CONTAPE ** FICHE/FRAME BREAK *****
CONTAPESYM
CONTAPE IDENT  VERSION 5.01 AUG, 1976
*
* LOAD AT 240B WITH SEMI-T
* SAVE FROM 3 TO SEMI-F START AT 240B (START)
*
*              VERSION 5.00 APR 1975
*              VERSION 4.00 FEB 1973
*              VERSION 3.00 FEB 1973
*      MODIFICATIONS MADE BY GARY GERE
*              IF YOU DONT KNOW WHO I AM, I WONT BORE YOU WITH DETAILS
*
*              VERSION 2.11 OCT 1970
*      MODIFICATIONS MADE BY JIM FAULKNER
*                              AT 1001 WATERTOWN ST.
*                              WEST NEWTON MA.
*
*      1.      PUT IN THE SUPPRESS COMMAND TO PREVENT THE
*              X-ON AND X-OFF CHARACTERS FROM BEING TRANSMITTED
*              (SUPRESS MAY NOT BE REVERSED -- ONCE ON ALWAYS
*              ON UNTIL THE PROGRAM IS RELOADED FROM EXEC)
*
*              VERSION 2.01 SEPTEMBER 1970
*      MODIFICATION MADE BY JIM FAULKNER
*                              AT 1001 WATERTOWN ST.
*                              WEST NEWTON MA.
*
*      1.      FIXED TO ALLOW GREATER THAN 20000B CHARACTERS
*              TO BE PUNCHED (SKE =17777B CHANGED TO SKE =57777B)
*
*
*              VERSION 2 SEPT 1970
*      MODIFICATIONS BY JIM FAULKNER
*                              AT 1001 WATERTOWN ST.
*                              WEST NEWTON MA.
*
*      1.      CONVERTED TO NARP RATHER THAN ARPAS(SUBTITUTE
*              '3*' FOR '(R)' AND 'OPD 103B5,1,1' BECOMES OPD 103B5,2)
*      2.      CHANGE TO CONSIDER 137B JUST LIKE ANY OTHER CHAR 
*              EVEN IF IT IS IN THE LAST WORD
*              OF FILE
*
*****
*
* THESE POINTERS ARE TO THE PAGE BUFFER FOR :STOCHR: AND :STOINI:
* THEY EXPECT BUFFER IS PAGE 4 [20000B].  CHANGE WITH CAUTION
*
STOBOT  EQU    20000B          BOTTOM [1ST WORD] OF BUFFER
STOTOP  EQU    23777B          TOP [LAST WORD] OF BUFFER
*
*****
*
* MACROS TO TOGGLE XON-XOFF FLAGS
* CURRENT IMPLEMENTATION: KLUDGE: BRS 172 SENDS A '314' TO TURN
* XON/XOFF OFF AND A '315' TO TURN XON/XOFF ON.
XONON  MACRO
       LDA     =315B           CODE TO TURN XON/XOFF ON
       LDX     =-1             ON COMMAND PORT
       BRS     172             SEND THE INFORMATION DOWN
       NOP     0               IGNORE NOSKIP RETURN
       ENDM

XONOFF MACRO
       LDA     =314B           CODE TO TURN XON/XOFF OFF
       LDX     =-1             ON COMMAND PORT
       BRS     172             SEND THE INFORMATION DOWN
       NOP     0               IGNORE NOSKIP RETURN
       ENDM


PRQ     OPD    103B5,2         DDEFINE POP TO PRINT MESSAGE

* STARTING ADDRESS
* THIS SHOULD BE AT 240B
START   BRU    *+2
        BRS    10              IN CASE OF CONTINUE ATTEMPT
        STA    COMFL           STORE COMMAND FILE NO.
        STA    COMFL1
        CLB
        SKE    =0
        LDB    =-1
        STB    CMFLG           0 IF PROG CALLED FROM TEL, -1 IF FROM COM FILE
        LDA    BPR             BRU PRQPOP IS IN BPR
        STA    103B
RESET   CLA
        STA    ERFLG           USED IN ROUTINE "ERR"
PRCHK   TCO    =155B
        TCO    =155B
        SKN    CMFLG
        BRU    GLTCH
        BRU    IN1             DO NOT PRINT GLITCH IF PROG CALLED FROM COM FILE
GLTCH   TCO    =32B            PRINT COLON
IN1     CIO    COMFL
        SKE    =155B           IF CR ONLY, PRINT COLON AGAIN
        BRU    IN11
        TCO    =155B
        BRU    PRCHK
IN11    SKE    =137B           HIT END OF COM FILE BEFORE QUIT
        BRU    IN2
        LDA    COMFL
        BRS    20              CLOSE COM FILE
        CLA
        STA    COMFL           RESET TO TTY "MODE"
        STA    CMFLG
        BRU    PRCHK
IN2     LRSH   8
        CIO    COMFL
        SKE    =155B
        BRU    *+2
        BRU    CHK1            1 CHAR. SEE IF IT IS Q OR ?
        LRSH   8
        CIO    COMFL
        SKE    =155B
        BRU    *+2
        BRU    ERR             2 CHARS
        LRSH   8
IN4     CIO    COMFL
        SKE    =155B
        BRU    IN4             WAIT FOR CR
        LDX    =CTBL-CTBLND
        CBA    MOVE            COMMAND INTO 'A' REGISTER
        SKE    CTBLND,2        SEARCH FOR COMMAND
        BRX    *-1
        BRU*   BTBLND,2        FALL THRU BRX MEANS COMMAND NOT FOUND
CHK1    CLA
        LSH    8
        SKE    =61B            (Q)
        BRU    *+2
        BRS    10              QUIT
        SKE    =37B            (QUESTION MARK)
        BRU    ERR             NOT Q OR ?
        BRU    HEL
CAP     PRQ    MSG1
        BRU    RESET
INS     PRQ    MSG2
        BRU    RESET
VER     PRQ    MSG3
        BRU    RESET
CHA     PRQ    MSG4
        BRU    RESET
CRE     PRQ    MSG5
        BRU    RESET
QUI     BRS    10
HEL     PRQ    MSG6
        BRU    RESET
*                              FOR VER 2.11 (SUPPRESS) (JJF)
SUP     MIN    CLENRD          SET CLEAN READ FLAG TO ONE (WAS 0)
        BRU    RESET           AND GET NEXT COMMAND
*
*                              END OF INSERT FOR  2.11
*
RUN     CLA
        STA    CMFLG1          (LATER SET IF FILE NAME INPUT FROM COM FILE)
        SKN    CMFLG           SKIP IF PROG CALLED FROM COM FILE
        BRU    ASK1
        CIO    COMFL           READ "COM" OR "TEL" FROM COM FILE (ALSO ALLOW "T")
        BRM    SPCHK
        SKE    =137B
        BRU    *+2
        BRU    ERR1            RUN WAS LAST ENTRY IN COM FILE
        SKE    =155B
        BRU    *+2
        BRU    ERR1            CR ONLY
        LRSH   8
        CIO    COMFL           2ND CHAR
        BRM    SPCHK
        SKE    =155B
        BRU    RDCM0
        CLA
        LSH    8
        SKE    =64B            (T)
        BRU    ERR1
        BRU    INTEL
RDCM0   LRSH   8
        CIO    COMFL           3RD CHAR
        BRM    SPCHK
        SKE    =155B
        BRU    *+2
        BRU    ERR1
        LRSH   8
        CIO    COMFL
        SKE    =155B
        BRU    *-2             WAIT FOR CR
        CBA
        SKE    COM
        BRU    RDCM2
        LDA    =-1
        STA    CMFLG1          SET CMFLG1 IF FILE NAME INPUT FROM COM FILE
        BRU    RUN1
RDCM2   SKE    TEL
        BRU    ERR1
INTEL   CLA
        STA    COMFL           WILL LATER RESET USING COMFL1
ASK1    PRQ    MSG7            REQUEST INPUT SOURCE
RUN1    LDA    COMFL
        BRS    62              OPEN FILE FOR INPUT
        BRU    ERR2            COULDNT OPEN FILE
        SKE    =0              SKIP IF INPUT FILE IS TEL
        BRU    PNCHK
        LDA    =-1
        STA    RDFLG           SET RDFLG IF INPUT FROM TEL
        BRU    OPEND
PNCHK   XAB    FILE            TYPE INTO A TO CHECK IT, FILE NO. INTO B
        SKE    =3
        BRU    ERR4            FILE NOT SYMBOLIC
        STB    INFL
        CXA    FILE            SIZE IN CHARS
*                              TEST AND REDUCE IF GT 2B4*3-1
*                              THIS FIX MADE IN VERSION 2.01 (JJF)
        SKG    =57777B
        BRU    *+3
        SUB    =2B4
        BRU    *-3
        STA    INLBSZ          FILE SIZE MOD 2B4 (4 PAGES)
        CLA
        STA    RDFLG
OPEND   CIO    COMFL           GET INPUT FILE TERMINATOR OUT OF INPUT BUFFER
        SKN    CMFLG1          FN INPUT FROM COM FILE?
ASK2    PRQ    MSG8            REQUESTS OUTPUT FILE
        LDA    COMFL
        LDX    =3
        BRS    63              OPEN FILE FOR OUTPUT
        BRU    ERR5            CANNOT OPEN OUTPUT FILE
        SKE    =1              FILE NUMBER
        BRU    RDCHK
        SKN    RDFLG           NEG. IF INPUT FROM TEL
        BRU    OPEND1          NO ERROR. FILE IN, FILE OUT.
        BRU    ERR3            TEL IN, TEL OUT
RDCHK   SKN    RDFLG
        BRU    ERR3            FILE IN, FILE OUT
        STA    OUTFL           NO ERROR. TEL IN, FILE OUT.
*FINISHED OPENING INPUT AND OUTPUT SOURCES AND CHECKING FOR ERRORS.
*NOW ASK FOR TABLE FILE NAME.
OPEND1  LDA    COMFL1
        STA    COMFL
        CLA
        STA    OPTFLG          SET LATER IF LF OPTION AFTER FN IS TAKEN
        SKN    CMFLG           SKIP IF PROGRAM CALLED FROM COM FILE
ASK3    PRQ    MSG9            REQUESTS NAME OF TABLE FILE
*USE STRING PTRS & CHECK TERMINATOR (CAR. RETURN OR LINE FEED?).
        LDA    FPTR            ALWAYS 3*FN-1. WCI INCREMENTS END PTR
        STA    FPTR+1
*LEADING CHARACTER INPUT:
        CIO    COMFL
        BRM    SPCHK           IGNORE LEADING SPACES
        SKE    =155B
        BRU    *+2
        BRU    OPTBL           WILL YIELD ERROR MESSAGE
        SKE    =152B
        BRU    *+2
        BRU    OPTBL           WILL YIELD ERROR MESSAGE
        SKE    =137B
        BRU    *+2
        BRU    ERR11           INSUFFICIENT INFO IN COMMAND FILE
*NON-LEADING CHARACTER INPUT & STORE
FNSTOR  WCI    FPTR
        CIO    COMFL
        SKE    =155B
        BRU    *+2
        BRU    OPTBL
        SKE    =152B
        BRU    FNSTOR
*SET FLAG. BEFORE ASKING OPTION QUESTION, SEE IF TABLE FILE CAN
*BE OPENED.
        LDA    =-1
        STA    OPTFLG
OPTBL   LDP    FPTR
        BRS    64              OPEN FILE FOR INPUT
        BRU    ERR6            CANNOT OPEN TABLE FILE
        XAB    MOVE            FILE TYPE TO A TO CHECK IT, MOVE FILE NO. TO B
        SKE    =3
        BRU    ERR7            TABLE FILE NOT SYMBOLIC
        STB    TBFL
        STX    TBFLSZ
*NOW ASK OPTION QUESTION IF LINE FEED WAS TYPED AFTER TABLE FILE NAME
        SKN    OPTFLG          SKIP IF LF TERMINATOR
        BRU    RDTBL
        SKN    RDFLG           SKIP IF INPUT FROM TEL
        BRU    OPTBL1
        SKN    CMFLG
        PRQ    MSG91           DO YOU WANT TO CONVERT RUBOUTS?
        BRU    ANSCHK
OPTBL1  SKN    CMFLG
        PRQ    MSG92           WANT TO CONVERT MULT BLANK CHARACTER?
ANSCHK  BRM    ANSRD           SKIP IF YES REPLY
        MIN    OPTFLG          ANSWER WAS NO. UNSET FLAG.
*READ IN CONTENTS OF TABLE FILE
RDTBL   LDA    =3B4            LIMIT OF TABLE FILE LENGTH
        LDX    =ITBL
        BIO    TBFL
        NOP
        LDA    BIPTR
        STA    IPTR            INITIALIZE BEGINNING STRING PTR
        ADD    TBFLSZ
        STA    IPTR+1
*ZERO OUT TBL
        CLA
        LDX    =-256
        STA    TBL+256,2
        BRX    *-1
*EXTRACT AND STORE ENTRIES FROM TABLE FILE INPUT
        LDA    =-1
        STA    TFLG            INIT TO "ENTRY NOT WAITING TO BE STORED"
        CLA
        STA    CNT             NO. OF ENTRIES STORED
        LDA    =TBL-1
        STA    PTR
NXNUM   CLA
        STA    HOLD
        LDX    =-3
NXCH    GCI    IPTR            INCREMENTS BEGINNING PTR
        BRU    END             HERE IF NO 137'S IN LAST WD READ
*CHECK FOR 137'S IN CASE FILE WAS CREATED INCORRECTLY AND FILE SIZE
*INCLUDES 137'S
        SKE    =137B
        BRU    *+2
        BRU    END
        SKE    =135B
        BRU    NXCH1
        GCI    IPTR
        NOP
        BRU    TRMCH
NXCH1   SKG    =31B
        SKG    =17B
        BRU    TRMCH
        SUB    =20B
        XMA    HOLD
        CLB
        STB    TFLG
        LSH    3
        ADM    HOLD
        BRX    NXCH
        BRU    STORE1
TRMCH   SKN    TFLG            SKIP IF ENTRY NOT WAITING TO BE STORED (MULT TERM CHAR)
        BRU    *+2
        BRU    NXCH
STORE1  BRM    STCNT
        BRU    PRMSG           HERE IF EXCEEDED MAX. TABLE LENGTH
        LDA    =-1             HERE IF STORED ENTRY (TABLE LENGTH OK)
        STA    TFLG
        BRU    NXNUM
END     SKN    TFLG
        BRU    *+2
        BRU    CHK
        BRM    STCNT           SKIP IF ENTRY IS STORED (TABLE LENGTH OK)
PRMSG   PRQ    ERMS12          TABLE LENGTH EXCEEDS MAX. LENGTH, ONLY 1ST 256 READ
*FINISHED SETTING UP TABLE FILE ENTRIES. BRANCH TO PUNCH OR READ ROUTINE
CHK     SKN    RDFLG
        BRU    PUNCH
*INIT THE READING TABLE
        BRM    STOINI
*READ TAPE INPUT AND SET UP STRING PTRS
        LDA    =ITBL-1
        STA    IPTR
        PRQ    MSG10           TURN ON READER
        LDX    =-1
        LDA    =40000400B
        BRS    12              SET 8 LEVEL INPUT
       XONON                   ;* ENABLE XON/XOFF
        LDX    =-1
        BRS    13              SKIP IF INPUT BUFFER EMPTY
        BRU    *+2
        BRU    *-2
BGNRD   CLB
        LDA    =2
        STA    DIFF
        BRM    RDSUB
        LSH    16
        STA    HOLD
        CLA
        STA    DIFF
        BRM    RDSUB
        LSH    8
        ADM    HOLD
        LDA    =1
        STA    DIFF
        BRM    RDSUB
        ADD    HOLD
        MIN    IPTR
*      STA* IPTR
        BRM    STOCHR          STORE A CHARACTER AWAY
        BRU    BGNRD
ENDRD   LDX    =-1
        LDA    =2
        BRS    12              TERMINATE 8 LEVEL INPUT
        LDA    DIFF
        SKE    =2              IS 2 IF WE FILLED (& STORED) LAST WORD
        BRU    *+2
        BRU    ENDRD1
        LDA    HOLD
        MIN    IPTR
*      STA* IPTR  STORE LAST WORD
        BRM    STOCHR
ENDRD1  BRM    STOFIR
*BEGIN CONVERSION PROCESS
        CLA
        STA    CNT1            NO. OF CHARACTERS WRITTEN
        LDA    BOPTR
        STA    OPTR            INIT BEGINNING PTR
CONV    LDA    BOPTR
        STA    OPTR+1          REINIT END PTR
        CLA
        STA    CNT
CONV1   BRM    STOREC
        BRU    COUNT
        CAX
        LDA    TBL,2
        SKE    =400B
        BRU    *+2
        BRU    CONV1
        WCI    OPTR
        MIN    CNT             NO OF CHARS STORED IN OTBL
        LDA    CNT
        SKE    =1400B
        BRU    CONV1
        LDA    =256
        LDX    =OTBL
        BIO    OUTFL
        NOP
        MIN    CNT1            NO OF FULL BLOCKS WRITTEN
        BRU    CONV
*CALCULATE NO. OF CHARS. WRITTEN
COUNT   LDA    CNT1            NO. OF FULL BLOCKS WRITTEN
        MUL    =1400B
        LSH    23
        ADD    CNT
        STA    CNT1            TOTAL NO. OF CHARS. WRITTEN
*WRITE OUT CONVERTED CHARS REMAINING IN OTBL.
        LDA    OPTR+1          LOC OF LAST CONV CHAR WRITTEN IN OTBL
        RSH    23
        DIV    =3
        STB    HOLD
        SUB    =OTBL           BIO UP TO WD BEFORE LAST WD WRITTEN INTO OTBL
        LDX    =OTBL
        BIO    OUTFL
        NOP
        COPY   AX,A            ADDR OF LAST WD WRITTEN INTO OTBL (HAS 1,2 OR 3 CHARS IN IT)
        LDB    0,2
        LSH    8
        CIO    OUTFL
        SKR    HOLD            0 IF 1 CHAR LEFT, 1 IF 2, 2 IF 3 CHARS LEFT
        BRU    *-3
       TCO     =155B
        LDA    CNT1
        LDB    =10
        LDX    =1
        BRS    36              PRINT CHAR. COUNT
        BRS    147
       PRQ     MSG11
        BRU    RESET
*PUNCH ROUTINE
* VERSION 4.00 GARY GERE REMOVED THE PAGER CODE
* FOR READING DISK FILE.  NOW GOES DIRECTOY TO TAPE
* THIS IS FASTER AND WORKS.
PUNCH  XONOFF                  ;* DISABLE XON/XOFF
        LDP    BTPTR
        STP    TPTR            (RE)INITIALIZE TITLE PTR
        SKN    CMFLG
        PRQ    MSG12           REQUEST TITLE
INTL    CIO    COMFL
        SKG    =77B
        BRU    TSTORE
        SKE    =155B
        BRU    *+2
        BRU    ENTL            TERMINATES ON CR
        SKE    =137B           END OF COM FILE HIT BEFORE TITLE
        BRU    INTL            IGNORES OTHER CTRL CHARS
        BRU    ERR11
TSTORE  WCI    TPTR
        BRU    INTL
*PERFORM CONVERSION, STORE CONVERTED CHARACTERS
ENTL    CLA
        STA    TFLG            USED IN MULT. BLANK CHAR LOGIC
        STA    CNT1
        LDA    PTR6            1 CHAR BEFORE PAGE 6
        STA    PTR6+1          REINIT END PTR (BEGINNING PTR IS CONSTANT)
        LDA    =RTBL-1
        STA    RPTR
*HERE TO TURN PUNCH ON..NO PAGER
        PRQ    MSG13           TURN ON PUNCH
        CIO    =0
        SKE    =155B
        BRU    *-2
*PUNCH RUBOUTS, TITLE (IF ANY), & MORE RUBOUTS
        LDX    =-1
        BRS    14              DISMISS UNTIL OUTPUT BUFFER EMPTY
        BRS    85              SET 8 LEVEL OUTPUT
        LDX    =-30
        BRM    LDR
        GCI    TPTR
        BRU    OUTND1          HERE IF NO TITLE SPECIFIED
OUTL    TCO    =0
        TCO    =0
        MUL    =3
        LSH    23
        ADD    =CHTB
        MUL    =3
        LSH    23
        SUB    =1
        STA    CPTR            SET BEGINNING PTR FOR CHARACTER
OUTL1   GCI    CPTR
        NOP    0               WON'T FALL THRU
        SKG    =177B           SKIP IF FINISHED PUNCHING CHARACTER
        BRU    OUTL2
        GCI    TPTR
        BRU    OUTND           HERE WHEN FINISHED PUNCHING TITLE
        BRU    OUTL
OUTL2   CIO    =1
        BRU    OUTL1
OUTND   TCO    =0
        TCO    =0
OUTND1  LDX    =-50
        BRM    LDR
*PUNCH CONVERTED CHARACTERS
OUTNX  CIO     INFL
       SKP     INFL            SKIP IF STILL GOOD FILE NUMBER
       BRU     ENDP            END OF PUNCH
       BRM     STORE           WRITE THE CHARACTER OUT
        BRU    OUTNX
*PUNCH TRAILER
ENDP    LDX    =-60
        BRM    LDR
        BRS    147
        LDX    =-1
        BRS    14              DISMISS UNTIL OUTPUT BUFFER EMPTY
        BRS    86              CLEAR 8 LEVEL OUTPUT
        BRU    RESET
*
* VER. 3.00 FIX-UP BY GARY GERE
* THIS ROUTINE WILL ACCEPT CHARACTERS TO BE STORED INTO A BUFFER
* THE SIZE OF THE BUFFER IS THE NUMBER OF AVAILABLE PAGES ON THE
* SYSTEM.  THIS IS DONE BY PAGEING THE BUFFER OUT ONTO THE RAD.
* CALL WITH A BRM.  IF THE BUFFER BECOMES FULL, THE LUSER WILL
* HEAR ABOUT IT BUT QUICK [DOES MESSAGE AND BRU ENDRD]
*
STOCHR  ZRO    *               ENRTY LOCATION
* P.S. TO INITIALIZE THIS ROUTINE, A BRM STOINI MUST BE DONE
        STA*   STOPTR          STORE THE CHARACTER INTO THE BUFFER
        MIN    STOPTR          INCREMENT THE TOP OF THE BUFFER PTR
        LDA    STOPTR          GET THE POINTER
        SKG    =STOTOP         IS THE NEW POINTER TOO LARGE?
        BRR    STOCHR          NO ITS OKAY - RETURN
        BRS    70              GET THE NUMBER OF FREE PAGES LEFT
        SKG    =0              IS THERE ANY AT ALL?
        BRU    STOFCK          NO -- ***LUSER***
* ALSO, THIS ROUTINE ASSUMES PAGE 4 [20000B] TO BE THE BUFFER PAGE
        BRS    43         IT'S OKAY, GET A NEW BUFFER IN THERE
        STB*   STOHLD          SAVE B RELABELLING
        MIN    STOHLD          INCREMENT POINTER COUNTER
        XAB
        ETR    =00777777B      REMOVE PAGE FROM ACTIVE RELABELLING
        XAB
        BRS    44              OUT THE PAGE GOES TO THE RAD
        LDA    =STOBOT
        STA    STOPTR          RESET STORE POINTER
        BRR    STOCHR          RETURN
* HERE WHEN USER BECOMES A LUSER
STOFCK  PRQ    YURFCK          TELL USER WHAT HAPPENED
        LDA    =2
        STA    DIFF            SO WE DONT CALL STOCHR AGAIN
        LDA    CLENRD
        SKG    =0
        TCO    =163B           TURN OFF READER IF POSSIBLE
        LDX    =-1
        BRS    11
        CLA
        BRS    81
        BRS    13              SKIP IF IMPUT EMPTY
        BRU    *-4
        BRU    ENDRD           AND IT'S ALL OVER

* ROUTINE CALLED WHEN READING IS COMPLETED
* IT STOPPS THE BUFFER
*
STOCMP  ZRO    *               ENTRY POINT
        LDA    STOPTR
        STA    STOLSS          SAVE COMPLETED READIN POINTER
        LDA    STOHLD
        STA    STOLAS          SAVE THE FINAL BYTE POINTER 
        BRR    STOCMP          AND RETURN

* ROUTINE TO RESET BUFFER TO INITIAL STATE AND RELABELL IN FIRST
* PAGE.............
*
STOFIR  ZRO    *               ENTRY POINT
        BRM    STOCMP
        BRS    43
        STB*   STOHLD          SAVE FINAL POINTER
        LDB    =STOREL
        STB    STOHLD
        BRS    43
        LDB*   STOHLD
        BRS    44
        LDA    =STOBOT
        STA    STOPTR
        LDA    STOLAS
        SKE    STOHLD          ARE WE ON THE LAST BUFFER ?
        BRU    STOR11          NO -- FULL BUFFER POINTER
        LDA    STOLSS
        MUL    =3
       LSH     23
       XMA     DIFF
       SKE     =2              IF 2 THEN NO EXTRA CHARACTERS
       ADM     DIFF            THERE WAS AN OFFSET, SO ADD IT
       LDB     DIFF            AND LOAD POINTER
        BRU    STOR12
STOR11  LDB    =3*STOTOP+2
STOR12  LDA    =3*STOBOT-1
        STP    IPTR            RETRIEVAL POINTERS
        BRR    STOFIR

* ROUTINE STOREC
* RETRIEVES ONE CHARACTER FROM BUFFER, SKIP RETURN IF OKAY,
* NOSKIP RETURN IF END OF JOB
*
STOREC  ZRO    *
        GCI    IPTR            GET NEXT CHARACTER (WE HOPE)
        BRU    STOERR          EOS, SEE IF IT'S THE END
        MIN    STOREC          SKIP RETURN
        BRR    STOREC          RETURN
STOERR  LDA    =STOBOT
        BRS    4               KILL THAT PAGE
        LDA    STOLAS
        SNE    STOHLD          IF NOSKIP (=) THEN LAST BUFFER
        BRR    STOREC          NOSKIP RETURN
        MIN    STOHLD
        BRS    43
        LDB*   STOHLD          GET NEXT BUFFER
        BRS    44              RELABEL IT IN
        LDA    STOLAS
        SKE    STOHLD
        BRU    STO13
        LDA    STOLSS
        MUL    =3
       LSH     23
       XMA     DIFF
       SKE     =2
       ADM     DIFF
       LDB     DIFF
        BRU    STO14
STO13   LDB    =3*STOTOP+2
STO14   LDA    =3*STOBOT-1
        STP    IPTR
       GCI     IPTR            WE HAD BETTER GET A CHAR FROM NEW BUFF
*      CLC 8/25/76 IF THIS FAILS LETS JUST PUNT
       0
        MIN    STOREC
        BRR    STOREC

* ROUTINE STOINI
* INIT'S PROGRAM STOCHR ROUTINE
*
STOINI  ZRO    *               ENTRY POINT
        LDA    =STOBOT
        STA    STOPTR          INIT STORE CHARACTER POINTER
        LDA    =STOREL
        STA    STOHLD          RESET RELABELLING POINTER
        BRR    STOINI          RETURN

*POP TO PRINT A MESSAGE
PRQPOP  EAX*   0
        CXA
        ETR    =37777B
        LDB    =-1
        LDX    =1
        BRS    34
        BRR    0
*SUBROUTINE TO IGNORE SPACES. MUST BE GIVEN IMMEDIATELY AFTER CIO.
*RETURNS AS USUAL IF CHAR ISN'T SPACE. RETURNS TO INSTRUCTION RIGHT
*BEFORE CALL (CIO) IF CHAR IS SPACE)
SPCHK   NOP
        SKE    =0
        BRU    *+2
        BRU    SUB
        SKE    =135B
        BRR    SPCHK
        CIO    COMFL
SUB     LDA    SPCHK
        SUB    =2              CHANGES RETURN ADR FROM 1 PAST CALL TO 1 BEFORE CALL
        STA    SPCHK
        BRR    SPCHK
*SUBROUTINE TO READ REPLY TO RUBOUT/MULT BLANK OPTION QUESTION.
*SKIP IF YES REPLY, NO SKIP IF NO. SAME ERROR MESSAGE EXCEPT IN COM FILE
*CASE, WHEN RDFLG IS CHECKED TO DETECT PROPER MESSAGE.
ANSRD   NOP
ANSRD1  CIO    COMFL           READ 1ST CHAR
        BRM    SPCHK
        SKE    =155B
        BRU    *+2
        BRU    ERR8
        SKE    =137B           END OF COM FILE HIT BEFORE REPLY
        BRU    *+2
        BRU    ERR81
        LRSH   8
        CIO    COMFL           READ 2ND CHAR
        BRM    SPCHK
        SKE    =155B
        BRU    RNXT
        CLA
        LSH    8
        SKE    =71B            (Y)
        BRU    *+3
        MIN    ANSRD
        BRR    ANSRD
        SKE    =56B            (N)
        BRU    ERR8            (1 CHAR, NOT Y OR N)
        BRR    ANSRD
RNXT    LRSH   8
        CIO    COMFL           READ 3RD CHAR
        BRM    SPCHK
        SKE    =155B
        BRU    RNXT1
        CLA
        LSH    16
        SKE    NO
        BRU    ERR8            (2 CHARS, NOT NO)
        BRR    ANSRD
RNXT1   LRSH   8
        CIO    COMFL           READ 4TH CHAR
        SKE    =155B
        BRU    ERR8            (MORE THAN 3 CHARS)
        CBA
        SKE    YES
        BRU    ERR8            (3 CHARS, NOT YES)
        MIN    ANSRD
        BRR    ANSRD
*SUBROUTINE TO CHECK TABLE LENGTH & STORE ENTRY IF TABLE LENGTH OK
*(MAX.=256 ENTRIES) IF TABLE LENGTH OK, WILL SKIP RETURN. IF TABLE
*LENGTH EXCEEDS MAX., NO SKIP RETURN
STCNT   NOP
        LDA    CNT             NO. OF ENTRIES ALREADY STORED
        SKE    =256
        BRU    *+2
        BRR    STCNT           NO SKIP RETURN IF TABLE EXCEEDS MAX. LENGTH
        MIN    CNT
        LDA    HOLD
        MIN    PTR
        STA*   PTR
        MIN    STCNT
        BRR    STCNT           SKIP RETURN IF TABLE LENGTH OK
*SUBROUTINE TO SEE IF INPUT BUFFER IS EMPTY AND DISMISS FOR 3 SECS IF
*IT IS. IF EMPTY FOR 6 SECS, STOPS TAPE READING. OTHERWISE READS A
*CHARACTER (IGNORES RUBOUTS IF REQUIRED)
RDSUB   NOP
        LDX    =-1
MTCHK   BRS    13              SKIP IF INPUT BUFFER EMPTY
        BRU    MTCHK1          INPUT BUFFER NOT EMPTY
        LDA    TFLG
        SKE    =2              WILL BE 2 AFTER 6 SECS OF NO INPUT
       BRU     *+2
        BRU    MTCHK0
        MIN    TFLG
*                              INSERT FOR 2.11(SUPPRESS) (JJF)
        LDA    CLENRD          PICK UP THE CLEAN READ FLAG
        SKG    =0              SKIP THE X-ON IF FLAG IS SET
*                                      END OF 2.11 INSERT
        TCO    =161B           CTRL Q (TURN ON RDR FOR SOME TTY'S)
*
*
        LDA    =3000           WAIT 3000 MILLISECONDS
        BRS    81              DISMISS (FOR 3 SECS)
       BRU     MTCHK
MTCHK0 LDA     CLENRD
       SKG     =0
       TCO     =163B
       BRU     ENDRD
MTCHK1  CLA
        STA    TFLG
        CIO    =0
        SKN    OPTFLG          SKIP IF CONVERT RUBOUTS
        BRU    *+2             HERE IF IGNORE RUBOUTS
        BRR    RDSUB           RETURN & STORE CHAR READ
        SKE    =377B
        BRU    *+2
        BRU    MTCHK
        SKE    =177B
        BRR    RDSUB
        BRU    MTCHK
*SUBROUTINE TO PUNCH LEADER/TRAILER. NEGATIVE OF NUMBER OF RUBOUTS
*TO BE PUNCHED MUST BE IN X REGISTER
LDR     NOP
        TCO    =377B
        BRX    *-1
        BRR    LDR
*SUBROUTINE TO TAKE CHARACTER IN A REGISTER, CONVERT IT, AND WRITE
*IT OUT TO THE TELETYPE.
STORE   NOP
        SKN    OPTFLG
        BRU    MBLNK
SRCH    CLX
SRCH1   SKE    TBL,2
        BRU    *+2
        BRU    MTCH
        XXA
        SKE    CNT
        BRU    *+3
        STX    HOLD
        BRU    ERR9
        ADD    =1
        XXA
        BRU    SRCH1
MTCH    MIN    CNT1
        CXA
       CIO     =1              WRITE THE CHARACTER TO TELETYPE
        BRR    STORE
MBLNK   SKN    TFLG
        BRU    MBCHK
        MIN    TFLG
        BRU    MBLNK2
MBCHK   SKE    =135B
        BRU    SRCH
        GCI    OPTR
        BRU    SET
MBLNK2  SUB    =1
        STA    BLNKNO
        COPY   A,X             CLEAR A AND X
MBLNK3  SKE    TBL,2
        BRU    *+2
        BRU    MTCH1
        XXA
        SKE    CNT
        BRU    *+3
        STX    HOLD
        BRU    ERR9
        ADD    =1
        XXA
        BRU    MBLNK3
MTCH1   MIN    CNT1
        CXA
       CIO     =1              WRITE THE CHARACTER TO TELETYPE
        SKR    BLNKNO
        BRU    MTCH1
        BRR    STORE
SET     LDA    =-1
        STA    TFLG
        BRR    STORE
*SUBROUTINE USED IN ERR2 TO ERR5 (INPUT FROM/OUTPUT TO ERRORS)
*CLOSES ALL FILES & RETURNS TO EXEC IF FN INPUT FROM COMFL.
*CLEARS INPUT BUFFER AND RETURNS (BRR) IF FN INPUT FROM COMFL.
ERCHK   NOP
        SKN    CMFLG1
        BRU    *+3
        BRS    17
        BRS    10
        LDX    =-1
        BRS    11
        BRR    ERCHK
*ERROR ROUTINES AND MESSAGES:
*ILLEGAL COMMAND ENTERED AFTER COLON
ERR     SKN    CMFLG
        BRU    ERR0
        PRQ    ERMSG1
        BRS    17              CLOSES ALL FILES, INCL. COM FILE
        BRS    10
ERR0    LDA    ERFLG
        SKE    =0
        BRU    ERR01
        MIN    ERFLG           INDICATE NEXT CONSEC ERROR SHOULD PRINT COM LIST
        PRQ    ERMSG           PRINT ? AND CR
        BRU    GLTCH
ERR01   PRQ    ERMSG0
        BRU    RESET
*"COM" OR "TEL" NOT IN COMMAND FILE
ERR1    PRQ    ERMSG2
        BRS    17
        BRS    10
*END OF COM FILE HIT PREMATURELY. INSUFFICIENT  INFO IN COM FILE.
ERR11   PRQ    ERM11
        BRS    17
        BRS    10
*CANNOT OPEN INPUT FILE
ERR2    PRQ    ERMSG3
        BRM    ERCHK
        BRU    ASK1
*INCORRECT COMBINATION ERROR
ERR3    PRQ    ERMSG4
ERR31   BRM    ERCHK
        BRS    147             CLOSE FILE(S) EXCEPT COMMAND FILE
        BRU    ASK1
*FILE NOT SYMBOLIC
ERR4    PRQ    ERMSG5
        BRU    ERR31
*CANNOT OPEN OUTPUT FILE
ERR5    PRQ    ERMSG6
        BRM    ERCHK
        BRU    ASK2
*CANNOT OPEN TABLE FILE
ERR6    PRQ    ERMSG7
ERR61   SKN    CMFLG
        BRU    ERR62
        BRS    17
        BRS    10
ERR62   LDX    =-1
        BRS    11
        BRU    ASK3
*TABLE FILE NOT SYMBOLIC
ERR7    PRQ    ERMSG5
        BRU    ERR61
*INCORRECT REPLY TO RUBOUT/MULT BLANK QUESTION
ERR8    SKN    CMFLG
        BRU    ERR82
ERR81   PRQ    ERMSG9          ERR0R. TYPE YES OR NO IN REPLY TO:
        SKN    RDFLG
        BRU    *+3
        PRQ    MSG91           RUBOUT QUESTION
        BRU    *+2
        PRQ    MSG92           MULT BLANK QUESTION
        BRS    17
        BRS    10
ERR82   LDX    =-1
        BRS    11
        PRQ    ERMSG8
        BRU    ANSRD1
*CODE NOT FOUND IN TABLE
ERR9    PRQ    ERMS10          ERROR. CODE...
        LDA    HOLD
        LDB    =8
        LDX    =1
        BRS    36
        PRQ    ERMS11          CANNOT BE FOUND IN TABLE.
        SKN    CMFLG
        BRU    *+3
        BRS    17
        BRS    10
        BRS    147
        BRU    RESET
YURFCK  ASC    '$ERROR: PROGRAM READ TABLE OVERFLOW. READING STOPPED.$/'
ERMSG   ASC    '$ ?$$$/'
ERMSG0  ASC    '$FOR ASSISTANCE, TYPE  HELP.$/'
ERMSG1  ASC    '$ILLEGAL COMMAND.$/'
ERM11   ASC    '$ERROR. INSUFFICIENT INFORMATION IN COMMAND FILE.$/'
ERMSG2  ASC    '$AFTER CALLING CONTAPE FROM A COMMAND FILE AND GIVING THE RUN COMMAND,'
        ASC    '$TYPE "COM" (FOLLOWED BY A CARRIAGE RETURN) IF THE "INPUT FROM"'
        ASC    '$AND "OUTPUT TO" REPLIES ARE IN THE COMMAND FILE, AND "T"'
        ASC    '$IF THEY ARE TO BE ENTERED FROM THE TERMINAL.$/'
ERMSG3  ASC    '$ERROR. CANNOT OPEN INPUT FILE.$/'
ERMSG4  ASC    '$ERROR. TO PUNCH TAPE, SPECIFY A FILE FOR INPUT AND T FOR OUTPUT.'
        ASC    '$TO READ TAPE, SPECIFY INPUT FROM T AND OUTPUT TO A FILE.$/'
ERMSG5  ASC    '$ERROR. FILE MUST BE SYMBOLIC.$/'
ERMSG6  ASC    '$ERROR. CANNOT OPEN OUTPUT FILE.$/'
ERMSG7  ASC    '$ERROR. CANNOT OPEN TABLE FILE.$/'
ERMSG8  ASC    '$ERROR. TYPE YES OR NO: /'
ERMSG9  ASC    '$ERROR. TYPE YES OR NO IN THE COMMAND FILE IN REPLY TO: $/'
ERMS10  ASC    '$ERROR. CODE /'
ERMS11  ASC    ' CANNOT BE FOUND IN TABLE.$/'
ERMS12  ASC    '$TABLE EXCEEDS MAXIMUM LENGTH. ONLY FIRST 256 ENTRIES HAVE BEEN READ.$/'
MSG1    ASC    '$3.5 MINUTES OF PRINTOUT'
        ASC    '$$THIS PROGRAM MAY BE USED TO PERFORM TAPE-TO-FILE CONVERSION OR FILE-TO-'
        ASC    '$TAPE CONVERSION, SPECIFIED BY A TABLE WHICH THE USER ENTERS FROM A'
        ASC    '$FILE.'
        ASC    '$$CONTAPE IS MORE FLEXIBLE FOR TAPE-TO-FILE CONVERSION; IT IS DESIGNED'
        ASC    '$MORE FOR THE USER WHO STARTS OUT WITH TAPE TO BE CONVERTED THAN'
        ASC    '$FOR THE USER WITH A FILE TO BE CONVERTED. (THE FILE-TO-TAPE CAPABILITY'
        ASC    '$IS IMPLEMENTED MAINLY SO THAT A FILE WRITTEN BY CONTAPE CAN BE PUNCHED'
        ASC    '$BACK OUT USING THE SAME TABLE.) CONSIDER THE FOLLOWING FEATURES OF'
        ASC    '$CONTAPE:'
        ASC    '$$            TAPE-TO-FILE                        FILE-TO-TAPE'
        ASC    '$             (READING)                           (PUNCHING)'
        ASC    '$$SEVERAL DIFFERENT TAPE CODES              SEVERAL DIFFERENT FILE CHAR-'
        ASC    '$CAN BE STORED AS THE SAME         BUT     ACTERS CANNOT BE PUNCHED AS'
        ASC    '$FILE CHARACTER.                           THE SAME TAPE CODE.'
        ASC    '$$ANY NUMBER OF DIFFERENT TAPE              NO FILE CHARACTERS CAN BE'
        ASC    '$CODES CAN BE IGNORED.             BUT     IGNORED.'
        ASC    '$$NO "ERROR CHECKING"                       "ERROR CHECKING" IS PERFORMED,'
        ASC    '$(SEE ADJACENT COLUMN)             BUT     SINCE PROGRAM EXECUTION TERM-'
        ASC    '$                                          INATES IF A FILE CHARACTER IS'
        ASC    '$                                          READ THAT IS NOT IN THE TABLE'
        ASC    '$                                          (NOTHING IS PUNCHED).'
        ASC    '$$SOME ADDITIONAL FEATURES ARE LISTED BELOW.'
        ASC    '$$DURING PUNCHING, A TITLE OF READABLE CHARACTERS MAY BE PUNCHED AT THE'
        ASC    '$BEGINNING OF THE TAPE. RUBOUTS ARE PUNCHED BEFORE THE TITLE (IF ANY),'
        ASC    '$AND BEFORE AND AFTER THE CONVERTED OUTPUT.'
        ASC    '$$DURING READING, THE PROGRAM TYPES A CONTROL Q OR CONTROL S EVERY 3'
        ASC    '$SECONDS TO FURTHER REGULATE THE TAPE READING ON THOSE TERMINALS WHICH'
        ASC    '$HAVE X ON AND X OFF ENABLED (WHERE CONTROL Q TURNS ON THE TAPE READER'
        ASC    '$AND CONTROL S TURNS IT OFF). ON TERMINALS WHICH DO NOT HAVE THIS'
        ASC    '$FEATURE, THE EMISSION OF CONTROL Q AND CONTROL S WILL HAVE ABSOLUTELY'
        ASC    '$NO EFFECT ON THE TAPE READING.$/'
MSG2    ASC    '$4.5 MINUTES OF PRINTOUT'
        ASC    '$$NOTE: THE INSTRUCTIONS LISTED BELOW ARE MINIMAL; MORE DETAILED'
        ASC    '$DOCUMENTATION MAY BE OBTAINED FROM YOUR TYMSHARE MARKETING'
        ASC    '$REPRESENTATIVE.'
        ASC    '$$THIS PROGRAM MAKES TWO REQUESTS INITIALLY:'
        ASC    '$$INPUT FROM'
        ASC    '$OUTPUT TO'
        ASC    '$$TO SPECIFY FILE-TO-TAPE CONVERSION, TYPE THE INPUT FILE NAME AFTER'
        ASC    '$"INPUT FROM", AND TYPE T (INDICATING THE TERMINAL) AFTER "OUTPUT TO".'
        ASC    '$$TO SPECIFY TAPE-TO-FILE CONVERSION, TYPE T AFTER "INPUT FROM", AND'
        ASC    '$TYPE THE OUTPUT FILE NAME AFTER "OUTPUT TO".'
        ASC    '$$THE PROGRAM NEXT REQUESTS THE TABLE FILE NAME.'
        ASC    '$$***WHEN FILE-TO-TAPE CONVERSION IS SPECIFIED:'
        ASC    '$$FOLLOW THE TABLE FILE NAME BY A CARRIAGE RETURN IF THE FILE CHARACTER'
        ASC    '$WHOSE CODE IS 135 OCTAL IS TO BE CONSIDERED A MULTIPLE BLANK'
        ASC    '$CHARACTER (THIS IS A CONVENTION OF THE TYMSHARE LANGUAGES).'
        ASC    '$IN SPECIAL CASES WHERE 135 SHOULD BE PROCESSED AS ANY ORDINARY DATA'
        ASC    '$CHARACTER, TYPE A LINE FEED AFTER THE TABLE FILE NAME. THE PROGRAM'
        ASC    '$WILL THEN ASK "DO YOU WANT TO CONVERT THE MULTIPLE BLANK CHARACTER?".'
        ASC    '$CONFIRM BY REPLYING WITH YES (OR Y) FOLLOWED BY A CARRIAGE RETURN.'
        ASC    '$NO (OR N) WOULD ABORT THE OPTION.'
        ASC    '$$THE TITLE IS THEN REQUESTED. REPLY WITH A CARRIAGE RETURN IF NO'
        ASC    '$TITLE IS DESIRED, OR TYPE THE TITLE FOLLOWED BY A CARRIAGE RETURN. IF'
        ASC    '$NECESSARY, A LINE FEED MAY BE TYPED TO CONTINUE THE TITLE ON THE NEXT'
        ASC    '$LINE.'
        ASC    '$$***WHEN TAPE-TO-FILE CONVERSION IS SPECIFIED:'
        ASC    '$$FOLLOW THE TABLE FILE NAME BY A CARRIAGE RETURN IF RUBOUTS (CODES'
        ASC    '$377 AND 177 OCTAL) ON THE TAPE ARE TO BE IGNORED. IN SPECIAL CASES'
        ASC    '$WHERE RUBOUTS SHOULD BE PROCESSED AS ANY ORDINARY DATA CHARACTERS,'
        ASC    '$TYPE A LINE FEED AFTER THE TABLE FILE NAME. THE PROGRAM WILL THEN ASK'
        ASC    '$"DO YOU WANT TO CONVERT RUBOUTS?". CONFIRM BY REPLYING WITH YES (OR Y)'
        ASC    '$FOLLOWED BY A CARRIAGE RETURN. NO (OR N) WOULD ABORT THE OPTION.'
        ASC    '$$THE PROGRAM WILL TELL YOU WHEN TO TURN ON THE TAPE READER. EITHER'
        ASC    '$TURN OFF THE READER WHEN THE RUBOUT TRAILER IS ENCOUNTERED OR,'
        ASC    '$IF YOU LET THE TAPE BE READ TO ITS END, BE SURE THERE ARE NO "JUNK"'
        ASC    '$CHARACTERS ON THE END (TRIM THE TAPE EVENLY ON ONE OF THE TRAILING '
        ASC    '$RUBOUTS). THE PROGRAM WILL STOP ACCEPTING TAPE INPUT AFTER THERE HAS'
        ASC    '$BEEN NO FURTHER INPUT FOR 6 SECONDS.'
        ASC    '$$***WHEN THE PROGRAM IS CALLED FROM A COMMAND FILE:'
        ASC    '$$THE "INPUT FROM" AND "OUTPUT TO" REPLIES MAY BE ENTERED FROM'
        ASC    '$THE TERMINAL OR FROM THE COMMAND FILE. (OTHER REPLIES, SUCH AS'
        ASC    '$TO THE TABLE FILE NAME REQUEST, ARE TAKEN FROM THE COMMAND FILE).'
        ASC    '$AFTER TYPING THE PROGRAM NAME AND THE RUN COMMAND, TYPE COM'
        ASC    '$(FOLLOWED BY A CARRIAGE RETURN) IN THE COMMAND FILE IF THE "INPUT'
        ASC    '$FROM" AND "OUTPUT TO" REPLIES WILL BE ENTERED IN THE COMMAND FILE;'
        ASC    '$TYPE T IF THEY ARE TO BE ENTERED FROM THE TERMINAL.$/'
MSG3    ASC    '$VERSION 5.00  MARCH, 1975$/'
MSG4    ASC    '$NO PREMIUM CHARGE$/'
MSG5    ASC    '$WRITTEN BY TYMSHARE$/'
MSG6    ASC    '$LEGAL COMMANDS:'
        ASC    '$$     HELP  (OR) ?   REPRINTS THIS LIST'
        ASC    '$     CAPABILITIES   DESCRIBES PROGRAM CAPABILITIES'
        ASC    '$     INSTRUCTIONS   HOW TO EXECUTE THE PROGRAM'
        ASC    '$     CREDITS        THOSE RESPONSIBLE FOR THIS PROGRAM'
        ASC    '$     CHARGES        ADDITIONAL COST (IF ANY)'
        ASC    '$     VERSION        LATEST UPDATE'
        ASC    '$     SUPPRESS       PREVENTS X-ON AND X-OFF'
        ASC    '$                    DURING READING'
        ASC    '$     RUN            BEGINS EXECUTION'
        ASC    '$     QUIT  (OR) Q   QUITS TO EXEC'
        ASC    '$$     ANY OF THESE COMMANDS MAY BE SHORTENED TO THE'
        ASC    '$     FIRST THREE LETTERS$/'
MSG7    ASC    '$INPUT FROM /'
MSG8    ASC    '$OUTPUT TO /'
MSG9    ASC    '$NAME OF TABLE FILE: /'
MSG91   ASC    'DO YOU WANT TO CONVERT RUBOUTS? /'
MSG92   ASC    'DO YOU WANT TO CONVERT THE MULTIPLE BLANK CHARACTER? /'
MSG10   ASC    '$TURN ON READER.$$/'
MSG11   ASC    ' CHARACTERS WRITTEN$/'
MSG12   ASC    '$TITLE: /'
MSG13   ASC    '$TURN ON PUNCH.'
        ASC    '$THEN TYPE CARRIAGE RETURN.$/'
CTBL    ASC    'PAC'
        ASC    'SNI'
        ASC    'REV'
        ASC    'AHC'
        ASC    'ERC'
        ASC    'IUQ'
        ASC    'LEH'
        ASC    'NUR'
        ASC    'PUS'           (SUPPRESS)
CTBLND  DATA   0
        DATA   CAP
        DATA   INS
        DATA   VER
        DATA   CHA
        DATA   CRE
        DATA   QUI
        DATA   HEL
        DATA   RUN
        DATA   SUP
BTBLND  DATA   ERR
COM     ASC    'MOC'
TEL     ASC    'LET'
NO      ASC    ' ON'
YES     ASC    'SEY'
CHTB    DATA   200B
        DATA   0B
        DATA   0B
        DATA   27700000B       !
        DATA   0B
        DATA   0B
        DATA   1600007B        "
        DATA   40000000B
        DATA   0B
        DATA   13016054B       #
        DATA   7406416B
        DATA   3300000B
        DATA   11021177B       $
        DATA   12411200B
        DATA   0B
        DATA   20020020B       %
        DATA   32661405B
        DATA   600600B
        DATA   14446505B       &
        DATA   12410050B
        DATA   20100000B
        DATA   1700000B        '
        DATA   0B
        DATA   0B
        DATA   7021101B        (
        DATA   40000000B
        DATA   0B
        DATA   20221034B       )
        DATA   40000000B
        DATA   0B
        DATA   22426030B       *
        DATA   37414054B
        DATA   22500000B
        DATA   2004074B        +
        DATA   2004200B
        DATA   0B
        DATA   24030200B       ,
        DATA   0B
        DATA   0B
        DATA   2004010B        -
        DATA   2004200B
        DATA   0B
        DATA   20100000B       .
        DATA   0B
        DATA   0B
        DATA   20020020B       /
        DATA   2000004B
        DATA   500000B
        DATA   17440501B       0
        DATA   20237200B
        DATA   0B
        DATA   20477500B       1
        DATA   40000000B
        DATA   0B
        DATA   30450521B       2
        DATA   22243200B
        DATA   0B
        DATA   10244515B       3
        DATA   22630600B
        DATA   0B
        DATA   2006012B        4
        DATA   37604200B
        DATA   0B
        DATA   13644511B       5
        DATA   22230600B
        DATA   0B
        DATA   17444511B       6
        DATA   22231200B
        DATA   0B
        DATA   260421B         7
        DATA   2202403B
        DATA   40000000B
        DATA   15444511B       8
        DATA   22244466B
        DATA   40000000B
        DATA   21444511B       9
        DATA   22244476B
        DATA   40000000B
        DATA   11100000B       :
        DATA   0B
        DATA   0B
        DATA   25032200B

        DATA   0B
        DATA   0B
        DATA   2010044B        <
        DATA   20500000B
        DATA   0B
        DATA   3006014B        =
        DATA   3006200B
        DATA   0B
        DATA   20422020B       >
        DATA   2100000B
        DATA   0B
        DATA   400531B         ?
        DATA   203200B
        DATA   0B
        DATA   17041131B       @
        DATA   25256521B
        DATA   23440200B
        DATA   37404411B       A
        DATA   2277200B
        DATA   0B
        DATA   37644511B       B
        DATA   22233200B
        DATA   0B
        DATA   17440501B       C
        DATA   20221200B
        DATA   0B
        DATA   37640501B       D
        DATA   20237200B
        DATA   0B
        DATA   37644511B       E
        DATA   22244600B
        DATA   0B
        DATA   37604411B       F
        DATA   2204600B
        DATA   0B
        DATA   17440501B       G
        DATA   24231020B
        DATA   40000000B
        DATA   37604010B       H
        DATA   2077600B
        DATA   0B
        DATA   20240577B       I
        DATA   20240600B
        DATA   0B
        DATA   10240501B       J
        DATA   17600401B
        DATA   40000000B
        DATA   37604024B       K
        DATA   10440600B
        DATA   0B
        DATA   37640100B       L
        DATA   20040200B
        DATA   0B
        DATA   37601004B       M
        DATA   2002002B
        DATA   37700000B
        DATA   37601004B       N
        DATA   2010040B
        DATA   37700000B
        DATA   17440501B       O
        DATA   20237200B
        DATA   0B
        DATA   37604411B       P
        DATA   2203200B
        DATA   0B
        DATA   17440501B       Q
        DATA   30277100B
        DATA   40000000B
        DATA   37604431B       R
        DATA   12243200B
        DATA   0B
        DATA   11444511B       S
        DATA   22231200B
        DATA   0B
        DATA   200577B         T
        DATA   200600B
        DATA   0B
        DATA   17640100B       U
        DATA   20037600B
        DATA   0B
        DATA   3610040B        V
        DATA   20020020B
        DATA   3700000B
        DATA   17640040B       W
        DATA   4020100B
        DATA   17700000B
        DATA   20221024B       X
        DATA   2012042B
        DATA   20300000B
        DATA   201004B         Y
        DATA   36002002B
        DATA   300000B
        DATA   30250511B       Z
        DATA   21241501B
        DATA   40000000B
        DATA   37640501B       [
        DATA   40000000B
        DATA   0B
        DATA   402000B         \
        DATA   2010040B
        DATA   20100000B
        DATA   20240577B       ]
        DATA   40000000B
        DATA   0B
        DATA   1001177B        ^
        DATA   402200B
        DATA   0B
        DATA   2014054B        _
        DATA   2004010B
CHTBND  DATA   2100000B
ERFLG   BSS    1
COMFL   BSS    1
COMFL1  BSS    1
CMFLG   BSS    1
CMFLG1  BSS    1
RDFLG   BSS    1
INFL    BSS    1
INLBSZ  BSS    1
OUTFL   BSS    1
OPTFLG  BSS    1
STOLSS  DATA   0               LAST WORD COUNT READ
STOLAS  DATA   0               LAST BYTE POINTER READ
STOHLD  DATA   0               POINTER TO FOLLOWING BUFFER FOR :STOCHR:
STOREL  BSS    100             RELABELLING BYTE POINTERS
STOPTR  DATA   0               POINTER TO CURRENT BUFFER
* ALSO SEE ABOVE FOR STOBOT AND STOTOP
FN      BSS    25
FPTR    DATA   3*FN-1
        DATA   3*FN-1
TBFL    BSS    1
TBFLSZ  BSS    1
ITBL    EQU    14000B          THIS IS A FCKEDUP CONSTANT
BIPTR   DATA   3*ITBL-1
IPTR    BSS    2
TFLG    BSS    1
HOLD    BSS    1
PTR     BSS    1
TBL     BSS    256
CNT     BSS    1
CNT1    BSS    1
DIFF    BSS    1
OTBL    BSS    256
BOPTR   DATA   3*OTBL-1
OPTR    BSS    2
TITL    BSS    40              SPACE FOR TITLE
BTPTR   DATA   3*TITL-1
        DATA   3*TITL-1
TPTR    BSS    2
CPTR    BSS    1
        DATA   3*CHTBND+3
PTR6    DATA   3*30000B-1      1 CHAR BEFORE PAGE 6
        DATA   0
CLENRD  ZRO    0               THE CLEAN READ FLAG (SUPPRESS)
BLNKNO  BSS    1
ENDFLG  BSS    1
FLIP    BSS    1
RTBL    BSS    10
RPTR    BSS    1
BPR     BRU    PRQPOP
        END
CONTAPE ** FICHE/FRAME BREAK *****
CONTAPESYM SYMSORT

SYM.  PG.LN. IDENT.

ANSCHK  8 11 CONTAPE ANSRD  18 21 CONTAPE ANSRD1 18 22 CONTAPE 
ASK1    5 37 CONTAPE ASK2    6 23 CONTAPE ASK3    7  4 CONTAPE BGNRD  10 12 CONTAPE 
BIPTR  34  2 CONTAPE BLNKNO 34 23 CONTAPE BOPTR  34 12 CONTAPE BPR    34 28 CONTAPE 
BTBLND 28 16 CONTAPE BTPTR  34 15 CONTAPE CAP     4 15 CONTAPE CHA     4 21 CONTAPE 
CHK     9 35 CONTAPE CHK1    4  7 CONTAPE CHTB   28 21 CONTAPE CHTBND 33 18 CONTAPE 
CLENRD 34 22 CONTAPE CMFLG  33 22 CONTAPE CMFLG1 33 23 CONTAPE CNT    34  8 CONTAPE 
CNT1   34  9 CONTAPE COM    28 17 CONTAPE COMFL  33 20 CONTAPE COMFL1 33 21 CONTAPE 
CONV   11  9 CONTAPE CONV1  11 13 CONTAPE COUNT  11 32 CONTAPE CPTR   34 18 CONTAPE 
CRE     4 23 CONTAPE CTBL   27 36 CONTAPE CTBLND 28  6 CONTAPE DIFF   34 10 CONTAPE 
END     9 29 CONTAPE ENDFLG 34 24 CONTAPE ENDP   14 13 CONTAPE ENDRD  10 31 CONTAPE 
ENDRD1 11  3 CONTAPE ENTL   13  3 CONTAPE ERCHK  22 20 CONTAPE ERFLG  33 19 CONTAPE 
ERM11  24 33 CONTAPE ERMS10 25  7 CONTAPE ERMS11 25  8 CONTAPE ERMS12 25  9 CONTAPE 
ERMSG  24 30 CONTAPE ERMSG0 24 31 CONTAPE ERMSG1 24 32 CONTAPE ERMSG2 24 34 CONTAPE 
ERMSG3 24 38 CONTAPE ERMSG4 24 39 CONTAPE ERMSG5 25  2 CONTAPE ERMSG6 25  3 CONTAPE 
ERMSG7 25  4 CONTAPE ERMSG8 25  5 CONTAPE ERMSG9 25  6 CONTAPE ERR    22 30 CONTAPE 
ERR0   22 35 CONTAPE ERR01  23  2 CONTAPE ERR1   23  5 CONTAPE ERR11  23  9 CONTAPE 
ERR2   23 13 CONTAPE ERR3   23 17 CONTAPE ERR31  23 18 CONTAPE ERR4   23 22 CONTAPE 
ERR5   23 25 CONTAPE ERR6   23 29 CONTAPE ERR61  23 30 CONTAPE ERR62  23 34 CONTAPE 
ERR7   23 38 CONTAPE ERR8   24  2 CONTAPE ERR81  24  4 CONTAPE ERR82  24 12 CONTAPE 
ERR9   24 17 CONTAPE FLIP   34 25 CONTAPE FN     33 35 CONTAPE FNSTOR  7 21 CONTAPE 
FPTR   33 36 CONTAPE GLTCH   3 13 CONTAPE HEL     4 26 CONTAPE HOLD   34  5 CONTAPE 
IN1     3 14 CONTAPE IN11    3 19 CONTAPE IN2     3 27 CONTAPE IN4     3 38 CONTAPE 
INFL   33 25 CONTAPE INLBSZ 33 26 CONTAPE INS     4 17 CONTAPE INTEL   5 35 CONTAPE 
INTL   12 30 CONTAPE IPTR   34  3 CONTAPE ITBL   34  1 CONTAPE LDR    20 39 CONTAPE 
MBCHK  21 29 CONTAPE MBLNK  21 25 CONTAPE MBLNK2 21 33 CONTAPE MBLNK3 21 36 CONTAPE 
MSG1   25 10 CONTAPE MSG10  27 31 CONTAPE MSG11  27 32 CONTAPE MSG12  27 33 CONTAPE 
MSG13  27 34 CONTAPE MSG2   26  3 CONTAPE MSG3   27 10 CONTAPE MSG4   27 11 CONTAPE 
MSG5   27 12 CONTAPE MSG6   27 13 CONTAPE MSG7   27 26 CONTAPE MSG8   27 27 CONTAPE 
MSG9   27 28 CONTAPE MSG91  27 29 CONTAPE MSG92  27 30 CONTAPE MTCH   21 21 CONTAPE 
MTCH1  22  8 CONTAPE MTCHK  20  4 CONTAPE MTCHK0 20 21 CONTAPE MTCHK1 20 25 CONTAPE 
NO     28 19 CONTAPE NXCH    8 37 CONTAPE NXCH1   9 10 CONTAPE NXNUM   8 34 CONTAPE 
OPEND   6 21 CONTAPE OPEND1  6 38 CONTAPE OPTBL   7 32 CONTAPE OPTBL1  8  9 CONTAPE 
OPTFLG 33 28 CONTAPE OPTR   34 13 CONTAPE OTBL   34 11 CONTAPE OUTFL  33 27 CONTAPE 
OUTL   13 23 CONTAPE OUTL1  13 32 CONTAPE OUTL2  13 39 CONTAPE OUTND  14  2 CONTAPE 
OUTND1 14  4 CONTAPE OUTNX  14  7 CONTAPE PNCHK   6  7 CONTAPE PRCHK   3  8 CONTAPE 
PRMSG   9 33 CONTAPE PRQ     2 31 CONTAPE PRQPOP 17 36 CONTAPE PTR    34  6 CONTAPE 
PTR6   34 20 CONTAPE PUNCH  12 25 CONTAPE QUI     4 25 CONTAPE RDCHK   6 33 CONTAPE 
RDCM0   5 17 CONTAPE RDCM2   5 33 CONTAPE RDFLG  33 24 CONTAPE RDSUB  20  2 CONTAPE 
RDTBL   8 14 CONTAPE RESET   3  6 CONTAPE RNXT   19  5 CONTAPE RNXT1  19 15 CONTAPE 
RPTR   34 27 CONTAPE RTBL   34 26 CONTAPE RUN     4 34 CONTAPE RUN1    5 38 CONTAPE 
SET    22 14 CONTAPE SPCHK  18  7 CONTAPE SRCH   21  9 CONTAPE SRCH1  21 10 CONTAPE 
START   2 35 CONTAPE STCNT  19 27 CONTAPE STO13  17 16 CONTAPE STO14  17 17 CONTAPE 
STOBOT  2  8 CONTAPE STOCHR 14 28 CONTAPE STOCMP 15 28 CONTAPE STOERR 16 35 CONTAPE 
STOFCK 15 11 CONTAPE STOFIR 15 38 CONTAPE STOHLD 33 31 CONTAPE STOINI 17 28 CONTAPE 
STOLAS 33 30 CONTAPE STOLSS 33 29 CONTAPE STOPTR 33 33 CONTAPE STOR11 16 21 CONTAPE 
STOR12 16 22 CONTAPE STORE  21  6 CONTAPE STORE1  9 24 CONTAPE STOREC 16 30 CONTAPE 
STOREL 33 32 CONTAPE STOTOP  2  9 CONTAPE SUB    18 14 CONTAPE SUP     4 29 CONTAPE 
TBFL   33 38 CONTAPE TBFLSZ 33 39 CONTAPE TBL    34  7 CONTAPE TEL    28 18 CONTAPE 
TFLG   34  4 CONTAPE TITL   34 14 CONTAPE TPTR   34 17 CONTAPE TRMCH   9 21 CONTAPE 
TSTORE 12 39 CONTAPE VER     4 19 CONTAPE XONOFF  2 23 CONTAPE XONON   2 16 CONTAPE 
YES    28 20 CONTAPE YURFCK 24 29 CONTAPE 
CONTAPE ** FICHE/FRAME BREAK *****
CONTAPEBLD
"BUILDING CONTAPE "DATE
"
"RESET
NARP
CONTAPESYM
CONTAPEBIN


RES
XDDT
;T CONTAPEBIN
%"SAVE FROM 3 TO ";F=
%"START AT "START=
%F
COM TEL
 y m