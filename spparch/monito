MONITOR ** FICHE/FRAME BREAK *****
B
B      IDENT 01/24/77

       LISTM


* ENTRY POINTS
       ENTRY   TFC02,PACFC
       ENTRY   T,T1,T2,T3,T4,BSX,SS01,SS02,SS03,BST,EPOPX
       ENTRY   MGET
       ENTRY   RFK,TFK,FKSTW,HFK,GFK,SCFK,DFK
* ENTRIES FROM MDBG
       ENTRY   PB,PX,PPB,NFORK,DBTOP,UFLAG

*
* 'SBRM','SBRR'   6/28/66
*
* SBRM  TIME=43.75 US
SBRM   POPD    570B5
$SBRME STX SS03; EAX* 0; XXA; ETR ADMSK
*THE NEXT LINE SHOULD BE
*      MRG =40040000B: XMA 0: EOR =40040000B: SKA X1: EOR X5: STA* 0
*TO STACK CONDITION OF OVERFLOW INDICATOR INSTEAD OF SETTING IT.
*THIS WOULD COST 3 CYCLES, PERHAPS SCREW UP BFORTRAN, AND STILL WOULD
*NOT QUITE SIMULATE EFFECT OF BRM IN USER MODE
       MRG =40040000B; XMA 0; EOR =40000B; STA* 0
       CXA; LDX SS03; BRR 0
*
SBRR   POPD    571B5
$SRB   STX SS03; LDX* 0; EAX 0,6; STX T; LDX SS03; BRR* T (TIME 28 US)
*
*
* 'BRS'  9/27/65

       IF MDSI
SYS    EQU 1
       ELSE
SYS    EQU 2
       ENDF
       FRGT SYS

*
* THIS ROUTINE DISPATCHES ON THE ADDRESS OF A 'BRS'
*
T      ZRO;* UNIVERSAL TEMPORARY STORAGE
T1     ZRO
T2     ZRO
T3     ZRO
T4     ZRO
BSX    ZRO;* BRS EXIT
SS01   ZRO;* SAVE (A)
SS02   ZRO;* SAVE (B)
SS03   ZRO;* SAVE (X)
*
BRS    POPD    573B5
$BS    STA SS01; STB SS02; STX SS03; EAX* 0
       COPY XA,B; SKA =37600B; BRU BSFT
BS1    LDA BST,2; SKG PRILEV; BRU BS3; TRAP 1
BSFT   ETR ADMSK; SKG =BSTU-BST; BRU BS1; TRAP 2

*      TAG     STATUS REQUIRED
*      0       NO STATUS
*      ,1      SUBSYSTEM
*      ,2      SYSTEM
*      ,3      EXEC
*      PRILEV IS THE FORK LEVEL. PRILEV IS HIGH FOR HIGH STATUS FORKS.
* TYPES:  OP CODE  TYPE
*           0      TRAP
*           1      MONITOR WITH X=PACPTR
*           2      EXEC
*           3      RUP BRS'S
*           4      MONITOR WITH DISC TS MAP
*           5      MONITOR WITH W TS MAP
*           6      MONITOR WITH X=SS03
*           7      MONITOR WITH DISC TS MAP AND X=SS03
*          10      MONITOR WITH W TS MAP AND X=SS03
*          11      MONITOR WITH M6 NET MAP AND X = SS03
*          12      EXEC WITH UFIO<0
*          13      MONITOR WITH M6 NET MAP AND
*                  X = TPORT.  CALLS GATT.  A,B GARBAGE.
*          14      MONITOR WITH W MAP (0711) MAP AND X=SS03
BST    ZRO 0 (0); 7 BRS1,3; 7 CCLS,3; 1 PMTI
       1 MPT (4); 1 FKSTAT; 2 21; 6 BRS7
       7 BRS8,3 (8); 1 FKST; 1 PPAN; 13B BRS11
       11B BRS12 (12); 13B BRS13; 13B BRS14; 2 4000B
       2 1+4000B (16); 7 BRS17; 2 3+4000B; 2 4+4000B
       7 BRS20 (20); 1 HFNA; 1 NTERM,3; 1 ALTERM,3
       6 BRS24 (24); 4 GRABB2,3; 1 SKROUT
       IF MDSI
       2 36+4000B (27)
       ELSE
       0 0 (27)
       ENDF
       10B SETEC (28)
       6 BRS29; 4 GIVEB,3; 1 FKWT
       6 CLM2,3 (32); 3 GETSTR; 3 OUTMSG; 3 OUTSTR
       3 OUTNUM (36); 2 20+1000B (37); 3 GETNUM; 5 RCPARW
       13B BRS40 (40); 7 LOCBLK,2; 5 BRS42; 1 RDRL
       1 STRL (44); 6 BRS45; 1 NROUT,3; 1 SROUT
       2 6 (48); 1 SRIR; 1 FFIX; 1 FFLT
       2 26+5000B (52); 2 27+5000B; 4 GRABB1,3; 10B MAYDMS
       1 PMTR,3; 1 MXSA,3; 2 2; 2 5+4000B (59)
       2 9 (60); 6 BRS61,2 (61); 2 16; 2 17
       2 18 (64); 2 19; 7 BRS66,3; 2 22
       2 14 (68); 2 15; 1 FRPMT; 5 SKXEC
       5 BRS72 (72); 10B RDCLEC; 5 BRS74; 13B BRS75,SYS
       5 BRS76; 7 BRS77; 1 SAIR; 13B BRS79
       1 MBRO (80); 6 BRS81; 1 SKFNE; 1 SKFZE
       1 SKFUZE (84); 13B BRS85; 13B BRS86; 6 BRS87,1
       5 RTEX (88); 5 RESMT; 1 DFR; 2 32+1000B
       7 BRS92 (92); 5 RSMET,3; 1 CLFK,2; 2 7,3
       2 8 (96); 13B BRS97,SYS; 5 BRS98; 13B BRS99,SYS
       5 AST (100); 5 UAST; 5 TREAD; 5 TWRT
       5 WHT (104); 5 CTRL; 5 BRS106; 5 SETPAR
       5 TSTD2 (108); 1 DMS; 5 TSTRDY; 1 BRSRET,3
       11B BRS112,3 (112); 6 BRS113; 6 BRS114; 1 EXRETE,3
       1 RURL (116); 1 SURL; 1 LDFLE; 1 STFLE
       1 APMTE,3 (120); 1 DPMTE; 4 ARDD,2; 4 AWDD,3
* DON'T FORGET TO REMOVE STATUS FROM BRS 126, 172, AND BLOCK
*      I/O BRS'S WHEN IT IS ESTABLISHED THAT THEY ARE HARMLESS.
       4 ARD,2 (BE+1,124); 4 AWD,3;  13B BRS126,3; 1 PEBRS,2
       7 SDBM,3 (BE+5,128); 11B BRS129,3; 10B BPTEST; 1 CRASH,3
       13B BRS132 (132); 12B 26+5000B (133); 6 XPOP; 10B BRS135
       10B BRS136,3 (BE+13,136); 11B BRS137; 6 BRS138,3; 13B BRS139
       2 33+1000B (BE+17,140); 2 11+2000B,3; 2 10+2000B; 5 BMTST
       4 EXBGET,3 (144); 4 EXBPUT,3; 1 QS,SYS; 7 BRS147
       1 FFNAE  (148); 1 FFIXE; 1 FFLTE; 7 BRS151
       13B BRS152; IF SUPER; 6 BRS153; 6 BRS154; ELSE
       6 BSTU; 6 BSTU; ENDF; 13B BRS155
       11B BRS156 (156); 7 BRS157; 10B BRS158; 11B BRS159,3
       13B BRS160; 13B BRS161; 13B BRS162; 11B BRS163,3
       13B BRS164; 12B 27+5000B (165); 11B BRS166,3; 10B BRS167
       13B BRS168; 13B BRS169; 10B BRS170; IF MDSI
       2 34+1000B,SYS; ELSE; 6 BSTU; ENDF
       13B BRS172,1; 2 23+4000B; 7 BRS174; 5 BRS175
       2 12+1000B (176); 13B BRS177; 13B BRS178,SYS; 10B NSUP
       1 CRSH,3 (180); 7 BRS181; 2 13+4000B; 14B BRS183,3; 14B BRS184,3
       IF MDSI; 4 BRS185,SYS; 4 BRS186,SYS; 2 35+1000B,SYS (187); ELSE
       6 BSTU; 6 BSTU; 6 BSTU; ENDF
       14B BRS188,3; 14B BRS189,3; 2 28+3000B,3 (190)
       2 29+3000B,2 (191); 2 30+3000B,SYS (192); 2 31+3000B,3 (193)
       10B BRS194,3; 10B BRS195,3
       IF TST; 11B BRS196,3; 11B BRS197,3; ENDF

H3     EQU *
$BSTU  BRM TRAP
BS3    ETR KS7; STA BSX; LCY 9; CBX; EXU *+1,2
H4     BRM TRAP; BRU BS2; BRU BS4; BRU BS6; BRU BS10; BRU BS12
       BRU BS14; BRU BS16; BRU BS20B; BRU BS22; BRU BS23
       BRU BS24; BRU BS25

BS23   SKR UFIO (OPCODE 12B); BRU *-1
$BS4   LDA 0; STA SBRSRT; BRU UBRSET
BS2    LDA SS01; LDB SS02; LDX PACPTR; BRU* BSX
BS6    LDA =UBRSET; XMA 0; STA SBRSRT
BS14   LDA SS01; LDB SS02; LDX SS03; BRU* BSX
BS10   BRM MPDSC; BRU BS2
BS12   BRM MPWB; BRU BS2
BS16   BRM MPDSC; BRU BS14
BS20B  BRM MPWB; BRU BS14


BS22   BRM MPTYM; BRU BS14
BS24   LDX SS03; BRM GATT; BRU* BSX
BS25   LDA =RWP*100B+RMP; BRM RLABEL; BRU BS14


*
* CLASS 3 BRS SETUP AND RETURN ROUTINE
* EXEC BRS'S
*
UBRSET BSS 0
       IF ALOG; DIR; LOGG 50B,JOB; EIR; ENDF; LDA NFORK; SKG ZERO; TRAP 5
       BRM GFK; BRU FKSTW; BRM STFK
       LDX PACPTR; LDA RL1,2; STA UBRL1; LDA RL2,2; STA UBRL2
       IF TSTAT1
       LDA REAL; STA XREAL (RECORD TIME XBRS STARTED)
       ENDF
       LDX UTTY
       LDA FK04; STA TTYASG,2
       LDA BRSTVA; STA 0; LDA BSX; RCY 9; ETR K37; CAX
       LDA BRSTV,2; CLB; LRSH 18; MRG =NCMEM*1B6+1B4+12B2
       LDX FK04 (NEW PACPTR); STA RL1,2; STB RL2,2
       LDA =700B+2B6; ADM PIM,2
       LDA BSX; ETR K777; IF TSTAT1; STA XBRS; ENDF; ADD 0
       ETR =50037777B; STA PL,2
       LDA =EXECL; RSH 15; LDA JOB; LSH 15; MRG X7; STA PTAB,2
       LDX STFK2 (NEW XPB)
       LDA SS01; STA PA,2; STA UBA
       LDA SS02; STA PB,2; STA UBB; LDA SS03; STA PX,2; STA UBX
       LDA SBRSRT; STA 0; STA UPL
       LDB =700004B; BRM FKGO

*
* CLASS 2   MONITOR BRS'S
* SAVE RETURN
*
*
* RETURN FROM CLASS 2 BRS'S
EPOPX  SKN TIME; BRR SBRSRT
       SKN TTIME; SKN ACTR; BRU *+2; BRR SBRSRT
       STA SS01; STB SS02; STX SS03; LDA SBRSRT; STA 0; BRU PACQM1
*
*
* BRS 111   RETURN FROM EXEC BRS'S  (CLASS 3/4)
BRSRET BSS 0
       IF ALOG; DIR; LOGG 51B,JOB; EIR; ENDF; LDA PPTR,2; MRG PLMSK; COPY AX,A
       STA UFIO (SET FIO/NIO SWITCH TO FIO)
       LDA PTEST,2; SKE =700004B; TRAP 6
       LDA UPL; ETR =50037777B; STA PL,2
       MIN PL,2; STX FK04 (PACPTR OF CALLING FORK)
       IF TSTAT1
       LDA REAL; SUB XREAL; LDX XBRS; ADM XBRST,2; MIN XBRSTC,2
       ENDF
       LDX PACPTR (FORK TO BE DELETED); BRM DFK
       BRM FKGO2

* BRS 115   ERROR RETURN FOR EXEC BRS'S
EXRETE LDA PPTR,2; MRG PLMSK; STA DNTERM
       COPY AX,A; STA UFIO; LDA PTEST,2; SKE =700004B
       TRAP 7; SUB THREE; STA PTEST,2; LDA UPL; STA 0; STX EXRA
       IF TSTAT1
       LDA REAL; SUB XREAL; LDX XBRS; ADM XBRST,2; MIN XBRSTC,2
       ENDF
       CLA; LDB PACPTR; LDX JOB; BRM RELPG
       LDX PACPTR; BRM DFK; LDX EXRA; LDA PIM,2; LRSH 3; ETR SEVEN
       MRG X4; STA XPB; CLB; STB PACJOB
       BRM STSTAT; STX PACPTR; STX PUPAC
       LDX UTTY; LDA =SOFTY; LDB =3B5; DIR
       SKA TF2,2; BRU EXR2; ADM TF2,2 (FAKE ESCAPE)
       LDE; LDA TIC1; BRM EPU; MIN ACTR; BRU POPR
EXR2   EIR; BRU POPR
EXRA   ZRO 0

* BRS 61       READ COPY OF MONITOR TO USER CORE
BRS61  LDX =44B3; STA 34000B,6; EAX 3777B,2; BRX *-2 (DIRTY 7 PGS)
       LDX =44B3; LDA 34000B,2; STA 34000B,6; BRX *-2 (MOVE 7 PGS)
       BRU POPX

* BRS 46   SET NON-TERMINABILITY
$WNROUT BRM MPPACT; LDX PACPTR
NROUT  LDA PIM,2; MRG X1; STA PIM,2; BRU POPX
* BRS 26   SKIP IF TERMINATION PENDING
SKROUT LDA PIM,2; SKA X2; BRU SKR2
       LDX UTTY; LDA =SOFTY+HARDY; SKA TF2,2
SKR2   MIN 0; BRU POPX
* BRS 47   CLEAR NON-TERMINABILITY
SROUT  LDA PIM,2; SKA X1; BRU *+2; BRU POPX
       ETR =47777777B; XMA PIM,2; SKA X2; BRU PACQE; BRU POPX
* BRS 90   DECLARE FORK FOR RUBOUT
DFR    CXA; LDX UTTY; STA TTYASG,2; BRU POPX

*      MEMORY ALLOCATION LOGIC
*

* ASSIGN A POSITION IN PMT
* RETURNS: NO SKIP=NO BYTES. SKIP=BYTE NO. IN X
PMGET  ZRO; CLA; LDB KM1; MIN PMGET; BRM PMSCH; SKR PMGET; BRR PMGET

PMSCH  ZRO; LDX =NUMEM-1; STX PMG5; LDX =NCMEM-1
MGET1  EAX 1,2; SKM* PMTJOB; BRU MGET4; MIN PMSCH; BRR PMSCH
MGET4  SKR PMG5; BRU MGET1; BRR PMSCH
PMG5   ZRO 0
*
*
* GET A BLOCK OF MEMORY
* INPUT: A=CORE ADDRESS IN PAGE. INDIRECT BIT IF MEMORY MUST
*          COME FROM AN UPPER FORK.
*        X=PACPTR
MGET   ZRO; BRM MX01; SKE ZERO; BRU MX03
       LDA KM2; STA MX09; LDX MS03
* SCAN FOR LOCAL OR FIXED MEMORY FORK
MGET11 STX MX08; LDA RL1,2; LDB RL2,2; LDX MX07; MIN MX09
       LCY 0,2; SKA K77B6; BRU MGET12; LDX MX08
       SKN PIM,2; BRU *+2; BRU MX03; SKN PTAB,2
       BRU MGET13 (CHECK HIGHER FORKS FIRST)
       LDA MX14; SKA =40000B; BRU MX03
       MIN MX09; BRM PMGET; BRU MX03
       STX MGTS2; BRM PMTA; LDX MS03
* PROPAGATE NEW BYTE AS NECESSARY
MGET10 STX MX08; LDA RL1,2; LDB RL2,2; LDX MX07
       LCY 0,2; RCY 18; MRG MGTS2; LCY 18; RCY 0,2
       LDX MX08; STA RL1,2; STB RL2,2
       LDA PPTR,2; MRG PLMSK; CAX; SKR MX09; BRU MGET10
* SET UP NEW MAP
       LDX MS03; BRM CHREL; BRM SWAPI
       SKN PACJOB; BRU MGET20; BRM STCMRL STOR COMPUT JB RELAB.
MGET20 BRM LABEL; BRU MX04
MGET12 LRSH 18; STA MGTS2; CAX; BRM PMTA; LDX MS03; BRU MGET10
MGET13 LDA PPTR,2; MRG PLMSK; CAX; SKA PRMSK; BRU MGET11; BRU MX03
*
* ASSIGN BLOCK IN PMT
PMTA   ZRO; LDA JOB; STA BJOB
       IF TSTAT; MIN NPGFLT; LDA =QTIGO+37B; STA RFR; ENDF
       CXA; ADD PMTJOB; ETR ADMSK; MRG =41B6; MIN RAJOB3
       DIR; BRM B; BRM RAGO; EIR
       IF MDSI; ELSE
       LDA =PGTIM; XMA TJOB; STA PMTA2
       ENDF
       LDA RAJOB3; SKE ZERO; BRU *-2
       IF MDSI; BRR PMTA; ELSE
       LDA PMTA2; STA TJOB; MIN* TJOB; BRR PMTA
PMTA2  ZRO 0
       ENDF
*
MGTS2  ZRO 0
*
* DELETE PMT ENTRY FROM ALL FORKS
* INPUT: X=RELABELING BYTE.
$MDEL  ZRO
       IF SUPER; LDA JOB
       SKE ONE; BRU MDL5; IF ALOG; DIR; LOGG 55B,LOGX; EIR; ENDF; ENDF
MDL5   COPY XA,B; STA T2; STB T3; ADD PMTJOB; STA T
       CAX; LDB 0,2; STB HLDC
RX33   DIR; BRM RES; BRU RX32
       EIR
       LDX T; CLA; XMA 0,2; XMA T2; COPY AB,X; SKE =NCMEM; BRU RXNTS
       STX XPB; LDX PACPTR; LDA PTAB,2
       ETR =67777777B; STA PTAB,2
RXNTS  LDA PACPTR; BRM MDELC; SKN T2; BRU RRRL (NOT SHARED)
RX6    LDB =7737777B; LDA =12B5; ADD T; LDX =-NUMEM*NJOB1
RX7    SKM PMTE,2; BRU RX5
       COPY XA,B; STB PMTE,2; SUB =-NUMEM*NJOB1
       RSH 23; DIV =NUMEM; COPY AX,BA; ADD =NCMEM; STA T4
       EAX 1,2; LDX TTNO,2; LDX TTYASG,2
RX4    LDA PPTR,2; SKA KS4B4; BRU RX3; CXA; LDB T4
       BRM MDELC; BRU RX6
RX5    BRX RX7
* NOTE THAT PPG WILL BE ZERO WHEN THE TTQ SCHEDULER DOES NOT
*      ACTUALLY HOLD THE PAGE.
       SKM PPG; BRU RRRL
       CLA; STA PPG; STA RLCT; BRM HLDR
RRRL   LDX PACPTR; BRM CHREL; SKN XPB; CLX; BRM SWAPI
       SKN T3; BRU RX12; SKN PACJOB; BRU RX13
       BRM STCMRL STORE COMPUT JB RELAB
RX12   BRM LABEL; IF PTICK; SKN PACJOB; ENDF; BRR MDEL
       IF PTICK
       LDA SWIN14; STA CJP; LDX TTIME; BRM NPC; BRR MDEL
       ENDF
RX3    RSH 12; CAX; BRU RX4
RX13   BRM LABEL; LDA RAJOB2; SKE ZERO; BRU *-2
       SKN RAER2; BRR MDEL
       LDX PACOMP; BRM SETSWP; BRM SWAPI
       BRM STCMRL STORE COMPUT JB RELAB
       IF PTICK; LDA SWIN14; STA CJP; ENDF; BRR MDEL
RX32   EIR; HLT; LDA T; BRU RX33
MDELC  ZRO; SKE PACOMP; BRU RX11; SKR T3
RX2    MRG KS4B4
RX11   COPY AX,BA; LDB THREE; STB T1
       LDB KM1; STB RLCT; LDB K77
RX1    SKM RL1,2; BRU *+5; CNA; ADM RL1,2; CNA; MIN RLCT
       SKM RL2,2; BRU *+5; CNA; ADM RL2,2; CNA; MIN RLCT; LCY 6
       SKR T1; BRU RX1; SKN RLCT; BRU RLHOLD
RX8    LDA PPTR,2; SKA K7777; BRU RX2; BRR MDELC
RLHOLD CXA; SKE PACPTR; BRU RLHLDB
RLHLDA BRM HLDR; BRU RX8
RLHLDB SKE PACOMP; BRU *+2; BRU RLHLDA; SKE PACSW; BRU RX8; BRU RLHLDA
$RLCT  ZRO
HLDA   ZRO
HLDB   ZRO
$HLDC  ZRO

$HLDR ZRO;* RELEASE PAGE BEING HELD BY COMPUTE JOB, INTERACTIVE JOB,
*              OR TTQ JOB SINCE RES ON A PAGE PTR ZEROES THE PTR
*              WITHOUT DECREMENTING THE USE COUNT.
       STA HLDA (PACPTR); STB HLDB (BYTE)
       LDA HLDC; ETR =77B5; SKE =12B5; BRR HLDR
       LDA HLDC; DIR; BRM REL; EIR; SKR RLCT; BRU *-5
       LDX HLDA; LDB HLDB; BRR HLDR

$SWLSC ZRO;* SKIP IF PAGE IS IN CORE.  'A' = PMT ADDR
       LDB =77B5
SWLS1  CAX; LDA 0,2; SKM =12B5; BRU SWLS2; BRU SWLS1
SWLS2  STA SWLS3
       ETR =77B5; LRSH 15; COPY AX,B; LDA SWLS; LSH 0,2
       SKA X4; BRR SWLSC; MIN SWLSC; BRR SWLSC
$SWLS3 ZRO


* COMMON ENTRY FOR MGET,MPUT,CHKRO
* GET RELABELING BYTE INTO A
* INPUT: A=ADDR. IN PAGE, X=PACPTR
$MX01  ZRO; STA MX14; ETR =34000B; STA MS01; STX MS03
       LDX MX01; LDB -1,2; STB MX00; LRSH 11; STA MX05; MUL THREE
       LDX MS03
$TT0M   LDA RL1,2; LDX RL2,2; XXB; STX MX07
       RCY 18; LCY 0,2; ETR K77; STA MX06; BRR MX01
*
MX04   MIN MX00
MX03   LDA MS01; LDX MS03; BRR MX00
*
MS01   ZRO     0               ADDR. OF 1ST WORD IN PAGE
MS03   ZRO     0   PACPTR
MX00   ZRO     0   RETURN FOR MGET OR MPUT
MX05   ZRO     0   PAGE NUMBER
MX06   ZRO     0   RELABELING BYTE
MX07   ZRO     0   RELABELLING BYTE INDEX
MX14   ZRO     0   IND. BIT=1 IF MEMORY COMES FROM UPPER FORK.
*
MX08   ZRO
MX09   ZRO


*
* 'MBRO','APMTE','DPMTE','MPT'  6/30/66
*
* BRS'S FOR MODIFYING THE MEMORY TABLES
*
*
* BRS 80   MAKE BLOCK READ ONLY
* INPUT: A=PMT NO.  IF A LT 0, MAKE FILE RO.  OTHERWISE, READ-WRITE
* OUTPUT: A=FORMER STATE OF PMT ENTRY
MBRO   ETR K77; SKG =NCMEM-1; EXU EX; BRM CRTA; TRAP; STA CRTA
       LDB =77B5; SKN SS01; SKM =12B5 (WRITE, IS IT INDIRECT)
       SKA X2; EXU EX
       LCY 2; EOR SS01; SKA X4; BRU *+2; BRU POPX (NO CHANGE)
       SKN SS01; BRU MBRO3
       LDA X1; ADM 0,2; LDX PACPTR; BRM CHREL; BRM SWAPI
       SKN PACJOB; BRU MBRO7; BRM STCMRL STORE COMPUT JB REL
MBRO7  BRM LABEL; BRU MBRO5
MBRO3  LDA X7; ADM 0,2 (TURN OFF RDO BIT)
MBRO5  LDA CRTA; LCY 2; ETR X4; XMA SS01; ETR K77
       ADM SS01; BRU POPX (RETURN FORMER PMT STATUS)
*
$QS    LDA QQEC; ADD QQCC; CAX; LDA QTIC
       LDB QIOC; BRR 0
*
* BRS 94   CLEAR FORKING STRUCTURE
CLFK   LDX JOB; SKN TTNO,2; BRU *+2; BRM TRAP; LDX PACPTR
       BRM HFK; MIN PL,2; STX FK04; LDA PPTR,2; RSH 12; CAX
       LDA =DFK; BRM SCFK; CLX;  STX PX,2; BRM FKGO3

* OUTPUT FROM CTRU.  A=EFFECTIVE CPU TIM, X=JOB.
       IF MDSI
$CTRU  0; LDX JOB; LDA ETTB,2; BRR CTRU
       ELSE
       IF -RP
$CTRU  0; LDX JOB; LDA CCT,2; MUL CTRU1; STA CTRU2
       LDA DSKMET; MUL SEVEN; LSH 23; ADD ETTB,2
       ADD CTRU2; BRR CTRU
* APPROX. .0097/KCH AT .05/CPUSEC
CTRU1 DATA 611157B;* .024 OR APPROX. $.02/KILOCHAR
CTRU2 DATA 0
       ELSE
$CTRU  0; LDX JOB; LDA SWPCNT,2; MUL KP96; ADD ETTB,2
       STA CTRU1; LDA CCT,2; MUL KP24; ADM CTRU1
       IF PTICK; LDA PTCKS,2; MUL KP06; ADM CTRU1; ENDF
       LDA DSKMET; MUL SIX; LSH 23; ADD CTRU1; BRR CTRU
CTRU1  DATA 0
KP96   DATA 36560510B
KP24   DATA 07534122B
KP06   DATA 01727024B
       ENDF
       ENDF MDSI
*
* BRS 57   MAKE EXPANDED SMT BYTE AVAILABLE TO USERS.
* INPUT: A=BYTE NO.
MXSA   SKG =LESMT; SKG =FESMT-1; TRAP; CAX; LDA X2
       SKA EXSMTD,2; BRU POPX; ADM EXSMTD,2; BRU POPX
*
*
* BRS 56   MAKE POINTER INDIRECT FOR RECOVER
* INPUT: A: BIT 0=1 FOR READ ONLY. BITS 17-23=PMT BYTE
*           NUMBER FOR PMT OR SMT BYTE POINTED AT.
*        B: BITS 18-23 SPECIFY THE PMT NO.
*        X: BITS 18-23 ARE CHANNEL NUMBER FOR SECOND BYTE.
* OUTPUT: A=USERS PMT BYTE NUMBER.
PMTR   CBA; ETR K77; SKG =NCMEM; TRAP 12; CAX; LDA* PMTJOB
       SKE ZERO; TRAP 13; STX PMI2; BRU PMI11

* BRS 3   MAKE POINTER INDERICT
* INPUT: A: BIT 0 = 1 FOR READ ONLY. BITS 17-23 = PMT BYTE
*         NUMBER FOR PMT OR SMT BYTE POINTED AT.
*      X: BITS 18-23 ARE CHANNEL NUMBER FOR SECOND BYTE.
* OUTPUT: A = USERS PMT BYTE NO.
PMTI   LDA KM1; STA PMI2
PMI11  LDA SS01; ETR K377; SKG =NCMEM-1; BRU PMI3
       SKG =FESMT-1; BRU PMI6; SKN EXEC1; BRU PMI7; BRU PMI8
PMI6   EXU EX; LDX SS03; SKN TTYASG,2; TRAP 14
       LDX TTYASG,2; LDA PTAB,2; LRSH 15; ETR K77
       SKG =NJOB; BRU *+2; TRAP 15; CAX
       LDA SS01; ETR K77; SUB =NCMEM; ADD PMTP,2; BRU PMI4
PMI3   EXU EX; ADD =SMT; BRU PMI4
PMI7   CAX; LDA EXSMTD,2; SKA X2; BRU *+2 (USER PAGE); TRAP 16; CXA
PMI8   SKN SS01; EXU EX
       ADD =EXSMT; SUB =FESMT; SKG =XSMTEM; BRU PMI4; TRAP 17
PMI2   ZRO 0   BYTE NO.
PMI4   CAX; LDA 0,2; SKA XX; BRU *+2; TRAP
       SKA X4; BRU *+3; LDA X4
       ADM 0,2; CXA; MRG =12B5; SKN SS01; BRU *+2
       MRG X1; LDX PMI2; SKN PMI2; BRU PMI5; LDB K1S7
       BRM PMSCH; BRU *+2; BRU PMIX; STA PMI2
       BRM PMGET; TRAP 19; LDA PMI2
PMI5   STA* PMTJOB
PMIX   STX SS01; BRU POPX
*
* BRS 120   ADD A PAGE FOR SPECIFIED PMT ENTY.
* INPUT: A=REL. BYTE
APMTE  SKG K77; SKG =NCMEM-1; TRAP 24; AXC
       SKE* PMTJOB; TRAP 25
       ADD ONE; STA* PMTJOB; BRU POPX
*
* BRS 4        DELETES A PMT ENTRY.  REMOVES PMT POINTER FROM ALL
*              OTHER FORKS.  A = ADDR. IN PAGE TO RELEASE
MPT    BRM MX01; BRU *+2
* BRS 121   DELETES PMT ENTRY
* INPUT: A=REL. BYTE
DPMTE  ETR K77; SKG ZERO; BRU POPX; SKG =NCMEM-1; TRAP(SMT ENTRY)
       STA MDEL; BRM CRTA; BRU POPX
       SKA X2; EXU EX (EXEC PAGE)
       LDX MDEL
       CXA; SKG =NCMEM; BRU BS112I (DO BRS 112)
       BRM MDEL; BRU POPX
*
* COMPUTE RELABELING TABLE ADDRESS
* INPUT: A=PSEUDO-REL. BYTE
* OUTPUT: A=PMT ENTRY,  B=INPUT X,  X=PMT/SMT ADDRESS
* RETURN SKIPS IF PMT IS NOT EQUAL ZERO.
CRTA   ZRO; COPY XB,AX; SKG =NCMEM-1; BRU CRTA1
       EAX* PMTJOB; LDA 0,2
CRTA2  SKE ZERO; MIN CRTA; BRR CRTA
CRTA1  ADD =SMT; CAX; LDA 0,2; BRU CRTA2
*
* 'RDRL','RURL','STRL','SURL'  6/28/66
*
* READ AND SET RELABELING
*
* BRS 43   READ FORK RELABELING
RDRL   LDA RL1,2; LDB RL2,2; BRU XPOPX
*
* BRS 116   READ PROGRAM RELABELING FROM TS BLOCK
RURL   LDA UPRRL1; LDB UPRRL2; BRU XPOPX
*
* BRS 44   SET FORK RELABELING
* CHANGES REL. IF REMAINING TIME QUANTUM IS ADEQUATE.
* SRT STORES NEW RELABELLING. NSRT STORES OLD RELABELLING.
STRL EQU *
        STA STRL1; STB STRL2; SKN PIM,2; BRU *+2; TRAP 28
STRLQ  LDX =SRT; BRM UPRL44; LDA KM1; STA S44T5; STA S44T12
       LDX PACPTR; LDA RL1,2; LDB RL2,2; LDX =NSRT; BRM UPRL44
       LDA PMTJOB; ETR ADMSK; STA SWPMT; CNA; ADD =SMT; STA SWSMT
       MIN NCHRLS (NO. OF RELABELING CHANGES)
       LDX KM8; LDB =77B5
S44T3  LDA SRT44E,2; SKE ZERO; BRU S44T7; SKE ENSRT,2; MIN S44T12
       BRU S44T4
S44T7  SKE ENSRT,2; BRU S44T2
S44T4  BRX S44T3
       SKN S44T5; BRU S44T13; SKN S44T12; BRU *+3
       MIN NNCHRLS (NULL RELABELING CHANGES)
       BRU POPX
* RELEASE OLD PAGES THAT ARE DIFFERENT
S44T27 LDX KM8
S44T30 LDA ENSRT,2; SKE ZERO; BRU *+2; BRU S44T31
       SKE SRT44E,2; BRU *+2; BRU S44T31; STX S44T10
       SKG =NCMEM-1; ADD SWSMT; ADD SWPMT
       DIR; BRM REL; EIR; LDX S44T10
S44T31 BRX S44T30; DIR; BRM RAGO; EIR
       IF TSTAT; MIN B44HNG
       LDA* TJOB; CNA; ADM B44TIM; ENDF
       CLA; SKE RAJOB3; BRU *-1
       IF TSTAT; LDA* TJOB; ADM B44TIM; ENDF
       SKN RAER3; BRU S44T33
       LDX PACPTR; LDA STRL1; LDB STRL2; STA RL1,2; STB RL2,2
* COMPUTE NEW REAL RELABELING
       CLA; LDX KM2; STA SRTE,2; BRX *-1; BRM SWIN
       LDX RRL3; SKN PACJOB; BRU S44T14
       BRM STCMRL STOR COMPUT JB REL.
S44T14 EQU *
       BRM LABEL; IF PTICK; SKN PACJOB; ENDF; BRU POPX
       IF PTICK
       LDA SWIN14; STA CJP; LDX TTIME; BRM NPC; BRU POPX
       ENDF
* CHECK LEGALITY
S44T2  MIN S44T5; STX S44T10; SKG =NCMEM-NUSMT; BRU S44T6
       SKG =NCMEM-1; ADD SWSMT; ADD SWPMT
S44T9  CAX; LDA 0,2; SKE ZERO; BRU *+2; TRAP 29
       SKM =12B5; BRU S44T51; ETR ADMSK
       SKG =EXSMTE; BRU *+2; TRAP 30; SKG =EXSMT1; BRU S44T53
       SKN EXEC1; BRU *+2; BRU S44T61; STA S44T62; LDA* S44T62
       SKA X2; BRU S44T61; TRAP 31
S44T62 ZRO 0
S44T53 SKG =PMTE; SKG =PMTM1; BRU *+2; EXU EX
       SKG =USMT; SKG =SMT; BRU *+2; EXU EX
S44T61 LDA 0,2; SKA X1; BRU S44T51; EXU EX
S44T51 SKA K1B7; BRU S44T8; SKA K2B7; EXU NEXEC
S44T11 LDX S44T10; BRU S44T4
S44T6  SKN EXEC1; TRAP 33; ADD =SMT; BRU S44T9
S44T8  SKA K2B7; EXU NSYS; BRU S44T11
* CHECK FOR MISSING PAGES
S44T13 LDX KM8; CLAB; STA S44T12; DIR
S44T19 LDA SRT44E,2; SKE ZERO; BRU *+2; BRU S44T15; STX S44T10
       SKG =NCMEM-1; ADD SWSMT; ADD SWPMT
       BRM SWLSC
       MIN S44T12 (COUNT MISSING PAGES); LDX S44T10
S44T15 BRX S44T19
       LDA S44T12; SKN PACJOB; BRU S44T20; ADM PG44
* RAJOB1 SHOULD BE 0 IF SUPERVISOR IS RUNNING.
       IF SUPER
       SKN SVST; BRU S44P1; MIN S44P2; SKN RAJOB1; MIN S44P3
       ENDF
S44P1  SKN RAJOB1; BRU S44T21; SKN PACSW; BRU *+2
*      THE FOLLOWING CAUSES COMPUTE JOB TO BE PUT ON QTI, AND
*      ANOTHER COMPUTE JOB WILL BE FETCHED WHILE WE RUN THE
*      INTERACTIVE JOB.  PERHAPS IT WOULD BE BETTER JUST TO DO
*      THE SWAP AND LEAVE THE COMPUTE JOB RESIDENT.  THIS OCCURS
*      ABOUT TWICE TO AS MANY AS TEN TIMES A MINUTE.
       BRU STDMS (SWAP JOB JUST CAME CAME IN)
       IF SUPER
       SKN SVST; BRU *+2; BRU S44T22
       ENDF
*      PERHAPS THE FOLLOWING SHOULD BE REMOVED.  ARGUMENTS AGAINST
*      REMOVAL ARE:  1. SLIGHTLY POORER RESPONSE DUE TO HAVING TO
*      WAIT FOR SHORT QUANTUM TO BE USED UP BEFORE CHECKING ACTR
*      AGAIN AND FETCHING THE INTERACTIVE JOB  (UP TO 36 CLOCK TICS).
*      2.  THE NEW COMPUTE JOB IS FETCHED WHILE THE INTERACTIVE JOB
*      IS RUNNING, AND MAY EVEN BE THE SAME JOB IF THERE IS ONLY ONE
*      USER ON THE COMPUTE QUEUE.
*              ARGUMENTS FOR REMOVAL ARE:  1.  MOST OF THE PAGES
*      ARE IN CORE, AND DISMISSING JOB ONLY CAUSES ANOTHER COMPUTE
*      JOB TO BE FETCHED WHOSE PAGES ARE NOT IN CORE.
       SKN ACTR; BRU STDMS (NO SWAP JOB COMING IN BUT ONE IS READY TO RUN)
S44T21 LDA STRLC; SKG PG44; BRU STDMS; BRU S44T22 (BRING PAGES)
*      2 * NO. OF PAGES TO BRING > TIME??
S44T20 LSH 1; SKG TIME; BRU *+2 (BRING PAGES); BRU STDMS
*      PENALTY BIT FOR SWAP JOB ONLY
       LDX PACPTR; LDA K1B5; MRG PL,2; STA PL,2
* BRING PAGES
S44T22 LDX KM8
       IF TSTAT; LDA =QTIGO+25B; STA RFR; ENDF
       LDA JOB; STA BJOB
S44T23 LDA SRT44E,2; SKE ZERO; BRU *+2; BRU S44T24; SKE ENSRT,2
       BRU *+2; BRU S44T24; STX S44T10; SKG =NCMEM-1
       ADD SWSMT; ADD SWPMT; MRG =41B6
       MIN RAJOB3; BRM B; LDX S44T10
S44T24 BRX S44T23; BRM RAGO; EIR
       BRU S44T27
* READ ERROR
S44T33 LDA KM1; STA RAER3; LDX KM8
S44T28 LDA SRT44E,2; SKE ZERO; BRU *+2; BRU S44T29; SKE ENSRT,2
       BRU *+2; BRU S44T29; STX S44T10
       SKG =NCMEM-1; ADD SWSMT; ADD SWPMT; MRG X4
       STA S44T43; BRM SWLSC
       BRU S44T44; LDA S44T43
       DIR; BRM REL; EIR
S44T44 LDX S44T10
S44T29 BRX S44T28; DIR; BRM RAGO; EIR
* RELEASE REMAINING OLD PAGES
       LDX KM8
S44T34 LDA ENSRT,2; SKE ZERO; BRU *+2; BRU S44T35; SKE SRT44E,2
       BRU S44T35; STX S44T10; SKG =NCMEM-1; ADD SWSMT; ADD SWPMT
       MRG X4; DIR; BRM REL; EIR
       LDX S44T10
S44T35 BRX S44T34; DIR; BRM RAGO; EIR; LDX PACPTR
       LDA STRL1; LDB STRL2; STA RL1,2; STB RL2,2
       LDB STRLD; MIN 0; STB PACDMS; LDA PACPTR
       LDX =QTI; BRU POPR4
* UNPACK RELABELING
* INPUT: A,B=RELABELING, X=TABLE ADDRESS
UPRL44 ZRO; STB SWT3; LRSH 18; STA 0,2
       CLA; LCY 6; STA 1,2; CLA; LCY 6; STA 2,2
       CLA; LCY 6; STA 3,2; LDA SWT3; LRSH 18; STA 4,2
       CLA; LCY 6; STA 5,2; CLA; LCY 6; STA 6,2
       CLA; LCY 6; STA 7,2; BRR UPRL44
* CHANGE RL1,RL2 AND DISMISS ON OLD QUEUE.
STDMS  EIR; LDB PACPTR; LDX JOB; LDA X4; BRM RELPG
       LDX PACPTR; LDA STRL1; LDB STRL2; STA RL1,2; STB RL2,2
       LDB STRLD; MIN 0
       STB PACDMS; LDA PACPTR
       IF SUPER; SKN SVST; BRU *+3; LDX =QSQ; BRU POPR4; ENDF
       SKN PACJOB; BRU POPR5 (DISMISS SWAP JOB ON SAME OR NEXT QUEUE)
       LDX =QTI; BRU POPR4 (DISMISS ON QTI IF WE ARE A DRUM JOB)
NSRT   BSS 8   UNPACKED RELABELING
ENSRT  BSS 0
S44T43 ZRO   0    TEMP STORE FOR ERRORS
S44T10 ZRO 0   TEMP STORE FOR X
S44T5  DATA -1   COUNT OF NEW NON-ZERO BYTES
S44T12 DATA -1   COUNT OF NEW 0 BYTES, COUNT OF MISSING PAGES
STRLD  24B PACDMB
       IF SUPER
S44P2  ZRO 0 NO. OF TIMES THE SUPERVISOR'S BEEN HERE.
S44P3  ZRO 0  N0. OF TIMES RAJOB1=0.
       ENDF
STRL1  ZRO     0               NEW RELABELLING WORDS FOR BRS 44
STRL2  ZRO     0
*
* BRS 117 SET PROGRAM RELABELING IN TS BLOCK
SURL   CLX; SKN EXEC1; BRU *+2; LDX X1; SKN SYSS; BRU *+2; LDX X3
       SKN EXECS; BRU *+2; LDX X7
       BRM SCRL; TRAP 34; LDA SS01; LDB SS02
       STA UPRRL1; STB UPRRL2; BRU POPX
*
* UNPACK RELABELING AND CHECK FOR LEGALITY.
* INPUT: A=RL1, B=RL2
* INPUT: X=X7 FOR EXEC, X3 FOR SYSTEM, X1 FOR SUBSYSTEM, 0 FOR USER
* OUTPUT: X=PACPTR IF IT SKIPS
* NO SKIP: A PMT ENTRY=0 OR USER TRIED TO RELABEL AN EXEC PAGE.
* SKIP: RELABELING OK.
SCRL   ZRO; STX STRL5; XXA; LSH 1; STA STRL52; LSH 1; STA STRL51
       LRSH 2; XXA; CLX; BRM UPRL; LDX KM10D
STRL3  LDA SRTE,2; SKE ZERO; BRU *+2; BRU STRL7; SKG =NCMEM-NUSMT
       BRU STRL6
STRL7A BRM CRTA; BRR SCRL; CBX; STA STRL9
       LDB =77B5; SKM =12B5; BRU STRL8; ETR ADMSK
       SKG =EXSMTE; BRU *+2; BRR SCRL; SKG =EXSMT1; BRU STRL10
       SKN STRL51; BRU *+2; BRU STRL41; STA S44T62; LDA* S44T62
       SKA X2; BRU STRL41; BRR SCRL
STRL10 SKG =PMTE; SKG =PMTM1; BRU *+3; SKN STRL5; BRR SCRL
       SKG =USMT; SKG =SMT; BRU *+3; SKN STRL5; BRR SCRL
STRL41 LDA STRL9; SKA X1; BRU STRL8; SKN STRL5; BRR SCRL
STRL8  SKA X2; BRU STRL4
STRL7  BRX STRL3; MIN SCRL; LDX PACPTR; BRR SCRL
STRL4  SKA X1; BRU STRL11; SKN STRL5; BRR SCRL; BRU STRL7
* PAGE IS READ ONLY
STRL11 SKN STRL52; BRR SCRL; BRU STRL7
* CHECK FOR SUBSYSTEM
STRL6  SKN STRL51; BRR SCRL; BRU STRL7A
STRL5  ZRO 0   NEG. FOR EXEC
STRL51 ZRO 0   NEG. FOR SUBSYSTEM
STRL52 ZRO 0   NEG. FOR SYSTEM
STRL9  ZRO 0
STRL61 ZRO 0
*


*
*
* BRS 10
PPAN   LDA 0; CLB; LDX =QTI; BRM PTRAP
*
*
* BRS 70   COUNT FREE PMT ENTRIES
* RETURNS NO. OF FREE PMT ENTRIES IN A
FRPMT  LDX JOB; LDA PMTP,2; ADD =NUMEM+250B5; STA FRP2
       LDX =-NUMEM; CLA; STA SS01
FRP2   SKE 0,2; BRU *+2; MIN SS01; BRX *-3; BRU POPX

* TRAP ROUTINES FOR DISC<3.  SEE "I" WHEN DISC=3.
       IF DISC<3
*
*
*     TRAP ROUTINES
*
* ILLEGAL INSTRUCTION TRAP
$TRAPI  ZRO; STA SS01; STB SS02; STX SS03
       LDX PACPTR; LDA RL2,2; ETR =77B2
       SKE =16B2; BRU *+4; LDA RRL2; XMA RRL1; BRM MONCR (SAVES PAGES FOR CRASH)
       LDA TRAPI; LDB ONE; LDX =QTI; BRM PTRAP
*
*GENERAL TRAP LOGIC
* INPUT: A=TRAP LOC., B=REASON, X=QUEUE FOR NEW FORK.
       TLABEL PTP
$PTRAP  ZRO; STX PTRPA
       CAX; LDA =600B; MRG RLTS; BRM PTPL
       LDA RRL1; STA PTRL1; LDA RRL2; STA PTRL2; LDA RRL3; STA PTRL3; CXA
       LDX PACPTR; SKG KM1; BRU *+2; LDA 0; ETR =50037777B
       IF ALOG; DIR; LOGG 56B,PTRAP; EIR; ENDF
       STA PL,2; SKN XPB; BRM MONCR
       LDX XPB; LDA SS02; STA PB,2; LDA SS01; STA PA,2
       LDA SS03; STA PX,2
       IF      FPH
       HFST    FAC1,FAC2
       ENDF
       LDX     PACPTR
       BRM RFK; LDA PTRPA; BRM TFK; STA FK04

SUPBUG EQU 1
       IF SUPBUG
       IF SUPER
* CRASHES SYSTEM ON SUPERVISOR ERROR WHILE WE STILL HAVE SOME HOPE OF
* FINDING THE CLUE IN CORE.
       SKN SVST; BRU PTRPB; COPY AX,A; SKE PPTR,2; BRU PTRPB
       SKE 211B; BRM MONCR
       ENDF
       ENDF

PTRPB  LDX TF07; STX STFK2; LDA PTRL1; LDB PTRL2; LDX PTRL3
       BRM LABEL; BRM FKGO3
PTRL1  ZRO 0
PTRL2  ZRO 0
PTRL3  ZRO 0
PTRPA  ZRO 0   QUEUE FOR NEW FORK
$TRAP  ZRO 0; BRM MPPACT; SKN XPB; BRU *+3; LDA TRAP; STA ERCODE
       LDA SBRSRT; SKN 0; STA 0; LDA 0; LDB ONE; LDX =QTI; BRM PTRAP
*READ-ONLY TRAP
       TLABEL  TPR
$TRAPR  ZRO; STA TR01; STB TR02; STX TR03
       LDA TRAPR; ETR =50037777B; STA TR00; MIN TRPXMA
       BRM CAE; NOP; SKR TRPXMA; ETR =34000B; MUL =6B4; STA TPR4
       LDA RLTS; MRG =06B2; BRM TPRL
       LDX PUPAC; LDA RL2,2; LDB RL1,2
       LDX TPR4; LCY 6,2; ETR K77; SKG =NCMEM-1; BRU TPR26
       ADD PMTJOB; ETR ADMSK
TPR25  CAX; LDA 0,2; SKA X1
       BRU TPR3 (REALLY RO); CXA
       DIR; BRM W; EIR
       IF TSTAT; MIN NPGDRT; ENDF
       LDX TPR4; LDB RRL1; LDA RRL2; LCY 6,2; ETR =77777737B
       RCY 6,2; LDX RRL3; XAB
       SKN PACJOB; BRU TPR22; BRM STCMRL STORE COMPUT JB RELAB
TPR22  BRM LABEL
       LDA TPRL1; BRM TPRL
       IF      FPH
       LDA*    TR00
       LDB     =157B5
       SKM     =13B5
       BRU     *+2
       SKR     TX00
       BRU     *+1
       ENDF
       ROV; LDA TR00; LCY 1; LSH 1
       LDA TR01; LDB TR02; LDX TR03; BRU* TR00
TPR3   LDA TR01; STA SS01; LDA TR02; STA SS02; LDA TR03
       STA SS03; LDA TRAPR; SKA X4; STA 0; BRM MTRAP
TPR26  ADD =SMT; BRU TPR25
TPR4   ZRO 0
TR00   ZRO 0
TR01   ZRO 0
TR02   ZRO 0
TR03   ZRO 0
$TRPXMA ZRO XMA41
XMA41  XMA 41B
XMA43  XMA 43B
*MEMORY TRAP

       TLABEL TPM
$TRAPM  ZRO;*   MEMORY TRAP INTERRUPT ROUTINE
       IF BUG
       STA TT01; LDA TRAPM; ETR =40037777B
       SKE =TT0M; BRU *+2; BRM MONCR; LDA TT01
       ENDF
       STA TX01; STB TX02; STX TX03
       LDA TRAPM; ETR =50037777B; STA TX00; BRM CAE
       MRG =40000B (MEMORY MUST COME FROM A HIGHER FORK)
       STA TT01; LDA =0600B; MRG RLTS; BRM TPML (MAP PMT); LDA TT01
       LDX PACPTR; BRM MGET; BRU TX05
       LDA TPML1; BRM TPML   (RESTORE RELABELLING)
       IF      FPH
       LDA*    TX00
       LDB     =157B5
       SKM     =13B5           CHECK FOR POT OR PIN FROM FP
       BRU     *+2
       SKR     TX00
       BRU     *+1
       ENDF
       ROV; LDA TX00; LCY 1; LSH 1
       LDA TX01; LDB TX02; LDX TX03; BRU* TX00
TX05   SKN TRAPM; BRM MTRAP
       LDA TX01; STA SS01; LDA TX02; STA SS02; LDA TX03; STA SS03
       LDA TX00; SKA X4; STA 0; BRM MTRAP
MTRAP  0; LDX PACPTR; LDA K1B6; BRM RIIR
MTPAN  LDA 0; LDB TWO; LDX =QTI; BRM PTRAP
TX00   ZRO
TX01   ZRO
TX02   ZRO
TX03   ZRO
       IF      BUG
$TT01   ZRO 0
       ENDF
       ENDF DISC<3

*      BRS 7     READ OR WRITE A TABLE IN THE MONITOR MEMORY
*      A=USER CORE ADRS, SIGN BIT ON FOR WRITE. X = TABLE NUMBER.
*      RWTAB MACRO SETS UP A SINGLE WORD ENTRY IN THE TABLE OF 
*           ACCESSABLE MONITOR TABLES.
*      AN ENTRY HAS BITS 10-23 AS THE TABLE ADRS. BITS 4-9 ARE THE TABLE
*           SIZE. BITS 0,1 ARE THE MINIMUM STATUS REQUIRED TO WRITE
*           THE TABLE AND BITS 2,3 ARE THE READ STATUS.

RWTAB  MACRO D;* CALLED WITH 4 ARGS      TABADR,TABSIZ,WSTAT,RSTAT
D2M1   EQU D(2)-1   SIZE ARGUEMENT MINUS 1
DTAG   EQU 2*D(3)+D(4)/2  BITS 0,1 FOR WR STATUS, BITS 2,3 FOR READ STAT
DOP3   EQU D(4)-D(4)/2-D(4)/2 1ST BIT OF OP FIELD IS 2ND BIT OF RD STAT
DOP2   EQU D2M1/2+DOP3*40B  CREATE OP FIELD
DOP1   OPD DOP2*1B5
       IF D2M1-D2M1/2-D2M1/2
       DOP1* D(1),DTAG; ELSE; DOP1 D(1),DTAG; ENDF
       FRGT RWTAB,D2M1,DTAG,DOP1,DOP2,DOP
       ENDM

RWTAB1 EQU *   TABLE OF MONITOR TABLES ACCESSABLE TO THE USER
       RWTAB   MISC,47B,3,SYS  COUNTERS TYPED OUT BY *1COUNT, TABLE 0
       RWTAB   RAERL,20,3,SYS  RAD ERROR TABLE, TABLE 1
       RWTAB   IDER2,10,3,SYS  DISC ERROR LIST, TABLE 2
       IF TSTAT
       RWTAB   QTIGO,32,3,SYS  SWAPS/ACTIV. COND, TABLE 3
       ELSE
       RWTAB   WASTE,1,3,SYS   NOT USED
       ENDF
       RWTAB   210B,6,3,SYS    BASE-HOST COMMUNICATIONS, TABLE 4
       RWTAB   RMT,NMEM,3,SYS  REAL MEMORY TABLE, TABLE 5
       RWTAB   GFLG,NFILE,3,SYS   GLOBAL FILE NUMBERS, TABLE 6
       RWTAB   TTNO,NJOB,3,SYS   JOB TO PORT CONVERSION, TABLE 7
       RWTAB   ALARM,1,3,SYS   ALARM, TABLE 8
       RWTAB   XBP,NFILE,3,SYS    GLOBAL X BLOCK PTRS, TABLE 9
       RWTAB   DSCTOP,1,3,SYS  HIGHEST DISC ADDRESS, TABLE 10
       RWTAB   MACH,1,3,0      MACHINE NUMBER, TABLE 11
       RWTAB   EQPT,1,3,0      FOR THE MAP, TABLE 12
       RWTAB   STACT,2,3,0     TABLE 13
       RWTAB   WERIS,NPORT,3,SYS LUD LOC TABLE, TABLE 14
       RWTAB   PMTP,NJOB,3,SYS PMT PTRS FOR EACH JOB, TABLE 15
       RWTAB   CPARW,NJOB,3,SYS CONTROL PARAMETERS, TABLE 16
       RWTAB   AUNN,NJOB,3,SYS USER NUMBERS, TABLE 17
       RWTAB   FGLIST,NJOB,3,SYS F.D. GROUP LIST, TABLE 18
       RWTAB   ADRSMT,56,3,SYS MISC MONITOR CELLS, TABLE 19
       RWTAB   RAFR,32,3,SYS   RAD BIT MAP, TABLE 20
       RWTAB   ETTB,NJOB,3,SYS COMPUTE TIME, TABLE 21
       IF PTICK
       RWTAB   PTCKS,NJOB,3,SYS PAGE TICKS, TABLE 22
       ELSE
       RWTAB   SWPCNT,NJOB,3,SYS       SWAPCOUNT, TABLE 22
       ENDF
       RWTAB   CCT,NJOB,3,SYS  CHARACTER COUNT, TABLE 23
       RWTAB   TTYASG,NPORT,3,SYS PACPTRS/PORT TABLE 24
       IF TSTAT
       RWTAB   Q0,40,3,SYS
       ELSE
       RWTAB   Q0,30,3,SYS     MONITOR QUEUES, TABLE 25
       ENDF
       RWTAB   MONTAB,2,3,SYS  ADDRESSES TO PEEK AT
       RWTAB   UEXFLG,1,3,0    JOB STATUS
       RWTAB   DBITS,1,3,0     AVAIL DISC BLOCKS
       RWTAB   UFLAG,1,0,0     USER SETABLE TABLE, TABLE 29.
       RWTAB   TYMTIM,1,3,0    TYMSHARE TIME.  TABLE 30.
       RWTAB   SERIAL,1,3,0    SERIAL NO.   TABLE 31.
       RWTAB   DSCTPD,1,3,SYS  MAX DISC ADDR ALLOWED BY DISCRW.  TABLE 32.
       RWTAB   UTTY,1,3,SYS    PORT NO.  USE WITH BRS 87 TO GET JOB NO.
RWTABN EQU *-RWTAB1     LENGTH OF TABLE
WASTE  ZRO
*
* MONTAB CONTAINS THE ADDRESS OF CELLS TO USE THE BRS 127 ON
$MONTAB ZRO PNEXT; ZRO PPTR
*

BRS7   CXA; SKG =RWTABN-1; SKG KM1; TRAP 43    (ILLEGAL TABLE);
       LDA RWTAB1,2; SKN SS01; LCY 2; LRSH 1; SKG PRILEV
       BRU *+2; TRAP 44   (READ OR WRITE STATUS INSUFFICIENT)
       LDA RWTAB1,2; STA LP; RSH 14; ETR K77; ADD ONE  (TABLE SIZE)
       COPY AB,N; COPY AX,N   SIZE IN A AND B. NEGATIVE SIZE IN X.
       ADD SS01; ETR =40037777B; STA SS01 UPDATE USER'S POINTER; MRG X4
       XAB; ADD LP; ETR ADMSK    USER ADRS IN B , MONITOR ADRS IN A
       SKN SS01; XAB (HE WANTS TO READ, NOT WRITE);
       ADD =235B5 (STA 0,2); STA LP+1; CBA; ADD =276B5 (LDA 0,2); STA LP
LP     0; 0; BRX LP; BRU POPX

* PEBRS    BRS 127
* READS A WORD IN MEMORY.
* INPUT: X=LOC. OF WORD
* OUTPUT: A= CONTENTS OF WORD.
PEBRS  EQU *
       LDA SS03; SKG K1S5; SKG KM1; TRAP 45
       SKG =ETBO+14B3; SKG =[TBI-1]+14B3; BRU *+2; BRU POPX
       RSH 11; ETR K37; MRG =600B; XMA RRL3; STA PEB2
       LRR3; POT RRL3; CLA; LSH 11
       LDB K77; SKB RRL3; ADD =34000B
       CAX; LDA 0,2
       STA SS01; LDA PEB2; XMA RRL3; LRR3; POT RRL3; BRU POPX
PEB2   ZRO 0   TEMP STOARAGE FOR RRL3
*
* BRS 5   RETURN STATUS OF CALLING FORK
* RETURN: A=1=SUBSYSTEM, A=3=SYSTEM, A=7=EXEC
*         A=0=NO STATUS
FKSTAT LDA PPTR,2; MRG PLMSK; SKA PRMSK; BRU *+2; LDA PACPTR
       COPY AX,A; LDB X2; SKB PTAB,2; MRG ONE; LDB K400
       SKB PIM,2; MRG FOUR; LDB K200; SKB PIM,2
       MRG TWO; BRU POPXB
*
*
*
*

*
*      FORK LOGIC
*
* FIND HIGHEST FORK IN STRUCTURE
HFK    ZRO; LDA XPB; ETR X4; STA XPB; STA STFK2
HFK1   LDA PPTR,2; SKA PRMSK; BRU *+2; BRR HFK
       MRG PLMSK; CAX; BRU HFK1
* GET FORK ENTRY.
GFK    ZRO; LDA FPLST; SKG ZERO; BRR GFK
       SUB =PPTR; COPY AX,A
       XMA PPTR,2; STA FPLST
       SKR PACFC (REDUCE PACT FREELIST CTR)
       LDA PACFC; SKG SPARE2; STA SPARE2 (LEAST PACT FREELIST CTR)
       MIN GFK; BRR GFK
* SET PDOWN(OLD)=NEW, PDOWN(NEW)=0
*     PFORK(NEW)=OLD, PPAR(NEW)=PDOWN(OLD)
* SET PTEST TO 7@ 2.
STFK   ZRO; STX FK04; SKR NFORK; BRU *+2; BRM MONCR
       LDX PPB; LDB PB,2; STB PPB; CXB; STB STFK2
       LSH 3; LDX FK04; STB PIM,2; CXA
       LDX PACPTR; LSH 12
       ETR PLMSK; XMA PPTR,2; ETR PRMSK; ADM PPTR,2
       LDA FK04; COPY XA,AX,B; ETR PRMSK; STA PPTR,2
       LDA STFK3; STA PTEST,2
       LDX PACPTR; BRR STFK
$STFK2  ZRO 0    XPB FOR NEW FORK
STFK3  7B 2   ACT. COND. BEFORE FORK RUNS.
$FK04   ZRO 0   NEW PACPTR
PACFC DATA NPAC PACT FREELIST COUNTER
*
* DELETE PAC ENTRY WHOSE PACT PTR IS GIVEN IN X
DFK    ZRO; IF ALOG; DIR; LOGG 21B,DFK; LOGG 21B,PACPTR; EIR; ENDF
       CXA;  STX DF01; LDA =700000B; BRM QSCH
* REMOVED FROM QUEUE IF DISMISSED
       LDA PPTR,2; SKA PRMSK; BRU *+2; BRR DFK (EXEC NOT DELETED)
       MIN NFORK
* REMOVE PB POINTER
       LDA PIM,2; RSH 3; ETR SEVEN; LDX PPB; XXA
       STA PB,2; STX PPB; LDX DF01
DF08   LDA PPTR,2; MRG PLMSK
       COPY AB,XA; LDX UTTY
* PFORK IN B, PACT PTR IN A
       SKE TTYASG,2; BRU *+2; STB TTYASG,2 (PROPAGATE RUBOUT 'UP')
* PUT PFORK IN X, PDOWN(PFORK) IN A
       CBX; LDA PPTR,2; RSH 12; SKE DF01; BRM MONCR
       COPY XB,AX
* LAST FORK ON PDOWN TO BE CLEARED- PUT PFORK IN X, PACT PTR IN B
       XXB; LDA PPTR,2; ETR PRMSK; STA PPTR,2; COPY BX,BA
* PUT PACT ENTRY ON FPLST
       ADD =PPTR; XMA FPLST; STA PPTR,2
       MIN PACFC (CURRENT PACT FREELIST CTR)
       BRR DFK
DF01   ZRO
*

* SEARCH SUBSIDIARY FORK STRUCTURE FOR SPECIFIED FORK
*      SKIP IF PRESENT, NO SKIP IF TERMINATED
SHFK   ZRO; LDA PPTR,2; SKA PLMSK; BRU *+2; BRR SHFK; RSH 12
       CAX; LDA PTAB,2; EOR SS01; SKA ADMSK; BRR SHFK
       MIN SHFK; BRR SHFK
* SCAN FORK STRUCTURE AND OPERATE
*      A= OPERATION
*      X= PACPTR
*      THE OPERATION SPEC. BY A IS CALLED WITH CORRECT PACPTR IN X
*      PERFORMS OP FOR ALL LOWER AND PARALLEL FORKS.
SCFK   ZRO; STA SCF01; STB SCF02; STX SCF03; CXA
* SCAN TO LOCAL 'BOTTOM'
SCF06   SKN PPTR,2; BRU SCF07
       LDA PPTR,2; RSH 12; CAX; BRU SCF06
SCF07  CXA; SKE SCF03; BRU SCF05
* PERFORM OP AND EXIT
       BRM* SCF01; LDB SCF02; LDX SCF03; BRR SCFK
* PERFORM OP AND GO 'UP'
SCF05 LDA PPTR,2; MRG PLMSK; STA SCF04; BRM* SCF01; LDX SCF04; BRU SCF07
SCF01   ZRO 0   OPERATION
SCF02   ZRO 0   STATUS WORD
SCF03   ZRO 0   PACPTR
SCF04   ZRO
*
* TERMINATE FORK STRUCTURE
* INPUT: X=PACPTR OF LOWER FORK, A=QUEUE, B=STATUS WORD
* OUTPUT: A=TF06=PACPTR FOR NEW FORK, X=TF05=QUEUE FOR NEW FORK
TFK    ZRO
       STA TF05; STB TF12; STX TF01
       LDB TF12; LDA PPTR,2; STA TF01; LDA PTAB,2; STA TF06
       LDA =DFK; BRM SCFK; LDA TF01; STX TF01; SKA PRMSK; BRU TF02
* EXEC TOP-LEVEL PANIC
       LDA TF10; STA PTEST,2; SKN XPB; BRM MONCR
       LDX XPB; LDA UEXL6; STX TF07
       STA PX,2 (SAVE STATUS); LDX TF01
       LDA TFC01; XMA PL,2; STA TFC02; MIN TFC02
       BRU TF09
* ORDINARY PANIC
TF02   MRG PLMSK; COPY AX,AB; LDA PIM,2; RSH 3; ETR SEVEN; STA TF07
       CXB
* DISMISSED ON ACT. COND. 7
       LDA TF13; STA PTEST,2; MIN PL,2
       SKN XPB; BRM MONCR; LDX TF07
       LDA TF06; ETR ADMSK; STA PA,2; LDA SCF02
       STA PX,2; CBX
TF09   CXA;  STX TF06; LDX TF05; BRR TFK
$TF01  ZRO
TF12   ZRO
TF10   20B PACDMB   EXEC PANIC
TF13   21B PACDMB   ORDINARY PANIC
TF05   ZRO 0   QUEUE FOR NEW FORK
$TF06  ZRO 0   PANIC TABLE ADDRESS
$TF07   ZRO 0   FORK NUMBER FOR HIGHER FORK
TFC01  ZRO EXECP,4
TFC02  ZRO 0   PL BEFORE IT BECAME EXECP,4

* READ FORK STATUS
* INPUT: B=STATUS, X=PACPTR OF FORK TO BE READ
RFK    ZRO; LDA PIM,2; EOR =300B; SKA =300B; BRU RF12 (NOT EXEC BRS)
       LDA PPTR,2; MRG PLMSK; CAX
RF12   LDA =RF06; BRM SCFK
       LDX JOB; STX SWJOB; LDX =NCMEM; CLAB; BRM SWAPI
       BRM LABEL
       LDB SCF02; LDX SCF03; BRR RFK
*
* INPUT: X=PACPTR OF LOWER OR PARALLEL FORK.
RF06   ZRO
       STX RF08; LDX JOB; STX SWJOB; LDX =NCMEM; CLAB
       BRM SWAPI; BRM LABEL; LDX RF08
       LDA PL,2; SKA X4; BRU *+2; LDA SBRSRT; STA RF14
       CXA; EOR SCF03; SKA ADMSK; BRU RF10
       LDB SCF02; SKB X4; BRU *+2; BRU RF07
RF10   LDA PTEST,2; ETR ADMSK; LDB KM1; SKE PACDMB; LDB KM2
RF07   LDA PIM,2; EOR =300B; SKA =300B; BRU *+3; CXA; BRU RF11 (EXEC BRS)
       LDA PPTR,2; SKA PRMSK; BRU *+2; CXA (TOP-LEVEL EXEC)
RF11   MRG PLMSK;  STA RF13; STB RF17
       LDA PIM,2; RSH 3; ETR SEVEN; STA RF15
       LDA PTAB,2; ETR ADMSK; MRG X4; STA RF08
       CXA; ADD RFC01; STA RF16; LDA RF08
       ETR =34000B; LRSH 11; MUL THREE
       LDX RF13; LDA RL1,2; LDX RL2,2; XXB; RCY 18; LCY 0,2
       STX RF33
       ETR K77; SKE ZERO; BRU *+2; BRR RF06
       STA RF32
       IF TSTAT; LDB =QTIGO+26B; STB RFR; ENDF
       LDB THREE; STB RF02
       LDB JOB; STB SWJOB; CLB; RCY 0,2; LCY 18
       LDX =NCMEM; STA RFRL1; STB RFRL2; STX RFRL3
RF03   BRM SWAPR; BRU RF04 (PANIC TABLE PAGE AND TS)
       BRM LABEL
       LDA RF32; ADD PMTJOB; DIR; BRM W; EIR; LDX RF33
       LDB RRL1; LDA RRL2; LCY 6,2; ETR =77777737B
       RCY 6,2; LDX RRL3; XAB; BRM LABEL
       LDA RF14; STA* RF08; MIN RF08 (SAVE PL)
       LDX RF15; LDA PA,2; STA* RF08; MIN RF08
       LDA PB,2; STA* RF08; MIN RF08
       LDA PX,2; STA* RF08; MIN RF08; LDX KM2
RF16   LDA PL4,2; STA* RF08; MIN RF08; BRX *-3
       LDA RF17; STA* RF08
* RELEASE PANIC TABLE AND TS BLOCK
       LDX JOB; LDA PMTP,2; ADD =-NCMEM; STA RELPG3
       LDA X4; STA RELPG8; LDA RFRL1; LDB RFRL2; LDX RFRL3
       BRM RELMEM; BRR RF06
* CAN'T READ PANIC TABLE PAGE
RF04   SKR RF02; BRU *+2; BRR RF06
       LDA RFRL1; LDB RFRL2; LDX RFRL3; BRU RF03
RF02   ZRO 0   READ ERROR RETRY COUNT
RF08   ZRO
RF13   ZRO
RF14   ZRO
RF15   ZRO 0   PB POINTER OF FORK TO READ
RF17   ZRO 0   STATUS WORD
RF32   ZRO 0
RF33   ZRO 0
RFC01  LDA PL4,2
RFRL1  ZRO 0   PANIC TABLE AND TS BLOCK RELABELING
RFRL2  ZRO 0
RFRL3  ZRO 0
*
* BRS 9   START SUBSIDIARY FORK
* INPUT: SS01=A=BITS + PANIC TABLE ADDRESS
*        BITS: 0=EXEC, 1=PANIC TABLE REL., 2=PROP. RUBOUT
*              3=FIXED MEMORY, 4=LOCAL MEMORY, 5=SUBSYSTEM STATUS
*              6=SYSTEM STATUS, 7=SUBSYSTEM INDEX
FKST   SKN PIM,2; BRU *+2; TRAP 46
       ETR K3777; ADD SIX; SKA K4000; TRAP 47  (PANIC TABLE OVERLAP)
       IF ALOG; DIR; LOGG 57B,XPB; EIR; ENDF
       LDA SS01; BRM SHFK; BRU *+2; TRAP 48  (TRIED TO RESTART SAME FORK)
       LDA NFORK; SKG ZERO; TRAP 49
       BRM GFK; BRU FKSTW (DISMISS UNTIL PACT SLOT FREE); BRM STFK
       CLB; LDA SS01; SKA X4; BRU FK20 (EXEC STATUS)
FK24   SKA K4B5; BRU FK21
FK25   SKA K1B6; BRU FK22
FK23   STA SS01; STB FK09A
       LDX FK04; LDB SS01; LDA PIM,2
       SKB X4; MRG K400; SKB K4B5; MRG K200; SKB K4B6
       MRG X4; STA PIM,2
       CBA; ETR ADMSK; LRSH 15; LDA JOB; LSH 15
       SKB K2B6; MRG X4; SKB K1B6
       MRG X2; MRG X1; STA PTAB,2
* PROPAGATE TTYASG DOWN IF CALLED FOR AND FORK HAS TTYASG
       LDA UTTY; SKG KM1; BRU FK07A
       CAX; LDA PACPTR; SKE TTYASG,2; BRU FK07A
       LDA FK04; SKB X1; STA TTYASG,2
FK07A  LDX PACPTR; LDA SS01; SKA X2; BRU FK08
       LDA RL1,2; LDB RL2,2
       LDX FK09A; BRM SCRL; BRU FK08B; LDX PACPTR
       LDA RL1,2; LDB RL2,2
* STORE RELABELLING, INITIAL A,B,X,L
FK09   LDX FK04; STA RL1,2; STB RL2,2; LDX SS01
       LDA 2,6; LDB 3,6; LDX STFK2; STA PB,2; STB PX,2
       LDX SS01; LDA 1,6; LDX STFK2; STA PA,2
       LDX SS01; LDA KM1; STA 6,6 (SET STATUS WD TO RUNNING)
       LDA 0,6; ETR =50037777B; SKN 0; BRU *+2; MRG X4
       LDX FK04; STA PL,2
       LDB =700006B; BRM FKGO
* PICK UP RELABELLING FROM PANIC TABLE
FK08   CAX; LDA 4,6; LDB 5,6; LDX FK09A
       BRM SCRL; BRU FK08B; LDX SS01; LDA 4,6; LDB 5,6; BRU FK09
FK08B  LDX FK04; BRM DFK; TRAP 50
* DISMISS UNTIL PACT SLOT IS RELEASED
FKSTW  LDB =FPLST; LDX =QTI; BRU NPOPDS
FK20   SKN EXECS; BRU *+4; MRG =414B5; LDB X7
       BRU FK23; ETR K3S7; BRU FK24
FK21   SKN SYSS; BRU *+4; MRG =14B5; LDB X3
       BRU FK23; ETR =37377777B; BRU FK25
FK22   SKN EXEC1; BRU *+3; LDB X1; BRU FK23
       ETR =36377777B; BRU FK23
FK09A  ZRO 0   STORAGE FOR RELABELLING STATUS
*
* DO NOT DISMISS EXEC BRS AND BRS 9 FORKS.
FKGO   ZRO; LDX PACPTR; STB PTEST,2
       LDA 0; ETR =50037777B; XMA PL,2; ETR =77B5; ADM PL,2
       SKN XPB; BRM MONCR; LDX XPB; LDA SS02; STA PB,2
       LDA SS01; STA PA,2; LDA SS03; STA PX,2; BRM FKGO3
$FKGO3  ZRO
       LDX STFK2; LDA PA,2; STA SS01; LDA PB,2; STA SS02
       LDA PX,2; STA SS03; BRM FKGO2
FKGO2  ZRO; LDA KM1; STA DNTERM
       LDX PACPTR; LDA RL1,2; LDB RL2,2
       LDX FK04; XMA RL1,2; STA STRL1; CBA; XMA RL2,2
       STA STRL2; STX PACPTR; STX PUPAC
       SKR PL,2; NOP; SKN PACJOB; BRU *+2; STX PACOMP
       LDA PL,2; STA 0; BRM STSTAT
       LDA PIM,2; LRSH 3; ETR SEVEN; MRG X4; STA XPB
       LDX JOB; DIR; LDA TTNO,2; ETR =77776077B; STA TTNO,2
       EIR; LDX PACPTR; LDA =700001B; STA PTEST,2
       LDA STRL1; LDB STRL2
       IF ALOG; DIR; LOGG 20B,FKGO; LOGG 20B,PACPTR; EIR; ENDF; BRU STRLQ
*
* BRS 31
* WAIT FOR SPECIFIED FORK TO TERMINATE
* INPUT: A=PANIC TABLE ADDR.
* OUTPUT: X=STATUS
FKWT   BRM SHFK; BRU FK01; BRM MONCR
FK01   LDX SS01; LDA 6,6; STA SS03; BRU POPX
*

* PROGRAMMED INTERRUPT LOGIC
*
* BRS 49   READ INTRRUPTS
SRIR   LDA PIM,2; ETR =37777100B; BRU XPOPX
*
*
* BRS 135 START TIMER FORK (RETURN FROM W PAGE)
$B135E BRM MPPACT
       LDA PIM,2
       MRG K1B5
       BRU SAIR
* BRS 194 KILL TIMER FORK (RETURN FROM W PAGE)
$B194C BRM MPPACT
       LDA PIM,2
       ETR =-1-1B5
* BRS 78   ARM INTERRPUTS
SAIR   ETR =3777000B
       IF MDSI; SKN EXEC1; ELSE; SKN SYSS; ENDF
       ETR =3776000B (DO NOT ARM INT. 11)
       XMA PIM,2; ETR =74000777B; ADM PIM,2; BRU POPX

ENDBRS BSS 0
       END
MONITOR ** FICHE/FRAME BREAK *****
B SYMSORT

SYM.  PG.LN. IDENT.

APMTE  13 30 B       B135E  32 21 B       B194C  32 26 B       
BRS     2 15 B       BRS61   7  1 B       BRS7   24 36 B       BRSRET  6 10 B       
BS      2 16 B       BS1     2 18 B       BS10    4 39 B       BS12    5  1 B       
BS14    4 38 B       BS16    5  2 B       BS2     4 36 B       BS20B   5  3 B       
BS22    5  6 B       BS23    4 34 B       BS24    5  7 B       BS25    5  8 B       
BS3     4 29 B       BS4     4 35 B       BS6     4 37 B       BSFT    2 19 B       
BST     3  3 B       BSTU    4 28 B       BSX     2 10 B       CLFK   11 38 B       
CRTA   14 11 B       CRTA1  14 14 B       CRTA2  14 13 B       CTRU   12 15 B       
CTRU   12  8 B       CTRU   12  5 B       CTRU1  12 19 B       CTRU1  12 12 B       
CTRU2  12 13 B       D2M1   23 11 B       DF01   27  8 B       DF08   26 34 B       
DFK    26 26 B       DFR     7 16 B       DOP1   23 15 B       DOP2   23 14 B       
DOP3   23 13 B       DPMTE  13 39 B       DTAG   23 12 B       ENDBRS 32 35 B       
ENSRT  18  9 B       EPOPX   6  4 B       EXR2    6 36 B       EXRA    6 37 B       
EXRETE  6 23 B       FK01   32 11 B       FK04   26 22 B       FK07A  30 38 B       
FK08   31 12 B       FK08B  31 14 B       FK09   31  4 B       FK09A  31 23 B       
FK20   31 17 B       FK21   31 19 B       FK22   31 21 B       FK23   30 27 B       
FK24   30 25 B       FK25   30 26 B       FKGO   31 26 B       FKGO2  31 33 B       
FKGO3  31 30 B       FKST   30 18 B       FKSTAT 25 25 B       FKSTW  31 16 B       
FKWT   32 10 B       FRP2   19 32 B       FRPMT  19 30 B       GFK    26  3 B       
H3      4 27 B       H4      4 30 B       HFK    25 38 B       HFK1   25 39 B       
HLDA   10  7 B       HLDB   10  8 B       HLDC   10  9 B       HLDR   10 11 B       
KP06   12 22 B       KP24   12 21 B       KP96   12 20 B       LP     25  6 B       
MBRO   11 22 B       MBRO3  11 30 B       MBRO5  11 31 B       MBRO7  11 29 B       
MDEL    8 36 B       MDELC   9 34 B       MDL5    8 39 B       MGET    7 35 B       
MGET1   7 26 B       MGET10  8  7 B       MGET11  7 38 B       MGET12  8 15 B       
MGET13  8 16 B       MGET20  8 14 B       MGET4   7 27 B       MGTS2   8 32 B       
MONTAB 24 33 B       MPT    13 36 B       MS01   11  1 B       MS03   11  2 B       
MTPAN  22 31 B       MTRAP  22 30 B       MX00   11  3 B       MX01   10 31 B       
MX03   10 38 B       MX04   10 37 B       MX05   11  4 B       MX06   11  5 B       
MX07   11  6 B       MX08   11  9 B       MX09   11 10 B       MX14   11  7 B       
MXSA   12 28 B       NROUT   7  7 B       NSRT   18  8 B       PACFC  26 23 B       
PEB2   25 20 B       PEBRS  25 12 B       PMG5    7 28 B       PMGET   7 23 B       
PMI11  13  8 B       PMI2   13 18 B       PMI3   13 14 B       PMI4   13 19 B       
PMI5   13 25 B       PMI6   13 10 B       PMI7   13 15 B       PMI8   13 16 B       
PMIX   13 26 B       PMSCH   7 25 B       PMTA    8 19 B       PMTA2   8 29 B       
PMTI   13  7 B       PMTR   12 38 B       PPAN   19 25 B       PTRAP  20 10 B       
PTRL1  20 36 B       PTRL2  20 37 B       PTRL3  20 38 B       PTRPA  20 39 B       
PTRPB  20 34 B       QS     11 34 B       RDRL   14 21 B       RF02   29 39 B       
RF03   29 21 B       RF04   29 37 B       RF06   28 38 B       RF07   29  6 B       
RF08   30  1 B       RF10   29  5 B       RF11   29  8 B       RF12   28 32 B       
RF13   30  2 B       RF14   30  3 B       RF15   30  4 B       RF16   29 30 B       
RF17   30  5 B       RF32   30  6 B       RF33   30  7 B       RFC01  30  8 B       
RFK    28 30 B       RFRL1  30  9 B       RFRL2  30 10 B       RFRL3  30 11 B       
RLCT   10  6 B       RLHLDA 10  4 B       RLHLDB 10  5 B       RLHOLD 10  3 B       
RRRL    9 20 B       RURL   14 24 B       RWTAB  23 10 B       RWTAB1 23 21 B       
RWTABN 24 29 B       RX1     9 38 B       RX11    9 36 B       RX12    9 23 B       
RX13    9 28 B       RX2     9 35 B       RX3     9 27 B       RX32    9 33 B       
RX33    9  2 B       RX4     9 13 B       RX5     9 15 B       RX6     9  8 B       
RX7     9  9 B       RX8    10  2 B       RXNTS   9  7 B       S44P1  16 15 B       
S44P2  18 16 B       S44P3  18 17 B       S44T10 18 11 B       S44T11 15 39 B       
S44T12 18 13 B       S44T13 16  4 B       S44T14 15 21 B       S44T15 16  9 B       
S44T19 16  5 B       S44T2  15 27 B       S44T20 16 38 B       S44T21 16 36 B       
S44T22 17  3 B       S44T23 17  6 B       S44T24 17 10 B       S44T27 15  5 B       
S44T28 17 14 B       S44T29 17 21 B       S44T3  14 36 B       S44T30 15  6 B       
S44T31 15 10 B       S44T33 17 13 B       S44T34 17 24 B       S44T35 17 28 B       
S44T4  14 39 B       S44T43 18 10 B       S44T44 17 20 B       S44T5  18 12 B       
S44T51 15 38 B       S44T53 15 35 B       S44T6  16  1 B       S44T61 15 37 B       
S44T62 15 34 B       S44T7  14 38 B       S44T8  16  2 B       S44T9  15 29 B       
SAIR   32 30 B       SBRM    1 18 B       SBRME   1 19 B       SBRR    1 28 B       
SCF01  27 30 B       SCF02  27 31 B       SCF03  27 32 B       SCF04  27 33 B       
SCF05  27 29 B       SCF06  27 23 B       SCF07  27 25 B       SCFK   27 21 B       
SCRL   18 34 B       SHFK   27 13 B       SKR2    7 11 B       SKROUT  7  9 B       
SRB     1 29 B       SRIR   32 17 B       SROUT   7 13 B       SS01    2 11 B       
SS02    2 12 B       SS03    2 13 B       STDMS  18  1 B       STFK   26 12 B       
STFK2  26 20 B       STFK3  26 21 B       STRL   14 29 B       STRL1  18 19 B       
STRL10 19  4 B       STRL11 19 11 B       STRL2  18 20 B       STRL3  18 36 B       
STRL4  19  9 B       STRL41 19  6 B       STRL5  19 14 B       STRL51 19 15 B       
STRL52 19 16 B       STRL6  19 13 B       STRL61 19 18 B       STRL7  19  8 B       
STRL7A 18 38 B       STRL8  19  7 B       STRL9  19 17 B       STRLD  18 14 B       
STRLQ  14 31 B       SUPBUG 20 24 B       SURL   18 23 B       SWLS1  10 21 B       
SWLS2  10 22 B       SWLS3  10 25 B       SWLSC  10 19 B       SYS     1 37 B       
SYS     1 35 B       T       2  5 B       T1      2  6 B       T2      2  7 B       
T3      2  8 B       T4      2  9 B       TF01   28 18 B       TF02   28 10 B       
TF05   28 22 B       TF06   28 23 B       TF07   28 24 B       TF09   28 17 B       
TF10   28 20 B       TF12   28 19 B       TF13   28 21 B       TFC01  28 25 B       
TFC02  28 26 B       TFK    27 38 B       TPR22  21 19 B       TPR25  21 12 B       
TPR26  21 33 B       TPR3   21 31 B       TPR4   21 34 B       TR00   21 35 B       
TR01   21 36 B       TR02   21 37 B       TR03   21 38 B       TRAP   21  1 B       
TRAPI  20  2 B       TRAPM  22  6 B       TRAPR  21  5 B       TRPXMA 21 39 B       
TT01   22 37 B       TT0M   10 34 B       TX00   22 32 B       TX01   22 33 B       
TX02   22 34 B       TX03   22 35 B       TX05   22 27 B       UBRSET  5 15 B       
UPRL44 17 34 B       WASTE  24 30 B       WNROUT  7  6 B       XMA41  22  1 B       
XMA43  22  2 B       
MONITOR ** FICHE/FRAME BREAK *****
BLET
BLET   IDENT 04/13/76
*      BUFFERLET MODULE

       LISTM
* THIS PACKAGE LOADS AT 37400B ALONG WITH "SET" PACKAGE".  IT
* GETS MOVED TO THE SAME POSITION IN SMT 20 BY SET.  IT CONTAINS
* BLOCK I/O CODE WHICH IS SWAPPABLE.

$BST3O BRM TTIO
       LDA =1*CSTAY/7; ADM TF5,2 (OUTPUT STATE FROM 3 TO 4)
       LDA =65777777B; STA SWLS (FOR PR)
ROBIN  EQU * MOVE TASK TO END OF TTQ.  DUPLICATE SOME CODE IN
*              PACT RELABELING TO SAVE SPACE.
       LDX BPORT; LDA TF6,2; LDX PREPT
       SKA K100; STX TTQTL; BRM NMSK; STA TF6,2
       LDA BPORT; LDX TTQTL; STA TTQTL
       BRM NMSK; XMA TF6,2; LDX BPORT; BRM NMSK; STA TF6,2
       BRU DEL2 (RETURN BUFFERLET)

* STATE =3I OR 4I
$BTTIO1 BRM TTIO; BRM MOVE; BRM UCL; BRM NC; BRU ROBIN

* STATE =1,2, OR 4O
$BTTIO2 BRM TTIO
        LDA STATE; SKE ONE; BRU TTIO2A; BRU TTIO2B (UNDECODED)
TTIO2A  LDX BPORT; SKN TF6,2; BRU TTIO2Y (START INPUT)
       SKE FOUR; BRU TTIO2X (START OUTPUT)
       BRM UCL
TTIO2B BRM NC (VALIDATE NEXT COMMAND)
       LDX BPORT; SKN TF6,2; BRU TTIO2Y
TTIO2X BRM MOVE (COPY USER BUFFER TO BUFFERLET); LDX BPORT
TTIO2Y LDB =IOBY+CSTAY/7; BRU TTIO2Z

TTIO ZRO;* SET UP CHARGING
       MIN NULSW1
       IF TSTAT; LDA =TTQTIM; STA CJOB; MIN NTTQTSK; ENDF
       LDX BPORT; LDA TF2,2; ETR K77; ADD =ETTB; STA TJOB
       BRR TTIO

MOVE ZRO;* COPIES BUFFERLET TO USER PAGE (INPUT) OR VICE-VERSA
*      FOR OUTPUT.
       BRM CMND
       LDX BPORT; LDA TF5,2; ETR =CHCY (COUNT FROM INTERRUPT ROUTINE)
       SKG BIOK1; BRU *+2; LDA BIOK1
       STA T1; LDA TF2,2; ETR K77; CAX; LDA T1; ADM CCT,2
       IF TSTAT; ADM NCCT; ENDF
       SUB BIOK1; CNA
       IF TSTAT; ADM NCCT1; ENDF
       MUL BIOK2; ADM* TJOB; LDA T1
       LDX BPORT; SKN TF6,2; BRU MOVE2; IF TSTAT; MIN NTOR; ENDF
MOVE1  SKG ZERO; BRR MOVE
       LDX T2; BRM PCK
       LDA 2,2; ETR K3777; ADD =30B3; ADD T3; STA T1
       LDX BPORT; LDA TF5,2; ETR =CHBNY; LRSH CHBNZ-7
       ADD =34B3; ADD T3; LDB T1
       SKN TF6,2; XAB; MRG =235B5; STA MOVET (MOVE TO ADDRESS)
       CBA; MRG =276B5; STA MOVEF (MOVE FROM ADDRESS)
       LDA T3; CNA; CAX
MOVEF  LDA 30000B,2
MOVET  STA 34000B,2
       BRX *-2
       BRR MOVE
MOVE2  CLB; IF TSTAT; MIN NTIR; ENDF; LDX T2
       LSH 14; XMA 2,2; ETR =4B7+37777B; ADM 2,2
       LDA T1; BRU MOVE1

UCL    ZRO;* UPDATE COMMAND LIST AND ADVANCE MAYBE
       BRM CMND; LDX BPORT; LDA TF5,2
       ETR =CZY+CEOTY+CTIMY+CTERY+CABOY+CSPAY
       LDX T2; LDB 1,2; SKB K3S4; BRU *+2; MRG K2B4
       MRG K4B7; MRG 0,2; SKA XX; BRU NC3 (SOME KIND OF ERROR)
       STA 0,2; MIN PCL
       LDX BPORT; LSH CADRZ+24; ETR =CADRY
       XMA TF6,2; ETR =-1-CADRY; ADM TF6,2
       BRR UCL

CMND   ZRO;* LOAD COMMAND PTR INTO T2
       LDX BPORT; LDA TF6,2; LRSH CADRZ; ETR K3777
       MRG =30B3; STA T2; ADD TWO; SKA K4000; BRU PCRER; BRR CMND

NC     ZRO;* SETUP NEW COMMAND
       BRM CMND; LDX T2; LDA 0,2; SKA K4B7; MRG K2B7
       SKA XX; BRU NC3
       LDA 2,2; STA T; LRSH 14; ETR K777
       SKG BIOK1; SKG ZERO; BRU CHCER
       BRM PCK
       MRG =2*CSTAY/7; LDX BPORT; DIR
       XMA TF5,2; ETR =-1-CSTAY-CHCY; EIR; ADM TF5,2
       LDA TF6,2; SKN T; MRG K4B7 (=CHOY); STA TF6,2
       BRR NC
PCRER  LDA K4B4; BRU NC2
CHCER  LDA K1B5
NC2    MRG* T2
NC3    MRG K4B7; STA* T2; MIN PCL; BRU DEL1

PCK    ZRO;* CHECK COUNT IN 'A' FOR POSSIBLE PAGECROSS
*      'X' = T2
*      'A' = COUNT (PRESERVED)
       STA T1; ADD TWO; RSH 23; DIV THREE; STA T3; SUB ONE
       ADD 2,2; LDB =34B3
       SKM 2,2; BRU PCRER; LDA T1; BRR PCK

       END
MONITOR ** FICHE/FRAME BREAK *****
BLET SYMSORT

SYM.  PG.LN. IDENT.

BST3O   1  9 BLET    BTTIO1  1 21 BLET    BTTIO2  1 24 BLET    
CHCER   3 14 BLET    CMND    2 38 BLET    MOVE    2  1 BLET    MOVE1   2 12 BLET    
MOVE2   2 24 BLET    MOVEF   2 20 BLET    MOVET   2 21 BLET    NC      3  3 BLET    
NC2     3 15 BLET    NC3     3 16 BLET    PCK     3 18 BLET    PCRER   3 13 BLET    
ROBIN   1 12 BLET    TTIO    1 34 BLET    TTIO2A  1 26 BLET    TTIO2B  1 29 BLET    
TTIO2X  1 31 BLET    TTIO2Y  1 32 BLET    UCL     2 28 BLET    
MONITOR ** FICHE/FRAME BREAK *****
D
D      IDENT 06/11/74

       LISTM

* SEE (A4TEL)@DISC-MAP FOR A DISC MAP.


       DEFINE BITMP,EBITMP,DHT,DHTE
       DEFINE CBF0,CSIZE,CEOF,CPTOP,CQ,CCKWRD
       DEFINE CFLG,CSW,CSW1,CEOF1,CC,COV,CP,CBASE
       DEFINE DBTOP,FBADR,FBWRD,FILE,GFILE,BUFF,LVL,CBIP,CP1,CP2
       DEFINE CRET0,CRET1,CRET2,CRET3,CRET4,CT1,CT2,CT3
       DEFINE CDSA,CDSB,CDSX,DSKMET

*      THE FOLLOWING TABLES MANIPULATE CP BITS DIFERENTLY ACCORDING TO
*      THE CURRENT VALUE OF LVL. SEE :CP: AND COMMENT IN FILE M.
CMSK   DATA    0,74B6,37B5,76B3,1777B
CSH    LRSH 24; LRSH 20; LRSH 15; LRSH 10; LRSH 0
CSH1   DATA 24,20,15,10,0
CMSK1  DATA    0,74B6,37B5,76B3,0
BFP    DATA 0,1,41B,101B,141B,541B
BFC    DATA 1,40B,40B,40B,400B
BFCN   DATA -1,-40B,-40B,-40B,-400B

*              ******************* OPEN AND CLOSE FILES
* INPUT: A=DISC ADDRESS DIVIDED BY 4, B=FILE PRIVELEGE BITS.
$BRS1  LDX =1-NFILE; LDA KM1; SKE EXBP,2; BRX *-1
       STX GFILE    (FIND GLOBAL FILE NUMBER)
*      RESTRICT OUTPUT TO DELETES.EXEC SETS SS02=57B FOR DELETE COMMAND.
       LDA SS02  (PRIVELEGE MASK)
       LDB GFILE (GLOBAL FILE NUMBER MINUS NFILE OR 0)
       SKA SIX   (CHECK INPUT, OUTPUT)
       SKN SDBM8 (OUTPUT, CHECK MAPPED OR UNMAPPED)
       LDA =57B  (EITHER MAPPED OR INPUT)
       SKB KM1   (CHECK FOR XBP TABLE FULL)
       SKE =57B  (FULL, CHECK IF OUTPUT)
       BRU CERR5  (UNMAPPED AND OUTPUT FILE OR XBP TABLE FULL)
       LDB SS01; LSH 26; ETR DMSK; STA SS01  (MAKE XBLOCK POINTER TO
*      LOGICAL DISC ADRS OR REAL DATA PRODUCT DISC ADRS)
       BRM BGET (ASSIGN HIM A TS BFR); BRU CERR2 (ALL BFRS ARE BUSY);
*      INITIALIZE CURSOR FLAG WORD,GLFG AND,SET UP CFLG TO POINT TO GFLG
       LDA GFILE; ADD =NFILE; STA GFILE; ADD =GFLG; LDX BUFF; STA CFLG,2
       LDB KM1; STB CSW1,2; STB CBASE,2
       LDB JOB; LSH 32; STA* CFLG,2; STB CP,2; STB CSW,2
       LDA FILE; SUB THREE; LSH 15; ADM* CFLG,2
       LDA SS02; ETR K377; MRG =-4B5; ADM* CFLG,2
       LDA SS01; ETR DMSK
       LDB* CFLG,2; SKB SIX; MRG X4; LDB KM2; STB T
       LDB DMSK; LDX =-NFILE OPEN FILE ONLY ONCE IF FOR OUTPUT
       SKM EXBP,2; BRU *+3; MIN T; MRG EXBP,2; BRX *-4
       LDX T; BRX CN3; SKA X4; BRU CNERR-1 (FILE BUSY)
CN3    SKA X4; BRU CN3A (GET FDCB FOR OUTPUT FILE)
$CN3C  BRM SETCC; LDA SS01; SKA DMSK; BRU CN6
       BRM CCLRX; BRM CG; STA T; CLA; STA LVL
CN4    EQU *   INITIALIZE BUFFERS FOR NEW FILE
       LDX LVL; LDA BUFF; ADD BFP,2; XXA   PUT A DISC ADRS AT THE
       LDB T; MIN T; STB 0,2               BEGINNING OF AN XBLOCK.
       ADD BUFF; CAX; MIN CC+1,2           MARK BFR FOR WRITE.
       LDA LVL; MIN LVL; SKG =MLVL-3; BRU CN4
       LDX BUFF; LDA =25252525B; STA CCKWRD,2
       LDA =37777770B; STA CEOF,2
CN5    LDA* BUFF; ETR DMSK; STA SS03
       LDX GFILE; LDB GFLG,2; SKB SIX; MRG X4; STA XBP,2
CN7    LDX BUFF; SKN* CFLG,2; BRM CDMS
       LDA SS01; SKG ZERO; BRU CN8
       LDA =MLVL-1; STA LVL; BRM SETBIP
       LDX BUFF; LDA CCKWRD,2; LDB 0,2; SKE =25252525B; BRU CN8A
       LDB* CFLG,2; SKB =4B4; BRU CNER4
       SKB K377; BRM CR (READ DBLOCK IF NOT MAPPING)
CN8    BRM DTS
       BRM SCEOF1; LDA K200; STA COV,2; LDA FSIZE; STA CQ,2
       DIR
*      CHECKSUM LEVEL 2
       LDA ONE; STA LVL; BRM SETBIP
       LDA CBIP; ADD BFC+1; CAX    (X POINTS TO LEVEL 2 BFR)
       LDA* CBIP
       DIR
       SKA X7; BRM CKSUM; EOR* CBIP; LDB* CBIP
       SKA X7; BRU CN8A
       EIR
       LDA FILE; STA SS01; LDA SS03; LRSH 2; STA SS03
COK    MIN 0; BRM NPOPX
CN8A   CBA
       IF DISC=3; BRM DP2IBM; ENDF
       BRM IDER; MIN DF; EIR; BRU CNER4


CN6    CLA; STA LVL    READ  ALL BUT LEVEL MLVL (DATA)
CN6A   BRM SETBIP; LDA SS01; ADD LVL; STA* CBIP
       LDA K2B6; BRM CRW; MIN LVL
       LDA LVL; SKG =MLVL-2; BRU CN6A; BRU CN5

CNER4  BRM RLSFD; LDA THREE; ADM CERRC; MIN CERRC
$CNERR LDA BUFF; BRM BPUT; BRM MONCR; LDA KM1; LDX GFILE; STA XBP,2
       BRU CERR

$BRS20 EQU *   CLOSE A FILE. RESET CIN FOR EXEC IF CLOSING COMMAND FILE.
       LDB ADMSK; SKM UCIN; BRU CCLS; CLB; STB UCIN; BRU CCLS

$BRS17 CLA; STA UCIN; LDB ONE; STB UCOUT; BRU CLSALL  (CLOSE ALL FILES)

$BRS147 LDA UCIN; LDB UCOUT; BRU CLSALL (CLOSE ALL FILES BUT UCIN,UCOUT)
$BRS77 EQU *   REDEFINE THE COUT FILE. CLOSE THE OLD COUT FILE.
       ETR ADMSK; XMA UCOUT; BRU CCLS


$BRS157 EQU *  COPY LVL 3 INDEX BLOCK TO USER'S MEMORY STARTING AT X
       BRM IOI    FILE NUMBER IS IN A
       CXA; ADD BFP+MLVL; ETR ADMSK; MRG =276B5; STA B157A
       LDA SS03; ADD BFC+MLVL-1; ETR ADMSK; MRG =635B5; STA B157A+1
       LDX BFCN+MLVL-1
B157A  LDA 0,2; STA 0,6; BRX B157A
       BRM NPOPX


$BRS151 EQU *  REDEFINE THE COMMAND FILE. CLOSE THE OLD COMMAND FILE.
       ETR ADMSK; XMA UCIN
$CCLS  EQU *   CLOSE 1 FILE
       BRM CLS1
       BRM NPOPX
CLS1   ZRO
       ETR ADMSK; SKG TWO; BRR CLS1
       STA FILE
       BRM CLS
       LDX JOB; SKN TTNO,2; BRU *+2; BRM CDMS
       LDA FILE; BRM CLS5; BRR CLS1


* BRS 181 - RESET COMMAND AND TOUT FILES TO TERMINAL
* FREQUENTLY USED IN ESCAPE AND ERROR PROCESSING
* RETURNS A=0,B=1,X=UNCHANGED
$BRS181 CLA; STA SS01; XMA UCIN; BRM CLS1
       LDA ONE; STA SS02; XMA UCOUT; BRU CCLS

$BRS8  CLAB;* CLOSE ALL FILES.DONT RESET CIN.
CLSALL STA CT1; STB CT2
       LDA THREE; STA CT3
CL1    SKE CT1; BRU *+2; BRU *+3; SKE CT2; BRM CLS (RUNOUT BUFFERS);
       MIN CT3; LDA CT3; SKG =3+NBUF-1; BRU CL1
       LDX JOB; SKN TTNO,2; BRU *+2; BRM CDMS
       LDA THREE; STA CT3
CL2    SKE CT1; BRU *+2; BRU *+3; SKE CT2; BRM CLS5 (CLEAN UP);
       MIN CT3; LDA CT3; SKG =3+NBUF-1; BRU CL2
       BRM NPOPX

$BRS174 EQU *  WRITE ALL BUFFER FOR FILE A ONTO DISC
       BRM IOI; SKG TWO; BRM NPOPX (0,1, OR 2 NOT DISC FILES);
       BRM CWALL (WRITE LVL 1,2, AND 3); BRM CW (WRITE LVL 0)
       BRM DTS   (START DISC IF NEC.); BRM NPOPX  (RETURN)

$C256  EQU *                      SEQENTIAL I/O ROUTINE FOR WIO,CIO
       LDX SS03; LDA* 0; BRM IOI; LDX SS03; STA* 0 (CLEAN UP FILE WORD);
       BRM CEOFP; SKG CP,2; BRU C2 (END OF FILE);
       LDA CP1 CP1 IS WHERE THE FILE NEEDS TO BE POSITIONED.SEE WIO,CIO.
       BRM CPOS  POSITION THE FILE AND MAYBE GET DISMISSED.
       BRM C1
       LDA 0; ETR =40037777B; STA T; LDA* T  (IS HE EXECUTING A CIT)
       ETR =177B5; SKE =134B5; BRM NPOPX (NO); MIN 0 (YES); BRM NPOPX
C2     LDA 0; ETR =40037777B; STA T; LDA* T; ETR =77B5
       LDX BUFF; LDB =27657537B; SKE =60B5 (WIO); LDB K137 (NOT A WIO);
       SKN CSW,2; STB SS01
       LDB =402B5; SKR COV,2; BRU FILINT
       LDA K200; STA COV,2; BRM TRAP  (TOO MANY CIO,S OR WIO,S)

*              ******************* ERASE SYSPOP
$PCEX1 EQU *
       LDA SS01; BRM CPX
       SKN CSW,2; BRU CERR1    MAKE SURE MODE IS OUTPUT
       LDB* CFLG,2; SKB FOUR; BRU *+2; BRU CERR2 (LACKS ERASE PRIVELEGE)
       LDA CP,2; SKG CPX1; BRU *+2; BRU CERR3  (CANT ERASE BACKWARDS);
       LDA CPX1; SKG CPTOP,2; BRU *+2; BRU CERR4 (CANT ERASE PAST CPTOP)
       BRM PE (ERASE)
       BRM SCEOF1; BRM CKERR
       BRU COK

*              ******************** SET CURSOR POSITION SYSPOP
$SCPX1 EQU *
       LDX BUFF; LDA =42B; SKN SS01; LDA =41B
       CLB; SKN EXEC1; CAB; SKM* CFLG,2
       BRU CERR1  (SCP PRIVELEGE NOT ENABLED OR WRONG READ/WRITE MODE)
       LDA CEOF,2; SKN SS01; LDA CPTOP,2; ADD ONE; STA T (MAX CURSOR POS)
       LDA SS01; BRM CPX; ADD ONE; SKG T; SKG CBOF,2
       BRU CERR2 (HE ATTEMPTED TO POSITION OUT OF LEGAL RANGE)
       LDA CPX1; BRM CPOS (POSITION AND MAYBE DMS)
       LDA SS01; RSH 23; STA CSW,2
       LDA K200; STA COV,2
       BRM C1; BRM SCEOF1; BRM CKERR
       BRU COK

*              ******************** READ CURSOR POSITION SYSPOP
$RCPX1 EQU *   READ CURSOR POSITION
       BRM CPRIV; LDA CP,2; BRM CPY; BRM NPOPXB

       IF -1
$SSPX1 EQU *   SET CURSOR SIZE. LIMIT THE FILE SIZE.
       BRM CWALL; BRM CW; LDX BUFF; SKN* CFLG,2; BRM CDMS
       LDA SS01; SKG =8457*1400B; BRU *+2; BRU CERR1
       ADD =1400B-1; RSH 23; DIV =1400B; STA CQ,2; BRU COK
       ENDF

$RSPX1 EQU *   READ CURSOR SIZE PARAMETERS
       LDX BUFF; SKN* CFLG,2; BRM CDMS
       LDA CSIZE,2; MUL =1400B/2; STB SS02   PYHSICAL SIZE IN CHARACTERS
       LDA CQ,2; MUL =1400B/2; STB SS03     REMAINING PHYSICAL QUANTUM
       LDA CPTOP,2; BRM CPY; ETR XX; BRM NPOPXB  HIGHEST ADRS WRITTEN


*      BIO     ******************** BLOCK I/O ROUTINES

*      BIO PROCEDURE
*      
*:BIOX1:
*      VALIDATE ARGUMENTS, INITIALIZE TS VARIABLES

*:B0:  EXIT IF BIO DONE
*      CALL BWIO IF A PARTIAL TS BUFFER NEEDS TO BE COPIED

*:B0C:  TS BUFFER CAN NOW BE DESTROYED
*      INITIALIZE BT4 WHICH SAYS HOW MANY DISC ADDRESSES ARE AVAILABLE
*      IN CORE MEMORY WITHOUT A CALL TO CPOS TO READ NEW XBLOCKS.
*      SET SS01 TO WORD COUNT FOR TOTAL NUMBER OF FULL DBLOCKS
*      TO BE READ OR WRITTEN.
*      GRAB MEMORY. SAVE RELABELLING FOR PAGE CROSS INTERRUPT ROUTINE.

*:B2:  B2 FIGURES OUT WHAT DISC COMMANDS ARE NEEDED TO DO BIO.
*      B2 CODE IS LESS THAN NEAT. MODIFY WITH CAUTION.
*      B2 CALLS B9 (THE DISMISS ROUTINE) IF
*              A CALL TO CPOS IS NECESSARY TO READ AN XBLOCK
*              OR THE WORD COUNT IS SUFICIENTLY DECREMENTED
*              OR :DLOCK: SAYS TOO MANY PAGES ARE LOCKED FOR THE DISC
*              OR THE DRQ LIST CONTAINS TOO MANY ENTRIES.
*  :B2W:       OUTPUT BIO
*      GRAB DISC SPACE IF DATA BLOCK POINTER IS ZERO
*      RELEASE DISC SPACE IF MEMORY BFR IS ZERO AND WRITE IS UNNECESSARY
*  :B2R:       CLEARS DATA BFR IF THE DISC ADDRESS OF THE DATA = 0.
*  :B2C:       B2C SETS UP FOR PAGECROSS IF PAGECROSSOVER IS IMMINENT.
*  :B2A:       OUTPUT THE PREVIOUS DISC COMMAND IF THE NEXT DISC ADRS
*      IS OUT OF SEQUENCE, OTHERWISE ADD 400B TO THE WORD COUNT THAT THE 
*      NEXT COMMAND OUTPUT BY BTC WILL HAVE.

*:B9:  DISMISS ROUTINE
*      OUTPUT ALL DISC COMMANDS BUILT BY B2.
*      PUT ZERO AT THE END OF THE PAGE CROSSOVER USER MEMORY ADRS LIST.
*      DO THE FIRST PAGECROSS COPY LOOP IF IN OUTPUT MODE.
*  :B9A:       POSITION THE FILE AND GET DISMISSED MAYBE.
*      RESTART THE BIO WITH UPDATED VALUES OF SS01,SS03

*:B99: FINAL EXIT. POSITION THE FILE SO THAT ALL LEVELS ARE IN CORE
*      AT THE NEW POSITION. CLEAN UP AND RETURN TO THE USER.

*:BWIO: BWIO COPIES DATA BETWEEN THE TS BFR AND USER MEMORY.
*:BTC: ALL THIS LITTLE ROUTINE DOES IS MAKE ONE BIG DISC COMMAND
*      WITH THE WORD COUNT IN WR8 WHICH ACCUMULATES A BIG VALUE IF
*      LOTS OF CONSECUTIVE DISC ADDRESSES ARE IN THE XBLOCK THAT
*      HOLDS THE DBLOCK POINTERS.
*:BINC:  INCREMENT A FEW POINTERS
*:BSEZ: SEE IF A DBLOCK IS ALL ZERO
*:BPCT:  PAGE CROSSOVER TEST.SKIP IF PAGE BOUNDARY IS IMMINENT.
*:BVIATS:  B (BIO)   VIA (BY WAY OF)   TS (TS BFR)
*      COPY A TS DATA BFR TO OR FROM USER MEMORY
*:BRMC: DETERMINE THE 2 PAGES INVOLVED IN ANY PAGE CROSS.

*      BIO DICTIONARY
*SS01   WORD COUNT. SLOWLY GETS DECREMENTED TO 0 AS BIO PROCEDES.
*SS03   USER MEMORY ADRS. GOES UP AS BIO PROCEDES.
*WR4   POINTS TO A LIST OF USER MODE CORE ADDRESSES FOR BIO PAGE
*      CROSSOVER BLOCKS. THE LIST START AT WR4+1 AND IS VARIABLE
*      LENGTH ENDING WITH A ZERO.THE ADDRESSES ALL HAVE THE SIGN BIT ON.
*WR6   ADDRESS TO BE USED IN DISC COMMAND IF NOT GOING TO USER CORE.
*WR8   WORD COUNT USED WHEN BTC ASSEMBLES AND OUTPUTS A COMMAND
*      TO THE DISC.
*WR9   LESS THAN 400B. THE NUMBER OF BIO WORDS IN THE LAST DBLOCK.
*WR11,WR12     USER'S REAL RELABELLING AFTER ALL MEMORY IS GRABBED.
*WR13  POINTS TO THE DISC ADDRESS FOR EACH DISC COMMAND. UPDATED BY
*      :BTC:. WR13 GOES UP IN BIG JUMPS FOR WELL ORDERED FILES.


$BIOX1 EQU *
       SKN 0; BRM MONCR
       LDX BUFF; SKN* CFLG,2; BRM CDMS (WAIT IF DATA IS MOVING);
       SKN SS01; BRU *+2; BRM NPOPX
       LDA SS03; ETR ADMSK; STA SS03; MRG X4; XMA SS03
       ADD SS01; SUB =40000B; COPY N,B; SKA X4; ADM SS01
       LDX =WR4; STX WR4
       STB 1,2; STB WR6; STB WR8; STB WR9; STB BTCX (KILL BTC HISTORY)
       BRM CEOFP
       LDA CSW,2; STA WR5; LDA CP,2; STA CP1; SKA THREE; BRM TRAP
*      CHECK IF HIS SS01 IS TOO GREAT AND REDUCE SS01 IF NECESSARY
       SUB* CEOFP1 (EOF); SUB THREE (LAST FEW CHARS); MUL X7 (CNA,RSH 2)
       SUB SS01
       SKA X4; BRU *+2; BRU *+4; ADM SS01; LDA =402B5; ADM COV,2 (EOF)
       LDB SS01; LSH 26; ADD CP,2
       SKG CPTOP,2; BRU *+5; SKN WR5; BRU *+3; STA CPTOP,2; MIN CC+1,2

B0     LDA THREE; STA LVL; BRM SETBIP; STA WR13
B0A    LDA THREE; STA LVL; LDA SS01; SKG ZERO; BRU B99
       LDX BUFF; LDB CP,2; SKA KM400; SKB CMSK+MLVL; BRU BWIO

B0C    EQU *
       BRM CW; LDX BUFF; LDA KM1; STA CC+MLVL,2
       LDA CP1; ETR CMSK+MLVL-1; EXU CSH+MLVL-1
       CNA; ADD BFC+MLVL-1; STA BT4
       LDA SS03; STA BT1; ADD SS01; SUB ONE; STA BT2
       LDA SS01; ETR K377; STA WR9; CNA; ADM SS01
BGRAB  LDA BT2; SKG BT1; BRU BGRABA
       LDB* BT1; SKN WR5; STB* BT1; LDA K4000; ADM BT1; BRU BGRAB
BGRABA LDB* BT2; SKN WR5; STB* BT2
       LDA RRL1; STA WR11; LDA RRL2; STA WR12
B2     LDA =MLVL-1; STA LVL   MAKE SURE PROPER CC FLAG IS REFERENECED
*              IF ANY LOW LEVEL ROUTINES CHANGE THE XBLOCK
       SKR BT4; BRU *+2; BRU B9
       LDA WR8; RSH 8; ADD WR13; STA BT3
       LDA SS01; SKG WR8; BRU B9
       LDA EIGHT; SKG DLOCK; BRU B9
       IF DISC<3     SEE IF DRQ LIST IS GETTING TOO FULL
       LDA DTXS1; ADD =NDRQ-3; SKG NDCL; BRU B9
       ELSE
       LDA RQ1A; SUB RQ3; SKA X4; ADD =NDRQ*3
       SKG =NDRQ-9; BRU *+2; BRU B9
       ENDF 
       CLA; SKN WR5; BRU B2R
B2W    SKE* BT3; BRU *+5; BRM CG; STA* BT3; LDX BUFF; MIN CC+MLVL-1,2
       LDA SS03; ADD WR8; BRM BSEZ; BRU B2C
       LDB BT3; BRM CESW; LDX BUFF; MIN CC+MLVL-1,2
B2W1   BRM BTC; LDA BFC+MLVL; BRM BINC; MIN WR13; BRU B2
B2R    SKE* BT3; BRU B2C
       LDA SS03; ADD WR8; ADD BFC+MLVL; ETR ADMSK; MRG =636B5
       CLB; LDX BFCN+MLVL; STA *+1; STB 0,6; BRX *-1; BRU B2W1
B2A    LDX BT3; LDA 0,2; SKG ZERO; BRU B2E
       IF DISC<3
       SUB FOUR; LDB WR8; SKB KM1; SKE -1,2; BRM BTC
       ELSE
       RSH 23; DIV =4*8*20*200   DISC PACK CROSSOVER IF B=0
       LDA WR8; SKB KM1; SKG ZERO; BRM BTC
       LDA 0,2; SUB FOUR; SKE -1,2; BRM BTC
       ENDF
B2B    LDA BFC+MLVL; ADM WR8; BRU B2
B2C    LDA BFC+MLVL; BRM BPCT; BRU B2A; BRM BTC
       LDA SS03; SKA K3777; BRU *+2; BRU B2A
       MIN WR4; STA* WR4
       DIR; BRM BRMC; BRM DLOCKI; LDX BRMC1; BRM DLOCKI
       LDX RLTS; BRM DLOCKI; EIR
       LDA BFC+MLVL; STA WR8; LDA BFP+MLVL; ADD BUFF; STA WR6
       MIN BT3; BRM BTC; BRU B2
* NEG. DATA ADDRESS
B2E    MIN NDA; BRM TRAP



B9     BRM BTC
       LDA =WR4; XMA WR4; COPY AX,B; STB 1,2; SKA WR5; SKG =WR4; BRU B9A
       DIR; BRM BVIATS; BRM BRMC; BRM DLOCKD; LDX BRMC1; BRM DLOCKD
       LDX RLTS; BRM DLOCKD; EIR

B9A    EQU *
       CLA; XMA WR9; ADM SS01; LDA CP1; BRM CPOS; BRU BIOX1

B99    LDA CP1; BRM CPOS
       SKN 0; BRM MONCR
       LDA COV,2; ETR ADMSK; XMA COV,2; ETR NADMSK
       MRG* 0; STA* 0; SKN* 0; MIN 0
       SKA WR5; MIN CC+MLVL,2
       BRM C1; LDA SS03; ETR ADMSK; STA SS03; BRM NPOPXB

BWIO   EQU *
       STA T; LSH 22; ETR K377; STA T2; SUB K400
       COPY B,N; SKG T; STA T
       LSH 2; ADD CP,2; LDB CMSK+MLVL-1; SKM CP,2; MIN WR13
       SKB WR5; MIN CC+MLVL,2
       LDA T2; ADD BUFF; ADD BFP+MLVL; LDB SS03; SKN WR5; XAB
       ADD T; ETR =40037777B; MRG =235B5; STA BWIO1+1
       CBA; ADD T; ETR =40037777B; MRG =276B5; STA BWIO1
       LDA T; BRM BINC; CAX
BWIO1  LDA 0,2; STA 0,2; BRX BWIO1
       LDA CP1; BRM CPOS; BRU BIOX1


BTC    ZRO;* OUTPUT ONE BIG DISC COMMAND THAT COMBINES MANY DATA BLOCKS
       LDA WR8; SKG ZERO; BRR BTC
*      FIRST MAKE SURE THAT A PAGE BOUNDARY READ IS NOT IMMEDIATELY
*      FOLLOWED BY A TS BFR READ, SINCE THE LATTER READ INTO THE TS
*      BUFFER MIGHT COMMENCE WHILE THE PRIOR READ IS BEING SERVICED
*      BY THE INTERRUPT ROUTINE.
       LDA WR6; SKG ZERO; BRU BTC1;* PREVIOUS I/O INTO TS BFR
       LDA BTCX; ETR =74B6; SKE X2; BRU BTC1;* PAGE BOUNDARY
       XMA BTCA; LDB =220210B; IF DISC =3; LDX =4B7+10B; ELSE
       LDX =4B7+1; ENDF; BRM DTC (DO SOME USELESS WORK TO STALL FOR TIME)
BTC1   CLAB; BRM BPCT; LDB K4B6; LDA X2; SKA WR5; LDA =62B6
       COPY AX,BX (CREATE INTERRUPT NUMBER AND READ/WRITE BIT)
       LDA WR8; RSH 5; COPY AB,XB (PUT IN WORD COUNT); COPY BX,A
       XMA WR6; SKG ZERO; LDA SS03; LDB WR13
       STA BTCA; STB BTCB; STX BTCX; SKB DMSK; BRM CDTC
       CLA; XMA WR8; BRM BINC
       LDA BT3; STA WR13; BRR BTC
BTCA   0;* LAST A REGISTOR ARGUMENT FOR CALL TO CDTC
BTCB   0;* LAST B REGISTOR ARGUMENT FOR CALL TO CDTC
BTCX   0

BINC   0;* UPDATE SS01 AND SS03 FOR BIO COMMANDS OUTPUTTED AND INCR. CP1.
       ADM SS03; CLB; LSH 2; ADM CP1
       MUL X7 (RSH 2,CNA); ADM SS01; BRR BINC

BSEZ   0;* SKIP IF BLOCK EQUAL ZERO
       ADD K400; ETR =40037777B; ADD BZ1; LDB KM1; LDX KM400
       STA *+1; SKB 0,2; BRR BSEZ; BRX *-2; MIN BSEZ; BRR BSEZ
BZ1    SKB 0,2

BPCT   0
       MIN BPCT; ADD SS03; ADD WR8; SUB ONE; EOR SS03
       SKA K4000; BRR BPCT; BRU* BPCT

BT1    0
BT2    0
BT3    0
BT4    0

*              ******************** END OF BIO ROUTINES

* READ OR WRITE ON DISC (BRS 124,125)
* INPUT: A=CORE ADDR.  B=DISC ADDR.  X=WORD COUNT.
* FLAGS KEPT BY JOB IN TTNO.
$ARDD  LDX X1; BRU AWDD1       BRS 122. READ  DISC. DONT DISMISS.
$AWDD  LDX X5                  BRS 123. WRITE DISC. DONT DISMISS.
$AWDD1 BRM DISCRW
       LDA ARMOT; SUB XARMOT; SKG =NDRQ-2      IS DRQ ALMOST FULL
       BRM NPOPX      (NO, LET HIM KEEP RUNNING)
       BRU ARD2 (YES, DISMISS HIM. HE MAYBE DOING LOTS OF BRS 122,123S)
$AWD   LDX X5; BRU ARD1                BRS 125.WRITE DISC AND DISMISS.
$ARD   LDX X1                          BRS 124.READ  DISC AND DISMISS.
ARD1   BRM DISCRW
ARD2   MIN 0; BRM CDMS1      DISMISS UNTIL IO IS COMPLETED
DISCRW 0;* READ OR WRITE ON DISC
       STX T2
       SKA NADMSK; BRM TRAP               BAD CORE ADRS
       LDA SS03; SKG K4000; SKG ZERO; BRM TRAP    BAD WORD COUNT
       SKA K77; BRM TRAP                        BAD WORD COUNT
       ADD SS01; SUB ONE; EOR SS01; SKA K4000; BRM TRAP  PAGE CROSSOVER
       LDX SS01; LDA 0,6; STA 0,6
       LDA SS01; BRM DTH
       IF MDSI; LDA DSCTPD; STA DSCTT; ENDF
       LDA SS03; RSH 5; MRG T2; CAX; LDA T; LDB SS02
       BRM DTC; BRM DTS; BRR DISCRW


*              ******************** BIT MAP ROUTINES
$GBRAN 0;*     RANDOM. HELPS SMOOTH DISC ALLOCATION. SEE GETBLK.

       IF DISC=1

$GETBLK 0;*    PUT ADDRESS OF AVAILABLE DISC BLOCK IN A 
       STA CBASEP (BASE/MAX PTR)
       LDA GB6A; STA *-1  
       LDA REAL; RSH 23; DIV =NFILE; STB GBRAN   SET GBRAN ONCE PER DAY
*      IF GNM ROUTINE HAS FAILED TO GET A NEW MAP, THEN SDBM8 FLAG
*      IS NEGATIVE AND DBITS IS ALSO NEGATIVE.
*      IN THAT CASE GIVE THE USER ENOUGH DBITS TO CLOSE THE FILE,
*      BUT TRAP HIM IN ORDER TO CAUSE HIM TO CLOSE THE FILE
GB6    LDA =MLVL; SKA SDBM8; SKN DBITS; BRU *+3; STA DBITS; BRM TRAP
       LDA MAPLBL; BRM RLABEL; BRU GB5
$GB5A  BRM MPDSC; LDB GB8; LSH 26; BRR GETBLK
$GB8   0
$GB9   0

GB6A   BRU GB6

LOCBIT 0;* CONVERT DISC ADDRESS IN A TO BITMAP WORD ADRS IN LB
*      AND BIT IN A.
*      NO SKIP IF GARBAGE. 1 SKIP IF UNMAPPED. 2 SKIPS NORMALLY.
       SKA =77000003B; BRR LOCBIT (GARBAGE);
       MIN LOCBIT; RSH 2; STA LB8
       ETR K3777    GET ARM POSITION
       SKG* GA1P; SKG* GAP; BRR LOCBIT
       LDA MAPLBL; BRM RLABEL
       LDA LB8; RSH 23; DIV K4000     DISC NUMBER
       MUL =GW; LSH 23; XMA LB8 (BIT NUMBER OF BEGINNING OF DISC
       ETR K3777; SUB* GAP; SUB ONE; ADD LB8   BIT POS. IN MAP
       RSH 23; DIV K30; ADD =BITMP; STA LB   WORD POSITION
       LDA X4; CBX; LRSH 0,2; MIN LOCBIT; BRR LOCBIT
$LB9   0;*     INPUT TO LOCBIT, AND DISC ADDRESS FOR DHPUT ROUTINE
LB8    0
LB     0;*     POINTS TO WORD IN BIT MAP.
       ENDF DISC=1

       IF DISC<3

* ENTER COMMAND IN LIST AND LOCK MEMORY BLOCK AND DECREMENT TTNO.
* A= ABS CORE ADDR
* B= DISC ADDR
* X= WORD COUNT
$DTC   ZRO
       SKE DTCA; BRU DTC2;* READ IS REQUESTED IN SAME PAGE AS PREVIOUS.
       STA DTCA; CXA; XMA DTCX; STB DTCB; ETR =74B6; SKE X2; BRU DTC8
       MIN DTCSW;* LAST CMND = BIO PAGECROSS.STALL FOR TIME. SEE :IDBPR:
       LDA DTCA; LDB =220210B (GARBAGE DUMP AREA); LDX =4B7+4; BRU DTC3
DTC2   STA DTCA; STB DTCB; STX DTCX
DTC3   STB* EDCL; XAB; ETR DMSK; SKG DSCTOP; BRU *+2; BRM TRAP
       MIN ARMOT; MIN DTXS1
       CXA; LDX EDCL; STX DTXS2
       STB 1,2 (CORE ADRS); STA 2,2 (WORD COUNT,ETC); LCY 13; ETR K37
       XXA; ADD THREE; SKE =DRQU; BRU *+2; LDA =DRQ; STA EDCL
       DIR; BRM DLOCKI; EIR
       LDB JOB; LSH 37; LDX DTXS2; ADM 2,2
       LDX JOB; LDA =-2B5; ADM TTNO,2
       LDA =NDRQ-2; SUB DTXS1; SKG NDCL; BRM MONCR
       SKN DTCSW; SKR DTCSW; BRR DTC
DTC8   LDA DTCA; LDB DTCB; LDX DTCX; BRU DTC3
DTCSW  DATA -1 SWITCH TO HELP DTC CALL ITSELF 
DTCA   0;* ARGUMENT FOR NORMAL CALL TO DTC
DTCB   0
DTCX   0


       ENDF DISC<3

       IF DISC>1

$GETBLK 0;*    PUT ADDRESS OF AVAILABLE DISC BLOCK IN A 
       STA CBASEP (BASE/MAX PTR)
       LDA GB6A; STA *-1
       LDA REAL; RSH 23; DIV =TABLEN; STB GBRAN   SET GBRAN ONCE PER DAY
*      FORCE USER TO TRAP IF OUTPUTTING TO A FILE IF GNM ROUTINE
*      HAS FAILED TO GET A NEW MAP. BUT ALLOW ENOUGH DBITS TO CLOSE FILE
GB6    LDA =MLVL; SKA SDBM8; SKN DBITS; BRU *+3; STA DBITS; BRM TRAP
       LDA MAPLBL; BRM RLABEL; BRU GB5
$GB5A  BRM MPDSC; LDB GB9; LSH 26; BRR GETBLK
GB6A   BRU GB6
$GB8   0
$GB9   0

LOCBIT 0;* CONVERT DATA PRODUCTS SECTOR ADRS INTO BIT MAP POINTER
       SKA =74000003B; BRR LOCBIT; MIN LOCBIT
       STA LB9  (SAVE DISC ADDRESS FOR DHPUT ROUTINE)
       ABC; DIV =32000*2;* A =DISC NUMBER
       SKE MAPNUM; BRR LOCBIT; MIN LOCBIT
       LDA MAPLBL; BRM RLABEL
       CLA; DIV K30; ADD =BITMP; STA LB
       CBX; LDA X4; LRSH 0,2
       BRR LOCBIT
LB     0

$LB9   0;*   (DISC ADDRESS FOR DHPUT ROUTINE)

       ENDF DISC>1

       IF DISC=3

$DTC   0
       STB DTCBSV; STB* RQ1A
       XAB; SKA =3777774B; BRU DTC11; SKE X7
       IF MDSI; BRU DTC12 (TRAP); CLA
DTC11  ETR DMSK; SKG DSCTT; BRU DTC13
DTC12  LDA DSCTOP; STA DSCTT; TRAP
DTC13  LDA DSCTOP; STA DSCTT (SET DSCTT BACK FOR FILE I/O)
       ELSE; BRM TRAP; CLA
DTC11  ETR DMSK; SKG DSCTOP; BRU *+2; BRM TRAP; ENDF
       CXA; LDX RQ1A; STB 1,2; STA 2,2
       SKA SEVEN; BRU *+5; LDB DTCBSV; SKB THREE; BRM TRAP ; BRU DTC1
       SKA =170B; BRM TRAP  (NO DATA CHAINING WITH LARGE WC);
       RSH 1; ETR THREE; STA T; LDA 0,2; ETR THREE; ADD T; SKG FOUR; BRU DTC1
       BRM TRAP (A SMALL WC REQUEST OVERLAPPED A 2314 PHYSICAL RECORD)
DTC1   LDB JOB; LSH 37; ADM 2,2
       LDA 0,2; BRM DP2IBM; LDX RQ1A; STA 0,2
       BRM CKSM; IF NFILE>100B; ETR K1S5; ENDF
       RSH 11; CAX; BRM DLOCKI
       MIN ARMOT (NO. OF DISC COMMANDS ENTERED)
       LDX JOB; LDA =-2B5; ADM TTNO,2; SKN TTNO,2; BRM MONCR
       EAX RQ1A; DIR; BRM INCRQ; EIR
       BRR DTC
DTCBSV 0;* COPY OF UNTRANSLATED DISC ADRS. GOOD FOR DEBUGGING PURPOSES.

*      PUT 3 BIT FOLDED CHECKSUM INTO DRQ SO 620 CAN CHECK MIC IN POLLD
$CKSM   0;*   CHECKSUM SUBROUTINE
       EOR 1,2; EOR 2,2; STA T; LRSH 8; EOR T; STA T; RSH 16
       EOR T; STA T; RSH 4; EOR T; LSH 16; ETR =36B5
       ADD 1,2; XMA 1,2; BRR CKSM


$DP2IBM 0;* CONVERT DP ADRS IN A TO IBM ADRS IN A
*      THERE ARE 32 100 WORD RECORDS PER TRACK
*      THERE ARE 20 HEADS PER CYLINDER
*      THERE ARE 200 CYLINDERS PER DISC
*      FIRST WORD OF 3 WORD DRQ ENTRY SHOULD BE:
*      BITS 0-2  CHECKSUM OR 0, BITS 3-5   DISC NUMBER
*      BITS 6-13  CYL., BITS 14-18  HEAD, BITS 19-23 FOR 100 WORD RECORD
       STA T; ETR X7 (CHECKSUM); XMA T; ETR DMSK
       RSH 23; DIV =32*20*200   PUT DISC PACK IN A
       COPY BX,B; LSH 18; ADM T   (ADM PACK NUMBER ONLY)
       CXA; RSH 23; DIV =32*20   (CYLINDER IN A)
       LSH 10; ADM T   (CYL)
       LSH 14; ADD T   ADD TO HEAD AND RECORD
       BRR DP2IBM

$DTS   0
       LDB RQ1A; STB RQ1; SKN DBITS; BRR DTS; BRM GNM (GET NEW BITMAP)
       BRR DTS; BRR DTS   (NORMALLY THERE IS A SKIP RETURN)

       ENDF 


$GMC  0;* (GET BIT MAP TO CORE AND CHECK IT)
       IF DISC<3
       LDA =2500B; STA GDCWC
       LDA DBMDA    (ADDRESS OF BIT MAP ON DISC)
       ADD THREE
       LDB =45300B   (READ IT REAL PAGE 11B PLUS 1300B)
       LDX =52B        (WORD COUNT/40B, IE., 2500B WORDS)
       ELSE
       LDA DBMDA; ADD THREE; LDB =45300B
       LDX TWO; XAB; BRM DTC
       LDA DBMDA; ADD FOUR; LDB =45400B; LDX =50B
       ENDF
       BRM GDC (GET DISC TO CORE)
       CLA; XMA -1  (GET DATE AND STORE ZERO TO INVALIDATE IT)
       SKE ZERO                (OR ZERO INDICATES NO VALID MAP ON DISC)
       BRU *+2; BRR GMC        (IF ZERO, NON-SKIP RETURN WITH NO MAP)
       STA MAPDAT              (IF NON-ZERO, STORE DATE AND)
       LDA -2; STA MAPTIM      (TIME AND GET MAP)
       IF DISC<3
       LDA =203666B; STA GDCRW (WRITE EOM FOR DISC)
       ENDF
       LDA DBMDA   (DISC ADDRESS TO WRITE BITMAP BACK TO DISC)
       LDB =45000B      (REAL PAGE 11B CONTAINS BITMAP)
       LDX =40000060B   (WORD COUNT/40B WITH SIGN BIT ON FOR WRITE)
       BRM GDC   (WRITE BITMAP BACK TO DISC WITH CONTROL WORD ZEROED)
       LDX =-TABLEN; CLA 0     (CHECKSUM BITMAP)
       ADD EBITMP,2; BRX *-1
       SKE -4; BRR GMC     (FAIL RETURN IF CHECKSUM BAD)
       STA BITSUM              (STORE CHECKSUM)
       LDA -6; SKE 200B; BRR GMC (GET MACHINE NUMBER AND CHECK)
       LDA -5; SKA X4; BRR GMC (CHECK SAVED DBITS NEGATIVE)
       LDA -3; SKA KM8; BRR GMC (NON-SKIP RETURN IF ZONE OUT OF RANGE)
       STA MAPNUM              (SETUP ZONE NUMBER)
       LDA -5; STA DBITS       (GO AHEAD AND STORE DBITS NOW)
       LDA X4; LDX MAPNUM; LRSH 3,2; STA MAPBIT (FOR EXEC FD ZONE BIT)
       IF DISC=1               (SETUP POINTERS INTO BITMAP FOR DP DISC)
       EAX GA,2; STX GAP; EAX 1,2; STX GA1P
       ENDF
       MIN GMC       (SKIP RETURN FOR SUCCESS)
       BRR GMC                 (RETURN)

*      (GET NEW BITMAP FROM DISC)
$GNM   ZRO; LDA REAL; STA GNM4; BRM GMD    (WRITE CURRENT MAP BACK TO DISC)
       BRM GDC
       IF DISC<3; LDA =202626B; STA GDCRW; ENDF
GNM5   LDA KM1; LDX PZONE; SKN PZONE  (TEMPORARILY PUT A NEG. VALUE)
       XMA DBITBL,2; STA DBMDA  (IN THE DBITBL TABLE THAT THE MAP)
       LDX KM8      (PROGRAM IS USING TO KEEP FROM CHOOSING THAT ZONE)
GNM2   STX MAPNUM   (SEARCH FOR ZONE WITH BIGGEST NUMBER OF DBITS)
       LDA DBITBE,2; SKG DBITE1,2; BRX GNM2; BRX *-2  (KEEP SEARCHING)
       SKG X0; BRU GNM1   (CHECK FOR ZERO OR NEG. NUMBER AND DON'T USE)
       LDA EIGHT; ADM MAPNUM  (CONVERT TO POSITIVE NUMBER)
       LDX MAPNUM   (GET DISC ADDRESS OF THIS ZONE TO READ IT IN)
       LDA MAPADR,2; XMA DBMDA  (AND STORE, RETREIVE SAVED DBIT ENTRY)
       LDX PZONE; SKN PZONE; STA DBITBL,2  (PUT BACK IF TAKEN OUT)
       BRM GMC  (GET NEW BITMAP TO CORE)
       BRU GNM3    (BAD MAP, MARK AS BAD AND LOOK FOR ANOTHER MAP)
       MIN GNM                 (GOOD MAP, SKIP RETURN)
GNMR   BRM MPDSC; BRR GNM    (OK, DONE - RETURN)
GNM1   LDA TWO; SKA ALARM; BRU *+2; ADM ALARM   (OUT OF DBITS)
       LDA KM1; STA SDBM8; STA MAPNUM   (SET TO UNMAPPED STATE)
       CLA; STA DBMDA; BRU GNMR                (AND RETURN)
GNM3   LDX MAPNUM; LDA X4; SKN DBITBL,2; ADM DBITBL,2 (MARK AS BAD MAP)
       BRU GNM5   (GO LOOK FOR ANOTHER MAP)
GNM4   ZRO 0   REAL WHEN ROUTINE LAST CALLED.

$BRS66 EQU *   DELETE A FILE
       LDB ONE; BRM CDEL1; BRM PE   DELETE ALL BLOCKS
       LDA* BUFF; ETR DMSK; STA B66A; LDB =B66A; BRM CE (REL. TOP XBLOCK
       LDA KM1; LDX BUFF; STA CSW1,2
       BRU COK
B66A   0

$GRABB1 EQU *  BRS 54. GRAB A BIT FROM THE BIT MAP AND RETURN DISC ADRS
*   RETURN ALWAYS SKIPS
       SKN SDBM8; BRU *+2; BRM NPOPXB  (NO BITMAP)
       LDA KM1
       BRM GETBLK (FAILURE, GET ONE FROM THE BITMAP)
       MIN 0; BRM NPOPXB

$GRABB2 EQU *  BRS 25. GRAB A PARTICULAR BIT IN MAP.INPUT IS DISC ADRS.
       SKA SDBM8; BRM CGRB1; BRM NPOPX; BRU COK

$GIVEB EQU *   BRS 30.GIVE BIT TO BIT MAP. DISC ADDRESS IN A.
       LDB KM1; STB CBASEP
       BRM CDEL3; BRM NPOPX; BRU COK
$CBASEP DATA -1 (BASE/MAX PTR)

$LOCBLK EQU *  BRS 41. RETURN DISC ADRS OF CURRENT DATA BLOCK
       LDA THREE; STA LVL; BRM SETBIP; LDA* CBIP; BRM NPOPXB

$BRS92 EQU *   SET FSIZE, THE DISC SPACE QUANTUM PARAMETER FOR FILES.
       SKG =8457*1400B; SKG =1400B*5-1; BRM TRAP
       ADD =1400B-1; RSH 23; DIV =1400B; STA FSIZE; BRM NPOPX

* BRS 128   SET DISC BIT MAP
* INPUT: A,B=DATA  X=ENTRY NUMBER
* CALLED BY REFRESH, SETMAP AND MAP.
* REFRESH BUILDS MAPS FROM FILE DIRECTORIES. USED WHEN MAPS GET
*   CLOBBERED OR WE'VE LOST TOO MANY BITS.
* REFRESH USES ENTRIES 4, 8, 10.
*
* SETMAP IS RUN AT STARTUP WHEN THERE IS AT LEAST ONE GOOD MAP.
*   IT CHECKS THE MAP CHECKSUMS, GIVES THE MAPS TO THE MONITOR,
*   SETS UP THE ACCOUNTING, ETC.
* SETMAP USES ENTRIES 3, 9.

* MAP RUNS IN TIMESHARING AND MOVES BITS FROM THE HOLE TABLE TO
*   THE MAPS ON DISC.
* MAP USES ENTRIES 5, 6, 7, 11.
$SDBM  EQU *
       XXA; SKG =SDBM2-SDBM1; SKG ZERO; BRM TRAP; XXA
SDBM1  BRU *,2
       BRU SDBMF               (USED TO BE BRU SDBMA FOR REMAPPING)
       BRM TRAP                (USED TO BE BRU SDBMB FOR REMAPPING)
       BRU SDBMC; BRU SDBMD; BRU SDBME
       BRM TRAP; BRU SDBMG; BRU SDBMH; BRU SDBMI; BRU SDBMJ
SDBM2  EQU *

* MAP INPUT: A=ZONE NUMBER, B= NUMBER OF DBITS.
* UPDATES NUMBER OF DBITS.
SDBMK  SKG SEVEN; SKG KM1; BRM NPOPX; CAX; STB DBITBL,2; BRU COK
* REFRESH INPUT: A=F(ZONUM).
SDBMJ  BRM CE3; BRM NPOPX; BRU COK  (GRAB BIT IN BITMAP IN USER CORE)
* SETMAP CALL.
SDBMI  BRM GNM; BRM NPOPX; BRU COK
* TURNS OFF A BIT IN THE REFRESH PROGRAM'S MEMORY.
* INPUT: A=FILE NO.
SDBMH  LDB TWO; BRM CDEL1; BRM PE; BRM SETCC; LDA KM1; STA CSW1,2
       LDA 0,2; BRM CE3; BRM NPOPX; BRU COK
* DISMISS MAP PROGRAM.
* INPUT:A=NUMBER OF DBITS RETURNED BY MAP. B=NO. OF ERRORS.
SDBMG  MIN 0; STA TRBLKS; MIN NPRUNS
        LDB =DHTPAC+35B5; LDX =QTI; BRU NPOPDS
* INPUT: A=NEW ZONE FOR MAP OF -1.
* NO SKIP RETURN: MAPNUM=A AND PZONE IS UNCHANGED.
* SKIP RETURN: MAPNUM IS NOT EQUAL TO A. PZONE CHANGED TO INPUT (A).
SDBMF  XMA PZONE; CAB; LDA MAPNUM; STA SS01; SKE PZONE
       BRU COK; STB PZONE; BRM NPOPX
* PUTS DISC HOLE TABLE (DHT) INTO MAP PROGRAM'S CORE AND CLEARS DHT.
* RESETS DHT POINTERS.
* INPUT: A=USER CORE ADDRESS FOR DHT.
SDBME  MRG X4; STA SS01; LDA MAPLBL; BRM RLABEL; BRU SDBME1
* REFRESH CALL.
SDBMD  LDA KM1; STA SDBM8; STA MAPING; BRU COK

       IF -1  (OLD REMAPPING CODE)
SDBMA  EQU *   SET MAP NUMBER. DETERMINE BIT MAP ZONE.
       SKA =-10B; BRM TRAP
       STA MAPNUM  STORE THE NUMBER OF THE CURRENT MAP ZONE.
       IF DISC=1; CLB; ELSE; MUL =32000/2; ENDF
       STB T  INITIAL 2314 RECORD TO BE MAPPED
       LDA MAPLBL; BRM RLABEL
       LDA =-25; STA DBITS  MAKE DBITS RUN OUT EARLY.SEE GETBLK.
       LDA KM1; STA MAPING  SET FLAG TO INDICATE WE ARE MAPPING.
       LDA X4; LDX MAPNUM; LRSH 24+3,2; STB MAPBIT; STA BITSUM
       IF DISC=1; EAX GA,2; STX GAP; EAX 1,2; STX GA1P; ENDF
       LDX =-TABLEN; STA EBITMP,2; BRX *-1   CLEAR BITMAP
       LDA =TABLEC/8-1; STA T2; LDB =776B5  X CONTAINS 0
SDBMA1 LDA T; SKA =-2B5; BRU SDBMA3  SKIP IF POSSIBLY IN EXEC AREA
       IF DISC>1; ETR K3777; SKG =3677B; SKG K77; BRU SDBMA2; ENDF
SDBMA3 LDA DSCTOP; SKG T; BRU SDBMA4 (NO MORE PHYSICAL DISC SPACE);
       LDA EIGHT; ADM DBITS; CBA; ADM BITMP,2; ADM BITSUM      FREE 8 BITS
SDBMA2 CBA; RCY 8; SKB X4; EAX 1,2; LDA EIGHT; ADM T; SKR T2; BRU SDBMA1
SDBMA4 BRU COK

SDBMB  EQU *   MAP ALL THE DISC SPACE FOR A FILE.
       CLB; BRM CDEL1   SET UP SIMILIAR TO BRS 66
       BRM PE                  CALL DELETE LOGIC
       BRM SETCC; LDA KM1; STA CSW1,2
       LDA 0,2; BRM CGRB1 (MAP TOP XBLOCK); BRM NPOPX; BRU COK
       ENDF  (OLD REMAPPING CODE - ALSO SEE CE1 CODE)

* SETMAP CALL.
SDBMC  EQU *   SET MAPING AND SDBM8 FLAGS TO ZERO TO INDICATE MAPING DONE.
       CLA; SKE DBMDA; BRU *+2; BRM TRAP  (DON'T SET FLAG IF NO BITMAP)
       STA MAPING; STA SDBM8; BRU COK


*      END OF BIT MAP ROUTINES  ***********
*              ******************** LOW LEVEL DISC SUBROUTINES
* 
* SETS FILE, BUFF, GFILE, CPTOP
* IOI DISMISSES IF FILE BUSY AND ACTS ON POSSIBLE EXCEPTIONAL CONDITIONS
* INPUT: A=LOCAL FILE NUMBER
* OUTPUT: A=LOCAL FILE NUMBER. X=TS BLOCK BFR ADRS.
$IOI   0;* VALIDATE LOCAL FILE NUM. DMS IF BFR BUSY. TRAP ON I/O ERRORS
       ETR ADMSK; SKG TWO; BRR IOI; SKG =2+NBUF; BRU *+2; BRM TRAP
       STA FILE; CAX; LDX BUF3,2; STX BUFF
       LDA CFLG,2; SKG ZERO; BRM TRAP  (FILE NOT OPENED)
       SUB =GFLG; STA GFILE    (INDEX IN GLOBAL GFLG TABLE)
       LDA =4B4; SKN GFILE; SKA* CFLG,2; BRU IOI2
       SKN CSW,2; BRU IOI1
       LDA CP,2; SKG CPTOP,2; BRU *+3; STA CPTOP,2; MIN CC+1,2
IOI1   SKN* CFLG,2; BRM CDMS1; LDA FILE; SKN CQ,2; BRR IOI
       LDA =MLVL; STA CQ,2; LDB =410B5 (QUANTUM EMPTY FLAG); BRU FILINT
IOI2   EQU *   FILE NOT OPENED OR UNRECOVERABLE ERROR
       SKN FILE; BRM CKERR; BRM TRAP

CKERR  0;* GENERATE SOFTWARE INT OR TRAP IF FILE I-O ERROR HAS OCUURED.
       LDA =4B4; SKA* CFLG,2; BRU *+2; BRR CKERR (NO ERROR, DO NOTHING);
       COPY N,B; ADM* CFLG,2 (CLEAR ERROR FLAG)
       STB CSW,2   ENTER READ MODE
       LDB =404B5; BRU FILINT

CDMS   0;* CALL POPDMS. ACTIVATE AT :CDMS2: WHEN DISC IS DONE.
       STA CDSA; STB CDSB; STX CDSX; BRM DTS
       LDA CDMS; STA CRET1 (:CDMS2: WILL DO A BRR CRET1 AFTER AWHILE)
       LDA =CDMS2; XMA 0; STA CRET0  (RESTART THIS USER AT CDMS2)
       SKA X4; STA SBRSRT    (SET UP SBRSRT IF NOT ALREADY SET UP)
       BRM CDMS1  

CPX    ZRO;* CONVERT USERS CP TO MONITOR CP.MONITOR CP HAS 4 CHARS/WORD.
       RSH 23; STA CPX2; CLA; DIV THREE
       STB CPX1; LSH 2; ADD CPX1; STA CPX1; BRR CPX
CPX1   0
CPX2   0

CPY    0;* CONVERT MONITOR CP (4 CHARS PER WORD) TO 3 CHARS PER WORD CP.
       STA CPY1; ETR THREE; XMA CPY1; RSH 2; MUL THREE; LSH 23
       ADD CPY1; LDX BUFF; SKN CSW,2; BRU *+2; MRG X4; STA CPY1; BRR CPY
CPY1   ZRO

CERR5  MIN CERRC
CERR4  MIN CERRC
CERR3  MIN CERRC
CERR2  MIN CERRC
CERR1  MIN CERRC
CERR   CLA; XMA CERRC; STA SS03; BRM NPOPX
$CERRC ZRO

CPRIV  0;* PUT PRIVELEGE MASK IN HIS X REGISTOR
       LDX BUFF; LDB* CFLG,2; LSH 39; ETR =377B5
       XMA SS03; ETR =40077777B; ADM SS03; BRR CPRIV

* COMPUTES WORD COUNT, CORE AND DISC ADDRESSES FOR CDTC.
* INPUT: A=INT. ROUTINE NO.  NEG. FOR WRITE.
CRW    0;* FILE READ WRITE ROUTINE.GET DISC ADRS AND CALL LOW LVL DRIVER
       STA CRW9
       LDX BUFF; LDB* CFLG,2; SKA X4; SKB TWO; BRU *+2; BRR CRW
       LDX LVL; LDA BFC+1,2; RSH 5; ADM CRW9
       BRM SETBIP; LDB* CBIP; SKB KM1; BRU *+2; BRM MONCR; LDB CBIP
       LDX LVL; LDA BUFF; ADD BFP+1,2; LDX CRW9; BRM CDTC
       BRR CRW
CRW9   ZRO

CW     0;* FILE WRITE.WONT WRITE A ZERO BFR. GETS AND GIVES BIT MAP BITS
       BRM SETBIP; LDA LVL; ADD BUFF; ADD =CC+1; STA CW8
       LDA KM1; XMA* CW8; SKG* CW8; BRR CW
       LDA* CBIP; SKA THREE; BRU CW3 (NON-DELETABLE DISC BLOCK)
       LDX LVL; LDA BUFF; ADD BFP+2,2; ADD CW9; STA CW1
       LDX BFCN+1,2; CLA
CW1    SKE 0,2; BRU CW2; BRX CW1
       LDB CBIP; SKE* CBIP; BRM CESW; BRR CW
CW2    SKE* CBIP; BRU CW3
       LDX BUFF; SKN CSW1,2; BRR CW
       BRM CG; STA* CBIP; SKR CW8; MIN* CW8
CW3    LDX BUFF; LDA =44B6; SKA CSW1,2; BRM CRW; BRR CW
CW9    SKE 0,2
CW8    0

CWALL  0;* START BUFFER LEVEL 1, 2, AND 3 WRITING. NO DISMISS NECESSARY.
       LDA =MLVL-1; STA LVL
       BRM CW; SKR LVL; LDA LVL; SKE ZERO; BRU *-4; BRR CWALL

CR     0;* FILE READ.CLEAR BFR IF DISC POINTER=0.
       LDB CR; STB CRET2
       BRM CW; LDA* CBIP; SKA DMSK; BRU CR1
       LDX BUFF; SKN* CFLG,2; BRM CDMS (DONT CLR YET.MAY BE WRITING);
       BRM CCLR; BRR CRET2
CR1    LDA K2B6; BRM CRW; BRR CRET2

CPOS   0;* DO EVERYTHING NEEDED TO POSITION FILE TO CP SPECIFIED IN A
       STA CT1 (POSITION TO CT1)  THIS ROUTINE MAY DISMISS ITSELF.
       LDX CPOS; STX CRET3; LDX =NLVL-2; STX LVL
CPS1   LDX LVL; LDX CSH1,2; LDB KM1; LSH 0,2
       LDX BUFF; LDA CP,2; SKM CT1; BRM CW; SKR LVL; BRU CPS1
CPS2   LDX BUFF; LDA CP,2; LDX =-NLVL
       LDB CMSK+NLVL,2; SKM CT1; BRU CPS4; BRX *-3
       BRM DTS; BRM SCEOF1; BRR CRET3
CPS4   LDA CT1; EOR CMSK1+NLVL+1,2; COPY AB,XA; LDX BUFF; STB CP,2
       ADD =NLVL; STA LVL; SKG =MLVL-1; BRM CR
       LDX BUFF; SKN* CFLG,2; BRM CDMS; BRU CPS2

CLS    0;*   CLEAN UP FILE I/O SO THAT FILE PARAMETERS CAN BE CLEARED.
       ETR ADMSK; SKG =NBUF+2; SKG TWO; BRM TRAP
       CAX; LDX BUF3,2; LDB CFLG,2; SKB KM1; BRU *+2; BRR CLS
       BRM IOI; LDA =MLVL-1; STA LVL; BRM CW; SKR LVL; BRU *-2
       BRR CLS

CLS5   0;*    CLEAN UP LOCAL AND GLOBAL FILE PARAMETERS
       CAX; LDX BUF3,2; LDB CFLG,2; SKB KM1; BRU *+2; BRR CLS5
       BRM IOI; BRM RLSFD (DECREMENT FDCB USE COUNT)
       LDA BUFF; BRM BPUT; BRM MONCR
       LDX GFILE; LDA KM1; STA XBP,2
       BRR CLS5

$EXBGET EQU *  BRS 144.LEND VERNE A BUFFER FOR AWHILE.
       BRM BGET; BRM NPOPX (NO FREE BFRS);
       LDA BUFF; SUB =34000B; STA SS01; BRU COK

$EXBPUT EQU *  BRS 145. FREE THE BFR THAT WAS BORROWED BY BRS 144.
       ADD =34000B; BRM BPUT; BRM MONCR; BRM NPOPX

BGET   0;*   FIND A FREE BUFFER
       LDX =-NBUF; LDA X4
       RSH 1; SKA FBWRD; BRU BGET1; BRX *-3; BRR BGET
BGET1  ADM FBWRD; EAX NBUF+3,2; CXA; ETR ADMSK; STA FILE
       LDX BUF3,2; STX BUFF
       MIN BGET; BRR BGET

BPUT   0;*   FREE A TS BFR. BFR ADRS IN A.
       LDX =-NBUF
       SKE BUFN,2; BRX *-1; SKE BUFN,2; BRR BPUT
       LDA X4; LRSH NBUF+1,2; SKA FBWRD; BRR BPUT
       ADM FBWRD; LDX BUFN,2; CLA; STA CFLG,2
       MIN BPUT; BRR BPUT

BSET   0;* CHANGE TS BLOCK VIRTUAL ADRS TO 16 BIT ABSOLUTE ADRS.
       RSH 11; LDA RLTS; LSH 11; STA T; BRR BSET

CEOFP  0;*  SET CEOF POINTER. CPTOP FOR INPUT, CEOF FOR OUTPUT
       LDX BUFF  POINT TO CEOF UNLESS (INPUT)AND(CPTOP LESS THAN CEOF).
CEOFP2 LDA CEOF,2; LDB CEOFP3; SKN CSW,2
CEOFP3 SKG CPTOP,2; LDB CEOFP2; STB CEOFP1; LDA* CEOFP1; BRR CEOFP
CEOFP1 0

SETCC  0;* SET CURSOR CHANGED FLAGS TO INHIBIT WRITES
       LDA BUFF; ADD SETCC1; LDX =-NLVL
       STA *+2; LDA KM1; STA BUFF+NLVL,2; BRX *-1; LDX BUFF; BRR SETCC
SETCC1 STA CC+NLVL,2

SCEOF1 0;*  SET CEOF1 SO THAT CIO,WIO LOGIC WILL KNOW WHEN TO CALL C256.
       BRM CEOFP; LDA CP,2; MRG CMSK+MLVL
       SKG* CEOFP1; BRU *+2; LDA* CEOFP1; STA CEOF1,2; BRR SCEOF1

C1     0;*  SET DATA BLOCK (BFR LEVEL=MLVL) CHANGED FLAG IF OUTPUT MODE.
       LDX BUFF; SKN CSW,2; BRR C1; MIN CC+MLVL,2; BRR C1

SETBIP 0;* POINT TO DISC ADRS THAT IS IN PARENT BFR OF BUFFER TO BE 
*      READ OR WRITTEN
       LDX BUFF; LDA CP,2; LDX LVL; ETR CMSK,2; EXU CSH,2
       ADD BFP,2; ADD BUFF; STA CBIP; BRR SETBIP

CCLR   0;* CLEAR THE BFR SPECIFIED BY L_L.
       LDX LVL; LDA BFP+1,2; ADD BFC+1,2; ADD BUFF; ADD =235B5; STA CCLR1
       LDX BFCN+1,2; CLA
CCLR1  STA 0,2; BRX CCLR1; BRR CCLR

CCLRX  0;*   CLEAR ALL THE BFRS FOR A GIVEN FILE.
       CLA
CX1    STA LVL; BRM CCLR; LDA LVL; ADD ONE
       SKG =MLVL-1; BRU CX1; BRR CCLRX


* SETS UP REGISTERS FOR DTC
* INPUT: A=CORE ADDRESS, B=POINTER TO DISC ADDRESS
*        X=INT. NO. AND WORD COUNT
CDTC   0;* CURSOR DTC. FOR FILES ONLY
       STA CDTCA; STB CDTCB; STX CDTCX
       SKN CDTCX; BRU CDTC1;* CHECK FOR SMALL WORD COUNT IF OUTPUT
       SKA MAPING; BRR CDTC  (DON'T WRITE IF MAPING); XXA
       SKA =176B; BRU CDTC1 (WORD COUNT GREATER THAN 40B);
       LDA* CDTCB; DIR; BRM CKSUM; EIR
*      PUT CHECKSUM INTO DISC ADDRESS AND MARK PARENT BUFFER CHANGED
       XMA* CDTCB; CAB; ETR DMSK; ADM* CDTCB
       LDA LVL; ADD BUFF; COPY AX,BA; SKE* CDTCB; MIN CC,2
CDTC1  LDX BUFF; LDA TWO; SKA CSW,2; SKA* CFLG,2; BRU *+2; BRR CDTC
       LDB GFILE; LSH 31; SKG ZERO; BRM MONCR
       IF NFILE>100B; ETR =17600B; ENDF; ADM CDTCX
       LDA CDTCA; SKA X4; BRU *+3; BRM BSET; BRU *+2; BRM DTH
       IF NFILE>100B
       LDB GFILE; LSH 38; ETR =14B6; MRG T
       ENDF
       LDB* CDTCB; LDX CDTCX; BRM DTC
       LDX BUFF; LDA K4B5; ADM* CFLG,2; BRR CDTC
CDTCA  0
CDTCB  0
CDTCX  0
CDTC9  EOR 0,2

PE     0;* MOVE TO CURSOR POSITION IN A. BACK UP CPTOP IF NECESSARY.
       STA CRET4; BRM CWALL; LDA PE; XMA CRET4
       LDX BUFF; SKE CPTOP,2; BRU PE6
       LDA CP,2; XMA CPTOP,2; MIN CC+1,2  SPECIAL CASE. DECREASE CPTOP.
PE6    STA CP2    CP2 IS THE FINAL GOAL OF THE ERASE
       LDA CP,2   START AT THE CURRENT POSITION
PE7    STA CP1  CP1 WORKS ITS WAY UP TO CP2.
PE1    BRM CWALL; LDA CP1; BRM CPOS
       LDX =MLVL-1; STX LVL; BRM SETBIP
       LDA CP2; SKG CP1; BRU PE9  (ERASE COMPLETED);
       LDA CP1; SKA CMSK+MLVL; BRU PE3 (CLEAR A FRACTION OF DATA);
       EOR CP2; SKG CMSK+MLVL; BRU PE4 (NO MORE FULL DATA BLOCKS);
       LDA CP1; ETR CMSK+MLVL-1; EXU CSH+MLVL-1
       EOR KM1 (CNA, SUB =1)  COMPUTE HOW MANY FULL DATA BLOCKS....
       ADD BFC+MLVL-1; STA CT2   .... CAN BE DELETED WITHOUT I/O.
       LDA CP2; SUB CP1; EXU CSH+MLVL-1; SUB ONE; SKG CT2; STA CT2
       SKR CBIP
PE2    MIN CBIP; LDB BFC+MLVL; LSH 26; ADM CP1  INCR. CP1 1 DATA BLOCK.
       LDB CBIP; CLA; SKE* CBIP; BRM CESW   DELETE A DATA BLOCK
       SKR CT2; BRU PE2; BRU PE1
PE3    MRG CMSK+MLVL; ADD ONE; SKG CP2; BRU PE5 (CLR BEG. OF DATA BLOCK);
PE4    LDA CP2   (CLR END OF DATA BLOCK)
PE5    STA CP1; BRM CLRPRT; BRU PE7
PE9    LDX BUFF; LDA CP,2; SKE CPTOP,2; SKG CPTOP,2; BRR CRET4
       LDA CP,2; MRG CMSK+MLVL; ADD ONE; BRM CLRPRT CLEAR GARBAGE PART OF
*      LAST DATA BLOCK SO IT WILL BE RELEASED IF USED PART WAS ALL ZERO.
       LDX BUFF; SKN CSW1,2; BRU PE9A
       LDA CPTOP,2; STA CP2; BRU PE7;* BACKUP TO THE NEW CPTOP.
PE9A   BRM CWALL; BRR CRET4;* DONT BOTHER TO REPOSITION .

CLRPRT 0;* CLEAR SOME OF THE CHARACTERS IN A DATA BLOCK.
       STA CLP9   CLEAR UP TO CLP9-1. START AT CURRENT CP.
       LDX BUFF; LDA CP,2; STA CLP8   CLP8 WORKS ITS WAY UP TO CLP9
CLP1   LDA CLP9; SKG CLP8; BRR CLRPRT
       LDX BUFF; MIN CC+MLVL,2; LDA CLP8; ETR CMSK+MLVL; RSH 2
       ADD BUFF; ADD BFP+MLVL; STA CLP7
       CLA; LSH 2; CAX; SKA THREE; BRU CLP3
       LDA CLP9; SUB CLP8; SKA KM4; BRU CLP2
CLP3   LDA CLP6,2; ADM CLP8; LDA CLP5,2
       ETR* CLP7; STA* CLP7; BRU CLP1
CLP2   LDA CLP9; SUB CLP8; ETR KM4; ADM CLP8
       MUL X7 (RSH 2,CNA); COPY AX,N,B; ADD CLP7; ADD CLP4
       STA *+1; STB 0,2; BRX *-1; BRU CLP1
CLP9   0
CLP8   0
CLP7   0
CLP6   DATA    1,1,2
CLP4   STB 0,2
CLP5   DATA    177777B,77600377B,77777400B

CDEL1  0;*  SET UP TO DELETE OR MAP A FILE
       LDX SS01; LDX BUF3,2; LDA* CFLG,2; SKA =4B4; BRM NPOPX (I/O ERR);
       STB CSW1,2; LDA SS01; BRM IOI
       LDA* CFLG,2; MRG K377; STA* CFLG,2; LDA KM1; STA CSW,2
       LDA CPTOP,2; BRR CDEL1

$CDEL3 ZRO;*   PUT A BIT INTO THE BIT MAP. FREE A BLOCK ON THE DISC.
       STA LB9   DISC ADDRESS FOR DHPUT ROUTINE
       SKA SDBM8; BRU CDEL3B   (NO MAP, PUT IN HOLE TABLE )
       BRM LOCBIT; BRR CDEL3 (ERR); BRU CDEL3B  (OK,UNMAPPED)
       SKA* LB; BRU CDEL3A  (ERR, BIT ALREADY MAPPED);
       ADM* LB; ADM BITSUM; MIN DBITS; BRU CDEL3C
$CDEL3E MIN CDEL3
CDEL3A BRM MPDSC; BRR CDEL3
CDEL3B LDA MAPLBL; BRM RLABEL; BRU DHPUT (STORE HOLE IN DHT TABLE)

CGRB1  0;*   GRAB A PARTICULAR BIT FROM THE BIT MAP.
       BRM LOCBIT; BRR CGRB1 (ERR); BRU CGRB1B (LEGAL ADRS NOT MAPPED)
       SKA* LB; BRU *+2; BRU CGRB1A (ERR, BIT ALREADY GRABBED);
       CNA; ADM* LB; ADM BITSUM; MIN CGRB1
       SKR DBITS; NOP
CGRB1A BRM MPDSC; BRR CGRB1
CGRB1B MIN CGRB1; BRR CGRB1

CG     0;*     GRAB A DISC BLOCK FOR A FILE
       LDA BUFF; ADD LVL; CAX; MIN CC,2
       LDX BUFF; LDA CBASE,2
       BRM GETBLK    (LOOK FOR A BLOCK IN THE BITMAP)
       LDX BUFF; MIN CSIZE,2; MIN CC+1,2; SKR CQ,2; NOP 0
       BRR CG   EXIT WITH DISC ADRS IN A AND BUFF IN X

* INPUT: B=BLOCK LOCATION INDIRECT
CE     0;*     ERASE A BLOCK
       STB CE9
       LDX BUFF; LDA CBASE,2; STA CBASEP (BASE/MAX PTR)
       LDA* CE9; SKA DMSK; SKA THREE; BRR CE; CLA; XMA* CE9
       ETR DMSK; BRM CDEL3; BRM TRAP
       LDA BUFF; ADD LVL; CAX; MIN CC,2
       LDX BUFF; MIN CQ,2; MIN CC+1,2; SKR CSIZE,2; BRR CE
*      BAD FILE WITH GOOD CHECKSUMS. CAUSE IT TO BE DESTROYED
       MIN CCKWRD,2    GARBAGE UP THE CHECKWORD SO FILE IS INACCESSABLE
       BRM SETCC; MIN CC+1,2   (WRITE TOP LEVEL XBLOCK ONLY); BRM TRAP
CE9    0;* POINTS TO DISC ADDRESS BEING DELETED
       
CESW   0;* CALL CE NORMALLY. CALL CE2 IF MAPPING A FILE FOR 1REFRESH.
       LDX BUFF; LDX CSW1,2; EXU CESW1+1,2; BRR CESW
CESW1  BRM CE (CSW1 =-1,NORMAL); BRM TRAP (OLD REMAP CODE - WAS BRM CE1)
       BRM CE   (BRS 66)
       BRM CE2  (REFRESHING DISC)

       IF -1   (OLD REMAP CODE - SEE SDBMA CODE)
CE1    0;* MAP A BIT
       STB CE9; LDA* CE9; SKA DMSK; SKA THREE; BRR CE1
       CLA; XMA* CE9; ETR DMSK
       BRM CGRB1; BRM NPOPX
       LDA BUFF; ADD LVL; CAX; MIN CC,2; BRR CE1
       ENDF  (OLD REMAP CODE)

CE2    0;*   SIMILAR TO CE1 CODE ONLY THIS IS FOR REFRESHING THE DISC
       STB CE9; LDA* CE9; SKA DMSK; SKA THREE; BRR CE2
       CLA; XMA* CE9; ETR DMSK; BRM CE3; BRM NPOPX
       LDA BUFF; ADD LVL; CAX; MIN CC,2; BRR CE2

CE3    0;*     TURN OFF A BIT IN THE REFRESHER PROGRAM'S BIT MAP
       IF DISC>1
       SKA =74000003B; BRR CE3  (GARBAGE)
       ABC; DIV =32000*2; CBX   (CALCULATE ZONE NUMBER)
       MUL =TABLEN; LSH 23  (MUL BY LENGTH OF A BITMAP IN WORDS)
       CXB; ADD =10000B; STA T  (ADD BEGINNING LOC. OF REFRESHER PROG.)
       CLA; DIV K30   (GET RELATIVE WORD NUMBER IN BITMAP)
       ELSE
       SKA =77000003B; BRR CE3; RSH 2; STA LB9; ETR K3777; LDX KM4
CE3B   SKG GAP,2; SKG GAD,2; BRU *+2; BRU CE3A (GET ZONE NUM)
       BRX CE3B; BRU CE3E   (COULDN'T FIND ZONE)
CE3A   CXA; ADD FOUR   (CONVERT TO ZONE NUM)
       MUL =TABLEN; LSH 23; ADD =10000B; STA T (ADDRESS IN REFRESSER PROG)
       LDA GAD,2; STA T1; LDA LB9; RSH 23; DIV K4000; MUL =GW
       LSH 23; STA LB8; LDA LB9; ETR K3777; SUB T1; SUB ONE; ADD LB8
       RSH 23; DIV K30
       ENDF
       ADD T; MRG X4; STA LB; LDA X4; CBX; LRSH 0,2; SKA* LB; BRU *+2
       BRU CE3E (ERROR); CNA; ADM* LB; MIN CE3; BRR CE3
CE3E   MIN CERROR; BRR CE3
CERROR 0 0     (NUMBER OF BITS ALREADY TURNED OFF)
*              ******************** END OF LOW LEVEL ROUTINES

       FORGET
$ENDD  EQU *
       END
MONITOR ** FICHE/FRAME BREAK *****
D SYMSORT

SYM.  PG.LN. IDENT.

ARD    11 39 D       ARD1   12  1 D       ARD2   12  2 D       
ARDD   11 32 D       AWD    11 38 D       AWDD   11 33 D       AWDD1  11 34 D       
B0      8 22 D       B0A     8 23 D       B0C     8 26 D       B157A   3 34 D       
B2      8 36 D       B2A     9 17 D       B2B     9 25 D       B2C     9 26 D       
B2E     9 34 D       B2R     9 14 D       B2W     9 10 D       B2W1    9 13 D       
B66A   18  8 D       B9      9 38 D       B99    10  7 D       B9A    10  4 D       
BFC     1 22 D       BFCN    1 23 D       BFP     1 21 D       BGET   24  7 D       
BGET1  24 10 D       BGRAB   8 32 D       BGRABA  8 34 D       BINC   11  9 D       
BIOX1   8  5 D       BPCT   11 18 D       BPUT   24 14 D       BRS1    1 27 D       
BRS147  3 24 D       BRS151  3 38 D       BRS157  3 29 D       BRS17   3 22 D       
BRS174  4 29 D       BRS181  4 15 D       BRS20   3 19 D       BRS66  18  3 D       
BRS77   3 25 D       BRS8    4 18 D       BRS92  18 28 D       BSET   24 21 D       
BSEZ   11 13 D       BT1    11 22 D       BT2    11 23 D       BT3    11 24 D       
BT4    11 25 D       BTC    10 27 D       BTC1   10 37 D       BTCA   11  5 D       
BTCB   11  6 D       BTCX   11  7 D       BWIO   10 14 D       BWIO1  10 23 D       
BZ1    11 16 D       C1     24 39 D       C2      5  3 D       C256    4 34 D       
CBASEP 18 23 D       CCLR   25  8 D       CCLR1  25 11 D       CCLRX  25 13 D       
CCLS    4  1 D       CDEL1  27 17 D       CDEL3  27 23 D       CDEL3A 27 30 D       
CDEL3B 27 31 D       CDEL3E 27 29 D       CDMS   21 25 D       CDTC   25 22 D       
CDTC1  25 31 D       CDTC9  26  4 D       CDTCA  26  1 D       CDTCB  26  2 D       
CDTCX  26  3 D       CE     28 10 D       CE1    28 29 D       CE2    28 36 D       
CE3    29  2 D       CE3A   29 13 D       CE3B   29 11 D       CE3E   29 21 D       
CE9    28 20 D       CEOFP  24 24 D       CEOFP1 24 28 D       CEOFP2 24 26 D       
CEOFP3 24 27 D       CERR   22  9 D       CERR1  22  8 D       CERR2  22  7 D       
CERR3  22  6 D       CERR4  22  5 D       CERR5  22  4 D       CERRC  22 10 D       
CERROR 29 22 D       CESW   28 22 D       CESW1  28 24 D       CG     28  2 D       
CGRB1  27 33 D       CGRB1A 27 38 D       CGRB1B 27 39 D       CKERR  21 19 D       
CKSM   15 26 D       CL1     4 21 D       CL2     4 25 D       CLP1   26 39 D       
CLP2   27  7 D       CLP3   27  5 D       CLP4   27 14 D       CLP5   27 15 D       
CLP6   27 13 D       CLP7   27 12 D       CLP8   27 11 D       CLP9   27 10 D       
CLRPRT 26 36 D       CLS    23 26 D       CLS1    4  4 D       CLS5   23 32 D       
CLSALL  4 19 D       CMSK    1 17 D       CMSK1   1 20 D       CN3     2 13 D       
CN3C    2 14 D       CN4     2 16 D       CN5     2 23 D       CN6     3 10 D       
CN6A    3 11 D       CN7     2 25 D       CN8     2 31 D       CN8A    3  5 D       
CNER4   3 15 D       CNERR   3 16 D       COK     3  4 D       CPOS   23 14 D       
CPRIV  22 12 D       CPS1   23 17 D       CPS2   23 19 D       CPS4   23 22 D       
CPX    21 32 D       CPX1   21 35 D       CPX2   21 36 D       CPY    21 38 D       
CPY1   22  2 D       CR     23  7 D       CR1    23 12 D       CRW    22 18 D       
CRW9   22 25 D       CSH     1 18 D       CSH1    1 19 D       CW     22 27 D       
CW1    22 33 D       CW2    22 35 D       CW3    22 38 D       CW8    23  1 D       
CW9    22 39 D       CWALL  23  3 D       CX1    25 15 D       DISCRW 12  3 D       
DP2IBM 15 32 D       DTC    15  1 D       DTC    13 22 D       DTC1   15 15 D       
DTC11  15  9 D       DTC11  15  5 D       DTC12  15  6 D       DTC13  15  7 D       
DTC2   13 27 D       DTC3   13 28 D       DTC8   13 38 D       DTCA   14  1 D       
DTCB   14  2 D       DTCBSV 15 23 D       DTCSW  13 39 D       DTCX   14  3 D       
DTS    16  8 D       ENDD   29 26 D       EXBGET 23 39 D       EXBPUT 24  4 D       
GB5A   14 18 D       GB5A   12 31 D       GB6    14 16 D       GB6    12 29 D       
GB6A   14 19 D       GB6A   12 35 D       GB8    14 20 D       GB8    12 32 D       
GB9    14 21 D       GB9    12 33 D       GBRAN  12 17 D       GETBLK 14 10 D       
GETBLK 12 21 D       GIVEB  18 20 D       GMC    16 15 D       GNM    17 18 D       
GNM1   17 35 D       GNM2   17 24 D       GNM3   17 38 D       GNM4   18  1 D       
GNM5   17 21 D       GNMR   17 34 D       GRABB1 18 10 D       GRABB2 18 17 D       
IOI    21  6 D       IOI1   21 14 D       IOI2   21 16 D       LB     14 32 D       
LB     13 13 D       LB8    13 12 D       LB9    14 34 D       LB9    13 11 D       
LOCBIT 14 23 D       LOCBIT 12 37 D       LOCBLK 18 25 D       PCEX1   5 10 D       
PE     26  6 D       PE1    26 13 D       PE2    26 23 D       PE3    26 26 D       
PE4    26 27 D       PE5    26 28 D       PE6    26 10 D       PE7    26 12 D       
PE9    26 29 D       PE9A   26 34 D       RCPX1   5 35 D       RSPX1   6  6 D       
SCEOF1 24 35 D       SCPX1   5 21 D       SDBM   19  8 D       SDBM1  19 10 D       
SDBM2  19 15 D       SDBMA  20  6 D       SDBMA1 20 18 D       SDBMA2 20 22 D       
SDBMA3 20 20 D       SDBMA4 20 23 D       SDBMB  20 25 D       SDBMC  20 33 D       
SDBMD  20  3 D       SDBME  20  1 D       SDBMF  19 35 D       SDBMG  19 30 D       
SDBMH  19 26 D       SDBMI  19 23 D       SDBMJ  19 21 D       SDBMK  19 19 D       
SETBIP 25  3 D       SETCC  24 30 D       SETCC1 24 33 D       SSPX1   5 39 D       

MONITOR ** FICHE/FRAME BREAK *****
FQJP
FQJP   IDENT 11/22/76
       LISTM

*      SCAN COMPUTE QUEUE FOR A CORE RESIDENT JOB THAT IS
*      READY TO RUN.

$FQJP1 SKN SCHLP; BRU FQJ3; LDX =QQEQ
       BRM SCAN; BRU FQJP6; BRU FQJ3; BRU FQJ11
FQJP6  SKN M48K; BRU *+2; BRU PEST6
       LDA PTAB,2; LRSH 15; ETR K77; CAX; STA SWJOB
       LDA PMTP,2; ADD =-NCMEM; STA SWPMT
       CNA; ADD =SMT; STA SWSMT
       LDX PACPTR; LDA RL1,2; LDB RL2,2; LDX =NCMEM
       BRM UPRL; LDX KM10D; DIR
FQJP2  STX SWIX; LDA SRTE,2; SKE ZERO; BRU *+2; BRU FQJP4
       SKG =NCMEM-1; ADD SWSMT; ADD SWPMT
       BRM SWLSC (CHECK TO SEE IF PAGE IS IN CORE)
       BRU FQJP5 (MISSING)
       LDX SWIX
FQJP4  BRX FQJP2
       EIR

* ALL PAGES IN CORE.  CHECK TO SEE IF COMPUTE JOB STILL BLOCKED

       SKN QQC; BRU FQJ3; LDX QQC
       SKN* PTEST,2; BRU FQJ3
       LDA PPREV; STA FQJPSW
       BRU PEST6               (GO SWAP IN JOB)
FQJP5  EIR; BRU PEST           (RETURN TO SCAN)

*      RETURN FQJP JOB BACK TO SAME PLACE IN COMPUTE QUEUE, UNLESS
*                              NEW DISMISSAL IS ON QTI.
*
$QPPUT ZRO
       SKN PACJOB; SKN FQJPSW; BRU QPPUT1
       COPY XA,B; SKN TTIME; BRU *+2; BRU QPPUT0
       SKE =QTI; BRU QPPUT2
QPPUT0 STB FQJPSW; LDA PACPTR
QPPUT1 BRM QPUT; BRR QPPUT
QPPUT2 LDX =QQEQ
QPPUT3 CXA; SKE FQJPSW; BRU QPPUT5
QPPUT4 LDA PACPTR; XMA PNEXT,2; LDX PACPTR; STA PNEXT,2
       MIN QQEC; SKG ZERO; BRU *+2; STX QQE+1
       STB FQJPSW; BRR QPPUT
QPPUT5 SKN PNEXT,2; BRU QPPUT4; LDX PNEXT,2; BRU QPPUT3

$FQJPSW DATA 0 (PPREV OF SELECTED FQJP PACT)

       END
MONITOR ** FICHE/FRAME BREAK *****
FQJP SYMSORT

SYM.  PG.LN. IDENT.

FQJP1   1  7 FQJP    FQJP2   1 15 FQJP    FQJP4   1 20 FQJP    
FQJP5   1 29 FQJP    FQJP6   1  9 FQJP    FQJPSW  2  8 FQJP    QPPUT   1 34 FQJP    
QPPUT0  1 38 FQJP    QPPUT1  1 39 FQJP    QPPUT2  2  1 FQJP    QPPUT3  2  2 FQJP    
QPPUT4  2  3 FQJP    QPPUT5  2  6 FQJP    
MONITOR ** FICHE/FRAME BREAK *****
I
I      IDENT  05/29/76

       LISTM

$UNIT  0;*     ACTIVE W BUFFER DEVICE NUMBER OR -1
$ACTR  0;*     ACTIVATION COUNTER

$XBP   BSS NFILE  TABLE FOR INDEX BLOCK POINTERS. INITIALIZED TO -1.
$EXBP  EQU *

$GFLG  BSS NFILE               FILE FLAGS INDEXED BY GFILE.
*      GFLAG FORMAT.GFLAG IS  INDEXED BY A GLOBAL FILE NUMBER.
*      GFLAG CONTAINS JOB AND LOCAL FILE NUMBERS. THE LOCAL FILE
*      BUFFER AREA CONTAINS THE CELL CFLG,2 WHICH POINTS TO THAT
*      FILE'S GFLAG WORD. HENCE, IT IS POSSIBLE TO GET GLOBAL INFO FROM
*      LOCAL INFO OR TO GET LOCAL INFO FROM GLOBAL INFO.
*      BITS 0-6. INITIALIZED TO -1. INCREMENTED FOR EACH DISC JOB
*      THAT IS STARTED. DECREMENTED BY INTERRUPT ROUTINE. GFLG (OR 
*      INDIRECT CFLG,2) IS POSITIVE WHEN FILE IS BUSY DOING I/O.
*      BITS 7,8 - LOCAL FILE NUMBER-3.    BIT 9 - ERROR DETECTED IN IDM
*      BITS 10-15 - JOB NUMBER
*      BITS 16-23 - FILE PRIVELEGE FLAGS
$EGFLG EQU *

$BUF    EQU *   TABLE OF LOCAL BUFF ADDRESSES IN TS BLOCK
$BUF3  EQU BUF-3
SYMBOL EQU FBADR
       RPT NBUF; DATA SYMBOL;SYMBOL EQU SYMBOL+NDBW; ENDR; FRGT SYMBOL
$BUFN  EQU     BUF+NBUF        

*      CURSOR POPS  *********

BIO    POPD    576B5
$BIOX  BRM* FSAVE1; BRU BIOX1

PCE    POPD    533B5           POSITION CURSOR AND ERASE
$PCEX  BRM* FSAVE1; BRU PCEX1

SCP    POPD    532B5           SET CURSOR POSITION
$SCPX  SKN 0; BRM MONCR (KEEP MONITOR FROM EXECUTING MARK LOCATIONS);
       BRM* FSAVE1; BRU SCPX1

RCP    POPD    531B5           READ CURSOR POSITION
$RCPX  BRM FSAVE; BRU RCPX1

SSP    POPD    526B5           SET PHYSICAL SIZE LIMIT FOR A FILE
$SSPX  BRM* FSAVE1; BRU NPOPX0

RSP    POPD    525B5           READ PHYSICAL SIZE, SIZE LIMIT, AND CPTOP
$RSPX  BRM FSAVE; BRU RSPX1

CIT    POPD    534B5           CHR INPUT AND TEST
$CITS   STA SS01; STB SS02; STX SS03
       LDA* 0; SKA =37770B; BRM TRAP; AXC; EXU *+1,2
       BRU TCIT; BRM TRAP; BRM TRAP; BRU CI2
       BRU CI2; BRU CI2; BRU CI2; BRM TRAP

CI2    LDX BUF3,2; STX BUFF; SKE CSW,2; BRM TRAP
       SKE CFLG,2; SKN* CFLG,2; BRU CFLGEX
       LDA CPTOP,2; SKG CP,2; BRU CI5
       LDA CP,2; RSH 2; ETR K377; ADD BUFF; AXC
       LSH 2 (A CONTIANS CHAR. POINTER); LDX CBF4,2 (DATA WORD)
       COPY AX,XA,XB; EXU CI3,2 (POSITION CHARACTER); ETR K377
       SKE SS01; BRU POPXB
*      DO A CIO AND MIN 0 AFTER THE CIO. SEE WEX3 AND C256 CODE.
       LDA WEX3; STA WEX; BRU CIE3
CI5    LDA K137; XMA SS01; SKE K137; BRU POPX; BRU POPX0
CI4    MIN 0   CIO COMPLETED WITHOUT CALLING DISC DRIVERS.
       LDB WEX2; STB WEX; BRU POPXB
CI3    LSH 8; RSH 8; NOP 0; BRM MONCR

CIO    POPD    561B5           CHR INPUT/OUTPUT
$CIE   STA SS01; STB SS02; STX SS03
CIE3   LDA* 0; SKA =37770B; BRU CIOT1A; AXC; EXU *+1,2
       IF CEM; BRU TCIO; ELSE; BRU CIOT1; ENDF; BRU CIOT1; BRU POPX; BRU CHRW
       BRU CHRW; BRU CHRW; BRU CHRW; BRM TRAP
CHRW   EQU *   CHARACTER READ/WRITE LOGIC
       LDX BUF3,2; STX BUFF; SKE CFLG,2; SKN* CFLG,2; BRU CFLGEX
       LDA CP,2; ETR THREE; SKN CSW,2; BRU *+3; MIN CC+MLVL,2; ADD FOUR
       XXA; LDB CHRW2,2; STB CHRW1; LDX CHRW3,2; XXA
       ADD CP,2; SKG CEOF1,2; BRU CHRW0
       STA CP1; LDA WEX1; STA WEX; LDA CP,2
CHRW0  XMA CP,2; RSH 2; ETR K377; ADD BUFF; COPY AX,A,B
CHRW1  0;* MODIFIED TO ONE OF THE FOLLOWING INSTRUCTIONS.
CHRW2  BRU CHR0; BRU CHR1; BRU CHR2; BRM MONCR
       BRU CHW0; BRU CHW1; BRU CHW2; BRM MONCR
CHRW3  DATA 1,1,2,0,1,1,2,0


* CIO INPUT ROUTINES DEPENDING ON CHAR. POSITION.
CHR0   LDA CBF4,2; LRSH 16; BRU WEX
CHR1   LDA CBF4,2; RSH 8; ETR K377; BRU WEX
CHR2   LDA CBF4,2; ETR K377; BRU WEX

* CIO OUTPUT ROUTINES DEPENDING ON CHAR. POSITION.
CHW0   LDB SS01; RCY 8; XMA CBF4,2; ETR K1S5; ADM CBF4,2
       LDA SS01; BRU WEX
CHW1   LDA SS01; ETR K377; LSH 8; XMA CBF4,2; ETR =77600377B; ADM CBF4,2
       LDA SS01; BRU WEX
CHW2   LDA SS01; ETR K377; XMA CBF4,2; ETR KM400; ADM CBF4,2
       LDA SS01; BRU WEX


WIO    POPD    560B5           WORD INPUT/OUTPUT
$WIE   STA SS01; STB SS02; STX SS03
       LDA* 0; SKA =37770B; BRM TRAP; AXC; EXU *+1,2
       BRM TRAP; BRM TRAP; BRU POPX; BRU WRW
       BRU WRW; BRU WRW; BRU WRW; BRM TRAP
WRW    EQU *   WORD READ/WRITE LOGIC
       LDX BUF3,2; STX BUFF; SKE CFLG,2; SKN* CFLG,2; BRU CFLGEX
       LDA CP,2; SKA THREE; BRM TRAP (CURSOR MUST POINT TO A WORD.)
       ADD FOUR; SKG CEOF1,2; BRU WRW1
       STA CP1; LDA WEX1; STA WEX; LDA CP,2
WRW1   XMA CP,2; RSH 2; ETR K377; ADD BUFF; SKN CSW,2
       BRU WRW2 (INPUT)
       MIN CC+MLVL,2; CAX; LDA SS01; STA CBF4,2; BRU WEX
WRW2   CAX; LDA CBF4,2
WEX    BRU POPXB (CHANGED TO NOP IF CP GT CEOF1)
       STA SS01; LDA WEX2; STA WEX
CALLD  BRM MPDSC; BRU C256
WEX1   NOP
WEX2   BRU POPXB
WEX3   BRU CI4                 USED BY CIT TO MIN 0 AFTER CIO RUNS.

CFLGEX EQU *   CFLG EXCEPTION. TRAP IF FILE UNOPENED. OTHERWISE, ASSUME
*      BUFFER IS BUSY AND DISMISS EVEN THOUGH BFR MAY HAVE BECOME FREE
       SKE CFLG,2; BRM CDMS1; BRM TRAP  DURING THE LAST FEW MICROSECONDS

$FILINT EQU *  FILE EXCEPTION INTERRUPT CODE. FILE EXCEPTION FLAGS IN B.
       CBA; MRG FILE; STA FLINT1
       SKN 0; BRU FLINT2 (DONT FLAG USER'S FILE WORD UNLESS IT IS IN
       CAB; LDX 0           HIS MEMORY).
       LDA 0,6; ETR =77B5; LDX SS03; SKE =73B5 (IS HE EXCUTING A BRS);
       STB* 0  (NO, IT MUST BE A FILE SYSPOP. FLAG HIS FILE WORD.);
FLINT2 BRM MPPACT; LDX PACPTR; LDA FLINT1; XMA SS01
       STA FLINT1; LDA K2B5; BRM RIIR; LDA FLINT1; XMA SS01
       SKA K2B5; BRU POPX (EOF); BRM TRAP (FATAL EXCEPTION)
FLINT1 0;* FILE WORD FLAGS.402B5=EOF,404B5=ERR,410B5=QUANTUM DEPLETION.

$CDMS1 0;*  DISMISS A USER UNTIL ALL HIS W BFR WORK IS DONE.
       LDA JOB; ADD CDMS10; CAB; LDX =QIO
       BRU NPOPDS
$CDMS10 10B TTNO ACTIVATION CONDITION 

$CDMS2 EQU *   RETURN HERE FOR ROUTINES DISMISSED BY :CDMS:
       STA SS01; STB SS02; STX SS03
       LDA CRET0; STA 0; BRM MPDSC
       LDA CDSA; LDB CDSB; LDX CDSX; BRR CRET1

FSAVE  0;* SAVE REGISTORS AND SET UP FOR FILE SYSPOP. CALLED BY 
*                         BRM FSAVE OR BRM* FSAVE1 FOR SKIPABLE SYSPOPS.
       STA SS01; STB SS02; STX SS03; BRM MPDSC
       SKN 0; BRR FSAVE
       LDA* 0; BRM IOI      VALIDATE FILE NUMBER
       SKG TWO; BRU FSAVE2    FILE =0,1, OR 2;
       LDX SS03; STA* 0; LDX BUFF
FSAVE1 BRR FSAVE
FSAVE2 LDX* FSAVE        WAS FSAVE CALLED INDIRECTLY.
       BRX NPOPX0        MAKE SKIP RETURN FOR PCE,SCP,SSP, AND BIO
       CLA; BRM NPOPXB         NON-SKIP FOR RCP,RSP

*      BASE/MAX STORAGE MEASUREMENT.  SEE W FOR REMAINDER OF CODE.

$CN3A  EQU *;* ENTRY POINT FROM BRS 1 (OUTPUT FILE)
       BRM MPWB; BRM SCSAO; BRU GTFDCB
       BRM MPPACT; LDX PACPTR; LDA PIM,2; MRG X1; STA PIM,2
       BRM MPDSC; LDA SIX; STA CERRC; BRU CNERR
$CN3B  BRM MPDSC; BRU CN3C (RETURN TO BRS 1 CODE)

$RLSFD ZRO;* DECREMENT FDCB USE COUNT
       LDX BUFF; LDA SIX; SKA* CFLG,2; BRU *+2; BRR RLSFD
       BRM MPWB; BRU RLSFD1
$RLSFD4 BRM MPDSC; BRR RLSFD

*      SYSPOPS

SNE    POPD 536B5              SKIP IF NOT EQUAL
$SNEX  SKE* 0; MIN 0; BRR 0
SKP    POPD 544B5              SKIP IF POSITIVE
$SKPX  SKN* 0; MIN 0; BRR 0
SKL    POPD 545B5              SKIP IF LESS
$SKLX  SKG* 0; BRU *+2; BRR 0; SKE* 0; MIN 0; BRR 0
* MAKE A STRING POINTER
SPTR POPD 114B5
$SPTR1 STX SS03
       EAX* 0
       CXA
       ETR K3S4
       MUL THREE
       LSH 23
       SUB ONE
       CAB
       BRU XPOPX

* ISC  INTERNAL TO STRING CONVERSION
NISC POPD 150B5
$NIOISC SKR UFIO
ISC2   NOP 24+5000B
ISC    POPD    140B5
$ISC1  STA     SS01
       LDA     ISC2
       BRU     SC1
* SIC  STRING TO INTERNAL CONVERSION
NSIC POPD 151B5
$NIOSIC SKR UFIO
SIC2   NOP 25+5000B
SIC    POPD    141B5
$SIC1  STA     SS01
       LDA     SIC2
SC1    STA     BSX
       STB     SS02
       STX     SS03
       EAX*    0
       CXA
       ETR     ADMSK
       STA     UBE
       BRU     BS4

       IF MDSI
* BRS 185 - READ DISC LIKE BRS 124.  DISC ADDRESSES RANGE BETWEEN
*      DSCTOP AND DSCTPD.
*
$BRS185 LDX X1; XAB; SKG DSCTOP; TRAP; XAB; BRU AWDD1

* BRS 186 - WRITE DISC LIKE BRS 125.
*
$BRS186 LDX X5; BRU BRS185+1

       ENDF


*      GENERAL I/O ROUTINES **************

$DTH    ZRO; ETR ADMSK; RSH 11; STB T; MUL THREE; CBX
       LDA RRL2; LDB RRL1; LCY 6,2; ETR K37; SKG SIX; BRM MONCR
       LDB T; LCY 11; STA T; BRR DTH

$XDIR  0; EOM 20004B; BRR XDIR   DISABLE INTERRUPTS

$XEIR  0; EOM 20002B; BRR XEIR   ENABLE INTERRUPTS

$RLABEL ZRO;*   SET RRL3=A. SAVE OLD RRL3 IN T4
       MLABEL; STA T4; BRR RLABEL

$BVIATS ZRO;* BIO BY WAY OF TS BLOCK. MOVE ONE DATA BLOCK.
       MIN WR4; LDX FILE; LDA BUF3,2; ADD =CBF4
       LDB* WR4; SKA WR5; XAB
       ADD BVLDA; STA BVCOPY; CBA; ADD BVSTA; STA BVCOPY+1; LDX KM400
BVCOPY 0; 0; BRX BVCOPY; BRR BVIATS
BVLDA  LDA 400B,2
BVSTA  STA 400B,2

$BRMC   ZRO;
       LDA* WR4; ETR =34000B; MUL =60000B; CAX; LDB WR11; LDA WR12
       LCY 6,2; ETR K37; STA BRMC1; LCY 6; ETR K37; CAX; BRR BRMC
$BRMC1  ZRO


*      **********  W BUFFER LOGIC

$TCLDMS SKS 10410B (TEST TAPE READY); BRU PACACT; BRU PEST

$WJ EQU * STORE WJOB AND EXIT
       BRM MPPACT; LDA PTAB,2; LRSH 15; ETR K77; STA WJOB; BRU POPX

* THIS CHECKS TO SEE THAT A TAPE INTERRUPT HAS NOT
* BEEN DELAYED FOR MORE THAN 3 SECONDS.
$WCLEAN 0
       LDA REAL; DIR; SKG TREAL; BRU WCL5; EOM* 0; EIR
       LDX WPTR; LDA WCL2; STA PTEST,2; SKR PL,2; NOP
       LDA WPAGE; MRG =RWP*64; MLABEL; STA CLWRL
       LDA K4B5; ADM* TMCA
WCL6   LDA KM1; STA WBIU; STA UNIT
       SKN TNUM; BRU WCL3; STA PRDMS1; BRU WCL4
WCL3   XMA TNUM; CAX; SKR TPDMS,2; NOP
WCL4   LDA XX; STA TREAL; SKN WPAGE; BRU *+2; BRU WCL7
       DIR; BRM WREL; EIR
WCL7   LDX WJOB; LDA K2B5; ADM TTNO,2
       IF DISC<3
       SKN DSW; BRM IDMGO
       ENDF
       LDA CLWRL; STA RRL3; LRR3; POT RRL3
WCL5   EIR; BRR WCLEAN
CLWRL  ZRO 0
WCL2   22B PACDMB


$TUA   DATA 0     USER'S VIRTUAL CORE ADDRESS
$TCA   DATA 0     CORE ADDRESS
$TWCNT DATA 0     WORD COUNT
$TNR   DATA 0     NUMBER OF RECORDS
$TRA   DATA 0     RECORD ADDRESS IN PAGE 7
$TMAR  DATA 0     CHANNEL MAR FROM PIN
$TPAR  DATA 0     TAPE PARITY. 1B3=BINARY
$TNUM  DATA -1    TAPE NUMBER
$TPDMS DATA -1,-1 TAPE DISMISS. ACTIVATE WHEN NEGATIVE.
$TPDMS3 12B UNIT    WAIT FOR UNIT TO CLEAR
$TMCA  ZRO 0   MONITOR COMMUNICATIONS WORD IN PAGE 7.
$CTMCA ZRO 0   TMCA FOR CONTROLS.
$WBIU  DATA -1   W BUFFER IN USE IF POSIT. DO NOT CHANGE DEV ASSIGN.
$WPTR  ZRO 0   PACPTR OF CONTROL FORK
$DEVICE DATA -1  DEVICE IN USE ON W BUFFER
$DEVCH DATA -1   CHANNEL ASSIGNED TO W BUFFER.
$TPE   DATA 0,0   MIN FOR EACH EOF AFTER TAPE END.
$TREAL DATA 37777777B   TIME WHIN TAPE MUST FINISH. (REAL+3 SEC.)
$TURL  ZRO 0   USER PAGE NUMBER.
$FMK   HLT* FMK2               POT WORD FOR EOF
FMK2   DATA 17B6               FILE MARK
$WJOB  ZRO  0                  USER JOB NO.
$TD2   ZRO 0   TAPE READ/WRITE POT WORD.  0-9=WD CNT. 10-23=ADDR.
$PRD6  ZRO 0   PRINTER POT WORD
$PRDMS1 DATA -1   PRINTER ACTIVATION WORD
$XSW DATA 0 (SWITCH USED BY W DRIVER ROUTINES)

$NINT2 MIN ACTR; BRM WREL
       IF DISC<3
       SKN DSW; BRM IDMW
       ENDF
       LDX WJOB; LDA K2B5; ADM TTNO,2; BRU WRET

* LOOK IN "B" FOR TRAP ROUTINES WHEN MONITOR ASSEMBLED WITH DISC<3
       IF DISC=3
*
*     TRAP ROUTINES  **********************
*
* ILLEGAL INSTRUCTION TRAP
$TRAPI  ZRO; STA SS01; STB SS02; STX SS03
       LDX PACPTR; LDA RL2,2; ETR =77B2
       SKE =16B2; BRU *+4; LDA RRL2; XMA RRL1; BRM MONCR (SAVES PAGES FOR CRASH)
       LDA TRAPI; LDB ONE; LDX =QTI; BRM PTRAP
*
*GENERAL TRAP LOGIC
* INPUT: A=TRAP LOC., B=REASON, X=QUEUE FOR NEW FORK.
       TLABEL PTP
$PTRAP  ZRO; STX PTRPA
       CAX; LDA =600B; MRG RLTS; BRM PTPL
       LDA RRL1; STA PTRL1; LDA RRL2; STA PTRL2; LDA RRL3; STA PTRL3; CXA
       LDX PACPTR; SKG KM1; BRU *+2; LDA 0; ETR =50037777B
       IF ALOG; DIR; LOGG 56B,PTRAP; EIR; ENDF
       STA PL,2; SKN XPB; BRM MONCR
       LDX XPB; LDA SS02; STA PB,2; LDA SS01; STA PA,2
       LDA SS03; STA PX,2
       IF      FPH
       HFST    FAC1,FAC2
       ENDF
       LDX     PACPTR
       BRM RFK; LDA PTRPA; BRM TFK; STA FK04

SUPBUG EQU 1
       IF SUPBUG
       IF SUPER
* CRASHES SYSTEM ON SUPERVISOR ERROR WHILE WE STILL HAVE SOME HOPE OF
* FINDING THE CLUE IN CORE.
       SKN SVST; BRU PTRPB; COPY AX,A; SKE PPTR,2; BRU PTRPB
       SKE 211B; BRM MONCR
       ENDF
       ENDF

PTRPB  LDX TF07; STX STFK2; LDA PTRL1; LDB PTRL2; LDX PTRL3
       BRM LABEL; BRM FKGO3
PTRL1  ZRO 0
PTRL2  ZRO 0
PTRL3  ZRO 0
PTRPA  ZRO 0   QUEUE FOR NEW FORK
$TRAP  ZRO 0; BRM MPPACT; SKN XPB; BRU *+3; LDA TRAP; STA ERCODE
       LDA SBRSRT; SKN 0; STA 0; LDA 0; LDB ONE; LDX =QTI; BRM PTRAP
*READ-ONLY TRAP
       TLABEL  TPR
$TRAPR  ZRO; STA TR01; STB TR02; STX TR03
       LDA TRAPR; ETR =50037777B; STA TR00; MIN TRPXMA
       BRM CAE; NOP; SKR TRPXMA; ETR =34000B; MUL =6B4; STA TPR4
       LDA RLTS; MRG =06B2; BRM TPRL
       LDX PUPAC; LDA RL2,2; LDB RL1,2
       LDX TPR4; LCY 6,2; ETR K77; SKG =NCMEM-1; BRU TPR26
       ADD PMTJOB; ETR ADMSK
TPR25  CAX; LDA 0,2; SKA X1
       BRU TPR3 (REALLY RO); CXA
       DIR; BRM W; EIR
       IF TSTAT; MIN NPGDRT; ENDF
       LDX TPR4; LDB RRL1; LDA RRL2; LCY 6,2; ETR =77777737B
       RCY 6,2; LDX RRL3; XAB
       SKN PACJOB; BRU TPR22; BRM STCMRL STORE COMPUT JB RELAB
TPR22  BRM LABEL
       LDA TPRL1; BRM TPRL
       IF      FPH
       LDA*    TR00
       LDB     =157B5
       SKM     =13B5
       BRU     *+2
       SKR     TX00
       BRU     *+1
       ENDF
       ROV; LDA TR00; LCY 1; LSH 1
       LDA TR01; LDB TR02; LDX TR03; BRU* TR00
TPR3   LDA TR01; STA SS01; LDA TR02; STA SS02; LDA TR03
       STA SS03; LDA TRAPR; SKA X4; STA 0; BRM MTRAP
TPR26  ADD =SMT; BRU TPR25
TPR4   ZRO 0
TR00   ZRO 0
TR01   ZRO 0
TR02   ZRO 0
TR03   ZRO 0
TRPXMA ZRO XMA41
XMA41  XMA 41B
XMA43  XMA 43B
*MEMORY TRAP

       TLABEL TPM
$TRAPM  ZRO;*   MEMORY TRAP INTERRUPT ROUTINE
       IF BUG
       STA TT01; LDA TRAPM; ETR =40037777B
       SKE =TT0M; BRU *+2; BRM MONCR; LDA TT01
       ENDF
       STA TX01; STB TX02; STX TX03
       LDA TRAPM; ETR =50037777B; STA TX00; BRM CAE
       MRG =40000B (MEMORY MUST COME FROM A HIGHER FORK)
       STA TT01; LDA =0600B; MRG RLTS; BRM TPML (MAP PMT); LDA TT01
       LDX PACPTR; BRM MGET; BRU TX05
       LDA TPML1; BRM TPML   (RESTORE RELABELLING)
       IF      FPH
       LDA*    TX00
       LDB     =157B5
       SKM     =13B5           CHECK FOR POT OR PIN FROM FP
       BRU     *+2
       SKR     TX00
       BRU     *+1
       ENDF
       ROV; LDA TX00; LCY 1; LSH 1
       LDA TX01; LDB TX02; LDX TX03; BRU* TX00
TX05   SKN TRAPM; BRM MTRAP
       LDA TX01; STA SS01; LDA TX02; STA SS02; LDA TX03; STA SS03
       LDA TX00; SKA X4; STA 0; BRM MTRAP
MTRAP  0; LDX PACPTR; LDA K1B6; BRM RIIR
MTPAN  LDA 0; LDB TWO; LDX =QTI; BRM PTRAP
TX00   ZRO
TX01   ZRO
TX02   ZRO
TX03   ZRO
       IF      BUG
$TT01   ZRO 0
       ENDF
       ENDF DISC=3
* COMPUTE EFFECTIVE OUT-OF-BOUNDS ADDRESS
* INPUT: A=TRAP LOC.
* OUTPUT: A=ADDRESS OR X4 IF POP CAUSED TROUBLE
* NO SKIP: USER POP OR P=LOC. BRANCHED TO.
*      TIME = 114 + N CY
$CAE    ZRO; STA CAE1; STX CAE3; SKN PUSW; BRU *+2; BRM MONCR
CAE11  BRM CEX; LDA* CAE1; BRU CAE4
* ADDRESS FOUND
CAE5   LDA CAE1; BRR CAE
* ADDRESS NOT FOUND
CAE4   LDA CEX3; STA CAE2; SKA X1; BRU CAE6; LDA IABIT; ADM CAE1
       LDX CAE3; BRM CEX; EAX* CAE1; BRU CAE7
* INDIRECT ADDRESS CHAIN OUT-OF-BOUNDS
       LDA KM4B4; ADM CAE1; BRU CAE9
CAE8   LDA CAE1; ETR X4; MRG CEX3; ETR =60037777B; STA CAE1
CAE9   LDX CAE3; BRM CEX; LDA* CAE1; BRU CAE8; BRU CAE5
* POP CAUSED TROUBLE
CAE6   LDA X4; BRR CAE
* CHECK FOR EXU- OTHERWISE X CONTAINS BAD ADDRESS
CAE7   CXA; ETR =40037777B; STA CAE1; LDA CAE2; EOR EXUW
       SKA =17700000B; BRU CAE10; LDX CAE3; BRU CAE11
* NOT EXU
CAE10  MIN CAE; BRU CAE5

CAE1   ZRO
CAE2   ZRO
CAE3   ZRO
EXUW   EXU     0
IABIT  ZRO*    0

* EXECUTE NEXT INSTRUCTION AND SKIP IF OUT-OF-BOUNDS
*      TIME = 31 + N CY
CEX    ZRO; MIN CEX; STA CEX1; LDA CEX2; EXU* TRPXMA; STA CEX3; EXU* CEX
CEX4   XMA CEX3; EXU* TRPXMA;  LDA CEX1; BRR CEX
* OUT-OF BOUNDS IF WE COME HERE
CEX2   BRU *+1; MIN CEX; BRU CEX4

CEX1   ZRO 0   SAVE A
CEX3   ZRO 0   CONTENTS OF A AS A RESULT OF EXECUTING NEXT INSTR.


* PARITY INTERRUPT ROUTINES  **************

$CPUP   0;* CPU PARITY. CPUP MAY CONTAIN ADRS OF FAILING INSTRUCTION.
       CKF; EOM 20004B (DIR); MIN CPC; SKN CPUP; BRU CPUP1
       SKN EXECS; BRU CPUP2
CPUP1  STX MCRX; LDX =100076B
CPUIOP STA MCRA; STB MCRB; BRM STOP
CPUP2  CKN; EOM 20002B (EIR); BRI CPUP

$IOPI   0;* IO PARITY INTERRUPT
       CKF; EOM 20004B (DIR)
       EOD 12000B; PIN IOPMAR; MIN IOP
       CKN; EOM 20002B (EIR); BRI IOPI

*      DISC AND NON-DISC W BFR INTERFACE ROUTINES  *********

WSA    0;*     W BUFFER INTERRUPT SAVE CELL
WSB    0
WSX    0
WSRRL3 0
$WPAGE 0;*     USER'S LOCKED PAGE
       IF DISC<3
$WSW   0;*     RETURN SWITCH FOR WRET. 0 FOR BRR, -1 FOR BRI.
WSAVE  0;* SAVE REGISTORS AND RELABELLING FOR ANY W BUFFER INTERRUPT
       SKN WS1; SKR WS1; BRR WSAVE
       STA WSA; STB WSB; STX WSX; LDA RRL3; STA WSRRL3; BRR WSAVE
WS1    0;* SAVE ONLY ONCE SWICTH

$WRET  EQU *   RESTORE THE REGISTORS AND EXIT FROM W BUFFER INTERRUPT
       SKN WSW; BRU *+3; IDT; EIR
       MIN WS1; LDA WSRRL3; MLABEL
       LDA WSA; LDB WSB; LDX WSX
       SKN WSW; SKR WSW; BRI* 31B
       SKN IDMW; BRI INT31; BRR* 31B
       ELSE
$WRET  LDA WSRRL3; MLABEL
       LDA WSA; LDB WSB; LDX WSX
       BRI INT31
       ENDF

$WB    0;*     DO A BRING ON THE 16 BIT ADRS IN A
       ETR =174B3; RSH 11; STA WPAGE; CAX; BRM DLOCKI; BRR WB

WREL   0;*     RELEASE WPAGE
       LDX WPAGE; BRM DLOCKD; BRR WREL

$INT31 0;*     THIS IS THE GENERAL W BUFFER INTERRUPT ENTRY POINT
       IF DISC<3
       BRM WSAVE
       ELSE
       STA WSA; STB WSB; STX WSX; LDA RRL3; STA WSRRL3
       ENDF
       LDA WPAGE; MRG =RWP*64; MLABEL
       LDA KM1; XMA UNIT; CAX
       EXU WINT,2 (VECTOR IN W PAGE)


* VARIOUS ENTRIES AND EXITS TO BIO SCANNER

$BIOSWP EQU * ENTRY TO PRESWAP CODE
       BRM MPWB; BRU BIOSW
$ST3O  EQU * EXIT FOR STATE 3 OUTPUT
       BRM RLABEL; BRU BST3O (IN BUFFERLET PAGE)
$ST3I  EQU * EXIT FOR STATE 3 INPUT
       BRM MPTYM; BRU MODCK
$TTIO2Z EQU * ISSUE AND INPUT/OUTPUT COMMAND
       BRM MPTYM; BRM SIO; BRU DEL1; BRU PR

$RACK2 EQU * MISSING PAGE IN SWAP.  SIMULATE A CIRCUIT ZAPPER
       BRM MPTYM; LDX BPORT; BRM TY1E3D
$DEL1  EQU * REMOVE TASK FROM TTQ.  RELABELING: ANY
       LDX BPORT; DIR; LDA TF5,2; ETR =-1-CSTAY; EIR; STA TF5,2
       SKR TTQ; BRU *+2; BRM MONCR
       LDX BPORT; LDA TF6,2; LDX PREPT
       SKA K100; STX TTQTL; BRM NMSK; STA TF6,2
$DEL2 EQU * RETURN BUFFERLET TO MAP.  RELABELING:  ANY
       LDX BPORT; LDA TF5,2; ETR =CHBNY; LRSH CHBNZ; COPY AX,B
       LDA K2B7; RCY 0,2
       SKA BFL; BRM MONCR; ADM BFL
* CHARGE FOR TIME BUFFERLET IN USE
       LDA REAL; SUB BLTIM,2; ADM BFLT; MUL BIOK3; ADM* TJOB
* UNLOCK BUFFERLET PAGE ONCE.  BE SURE SWLC IS SET UP BEFORE CALL.
       BRM MPPACT
       LDA =SMTP20; BRM SWLSC; BRU PR1
       LDA =SMTP20; DIR; BRM REL; EIR
$PR    EQU * RELEASE PROGRAM PAGE IF PG>-1
       BRM MPPACT
PR1    CLA; STA RLCT; XMA PPG; STA HLDC
       LDA =HLDC; SKN PG; BRM SWLSC; BRU PR2
       LDA HLDC; LDB =77B5; SKM =12B5; BRU PR2
       DIR; SKN PCL; BRM W; EIR; BRM HLDR (DOES REL)
PR2    DIR; BRM RAGO; EIR
       LDA =64237777B; STA SWLS; LDA KM1; STA PG
       IF TSTAT; LDA =NULJOB; STA CJOB; ENDF
       LDA =SETTB; STA TJOB
       SKN SWPCTR; BRU BIOSCF (SWAP QUANTUM USED)
$BIONXP EQU * CONTINUE TTQ SCAN
* WARNING *
* ALWAYS RESUMES WITH PORT POINTED AT BY PREPT, WHICH MAY BE
* THE SAME PORT IF QUEUE WAS NOT REORDERED
       BRM MPWB; BRU BIONX

*      DISC DRIVER AND ASSOCIATED ROUTINES  **************

$DREAL DATA 37777777B   SEE PU 3 SECOND ROUTINE

* DRQ MAP
*   WORD 0: DISC ADDR.
*   WORD 1: 0-7=FILE OR JOB NUMBER  8-23=CORE ADDR.
*   WORD 2: 0=R/W. 1-4=INT. ROUTINE. 5-10=JOB
*   WORD 2 CONTINUED     11-16=GLOBAL FILE NUMBER.17-23=WORD COUNT/40B
*      WORD 2 NEGATIVE FOR WRITE.
$DRQ   EQU *

$TYMSET 0;* INITIALIZE TYMNET. CALLED FROM SET.
       LDA RLTYM; BRM RLABEL
       LDX =-2-NPORT; LDA =TBUF; MUL THREE; LSH 23
       STA TP+NPORT+1,2; STB TC+NPORT+1,2; BRX *-2
       LDA =ETBUF*3-1; STA TP+NPORT
       LDX =-NTBI
       LDA TFREEC; LDB TFREE; STA ETBI,2; BRX *+1; STB ETBI,2; BRX *-3
       LDX =-NTBO
       STA ETBO,2; BRX *+1; STB ETBO,2; BRX *-3
       LDX KM100; LDA T128A+100B,2; STA T128+100B,2; BRX *-2
       LDB KM2; SKN M48K; BRU *+2; BRU *+6; LDB KM4
       LDA =22B5; STA ETBI-3; EOR KM1; STA ETBI-4
       LDA =2200400B; STA ETBI-1; EOR KM1; STA ETBI-2; STB TIX
       LDA T4; BRM RLABEL
       BRR TYMSET

M128   MACRO D
 DATA D(2).&B4+D(1).&B,D(4).&B4+D(3).&B,D(6).&B4+D(5).&B,D(8).&B4+D(7).&B
       ENDM

T128A  EQU *
       IF CEM
       M128 0121,7401,7011,7011,7211,7011,7011,7611
       M128 7011,7071,7621,7011,7011,7631,7011,7011
       M128 7011,7541,7011,7011,7011,7011,7011,7551
       ELSE
       M128 0121,7011,7011,7011,7011,7011,7011,7411    0-7
       M128 7011,7071,7421,7011,7011,7431,7011,7011
       M128 7011,7011,7011,7011,7011,7011,7011,7011
       ENDF
       IF MDSI
       IF CEM
       M128 7011,7011,7011,7041,7131,7041,7261,7051
       ELSE
       M128 7011,7011,7011,7041,7131,7041,7061,7051
       ENDF
       ELSE
       IF CEM
       M128 7011,7011,7011,7041,7041,7041,7261,7051
       ELSE
       M128 7011,7011,7011,7041,7041,7041,7061,7051
       ENDF
       ENDF
       M128 4411,7411,6411,6411,6411,6411,6411,6411     40-47
       M128 6411,6411,6411,6411,6411,6411,6411,6411
       M128 4411,4411,4411,4411,4411,4411,4411,4411   
       M128 4411,4411,6411,6411,6411,6411,6411,6411
       M128 6411,4411,4412,4411,4411,4413,4411,4411    100-107
       M128 4411,4411,4411,4411,4411,4411,4411,4411
       M128 4411,4411,4411,4411,4411,4411,4411,4411
       M128 4411,4411,4411,6411,6411,6414,6411,6411
       M128 4501,4501,4501,4501,4501,4501,4501,4501     140-147
       M128 4501,4501,4505,4501,4501,4506,4501,4501
       M128 4501,4501,4501,4501,4501,4501,4501,4501
       M128 4501,4501,4501,6501,6511,6511,6511,0121

* SYSTEM START
$SETSET EOM* 0; TSN; LRR3; POT =RSR; BRU SETSA
*
* MOVE W ROUTINES FROM REAL PAGE 11 TO REAL PAGE 7.
*
$SETWUP LDA =711B RELABEL W ROUTINES IN AND SET .
       BRM RLABEL
       CLA; LDX =-1000B; STA 31000B,2; BRX *-1 (CLEAR RAERT)
       LDX =35000B; LDA 0,2; STA -4000B,2; BRX SETMAP; BRU *-3
* INITIALIZE MAP PAGE.  GETS DISC HOLE TABLE CLEARED AND SOME MAP
* CODE MOVED INTO 11 WHICH ORIGINALLY CAME OUT OF 7.
SETMAP LDA =1113B; BRM RLABEL
       LDX =-1300B; LDA 35300B,2; STA 31300B,2; BRX *-2
       LDA =607B  (START SCHEDULER WITH THIS RELABELING IN M6 & 7)
       BRM RLABEL
       ARMI AIRWD   (ARM INTERRUPT LEVELS)
       CKN 0   (CLOCK ON)
       EIR 0   (ENABLE INTERRUPTS)
       BRU PACGO1 (START SCHEDULER)
* ONCE ONLY CODE FOR LOGGING IN PORTS 0-1
$TY11E SKE ONE; BRU TY11C; LDA TY11D; STA TY11B; BRU TY11C

       BSS 3*NDRQ+DRQ-*   RESERVE 3*NDRQ CELLS BETWEEN DRQ AND DRQU
$DRQU  EQU *   END OF DRQ
       ZRO 0   THIS CELL MODIFIED AT MUX15 AND BY DIM


       IF DISC<3

$DTS   ZRO;* START DISC IF IT IS NOT ALREADY EXECUTING A COMMAND CHAIN.
       LDA KM1; XMA DTXS1; SKG DTXS1; BRU DTS1
       ADD ONE; DIR; ADM NDCL; SKG NDCL; BRU DTS1
       SKN IDCL1; BRU DTS1; MIN DSW; LDA UNIT; SKG ZERO; BRM IDMGO
DTS1   EIR; SKN DBITS; BRR DTS  (RETURN IF DBITS LEFT)
       BRM GNM     (OUT OF DBITS IN THIS MAP, TRY AND GET NEW MAP)
       BRR DTS; BRR DTS  (NORMALLY, THERE IS A SKIP RETURN)

$IDMW  DATA -1   CALLED TO START DISC AFTER NON-DISC W BFR INTERRUPT
       STA IDMWA; STB IDMWB; STX IDMWX
       BRM IDMGO; BRU WRET
IDMWA  0;* RESTORE THESE REGISTORS AFTER THE DISC IS DONE. SEE :IDM2:
IDMWB  0
IDMWX  0

$IDMGO 0;*     GIVE THE DISC CONTROL OF THE W BUFFER
       LDA BRMW2; STA 31B; LDA BRMW3; STA 33B; LDA KM1; STA DSW
       CLA; STA UNIT; MIN WSW; BRM IDM; BRR IDMGO

* 'IDM'  4/16/66
* THIS IS THE DISC INTERRUPT ROUTINE FOR ALL DISC I/O
*   IDM MAKES ALL READS AT LEAST 64 WORDS.
IDMCK  ZRO;* 1 IF AN INTERRUPT IS PENDING. OTHERWISE 0.
$NDCL  ZRO;* COUNT OF DISC COMMANDS IN LIST
$EDCL  ZRO;* CURRENT END OF LIST
$IDCL  ZRO;* CURRENT INTERRUPT POINTER
$IDCL1 ZRO;* CURRENT COMMAND EXECUTING POINTER.
IDCL2  ZRO
ID01   ZRO     0               WORKING CELL
ID02   EOM     17200B          I/O CONTROL EOM
ID03   DATA    -200B           READ DIFFERENCE
$ID05   EOM     3666B           WRITE EOM
ID06   DATA    -1040B          READ  DIFFERENCE
IDSW1A EOM     10026B          ALERT DISK
IDSW1B BRU     ID3
IDCADD ZRO     0
DRMTRY ZRO;* TRY-AGAIN COUNTDOWN
$DSW   DATA -1 THIS SWITCH IS POSITIVE WHEN DISC WAITING FOR W BUFFER
*              TO BE FREED FROM ANOTHER W BUFFER UNIT
BRMW1  BRM  INT31
BRMW2  BRM IDM
BRMW3  BRM IDM2
$DTXS1  ZRO;* COMMAND COUNT
$DTXS2  ZRO;* LAST COMMAND LOC

$IDM   ZRO     0
$DRT    SKS 10026B; BRU DRT1    DISC READY TEST
$DET    SKS 11026B; BRU ID7     DISC ERROR TEST
$DCT    SKS 11000B; BRU ID7     DISC CHANNEL ERROR TEST
IDSW1  BRU     ID3             ALERT DISK  OR  BRU ID3
       POT*    IDCL            DISK ADDRESS
       EOM*    10000B          ALERT CHNL
IDE2   BRU     *               I/O CONTROL EOM
       POT     IDCADD          CORE ADDRESS
IDE1   BRU     *               R/W BUC
       BRM WSAVE; SKR NDCL; NOP 0       (SAVE REG.,DECR. COMMAND COUNT)
       LDA REAL; STA DREAL; MIN IDMCK
       LDA IDSW1B; STA IDSW1
       LDA IDCL; ADD THREE; SKE =DRQU; BRU *+2; LDA =DRQ; XMA IDCL (NXT CMD
ID4    XMA IDCL1; STA IDCL2; SKG KM1; BRU ID5 (IDCL1 IS EXECUTING)
       MIN XARMOT
       CAX; LDA 1,2; RSH 11; ETR K37; CAX; BRM DLOCKD
       LDX IDCL2; LDA 2,2; RSH 13; ETR K77; STA IDJOB
       CAX; LDA K2B5; ADM TTNO,2; SKN TTNO,2; MIN ACTR
       LDX IDCL2; LDB 2,2; LSH 5; ETR K17; CAX; LDA IDT,2; ETR XX
       STA IDTX; SKG IDT,2; EXU IDTX
       LSH 12; ETR K77
       IF NFILE>100B
       LDX RQ3; LDB 1,2; COPY BA,AX; ETR =14B6; RSH 38; COPY BA,XA
       ELSE
       ENDF
       ADD =GFLG; STA IDFILE
       SKG =GFLG; BRM MONCR
       EXU IDTX

IDTRET LDA THREE; STA DRMTRY          (DISC TRIES 4 TIMES)
ID5    LDA IDCL; SKN NDCL; BRU ID6; BRU ID1 (SETUP NXT CMND OR WINDUP)
ID6    EQU *      SETUP NEXT COMMAND
       STA IDCL; CAX
ID6A   LDA 1,2; SKG =33777B; BRM MONCR
       LRSH 14; ETR THREE; STA ID01  (2 HIGH ORDER CORE ADR BITS)
       CLA; RSH 5; LDA 2,2; ETR K177   (WORD COUNT/40B)
       SKG ONE; LDA TWO (WORD COUNT IS 40B. MAKE IT 100B);
       RSH 5; STB IDCADD
       ADD ID02; SKN 2,2; ADD ID03; STA IDE2
       LDB ID01; LSH 29; ADM IDE2
       LDA IDSW1A; STA IDSW1        (SET SWITCH TO XEQ COMMANDS)
       LDA ID05; SKN 2,2; ADD ID06; STA IDE1 (MAKE READ/WRITE EOM)
       SKN IDCL1; BRU ID1; BRU IDSW1     (EXIT IF CMND ACTIVE)
ID1    SKN WSW; BRU WRET
       SKN IDCL1; BRU *+2; BRU WRET
*      RESTORE STATE OF MACHINE, THEN CHECK FOR LOST INTERRUPT. SEE IF
*      IDCL1 COMMAND HAS FINISHED.
       MIN WS1; LDA WSRRL3; MLABEL; LDA WSA; LDB WSB; LDX WSX
       CZTW   SKIP IF W BFR WORD COUNT REGISTOR = 0; BRI IDM
       BRU IDM+1 (NOTE THAT IT IS ASSUMED THAT IDM WAS CALLED AS AN
*      INTERRUPT (DIDNT CHECK WSW).
ID3    BRM WSAVE; LDA KM1; BRU ID4 (SETUP TO INDICATE NO CMND EXECUTING)

IDDR   EQU *    PROCESS DATA BLOCK READ INTERRUPT
       LDX IDCL2; LDA 2,2; SKA =176B; BRU IDDW
*      WORD COUNT IS 40B. CHECK CHECKSUM.
       BRM IDLBL
       LDX IDCL2; LDB 0,2; SKB =74B6; BRU *+2; BRU IDDR1
       LDA 1,2; MRG =34000B; COPY AX,BA; BRM CKSUM
       LDB =74B6; SKM* IDCL2; BRU *+2; BRU IDDR1
       MIN DF; LDA* IDCL2; BRM IDER; BRM IDFAIL
IDDR1  LDA IDLBL1; MLABEL
IDDW   EQU     *
       LDA =-4B5; ADM* IDFILE
       BRU IDFRET

DRT1   EQU *  DISC WASNT READY WHEN IT SHOULD HAVE BEEN
       MIN DXX; EXU DRT; BRU *+2 (STILL NOT READY)
       BRU DET (A FEW MICROSECONDS LATE, MAY LOSE A REVOLUTION)
       BRM WSAVE
DRT2   LDX =-1000/7   SET UP FOR 1 MILISECOND LOOP
       EXU DRT; BRX *-1   7 MICROSECONDS PER ITERATION
       BRX DET  BRANCH IF DISC BECAME READY IN LESS THAN A MILISECOND
       MIN D26 (RECORD SERIOUS FAILURE)
       BRU DRT2

ID7    EQU *   ERRORS
       SKN IDCL1; BRU *+2; BRU ID3
       BRM WSAVE; LDA* IDCL1; BRM IDER   RECORD DISC ADDRESS
       EXU DET; MIN DS; EXU DCT; MIN DC
       SKR DRMTRY; BRU ID7A; MIN DU; BRU IDSW1
ID7A   MIN NDCL; LDA KM1; XMA IDCL1; BRU ID6

IDFRET EQU *   CHECK FOR HARDWARE ERRORS AND RETURN
       SKN DRMTRY; BRU IDTRET
       BRM IDFAIL; LDA* IDCL2; BRM IDER; BRU IDTRET

IDM2   ZRO; SKN IDCL1; BRU IDM22
       BRM WSAVE; LDA BRMW1; STA 31B; STA 33B
       LDA KM1; STA UNIT; XMA IDMW    RESET IDMW
       XMA IDM2; STA INT31  MOVE IDM2 TO INT31 AND SAVE IDMW
       SKN IDM2; BRU *+2 (RETURN TO NON-DISC W BFR ACTIVITY); BRU WRET
       LDA WPAGE; MRG =RWP*100B; MLABEL
       LDA IDMWA; LDB IDMWB; LDX IDMWX; BRR IDM2
IDM22  EXU DCT; BRU *+4; EXU DET; BRU *+2; BRI IDM2
       MIN WSW; BRM IDM; BRU IDM2+1

       ELSF DISC=3

* DIM MAKES RQ2 CATCH UP TO RQ1.
* RQ1 IS SET EQUAL TO RQ1A BY DTS.
$RQ1A  EQU 30B HEAD OF LIST CREATED BY DTC
$RQ1   EQU 32B HEAD OF LIST THAT 620 IS PROCESSING. SET UP BY DTS
$RQ2   EQU 34B CURRENT JOB BEING PROCESSED BY 620 UNLESS RQ1 = RQ2
$RQ3   EQU 35B CURRENT JOB BEING POST PROCESSED BY 940 UNLESS RQ3=RQ2

IDA    0
IDB    0
IDX    0
IDMC1  0

$IDM   0; MIN IDMC1
       STA IDA; STB IDB; STX IDX
       LDA REAL; STA DREAL;* STORE REAL TIME IN DREAL
* RQ2-DRQ SHOULD ALWAYS BE MULTIPLE OF 3
       LDA RQ2; SUB =DRQ; MUL THIRD; SKB K6B7; BRM MONCR
ID1    LDA RQ3; SKE RQ2; BRU ID2
       LDA IDA; LDB IDB; LDX IDX
       BRI IDM
ID2    MIN XARMOT
       LDX RQ3; LDA 2,2; RSH 13; ETR K77; STA IDJOB
       COPY AB,AX; LDA K2B5; SKB KM1; ADM TTNO,2; SKN TTNO,2
       IF TSTAT1
       BRU ID2B
       ELSE
       MIN ACTR
       ENDF
ID2A   LDX RQ3; LDA 1,2; RSH 11; ETR K37; CAX; BRM DLOCKD
       LDX RQ3; LDB 2,2; LSH 5; ETR K17; CAX; LDA IDT,2; ETR XX
       STA IDTX; SKN IDT,2; EXU IDTX
       LSH 12; ETR K77
       IF NFILE>100B
       LDX RQ3; LDB 1,2; COPY BA,AX; ETR =14B6; RSH 38; COPY BA,XA
       ELSE
       ENDF
       ADD =GFLG; STA IDFILE
       SKG =GFLG; BRM MONCR
       EXU IDTX

* FIX UP DRQ ENTRY SO DIM CANNOT USE IT AGAIN IF DIM MISREADS RQ1.
IDTRET LDX RQ3; LDA 1,2; EOR X6; STA 1,2
       SKA X4; BRU *+4; LDA 0,2; MIN DU; BRM IDER
       EAX RQ3; BRM INCRQ; BRU ID1
       IF TSTAT1
ID2B   MIN ACTR
       LDA REAL; STA DISCTT,2
       BRU ID2A
       ENDF

$INCRQ 0;* INCREMENT DRQ POINTER AND WRAP AROUNQD IF NECESSARY
       LDA 0,2; ADD THREE; SKE =DRQU; BRU *+2; LDA =DRQ; STA 0,2; BRR INCRQ

IDDR   EQU *
       LDX RQ3; LDA 2,2; SKA =176B; BRU IDDW
       BRM IDLBL
       LDX RQ3; LDA 1,2; MRG =34000B; AXC
       LDB* RQ3; SKB X7; BRM CKSUM (CHECKSUM BFR IF CKSM IS KNOWN)
       LDB X7; SKM* RQ3; BRU *+2; BRU IDDR1
       MIN DF; LDA* RQ3; BRM IDER; BRM IDFAIL
IDDR1  LDA IDLBL1; MLABEL
IDDW   EQU *
       LDA =-4B5; ADM* IDFILE

IDFRET EQU *
       LDX RQ3; LDA 0,2; SKN 1,2; BRU IDTRET; BRM IDFAIL; BRU IDTRET

       ENDF
IDT    EQU *   DISC INTERRUPT DISPATCH TABLE WITH FLAGS
* FLAGS        BIT 0 FOR FILE OPERATION,BITS 1 AND 2 UNUSED
       BRU IDTRET; BRU IDDR,4; BRU IDDW,4; BRM MONCR
       BRU ID124; BRM MONCR; BRM MONCR; BRM MONCR
       BRU IDBPR,4; BRU IDBPW,4; BRU IDBR,4; BRU IDBW,4
IDTX   ZRO 0   INSTR FROM IDT MINUS FLAGS


IDBR   EQU     IDDR            BIO READ INTERRUPT
IDBW   EQU     IDDW            BIO WRITE INTERRUPT
IDBPR  EQU *   BIO READ INTERRUPT FOR PAGE BOUNDARY
IDBPW  EQU *   BIO WRITE INTERRUPT FOR PAGE BOUNDARY
       BRM IDLBL; LDX WR4; SKN 1,2; BRU IDDR1
       LRR1; POT WR11; LRR2; POT WR12
       BRM BVIATS; BRM BRMC; BRM DLOCKD; LDX BRMC1; BRM DLOCKD
       LDA RRL3; ETR K37; CAX; BRM DLOCKD
       EIR; LRR1; POT RRL1; LRR2; POT RRL2
       BRU IDDR1

IDFAIL 0;* FAILURE DURING FILE I/O. SET FLAG TO CAUSE TRAP IN IOI.
       LDA* IDFILE; MRG =4B4; STA* IDFILE; BRR IDFAIL


IDLBL  ZRO;*   LABEL TS BLOCK
       LDA =0600B; MLABEL; STA IDLBL1; LDX IDJOB
       LDA* PMTP,2; ETR K37; ADM RRL3; LRR3; POT RRL3; BRR IDLBL
IDLBL1 ZRO

$CKSUM 0;* COMBINE AND FOLD DISC ADR AND WORDS 0,1,2, AND 37B OF BFR
*      A CONTAINS DISC ADR. X CONTAINS CORE BFR ADR.
       IF DISC=3; LDA 0,2; ELSE; ETR DMSK; EOR 0,2; ENDF
       EOR 1,2; EOR 2,2; EOR 37B,2
       STA CKS9; LSH 8; STA CKS8; LSH 8; EOR CKS9; EOR CKS8
       STA CKS9; LSH 4; EOR CKS9
       IF DISC<3; ETR =74B6; ELSE; ETR X7; ENDF
       BRR CKSUM
CKS9   0;* TEMP FOR FOLDING OPERATION
CKS8   0

$DLOCKI ZRO;*    LOCK PAGE FOR DISC
       DIR
       LDA =600B; ADD RLTS; BRM DLOCKR
       LDA RMC,2; SKG =775B; SKN XPB; BRU *+3; MIN DSKMET; MIN SDSKMT
       IF DISC=3; LDA KM4; ELSE; LDA KM8; ENDF
       ADM TTIME
       LDA K777; ADM RMC,2; LDA RMT,2; BRM B; LDA KM4; STA DLOCK
       LDX =7-NMEM; LDA =775B; SKG ERMC,2; MIN DLOCK; BRX *-2
* ADJ FOR BUFF. TER. I/O PG
* ADJ IN DLOCKI ONLY SINCE THIS PG STAYS LOCKED FOR LONG PERIODS
       LDA BFL; SKE =37777000B; MIN DLOCK
       LDA DLR1; BRM DLOCKR
       EIR; BRR DLOCKI

$DLOCKD ZRO;*    DECREMENT PAGE LOCK FOR DISC
       DIR
       LDA =06B2; BRM DLOCKR
       LDA RMC,2; SUB K777; STA RMC,2; SKG =776B; SKR DLOCK; NOP
       LDA RMT,2; BRM REL; BRM DRAGO
       LDA DLR1; BRM DLOCKR
       EIR; BRR DLOCKD

DLOCKR ZRO;* SET RELABELLING FOR DLOCK ROUTINES
       XMA RRL3; LRR3; POT RRL3; STA DLR1; BRR DLOCKR
DLR1   ZRO

ID124  EQU *   INTERRUPT ROUTINE FOR BRS 122,123,124,125
       IF DISC<3; SKN DRMTRY; ELSE; LDX RQ3; SKN 1,2; ENDF; BRU IDTRET
       LDA =600B; BRM DLOCKR
       LDX IDJOB; SET =4B4,TTNO SET BRS 122,123,124,125 ERROR BIT
       LDA TTNO,2; ETR K77; CAX; LDA TTYASG,2    FIND FORK DOING I-O
       CAX; LDA PPTR,2; RSH 12; MRG PLMSK; SKE PLMSK; BRU *-5
       LDA IDJOB; ADD CDMS10; SKE PTEST,2   (IS FORK DISMISSED ON IO)
       BRU ID124A   NO, OR YES BUT FORK IS ALREADY SET TO RUN AT PACTRP
       SKR PL,2; NOP 0
       ADD =12B5; STA PTEST,2    SET PTEST TO ACTIVATE AT PACTRP
       SUB =20B5  (MAKE PUTST WORD); XXA; RSH 12  (PUPAC IS B0 TO B11);
       LDA =-2B5; ADM 0,2  DECR. PTEST SO FORK WONT RUN BEFORE PU
       LDA 0,2   CHANNEL NUMBER IN X REQUIRED BY PU; XXA
       BRM EPU
ID124A LDA DLR1; BRM DLOCKR
       BRU IDTRET

* ROUTINE TO SAVE DISC ADDRESS OF ERROR
$IDER  0;* PUT DISC ADR OF FAILURE INTO TABLE
       IF DISC=3; ETR KS7; ELSE; ETR DMSK; ENDF
       STA* IDER1; MIN IDER1; SKN* IDER1; BRR IDER
       LDA EIDER; ADM IDER1; BRR IDER
IDER1  ZRO *+1
$IDER2 BSS 10
EIDER  DATA    -10
IDJOB  0
IDFILE 0
$XARMOT 0;* MINNED IN IDM FOR EVERY DISC TRANSFER COMPLETED
$DLOCK  DATA    -4 4 LESS THAN THE NUMBER OF PAGES LOCKED FOR DISC
$DMSK  DATA 3777777B   DISC ADRS MASK
$NDMSK DATA 74B6
$DSCTOP DATA 8*128000-1   MAX. 8 PACK 2314 ADDR. ALLOWED BY FILE I/O.
$DSCTPD DATA 8*128000-1   MAX. 8 PACK 2314 ADDR. ALLOWED BY DISCRW.
* NORMAL MACHINES CHECK DISC ADDR. AGAINST DSCTOP IN DTC.  THE MDSI
* MACHINE USES DSCTT, WHICH IS SET TO DSCTOP OR DSCTPD:
       IF MDSI
$DSCTT  DATA 8*128000-1
       ENDF

$BJOB  ZRO
$SWPCNT BSS NJOB;* NUMBER OF PAGES SWAPPED IN FOR THIS JOB.
       IF NFILE>100B
* LOOK IN "S" FOR PU QUEUE AND TABLES WHEN NFILE>100B
       ELSE
$CCT   BSS NJOB;* NUMBER OF CHARACTERS FOR THIS JOB.
       IF PTICK
$PTCKS BSS NJOB;* PACE*TICKS, CORE CHARGE.
       ENDF
$PUCT   BSS NPUQ*4
$EPUCT3 EQU PUCT+NPUQ*4+4
$EPUCT  EQU PUCT+NPUQ*4
$EPUCM3 EQU PUCT+NPUQ*4-4
       ENDF

       FORGET
ENDI   EQU *
       END
MONITOR ** FICHE/FRAME BREAK *****
I SYMSORT

SYM.  PG.LN. IDENT.

ACTR    1  6 I       BIO     1 33 I       BIONXP 15 34 I       
BIOSWP 14 36 I       BIOX    1 34 I       BJOB   26 25 I       BRMC    7 19 I       
BRMC1   7 22 I       BRMW1  19 20 I       BRMW2  19 21 I       BRMW3  19 22 I       
BRS185  6 28 I       BRS186  6 32 I       BUF     1 25 I       BUF3    1 26 I       
BUFN    1 29 I       BVCOPY  7 15 I       BVIATS  7 11 I       BVLDA   7 16 I       
BVSTA   7 17 I       CAE    12 19 I       CAE1   12 38 I       CAE10  12 36 I       
CAE11  12 20 I       CAE2   12 39 I       CAE3   13  1 I       CAE4   12 24 I       
CAE5   12 22 I       CAE6   12 31 I       CAE7   12 33 I       CAE8   12 28 I       
CAE9   12 29 I       CALLD   4  3 I       CCT    26 30 I       CDMS1   4 23 I       
CDMS10  4 26 I       CDMS2   4 28 I       CEX    13  7 I       CEX1   13 12 I       
CEX2   13 10 I       CEX3   13 13 I       CEX4   13  8 I       CFLGEX  4  8 I       
CHR0    3 13 I       CHR1    3 14 I       CHR2    3 15 I       CHRW    2 38 I       
CHRW0   3  5 I       CHRW1   3  6 I       CHRW2   3  7 I       CHRW3   3  9 I       
CHW0    3 18 I       CHW1    3 20 I       CHW2    3 22 I       CI2     2 19 I       
CI3     2 31 I       CI4     2 29 I       CI5     2 28 I       CIE     2 34 I       
CIE3    2 35 I       CIO     2 33 I       CIT     2 13 I       CITS    2 14 I       
CKS8   24 36 I       CKS9   24 35 I       CKSUM  24 27 I       CLWRL   8 11 I       
CN3A    5  8 I       CN3B    5 12 I       CPUIOP 13 22 I       CPUP   13 18 I       
CPUP1  13 21 I       CPUP2  13 23 I       CTMCA   8 26 I       DCT    19 29 I       
DEL1   15  8 I       DEL2   15 13 I       DET    19 28 I       DEVCH   8 30 I       
DEVICE  8 29 I       DLOCK  26 14 I       DLOCKD 25 13 I       DLOCKI 24 38 I       
DLOCKR 25 21 I       DLR1   25 23 I       DMSK   26 15 I       DREAL  16  3 I       
DRMTRY 19 17 I       DRQ    16 11 I       DRQU   18 14 I       DRT    19 27 I       
DRT1   21 15 I       DRT2   21 19 I       DSCTOP 26 17 I       DSCTPD 26 18 I       
DSCTT  26 22 I       DSW    19 18 I       DTH     6 39 I       DTS    18 20 I       
DTS1   18 24 I       DTXS1  19 23 I       DTXS2  19 24 I       EDCL   19  5 I       
EGFLG   1 23 I       EIDER  26 10 I       ENDI   27  2 I       EPUCM3 26 37 I       
EPUCT  26 36 I       EPUCT3 26 35 I       EXBP    1  9 I       EXUW   13  2 I       
FILINT  4 12 I       FLINT1  4 21 I       FLINT2  4 18 I       FMK     8 34 I       
FMK2    8 35 I       FSAVE   4 33 I       FSAVE1  5  1 I       FSAVE2  5  2 I       
GFLG    1 11 I       IABIT  13  3 I       ID01   19  9 I       ID02   19 10 I       
ID03   19 11 I       ID05   19 12 I       ID06   19 13 I       ID1    22 26 I       
ID1    20 31 I       ID124  25 25 I       ID124A 25 39 I       ID2    22 29 I       
ID2A   22 37 I       ID2B   23 15 I       ID3    20 39 I       ID4    20  1 I       
ID5    20 18 I       ID6    20 19 I       ID6A   20 21 I       ID7    21 25 I       
ID7A   21 30 I       IDA    22 16 I       IDB    22 17 I       IDBPR  24  9 I       
IDBPW  24 10 I       IDBR   24  7 I       IDBW   24  8 I       IDCADD 19 16 I       
IDCL   19  6 I       IDCL1  19  7 I       IDCL2  19  8 I       IDDR   23 23 I       
IDDR   21  2 I       IDDR1  23 30 I       IDDR1  21 10 I       IDDW   23 31 I       
IDDW   21 11 I       IDE1   19 35 I       IDE2   19 33 I       IDER   26  4 I       
IDER1  26  8 I       IDER2  26  9 I       IDFAIL 24 18 I       IDFILE 26 12 I       
IDFRET 23 34 I       IDFRET 21 32 I       IDJOB  26 11 I       IDLBL  24 22 I       
IDLBL1 24 25 I       IDM    22 21 I       IDM    19 26 I       IDM2   21 36 I       
IDM22  22  4 I       IDMC1  22 19 I       IDMCK  19  3 I       IDMGO  18 35 I       
IDMW   18 28 I       IDMWA  18 31 I       IDMWB  18 32 I       IDMWX  18 33 I       
IDSW1  19 30 I       IDSW1A 19 14 I       IDSW1B 19 15 I       IDT    23 38 I       
IDTRET 23 11 I       IDTRET 20 17 I       IDTX   24  4 I       IDX    22 18 I       
INCRQ  23 20 I       INT31  14 23 I       IOPI   13 25 I       ISC     6  4 I       
ISC1    6  5 I       ISC2    6  3 I       M128   16 29 I       MTPAN  12  5 I       
MTRAP  12  4 I       NDCL   19  4 I       NDMSK  26 16 I       NINT2   9  3 I       
NIOISC  6  2 I       NIOSIC  6 10 I       NISC    6  1 I       NSIC    6  9 I       
PCE     1 36 I       PCEX    1 37 I       PR     15 23 I       PR1    15 25 I       
PR2    15 29 I       PRD6    8 38 I       PRDMS1  8 39 I       PTCKS  26 32 I       
PTRAP   9 23 I       PTRL1  10 10 I       PTRL2  10 11 I       PTRL3  10 12 I       
PTRPA  10 13 I       PTRPB  10  8 I       PUCT   26 34 I       RACK2  15  6 I       
RCP     2  4 I       RCPX    2  5 I       RLABEL  7  8 I       RLSFD   5 14 I       
RLSFD4  5 17 I       RQ1    22 12 I       RQ1A   22 11 I       RQ2    22 13 I       
RQ3    22 14 I       RSP     2 10 I       RSPX    2 11 I       SC1     6 15 I       
SCP     1 39 I       SCPX    2  1 I       SETMAP 18  2 I       SETSET 17 31 I       
SETWUP 17 35 I       SIC     6 12 I       SIC1    6 13 I       SIC2    6 11 I       
SKL     5 25 I       SKLX    5 26 I       SKP     5 23 I       SKPX    5 24 I       
SNE     5 21 I       SNEX    5 22 I       SPTR    5 28 I       SPTR1   5 29 I       
SSP     2  7 I       SSPX    2  8 I       ST3I   15  1 I       ST3O   14 38 I       
SUPBUG  9 37 I       SWPCNT 26 26 I       SYMBOL  1 27 I       T128A  16 33 I       
TCA     8 16 I       TCLDMS  7 27 I       TD2     8 37 I       TMAR    8 20 I       
TMCA    8 25 I       TNR     8 18 I       TNUM    8 22 I       TPAR    8 21 I       
TPDMS   8 23 I       TPDMS3  8 24 I       TPE     8 31 I       TPR22  10 32 I       
TPR25  10 25 I       TPR26  11  7 I       TPR3   11  5 I       TPR4   11  8 I       
TR00   11  9 I       TR01   11 10 I       TR02   11 11 I       TR03   11 12 I       
TRA     8 19 I       TRAP   10 14 I       TRAPI   9 15 I       TRAPM  11 19 I       
TRAPR  10 18 I       TREAL   8 32 I       TRPXMA 11 13 I       TT01   12 11 I       
TTIO2Z 15  3 I       TUA     8 15 I       TURL    8 33 I       TWCNT   8 17 I       
TX00   12  6 I       TX01   12  7 I       TX02   12  8 I       TX03   12  9 I       
TX05   12  1 I       TY11E  18 11 I       TYMSET 16 13 I       UNIT    1  5 I       
WB     14 17 I       WBIU    8 27 I       WCL2    8 12 I       WCL3    8  2 I       
WCL4    8  3 I       WCL5    8 10 I       WCL6    7 39 I       WCL7    8  5 I       
WCLEAN  7 34 I       WEX     4  1 I       WEX1    4  4 I       WEX2    4  5 I       
WEX3    4  6 I       WIE     3 27 I       WIO     3 26 I       WJ      7 29 I       
WJOB    8 36 I       WPAGE  13 36 I       WPTR    8 28 I       WREL   14 20 I       
WRET   14 12 I       WRET   14  5 I       WRW     3 31 I       WRW1    3 36 I       
WRW2    3 39 I       WS1    14  3 I       WSA    13 32 I       WSAVE  13 39 I       
WSB    13 33 I       WSRRL3 13 35 I       WSW    13 38 I       WSX    13 34 I       
XARMOT 26 13 I       XBP     1  8 I       XDIR    7  4 I       XEIR    7  6 I       
XMA41  11 14 I       XMA43  11 15 I       XSW     9  1 I       
MONITOR ** FICHE/FRAME BREAK *****
JRSS
JRSS   IDENT 11/14/75
       NOLIST STAT,EXT

       ENTRY GUN,RDEN,TYPCHR,PNTUNO,PNTFD,PRINT,PNTUN
       ENTRY RDPAGE,CWIDTH,GOPT,FLFT,PPCT,AVG,CLEANUP,PFILE,PPFILE
       ENTRY TDATE1,PTIME,PRHD,PRFHD
       ENTRY PPAC,PRMTE,PIND,PRQHD
       IF TTQSW; ENTRY PBL; ENDF

*READ USER NAME AND LOOK UP IN LUD
*SKIPS IF FOUND WITH X = POINTER TO ENTRY
GUN    LDA =12; STA T1
       SPTR UNM; STP STPTR; CLAB; STP UNM; STP UNM+2; BRU GUN11
GUN1   SKR T1; WCI STPTR
GUN11  SBRM NXCH
       SKE CRCH; SNE =9; BRU GUN1A
       SKE LFCH; BRU *+2; BRU GUN1A
       SKE =40B; BRU *+3; LDA TEN; BRU GUN1
       SKG K77; BRU GUN1; BRU GUN11 (IGNORE CONTROLS)
GUN1A  STA T2 (TERM CHAR); SKP T1; R1
       LDX =UNM; JRS RDEN (READ ENTRY FROM LUD); R1 (NOT THERE)
GUN2   LDA 6,2; ETR =1777777B; STA GAN
       LDA 8,2; ETR =3774B; STA DSTRCT
       LDA 4,2 (F.D.PTR.); ETR =3777B; R2

*READS ENTRY FROM LUD GIVEN PTR TO STRING IN X
*RETURNS LOCATION OF ENTRY IN X
$RDEN  STX T1
       SPB FHASH (FORM HASH LOC)
RDEN1  SPB RBLK (READ BLOCK FROM DISC); LDB T1 (LOC. OF STRING)
RDEN2  STX T4; LDA 0,2; SKG ZERO; BRU RDEN3 (GO TO NEXT OR END)
       SKE* T1; BRU RDEN4 (NO COMPARE)
       LDA 1,2; XXB; SKE 1,2; BRU RDEN5
       LDA 2,2; XXB; SKE 2,2; BRU RDEN4
       LDA 3,2; XXB; SKE 3,2; BRU RDEN5
       XXB
       R2 (NAME COMPARES, PUT LOC. IN X)
RDEN5  XXB (RESTORE REGISTERS)
RDEN4  EAX 9,2; BRU RDEN2
RDEN3  SNE ZERO; R1 (NAME NOT IN LUD)
       SKE KM1; BRU *+3; MIN T3 (NEXT HASH LOC.); BRU RDEN1
       SKE =-2; HLT 0; BRU RDEN4 (EMPTY SLOT)

TYPCHR EQU *  PRINT CHARACTER WITH CONTROLS
       SKG =137B; BRU *+5; SKN USTA; R1
       TCF ='&'; ETR K77; CIO POUT
       R1

PNTUNO EQU *  PRINT USER NAME FROM UNIV. USER NO.
       CLB; BRU *+2
PNTFD  EQU *  PRINT USER NAME FROM F.D. PTR
       LDB KM1; STA UNO; STB CHARSW; STB FDSW
       CLA; STA BLKNO; JRS RDPAGE
SCHLUD LDA BLKNO; SKG =895; BRU *+2; BRU ENTRY
       SPB LUDPOS; SKG ENDPAG; BRU *+2; JRS RDPAGE
       LDX BUFPT; LDB =377777B
EXLOOP LDA 0,2; SKE ZERO; BRU *+2; BRU NXTBLK; SKE KM1
       BRU *+2; BRU NXTBLK; SKE =-2; BRU *+2; BRU NXTENT
       LDA 4,2; SKN FDSW; LDA 7,2; SKG ZERO; HLT
       SKM UNO; BRU NXTENT; LDA 4,2; ETR =3777B; STA UN; CXA; BRU OUTUN
NXTENT EAX 11B,2; BRU EXLOOP
NXTBLK LDA K100; ADM BUFPT; MIN BLKNO; BRU SCHLUD
ENTRY  LDA UNO; SKG ZERO; BRU NOUNO; SPB PONO; TCF ='?'
       R1
NOUNO  TYPE MGONE; R1

PRINT  EQU *  PRINT USER NAME FROM LUD LOC.
       STB CHARSW; STA OFFSET; ETR =1777B; XMA OFFSET
       RSH 10; STA BFRPOS; LDA OFFSET; SPB LUDPOS
       CAB; LDA =BFR; LDX =64; BRS 124; ADD BFRPOS
       STA BUFPT; CAX; LDB 4,2; XAB; ETR =3777B; XAB; STB UN
OUTUN  MUL THREE; LSH 23; SUB ONE; CAB; ADD =12; XAB
       STP PTR; SKN CHARSW; BRU PNTUN; GCD PTR; BRU *+3
       SKG ZERO; BRU *-3; MIN PTR+1
PNTUN  LDP PTR; LDX POUT; BRS 35; R1

RDPAGE EQU *  READ LUD PAGE
       LDA BLKNO; SPB LUDPOS; CAB; LDA =30000B
       LDX =4000B; BRS 122; COPY AX,BA,B; ADD =37B
       STA ENDPAG; STX BUFPT; BRS 55; R1


CWIDTH EQU * SET WIDTH ACCORDING TO OPTIONS SET
       LDA THREE; STA WIDTH
       LDX =-24; LDA OPTWE,2; SKNF 24,2; ADM WIDTH; BRX *-3; R1

GOPT   EQU * READ 3 CHAR OPTION TO DELIMITER
       SPTR BFR; STP STPTR; EAX STPTR; JRS GCMND; LDA BFR; R1

* DIVIDE 'A' (INTEGER) BY "FLOAT", PRINT IN F10.4
FLFT   BRS 150; FFDV FLOAT; STFM FLTEMP; TYPE F104,FLTEMP; R1

PPCT EQU * DIVIDE 'A' (INTEGER) BY "FLOAT", CONVERT TO PERCENT,
       BRS 150; FFMP F100; BRU FLFT+1 (PRINT IN F10.4)

AVG EQU * DIVIDE A BY B AND PRINT IN FLOATING FORMAT (F10.4)
       COPY BA,AX,B; SKE ZERO; BRU DIVOK; LDX =-10; CIO POUT
       BRX *-1; R1
DIVOK  BRS 51; STP DIVISOR
       CXA; BRS 150; FFDV DIVISOR; STFM DIVISOR
       TYPE F104,DIVISOR; R1

*CLEAN UP AFTER MON SNAPSHOT FILE ERROR
CLEANUP SPB BRS11; SPB BRS29; SPB CLSCFI; SPB CLEAN; R1

*PRINT FILENAME FROM FILPT
PFILE  LDP FILPT
PPFILE LDX POUT; BRS 35; R1

*      PRINT TIME FROM CUBS GMT IN 'A'
TDATE1 LDX K12B5; BRS 176; STA T1
       LRSH 20; ADD K72D; STA T2; CLA; LSH 4
       ADD ONE; SPB PDNO (TYPE MONTH); TCF K17
       LDA T1; ETR K1S5 (EXTRACT  OUT THE MINUTES); RSH 23; DIV K1440D
       STB T1 (SAVE THE MINUTES OF THE DAY); ADD ONE (ADJUST THE DAY)
       SPB PDNO (TYPE DAY); TCF K17
       LDA T2; SPB PDNO
       SPB TAB2 (TYPE 2 SPACES); LDA T1
PTIME  RSH 23;* PRINT TIME FROM MINUTES IN 'A'
       DIV K74 (60D)(COMPUTE HOURS); STB T1 (SAVE MINUTES)
       SKG NINE; TCF K20
       SPB PDNO (TYPE HOURS); TCF COLNCH; LDA T1; SKG NINE
       TCF K20 (0)(LEADING ZERO); SPB PDNO (TYPE THE MINUTES); R1 TDATE

* PRINT COLUMN HEADINGS
PRHD TCF CRCH; SKN HDSW1; R1; MIN HDSW1
       TYPE MPORT
       LDX =-9; SKNF 9,2; TYPE (_COLHDA,2); BRX *-2
       LDA WIDTH; SKG MWI; SKF 9; BRU *+2; TYPE COL9A
       TYPE MNUM
       LDX =-9; SKNF 9,2; TYPE (_COLHDB,2); BRX *-2
       LDA WIDTH; SKG MWI; SKF 9; BRU *+2; TYPE COL9B
       TCF CRCH
       R1

* PRINT COLUMN HEADINGS FOR FILES
PRFHD TCF CRCH; SKN HDSW3; R1; MIN HDSW3
       TYPE FILHED; R1

* PRINT HEADINGS FOR PMTS
PRPHD  TCF CRCH; SKN HDSW2; R1; MIN HDSW2
       TYPE PMTHED; R1
* PRINT PACT ENTRY FROM ADDRESS IN X.  PRESERVE A.
*      PACPTR IN T7, REAL IN T9
PPAC   STA T5; STX T6
* PACT
       TYPE MPACP
       LDA T7; CNA; SPB PONO; LDA T7; SNE XTTY; TYPE MTTYA
* PL
       LDX T6
       PEEK -3,2; STA T4; ETR K3S4; STA T1
       LDA =UM; SKN T4; LDA =MM; STA T2
       LDA T4; LRSH 15; ETR K77; STA T3
       LDA T4; LRSH 21; ETR ONE; STA T4
       TYPE _T2,T1,T4,T3
       PEEK -2,2; LDP* PPTR; STP RL
       TYPE MREL,RL,RL+1
       PEEK 1,2; STA ACT; LRSH 15; SKE =7; BRU PPAC1
       LDA ACT; ETR =7; CAX; TYPE (_SPTEST,2); BRU PPAC2
PPAC1  CAX; TYPE (_QTAB,2); LDA XCACLST,2; STA T1; PEEK* ACT; BRU* T1
XPEST  TYPE BLOCKM; BRU PPAC2
XACT   TYPE MRDY; BRU PPAC2
UNKAC  TYPE UNKTES
* JOB AND STATUS
PPAC2  LDX T6; PEEK 2,2; STA T3; LRSH 15; ETR K77; STA T1
       TYPE MJS,T1
       PEEK 3,2; STA T2; SKA =400B; TYPE MEX
       SKA =200B; TYPE MSY
       LDA T3; SKA =2B7; TYPE MSU
       LDA T2; SKA K100; TYPE MXBY
* PIM AND MEMORY STATUS
       TYPE MPIM,T2; LDA T3; SKA =4B7; TYPE MLO
       LDA T2; SKA =4B7; TYPE MFIX; TYPE MMEM
       RSH 3; ETR =7; STA T2 (FORK NO)
       LDA T3; ETR =37777B; STA T1 (PANIC TABLE ADDRESS)
       LDA T3; SKA =1B7; TYPE MFK,T2,T1
       LDA T5; LDX T6; R1
*ACTIVATION TEST ROUTINES
XCACLST 0 XCAC0; 0 XCAC1; 0 XCAC2; 0 XCAC3
       0 XCAC4; 1 XACT; 0 XCAC6; 0 XCACK
        0 XCAC2
       0 XCAC9; 0 XCAC10; 0 XCACK; 0 XCACK
       0 XCAC0; 0 XCAC0; 0 XCACK; 0 XCAC0; 0 XCAC0; 2 XCAC2
       0 XCAC0; 0 XCAC0; 0 XPEST; 0 XPEST; 0 XPEST; 0 XPEST; 0 XCACK
       0 XCAC11; 0 XCAC10; 0 XCAC1; 0 XCAC0; 0 XCAC12; 0 XPEST
XCACK   BRU UNKAC
XCAC0   SKG ZERO; BRU XPEST; BRU XACT
XCAC1   SKG ZERO; BRU XACT; BRU XPEST
XCAC2   SKG KM1; BRU XPEST; BRU XACT
XCAC3   SKA =IOBY+TBBY+CSTAY; BRU XPEST; BRU XACT
XCAC4   BRU UNKAC
XCAC12  EQU *
XCAC6   SKG T9
       BRU XACT; BRU XPEST
XCAC9   SKA =YELY; BRU XPEST; BRU XACT
XCAC10  SKG KM1; BRU XACT; BRU XPEST
XCAC11  SKA =5OY; BRU XPEST; BRU XACT

* PRINT PMT ENTRIES
*      DICTIONARY:  PMT BYTE NO. IN T1, PMT ENTRY IN T2,
*              LENGTH OF PMT IN PAGCNT, HEAD OF IND CHAIN IN T3,
*              IND. ADDR IN T4, IND. ADDR. SWITCH IN T5.

PRMTE STA T2; STA T3; CLA; STA T5 (INDIRECT SWITCH)
       JRS PRPHD
       SPB TAB3; LDA T1; SPB PONO (PRINT POSITION IN TABLE)
       LDA T2; ETR =77B5; SKE =12B5; BRU PRMTEB
PMTEX  LDA T2; ETR K3S4; STA T4; COPY AX,B; PEEK 0,2
       STA T2; ETR =77B5; SKE =12B5; BRU *+2; BRU PMTEX
       JRS PPM; SKR T5; NOP
       LDB T3; LDA =MM63; SKB =1B7; LDA =MM39; STA T7; TYPE _T7
       LDA T4; SUB XAEXSMT; SKA =4B7; BRU PMTE1
       STA T4; TYPE MM34; LDA T4; ADD K100; SPB PONO; BRU PRMTEA
PMTE1  LDA T4; SUB XADRPMT; SKA =4B7; BRU PMTE2
       JRS PIND; BRU PRMTEA
PMTE2  TYPE MM35; LDA T4; SUB XADRSMT; SPB PONO; BRU PRMTEA
PRMTEB JRS PPM
PRMTEA TCF ZERO; LDA T2; SKA =2B7; BRU PRMTE1 (EXEC BIT ON)
PRMTE2 SKA =1B7; TYPE M39 (RDO)
PMT1   SKA =4B7; TYPE M62 (WAS OR IS SHARED); R1
PRMTE1 SKN T5; TYPE M38; SKP T5; TYPE MM64 (US); BRU PRMTE2

PPM    TCF ZERO; LDA T2; ETR =77B5; RSH 15; CAX; TYPE (_STTAB,2)
       LDA T2; ETR =37B; STA T7; STA T8; LDB STTAB,2
       SKB =4B7+1B7; BRU PPM3 (PRINT USE COUNT)
       TYPE M7S (TAB 7 SPACES)
PPM1   SKB =4B6; BRU PPM4 (PRINT REAL PAGE NO)
       TYPE M3S (TAB 3 SPACES)
PPM2   SKB =2B6; BRU PPM5 (PRINT RAD ADDRESS)
       TYPE M6S (TAB 6 SPACES)
       R1
PPM3   CAX; SKB =1B7; PEEK RMC,2; STA T8; TYPE FLOC,T8; BRU PPM1
PPM4   TYPE B2S,T7; BRU PPM2
PPM5   LDA T2; ETR =77740B; STA T8; TYPE B5S,T8; R1


* PRINT PORT_PMT BYTE FOR SHARED PMT
PIND   RSH 23; DIV =35B; STB T8; CAX; PEEK TTNO+1,2
       ETR K77; STA T7; LDA =43B; ADM T8
       TYPE INDF,T7,T8; R1


* PRINT TTQ HEADING
PRQHD  TCF CRCH; SKN HDSW1; R1; MIN HDSW1
       TYPE TTQHED; R1

* PRINT BUFFERLET NO FOR "TTQ" COMMAND
       IF TTQSW
PBL    STA T3; COPY XA,XB; ADD =14; STA T2; CAX
       PEEK BLTIM,2; SUB T1; CNA; XMA T3
       TYPE PBLM,T2,T3; CBX; R1
       ENDF

       END
MONITOR ** FICHE/FRAME BREAK *****
JRSS SYMSORT

SYM.  PG.LN. IDENT.

AVG     3 18 JRSS    CLEANU  3 26 JRSS    CWIDTH  3  5 JRSS    
DIVOK   3 21 JRSS    ENTRY   2 24 JRSS    EXLOOP  2 18 JRSS    FLFT    3 13 JRSS    
GOPT    3  9 JRSS    GUN     1 12 JRSS    GUN1    1 14 JRSS    GUN11   1 15 JRSS    
GUN1A   1 20 JRSS    GUN2    1 22 JRSS    NOUNO   2 26 JRSS    NXTBLK  2 23 JRSS    
NXTENT  2 22 JRSS    OUTUN   2 33 JRSS    PBL     7 15 JRSS    PFILE   3 29 JRSS    
PIND    7  4 JRSS    PMT1    6 25 JRSS    PMTE1   6 19 JRSS    PMTE2   6 21 JRSS    
PMTEX   6 13 JRSS    PNTFD   2 12 JRSS    PNTUN   2 36 JRSS    PNTUNO  2 10 JRSS    
PPAC    4 28 JRSS    PPAC1   5  4 JRSS    PPAC2   5  9 JRSS    PPCT    3 15 JRSS    
PPFILE  3 30 JRSS    PPM     6 28 JRSS    PPM1    6 32 JRSS    PPM2    6 34 JRSS    
PPM3    6 37 JRSS    PPM4    6 38 JRSS    PPM5    6 39 JRSS    PRFHD   4 20 JRSS    
PRHD    4  9 JRSS    PRINT   2 28 JRSS    PRMTE   6  9 JRSS    PRMTE1  6 26 JRSS    
PRMTE2  6 24 JRSS    PRMTEA  6 23 JRSS    PRMTEB  6 22 JRSS    PRPHD   4 24 JRSS    
PRQHD   7 10 JRSS    PTIME   4  2 JRSS    RDEN    1 28 JRSS    RDEN1   1 30 JRSS    
RDEN2   1 31 JRSS    RDEN3   2  1 JRSS    RDEN4   1 39 JRSS    RDEN5   1 38 JRSS    
RDPAGE  2 38 JRSS    SCHLUD  2 15 JRSS    TDATE1  3 33 JRSS    TYPCHR  2  5 JRSS    
UNKAC   5  7 JRSS    XACT    5  6 JRSS    XCAC0   5 31 JRSS    XCAC1   5 32 JRSS    
XCAC10  6  1 JRSS    XCAC11  6  2 JRSS    XCAC12  5 36 JRSS    XCAC2   5 33 JRSS    
XCAC3   5 34 JRSS    XCAC4   5 35 JRSS    XCAC6   5 37 JRSS    XCAC9   5 39 JRSS    
XCACK   5 30 JRSS    XCACLS  5 23 JRSS    XPEST   5  5 JRSS    
MONITOR ** FICHE/FRAME BREAK *****
M
M      IDENT   06/06/74
       NOLIST EXT,STAT

* FOR INFORMATION ON THE DISC SEE (A4TEL)@DISC.

*      LOWER CORE MAP
* 3: MARK LOCATION IF CRASHED BY SELECTOR CHANNEL.
* 4-24: BRM MONCR
* 25: GARBAGE
* 26: DRQ
* 27: DRQU
* 30: RQ1A. HEAD OF DTC LIST.
* 31: BRM INT31
* 32: RQ1. HEAD OF DTS LIST.
* 33: BRM INT31
* 34: RQ2. CURRENT 620 JOB.
* 35: RQ3. CURRENT POST PROCESSING JOB.
* 36-77: INTERRUPT LOCATIONS OR BRM MONCR.
* 100-177: SYSPOPS.
* 200: SYSTEM NUMBER.
* 201: BRM MONCR. 
* 202: BRM MONCR. SET TO BRM MONCR+1 TO NOT SAVE CRASH.
* 203: SELECTOR CHANNEL DISC INTERRUPTS.
* 204: INTERRPUTED BY BASE ON EACH CHARACTER.
* 205: ALWAYS HIGH. ARMED FOR CLEARING A PAGE, ETC.
* 206: UNUSED INTERRPUT.
* 207: BIT 0=0=A MACHINE FOR SEL. CH.  BIT 0=1=B MACHINE FOR SEL. CH.
* 210: ALARM. BASE SOUNDS ALARM WHEN NOT EQUAL TO ZERO.
* 211: SUPAGE. SUPERVISOR PAGE 0.
* 212-213: UPFL. UP FLAG FOR BASE.
* 214: MARK LOCATION IF BASE CAUSES CRASH.
* 215: BRM MONCR
* 216: PC OF BASE IF BASE INDUCED CRASH.
* 217: ZERO UNLESS CUSTOM SYSTEM. 1=MDSI, 2=MAINTENANCE GROUP.
* 220: FIRST LOCATION OF I. SYSTEM STARTS LOADING HERE.


*      SYSTEM FLAGS, OPDS, PARAMETERS, AND MACROS

* ASSEMBLY FLAGS
BUG    EQU 1   (CHECK MEMORY TRAP BUG)
ALOG   EQU 0;* ASSEMBLE LOG ROUTINE AND CALLS.
EXEC   EQU     -1              TS BLOCK ASSEMBLY SWITCH
EXPMT  EQU  1   EXPANDED PMT'S.
PH2    EQU  1   1= PHASE 2 MUX
RE     EQU PH2
IIH    EQU PH2 INPUT OVERRUN INHIBIT (ALTMODES TOO).
FPH    EQU     -1             SIMULATE FLOATING POINT HARDWARE WITH -1
DCL    EQU  32   NUMBER OF PLATES ON A DATA PRODUCTS DISC
RP     EQU     -1              -1 = CPU, 1 = TRU
LISTAB EQU     0               ABSOLUTE LISTING PARAMETER
PTICK  EQU     0               ASSEMBLE PTCKS CODE IF TRUE
PTICKB EQU     0               PTICK BUG FLAG


*      NEXT 4 ASSEMBLY FLAGS FOR Q/A TO SELECT ****************

DISC   EQU 3   (1=DATA PRODUCTS DISC, 2=DUAL DP, 3= 2314)
SUPER1 EQU 0   (ASSEMBLE CODE FOR SUPERVISOR)
MDSI   EQU 1 (1 TO ASSEMBLE MDSI MONITOR)
LEASCO EQU 0 (1 TO ASSEMBLE LEASCO MONITOR)

TSTAT  EQU 1 (ASSEMBLE MOST STATISTICS)
TSTAT1 EQU 0 (ASSEMBLE REMAINING STATISTICS)
CEM    EQU 1 (ASSEMBLE COMMAND EDIT)
RAD1   EQU 0 (ASSEMBLE FOR 1 RAD)
TST    EQU 0 (ASSEMBLE BLOCK I/O TEST BRS'S)

SUPER  EQU 0
 IF MDSI
*ELSF DISC=1
 ELSF SUPER1
SUPER EQU 1
 ENDF

       IF MDSI
NJOB1  EQU 46
       ELSE
NJOB1  EQU 46 (46 JOBS PLUS P.U.)
       ENDF
       IF DISC=1
NJOB1  EQU 41
       ENDF
       IF SUPER1
NJOB1 EQU 43
       ENDF
       IF LEASCO=1
NFILE EQU 128
TSTAT EQU 0
       ELSE
NFILE EQU 35+5*DISC  NUMBER OF FILES THAT CAN BE OPEN AT ONCE
       ENDF

       IF LEASCO; REM ASSEMBLING MONITOR FOR LEASCO
       ELSF MDSI; REM ASSEMBLING MONITOR FOR MDSI
       ELSF 1; REM STANDARD 940 OPERATING SYSTEM; ENDF
       IF RAD1; REM ASSEMBLING FOR 1 RAD FILE; ENDF
       RPT 1; REM ASSEMBLING FOR DISC TYPE ($DISC); ENDR
       RPT 1; REM ASSEMBLING FOR ($NJOB1) USERS; ENDR
       RPT 1; REM ASSEMBLING FOR ($NFILE) FILES; ENDR
       IF SUPER
       REM SUPERVISOR SYSTEM
       ELSE
       REM NON-SUPERVISOR SYSTEM
       ENDF
       IF TSTAT1
       REM FULL STATISTICS-INHOUSE SYSTEM ONLY
       ENDF
       IF CEM
       REM COMMAND EDIT MODE
       ENDF
* OPDS
SBRS   OPD     173B5           SYSTEM MODE BRS
TSN    OPD     00222000B,1     GO FROM NORMAL TO MONITOR MODE
CKN    OPD     00220100B,1     TURN ON THE CLOCK
CKF    OPD     00220200B,1     TURN OFF THE CLOCK
LRR1   OPD     00220400B,1     LOAD RELABELLING REGISTER 1
LRR2   OPD     00221000B,1     LOAD RELABELLING REGISTER 2
LRR3   OPD     00221400B,1     LOAD RELABELLING REGISTER 3

*      MACROS
LISTM  MACRO; IF LISTAB; NOLIST ALL
       LIST    LCT,SRC,COM,EXP,EXT,CALL,DEF,SKIF,GO
       ELSE; NOLIST EXT,STAT; ENDF; ENDM
DEFL   LMACRO D;D(0) EQU LOC;LOC EQU LOC+D(1); ENDM

DIR    MACRO; BRM XDIR; ENDM   DEBUGGING AID
EIR    MACRO; BRM XEIR; ENDM   DO NOT REMOVE--NEEDED BY SYSD
SYSD   MACRO; DIR; BRM XXDIR; ENDM (PREVENT EIR IN LOW-LEVEL ROUTINES)
SYSE   MACRO; BRM XXEIR; ENDM (CANCEL SYSD AND EIR)

MLABEL MACRO; XMA RRL3; LRR3; POT RRL3; ENDM

* BREAKPOINT TEST
BPT    OPD     04020000B,1
*
* I/O DEVICE OPD'S
TTYS   MACRO; DATA 20277777B; ENDM
TTYSKS EQU     24077000B
EOD    OPD 6B5
IOSDW  EQU     214200B
IORDW  EQU     214000B
* PARAMETERS
BE     EQU     123             LAST BERKELEY BRS.
NPOP   EQU     44B             NUMBER OF SYSPOPS IN USE.
RDP    EQU     10B             REAL DISC PAGE
RWP    EQU     7B              REAL W PAGE
RMP    EQU     11B             REAL MAP PAGE
RSR    EQU     0607B           SET ROUTINE RELABELLING
RTR    EQU     12B             TYMNET BUFFERS
RSP    EQU     7               REAL STATISTICS PAGE.
* W BUFFER DEVICE PARAMETERS
NTAPE  EQU 2
NTRTRY EQU     10              NUMBER OF REREADS
NTWTRY EQU     3               NUMBER OF REWRITES
*      TYMNET SYMBOLS
*      MOST OF THE TYMNET BUFFERS ARE IN PAGE 12B
ALARM  EQU 210B                WHEN NON ZERO THE BASE SOUNDS AN ALARM
SUPAGE EQU 211B                POINTS TO SUPERVISORS PAGE 0
UPFL   EQU 212B AND 213   SEE PACGO1. TYMNET CLOBBERS UPFL PERIODICALLY.
* BASE PUTS BRM 214B TO INDUCE MONITOR CRASH.
* 216B GETS PC OF BASE UPON INDUCED CRASH.
SERIAL EQU 217B  (SERIAL NO. FOR CUSTOM MACHINES IN BITS 18-23)
TYMPAGE EQU 12B
NTBI   EQU 200B                NUMBER OF CELLS FOR TYMNET BFR INPUT
NTBO   EQU 400B
TBI    EQU 34000B              TYMNET BUFFER INPUT   (RING BUFFER)
ETBI   EQU TBI+NTBI
TBO    EQU ETBI                OUPUT RING BUFFER
ETBO   EQU TBO+NTBO
NPORT  EQU 64
TRATE  EQU ETBO
TF1    EQU TRATE+NPORT
TF3    EQU TF1+NPORT
TF4    EQU TF3+NPORT
T128   EQU TF4+NPORT
TP     EQU T128+64+1
TC     EQU TP+NPORT+2
*      PORT  FLAG DEFINITIONS    ***************************************

XX0    EQU 1;XX1 EQU 2;XX2 EQU 4;XX3 EQU 10B;XX4 EQU 20B;XX5 EQU 40B
XX6    EQU 1B2;XX7 EQU 2B2;XX10 EQU 4B2;XX11 EQU 1B3;XX12 EQU 2B3
XX13   EQU 4B3;XX14 EQU 1B4;XX15 EQU 2B4;XX16 EQU 4B4;XX17 EQU 1B5
XX20   EQU 2B5;XX21 EQU 4B5;XX22 EQU 1B6;XX23 EQU 2B6;XX24 EQU 4B6
XX25   EQU 1B7;XX26 EQU 2B7;XX27 EQU 4B7
       FRGT    XX0,XX1,XX2,XX3,XX4,XX5,XX6,XX7
       FRGT    XX10,XX11,XX12,XX13,XX14,XX15,XX16,XX17
       FRGT    XX20,XX21,XX22,XX23,XX24,XX25,XX26,XX27

FLAG   MACRO D GENERATE 2 FLAG SYMBOLS.ONE FOR MASKING,ONE FOR SHIFTING.
*    EXAMPLE   BETA IS A 6 BIT FIELD IN BITS 9-14 WHICH NEEDS TO BE
*  SHIFTED  9 PLACES TO BE NORMALIZED TO THE LOW PART OF SOME REGISTOR.
*            FLAG BETA,77,11 GENERATES (BETAZ EQU 11B) FOR SHIFTING
*                              AND (BETAY EQU 77B3) FOR MASKING
D(1).&Z EQU D(3).&B             SHIFT OPERAND
D(1).&Y EQU XX.&D(3)*D(2).&B     MASK OR BIT
       FRGT D(1).&Z,D(1).&Y
       ENDM


*      FLAGS IN TF1

       FLAG    CON,1,0         CONDEMNED CIRCUIT
       FLAG    AUX,1,1         AUXILIARY CIRCUIT
       FLAG    DI,1,2          DISMISSED ON INPUT
       FLAG    DE,1,3          DEFERRED ECHO IN EFFECT
       FLAG    GREEN,1,4       GREEN BALL TO BE RETURNED 
       FLAG    7I,1,5          CHARACTER 7 IN USERS INPUT BFR
       FLAG    IIH,1,6         INPUT INHIBITED ON AUXILIARY CIRCUIT
       FLAG    135,1,7         135 SWITCH COCKED TO OUTPUT BLANKS
       FLAG    152,1,11        OUTPUT 212,215,377 FOR TCO =152 AND
*                              OUTPUT 215,212 FOR TCO =155
       FLAG    102,1,12        OUTPUT 212 OR 342 FOR TCO =102 AND
*                              OUTPUT 214 OR 345 FOR TCO =105
       FLAG    GOB,1,13        CHR GOBBLER RECEIVED
       FLAG    MAR,1,14        AT LEFT MARGIN
       FLAG    MARS,1,15       SUPRESS LEFT MARGIN FLAG
       FLAG    XOFF,1,16       TERMINAL NOT INPUTTING IF XOFFY=1
       FLAG    LCO,1,17        LOWER CASE OUTPUT
       FLAG    LG,1,20         LOGIN.  DO NOT BACKPRESSURE.
       FLAG    DEF,1,22        PERMANENT DEFERRED ECHO
       FLAG    8O,1,23         8 LEVEL OUTPUT
       FLAG    RI,1,24   REFLECT YELLOW AND GREEN BALLS IMMEDIATELY
       FLAG    LCI,1,25        MAKE LOWER CASE INTO UPPER CASE
       FLAG    X,1,26          TERMINAL CAN UNDERSTAND X-ON, X-OFF CHRS
       FLAG    8I,1,27         8 LEVEL INPUT


*      FLAGS IN TF2
       FLAG    JB,77,0         JOB
       FLAG    RC,3,6          RATE CONTROLLER BITS.00 NO ACTIVATION 
*                      DELAY.01 NO DELAY.10 DELAY 2 SEC.11 DELAY 3 SEC.
       FLAG    BRK,7,11        3 BIT FIELD. ONE BIT ON FOR BREAK TABLE.
       FLAG    B113,1,14       IGNORE SOFT AND HARD ESCAPES, BRS 113,114.
       FLAG    SOFT,1,15       SOFT ESCAPE ON PHANTOM USER
       FLAG    HARD,1,16       HARD ESCAPE ON PU
       FLAG    B161,1,17       BRS 161 HAS DISARMED HARD + SOFT ESCAPES
       FLAG    B168,1,20       BRS 168 HAS DISARMED HARD ESCAPES
       FLAG    PUD,1,21        PREVENTS PU PROCESSING BEFORE JOB HAS RUN.
       FLAG    CED,1,22        COMMAND EDIT.
       FLAG    YEL,1,24        SEND OUT A YELLOW BALL AT DISMISS TIME IF SET.
       FLAG    5O,1,25         TYPE 5 OUT. TY5 CODE ACTIVATED BY CAC7.
       FLAG    ORA,1,26        WAITING FOR ORANGE BALL. SEE CAC9.
       FLAG    OIH,1,27        OUTPUT INHIBITED. USED BY SCHEDULAR.


*      FLAGS IN TF3

*       TF3 DESCRIBES THE BITS THAT DESCRIBE THE TERMINAL 
* CHARACTERISTICS. THEY ARE PASSED FROM THE 940 TO THE REMOTE AS
* CHARACTER PAIRS. THE FIRST CHARACTER OF EACH PAIR IS A 1. THE
* SECOND CHARACTER IS A CHARACTER WITH TWO 4 BIT FIELDS. THE
* FIRST FIELD IS A TYPE FIELD AND THE SECOND FIELD IS DATA BITS.
* BITS ARE NUMBERED FROM LEFT TO RIGHT.
* IF THE DATA BIT IS ON, THE CONDITION IT DESCRIBES IS ACTIVE.
* TYPE 0: 0 ECHO ON,1 ECHO CONTROL I,2 ECHO CR,RB TO LINE FEED,
*  3 ECHO LF TO CARRIAGE RETURN.
* TYPE 1: 0 CR DELAY,1-3 INPUT BAUD RATE
* TYPE 2: 0-2 OUTPUT BAUD RATE,3 REQUIRES PARITY.
* TYPE 3: 0-2 PARAMETER A,3 HALF DUX
* TYPE 4: 0-2 PARAMETER B
* TYPE 5: 0-3 PARAMETER C
*    PARAMETERS A, B, AND C ARE USED TO COMPUTE CARRIAGE RETURNS
* AS FOLLOWS: F(N)=MIN[N/(2^A)+B,C]
*    PARAMETERS A, B, AND C ARE USED TO COMPUTE LINE FEED DELAYS
* AS FOLLOWS: IF N=1,F(N)=A
* OTHERWISE, IF C>N, F(N)=C-N+B.  OTHERWISE F(N)=B

       FLAG    ECHO,1,27       PORT CAN ECHO
       FLAG    TAB,1,26        ECHO CONTROL I
       FLAG    ELF,1,25        ECHO LF AS CR,RB
       FLAG    ECR,1,24        ECHO CR AS LF
       FLAG    CRD,1,23        DELAY CR IF ON, LF IF OFF
       FLAG    IBR,7,20        INPUT BAUD RATE
       FLAG    OBR,7,15        OUTPUT BAUD RATE
       FLAG    PAR,1,14        TERMINAL REQUIRES PARITY
       FLAG    PARA,7,11       PARAMETER 'A'
       FLAG    HDUX,1,10       ON IF TERMINAL IS HALF DUPLEX
       FLAG    PARB,7,5        PARAMETER 'B'
       FLAG    PARX,1,4        SPARE
       FLAG    PARC,17,0       PARAMETER 'C'


*      FLAGS IN TF4

       FLAG    TERMC,777,0     8 LEVEL INPUT TERMINATING CHR
       FLAG    MOD,7,11        BLOCK INPUT MODES
       FLAG    5A,7,15         A REGISTOR FOR USER FROM INPUT TYPE 5
       FLAG    135C,377,20     135 BLANK COUNTER

*      FLAGS IN TF5 FOR BLOCK I/O

       FLAG    CHC,777,0       CHARACTER COUNT
       FLAG    CHBN,17,11      BUFFER NO.
       FLAG    CSTA,7,15       COMMAND STATE
       FLAG    CSPA,1,20       SPARE
       FLAG    CABO,1,21       USER ABORT
       FLAG    CTER,1,22       TERMINATE MSG RECEIVED FROM BASE
       FLAG    CTIM,1,23       TIMEOUT MSG
       FLAG    CEOT,1,24       EOT MSG (YELLOW BALL)
       FLAG    CZ,1,25         CIRCUIT ZAPPER
       FLAG    TBB,1,26        TERMINATE BUSY BIT
       FLAG    IOB,1,27        I/O BUSY BIT

*      FLAGS IN TF6 FOR BLOCK I/O

       FLAG    CNXT,177,0      NEXT PORT IN CHAIN
       FLAG    CADR,3777,7     COMMAND LIST HEAD ADDRESS
       FLAG    CPG,37,22       COMMAND LIST HEAD PAGE NO.
       FLAG    CHO,1,27        1=OUTPUT COMMAND, 0=INPUT
*                              THIS BIT IS COMPLEMENTED IN USER COMMAND


SET    MACRO D   SET ONE OF THE PORT FLAGS
       LDA D(1); SKA D(2),2; BRU *+2; ADM D(2),2; ENDM

RST    MACRO D   RESET ONE OF THE PORT FLAGS
       LDA D(1); COPY AB,N; SKB D(2),2; ADM D(2),2; ENDM

*      END OF PORT FLAG DEFINITIONS ************************************

ETBUF  EQU 37776B

* PAC TABLE PARAMETERS
NSQU   EQU 4   NUMBER OF CLOCK CYCLES IN SHORT QUANTUM.
NLQU   EQU 125  FULL QUANTUM SIZE.  2 SEC.
SVLQ   EQU    125   SUPERVISOR QUANTUM. MUST CHANGE BASE TO GO OVER 2 SEC.
* JOB AND MEMORY PARAMETERS
NJOB   EQU     NJOB1+1         NUMBER OF JOBS
NPAC   EQU     NJOB*2+NJOB/2+1 NUMBER OF PACT SLOTS
NPPAR  EQU 8   LENGTH OF PACT ENTRY
UMSZ   EQU     15              INITIAL MACHINE SIZE
NMEM   EQU 32  NUMBER OF PAGES
NSMEM  EQU 7   NUMBER OF PAGES USED BY SYSTEM
NSSMT  EQU     23B             NO. OF SYSTEM PAGES IN SMT
NUSMT  EQU 7   NUMBER OF NONPROPRIETARY SMT PAGES+1.
       IF EXPMT
NCMEM  EQU 43B    COMMON PART OF USER MACHINE.
NSMT   EQU 43B    SIZE OF SMT.
NXSMT  EQU 116B   NO. EXPANDED SMT'S.
FESMT  EQU 100B   FIRST EXPANDED SMT NUMBER.
LESMT  EQU NXSMT+FESMT-1   LAST EXPANDED SMT NUMBER.
       ELSE
NCMEM  EQU     60B             COMMON PART OF USER MACHINE
NSMT   EQU     60B             SIZE OF SMT
       ENDF
NUMEM  EQU 100B-NCMEM          NUMBER OF PRIVATE USER PAGES
NPUQ   EQU 16  NO. OF PUCT ENTRIES
* DISC PARAMETERS
NFDCB EQU 35+5*DISC (MAXIMUM NO. OF FILE DIR CONTROL BLOCKS)
NBUF   EQU 4   NUMBER OF FILES THAT A USER CAN HAVE OPENED AT ONCE.
MBUFX  EQU 0   MBUFX DEFINES THE FILE IN USE BIT MAP. SEE TSONI..1I
       RPT NBUF
MBUFX  EQU MBUFX/2+2B7; ENDR
NDRQ   EQU     70              NO. OF JOBS IN DISC QUEUE.
       IF DISC=1
*      20000B SECTORS PER DISC=400B DATA BLOCKS. 3600B ARE MAPPED.
*      8 DISCS ARE MAPPED. 3600B*8 BLOCKS ARE MAPPED.3600B*8=36000B
TABLEC EQU     36000B          NUMBER OF BITS IN BIT MAP.
       ELSE
TABLEC EQU 8*20*200  8 RECORDS,20 HEADS,200 CYLINDERS TO MAP A 2314 PACK
       ENDF
TABLEN EQU TABLEC+23;TABLEN EQU TABLEN/24   BIT MAP IN WORDS

DHT    EQU 34000B              BEGINNING OF DISC HOLE TABLE
DHTE   EQU 35000B              END OF DISC HOLE TABLE
DHC    EQU DHT+[DHTE-DHT]/2        CRITICAL POINT WHERE PROGRAM IS STARTED
BITMP  EQU 35300B              BEGINNING OF DISC BIT MAP
EBITMP EQU BITMP+TABLEN        END OF DISC BIT MAP

MAXFIL EQU 3B7 MAXIMUM FILE SIZE IN CHARACTERS
NLVL   EQU     5
MLVL   EQU     NLVL-1

* BUFFER MAP
CBF0   EQU     0
CBF1   EQU     1               20 POINTERS AND FILE PARAMETERS.
CBF2   EQU     41B             40 POINTERS.
CBF3   EQU     101B            40 POINTERS.
CBF4   EQU     141B            DATA AREA.

CSIZE  EQU     CBF1+37B        NO. OF 256 WORD BLOCKS. CHARGE SIZE.
CEOF   EQU     CSIZE-1         END OF FILE.
CBOF   EQU     CEOF-1          BEGINNING OF FILE.
CPTOP  EQU     CBOF-1          HIGHEST LOC. EVER WRITTEN. FOR INPUT.
CQ     EQU     CPTOP-1         PHYSICAL FILE SIZE QUANTUM
CCKWRD EQU CQ-1       CHECKWORD PUT INTO HIGHEST XBLOCK TO REDUCE ERRORS

CP     EQU     CBF4+400B       CURSOR POSITION.
*      BIT 22,23 OF CP TELL THE CHAR. POSITION IN A BUFFER WORD.
*      BITS 14-23   CHAR. POSITION FOR DATA BLOCK (BUFFER LEVEL=MLVL).
*      BITS  9-13   POINTS TO 1 OF 40B DISC ADDRESSES IN BFR MLVL-1
*      BITS  4-8    POINTS TO 1 OF 40B DISC ADDRESSES IN BFR MLVL-2
*      BITS  0-3    POINTS TO 1 OF 20B DISC ADDRESSES IN BFR MLVL-3
*      BIT 0   ALWAYS ZERO

CFLG   EQU     CP+1            POINTER TO GFLG.
CSW    EQU     CFLG+1          -1 FOR OUTPUT. 0 FOR INPUT.
CSW1   EQU     CSW+1           -1 NORMALLY,0 FOR BRS 128, -1 FOR BRS 66
CEOF1  EQU     CSW1+1           LOCAL EOF FOR WIO AND CIO. 0=EMPTY FILE.
CC     EQU     CEOF1+1         CURSOR CHANGED. 1 WORD PER BUFFER.
COV    EQU     CC+NLVL      COUNTER FOR TOO MANY WIO'S, ETC.
CBASE  EQU     COV+1           FDCBLE INDEX.
* END OF BUFFER MAP
*
NDBW   EQU     CBASE+1;NDBW EQU NDBW-CBF0     NDBW=BUFFER SIZE.
NDBS   EQU     NDBW*NBUF
* TS BLOCK MAP
TSMAPS EQU     65
LOC    EQU 37777B-NDBS-TSMAPS;* START ASSIGNMENT
DBTOP  DEFL 0  1ST WORD AFTER PRSYMS
FBADR  DEFL NDBS      FIRST BUFFER ADDRESS
FBWRD  DEFL 1     BUFFER AVAILABILTY BIT WORD
FILE   DEFL 1
GFILE  DEFL 1    GLOBAL FILE NO.
BUFF   DEFL 1        BUFFER ADDRESS.
LVL    DEFL 1   LVL TELLS WHICH TS BFR IN A FILE IS PERTINENT
CBIP   DEFL 1          POINTS TO DISC ADRS. SEE :SETBIP:
CP1    DEFL 1         WORKING STORAGE.
CP2    DEFL 1          WORKING STORAGE.
CRET0  DEFL 1  START UP LOCATION (LOC. 0) FOR DISMISSED FORK.
CRET1  DEFL 1        REENTRANT MARK LOCATION FOR :CDMS:
CRET2  DEFL 1
CRET3  DEFL 1
CRET4  DEFL 1
CT1    DEFL 1         REENTRANT TEMPORARY STORAGE
CT2    DEFL 1
CT3    DEFL 1
CDSA   DEFL 1       A REGISTOR WHEN :CDMS: WAS CALLED
CDSB   DEFL 1
CDSX   DEFL 1
FSIZE  DEFL 1       DEFAULT FILE SIZE QUANTUM. SEE TSONI, BRS92.
LQ     DEFL 1       LONG QUANTUM
PA     DEFL 8
PB     DEFL 8
PX     DEFL 8
FAC1   DEFL 1
FAC2   DEFL 1
PPB    DEFL 1    POINTER TO PB CHAIN
NFORK  DEFL 1          NUMBER OF FORKS COUNTER
DSKMET DEFL 1           DISK METER.
UFLAG  DEFL 1                  WORD READ AND WRITTEN BY USER WITH BRS 7.
P172   DEFL 1                  PORT NO. SAVED BY BRS 172
       IF TSTAT1
XBRS   DEFL 1
XREAL  DEFL 1
       ENDF
       IF LOC>40000B; DISASTER, TS PAGE FULL; ENDF
*      CHANGE :TSMAPS: AND THIS COMMENT IF MORE THAN 100 LOCATIONS ARE
*      ALLOCATED BETWEEN :TSMAPS: AND HERE
*
* SEE LINE 1 IN TS FOR COMPLETE MAP OF TS PAGE.
*
 FRGT TSMAPS
*      TTY BUFFERS OCCUPY REAL PAGE 12B AND 13B

* MACROS
DEFINE MACRO D  (DEFINE CAUSES MDBG SYMBOLS TO BE PUT INTO BINARY FILE)
D1     NARG D;D2 EQU 0
       RPT D1;D2 EQU D2+1;D(D2) EQU D(D2); ENDR; FRGT D1,D2; ENDM

TRAP   MACRO D; BRM TRAP; ENDM
LOGG   MACRO D; BRM LOG; D(1) D(2); ENDM
DTI    MACRO; ARMI DTIWD; ENDM
ATI    MACRO; ARMI AIRWD; ENDM
ARMI   MACRO D; AIR; POT D(1); ENDM
ENTRY  MACRO L;ENTCNT NARG; RPT ENTCNT;L(ENTCNT) EXT
ENTCNT EQU ENTCNT-1; ENDR; ENDM
SETINT MACRO A; LDA =A(1); STA BLK31; ENDM
TDT    MACRO L;$L(1).&W EQU *; RPT NTAPE; L(2) L(3).&B+*-L(1).&W; ENDR; ENDM
RMFF   MACRO; ENDM
SMFF   MACRO; ENDM
TLABEL MACRO   D               GEN. ROUTINE TO LABEL IN TTY BUFFERS
D(1).&L1 ZRO
D(1).&L ZRO; XMA RRL3; LRR3; POT RRL3; STA D(1).&L1; BRR D(1).&L; ENDM
TRP    MACRO L;ENTCNT NARG; RPT ENTCNT;L(ENTCNT) EQU TRAP
 FRGT L(ENTCNT);ENTCNT EQU ENTCNT-1; ENDR; ENDM
LBL    MACRO D;1LBL EQU D(2); RPT D(2); LDA D(1)+1LBL-1; LRSH 6
1LBL   EQU 1LBL-1; ENDR; ENDM
*
       IF      FPH
*
*      FLOATING POINT HARDWARE MACROS
*
*      INITIATE OUTPUT OF MOST SIGNIFICANT HALF
IMSHO  MACRO   D
       EOM*    30721B,2
N:     NARG
       IF      N:=1
       POT     D(1)
       ELSE
       POT     D(1),D(2)
       ENDF
       ENDM
*
*      INITIATE INPUT OF MOST SIGNIFICANT HALF
IMSHI  MACRO   D
       EOM*    30731B,2
N:     NARG
       IF      N:=1
       PIN     D(1)
       ELSE
       PIN     D(1),D(2)
       ENDF
       ENDM
*
*      INITIATE FLOATING LOAD
IFLD   MACRO   D
       EOM*    30720B,2
N:     NARG
       IF      N:=1
       POT     D(1)
       ELSE
       POT     D(1),D(2)
       ENDF
       ENDM
*
*      INITIATE FLOATING ADD
IFAD   MACRO   D
       EOM*    30722B,2
N:     NARG
       IF      N:=1
       POT     D(1)
       ELSE
       POT     D(1),D(2)
       ENDF
       ENDM
*
*      INITIATE FLOATING SUBTRACT
IFSB   MACRO   D
       EOM*    30723B,2
N:     NARG
       IF      N:=1
       POT     D(1)
       ELSE
       POT     D(1),D(2)
       ENDF
       ENDM
*
*      INTIATE FLOATING INVERSE SUBTRACT
IFSBI  MACRO   D
       EOM*    30724B,2
N:     NARG
       IF      N:=1
       POT     D(1)
       ELSE
       POT     D(1),D(2)
       ENDF
       ENDM
*
*      INITIATE FLOATING MULTIPLY
IFMP   MACRO   D
       EOM*    30725B,2
N:     NARG
       IF      N:=1
       POT     D(1)
       ELSE
       POT     D(1),D(2)
       ENDF
       ENDM
*
*      INITIATE FLOATING DIVIDE
IFDV   MACRO   D
       EOM*    30726B,2
N:     NARG
       IF      N:=1
       POT     D(1)
       ELSE
       POT     D(1),D(2)
       ENDF
       ENDM
*
*      INITIATE FLOATING INVERSE DIVIDE
IFDVI  MACRO   D
       EOM*    30727B,2
N:     NARG
       IF      N:=1
       POT     D(1)
       ELSE
       POT     D(1),D(2)
       ENDF
       ENDM
*
*      INITIATE FLOATING STORE
IFST   MACRO   D
       EOM*    30730B,2
N:     NARG
       IF      N:=1
       PIN     D(1)
       ELSE
       PIN     D(1),D(2)
       ENDF
       ENDM
*
*      RESET FLOATING OVERFLOW
RFPOV  MACRO   D
       SKS*    30720B,2
       BRU     *+1
       ENDM
*
*      SKIP IF FLOATING AC NEGATIVE
SHFAN  MACRO   D
       IFST    T
       SKS*    30721B,2
       ENDM
*      FLOATING POINT MACROS
*
*      LOAD FLOATING ACCUMULATOR
HFLD   MACRO   D
       IFLD    D(2)
       IMSHO   D(1)
       ENDM
*
*      STORE FLOATING ACCUMULATOR
HFST   MACRO   D
       IFST    D(2)
       IMSHI   D(1)
       ENDM
*
*      FLOATING ADD
HFAD   MACRO   D
       IFAD    D(2)
       IMSHO   D(1)
       ENDM
*
*      FLOATING SUBTRACT
HFSB   MACRO   D
       IFSB    D(2)
       IMSHO   D(1)
       ENDM
*
*      FLOATING SUBTRACT INVERSE
HFSBI  MACRO   D
       IFSBI   D(2)
       IMSHO   D(1)
       ENDM
*
*      FLOATING MULTIPLY
HFMP   MACRO   D
       IFMP    D(2)
       IMSHO   D(1)
       ENDM
*
*      FLOATING DIVIDE
HFDV   MACRO   D
       IFDV    D(2)
       IMSHO   D(1)
       ENDM
*
*      FLOATING DIVIDE INVERSE
HFDVI  MACRO   D
       IFDVI   D(2)
       IMSHO   D(1)
       ENDM
       ENDF
*
*
*
*
* EXEC ENTRY POINTS

EXECI  EQU     10000B
EXECP  EQU     10001B
OFFINT EQU     10002B
CKCPU  EQU     10003B   CPU TIME OVERRUN.
CKCPU1 EQU     10004B   CPU TIME OVERRUN IF IN EXEC.
*
*
*



FORGET MACRO
       ENDM
       FREEZE
       END
MONITOR ** FICHE/FRAME BREAK *****
M SYMSORT

SYM.  PG.LN. IDENT.

1LBL   13 11 M       ALARM   5  2 M       ALOG    2  3 M       
ARMI   12 37 M       ATI    12 36 M       BE      4 27 M       BITMP  10 17 M       
BPT     4 18 M       BUFF   11 26 M       BUG     2  2 M       CBASE  11 13 M       
CBF0   10 25 M       CBF1   10 26 M       CBF2   10 27 M       CBF3   10 28 M       
CBF4   10 29 M       CBIP   11 28 M       CBOF   10 33 M       CC     11 11 M       
CCKWRD 10 36 M       CDSA   11 39 M       CDSB   12  1 M       CDSX   12  2 M       
CEM     2 26 M       CEOF   10 32 M       CEOF1  11 10 M       CFLG   11  7 M       
CKCPU  18  2 M       CKCPU1 18  3 M       CKF     3 38 M       CKN     3 37 M       
COV    11 12 M       CP     10 38 M       CP1    11 29 M       CP2    11 30 M       
CPTOP  10 34 M       CQ     10 35 M       CRET0  11 31 M       CRET1  11 32 M       
CRET2  11 33 M       CRET3  11 34 M       CRET4  11 35 M       CSIZE  10 31 M       
CSW    11  8 M       CSW1   11  9 M       CT1    11 36 M       CT2    11 37 M       
CT3    11 38 M       D(1).& 13  7 M       D(1).& 13  6 M       D(1).&  6  1 M       
D(1).&  5 39 M       D1     12 30 M       DBTOP  11 21 M       DCL     2 10 M       
DEFINE 12 29 M       DEFL    4  8 M       DHC    10 16 M       DHT    10 14 M       
DHTE   10 15 M       DIR     4 10 M       DISC    2 19 M       DSKMET 12 12 M       
DTI    12 35 M       EBITMP 10 18 M       EIR     4 11 M       ENTCNT 12 39 M       
ENTRY  12 38 M       EOD     4 23 M       ETBI    5 12 M       ETBO    5 14 M       
ETBUF   9 10 M       EXEC    2  4 M       EXECI  17 38 M       EXECP  17 39 M       
EXPMT   2  5 M       FAC1   12  8 M       FAC2   12  9 M       FBADR  11 22 M       
FBWRD  11 23 M       FESMT   9 29 M       FILE   11 24 M       FLAG    5 34 M       
FORGET 18 10 M       FPH     2  9 M       FSIZE  12  3 M       GFILE  11 25 M       
HFAD   16 36 M       HFDV   17 21 M       HFDVI  17 27 M       HFLD   16 24 M       
HFMP   17 15 M       HFSB   17  3 M       HFSBI  17  9 M       HFST   16 30 M       
IFAD   14 12 M       IFDV   15 17 M       IFDVI  15 28 M       IFLD   14  1 M       
IFMP   15  6 M       IFSB   14 23 M       IFSBI  14 34 M       IFST   15 39 M       
IIH     2  8 M       IMSHI  13 29 M       IMSHO  13 18 M       IORDW   4 25 M       
IOSDW   4 24 M       LBL    13 10 M       LEASCO  2 22 M       LESMT   9 30 M       
LISTAB  2 12 M       LISTM   4  5 M       LOC    11 20 M       LOGG   12 34 M       
LQ     12  4 M       LRR1    3 39 M       LRR2    4  1 M       LRR3    4  2 M       
LVL    11 27 M       MAXFIL 10 20 M       MBUFX  10  3 M       MBUFX  10  1 M       
MDSI    2 21 M       MLABEL  4 15 M       MLVL   10 22 M       N:     16  2 M       
N:     15 30 M       N:     15 19 M       N:     15  8 M       N:     14 36 M       
N:     14 25 M       N:     14 14 M       N:     14  3 M       N:     13 31 M       
N:     13 20 M       NBUF    9 39 M       NCMEM   9 32 M       NCMEM   9 26 M       
NDBS   11 17 M       NDBW   11 16 M       NDRQ   10  4 M       NFDCB   9 38 M       
NFILE   3 13 M       NFILE   3 10 M       NFORK  12 11 M       NJOB    9 17 M       
NJOB1   3  7 M       NJOB1   3  4 M       NJOB1   3  1 M       NJOB1   2 38 M       
NLQU    9 14 M       NLVL   10 21 M       NMEM    9 21 M       NPAC    9 18 M       
NPOP    4 28 M       NPORT   5 15 M       NPPAR   9 19 M       NPUQ    9 36 M       
NSMEM   9 22 M       NSMT    9 33 M       NSMT    9 27 M       NSQU    9 13 M       
NSSMT   9 23 M       NTAPE   4 36 M       NTBI    5  9 M       NTBO    5 10 M       
NTRTRY  4 37 M       NTWTRY  4 38 M       NUMEM   9 35 M       NUSMT   9 24 M       
NXSMT   9 28 M       OFFINT 18  1 M       P172   12 14 M       PA     12  5 M       
PB     12  6 M       PH2     2  6 M       PPB    12 10 M       PTICK   2 13 M       
PTICKB  2 14 M       PX     12  7 M       RAD1    2 27 M       RDP     4 29 M       
RE      2  7 M       RFPOV  16 11 M       RMFF   13  3 M       RMP     4 31 M       
RP      2 11 M       RSP     4 34 M       RSR     4 32 M       RST     9  5 M       
RTR     4 33 M       RWP     4 30 M       SBRS    3 35 M       SERIAL  5  7 M       
SET     9  2 M       SETINT 13  1 M       SHFAN  16 17 M       SMFF   13  4 M       
SUPAGE  5  3 M       SUPER   2 34 M       SUPER   2 30 M       SUPER1  2 20 M       
SVLQ    9 15 M       SYSD    4 12 M       SYSE    4 13 M       T128    5 20 M       
TABLEC 10 10 M       TABLEC 10  8 M       TABLEN 10 12 M       TBI     5 11 M       
TBO     5 13 M       TC      5 22 M       TDT    13  2 M       TF1     5 17 M       
TF3     5 18 M       TF4     5 19 M       TLABEL 13  5 M       TP      5 21 M       
TRAP   12 33 M       TRATE   5 16 M       TRP    13  8 M       TSMAPS 11 19 M       
TSN     3 36 M       TST     2 28 M       TSTAT   3 11 M       TSTAT   2 24 M       
TSTAT1  2 25 M       TTYS    4 21 M       TTYSKS  4 22 M       TYMPAG  5  8 M       
UFLAG  12 13 M       UMSZ    9 20 M       UPFL    5  4 M       XBRS   12 16 M       
XREAL  12 17 M       XX0     5 25 M       XX13    5 27 M       XX20    5 28 M       
XX25    5 29 M       XX6     5 26 M       
MONITOR ** FICHE/FRAME BREAK *****
MAP
MAP    IDENT 01/16/76

       LISTM
* THIS PACKAGE LOADS AT 34000B AND REPRESENTS THE LAYOUT
* OF THE FIRST 1300B LOCATIONS OF THE MAP PAGE.
* ON SYSTEM STARTUP THIS CODE IS COPIED FROM PAGE 7 (SET) INTO 13
* (BLET) AND FROM THENCE INTO PAGE 11. (MAP)
       BSS DHTE-DHT (DISC HOLE TABLE)
       BSS NFDCB
$BASE EQU *
       BSS NFDCB
$MAX EQU *

       IF DISC=1
$GB5   LDA GFILE; ADD GBRAN; MUL =3*GW/24; DIV =TABLEN
GB1    LDA K4B4; COPY AX,BX,A,B
GB3    SKE BITMP,2; BRU *+2; BRX GB3
       CXA; ETR ADMSK; SKG =TABLEN-1; BRU GB2
       BRU GB1   WRAP AROUND BIT MAP
GB2    EQU *   BIT FOUND.CONVERT WORD POSITION INTO BIT POSITION.
       MUL K14; STB GB9
       LDA BITMP,2; LRSH 1; STX GB8; CLX; NOD 23; CXA; CNA; ADM GB9; CAX
       LDA X4; RSH 0,2; LDX GB8; ADM BITMP,2; ADM BITSUM; LDA GB9
*      CONVERT BIT POSITION INTO BLOCK ADDRESS
       RSH 23; DIV =GW;* DISC IN A. SECTOR DISPLACEMENT IN B.
       STB GB8; MUL K4000; LSH 23; ADD* GAP; ADD ONE  BEGINNING OF DISC
       ADM GB8     (SAVE DISC ADDRESS)
       SKR DBITS; NOP
       ELSE
$GB5   LDB GBRAN (FIND GOOD PLACE TO START LOOKING FOR A FREE BIT)
GB1    LDA K4B4; COPY AX,BX,A,B
GB2    SKE BITMP,2; BRU *+2; BRX GB2
       CXA; ETR ADMSK; SKG =TABLEN-1; BRU GB3
       BRU GB1 (WRAPAROUND)
GB3    MUL K14; STB GB9
       LDA BITMP,2; LRSH 1; STX GB8; CLX; NOD 23; CXA; CNA; ADM GB9
       CAX; LDA X4; RSH 0,2; LDX GB8; ADM BITMP,2; ADM BITSUM
       LDA MAPNUM; MUL =8*20*200/2; BAC; ADM GB9
       SKR DBITS; NOP
       ENDF
       LDX CBASEP; MIN BASE,2; LDA BASE,2; SKG MAX,2; BRU *+2; STA MAX,2
       BRU GB5A

*      (PUT RETURNED DISC BLOCK INTO HOLE TABLE (DHT)

DHCPTR DATA DHC (POINTER TO CRITICAL POINT IN DHT)
DHTEND DATA DHTE (POINTER TO END OF TABLE)
DHTPTR DATA DHT (POINTER TO DHT)
$DHPUT EQU *
       MIN DHTTC             (INCREMENT NUMBER OF TOTAL RECEIVED BLOCKS)
       LDA LB9                 (PICK UP DISC ADDRESS)
       IF DISC=1
       MRG K2B7                (IF DP SINGLE DISC, SET BIT 1)
       ENDF
       CAB 0                   (PUT IN B-REG)
       LDA DHTEND; SKG DHTPTR; BRU DHFULL  (CHECK IF DHT FULL)
       STB* DHTPTR    (STORE BLOCK IN HOLE TABLE)
       MIN DHTPTR              (INCREMENT DHT POINTER)
       MIN DHTCC               (INCREMENT NUMBER OF CURRENT ENTRIES)
       LDA DHTPTR; SKE DHCPTR   (CHECK IF AT CRITICAL POINT IN DHT)
       BRU CDEL3C; STA DHTPAC  (YES, DHTPAC IS SCHED. ACTIVATION COND.)
       MIN PCALLS              (INCREMENT NUMBER OF PROGRAM CALLS)
       LDA REAL; STA PRTIME    (STORE TIME SINCE STARTUP)
       BRU CDEL3C
DHFULL MIN DHTFUL (INCREMENT NUMBER OF TIMES DHT FULL AND RETURN)
$CDEL3C EQU * DECREASE BASE
       LDX CBASEP; SKR BASE,2; BRU CDEL3E; MIN BASE,2; BRU CDEL3E

* BRS 128 CALL ARG 5 USED BY MAP PROGRAM.
$SDBME1 LDX =DHT-DHTE; CLA; XMA DHTE,2; STA* SS01
       MIN SS01; BRX *-4; LDA KM1; STA DHTPAC; LDA =DHT
       STA DHTPTR; CLA; STA DHTCC; BRM NPOPX
       END
MONITOR ** FICHE/FRAME BREAK *****
MAP SYMSORT

SYM.  PG.LN. IDENT.

BASE    1 10 MAP     CDEL3C  2 27 MAP     DHCPTR  2  7 MAP     
DHFULL  2 26 MAP     DHPUT   2 10 MAP     DHTEND  2  8 MAP     DHTPTR  2  9 MAP     
GB1     1 31 MAP     GB1     1 16 MAP     GB2     1 32 MAP     GB2     1 20 MAP     
GB3     1 35 MAP     GB3     1 17 MAP     GB5     1 30 MAP     GB5     1 15 MAP     
MAX     1 12 MAP     SDBME1  2 31 MAP     
MONITOR ** FICHE/FRAME BREAK *****
NET
NET IDENT 04/13/76

       LISTM


TLOG   EQU -1   LOG WORDS SENT TO TBO AND WORDS RECEIVED FROM TBI 

*      ROUTINES USED TO SEND BLOCK I/O MESSAGES TO BASE

* INPUT STATE 2 MODE CHECKER
* LEAST SIG BIT OF MODE SPECIFIES IMAGE MODE (AUTOTERMINATE)
* NEXT BIT SPECIFIES IMAGE BINARY (NO TERMINATE FOR TIMEOUT)
$MODCK LDA TF4,2; LDB TF5,2
       EOR =MODY/7; XAB; SKB =MODY/7*2; ETR =-1-CTIMY
       SKA =CTIMY+CEOTY; SKB =MODY/7; BRU BIOSWP
       SKN TROSW; BRU BIONXP   (POSSIBLE 2 SEC WAIT ON THIS)
*                              (PORT IF THERE IS NOTHING ELSE)
*                              (TO DO AND ACTR GETS RESET)
       LDB =TBBY+CSTAY/7; BRM SIO; BRU BIOSWP; BRU BIONXP


* WRITE A MESSAGE INTO THE OUTPUT RING.  MESSAGE TYPES ARE AUTOMATICALLY
*      DETERMINED FROM CHO BIT IN TF6 AND BUSY BIT SPECIFIED IN 'B'.
*      'B'= MASK OF BITS TO BE ADDED INTO TF5, E.G. IOBY+CSTAY/7
*      TO TURN ON THE BUSY BIT AND INCREMENT THE STATE.  THIS ROUTINE
*      NONSKIPS WITHOUT WRITING TO THE RING IF THE BUSY BIT OR CZ OR CABO
*      ARE ALREADY ON.

$SIO ZRO
       CBA; ETR =IOBY+TBBY; MRG =CZY+CABOY; XAB
       DIR; SKB TF5,2; BRU SIO1 (ABORTED); MIN SIO
       ADM TF5,2; SKA =IOBY; BRU SIO2 (NEEDS TROPAIR)
       COPY XA,B; LCY 8; MRG =15B*2B5
       IF TST; BRM TTRO; ELSE; BRM TRO; ENDF
       LDA =-1-IIHY; ETR TF1,2; STA TF1,2
SIO1   EIR; BRR SIO
SIO2   LDA TF5,2; RCY 8; CXA; MRG BFLN
       LCY 8; MRG K4B7; STA TPAIR2
       LDA CMAP; ETR K37
       LDB TF5,2; SKB K400; MRG K40 (HI ORDER COUNT)
       RCY 8; CXA; LCY 8; SKN TF6,2; BRU *+3; MRG =3*2B5; BRU *+2; MRG K1B6
       IF TST; BRM TTROPAIR; ELSE; BRM TROPAIR; ENDF; BRU SIO1

*      END OF BLOCK I/O ROUTINES

$TF3XMA 0;*     SET NEW TERMINAL CHARACTERISTICS IN TF3 OR DISMISS
       SKN TF2,2; SKN TROSW; BRU TVDMS
       STA T     NEW VALUE FOR TF3
       LDB FIVE; STB T2   COUNTER FOR TERM. CHR. FIELDS  (0-5)
       XMA TF3,2
       EOR T    USE EOR TO NOTICE CHANGED FIELDS
       STA T3
TF3X0  LDX T2; SKA TF3MSK,2; BRU TF3X2
TF3X1  SKR T2; BRU TF3X0; LDX TPORT; BRR TF3XMA
TF3X2  LDA T; ETR TF3MSK,2; EXU TF3SHF,2; MRG TF3TYP,2
       LDX TPORT; RSH 8; CXA; LCY 8
       MRG K2B5; DIR; STA TPAIR2; ETR KM400; MRG ONE
       BRM TROPAIR; EIR   OUTPUT A 1 FOLLOWED BY TERMINAL CHARACTERISTIC
       LDA T3; BRU TF3X1

$TGC   0
       LDA XX; STA TT,2
TGC1   CLA; SKE TC,2; BRU *+2; BRU TGC3
       LDA THIRD; DIR
       MUL TP,2; AXC; LDX 0,2
       LCY 2; COPY AX,XA,XB; EXU TGC5,2
       ETR K377; LDX TPORT
       SKG SEVEN; BRU TGCE
       MIN TGC
TGC3   EIR; BRR TGC
TGC5   LCY 8; RCY 8; NOP 0; BRM MONCR

TGCE   ADD =2300003B+*; STA *+1; EXU *
       BRU TGCE0; BRM MONCR; BRM MONCR; BRM MONCR
       BRM MONCR; BRM MONCR; BRM MONCR; BRU TGCE7
TGCE0 LDA TINC3X; STA TGCINC SET UP POSSIBLE TP,TC UPDATE
       LDA KM1; XMA TGC; ADD ONE; STA TINC1
       LDA ONE; ADD TP,2; MUL THIRD; AXC; LDX 0,2
       LCY 2; COPY AX,XA,XB; EXU TGC5,2; ETR K377
       LDX TPORT; EIR; BRR TINC1

TGCE7  EQU *   ENTER PROGRAM ECHO MODE
       MIN TP,2; RST =7IY,TF1
       MIN TCC; SKR TC,2; BRU TGC1; BRM MONCR

$TGCINC 0 TINC2 POINT AT TP,TC UPDATE SUBROUTINE
TINC1 0;* USED BY TGCE0
TINC2 0;* REMOVE 1 CHAR FROM BUFFER
 DIR; SKR TC,2; BRU *+3; MIN TC,2; BRU *+3; MIN TP,2; MIN TCC; EIR
TINC2X BRR TINC2
TINC3 0;* RESET TGCINC TO POINT AT TINC2. MAYBE REMOVE TWO CHARS
* FROM BUFFER
 STA TGCINC; LDA TINC2X; XMA TGCINC; BRM TINC2; SKN TGC
TINC3X BRR TINC3; BRU* TINC3 REMOVE EXTRA CHAR

* WRITE CHARACTER TO INPUT BUFFER.  MAKE CERTAIN USER IS ACTIVATED IF
* CHARACTER COUNT > 377B OR INPUT BUFFER SPACE IS GETTING CRITICAL.
* SEND XOFF IF TERMINAL IS IN XOFF MODE.  BACKPRESSURE PORT IF
* ESCAPES ARE DISABLED OR IF IN 8 LEVEL INPUT MODE.
*
$TWC   0
       STA TWA; STX TWX; MIN TRATE,2
TWC1   LDA TP+1,2; SUB TC,2; SKG TP,2; BRU TG1
       LDA KM1; STA TY1E0F   (RESET DOUBLE CHAR PAIR FLAG)
       LDA TC,2; SKG K377; BRU TWC4A
TWC4   EQU *
       IF TSTAT1; LDA REAL; ELSE; CLA; ENDF
       STA TT,2; LDA =-1-RCY; ETR TF2,2; STA TF2,2
       LDA TF1,2; SKA =DIY; BRU *+2; BRU TWC6
       EOR =DIY; STA TF1,2; MIN ACTR; BRU TWC6
TWC4A  LDA 1TCC; SUB TCC; SKG ZERO; BRU TWC2
       LDA TF1,2; SKN TF3,2; BRU TWC4
TWC6   SKA =XY (IS TERMINAL IN X-OFF MODE?)
       SKA =XOFFY (HAS AN X-OFF BEEN SENT?)
       BRU TWC3 (DON'T SEND X-OFF)
       MRG =XOFFY  (SEND X-OFF AND SET SAID FLAG)
       STA TF1,2; COPY XA,B; LCY 8; MRG =200223B (XOFF); BRM TRO
TWC3   BRM BP (BACKPRESSURE IF APPLICABLE)
TWC2   LDA TC,2
       ADD TP,2; MUL THIRD; XMA TWA; ETR K377; AXC
       LCY 2; COPY AX,XA,XB
       EXU TWC5,2
       XMA* TWA; ETR TWMASK,2
       ADM* TWA
       LDX TWX; MIN TC,2; SKR TCC; BRR TWC; BRM MONCR
TWA    0;* INPUT CHR. CHANGED TO BFR POINTER.
$TWX   0;* PORT 
TWC5   RCY 8; LCY 8; NOP 0; BRM MONCR
TWMASK DATA 177777B,77600377B,-400B

       IF -1
TGCK   0;* REMOVE WHEN NOT SHOWING BUGS      
       CLA; LDX =-NPORT
TGCK0  LDB KM1
TGCK1  SKB TC+NPORT,2; BRU TGCK3
TGCK2  BRX TGCK1; BRR TGCK
TGCK3  STA TGSUM; LDA TP+NPORT,2; MUL THIRD; XMA TGSUM; ADD* TGSUM
       BRX TGCK0; BRR TGCK
TGSUM  0
TGSUM1 0
       ENDF -1

TG1    EQU *   GARBAGE COLLECTOR
       MIN TG1C
TG1A   LDA TP,2; SUB TP-1,2; SUB TC-1,2; SKG K17; BRU TG3
       LDA TP,2; MUL THIRD; STA TGBRX1
       LDA TP-1,2; ADD TC-1,2; ADD EIGHT; MUL THIRD; STA TGBRX1+1
       SUB TGBRX1; MUL THREE; LSH 23
       ADM TP,2; COPY AB,XA; EAX 1,2; EOR TWX; XAB; SKB ADMSK; BRU *-6
       LDA TP,2; ADD FIVE; MUL THIRD; SUB TGBRX1
       CNA; COPY AX,N
       ADD =276B5; ADM TGBRX1; ADD =235B5-276B5; ADM TGBRX1+1
       STX TBRX1X
TGBRX1 LDA 0,2; STA 0,2; BRX TGBRX1
TG2    EQU *   GARBAGE COLLECTION FINISHED. TRY TO STORE CHARACTER.
       LDX TWX; BRU TWC1
TG3    CXB; EAX -1,2; SKB ADMSK; BRU TG1A
       EAX NPORT
       MIN TG5C
TG5    EAX -1,2; LDA TP+1,2; SUB TP,2; SUB TC,2; SKG K17; BRU TG6
       LDA TP,2; ADD TC,2; MUL THIRD; STA TGBRX2
       LDA TP+1,2; MUL THIRD; SUB THREE; STA TGBRX2+1
       SUB TGBRX2; MUL THREE; LSH 23
       ADM TP,2; EAX -1,2; COPY AB,XA; EOR TWX; XAB; SKB ADMSK; BRU *-6
       LDA TP,2; ADD TC,2; MUL THIRD
       CNA; ADD TGBRX2; ADD ONE; COPY AX,N
       ADD =276B5; ADM TGBRX2; ADD =235B5-276B5; ADM TGBRX2+1
       STX TBRX2X
TGBRX2 LDA 0,2; STA 0,2; EAX -2,2; BRX TG2; BRU TGBRX2
TG6    COPY XA,B; EOR TWX; SKA ADMSK; BRU TG5
       LDA EIGHT; SKA ALARM; BRU *+2; ADM ALARM
       MIN BZ  BUFFER ZAP COUNT
       STB BZSIZE; STB TG6X
       LDA TG9; STA TG10
TG7    LDX =-NPORT     FIND THE BIGGEST BUFFER
TG8    LDA TC+NPORT,2; SKG BZSIZE
TG9    BRU TG11
       LDB TF1+NPORT,2; SKB =XY+LGY (XON/XOFF MODE OR LOGGING)
TG10   BRU TG11 (DON'T ZAP CIRCUIT THIS TIME AROUND)
       STA BZSIZE (SIZE OF BUFFER ZAPPED)
       STX TG6X (INDEX)
TG11   BRX TG8; SKN TG6X (DID WE FIND ANYTHING TO ZAP)
       BRU TG12 (QUITE POSSIBLY NO BUFFERS TO ZAP)
       LDA TG6X; COPY AX,A
       XMA TC+NPORT,2
       ADM BZCC (TOTAL CHARS ZAPPED)
       ADM TCC (UPDATE TOTAL BUFFER SIZE COUNT)
       CXA; ADD =NPORT; STA TG6X; CAX
       SET =GOBY,TF1
       BRM TBACKP (RELIEVE BACKPRESSURE)
       LDA TG6X
*      (CHECK IF THIS CHARACTER IS THE SECOND CHARACTER OF
*      A DOUBLE CHARACTER PAIR, AND ITS BUFFER JUST GOT ZAPPED)
       SKN TY1E0F; SKE TWX; BRU TG2 (NO, JUST TRY AND STORE CHAR)
       LDA TWA; STA TWA0; LDA TWC; STA TWC0 (SAVE CHAR AND RETURN LOC)
       CLA; LDX TWX; BRM TWC   (RESTORE ZERO CHARACTER IN ZAPPED BUFFER)
       LDA TWC0; STA TWC; LDA TWA0; LDX TWX; BRU TWC+1 (STORE 2ND CHAR)
TG12   LDA TWC5+2 (NOP); STA TG10; BRU TG7
BZCC   0;*     (TOTAL CHARS ZAPPED)
TWA0   0;*     (2ND CHAR OF DOUBLE PAIRS WHEN ZERO CHAR GETS ZAPPED)
TWC0   0;*     (ORIGANAL CALLER OF TWC ROUTINE)
TG1C   0;*     GARBAGE COLLECTOR STATISTIC
TG5C   0;*     GARBAGE COLLECTOR STATISTIC
TBRX1X 0
TBRX2X 0
TG6X   0
BZSIZE ZRO

$BP    ZRO;* BACKPRESSURE A PORT
       LDB TF1,2
       SKB =IIHY+LGY; BRR BP (ALREADY INHIBITED OR PROHIBITED)
       SKB =8IY; BRU *+5; LDB TF2,2; SKB =B113Y+B161Y; BRU *+2
       BRR BP (HIS PROGRAM CAN BE INTERRUPTED FROM THE TTY WITH AN ESCAPE CHR);
       LDA =IIHY; ADM TF1,2; COPY XA,B; LCY 8; MRG =7*2B5; BRM TRO
       BRR BP

$TRI   0
       IF TST; SKN TIBC; BRU TIBCHR; ENDF
       LDX TIX
       LDA ETBI+1,2; SKE TFREE; BRU *+3; MIN TRIC1; BRU TRI1
       MIN TIICTR; EOR ETBI,2; SKE KM1; BRM MONCR
       LDA TFREEC; STA ETBI,2
       LDA TFREE; XMA ETBI+1,2
       IF TLOG
       MIN TLOGP; LDB KM1; SKB* TLOGP; BRU *+3; LDB =TLOGP+1; STB TLOGP
       EOR X4; STA* TLOGP; EOR X4
       ENDF TLOG
       BRX *+1; BRX *+2; LDX =-NTBI; STX TIX
TRI1   COPY AB,AX,A; LCY 8; SKG K15; BRU *+2; BRM MONCR; STA TQTYPE
       CLA; LCY 8; SKG =NPORT-1; BRU *+2; BRM MONCR; STA TQPORT
       XXA; ETR K377; STA TQCHR
       BRR TRI
$TIX   0;* NEGATIVE INDEX INTO TBI
TRIC1  0

       IF TST
TIBCHR LDA* TIBP; MIN TIBP
       SKR TIBC; BRU TRI1; LDB =TIBUF; STB TIBP; BRU TRI1
$TIBUF BSS 16
$TOBUF BSS 32
$TTROPAIR ZRO
       LDB TTROPAIR; STB TTRO; STA* TOBP; MIN TOBP
       LDA TPAIR2; BRU *+2
$TTRO  ZRO
       STA* TOBP; MIN TOBP
       LDA TOBP; SKG =TOBUF+15; BRR TTRO
       CLB; STB TTROSW; BRR TTRO
       ENDF

$TROPAIR 0;* OUTPUT 2 WORDS TO THE RING. THE SECOND WORD FIRST.
       STX TPAIRX; STA TPAIR1
       LDX TOX; EAX* TRO1    POINTER TO WHERE THE FIRST COMPLEMENT GOES
       LDA TFREE; BRM TRO  ADVANCE THE POINTERS
       LDA TPAIR2; BRM TRO   STORE THE SECOND WORD AND ITS COMPLEMENT
       LDA TPAIR1; EOR KM1; STA 0,2; LDA TPAIR1; STA 1,2  1ST WORD
       IF TLOG
       MIN TLOGP; LDB KM1; SKB* TLOGP; BRU *+3; LDB =TLOGP+1; STB TLOGP
       STA* TLOGP
       ENDF TLOGP
       LDX TPAIRX
       BRR TROPAIR
TPAIR1 0
$TPAIR2 0
TPAIRX 0

$TROTY1 0
       DIR
       RCY 8; LDA K77; ETR TF2,2; XXA; MIN CCT,2; CAX; LCY 8; MRG K2B5
       SKA =370B
       BRU *+5; STA TPAIR2; ETR KM400; BRM TROPAIR; BRU *+2; BRM TRO
       EIR; BRR TROTY1

$TROM  0;* CALL TRO IMMEDIATE. DONT SET ESCAPE LIKE TROTY1 DOES.
       DIR; RCY 8; CXA; LCY 8; MRG K2B5; BRM TRO; EIR
       BRR TROM

$TRO   0
       MIN TOICTR
       STX TROX; LDX TOX; EOR KM1
TRO1   STA TBO+32,2
       BRX *+2; BRM MONCR; EOR KM1
       IF TLOG
       MIN TLOGP; LDB KM1; SKB* TLOGP; BRU *+3; LDB =TLOGP+1; STB TLOGP
       STA* TLOGP
       ENDF TLOG
       XMA* TRO1; SKE TFREE; BRM MONCR (OUTPUT BUFFER FULL)
       BRX TRO2
       LDA TRO1; ADD =32-NTBO; SKE TRO9; ADD =NTBO
       STA TRO1     MOVE TO NEXT GROUP OF 32 OR WRAP AROUND
       ADD =16-235B5-NTBO; SKG =TBO; ADD =NTBO  (LOOK AHEAD TO MAKE SURE
       CAX; LDA 0,2     THERE IS PLENTY OF ROOM IN THE RING)
       SKE TFREEC; BRU *+2; BRU TRO2A
       CXA; SUB =NTBO/2; SKG =TBO-1; ADD =NTBO
       STA TROSW    LET RING HALF EMPTY BEFORE USING IT AGAIN
       LDA CLINTV; STA CLINT1
TRO2A  LDX =-32
TRO2   STX TOX; LDX TROX
       BRR TRO
TROX   0;* SAVED X REGISTOR
TOX    DATA -32  INDEX INTO 32 WORD GRUOP IN OUTPUT RING
TRO9   STA TBO+32,2

       IF TLOG
TLOGP  0 *     POINTER INTO LOG BUFFER (WHICH FOLLOWS)
       IF DISC<3
       RPT 400B; 0 *,1  KEY THE LOG AREA WITH NON-ZERO CELLS); ENDR
       0 0     END OF LOG BUFFER PLUS 1 MUST CONTAIN A ZERO
       ELSF DISC=3; RPT 100B; 0 *,1; ENDR; DATA 0
       ENDF DISC
       ENDF

       END
MONITOR ** FICHE/FRAME BREAK *****
NET SYMSORT

SYM.  PG.LN. IDENT.

BP      6 14 NET     BZCC    6  4 NET     BZSIZE  6 12 NET     
MODCK   1 13 NET     SIO     1 29 NET     SIO1    1 36 NET     SIO2    1 37 NET     
TBRX1X  6  9 NET     TBRX2X  6 10 NET     TF3X0   2 14 NET     TF3X1   2 15 NET     
TF3X2   2 16 NET     TF3XMA  2  7 NET     TG1     4 26 NET     TG10    5 23 NET     
TG11    5 26 NET     TG12    6  3 NET     TG1A    4 28 NET     TG1C    6  7 NET     
TG2     4 38 NET     TG3     5  1 NET     TG5     5  4 NET     TG5C    6  8 NET     
TG6     5 14 NET     TG6X    6 11 NET     TG7     5 19 NET     TG8     5 20 NET     
TG9     5 21 NET     TGBRX1  4 37 NET     TGBRX2  5 13 NET     TGC     2 22 NET     
TGC1    2 24 NET     TGC3    2 31 NET     TGC5    2 32 NET     TGCE    2 34 NET     
TGCE0   2 37 NET     TGCE7   3  4 NET     TGCINC  3  8 NET     TGCK    4 15 NET     
TGCK0   4 17 NET     TGCK1   4 18 NET     TGCK2   4 19 NET     TGCK3   4 20 NET     
TGSUM   4 22 NET     TGSUM1  4 23 NET     TIBCHR  7  3 NET     TIBUF   7  5 NET     
TINC1   3  9 NET     TINC2   3 10 NET     TINC2X  3 12 NET     TINC3   3 13 NET     
TINC3X  3 16 NET     TIX     6 38 NET     TLOG    1  6 NET     TLOGP   8 31 NET     
TOBUF   7  6 NET     TOX     8 27 NET     TPAIR1  7 28 NET     TPAIR2  7 29 NET     
TPAIRX  7 30 NET     TRI     6 22 NET     TRI1    6 34 NET     TRIC1   6 39 NET     
TRO     8  4 NET     TRO1    8  7 NET     TRO2    8 24 NET     TRO2A   8 23 NET     
TRO9    8 28 NET     TROM    7 39 NET     TROPAI  7 16 NET     TROTY1  7 32 NET     
TROX    8 26 NET     TTRO    7 10 NET     TTROPA  7  7 NET     TWA     4  9 NET     
TWA0    6  5 NET     TWC     3 23 NET     TWC0    6  6 NET     TWC1    3 25 NET     
TWC2    4  2 NET     TWC3    4  1 NET     TWC4    3 28 NET     TWC4A   3 33 NET     
TWC5    4 11 NET     TWC6    3 35 NET     TWMASK  4 12 NET     TWX     4 10 NET     

MONITOR ** FICHE/FRAME BREAK *****
PAC
PAC    IDENT 01/10/77

       LISTM

* ENTRY POINTS

       ENTRY   PEST6,FQJ3,FQJ11,SCAN,PPREV,SCHLP,SWIX
       ENTRY   PACSW,RAER3,SWIN,SWLS,SWT3,SWPMT,SWSMT,PDMS2
       ENTRY   SRT44E,POPR3
       ENTRY   RAEROR,PACSWQ,PG44,POPR4,POPR5
       ENTRY   RLWB
       ENTRY   RAER2,RAJOB2,CMPST,NPOPDS
       ENTRY   CMRRL1,CMRRL2,CMRRL3,PACQUE,PACJOB,PACOMP,RAJOB1,STCMRL
       ENTRY   RAJOB,RAJOB3,RELPG,SWAPR,SWAPI,SWJOB
       ENTRY   RELMEM,RELPG3,RELPG8,SETSWP,POPX
       ENTRY   CLINTC,POPR,PACDMS
       ENTRY   MPPACT,RLTS,PUPACP,RLPACT
       ENTRY PUDEAD,PWNI
       ENTRY   PUTIM,NPOPX,NXPOP,NPOPXB
       ENTRY   MPDSC,MPWB,NTERM,ALTERM

       ENTRY   SRT,SRTE
       ENTRY   PACDMB,POPX,XPOP,PACQE,POPDMS
       ENTRY   PACGO,PEST,POPST,PUGO,NPUGO,QQEDMS,PACGO1
       ENTRY   FPULST,PUEPTR,PUBPTR,PUPAC
       ENTRY   UPRL,PTRL,LABEL,CHREL
       ENTRY   RRL1,RRL2,RRL3,TIME,TTIME,TIME1,PUCTR
       ENTRY   DMS
       ENTRY   EPU,FPLST,QSCH,QPUT,IIR
       ENTRY   CLINT,PWFI,TRAPT
       ENTRY   PPTEST,PTESTS,PACLVL

PACDMB ZRO *
DMS111 23B PACDMB   BRS 111 DISMISS
PACQ2  16B PACDMB  QUANTUM OVERFLOW

*
*      SCHEDULER 
* ACTIVATION CONDITIONS
* 
* 0      WD>0.  FKSTW (WAIT FOR PACT ON FREELIST IN BRS 9)
* 1      WD LE 0. FQJ4 (QTI JOB SWAPPING IN)
* 2      WD GE 0. TF2 (TTY OUT DISMISS)
* 3      NOT USED.  CRASH
* 4      SPECIAL TEST. WORD POINTS TO A SPECIAL ACTIVATION TEST
*        ROUTINE. TAPE READY TEST.
* 5      INTERRUPT OCCURRED. ADDRESS HAS A BIT SET CORRESPONDING TO
*        THE INTERRUPT WHICH OCCURRED.
* 6      WD<REAL. (INPUT BUFFER)
* 7      SPECIAL. FORK NOT ON QUEUES.
*            ADDRESS
*                0  DEAD
*                1  RUNNING
*                2  NEW FORK ABOUT TO START.  SEE BRS 9.
*                3  UNCORRECTABLE RAD ERRORS.
*                4  EXEC BRS.
*                5  BRS 109. DMS UNTIL OFF INTERRUPT PROCESSING.
*                6  BRS 9.
* 10     WD>0  ALL DISC WORK (CDMS)
* 11     WD(AND)YELLOW BALL FLAG=0.  OUTPUT BUFFER WAIT.
* 12     WD<0.  WAIT FOR UNIT TO BE FREE.
* 13     WD>0.  NOT USED
* 14     WD>0.  NOT USED
* 15     WD>0.  WAIT FOR LOGIN PU TASK.  (SEE SETPAC)
* 16     WD>0.  QUANTUM OVERFLOW
* 17     WD>0.  NOT USED
* 20     WD>0. EXEC LEVEL PANIC.  SEE TFK.
* 21     WD>0. ORDINARY PANIC.  SEE TFK.
* 22     WORD GE 0. DISC ERRORS OF PU 3 SEC W BUFFER TIME OUT.
*        GOES TO TRAP.
* 23     WD>0.  BRS 115.
* 24     WD>0. BRS 44.
* 25     NOT USED. SAVE FOR BRS 44.
* 26     NOT USED. SAVE FOR RFK.
* 27     NOT USED.  USED TO BE FOR COMPUTE JOB
* 30     NOT USED. SAVE FOR PUACT.
* 31     WD>0.  NOT USED
* 32     WD(AND)TYPE 5 OUT FLAG=0.  BRS 138.
* 33     WD<0. NEW TAPE AND PRINTER.
* 34     WD LE 0.  TROSW (OUTPUT RING CRAMP)
* 35     WD>0.  DHTPAC (ACTIVATE MAP PROGRAM--DHT FULL)
* 36     WD<REAL (BRS 45,81, ETC)
* 37     NOT USED.  SAVE FOR PMTA.
* WHEN CHANGING THIS LIST BE SURE TO INCREASE QTIGO TABLE.
* 
* 
* 
* *** LOG SYMBOLS
* 20 FKGO2,FKGO,PACPTR
* 21 PMTA,PMTA
* 22 POPD9A
* 23 PURBT,PUPAC,PUTTY
* 24 PGET,PGET,UTTY,JOB
* 27 CDMS1,JOB   DISMISS BRS 122,123 IF DRQ FULL
* 30 BRS153,0,LOGX=PAGE
* 32 PACGO5,JOB   ACTIVATE A FORK.
* 33 FCJ,SWJOB   FETCH COMPUTE JOB.
* 34 PEST3,SWJOB    SWAP QTI JOB.
* 35 RELPG,JOB,RELPG   RELEASE PAGES.
* 36 QPUT,QUEUE
* 37 QPUT,QPUT
* 40 QGET,PACPTR
* 41 QGET,QUEUE-PNEXT,QGET
* 42 POPR,BSX   DISMISS WITHOUT RELEASE
* 43
* 44
* 45 QTPUT,PACPTR
* 46 RELMEM,RELMEM   RELEASE MEMORY
* 47 SWAP,SWAP
* 50 UBRSET,JOB
* 51 BRSRET,JOB
* 52 STRLQ,0
* 53
* 54
* 55
* 56 PTRAP,PTRAP
* 57 FKST,XPB   BRS 9
* 60 SWREL,SWREL

*      POPRETURN ENTRY POINTS (NO DISMISS)

* RELABEL PAC TABLES BEFORE EXIT
NXPOP  STA SS01; BRM MPPACT; LDA SS01; BRR 0
NPOPXB 0; STA SS01; BRM NPOPX
$NPOPX0 BRM MPPACT
$POPX0 MIN 0; BRU POPX
NPOPX  0; BRM MPPACT
*SYSPOP EXIT TO RESTORE CENTRAL REGISTERS
POPX  LDA SS01
$POPXB  LDB SS02
$XPOPX LDX SS03
XPOP   BRR 0

*      DISMISSAL ENTRY POINTS

* DISMISS UNTIL INTERRUPT
* BRS 109
DMS    LDB =700005B; STB PACDMS; BRU POPST
NPOPDS BRM MPPACT; BRU POPDMS
* POP EXIT WITHOUT PAGE RELEASE - PAGES ALREADY RELEASED
*      E.G. BRS 115 TO POPR, BRS 44 TO POPR5 AND POPR4.
POPR   MIN 0; LDB DMS111
       IF ALOG; DIR; LOGG 42B,BSX; EIR; ENDF
       STB PACDMS
POPR3  LDA PACPTR
       LDX =QQE; SKN PACJOB; BRU POPR5; SKN TTIME; BRU *+2
       BRU POPR4; STX PACQUE
*      DISMISS USER ON FRONT OF QQE INSTEAD OF REAR
       IF TSTAT; MIN NQTPUT; ENDF
       IF ALOG; DIR; LOGG 45B,LOGA; EIR; ENDF
       CAX; LDA QQE; STA PNEXT,2
       STX QQE; MIN QQEC; SKG ZERO; BRU POPR6
       STX QQE+1 (FIX TAIL PTR); BRU POPR6
POPR5  LDX PACSWQ; SKN TTIME; BRU POPR7
       IF TSTAT; MIN NTTQJ; ENDF
       LDA =QQE; LDX PACPTR; BRU POPR8
POPR7  XXA; ADD =PNEXT
POPR8  XXA
POPR4  STX PACQUE; BRM QPPUT
POPR6  LDB PACDMS; LDX PACPTR; STB PTEST,2; STB PTESTS; BRU POPD9

QTEST  STB PACDMS
       IF TSTAT
       SKN TTIME; BRU *+3; MIN NTTQJ; BRU PDMS3; MIN NTQJ
       ENDF
       BRU PDMS3

*      QUANTUM EXCEEDED DISMISSALS - E.G. EPOPX TO PACQM1,
*      QUANTUM EXCEEDED TO PACQE, TRAPT1 TO QQEDMS.
$PACQM1 MIN 0
PACQE  LDB PACQ2 (SROUT COMES HERE TOO)
QQEDMS LDX =QQE; SKN PACJOB; BRU QTEST (NOT COMPUTE JOB)
       LDX =QQC
*POP DISMISS ENTRY POINT
POPDMS STB PACDMS; SKN PACJOB; BRU PDMS2 (NOT COMPUTE JOB)
       CXA; SKE =QIO; BRU PDMS2; LDX =QQC
*
*  SVST = SUPERVISOR STATUS (LOCATED IN TS PAGE) NEG. IF SUPERVISOR
*  SUPERVISOR SHARES 50%
*  OF COMPUTE TIME BETWEEN HIM AND THE QQC JOB.
*  QQC JOB ALTERNATES BETWEEN QIO AND QQE, SO WHEN SUPERVISOR IS
*  IS RUNNING EACH QIO AND QQE JOB GET 25% OF COMPUTE JOB TIME
*  SUPERVISOR CAN BE DISMISSED ON EITHER QQC OR QSQ AND NO OTHER QUEUE.
*
PDMS2  SKN TTIME; BRU PDMS3; LDX =QQE
       IF TSTAT; MIN NTTQJ; ENDF
PDMS3  EQU *
       IF SUPER
       CXA; SKN SVST; BRU PDMS4; SKE =QQC; LDX =QSQ
STT    EQU 1
       IF STT
       LDA REAL; STA STT20; STA STT21
       ENDF
PDMS4  EQU *
       ENDF SUPER
       LDA PACPTR; STX PACQUE; BRM QPPUT; BRU POPST2

*      BRS 109 ENTERS FROM DMS ABOVE.
POPST  CLA; STA PACQUE
POPST2 LDB PACDMS (PICK UP DISMISS COND)
       LDX PACPTR; STB PTEST,2; STB PTESTS
* RELEASE PAGES OF TERMINATING FORK
       LDB X4; LDA PACQUE; SKE =QQC; STB PGSW
POPD9  EQU *

       CLA; SKN XPB; BRU *+2; LDA SCHDLY; ETR FLAGS; STA T
       LDX PACPTR; LDA 0; ETR =50037777B; XMA PL,2; ETR K1B5
       MRG T; ETR =77B5; ADM PL,2 (SAVE START LOC)
       IF ALOG; DIR; LOGG 22B,PACPTR; LOGG 22B,JOB; EIR; ENDF
*SAVE CENTRAL REGISTERS
       SKN XPB; BRU PAC1E
       LDX XPB; LDA SS02; STA PB,2; LDA SS01; STA PA,2
       LDA SS03; STA PX,2
       IF      FPH
       HFST    FAC1,FAC2
       ENDF
       SKN     SFPOVI
       BRU     PAC1C
       BRM MONCR (FLOATING OVERFLOW YET TO BE REPORTED)
PAC1C  BSS     0
*SET UP PROPER QUANTUM REMAINING
       LDB =NLQU; IF SUPER; SKN SVST; BRU *+2; LDB =SVLQ; ENDF
       LDA TTIME; SKG KM1; CBA; STA LQ
       IF TSTAT
       LDA =NULJOB; STA CJOB
       SKN QQC (DID WE LOSE A COMPUTE JOB)
       SKN PACJOB (MAYBE, WAS IT RUNNING)
       BRU PAC1D
       LDA REAL; SUB CREAL
       ADM CTIME (HOW LONG COMPUTE JOB RESIDENT)
       MIN CJRUN (NO. OF COMPUTE JOBS FETCHED)
PAC1D  EQU *
       ENDF
PAC1E  SKN PGSW; BRU PAC1F
       LDA X4; LDB PACPTR; LDX JOB; STX PGSW; BRM RELPG
PAC1F  SKN XPB; BRU PACGO1
* PACJOB IS NEGATIVE WHENEVER A COMPUTE JOB IS RUNNING
       IF PTICK
$PACGOA SKN PACJOB; BRU PACGO1; LDA TTIME; BRM SJB
       ELSE
$PACGOA EQU * (ENTRY POINT FROM BRS 112)
       ENDF
PACGO1 LDA =SETTB; STA TJOB (SET ACCOUNT TO SYSTEM)
       CLA; STA PACJOB; STA SCHLP

PACGOM LDA 216B; LDB FG940A; SKE ZERO; CLB
       STB UPFL; LDA FG940B; STA UPFL+1
       IF DISC=3; LDA =2B5+1; STA DRQU; ENDF
       LDA REAL; STA MUX15



* TEST FOR PU ACTIVATION. DON'T RUN IF QTI OR COMPUTE JOB IS COMING IN.
* EG, "PACSW" IS NEG. AND CONTAINS ITS PACPTR, OR RAJOB2 .NE. 0.
*   RAJOB1 IS THE NUM OF PAGES COMING IN FROM THE RAD FOR THE QTI JOB.
*   RAJOB2 CONTAINS THE NUMBER OF PAGES COMING IN FOR THE COMPUTE JOB.
       SKN PACSW; BRU *+2; BRU PACGO; LDA RAJOB2; SKE ZERO; BRU PACGO
*   CHECK THE 3 SECOND TIMER FOR THE PHANTUM USER (PUTIME)
       LDA PUTIME; SKG REAL; BRU PU3SEC
*  PUCTR IS THE NUMBER OF JOBS ON THE PU QUEUE.
       LDA PUCTR; SKG ZERO; BRU PACGO
*  PURUN SAYS PU HAS BEEN AND IT DOESNT NEED TO BE RUN NOW
       SKN PURUN; BRU PUGO4
*   ACTR IS POSITVE IF ANY JOBS ARE READY TO RUN
       SKN ACTR; BRU *+2; BRU PACGO
*  PUCTR1 IS THE COUNT FROM LAST RUN WHICH IS CHECKED AGAINST THE
* CURRENT COUNT TO SEE IF PU SHOULD BE RUN
       SKE PUCTR1; BRU PUGO4; BRU PACGO

* IF THE SUPERVISOR IS RUNNING ON A 48K MACHINE, THE SUPERVISOR
* SHOULD BE THE ONLY EFFECTIVE JOB.
*
* START SCHEDULER
PACGO  LDA KM1; STA DNTERM; STA PURUN
       SKN M48K; BRU *+2; BRU PACGO2
       SKN QQC; BRU FCJ (FETCH COMPUTE JOB)
PACGO2 SKN PACSW; BRU FQJ (FETCH QTI JOB)
* QTI JOB EITHER IN OR COMING IN
       CLA
*  SCHLP DETERMINES WHETHER RAJOB1 SHOUD BE ZERO OR MINUS ONE
*  WHEN QTI JOB COMPLETES SWAP
       DIR; SKN SCHLP; BRU PACG21; SKE RAJOB1; BRU PACG22
       BRU PACGO7
PACG21 SKN RAJOB1; BRU *+2; BRU PACGO7
       MIN RAJOB1 (COUNTERACT SKR AT CMPIN OR CMPGO)
*                 (TO PREVENT PREMATURE UMT)
PACG22 EIR; BRU PACWT   (RUN COMPUTE JOB OR WAIT)
PACGO7 EIR
* QTI JOB READY TO RUN
$PACGO4 NOP; LDX PACSW; STX PACPTR; SKN RAER1; BRU NOGO
       BRM SETSWP; BRM SWAPI
PACGO6 BRM LABEL; CLEAR; STA PACSW; STA PACJOB; LDX PACPTR
       LDA FQJ5; STA PTEST,2
       LDA PNEXT,2; LDB PACSWQ; LDX PACSWP; BRM QGET
       LDA =NSQU; STA TIME
       SKR RAJOB1; BRM MONCR
       IF TSTAT
       LDX PNX4,2 (X CONTAINS PACSWQ)
       STX CJOB; MIN 1,2
       LDA REAL; SUB SREAL; ADM SWPTIM
       ENDF
* ACTIVATE A FORK
PACGO5 EQU *
       LDX PACPTR; BRM PGET
       IF ALOG; DIR; LOGG 32B,JOB; LOGG 32B,PACPTR; EIR; ENDF
       LDA =700001B; XMA PTEST,2; STA PPTEST
*  XPB IS NEGATIVE IF TS BLOCK EXISTS.
       LDA =NLQU; SKN XPB; BRU *+2; LDA LQ; STA TTIME
       DIR; IF SUPER; SKN SVST; BRU PACG51; CAB; LDA =NLQU
       SKG TTIME; CAB; STB TIME; BRU PACG52
       ENDF
PACG51 SKG TIME; STA TIME
PACG52 EIR
       LDA REAL; STA TIME1
       LDX UTTY; LDA =PUDY; COPY AB,N; SKB TF2,2; ADM TF2,2
       LDX PACPTR

*CHECK FOR INTERRUPT AND SET UP START LOC (0)
       BRM STSTAT    (SETS UP STATUS OF FORK)
       SKN XPB; BRU PACGO8
       LDA X1; SKN LMCPU; SKA PIM,2; BRU PACGO8
* LMCPU IS LIMIT ON CPU TIME
       BRM CTRU; LDX PACPTR; SKG LMCPU; BRU PACGO8; BRU PACGO9
PACGO8 LDA CMPQT; SKN PACJOB; LDA PACQT
       LRSH 15; ADD =ACTLST; XMA T; BRU* T
PACSRT LDA PL,2; STA 0
PACOVF ROV; LCY 1; LSH 1 (SET UP OVERFLOW)
       CLEAR
       STA     UMTF
       SKN XPB; BRU PAC2B
       LDX     XPB
       IF      FPH
       HFLD    FAC1,FAC2
       ENDF
       LDA PA,2; LDB PB,2; LDX PX,2
PAC2B  EQU *
       IF MDSI; ELSE
       SKN FQJPSW; MIN* TJOB
       ENDF
       BRU* 0
*
* RETURN TO EXEC FOR CPU TIME OVERRUN
PACGO9 LDB KM1; STB LMCPU
       LDX UTTY; LDX TTYASG,2; LDA PPTR,2; SKA PRMSK; CLB
       STB PAC9A; BRM HFK; STX PUPAC
       CLB; BRM RFK; LDA =QTI; BRM TFK; BRM QPUT; LDX TF01
       LDA TFC04; SKN PAC9A; LDA TFC03
       STA PL,2; LDA X1; MRG PIM,2; STA PIM,2; LDA X4; LDB PACPTR
       LDX JOB; BRM RELPG
       BRU PACGOA
TFC03  ZRO CKCPU,4
TFC04  ZRO CKCPU1,4
PAC9A  ZRO 0   NEG. IF IN EXEC
*
* SET STATUS FOR FORK
$STSTAT ZRO; LDA PTAB,2; LCY 1; RSH 23; STA EXEC1  -1 FOR SUBSYS STATUS
       LDA PIM,2; CLB; SKA K200; LDB KM1; STB SYSS
       CLB; SKA K400; LDB KM1; STB EXECS
       LDB X2; SKN EXEC1; LDB X1
       SKB SYSS; LDB X3; SKB EXECS; LDB =37B6
       STB PRILEV   HIGH FOR HIGHLY PRIVELEGED FORKS
       LDA SNOP; SKN SYSS; LDA SNTRP; STA NSYS
       LDA SNOP; SKN EXECS; LDA SNTRP; STA NEXEC; BRR STSTAT
*

* SCAN SPECIFIED QUEUE FOR A READY JOB
* INPUT: X=QUEUE (QTIQ)
* NO SKIP RETURN: NO READY JOB
* SKIP RETURN: X=PACPTR OF READY JOB
SCAN   ZRO
       IF TSTAT1; LDA PEST5A; STA PEST7A; ENDF
       MIN SCAN
       STX PACLVL (SAVE QUEUE); BRU *+2
* SCAN PACT
PEST   LDX PACPTR; SKN PNEXT,2
PEST5A BRR SCAN (NO READY JOBS); STX PPREV
PEST5  LDX PNEXT,2; STX PACPTR; LDA PTEST,2; LRSH 15; CAX
       LDA CACLST,2; STA T; LDX PACPTR; LDA* PTEST,2; BRU* T
$PACACT LDX PACPTR; LDA PL,2; EXU* SCAN
PEST6  LDX PACPTR
PEST7  MIN SCAN
PEST7A BRR SCAN
PEST8  SKA =7B5; BRU *+2; BRU PEST7; SUB K1B5
PEST9  STA PL,2; SKN PNEXT,2; BRU PEST6 (AT END ALREADY)
       LDA PACPTR; CAB; LDX PACLVL
       XMA PNXTP1,2 (FIX TAIL)
       COPY AX,BA (PACPTR TO A, TAIL PTR TO X)
       XMA PNEXT,2 (FIX OLD TAIL TO POINT TO US)
       CBX (RESTORE PACPTR)
       XMA PNEXT,2 (MAKE US POINT TO DUMMY)
       LDX PPREV
       STA PNEXT,2 (DELETE US FROM CHAIN)
       IF TSTAT; MIN ACTDLY; ENDF
       CBA (PACPTR); SKE PACSWP (PPREV OF INCOMING SWAP JOB)
       BRU PEST5
       STX PACSWP; BRU PEST5
PEST10 SKA =7B6; BRU *+2; BRU PEST7
       SUB K1B6; BRU PEST9
       IF TSTAT1
STAT5  LDA PTEST,2; SUB CDMS10; CAX; LDA REAL
       SUB DISCTT,2; ADM DSCTIM; MIN DSCRDY
       LDX PACPTR; BRR SCAN
STAT6  LDA REAL; SUB* PTEST,2; ADM TTYT; MIN TTYAC
       LDX PACPTR; BRR SCAN
       ENDF



QT     DATA QTIQ,QIOQ
QTE    EQU *
QLVL   ZRO


*      SCAN THE INTERACTIVE QUEUES.

       IF SUPER
FQJ    SKN PACSVR; BRU *+2; BRU PACWT (SUP IS COMPUTE JOB)
       ELSE
FQJ    EQU *
       ENDF
       SKN TTSW; BRU FQJ1
BIOST  BRM MPWB; BRU BIOSC (BIO SCANNER IN W PAGE)
$BIOSCE BRM MPPACT (BIO SCANNER RETURNS HERE)
$BIOSCF SKN TTSW; BRU FQJ3A
       IF SUPER
FQJ1   SKN M48K; BRU FQJ6; SKR SPR; BRU FQJ6
       LDX =QSQQ; BRM SCAN; BRU PEST7; BRU FQJ6; LDA ONE; STA SPR; BRU FQJ11
       ELSE
FQJ1   EQU *
       ENDF
FQJ6   LDX KM2
FQJ9   STX QLVL
       LDX QTE,2
FQJ10  BRM SCAN; BRU PEST8; BRU FQJ13 (NO JOB)
FQJ11  LDA KM1; STA TTSW; LDA K2B6 (NOP); STA PACGO4
       LDA =SETTB; STA TJOB
       IF TSTAT
       LDA REAL; STA SREAL (SAVE TIME OF FETCH)
       ENDF
       LDA T; STA PACQT
       LDA PACLVL; STA PACSWQ
       LDA PPREV; STA PACSWP
       LDA FQJ4; XMA PTEST,2; STA FQJ5
       STX PACSW; LDA =RAJOB1; STA SWRAJ; CLA; STA RAJOB1
       IF TSTAT
       LDA FQJ5; LRSH 15; ADD =QTIGO; STA RFR
       ENDF
       BRM SETSWP; BRM SWAP
       BRU PACAC2; BRU PACGO6; BRU PACWT

FQJ13  LDX QLVL; BRX FQJ9; SKN M48K; BRU FQJP1

* THIS SECTION COULD BE MOVED FROM ONCE-ONLY CODE TO FQJP1
       LDX =QQEQ; BRM SCAN; BRU PEST7; BRU FQJ3; BRU FQJ11
FQJ3   SKN TTSW; BRU BIOST
FQJ3A  LDA KM1; SKG NULSW; BRU *+2; BRU FQJ3B
* BIO SCANNER EXIT AT END OF TTQ.  RESET ACTR
       MIN PURUN; STA ACTR
FQJ3B  SKG NULSW1; MIN TTSW
       SKN QQC; BRU PACGO1
       CLA; STA TIME; SKN CMPST; BRU CMPGO
       SKE RAJOB2; BRU PACGO1; BRU CMPIN3
$FQJ4  BRU PACDMB
FQJ5   ZRO 0
*
* QTI JOB HAD READ ERROR
NOGO   BRM SETREL; BRM SWREL; CLA; STA PACSW; LDA KM1; STA RAER1
       IF SUPER; STA RAJOB1; ENDF
PACAC2 LDX PACPTR; LDA FQJ5; STA PTEST,2
       LDA PTAB,2; LRSH 15; ETR K77; CAX; DIR
       LDA TTNO,2; ADD K100; SKA K400; BRU PACDEL
       STA TTNO,2; EIR; BRU FQJ
* REMOVE USER
PACDEL ETR =77777077B; STA TTNO,2; EIR; LDX PACPTR; LDA PNEXT,2
       LDB PACSWQ; LDX PACSWP; BRM QGET; LDX PACPTR
       LDA =700003B; STA PTEST,2; MIN RU; BRU FQJ

* FETCH COMPUTE JOB
FCJ    LDA ONE; STA CMPST; CLA; STA PACOMP
       IF SUPER; STA PACSVR; ENDF
       STA PG44
       IF SUPER; SKR SPR; BRU FCJ2
       LDA REAL; SUB STT21; CLX; NOD 23; MIN STT24,2; LDA REAL; STA STT21
       LDX =QSQQ; BRM SCAN; BRU PEST7; BRU FCJ2; LDA X4; STA PACSVR; STA PG44
       LDA ONE; STA SPR; STX PACOMP; LDA REAL; SUB STT20
       CLX; NOD 23; MIN STT23,2; LDX PACOMP; BRU FCJ7
STT20  ZRO 0   REAL AT DMS
STT21  ZRO 0   REAL AT DMS/TEST
STT22  BSS 0
STT23  BES 23   TIME BETWEEN DMS AND READY RECOGNIZED.
STT24  BES 23   TIME BETWEEN TESTS FOR READY.
       ENDF SUPER

FCJ2   LDX WHOQ; BRM SCAN; BRU PEST10; BRU FCJ3; BRU FCJ4
FCJ3   LDX WHOQ2; BRM SCAN; BRU PEST10; BRU PACGO2 (NOTHING ON QQE OR QIO)
FCJ4   LDA WHOQ; XMA WHOQ2; STA WHOQ
FCJ6   STX PACOMP
FCJ7   LDA PNEXT,2; LDB PACLVL
       IF TSTAT; STB CMPSWQ; ENDF; LDX PPREV; BRM QGET
       IF TSTAT
       LDA REAL; STA CREAL
       ENDF
       LDA T; STA CMPQT
       LDA PACOMP; LDX PPREV; SKE PACSWP; BRU *+2; STX PACSWP
       LDX =QQC; BRM QPUT
       LDA KM1; STA CMPST (JOB COMING IN)
       LDA =RAJOB2; STA SWRAJ; LDA X4; STA SWPB; LDX PACOMP
       IF TSTAT
*USED TO BE QTIGO+27B WHICH WASN'T ALWAYS USEFUL:
       LDA PTEST,2; LRSH 15; ADD =QTIGO; STA RFR
       ENDF
       BRM SETSWP; IF ALOG; DIR; LOGG 33B,SWJOB; EIR; ENDF; BRM SWAP
       BRU FCJDEL; BRU *+2; BRU PACGO2
       BRM STCMRL STOR COMP JB REL.; MIN CMPST
       IF PTICK; LDA SWIN14; STA CJP; ENDF
       IF TSTAT
       LDA REAL; XMA CREAL; SUB REAL; CNA; ADM CMPTIM
       MIN SWPCJ
       ENDF
       BRU PACGO2
* READ ERROR. MOVE JOB TO QTI AND TRY AGAIN.
NOCOMP LDA KM1; STA RAER2; BRM SETREL; BRM SWREL
FCJDEL LDA =QQC; LDB =QQCQ; CBX; BRM QGET
       LDA PACOMP; LDX =QTI; BRM QPUT
       CLA; STA CMPST; STA PACOMP; BRU FCJ

* QUEUE JOB IS SWAPPING. RUN COMPUTE JOB OR WAIT.
* CMPST IS THE COMPUTE JOB STATUS IN TERMS OF THE RAD (SEE COMMENT)
PACWT  CLA; SKE CMPST; BRU *+2; BRU CMPGO; SKN CMPST; BRU PACWT3
PACWT2 SKE RAJOB2; BRU *+2; BRU CMPIN; SKE RAJOB1
       BRU PACWT2 (BOTH JOBS ARE SWAPPING); BRU PACGO4
* WAIT FOR QUEUE JOB. NO COMPUTE JOB.
PACWT3 SKE RAJOB1; BRU *-1; BRU PACGO4
* COMPUTE JOB JUST CAME IN
CMPIN  LDA KM1; LDB =36; DIR; ADM RAJOB1; STB TIME
       EIR
*      ENTRY FROM FQJ3 (NO SWAP JOB)--DONT CAUSE UMT.
CMPIN3 MIN CMPST; LDX PACOMP; SKN RAER2; BRU NOCOMP
       IF TSTAT
       LDA REAL; XMA CREAL; SUB REAL; CNA; ADM CMPTIM
       MIN SWPCJ
       ENDF
       BRM SETSWP; BRM SWAPI
       BRM STCMRL STORE COMPUT JB RELAB
       IF PTICK; LDA SWIN14; STA CJP; LDA CMRRL1; ENDF
       BRU CMPGO2
* STORE COMPUTE JOB RELABELING
STCMRL ZRO 0; STA CMRRL1; STB CMRRL2; STX CMRRL3; BRR STCMRL
* COMPUTE JOB READY TO RUN
* WETTB IS THE TIME THAT THE COMPUTE JOB TIES UP THE SHCEDULER
CMPGO  LDA =WETTB; STA TJOB; LDA KM1; STA SCHLP
       LDX =QQCQ; BRM SCAN; BRU PEST7; BRU PACGOM; LDA =SETTB; STA TJOB
*  36 CLOCK TICKS IS THE SHORT TIME QUANTUM
*  RAJOB1 IS NOW DECREMENTED FOR THE QTI JOB IN ORDER TO FORCE
*  A USER MODE TRAP BY THE RAD ROUTINES TO LET THE SCHEDULER
*  KNOW WHEN THE QTI JOB IS IN CORE.
       LDA =36; DIR; STA TIME; SKR RAJOB1; NOP; EIR
       LDA T; STA CMPQT
       LDA CMRRL1; LDB CMRRL2; LDX CMRRL3
CMPGO2 BRM LABEL
       IF PTICK
       LDX LQ (LONG QUANTUM REMAINING)
       LDA CJP; BRM NPC
       ENDF
* THE FOLLOWING LETS SUPER RUN ONLY 36 CLOCK TICS IF THERE IS NO
* INTERACTIVE JOB.  I CAN'T THINK OF ANY REASON FOR DOING THIS OTHER
* THAN TO GIVE OTHER JOBS ON QQE A SPECIAL BREAK.
       IF SUPER; SKN SVST; BRU *+2; MIN ACTR; ENDF
       LDX PACOMP; STX PACPTR
       LDA =QQC; LDB =QQCQ; CBX; BRM QGET
       IF TSTAT
       LDX CMPSWQ; LDX PNX5,2; STX CJOB
       MIN 1,2
       ENDF
       LDA KM1; STA PACJOB; BRU PACGO5


*SET UP FOR SWREL
* INPUT: X=PACPTR
SETREL ZRO; LDA PTAB,2; LRSH 15; ETR K77; COPY AX,XB
       LDA PMTP,2; ADD =-NCMEM; STA SWPMT; CNA; ADD =SMT; STA SWSMT; XXB
       LDA RL1,2; STA SWR1; LDA RL2,2; STA SWR2
       LDA =NCMEM; STA SWR3; BRR SETREL
* RELEASE PAGES FOR USER WITH READ ERROR
* INPUT: PSEUDO-REL IN SWR1,SWR2,SWR3.
*        PMT ADDR.-NCMEM IN SWPMT
SWREL  ZRO; LDA SWR1; LDB SWR2; LDX SWR3; BRM UPRL
       IF ALOG; DIR; LOGG 60B,SWREL; EIR; ENDF
       LDX NINE; STX SWRL3
SWRL7  LDX SWRL3; LDA SRT,2; SKE ZERO; BRU *+2; BRU SWRL4
       SKG =NCMEM-1; ADD SWSMT; ADD SWPMT; STA SWRL10; LDB =77B5
SWRL8  CAX; LDA 0,2; SKM =12B5; BRU *+2; BRU SWRL8
       SKM K4B5; BRU SWRL6
SWRL9  LDA SWRL10; MRG X4; DIR; BRM REL; EIR
SWRL4  SKR SWRL3; BRU SWRL7; DIR; BRM RAGO; EIR; BRR SWREL
SWRL6  SKM K2B5; BRU *+2; BRU SWRL9
       SKM =3B5; BRM MONCR; BRU SWRL4
SWRL3  ZRO 0
SWRL10 ZRO

* SET UP FOR SWAP
SETSWP ZRO; LDA PTAB,2; LRSH 15; ETR K77; STA SWJOB
       LDA RL1,2; LDB RL2,2; LDX =NCMEM; BRR SETSWP


* ROUTINE TO RELEASE PAGES.
* SUBSYSTEM PAGES GO WITH LOW PRIORITY WRITE.
* INPUT: B=PACPTR, X=JOB
*        A=0 FOR LOW PRIORITY WRITE. A=X4 FOR HIGH PRIORITY WRITE.
RELPG  ZRO; STA RELPG8; LDA PMTP,2; ADD =-NCMEM
       STA RELPG3 (PMT ADDR-NCMEM); IF ALOG; DIR; LOGG 35B,LOGX
       LOGG 35B,RELPG; EIR; ENDF
       CBX; LDA RL1,2; LDB RL2,2; LDX =NCMEM
       BRM RELMEM; BRR RELPG
* RELEASE MEMORY
RELMEM ZRO; IF ALOG; DIR; LOGG 46B,RELMEM; EIR; ENDF; BRM UPRL; LDX NINE; STX RELPG2
RELPG4 LDX RELPG2; LDA SRT,2; SKE ZERO; BRU *+2; BRU RELPG5
       SKG =NCMEM-1; BRU RELPG6; ADD RELPG3; MRG RELPG8
RELPG7 DIR; BRM REL; EIR
RELPG5 SKR RELPG2; BRU RELPG4; DIR; BRM RAGO; EIR; BRR RELMEM
RELPG6 ADD =SMT; BRU RELPG7
RELPG3 ZRO 0   PMT ADDR-NCMEM
RELPG2 ZRO 0   TEMP STORE FOR IX
RELPG8 ZRO 0   PRIORITY SWITCH. 0=LOW PRIORITY.

* RAJOB1=QTI JOB
* RAJOB2=COMPUTE JOB
* RAJOB3=RFK USER, BRS 44, AND OTHER HANG CALLS.

PACOMP ZRO 0   PACPTR OF COMPUTE JOB

CMRRL1 ZRO 0   RRL1 FOR COMPUTE JOB
CMRRL2 ZRO 0   RRL2 FOR COMPUTE JOB
CMRRL3 ZRO 0   RRL3 FOR COMPUTE JOB
       IF PTICK
$CJP   ZRO 0;* NO. OF COMPUTE JOB PAGES/
       ENDF
$PG44   ZRO 0   NO. OF PAGES READ BY BRS 44

SCHLP  ZRO 0   -1 IF WAITING FOR QQC JOB TO BE READY TO RUN.
*      E.G. IF COMPUTE JOB IS BLOCKED FOR DISC I/O AND WE HAVE
*      A SWAP JOB COMING IN, WE WANT TO TEST RAJOB1=0 SINCE UMT
*      WILL NEVER COME IN.
PGSW   DATA 0 (RELEASE FORK PAGES IF  NEG.)
CMPST  ZRO 0   COMPUTE JOB STATE. -1=COMING IN. 0=IN. 1=NO JOB.

       IF SUPER
SPR    ZRO 0   SUPERVISOR SWITCH. SUPER RUNS IF SWITCH IS NEG.
PACSVR ZRO 0   NEG. IF SUPERVISOR IS COMPUTE JOB.
       ENDF
WHOQ   DATA QQEQ   SET TO QQEQ OR QIOQ. WHICHEVER WE TRY NEXT.
WHOQ2  DATA QIOQ
CMPQT  0 0     CACLST ENTRY FOR COMPUTE JOB
PACSW  ZRO 0   PACPTR OF JOB COMING IN FROM QTI
PACSWQ DATA QTIQ QUEUE OF SWAP JOB COMING IN (PACLVL)
PACSWP ZRO 0   PPREV OF JOB COMING IN
PACQT  ZRO 0   CACLST ENTRY FOR SWAP JOB
PACJOB ZRO 0   0=QTI JOB RUNNING. -1=COMPUTE JOB RUNNING.
PURUN  DATA -1   RUN PU IF NO QUEUE JOBS.


*CAUSE A PROG INTERRRUPT
*  PPTEST IS THE INTERRUPT NUMBER
PACINT LDA PPTEST; ETR K37; SKE FIVE; BRU PI1
       LDA PTAB,2; RCY 15; ETR K77; CAX (JOB);
       LDA K1B5; COPY AB,N; ADM TTNO,2; SKB TTNO,2; BRM MONCR
       LDA FIVE; LDX PACPTR
PI1    LDB PL,2; SKN PL,2; LDB SBRSRT    GET INTERRUPTED ADDRESS
       COPY AX,BA; ETR ADMSK; LDX 200B,6 GET MARK LOCATION POINTER
       COPY XA,AB; LDX 0,6; STB 0,6   (GET INTERRUPT RETURN ADRS)
       ETR ADMSK;  ADD =40000001B; STA 0; LDX PACPTR; BRU PACOVF
*  CAUSE AN INSTRUCTION TRAP
PACTRP LDA PL,2; STA 0
       SKN XPB; BRM MONCR; LDX XPB; LDA PA,2; LDB PB,2; LDX PX,2
       STA SS01; STB SS02; STX SS03; BRM TRAP
*ACTIVATION TEST ROUTINES
CACLST 0 CAC0; 0 CAC1; 0 CAC2; 0 CAC3
       0 CAC4; 1 PACACT; 0 CAC6; 0 CACK
       IF TSTAT1; 0 CAC5; ELSE; 0 CAC2; ENDF
       0 CAC9; 0 CAC10; 0 CACK; 0 CACK
       0 CAC0; 0 CAC0; 0 CACK; 0 CAC0; 0 CAC0; 2 CAC2
       0 CAC0; 0 CAC0; 0 PEST; 0 PEST; 0 PEST; 0 PEST; 0 CACK
       0 CAC11; 0 CAC10; 0 CAC1; 0 CAC0; 0 CAC12; 0 PEST
* SPECIAL ACTIVATION ROUTINES
ACTLST BRU PACSRT; BRU PACINT; BRU PACTRP

CACK   BRM MONCR
CAC0   SKG ZERO; BRU PEST; BRU PACACT
CAC1   SKG ZERO; BRU PACACT; BRU PEST
CAC2   SKG KM1; BRU PEST; BRU PACACT
CAC3   SKA =IOBY+TBBY+CSTAY; BRU PEST; BRU PACACT
CAC4   BRU* PTEST,2
       IF TSTAT1
CAC5   SKG KM1; BRU PEST
       LDA CAC5A; STA PEST7A; BRU PACACT
CAC5A  BRU STAT5
       ELSE
CAC12  EQU *
       ENDF
CAC6   SKG REAL
       IF TSTAT1; BRU *+2; ELSE; BRU PACACT; ENDF; BRU PEST
       IF TSTAT1
       LDA CAC6A; STA PEST7A; BRU PACACT
CAC6A  BRU STAT6
       ENDF
CAC9   SKA =YELY; BRU PEST; BRU PACACT
CAC10  SKG KM1; BRU PACACT; BRU PEST
CAC11  SKA =5OY; BRU PEST; BRU PACACT
       IF TSTAT1
CAC12  SKG REAL; BRU PACACT; BRU PEST
       ENDF
*
*
PACDMS ZRO 0
PACQUE ZRO 0   QUEUE FOR TERMINATING FORK
PACLVL ZRO
PPREV  ZRO
PPTEST ZRO     0               SAVE OF STARTUP PTEST
PTESTS ZRO     0               SAVE OF DISMISS PTEST

FPLST ZRO
$SNOP  NOP
SNTRP  TRAP 53


* BIO SWAPPER
* VAR STORAGE
$PPG ZRO;* POINTER TO USER'S PROGRAM PAGE.  SAME FORMAT AS A PMT ENTRY.
$PG DATA -1;* ZERO IF PROGRAM PAGE IS EXPECTED TO BE SWAPPED
$PCL DATA -1;* NEGATIVE IF PROGRAM PAGE IS CLEAN
$BFL DATA 37777000B (BUFFERLET MAP.  NOTE BUFFERLETS 17-20B CONTAIN
*                    CODE AND ARE OMITTED FROM THE MAP)
$BFLN ZRO;* CURRENT BUFFER NO SHIFTED LEFT CHBNZ
$STATE DATA 0;* STATE OF CURRENT TTQ COMMAND.
$CMAP DATA 0;* REAL RELABELING FOR MONITOR RRL3. M6 IS PROG PG, M7 BUFFERLET.
$PASS DATA -2;* PASS COUNTER FOR BIO SCANNER
$PREPT DATA 100B;* PREVIOUS PORT IN TTQ CHAIN
$BPORT ZRO;* CURRENT PORT IN TTQ CHAIN.
$NULSW DATA -2;* MINNED IF BIO SCANNER HAS NOTHING TO DO
*      SO THAT ACTR WILL BE RESET AND WE SHOULD NOT GO
*      THROUGH FQJ FOR UP TO TWO SECONDS
$NULSW1 DATA -1;* MINNED FOR EACH TTQ TASK PERFORMED SO THAT
*      ORDER OF SCAN (TTQ OR QTI) CONTROLLED BY TTSW CAN BE CHANGED
$SWPCTR DATA -2;* COUNTS PAGE BRINGS BY BIO SCANNER
$RACKSW DATA -1;* POSITIVE WHEN BLET CODE BROUGHT FROM RAD
$TTSW DATA -1;* SCHEDULER SWITCH.  SCAN TTQ FIRST IF NEG.

$TSWAP EQU * EXIT FOR PROG. PAGE AND POSSIBLY BUFFERLET PAGE
       BRM MPPACT; LDA 0,2; SKA K3S7; SKA X1; BRU TSWAP2
       STX PPG; LDA X4; SKA 0,2; BRU *+2; ADM 0,2
       CXA; BRM SWLSC; MIN SWPCTR
       LDA =PPG+402B5; MIN RAJOB1; DIR; BRM B; EIR
$TSWAP1 EQU * EXIT FOR BUFFERLET PAGE SWAP ONLY
       BRM MPPACT
TSWAP2 SKN T1; BRU TSWAP3
       LDA =SMTP20+402B5; STA RACKSW
       BRM SWLSC (CLEARS B); STB RACKSW
       LDA =SMTP20+402B5; MIN RAJOB1; DIR; BRM B; EIR
TSWAP3 DIR; BRM RAGO; EIR; SKR RAJOB1; NOP
       LDA RAJOB1; SKE ZERO; BRU PACWT; BRU PACGO4

* RETURN HERE WHEN PAGES ARE IN

$TTIO1 BRM RACK; BRU BTTIO1
$TTIO2 BRM RACK; BRU BTTIO2
RACK   ZRO;* POST-SWAP CHECKS.
*      RETURNS IF BUFFERLET AND PROGRAM PAGES MADE IT OK
       BRM PUINIT (ZERO SOME CELLS TO AID CRASH ANALYSIS)
       LDA =65777777B; STA SWLS (STATES 2 AND 4 LEGAL)
       CLEAR; STA PACSW; LDA KM1
       STA PCL; STA RAER1; EOR PG; STA T1
       LDA =SMTP20; BRM SWLSC; BRU RACK2
       SKN T1; BRU RACK1
       LDA =PPG; BRM SWLSC; BRU RACK2
RACK1  LDA SMTP20; ETR K37; RCY 6
       LDA SWLS3; ETR K37; SKN T1; LDA K40; LSH 6; STA CMAP
       BRM RLABEL; BRR RACK

* PHANTOM USER
*
* INITIALIZE PU
PUINIT ZRO; CLA; STA PACPTR; STA PUPAC; STA XPB; STA JOB
       STA PMTJOB; STA UTTY; STA RLTS; LDA XX; STA TIME
       LDA PURRL; CAB; LDX PURRL3; BRM LABEL; BRR PUINIT
*
PUDMS  LDA PUCTR; STA PUCTR1; CLA; STA XPB; EIR; STA PUSW; BRU PACGO
* THIS CHECKS TO SEE IF REAL IS NEG OR ABOUT TO BE.
* IT RUNS EVERY 3 SEC.
PU3SEC BRM PUINIT; LDA REAL; SKA X4; BRM MONCR
       ADD =180; STA PUTIME
       ADD =60*60*60-180; SKA X4; SKN FATIG; BRU PUGO3
       MIN FATIG; LDA =6*2B5; DIR; BRM MPTYM; STA T1
       BRM TRO (SEE BRS159); LDA T1; MLABEL; EIR
       LDA ONE; ADM ALARM
PUGO3  EQU *
       IF DISC<3      TURN POSITION POWER OFF ON DP DISC AFTER 1 MINUTE 
       SKN IDCL1; BRU PUGO3A             OF INACTIVITY
       LDA REAL; SUB =60*60; SKG DREAL; BRU PUGO3A; LDA XX; STA DREAL
       EOM 10226B (POWER OFF)
       ELSE
       LDA     RQ1
       SKE     RQ3             CHECK IF DISC QUEUE EMPTY
       BRU     *+3
       LDA     XX              YES, SET DREAL TO INFINITY
       STA     DREAL
       ENDF
PUGO3A EQU *
       LDX =NPORT-1
PUGO3B LDA KM4; SKA PULIM; SKE WERIS,2; BRU PUGO3C; STX PUTTY
       MIN WERIS,2 (-3 <- -4)
       LDB K2B5; COPY XB,E; LDA TIC1; BRM EPU; LDX PUTTY
PUGO3C CXA; EAX -1,2; SKA ADMSK; BRU PUGO3B
PUGO6  EQU *
       BRM WCLEAN

PUGO4  BRM PUINIT; LDA KM1; STA PUSW
       IF TSTAT
*  UTIME IS THE NUMBER OF USERS TIMES THE TIME SPENT FOR THEM.
       LDA REAL; RSH 6; CAB; SUB LREAL; STB LREAL
       MUL NU; LSH 23; ADM UTIME; ENDF; BRU PUGO5
* P.U. SCHEDULER
* RELEASE PAGES OF LAST PU JOB AND CLEAR PU RELABELING
PUGO   LDA =SETTB; STA TJOB
       LDX PUJOB; LDA PMTP,2; ADD =-NCMEM; STA RELPG3
       LDA X4; STA RELPG8; LDA PURL1; LDB PURL2; LDX PURL3
       BRM RELMEM; CLA; STA PURL1; STA PURL2; STA PURL3
* SCAN FOR P.U. JOBS
PUGO5  LDA PUCTR; DIR; SKG ZERO; BRU PUDMS; EIR; LDX =PUBPTR; STA PUCTR1
PUSCN  STX PUCPTR; LDX 0,2; LDA 1,2; STA PUTST; LRSH 15; ETR K77
       AXC; BRU* PUCLST,2
PUSET  ZRO; LDX PUCPTR; LDX 0,2; LDA 2,2; RSH 12; STA PUPAC
       CLA; LCY 12; STA PUTTY; BRR PUSET
* SET PU RELABELLING BACK
SPURL  ZRO; BRM MPPACT; CLA; STA JOB; STA XPB
       LDA PURRL; CAB; LDX PURRL3; BRM LABEL
       LDA RRL3; ETR K77; STA RLTS; BRR SPURL
NPUGO  BRM SPURL; BRU PUGO
$NPUNXT BRM SPURL
* CAN'T PROCESS THIS ENTRY
PUNXT  LDX* PUCPTR; CXA; SKE PUEPTR; BRU PUSCN
       LDA PUCTR1; DIR; SKE PUCTR; BRU PUGO; BRU PUDMS
* PHANTOM USER ACTIVATION TESTS
PUCLST DATA PUCR1,PURBT,PU124A,PUCR1,PUCR1,PUCR1
       DATA PULO,PUTIM,PUCR1

* TEST PROGRAM INTERRUPT TIME OUT
PUTIM  LDX* PUCPTR; LDA REAL; SKG 2,2; BRU PUNXT
       LDA 3,2; LDB PRMSK; LCY 12; STB PUTIM9 (PACPTR OF FORK)
       CBX; LRSH 12; STA PUTTY
       LDX PTAB,2; XXA; LDX TTYASG,2; EOR PTAB,2; SKA =77B5
       BRU PUTIM1   WE FOUND SOME OLD PUTIM ENTRY FOR ANOTHER JOB
       BRM PUINT; STX PUTIM8 (JOB)
       LDX PUTIM9; LDA PTEST,2; SKE =7B5 (IS FORK DEAD)
       BRU PUTIM2 (NO)
PUTIM1 LDX* PUCPTR; LDA PUDEAD; STA 1,2; BRU PUNXT
PUTIM2 LDA K1B5; SKA PIM,2; BRU *+2; BRU PUACT1; STX T2
       LDA =PURBTA; BRM SCFK; STX PUPAC
       SKN T2; BRM RCJ; BRU PUACT
PUTIM3 LDA K1B5; LDX PUTIM9; BRM IIR; BRU NPUGO
       LDX PUTIM8; LDA K1B5; ADM TTNO,2; SKA TTNO,2; BRU NPUGO; BRM MONCR

PUTIM9 0
PUTIM8 0

* REMOVE EXTRA PU ENTRIES
PULO   BRU PUACT1

* TEST FOR RUBOUT
PURBT  BRM PUSET
       LDA PUPAC; LRSH 3; STA TIPIX; LDX PUTTY; SKG ONE; BRU PURBT2
       SKN TTYASG,2; BRU PURBT3; LDX TTYASG,2; STX T2; BRM PUINT; LDX T2
       LDA PIM,2; SKA K100 (XBRS FORK); BRU PURBT5 (YES)
PURBT4 LDA =PURBTA; BRM SCFK; STX PUPAC
       IF ALOG; DIR; LOGG 23B,PUPAC; LOGG 23B,PUTTY; EIR; ENDF
       SKN T2; BRM RCJ; BRU PUACT
* SETS T2 TO 0 IF ANY FORK IS ON QQC
PURBTA ZRO; LDA PIM,2; SKA X1; BRU PURBT1; COPY XA,AB; SKE QQC
       BRR PURBTA; COPY BA,B; STB T2; BRR PURBTA
PURBT1 MRG X2; STA PIM,2; BRU PUNXT
PURBT5 LDA PPTR,2; MRG PLMSK; CAX (EXAMINE UPPER FORK)
       LDA PIM,2; SKA X1; BRU PURBT1; LDX T2; BRU PURBT4
* BRS 112 OR ON INTERRUPT
PURBT2 SKN TTYASG,2; BRU PUACT1; BRM MONCR
PURBT3 LDA PUDEAD; STA PUTST; BRU PUACT1

PU124A EQU *   USER HAD DISC ERROR. ACTIVATE PU124B IF TTNO COUNT IS -1.
       LDA* PUTST; SKG =-2B5-1; BRU PUNXT  (IO IN PROGRESS)
       BRM PUSET; LDX PUPAC; STX T2; LDA =PURBTA; BRM SCFK; SKN T2
       BRM RCJ; BRU PUACT

PU124B EQU *   INTERRUPT FORK FOR IO ERROR IF INT 11 ARMED.
       LDA K2B5; ADM* PUTST  SET UP TO ACTIVATE AT PACTRP
       LDX PUPAC; LDA K1000; BRM IIR; BRU NPUGO  (UNARMED, CAUSE PACTRP);
       BRU NPUGO  (ARMED. PTEST OP-CODE IS 5. INT 11 WILL BE INVOKED.)

PUINT  0
       LDX PUTTY; LDA TF2,2; CAB; ETR K77; CAX
       LDA =401B5; SKA TTNO,2; BRU PUNXT
       LDA TIPIX; SKB =B113Y+RCY+PUDY; SKG TWO; BRR PUINT; BRU PUNXT

* ILLEGAL PU INDEX
PUCR1  BRM MONCR
* ACTIVATE P.U. REQUEST ROUTINE
PUACT2 BRM PUSET
PUACT  LDX PUPAC; LDA PTAB,2; LRSH 15; ETR K77; STA SWJOB
       STA PUJOB; STA JOB; ADD =ETTB; STA TJOB (COMMENCE CHARGING)
       IF TSTAT; LDA =30B+QTIGO; STA RFR; ENDF
       COPY A,B; LDX =NCMEM
       STA PURL1; STB PURL2; STX PURL3; BRM SWAPR; BRU PUSWER
       BRM LABEL; LDX PUPAC; BRM PGET
PUACT1 EQU *
       LDX PUCPTR; DIR; LDA FPULST; XMA* 0,2
       XMA 0,2; STA FPULST; SKE PUEPTR; BRU *+2; STX PUEPTR
       SKR PUCTR; MIN PULIM; EIR
       LDA PUTST; LRSH 15; ETR K77; CAX; BRU* PUCSET,2
* PHANTOM USER REQUEST PROCESSING PREPARATION
PUCSET ZRO PUCR1; ZRO* PUTST; DATA PU124B,PUCR1,PUCR1,PUCR1
       DATA PUGO,PUTIM3,PUCR1
* ERROR SWAPPING IN PU JOB
PUSWER CLA; STA PURL3 (PAGE ALREADY RELEASED)
       LDX JOB; DIR; LDA TTNO,2; ADD K100; STA TTNO,2
       EIR; SKA K400
       BRU PUER2; BRU NPUNXT
PUER2  LDA =6B5; STA PUTST; BRU PUACT1

* MAKE P. U. ENTRY
* INPUT: A=1,2. B=2,2. X=3,2. LOW 6 BITS OF X=TTY NO.
* OUTPUT: X=PU PTR.
EPU    0
       DIR
       XMA* FPULST; SKR PULIM; BRU *+2; BRM MONCR
       MIN PUCTR; XMA FPULST
       STX PUXSV; CAX; XMA* PUEPTR
       STX PUEPTR; XMA 0,2; STA 1,2; STB 2,2
       XMA PUXSV; STA 3,2; XMA PUXSV
       EIR; BRR EPU
PUXSV  ZRO 0
*
*
FPULST ZRO 0  1ST FREE ENTRY
$PUTTY 0;* TTY BEING PROCESSED BY PHANTOM USER
PUBPTR ZRO 0  PTR. TO 1ST ACTIVE ENTRY. LAST ENTRY POINTS TO PUBPTR
PUCTR  ZRO 0  NO. OF ENTRIES.
PUCTR1 ZRO 0  COUNTER DURING PU PROCESSING.
PUCPTR ZRO 0  IND. PTR. TO ACTIVE ENTRY DURING PU PROCESSING.
PUEPTR ZRO 0  LAST ACTIVE ENTRY.
PUPAC  ZRO 0  PACPTR OF ENTRY BEING PROCESSED BY PU.
PUDEAD 6   0  NULL PU ENTRY
PUTST  ZRO
PULIM  ZRO NPUQ   COUNTS NO. OF PU ENTRIES.
PUPACP ZRO 0   PACPTR FOR PU
$PUSW  ZRO 0;* -1 WHEN IN PU. 0 OTHERWISE.
PURL1  ZRO 0   RELABELING FOR P.U. JOBS
PURL2  ZRO 0
PURL3  ZRO 0
PURRL  DATA 40404040B
PURRL3 DATA 640B
PUTIME ZRO 0   3 SECOND ACTIVATION TIME.
PUJOB  ZRO 0
       IF TSTAT
LREAL  ZRO 0   LAST REAL FOR TIME CALCULATOR
       ENDF
*
*

* GET USER TO CORE
* INPUT: X=PACPTR
PGET   ZRO; STX PUPAC; CLA; STA XPB
       LDA PTAB,2; LRSH 15; ETR K77; STA JOB
       CAX; ADD =ETTB; STA TJOB (SET UP TIME CHARGING)
       LDA PMTP,2; ADD =20000000B-NCMEM; STA PMTJOB (SET UP PMT PTR)
       DIR; LDA TTNO,2; ETR =77776077B; STA TTNO,2; EIR
       ETR K77; STA UTTY (SET UP USER TELETYPE)
       LDA RRL3; ETR K77; STA RLTS; LDX PUPAC
       LDA PTAB,2; SKA X1; BRU *+2; BRU PGET1 (NO TS BLOCK)
       LDA PIM,2; ETR =70B; LRSH 3; MRG X4; STA XPB
       IF ALOG; DIR; LOGG 24B,PGET; LOGG 24B,UTTY; LOGG 24B,JOB; EIR; ENDF
PGET1  BRR PGET
       ZRO 0


*
* SWAPPER
*
* PREPARE TO RUN FORK. STARTS READING PAGES IF NECESSARY.
* INPUT: PSEUDO-RELABELING IN A,B,X
*        JOB NO. IN SWJOB
*        RAJOB PTR. IN SWRAJ
*        0 IN SWPB FOR LOW PRIORITY READ. 
*        X4 IN SWPB FOR HIGH PRIORITY READ.
*   SWPB IS SET TO 0 BEFORE THE SWAPPER EXITS.
* RETURNS: NO SKIP=READ ERROR. A=ERROR COUNT
*          1 SKIP=PAGES ARE IN. REAL REL. IN A,B,X
*          2 SKIP=PAGES ARE NOT IN, BUT ARE COMING.
SWAP   ZRO; IF ALOG; DIR; LOGG 47B,SWAP; EIR; ENDF; STA SWR1; STB SWR2; STX SWR3; BRM UPRL
       LDX SWJOB; LDA PMTP,2; ADD =-NCMEM; STA SWPMT
       CNA; ADD =SMT; STA SWSMT
       LDA =RAJOBE; SUB SWRAJ; CAX; LDA X4; LRSH 0,2; STA SWRAB
       LDA* SWRAJ; STA SWRAI; MIN* SWRAJ
       LDX KM10D; LDA SWJOB; STA BJOB
SWLP1  STX SWIX; LDA SRTE,2; SKE ZERO; BRU *+2; BRU SWLP
       SKG =NCMEM-1; ADD SWSMT; ADD SWPMT
       MRG SWPB; MRG SWRAB; MIN* SWRAJ; DIR; BRM B
       EIR     (SOME PAGES, SUCH AS TS PAGE, MAY BE IN VOID)
*              (STATE TO BEGIN WITH, AND MUST MAKE A TRANSITION)
*              (TO SCQ AND BE CLEARED BEFORE ANOTHER BRING CAN)
*              (BE DONE ON THEM.  THIS EIR PERMITS THE 205 INT.)
*              (TO SNEAK IN.  SEE BRS 44 BRING CODE FOR A MORE)
*              (EFFICIENT METHOD WHICH CAN CRASH THE SYSTEM.)
       LDX SWIX
SWLP   BRX SWLP1; CLA; STA SWPB
       DIR; BRM RAGO; EIR
       SKR* SWRAJ; NOP; LDA* SWRAJ; SKE SWRAI
       BRU SWSK2 (PAGES NOT ALL IN)
       LDA SWRAJ; SUB =RAJOB; CAX; SKN RAER,2; BRU SWSK0
       BRM SWIN; MIN SWAP; BRR SWAP
* READ ERROR
SWSK0  STX SWSK0A; BRM SWREL; LDX SWSK0A; LDA KM1; XMA RAER,2; BRR SWAP
SWSK0A ZRO 0
* PAGES NOT ALL IN
SWSK2  MIN SWAP; MIN SWAP; BRR SWAP
* 
* PAGES ALL IN. PUT REAL REL. IN A,B,X
       IF PTICK
$SWIN14 ZRO 0
       ENDF
SWIN   ZRO; IF PTICK; CLA; STA SWIN14; ENDF; LDX KM10D
SWIN8  LDA SRTE,2; SKE ZERO; BRU SWIN2; LDA K40; STA SRTE,2
SWIN3  BRX SWIN8; BRM PTRL; BRR SWIN
*NON-ZERO PSEUDO-REL ENTRY
* THIS SECTION HAS REDUNDANT CHECKING WHICH SHOULD BE REMOVED
* WHEN SWAPPER AND PAGER ARE DEBUGGED.
SWIN2  STX SWIX; IF PTICK; MIN SWIN14; ENDF
       SKE =NCMEM; MIN SWNCM; SKG =NCMEM-1; ADD SWSMT
       ADD SWPMT; SKN SWNCM; BRU SWIN6; STA SWIN7
       DIR; BRM W; EIR; LDA SWIN7
SWIN6  CAX; LDA 0,2
       ETR =37B+177B5; SKA X1; MRG K40; SKN SWNCM
       BRU SWIN4
* TS BLOCK
       LDB =77B5; SKM K2B5; BRM MONCR; SKA K40; BRM MONCR
       BRU SWIN5
* NOT TS BLOCK
SWIN4  SKR SWNCM; NOP
SWIN13 LDB =75B5; SKM K4B5; BRU *+3; MRG K40 (STATE 4 OR 6); BRU SWIN5
       LDB =77B5; SKM K2B5; BRU SWIN9 (NOT 2)
SWIN5  ETR K77; LDX SWIX; STA SRTE,2; BRU SWIN3
SWIN9  STA SWIN10; SKM =12B5; BRM MONCR; LDX 0,2
SWIN12 LDA 0,2; SKM =12B5; BRU SWIN11; CAX; BRU SWIN12
SWIN11 ETR =37B+77B5; LDB X1; SKB SWIN10; MRG K40
       BRU SWIN13
SWIN10 ZRO 0
SWIN7  ZRO 0

* READ PAGES FOR RUNNING FORK. HANG UNTIL ALL PAGES ARE IN.
* INPUT: PSEUDO-REL IN A,B,X
*        JOB NO. IN SWJOB
* RETURNS: NO SKIP=READ ERROR. A=ERROR COUNT.
*          SKIP=PAGES IN. REAL REL. IN A,B,X
SWAPR  ZRO; STA SWR1; LDA X4; STA SWPB
       LDA =RAJOB3; STA SWRAJ; CLA; STA RAJOB3; LDA SWR1
       BRM SWAP; BRU SWAPR2; BRU SRIN
       IF TSTAT
       MIN SWHNG
       LDA* TJOB; CNA; ADM SWTIM
       ENDF
       LDA* SWRAJ; SKE SWRAI; BRU *-2
       IF TSTAT
       LDA* TJOB; ADM SWTIM
       ENDF
       SKN RAER3; BRU SWAPR2; BRM SWIN
SRIN   MIN SWAPR; BRR SWAPR
SWAPR2 BRM SWREL; LDA KM1; XMA RAER3; BRR SWAPR (READ ERROR)

ANN    EQU -1

* CALLED WHEN ALL PAGES ARE KNOWN TO BE IN CORE AND
* NO BRING IS NEEDED.
* INPUT: PSEUDO-REL IN A,B,X
*        JOB NO. IN SWJOB
* RETURNS: NO SKIP=READ ERROR.  SKIP=REAL REL IN A,B,X
SWAPI  ZRO; STA SWR1; STB SWR2; STX SWR3; BRM UPRL
       LDX SWJOB; LDA PMTP,2; ADD =-NCMEM; STA SWPMT
       CNA; ADD =SMT; STA SWSMT; BRM SWIN
       BRR SWAPI
*
* SWAPPER VARIABLES
SWJOB  ZRO 0   JOB NO.
SWRAJ  ZRO 0   RAJOB POINTER
SWPMT  ZRO 0   PMT POINTER-NCMEM
SWPMTI ZRO 0   PMT POINTER INDEXED
SWSMT  ZRO 0   SMT-PMT
SWRAB  ZRO 0   RAJOB BIT MASK
SWRAI  ZRO 0   INITIAL VALUE OF RAJOB
SWIX   ZRO 0   TEMP STORE FOR SRT IX
SWPB   ZRO 0   HIGH PRIORITY READ SWITCH. X4 FOR HIGH PRIOR. READ.
SRT    BSS 8   STORAGE FOR UPRL
SRT44E BSS 2
SRTE   BSS 0   END OF SRT
SWR1   ZRO 0   RL1 INPUT
SWR2   ZRO 0   RL2 INPUT
SWR3   ZRO 0   RL3 INPUT
SWNCM  DATA -1   SWITCH. -1=NCMEM. 0=NOT NCMEM
SWLS   DATA 64237777B   IN CORE STATE MASK. STATES 2,4,5,6,8,9 IN CORE.
SLPGC  DATA -1   PAGE COUNT FOR SWAPL

RAJOB  ZRO 0
RAJOB1 DATA -1   QTI JOB
RAJOB2 ZRO 0   COMPUTE JOB
RAJOB3 ZRO 0   HANG CALLS
RAJOB4 ZRO 0
RAJOB5 ZRO 0
RAJOB6 ZRO 0
RAJOB7 ZRO 0
RAJOBE BSS 0
RAEROR BSS 0   RAD ERROR CORRESPNDING TABLE.
RAER   DATA -1
RAER1  DATA -1
RAER2  DATA -1
RAER3  DATA -1
RAER4  DATA -1
RAER5  DATA -1
RAER6  DATA -1
RAER7  DATA -1

*
* UNPACK RELABELLING REGISTERS
* INPUT: RELABELING IN A,B,X
* OUTPUT: ALL REGISTERS CLOBBERED
UPRL   ZRO; STB SWT3; LRSH 18; STA SRT
       CLA; LCY 6; STA SRT+1; CLA; LCY 6; STA SRT+2
       CLA; LCY 6; STA SRT+3; LDA SWT3; LRSH 18; STA SRT+4
       CLA; LCY 6; STA SRT+5; CLA; LCY 6; STA SRT+6
       CLA; LCY 6; STA SRT+7; CXA; RSH 6; ETR K77; STA SRT+8
       CLA; LCY 6; STA SRT+9; BRR UPRL
SWT3   ZRO 0
*
* PACK RELABELING IN SRT INTO A,B,X
PTRL   ZRO; LDA SRT+3; LRSH 6; LDA SRT+2; LRSH 6
       LDA SRT+1; LRSH 6; LDA SRT; LRSH 6; STB SWRL1
       LDA SRT+9; LRSH 6; LDA SRT+8; LRSH 18; CBX
       LDA SRT+7; LRSH 6; LDA SRT+6; LRSH 6
       LDA SRT+5; LRSH 6; LDA SRT+4; LRSH 6
       LDA SWRL1; BRR PTRL
SWRL1  ZRO 0
*
*
* SET UP REAL RELABELING. KEEPS PAGE 6 RELABELLING FROM RRL3.
* INPUT: REAL RELABELING IN A,B,X
LABEL  ZRO; STA RRL1; STB RRL2; CXA
       ETR K77; XMA RRL3; ETR =7700B; ADM RRL3
       LRR1; POT RRL1; LRR2; POT RRL2; LRR3; POT RRL3; BRR LABEL

CHREL  ZRO; LDA RL1,2; LDB RL2,2; LDX JOB; STX SWJOB
       LDX =NCMEM; BRR CHREL
*
RRL1  ZRO
RRL2  ZRO
RRL3  ZRO 0   CURRENT CONTENTS OF RR3
RLTS   ZRO     0  TS BLOCK RELABELLING FOR RUNNING FORK
RLPACT DATA 600B    PAC TABLE REAL RELABELLING
RLDSC  DATA 1000B   DISC REAL RELABELLING
RLWB   DATA  700B   W BUFFER DRIVERS REAL RELABELLING
$RLTYM DATA 0600B+TYMPAGE      TYMNET LABELLING
*
*
* ROUTINES TO RELABEL EXTRA MONITOR PAGES.
*
* PAC TABLE RELABELING
MPPACT ZRO; LDA RLPACT; MRG RLTS; STA RRL3
       LRR3; POT RRL3; BRR MPPACT
*
* DISC RELABELING
MPDSC  ZRO; LDA RLDSC; MRG RLTS; STA RRL3
       LRR3; POT RRL3; BRR MPDSC
*      SETUP TYMNET LABELLING
$MPTYM 0; LDA RLTYM; XMA RRL3; LRR3; POT RRL3; BRR MPTYM

* W BUFFER ROUTINE RELABELING
MPWB   ZRO; LDA RLWB; MRG RLTS; STA RRL3
       LRR3; POT RRL3; BRR MPWB

*      CLOCK ROUTINES AND TABLES
*
TIME   ZRO     0   SHORT
TTIME  ZRO     0   LONG
TIME1  ZRO     0               TIME AT START OF FORK
$CLOCK3 DATA -1                SKR CELL FOR INTERRUPT 74
* CLOCK INTRRUPT ROUTINE  AVG. TIME= .047 MS
CLINT  0
$CLINT1 MIN REAL     SOMETIMES BRU CLINTT   (SEE TVDMS)
CLINT4 MIN* TJOB
       IF TSTAT
       SKN CLINT; MIN STIME
       MIN* CJOB
       ENDF
       BPT4
CLINTC BRM MONCR
CLINT2 SKR TTIME; NOP; SKR TIME; BRI CLINT; SKN TTIME
       SKN ACTR; BRU CLOUT; BRI CLINT
CLOUT  BSS 0
       EOM     22400B
       SKR     UMTF
       NOP
       SKN CLINT; BRU CK0I
       BRI CLINT
CK0I   STA SA; LDA* CLINT; ETR =20077777B; SKE =40000B
       BRU OK; LDA =100; STA COUNT; STX SX
       SKN 0; BRU OKX; LDX 0
LPT    LDA 0,6; SKA =40000B; BRU IND; BRU OKX
IND    SKA X2; ADD SX; CAX; SKR COUNT; BRU LPT
       BRI =*+1; TRAP 54
OKX    LDX SX
OK     LDA SA; BRI CLINT
CLINTT EQU *   SEE IF TYMNET OUTPUT RING (TBO) IS EMPTYING.
       MIN CLINTW; STA SA
       LRR3; POT RLTYM; LDA* TROSW; LRR3; POT RRL3
       SKE TFREEC; BRU CLINTU
       LDA KM1; STA TROSW; LDA CLINTU; STA CLINT1; LDA SA; BRU CLINT1
CLINTU MIN REAL; LDA SA; BRU CLINT4
$CLINTV BRU CLINTT
CLINTW 0

SA     ZRO 0
SB     ZRO 0
SX     ZRO 0
COUNT  ZRO 0
*      USER MODE TRANSITION TRAP ROUTINE
*      USED TO DETECT APPROPRIATE TIME FOR
*      DISMISSAL FOR QUANTUM OVERFLOW OR TO
*      REPORT FLOATING OVERFLOW INTERRUPTS
*      TO A USER PROGRAM.
TRAPT  ZRO
       STA     SS01
       STB     SS02
       STX     SS03
       LDA     TRAPT
       STA     0
       SKN     SFPOVI
       BRU     TRAPT2
       COPY    A
       STA     SFPOVI
       LDA     K2B4
       LDX     PACPTR
       BRM     RIIR
TRAPT1 SKR     0
       BRU     *+1
       SKN     UMTF
       BRU     POPX
       EOM     22400B
       BRU     POPX
TRAPT2 SKN     UMTF
       BRU     TRAPT1
       SKN     DNTERM
       BRU     *+2
       BRU     PACQE
       COPY    A
       STA     UMTF
       BRU     TRAPT1
$SFPOVI ZRO    0               FLOATING OVERFLOW FLAG (-1 FOR OF PENDING)
$UMTF  ZRO     0               QUANTUM OVERFLOW FLAG (-1 FOR PENDING)
* (POWER OFF INT. - NOW ILLEGAL)
PWFI   ZRO
       LDX =100075B; BRM STOP;* BRI NOT ISSUED
*
* POWER ON INTERRPUT
PWNI   ZRO; BRU PWFI+1
*
* BRS'S FOR TIMING
*

$B135D BRM MPPACT; LDA =3000; BRU B81B
$B135C 7 PUTIM

$BRS45 LDA =3000      SIMULATE QUANTUM OVERFLOW
$BRS81 MIN 0; SKG =2000; LDA =2000   MINIMUM DISMISS OF 2 SECONDS
B81B   MUL =1727024B; ADD REAL; LDX JOB; STA ACDATA,2
       CXA; ADD B81A; CAB; LDX =QTI; BRU POPDMS
B81A   36B ACDATA

* BRS 22   DO NOT TERMINATE FORK
NTERM  CLA; STA DNTERM; BRU POPX
*
* BRS 23   ALLOW FORK TO TERMINATE
ALTERM LDA KM1; STA DNTERM; SKN TIME; BRU POPX; BRU PACQE
*
*      QUEUE ROUTINES
*
       IF ANN
* CHECK NUMBER OF ITEMS ON QUEUE AGAINST COUNTER
* INPUT: X=QUEUE (QIOQ)
QCK    ZRO; STX QCK5; CLA; STA QCK2
QCK4   SKN PNEXT,2; BRU QCK3; MIN QCK2; LDX PNEXT,2; BRU QCK4
QCK3   LDX QCK5; LDA PNX3,2; SKE QCK2; BRM MONCR; BRR QCK
QCK2   ZRO 0   COUNTER
QCK5   ZRO 0   QUEUE
*
* INPUT: A=PACPTR. X=QUEUE
* OUTPUT: A=PACPTR
QPUT   ZRO; STA QPUT4; STX QPUT5; CXA; SUB =PNEXT; CAX
       BRM QCK; LDA QPUT4; LDX QPUT5
       IF ALOG; DIR; LOGG 36B,LOGX; LOGG 37B,QPUT; EIR; ENDF
       LDB 2,2; MIN 3,2
       COPY AX,BA,XB; XMA PNEXT,2; SKE ZERO; BRM MONCR; COPY BX,XA
       LDB 1,2; STA 1,2
       CBX; STA PNEXT,2
       LDA QPUT5; SUB =PNEXT; CAX; BRM QCK; LDA QPUT4; BRR QPUT
QPUT4  ZRO 0   PACPTR
QPUT5  ZRO 0   QUEUE
*
* INPUT: A=PNEXT OF FORK TO GET, B=QUEUE (QIOQ), X=PREVIOUS PACPTR (QIOQ)
QGET   ZRO; STA QGET2; STB QGET3; STX QGET4; CBX; BRM QCK
       LDB QGET3; LDX QGET4
       LDX PNEXT,2; IF ALOG; DIR; LOGG 40B,LOGX; EIR; ENDF
       STX QGET8
       CLA; XMA PNEXT,2; XMA QGET2; SKE QGET2; BRM MONCR
       LDX QGET4; XXB; SKR PNX3,2; BRU *+2; BRM MONCR; XXB
       IF ALOG; DIR; LOGG 41B,LOGB; LOGG 41B,QGET; EIR; ENDF
       XMA PNEXT,2; STA QGET7; LDA PNEXT,2
       XXB; SKG ZERO; BRM QGET5
       STX QGET6; SUB =PNEXT; SKE QGET6; BRM MONCR
       STB PNXTP1,2; BRM QGET5
QGET5  ZRO; LDX QGET3; BRM QCK; BRR QGET
QGET2  ZRO 0   INPUT A=PNEXT
QGET3  ZRO 0   INPUT B=QUEUE (QIOQ)
QGET4  ZRO 0   INPUT X=PREVIOUS PACPTR (QIOQ)
QGET6  ZRO 0   QUEUE
QGET7  ZRO 0   PEVIOUS PNEXT
QGET8  ZRO 0   PACPTR
       ENDF
*
       IF -ANN
*
* INPUT: A=PACPTR.  X=QUEUE.
* OUTPUT: A=PACPTR
QPUT   ZRO
QPUT3 BSS 0
       IF ALOG; DIR; LOGG 36B,LOGX; LOGG 37B,QPUT; EIR; ENDF
       LDB 2,2; MIN 3,2; XXA
       STB PNEXT,2; XXA; LDB 1,2; STA 1,2
       CBX; STA PNEXT,2; BRR QPUT
       ENDF
*
       IF -ANN
* INPUT: A=PNEXT OF FORK TO GET, B=QUEUE (QIOQ), X=PREVIOUS PACPTR (QIOQ)
QGET   ZRO; XXB; SKR PNX3,2; BRU *+2; BRM MONCR; XXB
       IF ALOG; DIR; LOGG 41B,LOGB; LOGG 41B,QGET; EIR; ENDF
        STA PNEXT,2; XXB; SKG ZERO; BRR QGET; STB PNXTP1,2; BRR QGET
       ENDF
*
* INPUT: A=NEW ACT. COND.  X=PACPTR.
* QSCH CHANGES ACTIVATION CONDITION AND TAKES PAC ENTRY OFF
*   THE QUEUES.
QSCH   ZRO
       STA QSCH1; STX QSCH4
       XMA PTEST,2; EOR =700000B; SKA =7700000B; BRU *+2
       BRR QSCH (OLD ACT. COND. WAS 7. FORK NOT ON QUEUES.)
       LDA PNEXT,2; STA QSCH1; LDA =QTI; STA QSCH6; BRU QSCH5
QSCH2  SKG ZERO; BRU QSCH3
       LDA =QD; ADM QSCH6; LDA QSCH6; SKG =QSQ; BRU QSCH5; BRM MONCR
QSCH5  SUB =PNEXT; CAB
QSCH3  CAX; LDA PNEXT,2; SKE QSCH4; BRU QSCH2
       LDA QSCH1; BRM QGET; LDX QSCH4; BRR QSCH
QSCH1  ZRO 0   ACT. COND./ PNEXT
QSCH4  ZRO 0   PACPTR
QSCH6  ZRO 0
       IF PTICK
* CORE USE METER FOR COMPUTE JOB.
* NPC INPUT, A = NEW PAGE COUNT, X = REMAINING LONG TIME QUANTUM.
* SJB INPUT, A = REMAINING TIME QUANTUM. OUTPUT, A = PAGE*TICKS.
* CALL NPC EVERY TIME NUMBER OF PAGES CHANGE.
* CALL SJB AFTER EVERY COMPUTE JOB TO RESET METER AND GET TOTAL.
$NPC   ZRO; XMA NPCA; STX T2; SUB NPCA; MUL T2; LSH 23
       ADM NPCB
       IF PTICKB
       LDA T2; SKG TRQ; BRU *+2; BRM MONCR; STA TRQ
      ENDF
       BRR NPC
SJB    ZRO; COPY AX,A; BRM NPC
       CLA; XMA NPCB; CNA; LDX JOB; ADM PTCKS,2; ADM SPT
      IF PTICKB
       LDB XX; STB TRQ
      ENDF
       BRR SJB
      IF PTICKB
TRQ    DATA    37777777B
      ENDF
NPCA   ZRO
NPCB   ZRO
       ENDF
* PUT COMPUTE JOB ON QQE AND RELEASE COMPUTE JOB PAGES.
RCJ    ZRO; LDA =QQC; LDB =QQCQ; CBX; BRM QGET
       LDA PACOMP; LDX =QQE; BRM QPUT
       IF PTICK
       LDA CMPST; SKE ZERO; BRU RCJ1
       LDA CMRRL3; XMA RRL3; LRR3; POT RRL3; LDB LQ; STA RRL3
       LRR3; POT RRL3; CBA; BRM SJB
RCJ1   EQU *
       ENDF
       LDX PACOMP; LDA PTAB,2; LRSH 15; ETR K77; STA JOB
       COPY AX,XB; LDA X4; BRM RELPG; CLA; STA PACOMP; STA RAJOB2
       LDA ONE; STA CMPST; BRR RCJ
*
*      INTERRUPT LOGIC
*
* IIR    MAKES ACT. COND. A PROGR. INT. AND PUTS FORK ON QTI
* INPUT: A=INT. MASK.   X=PACPTR.
IIR    ZRO; SKA PIM,2; BRU *+2; BRR IIR
       STA IIR1; STX IIR2; EOR PIM,2; STA PIM,2
       CLEAR; LDA IIR1; NOD 24; CXA; SUB =500000B-2; CNA
       STA IIR4; LDX IIR2; LDA PIM,2; SKA X1; BRR IIR (NON-TERM.)
       LDA PTEST,2; SKE =700004B; BRU IIR3; LDA PPTR,2; RSH 12
       CAX; BRM DFK; BRU IIR5
IIR3   LDA PPTR,2; SKA PLMSK; BRU *+2; BRU IIR5; RSH 12; CAX
       LDB THREE; BRM RFK; LDA =DFK; BRM SCFK
IIR5   LDA IIR4; LDX IIR2; BRM QSCH
       LDX =QTI; LDA IIR2
       BRM QPUT; LDX IIR2; MIN IIR; BRR IIR
IIR1   ZRO 0   INT. MASK
IIR2   ZRO 0   PACPTR
IIR4   ZRO 0   ACT. COND.


* IIR FOR RUNNING FORKS
$RIIR  ZRO; SKA PIM,2; BRU *+2; BRR RIIR; STA IIR1; STX IIR2; EOR PIM,2
       STA PIM,2; CLEAR; LDA IIR1; NOD 24; CXA; ADD TWO; CNA; SKE FIVE
       BRU *+2; BRM MONCR; LDB 0; COPY AX,BA; ETR ADMSK; 
       LDX 200B,6; COPY XA,AB; LDX 0,6; STB 0,6; ETR ADMSK
       ADD X4; STA 0; BRU POPX

*      (TIME UP FLAGS WERE LAST REPLENTISHED)
MUX15 0

*
* MONITOR CRASH
* WHENEVER THE 940 GOES DOWN DIM WRITES ITSELF INTO 100000B
* AND THE BASE WRITES ITSELF INTO 140000B. THEN DIM DUMPS ALL OF
* MEMORY ONTO THE DISC. THE FIRST 16 PAGES GO ON LOC 0,1. DIM GOES
* ON LOC 20 AND THE BASE GOES ON LOC. 24.

$MONCR  ZRO
       SKS 20002B; MIN MCRI; CKF; EOM 20004B (DIR)
       EOD 12000B; PIN T3; SKS* 11026B; MIN RS1; SKS* 11000B; MIN RC1
       EOD 0; EOM 0
       STA MCRA; MIN MCRC
       LDA MCRC; SKE ONE; BRM CRA2
       LDA 0; STA MCR0
       STB MCRB; STX MCRX; LDA MONCR; STA MCRM; LDA MCRA; STA MCRA1
       LDX =-KSAVE; LDA* MCRSE,2; STA MCRSE,2; BRX *-2
       IF DISC=3
*      WAIT FOR DISC QUEUE TO EMPTY BEFORE WRITING OVER MONITOR PGS.
*      (PREVENTS DESTROYING RAW ACCOUNTING AND OTHER FILES)
*      NOTE DIM IS UPDATING RQ2 EVEN THO WE ARE NOT TAKING DISC INTERRUPTS.
       LDA RQ1; SKE RQ2; SKR CRAWT; BRU *+2; BRU *-3
       ENDF
* COPY BLET PAGE TO REAL 27
       LDA CMAP; ETR K37; SKG TEN; BRU MCRR1
       MRG =2700B; STA TA1; LRR3; POT TA1
       LDX =-4000B; LDA 0,2; STA 34000B,2; BRX *-2
*      COPY USER PAGES 0-3 TO PAGES 13,15,16,17 AND TS TO PAGE 14
MCRR1  LDA RLTS; MRG =1400B; STA TA1; LRR3; POT TA1
       LDX =-4000B; LRR2; POT =13151617B
MCR1   LDA RRL1; EOR PURRL
       SKA =77B6; LDB 4000B,6; STB TA1
       SKA =77B4; LDB 10000B,6; STB TA2
       SKA =77B2; LDB 14000B,6; STB TA3
       SKA =77B; LDB 20000B,6; STB TA4
       LDA RLTS; SKA =37B; LDA 0,2; STA 34000B,2
       LDA TA1; STA 24000B,6; LDA TA2; STA 30000B,6
       LDA TA3; STA 34000B,6; LDA TA4; STA 0,6; BRX MCR1
       BRM GMD; BRM GDCC (WRITE BITMAP AND DISC HOLE TABLE TO DISC)
       BRM CRA2
CRA2   ZRO; LDX =100077B; BRM STOP
       IF DISC=3
CRAWT  DATA 41642036B (5 SEC MAX WAIT)
       ENDF

*
*      SYSTEM GOES INTO A LOOP SO THAT OPERATOR CAN TELL AT
*      A GLANCE WHAT THE SITUATION IS.
*
*      BRU . IN 73: OPERATOR ERROR.  SYSTEM WAS IN BRU . AND RUNNING
*              WHEN SYSTEM WAS LOADED INTO CORE BY DIM
*      BRU . IN 75: POWER FAILURE
*      BRU . IN 76: CPU PARITY
*      BRU . IN 77: MONCR

* DELAY KEEPS OP. FROM HITTING START ON DUAL SELECTOR CHANNEL MACHINE
$STOP   ZRO; STX 0,2
       IF DISC=3; SKR STPCNT; BRU *-1; ENDF
       BRU 0,2
       IF DISC=3
STPCNT DATA 11207233B (17 SEC AT 7 MICROSEC/ITERATION)
       ENDF

* BRS 131   EXEC CRASHING SYSTEM BECAUSE OF ERROR.
$CRASH BRM MONCR

* BRS 180   EXEC CRASHING SYSTEM AT NORMAL TAKE DOWN.
$CRSH  MIN 202B; BRM MONCR

$MCRA  ZRO 0
MCRA1  ZRO 0
$MCRB  ZRO 0
$MCRX  ZRO 0
MCR0   ZRO 0
MCRM   ZRO 0   MONCR MARK LOCATION
MCRI   ZRO 0   1 IF ENABLED
MCRC   ZRO 0
RC1    ZRO 0   RAD CHANNEL ERROR ON MONCR
RS1    ZRO 0   RAD ERROR ON MONCR
TA1    ZRO 0
TA2    ZRO 0
TA3    ZRO 0
TA4    ZRO 0
* THE FOLLOWING TABLE CONTAINS FORMER CONTENTS OF CELLS
* WHICH ARE DESTROYED IN PROCESS OF WRITING OUT THE BITMAP.
* THIS LIST MAY BE SHORTENED WHEN DISC CODE IS BUGLESS.
*              DESTROYED BY:
MCRS   0 UPFL
       0 UPFL+1
       0 216B  (BASE CRASH,REINITIALIZE, AND 940 NO LONGER UP)
       0 DRQU
       0 T4    RLABEL
       0 RRL3  RLABEL
       0 RLABEL  GMD
       0 GMD   MONCR.
       0 T     GDC,CKSM,DP2IBM
       IF DISC=3
       0 RQ1A  INCRQ
       0 RQ1   GDCC
       0 RQ2   (DIM)
       ELSE
       0 GDC   MONCR
       0 T1    GDC
       0 T2    GDC
       0 T3    GDC
       0 GDCRW GDC
       0 GDCWC GDC
       ENDF
MCRSE  BSS 0
KSAVE  EQU *-MCRS

*      SET UP BIT MAP FOR WRITING TO DISC. SET UP COMMANDS.
$GMD 0; LDA MAPLBL; BRM RLABEL    (RELABEL MAP IN)
       LDA DBMDA; SKN SDBM8; SKG ZERO; BRU GMD2  (NO MAP IN CORE)
       LDX MAPNUM; LDA DBITS; STA DBITBL,2   (STORE DBITS AWAY IN TABLE)
       IF DISC<3
       LDA =203666B (DISC WRITE EOM)
       STA GDCRW
       ENDF
       LDA DMIN; STA -1; LDA REAL; STA -2  (SAVE DATE AND TIME IN BITMAP)
       LDA MAPNUM; STA -3; LDA BITSUM; STA -4 (SAVE ZONE AND CHECKSUM)
       LDA DBITS; STA -5; LDA 200B; STA -6 (SAVE DBITS AND MACHINE NO)
       IF DISC=3
       LDX =40000060B   (WORD COUNT/40B WITH SIGN BIT ON FOR WRITE)
       ELSE
       LDA =3000B; STA GDCWC
       ENDF
       LDA DBMDA; LDB =45000B
       BRR GMD   (RETURN)
GMD2   MIN GMD; BRR GMD

       IF DISC=3
$GDC   ZRO     0               (GET DISC TO CORE, A=DA, B=CA, X=WC)
       SKG K37; BRM MONCR; XAB
       BRM DTC                 (PUT MAP REQUEST ON DISC QUEUE)
       LDA RQ1A; STA RQ1       (INITIATE I/O - SEE DTS)
       SKE RQ2; BRU *-1        (WAIT FOR I/O TO FINISH)
       BRR GDC                 (RETURN)
$GDCC  ZRO 0   (DISC IO FOR BIT MAP IN MONCR ROUTINE)
       SKG K37; BRM CRA2
       STA* RQ1A (SAVE DISC ADDRESS); CXA; LDX RQ1A
       STB 1,2 (CORE ADDRESS); STA 2,2 (COUNT)
       LDA 0,2; BRM DP2IBM; LDX RQ1A; STA 0,2; BRM CKSM
       EAX RQ1A; BRM INCRQ; STA RQ1
       SKE RQ2; SKR GDCCTR
       BRR GDCC
       BRU *-3 (10.5 USEC PER CHECK)
GDCCTR DATA 41642036B (5 SEC MAX WAIT)
       ENDF

       IF DISC<3
GDCC   BSS 0
$GDC   0;* GET DISC TO CORE. B = CORE ADRS, A = DISC ADRS.
       STB T; STA T1; SKG K37; BRU GDC3  (BAD DISC ADDRESS)
GDC1   LDA T; RSH 14
       LDA GDCWC (WORD COUNT); LCY 14; STA T2
       LSH 19; LDA T; ETR =14B4; CBX
       RSH 14; CXB; LSH 5; MRG =IORDW
       LDB GDCRW; SKB K40; MRG K200; STA T3  (IF WRITE CHANGE TO IOSD)
       SKS 14000B; BRU *-1     (WAIT FOR CHANNEL READY)
       EXU DRT; BRU *-1        (WAIT FOR DISC READY)
       EOM 10026B (ALERT DISC); POT T1
       EOM* 1B4; EXU T3; POT T2
$GDCRW  EOM 2626B   DISC READ OR WRITE
       EXU DRT; BRU *-1; EXU DET; BRU GDC1; EXU DCT; BRU GDC1
       BRR GDC
$GDCWC DATA 2500B
       ENDF

GDC3   EQU *    (BAD DISC ADDRESS GIVEN TO GDC ROUTINE - CRASH)
       LDA KM1; STA SDBM8  (PREVENT BIT MAP FROM BEING WRITTEN TO DISC)
       BRM MONCR

       IF TSTAT
$QTIGO BSS 32 (RAD PAGES BROUGHT BY ACTIVATION NO.)
       ENDF
ENDPAC BSS 0
       FORGET
       END
MONITOR ** FICHE/FRAME BREAK *****
PAC SYMSORT

SYM.  PG.LN. IDENT.

ACTLST 18 22 PAC     ALTERM 33 37 PAC     ANN    28 22 PAC     
B135C  33 25 PAC     B135D  33 24 PAC     B81A   33 31 PAC     B81B   33 29 PAC     
BFL    19 29 PAC     BFLN   19 31 PAC     BIOSCE 11 33 PAC     BIOSCF 11 34 PAC     
BIOST  11 32 PAC     BPORT  19 36 PAC     BRS45  33 27 PAC     BRS81  33 28 PAC     
CAC0   18 25 PAC     CAC1   18 26 PAC     CAC10  19  5 PAC     CAC11  19  6 PAC     
CAC12  19  8 PAC     CAC12  18 35 PAC     CAC2   18 27 PAC     CAC3   18 28 PAC     
CAC4   18 29 PAC     CAC5   18 31 PAC     CAC5A  18 33 PAC     CAC6   18 37 PAC     
CAC6A  19  2 PAC     CAC9   19  4 PAC     CACK   18 24 PAC     CACLST 18 14 PAC     
CHREL  30 23 PAC     CJP    17 12 PAC     CK0I   31 37 PAC     CLINT  31 20 PAC     
CLINT1 31 21 PAC     CLINT2 31 29 PAC     CLINT4 31 22 PAC     CLINTC 31 28 PAC     
CLINTT 32  6 PAC     CLINTU 32 11 PAC     CLINTV 32 12 PAC     CLINTW 32 13 PAC     
CLOCK3 31 18 PAC     CLOUT  31 31 PAC     CMAP   19 33 PAC     CMPGO  15  5 PAC     
CMPGO2 15 14 PAC     CMPIN  14 28 PAC     CMPIN3 14 31 PAC     CMPQT  17 29 PAC     
CMPST  17 21 PAC     CMRRL1 17  8 PAC     CMRRL2 17  9 PAC     CMRRL3 17 10 PAC     
COUNT  32 18 PAC     CRA2   38 30 PAC     CRASH  39 15 PAC     CRAWT  38 32 PAC     
CRSH   39 18 PAC     DMS     4 21 PAC     DMS111  1 34 PAC     ENDPAC 42 10 PAC     
EPU    24 32 PAC     FCJ    13 11 PAC     FCJ2   13 26 PAC     FCJ3   13 27 PAC     
FCJ4   13 28 PAC     FCJ6   13 29 PAC     FCJ7   13 30 PAC     FCJDEL 14 16 PAC     
FPLST  19 19 PAC     FPULST 25  4 PAC     FQJ    11 29 PAC     FQJ    11 27 PAC     
FQJ1   11 39 PAC     FQJ1   11 36 PAC     FQJ10  12  5 PAC     FQJ11  12  6 PAC     
FQJ13  12 22 PAC     FQJ3   12 26 PAC     FQJ3A  12 27 PAC     FQJ3B  12 30 PAC     
FQJ4   12 34 PAC     FQJ5   12 35 PAC     FQJ6   12  2 PAC     FQJ9   12  3 PAC     
GDC    41 25 PAC     GDC    41  5 PAC     GDC1   41 27 PAC     GDC3   42  3 PAC     
GDCC   41 24 PAC     GDCC   41 11 PAC     GDCCTR 41 20 PAC     GDCRW  41 36 PAC     
GDCWC  41 39 PAC     GMD    40 24 PAC     GMD2   41  2 PAC     IIR    37  4 PAC     
IIR1   37 15 PAC     IIR2   37 16 PAC     IIR3   37 10 PAC     IIR4   37 17 PAC     
IIR5   37 12 PAC     IND    32  2 PAC     KSAVE  40 21 PAC     LABEL  30 19 PAC     
LPT    32  1 PAC     LREAL  25 25 PAC     MCR0   39 24 PAC     MCR1   38 20 PAC     
MCRA   39 20 PAC     MCRA1  39 21 PAC     MCRB   39 22 PAC     MCRC   39 27 PAC     
MCRI   39 26 PAC     MCRM   39 25 PAC     MCRR1  38 18 PAC     MCRS   39 38 PAC     
MCRSE  40 20 PAC     MCRX   39 23 PAC     MONCR  37 37 PAC     MPDSC  31  4 PAC     
MPPACT 30 39 PAC     MPTYM  31  7 PAC     MPWB   31 10 PAC     MUX15  37 28 PAC     
NOCOMP 14 15 PAC     NOGO   12 38 PAC     NPC    36  8 PAC     NPCA   36 23 PAC     
NPCB   36 24 PAC     NPOPDS  4 22 PAC     NPOPX   4 10 PAC     NPOPX0  4  8 PAC     
NPOPXB  4  7 PAC     NPUGO  22 18 PAC     NPUNXT 22 19 PAC     NTERM  33 34 PAC     
NULSW  19 37 PAC     NULSW1 20  1 PAC     NXPOP   4  6 PAC     OK     32  5 PAC     
OKX    32  4 PAC     PAC1C   6 25 PAC     PAC1D   6 37 PAC     PAC1E   6 39 PAC     
PAC1F   7  2 PAC     PAC2B   9 24 PAC     PAC9A  10  2 PAC     PACAC2 13  1 PAC     
PACACT 10 28 PAC     PACDEL 13  6 PAC     PACDMB  1 33 PAC     PACDMS 19 12 PAC     
PACG21  8 11 PAC     PACG22  8 14 PAC     PACG51  8 39 PAC     PACG52  9  1 PAC     
PACGO   8  1 PAC     PACGO1  7  9 PAC     PACGO2  8  4 PAC     PACGO4  8 17 PAC     
PACGO5  8 30 PAC     PACGO6  8 19 PAC     PACGO7  8 15 PAC     PACGO8  9 12 PAC     
PACGO9  9 31 PAC     PACGOA  7  7 PAC     PACGOA  7  5 PAC     PACGOM  7 12 PAC     
PACINT 18  1 PAC     PACJOB 17 34 PAC     PACLVL 19 14 PAC     PACOMP 17  6 PAC     
PACOVF  9 15 PAC     PACQ2   1 35 PAC     PACQE   5 15 PAC     PACQM1  5 14 PAC     
PACQT  17 33 PAC     PACQUE 19 13 PAC     PACSRT  9 14 PAC     PACSVR 17 25 PAC     
PACSW  17 30 PAC     PACSWP 17 32 PAC     PACSWQ 17 31 PAC     PACTRP 18 10 PAC     
PACWT  14 22 PAC     PACWT2 14 23 PAC     PACWT3 14 26 PAC     PASS   19 34 PAC     
PCL    19 28 PAC     PDMS2   5 29 PAC     PDMS3   5 31 PAC     PDMS4   5 38 PAC     
PEST   10 24 PAC     PEST10 11  7 PAC     PEST5  10 26 PAC     PEST5A 10 25 PAC     
PEST6  10 29 PAC     PEST7  10 30 PAC     PEST7A 10 31 PAC     PEST8  10 32 PAC     
PEST9  10 33 PAC     PG     19 27 PAC     PG44   17 14 PAC     PGET   25 32 PAC     
PGET1  26  3 PAC     PGSW   17 20 PAC     PI1    18  5 PAC     POPD9   6  9 PAC     
POPDMS  5 19 PAC     POPR    4 25 PAC     POPR3   4 28 PAC     POPR4   5  3 PAC     
POPR5   4 37 PAC     POPR6   5  4 PAC     POPR7   5  1 PAC     POPR8   5  2 PAC     
POPST   6  4 PAC     POPST2  6  5 PAC     POPX    4 12 PAC     POPX0   4  9 PAC     
POPXB   4 13 PAC     PPG    19 26 PAC     PPREV  19 15 PAC     PPTEST 19 16 PAC     
PREPT  19 35 PAC     PTESTS 19 17 PAC     PTRL   30  8 PAC     PU124A 23 28 PAC     
PU124B 23 33 PAC     PU3SEC 21  9 PAC     PUACT  24  8 PAC     PUACT1 24 14 PAC     
PUACT2 24  7 PAC     PUBPTR 25  6 PAC     PUCLST 22 24 PAC     PUCPTR 25  9 PAC     
PUCR1  24  5 PAC     PUCSET 24 20 PAC     PUCTR  25  7 PAC     PUCTR1 25  8 PAC     
PUDEAD 25 12 PAC     PUDMS  21  6 PAC     PUEPTR 25 10 PAC     PUER2  24 27 PAC     
PUGO   22  4 PAC     PUGO3  21 15 PAC     PUGO3A 21 27 PAC     PUGO3B 21 29 PAC     
PUGO3C 21 32 PAC     PUGO4  21 36 PAC     PUGO5  22  9 PAC     PUGO6  21 33 PAC     
PUINIT 21  2 PAC     PUINT  23 38 PAC     PUJOB  25 23 PAC     PULIM  25 14 PAC     
PULO   23  8 PAC     PUNXT  22 21 PAC     PUPAC  25 11 PAC     PUPACP 25 15 PAC     
PURBT  23 11 PAC     PURBT1 23 21 PAC     PURBT2 23 25 PAC     PURBT3 23 26 PAC     
PURBT4 23 15 PAC     PURBT5 23 22 PAC     PURBTA 23 19 PAC     PURL1  25 17 PAC     
PURL2  25 18 PAC     PURL3  25 19 PAC     PURRL  25 20 PAC     PURRL3 25 21 PAC     
PURUN  17 35 PAC     PUSCN  22 10 PAC     PUSET  22 12 PAC     PUSW   25 16 PAC     
PUSWER 24 23 PAC     PUTIM  22 28 PAC     PUTIM1 22 36 PAC     PUTIM2 22 37 PAC     
PUTIM3 23  1 PAC     PUTIM8 23  5 PAC     PUTIM9 23  4 PAC     PUTIME 25 22 PAC     
PUTST  25 13 PAC     PUTTY  25  5 PAC     PUXSV  25  1 PAC     PWFI   33 15 PAC     
PWNI   33 19 PAC     QCK    34  5 PAC     QCK2   34  8 PAC     QCK3   34  7 PAC     
QCK4   34  6 PAC     QCK5   34  9 PAC     QGET   35 20 PAC     QGET   34 25 PAC     
QGET2  34 37 PAC     QGET3  34 38 PAC     QGET4  34 39 PAC     QGET5  34 36 PAC     
QGET6  35  1 PAC     QGET7  35  2 PAC     QGET8  35  3 PAC     QLVL   11 21 PAC     
QPUT   35 10 PAC     QPUT   34 13 PAC     QPUT3  35 11 PAC     QPUT4  34 21 PAC     
QPUT5  34 22 PAC     QQEDMS  5 16 PAC     QSCH   35 28 PAC     QSCH1  35 38 PAC     
QSCH2  35 33 PAC     QSCH3  35 36 PAC     QSCH4  35 39 PAC     QSCH5  35 35 PAC     
QSCH6  36  1 PAC     QT     11 19 PAC     QTE    11 20 PAC     QTEST   5  6 PAC     
QTIGO  42  8 PAC     RACK   20 25 PAC     RACK1  20 34 PAC     RACKSW 20  4 PAC     
RAER   29 25 PAC     RAER1  29 26 PAC     RAER2  29 27 PAC     RAER3  29 28 PAC     
RAER4  29 29 PAC     RAER5  29 30 PAC     RAER6  29 31 PAC     RAER7  29 32 PAC     
RAEROR 29 24 PAC     RAJOB  29 15 PAC     RAJOB1 29 16 PAC     RAJOB2 29 17 PAC     
RAJOB3 29 18 PAC     RAJOB4 29 19 PAC     RAJOB5 29 20 PAC     RAJOB6 29 21 PAC     
RAJOB7 29 22 PAC     RAJOBE 29 23 PAC     RC1    39 28 PAC     RCJ    36 27 PAC     
RCJ1   36 33 PAC     RELMEM 16 31 PAC     RELPG  16 25 PAC     RELPG2 16 38 PAC     
RELPG3 16 37 PAC     RELPG4 16 32 PAC     RELPG5 16 35 PAC     RELPG6 16 36 PAC     
RELPG7 16 34 PAC     RELPG8 16 39 PAC     RIIR   37 21 PAC     RLDSC  30 31 PAC     
RLPACT 30 30 PAC     RLTS   30 29 PAC     RLTYM  30 33 PAC     RLWB   30 32 PAC     
RRL1   30 26 PAC     RRL2   30 27 PAC     RRL3   30 28 PAC     RS1    39 29 PAC     
SA     32 15 PAC     SB     32 16 PAC     SCAN   10 19 PAC     SCHLP  17 16 PAC     
SETREL 15 34 PAC     SETSWP 16 17 PAC     SFPOVI 33 12 PAC     SJB    36 14 PAC     
SLPGC  29 13 PAC     SNOP   19 20 PAC     SNTRP  19 21 PAC     SPR    17 24 PAC     
SPURL  22 15 PAC     SRIN   28 19 PAC     SRT    29  5 PAC     SRT44E 29  6 PAC     
SRTE   29  7 PAC     STAT5  11 10 PAC     STAT6  11 13 PAC     STATE  19 32 PAC     
STCMRL 15  2 PAC     STOP   39  7 PAC     STPCNT 39 11 PAC     STSTAT 10  5 PAC     
STT     5 34 PAC     STT20  13 19 PAC     STT21  13 20 PAC     STT22  13 21 PAC     
STT23  13 22 PAC     STT24  13 23 PAC     SWAP   26 20 PAC     SWAPI  28 29 PAC     
SWAPR  28  7 PAC     SWAPR2 28 20 PAC     SWIN   27 13 PAC     SWIN10 27 38 PAC     
SWIN11 27 36 PAC     SWIN12 27 35 PAC     SWIN13 27 31 PAC     SWIN14 27 11 PAC     
SWIN2  27 19 PAC     SWIN3  27 15 PAC     SWIN4  27 30 PAC     SWIN5  27 33 PAC     
SWIN6  27 23 PAC     SWIN7  27 39 PAC     SWIN8  27 14 PAC     SWIN9  27 34 PAC     
SWIX   29  3 PAC     SWJOB  28 35 PAC     SWLP   26 36 PAC     SWLP1  26 26 PAC     
SWLS   29 12 PAC     SWNCM  29 11 PAC     SWPB   29  4 PAC     SWPCTR 20  3 PAC     
SWPMT  28 37 PAC     SWPMTI 28 38 PAC     SWR1   29  8 PAC     SWR2   29  9 PAC     
SWR3   29 10 PAC     SWRAB  29  1 PAC     SWRAI  29  2 PAC     SWRAJ  28 36 PAC     
SWREL  16  2 PAC     SWRL1  30 14 PAC     SWRL10 16 14 PAC     SWRL3  16 13 PAC     
SWRL4  16 10 PAC     SWRL6  16 11 PAC     SWRL7  16  5 PAC     SWRL8  16  7 PAC     
SWRL9  16  9 PAC     SWSK0  27  4 PAC     SWSK0A 27  5 PAC     SWSK2  27  7 PAC     
SWSMT  28 39 PAC     SWT3   30  5 PAC     SX     32 17 PAC     TA1    39 30 PAC     
TA2    39 31 PAC     TA3    39 32 PAC     TA4    39 33 PAC     TFC03   9 39 PAC     
TFC04  10  1 PAC     TIME   31 15 PAC     TIME1  31 17 PAC     TRAPT  32 24 PAC     
TRAPT1 32 37 PAC     TRAPT2 33  4 PAC     TRQ    36 21 PAC     TSWAP  20  7 PAC     
TSWAP1 20 12 PAC     TSWAP2 20 14 PAC     TSWAP3 20 18 PAC     TTIME  31 16 PAC     
TTIO1  20 23 PAC     TTIO2  20 24 PAC     TTSW   20  5 PAC     UMTF   33 13 PAC     
UPRL   29 38 PAC     WHOQ   17 27 PAC     WHOQ2  17 28 PAC     XPOP    4 15 PAC     
XPOPX   4 14 PAC     
MONITOR ** FICHE/FRAME BREAK *****
RUP
RUP    IDENT   04/13/76

       LISTM
* STRING AND FLOATING POINT SYSPOPS  7/30/66

SCIT   OPD     134B5
SWCI   OPD     157B5           SYSPOPS WITH BIT 0 REMOVED ...
SCIO   OPD     161B5              ... FOR USE BY SYSTEM MODE ROUTINES
SBRS   OPD     173B5        
SSKSE  OPD     163B5
UGCI   MACRO   A
       EAX     A(1)
       BRM     GCU
       ENDM







*              USAGE COUNTERS FOR ARITHMETIC POPS
* UTILITY BRS'S (33,34,35,37)


*      BRS 33

$GETSTR STB     GSIN1
       STX     GSIN3
       ETR     =40037777B
       CAX
       LDB     1,6
       SKA     K4B7
       STB     0,6
       EAX     0,6
       STX     GSIN2
       BRU     GSIN5
GSIN4  SWCI*   GSIN2
       BRM RUPDMS
GSIN5  SCIO    GSIN3
       SKE     GSIN1
       BRU     GSIN4
       LDA     0,6
       LDB     1,6
       LDX     GSIN3
       BRU     EPOPX



*      BRS 34

$OUTMSG STB    STRO3
       MUL     THREE
       LSH     23
       SUB     ONE
       SKN     STRO3
       BRU     TYM2            NOT SPECIAL MODE
       LDB     =137777B
       BRU     STRO6
TYM2   CAB
       ADD     STRO3
       XAB
       BRU     STRO6


*      BRS 35

$OUTSTR ADD    ZERO              CLEAR X\0
       STX     STRO3
STRO6  ADD     ZERO              CLEAR X\0
        STX     STRO1
       ETR     K1S5
       STA     STRO2
       CBA
       ETR     K1S5
       STA     STRO21
STRO4  UGCI    STRO2
       BRU     STRO8
       SKN     STRO3
       BRU     STRO7
       SKE     K17
       BRU     STRO5
STRO8  LDX     STRO1
       BRU     EPOPX
STRO5  SKE     FOUR
       BRU     STRO7
       LDA     =155B
STRO7  SKG     K137
       BRU     STRO7A
       SKE     =147B           BELL
       BRU     *+2
       BRU     STRO7A
       SKE     =155B
       BRU     *+2
       BRU     STRO7A
       SKE     =152B
       BRU     *+2
       BRU     STRO7A
       SKN     UEXFLG
       BRU     STRO4
       CAB
       LDA     SIX              AMPERSAND
       SCIO    STRO1
       CBA
       SUB     K100
STRO7A SCIO    STRO1
       BRM RUPDMS
       BRU     STRO4

RUPDMS 0;* DISMISS FOR QUANTUM EXCEEDED.  MUST FOLLOW SYSTEM MODE POP
       SKN TIME; BRR RUPDMS
       SKN TTIME; SKN ACTR; BRU PACQM1 (DOES MIN 0)
       BRR RUPDMS





*930 STRING PROCESSING SYSTEM. MANUAL IS DOCUMENT NUMBER 30.10.20


*WRITE CHARACTER AND INCREMENT. THE POP ADDRESSES A STRING POINTER, AND
*THE CHARACTER IN A IS WRITTEN ONTO THE END OF THE SPECIFIED STRING.
*THE SECOND POINTER IS INCREASED BY ONE, SO THAT THE POINTER NOW
*POINTS TO THE NEW STRING. X AND A ARE PRESERVED, B DESTROYED.
WCI    POPD    157B5
$WCIP  BSS     0
WCI1   ETR     K377
       STB WCH3
       STA WCH1                SAVE CHARACTER TO BE WRITTEN
       STX WCH2                SAVE X REGISTER
       EAX* 0                  GET EFFECTIVE ADDRESS OF POP
       MIN 1,6                 INCREMENT SECOND WORD OF STRING POINTER
       LDA 1,6                 AND PICK IT UP.
       BRU WCH5                GO TO WCH CODE, WHICH IS IDENTICAL FROM
*WRITE CHARACTER AND DECREMENT: DECR. 1ST PTR.
*AND WRITE CHAR. ON BEGINNING OF STRING
WCD    POPD    135B5
$WCDP  BSS     0
WCD1   ETR K377
       STB WCH3
       STA WCH1
       STX WCH2
       EAX* 0
       LDA 0,6; SKR 0,6; NOP
       BRU WCH5
*                               THIS POINT ON.
*STORE POINTER. THE A AND B REGISTERS ARE STORED IN THE WORD ADDRESSED
*BY THE POP AND THE NEXT WORD
STP POPD 167B5
$STPP  STX STP1                SAVE INDEX REGISTER
       EAX* 0                  GET EFFECTIVE ADDRESS
       STA 0,6                 DO THE
       STB 1,6                 STORE
       LDX STP1                RESTORE X
       BRR 0                   RETURN
*LOAD POINTER. THE A AND B REGISTERS ARE LOADED FROM THE WORD ADDRESSED BY THE P
*ANF THE NEXT WORD.
LDP POPD 166B5
$LDPP  CXA; EAX* 0; LDB 1,6; LDX 0,6; XXA; BRR 0


*      GET CHARACTER AND DECREMENT
*   TRANSFER CHAR. FROM OPERAND STRING TO A REGISTER. DECREMENT END-STR. PTR.

GCD    POPD    137B5
$GCDP  BSS     0
GCD1   STB GCI4
       STX     GCI1
       EAX*    0
       LDA     1,6
       SKG     0,6
       BRU     GCI3
       SKR     1,6
       BRU     GCI8

*GET CHARACTER AND INCREMENT. THE POP ADDRESSES A STRING POINTER. IF THE
*FIRST WORD OF THE POINTER IS+=OR= TO THE SECOND, IT RETURNS WITHOUT
*      SKIPPING. OTHERWISE, IT SKIPS AND RETURNS WITH THE FIRST
*      CHARACTER OF THE STRING IN A AFTER INCRIMENTING THE FIRST POINTER
*      BY 1. X IS PRESERVED, B DESTROYED.
GCI    POPD 165B5
$GCIP  BSS     0
GCI77  STB GCI4
       STX GCI1                SAVE X
       EAX* 0                  YES. DON'T HAVE TO WORRY ABOUT WHETHER
*                              ADDRESS IS RELABLED. GET IT
GCI9   MIN 0,6                 INCREMENT POINTER
       LDA 0,6                 AND GET IT
       SKG 1,6                 IS STRING NULL (1ST POINTER +== END)
       BRU GCI8                NO
       SKR 0,6                 YES. RESTORE POINTER
       NOP 0                   ALLOW FOR POSSIBLE SKIP
GCI3   LDX GCI1                RESTORE X
       LDB GCI4
       BRR 0                   AND RETURN WITHOUT SKIPPING
GCI8  MIN 0                    INCREMENT RETURN ADDRESS FOR SKIP ON RETURN
       MUL =12525253B          MULTIPLY CHARACTER ADDRESS BY 1/3. THIS
*                              LEAVES WORD ADDRESS IN A, CHARACTER
*                              ADDRESS IN TOP TWO BITS OF B.
       RCH     412B            CAX + BAC. WORD ADDRESS TO X
       LCY     2               MOVE CHARACTER ADDRESS TO BOTTOM OF B
       LDA     0,6             GET WORD
       RCH     24B             CBX + CAB
       EXU GCI2,2              SHIFT TO GET CHARACTER IN BOTTOM OF A
       ETR K377               REMOVE SUPERFLUOUS BITS
       LDX GCI1                RESTORE X
       LDB GCI4
       BRR 0                   AND RETURN
GCI2   LCY 8                   SHIFT TABLE FOR EXTRACTING A CHARACTER
       LCY 16                  FROM A WORD
       CBA
       BRM TRAP
* GCI WITH POINTER IN T.S. BLOCK
GCU    ZRO
       LDA GCU
       STA 0
       MIN 0,2
       LDA 0,2
       SKG 1,2
       BRU GCI8
       SKR 0,2
       NOP
       BRR GCU
*WRITE CHARACTER ON THE END OF STRING STORAGE. THIS IS THE ONLY POP WHICH
*      CAN CAUSE A GARBAGE COLLECTION. IT EXPECTS THE ADDRESS OF THE
*      PARAMETER TABLE IN X AND THE CHARACTER TO BE WRITTEN IN A AND
*      RESTORES BOTH. B IS DESTROYED.
WCH POPD 164B5
$WCHP  BSS     0
WCH77  STB WCH3
       ETR     K377
       STA WCH1                SAVE CHARACTER
       STX WCH2                AND INDEX (ADDRESS OF PARAMETER TABLE)
       EAX* 0
       MIN 0,6                 INCREMENT CURRENT LAST CHARACTER TO GET
*                                CHARACTER ADDRESS FOR THE NEXT CHARACTER
       LDA 0,6                 GET THE ADDRESS TO A
       SKE 1,6                 IS IT EQUAL TO LAST ADDRESS IN STRING
*                              STORAGE$$
       BRU WCH5
       LDA KM1
       ADM 0,6
       EAX 2,6; CXA; ETR =40037777B; STA T; LDX WCH2; LDA WCH1
       LDB 0; BRU* T
WCH5   MUL =12525253B          COMPUTE WORD AND CHARACTER ADDRESSES
*                                 SEE GCI CODE
       CAX                     SAVE WORD ADDRESS
       LCY     5               CHARACTER ADDRESS SHIFTED 3 IN AC
       ETR K30                REMOVE EXTRANEOUS BITS
       LDB     0,6             PICK UP WORD
       XXA                     SHIFT COUNT TO X
       LCY 8,2                 SHIFT IT TO PUT CHARACTER TO BE ALTERED
*                                 AT BOTTOM
       ETR =77777400B          MASK OUT THIS CHARACTER
       MRG WCH1                AND INSERT THE NEW ONE
       RCY 8,2                 SHIFT WORD BACK
       CAX                     RESTORE WORD ADDRESS
       STB     0,6             STORE WORD
       LDA     WCH1            RESTORE A
       LDX WCH2                AND X
       LDB WCH3
       BRR 0                   AND RETURN
*SKIP ON STRING EQUAL. THIS POP COMPARES THE STRINGS WITH POINTERS IN
*      AB AND IN THE TWO WORDS ADDRESSED BY THE POP. IT  IS
*      EXACTLY IDENTICAL TO THE MACHINE COMMAND SKE. ALL REGISTERS ARE
*      PRESERVED. THIS POP CHECKS FOR EQUAL LENGTH STRINGS FIRST
*      RETURNING WITHOUT A SKIP IF THE STRINGS ARE NOT EQUAL. IF THEY
*      ARE, IT CALLS SKCO TO FIND OUT ABOUT EQUALITY OF THIER CONTENTS
SKSE POPD 163B5
$SKSEP BSS     0
       STA SKS1
       STB SKS1+1
       STA SKS5                SAVE TWO COPIES
       STB SKS5+1              OF FIRST STRING POINTER
       STX SKS2                SAVE X
       SUB SKS1+1              COMPUTE
       STA SKS6                AND SAVE LENGTH
       EAX* 0                  GET ADDRESS OF SECOND STRING POINTER
       LDA 0,6                 COMPUTE
       SUB 1,6                 ITS LENGTH
       SKE SKS6                AND COMPARE WITH FIRST
       BRU *+2                 NOT EQUAL
       BRU SKSE2               EQUAL
       LDX SKS2                NOT EQUAL. RESTORE X,
       LDA SKS5                A AND
       LDB SKS5+1              B
       BRR 0                   AND RETURN WITHOUT SKIPPING
SKSE2  LDB 1,6                 LENGTH EQUAL. PICK UP SECOND
       LDA     0,6             STRING POINTER
       LDX     SKS2            AND ORIGINAL X
       BRM SKCO                COMPARE STRING IN AB WITH THE ONE IN SKS1
       BRU *+2                 AB LESS
       MIN 0                EQUAL. INCREMENT RETURN ADDRESS FOR SKIP
SKSE1  LDA SKS5                GREATER. RESTORE A
       LDB SKS5+1              AND B
       BRR 0                AND RETURN
*SKIP ON STRING GREATER. THIS POP IS TO SKG AS SKSE IS TO SKE. IT CALLS
*      SKCO IMMEDIATELY WITHOUT COMPUTING LENGTHS
SKSG POPD 162B5
$SKSGP BSS     0
       STA SKS1                SAVE
       STB SKS1+1              TWO COPIES
       STA SKS5                OF FIRST STRING.
       STB SKS5+1
       STX SKS6                SAVE X
       EAX* 0                    GET
       LDA 0,6                 SECOND STRING
       LDB 1,6                 POINTER
       LDX SKS6                RESTORE X
       BRM SKCO                DO COMPARISON
       MIN 0                SECOND STRING LESS, I.E. FIRST GREATER($.)
*                                 INCREMENT RETURN ADDRESS FOR SKIP
       NOP 0                   EQUAL
       LDA SKS5                FIRST LESS. RESTORE A
       LDB SKS5+1              AND B
       BRR 0                AND RETURN
*THIS ROUTINE COMPARES THE STRINGS IN AB (FIRST STRING) AND IN SKS1
*      (SECOND STRING). IT RETURNS WITHOUT SKIPPING IF THE FIRST IS
*      LESS, SKIPS ONCE IF THEY ARE EQUAL, AND SKIPS TWICE IF THE FIRST
*      IS GREATER. NOTE THAT SEVERAL OF THE NECESSARY GCI'S ARE WRITTEN
*      OUT INSTEAD OF BEING CALLS ON THE POP.
SKCO ZRO 0
       STA SKS4                SAVE FIRST
       STB SKS4+1              STRING POINTER
       ADD K2000; SKG SKS4+1; BRM TRAP;* ANTI HOG MEASURE.
       STX SKS7                AND X
SKCO1 MIN SKS1                 BEGIN LOOP. GET A CHARACTER
       LDA SKS1                FROM SECOND STRING
       SKG SKS1+1              (IS IT NULL$$
       BRU SKCO4               NO
SKCO2 MIN SKCO                 YES.) FIRST STRING CANNOT BE LESS, SO
*                                 INCREMENT RETURN ADDRESS
       MIN     SKS4            IS FIRST STRING NULL
       LDA     SKS4
       SKG     SKS4+1
       MIN     SKCO            NO. THEREFORE IT IS GREATER
       BRU     SKCO5           RETURN
SKCO4  MUL =12525253B          SECOND STRING NOT NULL. GET CHARACTER
       RCH 401B                AS
       LRSH 22                 IN
       LDA 0,6                 GCI
       RCH 24B                 CODE
       EXU GCI2,2              ABOVE
       ETR K377
       STA SKS3                GOT IT
       MIN SKS4                TRY TO GET CHARACTER
       LDA SKS4                FROM FIRST STRING
       SKG SKS4+1              IS IT NULL$$
       BRU *+2                 NO
       BRU SKCO5               YES SO IT MUST BE LESS. RETURN WITHOUT
*                                 SKIPPING
       MUL =12525253B          NOT NULL. GET
       RCH 401B                CHARACTER
       LRSH 22                 AS
       LDA 0,6                 IN
       RCH 24B                 GCI
       EXU GCI2,2              CODE
       ETR K377               ABOVE
       SKE SKS3                AND COMPARE WITH CHARACTER OF 2ND STRING
       BRU SKCO3               NOT UAL
       BRU SKCO1               EQUAL. LOOP
SKCO3 SKG SKS3                 COMPARE FURTHER
       BRU SKCO5               LESS. RETURN WITOUT SKIPPING
       MIN SKCO                GREATER SKIP
       MIN SKCO                TWICE
SKCO5  LDX SKS7                RETURN POINT. RESTORE X
       BRR SKCO                AND RETUR


STP1   ZRO     0
GCI1   ZRO     0
GCI4   ZRO     0
GCI7   ZRO     0
WCH1   ZRO     0
WCH2   ZRO     0
WCH3   ZRO     0
SKS1   BSS     2
SKS2   ZRO     0
SKS3   ZRO     0
SKS4   BSS     2
SKS5   BSS     2
SKS6   ZRO     0
SKS7   ZRO     0
SCH1   BSS     2
SCH5   BSS     2
SCH4   ZRO     0
SCH9   ZRO     0
SCH10  ZRO     0               MASK FOR FIRST 3 CHARACTERS OF STRING
SCH11  ZRO     0               MASK FOR LAST 3 CHARACTERS OF STRING
SCH20  ZRO     0               STARTING LOCATION FOR SCAN OF HAST TABLE
SCH52  ZRO     0               FLAG IS -1 IF NO -1 ENTRY HAS BEEN
*                                 ENCOUNTERED DURING SCH SCAN, THE INDEX
*                                 OF THE FIRST SUCH ENTRY ENCOUNTERED
*                                 OTHERWISE
*
*      HARDWARE FLOATING POINT ROUTINES
*
*      MOST SYSPOPS HAVE TWO ENTRIES:
*      1. NORMAL ENTRY
*      2. FORTRAN II ENTRY WHICH DOUBLES THE INDEX REGISTER
*
*      ALL ROUTINES CLOBBER THE A AND B REGISTERS FOR MAXIMUM SPEED
*      X REGISTER IS PRESERVED
*
*      LDFM - FLOATING LOAD FROM MEMORY  (527B5)
$LDFME COPY    XB
       IF      FPH
$LDFME1 EAX*   0
       HFLD    (0,6),(1,6)
       COPY    BX
       BRR     0
       ELSE
$LDFME1 STB    SS03
       EAX*    0
       LDA     0,6
       LDB     1,6
       LDX     SS03
       BRU     SFPEX1
       ENDF

$LDFMEF COPY   XB,A          (516B5)
       LSH     1
       COPY    XB,BX
       BRU     LDFME1



*      LDFL - LOAD FLOATING FROM AB REGISTERS (BRS 118)
       IF      FPH
$LDFLE HFLD    SS01,SS02
       BRU     XPOPX
       ELSE
$LDFLE LDX     SS03
       BRU     SFPEX1
       ENDF


*      STFM - FLOATING STORE INTO MEMORY (530B5)
$STFME COPY    XB
       IF      FPH
$STFME1 EAX*   0
       HFST    (0,6),(1,6)
       COPY    BX
STFME2 BRR     0
       ELSE
$STFME1 STB     SS03
       LDA     FAC1
       LDB     FAC2
       EAX*    0
       STA     0,6
       STB     1,6
       BRU     XPOPX
       ENDF
$STFMEF COPY   XB,A          (517B5)
       LSH     1
       COPY    XB,BX
       BRU     STFME1


*      STFL - FLOATING STORE INTO AB REGISTERS (BRS 119)
       IF      FPH
$STFLE HFST    SS01,SS02
STFLE2 BRU     POPX
       ELSE
$STFLE LDA     FAC1
       LDB     FAC2
       BRU     XPOPX
       ENDF


*      FFAD - FLOATING ADD (552B5)
$FFADE COPY    XB
       IF      FPH
$FFADE1 EAX*   0
       HFAD    (0,6),(1,6)
       COPY    BX
       BRR     0
       ELSE
$FFADE1 BRM    SFSTUP
       BRU     FADE
       ENDF
$FFADEF COPY   XB,A          (520B5)
       LSH     1
       COPY    BX,XB
       BRU     FFADE1



*      FFMP - FLOATING MULTIPLY (572B5)
$FFMPE COPY    XB
       IF      FPH
$FFMPE1 EAX*   0             (BRU SFFMPE)
       HFMP    (0,6),(1,6)
       COPY    BX
       BRR     0
       ELSE
$FFMPE1 BRM    SFSTUP
       BRU     FMPE
       ENDF
$FFMPEF COPY   XB,A          (521B5)
       LSH     1
       COPY    XB,BX
       BRU     FFMPE1



*      FFDV - FLOATING DIVIDE (546B5)
$FFDVE COPY    XB
       IF      FPH
$FFDVE1 EAX*   0
       HFDV    (0,6),(1,6)
       COPY    BX
       BRR     0
       ELSE
$FFDVE1 BRM    SFSTUP
       BRU     FDVE
       ENDF
$FFDVEF COPY   XB,A          (522B5)
       LSH     1
       COPY    XB,BX
       BRU     FFDVE1



*      FFDI - FLOATING INVERSE DIVIDE (547B5)
$FFDIE COPY    XB
       IF      FPH
$FFDIE1 EAX*   0
       HFDVI   (0,6),(1,6)
       COPY    BX
       BRR     0
       ELSE
$FFDIE1 BRM    SFSTUP
       XMA     ARG1
       COPY    AB,BA
       XMA     ARG2
       COPY    AB,BA
       BRU     FDVE
       ENDF
$FFDIEF COPY   XB,A          (515B5)
       LSH     1
       COPY    XB,BX
       BRU     FFDIE1



*      FFSB - FLOATING SUBTRACT (542B5)
$FFSBE COPY    XB
       IF      FPH
$FFSBE1 EAX*   0
       HFSB    (0,6),(1,6)
       COPY    BX
       BRR     0
       ELSE
$FFSBE1 BRM    SFSTUP
       BRU     FSBE
       ENDF
$FFSBEF COPY   XB,A          (523B5)
       LSH     1
       COPY    XB,BX
       BRU     FFSBE1



*      FFSI - FLOATING SUBTRACT INVERSE (543B5)
$FFSIE COPY    XB
       IF      FPH
$FFSIE1 EAX*   0
       HFSBI   (0,6),(1,6)
       COPY    BX
       BRR     0
       ELSE
$FFSIE1 BRM    SFSTUP
       XMA     ARG1
       COPY    AB,BA
       XMA     ARG2
       COPY    AB,BA
       BRU     FSBE
       ENDF

$FFSIEF COPY   XB,A          (524B5)
       LSH     1
       COPY    XB,BX
       BRU     FFSIE1


*      SKFN - SKIP IF FLOATING AC NEGATIVE (BRS 82)
       IF      FPH
$SKFNE SHFAN
       BRU     XPOPX
       MIN     0
       BRU     XPOPX
       ELSE
$SKFNE SKN     FAC1
       BRU     XPOPX
       MIN     0
       BRU     XPOPX
       ENDF

*      SKFZ - SKIP IF FLOATING AC ZERO (BRS 83)
       IF      FPH
$SKFZE HFST    SS01,SS02
       LDA     SS01
       LDB     SS02
       ELSE
$SKFZE LDA     FAC1
       LDB     FAC2
       ENDF
       SKE     ZERO
       BRU     XPOPX
       MIN     0
       BRU     XPOPX


*      SKFUZ - SKIP IF FLOATING AC NON-ZERO (BRS 84)
       IF      FPH
$SKFUZE HFST   SS01,SS02
       LDA     SS01
       LDB     SS02
       ELSE
$SKFUZE LDA    FAC1
       LDB     FAC2
       ENDF
       SKE     ZERO
       MIN     0
       BRU     XPOPX



*      FFNA - NEGATE FLOATING AC (BRS 148)
       IF      FPH
$FFNAE HFMP    FMIN1,FMIN1+1
       BRU     XPOPX
FMIN1  DATA    4B7,0
       ELSE
$FFNAE LDA     FAC1
       LDB     FAC2
       BRM     FNA
       BRU     SFPEX
       ENDF

*      FFIX - FIX FLOATING ACCUMULATOR TO A (BRS 149)
       IF      FPH
$FFIXE HFST    SS01,SS02
       LDA     SS01
       LDB     SS02
       BRU     FFIX
       ELSE
$FFIXE LDA     FAC1
       LDB     FAC2
       BRU     FFIX
       ENDF

*      FFLT - FLOAT A TO FLOATING AC (BRS 150)
       IF      FPH
$FFLTE LDB     K27
       STB     SS02
       HFLD    SS01,SS02
       BRU     XPOPX
       ELSE
$FFLTE CLB
       SKE     ZERO
       BRU     *+2
       BRU     *+4
       LDX     K27
       NOD     48
       LDE
       LDX     SS03
       BRU     SFPEX1
       ENDF



       IF      -FPH
*      STORAGE AND EXITS FOR SIMULATED ROUTINES
$SFPFG DATA    -1            -1 IF SIMULATING NEW SYSPOPS
$ARG1  ZRO     0             ARGUMENT FOR FP SOFTWARE ROUTINES
$ARG2  ZRO     0

$SFPEX SKN     SFPFG
       BRU     SFPEX2
SFPEX1 STA     FAC1
       STB     FAC2
       BRR     0
SFPEX2 SKR     SFPFG
       BRU     *+1
       BRR     0

SFSTUP ZRO     0
       STB     SS03
       EAX*    0
       LDA     0,6
       STA     ARG1
       LDB     1,6
       STB     ARG2
       LDA     FAC1
       LDB     FAC2
       BRR     SFSTUP

IFSTUP ZRO     0
       MIN     SFPFG
       STX     SS03
       STA     SS01
       EAX*    0
       LDA     0,6
       STA     ARG1
       LDA     1,6
       STA     ARG2
       LDA     SS01
       BRR     IFSTUP
       ENDF


*      ROUTINES FOR PERFORMING STANDARD FLOATING SYSPOPS
*      WITH THE FLOATING POINT HARDWARE
*
       IF      FPH
$HFADE STX     SS03
       EAX*    0
       SKE     ZERO
       BRU     HFAD1
       LDA     0,6
       LDB     1,6
       BRU     XPOPX
HFAD1  STA     SS01
       STB     SS02
       HFLD    SS01,SS02     LOAD FA FROM CURRENT AB REGS
       HFAD    (0,6),(1,6)   ADD IN THE OPERAND
HFEX   HFST    SS01,SS02     RETURN RESULTS IN AB REGS
HFOVM1 BRU     POPX

$HFSBE STA     SS01
       STB     SS02
       STX     SS03
       EAX*    0
       CLA
       SKE     0,6
       BRU     *+2
       BRU     POPX
       HFLD    SS01,SS02     LOAD FA FROM CURRENT AB REGS
       HFSB    (0,6),(1,6)   SUBTRACT THE OPERAND
       BRU     HFEX



$HFMPE SKE     ZERO
       BRU     *+2
       BRR     0
       STA     SS01
       STB     SS02
       STX     SS03
       EAX*    0
       COPY    A,B
       SKE     0,6
       BRU     *+2
       BRU     XPOPX
       HFLD    SS01,SS02
       HFMP    (0,6),(1,6)   MULTIPLY BY THE OPERAND
       BRU     HFEX



$HFDVE SKE     ZERO
       BRU     *+2
       BRR     0
       STA     SS01
       STB     SS02
       STX     SS03
       HFLD    SS01,SS02
       EAX*    0
       HFDV    (0,6),(1,6)   DIVIDE BY THE OPERAND
       BRU     HFEX
       ELSE
$HFADE BRM     IFSTUP
       BRU     FADE

$HFSBE BRM     IFSTUP
       BRU     FSBE

$HFMPE BRM     IFSTUP
       BRU     FMPE

$HFDVE BRM     IFSTUP
       BRU     FDVE
       ENDF

$HFNA  BRM     FNA
       BRU     XPOPX

       IF      FPH
*
*      HARDWARE FLOATING OVERFLOW ROUTINE
*
$FPOVI ZRO     0
       STA     FPOV01
       RFPOV
       LDA     KM1
       STA     SFPOVI
       EOM     22400B        ARM THE USER MODE TRAP AND FLAG OVERFLOW
       LDA     FPOV01
       BRI     FPOVI
FPOV01 ZRO
       ENDF
*
*      FIX AND FLOAT
*      
$FFIX SKD NOP24 (DIFFERENCE EXPONENTS AND SKIP IF NUMBER NOT TOO BIG)
       BRU     FIXBIG
       COPY    B,E
       RSH     777B,2 (X WILL ALWAYS BE >0. CONVERT TO AN INTEGER)
       BRU     XPOPX
FIXBIG COPY    B,E
       LSH     1,2
       SKR     SFPOVI (TELL USER MODE TRAP THIS IS AN OVERFLOW)
NOP24  NOP     24D
       EOM     22400B (ARM USER MODE TRAP)
       BRU     XPOPX
*      
*      
$FFLT  CLB
       SKE     ZERO
       BRU     *+2
       BRU     XPOPX         GET XREG
       LDX     K27
       NOD     48
       LDE
       BRU XPOPX
*
       IF      -FPH
*      FLOATING POINT ARITHMETIC SOFTWARE



*      FLOATING ADD. WORKS ONLY ON NORMALIZED NUMBERS. TIME AVERAGES 55
*      CYCLES WITHOUT SIGNIFICANCE CHECK, THREE MORE WITH IT, PLUS
*      CALL AND RETURN.

$FADE  SKE     ZERO
       BRU     FAD9
       LDA     ARG1
       LDB     ARG2
       BRU     FAD7
FAD9   STA     SS01
       STB     SS02
       LDA     ARG1
       SKE     ZERO
       BRU     FAD10
FAD13  LDA     SS01
       LDB     SS02
       BRU     FAD7
FAD10  LDB     ARG2
       SKD     SS02
       BRU     FAD1
*      OPERAND IN MEMORY (ORIGINALLY IN REGISTERS) HAS BIGGER EXPONENT
FAD8   RSH     0,2
       XAB
       COPY    A,E
       ADD     SS02
*      ROUND SHOULD BE INCLUDED HERE
       XAB
       ADC     SS01
       STE
FAD14  OVT
       BRU     FAD2
       NOD     38
       SKE     ZERO
       BRU     FAD3
*      RESULT IS TRUE ZERO
FAD4   CLAB
       LDX     SS03
       BRU     SFPEX
*      RESULT IS NOT ZERO. TEST FOR UNDERFLOW
FAD3   REO
       OVT
       BRU     FAD4
*      NO UNDERFLOW OR OVERFLOW
FAD5   LDE
FAD7   LDX     SS03
       BRU     SFPEX
*      OVERFLOW ON FLOATING ADD
FAD2   RSH     1
       EOR     K4B7
       BRX     FAD5
*      OVERFLOW AND POSITIVE EXPONENT. POSSIBLE FLOATING OVERFLOW
       REO
       OTO
       BRU     FOVER
       BRU     FAD5
*      OPERAND IN MEMORY (ORIGINALLY IN REGISTERS) HAS SMALLER EXPONENT
FAD1   XMA     SS01
       XAB
       XMA     SS02
       XAB
       BRU     FAD8

*      FLOATING SUBTRACT. AVERAGES THREE MORE CYCLES THAN ADD

$FSBE  SKE     ZERO
       BRU     FSB2
       SKE     ARG1
       BRU     FSB3
       BRU     FAD7
FSB3   LDB     K400
FSB2   STA     SS01
       STB     SS02
       LDA     ARG1
       SKE     ZERO
       BRU     *+2
       BRU     FAD13
       LDB     ARG2
       SKD     SS02
       BRU     FSB1
       RSH     0,2
       XAB
       COPY    A,E
       XMA     SS02
       COPY    AX,E
       SUB     SS02
       XAB
       XMA     SS01
       SUC     SS01
       COPY    B,E
       BRU     FAD14
FSB1   XMA     SS01
       XAB
       XMA     SS02
       XAB
       RSH     0,2
       XAB
       MRG     K777
       SUB     SS02
       XAB
       SUC     SS01
       LDX     SS02
       COPY    XB,E
       COPY    X
       COPY    BX,B,E
       BRU     FAD14


*      DEFINITE FLOATING OVERFLOW OR UNDERFLOW
FOVER  BRX     FUNDER
       LCY     1
       LDA     XX
       RCY     1
       EOR     X4
       RSH     38
       EOR     X4
       STA     SS01
       STA     FAC1
       STB     SS02
       STB     FAC2
       SKR     SFPOVI
       BRU     *+1
       EOM     22400B        ARM THE USER MODE TRAP AND FLAG OVERFLOW
       LDX     SS03
       BRU     SFPEX
FUNDER ROV
       BRU     FAD4


*      FMP  FLOATING MULTIPLY
$FMPE  STA     SS01
       STE
       STX     ZE
       BAC
       LDX     SS03
       LRSH    2
       MUL     ARG1
       STA     ZM
       LDA     ARG2
       CXB
       COPY    AX,A,E
       XXA
       ADM     ZE
       COPY    XA,BX,B
       LRSH    2
       MUL     SS01
       ADD     ZM
       MUL     TWO
       STB     ZM
       XMA     SS01
       MUL     ARG1
       XAB
       ADD     ZM
       XAB
       ADC     SS01
       LDX     ZE
       SKA     XX
       BRU     FLEND
       SKB     =-1000B
       BRU     FLEND
       SKE     X4
       BRU     FLND2
       RCY     1
       BRX     FLEND
FLEND  NOD     4
       ROV
       REO
       OTO
       BRU     FOVER
       LDE
FLND2  LDX     SS03
       BRU     SFPEX

*      FDV  FLOATING DIVIDE
$FDVE  STA     SS01
       STE
       STX     ZE
       RSH     2
       DIV     ARG1
       OTO     0 (SKIP IF NO OVERFLOW BUT DON'T CLEAR IT. 03/02/72)
       BRU     FDVO
       STA     ZM
       BAC
       RSH     1
       STA     SS01
       LDB     ARG2
       CXA
       STE
       XXA
       CNA
       ADD     TWO
       ADM     ZE
       BAC
       RCY     2
       CNA
       MUL     ZM
       ADD     SS01
       DIV     ARG1
       MUL     TWO
       ADD     ZM
       LDX     ZE
       SKA     KM1
       BRU     FLEND
       BRU     FLND2
FDVO   LDA     SS01
       EOR     ARG1
       BRU     FOVER
*      STORAGE
ZE     ZRO
ZM     ZRO
       ENDF

*      BRS     21            FLOATING NEGATE
$FNA   ZRO     0
       SKB     =-1000B
       BRU     FLNA
       CNA
       SKE     ZERO
       SKA     K1S6
       BRU     FNA1
       STE
       SKE     X4
       BRU     FNAOV
       RCY     1
       BRX     FNAOV
FNAOV  NOD     4
       ROV
       REO
       OTO
       BRU     FNAOVR
       LDE
       BRU     FNA1
FNAOVR BRX     FNAUDR
       LCY     1
       LDA     XX
       RCY     1
       EOR     X4
       RSH     38
       EOR     X4
       SKR     SFPOVI
       BRU     *-1
       EOM     22400B          ARM USER MODE TRAP TO FLAG OVERFLOW
       BRU     FNA1
FNAUDR COPY    A,B
       BRU     FNA1
FLNA   STE
       COPY    AB,BA
       CNA
       COPY    AB,BA
       EOR     KM1
       LDE
FNA1   LDX     SS03
       BRR     FNA

* PRINT UNSIGNED INTEGER
* BRS 36
* INPUT: A=NUMBER. B=RADIX. X=FILE NO.
*
$OUTNUM STA    OUTNO2
       STB     OUTNO3
       STX     OUTNO5
       CBA
       SKG     ONE
       BRM TRAP
       CLA
OUTNO6 STA     OUTNO4
       LDA     OUTNO2
OUTNO7 STA     OUTNO1
       LRSH    23
       DIV     OUTNO3
       SKE     OUTNO4
       BRU     OUTNO7
       CBA
       ADD K27; SKG K40; SUB SEVEN
       SCIO    OUTNO5
       LDA     OUTNO1
       SKE     OUTNO2
       BRU     OUTNO6
       LDB     OUTNO3
       LDX     OUTNO5
       BRU     EPOPX
*
* DEMAND SIGNED INTEGER
* BRS 38
* INPUT: B=RADIX.  X=FILE NO.
* OUTPUT: A=NUMBER
*
$GETNUM STX    GETNO1
       BAC
       STA     GETNO2
       STB     GETNO3
       STB     GETNO7
GETNM  SCIO    GETNO1
       SKE     K13   PLUS
       BRU     *+2
       BRU     GETNO6
       SKE     K15   MINUS
       BRU     GETNM1
       LDA     KM1
       STA     GETNO7
GETNO6 SCIO    GETNO1
       SUB     K20
       SKG     KM1
       BRU     GETNO4
       SKG     GETNO2
       BRU     GETNO5
GETNO4 ADD     K20
       CAB
       LDA     GETNO3
       SKN     GETNO7
       BRU     EPOPX
       CNA
       BRU     EPOPX
GETNO5 SKE     GETNO2
       BRU     *+2
       BRU     GETNO4
       XMA     GETNO3
       MUL     GETNO2
       LSH     23
       ADM     GETNO3
       BRU     GETNO6

GETNM1 SKE     ZERO              IGNORE LEADING SPACES
       BRU     *+2
       BRU     GETNM
       SKE     =155B           IGNORE LEADING C.R.
       BRU     GETNO6+1
       BRU     GETNM
$ENDRUP BSS 0
       FORGET
       END
MONITOR ** FICHE/FRAME BREAK *****
RUP SYMSORT

SYM.  PG.LN. IDENT.

ARG1   18 15 RUP     ARG2   18 16 RUP     ENDRUP 30 31 RUP     
FAD1   23 33 RUP     FAD10  22 33 RUP     FAD13  22 30 RUP     FAD14  23  6 RUP     
FAD2   23 24 RUP     FAD3   23 16 RUP     FAD4   23 12 RUP     FAD5   23 20 RUP     
FAD7   23 21 RUP     FAD8   22 37 RUP     FAD9   22 25 RUP     FADE   22 20 RUP     
FDVE   26 33 RUP     FDVO   27 24 RUP     FFADE  13  5 RUP     FFADE1 13 12 RUP     
FFADE1 13  7 RUP     FFADEF 13 15 RUP     FFDIE  14 20 RUP     FFDIE1 14 27 RUP     
FFDIE1 14 22 RUP     FFDIEF 14 34 RUP     FFDVE  14  2 RUP     FFDVE1 14  9 RUP     
FFDVE1 14  4 RUP     FFDVEF 14 12 RUP     FFIX   21 28 RUP     FFIXE  17 26 RUP     
FFIXE  17 21 RUP     FFLT   22  2 RUP     FFLTE  17 38 RUP     FFLTE  17 33 RUP     
FFMPE  13 23 RUP     FFMPE1 13 30 RUP     FFMPE1 13 25 RUP     FFMPEF 13 33 RUP     
FFNAE  17 13 RUP     FFNAE  17  9 RUP     FFSBE  15  3 RUP     FFSBE1 15 10 RUP     
FFSBE1 15  5 RUP     FFSBEF 15 13 RUP     FFSIE  15 21 RUP     FFSIE1 15 28 RUP     
FFSIE1 15 23 RUP     FFSIEF 15 36 RUP     FIXBIG 21 33 RUP     FLEND  26 23 RUP     
FLNA   28 26 RUP     FLND2  26 29 RUP     FMIN1  17 11 RUP     FMPE   25 28 RUP     
FNA    27 33 RUP     FNA1   28 32 RUP     FNAOV  28  6 RUP     FNAOVR 28 13 RUP     
FNAUDR 28 24 RUP     FOVER  25  7 RUP     FPOV01 21 23 RUP     FPOVI  21 15 RUP     
FSB1   24 28 RUP     FSB2   24  8 RUP     FSB3   24  7 RUP     FSBE   24  2 RUP     
FUNDER 25 23 RUP     GCD     5 10 RUP     GCD1    5 12 RUP     GCDP    5 11 RUP     
GCI     5 26 RUP     GCI1   10 21 RUP     GCI2    6 15 RUP     GCI3    5 38 RUP     
GCI4   10 22 RUP     GCI7   10 23 RUP     GCI77   5 28 RUP     GCI8    6  2 RUP     
GCI9    5 32 RUP     GCIP    5 27 RUP     GCU     6 20 RUP     GETNM  29 34 RUP     
GETNM1 30 25 RUP     GETNO4 30  9 RUP     GETNO5 30 16 RUP     GETNO6 30  3 RUP     
GETNUM 29 29 RUP     GETSTR  1 28 RUP     GSIN4   1 38 RUP     GSIN5   2  1 RUP     
HFAD1  19 24 RUP     HFADE  20 34 RUP     HFADE  19 17 RUP     HFDVE  21  4 RUP     
HFDVE  20 23 RUP     HFEX   19 28 RUP     HFMPE  21  1 RUP     HFMPE  20  6 RUP     
HFNA   21  8 RUP     HFOVM1 19 29 RUP     HFSBE  20 37 RUP     HFSBE  19 31 RUP     
IFSTUP 18 38 RUP     LDFLE  12  5 RUP     LDFLE  12  2 RUP     LDFME  11 17 RUP     
LDFME1 11 24 RUP     LDFME1 11 19 RUP     LDFMEF 11 32 RUP     LDP     5  3 RUP     
LDPP    5  4 RUP     NOP24  21 36 RUP     OUTMSG  2 13 RUP     OUTNO6 29  7 RUP     
OUTNO7 29  9 RUP     OUTNUM 28 39 RUP     OUTSTR  2 29 RUP     RUPDMS  3 32 RUP     
SBRS    1  9 RUP     SCH1   10 34 RUP     SCH10  10 38 RUP     SCH11  10 39 RUP     
SCH20  11  1 RUP     SCH4   10 36 RUP     SCH5   10 35 RUP     SCH52  11  2 RUP     
SCH9   10 37 RUP     SCIO    1  8 RUP     SCIT    1  6 RUP     SFPEX  18 18 RUP     
SFPEX1 18 20 RUP     SFPEX2 18 23 RUP     SFPFG  18 14 RUP     SFSTUP 18 27 RUP     
SKCO    9 11 RUP     SKCO1   9 16 RUP     SKCO2   9 20 RUP     SKCO3  10 12 RUP     
SKCO4   9 27 RUP     SKCO5  10 16 RUP     SKFNE  16 10 RUP     SKFNE  16  5 RUP     
SKFUZE 16 37 RUP     SKFUZE 16 33 RUP     SKFZE  16 22 RUP     SKFZE  16 18 RUP     
SKS1   10 27 RUP     SKS2   10 28 RUP     SKS3   10 29 RUP     SKS4   10 30 RUP     
SKS5   10 31 RUP     SKS6   10 32 RUP     SKS7   10 33 RUP     SKSE    7 36 RUP     
SKSE1   8 22 RUP     SKSE2   8 16 RUP     SKSEP   7 37 RUP     SKSG    8 27 RUP     
SKSGP   8 28 RUP     SSKSE   1 10 RUP     STFLE  12 37 RUP     STFLE  12 34 RUP     
STFLE2 12 35 RUP     STFME  12 11 RUP     STFME1 12 18 RUP     STFME1 12 13 RUP     
STFME2 12 16 RUP     STFMEF 12 26 RUP     STP     4 33 RUP     STP1   10 20 RUP     
STPP    4 34 RUP     STRO4   2 38 RUP     STRO5   3  7 RUP     STRO6   2 31 RUP     
STRO7   3 10 RUP     STRO7A  3 28 RUP     STRO8   3  5 RUP     SWCI    1  7 RUP     
TYM2    2 21 RUP     UGCI    1 11 RUP     WCD     4 21 RUP     WCD1    4 23 RUP     
WCDP    4 22 RUP     WCH     6 34 RUP     WCH1   10 24 RUP     WCH2   10 25 RUP     
WCH3   10 26 RUP     WCH5    7 12 RUP     WCH77   6 36 RUP     WCHP    6 35 RUP     
WCI     4  9 RUP     WCI1    4 11 RUP     WCIP    4 10 RUP     ZE     27 28 RUP     
ZM     27 29 RUP     
MONITOR ** FICHE/FRAME BREAK *****
S
S      IDENT 12/30/77

       LISTM



PSP    MACRO D   CREATES ASC CELLS AND DATA CELLS FOR SYSTEM COUNTERS
PSPN   NARG D
* ASCII NAMES OF PSP COUNTERS MOVED TO MB IN EXEC.
PSPJ   EQU 0
       RPT PSPN
PSPJ   EQU PSPJ+1
$D(PSPJ) ZRO
       ENDR
$ECC   DATA -PSPN
       ENDM; FRGT PSP,PSPN,PSPJ


       ENTRY   FGLIST,FBMAP,EFGL,MACH
       ENTRY   PRILEV,NSYS,SST,EXECS,EX,NEXEC,SYSS
       ENTRY   VERS,STATUS
       ENTRY   NU,MAXNU,UTIME,RPAGE,DBITS
       ENTRY   SDBM8,DRC,RWD,RWR,SW205,RS
       ENTRY   TFICTR,ARMOT
       ENTRY   EXTPU,NB112
       ENTRY   SWXMA,DISCN,FATIG
       ENTRY   PAGES,TIICTR,TOICTR
       ENTRY   WERIS
       ENTRY   BRSTV,BRSTVA,IOP,M48K,IOPMAR
       ENTRY   PACPTR,JOB,UTTY,TJOB,PMTJOB
       ENTRY   STIME,REAL,SETTB,ETTB,WETTB
       ENTRY   PMTP,ADRSMT
       ENTRY   CPARW,AUNN,EAUNN,DMIN
       ENTRY   XPB,EXEC1
       ENTRY   MISC
       ENTRY   NRTSON,NRTZAP,NPGDRT,ACTDLY,SWHNG,SWTIM,NCHRLS
       ENTRY   NNCHRLS,B44HNG,B44TIM,NPGFLT,PGTIM,NQTPUT
       ENTRY   BIOK1,BIOK2,BIOK3,NBFL,BFLT,BLTIM
       ENTRY   STRLC
       IF TSTAT1
       ENTRY   XBRST,XBRSTC,TTYAC,TTYT,DISCTT,DSCTIM,DSCRDY
       ENDF
       IF TSTAT
       ENTRY   NULJOB,TTQTIM,NTTQTSK,NCCT,NCCT1,NTOR,NTIR
       ENTRY   QIL0,QIL3,QIL4,QIL5
       ENTRY   QCL0,QCL3,QCL4,QCL5
       ENTRY   NTTQJ,NTQJ,CMPTIM,SWPCJ
       ENTRY   CJRUN,CTIME,CMPSWQ,CREAL,SWPTIM,SREAL,CJOB
       ENDF
*
* CONSTANTS
*
$ZERO DATA 0
$ONE DATA 1
$TWO DATA 2
$THREE DATA 3
$FOUR DATA 4
$FIVE DATA 5
$SIX DATA 6
$SEVEN DATA 7
$EIGHT DATA 8
$NINE DATA 9
$TEN DATA 10
$K13 DATA 13B
$K14 DATA 14B
$K15 DATA 15B
$K16 DATA 16B
$K17 DATA 17B
$K20 DATA 20B
$K21 DATA 21B
$K22 DATA 22B
$K23 DATA 23B
$K24 DATA 24B
$K25 DATA 25B
$K26 DATA 26B
$K27 DATA 27B
$K30 DATA 30B
$K37 DATA 37B
$K40 DATA 40B
$K77 DATA 77B
$K100 DATA 100B
$K137 DATA 137B
$K177 DATA 177B
$K200 DATA 200B
$K377 DATA 377B
$K400 DATA 400B
$K777 DATA 777B
$K1000 DATA 1000B
$K1000D DATA 1000
$K1777 DATA 1777B
$K2000 DATA 2000B
$K3777 DATA 3777B
$K4000 DATA 4000B
$K7777 DATA 7777B
$K1B4   DATA 1B4
$K1S4   DATA 17777B
$K2B4   DATA 2B4
$K3S4   DATA 37777B
$K4B4   DATA 4B4
$KS5    DATA 77777B
$K1B5 DATA 1B5
$K1S5 DATA 177777B
$K2B5 DATA 2B5
$K3S5 DATA 377777B
$K4B5 DATA 4B5
$KS6 DATA 777777B
$K1B6 DATA 1B6
$K1S6 DATA 1777777B
$K2B6 DATA 2B6
$K3S6 DATA 3777777B
$K4B6 DATA 4B6
$KS7 DATA 7777777B
$K1B7 DATA 1B7
$K1S7 DATA 17777777B
$K2B7 DATA 2B7
$K3S7 DATA 37777777B
$K4B7 DATA 4B7
$K3B7  DATA 3B7
$K5B7 DATA 5B7
$K6B7 DATA 6B7
$K6S7 DATA 67777777B
$K7B7 DATA 7B7
$K77B6 DATA 77B6
$K777B5 DATA 777B5
$KS4B4 DATA 7777B4
$KS5B3 DATA 77777B3
$KM1 DATA -1
$KM2 DATA -2
$KM3 DATA -3
$KM4 DATA -4
$KM5 DATA -5
$KM6 DATA -6
$KM7 DATA -7
$KM8  DATA -8
$KM9  DATA -9
$KM10D DATA -10
$KM40  DATA -40B
$KS6B2 BSS 0
$KM100 DATA -100B
$KM200 DATA -200B
$KM300 DATA -300B
$KM400 DATA -400B
$KM4B3 DATA -4000B
$KM4B4 DATA -40000B
$KM4B5 DATA -400000B
$KM4B6 DATA -4000000B
$KM10 EQU KM8
$PLMSK EQU KS4B4
$PRMSK EQU K7777
$ADMSK EQU K3S4
$NADMSK EQU KM4B4
$PGMSK EQU K3777
$NPGMSK EQU KM4B3
$X0    EQU ZERO
$X1    EQU K1B7
$X2    EQU K2B7
$X3    EQU K3B7
$X4    EQU K4B7
$X5    EQU K5B7
$X6    EQU K6B7
$X7    EQU K7B7
$XX    EQU K3S7
*
* SYSTEM TABLES AND WORDS
*
PACPTR ZRO
JOB    ZRO
UTTY   ZRO
XPB    ZRO 0   PB POINTER
EXEC1  ZRO 0   NEGATIVE FOR SUBSYSTEM STATUS
EX     BSS 0   EXEC STATUS TRAP
NEXEC  ZRO 0   EXEC STATUS TRAP WITH RELABELING
EXECS  ZRO 0   NEG. FOR EXEC STATUS
SST    BSS 0   SYSTEM STATUS TRAP
NSYS   ZRO 0   SYSTEM STATUS TRAP WITH RELABELING.
SYSS   ZRO 0   NEG. FOR SYSTEM STATUS
PRILEV DATA 0;* 1B7 FOR NO STATUS, 2B7 FOR SUBSYS, 3B7 FOR SYS, 37B6 EX.
STATUS ZRO 1   STATUS CONTROL WORD.
TJOB   ZRO 0                   ELAPSED TIME POINTER
PMTJOB ZRO 0                   POINTER TO CURRENT PMT
*      (DO NOT CHANGE THIS TABLE WITHOUT CONSIDERATION OF BRS 7)
*      (THE TABLE IS FROM "ADRSMT" TO "NT19"
ADRSMT ZRO 0   ADDRESS OF SMT
       IF EXPMT
$ADRPMT ZRO PMT
$AEXSMT ZRO EXSMT
       ENDF
M48K   DATA    0               BIT 0=1 FOR 48K.
MAXNU  DATA    NJOB-1          MAXIMUM NUMBER OF USERS. SEE TY11.
*      BIT MAP PARAMETERS
$MAPLBL DATA RDP*100B+RMP      MAP DISC PAGE IN M6 AND MAP PAGE IN M7
$BITSUM DATA -1               BITMAP CHECKSUM
$MAPADR DATA   740210B,740250B,740310B,740350B
       DATA    760210B,760250B,760310B,760350B
$DBITBL BSS 8   NO. OF DBITS IN EACH ZONE.
$DBITBE EQU *
$DBITE1 EQU *+1
$DBMDA 0 0              DISC ADDRESS OF CURRENT BIT MAP IN CORE
SDBM8  DATA    -1              -1 IF BIT MAP NOT SET,0 OTHERWISE
$MAPBIT 0;* A SINGLE BIT WHICH TELL DISC ZONE.REDUNDANT TO MAPNUM.
$MAPDAT 0;*    (TIME MAP WAS WRITTEN TO DISC WHEN SYSTEM WENT DOWN)
$MAPTIM 0;*    (TIME MAP WAS WRITTEN TO DISC WHEN SYSTEM WENT DOWN)
$PZONE DATA -1 (CONTAINS ZONE NUMBER THAT MAP PROGRAM IS WORKING ON)

$GW     EQU 740B                NUMBER OF MAPPED BLOCKS ON A DISC
$GA     EQU *   DATA BLOCK ADDRESSES ON DISC 0 THAT DELIMIT 4 MAP ZONES
       DATA    77B,77B+GW,77B+2*GW,77B+3*GW,77B+4*GW
$GAD   EQU *-1
$GAP   DATA -1
$GA1P  DATA -1
DRC    DATA    400000B         CONSTANT FOR LOCATING EXEC ON DISC
$MAPING 0 0    -1 WHEN MAPPING, 0 WHEN NOT MAPPING
RWD    DATA    -1              MINNED BY SET IF DISC WRITE PROTECTED
RWR    DATA   -1              MINNED BY SET IF RAD WRITE PROTECTED
SW205  DATA    -1              MINNED BY SET IF 205 INTRPT IS NOT HIGH
SWXMA  DATA -1
MACH   ZRO 0;*  MACHINE NUMBER
DISCN  ZRO 0;* DISC NUMBER
VERS ASC '38.10' MON VERSION AS APPEARING IN EXEC "SYS" COMMAND
$FG940A DATA   40516337B   940 UP FLAGS
$FG940B DATA 51506262B     940 UP FLAGS
$TRBLKS ZRO    0               NUMBER OF RETURNED DBITS BY MAP PROGRAM
$NPRUNS ZRO    0               NUMBER OF TIMES MAP PROGRAM IS RUN
$DHTPAC DATA   -1              ACTIVATION SWITCH FOR MAP PROGRAM
$DHTCC  ZRO    0               NUMBER OF CURRENT ENTRIES IN DHT
$DHTTC  ZRO    0               NUMBER OF TOTAL ENTRIES PUT IN HOLE TABLE
$DHTFUL ZRO    0               NUMBER OF TIMES DHT FULL
$PCALLS ZRO    0               NUMBER OF MAP PROG. STARTUP REQUESTS
$PRTIME ZRO    0               LAST TIME PROGRAM WAS STARTED
$NT19  EQU *-ADRSMT            SIZE OF TABLE 19 FOR BRS 7
* JOB INDEXED TABLES
PMTP   BSS NJOB POINTER TO FIRST PMT ENTRY
$EPMTP EQU PMTP+NJOB
WERIS  EQU *                   LUD LOCATOR
       RPT NPORT; DATA -1; ENDR
$EWERIS EQU    *
* JOB - TELETYPE INDEX
* BITS 0-7=DISC BUSY BITS, 1B5 IS PUTIM BUSY BIT, 4B4 FOR ID124 ERRORS
*      BIT 15-17 (700B) FOR RAD ERR COUNT
$TTNO  0; RPT NJOB-2; DATA *+1-TTNO; ENDR
$ETTNO DATA 2-NJOB
$FULST DATA 1

*
* EXEC PARAMETERS
CPARW  BSS     NJOB   USER'S CONTROL PARAMETERS.
AUNN   BSS     NJOB            UUN. TO GET USER NAME TYPE 1ENTRY LF.
*                              EXEC SYMBOL TABLE IS 1EXECST.
*                              (TS)UN01=AUNN
EAUNN  EQU     *
* EXEC SWITCHES. SET BY BRS 136. DO NOT REORDER.
$SWLET DATA    0               LETTER ROUTINE SWITCH (0)
$DNTERM DATA -1 (DO NOT TERMINATE FORK IF POS.) (1)
$SLOMOD DATA 33B5+SCHDLY-34B3 (PARAMETER TO SET UP SCHDLY) (2)
$MASTER DATA 0 (-1 TO ENABLE CUR/MAX STG) (3)
* FLAG BIT MEANINGS:  
*      BITS 3-8 MASK FOR LOW PRIORITY SCHEDULING
*      BIT 11=1=SYSTEM RESTRICTED
*      BIT 23=1=EMERGENCY MESSAGE WAITING.
$FLAGS DATA 0 (4)
       DATA 0 (5 NOT USED)
FATIG  DATA -1;* MINNED IF REAL IS TOO LARGE. (6)
$SWMBL DATA    -1              MAIL BOX LIST BUSY (7)
* END OF EXEC SWITCHES
*
*      FILE DIRECTORY CONTROL BLOCK LIST
*      BITS 0-7 NEGATIVE USE COUNT
*      BIT 8 FLUSHED BIT
*      BITS 9-11 SPARE
*      BIT 12 JA (JUST ASSIGNED) ENTRY
*      BITS 13-23 FILE DIR NO. (0-3777B)
       RPT NFDCB-1; DATA 1B5; ENDR
       DATA 777B5 (FD. 0 LOCKED IN LIST)
$FDCBLE EQU *
$HDWID ZRO;* HARDARE IDENTIFICATION E.G. "Z"
$LDFACT        DATA NJOB       LOAD FACTOR
$LFLUSH DATA 0                 LAST TIME FDCB'S WERE FLUSHED.
*      BITS 0-5 NEG. USE COUNT,6-12 SPARE, 13-14 BUFFER NO.,
*      BITS 15-23 BUFFER STATE: 1=READ,2=WRITE,3=CORE,4=VOID.
$PG22  DATA 4                  STATE OF FDCB BUFFER IN SMT 22
$FI    DATA 0                  FLUSH INTERLOCK (UTTY OF OWNER)
$ACTIME DATA 0                 LAST TIME ACCOUNTING WAS WRITTEN.
$GBUSY BSS NJOB   ASSOCIATED WITH FGLIST IN THE EXEC
FGLIST BSS NJOB   FILE GROUP LIST
EFGL   BSS 0
SOV    EQU 4000B  CHANGE WHEN OVERFLOW FD AREA MOVES.
FBMAP  BSS 6000B/24-SOV/24+1



* SYSTEM PARAMETERS
*   RC = ERRORS DETECTED BY SKS 51000 PLUS ERRORS DETECTED BY SKS 51026
*   RS = ERRORS DETECTED BY SKS 51000
*   RA=RAD ADDRESSING, RU=RAD UNCORRECTABLE
*   RAT=RAD ANGLE, DC=DISC CHANNEL, DS=DISC SEEK, DF=DISC FAIL
*   DU=DISC UNCORRECTABLE, CPC=CPU PARITY
*      DXX IS MINNED WHENEVER A DP DISC WAS NOT READY ON ENTERRING IDM
*      D26 IS MINNED FOR EVERY MILISECOND OF CONTINUOUS
*              NOT READINESS. SEE DRT1 CODE.
*      BZ = NUMBER OF TTY BUFFERS ZAPPED BY TG6 CODE IN NET
       PSP     RC,RA,RU,RAT,DC,DS,DF,DU,DXX,D26,BTS,NDA,RS,CPC,BZ,IOP

MISC   BSS     0
IOPMAR ZRO     0               MAR CONTENTS OF LAST IO PARITY.
$MAPNUM DATA -1 AN INTEGER WHICH TELLS WHICH ZONE OF DISC IS MAPPED
DBITS  DATA    0               NO. OF FREE BITS IN BIT MAP
NRTSON ZRO     0               NO. OF LOGINS REJECTED.
NRTZAP ZRO     0               NO. OF CIRCUIT ZAPS IGNORED
TFICTR ZRO     0               CIRCUITS ZAPPED.
$SPARE1 DATA 0                 MAXIMUM NU.
$SPARE2 DATA NPAC              LEAST PACT ENTRIES IN FREELIST.
TIICTR ZRO     0               TTY INPUT CHARACTERS.
NPGDRT ZRO     0               NO. OF PAGES DIRTIED
TOICTR ZRO     0               TTY OUTPUT CHARACTERS.
ACTDLY  ZRO    0               NO. OF SWAP JOB ACTIVATION DELAYS
NU     ZRO     0               NO. OF USERS ON
UTIME  ZRO     0               NO. OF USER ON "SECONDS"--TICS/64*NU
REAL   ZRO     0               NO. OF CLOCK TICKS ELAPSED
SETTB  ZRO     0               UNSOLD TIME
WETTB  ZRO     0               CPU IDLE TIME.  NO JOBS RUNNABLE.  ALSO
*                              COUNTS IDLE TIME AT PMTA, WAITING FOR RAD PAGE.
STIME  ZRO     0               TIME IN SYSTEM MODE.
$SPT   ZRO     0               PAGE TICKS FOR ALL USERS
PAGES  ZRO     0               NO. OF PAGES SWAPPED
$SSWC  ZRO     0               SWAP COUNT FOR ALL USERS
RPAGE  ZRO     0               NO. OF PAGES READ.
$PAGEW ZRO     0               NO. OF PAGES WRITTEN.
$SDSKMT ZRO    0               DISK ACCESS UNITS FOR ALL USERS
ARMOT  ZRO     0               TOTAL DISC COMMANDS ENTERED FOR ALL USERS.
SWHNG  ZRO     0               NO. OF SWAP HANG CALLS
SWTIM  ZRO     0               HANG TIME "
EXTPU  ZRO     0               EXTRA PU ENTRIES AT BRS 112 (CLEANUP PU)
NB112  ZRO     0               NUMBER OF LOGOUTS (BRS 112 COUNT)
$RBER  ZRO     0               RUBOUT ERROR ON PU. (WERIS.NE.-3)
$UPSHUT 0 0    UP,SHUT FLAG. 2 FOR UP, 1 FOR SHUT.
NCHRLS ZRO     0               NO. OF RELABELING CHANGES
NNCHRLS ZRO    0               NO. OF NULL  "   "
B44HNG ZRO     0               NO. OF BRS 44 HANG CALLS
B44TIM ZRO     0               HANG TIME "
NPGFLT ZRO     0               NO. OF NEWLY ACCESSED PAGES
PGTIM  ZRO     0               HANG TIME FOR PAGE FAULT
NQTPUT ZRO     0               NO. COMPUTE JOBS PLACED AT HEAD OF QQE
$EQPT  EQU  *  BITS IN THIS CELL TELL THE STATE OF MONITOR IF SWITCHES
*      BIT 20 - ASSEMBLE TRU'S
*      BIT 21 - 2314 DRIVES
*      BIT 22 - TYMNET
*      BIT 23 - FLOATING PT. HARDWARE
       IF FPH;DUM EQU 1; ELSE;DUM EQU 0; ENDF
       IF PH2;DUM EQU DUM+2; ENDF
       IF DISC=3;DUM EQU DUM+4; ENDF
       IF RP;DUM EQU DUM+8; ENDF
       DATA DUM; FRGT DUM
$NMISC EQU *-MISC              SIZE OF MISC TABLE FOR RWTAB MACRO
*      MISC TABLE ENDS HERE. LENGTH OF TABLE IS 45B. MAINTAIN THIS 
*      COMMENT AND A CELL IN RWTAB FOR BRS 7 WHEN CHANGING MISC TABLE.
*      THE LENGTH OF THE MISC TABLE CAN BE FOUND BY SAYING:
*      NMISC= IN DDT AFTER LOADING S. THE SIZE OF TABLE 19 CAN
*      BE FOUND BY SAYING: NT19=


* BRS MODULE TRANSFER VECTOR
* GS (0),GS+AF (1),GS+CM (2),GS+FS (3),GS+MB (4),GS+NIO (5)
* MOST XBRS'S USE (0). EXCEPTIONS ARE: (1): BRS 37,91,140,171,176,187
* (2): BRS 141-142. (3): BRS 190-193
* (3): NOT USED. (4): BRS 15-16,18-19,27,59,173,182.
* (5): BRS 52,53,133,165,ISC,SIC,NISC,NSIC
BRSTV  DATA 0,16B,13B6,22B,15B2,17B
BRSTVA DATA 40010005B






* TIMING TABLES
DMIN   DATA -1                SYS. START-UP DATE/TIME IN MINS.
*                   1ST 6 BITS FOR MONTH. REST FOR MINUTES OF MONTH.
$YEAR  DATA    16B  YEAR NUMBER-1964
$LGMON ZRO     0 LAST TIME MONITOR DATA ENTERED IN ACCOUNTING
$CZONE ZRO 0     CURRENT TIME ZONE FOR EXEC
ETTB   BSS NJOB                COMPUTE TIME COUNTER
$STACT 0;*     START ACCOUNTING CURSOR POSITION
$CRACT 0;*     CURRENT ACCOUNTING CURSOR POSITION
$DSTSW 0;*     SWITCH FOR GMT TIME CONVERSION
$TMK   DATA 4167     CONSTANT FOR COMPACTED BINARY TIME (BRS 74)
$TMK1  0;*     CONSTANT FOR LOCAL TIME CONVERSION (BRS 42)
$TMK2  0;*     CONSTANT FOR LOCAL TIME CONVERSION
$TYMTIM 0;*    MICROSECOND TIME


*      STATISTICS COUNTERS

       IF TSTAT1
XBRST  BSS 37  XBRS TIME SPENT, BY XBRS NO.
XBRSTC BSS 37  NO. XBRS CALLS
TTYAC  BSS  1  TOTAL NO. TTY READY TO RUN
TTYT   BSS  1  TOTAL TTY RESPONSE TIME BEFORE RUN
DISCTT BSS NJOB
DSCRDY BSS  1  TOTAL NO. DISC READY TO RUN
DSCTIM BSS  1  TOTAL DISC RESPONSE TIME BEFORE RUN
       ENDF
       IF TSTAT
NTTQJ  BSS  1  NO. OF QUEUE JUMPS DUE TO TTIME MECHANISM
NTQJ   BSS  1  NO. "  "   "  "  " TIME MECHANISM
CMPTIM BSS  1  SWAP TIME FOR COMPUTE JOB
SWPCJ  BSS  1  NO. OF COMPUTE JOBS SWAPPED
CJRUN  BSS  1  NO. OF COMPUTE JOBS RUN--REDUNDANT TO SWPCJ
CTIME  BSS  1  TOTAL TIME COMPUTE JOB RESIDENT
CMPSWQ BSS  1  PACLVL OF COMPUTE JOB FETCHED
CREAL  BSS  1  TIME OF LAST FCJ
SWPTIM BSS  1  SWAP TIME FOR SWAP JOB
SREAL  BSS  1  TIME OF LAST FQJ
CJOB   BSS  1  ELAPSED TIME POINTER
NULJOB BSS  1  TIME ACCUMULATED BY NULL JOB
TTQTIM BSS  1  TIME ACCUMULATED BY BLOCK I/O PROCESSING
NTTQTSK BSS 1  NO. OF BLOCK I/O TASKS
NCCT   BSS  1  TOTAL CHARS MOVED BY BLOCK I/O
NCCT1  BSS  1  TOTAL CHARS MOVED FOR CHARGING PURPOSES
NTOR   BSS  1  TOTAL OUTPUT RECORDS "
NTIR   BSS  1  TOTAL INPUT RECORDS

*      SWAP JOB COUNTERS--PAIR FOR EACH QUEUE LEVEL
*              ELAPSED TIME, NO. OF TIMES RUN
QIL0   BSS 2
QIL3   BSS 2
QIL4   BSS 2
QIL5   BSS 2

*      COMPUTE JOB COUNTERS
QCL0   BSS 2
QCL3   BSS 2
QCL4   BSS 2
QCL5   BSS 2
       ENDF
BIOK1  DATA 600B (MAXIMUM RECORD SIZE)
       IF MDSI
BIOK2 DATA 0
BIOK3 DATA 0
       ELSE
BIOK2  DATA 304470B (.012 FOR $.01/KILOCHAR)
BIOK3  DATA  0  (CONSTANT FOR BUFFERLET USE)
       ENDF
NBFL   BSS  1  TOTAL NO. OF BUFFERLETS ASSIGNED
BFLT   BSS  1  TOTAL BUFFERLET TIME
BLTIM  BSS 14  TIME BUFFERLET ASSIGNED
*      TUNING PARAMETERS
STRLC  DATA 15 (NO. OF BRS 44 PAGES ALLOWED FOR COMPUTE JOB)

       IF NFILE>100B
* LOOK IN "I" FOR THESE TABLES WHEN NFILE<101B
$CCT   BSS NJOB;* NUMBER OF CHARACTERS FOR THIS JOB.
       IF PTICK
$PTCKS BSS NJOB;* PACE*TICKS, CORE CHARGE.
       ENDF
$PUCT   BSS NPUQ*4
$EPUCT3 EQU PUCT+NPUQ*4+4
$EPUCT  EQU PUCT+NPUQ*4
$EPUCM3 EQU PUCT+NPUQ*4-4
       ENDF

ENDSYM BSS 0
       FORGET
       END
MONITOR ** FICHE/FRAME BREAK *****
S SYMSORT

SYM.  PG.LN. IDENT.

ACTDLY  9  3 S       ACTIME  8  9 S       ADMSK   4 33 S       
ADRPMT  5 29 S       ADRSMT  5 27 S       AEXSMT  5 30 S       ARMOT   9 17 S       
AUNN    7 13 S       B44HNG  9 26 S       B44TIM  9 27 S       BFLT   12 15 S       
BIOK1  12  6 S       BIOK2  12 11 S       BIOK2  12  8 S       BIOK3  12 12 S       
BIOK3  12  9 S       BITSUM  5 36 S       BLTIM  12 16 S       BRSTV  10 16 S       
BRSTVA 10 17 S       CCT    12 22 S       CJOB   11 23 S       CJRUN  11 17 S       
CMPSWQ 11 19 S       CMPTIM 11 15 S       CPARW   7 12 S       CRACT  10 32 S       
CREAL  11 20 S       CTIME  11 18 S       CZONE  10 29 S       D(PSPJ  1 13 S       
DBITBE  6  1 S       DBITBL  5 39 S       DBITE1  6  2 S       DBITS   8 33 S       
DBMDA   6  3 S       DHTCC   6 30 S       DHTFUL  6 32 S       DHTPAC  6 29 S       
DHTTC   6 31 S       DISCN   6 23 S       DISCTT 11  8 S       DMIN   10 25 S       
DNTERM  7 19 S       DRC     6 16 S       DSCRDY 11  9 S       DSCTIM 11 10 S       
DSTSW  10 33 S       EAUNN   7 16 S       ECC     1 15 S       EFGL    8 12 S       
EIGHT   2 22 S       ENDSYM 12 32 S       EPMTP   6 38 S       EPUCM3 12 29 S       
EPUCT  12 28 S       EPUCT3 12 27 S       EQPT    9 31 S       ETTB   10 30 S       
ETTNO   7  7 S       EWERIS  7  2 S       EX      5 15 S       EXEC1   5 14 S       
EXECS   5 17 S       EXTPU   9 20 S       FATIG   7 28 S       FBMAP   8 14 S       
FDCBLE  8  1 S       FG940A  6 25 S       FG940B  6 26 S       FGLIST  8 11 S       
FI      8  8 S       FIVE    2 19 S       FLAGS   7 26 S       FOUR    2 18 S       
FULST   7  8 S       GA      6 11 S       GA1P    6 15 S       GAD     6 13 S       
GAP     6 14 S       GBUSY   8 10 S       GW      6 10 S       HDWID   8  2 S       
IOPMAR  8 31 S       JOB     5 11 S       K100    3  3 S       K1000   3 10 S       
K1000D  3 11 S       K13     2 25 S       K137    3  4 S       K14     2 26 S       
K15     2 27 S       K16     2 28 S       K17     2 29 S       K177    3  5 S       
K1777   3 12 S       K1B4    3 17 S       K1B5    3 23 S       K1B6    3 29 S       
K1B7    3 35 S       K1S4    3 18 S       K1S5    3 24 S       K1S6    3 30 S       
K1S7    3 36 S       K20     2 30 S       K200    3  6 S       K2000   3 13 S       
K21     2 31 S       K22     2 32 S       K23     2 33 S       K24     2 34 S       
K25     2 35 S       K26     2 36 S       K27     2 37 S       K2B4    3 19 S       
K2B5    3 25 S       K2B6    3 31 S       K2B7    3 37 S       K30     2 38 S       
K37     2 39 S       K377    3  7 S       K3777   3 14 S       K3B7    4  1 S       
K3S4    3 20 S       K3S5    3 26 S       K3S6    3 32 S       K3S7    3 38 S       
K40     3  1 S       K400    3  8 S       K4000   3 15 S       K4B4    3 21 S       
K4B5    3 27 S       K4B6    3 33 S       K4B7    3 39 S       K5B7    4  2 S       
K6B7    4  3 S       K6S7    4  4 S       K77     3  2 S       K777    3  9 S       
K7777   3 16 S       K777B5  4  7 S       K77B6   4  6 S       K7B7    4  5 S       
KM1     4 10 S       KM10    4 30 S       KM100   4 22 S       KM10D   4 19 S       
KM2     4 11 S       KM200   4 23 S       KM3     4 12 S       KM300   4 24 S       
KM4     4 13 S       KM40    4 20 S       KM400   4 25 S       KM4B3   4 26 S       
KM4B4   4 27 S       KM4B5   4 28 S       KM4B6   4 29 S       KM5     4 14 S       
KM6     4 15 S       KM7     4 16 S       KM8     4 17 S       KM9     4 18 S       
KS4B4   4  8 S       KS5     3 22 S       KS5B3   4  9 S       KS6     3 28 S       
KS6B2   4 21 S       KS7     3 34 S       LDFACT  8  3 S       LFLUSH  8  4 S       
LGMON  10 28 S       M48K    5 32 S       MACH    6 22 S       MAPADR  5 37 S       
MAPBIT  6  5 S       MAPDAT  6  6 S       MAPING  6 17 S       MAPLBL  5 35 S       
MAPNUM  8 32 S       MAPTIM  6  7 S       MASTER  7 21 S       MAXNU   5 33 S       
MISC    8 30 S       NADMSK  4 34 S       NB112   9 21 S       NBFL   12 14 S       
NCCT   11 27 S       NCCT1  11 28 S       NCHRLS  9 24 S       NEXEC   5 16 S       
NINE    2 23 S       NMISC  10  2 S       NNCHRL  9 25 S       NPGDRT  9  1 S       
NPGFLT  9 28 S       NPGMSK  4 36 S       NPRUNS  6 28 S       NQTPUT  9 30 S       
NRTSON  8 34 S       NRTZAP  8 35 S       NSYS    5 19 S       NT19    6 35 S       
NTIR   11 30 S       NTOR   11 29 S       NTQJ   11 14 S       NTTQJ  11 13 S       
NTTQTS 11 26 S       NU      9  4 S       NULJOB 11 24 S       ONE     2 15 S       
PACPTR  5 10 S       PAGES   9 12 S       PAGEW   9 15 S       PCALLS  6 33 S       
PG22    8  7 S       PGMSK   4 35 S       PGTIM   9 29 S       PLMSK   4 31 S       
PMTJOB  5 24 S       PMTP    6 37 S       PRILEV  5 21 S       PRMSK   4 32 S       
PRTIME  6 34 S       PSP     1  7 S       PSPJ    1 12 S       PSPJ    1 10 S       
PSPN    1  8 S       PTCKS  12 24 S       PUCT   12 26 S       PZONE   6  8 S       
QCL0   12  1 S       QCL3   12  2 S       QCL4   12  3 S       QCL5   12  4 S       
QIL0   11 34 S       QIL3   11 35 S       QIL4   11 36 S       QIL5   11 37 S       
RBER    9 22 S       REAL    9  6 S       RPAGE   9 14 S       RWD     6 18 S       
RWR     6 19 S       SDBM8   6  4 S       SDSKMT  9 16 S       SETTB   9  7 S       
SEVEN   2 21 S       SIX     2 20 S       SLOMOD  7 20 S       SOV     8 13 S       
SPARE1  8 37 S       SPARE2  8 38 S       SPT     9 11 S       SREAL  11 22 S       
SST     5 18 S       SSWC    9 13 S       STACT  10 31 S       STATUS  5 22 S       
STIME   9 10 S       STRLC  12 18 S       SW205   6 20 S       SWHNG   9 18 S       
SWLET   7 18 S       SWMBL   7 29 S       SWPCJ  11 16 S       SWPTIM 11 21 S       
SWTIM   9 19 S       SWXMA   6 21 S       SYSS    5 20 S       TEN     2 24 S       
TFICTR  8 36 S       THREE   2 17 S       TIICTR  8 39 S       TJOB    5 23 S       
TMK    10 34 S       TMK1   10 35 S       TMK2   10 36 S       TOICTR  9  2 S       
TRBLKS  6 27 S       TTNO    7  6 S       TTQTIM 11 25 S       TTYAC  11  6 S       
TTYT   11  7 S       TWO     2 16 S       TYMTIM 10 37 S       UPSHUT  9 23 S       
UTIME   9  5 S       UTTY    5 12 S       VERS    6 24 S       WERIS   6 39 S       
WETTB   9  8 S       X0      4 37 S       X1      4 38 S       X2      4 39 S       
X3      5  1 S       X4      5  2 S       X5      5  3 S       X6      5  4 S       
X7      5  5 S       XBRST  11  4 S       XBRSTC 11  5 S       XPB     5 13 S       
XX      5  6 S       YEAR   10 27 S       ZERO    2 14 S       
MONITOR ** FICHE/FRAME BREAK *****
SET
SET   IDENT 05/07/74

       LISTM
* MONITOR MODULE 0
DR     EQU -1


* 'DRMSET'
* THIS ROUTINE INITIALIZES THE DISC I/O.
*
DRMSET ZRO
       LDA KM1; STA UNIT
       LDX =-NFILE; STA EXBP,2; BRX *-1
       IF DISC<3
       LDA =DRQ; STA EDCL; STA IDCL
       LDA KM1; STA NDCL; STA IDCL1; STA DTXS1; STA WSW
       LDA KS6; STA DSCTOP (HIGHEST DP SECTOR)
       ENDF
       BRR DRMSET

PROTEC ZRO;*   SET DISC WRITE PROTECT SWITCH IF DISC IS WRITE PROTECTED.
       LDA KM1; STA RWD; CLA; STA T
       IF DISC<3
       LDA =20002B; LDX KM40      CHECK DISC
RW1    EOM 10026B; POT T; SKS 12026B; BRU *-1; SKS 13026B; MIN RWD 
       ADM T; BRX RW1
       SKS 10027B; BRR PROTEC; LDX K1B6; STX T; LDX KM40
RW2    EOM 10027B; POT T; SKS 12027B; BRU *-1 (WAIT FOR STATE 1 READY)
       SKS 13027B; MIN RWD (WRITE PROTECTED); ADM T; BRX RW2
       SKS 10022B; BRR PROTEC; LDX K2B6; STX T; LDX KM40
RW3    EOM 10022B; POT T; SKS 12022B; BRU *-1
       SKS 13022B; MIN RWD; ADM T; BRX RW3
       SKS 10023B; BRR PROTEC; LDX =3B6; STX T; LDX KM40
RW4    EOM 10023B; POT T; SKS 12023B; BRU *-1
       SKS 13023B; MIN RWD; ADM T; BRX RW4
       ENDF DISC<3
       BRR PROTEC
*
CK205  ZRO;*   TELL EXEC WHETHER OR NOT 205 IS WIRED HIGH
       LDA *+1; XMA 205B; ARMI ARM205; MIN CK205; ARMI DIS205
       SKE CK205+2; MIN SW205; BRI CK205

CKXMA  ZRO;* TEST XMA ON READ ONLY PAGE
       LDB =RSR+40B; LDX RRL3; BRM LABEL
       LDA CKXMA2; XMA 43B; CAB; XMA *,4
CKXMA1 STB 43B; SKE 43B; MIN SWXMA; BRR CKXMA
CKXMA2 BRU* =CKXMA1  MINIMUM OF 2 CYCLES REQUIRED FOR INTRPT INSTRUCTION

CKRD   ZRO; CLB;ZILCH MACRO D;J EQU D(1)
       EOD 10226B+2000B*J+D(2); PIN T
       LDA T; EOD 10226B+2000B*J+D(2); PIN T; SKE T; BRU *+2; BRU *-4
       LDA =1+20000B*J; ADM T; EOD 10026B+D(2); POT T
       EOD* 10000B+D(2); EOD 14200B; POT =CKRDBF+100B*4B4
       EOD 2226B+D(2); LDA =1500000/1750/4; STA TS
       SKR TS; BRU *-1; SKS* 10026B+D(2); BRU *+2
       BRU *+6; LDA ONE; LSH J; ADM RAT; SKS* 10026B+D(2); BRU *-1
       FRGT J
       ENDM
       ZILCH 0,0
       IF RAD1; ELSE
       IF DR; ZILCH 0,100B; ELSE; ZILCH 1,0; ENDF
       IF DR; LDX =-512; CLA; STX CKRDBF+1; STA CKRDBF; BRM HRELB
        LDA CKRDBF; LDX CKRDBF+1; ADD K40; BRX *-6; ENDF
       ENDF RAD1
       BRR CKRD
CKRDBF BSS 100B                BUFFER FOR CKRD

CKMEM  0;* SCAN MEMORY FOR BAD PARITY
       LDA MP7; XMA 56B; STA T1    SAVE MEMORY TRAP LOCATION
       LDA RRL3; STA T; ETR K37; STA RRL3
MP1    LDA RRL3; ADD K100; BRM RLABEL; LDX KM4B3
MP2    LDA 34000B,2    CHECK A CELL AND POSSIBLY TRAP TO MP7+1
MP2A   BRX MP2
       LDA RRL3; SKN M48K; SUB K1000; SKG =2700B; BRU MP1
       LDA MP9; LDB MP8; LDX =100076B; SKB KM1; BRM STOP
       LDA T; BRM RLABEL; LDA T1; STA 56B
       BRR CKMEM

MP9    0;* NUMBER OF CELLS IN MEMORY HAVING BAD PARITY
MP8    0;* ADDRESS OF LAST CELL IN MEMORY HAVING BAD PARITY
MP7    BRM *+1; 0;* MEMORY PARITY TRAP ROUTINE FOR CK   

       STA 34000B,2   FIX UP BAD WORD
       LDA RRL3; LSH 5; ETR =37B*4000B; STA MP8   PAGE OF ERROR
       CXA; ADD K4000; ETR K3777; ADM MP8  16 BIT ADRS 
       MIN MP9; BRI =MP2A

RADTYM 0;* SYSTEM IS NOW FULLY SET UP. IF RAD IS WRITE PROTECTED SET RWR
*      PLUS FOR EXEC AND AS A SEPERATE FUNCTION WHICH CAN BE OVERLAPPED
*      KEEP SETTING THE TYMNET KEY FOR 1/2 SEC SO BASE KNOWS 940 IS UP.
       LDA KM1; STA RWR; CLA; STA T
       LDA =40000B/32+1; IF RAD1; LDX =-16; ELSE; LDX =-32; ENDF
RM1    EOD 10026B; POT T; SKS* 13026B; MIN RWR; ADM T
       LDB FG940A; STB UPFL; LDB FG940B; STB UPFL+1
       BRX RM1
       BRR RADTYM

*      SYSTEM INITIALIZE ROUTINE
*
$SETSA EQU *   BEGINNING OF SYSTEM SET UP CODE. REACHED FROM SETSET.
       IF DISC<3; EOM 14010B     REWIND THE DSWAP TAPE; ENDF
       LDA =RSR; STA RRL3; ETR K37; STA RLTS
       CLA; BPT2; LDA X4; STA M48K
       IF DISC=3; LDA 2; ELSE; LDA 22B; RSH 13; ENDF
       ETR K37; STA DISCN  
SET9   BRM SSET; BRM CKRD
       BRM DRMSET; BRM PROTEC; BRM CKXMA; BRM CKMEM; BRM RADTYM
$SET7  EQU *
       IF DISC<3
       SKS 14026B; BRM MONCR (DISC HEADER SWITCH ON)
       SKS 10027B; BRU *+3; SKS 14027B; BRM MONCR
       SKS 10022B; BRU *+3; SKS 14022B; BRM MONCR
       SKS 10023B; BRU *+3; SKS 14023B; BRM MONCR
       ENDF

       BRU SETWUP    MOVE W ROUTINES TO PAGE 7, AND THEN START SCHED.

*
$SSET  ZRO;* RESET SYSTEM
       ARMI AIRWD
       CLA; STA REAL
       LDX =-77B; LDA CLINTC; STA 100B,2; BRX *-1
       STA SETSET
       LDX =-NPAC*NPPAR; CLB
       LDA =SMT; STA ADRSMT
SET1   LDA =700000B; STA PTEST,2
       CXA; ADD =PPTR; ADD =NPPAR; STA PPTR,2
       EAX NPPAR-1,6; BRX SET1
       LDA =PPTR2; STA FPLST; STB PPTRU
       STB PUCTR
       LDX =-NPUQ*4
$SET3  CXA; ADD =EPUCT3; STA EPUCT,2
       EAX 3,6; BRX SET3; CLB; STB EPUCM3
       LDA =PUCT; STA FPULST; LDA =PUBPTR; STA PUBPTR; STA PUEPTR
       LDA ONE; STA CMPST
$SET6  LDX =-NPORT; LDA KM1; STA EWERIS,2; BRX *-1
       LDX =-NJOB; CLA; STA EPMTP,2; BRX *-1
       LDA K14; BRM SETFRE
       LDA K22; STA TS; SUB K15; SKN M48K; ADD EIGHT; STA TSA
FRLP   LDA TS; BRM SETFRE; MIN TS; SKR TSA; BRU FRLP
SET4   LDX     KM100
       LDA     EPOPTB,2
       STA     200B,2
       BRX     *-2
       LDX =WDTB-WDTE
       LDA WDTE,2; STA* WDTE+1,2; BRX *+1; BRX *-3
* MEMORY MAPPING
*   PAGE 7=LOG AND SET, PAGE 10=DISC, 11=W, 12=NET CODE AND TTY BUFFERS

       IF DISC=3
*   EXEC IS LOADED AT 12-16, NET AT 17. MOVE EXEC TO 15-21 AND NET TO 12
       LDA =17221222B
SET2   STA RRL1; LRR1; POT RRL1    SET UP TO MOVE A PAGE OF CODE
       LDX KM4B3; LDB 4000B,6; STB 10000B,6; BRX *-2
       SUB =0101B4; SKE =11141222B; BRU SET2
*      EXEC IS AT 15-21 AND NET IS AT 22. MOVE NET TO 12
       LDX KM4B3; LDB 20000B,6; STB 14000B,6; BRX *-2

       ELSF DISC<3

*      READ SYSNO FROM DISC AND PUT IN LOCATION 200B
       LDA K200; LDB =10B*4000B; BRM GDC
       LDA =10B6; STA RRL1; LRR1; POT RRL1; LDA 75B,4; LRSH 12; STA 200B

       LDA =DSCTBL; STA T4; BRU SET2
DSCTBL DATA 0,10B*4000B     DISC CODE
       DATA 40B,11B*4000B   W BFR CODE
       DATA 340B,12B*4000B  NET CODE AND TYMNET BUFFERS
       DATA 100B,15B*4000B  EXEC PAGE 12
       DATA 140B,16B*4000B  EXEC PAGE 13
       DATA 200B,17B*4000B  EXEC PAGE 14
       DATA 240B,20B*4000B  EXEC PAGE 15
       DATA 300B,21B*4000B  EXEC PAGE 16
       DATA -1
SET2   LDB DISCN; LSH 24+13   (MUL BY 20000)
       ADD =20000B-400B+20000B  (20000-400 IS ARM POS 62)
*             20000 MOVES UP 1 DISC TO SECOND HALF OF SYSTEM
       ADD* T4; MIN T4; LDB* T4; MIN T4
       BRM GDC    GET DISC TO CORE
       SKN* T4; BRU SET2
       ARMI AIRWD

       ENDF

* COPY SET PAGE TO REAL PAGE 13B, SO BUFFERLET CODE IS MOVED TO SMT 20
       LDA =07134040B; STA RRL1; LRR1; POT RRL1
       LDX KM4B3; LDB 4000B,6; STB 10000B,6; BRX *-2
* SET SMT'S AS GRABBED PAGES
       LDX =NSSMT-NSMT; LDA =1B7+1; STA SMTE,2; BRX *-1
       IF EXPMT; LDX =-NXSMT; STA EXSMTE,2; BRX *-1; ENDF
* SET MONITOR AND EXEC RMT'S AND RMC'S
       LDB K27; LDA =SMT; ADD ONE; LDX ONE; STB RMC,2; STA RMT,2
       ADD ONE; EAX 1,2; SKR MPGC; BRU *-5
       STB RMC; STA RMT; EAX 1,2
       ADD ONE; STB RMC,2; STA RMT,2     DISC CODE--SMT 10
       ADD ONE; EAX 1,2
       STB RMC,2; STA RMT,2    BITMAP AND HOLE TABLE--SMT 11
       CLB; EAX 3,2            SKIP OVER NET PG 12-13-14
* EXEC IN REAL PAGES 15-16-17-20-21 (SMT 12-16)
       ADD ONE; EAX 1,2; STB RMC,2; STA RMT,2; SKR EPGC; BRU *-5
* SMT 20 IN REAL PAGE 13
       LDA =SMT; ADD K20; LDX K13; STB RMC,2; STA RMT,2
       LDA =SMT; ADD TEN; STA T; LDX KM5; STX T2
       BRM REL; MIN T; LDA T; LDX T2; BRX *-5
       LDA =SMT; ADD K20; BRM REL
       LDX =20200007B; STX SMTPG7; LDA =SMTPG7; STA RMT,2
       BRM TYMSET
       BRR SSET
SMTAD  DATA    SMT
EXP    DATA    3               NO. OF EXEC PAGES -1.
MPGC   DATA    5               NO. OF MONITOR PAGES-1
EPGC   DATA    4               NO. OF EXEC PAGES-1+FIO
*
*
SETFRE ZRO; STA TS; CAX; LDA =32; BRM RAINS; LDX TS; LDA KM1
       STA RMT,2; CLA; STA RMC,2; BRR SETFRE
TS     ZRO
TSA    ZRO
*
*



WDTB   EQU *

* 16.NE.17 IDENTIFIES THIS MONITOR TO BASE FOR NETWORK CLOCK
       0; 0 16B
WDPIT  BRM TRAPI; 0 40B
WDIMT  BRM TRAPM; 0 41B
WDRMT  BRM TRAPR; 0 43B
WDUMT  BRM TRAPT; 0 44B
WD31   BRM INT31; 0 31B
WD33   BRM INT31; 0 33B
       IF DISC=3
       BRU 1; 0 1    KEEP FROM MONCRASHING ON TOO FAST BRING UP
       0 DRQ; 0 26B
       0 DRQU; 0 27B
       0 DRQ; 0 RQ1A
       0 DRQ; 0 RQ1
       0 DRQ; 0 RQ2
       0 DRQ; 0 RQ3
       ENDF
WDPWNI BRM PWNI; 0 36B
WDPWFI BRM PWFI; 0 37B
WDCP   BRM CPUP; 0 56B
WDIOP  BRM IOPI; 0 57B
       BRM RAI1; 0 64B
WDIDM  BRM RADI2; 0 65B
       IF FPH; BRM FPOVI; 066B; ENDF
CLOCK2 BRM CLINT; 0 74B
       SKR CLOCK3; 0 75B
       BRM MONCR; 0 201B
       BRM MONCR; 0 202B
       IF DISC=3; BRM IDM; 0 203B; ELSE; BRU 203B; 0 203B; ENDF
       BRM TQ; 0 204B
       BRM RCL; 0 205B
       BRU 206B; 0 206B
       BRM MONCR; 0 215B
       IF MDSI; 0 1; ELSF LEASCO; 0 2; ELSE; 0; ENDF; 0 217B

WDTE   EQU *
*      
*      SYSPOP TRANSFER VECTOR
*
POPTB  BRM     TRAP          500B5
       BRM     TRAP
       BRM     TRAP
       BRM     TRAP
       BRM     TRAP          504B5
       BRM     TRAP
       BRM     TRAP
       BRM     TRAP
       BRM     TRAP          510B5
       BRM     TRAP
       BRM     TRAP
       BRM     TRAP
       BRU     SPTR1         514B5
       BRU     FFDIEF
       BRU     LDFMEF
       BRU     STFMEF
       BRU     FFADEF        520B5
       BRU     FFMPEF
       BRU     FFDVEF
       BRU     FFSBEF
       BRU     FFSIEF          524B
       BRU     RSPX
       BRU     SSPX
       BRU     LDFME
       BRU     STFME           530B
       BRU     RCPX
       BRU     SCPX
       BRU     PCEX
       BRU     CITS          534B5
       BRU     WCDP
       BRU     SNEX
       BRU     GCDP
       BRU     ISC1          540B5
       BRU     SIC1
       BRU     FFSBE
       BRU     FFSIE
       BRU     SKPX            544B5
       BRU     SKLX
       BRU     FFDVE
       BRU     FFDIE
       BRU     NIOISC        550B5
       BRU     NIOSIC
       BRU     FFADE
       BRU     HFDVE
       BRU     HFMPE         554B5
       BRU     HFSBE
       BRU     HFADE
       BRU     WCIP
       BRU     WIE           560B5
       BRU     CIE
       BRU     SKSGP
       BRU     SKSEP
       BRU     WCHP          564B5
       BRU     GCIP
       BRU     LDPP
       BRU     STPP
       BRU     SBRME         570B5
       BRU     SRB
       BRU     FFMPE
       BRU     BS
       BRU     TCIX          574B5
       BRU     TCOX
       BRU     BIOX
       BRM     TRAP
EPOPTB EQU     *

*      A BUFFER USED BY LOG (WHEN ASSEMBLED) IS DEFINED AT THE END 
*      OF SET BY THE LOAD MAP

       FORGET
       END
MONITOR ** FICHE/FRAME BREAK *****
SET SYMSORT

SYM.  PG.LN. IDENT.

CK205   1 39 SET     CKMEM   2 29 SET     CKRD    2 10 SET     
CKRDBF  2 27 SET     CKXMA   2  4 SET     CKXMA1  2  7 SET     CKXMA2  2  8 SET     
CLOCK2  7 16 SET     DR      1  5 SET     DRMSET  1 11 SET     DSCTBL  5 10 SET     
EPGC    6 17 SET     EPOPTB  9 17 SET     EXP     6 15 SET     FRLP    4 23 SET     
MP1     2 32 SET     MP2     2 33 SET     MP2A    2 34 SET     MP7     3  3 SET     
MP8     3  2 SET     MP9     3  1 SET     MPGC    6 16 SET     POPTB   7 31 SET     
PROTEC  1 21 SET     RADTYM  3 10 SET     RM1     3 15 SET     RW1     1 25 SET     
RW2     1 28 SET     RW3     1 31 SET     RW4     1 34 SET     SET1    4  9 SET     
SET2    5 19 SET     SET2    4 36 SET     SET3    4 15 SET     SET4    4 24 SET     
SET6    4 19 SET     SET7    3 30 SET     SET9    3 28 SET     SETFRE  6 20 SET     
SETSA   3 22 SET     SMTAD   6 14 SET     SSET    4  2 SET     TS      6 22 SET     
TSA     6 23 SET     WD31    6 37 SET     WD33    6 38 SET     WDCP    7 11 SET     
WDIDM   7 14 SET     WDIMT   6 34 SET     WDIOP   7 12 SET     WDPIT   6 33 SET     
WDPWFI  7 10 SET     WDPWNI  7  9 SET     WDRMT   6 35 SET     WDTB    6 29 SET     
WDTE    7 27 SET     WDUMT   6 36 SET     
MONITOR ** FICHE/FRAME BREAK *****
SPBS
SPBS   IDENT 11/14/75
       NOLIST STAT,EXT
       ENTRY MLUDL,FHASH,RBLK,INITS,RDDNUM,RDD3,SETN12,CRLF
       ENTRY LUDPOS,PONO,PDNO,PRCHR,TWD,BRS11,BRS29,CLEAN,CLSCFI
       ENTRY TAB2,TAB3


* CALCULATE LUD LOCATOR FROM X
MLUDL CXA; ETR K3S4; SUB =BFR; CLB; LSH 10; MRG T3 (HASH LOC); BRR 0

* FINDS HASH LOC. IN LUD GIVEN PTR TO NAME IN X
FHASH  LDA 0,2; ADD 1,2; ADD 2,2; ADD 3,2; LRSH 23
       DIV =887; STB T3 (SAVE HASH LOC.); BRR 0

* READS LUD BLOCK INTO DISC TEMP. BUF.
RBLK   LDA T3; LRSH 23; DIV =200B (ENTRIES PER DISC)
       STB T4; CLB; LSH 13; ADD T4; ADD =320200B (FIRST DISC ADR.)
       CAB; STA T4; LDA =BFR; LDX K100
       BRS 124; LDX =BFR; BRR 0

* INITIALIZE SELECT ARRAY
INITS  LDX =-NPORT; STB SEL+NPORT,2; BRX *-1
       SKB KM1; BRU *+2; LDX =-2; STX HDSW; BRR 0

* READ DECIMAL NO.  RETURNS A=TERMINATOR AND B=NUMBER
RDDNUM LDA KM1; STA CHSW
RDD1   SBRM NXCH
RDD3   SKG =31B; SKG =17B; BRU RDD2; SUB =20B
       XMA ACCUM; MUL =10; LSH 23; ADM ACCUM; BRU RDD1
RDD2   ABC; XMA ACCUM; XAB; SKE CRCH; SNE LFCH; STA CHSW
       BRR 0

* SET SELECT ARRAY = -1 FROM T1 TO T2.  NONSKIP IF T1 OR T2 OUT OF RANGE.
SETN12 LDA T2; SKG =NPORT-1; BRU *+2; BRR 0
       LDA T1; SKG T2; SKG KM1; BRR 0; LDB KM1
SETN1A CAX; STB SEL,2; MIN T1; MIN HDSW
       LDA T1; SKG T2; BRU SETN1A
       BRU SKPR

* SKIP IF NOT CR OR LF AND SET CHSW CORRECTLY
CRLF   STA CHSW; LDA KM1; XMA CHSW; SKE CRCH; SNE LFCH; BRU *+3
SKPR   MIN 0; BRR 0
       MIN CHSW; BRR 0

LUDPOS EQU *  CALCULATE LUD POSITION
       RSH 23; DIV =128; STB OFFSET; CLB; LSH 13
       ADD =320200B; ADD OFFSET; BRR 0
* PRINT DECIMAL NO.
PDNO   LDB TEN; BRU PONO+1

*PRINT OCTAL NUMBER
PONO   LDB =8; LDX POUT; BRS 36; BRR 0

*PRINT CHAR FROM 'B' AND SKIP
PRCHR  XAB; CIO POUT; XAB; BRU SKPR


* TYPE 3 CHARS FROM B REGISTER.  SAVE 'X'
TWD    STX SV3; LDX =-3; LCY 8; CIO POUT; BRX *-2; BRU XPOP
* CLEAR INPUT BUFFER.  KILL REPEAT COUNT.
BRS11  LDX KM1; STX RPT; STX RPT1; BRS 11; CLA; STA CHSW; BRR 0

* CLEAR OUTPUT BUFFER
BRS29  LDX KM1; BRS 29; BRR 0

* RESET COMMANDS FILES TO TERMINAL
CLSCFI LDA OUTFIL; SKE TOUT; BRS 20; BRS 181; STP CIN
       STB POUT (=1)
       STB OUTFIL (=1)
       BRR 0

* RESET MONITOR SNAP FILES AND MARK NO MONITOR PRESENT
CLEAN LDA KM1; XMA INFIL; SKE KM1; BRS 20
       LDA KM1; XMA INFIL2; SKE KM1; BRS 20
       CLEAR; STA MSW (NO MONITOR PRESENT)
       BRR 0

* TAB 2 SPACES
TAB2   CLA; BRU TAB3+2

* TAB 3 SPACES
TAB3   CLA; CIO POUT; CIO POUT; CIO POUT; BRR 0

       END
MONITOR ** FICHE/FRAME BREAK *****
SPBS SYMSORT

SYM.  PG.LN. IDENT.

BRS11   2 22 SPBS    BRS29   2 25 SPBS    CLEAN   2 34 SPBS    
CLSCFI  2 28 SPBS    CRLF    2  2 SPBS    FHASH   1 12 SPBS    INITS   1 22 SPBS    
LUDPOS  2  6 SPBS    MLUDL   1  9 SPBS    PDNO    2 10 SPBS    PONO    2 13 SPBS    
PRCHR   2 16 SPBS    RBLK    1 16 SPBS    RDD1    1 27 SPBS    RDD2    1 30 SPBS    
RDD3    1 28 SPBS    RDDNUM  1 26 SPBS    SETN12  1 34 SPBS    SETN1A  1 36 SPBS    
SKPR    2  3 SPBS    TAB2    3  1 SPBS    TAB3    3  4 SPBS    TWD     2 20 SPBS    

MONITOR ** FICHE/FRAME BREAK *****
TS
TS93   IDENT   09/29/76
*
* THE TS PAGE STRUCTURE IS:
*    EXEC AND MONITOR SHARED WORDS.
*    SPACE
*    FILE BUFFERS
*    TSMAPS: MISC. USER ORIENTED CELLS SUCH AS A,B,X.
* AS OF 3/14/73 THE EXEC  CELLS STOPPED AT 34606.
*               THE FIRST BUFFER WAS AT 35016.
*               TSMAPS BEGINS AT ABOUT 37676.
* THE FIRST BUFFER LOCATION MAY BE FOUND IN I AT BUF3+3.

       DELSYM
1ORG   EQU     *
LOCORG MACRO D;2ORG EQU *-1ORG; BSS D(1)-2ORG; ENDM

$X     EQU     34000B

       LOCORG  2

       IF      -EXEC

$SBRSRT ZRO
$WR4   BSS     30
$OUTNO1 ZRO
$OUTNO2 ZRO
$OUTNO3 ZRO
$OUTNO4 ZRO
$OUTNO5 ZRO
GSIN1  EXT     OUTNO1
GSIN2  EXT     OUTNO2
GSIN3  EXT     OUTNO3
STRO1  EXT     OUTNO1
STRO2  EXT     OUTNO2
STRO21 EXT     OUTNO3
STRO3  EXT     OUTNO4
GETNO1 EXT     OUTNO1
GETNO2 EXT     OUTNO2
GETNO3 EXT     OUTNO3
GETNO7 EXT     OUTNO5
$WR1   ZRO
$WR2   ZRO
$WR3   ZRO
$WR31  ZRO
$WR5   ZRO
$WR6   ZRO
$WR7   ZRO
$WR8   ZRO
$WR9   ZRO
$WR10  ZRO
$WR11  ZRO
$WR12  ZRO
$WR13  ZRO
       BSS     2               USED BY EXEC
$UPL   ZRO     0    EXEC BRS PANIC TABLE.
$UBA   ZRO
$UBB   ZRO
$UBX   ZRO
$UBRL1 ZRO
$UBRL2 ZRO
$UBE   ZRO
$UCIN  ZRO
$UCOUT ZRO
$UUNO  ZRO
       ZRO

       LOCORG  105B

$EXRL1 ZRO 0                   (FIRST HALF OF EXEC RELABELING)
$EXRL2 ZRO 0                   (2ND HALF OF " ")
$UPRRL1 ZRO 0                  (1ST HALF OF PROG. RELABELING)
$UPRRL2 ZRO 0                  (2ND HALF OF " ")
$SSRL1 ZRO 0                   (FIRST HALF OF SUBSYSTEM RELABELING)
$SSRL2 ZRO 0                   (2ND HALF OF " ")
$UREAL ZRO 0                   (NO. OF CLOCK TICS AT LOGIN)
$EXECL BSS     6    EXEC PANIC TABLE.
$UEXL6 ZRO
$EXECLM EQU    EXECL-34000B
$ERCODE ZRO

       ELSF    1

       ZRO
$XWR4  BSS     30
XWR41  EXT     XWR4+1
XWR42  EXT     XWR4+2
XWR43  EXT     XWR4+3
XWR44  EXT     XWR4+4
XWR45  EXT     XWR4+5
XWR46  EXT     XWR4+6
XWR47  EXT     XWR4+7
XWR4E  EXT     XWR47+1
XWR4E8 EXT     XWR4E+8         FOR 8 RESOURCES
       BSS     5
$XWR1  ZRO
$XWR2  ZRO
$XWR3  ZRO
$XWR31 ZRO
T1     ZRO
T2     ZRO
T3     ZRO
T4     ZRO
T5     ZRO
T6     ZRO
T7     ZRO
T8     ZRO
T9     ZRO
T10    ZRO
T11    ZRO
$UBRSRT ZRO    0               REFERENCE FOR XT1-11 SEE AF
$BASE  BSS 0
$UA    ZRO
$UB    ZRO
$UX    ZRO
$CMRL1 ZRO
$CMRL2 ZRO
$UE    ZRO
$CIN   ZRO
$COUT  ZRO
$UNO   ZRO
$MSW   ZRO

       LOCORG  105B

$EXRL1 ZRO
$EXRL2 ZRO
$PRGRL1 ZRO
$PRGRL2 ZRO
$SSRL1 ZRO
$SSRL2 ZRO
$UREAL ZRO
$EXECL ZRO
$EXECA ZRO
$EXECB ZRO
$EXECX ZRO
$EXECR BSS     2
$EXECL6 ZRO
$ERCODE ZRO


EXRL   EXT     EXRL1
PRGRL  EXT     PRGRL1
SSRL   EXT     SSRL1
$REMAC ZRO 0                   (ACCT FOR COMMANDS FILE REMOTE LICENSE)
$ANO   ZRO 0                   (ACCT NO)
$FDLUDL ZRO 0                  (FILE DIRECTORY LUD LOCATOR)
$LUDL  ZRO     0               LUD LOCATER FOR THIS USER (SAME WERIS)
$FDUN  ZRO 0                   (FILE DIRECTORY USER NO)
$GRU   ZRO 0                   (CURRENT GROUP NO)
$NGRP  ZRO 0                   (NO. OF GROUPS)
$CR3   ZRO
$LUDWD5 ZRO
$UDMIN  ZRO
$MSZ2 BSS 1 (FORCE EXIT IF NON-NEGATIVE--CHECKED AT CRA)
$LDTEMP ZRO    0               STORAGE FOR DISC. BUF. LOCATION
$SW60  ZRO     0               BRS 48/60 SW., NEG. IF 48/60
$SWPRP ZRO     0               PROPRIETARY FILE SW.
$BRKTBL ZRO    0               BRKTBL FOR EXEC BRS'S
$FDAN  ZRO     0               FILE DIR. ACCT. NO.
$SWINIT ZRO    0               INITIAL COMMANDS-FROM FILE SW.
$AFSV4 ZRO     0               (TERMINAL ID)
$UNM   BSS     2               (USER NAME AT LOGIN (ASCII--NEXT 4 LOCS))
$UNM2  BSS     2
$UNMP  ZRO
$UNMP1 ZRO
$UNMPCF EQU    3*UNM-3*XWR1
$AFSV5 ZRO
$NMCHX ZRO
$ERRSW ZRO
$SWOFF BSS 1 (POSITIVE IF USER HAS BEEN ZAPPED AND OFFINT BEING DONE)
$SWTM  ZRO
$PJ    BSS     4
$EPJ   EQU     *
$FLPOS ZRO 0                   (FILE POS. NO. IN DIRECTORY)
$FLX   ZRO 0                   (FILE DIR. INDEX PTR)
$GRCT  ZRO 0                   (GROUP NO. OF LAST FILE ACCESSED)
$CMND  ZRO 0                   (BRS 142 EXEC COMMAND - 3 CHARS)
$GRP   ZRO 0                   (CURRENT FILE DIR. GROUP NO.)
$GAN   ZRO 0                   (GAN OF LAST FILE DIR. ACCESSED)
$OPDSTR ZRO 0                  (DISTRICT SET BY DS COMMAND)
$EBASE EQU     *
T12    ZRO
T13    ZRO
T14    ZRO
$TLV0  ZRO     0               ( MAX. ADR. 177B)

       LOCORG  210B

$DBF   BSS     128
$EDBF  EQU     *
$OVFP  EQU     DBF+124
$LFADR EQU     OVFP-2
$OVFP1 EQU     OVFP+1
$OVFP2 EQU     OVFP+2
$MTIME EQU     OVFP+3

$FDCONT ZRO
$SSTIME ZRO
$SSID  ZRO
$INFIL ZRO
ECRFIL EXT     INFIL
$OUTFIL ZRO
ECDFIL EXT     OUTFIL
$PVTSW ZRO
$OPNCN ZRO
$LETP  ZRO
$LGRS  ZRO
$RSREAL ZRO    0               FIRST RESOURCE STORAGE
$RSEND BES     7



* PANIC TABLES FOR EXEC FORKS

$EXSL  ZRO     0    PANIC TABLE FOR 'FILE' FORKS.
$EXSA  ZRO     0
$EXSB  ZRO     0
$EXSX  ZRO     0
$EXSR1 ZRO     0
$EXSR2 ZRO     0
$EXSM  ZRO     0
$SSL   ZRO     0    PANIC TABLE FOR GO, DUMP.
$SSA   ZRO     0
$SSB   ZRO     0
$SSX   ZRO     0
$SSR1  ZRO     0
$SSR2  ZRO     0
$SSM   ZRO     0
$GETSTL ZRO
$SYSTL ZRO

*EXEC TEMP. STORAGE
$TLV1  ZRO
$TLV11 ZRO
$TLV2  ZRO
$TLV21 ZRO
$TLV22 ZRO
$TLV23 ZRO
$TLV3  ZRO


* WORKING SPACE FOR EXEC BRS'S


GFN1   EXT     T10
$GOFNFT ZRO
FN2    EXT     T3
$UNPTR BSS     2
UNPTR1 EXT     UNPTR+1
$FNPTR BSS     2
FNPTR1 EXT     FNPTR+1
$GETPL ZRO     0
DEL1   EXT     T1
DEL2   EXT     T2
DEL3   EXT     T3
$UNO1  ZRO     0
DUMP1  EXT     T8
ECDMP6 EXT     T12
ECRV6  EXT     T12
DRSW9  EXT     T3
$GBIOPT ZRO    0
$GBIOFN ZRO    0
$GBIOSW ZRO    0
$GBIO2 ZRO     0
$GBIOCR ZRO    0
$GBIOC2 ZRO    0

$GBIO4 ZRO     0
* DO NOT REORDER DOWN TO SUSR2 WITHOUT MODIFYING NIO EXTERNALS

$GET1  ZRO
$GET2  ZRO
$GET3  ZRO
$GET4  ZRO
ZYEAR  EXT     GET4
$GET5  ZRO
ZMONTH EXT     GET5
$GET6  ZRO
ZDAY   EXT     GET6
$GETFN ZRO
ZHOUR  EXT     GETFN
$SUSR2 ZRO
ZMIN   EXT     SUSR2

$SUSR3 ZRO
ZSEC   EXT     SUSR3
$SRSU20 ZRO
ZMS    EXT     SRSU20
$SRSU21 ZRO
$SRSU3 ZRO
$SAVELL ZRO    0
$SAVEFL ZRO    0
$SAVEOR ZRO    0
$SAVESL ZRO    0

$MFFLAG BSS 1 (USED BY NIO)
DPFG2  EXT     MFFLAG

COPY1  EXT     SAVELL
COPYT  EXT     SAVESL
$SW58  ZRO     0               DOING BRS 58 (RENAME A FILE) IF NEG.
$PJCSW ZRO     0               PJC SW IF NOT ZERO HAS LUDL FOR PJC

*FOLLOWING 5 USED CHIEFLY BY NIO.  SEE MSGT POP.

$FIOW BSS 1 (NIO TEMP)
$DGTCNT BSS 1 (COUNT OF DIGITS TO OUTPUT)
$POST BSS 1 (POS.-> LEFT JUSTIFIED NO., POST BLANKS)
$IOD BSS 1 (DIGITS AFTER DEC POINT SPEC.)
$ERRNUM BSS 1 (NIO ERROR CODE)

*      PUSHDOWN STACK
$PDP   ZRO
$PDC   ZRO
$PDL   BSS     9


$S1    BSS 5 (USED BY BRS 1 CODE)
S2     EXT S1+1
FDNO   EXT S1+2
S4     EXT S1+3
S5     EXT S1+4
$RLSW  BSS 1 (SEE GTXFD CODE)
$DP    BSS 1 (DESIRED BUFFER IN PAGE 22)
$FDCBX BSS 1 (FDCBLE INDEX)
$FDCBT BSS 1 (TEMP)
$CHGFLG BSS 1 (BUFFER CHANGED FLAG)
$RLV4  ZRO
$TLV4  ZRO
$DSTRCT ZRO 0                  DISTRICT NO. FROM LUD ON NEW FILE
$NAST  ZRO 0                   (NASTY SWITCH TO FORCE KICKOFF)
*FOLLOWING 2 LOCS. NOT NECESSARY IF LUD IS READ FOR PROJ. COM.
$AFSV6 ZRO
$AFSV7 ZRO
$SXWR31 ZRO
$GOREMA ZRO
$OPTM  ZRO     0               TIME CONTROL OF OPERATOR STATUS
$TUZN  ZRO     0               USED BY CDX IN AF FOR TEMP STOR UZONE
$TCZN  ZRO

XT1    EXT     T1
XT2    EXT     T2
XT3    EXT     T3
XT4    EXT     T4
XT5    EXT     T5
XT6    EXT     T6
XT7    EXT     T7
XT8    EXT     T8
XT9    EXT     T9
XT10   EXT     T10
XT11   EXT     T11
XT12   EXT     T12
XT13   EXT     T13
XT14   EXT     T14
XT15   EXT     FIOW
XT16   EXT     DGTCNT
XT17   EXT     POST
XT18   EXT     IOD
XT19   EXT     ERRNUM
$XTE   ZRO     0
$SGOREM BSS 1 (SAVED "GO" REMOTE ACCT)
$SREMAC BSS 1 (SAVED "COMMANDS" REMOTE ACCT)
$BUDGET BSS 1 (BUDGETED CPU SECONDS FROM LUD WORD 5)

* NIO EXTERNALS 11/14/73

OVFLFG EXT XWR4+33 (CONVERSION OVERFLOW)
IOW EXT T4 (FIELD WIDTH SPEC)
IOFMT EXT T5 (FORMAT SPECIFICATION)
DEXP EXT T6 (DECIMAL EXPONENT)
IODEXP EXT T7 (BINARY EXPONENT)
SIGN EXT T8 (FLAG FOR SIGN OF FRACTIONAL PART)
NCONV EXT T9 (TEMP)
IOFILE EXT T11 (FILE NO. FOR BRS 52,53)
NIO1 EXT T12 (1ST WORD OF D'E P'N ACCUMULATOR)
NIO2 EXT T13 (2ND  "  )
NIO3 EXT T14 (3RD  "  )
NIO4 EXT TLV1
NIO5 EXT TLV2
NIO6 EXT TLV21
NIO7 EXT TLV22
NIO8 EXT TLV23
NIO9 EXT TLV3
IOPTR EXT FNPTR
IOPTR1 EXT FNPTR1
* FLAGS CLEARED IN BRX LOOP
NODOTFG EXT GET1 (FLAG TO SUPRESS DEC. PT)
DPFG EXT GET2 (DOUBLE PREC FLAG)
FMT4FG EXT GET3 (NIO FORMAT 4 FLAG)
OVFL EXT GET4 (ASTERISK OVERFLOW ACTION FLAG)
SD EXT GET5 (SMALL D)
SE EXT GET6 (SMALL E)
BD EXT GETFN (BIG D)
NFLAGE EXT SUSR2 (END OF FLAGS CLEARED IN BRX LOOP)
NIO10 EXT SAVELL
NIO11 EXT SAVEFL
NIO12 EXT SAVEOR
DPFLAG EXT SAVESL
ODOTFG EXT GBIO2 (USED TO PUT OUT .)
SIGNEX EXT RLV4 (SIGN OF EXPONENT FLAG)
SHRTRM EXT TLV4 (FLAG USED TO SHORT TERMINATE SIC)

       ENDF

       LOCORG  600B
$LMCPU ZRO
$SVST  ZRO     0               SUPERVISOR START IF NEG.

$RPCHG ZRO
$RPMAX ZRO
$RPN   ZRO
$UZONE ZRO
$UEXFLG BSS 0
$EXFLAG ZRO
$UFIO BSS 0
$FIO BSS 1 (-1 FOR NIO, POS. FOR FIO)
$TSVER BSS 1 (SPACE FOR TS VERIFICATION WORD)
$SCHDLY BSS 1 (SCHEDULER DELAY PARAMETER)
       IF CEM
$CVSW  DATA 0 (CONTROL V SWITCH)
$CRSW  DATA -1 (NEG. UNTIL 1ST TIME THRU CR)
$TLCNR DATA -1 (LINE BUFFER CHAR COUNT)
$TLBUF DATA 0 (LINE BUFFER)
 BSS 42
 ENDF

       IF      -EXEC

       FORGET
       ENDF

       END
MONITOR ** FICHE/FRAME BREAK *****
TS SYMSORT

SYM.  PG.LN. IDENT.

1ORG    1 14 TS93    AFSV4   5  5 TS93    AFSV5   5 11 TS93    
AFSV6   9 21 TS93    AFSV7   9 22 TS93    ANO     4 28 TS93    BASE    3 33 TS93    
BD     11  3 TS93    BRKTBL  5  2 TS93    BUDGET 10 12 TS93    CHGFLG  9 15 TS93    
CIN     4  1 TS93    CMND    5 21 TS93    CMRL1   3 37 TS93    CMRL2   3 38 TS93    
COPY1   8 26 TS93    COPYT   8 27 TS93    COUT    4  2 TS93    CR3     4 34 TS93    
CRSW   11 31 TS93    CVSW   11 30 TS93    DBF     5 33 TS93    DEL1    7 19 TS93    
DEL2    7 20 TS93    DEL3    7 21 TS93    DEXP   10 19 TS93    DGTCNT  8 34 TS93    
DP      9 12 TS93    DPFG   10 37 TS93    DPFG2   8 24 TS93    DPFLAG 11  8 TS93    
DRSW9   7 26 TS93    DSTRCT  9 18 TS93    DUMP1   7 23 TS93    EBASE   5 25 TS93    
ECDFIL  6  8 TS93    ECDMP6  7 24 TS93    ECRFIL  6  6 TS93    ECRV6   7 25 TS93    
EDBF    5 34 TS93    EPJ     5 17 TS93    ERCODE  4 21 TS93    ERCODE  3  1 TS93    
ERRNUM  8 37 TS93    ERRSW   5 13 TS93    EXECA   4 16 TS93    EXECB   4 17 TS93    
EXECL   4 15 TS93    EXECL   2 37 TS93    EXECL6  4 20 TS93    EXECLM  2 39 TS93    
EXECR   4 19 TS93    EXECX   4 18 TS93    EXFLAG 11 24 TS93    EXRL    4 24 TS93    
EXRL1   4  8 TS93    EXRL1   2 30 TS93    EXRL2   4  9 TS93    EXRL2   2 31 TS93    
EXSA    6 21 TS93    EXSB    6 22 TS93    EXSL    6 20 TS93    EXSM    6 26 TS93    
EXSR1   6 24 TS93    EXSR2   6 25 TS93    EXSX    6 23 TS93    FDAN    5  3 TS93    
FDCBT   9 14 TS93    FDCBX   9 13 TS93    FDCONT  6  2 TS93    FDLUDL  4 29 TS93    
FDNO    9  8 TS93    FDUN    4 31 TS93    FIO    11 26 TS93    FIOW    8 33 TS93    
FLPOS   5 18 TS93    FLX     5 19 TS93    FMT4FG 10 38 TS93    FN2     7 13 TS93    
FNPTR   7 16 TS93    FNPTR1  7 17 TS93    GAN     5 23 TS93    GBIO2   7 30 TS93    
GBIO4   7 34 TS93    GBIOC2  7 32 TS93    GBIOCR  7 31 TS93    GBIOFN  7 28 TS93    
GBIOPT  7 27 TS93    GBIOSW  7 29 TS93    GET1    7 37 TS93    GET2    7 38 TS93    
GET3    7 39 TS93    GET4    8  1 TS93    GET5    8  3 TS93    GET6    8  5 TS93    
GETFN   8  7 TS93    GETNO1  1 37 TS93    GETNO2  1 38 TS93    GETNO3  1 39 TS93    
GETNO7  2  1 TS93    GETPL   7 18 TS93    GETSTL  6 34 TS93    GFN1    7 11 TS93    
GOFNFT  7 12 TS93    GOREMA  9 24 TS93    GRCT    5 20 TS93    GRP     5 22 TS93    
GRU     4 32 TS93    GSIN1   1 30 TS93    GSIN2   1 31 TS93    GSIN3   1 32 TS93    
INFIL   6  5 TS93    IOD     8 36 TS93    IODEXP 10 20 TS93    IOFILE 10 23 TS93    
IOFMT  10 18 TS93    IOPTR  10 33 TS93    IOPTR1 10 34 TS93    IOW    10 17 TS93    
LDTEMP  4 38 TS93    LETP    6 11 TS93    LFADR   5 36 TS93    LGRS    6 12 TS93    
LMCPU  11 16 TS93    LOCORG  1 15 TS93    LUDL    4 30 TS93    LUDWD5  4 35 TS93    
MFFLAG  8 23 TS93    MSW     4  4 TS93    MSZ2    4 37 TS93    MTIME   5 39 TS93    
NAST    9 19 TS93    NCONV  10 22 TS93    NFLAGE 11  4 TS93    NGRP    4 33 TS93    
NIO1   10 24 TS93    NIO10  11  5 TS93    NIO11  11  6 TS93    NIO12  11  7 TS93    
NIO2   10 25 TS93    NIO3   10 26 TS93    NIO4   10 27 TS93    NIO5   10 28 TS93    
NIO6   10 29 TS93    NIO7   10 30 TS93    NIO8   10 31 TS93    NIO9   10 32 TS93    
NMCHX   5 12 TS93    NODOTF 10 36 TS93    ODOTFG 11  9 TS93    OPDSTR  5 24 TS93    
OPNCN   6 10 TS93    OPTM    9 25 TS93    OUTFIL  6  7 TS93    OUTNO1  1 25 TS93    
OUTNO2  1 26 TS93    OUTNO3  1 27 TS93    OUTNO4  1 28 TS93    OUTNO5  1 29 TS93    
OVFL   10 39 TS93    OVFLFG 10 16 TS93    OVFP    5 35 TS93    OVFP1   5 37 TS93    
OVFP2   5 38 TS93    PDC     9  2 TS93    PDL     9  3 TS93    PDP     9  1 TS93    
PJ      5 16 TS93    PJCSW   8 29 TS93    POST    8 35 TS93    PRGRL   4 25 TS93    
PRGRL1  4 10 TS93    PRGRL2  4 11 TS93    PVTSW   6  9 TS93    REMAC   4 27 TS93    
RLSW    9 11 TS93    RLV4    9 16 TS93    RPCHG  11 19 TS93    RPMAX  11 20 TS93    
RPN    11 21 TS93    RSEND   6 14 TS93    RSREAL  6 13 TS93    S1      9  6 TS93    
S2      9  7 TS93    S4      9  9 TS93    S5      9 10 TS93    SAVEFL  8 19 TS93    
SAVELL  8 18 TS93    SAVEOR  8 20 TS93    SAVESL  8 21 TS93    SBRSRT  1 23 TS93    
SCHDLY 11 28 TS93    SD     11  1 TS93    SE     11  2 TS93    SGOREM 10 10 TS93    
SHRTRM 11 11 TS93    SIGN   10 21 TS93    SIGNEX 11 10 TS93    SREMAC 10 11 TS93    
SRSU20  8 14 TS93    SRSU21  8 16 TS93    SRSU3   8 17 TS93    SSA     6 28 TS93    
SSB     6 29 TS93    SSID    6  4 TS93    SSL     6 27 TS93    SSM     6 33 TS93    
SSR1    6 31 TS93    SSR2    6 32 TS93    SSRL    4 26 TS93    SSRL1   4 12 TS93    
SSRL1   2 34 TS93    SSRL2   4 13 TS93    SSRL2   2 35 TS93    SSTIME  6  3 TS93    
SSX     6 30 TS93    STRO1   1 33 TS93    STRO2   1 34 TS93    STRO21  1 35 TS93    
STRO3   1 36 TS93    SUSR2   8  9 TS93    SUSR3   8 12 TS93    SVST   11 17 TS93    
SW58    8 28 TS93    SW60    4 39 TS93    SWINIT  5  4 TS93    SWOFF   5 14 TS93    
SWPRP   5  1 TS93    SWTM    5 15 TS93    SXWR31  9 23 TS93    SYSTL   6 35 TS93    
T1      3 21 TS93    T10     3 30 TS93    T11     3 31 TS93    T12     5 26 TS93    
T13     5 27 TS93    T14     5 28 TS93    T2      3 22 TS93    T3      3 23 TS93    
T4      3 24 TS93    T5      3 25 TS93    T6      3 26 TS93    T7      3 27 TS93    
T8      3 28 TS93    T9      3 29 TS93    TCZN    9 27 TS93    TLBUF  11 33 TS93    
TLCNR  11 32 TS93    TLV0    5 29 TS93    TLV1    6 38 TS93    TLV11   6 39 TS93    
TLV2    7  1 TS93    TLV21   7  2 TS93    TLV22   7  3 TS93    TLV23   7  4 TS93    
TLV3    7  5 TS93    TLV4    9 17 TS93    TSVER  11 27 TS93    TUZN    9 26 TS93    
UA      3 34 TS93    UB      3 35 TS93    UBA     2 17 TS93    UBB     2 18 TS93    
UBE     2 22 TS93    UBRL1   2 20 TS93    UBRL2   2 21 TS93    UBRSRT  3 32 TS93    
UBX     2 19 TS93    UCIN    2 23 TS93    UCOUT   2 24 TS93    UDMIN   4 36 TS93    
UE      3 39 TS93    UEXFLG 11 23 TS93    UEXL6   2 38 TS93    UFIO   11 25 TS93    
UNM     5  6 TS93    UNM2    5  7 TS93    UNMP    5  8 TS93    UNMP1   5  9 TS93    
UNMPCF  5 10 TS93    UNO     4  3 TS93    UNO1    7 22 TS93    UNPTR   7 14 TS93    
UNPTR1  7 15 TS93    UPL     2 16 TS93    UPRRL1  2 32 TS93    UPRRL2  2 33 TS93    
UREAL   4 14 TS93    UREAL   2 36 TS93    UUNO    2 25 TS93    UX      3 36 TS93    
UZONE  11 22 TS93    WR1     2  2 TS93    WR10    2 11 TS93    WR11    2 12 TS93    
WR12    2 13 TS93    WR13    2 14 TS93    WR2     2  3 TS93    WR3     2  4 TS93    
WR31    2  5 TS93    WR4     1 24 TS93    WR5     2  6 TS93    WR6     2  7 TS93    
WR7     2  8 TS93    WR8     2  9 TS93    WR9     2 10 TS93    X       1 17 TS93    
XT1     9 29 TS93    XT10    9 38 TS93    XT11    9 39 TS93    XT12   10  1 TS93    
XT13   10  2 TS93    XT14   10  3 TS93    XT15   10  4 TS93    XT16   10  5 TS93    
XT17   10  6 TS93    XT18   10  7 TS93    XT19   10  8 TS93    XT2     9 30 TS93    
XT3     9 31 TS93    XT4     9 32 TS93    XT5     9 33 TS93    XT6     9 34 TS93    
XT7     9 35 TS93    XT8     9 36 TS93    XT9     9 37 TS93    XTE    10  9 TS93    
XWR1    3 17 TS93    XWR2    3 18 TS93    XWR3    3 19 TS93    XWR31   3 20 TS93    
XWR4    3  6 TS93    XWR41   3  7 TS93    XWR42   3  8 TS93    XWR43   3  9 TS93    
XWR44   3 10 TS93    XWR45   3 11 TS93    XWR46   3 12 TS93    XWR47   3 13 TS93    
XWR4E   3 14 TS93    XWR4E8  3 15 TS93    ZDAY    8  6 TS93    ZHOUR   8  8 TS93    
ZMIN    8 10 TS93    ZMONTH  8  4 TS93    ZMS     8 15 TS93    ZSEC    8 13 TS93    
ZYEAR   8  2 TS93    
MONITOR ** FICHE/FRAME BREAK *****
TYM
TYM    IDENT 09/04/77

       LISTM


*      MDBG DEFINITIONS THAT ARE USEFUL TO HAVE  IN THE SYMBOL TABLE
       DEFINE ALARM,TBI,TBO,TP,TC,TRATE,TF1,TF3,TF4,T128,NPORT,NTBI,NTBO



*      CHARACTER PROPERTIES          ***********************************

*      CHARACTER PROPERTIES ARE LOOKED UP IN AN ARRAY OF 12 BIT
*      CHARACTER DESCRIPTOR BYTES. ON INPUT THE INDEX IS EXTERNAL ASCI,
*      ON OUTPUT IT IS INTERNAL ASCI. HENCE THE INPUT AND OUTPUT 
*      PROPERTIES OF A SINGLE CHR ARE IN 2 DIFFERENT DESCRIPTOR BYTES.
*      A CHR DESCRIPTOR TELLS WHICH BREAK TABLES THE CHR BREAKS ON IN
*      THE FIRST 3 BITS. THE NEXT BIT SAYS WHETHER CHR IS ECHOABLE.
*      NEXT IS THE CE BREAK BIT FOLLOWED BY A 4 BIT INPUT TYPE AND A 3 BIT
*                              OUTPUT TYPE.

*  CHARACTERS ARE DIVIDED INTO CLASSES FOR INPUT AND OUTPUT PROCESSING

*      7 LEVEL OUTPUT CHARACTER TYPES (INTERNAL ASCI)
*      MOST    TYPE 1          NORMAL PROCESSING
*      102     TYPE 2          TO102 PROCESSING
*      105     TYPE 3
*      135     TYPE 4          
*      152     TYPE 5
*      155     TYPE 6

* 7 LEVEL INPUT DIVISIONS ACCORDING TO EXTERNAL ASCI CODE
*      0       TYPE 12         DISCARD
*      1       TYPE 0          CONTROL-A (COMMAND EDIT)
*      2-10    TYPE 1          NORMAL
*      11      TYPE 7          PROCESS TAB CHR
*      12      2               TI12 PROCESSING
*      13-14   1               NORMAL PROCESSING
*      15      3               TI15 PROCESSING
*      16-20   1               NORMAL PROCESSING
*      21      14              CONTROL-Q (COMMAND EDIT)
*      22-26   1               NORMAL PROCESSING
*      27      15              CONTROL-W (COMMAND EDIT)
*      30-32   1               NORMAL PROCESSING
*      33      4               SOFT ESCAPE
*      34      13              CONTROL SHIFT L. (MDSI) OR SOFT ESCAPE
*      35      4               SOFT ESCAPE
*      36      6        CONTROL SHIFT N. USED TO MAP TO 04 SOMETIMES.
*      37      5               HARD ESCAPE
*      40-137  1               NORMAL PROCESSING
*      140-173 10              LOWER CASE
*      174-176 11              SOFT ESCAPE OR LOWER CASE
*      177     12              DISCARD

*      END OF CHARACTER PROPERTIES   **********************************

$TCC DATA 0 (INPUT BUFFER SPACE AVAIL (CHARS) SET BY BUILD TO [ETBUF-TBUF]*3
2TCC DATA 0 (20 PCT. THRESHOLD LEVEL = 6*[ETBUF-TBUF]/10
$1TCC DATA 0 (10 PCT. THRESHOLD LEVEL = 3*[ETBUF-TBUF]/10

$THIRD DATA 12525270B  MULTIPLY A BY THIS AND A IS DIVIDED BY 3 AND
*      B0 AND B1 CONTAIN REMAINDER. IF A STARTS OUT SIGNIFICANTLY MORE
*      THAN A LEGITIMATE CHR ADRS <0 TO 140000B> THEN THE QUOTIENT AND
*      THE 2 BIT REMAINDER BECOME ERRONEOUS. B0,B1 BECOME 3
*      ABOUT 1 FOURTH OF THE TIME WHEN A CHR ADRS IS CLOBBERED. THIS
*      CAUSES CRASHES ON EXU TGC5,2 INSTRUCTIONS.

$TTYASG EQU *; RPT NPORT; 0 37777B; ENDR

$ACDATA BSS NJOB ACTIVATION DATA. SEE BRS14,BRS81, BRS164.
$TT    BSS NPORT   RUN USER IF TT LESS THAN REAL.   6@ TT
$TF2   BSS NPORT  TF2 NOT IN PAGE 12 SO SCHEDULAR CAN CHECK OIH FLAG
$TF5   BSS NPORT
$TF6   BSS NPORT
$TTQHD DATA TTQHD-TF6
$TTQTL DATA TTQHD-TF6
$TTQ   ZRO
$TFREE DATA 2*2B5              VALUE OF FREE ENTRY IN TBI OR TBO
$TFREEC DATA -2*2B5-1          COMPLEMENT OF TFREE
$TPORT 0

* TABLES FOR MASKING, SHIFTING, AND UPDATING TERMINAL PARAMETERS

$TF3MSK DATA ECHOY+TABY+ELFY+ECRY
       DATA CRDY+IBRY
       DATA OBRY+PARY
       DATA PARAY+HDUXY
       DATA PARBY+PARXY
       DATA PARCY
$TF3SHF LRSH ECRZ
       LRSH IBRZ
       LRSH PARZ
       LRSH HDUXZ
       LRSH PARXZ
       NOP
$TF3TYP DATA 0*20B
       DATA 1*20B
       DATA 2*20B
       DATA 3*20B
       DATA 4*20B
       DATA 5*20B


$TCIX  STA SS01; STB SS02; STX SS03
       LDA* 0; STA* 0
       LDX UTTY; STX TPORT
       IF CEM
       LDB TF2,2; EAX TCI2; SKB =CEDY; BRU TCI3E
       SKN TLCNR; BRU TCI5E
       ENDF
       BRM MPTYM
       BRM TUGC; BRU TUDMS; BRM TUE
       BRM* TGCINC
TCI2   LDX SS03; STA* 0
TCIC7  BRM NPOPXB

       IF CEM
$TCIO   LDX UTTY; STX TPORT
       LDB K77; LDA TF2,2; SKM JOB; BRU CPORT7
       EAX TCIC7; SKA =CEDY; BRU TCI3E
       SKN TLCNR; BRU TCI5E
       BRM MPTYM
       ENDF
TCICIO BRM TUGC; BRU TUDMS; BRM TUE; STA SS01
TCI1   BRM* TGCINC; BRM NPOPX

$TCIT  LDX UTTY; STX TPORT
       IF CEM
       LDB TF2,2; EAX TCIT2; SKB =CEDY; BRU TCI3EL
       SKN TLCNR; BRU TCI5EL
       ENDF
       BRM MPTYM; BRM TUGC; BRU TUDMS
       XMA SS01; SKE SS01; BRM NPOPX
       MIN 0; BRM TUE; BRU TCI1
       IF CEM
TCIT2  STA SS01; BRM NPOPX

TCI5EL CLA; BRU *+2
TCI5E LDA KM1; STA TCLFLG; STX TCI5EX; LDB K4B7
       BRM MPWB; BRU TCI5

TCI3EL CLA; BRU *+2
TCI3E LDA KM1; STA TCLFLG; STX TCI5EX; LDB K4B7
       BRM MPWB; BRU TCI3
$TCI5EX ZRO
$TCLFLG ZRO
$CECHR ZRO
       BRM MPTYM; BRM TUGC; BRU TUDMS
       STA TUE9; BRM TUE; BRM* TGCINC; BRM MPWB
       BRR CECHR
       ENDF

TUCHR  0
TUCHRF 0
TUECHO 0

$TUGC   0
       LDX TPORT
TUGC1  LDB TF1,2; SKB =GOBY+IIHY+XOFFY; BRU TUGC3
TUGC2  BRM TGC; BRR TUGC; STA TUCHR; LDB TF1,2; SKB =8IY; BRU TUN8
       ETR K177; RCY 1; XXA; LDX T128,2; XXA
       SKB X4; RCY 12; STA TUCHRF
       LDB TUCHR; DIR; BRM TQD; EIR; STA TUECHO
       LDA TUCHRF; RCY 3; ETR K17
       ADD =2300004B+*; STA *+2; LDA TUCHR; EXU *
       IF CEM; BRU TUN; ELSE; BRM MONCR; ENDF
       BRU TUN; BRU TUN; BRU TUN; BRU TUN
       BRU TUN; BRU TU36; BRU TUN; BRU TULC
       BRU TUN; BRU TUIGNR; BRU TUN
       IF CEM; BRU TUN (14); BRU TUN (15); ENDF
TUGC3  SKB =GOBY; BRU TUGC4 (CHR GOBBLER RECEIVED OR BUFFER ZAPPED BY TWC);
       LDB TC,2; DIR; LDA TCC; SUB 2TCC (POS=> MORE THAN 20 PCT. AVAIL)
       XAB; SKG FOUR; BRU TUGC5 (RELIEVE B'PRESSURE UNCONDITIONALLY)
       SKG K40; SKB X4; BRU *+2
TUGC5  BRM TBACKP
       EIR; BRU TUGC2
TUGC4  LDA =-GOBY; ADM TF1,2; LDB K1B4; BRM TIIR; BRU TUGC1

TUDMS  LDB K4000; BRM TIIR
       LDX TPORT
       LDA TF1,2; MRG =DIY     (SET DISMISSED FOR INPUT)
       STA TF1,2; BRM RBALLS
       LDA =6B5+TT
TUDMS1 ADD TPORT; CAB; LDX =QTI; BRU NPOPDS
RBALLS 0;* RETURN YELLOW AND GREEN BALLS IF PENDING
       CAB; SKB =GREENY; BRU *+2   (RETURN GREEN BALL)
       BRU *+5; LDA =-GREENY; ADM TF1,2; LDA FIVE; BRM TROM
       LDA =YELY; EOR TF2,2; SKA =YELY; BRU RBALL1; STA TF2,2
       COPY XA,B; LCY 8; MRG =200376B; STA TPAIR2; EOR K377; BRM TROPAIR
RBALL1 EIR; BRR RBALLS

TUN    SUB K40
TUN1   ETR K177
TUN2   MIN TUGC; BRR TUGC

TUN8   LCY TERMCZ; EOR TF4,2; SKA =TERMCY; BRU TUN8A
       LDA =-1-8IY; DIR
       ETR TF1,2; STA TF1,2
       LDA =-1-BRKY; ETR TF2,2; MRG BRS12B+3; STA TF2,2
       EIR
TUN8A  CLA; STA TUECHO; LDA TUCHR; BRU TUN2

TU36   LDA FOUR; BRU TUN

TULC   LDB TF1,2; SUB  K40; SKB =LCIY; BRU TUN1; BRU TUN

TUIGNR BRM* TGCINC; BRU TUGC1

*TUE SENDS OFF THE ECHOS COMPUTED BY TQD AND SAVED BY TUGC.
* IT DOES THIS IF (JOB IS IN DEFERED ECHO MODE)&(PORT CAN ECHO)&
* (OUTPUT RING ISN'T NEARLY FULL).  IN THE LAST CASE IT DISMISSES.
TUE    0
       LDB TF1,2; SKB =DEY; SKB =7IY; BRR TUE
       LDB TUECHO; SKB KM1; SKN TF3,2; BRR TUE
       SKN TF2,2; SKN TROSW; BRU TVDMS
       STA TUE9; CBA
       STA TUE8; BRM TROTY1; LDA TUE8; LRSH 8; SKE ZERO; BRU *-5
       RST =MARY,TF1
       LDA TUE9; BRR TUE
$TUE9   0
$TUE8   0

TIIR   0;* GENERATE SOFTWARE INTERRUPT AT 210,211 OR 212 IF ARMED.
*      210     BFR CLEARED BUT CIRCUIT STILL VALID    (1B4)
*      211     DISMISS WILL OCCUR ON CIO IN OR OUT    (4B3)
*      212     BAD FILE NUMBER ON CIO. COULD BE A ZAPPED CIRCUIT. (2B3)
       STX TIIRX
       BRM MPPACT; LDX PACPTR; CBA; BRM RIIR
       BRM MPTYM; LDX TIIRX; BRR TIIR
TIIRX  0

$TCOX  EQU *
       STA SS01; STB SS02; STX SS03
       LDB* 0   GET CHARACTER TO BE OUTPUT
       BRM MPTYM
       LDX UTTY; STX TPORT; CBA; BRU TCO1
TCOCHR 0

$CIOT1A CAX
$CIOT1  BRM CPORT
       SKN CPORT9; BRU TCICIO (INPUT CIO); LDA SS01;*BRU TCO1 (OUTPUT);

TCO1   ETR K377; STA TCOCHR
       SKN TF2,2; SKN TROSW; BRU TVDMS
       LDB TF1,2; SKB =8OY+135Y; BRU TCO2
       BRM TO; BRM NPOPX
TCO2   SKB =135Y; BRU TCO3;* SKIP IF 8 LVL OUPUT
       BRM TROTY1; BRM NPOPX
TCO3   LDB TF4,2; SKB =135CY; BRU TCO3A (COUNTING IN PROGRESS)
*      COUNTER AT 0. SET COUNTER AND OUTPUT BLANKS
       LSH 135CZ; ETR =135CY; ADM TF4,2
TCO3A  LDA =135CY; SKA TF4,2; BRU TCO3B
       LDA =-135Y; ADM TF1,2; BRM NPOPX
TCO3B  SKN TF2,2; SKN TROSW; BRU TVDMS
       LDA =240B; BRM TROTY1
       LDB KM1; LSH 24+135CZ; ADM TF4,2; BRU TCO3A

$TVDMS  LDB K4000; BRM TIIR
       LDA =TF2+2B5; ADD TPORT; CAB; SKN TF2,2
TVDMS1 LDB TROSW1; LDX =QTI; BRU NPOPDS

$TROSW DATA -1
TROSW1 34B TROSW

TO     0
       ETR K177; RCY 1; XXA; LDX T128,2; XXA; SKB X4; RCY 12
       LDB TF1,2; ETR SEVEN; ADD =2300003B+*; STA *+1; EXU *
       BRM MONCR; BRU TON; BRU TO102; BRU TO105
       BRU TO135; BRU TO152; BRU TO155; BRM  MONCR

TON    LDA K40
       ADD TCOCHR; MRG K200
       BRM TROTY1
TON3   LDA =MARY; COPY AB,N; SKB TF1,2
TON2   ADM TF1,2; BRR TO

TO102  SKB =LCOY; BRU TON; LDA =212B; BRM TROTY1; BRR TO

TO105  SKB =LCOY; BRU TON; SKB =MARY; BRR TO
       LDA =MARY; ADM TF1,2
       LDA =215B; BRM TROTY1; BRR TO

TO135  LDA =135Y; SKA TF1,2; BRM MONCR; ADM TF1,2
       LDA =135CY; ETR TF4,2; CNA; ADM TF4,2
       BRU TON3

TO152  LDA =212B; BRM TROTY1
       LDB TF1,2; SKB =MARY; BRR TO
       LDA =215B; BRM TROTY1; LDA K377; BRM TROTY1
TO152A LDB TF1,2; SKB =MARY+MARSY; BRR TO
       LDA =MARY; BRU TON2

TO155  SKB =MARY; BRU TO155A
       LDA =215B; BRM TROTY1
TO155A LDA =212B; BRM TROTY1; BRU TO152A


*      204 INTERRUPT PROCESSING ***************************************

TQC    0 0   COUNTER FOR 204 INTERRUPTS
TQA    0
TQB    0
TQX    0
TQRL   0
TQRET  LDA TRCTIM; SKG REAL; BRU TRC
       LDA TQRL; MLABEL; LDA TQA; LDB TQB; LDX TQX; BRI TQ
$TQPORT 0
$TQTYPE 0
$TQCHR 0
TQCHRF 0

* 204 INTERRUPT ROUTINE.  TERMINAL CHARACTER INTERRUPT FROM BASE.
$TQ    0
       MIN TQC; STA TQA; STB TQB; STX TQX
       LDA RLTYM; MLABEL; STA TQRL

TQ1    BRM TRI; XMA TQTYPE  (SAVE CHR, GET TYPE);
       ADD =2300003B+*; XMA TQTYPE; EXU* TQTYPE
       BRM MONCR
       BRU TY1; BRU TQRET; BRU TY3; BRU TY4
       BRU TY5; BRU TY6; BRU TY7; BRU TY10
       BRU TY11; BRU TY12; BRU TY13; BRU TY14; BRU TY15

* TQD PUTS 0, 1, 2 OR 3 CHARACTERS IN A THAT SHOULD BE ECHOED JUST IN CASE
*IT IS LATER DETERMINED THAT THERE SHOULD BE AN ECHO.
TQD    0;* PUT ECHO CHR IN A WITH SIGN BIT OR 0 IF SHOULDNT ECHO
       SKA K400; SKN TF3,2; BRU TQD1
       STB TQDCHR; RCY 3
* PERMIT IMMEDIATE ECHO ON AUX CIRCUIT 5/17/76
       LDB TF1,2;* SKB =AUXY;* BRU TQD1
       ETR K17; ADD =2300003B+*; XMA TQDCHR; EXU* TQDCHR
       IF CEM; BRU TQD01; ELSE; BRM MONCR; ENDF; BRR TQD; BRU TQD12; BRU TQD15
       BRM MONCR; BRM MONCR; BRM MONCR; BRU TQTAB
       BRR TQD; BRR TQD; BRM MONCR; BRM MONCR (13)
       IF CEM; BRU TQD21 (14); BRU TQD27 (15); ENDF
TQD1   CLA; BRR TQD

TQDCHR 0

TQD12  LDB TF3,2; LDA =212B; SKB =ELFY; MRG =215B*4B2+377B*2B5; BRR TQD

TQD15  LDB TF3,2; LDA =215B; SKB =ECRY; MRG =212B*4B2; BRR TQD
       IF CEM
TQD01  LDB TF2,2; CLA; SKB =CEDY; LDA TQD01E; BRR TQD
TQD21  LDB TF2,2; CLA; SKB =CEDY; LDA TQD21E; BRR TQD
TQD27  LDB TF2,2; CLA; SKB =CEDY; LDA =334B; BRR TQD
       IF MDSI
TQD01E DATA 336B
TQD21E DATA 337B+215B*4B2+212B*2B5
       ELSE
TQD01E DATA 337B
TQD21E DATA 336B+215B*4B2+212B*2B5
       ENDF
       ENDF

TQTAB  LDB TF3,2; SKB =TABY; BRR TQD; BRU TQD1

TY1    LDB TF1,2; SKB =CONY; BRU TQ1; SKA =-10B; BRU TY1B
       ADD =2300003B+*; STA *+1; EXU *
       BRU TY1E0; BRU TY1E1; BRU TY1E2; BRU TY1E3
       BRU TY1E4; BRU TY1E5; BRU TY1E6; BRU TY1E7

TY1E0  EQU *   CHARACTER PAIR. PUT BOTH IN USER BUFFER.
       CLA; BRM TWC   FIRST THE ZERO
       MIN TY1E0F    (SET FLAG FOR TWC TO INDICATE CHAR PAIR)
       BRM TRI; CXA; EOR TWX; SKA ADMSK; BRM MONCR (WRONG PORT);
       LDA TQTYPE; SKE ONE; BRM MONCR
       LDA TQCHR; LDB TF1,2; BRU TY1B
$TY1E0F DATA -1   (CHARACTER PAIR FLAG FOR TWC ROUTINE)

*
* NEW RULES 01/15/73
*      COMMAND PORT            AUX PORT
*      SEND YELLOW             SEND YELLOW
*      REC. ORANGE->ACTIVATE    REC. ORANGE->ACTIVATE
*      REC. YELLOW->ACTIVATE   REC. YELLOW->REFLECT ORANGE
*
* 05/17/76  COMMAND PORT NOW TREATED LIKE AUXPORT
TY1E1  BRM TRI; SKG =375B; BRU TY1E1B
 SKE K377
 BRU TY1E1A  (ORANGE)
       LDB TF1,2
       SKB =DIY+RIY (CHECK FOR INPUT WAIT OR BRS 79 FLAG)
       BRU *+5; LDA =YELY; MRG TF2,2; STA TF2,2; BRU TQ1
       COPY XA,B; LCY 8; MRG =200376B; STA TPAIR2; EOR K377; BRM TROPAIR
       BRU TQ1
TY1E1A LDA =-1-ORAY; ETR TF2,2; STA TF2,2; ETR K77; AXC; STA ACDATA,2
       BRU TQ1
TY1E1B SKE =375B; BRU *+2; BRU TY1E2A
       LDB TF2,2; SKB =ORAY; BRU *+2; BRU TQ1
       CLB; LSH 135CZ; SUB =135CY; ADM TF4,2
       BRU TQ1

TY1E2  BRM CLIB
TY1E2A LDA TF1,2; SKA =LGY; BRU TY11A
       MRG =GOBY; STA TF1,2; BRU TQ1

TY1E3  EQU *   TYMNET REQUEST TO ZAP A CIRCUIT
       COPY XA,E; SKG ONE; BRU TY1E3C (DON'T ZAP SUP OR MAP)
TY1E3B MIN TFICTR; BRM TY1E3D; BRU TQ1
TY1E3C MIN NRTZAP; BRU TQ1
$TY1E3D ZRO
        DIR; LDB TF1,2; SKB =CONY; BRU TY1E3F
       SKB =AUXY; BRU TY1E3E; BRM TBIO; BRM TZAPR (DOES EIR)
       BRR TY1E3D
TY1E3E BRM TBRK; BRM TZAP (DOES EIR); BRR TY1E3D
TY1E3F EIR; BRR TY1E3D

TY1E4  EQU *   CHARACTERS FOLLOWING THIS ONE ARE ECHOED BY REMOTE
       RST =DEY,TF1; BRU TQ1

TY1E5  EQU *   GREEN BALLS ARRIVE HERE
       SKN TROSW; BRU TQ1  IGNORE GREEN BALLS IF RING NEAR FULL.
       SKB =DEFY; BRU TQ1 (IGNORE GREEN BALLS FOR PERMANENT DEFERRED ECHO)
       SKB =DIY+RIY; BRU TY1E5A  (CHECK FOR INPUT WAIT OR BRS 79 FLAG)
       SET =GREENY,TF1; BRU TQ1
TY1E5A LDA TQCHR; BRM TROM; BRU TQ1

TY1E6  LDA =-GREENY; SKB =GREENY; ADM TF1,2        RESET GREEN BALL FLAG
       SKN TROSW; BRU TQ1  DON'T SEND RED BALL BACK IF RING NEAR FULL
       BRU TY1E5A    RETURN RED BALL

TY1E7  EQU *   CHRS FOLLOWING THIS ONE HAVENT BEEN ECHOED BY REMOTE
       LDA =DEY; SKB =DIY; BRU *+4; LDA SEVEN; BRM TWC; LDA =7IY+DEY
       MRG TF1,2; STA TF1,2; BRU TQ1

TY1B   XAB; ETR =@RIY; STA TF1,2; XAB; SKB =8IY; BRU TY18
       ETR K177; LRSH 1; XXA; LDX T128,2; XXA; SKB X4; LRSH 12
       IF CEM; SKA K200; EOR =CEDY+200B; ENDF; STA TQCHRF
       RCY 3; LDB TF1,2; ETR K17; ADD =2300003B+*; STA *+1; EXU *
       IF CEM; BRU TY1N; ELSE; BRM MONCR; ENDF; BRU TY1N; BRU TY1N; BRU TY1N
       BRU TSOFT; BRU THARD; BRU TY36; BRU TY1N
       BRU TY1N; BRU TSSOFT; BRU TY1N; IF MDSI; BRU TQ1
       ELSE; BRM MONCR; ENDF
       IF CEM; BRU TY1N (14); BRU TY1N (15); ENDF

TY18   EQU *
       BRM TWC; BRM TBRK; BRU TQ1

TY1N   CBA; ETR =DEY+DIY; SKE =DEY+DIY; BRU TY1N1
       LDA TQCHRF; LDB TQCHR; BRM TQD; SKE ZERO; BRU *+2; BRU TY1N1
       SKN TF2,2; SKN TROSW; BRU TY1N2
       STA TY1N9; BRM TROTY1; LDA TY1N9; LRSH 8; SKE ZERO; BRU *-5
TY1N1  RST =MARY,TF1
       LDA TQCHR; BRM TWC
       LDA TQCHRF; ETR TF2,2
       IF CEM
       SKA =BRKY+CEDY
       ELSE
       SKA =BRKY
       ENDF
       BRM TBRK
       BRU TQ1
TY1N2  LDA =7IY; MRG TF1,2; ETR =-1-DIY; STA TF1,2
       SKN TY1E0F; BRU *+4; LDA SEVEN; BRM TWC; BRU TY1N1
* REPLACE 0 PREFIX WITH 7 AND APPEND 0 PREFIX
       LDA KM1; STA TY1E0F; ADM TC,2; MIN TCC
       LDA SEVEN; BRM TWC; CLA; BRM TWC; MIN TY1E0F; BRU TY1N1
TY1N9  0

TSSOFT SKB =LCIY; BRU TY1N
TSOFT  EQU * SOFT  ESCAPE PROCESSING
       SKB =AUXY; BRU TY1N
       LDB TF2,2; SKB =SOFTY+HARDY+B161Y+PUDY; BRU TQ1
       LDA TQPORT; SKE DEVCH; BRU *+4; LDB KM1; SKN WBIU; STB DEVCH
       LDX TTYASG,2; LDA PIM,2; LDX TQPORT; SKA K2B6; BRU *+2; BRM CLIB
       BRM TBRK; LDA =SOFTY; LDB =3B5
TSOFT1 ADM TF2,2; COPY XB,E; LDA TIC1; BRM EPU; MIN ACTR
       BRU TQ1


THARD  SKB =CONY; BRU TQ1
       SKB =AUXY; BRU TY1N
       LDB TF2,2; SKB =HARDY+B161Y+B168Y; BRU TQ1
       SKB =B113Y; BRU *+3; BRM TGOBBLE; BRM TBRK; BRM CLIB
       LDA =HARDY; LDB K4B5; BRU TSOFT1

TY36   EQU *   CONTROL SHIFT N
       LDA =204B; STA TQCHR; BRU TY1N1

TY3    LDA =IOBY; COPY AB,N; SKB TF5,2; SKN TF6,2; BRU TQ1
       ADM TF5,2
TY3A   MIN ACTR; BRU TQ1
TY4    CLB; BRU TY15A
TY13   LDB =CEOTY; BRU TY15A
TY14   LDB =CTIMY; BRU TY15A
TY15   LDA =TBBY; COPY AB,N; SKB TF5,2; ADM TF5,2
       LDA TQCHR; LDB =CTERY
TY15A  XAB; SKB K40 (HIGH ORDER BIT OF COUNT); MRG K400; STA TY15B
       STX TWX; BRM TRI; ADM TY15B; CXA; SKE TWX; BRM MONCR
       LDA TF5,2; SKA =IOBY; BRU *+2; BRU TQ1
       EOR TY15B; ETR =IOBY+CEOTY+CTIMY+CTERY+CHCY; EOR TF5,2
       STA TF5,2; BRU TY3A
TY15B ZRO

TY5    EQU *   RECEIVE RESPONSE FROM SUPERVISORY REQUEST HERE.
       LDB TF2,2; SKB =5OY; BRU *+2; BRU TQ1
       LCY 5AZ; ETR =5AY; LDB TF4,2; SKB =5AY; BRU *+2; ADM TF4,2
       LDA =-5OY; ADM TF2,2; BRU TQ1

TY6 EQU * BASE STORED NETWORK CLOCK INTO 16B AND 17B
* SUBTRACT RUN TIME IN SECONDS
 LDA REAL; RSH 23; DIV =60; CNA; ADD 17B; STA 17B
 LDA 16B; SUC ZERO; MRG X4; STA 16B; BRU TQ1

TY7    SET =OIHY,TF2; BRU TQ1

TY10   RST =OIHY,TF2; BRU TQ1

TY11   COPY XA,E; SKG ONE
$TY11B BRU TY11E (SUP OR MAP)
$TY11C LDA WERIS,2; SKE KM1; BRU TY11A (PORT IN USE)
       LDA TF2,2; SKA =JBY; BRU TY11A (PORT IN USE)
       LDA MAXNU; SKG NU
$TY11D BRU TY11Z
       LDA =CSTAY; SKA TF5,2; BRU TY11Z (PORT TEMPORARILY BUSY)
       MIN NU; MIN WERIS,2
       LDA NU; SKG SPARE1; BRU *+2; STA SPARE1
* SET TO 8 LVL INPUT AND NEVER BACKPRESSURE BIT (LG)
       LDA =8IY+LGY; STA TF1,2; LDA =TERMCY; STA TF4,2
       CLA; STA TF2,2; STA TF3,2; STA TRATE,2
       STA TF5,2 (TURN OFF CZY BIT)
       XMA TC,2; ADM TCC (TOTAL CHAR SPACE COUNT)
       LDB K1B5; COPY XB,E; LDA TIC1; BRM EPU; MIN ACTR
       LDX TQPORT; BRU TY1E7 (ENTER DEFERRED ECHO MODE);
TY11A  MIN NRTSON; BRU TY1E3B (TREAT LIKE ZAPPER REQUEST)
TY11Z  MIN NRTSON (COUNT LOGINS REJECTED)
       BRM TZAP       (OUT OF JOB SLOTS, SEND CIRCUIT ZAPPER BACK)
       BRU TQ1

TY12   EQU *   TQPORT IS NEW PORT. A REG. AND TQCHR IS COMMAND PORT.
       COPY AX,N; LDB TF2,2; SKB =5OY; SKG =-NPORT; BRU TY12A
       CXB; LDX TQPORT; LDA TF2,2; SKA =JBY; BRU TY12A (BUSY PORT)
       LDA TF5,2; SKA =CSTAY; BRU TY11Z (PORT TEMPORARILY BUSY)
       XXB; LSH 24+135CZ; SUB =135CY; ADM TF4,2
       LDA TF2,2 (COMMAND PORT); ETR K77; LDX TQPORT
       STB TF3,2; STB TF5,2; STA TF2,2
       LDA =TERMCY; STA TF4,2; LDA =8IY+AUXY; STA TF1,2
       CLA; XMA TC,2; ADM TCC
       BRU TQ1
TY12A  LDA TQPORT; SKG ONE; BRU TY11Z; BRU TY11A

TRC    EQU *
       LDA =90; ADM TRCTIM
       LDX =-NPORT
TRC1   LDA TF2+NPORT,2; ETR K77 JOB NUMBER
       SKG ZERO; BRU TRC2   NOT A VALID JOB
       ABC; XMA TRATE+NPORT,2   CLEAR RATE COUNTER
       XXB; ADM CCT,2; CBX  ADD A BUNDLE TO HIS CHR COUNT CHARGE
       LDB TC+NPORT,2; SKB KM400; BRU TRC3   LOTS OF CHARACTERS IN BFR
       LDB =RCY/3; SKG K15; LDB =-RCY/3; CBA  INCREMENT RC OR DECR RC
       ADD TF2+NPORT,2; EOR TF2+NPORT,2  DEPENDING ON CURRENT INPUT RATE
       SKA =-1-RCY; BRU TRC2  (OVERFLOWED THE 2 BIT FIELD);
       CBA; ADM TF2+NPORT,2 
TRC2   BRX TRC1
       BRU TQ1
TRC3   STX TRC3X; CXA; ADD =NPORT; CAX
       LDB =RCY; LDA =-RCY/3; SKB TF2,2; ADM TF2,2
       BRM TBRK; LDX TRC3X; BRU TRC2
TRC3X  0
TRCTIM 0

*      END OF 204 PROCESSING *******************************************


*      ROUTINES THAT INTERFACE WITH SCHEDULAR **************************

$TIP   LDX PUTTY; STX UTTY; LDX TIPIX
       EXU *+1,2; BRU TSON; BRU TSON; BRU TFIP; BRU TPUS; BRU TPUH

$TIC1  1 TIP
$TIPIX 0

TSON   LDA FPLST; SKN FULST; SKG ZERO; BRM MONCR
       LDA FULST; LDX PUTTY; ADM TF2,2; STA JOB
       XXA; XMA TTNO,2; STA FULST
* START UP EXEC FOR THIS USER
       BRM GFK; BRM MONCR; LDA =NUMEM; MUL JOB; LSH 23; STX PUPAC
       LDX JOB; ADD TSONC4
       SUB =NCMEM+NUMEM; STA PMTJOB; ADD =-20000000B+NCMEM; STA PMTP,2
       LDX PUPAC
* SET UP NEW PAC SLOT
       LDB JOB; LSH 39; ADD =EXECLM; MRG X6; STA PTAB,2
       LDB TIPIX; LSH 44
       ADD =1B7+6B2; STA PIM,2
       LDA PUPAC; LDX PUTTY; STA TTYASG,2
       LDX =QTI; BRM QPUT; LDX PUPAC
       LDA TSONC1; STA PL,2; LDA TSONC2; STA RL1,2; LDA TSONC3; STA RL2,2
       LDA SETPC2; STA PTEST,2; BRU NPUGO
TSONC2 DATA    011213B+NCMEM*1B6
TSONC3 DATA    1415B4
TSONC4 ZRO     PMT,2
TSONC1 ZRO     TSONI
SETPC2 13 PACDMB
*
TSONI  LDX =NCMEM; LDA* PMTJOB; MRG X2; STA* PMTJOB
       LDX PACPTR; LDA X1; ADM PTAB,2; LDA X4; STA XPB
       LDA RRL3; ETR K77; STA RLTS
       LDA =NLQU; STA LQ
       LDA =8457; STA FSIZE (USED IN BRS 1 TO SET FILE SIZE QUANTUM)
       LDA SEVEN; STA NFORK; LDA KM1; STA LMCPU
       LDX KM7; LDA TWO; STA PX,2; ADD ONE; BRX *-2
       LDA ONE; STA PPB
       LDA =MBUFX; STA FBWRD
       LDX PACPTR; LDA PIM,2; ETR K4B6; LRSH 44
       LDA PIM,2; ETR =73777777B; STA PIM,2; CBA; BRU EXECI,4
*
TFIP   LDX UTTY; LDA KM3; SKE WERIS,2; BRU TFIP2; MIN WERIS,2
       LDX TTYASG,2; STX TFIP3; BRM HFK; STX PUPAC
       LDX PUPAC; BRM RFK; LDA =QTI; BRM TFK
       BRM QPUT; LDX TF06; LDB TFIP1; STB PL,2
       LDA PIM,2; ETR =74000777B; STA PIM,2
       BRU NPUGO
TFIP2  MIN RBER; BRU NPUGO
TFIP1  ZRO OFFINT,4
TFIP3  ZRO 0

TPUS   EQU *   PU SOFT ESCAPE PROCESSING
       BRM MPTYM; LDX UTTY
       LDA =SOFTY; SKA TF2,2; BRU *+2; BRU NPUGO; CNA; ADM TF2,2
       LDA =PUDY; SKA TF2,2; BRU *+2; ADM TF2,2
       BRM MPPACT
       LDX TTYASG,2; LDA K2B6; BRM IIR; BRU TH1; BRU NPUGO

TPUH   EQU *   PU HARD ESCAPE PROCESSING
       BRM MPTYM; LDX UTTY
       LDA =HARDY; SKA TF2,2; BRU *+2; BRU NPUGO; CNA; ADM TF2,2
       LDA =PUDY; SKA TF2,2; BRU *+2; ADM TF2,2
       BRM CLIB; BRM MPPACT; LDX TTYASG,2; BRM HFK
TH1    STX PUPAC; CLB; SKN XPB; BRU *+2; STB UCIN
       BRM RFK; LDA =QTI; BRM TFK; BRM QPUT
       BRU NPUGO

*      TYMNET BRS S    ************************************************

$BRS11 EQU *   CLEAR INPUT BFR
       BRM CLIB
       IF CEM
       LDA TPORT; SKE UTTY; BRM NPOPX
       BRM MPPACT; CLA; STA TLBUF
       STA CVSW; LDA KM1; STA TLCNR
       BRU POPX
       ELSE
       BRM NPOPX
       ENDF

$BRS12 EQU *   SET ECHO TABLE
       IF CEM; SKA K4B4; CLX; ENDF; BRM GATT
       LDA SS01
       IF CEM
*      SKA =-1-8IY-8OY-LCIY-LCOY-XY-5677777B [ALLOW BITS 9,10, AND MODE]
*      BRM TRAP
       SKA K4B4; ETR =-1-8IY-8OY-3; STA SS01
       ELSE
       SKA =-1-8IY-8OY-LCIY-LCOY-XY-5637777B [ALLOW BITS 10 AND MODE]
       BRM TRAP BIT OTHER THAN 8IY,8OY,LCIY,LCOY,TABY/16,ELFY/16,ECRY/16
* OR MODE
       ENDF
       LDB =ECHOY; ETR =8IY+777B;; SKE THREE; SKA =8IY; CLB; STB T ECHO BIT
       LDA SS01; LCY 4; ETR =ELFY+ECRY; EOR =ELFY+ECRY 
       MRG T; EOR TF3,2; ETR =ECHOY+ELFY+ECRY; EOR TF3,2
       BRM TF3XMA     OUTPUT NEW TERMINAL CHARACTERISTICS IF ANY
       LDA TF4,2; ETR =TERMCY; CNA; ADM TF4,2
       LDA SS01; IF TERMCZ; LCY TERMCZ; ENDF; ETR =TERMCY; ADM TF4,2
       LDA SS01; ETR =8IY+8OY+3   ONLY 3 IS IN EXPONENT FIELD
       COPY AX,XB,A,E    CLEAR ECHO TABLE FROM A, CAX ETC.
       LDX BRS12B,2; XXB
* TURN OFF LG BIT UNCONDITIONALLY.
       DIR; EOR TF1,2; ETR =8IY+8OY+LGY; EOR TF1,2; STA TF1,2
       IF CEM
       LDA SS01; SKA K4B4; LDB =CEDY
       CBA; EOR TF2,2; ETR =BRKY+CEDY; EOR TF2,2
       XMA TF2,2; EOR TF2,2; EIR
       CAX; BRM MPPACT; CXA; SKA =CEDY; SKN TLBUF; BRU POPX
       LDA TLBUF; ETR K1S5; STA TLBUF; BRU POPX
       ELSE
       CBA; EOR TF2,2; ETR =BRKY; EOR TF2,2; STA TF2,2; BRU BS153A
       ENDF
BRS12B DATA BRKY/7*4,BRKY/7*2,BRKY/7,BRKY/7*4     BREAK TABLE BITS

$BRS13 EQU *  SKIP IF INPUT BFR EMPTY OR SKIP IF OUTPUT BACKPRESSURE.
       IF CEM
       LDA TPORT; SKE UTTY; BRU BRS13A
       BRM MPPACT
       SKN TLCNR; BRU POPX
       BRM MPTYM
       ENDF
BRS13A BRM TUGC; BRU NPOPX0; BRM NPOPX

$BRS14 EQU *   DISMISS UNTIL TERMINAL OUTPUT COMPLETED
       BRM TYEL; BRM MPPACT; LDA XX; BRU BRS81

$BRS24 EQU *   SET LCI AND LCO AND X-ON, X-OFF MODES
       ETR =XY+LCIY+8OY+LCOY+MARSY+MARY
       SKA =MARSY (BIT 10)
       EOR =MARSY+DEFY (MOVE MARS BIT TO DEF)
       STA T
       BRM GATT; LDA TF1,2
       ETR =XY+LCIY+8OY+DEFY+LCOY+MARY (BITS WE CAN TOGGLE)
       CNA; ADD T; ADM TF1,2
       LDA TF4,2; EOR SS01; ETR =MODY; EOR TF4,2; STA TF4,2
       BRM NPOPX


$BRS29 EQU *   CLEAR OUTPUT BFR
       CXA; SKE KM1; BRU *+2; LDX ONE
       BRM CPORT; SKN CPORT9; BRM TRAP
       SKN TROSW; BRU TVDMS
       BRM TGOBBLE
       BRM NPOPX

* BRS 32   CLEAN UP -2 AND -3 FOR MOST CASES.
* INPUT: X=CHANNEL NUMBER
$CLM2  LDA KM1; SKG WERIS,2; BRU POPX
       LDX TTYASG,2; LDA PTEST,2
       LDB FQJ4; ETR =77B5; SKE =7B5; STB PTEST,2; BRU POPX

$BRS40 EQU *   READ ECHO TABLE AND ECI,ELF,ECR,8I,8O,X (SEE MDBG FLAGS)
       LDA TF1,2; ETR =8IY+8OY+XY+LCIY+LCOY+MARY+RIY+DEFY
       SKA =DEFY; EOR =DEFY+MARSY (MOVE DEF BIT TO MARS)
       STA SS01
       LDA TF3,2; ETR =TABY+ECRY+ELFY; EOR =ECRY+ELFY; LRSH 4; ADM SS01
       LDA TF4,2; ETR =MODY; ADM SS01 (MODE BITS)
       SKN TF1,2; BRU B40B (NOT 8 LVL);* 8 LVL
       ETR =TERMCY
B40A   ADM SS01; BRM NPOPX
B40B   LDA =BRKY; ETR TF2,2; SKN TF3,2; CLA
       LDX =20-BRKZ; NOD 23-BRKZ; CXA; CNA (0,1,2 OR 3,BELEIVE IT OR NOT)
       IF CEM
       LDX TPORT; LDB TF2,2; SKB =CEDY; LDA K4B4
       ENDF
       BRU B40A


$BRS75 EQU * RETURN ADDR OF CURRENT BUFFERED TERMINAL I/O COMMAND
       LDA TF6,2; LRSH CADRZ
       EOR SS01; ETR K3777; EOR SS01; BRM NPOPXB

$BRS79 EQU *    RETURN CURRENT AND FUTURE GREEN AND YELLOW BALLS
       DIR
       LDA =RIY; MRG TF1,2; STA TF1,2
       BRM RBALLS; BRM NPOPX

$BRS85 EQU *   SET 8 LEVEL OUTPUT MODE
       LDA =8OY; SKA TF1,2; BRM NPOPX; BRU BRS86A

$BRS86 EQU *   CLEAR 8 LEVEL OUTPUT MODE
       LDA =8OY; COPY AB,N; SKB TF1,2
BRS86A ADM TF1,2; BRM NPOPX

$BRS87 EQU *   CONVERT PORT NUMBER IN X TO JOB NUMBER IN A
       LDA TF2,2; ETR K77; BRM NPOPXB


* INITIATE BUFFERED TERMINAL I/O

* 'A'=ADDRESS OF COMMAND 'X'=PORT
* NONSKIP RETURN WITH NO ACTION IF I/O IS NOT GOING.  IF 'B' IS
* NEGATIVE I/O WILL BE STARTED.
* FORMAT OF COMMAND LIST:
* WORD 0: FLAGS, SHOULD HAVE SIGN BIT ON PRIOR TO CALLING THIS BRS
*      BIT 0 - USE BIT (=1 INDICATES MONITOR THROUGH WITH THIS COMMAND)
*      BIT 1 - PROCESSING STOPPED DUE TO USE BIT ON
*      BITS 2-7 COPIED FROM BITS 2-7 OF TF5
*      BIT 8 - CHARACTER COUNT ERROR
*      BIT 9 - PAGECROSS ERROR
*      BIT 10 - COMMAND LIST ENDS WITH ZERO FORWARD PTR
* WORD 1: ADDRESS WITHIN SAME PAGE OF NEXT COMMAND
* WORD 2: COMMANDS OF FORM:
*      BIT 0: 0=OUTPUT,1=INPUT
*      BITS 1-9: CHARACTER COUNT
*      BITS 10-23: BUFFER ADDRESS.  ONLY BITS 13-23 WILL BE EXAMINED.
*      IT IS ASSUMED THAT THE COMMAND LIST AND ALL BUFFERS ARE IN THE
*      SAME PAGE.

$BRS97 SKN TROSW; BRU TVDMS
       LDB TF5,2; SKN SS02; SKB =CSTAY; BRU *+2; BRM NPOPX
       LDA SS01; COPY AX,A; SKN 0,6; TRAP; STA 0,6
       SKB =CSTAY; BRU B97A
* BACKPRESSURE PORT AND RETURN GREEN BALLS FOR INPUT COMMAND
       SKN 2,6; BRU B97B
       LDX TPORT; DIR; BRM BP; LDA TF1,2; BRM RBALLS (DOES EIR)
* CREATE TTQ ENTRY
B97B   LDA SS01
       LDX PACPTR; BRM MX01; SKG =NCMEM-1; TRAP; SUB =NCMEM; COPY AX,B
       LDA SS01; RSH 11; CXA; LSH CPGZ; STA T1
* MAKE THIS PORT THE END OF TTQ
       LDA TPORT; LDX TTQTL; STA TTQTL; BRM NMSK
       XMA TF6,2; LDX TPORT
       ETR K177; MRG T1; STA TF6,2; MIN TTQ
* SET UP COMMAND STATE = 1 (UNDECODED)
       LDA =1*CSTAY/7; DIR; XMA TF5,2; ETR =CZY; EIR; ADM TF5,2
B97A   MIN ACTR
       BRU NPOPX0

$NMSK  ZRO;* PRESERVE CONTENTS OF TF6 WHEN MODIFYING CNXT
       EOR TF6,2; ETR =CNXTY; EOR TF6,2; BRR NMSK

* ABORT BLOCK I/O
$BRS99 SKN TROSW; BRU TVDMS
       LDB =TBBY; BRM SIO; NOP
       SET =CABOY,TF5; BRM NPOPX

$BS112I BRM MPTYM
$BRS112 EQU *  SUICIDE BRS. REMOVE JOB FROM SYSTEM TABLES.
       BRM TZAP1 (MAYBE GET DISMISSED); BRM MPPACT
       LDX =NCMEM
BS112F LDA* PMTJOB; SKE ZERO; BRU BS112H
BS112G EAX 1,2; CXA; SKG K77; BRU BS112F
       LDX JOB; LDA X4; SKR NU; SKA TTNO,2; BRM MONCR
       COPY XA,B; STB PMTP,2
       XMA FULST; XMA TTNO,2; ETR K77
       SKE DEVCH; BRU *+3; LDB KM1; STB DEVCH
       CAX; LDA ADMSK; XMA TTYASG,2
       ADD =PPTR; XMA FPLST; STA* FPLST
       MIN PACFC (CURRENT PACT FREELIST CTR)
       LDB K77; LDX PUBPTR     CLEAR USER FROM P.U.
BS112A CXA; SKE =PUBPTR; BRU *+2; BRU BS112B
       LDA 3,2; SKM UTTY; BRU *+4; LDA PUDEAD; STA 1,2; MIN EXTPU
       LDX 0,2; BRU BS112A

BS112B COPY A,X; STA RELPG8
       EAX* PMTJOB; STX RELPG3 (SAME AS LDA PMTJOB,ETR ADMSK,STA RELPG3)
       LDX PACPTR; LDA RL1,2; LDB RL2,2; CLX; BRM RELMEM
       CLA; LDX JOB; SKE AUNN,2; MIN NB112; STA AUNN,2; STA CPARW,2
       LDA KM1; LDX UTTY; STA WERIS,2
       LDA JOB; LDB K77; SKM TF2,2; BRU PACGOA
       BRM MPTYM; BRM TZAP; BRM MPPACT
       BRU PACGOA
BS112H STX BS112D; BRM MDEL; LDX BS112D; BRU BS112G
BS112D 0

$BRS113 EQU *  INHIBIT SOFT AND HARD ESSCAPES FOR USER
       LDX UTTY; SET =B113Y,TF2; BRU POPX

$BRS114 EQU *  UNDO BRS 113
       LDX UTTY; LDA =-B113Y; LDB TF2,2; SKB =B113Y; ADM TF2,2
       SKB =SOFTY+HARDY; BRU BRS45  (DISMISS LONG ENOUGH FOR PU TO RUN);
       BRU POPX

$BRS126 EQU *  SEND YELLOW BALL WITHOUT DISMISS.  TEST ORANGE BALL
*              EXPECTED FLAG
       SKN SS01; BRM TYEL
       LDA TF2,2; SKA =ORAY; MIN 0; BRM NPOPX

$BRS129 EQU *  HANG PORT IN A IF IT IS A COMMAND PORT.
       SKG =NPORT-1; SKA X4; BRM TRAP; SKG ZERO; BRM NPOPX; CAX
B129A  DIR; SKN WERIS,2; BRM TZAPR; BRU BS153A

$BRS132 EQU *  READ TERMINAL CHARACTERISTICS OUT OF TF3
       LDA TF3,2; BRM NPOPXB

$BRS137 EQU *  LIST PORT NUMBERS IN HIS MEMORY. X POINTS TO HEAD OF LIST
       COPY XA,B; ETR ADMSK; ADD =4B7+1; STA T POINTS TO 2ND ENTRY 
       STB 0,6    PUT HIS COMMAND PORT AT HEAD OF LIST
       LDX =-NPORT; LDB =AUXY   APPEND AUXILIARY PORTS TO LIST
B137A  LDA TF2+NPORT,2; ETR K77; SKB TF1+NPORT,2; SKE JOB
       BRU B137B     NOT ONE OF HIS AUXILAIRY PORTS
       CXA     USER PORT NUMBER = MONITOR PORT INDEX TIMES 2 PLUS 10B.
       ADD =NPORT+4  (MONITOR INDEX+4); STA* T; ADM* T; MIN T
B137B  BRX B137A
       LDA T; SUB SS03; ETR ADMSK     LENGTH OF LIST
       BRM NPOPXB

$BRS138 EQU *  INITIATE SUPERVISORY REQUEST
       LDX UTTY; SKN TF2,2; SKN TROSW; BRU TVDMS; SET =5OY,TF2
       LDA =B138A; BRM B138C
       COPY XA,B; LSH 8; MRG =5*2B5; BRM TRO (SEND A TYPE 5); EIR
       LDA =32B5+TF2; ADD UTTY; CAB; LDX =QTI
       BRU NPOPDS
B138A  STB SS02; STX SS03
       LDA SBRSRT; STA 0
       BRM MPTYM; LDX UTTY
       LDA TF4,2; ETR =5AY; LRSH 5AZ; STA SS01   ERROR NUMBER FROM SUP
       LDA TF4,2; ETR =135CY;* A=135CY IF TYPE 12 DIDNT PRECEDE TYPE 5
       LRSH 135CZ; COPY AX,AB,N; SKG =-NPORT; BRM NPOPX (NO TYPE 12)
       LSH 25; ADD EIGHT; STA SS03   USERS X REG IS NEW CIRCUIT NUMBER
       BRM NPOPX
B138C  ZRO; XMA 0; STA SBRSRT; BRM MPTYM
       LDA =135CY+5AY; ETR TF4,2; CNA; ADD =135CY; ADM TF4,2
       LDA =-1-135Y; DIR
       ETR TF1,2; STA TF1,2; BRR B138C

$BRS139 EQU *
       LDB TF1,2; SKB =AUXY; BRU *+2; BRM TRAP
       BRM TZAP; BRM NPOPX

$BRS152 EQU *    RETURN TTY INPUT BUFFER CHARACTER COUNT IN A
       LDA TC,2; BRM NPOPXB

       IF SUPER
$BRS153 EQU *    SET CELL 211 WHICH POINTS TO SUP PAGE 0
       LDA RRL1; LRSH 18; ETR K37; AXC
       SKN SVST; BRM TRAP; SKE 211B; BRM TRAP; STX 211B
       LDA RMT,2; DIR; BRM B
       ENDF
BS153A EIR; BRM NPOPX

       IF SUPER
$BRS154 EQU *   RESET CELL 211
       CLA; SKE 211B; SKN SVST; BRM TRAP
       XMA 211B; CAX; LDA RMT,2
       DIR; BRM REL; BRM DRAGO
       BRU BS153A
       ENDF

$BRS155 EQU * (IF X IS INPUT PORT THEN SKIP IF NO CHRS RECEIVED, IF
*               X IS OUTPUT PORT THEN SKIP IF TCO WOULD CAUSE A DISMISS)
       SKN CPORT9; BRU *+5; SKN TF2,2; SKN TROSW; BRU NPOPX0; BRM NPOPX
       CLA; SKE TC,2; BRM NPOPX; BRU NPOPX0

$BRS156 EQU *  ZAP ALL AUXILIARY CIRCUITS FOR THIS JOB.
       BRM TZAP1; BRM NPOPX

$BRS159 EQU *  SET UP/SHUT STATE.
       STA UPSHUT; MIN UPSHUT (UPSHUT = 1 FOR SHUT, 2 FOR UP)
       MRG =6*2B5; DIR; BRM TRO (SEND TYPE 6 TO BASE); BRU BS153A


$BRS160 EQU *       BRS 160. CHANGE TERMINAL CHARACTERISTICS.
       LDA SS01; BRM TF3XMA; BRM NPOPX

$BRS161 SET =B161Y,TF2; BRM NPOPX   COMPLETELY IGNORE ESCAPES
$BRS162 RST =B161Y,TF2; BRM NPOPX   UNDO BRS 161

$BRS163 LDX KM4B3; LDA 0,2; STA 0,6; BRX *-2; BRM NPOPX  NET TO USER

$BRS164 EQU *  ACTIVATE HIM WHEN YELLOW BALL ARRIVES OR TIME RUNS OUT.
       BRM TYEL; BRM MPPACT; LDA SS01; BRU BRS81

$BRS166 EQU *  HANG PORT 0
       COPY A,X; BRU B129A

$BRS168 SET =B168Y,TF2; BRM NPOPX   DISARM HARD ESCAPES
$BRS169 RST =B168Y,TF2; BRM NPOPX

$BRS172 EQU *  SEND OUT CONTROL INFORMATION TO REMOTE. SEND A16-A23.
       SKN TF2,2; SKN TROSW; BRU TVDMS
       SKN SS01; BRU B172A
       BRM MPPACT; STX P172 (SAVE PORT NO. IN TS PAGE)
       LDA =B172B-1; BRM B138C (SAVE 0 IN SBRSRT AND SET UP TF4)
B172A  LDA SS01; RCY 8; CXA; LCY 8; MRG K2B5   (A TYPE 1 CHARACTER)
       DIR
       STA TPAIR2; ETR KM400; MRG ONE (TYPE 1, CHARACTER 1); BRM TROPAIR
       SKN SS01
       BRU BS153A
       BRM TYEL (SEND YELLOW BALL)
       BRM MPPACT; LDA SS02; BRU BRS81 (WAIT FOR IT TO RETURN)
B172B  STB SS02; STX SS03
       LDA SBRSRT; STA 0; LDX P172
       BRM MPTYM; LDA =-1-ORAY; DIR; ETR TF2,2; EIR; STA TF2,2
       LDA TF4,2; LRSH 135CZ; BRM NPOPXB

$BRS177 EQU * STORE TERMINAL PARAMETERS WITHOUT UPDATING REMOTE
       LDA SS01; XMA TF3,2; BRM NPOPXB
* DISMISS FOR BLOCK I/O COMPLETION
$BRS178 LDA =IOBY+TBBY+CSTAY; SKA TF5,2; BRU *+2; BRM NPOPX
       MIN 0; LDA =3B5+TF5; BRU TUDMS1

$B195A BRM MPTYM; SET =AUXY,TF1; BRU NPOPX0

       IF TST

* A = ADDRESS OF CORE ARRAY TO READ INTO.
* B = NO. OF WORDS-1 READ.
* X = NOT USED.
* NOSKIP IF TOBUF IS EMPTY.
$BRS195 EQU * EMPTY TEST OUTPUT BUFFER.  RESET TTROSW.
       LDA =TOBUF; STA T; SKE TOBP; BRU *+2; BRM NPOPX (EMPTY)
       LDX SS01; LDA KM1; STA SS02
B194A  LDA* T; STA 0,6; EAX 1,2; MIN T; MIN SS02
       LDA T; SKE TOBP; BRU B194A
       LDA =TOBUF; STA TOBP; SKR TTROSW; NOP
       BRU NPOPX0
$TOBP  DATA TOBUF
$TTROSW DATA -1 (POS. WHEN TEST OUTPUT BUFFER FULL)

* A = ADDRESS OF CORE ARRAY TO WRITE OUT OF.
* B = NO. OF WORDS-1 TO WRITE
* X = NOT USED.
* NOSKIP IF TIBUF IS NOT YET EMPTY.
$BRS196 EQU * FILL TEST INPUT BUFFER.
       SKN TIBC; BRM NPOPX (NOT EMPTY)
       LDB =TIBUF; STB T
       LDX SS01
B195A  LDB 0,6; DIR; STB* T; MIN T; MIN TIBC
       EAX 1,2; SKR SS02; BRU B195A
       EIR; BRU NPOPX0
$TIBP DATA TIBUF
$TIBC DATA -1
       ENDF

*      END OF TYMNET BRS S     ***************************************

*      LOW LEVEL ROUTINES  *********************************************

TBRK   0
       LDA TF2,2; ETR =RCY; LRSH RCZ
       XXA; LDX TDELAY,2; XXA
       LDB TF1,2; SKE ZERO; BRU *+3; SKB =DIY; MIN ACTR; ADD REAL
       IF TSTAT1
       XMA TT,2
       SKE XX
       ENDF
       STA TT,2
       LDA =-DIY; SKB =DIY; ADM TF1,2
       CBA; ETR =DIY+DEY; SKE =DIY+DEY; BRR TBRK
       LDA =7IY; SKA TF1,2; BRR TBRK
       ADM TF1,2; LDA SEVEN; BRM TWC; BRR TBRK

TDELAY DATA 0,0,90,180

$GATT   0;*     VALIDATE PORT NUMBER IN X. SET UP RRL3 AND TPORT
       CXA; SKG KM1; CLX         -1 MEANS USERS COMMAND PORT
       BRM CPORT; BRR GATT

CPORT  0
       CXA; ETR ADMSK; LRSH 1; STB CPORT9
       LDX UTTY; SKG ZERO; BRU CPORT2
       SUB FOUR; SKG =NPORT-1; SKA X4; BRM TRAP; CAX
CPORT2 STX TPORT
       LDA JOB; LDB K77; SKM TF2,2; BRU *+3; BRM MPTYM; BRR CPORT
       BRM MPPACT
CPORT7 LDX PACPTR; LDA K2000; BRM RIIR; BRM TRAP
CPORT9 0;* NEGEIRVE IF LAST PORT AGRGUMENT WAS FOR OUTPUT. POSITIVE FOR INPUT.

TGOBBLE 0;*   SEND A CHARACTER GOBBLER OUT TO TYMNET
       DIR
       LDA =-1-YELY; ETR TF2,2; STA TF2,2    RST YELLOW BALL FLAG
       LDA =-1-135Y-MARY; ETR TF1,2; STA TF1,2 STOP BLNKS,RST MARGN FLG
       LDA TWO; BRM TROM   SEND CHR GOBBLE AND EIR
       BRR TGOBBLE

TZAPR  0;* TZAP REQUEST. SET UP PU TASK TO ZAP A PORT.
       DIR; LDA WERIS,2; SKG KM1; BRU TZAP3
       LDB KM4; STB WERIS,2; BRM TBRK
TZAP3  EIR; BRR TZAPR

TZAP1  0;*     ZAP ALL AUXILIARY CIRCUITS FOR THIS JOB.
       LDX =NPORT-1
TZAP2  LDA TF2,2; ETR K77
       SKE JOB; BRU TZAP4; LDB TF1,2; SKB =AUXY; BRU TZAP5
TZAP4  CXA; EAX -1,2; SKA ADMSK; BRU TZAP2
       BRR TZAP1
TZAP5  SKN TROSW; BRU TVDMS1; BRM TZAP; BRU TZAP4

TZAP   0;*     ZAP A PORT.
       DIR
       BRM TBIO
       LDA =CONY; ADM TF1,2; LDA =JBY; ETR TF2,2; COPY N,B; ADM TF2,2
       CLA; XMA TC,2; ADM TCC (TOTAL CHAR SPACE COUNT)
* HELP OUT THE GARBAGE COLLECTOR
       LDA TP-1,2; ADD TC-1,2; STA TP,2
       LDA THREE; BRM TROM    SEND CIRCOUT CIRCUIT ZAPPER TO TYMNET
       EIR; BRR TZAP

TBIO ZRO;* TERMINATE BLOCK I/O
       LDA TF5,2; SKA =IOBY; BRU *+2; BRU TBIO1
       SKN TF6,2; ETR =-1-CHCY (ZERO COUNT)
TBIO1 MRG =CZY; ETR =-1-IOBY-TBBY; STA TF5,2; BRR TBIO

CLIB   0
       DIR; BRM TBACKP
       LDA =-1-MARY-GOBY; ETR TF1,2; STA TF1,2
       ABC; XMA TC,2; ADM TCC (TOTAL CHAR SPACE COUNT)
       LDA SEVEN; SKB =7IY; BRM TWC (PUT BACK 7 IN INPUT BFR);
       EIR; BRR CLIB

$TBACKP 0
       COPY XA,B; LCY 8; MRG =200021B; LDB TF1,2; SKB =XOFFY; BRM TRO
       LDA =-1-IIHY-XOFFY; ETR TF1,2; XMA TF1,2
       SKA =IIHY; BRU *+2; BRR TBACKP
       COPY XA,B; LCY 8; MRG =10B*2B5; BRM TRO; BRR TBACKP

TYEL   0;* SEND YELLOW BALL TO TYMNET.
       COPY XA,B; LCY 8; MRG =200376B
       DIR; STA TPAIR2; MIN TPAIR2;  EOR K377; BRM TROPAIR
* ORANGE BALL FLAG => YELLOW BALL OUT, ORANGE EXPECTED
       LDA =ORAY; MRG TF2,2; STA TF2,2
       EIR; BRR TYEL

$AIRWD EQU *
      IF DISC=3; DATA 614B3; ELSE; DATA 604B3; ENDF
$DTIWD EQU *
       IF DISC=3; DATA 61B4; ELSE; DATA 6B5; ENDF
       END
MONITOR ** FICHE/FRAME BREAK *****
TYM SYMSORT

SYM.  PG.LN. IDENT.

1TCC    2 20 TYM     2TCC    2 19 TYM     ACDATA  2 31 TYM     
AIRWD  28 29 TYM     B129A  22 29 TYM     B137A  22 38 TYM     B137B  23  3 TYM     
B138A  23 13 TYM     B138C  23 21 TYM     B172A  25  6 TYM     B172B  25 13 TYM     
B194A  25 35 TYM     B195A  26 11 TYM     B195A  25 24 TYM     B40A   19 24 TYM     
B40B   19 25 TYM     B97A   21 13 TYM     B97B   21  4 TYM     BRS11  17 12 TYM     
BRS112 21 25 TYM     BRS113 22 14 TYM     BRS114 22 17 TYM     BRS12  17 23 TYM     
BRS126 22 22 TYM     BRS129 22 27 TYM     BRS12B 18 16 TYM     BRS13  18 18 TYM     
BRS132 22 31 TYM     BRS137 22 34 TYM     BRS138 23  7 TYM     BRS139 23 26 TYM     
BRS13A 18 25 TYM     BRS14  18 27 TYM     BRS152 23 30 TYM     BRS153 23 34 TYM     
BRS154 24  3 TYM     BRS155 24 10 TYM     BRS156 24 15 TYM     BRS159 24 18 TYM     
BRS160 24 23 TYM     BRS161 24 26 TYM     BRS162 24 27 TYM     BRS163 24 29 TYM     
BRS164 24 31 TYM     BRS166 24 34 TYM     BRS168 24 37 TYM     BRS169 24 38 TYM     
BRS172 25  1 TYM     BRS177 25 18 TYM     BRS178 25 21 TYM     BRS195 25 32 TYM     
BRS196 26  7 TYM     BRS24  18 30 TYM     BRS29  19  3 TYM     BRS40  19 16 TYM     
BRS75  19 33 TYM     BRS79  19 37 TYM     BRS85  20  3 TYM     BRS86  20  6 TYM     
BRS86A 20  8 TYM     BRS87  20 10 TYM     BRS97  20 35 TYM     BRS99  21 20 TYM     
BS112A 21 38 TYM     BS112B 22  3 TYM     BS112D 22 12 TYM     BS112F 21 28 TYM     
BS112G 21 29 TYM     BS112H 22 11 TYM     BS112I 21 24 TYM     BS153A 23 39 TYM     
CECHR   4 30 TYM     CIOT1   7  6 TYM     CIOT1A  7  5 TYM     CLIB   28  9 TYM     
CLM2   19 12 TYM     CPORT  27  3 TYM     CPORT2 27  7 TYM     CPORT7 27 10 TYM     
CPORT9 27 11 TYM     DTIWD  28 31 TYM     GATT   26 38 TYM     NMSK   21 16 TYM     
RBALL1  5 34 TYM     RBALLS  5 29 TYM     SETPC2 16  9 TYM     TBACKP 28 16 TYM     
TBIO   28  4 TYM     TBIO1  28  7 TYM     TBRK   26 22 TYM     TCC     2 18 TYM     
TCI1    4  8 TYM     TCI2    3 36 TYM     TCI3E   4 26 TYM     TCI3EL  4 25 TYM     
TCI5E   4 22 TYM     TCI5EL  4 21 TYM     TCI5EX  4 28 TYM     TCIC7   3 37 TYM     
TCICIO  4  7 TYM     TCIO    4  1 TYM     TCIT    4 10 TYM     TCIT2   4 19 TYM     
TCIX    3 26 TYM     TCLFLG  4 29 TYM     TCO1    7  9 TYM     TCO2    7 13 TYM     
TCO3    7 15 TYM     TCO3A   7 18 TYM     TCO3B   7 20 TYM     TCOCHR  7  3 TYM     
TCOX    6 37 TYM     TDELAY 26 36 TYM     TF2     2 33 TYM     TF3MSK  3  6 TYM     
TF3SHF  3 12 TYM     TF3TYP  3 18 TYM     TF5     2 34 TYM     TF6     2 35 TYM     
TFIP   16 23 TYM     TFIP1  16 30 TYM     TFIP2  16 29 TYM     TFIP3  16 31 TYM     
TFREE   2 39 TYM     TFREEC  3  1 TYM     TGOBBL 27 13 TYM     TH1    17  6 TYM     
THARD  13  4 TYM     THIRD   2 22 TYM     TIBC   26 15 TYM     TIBP   26 14 TYM     
TIC1   15 25 TYM     TIIR    6 28 TYM     TIIRX   6 35 TYM     TIP    15 22 TYM     
TIPIX  15 26 TYM     TO      7 31 TYM     TO102   8  4 TYM     TO105   8  6 TYM     
TO135   8 10 TYM     TO152   8 14 TYM     TO152A  8 17 TYM     TO155   8 20 TYM     
TO155A  8 22 TYM     TOBP   25 39 TYM     TON     7 37 TYM     TON2    8  2 TYM     
TON3    8  1 TYM     TPORT   3  2 TYM     TPUH   17  1 TYM     TPUS   16 33 TYM     
TQ      9  1 TYM     TQ1     9  5 TYM     TQA     8 28 TYM     TQB     8 29 TYM     
TQC     8 27 TYM     TQCHR   8 36 TYM     TQCHRF  8 37 TYM     TQD     9 14 TYM     
TQD01   9 32 TYM     TQD01E  9 39 TYM     TQD01E  9 36 TYM     TQD1    9 24 TYM     
TQD12   9 28 TYM     TQD15   9 30 TYM     TQD21   9 33 TYM     TQD21E 10  1 TYM     
TQD21E  9 37 TYM     TQD27   9 34 TYM     TQDCHR  9 26 TYM     TQPORT  8 34 TYM     
TQRET   8 32 TYM     TQRL    8 31 TYM     TQTAB  10  5 TYM     TQTYPE  8 35 TYM     
TQX     8 30 TYM     TRC    14 36 TYM     TRC1   14 39 TYM     TRC2   15  9 TYM     
TRC3   15 11 TYM     TRC3X  15 14 TYM     TRCTIM 15 15 TYM     TROSW   7 28 TYM     
TROSW1  7 29 TYM     TSOFT  12 33 TYM     TSOFT1 12 39 TYM     TSON   15 28 TYM     
TSONC1 16  8 TYM     TSONC2 16  5 TYM     TSONC3 16  6 TYM     TSONC4 16  7 TYM     
TSONI  16 11 TYM     TSSOFT 12 32 TYM     TT      2 32 TYM     TTQ     2 38 TYM     
TTQHD   2 36 TYM     TTQTL   2 37 TYM     TTROSW 26  1 TYM     TTYASG  2 29 TYM     
TU36    6  8 TYM     TUCHR   4 36 TYM     TUCHRF  4 37 TYM     TUDMS   5 23 TYM     
TUDMS1  5 28 TYM     TUE     6 17 TYM     TUE8    6 26 TYM     TUE9    6 25 TYM     
TUECHO  4 38 TYM     TUGC    5  1 TYM     TUGC1   5  3 TYM     TUGC2   5  4 TYM     
TUGC3   5 15 TYM     TUGC4   5 21 TYM     TUGC5   5 19 TYM     TUIGNR  6 12 TYM     
TULC    6 10 TYM     TUN     5 36 TYM     TUN1    5 37 TYM     TUN2    5 38 TYM     
TUN8    6  1 TYM     TUN8A   6  6 TYM     TVDMS   7 24 TYM     TVDMS1  7 26 TYM     
TY1    10  7 TYM     TY10   14  1 TYM     TY11   14  3 TYM     TY11A  14 19 TYM     
TY11B  14  4 TYM     TY11C  14  5 TYM     TY11D  14  8 TYM     TY11Z  14 20 TYM     
TY12   14 24 TYM     TY12A  14 34 TYM     TY13   13 17 TYM     TY14   13 18 TYM     
TY15   13 19 TYM     TY15A  13 21 TYM     TY15B  13 26 TYM     TY18   12  8 TYM     
TY1B   11 37 TYM     TY1E0  10 12 TYM     TY1E0F 10 18 TYM     TY1E1  10 28 TYM     
TY1E1A 10 36 TYM     TY1E1B 10 38 TYM     TY1E2  11  4 TYM     TY1E2A 11  5 TYM     
TY1E3  11  8 TYM     TY1E3B 11 10 TYM     TY1E3C 11 11 TYM     TY1E3D 11 12 TYM     
TY1E3E 11 16 TYM     TY1E3F 11 17 TYM     TY1E4  11 19 TYM     TY1E5  11 22 TYM     
TY1E5A 11 27 TYM     TY1E6  11 29 TYM     TY1E7  11 33 TYM     TY1N   12 11 TYM     
TY1N1  12 15 TYM     TY1N2  12 25 TYM     TY1N9  12 30 TYM     TY3    13 13 TYM     
TY36   13 10 TYM     TY3A   13 15 TYM     TY4    13 16 TYM     TY5    13 28 TYM     
TY6    13 33 TYM     TY7    13 38 TYM     TYEL   28 22 TYM     TZAP   27 33 TYM     
TZAP1  27 25 TYM     TZAP2  27 27 TYM     TZAP3  27 23 TYM     TZAP4  27 29 TYM     
TZAP5  27 31 TYM     TZAPR  27 20 TYM     
MONITOR ** FICHE/FRAME BREAK *****
W
W      IDENT   06/22/76

       LISTM
* ENTRY POINTS
       ENTRY   CTLI,TBSFI,TEOFI,TFSFI,PRDI,TRINT,TWI
       ENTRY   CTRL,ETTW,TREAD,TWRT

       TDT     TRT,SKS,10410   SKIP IF TAPE NOT READY
       TDT     BTT,SKS,12010   SKIP IF NOT BEGINNING OF TAPE
       TDT     ETT,SKS,11010   SKIP IF NOT END OF TAPE
       TDT     TFT,SKS,13610   SKIP IF NOT END OF FILE
       TDT     FPT,SKS,14010   SKIP IF TAPE NOT FILE PROTECTED
       TDT     D8T,SKS,17210   SKIP IF NOT 800 DENSITY
       TDT     D2T,SKS,16210   SKIP IF NOT 200 DENSITY
       TDT     D5T,SKS,16610   SKIP IF NOT 556 DENSITY
       TDT     RTB,EOM*,3610   READ TAPE BINARY
       TDT     WTB,EOM*,3650   WRITE TAPE BINARY
       TDT     WFM,EOM*,2050   WRITE FILE MARK
       TDT     SFB,EOM*,3630    SCAN FORWARD IN BINARY
       TDT     SRB,EOM*,7630    SCAN REVERSE IN BINARY
       TDT     ETF,EOM*,3670   ERASE TAPE FORWARD
       TDT     ETR,EOM*,7670   ERASE TAPE IN REVERSE
       TDT     REW,EOM,14010   REWIND

SETXX  MACRO; LDA XX; STA TREAL; ENDM
SETRL  MACRO; LDA REAL; ADD =180; STA TREAL; ENDM

* BRS 100 ASSIGN DEVICE TO CHANNEL N
* DEVICE NUMBERS: 0=TAPE 0, 1=TAPE 1, 2=PRINTER
* INPUT: A=DEVICE NUMBER, X=CHANNEL NUMBER OR -1.
* RETURNS: NO SKIP=ERROR. DEVICE ALREADY ASSIGNED.
*          SKIP=ASSIGNMENT OK.
$AST   SKN WBIU; BRM NPOPX
       SKN SYSS; BRU *+2; BRU AST2
       LDB X1; LDX JOB; SKB CPARW,2; BRU *+2; BRM TRAP
AST2   SKG TWO; SKG KM1; BRM TRAP; CAX
       LDA EQPT; RCY 4,2; SKA ONE; BRU *+2; TRAP; LDA SS03
       SKE KM1; BRU *+2; LDA UTTY; XXA
       SKN TTYASG,2; BRM TRAP
       STA DEVICE; STX DEVCH
       LDA KM1; STA TPAR; MIN 0
       LDX TTYASG,2; BRU WJ (STORE WJOB AND EXIT)
* BRS 101   UNASSIGN DEVICE TO CHANNEL N
$UAST  SKN SYSS; BRU *+2; BRU UAST2
       LDB X1; LDX JOB; SKB CPARW,2; BRU *+2; BRM TRAP
UAST2  LDA KM1; STA DEVICE; STA DEVCH; BRM NPOPX
* BRS 104   WHO HAS DEVICE
* OUTPUT: A=DEVICE, X=CHANNEL
$WHT   LDA DEVICE; LDX DEVCH; BRU NXPOP

* NEW TAPE LOGIC

* UNIT ASSIGNMENT

       BRM MONCR (-1 ILLEGAL)
$WINT  BRM MONCR ( 0 DISC, ILLEGAL)
       BRU TRINT ( 1 TAPE READ)
       BRU TWI   ( 2 TAPE WRITE)
       BRU CTLI  ( 3 CONTROLS)
       BRU TEOFI ( 4 EOF)
       BRU TFSFI ( 5 FORWARD SPACE FILE)
       BRU TBSFI ( 6 BACKWARD SPACE FILE)
       BRU PRDI  ( 7 PRINTER)

* BRS 102   READ TAPE
* INPUT: A=CORE ADDR., B=WORD COUNT, X=NO. OF RECORDS (EQ OR LT 64)
* OUTPUT: 1 WORD AT BEGINNING OF EACH RECORD.
* OP CODE FLAGS:
*      00=TAPE RECORD WAS READ. IT HAD N WORDS WHICH FOLLOW.
*      01=TAPE RECORD WAS READ. IT HAD N WORDS WHICH FOLLOW, BUT
*         AN ERROR WAS MADE. NO FURTHER RECORDS WERE READ.
*      02=END OF FILE. NO MORE READING.
*      03=LAST TAPE RECORD DUE TO LACK OF CORE SPACE.
*         NO MORE RECORDS. RECORD MAY HAVE BEEN TRUNCATED.
*      04=TAPE RECORD WAS TRUNCATED DUE TO OVERRUN OF 3 SEC.
*         TIME LIMIT. (PERHAPS RUNAWAY)
*      05=NO MORE RECORDS DUE TO REACHING SPECIFIED RECORD COUNT.
*      06=END OF TAPE. NO MORE READING.
*      07=TAPE NOT READY. NO MORE READING.
*      10=PAGE BOUNDARY ERROR ON WRITE.
*      11=TAPE WRITE PROTECTED.
*      12=BEGINNING OF TAPE. NO WRITE.
*      13=DEVICE NO LONGER ASSIGNED.
*      14=RUBOUT
TREAD  BRM CHKDEV  (CHECK TNUM, WBIU, UNIT & BLKBSY)
       LDA SS03; SUB ONE; STA TNR; SKN TNR; BRU *+2
       BRM TTRAP; SKG K100; BRU *+2; BRM TTRAP
       STB TWCNT; SKR TWCNT; BRU *+2; BRM TTRAP; LDA SS01
       ETR ADMSK; STA TCA; ETR PGMSK; ADD TWCNT; SKA =77774B3
       BRM TTRAP; LDX TCA; LDB 0,6; STB 0,6; CXA; BRM DTH
       STA TCA
       LDX TNUM; LDB RTBW,2
       BRM TPSET; BRU TRD4; LDA TRA; STA TMCA
       CLA; LDX SS01; STA 0,6; LDA ONE; STA UNIT
TRD5   LDA =-2B5; LDX JOB; ADM TTNO,2; STX WJOB
       LDA TCA; BRM WB
       LDA TNUM; CAX; ADD TPDMS2; MIN TPDMS,2; CAB
* DISMISS DRIVER
TRDMS1 BRM TFIN
TRDMS  LDX =QTI; MIN 0; MIN XSW; SYSE; BRU NPOPDS
TRD4   BRU TWR4+2
TPDMS2 33B TPDMS

* INPUT: A=TCA, B=RTB OR WTB
* SETS TRA=(TCA) IN P7.
* SETS UP COMMANDS AT (TCA)+1
TPSET  ZRO; XAB; ETR TPAR; XAB
       STB TRD2; RCY 9; ETR =140B; MRG =216000B; STA IORD; LDA TWCNT
       SKG ZERO; BRU TPSET2
       LCY 14; ETR =7774B4; STA TD2; LDA ONE; SKB ONE; ADM IORD
       LDA TCA; ETR ADMSK; ADD ONE; ADM TD2; SUB ONE
       ETR K3777; ADD =34000B
       STA TRA; BRM TRD; BRR TPSET; MIN WBIU
       MIN TPSET; BRR TPSET
TPSET2 LDA =3B5; BRR TPSET

* TAPE READ/WRITE DRIVER
TRD   ZRO; LDX TNUM; LDA =6B5; EXU ETTW,2; BRR TRD (END OF TAPE)
       EXU TRTW,2; BRU TRD2A (TAPE READY); LDA =7B5; BRR TRD
TRD2A  SKN XSW; BRU TRD2; SYSD
$TRD2  NOP 0 (READ/WRITE TAPE BINARY)
$IORD  ZRO 0   IORD WORD. EOM 16000B.
       POT TD2
       MIN TRD; CLA; BRR TRD

* TAPE READ INTERRUPT
TRINT  LDX TNUM; ASCW; PIN TMAR
       SETXX
       LDA TMAR; CAB; SUB TCA; STB TCA; ETR ADMSK
       SUB ONE
       SKN DEVICE; BRU *+2; BRU TRI9 (LOST DEVICE)
       SKN DEVCH; BRU *+2; BRU TRI10 (RUBOUT)
       EXU TFTW,2; BRU TRI2 (EOF)
       BETW; BRU TRI1 (ERROR)
       IF DISC<3; SKN DSW; BRM IDMW; ENDF
       SKE TWCNT; BRU TRI8; MRG =3B5; BRU TRI6
TRI8   SKR TNR; BRU TRI5; MRG =5B5; BRU TRI6 (RECORD COUNT ZERO)
TRI5   EXU ETTW,2; BRU TRI3 (END OF TAPE)
       STA* TRA; ADD ONE; CNA; ADM TWCNT; CBA; LDB RTBW,2
       BRM TPSET; BRU TRI6; LDA TRA; STA TMCA; CLA; STA* TMCA
       LDA ONE; STA UNIT; SETRL; BRU WRET
TRI6   STA* TRA
       LDX TNUM; SKR TPDMS,2; NOP; LDA KM1; STA TNUM
       STA WBIU
       BRU NINT2
TRI1   MRG K1B5 (ERROR); BRU TRI6
TRI2   MRG K2B5 (EOF); BRU TRI6
TRI3   MRG =6B5 (END OF TAPE); BRU TRI6
TRI9   MRG =13B5 (LOST DEVICE); BRU TRI6
TRI10  MRG =14B5 (RUBOUT); BRU TRI6

* BRS 103   WRITE TAPE.
* INPUT: A=CORE ADDRESS.
*   (A) COMMUNICATION FROM SYSTEM TO USER.
*   (A)+1 1ST RECORD WORD COUNT.
*   (A)+2 THRU (A)+N+1 RECORD DATA.
*   (A)+N+2 NEXT RECORD WORD COUNT.
*   ETC. COUNT=0 AFTER LAST RECORD.
* OUTPUT: A=ADDRESS OF LAST RECORD.

TWRT   BRM CHKDEV (CHECK DEVICE ASG)
       LDA SS01; ETR ADMSK
       CAX; LDB 0,6; STB 0,6
       ETR =34000B; STA TURL; CXA; ETR ADMSK; ADD ONE; STA 0,6; CXA
       ETR K3777; ADD =34000B; STA TMCA; EAX 1,2
       ADD TWO; ADD 0,6; SKA =7774B4; BRM TTRAP; CXA; ETR ADMSK; STA TCA
       LDA 0,6; STA TWCNT; LDA TCA
       BRM DTH; STA TCA
       LDX TNUM; LDA =11B5; EXU FPTW,2; BRU TWR4
       LDA =12B5; EXU BTTW,2; BRU TWR4
       LDA TCA; LDB WTBW,2
       BRM TPSET; BRU TWR4; LDA TWO; STA UNIT
       BRU TRD5
TWR4   ADD SS01; ADD ONE; LDX SS01; STA 0,6
TWR5   LDA KM1; STA TNUM; BRM NPOPX
* UNIT  BUSY
BLKBSY LDB TPDMS3; LDX =QTI; BRU NPOPDS

* TAPE WRITE INTERRUPT.
TWI    BSS 0
       SETXX
       SKN DEVICE; BRU *+2; BRU TWI7 (LOST DEVICE)
       SKN DEVCH; BRU *+2; BRU TWI10 (RUBOUT)
       BETW; BRU TWI1 (ERROR)
       IF DISC<3; SKN DSW; BRM IDMW; ENDF; LDX TNUM
       EXU ETTW,2; BRU TWI3 (END OF TAPE)
       CLA; STA TPE,2
       LDA* TRA; ETR ADMSK; ADD ONE; ADM TCA; ADM TRA
       LDA* TRA; SKE ZERO; BRU *+2; BRU TWI6; STA TWCNT; LDA TCA
       ETR PGMSK; ADD TWCNT; SKA =77774B3; BRU TWI2
       LDA TCA; LDB WTBW,2; BRM TPSET; BRU TWI6
       LDA TCA; ETR K3777; ADD TURL; STA* TMCA
       LDA TWO; STA UNIT; SETRL; BRU WRET
TWI1   LDA K1B5 (ERROR)
TWI6   ADM* TMCA; LDX TNUM; SKR TPDMS,2; NOP
       LDA KM1; STA TNUM; STA WBIU; BRU NINT2
TWI3   LDA =6B5 (END OF TAPE); BRU TWI6
TWI2   LDA =10B5 (PAGE OVERRUN); BRU TWI6
TWI7   LDA =13B5 (LOST DEVICE); BRU TWI6
TWI10  LDA =14B5 (RUBOUT); BRU TWI6
*
* BRS 105   NEW TAPE CONTROLS
* INPUT: A=1=NOP, 2=BACKSPACE RECORD, 3=FORWARD SPACE FILE
*          4=BACKSPACE FILE, 5=WRITE 3 INCHES BLANK TAPE
*          6=REWIND, 7=WRITE END OF FILE, 8=TEST FILE PROTECT RING
CTRL   BRM CHKDEV (CHECK DEVICE); LDA =CTMCA; STA TMCA
       MIN WBIU; EXU TRTW,2; BRU CTL10 (READY)
       LDA TRTW,2; STA TCLDMS; LDB TDS; LDX =QTI
       LDA KM1; STA TNUM; STA WBIU; BRU NPOPDS
TDS    4 TCLDMS
CTL10  LDA PACPTR; STA WPTR
       LDA SS01; SKG EIGHT; SKG ZERO; BRM TTRAP
       CAX; BRU* *,2
CRL6   DATA TREW3,TBSR,TFSF,TBSF,TERS,TREW,TEOF,TFPR

* REWIND
TREW   LDX TNUM
TREW2  EXU REWW,2
TREW3  BRM CTLX3

* BACKSPACE RECORD
TBSR   LDX TNUM
       EXU BTTW,2; BRM CTLX3
       LDA SRBW,2; ETR TPAR; SYSD; STA *+1
       EXU SRBW,2; EOM 16000B; POT X0
*  CONTROL EXIT
CTLX   LDA THREE
CTLX2   STA UNIT; CXA; ADD TPDMS2; MIN TPDMS,2; CAB
       LDA =-2B5; LDX JOB; STX WJOB; ADM TTNO,2
       LDA X4; STA WPAGE
       BRU TRDMS1
CTLX3  ZRO; LDX KM1; STX TNUM; STX WBIU; BRM NPOPX
*  CONTROL INTERRUPT ROUTINE.
$CTLI  BSS 0
CTLI2  LDX TNUM; SKR TPDMS,2; NOP; LDA KM1
       STA TNUM; STA WBIU; LDA XX; STA TREAL
       IF DISC<3; SKN DSW; BRM IDMW; ENDF
       LDX WJOB; LDA K2B5; ADM TTNO,2; BRU WRET

* ERASE 3 INCH GAP
TERS   LDX TNUM
       LDA =11B5; EXU FPTW,2; BRU TERS3 (FILE PROTECTED)
       LDA =6B5; EXU ETTW,2; BRU TERS3 (END OF TAPE)
       SYSD; EXU ETFW,2; EOM 16000B; POT X4; BRU CTLX
TERS3  STA SS01; BRM CTLX3

* WRITE END OF FILE
TEOF   LDX TNUM
       LDA =11B5; EXU FPTW,2; BRU TERS3 (FILE PROTECTED)
       EXU ETTW,2; BRU TEOF3 (END OF TAPE)
       CLA; STA TPE,2
TEOF4  SYSD; EXU ETFW,2; EOM 16000B; POT X4; LDA FOUR; BRU CTLX2
TEOF3  MIN TPE,2; LDA TPE,2; SKG FOUR; BRU TEOF4; BRM TTRAP
TEOFI  LDX TNUM; EXU TRTW,2; BRU *+2; BRU *-2
       EXU WFMW,2; EOM 16000B; POT FMK
       LDA THREE; STA UNIT; BRU WRET

* FORWARD SPACE FILE
TFSF   LDX TNUM; LDA =6B5; EXU ETTW,2; BRU TFSF2 (EOT)
       LDA SFBW,2; ETR TPAR; STA TFSFI3; SYSD; STA *+1
       EXU SFBW,2; EOM 16000B; POT X0; LDA FIVE; BRU CTLX2
TFSF2  STA SS01; BRM CTLX3
TFSFI  SKN DEVICE; BRU *+2; BRU CTLI2 (LOST DEVICE)
       SKN DEVCH; BRU *+2; BRU CTLI2 (RUBOUT)
       LDX TNUM; EXU TRTW,2; BRU *+2; BRU CTLI2
       EXU TFTW,2; BRU CTLI2 (EOF)
       EXU ETTW,2; BRU CTLI2 (EOT)
       SETXX
       IF DISC<3; SKN DSW; BRM IDMW; ENDF
       LDA FIVE; STA UNIT
TFSFI3 EXU SFBW,2; EOM 16000B; POT X0
       SETRL; BRU WRET

* BACKSPACE FILE
TBSF   LDX TNUM; EXU BTTW,2; BRM CTLX3 (EOT)
       LDA SRBW,2; ETR TPAR; STA TBSFI3; SYSD; STA *+1
       EXU SRBW,2; EOM 16000B; POT X0; LDA SIX; BRU CTLX2
TBSFI  SKN DEVICE; BRU *+2; BRU CTLI2 (LOST DEVICE)
       SKN DEVCH; BRU *+2; BRU CTLI2 (RUBOUT)
       LDX TNUM; EXU TRTW,2; BRU *+2; BRU CTLI2
       EXU TFTW,2; BRU CTLI2 (EOF)
       EXU BTTW,2; BRU CTLI2 (BOT)
       SETXX
       IF DISC<3; SKN DSW; BRM IDMW; ENDF
TBSFI3 EXU SRBW,2; EOM 16000B; POT X0; LDA SIX; STA UNIT
       SETRL; BRU WRET

* TEST FILE PROTECT RING
TFPR   LDX TNUM; LDA =11B5; EXU FPTW,2; BRU TERS3 (FILE PROTECTED)
       BRM CTLX3 (NOT PROTECTED)

* BRS 107   SET TAPE PARITY
* INPUT: A NEGATIVE FOR BCD (EVEN PARITY), POSITIVE FOR BINARY (ODD PARITY)
*
$SETPAR LDA DEVCH; SKE UTTY; BRM TRAP; LDA =77776777B
       SKN SS01; LDA KM1; STA TPAR; BRM NPOPX

* 
* BRS 108   TEST DENSITY
* OUTPUT: A=0 FOR 200, A=1 FOR 556, A=2 FOR 800.
$TSTD2 LDA DEVICE; SKG ONE; SKG KM1; BRM TRAP; CAX; CLA
       EXU D2TW,2; BRU TSTD3; LDA ONE; EXU D5TW,2; BRU TSTD3
       LDA TWO; EXU D8TW,2; BRU TSTD3; BRM TRAP
TSTD3  LDX SS03; BRU NXPOP

TTRAP  ZRO; LDA KM1; STA TNUM; STA WBIU; BRM TRAP
*
* BRS 110   TEST TAPE READY
$TSTRDY LDA DEVICE; ETR ONE; CAX; EXU TRTW,2; MIN 0 (READY)
       BRM NPOPX (NOT READY)

TFIN  ZRO; LDA REAL; ADD =180; STA TREAL
       LDA PACPTR; STA WPTR; BRR TFIN

CHKDEV ZRO 0;*  CHECK DEVICE ASG. SAVE SOME SPACE
       SKN TNUM; BRM TRAP; SKN WBIU; BRM TRAP; SKN UNIT
       BRU BLKBSY; LDA UTTY; SKE DEVCH; BRM TRAP; LDX DEVICE
       CXA; SKG ONE; SKG KM1; BRM TRAP; STX TNUM
       LDA KM1; STA XSW (PERMIT XXDIR IN TPSET); BRR CHKDEV

PRSET ZRO 0;* SET UP TO PRINT A LINE
       LDX TRA; LDB 0,2; SKN B98SW; LDB =34*8
       LSH 21; CLB; ETR K77; STA PRBWC
       SUB ONE; SKG =33; BRU *+2; LDA =33
       LSH 14; STA PRD6; LDA TCA; ETR ADMSK
       ADD ONE; ADM PRD6; LDA 0,2
       ETR SEVEN; LSH 9; MRG PRSK
       SKN 0,2; MRG K200; STA POSL
POSL   EOM 10460B; LDA TCA; RCY 9; ETR =140B; MRG =216000B
       STA PRD4; MIN WBIU
       SKN XSW; BRU PRD4A; SYSD
PRD4A  EOM* 2660B
PRD4   EOM 16000B; POT PRD6; LDA SEVEN; STA UNIT
       BRR PRSET
PRSK   EOM 10460B

PRDI   EQU * PRINTER INTERRUPT
       LDA PRBWC; ADM TCA; ADM TRA; COPY N,B; ADM PRWC
       SKN PRWC; BRU PRDI2
PRDI3  LDA KM1; STA WBIU
       SKR PRDMS1; NOP; LDA XX; STA TREAL; BRU NINT2
PRDI2  LDA =13B5; SKN DEVICE; BRU *+2; BRU PRDI4
       LDA =14B5; SKN DEVCH; BRU *+2; BRU PRDI4 (RUBOUT)
       LDA =7B5; SKS 12060B; BRU PRDI4 (NOT READY)
       SETXX
       IF DISC<3; SKN DSW; BRM IDMW; ENDF
       BRM PRSET; SETRL; BRU WRET
PRDI4  STA* TMCA; BRU PRDI3
PRWC   ZRO 0

PRBWC  ZRO 0
B98SW  ZRO 0

WDVR1 ZRO 0;* SETUP COMMON TO PRINTER, CARD, AND PUNCH DRIVERS
       SKE DEVICE; TRAP
       LDA UTTY; SKN WBIU; TRAP; SKE DEVCH; TRAP; SKN UNIT; BRU BLKBSY
       LDA SS01; ETR ADMSK; CAX; LDB 0,6; STB 0,6
       ETR =34000B; STA TURL (NOT USED)
       EAX 1,2 (POINT TO FIRST WORD PAST COMMUNICATIONS WORD)
       LDA SS01; ETR K3777; ADD =34000B; STA TMCA
       COPY XA,B; ETR ADMSK; STA TCA; STA TUA
       LDB =34000B; SKM SS01; TRAP; ADD SS03; SKM TCA; TRAP
       LDA TCA; CLB; BRM DTH (CONVERT TO 16 BIT ADDR)
       STA TCA (REAL ADDR OF BUFFER START)
       ETR K3777; ADD =34000B; STA TRA
       SKS 14000B; BRM MONCR
       BRR WDVR1
WDVR3 ZRO 0;* COMMON TO PRINTER, CARD, AND PUNCH DRIVERS
       LDA TCA; BRM WB; LDA WPAGE; MRG RLWB; BRM RLABEL
       LDA KM1; STA XSW (PERMIT XXDIR IN CR---,CP---, AND PRSET)
       BRR WDVR3
WDVR4 ZRO 0;* COMMON TO PRINTER, CARD, AND PUNCH DRIVERS
       BRM TFIN; BRM MPWB; CLA; STA WBIU; LDX JOB; LDA =-2B5
       ADM TTNO,2; BRR WDVR4

*
* BRS 98  PRINTER DRIVER FOR COMPRESSED BUFFERS
* INPUT        A=CORE ADDRESS, X=WORD COUNT
*      (A) COMMUNICATIONS WORD
*      (A+1) BIT 0 FOR SKIP=1  =0 FOR UPSPACE
*            BITS 15-20 NUMBER OF WORDS IN BUFFER
*            BITS 21-23 CODE FOR SKIP
*      (A+2)-(A+N) LINE OF PRINT  N=BITS 15-20 ABOVE
*      (A+N+2) NEXT LIKE (A+1)
*
$BRS98 LDA TWO; BRM WDVR1
       LDB KM1; BRU B106A

*
*
* BRS 106   PRINTER DRIVER
* INPUT: A=CORE ADDRESS, X=WORD COUNT
*      (A) COMMUNICATION WORD FROM SYSTEM TO USER.
*      (A+1) PAPER CONTROL,  NEG FOR SKIP, POS FOR UPSPACE.
*      (A+2)-(A+34) ONE LINE OF DATA.
*      (A+35)  PAPER CONTROL.

$BRS106 LDA TWO; BRM WDVR1
       LDA SS03; SUB ONE; RSH 23; DIV =34; SKB KM1; TRAP
B106A  STB B98SW; LDA SS03; SUB TWO; STA PRWC
       LDA =7B5; SKS 12060B; BRU PRD2
       BRM WDVR3
       BRM PRSET
       BRM WDVR4
       MIN PRDMS1; LDB PRDMS; BRU TRDMS
PRDMS  33B PRDMS1
PRD2   LDX SS01; STA 0,6; BRM NPOPX

* SYSTEM DISABLE.  CALL WITH INTS. DISABLED TO PREVENT LOWER LEVEL
* ROUTINES FROM ENABLING INTERRUPTS.
$XXDIR 0; STA XEIR+1; LDA XEIR+2; XMA XEIR+1; BRR XXDIR

* SYSTEM ENABLE.
$XXEIR 0; STA XEIR+1; LDA *+4; XMA XEIR+1; EIR; BRR XXEIR; EOM 20002B


*      MISCELLANEOUS BRS'S WHICH CAN BE IN ANY OVERLAY WITH TS


*BRS 73 - READ ERROR CODE.
$RDCLEC LDA ERCODE
*BRS 28 - EXCHANGE 'A' AND ERROR CODE.
$SETEC XMA ERCODE; BRU NXPOP

* BRS 39 READ CPARW AND AUNN
$RCPARW LDX JOB; LDA CPARW,2; LDB AUNN,2; BRU RTEX+1

$BRS42 BRM RREAL; ETR K3S6
BRS42A XAB; BRU NXPOP

RREAL  ZRO
       LDA UZONE; ETR K37; LDB K40; SKB UZONE; SKN DSTSW; SUB ONE
       MUL =30; CBA; ADD DMIN; SKG TMK1; BRU *+2; ADD TMK2
       LDB REAL; LDX YEAR; BRR RREAL

$MAYDMS EQU *  BRS 55. DISMISS IF USER IS RUNNING THE DISC.
       LDX JOB; SKN TTNO,2; BRM NPOPX; MIN 0; BRM CDMS1

* BRS 71   SKIP IF EXFLG SET. SET B=UEXFLG VALUE.
* 2B7=SUBSYSTEM, 4B7=SYSTEM, 6B7=EXEC
$SKXEC LDB UEXFLG; STB SS02; SKN UEXFLG; BRM NPOPX; BRU NPOPX0

* BRS 72 - LOOK UP IBP IN XBP FOR EXEC AND OTHERS.
*      'A' = IBP (SECTOR ADDRESS)
*      'B', 'X' NOT USED.
*      IF NOT FOUND, NON-SKIP RETURN WITH 'A','B','X' UNCHANGED.
*      IF FOUND, SKIP RETURNS WITH 'A'= GFLG ENTRY, 'B'= AUNN ENTRY
*      'X'=LUD LOCATOR (WERIS) FOR FILE JOB.
*
$BRS72 LDX =-NFILE; LDB DMSK
BRS72A SKM EXBP,2; BRU BRS72B
       LDA EGFLG,2; CAX; RSH 8; ETR K77; XXA
       LDB AUNN,2; LDX TTNO,2; LDX WERIS,2; MIN 0; BRU NXPOP
BRS72B BRX BRS72A; BRM NPOPX

$BRS74  LDA REAL; MUL TMK; ADD TYMTIM; LDB REAL; LDX TYMTIM; BRU NXPOP

$BRS76 BRM RREAL; BRU BRS42A

* BRS 88, READ CPU TIME
$RTEX  BRM CTRU; LDX SS03; BRU NXPOP

* BRS 89, GET METER READINGS FOR SESSION.
* A= ADDRESS FOR READINGS.
* DISK USE, SWAP COUNT, CHARACTER COUNT, PAGE TICKS
* CPU TIME, CONNECT TIME.
$RESMT BRM CTRU; LDB SWPCNT,2; LDX SS01; STA 4,6; STB 1,6
       LDX JOB; LDA CCT,2
       IF PTICK; LDB PTCKS,2; ELSE; CLB; ENDF
       LDX SS01; STA 2,6; STB 3,6
       LDA DSKMET; STA 0,6; LDA REAL; SUB UREAL; STA 5,6
       BRM NPOPX

* BRS 93  RESET METERS.
$RSMET CLA; STA DSKMET; LDX JOB; STA SWPCNT,2; STA ETTB,2
       IF PTICK; STA PTCKS,2; ENDF; STA CCT,2; BRM NPOPX

* BRS 130   BREAK POINT TEST
* SKIPS IS BREAK POINT SWITCH IS DOWN.
* INPUT: X=SWITCH NUMBER.
$BPTEST SKN EXEC1; BRM TRAP
       LDA K1000; RSH 0,2; XMA BPT2; ETR KS5B3
       ADM BPT2
BPT2   BPT; MIN 0; BRM NPOPX

$BRS135 EQU *  INTERRUPT FORK AFTER TIME IN B IS ELAPSED
       EAX PUBPTR              LOOK FOR OLD BRS 135 ENTRIES ON PU 
B135A  LDX 0,2; CXA; SKE =PUBPTR; BRU *+2; BRU B135B
       LDA 1,2; SKE B135C; BRU B135A    (NOT A PUTIM ENTRY);
*      REMOVE ENTRY IF PU PACPTR SAME AS CURRENT OR IF SAME USER
       LDA 3,2; EOR UTTY; LRSH 12; EOR PACPTR
       SKB PLMSK (CHECK UTTY; SKG PLMSK (CK PACPTR); BRU *+2 ; BRU B135A
       LDA PUDEAD; STA 1,2    CANCEL PU ENTRY AND WAIT UNTIL IT 
       BRU B135D               (DISMISS TO LET PU SCHEDULER RUN)
B135B  LDA SS02; MUL =1727024B     CONVERT MILISECONDS TO CLOCK TICKS
       ADD REAL; COPY AX,B; LDA PACPTR; LSH 12; MRG UTTY; COPY XB,AX
       LDA B135C; BRM EPU
       LDX PACPTR; BRU B135E   (ARM INTERRUPT 5)
* BRS 136 - SET EXEC SWITCHES.  X=SWITCH NO.  A=NEW VALUE.  RETURNS
*              A=OLD VALUE.  TRAP ON UNUSED SWITCHES.
$BRS136 XXA; SKE ONE; SKA KM8; TRAP
       SKE FIVE; BRU *+2; BRM TRAP
       XXA; XMA SWLET,2; BRU NXPOP

* BRS 143  TEST BIT MAP SET
$BMTST SKN SDBM8; MIN 0 (MAP SET)
       LDA MAPDAT; LDB MAPTIM  (DATE AND TIME MAP WRITTEN TO DISC)
       LDX MAPNUM  (MAP ZONE); BRU NXPOP

* BRS 158 - ADD TO "ROYALTY" CHARGE RPCHG WHICH IS WRITTEN IN USER
*      RESOURCE RECORDS.  NOTHING IS ADDED IF USER HAS NOT PREVIOUSLY
*      CALLED BRS 170 TO SET UP THE "ROYALTY" LIMIT, RPMAX, AND THE
*      MAXIMUM NO.  OF BRS 158 CALLS, RPN.
*
$BRS158 SKR RPN; SKA KM4B3 (LIMIT 2047D UNITS); BRU NXPOP; CAB
       IF MDSI
       LDX JOB; ADD =37777777B-2*60*3600; ADD ETTB,2 (ADD TO USER'S CPU TIME)
       SKG ETTB,2; BRM NPOPX (OVERFLOW); CBA
       ENDF
       ADD RPCHG; SKG RPMAX; SKG RPCHG; BRM NPOPX (EXCEEDED LIMIT)
       STA RPCHG
       IF MDSI
       CBA; ADM ETTB,2
       ENDF
       BRU NPOPX0

$BRS167 EQU * READ AND RESET BRS122,123,124,125 ERROR FLAG
       LDX JOB; LDA =4B4; SKA TTNO,2; BRU *+2; BRM NPOPX
       CNA; ADM TTNO,2; BRU NPOPX0

*
* BRS 170 - STORE "ROYALTY" PARAMETERS
*      A = MAX. NO. OF ROYALTY UNITS
*      B = MAX. NO. OF BRS 158 CALLS 
*
$BRS170 STA RPMAX; STB RPN; BRU NXPOP

* BRS 175, SAME AS BRS 89 WITH ETTB AS SEVENTH WORD
$BRS175 LDX JOB; LDA ETTB,2; LDX SS01; STA 6,6; BRU RESMT
*
* BRS 179   SET SUPERVISOR BIT OFF
$NSUP  CLA; STA SVST; BRM NPOPX

$BRS194 EQU *  KILL ONGOING TIMER WITHOUT DISMISSAL.  USE SPARINGLY
       EAX PUBPTR
       LDB K77
B194A  LDX 0,2; CXA; SKE =PUBPTR; BRU *+2; BRU B194B
       LDA 3,2; SKM UTTY; BRU B194A
       LDA 1,2; SKE B135C; BRU B194A
       LDA PUDEAD; STA 1,2; BRU B194A
B194B  LDX PACPTR; BRU B194C   (DISARM INTERRUPT 5)

$BRS195 EQU *  MAKE COMMAND PORT AN AUX PORT.  X = NEW COMMAND PORT
       SKN TTYASG,2; BRM NPOPX
       LDA TF2,2; ETR =JBY; LDX UTTY; DIR
       XMA TF2,2; ETR =-1-CEDY-JBY
       SKA =BRKY; BRU *+2; MRG =BRKY/7*2
       EIR; ADM TF2,2
       BRU B195A

       IF CEM
*      COMMAND EDIT.  GOES TO CECHR WHEN TYMNET
*      RELABELING NEEDED TO FILL LINE BUFFER.  RUNS
*      WITH TS PAGE IN LOGICAL PG. 7.

$TCI3 SKB TLBUF (SKIP IF LINE BUFFER IN OUTPUT STATE)
 BRU TCI4 (LINE BUFFER IN INPUT STATE)
 SKN TLCNR (SKIP IF LINE BUFFER EMPTY)
 BRU TCI5 (NOT EMPTY, RETURN NEXT CHAR)
 STB TLBUF (MARK BUFFER IN INPUT STATE)


TCI4 EQU *
TCI4A LDA TLCNR (LINE BUFFER CHAR COUNT)
 SKG CRTBL (FULL)
 BRU TCI6 (CONTINUE COMND EDIT INPUT)
TCI4B LDA TLBUF (LINE BUFFER PTR AND 1ST 2 CHARS)
 ETR K1S5 (SET BUFFER TO OUTPUT STATE)
 STA TLBUF (RESTORE PTR AND 1ST 2 CHARS)


$TCI5 BRM TCX (PLACE CHAR IN TUE9 (16-23)
 SKB TCLFLG (INSTRUCTION FOR TCX)
 LDA TUE9 (RECOVER CHAR)
 ETR K177
 LDX TCI5EX
 SKB K4B7 (SKIP IF LOOKAHEAD); BRU TCI5A
 SKE SS01; BRU 0,2 (STORE CHAR AND NONSKIP RETURN)
 MIN 0; EAX 1,2 (SS01 ALREADY CONTAINS CHAR)
 LDA K2B5; ADM TLBUF (ADJUST LINE BUFFER PTR)
TCI5A SKR TLCNR (DECREMENT LINE BUFFER COUNT)
 BRU 0,2 (RETURN TO MAIN EXIT LOOP)
 CLB
 STB TLBUF (RESET BUFFER PTR, EMPTY, OUTPUT)
 BRU 0,2 (EXIT)


TCI6 BRM CECHR (GET CHAR FROM INPUT BUFFER)
 LDA TUE9; SKA K100; BRU TCI6A; LDA KM1; STA CVSW; BRU TCICV1
TCI6A LSH 16
 LDB CHMSK
 LDX KM8 (NEG. LENGTH OF TABLE)
 SKM CRTBL,2
 BRX *-1
 LDA CRTBL,2
 STA TUE8 (SAVE TABLE ENTRY)
 SKN CVSW; BRU *+2; BRU TCICV1 (TAKE CHAR LITERALLY)
 SKA K4B7 (CONT-V); BRU TCICV
 SKA K200 (SKIP IF NOT CONT-A,Q,W)
 BRU TCI7 (PERFORM EDIT)
TCICV1 CLEAR; LDB CRTBL
 XMA CVSW (CLEAR CONTROL-V SWITCH)
 SKE ZERO (WAS IT SET); STB TUE8 (YES--FORGET CHAR PROPERTIES)
 BRM TCX (PLACE CHAR IN LINE BUFFER)
 STA TLBUF,2 (INSTRUCTION FOR TCX)
 MIN TLCNR (INCREMENT LINE BUFFER COUNT)
TCICV2 LDB KM1; LDA TUE8 (RECOVER CRTBL ENTRY)
 SKB TLCNR (LINE BUFFER EMPTY (1ST CHAR)
 SKE CRTBLG (SKIP IF CONTROL G)
 SKA K100 (SKIP IF CR,LF, OR CONT-G)
 BRU TCI4A (CHECK BUFFER, RECYCLE)
 BRU TCI4B (START OUTPUT PHASE)

TCICV STA CVSW (SET NEG.); BRU TCICV2
TCI7 SKB TLCNR (SKIP IF LINE BUFFER NOT EMPTY)
 BRU TCI6 (EMPTY, IGNORE EDIT)
 BRU* TCX,2 (PERFORM EDIT)
TCI7Q LDA KM1; STA TLCNR; LDA K4B7; STA TLBUF (RESET INTERLINE POINTER)
 BRU TCI6 (INPUT NEXT CHAR)
TCI7A BRM TCI7B (DECREMENT LINE POSITION)
 BRU TCI6 (INPUT NEXT CHAR)
TCI7W LDA KM1; STA TUE8 (LAST BLANK INDICATOR)
 STA TUGC (LAST COMMA INDICATOR)
TCI7W1 CLEAR
 BRM TCX (LOOK AT CURRENT CHAR. IN LINE)
 LDA TLBUF,2 (INSTRUCTION FOR TCX)
 LDB K177
 CLA (BLANK)
 SKM TUE9 (CUR CHAR A BLANK)
 BRU TCI7W3 (NO)
 SKN TUE8 (LAST BLANK)
 BRU TCI6 (YES, THRU)
TCI7W2 BRM TCI7B (DECREMENT LINE POS)
 BRU TCI7W1 (LOOK AT PRECEDING CHAR)
TCI7W3 LDA K14 (COMMA)
 SKM TUE9 (CUR CHAR A COMMA)
 BRU TCI7W4 (NO)
 SKN TUGC (LAST COMMA)
 BRU TCI6 (YES, THRU)
 BRU *+2
TCI7W4 MIN TUE8 (NEXT BLANK THRU)
 MIN TUGC (NEXT COMMA THRU)
 BRU TCI7W2

TCI7B ZRO
 LDA L8MSK (NEGATED LINE POS. INCREMENT)
 ADM TLBUF
 SKR TLCNR
 BRR TCI7B (NOT EMPTY)
 BRU TCI6 (EMPTY, DONE WITH EDIT)
 ZRO TCI7Q
 ZRO TCI7A
 ZRO TCI7W
TCX ZRO
 MIN TCX (ALWAYS SKIP)
 LDA TLBUF (LINE BUFFER PTR)
 ADD K2B5
 EXU* TCX
 STA TLBUF
 ETR CHMSK
 ABC
 DIV =3B5
 COPY BA,AX
 LRSH 12
 LDB TLBUF,2
 XXA
  LCY 8,2
 XMA TUE9
 EOR TUE9
 ETR K377
 EOR TUE9
 RCY 8,2
 COPY BA,AX
 LDB TCLFLG
 EXU* TCX
 STA TLBUF,2
 BRR TCX

* BIT 0=CONT-V
* BIT 16 (K200)=CONT-A,W,Q
* BIT 17 (K100)=NOT CR,LF, OR CONT-G
CRTBLG DATA 147B*2B5 (CONTROL G)
 DATA 155B*2B5 (CR)
 DATA 152B*2B5 (LF)
 DATA 144B*2B5
 DATA 4B7+100B+166B*2B5 (CONT-V)
 DATA 300B+161B*2B5 (CONT-Q)
 DATA 300B+141B*2B5 (CONT-A)
 DATA 300B+167B*2B5 (CONT-W)
CRTBL DATA 175B (OTHER CONTROL) (ALSO USE AS DATA)
L8MSK DATA 776B5
CHMSK DATA 376B5
       ENDF


*      BLOCK I/O SCANNER ENTERED FROM SCHEDULER.  PERFORMS
*      TASKS ON THE TTQ QUEUE DEPENDING ON THE STATE
*      EACH TASK IN IN.

*      STATE 1 = UNDECODED.  COMMAND LIST HAS NOT BEEN LOOKED AT YET.
*      STATE 2 = COMMAND READY TO PERFORM
*      STATE 3 = I/O STARTED (IF IO BITS ON) OR JUST COMPLETED
*      STATE 4 = POST PROCESSING IF ANY

$BIOSC LDA KM2; STA SWPCTR; STA NULSW; STA NULSW1
BIOSC1 ADD ONE; SKG ZERO; BRU BIOSC2
BIOSC4 MIN NULSW (TTQ NULL); BRU BIOSCE
BIOSC2 STA PASS; LDX K100; BRU BIONX1
$BIONX LDX PREPT
BIONX1 LDA TF6,2; SKA K100; BRU BIOSC3 (END OF QUEUE)
       STX PREPT; ETR K77; CAX
       LDA TF5,2; SKA =IOBY+TBBY; BRU BIONX1
       STX BPORT; ETR =CSTAY; LRSH CSTAZ; STA STATE
       SKG FOUR; SKG ZERO; BRM MONCR
       SKE FOUR; BRU STATE3
STATE4 SKN TF6,2; BRU BIOSW (TSWAP PRELIMINARY)
STATE1 SKN PASS; BRU *+2; BRU BIONX1 (IGNORE ON FIRST PASS)
       LDA BFL; SKE ZERO
       IF TST; SKN TTROSW; ELSE; SKN TROSW; ENDF
       BRU BIOSC4 (WAIT UP TO 2 SEC)
* ASSIGN A BUFFERLET
       CLX; NOD 24; LDB K2B7; LCY 24,2; EOR BFL; STA BFL
       COPY XA,B; CNA; SKG =15B; BRU *+2; BRM MONCR; STA T
       LSH CHBNZ; STA BFLN; LDX BPORT; DIR
       XMA TF5,2; ETR =-1-CHBNY; EIR; ADM TF5,2
       LDX T; LDA REAL; STA BLTIM,2; MIN NBFL
* SET TO SWAP BUFFERLET PAGE AND MAYBE THE PROGRAM PAGE
       LDA =TTIO2+1B5; BRU BIOSW1
BIOSC3 LDA PASS; BRU BIOSC1

STATE3 SKE THREE; BRU STATE1; SKN TF6,2; BRU ST3I
       LDA CMAP; BRU ST3O
$BIOSW LDA =TTIO1+1B5 (BRU TTIO1)
BIOSW1 STA PACGO4; LDA =SETTB; STA TJOB
       LDA KM1; STA PACSW; STA PG
       IF TSTAT; LDA =QTIGO+27B; STA RFR; ENDF
       LDX BPORT; LDA TF2,2; ETR K77; STA BJOB (MAY BE ZERO)
       LDA ONE; STA RAJOB1
* TRUTH TABLE TO CONTROL SWAPPING OF BUFFERLET AND PGM PAGES

* BITS 0-11 OUTPUT STATES:
* BITS 0-5 BRING BUFFERLET PAGE FOR STATES 0-5
* BITS 6-11 BRING PROGRAM PAGE FOR STATES 0-5

* BITS 12-23 INPUT STATES:
* BITS 12-17 BRING BUFFERLET PAGE FOR STATES 0-5
* BITS 18-23 BRING PROGRAM PAGE FOR STATES 0-5
       LDA =76767066B
       SKN TF6,2; LCY 12; LDX STATE (0-5)
       LCY 0,2; STA T1 (BRING BUFFERLET PAGE IF NEGATIVE)
       SKA K4B5 (BIT 6); BRU BIOSW2 (BRING PROGRAM PAGE)
       BRU TSWAP1 (BRING BUFFERLET PAGE MAYBE)
BIOSW2 LDX BPORT; LDA TF6,2; ETR =CPGY; LRSH CPGZ; STA T4
       MIN PG; LDX BJOB; LDA PMTP,2; SKG ZERO; BRU TSWAP1
       ADD T4; MRG =12B5; CAX; BRU TSWAP

*      BRS'S AND SUPPORTING ROUTINES FOR BASE/MAX STORAGE MEASUREMENT

* FETCH BASE+MAX DATA FOR FD GIVEN IN 'X'.  'A'=NEG. INDEX
*  TO SPEED UP SEARCH (OPTIONAL).  RETURNS 'A'= BASE STORAGE FIGURE,
*      'B'=MAX STORAGE USED, 'X'=UNCHANGED FROM CALL.
*      SKIPS IF FD MATCH IS FOUND.  IF NO MATCH IS FOUND A NONSKIP
*      RETURN IS GIVEN WITH THE NONTERMINAL BIT SET IN PIM.
$BRS183 CAX; SKG KM1; SKG =-NFDCB-1; LDX KM1
       LDB K7777; LDA SS03; SKM FDCBLE,2; BRU FDCBA2
FDCBA1 MIN 0; LDA BASE,2; LDB MAX,2; LDX SS03; BRU NXPOP
FDCBA2 BRM SCSAO; BRU FDCBA1; BRU WNROUT

* REPLACE BASE+MAX FROM 'A' AND 'B' FOR FD GIVEN IN 'X'.  RETURNS
* OLD VALUES IN 'A' AND 'B'.  TURNS OFF JA BIT IF ON.  IF NO MATCH
*      FOR FD IS FOUND, A NONSKIP RETURN WITH THE NONTERMINAL BIT SET
*      IN PIM IS GIVEN.  OTHERWISE, A SKIP RETURN IS GIVEN.
$BRS184 BRM SCSAO; BRU RFDCBD; BRU WNROUT

* ADJUST BASE+MAX GIVEN BASE ADJUSTMENT IN 'A' AND FD IN 'X'.
*      THIS BRS ADJUSTS THE BASE STORAGE FIGURE BY THE AMOUNT GIVEN
*      IN 'A' AND INCREASES THE MAX IF NECESSARY.  IF NO MATCH FOR
*      THE FD IS FOUND, A NONSKIP RETURN WITH THE NONTERMINAL BIT SET
*      IN PIM IS GIVEN.  OTHERWISE, A SKIP RETURN IS GIVEN.
$BRS188 BRM SCSAO; BRU ADBASE; BRU WNROUT

*      ACQUIRE FDCB FOR FD IN 'X'.  SCAN FOR REPLACEMENT OR MATCH.
*      1. NO SKIP IF MATCH FOUND.
*      2. SKIP IF MATCH FOUND BUT JA, OR IF WE ARE REPLACING
*              AN OLDER ENTRY.  IN THIS CASE 'A' NOW CONTAINS A NEGATIVE
*              FDCBLE INDEX FOR USE WITH BRS 184.
*      3. DOUBLE SKIP IF NO ENTRIES ARE REPLACEABLE.
*
*      IMPORTANT:  THIS BRS DOES NOT MAKE THE JOB NONTERMINABLE.
*      CORRECT USAGE REQUIRES THAT THE PROCESS BE NONTERMINABLE
*      PRIOR TO THE BRS 189 CALL, SINCE IT CAN SET THE JA BIT.
$BRS189 LDB K3777; LDX =FDCBHD-NXFDCB; STB T1
ACFDC0 LDA SS03
ACFDC1 SKN NXFDCB,2; BRU ACFDC5
       STX FDCPREV; LDX NXFDCB,2; STX FDCPTR
       SKM FDCBLE,2; BRU ACFDC3
       LDA FDCBLE,2
ACFDC7 STX SS01; SKA K4000 (JA)
ACFDC2 MIN 0; BRM REORD; BRM NPOPX
ACFDC3 SKN FDCBLE,2 (USE COUNT=0); BRU *+2 (YES); BRU ACFDC1
       LDA K1B5 (FLUSHED); LDB K4000 (JA); SKA FDCBLE,2
       SKB FDCBLE,2; BRU ACFDC4 (EITHER NOT FLUSHED OR JA)
       STX T; LDA FDCPREV; STA T1 (REMEMBER LOC.)
ACFDC4 LDB K3777; BRU ACFDC0
ACFDC5 LDX T; STX FDCPTR; LDA T1; STA FDCPREV
       SKA X4; BRU ACFDC6; MIN 0; BRU NPOPX0 (DOUBLE SKIP RETURN)
ACFDC6 LDA SS03; ETR K3777; MRG K4000 (JA); STA FDCBLE,2; BRU ACFDC7

REORD ZRO;* REORDER LIST.  X=FDCPTR, FDCPREV=PREVIOUS FDCPTR
       LDA NXFDCB,2; LDX FDCPREV; STA NXFDCB,2
       LDX FDCPTR; LDA FDCBHD; STA NXFDCB,2; STX FDCBHD
       BRR REORD

$SCSAO  ZRO;*SCAN STRUCTURE AND OPERATE
       MIN SCSAO
       LDX =FDCBHD-NXFDCB
       LDA SS03; LDB K7777
SCSAO1  SKN NXFDCB,2; BRR SCSAO
       STX FDCPREV; LDX NXFDCB,2; STX FDCPTR
       SKM FDCBLE,2; BRU SCSAO1
       EXU* SCSAO

RFDCBD EQU * REPLACE FDCB DATA FROM SS01 AND SS02
       LDA SS01 (NEW BASE); XMA BASE,2; STA SS01
       LDA SS02; XMA MAX,2; STA SS02
TOFFJA LDA FDCBLE,2; ETR =-1-1B5-4B3; STA FDCBLE,2 (TURN OFF FLUSHED AND JA)
       BRU ACFDC2 (REORDER LIST)

ADBASE EQU * ADJUST BASE AND MAX FROM SS01
       LDA SS01; CLB; ADM BASE,2; SKN BASE,2; BRU *+2; STB BASE,2
       LDA BASE,2; SKG MAX,2; BRU TOFFJA; STA MAX,2; BRU TOFFJA

$RLSFD1 EQU * DECREMENT USE COUNT ON FDCB WHEN CLOSING FILE
       LDA CBASE,2; CAX; SKG KM1; SKG =-NFDCB-1; BRM MONCR
       LDA FDCBLE,2; ADD K2B5; SKA X4; BRU RLSFD3
       SKA K3777 (FD ZERO); BRU RLSFD2; BRU RLSFD4
RLSFD2 ETR KS5 (ZERO USE COUNT AND FLUSHED BIT OFF)
RLSFD3 STA FDCBLE,2; BRU RLSFD4


$GTFDCB EQU * INCREMENT USE COUNT FOR FDCB IN FILE OPEN.
       LDA =-2B5; ADM FDCBLE,2
       BRM REORD; LDA BUFF; XXA; STA CBASE,2
       BRU CN3B

$FDCPREV ZRO
$FDCPTR  ZRO
$FDCBHD    DATA *+1-NXFDCB
       RPT NFDCB-1
       DATA *+1-NXFDCB
       ENDR
       DATA FDCBHD
$NXFDCB    EQU *
$ENDW   LDA =44445555B
       FORGET
       DELSYM
       END
MONITOR **FICHE/FRAME BREAK *****
W SYMSORT

SYM.  PG.LN. IDENT.

ACFDC0 21 23 W       ACFDC1 21 24 W       ACFDC2 21 29 W       
ACFDC3 21 30 W       ACFDC4 21 34 W       ACFDC5 21 35 W       ACFDC6 21 37 W       
ACFDC7 21 28 W       ADBASE 22 20 W       AST     1 33 W       AST2    1 36 W       
B106A  11 10 W       B135A  13 20 W       B135B  13 27 W       B194A  15  1 W       
B194B  15  5 W       B98SW  10  1 W       BIONX  19 17 W       BIONX1 19 18 W       
BIOSC  19 13 W       BIOSC1 19 14 W       BIOSC2 19 16 W       BIOSC3 19 37 W       
BIOSC4 19 15 W       BIOSW  20  2 W       BIOSW1 20  3 W       BIOSW2 20 22 W       
BLKBSY  5 21 W       BMTST  13 38 W       BPT2   13 16 W       BPTEST 13 13 W       
BRS106 11  8 W       BRS135 13 18 W       BRS136 13 33 W       BRS158 14  8 W       
BRS167 14 20 W       BRS170 14 29 W       BRS175 14 32 W       BRS183 20 33 W       
BRS184 21  3 W       BRS188 21 10 W       BRS189 21 22 W       BRS194 14 37 W       
BRS195 15  7 W       BRS42  11 38 W       BRS42A 11 39 W       BRS72  12 21 W       
BRS72A 12 22 W       BRS72B 12 25 W       BRS74  12 27 W       BRS76  12 29 W       
BRS98  10 35 W       CHKDEV  9  3 W       CHMSK  18 39 W       CRL6    6 19 W       
CRTBL  18 37 W       CRTBLG 18 29 W       CTL10   6 16 W       CTLI    6 39 W       
CTLI2   7  1 W       CTLX    6 32 W       CTLX2   6 33 W       CTLX3   6 37 W       
CTRL    6 11 W       ENDW   23  6 W       FDCBA1 20 35 W       FDCBA2 20 36 W       
FDCBHD 22 39 W       FDCPRE 22 37 W       FDCPTR 22 38 W       GTFDCB 22 32 W       
IORD    4  5 W       L8MSK  18 38 W       MAYDMS 12  7 W       NSUP   14 35 W       
NXFDCB 23  5 W       POSL    9 17 W       PRBWC   9 39 W       PRD2   11 17 W       
PRD4    9 21 W       PRD4A   9 20 W       PRDI    9 25 W       PRDI2   9 30 W       
PRDI3   9 28 W       PRDI4   9 36 W       PRDMS  11 16 W       PRSET   9  9 W       
PRSK    9 23 W       PRWC    9 37 W       RCPARW 11 36 W       RDCLEC 11 31 W       
REORD  21 39 W       RESMT  12 38 W       RFDCBD 22 14 W       RLSFD1 22 24 W       
RLSFD2 22 28 W       RLSFD3 22 29 W       RREAL  12  2 W       RSMET  13  7 W       
RTEX   12 32 W       SCSAO  22  5 W       SCSAO1 22  9 W       SETEC  11 33 W       
SETPAR  8 22 W       SETRL   1 26 W       SETXX   1 25 W       SKXEC  12 12 W       
STATE1 19 25 W       STATE3 19 39 W       STATE4 19 24 W       TBSF    8  2 W       
TBSFI   8  5 W       TBSFI3  8 12 W       TBSR    6 27 W       TCI3   15 20 W       
TCI4   15 27 W       TCI4A  15 28 W       TCI4B  15 31 W       TCI5   15 36 W       
TCI5A  16  6 W       TCI6   16 13 W       TCI6A  16 15 W       TCI7   17  1 W       
TCI7A  17  6 W       TCI7B  17 31 W       TCI7Q  17  4 W       TCI7W  17  8 W       
TCI7W1 17 10 W       TCI7W2 17 19 W       TCI7W3 17 21 W       TCI7W4 17 27 W       
TCICV  16 39 W       TCICV1 16 26 W       TCICV2 16 32 W       TCX    18  1 W       
TDS     6 15 W       TEOF    7 14 W       TEOF3   7 19 W       TEOF4   7 18 W       
TEOFI   7 20 W       TERS    7  7 W       TERS3   7 11 W       TFIN    8 39 W       
TFPR    8 16 W       TFSF    7 25 W       TFSF2   7 28 W       TFSFI   7 29 W       
TFSFI3  7 37 W       TOFFJA 22 17 W       TPDMS2  3 24 W       TPSET   3 29 W       
TPSET2  3 37 W       TRD     4  1 W       TRD2    4  4 W       TRD2A   4  3 W       
TRD4    3 23 W       TRD5    3 17 W       TRDMS   3 22 W       TRDMS1  3 21 W       
TREAD   3  7 W       TREW    6 22 W       TREW2   6 23 W       TREW3   6 24 W       
TRI1    4 29 W       TRI10   4 33 W       TRI2    4 30 W       TRI3    4 31 W       
TRI5    4 21 W       TRI6    4 25 W       TRI8    4 20 W       TRI9    4 32 W       
TRINT   4 10 W       TSTD2   8 28 W       TSTD3   8 31 W       TSTRDY  8 36 W       
TTRAP   8 33 W       TWI     5 24 W       TWI1    5 38 W       TWI10   6  5 W       
TWI2    6  3 W       TWI3    6  2 W       TWI6    5 39 W       TWI7    6  4 W       
TWR4    5 18 W       TWR5    5 19 W       TWRT    5  5 W       UAST    2  5 W       
UAST2   2  7 W       WDVR1  10  3 W       WDVR3  10 17 W       WDVR4  10 21 W       
WHT     2 10 W       WINT    2 17 W       XXDIR  11 21 W       XXEIR  11 24 W       

MONITOR ** FICHE/FRAME BREAK *****
XRA0
XRA0   IDENT 11/03/74
       NOLIST STAT,EXT

TTQSW EQU 1
DEBUG  EQU 1

* LIST OPTION FLAGS

CPAFLG EQU  0  LIST CPARW AND MAIL STATUS
GRPFLG EQU  1  LIST FD GROUP NO.
COMFLG EQU  2  LIST COMPUTE TIME
SWPFLG EQU  3  LIST SWAP COUNT
CHRFLG EQU  4  LIST CHAR COUNT
ACTFLG EQU  5  LIST ACTIVATION CONDITION
SUBFLG EQU  6  LIST SUBSYSTEM
MEMFLG EQU  7  LIST MEMORY USED
QTYFLG EQU  8  LIST QUEUE TYPE
UNMFLG EQU  9  LIST USER NAME
PACFLG EQU 10  LIST PACT CHAINS
PMTFLG EQU 11  LIST PMT ENTRIES
TTYFLG EQU 12  LIST PORTS ATTACHED
DEVFLG EQU 13  LIST DEVICES ASSIGNED
FILFLG EQU 14  LIST FILES OPENED
QUEFLG EQU 15  LIST COUNT OF USERS ON QUEUES

JRS    OPD 100B5,2
SPB    OPD 101B5,2
PEEK   OPD 102B5,2
ERR    OPD 103B5,2
SETF   OPD     10404000B,2
CLRF   OPD     10410000B,2
SKF    OPD     10414000B,2
SKNF   OPD     10420000B,2
XFA    OPD     104B5,2
TCF    OPD 105B5,2
MSG    OPD 106B5,2
FMTYPE OPD 112B5,2
PTYPE  OPD 113B5,2
SPTR   OPD 514B5,2

TYPE   MACRO D
XX     NARG
       IF XX=1
       FMTYPE D(1)
       ELSE
       PTYPE  D(1)
       NOP XX
       RPT (X=2,XX)
       NOP D(X)
       ENDR
       ENDF
       ENDM
FORMAT MACRO   D
       TEXT    \D(,)\
       ENDM
R1     MACRO D; BRU R1; ENDM
R2     MACRO D; BRU R2; ENDM

       FREEZE
       ENTRY PG0,INFIL2,FILPT2,FILBF2,WKPT
       ENTRY STACKP,MACHNO,BNUMR,BNUMS,FAS,FBCNT,FLS,FMAT,FMATP
       ENTRY FMATS,FMCNT,FSX,PCNT,PCNTS,PFROM,POUT,PRNPN2
       ENTRY PRNPNT,TADD,PRAY1,PRAY2,PRNCNT,BFPRN
       ENTRY SSV1,SSV2,SSV3,SV1,SV2,SV3
       ENTRY ARGSW,PROSW,CBUF,CBUFP,CHRCNT,CHSW
       ENTRY RPT,RPT1,DOPT,CMNX,WIDTH,GAN
       ENTRY USTA,XPORT
       ENTRY CIN,TOUT,CMNDP,CURPAG,INFIL
       ENTRY TRASW,FKPL,FKPX,FKRL1,FKRL2,FKSTA
       ENTRY PRGRL,LASTCH,OUTFIL
       ENTRY GCX,FLAG,MSW,OPTB,OPTX,PPTR,NXCHR
       ENTRY DIVISOR,FLTEMP,FLOAT
       ENTRY T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,FILPT,FILBUF
       ENTRY WKBUFF
       ENTRY SEL,XTTY,DSTRCT,ACCUM,UNM,XPPTR,CLOCK,CLOCK1,XPNEXT
       ENTRY RDMON,NINE,K34B3
       ENTRY ACT,BLKNO,BFR,BFRPOS,BUFLOC,BUFPT,CHARSW
       ENTRY HDSW1,HDSW2,HDSW3,HDSW4,HDSW
       ENTRY DEVNUM,DSCN,ENDPAG,EXECSW,FDSW,GFDSW,GFIL
       ENTRY INDEX,JOB,OFFSET,PAGCTR,PAGE,PAGCNT,PAGTBL
       ENTRY PMTADR,PMTPTR,PORT,PRPAGE,PTR,STR,PRIV
       ENTRY RL,SHPAGE,STPTR,TABLE,UNO,UN,XADRSMT
       ENTRY XADRPMT,XAEXSMT
BEGIN  EQU *
       BSS 11B+BEGIN-* (ROOM FOR SUBROUTINE CALL STACK)
STACKP ZRO
*      CELLS USED BY TYPE POP
MACHNO ZRO
BNUMR  ZRO
BNUMS  ZRO
FAS    ZRO
FBCNT  ZRO
FLS    ZRO
FMAT   ZRO
FMATP  ZRO
FMATS  BSS 2
FMCNT  ZRO
FSX    ZRO
PCNT   ZRO
PCNTS  ZRO
PFROM  ZRO
POUT   ZRO
PRNPN2 ZRO
PRNPNT ZRO
TADD   ZRO
PRAY1  BSS     10
PRAY2  BSS     10
PRNCNT ZRO
BFPRN  ZRO
SSV1   ZRO
SSV2   ZRO
SSV3   ZRO
SV1    ZRO
SV2    ZRO
SV3    ZRO
ARGSW  ZRO
*      END OF CELLS USED BY TYPE POP
PROSW  ZRO
CMNX ZRO
RPT    BSS 1
RPT1   BSS 1
DOPT  BSS 1 (POSITIVE TO DEMAND OPTIONS)
WIDTH BSS 1
       BSS 100B+BEGIN-*
       BSS 14B (ROOM FOR POP TV)
CBUF   BSS 20
CBUFP  BSS 2
CHRCNT BSS 1
CHSW   BSS 1 (POSITIVE TO PROMPT FOR OPTIONS)
CIN    BSS 1
TOUT   BSS 1
CMNDP  BSS 2
CURPAG BSS 1
INFIL BSS 1
INFIL2 BSS 1
TRASW BSS 1
FKPL BSS 3
FKPX BSS 1
FKRL1  BSS 1
FKRL2  BSS 1
FKSTA  BSS 1
PG0    BSS 1
PRGRL  BSS 2
PRGRL2 EQU PRGRL+1
LASTCH ZRO
OUTFIL ZRO
GCX    BSS 1
FLAG   BSS 1
MSW    BSS 1
OPTB   BSS 1
OPTX   BSS 1
PPTR   BSS 1
NXCHR  BSS 1
GAN    BSS 1
       BSS 213B+BEGIN-* (ROOM FOR INTERRUPTS)
USTA BSS 1
XPORT BSS 1
       BSS 240B+BEGIN-*
       BRU START
       BRS 10
       ASC 'A1.00'
       ASC %C'KY'R%

T1 BSS 1
T2 BSS 1
T3 BSS 1
T4 BSS 1
T5 BSS 1
T6 BSS 1
T7 BSS 1
T8 BSS 1
T9 BSS 1
T10 BSS 1
DIVISOR BSS 2
FLTEMP BSS 2
FLOAT BSS 2
FILPT BSS 2
FILBUF BSS 26
FILPT2 BSS 2
FILBF2 BSS 26
WKPT   BSS 2
WKBUFF   BSS 32
SEL BSS NPORT
XTTY ZRO
DSTRCT ZRO
ACCUM ZRO
UNM BSS 4
XPPTR ZRO
CLOCK ZRO
CLOCK1 ZRO
XPNEXT ZRO
ACT    ZRO
BLKNO  ZRO
BFR    BSS 128
BFRPOS ZRO
BUFLOC ZRO
BUFPT  ZRO
CHARSW ZRO
HDSW1 ZRO
HDSW2 ZRO
HDSW3 ZRO
HDSW4 ZRO
HDSW DATA -1 (ONCE ONLY HEADING SWITCH)
DEVNUM ZRO
DSCN   ZRO
ENDPAG ZRO
EXECSW ZRO
FDSW   ZRO
GFDSW  ZRO
GFIL   ZRO
INDEX  ZRO
JOB    ZRO
OFFSET ZRO
PAGCTR ZRO
PAGE   ZRO
PAGCNT ZRO
PAGTBL BSS 8
PMTADR ZRO
PMTPTR ZRO
PORT   DATA -1
PRPAGE ZRO
PTR    DATA 3*STR-1,3*STR-1
STR    BSS 12
PRIV   ZRO
RL     BSS 2
SHPAGE ZRO
STPTR  BSS 2
TABLE  BSS 8
UNO    ZRO
UN     ZRO
XADRSMT ZRO
XADRPMT ZRO
XAEXSMT ZRO

RDMON  CLA; SKN TRASW; BRU *+2; STA MSW; SKN RPT1; STA MSW
       SKN MSW; BRU *+2; R1
       LDA FKRL2; ETR K77; SNE PG0; CLA; XMA PRGRL2
       ETR =777777B2
       ADM PRGRL2; LDP PRGRL; BRS 44
       LDA KM1; STA CURPAG (NET IN WINDOW)
       SKN INFIL; BRU RDNET
       BRS 163 (NET TO USER PG 7)
NREAD  BRS 43; STP PRGRL
       LRSH 18; XMA FKRL2; ETR =777777B2; ADM FKRL2
       LDA K34B3; STA FKPX; ADD =CREAD; SKN INFIL; ADD =FREAD-CREAD
       STA FKPL; LDA =FKPL+634B5; BRS 9; BRS 42; ADD CLOCK; STA CLOCK1
       LDA PRGRL2; ETR K77; XMA FKRL2; ETR =777777B2
       ADM FKRL2; LDA FKSTA; SKE ZERO; ERR NLD
       LDA KM1; STA MSW; PEEK CRSH; SKE =61B5+202B; BRU *+3
       TYPE SNAP; R1; TYPE ALIGN; R1
CREAD  BRS 61; BRS 10
FREAD  LDA NINE,2; SCP INFIL+34000B; HLT
       LDA K34B3,2; CLX; BIO INFIL+34000B; HLT
       BRS 10
RDNET  LDA NINE; SCP INFIL2; ERR NETFIL
       LDA =4000B; LDX K34B3; BIO INFIL2; ERR NETFIL
       BRU NREAD
NINE   DATA 9
K34B3  DATA 34B3
       IF 4001B+BEGIN-*; ELSE
       REM TOO MUCH CODE IN USER PG 0
       ENDF

       END
MONITOR ** FICHE/FRAME BREAK *****
XRA0 SYMSORT

SYM.  PG.LN. IDENT.

ACCUM   5 30 XRA0    ACT     5 36 XRA0    ACTFLG  1 14 XRA0    
ARGSW   3 38 XRA0    BEGIN   3  6 XRA0    BFPRN   3 31 XRA0    BFR     5 38 XRA0    
BFRPOS  5 39 XRA0    BLKNO   5 37 XRA0    BNUMR   3 11 XRA0    BNUMS   3 12 XRA0    
BUFLOC  6  1 XRA0    BUFPT   6  2 XRA0    CBUF    4  9 XRA0    CBUFP   4 10 XRA0    
CHARSW  6  3 XRA0    CHRCNT  4 11 XRA0    CHRFLG  1 13 XRA0    CHSW    4 12 XRA0    
CIN     4 13 XRA0    CLOCK   5 33 XRA0    CLOCK1  5 34 XRA0    CLRF    1 31 XRA0    
CMNDP   4 15 XRA0    CMNX    4  2 XRA0    COMFLG  1 11 XRA0    CPAFLG  1  9 XRA0    
CREAD   7 17 XRA0    CURPAG  4 16 XRA0    DEBUG   1  5 XRA0    DEVFLG  1 22 XRA0    
DEVNUM  6  9 XRA0    DIVISO  5 18 XRA0    DOPT    4  5 XRA0    DSCN    6 10 XRA0    
DSTRCT  5 29 XRA0    ENDPAG  6 11 XRA0    ERR     1 29 XRA0    EXECSW  6 12 XRA0    
FAS     3 13 XRA0    FBCNT   3 14 XRA0    FDSW    6 13 XRA0    FILBF2  5 24 XRA0    
FILBUF  5 22 XRA0    FILFLG  1 23 XRA0    FILPT   5 21 XRA0    FILPT2  5 23 XRA0    
FKPL    4 20 XRA0    FKPX    4 21 XRA0    FKRL1   4 22 XRA0    FKRL2   4 23 XRA0    
FKSTA   4 24 XRA0    FLAG    4 31 XRA0    FLOAT   5 20 XRA0    FLS     3 15 XRA0    
FLTEMP  5 19 XRA0    FMAT    3 16 XRA0    FMATP   3 17 XRA0    FMATS   3 18 XRA0    
FMCNT   3 19 XRA0    FMTYPE  1 37 XRA0    FORMAT  2 14 XRA0    FREAD   7 18 XRA0    
FSX     3 20 XRA0    GAN     4 37 XRA0    GCX     4 30 XRA0    GFDSW   6 14 XRA0    
GFIL    6 15 XRA0    GRPFLG  1 10 XRA0    HDSW    6  8 XRA0    HDSW1   6  4 XRA0    
HDSW2   6  5 XRA0    HDSW3   6  6 XRA0    HDSW4   6  7 XRA0    INDEX   6 16 XRA0    
INFIL   4 17 XRA0    INFIL2  4 18 XRA0    JOB     6 17 XRA0    JRS     1 26 XRA0    
K34B3   7 25 XRA0    LASTCH  4 28 XRA0    MACHNO  3 10 XRA0    MEMFLG  1 16 XRA0    
MSG     1 36 XRA0    MSW     4 32 XRA0    NINE    7 24 XRA0    NREAD   7  9 XRA0    
NXCHR   4 36 XRA0    OFFSET  6 18 XRA0    OPTB    4 33 XRA0    OPTX    4 34 XRA0    
OUTFIL  4 29 XRA0    PACFLG  1 19 XRA0    PAGCNT  6 21 XRA0    PAGCTR  6 19 XRA0    
PAGE    6 20 XRA0    PAGTBL  6 22 XRA0    PCNT    3 21 XRA0    PCNTS   3 22 XRA0    
PEEK    1 28 XRA0    PFROM   3 23 XRA0    PG0     4 25 XRA0    PMTADR  6 23 XRA0    
PMTFLG  1 20 XRA0    PMTPTR  6 24 XRA0    PORT    6 25 XRA0    POUT    3 24 XRA0    
PPTR    4 35 XRA0    PRAY1   3 28 XRA0    PRAY2   3 29 XRA0    PRGRL   4 26 XRA0    
PRGRL2  4 27 XRA0    PRIV    6 29 XRA0    PRNCNT  3 30 XRA0    PRNPN2  3 25 XRA0    
PRNPNT  3 26 XRA0    PROSW   4  1 XRA0    PRPAGE  6 26 XRA0    PTR     6 27 XRA0    
PTYPE   1 38 XRA0    QTYFLG  1 17 XRA0    QUEFLG  1 24 XRA0    R1      2 17 XRA0    
R2      2 18 XRA0    RDMON   7  1 XRA0    RDNET   7 21 XRA0    RL      6 30 XRA0    
RPT     4  3 XRA0    RPT1    4  4 XRA0    SEL     5 27 XRA0    SETF    1 30 XRA0    
SHPAGE  6 31 XRA0    SKF     1 32 XRA0    SKNF    1 33 XRA0    SPB     1 27 XRA0    
SPTR    1 39 XRA0    SSV1    3 32 XRA0    SSV2    3 33 XRA0    SSV3    3 34 XRA0    
STACKP  3  8 XRA0    STPTR   6 32 XRA0    STR     6 28 XRA0    SUBFLG  1 15 XRA0    
SV1     3 35 XRA0    SV2     3 36 XRA0    SV3     3 37 XRA0    SWPFLG  1 12 XRA0    
T1      5  8 XRA0    T10     5 17 XRA0    T2      5  9 XRA0    T3      5 10 XRA0    
T4      5 11 XRA0    T5      5 12 XRA0    T6      5 13 XRA0    T7      5 14 XRA0    
T8      5 15 XRA0    T9      5 16 XRA0    TABLE   6 33 XRA0    TADD    3 27 XRA0    
TCF     1 35 XRA0    TOUT    4 14 XRA0    TRASW   4 19 XRA0    TTQSW   1  4 XRA0    
TTYFLG  1 21 XRA0    TYPE    2  2 XRA0    UN      6 35 XRA0    UNM     5 31 XRA0    
UNMFLG  1 18 XRA0    UNO     6 34 XRA0    USTA    4 39 XRA0    WIDTH   4  6 XRA0    
WKBUFF  5 26 XRA0    WKPT    5 25 XRA0    XADRPM  6 37 XRA0    XADRSM  6 36 XRA0    
XAEXSM  6 38 XRA0    XFA     1 34 XRA0    XPNEXT  5 35 XRA0    XPORT   5  1 XRA0    
XPPTR   5 32 XRA0    XTTY    5 28 XRA0    XX      2  3 XRA0    
MONITOR ** FICHE/FRAME BREAK *****
XRA1
XRA1   IDENT 8/31/76
       NOLIST STAT,EXT

       ENTRY ONE,KM1,ZERO
       ENTRY CRCD,CRCH,GCMND,START
       ENTRY R1,R2,LFCH,XPOP,NXCH
       ENTRY ILCH,ERRET

START  STP CIN; LDX =DATA-DATAE; LDA DATAE,2; STA* DATAJ,2; BRX *-2
       LDB KM1; SPB INITS (INITIALIZE SELECT TO ALL PORTS)
       LDA =4B4; BRS 12
       BRS 71; NOP; STB USTA
* MUST BE TYMSHARE PROPRIETARY UNLESS PERSONAL EXE OR SYS LICENSE
       SKB =4B7; BRU STCK4; BRS 39; SKA =4B7; BRU STCK2
STCK1 TYPE MSTAT; BRS 10
* MUST HAVE OPER LICENSE AND DIST 0 UNLESS USER IS MDSISUP ON
* MDSI MACHINE
STCK2  XAB; SKE =123723B (MDSISUP); BRU STCK3
       LDA =T1; LDX =31; BRS 7; LDA T1; SKE =1; BRU STCK1; BRU STCK4
STCK3  SKB =1B7 (OPER LICENSE); SKB =7774B; BRU STCK1 (NOT DIST 0)
STCK4  TYPE PVERS
       LDA TOUT; STA OUTFIL
* WINDOW PAGE IS AT 34000B.  PAGE AT 30000B IS RESERVED FOR LUD READS.
       BRS 43; STP PRGRL; LRSH 18; STA PG0; BRU CRCD

* ERROR ENTRY POINT
ILCH   STA T1; SPB BRS29; SPB CLSCFI
       TYPE ILCHM; LDA T1; JRS TYPCHR; TCF =2
ERRET  SPB BRS11
* COMMAND DISPATCHER

CRCD   LDA CRCH; CIO TOUT
       LDA TOUT; SKE POUT; BRU *+2; BRU CD
       LDA CRCH; CIO POUT
CD     LDA TOUT; STA POUT
       LDA =2B6; BRS 78
       LDA FLAG; ETR KM1; STA FLAG
       LDA SINIT; STA STACKP
       CLA; STA ACCUM
       BRS 114
       LDA KM1; STA HDSW1; STA HDSW2; STA HDSW3; STA HDSW4
       LDA =12B (READINESS SYMBOL); SKN CHSW (STILL WORKING ON LAST COMMAND)
       CIO TOUT
       SPTR CBUF; STP CBUFP; CLA; STA CBUF
       EAX CBUFP; JRS GCMND (GET COMMAND FROM LINE BUFFER)
       LDA CBUF
       LDX =CTBL-CTBLE
CLOOK  SKE CTBLE,2; BRU NCMND
       LDA OUTFIL; STA POUT; STX CMNX
RPT2   LDB KM1; LDA RPT1; SKE RPT; SKG KM1; CLB
       STB DOPT (DEMAND OPTIONS WHEN POS)
       LDA CTTBLE,2; STA CMNDP; ETR =2B6+37777B; XMA CMNDP
       CAB
       LCY 2 (SIGN NOT USABLE DUE TO LOADER PROBLEMS)
       LDX =-7
OPT    LCY 1; SKA ONE; BRU OPTA
OPTN   BRX OPT; JRS* CMNDP
       LDA RPT1
       LDX CMNX; LDB =2B7; SKB CTTBLE,2; SKG KM1; BRU OPTZ (NO REPEAT)
       SKG ZERO; BRU OPTY (NO DELAY)
       BRS 42; SUB CLOCK1; CNA; SKG ZERO; BRU BEL
       MUL =1000; DIV =60; BRS 81; BRU *+2
BEL    TCO =147B
OPTY   LDX CMNX; SKR RPT1; BRU RPT2
OPTZ   LDA CMNDP; SKA =CC; BRU CRCD; SKN CHSW; BRU CD; BRU CRCD
OPTA   STB OPTB; STX OPTX; JRS* CTOBLE,2
       LDB OPTB; LDX OPTX; BRU OPTN
NCMND  BRX CLOOK
QM     SPB BRS29; TCF =37B; BRU ESCAP2

OPCK   BRS 71; BRU *+2; R1; BRS 39; SKA =1B7; SKA =7774B; BRU QM; R1

EXIT   BRS 147; BRS 10

ESCAPE ZRO SV1; SPB BRS29
ESCAP2 SPB CLSCFI; BRU ERRET
GCMND EQU * GET COMMAND SUBSTRING.  'X'=ADDR OF STRING PTRS
*              FOR STRING WRITTEN INTO.
       STX GCX
       LDX KM1; STX CHSW; STX PROSW (PROTECTED STRING SWITCH)
GCMND1 SBRM NXCH
       SKE ="  /"; SNE ="  '"; BRU GCMND5
       SKN PROSW; BRU GCMND4; LDX =DELIM-DELIME
GCMND2 SKE DELIME,2; BRU GCMND3
       STA LASTCH
       SKE CRCH; SNE LFCH; STA CHSW (POS FOR CR OR LF)
NULL   R1
GCMND3 BRX GCMND2
GCMND4 LDX GCX; WCI 0,2; BRU GCMND1
GCMND5 SKN PROSW; BRU GCMND6
       STA PROSW (POS); BRU GCMND4
GCMND6 SKE PROSW; BRU GCMND4
       LDA KM1; XMA PROSW; BRU GCMND4

NXCH   ZRO NXCHR  (GET A CHARACTER FROM THE INPUT LINE)
NXCH3  CIO CIN
       SKE =137B (EOF); BRR NXCHR
       CLA; STA CIN; BRS 151; BRU NXCH3


*:*:*:*:*:*:* POPS AND SUCH *:*:*:*:*:*

* JUMP RECURSIVELY TO SUBROUTINE
SJRS   STA* STACKP; LDA 0; XMA* STACKP
       SKR STACKP; BRU* 0; ERR OFLOW
* RETURN SKIPPING
R2     MIN STACKP; MIN* STACKP; BRU R1+1
* RETURN NON-SKIP
R1     MIN STACKP
       IF DEBUG
       XMA STACKP; ETR K3S4; SKG SINIT; BRU *+2
       ERR UFLOW; XMA STACKP
       ENDF
       BRR* STACKP
*      PEEK AT MONITOR WORD THROUGH WINDOW.

PEEKABO SKN MSW; ERR NLD (MON NOT LOADED)
       STX SV3
       EAX* 0
PEEK1  CXA; EOR CURPAG (INITIALLY -1)
       SKA K34B3; BRU PEEK2 (NOT IN WINDOW)
       MRG =34000B; ETR K3S4; STA PPTR
       LDA* PPTR; LDX SV3; BRR 0
PEEK2  STX SSV3; STB SV2; CXA; ETR K34B3; STA CURPAG
       MUL =6B4; CAX; LDP FKRL1; LCY 6,2; CBA
       ETR =77B; SKG ZERO; ERR NLD; STA SV1
       BRS 43; XAB; ETR =777777B2; MRG SV1; XAB; BRS 44
       STP PRGRL
       LDX SSV3; LDB SV2; BRU PEEK1

* ERROR.  PRINT MESSAGE, CLEAN UP, ETC. RETURN TO CD.

ERR1   LDA 0; STA T1
       SPB BRS29 (CLEAR OUTPUT BUFFER)
       SPB CLSCFI (CLOSE COMMANDS FILES)
       TYPE _T1
       SPB BRS11 (CLEAR INPUT BUFFER)
       SPB CLEAN (CLEAN UP GOODIES)
       BRU CRCD


*      FLAG POP

9FLG   STA     SV1
        STB     SV2
        STX     SV3
        EAX*    0
 COPY XA,XB,X
        EAX     FLAG
        ETR     =377B
    SKB     K34B3
        BRU     *+4
        LDA     SV1
        XMA     0,2
        BRU     APOP
        XAB
        ETR     K34B3
        SKG     =20000B (B10)
        BRU     *+2
       ZRO
        STX     SSV1
        STB     SSV2
        RSH     11
        AXC
        LDB     =4B7
        RSH*    SSV2
        BRU     *,2
        BRU     SETFL
        BRU     CLFL
        BRU     SKFL
        SKB*    SSV1
        BRU     POPX
        MIN     0
        BRU     POPX
SKFL    SKB*    SSV1
        MIN     0
        BRU     POPX
SETFL   CBA
        MRG*    SSV1
        STA*    SSV1
        BRU     POPX
CLFL    CBA
        EOR     KM1
        ETR*    SSV1
        STA*    SSV1
POPX   LDA SV1
APOP   LDB SV2
XPOP   LDX SV3
       BRR 0
*      WRITE CHAR. POP

POP5   STA SV1; LDA* 0; CIO POUT; LDA SV1; BRR 0

*      MESSAGE POP (SIMPLER THAN TYPE)

POP6   STA SV1; STB SV2; STX SV3
       EAX* 0; CXA; ETR K3S4; LDB KM1; LDX POUT; BRS 34
       BRU POPX


*:*:*:*:*:*:* THE TYPE POP *:*:*:*:*:*:*
POP12  STA     SV1
       LDA KM1
       BRU     POP13B
POP13  STA     SV1
       CLA
POP13B STA     ARGSW
       STB     SV2
       STX     SV3
       STX     FSX
       LDA     KM1
       STA     PRNCNT
       LDA     =PRAY1
       STA     PRNPNT
       LDA     =PRAY2
       STA     PRNPN2
       LDA     0
       ETR     K3S4
       STA     PFROM
       EAX*    0
       COPY    AX,XA
       ETR     K3S4
       MUL     =4
       LSH     23
       STA     FMAT
       STA     FMATP
       LDA     1,2
       ETR     K3S4
       SKN ARGSW
       ADM     0
       SUB     ONE
       STA     PCNT
       STA     PCNTS
FMLOOP CLA
       STA     FMCNT
       BRM     TGCI
       LDX     =-14
       SNE     PFLIST+14,2
       BRU*    PBRA+14,2
       BRX     *-2
       SKL     =20B
       SKL     =32B
       BRU     BFMAT2
       SKR     FMAT
       SBRM    BNUM
       SUB     ONE
       STA     FMCNT
       BRU     FMLOOP+2
CFRM   LDX =-3; LDB MACHNO
       LCY 8; CIO POUT; BRX *-2
       BRU FMLOOP
DOLLAR BRM     TGCI
       SNE     =4B
       BRU     FMLOOP
       CIO     POUT
       BRU     DOLLAR
XFMAT  LDA     MBCH
       CIO     POUT
       LDA     FMCNT
       ADD     ONE
       CIO     POUT
       BRU     FMLOOP
HMAT   LDA     FMCNT
       ADD     ONE
       CNA
       CAX
       BRM     TGCI
       CIO     POUT
       BRX     *-2
       BRU     FMLOOP
FSLASH LDA     CRCH
       CIO     POUT
       BRU     FMLOOP
FRP    SKR     PRNPN2
       SKR*    PRNPN2
       BRU     *+2
       BRU     RPN2
       MIN     PRNPN2
       SKR     PRNPNT
       LDA*    PRNPNT
       MIN     PRNPNT
       STA     FMAT
       BRU     FMLOOP
RPN2   SKR     PRNCNT
       BRU     *+2
       BRU     POPX
       SKR     PRNPNT
       BRU     FMLOOP
       BRU     POPX
LPRNTH MIN     PRNCNT
       LDA     PRNCNT
       SKL     =5
       BRU     BFMAT3
       LDA     FMAT
       STA*    PRNPNT
       MIN     PRNPNT
       LDA     FMCNT
       STA*    PRNPN2
       MIN     PRNPN2
       BRU     FMLOOP
LFM    SBRM    BADD
       BRU     FMLOOP
       LDA     0,2
       LDB     TEN
       LDX     POUT
       BRS     36
       SKR     FMCNT
       BRU     LFM
       BRU     FMLOOP
FII    SBRM    BNUM
       STA     FBCNT
       CLB
       LSH     9
       ADD     K1B7
       ADD     POUT
       STA     FBCNT
FI2    SBRM    BADD
       BRU     XMAT2
       LDA     0,2
       LDX     FBCNT
       BRS     165
       SKR     FMCNT
       BRU     FI2
       BRU     FMLOOP
FIB    SBRM    BNUM
       STA     FBCNT (FW)
FIB2   SBRM    BADD
       BRU     XMAT2
       LDA FBCNT; STA SSV1; STX SSV3
       LDA 0,2; SKE ZERO; BRU FIB3; SKR SSV1; NOP
FIB3   SKA KM1; BRU *+2; BRU FIB4
       LRSH 3; SKR SSV1; BRU FIB3
FIB4   LDA SSV1; SKG ZERO; BRU FIB6
       CNA; AXC; CIO POUT; BRX *-1
FIB5   LDX SSV3
FIB6   LDA     0,2
       LDX     POUT
       LDB     =8
       BRS     36
       SKR     FMCNT
       BRU     FIB2
       BRU     FMLOOP
FAA     SBRM    BNUM
       STA     FBCNT
       CNA; STA FAS
FA2    SBRM    BADD
       BRU     XMAT2
       CXA
       ETR K3S4
       MUL     THREE
       LSH     23
       SUB     ONE
       STA     FMATS
       ADD     FBCNT
       STA     FMATS+1
       LDX     FAS
FA4    GCI     FMATS
       BRU     FA3
       SKA     K100
       BRU     *+2
       BRU     *+5
       STA     TADD
       LDA     =6
       CIO     POUT
       LDA     TADD
       ETR     =77B
       CIO     POUT
       BRX     FA4
FA3    SKR     FMCNT
       BRU     FA2
       BRU     FMLOOP
XMAT2  LDA     MBCH
       CIO     POUT
       LDA     FBCNT
       SKG     ZERO
       LDA     ONE
       CIO     POUT
       SKR     FMCNT
       BRU     XMAT2
       BRU     FMLOOP
BNUM   ZRO     BNUMR
       CLA
       STA     BNUMS
       BRM     TGCI
       SKL     =20B
       SKL     =32B
       BRU     *+7
       SUB     =20B
       XMA     BNUMS
       MUL     TEN
       LSH     23
       ADM     BNUMS
       BRU     *-9
       LDA     BNUMS
       SKR     FMAT
       BRR     BNUMR
AFL     SBRM    BNUM
       CLB
       LSH     9
       STA     FLS
       BRM     TGCI
       SKE     K16
       BRU     BFMAT
       SBRM    BNUM
       CLB
       LSH     15
       ADM     FLS
        LDA     =3B7
       MRG     POUT
       ADM     FLS
AFL3    SBRM    BADD
       BRU XMAT3
       LDP     0,2
       LDX     FLS
       BRS     165
       SKR     FMCNT
       BRU     AFL3
       BRU     FMLOOP
XMAT3  MIN     FMCNT
       LDA     MBCH
       CIO     POUT
       LDA     FLS
       ETR     =77B3
       LRSH    9
       CIO     POUT
       SKR     FMCNT
       BRU     XMAT3+1
       BRU     FMLOOP
BADD   ZRO     BNUMR
       LDA     PCNT
       SKG     ZERO
       BRU     BADD2
       LDA     PCNTS
       ADD     PFROM
       SUB     PCNT
       SKR     PCNT
       ETR     K3S4
       ADD     =2
       MRG     =4B4
       STA     TADD
       LDX     FSX
       EAX*    TADD
       MIN     BNUMR
BADD2  CLA
       BRR     BNUMR
BFMAT1 TYPE    NFILEN
       BRU     BFMAT
BFMAT3 TYPE    OV5
       BRU     BFMAT
BFMAT2 TCO     CRCH
       LDA     FMATP
       XMA     FMAT
       SUB     FMAT
       CNA
       CAX
       BRM     TGCI
       CIO     ONE
       BRX     *-2
       TYPE    LCHR
BFMAT  LDA     0
       ETR     K3S4
       SUB     PCNTS
       SUB     ONE
       STA     BFPRN
       TYPE    BFMATM,BFPRN
       BRS     10
PFLIST ASC     '  $  X  ,  )  I  A  (  B  H     /  F  L  C'
PBRA   DATA    DOLLAR,XFMAT,FMLOOP,FRP,FII,FAA,LPRNTH,FIB,HMAT,FMLOOP
        DATA    FSLASH,AFL,LFM,CFRM
BFMATM FORMAT  (/$AT OCTAL LOCATION $B5/)
LCHR   FORMAT  (/$FORMAT ERROR, LAST CHARACTER NOT ACCEPTABLE$)
NFILEN FORMAT  (/$FORMAT ERROR, NO FILE NUMBER$)
OV5    FORMAT  (/$FORMAT ERROR, TOO MANY STACKED PARENTHESES$)
TGCI   ZRO
       STP     SSV1
       STX     SSV3
       LDA     FMAT
       LRSH    23
       DIV     =4
       COPY    AX,BA
       MUL     =6
       LSH     23
       LDB     0,2
       XXA
       LCY     6,2
       ETR     =77B
       MIN     FMAT
       LDB     SSV2
       LDX     SSV3
       BRR     TGCI
*:*:*:*:*:*:* END OF TYPE POP *:*:*:*:*:*:*

*:*:*:*:*:*:* DATA AND SUCH *:*:*:*:*:*:*:*

DATA   DATA 1,-1,0,0
SINIT  DATA STACKP-1,-1,0
       BRU SJRS; BRU* 0; BRU PEEKABO; BRU ERR1
       BRU 9FLG; BRU POP5; BRU POP6
       BRU POP12; BRU POP13
       DATA ESCAPE
       DATA -1,-1,76643000B,600
DATAE EQU *
       DATA POUT,CURPAG,CHSW,MSW
       DATA STACKP,INFIL,TRASW
       DATA 100B,101B,102B,103B
       DATA 104B,105B,106B
       DATA 112B,113B,201B
       DATA RPT1,RPT,FLAG,CLOCK
DATAJ EQU *
ONE    EQU DATA
KM1    EQU DATA+1
ZERO   EQU DATA+2

* COMMAND TABLE

RR EQU 2B7 REPEAT
VV EQU 1B7 VALIDATE
XX EQU 4B6 SNAPSHOT REQUIRED
CC EQU 2B6 CARRIAGE RETURN
CTBL   ASC '   QUIQ  DATGETXBRSSTB44RADTRARPTLISSELGO CLKHELTTQPUQ'
CTBLE EQU *
       DATA CD,EXIT,EXIT,DATE+XX
       DATA GET+VV,XBR+RR+XX
       DATA SST+RR+XX
       DATA B44+RR+XX
       DATA RAD+RR+XX
       DATA TRACE+CC,REPEAT+CC,LIST,SELECT,GO+RR+XX+CC
       DATA CLKSET,HELP,BSCAN+RR+XX+CC,PUQ+RR+XX+CC
CTTBLE EQU *
*      OPTIONAL SUBROUTINES FOR EACH COMMAND
       FORGET RR
       FORGET VV
       FORGET XX

       DATA OPCK  (BIT 2 - COMMAND REQUIRES VALIDATION)
       DATA RDMON (BIT 3 - COMMAND REQUIRES MONITOR TO BE LOADED)
       DATA NULL  (BIT 4
       DATA NULL  (BIT 5
       DATA NULL  (BIT 6
       DATA NULL  (BIT 7
       DATA NULL  (BIT 8
CTOBLE EQU *

* DELIMITER TABLE

DELIM DATA 0,14B,152B,155B,15B
DELIME EQU *
LFCH   EQU DELIM+2
CRCH   EQU DELIM+3

       END
MONITOR ** FICHE/FRAME BREAK *****
XRA1 SYMSORT

SYM.  PG.LN. IDENT.

9FLG    4 27 XRA1    AFL    11  7 XRA1    AFL3   11 21 XRA1    
APOP    5 31 XRA1    BADD   11 39 XRA1    BADD2  12 15 XRA1    BEL     2 24 XRA1    
BFMAT  12 31 XRA1    BFMAT1 12 17 XRA1    BFMAT2 12 21 XRA1    BFMAT3 12 19 XRA1    
BFMATM 13  2 XRA1    BNUM   10 30 XRA1    CC     14 12 XRA1    CD      1 35 XRA1    
CFRM    7 15 XRA1    CLFL    5 26 XRA1    CLOOK   2  9 XRA1    CRCD    1 32 XRA1    
CRCH   15  3 XRA1    CTBL   14 13 XRA1    CTBLE  14 14 XRA1    CTOBLE 14 35 XRA1    
CTTBLE 14 22 XRA1    DATA   13 27 XRA1    DATAE  13 34 XRA1    DATAJ  14  2 XRA1    
DELIM  14 39 XRA1    DELIME 15  1 XRA1    DOLLAR  7 18 XRA1    ERR1    4 16 XRA1    
ERRET   1 29 XRA1    ESCAP2  2 37 XRA1    ESCAPE  2 36 XRA1    EXIT    2 34 XRA1    
FA2     9 34 XRA1    FA3    10 18 XRA1    FA4    10  6 XRA1    FAA     9 31 XRA1    
FI2     9  5 XRA1    FIB     9 13 XRA1    FIB2    9 15 XRA1    FIB3    9 19 XRA1    
FIB4    9 21 XRA1    FIB5    9 23 XRA1    FIB6    9 24 XRA1    FII     8 37 XRA1    
FMLOOP  6 39 XRA1    FRP     8  1 XRA1    FSLASH  7 37 XRA1    GCMND   2 38 XRA1    
GCMND1  3  3 XRA1    GCMND2  3  6 XRA1    GCMND3  3 10 XRA1    GCMND4  3 11 XRA1    
GCMND5  3 12 XRA1    GCMND6  3 14 XRA1    HMAT    7 29 XRA1    ILCH    1 27 XRA1    
KM1    14  4 XRA1    LCHR   13  3 XRA1    LFCH   15  2 XRA1    LFM     8 28 XRA1    
LPRNTH  8 17 XRA1    NCMND   2 29 XRA1    NFILEN 13  4 XRA1    NULL    3  9 XRA1    
NXCH    3 17 XRA1    NXCH3   3 18 XRA1    ONE    14  3 XRA1    OPCK    2 32 XRA1    
OPT     2 17 XRA1    OPTA    2 27 XRA1    OPTN    2 18 XRA1    OPTY    2 25 XRA1    
OPTZ    2 26 XRA1    OV5    13  5 XRA1    PBRA   12 39 XRA1    PEEK1   4  3 XRA1    
PEEK2   4  7 XRA1    PEEKAB  3 39 XRA1    PFLIST 12 38 XRA1    POP12   6  7 XRA1    
POP13   6 10 XRA1    POP13B  6 12 XRA1    POP5    5 36 XRA1    POP6    6  1 XRA1    
POPX    5 30 XRA1    QM      2 30 XRA1    R1      3 31 XRA1    R2      3 29 XRA1    
RPN2    8 11 XRA1    RPT2    2 11 XRA1    RR     14  9 XRA1    SETFL   5 22 XRA1    
SINIT  13 28 XRA1    SJRS    3 26 XRA1    SKFL    5 19 XRA1    START   1  9 XRA1    
STCK1   1 15 XRA1    STCK2   1 18 XRA1    STCK3   1 20 XRA1    STCK4   1 21 XRA1    
TGCI   13  6 XRA1    VV     14 10 XRA1    XFMAT   7 23 XRA1    XMAT2  10 21 XRA1    
XMAT3  11 29 XRA1    XPOP    5 32 XRA1    XX     14 11 XRA1    ZERO   14  5 XRA1    

MONITOR ** FICHE/FRAME BREAK *****
XRA2
XRA2   IDENT 11/03/74
       NOLIST STAT,EXT
       ENTRY DATE,GET,XBR,SST,B44,RAD,TRACE,REPEAT,CLKSET
       ENTRY LIST,SELECT,GO,HELP,BSCAN,PUQ


DATE   PEEK MACH; STA MACHNO
       TYPE SYSID1
       LDA KM1; JRS TDATE1
       PEEK VERS; STA T1; PEEK VERS+1; STA T2
       PEEK DISCN; STA T3; PEEK EQPT; STA T4
       TYPE SYSID2,T3,T1,T2,T4
       SKN INFIL; BRU DAT2 (MONITOR FROM FILE)
       TCF K15
       BRS 113; BRS 43; STB T1; XAB; ETR =77777700B
       MRG K13; XAB; BRS 44; MSG 34000B
       BRS 43; LDB T1; BRS 44; BRS 114
       TYPE MC (MONITOR FROM CORE)
DAT1   PEEK TYMTIM; STA T3
       TYPE MU (MONITOR UP)
       JRS TDATE1
       PEEK REAL; STA T4
       MUL TMK; ADD T3
       TYPE MCLK (TIME ON MON CLOCK)
       JRS TDATE1
       LDA T4; RSH 23; DIV =3600 (CONVERT TICS TO MINUTES)
       TYPE MRUN (RUN TIME)
       JRS PTIME; TCF CRCH; R1 DATE
DAT2   TYPE MF (MON FROM FILE); JRS PFILE; BRU DAT1

GET    EQU * LOAD MONITOR FROM CRASH FILE
       SKN CHSW; TYPE FFILE (FROM FILE:)
       SPB CLEAN (SET NO MONITOR PRESENT)
       LDA =FILPT; STA T2
       SPTR FILBUF; STP FILPT; EAX FILPT; JRS GCMND
       LDP FILPT; BRS 64; BRU BADFIL
       STA INFIL
       CBA; SKE =1; BRU WRTYPE (NOT SAVE FILE)
       WIO INFIL; SKE ZERO; BRU WRFMT
       WIO INFIL; SKE =33777B; BRU WRFMT
       WIO INFIL; SKE ZERO; BRU WRFMT
       LDP FILPT; STP WKPT
       SPTR FILBF2; STP FILPT2
       GCI WKPT; BRU RQNAM
       SKE ="  ("; BRU GET4
       WCI FILPT2
GET1   GCI WKPT; BRU RQNAM
       WCI FILPT2; SKE ="  )"; BRU GET1
GET2   EQU *
       RPT 2; SPB GNUM; ENDR
       LDX =-4; GCI WKPT; BRU RQNAM
       SKE MAIN,2; BRU RQNAM
       BRX *-4
       LDA ="  N"; WCI FILPT2
       LDA ="  E"; WCI FILPT2
       LDA ="  T"; WCI FILPT2
       RPT 4; SPB GNUM; ENDR
       GCI WKPT; BRU GET3
RQNAM  TYPE NETNAM
       SPTR FILBF2; STP FILPT2; EAX FILPT2; JRS GCMND
GET3   LDA =FILPT2; STA T2
       LDP FILPT2; BRS 64; BRU BADFIL
       STA INFIL2
       CBA; SKE ONE; BRU WRTYPE
       WIO INFIL2; SKE K34B3; BRU WRFMT
       WIO INFIL2; SKE K3S4; BRU WRFMT
       WIO INFIL2; SKE ZERO; BRU WRFMT
       R1
GET4   SKR WKPT; BRU GET2
       ASC '  M  A  I  N'
MAIN   EQU *
GNUM   GCI WKPT; BRU RQNAM; SKG K31; SKG K17; BRU RQNAM
       WCI FILPT2; BRR 0
BADFIL JRS CLEANUP; TYPE CANOPN; BRU FABORT
WRTYPE LDA =BTYPE; BRU *+2
WRFMT  LDA =BFMT; BRS 113; STA T1
       JRS CLEANUP
       TYPE _T1
FABORT LDP* T2; JRS PPFILE
       BRU CRCD

*      XBRS STATS
XBR    TYPE XBRSTA
       IF TSTAT1
       CLA; STA T1; STA T2; STA T3
       PEEK XBRSTC; LDA PPTR; MRG =2B7; STA T4
       PEEK XBRST; LDA PPTR; MRG =2B7; STA T5
XBR2   LDX T3; LDA XBNO,2; SKE KM1; BRU XBR3
       TYPE XBR6,T2; TCF ZERO
       LDP T1; JRS AVG; TCF CRCH; R1
       ELSE
       R1
       ENDF
       IF TSTAT1
XBR3   LDA* T4; SKE ZERO; BRU *+2; BRU XBR5
       LDA XBNO,2; SKG =777B; BRU XBR4
       LDB THREE; LDX POUT; BRS 34; BRU *+2
XBR4   TYPE FI3,(XBNO,2)
       LDX T3; LDA* T4; ADM T2 (TOTAL COUNT)
       TYPE FI8,_T4; TCF ZERO
       LDX T3; LDA* T5; ADM T1 (TOTAL TIME)
       LDB* T4; JRS AVG; TCF CRCH
XBR5   MIN T3; BRU XBR2
       ENDF

SST    TYPE QJSTA; IF TSTAT; TYPE QJSTA1
       PEEK QIL0; LDA PPTR; JRS PQ
* T6 IS TOTAL NO. OF SWAP JOBS RUN
       TYPE QJ1,T6
       TYPE QJ2; PEEK SWPTIM; LDB T6; JRS AVG
       TYPE CJSTA; TYPE QJSTA1
       PEEK QCL0; LDA PPTR; JRS PQ
       PEEK SWPCJ; STA T1; TYPE QJ3,T1
       TYPE QJ2; PEEK CMPTIM; LDB T1; JRS AVG
       TYPE QJ4; PEEK CTIME; LDB T1; JRS AVG; TCF CRCH
       ENDF
       R1
       IF TSTAT
* PRINT STATISTICS FOR FOUR QUEUE LEVELS AND TOTALS
PQ     STA T1
       LDA THREE; STA T2
       CLA; STA T5 (TOTAL TIME SPENT--ALL LEVELS)
       STA T6 (TOTAL RUN--ALL LEVELS)
NPQ    LDX T1; LDP 0,2; XAB; SKE ZERO; BRU *+2; BRU NXPQ (ZERO COUNT)
       LDA THREE; SUB T2; CAX; LDB QTYP,2; LDX =-3
       LSH 8; CIO POUT; BRX *-2; TCF ZERO
       LDX T1; LDP 0,2; STP T3 (TIME IN T3, COUNT IN T4)
       ADM T5 (TOTAL TIME)
       XAB; ADM T6 (TOTAL COUNT)
       TYPE FI8,T4 (PRINT COUNT)
       TCF ZERO
       LDP T3; JRS AVG
       TCF CRCH
NXPQ   LDA =2; ADM T1; SKR T2; BRU NPQ
       TYPE FPQ,T6
       LDP T5; JRS AVG; TCF CRCH; R1
       ENDF
B44    PEEK NCHRLS; LDP* PPTR; STP T1; BRS 51; STP FLOAT
       IF TSTAT
       PEEK B44HNG; LDP* PPTR; STP T3 (HANG T3, TIME T4)
       LDA T1; SUB T2; SUB T3; STA T5 (SCHED)
       TYPE MB44,T1,T2,T3,T5
       LDA T2; JRS PPCT; LDA T3; JRS PPCT; LDA T5; JRS PPCT
       PEEK QTIGO+24B; LDP* PPTR; STP T1 (SCHED, HANG)
       TYPE RM3,T2,T1
       LDA T4; LDB T3; JRS AVG
       ELSE
       TYPE MB44,T1,T2
       LDA T2; JRS PPCT
       ENDF
       TCF CRCH; R1
RAD    TYPE RADM1
       IF TSTAT
       CLA; STA T4 (TOTAL PGS)
       LDX =-32; STX T2 (NEG. ON 1ST PASS)
       PEEK QTIGO+32,2; STA WKBUFF+32,2; ADM T4; BRX *-3
       LDA T4; BRS 150; STFM FLOAT
RAD6   LDX =-32
RAD2   STX T1; LDA WKBUFF+32,2; SNE ZERO; BRU RAD4
       SKN T2; BRU RAD3
       CXA; SKE =-8 (PUACT); SNE =-10 (RFK); BRU RAD3
       SKE =-11 (B44 HNG); SNE KM1 (PMTA); BRU RAD3; BRU RAD4
RAD3   FMTYPE* QTAB+32,2
       TYPE FI8,(WKBUFF+32,2)
       CLA; XMA WKBUFF+32,2; JRS PPCT
       LDA CRCH; CIO POUT; LDX T1
RAD4   BRX RAD2; SKN T2; BRU RAD5; STX T2
       TYPE RADM2; BRU RAD6
RAD5   TYPE RADM3,T4 (TOTAL BRING)
       ENDF
       PEEK RPAGE; STA T4
       PEEK SSWC; BRS 150; STFM FLOAT
       TYPE RADM4,T4 (TOTAL READ)
       LDA T4; JRS PPCT (PCT. OF SWAP)
       PEEK RPAGEH; STA T1
       PEEK RPAGEL; STA T2
       PEEK PAGEW; STA T3; ADM T4
       PEEK RASCT; CNA; RSH 7; STA T5
       TYPE RADM5,T1,T2,T3,T4,T5
       R1

*      TOGGLE TRACE SWITCH

TRACE  LDA TRASW; EOR KM1; STA TRASW
       SKN TRASW; TYPE TRCOFF; SKP TRASW; TYPE TRCON; R1

*      GET REPEAT COUNT

REPEAT SKN CHSW; BRU PRTRPT; SPB RDDNUM
       SPB CRLF; NOP
       CBA; SUB ONE
       STA RPT1; STA RPT; R1
PRTRPT SKN RPT1; BRU *+3; TYPE MRPT; R1
       LDA RPT1; ADD ONE; STA T1
       TYPE MMRPT,T1; R1

*      SET CLOCK INTERVAL FOR REPEATS

CLKSET SKN CHSW; BRU PRTCLK
       SPB RDDNUM; SPB CRLF; NOP
       CBA; MUL =60; LSH 23; STA CLOCK; R1
PRTCLK LDA CLOCK; RSH 23; DIV =60; STA T1
       TYPE CLKVAL,T1; R1

* LIST OPTIONS

LIST   SKN CHSW; BRU TYPOPT; JRS GOPT (GET OPTION--3 CHARS)
       SKE ="HEL"; BRU LISS; TYPE HOPT1; TYPE HOPT; TYPE HHOPT; R1
LISS   LDX KM1; BRS 113
       CLA; XMA FLAG; STA T1; LDA BFR
OPTD   LDX =-5; SNE SOPTE,2; BRU SOPTS (SPECIAL OPTION SET); BRX *-2
       LDX =-24; SNE OPTE,2; BRU OPTS (REGULAR OPTION SET); BRX *-2
       LDA T1; STA FLAG; SPB CLSCFI; LDP STPTR; LDX POUT; BRS 35
       TYPE NOTREC (NOT RECOGNIZED); BRU ERRET
SOPTS  LDA SOPVE,2; MRG FLAG; STA FLAG; BRU *+2
OPTS   SETF 24,2; SKN CHSW; R1; JRS GOPT; BRU OPTD
TYPOPT LDX =-24
TYPO1  LDB OPTE,2; SKF 24,2; BRU TYPO2
       SPB TWD; TCF ZERO
TYPO2  BRX TYPO1; TCF CRCH; R1

* SELECT WHOM WILL BE ANALYZED

SELECT SKN CHSW; BRU PRTSEL (TELL WHOM)
       SBRM NXCH; SKG ZERO; BRU *-2
       SPB CRLF; BRU SELALL
       CLB; SPB INITS
       SKE ="  ("; BRU SELNM1 (BETTER BE A NUMBER)
       JRS RDMON
SELUNM JRS GUN; BRU SEL3; SPB MLUDL; STA T1 (LUD LOCATOR)
       LDA KM1; STA PORT; STA T5
SEL1   MIN PORT; LDA PORT; SKG =NPORT-1; BRU *+2; BRU SEL2
       CAX; PEEK WERIS,2; SKE T1; BRU SEL1
       LDA KM1; STA SEL,2; MIN T5; BRU SEL1
SEL2   SKN T5; BRU SEL4
SEL3   LDB KM1; SPB INITS
       SPB CLSCFI; LDP STPTR; LDX POUT; BRS 35; TYPE NOTON; BRU ERRET
SEL4   LDA T2; SKE =9; R1
       SBRM NXCH; SPB CRLF; R1
       SNE ZERO; R1
       SKE =14B; BRU ILCHS
       SBRM NXCH; SNE ="  ("; BRU SELUNM
ILCHS  LDB KM1; SPB INITS; BRU ILCH
SELNM1 LDB KM1; STB CHSW; SPB RDD3; BRU *+2
SELNUM SPB RDDNUM; STB T1; SNE =14B; BRU SELCOM; SNE =15B; BRU SELDAS
SELTER SKE CRCH; SNE LFCH; BRU *+3; SKE ZERO; BRU SELERR
       STB T2; SPB SETN12; BRU SELERR; R1
SELDAS SPB RDDNUM; SNE =15B; BRU SELERR; SKE =14B; BRU SELTER
SELCOM STB T2; SPB SETN12; BRU SELERR; BRU SELNUM
SELERR LDB KM1; SPB INITS; SPB CLSCFI
       TYPE BADRANGE; BRU ERRET
SELALL LDB KM1; SPB INITS; R1
PRTSEL LDA KM1; STA T2; STA T3 (COMMA SW); STA PORT
       TYPE WHOM
PRTS1  MIN PORT
PRTS2  LDA PORT; SKG =NPORT-1; BRU PRTS3; TCF CRCH; R1
PRTS3  CAX; SKN SEL,2; BRU PRTS1; STA T1
PRTS4  MIN PORT; LDA PORT; SKG =NPORT-1; BRU PRTS6
PRTS5  SKN T3; TCF =14B; MIN T3; LDA T1; SPB PDNO
       SKN T2; BRU *+2; BRU PRTS2; TCF =15B; LDA T2; SPB PDNO
       LDA KM1; STA T2; BRU PRTS2
PRTS6  CAX; SKN SEL,2; BRU PRTS5; STA T2; BRU PRTS4

*      PRINT USERS ON SYSTEM

GO     LDA KM1; STA PORT
       SKN HDSW (NEG. IF ONE USER SELECTED); BRU *+2; BRU GO1
       STA HDSW1; STA HDSW2; STA HDSW3; STA HDSW4
GO1    JRS CWIDTH
       PEEK ADRSMT; STA XADRSMT
       PEEK ADRPMT; STA XADRPMT
       PEEK AEXSMT; STA XAEXSMT
       PEEK MONTAB; STA XPNEXT
       PEEK MONTAB+1; STA XPPTR

       LDA FLAG; SKA =77774B3; BRU *+2; BRU END
*PORT NO., WIDTH =3
HEADER MIN PORT; LDA PORT; SKG =NPORT-1; BRU *+2; BRU END
       CAX; SKN SEL,2; BRU HEADER (NOT SELECTED)
       PEEK TF2,2; ETR =77B; STA JOB; SKG ZERO; BRU HEADER
       PEEK TTYASG,2; STA XTTY; SKA =4B7; BRU *+2; BRU HEADER
       JRS PRHD (PRINT HEADER IF NOT ALREADY OUT) (TYPE CRCH ALWAYS)
       TYPE I2S,PORT

*STATUS, WIDTH =6
       SKF CPAFLG; BRU GRP
       LDX JOB; PEEK CPARW,2; LDB ONE; SKA =2; SPB PRCHR; TCF ZERO
       LDA* PPTR; LRSH 12; SKG ZERO; BRU NONE; STA T1
       TYPE B4F,T1; BRU *+2
NONE   TYPE MNONE; TCF ZERO

*FILE GROUP, WIDTH =6
GRP    SKF GRPFLG; BRU COMP; LDX JOB
       PEEK FGLIST,2; SKE ZERO; BRU PNTGRP; TCF ZERO; TYPE MNONE
       TCF ZERO; BRU COMP
PNTGRP LDB =3; SKA =4B7; SPB PRCHR; TCF ZERO; ETR =7777B; STA T1
       TYPE B4S,T1

*COMPUTE TIME, WIDTH =8
COMP   SKF COMFLG; BRU SWP
       LDX JOB; PEEK ETTB,2; RSH 23; DIV =60; STA T1 (SECONDS)
       RSH 23; DIV =3600 (HOURS)
       SKE ZERO; BRU *+3; SPB TAB2; BRU SKIPHR; SPB PDNO
       TCF =':'
SKIPHR LDA T1; JRS PTIME; TCF ZERO

*SWAPCOUNT, WIDTH =5
SWP    SKF SWPFLG; BRU CHAR; LDX JOB
       PEEK SWPCNT,2; ADD =500; RSH 23; DIV =1000; STA T1
       TYPE FI4S,T1

*CHARCOUNT, WIDTH =5
CHAR   SKF CHRFLG; BRU PACT
       LDX JOB; PEEK CCT,2; ADD =500; RSH 23; DIV =1000; STA T1
       TYPE FI4S,T1

* EXAMINE FORK IMMEDIATELY BELOW EXEC.  IGNORE LOWER FORKS.
PACT   LDA XTTY; ADD XPPTR; CAX; PEEK 0,2
       SKE ZERO; BRU *+2; BRU EXC; SKA =7777B; BRU CHAIN
       LRSH 12; MRG =77770000B; ADD XPPTR; CAX
       PEEK -2,2; STA RL; PEEK -1,2; STA RL+1
       PEEK 1,2; STA ACT; BRU PTEST
CHAIN  MRG =77770000B; BRU PACT+1
EXC    PEEK 1,2; STA ACT; LDA KM1; STA EXECSW

*ACTIVATION CONDITION, WIDTH =11
PTEST  SKF ACTFLG; BRU SUBSYS; LDA ACT; LRSH 15
       SKE =7; BRU ACTIV; LDA ACT; ETR =7; SKE =6; BRU ACTIV
       TCF ='@'; BRU *+2
ACTIV  TCF ZERO; LDA XTTY; BRU *+2
PT1    RSH 12; ADD XPPTR; CAX; PEEK 0,2; SKA =7777B4; BRU PT1
       PEEK 1,2; STA ACT; LRSH 15; SKE =7; BRU PT3
       LDA ACT; ETR =7; CAX; TYPE (_SPTEST,2)
       SPB TAB2; SPB TAB3
PT2    TCF ZERO; BRU SUBSYS
PT3    CAX; TYPE (_QTAB,2); BRU PT2

*SUBSYSTEM, WIDTH =7
SUBSYS SKF SUBFLG; BRU FINIS1; LDP RL; SKN EXECSW; BRU UNPACK; CLA; STA EXECSW
       TYPE MEXEC; BRU FINISH

UNPACK LDX =TABLE; LRSH 18; STA 0,2; CLA; LCY 6; STA 1,2; CLA
       LCY 6; STA 2,2; CLA; LCY 6; STA 3,2; LDA RL+1; LRSH 18
       STA 4,2; CLA; LCY 6; STA 5,2; CLA; LCY 6; STA 6,2; CLA
       LCY 6; STA 7,2; LDX JOB; PEEK PMTP,2; ADD =1
       STA PMTPTR; LDX =-8

PACRL  STX BUFPT; LDA TABLE+8,2; SKG =24B; SKG KM1; BRU *+2; BRU NXTBYT
       SKG =30B; BRU *+2; BRU *+3; SKE =25B; BRU EDITOR; SKG =34B; BRU BFOR
       SKG =40B; BRU XDDT; SKG =42B; BRU DDT; SUB =44B
       ADD PMTPTR; AXC; PEEK 0,2; LDB =77B5; SKM =12B5; BRU NXTBYT
       CAX; PEEK 0,2; SKM =12B5; BRU *+2; BRU *-4; CXA
       ETR =37777B; SKG XAEXSMT; SNE XAEXSMT; BRU *+2; BRU INDPMT
       SUB XAEXSMT; AXC; FMTYPE* SUBTBL,2; BRU FINISH
INDSMT SUB XADRSMT; STA PAGE; TYPE MSMT; LDA PAGE; SKG =7; TCF ="  0"
       SPB PONO; BRU FINISH
INDPMT SKG XADRPMT; SNE XADRPMT; BRU *+2; BRU INDSMT
       SUB XADRPMT; JRS PIND; BRU FINISH

NXTBYT LDX BUFPT; BRX PACRL; TYPE MPRIV; BRU FINISH
EDITOR TYPE MED; BRU FINISH
DDT    TYPE MDDT; BRU FINISH
XDDT   TYPE MXDDT; BRU FINISH
BFOR   TYPE MBFORC
FINISH TCF ZERO

*MEMORY USE, WIDTH =6
FINIS1 SKF MEMFLG; BRU QTYPE
       CLA; STA SHPAGE; STA PRPAGE; LDA =34B; STA PAGCNT
       LDA JOB; SUB =1; MUL =35B; LSH 23; ADD XADRPMT
       STA PMTADR
UMLOOP LDX PMTADR; PEEK 0,2; SKE ZERO; BRU *+2; BRU PUBLIC+1
       LRSH 15; ETR =17B; SKE =12B; BRU PUBLIC; MIN SHPAGE
PUBLIC MIN PRPAGE; MIN PMTADR; SKR PAGCNT; BRU UMLOOP
       LDA PRPAGE; LDB SHPAGE; LSH 1; STP T1; TYPE PGFT,T1,T2

*QUEUE TYPE, WIDTH =6
QTYPE  SKF QTYFLG; BRU TYPUN; TCF ZERO; LDA XTTY; BRU *+2
* SCAN TOIV TTOM
QTYP1  RSH 12; ADD XPPTR; CAX; PEEK 0,2; SKA =7777B4; BRU QTYP1
       PEEK 1,2; STA ACT; LRSH 15; SKE =7; BRU QTYP3
       LDA ACT; ETR =7; CAX; TYPE (_SPTEST,2)
QTYP5  TCF ZERO; BRU TYPUN
QTYP3  PEEK -4,2 (PNEXT)
QTYP2  SKG KM1; BRU QTYP4; SUB =QTI; RSH 23
       IF TSTAT
       DIV =QD
       ELSE
       DIV =QD-2
       ENDF
       CAX; TYPE (_QUEUE,2); BRU QTYP5
QTYP4  ADD XPNEXT; CAX; PEEK 0,2; BRU QTYP2

*USER NAME, WIDTH =13
TYPUN  SKF UNMFLG; BRU PAC0; LDA WIDTH; SKG MWI; BRU *+2; TYPE FOLD
       TCF ZERO
       LDX PORT; PEEK WERIS,2; SKG ZERO
       BRU UNKNWN; LDB KM1; JRS PRINT; BRU PAC0
UNKNWN SKG =-2; BRU MINUS; LDX JOB; PEEK AUNN,2
       SKG ZERO; BRU ZER; JRS PNTUNO; BRU PAC0
ZER   TYPE MGONE; BRU PAC0
MINUS  CNA; TCF ='-'; SPB PDNO
* PRINT PACT CHAIN
PAC0   SKF PACFLG; BRU PRPMT
       PEEK REAL; STA T9; LDA XTTY
PAC1   MRG =7777B4; STA T7; ADD XPPTR; CAX; PEEK 0,2
       SKA =7777B; BRU PAC1 (SCAN TO TOP); BRU PAC3
PAC2   RSH 12; STA T7; ADD XPPTR; CAX; PEEK 0,2
PAC3   JRS PPAC (PRESERVES A); SKA =7777B4; BRU PAC2
       TCF CRCH
PRPMT  SKF PMTFLG; BRU PRTTY
       LDA =34B; STA PAGCNT; LDX JOB; PEEK PMTP,2; SKG =0; BRU PRTTY
       ETR =37777B; STA PMTADR; LDA =43B; STA T1
       TCF CRCH
NXPMT  LDX PMTADR; PEEK 0,2; SKE ZERO; JRS PRMTE; MIN T1; MIN PMTADR
       SKR PAGCNT; BRU NXPMT; TCF CRCH

* PRINT TTY PORTS ASSIGNED TO THIS JOB
PRTTY  SKF TTYFLG; BRU HEADER
       LDA KM1; STA XPORT
NXTTY  MIN XPORT; LDA XPORT; SKG =NPORT-1; BRU *+3; TCF CRCH; BRU HEADER
       CAX; PEEK TF2,2; STA T2; ETR K77; SKE JOB; BRU NXTTY
       PEEK TT,2; STA T6
       PEEK TF1,2; STA T1
       PEEK TC,2; STA T5
       PEEK TF3,2; STA T3
       PEEK TF4,2; STA T4
       LDA T2; ETR =BRKY; SKN T3; CLA
       LDX =20-BRKZ; NOD 23-BRKZ; CXA; CNA; STA T7
       LDA T2; ETR =RCY; LRSH RCZ; STA T8
       TYPE TTYHED,XPORT,T7,T8,T5
       LDA T6; SPB PONO
       TYPE T1F; LDA T1; LDX =-24; SKA ONE; TYPE (_MTF1,2); RCY 1; BRX *-3
       LDA T2; LDX =-12; SKA =1B4; TYPE (_MTF2,2); RCY 1; BRX *-3
       LDA T3; LDX  =-5; SKA =2B6; TYPE (_MTF3,2); RCY 1; BRX *-3
       LDA T3; SKA =10000B; TYPE MTFPAR; SKA =400B; TYPE MTF310
       LDA T3; LRSH 16; ETR =7; CAX; LDA BAUDTBL,2; STA T1
       LDA T3; LRSH 13; ETR =7; CAX; LDA BAUDTBL,2; STA T2
       LDA T3; LRSH 9; ETR =7; STA T6 (A)
       LDA T3; LRSH 5; ETR =7; STA T5 (B)
       LDA T3; ETR =17B; STA T3 (C)
       TYPE IBAUD,T1,T2,T6,T5,T3
       LDA T4; ETR =135CY; LRSH 135CZ; STA T1 (MB COUNT)
       LDA T4; ETR =5AY; LRSH 5AZ; STA T2 (5A)
       LDA T4; ETR =MODY; LRSH MODZ; STA T3 (MODE)
       LDA T4; ETR =TERMCY; STA T4 (TERM CHAR)
       TYPE MTF4C; LDA T1; SPB PONO
       TYPE MTF4A; LDA T2; SPB PONO
       TYPE MTF4M; LDA T3; SPB PONO
       TYPE MTF4T; LDA T4; SPB PONO
       BRU NXTTY
END    SKF DEVFLG; BRU FILES; TCF CRCH; PEEK DEVICE; SKG KM1; BRU NODEV
       STA DEVNUM
       PEEK DEVCH; STA PORT; CAX; SKG ZERO; BRU *+3; SKN SEL,2; BRU FILES
       LDX DEVNUM
       FMTYPE* DEVTBL,2; LDA PORT; SKG ZERO; BRU DEVREL
       TYPE MASG; LDX PORT; PEEK WERIS,2; LDB KM1; JRS PRINT
       TYPE DEVMA,PORT
       BRS 104; SKG =1; SKN INFIL (MON FROM CORE); BRU ENDDEV; BRS 110
       BRU NOTRDY; BRS 108; CAX; TYPE MDEN,(DENTBL,2)
       BRS 110
NOTRDY TYPE MNRDY; BRU ENDDEV
NODEV  TYPE MNODEV; BRU FILES
DEVREL TYPE MDVREL
ENDDEV TCF =155B

FILES  SKF FILFLG; BRU FINFIL
       LDA =NFILE-1; STA GFIL
SEARCH LDX GFIL; PEEK XBP,2; SKE KM1; BRU FILHDR
NXTFIL SKR GFIL; BRU SEARCH; BRU FINFIL
FILHDR STA INDEX; PEEK GFLG,2
       STA PRIV; RSH 8; ETR K77; STA JOB
       CAX; PEEK AUNN,2; STA UNO; PEEK TTNO,2; ETR K77; STA PORT
       CAX; SKN SEL,2; BRU NXTFIL
       JRS PRFHD; TYPE I2S,PORT
       LDA PRIV; CLB; RSH 15; ETR =3; ADD =3; STA T1; TYPE I2S,T1
       LDA ONE; STA GFDSW
       LDX =-8; LDA PRIV
POPT0  STA T1; SKA =200B; BRU POPT
       SPB TAB3
POPT1  LDA T1; LCY 1; BRX POPT0
       SPB TAB2; LDX PORT; PEEK WERIS,2; SKG ZERO; BRU PFUN1; CLB; JRS PRINT
PFUN3  SPB TAB2; LDA UN
READ   RSH 23; DIV =64; SKG =3; BRU RFD; SKG =35; BRU *+3
       SUB =16; BRU RFD; SUB =4; XAB; SUB =100B; XAB
RFD    STB DSCN; CLB; LSH 12; ADD DSCN; LSH 1; ADD =200B; CAB
RFDA   LDA =BFR; LDX =128; BRS 124

FNDXBP LDA INDEX; ETR =1777777B; RSH 2; LDX =-128
LOOKUP SKE BFR+128,2; BRU FIXUP; CXA; ADD =BFR+129
       MUL =3; LSH 23; SUB =1; STA STPTR; LSH 6; STA STPTR+1
       SKN GFDSW; BRU PNTFIL+1; TCF ='('; LDA BFR+124
       SKG =3777B; SKG ZERO; LDA UN; JRS PNTFD; TCF =')'
       BRU PNTFIL+1
FIXUP  BRX LOOKUP; LDA BFR+125; SKG ZERO; BRU PRVATE; STA UN
       BRU READ
PRVATE SKR GFDSW; BRU *+3; TYPE MNF; BRU NXTFIL; LDX JOB
       PEEK FGLIST,2; ETR =3777B; SKG ZERO; BRU PRVATE; STA UN
       LDA KM1; STA GFDSW; LDA UN; BRU READ
PFUN1  LDX JOB; PEEK AUNN,2; SKG ZERO; BRU PFUN2; JRS PNTUNO; BRU PFUN3
PFUN2  TYPE MGONE; BRU PRVATE


POPT   LDB POPTE,2; SPB TWD; BRU POPT1
PNTFIL JRS TYPCHR; GCI STPTR; HLT; SKG =177B; BRU PNTFIL
       EOR =200B; JRS TYPCHR; GCI STPTR; HLT; SKE =136B 
       BRU *+2; BRU NXTFIL; JRS TYPCHR; GCI STPTR; HLT
       SKE =136B; JRS TYPCHR; BRU NXTFIL

FINFIL SKF QUEFLG; BRU EOJ
       PEEK QTIC; STA T1; PEEK QIOC; STA T2
       PEEK QQEC; STA T3; PEEK QQCC; STA T4
       PEEK QSQC; STA T5
       TYPE MQTI,T1,T2,T3,T4,T5
EOJ    R1

* PRINT BRIEF EXPLANATION OF COMMANDS
HELP   TYPE HELPM; TYPE HOPT2; TYPE HOPT; TYPE HHOPT; R1

* PRINT BLOCK I/O SCANNER QUEUE (TTQ)

       IF -TTQSW
BSCAN EQU *
       ELSE
BSCAN  LDA KM1; SKN HDSW; STA HDSW1
       LDX K100; BRU NX1
NX  LDX PORT
NX1 PEEK TF6,2; SKA K100; BRU TTQE; STA T6; ETR K77; CAX; STX PORT
       SKN SEL,2; BRU NX1
       PEEK TF5,2; STA T5; ETR =CSTAY; LRSH CSTAZ; STA T1
       PEEK TF6,2; STA T6; ETR =CPGY; LRSH CPGZ; ADD =43B; STA T2
       LDA T6; ETR =CADRY; LRSH CADRZ; STA T3
       JRS PRQHD
       TYPE TTQP,PORT,T1,T2,T3
       LDA T1; SKG ONE; BRU NX
       LDA T5; ETR =CHBNY; LRSH CHBNZ; STA T2
       LDA T5; ETR =777B; STA T3
       TYPE TTQP1,T2,T3
       SKN T6; BRU *+3; TYPE TTQPO; BRU *+2; TYPE TTQPI
       LDA T5; LDX =-8; SKA =4B7; TYPE (_TFF5,2); LCY 1; BRX *-3
       BRU NX
TTQE   PEEK SMTP20; LDB =77B5; SKM =4B5; BRU *+2; BRU TTQE1
       SKM =2B5; BRU NOLOCK
TTQE1  ETR =37B; CAX; PEEK RMC,2; STA T1
       TYPE P20LOK,T1
       BRU *+2
NOLOCK TYPE P20NLK
       PEEK REAL; STA T1; PEEK BFL; LDX =-14
       SKA =2B7; BRU *+2; JRS PBL; LCY 1; BRX *-4
       PEEK NBFL; STA T2; PEEK BFLT; STA T1
       TYPE BASS,T2; LDP T1; JRS AVG
       IF TSTAT
       PEEK NTTQTS; STA T2; PEEK TTQTIM; STA T1
       TYPE TTQTM,T2; LDP T1; JRS AVG
       PEEK NCCT; STA T1; PEEK NTOR; STA T2; PEEK NTIR; STA T3
       TYPE MISTQ,T1,T2,T3
       ENDF
       ENDF
       R1

* PRINT PHANTOM USER QUEUE

PUQ    PEEK REAL; STA T7
       LDA =PUBPTR; STA T1
PUN    LDX T1; PEEK 0,2; SNE =PUBPTR; R1
       CAX; STA T1
       PEEK 1,2; LRSH 15; SKG =7; SKG ZERO; BRU PUN
       STA T3 (PUCLST INDEX)
       PEEK 2,2; STA T4; LRSH 15; STA T5
       PEEK 3,2; ETR =77B; STA PORT
       LDA* PPTR; RSH 12; MRG =7777B4; CNA; STA T6
       LDX PORT; SKN SEL,2; BRU PUN
       TYPE PUQM1,PORT
       LDX T3; JRS* PUNLST-1,2; BRU PUN
PUNLST DATA RUBOUT,P124,PILL,PILL,PILL,PDEAD,PTIMER
RUBOUT LDA T5; SKG =4; BRU RUB1; TYPE RBT0,T5; R1
RUB1   CAX; TYPE (_RBT,2); R1
P124   TYPE P124M; LDA T6; SPB PONO; R1
PILL   TYPE BADPU,T3; R1
PDEAD  TYPE DEDPU; R1
PTIMER TYPE TIMPU; LDA T6; SPB PONO
       LDA T4; SUB T7; SKG KM1; BRU PTIM1
       STA T4; TYPE TRM,T4; R1
PTIM1  CNA; STA T4; TYPE NTRM,T4; R1

       END
MONITOR ** FICHE/FRAME BREAK *****
XRA2 SYMSORT

SYM.  PG.LN. IDENT.

ACTIV   9 18 XRA2    B44     4 21 XRA2    BADFIL  2 35 XRA2    
BFOR   10 13 XRA2    BSCAN  14 18 XRA2    BSCAN  14 16 XRA2    CHAIN   9 11 XRA2    
CHAR    9  1 XRA2    CLKSET  6  4 XRA2    COMP    8 27 XRA2    DAT1    1 19 XRA2    
DAT2    1 29 XRA2    DATE    1  7 XRA2    DDT    10 11 XRA2    DEVREL 12 35 XRA2    
EDITOR 10 10 XRA2    END    12 23 XRA2    ENDDEV 12 36 XRA2    EOJ    14  8 XRA2    
EXC     9 12 XRA2    FABORT  3  1 XRA2    FILES  12 38 XRA2    FILHDR 13  3 XRA2    
FINFIL 14  3 XRA2    FINIS1 10 17 XRA2    FINISH 10 14 XRA2    FIXUP  13 27 XRA2    
FNDXBP 13 21 XRA2    GET     1 31 XRA2    GET1    2  8 XRA2    GET2    2 10 XRA2    
GET3    2 22 XRA2    GET4    2 30 XRA2    GNUM    2 33 XRA2    GO      7 32 XRA2    
GO1     7 35 XRA2    GRP     8 20 XRA2    HEADER  8  5 XRA2    HELP   14 11 XRA2    
ILCHS   7  9 XRA2    INDPMT 10  6 XRA2    INDSMT 10  4 XRA2    LISS    6 14 XRA2    
LIST    6 12 XRA2    LOOKUP 13 22 XRA2    MAIN    2 32 XRA2    MINUS  11 12 XRA2    
NODEV  12 34 XRA2    NOLOCK 15  1 XRA2    NONE    8 17 XRA2    NOTRDY 12 33 XRA2    
NPQ     4  7 XRA2    NX     14 20 XRA2    NX1    14 21 XRA2    NXPMT  11 25 XRA2    
NXPQ    4 17 XRA2    NXTBYT 10  9 XRA2    NXTFIL 13  2 XRA2    NXTTY  11 31 XRA2    
OPTD    6 16 XRA2    OPTS    6 21 XRA2    P124   15 32 XRA2    PAC0   11 14 XRA2    
PAC1   11 16 XRA2    PAC2   11 18 XRA2    PAC3   11 19 XRA2    PACRL   9 36 XRA2    
PACT    9  6 XRA2    PDEAD  15 34 XRA2    PFUN1  13 32 XRA2    PFUN2  13 33 XRA2    
PFUN3  13 15 XRA2    PILL   15 33 XRA2    PNTFIL 13 37 XRA2    PNTGRP  8 23 XRA2    
POPT   13 36 XRA2    POPT0  13 11 XRA2    POPT1  13 13 XRA2    PQ      4  3 XRA2    
PRPMT  11 21 XRA2    PRTCLK  6  7 XRA2    PRTRPT  5 37 XRA2    PRTS1   7 21 XRA2    
PRTS2   7 22 XRA2    PRTS3   7 23 XRA2    PRTS4   7 24 XRA2    PRTS5   7 25 XRA2    
PRTS6   7 28 XRA2    PRTSEL  7 19 XRA2    PRTTY  11 29 XRA2    PRVATE 13 29 XRA2    
PT1     9 19 XRA2    PT2     9 23 XRA2    PT3     9 24 XRA2    PTEST   9 15 XRA2    
PTIM1  15 38 XRA2    PTIMER 15 35 XRA2    PUBLIC 10 23 XRA2    PUN    15 19 XRA2    
PUNLST 15 29 XRA2    PUQ    15 17 XRA2    QTYP1  10 29 XRA2    QTYP2  10 34 XRA2    
QTYP3  10 33 XRA2    QTYP4  11  2 XRA2    QTYP5  10 32 XRA2    QTYPE  10 27 XRA2    
RAD     4 35 XRA2    RAD2    5  3 XRA2    RAD3    5  7 XRA2    RAD4    5 11 XRA2    
RAD5    5 13 XRA2    RAD6    5  2 XRA2    READ   13 16 XRA2    REPEAT  5 33 XRA2    
RFD    13 18 XRA2    RFDA   13 19 XRA2    RQNAM   2 20 XRA2    RUB1   15 31 XRA2    
RUBOUT 15 30 XRA2    SEARCH 13  1 XRA2    SEL1    6 37 XRA2    SEL2    7  1 XRA2    
SEL3    7  2 XRA2    SEL4    7  4 XRA2    SELALL  7 18 XRA2    SELCOM  7 15 XRA2    
SELDAS  7 14 XRA2    SELECT  6 29 XRA2    SELERR  7 16 XRA2    SELNM1  7 10 XRA2    
SELNUM  7 11 XRA2    SELTER  7 12 XRA2    SELUNM  6 35 XRA2    SKIPHR  8 32 XRA2    
SOPTS   6 20 XRA2    SST     3 28 XRA2    SUBSYS  9 27 XRA2    SWP     8 35 XRA2    
TRACE   5 28 XRA2    TTQE   14 35 XRA2    TTQE1  14 37 XRA2    TYPO1   6 23 XRA2    
TYPO2   6 25 XRA2    TYPOPT  6 22 XRA2    TYPUN  11  5 XRA2    UMLOOP 10 21 XRA2    
UNKNWN 11  9 XRA2    UNPACK  9 30 XRA2    WRFMT   2 37 XRA2    WRTYPE  2 36 XRA2    
XBR     3  5 XRA2    XBR2    3 10 XRA2    XBR3    3 17 XRA2    XBR4    3 20 XRA2    
XBR5    3 25 XRA2    XDDT   10 12 XRA2    ZER    11 11 XRA2    
MONITOR ** FICHE/FRAME BREAK *****
XRA3
XRA3   IDENT 11/03/74
       NOLIST STAT,EXT

*      C O N S T A N T S

       ENTRY K77,NETFIL,THREE,SYSID1,SYSID2,K15,NETNAM,K31
       ENTRY K16,K100,K1B7,MBCH,K3S4
       ENTRY TMK,K12B5,K72D,K17,K1S5,K1440D
       ENTRY K74,K13,K20,COLNCH,SIX,TEN
       ENTRY F100,SEVEN

       ENTRY TTYHED,T1F
       ENTRY MTF1,MTF2,MTF3,MTF310
       ENTRY IBAUD,MTFPAR
       ENTRY BAUDTBL
       ENTRY MTF4T,MTF4M,MTF4A,MTF4C
       ENTRY PUQM1,RBT0,RBT,P124M,BADPU,DEDPU,TIMPU,TRM,NTRM
       ENTRY TTQHED,TTQP,TTQP1,TTQPI,TTQPO,TFF5,BASS
       IF TSTAT
       ENTRY TTQTM,MISTQ
       ENDF
       ENTRY P20LOK,P20NLK,PBLM
       ENTRY MWI
       ENTRY MV,EV,MC,MF,MU,MCLK,MRUN
       ENTRY MRPT,MMRPT,TRCON,TRCOFF,CLKVAL
       ENTRY MTTYA,BLOCKM,MRDY,UNKTES,UM,MM,MPACP,MREL
       ENTRY MPIM
       ENTRY MJS,MEX,MSY,MSU,MXBY,MFIX,MLO,MMEM,MFK
       ENTRY M62
       ENTRY MM64,MM34,MM35,M38,M39,MM63,MM39,M7S,M3S,M6S,B5S
       ENTRY FLOC,B2S,STTAB
       ENTRY MPORT,MNUM,COLHDA,COLHDB,COL9A,COL9B
       ENTRY PMTHED,FILHED
       ENTRY MSTAT,PVERS,SNAP,ALIGN,NLD,OFLOW
       ENTRY FFILE,BTYPE,BFMT,CANOPN
       ENTRY BADRAN,WHOM,NOTON,ILCHM,DEVMA,MASG,MDEN,MDVREL
       ENTRY MGONE,MNF,MNODEV,MNONE,MNRDY,MPRIV,MQTI
       ENTRY MSMT,MEXEC,MED,MBFORC,MXDDT,MDDT
       ENTRY FI4S,B4S,I2S,B4F,PGFT,INDF,FOLD
       ENTRY HELPM,HHOPT,HOPT,NOTREC,HOPT1,HOPT2
       ENTRY FI3,FI8,F104,XBRSTA,QJSTA,MB44,RADM1,RADM4,RADM5
       ENTRY QTAB,SUBTBL,POPTE,DENTBL,DEVTBL,QUEUE,SPTEST
       ENTRY SOPTE,SOPVE,OPTWE,OPTE
       IF TSTAT
       ENTRY RADM2,RADM3
       ENTRY RM3,QTYP
       ENTRY FPQ,QJSTA1,CJSTA,QJ1,QJ2,QJ3,QJ4
       ENDF
       IF TSTAT1
       ENTRY XBNO,ISC,SIC,XBR6
       ENDF

TMK    DATA 4167
K12B5  DATA 12B5
K72D   DATA 72
K17    DATA 17B
K31    DATA 31B
K1S5   DATA 177777B
K1440D DATA 1440
K74    DATA 60
THREE DATA 3
K13 DATA 13B
K15    DATA 15B
K16    DATA 16B
K77    DATA 77B
K3S4   DATA 37777B
K100   DATA 100B
K1B7   DATA 1B7
MBCH   DATA 135B
K20    DATA 20B
COLNCH DATA 32B
SIX DATA 6
TEN DATA 10
F100 DATA 31B6,7
SEVEN EQU F100+1
FI3 FORMAT (I3)
FI8 FORMAT (I8)
F104 FORMAT (F10.4)
TRCON FORMAT ($TRACE ON$)
TRCOFF FORMAT ($TRACE OFF$)
CLKVAL FORMAT ($CLOCK INTERVAL = $,L,$ SECONDS$,/)
MRPT FORMAT ($NO REPEAT$)
MMRPT FORMAT ($COUNT REMAINING = $,I3)
MB44 FORMAT (/,$BRS 44 STATISTICS$,/,$     NO.      NULL      HANG    SCHED.$,/,I8,3(2X,I8),/,$PCT$,5X)
RADM4  FORMAT (/,$TOTAL READS $,I8,4X,$PCT. OF SWAPCOUNT $)
RADM5  FORMAT (/,$HI PRIORITY $,I8,4X,$LO PRIORITY$,I8,/,$TOTAL WRITES$,I8,/,$RAD COMMANDS$,I8,4X,$PAGES IN USE$,I7,/)
       RPT (X=0,7); DATA MTF1($X); ENDR
       RPT (X=10,17); DATA MTF1($X); ENDR
       RPT (X=20,27); DATA MTF1($X); ENDR
MTF1   EQU *
MTF1   EQU *
MTF127 FORMAT ($8I $)
MTF126 FORMAT ($XONOFF $)
MTF125 FORMAT ($LCI $)
MTF124 FORMAT ($RI $)
MTF123 FORMAT ($8O $)
MTF122 FORMAT ($DEF $)
MTF121 FORMAT ($SP1 $)
MTF120 FORMAT ($LG $)
MTF117 FORMAT ($LCO $)
MTF116 FORMAT ($XOFF $)
MTF115 FORMAT ($MARS $)
MTF114 FORMAT ($MAR $)
MTF113 FORMAT ($GOB $)
MTF112 FORMAT ($102 $)
MTF111 FORMAT ($152 $)
MTF110 FORMAT ($531 $)
MTF17  FORMAT ($135 $)
MTF16  FORMAT ($IIH $)
MTF15  FORMAT ($7I $)
MTF14  FORMAT ($GREEN $)
MTF13  FORMAT ($DE $)
MTF12  FORMAT ($DI $)
MTF11  FORMAT ($AUX $)
MTF10  FORMAT ($CON $)
       RPT (X=14,17); DATA MTF2($X); ENDR
       RPT (X=20,27); DATA MTF2($X); ENDR
MTF2 EQU *
MTF227 FORMAT ($OIH $)
MTF226 FORMAT ($ORA $)
MTF225 FORMAT ($5O $)
MTF224 FORMAT ($YEL $)
MTF223 FORMAT ($SP2 $)
MTF222 FORMAT ($CED $)
MTF221 FORMAT ($PUD $)
MTF220 FORMAT ($B168 $)
MTF217 FORMAT ($B161 $)
MTF216 FORMAT ($HARD $)
MTF215 FORMAT ($SOFT $)
MTF214 FORMAT ($B113 $)
       RPT (X=23,27); DATA MTF3($X); ENDR
MTF3 EQU *
MTF327 FORMAT ($ECHO $)
MTF326 FORMAT ($TAB $)
MTF325 FORMAT ($ELF $)
MTF324 FORMAT ($ECR $)
MTF323 FORMAT ($DLYCR $)
MTF310 FORMAT ($HDX $)
IBAUD FORMAT ($IB= $,L,$ OB= $,L,$ A= $,L,$ B= $,L,$ C= $,L)
BAUDTBL DATA 110,150,300,400,600,1200,1200,1200
MTFPAR FORMAT ($PAR $)
MTF4T FORMAT ($ TERMC= $)
MTF4M FORMAT ($ MODE= $)
MTF4A FORMAT ($ 5A= $)
MTF4C FORMAT (/,8X,$135C= $)
TTYHED FORMAT (/,$PORT: $,I2,$ BRK= $,I1,$ RC= $,I1,$ COUNT= $,I3,$ TT= $)
T1F    FORMAT (/,$FLAGS:  $)
PUQM1  FORMAT (/,$  PORT: $,I2,1X)
RBT0   FORMAT ($ILL. TIP INDEX: $,L)
RBT    DATA RBT1,RBT1,RBT2,RBT3,RBT4
RBT1   FORMAT ($TSON$)
RBT2   FORMAT ($TFIP$)
RBT3   FORMAT ($TPUS$)
RBT4   FORMAT ($TPUH$)
P124M  FORMAT ($ID124 PACT: -$)
BADPU  FORMAT ($ILL. PUCLST INDEX: $,L)
DEDPU  FORMAT ($DEAD$)
TIMPU  FORMAT ($TIMEOUT PACT: -$)
TRM    FORMAT (2X,L,$ TICS REMAINING$)
NTRM   FORMAT ($  -$,L,$ TICS REMAINING$)
TTQHED FORMAT ($TTY STATE PMT ADDR BUFF COUNT STATUS$,/)
TTQP   FORMAT (I3,5X,I1,2X,B2,1X,B4)
TTQP1  FORMAT (3X,B2,3X,B3)
TTQPI  FORMAT ($ IN $)
TTQPO  FORMAT ($ OUT $)
       DATA TF5A,TF5B,TF5C,TF5D,TF5E,TF5F,TF5G,TF5H
TFF5   EQU *
TF5A   FORMAT ($IOB $)
TF5B   FORMAT ($TBB $)
TF5C   FORMAT ($CZ $)
TF5D   FORMAT ($CEOT $)
TF5E   FORMAT ($CTIM $)
TF5F   FORMAT ($CTER $)
TF5G   FORMAT ($CABO $)
TF5H   FORMAT ($CSPA $)
BASS   FORMAT (//,$BUFFERLETS ASSIGNED= $,L,$ AVG. LIFETIME= $)
       IF TSTAT
TTQTM  FORMAT (/,$TASKS PERFORMED= $,L,$ AVG. TIME= $)
MISTQ  FORMAT (/,$TOTAL CHARS MOVED=$,I8,/,I8,$ OUTPUT RECORDS$,/,I8,$ INPUT RECORDS$)
       ENDF
P20LOK FORMAT (//$BUFFERLET PAGELOCK= $,B6,/)
P20NLK FORMAT (//$BUFFERLET PAGE NOT LOCKED$/)
PBLM   FORMAT (/,$BUFF $,B2,$ LIFE= $,L)
MWI    DATA 58
MV FORMAT (/$MONITOR VERSION $,2A3)
EV FORMAT (/$EXEC VERSION $)
MC FORMAT (/$MONITOR FROM CORE$)
MF FORMAT (/$MONITOR FROM FILE: $)
MU FORMAT (/$TIME MONITOR CAME UP : $)
MCLK FORMAT (/$TIME ON MONITOR CLOCK: $)
MRUN FORMAT (/$RUN TIME:  $)
SYSID1 FORMAT ($SYSTEM $,C,1X)
SYSID2 FORMAT (/$DISC$,B3,$, SYS. $,2A3,$-$,B8)
M62    FORMAT ($SH $)
MM64   FORMAT ($US $)
MM34   FORMAT ($EXSMT $)
MM35   FORMAT ($SMT $)
M38    FORMAT ($EX $)
M39    FORMAT ($RO $)
MM63   FORMAT ($RDW LINKAGE TO $)
MM39   FORMAT ($RDO LINKAGE TO $)
M7S    FORMAT (7X)
M3S    FORMAT (3X)
M6S    FORMAT (6X)
B5S    FORMAT (B5,1X)
FLOC   FORMAT (B6,1X)
B2S    FORMAT (B2,1X)
UCPMT EQU 4B7 (USE COUNT IN PMT)
UCRMC EQU 1B7 (USE COUNT IN RMC)
RPG    EQU 4B6 (REAL PAGE)
RADPG EQU 2B6 (RAD PAGE)
STTAB  DATA ST0,ST1+UCPMT,ST2+UCRMC+RPG,ST3+RADPG
       DATA ST4+UCRMC+RADPG+RPG
       DATA ST5+RADPG+RPG
       DATA ST6+RADPG+RPG
       DATA ST7+UCPMT+RADPG
       DATA ST10+UCRMC+RADPG+RPG
       DATA ST11+RADPG+RPG
       DATA ST12,ST13+UCRMC+RPG
ST0    FORMAT ($VOID   $)
ST1    FORMAT ($CORE WT$)
ST2    FORMAT ($IN CORE$)
ST3    FORMAT ($ON RAD $)
ST4    FORMAT ($ON BOTH$)
ST5    FORMAT ($WRITE Q$)
ST6    FORMAT ($WRITE  $)
ST7    FORMAT ($READ QU$)
ST10   FORMAT ($READ   $)
ST11   FORMAT ($CORE EX$)
ST12   FORMAT ($INDIREC$)
ST13   FORMAT ($CLEAR W$)
MPORT  FORMAT ($TTY$)
MNUM   FORMAT (/,$NO.$)
       DATA COL0A,COL1A,COL2A,COL3A,COL4A,COL5A,COL6A,COL7A,COL8A
COLHDA EQU *
       DATA COL0B,COL1B,COL2B,COL3B,COL3B,COL5B,COL6B,COL7B,COL8B
COLHDB EQU *
COLHDB EQU *
COL0A  FORMAT ($ CPARW$)
COL0B  FORMAT ($  SET $)
COL1A  FORMAT ($ FILE $)
COL1B  FORMAT ($GROUP $)
COL2A  FORMAT ($  COMP. $)
COL2B  FORMAT ($  TIME  $)
COL3A  FORMAT ($ SWAP $)
COL3B  FORMAT ($ CNT. $)
COL4A  FORMAT ($ CHAR $)
COL5A  FORMAT ($ACTIVATION $)
COL5B  FORMAT ($ CONDITION $)
COL6A  FORMAT ($ SUB   $)
COL6B  FORMAT ($SYSTEM $)
COL7A  FORMAT ($MEM(K)$)
COL7B  FORMAT ($PR+SH $)
COL8A  FORMAT ($ QUEUE$)
COL8B  FORMAT ($ TYPE $)
COL9A  FORMAT ($  USER$)
COL9B  FORMAT ($  NAME$)
PMTHED FORMAT ($  PMT   PAGE   LOCK RL   RAD  STATUS$,/,$ PAGE  STATE        NO  ADDR$,/)
FILHED FORMAT ($TTY FILE$,5X,$FILE OPTIONS$,7X,$USER NAME$,5X,$FILE NAME$,/)
MSTAT  FORMAT (/$INSUFFICIENT LICENSE$/)
PVERS   FORMAT (/$XRAY VERSION 1.01$/)
SNAP   FORMAT (/$* SNAPSHOT *$//)
ALIGN  FORMAT (/$SYMBOLS MISALIGNED$/)
NETNAM FORMAT ($NET FILE: $)
NETFIL FORMAT (/$BAD NET FILE$/)
NLD    FORMAT (/$NO MONITOR LOADED$/)
OFLOW  FORMAT (/$STACK O'FLOW$/)
       IF DEBUG
$UFLOW  FORMAT (/$STACK U'FLOW$/)
       ENDF
FFILE  FORMAT ($FROM FILE: $)
BTYPE  FORMAT (/$NOT SAVE TYPE: $)
BFMT   FORMAT (/$NOT CRASH FORMAT: $)
CANOPN FORMAT (/$CANNOT OPEN: $)
BADRAN FORMAT ($QUESTIONABLE RANGE OF PORT NUMBERS$)
WHOM   FORMAT ($PORTS: $)
NOTON  FORMAT ($ NOT ON SYSTEM$)
ILCHM  FORMAT ($ILL. CHAR "$)
DEVMA  FORMAT ($ [$,L,$].$)
MASG   FORMAT  ($ ASSIGNED TO $)
MDEN   FORMAT ($ DENSITY = $,L,$ BPI.$)
MDVREL FORMAT  ($ RELEASED.$)
MGONE  FORMAT (12($?$))
MNF    FORMAT  ($(PRIVATE)$)
MNODEV FORMAT  (/,$NO DEVICE ASSIGNED.$,/)
MNONE  FORMAT ($NONE$)
MNRDY  FORMAT  ($ TAPE NOT READY.$)
MPRIV  FORMAT ($(PRIV)$)
MQTI   FORMAT (/,$QTI = $,L,$ QIO = $,L,$ QQE = $,L,$ QQC = $,L,$ QSQ = $,L,/)
MTTYA  FORMAT ($ _TTYASG$)
BLOCKM FORMAT ($ (BLOCKED)$)
MRDY   FORMAT ($ (READY)$)
UNKTES FORMAT ($ (???)$)
UM     FORMAT (/,$   PL: $,B5,$ USER  OVF=$,I1,$ PRIORITY=$,B2)
MM     FORMAT (/,$   PL: $,B5,$ MON.  OVF=$,I1,$ PRIORITY=$,B2)
MPACP  FORMAT (//,$   PACT -$)
MREL   FORMAT (/,$   RELABELING: $,B8,$,$,B8,/,$   PTEST: $)
MJS    FORMAT (/,$   JOB: $,B2,$ STATUS: $)
MEX    FORMAT ($EXE $)
MSY    FORMAT ($SYS $)
MSU    FORMAT ($SUB $)
MXBY   FORMAT ($XBR $)
MPIM   FORMAT (/,$   PIM: $,B8,2X)
MFIX   FORMAT ($FIXED $)
MLO    FORMAT ($LOCAL $)
MMEM   FORMAT ($MEMORY$)
MFK    FORMAT (/,$   TS BLOCK  FORK NO. $,B1,$  PANIC: $,B5)
MSMT   FORMAT ($SMT:$)
MEXEC  FORMAT ($EXEC  $)
MED    FORMAT ($EDITOR$)
MBFORC FORMAT ($BFOR,C$)
MXDDT  FORMAT ($XDDT  $)
MDDT   FORMAT ($DDT   $)
FI4S   FORMAT (I4,$K $)
B4S    FORMAT (B4,1X)
I2S    FORMAT (I2,1X)
B4F    FORMAT (B4)
PGFT   FORMAT (I2,$+$,I2,1X)
INDF   FORMAT (I3,$_$B2)
FOLD   FORMAT (/,3X)
NOTREC FORMAT ($ NOT RECOGNIZED.  TRY HELP.$)
HELPM  TEXT '($VALID COMMANDS ARE:$,//,$DAT - PRINT SYSTEM VERSION AN'
       TEXT 'D DATE$,/,$GET - GET MONITOR SNAPSHOT FROM FILE$,/,$'
       TEXT 'XBR - PRINT EXEC BRS STATISTICS$,/,$SST - PRINT SCHE'
       TEXT 'DULER STATISTICS$,/,$B44 - PRINT BRS 44 STATISTICS$,'
       TEXT '/,$RAD - PRINT RAD STATISTICS$,/,$TRA - TOGGLE TRACE'
       TEXT ' SWITCH TO CONTROL SNAPSHOTS$,/$RPT - SET REPEAT COU'
       TEXT 'NT FOR MULTIPLE SNAPSHOTS$,/,$CLK - SET TIMING INTER'
       TEXT 'VAL BETWEEN SNAPSHOTS$,/,$LIS - SET LIST OPTIONS FOR'
       TEXT ' "GO" COMMAND$,/,$SEL - SELECT PORTS OR USERS FOR "G'
       TEXT 'O" COMMAND$,/,$GO  - MAKE REPORT OF USERS ON SYSTEM$'
       TEXT ',/,$PUQ - PRINT PHANTOM USER QUEUE$,/,$TTQ - PRINT BUFFERED'
       TEXT 'TERMINAL I/O QUEUE $'
       TEXT '/,$HEL - THESE MESSAGES$,/,$QUI - (OR Q) QUIT THE PROGRAM$,//)'
HHOPT  TEXT '$THE FOLLOWING OPTIONS MAY BE SPECIFIED TO SPECIFY G'
       TEXT 'ROUPS$,/,$OF OPTIONS ABOVE, THUS SAVING TYPING:$,/,$'
       TEXT 'EXE - EQUIVALENT TO CPA GRP UNM DEV FIL$,/,$RES - EQ'
       TEXT 'UIVALENT TO COM SWP CHR MEM UNM$,/,$SCH - EQUIVALENT'
       TEXT ' TO COM SWP CHR ACT QTY UNM QUE$,/,$SYS - EQUIVALENT'
       TEXT ' TO SUB MEM UNM$,/,$ALL - EQUIVALENT TO ALL OPTIONS '
       TEXT 'EXCEPT PMT PAC$,//)'
HOPT1  TEXT '(/,$LIST OPTIONS ARE$)'
HOPT2  TEXT '(/,$UNDER THE "LIST" COMMAND THE FOLLOWING OPTIONS ARE AVAILABLE:$)'
HOPT   TEXT '(/,$HEL - EXPLAIN OPTIONS AVAILABLE$'
       TEXT ',/,$CPA - LIST CPARW AND MAIL STATUS'
       TEXT '$,/,$GRP - LIST FD GROUP NO.$,/,$COM - LIST COMPUTE TIME'
       TEXT '$,/,$SWP - LIST SWAP COUNT$,/,$CHR - LIST CHAR COUNT$,/,'
       TEXT '$ACT - LIST ACTIVATION CONDITION$,/,$SUB - LIST SUBSYSTE'
       TEXT 'M$,/,$MEM - LIST MEMORY USED$,/,$QTY - LIST QUEUE TYPE$,'
       TEXT '/,$UNM - LIST USER NAME$,/,$DEV - LIST DEVICES IN USE$,/'
       TEXT ',$FIL - LIST FILES OPENED$,/,$QUE - LIST QUEUE COUNTS$,/'
       TEXT ',$PMT - LIST PRIVATE MEMORY$,/$PAC - LIST PACT CHAINS$,/'
       TEXT ',$TTY - LIST PORT TABLES$,//)'
SUBTBL DATA MPRIV,MSB,MSB,MSB,MSB,MSB,MSB,MSB
       DATA MXFO,MXFO
       DATA MCAL,MCAL,MCAL,MCAL,MCAL
       DATA MNBA,MNBA,MNBA,MNBA,MNBA,MNBA,MNBA,MXFO,MXFO
       DATA MFTC,MFTC
       DATA MCOM,MCOM,MCOM
       DATA MSFOR,MSFOR,MSFOR,MSFOR,MSFOR,MSFOR,MSFOR,MSFOR
       DATA MSFOR,MSFOR,MPRIV
       DATA MFOS,MFOS,MFOS
       DATA MPRIV,MPRIV,MPRIV,MNBA,MNBA,MNBA,MNBA,MPRIV
       DATA MF2C,MF2C
       DATA MF2OS,MF2OS,MF2OS
       DATA MPRIV,MXFO,MXFO,MXFO,MXFO,MPRIV,MPRIV,MPRIV,MPRIV
       DATA MBFOR,MBFOR,MBFOR,MBFOR,MBFOR,MBFOR,MBFOR,MBFOR,MBFOR
       DATA MBFOR,MBFOR,MBFOR,MPRIV
       ASC  'SB IU SC       PC WR RD '
POPTE  EQU *
DENTBL DATA 200,556,800
DEVTBL DATA MTAPE0,MTAPE1,MPRINT
MTAPE0 FORMAT (/,$TAPE DRIVE 0$)
MTAPE1 FORMAT (/,$TAPE DRIVE 1$)
MPRINT FORMAT (/,$PRINTER$)
QUEUE  DATA MQTIQ,MQIOQ,MQQEQ,MQQCQ,MQSQQ
MQTIQ  FORMAT ($QTI $)
MQIOQ  FORMAT ($QIO $)
MQSQQ  FORMAT ($QSQ $)
MQQCQ  FORMAT ($QQC $)
MQQEQ  FORMAT ($QQE $)
MSB    FORMAT ($SBASIC$)
MCAL   FORMAT ($CAL   $)
MFTC   FORMAT ($FTC   $)
MCOM   FORMAT ($COMMON$)
MSFOR  FORMAT ($SFOR  $)
MFOS   FORMAT ($FOS   $)
MF2C   FORMAT ($F2C   $)
MF2OS  FORMAT ($F2OS  $)
MXFO   FORMAT ($XFO   $)
MNBA   FORMAT ($NBASIC$)
MBFOR  FORMAT ($BFOR,R$)
SPTEST DATA MSA,MSBB,MSC,MSD,MSE,MSF,MSGG
MSA    FORMAT ($DEAD$)
MSBB   FORMAT ($RUN $)
MSC    FORMAT ($B9ST$)
MSD    FORMAT ($RAD $)
MSE    FORMAT ($XBRS$)
MSF    FORMAT ($B109$)
MSGG   FORMAT ($BRS9$)
       ASC 'ALLEXERESSCHSYS'
SOPTE EQU *
       DATA 77747400B,60043000B,1624B4,17140400B,0064B4
SOPVE EQU *
       ASC 'CPAGRPCOMSWPCHRACTSUBMEMQTYUNMPACPMTTTYDEVFILQUE'
       RPT 8; DATA -1; ENDR
OPTE EQU *
       DATA 6,6,8,6,6,11,7,6,6,0,0,0,0,0,0,0
       RPT 8; DATA 0; ENDR
OPTWE  EQU *
QTAB   EQU *
       RPT (X=0,7); DATA QM($X); ENDR
       RPT (X=10,12); DATA QM($X); ENDR
       DATA QM13,QM13,QM15,QM16,QM13
       RPT (X=20,27); DATA QM($X); ENDR
       DATA QM30,QM13
       RPT (X=32,37); DATA QM($X); ENDR
QM0 FORMAT ($FKSTW    $)
QM1 FORMAT ($FQJ SWP  $)
QM2 FORMAT ($TTY OUT. $)
QM3 FORMAT ($TTQ WAIT $)
QM4 FORMAT ($TAPE RDY.$)
QM5 FORMAT ($SOFT.INT.$)
QM6 FORMAT ($TTY INPUT$)
QM7 FORMAT ($SPECIAL  $)
QM10 FORMAT ($DISC     $)
QM11 FORMAT ($YEL. BALL$)
QM12 FORMAT ($UNIT<0   $)
QM13 FORMAT ($UNKNOWN  $)
QM15 FORMAT ($SETPAC PU$)
QM16 FORMAT ($TRAPT    $)
QM20 FORMAT ($TFK EXEC $)
QM21 FORMAT ($TFK OTHER$)
QM22 FORMAT ($124 PU   $)
QM23 FORMAT ($BRS115   $)
QM24 FORMAT ($BRS44 SCH$)
QM25 FORMAT ($BRS44 HNG$)
QM26 FORMAT ($RFK SWP  $)
QM27 FORMAT ($TTQ SWP  $)
QM30 FORMAT ($PUACT SWP$)
QM32 FORMAT ($SUPR.REQ.$)
QM33 FORMAT ($TAPE/PRI.$)
QM34 FORMAT ($OUT. RING$)
QM35 FORMAT ($DHTPAC   $)
QM36 FORMAT ($CLOCK    $)
QM37 FORMAT ($PMTA SWP $)
       IF TSTAT
RADM1  FORMAT ($RAD STATISTICS$,/,$ACT. COND$,3X,$PAGES$,6X,$PCT.$,//)
RADM2  FORMAT (/,$SCHED.$,//)
RADM3  FORMAT (27($-$),/,9X,I8,$  100.0000$,/)
FPQ    FORMAT (24($-$),/,4X,I8,1X)
QJSTA FORMAT (/,$SWAP JOB STATISTICS$)
QJSTA1 FORMAT (/,$LEVEL NO. RUN  AVG. RUN$,/)
CJSTA FORMAT (//,$COMPUTE JOB STATISTICS$)
QTYP ASC 'QTIQIOQQEQSQ'
QJ1 FORMAT (/,$SWAP JOBS RUN = $,I11)
QJ2 FORMAT (/,$AVG. SWAP TIME = $)
QJ3 FORMAT (/,$COMPUTE JOBS RUN = $,I8)
QJ4 FORMAT (/,$AVG. TIME RESIDENT = $)
RM3 FORMAT (/,$PAGES TO BRING$,4X,2(I10),/,$AVG. HANG TIME:$,3X)
       ELSE
RADM1  FORMAT ($RAD STATISTICS$,/)
QJSTA  FORMAT (/,$SWAP AND COMPUTE JOB STATISTICS NOT ASSEMBLED$,/)
       ENDF
       IF TSTAT1
XBRSTA FORMAT (/,$XBRS STATISTICS$,/,$NO.   COUNT   AVG. RUN$,/)
XBR6   FORMAT (22($-$),/,3X,I8)
XBNO   DATA 15,16,58,18,19,59,48,95,96,60,142,141,176
       DATA 182,68,69,62,63,64,65,37,6,67,173,ISC,SIC
       DATA 52,53,190,191,192,193,91,140,171,187,27,-1
ISC    ASC 'ISC'
SIC    ASC 'SIC'
       ELSE
XBRSTA FORMAT (/,$XBRS STATISTICS NOT ASSEMBLED$,/)
       ENDF
       END
MONITOR ** FICHE/FRAME BREAK *****
XRA3 SYMSORT

SYM.  PG.LN. IDENT.

ALIGN   7 29 XRA3    B2S     6 12 XRA3    B4F     9  5 XRA3    
B4S     9  3 XRA3    B5S     6 10 XRA3    BADPU   4 39 XRA3    BADRAN  8  2 XRA3    
BASS    5 20 XRA3    BAUDTB  4 23 XRA3    BFMT    7 39 XRA3    BLOCKM  8 18 XRA3    
BTYPE   7 38 XRA3    CANOPN  8  1 XRA3    CJSTA  12 25 XRA3    CLKVAL  3  3 XRA3    
COL0A   7  5 XRA3    COL0B   7  6 XRA3    COL1A   7  7 XRA3    COL1B   7  8 XRA3    
COL2A   7  9 XRA3    COL2B   7 10 XRA3    COL3A   7 11 XRA3    COL3B   7 12 XRA3    
COL4A   7 13 XRA3    COL5A   7 14 XRA3    COL5B   7 15 XRA3    COL6A   7 16 XRA3    
COL6B   7 17 XRA3    COL7A   7 18 XRA3    COL7B   7 19 XRA3    COL8A   7 20 XRA3    
COL8B   7 21 XRA3    COL9A   7 22 XRA3    COL9B   7 23 XRA3    COLHDA  7  1 XRA3    
COLHDB  7  4 XRA3    COLHDB  7  3 XRA3    COLNCH  2 32 XRA3    DEDPU   5  1 XRA3    
DENTBL 10 20 XRA3    DEVMA   8  6 XRA3    DEVTBL 10 21 XRA3    EV      5 30 XRA3    
F100    2 35 XRA3    F104    2 39 XRA3    FFILE   7 37 XRA3    FI3     2 37 XRA3    
FI4S    9  2 XRA3    FI8     2 38 XRA3    FILHED  7 25 XRA3    FLOC    6 11 XRA3    
FOLD    9  8 XRA3    FPQ    12 22 XRA3    HELPM   9 10 XRA3    HHOPT   9 23 XRA3    
HOPT    9 32 XRA3    HOPT1   9 30 XRA3    HOPT2   9 31 XRA3    I2S     9  4 XRA3    
IBAUD   4 22 XRA3    ILCHM   8  5 XRA3    INDF    9  7 XRA3    ISC    13  3 XRA3    
K100    2 28 XRA3    K12B5   2 15 XRA3    K13     2 23 XRA3    K1440D  2 20 XRA3    
K15     2 24 XRA3    K16     2 25 XRA3    K17     2 17 XRA3    K1B7    2 29 XRA3    
K1S5    2 19 XRA3    K20     2 31 XRA3    K31     2 18 XRA3    K3S4    2 27 XRA3    
K72D    2 16 XRA3    K74     2 21 XRA3    K77     2 26 XRA3    M38     6  3 XRA3    
M39     6  4 XRA3    M3S     6  8 XRA3    M62     5 38 XRA3    M6S     6  9 XRA3    
M7S     6  7 XRA3    MASG    8  7 XRA3    MB44    3  6 XRA3    MBCH    2 30 XRA3    
MBFOR  11  2 XRA3    MBFORC  8 38 XRA3    MC      5 31 XRA3    MCAL   10 32 XRA3    
MCLK    5 34 XRA3    MCOM   10 34 XRA3    MDDT    9  1 XRA3    MDEN    8  8 XRA3    
MDVREL  8  9 XRA3    MED     8 37 XRA3    MEX     8 26 XRA3    MEXEC   8 36 XRA3    
MF      5 32 XRA3    MF2C   10 37 XRA3    MF2OS  10 38 XRA3    MFIX    8 31 XRA3    
MFK     8 34 XRA3    MFOS   10 36 XRA3    MFTC   10 33 XRA3    MGONE   8 10 XRA3    
MISTQ   5 23 XRA3    MJS     8 25 XRA3    MLO     8 32 XRA3    MM      8 22 XRA3    
MM34    6  1 XRA3    MM35    6  2 XRA3    MM39    6  6 XRA3    MM63    6  5 XRA3    
MM64    5 39 XRA3    MMEM    8 33 XRA3    MMRPT   3  5 XRA3    MNBA   11  1 XRA3    
MNF     8 11 XRA3    MNODEV  8 12 XRA3    MNONE   8 13 XRA3    MNRDY   8 14 XRA3    
MNUM    6 38 XRA3    MPACP   8 23 XRA3    MPIM    8 30 XRA3    MPORT   6 37 XRA3    
MPRINT 10 24 XRA3    MPRIV   8 15 XRA3    MQIOQ  10 27 XRA3    MQQCQ  10 29 XRA3    
MQQEQ  10 30 XRA3    MQSQQ  10 28 XRA3    MQTI    8 16 XRA3    MQTIQ  10 26 XRA3    
MRDY    8 19 XRA3    MREL    8 24 XRA3    MRPT    3  4 XRA3    MRUN    5 35 XRA3    
MSA    11  4 XRA3    MSB    10 31 XRA3    MSBB   11  5 XRA3    MSC    11  6 XRA3    
MSD    11  7 XRA3    MSE    11  8 XRA3    MSF    11  9 XRA3    MSFOR  10 35 XRA3    
MSGG   11 10 XRA3    MSMT    8 35 XRA3    MSTAT   7 26 XRA3    MSU     8 28 XRA3    
MSY     8 27 XRA3    MTAPE0 10 22 XRA3    MTAPE1 10 23 XRA3    MTF1    3 13 XRA3    
MTF1    3 12 XRA3    MTF10   3 37 XRA3    MTF11   3 36 XRA3    MTF110  3 29 XRA3    
MTF111  3 28 XRA3    MTF112  3 27 XRA3    MTF113  3 26 XRA3    MTF114  3 25 XRA3    
MTF115  3 24 XRA3    MTF116  3 23 XRA3    MTF117  3 22 XRA3    MTF12   3 35 XRA3    
MTF120  3 21 XRA3    MTF121  3 20 XRA3    MTF122  3 19 XRA3    MTF123  3 18 XRA3    
MTF124  3 17 XRA3    MTF125  3 16 XRA3    MTF126  3 15 XRA3    MTF127  3 14 XRA3    
MTF13   3 34 XRA3    MTF14   3 33 XRA3    MTF15   3 32 XRA3    MTF16   3 31 XRA3    
MTF17   3 30 XRA3    MTF2    4  1 XRA3    MTF214  4 13 XRA3    MTF215  4 12 XRA3    
MTF216  4 11 XRA3    MTF217  4 10 XRA3    MTF220  4  9 XRA3    MTF221  4  8 XRA3    
MTF222  4  7 XRA3    MTF223  4  6 XRA3    MTF224  4  5 XRA3    MTF225  4  4 XRA3    
MTF226  4  3 XRA3    MTF227  4  2 XRA3    MTF3    4 15 XRA3    MTF310  4 21 XRA3    
MTF323  4 20 XRA3    MTF324  4 19 XRA3    MTF325  4 18 XRA3    MTF326  4 17 XRA3    
MTF327  4 16 XRA3    MTF4A   4 27 XRA3    MTF4C   4 28 XRA3    MTF4M   4 26 XRA3    
MTF4T   4 25 XRA3    MTFPAR  4 24 XRA3    MTTYA   8 17 XRA3    MU      5 33 XRA3    
MV      5 29 XRA3    MWI     5 28 XRA3    MXBY    8 29 XRA3    MXDDT   8 39 XRA3    
MXFO   10 39 XRA3    NETFIL  7 31 XRA3    NETNAM  7 30 XRA3    NLD     7 32 XRA3    
NOTON   8  4 XRA3    NOTREC  9  9 XRA3    NTRM    5  4 XRA3    OFLOW   7 33 XRA3    
OPTE   11 17 XRA3    OPTWE  11 20 XRA3    P124M   4 38 XRA3    P20LOK  5 25 XRA3    
P20NLK  5 26 XRA3    PBLM    5 27 XRA3    PGFT    9  6 XRA3    PMTHED  7 24 XRA3    
POPTE  10 19 XRA3    PUQM1   4 31 XRA3    PVERS   7 27 XRA3    QJ1    12 27 XRA3    
QJ2    12 28 XRA3    QJ3    12 29 XRA3    QJ4    12 30 XRA3    QJSTA  12 34 XRA3    
QJSTA  12 23 XRA3    QJSTA1 12 24 XRA3    QM0    11 28 XRA3    QM1    11 29 XRA3    
QM10   11 36 XRA3    QM11   11 37 XRA3    QM12   11 38 XRA3    QM13   11 39 XRA3    
QM15   12  1 XRA3    QM16   12  2 XRA3    QM2    11 30 XRA3    QM20   12  3 XRA3    
QM21   12  4 XRA3    QM22   12  5 XRA3    QM23   12  6 XRA3    QM24   12  7 XRA3    
QM25   12  8 XRA3    QM26   12  9 XRA3    QM27   12 10 XRA3    QM3    11 31 XRA3    
QM30   12 11 XRA3    QM32   12 12 XRA3    QM33   12 13 XRA3    QM34   12 14 XRA3    
QM35   12 15 XRA3    QM36   12 16 XRA3    QM37   12 17 XRA3    QM4    11 32 XRA3    
QM5    11 33 XRA3    QM6    11 34 XRA3    QM7    11 35 XRA3    QTAB   11 21 XRA3    
QTYP   12 26 XRA3    QUEUE  10 25 XRA3    RADM1  12 33 XRA3    RADM1  12 19 XRA3    
RADM2  12 20 XRA3    RADM3  12 21 XRA3    RADM4   3  7 XRA3    RADM5   3  8 XRA3    
RADPG   6 16 XRA3    RBT     4 33 XRA3    RBT0    4 32 XRA3    RBT1    4 34 XRA3    
RBT2    4 35 XRA3    RBT3    4 36 XRA3    RBT4    4 37 XRA3    RM3    12 31 XRA3    
RPG     6 15 XRA3    SEVEN   2 36 XRA3    SIC    13  4 XRA3    SIX     2 33 XRA3    
SNAP    7 28 XRA3    SOPTE  11 12 XRA3    SOPVE  11 14 XRA3    SPTEST 11  3 XRA3    
ST0     6 25 XRA3    ST1     6 26 XRA3    ST10    6 33 XRA3    ST11    6 34 XRA3    
ST12    6 35 XRA3    ST13    6 36 XRA3    ST2     6 27 XRA3    ST3     6 28 XRA3    
ST4     6 29 XRA3    ST5     6 30 XRA3    ST6     6 31 XRA3    ST7     6 32 XRA3    
STTAB   6 17 XRA3    SUBTBL 10  3 XRA3    SYSID1  5 36 XRA3    SYSID2  5 37 XRA3    
T1F     4 30 XRA3    TEN     2 34 XRA3    TF5A    5 12 XRA3    TF5B    5 13 XRA3    
TF5C    5 14 XRA3    TF5D    5 15 XRA3    TF5E    5 16 XRA3    TF5F    5 17 XRA3    
TF5G    5 18 XRA3    TF5H    5 19 XRA3    TFF5    5 11 XRA3    THREE   2 22 XRA3    
TIMPU   5  2 XRA3    TMK     2 14 XRA3    TRCOFF  3  2 XRA3    TRCON   3  1 XRA3    
TRM     5  3 XRA3    TTQHED  5  5 XRA3    TTQP    5  6 XRA3    TTQP1   5  7 XRA3    
TTQPI   5  8 XRA3    TTQPO   5  9 XRA3    TTQTM   5 22 XRA3    TTYHED  4 29 XRA3    
UCPMT   6 13 XRA3    UCRMC   6 14 XRA3    UFLOW   7 35 XRA3    UM      8 21 XRA3    
UNKTES  8 20 XRA3    WHOM    8  3 XRA3    XBNO   12 39 XRA3    XBR6   12 38 XRA3    
XBRSTA 13  6 XRA3    XBRSTA 12 37 XRA3    
MONITOR ** FICHE/FRAME BREAK *****
LOAD 
"LOAD MAP"
RESET
XDDT
0;TBPMT
%K
;K
;Z
;F<P5>
34000;TB1TS
34000-P5;TBPMT
220;TBI
;TBFQJP
;F\P1:
0;14000-P1#._4000;TBS
;TBTYM
1\BRU SETSET
25\BRU SETSET
73\BRU 73; BRU 73; BRU 73; BRU 73; BRU 73; BRU 73
;TBB
;TBR
;TBRUP
;TBPAC
0;134000-P5-;F#;F\P5:
P5_34000;TBMAP
35300;TBSET
;F\P7:P7+1
37400;TBBL
%Q TOUT NOTHING
CON
100\BRS 43D; STP 11,5; RCY 6; LRSH 6; LCY 12D; STB 13
.+1\LRSH 12D; LSH 12D; STB 20
. 1\CLB; BRS 44D; LDB 20000; LDB 24000; LDB 34000
. 1\BRS 43D; STB 14; CLA; LSH 6; CBX; CLB; LSH 6
. 1\STA 15; CXB; CLA; LSH 6; CBX; CLB; LSH 6; STA 16
. 1\CXA; LRSH 12D; STA 17; CLEAR; BRS 12
100;G
11\<R1>12\<R2>13\<R3>14\<R4>15\<R5>16\<R6>17\<R7>20\<R20>
R1,R3+R5;R
%Q
TOUT TELETYPE
CON
30000;TBD
;F\DP6:
34000-DP6#DP6_
R1,R3+R6;R
31000;TBW
;F\WP6:WP6 1
34000-WP6#WP6_
WP6 1\-1
. 4001<LDATA>
37777<ELDATA>
33777\LDATA-4000-.
R1,R20+R7;RTC+NPORT+1;TBNET
11,20;Z
37776<ETBUF>
;F<TBUF>ETBUF-TBUF;*3<BUFSIZ>TCC\BUFSIZ
BUFSIZ;/3<BUFSIZ>1TCC\BUFSIZ
BUFSIZ+12<BUFSIZ>2TCC\BUFSIZ
BUFSIZ;KETBUF;K;UR1,R2;R%Q
SAVE 0 TO 37777 ON M1

KILL
TOUT NOTHING
CON
R4-R7,R7;R
07010203<R1>
04050611<R2>
600<R6>
1000<R10>
11<R11>
43011213<RE1>
14151600<RE2>
R3;KR4;KR5;KR7;KR20;K
EXSMTE;KUEXFLG;KOHM;KDR;K
11@<BRI>6@<EOD>EOM 20002<EIR>EOM 20004<DIR>EOM 20100<CKN>
P1+1;FEOM 20200<CKF>EOM 20400<LRR1>EOM 21000<LRR2>EOM 21400<LRR3>%Q
TOUT TELETYPE
SAVE 0 TO 37777 ON M2

KILL
DUMP MONST

CON
;W MSYM

%FRES
XDD
0;TB0
;TB1
;TB2
;TBSPB
;TBJRS
;TB3
;CBSYM

0;TMSYM
;U;K
0;TBSYM
%FSAV 240 TO 13777 ON G1XRAY

240
"
GO FILE FOR 1XRAY FOR THIS MONITOR:
"
CHECKSUM
.
G1XRAY-GO-FILE
.
COM T
MONITOR ** FICHE/FRAME BREAK *****
NARP
"MAKE NARP BINARY FILES
"
NARP
M
NOT
TEL
DUM CON

CON
TS
B1TS

TEL
CON
S
BS

TEL
CON
I
BI

TEL
CON
FQJP
BFQJP

TEL
CON
TYM
BTYM

TEL
CON
NET
BNET

TEL
CON
PAC
BPAC

TEL
CON
B
BB

TEL
CON
R
BR

TEL
CON
RUP
BRUP

TEL
CON
PMT
BPMT

TEL
CON
SET
BSET

TEL
CON
BLET
BBL

TEL
CON
MAP
BMAP

TEL
CON
D
BD

TEL
CON
W
BW

TEL
RUN CON
XRA0
B0

TEL
CON
XRA1
B1

TEL
CON
XRA2
B2

TEL
CON
XRA3
B3

TEL
CON
JRSS
BJRS

TEL
CON
SPBS
BSPB

TEL
COM LOAD
   qbP