SURVEY ** FICHE/FRAME BREAK *****
/CFIX:SRCE/
FIX IDENT
*  FIX THE FLOATING POINT NUMBER WHOSE VALUE IS IN A,B
*  AND STORE IN THE ADDRESS IN X

$FIX   ZRO  0
       BRS 118  LOAD FLOATING ACCUMULATORS
       BRS 149  FIX NUMBER AND PLACE IN A,B
       STP 0,2  STORE IN (X)
       BRR FIX
       END
SURVEY ** FICHE/FRAME BREAK *****
/CFIX:SRCE/ SYMSORT

SYM.  PG.LN. IDENT.

FIX     1  5 FIX     
SURVEY ** FICHE/FRAME BREAK *****
/CPAVCOM:SIMP/
!  COM VERSION C
!  JP BARASZ
! 14 JAN 1972
!
! CONVERTED TO BILINGUAL VERSION 5/74 BY B.THORNQUIST
!
! MESAGE 'INT NOT DESTROYED REMOVED
!
DEF BI(ENGLISH,FRENCH) AS ENGLISH

       TABLE &
VERSION [BI("SURVEY A03.08","CPAVOT A03.08")]

!!! SUPERGLOBALS

FIND CMFLG
FIND SFLNO,SNAME(0:1)
FIND CFLNO
!
!
FIND  STUDY(0:11)
FIND TEL,DIC,NMPAGE,QCBPAGE,BFLNO,INTRFL

!!! SWAPPER VARIABLES

FIND RL1,RL2
FIND COMRL1,COMRL2,MAJRL1,MAJRL2,MAJST,TCORL1,TCORL2,TCOMST
FIND PREST,PRERL1,PRERL2
FIND IMPST,IMPRL1,IMPRL2
FIND STASTR,STARL1,STARL2
FIND GENST,GENRL1,GENRL2
FIND TABUST,TABRL1,TABRL2

!!! DICTIONARY CONTROL BLOCK

FIND DICVERS,NQUES,CDPLST,CDPLND,LLBPLST,LLBPLND,QCBADR
FIND NAMADR,QSIZE,QVERS,FMT,NMCRD,QNOPOS,QNOLEN,CDNOPOS,CDNOLEN

!!! SHARABLE PAGES

FIND QNAME(),QCBS()

!!! EXTERNAL FUNCTIONS

FIND %BOUT,%OUTNO
FIND %ARM,%LENGTH,%LEFT,%DISPLAY,%EQUAL,%STRNG
FIND %LOADER
FIND %ADDSTR,%GETLIST,%NXTITEM,%TRNSTR
FIND %ACCEPT,%GTPT,%STRFRK

!!! LOCAL VARIABLES

!
!      COMMAND FILE VARIABLES
!
LOCAL GFLNO    ! GO FILE NUMBER
LOCAL STIRT:

LOCAL I,J,K,L,M,N,TSTR(0:72),ERR,PTR,VSIZE,FSIZE
FIND FORKTB(0:6)
LOCAL QCUR
LOCAL DMOD  !DICTIONARY MODIFIED FLAG

!!! SCANNER AND OTHER EXTERNAL VARIABLES AND FUNCTIONS

FIND TYPE,VALUE,TOKEN(0:1),%READ,%SCAN
FIND BUFF(0:1),NEWBUF(0:1)
FIND LIST(1) !LIST PROCESSOR BUFFER

!!! SCANNER TYPES

DEF ALPHTYPE AS 1
DEF NUMTYPE AS 2
DEF EOLTYPE AS 5
DEF QSTYPE AS 6

!!! LOCAL FUNCTIONS
LOCAL %SYNERR,%QINIT,%DICRIT,%SUBGO,%BINIT,%SHORT,%SHIRT

!!! LABELS

GLOBAL BADDIC:,ESCAPE:,START:,ST1:


!!! MACROS

DEF SORTIE AS 0
DEF BIN AS 2
DEF ENDLIST AS OCT 20000000
DEF NFILTS AS 48
DEF MXQUES AS 512-48
DEF FDEL(P1,P2,BAD) BY
       \BRS 48 (I,J,GO BAD)
       \BRS 69 (GO BAD)
ENDM FDEL
DEF OPENO(P1,P2,BAD,FILE,TYP) BY
!
       \BRS 65 (P1,P2,TYP,GO BAD)
       \STA (FILE)
ENDM OPENO
DEF CLOSE(X) AS \BRS 20 (X)

!DEF OUTNO(X) AS \BRS 36 (X,10,1)
DEF PROMPT(X) BY
       DISPLAY(X,1,0)
       READ(@TEL)
ENDM PROMPT
DEF DREAD(WHAT,NUM,WHERE) BY 
       \SCP (DIC,WHERE,GO BADDIC)
       \BIO(DIC,NUM,,WHAT,GO BADDIC)
ENDM DREAD
DEF DWRITE(WHA,N,WHE) BY
       DREAD(WHA,N,WHE+OCT 40000000)
ENDM DWRITE
DEF QQNAME(X,Y) AS QNAME ((X-1)*4+Y)
DEF QQCBS(X,Y) AS QCBS ((X-1)*4+Y)

!!! COMMAND TABLE

DEF NORDRS AS 8
TABLE ORDR(0:NORDRS-1)["QUIT",BI("UPDATE","MAJ"), &
        BI("DESTROY","DETRUIRE"),BI("TABULATION","VENTILATION") &
                                        ,BI('PRINT','EDITION'), &
        'GENERATION',BI('HELP','SOS'),'TIME' ]

!
!-------------------------------------------DEBUT

!
!      SEE IF WE HAVE A COMMAND FILE
!

START: \STA(CFLNO)  ! SAVE COMMAND FILE NO. (IF ANY)
       \STX(GFLNO)  ! SAVE GO FILE NO.
       CMFLG_0
       IF CFLNO THEN TEL_CFLNO ELSE GO STIRT
STIRT:  \BRS 113
       \BRS 92 (3200000)  !SET MAX FILE SIZE
       DISPLAY(VERSION,1,1)
       LOADER(@MAJST,@MAJRL1,GFLNO)
       LOADER(@TCOMST,@TCORL1,GFLNO)
       LOADER(@TABUST,@TABRL1,GFLNO)
       LOADER(@PREST,@PRERL1,GFLNO)
       LOADER(@IMPST,@IMPRL1,GFLNO)
       LOADER(@GENST,@GENRL1,GFLNO)
       LOADER(@STASTR,@STARL1,GFLNO)

!***** DEBUG
!EF OUTNUM(X,Y,Z) AS \BRS 36 (X,Y,Z)
!OUTNUM(COMRL1,8,1); BOUT(CARRET); OUTNUM(COMRL2,8,1); BOUT(CARRET)
!OUTNUM(MAJRL1,8,1); BOUT(CARRET); OUTNUM(MAJRL2,8,1); BOUT(CARRET)
!OUTNUM(TCORL1,8,1); BOUT(CARRET); OUTNUM(TCORL2,8,1) ; BOUT(CARRET)
!OUTNUM(TABRL1,8,1); BOUT(CARRET); OUTNUM(TABRL2,8,1); BOUT(CARRET)
!OUTNUM(PRERL1,8,1); BOUT(CARRET); OUTNUM(PRERL2,8,1); BOUT(CARRET)
!UTNUM(IMPRL1,8,1); BOUT(CARRET); OUTNUM(IMPRL2,8,1); BOUT(CARRET)
!OUTNUM(GENRL1,8,1); BOUT(CARRET); OUTNUM(GENRL2,8,1); BOUT(CARRET)
!OUTNUM(STARL1,8,1); BOUT(CARRET); OUTNUM(STARL2,8,1); BOUT(CARRET)
!******* DEBUG
       CLOSE(GFLNO) ! CLOSE GO FILE

       QCBS_OCT 30000
       QNAME_OCT 34000
       ARM(ST1); \BRS 114
       \BRS 13(,,-1,GO STZ)
!
!      GET STUDY NAME
!
ST1:   DISPLAY(BI("STUDY NAME: ","NOM DE L'ETUDE: "),1,0)
STZ:   READ(@TEL)
       TRNSTR(@BUFF,@STUDY)
       IF LENGTH(@STUDY)>27 OR LENGTH(@STUDY)=0 THEN GO ST1
       ADDSTR(@STUDY,"'DIC'",@TSTR)
       GTPT(@TSTR,@I,@J)
       LOCAL LSHIF
       LSHIF_OCT 10000
       IF CFLNO THEN LSHIF_1
       OPENO(I+OCT 11600000,J,ST1,DIC,BIN*LSHIF)
       \RSP (DIC); \STA (FSIZE)

       IF FSIZE<3 THEN GO NEWDIC
       \SCP(DIC,0,GO BADDIC) !READ MODE
!
!      GE TQCB'S AND QNAMES
!
       \WIO (DIC); \STA (DICVERS)
       IF DICVERS#^"C02" THEN DO
               DISPLAY(BI("DICTIONARY VERSION INCOMPATIBLE", &
               'VERSION DU DICTIONNAIRE INCOMPATIBLE'),1,1)
               CLOSE(DIC); GO ST1
       END
       \BIO(DIC,15,,@NQUES,GO BADDIC)
       \BRS 43; \STA (RL1); \STB (RL2)
       [COMRL1;COMRL2]_[RL1;RL2]
       DREAD(QCBS,4096,QCBADR) !READ QCBS AND QNAMES!
       \BRS 43; \STA (I); \STB (J)
       QCBPAGE_BYT(J,6,6)
       NMPAGE_BYT(J,6,0)
       GO CMND

!
!      HERE FOR NEW DICTIONARY
!
NEWDIC: DISPLAY(BI("TOTAL NUMBER OF QUESTIONS: ", &
         "NOMBRE DE TOTAL DE QUESTIONS: "),1,0)
       DMOD_1
       READ(@TEL)
       SCAN
       IF TYPE#NUMTYPE OR VALUE=0 OR VALUE>MXQUES THEN GO NEWDIC
       NQUES_VALUE
ND1:   DISPLAY("FORMAT: ",1,0)
       READ(@TEL)
ND2:   SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT(BI("SURVEY FORMAT OR CARD FORMAT: ", &
                 "FORMAT 'SURVEY' OU FORMAT 'CARTES': "))
               GO ND2
       END
       IF TYPE#ALPHTYPE THEN GO ND1
       IF SHORT("SURVEY") THEN [FMT_0; GO ND3]
       IF NOT SHORT(BI("CARDS","CARTES")) THEN GO ND1
       FMT_1

ND3:    NULL
       
!--------------------------------------------------- INITIALIZE DICO.

       DICVERS_^"C02"
       QCBADR_OCT 400*3
       NAMADR_OCT 4400*3
       CDPLST_CDPLND_OCT 10400*3
       NMCRD_0  !PREVENTS PREPROCESS BEFORE FORMAT DEFINITION
       LLBPLST_LLBPLND_CDPLST+180000

       QSIZE_3; QINIT(1,NQUES,@QSIZE)
       BINIT  ! INITIALIZE BASE NAMES
       \BRS 43; \STA (I); \STB (J)
       QCBPAGE_BYT(J,6,6)
       NMPAGE_BYT(J,6,0)


!
CMND:  ARM(ESCAPE)
       BOUT(CARRET); BOUT($*)
       READ(@TEL)
       SCAN
       IF TYPE=EOLTYPE THEN GO CMND
       IF TYPE#ALPHTYPE THEN DO
CMND1:         SYNERR(BI("INVALID COMMAND","ORDRE INCORRECT"))
       END

DSPTCH: I_0
DSP0:   IF SHIRT('PRINT') THEN GO EDIT
       IF SHIRT('PREPROCESS') THEN GO PRETRAIT
       IF SHIRT('PRETREAT') THEN GO PRETRAIT
       IF SHORT(ORDR(I)) THEN GO DSP1
       IF INC I<NORDRS THEN GO DSP0
       GO CMND1

DSP1:  DO I+1 OF NORDRS
       1:  GO QUIT
       2:  GO MAJ
       3:  GO CMND1
       4:  GO VENTIL
       5:  GO EDIT
       6:  GO GENER
       7:  GO SOS
        8:  GO TIME
       END

!
TIME:  \BRS 88; \STA (I); OUTNO(I/60); DISPLAY(" SECS.",0,1)
       GO CMND

SOS:   I_0
       DISPLAY(BI("VALID COMMANDS ARE:", &
             "LES ORDRES VALBLES SONT:"),1,1)
SOS0:  IF I=2 THEN INC I
       DISPLAY(ORDR(I),1,0)
       IF INC I<NORDRS THEN GO SOS0
       DISPLAY(BI('PREPROCESS','PRETRAITMENT'),1,0)
       BOUT(CARRET); GO CMND

FREE:   NULL
       \BRS 70; \BRS 36 (,10,1)  !OUTPUT NUMBER OF FREE PAGES
       BOUT(CARRET); GO CMND

QUIT:  DICRIT
       EXIT
VENTIL:  DICRIT
       FORKTB(0)_TCOMST
       FORKTB(4)_TCORL1
       FORKTB(5)_TCORL2
       SUBGO
       GO CMND

PRETRAIT: DICRIT
       FORKTB(0)_PREST
       FORKTB(4)_PRERL1
       FORKTB(5)_PRERL2
       SUBGO
      CLOSE(BFLNO); BFLNO_0  ! BINARY FILE LEFT OPEN BY PRE
       GO CMND

EDIT:  DICRIT
       FORKTB(0)_IMPST
       FORKTB(4)_IMPRL1
       FORKTB(5)_IMPRL2
       SUBGO
       GO CMND

GENER: DICRIT
       FORKTB(0)_GENST
       FORKTB(4)_GENRL1
       FORKTB(5)_GENRL2
       SUBGO
       GO CMND

MAJ:    DICRIT

       FORKTB(0)_MAJST
       FORKTB(4)_MAJRL1
       FORKTB(5)_MAJRL2
       SUBGO
       GO CMND


DETRUIRE:  ARM(ST1)
       K_0; CLOSE(DIC)
       MOVE 16 FROM ALL 0 TO @DICVERS
  PROMPT("DO YOU WISH TO DESTROY BINARY VERSION(S) OF YOUR DATA FILE? ")
       SCAN
  IF NOT(SHORT(BI("YES","OUI"))) THEN GO DET12
       ADDSTR(@SNAME,"'BIN'",@TSTR)
       GTPT(@TSTR,@I,@J)
       IF BFLNO THEN [CLOSE(BFLNO); BFLNO_0]
       FDEL(I,J,DET11)

DET11: ADDSTR(@SNAME,"'BIN'OLD",@TSTR)
       GTPT(@TSTR,@I,@J)
       FDEL(I,J,DET12)
DET12: IF DIC THEN [CLOSE(DIC); DIC_0]
       ADDSTR(@STUDY,"'DIC'",@TSTR)
DETA:   GTPT(@TSTR,@I,@J)
       DMOD_0
      FDEL(I,J,DET1)
DET2:  NULL
       IF K THEN GO CMND ELSE K_1
       ADDSTR(@STUDY,"'INT'",@TSTR)
       IF INTRFL THEN [CLOSE(INTRFL); INTRFL_0]
       GO DETA
DET1:  NULL
       GO CMND

!
!------------------------------------------- SERVICE ROUTINES

BADDIC:  DISPLAY(BI("BAD DICTIONARY FILE", &
                 "ERREUR SYSTEME DICTIONNAIRE"),1,1)
       EXIT

!
!
!  NAME:               ESCAPE
!
!  FUNCTION:           ARMS ESCAPE AND TRAPS TO LABLE CMND:
!
!  INPUT:              NONE
!
!  OUTPUT:             NONE
!
!  ERRORS DETECTED:    NONE
!
!  ROUTINES CALLED:    NONE
!
ESCAPE:        ARM(ESCAPE)
       BUFF(0)_NEWBUF(0)_-1
       \BRS 11 (,,-1); \BRS 29
       BOUT(CARRET)
       GO CMND

!
!  NAME:               SYNERR:_(@X)
!
!  FUNCTION:           DISPLAYS MESSAGE 'ERROR AT:' FOLOWED BY
!                      THE STRING IN X
!
!  INPUT:              X = FWA OF STRING TO BE APPENDED
!
!  OUTPUT:             NONE
!
!  ROUTINES CALLED:    NONE
!  
!  ERRORS DETECTED:    NONE
!
%SYNERR(@X)

       \BRS 11 (,,-1) !CLEAR BUFFERS
       DISPLAY(BI("ERROR AT:","ERREUR A:"),0,0)
       DISPLAY(@TOKEN,0,1)
       DISPLAY(@X,0,1)
       GO CMND

END SYNERR

!
!
!      INITIALIZE QUESTION NAMES
!
%QINIT(LOW,HIGH,@QPTR)

       QCUR_LOW
QIN1:  QQCBS(QCUR,0)_1 !INITIAL VECSIZE
       QQCBS(QCUR,1)_QPTR
       INC QPTR
       QQCBS(QCUR,2)_ 0       ! UNDEFINED
       QQCBS(QCUR,3)_ 0       ! UNDEFINED

       STRNG(QCUR,@TSTR)
       ADDSTR("QUES. ",@TSTR,@QQNAME(QCUR,0))
       IF INC QCUR<= HIGH THEN GO QIN1

       RETURN

END QINIT
%DICRIT   ! WRITE DICTIONNARY IF MODIFIED
       IF DMOD THEN DO
               \BRS 113; BOUT(OCT 147)
               DWRITE(@DICVERS,16,0)
               DWRITE(QCBS,4096,QCBADR)
               \CLA; \SCP(DIC,GO BADDIC) !READ MODE
               DMOD_0
               \BRS 114; BOUT(OCT 147)
       END
       RETURN
END DICRIT
%SUBGO
       STRFRK(@FORKTB+OCT 33600000)
       IF FORKTB(6) THEN DO !I OR M TRAP
               DISPLAY("TRAP AT: ",1,0); I_0; \BRS 114
SGO1:          \BRS 36 (FORKTB(I),8,1); BOUT(CARRET)
               IF INC I<7 THEN GO SGO1
       END
       \BRS 114   ! RELEASE ESCAPE AFTER FORK RETURNS
       RETURN
END SUBGO
!
!
!      INITIALIZE FILTER NAMES
!
!
!  NAME:               BINIT
!
!  FUNCTION:           TO INITIALIZE FILTER NAMES TO DEFAULT VALUE
!
!  INPUT:              NONE
!  OUTPUT:             NONE
!
!  ERRORS DETECTED:    NONE
!
!  ROUTINES CALLED:    NONE
!
%BINIT
       I_1
L1:    STRNG(I,@TSTR)
       ADDSTR(BI("FILTER ","FILTRE "),TSTR,@QQNAME(MXQUES+I,0))
       IF INC I<=NFILTS THEN GO L1 ELSE RETURN
END BINIT

!
!  NMAE:               SHORT
!
!  FUNCTION:           RETURNS A TRUE VALUE IF -A- IS LEFT SUBSET
!                      OF GLOBAL VARIABLE -TOKEN-
!                      
!  INPUT:              -A- CONTAINS STRING TO BE TESTED
!
!  OUTPUT:             TRUE OR FALSE VALUE AS ABOVE
!
!  ERRORS DETECTED:    NONE
!
!  ROUTINES CALLED:    NONE
!
%SHORT(@A)
       LEFT(@A,LENGTH(@TOKEN),@TSTR)
       IF EQUAL(@TOKEN,@TSTR) THEN RETURN 1
       RETURN 0
END SHORT

!
!  NAME:               SHIRT
!
!  FUNCTION:           RETURNS A TRUE VALUE IF LENGTH OF STRING -A- > 3
!                      AND THE STRING CONTAINED IN A IS LEFT SUBSET OF 
!                      THAT CONTAINED IN GLOBAL VARIABLE TOKEN
!
!  INPUT:              -A- CONTAINS STRING TO BE TESTED
!
!  OUTPUT:             AS ABOVE
!
!  ERRORS DETECTED:    NONE
!
!  ROUTINES CALLED:    NONE
!
%SHIRT(@A)
       LOCAL I,II
       I_2
       II_LENGTH(@A)
       IF II < 3 THEN RETURN 0
       WHILE INC I <= II THEN DO
       LEFT(@A,I,@TSTR)
       IF EQUAL(@TOKEN,@TSTR) THEN RETURN 1
       END
       RETURN 0
END SHIRT
SURVEY ** FICHE/FRAME BREAK *****
/CPAVCOM:SIMP/ SYMSORT

SYM.  PG.LN. IDENT.

!      12  1 !       !      11 39 !       !      11 28 !       !      11 27 !       
!      11 26 !       !      11 15 !       !      10  6 !       !      10  5 !       
!      10  1 !       !       1  3 !       !       1  2 !       !!!     3 32 !       
!!!     2 39 !       !!!     2 34 !       !!!     2 31 !       !!!     2 24 !       
!!!     2 18 !       !!!     2  7 !       !!!     1 38 !       !!!     1 34 !       
!!!     1 29 !       !!!     1 19 !       !!!     1 11 !       !*****  4 27 !       
!*****  4 17 !       !DEF    3 17 !       !EF     4 18 !       !LM!   11 37 !       
!LM!   11 24 !       !LM!    9 38 !       !LM!M! 11 11 !       !LM!M! 10 15 !       
!LM!M!  9 26 !       !LMCMN  6 26 !       !LMTIM  7 15 !       !M      5 11 !       
!M      3 12 !       !M!    12  5 !       !M!    12  4 !       !M!    12  3 !       
!M!    12  2 !       !M!    11 38 !       !M!    11 31 !       !M!    11 30 !       
!M!    11 29 !       !M!    11 25 !       !M!    11 17 !       !M!    11 16 !       
!M!    11 14 !       !M!    11 13 !       !M!    10  4 !       !M!    10  3 !       
!M!    10  2 !       !M!     9 39 !       !M!     9 31 !       !M!     9 30 !       
!M!     9 29 !       !M!     9 28 !       !M!     9 27 !       !M!     5 26 !       
!M!     5 10 !       !M!     4 34 !       !M!     2  9 !       !M!     1  5 !       
!M!     1  4 !       !M!LM! 11 12 !       !M!MFI  1 16 !       !MDEF   1  6 !       
!MLOCA  2 10 !       !MST1:  4 35 !       %DICRI 10 30 !       %SUBGO 11  2 !       
------  6 10 !       -LM!--  9 20 !       ;MESCA  9 32 !       ;MMSTA  4  2 !       
;MNEWD  5 27 !       BADDIC  9 22 !       CMND1:  6 32 !       
DEF     3 34 !       DEF     3 30 !       DEF     3 29 !       DEF     3 26 !       
DEF     3 22 !       DEF     3 18 !       DEF     3 15 !       DEF     3 11 !       
DEF     3  7 !       DEF     3  6 !       DEF     3  5 !       DEF     3  4 !       
DEF     3  3 !       DEF     3  2 !       DEF     2 29 !       DEF     2 28 !       
DEF     2 27 !       DEF     2 26 !       DET11:  9  4 !       DET12:  9  7 !       
DET1:   9 17 !       DET2:   9 12 !       DETA:   9  9 !       DSP0:   6 36 !       
DSP1:   7  4 !       DSPTCH  6 35 !       EDIT:   8  9 !       END    12 15 !       
END    11 35 !       END    11 22 !       END    11 10 !       END    11  1 !       
END    10 29 !       END    10 13 !       ENDM    3 28 !       ENDM    3 25 !       
ENDM    3 21 !       ENDM    3 14 !       ENDM    3 10 !       FIND    2 22 !       
FIND    2 21 !       FIND    2 20 !       FIND    2 14 !       FIND    2  5 !       
FIND    2  4 !       FIND    2  3 !       FIND    2  2 !       FIND    2  1 !       
FIND    1 36 !       FIND    1 32 !       FIND    1 31 !       FIND    1 27 !       
FIND    1 26 !       FIND    1 25 !       FIND    1 24 !       FIND    1 23 !       
FIND    1 22 !       FIND    1 21 !       FIND    1 17 !       FIND    1 15 !       
FIND    1 14 !       FIND    1 13 !       FREE:   7 27 !       GENER:  8 16 !       
GLOBAL  2 36 !       L1:    11 19 !       LOCAL   2 32 !       LOCAL   2 16 !       
LOCAL   2 15 !       LOCAL   2 13 !       LOCAL   2 11 !       MAJ:    8 23 !       
MM%BIN 11 18 !       MM%SHI 12  6 !       MM%SHO 11 32 !       ND1:    5 34 !       
ND2:    5 36 !       ND3:    6  8 !       QIN1:  10 17 !       QUIT:   7 31 !       
SGO1:  11  5 !       SOS0:   7 21 !       SOS:    7 18 !       STIRT:  4  6 !       
STZ:    4 36 !       TABLE   3 35 !       VENTIL  7 33 !       VERSIO  1  9 !       
ZRETRA  8  1 !       ^ETRUI  8 32 !       _LM!--  4  1 !       _M%QIN 10 16 !       
_M%SYN 10  7 !       _OUTNU  4 26 !       _OUTNU  4 25 !       _OUTNU  4 23 !       
_OUTNU  4 22 !       _OUTNU  4 21 !       _OUTNU  4 20 !       _OUTNU  4 19 !       
_UTNUM  4 24 !       
SURVEY ** FICHE/FRAME BREAK *****
/CPAVEDIT:SRCE/
EDITOR IDENT 1/20/70 FIX LKF+1
*...
*...MODIFIED FOR BILINGUAL VERSION 5/74 BY B.THORNQUIST
*...
*... PARAMETER LANG =0 ENGLISH, #0 YIELDS FRENCH
*...
LANG EQU 0
   ;* 
   ;* PROMPT  CALLER:
TEMP  BSS 2
EIND  BSS 1
FIVE  DATA 5
DELTFG  BSS 1
LASTFG  BSS 1
TTYIN  BSS 1
EOFLOC DATA 0

GO    POPD  100B5,2
       BRU* 0
XCIO MACRO D
       SKE EOLIT; BRU *+3; TCO CARRET; BRU *+2; CIO ONE
     ENDM
XTCI MACRO D
       CIO CFLNO; STA D(1); SKE =155B; BRU *+3; LDA EOLIT; STA D(1)
       ENDM


BRS35   STP TEMP; GCI TMP; BRR 0; SKA =@77B; BRR 0
       XCIO ONE; BRU BRS35+1
RETURN  LDA =377B; WCH NBWCH; LDX =-BUFSIZE; LDA NEWBUF+BUFSIZE,2
        STA BUFF+BUFSIZE,2; BRX *-2; BRR GETSTR



   ;*
$GETSTR  ZRO 0
   ;* ; LDA =ERRTOO; STA NBOVFL
   ;* 
GTSRA  LDA =NEWBUF; BRM LENGTH (GET LENGTH OF BUFFER); STA NBGCI+1
       LDA NBFF; STA NBGCI; ADM NBGCI+1
       LDP OBFF; STP OBGCI; STA OBSAV
   ;* MOVE NEW BUF TO OLD BUF; GCI NBGCI; BRU *+3; WCI OBGCI; BRU *-3
   ;* CLEAR NEWBUF FOR WCH; LDP NBFF; STP NBGCI
   ;* SET FLAGS; CLA; STA EIND INSERT MODE FLAG
   ;* READ INITIAL INPUT CHAR; XTCI CHAR; LDB MINUS1 ; STB TTYIN; SKN EOFLOC
   ;* 
GTSA  SKG =172B; SKG =140B; BRU CPUT NOT A CONTROL
   ;* CONTROL CHAR HAS BEEN ENTERED:; COPY AX,AB; LDA CCT-141B,2
   SKN EIND; BRU GTSB
   ;* WE ARE IN INSERT MODE; SKA K1B6; BRU GTSB
  HIS FUNCTION MUST TURN OFF INSERT MODE
TNOFF  MIN EIND ; TCO =36B; LDB NBFF; STB NBGCI; LDB OBFF; STB OBSAV
   ;* 
GTSB  COPY XA,AX
   ;* EXECUTE THE CONTOL FUNCTION; BRU 0,2
   ;* NON CONTROL CHAR WAS INPUT, APPEND TO NEWBUF
CPUT  WCH NBWCH; SKN EIND
   ;* NOT IN INSERT MODE, REMOVE CORRESPONDING CHAR FORM ODDBUF
   MIN OBGCI;*  ; SKE EOLIT ; BRU CGET; BRU RETURN
   ;* 
   ;* READ NEXT CHAR
CGET  XTCI CHAR; BRU GTSA
   ;* 
   ;* 
CCT  DATA ACTRL+1B6; DATA RING+1B6,CCTRL,DCTRL,ECTRL+1B6
   DATA FCTRL,CPUT+1B6,HCTRL,ICTRL+1B6
   DATA CPUT+1B6,KCTRL,RING+1B6,CPUT+1B6
   DATA NCTRL,OCTRL,PCTRL,QCTRL+1B6
   DATA RCTRL,SCTRL,TCTRL,UCTRL,VCTRL+1B6
   DATA WCTRL+1B6,XCTRL,YCTRL,ZCTRL;*  
   ;* 
   ;* 
   ;* ILLEGAL CONTROL FUNCTION, RING BELL
RING  TCO K147B; BRU CGET
   ;* 
   ;* 
   ;* BACKSPACE NEW, PRINT BACKARROW
ACTRL  GCD NBGCI; BRU RING; TCO K77B; BRU CGET
   ;* 
   ;* COPY 1 CHAR FROM OLD TO NEW AND PRINT IT
CCTRL  GCI OBGCI; BRU RING; WCH NBWCH; XCIO ONE ; SKE EOLIT ; BRU CGET
   BRU RETURN;*  COPY REST OF OLD TO NEW, PRINTING
DCTRL  GCI OBGCI; BRU RING
DCTA  WCH NBWCH; XCIO ONE ; SKE EOLIT ; GCI OBGCI; BRU GEXIT; BRU DCTA
   ;* EXIT AFTER CONFIRMING C.R.
GEXIT  SKE EOLIT ; BRU *+2; BRU RETURN; LDA EOLIT ; WCH NBWCH; XCIO ONE 
   BRU RETURN;*  CHANGE INSERT MODE, PRINTING OPEN OR CLOSE BROCKET
ECTRL  SKN EIND; BRU ECTA
   ;* TURN INSERT MODE OFF; LDA =CGET; BRU TNOFF
   ;* TURN INSERT MODE ON
ECTA  LDA MINUS1 ; STA EIND
   ;* TEMPORARILY DELETE CURRENT NEW AND OLD; LDA NBWCH; STA NBGCI
   LDA OBGCI; STA OBSAV; TCO =34B LESS (OPEN BROCKET); BRU CGET
   ;* 
   ;* COPY OLD TO NEW, NO PRINTING
FCTRL  GCI OBGCI; BRU RING
FCTA  WCH NBWCH; GCI OBGCI; BRU GEXIT; BRU FCTA
   ;* COPY OLD TO NEW, PRINTING UPTO BUT NOT INCLUDING C.R.
HCTRL  GCI OBGCI; BRU RING
HCTB  SKE EOLIT  C.R.; BRU HCTA
   ;* WE HAVE JUST REMOVED C.R. FROM OLD, PUT IT BACK AND EXIT
   SKR OBGCI; BRU CGET
   ;* 
HCTA  WCH NBWCH; XCIO ONE ; GCI OBGCI; BRU CGET; BRU HCTB
   ;* APPEND BLANKS TO NEW TO THE NEXT TAB, DELETE CORRESPONDING CHARS
   ;* FROM OLD UNLESS INSERT MODE
ICTRL  GO FINTAB
ICTA  SKN EIND; GCI OBGCI; CLA; CLA; WCH NBWCH; TCO ZERO; BRX ICTA
   BRU CGET;*  
   ;* 
   ;* 
FINTAB  LDA NBWCH; SUB NBFF
   ;* NO OF CHAR IN NEWBUF NOW IN A; LRSH 23; DIV SIX; COPY BA; SUB SIX
   COPY AX; BRR 0
   ;* 
   ;* DELETE CHAR FROM OLD, PRINT IT
KCTRL  GCI OBGCI; BRU RING; XCIO ONE ; BRU CGET
   ;* BACKSPACE OLD AND NEW LINES ONE CHAR, PRINT BACK ARROW
NCTRL  LDA OBGCI; SKG OBFF; BRU RING; SKR OBGCI; BRU ACTRL
   ;* 
   ;* 
   ;* 
   ;* 
   ;* COPY TO BEFORE NEXT INPUT CHAR
OCTRL  LDA MINUS1 ; CLB
   ;* 
   ;* 
   ;* 
   ;* SEEK NEXT INPUT CHAR IN OLD AND PROCESS:
   ;* 
   ;*       DELTFG: 0=DELETE PASSED CHARS, -1=COPY
   ;*       LASTFG: 0=EXCLUDE MATCHED CHAR, -1=INCLUDE
   ;* 
   ;* 
   ;* 
CHMTCH  STA DELTFG; STB LASTFG; LDP OBGCI; SKN LASTFG; ADD ONE; STP TMPT
   ;* SET TO NO ECHO; LDX MINUS1 ; LDA THREE ; BRS 12
   ;* READ IN CHAR TO BE MATCHED; XTCI CHAR
   ;* RESET ECHO; LDA TWO ; BRS 12
   ;* FIND A MATCH; GCI TMPT; BRU RING; SKE CHAR; BRU *-3
   ;* SET BUFF POINTER; LDA TMPT; SKN LASTFG; SUB ONE; STA OBWCH
   ;* PROCESS AFFECTED CHARS; SKN DELTFG; BRU CHMA
   ;* COPY AFFECTED CHARS;CHMT1 GCI OBGCI; BRU CHMB; WCH NBWCH; XCIO ONE 
   SKE EOLIT ; BRU CHMT1; BRU RETURN
   ;* 
   ;* DELETE AFFECTED CHARS
CHMA  GCI OBGCI; BRU CHMB; TCO FIVE PERCENT; BRU *-3
   ;* FIXUP OLD POINTER
CHMB  LDA TMPT1; STA OBWCH; BRU CGET
   ;* 
   ;* DELETE TO BEFORE GIVEN CHAR
PCTRL  COPY A,B; BRU CHMTCH
   ;* START BUFF AND NEWBUF BOTH AT BEGINNING
QCTRL  LDA NBGCI; STA NBWCH; LDA OBSAV; STA OBGCI; TCO =76B UP ARROW
       TCO CARRET
       TCO =152B  LINE FEED
   BRU CGET
   ;* 
   ;* 
   ;* *PRINT A LINE FEED, THE REST OF OLD, THE C.R., THEN CURRENT NEW.
   ;* 
RCTRL  TCO =102B
RCTA  LDP OBGCI; GO BRS35
   ;* PRINT C.R.; LDP NBGCI ;  GO BRS35; BRU CGET
   ;* 
   ;* 
   ;* 
   ;* DELETE CHAR FROM OLD AND PRINT PERCENT
SCTRL  GCI OBGCI; BRU RING; TCO FIVE; BRU CGET
   ;* 
   ;* TYPE REST OF OLD, THEN NEW SO-FAR, LINED UP
   ;* 
TCTRL  LDA NBGCI; SUB NBWCH; COPY AX,A
   ;TCTRL1 XCIO ONE; BRX TCTRL1; BRU RCTA
   ;* COPY OLD TO NEW UP TO NEXT TAB, PRINTING
UCTRL GO FINTAB; GCI OBGCI; BRU RETURN; WCH NBWCH; XCIO ONE; BRX UCTRL+1
   BRU CGET;*  
   ;* 
   ;* 
   ;* ALLOW FOLLOWING CHAR TO BE TAKEN LITERALLY
VCTRL  CIO CFLNO; STA CHAR; BRU CPUT
   ;* 
   ;* BACKSPACE NEW LINE TO LAST SPACE BEFORE LAST NON-SPACE
WCTRL  TCO =74B; GCD NBGCI; BRU RING; SKE ZERO; BRU *+2; BRU *-4
   ;* FIND PRIOR SPACE; GCD NBGCI; BRU RING; SKE ZERO; BRU *-3
   ;* PUT IT BACK ON; WCH NBWCH; BRU CGET
   ;* 
   ;* 
   ;* DELETE OLD LINE TO GIVEN CHAR, PRINTING PERCENTS
XCTRL  CLA; LDB MINUS1 ; BRU CHMTCH
   ;* 
   ;* TYPE C.R., THEN COPY REST OF OLD TO NEW, THEN MAKE NEW OLD.
   ;* AND LCEAR NEW, WITHOUT PRINTING
YCTRL  TCO CARRET; GCI OBGCI; BRU YCTRLA; WCH NBWCH; BRU *-3
YCTRLA LDA EOLIT; WCH NBWCH; BRU GTSRA  (PATCH FOR EOLIT AT END OF NBUFF)
   ;* COPY OLD TO NEW UPT TO GIVEN HAR
ZCTRL  LDA MINUS1 ; COPY AB; BRU CHMTCH

ERRTOO LDA =TBIG; LDB =-1; LDX =1; BRS 34; BRU RETURN

  IF LANG=0
TBIG ASC '$LINE TOO LONG$/'
  ELSE
TBIG   ASC '$LIGNE TROP LONGUE$/'
   ENDF

OBFF   DATA 3*BUFF-1,3*BUFF-1
NBFF   DATA 3*NEWBUF-1,3*NEWBUF-1

OBGCI  BSS 1
OBWCH  BSS 1
OBSAV  BSS 1

NBGCI  BSS 1
NBWCH  BSS 1
NBLIM  DATA 3*NEWBUF+3BUFS
NBOVFL BRU  ERRTOO
NBSAV  BSS 1

BUFSIZE EQU 100


CARRET DATA 155B
EOLIT  DATA 377B
K144B  DATA 144B
ONE    DATA 1
ZERO   DATA 0


MINUS1 DATA -1
K147B   DATA 147B
K1B6    DATA 1B6
K77B    DATA 77B
SIX    DATA 6
THREE  DATA 3
TMPT  BSS 1
TMPT1 BSS 1
TWO DATA 2
CHAR BSS 1
TMP  BSS 1
3BUFS  EQU 3*BUFSIZE-1
  END
SURVEY ** FICHE/FRAME BREAK *****
/CPAVEDIT:SRCE/ SYMSORT

SYM.  PG.LN. IDENT.

3BUFS   7  7 EDITOR  ACTRL   2 39 EDITOR  BRS35   1 28 EDITOR  
BUFSIZ  6 25 EDITOR  CARRET  6 28 EDITOR  CCT     2 26 EDITOR  CCTRL   3  3 EDITOR  
CGET    2 23 EDITOR  CHAR    7  5 EDITOR  CHMA    4 30 EDITOR  CHMB    4 32 EDITOR  
CHMTCH  4 19 EDITOR  CPUT    2 18 EDITOR  DCTA    3  6 EDITOR  DCTRL   3  5 EDITOR  
DELTFG  1 13 EDITOR  ECTA    3 13 EDITOR  ECTRL   3 10 EDITOR  EIND    1 11 EDITOR  
EOFLOC  1 16 EDITOR  EOLIT   6 29 EDITOR  ERRTOO  6  4 EDITOR  FCTA    3 19 EDITOR  
FCTRL   3 18 EDITOR  FINTAB  3 34 EDITOR  FIVE    1 12 EDITOR  GETSTR  1 36 EDITOR  
GEXIT   3  8 EDITOR  GO      1 18 EDITOR  GTSA    2  8 EDITOR  GTSB    2 15 EDITOR  
GTSRA   1 39 EDITOR  HCTA    3 26 EDITOR  HCTB    3 22 EDITOR  HCTRL   3 21 EDITOR  
ICTA    3 30 EDITOR  ICTRL   3 29 EDITOR  K144B   6 30 EDITOR  K147B   6 36 EDITOR  
K1B6    6 37 EDITOR  K77B    6 38 EDITOR  KCTRL   3 39 EDITOR  LANG    1  7 EDITOR  
LASTFG  1 14 EDITOR  MINUS1  6 35 EDITOR  NBFF    6 13 EDITOR  NBGCI   6 19 EDITOR  
NBLIM   6 21 EDITOR  NBOVFL  6 22 EDITOR  NBSAV   6 23 EDITOR  NBWCH   6 20 EDITOR  
NCTRL   4  2 EDITOR  OBFF    6 12 EDITOR  OBGCI   6 15 EDITOR  OBSAV   6 17 EDITOR  
OBWCH   6 16 EDITOR  OCTRL   4  8 EDITOR  ONE     6 31 EDITOR  PCTRL   4 35 EDITOR  
QCTRL   4 37 EDITOR  RCTA    5  7 EDITOR  RCTRL   5  6 EDITOR  RETURN  1 30 EDITOR  
RING    2 35 EDITOR  SCTRL   5 13 EDITOR  SIX     6 39 EDITOR  TBIG    6  9 EDITOR  
TBIG    6  7 EDITOR  TCTRL   5 17 EDITOR  TEMP    1 10 EDITOR  THREE   7  1 EDITOR  
TMP     7  6 EDITOR  TMPT    7  2 EDITOR  TMPT1   7  3 EDITOR  TNOFF   2 13 EDITOR  
TTYIN   1 15 EDITOR  TWO     7  4 EDITOR  UCTRL   5 20 EDITOR  VCTRL   5 25 EDITOR  
WCTRL   5 28 EDITOR  XCIO    1 20 EDITOR  XCTRL   5 34 EDITOR  XTCI    1 23 EDITOR  
YCTRL   5 38 EDITOR  YCTRLA  5 39 EDITOR  ZCTRL   6  2 EDITOR  ZERO    6 32 EDITOR  

SURVEY ** FICHE/FRAME BREAK *****
/CPAVGEN:SIMP/
!!! GEN MAIN
! WRITTEN BY CARLA BARASZ
! JUNE 27,1972
!
! ROUTINE CONVERTED TO BILINGUAL VERSION 5/74 BY B.THORNQUIST
!
DEF BI(ENGLISH,FRENCH) AS ENGLISH


!
! VERSION 74137 WARNS USER IF HE HAS NOT SAVED HIS PROGRAM BEFORE EXIT
!
       TABLE &
VERSION ["GEN 74137"]

       FIND CFLNO    ! COMMANDS FILE NUMBER OR 0
       FIND %SWAPIN,%INITIAL,RL1,RL2,NMPAGE,QCBPAGE
       FIND LIB(),QNAME(),QCBS()
       FIND SNAME(0:1),PRESTR,PRERL1,PRERL2,%STRFR1
       LOCAL BFNAME(0:15)
       LOCAL KSVFL
       GLOBAL FORK2(0:6)
       GLOBAL %SHORT
       FIND BFLNO,SFLNO
       FIND OUTFLG,ERRFLG,QNRADR,QNRREC(),DNM(0:1),XQNRREC,XFLTREC,FLTREC
       FIND ERREC(0:1),FLTCNT(0:1),TMPREC(0:1)
       GLOBAL ECNT,RETCNT,MAXREC,EOFFLG,GFLNO,LSTADR,POLPG,SAVRL2
       GLOBAL NRREC,PAGE,LBPAGE
       FIND BUFF(0:1),NEWBUF(0:1)  !COMMAND BLOCKS!
       FIND VALUE,TYPE,TOKEN(0:24),CURPOS
       FIND POLADR,NOGO
        GLOBAL TSTR(0:24),NUMREC,RUNFLG

       GLOBAL ESCAPE:,BADDIC:,GTFL:,BADDFL:,PROG:
       GLOBAL POLRET:
LOCAL P,P1,P2
       LOCAL EOF:
       FIND %BCLOS,%BERX,%BOUT,%OUTNO
       FIND %SCAN,%READ,%DISPLAY,%EQUAL,%TRNSTR,%LENGTH,%GETSTR
       FIND %LEFT,%ARM,%ADDSTR,%GTPT,%RETESC
       GLOBAL %YES,%BINOPN,%READREC,%RENAME

       LOCAL TEL,FILIN
       LOCAL J,FLNO
       LOCAL PT1,PT2
       LOCAL %FSCAN,%XSAVE,%FOPEN,%XLOAD,%GETRNG


!DICTIONNARY VARIABLES!

       FIND DICVERS,NQUES,CDPLST,CDPLND,LLBPLST,LLBPLND,QCBADR
       GLOBAL BNAMADR
       FIND NAMADR,QSIZE,QVERS
       FIND DIC

       FIND %COMPIL

DEF SETADR BY
XFLTREC_1+XQNRREC_QNRREC+OCT 20000000
FLTREC_QNRREC+1
ENDM SETADR
DEF MAXERR AS 199
DEF MAXTMP AS 199
DEF NBASES AS 48
DEF ERMAX AS 7
DEF BADTYPE AS 0
DEF ANTYPE  AS 1
DEF NUMTYPE AS 2
DEF SYMTYPE AS 3
DEF RESTYPE AS 4
DEF EOLTYPE AS 5
DEF QUSTYPE AS 6
DEF FILTYPE AS 7
DEF FICTYPE AS 8

DEF QNAMADR AS 12
DEF BIN AS 2
DEF SYM AS 3
DEF SORTIE AS 0
DEF ENTREE AS 1
DEF PROMPP(X) BY
       DISPLAY(X,1,0)
       READ(@TEL)
ENDM PROMPP

DEF PROMPT BY
DISPLAY(BI("FILE: ","FICHIER: "),0,0); READ(@TEL); FSCAN
ENDM PROMPT
DEF CLOSE(X) AS \BRS 20 (X)
DEF OPENI(P1,P2,BAD,FILE) BY
       \BRS 64 (P1,P2,GO BAD); \STA (FILE)
ENDM OPENI
DEF OPENO(P1,P2,BAD,FILE,TYPE) BY
       \BRS 65 (P1,P2,TYPE,GO BAD); \STA (FILE)
ENDM OPENO
!DEF OUTNO(X) AS \BRS 36 (X,10,1)




!!!!!!!!!!!
!BEGIN PROG
!!!!!!!!!!!



       FIND MAXRNG(1)
       FIND MXPOOL(0:1)
       FIND PDIC(0:1),POOL(1:2)
       LOCAL FREE,K,I,R1NG,R2NG,EDMOD,DOT
       DEF MXCCS AS 9
    TABLE CCS(1:MXCCS)[BI("RUN","TRAITER"),BI("LIST","LISTER"),"DELETE", &
     "SAVE","LOAD","EDIT",BI("MODIFY","MODIFIER"),"QUIT",BI("HELP","SOS")]


!
! INITIALIZE FLAG TO SHOW THAT NO FILE HAS BEEN WRITTEN
!
       KSVFL_0
PROG: \BRS 113 !PREVENT ESCAPES UNTIL ALL OK!
!      DISPLAY(VERSION,1,2)
       FREE_1
       I_0
LL:    PDIC(I)_0; IF INC I<=MAXRNG THEN GO LL
       TEL_FILIN_0
       INITIAL
       \BRS 114



INPUT: \BRS 114
       IF FILIN=0 THEN [BOUT($G);BOUT($>)]; READ(@FILIN,EOF)
       SCAN
       IF TYPE=EOLTYPE THEN GO INPUT
       IF TYPE = NUMTYPE THEN DO
               IF VALUE >MAXRNG THEN  &
        [BCLOS; DISPLAY(BI("INCORRECT LINE NUMBER", &
                "NUMERO DE LIGNE INCORRECT"),0,1); BERX; GO INPUT]
               IF PDIC(VALUE) THEN DO !THERE WAS ALREADY A LINE HERE
                   IF LENGTH(@BUFF)<=LENGTH(@POOL(PDIC(VALUE)))THEN DO
                       TRNSTR(@BUFF,@POOL(PDIC(VALUE)))
                       GO INPUT
                   END
               END
       IF MXPOOL-FREE<=LENGTH(@BUFF)/3 THEN GO OFPOOL
               PDIC(VALUE)_FREE
       TRNSTR(@BUFF,@POOL(FREE))
       FREE_FREE+LENGTH(@BUFF)/3 +1
       GO INPUT
       END
       IF TYPE # ANTYPE THEN GO IERR
       K_1
       INL:    LEFT(CCS(K),LENGTH(@TOKEN),@TSTR)
               IF EQUAL(@TSTR,@TOKEN) THEN DO
               DO K OF MXCCS
       1: GO TRAITER
       2:    GO LIST
       3: GO DELT
       4: GO SAVE
       5: GO LOAD
       6: EDMOD_1; GO EDIT
       7:EDMOD_0; GO EDIT
       8: GO FINIR
       9: GO SOS
               END
               END
       IF INC K <= MXCCS THEN GO INL
       GO IERR


OFPOOL:  DISPLAY(BI("TEXT OVERFLOW","DEPASSEMENT DE CAPACITE DU TEXT"),2,2)
       IF FILIN THEN GO EOF ELSE GO INPUT

EOF:   CLOSE(FILIN); FILIN_0; GO INPUT

       LIST:   SCAN; IF TYPE=EOLTYPE THEN DO
           R1NG_0; R2NG_MAXRNG
       END ELSE DO
           GETRNG
           IF R1NG<0 !ERROR IN LINE RANGE! THEN GO INPUT
           IF TYPE#EOLTYPE THEN GO IERR !GARBAGE AT END!
       END

       LIS1T:   IF PDIC(R1NG) THEN DISPLAY(@POOL(PDIC(R1NG)),1,0)
               IF INC R1NG <=R2NG    THEN GO LIS1T
               BOUT(CARRET); GO INPUT

EDIT:  SCAN
       GETRNG
       IF R1NG<0 THEN GO INPUT !BAD LINE RANGE
       IF TYPE # EOLTYPE THEN GO IERR

       EDI2T: IF PDIC(R1NG) =0 THEN GO EDI1T
               IF EDMOD THEN DISPLAY(@POOL(PDIC(R1NG)),1,1)
               TRNSTR(@POOL(PDIC(R1NG)),@NEWBUF)
               GETSTR; CURPOS_CHPT(@BUFF,-1)
               SCAN
               IF TYPE=EOLTYPE THEN DO
                               PDIC(R1NG)_0
                               GO EDI1T
               END
               IF TYPE#NUMTYPE OR VALUE>MAXRNG THEN DO
                       BCLOS;  DISPLAY(BI("INCORRECT LINE NUMBER", &
                                "NUMERO DE LIGNE INCORRECT"),0,1)
                       BERX
                               GO EDI2T
               END
     IF PDIC(VALUE) AND LENGTH(@BUFF)<= LENGTH(@POOL(PDIC(VALUE))) THEN DO
                               TRNSTR(@BUFF,@POOL(PDIC(VALUE)))
                               GO EDI1T
               END
               IF MXPOOL-FREE<=LENGTH(@BUFF)/3 THEN GO OFPOOL
               PDIC(VALUE)_FREE
               TRNSTR(@BUFF,@POOL(FREE))
               FREE_FREE+LENGTH(@BUFF)/3+1
               GO EDI1T

       EDI1T:  IF INC R1NG<= R2NG THEN GO EDI2T
               BOUT(CARRET); GO INPUT


       DELT:   SCAN
       GETRNG
       IF R1NG<0 THEN GO INPUT !BAD LINE RANGE!
       IF TYPE#EOLTYPE THEN GO IERR !GARBAGE AT END!

       DEL2T: PDIC(R1NG)_0
               IF INC R1NG<=R2NG THEN GO DEL2T

               GO INPUT

       DEL1T:  IERR:  DISPLAY(BI("ERROR IN SYNTAX",  &
                      "ERREUR DE SYNTAXE"),0,1)
               GO INPUT


SAVE:   XSAVE; GO INPUT

LOAD:  XLOAD; GO INPUT



!
!
!      COMPILE AND RUN USER PROGRAM
!
TRAITER: SCAN
       IF TYPE#EOLTYPE THEN DO
               IF TYPE#NUMTYPE THEN GO IERR
               IF VALUE<1 THEN GO IERR
               MAXREC_VALUE-1
       END ELSE MAXREC_-1
         COMPIL
       IF NOGO THEN GO INPUT
GTFL:  NULL
!      \BRS 113
       IF BINOPN THEN [BOUT(CARRET); GO INPUT]
!      RUNFLG_1    SPECIAL ESCAPE PROCESSING
!      \BRS 114
!!!  SWAP OUT TEXTPAGE
       \BRS 43; \STP (RL1); SAVRL2_RL2; POLPG_BYT(RL2,6,12)
       RL2_POLPG*OCT 10000; \BRS 44(RL1,RL2)

       MOVE MAXERR FROM ALL 0 TO @ERREC(1)
       MOVE MAXTMP FROM ALL 0 TO @TMPREC(1)
       MOVE NBASES FROM ALL 0 TO @FLTCNT(1)
       NRREC_0
       EOFFLG_RETCNT_0
       QNRREC_OCT 34002 ! PASS VERSION WORDS
       SETADR
       \BIO (BFLNO,2048,,14336,GO EOF11); \STA (LSTADR)
       GO RCLP
EOF11: \STA (LSTADR); EOFFLG_1


RCLP:  NULL

!
!      READ IN DATA BLOCK
!
INREC: IF BYT(NRREC+1,4,0)=0 THEN DO
               IF RETCNT>=72 THEN [BOUT(CARRET);RETCNT_0]
               BOUT($')
               INC RETCNT
       END
       READREC

       ERRFLG_0
       GO^ POLADR

POLRET: IF ERRFLG THEN DO
             ECNT_0
             BOUT(CARRET)
             BOUT($N)
             OUTNO(QNRREC(0))
             BOUT(CARRET)
             K_1
        OERR: IF ERREC(K) THEN DO
                ECNT_ECNT+1
                IF ECNT>ERMAX THEN [BOUT(CARRET); ECNT_0]
                DISPLAY("     ",0,0)
                OUTNO(K)
            END
            IF INC K<=MAXERR THEN GO OERR
               BOUT(CARRET)
       END
!   READREC ROUTINE WILL TAKE CARE OF WRITING OUTPUT RECORDS
!   EXCEPT THE LAST ONE



       IF INC NRREC<= MAXREC THEN DO
             QNRREC_QNRREC+QSIZE
             SETADR
             GO RCLP
       END
       IF OUTFLG THEN DO
               \BIO(GFLNO,QNRREC+QSIZE-OCT 30000,,OCT 30000,GO OUTERR)
       END
       \BRS 113
       CLOSE(BFLNO); BFLNO_0
       IF OUTFLG THEN DO
            CLOSE(GFLNO); GFLNO_0
               ADDSTR(@BFNAME,"OLD",@TSTR)
               IF RENAME(@BFNAME,@TSTR) THEN GO NOREN
               IF RENAME("GEN'OUTPUT'",@BFNAME) THEN GO NOREN
               DISPLAY(BI("YOUR OLD BINARY FILE IS NOW NAMED: ", &
                "VOTRE ANCIEN FICHIER BINAIRE EST SOUS LE NOM: "),1,1)
               DISPLAY(@TSTR,0,0)
               DISPLAY(BI("DO YOU WISH TO SAVE IT? ", &
                "DESIREZ-VOUS LE CONSERVER? "),1,0)
               IF NOT YES THEN DO
                               GTPT(@TSTR,@P1,@P2)
                               \BRS 48(P1,P2,GO NODEL);\BRS 69(GO NODEL)
               END
       END
       GO RENOK
NOREN: NODEL:  DISPLAY(BI("RENAMING ERROR","ERREUR DU RENAME"),1,1); GO RENOK
RENOK: \BRS 43; \STP (RL1); [12,6,6]*[P,P1,P2]_RL2
       \BRS 121(P1); \BRS 121(P2); RL2_SAVRL2
       \BRS 44(RL1,RL2)
       RUNFLG_0
       \BRS 114

!!! ABOVE RELEASES DATA BUFFERS AND BRINGS IN TEXT PAGE


       K_1
PFTL: IF FLTCNT(K) THEN DO
          DISPLAY(BI("FILTER","FILTRE"),1,0)
          OUTNO(K); DISPLAY(": ",0,0); OUTNO(FLTCNT(K))
       END
       IF INC K<= NBASES THEN GO PFTL
       DISPLAY(BI("NUMBER OF RECORDS PROCESSED ",  &
               "NOMBRE D'ENREGISTREMENTS TRAITES: "),1,0)
       OUTNO(NRREC)
       BOUT(CARRET); BOUT(CARRET)
       GO INPUT

OUTERR: BCLOS;  DISPLAY(BI("ERROR IN OUTPUT FILE",  &
         "ERREUE DANS FICHIER DE SORTIE"),1,1)
       DISPLAY(BI("ABORTED","ANNULE"),0,1)
       BERX
       EXIT

BADDIC: DISPLAY(BI("ERROR IN DICTIONARY FILE",  &
          "ERREUR DANS FICHIER DICTIONNAIRE"),1,1)
       BCLOS
       DISPLAY(BI("ABORTED","ANNULE"),0,1)
       BERX
       EXIT

ESCAPE: ARM(ESCAPE)
       \BRS 113
       \BRS 11 (,,-1); \BRS 29
       IF NOT RUNFLG THEN GO ESS1
       DISPLAY(BI("CONTINUE? ","CONTINUER? "),1,0)
       IF YES THEN [DISPLAY(BI("I'LL TRY","JE VAIS ESSAYER"),0,1); &
                       \BRS 114;RETESC]
       RUNFLG_0
       DISPLAY(BI("JOB ABORTED","TRAITEMENT ANNULE"),1,0)
       IF GFLNO THEN DO
             CLOSE(GFLNO)
               GTPT("GEN'OUTPUT'",@PT1,@PT2)
               \BRS 48(PT1,PT2,GO OUTERR);\BRS 69(GO OUTERR)
       END
       IF BFLNO THEN  CLOSE(BFLNO)
       GFLNO_BFLNO_0
       GO RENOK
ESS1:  IF FILIN THEN [CLOSE(FILIN); FILIN_0]
       BUFF(0)_NEWBUF(0)_-1
       \BRS 114
       BOUT(CARRET); GO INPUT


BADDFL: BCLOS;  DISPLAY(BI("ERROR IN DATA FILE","ERREUE DANS FICHIER DE DONNEES"),1,1)
       DISPLAY(BI("ABORTED","ANNULE"),0,1)
       BERX
        EXIT




       TABLE SIX[6]
!
! CHECK TO IF PROGRAM HAS BEEN SAVED
!
FINIR: IF KSVFL=1 THEN GO FINI1
 DISPLAY(BI("PROGRAM NOT SAVED. OK? ","PROGRAMME PAS CONSERVE'. OK?"),0,0)
       IF YES THEN GO FINI1
       SCAN
       KSVFL_1
       IF SHORT(BI("YES","OUI")) THEN GO FINI1
       GO INPUT

FINI1: \BRS 113; \BRS 43;  \LSH (^SIX,0); \BRS 121; \LSH (^SIX,0); \BRS 121
       \BRS 121(LBPAGE)
       EXIT  ! RELEASE SCRATCH PAGES 4 AND 5

SOS:  DISPLAY(BI("VALID COMMANDS ARE:","LES ORDRES VALABLES SONT:"),1,2)
       I_1
S01:   DISPLAY(CCS(I),0,1)
       IF INC I<=MXCCS THEN GO S01
       GO INPUT

!SUBROUTINES!



!
!
!      SAVE USER PROGRAM
!
%XSAVE

! TURN ON PROGRAM SAVED FLAG
       KSVFL_1
       FOPEN(SORTIE,SYM)

       K_0
XS1:   IF PDIC(K)=0 THEN GO XS3
       J_CHPT(@POOL(PDIC(K)),-1)
       XS2:  I_NCHV(J)
               IF I=EOLIT THEN DO
                    \CIO (FLNO,CARRET)
                    GO XS3
               END
       \CIO(FLNO,I)
       GO XS2
XS3:   IF INC K <= MAXRNG THEN GO XS1
       CLOSE(FLNO)
       RETURN
END XSAVE

!
!  NAME:              FOPEN(IOTYPE,FTYPE)
!
!  FUNCTION:          SCANS BUFF FOR VALID FILE NAME, IF FOUND ATTEMPTS
!                     TO OPEN IT.
!
!  INPUT:             IOTYPE = TYPE OF FILE (INPUT,OUTPUT)
!                     FTYPE  = COMMAND FILE NO. (WILL SUPPRESS
!                     'OLD FILE, NEWFILE' MESSAGE IF NON-ZERO.
!
!  OUTPUT:            NONE
!
!  ROUTINES CALLED:   DISPLAY,OPENI,OPENO
!
!  ERRORS DETECTED:   BRANCHES TO LABEL -INPUT- IF BAD FILE NAME
!
%FOPEN(IOTYPE,FTYPE)

       LOCAL FO3:,PT1,PT2
       FSCAN
       FO1:    IF TYPE=EOLTYPE THEN DO
               FO2: NULL
                   PROMPT
                    GO FO1
               END
               IF TYPE#FICTYPE THEN DO
               FO3: DISPLAY(BI("INCORRECT FILE","FICHIER INCORRECT"),1,1); &
                 GO INPUT
               END
       PT1_CHPT(@TOKEN,-1)
       PT2_PT1+LENGTH(@TOKEN)
       LOCAL LSHIF
       LSHIF_OCT 10000
       IF CFLNO THEN LSHIF_1
       IF IOTYPE=SORTIE THEN DO
            OPENO(PT1,PT2,FO3,FLNO, FTYPE*LSHIF)
       END ELSE DO
            OPENI(PT1,PT2,FO3,FLNO)
       END
       DISPLAY("OK.",0,1)
       RETURN
END FOPEN

%XLOAD

       FOPEN(ENTREE,SYM)
       FILIN_FLNO<==0
       RETURN

END XLOAD

!
%GETRNG

       GR1:    IF TYPE=ANTYPE THEN DO
                   IF EQUAL(@TOKEN,"ALL") THEN DO
                       R1NG_0
                       R2NG_MAXRNG
                       SCAN; RETURN
                   END
                   GO BADRNG
               END
               IF TYPE=EOLTYPE THEN DO
                   DISPLAY(BI("LINES","LIGNES:"),0,0)
                   READ(@TEL); SCAN; GO GR1
               END
               IF TYPE#NUMTYPE OR VALUE>MAXRNG THEN GO BADRNG
               R1NG_VALUE; SCAN
               IF TYPE=EOLTYPE THEN [R2NG_R1NG;RETURN]
               IF EQUAL(@TOKEN,"TO") THEN GO GRB
               IF CHV(CHPT(@TOKEN))#$- THEN GO BADRNG
GRB:           SCAN
           IF TYPE#NUMTYPE OR VALUE<R1NG OR VALUE>MAXRNG THEN GO BADRNG
               R2NG_VALUE
               SCAN; RETURN

BADRNG:    R1NG_-1
               BCLOS
           DISPLAY(BI("INCORRECT LINE NUMBER(S)", &
            "LIGNES INCORRECTES"),1,1); BERX; RETURN
END GETRNG
!
!  NAME:              FSCAN
!
!  FUNCTION:          TO SCAN FOR A VALID FILE NAME IN THE GLOBAL
!                     VARIABLE -TOKEN-.
!
!  INPUT:             STRING TO BE TESTED IN TOKEN
!
!  OUTPUT:            TYPE CODE IN VARIABLE -TYPE-
!  
!  ERRORS DETECTED:   NONE
!
!  ROUTINES CALLED:   GETCAR
!
%FSCAN

       FIND %GETCAR
       LOCAL TEMP,TK1PT
      FIND CARTYPE,TKPT,CURCAR

       TK1PT_TKPT_CHPT(@TOKEN,-1)
SF0:   GETCAR
       IF CURCAR=$  THEN GO SF0
       IF CURCAR=EOLIT THEN [TYPE_EOLTYPE;RETURN]
SF1:    IF CURCAR=$/ OR CURCAR=$' THEN GO SF2
       IF CURCAR=$ OR CURCAR=EOLIT THEN DO
               NCHV(TKPT)_EOLIT
               TYPE_FICTYPE
               RETURN
       END
       NCHV(TKPT)_CURCAR
       GETCAR
       GO SF1

SF2:   TEMP_CURCAR
       NCHV(TKPT)_CURCAR
SF2A:  NULL
       GETCAR
       IF CURCAR=EOLIT OR TKPT-TK1PT>71 THEN DO
               TYPE_BADTYPE
               RETURN
       END
       NCHV(TKPT)_CURCAR
       IF CURCAR=TEMP THEN DO
             GETCAR
            NCHV(TKPT)_CURCAR
             GO SF1
       END
       GO SF2A

END FSCAN


!
%YES
       LOCAL STR(0:10)
Y1:    READ(@TEL)
       SCAN
       LEFT(BI("YES","OUI"),MAX(1,LENGTH(@TOKEN)),@STR)
       IF EQUAL(@STR,@TOKEN) THEN RETURN 1
       LEFT(BI("NO","NON"),MAX(1,LENGTH(@TOKEN)),@STR)
       IF EQUAL(@STR,@TOKEN) THEN RETURN 0
       DISPLAY(BI("YES OR NO ?","OUI OU NON ? "),1,0)
       GO Y1
END YES
!
!
!      OPEN BINARY FILE
!      OPEN BINARY FILE
!
!  NAME:              BINOPN
!
!  FUNCTION:          TO REQUEST A NAME FOR A BINARY OUTPUT FILE,
!                     THEN OPEN THAT FILE.
!
!  INPUT:             NONE
!
!  OUTPUT:            BFNAME CONTAINS FILE NAME
!
!  ERRORS DETECTED:   IF THE FILE NAME INPUT IS 'Q' OR 'QUIT', "JOB
!                     ABORTED" IS DISPLAYED AND AN ERROR RETURN
!                     IS EXECUTED.
!                     IF THE FILE NAMED DOES NOT EXIST A DIAGNOSTIC
!                     IS GIVEN. (THIS IMPLIES THAT THE SYMBOLIC FILE
!                     HAS NOT BEEN PREPROCESSED)
!
!  ROUINTES CALLED:   OPENI,OPENO,DISPLAY,TRNSTR,GTPT
!
%BINOPN
       
ACPT:  DISPLAY(BI("FILE: ","FICHIER: "),1,0)
       READ(@TEL); TRNSTR(@BUFF,@SNAME)
       IF EQUAL(@SNAME,"Q") OR EQUAL(@SNAME,"QUIT") THEN DO
               DISPLAY(BI("JOB ABORTED","TRAITEMENT ANNULE!"),1,1)
               RETURN 1
       END

B3:    NULL
        IF NOT LENGTH(@SNAME) THEN GO ACPT

       ADDSTR(@SNAME,"'BIN'",@BFNAME)
       GTPT(@BFNAME,@PT1,@PT2)

       OPENI(PT1,PT2,NOBIN,BFLNO)
       \STB (J); IF J#2 THEN GO BBIN  !NOT BINARY
       GO CKSZ
NOBIN: GTPT(@SNAME,@PT1,@PT2)
       \BRS 48(PT1,PT2,GO ACPT)  !LOOK-UP SYM FILE
BBIN:  DISPLAY(@BFNAME,1,0); DISPLAY(BI(" INVALID OR MISSING"," NON-VALABLE OU ABSENT"),0,0)
       DISPLAY(BI("THE PREPROCESSING PHASE MUST BE CALLED", &
                "UN PRETRAITEMENT EST NECESSAIRE"),1,0)
       RETURN 1
ALLOK: IF OUTFLG THEN DO
               GTPT("GEN'OUTPUT'",@PT1,@PT2)
               OPENO(PT1,PT2,NOOUT,GFLNO,2)
       END
       \SCP (BFLNO,0,GO BADDFL)
       RETURN 0

NOOUT: DISPLAY(BI("IMPOSSIBLE TO OPEN GEN'OUTPUT'", &
           "IMPOSSIBLE D'OUVRIR GEN'OUTPUT'"),1,1); RETURN 1


CKSZ:  \RSP (BFLNO); \STA (I); I_I-6
       [NUMREC;J]_ I DIVMOD(QSIZE*3)
       IF MAXREC<0 THEN MAXREC_NUMREC-1 !-1 TO ADJUST TO BASE 0 IN READ LOOP
       IF J#0 THEN GO NEWVERS
       \WIO (BFLNO); \STA (I)
       IF I#DICVERS THEN GO NEWVERS
       \WIO (BFLNO); \STA (I)
       IF I#QVERS THEN GO NEWVERS
       GO ALLOK

NEWVERS:  NULL
       CLOSE(BFLNO); BFLNO_0; GO BBIN

END BINOPN
!
!  NAME:              INITIAL
!
!  FUNCTION:          SWAPS IN QCBPAGE AND ARMS ESCAPES
!
!  INPUT:             NONE
!
!  OUTPUT:            NONE
!
!  ERRORS DETECTED:   NONE
!
!  ROUTINES CALLED:   SWAPIN,ARM
!
!
%INITIAL

       \BRS 43; \STA (RL1); \STB (RL2)! GET RELABELING
       LIB_OCT 34000; LIB(0)_0 !GRAB PAGE
       \BRS 43; \STP(RL1); LBPAGE_PAGE_BYT(RL2,6,0)
       QNAME_OCT 34000
       SWAPIN(QCBPAGE,6); QCBS_OCT 30000
       RUNFLG_0
       ARM(ESCAPE)
       \BRS 114
       RETURN
END INITIAL
!
!  NAME:              READREC
!
!  FUNCTION:          TO READ THE NEXT RECORD FROM THE BINARY DATA FILE
!  
!  INPUT:             NONE
!
!  OUTPUT:            NONE
!
!  ERRORS DETECTED:   EOFFLG SET IF EOF ENCOUNTERED
!
!  ROUTINES CALLLED:  NONE
!
!
%READREC

       IF QNRREC<14336 THEN RETURN
       IF OUTFLG AND NRREC#0 THEN DO
               \BIO (GFLNO,2048,,OCT 30000,GO OUTERR)
       END
       \BRS 43; \STP (RL1)
       [12,6,6]*[P,P1,P2]_RL2
       RL2_[12,6,6]*[P,P2,P1]; \BRS 44(RL1,RL2)
       QNRREC_QNRREC-2048
       SETADR
       LSTADR_BYT(LSTADR+OCT 34000,14,0)
       IF NOT EOFFLG THEN DO
               \BIO (BFLNO,2048,,14336,GO EOF22); \STA (LSTADR)
       END
       RETURN
EOF22: \STA (LSTADR); EOFFLG_1; RETURN
END READREC

!
!
!  NAME:              RENAME(@ON,@NN)
!
!  FUNCTION:          STANDARD XDS 940 RENAME
!  
!  INPUT:             ON = OLD FILE NAME
!                     NN = NEW FILE NAME
!
!  ERRORS DETECTED:   RETURN 0 AND DISPLAY DIAGNOSTIC IF RENAME
!                     HAS FAILED.
!
!  ROUTINES CALLED:   DISPLAY,GTPT,TRNSTR,ADDSTR
!
%RENAME(@ON,@NN)
       LOCAL STRING(0:20)
       GTPT(@NN,@P1,@P2)
!  DELETE OLD FILE IF OLD NAME EXISTS
       \BRS 48(P1,P2,GO NOF); \BRS 69(GO BADREN); GO NOF

BADREN: DISPLAY("RENAME ",1,0)
        DISPLAY(@ON,0,0); BOUT($,); DISPLAY(@NN,0,0)
        DISPLAY(BI("HAS NOT WORKED","N'A PAS FONCTIONNE"),1,1); RETURN 1

NOF:   TRNSTR(@ON,@STRING)
       GTPT(@STRING,@P1,@P2)
       ADDSTR(@ON,@NN,@STRING)
       GTPT(@STRING,@P1,@P)
       \BRS 58(P1,P2,P,GO BADREN)
       RETURN 0
END RENAME

!
%SHORT(@A)
       LEFT(@A,LENGTH(@TOKEN),@TSTR)
       IF EQUAL(@TOKEN,@TSTR) THEN RETURN 1
       RETURN 0
END  SHORT
SURVEY ** FICHE/FRAME BREAK *****
/CPAVGEN:SIMP/ SYMSORT

SYM.  PG.LN. IDENT.

!      17 37 !!!     !      17 33 !!!     !      17 31 !!!     !      17 30 !!!     
!      17 29 !!!     !      17  6 !!!     !      17  5 !!!     !      15 15 !!!     
!      15 14 !!!     !      15 13 !!!     !      15 12 !!!     !      15 11 !!!     
!      15  7 !!!     !      15  4 !!!     !      13 32 !!!     !      13 31 !!!     
!      13 28 !!!     !      12  3 !!!     !      12  2 !!!     !      11 39 !!!     
!       8 18 !!!     !       8 17 !!!     !       7 10 !!!     !       7  9 !!!     
!       7  7 !!!     !       3 31 !!!     !       1  3 !!!     !       1  2 !!!     
!!!     9 16 !!!     !!!     7 11 !!!     !DEF    3 13 !!!     !LM!   17  3 !!!     
!LM!   16 26 !!!     !LM!   15  5 !!!     !LM!   13 26 !!!     !LM!   11 37 !!!     
!LM!LM 17 27 !!!     !LM!M! 15  3 !!!     !LM!M!  6 36 !!!     !LM%YE 14 32 !!!     
!M      3 29 !!!     !M      1  9 !!!     !M!    17 34 !!!     !M!    17 32 !!!     
!M!    17 28 !!!     !M!    17  9 !!!     !M!    17  8 !!!     !M!    17  7 !!!     
!M!    17  4 !!!     !M!    16 31 !!!     !M!    16 30 !!!     !M!    16 29 !!!     
!M!    16 28 !!!     !M!    16 27 !!!     !M!    15 16 !!!     !M!    15 10 !!!     
!M!    15  9 !!!     !M!    15  8 !!!     !M!    15  6 !!!     !M!    13 33 !!!     
!M!    13 30 !!!     !M!    13 29 !!!     !M!    13 27 !!!     !M!    12  6 !!!     
!M!    12  5 !!!     !M!    12  4 !!!     !M!    12  1 !!!     !M!    11 38 !!!     
!M!    10 37 !!!     !M!     7 29 !!!     !M!     3 28 !!!     !M!     1  8 !!!     
!M!     1  4 !!!     !MDEF   1  5 !!!     !MFINI 10 38 !!!     !MINRE  7 30 !!!     
%XLOAD 12 32 !!!     ACPT:  15 18 !!!     ALLOK: 16  1 !!!     
B3:    15 25 !!!     BADDFL 10 28 !!!     BADDIC  9 37 !!!     BADREN 18  1 !!!     
BADRNG 13 21 !!!     BBIN:  15 36 !!!     CKSZ:  16 12 !!!     DEF     3 10 !!!     
DEF     3  7 !!!     DEF     3  6 !!!     DEF     3  3 !!!     DEF     2 37 !!!     
DEF     2 36 !!!     DEF     2 35 !!!     DEF     2 34 !!!     DEF     2 33 !!!     
DEF     2 32 !!!     DEF     2 30 !!!     DEF     2 29 !!!     DEF     2 28 !!!     
DEF     2 27 !!!     DEF     2 26 !!!     DEF     2 25 !!!     DEF     2 24 !!!     
DEF     2 23 !!!     DEF     2 22 !!!     DEF     2 21 !!!     DEF     2 20 !!!     
DEF     2 19 !!!     DEF     2 18 !!!     DEF     2 15 !!!     EDIT:   5 20 !!!     
END    18 16 !!!     END    18 11 !!!     END    17 25 !!!     END    17  2 !!!     
END    16 25 !!!     END    15  2 !!!     END    14 29 !!!     END    13 25 !!!     
END    12 36 !!!     END    12 30 !!!     END    11 35 !!!     ENDM    3 12 !!!     
ENDM    3  9 !!!     ENDM    3  5 !!!     ENDM    3  1 !!!     EOF11:  7 24 !!!     
EOF22: 17 24 !!!     EOF:    5  6 !!!     ESCAPE 10  5 !!!     ESS1:  10 22 !!!     
FINI1: 11  7 !!!     GRB:   13 16 !!!     GTFL:   7  6 !!!     INPUT:  4  2 !!!     
LL:     3 34 !!!     LOAD:   6 32 !!!     LOCAL   1 32 !!!     M!!!!!  3 19 !!!     
MM%FSC 13 34 !!!     MM%XSA 11 18 !!!     NEWVER 16 22 !!!     NOBIN: 15 34 !!!     
NOF:   18  5 !!!     NOOUT: 16  8 !!!     NOREN:  9  9 !!!     O!!!!!  3 18 !!!     
OFPOOL  5  3 !!!     OLM%GE 12 38 !!!     OM%BIN 15 17 !!!     OM%REN 17 35 !!!     
OUTERR  9 31 !!!     PFTL:   9 20 !!!     POLRET  8  1 !!!     PROG:   3 30 !!!     
RCLP:   7 27 !!!     RENOK:  9 10 !!!     S01:   11 13 !!!     SAVE:   6 30 !!!     
SF0:   13 39 !!!     SF1:   14  3 !!!     SF2:   14 13 !!!     SF2A:  14 15 !!!     
SOS:   11 11 !!!     VERSIO  1 10 !!!     XS1:   11 23 !!!     XS3:   11 32 !!!     
Y1:    14 33 !!!     [MTRAI  6 37 !!!     ]LM%SH 18 13 !!!     ]M!LM% 16 32 !!!     
_DICTI  2  6 !!!     _FLTRE  2 16 !!!     _ISPLA  3  4 !!!     _LTREC  2 17 !!!     
_M!LM% 17 10 !!!     _M%FOP 12  7 !!!     _SUBRO 11 17 !!!     
SURVEY ** FICHE/FRAME BREAK *****
/CPAVGENB:SRCE/
GENBUF IDENT
ORG EQU *
*
*
$POLSZ EQU 1600
$MAXRNG EQU 299
$MXPOOL EQU 1700
$TRECSZ EQU 200
$ERECSZ EQU 200

 BSS 24000B
$POLISH BSS POLSZ
$TMPREC BSS TRECSZ
$ERREC BSS TRECSZ
 BSS 20000B+ORG-*
$POOL   BSS MXPOOL
*
*
$PDIC   BSS MAXRNG
 END
SURVEY ** FICHE/FRAME BREAK *****
/CPAVGENB:SRCE/ SYMSORT

SYM.  PG.LN. IDENT.

ERECSZ  1  9 GENBUF  ERREC   1 14 GENBUF  MAXRNG  1  6 GENBUF  
MXPOOL  1  7 GENBUF  ORG     1  2 GENBUF  PDIC    1 19 GENBUF  POLISH  1 12 GENBUF  
POLSZ   1  5 GENBUF  POOL    1 16 GENBUF  TMPREC  1 13 GENBUF  TRECSZ  1  8 GENBUF  

SURVEY ** FICHE/FRAME BREAK *****
/CPAVGENC:SIMP/
!GENERATION COMPILER!
! WRITTEN BY C.BARASZ
! VERSION C
! JUNE 27 1972
! 
!  MODIFIED FOR BILINGUAL VERSION 5/74 BY B. THORNQUIST
!

DEF BI(ENGLISH,FRENCH) AS ENGLISH



GLOBAL %COMPIL
DEF TURNOFF(X) AS X_0
DEF TURNON(X) AS X_1
DEF INRANGE(X,Y,Z) AS X>= Y AND X<=Z
DEF OUTRANGE(X,Y,Z) AS X<Y OR X>Z
DEF OVER(X) AS >X
DEF NOTYPES AS 10
DEF PROP AS 9
DEF NUMTYPE AS 2
FIND POLSZ(0:1)
DEF NUMOPRS AS 20
DEF NFILTS AS 48
DEF MXQUES AS 512-48
DEF PDR AS -4000000
FIND MAXRNG(0:1)
DEF STKMAX AS 20
!DEF OUTNO(X) AS \BRS 36 (X,10,1)
DEF ENDLIST AS OCT 20000000
DEF QQCBS(X,Y) AS QCBS((X-1)*4+Y)
DEF QQNAME(X,Y) AS QNAME((X-1)*4+Y)
DEF LLIB(X,Y) AS LIB((X-1)*9+Y)
DEF CONTIN(Q) AS BYT(QQCBS(Q,0),1,23)
DEF NONDEF(Q) AS QQCBS(Q,2)=0
DEF COPIED(Q) AS QQCBS(Q,2)<0

DEF VECSIZE(X) AS BYT(QQCBS(X,0),5,0)
DEF RECPOS(X) AS BYT(QQCBS(X,1),12,0)


!POPS!

DEF TAD AS OCT 11100000
DEF TFN AS OCT 11200000
DEF TEN AS OCT 11300000
DEF TTN AS OCT 11400000
DEF TQV AS OCT 11500000
DEF TFV AS OCT 11600000
DEF TEV AS OCT 11700000
DEF TTV AS OCT 12000000
DEF TLN AS OCT 12100000
DEF TSK AS OCT 12200000
DEF TLK AS OCT 12300000
DEF EPOP AS OCT 12400000

DEF OPRPOP AS OCT 12500000
DEF QNA AS OPRPOP+NUMOPRS+2


TABLE OPRPREC(0:NUMOPRS+1)[-1,60,60,70,70,50,50,50,50,0,1,99,99,99,&
                          20,80,50,50,40,30,90,100]

GLOBAL TOP,OPRSTK(STKMAX),EXPCNT
GLOBAL NOGO,ASGNOK,QFOUND,BRACOK,CONTOK,POLPNT,TOPPREC
GLOBAL OPRCNT,CURQUES,LINO,LIBREAD,NCODES,OUTFLG
LOCAL I,K,J,L,N

GLOBAL %ERR,%STACK,%UNSTACK,%PROCOPR,%PROCKON,%OUTQADR
GLOBAL %OUTFADR,%OUTQVAL,%OUTFVAL,%READLIB,%INPAGE
GLOBAL %TOKISQ,%TOKISF,%TOKISL,%OUTPOL

GLOBAL BADDIC:
GLOBAL %UFLOW

FIND %BCLOS,%BERX,%BOUT,%OUTNO
FIND %SCAN,%READ,%DISPLAY,%EQUAL,%TRNSTR,%SWAPIN
FIND VALUE,TYPE,CURPOS,TOKEN(0:24)
FIND BUFF(0:1),POOL(1),PDIC(0:1)
FIND DIC
FIND QCBPAGE,NMPAGE,PAGE,LBPAGE
FIND QNAME(),QCBS(),LIB()

FIND POLISH(1:2)

FIND NQUES,QCBLEN,QCBSTRT


BADDIC: DISPLAY(BI("ERROR IN DICTIONARY FILE", &
           "ERREUR DANS FICHIER DICTIONNAIRE"),1,1)
       DISPLAY(BI("ABORTED","ANNULE"),0,1)
       EXIT


%COMPIL

!   LOAD POP VECTOR

FIND SPOP(0:12)
DEF LOCPOP(I) AS ^(OCT 111 +I)

       L_0
LPOP:  LOCPOP(L)_SPOP(L)
       IF INC L <= 12 THEN GO LPOP

        TURN.OFF(OUTFLG)
        TURN.OFF(NOGO)

        POLPNT_0



        EXPCNT_0
        L_0

!GET LINE FROM DICTIONNARY, TRANSFER TO SCANNER'S BUFFER!

BEGCOM: IF PDIC(L)=0 THEN GO ENDCLP

        INC EXPCNT
        TURN.OFF(QFOUND)
        TURN.OFF(LIB.READ)
        TURN.OFF(ASGN.OK)
        TURN.OFF(BRAC.OK)
        TURN.OFF(CONT.OK)

        CURQUES_0
        TOP_1
        OPR.STK(TOP)_0
        TOP.PREC_OPR.PREC(OPR.STK(TOP))

        OPRCNT_0

        TRNSTR(@POOL(PDIC(L)),@BUFF)
        CURPOS_CHPT(@BUFF,-1)

!SCAN FOR LINE NUMBER!

        SCAN
        IF TYPE#NUM.TYPE THEN DO
               LINO_0
                ERR(BI("LINE NUMBER","NUMERO DE LIGNE"))
               GO ENDCLP
        END

        LINO_VALUE
        OUTPOL(TLN+LINO)


!SCAN FOR LEFT SIDE OF EXPRESSION (ONLY Q,F,T OR E TYPES ALLOWED)!

        SCAN

        DO TYPE+1 OF NOTYPES

        1:3:4:5:6: ERR(BI("SYNTAX","SYNTAXE"))
                     GO ENDCLP

!ALPHA!
!QUES?! 2: IF TOK.IS.Q(@N) THEN DO
               OUTQADR(N)
!FILTER?!  END ELSE IF TOK.IS.F(@N) THEN DO
               OUTFADR(N)
!ERROR!    END ELSE  DO
               ERR(BI("INVALID VARIABLE","VARIABLE NON VALABL"))
               GO ENDCLP
           END


!QTYPE! 7: IF  IN.RANGE(VALUE,1,NQUES)  THEN OUTQADR(VALUE) &
           ELSE [ERR(BI("INVALID QUESTION NUMBER", &
                          "NUMERO DE QUESTION INCORRECT")); GO ENDCLP]

!FTYPE! 8: IF  IN.RANGE(VALUE,1,NFILTS) THEN OUTFADR(VALUE) &
           ELSE [ERR(BI("INVALID FILTER NUMBER", &
                 "NUMERO DE FILTRE INCORRECT")); GO ENDCLP]

!ETYPE!  9: IF  IN.RANGE(VALUE,1,199) THEN OUTPOL(TEN+VALUE) &
            ELSE [ERR(BI("INVALID NUMBER","NUMERO INCORRECT")); GO ENDCLP]

!TTYPE! 10: IF  IN.RANGE(VALUE,1,199) THEN OUTPOL(TTN+VALUE) &
            ELSE [ERR(BI("INVALID NUMBER","NUMERO INCORRECT")); GO ENDCLP]


       END

!AFTER LEFT SIDE OF EXPRESSION FOUND LOOK FOR OPERATOR!
        GO OPERS

!SCAN FOR AN OPERATOR( + - / * = # < > ) [ ] _ :  <= >= AND OR NOT)!

OPERS:  SCAN
        IF TYPE= 5 THEN GO ENDPROC    !END OF LINE ENCOUNTERED!

        IF TYPE# 3 THEN [ERR(BI("SYNTAX","SYNTAXE")); GO ENDCLP] !NON OPERATOR FOUND!

        DO VALUE OF NUMOPRS

        1:2:3:4:5:6:7:8:16:17:18:19:20:  PROC.OPR
!       + - / * = # < > <= >= AND OR NOT            !

!COMMA!
        13: ERR(BI("INVALID CHARACTER","CARACTERE NON VALABLE"))
           GO ENDCLP

!CONTAINS!
        15: IF NOT CONT.OK THEN [ERR(BI("SYNTAX","SYNTAXE")); GO ENDCLP]

            POLISH(POLPNT)_TAD+RECPOS(CUR.QUES)
            OUTPOL(TSK+VECSIZE(CUR.QUES))
            PROC.OPR

!OPEN PAREN!
        9: ERR(BI("( IMPROPERLY PLACED","( MAL PLACE"))
           GO ENDCLP

!ASSIGN!
        14: IF OPRCNT#0 THEN [ERR(BI("SYNTAX","SYNTAXE")); GO ENDCLP]
            TURN.ON(ASGN.OK)
            PROC.OPR

!CLOSE PAREN!
        10: UNSTACK
            IF TOPPREC#OPR.PREC(PROP) THEN &
            [ERR(BI("( MISSING","( MANQUANTE")); GO ENDCLP]
            IF DEC TOP<1 THEN  UFLOW
            TOP.PREC_OPR.PREC(OPR.STK(TOP))
            GO OPERS

!BRACKET!
        11: IF NOT BRAC.OK THEN [ERR(BI("SYNTAX","SYNTAXE")); GO ENDCLP]

            SCAN    !FOR SUBSCRIPT!
            IF TYPE # NUMTYPE THEN [ERR(BI("INVALID INDEX",  &
             "INDICE INCORRECT")); GO ENDCLP]
            IF OUT.RANGE(VALUE,1,VECSIZE(CUR.QUES)) THEN &
            [ERR(BI("INVALID INDEX","INDICE INCORRECT")); GO ENDCLP]
            POLISH(POLPNT)_POLISH(POLPNT)+VALUE-1
            SCAN    !FOR CLOSE BRACKET!
            IF NOT EQUAL("]",@TOKEN) THEN [ERR(BI("] MANQUANT", &
              "] MANQUANT")); GO ENDCLP]
            TURN.OFF(CONT.OK)
            GO OPERS

!CLOSE BRACKET!
        12: ERR(BI("SYNTAX","SYNTAXE"))
            GO ENDCLP

        END

        GO VARS  !AFTER OPR FOUND LOOK FOR VARIABLE/CONSTANT!


!SACN FOR A VARIABLE(Q,F,T,E) OR CONSTANT!

VARS:   SCAN

        DO TYPE+1 OF NOTYPES

        1:5: ERR(BI("INVALID CHARACTER OR VARIABLE",  &
                   "CARACTERE OU VARIABLE NON VALABLE"))
               GO ENDCLP

!EOL!
        6: ERR("EXPRESSION INCOMPLETE")
           GO ENDCLP

! ( , NEG , NOT !
        4: IF EQUAL(@TOKEN,"(") THEN DO
               TOP.PREC._-1
               PROC.OPR
               GO VARS
           END ELSE IF EQUAL(@TOKEN,"-") THEN DO
               VALUE_NUMOPRS+1
               PROC.OPR
               GO VARS
           END ELSE IF EQUAL(@TOKEN,"NOT") THEN DO
               PROC.OPR
               GO VARS
           END ELSE IF EQUAL(@TOKEN,"+") THEN GO VARS

           ERR(BI("SYNTAX","SYNTAXE")) !OPER FOUND INSTEAD OF VARIABLE!
           GO ENDCLP

!CONSTANT!
        3: PROC.KON

!ALPHA-NUMERIC!
!QUESTION?!
        2: IF EQUAL(@TOKEN,"QNO") THEN DO
               OUTPOL(QNA)
               TURN.OFF(BRAC.OK)
               TURN.OFF(CONT.OK)
           END ELSE IF TOK.IS.Q(@N) THEN DO
               OUTQVAL(N)
!LIBELLE?!
           END ELSE IF QFOUND THEN DO
               IF EQUAL(@TOKEN,BI("NA","PDR")) &
                    THEN [VALUE_PDR;PROCKON;GO FNDVAR]
               IF NOT LIB.READ THEN DO
               IF COPIED(CURQUES) THEN CURQUES_-QQCBS(CURQUES,2)
                      IF CONTIN(CURQUES) OR NONDEF(CURQUES) THEN GO CKFLT
                      READLIB
                      TURN.ON(LIB.READ)
               END

               IF TOK.IS.L(@N)  THEN DO
                               VALUE_N
                               PROC.KON
               END ELSE GO CKFLT

!FILTER?!
        END ELSE DO
               CKFLT: IF TOK.IS.F(@N) THEN OUTFVAL(N) &
                      ELSE [ERR(BI("INVALID VARIABLE", &
                         "VARIABLE NON VALABLE")); GO ENDCLP]
        END

!QTYPE!

        7: IF IN.RANGE(VALUE,1,NQUES) THEN OUTQVAL(VALUE) &
           ELSE [ERR(BI("QUESTION NUMBER INCORRECT", &
                      "NUMERO DE QUESTION INCORRECT")); GO ENDCLP]

!FTYPE!
        8: IF IN.RANGE(VALUE,1,NFILTS) THEN OUTFVAL(VALUE) &
           ELSE [ERR(BI("FILTER NUMBER INCORRECT",  &
                      "NUMERO DE FILTRE INCORRECT")); GO ENDCLP]

!ETYPE!
        9: IF IN.RANGE(VALUE,1,199) THEN DO
               OUTPOL(TEV+VALUE)
               TURN.OFF(BRAC.OK)
               TURN.OFF(CONT.OK)
           END ELSE [ERR(BI("INVALID NUMBER", &
                      "NUMERO INCORRECT")); GO ENDCLP]

!TTYPE!
        10: IF IN.RANGE(VALUE,1,199) THEN DO
               OUTPOL(TTV+VALUE)
               TURN.OFF(BRAC.OK)
               TURN.OFF(CONT.OK)
           END ELSE [ERR(BI("INVALID NUMBER", &
                     "NUMERO INCORRECT")); GO ENDCLP]

        END

!AFTER FINDING A VARIABLE/CONSTANT LOOK FOR AN OPERATOR!

FNDVAR: GO OPERS



!END OF LINE FOUND!

ENDPROC: IF OPRSTK(TOP)=PROP THEN [ERR(BI(") MISSING", &
               ") MANQUANT")); GO ENDCLP]
         IF TOP=1 THEN GO FINCOM
       I_OPRPOP+OPRSTK(TOP)
       OUTPOL(I)
       DEC TOP
       GO ENDPROC

FINCOM: IF NOT ASGN.OK THEN ERR(BI("ASSIGNMENT","ASSIGNATION"))
ENDCLP: IF INC L<= MAXRNG THEN GO BEGCOM

!ALL LINES COMPILED, GO TO RUN SIDE!

       IF EXPCNT=0 THEN DO
               DISPLAY(BI("NO PROGRAM","PAS DE PROGRAM"),1,1)
               TURN.ON(NOGO)
       END
       OUTPOL(EPOP)
       RETURN



END COMPIL




%UFLOW

       DISPLAY(BI("ERROR 'UNDERFLOW'","ERREUR 'UNDER FLOW'"),1,1)
       DISPLAY(BI("ABORTED","ANNULE"),0,1)
       EXIT
END UFLOW

!ROUTINE STACKS OPERATOR!

%PROCOPR

       STACK
       INC OPRCNT
       RETURN

END PROCOPR

!ROUTINE OUTPUTS CONSTANT!

%PROCKON

       IF VALUE>OCT 37777 OR  VALUE<0 THEN DO
               OUTPOL(TLK)
               OUTPOL(VALUE)
       END ELSE OUTPOL(TSK+VALUE)

       TURN.OFF(BRAC.OK)
       TURN.OFF(CONT.OK)

       RETURN
END PROCKON

!ROUTINE OUTPUTS QUES ADR!

%OUTQADR(N)

       IF CUR.QUES#N THEN TURN.OFF(LIB.READ)
       TURNON(OUTFLG)
       OUTPOL(TAD+RECPOS(N))
       TURN.ON(BRAC.OK)
       TURN.ON(QFOUND)
       CURQUES_N
       RETURN

END OUTQADR

!ROUTINE OUTPUTS FILTER ADDRESS!

%OUTFADR(N)

       TURN.ON(OUTFLG)
       OUTPOL(TFN+N)
       RETURN
END OUTFADR

!ROUTINE OUTPUTS QUES. VALUE!

%OUTQVAL(N)

       IF CURQUES#N THEN TURN.OFF(LIB.READ)
       CURQUES_N
       TURN.ON(BRAC.OK)
       TURN.ON(CONT.OK)
       TURN.ON(QFOUND)
       OUTPOL(TQV+RECPOS(N))
       RETURN
END OUTQVAL

!ROUTINE OUTPUTS FILTER VALUE!

%OUTFVAL(N)

       OUTPOL(TFV+N)
       TURN.OFF(BRAC.OK)
       TURN.OFF(CONT.OK)
       RETURN
END OUTFVAL

!ROUTINE READS  QCB OF CURRENT QUESTION!



!ROUTINE READS LIBELLES!

%READLIB

       LOCAL I,K,J
       INPAGE(LBPAGE)
       NCODES_QQCBS(CURQUES,2)
       IF NCODES < 1 THEN DISPLAY ("SYSERR IN READLIB",1,1)
       \SCP(DIC,QQCBS(CURQUES,3),GO BADDIC)
       \BIO(DIC,NCODES*9,,LIB,GO BADDIC)

       RETURN
END READLIB

!ROUTINE VERIFIES IF TOKEN IS A QUES. NAME!

%TOKISQ(@Q)

       LOCAL I,K
       INPAGE(NMPAGE)
       I_1
TL:    NULL
       IF EQUAL(@TOKEN,@QQNAME(I,0)) THEN DO
               Q_I
               RETURN 1
       END
       IF INC I<= NQUES THEN GO TL

       RETURN 0
END TOKISQ

!ROUTINE VERIFIES IF TOKEN IS A FILTER NAME!

%TOKISF(@F)

       LOCAL I,K
       INPAGE(NMPAGE)
       I_1
FL:    NULL
       IF EQUAL(@TOKEN,@QQNAME(I+MXQUES,0)) THEN DO
               F_I
               RETURN 1
       END

       IF INC I<=NFILTS THEN GO FL

       RETURN 0
END TOKISF

!ROUTINE VERIFIES IF TOKEN IS A LIBELLE!

%TOKISL(@L)

       LOCAL I,K

       I_1
LLP:   NULL
       IF EQUAL(@TOKEN,@LLIB(I,1)) THEN DO
               L_LLIB(I,0)
               RETURN 1
       END

       IF INC I<= NCODES THEN GO LLP

       RETURN 0
END TOKISL

!ROUTINE STACKS AN OPERATOR (CALLS UNSTACK,WHICH UNSTACKS IF NECESSARY)!

%STACK

       UNSTACK
       IF INC TOP OVER(STKMAX) THEN ERR(BI("EXPRESSION TOO LONG", &
                                  "EXPRESSION TROP LONGUE"))
       OPRSTK(TOP)_VALUE
       TOP.PREC_OPRPREC(VALUE)
       RETURN
END STACK

!ROUTINE AUTOMATICALLY UNSTACKS UNTIL IT FIND AN OPERATOR THAT HAS!
!A GREATER OR EQUAL PRIORITY THAN THE CURRENT OPERATOR!

%UNSTACK

       LOCAL I

UN:    IF OPR.PREC(VALUE)>TOP.PREC THEN RETURN
       I_OPRPOP+OPRSTK(TOP)
       OUTPOL(I)
       IF DEC TOP <1 THEN  UFLOW
       TOP.PREC_OPRPREC(OPRSTK(TOP))
       GO UN
END UNSTACK


!ERROR ROUTINE: ERROR FOUND WHILE COMPILING LINE!

%ERR(MES)
       BCLOS

       LOCAL PNT,CAR,ERSTR(0:23),ERPOS
       BOUT(CARRET)
       PNT_CHPT(@BUFF,-1)
       ERPOS_CURPOS-PNT-1
OERR:  CAR_NCHV(PNT)
       IF CAR=EOLIT OR (CAR=LNFEED AND CURPOS<=PNT) THEN DO
               CH(@ERSTR,ERPOS)_EOLIT
               DISPLAY(@ERSTR,1,0)
               CH(@ERSTR,ERPOS)_$ 
               BOUT($^)
               DISPLAY(MES,1,1)
               TURN.ON(NOGO)
               BERX
               RETURN
       END

       BOUT(CAR)
       IF CAR=LNFEED THEN ERPOS_CURPOS-PNT-1
       GO OERR
END ERR

%OUTPOL(I)


       IF NOGO THEN RETURN
       IF INC POLPNT OVER(POLSZ) THEN DO
               ERR(BI("PROGRAM TOO LARGE","PROGRAM TROP LARGE"))
               RETURN
       END

       POLISH(POLPNT)_I
       RETURN
END OUTPOL


%INPAGE(PG)

       IF PAGE=PG THEN RETURN
       SWAPIN(PG,7); PAGE_PG
       RETURN
END INPAGE
SURVEY ** FICHE/FRAME BREAK *****
/CPAVGENC:SIMP/ SYMSORT

SYM.  PG.LN. IDENT.

!       7 22 OGENERAT!       5 37 OGENERAT!       1  6 OGENERAT!       1  5 OGENERAT
!       1  4 OGENERAT!       1  3 OGENERAT!       1  2 OGENERAT!A     13 31 OGENERAT
!AFTER  9 14 OGENERAT!AFTER  5 24 OGENERAT!ALL    9 33 OGENERAT!CLOSE  6 39 OGENERAT
!CLOSE  6 17 OGENERAT!COMMA  5 39 OGENERAT!DEF    1 27 OGENERAT!END    9 20 OGENERAT
!EOL!M  7 19 OGENERAT!ERROR 14  5 OGENERAT!ERROR  5  1 OGENERAT!ETYPE  8 37 OGENERAT
!ETYPE  5 15 OGENERAT!FILTE  4 38 OGENERAT!FTYPE  8 33 OGENERAT!FTYPE  5 11 OGENERAT
!GET    3 32 OGENERAT!MMDEF  1  7 OGENERAT!OPEN   6  9 OGENERAT!QTYPE  5  7 OGENERAT
!ROUTI 13 30 OGENERAT!ROUTI 13 20 OGENERAT!ROUTI 13  4 OGENERAT!ROUTI 12 27 OGENERAT
!ROUTI 12 12 OGENERAT!ROUTI 11 39 OGENERAT!ROUTI 11 35 OGENERAT!ROUTI 11 27 OGENERAT
!ROUTI 11 16 OGENERAT!ROUTI 11  9 OGENERAT!ROUTI 10 36 OGENERAT!ROUTI 10 23 OGENERAT
!ROUTI 10 15 OGENERAT!SACN   7  9 OGENERAT!SCAN   5 27 OGENERAT!SCAN   4 27 OGENERAT
!SCAN   4 14 OGENERAT!TTYPE  9  5 OGENERAT!TTYPE  5 18 OGENERAT%STACK 13 22 OGENERAT
%UFLOW 10 10 OGENERATBADDIC  3  7 OGENERATBEGCOM  3 34 OGENERAT
DEF     3 16 OGENERATDEF     2 15 OGENERATDEF     2 14 OGENERATDEF     2 12 OGENERAT
DEF     2 11 OGENERATDEF     2 10 OGENERATDEF     2  9 OGENERATDEF     2  8 OGENERAT
DEF     2  7 OGENERATDEF     2  6 OGENERATDEF     2  5 OGENERATDEF     2  4 OGENERAT
DEF     2  3 OGENERATDEF     2  2 OGENERATDEF     1 37 OGENERATDEF     1 36 OGENERAT
DEF     1 34 OGENERATDEF     1 33 OGENERATDEF     1 32 OGENERATDEF     1 31 OGENERAT
DEF     1 30 OGENERATDEF     1 29 OGENERATDEF     1 28 OGENERATDEF     1 26 OGENERAT
DEF     1 24 OGENERATDEF     1 23 OGENERATDEF     1 22 OGENERATDEF     1 21 OGENERAT
DEF     1 19 OGENERATDEF     1 18 OGENERATDEF     1 17 OGENERATDEF     1 16 OGENERAT
DEF     1 15 OGENERATDEF     1 14 OGENERATDEF     1 13 OGENERATDEF     1 12 OGENERAT
END    15  5 OGENERATEND    14 38 OGENERATEND    14 28 OGENERATEND    14  2 OGENERAT
END    13 28 OGENERATEND    13 18 OGENERATEND    13  2 OGENERATEND    12 25 OGENERAT
END    12 10 OGENERATEND    11 33 OGENERATEND    11 25 OGENERATEND    11 14 OGENERAT
END    11  7 OGENERATEND    10 34 OGENERATEND    10 21 OGENERATEND    10 13 OGENERAT
END    10  5 OGENERATENDCLP  9 31 OGENERATENDPRO  9 22 OGENERATFINCOM  9 30 OGENERAT
FIND    3 15 OGENERATFIND    3  4 OGENERATFIND    3  2 OGENERATFIND    2 39 OGENERAT
FIND    2 38 OGENERATFIND    2 37 OGENERATFIND    2 36 OGENERATFIND    2 35 OGENERAT
FIND    2 34 OGENERATFIND    2 33 OGENERATFIND    1 25 OGENERATFIND    1 20 OGENERAT
FL:    12 32 OGENERATFNDVAR  9 16 OGENERATGLOBAL  2 31 OGENERATGLOBAL  2 30 OGENERAT
GLOBAL  2 28 OGENERATGLOBAL  2 27 OGENERATGLOBAL  2 26 OGENERATGLOBAL  2 23 OGENERAT
GLOBAL  2 22 OGENERATGLOBAL  2 21 OGENERATGLOBAL  1 11 OGENERATGPOPS!  2  1 OGENERAT
LLP:   13  9 OGENERATLOCAL   2 24 OGENERATLPOP:   3 19 OGENERATMASSIG  6 13 OGENERAT
MBRACK  6 25 OGENERATMCOMPI  3 13 OGENERATMERR(M 14  7 OGENERATMFILTE  8 23 OGENERAT
MOUTPO 14 30 OGENERATMPROCK 10 25 OGENERATMPROCO 10 17 OGENERATMQTYPE  8 29 OGENERAT
MREADL 12  2 OGENERATMTOKIS 13  6 OGENERATMUNSTA 13 33 OGENERATOERR:  14 13 OGENERAT
OOUTFA 11 11 OGENERATOOUTFV 11 29 OGENERATOOUTQA 10 38 OGENERATOOUTQV 11 18 OGENERAT
OPERS:  5 29 OGENERATOTOKIS 12 29 OGENERATTABLE   2 18 OGENERATTL:    12 17 OGENERAT
UN:    13 35 OGENERATVARS:   7 11 OGENERAT]CONST  7 39 OGENERAT]TOKIS 12 14 OGENERAT
_ALPHA  8  2 OGENERAT_ALPHA  4 36 OGENERAT_CONTA  6  3 OGENERAT_INPAG 15  2 OGENERAT
_LIBEL  8  8 OGENERAT
SURVEY ** FICHE/FRAME BREAK *****
/CPAVGENR:SRCE/
GENPOP IDENT
       ;*   THIS VERSION IS OPTIMIZED BY USING THE X REGISTER
       ;*   AS A STACK POINTER.  THE FIRST GENERATED INSTRUCTION
       ;*   IS AN EAX -200D.  THE POPS THEREAFTER PRESERVE THE STACK
       ;*    POINTER

OLD    EQU 0   (THE CODE IS ALREADY WRITTEN FOR PROCESSING FILTERS)
               ;* WHEN THEY WILL BE USING 1 BIT EACH

*******MACRO INCREMENTS STACK POINTER AND CHECKS FOR OVER FLOW***
       ;*
       ;*
MINSTK MACRO
       BRX *+2; BRM OVER; STA ESTACK,2
       ENDM
       ;*
       ;*
*******MACRO DECREMENTS POINTER******
       ;*
       ;*
DECSTK MACRO
       EAX -1,2
       ENDM
       ;*
******* MACRO GETS TOP OF STACK AND SETS POINTER TO NEXT ELEMENT**
       ;*
GETTOP MACRO
       LDA ESTACK,2; DECSTK
       ENDM
       ;*
       ;*

       ;*  CHECK IF EITHER ELEMENTS ON THE TOP IS PDR AND MAKE RESULT PDR

ISPDR  MACRO D
       LDA PDRCOD; SKE ESTACK,2; BRU *+2
      IF D(1)=1; BRU MULPDR; ELSE; BRU SETPDR; ENDF
       SKE ESTACK-1,2; BRU *+2
       IF D(1)=1; BRU MULPDR; ELSE; BRU SETPDR; ENDF
       ENDM

PDRCOD DATA -4000000

SETPDR DECSTK; LDA PDRCOD; STA ESTACK,2; BRR 0
       ;*  SETPDR ONLY IF OTHER MULTIPLIER IS NOT  0 OR 1
MULPDR LDA ESTACK,2; MUL ESTACK-1,2; LSH 23
       SKE PDRCOD; BRU *+2; BRU MULX; SKE =0; BRU SETPDR; BRU MULX


*******ERROR ROUTINES*******
       ;*
       ;*
OVER ZRO 0
      LDA =MES1; BRM MSG; BRS 10
       ;*
UNDER ZRO 0
       LDA =MES2; BRM MSG; BRS 10
       ;*
ERROR ZRO 0
       LDA =MES3; BRM MSG; BRS 10
       ;*
MSG ZRO 0
       LDB =-1; LDX =1; BRS 34; BRR MSG
       ;*
       ;*
       ;*
*******STACK RELATIVE ADRESSES*****
       ;*
       ;*
       ;*
TAD    POPD    111B5
XTAD   EQU *
       ;*
       CXB; EAX* 0; COPY XA,BX; ETR ADRMSK
       MINSTK; BRR 0
       ;*
       ;*
TFN    POPD    112B5
XTFN   EQU *
       ;*
       CXB; EAX* 0; COPY XA,BX; ETR ADRMSK
       MRG =1B5 (TO INDICATE ITS A FILTER NUMBER)
       MINSTK; BRR 0
       ;*
       ;*
TEN    POPD    113B5
XTEN   EQU *
       ;*
       CXB; EAX* 0; COPY XA,BX; ETR ADRMSK
       MRG =2B5 (TO INDICATE ITS A ERROR NUMBER)
       MINSTK; BRR 0
       ;*
       ;*
TTN    POPD    114B5
XTTN   EQU *
       ;*
       CXB; EAX* 0; COPY XA,BX; ETR ADRMSK
       MRG =3B5 (TO INDICATE ITS A TEMPORARY VARIABLE NUMBER)
       MINSTK; BRR 0
       ;*
       ;*
       ;*
*******STACK VALUES******
       ;*
       ;*
       ;*
TQV    POPD    115B5
XTQV   EQU *
       ;*
       CXB; EAX* 0; LDA* XQNRREC
       CBX; MINSTK; BRR 0
       ;*
       ;*
TFV    POPD    116B5
XTFV   EQU *
       ;*
       IF OLD
       CXB; EAX* 0; LDA* XFLTREC; CBX
       ELSE
       STX SX; EAX* 0; CXA; SUB =1; ETR =77B; CAX
       LDP* FLTREC; XAB
       RCY 0,2
       ETR =1; LDX SX
       ENDF
       MINSTK; BRR 0
       ;*
       ;*
       ;*
TEV    POPD    117B5
XTEV   EQU *
       ;*
       CXB
       EAX* 0; LDA ERREC,2; CBX; MINSTK; BRR 0
       ;*
       ;*
TTV    POPD    120B5
XTTV   EQU *
       ;*
       CXB; EAX* 0
       LDA TMPREC,2; CBX; MINSTK; BRR 0
       ;*
       ;*
TSK    POPD    122B5
XTSK   EQU *
       ;*
       CXB; EAX* 0; COPY XA,BX; ETR ADRMSK
       MINSTK; BRR 0
       ;*
       ;*
TLK    POPD    123B5
XTLK   EQU *
       ;*
       MIN 0 (TO GET LONG CONSTANT FOLLOWING THIS POP)
       CXB; LDX 0; LDA 0,2; CBX; MINSTK; BRR 0
       ;*
       ;*
       ;*
*******OPERATOR POPS AND STORE POP****
       ;*
       ;*
       ;*
OPRPOP POPD    125B5
XOPRPOP EQU *
       ;*
       CXB; EAX* 0  (GET OPERATION NUMBER TO PERFORM)
       BRU *,2
BVEC           BRU ADD
               BRU SUB
               BRU DIV
               BRU MUL
               BRU EQ
               BRU NEQ
               BRU LT
               BRU GT
               BRM ERROR (OPEN PAREN)
               BRM ERROR (CLOSE PAREN)
               BRM ERROR (OPEN BRACKET)
               BRM ERROR (CLOSE BRACKET)
               BRM ERROR (COMMA)
               BRU STORE
               BRU CONTAIN
               BRU LE
               BRU GE
               BRU AND
               BRU OR
               BRU NOT
               BRU NEG
               BRU QNO   (TAKE QUESTIONNAIRE NUMBER)
       ;*
ADD    CBX; ISPDR 0; GETTOP; ADM ESTACK,2; BRR 0
       ;*
SUB    CBX; ISPDR 0; GETTOP; CNA; ADM ESTACK,2; BRR 0
       ;*
DIV    CBX; ISPDR 0; GETTOP; STA TEMP; LDA ESTACK,2; CLB; RSH 23
       DIV TEMP; STA ESTACK,2
       ;* ROUND IF REMAINDER > 1/2 THE DIVISOR
       COPY BA,B; LSH 1; SKG TEMP; BRR 0; MIN ESTACK,2; BRR 0
       ;*
MUL    CBX; ISPDR 1
MULX    GETTOP; MUL ESTACK,2; RSH 1; STB ESTACK,2; BRR 0
       ;*
EQ     CBX; GETTOP; SKE ESTACK,2; BRU FALSE; BRU TRUE
       ;*
NEQ    CBX; GETTOP; SKE ESTACK,2; BRU TRUE; BRU FALSE
       ;*
LT     CBX; GETTOP; SKG ESTACK,2; BRU FALSE; BRU TRUE
       ;*
GT     CBX; GETTOP; STA TEMP; LDA ESTACK,2; SKG TEMP; BRU FALSE; BRU TRUE
       ;*
LE     CBX; GETTOP; STA TEMP; LDA ESTACK,2; SKG TEMP; BRU TRUE; BRU FALSE
       ;*
GE     CBX; GETTOP; SKG ESTACK,2; BRU TRUE; BRU FALSE
       ;*
AND    CBX; GETTOP; STA TEMP; CLA; SKE TEMP; BRU *+2; BRU FALSE
       SKE ESTACK,2; BRU TRUE; BRU FALSE
       ;*
OR     CBX; GETTOP; MRG ESTACK,2; SKE =0; BRU TRUE; BRU FALSE
       ;*
NOT    COPY BX,A; SKE ESTACK,2; BRU FALSE; BRU TRUE
       ;*
NEG    COPY BX,A; SUB ESTACK,2; STA ESTACK,2; BRR 0
       ;*
QNO    CBX; LDA* QNRREC; MINSTK; BRR 0
       ;*
       ;*
CONTAIN CBX; GETTOP  (CONSTANT); STA TEMP+1
       GETTOP; STA VECSIZE
       LDA ESTACK,2 (RECORD POINTER Q(1))
       ADD QNRREC; STA TEMP
SCLP   SKR VECSIZE; BRU *+2; BRU FALSE; LDA* TEMP
       SKE TEMP+1; BRU ECLP; BRU TRUE
ECLP   MIN TEMP
       BRU SCLP
       ;*
STORE  CBX; GETTOP; STA TEMP  (ITEM TO BE STORED)
       LDA ESTACK,2  (RELATIVE POINTER)
       RSH 15  (GET RECORD TYPE)
       STX SX; COPY AX,A; LSH 15 (RELATIVE POINTER BACK IN A)
       BRU STOTYP,2
STOTYP BRU STOQNR
       BRU STOFLT
       BRU STOERR
       BRU STOTMP
       ;*
STOQNR CAX; LDA TEMP; STA* XQNRREC; LDX SX; DECSTK; BRR 0
STOFLT COPY AX,A; SKE TEMP; ADD =1; STA TEMP; ADM FLTCNT,2
       IF OLD
       STA* XFLTREC
       ELSE
       CXA; SUB =1; CAX
       LDP* FLTREC; XAB; RCY 0,2; ETR =77777776B; MRG TEMP; LCY 0,2
       XAB; STP* FLTREC
       ENDF
       LDX SX; DECSTK; BRR 0
STOERR CAX; LDA TEMP; STA ERREC,2; SKE =0; MIN ERRFLG
       LDX SX; DECSTK; BRR 0
STOTMP CAX; LDA TEMP; STA TMPREC,2; LDX SX; DECSTK; BRR 0
       ;*
       ;*
       ;*
TLN    POPD    121B5
XTLN   EQU *
       ;*
       EAX* 0; CXA;  ETR ADRMSK; STA LINUM
       LDX STKMIN (INITIALIZE STACK PT); BRR 0
       ;*
       ;*
       ;*
EPOP    POPD   124B5
XEPOP   EQU *
       CXA; MRG =4B7; SKE STKMIN; BRM ERROR; BRU POLRET
TRUE LDA =1; STA ESTACK,2; BRR 0
FALSE CLA; STA ESTACK,2; BRR 0
       ;*
       ;*
       ;*
MES1 ASC '$SYSTEMS ERROR: STACK OVERFL0W/'
MES2 ASC '$SYSTEMS ERROR: STACK UNDERFLOW/'
MES3 ASC '$ERROR IN GENERATED CODE/'
       ;*
       ;*
SX    BSS 1
VECSIZE BSS 1
TEMP BSS 5
UNDR BSS 1
STACK BSS 200
ESTACK EQU *
OVR BSS 1
STKMIN DATA -200
$ERRFLG BSS 1
$FLTCNT BSS 49
$LINUM BSS 1
ADRMSK DATA 37777B

*   POP VECTOR
*   POP VECTOR

$SPOP EQU *
 BRU XTAD; BRU XTFN; BRU XTEN; BRU XTTN; BRU XTQV
 BRU XTFV; BRU XTEV; BRU XTTV; BRU XTLN; BRU XTSK; BRU XTLK
 BRU XEPOP; BRU XOPRPOP
$NDPOP EQU *
$QNRREC DATA 0
$XQNRREC DATA 0 QNRREC ADR+XBIT
$FLTREC DATA 0
$XFLTREC DATA 0  FLT ADR +XBIT
$POLADR DATA POLISH+1
$TMPADR DATA TMPREC
$ERRADR DATA ERREC
 END
SURVEY ** FICHE/FRAME BREAK *****
/CPAVGENR:SRCE/ SYMSORT

SYM.  PG.LN. IDENT.

ADD     5 34 GENPOP  ADRMSK  8 20 GENPOP  AND     6 19 GENPOP  
BVEC    5 11 GENPOP  CONTAI  6 31 GENPOP  DECSTK  1 21 GENPOP  DIV     5 38 GENPOP  
ECLP    6 37 GENPOP  EPOP    7 35 GENPOP  EQ      6  7 GENPOP  ERRADR  8 36 GENPOP  
ERRFLG  8 17 GENPOP  ERROR   2 20 GENPOP  ESTACK  8 14 GENPOP  FALSE   7 39 GENPOP  
FLTCNT  8 18 GENPOP  FLTREC  8 32 GENPOP  GE      6 17 GENPOP  GETTOP  1 27 GENPOP  
GT      6 13 GENPOP  ISPDR   1 35 GENPOP  LE      6 15 GENPOP  LINUM   8 19 GENPOP  
LT      6 11 GENPOP  MES1    8  4 GENPOP  MES2    8  5 GENPOP  MES3    8  6 GENPOP  
MINSTK  1 13 GENPOP  MSG     2 23 GENPOP  MUL     6  4 GENPOP  MULPDR  2  7 GENPOP  
MULX    6  5 GENPOP  NDPOP   8 29 GENPOP  NEG     6 26 GENPOP  NEQ     6  9 GENPOP  
NOT     6 24 GENPOP  OLD     1  7 GENPOP  OPRPOP  5  6 GENPOP  OR      6 22 GENPOP  
OVER    2 14 GENPOP  OVR     8 15 GENPOP  PDRCOD  2  3 GENPOP  POLADR  8 34 GENPOP  
QNO     6 28 GENPOP  QNRREC  8 30 GENPOP  SCLP    6 35 GENPOP  SETPDR  2  5 GENPOP  
SPOP    8 25 GENPOP  STACK   8 13 GENPOP  STKMIN  8 16 GENPOP  STOERR  7 21 GENPOP  
STOFLT  7 12 GENPOP  STOQNR  7 11 GENPOP  STORE   7  1 GENPOP  STOTMP  7 23 GENPOP  
STOTYP  7  6 GENPOP  SUB     5 36 GENPOP  SX      8  9 GENPOP  TAD     2 32 GENPOP  
TEMP    8 11 GENPOP  TEN     3  8 GENPOP  TEV     4 12 GENPOP  TFN     2 39 GENPOP  
TFV     3 36 GENPOP  TLK     4 33 GENPOP  TLN     7 27 GENPOP  TMPADR  8 35 GENPOP  
TQV     3 29 GENPOP  TRUE    7 38 GENPOP  TSK     4 26 GENPOP  TTN     3 16 GENPOP  
TTV     4 19 GENPOP  UNDER   2 17 GENPOP  UNDR    8 12 GENPOP  VECSIZ  8 10 GENPOP  
XEPOP   7 36 GENPOP  XFLTRE  8 33 GENPOP  XOPRPO  5  7 GENPOP  XQNRRE  8 31 GENPOP  
XTAD    2 33 GENPOP  XTEN    3  9 GENPOP  XTEV    4 13 GENPOP  XTFN    3  1 GENPOP  
XTFV    3 37 GENPOP  XTLK    4 34 GENPOP  XTLN    7 28 GENPOP  XTQV    3 30 GENPOP  
XTSK    4 27 GENPOP  XTTN    3 17 GENPOP  XTTV    4 20 GENPOP  
SURVEY ** FICHE/FRAME BREAK *****
/CPAVGLOB:SIMP/
!!! GLOBAL VARIABLES

GLOBAL QCBS(),QNAME(),LIB(),BNAME()
GLOBAL STUDY(0:9),SNAME(0:9)
GLOBAL BUFF(0:99),NEWBUF(0:99)


!!! GLOBAL FUNCTIONS

GLOBAL %BCLOS,%BERX
GLOBAL %SWAPIN,%BOUT,%OUTNO

!!! EXTERNAL VARIABLES

FIND RL1,RL2,CFLNO

!----------------------------------------------- SWAPIN ROUTINE

%SWAPIN(PAGE,IPOS)

       \BRS 113

       \BRS 43; \STP (RL1)
       DO IPOS+1 OF 8
       1:  BYT(RL1,6,18)_PAGE
       2:  BYT(RL1,6,12)_PAGE
       3:  BYT(RL1,6,6)_PAGE
       4:  BYT(RL1,6,0)_PAGE
       5:  BYT(RL2,6,18)_PAGE
       6:  BYT(RL2,6,12)_PAGE
       7:  BYT(RL2,6,6)_PAGE
       8:  BYT(RL2,6,0)_PAGE
       END

       \BRS 44(RL1,RL2)

       \BRS 114
       RETURN

END SWAPIN
!
!  SUPPRESS ALL OUTPUT IF RUNNING FROM A COMMAND FILE
!

!
!  NAME:              BOUT(CHAR)
!**** THIS ROUTINE NO LONGER SUPPRESSES OUTPUT IF A COMMAND 
!**** FILE IS PRESENT AS PER CROSSLEY INSTRUCTIONS
!
!  FUNCTION:          TO OUTPUT THE CHARACTER IN CHAR TO 
!                     TERMINAL. OUTPUT IS SUPPRESSED IF A COMMAND
!                     FILE IS PRESENT.
!  
!  INPUT:             CHAR CONTAINS CHARACTER TO BE OUTPUT
!
!  OUTPUT:            NONE
!
!  ERRORS DETECTED:   NONE
!
!  ROUTINES CALLED:   NONE
!
%BOUT(CHAR)
       TTY _ CHAR
!*     IF NOT CFLNO THEN TTY_CHAR
       RETURN
END BOUT


!
!  NAME:              OUTNO(X)
!**** THIS ROUTINE NO LONGER SUPPRESSES OUTPUT IF A COMMAND FILE IS 
!**** PRESENT AS PER CROSSLEY INSTRUCTIONS
!
!  FUNCTION:          TO CONVERT THE BINARY NUMBER IN X TO ASCII 
!                     NOTATION (BASE 10) AND OUTPUT IT TO THE TERMINAL.
!                     OUTPUT IS SUPPRESSED IF A COMMAND FILE IS PRESENT.
!
!  INPUT:             X CONTAINS NUMBER TO BE CONVERTED
!
!  ROUTINES CALLED:   NONE
!
!  ERRORS DETECTED:   NONE
!
%OUTNO(X)
!*     IF NOT CFLNO THEN \BRS 36(X,10,1)

       \BRS 36(X,10,1)

       RETURN
END OUTNO
!  SET UP ROUTINES TO DIRECT OUTPUT TO TTY AND CLOSE FILES IF AN ERROR
!  OCCURS WHEN EXECUTING FROM A COMMAND FILE

TABLE BERP[0]

!
!  NAME:              BCLOS
!
!  FUNCTION:          CLOSES ALL FILES IF A COMMAND FILE IS 
!                     PRESENT.
!
!  INPUT:             NONE
!
!  OUTPUT:            NONE
!
!  ERRORS DETECTED:   NONE
!
!  ROUTINES CALLED:   NONE
!
%BCLOS
       IF NOT CFLNO THEN RETURN
       BERP_1
       CFLNO_0
       \BRS 17
       RETURN
END    BCLOS



!
!  NAME:              BERX
!
!  FUNCTION:          TO ABORT PROGRAM TO EXECUTIVE LEVEL IF BERP
!                     FLAG HAS BEEN SET BY ROUTINE BCLOS.
!
!  INPUT:             NONE
!
!  OUTPUT:            NONE
!
!  ERRORS DETECTED:   NONE
!
!  ROUTINES CALLED:   NONE
!
%BERX
       IF NOT BERP THEN RETURN
       \BRS 10
       RETURN
END    BERX

SURVEY ** FICHE/FRAME BREAK *****
/CPAVGLOB:SIMP/ SYMSORT

SYM.  PG.LN. IDENT.

!       3 17 !!!     !       3  1 !!!     !       2 34 !!!     !       2 33 !!!     
!       2 23 !!!     !       2 22 !!!     !       2  8 !!!     !       2  7 !!!     
!       2  6 !!!     !       2  5 !!!     !!!     1 13 !!!     !!!     1  8 !!!     
!*      2 13 !!!     !****   2 20 !!!     !****   2 19 !!!     !****   2  3 !!!     
!****   2  2 !!!     !LM!    3 15 !!!     !LM!    2 38 !!!     !LM!    2 18 !!!     
!M!     3 21 !!!     !M!     3 20 !!!     !M!     3 19 !!!     !M!     3 18 !!!     
!M!     3 16 !!!     !M!     3  5 !!!     !M!     3  4 !!!     !M!     3  3 !!!     
!M!     3  2 !!!     !M!     2 39 !!!     !M!     2 26 !!!     !M!     2 25 !!!     
!M!     2 24 !!!     !M!     2 21 !!!     !M!     2 11 !!!     !M!     2 10 !!!     
!M!     2  9 !!!     !M!     2  4 !!!     !M!     1 39 !!!     !M%BER  3 22 !!!     
!MM!LM  2  1 !!!     ------  1 17 !!!     END     3 25 !!!     
END     3 11 !!!     END     2 32 !!!     END     2 15 !!!     END     1 38 !!!     
FIND    1 15 !!!     GLOBAL  1 11 !!!     GLOBAL  1 10 !!!     GLOBAL  1  5 !!!     
GLOBAL  1  4 !!!     GLOBAL  1  3 !!!     MM%BCL  3  6 !!!     TABLE   2 36 !!!     
_M%BOU  2 12 !!!     _M%OUT  2 27 !!!     _SWAPI  1 19 !!!     
SURVEY ** FICHE/FRAME BREAK *****
/CPAVGLOBAL:SRCE/
GLOBAL IDENT
BEG EQU *

*  SUPERGLOBAL SECTION

       BSS 1

$CFLNO BSS 1     (COMMAND FILE NO.)
$CMFLG BSS 1
$TEL   BSS 1
$DIC   BSS 1
$INTRFL BSS 1
$SFLNO BSS 1
$BFLNO BSS 1

*   DICTIONARY GLOBALS

$DICVERS  BSS 1
$NQUES BSS 1
$CDPLST BSS 1
$CDPLND BSS 1
$LLBPLST BSS 1
$LLBPLND BSS 1
$QCBADR  BSS 1
$NAMADR BSS 1
$QSIZE  BSS 1
$QVERS  BSS 1
$FMT   BSS 1
$NMCRD BSS 1
$QNOPOS BSS 1
$QNOLEN BSS 1
$CDNOPOS BSS 1
$CDNOLEN BSS 1

$TCTR BSS 1



*   RELABELING VARIABLES
$RL1 BSS 1
$RL2 BSS 1
$COMRL1 BSS 1
$COMRL2 BSS 1
$MAJRL1 BSS 1
$MAJRL2 BSS 1
$TCORL1 BSS 1
$TCORL2 BSS 1
$TABRL1 BSS 1
$TABRL2 BSS 1
$PRERL1 BSS 1
$PRERL2 BSS 1
$IMPRL1 BSS 1
$IMPRL2 BSS 1
$GENRL1 BSS 1
$GENRL2 BSS 1
$STARL1 BSS 1
$STARL2 BSS 1

*     STARTING ADDRESSES

$PRESTR BSS 1
$PREST  EQU PRESTR
$TCOMST BSS 1
$TABUST BSS 1
$MAJST  BSS 1
$GENST BSS 1
$IMPST BSS 1
$STASTR BSS 1
$NMPAGE BSS 1
$QCBPAGE BSS 1

END EQU *
       BSS BEG-END
       FRGT END,BEG
       END
SURVEY ** FICHE/FRAME BREAK *****
/CPAVGLOBAL:SRCE/ SYMSORT

SYM.  PG.LN. IDENT.

BEG     1  2 GLOBAL  BFLNO   1 14 GLOBAL  CDNOLE  1 33 GLOBAL  
CDNOPO  1 32 GLOBAL  CDPLND  1 21 GLOBAL  CDPLST  1 20 GLOBAL  CFLNO   1  8 GLOBAL  
CMFLG   1  9 GLOBAL  COMRL1  2  3 GLOBAL  COMRL2  2  4 GLOBAL  DIC     1 11 GLOBAL  
DICVER  1 18 GLOBAL  END     2 33 GLOBAL  FMT     1 28 GLOBAL  GENRL1  2 15 GLOBAL  
GENRL2  2 16 GLOBAL  GENST   2 27 GLOBAL  IMPRL1  2 13 GLOBAL  IMPRL2  2 14 GLOBAL  
IMPST   2 28 GLOBAL  INTRFL  1 12 GLOBAL  LLBPLN  1 23 GLOBAL  LLBPLS  1 22 GLOBAL  
MAJRL1  2  5 GLOBAL  MAJRL2  2  6 GLOBAL  MAJST   2 26 GLOBAL  NAMADR  1 25 GLOBAL  
NMCRD   1 29 GLOBAL  NMPAGE  2 30 GLOBAL  NQUES   1 19 GLOBAL  PRERL1  2 11 GLOBAL  
PRERL2  2 12 GLOBAL  PREST   2 23 GLOBAL  PRESTR  2 22 GLOBAL  QCBADR  1 24 GLOBAL  
QCBPAG  2 31 GLOBAL  QNOLEN  1 31 GLOBAL  QNOPOS  1 30 GLOBAL  QSIZE   1 26 GLOBAL  
QVERS   1 27 GLOBAL  RL1     2  1 GLOBAL  RL2     2  2 GLOBAL  SFLNO   1 13 GLOBAL  
STARL1  2 17 GLOBAL  STARL2  2 18 GLOBAL  STASTR  2 29 GLOBAL  TABRL1  2  9 GLOBAL  
TABRL2  2 10 GLOBAL  TABUST  2 25 GLOBAL  TCOMST  2 24 GLOBAL  TCORL1  2  7 GLOBAL  
TCORL2  2  8 GLOBAL  TCTR    1 35 GLOBAL  TEL     1 10 GLOBAL  
SURVEY ** FICHE/FRAME BREAK *****
/CPAVIMP1:SIMP/
!!! IMP BODY OF "TABLEAU"PROCESSING
!
! VERSION CONVERTED TO BILINGUAL 5/74 BY B. THORNQUIST
!

DEF BI(ENGLISH,FRENCH) AS ENGLISH


FIND %TABOUT,%CMND

FIND %BOUT,%OUTNO,%BCLOS,%BERX
!!!









NOTE   CARLA... SIZE HAS BEEN REDUCED TO 155 INSTEAD OF 200 FOR TABLE PROCESS.


DEF CLOSE(X) AS \BRS 20(X)
DEF SSSIZE AS 140  !********** CORRESPONDS TO S IN /CPAVIMPG:SRCE/
DEF SSIZE AS 155   !********** CORRESPONDS TO D IN /CPAVIMPG:SRCE/
!DEF OUTNO(X) AS \BRS 36 (X,10,1)

FIND   %SWAPIN
FIND %CARSIZE,%TABID,%STAT
FIND %FINIR,%SUBSTR
FIND %ARM
FIND    %READ,%SCAN,%EQUAL,%VAL,%WRITE,%ACCEPT,%FSCAN
FIND   %FDIV,%FMUL,%FSUB,%FLOAT,%FADIT
FIND %NULSTR
FIND   %OUTNUM
FIND %TITL,%COLTTL,%PCNTCK,%VERPGE,%RWTTL
FIND %DISPLAY
FIND %LENGTH,%LEFT       !STRING FUNCTIONS!
FIND %TRNSTR
FIND %YESNO     !ACCEPT FROM TTY A YES OR NO ANSWER!
FIND      %CAROUT
FIND  %ADDSTR,%GTPT
FIND %STRNG
FIND %CORCO
FIND  %OUTCL1,%OUTCL2
FIND    %SQRT
FIND %PACK6
FIND %PERCNT,%AVRGE
FIND %FLSTR,%HIST

FIND CHI2FL,STASTR,STARL1,STARL2,DF,RL1,RL2
FIND PCHFLG
FIND QNAME()
FIND BUFF(0:1),NEWBUF(0:1)
FIND STUDY(0:1)
FIND TOKEN(0:24),CURPOS,TYPE,VALUE   !SCANER VARIABLES!
FIND TSTR(0:1)
FIND TCNT,TCB(0:399),TBL(3000)
FIND ROWAVG(400),COLAVG(),ROWSD(400),COLSD()

FIND ROWSE(430),COLSE()    ! ARRAYS FOR STD ERROR

FIND RRESPS(SSIZE),CRESPS(),RRSPND(SSIZE),CRSPND()
FIND XTOT,YTOT,DKTOT(200),TPTR,ROW,COL,FLTRNO
FIND NQUES,QCBLEN,QCBBEG,FLR(5),BASADR
FIND BASNAM(0:10)
FIND TLINE1(400)
FIND TLINE2(400)
FIND AUX(2)
FIND NCELLS,RNAME(0:10),CNAME(0:10),BTITL(0:13)
FIND CC(0:1)
FIND CLHEAD(),RWHEAD(0:799)
FIND BLNK6(0:1)
FIND BLNK11(0:3)
FIND BLNK12(0:4)
FIND VALID(200)
FIND FHALF(0:1)
FIND F10(0:1),F100(0:1)
FIND DATE(0:5)

FIND IMPRL1,NMPAGE,QCBPAGE
LOCAL PARSTR(0:2)
LOCAL LFSTR
FIND BLKNUM,OLDBLK,LASADR,OLDTCB
FIND   DIC,INTRFL,LF2
FIND OFL
FIND RESTOT,ZROROW,ZROCOL,HORSTA,VERSTA,CRSTOT
FIND NCOLS,NROWS,COLPGE,ROWPGE,NCANS,NRANS,RTYP,CTYP,RHDPT,CHDPT
FIND RMIN,CMIN
FIND ZONE
FIND FRMFLG,CORFLG,PCNT1,PCNT2,PCNT3,RWMEAN,CLMEAN,HSFLG,CNTFLG
FIND T
FIND EMPTAB
FIND RCODES,CCODES,NVAL
FIND DBLROW,TBLROW
FIND CODE,HPNT
FIND VCNT,HCNT,EFFEC,RCNT
FIND SYMBL
FIND RCODP,CCODP
FIND CRLTMP
FIND FPAGES
FIND TEL

FIND WTNO

LOCAL  I,J,K,L,M,N,R
LOCAL  PT1,PT2
LOCAL  SMBL,CAR
LOCAL DK,S,Y,DIVSR
LOCAL  ENDC
LOCAL P,C !CARLA FORGOT THEM OH THE BAD GIRL!

FIND %GETNAM

GLOBAL MULFLG  !  FLAG FOR MULTIPLE RESPONSE QUESTION
GLOBAL MOYEN:,PRCNTS:,FORMAT:,CORL:,CHI2: ! MOVED FROM IMP

GLOBAL ESCAPE:,QUIT:,BADDIC:,NOINT:,BADINT:,HISGRM:
GLOBAL  %IMP1

DEF    MXQUES AS 512-48
DEF    COLWTH AS 12
DEF   INP AS 1
DEF     OUTP AS 0
DEF       SYMB    AS 3
DEF    FIXLEN AS 19
DEF    CLEAR(X,Y) AS MOVE Y FROM ALL 0 TO X
DEF NOTYPES AS 10
!***** FROM IMP
FIND SYNERR:
TABLE PCOP(0:1) [BI("RESPONDENTS","REPONDANTS"),BI("RESPONSES","REPONSES")]

DEF PROMPT(X) BY
       DISPLAY(X,0,0)
       READ(@TEL)
ENDM PROMPT

DEF    BIN AS 2
DEF    NTY AS 2
FIND %SHORT
DEF    ETY AS 5
DEF    ATY AS 1



!******
LOCAL QZ

!ENDDEC!

%IMP1
       QZ_CARRET

       LFSTR_OCT 155*OCT 200000+OCT 177400; ADDSTR(BI("BY","PAR"),  &
                    @LFSTR,@PARSTR)
       IF VALUE<1 THEN GO BADNUM
       IF OFL>2 THEN [DISPLAY(BI("TABLE: ","TABLEAU: "),1,0); OUTNO(VALUE)]

!GET VARIOUS TCB VALUES!



GTBLK: [BLKNUM;T]_(VALUE-1) DIVMOD 20  ! GET BLOCK AND TABLE NO. !
       IF (OLDBLK=BLKNUM) AND (OLDTCB=OLDBLK) THEN GO GETAB
       K_BLKNUM*(3401*3)
       IF K>=LASADR THEN GO BADNUM
       \SCP(INTRFL,K,GO BADINT)
       OLDBLK_OLDTCB_-1    !JUST IN CASE HE ESCAPES DURING BIO!
       \BIO(INTRFL,3401,,@TCNT,GO BADINT)
       OLDBLK_OLDTCB_BLKNUM
GETAB: IF TCNT>=T+1 THEN GO OUT1
BADNUM: BCLOS;  DISPLAY("TAB. ",1,0); OUTNO (VALUE);BOUT($?); BERX
       RETURN 3    !GO CMND   ERROR INDICATED, GO TO COMMAND

OUT1:  TPTR_   TCB((20*17)+T)  ! POINTER TO TABLE !
       DEC TPTR
       NROWS_  TCB((20*14)+T)  ! NUMBER OF ROWS(INCLUDING ALL OPTIONS) !
!   SET UP FLOATING ARRAYS FOR COLS RELATIVE TO RAW ARRAYS

LOCAL N1,N2,N4
       N4_2*N2_2*N1_NROWS+1
       COLSE _ @ROWSE(N2)   !* STD ERROR ARRAY
       COLAVG_@ROWAVG(N2)
       COLSD _@ROWSD(N2)
       CRESPS_@RRESPS(N1)
       CRSPND_@RRSPND(N1)
       CLHEAD_@RWHEAD((2*N4)+8)   !******

       NCOLS_  TCB((20*15)+T)
       ROW_    TCB((20*2)+T)
       COL_    TCB((20*3)+T)  ! COL NUMBER (IF 0 THIS IS MARGINAL TABLE !
       WTNO_BYT(TCB(20+T),12,12)
       FLTRNO_ TCB(T)
       NRANS_  TCB((20*6)+T)
       NCANS_  TCB((20*7)+T)
       RTYP _  TCB((20*4)+T)
       CTYP _  TCB((20*5)+T)
       RCODP_  TCB((20*8)+T)  ! ROW QUESTION CODE POINTER  !
       CCODP_  TCB((20*9)+T)   ! COL QUESTION CODE POINTER  !
       RHDPT_  TCB((20*18)+T)
       CHDPT_  TCB((20*19)+T)
       RMIN_   TCB((20*10)+T)
       CMIN_   TCB((20*11)+T)
       PT1_PT2_CHPT(@DATE,-1)
       \BRS 91 (PT1,PT2)
       CH(DATE,12)_EOLIT


!IF HISTOGRAM DEMANDED CHECK IF OK!

       IF (CORFLG AND (COL=0 OR NRANS>1 OR NCANS>1)) OR &
       NOT CORFLG THEN CRLTMP_0 ELSE CRLTMP_1
       MULFLG_0
       IF (CORFLG AND (COL=0 OR NRANS>1 OR NCANS>1)) THEN MULFLG_1
!*******
       IF HSFLG=0 THEN GO CK1
               IF COL#0 THEN &
          [DISPLAY(BI("TABLE ","TABLEAU "),1,0);OUTNO(VALUE); DISPLAY(" NON-MARGINAL",0,0) &
               ; RETURN 3 !GO CMND!]
               EMPTAB_0
               SYMBL_$*
               GO TOTS

!CHECK IF ALL FLAGS OFF AND IF THIS IS THE CASE RETURN TO CMND!

CK1:   IF NOT CNTFLG AND NOT PCNT1 AND NOT PCNT2 AND NOT PCNT3 &
       AND NOT RWMEAN AND NOT CLMEAN THEN EMPTAB_1 &
               ELSE [EMPTAB_0; GO TOTS]
      IF NOT CRLTMP AND CHI2FL=0  THEN [BOUT($?);BOUT(CARRET);RETURN 3 !GO CMND!]

!ACCUMULATE TOTALS:RESPONSE,RESPONDANTS,ETC..!

TOTS:  CLEAR (DKTOT+1,SSSIZE)
       CLEAR(RRESPS+1,SSIZE)

       CLEAR(RRSPND+1,SSIZE)

       CLEAR(VALID+1,SSSIZE)
       CRSTOT_RESTOT_ZROROW_ZROCOL_HORSTA_VERSTA_XTOT_YTOT_0

!ROW RESPONDANT TOTAL ARRAY!

       J_1
TL1:   RRSPND(J)_TBL(TPTR+(J*NCOLS))
       XTOT_XTOT+RRSPND(J)  !  INCREMENT TOTAL ROW RESPONDANTS !
       IF RRSPND(J)=0 &
               THEN ZROROW_ZROROW+1  ! INCREMENT NO. OF ZERO ROWS !
       IF INC J<= NROWS-3 &
               THEN GO TL1
       XTOT_XTOT-TBL(TPTR+((NROWS-3)*NCOLS)) ! SUB REJECTS FROM TOTAL !
       IF COL=0 &
               THEN [VALID(1)_1; GO GTCM]

!COL RESPONDANT TOTAL ARRAY!

       J_1; NVAL_1
TL2:   CRSPND(J)_TBL(TPTR+((NROWS-1)*NCOLS)+J)
       IF CRSPND(J)=0 &
               THEN [ZROCOL_ZROCOL+1; GO EL2]
       VALID(NVAL)_J; NVAL_NVAL+1  ! FLAG AS VALID COLUMN  !
       YTOT_YTOT+CRSPND(J)
EL2:   IF INC J<=NCOLS-3 THEN GO TL2
       YTOT_YTOT-TBL(TPTR+(NCOLS*NROWS)-3)

!COL RESPONSE TOTAL ARRAY!

       I_1   !CONTROLS COL LOOP!
TL3I:  J_0   !CONTROLS ROW LOOP!
TL3J:  K_TBL(TPTR+(J*NCOLS)+I)
       CRESPS(I)_CRESPS(I)+K
       IF INC J<=NROWS-6 &
               THEN GO TL3J
!  PICK UP 'NO ANSWER' TOTAL FOR COLUMN !
       DKTOT(I)_TBL(TPTR+((NROWS-5)*NCOLS)+I)
!  ADD 'NO ANSWERE' TOTAL TO COL RESPONSE TOTAL !
       CRESPS(I)_CRESPS(I)+DKTOT(I)
       IF INC I <= NCOLS-3 &
               THEN GO TL3I

!TOTAL RESPONSES FOR TABLE!

       J_1
TL4:   RESTOT_RESTOT+CRESPS(J)
       IF INC J<= NCOLS-4 THEN GO TL4
       J_1
TL6:   CRSTOT_CRSTOT+CRESPS(J)-DKTOT(J)
       IF INC J<= NCOLS-5 THEN GO TL6

!ROW RESPONSE TOTAL ARRAY!

       I_1
TL5I:  J_1
TL5J:  K_TBL(TPTR+((I-1)*NCOLS)+J)
       RRESPS(I)_RRESPS(I)+K
       IF INC J <= NCOLS-4 &
               THEN GO TL5J
       IF INC I <= NROWS-3 &
               THEN GO TL5I

!GET MEAN BY ROW!

       IF RWMEAN=0 THEN GO GTCM
!  INCREMENT NUMBER OF OPTIONAL ROWS  !
       HORSTA_HORSTA+2; NCELLS_TPTR+(NCOLS*NROWS) !****
       I_1
RM1:   K_TPTR+(I*NCOLS); DK_TBL(K-4)
!      SIGMA (ROW VALUES)**2
       S_ TBL(K-2)  !  SIGMA(ROW VALUES)**2

       Y_ TBL(K-1)
       DIVSR_RRESPS(I)-DK
       AVRGE(Y,S,DIVSR,@ROWAVG(I+I-1),@ROWSD(I+I-1),@ROWSE(I+I-1))
       IF INC I<= NROWS-3 &
               THEN GO RM1
       DK_TBL(NCELLS-4)
       S _TBL(NCELLS-2)
       Y_ TBL(NCELLS-1)
       DIVSR_YTOT-DK
       J_NROWS-2
       AVRGE(Y,S,DIVSR,@ROWAVG(J+J-1),@ROWSD(J+J-1),@ROWSE(J+J-1))

!GET MEAN BY COL!

GTCM:  IF CLMEAN=0 &
               THEN GO GTHD
       VERSTA_VERSTA+3  !**NCREMENT NO. OF OPTIONAL COLUMNS !
       IF COL = 0 &
               THEN [J_1; GO CM2]
       J_NCOLS-1
       I_1
CM1:   S_ TBL(TPTR+(NCOLS*(NROWS-3))+I)  ! SIGMA(COL VALUES)**2 !
       Y_ TBL(TPTR+(NCOLS*(NROWS-2))+I)   ! SIGMA(COL VALUES)   !
       DIVSR_ CRESPS(I)-DKTOT(I)  !  NO. OF COL RESPONSES  !
       AVRGE(Y,S,DIVSR,@COLAVG(I+I-1),@COLSD(I+I-1),@COLSE(I+I-1))
       IF INC I <= NCOLS-3 &
               THEN GO CM1
CM2:   DK_TBL(TPTR+(NCOLS*(NROWS-4)))  ! DK = DONT KNOW RO NO ANSWER  !
       S _TBL(TPTR+(NCOLS*(NROWS-2)))
       Y_ TBL(TPTR+(NCOLS*(NROWS-1)))
       DIVSR_XTOT-DK  !  ROW RESPONDENTS - NO ANSWERS !
       AVRGE(Y,S,DIVSR,@COLAVG(J+J-1),@COLSD(J+J-1),@COLSE(J+J-1))
!  SUBSCRIPT OF J+J BECAUSE 2 WDS REQUIRED FOR FLOATING PT NO.  !

!GET ELEMENT FOR TABLE TITLE: ROW NAME, COL NAME, BASE NAME!

GTHD:  \BRS 113
       I_BYT(IMPRL1,6,12)
       SWAPIN(NMPAGE,1)
       QNAME_OCT 4000
       GETNAM(ROW,@RNAME)
       IF COL THEN DO
               GETNAM(COL,@TSTR)
               ADDSTR(@PARSTR,@TSTR,@CNAME)
       END ELSE  CH(CNAME)_EOLIT

GTBS:  IF FLTRNO THEN DO
               GETNAM(FLTRNO+MXQUES,@BASNAM)
       END ELSE BASNAM(0)_-1   !  COSTS LESS CODE FOR EOLIT
       SWAPIN(I,1)
       QNAME_OCT 34000  ! NORMAL POSITION
       \BRS 114

!GET CORRELATION COEFFICIENT IF FLAG SET AND REQUIREMENT SATISFIED!

GTCOR: IF CRLTMP THEN DO
               CORCO(TPTR,NROWS,NCOLS,CRSTOT,@CC)
       END

!DETIRMINE NUMBER OF STATISTICS ROWS AND COLS!

       RCODES_NROWS-AUX(1)
       VERSTA_VERSTA+4
       IF NOT FRMFLG THEN DO
!              COMPUTE PAGE LENGTH    !
               ROWPGE_FIXLEN+((DBLROW+1)*(RCODES+VERSTA-ZROROW))
       END

       TBLROW_(ROWPGE-FIXLEN)/(DBLROW+1) !NUMBER OF TABLE ROWS PER PAGE !

       IF COL=0 THEN DO
!        COL = = IMPLIES MARGINAL TABLE  !
               CCODES_0
               HORSTA_HORSTA+1
               TRNSTR(BI("RESPONSES  ","REPONSES  "),@CLHEAD(0))
               TRNSTR("           ",@CLHEAD(4))
               RETURN 2   ! NO COLS (MARGINAL)
       END

       CCODES_NCOLS-AUX(2)
       HORSTA_HORSTA+4

!INCLUDE STATISTICS COLS IN VALID COL ARRAY!

       I_CCODES+3
ST1:   VALID(NVAL)_I
       IF INC I<= HORSTA+CCODES &
               THEN [INC NVAL; GO ST1]

       RETURN 1   !NORMAL RETURN
END IMP1



       




ESCAPE: ARM(ESCAPE)
       \BRS 11 (,,-1); \BRS 29
       BUFF(0)_NEWBUF(0)_-1
       BOUT(QZ); GO CMND


!QUIT!

QUIT:  \BRS 113
       IF OFL>2 THEN DO
             \RSP(OFL); \PCE(OFL); \ZRO
             CLOSE(OFL); OFL_1
       END
       \BRS 43; \STP (RL1); [6,6,6,6]*[,I,J,K]_RL2; \BRS 121(I); \BRS 121(J);\BRS 121(K)
       EXIT


BADDIC: BCLOS;         DISPLAY(BI("ERROR IN DICTIONARY FILE.",   &
                "ERREUE DANS FICHIER DICTIONNAIRE"),1,1)
               BERX
               EXIT

NOINT: GO CMND

BADINT: BCLOS;  DISPLAY(BI("ERROR IN INTERMEDIARY FILE",  &
              "ERREUR DANS FICHIER DICTIONNAIRE"),1,1); BERX
               EXIT


HISGRM:        HSFLG_1; GO TABOUT



MOYEN: SCAN
       IF TYPE=ETY THEN GO MOY1
       CLMEAN_RWMEAN_0
       IF SHORT(BI("NONE","AUCUNE")) THEN GO CMND
MM2A:  IF CH(@TOKEN)=$, THEN GO MM2S
       IF TYPE=ETY THEN GO CMND
       IF TYPE#ATY THEN GO SYNERR
       IF SHORT(BI("ROW","LIGNE")) THEN [RWMEAN_1; GO MM2S]
       IF SHORT(BI("COLUMN","COLONNE")) THEN [CLMEAN_1; GO MM2S]
       GO SYNERR

MM2S:  SCAN; GO MM2A


MOY1:  DISPLAY(BI("BY ROW? ","PAR LIGNE? "),0,0)
       READ(@TEL)
       RWMEAN_YESNO
       DISPLAY (BI("BY COL? ","PAR COL.? "),0,0)
       READ(@TEL)
       CLMEAN_YESNO
       GO CMND


!
!
!     P E R C E N T A G E  C O M M A N D
!
PRCNTS: SCAN


       IF TYPE=ATY THEN GO PTYP
       IF TYPE=ETY THEN DO
              PROMPT(BI("RESPONDENT, RESPONSES, OR NONE? ", &
                "REPONDANT, RESPONSES, OU AUCUN? "))
                   GO PRCNTS
       END

PTYP:  I_0
TYP1:  NULL
       IF SHORT(PCOP(I)) THEN [INC I; GO PPAR]
       IF INC I<=1 THEN GO TYP1

       IF SHORT(BI("NONE","AUCUN")) THEN DO
               PCNT1_PCNT2_PCNT3_0
               GO CMND
       END ELSE GO SYNERR

PPAR:  SCAN; IF TYPE#ETY THEN GO PP2
       DISPLAY (BI("BY ROW? ","PAR LIGNE? "),0,0)
       READ(@TEL)
       J_YESNO
       IF J THEN PCNT1_I ELSE PCNT1_0
       DISPLAY (BI("BY COL.? ","PAR COL.? "),0,0)
       READ(@TEL)
       J_YESNO
       IF J THEN PCNT2_I ELSE PCNT2_0
       DISPLAY(BI("BY TOTAL? ","PAR EFFECTIF? "),0,0)
       READ(@TEL)
       J_YESNO
       IF J THEN PCNT3_I ELSE PCNT3_0
PPN:   IF PCNT2 OR PCNT3 THEN DBLROW_2 ELSE DBLROW_1
       GO CMND

PP2:   PCNT1_PCNT2_PCNT3_0

PP2A:  IF CH(@TOKEN)=$, THEN GO PP2S
       IF TYPE=ETY THEN GO PPN
       IF TYPE#ATY THEN GO SYNERR

       TABLE POPTS(0:2)[BI("ROW","LIGNE"),BI("COLUMN","COLONNE"), &
       BI( "TOTAL","EFFECTIF")]

       K_0
PP2B:  IF SHORT(POPTS(K)) THEN GO PP2C
       IF INC K<=2 THEN GO PP2B ELSE GO SYNERR

PP2C:  DO K+1 OF 3
       1: PCNT1_I
       2: PCNT2_I
       3: PCNT3_I
       END
       
PP2S:  SCAN; GO PP2A

!
!  F O R M A T  C O M M A N D
!
FORMAT: SCAN
       IF CH(@TOKEN)=$, THEN GO FORMAT
       IF TYPE=ETY THEN DO
       F1: NULL
               PROMPT(BI("WIDTH: ","LARGEUR: "))
               GO FORMAT
       END
       IF TYPE=NTY THEN DO
               ZONE_VALUE
               IF ZONE<24 OR ZONE>144 THEN DO
                    DISPLAY(BI("BETWEEN 24 AND 144!",  &
                     "ENTRE 24 ET 144"),1,1); GO F1
               END
       F11:    COLPGE_(ZONE/COLWTH)-1
               GO F2
       END
       IF TYPE=ATY THEN DO

               IF SHORT("STANDARD") THEN [ZONE_72; GO F11]
               GO SYNERR
       END
       GO SYNERR

F2:    SCAN
       IF CH(@TOKEN)=$, THEN GO F2
       IF TYPE=ETY THEN DO
       F22: NULL
               PROMPT(BI("LENGTH: ","LONGUEUR: "))
               GO F2
       END
       IF TYPE=NTY THEN DO
               ROWPGE_VALUE
               IF ROWPGE<35 THEN [DISPLAY(BI("LENGTH > 35!",  &
                 "LONGUEUR > 35!"),1,1); GO F22]
       F3:     FRMFLG_1
               GO F4
       END
       IF TYPE=ATY THEN DO
               IF SHORT("STANDARD") THEN [ROWPGE_66; GO F3]
               IF SHORT(BI("FREE","LIBRE")) THEN [FRMFLG_0; GO CMND]
       GO SYNERR
       END

F4:    SCAN
       IF TYPE#ETY THEN GO SYNERR
       GO CMND






!
!
!  C O R R E L A T I O N    C O M M A N D
!
!SET CORELATION FLAG!

CORL:   SCAN
       IF TYPE = ETY THEN [CRLTMP_1; CORFLG_1; GO CMND]
       IF SHORT("NONE") THEN [CRLTMP_0; CORFLG_0; GO CMND]
       GO SYNERR


!SET HEAD COUNT FLAG!





!
!
!   C H I - S Q U A R E     C O M M A N D 
CHI2:  SCAN
       IF TYPE=ETY THEN DO
               PROMPT(BI("TABLE, ROWS, COLUMNS, OR NONE? ",  &
                               "TABLEAU, LIGNES, COLONNES OU AUCUN? "))
               GO CHI2
       END

       IF SHORT(BI("TABLE","TABLEAU")) THEN DO
               CHI2FL_-1
               GO C2P3
       END ELSE IF SHORT(BI("ROWS","LIGNES")) THEN DO
               I_1
               GO C2PR
       END ELSE  IF SHORT(BI("COLUMNS","COLONNES")) THEN DO
               I_0
               GO C2PR
       END ELSE IF SHORT(BI("NONE","AUCUN")) THEN [CHI2FL_0; GO CMND]
       GO SYNERR

C2PR:  SCAN
       IF TYPE=ETY THEN DO
               PROMPT(BI("WHICH ONES? ","LESQUELLES? "))
               GO C2PR
       END

       IF CH(@TOKEN)=$, THEN GO C2PR
       IF TYPE # NTY THEN GO SYNERR
       J_VALUE-1

C2P2: SCAN
       IF TYPE=ETY THEN DO
               PROMPT(BI("THE OTHER? ","L'AUTRE? "))
               GO C2P2
       END

       IF CH(@TOKEN)=$, THEN GO C2P2
       IF TYPE#NTY THEN GO SYNERR
       K_VALUE-1

       CHI2FL_[1,7,8,8]*[I,0,J,K]

C2P3:  SCAN; IF TYPE=ETY THEN [PCHFLG_0; GO CMND]
       IF CH(@TOKEN)=$, THEN GO C2P3
       IF TYPE#ATY THEN GO SYNERR
       IF NOT SHORT(BI("FOLDED","PLIEE")) THEN GO SYNERR

       PCHFLG_1
       GO CMND

       




SURVEY ** FICHE/FRAME BREAK *****
/CPAVIMP1:SIMP/ SYMSORT

SYM.  PG.LN. IDENT.

!      10 14 !!!     !      10  7 !!!     !       9 14 !!!     !       8 18 !!!     
!       8 14 !!!     !       7 25 !!!     !       7 23 !!!     !       5  7 !!!     
!*****  4  1 !!!     !CHECK  6 13 !!!     !COL    7 15 !!!     !COL    7  4 !!!     
!DEF    1 15 !!!     !GET    9 35 !!!     !GET    9 16 !!!     !GET    8 33 !!!     
!GET    8 11 !!!     !GET    4 27 !!!     !IF     5 38 !!!     !INCLU 10 25 !!!     
!LM!M! 15 27 !!!     !LM!M! 15 12 !!!     !LM!M! 12 18 !!!     !M!    13 37 !!!     
!M!     1  2 !!!     !M!SET 15 13 !!!     !MMDEF  1  3 !!!     !ROW    7 39 !!!     
!ROW    6 30 !!!     !SET   15 21 !!!     !TOTAL  7 30 !!!     ;MFORM 13 38 !!!     
;MPRCN 12 19 !!!     BADDIC 11 18 !!!     BADINT 11 25 !!!     
BADNUM  5  1 !!!     C2P2:  16 18 !!!     C2P3:  16 30 !!!     C2PR:  16  8 !!!     
CHI2:  15 28 !!!     CK1:    6 15 !!!     CM1:    9  3 !!!     CM2:    9  9 !!!     
CORL:  15 15 !!!     DEF     4 14 !!!     DEF     4 13 !!!     DEF     4 11 !!!     
DEF     4 10 !!!     DEF     4  5 !!!     DEF     3 39 !!!     DEF     3 38 !!!     
DEF     3 37 !!!     DEF     3 36 !!!     DEF     3 35 !!!     DEF     3 34 !!!     
DEF     3 33 !!!     DEF     3 32 !!!     DEF     1 14 !!!     DEF     1 13 !!!     
DEF     1 12 !!!     EL2:    7 12 !!!     END    10 33 !!!     ENDM    4  8 !!!     
ESCAPE 11  3 !!!     F2:    14 22 !!!     F4:    15  3 !!!     FIND    4 12 !!!     
FIND    4  2 !!!     FIND    3 24 !!!     FIND    3 15 !!!     FIND    3 13 !!!     
FIND    3 12 !!!     FIND    3 11 !!!     FIND    3 10 !!!     FIND    3  9 !!!     
FIND    3  8 !!!     FIND    3  7 !!!     FIND    3  6 !!!     FIND    3  5 !!!     
FIND    3  4 !!!     FIND    3  3 !!!     FIND    3  2 !!!     FIND    3  1 !!!     
FIND    2 39 !!!     FIND    2 38 !!!     FIND    2 37 !!!     FIND    2 36 !!!     
FIND    2 35 !!!     FIND    2 34 !!!     FIND    2 31 !!!     FIND    2 29 !!!     
FIND    2 28 !!!     FIND    2 27 !!!     FIND    2 26 !!!     FIND    2 25 !!!     
FIND    2 24 !!!     FIND    2 23 !!!     FIND    2 22 !!!     FIND    2 21 !!!     
FIND    2 20 !!!     FIND    2 19 !!!     FIND    2 18 !!!     FIND    2 17 !!!     
FIND    2 16 !!!     FIND    2 15 !!!     FIND    2 14 !!!     FIND    2 13 !!!     
FIND    2 11 !!!     FIND    2  9 !!!     FIND    2  8 !!!     FIND    2  7 !!!     
FIND    2  6 !!!     FIND    2  5 !!!     FIND    2  4 !!!     FIND    2  3 !!!     
FIND    2  2 !!!     FIND    2  1 !!!     FIND    1 38 !!!     FIND    1 37 !!!     
FIND    1 36 !!!     FIND    1 35 !!!     FIND    1 34 !!!     FIND    1 33 !!!     
FIND    1 32 !!!     FIND    1 31 !!!     FIND    1 30 !!!     FIND    1 29 !!!     
FIND    1 28 !!!     FIND    1 27 !!!     FIND    1 26 !!!     FIND    1 25 !!!     
FIND    1 24 !!!     FIND    1 23 !!!     FIND    1 22 !!!     FIND    1 21 !!!     
FIND    1 20 !!!     FIND    1 19 !!!     FIND    1 18 !!!     FIND    1 17 !!!     
FIND    1  8 !!!     FIND    1  6 !!!     GETAB:  4 39 !!!     GLOBAL  3 30 !!!     
GLOBAL  3 29 !!!     GLOBAL  3 27 !!!     GLOBAL  3 26 !!!     GTBLK:  4 31 !!!     
GTBS:   9 28 !!!     GTCM:   8 35 !!!     GTCOR:  9 37 !!!     GTHD:   9 18 !!!     
HISGRM 11 30 !!!     LOCAL   5  9 !!!     LOCAL   3 22 !!!     LOCAL   3 21 !!!     
LOCAL   3 20 !!!     LOCAL   3 19 !!!     LOCAL   3 18 !!!     LOCAL   3 17 !!!     
LOCAL   2 33 !!!     LOCAL   2 32 !!!     M*****  6  5 !!!     MM2A:  11 38 !!!     
MM2S:  12  6 !!!     MOY1:  12  9 !!!     MOYEN: 11 34 !!!     NOINT: 11 23 !!!     
O*****  4 18 !!!     ODETIR 10  2 !!!     OUT1:   5  4 !!!     PP2:   13 16 !!!     
PP2A:  13 18 !!!     PP2B:  13 26 !!!     PP2C:  13 29 !!!     PP2S:  13 35 !!!     
PPAR:  12 39 !!!     PPN:   13 13 !!!     PTYP:  12 29 !!!     RM1:    8 17 !!!     
ST1:   10 28 !!!     TABLE   4  3 !!!     TL1:    6 33 !!!     TL2:    7  7 !!!     
TL3I:   7 18 !!!     TL3J:   7 19 !!!     TL4:    7 33 !!!     TL5I:   8  3 !!!     
TL5J:   8  4 !!!     TL6:    7 36 !!!     TOTS:   6 22 !!!     TYP1:  12 30 !!!     
UACCUM  6 20 !!!     ]ENDDE  4 20 !!!     _!!JJJ  1  9 !!!     _QUIT! 11  9 !!!     

SURVEY ** FICHE/FRAME BREAK *****
/CPAVIMP2:SIMP/
!
DEF BI(ENGLISH,FRENCH) AS ENGLISH
!
!!! IMP2   SOME SUBROUTINES FOR CPAVIMP


FIND %BCLOS,%BERX


FIND DIC
FIND %TRNSTR
GLOBAL %GETNAM,%XMOVE
!******


FIND %DISPLAY

BADDIC: BCLOS; DISPLAY(BI("ERROR IN DICTIONARY FILE.", &
        "ERREUR DANS FICHIER DICTIONNAIRE"),1,1); BERX; EXIT
%GETNAM(NUM,@NAME)

DEF DREAD(WHAT,NUM,WHERE) BY
       \SCP(DIC,WHERE,GO BADDIC)
       \BIO(DIC,NUM,,WHAT,GO BADDIC)
ENDM DREAD
DEF QQNAME(X,Y) AS QNAME(4*(X-1)+Y)
FIND QNAME()

       XMOVE(@QQNAME(NUM,0),@NAME,4)
       IF NAME#-1 THEN RETURN
       DREAD(@NAME,72,^(@NAME+1))
       RETURN
END GETNAM
%XMOVE(@A,@B,N)
LOCAL I
       I_0
L1:    ^(@B+I)_^(@A+I)
       IF INC I<N THEN GO L1 ELSE RETURN
END XMOVE
SURVEY ** FICHE/FRAME BREAK *****
/CPAVIMP2:SIMP/ SYMSORT

SYM.  PG.LN. IDENT.

!M!!!   1  2 !MDEF   BADDIC  1 13 !MDEF   DEF     1 19 !MDEF   
END     1 31 !MDEF   END     1 26 !MDEF   ENDM    1 18 !MDEF   FIND    1 20 !MDEF   
FIND    1  9 !MDEF   FIND    1  8 !MDEF   FIND    1  5 !MDEF   GLOBAL  1 10 !MDEF   
L1:     1 29 !MDEF   O*****  1 11 !MDEF   OXMOVE  1 27 !MDEF   _GETNA  1 15 !MDEF   

SURVEY ** FICHE/FRAME BREAK *****
/CPAVIMP:SIMP/
!!! EDI VERSION C
!!! FEB 21 1972
!!! JP BARASZ
!
! VERSION CONVERTED TO BILINGUAL 5/74 BY B. THORNQUIST
!

DEF BI(ENGLISH,FRENCH) AS ENGLISH


LOCAL QQ
  






       TABLE &
VERSION [BI("PRI 75101","EDI 75101")]
!.-.-.-.-.-.!


GLOBAL CMND:

FIND CMFLG
FIND %BCLOS,%BERX,%OUTNO,%BOUT
FIND %TABID,%GETNAM
FIND %GETLIST,%NXTITEM
FIND %SUBSTR
FIND %ARM
FIND    %READ,%SCAN,%EQUAL,%VAL,%WRITE,%ACCEPT,%FSCAN
FIND  %IMP1
FIND   %SWAPIN
FIND %NULSTR
FIND   %OUTNUM
FIND %TITL,%COLTTL,%PCNTCK,%VERPGE,%RWTTL
FIND %DISPLAY
FIND %LENGTH,%LEFT       !STRING FUNCTIONS!
FIND %TRNSTR
FIND %YESNO,%SHORT !ACCEPT FROM TTY A YES OR NO ANSWER!
FIND      %CAROUT
FIND  %ADDSTR,%GTPT
FIND %STRNG
FIND %CORCO
FIND  %OUTCL1,%OUTCL2
FIND    %SQRT
FIND %PACK6
FIND %PERCNT,%AVRGE
FIND %FLSTR,%HIST
!.-.-.-.-.-.!

FIND TSTR(0:72)
FIND CHI2FL,DF,CHIST1(0:1),CHIST2(0:1),CHIVAL(0:1),PCHFLG
FIND BUFF(0:1),NEWBUF(0:1)
FIND STUDY(0:1)
FIND TOKEN(0:24),CURPOS,TYPE,VALUE   !SCANER VARIABLES!
FIND TCNT,TCB(0:399),TBL(3000)
FIND ROWAVG(400),COLAVG(),ROWSD(400),COLSD()
FIND ROWSE(430),COLSE()
FIND RRESPS(200),CRESPS(),RRSPND(200),CRSPND()
FIND XTOT,YTOT,DKTOT(200),TPTR,ROW,COL,FLTRNO
FIND NQUES,QCBLEN,QCBBEG,FLR(5),BASADR
FIND BASNAM(0:10)
FIND TLINE1(400)
FIND TLINE2(400)
FIND AUX(2)
FIND NCELLS,RNAME(0:10),CNAME(0:10)
FIND CC(0:1)
FIND CLHEAD(),RWHEAD(0:799)
FIND BLNK6(0:1)
FIND BLNK11(0:3)
FIND BLNK12(0:4)
FIND VALID(200)
FIND FHALF(0:1)
FIND F10(0:1),F100(0:1)
FIND DATE(0:5)

!.-.-.-.-.-.!

FIND CFLNO    !  COMMAND FILE NO. OR 0
FIND BLKNUM,OLDBLK,LASADR,OLDTCB
FIND   DIC,INTRFL,LF2
FIND RL1,NMPAGE,QCBPAGE,RL2

FIND OFL
!     STRING PACKING FUNCTION FOR BRS 53 (CONVERT INT TO STR)
     
LOCAL QJ,Q4


FIND RESTOT,ZROROW,ZROCOL,HORSTA,VERSTA,CRSTOT
FIND NCOLS,NROWS,COLPGE,ROWPGE,NCANS,NRANS,RTYP,CTYP,RHDPT,CHDPT
FIND RMIN,CMIN
FIND ZONE
FIND FRMFLG,PCNT1,PCNT2,PCNT3,RWMEAN,CLMEAN,HSFLG,CNTFLG
FIND T
FIND EMPTAB
FIND RCODES,CCODES,NVAL
FIND DBLROW,TBLROW
FIND CODE,HPNT
FIND VCNT,HCNT,EFFEC,RCNT
FIND SYMBL

FIND RCODP,CCODP
FIND FPAGES
FIND TEL

!.-.-.-.-.-.!

!*******GLOBAL CRLTMP,CORFLG
FIND CRLTMP,CORFLG
!******
FIND ESCAPE:,QUIT:,BADDIC:,NOINT:,BADINT:,HISGRM:
GLOBAL STO:
GLOBAL PROG:
GLOBAL SYNERR:,DSPTCH:,TABOUT:
FIND MOYEN:,FORMAT:,PRCNTS:   !  MOVED TO IMP1
FIND CHI2:  !  MOVED TO IMP1
GLOBAL SOS:
GLOBAL SORTIE:
FIND CORL:

!.-.-.-.-.-.!

LOCAL LLL
LOCAL BADNUM:
LOCAL  I,J,K,L,M,N,R,S.A.FLG
LOCAL  PT1,PT2
LOCAL  SMBL,CAR
LOCAL DK,S,Y,DIVSR
LOCAL  ENDC
LOCAL P,C !CARLA FORGOT THEM OH THE BAD GIRL!

!.-.-.-.-.-.!

DEF WAIT.FORM AS IF OFL=1 THEN CAROUT(OCT 377,OFL,3)
DEF CLOSE(X) AS \BRS 20 (X)
DEF OPENI(P1,P2,BAD,FILE) BY
\BRS 64 (P1,P2,GO BAD); \STA (FILE)
ENDM OPENI
DEF OPENO(P1,P2,BAD,FILE,TYPE) BY
\BRS 65 (P1,P2,TYPE,GO BAD); \STA (FILE)
ENDM OPENO
DEF PROMPT(X) BY
      DISPLAY(X,0,0)
       READ(@TEL)
ENDM PROMPT
DEF BIN AS 2
DEF    COLWTH AS 12
DEF    NTY AS 2
DEF    ETY AS 5
DEF    ATY AS  1
DEF   INP AS 1
DEF     OUTP AS 0
DEF       SYMB    AS 3
DEF    ENDLIST AS OCT 20000000
DEF    FIXLEN AS 21
DEF   NORDRS AS 15
DEF    CLEAR(X,Y) AS MOVE Y FROM ALL 0 TO X
DEF NOTYPES AS 10
!.-.-.-.-.-.!

GLOBAL PARSTR(0:1)
TABLE STAR12 ["        *   "]
TABLE  SHEAD (0:6) [BI("NA","PDR"),BI("REJECT","REBUT"),  &
  BI("RESPONSES","REPONSES"),BI("RESPONDENTS","REPONDANTS"),  &
     BI("MEAN","MOYEN"),BI("STD. DEV.","ECART"),"STD. ERROR"]
TABLE ORDR (0:NORDRS-1) &
[BI("TABLE","TABLEAUX"),BI("DEVIATION","ECART"),BI("MEAN","MOYENNE"),BI("PERCENTAGE","POURCENTAGES"), &
 "FORMAT",BI("HELP","SOS"),"QUIT","CORRELATION", "HEADCOUNT", &
 BI("HISTOGRAM","HISTOGRAMME"),BI("OUTPUT","SORTIE"),  &
 BI("APPEND","AJOUTER"),BI("IDENTIFY","IDENTIFIER"), &
 BI("DESTROY","DETRUIRE"),"CHI2"]
TABLE PCOP (0:1) [BI("RESPONDENTS","REPONDANTS"),BI("RESPONSES","REPONSES")]
!ENDDEC!





!
PROG:  NULL  !  DISPLAY(VERSION,1,1)
       LOCAL QZ
       QZ_CARRET
       CRLTMP_0
       \BRS 113  !PREVENT ESCAPES UNTIL ALL SET UP!
       IF NOT INTRFL THEN DO
               ADDSTR(@STUDY,"'INT'",@TSTR)
               GTPT(@TSTR,@PT1,@PT2)
               OPENO(PT1+OCT 11600000,PT2,NOINT,INTRFL,BIN)
       END
       \RSP(INTRFL); \STA(LASADR)
       IF LASADR=0 THEN GO NOINT
       OLDBLK_-1
       OLDTCB_-1
       TRNSTR(BI(" BY"," PAR"),@PARSTR); CH(PARSTR)_QZ
       AUX(1)_5; AUX(2)_5; DBLROW_1; CH(BLNK6,6)_EOLIT
       TEL_CFLNO    !READ FROM COMMAND FILE OR TTY
       CH(BLNK11,11)_EOLIT; CH(BLNK12,12)_EOLIT
       FHALF(0)_OCT 37777777; FHALF(1)_OCT 77777777
    F10(0)_OCT 24000000;F10(1)_OCT 4;F100(0)_OCT 31000000;F100(1)_ OCT 7




!SET UP INITIAL VALUES!

       LOCAL Q12

       OFL_1        !OUTPUT TO TEL UNLESS USER CHANGES!

       QJ _ [3,6,6,1,8]*[3,2,6,0,OFL]
       Q4 _ [3,6,6,1,8]*[3,4,12,0,OFL]
       Q12_ [3,6,6,1,8]*[3,2,12,0,OFL]

       ZONE_72
       COLPGE_(ZONE/COLWTH)-1

!SET FLAGS TO ZERO!
       CNTFLG_1
       FRMFLG_CORFLG_PCNT1_PCNT2_PCNT3_RWMEAN_CLMEAN_0


!COMMAND MODE: PRINTS + ON TTY AND ACCEPTS ORDER!

       ARM(ESCAPE)
       \BRS 114    !ESCAPE OK NOW!
       CMFLG_0
!      IF CFLNO THEN [CMFLG_CFLNO; CFLNO_0]
!
CMND:  BOUT(QZ); BI(BOUT($P),BOUT($E)); BOUT($>)
QJ_[3,6,6,1,8]*[3,2,6,1,OFL]
Q4_[3,6,6,1,8]*[3,4,12,1,OFL]
Q12_[3,6,6,1,8]*[3,2,12,1,OFL]
       READ(@TEL)
       SCAN
       IF TYPE=ETY THEN GO CMND
       IF TYPE =ATY THEN GO DSPTCH


SYNERR: DISPLAY (BI("SYNTAX ERROR","ERREUR DE SYNTAXE"),0,1)
       GO CMND

!CHECK IF TOKEN=VALID COMMAND AND GO TO APPROPRIATE ROUTINE!

DSPTCH: NULL
       I_0
       HSFLG_0
DSP0:  IF SHORT(ORDR(I)) THEN GO DSP1

       IF INC I<= NORDRS-1 THEN GO DSP0

       GO SYNERR     ! TOKEN NOT A VALID COMMAND!

!
DSP1:  DO I+1 OF NORDRS
               1: GO TABOUT
               2: GO MOYEN
               3: GO MOYEN
               4: GO PRCNTS
               5: GO FORMAT
               6: GO SOS
               7: GO QUIT
               8: GO CORL
                9: GO HDCNT
               10: GO HISGRM
               11: GO SORTIE
               12: GO APPEND
               13:  TABID(BADINT,BADNUM,SYNERR) !PAR. ARE ERROR RETURNS!
                    GO CMND
               14:  GO DELETE
               15:   GO CHI2
               END


!PRINT TABLE ON OUTPUT FILE WITH OPTIONS APPLIED!
BADNUM:        DISPLAY(BI("INVALID TABLE NUMBER",  &
                 "NUMERO DE TABLEAUX INCORRECT"),0,1)
       GO CMND

!
!
!   
!  OUTPUT TABLE
!
TABOUT: SCAN
       IF TYPE=ETY THEN DO
               PROMPT(BI("TABLE:","TABLEAUX: "))
               GO TABOUT
       END
       IF TYPE # NTY THEN GO SYNERR
       GETLIST(@I,1,5000); IF I THEN GO SYNERR
       
NEWTAB: VALUE_NXTITEM
       IF VALUE=ENDLIST THEN GO CMND
        I_IMP1    ! CALL MAIN TABLE PROCESSING ROUTINE
       DO I OF 5
       1: GO CCC
       2: GO RHD0
       3: GO NEWTAB
       4: GO SYNERR
       5: GO TBEG
       END

!GET COL HEADINGS FROM DIC FILE!

CCC:   M_CMIN
       I_1        !LOOP CONTROL: I=1 TO NUMBER OF COL CODES!
CHD1:  CODE_ TBL(CCODP+I-1)
       K_(I-1)*8   !****
       IF CTYP=2 THEN GO CHD2 ! NO LIBS FOR CONT. TYPE
       J_CHDPT+(I*27)-24    ! LIB PTR FOR ITH CODE OF COL!
       \SCP(DIC,J,GO BADDIC)
       \BIO(DIC,8,,@CLHEAD(K),GO BADDIC)   !******

       CH(@CLHEAD(K),11)_EOLIT
       CH(@CLHEAD(K+4),11)_EOLIT !*******

       GO CHD3

CHD2:  IF CTYP=1 THEN DO
               STRNG(CODE,@CLHEAD(K))
       END ELSE DO
               IF M=CODE THEN DO
                               STRNG(CODE,@CLHEAD(K))
                  END ELSE DO
                               STRNG(M,@TSTR)
                               ADDSTR(@TSTR,"-",@CLHEAD(K))
                               STRNG(CODE,@TSTR)
                               ADDSTR(@CLHEAD(K),@TSTR,@CLHEAD(K))
                  END
               CH(@CLHEAD(K+4),0)_EOLIT  !***
               M_CODE+1
       END

CHD3:  IF INC I<=CCODES THEN GO CHD1

!PUT NECESSARY STATISTICS COL HEADINGS IN COL HEADING ARRAY!

       C_CCODES
       I_CCODES+1
CHD5:  K_(I-1)*8 !**I=NUMBER COL CODES+1 TO NUM COL CODES+STATS!
       TRNSTR(SHEAD(I-C-1),@CLHEAD(K))
       CH(@CLHEAD(K+4),0)_EOLIT  !***
       IF INC I<= CCODES+HORSTA THEN GO CHD5

!***** PUT IN STD ERROR IN SECOND LINE
       IF I>CCODES+5 THEN DO
               K _ K-4
            TRNSTR(SHEAD(6),@CLHEAD(K))
       END

!GET ROW HEADINGS!

RHD0:  M_RMIN
       I_1
RHD1:  CODE_ TBL(RCODP+I-1)
       K_(I-1)*8  !******
       IF RTYP=2 THEN GO RHD2
       J_RHDPT+(I*27)-24
       \SCP(DIC,J,GO BADDIC)
       \BIO(DIC,8,,@RWHEAD(K),GO BADDIC) !******
       CH(@RWHEAD(K),11)_EOLIT
       GO RHD3

RHD2:  NULL
       IF M=CODE THEN DO
                               STRNG(CODE,@RWHEAD(K))
                  END ELSE DO
                               STRNG(M,@TSTR)
                               ADDSTR(@TSTR,"-",@RWHEAD(K))
                               STRNG(CODE,@TSTR)
                               ADDSTR(@RWHEAD(K),@TSTR,@RWHEAD(K))
                  END
               CH(@RWHEAD(K+4),0)_EOLIT   !****
               M_CODE+1

RHD3:  IF INC I<= RCODES THEN GO RHD1

       C_RCODES
       I_RCODES+1

!  SET UP NA AND REJECT HEADINGS
RHD5:  K_(I-1)*8   !******
       TRNSTR(SHEAD(I-C-1),@RWHEAD(K))
       CH(@RWHEAD(K+4),0)_EOLIT  !************
       IF INC I<= RCODES+VERSTA THEN GO RHD5


!
!PRINT TABLE TITLE, START PRINT LOOP!

TBEG:  NULL
       IF OFL=1 THEN CAROUT(QZ,OFL,3)
       CAROUT(OCT 154,OFL,1); WAIT.FORM
      CAROUT($.,OFL,1); CAROUT(QZ,OFL,2)
       HCNT_0
       P_1      !LOOP CONTROL, P=1 TO COL CODES+HORSTA BY COL/PAGE!
       EFFEC_TBL(TPTR+(NCOLS*NROWS)) !TOTAL HEAD COUNT FOR TABLE!

       VCNT_1
B500:  RCNT_0
       ENDC_MIN(P+COLPGE-1,CCODES+HORSTA-ZROCOL)
       HCNT_HCNT+1
       TITL          !PRINTS TABLE TITLE ON OUTPUT FILE!
       IF EMPTAB THEN DO
               IF FRMFLG THEN CAROUT(QZ,OFL,ROWPGE-FIXLEN-1)
               CAROUT(QZ,OFL,1)
               CAROUT($.,OFL,1);CAROUT(QZ,OFL,2)
               GO NEWTAB
       END
       IF HSFLG THEN [HIST;GO NEWTAB]

!PRINT COL HEADINGS!

       WRITE(@BLNK12,OFL)        !PRINT 12 BLANKS ON OUTPUT FILE!
       COLTTL(P)                  !PRINTS COL HEADINGS FOR PAGE P!
!
!     PRINT STD. DEVIATION HEADING IF REQUIRED
!

!      IF NOT RWMEAN THEN GO B399
!
!      WRITE(@BLNK12,OFL)
!      C_P
!B398:  J_VALID(C)
!      IF J=CCODES+5 THEN DO
!      WRITE("  STD. ERROR",OFL)
!      END ELSE DO
!      WRITE(@BLNK12,OFL)
!      END

!      IF INC C<=ENDC THEN GO B398

B399:  CAROUT(QZ,OFL,2)


!GET ROWS : ROW CODES+DK+REJECT!

       R_1     !LOOP CONTROL, R=1 TO ROWCODES+2!
!
!  CHECK FOR EMPTY ROW
!
B400:  IF RRSPND(R)=0 THEN GO E400  !ROW EMPTY, GET NEXT ROW!
       IF COL=0 THEN DO
               J_1
               RRESPS(R)_RRSPND(R)
               GO B160
       END ELSE DO
               J_(2*(CCODES+2))+1
       END

!GET FIRST PART OF ROW!

       C_1          !LOOP CONTROL, C=1 TO COL CODES +2!
B150:  IF CRSPND(C)=0 THEN GO E150 !COL EMPTY, GET NEXT COL!
       K_C+C-1
               TLINE1(K)_TBL(TPTR+((R-1)*NCOLS)+C)

       PCNTCK(1,@TLINE1+C+C,RRSPND(R),RRESPS(R))
       PCNTCK(2,@TLINE2+C+C-1,CRSPND(C),CRESPS(C))
       PCNTCK(3,@TLINE2+C+C,EFFEC,EFFEC)

E150:  IF INC C<= CCODES+2 THEN GO B150

       IF PCNT1=2 THEN &
       TLINE1(2*(CCODES+2))_-1 !GET RID OF PERCENT FOR REJECT CELL!

!GET RESPONSE TOTAL FOR ROW!

               TLINE1(J)_RRESPS(R)

       PCNTCK(1,@TLINE1+J+1,RRSPND(R),RRESPS(R))
       PCNTCK(2,@TLINE2+J,EFFEC,RESTOT)
       PCNTCK(3,@TLINE2+J+1,EFFEC,EFFEC)

       J_J+2

B160:      TLINE1(J)_RRSPND(R)

       IF COL=0 THEN M_RRSPND(R) ELSE M_-1
       PCNTCK(1,@TLINE1+J+1,RRSPND(R),M)
       IF  COL=0 THEN M_XTOT ELSE M_-1
       PCNTCK(2,@TLINE2+J,EFFEC,M)
       PCNTCK(3,@TLINE2+J+1,EFFEC,EFFEC)

!PRINT THEN ROW!

!GET RID OF PERCENTS FOR REJECT ROW CELLS!
       IF R=RCODES+2 AND PCNT2=2 THEN DO
               I_1
               PR: TLINE2(I+I-1)_-1
               IF INC I<= CCODES+3 THEN GO PR
       END

!PRINT NEW PAGE IF ROWS PRINTED = MAX ROW PER PAGE!

       IF RCNT>= TBLROW THEN VERPGE(P)

       RWTTL(R)    !SUB PRINT ROW HEADING ROW R!

       C_P    !LOOP CONTROL, C=P TO ENDC
PR2:   J_VALID(C)
       K_R+R-1
!CHECK IF MUST PRINT MEAN/S.D. COL!
       IF J=CCODES+5 THEN DO
               IF ROWAVG(K)<0 THEN DO
                         WRITE("        *   ",OFL)
               END ELSE DO
                         \BRS 53 (ROWAVG(K),ROWAVG(K+1),Q12)
!                        FLSTR(ROWAVG(K),ROWAVG(R+R),@TSTR)
!                        PACK6(@TSTR)
               END
       END ELSE IF  J=CCODES+6 THEN DO
         IF ROWSD(K)<0 THEN DO
               WRITE("        *   ",OFL)
         END ELSE DO
               \BRS 53(ROWSD(K),ROWSD(K+1),Q12)
         END
         END ELSE DO
               OUTCL1(J)   !OUT PUT HEAD COUNT, PERCENT FOR CELL J!
       END

       IF INC C<= ENDC THEN GO PR2

!PRINT TLINE2 IF EITHER PERCENT BY COL OR EFFECTIF DEMANDED!

!******* PRINT SECOND LINE OF ROW TITLE

       CAROUT(QZ,OFL,1)
       J _ (R-1)*8 + 4
       LOCAL JI
       JI _ LENGTH(@RWHEAD(J))

       IF JI>11 THEN JI_0  ! FOR OLDER DICTIONARIES

       JI _ 12-JI
       IF JI=12 THEN GO RW1

       WRITE(@RWHEAD(J),OFL)
RW1:   CAROUT($ ,OFL,JI)
!*******
       IF NOT PCNT2 AND NOT PCNT3 AND NOT RWMEAN THEN GO PR6
       C_P

PR4:   J_VALID(C)

       IF J=CCODES+6 THEN GO PR6  

       IF J = CCODES+5 AND RWMEAN THEN DO
               IF ROWSD(K)<0 THEN [WRITE("        *   ",OFL); GO PR5] &
               ELSE [\BRS 53 (ROWSE(K),ROWSE(K+1),Q4); GO PR5]
       END ELSE DO
               IF NOT PCNT2 AND NOT PCNT3 OR J=CCODES+5 THEN &
               [WRITE(@BLNK12,OFL); GO PR5 ] ELSE OUTCL2(J)
!***
       END

PR5:   IF INC C<= ENDC THEN GO PR4
PR6:   CAROUT(QZ,OFL,2); INC RCNT

!NEXT ROW!

E400:  IF INC R<= RCODES+2 THEN GO B400

!GET REST OF ROWS: RESPONSE TOTAL ROW, RESPONDANT TOTAL, MEAN!

       IF COL = 0 THEN DO
               J_1
               GO B215
       END ELSE DO
               J_(2*(CCODES+2))+1
       END

!GET FIRST PART OF RESPONSE TOTAL ROW!

       C_1
B205:  K_C+C-1
               TLINE1(K)_CRESPS(C)

       PCNTCK(1,@TLINE1+C+C,EFFEC,RESTOT)
       PCNTCK(2,@TLINE2+C+C-1,CRSPND(C),CRESPS(C))
       PCNTCK(3,@TLINE2+C+C,EFFEC,EFFEC)

E205:  IF INC C<=CCODES+2 THEN GO B205
       IF PCNT1=2 THEN TLINE1(2*(CCODES+2))_-1

!GET REST OF RESPONSE TOTAL ROW!

               TLINE1(J)_RESTOT

       TLINE1(J+1)_-1; TLINE2(J)_-1
       PCNTCK(3,@TLINE2+J+1,EFFEC,EFFEC)
       J_J+2

B215:      TLINE1(J)_XTOT
B2151: TLINE1(J+1)_-1
       TLINE2(J)_-1
       PCNTCK(3,@TLINE2+J+1,EFFEC,EFFEC)

!PRINT RESPONSE TOTAL ROW!

       IF RCNT>=TBLROW THEN VERPGE(P)

!  PRINT RESPONSES ROW
PR1A:  RWTTL(RCODES+3)
       C_P
PR2A:  J_VALID(C)
       IF J=CCODES+5 OR J=CCODES+6 THEN DO
               WRITE(@BLNK12,OFL)
               GO PR3A
       END ELSE DO
               OUTCL1(J)
       END

PR3A:  IF INC C  <= ENDC THEN GO PR2A

       C_P
       IF NOT PCNT2 AND NOT PCNT3 THEN GO PR6A
       CAROUT(QZ,OFL,1);WRITE (@BLNK12,OFL)
PR4A:  J_VALID(C)
       IF  J=CCODES+5 OR J=CCODES+6 THEN DO
               WRITE (@BLNK12,OFL)
               GO PR5A
       END ELSE DO
               OUTCL2(J)
       END

PR5A:  IF INC C<=ENDC THEN GO PR4A
PR6A:  CAROUT(QZ,OFL,2); INC RCNT

!!!!!  IF COL = 0 THEN GO B245   SKIP RESPONDANT ROW!

       IF COL = 0 THEN GO PR2B1 !   PRINT RESPONDENT TOTAL!


!GET RESPONDANT ROW!

       C_1
B235:  K_C+C-1
               TLINE1(K)_CRSPND(C)


       PCNTCK(1,@TLINE1+C+C,EFFEC,-1)
       PCNTCK(2,@TLINE2+C+C-1,CRSPND(C),-1)
       PCNTCK(3,@TLINE2+C+C,EFFEC,EFFEC)
       IF INC C<= CCODES+2 THEN GO B235

B2351: J_(2*(CCODES+2))+1
               TLINE1(J)_YTOT

       TLINE1(J+1)_-1; TLINE2(J)_-1
       PCNTCK(3,@TLINE2+J+1,EFFEC,EFFEC)
       J_J+2
       TLINE1(J)_-1;TLINE1(J+1)_-1;TLINE2(J)_-1;TLINE2(J+1)_-1

!PRINT RESPONDANT TOTAL ROW!
!
!  CHECK IF ROW WILL FIT ON PAGE

PR2B1: IF RCNT>=TBLROW THEN VERPGE(P)




       RWTTL(RCODES+4)

       IF COL =  0 THEN TLINE1(1) _ EFFEC

       C_P
PR2B:  J_VALID(C)
       I_RCODES+3; K_I+I-1
       IF J=CCODES+5 THEN DO
               IF ROWAVG(K)<0 THEN DO
                         WRITE("        *   ",OFL)
               END ELSE DO
!                     CONVERT MEAN FROM BINARY TO ASCII DEC NOTATION
                         \BRS 53 (ROWAVG(K),ROWAVG(K+1),Q12)
               END
       END ELSE IF J=CCODES+6 THEN DO
               IF ROWSD(K)<0 THEN DO
               WRITE("        *   ",OFL)
               END ELSE DO
               \BRS 53(ROWSD(K),ROWSD(K+1),Q12)
               END
       END ELSE DO
               OUTCL1(J)
       END

       IF INC C<= ENDC THEN GO PR2B

       C_P
       IF NOT PCNT2 AND NOT PCNT3 AND NOT RWMEAN THEN GO PR6B
       CAROUT(QZ,OFL,1);WRITE(@BLNK12,OFL)
PR4B:  J_VALID(C)
       IF J=CCODES+6 THEN GO PR6B

       IF J=CCODES+5 AND RWMEAN THEN DO
!***
               IF ROWSD(K)<0 THEN [WRITE("        *   ",OFL); GO PR5B] &
               ELSE [\BRS 53 (ROWSE(K),ROWSE(K+1),Q4); GO PR5B]
       END ELSE DO
               IF NOT PCNT2 AND NOT PCNT3 OR J=CCODES+5 THEN &
               [WRITE(@BLNK12,OFL); GO PR5B] ELSE OUTCL2(J)
!***
       END

PR5B:  IF INC C<=ENDC THEN GO PR4B
PR6B:  CAROUT(QZ,OFL,2); INC RCNT

!
!PRINT MEAN ROW IF MEAN ROW FLAG ON!

B245:  IF NOT CLMEAN THEN GO B498
       IF RCNT>=TBLROW THEN VERPGE(P)

       WRITE("MEAN      ",OFL)
       C_P
PR2C:  J_VALID(C)
     IF J=CCODES+5 OR J=CCODES+6 THEN DO
               WRITE(@BLNK12,OFL)
               GO PR3C
       END

       K_J+J-1

       IF J=CCODES+3 THEN [WRITE(@BLNK12,OFL); GO PR3C]
       IF COLAVG(K)<0 THEN DO
               WRITE("   *  ",OFL)
       END ELSE DO
               \BRS 53 (COLAVG(K),COLAVG(K+1),Q12)
       END

PR3C:  IF INC C<= ENDC THEN GO PR2C
       CAROUT(QZ,OFL,2)
       INC RCNT
!**********

!  PRINT STD. DEV. ROW

       WRITE("STD. DEV. ",OFL)

       C_P

BZ20:  J _ VALID(C)
       IF J=CCODES+3 OR J=CCODES+5 OR J=CCODES+6 THEN DO
            WRITE(@BLNK12,OFL)
       END ELSE DO
               K_J+J-1
               IF COLSD(K)<0 THEN DO
               WRITE("        *   ",OFL)
               END ELSE DO
            \BRS 53(COLSD(K),COLSD(K+1),Q12)
               END

       END
      
       IF INC C <=ENDC THEN GO BZ20
       CAROUT(QZ,OFL,2)

!      PRINT STD ERROR ROW

       WRITE("STD. ERROR",OFL)
       C _ P

BZ10:  J _ VALID(C)

       IF J=CCODES+3 OR J=CCODES+5 OR J=CCODES+6 THEN DO
               WRITE(@BLNK12,OFL)
               GO BZ90C
       END

       K _ J+J-1

       IF COLSD(K)<0 THEN DO
               WRITE("        *   ",OFL)
       END ELSE DO
               \BRS 53 (COLSE(K),COLSE(K+1),Q4)
       END

BZ90C: IF INC C<=ENDC  THEN GO BZ10
       CAROUT(QZ,OFL,DBLROW+1)

       INC RCNT


!LAST ROW PRINTED, FILL IN PAGE WITH BLANK LINES IF NECESSARY!

B498:  IF RCNT<TBLROW THEN DO
               J_TBLROW-RCNT
       CAROUT(QZ,OFL,J*(DBLROW+1))
       END

       CAROUT(QZ,OFL,1);CAROUT($.,OFL,1)
        CAROUT(QZ,OFL,2)

!END P LOOP!

E500:  P_P+COLPGE   ! INCREMENT NUMBER OF COLUMNS PRINTED   !
       IF P<=CCODES+HORSTA-ZROCOL THEN DO
               INC VCNT  ! INCREMENT PAGE COUNTER
               CAROUT(OCT 154,OFL,1); WAIT.FORM;GO B500
       END

!ENTIRE TABLE PRINTED!
       GO  NEWTAB

!
!
!OPTIONS ROUTINES: SET FLAGS!

DELETE: DISPLAY(BI("REALLY? ","VRAIMENT? "),0,0)
       READ(@TEL); IF NOT YESNO THEN GO CMND
       \BRS 113; CLOSE(INTRFL); INTRFL_0
       ADDSTR(@STUDY,"'INT'",@TSTR)
       GTPT(@TSTR,@PT1,@PT2)
       \BRS 48(PT1,PT2,GO BADINT)
       \BRS 69(GO BADINT)
       DISPLAY(@TSTR,1,0); DISPLAY(BI(" DESTROYED!","DETRUIT!"),0,1)
       GO NOINT


APPEND: S.A.FLG_1; GO SOR2

SORTIE: S.A.FLG_0

SOR2:  IF OFL>2 THEN CLOSE(OFL);OFL_1
SRT1:  FSCAN
       IF TYPE=5 THEN GO STO
       IF TYPE#8 THEN DO
               DISPLAY(BI("ERROR","ERREUR"),0,1)
               GO STO
       END
       GTPT(@TOKEN,@PT1,@PT2)
       LLL_OCT 10000
       IF CFLNO THEN LLL_1
       OPENO(PT1+OCT 11600000,PT2,STO,OFL,LLL*SYMB)
       IF S.A.FLG AND OFL>2 THEN DO
               \RSP(OFL); \STA (I); \SCP (OFL,I+OCT 40000000,GO IOERR)
       END
       GO CMND
IO.ERR: DISPLAY("I/O ERROR",1,1); GO CMND

STO:   DISPLAY(BI("FILE: ","FICHIER: "),0,0)
       READ(@TEL)
       GO SRT1


!
!     S S S  C O M M A N D
!
SOS: DISPLAY(BI("VALID COMMANDS ARE:","LES ORDRES VALABLES SONT:"),1,1)
       I_0
S1:    DISPLAY(ORDR(I),1,0)
       IF INC I<=NORDRS-1 THEN GO S1
       BOUT(QZ)
  DISPLAY ("NOTE: TABLE(S) MUST BE GENERATED BY USING THE TABULATION COMMAND")
       GO CMND
HDCNT: SCAN
       IF TYPE = ETY THEN [CNTFLG_1; GO CMND]
       IF SHORT("NONE") THEN [CNTFLG_0; GO CMND]
       GO SYNERR


SURVEY ** FICHE/FRAME BREAK *****
/CPAVIMP:SIMP/ SYMSORT

SYM.  PG.LN. IDENT.

!      19 11 !!!     !      17 10 !!!     !      15 17 !!!     !      13  4 !!!     
!      13  3 !!!     !      11  5 !!!     !      11  3 !!!     !      11  2 !!!     
!      11  1 !!!     !      10 39 !!!     !      10 38 !!!     !      10 36 !!!     
!       9 38 !!!     !       7 18 !!!     !       6  9 !!!     !       2 38 !!!     
!!!     1  3 !!!     !!!     1  2 !!!     !!!!!  16  5 !!!     !***** 13 20 !!!     
!*****  9  2 !!!     !***M  17 37 !!!     !***M  17 32 !!!     !***M  14  8 !!!     
!B398: 10 37 !!!     !CHECK 12 36 !!!     !CHECK  6 20 !!!     !COMMA  6  4 !!!     
!END   20  8 !!!     !ENTIR 20 16 !!!     !GET   16 10 !!!     !GET   14 39 !!!     
!GET   14 26 !!!     !GET   14 17 !!!     !GET   12 20 !!!     !GET   11 39 !!!     
!GET   11 23 !!!     !GET   11 10 !!!     !GET    9  8 !!!     !GET    7 38 !!!     
!LAST  19 37 !!!     !LM!   21 19 !!!     !LM!LM  7 17 !!!     !LMCMN  6 10 !!!     
!LMDSP  6 31 !!!     !M!    16 31 !!!     !M!    11 13 !!!     !M!    10 35 !!!     
!M!    10 33 !!!     !M!     1  4 !!!     !MB400 11 14 !!!     !MM!   10 34 !!!     
!MMDEF  1  5 !!!     !MSOS: 21 20 !!!     !NEXT  14 13 !!!     !PRINT 16 30 !!!     
!PRINT 15 13 !!!     !PRINT 13 18 !!!     !PRINT 12 27 !!!     !PRINT 12 18 !!!     
!PRINT 10 29 !!!     !PRINT  7 12 !!!     !PUT    8 32 !!!     !SET    5 38 !!!     
!SET    5 25 !!!     ;MTABO  7 19 !!!     APPEND 20 32 !!!     
B150:  11 26 !!!     B160:  12 10 !!!     B205:  14 29 !!!     B2151: 15  9 !!!     
B215:  15  8 !!!     B2351: 16 22 !!!     B235:  16 13 !!!     B245:  18  5 !!!     
B399:  11  7 !!!     B498:  19 39 !!!     B500:  10 17 !!!     BADNUM  7 13 !!!     
BZ10:  19 16 !!!     BZ20:  18 34 !!!     BZ90C: 19 31 !!!     CCC:    8  1 !!!     
CHD1:   8  3 !!!     CHD2:   8 15 !!!     CHD3:   8 30 !!!     CHD5:   8 36 !!!     
DEF     4 27 !!!     DEF     4 26 !!!     DEF     4 25 !!!     DEF     4 24 !!!     
DEF     4 23 !!!     DEF     4 22 !!!     DEF     4 21 !!!     DEF     4 20 !!!     
DEF     4 19 !!!     DEF     4 18 !!!     DEF     4 17 !!!     DEF     4 16 !!!     
DEF     4 15 !!!     DEF     4 11 !!!     DEF     4  8 !!!     DEF     4  5 !!!     
DEF     4  4 !!!     DELETE 20 21 !!!     DSP0:   6 25 !!!     DSPTCH  6 22 !!!     
E150:  11 34 !!!     E205:  14 36 !!!     E400:  14 15 !!!     E500:  20 10 !!!     
ENDM    4 14 !!!     ENDM    4 10 !!!     ENDM    4  7 !!!     FIND    3 31 !!!     
FIND    3 28 !!!     FIND    3 27 !!!     FIND    3 22 !!!     FIND    3 19 !!!     
FIND    3 18 !!!     FIND    3 17 !!!     FIND    3 15 !!!     FIND    3 14 !!!     
FIND    3 13 !!!     FIND    3 12 !!!     FIND    3 11 !!!     FIND    3 10 !!!     
FIND    3  9 !!!     FIND    3  8 !!!     FIND    3  7 !!!     FIND    3  6 !!!     
FIND    3  5 !!!     FIND    3  4 !!!     FIND    2 37 !!!     FIND    2 35 !!!     
FIND    2 34 !!!     FIND    2 33 !!!     FIND    2 30 !!!     FIND    2 29 !!!     
FIND    2 28 !!!     FIND    2 27 !!!     FIND    2 26 !!!     FIND    2 25 !!!     
FIND    2 24 !!!     FIND    2 23 !!!     FIND    2 22 !!!     FIND    2 21 !!!     
FIND    2 20 !!!     FIND    2 19 !!!     FIND    2 18 !!!     FIND    2 17 !!!     
FIND    2 16 !!!     FIND    2 15 !!!     FIND    2 14 !!!     FIND    2 13 !!!     
FIND    2 12 !!!     FIND    2 11 !!!     FIND    2 10 !!!     FIND    2  9 !!!     
FIND    2  8 !!!     FIND    2  7 !!!     FIND    2  5 !!!     FIND    2  4 !!!     
FIND    2  3 !!!     FIND    2  2 !!!     FIND    2  1 !!!     FIND    1 39 !!!     
FIND    1 38 !!!     FIND    1 37 !!!     FIND    1 36 !!!     FIND    1 35 !!!     
FIND    1 34 !!!     FIND    1 33 !!!     FIND    1 32 !!!     FIND    1 31 !!!     
FIND    1 30 !!!     FIND    1 29 !!!     FIND    1 28 !!!     FIND    1 27 !!!     
FIND    1 26 !!!     FIND    1 25 !!!     FIND    1 24 !!!     FIND    1 23 !!!     
FIND    1 22 !!!     FIND    1 21 !!!     FIND    1 20 !!!     GLOBAL  3 30 !!!     
GLOBAL  3 29 !!!     GLOBAL  3 26 !!!     GLOBAL  3 25 !!!     GLOBAL  3 24 !!!     
HDCNT: 21 27 !!!     IO.ERR 21 12 !!!     LOCAL   4  1 !!!     LOCAL   3 39 !!!     
LOCAL   3 38 !!!     LOCAL   3 37 !!!     LOCAL   3 36 !!!     LOCAL   3 35 !!!     
LOCAL   3 34 !!!     LOCAL   3  1 !!!     LOCAL   1  8 !!!     M***** 13 34 !!!     
NEWTAB  7 27 !!!     O***** 18 28 !!!     O*****  3 23 !!!     O.-.-.  4 28 !!!     
O.-.-.  4  3 !!!     O.-.-.  3 33 !!!     O.-.-.  3 21 !!!     O.-.-.  2 32 !!!     
O.-.-.  2  6 !!!     O.-.-.  1 18 !!!     PR1A:  15 18 !!!     PR2:   12 34 !!!     
PR2A:  15 20 !!!     PR2B1: 16 33 !!!     PR2B:  17  4 !!!     PR2C:  18 10 !!!     
PR3A:  15 28 !!!     PR3C:  18 25 !!!     PR4:   13 37 !!!     PR4A:  15 33 !!!     
PR4B:  17 28 !!!     PR5:   14 10 !!!     PR5A:  16  2 !!!     PR5B:  17 39 !!!     
PR6:   14 11 !!!     PR6A:  16  3 !!!     PR6B:  18  1 !!!     RHD0:   9 10 !!!     
RHD1:   9 12 !!!     RHD2:   9 21 !!!     RHD3:   9 33 !!!     RHD5:   9 39 !!!     
RW1:   13 33 !!!     S1:    21 22 !!!     SOR2:  20 36 !!!     SORTIE 20 34 !!!     
SRT1:  20 37 !!!     STO:   21 14 !!!     SYNERR  6 17 !!!     TABLE   4 39 !!!     
TABLE   4 33 !!!     TABLE   4 30 !!!     TABLE   4 29 !!!     TBEG:  10  8 !!!     
ULM!PR 18  3 !!!     ULM!PR 10  6 !!!     VERSIO  1 17 !!!     \BRS    4  9 !!!     
\BRS    4  6 !!!     _B_?*^  4 34 !!!     _ENDDE  5  1 !!!     _LM!LM 20 19 !!!     
_Z__W,  6 11 !!!     
SURVEY ** FICHE/FRAME BREAK *****
/CPAVIMPG:SRCE/
*
*  NO CONVERSION IS NECESSARY FOR THIS PROGRAM TO MAKE IT BILINGUAL
*
CIMPG  IDENT

S       EQU 140
D       EQU 155


$TCNT   EQU  37777B-3401
$TCB    EQU  TCNT+1
$TBL    EQU  TCB+400-1

$ROWSD  EQU *-1; BSS 2*D
$COLSD  BSS 1 (FIND)
$RRESPS EQU *-1; BSS D
$CRESPS BSS 1 (FIND)
$RRSPND EQU *-1; BSS D
$CRSPND BSS 1 (FIND)

$DKTOT  EQU *-1; BSS S
$TLINE1 EQU *-1; BSS 2*S
$TLINE2 EQU *-1; BSS 2*S

$RWHEAD BSS 8*D
$CLHEAD BSS 1 (FIND)

$VALID  EQU *-1; BSS S

$RNAME  BSS 72
$CNAME  BSS 72
$BASNAM BSS 72
$TSTR   BSS 73

$FHALF  BSS 2
$F10    BSS 2
$F100   BSS 2
$CC     BSS 2

$DATE   BSS 6

$BLNK6  BSS 2
$BLNK11 BSS 4
$BLNK12 BSS 5

$AUX    EQU *-1; BSS 2

$BLKNUM BSS 1
$OLDBLK BSS 1
$LASADR BSS 1
$OLDTCB BSS 1
$OFL    BSS 1
$RESTOT BSS 1
$ZROROW BSS 1
$ZROCOL BSS 1
$HORSTA BSS 1
$VERSTA BSS 1
$CRSTOT BSS 1
$XTOT   BSS 1
$YTOT   BSS 1
$TPTR   BSS 1
$ROW    BSS 1
$COL    BSS 1
$FLTRNO BSS 1
$NCOLS  BSS 1
$NROWS  BSS 1
$COLPGE BSS 1
$ROWPGE BSS 1
$NCANS  BSS 1
$NRANS  BSS 1
$RTYP   BSS 1
$CTYP   BSS 1
$RHDPT  BSS 1
$CHDPT  BSS 1
$RMIN   BSS 1
$CMIN   BSS 1

$ZONE   BSS 1
$FRMFLG BSS 1
$CORFLG BSS 1
$PCNT1  BSS 1
$PCNT2  BSS 1
$PCNT3  BSS 1
$RWMEAN BSS 1
$CLMEAN BSS 1
$HSFLG  BSS 1
$CNTFLG BSS 1

$T      BSS 1
$WTNO   BSS 1
$EMPTAB BSS 1
$RCODES BSS 1
$CCODES BSS 1
$NVAL   BSS 1
$NCELLS BSS 1
$DBLROW BSS 1
$TBLROW BSS 1
$CODE   BSS 1
$HPNT   BSS 1
$VCNT   BSS 1
$HCNT   BSS 1
$EFFEC  BSS 1
$RCNT   BSS 1
$SYMBL  BSS 1
$CRLTMP BSS 1
$RCODP  BSS 1
$CCODP  BSS 1
$FPAGES BSS 1

$CHI2FL BSS 1
$CHIVAL BSS 2
$PCHFLG BSS 1 (CONTROLS PRINTING OF FOLDED TABLE)
$DF    BSS 1 (DEGREES OF FREEDOM)
$CHIST1 BSS 21
$CHIST2 BSS 21


$ROWAVG EQU *-1; BSS 2*D
$COLAVG BSS 1 (FIND)
        BSS 1
$ROWSE  EQU *-1 ; BSS 2*D
$COLSE  BSS 1 (FIND)
        END
SURVEY ** FICHE/FRAME BREAK *****
/CPAVIMPG:SRCE/ SYMSORT

SYM.  PG.LN. IDENT.

AUX     2  6 *M*     BASNAM  1 31 *M*     BLKNUM  2  8 *M*     
BLNK11  2  3 *M*     BLNK12  2  4 *M*     BLNK6   2  2 *M*     CC      1 37 *M*     
CCODES  3 14 *M*     CCODP   3 28 *M*     CHDPT   2 34 *M*     CHI2FL  3 31 *M*     
CHIST1  3 35 *M*     CHIST2  3 36 *M*     CHIVAL  3 32 *M*     CIMPG   1  3 *M*     
CLHEAD  1 25 *M*     CLMEAN  3  6 *M*     CMIN    2 36 *M*     CNAME   1 30 *M*     
CNTFLG  3  8 *M*     CODE    3 19 *M*     COL     2 23 *M*     COLAVG  4  1 *M*     
COLPGE  2 27 *M*     COLSD   1 14 *M*     COLSE   4  4 *M*     CORFLG  3  1 *M*     
CRESPS  1 16 *M*     CRLTMP  3 26 *M*     CRSPND  1 18 *M*     CRSTOT  2 18 *M*     
CTYP    2 32 *M*     D       1  6 *M*     DATE    1 39 *M*     DBLROW  3 17 *M*     
DF      3 34 *M*     DKTOT   1 20 *M*     EFFEC   3 23 *M*     EMPTAB  3 12 *M*     
F10     1 35 *M*     F100    1 36 *M*     FHALF   1 34 *M*     FLTRNO  2 24 *M*     
FPAGES  3 29 *M*     FRMFLG  2 39 *M*     HCNT    3 22 *M*     HORSTA  2 16 *M*     
HPNT    3 20 *M*     HSFLG   3  7 *M*     LASADR  2 10 *M*     NCANS   2 29 *M*     
NCELLS  3 16 *M*     NCOLS   2 25 *M*     NRANS   2 30 *M*     NROWS   2 26 *M*     
NVAL    3 15 *M*     OFL     2 12 *M*     OLDBLK  2  9 *M*     OLDTCB  2 11 *M*     
PCHFLG  3 33 *M*     PCNT1   3  2 *M*     PCNT2   3  3 *M*     PCNT3   3  4 *M*     
RCNT    3 24 *M*     RCODES  3 13 *M*     RCODP   3 27 *M*     RESTOT  2 13 *M*     
RHDPT   2 33 *M*     RMIN    2 35 *M*     RNAME   1 29 *M*     ROW     2 22 *M*     
ROWAVG  3 39 *M*     ROWPGE  2 28 *M*     ROWSD   1 13 *M*     ROWSE   4  3 *M*     
RRESPS  1 15 *M*     RRSPND  1 17 *M*     RTYP    2 31 *M*     RWHEAD  1 24 *M*     
RWMEAN  3  5 *M*     S       1  5 *M*     SYMBL   3 25 *M*     T       3 10 *M*     
TBL     1 11 *M*     TBLROW  3 18 *M*     TCB     1 10 *M*     TCNT    1  9 *M*     
TLINE1  1 21 *M*     TLINE2  1 22 *M*     TPTR    2 21 *M*     TSTR    1 32 *M*     
VALID   1 27 *M*     VCNT    3 21 *M*     VERSTA  2 17 *M*     WTNO    3 11 *M*     
XTOT    2 19 *M*     YTOT    2 20 *M*     ZONE    2 38 *M*     ZROCOL  2 15 *M*     
ZROROW  2 14 *M*     
SURVEY ** FICHE/FRAME BREAK *****
/CPAVIMPS:SIMP/

!!! IMPSUBS
!!! JP BARASZ
!!! MAI 13 1972
!!!  BELONGS TO CPAVOT
!
! VERSION CONVERTED TO BILINGUAL 5/74 B B. THORNQUIST
!
DEF BI(ENGLISH,FRENCH) AS ENGLISH

LOCAL I,J
FIND MULFLG  ! FLAG FOR MULTIPLE ANSWER QUESTION
FIND %BOUT,%OUTNO,%BCLOS,%BERX
FIND CURCAR,TKPT,%GETCAR
FIND %FLOAT,%FDIV,%FMUL,%FSUB,%FADIT
FIND %GETLIST,%NXTITEM,LIST(0:1)
FIND %SUBSTR
FIND %ARM
FIND    %READ,%SCAN,%EQUAL,%VAL,%WRITE,%ACCEPT
FIND  %IMP1
FIND   %SWAPIN
FIND %NULSTR
DEF OUTNUM AS \BRS 36
GLOBAL %TITL,%COLTTL,%PCNTCK,%VERPGE,%RWTTL
FIND %DISPLAY
FIND %LENGTH,%LEFT       !STRING FUNCTIONS!
FIND %TRNSTR
FIND      %CAROUT
FIND  %ADDSTR,%GTPT
FIND %STRNG
GLOBAL  %OUTCL1,%OUTCL2
FIND    %SQRT
FIND TSTR(0:72)
FIND CHI2FL,DF,CHIST1(0:1),CHIST2(0:1),CHIVAL(0:1)
FIND BUFF(0:1),NEWBUF(0:1)
FIND STUDY(0:1)
FIND TOKEN(0:24),CURPOS,TYPE,VALUE   !SCANER VARIABLES!
FIND TCNT,TCB(0:399),TBL(3000)
FIND ROWAVG(400),COLAVG(),ROWSD(400),COLSD()
FIND RRESPS(200),CRESPS(),RRSPND(200),CRSPND()
FIND XTOT,YTOT,DKTOT(200),TPTR,ROW,COL,FLTRNO
FIND NQUES,QCBLEN,QCBBEG,FLR(5),BASADR
FIND BASNAM(0:10)
FIND TLINE1(400)
FIND TLINE2(400)
FIND AUX(2)
FIND NCELLS,RNAME(0:10),CNAME(0:10)
FIND CC(0:1)
FIND CLHEAD(),RWHEAD(0:799)
FIND BLNK6(0:1)
FIND BLNK11(0:3)
FIND BLNK12(0:4)
FIND VALID(200)
FIND FHALF(0:1)
FIND F10(0:1),F100(0:1)
FIND DATE(0:5)
FIND BLKNUM,OLDBLK,LASADR,OLDTCB
FIND   DIC,INTRFL,LF2
FIND RL1,NMPAGE,QCBPAGE,RL2
FIND OFL
FIND RESTOT,ZROROW,ZROCOL,HORSTA,VERSTA,CRSTOT
FIND NCOLS,NROWS,COLPGE,ROWPGE,NCANS,NRANS,RTYP,CTYP,RHDPT,CHDPT
FIND RMIN,CMIN
FIND ZONE
FIND FRMFLG,CORFLG,PCNT1,PCNT2,PCNT3,RWMEAN,CLMEAN,HSFLG,CNTFLG
FIND T
FIND EMPTAB
FIND RCODES,CCODES,NVAL
FIND DBLROW,TBLROW
FIND CODE,HPNT
FIND VCNT,HCNT,EFFEC,RCNT
FIND SYMBL
FIND CRLTMP
FIND RCODP,CCODP
FIND FPAGES
FIND TEL

GLOBAL %YESNO,%SHORT,%STAT
GLOBAL %PERCNT,%AVRGE,%HIST,%FLSTR,%FSCAN,%TABID,%CORCO,%PACK6
       DEF ALPHTYPE AS 1
       DEF NUMTYPE AS 2
       DEF EOLTYPE AS 5
       DEF FICTYPE AS 8
       DEF BADTYPE AS 0
DEF ENDLIST AS OCT 20000000
DEF WAIT.FORM AS IF OFL=1 THEN CAROUT(OCT 377,OFL,5)
DEF PROMPT(X) BY
DISPLAY(X,0,0); READ(@TEL)
ENDM PROMPT
DEF LIST.IS.ALL BY
LIST(0)_LIST(3)_1; LIST(1)_OCT 40000001; LIST(2)_5000; LIST(4)_ENDLIST
ENDM LISTISALL

DEF OUTP AS 0
DEF SYMB AS 3


DEF COLWTH AS 12
!DEF OUTNO(X) AS \BRS 36 (X,10,1)


!
!  NAME:               PERCNT(A,B)
!  FUNCTION:           TO COMPUTE A/B*100.
!
!  INPUT:              A = DIVIDEND (INTEGER)
!                      B = DIVISOR  (INTEGER)
!
!  OUTPUT:             VALUE RETURNED IS A/B*100.
!
!  ERRORS DETECTED:    NONE
!
!  ROUTINES CALLED:    FLOAT,FMUL,FDIV
!
%PERCNT(A,B)

       LOCAL C(0:1),A1(0:1),B1(0:1)
       IF B<=0 THEN [C(0)_-1; RETURN [C(0);C(1)]]
       FLOAT(A,@A1)
       FLOAT(B,@B1)
       FDIV(@A1,@B1,@C)
       FMUL(@F100,@C,@C)
       RETURN [C(0);C(1)]
END PERCNT
!
!  NAME:               AVRGE(Y,S,D,MEAN,SDEV)
!  
!  FUNCTION:           TO COMPUTE MEAN AND STANDARD DEVIATION
!
!  INPUT:              Y = SUM OF THE VALUES OF THE OBSERVATIONS
!                      S = SUM OF THE SQUARES OF THE VALUES OF THE
!                          OBSERVATIONS
!
!                      D = TOTAL NUMBER OF OBSERVATIONS
!
!  ERRORS DETECTED:    IF THE MEAN IS NEGATIVE -1 IS RETURNED FOR 
!                      THE VALUES OF THE MEAN AND STANDARD DEVIATION
!                      IF NUMBER OF OBSERVATIONS IS LESS THAN 2, -1
!                      IS RETURNED FOR THE VALUE OF THE STANDARD
!                      DEVIATION
!
!  ROUTINE CALLED:     FLOAT,FDIV,FSUB,FMUL
!
%AVRGE(Y,S,D,@MEAN,@SDEV,@SE)

       LOCAL FY(0:1),FS(0:1),FD(0:1),FT(0:1)

       IF D<=0 THEN DO
               MEAN_-1
               SDEV_-1
               SE _ -1
               RETURN
       END

       FLOAT(Y,@FY); FLOAT(D,@FD)
       FDIV(@FY,@FD,@MEAN)

       IF D-1<=0 THEN DO
               SDEV_-1
               RETURN
       END

       FLOAT(S,@FS)
       FMUL(@FY,@FY,@FY)
       FDIV(@FY,@FD,@FY)
       FSUB(@FS,@FY,@FS)
       FLOAT(1,@FT)
       FSUB(@FD,@FT,@FD)
       FDIV(@FS,@FD,@FS)
       \BRS 118 (FS(0),FS(1))  !LOAD FLOATING ACCUMULATORS!
       \BRS 82 (GO ASQ)   ! SKIP IF ACCUMULATORS NEGATIVE!
       SDEV_-1
       RETURN
ASQ:   SQRT(@FS,@SDEV,7)

!**********
       LOCAL FE(0:1)
       SQRT(@FD,@FE,7)


       FDIV(@SDEV,@FE,@SE)
!*********

       RETURN
END AVRGE


!
!  NAME:               FLSTR(X,Y,STR)
!
!  FUNCTION:           TO CONVERT THE FLOATIN POINT NUMBER IN X,Y TO
!                      INTERNAL ASCII REPRESENTATION WITH ONE DECIMAL
!                      PLACE.
!  INPUT:              X = MOST SIGNIFICANT PART OF NUMBER
!                      Y = LEAST SIGNIFICANT PART OF NUMBER
!
!  OUTPUT:             STRNG CONTAINS ASCII REPRESENTATION OF NUMBER
!
!  ERRORS DETECTED:    NONE
!
!  ROUTINES CALLED:    FMUL,FADIT,STRNG,ADDSTR
!  
%FLSTR(X,Y,STR)

LOCAL FVAR(0:1),J,K,L,TSTR(0:30)

       FVAR(0)_X; FVAR(1)_Y
       FMUL(@F10,@FVAR,@FVAR)
       FADIT(@FHALF,@FVAR,@FVAR)
       \BRS 50 (FVAR(0),FVAR(1)); \STA (L)
       [J;K]_L DIVMOD 10
       STRNG(K,STR)
       ADDSTR(".",STR,@TSTR)
       STRNG(J,STR)
       ADDSTR(STR,@TSTR,STR)
       RETURN
END FLSTR


!
!  NAME:               HIST
!
!  FUNCTION:           TO PRINT A HISTOGRAM OF THE REQUESTED MARGINAL
!                      TABLE
!
%HIST
LOCAL L,J,FL(0:1),FH(0:1),FSCL(0:1),R,K,FRR(0:1),HWTH,N,TSTR(0:30)
       L_0
       J_1
H1:    IF RRSPND(J)>L THEN L_RRSPND(J)
       IF INC J<=NROWS-3 THEN GO H1

       FLOAT(L,@FL)
       HWTH_COLWTH*COLPGE
       FLOAT(HWTH-COLWTH,@FH)
       FDIV(@FH,@FL,@FSCL)

       WRITE(@BLNK12,OFL)
       CAROUT($I,OFL,1)
       CAROUT($-,OFL,HWTH)

       R_1
B608:  IF RRSPND(R)=0 THEN GO E608
       CAROUT(CARRET,OFL,1)
       J_(R-1)*8
       K_LENGTH(@RWHEAD(J))
       K_12-K
       WRITE(@RWHEAD(J),OFL)
       CAROUT($ ,OFL,K)
       WRITE("I",OFL)

       FLOAT(RRSPND(R),@FRR)
       FMUL(@FRR,@FSCL,@FRR)
       FADIT(@FRR,@FHALF,@FRR)
       \BRS 50 (FRR(0),FRR(1)); \STA (N)
       CAROUT(SYMBL,OFL,N)
       CAROUT($ ,OFL,5)
       STRNG(RRSPND(R),@TSTR); PACK6(@TSTR)
       CAROUT(CARRET,OFL,1)
!
!
!  ADD SECOND LINE OF ANNOTATION
!
       J_(R-1)*8 + 4
       CH(@RWHEAD(J),11)_ EOLIT !*******
       K_LENGTH(@RWHEAD(J))
       K_12-K
       WRITE(@RWHEAD(J),OFL)
       CAROUT($ ,OFL,K)
!
       CAROUT($I,OFL,1)
       CAROUT(SYMBL,OFL,N)
       CAROUT($ ,OFL,5)
       [FRR(0);FRR(1)]_DOUBLE PERCNT(RRSPND(R),EFFEC)
       IF FRR(0)<1 THEN DO
               WRITE("   *  ",OFL)
       END ELSE DO
               FLSTR(FRR(0),FRR(1),@TSTR)
               PACK6(@TSTR)
       END
       CAROUT(CARRET,OFL,1);WRITE(@BLNK12,OFL);CAROUT($I,OFL,1)
E608:  IF INC R<=NROWS-3 THEN GO B608

       CAROUT($-,OFL,HWTH)
       CAROUT(CARRET,OFL,2)
       WRITE(BI("RESPONSES   ","REPONSES   "),OFL)
       STRNG(XTOT,@TSTR);PACK6(@TSTR)
       CAROUT(CARRET,OFL,2)
       WRITE(BI("EACH ","CHAQUE "),OFL)
       CAROUT(SYMBL,OFL,1)
       WRITE(BI(" REPRESENTS "," REPRESENTE "),OFL)
       FDIV(@FL,@FH,@FSCL)
       FLSTR(FSCL(0),FSCL(1),@TSTR);PACK6(@TSTR)
       WRITE(BI(" OBSERVATIONS"," SUJETS"),OFL)
       CAROUT(CARRET,OFL,4)
       CAROUT(CARRET,OFL,1)

       CAROUT($.,OFL,1);CAROUT(CARRET,OFL,2)
       RETURN
END HIST
!
!  NAME:               FSCAN
!
!  FUNCTION:           TO SCAN FOR A VAID FILE NAME IN BUFF
!
!  INPUT:              NONE
!
!  OUTPUT:             NONE
!
%FSCAN

       LOCAL TEMP,TK1PT

       TK1PT_TKPT_CHPT(@TOKEN,-1)
SF0:   GETCAR
       IF CURCAR=$  THEN GO SF0
       IF CURCAR=EOLIT THEN [TYPE_EOLTYPE;RETURN]
SF1:    IF CURCAR=$/ OR CURCAR=$' THEN GO SF2
       IF CURCAR=$ OR CURCAR=EOLIT THEN DO
               NCHV(TKPT)_EOLIT
               TYPE_FICTYPE
               RETURN
       END
       NCHV(TKPT)_CURCAR
       GETCAR
       GO SF1

SF2:   TEMP_CURCAR
       NCHV(TKPT)_CURCAR
SF2A:  NULL
       GETCAR
       IF CURCAR=EOLIT OR TKPT-TK1PT>71 THEN DO
               TYPE_BADTYPE
               RETURN
       END
       NCHV(TKPT)_CURCAR
       IF CURCAR=TEMP THEN DO
             GETCAR
            NCHV(TKPT)_CURCAR
             GO SF1
       END
       GO SF2A

END FSCAN



!
!  NAME:               TABID(ERFL:,ERNUM:,ERRSYN)
!
!  FUNCTION:           TO PRINT DESCRIPTIVE INFORMATION ABOUT TABLES
!                      CONSTRUCTED IN THE 'INT' FILE. 
!
!  INPUT:              ERFL:,ERNUM:,ERSYN: ARE LOCATIONS TO BRANCH
!                      FOR VARIOUS TYPES OF ERRORS DETECTED
!
!  OUTPUT:             NONE
!
!  ERRORS DETECTED:    SEE INPUT
!
!  ROUTINES CALLLED:   PROMPT,SHORT,SCAN,OUTNO,BOUT,DISPLAY
!
%TABID(ERFL:,ERNUM:,ERSYN:)

       LOCAL I,J,K,L,X,ALLFLG

TID:  SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT(BI("TABLES: ","TABLEAUX: "))
               GO TID
       END
       IF TYPE =ALPHTYPE THEN DO
               IF SHORT(BI("ALL","TOUTES")) OR SHORT("TOUS") THEN DO
                     SCAN; IF TYPE#EOLTYPE THEN GO ERSYN
                     LIST.IS.ALL
                     ALLFLG_1; GO TIDX
               END
       END
       IF TYPE#NUMTYPE THEN GO ERSYN
       GETLIST(@I,1,5000); IF I THEN GO ERSYN
       ALLFLG_0

TIDX:  VALUE_NXTITEM
       IF VALUE=ENDLIST THEN [BOUT(CARRET); RETURN]
       
       [J;K]_(VALUE-1) DIVMOD 20
       IF J#OLDTCB THEN DO
               IF J*3401*3>=LASADR THEN GO ERN
       \SCP(INTRFL,J*3401*3,GO ERFL)
               OLDTCB_-1 ! IN CASE HE ESCAPES
               \BIO(INTRFL,401,,@TCNT,GO ERFL)
               OLDTCB_J
       END

       IF K>TCNT-1 THEN GO ERN

ID0:   DISPLAY(BI("TABLE ","TABLEAU "),1,0)
       OUTNO((K+1)+(20*J))
       BOUT($:)
       BOUT($ ); BOUT($Q); OUTNO(TCB((20*2)+K))
      IF TCB((20*3)+K) THEN [DISPLAY(BI(" BY Q"," PAR Q"),0,0);OUTNO(TCB((20*3)+K))]
       IF TCB(K) THEN [DISPLAY(BI(", FILTER ",",FILTRE "),0,0);OUTNO(TCB(K))]

       [12,12]*[X,]_TCB(K+20)
       IF X THEN [DISPLAY(BI(",WEIGHTED BY Q",",PONDERE PAR Q"),0,0); OUTNO(X)]
       GO TIDX

ERN:   IF ALL.FLG THEN GO TIDX 
       BOUT(CARRET); OUTNO(VALUE); BOUT($?); GO TIDX

END TABID


%CORCO(P,NR,NC,CRS,@RES)

       LOCAL I,X,X2,Y,Y2
       LOCAL FX(0:1),FX2(0:1),FY(0:1),FY2(0:1)
       LOCAL FXY(0:1), FT(0:1), FC(0:1), FSX(0:1), FSY(0:1), FD(0:1)
       IF CRS=0 THEN GO NOCO

       X_X2_Y_Y2_0

       I_1
ILP:   Y2_Y2+TBL(P+(NC*I)-2)
       Y_Y  +TBL(P+(NC*I)-1)
       IF INC I<=NR-5 THEN GO ILP

       I_1
ILP1:  X2_X2+TBL(P+((NR-3)*NC)+I)
       IF INC I<=NC-5 THEN GO ILP1

       I_1
ILP2:  X_X+TBL(P+((NR-2)*NC)+I)
       IF INC I<=NC-5 THEN GO ILP2

       FLOAT(X,@FX)
       FLOAT(X2,@FX2)
       FLOAT(Y,@FY)
       FLOAT(Y2,@FY2)
       FLOAT(TBL(P+((NR-1)*NC)-1),@FXY)
       FMUL(@FX,@FY,@FT)
       FLOAT(CRS,@FC)
       FDIV(@FT,@FC,@FT)
       FSUB(@FXY,@FT,@FXY)

       FMUL(@FX,@FX,@FT)
       FDIV(@FT,@FC,@FT)
       FSUB(@FX2,@FT,@FSX)

       FMUL(@FY,@FY,@FT)
       FDIV(@FT,@FC,@FT)
       FSUB(@FY2,@FT,@FSY)

       IF FSX(0)<0 OR FSY(0)<0 THEN GO NOCO

       SQRT(@FSX,@FD,5); SQRT(@FSY,@FT,5)
       FMUL(@FD,@FT,@FD)
       IF FD(0)=0 AND FD(1)=0 THEN GO NOCO
       FDIV(@FXY,@FD,@RES)
       RETURN
NOCO:  RES_3; RETURN
END CORCO
!
!  NAME                PACK6(@STR)
!
!  FUNCTION:           TO WRITE THE CONTENTS OF STR ON UNIT OFL.
!                      IF STRNG CONTAINS LESS THAN 6 CHARACTERS, THEN
!                      IT IS LEFT PADDED WITH BLANKS BEFORE WRITING.
!  
!  INPUT:              STR CONTAINS  THE STRING TO BE WRITTEN
!
!  OUTPUT:             NONE
!
!  ERRORS DETECTED:    IF STR CONTAINS MORE THAN 6 CHARACTERS, A
!                      BLANK AND 5 ASTERISKS ARE WRITTEN.
!
!  ROUTINES CALLED:    CAROUT
!
%PACK6(@STR)

       LOCAL J

       J_LENGTH(@STR)
       IF J>6 THEN [WRITE(" *****",OFL); RETURN]
       J_6-J
       CAROUT($ ,OFL,J)
       WRITE(@STR,OFL)

       RETURN
END PACK6
%YESNO

LOCAL J,I
GT1:    SCAN
       IF TYPE#ALPHTYPE THEN GO QUOI

QUEL:  IF SHORT(BI("YES","OUI")) THEN [I_1; GO YN1]
       IF SHORT(BI("NO","NON")) THEN I_0 ELSE GO QUOI
YN1:   SCAN; IF TYPE#EOLTYPE THEN GO QUOI
       RETURN I
QUOI:   DISPLAY(BI("YES OR NO? ","OUI OU NON? "),0,0)
       READ(@TEL)
       GO GT1
END YESNO

!.-.-.-.-.-.!

!
!  NAME:               SHORT(@A)
!
!  FUNCTION:           RETURNS A TRUE VALUE IF -A- CONTAINS
!                      A LEFT SUBSET OF GLOBAL VARIABLE -TOKEN-.
!
!  INPUT:              A = STRING TO BE TESTED
!
!  OUTPUT:             TRUE IF LEFT SUBSET
!                      FALSE IF NOT LEFT SUBSET
!
!  ERRORS DETECTED:    NONE
!
!  ROUTINES CALLED:    NONE
!
%SHORT(@A)
       LEFT(@A,LENGTH(@TOKEN),@TSTR)
       IF EQUAL(@TOKEN,@TSTR) THEN RETURN 1
       RETURN 0
END SHORT

%STAT
       LOCAL FORK(0:6)
       FIND STASTR,STARL1,STARL2,DF,RL1,RL2

       IF NOT (CHI2FL AND COL) THEN [DF_-1; RETURN]
       FORK(0)_STASTR
       \BRS 43;\STP (RL1)
       FORK(4)_STARL1
       FORK(5)_RL2
       \BRS 9(FORK+OCT 33600000)
       IF FORK(6)=0 THEN RETURN
       I_0; DISPLAY(BI("TRAP IN STAT","TRAP DANS STAT"),1,1)
L:     \BRS 36(FORK(I),8,1); BOUT(CARRET)
       IF INC I<=6 THEN GO L

       RETURN
END STAT
!
!  NAME:               VERPGE(HPGE)
!
!  FUNCTION:           TO SKIP TO NEW PAGE, PRINT PAGE TITLE, AND PRINT
!                      APPROPRIATE COLUMN TITLES.
!
!  INPUT:              HPGE
!
!  OUTPUT:             NONE
!
!  ERRORS DETECTED:    NONE
!
!
!  ROUTINES CALLED:    CAROUT,TITL,COLTTL
!
%VERPGE(HPGE)

       CAROUT(CARRET,OFL,1)
       CAROUT(OCT 154,OFL,1); WAIT.FORM
       CAROUT($.,OFL,1)
       CAROUT(CARRET,OFL,2)
       INC VCNT
       TITL
       WRITE(@BLNK12,OFL)
       COLTTL(HPGE)
       RCNT_0
       RETURN
END VERPGE


%RWTTL(ROW)

       LOCAL J,K
       J_(ROW-1)*8 !*****
!*****
!      WRITE(@RWHEAD(J),OFL)
!      CAROUT(CARRET,OFL,1)
!      J_J+4
!******
       K_LENGTH(@RWHEAD(J))
       IF K>11 THEN K_0   !*****
       K_12-K
       IF K=12 THEN GO RW1  !*******
       WRITE(@RWHEAD(J),OFL)
RW1:   CAROUT($ ,OFL,K)
       RETURN
END RWTTL





%TITL
       WRITE(@STUDY,OFL)
       CAROUT(CARRET,OFL,1)
       WRITE(@DATE,OFL); CAROUT(CARRET,OFL,1)
       CAROUT($ ,OFL,ZONE-22)
       WRITE (BI("TABLE ","TABLEAU "),OFL)
       OUTNUM(T+1+(20*BLKNUM),10,OFL)
       WRITE(" PAGE ",OFL)
       OUTNUM(VCNT,10,OFL)
       HCNT_HCNT+1  !***** INCREMENT PAGE NUMBER
       CAROUT(CARRET,OFL,2);WRITE(@RNAME,OFL);CAROUT(CARRET,OFL,1)
       WRITE(@CNAME,OFL);CAROUT(CARRET,OFL,2)
       WRITE(BI("TOTAL: ","EFFECTIF: "),OFL)
       OUTNUM(EFFEC,10,OFL)
       CAROUT(CARRET,OFL,2);WRITE(@BASNAM,OFL);CAROUT(CARRET,OFL,2)
!*******
       IF MULFLG  THEN DO
   WRITE ("CORRELATION COEFFICIENT INVALID FOR MULTIPLE RESPONSE QUESTIONS",OFL)
   CAROUT(CARRET,OFL,1)
       GO TSCH
       END
       IF CRLTMP THEN DO
               WRITE("CORRELATION: ",OFL)
               IF CC(0)= 3 THEN DO
                               CAROUT($*,OFL,1)
               END ELSE DO
                               J_[3,6,6,1,8]*[3,3,8,0,OFL]
                               \BRS 53 (CC(0),CC(1),J)
               END
       END ELSE GO TSCH
       CAROUT(CARRET,OFL,1)
TSCH:  IF (CHI2FL=0) OR VCNT#1  THEN GO TS1
       STAT
       IF DF=-1 THEN GO TS1
       WRITE(CHIST1,OFL)
       IF DF>0 THEN DO
               J_[3,6,6,1,8]*[3,3,10,0,OFL]
               \BRS 53 (CHIVAL(0),CHIVAL(1),J)
       END
       CAROUT(CARRET,OFL,1)
       WRITE(CHIST2,OFL)
       IF DF>0 THEN OUTNUM(DF,10,OFL)
TS1:   CAROUT(CARRET,OFL,3)
       RETURN
END TITL


!
!  NAME:               COLTTL(P)
!
!  FUNCTION:           TO  OUTPUT N COLUMN HEADINGS WHERE N = THE NUMBER 
!                      OF COLUMNS TO BE PROCESSED FOR THIS PASS OF THE
!                      P LOOP.
!
!  INPUT:              P = NUMBER OF FIRST COLUMN TO BE OUTPUT
!
!  OUTPUT:             NONE
!  ERRORS DETECTED:    NONE
!
!  ROUTINES CALLED:    CAROUT
!
%COLTTL(P)

!  COLPGE = # OF COLS THAT CAN BE PRINTED ON A PAGE
!  CCODES = # OF COLUMN CODES
!  HORSTA = # OF OPTIONAL COLUMNS
!  ZROCOL = # OF ZERO COLUMNS

       LOCAL C,J,K,L,M,M1,M2,I

       K_MIN(P+COLPGE-1,CCODES+HORSTA-ZROCOL)
       I_0
CT0:   C_P
CT:    L_(VALID(C)-1)*8 + I  !****
       CAROUT($ ,OFL,1)
       J_LENGTH(@CLHEAD(L))
       IF J>11 THEN J_0  !**** TEMP FIX
       M_11-J
       M1_M/2
       M2_(M/2)+ M MOD 2
       CAROUT($ ,OFL,M1)

       IF J=0 THEN GO CT1
       WRITE(@CLHEAD(L),OFL)
CT1:   CAROUT($ ,OFL,M2)
       IF INC C<= K THEN GO CT
       CAROUT(CARRET,OFL,1)

!****
       IF I=4 THEN RETURN
       WRITE(@BLNK12,OFL)
       I_4
       GO CT0

END COLTTL






%PCNTCK(TYP,@VAR,A,B)

       DO TYP OF 3
               1: IF PCNT1=1 THEN DO
                               VAR_A
                  END ELSE IF PCNT1 =2 THEN DO
                               VAR_B
                  END ELSE DO
                               VAR_-1
                  END

               2: IF PCNT2=1 THEN DO
                               VAR_A
                  END ELSE IF PCNT2=2 THEN DO
                               VAR_B
                   END ELSE DO
                               VAR_-1
                  END

               3: IF PCNT3=1 THEN DO
                               VAR_A
                  END ELSE IF PCNT3=2 THEN DO
                               VAR_B
                  END ELSE DO
                               VAR_-1
                  END
       END

       RETURN
END  PCNTCK

!
!  NAME:               OUTCL1(I)
!
!  FUNCTION:           TO OUTPUT THE STRING IN TLINE1(I+I-1).
!                      IF TLINE1(I+I-1)<0 OR CNTFLG=0 THEN WRITE
!                      6 BLANKS, ELSE OUTPUT 6 CHARS FROM TLINE1(I+I-1).
!                      THEN IF TLINE1(I+I)>0 COMPUTE THE VALUE OF
!                      TLINE1(I+I-1)/TLINE1(I+I)*100. AND OUTPUT IT.
!
!  INPUT:              I = INDEX TO TLINE1
!
!  OUTPUT:             NONE
!
!  ERRORS DETECTED:    NONE
!
!  ROUTINES CALLED:    STRNG,FLSTR,PACK6
!
%OUTCL1(I)

       LOCAL FPCT(0:1),J,K
       IF TLINE1(I+I-1)<0 OR NOT CNTFLG  THEN DO
               WRITE(@BLNK6,OFL)
       END ELSE DO
               STRNG(TLINE1(I+I-1),@TSTR)
               PACK6(@TSTR)
       END


       IF TLINE1(I+I)<0 THEN DO
               WRITE(@BLNK6,OFL)
       END ELSE DO
               J_TLINE1(I+I-1); K_TLINE1(I+I)
               [FPCT(0);FPCT(1)]_DOUBLE PERCNT(J,K)
               IF FPCT(0)<0 THEN DO
                               WRITE("   *  ",OFL)
               END ELSE DO
                      FLSTR(FPCT(0),FPCT(1),@TSTR)
                      PACK6(@TSTR)
               END
       END

       RETURN
END OUTCL1



!
!  NAME:               OUTCL2(I)
!  
!  FUNCTION:           TO OUTPUT THE VALUE OF
!                      TLINE1(I+I-)/TLINE2(I+I-1)*100.
!                      IF THIS IS NEGATIVE OUTPUT 6 BLANKS.
!                      THEN OUTPUT THE QUANTITY
!                      TLINE1(I+I-1)/TLINE2(I+I)*100.  IF THIS IS
!                      NEGATIVE THE N OUTPUT 6 BLANKS.
!
!  ERRORS DETECTED:    NONE
!
!  ROUTINES CALLED:    STRNG,FLSTR,PACK6
%OUTCL2(I)

       LOCAL FPCT(0:1),J,K
       J_TLINE1(I+I-1); K_TLINE2(I+I-1)
       IF K<0 THEN DO
               WRITE(@BLNK6,OFL)
       END ELSE DO
               [FPCT(0);FPCT(1)]_DOUBLE PERCNT(J,K)
               IF FPCT(0)<0 THEN DO
                         WRITE("   *  ",OFL)
               END ELSE DO
                       FLSTR(FPCT(0),FPCT(1),@TSTR)
                      PACK6(@TSTR)
               END
       END


       IF TLINE2(I+I)<0 THEN DO
               WRITE(@BLNK6,OFL)
       END ELSE DO
               K_TLINE2(I+I);J_TLINE1(I+I-1)
               [FPCT(0);FPCT(1)]_DOUBLE PERCNT(J,K)
               IF FPCT(0)<0 THEN DO
                         WRITE("   *  ",OFL)
               END ELSE DO
                           FLSTR(FPCT(0),FPCT(1),@TSTR)
                         PACK6(@TSTR)
               END
       END

       RETURN
END OUTCL2












SURVEY ** FICHE/FRAME BREAK *****
/CPAVIMPS:SIMP/ SYMSORT

SYM.  PG.LN. IDENT.

!      18  8 M!!!    !      18  7 M!!!    !      18  6 M!!!    !      18  5 M!!!    
!      18  4 M!!!    !      18  3 M!!!    !      18  2 M!!!    !      17  8 M!!!    
!      17  7 M!!!    !      17  6 M!!!    !      17  5 M!!!    !      15 18 M!!!    
!      15 17 M!!!    !      15 16 M!!!    !      15 13 M!!!    !      15 10 M!!!    
!      15  9 M!!!    !      13 26 M!!!    !      13 25 M!!!    !      13  4 M!!!    
!      12 17 M!!!    !      12 14 M!!!    !      11 26 M!!!    !      11 23 M!!!    
!      11 22 M!!!    !      11 21 M!!!    !      11 20 M!!!    !       8 35 M!!!    
!       8 33 M!!!    !       5 37 M!!!    !       5 19 M!!!    !       5 15 M!!!    
!       5 14 M!!!    !       5 13 M!!!    !       5 12 M!!!    !       4  8 M!!!    
!       4  7 M!!!    !       4  6 M!!!    !       4  5 M!!!    !       4  2 M!!!    
!       4  1 M!!!    !       3 38 M!!!    !       3 37 M!!!    !       3 24 M!!!    
!       3 22 M!!!    !!!     1  4 M!!!    !!!     1  3 M!!!    !!!     1  2 M!!!    
!***** 13 27 M!!!    !***** 13 24 M!!!    !****M 16  1 M!!!    !DEF    3 18 M!!!    
!LM!   18  1 M!!!    !LM!   17  3 M!!!    !LM!   15  7 M!!!    !LM!   13  2 M!!!    
!LM!   11 18 M!!!    !LM!    8 31 M!!!    !LM!    7 30 M!!!    !LM!    5 35 M!!!    
!LM!    5 10 M!!!    !LM!    3 36 M!!!    !LM!    3 21 M!!!    !M      6 39 M!!!    
!M      6 33 M!!!    !M!    18 10 M!!!    !M!    18  9 M!!!    !M!    17 12 M!!!    
!M!    17 11 M!!!    !M!    17 10 M!!!    !M!    17  9 M!!!    !M!    17  4 M!!!    
!M!    15 14 M!!!    !M!    15 12 M!!!    !M!    15 11 M!!!    !M!    15  8 M!!!    
!M!    13  7 M!!!    !M!    13  6 M!!!    !M!    13  5 M!!!    !M!    13  3 M!!!    
!M!    12 19 M!!!    !M!    12 18 M!!!    !M!    12 16 M!!!    !M!    12 15 M!!!    
!M!    12 13 M!!!    !M!    11 27 M!!!    !M!    11 25 M!!!    !M!    11 24 M!!!    
!M!    11 19 M!!!    !M!     8 38 M!!!    !M!     8 37 M!!!    !M!     8 36 M!!!    
!M!     8 34 M!!!    !M!     8 32 M!!!    !M!     7 33 M!!!    !M!     7 32 M!!!    
!M!     7 31 M!!!    !M!     5 36 M!!!    !M!     5 18 M!!!    !M!     5 17 M!!!    
!M!     5 16 M!!!    !M!     5 11 M!!!    !M!     4  9 M!!!    !M!     4  4 M!!!    
!M!     4  3 M!!!    !M!     3 39 M!!!    !M!     3 27 M!!!    !M!     3 26 M!!!    
!M!     3 25 M!!!    !M!     3 23 M!!!    !M!     1  5 M!!!    !M!M!  13  8 M!!!    
!M!M!   6 32 M!!!    !MDEF   1  6 M!!!    %STATM 12 25 M!!!    %TITLM 14  1 M!!!    
ASQ:    4 38 M!!!    B608:   6 15 M!!!    CT0:   15 24 M!!!    
CT1:   15 36 M!!!    CT:    15 25 M!!!    DEF     3 17 M!!!    DEF     3 14 M!!!    
DEF     3 13 M!!!    DEF     3  9 M!!!    DEF     3  6 M!!!    DEF     3  5 M!!!    
DEF     3  4 M!!!    DEF     1 20 M!!!    E608:   7 11 M!!!    END    19  1 M!!!    
END    17 36 M!!!    END    17  1 M!!!    END    16  6 M!!!    END    15  4 M!!!    
END    13 34 M!!!    END    13 19 M!!!    END    13  1 M!!!    END    12 23 M!!!    
END    12 10 M!!!    END    11 37 M!!!    END    11 17 M!!!    END    10  7 M!!!    
END     8 27 M!!!    END     7 29 M!!!    END     5 32 M!!!    END     5  7 M!!!    
END     3 35 M!!!    ENDM    3 11 M!!!    ENDM    3  8 M!!!    ERN:   10  4 M!!!    
FIND    2 34 M!!!    FIND    2 33 M!!!    FIND    2 32 M!!!    FIND    2 31 M!!!    
FIND    2 30 M!!!    FIND    2 29 M!!!    FIND    2 28 M!!!    FIND    2 27 M!!!    
FIND    2 26 M!!!    FIND    2 25 M!!!    FIND    2 24 M!!!    FIND    2 23 M!!!    
FIND    2 22 M!!!    FIND    2 21 M!!!    FIND    2 20 M!!!    FIND    2 19 M!!!    
FIND    2 18 M!!!    FIND    2 17 M!!!    FIND    2 16 M!!!    FIND    2 15 M!!!    
FIND    2 14 M!!!    FIND    2 13 M!!!    FIND    2 12 M!!!    FIND    2 11 M!!!    
FIND    2 10 M!!!    FIND    2  9 M!!!    FIND    2  8 M!!!    FIND    2  7 M!!!    
FIND    2  6 M!!!    FIND    2  5 M!!!    FIND    2  4 M!!!    FIND    2  3 M!!!    
FIND    2  2 M!!!    FIND    2  1 M!!!    FIND    1 39 M!!!    FIND    1 38 M!!!    
FIND    1 37 M!!!    FIND    1 36 M!!!    FIND    1 35 M!!!    FIND    1 34 M!!!    
FIND    1 33 M!!!    FIND    1 32 M!!!    FIND    1 31 M!!!    FIND    1 30 M!!!    
FIND    1 29 M!!!    FIND    1 27 M!!!    FIND    1 26 M!!!    FIND    1 25 M!!!    
FIND    1 24 M!!!    FIND    1 23 M!!!    FIND    1 22 M!!!    FIND    1 19 M!!!    
FIND    1 18 M!!!    FIND    1 17 M!!!    FIND    1 16 M!!!    FIND    1 15 M!!!    
FIND    1 14 M!!!    FIND    1 13 M!!!    FIND    1 12 M!!!    FIND    1 11 M!!!    
FIND    1 10 M!!!    FIND    1  9 M!!!    GLOBAL  2 37 M!!!    GLOBAL  2 36 M!!!    
GLOBAL  1 28 M!!!    GLOBAL  1 21 M!!!    GT1:   11 39 M!!!    H1:     6  2 M!!!    
ID0:    9 32 M!!!    ILP1:  10 23 M!!!    ILP2:  10 27 M!!!    ILP:   10 18 M!!!    
L:     12 36 M!!!    LOCAL   1  8 M!!!    M***** 14 15 M!!!    MM%FSC  7 34 M!!!    
MM%SHO 12 20 M!!!    MOUTCL 18 11 M!!!    NOCO:  11 16 M!!!    O*****  5  6 M!!!    
O*****  5  1 M!!!    O.-.-. 12 12 M!!!    OM%HIS  5 38 M!!!    OYESNO 11 38 M!!!    
QUEL:  12  3 M!!!    QUOI:  12  7 M!!!    RW1:   13 32 M!!!    SF0:    7 37 M!!!    
SF1:    8  1 M!!!    SF2:    8 11 M!!!    SF2A:   8 13 M!!!    TID:    9  2 M!!!    
TIDX:   9 18 M!!!    TS1:   15  2 M!!!    TSCH:  14 30 M!!!    YN1:   12  5 M!!!    
]M%COL 15 15 M!!!    ]M%OUT 17 13 M!!!    _CORCO 10 10 M!!!    _FLSTR  5 20 M!!!    
_ISPLA  3  7 M!!!    _IST(0  3 10 M!!!    _M%AVR  4 10 M!!!    _M%PAC 11 28 M!!!    
_M%PER  3 28 M!!!    _M%TAB  8 39 M!!!    _M%VER 13  9 M!!!    _PCNTC 16 13 M!!!    
_RWTTL 13 22 M!!!    
SURVEY ** FICHE/FRAME BREAK *****
/CPAVIOFUNC:SRCE/
*
* THIS ROUTINE NEEDS NO MODIFICATION FOR BILINGUAL VERSION
*
IO IDENT
************IO AND FILE ROUTINES FOR SIMPL PROGRAMS***********************
A BSS 1
B BSS 1
X BSS 1
RET BSS 1
FTYP BSS 1
IOTYP BSS 1
FLNO BSS 1
TBRS BSS 1
TEMP BSS 2
ERRET BSS 1


*
*

*
*  NAME               CAROUT
*
*  FUNCTION:          TO WRITE (A REG) (B REG) TIMES ON FILE (X REG)
*
*  INPUT              A REG = CHARACTER TO BE OUTPUT
*                     B REG = UNIT NUMBER
*                     X REG = COUNT
*
*  OUTPUT:            NONE
*
*  ROUINTES CALLED:   NONE
*
*  ERRORS DETECTED:   NONE
*
$CAROUT ZRO 0
       STA A
       CLA
       SKE CFLNO
       BRR CAROUT  SUPPRESS PRINTING IF COMMANF FILE
       LDA A
       STX TEMP; STB TEMP+1
       BRU CAR1
CAR2   CIO TEMP+1
CAR1   SKR  TEMP
       BRU     CAR2
       BRR CAROUT

*
*  NAME:              OUTNUM
*
*  FUNCTION:          TO WRITE THE ASCII REPRESENTATION OF 
*                     A BINARY INTEGER TO THE TERMINAL. (USES BRS 36)
*
*  INPUT:             A REG = NUMBER TO BE CONVERTED
*                     B REG = RADIX
*
*  OUTPUT:            NONE
*
*  ERRORS DETECTED:   NONE
*
*  ROUTINES CALLED:   NONE
*
$OUTNUM ZRO 0
       STA A
       CLA
       SKE CFLNO
       BRR OUTNUM
       LDA A
       BRS 36; BRR OUTNUM


*
*
*
*  NAME:              WRITE
*
*  FUNCTION:          TO WRITE A STRING TO A FILE
*
*  INPUT:             A REG = FWA OF STRING
*                     B REG = UNIT NUMBER
*
*  OUTPUT:            NONE
*
*  ERRORS DETECTED:   NONE
*
$WRITE ZRO 0
 STB TEMP+1
 MUL =3  
 LSH 23  
 ADD =-1
 STA TEMP
LW MIN TEMP
 LDA TEMP
 MUL =12525253B  
 CAX  
 LSH 5  
 ETR =30B  
 LDB 0,2  
 COPY BA,AX  
 LSH 8,2  
 ETR =377B  
 SKG =127
 BRU OCAR
 BRR  WRITE
OCAR CIO TEMP+1
 BRU LW

*
*

*
*  NAME               ARM
*
*  FUNCTION:          TO SET LOCATION TO TRAP TO WHEN ESCAPE DETECTED,
*                     ARMS ESCAPES
*  INPUT:             A REG = LOCATION TO TRAP TO
*
*  OUTPUT:            NONE
*
*  ERRORS DETECTED:   NONE
*
*  ROUTINES CALLED:   NONE
*
$ARM    ZRO 0   !ARM ESCAPE INTERRUPT
       ADD =1B5 (BRU OPCODE); STA ESCGO; LDA =ESC; STA 201B
       LDA =2B6; BRS 78
       BRR ARM

ESC    ZRO ESCRET
 STA A; STB B; STX X
ESCGO  ZRO 0
$ESCRET  DATA 0  (ESCAPE LOCATION

$RETESC ZRO 0
       LDA A; LDB B; LDX X; BRS 114; BRU* ESCRET
  END
SURVEY ** FICHE/FRAME BREAK *****
/CPAVIOFUNC:SRCE/ SYMSORT

SYM.  PG.LN. IDENT.

A       1  5 *M*     ARM     4  7 *M*     B       1  6 *M*     
CAR1    2  5 *M*     CAR2    2  4 *M*     CAROUT  1 35 *M*     ERRET   1 14 *M*     
ESC     4 12 *M*     ESCGO   4 14 *M*     ESCRET  4 15 *M*     FLNO    1 11 *M*     
FTYP    1  9 *M*     IO      1  3 *M*     IOTYP   1 10 *M*     LW      3 14 *M*     
OCAR    3 27 *M*     OUTNUM  2 24 *M*     RET     1  8 *M*     RETESC  4 17 *M*     
TBRS    1 12 *M*     TEMP    1 13 *M*     WRITE   3  8 *M*     X       1  7 *M*     

SURVEY ** FICHE/FRAME BREAK *****
/CPAVLIST:SIMP/
!
! ROUTINE MODIFIED FOR BILINGUAL VERSION 5/74 BY B. THORNQUIST
!

DEF BI(ENGLISH,FRENCH) AS ENGLISH
FIND %SCAN,%READ,%IBRS,%DISPLAY,%EQUAL,%LENGTH
FIND CURPOS,TOKEN(0:24),TYPE,VALUE
GLOBAL %GETLIST,%NXTITEM
GLOBAL LSTPNT,LIST(60),LISERR,LCNT,TEL
LOCAL I,J,K
DEF OUTNUM(X) AS IBRS(X,10,1,36)
DEF NUMTYPE AS 2
DEF SYMTYPE AS 3
DEF RESTYPE AS 4
DEF EOLTYPE AS 5
DEF ENDLIST AS OCT 20000000
DEF NOTYPES AS 10




!
!  NAME:              GETLIST(@ERR,IMIN,IMAX)
!
!  FUNCTION:          THIS ORUTINE IS CALLED EVERY TIME A PROGRAM
!                     EXPECTS A LIST.
!                     A LIST HAS THE FORM:
!                     <LIST>:=:<SUBLIST>+<SUBLIST>,<LIST>
!
!                     <SUBLIST>:=:<NUMBER>+<NUMBER><TO><NUMBER>+
!                                   <NUMBER><TO><NUMBER><BY><NUMBER>
!                     WHERE + IS A LOGICAL EXCLUSIVE OR.
!                     GETLIST TRANSLATES THIS LIST INTO SINGLETS
!                     OR TRIPLETS (START,END,INCREMENT) INTHE VARIABLE
!                     LIST.
!  
!  INPUT:             LIST IN BUFF
!
!  OUTPUT:            TRANSLATED LIST IN -LIST-
!
!  ERRORS DETECTED:   AN IMPROPER LIST CAUSES ERR TO BE SET
!
!  ROUTINES CALLED:   SCAN
!  ROUTINES CALLED:   SCAN
%GETLIST(@ERR,IMIN,IMAX)

LOCAL PNT,AOK,PAROK,CMPLX,FNDINC

       LSTPNT_1
       ERR_PAROK_PNT_CMPLX_FNDINC_0
       A.OK_1   !ALRIGHT TO FIND 'A'!
       GO NUM1   ! AT ENTRY CALLING ROUTINE AS ALREADY GOTTEN FIRST NUMBER

BEGN:  SCAN
       IF TYPE=EOLTYPE THEN GO RET
       GO NUM1

GETNUM: SCAN
NUM1:  IF TYPE#NUMTYPE THEN DO
               ERR_1
               GO RET
       END

! CHECK MIN/MAX IF NUMBER IS NOT AN INCREMENT !

       IF NOT FND.INC THEN DO
               IF VALUE<IMIN OR VALUE>IMAX THEN [ERR_1; GO RET]
       END

       INC PNT
       LIST(PNT)_VALUE

       GO GETSYM

GETSYM: SCAN
       DO TYPE+1 OF NOTYPES
               1:2:3:7:8:9:10: ERR_1; GO RET
               6: GO RET
               4: IF NOT EQUAL(@TOKEN,",") THEN [ERR_1; GO RET]
                  IF CMPLX THEN DO
                               IF NOT FND.INC THEN&
                               [INC PNT;  LIST(PNT)_1]
                               BYT(LIST(PNT-2),1,23)_1
                  END
                  FND.INC_CMPLX_PAR.OK_0; A.OK_1 !RESET FLAGS!
                  GO GETNUM
               5: IF EQUAL(@TOKEN,BI("TO","A")) THEN DO
                               IF NOT A.OK THEN [ERR_1; GO RET]
                               A.OK_0
                               CMPLX_PAR.OK_1
                               GO GETNUM
                  END ELSE IF EQUAL(@TOKEN,BI("BY","PAR")) THEN DO
                               IF NOT PAR.OK THEN [ERR_1; GO RET]
                               PAR.OK_A.OK_0; FND.INC_1
                               GO GETNUM
                  END ELSE [ERR_1; GO RET]

       END

RET:   IF CMPLX THEN DO
               IF NOT FND.INC THEN [INC PNT; LIST(PNT)_1]
               BYT(LIST(PNT-2),1,23)_1
       END
       INC PNT; LIST(PNT)_ENDLIST
       CURPOS_CURPOS-LENGTH(@TOKEN)
       RETURN

END GETLIST


!
!  NAME:              NXITEM
!
!  FUNCTION:          RETURNS THE NEXT ITEM IN THE LIST CONSTRUCTED
!                     BY GETLIST.
!
!  INPUT:             NONE
!
!  OUTPUT:            RETURNS NEXT ITEM
!
!  ERRORS DETECTED:   NONE
!
!  ROUTINES CALLED:   NONE
!
%NXTITEM

LOCAL I,J,K

       I_LIST(LSTPNT)
       IF BYT(I,1,23)=1 THEN DO
               BYT(I,1,23)_0
               J_LIST(LSTPNT+1)
               K_LIST(LSTPNT+2)
               IF (I+K)>J THEN LSTPNT_LSTPNT+3 ELSE&
               LIST(LSTPNT)_LIST(LSTPNT)+K
               RETURN I
       END ELSE [INC LSTPNT; RETURN I]

END NXTITEM
SURVEY ** FICHE/FRAME BREAK *****
/CPAVLIST:SIMP/ SYMSORT

SYM.  PG.LN. IDENT.

!       3 24 !M!     !       2 14 !M!     !       1 35 !M!     !       1 31 !M!     
!       1 30 !M!     !       1 29 !M!     !       1 28 !M!     !       1 27 !M!     
!       1 26 !M!     !       1 25 !M!     !       1 23 !M!     !       1 22 !M!     
!       1 21 !M!     !LM!    3 22 !M!     !LM!    1 19 !M!     !M!     3 28 !M!     
!M!     3 27 !M!     !M!     3 26 !M!     !M!     3 25 !M!     !M!     3 23 !M!     
!M!     1 34 !M!     !M!     1 33 !M!     !M!     1 32 !M!     !M!     1 24 !M!     
!M!     1 20 !M!     !MMDEF  1  2 !M!     BEGN:   2  4 !M!     
DEF     1 14 !M!     DEF     1 13 !M!     DEF     1 12 !M!     DEF     1 11 !M!     
DEF     1 10 !M!     DEF     1  9 !M!     DEF     1  8 !M!     END     4  2 !M!     
END     3 19 !M!     FIND    1  4 !M!     FIND    1  3 !M!     GETNUM  2  8 !M!     
GETSYM  2 25 !M!     GLOBAL  1  6 !M!     GLOBAL  1  5 !M!     LOCAL   1  7 !M!     
NUM1:   2  9 !M!     OM%NXT  3 29 !M!     RET:    3 11 !M!     _GETLI  1 36 !M!     

SURVEY ** FICHE/FRAME BREAK *****
/CPAVMAJ1:SIMP/
!!! MAJ VERSION C (SUBROUTINES)
!   MODIFIED 3/27/75 FOR MODULO 100 CARD FORMAT
     DEF BI(ENGLISH,FRENCH) AS ENGLISH
!!!  MAJ VARIABLES

FIND CMND:
FIND QCUR
FIND DMOD,QMOD,TMOD,ESCAPE:,OTIME
FIND TSTR(0:1),BADDIC:
!!! SUPERGLOBALS

FIND TEL,DIC,RL1,RL2,NMPAGE,QCBPAGE

!!! DICTIONARY CONTROL BLOCK

GLOBAL RESTRUC:,FORMAT:,CARTES:,QUIT:
FIND DICVERS,NQUES,CDPLST,CDPLND,LLBPLST,LLBPLND,QCBADR
FIND NAMADR,QSIZE,QVERS,FMT,NMCRD,QNOPOS,QNOLEN,CDNOPOS,CDNOLEN

!!! SHARABLE PAGES

FIND QNAME(),QCBS(),LIB()

!!! EXTERNAL FUNCTIONS

FIND %BCLOS,%BERX,%BOUT,%OUTNO
FIND %ADDSTR,%STRNG
FIND %ARM,%LENGTH,%LEFT,%DISPLAY,%EQUAL
FIND %SWAPIN  !GLOBAL FUNCTION!
FIND %TRNSTR,%GETLIST,%NXTITEM

!!! SCANNER AND OTHER GLOBAL  VARIABLES AND FUNCTIONS

FIND TYPE,VALUE,TOKEN(0:1),%READ,%SCAN
FIND BUFF(0:1),NEWBUF(0:1)
FIND LIST(1)  !LIST PROCESSOR BUFFER

!!! SCANNER TYPES

DEF ALPHTYPE AS 1
DEF NUMTYPE AS 2
DEF EOLTYPE  AS 5
DEF QSTYPE AS 6
DEF FLTYPE AS 7

!!! LOCAL FUNCTIONS

!!! MACROS

DEF ENDLIST AS OCT 20000000
DEF NFILTS AS 48
DEF MXQUES AS 512-48
DEF RING AS BOUT(OCT 147)
!DEF OUTNO(X) AS \BRS 36 (X,10,1)
DEF LIST.IS.ALL BY
               LIST(0)_1 !LIST POINTER
               LIST(1)_OCT 40000001; LIST(2)_NQUES; LIST(3)_1
               LIST(4)_ENDLIST
               SCAN
               IF TYPE#EOLTYPE THEN SYNERR(BI("SYNTAX","SYNTAXEZ"))
ENDM LIST.IS.ALL
DEF PROMPT(X) BY
       DISPLAY(X,0,0)
       READ(@TEL)
ENDM PROMPT
DEF DREAD(WHAT,NUM,WHERE) BY
       \SCP (DIC,WHERE,GO BADDIC)
       \BIO (DIC,NUM,,WHAT,GO BADDIC)
ENDM DREAD
DEF DWRITE(WHAT,NUM,WHERE) BY
DREAD(WHAT,NUM,WHERE+OCT 40000000)
ENDM DWRITE
DEF QQCBS(X,Y) AS QCBS((X-1)*4+Y)
DEF QQNAME(X,Y) AS QNAME((X-1)*4+Y)
DEF LLIB(X,Y) AS LIB((X-1)*9+Y)

LOCAL PMFLG,CLPOS,NMCOL,FMTYP,I,CNCD,CQNL,CQPS,CCPS,CCNL

GLOBAL %WARN.HIM
FIND CVERS  !BIN VERSION CHANGE
GLOBAL %INITIAL,%SYNERR,%DICRIT,%QINIT,%BINIT,%TOUT,%SHORT
GLOBAL %FMTRTN,%CRTRTN,%RESRTN

%FMTRTN
       IF FMT=0 THEN DO
               SYNERR(BI("COMMAND INVALID FOR OTHER THAN CARD FORMAT.", &
               "L'ORDRE N'EST VALABLE QUE POUR FORMAT CARTE."))
       END
       IF NMCRD=0 THEN DO
               SYNERR(BI("USE THE COMMAND 'CARDS' BEFORE THIS COMMAND", &
               "UTILISER L'ORDRE 'CARTES' AVANT CET ORDRE!"))
       END
       
FORMOT: SCAN


       IF TYPE=EOLTYPE THEN DO
               PROMPT('QUESTION(S): ')
               GO FORMOT
       END

       IF TOUT THEN DO
               LIST.IS.ALL
       END ELSE DO
               IF TYPE=QSTYPE THEN TYPE_NUMTYPE
               GETLIST(@I,1,NQUES)
               IF I THEN SYNERR(BI("SYNTAX","SYNTAXE"))
       END

!!! GET QUES.

FMT1:  QCUR_NXTITEM
       IF QCUR=ENDLIST THEN RETURN

FMT2:  PMFLG_0
       OUTNO(QCUR); BOUT($:); BOUT($ )
       READ(@TEL)

!!! GET BEGINNING COL. NO. FOR QUES

FMTP:  SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT('POSITION (COL.): ')
               GO  FMTP
       END

       IF CH(@TOKEN)=$, THEN GO FMTP
       IF TYPE#NUMTYPE THEN [DISPLAY(BI("SYNTAX","SYNTAXE"),0,1); GO FMT2]
!*****
!      MODIFIED FOR MODULO 100 FORMAT
!      E.G. 101 IMPLIES CARD 1, POS 1
!             203 IMPLIES CARD 2, POS 3
!             UND SO WEITER

LOCAL BQUO,BREM

       IF VALUE<101 THEN [DISPLAY("COLUMN POSITION MUST BE > 100",0,1); &
                          GO FMT2]

       [BQUO;BREM] _ VALUE DIVMOD 100 ! GET QUOTIENT AND REM MODULO 100
       CLPOS _ ((BQUO-1)*80) + BREM
!****

!!! GET NUMBER OF COLS. PER ANSWER

FMTC:  SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT(BI("COLS./RESPONSE: ","COLS./REPONSE: "))
               PMFLG_1
               GO FMTC
       END
! REASON FOR 'PMFLG': IF PROMPTED FOR  COLS/ANS THEN I WANT TO
!                     PROMPT FOR ALPHA/NUM TYPE EVEN THOUGH THIS IS
!                     NORMALLY A DEFAULT OPTION (WHEN NOT PROMPTING)

       IF CH(@TOKEN)=$, THEN GO FMTC
       IF TYPE#NUMTYPE THEN [DISPLAY('SYNTAXE!',0,1); GO FMT2]
       IF VALUE<1 OR VALUE>7 THEN DO
               DISPLAY(BI("COLS/RESPONSE BETWEEN 1 AND 7!", &
                "COLS/REPONSE ENTRE 1 ET 7!"),0,1); GO FMT2
       END
       I_CLPOS+(BYT(QQCBS(QCUR,0),5,0)*VALUE)-1
       IF I>80*NMCRD THEN DO
               DISPLAY(BI("OVERFLOW OF INPUT RECORD", &
               "DEBORDEMENT DE L'ENREG. D'ENTEEZ"),0,1)
               GO FMT2
       END
       NMCOL_VALUE
       IF NMCOL>1 THEN PMFLG_0 ! EVEN IF PROMPTED TYPE = 'N' !

!!! ALPHA OR NUMERIC CODES ?

FMTT:  SCAN
       IF TYPE=EOLTYPE AND PMFLG=0 THEN DO
               FMTYP_0
               GO FMTQ  !MOD QCB FOR QUES !
       END ELSE IF TYPE=EOLTYPE THEN DO
               PROMPT(BI("CHARACTER OR NUMERIC: ","CARACTERE OU NUMERIQUE: "))
               PMFLG_0
               GO FMTT
       END
       IF CH(@TOKEN)=$, THEN GO FMTT
       IF SHORT(BI("ALPHA","CARACTERE")) OR SHORT("CHARACTER") THEN DO
               IF NMCOL>1 THEN DO
               DISPLAY(BI("MULTI-COL. RESPONSES MUST BE NUMERIC.", &
               "REPONSES MULTI-COLS. DOIVENT ETRE NUMERIQUES"),0,1)
               GO FMT2
               END
               FMTYP_1
               GO FMTQ  ! MOD QCB  !
       END ELSE IF SHORT(BI("NUMERIC","NUMERIQUE")) THEN DO
               FMTYP_0
               GO FMTQ
       END ELSE [DISPLAY(BI("SYNTAX","SYNTAXE"),0,1); GO FMT2]

!!! MOD. WORD 0 OF QCB FOR QCUR

FMTQ:  SCAN
       IF TYPE#EOLTYPE THEN [DISPLAY(BI("SYNTAX","SYNTAXE"),0,1); GO FMT2]
       \BRS 113
!*****************
       BYT(QQCBS(QCUR,0),11,7)_CLPOS
!*****************
       BYT(QQCBS(QCUR,0),3,18)_NMCOL
       BYT(QQCBS(QCUR,0),1,22)_FMTYP
       INC QVERS; WARN.HIM
       QMOD_1
       DMOD_1
       \BRS 114
       GO FMT1

!---------------------------------------------------CARD FORMAT ROUTINE

END FMTRTN

%CRTRTN

       IF FMT=0 THEN DO
               SYNERR(BI("COMMAND VALID ONLY FOR CARD FORMAT", &
               "L'ORDRE N'EST VALABLE QUE POUR FORMAT CARTE!"))
       END
CARTOS:  SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT(BI("NUMBER OF CARDS PER Q'AIRE: ", &
                "NOMBRE DE CARTES PAR Q'AIRE: "))
               GO CARTOS
       END
       IF CH(@TOKEN)=$, THEN GO CARTOS
       IF TYPE#NUMTYPE THEN SYNERR(BI("SYNTAX","SYNTAXE"))
       IF VALUE<1 OR VALUE>25 THEN SYNERR(BI("BETWEEN 1 AND 25", &
       "ENTRE 1 ET 25"))
       CNCD_VALUE

!!! LENGTH OF Q'AIRE NUMBER

CRD0:  SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT(BI("LENGTH OF Q'AIRE NUMBER (NO. OF COLS.): ", &
               "LONGEUER DU NUMERO DE Q'AIRE (NOMBRE DE COLS.) : "))
               GO CRD0
       END

       IF CH(@TOKEN)=$, THEN GO CRD0
       IF TYPE#NUMTYPE THEN SYNERR(BI("SYNTAX","SYNTAXE"))
       IF VALUE>6 OR (VALUE=0 AND CNCD#1) THEN &
               SYNERR(BI("BETWEEN 1 AND 6","ENTRE 1 ET 6"))
       CQNL_VALUE
       IF CQNL=0 THEN [CQPS_0; GO CD11]  !DON'T ASK POS IF LENGTH=0

!!! COL. NUMBER FOR Q'AIRE NUMBER

CRD1:  SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT(BI("POSITION OF Q'AIRE NUMBER (COL.): ", &
               "POSITION (COL.) DU NUMERO DE Q'AIRE: "))
               GO CRD1
       END
       IF CH(@TOKEN)=$, THEN GO CRD1

       IF TYPE#NUMTYPE THEN SYNERR(BI("SYNTAX","SYNTAXE"))
       IF VALUE<1 OR VALUE>81-CQNL THEN &
               SYNERR(BI("INVALID COL. NUMBER","NUMERO DE COLONNE ERRONE"))
       CQPS_VALUE


!!! IF MUTIPLE CARDS GET CARD NO. POSITION AND LENGTH

CD11:  IF CNCD=1 THEN DO
               CCPS_CCNL_0
               GO CRDD   ! MOD DIC !
       END

CRD2:  SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT(BI("LENGTH OF CARD NUMBER (NO. OF COLS.): ",&
               "LONGEUER DU NUMERO DE CARTE (NOMBRE DE COLS.): "))
               GO CRD2
       END

       IF CH(@TOKEN)=$, THEN GO CRD2
       IF TYPE#NUMTYPE THEN SYNERR(BI("SYNTAX","SYNTAXE"))
       IF VALUE<1 OR VALUE>6 THEN &
               SYNERR(BI("BETWEEN 1 AND 6","ENTRE 1 ET 6"))
       CCNL_VALUE

CRD3:  SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT(BI("POSITION OF CARD NUMBER (COL.) : ",&
                "PSOITION (COL.) DU NUMERO DE CARTE : "))
               GO CRD3
       END

       IF CH(@TOKEN)=$, THEN GO CRD3
       IF TYPE#NUMTYPE THEN SYNERR(BI("SYNTAX","SYNTAXE"))
       IF VALUE<1 OR VALUE>81-CCNL THEN &
               SYNERR(BI("INVALID COLUMN NUMBER",'NUMERO DE COLONNE ERRONE'))

       CCPS_VALUE

!!! MODIFY CARD FORMAT ENTRIES IN DIC

CRDD:  SCAN
       IF TYPE#EOLTYPE THEN SYNERR('SYNTAXE')

       \BRS 113
       NMCRD_CNCD
       QNOPOS_CQPS
       QNOLEN_CQNL
       CDNOPOS_CCPS
       CDNOLEN_CCNL
       INC QVERS; WARN.HIM
       DMOD_1
       \BRS 114
       RETURN

END CRTRTN
!
!  NAME:              INITIAL
!
!  FUNCTION:          TO SWAP IN QUESTION AND FILTER NAMES PAGE,
!                     HEADER PAGE, QCB PAGE, AND ARM ESCAPE ROUTINE.
!
!  INPUT:             NONE
!
!  OUTPUT:            NONE
!
!  ERRORS DETECTED:   NONE
!
!  ROUTINES CALLED:   NONE
!
%INITIAL

       \BRS 43; \STA (RL1); \STB (RL2)! GET RELABELING
       SWAPIN(NMPAGE,7); QNAME_OCT 34000
       LIB_OCT 24000
       SWAPIN(QCBPAGE,6); QCBS_OCT 30000
       CVERS_0
       ARM(ESCAPE)
       \BRS 114
       RETURN
END INITIAL


!--------------------------------------------- SYNTAX ERROR ROUTINE

%SYNERR(@X)
FIND CMND:

       BCLOS
       \BRS 11 (,,-1)  !CLEAR INPUT BUFFER
       DISPLAY(BI("ERROR AT:","ERREUR A: "),0,0); DISPLAY(@TOKEN,0,1)
       DISPLAY(@X,0,1)
       BERX
       GO CMND

END SYNERR
!
!  NAME:              DICRIT
!
!  FUNCTION:          DISARMS ESCAPES, WRITES DCB, QCB, AND QUESTION
!                     AND FILTER NAME BLOCKS IF THESE HAVE BEEN MODIFIED.
!                     ENABLES ESCAPES
!
!  INPUT:             NONE
!
!  OUTPUT:            NONE
!
!  ERRORS DETECTED:   NONE
!
!  ROUTINES CALLED:   DWRITE
!
%DICRIT
       OTIME_\BRS 42
       IF DMOD+QMOD+TMOD=0 THEN RETURN  !NO MODIFS
       \BRS 113
       IF DMOD THEN DO
               RING
               DMOD_0
               DWRITE(@DICVERS,16,0)
       END
       IF QMOD THEN DO
               RING; RING; QMOD_0
               DWRITE(QCBS,NQUES*4,QCBADR)
       END
       IF TMOD THEN DO
               RING; RING; RING; TMOD_0
               DWRITE(QNAME,2048,NAMADR)
       END
       \CLA; \SCP (DIC,GO BADDIC)  !SET TO READ MODE
       \BRS 114
       RETURN
END DICRIT
!
!  NAME:              QINIT
!
!  FUNCTION:          INITIALIZES QUESTION STATUS TO UNDEFINED
!
!  INPUT:
!
!  OUTPUT:            NONE
!
!  ERRORS DETECTED:   NONE
!
!  ROUTINES CALLED:   ADDSTR
!

%QINIT(LOW,HIGH,@QPTR)

       QCUR_LOW
QIN1:  NULL
        QQCBS(QCUR,0)_1  !INITIAL VECSIZE
       QQCBS(QCUR,1)_QPTR
       INC QPTR
       QQCBS(QCUR,2)_ 0       ! UNDEFINED
       QQCBS(QCUR,3)_ 0       ! UNDEFINED

       STRNG(QCUR,@TSTR)
       ADDSTR("QUES. ",@TSTR,@QQNAME(QCUR,0))
       IF INC QCUR<= HIGH THEN GO QIN1

       RETURN

END QINIT

%BINIT
       I_1
L1:    STRNG(I,@TSTR)
       ADDSTR(BI("FILTER ","FILTRE"),@TSTR,@QQNAME(MXQUES+I,0))
       IF INC I <= NFILTS THEN GO L1 ELSE RETURN
END BINIT


!
!  NAME:              TOUT
!
!  FUNCTION:          RETURNS A TRUE VALUE IF THE CONTENTS OF GLOBAL
!                     VARIABLE TOKEN IS 'ALL'.
!  INPUT:             TOKEN CONTAINS STRING TO BE TESTED
!
!  OUTPUT:            TRUE IF TOKEN CONTAINS 'ALL'
!
!  ERRORS DETECTED:   NONE
!
!  ROUTINES CALLED:   LEFT
!
%TOUT
       LOCAL L,TSTR(0:2)
       L_MIN(LENGTH(@TOKEN),6)
       LEFT(BI("ALL","TOUTES"),L,@TSTR)
       IF EQUAL(@TSTR,@TOKEN) THEN RETURN 1
       LEFT(BI("ALL","TOUS"),L,@TSTR)
       RETURN EQUAL(@TSTR,@TOKEN)
END TOUT
%SHORT(@A)
       LEFT(@A,LENGTH(@TOKEN),@TSTR)
       IF EQUAL(@TOKEN,@TSTR) THEN RETURN 1
       RETURN 0
END SHORT
%WARN.HIM   !WARN HIM OF STRUCTURE CHANGES

       INC CVERS
       IF CVERS=1 AND QVERS>1  THEN DO  ! ONLY ONCE!!!
DISPLAY(BI("THIS COMMAND HAS MODIFIED THE STRUCTURE OF THE BINARY FILE(S)", &
   "CET ORDRE A MODIFIE LA STRUCTURE DU/DES FICHIER(S) BINAIRE(S)"),1,0)
DISPLAY(BI("THE PREPROCESSING PHASE MUST BE CALLED.", &
   "IL EST NECESSAIRE DE REFAIRE LE PRETRAITEMENT S'IL A DJA ETE FAIT"),1,1)
       END
       RETURN
END WARN.HIM

%RESRTN

RESTROC: SCAN
       IF TYPE=EOLTYPE THEN DO 
               PROMPT(BI("NEW NUMBER OF QUESTIONS: ", &
                "NOUVEAU NOMBRE DE QUESTIONS: "))
               GO RESTROC
       END
       IF TYPE#NUMTYPE OR VALUE=0 OR VALUE>MXQUES THEN DO
               SYNERR(BI("SYNTAX","SYNTAXE"))
       END
       IF VALUE=NQUES THEN DO
               DISPLAY(BI("UNCHANGED!","INCHANGE!"),1,1)
               RETURN
       END
       

       \BRS 113
       INC QVERS !ANCIENNES VERSIONS DE FICH. BIN. NON-COMPATIBLES
       WARN.HIM

       IF VALUE<NQUES THEN DO    !   
!      MOINS DE QUESTIONS QU'AVANT

               QSIZE_QCBS(VALUE*4+1) !BECOMES QPNTR OF NEXT HIGHER QUEST.
               I_0; QINIT(VALUE+1,NQUES,@I!QINIT EXPECTS AN INITIAL &
                               VALUE IN I FOR THE DELETED QUESTION!)

               DISPLAY("QUESTION(S): ",1,0); OUTNO(VALUE+1)
               IF NQUES#VALUE+1 THEN DO
                               DISPLAY(BI( " TO "," A "),0,0); OUTNO(NQUES)
               END
               DISPLAY(BI(" DESTROYED"," DETRUITE(S)"),0,1)
RES1:  NQUES_VALUE
       DMOD_TMOD_QMOD_1
       \BRS 114
       RETURN
       END

!    NEW NUMBER > OLD NUMBER
       QINIT(NQUES+1,VALUE,@QSIZE)

       !QSIZE WILL BE CORRECTLY MODIFIED BY QINIT!
       DISPLAY(BI("DEFINE QUESTION(S): ","DEFINIR QUESTION(S): "),1,0)
       OUTNO(NQUES+1)
       IF VALUE#NQUES+1 THEN DO
               DISPLAY(BI(" TO "," A "),0,0); OUTNO(VALUE)
       END
       DISPLAY(BI(" BEFORE USING THEM. "," AVANT DE L(ES) UTILISER"),0,1)
       GO RES1
END RESRTN


RESTRUC: RESRTN; GO CMND

FORMAT: FMTRTN; GO CMND

CARTES: CRTRTN; GO CMND



QUIT:  DICRIT

       \BRS 43; \STB (RL2); \BRS 121(BYT(RL2,6,12))
       \BRS 113; EXIT ! NO ESCAPE DURING FORK RETURN

SURVEY ** FICHE/FRAME BREAK *****
/CPAVMAJ1:SIMP/ SYMSORT

SYM.  PG.LN. IDENT.

!      12 34 !!!     !      12 17 !!!     !      11  9 !!!     !      11  8 !!!     
!       9 30 !!!     !       9 29 !!!     !       8 38 !!!     !       4 33 !!!     
!       4 32 !!!     !       4 31 !!!     !       4 14 !!!     !       4 13 !!!     
!       4 12 !!!     !       1  2 !!!     !!!     8 19 !!!     !!!     7 24 !!!     
!!!     7  8 !!!     !!!     6 31 !!!     !!!     5 36 !!!     !!!     5 11 !!!     
!!!     4  1 !!!     !!!     3 31 !!!     !!!     2  9 !!!     !!!     2  7 !!!     
!!!     1 38 !!!     !!!     1 32 !!!     !!!     1 24 !!!     !!!     1 20 !!!     
!!!     1 14 !!!     !!!     1 10 !!!     !!!     1  4 !!!     !*****  4 11 !!!     
!****M  4 23 !!!     !DEF    2 15 !!!     !LM!   11  6 !!!     !LM!   10 16 !!!     
!LM!    9 27 !!!     !LM!    8 36 !!!     !M!    11 12 !!!     !M!    11 11 !!!     
!M!    11 10 !!!     !M!    11  7 !!!     !M!    10 21 !!!     !M!    10 20 !!!     
!M!    10 19 !!!     !M!    10 18 !!!     !M!    10 17 !!!     !M!     9 34 !!!     
!M!     9 33 !!!     !M!     9 32 !!!     !M!     9 31 !!!     !M!     9 28 !!!     
!M!     9  3 !!!     !M!     9  2 !!!     !M!     9  1 !!!     !M!     8 39 !!!     
!M!     8 37 !!!     !M%TOU 11 13 !!!     %BINIT 10 38 !!!     %FMTRT  3  6 !!!     
------  9 15 !!!     CARTES 13 13 !!!     CARTOS  6 19 !!!     
CD11:   7 26 !!!     CRD0:   6 33 !!!     CRD1:   7 10 !!!     CRD2:   7 31 !!!     
CRD3:   8  5 !!!     CRDD:   8 21 !!!     DEF     2 36 !!!     DEF     2 35 !!!     
DEF     2 34 !!!     DEF     2 31 !!!     DEF     2 27 !!!     DEF     2 23 !!!     
DEF     2 16 !!!     DEF     2 14 !!!     DEF     2 13 !!!     DEF     2 12 !!!     
DEF     2 11 !!!     DEF     2  5 !!!     DEF     2  4 !!!     DEF     2  3 !!!     
DEF     2  2 !!!     DEF     2  1 !!!     END    13  6 !!!     END    11 34 !!!     
END    11 23 !!!     END    11 19 !!!     END    11  3 !!!     END    10 36 !!!     
END    10 15 !!!     END     9 26 !!!     END     9 12 !!!     END     8 35 !!!     
END     6 13 !!!     ENDM    2 33 !!!     ENDM    2 30 !!!     ENDM    2 26 !!!     
ENDM    2 22 !!!     FIND    3  2 !!!     FIND    1 36 !!!     FIND    1 35 !!!     
FIND    1 34 !!!     FIND    1 30 !!!     FIND    1 29 !!!     FIND    1 28 !!!     
FIND    1 27 !!!     FIND    1 26 !!!     FIND    1 22 !!!     FIND    1 18 !!!     
FIND    1 17 !!!     FIND    1 12 !!!     FIND    1  9 !!!     FIND    1  8 !!!     
FIND    1  7 !!!     FIND    1  6 !!!     FMT1:   3 33 !!!     FMT2:   3 36 !!!     
FMTC:   4 25 !!!     FMTP:   4  3 !!!     FMTQ:   5 38 !!!     FMTT:   5 13 !!!     
FORMAT 13 11 !!!     FORMOT  3 15 !!!     GLOBAL  3  4 !!!     GLOBAL  3  3 !!!     
GLOBAL  3  1 !!!     GLOBAL  1 16 !!!     L1:    10 39 !!!     LOCAL   4 16 !!!     
LOCAL   2 38 !!!     MCRTRT  6 15 !!!     MM%INI  9  4 !!!     MSHORT 11 20 !!!     
MWARN. 11 24 !!!     O*****  6  3 !!!     O*****  6  2 !!!     QIN1:  10 23 !!!     
QUIT:  13 17 !!!     RES1:  12 28 !!!     RESTRU 13  9 !!!     ]M%DIC  9 35 !!!     
_-----  6 11 !!!     _ISPLA 11 30 !!!     _ISPLA 11 28 !!!     _MM%QI 10 22 !!!     
_READ(  2 32 !!!     _RESRT 11 36 !!!     _SYNER  9 17 !!!     
SURVEY ** FICHE/FRAME BREAK *****
/CPAVMAJ:SIMP/
! MAJ VERSION C
! JP BARASZ
! 12 JAN 1972
!
! VERSION CONVERTED TO BILINGUAL 5/74 BY B.THORNQUIST
!
DEF BI(ENGLISH,FRENCH) AS ENGLISH


       TABLE &
VERSION[BI("UPD 75086","MAJ 75086")]
!  2.10 CORRECTS LABEL EATING BUG (TOO LONG WRITE ON MODIFY)
! VERS 74137 DISPLAYS TITLES ALONG WITH DEFINTIONS
! VERS 75137 ALLOWS MODULO 100 CARD FORMAT

!!! SUPERGLOBALS

FIND QUIT:,RESTRUC:,FORMAT:,CARTES:
FIND TEL,DIC,RL1,RL2,NMPAGE,QCBPAGE

!!! DICTIONARY CONTROL BLOCK

FIND DICVERS,NQUES,CDPLST,CDPLND,LLBPLST,LLBPLND,QCBADR
FIND NAMADR,QSIZE,QVERS,FMT,NMCRD,QNOPOS,QNOLEN,CDNOPOS,CDNOLEN

!!! SHARABLE PAGES

FIND QNAME(),QCBS(),LIB()

!!! EXTERNAL FUNCTIONS

FIND %BCLOS,%BERX,%BOUT,%OUTNO
FIND %ADDSTR,%STRNG
FIND %ARM,%LENGTH,%LEFT,%DISPLAY,%EQUAL
FIND %SWAPIN  !GLOBAL FUNCTION!
FIND %TRNSTR,%GETLIST,%NXTITEM

!!! LOCAL VARIABLES

       LOCAL BQFL
LOCAL I,J,K,L,M,N,ERR,MINIM,LMAX,QF.FLG
GLOBAL TSTR(0:72)
LOCAL VSIZE,PTR
GLOBAL QCUR !CURRENT QUESTION NUMBER!
GLOBAL CVERS ! VERSION CHANGED FLAG
LOCAL NCODES 
LOCAL CDCUR !CURRENT CODE
LOCAL AUTO !AUMATIC LABEL SWITCH
GLOBAL TMOD !NAME PAGE MODIFIED FLAG #0 MEANS MODIFIED!
GLOBAL QMOD !QCB  PAGE MODIFIED FLAG #0 MEANS MODIFIED!
GLOBAL DMOD !DIC  INFO MODIFIED FLAG #0 MEANS MODIFIED
GLOBAL OTIME,TIME ! TIME COUNTER

!!! SCANNER AND OTHER GLOBAL  VARIABLES AND FUNCTIONS

FIND TYPE,VALUE,TOKEN(0:1),%READ,%SCAN
FIND BUFF(0:1),NEWBUF(0:1)
FIND LIST(1)  !LIST PROCESSOR BUFFER

!!! SCANNER TYPES

DEF ALPHTYPE AS 1
DEF NUMTYPE AS 2
DEF EOLTYPE  AS 5
DEF QSTYPE AS 6
DEF FLTYPE AS 7

!!! GLOBAL FUNCTIONS

GLOBAL %GEN.AUTO,%PR.CODE

!!! LOCAL FUNCTIONS
FIND %INITIAL,%SYNERR,%DICRIT,%QINIT,%BINIT,%TOUT,%SHORT,%FMTRTN,%CRTRTN
FIND %RESRTN  ! RESTRUCTURE ROUTINE
FIND %WARN.HIM

!!! LABELS

GLOBAL CMND:
GLOBAL BADDIC:
GLOBAL PROG:,ESCAPE:


!!! MACROS

!**********
DEF SSIZE AS 140 !******* THIS MUST CORRESPOND TO S IN /CPAVIMPG:SRCE/

!**********
DEF ENDLIST AS OCT 20000000
DEF NFILTS AS 48
DEF MXQUES AS 512-48
DEF RING AS BOUT(OCT 147)
DEF ALPHA(X) AS BYT(QQCBS(X,0),1,22)
!DEF OUTNO(X) AS \BRS 36 (X,10,1)
DEF LIST.IS.ALL BY
               LIST(0)_1 !LIST POINTER
               LIST(1)_OCT 40000001; LIST(2)_NQUES; LIST(3)_1
               LIST(4)_ENDLIST
               SCAN
               IF TYPE#EOLTYPE THEN SYNERR(BI("SYNTAX","SYNTAXE"))
ENDM LIST.IS.ALL
DEF PROMPT(X) BY
       DISPLAY(X,0,0)
       READ(@TEL)
ENDM PROMPT
!
! D R E A D
!
DEF DREAD(WHAT,NUM,WHERE) BY
       \SCP (DIC,WHERE,GO BADDIC)
       \BIO (DIC,NUM,,WHAT,GO BADDIC)
ENDM DREAD
DEF DWRITE(WHAT,NUM,WHERE) BY
DREAD(WHAT,NUM,WHERE+OCT 40000000)
ENDM DWRITE
DEF QQCBS(X,Y) AS QCBS((X-1)*4+Y)
DEF QQNAME(X,Y) AS QNAME((X-1)*4+Y)
DEF LLIB(X,Y) AS LIB((X-1)*9+Y)

!!! COMMAND TABLE

DEF NORDRS AS 11
TABLE ORDR(0:NORDRS-1)[BI("TITLE","LIBELLER"),BI("DEFINE","DEFINIR"),&
"QUIT",BI("HELP","SOS"),BI("LOOK","VOIR"),BI("COPY","COPIER"),BI("MODIFY","MODIFIER"), &
BI("MULTIPLE","VECTORIELLES"),BI("RESTRUCTURE","RESTRUCTURER"), &
"FORMAT",BI("CARDS","CARTES")]
TABLE MODTAB(0:2)[BI("ADD","AJOUTER"),BI("DESTROY","DETRUIRE"), &
  BI("CHANGE","CHANGER")]
!------------------------------------------------ INITIALIZATION

PROG: NULL ! DISPLAY(VERSION,1,1)
       INITIAL

!
!------------------------------------------------ COMMAND ROUTINE

CMND:  BQFL_0
       \BRS 42; \STA (TIME); IF TIME>OTIME+3600 THEN DICRIT
       BOUT(CARRET); BI(BOUT($U),BOUT($M));BOUT($>)
       READ(@TEL)
       SCAN
       IF TYPE=EOLTYPE THEN GO CMND
       IF TYPE#ALPHTYPE THEN DO
CMND1: SYNERR(BI("INVALID COMMAND","ORDRE INCORRECT"))
       END

DSPTCH: I_0
DSP0:  IF SHORT(ORDR(I)) THEN GO DSP1
       IF INC I<NORDRS THEN GO DSP0
       GO CMND1

DSP1:  DO I+1 OF NORDRS
!
!
!      DEFINE QUESTION OR FILTER TITLES
!
       1:    GO TITRE
       2:    GO DEFINIR
       3:    GO QUIT
       4:    GO SOS
       5:    GO VOIR
       6:    GO COPIER
       7:    GO MODIFIER
       8:    GO VECTOR
       9:   GO RESTRUC
       10:     GO FORMAT
       11:     GO CARTES
       END

TITRE:   SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT(BI("QUESTIONS OR FILTERS?: " ,"QUESTIONS OU FILTRES?: "))
               GO TITRE
       END

       IF TYPE=ALPHTYPE THEN DO
               IF SHORT("QUESTIONS") THEN [QF.FLG_0;LMAX_NQUES; GO TITA]
               IF SHORT(BI("FILTERS","FILTRES")) THEN[QF.FLG_MXQUES;LMAX_NFILTS; GO TITA]
               SYNERR(BI("SYNTAX","SYNTAXE"))
       END
       IF TYPE=QSTYPE THEN DO
               TYPE_NUMTYPE; QF.FLG_0; LMAX_NQUES
               GO TITB
       END
       IF TYPE =FLTYPE THEN DO
               TYPE_NUMTYPE; QF.FLG_MXQUES; LMAX_NFILTS
               GO TITB
       END

TITA:  SCAN
       IF TYPE = EOLTYPE THEN DO
               PROMPT(BI("NUMBERS: ","NUMEROS: "))
               GO TITA
       END
       IF CH(@TOKEN)=$, THEN GO TITA
       IF TYPE=ALPHTYPE THEN DO
               IF NOT TOUT THEN SYNERR(BI("SYNTAX","SYNTAXE"))
               LIST.IS.ALL
               LIST(2)_LMAX !ADJUST TO MAXFILT IF NECESSARY!
               GO TIT1
       END
       
       IF TYPE#NUMTYPE THEN SYNERR(BI("SYNTAX","SYNTAXE"))

TITB:  GETLIST(@ERR,1,LMAX)
       IF ERR=1 THEN SYNERR(BI("SYNTAX","SYNTAXE"))
       IF ERR=2 THEN SYNERR(BI("INVALID LIST","LISTE INCORRECTE"))


TIT1:  QCUR_NXTITEM+QF.FLG

TIT2:  IF QCUR-QFFLG=ENDLIST THEN GO CMND ! (END OF LIST)
TIT3:  IF QF.FLG THEN BOUT($F) ELSE BOUT($Q)
       OUTNO(QCUR-QFFLG); BOUT($:); BOUT($ )
       READ(@TEL)
       TMOD_1
       IF LENGTH(@BUFF)>11 THEN GO TITL ELSE DO
TITS:          TRNSTR(@BUFF,@QQNAME(QCUR,0))
TIT5:          GO TIT1
       END

TITL:  \BRS 113
       IF QQNAME(QCUR,0)=-1 THEN DO
               DWRITE(@BUFF,72,QQNAME(QCUR,1))
       END ELSE DO
               DWRITE(@BUFF,72,LLBPLND)
               QQNAME(QCUR,1)_LLBPLND
               LLBPLND_LLBPLND+72*3
               DMOD_1
               QQNAME(QCUR,0)_-1
               TMOD_1
       END
       \BRS 114
       GO TIT1

QUESTION:  SCAN
       IF CH(@TOKEN)=$, THEN GO QUESTION
       IF TYPE=EOLTYPE THEN DO
               PROMPT(BI("WHICH ONES?:","LESQUELLES?:"))
               GO QUESTION
       END
       IF TOUT THEN DO
               LIST.IS.ALL
       END ELSE DO
               IF TYPE=QSTYPE THEN TYPE_NUMTYPE !QUES REF OK
               GETLIST(@ERR,1,NQUES)
               IF ERR=2 THEN SYNERR(BI("INVALID LIST","LISTE INCORRECTE"))
               IF ERR=1 THEN SYNERR(BI("SYNTAX","SYNTAXE"))
       END
       QF.FLG_0
       BOUT(CARRET)

QUS1:  QCUR_NXTITEM+QF.FLG

QUS2:  IF QCUR-QF.FLG=ENDLIST THEN GO CMND
QUS3:  NULL
       IF BQFL = 0 THEN DISPLAY(@QQNAME(QCUR,0),0,1)
! IF COMMAND IS LIST FILTERS ALL DONT LIST UNDEFINED FILTERS
       IF QF.FLG AND (@QQNAME(QCUR,0)=BI("FILTE","FILTR")) THEN GO QUS1
       IF QF.FLG THEN BOUT($F) ELSE BOUT($Q)
       OUTNO(QCUR-QF.FLG); BOUT($:); BOUT($ )
       IF QQNAME(QCUR,0)=-1 THEN GO QUSL
       DISPLAY(@QQNAME(QCUR,0),0,1)
       GO QUS1

QUSL:  NULL
       DREAD(@TSTR,72,QQNAME(QCUR,1))
       DISPLAY(@TSTR,0,1)
       GO QUS1

!
!
!      DEFINE OR REDEFINE QUESTION CHARACTERISTICS
!
DEFINIR:  SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT("QUESTION: ")
               GO DEFINIR
       END
       IF TYPE#NUMTYPE AND TYPE#QSTYPE THEN SYNERR(BI("SYNTAX","SYNTAXE"))
        IF VALUE=0 OR VALUE>NQUES THEN SYNERR(BI("INVALID QESTION","QUES. INCORRECTE"))
       QCUR_VALUE
       AUTO_0

DEFT:  SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT("TYPE: ")
               GO DEFT
       END
       IF CH(@TOKEN)=$, THEN GO DEFT
       IF TYPE # ALPHTYPE THEN SYNERR("TYPE INCORRECT")
       IF SHORT(BI("CONTINUOUS","CONTINU")) THEN GO DFFC
       IF SHORT(BI("DISCRETE","DISCRET")) THEN GO DEFD
       SYNERR("TYPE INCORRECT")

DFFC:  IF ALPHA(QCUR) THEN SYNERR("TYPE INCOMPATIBLE WITH CHARACTER FORMAT")

DEFC:  SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT("MIN: ")
               GO DEFC
       END
       IF CH(@TOKEN)=$, THEN GO DEFC
       IF TYPE = NUMTYPE THEN DO
               MINIM_VALUE
               GO DEF1
       END
       SYNERR(BI("SYNTAX","SYNTAXE"))

DEF1:  SCAN
       IF TYPE=EOLTYPE THEN DO
DEF0:          NULL
               PROMPT(BI("MAXIMUM PER BREAK: ","MAXIMA DES TRANCHES: "))
               GO DEF1
       END
       IF TYPE = NUMTYPE THEN DO
               GETLIST(@ERR,0,OCT 37777777)
               IF ERR OR CH(@TOKEN)#EOLIT THEN SYNERR(BI("INVALID LIST", &
                "LISTE INCORRECTE"))
               LIB(0)_MINIM
               K_1; I_MINIM-1
DEF2:          J_NXTITEM
               IF J=ENDLIST THEN [DEC K;GO DEF3]
               IF J<=I THEN DO
                       DISPLAY(BI("SEQUENCE ERROR","ERREUR DE SEQUENCE"),0,1)
                       GO DEF0
               END
               I_LIB(K)_J
               IF INC K<=199 THEN GO DEF2
               SYNERR(BI("TOO MANY BREAKS","TROP DE TRANCHES"))

DEF3:          \BRS 113
               DWRITE(LIB,K+1,CDPLND)
               BYT(QQCBS(QCUR,0),1,23)_1
               QQCBS(QCUR,3)_CDPLND
               QQCBS(QCUR,2)_K
               CDPLND_CDPLND+(K+1)*3
               DMOD_QMOD_1
               \BRS 114

               GO CMND
       END
       IF CH(@TOKEN)=$, THEN GO DEF1
       SYNERR(BI("SYNTAX","SYNTAXE"))

DEFD:  SCAN
       IF CH(@TOKEN)=$, THEN GO DEFD
       IF TYPE=EOLTYPE THEN DO
DFD0:          NULL
               PROMPT(BI("LIST OF CODES: ","LISTE DE CODES: "))
               GO DEFD
       END
       IF TYPE=ALPHTYPE THEN DO
               IF SHORT(BI("AUTOMATIC","AUTOMATIQUE")) THEN DO
                               AUTO_1
                               GO DEFD
               END
               GO DFDS
       END
       IF TYPE=NUMTYPE THEN DO
               GETLIST(@ERR,0,OCT 37777777)
               IF ERR OR CH(@TOKEN)#EOLIT THEN DO
                               SYNERR(BI("INVALID LIST","LISTE INCORRECTE"))
               END
               NCODES_0; J_-1  !COMPAROR FOR SEQ. CHECK
               GO DFD1
       END
DFDS:  SYNERR(BI("SYNTAX","SYNTAXE"))

DFD1:  CDCUR_NXTITEM

       IF CDCUR=ENDLIST THEN GO DFDE
       IF CDCUR<= J THEN DO
               DISPLAY(BI("SEQUENCE ERROR","ERREUR DE SEQUENCE"),1,0)
               GO DFD0
       END
       J_CDCUR
       IF INC NCODES>SSIZE THEN SYNERR(BI("TOO MANY CODES","TROP DE CODES"))
DFD2:  IF AUTO THEN GO DFD4
       PR.CODE; BOUT($:); BOUT($ )
       READ(@TEL)
       IF LENGTH(@BUFF)>11 THEN DO
               DISPLAY(BI("TOO LONG","TROP LONG"),0,1); GO DFD2
       END
DFD3:  TRNSTR(@BUFF,@LLIB(NCODES,1))

       LLIB(NCODES,0)_CDCUR
       IF AUTO THEN GO DFD1
!********   MOD FOR SECOND LINE OF ANNOTATION

DFD2B: DISPLAY("LINE 2: ",0,0)
       READ(@TEL)
       IF LENGTH(@BUFF)>11 THEN DO
               DISPLAY("TOO LONG",0,1); GO DFD2B
       END

       TRNSTR(@BUFF,@LLIB(NCODES,5))
!**********


       GO DFD1
DFD4:  GEN.AUTO
       GO DFD3


DFDE:  \BRS 113
       BYT(QQCBS(QCUR,0),1,23)_0   !DISCRETE
       QQCBS(QCUR,2)_NCODES
       QQCBS(QCUR,3)_CDPLND
       DWRITE(LIB,NCODES*9,CDPLND)
       CDPLND_CDPLND+(NCODES*9*3)
       DMOD_QMOD_1
       \BRS 114
       GO CMND

!
!
!      DISPLAY QUESTION DEFINITIONS, QUESTION OF FILTER TITLES
!      FORMAT OR STRUCTURE DEPENDING ON SUB-COMMANDS
!
!
!  DISPLAY QUESTION DEFINITIONS, QUESTION OR FILTER TITLES,FORMAT
!  OR STRUCTURE DEPENDING ON SUB COMMANDS
VOIR:  SCAN
       IF TYPE=EOLTYPE THEN DO
          PROMPT(BI("DEFINITIONS,QUESTIONS, FILTERS, FORMAT OR STRUCTURE? ", &
            "DEFINITIONS, QUESTIONS, FILTRES, FORMAT, OU STRUCTURE? "))
          GO VOIR
       END
       IF TYPE#ALPHTYPE THEN SYNERR(BI("SYNTAX","SYNTAXE"))
       K_0
       TABLE DQFS(0:4)["DEFINITIONS","QUESTIONS",BI("FILTERS","FILTRES"),"FORMAT","STRUCTURE"]

VRA:   IF SHORT(DQFS(K)) THEN GO VRB
       IF INC K<5 THEN GO VRA
       SYNERR(BI("SYNTAX","SYNTAXE"))

VRB:   DO K+1 OF 4
       1:  GO VRZ    !VOIR DEFINITIONS
       2:  QF.FLG_0; BQFL_1;  GO QUESTION  !VOIR TITRES QUESTIONS
       3:   BQFL_1+0; GO VVRC   !VOIR TITRES FILTRES
       4:  GO VF1     !VOIR FORMAT
       5:  GO VSTR    ! VOIR STRUCTURE
       END

VSTR:  SCAN
       IF TYPE#EOLTYPE THEN SYNERR(BI("SYNTAX","SYNTAXE"))
       DISPLAY("DICVERS: ",1,0)
       [8,8,8]*[I,J,K]_DICVERS
       BOUT(I);BOUT(J);BOUT(K)
       DISPLAY("NQUES: ",1,0); OUTNO(NQUES)
       DISPLAY("QSIZE: ",1,0); OUTNO(QSIZE)
       DISPLAY("QVERS: ",1,0); OUTNO(QVERS)
       DISPLAY("FORMAT: ",1,0)
       IF FMT=0 THEN [DISPLAY("SURVEY",0,1); GO CMND]
       DISPLAY(BI("CARD","CARTE"),0,0)
       IF NMCRD=0 THEN DO
               DISPLAY(BI(", NOT YET DEFINED",", PAS ENCORE DEFINI"),0,1)
               GO VST1
       END
       DISPLAY(BI("CARDS/Q'AIRE: ","CARTES/Q'AIRE: "),1,0); OUTNO(NMCRD)
       DISPLAY("QNO POS,LENGTH: ",1,0);OUTNO(QNOPOS);BOUT($,);OUTNO(QNOLEN)
       DISPLAY("CNO POS,LENGTH: ",1,0);OUTNO(CDNOPOS);BOUT($,);OUTNO(CDNOLEN)
VST1:  BOUT(CARRET)
       GO CMND



VVRC:  SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT(BI("WHICH ONES? ","LESQUELS? "))
               GO VVRC
       END
       IF CH(@TOKEN)=$, THEN GO VVRC
       IF TYPE=ALPHTYPE THEN DO
               IF TOUT THEN DO
                               LIST.IS.ALL
                               LIST(2)_NFILTS; GO VVRD
               END
               SYNERR(BI("SYNTAX","SYNTAXE"))
       END
       IF TYPE=NUMTYPE THEN DO
               GETLIST(@ERR,1,NFILTS)
               IF ERR=1 THEN SYNERR(BI("SYNTAX","SYNTAXE"))
               IF ERR=2 THEN SYNERR(BI("INVALID LIST","LISTE INCORRECTE"))
       END
VVRD:  QFFLG_MXQUES; GO QUS1


VRZ:   SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT("QUESTIONS: ")
               GO VRZ
       END
       IF TOUT THEN DO
               LIST.IS.ALL
               GO VR1
       END
       IF TYPE=QSTYPE THEN TYPE_NUMTYPE
       IF TYPE#NUMTYPE THEN SYNERR(BI("SYNTAX","SYNTAXE"))
       GETLIST(@ERR,1,NQUES)
       IF ERR THEN SYNERR(BI("INVALID LIST","LISTE INCORRECTE"))

VR1:   QCUR_NXTITEM
       IF QCUR=ENDLIST THEN GO CMND
       DISPLAY("QUESTION: ",1,0); OUTNO(QCUR); BOUT(CARRET)
!
! DISPLAY TITLES TO QUESTIONS ALONG WITH DEFINITIONS
!
       IF QQNAME(QCUR,0)=-1 THEN GO VRA1
       DISPLAY(BI("TITLE: ","TITRE: "),1,0); DISPLAY(@QQNAME(QCUR,0),0,1)
       GO VRB1
VRA1:  NULL
       DREAD(@TSTR,72,QQNAME(QCUR,1))
       DISPLAY(BI("TITLE: ","TITRE: "),1,0); DISPLAY(@TSTR,0,1)
VRB1:  NULL

       OUTNO(BYT(QQCBS(QCUR,0),5,0)); DISPLAY(BI(" ANSWER(S) "," REPONSE(S)"),0,0)

       NCODES_QQCBS(QCUR,2)   ! IF 0 UNDEFINED IF NEG. COPIED
       IF NCODES=0 THEN DO
               DISPLAY(BI("UNDEFINED","NON-DEFINIE"),1,1)
               GO VR1
       END
       IF NCODES<0 THEN DO
               DISPLAY(BI("COPIED FROM QUESTION ", &
                   "COPIEE SUR QUESTION "),1,0); OUTNO(-NCODES)
               BOUT(CARRET)
               GO VR1
       END
       DISPLAY("TYPE ",1,0)
       IF QQCBS(QCUR,0)<0 THEN GO VRC  !CONTINUOUS

       DISPLAY(BI("DISCRETE","DISCRET"),0,1)
       OUTNO(NCODES); DISPLAY(" CODES",0,1)
       DREAD(LIB,NCODES*9,QQCBS(QCUR,3))

       I_1
VRD1:  CDCUR_LLIB(I,0); PR.CODE;   BOUT($:); BOUT($ )
       DISPLAY(@LLIB(I,1),0,1)
!****** MOD FOR FOR SECOND LINE OF ANNOTATION

       DISPLAY("LINE 2: ",0,0)
       CH(@LLIB(I,5),11) _ EOLIT  ! FOR UPWARD COMPATIBILITY
       DISPLAY(@LLIB(I,5),0,1)
!*******
       IF INC I<=NCODES THEN GO VRD1
       GO VR1

VRC:   DISPLAY(BI("CONTINUOUS","CONTINU"),0,1)
       OUTNO(NCODES); DISPLAY(BI(" BREAKS"," TRANCHES"),0,1)
       DREAD(LIB,NCODES+1,QQCBS(QCUR,3))
       OUTNO(LIB(0))  !  MIN IS FIRST ELEMENT

       CDCUR_1
VRC1:  BOUT($-)
       OUTNO(LIB(CDCUR)); BOUT(CARRET)
       IF INC CDCUR>NCODES THEN GO VR1
       OUTNO(LIB(CDCUR-1)+1)
       GO VRC1

VF1:   SCAN
       IF CH(@TOKEN)=$, THEN GO VF1
       IF TYPE=EOLTYPE THEN DO
               PROMPT("QUESTIONS: ")
               GO VF1
       END
       IF TYPE=ALPHTYPE AND TOUT THEN DO
               LIST.IS.ALL
               GO VF2
       END
       IF TYPE#NUMTYPE THEN SYNERR(BI("SYNTAX","SYNTAXE"))
       GETLIST(@ERR,1,NQUES)
       IF ERR=1 THEN SYNERR(BI("SYNTAX","SYNTAXE"))
       IF ERR=2 THEN SYNERR(BI("INVALID LIST","LISTE INCORRECTE"))
       
VF2:   DISPLAY("NO: MUL",1,0)
       IF FMT THEN DISPLAY(BI(",POS,COL PER ANS,C/N", &
         ",POS,COL PAR REP,C/N"),0,0)
       DISPLAY("-------",1,0)
       IF FMT THEN DISPLAY("--------------------",0,0)
       BOUT(CARRET)
       
VF3:   QCUR_NXTITEM
       IF QCUR=ENDLIST THEN GO CMND

       OUTNO(QCUR); BOUT($:); BOUT($ )
       OUTNO(BYT(QQCBS(QCUR,0),5,0))  !VECSIZE
       IF FMT THEN DO
               BOUT($,)
!***************
               I_BYT(QQCBS(QCUR,0),11,7)
               IF I=0 THEN [DISPLAY(BI("UNDEFINED","NON-DEFINI"),0,0); GO VF4]
!*****
!     MODIFIED FOR MODULO 100 CARD FORMAT 3/27/75 B.THORNQUIST

       LOCAL BQUO,BREM

       [BQUO;BREM] _ I DIVMOD 80
       I_((BQUO+1)*100) + BREM  ! CONVERT TO MODULO 100 NOTATION

!****
               OUTNO(I)
               BOUT($,)
               OUTNO(BYT(QQCBS(QCUR,0),3,18))
               BOUT($,)
               IF ALPHA(QCUR) THEN BOUT($C) ELSE BOUT($N)
       END
VF4:   BOUT(CARRET)
       GO VF3

!
!
!      COPY A QUESTION DEFINITION TO ANOTHER QUESTION
!
!
!  COPY A QUESTION DEFINITION TO ANOTHER QUESTION
!
COPIER:        SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT("QUESTION: ")
               GO COPIER
       END
       IF TYPE#NUMTYPE AND TYPE#QSTYPE THEN SYNERR(BI("SYNTAX","SYNTAXE"))
       IF VALUE=0 OR VALUE>NQUES THEN SYNERR(BI("INVALID QUESTION", &
         "QUES. INCORRECTE"))
       QCUR_VALUE

COP1:  SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT(BI("FROM: ","MODELE: "))
               GO COP1
       END
       IF EQUAL(@TOKEN,BI("FROM","SUR")) THEN GO COP1
       IF CH(@TOKEN)=$, THEN GO COP1


       IF TYPE#QSTYPE AND TYPE#NUMTYPE THEN SYNERR(BI("SYNTAX","SYNTAXE"))
       IF VALUE=0 OR VALUE>NQUES OR VALUE=QCUR THEN SYNERR("MODELE INCORRECTE")
       J_QQCBS(VALUE,2)   !SEE IF MODELE DEFINED AND NOT COPIED

       IF J<1 THEN DO
               DISPLAY("QUESTION ",1,0); OUTNO(VALUE)
               IF J=0 THEN DISPLAY(BI(" UNDEFINED"," NON-DEFINIE"),0,1) ELSE &
                           DISPLAY(BI(" IS ITSELF A COPY"," DEJA COPIEE"),0,1)
               GO CMND
       END
       QQCBS(QCUR,2)_-VALUE
       QMOD_1
       GO CMND


!
!
!      MODIFY QUESTION CHARACTERISTICS
!
!
!  
!  MODIFY QUESTION CHARACTERISTICS
!
MODIFIER: SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT("QUESTION: ")
               GO MODIFIER
       END
       IF TYPE#QSTYPE AND TYPE#NUMTYPE THEN SYNERR(BI("SYNTAX","SYNTAXE"))
       IF VALUE=0 OR VALUE>NQUES THEN SYNERR(BI("INVALID QUESTION", &
         "QUES INCORRECTE"))
       QCUR_VALUE; AUTO_0
       IF QQCBS(QCUR,0)<0 THEN DO
               DISPLAY(BI("USE THE COMMAND 'DEFINE' TO MODIFY A CONTINUOUS QUESTION", &
               "UTILISER L'ORDRE DEFINIR POUR MODIFIER UNE QUESTION CONTINUE"),1,1)
               GO CMND
       END
       NCODES_QQCBS(QCUR,2)
       IF NCODES=0 THEN SYNERR(BI("QUESTION UNDEFINED","QUESTION NON-DEFINIE"))
       IF NCODES<0 THEN SYNERR(BI("A COPY CANNOT BE MODIFIED", &
        "QUESTION COPIEE NON-MODIFIABLE"))
   
MOD1:  SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT(BI("ADD, DESTROY, OR CHANGE? ","AJOUTER,DETRUIRE, OU CHANGER "))
               GO MOD1
       END
       IF CH(@TOKEN)=$, THEN GO MOD1
       IF TYPE#ALPHTYPE THEN SYNERR(BI("SYNTAX","SYNTAXE"))
       K_0
       J_LENGTH(@TOKEN)

MOD2:  NULL
       IF SHORT(MODTAB(K)) THEN GO MOD3
       IF INC K<3 THEN GO MOD2
       SYNERR(BI("SYNTAX","SYNTAXE"))

MOD3:  SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT(BI("LIST OF CODES: ","LISTE DES CODES: "))
               GO MOD3
       END
       IF CH(@TOKEN)=$, THEN GO MOD3
       IF SHORT("AUTOMATIQUE") THEN [AUTO_1; GO MOD3] 
       IF TYPE#NUMTYPE THEN SYNERR(BI("SYNTAX","SYNTAXE"))
       GETLIST(@ERR,0,OCT 37777777)
       IF ERR THEN SYNERR(BI("INVALID LIST","LISTE INCORRECTE"))
       DREAD(LIB,NCODES*9,QQCBS(QCUR,3))

       DO K+1 OF 3
       1:  GO MAJO
       2:  GO MDET
       3:  GO MCHN
       END

MAJO:  CDCUR_NXTITEM
       IF CDCUR=ENDLIST THEN GO MJE

       I_1

MJ0:   IF CDCUR=LLIB(I,0) THEN DO
               PR.CODE; DISPLAY(BI(" (ALREADY EXISTS): " &
                ," (EXISTE DEJA): "),AUTO,0)
               GO MJ3
       END
       IF CDCUR>LLIB(I,0) THEN GO MJ5

!    MAKE ROOM FOR THE CURRENT ENTRY

       K_NCODES

MR0:   J_0
MR1:   LLIB(K+1,J)_LLIB(K,J)
       IF INC J<9 THEN GO MR1
       IF DEC K>= I THEN GO MR0
MR1A:  IF INC NCODES>SSIZE THEN SYNERR(BI("TOO MANY CODES","TROP DE CODES"))
MR2:   IF NOT AUTO THEN[PR.CODE; BOUT($:); BOUT($ )]

MJ3:   LLIB(I,0)_CDCUR
       IF AUTO THEN GO MJ4
       READ(@TEL)
       IF LENGTH(@BUFF)>11 THEN DO
               DISPLAY(BI("TOO LONG!","TROP LONG!"),0,1)
               GO MR2
       END
MJ3A:  TRNSTR(@BUFF,@LLIB(I,1))

!******  MOD FOR SECOND LINE OF ANNOTATION
       IF AUTO THEN [QMOD_1; GO MAJO]

MJ4B:  DISPLAY("LINE 2: ",0,0)
       READ(@TEL)
       IF LENGTH(@BUFF)>11 THEN DO
               DISPLAY("TOO LONG",0,1)
               GO MJ4B
       END

       TRNSTR(@BUFF,@LLIB(I,5))
!*******
       QMOD_1
       GO MAJO

MJ4:   GEN.AUTO
       GO MJ3A

MJ5:   IF INC I<= NCODES THEN GO MJ0
       GO MR1A

MJE:   J_QQCBS(QCUR,2)<==NCODES
       \BRS 113
       IF NCODES<=J THEN DO
       DWRITE(LIB,NCODES*9,QQCBS(QCUR,3))
       END ELSE DO
       QQCBS(QCUR,3)_CDPLND
       DWRITE(LIB,NCODES*9,CDPLND)
       CDPLND_CDPLND+(3*NCODES*9)
       DMOD_1
       END
       \BRS 114
       GO CMND

MDET:  CDCUR_NXTITEM
       IF CDCUR=ENDLIST THEN GO MDE
       I_1

MD0:   L_LLIB(I,0)
       IF CDCUR=L THEN GO MD2
       IF CDCUR<L THEN DO
MD1:           PR.CODE; DISPLAY(BI(" DOES NOT EXIST"," N'EXISTE PAS"),0,1)
               GO MDET
       END
       IF INC I<= NCODES THEN GO MD0
       GO MD1

MD2:   J_0
MD2A:  LLIB(I,J)_LLIB(I+1,J)
       IF INC J<9 THEN GO MD2A
       IF INC I<NCODES THEN GO MD2
       IF DEC NCODES THEN GO MDET  ! IF NOT ZERO
       QQCBS(QCUR,2)_0  !MARK AS UNDEFINIED
       QMOD_1
       DISPLAY(BI("NO CODES LEFT! QUESTION NOW UNDEFINED", &
        "PLUS DE CODES! QUESTION NON-DEFINIE"),1,1)
       GO CMND

MDE:   \BRS 113
       J_QQCBS(QCUR,2)<==NCODES
       IF NCODES=J THEN [\BRS 114; GO CMND] !JUST IN CASE NO CHANGES
       QMOD_1
       DWRITE(LIB,NCODES*9,QQCBS(QCUR,3))
       \BRS 114
       GO CMND

MCHN:  IF NOT AUTO THEN DISPLAY(BI("TYPE THE NEW HEADINGS", &
         "FRAPPER LES NOUVEAU LIBELLES"),1,1)
MCH:   CDCUR_NXTITEM
       IF CDCUR=ENDLIST THEN GO MCE
       I_1

MC0:   L_LLIB(I,0)
       IF CDCUR=L THEN GO MC2
       IF CDCUR<L THEN DO
MC1:           PR.CODE; DISPLAY(BI(" DOES NOT EXIST"," N'EXISTE PAS"),0,1)
               GO MCH
       END

       IF INC I<= NCODES THEN GO MC0
       GO MC1

MC2:   IF AUTO THEN GO MC4
       PR.CODE; BOUT($:); BOUT($ )
       READ(@TEL)
       IF LENGTH(@BUFF)>11 THEN DO
               DISPLAY(BI("TOO LONG","TROP LONG!"),0,1)
               GO MC2
       END
MC3:   TRNSTR(@BUFF,@LLIB(I,1))
!*** MOD FOR SECOND LINE OF ANNOTATION
       IF AUTO THEN GO MCH

MC2B:  DISPLAY("LINE 2: ",0,0)
       READ(@TEL)
       IF LENGTH(@BUFF)>11 THEN DO
               DISPLAY("TOO LONG",0,1)
               GO MC2B
       END

       TRNSTR(@BUFF,@LLIB(I,5))
!*****
       GO MCH

MC4:   GEN.AUTO
       GO MC3

MCE:   \BRS 113
       DWRITE(LIB,NCODES*9,QQCBS(QCUR,3))
       \BRS 114
       GO CMND

!
!
!      DEFINE MULTIPLE ANS QUESTIONS
!
!
!
!  MULTIPLE COMMAND
!
VECTOR: NULL
        SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT(BI("NUMBER OF RESPONSES: ","TAILLE DU VECTOR: "))
               GO VECTOR

       END
       IF TYPE=NUMTYPE THEN DO
               IF VALUE=0 OR VALUE>32 THEN DO
                    SYNERR(BI("MUST BE BETWEEN 1 AND 32!", &
                      "TAILLE ENTRE 1 ET 32 "))
               END
               VSIZE_VALUE
               GO VEC1
       END
       SYNERR(BI("NUMERIC RESPONSE REQUIRED","TAILLE DOIT ETRE NUMERIQUE"))

VEC1:  SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT("QUESTIONS: ")
               GO VEC1
       END
       IF CH(@TOKEN)=$, THEN GO VEC1
       IF TYPE #NUMTYPE THEN SYNERR(BI("INVALID LIST","LISTE INCORRECTE"))
       GETLIST(@ERR,1,NQUES)
       IF ERR THEN SYNERR(BI("INVALID LIST","LISTE INCORRECTE"))
       \BRS 113

VEC2:  QCUR_NXTITEM
       IF QCUR=ENDLIST THEN GO VECE
       BYT(QQCBS(QCUR,0),5,0)_VSIZE
       GO VEC2

VECE:  NULL ! RECOMPUTE RECORD POINTER
       INC QVERS   !OLD BINARY FILES NO LONGER VALID
       WARN.HIM
       QCUR_1; PTR_3; VSIZE_0
VEC3:  QQCBS(QCUR,1)_PTR
       VSIZE_BYT(QQCBS(QCUR,0),5,0)
       PTR_PTR+VSIZE
       IF INC QCUR<= NQUES THEN GO VEC3
       QSIZE_PTR
       DMOD_QMOD_1
       \BRS 114

       GO CMND





!
!
!      HELP
!
!
!
!    H E L P  C O M M A N D
!
SOS:   DISPLAY(BI("VALID COMMANDS ARE:","LES ORDRES VALABLES SONT"),1,1)
       I_0
SOS0:  DISPLAY(ORDR(I),1,0)
       IF INC I<NORDRS THEN GO SOS0
       BOUT(CARRET); GO CMND


BADDIC:  BCLOS
         DISPLAY(BI("ERROR, SYSTEM DICTIONARY", &
          "ERREUR SYSTEME DICTIONAIRE"),1,1)
       BERX
         \BRS 113; EXIT !NO ESCAPES

ESCAPE: ARM(ESCAPE)
       BUFF(0)_NEWBUF(0)_-1
       \BRS 11 (,,-1)
       \BRS 29
       BOUT(CARRET)
       GO CMND


!------------------------------------------------ INIT ROUTINE
%GEN.AUTO
       IF ALPHA(QCUR) THEN DO
          TRNSTR("CODE '",@BUFF)
          BUFF(2)_[8,8,8]*[CDCUR,$',EOLIT]
       END ELSE DO
          STRNG(CDCUR,@TSTR)
          ADDSTR("CODE ",@TSTR,@BUFF)
       END
       RETURN
END GEN.AUTO
%PR.CODE
       OUTNO(CDCUR)
       IF ALPHA(QCUR) THEN [BOUT($(); BOUT(CDCUR); BOUT($))]
       RETURN
END PR.CODE
SURVEY ** FICHE/FRAME BREAK *****
/CPAVMAJ:SIMP/ SYMSORT

SYM.  PG.LN. IDENT.

!      18 26 !       !      16 39 !       !      11 13 !       !      11 11 !       
!       7 14 !       !       1 12 !       !       1 11 !       !       1 10 !       
!       1  3 !       !       1  2 !       !!!     3 37 !       !!!     3  4 !       
!!!     2 36 !       !!!     2 31 !       !!!     2 27 !       !!!     2 19 !       
!!!     2 13 !       !!!     1 36 !       !!!     1 28 !       !!!     1 24 !       
!!!     1 19 !       !!!     1 14 !       !***   21 18 !       !***** 21 29 !       
!***** 19  7 !       !***** 15 24 !       !***** 14 12 !       !****M 15 31 !       
!DEF    3 13 !       !LM!M! 23 14 !       !LM!M! 21 39 !       !LM!M! 16 37 !       
!LM!M! 16  1 !       !LM!M! 11 10 !       !LM!M!  7 27 !       !LM!M!  4 29 !       
!M     13 20 !       !M      4 30 !       !M!    13 19 !       !M!     3 25 !       
!M!     1  4 !       !M!LM! 23 15 !       !M!LM! 22  1 !       !M!LM! 16 38 !       
!M!LM! 16  2 !       !M!LM! 11 12 !       !MDEF   3 26 !       !MDEF   1  5 !       
!MSOS: 23 16 !       +***** 10 25 !       ------ 23 37 !       ------  4  6 !       
-LM!--  4 11 !       ;MCOPI 16  3 !       ;MVECT 22  2 !       
BADDIC 23 23 !       CMND1:  4 20 !       CMND:   4 13 !       COP1:  16 13 !       
DEF     3 39 !       DEF     3 35 !       DEF     3 34 !       DEF     3 33 !       
DEF     3 30 !       DEF     3 21 !       DEF     3 14 !       DEF     3 12 !       
DEF     3 11 !       DEF     3 10 !       DEF     3  9 !       DEF     2 25 !       
DEF     2 24 !       DEF     2 23 !       DEF     2 22 !       DEF     2 21 !       
DEF0:   8 26 !       DEF1:   8 24 !       DEF2:   8 36 !       DEF3:   9  7 !       
DEFC:   8 12 !       DEFD:   9 21 !       DEFT:   7 38 !       DFD0:   9 24 !       
DFD1:  10  6 !       DFD2:  10 15 !       DFD2B: 10 27 !       DFD3:  10 21 !       
DFD4:  10 35 !       DFDE:  10 39 !       DFDS:  10  4 !       DFFC:   8 10 !       
DSP0:   4 24 !       DSP1:   4 28 !       DSPTCH  4 23 !       END    24 11 !       
END    24  7 !       ENDM    3 32 !       ENDM    3 29 !       ENDM    3 24 !       
ENDM    3 20 !       ESCAPE 23 29 !       FIND    2 34 !       FIND    2 33 !       
FIND    2 32 !       FIND    2 17 !       FIND    2 16 !       FIND    2 15 !       
FIND    1 34 !       FIND    1 33 !       FIND    1 32 !       FIND    1 31 !       
FIND    1 30 !       FIND    1 26 !       FIND    1 22 !       FIND    1 21 !       
FIND    1 17 !       FIND    1 16 !       GLOBAL  3  1 !       GLOBAL  2 39 !       
GLOBAL  2 38 !       GLOBAL  2 29 !       GLOBAL  2 11 !       GLOBAL  2 10 !       
GLOBAL  2  9 !       GLOBAL  2  8 !       GLOBAL  2  4 !       GLOBAL  2  3 !       
GLOBAL  2  1 !       LOCAL   2  7 !       LOCAL   2  6 !       LOCAL   2  5 !       
LOCAL   2  2 !       LOCAL   1 39 !       M***** 19 18 !       M***** 14 17 !       
MAJO:  18 14 !       MC0:   20 39 !       MC1:   21  3 !       MC2:   21 10 !       
MC2B:  21 21 !       MC3:   21 17 !       MC4:   21 31 !       MCE:   21 34 !       
MCH:   20 35 !       MCHN:  20 33 !       MD0:   20  5 !       MD1:   20  8 !       
MD2:   20 14 !       MD2A:  20 15 !       MDE:   20 25 !       MDET:  20  1 !       
MJ0:   18 19 !       MJ3:   18 37 !       MJ3A:  19  5 !       MJ4:   19 21 !       
MJ4B:  19 10 !       MJ5:   19 24 !       MJE:   19 27 !       MOD1:  17 20 !       
MOD2:  17 30 !       MOD3:  17 35 !       MPR.CO 24  8 !       MR0:   18 30 !       
MR1:   18 31 !       MR1A:  18 34 !       MR2:   18 35 !       O***** 15 22 !       
O***** 10 34 !       O*****  3  8 !       O*****  3  6 !       OGEN.A 23 38 !       
PROG:   4  8 !       QUS1:   7  9 !       QUS2:   7 11 !       QUS3:   7 12 !       
QUSL:   7 22 !       SOS0:  23 18 !       TABLE   4  1 !       TIT1:   6  5 !       
TIT2:   6  7 !       TIT3:   6  8 !       TIT5:   6 14 !       TITA:   5 24 !       
TITB:   5 39 !       TITL:   6 17 !       TITRE:  5  4 !       TITS:   6 13 !       
VEC1:  22 19 !       VEC2:  22 30 !       VEC3:  22 39 !       VECE:  22 35 !       
VF1:   14 32 !       VF2:   15  8 !       VF3:   15 15 !       VF4:   15 37 !       
VOIR:  11 14 !       VR1:   13 16 !       VRA1:  13 23 !       VRA:   11 24 !       
VRB1:  13 26 !       VRB:   11 28 !       VRC1:  14 26 !       VRC:   14 20 !       
VRD1:  14 10 !       VRZ:   13  2 !       VST1:  12 15 !       VSTR:  11 36 !       
VVRC:  12 20 !       VVRD:  12 38 !       [MDEFI  7 28 !       [UESTI  6 31 !       
_ERSIO  1  9 !       _FORMA  4  4 !       _I("MU  4  3 !       _MMODI 17  1 !       
_QUIT"  4  2 !       _READ(  3 31 !       
SURVEY ** FICHE/FRAME BREAK *****
/CPAVPRE1:SRCE/
PRE1 IDENT
*...
*... ROUTINE MODIFIED FOR BILINGUAL VERSION 5/73 BY B. THORNQUIST
*...
*... PARAMETER LANG=0 YIELDS ENGLISH, #0 YIELDS FRENCH
LANG EQU 0
       ;*
       ;*
       ;*
*......CREATION D UN FICHIER BINAIRE DE DONNEES A PARTIR D UN
*......FICHIER SYMBOLIQUE CREE PAR L UTILISATEUR.
       ;*
       ;*
*.....ROUTINE DE SORTIE DE MESSAGES
       ;*
       ;*
MES MACRO D
       LDA =D(1); LDB =-1; LDX =1; BRS 34
       ENDM
       ;*
       ;*
       ;*
*.....LECTURE DU FICHIER SYMBOLIQUE
*.....INITIALISATION DES POINTEURS DE CHAINE
       ;*
$PREMAIN ZRO 0; LDA =ESC; STA 201B; LDA =2B6; BRS 78; BRS 114
       CLA; STA NCHAR
      STA NCR; STA NREC; STA NCOTES; LDA BLOCPT
 STA INPNT; STA INPNT+1
       ;*
       ;*
       ;*
 BRM RECZRO INITIALISATION DE RECORD
 BRM GETCAR; NOP; SKE ENN; BRU NONN; BRU NTROUV;NONN STA ERRCAR
 BRM LIGN; BRM CHAR; MES MSG1
       CLA
       SKE CFLNO
       BRS 10    ABORT IF COMMAND FILE
       BRM SKIPN


 BRU EOF1;NTROUV CLA; STA ACCUM; BRM GETCAR; BRU EOF1;
       ;*
*..TESTS DES NUMEROS APRES N ET Q.
       ;*
TSTNUM STA ERRCAR; SUB =20B;  SKG =9; SKG =-1; BRU SKIPN1; BRU CONT;
SKIPN1 BRM LIGN; BRM CHAR1; MES MSG2
       CLA
       SKE CFLNO
       BRS 10     ABORT IF COMMAND FILE
       BRM SKIPN

 BRU EOF1
 BRU NTROUV
CONT STA NUM
 LDA ACCUM
 MUL =10
 LSH 23
 ADD NUM

 STA ACCUM
 BRM GETCAR
 CLA
 BRM TSTSEP
 BRU TSTNUM
 LDA ACCUM
 STA NYY

 STA RECORD;NEXTN BRM GETCAR; BRU EOF2; SKE ENN; BRU SEPAR; BRM ECRIT;
 BRU NTROUV;SEPAR BRM TSTSEP; BRU *+2; BRU NEXTN;
       ;*
*..RECHERCHE DU CARACTERE Q
       ;*
       SKE ENQ; BRU SKIPQ; BRU QTROUV
SKIPQ STA ERRCAR; BRM LIGN; BRM NQAIR
       BRM CHAR; MES MSG2
       CLA
       SKE CFLNO
       BRS 10    ABORT IF COMMAND FILE

SKIPQ5 BRM SKIPQN; BRU EOF2;
 BRU NORM1
 BRU QTROUV
NORM1 BRM ECRIT
 BRU NTROUV
QTROUV CLA
 STA ACCUM

 BRM GETCAR
 CLA
TSTNB STA ERRCAR
 SUB =20B
 SKG =9
 SKG =-1
 BRU *+2
 BRU NUMB

 BRM LIGN; BRM NQAIR; BRM CHAR1; MES MSG3
       CLA
       SKE CFLNO
       BRS 10    ABORT IF COMMAND FILE
       BRU SKIPQ5

NUMB STA NUM
 LDA ACCUM
 MUL =10
 LSH 23
 ADD NUM
 STA ACCUM
 BRM GETCAR

 CLA; BRM TSTSEP; BRU TSTNB;
       ;*
       ;*
 LDA ACCUM; SKG =0; BRU *+2; BRU NQUEST; SKE =0; BRU *+2; BRU COMPT;
MESSG BRM LIGN
 BRM NQAIR
 TCO COLON
 LDA ACCUM
 BRM OUTNB
 MES MSG4

 CLA
 SKE CFLNO
 BRS 10    ABORT IF COMMAND FILE
 BRU SKIPQ5
NQUEST SKG NQUES; BRU COMPT; BRU MESSG;
COMPT STA QYY; SUB =1; STA QY1; CLA; STA CTR; STA ACCUM;
       ;*
GETREP BRM GETCAR; BRU EOF2; BRM TSTSEP; BRU *+2; BRU GETREP; SKE ENQ;
 BRU *+2; BRU QTROUV; SKE ENN; BRU *+3; BRM ECRIT; BRU NTROUV;
TSTNB1 STA ERRCAR; SUB =20B; SKG =9; SKG =-1; BRU *+2; BRU NUMB1;
*
*  KLUDGE IN ALLOWING ALPHA ANSWERS
*
       ADD 20B
       BRU TALP

 BRM LIGN; BRM NQAIR; BRM QUES; BRM CHAR; MES MSG9
       CLA
       SKE CFLNO
       BRS 10    ABORT IF COMMAND FILE
       BRU SKIPQ5

NUMB1 STA NUM
 LDA ACCUM
 MUL =10
 LSH 23
 ADD NUM
TALP STA ACCUM
 BRM GETCAR

 CLA; BRM TSTSEP; BRU TSTNB1; MIN CTR;  LDA CTR; LDX QY1;
       ;*
*..TEST POUR VOIR SI NBRE TROUVE  N EST PAS PLUS GRAND QUE LE 
*..NBRE DE REPONSES A LA QUESTION.
       ;*
 SKG NREP,2; BRU REP; BRM LIGN; BRM NQAIR; BRM QUES;
 MES MSG5
 CLA
 SKE CFLNO
 BRS 10    ABORT IF COMMAND FILE
 BRU SKIPQ5

       ;*
REP LDA AREP,2; ADD CTR; SUB =1; CAX; LDA ACCUM; STA RECORD,2; CLA;
 STA ACCUM; BRU GETREP;
       ;*
       ;*
*.....ROUTINE DE LECTURE DU FICHIER ENTREE SYMBOLIQUE
       ;*
       ;*
GETCAR ZRO 0;LETCAR GCI INPNT; BRU LECTUR; MIN NCHAR; SKE CR; BRU *+2
 MIN NCR; MIN GETCAR; BRR GETCAR
LECTUR LDX =BLOC; LDA =512; BIO SFLNO; BRU *+2; BRU *+3; SKG =BLOC;
 BRR GETCAR; MUL =3; LSH 23; SUB =1; STA INPNT+1;
       ;*
*..CREATION DES POINTEURS DE CHAINE A L AIDE DE L ADRESSE DU DERNIER
*..MOT (RETOURNE PAR LE BIO)
       ;*
 LDA BLOCPT; STA INPNT; BRU LETCAR;
       ;*
       ;*
*.....ROUTINE POUR TROUVE N
       ;*
SKIPN ZRO 0; BRM GETCAR; BRR SKIPN; SKE ENN; BRU *-3; MIN SKIPN;
 BRR SKIPN;
       ;*
       ;*
*.....ROUTINE POUR VOIR SI LE CARACTERE EST UN N OU UN Q
       ;*
SKIPQN ZRO 0;CARQ BRM GETCAR; BRR SKIPQN; SKE ENN; BRU *+2; BRU *+4;
 SKE ENQ; BRU CARQ; MIN SKIPQN; MIN SKIPQN; BRR SKIPQN;
       ;*
*.....ROUTINE D ECRITURE
       ;*
ECRIT ZRO 0; LDA QSIZE; LDX =RECORD; BIO BFLNO; BRM SYSERR;
 MIN NREC
 LDA NREC
 SKA =15
 BRU *+2
 BRM ACOTE
 BRM RECZRO
 BRR ECRIT
       ;*
       ;*
*.....ROUTINE D INITIALISATION DE L ENREGISTREMENT RECORD POUR LE
*.....FICHIER SORTIE
       ;*
RECZRO ZRO 0; LDA QSIZE; ADD =1; CNA; CAX; LDA RECPTI; STA RECPT;
 LDA CONTNU (CONTENU DES MOTS NON UTILISES DANS FICHIER SORTIE)
INIREC STA* RECPT; MIN RECPT; BRX INIREC; LDA =-1; STA RECORD+1
       STA RECORD+2;  BRR RECZRO
       ;*
*....ROUTINES POUR SORTIR LES MESSAGES D ERREURS
       ;*
LIGN ZRO 0; MES NLIGN; LDA NCR; ADD =1; BRM OUTNB; BRR LIGN
NQAIR ZRO 0; TCO VIRG; TCO ENN; LDA NYY; BRM OUTNB; BRR NQAIR
QUES ZRO 0; TCO VIRG; TCO ENQ; LDA QYY; BRM OUTNB; BRR QUES
CHAR ZRO 0; TCO COLON; LDA ERRCAR; SUB =20B; SKG =9; SKG =-1; BRU *+2
 BRU *+3; TCO ERRCAR; BRR CHAR; BRM OUTNB; BRR CHAR
CHAR1 ZRO 0; TCO COLON; TCO ERRCAR; BRR CHAR1
       ;*
*.....ROUTINE EOF1
       ;*
EOF1  CLA
      SKE CFLNO
      BRU EOFZ   SUPPRESS PRINTING IF COMMAND FILE
     MES MSGREC; LDA NREC; BRM OUTNB; MES MSGCAR; LDA NCHAR; BRM OUTNB
EOFZ   CLA; XMA SFLNO; BRS 20; RSP BFLNO; PCE BFLNO; BRM SYSERR
     LDA =6; SCP BFLNO; BRM SYSERR CURSOR IN READ MODE AFTER VERSION NO.
       BRS 43; ETR =77B; BRS 121; CLA; LSH 6; BRS 121 !RELEASE MEMORY
 BRR PREMAIN
SYSERR ZRO 0; MES ERRSYS; BRU SYSERR ! CAUSES I TRAP
       ;*
*.....ROUTINE EOF2
       ;*
EOF2 BRM ECRIT; BRU EOF1
       ;*
       ;*
*...ROUTINE DE SORTIE DES COTES
       ;*
ACOTE  ZRO 0
       CLA
       SKA CFLNO  SUPPRES PRINNTING IF COMMAND FILE
    TCO COTE; MIN NCOTES; LDA NCOTES; SKG =71; BRR ACOTE;
 CLA
 SKA CFLNO
 TCO CR; CLA; STA NCOTES; BRR ACOTE
       ;*
       ;*
ESC   ZRO SESC; STA SA; STB SB; STX SX
       LDX -1; BRS 161; LDX =-1; BRS 11; BRS 29
       LDA =2B6; BRS 78
       IF LANG=0
       ;E1 MES CON; CIO =0; SKE "Y"; BRU E2
       ELSE
       ;E1  MES CON; CIO =0; SKE ="O"; BRU E2
       ENDF
       LDX -1; BRS 162;  LDA SA; LDB SB; LDX SX; BRU* SESC
       ;E2  SKE ="N"; BRU E1; LDX -1; BRS 162; BRU EOF1
       ;SESC BSS 1;SA BSS 1;SB BSS 1;SX BSS 1

       ;*
OUTNB ZRO 0; LDX =1; LDB =10; BRS 36; BRR OUTNB;
       ;*
       ;*
*.....ROUTINE POUR SAVOIR SI LE NBRE EST >=0 OU <=9
       ;*
       ;*
       ;*
*.....ROUTINE POUR SAVOIR SI CARACTERE EST UN SEPARATEUR
       ;*
TSTSEP ZRO 0; SKE =0; BRU *+2 ; BRU FIN; SKE LF;
 BRU *+2
 BRU FIN
 SKE CR
 BRU *+2
 BRU FIN
 SKE VIRG
 BRU *+2
 BRU FIN

 SKE =135B; BRR TSTSEP; BRM GETCAR; BRU EOF2;FIN MIN TSTSEP;
 BRR TSTSEP;
       ;*
*.....ET NON NUL
       ;*
       ;*
FPNT BSS 2
TEMP BSS 1
$NREP EQU 20000B
$AREP EQU 22000B
INDEX BSS 1;BLOCPT DATA 3*BLOC-1;INPNT BSS 2;ACCUM BSS 1;
$RECORD EQU 14000B
BLOC   EQU 34000B
$IREC EQU BLOC
CTR    BSS 1
QYY     BSS 1
  IF LANG=0
CON ASC '$CONTINUE? /'
MSG2 ASC '  BAD CHAR. AFTER N$/'
MSG3 ASC '  BAD CHAR. AFTER Q$/'
MSG4 ASC '  BAD QUESTION NUMBER$/'
MSG1 ASC '  1ST CHAR. MUST BE N$/'
MSG5 ASC '  TOO MANY ANSWERS$/'
MSGREC ASC '$$NUMBER OF RECORDS PROCESSED: /'
MSGCAR ASC '$NUMBER OF CHARS.: /'
NLIGN ASC '$LINE NO: /'
MSG9 ASC '  BAD ANSWER$/'
    ELSE
CON ASC '$CONTINUER? /'
MSG2 ASC '  CARACTERE ERRONE APRES N$/'
MSG3 ASC '  CARACTERE ERRONE APRES Q$/'
MSG4 ASC '  NUMERO DE QUESTION ERRONE$/'
MSG1 ASC '  1ER CARACTERE DOIT ETRE  N$/'
MSG5 ASC '  TROP DE REPONSES$/'
MSGREC ASC '$$NBRE D ENREGISTREMENTS TRAITES: /'
MSGCAR ASC '$NBRE DE CARACTERES: /'
NLIGN ASC '$LIGNE NO: /'
MSG9 ASC '  REPONSE ERRONEE$/'
     ENDF
NUM BSS 1
NREC BSS 1
NYY BSS 1
ERRCAR BSS 1;
       ;*
       ;*
*...DEFINITION DES DIFFERENTS MOTS DU DICTIONNAIRE
       ;*
       ;*
       ;*
       ;*
CONTNU DATA -4000000;RECPTI DATA RECORD;RECPT BSS 1;ENN DATA 56B
SLASH DATA 17B;ENQ DATA 61B;CR DATA 155B;LF DATA 152B;BLANC DATA 0
QY1 BSS 1;VIRG DATA 14B;
NCHAR ZRO;TEMPA ZRO;TEMPX ZRO
ERRSYS ASC '$ERREUR SYSTEME/'
COTE DATA 1;NCR BSS 1;COLON DATA 32B;NCOTES BSS 1
REPOND DATA 3*ANSW-1,3*ANSW-1;ANSW BSS 2
 END
SURVEY ** FICHE/FRAME BREAK *****
/CPAVPRE1:SRCE/ SYMSORT

SYM.  PG.LN. IDENT.

ACOTE   7  9 PRE1    AREP    8 20 PRE1    BLOC    8 23 PRE1    
CHAR    6 25 PRE1    CHAR1   6 27 PRE1    COMPT   4 11 PRE1    CON     8 39 PRE1    
CON     8 28 PRE1    CONT    2 16 PRE1    CONTNU  9 22 PRE1    COTE    9 27 PRE1    
CTR     8 25 PRE1    ECRIT   6  2 PRE1    EOF1    6 31 PRE1    EOF2    7  4 PRE1    
EOFZ    6 35 PRE1    ERRCAR  9 14 PRE1    ERRSYS  9 26 PRE1    ESC     7 18 PRE1    
FPNT    8 17 PRE1    GETCAR  5 17 PRE1    GETREP  4 13 PRE1    INDEX   8 21 PRE1    
INIREC  6 17 PRE1    IREC    8 24 PRE1    LANG    1  6 PRE1    LECTUR  5 19 PRE1    
LIGN    6 22 PRE1    MES     1 17 PRE1    MESSG   3 38 PRE1    MSG1    9  4 PRE1    
MSG1    8 32 PRE1    MSG2    9  1 PRE1    MSG2    8 29 PRE1    MSG3    9  2 PRE1    
MSG3    8 30 PRE1    MSG4    9  3 PRE1    MSG4    8 31 PRE1    MSG5    9  5 PRE1    
MSG5    8 33 PRE1    MSG9    9  9 PRE1    MSG9    8 37 PRE1    MSGCAR  9  7 PRE1    
MSGCAR  8 35 PRE1    MSGREC  9  6 PRE1    MSGREC  8 34 PRE1    NCHAR   9 25 PRE1    
NLIGN   9  8 PRE1    NLIGN   8 36 PRE1    NORM1   3  6 PRE1    NQAIR   6 23 PRE1    
NQUEST  4 10 PRE1    NREC    9 12 PRE1    NREP    8 19 PRE1    NUM     9 11 PRE1    
NUMB    3 26 PRE1    NUMB1   4 28 PRE1    NYY     9 13 PRE1    OUTNB   7 31 PRE1    
PREMAI  1 26 PRE1    QTROUV  3  8 PRE1    QUES    6 24 PRE1    QY1     9 24 PRE1    
QYY     8 26 PRE1    RECORD  8 22 PRE1    RECZRO  6 15 PRE1    REP     5 10 PRE1    
REPOND  9 28 PRE1    SKIPN   5 30 PRE1    SKIPN1  2  8 PRE1    SKIPQ   2 36 PRE1    
SKIPQ5  3  3 PRE1    SKIPQN  5 36 PRE1    SLASH   9 23 PRE1    SYSERR  6 39 PRE1    
TALP    4 33 PRE1    TEMP    8 18 PRE1    TSTNB   3 13 PRE1    TSTNB1  4 15 PRE1    
TSTNUM  2  7 PRE1    TSTSEP  8  1 PRE1    
SURVEY ** FICHE/FRAME BREAK *****
/CPAVPRE:SIMP/

!JP BARASZ
! 28 JAN 1972
DEF BI(ENGLISH,FRENCH) AS ENGLISH

!      TABLE &
 VERSION ["PRE VER 74144"]
                  ! ALLOW CARD FILES NON-MULTIPLE OF 81
               ! ERROR DISPLAY QUES. NO.

!!! SUPERGLOBALS
FIND TEL,DIC,RL1,RL2,NMPAGE,QCBPAGE
!!! DICTIONARY CONTROL BLOCK
FIND DICVERS,NQUES,CDPLST,CDPLND,LLBPLST,LLBPLND,QCBADR
FIND NAMADR,QSIZE,QVERS,FMT,NMCRD,QNOPOS,QNOLEN,CDNOPOS,CDNOLEN
!!! SHARABLE PAGES
FIND QNAME(),QCBS(),LIB()
!!! EXTERNAL FUNCTIONS
       FIND %BOUT,%OUTNO
FIND %BCLOS,%BERX
FIND %ADDSTR,%STRNG,%GTPT,%VAL,%INCHV
FIND %ARM,%LENGTH,%LEFT,%DISPLAY,%EQUAL
FIND %SWAPIN  !GLOBAL FUNCTION!
FIND %RETESC
FIND %TRNSTR,%GETLIST,%NXTITEM
!!! LOCAL VARIABLES
       LOCAL BLAST,BFIRST,ENTRD,FIRST
LOCAL CARSIZE
!!! SCANNER AND OTHER GLOBAL  VARIABLES AND FUNCTIONS
FIND TYPE,VALUE,TOKEN(0:1),%READ,%SCAN
FIND BUFF(0:1),NEWBUF(0:1)
FIND LIST(1)  !LIST PROCESSOR BUFFER
!!! SCANNER TYPES
!!! LOCAL FUNCTIONS
!!! LABELS
!!! MACROS
!!! COMMAND TABLE
!!! PRE1 GLOBALS

FIND SFLNO,BFLNO,SNAME(0:1)
FIND AREP(0:1) !ADRESS OF QUESTION
FIND NREP(0:1) !VEC SIZE
DEF OPENI(P1,P2,BAD,FILE) BY
       \BRS 64 (P1,P2,GO BAD); \STA (FILE)
ENDM OPENI
DEF OPENO(P1,P2,BAD,FILE,TYPE) BY
       \BRS 65 (P1,P2,TYPE,GO BAD); \STA (FILE)
ENDM OPENO
DEF CLOSE(X) AS \BRS 20 (X)

DEF BIN AS 2
DEF SYM AS 3
DEF ENTREE AS 1
DEF SORTIE AS 0
DEF QQCBS(X,Y) AS QCBS(4*(X-1)+Y)
!DEF OUTNO(X) AS \BRS 36(X,10,1)

LOCAL PT1,PT2,TSTR(0:24),QCUR,OK,TST1(0:24),I,J,K,L
LOCAL EOF:
LOCAL TEMPA,TEMPB,TEMPC,TEMPD,BKON,CKON,DKON
!!! GLOBAL LABELS

GLOBAL PROG:,BADBIN:,PG2:

!!! LOCAL ROUTINES

GLOBAL %CRDMAIN,%YES,%ERP

!!! EXT LABELS

FIND %PREMAIN


PROG: NULL ! DISPLAY(VERSION,1,1)
       SWAPIN(QCBPAGE,6); QCBS_OCT 30000
       \BRS 113
       QCUR_1

PG1:   AREP(QCUR-1)_QQCBS(QCUR,1)
       NREP(QCUR-1)_BYT(QQCBS(QCUR,0),16,0)
       IF INC QCUR<= NQUES THEN GO PG1

       IF FMT=1 AND NMCRD=0 THEN DO
               BCLOS
                 DISPLAY(BI("DEFINE THE FORMAT OF THE QUESTIONNAIRE WITH UPDATE BEFORE PREPROCESSING", &
                  "DEFINIR LE FORMAT DU Q'AIRE AVEC 'MAJ' AVANT DE FAIRE LE PRETRAITEMENT"),1,1)
               BERX
               GO XIT
       END
!***   IF SFLNO THEN GO ALOPN
       

!  ASK FOR INPUT FILE
!
PG2:   \BRS 114
       DISPLAY(BI("INPUT FILE: ","FICHIER ENTREE: "),1,0)
       READ(@TEL); TRNSTR(BUFF,SNAME)
       IF EQUAL(@SNAME,"Q") OR EQUAL(@SNAME,"QUIT") THEN GO XIT
       GTPT(@SNAME,@PT1,@PT2)
       OPENI(PT1,PT2,PG2,SFLNO)
       \RSP (SFLNO); \STA (CARSIZE)
       IF CARSIZE=0 THEN DO
               BCLOS
               DISPLAY(BI("FILE EMPTY","FICHIER VIDE"),1,1)
               BERX
               CLOSE(SFLNO); SFLNO_0; GO PG2
       END
       
!
!  OPEN BINARY OUTPUT FILE
!
ALOPN: IF BFLNO THEN GO ALP1
       ADDSTR(@SNAME,"'BIN'",@TSTR)
       GTPT(@TSTR,@PT1,@PT2)
       OPENO(PT1+OCT 11600000,PT2,BADBIN,BFLNO,BIN)
ALP1:  \WIO(BFLNO,DICVERS)
       \WIO(BFLNO,QVERS)
       IF FMT THEN DO
               CRDMAIN(CARSIZE,@OK)
               IF NOT OK THEN [CLOSE(SFLNO); SFLNO_0; GO PG2]
       END ELSE [SWAPIN(0,6) ;PREMAIN]
XIT:   \BRS 113; \BRS 43; \STP (RL1); \BRS 121(BYT(RL1,6,0))
       IF RL2 THEN DO
               [6,6,6,6]*[I,J,,L]_RL2
               \BRS 121(I);\BRS 121(J);\BRS 121(L)
       END
       EXIT


BADBIN:        BCLOS
               DISPLAY(BI("CANNOT OPEN: ","IMPOSSIBLE D'OUVRIR: "),1,0)
       DISPLAY(@TSTR,0,1)
               BERX
       CLOSE(SFLNO)
       SFLNO_0
       EXIT

!
!-----------------------------------------CARD PRE ROUTINE!
%CRDMAIN(FSIZE,@OK)


FIND IREC(0:1)
LOCAL I,J,K,L,ACUR,NREC,INCNT,RECNT,ERFLG,CSIZE,CDCNT,QCNT
LOCAL CVEC,CQPTR,CLPOS,NMCOL,FMTYP,SEQER,ESCAPE:
TABLE BLANK(0:6)[" ","  ","   ","    ","     ","      ","       "]
LOCAL PTPR(0:1)

FIND RECORD(0:1)   !OUTPUT RECORD
!
!
!
!      ARM INTERRUPT FOR EOF CONDITION
!
       BKON_OCT 204
       \BRS 49   ! READ UP INTERRUPT MASK
       \STA(DKON) ! SAVE IT
       CKON_OCT 200000  ! 2B5 UNUSUAL I/O CONDITION
       TEMPD_^BKON   ! SAVE INTERRUPT ADDRESS
       ^BKON_@EOF
       \LDA(CKON)
       \BRS 78      ! ARM EOF INTERRUPT



!      \BRS 113
!      [I;J]_ FSIZE DIVMOD 81*NMCRD
!      IF J#0 OR I<1 THEN DO
!              DISPLAY(BI("FILE SIZE NON-MULTIPLE OF 81*NUMBER OF CARDS PER Q'AIRE", &
                 "FICHIER NON-MULTIPLE DE 81*NOMBRE DE CARTES PAR Q'AIRE"),0,1)
!              OK_0
!              \BRS 114
!             RETURN
!      END ELSE NREC_I*NMCRD
       QCNT_INCNT_0
       RECNT_0
       ERFLG_1
       CSIZE_80*NMCRD
!**    ARM(ESCAPE)
       \BRS 114

! CLEAR OUTPUT RECORD

CLREC: MOVE 2045 FROM ALL -4000000 TO @RECORD(3)
       RECORD(0)_0; RECORD(1)_RECORD(2)_-1
       FIRST_1; ENTRD_0
       I_1; CDCNT_0; PTPR(0)_PTPR(1)_@IREC(1)*3-1; J_0; SEQER_0

!
       CSIZE_0
!
! INPUT RECORD

GTREC: TEMPC_SFLNO
       \BRS 113; \BRS 33(PTPR,OCT 155,TEMPC)

       \STB(TEMPB)   ! POINTER TO LAST CHAR
       \STA(TEMPA)   ! POINTER 1ST-1 CHAR
       \LDA(TEMPB)   ! COMPUTE NUMBER
       \SUB(TEMPA)   ! OF CHARS READ
       \STA(TEMPB)   
       CSIZE_CSIZE+TEMPB
       \BRS 114
!
!
       INC INCNT     !CARD COUNTER!
       IF NMCRD=1 THEN GO GTQ1

!!! GET CARD NUM

       PT1_CHPT(@IREC(1),CDNOPOS-2+J)
       PT2_CHPT(@TSTR,-1)
       J_J+80    !INC INPUT REC POINTER!
       K_1
GTCDNO: L_INCHV(@PT1); NCHV(PT2)_L
       IF INC K<=CDNOLEN THEN GO GTCDNO
       NCHV(PT2)_EOLIT; L_VAL(CHPT(@TSTR))
!*******

       IF L<CDCNT THEN DO
               BCLOS
               DISPLAY(BI("SEQUENCE ERROR","ERREUR SEQUENCE"),1,1)
               DISPLAY(BI("RECORDED AT :","ENREG. :"),0,0);OUTNO(INCNT)
               BERX
               SEQER_1
       END

       CDCNT_L
       IF INC I<=NMCRD THEN GO GTREC
 IF SEQER THEN GO CLREC

! GET Q'AIRE NUMBER

GTQ1:  PT1_CHPT(@IREC(1),QNOPOS-2)
       PT2_CHPT(@TSTR,-1)
       I_1

GTQNO: IF QNOLEN>0 THEN DO ! IF 0 JUST USE NEXT RECORD NUMBER
          J_INCHV(@PT1)
          NCHV(PT2)_J
          IF INC I<=QNOLEN THEN GO GTQNO
          NCHV(PT2)_EOLIT
          J_VAL(CHPT(@TSTR))
          IF J<0 THEN DO
               DISPLAY(BI("ERROR AT: ","ERREUR A: "),1,0); DISPLAY(@TSTR,0,0)
               DISPLAY(BI("ERRONEOUS Q'AIRE NUMBER", &
               "NUMERO DE Q'AIRE ERRONE"),1,0)
               GO NXTR
          END
       END ELSE J_RECNT+1

       RECORD(0)_J
       QCUR_1

GTQUES: ACUR_1
       CVEC_BYT(QQCBS(QCUR,0),5,0)  ! NO. ANS/QUEST !
       CQPTR_BYT(QQCBS(QCUR,1),12,0) !NUO. OF CODES OR BREAKS !
!*****************************
        CLPOS_BYT(QQCBS(QCUR,0),11,7) ! FIRST CARD COL OF QUEST !
       NMCOL_BYT(QQCBS(QCUR,0),3,18)  ! NO .OF COLS/ANS  !
       FMTYP_BYT(QQCBS(QCUR,0),1,22)  ! FMTYP - CONTINUOUS OR DISCRETE!

       IF CLPOS<1 THEN DO
               IF RECNT=0 THEN DO
                               IF ERFLG THEN &
          [BCLOS;  DISPLAY(BI("UNDEFINED QUESTION(S):","QUESTION(S) NON-DEFINIE(S):"),1,1);ERFLG_0]
                               ERP
                               BERX
               END
               GO NXTQ
       END

!GET ANS

GTANS: IF CLPOS+NMCOL-1>CSIZE THEN DO
               IF RECNT=0 THEN DO
                               BCLOS
                               DISPLAY("QUESTION: ",1,0); OUTNO(QCUR)
                               DISPLAY(BI("FORMAT OVERFLOW!", &
                                "FORMAT DEBORDEZ"),0,1)
                               BERX

                               DISPLAY(BI("CONTINUE? ","CONTINUER? "),1,0)
                               IF YES THEN GO NXTQ
                               DISPLAY(BI("PROCESSING ABORTED","TRAITEMENT ANNULE"),1,1)
                               GO EOF
               END
               GO NXTQ
       END

!GET ANS VALUE

       LOCAL IBL
       IBL_0
!*******
       PT1_CHPT(@IREC(1),CLPOS-2)
       PT2_CHPT(@TSTR,-1)
       I_1
GTQV:  J_INCHV(@PT1)
       IF J # $  THEN IBL_1 !** ENCOUNTERED NON BLANK
       IF (J=$  AND IBL=1 AND FMTYP=0) THEN GO FV !** IGNORE TRAILING BLKS

       NCHV(PT2)_J
       IF INC I<= NMCOL THEN GO GTQV

! NUMERIC TYPE
FV:    IF FMTYP=0 THEN DO
               NCHV(PT2)_EOLIT
               J_VAL(CHPT(@TSTR))
               IF J<0 THEN DO
                 IF EQUAL(@TSTR,BLANK(NMCOL-1)) THEN GO NXTA !PDR
                 BCLOS
                 DISPLAY(BI("ERROR IN: ","ERREUR A: "), &
                   1,0); DISPLAY(@TSTR,0,0)
                 DISPLAY(" QUES. ",0,0); OUTNO(QCUR); BOUT($,)
                 DISPLAY(BI("RECORD: ","ENREG. : "),0,0); OUTNO(RECNT+1); &
                  BOUT($,)
                 DISPLAY("POS. : ",0,0)
                 LOCAL BZ
                 BZ_ (1+(CLPOS/80))*100
                 BZ _ BZ+CLPOS- (CLPOS/80)*80
                 OUTNO(BZ);  BOUT(CARRET)

               BERX
                 GO NXTA
               END
       END ELSE IF J=$ THEN GO NXTA ! PDR OF ALPHA TYPE

       RECORD(CQPTR+ACUR-1)_J

!  CVEC = NO. ANS/QUESTION
NXTA:  IF INC ACUR<=CVEC THEN DO
               CLPOS_CLPOS+NMCOL
               GO GTANS
       END
NXTQ:  IF INC QCUR<=NQUES THEN GO GTQUES
       IF RECNT=0 THEN DO
             IF  ENTRD AND BFIRST#BLAST THEN [BOUT($-);OUTNO(BLAST)]
             BOUT(CARRET)
       END

NXTR:  \BIO(BFLNO,QSIZE,,RECORD,GO BADBFL)
       INC RECNT
       IF BYT(RECNT,4,0)=0 THEN DO
               BOUT($!); IF INC QCNT>71 THEN DO
                      BOUT(CARRET); QCNT_0
               END
       END
!      IF INCNT<=NREC-1 THEN GO CLREC
       GO CLREC

! END OF CARD FILE

!
EOF:   TEMPA_TEMPA ! DUMMY FOR SUBROUTINE ENTRY
       ^BKON_TEMPD   ! RESTORE INTERRUPT ADDRESS
       \BRS 113
       CLOSE(SFLNO)
       SFLNO_0
       \RSP(BFLNO); \STA(I)
       \PCE(BFLNO,I,GO BADBFL)
       \SCP(BFLNO,0,GO BADBFL)
       DISPLAY(BI("INPUT CARD IMAGES:","NOMBRE DE CARTES EN ENTREE: "),2,0)
       OUTNO(INCNT)
       DISPLAY(BI("RECORDS CREATED ","NOMBRE D'ENREGISTREMENTS CREES: "),1,0)
       OUTNO(RECNT); BOUT(CARRET)
       OK_1; \BRS 114; RETURN
BADBFL: DISPLAY(BI("I/O ERROR (BIN)","ERREUR D'E/S: FICHIER PAVOT BINAIRE"),1,1)
       \ZRO

ESCAPE: \BRS 113
        ARM(ESCAPE)
       BUFF(0)_@NEWBUF(0)_-1
       \BRS 11(,,-1)
       \BRS 29
       DISPLAY(BI("CONTINUE? ","CONTINUER? "),1,0)
       IF YES THEN [DISPLAY(BI("I'LL TRY","JE VAIS ESSAYER"),0,1);RETESC]
       DISPLAY(BI("PROCESSING ABORTED","TRAITEMENT ANNULE"),0,1); GO EOF

END CRDMAIN

!-------------------------------------------------------------YES OR NO ?

!
!  NAME:              YES
!  
!  FUNCTION:          DETERMINES WHETHER OR NOT YES OR NO HAS BEEN
!
!  INPUT:             NONE
!
!  OUTPUT:             TRUE IF YES TYPE
!                     FALSE IF NO TYPED
!                     
!  ERRORS DETECTED:   PROMPTS IF NEITH YES OR NO HAS BEEN TYPED AND
!                     CHECKS AGAIN.
!
!  ROUTINES CALLED:   TRNSTR,LEFT,DISPLAY
!
%YES
LOCAL I
Y1:    READ(@TEL); TRNSTR(BUFF,TSTR)
       I_LENGTH(@TSTR)
       LEFT(BI("YES","OUI"),I,@TST1)
       IF EQUAL(@TSTR,@TST1) THEN RETURN 1
       LEFT(BI("NO","NON"),I,@TST1)
       IF EQUAL(@TSTR,@TST1) THEN RETURN 0
       DISPLAY(BI("YES OR NO? ","OUI OU NON? "),0,0)
       GO Y1
END YES



%ERP

       ENTRD_1
EEE:  IF FIRST THEN DO
              OUTNO(QCUR); BLAST_BFIRST_QCUR; FIRST_0
       END ELSE DO
               IF QCUR=BLAST+1 THEN BLAST_QCUR ELSE DO
                     IF BFIRST#BLAST THEN [BOUT($-); OUTNO(BLAST)]
                     BOUT(CARRET)
                     FIRST_1; GO EEE
               END
       END
       RETURN
END ERP
SURVEY ** FICHE/FRAME BREAK *****
/CPAVPRE:SIMP/ SYMSORT

SYM.  PG.LN. IDENT.

!      10 20 M!JP    !      10 19 M!JP    !      10 18 M!JP    !      10 17 M!JP    
!      10 14 M!JP    !      10 13 M!JP    !       9 20 M!JP    !       9 17 M!JP    
!       8 38 M!JP    !       8 13 M!JP    !       6 19 M!JP    !       5 14 M!JP    
!       5  6 M!JP    !       5  5 M!JP    !       5  4 M!JP    !       5  3 M!JP    
!       5  1 M!JP    !       4 39 M!JP    !       4 38 M!JP    !       4 37 M!JP    
!       3 14 M!JP    !       1  5 M!JP    !       1  2 M!JP    !!!     5 37 M!JP    
!!!     2 29 M!JP    !!!     2 25 M!JP    !!!     2 21 M!JP    !!!     1 37 M!JP    
!!!     1 36 M!JP    !!!     1 35 M!JP    !!!     1 34 M!JP    !!!     1 33 M!JP    
!!!     1 32 M!JP    !!!     1 28 M!JP    !!!     1 25 M!JP    !!!     1 17 M!JP    
!!!     1 15 M!JP    !!!     1 12 M!JP    !!!     1 10 M!JP    !**     5 11 M!JP    
!***    3 11 M!JP    !DEF    2 16 M!JP    !GET    7 38 M!JP    !GET    7 20 M!JP    
!LM!   10 12 M!JP    !LMEOF  9 22 M!JP    !M      5 21 M!JP    !M      4 26 M!JP    
!M!    10 21 M!JP    !M!    10 16 M!JP    !M!    10 15 M!JP    !M!     5 22 M!JP    
!M!     3 29 M!JP    !M!M    5 34 M!JP    !M!M!M  4 25 M!JP    !MALOP  3 30 M!JP    
!MPG2:  3 15 M!JP    %ERPMM 10 35 M!JP    ALP1:   3 34 M!JP    
BADBFL  9 35 M!JP    BADBIN  4  9 M!JP    CLREC:  5 16 M!JP    DEF     2 15 M!JP    
DEF     2 14 M!JP    DEF     2 13 M!JP    DEF     2 12 M!JP    DEF     2 11 M!JP    
DEF     2  9 M!JP    DEF     2  6 M!JP    DEF     2  3 M!JP    DEF     1  3 M!JP    
EEE:   10 36 M!JP    END    11  7 M!JP    END    10 31 M!JP    END    10  8 M!JP    
ENDM    2  8 M!JP    ENDM    2  5 M!JP    ESCAPE  9 38 M!JP    FIND    4 24 M!JP    
FIND    2 31 M!JP    FIND    2  2 M!JP    FIND    2  1 M!JP    FIND    1 39 M!JP    
FIND    1 31 M!JP    FIND    1 30 M!JP    FIND    1 29 M!JP    FIND    1 24 M!JP    
FIND    1 23 M!JP    FIND    1 22 M!JP    FIND    1 21 M!JP    FIND    1 20 M!JP    
FIND    1 19 M!JP    FIND    1 16 M!JP    FIND    1 14 M!JP    FIND    1 13 M!JP    
FIND    1 11 M!JP    FV:     8 14 M!JP    GLOBAL  2 27 M!JP    GLOBAL  2 23 M!JP    
GTANS:  7 22 M!JP    GTCDNO  6  4 M!JP    GTQ1:   6 21 M!JP    GTQNO:  6 25 M!JP    
GTQUES  7  3 M!JP    GTQV:   8  6 M!JP    GTREC:  5 24 M!JP    LOCAL   4 22 M!JP    
LOCAL   4 20 M!JP    LOCAL   4 19 M!JP    LOCAL   2 20 M!JP    LOCAL   2 19 M!JP    
LOCAL   2 18 M!JP    LOCAL   1 27 M!JP    M*****  8  3 M!JP    M*****  6  7 M!JP    
NXTA:   8 39 M!JP    NXTQ:   9  4 M!JP    NXTR:   9 10 M!JP    O*****  7  6 M!JP    
OM%YES 10 22 M!JP    PG1:    2 39 M!JP    PROG:   2 34 M!JP    TABLE   4 21 M!JP    
XIT:    4  1 M!JP    Y1:    10 23 M!JP    _----- 10 10 M!JP    _CRDMA  4 18 M!JP    
_LM!--  4 17 M!JP    
SURVEY ** FICHE/FRAME BREAK *****
/CPAVSCAN:SIMP/
!
! ROUTINE MODIFIED FOR BILINGUAL VERSION 5/74 BY B.THORNQUIST
!
DEF BI(ENGLISH,FRENCH) AS ENGLISH

! EXTERNAL SYMBOLS FOR THE SCANNER

       GLOBAL TOKEN(0:24),CURPOS,TYPE,VALUE

! LOCAL SYMBOLS !

       FIND %BCLOS,%BERX
       FIND  %DISPLAY,%VAL,%EQUAL,%GETSTR
       FIND BUFF(0:1)

! GLOBAL SYMBOLS


       GLOBAL %SCAN,%READ,%MMMM

DEF NNNN(A,B) AS MMMM(@A,B)

!  NAME:              SCAN
!
!  PURPOSE:           RETURNS THE NEXT ITEM OF THE LIN IN -BUFF- IN THE
!                     GLOBAL VARIABLE -TOKEN-.
!
!  INPUT:             NONE
!
!  OUTPUT:            NONE
!
!  ERRORS DETECTED:   NONE
!
!  ROUTINES CALLED:   GETCAR
!
%SCAN  !MULTIPLE USE SCANNER


       GLOBAL %GETCAR
       GLOBAL CARTYPE,TKPT,CURCAR
       LOCAL K,TEMP,QUOTE

!DEFINITIONS!

DEF BADTYPE AS 0
DEF ANTYPE  AS 1
DEF NUMTYPE AS 2
DEF SYMTYPE AS 3
DEF RESTYPE AS 4
DEF EOLTYPE AS 5
DEF QUSTYPE AS 6
DEF FILTYPE AS 7
DEF ERRTYPE AS 8
DEF TMPTYPE AS 9

DEF MXRES AS 2
DEF MXRSW AS 2


!TYPE DEFINIONS FOR CHARACTERS!
DEF XTYPE AS 7  !BAD CHARACTERS
DEF ATYPE AS 1  !LETTERS
DEF NTYPE AS 2  !NUMERICS
DEF STYPE AS 3  !SPECIAL SYMBOLS
DEF BTYPE AS 4  !SPACE AND LNFEED
DEF QTYPE AS 5  !QUOTES
DEF ETYPE AS 6  !EOLIT
DEF CTYPE AS 8  !  EXLMATION MARK
DEF DTYPE AS 9  !  DOLLAR
DEF MXTYPE AS 9  !MAXIMUM OF ABOVE TYPES

DEF PLUS AS 1
DEF MNUS AS 2
DEF DIV  AS 3
DEF MULT AS 4
DEF EQAL AS 5
DEF NEQ  AS 6
DEF LT   AS 7
DEF GT   AS 8
DEF PROP AS 9
DEF PRCL AS 10
DEF BROP AS 11
DEF BRCL AS 12
DEF VIRG AS 13
DEF ASSG AS 14
DEF COLON AS 15

DEF MXSYM AS 14
       TABLE SCAR(0:MXSYM)[$+,$-,$/,$*,$=,$#,$<,$>,$(,$),$[,$],$,,$_,$:]
       TABLE SVAL(0:MXSYM)[PLUS,MNUS,DIV,MULT,EQAL,NEQ,LT,GT,PROP,PRCL,&
               BROP,BRCL,VIRG,ASSG,COLON]
       DEF LE.VAL AS MXSYM+2
       DEF GE.VAL AS MXSYM+3
       DEF ANDV AS MXSYM+4
       DEF ORV  AS MXSYM+5
       DEF NOTV AS MXSYM+6

       TABLE ARES(0:MXRES)["AND","OR","NOT"]
       TABLE VARES(0:MXRES)[ANDV,ORV,NOTV]

       TABLE RES(0:MXRSW)[BI("TO","A"),BI("BY","PAR")]
       TABLE VRES(0:MXRSW)[1,2]

       DEF MXPVTYP AS 3
       TABLE PAVTYP(0:MXPVTYP)[$Q,$F,$E,$T]
       TABLE PAVTVAL(0:MXPVTYP)[QUSTYPE,FILTYPE,ERRTYPE,TMPTYPE]


BGSCN:   TYPE_-1;GETCAR
       TKPT_CHPT(@TOKEN,-1)
       NNNN(TKPT,CURCAR)
       IF CARTYPE=XTYPE THEN DO
   BADCAR:  TYPE_BADTYPE
   GDCAR:   NNNN(TKPT,EOLIT)
            RETURN
       END

       DO CARTYPE OF MXTYPE
       ATYPE: XTYPE:  GO ALPHA
       NTYPE: GO NUM
       STYPE:  GO SYMB
       BTYPE:  GO BGSCN
       QTYPE:  GO QTAN
EOLRET:ETYPE:  TYPE_EOLTYPE; DEC CURPOS; RETURN
       CTYPE:  GO COMMENT
       DTYPE:  GO DOLLAR
       END


DOLLAR: GETCAR
        IF CURCAR=EOLIT THEN [DEC CURPOS; GO BADCAR]
        VALUE_CURCAR; TYPE_NUMTYPE; GO GDCAR

COMMENT: GETCAR; IF CURCAR=EOLIT THEN [CH(TOKEN)_EOLIT; GO EOLRET]
       IF CARTYPE=CTYPE THEN GO BGSCN !OTHER EXCLAMATION POINT
       GO COMMENT

ALPHA:     GETCAR
           IF CARTYPE # NTYPE AND CARTYPE # ATYPE THEN GO ALF1
           NNNN(TKPT,CURCAR); GO ALPHA

    ALF1:  DEC CURPOS
           NNNN(TKPT,EOLIT)

   !SEE IF RESERVED WORD!
       K_0
   ALF2:   IF EQUAL(RES(K),@TOKEN) THEN DO
               VALUE_VRES(K)
               TYPE_RESTYPE; RETURN
           END
           IF INC K <= MXRSW THEN GO ALF2

   !SEE IF OPERATOR WORD
       K_0
   ALF3:   IF EQUAL(ARES(K),@TOKEN) THEN DO
               VALUE_VARES(K); TYPE_SYMTYPE
               RETURN
           END
       IF INC K <= MXRES THEN GO ALF3

!!!!!!!!
!SPECIAL OPTION PAVOT...  SEARCH FOR QNNNN OR FNNNN
!!!!!!!!

       TEMP_CHV(CHPT(@TOKEN))
       K_0
PVLP:  IF TEMP=PAVTYP(K) THEN DO
           TEMP_VAL(CHPT(@TOKEN,1))
           IF TEMP>=0 THEN DO
               TYPE_PAVTVAL(K)
                VALUE_TEMP
               RETURN
           END
       END
       IF INC K<=MXPVTYP THEN GO PVLP

   ! IT IS A REGULAR AN STRING!
   
       TYPE_ANTYPE; RETURN


!NUMERIC TOKEN!


NUM:   VALUE_CHV(TKPT)-$0
    NUM0: GETCAR
       IF CARTYPE#NTYPE THEN GO NUM1
       NNNN(TKPT,CURCAR)
       VALUE_VALUE*10+CURCAR-$0
       GO NUM0

   NUM1:   DEC CURPOS
           NNNN(TKPT,EOLIT)
           TYPE_NUMTYPE; RETURN

!SPECIAL SYMBOL


SYMB:  TEMP_CURCAR
       TYPE_SYMTYPE
   !CHECK IF <= OR >=!
       GETCAR
       IF CURCAR = $= THEN DO

           IF TEMP = $< THEN DO
               VALUE_LE.VAL
               SYM0:  NNNN(TKPT,CURCAR);NNNN(TKPT,EOLIT); RETURN
           END
           IF TEMP = $> THEN DO
               VALUE_GE.VAL; GO SYM0
           END
       END
           DEC CURPOS; NNNN(TKPT,EOLIT)
           CURCAR_TEMP
   !GET SYMBOL VALUE!
   
       K_0

SYM1:  IF SCAR(K)=CURCAR THEN [VALUE_SVAL(K);RETURN]
       IF INC K <= MXSYM THEN GO SYM1
       GO SYSERR!

!ALPHANUM STRING BETWEEN QUOTES!

QTAN:  QUOTE_CURCAR
       DEC TKPT ! SO QUOTE IS NOT INCLUDED

QTA1:  GETCAR
       IF CURCAR=QUOTE THEN GO QTA2
       IF CURCAR = EOLIT THEN DO
           TYPE_BADTYPE;NNNN(TKPT,CURCAR);DEC CURPOS

           RETURN
       END
       NNNN(TKPT,CURCAR);GO QTA1
   
   QTA2:   NNNN(TKPT,EOLIT)
           TYPE_ANTYPE
           RETURN


!
!  NAME:              GETCAR
!
!  PURPOSE:           TO RETRIEVE THE NEXT CHARACTER FROM THE STRING
!                     POINTED TO BY -CURPOS-
!
!  INPUT:             -CURPOS- POINTER TO STRING
!
!  OUTPUT:            -CURCAR- CONTAINS NEXT CHARACTER IN STRING
!                     -CARTYPE- CONTAINS CHARACTER TYPE (DEFINED IN
!                     SCAN LISTING)
!
!  ERRORS DETECTED:   NONE
!
!  ROUTINES CALLED:   NONE
!
! GET CHARACTER ROUTINE

%GETCAR

       !TRANSLATE TABLE FOR ASCII
       TABLE TRANS(0:63)[BTYPE,CTYPE,QTYPE,STYPE,DTYPE,2(XTYPE),QTYPE,&
           6(STYPE),XTYPE,STYPE,  10(NTYPE),STYPE,XTYPE, &
           3(STYPE),2(XTYPE),26(ATYPE),STYPE,XTYPE,STYPE,XTYPE,STYPE]

       CURCAR_NCHV(CURPOS)

       IF CURCAR=LN.FEED THEN [CARTYPE_BTYPE; RETURN]
       IF CURCAR= EOLIT  THEN [CARTYPE_ETYPE; RETURN]
       IF CURCAR > 64 THEN CURCAR_CURCAR-32
       CARTYPE_TRANS(CURCAR)
       RETURN

END GETCAR

!
!  NAME:              SYSERR
!
!  PURPOSE:           CLOSES BINARY FILE, DISPLAYS ERROR MESSAGE,
!                     EXITS TO EXEC.
!  
!  INPUT:             NONE
!
!  OUTPUT:            NONE
!
!  ERRORS DETECTED:   NONE
!
!  ROUTINES CALLED:   NONE
!
SYSERR: BCLOS;  DISPLAY("ERROR IN SCANNER",2,2)
       \BRS 36(CURPOS,8,1)
    DISPLAY(@BUFF,1,0); DISPLAY(@TOKEN,1,1); BERX; EXIT
END SCAN
!
!  NAME:              READ
!
!  PURPOSE:           TO READ A RECORD FROM A DISC FILE
!
!  INPUT:             -FILE- CONTAINS FILE NAME
!                     -EOFR:- LABLE TO BRANCH TO IF EOF ENCOUNTERED
!
!  OUTPUT:            -BUFF- CONTAINS RECORD READ
!
!  ERRORS DETECTED:   IF RECORD READ IS GREATER THAN 300 CHARACTERS
!                     A MESSAGE IS ISSUED, AND THE NEXT RECORD IS 
!                     READ.
!
!  ROUTINES CALLED:   NONE
!
%READ(@FILE,EOFR:)

       LOCAL CPNT,CCPNT,J

DEF ACONT AS OCT 141
DEF QCONT AS OCT 161
DEF WCONT AS OCT 167
DEF BELL AS OCT 147
DEF BLANK AS $    !SPACE
DEF BACAR AS $_
DEF BACSL AS $\
DEF UPAR AS $^


       IF FILE=0 THEN DO
               GETSTR
               CURPOS_CHPT(@BUFF,-1)
               RETURN
       END
!RESET POINTERS!
   RD1: CCPNT_CPNT_CHPT(@BUFF,-1)

   GTCAR:  \CIO (FILE); \STA (J)

               IF FILE<0 THEN GO EOFR
      IF J>OCT 77 AND J#LN.FEED AND J#CARRET THEN DO
           TTY_BELL; GO GTCAR
       END
       GTF:  NNNN(CPNT,J)
           IF CPNT>CCPNT+300 THEN [DISPLAY(BI("TOO LONG", &
                      "TROP LONG"),2,2); GO RD1]
           IF J=CARRET THEN [CHV(CPNT)_EOLIT;CURPOS_CCPNT; RETURN]
       GO GTCAR

END READ

%MMMM(@I,J)
NCHV(I)_J
RETURN
END MMMM
SURVEY ** FICHE/FRAME BREAK *****
/CPAVSCAN:SIMP/ SYMSORT

SYM.  PG.LN. IDENT.

!       8  1 !M!     !       7 39 !M!     !       7 36 !M!     !       7 25 !M!     
!       7 24 !M!     !       7 23 !M!     !       7  1 !M!     !       6 39 !M!     
!       6 36 !M!     !       1 23 !M!     !       1 21 !M!     !       1 14 !M!     
!       1  8 !M!     !       1  4 !M!     !LM!    7 33 !M!     !LM!    7 21 !M!     
!LM!    6 34 !M!     !M!     8  2 !M!     !M!     7 38 !M!     !M!     7 37 !M!     
!M!     7 35 !M!     !M!     7 34 !M!     !M!     7 28 !M!     !M!     7 27 !M!     
!M!     7 26 !M!     !M!     7 22 !M!     !M!     7  4 !M!     !M!     7  3 !M!     
!M!     7  2 !M!     !M!     6 38 !M!     !M!     6 37 !M!     !M!     6 35 !M!     
!M!     1 27 !M!     !M!     1 26 !M!     !M!     1 25 !M!     !M!     1 24 !M!     
!M!     1 22 !M!     !M%SCA  1 28 !M!     !MDEF   1  2 !M!     !NUMER  5 13 !M!     
!RESET  8 20 !M!     !SPECI  5 27 !M!     !TYPE   2 11 !M!     ;MSYSE  7 29 !M!     
ALPHA:  4 11 !M!     BGSCN:  3 21 !M!     COMMEN  4  7 !M!     
DEF     8 12 !M!     DEF     8 11 !M!     DEF     8 10 !M!     DEF     8  9 !M!     
DEF     8  8 !M!     DEF     8  7 !M!     DEF     8  6 !M!     DEF     8  5 !M!     
DEF     2 39 !M!     DEF     2 37 !M!     DEF     2 36 !M!     DEF     2 35 !M!     
DEF     2 34 !M!     DEF     2 33 !M!     DEF     2 32 !M!     DEF     2 31 !M!     
DEF     2 30 !M!     DEF     2 29 !M!     DEF     2 28 !M!     DEF     2 27 !M!     
DEF     2 26 !M!     DEF     2 25 !M!     DEF     2 24 !M!     DEF     2 23 !M!     
DEF     2 21 !M!     DEF     2 20 !M!     DEF     2 19 !M!     DEF     2 18 !M!     
DEF     2 17 !M!     DEF     2 16 !M!     DEF     2 15 !M!     DEF     2 14 !M!     
DEF     2 13 !M!     DEF     2 12 !M!     DEF     2  8 !M!     DEF     2  7 !M!     
DEF     2  5 !M!     DEF     2  4 !M!     DEF     2  3 !M!     DEF     2  2 !M!     
DEF     2  1 !M!     DEF     1 39 !M!     DEF     1 38 !M!     DEF     1 37 !M!     
DEF     1 36 !M!     DEF     1 19 !M!     DOLLAR  4  3 !M!     END     8 35 !M!     
END     7 32 !M!     END     7 19 !M!     M!!!!!  4 35 !M!     MALPHA  6 15 !M!     
MGETCA  7  6 !M!     NUM:    5 16 !M!     PVLP:   4 37 !M!     QTA1:   6 20 !M!     
QTAN:   6 17 !M!     SYM1:   6 11 !M!     SYMB:   5 30 !M!     _!!!!!  4 34 !M!     
_DEFIN  1 35 !M!     _M%REA  8  3 !M!     _MMMM(  8 37 !M!     _OLRET  3 36 !M!     

SURVEY ** FICHE/FRAME BREAK *****
/CPAVSTAT:SIMP/

!!! IMPSTAT MODULE
!
! ROUTINE TO CONVERTED TO BILINGUAL 5/74 BY B.THORNQUIST
!
 
DEF BI(ENGLISH,FRENCH) AS ENGLISH

! AUG 1, 1972

TABLE &
VERSION ["STAT C01.02"]


FIND RL1,RL2
FIND CHI2FL,CHIVAL(0:1),CHIST1(0:11),CHIST2(0:11),DF,NROWS,NCOLS,PCHFLG
FIND CLHEAD(),RWHEAD(0:1),TCB(0:1),TBL(1),T,AUX(2),TPTR

FIND %WRITE,OFL
FIND %ADDSTR,%TRNSTR

GLOBAL CR1,CR2,CRFL
GLOBAL INTG(),XXTOT(0:214),YYTOT(),GDTOT
GLOBAL XMIN,YMIN,NX,NY,ADX,ADY,CUMUL(0:1),T1(0:1),T2(0:1),T3(0:1),TEMP(0:1)
GLOBAL XTR
GLOBAL NEXT
GLOBAL NXP1,NYP1
GLOBAL X,Y,S

GLOBAL %CHI2,%COLAPS,%IMIN,%SMALL,%TOTAL,%MOVTAB,%PRCHTB


DEF XINTG(I,J) AS INTG(I*NYP1+J)
DEF IS.ROW AS CRFL=1
DEF IS.COL AS CRFL=0

DEF XCH(A,B) BY
       \LDA(A); \XMA(B); \STA(A)
ENDM XCH

DEF FLOAT(S,D) BY
      \BRS 51(S); \STP(^D) !ONLY SIMPLE OPERAND PERMINTED
ENDM FLOAT

GLOBAL STPROG:

STPROG: \BRS 113
       
       IF CHI2FL=0 THEN [DF_-1; GO RETST]
       INTG_OCT 10000; INTG(0)_0 !GRAB PAGE
       MOVTAB
       YYTOT_XXTOT+NX+1

       IF CHI2FL=-1 THEN DO
               CHI2
               TRNSTR("CHI2: ",CHIST1)
DFMV:          TRNSTR(BI("DEGREES OF FREEDOM: ", &
                 "DEGRES DE LIBERTE: "),CHIST2)
               GO RETST
       END
       [1,7,8,8]*[CRFL,,CR1,CR2]_CHI2FL
       IF CR1=CR2 THEN GO ERCHI2
       IF CR1>CR2 THEN DO
              XCH(CR1,CR2)
       END
       IF (IS.ROW AND CR2>NX) OR(IS.COL AND CR2>NY) THEN GO ERCHI2

       IF IS.ROW THEN GO MROW
       X_0
MC1:   XTR_XINTG(X,CR1)
      XINTG(X,0)_XTR
       XTR_XINTG(X,CR2)
       XINTG(X,1)_XTR
       IF INC X<=NX THEN GO MC1
       NY_1; GO CALC

MROW:  Y_0
MR1:   XTR_XINTG(CR1,Y)
       XINTG(0,Y)_XTR
       XTR_XINTG(CR2,Y)
       XINTG(1,Y)_XTR
       IF INC Y<= NY THEN GO MR1
       NX_1; GO CALC

CALC:  CHI2
       IF IS.ROW THEN DO
               ADDSTR(BI("CHI2 ROWS ","CHI2 LIGNES "),@RWHEAD(8*CR1),CHIST1)
             ADDSTR(CHIST1,' ',CHIST1); ADDSTR(CHIST1,@RWHEAD(8*CR1+4),CHIST1)

               ADDSTR(CHIST1,BI(" AND "," ET "),CHIST1)
               ADDSTR(CHIST1,@RWHEAD(8*CR2),CHIST1)
             ADDSTR(CHIST1,' ',CHIST1); ADDSTR(CHIST1,@RWHEAD(8*CR2+4),CHIST1)
               GO DFMV
       END ELSE DO
               ADDSTR(BI("CHI2 COLUMNS ","CHI2 COLONNES "),@CLHEAD(8*CR1),CHIST1)
            ADDSTR(CHIST1,' ',CHIST1); ADDSTR(CHIST1,@CLHEAD(8*CR1+4),CHIST1)
               ADDSTR(CHIST1,BI(" AND "," ET "),CHIST1)
               ADDSTR(CHIST1,@CLHEAD(8*CR2),CHIST1)
            ADDSTR(CHIST1,' ',CHIST1); ADDSTR(CHIST1,@CLHEAD(8*CR2+4),CHIST1)
               GO DFMV
       END

RETST: \BRS 43; \STP(RL1); [12,6,6]*[,X,Y]_RL1
       \BRS 121(X); \BRS 121(Y)
       \BRS 114; EXIT

ER2CHI: TRNSTR(BI("CHI2: COLUMN OR ROW OF ZEROS! CANNOT CALCULATE", &
           "CHI2: COLONNE OU LIGNE DE ZEROS! NON CALCULABLE"),CHIST1)
       GO ER3C

ERCHI2: TRNSTR(BI("CHI2: INVALID PARAMETERS", &
          "CHI2: PARAMETRES INCORRECTES"),CHIST1)
ER3C:  CHIST2(0)_-1; DF_0
       GO RETST

%CHI2
       COLAPS   !COLAPSE TABLE
       IF PCHFLG THEN PRCHTB
       CUMUL(0)_CUMUL(1)_0
       ADX_0
       
C1:    ADY_0
C11:   NULL
       FLOAT(XINTG(ADX,ADY),T1)
       FLOAT(XXTOT(ADX),T2)
       FLOAT(YYTOT(ADY),T3)

       \LDP (^T1); \FMP(^T1); \FDV(^T2); \FDV(^T3)
       \FAD (^CUMUL); \STP(^CUMUL)

       IF INC ADY<=NY THEN GO C11
       IF INC ADX<=NX THEN GO C1

       FLOAT(GDTOT,T1)
       FLOAT(1,T2)

       \LDP(^CUMUL); \FSB(^T2); \FMP(^T1)

       \STP(^CHIVAL); DF_NX*NY
       RETURN
END CHI2


%COLAPS

AA:    TOTAL

       XMIN_IMIN(XXTOT,NX)
       YMIN_IMIN(YYTOT,NY)

       IF XXTOT(XMIN)*YYTOT(YMIN)/GDTOT>2 THEN RETURN

       IF (XXTOT(XMIN)<YYTOT(YMIN)) AND NX>1 THEN GO XCOLAPS
       IF NY>1 THEN GO YCOLAPS
       IF XXTOT(XMIN)*YYTOT(YMIN)=0 THEN GO ER2CHI !ZERO LINE OR COL COULD NOT
                                                   !BE COLAPSED
       RETURN

XCOLAPS: ADX_SMALL(XXTOT,XMIN,NX)

       Y_0; NEXT_ADX+1
XC1:   XINTG(ADX,Y)_XINTG(ADX,Y)+XINTG(NEXT,Y)
       IF INC Y<=NY THEN GO XC1

       S_ADX+1
XC2:   Y_0; NEXT_S+1
XC21:  XINTG(S,Y)_XINTG(NEXT,Y)
       IF INC Y<=NY THEN GO XC21
       IF INC S<=NX-1 THEN GO XC2
       DEC NX
       GO AA


YCOLAPS: ADY_SMALL(YYTOT,YMIN,NY)

       X_0; NEXT_ADY+1
YC1:   XINTG(X,ADY)_XINTG(X,ADY)+XINTG(X,NEXT)
       IF INC X<=NX THEN GO YC1
       S_ADY+1
YC2:   X_0; NEXT_S+1
YC21:  XINTG(X,S)_XINTG(X,NEXT)
       IF INC X<=NX THEN GO YC21
       IF INC S<=NY-1 THEN GO YC2
       DEC NY
       GO AA

END COLAPS

%SMALL(ARRAY(),DIM,BDIM)

       IF DIM=BDIM THEN RETURN DIM-1
       IF DIM=0 THEN RETURN DIM
       IF ARRAY(DIM-1)<ARRAY(DIM+1) THEN RETURN DIM-1 ELSE RETURN DIM
END SMALL

%IMIN(ARRAY(),DIM)
       LOCAL K,LMIN,DMIN
       K_0; LMIN_OCT 37777777; DMIN_-1

IM1:   IF ARRAY(K)<LMIN THEN [LMIN_ARRAY(K); DMIN_K]
       IF INC K<=DIM THEN GO IM1
       RETURN DMIN
END IMIN

%TOTAL

       MOVE 215 FROM ALL 0 TO XXTOT

       GDTOT_0
       ADY_0

L1:    ADX_0
L11:   XXTOT(ADX)_XXTOT(ADX)+XINTG(ADX,ADY)
       YYTOT(ADY)_YYTOT(ADY)+XINTG(ADX,ADY)
       GDTOT_GDTOT+XINTG(ADX,ADY)
       IF INC ADX<=NX THEN GO L11
       IF INC ADY<= NY THEN GO L1

       RETURN
END TOTAL
%MOVTAB

       NXP1_1+NX_NROWS-AUX(1)-1
       NYP1_1+NY_NCOLS-AUX(2)-1

       S_0
       IF NY<0 THEN [S_4; NY_0; NYP1_1]

       X_0
TR1:   Y_0
TRCELL: XINTG(X,Y)_TBL((X*NCOLS)+Y+TPTR+S+1)
       IF INC Y<=NY THEN GO TRCELL
       IF INC X<=NX THEN GO TR1

       RETURN
END MOVTAB

%PRCHTB
       WRITE(BI("TABLE COLLAPSED","CHI2: TABLE PLIEE"),OFL)
       \CIO(OFL,CARRET); \CIO(OFL,CARRET)
       S_[3,12,1,8]*[1,4,1,OFL]
       X_0
CC1:   Y_0
CC2:   XTR_XINTG(X,Y); IF XTR<9999 THEN \BRS 53(XTR,,S) ELSE WRITE("****",OFL)
       IF INC Y<=NY THEN GO CC2
       \CIO(OFL,CARRET)
       IF INC X<=NX THEN GO CC1
       \CIO(OFL,CARRET)
       RETURN
END PRCHTB
SURVEY ** FICHE/FRAME BREAK *****
/CPAVSTAT:SIMP/ SYMSORT

SYM.  PG.LN. IDENT.

!       1  6 M!!!    !M      1  3 M!!!    !M!     1  2 M!!!    %CHI2M  3 35 M!!!    
%PRCHT  6 30 M!!!    %TOTAL  6  1 M!!!    C11:    4  2 M!!!    
C1:     4  1 M!!!    CALC:   3  4 M!!!    CC1:    6 34 M!!!    CC2:    6 35 M!!!    
DEF     1 38 M!!!    DEF     1 34 M!!!    DEF     1 32 M!!!    DEF     1 31 M!!!    
DEF     1 30 M!!!    DEF     1  4 M!!!    DFMV:   2 15 M!!!    END     7  2 M!!!    
END     6 28 M!!!    END     6 14 M!!!    END     5 38 M!!!    END     5 30 M!!!    
END     5 25 M!!!    END     4 20 M!!!    ENDM    2  1 M!!!    ENDM    1 36 M!!!    
ER2CHI  3 26 M!!!    ER3C:   3 32 M!!!    ERCHI2  3 30 M!!!    FIND    1 17 M!!!    
FIND    1 16 M!!!    FIND    1 14 M!!!    FIND    1 13 M!!!    FIND    1 12 M!!!    
GLOBAL  2  3 M!!!    GLOBAL  1 27 M!!!    GLOBAL  1 25 M!!!    GLOBAL  1 24 M!!!    
GLOBAL  1 23 M!!!    GLOBAL  1 22 M!!!    GLOBAL  1 21 M!!!    GLOBAL  1 20 M!!!    
GLOBAL  1 19 M!!!    IM1:    5 35 M!!!    L11:    6  7 M!!!    L1:     6  6 M!!!    
MC1:    2 28 M!!!    MMOVTA  6 15 M!!!    MR1:    2 36 M!!!    MROW:   2 35 M!!!    
RETST:  3 22 M!!!    STPROG  2  5 M!!!    TABLE   1  8 M!!!    TR1:    6 22 M!!!    
TRCELL  6 23 M!!!    VERSIO  1  9 M!!!    XC1:    4 39 M!!!    XC21:   5  5 M!!!    
XC2:    5  4 M!!!    XCOLAP  4 36 M!!!    YC1:    5 15 M!!!    YC21:   5 19 M!!!    
YC2:    5 18 M!!!    YCOLAP  5 12 M!!!    _COLAP  4 23 M!!!    _IMIN(  5 32 M!!!    
_SMALL  5 27 M!!!    
SURVEY ** FICHE/FRAME BREAK *****
/CPAVTABU:SIMP/
!!! TABU VERSION C
!   JP BARASZ
!   2 FEVRIER 1972
!
! CONVERTE TO BILINGUAL VERSION 5/74 BY B. THORNQUIST
!

DEF BI(ENGLISH,FRENCH) AS ENGLISH


       TABLE &
VERSION ["TABU C02.08"]
!   VERSION 2.06 FIXES DK/NA BUG 
!      VERSION 2.07 FIXES A SUBSCRIPT BUG IN DK/NA LOCGIC
!    VERSION 2.08 FIXES BUG IN TABULATING AND XTABULATING MULTIPLE
!    RESPONSE QUESTIONS WHERE N ANSWERS MAY BE IDENTICAL
!    CORRECTS RESPONSE AND RESPONDENT TOTALS
!    ADDD BIAS OPTION FOR WEIGHTED TABLES

! BLOCK COMMON TO TABCOM AND TABU !

       FIND CNTBAS
       FIND %BOUT,%OUTNO
       FIND LASADR,TCNT,TCB(0:399),TBL(3000)
       FIND NQUES,QSIZE


! END COMMON BLOCK !
!*****  

       FIND %FIX,%FLOAT,%FMUL,%FDIV

!*****


       GLOBAL RETCNT
       FIND TCTR
       GLOBAL %YES,%READREC
       DEF OPENI(P1,P2,BAD,FILE) BY
       \BRS 64 (P1,P2,GO BAD); \STA (FILE)
       ENDM OPENI
       DEF CLOSE(X) AS \BRS 20 (X)
       FIND %WRITE,%CAROUT
       FIND %ARM,%RETESC
       GLOBAL CNTR,FSIZE,LSTADR,EOFFLG,P,P1,P2
!       DEF OUTNO(X) AS \BRS 36 (X,10,1)
       GLOBAL AUX(2)
       GLOBAL ANSRS()
       FIND %DISPLAY,%READ,%GTPT,%LENGTH,%EQUAL,%LEFT
       FIND %ADDSTR,%SCAN,TOKEN(0:1),CURPOS,%TRNSTR
       FIND BFLNO,SFLNO,SNAME(0:1),BUFF(0:1)
       GLOBAL BFNAME(0:15)
       FIND QVERS,DICVERS,TYPE
       FIND PRESTR,PRERL1,PRERL2,RL1,RL2

       DEF EOLTYPE AS 5
       GLOBAL %FILT,%BINOPN
       LOCAL PT1,PT2,TSTR(0:10),TST1(0:10)
       FIND TEL,DIC,INTRFL
       GLOBAL PROG:,BADDIC:,BADINT:,ESCAPE:,NOBIN:

       DEF NWDS AS 3401
       DEF NA AS -4000000
       DEF NBAS AS 48
       DEF WCP AS OCT 40000000
       GLOBAL TPTR,NROWS,NCOLS,ROW,COL,NRANS
       GLOBAL NCANS,RDTPNT,CDTPNT,RCODE,CCODE,RTYP,CTYP,WGHTNO,WGHT
       GLOBAL IBTOT,RMIN,CMIN,RDAT,IRTAB,IRTOT,CDAT,ICTAB,IXTOT,ICTOT
       GLOBAL LOWVAL

       LOCAL CNAK,RNAK  ! DK/NA CTRS
       LOCAL I,J,R,C,T,A,A1,C1,TIN,K
       LOCAL BSZ

       
       DEF INP AS 1
       DEF OUTP AS 0

!*****

       LOCAL BIAS,FBIAS(0:1),FWGHT(0:1),FRDAT(0:1),FCDAT(0:1)
       LOCAL TEMP,FTEMP(0:1),FTEMP1(0:1),TEMP1,TEMP2,FTEMP2(0:1)

!*****






PROG:  NULL !  DISPLAY(VERSION,1,1)
       AUX(1)_5; AUX(2)_5
PG1:   IF BINOPN THEN GO FINIR   ! COULD NOT OPEN BINARY FILE
       ARM(ESCAPE)
       EOFFLG_CNTR_0
       RETCNT_0
       \BRS 43; \STA (RL1); ANSRS_OCT 34002
       \BIO(BFLNO,2048,,OCT 34000,GO EO1F); \STA(LSTADR)
       \BRS 114; GO RDRC

EO1F: \STA (LSTADR); EOFFLG_1; \BRS 114
RDRC:  IF CNTR>= TCTR THEN GO EOF1
       READREC
       ANSRS(0)_1   ! SO WEIGHT 0 WILL BE ONE
       INC CNTR
       IF BYT(CNTR,4,0)=0 THEN DO
               IF RETCNT>=72 THEN [BOUT(CARRET);RETCNT_0]
               BOUT($')
               INC RETCNT
       END

  ! TAB LOOP : B200 TO T200 !

       T_0

  ! CHECK IF QAIRE MEETS FILTER CONDITIONS  !

B200: IF (FILT(TCB(T))) = 0 THEN GO T200 ! FILTER TABLE T!

  ! FILTER CONDITION MET ,TAKE VARS WITH CALCULATED INDEXES OUT OF LOOP !

       TPTR_TCB((20*17)+T)  ! TABLE PNT  !
       TPTR_TPTR-1
!*****
       BIAS _ TCB((20*16)+T)
       IF BIAS=0 THEN BIAS _ 1
       FLOAT(BIAS,@FBIAS)
!*****
       NROWS_TCB((20*14)+T)  ! # OF ROW BREAKS  !
       NCOLS_TCB((20*15)+T)  ! # OF COL BREAKS  !
       ROW_TCB((20*2)+T)     ! ROW VARIABLE     !
       COL_TCB((20*3)+T)     ! COL VARIABLE     !
       NRANS_TCB((20*6)+T)   ! ROW VEC SIZE     !
       NCANS_TCB((20*7)+T)   ! COL VEC SIZE    !
       RDTPNT_TCB((20*12)+T)  ! ROW VAR DATA REC PNT !
       CDTPNT_TCB((20*13)+T)  ! COL VAR DATA REC PNT !
       RCODE_TCB((20*8)+T)   ! ROW QUES CODE PNT !
       CCODE_TCB((20*9)+T)   ! COL QUES CODE PNT !
       RTYP_TCB((20*4)+T)    ! ROW VAR TYPE    !

       CTYP_TCB((20*5)+T)    ! COL VAR TYP     !
       [12,12]*[,WGHTNO]_TCB(20+T)      ! WEIGHT FACT. VAR  ADDRESS!
       WGHT_ANSRS(WGHTNO)
       IF WGHT=NA THEN WGHT_0
!*****
       FLOAT(WGHT,@FWGHT)
       RMIN_TCB((20*10)+T)   ! ROW QUES MIN. VAL. !
       CMIN_TCB((20*11)+T)   ! COL QUES MIN. VAL. !
       IBTOT_TPTR+(NROWS*NCOLS)  ! BASE ADR IN TABLE  !
!*****
       TBL(IBTOT)_TBL(IBTOT)+  WGHT! ADD TO BASE TOTAL  !

!****** FOR VERSION 3.08 12/30/75 *********
!
!      TREAT MULTIPLE RESPONSE COLUMN QUESTIONS AS MARGINAL
!      I.E. IGNORE DUPLICATE ANSWERS, THIS IS A CONVENTION
!

       LOCAL II,JJ,GM,FDFLG

       LOCAL JJUNK
       JJUNK_0   !************
       IF JJUNK=0 THEN GO ZEND !****

ZBEG:  FDFLG_0
       
       IF (NCANS=1) OR (COL=0) THEN GO ZEND  !  NOT MULTIPLE, IGNORE

       II_0  ! INDEX TO II-TH ANS FROM DATA RECORD

Z10:   JJ_II+1  !  INDEX TO CODE BEING CHECKED

       IF ANSRS(CDTPNT+II)=NA THEN GO Z40  !  NO ANSWER, IGNORE

!      CHECK EACH CODE AGAINST CURRENTT ANSWER

Z20:   DO CTYP OF 2

!      DISCRETE
       1: IF ANSRS(CDTPNT+II)=ANSRS(CDTPNT+JJ) THEN GO Z45 ELSE GO Z30

!      CONTINUOUS, A LITTLE TRICKY

       2: IF FDFLG#0 THEN GO Z22  !DONT FIND RANGE IF ALREADY FOUND
          LOWVAL_CMIN
          C1_0  ! RUNS TO NCOLS-AUX(2)-1
Z21:   ICTAB _ TBL(CCODE+C1)  ! GET C1-TH MAXIMUM

       IF (ANSRS(CDTPNT+II) >= LOWVAL) AND (ANSRS(CDTPNT+II) <= ICTAB) &
          THEN [FDFLG_1 ;  GO Z22]

       LOWVAL _ ICTAB+1 ! SET NEXT MINIMUM

       IF INC C1<=(NCOLS-AUX(2)-1) THEN GO Z21 !CHECK NEX BREAK

       GO Z40  

Z22:   IF(ANSRS(CDTPNT+JJ)>=LOWVAL)AND(ANSRS(CDTPNT+JJ))<=ICTAB &
         THEN GO Z45 ELSE GO Z30

       END



!      FOUND DUPLICATE ANS

Z45:   ANSRS(CDTPNT+JJ)_NA
!      SEND MESSAGE
       BOUT(CARRET)
       DISPLAY("DUPLICATE RESPONSE DROPPED. TABLE ",0,0)
       GM_T+CNTBAS+1
       OUTNO(GM)
       DISPLAY(", RECORD NO. ",0,0)
       OUTNO(CNTR)
       DISPLAY(", QUESTION ",0,0)
       OUTNO(COL)
       BOUT(CARRET); BOUT(CARRET)
Z30:   IF INC JJ<=(NCANS-1) THEN GO Z20  ! GET NEXT ANSWER

Z40:   FDFLG_0  ! TRUN RANGE FOUND FLAG OFF
       IF INC II<=(NCANS-2) THEN GO Z10 !  GET NEXT ANSWER

ZEND:  NULL

  !  ROW ANSWERS LOOP, A=0 TO NRANS-1 !

       A_RNAK_0





B50:   RDAT_ANSRS(RDTPNT+A)              ! GET FIRST VALUE OF ROW VAR !
!*****
       FLOAT(RDAT,@FRDAT)
!*****
       LOWVAL_RMIN

  ! FIND WHAT ROW ANSR GOES IN: CODE OR BREAK !


       C_0    ! LOOP CONTROL: C=0 TO NROWS-AUX(1)-1 !
B30:   IRTAB_TBL(RCODE+C)     ! CTH VALID CODE FOR ROW VARIABLE  !


       DO RTYP OF 2
1:     IF RDAT=IRTAB THEN GO S35 ELSE GO C30
2:     IF (RDAT>= LOWVAL) AND (RDAT <=IRTAB) THEN GO S35 ELSE &
       [LOWVAL_IRTAB+1; GO C30]
END
  ! FOUNT ROW, ADD TO TOTALS: RESPONDANTS, ANSWERS, ANSWERS SQUARED !







S35:   IRTOT_TPTR+((C+1)*NCOLS) !   RESPONDANT TOTAL ADR FOR ROW !
       TBL(IRTOT)_TBL(IRTOT)+WGHT

S36:   IRTOT_TPTR+(NCOLS*(NROWS-2))  ! TOTAL ROW ANS SQUARED ADR !
!****
       FMUL(@FRDAT,@FWGHT,@FTEMP)
       FDIV(@FTEMP,@FBIAS,@FTEMP1)
       FIX(FTEMP1(0),FTEMP1(1),@TEMP)
       FMUL(@FRDAT,@FTEMP1,@FTEMP)
       FIX(FTEMP(0),FTEMP(1),@TEMP1)
       TBL(IRTOT) _ TBL(IRTOT) + TEMP1



!*****

       IRTOT_IRTOT+NCOLS     ! TOTAL ROW ANSRS ADR !
       TBL(IRTOT)_TBL(IRTOT)+(WGHT*RDAT)
       GO S40                 ! BRANCH OUT OF FIND CODE LOOP !

  ! END OF FIND CODE LOOP  !

C30:   &
       IF INC C <= NROWS-AUX(1)-1 THEN GO B30

  ! CODE NOT FOUND CHECK FOR DK !

       IF RDAT=NA THEN [INC RNAK; GO A50]
!*****
       BOUT(CARRET)
       DISPLAY("REJECT IN TABLE ",0,0)
       LOCAL BBB
       BBB_T+CNTBAS+1
       OUTNO(BBB)
       DISPLAY(", RECORD NO. ",0,0)
       OUTNO(CNTR)
       DISPLAY(", QUESTION ",0,0)
       OUTNO(ROW)
       DISPLAY(". VALUE IS ",0,0)
       OUTNO(RDAT)
       BOUT(CARRET); BOUT(CARRET)
!******
       C_NROWS-4
C31:   IRTOT_TPTR+((C+1)*NCOLS)  !NA OR REJECT ADR FOR ROW !
       TBL(IRTOT)_TBL(IRTOT)+WGHT

  ! CHECK IF TABLE IS MARGINAL !

S40:   IF COL=0 THEN GO A50 !  IF MAR DONT GET COL ANSRS !

  ! FIND THE COL (S) FOR THE ROW ALREADY FOUND , LOOP A1=0 TO NCANS-1 !

       CNAK_A1_0
B45:   CDAT_ANSRS(CDTPNT+A1)
       FLOAT(CDAT,@FCDAT)
       LOWVAL_CMIN

  ! COL CODE LOOP C1=0 TO NCOLS-AUX(2)-1


       C1_0
B43:   ICTAB_TBL(CCODE+C1)
       DO CTYP OF 2
1:     IF CDAT=ICTAB THEN GO S44 ELSE GO C143
2:     IF (CDAT>=LOWVAL) AND (CDAT <= ICTAB) THEN GO S44 ELSE&
       [LOWVAL_ICTAB+1; GO C143]
END

  ! FOUND ROW AND COL, ADD TO TOTALS: XTAB CELL, COL AND ROW ANS !
  ! COL AND ROW ANS SQUARED !

S44:   IXTOT_TPTR+(C*NCOLS)+C1+1  ! ADR OF CROSS TAB CELL TO ADD TO !




       
       TBL(IXTOT)_TBL(IXTOT)+WGHT

  ! ADD TO SUM OF COL ANSRS SQUARED FOR THE ROW !

       IXTOT_TPTR+((C+1)*NCOLS)-2
!***** TBL(IXTOT)_TBL(IXTOT)+((CDAT*CDAT)*WGHT)
       FMUL(@FCDAT,@FWGHT,@FTEMP2)
       FDIV(@FTEMP2,@FBIAS,@FTEMP2)
       FMUL(@FCDAT,@FTEMP2,@FTEMP2)
       FIX(FTEMP2(0),FTEMP2(1),@TEMP2)
       TBL(IXTOT) _ TBL(IXTOT) + TEMP2
!*****

  ! ADD TO SUM OF COL ANSRS FOR THE ROW !

       IXTOT_IXTOT+1
       TBL(IXTOT)_TBL(IXTOT)+(CDAT*WGHT)

  ! GET ROW SUMS FOR COL IF ROW NOT DK !

       IF C > NROWS-AUX(1)-1 THEN GO A145 !ROW IS DK OR BAD !

  ! ADD TO SUM OF ROW ANSRS SQUARED FOR THE COL !

       IXTOT_TPTR+(NCOLS*(NROWS-3))+C1+1
!***** TBL(IXTOT)_TBL(IXTOT)+(WGHT*(RDAT*RDAT))

       FMUL(@FTEMP1,@FRDAT,@FTEMP2)
       FIX(FTEMP2(0),FTEMP2(1),@TEMP2)
       TBL(IXTOT) _ TBL(IXTOT) + TEMP2

  ! ADD TO SUM OF ROW ANSRS FOR THE COL !

       IXTOT_IXTOT+NCOLS
       TBL(IXTOT)_TBL(IXTOT)+(WGHT*RDAT)

  ! ADD TO SUM OF X*Y !

       IXTOT_TPTR+((NROWS-1)*NCOLS)-1
!***** TBL(IXTOT)_TBL(IXTOT)+(WGHT*(CDAT*RDAT))

       FMUL(@FCDAT,@FTEMP1,@FTEMP)
       FIX(FTEMP(0),FTEMP(1),@TEMP)
       TBL(IXTOT) _ TBL(IXTOT) + TEMP


!*****

       GO A145  ! GET NEXT COL ANS- A145 END OF COL ANS LOOP !

  ! END OF COL CODES LOOP !

C143:  &
       IF INC C1 <= NCOLS-AUX(2)-1 THEN GO B43

  ! CODE NOT FOUND CHECK FOR DK OR BAD !

       IF CDAT = NA THEN [INC CNAK; GO A145]
       DISPLAY("REJECT IN TABLE ",0,0)
       BBB_T+CNTBAS+1
       OUTNO(BBB)
       DISPLAY(", QAIRE NO. ",0,0)
       OUTNO(CNTR)
       DISPLAY(", QUESTION ",0,0)
       OUTNO(COL)
       DISPLAY(". VALUE IS ",0,0)
       OUTNO(CDAT)
       BOUT(CARRET)
       BOUT(CARRET)
!*******
       C1_NCOLS-4

  ! COL ANS IS DK OR BAD, ADD TO APPROPRIATE CROSS TAB CELL !

D143:  IXTOT_TPTR+(C*NCOLS)+C1+1
       TBL(IXTOT)_TBL(IXTOT)+WGHT
  ! GET NEXT COL ANS IF BOTH ROW AND COL DK/REJECT !


       IF C> NROWS-AUX(1)-1 THEN GO A145

  ! ADD TO SUM OF ROW ANSRS SQUARED FOR THE DK/REJECT COL !

       IXTOT_TPTR+(NCOLS*(NROWS-3))+C1+1
!***** TBL(IXTOT)_TBL(IXTOT)+(WGHT*(RDAT*RDAT))

       FMUL(@FTEMP1,@FRDAT,@FTEMP)
       FIX(FTEMP(0),FTEMP(1),@TEMP)
       TBL(IXTOT) _ TBL(IXTOT) + TEMP

  ! ADD TO SUM OF ROW ANSRS  FOR THE DK/REJECT COL !

       IXTOT_IXTOT+NCOLS
       TBL(IXTOT)_TBL(IXTOT)+(WGHT*RDAT)

 !  END OF COL ANSRS LOOP !

A145:  &
       IF INC A1 <=NCANS-1 THEN GO B45
       IF CNAK = NCANS THEN [C1_NCOLS-AUX(2); CNAK_0; GO D143]
       !ABOVE LINE FORCES GOING THROUGH THE LOOP IF ALL ANS ARE DK

  ! END OF ROW ANSRS LOOP !

A50:  &
       IF INC A <= NRANS-1 THEN GO B50
       IF RNAK = NRANS THEN [C_NROWS-AUX(1); RNAK_0; GO C31]
       !ABOVE ALL ROWS WERE NA, PROCESS COLUMNS AND FORCE EXIR NEXT ITERATION

  ! GET CO TOTALS !

       IF COL = 0 THEN GO  T200

       CNAK_A1_0
B60:   LOWVAL_CMIN
       CDAT_ANSRS(CDTPNT+A1)


       C1_0
B55:   ICTAB_TBL(CCODE+C1)
       DO CTYP OF 2
1:     IF CDAT=ICTAB THEN GO S58 ELSE GO C155
2:     IF (CDAT >= LOWVAL) AND (CDAT <=ICTAB) THEN GO S58 &
       ELSE [LOWVAL_ICTAB+1; GO C155]
END

S58:   ICTOT_TPTR+((NCOLS)*(NROWS-1))+C1+1



       TBL(ICTOT)_TBL(ICTOT)+WGHT  !* TOTAL RESPONDENTS FOR COL C1
S581:  ICTOT_TPTR+(NROWS*NCOLS)-2
!***** TBL(ICTOT)_TBL(ICTOT)+(WGHT*(CDAT*CDAT))
       FLOAT(CDAT,@FCDAT)
       FMUL(@FCDAT,@FWGHT,@FTEMP)
       FDIV(@FTEMP,@FBIAS,@FTEMP1)
       FMUL(@FTEMP1,@FCDAT,@FTEMP1)
       FIX(FTEMP1(0),FTEMP1(1),@TEMP1)
       TBL(ICTOT) _ TBL(ICTOT) +TEMP1
       ICTOT_ICTOT+1
       TBL(ICTOT)_TBL(ICTOT)+(WGHT*CDAT)
       GO A160
C155:  &
       IF INC C1 <=NCOLS-AUX(2)-1 THEN GO B55

  ! CHECK FOR DK/REJECT COL TOTALS !
       IF CDAT = NA THEN [INC CNAK; GO A160]
       C1_NCOLS-4
C156:  ICTOT_TPTR+(NCOLS*(NROWS-1))+C1+1
       TBL(ICTOT)_TBL(ICTOT)+WGHT
A160:  &
       IF INC A1 <= NCANS-1 THEN GO B60
       IF CNAK = NCANS THEN [CNAK_0; C1_NCOLS-AUX(2); GO C156]

  ! END OF TABLE LOOP !

T200: &
       IF INC T <=TCNT-1 THEN GO B200


  ! GET NEXT RECORD !

       ANSRS_ANSRS+QSIZE
       GO RDRC

  ! EOF OF FILE ROUTINE !

  ! CORRECT EOF ENCOUNTERED, WRITE COMMON BLOCK, END PROGRAM !
EOF1:  \BRS 113
       CLOSE(BFLNO); BFLNO_0
!******
!      FOR ALL TABLE ENTRIES THAT HAVE NOT BEEN DIVIDED
!      BY THE WEIGHTING BIAS DO SO.

       T _ 0
BB00:  TPTR _ TCB((20*17)+T)-1

       BIAS _ TCB((20*16)+T)  ! GET BIAS FOR THIS TABLE

       LOCAL IB,IJ,IR
       NROWS_TCB((20*14)+T)
       NCOLS_TCB((20*15)+T)

       IF BIAS = 1 THEN GO BB100

       IJ _ 0
       II _ 0
       IB _ 0


BB10:  IR _ TPTR+1+IB+II
       IF II=NCOLS-AUX(2)+2 THEN GO BB20 ! DONT DIVIDE ANS SQD COL
       TBL(IR) _ TBL(IR)/BIAS
BB20:  IF INC II <= NCOLS-1 THEN GO BB10

       II _ 0
       IB _ IB + NCOLS  ! POINT TO NEXT ROW
       IF INC IJ<=NROWS-4 THEN GO BB10 ! STOP AT REJCT ROW

       II _ 0
       IR _ TPTR+1+(NCOLS*(NROWS-2))
BB40:  TBL(IR+II) _ TBL(IR+II)/BIAS
       TBL(IR+II+NCOLS) _ TBL(IR+II+NCOLS)/BIAS

       IF INC II<=NCOLS-AUX(2)+1 THEN GO BB40 ! STOP AT REJECT COL

       IR _ TPTR   + ((NROWS*NCOLS)-1) !* 3/26 MOD FOR POP TOT
       TBL(IR)_ TBL(IR)/BIAS ! COL ANS
       TBL(IR+1)_TBL(IR+1)/BIAS  !*** 4/11 MOD FOR BAS TOTAL
       IR_TPTR + (NROWS-1)*NCOLS
       TBL(IR) _ TBL(IR)/BIAS


BB100: IF INC T<=TCNT-1 THEN GO BB00


!      END OF TABLE BIAS LOOP
!******
       IF TCTR=FSIZE THEN TCTR_8000000 !THIS RESETS TCTR FOR MULTIPLE
                                       !FILE PROCESSING ONLY IN CASE
                                       !TCTR WASN'T SPEC. IN "TRAITER"
       DISPLAY(BI("NUMBER OF RECORDS PROCESSED: ", &
        "NOMBRE D'ENREGISTREMENTS TRAITES: "),1,0)
       OUTNO(CNTR)
       DISPLAY(BI("ANOTHER FILE? ","UN AUTRE FICHIER? "),1,0)
       IF YES THEN GO PG1

       I_[1,23]*[1,LASADR]
       \LDA (I); \SCP (INTRFL, GO BADINT)
       \BIO (INTRFL,NWDS,,@TCNT,GO BADINT)
       GO FINIR



BADDIC:  DISPLAY(BI("ERROR IN DICTIONARY FILE", &
           "ERREUR DANS FICHIER DICTIONNAIRE"),2,2)
       DISPLAY(BI("ABORTED","ANNULE"),0,1)
       EXIT

BADINT:  DISPLAY(BI("ERROR IN INTERMEDIARY FILE",  &
          "ERREUR DANS FICHIER DINTERMEDIAIRE"),2,2)
       DISPLAY(BI("ABORTED","ANNULE"),0,1); EXIT

BDATA: DISPLAY (BI("ERROR IN DATA FILE",  &
          "ERREUE DANS FICHIER DE DONNEES"),2,2)
       DISPLAY(BI("ABORTED","ANNULE"),0,1); EXIT




ESCAPE: \BRS 113
       ARM(ESCAPE)
       \BRS 11 (,,-1); \BRS 29
       DISPLAY(BI("CONTINUE? ","CONTINUER? "),1,0)
       IF YES THEN [DISPLAY(BI(" ","JE VAIS ESSAYER"),0,1);\BRS 114; RETESC]
       DISPLAY(BI("ABORTED","ANNULE"),0,1)
       CLOSE(BFLNO); BFLNO_0; GO FINIR

FINIR: \BRS 113
       \BRS 43; \STP (RL1); \BRS 121 (BYT(RL1,6,0))
       ! RELEASES TABLE PAGES AND DATA IO PAGE
       [6,6,6,6]*[P,I,P1,P2]_RL2; \BRS 121(I)
       \BRS 121(P);\BRS 121(P1);\BRS 121(P2)
       EXIT
%YES
Y1:    READ(@TEL)
       I_LENGTH(@BUFF)
       LEFT(BI("YES","OUI"),I,@TST1)
       IF EQUAL(@BUFF,@TST1) THEN RETURN 1
       LEFT(BI("NO","NON"),I,@TST1)
       IF EQUAL(@BUFF,@TST1) THEN RETURN 0
       DISPLAY(BI("YES OR NO","OUI OU NON? "),0,0)
       GO Y1
END YES

!
!  NAME:              FILT(N)
!
!  FUNCTION:          RETURNS VALUE OF FILTER N
!
!  INPUT:             N = FILTER NUMBER
!
!  OUTPUT:            TRUE IF FILTER N = 1
!
!  ERRORS DETECTED:   NONE
!
!  ROUTINES CALLED:   NONE
!
%FILT(N)
       IF NOT N THEN RETURN 1
       IF N<25 THEN RETURN  ANSRS(2) BAND (1 SHL (N-1))
                    RETURN  ANSRS(1) BAND (1 SHL (N-25))
END FILT


!
!  NAME:              READREC
!
!  FUNCTION:          TO READ A RECORD FROM THE BINARY DATA FILE.
!                     CHECKS TO SEE IF THE CURRENT RECORD HAS BEEN
!                     EXHAUSTED, IF NOT RETURN.  OTHERWISE IT
!                     BUFFERS IN A NEW RECORD.  IF AN EOF IS ENCOUNTERED
!                     IT BRANCHES TO EOF22.
!
!  INPUT:             NONE
!
!  OUTPUT:            NONE
!
!  ERRORS DETECTED:   NONE
!
!  ROUTINES CALLED:   NOEN
!
%READREC

       IF ANSRS<OCT 34000 THEN RETURN
       \BRS 43; \STP (RL1)
       [12,6,6]*[P,P1,P2]_RL2
       RL2_[12,6,6]*[P,P2,P1]  !EXCH. P6 AND P7
       \BRS 44(RL1,RL2)
       ANSRS_ANSRS-2048; LSTADR_BYT(LSTADR+OCT 34000,14,0)
       IF NOT EOFFLG THEN DO
               \BIO (BFLNO,2048,,OCT 34000, GO EOF22); \STA (LSTADR)
       END
       RETURN
EOF22: \STA (LSTADR); EOFFLG_1; RETURN
END READREC
!
!  NAME:              BINOPN
!  FUNCTION:          OPENS BINARY DATA FILE WITH NAME OF SYMBOLIC
!                     DATA FILE APPENDED WITH 'BIN'.
!  INPUT:             NONE
!
!  OUTPUT:            NONE
!
!  ERRORS DETECTED:   DISPLAYS APPROPRIATE ERROR MESSAGE AND RETURNS
!                     1 IF BINARY FILE MISSING, SYMBOLIC DATA FILE 
!                     MISSING, OR BINARY DATA FILE WAS CREATED WITH
!                     NA OUTDATED VERSION OF SURVEY.
!
!  ROUTINES CALLED:   DISPLAY,READ,OPENI,CLOSE
!
%BINOPN
       
ACPT:  DISPLAY(BI("FILE: ","FICHIER: "),1,0)
       READ(@TEL); TRNSTR(@BUFF,@SNAME)
       IF EQUAL(@SNAME,"Q") OR EQUAL(@SNAME,"QUIT") THEN DO
               DISPLAY(BI("PROCESSING ABORTED","TRAITEMENT ANNULE!"),1,1)
               RETURN 1
       END

B3:     IF NOT LENGTH(@SNAME) THEN GO ACPT
       ADDSTR(@SNAME,"'BIN'",@BFNAME)
       GTPT(@BFNAME,@PT1,@PT2)

       OPENI(PT1,PT2,NOBIN,BFLNO)
       \STB (J); IF J#2 THEN GO BBIN  !NOT BINARY
       GO CKSZ
NOBIN: GTPT(@SNAME,@PT1,@PT2)
       \BRS 48(PT1,PT2,GO ACPT)  !LOOK-UP SYM FILE
BBIN:  DISPLAY(@BFNAME,1,0); DISPLAY(BI(" INVALID OR MISSING", &
          "NON-VALABLE OU ABSENT"),0,0)
       DISPLAY(BI("PREPROCESSING PROGRAM MUST BE CALLED",  &
           "UN PRETRAITEMENT EST NECESSAIRE"),1,0)
       RETURN 1
BADDFL: DISPLAY(BI("I/0 ERROR","I/O ERREUR"),1,1); EXIT
ALLOK: IF TCTR>FSIZE THEN TCTR_FSIZE
       \SCP(BFLNO,0,GO BADDFL)
       RETURN 0



CKSZ:  \RSP (BFLNO); \STA (I); I_I-6
       [I;J]_ I DIVMOD(QSIZE*3)
       FSIZE_I
       IF J#0 THEN GO NEWVERS
       \WIO (BFLNO); \STA (I)
       IF I#DICVERS THEN GO NEWVERS
       \WIO (BFLNO); \STA (I)
       IF I#QVERS THEN GO NEWVERS
       GO ALLOK

NEWVERS:  NULL
       CLOSE(BFLNO); BFLNO_0; GO BBIN

END BINOPN


SURVEY ** FICHE/FRAME BREAK *****
/CPAVTABU:SIMP/ SYMSORT

SYM.  PG.LN. IDENT.

!      16 26 !!!     !      16 25 !!!     !      16 24 !!!     !      16 21 !!!     
!      16 20 !!!     !      16 19 !!!     !      16  1 !!!     !      15 39 !!!     
!      15 38 !!!     !      15 37 !!!     !      14  5 !!!     !      12 39 !!!     
!       5 30 !!!     !       5 27 !!!     !       5  4 !!!     !       5  1 !!!     
!       4 36 !!!     !       4 19 !!!     !       2  1 !!!     !       1 25 !!!     
!       1 17 !!!     !       1 15 !!!     !       1 14 !!!     !       1 13 !!!     
!       1 12 !!!     !       1 11 !!!     !       1 10 !!!     !       1  3 !!!     
!       1  2 !!!     !***** 14  6 !!!     !***** 12 38 !!!     !***** 11 39 !!!     
!***** 10 32 !!!     !*****  9 36 !!!     !*****  9 29 !!!     !*****  9 15 !!!     
!*****  9  3 !!!     !*****  8 36 !!!     !*****  7 37 !!!     !*****  7 25 !!!     
!*****  7 13 !!!     !*****  6 18 !!!     !*****  6 17 !!!     !*****  4 17 !!!     
!*****  4 15 !!!     !*****  4 11 !!!     !*****  3 34 !!!     !*****  3 31 !!!     
!*****  2 34 !!!     !*****  1 26 !!!     !****M  7  4 !!!     !LM!   16 18 !!!     
!LM!   15 35 !!!     !LM!   15 23 !!!     !M!    16 27 !!!     !M!    16 23 !!!     
!M!    16 22 !!!     !M!    16  5 !!!     !M!    16  4 !!!     !M!    16  3 !!!     
!M!    16  2 !!!     !M!    15 36 !!!     !M!    15 28 !!!     !M!    15 27 !!!     
!M!    15 26 !!!     !M!    15 25 !!!     !M!    15 24 !!!     !M!     4 18 !!!     
!M!     1  4 !!!     !MM     4 20 !!!     !MMDEF  1  5 !!!     %YESMY 15 13 !!!     
1:     11 30 !!!     1:      8 19 !!!     1:      6 28 !!!     2:     11 31 !!!     
2:      8 20 !!!     2:      6 29 !!!     A145:  11  6 !!!     
A160:  12 18 !!!     A50:   11 13 !!!     ACPT:  16 29 !!!     ALLOK: 17 12 !!!     
B200:   3 25 !!!     B30:    6 24 !!!     B3:    16 36 !!!     B43:    8 17 !!!     
B45:    8  9 !!!     B50:    6 16 !!!     B55:   11 28 !!!     B60:   11 23 !!!     
BADDFL 17 11 !!!     BADDIC 14 22 !!!     BADINT 14 27 !!!     BB00:  13  3 !!!     
BB100: 14  2 !!!     BB10:  13 18 !!!     BB20:  13 21 !!!     BB40:  13 29 !!!     
BBIN:  17  6 !!!     BDATA: 14 31 !!!     C143:  10  1 !!!     C155:  12 10 !!!     
C156:  12 16 !!!     C30:    7 19 !!!     C31:    7 38 !!!     CKSZ:  17 18 !!!     
D143:  10 22 !!!     END    17 31 !!!     END    16 17 !!!     END    15 32 !!!     
END    15 21 !!!     ENDM    6 31 !!!     ENDMM   8 22 !!!     EO1F:   3  8 !!!     
EOF1:  12 36 !!!     EOF22: 16 16 !!!     ESCAPE 14 38 !!!     FINIR: 15  7 !!!     
M***** 10 18 !!!     M*****  1 30 !!!     NEWVER 17 28 !!!     NOBIN: 17  4 !!!     
OM%BIN 16 28 !!!     OM%FIL 15 29 !!!     OM%REA 16  6 !!!     PG1:    2 39 !!!     
RDRC:   3  9 !!!     S35:    6 39 !!!     S36:    7  3 !!!     S40:    8  4 !!!     
S44:    8 25 !!!     S581:  11 38 !!!     T200:  12 24 !!!     VERSIO  1  9 !!!     
Z10:    4 32 !!!     Z20:    4 38 !!!     Z21:    5  9 !!!     Z22:    5 20 !!!     
Z30:    6  1 !!!     Z40:    6  3 !!!     Z45:    5 29 !!!     ZBEG:   4 26 !!!     
ZEND:   6  6 !!!     _*****  2 37 !!!     _NDMMS 11 33 !!!     
SURVEY ** FICHE/FRAME BREAK *****
/CPAVTCOM:SIMP/
!!! TCOM VERSION C
!    JP BARASZ
! 26 JAN 1972
!
! VERSION CONVERTED TO BILINGUAL 5/74 BY B. THORNQUIST
!

DEF BI(ENGLISH,FRENCH) AS ENGLISH


       TABLE &
VERSION [BI("TAB U02.06","VENT C02.06")]  !FIX LOWER LIMIT BUG IN CONT. QUESTIONS

!!!!!BLOCK COMMON TO TABCOM AND TABU"!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

FIND LASADR      !INTERMEDIARY FILE SIZE!
       FIND RL1,RL2
FIND TCNT
FIND TCB(0:399)
DEF TTCB(X) AS TCB(20*(X)+TPOS)
FIND TBL(3000)
FIND NQUES
FIND QCBADR
FIND CDPLST
FIND CDPLND
FIND FLR(0:1)
FIND QSIZE
FIND BNAMADR


!!!!!END COMMON BLOCK!!!!!!!!!!!!!!!!!!!!!!



FIND CNTBAS
FIND TCTR
DEF PROMPT(X) BY
       DISPLAY(X,0,0)
       READ(@TEL)
ENDM PROMPT
!DEF OUTNO(X) AS \BRS 36 (X,10,1)
DEF CLOSE(X) AS \BRS 20 (X)
DEF OPENO(P1,P2,BAD,FILE,TYPE) BY
\BRS 65 (P1,P2,TYPE,GO BAD); \STA (FILE)
ENDM OPENO
DEF NOTYPES AS 10
DEF NORDRS AS 7
DEF ENDLIST AS OCT 20000000
DEF NFILTS AS 48
DEF MXQUES AS 512-NFILTS
DEF BIN AS 2
DEF SORTIE AS 0
DEF SYM AS 3
DEF CLEAR(X,Y) AS MOVE Y FROM ALL 0 TO X
DEF OUTTBL AS OCT 40000000

!!!!!STRING ARRAYS!!!!!!!!!!!!!!!!!!!!!!!!!

FIND QNAME(),QCBS(),LIB()
DEF QQCBS(X,Y) AS QCBS(4*(X-1)+Y)
DEF LLIB(X,Y) AS LIB(9*(X-1)+Y)
FIND NMPAGE,QCBPAGE
FIND BNAME()     !48 NAMES IN QNAME FORMAT AT END OF NAME PAGE
TABLE ORDR(0:NORDRS-1)[BI("FILTER","FILTRE"),BI("WEIGHT","PONDERATION"),&
   BI("CROSSTAB","CROISE"),"MARGINAL",BI("RUN","TRAITER"), &
       BI("HELP","SOS"), &
     "QUIT"]
TABLE LC(2)[BI("LINE? ","LIGNE? "),"COL.? "]
LOCAL TSTR(0:10)
LOCAL TST1(0:10)


!!!!!LABELS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

GLOBAL BADDIC:,SYNERR:,DSPTCH:,BADTOK:,PROG:,BADINT:,ESCAPE:,COMERR:
GLOBAL FILTER:,WEIGHT:,CROSS:,MARG:,PROCS:,SOS:,PLACE:,QUIT:


!!!!!VARIABLES!!!!!!!!!!!!!!!!!!!!!!!!!!!!

FIND TEL
GLOBAL CURBAS,CURWGHT
GLOBAL SIZE,QUES(2),TPOS,MFLG
GLOBAL MF.NM.FG  ! THIS FLAB USED TO INDICATE MARG CALLED WITH QNAME ARG.
GLOBAL QCB(),NCODES(2),CPLPNT(2),AUX(2)
GLOBAL SIZLFT,END3K,STRT3K,E3,S3,CF
LOCAL I,J,K,L,M,N,L2,PT1,PT2,ERR,M1,M2
!*****

       LOCAL BIAS

!*****


!!!!!SCANNER VARIABLES!!!!!!!!!!!!!!!!!!!!!!!!!

FIND TYPE,VALUE,TOKEN(0:24),%READ,%SCAN
FIND BUFF(0:1),NEWBUF(0:1)
DEF NUMTYPE AS 2
DEF EOLTYPE AS 5
DEF QSTYPE AS 6


!!!!!SUBROUTINES!!!!!!!!!!!!!!!!!!!!!!!!!!!!

GLOBAL %YESNO,%RELLIB,%SHORT

!!!!!EXTERNAL FUNCTIONS AND VARIABLES!!!!!!!

FIND %BCLOS,%BOUT,%BERX,%OUTNO
FIND DIC,INTRFL       !DICTIONNARY AND INTERMEDIARY FILE NUMBERS!
FIND STUDY(0:1)       !DIC NAME!
FIND %ACCEPT,%DISPLAY,%LEFT,%EQUAL,%STRNG,%LENGTH
FIND %ARM,%GTPT,%WRITE,%CAROUT
FIND %SWAPIN,%ADDSTR,%GETLIST,%NXTITEM,%STRTAB


!!!!!END DECLARATIONS!!!!!!!!!!!!!!!!!!!!!!!


!
!--------------------------------------------INITIALIZE VALUES---!

PROG: \BRS 113
!      DISPLAY(VERSION,1,1)
       AUX(1)_5; AUX(2)_5
       CLEAR(TCB,400)
       CLEAR(@TBL(1),3000)
       SIZLFT_3000
       END3K_3001
       STRT3K_1
       CURBAS_0
!*****
       BIAS_1
!*****
       CURWGHT_0
       TCNT_0
       IF INTRFL THEN GO PG1   ! FILE ALREADY OPEN
       ADDSTR(@STUDY,"'INT'",@TSTR)
       GTPT(@TSTR,@PT1,@PT2)
       OPENO(PT1+OCT 11600000,PT2,BADINT,INTRFL,BIN)
PG1:   \RSP (INTRFL); \STA (LASADR)
       IF LASADR<(3*3401) THEN CNTBAS_ 0 ELSE &
       CNTBAS_((LASADR/3)/3401)*20
!***** CNTBAS_((LASADR/3)/3401)*20


       SWAPIN(NMPAGE,7); QNAME_OCT 34000; BNAME_QNAME+(4*MXQUES)
       SWAPIN(QCBPAGE,6); QCBS_OCT 30000
       LIB_OCT 24000

!
!------------------------------------------START COMMAND MODE---!

       ARM(ESCAPE)
       \BRS 114
CMND:  MFLG_0    !RESET MARGINAL TABLE FLAG!

       BOUT(CARRET)
       BI(BOUT($T),BOUT($V)); BOUT($>)
       READ(@TEL)
       SCAN

       DO TYPE+1 OF NOTYPES
               1:3:4:5:7:8:9:10: GO SYNERR
               2:             GO DSPTCH
               6:  GO CMND
       END


DSPTCH: I_0

DSP0:  IF SHORT(ORDR(I)) THEN GO DSP1
       IF INC I< NORDRS THEN GO DSP0
       IF SHORT("SOS")  THEN GO SOS

       GO SYNERR     !NOT A VALID COMMAND!

DSP1:  DO I+1 OF NORDRS
               1: GO FILTER
               2: GO WEIGHT
               3: GO CROSS
               4: GO MARG
               5: GO PROCS
               6: GO SOS
               7:  GO QUIT

       END


!
!------------------------------------------------FILTER---!

FILTER: SCAN
       DO TYPE+1 OF NOTYPES
               1:4:5:7:9:10: GO SYNERR
               3:8:     I_VALUE; GO FL1
               6:       DISPLAY(BI("NUMBER (OR NAME): ", &
                         "NOM (OU NUMERO): "),0,0)
                        READ(@TEL)
                        GO FILTER
               2:       I_0
                  FN:   K_I*4
                        IF EQUAL(@TOKEN,@BNAME(K)) THEN [INC I; GO FL1]
                        IF INC I< NFILTS THEN GO FN
                        J_LENGTH(@TOKEN); LEFT(BI("NONE","AUCUNE"),MAX(3,J),@TSTR)
                        IF EQUAL(@TOKEN,@TSTR) THEN [I_0; GO FL1]
                        GO BADTOK    !INVALID QUESTION NAME!
       END

FL1:   IF I>NFILTS OR I<0 THEN GO BADTOK
       CURBAS_I
       GO CMND


!
!-------------------------------------------------WEIGHT---!

WEIGHT: SCAN
       DO TYPE+1 OF NOTYPES
               1:5:4:8:9:10: GO SYNERR
               3:7:     I_VALUE; GO WL1
               6:       DISPLAY(BI("NAME (OR NUMBER): ", &
                         "NOM (OU NUMERO): "),0,0)
                        READ(@TEL)
                        GO WEIGHT

               2:       I_0
                  WL:   K_I*4
                        IF EQUAL(@TOKEN,@QNAME(K)) THEN [INC I;GO WL1]
                        IF INC I< NQUES THEN GO WL
                        J_LENGTH(@TOKEN); LEFT(BI("NONE","AUCUNE"),MAX(3,J),@TSTR)
                        IF EQUAL(@TOKEN,@TSTR) THEN [I_0; GO WL1]
                        GO BADTOK
       END

WL1:   IF I<0 OR I>NQUES THEN GO BADTOK
       IF I THEN DO
               QCB_@QQCBS(I,0)
               CURWGHT_[12,12]*[I,QCB(1)]   !QPTR OF WEIGHT QUESTION
       END ELSE CURWGHT_I
!*****

       BIAS_1
!WL2:   DISPLAY("BIAS: ",0,0)
!      READ(@TEL)
!      SCAN
!      BOUT(CARRET)

!      IF TYPE # NUMTYPE THEN [DISPLAY("SYNTAX ERROR",1,0); GO WL2]
!
!      I _VALUE
!
!      IF I<0 THEN [DISPLAY("NUMBER MUST BE POSITIVE",1,0); GO WL2]
!
!      BIAS _ I
!*****
       GO CMND


!----------------------------------------------------SOS---!

SOS: DISPLAY(BI("VALID COMMANDS ARE:","LES ORDRES VALABLES SONT:"),1,1)
       I_0
S1:    DISPLAY(ORDR(I),1,0)
       IF INC I<= NORDRS-1 THEN GO S1
       BOUT(CARRET)
       GO CMND


!
!---------------------------------------------------CROSS---!


!GET QUESTIONS FOR TABLE!

CROSS:  IF TCNT=20 THEN DO
CS1: BCLOS;  DISPLAY(BI("MAXIMUM OF 20 TABLES","MAXIMUM DE 20 TABLEAUX"),1,0)
               \BRS 11(,,-1)
               BERX
             GO CMND
       END
       MF.NM.FG_1   !  MARGINAL CALLING PARM. BY NAME GOES HERE
        J_1
CR1:   IF J=2 AND MFLG THEN [I_0;GO CR3] !MARGINAL TABLE!

CR0:   IF NOT MFLG THEN SCAN  ! SCANNER CALLED ALREADY IF MFLAG
       DO TYPE+1 OF NOTYPES
               1:8:9:10:  GO SYNERR
               4:5: IF J=1 THEN GO SYNERR
                    IF EQUAL(",",@TOKEN) OR EQUAL("*",@TOKEN)&
                    OR EQUAL(BI("BY","PAR"),@TOKEN) THEN GO CR0
                     GO SYNERR
               3:7:     I_VALUE; GO CR2
               6:       DISPLAY(LC(J),0,0)
                        READ(@TEL)
                        GO CR0
               2:       I_0
                  CL:   K_I*4
                        IF EQUAL(@TOKEN,@QNAME(K)) THEN [INC I;GO CR2]
                        IF INC I<NQUES THEN GO CL
                         GO BADTOK
       END

CR2:   IF I<=0 OR I> NQUES THEN  GO BADTOK

CR3:   QUES(J)_I

       IF INC J<=2 THEN GO CR1

       SCAN
       IF TYPE#5 THEN  GO SYNERR
       \BRS 113
       INC TCNT; TPOS_TCNT-1
       TTCB(2)_QUES(1); TTCB(3)_QUES(2)
       GO B75


!
!------------------------------------------------MARGINAL---!

MARG:  MFLG_1; J_1
       SCAN
       IF TYPE=EOLTYPE THEN DO
               PROMPT(BI("LIST OF QUESTIONS: ","LISTE DES QUESTIONS:"))
               GO MARG
       END
       IF TYPE#NUMTYPE AND TYPE#QSTYPE THEN GO CROSS
       TYPE_NUMTYPE
               GETLIST(@ERR,1,NQUES)
       IF ERR THEN GO SYNERR
       MF.NM.FG_0  ! MEANS CALLED BY LIST AND NOT BY NAME

MG1:   I_NXTITEM
       IF I=ENDLIST THEN GO CMND
       IF TCNT=20 THEN GO CS1
       J _ 1
       GO CR2
!

!----------------------------------------SET UP TCB AND TABLE BLOCK---!

B75:   TTCB(0)_CURBAS
       TTCB(1)_CURWGHT
!*****

       TTCB(16) _ BIAS
!*****
       SIZE_1

       J_1
!GET QUESTION INFORMATION FROM DICTIONNARY!

B200:  QCB_@QQCBS(QUES(J),0)

!TEST IF QUESTION UNDEFINED!

       IF QCB(2)=0 THEN [DEC TCNT; \BRS 114; &
                         STRNG(QUES(J),@TOKEN); GO BADTOK]

       TTCB(J+5)_BYT(QCB(0),5,0) ! VSIZE
       TTCB(J+11)_QCB(1)  ! QPTR

!TEST IF QUESTION A COPY!

B202:  K_QCB(2)
       IF K<0 THEN DO
               QCB_@QQCBS(-K,0)
               IF QCB(2) =0 THEN DO
                               BCLOS
                               DISPLAY("QUESTION ",1,0); OUTNO(-K)
                               DISPLAY(BI(" UNDEFINED"," NON-DEFINIE"),0,1); DEC TCNT
                               BERX
                               GO CMND
               END
               GO B202
       END

       K_TTCB(J+3)_BYT(QCB(0),1,23)+1
       NCODES(J)_QCB(2)
       CPLPNT(J)_TTCB(J+17)_QCB(3)
       IF K=2 THEN DO  ! GET MIN CODE FROM DICTIONNARY
               \SCP (DIC,QCB(3),GO BADDIC)
               \WIO (DIC); \CAB
               \STB (TTCB(J+9))        
       END

       K_TTCB(J+13)_NCODES(J)+AUX(J)
       SIZE_SIZE*K

!CHECK FOR MARGINAL!

       IF MFLG THEN DO
               SIZE_SIZE*AUX(2)
               TTCB(15)_AUX(2)
               L2_1; CF_2
               GO B210
       END

       IF INC J<= 2 THEN GO B200

       L2_2; CF_0

B210:  TTCB(17)_STRT3K     !TABLE POINTER!
       E3_END3K; S3_STRT3K+SIZE

!CHECK IF CODES ALREADY IN POOL!

       L_1
B220:  IF TCNT=1 THEN GO B214
       I_TCNT-1
B213:  J_1
B212:  IF QUES(L)=TCB((20*(J+1))+I-1) THEN DO
               TTCB(L+7)_TCB((20*(J+7))+I-1)
               CF_CF+L
               GO E220
       END

       IF INC J<=2 THEN GO B212
       IF DEC I>0 THEN GO B213

B214:  SIZE_SIZE+NCODES(L)  !CODES OF QUES(L) NOT ALREADY IN POOL!
       TTCB(L+7)_E3-NCODES(L)
       E3_E3-NCODES(L)

E220:  IF INC L<=L2 THEN GO B220

       !CHECK IF STILL ROOM LEFT FOR TABLE!

       IF SIZLFT-SIZE<0 THEN DO
         DISPLAY(BI("THER IS NOT ENOUGH ROOM LEFT FOR THIS TABLE", &
          "IL NE RESTE PAS ASSEZ DE PLACE POUR CE TABLEAU."),1,1)
DISPLAY(BI("DEFINE A SMALLER TABLE, OR GIVE THE COMMAND 'RUN'.", &
  "DEFINIR UN TABLEAU PLUS PETIT OU DONNER L'ORDRE 'TRAITER'"),0,1)
       TCNT_TCNT-1
       \BRS 114
       GO CMND
       END

!ALL OK-SET FINAL POINTERS TO TOP AND BOTTOM OF TABLE BLOCK!

       SIZLFT_SIZLFT-SIZE
       STRT3K_S3
       END3K_E3

       DISPLAY(BI("TABLE ","TABLEAUX "),0,0)
       OUTNO(TCNT+CNTBAS)
       BOUT(CARRET)

!WRITE CODES (IF NECESSARY ) IN POOL!

       IF CF=0 THEN DO
               I_1
               J_2
       END ELSE IF CF=1 THEN DO
               I_2
               J_2
       END ELSE IF CF=2 THEN DO
               I_1
               J_1
       END ELSE GO B275

       L_I
B260:  K_CPLPNT(L)
       \LDA (K); \SCP (DIC,GO BADDIC)
       IF TTCB(3+L)=2 THEN DO
               \WIO (DIC); \STA (M1)
               TTCB(9+L)_M1   !   GET MINIMUM OF SLICE IN TCB
               \BIO (DIC,NCODES(L),,@TBL(TTCB(L+7)),GO BADDIC)
       END ELSE DO
               \BIO (DIC,NCODES(L)*9,,LIB, GO BADDIC)
               M1_1; M2_TTCB(L+7) !POOL POINTER
       LOP1:   TBL(M2)_LLIB(M1,0); INC M2
               IF INC M1<=NCODES(L) THEN GO LOP1
       END
               IF INC L<=J THEN GO B260  !SEE IF OTHER QUESTION AND REDO


B275:  \BRS 114
       IF MFLG AND NOT MF.NM.FG  THEN GO MG1  !ONLY IF LIST WAS USED
       GO CMND


!--------------------------------------------SPACE LEFT-------!

PLACE: BOUT(CARRET)
       OUTNO(SIZLFT)
       BOUT(CARRET)
       GO CMND

!-----------------------------------------------PROCESS---!

PROCS: IF TCNT=0 THEN DO
               DISPLAY(BI("NO TABLES HAVE BEEN REQUESTED", &
                "AUCUN TABLEAU DEMANDE"),1,1)
               GO CMND
       END
       SCAN
       IF TYPE=2 THEN DO
               TCTR_VALUE
       END ELSE IF TYPE=5 THEN DO
               TCTR_8000000
       END ELSE GO SYNERR
       \BRS 113
       \BRS 43; \STP(RL1); \BRS 121(BYT(RL2,6,12))
       STRTAB



!--------------------------------------------------QUIT---!

QUIT:  IF TCNT = 0 THEN [RELLIB;\BRS 113; EXIT]
       DISPLAY(BI("WITHOUT PROCESSING? ","SANS TRAITEMENT?"),0,0)
       READ(@TEL)
       I_YESNO
       IF I THEN [RELLIB;\BRS 113;EXIT] ELSE GO CMND


!------------------------------------------------ESCAPE ROUTINE--!

ESCAPE: ARM(ESCAPE)
       BUFF(0)_NEWBUF(0)_-1
       \BRS 11 (,,-1); \BRS 29
       BOUT(CARRET); GO CMND


!-----------------------------------------------ERROR IN DICTIONNARY--!

BADDIC: BCLOS; DISPLAY(BI("ERROR IN DICTIONARY FILE", &
                 "ERREUR DANS FICHIER DICTIONNAIRE"),1,1)
               DISPLAY(BI("ABORTED","ANNULE"),0,1)
               BERX
              EXIT


!----------------------------------------------ERROR IN INTER FILE---!

BADINT: BCLOS;  DISPLAY(BI("ERROR IN INTERMEDIARY FILE", &
         "ERREUR DANS FICHIER INTERMEDIAIRE"),1,1)
         DISPLAY(BI("ABORTED","ANNULE"),0,1)
        BERX
        EXIT

!--------------------------------------UNDEFINED QUESTION OR FILTER---!

BADTOK: BCLOS;  DISPLAY(@TOKEN,0,0)
        DISPLAY(BI("UNDEFINED"," NON DEFINI"),0,1)
        GO B275


SYNERR: BCLOS; DISPLAY(BI("ERROR IN SYNTAX","ERREUR DE SYNTAXE"),0,1)
       BERX
       GO CMND

COMERR: BCLOS; DISPLAY(BI("ERROR IN FILE /**COM**/","ERREUR FICHIER /**COM**/"),1,1)
       DISPLAY(BI("ABORTED","ANNULE"),0,1)
       BERX
       EXIT



!------------------------------------------YES/NO ROUTINE---!

%YESNO
       LOCAL J,I
GT1:   SCAN
       DO TYPE+1 OF NOTYPES
              1:3:4:5:6:7:8:9:10: GO QUOI
               2:             GO QUEL
       END

QUEL:  J_LENGTH(@TOKEN); LEFT(BI("YES","OUI"),J,@TSTR)
       IF EQUAL(@TSTR,@TOKEN) THEN DO
               I_1
       END ELSE DO
               LEFT(BI("NO","NON"),J,@TSTR)
               IF EQUAL(@TSTR,@TOKEN) THEN I_0 ELSE GO QUOI
       END

       SCAN; IF TYPE#5 THEN GO QUOI
       RETURN I
QUOI:  DISPLAY(BI("YES OR NO? ","OUI OU NON? "),0,0)
       \BRS 11 (,,-1)
       READ(@TEL)
       GO GT1
  END YESNO
%RELLIB
       \BRS 43; \STA(RL1); \STB (RL2)
       \BRS 121(BYT(RL1,6,0))
       \BRS 121(BYT(RL2,6,18))
       \BRS 121(BYT(RL2,6,12))
       RETURN
END RELLIB

%SHORT(@A)

       LEFT(@A,LENGTH(@TOKEN),@TSTR)
       IF EQUAL(@TOKEN,@TSTR) THEN RETURN 1
       RETURN 0
END SHORT
SURVEY ** FICHE/FRAME BREAK *****
/CPAVTCOM:SIMP/ SYMSORT

SYM.  PG.LN. IDENT.

!       6 28 !!!     !       6 26 !!!     !       6 25 !!!     !       6 24 !!!     
!       3 31 !!!     !       1  3 !!!     !       1  2 !!!     !!!!!E  3 25 !!!     
!!!!!E  1 27 !!!     !*****  8 31 !!!     !*****  8 30 !!!     !*****  6 32 !!!     
!*****  6 22 !!!     !*****  4 10 !!!     !*****  4  1 !!!     !*****  3 39 !!!     
!*****  3  2 !!!     !ALL   11  5 !!!     !CHECK 10 11 !!!     !CHECK  9 34 !!!     
!DEF    1 37 !!!     !GET    8 34 !!!     !M!     6 31 !!!     !M!     6 30 !!!     
!M!     6 29 !!!     !M!     1  4 !!!     !MMDEF  1  5 !!!     !TEST   9  7 !!!     
!TEST   8 38 !!!     !WL2:   6 23 !!!     !WRITE 11 15 !!!     %RELLI 14 30 !!!     
%YESNO 14  8 !!!     B200:   8 36 !!!     B202:   9  9 !!!     
B210:  10  8 !!!     B212:  10 17 !!!     B213:  10 16 !!!     B214:  10 26 !!!     
B220:  10 14 !!!     B260:  11 29 !!!     B275:  12  5 !!!     B75:    8 28 !!!     
BADDIC 13 12 !!!     BADINT 13 21 !!!     BADTOK 13 29 !!!     CMND:   4 21 !!!     
COMERR 13 38 !!!     CR0:    7 16 !!!     CR1:    7 14 !!!     CR2:    7 34 !!!     
CR3:    7 36 !!!     CROSS:  7  6 !!!     CS1:    7  7 !!!     DEF     3 10 !!!     
DEF     3  9 !!!     DEF     3  8 !!!     DEF     2 18 !!!     DEF     2 17 !!!     
DEF     2 12 !!!     DEF     2 11 !!!     DEF     2 10 !!!     DEF     2  9 !!!     
DEF     2  8 !!!     DEF     2  7 !!!     DEF     2  6 !!!     DEF     2  5 !!!     
DEF     2  4 !!!     DEF     2  3 !!!     DEF     1 39 !!!     DEF     1 38 !!!     
DEF     1 33 !!!     DEF     1 16 !!!     DSP0:   4 37 !!!     DSP1:   5  4 !!!     
DSPTCH  4 35 !!!     E220:  10 30 !!!     END    15  1 !!!     END    14 35 !!!     
ENDM    2  2 !!!     ENDM    1 36 !!!     ESCAPE 13  4 !!!     FIND    3 22 !!!     
FIND    3 21 !!!     FIND    3 20 !!!     FIND    3 19 !!!     FIND    3 18 !!!     
FIND    3 17 !!!     FIND    3  7 !!!     FIND    3  6 !!!     FIND    2 20 !!!     
FIND    2 19 !!!     FIND    2 16 !!!     FIND    1 32 !!!     FIND    1 31 !!!     
FIND    1 24 !!!     FIND    1 23 !!!     FIND    1 22 !!!     FIND    1 21 !!!     
FIND    1 20 !!!     FIND    1 19 !!!     FIND    1 18 !!!     FIND    1 17 !!!     
FIND    1 15 !!!     FIND    1 14 !!!     FL1:    5 33 !!!     GLOBAL  2 39 !!!     
GLOBAL  2 38 !!!     GLOBAL  2 37 !!!     GLOBAL  2 36 !!!     GLOBAL  2 35 !!!     
GLOBAL  2 31 !!!     GT1:   14  9 !!!     K!!!!B  1 11 !!!     LOCAL   3  1 !!!     
LOCAL   2 27 !!!     LOCAL   2 26 !!!     MG1:    8 21 !!!     MSHORT 14 37 !!!     
O!!!!!  1 12 !!!     O!!!!S  2 14 !!!     OISPLA 10 37 !!!     PG1:    4  7 !!!     
PLACE: 12 12 !!!     PROG:   3 30 !!!     QUEL:  14 15 !!!     QUOI:  14 25 !!!     
S1:     6 37 !!!     SYNERR 13 34 !!!     TABLE   2 25 !!!     TABLE   2 21 !!!     
VERSIO  1  9 !!!     WL1:    6 17 !!!     \BRS    2  1 !!!     _!!!!E  3 15 !!!     
_!!!!L  2 30 !!!     _!!!!S  3 13 !!!     _!!!!V  2 34 !!!     _*****  3  4 !!!     
_----- 14  6 !!!     _----- 13 27 !!!     _----- 13 19 !!!     _----- 13 10 !!!     
_----- 13  2 !!!     _----- 12 34 !!!     _----- 12 17 !!!     _----- 12 10 !!!     
_-----  6 35 !!!     _LM!--  8  9 !!!     _LM!--  7  4 !!!     _LM!--  5 38 !!!     
_LM!--  5 16 !!!     _LM!--  4 17 !!!     _LM!--  3 28 !!!     _LMM!-  8 26 !!!     

SURVEY ** FICHE/FRAME BREAK *****
/CTCOMMON:SRCE/
CTCOMMON IDENT
$CNTBAS DATA 0
LASADR EXT
LASADR DATA 0
TCNT EXT
TCNT DATA 0
TCB EXT
TCB EQU *-0
 RPT 1+399-0
 DATA 0
 ENDR
TBL EXT
TBL EQU *-1
 RPT 1+3000-1
 DATA 0
 ENDR
X1 EQU 40000000B
*LINE  3
*LINE  4
*LINE  0

 END
SURVEY ** FICHE/FRAME BREAK *****
/CTCOMMON:SRCE/ SYMSORT

SYM.  PG.LN. IDENT.

CNTBAS  1  2 CTCOMMONLASADR  1  4 CTCOMMONLASADR  1  3 CTCOMMON
TBL     1 13 CTCOMMONTBL     1 12 CTCOMMONTCB     1  8 CTCOMMONTCB     1  7 CTCOMMON
TCNT    1  6 CTCOMMONTCNT    1  5 CTCOMMONX1      1 17 CTCOMMON
SURVEY ** FICHE/FRAME BREAK *****
/LOADER:SRCE/
LOADER IDENT
 LIST

*   COMMAND MODULE LOADER ROUTINE

$STRFRK  ZRO 0; BRS 9; BRR STRFRK
$STRFR1  ZRO 0; BRS 9; BRR STRFR1
$FORKTB BSS 7
LDFILE  DATA 3
SA BSS 1
SB BSS 1
SVRL BSS 2

$LOADER ZRO 0
       STX LDFILE   (GO FILE NUMBER)
       STA SA (STARTING ADDRESS ADDRESS)
       STB SB (RELABELING WORD ADRESS)
       BRS 43; STP SVRL; ETR =77B6; CLB; BRS 44 (RELABEL OUT CALLING)
       WIO LDFILE; STA STAD; WIO LDFILE; STA NDAD; WIO LDFILE
       STA* SA (STARTING ADDRESS)
       LDA NDAD; SUB STAD; ADD =1; LDX STAD; BIO LDFILE
       LDA NDAD; SKG =33777B; BRU SHORT
       BRS 43; STP* SB
RET    LDP SVRL; BRS 44; BRR LOADER

SHORT BRS 43; RSH 6; LSH 6; STP* SB; BRU RET

STAD  BSS 1
NDAD  BSS 1

       END
SURVEY ** FICHE/FRAME BREAK *****
/LOADER:SRCE/ SYMSORT

SYM.  PG.LN. IDENT.

FORKTB  1  8 LOADER  LDFILE  1  9 LOADER  LOADER  1 14 LOADER  
NDAD    1 29 LOADER  RET     1 24 LOADER  SA      1 10 LOADER  SB      1 11 LOADER  
SHORT   1 26 LOADER  STAD    1 28 LOADER  STRFR1  1  7 LOADER  STRFRK  1  6 LOADER  
SVRL    1 12 LOADER  
SURVEY ** FICHE/FRAME BREAK *****
/MATHFUNC:SRCE/
MATH IDENT
*********************MATH FUNCTIONS FOR SIMPL PROGRAMS********************


TEMP BSS 1
TEMP1 BSS 1



*LOAD REGISTER MACROS********************


LDR MACRO D
       LDA D(1); LDB D(1)+1
       ENDM
STR    MACRO D
       STA D(1); STB D(1)+1
       ENDM
********************
*CALLED BY SQRT(@X,@Y,PREC) WHERE X,Y ARE TWO WORDS FLOATING VARIABLES
*  AND PREC IS A POSITIVE INTEGER CONTROLLING THE ITERATION LOOP
*  3 GIVES 10 E-4 PRECISION WITH 1.9  MS/SQRT
*  7 GIVES 10E-11 WITH 4.0 MS/SQRT
********************
*
AY     BSS 1 ADRESS OF Y
X      BSS 2
Y      BSS 2
T      BSS 2
K      BSS 1
MONE   DATA 4B7,0
PPREC  BSS 1  PRECISION CONTROL
*
*
*




$FLOAT ZRO 0
       CBX; BRS 51; STP 0,2; BRR FLOAT


$FDIV ZRO 0
       STX TEMP   (QUOTIENT ADDRESS); STB TEMP1 (DIVISOR)
       CAX (DIVIDEND); LDP 0,2; FDV* TEMP1; STP* TEMP; BRR FDIV

$FMUL ZRO 0
       STX TEMP; STB TEMP1; CAX; LDP 0,2; FMP* TEMP1
       STP* TEMP; BRR FMUL

$FADIT  ZRO 0
       STX TEMP; STB TEMP1; CAX; LDP 0,2; FAD* TEMP1
       STP* TEMP; BRR FADIT

$FSUB  ZRO 0
       STX TEMP; STB TEMP1; CAX; LDP 0,2; FSB* TEMP1
       STP* TEMP; BRR FSUB
$SQRT  ZRO   0
       STB AY
       CAX
       LDA  0,2 ; LDB 1,2
       STX     SQX
       SKA     =-1
       BRU     CONT
       LDX     SQX
       STP* AY
       BRR  SQRT           EXIT IF ZERO ARG
CONT   STA     LIB1
       STB     LIB2
ARGPOS XAB
       LCY     4
       ETR     =23B
       STA     LIB6
       CAX
       LDA     LIB1
       MUL     C3,2            PERFORM CUBIC FIT
       ADD     C2,2
       MUL     LIB1
       ADD     C1,2
       MUL     LIB1
       ADD     C0,2
       STA     LIB4            LIB4=ROOT
       LDA     LIB2
       ETR     =777B
       SKA     =400B
       MRG     =1000B
       ADD     =1
       RSH     1
       STA     LIB6
       STB     LIB5
       LDA     LIB1
       LDB     LIB2
       SKN     LIB5
       RSH     1
       RSH     2
       DIV     LIB4            AH,AL/ROOT
       STA     LIB3
       BAC
       DIV     LIB4            REMAINDER/ROOT
       LCY     1
       ETR     =77777000B
       MRG     LIB6            INSERT EXPONENT
       XAB
       ETR     =1
       SKA     =1              TEST NEG
       MRG     =-1
       ADD     LIB4
       ADD     LIB3
       LDX     SQX
       STP* AY
       BRR  SQRT

ERM    TEXT    'NEGATIVE ARGUMENT TO SQUARE ROOT. ABSOLUTE VALUE USED./'


       OCT
C0     DATA    03571347,04105632,04377337,04653532
C1     DATA    24035556,22100301,20524702,17404074
C2     DATA    64040313,67137522,71114033,72364432
C3     DATA    04201570,02442454,01540204,01133522
       DATA    02511007,02731406,03134614,03326443
       DATA    16135622,14642160,13621520,12756406
       DATA    67436343,71611227,73117403,74060542
       DATA    03003710,01641433,01143077,00652664

LIB1   BSS     1
LIB2   BSS     1
LIB3   BSS     1
LIB4   BSS     1
LIB5   BSS     1
LIB6   BSS     1
SQX    BSS     1
       END
SURVEY ** FICHE/FRAME BREAK *****
/MATHFUNC:SRCE/ SYMSORT

SYM.  PG.LN. IDENT.

ARGPOS  2 32 MATH    AY      1 26 MATH    C0      4  1 MATH    
C1      4  2 MATH    C2      4  3 MATH    C3      4  4 MATH    CONT    2 30 MATH    
ERM     3 36 MATH    FADIT   2 13 MATH    FDIV    2  5 MATH    FLOAT   2  1 MATH    
FMUL    2  9 MATH    FSUB    2 17 MATH    K       1 30 MATH    LDR     1 13 MATH    
LIB1    4 10 MATH    LIB2    4 11 MATH    LIB3    4 12 MATH    LIB4    4 13 MATH    
LIB5    4 14 MATH    LIB6    4 15 MATH    MONE    1 31 MATH    PPREC   1 32 MATH    
SQRT    2 20 MATH    SQX     4 16 MATH    STR     1 16 MATH    T       1 29 MATH    
TEMP    1  5 MATH    TEMP1   1  6 MATH    X       1 27 MATH    Y       1 28 MATH    

SURVEY ** FICHE/FRAME BREAK *****
/STRFUNC:SIMP/
!-------------------STRING FUNCTIONS FOR SIMPL PROGRAMS--------------!

GLOBAL %VAL
GLOBAL %ADDSTR
GLOBAL %NULSTR
GLOBAL %LEFT
GLOBAL %STRNG
GLOBAL %GTPT
GLOBAL %DISPLAY
GLOBAL %ACCEPT
GLOBAL %EQUAL
GLOBAL %LENGTH
GLOBAL %INCHV
GLOBAL %TRNSTR
GLOBAL %SUBSTR
GLOBAL %INDEX

FIND CFLNO




!------------------------------------!

%ADDSTR(STR1,STR2,STR3)

       LOCAL P1,P2,P3,CAR
     P1_CHPT(STR1,-1); P2_CHPT(STR3,-1)
S:     CAR_INCHV(@P1)
       IF CAR>= OCT 200 THEN GO A
       NCHV(P2)_CAR
       GO S

A:     P3_CHPT(STR2,-1)
A1:    NCHV(P2)_INCHV(@P3)
       IF CHV(P2)>= OCT 200 THEN RETURN
       GO A1
END ADDSTR

!------------------------------------!

%DISPLAY(WPT,M,N)

       LOCAL PNT,J

!  DO NOT OUTPUT IF BEING RUN FROM COMMAND FILE

! DONT SUPPRESS OUTPUT IF CMD FILE AS PER CROSSLEY INSTR
!*     IF CFLNO THEN RETURN

       REPEAT M TTY_CARRET
       PNT_CHPT(WPT,-1)
C0:    J_INCHV(@PNT)
       IF J>= OCT 200 THEN  GO DFIN
               TTY_J


       GO C0
DFIN:  REPEAT N TTY_CARRET
       RETURN
END DISPLAY

!------------------------------------!

%LENGTH(STR)
       LOCAL PNT,LEN,J
       LEN_0
       PNT_CHPT(STR,-1)
L:     J_INCHV(@PNT)
       IF J>= OCT 200 THEN RETURN LEN
       LEN_LEN+1
       GO L
END LENGTH

!------------------------------------!

%NULSTR(STR)

       LOCAL J
       IF CH(STR)>= OCT 200 THEN J_1 ELSE J_0
       RETURN J
END NULSTR

!------------------------------------!

%ACCEPT(STR)

       LOCAL CAR,PNT
C0:    PNT_CHPT(STR,-1)
C1:    CAR_TTY
       IF CAR=CARRET THEN GO EO
       IF CAR=OCT 141 THEN DO
               TTY_$_
               DEC PNT
               GO C1
       END
       IF CAR=OCT 161 THEN DO
               TTY_$^
               TTY_CARRET
               GO C0
       END
       NCHV(PNT)_CAR
       GO C1
EO:    NCHV(PNT)_EOLIT
       RETURN
END ACCEPT

!------------------------------------!

%GTPT(STR,@PNT1,@PNT2)

       LOCAL J,CAR
       PNT1_CHPT(STR,-1)
       J_PNT1
G:     CAR_INCHV(@J)
       IF CAR>= OCT 200 THEN DO
               PNT2_DEC J
               RETURN
       END

       GO G
END GTPT

!------------------------------------!

%STRNG(NUM,STR)

       LOCAL PT1,PT2,STR2(0:25),N1,N2,CAR

       PT2_CHPT(STR2,10); PT1_CHPT(STR,-1)
       CHV(PT2)_EOLIT
       N1_NUM
S:     [N1;N2]_N1 DIVMOD 10
       N2_N2+$0
       PCHV(PT2)_N2
       IF N1 THEN GO S

       DEC PT2
S1:    CAR_INCHV(@PT2)
       NCHV(PT1)_CAR
       IF CAR = EOLIT THEN RETURN
       GO S1
END STRNG

!------------------------------------!

%LEFT(STR1,NUM,STR2)

       LOCAL I,PT1,PT2,CAR

       I_1
       PT1_CHPT(STR1,-1)
       PT2_CHPT(STR2,-1)
L:     CAR_INCHV(@PT1)
       NCHV(PT2)_CAR
       IF INC I<=NUM THEN GO L
       NCHV(PT2)_EOLIT
       RETURN
END LEFT

!-----------------------------------!

%TRNSTR(STR1,STR2)

       LOCAL CAR,PT1,PT2

       PT1_CHPT(STR1,-1); PT2_CHPT(STR2,-1)
T:     CAR_INCHV(@PT1)
       NCHV(PT2)_CAR
       IF CAR>= OCT 200 THEN RETURN
       GO T
END TRNSTR

!------------------------------------!

%EQUAL(STR1,STR2)

       LOCAL J1,J2,K1,K2

       J1_CHPT(STR1,-1)
       J2_CHPT(STR2,-1)

A:     K1_INCHV(@J1);K2_INCHV(@J2)
       IF K1>=OCT 200 AND K2>=OCT 200 THEN RETURN 1
       IF K1#K2 THEN RETURN 0
       GO A

END EQUAL
!--VAL (CH.POS) EVALUATES A NON-NEGATIVE INTEGER FROM A STRING STARTING
! WITH A DIGIT AND ENDING WITH EOLIT. ONLY NUMERIC DIGITS MAY BE PRESENT
! NON-NUMERIC STRINGS RETURN -1.

%VAL(CH.POS)

       LOCAL V,K1
       WHILE (K1_CHV(CH.POS))=0 THEN INC CH.POS
       IF K1<$0 OR K1>$9 THEN RETURN -1
       V_K1-$0

       VAL1:  K1_INCHV(@CH.POS)
              IF K1 =EOLIT THEN RETURN V
              IF K1<$0 OR K1>$9 THEN RETURN -1
              V_V*10+K1-$0
      GO VAL1
END VAL

%SUBSTR(STR1,STRT,NUM,STR2)

       LOCAL I,PT1,PT2,CAR

       I_1
       PT1_CHPT(STR1,STRT-2)
       PT2_CHPT(STR2,-1)
SL:    CAR_INCHV(@PT1)
       NCHV(PT2)_CAR
       IF INC I<=NUM THEN GO SL
       NCHV(PT2)_EOLIT
       RETURN
END SUBSTR
%INCHV(@X)

RETURN NCHV(X)
END INCHV


%INDEX(@STRING,@SEARCH,BEG)
DISPLAY("INDEX FUNCTION NOT IMPLEMENTED",1,1)
RETURN
END INDEX
SURVEY ** FICHE/FRAME BREAK *****
/STRFUNC:SIMP/ SYMSORT

SYM.  PG.LN. IDENT.

!       4 35 _-------!       4 34 _-------!       2  1 _-------!       1 38 _-------
!*      2  2 _-------!--VAL  4 33 _-------A1:     1 31 _-------
A:      4 27 _-------A:      1 30 _-------C0:     2 31 _-------C0:     2  6 _-------
C1:     2 32 _-------DFIN:   2 12 _-------END     5 22 _-------END     5 20 _-------
END     5  8 _-------END     4 32 _-------END     4 20 _-------END     4 11 _-------
END     3 38 _-------END     3 21 _-------END     3  9 _-------END     2 28 _-------
END     2 23 _-------END     2 14 _-------END     1 34 _-------EO:     3  7 _-------
FIND    1 18 _-------G:      3 14 _-------GLOBAL  1 16 _-------GLOBAL  1 15 _-------
GLOBAL  1 14 _-------GLOBAL  1 13 _-------GLOBAL  1 12 _-------GLOBAL  1 11 _-------
GLOBAL  1 10 _-------GLOBAL  1  9 _-------GLOBAL  1  8 _-------GLOBAL  1  7 _-------
GLOBAL  1  6 _-------GLOBAL  1  5 _-------GLOBAL  1  4 _-------GLOBAL  1  3 _-------
L:      4  6 _-------L:      2 19 _-------S1:     3 34 _-------S:      3 28 _-------
S:      1 25 _-------SL:     5 15 _-------T:      4 16 _-------^ETURN  5 26 _-------
_-----  4 22 _-------_-----  4 13 _-------_-----  4  1 _-------_-----  3 23 _-------
_-----  3 11 _-------_-----  2 30 _-------_-----  2 25 _-------_-----  2 16 _-------
_-----  1 36 _-------_-----  1 23 _-------_INCHV  5 21 _-------_INDEX  5 25 _-------
_SUBST  5 10 _-------_VAL(C  4 37 _-------
SURVEY ** FICHE/FRAME BREAK *****
/STRTABU:SRCE/
STRTAB IDENT

$STRTAB ZRO 0
       BRS 43; XAB; ETR =77B6; XAB; ETR =77B; ADD TABRL1; BRS 44
       BRU* TABUST

       END
SURVEY ** FICHE/FRAME BREAK *****
/STRTABU:SRCE/ SYMSORT

SYM.  PG.LN. IDENT.

STRTAB  1  3 STRTAB  
SURVEY ** FICHE/FRAME BREAK *****
CCOMCOM
RES
XDD
0;TCPAVGLOBAL
202;TIOFUNC
;TCPAVGLOB
;TSTRFUNC
;TLOADER
;TSCAN
;TSTRTABU
4000;TEDIT
;TLIST
;TCCOM
;U
WIO;KBIO;K0\4
3;A1;XBRS 63D;USURVEY


0;AWIO 0;U;F;AWIO 0;USTART+40000000;AWIO 0;U
;F+1;A0;XBIO 0;U4;ABRS 20D;U
;CCCOMST

%F
COP SURVEY,XPAVOT

COM CPAVASM
SURVEY ** FICHE/FRAME BREAK *****
CGENCOM
RES
XDD
0;TCPAVGLOBAL
202;TIOFUNC
;TCPAVGLOB
;TSTRFUNC
;TLOADER
;TSCAN
0;TCGENB-'BUFFERS'
4000;TEDIT
;TLIST
;TCGENR
;TCGEN
;TCGENC
;U
;CCGENST

3;A
1;X
WIO;K
BRS 63D;U
CPAVGEN

4000;A
4\4
WIO 4;U
;F;A
WIO 4;U
PROG;A
WIO 4;U
4000;X
;F-4000+1;A
BIO;K
BIO 4;U
4;A
BRS 20D;U
%F
"
READY
"COM TEL
SURVEY ** FICHE/FRAME BREAK *****
CIMPCOM
RES
XDD
0;TCPAVGLOBAL
202;TIOFUNC
;TCPAVGLOB
;TSTRFUNC
;TLOADER
;TSCAN
22005;TCIMPG
%"LAST WORD OF AVAILABLE CORE IS 31266"
4000;TEDIT
;TLIST
;TMATHFUNC
;TCIMPS
;TCIMP
;TCIMP1
;TCIMP2
%"IF THE ABOVE ADDRESS IS >= 22005 WE ARE IN DEEP MERDE"
;U
22005;F

3;A
1;X
BRS 63D;U
CPAVIMP

4000;A
4\4
WIO 4;U
;F;A
WIO 4;U
PROG;A
WIO 4;U
4000;X
;F-4000+1;A
BIO 4;U
4;A
BRS 20D;U
%F
"
READY
"COM TEL
SURVEY ** FICHE/FRAME BREAK *****
CMAJCOM
RES
XDD
0;TCPAVGLOBAL
202;TIOFUNC
;TCPAVGLOB
;TSTRFUNC
;TLOADER
;TSCAN
4000;TEDIT
;TLIST
;TCMAJ
;TCMAJ1
;U
;CCMAJST

3;A
1;X
WIO;K
BRS 63D;U
CPAVMAJ

4000;A
4\4
WIO 4;U
;F;A
WIO 4;U
PROG;A
WIO 4;U
4000;X
;F-4000+1;A
BIO;K
BIO 4;U
4;A
BRS 20D;U
%F
"
READY
"COM TEL
SURVEY ** FICHE/FRAME BREAK *****
CPAVASM
COP XPAVOT,SURVEY

GO SAVE
SURVEY
CPAVMAJ
GO SAVE
SURVEY
CPAVTCOM
GO SAVE
SURVEY
CPAVTABU
GO SAVE
SURVEY
CPAVPRE
GO SAVE
SURVEY
CPAVIMP
GO SAVE
SURVEY
CPAVGEN
GO SAVE
SURVEY
CPAVSTAT
"
READY"
COM TEL
SURVEY ** FICHE/FRAME BREAK *****
CPRECOM
RES
XDD
0;TCPAVGLOBAL
202;TIOFUNC
;TCPAVGLOB
;TSTRFUNC
;TLOADER
;TSCAN
4000;TEDIT
;TCPRE1
;TCPRE
;U
WIO;KBIO;K4\4
3;A1;XBRS 63D;UCPAVPRE


4000;AWIO 4;U;F;AWIO 4;UPROG;AWIO 4;U4000;X;F-4000+1;A
BIO 4;U4;ABRS 20D;U
;CCPREST

%F
"READY"
COM TEL
SURVEY ** FICHE/FRAME BREAK *****
CSTATCOM
RES
XDD
0;TCPAVGLOBAL
202;TIOFUNC
;TCPAVGLOB
;TSTRFUNC
;TLOADER
;TSCAN
22005;TCIMPG
4000;TEDIT
;TCSTAT
;U
;CCSTATST

3;A
1;X
BRS 63D;U
CPAVSTAT

4000;A
4\4
WIO 4;U
;F;A
WIO 4;U
STPROG;A
WIO 4;U
4000;X
;F-4000+1;A
BIO 4;U
4;A
BRS 20D;U
%F
"
READY
"COM TEL
SURVEY ** FICHE/FRAME BREAK *****
CTABUCOM
RES
XDD
0;TCPAVGLOBAL
14000;TCTCOMMON
202;TIOFUNC
;TCPAVGLOB
;TSTRFUNC
;TLOADER
;TSCAN
;TSTRTABU
4000;TEDIT
;TMATHFUNC
;TCFIX


;TCTABU
%"THE ABOVE ADDRESS MUST BE LESS THAN 14000"
;U
;CCTABUST

3;A
1;X
WIO;K
BRS 63D;U
CPAVTABU

4000;A
4/4
WIO 4;U
;F;A
WIO 4;U
PROG;A
WIO 4;U
4000;X
;F-4000+1;A
BIO;K
BIO 4;U
4;A
BRS 20D;U
%F
"
READY
"COM TEL
SURVEY ** FICHE/FRAME BREAK *****
CTCOMCOM
RES
XDD
14000;TCTCOMMON
0;TCPAVGLOBAL
202;TIOFUNC
;TCPAVGLOB
;TSTRFUNC
;TLOADER
;TSCAN
;TSTRTABU
4000;TEDIT
;TMATHFUNC
;TCFIX
;TLIST

;TCTCOM
%"THE ABOVE ADDRESS MUST BE LESS THAN 14000"
;U
;CCTCOMST

3;A
1;X
WIO;K
BRS 63D;U
CPAVTCOM

4000;A
4/4
WIO 4;U
;F;A
WIO 4;U
PROG;A
WIO 4;U
4000;X
;F-4000+1;A
BIO;K
BIO 4;U
4;A
BRS 20D;U
%F
"
READY
"COM TEL
   7 