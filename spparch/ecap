ECAP ** FICHE/FRAME BREAK *****
ECAINLSYM
INLANG IDENT   VER.6 ECAP INPUT LANGUAGE    T.FLORYAN
*
*
RSP    OPD     125B5,1,1,0,1   READ SIZE PARAMETERS OF RANDOM FILE
STRING OPD     177B5,1         STRING ENTRY AND EDITING
TIM    OPD     176B5,1,1       APPENDS TIME TO A STRING
DAT    OPD     175B5,1,1       APPENDS DATE TO A STRING
BRK    OPD     174B5,1,1       BREAKS A STRING WITH COMMAS
SIC    OPD     173B5,1,1       STRING TO INTERNAL CONVERSION
PSTR   OPD     172B5,1,1       PRINTS STRING TO TEL
SND    OPD     171B5,1,1       ASCII TO TEL IF TEL IS COMMAND FILE
SNDA   OPD     170B5,1,1       ASCII TO TEL
PTX    OPD     167B5,1,1       TEXT TO TEL
MDE    OPD     166B5,1,1       MEMORY DECREMENT
MAX    OPD     165B5,2         INTEGER MAX
MOD    OPD     164B5,1,1       (A) MOD (LOCATION)
PUTB   OPD     163B5,2         PUTS A STRING IN TEXT BLOCK
CMPRS  OPD     162B5,1,1       COMPRESSES INPUT STRINGS
PCKT   OPD     161B5,1,1       PRINTS CIRCUIT TO A FILE (FORMAT)
RANGE  OPD     160B5,1,1       RETURNS TEXT BLOCK ADDRESS(ES)
STIA   OPD     157B5,1,1       STA INTO 1-DIM INTEGER ARRAY
LDIA   OPD     156B5,1,1       LDA FROM 1-DIM INTEGER ARRAY
STFA   OPD     155B5,1,1       STP INV INTO 1-DIM REAL ARRAY
LDFA   OPD     154B5,1,1       LDP INV FROM 1-DIM REAL ARRAY
STF    OPD     153B5,1,1       STP INV INTO FOS REAL NUMBER
LDF    OPD     152B5,1,1       LDP INV FROM FOS REAL NUMBER

$INLANG ZRO    RTN
       LDX     =POPTAB-POPTND
       LDA     200B,2
       LDB     POPTND,2
       STB     200B,2
       STA     POPTND,2
       BRX     *-4
       BRS 26; BRU TREARM; LDA =REARM; STA 201B
       LDA ESMASK; BRS 78; BRS 114; CIT ZERO
ESMASK NOP 0
REARM  ZRO RTN
TREARM BRS 114
       LDA ONES; STA PUTFLG
       LDA IFROM; SKE ONE; BRU ACLDC1; BRM REMFOS; LDA =2; STA MF
       LDA ONES; STA ESCOMP
SETTGO LDX NTR; BRU *,2
       BRU SETDCL
       BRU SETACL
       BRU SETTRL
ACLDC1 LDA OF; ETR =77B; SKG =2; BRU *+5; LDA =155B; CIO OF
       LDA =134B; CIO OF
       BRM REMFOS; BRM INITXB; BRM RDTIME; SKN ESCOMP; BRM PAUCMP
       LDA NTR; SKE =3; BRU SETL4; BRM CZERO; BRM INIVAR; BRU SETL4
SETTDC SKN XXXINS; BRU *+4; SKN LNGEDT; BRU HOOHAH; BRU EDBUBU
       LDA ONE; STA NTR; BRU ACLDC2
SETTAC SKN XXXINS; BRU *+4; SKN LNGEDT; BRU HOOHAH; BRU EDBUBU
       LDA =2; STA NTR; BRU ACLDC2
SETTTR SKN XXXINS; BRU *+4; SKN LNGEDT; BRU HOOHAH; BRU EDBUBU
       LDA =3; STA NTR
ACLDC2 SKN TLATE; BRU *+4; BRM CZERO; BRM INIVAR; BRR CLOOKY
       BRM RELTXB; BRU SETTGO

*  RETURN TO STANDARD FRONT END LINK
*
SRESET SKN XXXINS; BRU *+4; SKN LNGEDT; BRU HOOHAH; BRU EDBUBU
       SKN OUTFLG; BRU *+7; LDA OF; ETR =77B; SKE ONE; BRS 20
       LDA SWAPOF; STA OF
       BRM RELTXB; BRM CZERO; BRM RESFOS
       CLX; BRM LINKER

*  LINKING ROUTINE
*
*              LDX (LINK NUMBER)
*              BRM LINKER
*
*  LINK NUMBER:
*
*      0  SFE
*      1  DCC
*      2  AC1
*      3  TRC
*
LINKER ZRO
       BRS 113; STX LINKER; LDP* LINKF,2; BRS 64; BRU ERLINK
       STA 1002B
*  RESTORES FOS POPS
       LDX =POPTAB-POPTND
       LDA POPTND,2
       STA 200B,2
       BRX *-2
       WIO 1002B
       SBRM* 777B
ERLINK STX LNKODE; SNDA LNKERR
       LDA LINKER; SKE ZERO; ADD =3
       LDB =10; LDX ONE; BRS 36
       TCO =15B; LDA LNKODE; BRS 36
       SNDA CRCR; BRS 10
LNKERR ASC '$$AN ECAP LIBRARY FILE IS MISSING'
       ASC '.$CALL TYMSHARE FOR ASSISTANCE AND MENTION'
       ASC ' THIS CODE:  /'
LNKODE ZRO
LINKF  DATA SFE,DCC,AC1,TRC

*  RELABELLING SUBROUTINES
*
*      REMFOS    REMOVES FOS FROM CORE
*      RESFOS    PUTS FOS BACK IN CORE
*      REMTXB    REMOVES TEXT BUFFER FROM CORE
*      RESTXB    PUTS TEXT BUFFER BACK IN CORE
*      RELTXB    COMPLETELY ELIMINATES CURRENT TEXT BUFFER
*
REMFOS ZRO
       BRS 43; COPY AB,BA,BX; ETR =7777B; STA FOSPAG
       CXA; ETR =7777B4; XAB; BRS 44; BRR REMFOS
RESFOS ZRO
       BRS 43; XAB; ETR =7777B4; MRG FOSPAG
       XAB; BRS 44; BRR RESFOS
REMTXB ZRO
       BRS 43; COPY AB,BA,BX; ETR =7777B; STA TEXBUF
       CXA; ETR =7777B4; XAB; BRS 44; BRR REMTXB
RESTXB ZRO
       BRS 43; XAB; ETR =7777B4; MRG TEXBUF
       XAB; BRS 44; BRR RESTXB
RELTXB ZRO
       BRM REMTXB    CHANGED WITH VER.6.03
       LDX =-2
       LDA TEXBUF; ETR RMASK,2; 66B* SHIFT,2; SKE ZERO; BRS 121
       BRX *-5
       CLA; STA TEXBUF; BRR RELTXB
       DATA 77B2,77B
RMASK  DATA 24006B,24000B
SHIFT  EQU *

FOSPAG EQU 30B
TEXBUF EQU 31B

*  ZEROES OUT COMMON UP TO BUT NOT INCLUDING NTR
*
CZERO  ZRO
       LDA 400B; SUB =NTR; COPY AX,A
       STA NTR,2; BRX *-1; BRR CZERO

*  SETS UP TEXT BLOCK INITIAL CONDITIONS
*      BLKTO  =30000B
*      BLKCUR =0
*      BLKFRM =0
*      BLKNOS =0
*      BLKPOS =0
*      BLKWDS =0
*      BLKCHR =0
*      BLKPTR NULLED
*      XFRPTR NULLED
*
INITXB ZRO
       LDA =30000B; STA BLKTO
       LDX =-10
       CLA; STA 51B,2; BRX *-1; STA STBLK
       BRR INITXB

BLKTO  EQU  36B
BLKCUR EQU  37B
BLKFRM EQU  40B
BLKNOS EQU  41B
BLKPOS EQU  42B
XFRPTR EQU  43B
BLKPTR EQU  45B
BLKWDS EQU  47B
BLKCHR EQU  50B

*
*  INPUT FILE HANDLER
*  ON EOF OF CURRENT IF, CLOSES IT AND ATTEMPTS TO OPEN NEXT FILE.
*  IF FILE ENDS UP BEING THE TERMINAL, THE USER IS SO NOTIFIED.
*  BRANCHES TO INLNTR WHEN THROUGH.
*
EOFENC LDA IF; BRS 20
EOFCAN CLAB; STA IF; STP PTIFIL
       BRK PTIFLX; NOP
       STP PTIFIL; BRS 64; BRU EOFCHK
       STA IF; BRU INLNTR
EOFCHK LDF PTIFIL; SKG PTIFIL; BRU EOFTEL
       SNDA EOFM1; PSTR PTIFIL; BRU EOFCAN
EOFTEL SNDA EOFM2; BRU INLNTR
EOFM1  ASC '$CANNOT OPEN FILE: /'
EOFM2  ASC '$PROCEEDING WITH THE TERMINAL AS INPUT FILE$$/'




*  FILE DATA
*
*      LFILES(36) STORAGE AREA FOR LINK FILE NAMES
*      IFILES(44) STORAGE AREA FOR INPUT FILE NAMES
*      SAVEFL(5)  STORAGE AREA FOR SAVE FILE NAME
*
*      PTIFIL  STRING POINTERS FOR CURRENT INPUT FILE
*      PTSAVE  STRING POINTERS FOR "SAVE" FILE
*      PTIFLX  STRING POINTERS FOR REST OF INPUT FILE STRING
*      SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC  LINK FILE STRING POINTERS
*
IF     EQU     642B  INPUT FILE NUMBER
OF     EQU     643B  OUTPUT FILE NUMBER
SF     EQU     644B  SAVE FILE NUMBER
MF     EQU     645B  MODEL FILE NUMBER
COMINF EQU    1004B  COMMAND INPUT FILE NUMBER

*    ANALYSIS TYPE INITIALIZER
*
*
SETDCL BRM CZERO; BRM INITXB; LDA ONE; STA NTR; BRU SETL1
SETACL BRM CZERO; BRM INITXB; LDA =2; STA NTR; BRU SETL1
SETTRL BRM CZERO; BRM INITXB; LDA =3; STA NTR
SETL1  BRM INIVAR; BRM SETIME
       LDA NTR; SKE =3; BRU SETL2
       LDA =XXXTR; BRU SETL3
SETL2  LDB =XXXAC; SKE =2; LDB =XXXDC; COPY BA,B
SETL3  MUL =3; LSH 23; SUB ONE; CAB
       ADD =2; XAB; STP XFRPTR; PUTB
SETL4  LDA IOPTON; SKA ONE; BRU *+2; BRU *+4; LDA IFROM; SKE ONE
       BRU PAUANL; LDA NTR; ADD ONE; STA IFROM
       LDA IF; SKG ZERO; BRU *+7; LDA OF; ETR =77B; SKG ONE; BRU *+3
       TCO =140B; BRU *+2; SND CRCR
       BRM MOVER; BRU INLNTR
CRCR   ASC '$$/'
XXXDC  ASC 'DC'
XXXAC  ASC 'AC'
XXXTR  ASC 'TR'
FP1EM3 DATA 20304467B,22742767B  .001
FPONE  DATA 20000000B,00000001B 1.0
FP1E7  DATA 23045500B,00000030B 1E7
FP1EM2 DATA 24365605B,07533772B  .01

*  INITIALIZES VARIABLES
*
INIVAR ZRO
       LDA NTR; LDX ONE; STIA KTYPE; STX MAC
       STX IRTN; STX MAJOR
       LDA ONES; STA M1
       LDP FP1EM3; STF ERROR1; STF ERROR2
       LDP FPONE; STF ERROR3
       LDA NTR; SKE =3; BRR INIVAR
       LDP FP1E7; STF OPEN
       LDP FP1EM2; STF SHORT
       BRR INIVAR

INLNTR LDA =INLPAZ; BRM ALTMDY
       CLA; STA EDSTAT; LDA IF; STA INFILE; SKG ZERO
       SND ACLGLT; STRING; BRU EOFENC
       CMPRS PTRNEW; BRU INLNTR; LDP CMPRSP; STP INLPT1; STP INLPT2
       BRM CLOOKY; BRU INLNTR
*
*  S C A N   R O U T I N E
*
*  EXAMINES LINES
*
*      TLATE = 0  SYNTAX CHECKER
*      TLATE =-1  TRANSLATION AND STORE
*
TLATE  DATA 0
CLOOKY ZRO
CLOOK1 GCI INLPT2; BRR CLOOKY
       SKE =33B; BRU *+4; MIN CMPRSP; MIN INLPT1; BRU CLOOK1
       SKE =61B "Q"UIT; BRU *+2; BRU SRESET  RETURN TO SFE LINK
       SKE =43B; BRU *+2; BRU COMMNT; MDE INLPT2
       LDA INLPT2+1; SUB INLPT2; SKG ONE; BRU BADK1
       LDA INLPT2; CAB; ADD =2; XAB; STP COMPTR; LDA =COMDAT
       ADD =COMDAT; ADD =COMDAT; SUB ONE; CAB; ADD =2; XAB; LDX =-12
COMCK1 SKSE COMPTR
       BRU *+4; CLA; STA M1; BRU COMVK1,2
       ADD =4; XAB; BRX COMCK1
       LDA =CKTDAT; ADD =CKTDAT; ADD =CKTDAT; SUB ONE
       CAB; ADD =2; XAB; LDX =-15
COMCK2 SKSE COMPTR
       BRU *+4; CLA; STA M1; BRU COMVK2,2
       ADD =4; XAB; BRX COMCK2
       LDA =CARDAT; ADD =CARDAT; ADD =CARDAT; CAB; SUB ONE
       LDX =-8; MDE COMPTR+1
COMCK3 SKSE COMPTR
       BRU *+2; BRU COMCK4; ADD =2; XAB; BRX COMCK3; BRU BADK6
COMCK4 CXA; MRG =4B7; SKG =-3
       BRU *+4                 B,T,M,S,E OR I CARD
       SKE =-2
       BRU NCARDR              N-CARD
       BRU CONTKD              "*" - CONTINUE
       MIN COMPTR+1
       GCD COMPTR
       BRU BADK6
       SKG =31B
       SKG =17B                CHECK FOR CARD SERIAL NUMBER
       BRU BADK7               NO SER.NUMBER...ERROR
       EAX 2,2
       CLA; STA M1  FOR CONTINUE OF E OR I CARDS
       BRU COMVK3,2            B,T,M,S,E OR I CARD

*
*  DIFFERENTIATES BETWEEN (INITIAL TIME) AND (INSERT)
*  AND BRANCHES TO PROPER ROUTINE
*
AMBGIN LDX =-3; GCI INLPT2; BRU BADK1; BRX *-2
       LDB INLPT1
       STB INLPT2
       SKE =63B                S
       BRU *+2
       BRU LGINSR
       SKE =51B                I
       BRU *+2
       BRU INITIM
       SKE =35B                =
       BRU BADK8               NO INSERT OR INITIAL TIME
       BRU INITIM

RTN    ZRO
ACLGLT ASC     '*/'
INLPT1 BSS     2
INLPT2 BSS     2
COMPTR BSS     2

COMDAT ASC     'DCACTRMOEXENEDINDELIGOHE'
       BRU     SETTDC          TO BE DC
       BRU     SETTAC          TO BE AC
       BRU     SETTTR          TO BE TR
       BRU     SETMOD          MODIFY
       BRU     EXECUT          EXECUTE
       BRU     COMQUI          RETURN TO EXEC
       BRU     LGEDIT          EDIT
       BRU     AMBGIN          CHECK: (INSERT) OR (INITIAL TIME)
       BRU     LGDELE          DELETE
       BRU     LGLIST          LIST
       BRU     LGGOGO          GO
       BRU     HELPER          HELP
COMVK1 EQU     *

CKTDAT ASC     'PRPUFRTIOUFIWOSEST1E2E3ESHOPEQ'
       BRU     DPRINT          PRINT OUTPUT
       BRU     DPUNCH          PUNCH OUTPUT
       BRU     FREQUE          FREQUENCY
       BRU     TIMEST          TIME STEP
       BRU     OUTINT          OUTPUT INTERVAL
       BRU     FINTIM          FINISH TIME
       BRU     WORSTC          WORST CASE
       BRU     SENSIT          SENSITIVITIES
       BRU     STDDEV          STANDARD DEVIATION
       BRU     1ERROR          1ERROR MARGIN
       BRU     2ERROR          2ERROR MARGIN
       BRU     3ERROR          3ERROR MARGIN
       BRU     DSHORT          SHORT
       BRU     DOPENK          OPEN
       BRU     EQUILB          EQUILIBRIUM
COMVK2 EQU     *

CARDAT ASC     'BTMSEI*N'
       BRU     BCARDR          B-CARD
       BRU     TCARDR          T-CARD
       BRU     MCARDR          M-CARD
       BRU     SCARDR          S-CARD
       BRU     ECARDR          E-CARD
       BRU     ICARDR          I-CARD
COMVK3 EQU     *

*
*  P O P   T R A N S F E R   V E C T O R   T A B L E
*
POPTAB EQU     *
       BRU     LDFPOP          LDF     152
       BRU     STFPOP          STF     153
       BRU     LDFAPP          LDFA    154
       BRU     STFAPP          STFA    155
       BRU     LDIAPP          LDIA    156
       BRU     STIAPP          STIA    157
       BRU     RANGEP          RANGE   160
       BRU     PCKTPP          PCKT    161
       BRU     CMPRSS          CMPRS   162
       BRU     PUTBPP          PUTB    163
       BRU     MODPOP          MOD     164
       BRU     MAXPOP          MAX     165
       BRU     MDEPOP          MDE     166
       BRU     PTXPOP          PTX     167
       BRU     SNDAPP          SNDA    170
       BRU     SNDPOP          SND     171
       BRU     PSTRPP          PSTR    172
       BRU     SICPOP          SIC     173
       BRU     BRKPOP          BRK     174
       BRU     DATPOP          DAT     175
       BRU     TIMPOP          TIM     176
       BRU     STRNGP          STRING  177
POPTND EQU     *

*
*  A L T M O D E   R O U T I N E S
*
*  BRM ALTMDY  LETS ALTMODE OCCUR, CLEARS I-O BUFFERS, CLOSES OLD
*              COMMAND FILE AND MAKES THE TERMINAL THE NEW ONE, AND
*              RETURNS TO SPECIFIED LOCATION
*
*  BRM ALTMDN  EFFECTIVELY DISABLES THE ALTMODE, WILL NOT ALLOW
*              AN INTERRUPT OF THE PROGRAM TO OCCUR
*
ALTMDY ZRO; MRG =1B5 (BRU 0); STA ESCPYB
       LDA =ESCAPY; STA 201B; LDA =2B6; BRS 78; BRR ALTMDY
ESCAPY ZRO ALTRTN
       STP ALTA; STX ALTX; MDE ALTFLG
       LDX =-1; BRS 11; BRS 29; TCO =155B; CLA; STA COMINF
       BRS 151
ESCPYB ZRO
ALTMDN ZRO
       LDA =ESCAPN; STA 201B; LDA =2B6; BRS 78; BRR ALTMDN
ESCAPN ZRO ALTRTN
       STA PAREGR; BRM ALTMDN; LDA PAREGR; BRR ALTRTN
ALTFLG BSS  1  =-1 IF ALTMODE HIT
ALTA   ZRO
ALTB   ZRO
ALTX   ZRO
ALTRTN ZRO
PAREGR ZRO
COMQUI TCO =155B; BRS 10       RETURNS TO THE EXEC

*
*  TIME STEP  --  TRANSIENT ONLY
*
TIMEST LDA NTR; SKE =3; BRU INVIGN; BRM CKNUM1; SKN TLATE
       BRU CKNUMS; STF DELTA; BRR CLOOKY
*
*  OUTPUT INTERVAL  --  TRANSIENT ONLY
*
OUTINT LDA NTR; SKE =3; BRU INVIGN; BRM CKNUM1; SKN TLATE
       BRU CKNUMS; BRS 50; STA MAJOR; BRR CLOOKY
*
*  INITIAL TIME  --  TRANSIENT ONLY
*
INITIM LDA NTR; SKE =3; BRU INVIGN; BRM CKNUMP
       SKN TLATE; BRU CKNUMS; STF START; BRR CLOOKY
*
*  FINISH TIME  --  TRANSIENT ONLY
*
FINTIM LDA NTR; SKE =3; BRU INVIGN; BRM CKNUM1; SKN TLATE
       BRU CKNUMS; STF FINISH; BRR CLOOKY
*
*  1ERROR
*
1ERROR BRM CKNUMP; SKN TLATE; BRU CKNUMS; STF ERROR1; BRR CLOOKY
*
*  2ERROR
*
2ERROR BRM CKNUMP; SKN TLATE; BRU CKNUMS; STF ERROR2; BRR CLOOKY
*
*  3ERROR
*
3ERROR BRM CKNUMP; SKN TLATE; BRU CKNUMS; STF ERROR3; BRR CLOOKY
*
*  OPEN  --  TRANSIENT ONLY
*
DOPENK LDA NTR; SKE =3; BRU INVIGN; BRM CKNUM1; SKN TLATE
       BRU CKNUMS; STF OPEN; BRR CLOOKY
*
*  SHORT  --  TRANSIENT ONLY
*
DSHORT LDA NTR; SKE =3; BRU INVIGN; BRM CKNUM1; SKN TLATE
       BRU CKNUMS; STF SHORT; BRR CLOOKY

*  PUTS STRING UP TO END OF NUMBER INTO BUFFER AND CONTINUES
*
CKNUMS LDA INLPT1; LDB INLPT2; STP XFRPTR; PUTB
       GCI INLPT2; BRR CLOOKY; SKE =33B; BRU *-3; LDA INLPT2
       STA INLPT1; STA CMPRSP; BRU CLOOK1

*  PRINTS OUT AN INVALID STATEMENT, A MESSAGE AND CONTINUES
*
INVIGN GCI INLPT2; BRU *+4; SKE =33B; BRU INVIGN
       MDE INLPT2; TCO =155B; LDA INLPT1; LDB INLPT2; LDX =1; BRS 35
       SNDA MGINVI; LDA INLPT2; STA INLPT1; STA CMPRSP; BRU CLOOK1
MGINVI ASC  '$INVALID STATEMENT -- IGNORED$/'

*  CALLS FOR CONVERSION OF NUMBER WHICH MUST BE GREATER THAN ZERO
*  AND IS RETURNED IN THE A AND B REGISTERS
*
CKNUM1 ZRO
       BRM GETCHK; SKA =4B7; BRU BADK2; SKG ZERO; BRU BADK2; BRR CKNUM1

*  CALLS FOR CONVERSION OF NUMBER WHICH MUST BE >= ZERO AND IS
*  RETURNED IN THE A AND B REGISTERS
*
CKNUMP ZRO
       BRM GETCHK; SKA =4B7; BRU BADK5; BRR CKNUMP

*  GETS THE NUMBER FOR:
*
*      TI, OU, IN, FI, 1E, 2E, 3E, SH, OP
*
*  BRANCHES TO ERROR ROUTINES AS APPLICABLE
*
GETCHK ZRO
GETCK1 GCI INLPT2
       BRU BADK1               INCOMPLETE
       SKE =35B                =
       BRU GETCK2
       LDA INLPT2
       STA CPOINT
       SIC INLPT2
       BRU BADK3               OVERFLOW
       BRR GETCHK
GETCK2 SKE =33B                SEMICOLON
       BRU GETCK1
       LDA INLPT2
       STA CPOINT
       BRU BADK4               INCOMPLETE

*
*  EQUILIBRIUM  --  TRANSIENT ONLY
*
EQUILB LDA NTR; SKE =3; BRU INVIGN
       SKN TLATE; BRU NTRST1
       LDA ONE; STA NEQUIM; BRR CLOOKY

*
*  STANDARD DEVIATION  --  DC ONLY
*
STDDEV LDA NTR; SKE ONE; BRU INVIGN
       SKN TLATE; BRU NTRST1
       SKN MOSTAT; BRU STDEVI
       LDA MSEQ; LDB =4; SKE =2; LDB =3; STB MSEQ; BRR CLOOKY
STDEVI LDA ISEQ; LDB =4; SKE =2; LDB =3; STB ISEQ; BRR CLOOKY

*
*  WORST CASE  --  DC ONLY
*
WORSTC LDA NTR; SKE ONE; BRU INVIGN
       BRM MULNGT
       SKN TLATE  CONVERT STATEMENT
       BRU NTRST2 PUT STRING IN BUFFER
       SKN MOSTAT MODIFY ENTRY
       BRU WRSTC3 INITIAL ENTRY
       LDX =3
       SKN MULFLG  ALL NODES
       BRU WRSTC2  SELECTED NODES
       LDA =37777777B
       STIA IWCOUT; EAX 1,2; STIA IWCOUT
WRSTC1 LDA MSEQ
       LDB =4; SKE =3; LDB =2; STB MSEQ; BRR CLOOKY
WRSTC2 LDA NUMTMP; STIA IWCOUT; BRU WRSTC1
WRSTC3 LDX ONE
       SKN MULFLG  ALL NODES
       BRU WRSTC5  SELECTED NODES
       LDA =37777777B
       STIA IWCOUT; EAX 1,2; STIA IWCOUT
WRSTC4 LDA ISEQ
       LDB =4; SKE =3; LDB =2; STB ISEQ; BRR CLOOKY
WRSTC5 LDA NUMTMP; STIA IWCOUT; BRU WRSTC4

*
*  SENSITIVITIES  --  DC ONLY
*
SENSIT LDA NTR; SKE ONE; BRU INVIGN
       BRM MULNGT
       SKN TLATE   CONVERT STATEMENT
       BRU NTRST2  PUT STRING IN BUFFER
       SKN MOSTAT  MODIFY ENTRY
       BRU SNSIT3  INITIAL ENTRY
       SKN MULFLG  ALL NODES
       BRU SNSIT2  SELECTED NODES
       LDA =37777777B
SNSIT1 STA ID1
       LDA MSEQ
       SKE ZERO
       BRR CLOOKY
       MIN MSEQ
       BRR CLOOKY
SNSIT2 LDA NUMTMP
       BRU SNSIT1
SNSIT3 SKN MULFLG  ALL NODES
       BRU SNSIT5  SELECTED NODES
       LDA =37777777B
SNSIT4 STA ID1
       LDA ISEQ
       SKE ZERO
       BRR CLOOKY
       MIN ISEQ
       BRR CLOOKY
SNSIT5 LDA NUMTMP
       BRU SNSIT4

*
*  PUTS STRING IN BUFFER FOR ST, EQ, WO, SE
*
NTRST1 GCI INLPT2; BRU NTRST2
       SKE =33B; BRU NTRST1; MDE INLPT2
NTRST2 LDA INLPT1; LDB INLPT2; STP XFRPTR; STB INLPT1; STB CMPRSP
       PUTB; BRU CLOOK1

*
*  GETS NODES, IF ANY, FOR SENSITIVITIES AND WORST CASE
*  IF NODES, MULFLG >= 0 AND BOOLEAN NODES ARE IN NUMTMP
*  BRANCHES TO APPLICABLE ERROR ROUTINES
*
MULNGT ZRO
       LDA ONES; STA MULFLG; CLA; STA NUMTMP
MULNG1 GCI INLPT2
       BRR MULNGT
       SKE =33B; BRU *+3; MDE INLPT2; BRR MULNGT
       SKE =14B; BRU MULNG1; MIN MULFLG
       LDA INLPT2; STA CPOINT
       SIC INL       BRU BADK3   OVERFLOW
       SKA =4B7; BRU BADK2  NEGATIVE
       SKG ZERO; BRU BADK2  ZERO
       BRS 50
       SKG DNODES  MAX. NUMBER OF NODES
       BRU *+2
       BRU BADK9   TOO LARGE A NUMBER
       SKN TLATE   CONVERT
       BRU MULNG1  JUST SYNTAX CHECKING
       COPY AX,B
       LDA ONE
       LSH -1,2
       MRG NUMTMP
       STA NUMTMP
       BRU MULNG1
NUMTMP ZRO
MULFLG ZRO

*
*  FREQUENCY  --  AC ONLY
*
FREQUE LDA NTR; SKE =2; BRU INVIGN
       SKN MOSTAT  MODIFY ENTRY
       BRU FREQUI  INITIAL ENTRY
       BRM MODDER
       CAX; LDA =8; STIA MOPARM
FREQU1 GCI INLPT2
       BRU GTNMM4  INCOMPLETE
       SKE =33B; BRU *+3; MDE INLPT2; BRU GTNMM4
       SKE =35B; BRU FREQU1
       BRM GETNMM
       SKN TLATE
       BRU FREQU2
       LDX NUMMO; STFA VFIRST; LDA ONE; STA NREC
FREQU2 GCI INLPT2
       BRU *+4
       SKE =33B; BRU *+5; MDE INLPT2
       SKN TLATE; BRU NTRST2; BRU CLOOK1
       SKE =10B; BRU BADK11  BAD CHARACTER
       GCI INLPT2
       BRU GTNMM4  INCOMPLETE
       SKE =13B  +
       BRU *+3
       MIN NREC; BRU *+2; MDE INLPT2
       BRM GETNMM
       SKN TLATE
       BRU FREQU3
       LDX NUMMO; STFA VSECND; BRS 50; STIA MOSTEP
FREQU3 GCI INLPT2; BRU GTNMM4  INCOMPLETE
       SKE =33B; BRU *+3; MDE INLPT2; BRU GTNMM4
       SKE =11B; BRU BADK11  BAD CHARACTER
       BRM GETNMM
       SKN TLATE
       BRU CKNUMS  PUT STRING IN BUFFER
       LDX NUMMO
       STFA VLAST
       BRR CLOOKY
FREQUI BRM CKNUM1  FR=NN  >0
       SKN TLATE  CONVERT
       BRU CKNUMS  PUT STRING IN BUFFER
       FMP TWOPI   CONVERT TO RADIAN FREQUENCY
       STF OMEGA
       BRR CLOOKY
TWOPI  DATA 31103755B,24166003B    6.2831853072


*
*      P R I N T   A N D   P U N C H
*
*
DPRINT LDA ONES; STA OUTMOD; LDB ONE; BRU *+3
DPUNCH CLB; STB OUTMOD; LDX =16; CLA; STIA NPRINT; EAX 1,2; STIA NPRINT
       CBX; EAX 16,2; LDA ONE; STIA NPRINT
PRIPUN LDA ONES; STA MULFLG; SKN TLATE; BRU PRPU1
       SKN MOSTAT; BRU PRPU1
       LDX =1; CLA; STIA NPRINT; EAX 1,2; CXA; SKG =10; BRU *-5
       LDX =21; CLA; STIA NPRINT; EAX 1,2; CXA; SKG =60; BRU *-5
PRPU1  GCI INLPT2
       BRU PRPUEX
       SKE =33B; BRU *+3; MDE INLPT2; BRU PRPUEX
       SKE =14B; BRU PRPU1
PRPUCK LDA INLPT2; CAB; ADD =2; STF COMPTR
       LDA =OUTDAT; ADD =OUTDAT; ADD =OUTDAT; SUB ONE
       CAB; ADD =2; XAB; LDX =-13
PRPU2  SKSE COMPTR
       BRU *+2; BRU PRPU3
       ADD =4; XAB; BRX PRPU2; BRU BADK13
*
*    NV , CA , CV , BA , BV , BP , SE , WO , ST , MI , VO , CU , DB
*     1    2    3    4    5    6    7    8    9   10   1    2    13
*                                  DC   DC   DC                  AC
*
OUTDAT ASC     'DBCUVOMISTWOSEBPBVBACVCANV'

PRPU3  MIN MULFLG; CXA; MRG =4B7; CNA
       SKG =10; BRU *+5; SKE =13; BRU *+2; BRU PRPUAC; SUB =10
       STA K; SKG =9; SKG =6; BRU PRPU4
       CAB; LDA NTR; SKE ONE; BRU BADK14
       CBA
PRPU4  SKN TLATE; BRU PRPU5
       CAX; LDA ONE; STIA NPRINT
PRPU5  GCI INLPT2
       BRU PRPUEX
       SKE =33B; BRU *+3; MDE INLPT2; BRU PRPUEX
       SKE =14B; BRU *+2; BRU PRPUCK  ANOTHER SPEC
       SKE =10B; BRU PRPU5
       LDA K; SKG =9; SKG =6; BRU *+2; BRU BADK15
       CLA; STA JJJ
PRPU6  MIN JJJ; LDA JJJ; SKG =6; BRU *+2; BRU BADK16
       BRM GETNMI
       BRS 50
       SKN TLATE; BRU PRPU7
       STA NUMTMP; LDA K; MUL =6; LSH 23
       ADD =20; ADD JJJ; SUB =6
       CAX; LDA NUMTMP; STIA NPRINT
PRPU7  GCI INLPT2
       BRU BADK17
       SKE =33B; BRU *+3; MDE INLPT2; BRU BADK17
       SKE =14B; BRU *+2; BRU PRPU6
       SKE =11B; BRU BADK18
       BRU PRPU1
PRPUAC LDA NTR; SKE =2; BRU BADK19
       MIN INLPT2; MIN INLPT2
       GCI INLPT2; BRU BADK17
       SKE =10B; BRU PRPU8
       GCI INLPT2
       BRU BADK17
       SKE =42B; BRU *+4; LDA ONES; STA NUMTMP; BRU PRUAC1
       SKE =66B; BRU BADK18
       LDA ONE; STA NUMTMP
PRUAC1 BRM GETNMI; SKN TLATE; BRU PRUAC2; BRS 50
       MUL =100; LSH 23; LDX =59; STIA NPRINT
PRUAC2 GCI INLPT2; BRU BADK17
       SKE =17B; BRU BADK18
       GCI INLPT2; BRU BADK17
       SKE =42B; BRU PRUAC4; LDA ONES
PRUAC3 SKE NUMTMP; BRU BADK18
       BRU PRUAC5
PRUAC4 SKE =66B; BRU BADK18
       LDA ONE; BRU PRUAC3
PRUAC5 BRM GETNMI; SKN TLATE; BRU PRUAC6
       BRS 50; STA K; LDX =59; LDIA NPRINT
       ADD K; MUL NUMTMP; LSH 23
       LDX =59; STIA NPRINT
PRUAC6 GCI INLPT2; BRU BADK17
       SKE =11B; BRU BADK18
       BRU PRPU1
PRPU8  MDE INLPT2; BRU BADK17
PRPUEX SKN MULFLG; BRU *+2; BRU BADK17
       SKN TLATE; BRU *+2; BRR CLOOKY
       SKN OUTMOD; BRU PRPUX2 (PUNCH)
* PRINT OUTPUT CHECKER
       SKN OUTFLG; BRU PRPUX1  (NO SWAP HAS OCCURRED)
       LDA OF; ETR =77B; SKG ONE; BRU NTRST2 ALL OK
       LDA OF; BRS 20; LDA =43000001B; STA OF; MIN OUTFLG; BRU NTRST2
PRPUX1 LDA OF; ETR =77B; SKG ONE; BRU NTRST2
       MDE OUTFLG; LDA OF; STA SWAPOF
       LDA =43000001B; STA OF; BRU NTRST2
* PUNCH OUTPUT CHECKER
PRPUX2 SKN OUTFLG; BRU PRPUX3
       LDA OF; ETR =77B; SKE ONE; BRU NTRST2
       LDA SWAPOF; STA OF; MIN OUTFLG; BRU NTRST2
PRPUX3 LDA OF; ETR =77B; SKE ONE; BRU NTRST2
       SNDA PRPUM1
PRPUX4 LDA =104B5; LDX =3; BRS 63; BRU PRPUX5
       LDB OF; STA OF; STB SWAPOF; SKG =2; BRU *+5
       RSP OF; MRG =4B7; SCP OF; BRU PRPUX6
       LDA OF; MRG =43B6; STA OF; MDE OUTFLG; BRU NTRST2
PRPUX5 SNDA PRPUM2; BRU PRPUX4
PRPUX6 LDA OF; BRS 20; BRU PRPUX5

OUTMOD EQU 15B   -1 = PRINT, 0 = PUNCH
OUTFLG EQU 16B   -1 = FILE SWAP HAS OCCURRED, 0 = HAS NOT
SWAPOF EQU 17B   SWAPPED FILE NUMBER

PRPUM1 ASC '$ENTER OUTPUT FILE NAME FOR "PUNCH" (APPEND MODE): /'
PRPUM2 ASC '$CANNOT OPEN FILE, PLEASE ENTER NEW NAME: /'

K      ZRO
JJJ    ZRO


*
*  GETS A NUMBER AND RETURNS IF > ZERO
*  FOR MODIFY ROUTINE
*
GETNMM ZRO
       LDA INLPT2; STA CPOINT
       SIC INLPT2
       BRU GTNMM1  OVERFLOW
       SKA =4B7
       BRU GTNMM2  NEGATIVE
       SKG ZERO
       BRU GTNMM3  ZERO
       BRR GETNMM
GTNMM1 MDE NUMMO; BRU BADK3
GTNMM2 MDE NUMMO; BRU BADK2
GTNMM3 MDE NUMMO; BRU BADK2
GTNMM4 MDE NUMMO; BRU BADK1

*  CHECKS THAT THE NUMBER OF MODIFICATIONS ARE <= LIMMOD
*
MODDER ZRO
       MIN NUMMO; LDA NUMMO
       SKG LIMMOD  MAX NUMBER OF MODIFICATIONS
       BRR MODDER
       MDE NUMMO
       BRU BADK10

*
*  GETS A NUMBER AND RETURNS OF > ZERO
*  FOR INITIAL ENTRY ROUTINE
*
GETNMI ZRO
       LDA INLPT2; STA CPOINT
       SIC INLPT2
       BRU BADK3  OVERFLOW
       SKA =4B7
       BRU BADK2  NEGATIVE
       SKG ZERO
       BRU BADK2  ZERO
       BRR GETNMI



**EOS**

*
*              M   -   C A R D
*
*                 10 MAX
*
*            AC AND TR ANALYSES
*
*
MCARDR LDA NTR; SKG ONE; BRU INVIGN
*  GET SERIAL NUMBER
       GCI INLPT2
       NOP 0  ALREADY CHECKED
       BRM GETNMI
       BRS 50
       SKG =10; BRU *+2; BRU BADK20
       STA NUM
       LDA NLTRMS
       ADD ONE; SKG =10; BRU *+2; BRU BADK21
       BRM NULKRD
       MDE INLPT2
       GCI INLPT2; BRU BADK17  INCOMPLETE
MCARDB GCI INLPT2; BRU MCARDE
       SKE =42B
       BRU MCARD2  CHECK FOR "L"
       SKN TOFROM; BRU *+2; BRU BADK12  INVALID
       BRM GETFRE
       SKG DBRNCH; BRU *+2; BRU BADK24  BRANCH NUMBER TOO HIGH
       SKN TLATE; BRU MCARD1
       SKN MOSTAT; BRU *+2; BRU MCARD1
       LDX NUM; STIA ICOLM
MCARD1 BRM GETTOE
       SKG DBRNCH; BRU *+2; BRU BADK24  BRANCH NUMBER TOO HIGH
       SKN TLATE; BRU *+6
       SKN MOSTAT; BRU *+2; BRU *+3
       LDX NUM; STIA IROWM
       MDE TOFROM
*  DECIDES WHERE TO GO NEXT
MCARDG GCI INLPT2; BRU MCARDE
       SKE =33B; BRU *+3; MDE INLPT2; BRU MCARDE
       SKE =14B; BRU BADK18  BAD CHAR
       BRU MCARDB
*  L=
MCARD2 SKE =54B; BRU BADK18  BAD CHAR
       SKN NOEL; BRU *+2; BRU BADK23  TOO MANY ELEMENTS
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =35B; BRU BADK18  BAD CHAR
       GCI INLPT2; BRU BADK17  INCOMPLETE
*  (L,L)
       SKE =10B; BRU MCARD3
       LDA NTR; SKE =3; BRU BADK18  BAD CHAR
       LDA INLPT2; STA CPOINT
       SIC INLPT2; BRU BADK3  OVERFLOW
       SKE ZERO; BRU *+2; BRU BADK22  MUST BE NON-ZERO
       SKN TLATE; BRU *+3
       LDX NUM; STFA FLML
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =14B; BRU BADK18  BAD CHAR
       LDA INLPT2; STA CPOINT
       SIC INLPT2; BRU BADK3  OVERFLOW
       SKE ZERO; BRU *+2; BRU BADK22 MUST BE NON-ZERO
       SKN TLATE; BRU *+3
       LDX NUM; STFA FLMH
MCARDT MDE NOEL; BRU MCARDG
*  GETS MODIFY   L=N    L=N(N)N
MCARD3 MDE INLPT2
       SKN MOSTAT; BRU MCARD4
       BRM MODDER
       SKN TLATE; BRU *+6
       LDX NUMMO
       LDA NUM; STIA MOBRN; LDA =7; STIA MOPARM
       BRM PARMOD; BRU MCARDT
*  L=N
*  INITIAL
MCARD4 BRM NUMNOZ
       SKN TLATE; BRU MCARDT
       LDX NUM
       STFA FLML; STFA FLMH; XMA NTR
       SKE =3; BRU *+3; XMA NTR; BRU MCARDT; XMA NTR; STFA FLM; BRU MCARDT
*
*  SHOULD BE:    NOEL = -1    TOFROM = -1
MCARDE SKN NOEL; BRU BADK17  INCOMPLETE
       SKN TOFROM; BRU *+5
       MIN NLTRMS
       SKN TLATE; BRU NTRST1
       BRR CLOOKY
       SKN MOSTAT; BRU BADK17  INCOMPLETE
       BRU *-5


*              S   -   C A R D
*
*                 60 MAX
*
*      SNN   B=BS,(B1,...BN),ON/OFF
*
*
SCARDR LDA NTR; SKE =3; BRU INVIGN
*  GET SERIAL NUMBER
       GCI INLPT2; NOP
       BRM GETNMI; BRS 50; SKG =60; BRU *+2; BRU BADK25  SER.NO.TOO HIGH
       STA NUM
       MDE INLPT2
       LDA NOSW; ADD =1; SKG =60; BRU *+2; BRU BADK26  TOO MANY S-CARDS
       GCI INLPT2; BRU BADK17  INCOMPLETE
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =42B; BRU BADK18  BAD CHAR
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =35B; BRU BADK18  BAD CHAR
       BRM GETNMI; BRS 50; SKG =60; BRU *+2; BRU BADK24  B-NO. TOO HIGH
       SKN TLATE; BRU *+5
       LDX NUM
       STIA LINK1D; CLA; STIA LIST4
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =14B; BRU BADK18  BAD CHAR
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =10B; BRU BADK18  BAD CHAR
*  GET SWITCHED BRANCHES
SCARD1 LDA KS; SKG =59; BRU *+2; BRU BADK27  TOO MANY SWITCHED BRANCHES
       BRM GETNMI; BRS 50; SKG =60; BRU *+2; BRU BADK24  B-NO TOO HIGH
       SKN TLATE; BRU *+8
       MIN KS; LDX KS
       STIA LINK1E
       LDX NUM
       LDIA LIST4; ADD ONE; STIA LIST4
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =14B; BRU *+2; BRU SCARD1
       SKE =11B; BRU BADK18  BAD CHAR
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =14B; BRU BADK18  BAD CHAR
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =57B; BRU BADK18  BAD CHAR
       GCI INLPT2; BRU BADK17 INCOMPLETE
       SKE =46B; BRU *+7
       SKN TLATE; BRU SCARD2
       LDX NUM; LDA ONE; STIA LABEL; BRU SCARD2
       SKE =56B; BRU BADK18  BAD CHAR
       SKN TLATE; BRU SCARD2
       LDX NUM; LDA =2; STIA LABEL
SCARD2 MIN NOSW
       SKN TLATE; BRU NTRST1; BRR CLOOKY



*                  T   -   C A R D
*
*                     10 MAX
*
*  TNN B(N,N),[ELEMENT]
*  TNN [ELEMENT],B(N,N)
*
*
*             INITIAL                    MODIFY
*
*             D=N       AC,DC,TR         D=N          AC,DC
*  [ELEMENT]  D=(N,N)         TR         D=N(N)N      AC,DC
*             D=N(N)       DC            D=N(N)          DC
*             D=N(N,N)     DC            D=N(N,N)        DC
*
*  D = BETA (OR) GM
*
*
TCARDR GCI INLPT2; NOP
       BRM GETNMI; BRS 50; SKG =10; BRU *+2; BRU BADK20 SER.TOO HIGH
       STA NUM; MDE INLPT2; BRM NULKRD
       LDA NTERMS; ADD ONE; SKG =10; BRU *+2; BRU BADK28  TOO MANY
       GCI INLPT2; BRU BADK17 INCOMPLETE
*  DECIDE IF   B(   GM   BETA
TCARDB GCI INLPT2; BRU TCARDE
       SKE =33B; BRU *+3; MDE INLPT2; BRU TCARDE
       SKE =14B; BRU *+2; BRU TCARDB
       SKE =42B; BRU *+9
       GCI INLPT2; BRU BADK17 INCOMPLETE
       SKE =10B; BRU *+2; BRU TCARD1  B(B1,B2)
       SKE =45B; BRU BADK18  BAD CHAR
       BRU TCARD5  BETA
       SKE =47B; BRU BADK18  BAD CHAR
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =55B; BRU BADK18  BAD CHAR
*  GM
*
       SKN NOEL; BRU *+2; BRU BADK23  TOO MANY ELEMENTS
       GCI INLPT2; BRU BADK17 INCOMPLETE
       SKE =35B; BRU BADK18  BAD CHAR
*  GET GM DATA
*
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =10B; BRU TCARD2
*  TR:  (GM,GM)
       LDA NTR; SKE =3; BRU BADK18  BAD CHAR
       BRM RNUMBR
       SKN TLATE; BRU *+3
       LDX NUM; STFA YTERML
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =14B; BRU BADK18  BAD CHAR
       BRM RNUMBR
       SKN TLATE; BRU *+3
       LDX NUM; STFA YTERMH
TCARDC GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =11B; BRU BADK18  BAD CHAR
       BRU TCARDT
*  B(B1,B2) HANDLER  -  IGNORES ON MODIFY
*
TCARD1 MDE INLPT2  RETURN TO (
       SKN TOFROM; BRU *+2; BRU BADK12  INVALID
       BRM GETFRE
       SKG DBRNCH; BRU *+2; BRU BADK24  B.NO.TOO HIGH
       SKN TLATE; BRU *+6
       SKN MOSTAT; BRU *+2; BRU *+3
       LDX NUM; STIA ICOLT
       BRM GETTOE
       SKG DBRNCH; BRU *+2; BRU BADK24  B.NO.TOO HIGH
       SKN TLATE; BRU *+6
       SKN MOSTAT; BRU *+2; BRU *+3
       LDX NUM; STIA IROWT
       MDE TOFROM  SETS FLAG
       BRU TCARDB
TCARDT MDE NOEL; BRU TCARDB
*  AC,DC:    GM    GM(GM)GM    GM(GM,GM)    GM(GM)    MODIFY
*
TCARD2 MDE INLPT2
       SKN MOSTAT; BRU TCARD3  INITIAL ENTRY
       BRM MODSUB
       MDE NOEL
       SKN TLATE; BRU TCARDB
       LDX NUMMO; LDA NUM; STIA MOBRN
       LDA =-2; STIA MOPARM; BRU TCARDB
*  INITIAL ENTRY  GM
*    GM    GM(GM)     GM(GM,GM)
*
TCARD3 BRM RNUMBR
       SKN TLATE; BRU *+11
       LDX NUM
       STFA YTERML; STFA YTERMH
       XMA NTR; SKE =3; BRU *+3
       XMA NTR; BRU TCARDT
       XMA NTR; STFA YTERM
       GCI INLPT2; BRU TCARDT
       SKE =10B; BRU *+2; BRU *+3; MDE NOEL; BRU TCARDB+2
       LDA NTR; SKE ONE; BRU BADK18  BAD CHAR
       BRM RNUMBR
       SKN TLATE; BRU *+4
       LDX NUM; STFA YTERML; STFA YTERMH
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =11B; BRU TCARD4    ,--)
TCARDZ SKN TLATE; BRU TCARDT
       LDX NUM; LDFA YTERM; STP FTEMP1
       SKA =4B7; BRS 21  ABS.VALUE
       STP FTEMP2
       LDFA YTERML; FMP FTEMP2; STP FTEMP2
       LDP FTEMP1; FSB FTEMP2; STFA YTERML
       LDP FTEMP1; FAD FTEMP2; STFA YTERMH; BRU TCARDT
TCARD4 SKE =14B; BRU BADK18  BAD CHAR
       BRM RNUMBR
       SKN TLATE; BRU *+3
       LDX NUM; STFA YTERMH
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =11B; BRU BADK18  BAD CHAR
       BRU TCARDT
*  BETA
*
TCARD5 SKN NOEL; BRU *+2; BRU BADK23  TOO MANY ELEMENTS
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =35B; BRU *-3
*  GET BETA DATA
*
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =10B; BRU TCARD6  NOT (BETA,BETA) [TR]
*  TR:   (BETA,BETA)
*
       LDA NTR; SKE =3; BRU BADK18  BAD CHAR
       BRM RNUMBR
       SKN TLATE; BRU *+13
       STP FTEMP1
       LDX NUM; LDIA ICOLT; STA NBRN; CAX
       LDFA YMIN
       SKE ZERO; BRU *+2; BRU TKDERR  B-CARD NOT YET SPECIFIED
       FMP FTEMP1; LDX NUM
       STFA YTERML
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =14B; BRU BADK18  BAD CHAR
       BRM RNUMBR
       SKN TLATE; BRU TCARDC
       STP FTEMP1; LDX NBRN
       LDFA YMAX
       SKE ZERO; BRU *+2; BRU TKDERR B-CARD NOT YET SPECIFIED
       FMP FTEMP1; LDX NUM
       STFA YTERMH; BRU TCARDC
*  AC,DC:  BETA    BETA(BETA)BETA   BETA(BETA)   BETA(BETA,BETA)
*  MODIFY
*
TCARD6 MDE INLPT2
       SKN MOSTAT; BRU TCARD7  INITIAL ENTRY
       BRM MODSUB
       MDE NOEL; SKN TLATE; BRU TCARDB
       LDX NUMMO
       LDA NUM; STIA MOBRN
       LDA =2; STIA MOPARM; BRU TCARDB
*  INITIAL ENTRY BETA
*  BETA    TR ANALYSIS
*
TCARD7 LDA NTR; SKE =3; BRU TCARD8    AC,DC
       BRM RNUMBR
       SKN TLATE; BRU TCARDT
       STP FTEMP1
       LDX NUM; LDIA ICOLT; STA NBRN; CAX
       LDFA YMIN
       SKE ZERO; BRU *+2; BRU TKDERR B-CARD NOT YET SPECIFIED
       FMP FTEMP1; LDX NUM
       STFA YTERML; LDFA YMAX
       SKE ZERO; BRU *+2; BRU TKDERR  B-CARD NOT YET SPECIFIED
       FMP FTEMP1; LDX NUM
       STFA YTERMH; BRU TCARDT
*  INITIAL ENTRY  BETA
*    BETA   BETA(BETA)    BETA(BETA,BETA)
*
TCARD8 BRM RNUMBR; SKN TLATE; BRU *+16
       STP FTEMP1
       LDX NUM; LDIA ICOLT; STA NBRN; CAX
       LDFA Y; STP FTEMP2
       SKE ZERO; BRU *+2; BRU TKDERR  B-CARD NOT YET SPECIFIED
       FMP FTEMP1; LDX NUM
       STFA YTERM; STFA YTERML; STFA YTERMH
       GCI INLPT2; BRU TCARDT
       SKE =10B; BRU *+2; BRU *+3; MDE INLPT2; BRU TCARDT
       LDA NTR; SKE ONE; BRU BADK18  BAD CHAR
       BRM RNUMBR
       SKN TLATE; BRU *+5
       FMP FTEMP2; LDX NUM
       STFA YTERML; STFA YTERMH
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =14B; BRU TCARD9  BETA(BETA)
       BRM RNUMBR
       SKN TLATE; BRU *+4
       FMP FTEMP2; LDX NUM
       STFA YTERMH
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =11B; BRU BADK18  BAD CHAR
       BRU TCARDT
*  BETA(BETA)
*
TCARD9 SKE =11B; BRU BADK18  BAD CHAR
       BRU TCARDZ
*
*  SHOULD BE:
*      NOEL = -1    TOFROM = -1
*
TCARDE SKN NOEL; BRU BADK17  INCOMPLETE
       SKN TOFROM; BRU *+5
       MIN NTERMS
       SKN TLATE; BRU NTRST1
       BRR CLOOKY
       SKN MOSTAT; BRU BADK17  INCOMPLETE
       BRU *-5
NBRN   ZRO

TKDERR SNDA TKDER1
       LDX =-8; CLA; CIO ONE; BRX *-1
       LDP INLPT1; LDX ONE; BRS 35
       SNDA TKDER2
*  ZERO COMMON AND REMOVE 'EXECUTE' FROM TEXT BUFFER
TCDINL LDA BLKNOS
       BRM GETPOS
       BRM DELETM
       CLA; STA TLATE; STA STBLK; BRM BSCAN
*
*  DRIVER TO ALLOW REPAIR OF CIRCUIT
*
INLFIX LDA =INLFIX; BRM ALTMDY; CLA; STA EDSTAT; STA INFILE
       SNDA ACLGLT; STRING; NOP
       CMPRS PTRNEW; BRU INLFIX
       LDP CMPRSP; STP INLPT1; STP INLPT2
       BRM CLOOKY; BRU INLFIX
TKDER1 ASC '$$ERROR: CANNOT PROCEED$
+T-CARD MUST NOT PRECEDE THE B-CARD DEFINING ITS FROM BRANCH:$$/'
TKDER2 ASC '$$PLEASE REORGANIZE YOUR CIRCUIT STATEMENTS$$/'


*                       B   -   C A R D
*
*                            60 MAX
*
*        BNN  N(N,N), [ELEMENT] [,SOURCE] [,INITIAL CONDITIONS]
*
*              INITIAL                 MODIFY
*
*  [ELEMENT]   D=N         DC,AC,TR    D=N          DC,AC
*              D=(N,N)           TR    D=N(N)N      DC,AC
*              D=N(N)      DC          D=N(N)       DC
*              D=N(N,N)    DC          D=N(N,N)     DC
*
*              D = R (OR) G    DC,AC,TR
*                = L (OR) C       AC,TR
*
*  [SOURCE]    D=N         DC,AC,TR    D=N          DC,AC
*              D=(N,N)           TR    D=N(N)N      DC,AC
*              D=N(N)      DC          D=N(N)       DC
*              D=N(N,N)    DC          D=N(N,N)     DC
*              D=N/N          AC       D=N(N)N/N(N)N   AC
*
*              D = E (OR) I
*
*  [INITIAL CONDITIONS]
*              D=N        TR
*                  D = EO (OR) E0
*                  D = IO (OR) I0
*
*
*
BCARDR GCI INLPT2; NOP
       BRM GETNMI; BRS 50; SKG DBRNCH; BRU *+2; BRU BADK24
       STA NUM; LDB NMAX; MAX; SKG DBRNCH; BRU *+2; BRU BADK29
       STA NMAX; MDE INLPT2; BRM NULKRD
       GCI INLPT2; BRU BADK17  INCOMPLETE
*  DECIDE WHERE TO GO:  B  R  G  L  C  E  I  EO  IO  E0  I0
BCARDB GCI INLPT2; BRU BCARDE
       SKE =33B; BRU *+3; MDE INLPT2; BRU BCARDE
       SKE =14B; BRU *+2; BRU BCARDB
       SKE =56B; BRU *+2; BRU BKRDN  GET NODES
       SKE =43B; BRU *+2; BRU BKRDC  GET CAPACITOR
       SKE =45B; BRU *+2; BRU BKRDE  GET VOLTS
       SKE =47B; BRU *+2; BRU BKRDG  GET CONDUCTOR
       SKE =51B; BRU *+2; BRU BKRDI  GET AMPS
       SKE =54B; BRU *+2; BRU BKRDL  GET INDUCTOR
       SKE =62B; BRU BADK18; BRU BKRDR  GET RESISTOR
*  GET NODAL DATA  -  IGNORE ON MODIFY
*
BKRDN  SKN TOFROM; BRU *+2; BRU BADK12  INVALID
       BRM GETFRE
       SKG DNODES; BRU *+2; BRU BADK30  NODE TOO HIGH
       SKN MOSTAT; BRU *+2; BRU *+13
       SKN TLATE; BRU *+3
       LDX NUM; STIA NINIT
       STA FTEMP1
       LDF HNODE; BRS 50
       XMA FTEMP1
       SKG FTEMP1; BRU *+3
       BRS 51; STF HNODE
       BRM GETTOE
       SKG DNODES; BRU *+2; BRU BADK30  NODE TOO HIGH
       SKN MOSTAT; BRU *+2; BRU BCARDB
       SKN TLATE; BRU *+3
       LDX NUM; STIA NFIN
       STA FTEMP1
       LDF HNODE; BRS 50
       XMA FTEMP1
       SKG FTEMP1; BRU *+3
       BRS 51; STF HNODE
       MDE TOFROM  SETS FLAG
       BRU BCARDB
BCARDT MDE NOEL; BRU BCARDB
*  CAPACITOR
*
BKRDC  LDA NTR; SKG ONE; BRU BADK18  BAD CHAR
       SKN NOEL; BRU *+2; BRU BADK23  TOO MANY
       SKN MOSTAT; BRU BKRDC9  INITIAL ENTRY
       BRM MODSUB
       SKN TLATE; BRU BCARDT
       LDX NUMMO; LDA NUM; STIA MOBRN
       LDA =6; STIA MOPARM; BRU BCARDT
*  CONDUCTOR
*
BKRDG  SKN NOEL; BRU *+2; BRU BADK23  TOO MANY
       SKN MOSTAT; BRU BKRDG9  INITIAL ENTRY
       BRM MODSUB
       SKN TLATE; BRU BCARDT
       LDX NUMMO; LDA NUM; STIA MOBRN
       LDA ONES; STIA MOPARM; BRU BCARDT
*  INDUCTOR
*
BKRDL  LDA NTR; SKG ONE; BRU BADK18  BAD CHAR
       SKN NOEL; BRU *+2; BRU BADK23  TOO MANY
       SKN MOSTAT; BRU BKRDL9  INITIAL ENTRY
       BRM MODSUB
       SKN TLATE; BRU BCARDT
       LDX NUMMO; LDA NUM; STIA MOBRN
       LDA =5; STIA MOPARM; BRU BCARDT
*  RESISTOR
*
BKRDR  SKN NOEL; BRU *+2; BRU BADK23  TOO MANY
       SKN MOSTAT; BRU BKRDR9  INITIAL ENTRY
       BRM MODSUB
       SKN TLATE; BRU BCARDT
       LDX NUMMO
       LDA NUM; STIA MOBRN
       LDA ONE; STIA MOPARM; BRU BCARDT
*  C  INITIAL ENTRY
*
BKRDC9 LDA ONES; STA INVFLG; BRM DATSTO
       SKN TLATE; BRU BCARDT
       MIN NUMBC; LDA ONE; LDX NUM; STIA MODE1; BRU BCARDT
*  G  INITIAL ENTRY
*
BKRDG9 LDA ONES; STA INVFLG; BRM DATSTO
       SKN TLATE; BRU BCARDT
       MIN NUMBR; LDB =-2; LDX =2; LDA NTR; SKE =3; CBX; CXA
       LDX NUM; STIA MODE1; BRU BCARDT
*  L  -INITIAL ENTRY
*
BKRDL9 CLA; STA INVFLG; BRM DATSTO
       SKN TLATE; BRU BCARDT
       MIN NUMBL; LDA =3; LDX NUM; STIA MODE1; BRU BCARDT
*  R  -  INITIAL ENTRY
*
BKRDR9 CLA; STA INVFLG; BRM DATSTO
       SKN TLATE; BRU BCARDT
       MIN NUMBR
       LDA =2; LDX NUM; STIA MODE1; BRU BCARDT
BKRDE  SKN MOSTAT; BRU BKRDE3  INITIAL
       BRM MODSUB
       MDE NOE; SKN TLATE; BRU *+6
       LDX NUMMO
       LDA NUM; STIA MOBRN; LDA =3; STIA MOPARM
BKRDEE GCI INLPT2; BRU BCARDB
       SKE =17B; BRU *+2; BRU *+3; MDE INLPT2; BRU BCARDB
       BRM MODSUB; BRU BCARDB
BKRDI  SKN MOSTAT; BRU BKRDI3  INITIAL
       BRM MODSUB
       MDE NOI; SKN TLATE; BRU BKRDEE
       LDX NUMMO
       LDA NUM; STIA MOBRN; LDA =4; STIA MOPARM; BRU BKRDEE
*
*  SHOULD BE:
*      INITIAL:   TOFROM = -1  AND   NOEL = -1
*      MODIFY:   NOEL (OR) NOI (OR) NOE = -1
BCARDE  SKN MOSTAT; BRU BKARDE
       LDA NOEL; MRG NOE; MRG NOI
       SKA =4B7; BRU *+2; BRU BADK17  INCOMPLETE
       SKN TLATE; BRU NTRST1; BRR CLOOKY
BKARDE SKN NOEL; BRU BADK17  INCOMPLETE
       SKN TOFROM; BRU BADK17  INCOMPLETE
       SKN TLATE; BRU NTRST1; BRR CLOOKY
*  E  INITIAL  CHECKS FOR EO AND E0
*
BKRDE3 GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =20B; BRU *+2; BRU BKRDEI
       SKE =57B; BRU *+2; BRU BKRDEI
       SKE =35B; BRU BADK18  BAD CHAR
       SKN NOE; BRU *+3; MDE INLPT2; BRU BADK31 TOO MANY SOURCES
       LDX =-4; LDA DATAE,2; STA SOUDAT,2; BRX *-2
       BRM SOUDAT; MDE NOE; BRU BCARDB
       DATA E,EMIN,EMAX,EPHA
DATAE  EQU *
*  EO  E0   TR ONLY
BKRDEI LDA NTR; SKE =3; BRU BADK32  TR ONLY
       SKN NOIC; BRU *+2; BRU BADK33  TOO MANY
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =35B; BRU BADK18  BAD CHAR
       BRM NUMNOZ; SKN TLATE; BRU *+3
       LDX NUM; STFA E; MDE NOIC; BRU BCARDB
*  I  INITIAL  CHECKS FOR EO AND E0
*
BKRDI3 GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =20B; BRU *+2; BRU BKRDII
       SKE =57B; BRU *+2; BRU BKRDII
       SKE =35B; BRU BADK18  BAD CHAR
       SKN NOI; BRU *+3; MDE INLPT2; BRU BADK31  TOO MANY SOURCES
       LDX =-4; LDA DATAI,2; STA SOUDAT,2; BRX *-2
       BRM SOUDAT; MDE NOI; BRU BCARDB
       DATA AMP,AMPMIN,AMPMAX,AMPPHA
DATAI  EQU *
*  IO  I0  TR ONLY
BKRDII LDA NTR; SKE =3; BRU BADK32  TR ONLY
       SKN NOIC; BRU *+2; BRU BADK33  TOO MANY
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =35B; BRU BADK18  BAD CHAR
       BRM NUMNOZ; SKN TLATE; BRU *+3
       LDX NUM; STFA AMP; MDE NOIC; BRU BCARDB
*
*  SUBROUTINE FOR STORING C G L AND R DATA FOR INITIAL ENTRY
*
DATSTO ZRO
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =35B; BRU BADK18  BAD CHAR
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =10B; BRU DATST1
*  (N,N)  TR
*
       LDA NTR; SKE =3; BRU BADK18 BAD CHAR
       BRM NUMNOZ
       SKN TLATE; BRU *+5
       SKN INVFLG; BRM INVERT
       LDX NUM; STFA YMIN
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =14B; BRU BADK18  BAD CHAR
       BRM NUMNOZ
       SKN TLATE; BRU *+5
       SKN INVFLG; BRM INVERT
       LDX NUM; STFA YMAX
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =11B; BRU BADK18  BAD CHAR
       BRR DATSTO
*  INVERTER    SETS (A,B) = 1./(A,B)
*
INVERT ZRO
       STP FTEMP3; LDP FPONE; FDV FTEMP3; BRR INVERT
FTEMP3 BSS 2
INVFLG ZRO
*
*    N    N(N)     N(N,N)
*  A,D,T  DC        DC
DATST1 MDE INLPT2; BRM NUMNOZ; SKN TLATE; BRU DATST2
       SKN INVFLG; BRM INVERT
       LDX NUM; STFA YMIN; STFA YMAX
       XMA NTR; SKE =3; BRU *+3
       XMA NTR; BRR DATSTO
       XMA NTR; STFA Y
DATST2 GCI INLPT2; BRR DATSTO
       SKE =33B; BRU *+3; MDE INLPT2; BRR DATSTO
       SKE =14B; BRU *+3; MDE INLPT2; BRR DATSTO
       SKE =10B; BRU BADK18  BAD CHAR
       LDA NTR; SKE ONE; BRU BADK18  BAD CHAR
       BRM NUMNOZ
       SKN TLATE; BRU *+6
       SKN INVFLG; BRM INVERT
       LDX NUM
       STFA YMIN; STFA YMAX
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =14B; BRU DATST4
*  N(N,N)
       BRM NUMNOZ
       SKN TLATE; BRU DATST3
       SKN INVFLG; BRM INVERT
       LDX NUM
       SKN INVFLG; BRU *+3
       STFA YMAX; BRU *+2; STFA YMIN
DATST3 GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =11B; BRU BADK18; BRR DATSTO
*  N(N)
DATST4 SKE =11B; BRU BADK18  BAD CHAR
       SKN TLATE; BRR DATSTO
       SKN INVFLG; BRU DATST5
       LDX NUM
       LDFA Y; STP FTEMP1
       LDFA YMIN; STP FTEMP2
       BRS 21
       FAD FPONE
       FMP FTEMP1
       STFA YMIN
       LDP FTEMP2
       FAD FPONE
       FMP FTEMP1
       STFA YMAX
       BRR DATSTO
DATST5 LDX NUM
       LDFA Y; STP FTEMP1
       LDFA YMIN; BRM INVERT; STP FTEMP2
       FAD FPONE
       STP FTEMP3
       LDP FTEMP1
       FDV FTEMP3
       STFA YMIN
       LDP FPONE
       FSB FTEMP2
       STP FTEMP3
       LDP FTEMP1
       FDV FTEMP3
       STFA YMAX
       BRR DATSTO
*
*  GETS SOURCE DATA  (INITIAL)
*  FOR E AND I SUBGROUPS
*  USES INDIRECT TRANSFER ADDRESSES
*
XFRNOM BSS 1    FIRST  NOM
XFRMIN BSS 1    SECOND MIN
XFRMAX BSS 1    LAST   MAX
XFRPHA BSS 1    PHASE
SOUDAT ZRO
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =10B; BRU SOUDT1
* (N,N)
       LDA NTR; SKE =3; BRU BADK18  BAD CHAR
       BRM RNUMBR; SKN TLATE; BRU *+3
       LDX NUM; STFA* XFRMIN
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =14B; BRU BADK18  BAD CHAR
       BRM RNUMBR; SKN TLATE; BRU *+3
       LDX NUM; STFA* XFRMAX
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =11B; BRU BADK18  BAD CHAR; BRR SOUDAT
* N.....
SOUDT1 MDE INLPT2; BRM RNUMBR; SKN TLATE; BRU *+11
       LDX NUM; STFA* XFRMIN; STFA* XFRMAX
       XMA NTR; SKE =3; BRU *+3
       XMA NTR; BRR SOUDAT
       XMA NTR; STFA* XFRNOM
       GCI INLPT2; BRR SOUDAT
       SKE =33B; BRU *+3; MDE INLPT2; BRR SOUDAT
       SKE =14B; BRU *+3; MDE INLPT2; BRR SOUDAT
       SKE =17B; BRU SOUDT2
* N/N
       LDA NTR; SKE =2; BRU BADK18  BAD CHAR
       BRM RNUMBR; SKN TLATE; BRR SOUDAT
       FMP PID180; LDX NUM
       STFA* XFRPHA; BRR SOUDAT
PID180 DATA 21676431B,67013773B  PI/180   .01745329
*
*  N(N)   N(N,N)   DC ONLY
*
SOUDT2 SKE =10B; BRU BADK18  BAD CHAR
       LDA NTR; SKE ONE; BRU BADK18  BAD CHAR
       BRM RNUMBR; SKN TLATE; BRU *+5
       LDX NUM; STFA* XFRMIN; STFA* XFRMAX; STP FTEMP1
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =14B; BRU SOUDT3
       BRM RNUMBR; SKN TLATE; BRU *+3
       LDX NUM; STFA* XFRMAX
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =11B; BRU BADK18  BAD CHAR
       BRR SOUDAT
*  N(N)  =>>> N)
*
SOUDT3 SKE =11B; BRU BADK18  BAD CHAR
       SKN TLATE; BRR SOUDAT
       LDX NUM; LDFA* XFRNOM; STP FTEMP2
       SKA =4B7; BRS 21
       FMP FTEMP1; STP FTEMP1
       LDP FTEMP2; FSB FTEMP1; STFA* XFRMIN
       LDP FTEMP2; FAD FTEMP1; STFA* XFRMAX; BRR SOUDAT




*                   I   -   C A R D
*
*                          5 MAX
*
*                      TR ONLY
*
*              (K),---,---,---,---    (50 ENTRIES)
*      INN     P(K),---,---,---,---   (50 ENTRIES)
*              SIN(K),V1,V0,T0
*
*
ICARDR LDA NTR; SKE =3; BRU INVIGN
       LDA KI; ADD ONE; SKG =5; BRU *+2; BRU BADK34  TOO MANY 5 MAX
       SKN TLATE; BRU *+2; MIN KI
       GCI INLPT2; NOP
       BRM GETNMI; BRS 50; SKG DBRNCH; BRU *+2; BRU BADK25  SER.TOO HIGH
       SKN TLATE; BRU ICARD1
       LDX KI; STIA LISTI
       STX COLUMN; LDX =2; STX ARYROW
       BRM ARYPOS; LDP FPONE; BRS 21; STFA ATIME
ICARD1 LDA ONES; STA KELAST; STA M1
       LDA ONE; STA M2
       LDA =ICARDE; STA CONTR  DEFINE ENTRY POINT FOR CONTINUE
       MDE INLPT2; GCI INLPT2; BRU BADK17
       GCI INLPT2; BRU ICARDL
       SKE =10B; BRU *+2; BRU ICARDT
       SKE =60B; BRU *+2; BRU ICARDP
       SKE =63B; BRU BADK18
* SIN
       GCI INLPT2; BRU BADK17
       SKE =51B; BRU BADK18
       GCI INLPT2; BRU BADK17
       SKE =56B; BRU BADK18
       GCI INLPT2; BRU BADK17
       SKE =10B; BRU BADK18
       SKN TLATE; BRU *+4
       LDP FPONE; BRM ARYPOS; STFA ATIME
       BRM NUMNOZ; LDX M2; STX ARYROW
       SKN TLATE; BRU *+3
       BRM ARYPOS; STFA ATIME
       GCI INLPT2; BRU BADK17
       SKE =11B; BRU BADK18
       GCI INLPT2; BRU BADK17
       SKE =14B; BRU BADK18
       BRU ICARDE
* P(K)
ICARDP GCI INLPT2; BRU BADK17
       SKE =10B; BRU BADK18
       SKN TLATE; BRU ICARDT
       CLAB; BRM ARYPOS; STFA ATIME
* (K)
ICARDT BRM NUMNOZ; LDX M2; STX ARYROW
       SKN TLATE; BRU *+3
       BRM ARYPOS; STFA ATIME
       GCI INLPT2; BRU BADK17
       SKE =11B; BRU BADK18
       GCI INLPT2; BRU BADK17
       SKE =14B; BRU BADK18
       BRU ICARDE
ICARDL SKN TLATE; BRU *+2; BRR CLOOKY
       MIN KI; BRU NTRST1
*  ENTRY POINT FOR I-CARD CONTINUE
*
ICARDE BRM SAMPTR
       GCI INLPT2; BRU ICARDL
       SKE =33B; BRU *+3; MDE INLPT2; BRU ICARDL
       SKE =14B; BRU BADK18
       BRU ICARDE
*  STORES DATA AND CHECKS FOR LIMIT OF 50
*
SAMPTR ZRO
       LDA INLPT2; STA CPOINT
       SIC INLPT2; BRU BADK3
       SKN TLATE; BRU SAMPT1
       BRM ARYPOS; STFA AMPTR; LDX COLUMN; LDA ARYROW; STIA NUMI
SAMPT1 MIN ARYROW; LDA ARYROW; SKG =50; BRR SAMPTR
       SNDA SOUERR; BRU IGNORE
SOUERR ASC '$TOO MANY TIME-DEPENDENT SOURCES (50 MAX) -- IGNORED$/'
*
*  RETURNS ARRAY POSITION IN X-REGISTER
*  FOR 2-DIM ARRAYS SO AS TO BE ABLE TO USE: STIA  LDIA  STFA  LDFA
*
*              (N1,N2)
*
*      N1  COLUMN
*      N2  ARYROW
*
*  NOTE:  THE "MUL =5" BECAUSE ARRAYS HERE ARE  XX(5,XX)
*
ARYPOS ZRO
       STP REGSAV
       LDA ARYROW; SUB ONE; MUL =5; LSH 23
       ADD COLUMN; CAX
       LDP REGSAV
       BRR ARYPOS
REGSAV BSS 2
ARYROW ZRO
COLUMN ZRO



*                   E   -   C A R D
*
*                       5 MAX
*
*                     TR ONLY
*
*              (K),---,---,---,---    (50 ENTRIES)
*      ENN     P(K),---,---,---,---    (50 ENTRIES)
*              SIN(K),I1,I0,T0
*
*
ECARDR LDA NTR; SKE =3; BRU INVIGN
       LDA KE; ADD ONE; SKG =5; BRU *+2; BRU BADK34
       SKN TLATE; BRU *+2; MIN KE
       GCI INLPT2; NOP
       BRM GETNMI; BRS 50; SKG DBRNCH; BRU *+2; BRU BADK25
       SKN TLATE; BRU ECARD1
       LDX KE; STIA LISTE
       STX COLUMN; LDX =2; STX ARYROW
       BRM ARYPOS; LDP FPONE; BRS 21; STFA ETIME
ECARD1 LDA ONES; STA M1
       LDA ONE; STA KELAST; STA M2
       LDA =ECARDE; STA CONTR    SETS UP CONTINUE LOCATION
       MDE INLPT2; GCI INLPT2; BRU BADK17
       GCI INLPT2; BRU BADK17
       SKE =10B; BRU *+2; BRU ECARDT
       SKE =60B; BRU *+2; BRU ECARDP
       SKE =63B; BRU BADK18
* SIN
       GCI INLPT2; BRU BADK17
       SKE =51B; BRU BADK18
       GCI INLPT2; BRU BADK17
       SKE =56B; BRU BADK18
       GCI INLPT2; BRU BADK17
       SKE =10B; BRU BADK18
       SKN TLATE; BRU *+4
       LDP FPONE; BRM ARYPOS; STFA ETIME
       BRM NUMNOZ; LDX M2; STX ARYROW
       SKN TLATE; BRU *+3
       BRM ARYPOS; STFA ETIME
       GCI INLPT2; BRU BADK17; SKE =11B; BRU BADK18
       GCI INLPT2; BRU BADK17; SKE =14B; BRU BADK18; BRU ECARDE
* P(K)
ECARDP GCI INLPT2; BRU BADK17
       SKE =10B; BRU BADK18
       SKN TLATE; BRU ECARDT
       CLAB; BRM ARYPOS; STFA ETIME
* (K)
ECARDT BRM NUMNOZ; LDX M2; STX ARYROW
       SKN TLATE; BRU *+3
       BRM ARYPOS; STFA ETIME
       GCI INLPT2; BRU BADK17
       SKE =11B; BRU BADK18
       GCI INLPT2; BRU BADK17
       SKE =14B; BRU BADK18
       BRU ECARDE
ECARDL SKN TLATE; BRU *+2; BRR CLOOKY; MIN KE; BRU NTRST1
*  ENTRY POINT FOR E-CARD CONTINUE
*
ECARDE BRM SETR
       GCI INLPT2; BRU ECARDL
       SKE =33B; BRU *+3; MDE INLPT2; BRU ECARDL
       SKE =14B; BRU BADK18; BRU ECARDE
*  STORES DATA AND CHECKS FOR LIMIT OF 50
*
SETR   ZRO
       LDA INLPT2; STA CPOINT; SIC INLPT2; BRU BADK3
       SKN TLATE; BRU SETR1
       BRM ARYPOS; STFA ETR; LDX COLUMN; LDA ARYROW; STIA NUME
SETR1  MIN ARYROW; LDA ARYROW; SKG =50; BRR SETR
       SNDA SOUERR; BRU IGNORE


*    CONTINUE OF E AND I CARDS
*      MUST BE FIRST STATEMENT FOLLOWING E OR I SPEC
*
*
CONTKD LDA NTR; SKE =3; BRU INVIGN
       SKN M1; BRU INVIGN; GCI INLPT2; NOP; BRU* CONTR
CONTR  ZRO



**EOC**


*  GETS FROM AND TO NODES/BRANCHES
*
*  GETFRE GETS "FROM" ELEMENT, RETURNS AS A POSITIVE (>=0)
*  INTEGER IN THE A-REGISTER
*      (N,N),...       ,N),...
*
*  GETTOE GETS "TO" ELEMENT, RETURNS AS A POSITIVE (>=0)
*  INTEGER IN THE A-REGISTER
*      ,N),...        ,...
*
*  BOTH ROUTINES BRANCH TO APPLICABLE ERROR ROUTINES
*
GETFRE ZRO
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =10B; BRU BADK18  BAD CHAR
       BRM GTFTNI
       BRR GETFRE
GETTOE ZRO
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =14B; BRU BADK18  BAD CHAR
       BRM GTFTNI
       STA GTFTNI
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =11B; BRU BADK18  BAD CHAR
       LDA GTFTNI; BRR GETTOE

*  GETS AND RETURNS A POSITIVE (>=0) INTEGER
*
GTFTNI ZRO
       LDA INLPT2; STA CPOINT
       SIC INLPT2; BRU BADK3  OVERFLOW
       SKA =4B7; BRU BADK2  NEGATIVE
       BRS 50  FIX
       BRR GTFTNI


*  HANDLES:    N    N(N)N    N(N)     N(N,N)
*  FOR MODIFY ROUTINE
*
MODSUB ZRO
       BRM MODDER
       GCI INLPT2; BRU BADK17; SKE =35B; MDE INLPT2
       BRM RNUMBR
       SKN TLATE; BRU *+5
       LDX NUMMO
       STFA VFIRST; STFA VSECND; STFA VLAST
       GCI INLPT2; BRR MODSUB
       SKE =10B; BRU *+2; BRU *+3; MDE INLPT2; BRR MODSUB
       BRM RNUMBR
       SKN TLATE; BRU *+4
       LDX NUMMO
       STFA VSECND; STFA VLAST
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =14B; BRU MODSB1   N(N)  N(N)N
*  N(N,N)
       BRM RNUMBR
       SKN TLATE; BRU *+3
       LDX NUMMO; STFA VLAST
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =11B; BRU BADK18  BAD CHAR
       BRR MODSUB
MODSB1 SKE =11B; BRU BADK18  BAD CHAR
       GCI INLPT2; BRU *+13  N(N)
       SKE =33B; BRU *+2; BRU *+3  N(N)
       SKE =14B; BRU MODSB2   N(N)N
       LDA NTR; SKE ONE; BRU BADK18  BAD CHAR
       MDE INLPT2; SKN TLATE; BRR MODSUB; BRU *+6
       LDA NTR; SKE ONE; BRU BADK18; SKN TLATE; BRR MODSUB
       LDX NUMMO; LDFA VFIRST; STP FTEMP1
       SKA =4B7; BRS 21; STP FTEMP2
       LDFA VSECND; FMP FTEMP2; STP FTEMP2
       LDP FTEMP1; FSB FTEMP2; STFA VSECND
       LDP FTEMP1; FAD FTEMP2; STFA VLAST; BRR MODSUB
MODSB2 MDE INLPT2; BRM RNUMBR
       SKN TLATE; BRR MODSUB
       LDX NUMMO; STFA VLAST
       LDFA VSECND; BRS 50
       STIA MOSTEP; BRR MODSUB
FTEMP1 BSS 2
FTEMP2 BSS 2
*  EXTRACTS AND STORES NUMBERS FOR MODIFY
*
*  ON:   X=N    X=N(N)N   SUBGROUPS
*
*
PARMOD ZRO
       BRM RNUMBR
       SKN TLATE; BRU *+5
       LDX NUMMO
       STFA VFIRST; STFA VSECND; STFA VLAST
       GCI INLPT2; BRR PARMOD
       SKE =10B; BRU BADK18  BAD CHAR
       BRM RNUMBR
       SKN TLATE; BRU *+4
       LDX NUMMO
       STFA VSECND; STFA VLAST
       GCI INLPT2; BRU BADK17  INCOMPLETE
       SKE =11B; BRU BADK18  BAD CHAR
       BRM RNUMBR
       SKN TLATE; BRR PARMOD
       LDX NUMMO
       STFA VLAST
       LDFA VSECND; BRS 50; STIA MOSTEP; BRR PARMOD

*  COMMENT HANDLER
*
COMMNT MDE INLPT2; SKN TLATE; BRU NTRST1; BRR CLOOKY

*  CALLS FOR CONVERSION OF A REAL NUMBER
*
RNUMBR ZRO
       LDA INLPT2; STA CPOINT
       SIC INLPT2; BRU BADK3; BRR RNUMBR

*
*  GETS AND RETURNS A NON-ZERO NUMBER
*
NUMNOZ ZRO
       LDA INLPT2; STA CPOINT
       SIC INLPT2; BRU BADK3  OVERFLOW
       SKE ZERO; BRR NUMNOZ; BRU BADK22  ZERO

*  IGNORES A STATEMENT
*
IGNORE GCI INLPT2; BRU *+4
       SKE =33B; BRU IGNORE
       MDE INLPT2
       LDA INLPT1; LDB INLPT2; LDX ONE; BRS 35; TCO =155B
       STB INLPT1; STB CMPRSP; BRU CLOOK1

******************************

*  ERROR NOTIFICATION AND BRANCH TO FORCED EDIT MODE ROUTINE
*
BADK1  SNDA    MGBD1
       PSTR    INLPT1
       SNDA    MGBD
       BRU     4CEDIT
BADK2  SNDA    MGBD2
       PSTR    INLPT1
       BRM     EPOINT
       BRU     4CEDIT
BADK3  SNDA    MGBD3
       BRU     BADK2+1
BADK4  SNDA    MGBD1
       BRU     BADK2+1
BADK5  SNDA    MGBD5
       BRU     BADK2+1
BADK6  SNDA    MGBD6
       BRU     BADK1+1
BADK7  SNDA    MGBD7
       LDA     COMPTR+1
       STA     CPOINT
       BRU     BADK2+1
BADK8  SNDA    MGBD8
       BRU     BADK1+1
BADK9  SNDA MGBD9; BRU BADK2+1
MGBD9  ASC '$NODE NUMBERS MUST BE BETWEEN 1 AND 20 INCLUSIVE -- PLEASE EDIT$ /'
BADK10 GCI INLPT2; BRU *+4; SKE =33B; BRU *-3
       MDE INLPT2; TCO =155B; LDA INLPT1; LDB INLPT2; LDX =1
       BRS 35; SNDA MGMMNY; LDA INLPT2; STA INLPT1; STA CMPRSP
       MDE NUMMO; BRU CLOOK1
MGMMNY ASC '$NUMBER OF MODIFICATIONS HAS EXCEEDED 20 -- STATEMENT IGNORED$/'
BADK11 SNDA MGBD11
       MDE NUMMO
       MDE INLPT2
       LDA INLPT2; STA CPOINT; BRU BADK2+1
MGBD11 ASC '$ILLEGAL CHARACTER -- PLEASE EDIT$ /'
BADK12 SNDA MGBD12; BRU BADK11+2
MGBD12 ASC '$INVALID SPECIFICATION -- PLEASE EDIT$ /'
BADK13 SNDA MGBD13; BRU BADK11+3
MGBD13 ASC '$INVALID OUTPUT SPECIFICATION -- PLEASE EDIT$ /'
BADK14 SNDA MGBD14; BRU BADK11+3
MGBD14 ASC '$OUTPUT VALID FOR DC ONLY -- PLEASE REMOVE$ /'
BADK15 SNDA MGBD15; BRU BADK11+2
MGBD15 ASC '$SELECTIVE OUTPUT FOR THIS PARAMETER SHOULD BE SPECIFIED ON A$S'
       ASC 'OLUTION CONTROL STATEMENT -- PLEASE EDIT$ /'
BADK16 SNDA MGBD16; BRU BADK11+3
MGBD16 ASC '$TOO MANY PARAMETERS IN OUTPUT BLOCK (6 MAX) -- PLEASE EDIT$ /'
BADK17 SNDA MGBD1; BRU BADK11+3
BADK18 SNDA MGBD11; BRU BADK11+2
BADK19 SNDA MGBD19; BRU BADK11+3
MGBD19 ASC '$OUTPUT VALID FOR AC ONLY -- PLEASE REMOVE$ /'
BADK20 SNDA MGBD20
       BRU BADK2+1
MGBD20 ASC '$SERIAL NUMBER TOO LARGE (10 MAX) -- PLEASE EDIT$ /'
BADK21 SNDA MGBD21
       BRU IGNORE
MGBD21 ASC '$TOO MANY M-CARDS (10 MAX) -- IGNORED$/'
BADK22 SNDA MGBD22
       BRU BADK2+1
MGBD22 ASC '$NUMBER MUST BE NON-ZERO -- PLEASE EDIT$ /'
BADK23 SNDA MGBD23
       BRU BADK11+2
MGBD23 ASC '$TOO MANY ELEMENTS ON CARD -- PLEASE EDIT$ /'
BADK24 SNDA MGBD24
       BRU BADK2+1
MGBD24 ASC '$BRANCH NUMBER TOO HIGH (60 MAX) -- PLEASE EDIT$ /'
BADK25 SNDA MGBD25
       BRU BADK2+1
MGBD25 ASC '$SERIAL NUMBER TOO LARGE (60 MAX) -- PLEASE EDIT$ /'
BADK26 SNDA MGBD26
       BRU IGNORE
MGBD26 ASC '$TOO MANY S-CARDS -- IGNORED$/'
BADK27 SNDA MGBD27
       BRU BADK1+1
MGBD27 ASC '$TOO MANY SWITCHED BRANCHES (60 MAX) -- PLEASE EDIT$ /'
BADK28 SNDA MGBD28
       BRU IGNORE
MGBD28 ASC '$TOO MANY T-CARDS (10 MAX) -- IGNORED$/'
BADK29 SNDA MGBD29
       BRU IGNORE
MGBD29 ASC '$TOO MANY BRANCHES (60 MAX) -- IGNORED$/'
BADK30 SNDA MGBD30
       BRU BADK2+1
MGBD30 ASC '$NODE NUMBER TOO HIGH (20 MAX) -- PLEASE EDIT$ /'
BADK31 SNDA MGBD31
       BRU BADK11+2
MGBD31 ASC '$TOO MANY SOURCES -- PLEASE EDIT$ /'
BADK32 SNDA MGBD32
       BRU BADK11+2
MGBD32 ASC '$VALID FOR TRANSIENT ANALYSIS ONLY -- PLEASE EDIT$ /'
BADK33 SNDA MGBD33
       BRU BADK2+1
MGBD33 ASC '$TOO MANY INITIAL CONDITIONS -- PLEASE EDIT$ /'
BADK34 SNDA TMNYSK
       BRU IGNORE
TMNYSK ASC '$TOO MANY TIME-DEPENDENT SOURCE CARDS (5 MAX) -- IGNORED$/'
MGBD   ASC     '$?/'
MGBD1  ASC     '$INCOMPLETE STATEMENT -- PLEASE EDIT$ /'
MGBD2  ASC     '$NUMBER MUST BE GREATER THAN ZERO -- PLEASE EDIT$ /'
MGBD3  ASC     '$NUMBER TOO LARGE -- PLEASE EDIT$ /'
MGBD5  ASC     '$NUMBER MUST BE >= ZERO -- PLEASE EDIT$ /'
MGBD6  ASC     '$UNIDENTIFIABLE STATEMENT -- PLEASE RE-ENTER$ /'
MGBD7  ASC     '$NO SERIAL NUMBER -- PLEASE EDIT$ /'
MGBD8  ASC     '$AMBIGUOUS COMMAND -- TYPE MORE CHARACTERS$ /'

*  TYPES AN ARROW POINTING TO AN ERROR
*
EPOINT ZRO
       TCO =155B; LDA INLPT1; SUB CPOINT; CAX; EAX -1,2; TCO ZERO; BRX *-1
       TCO =76B; SNDA MGBD; BRR EPOINT
CPOINT ZRO

*  FORCED EDIT ROUTINE
*
       SNDA MGBD
4CEDIT CLA
       STA INFILE
       LDA ONES
       STA EDSTAT
       STRING INLPT1
       NOP
       CMPRS PTRNEW; BRU 4CEDIT-1; LDP CMPRSP; STP INLPT1
       STP INLPT2; BRU CLOOK1

**BOC**

*
*     L I S T   O F   T E X T   B L O C K
*
LGLIST SKN XXXINS; BRU *+4; SKN LNGEDT; BRU HOOHAH; BRU EDBUBU
       LDA CLOOKY; STA COMRTN
       LDA BLKNOS; SKG ZERO; BRU PRQUES
       LDA =LSTALT; BRM ALTMDY
       GCI INLPT2; BRU LGLST1
       SKE ZERO; BRU *-3
       GCI INLPT2; BRU PRQUES
       SKG ZERO; BRU *-3
       MDE INLPT2
       RANGE INLPT2; BRU PRQUES
       TCO =155B; BRM LISTER; TCO =155B
       BRR COMRTN
LGLST1 LDA ONE; SUB BLKNOS; STA POSCTR
       LDX =30000B; BRU *-8
LSTALT CLA; STA ALTFLG; BRR COMRTN

*
*      D E L E T E   O F    T E X T   B L O C K
*
LGDELE SKN XXXINS; BRU *+4; SKN LNGEDT; BRU HOOHAH; BRU EDBUBU
       LDA CLOOKY; STA COMRTN
       LDA BLKNOS; SKG ZERO; BRU PRQUES
       GCI INLPT2; BRU PRQUES
       SKE ZERO; BRU *-3
       GCI INLPT2; BRU PRQUES
       SKG ZERO; BRU *-3
       MDE INLPT2
       BRM ALTMDN
       RANGE INLPT2; BRU PRQUES
       LDA BEGLOC; SKE ONE; BRU *+2; BRU PRQUES
       BRM DELETM
       SKN MOSTAT; BRM BSCAN
       BRU LSTALT


COMRTN ZRO
PRQUES SND BOOBOO
       BRU LSTALT
BOOBOO ASC '?$$/'

*
*    I N S E R T   T E X T   A H E A D   O F    O L D
*
LGINSR SKN XXXINS; BRU *+4; SKN LNGEDT; BRU HOOHAH; BRU EDBUBU
       LDA CLOOKY; STA COMRTN
       LDA BLKNOS; SKG ZERO; BRU PRQUES
       GCI INLPT2; BRU PRQUES
       SKE ZERO; BRU *-3
       GCI INLPT2; BRU PRQUES
       SKG ZERO; BRU *-3
       MDE INLPT2
       RANGE INLPT2; BRU PRQUES
       LDA BEGLOC; SKE ONE; BRU *+2; BRU PRQUES
       SKE ENDLOC; BRU PRQUES
       BRM INSRT1
       TCO  =155B
LGINST LDA =INSALT; BRM ALTMDY
       SNDA INSGLT
       CLA; STA EDSTAT; STA INFILE
       STRING; NOP
       SKE ONES; BRU *+4
       SNDA CRCR
INSALT BRM INSRT2
       BRU LSTALT
       CMPRS PTRNEW; BRU LGINST
       LDP CMPRSP; STP INLPT1; STP INLPT2
       BRM CLOOKY; BRU LGINST
INSGLT ASC ' /'

HOOHAH SNDA HAHHOO
       BRU LGINST
HAHHOO ASC '$NO DIRECT COMMANDS DURING INSERT MODE -- IGNORED$$/'


*
*        T E X T   B U F F E R   E D I T I N G   D R I V E R
*
*        SCHEME:  RETRIEVE - INSERT - DELETE
*
*
LGEDIT SKN XXXINS; BRU *+4; SKN LNGEDT; BRU HOOHAH; BRU EDBUBU
       LDA CLOOKY; STA COMRTN
       LDA BLKNOS; SKG ZERO; BRU PRQUES
       GCI INLPT2; BRU PRQUES
       SKE ZERO; BRU *-3
       GCI INLPT2; BRU PRQUES
       SKG ZERO; BRU *-3; MDE INLPT2
       RANGE INLPT2; BRU PRQUES
       LDA BEGLOC; SKG ONE; BRU PRQUES; STA BLKED1
       LDA ENDLOC; STA BLKED2; CLA; STA POSCTR
       TCO =155B; LDA =LGED5; BRM ALTMDY
       CXA; ETR =37777B; CAX
       SKR LNGEDT; NOP
LGED1  STX BLKNOW; BRM INSRT1
       LDX BLKNOW
       LDB 0,2; CLA; LCY 9; STA CHRNOW; CLA; STA INFILE
       LCY 15; STA BLKNXT; CXA
       MUL =3; LSH 23; ADD =5; CAB; ADD CHRNOW; XAB; STP XXXPTR
       LDA ONES; STA EDSTAT; STA PRNTST; TCO ZERO
       STRING XXXPTR; NOP
       SKE ONES; BRU LGED2
       LDP PTROLD; LDX ONE; BRS 35; TCO =155B; STP XFRPTR
       PUTB; BRU LGED3
LGED2  CMPRS PTRNEW; BRU LGED3  NULL- TO DELETE OLD LINE
       LDP CMPRSP; STP INLPT1; STP INLPT2; BRM CLOOKY
LGED3  BRM INSRT2; LDX BLKNOW; BRM DELETM; SKN MOSTAT; BRM BSCAN
       MIN BLKED1; LDA BLKED1; SKG BLKED2; BRU LGED4
LGEDLV TCO =155B; CLA; STA ALTFLG; STA LNGEDT
       SKN MOSTAT; BRM BSCAN; BRR COMRTN
LGED4  LDX BLKNXT; BRU LGED1
LGED5  BRM INSRT2; BRU LGEDLV
EDBUBU SNDA BUBUED; BRM INSRT2; LDX BLKNOW; BRU LGED1
BUBUED ASC '$NO DIRECT COMMANDS DURING EDIT MODE -- IGNORED$$/'
BLKNXT ZRO
BLKNOW ZRO
CHRNOW ZRO
BLKED1 ZRO
BLKED2 ZRO
XXXPTR BSS  2
LNGEDT DATA 0


*  USED WHEN FIXING OR REPAIRING THE TEXT BUFFER
*
BSCAN  ZRO
       CLA; STA PUTFLG; BRM CZERO; BRM MOVER; BRM CZERO; BRM INIVAR
       LDA =2; BRM GETPOS
BSCAN1 STX BSCANX
       LDB 0,2; CLA; LCY 9; SKG ZERO; BRU BSCANE
       STA BSCANS; CXA; ETR =37777B; MUL =3; LSH 23; ADD =5
       CAB; ADD BSCANS; XAB; STP CMPRSP; STP INLPT1; STP INLPT2
       BRM CLOOKY; LDX* BSCANX; BRU BSCAN1
BSCANE MDE PUTFLG; BRR BSCAN
BSCANX ZRO
BSCANS ZRO
PUTFLG EQU 51B    PUTB FLAG (NO PUT IN BUF. DURING BSCAN)


*  PRINTS OUT HELP MESSAGE
*
HELPER SKN XXXINS; BRU *+4; SKN LNGEDT; BRU HOOHAH; BRU EDBUBU
       LDA CLOOKY; STA COMRTN
       PTX HLPMSG
       BRR COMRTN


*    G O   A F T E R   A   P A U S E
*
LGGOGO SKN XXXINS; BRU *+4; SKN LNGEDT; BRU HOOHAH; BRU EDBUBU
       LDA CLOOKY; STA COMRTN
       SKN PAUFLG; BRU *+2; BRU *+3
       SNDA NOGO; BRR COMRTN; MIN PAUFLG; BRU* PAUBRU

*      P A U S E R
*
PAUEXE SNDA PAUM3; LDA =EXER1; STA PAUBRU
       MDE PAUFLG; BRU INLPAU
PAUANL SNDA PAUM1; BRM MOVER; BRU PAUST1
INLPAZ LDA IF; SKG ZERO; BRU INLNTR; SNDA PAUM2
PAUST1 LDA =INLNTR; STA PAUBRU; MDE PAUFLG
INLPAU LDA =INLPAU; BRM ALTMDY
       CLA; STA EDSTAT; STA INFILE; SNDA ACLGLT
       STRING; NOP
       CMPRS PTRNEW; BRU INLPAU
       LDP CMPRSP; STP INLPT1; STP INLPT2
       BRM CLOOKY; BRU INLPAU
PAUBRU ZRO
PAUFLG DATA 0  GO IF = -1
NOGO   ASC 'NO GO$/'
PAUM1  ASC '$$PAUSE AFTER COMPUTE$$/'
PAUM2  ASC '$$PAUSE AFTER INTERRUPT$$/'
PAUM3  ASC '$$PAUSE AFTER INPUT$$/'

PAUCMP ZRO
       LDA ONES; STA ESCOMP; LDA IOPTON; SKA ONE; BRR PAUCMP
       SNDA PAUCP1; LDA IF; SKG ZERO; BRR PAUCMP
       SNDA PAUCP2; CIO ZERO; SKE ='   Y'; BRU *+3
       BRM WASTE; BRR PAUCMP
       BRM WASTE; LDA IF; SKE ZERO; BRS 20; CLAB; STA IF; STP PTIFIL
       LDA OF; ETR =77B; SKE ONE; BRS 20; LDA =43000001B; STA OF
       BRR PAUCMP
WASTE  ZRO
       SKG =155B; SKG =151B; BRU *+2; BRR WASTE
       CIO ZERO; SKG =77B; BRU *-2; BRR WASTE
ESCOMP EQU 21B
PAUCP1 ASC '$INTERRUPTED DURING COMPUTE$/'
PAUCP2 ASC 'CONTINUE? /'


*    SETS COUNTERS FOR CARDS
*
NULKRD ZRO
       CLA; STA NOEL; STA NOE; STA NOI; STA NOIC
       STA TOFROM; BRR NULKRD
TOFROM BSS 1  =-1 IF (N,N) WAS ENTERED, =0 IF NOT

*  'SAVE' AND 'LIST' OPTIONS SUBROUTINE
*
SAVLIS ZRO
       LDA IOPTON; SKA =10B; BRU *+2; BRU SAVER1
       LDP PTSAVE; MRG =104B5; LDX =3; BRS 65; BRU *+7
       STA SF; RSP SF; MRG =4B7; SCP SF; BRU *+5; BRU SAVER1
       LDA =2; STA SF; BRU SAVER1; LDA SF; BRS 20; BRU *-5
SAVER1 LDA IOPTON; SKA =1B3; BRU *+2; BRU *+5; LDA =155B; CIO OF
       CIO OF; CIO OF; LDA STBLK; BRM GETPOS
SAVER2 STX BLKNOW
       LDB 0,2; CLA; LCY 9; SKG ZERO; BRU SAVLSG
       STA CHRNOW; CXA; ETR =37777B; MUL =3; LSH 23; ADD =5
       CAB; ADD CHRNOW; STF TPTR
       LDA IOPTON; SKA =1B3; PCKT OF
       LDA IOPTON; SKA =10B; BRU *+2; BRU SAVER3
       LDA SF; SKE =2; PCKT SF
SAVER3 LDX* BLKNOW; BRU SAVER2
SAVLSG LDA SF; BRS 20
       LDA =2; STA SF; BRR SAVLIS

*  RETURNS ADDRESS OF FIRST BLOCK TO PRINT IN X-REGISTER
*
GETPOS ZRO
       CLX; STX POSCTR
       LDX =30000B; MIN POSCTR
       SKE POSCTR; BRU *+2; BRR GETPOS
       CAB; LDA 0,2; ETR =37777B; COPY AX,BA; BRU *-8

*  'DATE' OPTION SUBROUTINE
*
DATOPT ZRO
       SKN MOSTAT; BRU *+2; BRR DATOPT
       LDA IOPTON; SKA =2B4; BRU *+2; BRR DATOPT
       LDA =STRTMP; MUL =3; LSH 23; SUB ONE; CAB; STP TPTR
       LDA =TYMECP; MUL =3; LSH 23; SUB ONE; CAB; ADD =13
       STF TPTR1
       GCI TPTR1; BRU *+3; WCI TPTR; BRU *-3
       LDX =-4; CLA; WCI TPTR; BRX *-1; DAT TPTR
       LDX =-4; CLA; WCI TPTR; BRX *-1
       LDA =PROGRM; MUL =3; LSH 23; SUB ONE; CAB; ADD =10; STF TPTR1
       GCI TPTR1; BRU *+3; WCI TPTR; BRU *-3
       LDA IF; SKG ZERO; BRU *+7; LDP PTIFIL; STP TPTR1
       GCI TPTR1; BRU *+5; WCI TPTR; BRU *-3
       LDA =64B; WCI TPTR
       LDA OF; ETR =77B; SKE ONE; BRU *+5
       LDX =-5; LDA =155B; CIO OF; BRX *-1
       LDF TPTR; SUB TPTR; ADD =-72; RSH 1
       COPY AX,A; CIO OF; BRX *-1
       LDP TPTR; LDX OF; BRS 35; BRR DATOPT
TYMECP ASC 'TYMSHARE ECAP'
PROGRM ASC 'PROGRAM:  '

*  'TIME' OPTION SUBROUTINES
*
SETIME ZRO
       LDA ONE; BRS 89; BRR SETIME
RDTIME ZRO
       LDA IOPTON; SKA =1B4; BRU *+2; BRU RDTIM1
       LDA =7; BRS 89
       LDA =STRTMP; MUL =3; LSH 23; SUB ONE; CAB; STP TPTR
       LDA =155B; WCI TPTR; WCI TPTR; WCI TPTR
       LDB TIMEOJ; LDX =-3; CLA; LCY 8; WCI TPTR; BRX *-3
       LDX =-7; CLA; WCI TPTR; BRX *-1
       LDB TIMCPU; LDX =-3; CLA; LCY 8; WCI TPTR; BRX *-3
       CLA; WCI TPTR; WCI TPTR
       LDA TIME1B; SUB TIME1A; TIM TPTR
       LDX =-7; CLA; WCI TPTR; BRX *-1
       LDA =TIMTER; MUL =3; LSH 23; SUB ONE; CAB; ADD =8
       XAB; STP TPTR1
       GCI TPTR1; BRU *+3; WCI TPTR; BRU *-3
       CLA; WCI TPTR; WCI TPTR
       LDA TIME2B; SUB TIME2A; TIM TPTR
       LDA =155B; WCI TPTR; WCI TPTR
       LDP TPTR; LDX OF; BRS 35
RDTIM1 BRM SETIME; BRR RDTIME
TIMEOJ ASC 'EOJ'
TIMCPU ASC 'CPU'
TIMTER ASC 'TERMINAL'
TIME1A EQU  5   NEW STARTING CPU TIME
TIME2A EQU  6   NEW STARTING TERMINAL TIME
TIME1B EQU 13B  CURRENT CPU TIME
TIME2B EQU 14B  CURRENT TERMINAL TIME


*    B E G I N S   E X E C U T I O N   ! ! ! ! !
*
*
EXECUT SKN XXXINS; BRU *+4; SKN LNGEDT; BRU HOOHAH; BRU EDBUBU
       SKN TLATE; BRU *+2; BRU EXED
       LDA MF; SKE =2; BRS 20; LDA =2; STA MF
       LDP INLPT2; STP XFRPTR
       PUTB
       LDA IOPTON; SKA ONE; BRU PAUEXE
EXER1  BRM ALTMDN; BRM MOVER
       LDA ONES; STA TLATE
       MIN STBLK; LDA STBLK; BRM GETPOS
EXER2  STX BLKNOW
       LDB 0,2; CLA; LCY 9; SKG ZERO; BRU EXED
       STA CHRNOW; CXA; ETR =37777B
       MUL =3; LSH 23; ADD =5; CAB
       ADD CHRNOW; XAB; STP CMPRSP; STP INLPT1; STP INLPT2
       BRM CLOOKY; LDX* BLKNOW; BRU EXER2
EXED   SKN MOSTAT; BRU *+2; BRU EXEL1
       LDA =3; STA IRTN
       LDA NTR; SKG =2; BRU EXER3
       LDA NEQUIM; SKE ZERO; BRM TTRADE
EXER3  LDF HNODE; BRS 50; STA NNODE
       CLA; STA NOEXEC
*
*  CHECKS THAT ALL NODES ARE IN
*
       LDX ONE; STA K
EXEA1  LDX ONE
EXEA2  STX L
       LDIA NINIT; SUB K; SKE ZERO; BRU *+2; BRU EXEA3
       LDX L; LDIA NFIN; SUB K; SKE ZERO; BRU *+2; BRU EXEA3
       MIN L; LDA L; CAX; SKG NMAX; BRU EXEA2
       SNDA MSGNOD; LDA K; LDB =10; LDX ONE; BRS 36
       MDE NOEXEC
EXEA3  MIN K
       LDA K; SKG NNODE; BRU EXEA1
*
*  CHECKS THAT ALL BRANCHES ARE IN
*
       LDX ONE; STX K
EXEA4  LDIA MODE1
       SKE ZERO; BRU EXEA5
       SNDA MSGBRA; LDA K; LDB =10; LDX ONE; BRS 36; MDE NOEXEC
EXEA5  MIN K; LDX K; CXA; SKG NMAX; BRU EXEA4
       SKN NOEXEC; BRU *+4; SNDA CRCR; BRM MOVER; BRU TCDINL
EXEL1  LDX NTR; BRU *,2
       BRU EXEL2  DC
       BRU EXEL3  AC
*
*  CHECKS IF "TIME STEP" OR "EQUILIBRIUM" WAS SPECIFIED
*  IF SO, BRANCHES TO EXEL5 TO PROCEED TO COMPUTE
*  OTHERWISE WILL NOTIFY THE USER OF HIS ERROR AND
*  ALLOW HIM TO CORRECT IT IMMEDIATELY AND WILL ALSO PUT
*  THE NEW PARAMETER IN THE TEXT BLOCK
*
       LDF DELTA; SKG ZERO; BRU *+2; BRU EXEL5
       LDA NEQUIM; SKG ZERO; BRU EXEL6; BRU EXEL5
EXEL6  SNDA EXERR1; BRU *+2
EXEL7  SNDA EXEQTI
       CLA; STA EDSTAT; STA INFILE; STRING; NOP
       CMPRS PTRNEW; BRU EXEL7
       LDP CMPRSP; STP INLPT1; STP INLPT2
       GCI INLPT2; NOP
       SKE ='   E'; BRU EXEL8
       LDA ONE; STA NEQUIM; BRM TTRADE
       LDA =EXEREQ; MUL =3; LSH 23; SUB ONE; CAB; ADD =11; STF FRQPTR
       LDA INLPT1; CAB; STP INLPT1; BRM EXELIN; BRU EXEL5
EXEL8  SKE ='   T'; BRU EXEL7
       GCI INLPT2; BRU EXEL7; SKE ='   ='; BRU *-3
       LDA INLPT2; STA INLPT1
       SIC INLPT2; BRU EXEL6  TOO LARGE
       SKG ZERO; BRU EXEL6   <=0  (BAD)
       STF DELTA; LDA INLPT2; STA INLPT1+1
       LDA =EXERTI; MUL =3; LSH 23; SUB ONE; CAB; ADD =11; STF FRQPTR
       GCI INLPT1; BRU *+3; WCI FRQPTR; BRU *-3
       BRM EXELIN; BRU EXEL5
*
*  CHECKS IF FREQUENCY WAS SPECIFIED...IF SO, GOES ON ITS MERRY WAY
*  OTHERWISE IT NOTIFIES THE USER OF HIS ERROR AND ALLOWS HIM TO
*  CORRECT IT IMMEDIATELY. THE FREQUENCY THUS ENTERED IS AUTOMATICALLY
*  INSERTED AHEAD OF THE LAST LINE IN THE TEXT BLOCK
*
EXEL3  LDF OMEGA; SKE ZERO; BRU EXEL2
       LDA =3600000B; STA EBUFF1; SNDA EXERR2; SNDA EXERFR
       CLA; STA EDSTAT; STA INFILE; STRING; NOP
       CMPRS PTRNEW; BRU *-7  NULL STRING
       LDP CMPRSP; STP INLPT1; STP INLPT2
       SIC INLPT2; BRU EXEL3  FREQ. TOO LARGE
       SKG ZERO; BRU EXEL3   <=0  (BAD)
       FMP TWOPI; STF OMEGA
       LDA INLPT2; STA INLPT1+1
       LDA =EXERFR; MUL =3; LSH 23; SUB ONE; CAB; ADD =12; STF FRQPTR
       GCI INLPT1; BRU *+3; WCI FRQPTR; BRU *-3
       BRM EXELIN; BRU EXEL2
*
*  INSERTS NEW LINE INTO TEXT BUFFER AS:    INSERT $
*
EXELIN ZRO
       LDA ='   $'; WCD INLPT1; RANGE INLPT1; NOP
       BRM INSRT1; CMPRS FRQPTR; NOP
       LDP CMPRSP; STP XFRPTR; PUTB; BRM INSRT2; BRR EXELIN
*
*  PERFORMS A VALUE SWAP TO EFFECT A TRANSIENT EQUILIBRIUM SOLUTION
*
TTRADE ZRO
       LDP SHORT; STP FTEMP1; LDP OPEN; STP SHORT
       LDP FTEMP1; STP OPEN; BRR TTRADE
*
*  FINISHES UP THE INSPECTION OF INPUT BEFORE COMPUTE
*
EXEL2  LDX ONE; LDA NUMMO; SKE ZERO; EAX 1,2; STX IRTN
       LDA ONE; STA KSW
EXEL5  LDA =EXEL10; BRM ALTMDY; LDA IOPTON; SKA =2B4; BRM DATOPT
       LDA IOPTON; SKA =1010B; BRM SAVLIS
EXEL9  BRM RELTXB; BRM RESFOS
       LDX NTR; BRM LINKER
EXEL10 LDA =EXEL10; BRM ALTMDY; SNDA EXEL41
       CIO ZERO; SKE ='   Y'; BRU *+3
       BRM WASTE; BRU EXEL9
       BRM WASTE; SNDA EXEL42
       CLA; STA TLATE; LDX NTR; BRU *,2
       BRU SETTDC
       BRU SETTAC
       BRU SETTTR
EXEL41 ASC '$BEGIN ANALYSIS? /'
EXEL42 ASC '$JOB ABANDONED$$/'

STBLK  EQU  20B
L      ZRO
MSGNOD ASC '$MISSING NODE NUMBER:  /'
MSGBRA ASC '$MISSING BRANCH NUMBER:  /'
EXERR1 ASC '$$TIME STEP OR EQUILIBRIUM NOT PROPERLY DEFINED '
       ASC '-- PLEASE SPECIFY NOW'
EXEQTI ASC '$[TIME STEP = (OR) EQUILIBRIUM]:  /'
EXEREQ ASC 'EQUILIBRIUM'
EXERTI ASC 'TIME-STEP= '
       BSS 10
EXERR2 ASC '$$FREQUENCY NOT PROPERLY DEFINED -- PLEASE ENTER NOW$/'
EXERFR ASC 'FREQUENCY = '
EBUFF1 BSS 10
FRQPTR BSS 2

*
*  SAVES GOODIES FROM GETTING GOOFED UP DURING SYNTAX CHECK
*
MOVER ZRO
       LDX =-21
       LDA MVEARY,2
       LDB* CVEARY,2
       STB MVEARY,2
       STA* CVEARY,2
       BRX *-4
       LDP HNODE; STP FTEMP1
       LDP MVTMP; STP HNODE
       LDP FTEMP1; STP MVTMP; CLA; STA TLATE; BRR MOVER
MVTMP  BSS 2
MVEARY BES 21
       DATA ID1
       DATA ISEQ
       DATA KS
       DATA MAC
       DATA MAJOR
       DATA MSEQ
       DATA NREC
       DATA M1
       DATA NEQUIM
       DATA NLTRMS
       DATA NOSW
       DATA NUMMO
       DATA NTERMS
       DATA NNODE
       DATA NMAX
       DATA NUMBR
       DATA NUMBC
       DATA NUMBL
       DATA KELAST
       DATA KE
       DATA KI
CVEARY EQU  *

*     M O D I F Y
*     (HOPEFULLY)
*
SETMOD SKN XXXINS; BRU *+4; SKN LNGEDT; BRU HOOHAH; BRU EDBUBU
       LDA NTR; SKE =3; BRU *+2; BRU MEORDR
       LDA ONES; STA MOSTAT
       LDA ONE; STA IRTN; STA MO
       LDX =7; CLA; STIA NPRINT; STA MSEQ; STA NUMMO
       SKN TLATE; BRU NTRST1; BRR CLOOKY
MEORDR SNDA MGORDR
       BRU IGNORE
MGORDR ASC '$$VALID ONLY FOR DC AND AC ANALYSES -- IGNORED$/'
DBRNCH DATA 60
DNODES DATA 20
LIMMOD DATA 20
ONE    EQU 415B
ONES   EQU 420B
ZERO   EQU 414B
MOSTAT DATA 0


*
*       N  -  C A R D    H A N D L E R
*
*
*  RELOCATION INDICES -
*
*      FI=    FOR FILE ID
*      MO=    FOR MODEL ID
*      NO(    FOR ALL NODAL DATA
*      BR(    FOR ALL BRANCH DATA AND B-CARDS
*      SW(    FOR S-CARDS
*      TR(    FOR T-CARDS
*      MU(    FOR M-CARDS
*      VO(    FOR E-CARDS
*      CU(    FOR I-CARDS
*
*  EXAMPLE:
*
*      N1 BR(4,7,9),NO(1,5,6,9),FI=/MODELS/,MO=MODEL1
*
*  SCHEME -
*
*
*  A. INDEX FOR FILE AND OPEN IF POSSIBLE
*  B. STORE MODEL ID
*  C. ANALYZE AND STORE N-CARD DATA
*  D. LOCATE MODEL ON FILE IF POSSIBLE
*  E. INPUT LINE-BY-LINE FROM THE FILE AND EDIT IT, SUBSTITUTING
*      VALUES ON N-CARD FOR THOSE ON ENTERED LINE
*  F. SEND NEW LINE THROUGH SYNTAX CHECKER
*  G. CONTINUE E-F ABOVE UNTIL END OF MODEL IS REACHED
*
*
NCARDR CLA; STA M1; STA MF
       LDA =NKDFIN; BRM ALTMDY; LDA CLOOKY; STA NKDRTN
       GCI INLPT2; BRU NKER69; SKE ZERO; BRU *-3
       LDA ONE; STA MINDSP
* CLEAR OUT THE WORKING STORAGE
       LDX =BABBEG-BABEND; CLA; STA BABEND,2; BRX *-1
* GET FILE ID
       LDP INLPT2; STP WHEPTR
       LDA =FILEID; BRM MINDEX; BRU *+2; BRU NKER1
       CBA; STP NKFPTR; LDB INLPT2+1; STP MINPTR; GCI MINPTR; BRU NKER1
       SKE =17B; BRU *+8
       MIN NKFPTR+1; GCI MINPTR; BRU NKER2
       SKE =17B; BRU *-4; MIN NKFPTR+1; BRU *+9
       SKE =14B; BRU *+2; BRU NKER1
       MIN NKFPTR+1; GCI MINPTR; BRU *+3
       SKE =14B; BRU *-4
       LDP NKFPTR; BRS 48; BRU NKER2
       LDP NKFPTR; BRS 64; BRU NKER3
NKD2   SKG =2; BRU NKER4; XAB; SKE =3; BRU NKER5; STB MF
*
*  GET AND STORE MODEL ID
*
NKD3   LDA =MODLID; BRM MINDEX; BRU *+2; BRU NKER6
       CBA; LDB INLPT2+1; STP MINPTR
NKD31  LDA =MODLBF; MUL =3; LSH 23; SUB ONE; CAB; STP MODLPT
       BRU *+2; WCI MODLPT; GCI MINPTR; BRU *+3
       SKE =14B; BRU *-4; LDA MODLPT+1; SUB MODLPT; SKG ZERO; BRU NKER6
*
*  ANALYZE AND STORE N-CARD DATA IN BYTE ARRAYS
*
NKD5   LDA =20; STA MINDSP; LDX =-7
NKD50  STX NIDPTR; CXA; CNA; SUB ONE; STA NKDBDP; LDB =DATLIM; BRM NKDRET
       STA CURMAX; CLA; STA NKDBDP; LDA NIDEQU,2; BRM MINDEX
       CBA; LDB INLPT2+1; STP MINPTR
NKD51  SIC MINPTR; LDP FPONE; BRS 50; MIN NKDBDP; CAB
       LDA NKDBDP; SKG CURMAX; BRU *+2; BRU *+9; CBA
       LDX NIDPTR; LDB NIDPTR,2; BRM NKDSTO
       GCI MINPTR; BRU *+3; SKE =11B; BRU NKD51; LDX NIDPTR; BRX NKD50
*
*  LOCATE MODEL ON FILE IF POSSIBLE
*
NKD6   CLA; STA EDSTAT; LDA MF; STA INFILE; STRING; BRU NKDEOF
       LDA CHRNEW; SKG ZERO; BRU NKD6
       BRM CHKMOD; BRU NKD6; GCI PTRNEW; NOP
       SKE =32B; BRU *-3; GCI PTRNEW; BRU NKD6
       SKG ZERO; BRU *-3; MDE PTRNEW
       LDP PTRNEW; STP MINPTR; CAB; STP NKDPTR
       BRU *+2; MIN NKDPTR+1; GCI MINPTR; BRU *+3
       SKE ZERO; BRU *-4; LDP MODLPT; SKSE NKDPTR; BRU NKD6
*
*  WHOOPEE...FOUND THE MODEL ON THE FILE!
*  NOW LET'S DO SOMETHING WITH IT!!
*
NKD7   CLA; STA EDSTAT; LDA MF; STA INFILE
       STRING; BRU NKDFIN
       CMPRS PTRNEW; BRU NKD7
       BRM CHKMOD; BRU *+2; BRU NKDFIN
       LDA =NKDBUF; MUL =3; LSH 23; SUB ONE; CAB; STP NKDPTR; BRU NKD70
*
*  HANDLES CARD SERIAL NUMBERS
*
       WCI NKDPTR
NKD70  GCI CMPRSP; BRU NKDSYN
       BRM IDVALD; BRU NKD71; STX NIDKRD
       STA IDVALD; GCI CMPRSP; BRU NKDSYN
       SKG =72B; SKG =40B; BRU *+4
       MDE CMPRSP; LDA IDVALD; BRU NKD71
       MDE CMPRSP; LDA IDVALD
       WCI NKDPTR; SIC CMPRSP; LDP FPONE
       BRS 50; STA NKDBDP
       LDX NIDKRD; LDB NIDPTR,2; BRM NKDRET
       BRM WRTNUM; MDE CMPRSP; BRU NKD72
*
*  HANDLES INTRA-RECORD SUBSTITUTIONS
*      ONLY VALID ONES ARE:
*
*      BRANCHES:  BV(    BA(    BP(    B=(    B(
*      NODES:     N(     NV(    VO...(
*
*  IF DETECTS A NEW RECORD, BRANCHES BACK TO ROUTINE THAT
*  HANDLES CARD SERIAL NUMBER
*
NKD71  WCI NKDPTR
NKD72  GCI CMPRSP; BRU NKDSYN
NKD72A SKG ZERO; BRU NKD71
       SKE =33B; BRU *+2; BRU NKD70-1
       SKE =42B; BRU NKD75  NOT A "B" RECORD
       WCI NKDPTR
       GCI CMPRSP; BRU NKDSYN
       SKE =41B; BRU *+2; BRU NKD73
       SKE =60B; BRU *+2; BRU NKD73
       SKE =66B; BRU *+2; BRU NKD73
       SKE =35B; BRU *+2; BRU NKD73
       SKE =10B; BRU NKD72A; BRU NKD74
NKD73  WCI NKDPTR
       GCI CMPRSP; BRU NKDSYN
       SKE =10B; BRU NKD72A
NKD74  LDX =-6; STX NIDKRD; BRU NKD777
NKD75  SKE =56B; BRU NKD77
       WCI NKDPTR
       GCI CMPRSP; BRU NKDSYN
       SKE =10B; BRU *+2; BRU NKD76
       SKE =66B; BRU NKD72A
       WCI NKDPTR
       GCI CMPRSP; BRU NKDSYN
       SKE =10B; BRU NKD72A
NKD76  LDX =-7; STX NIDKRD; BRU NKD777
NKD77  SKE =66B; BRU NKD71
       WCI NKDPTR
       GCI CMPRSP; BRU NKDSYN
       SKE =57B; BRU NKD72A
NKD77N WCI NKDPTR
       GCI CMPRSP; BRU NKDSYN
       SKE =33B; BRU *+2; BRU NKD70-1
       SKE =14B; BRU *+2; BRU NKD71
       SKE =10B; BRU NKD77N; BRU NKD76
NKDSYN CMPRS NKDPTR
       BRU NKD7; LDP CMPRSP; STP INLPT1; STP INLPT2
       BRM CLOOKY; BRU NKD7
NKDFIN LDA MF; BRS 20; CLA; STA MF; BRR NKDRTN
NKDRTN ZRO
NKD777 WCI NKDPTR
       SIC CMPRSP; LDP FPONE; BRS 50; STA NKDBDP
       LDX NIDKRD; LDB NIDPTR,2; BRM NKDRET
       BRM WRTNUM
       GCI CMPRSP; BRU NKDSYN
       SKE =14B; BRU NKD72A; BRU NKD777
*
*  WHAT TO DO IF THE MODEL DOESN'T EXIST ON THE FILE
*
NKDEOF SNDA NERM7; PSTR MODLPT; SNDA NERM7A; PSTR NKFPTR
       SNDA NERM8; CLA; STA NMGSTA
NKD11  CLA; STA MINSTA; LDA =NKDBUF; MUL =3; LSH 23; SUB ONE
       CAB; STP WHEPTR; BRU NKD12; WCI WHEPTR
NKD12  CIO ZERO; SKG =77B; BRU NKD12-1; SKE =155B; BRU *+2
       BRU NKD12A; SKE =141B; BRU NKD12; GCD WHEPTR; BRU *+3
       TCO =77B; BRU NKD12; TCO =147B; BRU NKD12
NKD12A LDA =2; STA MINDSP
       LDA =RELNX1; BRM MINDEX; LDA ONE; ADM MINSTA
       LDA =RELNX2; BRM MINDEX; LDA =2; ADM MINSTA
       LDA =RELNX3; BRM MINDEX; LDA =4; ADM MINSTA
       LDA =RELNX4; BRM MINDEX; SNDA UTOO; BRU NKD13+3
       LDX =-7; CXA; CNA; SKE MINSTA; BRX *-3; BRU NKD13,2
       BRU NKD14  6  FILE-MODEL
       BRU NKD13
       BRU NKD15  4  FILE
       BRU NKD13
       BRU NKD16  2  MODEL
       BRU NKD17  1  IGNORE
NKD13  SKN NMGSTA; BRU *+4; SNDA NKDHUH
       SNDA JUST2P; BRU NKD11
       SNDA JUST; MDE NMGSTA; BRU NKD11
NKD15  BRM NKDFIL
       BRU NKD6
NKD16  SNDA NERM10; BRM NKDMOD
       CLA; SCP MF; NOP; BRU NKD6
NKD17  LDA MF; BRS 20; CLA; STA MF
       SNDA NKIGGY; BRR NKDRTN
NKD14  BRM NKDFIL; BRU NKD16
NKER1  SNDA NERM1; BRU NKER5A
NKER2  SNDA NERM2; PSTR NKFPTR; BRU NKER5A
NKER3  SNDA NERM3; PSTR NKFPTR; BRU NKER5A
NKER5  CBA
NKER4  BRS 20; CLA; STA MF; PSTR NKFPTR; SNDA NERM4
NKER5A BRM NKDFIL; BRU NKD3
NKER6  SNDA NERM6; BRM NKDMOD; BRU NKD5
NKER69 SNDA NERM69; BRR NKDRTN
NKDFIL ZRO
       LDA MF; BRS 20; CLA; STA MF
NKDFLA SNDA NERM5
       LDA =NKDFBF; MUL =3; LSH 23; SUB ONE; CAB; STP NKFPTR
       BRU *+2; WCI NKFPTR
       CIO ZERO; SKG =77B; BRU *-3
       SKE =155B; BRU *+2; BRU *+9
       SKE =141B; BRU *-7
       GCD NKFPTR; BRU *+3
       TCO =77B; BRU *-11
       TCO =147B; BRU *-13
       LDP NKFPTR; BRS 48; BRU NKDFLB
       LDP NKFPTR; BRS 64; BRU NKDFLC
       SKG =2; BRU *+7
       XAB; SKE =3; BRU *+3
       STB MF; BRR NKDFIL
       CBA; BRS 20; CLA; STA MF; PSTR NKFPTR; SNDA NERM4
       BRU NKDFLA
NKDFLB SNDA NERM2; PSTR NKFPTR; BRU NKDFLA
NKDFLC SNDA NERM3; PSTR NKFPTR; BRU NKDFLA
NKFPTR BSS 2
NKDFBF BSS 10
NKDMOD ZRO
       LDA =MODLBF; MUL =3; LSH 23; SUB ONE; CAB
       STP MODLPT; BRU *+2; WCI MODLPT
NKDXY1 CIO ZERO; SKG =77B; BRU *-3
       SKE =155B; BRU *+2; BRR NKDMOD
       SKE =141B; BRU NKDXY2
       GCD MODLPT; BRU NKDXY1; TCO =77B; BRU NKDXY1
NKDXY2 SKE =161B; BRU NKDXY1
       TCO =76B; TCO =155B; BRU NKDMOD+1
*
*  STORE INTEGER FROM A-REGISTER INTO BUFFER WHOSE ADDRESS
*  IS IN B-REGISTER AND WHOSE BYTE DISPLACEMENT IS
*  IN VARIABLE NKDBDP
*
NKDSTO ZRO
       COPY AX,BA,B; MUL =3; LSH 23; SUB ONE; ADD NKDBDP; CAB
       STP BUFPTR; CXA; WCI BUFPTR; BRR NKDSTO
*
*  RETRIEVE INTEGER INTO A-REGISTER FROM BUFFER WHOSE ADDRESS
*  IS IN THE B-REGISTER AND WHOSE BYTE-DISPLACEMENT IS IN NKDBDP
*
NKDRET ZRO
       COPY BA,B; MUL =3; LSH 23; ADD NKDBDP; CAB; SUB ONE; STP BUFPTR
       GCI BUFPTR; NOP; BRR NKDRET
NKDBDP ZRO
*
*  APPENDS THE NUMBER IN THE A-REGISTER AS AN INTEGER STRING
*  TO NKDPTR
*
WRTNUM ZRO
       LRSH 23; DIV =10; SKG ZERO; BRU *+3
       ADD =20B; WCI NKDPTR; CBA; ADD =20B
       WCI NKDPTR; BRR WRTNUM
*
*  NO SKIP RETURN IF INDEX FOUND
*      RETURNS IN (A)(B) POINTERS TO SUBSTRING
*  VALUE IN MINDSP IS SKIP RETURN INDEX
*
MINDEX ZRO
       MUL =3; LSH 23; ADD =2; CAB; SUB =3; STP MINPTR
       LDA WHEPTR+1; SUB WHEPTR; SUB =2; CNA; CAX
       LDA WHEPTR; CAB; ADD =3; BRU *+4
       ADD ONE; XAB; ADD ONE; XAB; SKSE MINPTR
       BRU *+2; BRR MINDEX; BRX *-7
       LDA MINDSP; ADM MINDEX; BRR MINDEX
*
*  CHECKS IF A MODEL ID WAS JUST ENTERED FROM THE FILE
*  SKIP RETURN IF IT WAS
*
CHKMOD ZRO
       LDX =-2; STX MODCHK; LDP STRNEW; STP MINPTR
       LDA MINPTR+2,2; SKE MODCHK,2; BRU *+2; MIN MODCHK
       BRX *-4; SKN MODCHK; MIN CHKMOD; BRR CHKMOD
       ASC 'MODEL:'
MODCHK ZRO
*
*  CHECKS IF THE VALUE IN THE A-REGISTER IS ONE THAT IS VALID
*  FOR SUBSTITUTION.  SKIP RETURN IF IT IS AND THE APPROPRIATE
*  VALUE IS IN THE X-REGISTER
*
IDVALD ZRO
       LDX =-7; SKE NIDKRD,2; BRU *+3
       MIN IDVALD; BRR IDVALD
       BRX *-4; BRR IDVALD
       DATA '   N','   B','   S','   T'
       DATA '   M','   E','   I'
NIDKRD ZRO
MODLBF BSS 10
MODLPT BSS 2
NKDPTR BSS 2
BUFPTR BSS 2
MINSTA ZRO
NMGSTA ZRO
CURMAX ZRO
RELNX1 ASC 'IGN'
RELNX2 ASC 'MOD'
RELNX3 ASC 'FIL'
RELNX4 DATA 11432443B
MINDSP ZRO
MINPTR BSS 2
WHEPTR BSS 2
NKDBUF BSS 44
MODLID ASC 'MO='
FILEID ASC 'FI='
NKDID1 ASC 'NO('
NKDID2 ASC 'BR('
NKDID3 ASC 'SW('
NKDID4 ASC 'TR('
NKDID5 ASC 'MU('
NKDID6 ASC 'VO('
NKDID7 ASC 'CU('
*
*  INDEX FOR ID SUBGROUP SEARCH
*
       DATA NKDID1
       DATA NKDID2
       DATA NKDID3
       DATA NKDID4
       DATA NKDID5
       DATA NKDID6
       DATA NKDID7
NIDEQU EQU    *
*
*  INDEX FOR ID SUBGROUP DATA BUFFER
*
       DATA NNOBUF
       DATA NBRBUF
       DATA NSWBUF
       DATA NTRBUF
       DATA NMUBUF
       DATA NVOBUF
       DATA NCUBUF
NIDPTR ZRO
*
*  BYTE ADDRESSED DATA CONVERSION STORAGE TABLES
*
BABBEG EQU *
NNOBUF BSS 7
NBRBUF BSS 20
NSWBUF BSS 20
NTRBUF BSS 4
NMUBUF BSS 4
NVOBUF BSS 2
NCUBUF BSS 2
BABEND EQU *
*
*  DATA LIMIT TABLE  -  BYTE ADDRESSED VIA X-REGISTER
*
DATLIM DATA 5*65536+5*256+10     CU  VO  MU
       DATA 10*65536+60*256+60   TR  SW  BR
       DATA 20*65536             NO
*
*  N-CARD MESSAGES
*
NERM1  ASC 'MODEL FILE NOT SPECIFIED/'
NERM2  ASC 'I CANNOT FIND FILE: /'
NERM3  ASC 'I CANNOT OPEN FILE: /'
NERM4  ASC ' IS NOT A VALID MODEL FILE/'
NERM5  ASC '$PLEASE GIVE ME YOUR MODEL FILE NAME: /'
NERM6  ASC 'MODEL ID NOT SPECIFIED$PLEASE ENTER NOW: /'
NERM7  ASC '$I CANNOT FIND /'
NERM7A ASC ' ON /'
NERM8  ASC '$SHALL I IGNORE THE N-CARD, USE ANOTHER MODEL'
       ASC ', OR TRY A NEW FILE?$/'
NKDHUH ASC 'WHAT?$/'
JUST   ASC 'JUST ANSWER: IGNORE (OR) MODEL (OR) FILE (OR) MODEL AND FILE'
JUST2P ASC '$WHICH? /'
UTOO   ASC 'YOU TOO$/'
NERM69 ASC '$N-CARD INCOMPLETE -- IGNORED$$/'
NERM10 ASC 'MODEL NAME: /'
NKIGGY ASC 'OK.$$/'



*
*
*    F O R T R A N   C O M M O N   L I N K A G E
*
*
*
*
*  THE FOLLOWING FORTRAN II STATEMENTS ARE USED TO GENERATE THE
*  APPROPRIATE VARIABLE LINKAGES BETWEEN THE ARPAS INPUT LANGUAGE
*  AND THE FORTRAN COMPUTE LINKS.  THE PROCEDURE IS TO COMPILE
*  THE FOLLOWING FORTRAN COMMON WITH THE MAP AND LIST OPTIONS, AND
*  THEN TO USE THE PROGRAM  FPRCS  TO GENERATE THE APPROPRIATE
*  ARPAS  EQU-COMMON.  CERTAIN VARIABLES ARE ALSO USED IN THE
*  TRANSIENT MODIFY ROUTINE AND CARE MUST BE TAKEN SO AS NOT TO
*  FORGET TO UPDATE THAT ROUTINE AS NECESSARY.
*
*
*      DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
*      DIMENSION JAKE[50]
*      DIMENSION LIST4[60],LABEL[60],LISTE[5],LISTI[5],NUME[5],NUMI[5]
*      DIMENSION LINK1D[60],LINK1E[60]
*      DIMENSION NPRINT[60]
*      DIMENSION E[60],EMIN[60],EMAX[60],AMP[60],AMPMIN[60],AMPMAX[60]
*      DIMENSION Y[60],YMIN[60],YMAX[60],NINIT[60],NFIN[60],MODE1[60]
*      DIMENSION YTERM[60],YTERMH[10],YTERML[10],IROWT[10],ICOLT[10]
*      DIMENSION VFIRST[20],VSECND[20],VLAST[20]
*      DIMENSION MOBRN[20],MOPARM[20],MOSTEP[20],IWCOUT[4]
*      DIMENSION FLM[50]
*      DIMENSION EPHA[60]
*      DIMENSION AMPPHA[60],ETIME[5,2],ATIME[5,2]
*      DIMENSION ETR[5,50],AMPTR[5,50]
*      DIMENSION NWORDS[72],NMCD[2,8],KLABEL[4],KPUNC[5],INDC[2,20]
*      DIMENSION INPUTB[9],NBCD[20],KTYPE[5]
*      DIMENSION KOUT[2,10]
*      DIMENSION IROWM[20],ICOLM[20],FLML[10],FLMH[10]
*      COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
*      COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
*      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
*      COMMON NPRINT
*      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
*      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
*      COMMON YTERMH,YTERML,IROWT,ICOLT
*      COMMON ERROR1
*      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
*      COMMON NREC,MAJOR,ERROR2,ERROR3,ETIME,ATIME
*      COMMON ETR,AMPTR
*      COMMON NWORDS,NMCD,KLABEL,KPUNC,INDC
*      COMMON INPUTB,NBCD,KTYPE,NBLANK,NOEXEC,ITOL,NEQUIM,IPC
*      COMMON INVAL,LL,ICOL,LTYPE,KCOL,NQUIT,ITRANS,KO,KS,KELAST,NUM,M1
*      COMMON M2,M3,KCARD,KG,NP,MAC,HNODE,TNUM,NOEL,NOE,NOI,NOIC
*      COMMON KOUT
*      COMMON ISEQ,ID1,MSEQ,ID2,MO,NUMMO,ID3,OPEN,VFIRST,ID5,VSECND
*      COMMON VLAST,EPHA,IROWM,ICOLM,FLML,FLMH
*      COMMON FLM,MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
*      EQUIVALENCE [ISEQ,START],[MSEQ,FINISH],[NUMMO,SHORT],
*     1 [VSECND[11],LABEL[1]],[YTERM[31],LIST4[1]],[IWCOUT[2],KE],
*     2 [IWCOUT[4],NOSW],[FLM[26],JAKE[1]],[JAKE[31],NUMI[1]],
*     3 [JAKE[36],NUME[1]],[JAKE[41],LISTI[1]],[JAKE[46],LISTE[1]],
*     4 [EPHA[1],LINK1D[1]],[AMPPHA[31],LINK1E[1]],(IWCOUT(3),KI)
*
*
*
*    A R P A S    E Q U - C O M M O N
*
*
*  THE FOLLOWING CORE LOCATIONS ARE GENERATED AS OUTPUT FROM THE
*  PROGRAM  FPRCS  WHICH TAKES ITS INPUT FROM THE FORTRAN COMPILER
*  LIST OUTPUT
*
*
*
LFILES EQU 77734B-50001B
SFE    EQU 77732B-50001B
DCL    EQU 77730B-50001B
DCC    EQU 77726B-50001B
ACL    EQU 77724B-50001B
AC1    EQU 77722B-50001B
AC2    EQU 77720B-50001B
TRL    EQU 77716B-50001B
TRC    EQU 77714B-50001B
ICON   EQU 77713B-50001B
IFROM  EQU 77712B-50001B
IOPTON EQU 77711B-50001B
IFILES EQU 77635B-50001B
PTIFIL EQU 77633B-50001B
PTIFLX EQU 77631B-50001B
SAVEFL EQU 77617B-50001B
PTSAVE EQU 77615B-50001B
NTR    EQU 77614B-50001B
NMAX   EQU 77613B-50001B
NNODE  EQU 77612B-50001B
NTERMS EQU 77611B-50001B
NUMBL  EQU 77610B-50001B
NUMBR  EQU 77607B-50001B
NUMBC  EQU 77606B-50001B
IRTN   EQU 77605B-50001B
NSWTCH EQU 77604B-50001B
KTO    EQU 77603B-50001B
KSW    EQU 77602B-50001B
NPRINT EQU 77506B-50001B
E      EQU 77316B-50001B
EMIN   EQU 77126B-50001B
EMAX   EQU 76736B-50001B
AMP    EQU 76546B-50001B
AMPMIN EQU 76356B-50001B
AMPMAX EQU 76166B-50001B
Y      EQU 75776B-50001B
YMIN   EQU 75606B-50001B
YMAX   EQU 75416B-50001B
NINIT  EQU 75322B-50001B
NFIN   EQU 75226B-50001B
MODE1  EQU 75132B-50001B
YTERMH EQU 75106B-50001B
YTERML EQU 75062B-50001B
IROWT  EQU 75050B-50001B
ICOLT  EQU 75036B-50001B
ERROR1 EQU 75034B-50001B
IWCOUT EQU 75030B-50001B
NLTRMS EQU 75027B-50001B
DELTA  EQU 75025B-50001B
OMEGA  EQU 75023B-50001B
NREC   EQU 75022B-50001B
MAJOR  EQU 75021B-50001B
ERROR2 EQU 75017B-50001B
ERROR3 EQU 75015B-50001B
ETIME  EQU 74771B-50001B
ATIME  EQU 74745B-50001B
ETR    EQU 73761B-50001B
AMPTR  EQU 72775B-50001B
NWORDS EQU 72665B-50001B
NMCD   EQU 72645B-50001B
KLABEL EQU 72641B-50001B
KPUNC  EQU 72634B-50001B
INDC   EQU 72564B-50001B
INPUTB EQU 72553B-50001B
NBCD   EQU 72527B-50001B
KTYPE  EQU 72522B-50001B
NBLANK EQU 72521B-50001B
NOEXEC EQU 72520B-50001B
ITOL   EQU 72517B-50001B
NEQUIM EQU 72516B-50001B
IPC    EQU 72515B-50001B
INVAL  EQU 72514B-50001B
LL     EQU 72513B-50001B
ICOL   EQU 72512B-50001B
LTYPE  EQU 72511B-50001B
KCOL   EQU 72510B-50001B
NQUIT  EQU 72507B-50001B
ITRANS EQU 72506B-50001B
KO     EQU 72505B-50001B
KS     EQU 72504B-50001B
KELAST EQU 72503B-50001B
NUM    EQU 72502B-50001B
M1     EQU 72501B-50001B
M2     EQU 72500B-50001B
M3     EQU 72477B-50001B
KCARD  EQU 72476B-50001B
KG     EQU 72475B-50001B
NP     EQU 72474B-50001B
MAC    EQU 72473B-50001B
HNODE  EQU 72471B-50001B
TNUM   EQU 72467B-50001B
NOEL   EQU 72466B-50001B
NOE    EQU 72465B-50001B
NOI    EQU 72464B-50001B
NOIC   EQU 72463B-50001B
KOUT   EQU 72437B-50001B
ISEQ   EQU 72436B-50001B
ID1    EQU 72435B-50001B
MSEQ   EQU 72434B-50001B
ID2    EQU 72433B-50001B
MO     EQU 72432B-50001B
NUMMO  EQU 72431B-50001B
ID3    EQU 72430B-50001B
OPEN   EQU 72426B-50001B
VFIRST EQU 72356B-50001B
ID5    EQU 72355B-50001B
VSECND EQU 72305B-50001B
VLAST  EQU 72235B-50001B
EPHA   EQU 72045B-50001B
IROWM  EQU 72021B-50001B
ICOLM  EQU 71775B-50001B
FLML   EQU 71751B-50001B
FLMH   EQU 71725B-50001B
FLM    EQU 71561B-50001B
MOBRN  EQU 71535B-50001B
MOPARM EQU 71511B-50001B
MOSTEP EQU 71465B-50001B
AMPPHA EQU 71275B-50001B
YTERM  EQU 71105B-50001B
KE     EQU 75031B-50001B
NOSW   EQU 75033B-50001B
KI     EQU 75032B-50001B
START  EQU 72435B-50001B
FINISH EQU 72433B-50001B
SHORT  EQU 72430B-50001B
LABEL  EQU 72332B-50001B
LINK1D EQU 72046B-50001B
JAKE   EQU 71644B-50001B
NUMI   EQU 71702B-50001B
NUME   EQU 71707B-50001B
LISTI  EQU 71714B-50001B
LISTE  EQU 71721B-50001B
LINK1E EQU 71372B-50001B
LIST4  EQU 71202B-50001B
       END
ECAP ** FICHE/FRAME BREAK *****
ECAINLSYM SYMSORT

SYM.  PG.LN. IDENT.

+T-CAR 31 29 INLANG  1ERROR 12  8 INLANG  2ERROR 12 12 INLANG  3ERROR 12 16 INLANG  
4CEDIT 51 33 INLANG  AC1    76  6 INLANG  AC2    76  7 INLANG  
ACL    76  5 INLANG  ACLDC1  2  8 INLANG  ACLDC2  2 18 INLANG  ACLGLT  8 37 INLANG  
ALTA   11 17 INLANG  ALTB   11 18 INLANG  ALTFLG 11 16 INLANG  ALTMDN 11 12 INLANG  
ALTMDY 11  5 INLANG  ALTRTN 11 20 INLANG  ALTX   11 19 INLANG  AMBGIN  8 23 INLANG  
AMP    76 33 INLANG  AMPMAX 76 35 INLANG  AMPMIN 76 34 INLANG  AMPPHA 79  1 INLANG  
AMPTR  77 19 INLANG  ARYPOS 42 39 INLANG  ARYROW 43  7 INLANG  ATIME  77 17 INLANG  
BABBEG 73  9 INLANG  BABEND 73 17 INLANG  BADK1  48 37 INLANG  BADK10 49 22 INLANG  
BADK11 49 27 INLANG  BADK12 49 32 INLANG  BADK13 49 34 INLANG  BADK14 49 36 INLANG  
BADK15 49 38 INLANG  BADK16 50  2 INLANG  BADK17 50  4 INLANG  BADK18 50  5 INLANG  
BADK19 50  6 INLANG  BADK2  49  2 INLANG  BADK20 50  8 INLANG  BADK21 50 11 INLANG  
BADK22 50 14 INLANG  BADK23 50 17 INLANG  BADK24 50 20 INLANG  BADK25 50 23 INLANG  
BADK26 50 26 INLANG  BADK27 50 29 INLANG  BADK28 50 32 INLANG  BADK29 50 35 INLANG  
BADK3  49  6 INLANG  BADK30 50 38 INLANG  BADK31 51  2 INLANG  BADK32 51  5 INLANG  
BADK33 51  8 INLANG  BADK34 51 11 INLANG  BADK4  49  8 INLANG  BADK5  49 10 INLANG  
BADK6  49 12 INLANG  BADK7  49 14 INLANG  BADK8  49 18 INLANG  BADK9  49 20 INLANG  
BCARDB 32 31 INLANG  BCARDE 35 24 INLANG  BCARDR 32 25 INLANG  BCARDT 33 27 INLANG  
BKARDE 35 28 INLANG  BKRDC  33 30 INLANG  BKRDC9 34 26 INLANG  BKRDE  35  7 INLANG  
BKRDE3 35 33 INLANG  BKRDEE 35 12 INLANG  BKRDEI 36  4 INLANG  BKRDG  33 39 INLANG  
BKRDG9 34 31 INLANG  BKRDI  35 15 INLANG  BKRDI3 36 12 INLANG  BKRDII 36 22 INLANG  
BKRDL  34  8 INLANG  BKRDL9 34 37 INLANG  BKRDN  33  4 INLANG  BKRDR  34 17 INLANG  
BKRDR9 35  3 INLANG  BLKCHR  5  9 INLANG  BLKCUR  5  2 INLANG  BLKED1 55  7 INLANG  
BLKED2 55  8 INLANG  BLKFRM  5  3 INLANG  BLKNOS  5  4 INLANG  BLKNOW 55  5 INLANG  
BLKNXT 55  4 INLANG  BLKPOS  5  5 INLANG  BLKPTR  5  7 INLANG  BLKTO   5  1 INLANG  
BLKWDS  5  8 INLANG  BOOBOO 53  7 INLANG  BRK     1  8 INLANG  BSCAN  55 15 INLANG  
BSCAN1 55 18 INLANG  BSCANE 55 23 INLANG  BSCANS 55 25 INLANG  BSCANX 55 24 INLANG  
BUBUED 55  3 INLANG  BUFPTR 72  2 INLANG  CARDAT  9 36 INLANG  CHKMOD 71 20 INLANG  
CHRNOW 55  6 INLANG  CKNUM1 13  5 INLANG  CKNUMP 13 11 INLANG  CKNUMS 12 30 INLANG  
CKTDAT  9 18 INLANG  CLOOK1  7 24 INLANG  CLOOKY  7 23 INLANG  CMPRS   1 18 INLANG  
COLUMN 43  8 INLANG  COMCK1  7 31 INLANG  COMCK2  7 36 INLANG  COMCK3  8  2 INLANG  
COMCK4  8  4 INLANG  COMDAT  9  3 INLANG  COMINF  6  7 INLANG  COMMNT 48  9 INLANG  
COMPTR  9  1 INLANG  COMQUI 11 22 INLANG  COMRTN 53  4 INLANG  COMVK1  9 16 INLANG  
COMVK2  9 34 INLANG  COMVK3 10  4 INLANG  CONTKD 45 11 INLANG  CONTR  45 13 INLANG  
CPOINT 51 28 INLANG  CRCR    6 26 INLANG  CURMAX 72  5 INLANG  CVEARY 63 38 INLANG  
CZERO   4 19 INLANG  DAT     1  7 INLANG  DATAE  36  2 INLANG  DATAI  36 20 INLANG  
DATLIM 73 21 INLANG  DATOPT 57 39 INLANG  DATST1 37 22 INLANG  DATST2 37 28 INLANG  
DATST3 38  8 INLANG  DATST4 38 11 INLANG  DATST5 38 26 INLANG  DATSTO 36 31 INLANG  
DBRNCH 64 13 INLANG  DCC    76  4 INLANG  DCL    76  3 INLANG  DELTA  77 10 INLANG  
DNODES 64 14 INLANG  DOPENK 12 20 INLANG  DPRINT 18  6 INLANG  DPUNCH 18  7 INLANG  
DSHORT 12 25 INLANG  E      76 30 INLANG  EBUFF1 62 38 INLANG  ECARD1 43 32 INLANG  
ECARDE 44 32 INLANG  ECARDL 44 29 INLANG  ECARDP 44 16 INLANG  ECARDR 43 23 INLANG  
ECARDT 44 21 INLANG  EDBUBU 55  2 INLANG  EMAX   76 32 INLANG  EMIN   76 31 INLANG  
EOFCAN  5 18 INLANG  EOFCHK  5 22 INLANG  EOFENC  5 17 INLANG  EOFM1   5 25 INLANG  
EOFM2   5 26 INLANG  EOFTEL  5 24 INLANG  EPHA   78 31 INLANG  EPOINT 51 25 INLANG  
EQUILB 13 39 INLANG  ERLINK  3 12 INLANG  ERROR1 77  7 INLANG  ERROR2 77 14 INLANG  
ERROR3 77 15 INLANG  ESCAPN 11 14 INLANG  ESCAPY 11  7 INLANG  ESCOMP 56 36 INLANG  
ESCPYB 11 11 INLANG  ESMASK  1 37 INLANG  ETIME  77 16 INLANG  ETR    77 18 INLANG  
EXEA1  60  4 INLANG  EXEA2  60  5 INLANG  EXEA3  60 11 INLANG  EXEA4  60 17 INLANG  
EXEA5  60 20 INLANG  EXECUT 59 18 INLANG  EXED   59 33 INLANG  EXEL1  60 22 INLANG  
EXEL10 62 15 INLANG  EXEL2  62  9 INLANG  EXEL3  61 20 INLANG  EXEL41 62 23 INLANG  
EXEL42 62 24 INLANG  EXEL5  62 11 INLANG  EXEL6  60 34 INLANG  EXEL7  60 35 INLANG  
EXEL8  61  5 INLANG  EXEL9  62 13 INLANG  EXELIN 61 35 INLANG  EXEQTI 62 32 INLANG  
EXER1  59 24 INLANG  EXER2  59 27 INLANG  EXER3  59 37 INLANG  EXEREQ 62 33 INLANG  
EXERFR 62 37 INLANG  EXERR1 62 30 INLANG  EXERR2 62 36 INLANG  EXERTI 62 34 INLANG  
FILEID 72 15 INLANG  FINISH 79  7 INLANG  FINTIM 12  3 INLANG  FLM    78 36 INLANG  
FLMH   78 35 INLANG  FLML   78 34 INLANG  FOSPAG  4 14 INLANG  FP1E7   6 32 INLANG  
FP1EM2  6 33 INLANG  FP1EM3  6 30 INLANG  FPONE   6 31 INLANG  FREQU1 17  1 INLANG  
FREQU2 17  9 INLANG  FREQU3 17 23 INLANG  FREQUE 16 35 INLANG  FREQUI 17 32 INLANG  
FRQPTR 62 39 INLANG  FTEMP1 47 20 INLANG  FTEMP2 47 21 INLANG  FTEMP3 37 17 INLANG  
GETCHK 13 20 INLANG  GETCK1 13 21 INLANG  GETCK2 13 30 INLANG  GETFRE 45 32 INLANG  
GETNMI 21 32 INLANG  GETNMM 21  5 INLANG  GETPOS 57 31 INLANG  GETTOE 45 37 INLANG  
GTFTNI 46  9 INLANG  GTNMM1 21 14 INLANG  GTNMM2 21 15 INLANG  GTNMM3 21 16 INLANG  
GTNMM4 21 17 INLANG  HAHHOO 54  1 INLANG  HELPER 55 31 INLANG  HNODE  78 12 INLANG  
HOOHAH 53 38 INLANG  ICARD1 41  9 INLANG  ICARDE 42 13 INLANG  ICARDL 42  9 INLANG  
ICARDP 41 35 INLANG  ICARDR 40 39 INLANG  ICARDT 42  1 INLANG  ICOL   77 35 INLANG  
ICOLM  78 33 INLANG  ICOLT  77  6 INLANG  ICON   76 10 INLANG  ID1    78 20 INLANG  
ID2    78 22 INLANG  ID3    78 25 INLANG  ID5    78 28 INLANG  IDVALD 71 31 INLANG  
IF      6  3 INLANG  IFILES 76 13 INLANG  IFROM  76 11 INLANG  IGNORE 48 27 INLANG  
INDC   77 24 INLANG  INITIM 11 37 INLANG  INITXB  4 34 INLANG  INIVAR  6 37 INLANG  
INLANG  1 28 INLANG  INLFIX 31 23 INLANG  INLNTR  7  9 INLANG  INLPAU 56 12 INLANG  
INLPAZ 56 10 INLANG  INLPT1  8 38 INLANG  INLPT2  8 39 INLANG  INPUTB 77 25 INLANG  
INSALT 53 31 INLANG  INSGLT 53 36 INLANG  INVAL  77 33 INLANG  INVERT 37 15 INLANG  
INVFLG 37 18 INLANG  INVIGN 12 36 INLANG  IOPTON 76 12 INLANG  IPC    77 32 INLANG  
IROWM  78 32 INLANG  IROWT  77  5 INLANG  IRTN   76 25 INLANG  ISEQ   78 19 INLANG  
ITOL   77 30 INLANG  ITRANS 77 39 INLANG  IWCOUT 77  8 INLANG  JAKE   79 11 INLANG  
JJJ    20 37 INLANG  JUST   73 38 INLANG  JUST2P 73 39 INLANG  K      20 36 INLANG  
KCARD  78  8 INLANG  KCOL   77 37 INLANG  KE     79  3 INLANG  KELAST 78  3 INLANG  
KG     78  9 INLANG  KI     79  5 INLANG  KLABEL 77 22 INLANG  KO     78  1 INLANG  
KOUT   78 18 INLANG  KPUNC  77 23 INLANG  KS     78  2 INLANG  KSW    76 28 INLANG  
KTO    76 27 INLANG  KTYPE  77 27 INLANG  L      62 27 INLANG  LABEL  79  9 INLANG  
LDF     1 26 INLANG  LDFA    1 24 INLANG  LDIA    1 22 INLANG  LFILES 76  1 INLANG  
LGDELE 52 27 INLANG  LGED1  54 23 INLANG  LGED2  54 33 INLANG  LGED3  54 35 INLANG  
LGED4  54 39 INLANG  LGED5  55  1 INLANG  LGEDIT 54 10 INLANG  LGEDLV 54 37 INLANG  
LGGOGO 55 39 INLANG  LGINSR 53 12 INLANG  LGINST 53 25 INLANG  LGLIST 52  8 INLANG  
LGLST1 52 20 INLANG  LIMMOD 64 15 INLANG  LINK1D 79 10 INLANG  LINK1E 79 16 INLANG  
LINKER  3  2 INLANG  LINKF   3 21 INLANG  LIST4  79 17 INLANG  LISTE  79 15 INLANG  
LISTI  79 14 INLANG  LL     77 34 INLANG  LNGEDT 55 10 INLANG  LNKERR  3 17 INLANG  
LNKODE  3 20 INLANG  LSTALT 52 22 INLANG  LTYPE  77 36 INLANG  M1     78  5 INLANG  
M2     78  6 INLANG  M3     78  7 INLANG  MAC    78 11 INLANG  MAJOR  77 13 INLANG  
MAX     1 15 INLANG  MCARD1 22 37 INLANG  MCARD2 23 10 INLANG  MCARD3 23 32 INLANG  
MCARD4 24  2 INLANG  MCARDB 22 28 INLANG  MCARDE 24  9 INLANG  MCARDG 23  5 INLANG  
MCARDR 22 15 INLANG  MCARDT 23 30 INLANG  MDE     1 14 INLANG  MEORDR 64 10 INLANG  
MF      6  6 INLANG  MGBD   51 14 INLANG  MGBD1  51 15 INLANG  MGBD11 49 31 INLANG  
MGBD12 49 33 INLANG  MGBD13 49 35 INLANG  MGBD14 49 37 INLANG  MGBD15 49 39 INLANG  
MGBD16 50  3 INLANG  MGBD19 50  7 INLANG  MGBD2  51 16 INLANG  MGBD20 50 10 INLANG  
MGBD21 50 13 INLANG  MGBD22 50 16 INLANG  MGBD23 50 19 INLANG  MGBD24 50 22 INLANG  
MGBD25 50 25 INLANG  MGBD26 50 28 INLANG  MGBD27 50 31 INLANG  MGBD28 50 34 INLANG  
MGBD29 50 37 INLANG  MGBD3  51 17 INLANG  MGBD30 51  1 INLANG  MGBD31 51  4 INLANG  
MGBD32 51  7 INLANG  MGBD33 51 10 INLANG  MGBD5  51 18 INLANG  MGBD6  51 19 INLANG  
MGBD7  51 20 INLANG  MGBD8  51 21 INLANG  MGBD9  49 21 INLANG  MGINVI 12 39 INLANG  
MGMMNY 49 26 INLANG  MGORDR 64 12 INLANG  MINDEX 71  9 INLANG  MINDSP 72 10 INLANG  
MINPTR 72 11 INLANG  MINSTA 72  3 INLANG  MO     78 23 INLANG  MOBRN  78 37 INLANG  
MOD     1 16 INLANG  MODCHK 71 25 INLANG  MODDER 21 21 INLANG  MODE1  77  2 INLANG  
MODLBF 71 38 INLANG  MODLID 72 14 INLANG  MODLPT 71 39 INLANG  MODSB1 47  3 INLANG  
MODSB2 47 15 INLANG  MODSUB 46 20 INLANG  MOPARM 78 38 INLANG  MOSTAT 64 19 INLANG  
MOSTEP 78 39 INLANG  MOVER  63  5 INLANG  MSEQ   78 21 INLANG  MSGBRA 62 29 INLANG  
MSGNOD 62 28 INLANG  MULFLG 16 30 INLANG  MULNG1 16  8 INLANG  MULNGT 16  6 INLANG  
MVEARY 63 16 INLANG  MVTMP  63 15 INLANG  NBCD   77 26 INLANG  NBLANK 77 28 INLANG  
NBRBUF 73 11 INLANG  NBRN   31  9 INLANG  NCARDR 65 16 INLANG  NCUBUF 73 16 INLANG  
NEQUIM 77 31 INLANG  NERM1  73 27 INLANG  NERM10 74  3 INLANG  NERM2  73 28 INLANG  
NERM3  73 29 INLANG  NERM4  73 30 INLANG  NERM5  73 31 INLANG  NERM6  73 32 INLANG  
NERM69 74  2 INLANG  NERM7  73 33 INLANG  NERM7A 73 34 INLANG  NERM8  73 35 INLANG  
NFIN   77  1 INLANG  NIDEQU 72 33 INLANG  NIDKRD 71 37 INLANG  NIDPTR 73  5 INLANG  
NINIT  76 39 INLANG  NKD11  68 31 INLANG  NKD12  68 33 INLANG  NKD12A 68 36 INLANG  
NKD13  69  9 INLANG  NKD14  69 18 INLANG  NKD15  69 12 INLANG  NKD16  69 14 INLANG  
NKD17  69 16 INLANG  NKD2   65 34 INLANG  NKD3   65 38 INLANG  NKD31  66  1 INLANG  
NKD5   66  7 INLANG  NKD50  66  8 INLANG  NKD51  66 11 INLANG  NKD6   66 18 INLANG  
NKD7   66 30 INLANG  NKD70  66 39 INLANG  NKD71  67 20 INLANG  NKD72  67 21 INLANG  
NKD72A 67 22 INLANG  NKD73  67 32 INLANG  NKD74  67 35 INLANG  NKD75  67 36 INLANG  
NKD76  68  5 INLANG  NKD77  68  6 INLANG  NKD777 68 20 INLANG  NKD77N 68 10 INLANG  
NKDBDP 70 34 INLANG  NKDBUF 72 13 INLANG  NKDEOF 68 29 INLANG  NKDFBF 70  9 INLANG  
NKDFIL 69 27 INLANG  NKDFIN 68 18 INLANG  NKDFLA 69 29 INLANG  NKDFLB 70  6 INLANG  
NKDFLC 70  7 INLANG  NKDHUH 73 37 INLANG  NKDID1 72 16 INLANG  NKDID2 72 17 INLANG  
NKDID3 72 18 INLANG  NKDID4 72 19 INLANG  NKDID5 72 20 INLANG  NKDID6 72 21 INLANG  
NKDID7 72 22 INLANG  NKDMOD 70 10 INLANG  NKDPTR 72  1 INLANG  NKDRET 70 31 INLANG  
NKDRTN 68 19 INLANG  NKDSTO 70 24 INLANG  NKDSYN 68 15 INLANG  NKDXY1 70 13 INLANG  
NKDXY2 70 17 INLANG  NKER1  69 19 INLANG  NKER2  69 20 INLANG  NKER3  69 21 INLANG  
NKER4  69 23 INLANG  NKER5  69 22 INLANG  NKER5A 69 24 INLANG  NKER6  69 25 INLANG  
NKER69 69 26 INLANG  NKFPTR 70  8 INLANG  NKIGGY 74  4 INLANG  NLTRMS 77  9 INLANG  
NMAX   76 19 INLANG  NMCD   77 21 INLANG  NMGSTA 72  4 INLANG  NMUBUF 73 14 INLANG  
NNOBUF 73 10 INLANG  NNODE  76 20 INLANG  NOE    78 15 INLANG  NOEL   78 14 INLANG  
NOEXEC 77 29 INLANG  NOGO   56 20 INLANG  NOI    78 16 INLANG  NOIC   78 17 INLANG  
NOSW   79  4 INLANG  NP     78 10 INLANG  NPRINT 76 29 INLANG  NQUIT  77 38 INLANG  
NREC   77 12 INLANG  NSWBUF 73 12 INLANG  NSWTCH 76 26 INLANG  NTERMS 76 21 INLANG  
NTR    76 18 INLANG  NTRBUF 73 13 INLANG  NTRST1 15 35 INLANG  NTRST2 15 37 INLANG  
NULKRD 57  4 INLANG  NUM    78  4 INLANG  NUMBC  76 24 INLANG  NUMBL  76 22 INLANG  
NUMBR  76 23 INLANG  NUME   79 13 INLANG  NUMI   79 12 INLANG  NUMMO  78 24 INLANG  
NUMNOZ 48 20 INLANG  NUMTMP 16 29 INLANG  NVOBUF 73 15 INLANG  NWORDS 77 20 INLANG  
OF      6  4 INLANG  OMEGA  77 11 INLANG  ONE    64 16 INLANG  ONES   64 17 INLANG  
OPEN   78 26 INLANG  OUTDAT 18 28 INLANG  OUTFLG 20 30 INLANG  OUTINT 11 32 INLANG  
OUTMOD 20 29 INLANG  PAREGR 11 21 INLANG  PARMOD 47 27 INLANG  PAUANL 56  9 INLANG  
PAUBRU 56 18 INLANG  PAUCMP 56 25 INLANG  PAUCP1 56 37 INLANG  PAUCP2 56 38 INLANG  
PAUEXE 56  7 INLANG  PAUFLG 56 19 INLANG  PAUM1  56 21 INLANG  PAUM2  56 22 INLANG  
PAUM3  56 23 INLANG  PAUST1 56 11 INLANG  PCKT    1 19 INLANG  PID180 39 39 INLANG  
POPTAB 10  9 INLANG  POPTND 10 32 INLANG  PRIPUN 18  9 INLANG  PROGRM 58 20 INLANG  
PRPU1  18 13 INLANG  PRPU2  18 20 INLANG  PRPU3  18 30 INLANG  PRPU4  18 35 INLANG  
PRPU5  18 37 INLANG  PRPU6  19  5 INLANG  PRPU7  19 12 INLANG  PRPU8  20  5 INLANG  
PRPUAC 19 18 INLANG  PRPUCK 18 17 INLANG  PRPUEX 20  6 INLANG  PRPUM1 20 33 INLANG  
PRPUM2 20 34 INLANG  PRPUX1 20 13 INLANG  PRPUX2 20 17 INLANG  PRPUX3 20 20 INLANG  
PRPUX4 20 22 INLANG  PRPUX5 20 26 INLANG  PRPUX6 20 27 INLANG  PRQUES 53  5 INLANG  
PRUAC1 19 27 INLANG  PRUAC2 19 29 INLANG  PRUAC3 19 33 INLANG  PRUAC4 19 35 INLANG  
PRUAC5 19 37 INLANG  PRUAC6 20  2 INLANG  PSTR    1 10 INLANG  PTIFIL 76 14 INLANG  
PTIFLX 76 15 INLANG  PTSAVE 76 17 INLANG  PTX     1 13 INLANG  PUTB    1 17 INLANG  
PUTFLG 55 26 INLANG  RANGE   1 20 INLANG  RDTIM1 59  5 INLANG  RDTIME 58 26 INLANG  
REARM   1 38 INLANG  REGSAV 43  6 INLANG  RELNX1 72  6 INLANG  RELNX2 72  7 INLANG  
RELNX3 72  8 INLANG  RELNX4 72  9 INLANG  RELTXB  4  4 INLANG  REMFOS  3 31 INLANG  
REMTXB  3 37 INLANG  RESFOS  3 34 INLANG  RESTXB  4  1 INLANG  RMASK   4 11 INLANG  
RNUMBR 48 13 INLANG  RSP     1  4 INLANG  RTN     8 36 INLANG  SAMPT1 42 25 INLANG  
SAMPTR 42 20 INLANG  SAVEFL 76 16 INLANG  SAVER1 57 16 INLANG  SAVER2 57 18 INLANG  
SAVER3 57 25 INLANG  SAVLIS 57 11 INLANG  SAVLSG 57 26 INLANG  SCARD1 25  7 INLANG  
SCARD2 25 28 INLANG  SCARDR 24 25 INLANG  SENSIT 15  3 INLANG  SETACL  6 13 INLANG  
SETDCL  6 12 INLANG  SETIME 58 24 INLANG  SETL1   6 15 INLANG  SETL2   6 18 INLANG  
SETL3   6 19 INLANG  SETL4   6 21 INLANG  SETMOD 64  4 INLANG  SETR   44 38 INLANG  
SETR1  45  3 INLANG  SETTAC  2 14 INLANG  SETTDC  2 12 INLANG  SETTGO  2  4 INLANG  
SETTRL  6 14 INLANG  SETTTR  2 16 INLANG  SF      6  5 INLANG  SFE    76  2 INLANG  
SHIFT   4 12 INLANG  SHORT  79  8 INLANG  SIC     1  9 INLANG  SND     1 11 INLANG  
SNDA    1 12 INLANG  SNSIT1 15 12 INLANG  SNSIT2 15 18 INLANG  SNSIT3 15 20 INLANG  
SNSIT4 15 23 INLANG  SNSIT5 15 29 INLANG  SOUDAT 39 11 INLANG  SOUDT1 39 25 INLANG  
SOUDT2 40  4 INLANG  SOUDT3 40 17 INLANG  SOUERR 42 27 INLANG  SRESET  2 23 INLANG  
START  79  6 INLANG  STBLK  62 26 INLANG  STDDEV 14  7 INLANG  STDEVI 14 11 INLANG  
STF     1 25 INLANG  STFA    1 23 INLANG  STIA    1 21 INLANG  STRING  1  5 INLANG  
SWAPOF 20 31 INLANG  TCARD1 27 14 INLANG  TCARD2 27 31 INLANG  TCARD3 28  2 INLANG  
TCARD4 28 24 INLANG  TCARD5 28 33 INLANG  TCARD6 29 24 INLANG  TCARD7 29 34 INLANG  
TCARD8 30 10 INLANG  TCARD9 30 35 INLANG  TCARDB 26 18 INLANG  TCARDC 27  9 INLANG  
TCARDE 31  2 INLANG  TCARDR 26 12 INLANG  TCARDT 27 28 INLANG  TCARDZ 28 17 INLANG  
TCDINL 31 16 INLANG  TEXBUF  4 15 INLANG  TIM     1  6 INLANG  TIMCPU 59  7 INLANG  
TIME1A 59  9 INLANG  TIME1B 59 11 INLANG  TIME2A 59 10 INLANG  TIME2B 59 12 INLANG  
TIMEOJ 59  6 INLANG  TIMEST 11 27 INLANG  TIMTER 59  8 INLANG  TKDER1 31 28 INLANG  
TKDER2 31 30 INLANG  TKDERR 31 11 INLANG  TLATE   7 22 INLANG  TMNYSK 51 13 INLANG  
TNUM   78 13 INLANG  TOFROM 57  7 INLANG  TRC    76  9 INLANG  TREARM  1 39 INLANG  
TRL    76  8 INLANG  TTRADE 62  3 INLANG  TWOPI  17 38 INLANG  TYMECP 58 19 INLANG  
UTOO   74  1 INLANG  VFIRST 78 27 INLANG  VLAST  78 30 INLANG  VSECND 78 29 INLANG  
WASTE  56 33 INLANG  WHEPTR 72 12 INLANG  WORSTC 14 16 INLANG  WRSTC1 14 27 INLANG  
WRSTC2 14 29 INLANG  WRSTC3 14 30 INLANG  WRSTC4 14 35 INLANG  WRSTC5 14 37 INLANG  
WRTNUM 70 39 INLANG  XFRMAX 39  9 INLANG  XFRMIN 39  8 INLANG  XFRNOM 39  7 INLANG  
XFRPHA 39 10 INLANG  XFRPTR  5  6 INLANG  XXXAC   6 28 INLANG  XXXDC   6 27 INLANG  
XXXPTR 55  9 INLANG  XXXTR   6 29 INLANG  Y      76 36 INLANG  YMAX   76 38 INLANG  
YMIN   76 37 INLANG  YTERM  79  2 INLANG  YTERMH 77  3 INLANG  YTERML 77  4 INLANG  
ZERO   64 18 INLANG  
ECAP ** FICHE/FRAME BREAK *****
ECASFESYM
SFECAP IDENT   VER.6   ECAP STANDARD FRONT END   T.FLORYAN
*
*
SND    OPD     177B5,1,1
SNDA   OPD     176B5,1,1
CSTR   OPD     175B5,1,1
PTX    OPD     174B5,1,1
PSTR   OPD     173B5,1,1
BRK    OPD     172B5,1,1
DAT    OPD     171B5,1,1
WRT    OPD     170B5,1,1
PRT    OPD     167B5,1,1
SPC    OPD     166B5,1,1
LIN    OPD     165B5,1,1
MDE    OPD     164B5,1,1
$SFEACT ZRO    RTN
       LDX     =POPTAB-POPTND
       LDA     200B,2
       LDB     POPTND,2
       STB     200B,2
       STA     POPTND,2
       BRX     *-4
       BRS 26; BRU TREARM; LDA =REARM; STA 201B
       LDA ESMASK; BRS 78; BRS 114; CIT ZERO
ESMASK NOP 0
REARM  ZRO RTN
TREARM BRS 114
START  LDA IFROM; SKE ZERO; BRU MST; CLA; STA IF; LDA =43000001B; STA OF
       LDA =2; STA SF
MST    CLA
       STA     ERRCNT
       BRM CLOSE
ST     SND     GLITCH
       BRM     ALTMOD
       CLA
       STA     CBUFF
       LDX     COMINF
       CSTR    CBUFF
       STP     CPTR
       STX     TRMCHR
       SKN     TRMCHR
       BRU     *+2
       BRU     RDERR
       CLA
       LDB     CBUFF
       LSH     8
       SKE     =61B            Q  IMMEDIATE ACTION
       BRU     *+3
       TCO     =155B
       BRS     10
       SKE     =37B            ?  IMMEDIATE ACTION
       BRU     *+2
       BRU     HELP
       LDA     CBUFF
       LDX     =CMDTAB-CMDTND
       SKE     CMDTND,2
       BRX     *-1
       BRU     BRANCH,2        GO TO CHOSEN LOCATION
ALTMOD ZRO
       LDA     201B
       SKG     ZERO
       BRR     ALTMOD
       LDA     =ESCAPE
       STA     201B
       LDA     =2B6
       BRS     78
       BRR     ALTMOD
ESCAPE ZRO
       LDX     ONES
       BRS     11
       BRS     29
       TCO     =155B
       CLA
       STA     COMINF
       BRS     151
       BRU     MST
*
*  C O M M A N D   S T O R A G E   T A B L E
*
CMDTAB ASC     'QUI'           QUIT
       ASC     'HEL'           HELP
       ASC     'COM'           COMMANDS
       ASC     'RUN'           RUN
       ASC     'EXPNOE'        EXPERT,NOEXPERT
       ASC     'BAT'           BATCH
       ASC     'EXE'           EXECUTE
       ASC     'LOAREA'        LOAD,READ
       ASC     'WRIPUN'        WRITE,PUNCH
       ASC     'LISNOL'        LIST,NOLIST
       ASC     'SAVNOS'        SAVE,NOSAVE
       ASC     'FORNOF'        FORMAT,NOFORMAT
       ASC     'DATNOD'        DATE,NODATE
       ASC     'TIMNOT'        TIME,NOTIME
       ASC     'PAUNOP'        PAUSE,NOPAUSE
       ASC     'RES'           RESET
       ASC     'CAT'           CATALOG
       ASC     'CON'           CONVERT
       ASC     'SUM'           SUMMARY
       ASC     'CAP'           CAPABILITIES
       ASC     'INS'           INSTRUCTIONS
       ASC     'VER'           VERSION
       ASC     'CHA'           CHARGES
       ASC     'CRE'           CREDITS
       ASC     'DEB'           DEBUG *PRIVATE*
       ASC     'OPT'           OPTIONS *PRIVATE*
       ASC     'WHY'           WHY *PRIVATE*
       ASC     'BAD'           BAD *PRIVATE*
       ASC     'LIN'           LINKS *PRIVATE*
CMDTND EQU     *
*
*  C O M M A N D   T R A N S F E R   V E C T O R S
*
       NOP
       BRU     HELP            HELP
       BRU     COMNDZ          COMMANDS
       BRU     RUNRUN          RUN
       BRU     EXPERT          EXPERT
       BRU     NEXPRT          NOEXPERT
       BRU     BATCH           BATCH
       BRU     EXECUT          EXECUTE
       BRU     LOAD            LOAD
       BRU     LOAD            READ
       BRU     WRITE           WRITE
       BRU     WRITE           PUNCH
       BRU     LIST            LIST
       BRU     NOLIST          NOLIST
       BRU     SAVE            SAVE
       BRU     NSAVE           NOSAVE
       BRU     FORMAT          FORMAT
       BRU     NOFRMT          NOFORMAT
       BRU     DATE            DATE
       BRU     NODATE          NODATE
       BRU     TIME            TIME
       BRU     NOTIME          NOTIME
       BRU     PAUSE           PAUSE
       BRU     NPAUSE          NOPAUSE
       BRU     CANCEL          CANCEL
       BRU     CATLOG          CATALOG
       BRU     CONVRT          CONVERT
       BRU     SUMSUM          SUMMARY
       BRU     CAPABS          CAPABILITIES
       BRU     INSTRK          INSTRUCTIONS
       BRU     VERNO           VERSION
       BRU     CHARGZ          CHARGES
       BRU     CREDTS          CREDITS
       BRU     DEBUG           DEBUG
       BRU     OPTION          OPTION
       BRU     WHYNOT          WHY
       BRU     BADFLZ          BAD
       BRU     ECPLNK          LINKS
BRANCH MIN     ERRCNT
       LDA     ERRCNT
       SKG     ONE
       BRU     ONERR
       LDA     COMINF
       SKE     ZERO
       SNDA    ERCMDF
       SNDA    WHYMSG
       CLA
       STA     COMINF
       BRS     151
       BRU     MST
ONERR  LDA     COMINF
       SKG     ZERO
       BRU     *+4
       SNDA    ERCMD
       PSTR    CPTR
       TCO     =155B
       SND     QMARK
       BRU     ST
RDERR  CXA
       SKE     ONES            NULL STRING ERROR
       BRU     *+5
       LDA     COMINF
       SKE     ZERO
       SNDA    NULSTR
       BRU     ST
       SNDA    EOFENC
       CLA
       STA     COMINF
       BRS     151
       BRU     MST
WHYNOT LDA     ERRCNT
       SKG     ZERO
       BRU     *+4
       SND     BCMSG
       SND     WHYMSG
       BRU     MST
       SND     NOERRS
       BRU     MST
BCMSG  ASC     'BAD COMMAND$/'
NOERRS ASC     'NO ERRORS$/'
*
*  P O P   T R A N S F E R   V E C T O R   T A B L E
*
POPTAB EQU     *
       BRU     MDEPOP          MDE   164
       BRU     LINPOP          LIN   165
       BRU     SPCPOP          SPC   166
       BRU     PRTPOP          PRT   167
       BRU     WRTPOP          WRT   170
       BRU     DATPOP          DAT   171
       BRU     BRKPOP          BRK   172
       BRU     PSTRPP          PSTR  173
       BRU     PTXPOP          PTX   174
       BRU     CSTRPP          CSTR  175
       BRU     SNDAPP          SNDA  176
       BRU     SNDPOP          SND   177
POPTND EQU     *
*
*  D A T A   A N D   M E S S A G E S
*
RTN    ZRO
CPTR   BSS     2
CBUFF  BSS     44
ERRCNT ZRO
TRMCHR ZRO
WHYMSG ASC     '$FOR ASSISTANCE, TYPE "HELP"$/'
ERCMDF ASC     'EXCESSIVE ERRORS IN COMMAND FILE$/'
ERCMD  ASC     'ERROR, BAD COMMAND: /'
GLITCH ASC     '$:/'
QMARK  ASC     '?$/'
NULSTR ASC     'NULL COMMAND$/'
EOFENC ASC     'EOF IN COMMAND FILE$/'
ZERO   EQU     414B            FOS DATA  = 0
ONE    EQU     415B            FOS DATA  = 1
ONES   EQU     420B            FOS DATA  =-1
*
*  S T A R T   O F   A L L   R O U T I N E S
*
SUMSUM LDA     ONES
       STA     KMDOPT
       BRU     HLPALL
INSTRK LDA     TRMCHR
       SKE     ZERO
       BRU     *-4
       LDA     ONES
       LDX     COMINF
       CSTR    CBUFF
       STP     CPTR
       CXA
       SKG     ONES
       BRU     RDERR
HLPCCK CLA
       STA     DBUFF
       LDA     =DBUFF
       ADD     =DBUFF
       ADD     =DBUFF
       SUB     ONE
       CAB
       STP     DPTR
HLPMCK GCI     CPTR
       BRU     HLPLST
       SKG     ZERO
       BRU     HLPMCK
       WCI     DPTR
       GCI     CPTR
       BRU     HLPLST
       SKE     =14B
       BRU     *-4
       BRM     HLPSBR
       BRU     HLPCCK
HLPLST LDA     DBUFF
       SKG     ZERO
       BRU     MST
       BRM     HLPSBR
       BRU     MST
HLPALL SKN     KMDOPT
       PTX     HLPMSG
       SNDA    CMDLST
       LDX     =BHPTB1-PVTCMD
HLPLUP SKN*    PVTCMD,2
       BRU     *+3
       EAX     2,2
       BRU     *-3
       SNDA*   PVTCMD,2
       EAX     1,2
       SKN     KMDOPT
       PTX*    PVTCMD,2
       BRX     HLPLUP
       TCO     =155B
       TCO     =155B
       BRU     MST
HLPSBR ZRO
       LDA     DBUFF
       LDX     =CMDTAB-CMDTND
       SKE     CMDTND,2
       BRU     *+2
       BRU     HLPSND
       BRX     *-3
       SNDA    ERORON
       PSTR    DPTR
       TCO     =155B
       BRR     HLPSBR
HLPSND COPY    XA,B
       LCY     1
       CAX
       SKN*    HLPTB1,2
       BRU     *+3
       EAX     2,2
       BRU     *-3
       SNDA*   HLPTB1,2
       EAX     1,2
       PTX*    HLPTB1,2
       BRR     HLPSBR
ERORON ASC     'ERROR ON: /'
DBUFF  BSS     44
DPTR   BSS     2
PXREG  ZRO
KMDOPT ZRO
CMDLST ASC     '$VALID COMMANDS ARE:$$/'
*
*  H E L P   M E S S A G E - F I N D E R   A R R A Y
*       (OVERLAYS COMMAND TRANSFER VECTOR ARRAY)
*
BHPTB1 DATA    HLPA1,HLPB1     QUIT
       DATA    HLPA2,HLPB2     HELP
       DATA    HLPAU1,HLPBU1   COMMANDS
       DATA    HLPA3,HLPB3     RUN
       DATA    ONES,ONES
       DATA    HLPA4,HLPB4     EXPERT,NOEXPERT
       DATA    HLPA5,HLPB5     BATCH
       DATA    HLPA6,HLPB6     EXECUTE
       DATA    ONES,ONES
       DATA    HLPA7,HLPB7     LOAD,READ
       DATA    ONES,ONES
       DATA    HLPA8,HLPB8     WRITE,PUNCH
       DATA    ONES,ONES
       DATA    HLPA9,HLPB9     LIST,NOLIST
       DATA    ONES,ONES
       DATA    HLPA10,HLPB10   SAVE,NOSAVE
       DATA    ONES,ONES
       DATA    HLPA11,HLPB11   FORMAT,NOFORMAT
       DATA    ONES,ONES
       DATA    HLPA12,HLPB12   DATE,NODATE
       DATA    ONES,ONES
       DATA    HLPA13,HLPB13   TIME,NOTIME
       DATA    ONES,ONES
       DATA    HLPA14,HLPB14   PAUSE,NOPAUSE
       DATA    HLPA15,HLPB15   RESET
       DATA    HLPA16,HLPB16   CATALOG
       DATA    HLPA17,HLPB17   CONVERT
       DATA    HLPA18,HLPB18   SUMMARY
       DATA    HLPA19,HLPB19   CAPABILITIES
       DATA    HLPA20,HLPB20   INSTRUCTIONS
       DATA    HLPA21,HLPB21   VERSION
       DATA    HLPA22,HLPB22   CHARGES
       DATA    HLPA23,HLPB23   CREDITS
PVTCMD DATA    HLPA24,HLPB24   DEBUG
       DATA    HLPA25,HLPB25   OPTIONS
       DATA    HLPA26,HLPB26   WHY
       DATA    HLPAX1,HLPBX1   BAD
       DATA    HLPAX2,HLPBX2   LINKS
HLPTB1 EQU     *
HLPA1  ASC     '$QUIT (OR) Q/'
HLPA2  ASC     '$HELP (OR) ?/'
HLPAU1 ASC     '$COMMANDS/'
HLPA3  ASC     '$RUN/'
HLPA4  ASC     '$EXPERT,NOEXPERT/'
HLPA5  ASC     '$BATCH/'
HLPA6  ASC     '$EXECUTE/'
HLPA7  ASC     '$LOAD,READ/'
HLPA8  ASC     '$WRITE,PUNCH/'
HLPA9  ASC     '$LIST,NOLIST/'
HLPA10 ASC     '$SAVE,NOSAVE/'
HLPA11 ASC     '$FORMAT,NOFORMAT/'
HLPA12 ASC     '$DATE,NODATE/'
HLPA13 ASC     '$TIME,NOTIME/'
HLPA14 ASC     '$PAUSE,NOPAUSE/'
HLPA15 ASC     '$RESET/'
HLPA16 ASC     '$CATALOG/'
HLPA17 ASC     '$CONVERT/'
HLPA18 ASC     '$SUMMARY/'
HLPA19 ASC     '$CAPABILITIES/'
HLPA20 ASC     '$INSTRUCTIONS/'
HLPA21 ASC     '$VERSION/'
HLPA22 ASC     '$CHARGES/'
HLPA23 ASC     '$CREDITS/'
HLPA24 ASC     '$DEBUG/'
HLPA25 ASC     '$OPTIONS/'
HLPA26 ASC     '$WHY/'
HLPAX1 ASC     '$BAD/'
HLPAX2 ASC     '$LINKS/'

*
*  THIS ROUTINE ASKS FOR INPUT FILE(S) AND AN OUTPUT FILE AND INVOKES
*  A FORMAT PROCESSOR (CONDO) THAT FORMATS THE TOPOLOGY FROM THE
*  INPUT FILE(S) ON THE OUTPUT FILE.  WILL ALSO ACCEPT MULTIPLE
*  STATEMENTS ON ONE LINE SEPARATED BY SEMICOLONS
*
CONVRT BRM GETIOF; SND CRCR
CONCYC BRK CPTR; BRU *+5; BRM OPNIN; BRU MST; BRM CONDO; BRU CONCYC
       BRM OPNIN; BRU MST; BRM CONDO; SND EOJ; BRU MST
CONDO  ZRO
CONDO1 LDA ONES; LDX IMMIN; CSTR DBUFF; STP DPTR; STP GPTR; CXA
       SKG ONES; BRU CONDON
CONBR1 LDA ONES; STA CONMUL; BRM NULVPT; GCI DPTR; BRU CONDO1
       SKE ZERO; BRU *+4; GCI GPTR; NOP; BRU *-6; SKE =33B
       BRU *+2; BRU *-5; SKE =12B; BRU CONBR2
CONAS1 GCI DPTR; BRU CONAS2; SKG ZERO; BRU CONAS1
       CLA; LDX =-5; WCI VPTR; BRX *-1; BRU CONASR; WCI VPTR
CONASR GCI GPTR; BRU CONASN; SKE =33B; BRU *-4
CONASM MIN CONMUL
CONASN LDA GPTR; STA DPTR; BRU CONOUT
CONAS3 WCI VPTR
CONAS2 GCI GPTR; BRU CONASN; SKG ZERO; BRU CONAS2; SKE =33B; BRU CONAS3
       BRU CONASM
CONBR2 SKE =43B; BRU CONBR3; GCI DPTR; BRU CONAS2; SKG ZERO; BRU CONASR
       SKE =57B; BRU CONASR
CONELS LDX =-6; CLA; WCI VPTR; BRX *-1; BRU CONASR
CONBR3 SKG =31B; SKG =17B; BRU *+2; BRU CONELS; LDX =-7; SKE DIRTAB,2
       BRU *+2; BRU *+3; BRX *-3; BRU CONELS; LDA ONE; STA CONCOL
CONCGT GCI DPTR; BRU CONELS; SKG ZERO; BRU CONCGT; SKG =31B; SKG =17B
       BRU *+3; MIN CONCOL; BRU CONCGT; LDA CONCOL; SKG ONE; BRU CONELS
       GCI GPTR; NOP
CONCWT WCI VPTR; GCI GPTR; BRU CONCL7; SKG ZERO; BRU *-3; SKG =31B
       SKG =17B; BRU *+2; BRU CONCWT; SKE =14B; BRU *+5
       GCI GPTR; BRU CONCL7; SKG ZERO; BRU *-3; WCD GPTR
CONCL7 LDA CONCOL; ADD =-6; COPY AX,A; WCI VPTR; BRX *-1; BRU CONASR
       DATA 42B,45B,51B,55B,56B,63B,64B
DIRTAB EQU *
NULVPT ZRO
       LDA =VBUFF; ADD =VBUFF; ADD =VBUFF; SUB ONE; CAB; STP VPTR
       BRR NULVPT
CONOUT PRT VPTR; LIN 1
       SKN CONMUL; BRU CONBR1; BRU CONDO1
CONDON SKE ONES; BRU CONKLZ; SND CR; BRU CONDO1
CONKLZ LDA IMMIN; BRS 20; CLA; STA IMMIN; BRR CONDO
CONMUL ZRO
GPTR   BSS 2
VPTR   BSS 2
VBUFF  BSS     44
CONCOL ZRO
*
*  THIS ROUTINE ASKS FOR INPUT FILE(S) AND AN OUTPUT FILE AND INVOKES
*  A PROCESSOR (CATDO) THAT CATALOGS THE MODELS STORED ON THE INPUT
*  FILES TO A FILE OR TO THE TERMINAL.  AN INDEX IS THE FIRST PRINTOUT.
*
CATLOG LDA TRMCHR; SKE ZERO; SND FILES; LDA ONES; STA FILCNT; LDX COMINF
       CSTR CBUFF; STP CPTR; STP DPTR; CXA; SKG ONES; BRU RDERR
       BRK DPTR; BRU *+6; BRM CHKFIL; MIN FILCNT; BRM TELCHK; BRU MST
       BRU *-6; BRM CHKFIL; MIN FILCNT; BRM TELCHK; BRU MST
       SKN FILCNT; BRU MST; SND OUTTO; LDA ONES; LDX COMINF
       CSTR DBUFF; STP DPTR; XXA; SKG ONES; BRU RDERR+1; XXA
       BRM OPNOUT; BRU MST; SND CRCR; LDA IMMOUT; SKG ONE; LDA ONES
       STA FILCNT; CLA; STA PAGE; STA LSTFIL; STA CATFLG; LDB =61
       SKN FILCNT; LDB =39; STB LINPAG
CATCYC BRK CPTR; BRU *+5; BRM OPNIN; BRU MST; BRM CATDO; BRU CATCYC
       BRM OPNIN; BRU MST; MDE LSTFIL; BRM CATDO; SND EOJ
       LDA IMMOUT; SKE ONE; BRU MST; SNDA CRCR; SNDA CRCR; BRU MST
CATDO  ZRO
       LDA 400B; ADD =50; STA MDADR1; STA MDADR2; BRM HEADNG
CPAS1  LDA ONES; LDX IMMIN; CSTR VBUFF; STP VPTR; CXA; SKE ONES
       BRU *+2; BRU CPAS1; SKG ONES; BRU NOMOD1; BRM CHKMOD; BRU CPAS1
       CLA; STA* MDADR1; MIN* MDADR1; WRT INDEX; LIN 2; BRM PRTMOD
CPAS1A LDA ONES; LDX IMMIN; CSTR VBUFF; STP VPTR; CXA; SKE ONES
       BRU *+2; BRU CPAS1A; SKG ONES; BRU CPAS2
       BRM CHKMOD; BRU *+2; BRU CPAS1B; MIN* MDADR1; BRU CPAS1A
CPAS1B MIN MDADR1; CLA; STA* MDADR1; MIN* MDADR1; LDA LINLFT
       SKG ZERO; BRU *+2; BRU CPAS1C; BRM CATFIL; BRM HEADNG
CPAS1C BRM PRTMOD; BRU CPAS1A
CPAS2  CLA; SCP IMMIN; BRU RANERR
CPAS2X LDA LINLFT; SKG ONE; BRU *+2; BRU CPAS2A; BRM CATFIL; BRM HEADNG
CPAS2A LIN 2; BRM PAGCHK; BRU *-4
CPAS2B LDA ONES; LDX IMMIN; CSTR VBUFF; STP VPTR; CXA; SKE ONES
       BRU *+2; BRU CPAS2B; SKG ONES; BRU CATEOF; BRM CHKMOD; BRU CPAS2B
CPAS2C PRT VPTR; LIN 1; MDE* MDADR2
       LDA* MDADR2; SKE ZERO; BRU CPAS2E; MIN MDADR2; BRU CPAS2X
CPAS2E LDA ONES; LDX IMMIN; CSTR VBUFF; STP VPTR; CXA; SKE ONES
       BRU *+2; BRU CPAS2E; SKG ONES; BRU CATEOF; BRU CPAS2C
NOMOD1 WRT NOMODL; LIN 3; LDA LINLFT; SKG =2; BRU CATEOF; LIN 3
CATEOF BRM CATKLZ; LDA LINPAG; LRSH 1; XMA LINLFT; SKG LINLFT
       BRU CATND1; XMA LINLFT; SKG =20; BRU *+2; BRU CATND1; BRM CATFIL
       SKN LSTFIL; BRR CATDO; BRU CATND2
CATND1 SKN LSTFIL; BRU CATND3; BRM CATFIL
CATND2 SKN FILCNT; BRR CATDO; WRT SEPMRK; BRR CATDO
CATND3 MDE CATFLG; BRR CATDO
*
*  PRINTS OUT CURRENT MODEL ID FOR "INDEX"
*
PRTMOD ZRO
       SPC 7; LDA =6; ADM VPTR; GCI VPTR; BRU *+10; SKG ZERO; BRU *-3
       CIO IMMOUT; GCI VPTR; BRU *+3; SKE ZERO; BRU *-4; LIN 1
       BRR PRTMOD; LDA =12B; LDX =-6; CIO IMMOUT; BRX *-1; BRU *-6
*
*  BUILDS AND PRINTS OUT THE PAGE HEADING
*
HEADNG ZRO
       LDA CATFLG; SKE ZERO; BRU CHEADN; LDA LINPAG; STA LINLFT; CLA
       STA LINES; SKN FILCNT; BRU *+3; WRT SEPMRK; LIN 3; SPC 8
       LDA =THDNG; ADD =THDNG; ADD =THDNG; SUB ONE; CAB; ADD =32
       XAB; STP HPTR; DAT HPTR; PRT HPTR; SPC 7; WRT PAGENO; MIN PAGE
       LDA PAGE; SKG =9; SPC 1; LDB =10; LDX IMMOUT; BRS 36
CHEADN LIN 2; WRT MSGFIL; PRT TFILPT; LIN 2; CLA; STA CATFLG; BRR HEADNG
*
*  FILLS REMAINDER OF PAGE
*
CATFIL ZRO
       LDA LINES; SUB LINPAG; CAX; LIN 1; BRX *-1; SKN FILCNT
       BRR CATFIL; LIN 5; BRR CATFIL
*
*  CHECKS IF FIRST WORD IN CURRENT VPTR IS "MODEL:"
*  SKIP RETURN IF IT IS
*
CHKMOD ZRO
       LDX =-2; STX MODCHK; LDA VBUFF+2,2; SKE MODCHK,2; BRU *+2
       MIN MODCHK; BRX *-4; SKN MODCHK; MIN CHKMOD; BRR CHKMOD
       ASC  'MODEL:'
MODCHK ZRO
*
*  CLOSES CURRENT INPUT FILE
*
CATKLZ ZRO
       LDA IMMIN; BRS 20; CLA; STA IMMIN; BRR CATKLZ
*
*  CHECKS LINES TO GO ON PAGE WITH LINE COUNT OF NEXT MODEL TO BE
*  PRINTED...IF THE MODEL WILL FIT, DOES A SKIP RETURN...RETURNS
*  NO. OF LINES LEFT ON PAGE IF NEXT MODEL IS PRINTED IN A-REGISTER
*
PAGCHK ZRO
       LDA LINLFT; SUB* MDADR2; SKG ONES; BRR PAGCHK; MIN PAGCHK; BRR PAGCHK
RANERR SNDA SYSERR; BRU MST
SYSERR ASC     '$*** RANDOM-FILE COMPUTER ERROR ***$'
       ASC     '$*** OPERATION ABORTED ***$/'
NOMODL ASC     'NO MODELS ON FILE/'
MSGFIL ASC     'FILE:  /'
INDEX  ASC     'INDEX:/'
SEPMRK ASC     '----/'
THDNG  ASC     'TYMSHARE ECAP MODEL CATALOG  -  '
       BSS     6
PAGENO ASC     'PAGE /'
HPTR   BSS     2
LINLFT BSS     1   CONTAINS NO. OF LINES LEFT ON CURRENT PAGE
LINES  BSS     1   CONTAINS NO. OF LINES USED ON CURRENT PAGE
LINPAG BSS     1   ALLOWABLE LINES/PAGE ON IMMOUT
PAGE   BSS     1   CURRENT PAGE NUMBER
LSTFIL BSS     1   FLAG FOR LAST FILE BEING OPERATED ON
MDADR1 BSS     1   STORAGE INDEX FOR LINES IN EACH MODEL
MDADR2 BSS     2   RETRIEVAL INDEX FOR LINES IN EACH MODEL
CATFLG BSS     1   =-1 IF MORE THAN 1 FILE ON CURRENT PAGE
*  MDADR1  MIN FOR EACH NEW MODEL, MIN* FOR EACH NEW LINE IN MODEL
*  FILCNT  >0 IF IMMOUT = FILE, =-1 IF IMMOUT = TEL
*  CURRENT FILE POINTERS IN TFILPT
EXPERT LDA IOPTON; MRG SIGN; BRU OPTSET
NEXPRT LDA IOPTON; EOR SIGN; BRU OPTSET
PAUSE  LDA IOPTON; MRG ONE; BRU OPTSET
NPAUSE LDA IOPTON; EOR ONE; BRU OPTSET
FORMAT LDA IOPTON; MRG OPTFOR; BRU OPTSET
NOFRMT LDA IOPTON; EOR OPTFOR; BRU OPTSET
LIST   LDA IOPTON; MRG OPTLIS; BRU OPTSET
NOLIST LDA IOPTON; EOR OPTLIS; BRU OPTSET
TIME   LDA IOPTON; MRG OPTTIM; BRU OPTSET
NOTIME LDA IOPTON; EOR OPTTIM; BRU OPTSET
DATE   LDA IOPTON; MRG OPTDAT; BRU OPTSET
NODATE LDA IOPTON; EOR OPTDAT
OPTSET STA IOPTON; SND OKMSG; BRU MST
OKMSG  ASC 'OK.$/'
CANCEL CLAB; STA IOPTON; STA IFROM; STP PTIFLX; STP PTIFIL; STP PTSAVE
       LDA IF; BRS 20; LDA OF; BRS 20; SND OKMSG; BRU START
SAVE   LDA SF; BRS 20; LDA =2; STA SF; LDA TRMCHR; SKE ZERO; SND MSGTO
       LDA ONES; LDX COMINF; CSTR SAVEFL; STP PTSAVE; XXA; SKG ONES
       BRU RDERR+1; XXA; BRM OPNOUT; BRU MST; BRM CLOSE; LDA IOPTON
       MRG OPTSAV; BRU OPTSET
NSAVE  LDA IOPTON; EOR OPTSAV; BRU OPTSET
SIGN   DATA    4B7             EXPERT
OPTDAT DATA    2B4             DATE
OPTTIM DATA    1B4             TIME
OPTLIS DATA    1B3             LIST
OPTFOR DATA    1B2             FORMAT
OPTSAV DATA    10B             SAVE
       DATA     1              PAUSE
OPTION LDX =SIGN-OPTION; LDA IOPTON; SKA OPTION,2; SNDA* OPTMSG,2
       BRX *-3; LDA IOPTON; SKA ONES; BRU MST; SNDA NOPT; BRU MST
       DATA OPTM1,OPTM2,OPTM3,OPTM5,OPTM6,OPTM8,OPTM9
OPTMSG EQU *
OPTM1  ASC     'EXPERT$/'
OPTM2  ASC     'DATE$/'
OPTM3  ASC     'TIME$/'
OPTM5  ASC     'LIST$/'
OPTM6  ASC     'FORMAT$/'
OPTM8  ASC     'SAVE$/'
OPTM9  ASC     'PAUSE$/'
NOPT   ASC     'NONE$/'
*
*  LOAD ROUTINE FOR EXPLICIT MODE
*
*  GETIN ACCEPTS AND CHECKS STACKED FILES AND OPENS THE FIRST ONE.
*  SKIP RETURN IF NO ERROR, APPROPRIATE ERROR MESSAGES ARE TYPED
*
LOAD   LDA TRMCHR; SKE ZERO; SND FROM; BRM GETIN; BRU MST; BRU MST
GETIN  ZRO
       LDA IF; BRS 20; CLAB; STA IF; STP PTIFIL
       LDA ONES; STA FILCNT; LDX COMINF
       CSTR IFILES; STP PTIFLX; STP DPTR; CXA; SKG ONES; BRU RDERR
       BRK DPTR; BRU *+4; BRM INFCHK; MIN FILCNT; BRU *-4
       BRM INFCHK; MIN FILCNT; SKN FILCNT; BRR GETIN
       BRK PTIFLX; NOP; STP PTIFIL; STP TFILPT; BRS 64
       BRU *+4; STA IF; MIN GETIN; BRR GETIN
       SNDA CNTOPN; TCO =32B; TCO ZERO; PSTR TFILPT; TCO =155B
       BRR GETIN
INFCHK ZRO
       STP TFILPT; BRS 48; BRU INFCK3; LDB =INFBUF; LDX =4; BRS 96
       LDA INFBUF+1; SKG ZERO; BRU INFRTN
       CLA; LDB INFBFF; LSH 3; SKE =2; BRU INFCK3; CLA; LSH 3
       SKE =3; BRU INFCK2; CLA; LSH 12; SKA =4; BRU INFCK1
INFRTN MIN INFCHK; BRR INFCHK
INFCK1 SNDA CNTOPN; BRU INFPRT
INFCK3 SNDA ERRNAM; BRU INFPRT+2
INFCK2 SNDA FLTYWG
INFPRT TCO =32B; TCO ZERO; PSTR TFILPT; TCO =155B; BRR INFCHK
INFBUF BSS 3
INFBFF ZRO
*
*  WRITE FOR EXPLICIT MODE
*
*  GETOUT OPENS SOLUTION OUTPUT FILE
*      SKIP RETURN IF NO ERRORS, APPROPRIATE ERROR MESSAGES ARE TYPED
*
WRITE  LDA TRMCHR; SKE ZERO; SND MSGTO; BRM GETOUT; BRU MST; BRU MST
GETOUT ZRO
       LDA OF; BRS 20; LDA =43000001B; STA OF
       LDA ONES; LDX COMINF; CSTR DBUFF; STP TFILPT; CXA; SKG ONES; BRU RDERR
       LDA COMINF; SKG ZERO; BRU *+3; LDX =3; BRU *+3; MRG =3B4; CAX
       LDP TFILPT; BRS 65; BRU *+12; MRG =43B6; STA OF; EOR =43B6
       SKG =2; BRU *+5; LDA COMINF; SKG ZERO; BRU *+2; CIO COMINF
       MIN GETOUT; BRR GETOUT; SNDA CNTOPN; BRM PTBDNM; BRR GETOUT
RUNRUN LDA IOPTON; ETR SMASKE; STA IOPTON
       SKN IOPTON; BRU RUNBEG; SND MSGIN; BRM GETIN
       BRU *-2; SND MSGOUT; BRM GETOUT; BRU *-2; SND MSGLST; BRM KONFRM
       BRU *+4; LDA IOPTON; MRG =11B2; STA IOPTON; SND MSGPAU; BRM KONFRM
       BRU *+2; MIN IOPTON; SND MSGHDG; BRM KONFRM; BRU GOTOIT; LDA IOPTON
       MRG =3B4; STA IOPTON; BRU GOTOIT
RUNBEG SND RUNM1; BRM GETIN; BRU *-2; SND RUNM2; BRM GETOUT; BRU *-2
       SND RUNM3; BRM KONFRM; BRU *+4; LDA IOPTON; MRG =11B2; STA IOPTON
       SND RUNM4; BRM KONFRM; BRU *+2; MIN IOPTON; SND RUNM5; BRM KONFRM
       BRU *+4; LDA IOPTON; MRG =3B4; STA IOPTON; SND CR; BRU GOTOIT
BATCH  LDA IOPTON; ETR SMASKE
       MRG =40031100B; STA IOPTON; SND BATCH1; BRM GETIN
       BRU *-2; SND BATCH2; BRM GETOUT; BRU *-2; SND CRCR; BRU GOTOIT
BATCH1 ASC 'READ FILE(S): /'
BATCH2 ASC 'PUNCH TO: /'
SMASKE DATA 40000010B    EXPERT AND SAVE OPTIONS
RUNM1  ASC '$ENTER INPUT-OUTPUT MEDIA [DISK FILE(S) OR TERMINAL]$$'
       ASC 'INPUT FROM: /'
RUNM2  ASC ' OUTPUT TO: /'
RUNM3  ASC '$PRINT INPUT CIRCUIT WITH SOLUTION? /'
RUNM4  ASC '$PAUSE AFTER EACH OPERATION? /'
RUNM5  ASC '$DO YOU WANT A HEADING WITH THE SOLUTION? /'
*
*  SKIP RETURN IF YES, ELSE NO SKIP
*
KONFRM ZRO
       CIO COMINF; SKE =71B; BRU *+2; MIN KONFRM; SKG =77B; BRU *+2
       BRR KONFRM; CIO COMINF; BRU *-4
MSGIN  ASC 'INPUT: /'
MSGOUT ASC 'OUTPUT: /'
MSGLST ASC 'CIRCUIT? /'
MSGPAU ASC 'PAUSE? /'
MSGHDG ASC 'HEADING? /'
*
*  GOES TO CHOSEN ANALYSIS
*
EXECUT LDA IF; SKE ZERO; BRU GOTOIT; LDA TRMCHR; SKE ZERO; SND ANALYS
       LDA ONES; LDX COMINF; CSTR DBUFF; STP CPTR; CXA; SKG ONES; BRU RDERR
ANLBRU LDB DBUFF; CLA; LSH 16; LDX =-3; SKE CHOICE,2; BRX *-1
       STX LERR; BRU GOGO,2
       ASC ' TR AC DC'
CHOICE EQU *
       NOP; NOP; BRU GO
GOGO   BRM NULVPT; LDP CPTR; STP DPTR; GCI DPTR; BRU GOTOIT
       SKE =33B; BRU *-3; GCI DPTR; BRU GOTOIT; SKG ZERO; BRU *-3
       CAB; LDA DPTR; SUB ONE; STA CPTR; CBA; WCI VPTR; GCI DPTR
       BRU *+2; BRU *-3; LDB VBUFF; BRU ANLBRU+1
       DATA TRL,ACL,DCL
GO     CXA; CNA; STA NTR; LDA ONE; STA IFROM
*  NOP 113 TURNS OFF ALTMODE.REPLACE W/ BRS 113 WHEN MONITOR IS FIXED
       BRS 113
       LDP* GO,2; BRS 64; BRU ERLINK; STA 1002B
*  RESTORES FOS POPS
       LDX =POPTAB-POPTND; LDA 200B,2; LDB POPTND,2; STB 200B,2
       STA POPTND,2; BRX *-4; WIO 1002B; SBRM* 777B
LNKERR ASC '$$AN ECAP LIBRARY FILE IS MISSING'
       ASC '.$CALL TYMSHARE FOR ASSISTANCE AND MENTION'
       ASC ' THIS CODE:  /'
LERR   ZRO
ERLINK STX ABREGS; SNDA LNKERR; LDA LERR; CNA; LDB =10; LDX ONE; BRS 36
       TCO =15B; LDA ABREGS; BRS 36; SNDA CRCR; BRS 10
GOTOIT LDA IF; SKG ONE; BRU GODOIT
       LDA ONES; LDX IF; CSTR DBUFF; STP CPTR; CXA; SKG ONES; BRU GOTODO
       BRU ANLBRU
GOTODO SKE ONES; BRU *+2; BRU GOTOIT; LDA IF; BRS 20; CLAB; STA IF
       STP PTIFIL
       BRK PTIFLX; BRU GODOIT; STP PTIFIL; BRS 64; BRU *+3; STA IF
       BRU GOTOIT; SNDA CNTOPN; TCO =32B; TCO ZERO; PSTR PTIFIL
       TCO =155B; BRU MST
GODOIT SND ANALYS; LDA ONES; LDX IF; CSTR DBUFF; STP CPTR; CXA
       SKG ONES; BRU *+2; BRU ANLBRU; SKE ONES; BRU RDERR; BRU GODOIT
ANALYS ASC 'ANALYSIS: /'


*  INITIATES A NEW COMMAND FILE
*
COMNDZ LDA TRMCHR; SKE ZERO; SND FROM
COMND1 LDA ONES; LDX COMINF; CSTR COMBUF; STP COMPTR
       LDA COMINF; BRS 20; CLA; STA COMINF
       CXA; SKG ONES; BRU RDERR
       LDP COMPTR; CLX; BRS 64; BRU COMER1
       XAB; SKE =3; BRU COMER3; CBA; STA COMINF; BRS 151; BRU MST
COMER1 SNDA ERRNAM
COMER2 PSTR COMPTR; SNDA COMSG1; BRU COMND1
COMER3 CBA; BRS 20; SNDA FLTYWG; SNDA COMSG2; BRU COMER2
COMPTR BSS 2
COMBUF BSS 20
COMSG1 ASC '$COMMANDS FROM: /'
COMSG2 ASC ': /'


*  PRIVILEGED COMMAND (REQUIRES TYMSHARE STATUS) THAT PRINTS OUT
*  THE NAMES OF ALL ECAP LINK FILES
*
ECPLNK BRS 39; SKA SIGN; BRU *+2; BRU BRANCH; TCO =155B
       LDX =-17; BRX *+2; BRU MST; SNDA FILSAV,2; PSTR LFILES,2
       TCO =155B; BRX *-5; BRU MST

*  PRIVILEGED COMMAND (REQUIRES TYMSHARE STATUS) THAT PRINTS OUT
*  THE NAMES OF ANY BAD ECAP LINK FILES FOLLOWED BY THE EXEC
*  ERROR CODE.  IF NO FILES ARE BAD, PRINTS "NONE".
*
BADFLZ BRS 39; SKA SIGN; BRU *+2; BRU BRANCH; TCO =155B
       LDA ONES; STA BADCNT; LDX =-17
BADFZ1 BRX *+2; BRU BADFZ2; STX BADXRG; LDP LFILES,2; CLX; BRS 64
       BRU *+4; BRS 20; LDX BADXRG; BRX BADFZ1
       STX BADCOD; LDX BADXRG; SNDA FILSAV,2; PSTR LFILES,2
       SNDA BADABC; LDA BADCOD; LDB =10; LDX ONE; BRS 36; TCO =155B
       LDX BADXRG; MIN BADCNT; BRX BADFZ1
BADFZ2 SKN BADCNT; BRU MST; SNDA ALLGUD; BRU MST
ALLGUD ASC 'NO BAD FILES$/'
BADABC ASC '  ERROR CODE: /'
BADXRG ZRO
BADCOD ZRO
BADCNT ZRO

CAPABS PTX     CAPTXT
       BRU     MST
HELP   PTX     HELPMG
       BRU     MST
VERNO  SNDA    VERZN
       PSTR    22B    VERSION NUMBER STRING POINTERS
       TCO     =155B
       BRU     MST
VERZN  ASC     'VERSION /'
CHARGZ SNDA    COST
       BRU     MST
COST   ASC     'NO PREMIUM CHARGE$/'
CREDTS SNDA    GLORY
       BRU     MST
GLORY  ASC     'WRITTEN BY THAD FLORYAN, TYMSHARE TECHNICAL DIVISION$/'
DEBUG  BRS     39
       SKA     SIGN
       BRU     *+2
       BRU     BRANCH
*
*  PASSWORD ROUTINE TO ALLOW USE OF DEBUG ROUTINES (2ND LEVEL OF
*  SECURITY).  PASSWORD IS HASHED AND MUST BE ENTERED AT ASSEMBLY
*  TIME.  TO ENTER A NEW PASSWORD, A ROUTINE SIMILAR TO THE ONE
*  BELOW MUST BE USED  TO FORM THE HASH
*
       SNDA KEYMSG; LDA =3; LDX ONES; BRS 12; CLAB; BRU PSWIN
PSWAN  ADD =77B; ADD INPASS; LDB INPASS+1
       MUL PIZAZZ; LSH 7; MUL PIZAZZ    HASH IT
PSWIN  STP INPASS; CIO ZERO; SKG =77B; BRU PSWAN
       LDA INPASS; SKE PKEY1; BRU DBADUG
       XAB; SKE PKEY2; BRU DBADUG; CLA; LDX ONES; BRS 12
       TCO     =155B
       CIO     COMINF
       SKE     =144B            DISABLE PROGRAMMED INTERRUPT
       BRU     DBNXT
       LDA     =2B6
       SKE     ST+1
       BRU     *+2
       BRU     MST
       STA     ST+1
       CLA
       STA     201B
       BRS     78
       BRU     MST
DBNXT  SKE     =145B           ENABLE PROGRAMMED INTERRUPT
       BRU     DBNXT1
       LDA     BRMALT
       STA     201B
       STA     ST+1
       BRU     MST
BRMALT BRM     ALTMOD
DBNXT1 SKE =146B; BRU DBNXT2   LISTS ALL FILES USED
       LDX =-17; BRX *+2; BRU *+5; SNDA FILSAV,2; PSTR LFILES,2
       TCO =155B; BRX *-5; SNDA FILSAV; PSTR PTSAVE; SNDA FILCIN
       PSTR PTIFIL; SNDA FILRIN; PSTR PTIFLX; SNDA FILTFP
       PSTR TFILPT; TCO =155B; BRU MST
       ASC 'TRC: /TRL: /AC2: /AC1: /ACL: /DCC: /DCL: /SFE: /'
FILSAV ASC 'SAV: /'
FILCIN ASC '$CIN: /'    CURRENT INPUT
FILRIN ASC '$RIN: /'    REST OF INPUT STRING
FILTFP ASC '$TFP: /'    TEMPORARY FILE POINTERS
DBNXT2 SKE =141B; BRU DBNXT4; SNDA AUTHOR; BRU MST
AUTHOR ASC '$WRITTEN AND IMPLEMENTED BY THAD FLORYAN$$/'
DBADUG CLA; LDX ONES; BRS 12; BRU BRANCH
KEYMSG ASC '$KEY: /'
PIZAZZ DATA 25773301B    7**8
INPASS BSS 2
PKEY1  DATA 11016123B    CIPHERED
PKEY2  DATA 23507640B        PASSWORD

*
*  WRITE ROUTINE FOR DEBUG
*  WRITES ALL ECAP FILES OUT TO NEW FILES
*
DBNXT4 SKE =167B; BRU MST; SNDA WLOAD; CLA; LDX ONE
       BRS 63; BRU SWPLNK; STA SWPFIL; CLA; WIO SWPFIL; STA 1237B
       LDA =37777B; WIO SWPFIL; LDA =75B; WIO SWPFIL; BRM SWAPOP
       LDA =4B4; CLX; BIO SWPFIL; NOP; LDA SWPFIL; BRS 20; BRM SWAPOP
SWPLNK TCO =155B; LDX =-17
SWPGET BRX *+2; BRU SWPEOJ; STX BADXRG; SNDA FILSAV,2; CLA; LDX =2
       BRS 63; BRU SWPLIT; STA SWPOUT; LDX BADXRG; LDP LFILES,2
       CLX; BRS 64; BRS 10; STA SWPFIL
SWPRDF LDA =256; LDX =SWPBUF; BIO SWPFIL; NOP; LDB =4B5; SKB SWPFIL
       BRS 10; LDB =2B5; SKB SWPFIL; BRU SWPNXT; LDA =256
       LDX =SWPBUF; BIO SWPOUT; NOP; BRU SWPRDF
SWPNXT SUB =SWPBUF; LDX =SWPBUF; BIO SWPOUT; NOP; LDA SWPFIL; BRS 20
       LDA SWPOUT; BRS 20
SWPLIT LDX BADXRG; TCO =155B; BRX SWPGET
SWPEOJ SNDA EOJ; BRU MST
WLOAD  ASC '$LOADER: /'
SWAPOP ZRO
       LDX =POPTAB-POPTND; LDA 200B,2; LDB POPTND,2
       STB 200B,2; STA POPTND,2; BRX *-4; BRR SWAPOP
SWPFIL ZRO
SWPOUT ZRO
SWPBUF BSS 257

*
*
*
*  P R O G R A M M E D   O P E R A T O R S
*
*
*
*
*  POP ROUTINE TO PRINT A STRING TO THE TERMINAL
*
*  CALLING SEQUENCE:
*
*              PSTR    PTR
*              NORMAL RETURN
*
*      WHERE PTR IS THE FIRST CELL OF A STRING POINTER PAIR
*
*  REGISTERS AFFECTED:  A,B
*
PSTRPP STX     PXREG
       EAX*    0
       LDP     0,2
       LDX     ONE
       BRS     35
       LDX     PXREG
       BRR     0
*
*  -POP ROUTINE TO INPUT A STRING FROM A FILE AND STORE THE STRING
*   AT A GIVEN LOCATION FOR ENTRY TO A COMMAND PROCESSING LANGUAGE...
*   CONTROL CHARACTERS ARE NOT STORED WITHIN THE STRING
*  -INPUT TERMINATES ON CR,LF,EOF OR CTRL-D (AND CONDITIONALLY A SPACE)
*  -LEADING SPACES ARE IGNORED
*  -IF INPUT IS FROM OTHER THAN THE TERMINAL, EDITING GLITCHES ARE NOT
*   SENT TO THE TERMINAL
*  -FEATURES CONTROL-A, -Q AND -W EDITING
*
*  CALLING SEQUENCE:
*
*              LDA    OP
*              LDX    FILE
*              CSTR   BUFF
*              NORMAL RETURN
*
*  INPUTS:
*
*      OP   = 0  RETURNS ON FIRST NONLEADING SPACE,CR,LF,CTRL-D OR EOF
*           =-1  WRITES ALL ALPHAMERIC CHARACTERS TO THE STRING AND
*                RETURNS ON CR, LF, CTRL-D OR EOF
*
*      FILE:     FILE NUMBER FROM WHICH INPUT IS TO BE ACCEPTED
*
*      BUFF:     STRING BUFFER STORAGE LOCATION ADDRESS
*                I.E.  FOR A STRING OF 72 CHARACTERS, BUFF BSS 24
*                WOULD BE ADEQUATE
*
*  RETURN:
*
*      A AND B REGISTERS CONTAIN THE STRING POINTERS TO THE STRING
*           STORED AT BUFF
*      X-REG >= 0  TERMINATING CHARACTER IS IN X-REGISTER
*             =-1  STRING IS NULL
*             =-2  EOF ENCOUNTERED
*
CSTRPP CXB
       STP     WORK
       EAX*    0
       CXA
       ETR     =37777B
       STA     PTR
       ADD     PTR
       ADD     PTR
       SUB     ONE
       CAB
       STP     PTR
CFIRST CIO     FILE            -ELIMINATES LEADING SPACES
       SKN     FILE
       BRU     *+4
EOFRTN LDX     =-2
ERRRTN LDP     PTR
       BRR     0
       SKE     ZERO
       SKG     =77B
       BRU     CCHK
       SKE     =155B
       BRU     *+2
       BRU     ZROSTR
       SKE     =152B
       BRU     *+2
       BRU     ZROSTR
       SKE     =137B
       BRU     *+2
       BRU     EOFRTN
       SKE     =144B
       BRU     *+2
       BRU     EOFRTN
       SKE     =135B
       BRU     CNEXT+1
       CIO     FILE
       BRU     CFIRST
CCHK   SKE     ZERO
       BRU     *+2
       BRU     CFIRST
       WCI     PTR
CNEXT  CIO     FILE
       SKN     FILE
       BRU     *+2
       BRU     EOFRTN
       SKE     ZERO
       SKG     =77B
       BRU     CKWORK
       SKE     =155B
       BRU     *+4
GOBACK CAX
       LDP     PTR
       BRR     0
       SKE     =152B
       BRU     *+2
       BRU     GOBACK
       SKE     =141B
       BRU     CKCTRQ
       GCD     PTR
       BRU     *+5
       LDA     FILE
       SKG     ZERO
       TCO     =77B
       BRU     CNEXT
ZROSTR LDX     ONES
       BRU     ERRRTN
CKCTRQ SKE     =161B
       BRU     EOFCK
       LDA     FILE
       SKG     ZERO
       TCO     =76B
       BRU     ZROSTR
EOFCK  SKE     =137B
       BRU     *+2
       BRU     EOFRTN
       SKE     =135B
       BRU     CKCTRW
       CIO     FILE
       CNA
       COPY    AX,A
       WCI     PTR
       BRX     *-1
       BRU     CNEXT
CKWORK SKN     WORK
       SKE     ZERO
       BRU     *+2
       BRU     GOBACK
       WCI     PTR
       BRU     CNEXT
CKCTRW SKE     =167B
       BRU     CNEXT
       LDA     FILE
       SKG     ZERO
       TCO     =74B
CTRLWR GCD     PTR             -CONTROL W ROUTINE
       BRU     ZROSTR
       SKE     =14B            -COMMA
       BRU     *+3
WRTBCK WCI     PTR
       BRU     CNEXT
       SKE     ZERO
       BRU     CTRLWR
       BRU     WRTBCK
WORK   ZRO
FILE   ZRO
PTR    BSS     2
*
*  TWO POP ROUTINES TO OUTPUT ASC TEXT TO THE TERMINAL
*  SND:  OUTPUTS TEXT ONLY IF THE TERMINAL IS THE COMMAND INPUT FILE
*  SNDA: ALWAYS TYPES THE MESSAGE
*
*  CALLING SEQUENCE:
*
*              SND    MSG
*              NORMAL RETURN
*
*      WHERE MSG IS THE STARTING CELL OF THE TEXT BLOCK
*
*  REGISTERS AFFECTED:  A,B
*
*
SNDPOP STX    PXREG
       LDA     COMINF
       SKE     ZERO
       BRR     0
SENDIT EAX*    0
       CXA
       ETR     =37777B
       LDB     ONES
       LDX     ONE
       BRS     34
       LDX     PXREG
       BRR     0
SNDAPP STX    PXREG
       BRU     SENDIT
*
*  POP ROUTINE TO OUTPUT PACKED TEXT TO THE TERMINAL
*      \  =  74B  IS INTERPRETED AS A CARRIAGE RETURN
*      ^  =  76B  IS INTERPRETED AS END-OF-TEXT FLAG
*      _  =  77B  IS INTERPRETED AS MULTIPLE SPACE FLAG...THE
*                 SUCCEEDING CHARACTER IS THE SPACE COUNT
*
*  CALLING SEQUENCE:
*
*              PTX    BUFF
*
*      WHERE BUFF IS THE STARTING CELL OF THE TEXT BLOCK
*
*  REGISTERS AFFECTED:  A,B
*
*
PTXPOP STX PXREG
       LDA ONES; STA MSCNT; EAX* 0; BRU *+2
NXT    EAX 1,2; LDB 0,2; STX XREG1; LDX =-4
R      CLA; LSH 6; SKN MSCNT; BRU MS; SKE =76B; BRU *+3; LDX PXREG
       BRR 0; SKE =77B; BRU *+3; MIN MSCNT; BRU F; SKE =74B; BRU *+2
       LDA =155B; CIO ONE
N      LDA ONES; STA MSCNT
F      BRX R; LDX XREG1; BRU NXT
MS     CNA; STX XREG2; COPY AX,A; CIO ONE; BRX *-1; LDX XREG2; BRU N
MSCNT  ZRO
XREG1  ZRO
XREG2  ZRO
*
*  POP ROUTINE TO BREAK UP A STRING CONTAINING COMMAS AND ELIMINATES
*  LEADING AND TRAILING SPACES
*
*  CONVERTS "ONE,TWO" TO "ONE" AND "TWO"
*  CONVERTS "/1,2/,/3,4/" TO "/1,2/" AND "/3,4/"
*
*  CALL:
*
*              BRK PTR
*              LAST RETURN
*              NORMAL RETURN
*
*  RETURNS:
*
*      NO SKIP: A=-1 IF A NULL STRING (OR) LAST STRING POINTERS IN
*               A AND B REGISTERS
*
*      SKIP:    NEXT STRING POINTERS IN A AND B, PTR IS UPDATED IN
*               MEMORY AND AT LEAST ONE MORE STRING TO GO
*
BRKPOP EAX* 0; LDP 0,2; STP BRKOLD; CAB; STP BRKPTR; GCI BRKOLD
       BRU BRKBCK; SKE ZERO; BRU *+4; MIN BRKPTR; MIN BRKPTR+1
       BRU *-6; SKE =17B; BRU *+2; BRU BRKFIL; MIN BRKPTR+1
       GCI BRKOLD; BRU BRKRTN+1; SKE =14B; BRU BRKAGN
BRKRTN MIN 0; LDP BRKOLD; STP 0,2; LDP BRKPTR; BRR 0
BRKAGN SKE ZERO; BRU *-11; GCI BRKOLD; BRU BRKRTN+1; SKE =14B
       BRU *-3; BRU BRKRTN
BRKBCK LDA ONES; CAB; BRU BRKRTN+2
BRKFIL MIN BRKPTR+1; GCI BRKOLD; BRU BRKRTN+1; SKE =17B; BRU BRKFIL
       MIN BRKPTR+1; GCI BRKOLD; BRU BRKRTN+1; SKE =14B
       BRU *-3; BRU BRKRTN
BRKOLD BSS 2
BRKPTR BSS 2
*
*  POP ROUTINE TO APPEND CURRENT DATE AND TIME TO A STRING.  THIS
*  ROUTINE CREATES AN 18 CHARACTER STRING IN THE FORM:
*
*              JAN.12,1970  13:15
*
*  CALLING SEQUENCE:
*
*              DAT    PTR
*              NORMAL RETURN
*
*  REGISTERS AFFECTED:  ALL
*
DATPOP CLX; EAX* 0; STX DATADR; LDP 0,2; STP BRKPTR; BRS 42
       STB PXREG; STX YEAR
       ABC; DIV =1800; ADD PXREG; CAX; LRSH 16; STA MONTH; CXA
       ETR =177777B; RSH 23; DIV =1440; ADD ONE; STA DAY; CBA
       RSH 23; DIV =60; STP HOURS; LDX MONTH; LDB DATJAN,2; LDX =-3
       CLA; LSH 8; WCI BRKPTR; BRX *-3; LDA MONTH; LDB =16B; SKE =4
       CBX; CXA; WCI BRKPTR; LDA DAY; BRM NUMSTR; LDX =-3; LDB CENTRY
       CLA; LSH 8; WCI BRKPTR; BRX *-3; LDA =64; ADD YEAR; BRM NUMSTR; CLA
       WCI BRKPTR; WCI BRKPTR; LDA HOURS; BRM NUMSTR; LDA =32B
       WCI BRKPTR; LDA MINS; RSH 23; DIV =10; ADD =20B; WCI BRKPTR
       CBA; ADD =20B; WCI BRKPTR; LDX DATADR; LDP BRKPTR
       STP 0,2; BRR 0
NUMSTR ZRO
       RSH 23; DIV =10; SKE ZERO; ADD =20B; WCI BRKPTR; CBA
       ADD =20B; WCI BRKPTR; BRR NUMSTR
DATJAN ASC 'JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC'
CENTRY ASC ',19'
YEAR   ZRO
MONTH  ZRO
DAY    ZRO
HOURS  ZRO
MINS   ZRO
DATADR ZRO
*
*  TWO POP ROUTINES TO PRINT ASC TEXT TO THE FILE NUMBER STORED
*  IN IMMOUT
*  WRT  PRINTS IN-LINE TEXT TERMINATED BY A "/"     (BRS 34)
*  PRT  PRINTS A STRING                               (BRS 35)
*
*  CALLING SEQUENCES:
*
*      WRT  TEXT    (FIRST CELL OF AN ASC STRING)
*      PRT  PTR     (FIRST CELL OF A STRING POINTER PAIR)
*
*  REGISTERS AFFECTED:  NONE
*
WRTPOP STP ABREGS; STX OXREGS; EAX* 0; CXA; ETR =37777B; LDB ONES
       LDX IMMOUT; BRS 34; LDP ABREGS; LDX OXREGS; BRR 0
PRTPOP STP ABREGS; STX OXREGS; EAX* 0; LDP 0,2; LDX IMMOUT; BRS 35
       LDP ABREGS; LDX OXREGS; BRR 0
ABREGS BSS 2
OXREGS ZRO
*
*  POP ROUTINE TO PRINT A NUMBER OF SPACES ON IMMOUT
*
*  CALLING SEQUENCE:
*
*      SPC  NN        WHERE NN IS THE NUMBER OF SPACES
*
*  REGISTERS AFFECTED:  NONE
*
SPCPOP STA ABREGS; STX OXREGS; EAX* 0; CXA; ETR =37777B; CNA; COPY AX,A
       CIO IMMOUT; BRX *-1; LDA ABREGS; LDX OXREGS; BRR 0
*
*  POP ROUTINE TO PRINT A NUMBER OF CR-LF'S ON IMMOUT
*
*  CALLING SEQUENCE:
*
*      LIN  NN        WHERE NN IS THE NUMBER OF LINES
*
*  REGISTERS AFFECTED:  NONE
*
LINPOP STA ABREGS; STX OXREGS; LDX 0; STX LINRTN; EAX* 0,2; CXA
       ETR =37777B; CNA; CAX; LDA =155B; CIO IMMOUT; MIN LINES
       MDE LINLFT; BRX *-3; LDA ABREGS; LDX OXREGS; BRR LINRTN
LINRTN ZRO
*
*  POP ROUTINE TO DECREMENT MEMORY BY ONE...EXACTLY THE OPPOSITE
*  OF "MIN"
*  REGISTERS AFFECTED:  NONE
*
MDEPOP STX MDEARG; EAX* 0; SKR 0,2; NOP
       LDX MDEARG; BRR 0
MDEARG ZRO
*
*
*  S U B R O U T I N E S   U S E D   I N   G E N E R A L
*
*
*
*  GETS AND OPENS A SYMBOLIC OUTPUT FILE FOR CONVERT AND CATALOG
*  ROUTINES AND CHECKS EXISTENCE OF INPUT FILES
*
GETIOF ZRO
       LDA TRMCHR; SKE ZERO; SND FILES; LDA ONES; STA FILCNT
       LDX COMINF; CSTR CBUFF; STP CPTR; STP DPTR; CXA; SKG ONES
       BRU RDERR; BRK DPTR; BRU *+4; BRM CHKFIL; MIN FILCNT
       BRU *-4; BRM CHKFIL; MIN FILCNT; SKN FILCNT; BRU MST
       SND OUTTO; LDA ONES; LDX COMINF; CSTR DBUFF; STP DPTR
       XXA; SKG ONES; BRU RDERR+1; XXA; BRM OPNOUT; BRU MST; BRR GETIOF
*
*  SUBROUTINE TO CHECK IF A FILE EXISTS
*
*              LDP STRING
*              BRM CHKFIL
*              DOESN'T RETURN
*              DOES RETURN
*
*  TYPES A MESSAGE IF FILE CANNOT BE FOUND
*
CHKFIL ZRO; BRS 48; BRU *+3; MIN CHKFIL; BRR CHKFIL; STP TFILPT
       SNDA ERRNAM; PSTR TFILPT; TCO =155B; BRR CHKFIL
*
*  SUBROUTINE TO OPEN A SYMBOLIC INPUT FILE FOR IMMEDIATE USE WITHOUT
*  DISTURBING CONTENTS OF THE FOS FILE TABLES
*
*  CALL:
*
*              LDP FILE
*              BRM OPNIN
*              ERROR RETURN
*              NORMAL RETURN
*
*  APPROPRIATE ERROR MESSAGES ARE TYPED IF FILE CANNOT BE FOUND
*  OR OPENED
*
OPNIN  ZRO
       STP TFILPT; BRS 64; BRU *+7; STA IMMIN
       XAB; SKE =3; BRU *+12; MIN OPNIN; BRR OPNIN
       SNDA ERRNAM; CXA; SKE =10; BRU *+4; PSTR TFILPT; TCO =155B
       BRR OPNIN; BRM PTBDNM; BRR OPNIN; XAB; BRS 20; SNDA FLTYWG
       BRM PTBDNM; BRR OPNIN
*
*  SUBROUTINE TO OPEN A SYMBOLIC OUTPUT FILE FOR IMMEDIATE USE
*  WITHOUT DISTURBING THE CONTENTS OF THE FOS FILE TABLES
*
*  CALL:
*
*              LDP FILE
*              BRM OPNOUT
*              ERROR RETURN
*              NORMAL RETURN
*
*  APPROPRIATE ERROR MESSAGES ARE TYPED IF FILE CANNOT BE OPENED
*
OPNOUT ZRO; STP TFILPT; LDA COMINF
       SKG ZERO; BRU *+3; LDX =3; BRU *+3; MRG =3B4; CAX; LDP TFILPT
       BRS 65; BRU *+10; STA IMMOUT; SKG =2; BRU *+5; LDA COMINF
       SKG ZERO; BRU *+2; CIO COMINF; MIN OPNOUT; BRR OPNOUT
       SNDA CNTOPN; BRM PTBDNM; BRR OPNOUT
*
*  CHECKS IF CURRENT STRING BROKEN BY BRK IS ANYTHING DENOTING
*  "TELETYPE"...IF SO, TYPES MESSAGE "ILLEGAL FILE: " AND RETURNS
*  ...IF NOT "TELETYPE", DOES A SKIP RETURN
*
TELCHK ZRO
       LDP BRKPTR; STP TFILPT; LDA =TELETY; ADD =TELETY; ADD =TELETY
       SUB ONE; CAB; STP BRKPTR; LDA TFILPT+1; SUB TFILPT; ADM BRKPTR+1
       LDP TFILPT; SKSE BRKPTR; BRU *+5; SNDA ILLFIL; PSTR TFILPT
       TCO =155B; BRR TELCHK; MIN TELCHK; BRR TELCHK
TELETY ASC 'TELETYPE'
*
*  F I L E   T A B L E
*
COMINF EQU     1004B           FOS DATA =COMMAND INPUT FILE NUMBER
IMMOUT ZRO
IMMIN  ZRO
FILCNT ZRO
TFILPT BSS     2
EOJ    ASC     '$$EOJ$$/'
CR     ASC     '$/'
CRCR   ASC     '$$/'
FROM   ASC     'FROM: /'
MSGTO  ASC     'TO: /'
FILES  ASC     'FILE(S): /'
OUTTO  ASC     'OUTPUT TO: /'
CNTOPN ASC     'CANNOT OPEN FILE/'
ERRNAM ASC     'ERROR ON NAME: /'
FLTYWG ASC     'FILE TYPE WRONG/'
ILLFIL ASC     'ILLEGAL FILE: /'
PTBDNM ZRO
       LDA COMINF; SKG ZERO; BRU *+4; TCO =32B; TCO ZERO
       PSTR TFILPT; TCO =155B; BRR PTBDNM
CLOSE  ZRO
       LDA IMMIN; BRS 20; LDA IMMOUT; BRS 20; CLA; STA IMMIN
       STA IMMOUT; BRR CLOSE
IF     EQU     642B
OF     EQU     643B
SF     EQU     644B
$LFILES EQU  77734B-50001B
$SFE    EQU  77732B-50001B
$DCL    EQU  77730B-50001B
$DCC    EQU  77726B-50001B
$ACL    EQU  77724B-50001B
$AC1    EQU  77722B-50001B
$AC2    EQU  77720B-50001B
$TRL    EQU  77716B-50001B
$TRC    EQU  77714B-50001B
$ICON   EQU  77713B-50001B
$IFROM  EQU  77712B-50001B
$IOPTON EQU  77711B-50001B
$IFILES EQU  77635B-50001B
$PTIFIL EQU  77633B-50001B
$PTIFLX EQU  77631B-50001B
$SAVEFL EQU  77617B-50001B
$PTSAVE EQU  77615B-50001B
$NTR    EQU  77614B-50001B
       END
ECAP ** FICHE/FRAME BREAK *****
ECASFESYM SYMSORT

SYM.  PG.LN. IDENT.

ABREGS 30 21 SFECAP  AC1    34  9 SFECAP  AC2    34 10 SFECAP  
ACL    34  8 SFECAP  ALLGUD 19 35 SFECAP  ALTMOD  2 20 SFECAP  ANALYS 18 35 SFECAP  
ANLBRU 18  2 SFECAP  AUTHOR 21 25 SFECAP  BADABC 19 36 SFECAP  BADCNT 19 39 SFECAP  
BADCOD 19 38 SFECAP  BADFLZ 19 27 SFECAP  BADFZ1 19 29 SFECAP  BADFZ2 19 34 SFECAP  
BADXRG 19 37 SFECAP  BATCH  17 13 SFECAP  BATCH1 17 16 SFECAP  BATCH2 17 17 SFECAP  
BCMSG   5 35 SFECAP  BHPTB1  9  4 SFECAP  BRANCH  4 34 SFECAP  BRK     1  9 SFECAP  
BRKAGN 28 38 SFECAP  BRKBCK 29  1 SFECAP  BRKFIL 29  2 SFECAP  BRKOLD 29  5 SFECAP  
BRKPOP 28 33 SFECAP  BRKPTR 29  6 SFECAP  BRKRTN 28 37 SFECAP  BRMALT 21 13 SFECAP  
CANCEL 15 12 SFECAP  CAPABS 20  2 SFECAP  CATCYC 12 19 SFECAP  CATDO  12 22 SFECAP  
CATEOF 13  4 SFECAP  CATFIL 13 30 SFECAP  CATFLG 14 33 SFECAP  CATKLZ 14  6 SFECAP  
CATLOG 12 10 SFECAP  CATND1 13  7 SFECAP  CATND2 13  8 SFECAP  CATND3 13  9 SFECAP  
CBUFF   6 20 SFECAP  CCHK   25  3 SFECAP  CENTRY 29 36 SFECAP  CFIRST 24 17 SFECAP  
CHARGZ 20 11 SFECAP  CHEADN 13 26 SFECAP  CHKFIL 32  3 SFECAP  CHKMOD 13 37 SFECAP  
CHOICE 18  5 SFECAP  CKCTRQ 25 32 SFECAP  CKCTRW 26 16 SFECAP  CKWORK 26 10 SFECAP  
CLOSE  33 37 SFECAP  CMDLST  8 38 SFECAP  CMDTAB  3  2 SFECAP  CMDTND  3 31 SFECAP  
CNEXT  25  7 SFECAP  CNTOPN 33 30 SFECAP  COMBUF 19 11 SFECAP  COMER1 19  7 SFECAP  
COMER2 19  8 SFECAP  COMER3 19  9 SFECAP  COMINF 33 18 SFECAP  COMND1 19  2 SFECAP  
COMNDZ 19  1 SFECAP  COMPTR 19 10 SFECAP  COMSG1 19 12 SFECAP  COMSG2 19 13 SFECAP  
CONAS1 11 10 SFECAP  CONAS2 11 16 SFECAP  CONAS3 11 15 SFECAP  CONASM 11 13 SFECAP  
CONASN 11 14 SFECAP  CONASR 11 12 SFECAP  CONBR1 11  7 SFECAP  CONBR2 11 18 SFECAP  
CONBR3 11 21 SFECAP  CONCGT 11 23 SFECAP  CONCL7 11 29 SFECAP  CONCOL 12  4 SFECAP  
CONCWT 11 26 SFECAP  CONCYC 11  2 SFECAP  CONDO  11  4 SFECAP  CONDO1 11  5 SFECAP  
CONDON 11 37 SFECAP  CONELS 11 20 SFECAP  CONKLZ 11 38 SFECAP  CONMUL 11 39 SFECAP  
CONOUT 11 35 SFECAP  CONVRT 11  1 SFECAP  COST   20 13 SFECAP  CPAS1  12 24 SFECAP  
CPAS1A 12 27 SFECAP  CPAS1B 12 30 SFECAP  CPAS1C 12 32 SFECAP  CPAS2  12 33 SFECAP  
CPAS2A 12 35 SFECAP  CPAS2B 12 36 SFECAP  CPAS2C 12 38 SFECAP  CPAS2E 13  1 SFECAP  
CPAS2X 12 34 SFECAP  CPTR    6 19 SFECAP  CR     33 24 SFECAP  CRCR   33 25 SFECAP  
CREDTS 20 14 SFECAP  CSTR    1  6 SFECAP  CSTRPP 24  6 SFECAP  CTRLWR 26 21 SFECAP  
DAT     1 10 SFECAP  DATADR 30  3 SFECAP  DATE   15  8 SFECAP  DATJAN 29 35 SFECAP  
DATPOP 29 20 SFECAP  DAY    29 39 SFECAP  DBADUG 21 26 SFECAP  DBNXT  21  7 SFECAP  
DBNXT1 21 14 SFECAP  DBNXT2 21 24 SFECAP  DBNXT4 21 37 SFECAP  DBUFF   8 34 SFECAP  
DCC    34  7 SFECAP  DCL    34  6 SFECAP  DEBUG  20 17 SFECAP  DIRTAB 11 31 SFECAP  
DPTR    8 35 SFECAP  ECPLNK 19 19 SFECAP  EOFCK  25 38 SFECAP  EOFENC  6 29 SFECAP  
EOFRTN 24 20 SFECAP  EOJ    33 23 SFECAP  ERCMD   6 25 SFECAP  ERCMDF  6 24 SFECAP  
ERLINK 18 23 SFECAP  ERORON  8 33 SFECAP  ERRCNT  6 21 SFECAP  ERRNAM 33 31 SFECAP  
ERRRTN 24 21 SFECAP  ESCAPE  2 29 SFECAP  ESMASK  1 25 SFECAP  EXECUT 17 39 SFECAP  
EXPERT 14 37 SFECAP  F      28  7 SFECAP  FILCIN 21 21 SFECAP  FILCNT 33 21 SFECAP  
FILE   26 31 SFECAP  FILES  33 28 SFECAP  FILRIN 21 22 SFECAP  FILSAV 21 20 SFECAP  
FILTFP 21 23 SFECAP  FLTYWG 33 32 SFECAP  FORMAT 15  2 SFECAP  FROM   33 26 SFECAP  
GETIN  16  6 SFECAP  GETIOF 31 25 SFECAP  GETOUT 16 35 SFECAP  GLITCH  6 26 SFECAP  
GLORY  20 16 SFECAP  GO     18 12 SFECAP  GOBACK 25 16 SFECAP  GODOIT 18 33 SFECAP  
GOGO   18  7 SFECAP  GOTODO 18 28 SFECAP  GOTOIT 18 25 SFECAP  GPTR   12  1 SFECAP  
HEADNG 13 20 SFECAP  HELP   20  4 SFECAP  HLPA1  10  4 SFECAP  HLPA10 10 14 SFECAP  
HLPA11 10 15 SFECAP  HLPA12 10 16 SFECAP  HLPA13 10 17 SFECAP  HLPA14 10 18 SFECAP  
HLPA15 10 19 SFECAP  HLPA16 10 20 SFECAP  HLPA17 10 21 SFECAP  HLPA18 10 22 SFECAP  
HLPA19 10 23 SFECAP  HLPA2  10  5 SFECAP  HLPA20 10 24 SFECAP  HLPA21 10 25 SFECAP  
HLPA22 10 26 SFECAP  HLPA23 10 27 SFECAP  HLPA24 10 28 SFECAP  HLPA25 10 29 SFECAP  
HLPA26 10 30 SFECAP  HLPA3  10  7 SFECAP  HLPA4  10  8 SFECAP  HLPA5  10  9 SFECAP  
HLPA6  10 10 SFECAP  HLPA7  10 11 SFECAP  HLPA8  10 12 SFECAP  HLPA9  10 13 SFECAP  
HLPALL  7 34 SFECAP  HLPAU1 10  6 SFECAP  HLPAX1 10 31 SFECAP  HLPAX2 10 32 SFECAP  
HLPCCK  7 10 SFECAP  HLPLST  7 29 SFECAP  HLPLUP  7 38 SFECAP  HLPMCK  7 18 SFECAP  
HLPSBR  8 11 SFECAP  HLPSND  8 22 SFECAP  HLPTB1 10  3 SFECAP  HOURS  30  1 SFECAP  
HPTR   14 25 SFECAP  ICON   34 13 SFECAP  IF     34  1 SFECAP  IFILES 34 16 SFECAP  
IFROM  34 14 SFECAP  ILLFIL 33 33 SFECAP  IMMIN  33 20 SFECAP  IMMOUT 33 19 SFECAP  
INDEX  14 20 SFECAP  INFBFF 16 27 SFECAP  INFBUF 16 26 SFECAP  INFCHK 16 16 SFECAP  
INFCK1 16 22 SFECAP  INFCK2 16 24 SFECAP  INFCK3 16 23 SFECAP  INFPRT 16 25 SFECAP  
INFRTN 16 21 SFECAP  INPASS 21 29 SFECAP  INSTRK  6 39 SFECAP  IOPTON 34 15 SFECAP  
KEYMSG 21 27 SFECAP  KMDOPT  8 37 SFECAP  KONFRM 17 28 SFECAP  LERR   18 22 SFECAP  
LFILES 34  4 SFECAP  LIN     1 14 SFECAP  LINES  14 27 SFECAP  LINLFT 14 26 SFECAP  
LINPAG 14 28 SFECAP  LINPOP 31  4 SFECAP  LINRTN 31  7 SFECAP  LIST   15  4 SFECAP  
LNKERR 18 19 SFECAP  LOAD   16  5 SFECAP  LSTFIL 14 30 SFECAP  MDADR1 14 31 SFECAP  
MDADR2 14 32 SFECAP  MDE     1 15 SFECAP  MDEARG 31 15 SFECAP  MDEPOP 31 13 SFECAP  
MINS   30  2 SFECAP  MODCHK 14  2 SFECAP  MONTH  29 38 SFECAP  MS     28  8 SFECAP  
MSCNT  28  9 SFECAP  MSGFIL 14 19 SFECAP  MSGHDG 17 35 SFECAP  MSGIN  17 31 SFECAP  
MSGLST 17 33 SFECAP  MSGOUT 17 32 SFECAP  MSGPAU 17 34 SFECAP  MSGTO  33 27 SFECAP  
MST     1 30 SFECAP  N      28  6 SFECAP  NEXPRT 14 38 SFECAP  NODATE 15  9 SFECAP  
NOERRS  5 36 SFECAP  NOFRMT 15  3 SFECAP  NOLIST 15  5 SFECAP  NOMOD1 13  3 SFECAP  
NOMODL 14 18 SFECAP  NOPT   15 37 SFECAP  NOTIME 15  7 SFECAP  NPAUSE 15  1 SFECAP  
NSAVE  15 18 SFECAP  NTR    34 21 SFECAP  NULSTR  6 28 SFECAP  NULVPT 11 32 SFECAP  
NUMSTR 29 32 SFECAP  NXT    28  2 SFECAP  OF     34  2 SFECAP  OKMSG  15 11 SFECAP  
ONE     6 31 SFECAP  ONERR   5  7 SFECAP  ONES    6 32 SFECAP  OPNIN  32 19 SFECAP  
OPNOUT 32 38 SFECAP  OPTDAT 15 20 SFECAP  OPTFOR 15 23 SFECAP  OPTION 15 26 SFECAP  
OPTLIS 15 22 SFECAP  OPTM1  15 30 SFECAP  OPTM2  15 31 SFECAP  OPTM3  15 32 SFECAP  
OPTM5  15 33 SFECAP  OPTM6  15 34 SFECAP  OPTM8  15 35 SFECAP  OPTM9  15 36 SFECAP  
OPTMSG 15 29 SFECAP  OPTSAV 15 24 SFECAP  OPTSET 15 10 SFECAP  OPTTIM 15 21 SFECAP  
OUTTO  33 29 SFECAP  OXREGS 30 22 SFECAP  PAGCHK 14 13 SFECAP  PAGE   14 29 SFECAP  
PAGENO 14 24 SFECAP  PAUSE  14 39 SFECAP  PIZAZZ 21 28 SFECAP  PKEY1  21 30 SFECAP  
PKEY2  21 31 SFECAP  POPTAB  6  1 SFECAP  POPTND  6 14 SFECAP  PRT     1 12 SFECAP  
PRTMOD 13 13 SFECAP  PRTPOP 30 19 SFECAP  PSTR    1  8 SFECAP  PSTRPP 23  1 SFECAP  
PSWAN  20 28 SFECAP  PSWIN  20 30 SFECAP  PTBDNM 33 34 SFECAP  PTIFIL 34 17 SFECAP  
PTIFLX 34 18 SFECAP  PTR    26 32 SFECAP  PTSAVE 34 20 SFECAP  PTX     1  7 SFECAP  
PTXPOP 27 39 SFECAP  PVTCMD  9 37 SFECAP  PXREG   8 36 SFECAP  QMARK   6 27 SFECAP  
R      28  3 SFECAP  RANERR 14 15 SFECAP  RDERR   5 15 SFECAP  REARM   1 26 SFECAP  
RTN     6 18 SFECAP  RUNBEG 17  9 SFECAP  RUNM1  17 19 SFECAP  RUNM2  17 21 SFECAP  
RUNM3  17 22 SFECAP  RUNM4  17 23 SFECAP  RUNM5  17 24 SFECAP  RUNRUN 17  3 SFECAP  
SAVE   15 14 SFECAP  SAVEFL 34 19 SFECAP  SENDIT 27 13 SFECAP  SEPMRK 14 21 SFECAP  
SF     34  3 SFECAP  SFE    34  5 SFECAP  SFEACT  1 16 SFECAP  SIGN   15 19 SFECAP  
SMASKE 17 18 SFECAP  SND     1  4 SFECAP  SNDA    1  5 SFECAP  SNDAPP 27 21 SFECAP  
SNDPOP 27  9 SFECAP  SPC     1 13 SFECAP  SPCPOP 30 32 SFECAP  ST      1 33 SFECAP  
START   1 28 SFECAP  SUMSUM  6 36 SFECAP  SWAPOP 22 14 SFECAP  SWPBUF 22 19 SFECAP  
SWPEOJ 22 12 SFECAP  SWPFIL 22 17 SFECAP  SWPGET 22  3 SFECAP  SWPLIT 22 11 SFECAP  
SWPLNK 22  2 SFECAP  SWPNXT 22  9 SFECAP  SWPOUT 22 18 SFECAP  SWPRDF 22  6 SFECAP  
SYSERR 14 16 SFECAP  TELCHK 33  9 SFECAP  TELETY 33 14 SFECAP  TFILPT 33 22 SFECAP  
THDNG  14 22 SFECAP  TIME   15  6 SFECAP  TRC    34 12 SFECAP  TREARM  1 27 SFECAP  
TRL    34 11 SFECAP  TRMCHR  6 22 SFECAP  VBUFF  12  3 SFECAP  VERNO  20  6 SFECAP  
VERZN  20 10 SFECAP  VPTR   12  2 SFECAP  WHYMSG  6 23 SFECAP  WHYNOT  5 27 SFECAP  
WLOAD  22 13 SFECAP  WORK   26 30 SFECAP  WRITE  16 34 SFECAP  WRT     1 11 SFECAP  
WRTBCK 26 25 SFECAP  WRTPOP 30 17 SFECAP  XREG1  28 10 SFECAP  XREG2  28 11 SFECAP  
YEAR   29 37 SFECAP  ZERO    6 30 SFECAP  ZROSTR 25 30 SFECAP  
ECAP ** FICHE/FRAME BREAK *****
ECFSFESYM
C-SFEF    FORTRAN START OF STANDARD-FRONT-END LINK
C
C      INITIAL COMMON, PURPOSE OF VARIABLES
C
C  LFILES      STORAGE AREA FOR LINK FILE NAMES
C  IFILES      STORAGE AREA FOR INPUT FILE NAMES
C  SAVEFL      STORAGE AREA FOR SAVE FILE NAME
C  SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC     LINK FILE STRING POINTERS
C  ICON        CONTINUE FLAG FROM LINKS
C  IFROM       "WHERE CAME FROM" INDICATOR
C              0  FROM GO FILE
C              1  FROM SFE
C              2  FROM DCL
C              3  FROM ACL
C              4  FROM TRL
C              5  FROM DCC
C              6  FROM AC1
C              7  FROM TRC
C              8  FROM AC2
C              9  FROM  -
C  IOPTON      BOOLEAN-BIT WORD FOR OUTPUT AND CONTROL OPTIONS
C              WORD CONTAINS 24 BITS, 0(SIGN) TO 23
C              BIT  PURPOSE [SET  (NOT SET)]
C               0   4B7 = EXPERT  (NOEXPERT)
C              10   2B4 = DATE    (NODATE)
C              11   1B4 = TIME    (NOTIME)
C              14   1B3 = LIST    (NOLIST)
C              17   1B2 = FORMAT  (NOFORMAT)
C              20   10B = SAVE    (NOSAVE)
C              23    1  = PAUSE   (NOPAUSE)
C
C  PTIFIL      STRING POINTERS FOR CURRENT INPUT FILE
C  PTSAVE      STRING POINTERS FOR "SAVE" FILE
C  PTIFLX      STRING POINTERS FOR REMAINING INPUT FILE STRING
C
C  INPUT FILE NUMBER STORED AT   642B  (FOS UNIT 2)
C  OUTPUT FILE NUMBER STORED AT  643B  (FOS UNIT 3)
C  SAVE FILE NUMBER STORED AT    644B  (FOS UNIT 4)
C  MODEL FILE NUMBER STORED AT   645B  (FOS UNIT 5)
C
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC
       COMMON ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX
       COMMON SAVEFL,PTSAVE
       COMMON NTR
       CALL SFEACT
       END
ECAP ** FICHE/FRAME BREAK *****
ECFSFESYM SYMSORT

SYM.  PG.LN. IDENT.

C       1 35 C-SFEF  C       1 34 C-SFEF  C       1 33 C-SFEF  
C       1 31 C-SFEF  C       1 30 C-SFEF  C       1 28 C-SFEF  C       1 27 C-SFEF  
C       1 26 C-SFEF  C       1 25 C-SFEF  C       1 24 C-SFEF  C       1 23 C-SFEF  
C       1 22 C-SFEF  C       1 21 C-SFEF  C       1 20 C-SFEF  C       1 19 C-SFEF  
C       1 18 C-SFEF  C       1 17 C-SFEF  C       1 16 C-SFEF  C       1 15 C-SFEF  
C       1 14 C-SFEF  C       1 13 C-SFEF  C       1 12 C-SFEF  C       1 11 C-SFEF  
C       1 10 C-SFEF  C       1  9 C-SFEF  C       1  8 C-SFEF  C       1  7 C-SFEF  
C       1  6 C-SFEF  C       1  5 C-SFEF  C       1  4 C-SFEF  CM      1 36 C-SFEF  
CMC     1 32 C-SFEF  CMC     1 29 C-SFEF  CMC     1  3 C-SFEF  CMC     1  2 C-SFEF  

ECAP ** FICHE/FRAME BREAK *****
ECGOFSYM
C-ECGOFS     VER.6 ECAP LINK NAME LOADER AND GO FILE    -T.FLORYAN
C
C  THIS IS THE ECAP GO FILE THAT CALLS THE STANDARD-FRONT-END LINK
C
C  WHEN THIS PROGRAM IS FIRST RUN, IT IS THE ECAP LINK NAME LOADER
C  AFTER ENTERING THE LINK NAMES, A SAVE FILE IS CREATED AUTOMATICALLY
C  IN THE INIT SUBROUTINE, AFTER WHICH THIS PROGRAM IS TRANSMITTED
C  AS THE GO FILE
C
C
C  FOR EFFICIENCY OF OPERATION, THE GO FILE IS ALSO THE
C  STANDARD-FRONT-END THE FIRST TIME THROUGH...AFTERWARDS, ALL
C  TRANSFERS TO THE SFE GO TO THE STANDARD FRONT END LINK FILE
C
       DIMENSION LFILES(36)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON
       IF (NAMES) 10,10
       CALL SFEACT
10     NAMES=1
       CALL INIT(LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC)
       END
ECAP ** FICHE/FRAME BREAK *****
ECGOFSYM SYMSORT

SYM.  PG.LN. IDENT.

10      1 14 C-ECGOFSC       1  9 C-ECGOFSC       1  8 C-ECGOFS
C       1  6 C-ECGOFSC       1  5 C-ECGOFSC       1  4 C-ECGOFSCM      1 10 C-ECGOFS
CMC     1  3 C-ECGOFSCMC     1  2 C-ECGOFSCMCMC   1  7 C-ECGOFS
ECAP ** FICHE/FRAME BREAK *****
ECINLPOPSYM
INLPOP IDENT   VER.6 ECAP INPUT LANGUAGE POPS
*
*
SIC    OPD     173B5,1,1
MDE    OPD     166B5,1,1
MOD    OPD     164B5,1,1
*
*
*
*                 P O P   R O U T I N E S
*
*
*
*      STRING  STRING EDITING
*      TIM     APPENDS TIME TO A STRING
*      DAT     APPENDS CURRENT DATE TO A STRING
*      BRK     BREAKS UP A STRING CONTAINING COMMAS
*      SIC     STRING TO FLOATING-POINT CONVERSION
*      (XSIC)  STRING TO INTEGER CONVERSION
*      PSTR    PRINTS A STRING TO THE TERMINAL
*      SND     SENDS ASCII TEXT TO TERMINAL IF COMMAND FILE IS TERMINAL
*      SNDA    ALWAYS SENDS ASCII TEXT TO TERMINAL
*      PTX     PRINTS PACKED TEXT TO THE TERMINAL
*      MDE     MEMORY DECREMENT
*      MAX     INTEGER MAXIMUM OF TWO NUMBERS IN A AND B REGISTERS
*      MOD     (A-REGISTER) MOD (LOCATION)
*      (ABS)   FLOATING-POINT ABSOLUTE VALUE
*      (FLN)   FLOATING-POINT NEGATE  (USE BRS 21 INSTEAD)
*      PUTB    PUTS A STRING IN CURRENT TEXT BLOCK
*      CMPRS   COMPRESSES INPUT LINES
*      PCKT    PRINTS CIRCUIT TO A FILE, FORMAT OR NOT = IOPTON
*      RANGE   RETURNS TEXT BLOCK ADDRESS(ES)
*      DELETM  SUBROUTINE TO DELETE A TEXT BLOCK
*      LISTER  SUBROUTINE TO LIST TEXT BLOCK(S)
*      INSRT1  TWO SUBROUTINES USED FOR INSERTING NEW TEXT AHEAD OF
*      INSRT2      OLD TEXT ALREADY IN TEXT BLOCK
*      STIA    STORE A-REG IN 1-DIM INTEGER ARRAY
*      LDIA    LOAD A-REG FROM 1-DIM INTEGER ARRAY
*      STFA    STORE AB INV IN 1-DIM REAL ARRAY
*      LDFA    LOAD AB INV FROM 1-DIM REAL ARRAY
*      STF     STORE AB INV IN REAL NUMBER
*      LDF     LOAD AB INV FROM REAL NUMBER
*******
*
*      (---)   MEANS THAT THE ROUTINE OR TECHNIQUE IS WITHIN THIS
*              POP PACKAGE BUT WILL NOT BE ASSEMBLED BECAUSE AN "*"
*              IS IN FRONT OF EACH LINE OF CODE
*
*
*
*
*  S T R I N G   E N T R Y   A N D   E D I T I N G   R O U T I N E
*
*  FEATURES THE COMPLETE EDITING CAPABILITY OF EDITOR
*
*  WRITTEN BY:  THAD FLORYAN
*
*  CALLING SEQUENCE:
*
*              STRING  (XX)
*              ERROR RETURN  (EOF)
*              NORMAL RETURN
*
*      -ERROR RETURN IS ON AN END-OF-FILE CONDITION
*      -NORMAL RETURN MEANS A LINE WAS ENTERED OR EDITED
*
*  OTHER POPS REQUIRED:
*
*      MDE  LOC     (MEMORY DECREMENT)
*      MOD  LOC     (A-REG MOD LOC)
*
*  SETTING UP ENTRY:
*
*      EDSTAT    -1  TO INITIATE AN EDIT MODE
*                >=0 TO INITIATE AN ENTER MODE
*      INFILE    CURRENT FILE NUMBER FOR INPUT
*      (XX)      ADDRESS MUST BE USED FOR EDIT MODE AND IS THE ADDRESS
*                OF A STRING POINTER PAIR
*      PRNTST    -1  TO PRINT THE OLD STRING ON ENTRY
*                >=0 DO NOT PRINT OLD STRING ON ENTRY
*
*  RETRIEVING OUTPUT:
*
*      CHRNEW    NUMBER OF CHARACTERS IN THE NEW STRING
*                IF CHRNEW IS NEGATIVE, THEN AN INSERT OR APPEND
*                OPERATION WAS TERMINATED BY A CONTROL-D
*      PTRNEW    POINTERS TO THE NEW STRING IN TEMP. STORAGE
*
*  REGISTERS AFFECTED:  ALL
*
$STRNGP LDA    0
       STA     STRRTN
$RBUILD CLA
       STA     INSERT
       LDA     =STRNEW
       ADD     =STRNEW
       ADD     =STRNEW
       SUB     ONE
       CAB
       STP     PTRNEW
       LDA     ONE
       STA     TABPOS
       STA     POSOLD
       SKN     EDSTAT
       BRU     GETCHR
       BRM     CKTRLY
       EAX*    STRRTN
       LDP     0,2
       STA     LOCOLD
       STP     PTROLD
       SKN     PRNTST
       BRU     GETCHR
       MIN     PRNTST
       LDX     ONE
       BRS     35
       TCO     =155B
       TCO     ZERO
$GETCHR CIO     INFILE
       SKN     INFILE
       BRU     *+2
       BRR     STRRTN
       LDB     ONES
       STB     STRSCV
       SKG     =77B
       BRU     BLNKCK
       SKN     EDSTAT
       BRU     *+2
       BRU     *+5
       SKE     =144B
       BRU     *+3
       LDA     ONES
       BRU     NDNTRX
       SKE     =135B
       BRU     *+5
       CIO     INFILE
       SKN     INFILE
       BRU     GETCHR
       BRR     STRRTN
       SKE     =137B
       BRU     CTRLA
       BRR     STRRTN
$BLNKCK SKG     ZERO
       BRU     GETCHR
$NEWRIT WCI     PTRNEW
       MIN     TABPOS
       SKN     INSERT
       MIN     POSOLD
$CHARIN CIO     INFILE
       SKN     INFILE
       BRU     *+2
       BRR     STRRTN
       SKG     =77B
       BRU     NEWRIT
       SKE     =137B
       BRU     *+2
       BRR     STRRTN
       SKE     =135B
       BRU     CTRLA
       CIO     INFILE
       SKN     INFILE
       BRU     *+2
       BRR     STRRTN
       CNA
       COPY    AX,A
       WCI     PTRNEW
       BRX     *-1
       BRU     CHARIN
*
*  CONTROL-A   DELETES PRECEEDING CHARACTER
*
$CTRLA  SKE     =141B
       BRU     CTRLQ
       GCD     PTRNEW
       BRU     ILLOPR
       TCO     =77B
       MDE     TABPOS
       BRU     CHARIN
*
*  CONTROL-Q   DELETES ENTIRE LINE, ALLOWS RESTART OF EDIT
*
$CTRLQ  SKE     =161B
       BRU     CTRLW
       TCO     =76B
       TCO     =155B
       TCO     ZERO
       CLA
       STA     PRNTST
       BRU     RBUILD
*
*  CONTROL-W   DELETES PRECEEDING WORD
*
$CTRLW  SKE     =167B
       BRU     CTRLZ
       TCO     =74B
$CTRLWW GCD     PTRNEW
       BRU     ILLOPR
       MDE     TABPOS
       SKE     =14B
       BRU     *+4
       WCI     PTRNEW
       MIN     TABPOS
       BRU     CHARIN
       SKE     ZERO
       BRU     CTRLWW
       BRU     *-5
*
*  CONTROL-Z   PLUS A CHARACTER:  COPIES UP TO AND INCLUDING THE
*              CHARACTER TYPED AFTER IT
*
$CTRLZ  SKE     =172B
       BRU     CTRLC
       SKN     EDSTAT
       BRU     ILLOPR
       BRM     STRSCN
$CTRLZZ GCI     TEMPTR
       NOP
       SKE     CHRCOM
       BRU     *+6
       CIO     ONE
       MIN     POSOLD
       MIN     TABPOS
       WCI     PTRNEW
       BRU     CHARIN
       CIO     ONE
       MIN     POSOLD
       MIN     TABPOS
       WCI     PTRNEW
       BRU     CTRLZZ
*
*  CONTROL-C   COPIES NEXT CHARACTER IN OLD STRING (LINE)
*
$CTRLC  SKE     =143B
       BRU     CTRLS
       SKN     EDSTAT
       BRU     ILLOPR
       BRM     OLDPOS
       GCI     TEMPTR
       BRU     ILLOPR
       CIO     ONE
       BRU     NEWRIT
*
*  CONTROL-S   DELETES NEXT CHARACTER IN OLD LINE
*
$CTRLS  SKE     =163B
       BRU     CTRLD
       SKN     EDSTAT
       BRU     ILLOPR
       LDA     PTROLD+1
       SKG     PTROLD
       BRU     ILLOPR
       TCO     =5
       MIN     POSOLD
       BRU     CHARIN
*
*  CONTROL-D   DURING EDIT, COPIES THE REST OF THE OLD LINE TO THE
*              NEW LINE AND TERMINATES THE EDIT.
*              DURING APPEND AND INSERT, IT TERMINATES
*              THE OPERATION
*
$CTRLD  SKE     =144B
       BRU     CTRLE
       SKN     EDSTAT
       BRU     *+9
       BRM     OLDPOS
       LDB     PTROLD+1
       STB     TEMPTR+1
       GCI     TEMPTR
       BRU     *+4
       CIO     ONE
       WCI     PTRNEW
       BRU     *-4
$CTRLDD TCO     =155B
       BRU     NDNTRS
*
*  CONTROL-E   INSERTS TEXT INTO NEW LINE
*
$CTRLE  SKE     =145B
       BRU     CTRLF
       SKN     EDSTAT
       BRU     ILLOPR
       SKN     INSERT
       BRU     *+5
       TCO     =36B
       CLA
       STA     INSERT
       BRU     CHARIN
       TCO     =34B
       MDE     INSERT
       BRU     CHARIN
*
*  CONTROL-F   COPIES BUT DOES NOT PRINT THE REST OF THE OLD LINE
*              DURING AN EDIT
*
$CTRLF  SKE     =146B
       BRU     CTRLH
       SKN     EDSTAT
       BRU     ILLOPR
       BRM     OLDPOS
       LDB     PTROLD+1
       STB     TEMPTR+1
       GCI     TEMPTR
       BRU     CTRLDD
       WCI     PTRNEW
       BRU     *-3
*
*  CONTROL-H   COPIES AND PRINTS THE REST OF THE OLD LINE AND
*              CONTINUES THE EDIT AT THE END OF THE LINE
*
$CTRLH  SKE     =150B
       BRU     CTRLI
       SKN     EDSTAT
       BRU     ILLOPR
       BRM     OLDPOS
       LDB     PTROLD+1
       STB     TEMPTR+1
$CTRLHH GCI     TEMPTR
       BRU     CHARIN
       CIO     ONE
       WCI     PTRNEW
       MIN     TABPOS
       MIN     POSOLD
       BRU     CTRLHH
*
*  CONTROL-I   SPACES TO NEXT TAB STOP  (SET AT 7-SPACE INTERVALS)
*
$CTRLI  SKE     =151B
       BRU     CTRLJ
       LDA     TABPOS
       CLB
       SKG     ONE
       LDB     ONES
       STB     TMPFLG
       MOD     =7
       SUB     =7
       COPY    AX,A
       BRU     *+5
$CTRLII BRX     *+4
       LDA     TABPOS
       STA     OLDPOS
       BRU     CHARIN
       SKN     TMPFLG
       WCI     PTRNEW
       CIO     ONE
       SKN     TMPFLG
       MIN     TABPOS
       BRU     CTRLII
*
*  CONTROL-J   LINE FEED: TERMINATES THE EDIT
*
$CTRLJ  SKE     =152B
       BRU     CTRLK
       BRU     NDNTRS
*
*  CONTROL-K   DELETES NEXT CHARACTER IN OLD LINE AND PRINTS IT
*
$CTRLK  SKE     =153B
       BRU     CTRLM
       SKN     EDSTAT
       BRU     ILLOPR
       BRM     OLDPOS
       GCI     TEMPTR
       BRU     ILLOPR
       CIO     ONE
       MIN     POSOLD
       MIN     TABPOS
       BRU     CHARIN
*
*  CONTROL-M   CARRIAGE RETURN: TERMINATES THE EDIT
*
$CTRLM  SKE     =155B
       BRU     CTRLN
       BRU     NDNTRS
*
*  CONTROL-N   BACKSPACES IN OLD AND NEW LINES
*
$CTRLN  SKE     =156B
       BRU     CTRLO
       SKN     EDSTAT
       BRU     ILLOPR
       LDA     TABPOS
       SKG     ONE
       BRU     ILLOPR
       GCD     PTRNEW
       BRU     ILLOPR
       TCO     =77B
       MDE     TABPOS
       MDE     POSOLD
       BRU     CHARIN
*
*  CONTROL-O   PLUS A CHARACTER:  COPIES UP TO BUT NOT INCLUDING
*              THE CHARACTER TYPED AFTER IT
*
$CTRLO  SKE     =157B
       BRU     CTRLP
       SKN     EDSTAT
       BRU     ILLOPR
       CLA
       STA     STRSCV
       BRM     STRSCN
       GCI     TEMPTR
       NOP
       BRU     *+6
$CTRLOO GCI     TEMPTR
       NOP
       SKE     CHRCOM
       BRU     *+2
       BRU     CHARIN
       CIO     ONE
       WCI     PTRNEW
       MIN     POSOLD
       MIN     TABPOS
       BRU     CTRLOO
*
*  CONTROL-P   PLUS A CHARACTER: DELETES UP TO BUT NOT INCLUDING
*              THE CHARACTER TYPED AFTER IT
*
$CTRLP  SKE     =160B
       BRU     CTRLR
       SKN     EDSTAT
       BRU     ILLOPR
       CLA
       STA     STRSCV
       BRM     STRSCN
       GCI     TEMPTR
       NOP
       BRU     *+6
$CTRLPP GCI     TEMPTR
       NOP
       SKE     CHRCOM
       BRU     *+2
       BRU     CHARIN
       TCO     =5
       MIN     POSOLD
       BRU     CTRLPP
*
*  CONTROL-R   COPIES AND PRINTS REST OF OLD LINE PLUS THE NEW LINE
*              CONTINUES EDIT FROM WHERE CTRL-R WAS TYPED
*
$CTRLR  SKE     =162B
       BRU     CTRLT
       SKN     EDSTAT
       BRU     ILLOPR
$CTRLRR BRM     OLDPOS
       LDB     PTROLD+1
       LDA     TEMPTR
       LDX     ONE
       BRS     35
       TCO     =155B
       TCO     ZERO
       LDP     PTRNEW
       BRS     35
       BRU     CHARIN
*
*  CONTROL-T   SAME AS CONTROL-R EXCEPT THAT IT ALIGNS THE REST OF
*              THE OLD LINE WITH THE NEW LINE
*
$CTRLT  SKE     =164B
       BRU     CTRLU
       SKN     EDSTAT
       BRU     ILLOPR
       TCO     =155B
       LDA     PTRNEW
       SUB     PTRNEW+1
       SKG     ONES
       BRU     *+2
       BRU     ILLOPR
       CAX
       EAX     -2,2
       BRX     *+2
       BRU     CTRLRR
       TCO     ZERO
       BRU     *-3
*
*  CONTROL-U   COPIES FROM OLD LINE UP TO NEXT TAB STOP IN NEW LINE
*
$CTRLU  SKE     =165B
       BRU     CTRLX
       SKN     EDSTAT
       BRU     ILLOPR
       BRM     OLDPOS
       LDB     PTROLD+1
       STB     TEMPTR+1
       LDA     TABPOS
       MOD     =7
       SUB     =7
       CAX
       BRU *+3
$CTRLUU BRX     *+2
       BRU     CHARIN
       GCI     TEMPTR
       BRU     CHARIN
       CIO     ONE
       MIN     POSOLD
       MIN     TABPOS
       WCI     PTRNEW
       BRU     CTRLUU
*
*  CONTROL-X   PLUS A CHARACTER: DELETES UP TO AND INCLUDING
*              THE CHARACTER TYPED AFTER IT
*
$CTRLX  SKE     =170B
       BRU     CTRLY
       SKN     EDSTAT
       BRU     ILLOPR
       BRM     STRSCN
$CTRLXX GCI     TEMPTR
       NOP
       SKE     CHRCOM
       BRU     *+4
       TCO     =5
       MIN     POSOLD
       BRU     CHARIN
       TCO     =5
       MIN     POSOLD
       BRU     CTRLXX
*
*  CONTROL-Y   COPIES BUT DOES NOT PRINT REST OF OLD LINE AND
*              CONTINUES EDIT AT THE BEGINNING OF THE NEW LINE.  SAME
*              AS CONTROL-F FOLLOWED BY ".EDIT" W/OUT PRINT
*
$CTRLY  SKE     =171B
       BRU     ILLOPR
       SKN     EDSTAT
       BRU     CTRLYY
       LDA     POSOLD
       SUB     ONE
       ADD     LOCOLD
       LDB     PTROLD+1
       STP     TEMPTR
       GCI     TEMPTR
       BRU     *+3
       WCI     PTRNEW
       BRU     *-3
$CTRLYY TCO     =155B
       LDA     ONES
       STA     EDSTAT
       TCO     ZERO
       LDA     =STRTMP
       ADD     =STRTMP
       ADD     =STRTMP
       SUB     ONE
       CAB
       STP     TEMPTR
       STA     LOCOLD
       GCI     PTRNEW
       BRU     *+3
       WCI     TEMPTR
       BRU     *-3
       LDA     ONES
       STA     CHROLD
       BRU     RBUILD
$CKTRLY ZRO
       SKN     CHROLD
       BRU     *+4
       MIN     CKTRLY
       MIN     CKTRLY
       LDP     TEMPTR
       CLX
       STX     CHROLD
       BRR     CKTRLY
$ILLOPR TCO     =147B
       LDA     TABPOS
       SKG     ONE
       BRU     GETCHR
       BRU     CHARIN
$OLDPOS ZRO
       LDA     POSOLD
       SKN     STRSCV
       ADD     ONE
       LDB     ONES
       STB     STRSCV
       ADD     LOCOLD
       SKG     PTROLD+1
       BRU     *+2
       BRU     ILLOPR
       CAB
       SUB     ONE
       STP     TEMPTR
       BRR     OLDPOS
$STRSCN ZRO
       BRM     OLDPOS
       LDB     PTROLD+1
       STB     TEMPTR+1
       LDA     =3
       LDX     ONES
       BRS     12
       CIO     INFILE
       COPY    AB,A
       BRS     12
       SKN     INFILE
       BRU     *+2
       BRR     STRRTN
       CBA
       SKG     =77B
       BRU     *+2
       BRU     ILLOPR
       STA     CHRCOM
       GCI     TEMPTR
       BRU     ILLOPR
       SKE     CHRCOM
       BRU     *-3
       BRM     OLDPOS
       LDB     PTROLD+1
       STB     TEMPTR+1
       BRR     STRSCN
$NDNTRS LDA     PTRNEW+1
       SUB     PTRNEW
$NDNTRX STA     CHRNEW
       MIN     STRRTN
       BRR     STRRTN
*
*  S T R I N G   P O P   S T O R A G E   A R E A
*
$STRRTN BSS  1  RETURN LOCATION
$EDSTAT BSS  1  -1 FOR EDIT MODE, >=0 FOR ENTER MODE
$TMPFLG BSS  1  MISC. TEMPORARY STORAGE
$INFILE BSS  1  CURRENT ACTIVE INPUT FILE
$LOCOLD BSS  1  BEG. POINTER OF OLD STRING
$CHROLD DATA 0  FLAG USED FOR CONTROL-Y ROUTINE
$STRTMP BSS 44  TEMP. STORAGE FOR STRING RELOCATION
$STRNEW BSS 44  TEMP. STORAGE FOR NEW STRING
$CHRNEW BSS  1  ON NORMAL RETURN, NO. OF CHARS IN NEW STRING
$PTROLD BSS  2  LOC. FOR COMPUTED POINTERS TO OLD STRING
$PTRNEW BSS  2  POINTERS TO NEW STRING IN  STRNEW
$TABPOS BSS  1  CURRENT TAB POSITION IN NEW STRING
$POSOLD BSS  1  CURRENT TAB POSITION IN OLD STRING
$PRNTST BSS  1  -1 TO PRINT OLD STRING, >= DO NOT PRINT OLD STRING
$TEMPTR BSS  2  TEMP. POINTERS FOR STRING MANIPULATION
$INSERT BSS  1  CONTROL-E INSERT FLAG
$CHRCOM BSS  1  CHARACTER TESTED IN CTRL-Z,-O,-P AND -X ROUTINES
$STRSCV BSS  1  STRING SCAN TEST FLAG FOR CTRL-O AND -P ROUTINES
*
*  POP ROUTINE TO TAKE THE NUMBER IN THE A-REGISTER, CONVERT IT TO
*  A 7-CHARACTER TIME STRING AND APPEND IT TO THE STRING REFERENCED
*  BY THE POP IN THE FORM:
*
*              1:17:32
*
*  CALLING SEQUENCE:
*
*              LDA  TIME
*              TIM  PTR
*              NORMAL RETURN
*
*  REGISTERS AFFECTED:  ALL
*
$TIMPOP EAX* 0; STX TIMLOC; LDB 0,2; STB TIMPTR; LDB 1,2; STB TIMPTR+1
       ABC
       DIV  =108000    (60^3)/2
       COPY AX,A       HOURS
       DIV  =900       (60^2)/4
       STA  MINUTZ     MINUTES
       LSH  1          (REMAINDER)*2
       CLA
       DIV  =15        60/4
       STA  SEKNDZ     SECONDS
       CXA             HOURS
       ADD  =20B
       WCI  TIMPTR
       LDB  MINUTZ     MINUTES
       BRM  NUMST1
       LDB  SEKNDZ     SECONDS
       BRM  NUMST1
       LDX TIMLOC; LDP TIMPTR; STP 0,2
       BRR  0
$NUMST1 ZRO
       LDA =32B; WCI TIMPTR; LSH 1; CLA; DIV =10; ADD =20B; WCI TIMPTR
       CBA; ADD =20B; WCI TIMPTR; BRR NUMST1
$MINUTZ ZRO
$SEKNDZ ZRO
$TIMLOC ZRO
$TIMPTR BSS  2
*
*  POP ROUTINE TO APPEND CURRENT DATE AND TIME TO A STRING.  THIS
*  ROUTINE CREATES AN 18 CHARACTER STRING IN THE FORM:
*
*              JAN.12,1970  13:15
*
*  CALLING SEQUENCE:
*
*              DAT    PTR
*              NORMAL RETURN
*
*  REGISTERS AFFECTED:  ALL
*
$DATPOP EAX* 0; STX TIMLOC; LDP 0,2; STP TIMPTR; BRS 42; STB SEKNDZ
       STX YEAR; ABC; DIV =1800; ADD SEKNDZ; CAX; LRSH 16; STA MONTH; CXA
       ETR =177777B; RSH 23; DIV =1440; ADD ONE; STA DAY; CBA
       RSH 23; DIV =60; STA HOURS; STB MINUTZ; LDX MONTH; LDB DATJAN,2
       LDX =-3; CLA; LSH 8; WCI TIMPTR; BRX *-3; LDA MONTH; LDB =16B
       SKE =4; CBX; CXA; WCI TIMPTR; LDA DAY; BRM NUMSTR; LDX =-3
       LDB CENTRY; CLA; LSH 8; WCI TIMPTR; BRX *-3; LDA =64; ADD YEAR
       BRM NUMSTR; CLA; WCI TIMPTR; WCI TIMPTR; LDA HOURS; BRM NUMSTR
       LDA =32B; WCI TIMPTR; LDA MINUTZ; RSH 23; DIV =10; ADD =20B
       WCI TIMPTR; CBA; ADD =20B; WCI TIMPTR; LDX TIMLOC
       LDP TIMPTR; STP 0,2; BRR 0
$NUMSTR ZRO
       RSH 23; DIV =10; SKE ZERO; ADD =20B; WCI TIMPTR; CBA
       ADD =20B; WCI TIMPTR; BRR NUMSTR
$DATJAN ASC 'JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC'
$CENTRY ASC ',19'
$YEAR   ZRO
$MONTH  ZRO
$DAY    ZRO
$HOURS  ZRO
*
*  POP ROUTINE TO BREAK UP A STRING CONTAINING COMMAS AND ELIMINATES
*  LEADING AND TRAILING SPACES
*
*  CONVERTS "ONE,TWO" TO "ONE" AND "TWO"
*  CONVERTS "/1,2/,/3,4/" TO "/1,2/" AND "/3,4/"
*
*  CALL:
*
*              BRK PTR
*              LAST RETURN
*              NORMAL RETURN
*
*  RETURNS:
*
*      NO SKIP: A=-1 IF A NULL STRING (OR) LAST STRING POINTERS IN
*               A AND B REGISTERS
*
*      SKIP:    NEXT STRING POINTERS IN A AND B, PTR IS UPDATED IN
*               MEMORY AND AT LEAST ONE MORE STRING TO GO
*
$BRKPOP EAX* 0; LDP 0,2; STP BRKOLD; CAB; STP BRKPTR; GCI BRKOLD
       BRU BRKBCK; SKE ZERO; BRU *+4; MIN BRKPTR; MIN BRKPTR+1
       BRU *-6; SKE =17B; BRU *+2; BRU BRKFIL; MIN BRKPTR+1
       GCI BRKOLD; BRU BRKRTN+1; SKE =14B; BRU BRKAGN
$BRKRTN MIN 0; LDP BRKOLD; STP 0,2; LDP BRKPTR; BRR 0
$BRKAGN SKE ZERO; BRU *-11; GCI BRKOLD; BRU BRKRTN+1; SKE =14B
       BRU *-3; BRU BRKRTN
$BRKBCK LDA ONES; CAB; BRU BRKRTN+2
$BRKFIL MIN BRKPTR+1; GCI BRKOLD; BRU BRKRTN+1; SKE =17B; BRU BRKFIL
       MIN BRKPTR+1; GCI BRKOLD; BRU BRKRTN+1; SKE =14B
       BRU *-3; BRU BRKRTN
$BRKOLD BSS 2
$BRKPTR BSS 2
*
*  POP ROUTINE TO CONVERT A FREE-FORM NUMERIC STRING TO A FLOATING-
*  POINT REAL NUMBER
*
*  WRITTEN BY:  THAD FLORYAN    DEC.28, 1969
*
*  CALLING SEQUENCE:
*
*              SIC    STRING
*              ERROR RETURN
*              NORMAL RETURN
*
*  RETURNS:
*
*      NORMAL: FLOATING-POINT NUMBER IS IN A AND B REGISTERS WITH THE
*              EXPONENT IN THE B-REGISTER.  X-REGISTER IS LEFT
*              UNDISTURBED.  CONVERSION IS TERMINATED ON THE FIRST
*              "NON-NUMERIC" CHARACTER OR END-OF-STRING.  THE STRING
*              POINTERS ARE UPDATED IN MEMORY, I.E.:
*                   SIC  PTR      ="1E4(+10)1E5"
*                   ---
*                   1E4=(A)(B)    ="(+10)1E5"
*
*              IF FLOATING UNDERFLOW, FLOATING-POINT ZERO IS RETURNED
*              IN THE A AND B REGISTERS AND THE STRING POINTERS ARE
*              UPDATED IN MEMORY.
*
*      ERROR:  IF FLOATING OVERFLOW, THE MAXIMUM ALLOWABLE FLOATING-
*              POINT NUMBER IS RETURNED IN THE A AND B REGISTERS
*              AND THE STRING POINTERS ARE UPDATED IN MEMORY.
*
*
$SICPOP STX SICTX; EAX* 0; STX SICADR
       LDP 0,2; STP SICPTR; CLA; LDX =-9; STA SICBUF,2; BRX *-1
$SIL100 GCI SICPTR; BRU SIL35; MIN SICHAR; LDX =-15; SKE SICPNC,2
       BRU *+2; BRU SIL22; BRX *-3; WCD SICPTR; BRU SIL35
$SIL22  CXA; ADD =16; STA SICKEY; SUB =2; SKG ONES; BRU SIL100; SKE ZERO
       BRU SIL9; LDA SICNOE; SKE ZERO; BRU SIL8; MIN SICMS; BRU SIL100
$SIL8   MIN SICMSX; BRU SIL100
$SIL9   LDA SICKEY; SUB =13; SKG ONES; BRU SIL12; SKE ZERO; BRU SIL10
       MIN SICPRT; BRU SIL100
$SIL12  LDA SICNOE; SKE ZERO; BRU SIL33; BRU SIL185
$SIL10  LDA SICKEY; ADD =-15; SKG ONES; BRU SIL21; BRU SIL35
$SIL185 LDA SICPRT; SKG ZERO; BRU SIL187; MIN SICKNT
$SIL187 LDA SICKEY; SUB =3; BRS 51; STP SICTKE; LDP SICACC
       FMP FPTEN; FAD SICTKE; STP SICACC; BRU SIL100
$SIL21  MIN SICNOE; BRU SIL100
$SIL33  LDA SICNGX; MUL =10; LSH 23; ADD SICKEY; SUB =3; STA SICNGX
       BRU SIL100
$SIL35  LDA SICMSX; SKG ZERO; BRU SIL40; LDA SICNGX; CNA; STA SICNGX
$SIL40  LDA SICNGX; SUB SICKNT; STA SICNGX; SKE ZERO; BRU SIL27; BRU SIL28
$SIL27  LDA SICNGX    (CHECK EXP. FOR POS OR NEG)
       SKG ONES; BRU SIL27N; SKE ZERO; BRU SIL27P; BRU SIL28
$SIL27P CNA; CAX
       LDP FPONE
       FMP FPTEN    (1.0)*(10.0)
       BRX *-1
       FMP SICACC   SICACC*10^(SICNGX)
       STP SICACC
       BRU SIL28
$SIL27N CAX
       LDP FPONE
       FMP FTENTH   (1.0)*(0.1)
       BRX *-1
       FMP SICACC   SICACC*10^(-SICNGX)
       STP SICACC
$SIL28  LDA SICMS; SKE ZERO; BRU SICNEG
$SICRTN LDP SICPTR; LDX SICADR; STP 0,2  RETURN UPDATED POINTERS
       LDA SICACC+1; ETR =777B; SKE =377B; BRU SICGOB; LDA SICACC
       SKE =37777777B
$SICGOB MIN 0
       LDP SICACC; LDX SICTX; BRR 0
$SICNEG LDP SICACC; BRS 21; STP SICACC; BRU SICRTN
*
*  DATA AND STORAGE
*
$SICKNT ZRO
$SICMS  BSS  1   SIGN OF THE MANTISSA
$SICMSX BSS  1   SIGN OF THE EXPONENT
$SICHAR BSS  1   CHARACTER POSITION WITHIN THE STRING
$SICPRT ZRO
$SICNGX ZRO
$SICNOE ZRO
$SICACC BSS  2   ACCUMULATOR FOR CONVERTED NUMBER
$SICBUF EQU  *
$SICKEY ZRO
$SICTKE BSS  2
$SICADR ZRO
$SICTX  ZRO
$SICPTR BSS  2
$FPTEN  DATA  24B6,4              10.0
$FTENTH DATA  31463146B,31463775B  0.1
$FPONE  DATA  2B7,1                1.0
*
*  CHARACTERS:  +  -  0  1  2  3  4  5  6  7  8  9  .  E  (SPACE)
*
       DATA  13B,15B,20B,21B,22B,23B,24B,25B
       DATA  26B,27B,30B,31B,16B,45B,0
$SICPNC EQU  *
*
*  POP ROUTINE TO CONVERT AN INTEGER STRING TO AN INTEGER NUMBER IN
*  THE RANGE -999 TO +999.  ALL STRING CHARACTERS MUST BE IN THE
*  RANGE 0 TO 9.  THE FIRST STRING CHARACTER MUST BE A NUMBER OR A
*  SIGN:  "+" OR "-"
*
*  CALLING SEQUENCE:
*
*              XSIC   STRING
*              NORMAL RETURN
*
*  DUE TO THE REVERSE SCAN TECHNIQUE USED (FOR SPEED), THE STRING
*  POINTERS MUST DELIMIT ONLY THE STRING TO BE CONVERTED AND THEY
*  WILL BE DESTROYED ON RETURN
*
*  REGISTERS AFFECTED:  A,B
*
*XSICPP STX XSICTX
*       EAX* 0;* LDP 0,2;* STP XSICPT
*       LDB ONES;* GCI XSICPT;* BRU XSICRT;* SKE =15B (-);* BRU *+2
*       CLB;* STB XSICNG;* WCD XSICPT;* CLX;* STX XSICNM
*XSICGN GCD XSICPT;* BRU XSICRT
*       SKG =31B;* SKG =17B;* BRU XSICRT;* SUB =20B;* MUL TENTAB,2;* LSH 23
*       ADM XSICNM;* EAX 1,2;* BRU XSICGN
*XSICRT LDA XSICNM;* SKN XSICNG;* CNA;* LDX XSICTX;* BRR 0
*XSICNM ZRO
*XSICTX ZRO
*XSICNG ZRO
*XSICPT BSS 2
*TENTAB DATA 1,10,100
*
*  POP ROUTINE TO PRINT A STRING TO THE TERMINAL
*
*  CALLING SEQUENCE:
*
*              PSTR    PTR
*              NORMAL RETURN
*
*      WHERE PTR IS THE FIRST CELL OF A STRING POINTER PAIR
*
*  REGISTERS AFFECTED:  A,B
*
$PSTRPP STX MSGXRG; EAX* 0; LDP 0,2; LDX ONE; BRS 35; LDX MSGXRG; BRR 0
*
*  TWO POP ROUTINES TO OUTPUT ASC TEXT TO THE TERMINAL
*  SND:  OUTPUTS TEXT ONLY IF THE TERMINAL IS THE COMMAND FILE
*  SNDA: ALWAYS OUTPUTS THE TEXT
*
*  CALLING SEQUENCE:
*
*              SND   MSG
*              NORMAL RETURN
*
*  WHERE MSG IS THE STARTING CELL OF THE ASC MESSAGE
*
*  REGISTERS AFFECTED:  A,B
*
$SNDPOP STX MSGXRG; LDA COMINF; SKE ZERO; BRR 0
$SENDIT EAX* 0; CXA; ETR =37777B; LDB ONES; LDX ONE; BRS 34
       LDX MSGXRG; BRR 0
$SNDAPP STX MSGXRG; BRU SENDIT
*
*  POP ROUTINE TO OUTPUT PACKED TEXT TO THE TERMINAL
*      \  =  74B  IS INTERPRETED AS A CARRIAGE RETURN
*      ^  =  76B  IS INTERPRETED AS END-OF-TEXT FLAG
*      _  =  77B  IS INTERPRETED AS MULTIPLE SPACE FLAG...THE
*                 SUCCEEDING CHARACTER IS THE SPACE COUNT
*
*  CALLING SEQUENCE:
*
*              PTX   BUFF
*
*      WHERE BUFF IS THE STARTING CELL OF THE TEXT BLOCK
*
*  REGISTERS AFFECTED:  A,B
*
$PTXPOP STX MSGXRG
       LDA ONES; STA MSCNT; EAX* 0; BRU *+2
$PTXNXT EAX 1,2; LDB 0,2; STX XREG1; LDX =-4
$PTXR   CLA; LSH 6; SKN MSCNT; BRU PTXMS; SKE =76B; BRU *+3; LDX MSGXRG
       BRR 0; SKE =77B; BRU *+3; MIN MSCNT; BRU PTXF; SKE =74B; BRU *+2
       LDA =155B; CIO ONE
$PTXN   LDA ONES; STA MSCNT
$PTXF   BRX PTXR; LDX XREG1; BRU PTXNXT
$PTXMS  CNA; STX XREG2; COPY AX,A; CIO ONE; BRX *-1; LDX XREG2; BRU PTXN
$MSCNT  ZRO
$XREG1  ZRO
$XREG2  ZRO
$MSGXRG ZRO
*
*  POP ROUTINE TO DECREMENT MEMORY BY ONE.
*  EXACTLY THE OPPOSITE OF THE HARD-WIRED "MIN LOC"
*
*  CALLING SEQUENCE:
*
*              MDE   LOC
*
*  REGISTERS AFFECTED:  NONE
*
$MDEPOP STX MDEARG
       EAX* 0; SKR 0,2; NOP; LDX MDEARG; BRR 0
$MDEARG ZRO
*
*  POP ROUTINE THAT RETURNS THE MAXIMUM OF THE TWO NUMBERS IN THE
*  A AND B REGISTERS IN THE A-REGISTER
*
*              LDA NUM1
*              LDB NUM2
*              MAX
*
*  REGISTERS AFFECTED:  A
*
$MAXPOP STB MAXCOM; SKG MAXCOM; LDA MAXCOM; BRR 0
$MAXCOM ZRO
*
*  POP ROUTINE THAT PERFORMS MODULO OPERATION ON THE NUMBER IN THE
*  A-REGISTER BY THE NUMBER REFERENCED BY THE ADDRESS
*
*        (A-REGISTER) MOD (NUMBER AT ADDRESS)
*
*  REGISTERS AFFECTED:  A,B
*
$MODPOP STX MODXRG
       EAX* 0; MUL ONE; DIV 0,2; XAB; LDX MODXRG; BRR 0
$MODXRG ZRO
*
*  FLOATING-POINT ABSOLUTE VALUE OF THE FLOATING-POINT NUMBER IN
*  THE A AND B REGISTERS -
*
*  IS ACHIEVED BY:      SKG  ONES  (-1)
*                       FLN
*
*  FLOATING-POINT NUMBER FORMAT:
*
*      FIRST WORD:    FRACTION (MANTISSA, MOST SIGNIFICANT)
*      SECOND WORD:   EXPONENT (EXPONEXT, LEAST SIGNIFICANT)
*
*
*  FLOATING-POINT NEGATE
*      (THE ONE IN THE MONITOR DOESN'T WORK)
*
*  REGISTERS AFFECTED:  A,B
*
*FLNPOP STX FLNTX
*       SKB =77777000B;* BRU FLNPPA;* CNA
*       SKE ZERO;* SKA =17777777B;* BRR 0
*       STE;* SKE SIGN (4B7);* BRU FLNCOM
*       RCY 1;* BRX FLNQ5F
*FLNCOM NOD 4
*FLNQ5F XXA;* SKG =377B;* SKG =77777377B;* BRU FLNERR;* XXA
*FLNPPB LDE;* LDX FLNTX;* BRR 0
*FLNPPA STE;* XAB;* CNA;* XAB;* EOR ONES;* BRU FLNPPB
*FLNTX  ZRO
** FLOATING POINT OVER-/UNDER-FLOW
*FLNERR XXA;* BRU FLNPPB
*
*  POP ROUTINE TO PUT STRING REFERENCED BY XFRPTR (TRANSFER POINTERS)
*  INTO NEXT AVAILABLE TEXT BLOCK AREA.  EACH TEXT BLOCK HAS A 2-WORD
*  HEADER DENOTING:
*      1) 'TO' AND 'FROM' LOCATIONS
*      2) NUMBER OF CHARACTERS AND FULL WORDS USED BY THE STRING
*         STORED IN THE TEXT BLOCK
*
*  THE TEXT BLOCK IS OF THE FORM:
*
*      BIT:   000 000 000 0 11 111 111 112 222
*             012 345 678 9 01 234 567 890 123
*
*      HEADER: 2 WORDS
*      TEXT: AS MANY WORDS AS REQUIRED
*
*  FIRST WORD (HEADER)
*      BITS  1- 8  NUMBER OF CHARACTERS IN CURRENT STRING
*      BITS 10-23  ADDRESS OF NEXT BLOCK ("TO")
*      IF BIT 0 IS SET (WORD IS NEGATIVE), IT MEANS "THIS BLOCK CONTAINS
*              GARBAGE (LINE WAS DELETED) AND THE NEXT WORD CONTAINS THE
*              NUMBER OF WORDS AVAILABLE FOR REUSE."
*
*  SECOND WORD (HEADER)
*      BITS  1- 8  NUMBER OF FULL WORDS USED IN "THIS" BLOCK TO CONTAIN
*                  THE STRING
*      BITS 10-23  ADDRESS OF PREVIOUS BLOCK ("FROM")
*      IF THE FIRST WORD WAS NEGATIVE, THIS WORD CONTAINS THE NUMBER OF
*              WORDS AVAILABLE FOR REUSE AS STRING STORAGE
*
*  THIRD WORD (AND ON TO END)
*      ASCII CHARACTERS STORED 3 TO A WORD
*
*  INITIAL CONDITIONS (EMPTY TEXT BUFFER):
*
*      BLKTO/  30000B
*      BLKCUR/     0
*      BLKFRM/     0
*      BLKNOS/     0
*
*  DATA REQUIRED BY THIS ROUTINE:
*
*      BLKTO  BSS 1            ADDRESS OF NEXT AVAILABLE TEXT BLOCK
*      BLKCUR BSS 1            ADDRESS OF CURRENT TEXT BLOCK
*      BLKFRM BSS 1            ADDRESS OF PREVIOUS TEXT BLOCK
*
*      XFRPTR BSS 2            STRING POINTERS TO STRING TO BE INSERTED
*                              IN CURRENT TEXT BLOCK
*
*  OUTPUT FROM THIS ROUTINE:
*
*      BLKTO   ADDRESS OF NEXT AVAILABLE TEXT BLOCK
*      BLKCUR  ADDRESS OF CURRENT TEXT BLOCK
*      BLKFRM  ADDRESS OF PREVIOUS TEXT BLOCK
*      BLKNOS  TOTAL NUMBER OF TEXT BLOCKS WRITTEN IN TEXT BUFFER
*      BLKPOS  ADDRESS OF CURRENT TEXT BLOCK (SAME ADDRESS AS IN BLKCUR)
*              THIS ADDRESS IS USED BY OTHER ROUTINES AS A BASE
*      XFRPTR  DESTROYED
*      BLKWDS  NUMBER OF FULL-WORDS USED TO STORE STRING IN BLOCK
*      BLKCHR  NUMBER OF CHARACTERS IN STRING IN CURRENT TEXT BLOCK
*      BLKPTR  STRING POINTERS TO STRING IN CURRENT TEXT BLOCK
*
*  CALLING SEQUENCE:
*
*              (PUT INPUT DATA IN PROPER LOCATIONS)
*              PUTB
*              NORMAL RETURN
*
*  REGISTERS AFFECTED:  ALL
*
$PUTBPP SKN PUTFLG; BRR 0; LDA XFRPTR+1; SUB XFRPTR
       STA BLKCHR; MUL ONE; DIV =3; SKB ONES; ADD ONE; STA BLKWDS
       LDA BLKTO; LDB BLKCUR; STA BLKCUR; STA BLKPOS; STB BLKFRM
       ADD BLKWDS; ADD =2; STA BLKTO; COPY AX,A,B; LDA BLKCHR
       LSH 15; COPY AB,XB; STB* BLKCUR; CLAB; LDX BLKCUR; LDA BLKWDS
       LSH 15; MRG BLKFRM; STA 1,2; LDA BLKCUR; ADD BLKCUR; ADD BLKCUR
       ADD =5; CAB; STP BLKPTR; GCI XFRPTR; BRU *+3; WCI BLKPTR
       BRU *-3; MIN BLKNOS; BRR 0
$BLKTO EQU  36B
$BLKCUR EQU  37B
$BLKFRM EQU 40B
$BLKPOS EQU 42B
$BLKNOS EQU 41B
$BLKPTR EQU 45B
$BLKWDS EQU 47B
$BLKCHR EQU 50B
PUTFLG EQU 51B    MEANINGFUL ONLY DURING BSCAN ...
*                 =-1 PUT IN BUFFER, IF = 0, DO NOT PUT IN BUFFER
$XFRPTR EQU 43B
*
*  POP ROUTINE THAT COMPRESSES AND CONDITIONS INPUT LINES.
*  SHOULD BE USED ON EVERY LINE THAT IS INPUTTED.
*  ALLOWS SAVING OF SPACE IN THE TEXT BUFFER AND MAKES FOR EASIER
*  TRANSLATION.
*
*  CALLING SEQUENCE:
*
*              CMPRS    POINTER
*              ERROR RETURN (NULL STRING)
*              NORMAL RETURN
*
*  ON NORMAL RETURN, THE UPDATED POINTERS ARE IN CMPRSP AND THE STRING
*  IS STORED IN CMPRSB.  COMPRESSES ALL LINES, EVEN WITH
*  SEMICOLONS, UNLESS THE SEMICOLON IS IN A SLASHED FILE NAME ON
*  AN N-CARD.  COMMENTS (ANY LINE OR RECORD BEGINNING WITH A 'C') ARE
*  LEFT AS IS EXCEPT TRAILING SPACES ARE REMOVED.
*
*  EXAMPLES:
*
*   IN:  B 1 , N ( 1, 2),R = 3 50
*  OUT:  B1 N(1,2),R=350
*   IN:  E DIT $- 2,  $
*  OUT:  EDIT $-2,$
*   IN:  N1,FI = / 1,2,3 /  , M O = T RANS, NO =2, ( 7, 9)
*  OUT:  N1 FI=/ 1,2,3 /,MO=TRANS,NO=2,(7,9)
*
$CMPRSS EAX* 0; LDP 0,2; STP CMPRSX; LDA =CMPRSB; ADD =CMPRSB; ADD =CMPRSB
       SUB ONE; CAB; STP CMPRSP; LDA CMPRSX+1; SUB CMPRSX; SKG ZERO
       BRR 0
$CMPRSG GCI CMPRSX; BRU CMPRSO; SKG ZERO; BRU CMPRSG; SKE =43B
       BRU CMPRSR
$CMPRSC WCI CMPRSP; GCI CMPRSX; BRU CMPRSO; SKE =33B; BRU CMPRSC
       CAB; GCD CMPRSP; BRR 0; SKG ZERO; BRU *-3; WCI CMPRSP
       CBA; BRU CMPRSZ
$CMPRSR LDX =-7; SKE LABTAB,2; BRU *+2; BRU CMPRSN; BRX *-3; BRU CMPRSQ
$CMPRSV BRM CMPRSA; BRU CMPRSV
$CMPRSZ WCI CMPRSP; BRU CMPRSG
$CMPRSD BRM CMPRSY; SKE =14B
$CMPRSH WCI CMPRSP; GCI CMPRSX; BRU CMPRSO; SKG ZERO; BRU *-3
       SKE =33B; BRU CMPRSH; BRU CMPRSZ
$CMPRSO GCD CMPRSP; BRR 0; SKE =33B; BRU *+2; BRU CMPRSO
       WCI CMPRSP; MIN 0; BRR 0
$CMPRSN COPY AB,XA; SKE =-3; BRU CMPRSF; BRM CMPRSY; SKE =14B
$CMPRSE WCI CMPRSP; SKE =46B; BRU CMPRSM; GCI CMPRSX; BRU CMPRSO
       SKG ZERO; BRU *-3; SKE =51B; BRU CMPRST
       BRM CMPRSA; SKE =35B; BRU *-2; WCI CMPRSP; GCI CMPRSX
       BRU CMPRSO; SKG ZERO; BRU *-3; SKE =17B; BRU *+8; WCI CMPRSP
       GCI CMPRSX; BRU CMPRSO; SKE =17B; BRU *-4; WCI CMPRSP
       BRU CMPRSM; BRM CMPRSA; SKE =14B; BRU *-2; BRU CMPRSE
$CMPRSM GCI CMPRSX; BRU CMPRSO; SKG ZERO; BRU CMPRSM
$CMPRST SKE =33B; BRU CMPRSE; BRU CMPRSZ
$CMPRSY ZRO
       CBA; BRM CMPRSA; SKG =31B; SKG =17B; BRU CMPRSH; BRM CMPRSA
       SKG =31B; SKG =17B; BRU *+2; BRU *-4; COPY AB,A; WCI CMPRSP
       CBA; BRR CMPRSY
$CMPRSF CBA; SKE =45B; BRU CMPRSI; BRM CMPRSA; SKE =44B; BRU CMPRSU
       BRU CMPRSK
$CMPRSI SKE =51B; BRU CMPRSD; BRM CMPRSA; SKE =56B; BRU CMPRSU
       BRM CMPRSA; SKE =63B; BRU CMPRSU
$CMPRSK WCI CMPRSP; GCI CMPRSX; BRU CMPRSO; SKE =33B; BRU *+2
       BRU CMPRSZ; SKE ZERO; BRU CMPRSK; BRM CMPRSA; BRU *-1
$CMPRSU WCD CMPRSX; GCD CMPRSP; NOP; CAB; BRU CMPRSD
$CMPRSQ SKE =44B; BRU CMPRSJ; BRM CMPRSA; SKE =45B; BRU CMPRSU
       BRU CMPRSK
$CMPRSJ SKE =54B; BRU CMPRSV; BRM CMPRSA; SKE =51B; BRU CMPRSU; BRU CMPRSK
$CMPRSA ZRO
       WCI CMPRSP; GCI CMPRSX; BRU CMPRSO; SKG ZERO; BRU *-3
       SKE =33B; BRR CMPRSA; BRU CMPRSZ
$CMPRSX BSS 2
$CMPRSP BSS 2
$CMPRSB BSS 44
*
*  POP ROUTINE TO OUTPUT THE CIRCUIT STRING IN TPTR TO A SPECIFIED
*  FILE.  OUTPUT WILL BE FORMATTED IF IOPTON IS SET PROPERLY.
*
*  CALLING SEQUENCE:
*
*              PCKT    FILE
*
*  USES LABEL DICTIONARY "LABTAB"
*
$PCKTPP EAX* 0; LDA 0,2; STA PCKTFL; LDP TPTR; STP TPTR1; STP TPTR2
       LDA IOPTON; ETR =1B2; SKG ZERO; BRU PCKOUT
$PCKBR1 GCI TPTR1; BRR 0; SKE ZERO; BRU *+4; GCI TPTR2; NOP; BRU PCKBR1
       SKE =12B; BRU PCKBR2
$PCKAS1 GCI TPTR1; BRU PCKOUT; SKG ZERO; BRU PCKAS1; CLA; LDX =-5
       CIO PCKTFL; BRX *-1; BRU PCKOUT
$PCKBR2 SKE =43B; BRU PCKBR3; GCI TPTR1; BRU PCKOUT; SKG ZERO
       BRU PCKOUT; SKE =57B; BRU PCKOUT
$PCKELS LDX =-6; CLA; CIO PCKTFL; BRX *-1; BRU PCKOUT
$PCKBR3 SKG =31B; SKG =17B; BRU *+2; BRU PCKELS; LDX =-7; SKE LABTAB,2
       BRU *+2; BRU *+3; BRX *-3; BRU PCKELS; LDA ONE; STA PCKCOL
$PCKCGT GCI TPTR1; BRU PCKELS; SKG ZERO; BRU PCKCGT; SKG =31B
       SKG =17B; BRU *+3; MIN PCKCOL; BRU PCKCGT; LDA PCKCOL
       SKG ONE; BRU PCKELS; GCI TPTR2; NOP
$PCKCWT CIO PCKTFL; GCI TPTR2; BRU PCKCL7; SKG ZERO; BRU *-3; SKG =31B
       SKG =17B; BRU *+2; BRU PCKCWT; SKE =14B; BRU *+5; GCI TPTR2
       BRU PCKCL7; SKG ZERO; BRU *-3; WCD TPTR2
$PCKCL7 LDA PCKCOL; ADD =-6; COPY AX,A; CIO PCKTFL; BRX *-1
$PCKOUT LDP TPTR2; LDX PCKTFL; BRS 35; LDA =155B; CIO PCKTFL; BRR 0
$PCKCOL ZRO
$PCKTFL ZRO
*
*  POP ROUTINE THAT EXAMINES AND EVALUATES THE RANGE TYPED AFTER
*  AN EDITING COMMAND.  IF THE RANGE IS INVALID, NO SKIP RETURN
*  IF VALID, SETS UP POSCTR AND THE X-REGISTER FOR USE BY OTHER
*  ROUTINES.
*
*
*      CALLING SEQUENCE:
*
*              RANGE  PTR
*              ERROR RETURN
*              NORMAL RETURN
*
$RANGEP LDA 0; STA RANRTN
       LDA BLKNOS; SKG ZERO; BRR RANRTN
       EAX* 0; LDP 0,2; STP TPTR; STP TPTR1
       LDX ONES; STX RANMUL
       GCI TPTR; BRU *+5
       SKE =14B; BRU *-3
       MIN RANMUL; BRU *-5
       LDA TPTR1; STA TPTR
       SKN RANMUL; BRU RNGEP1  MULTIPLE RANGE
       LDP TPTR1; STP TPTR2
       BRM POSGET; STA BEGLOC; STA ENDLOC; BRU RANPOS
RNGEP1 LDA TPTR; CAB; STP TPTR1; BRU *+2
       MIN TPTR1+1
       GCI TPTR; BRR RANRTN
       SKE =14B; BRU *-4
       LDP TPTR1; STP TPTR2; BRM POSGET; STA BEGLOC
       LDP TPTR; STP TPTR2; BRM POSGET; STA ENDLOC
       SUB BEGLOC; SKG ONES; BRR RANRTN
       LDA BEGLOC
RANPOS CLX; STX POSCTR; LDX =30000B; MIN POSCTR; SKE POSCTR; BRU *+7
       LDA ENDLOC; SUB BEGLOC; CNA; STA POSCTR; MIN RANRTN; BRR RANRTN
       CAB; LDA 0,2; ETR =37777B; COPY AX,BA; BRU *-13
$TPTR   BSS  2
$TPTR1  BSS  2
$TPTR2  BSS  2
$TPTR3  BSS  2
$RANFLG ZRO
$POSTMP ZRO
$POSWDS ZRO
$POSCTR ZRO
$RANRTN ZRO
$RANMUL ZRO
$BEGLOC ZRO
$ENDLOC ZRO
$CURLOC ZRO
*
*  RETURNS THE PHYSICAL POSITION OF RANGE DENOTED IN TPTR2 IN
*  A-REGISTER.  ON ERRORS, TAKES ERROR POP RETURN
*
POSGET ZRO
       LDB ONES; STB RANFLG; GCI TPTR2; BRR RANRTN
       SKG =31B; SKG =17B; BRU POSGT1 NOT NUMERIC
       MDE TPTR2
       SIC TPTR2; BRR RANRTN
       BRS 50  CONVERT TO INTEGER
POSGTR SKG ZERO; BRR RANRTN
       SKG BLKNOS; BRR POSGET; BRR RANRTN
*
*  '.' REFERENCE
*
POSGT1 SKE =16B; BRU POSGT2
       BRM POSCUR
POSGT4 SIC TPTR2; BRR RANRTN
       BRS 50; ADD POSTMP; BRU POSGTR
*
*  '$' REFERENCE
*
POSGT2 SKE =4; BRU POSGT3
       SIC TPTR2; BRR RANRTN
       BRS 50; ADD BLKNOS; BRU POSGTR
*
*  LABEL REFERENCE
*
POSGT3 LDX =-7
       SKE LABTAB,2; BRU *+2; BRU *+3
       BRX *-3; BRR RANRTN
       LDA TPTR2; SUB ONE; CAB; STP TPTR3; MIN TPTR3+1
       GCI TPTR2; BRU *+7
       SKG =31B; SKG =17B; BRU *+3
       MIN TPTR3+1; BRU *-6
       MDE TPTR2
       LDA TPTR2; SUB TPTR3; SKG ONE; BRR RANRTN
       STA POSWDS
       CLX; STX POSCTR; LDA BLKNOS
       CNA; STA POSTMP; LDX =30000B
POSGT5 MIN POSCTR; MIN POSTMP; STX POSCUR
       EAX 2,2; CXA; MUL =3; LSH 23; SUB ONE; CAB; ADD POSWDS
       XAB; SKSE TPTR3; BRU *+4; LDA POSCTR; STA POSTMP; BRU POSGT4
       SKN POSTMP; BRR RANRTN
       LDA* POSCUR; ETR =37777B; CAX; BRU POSGT5
*
*  RETURNS PHYSICAL POSITION OF CURRENT TEXT BLOCK IN POSTMP
*
$POSCUR ZRO
       LDA BLKPOS; STA POSTMP; CLX; STX POSCTR; LDX =30000B
       MIN POSCTR; LDA 0,2; ETR =37777B; SKE POSTMP; BRU *+5; MIN POSCTR
       LDA POSCTR; STA POSTMP; BRR POSCUR; CAX; BRU *-10
*
*  B  E  I  M  N  S  T
*
       DATA 42B,45B,51B,55B,56B,63B,64B
$LABTAB EQU  *
*
*  DELETES TEXT BLOCKS SELECTED IN RANGE.  PATCHES THE TEXT BLOCK
*  POINTER CHAIN AND MAKES THE DELETED BLOCK(S) LOOK LIKE THIS:
*
*              WORD 1     -1
*              WORD 2     WORD COUNT
*              WORD 3     0
*                TO       0
*              (WORD COUNT-2)
*
$DELETM ZRO
       STX CURLOC; LDB 1,2; CLA; LSH 9; STA 1,2; CLA; LSH 15
       STA WHEFRM; LDA 0,2; ETR =37777B; STA WHERTO; LDA ONES; STA 0,2
       LDA DELNDX; ETR =777B5; ADD 1,2; ADD =2; ADD CURLOC
       STA DELNDX; LDA 1,2; CNA; COPY AX,A
$DELNDX STA 0,2; BRX DELNDX
       LDA* WHEFRM; ETR =777B5; MRG WHERTO; STA* WHEFRM
       LDX WHERTO; LDA 1,2; ETR =777B5; MRG WHEFRM; STA 1,2
       MDE BLKNOS; SKN POSCTR; BRU *+3; MIN POSCTR; BRU DELETM+1
       LDA BLKNOS; SUB ONE; STA SCOUNT; LDX =30000B; BRU *+2
       CAX; LDA 0,2; ETR =37777B; SKR SCOUNT; BRU *-4
       STA BLKTO; STX BLKCUR; LDA 1,2; ETR =37777B; STA BLKFRM
       BRR DELETM
SCOUNT ZRO
$WHEFRM ZRO
$WHERTO ZRO

*  PRINTS OUT CONTENTS OF TEXT BLOCKS SELECTED IN RANGE
*
$LISTER ZRO
       STX CURLOC; LDB 0,2; CLA; LSH 9; STA BLKCHR; CXA; ADD CURLOC
       ADD CURLOC; ADD =5; CAB; ADD BLKCHR; XAB; LDX ONE; BRS 35
       TCO =155B; SKN POSCTR; BRR LISTER; MIN POSCTR
       LDA* CURLOC; ETR =37777B; CAX; BRU LISTER+1


*  PERFORMS PATCHES NECESSARY FOR INSERTING TEXT IN TEXT BLOCK
*
*      INSRT1 IS CALLED BEFORE ENTRY OF NEW TEXT
*          USE PUTB AS NORMAL
*          SETS XXXINS = -1 AS A FLAG
*
*      INSRT2 IS CALLED UPON TERMINATION ON INSERT
*          XXXINS IS SET TO ZERO AS A FLAG
*
*  PROPER CALLING SEQUENCE:
*
*              RANGE  PTR
*              ERROR RETURN
*              BRM INSRT1
*              (ENTER TEXT)(XXXINS = -1)
*              (CONTROL D)
*              BRM INSRT2
*              (FINISHED)(XXXINS = 0)
*
$INSRT1 ZRO
       CXA; ETR =37777B; STA BLKIN1
       LDX 1,2; LDA 0,2; ETR =777B5; MRG BLKTO; STA 0,2
       LDA BLKCUR; STA BLKIN2
       CXA; ETR =37777B; STA BLKCUR
       LDA ONES; STA XXXINS; BRR INSRT1
$INSRT2 ZRO
       LDX BLKCUR
       LDA 0,2; ETR =777B5; MRG BLKIN1; STA 0,2
       LDX BLKIN2
       LDA 0,2; ETR =777B5; MRG BLKTO; STA 0,2
       LDX BLKIN1
       LDA 1,2; ETR =777B5; MRG BLKCUR; STA 1,2
       LDA BLKIN2; STA BLKCUR
       MIN XXXINS; BRR INSRT2
$XXXINS DATA 0
BLKIN1 ZRO
BLKIN2 ZRO

*
*  STIA  STORE A-REG IN 1-DIM INT. ARRAY, POS. IN X (>0)
*  LDIA  LOAD A-REG FROM 1-DIM INT. ARRAY, POS. IN X (>0)
*
$STIAPP STX STOREX
       EAX -1,2; XXA; MRG =235B5  (STA 0,2)
$IARSTO STA *+3; XXA; EAX* 0; ZRO; LDX STOREX; BRR 0
$LDIAPP STX STOREX; EAX -1,2; XXA; MRG =276B5 (LDA 0,2); BRU IARSTO
*
*  LDFA  LOAD AB INV. FROM 1-DIM REAL ARRAY, POS. IN X (>0)
*  STFA  STORE AB INV. IN 1-DIM REAL ARRAY, POS. IN X (>0)
*
$LDFAPP STX STOREX
       COPY XA,B,X; LSH 1; SUB =2; MRG =766B5 (LDP 0,2)
       STA *+2; EAX* 0; ZRO; XAB; LDX STOREX; BRR 0
$STFAPP STX STOREX; STA STOREA
       STB STOREB; COPY XA,B; LSH 1; SUB =2; MRG =767B5 (STP 0,2)
       STA *+4; LDB STOREA; LDA STOREB; EAX* 0; ZRO; XAB
       LDX STOREX; BRR 0
*
*  STF  STORE AB INV IN REAL NUMBER
*  LDF  LOAD AB INV FROM REAL NUMBER
*
$STFPOP STX STOREX
       EAX* 0; STA 1,2; STB 0,2; LDX STOREX; BRR 0
$LDFPOP STX STOREX
       EAX* 0; LDA 1,2; LDB 0,2; LDX STOREX; BRR 0
$STOREX ZRO
$STOREB ZRO
STOREA ZRO
COMINF EQU 1004B
IOPTON EQU 77711B-50001B
ONE    EQU 415B
ONES   EQU 420B
ZERO   EQU 414B
       END
ECAP ** FICHE/FRAME BREAK *****
ECINLPOPSYM SYMSORT

SYM.  PG.LN. IDENT.

BEGLOC 32 22 INLPOP  BLKCHR 28 26 INLPOP  BLKCUR 28 20 INLPOP  
BLKFRM 28 21 INLPOP  BLKIN1 35 36 INLPOP  BLKIN2 35 37 INLPOP  BLKNOS 28 23 INLPOP  
BLKPOS 28 22 INLPOP  BLKPTR 28 24 INLPOP  BLKTO  28 19 INLPOP  BLKWDS 28 25 INLPOP  
BLNKCK  4 25 INLPOP  BRKAGN 19 30 INLPOP  BRKBCK 19 32 INLPOP  BRKFIL 19 33 INLPOP  
BRKOLD 19 36 INLPOP  BRKPOP 19 25 INLPOP  BRKPTR 19 37 INLPOP  BRKRTN 19 29 INLPOP  
CENTRY 18 38 INLPOP  CHARIN  4 31 INLPOP  CHRCOM 17  6 INLPOP  CHRNEW 16 37 INLPOP  
CHROLD 16 34 INLPOP  CKTRLY 15  6 INLPOP  CMPRSA 30 18 INLPOP  CMPRSB 30 23 INLPOP  
CMPRSC 29 23 INLPOP  CMPRSD 29 29 INLPOP  CMPRSE 29 35 INLPOP  CMPRSF 30  8 INLPOP  
CMPRSG 29 21 INLPOP  CMPRSH 29 30 INLPOP  CMPRSI 30 10 INLPOP  CMPRSJ 30 17 INLPOP  
CMPRSK 30 12 INLPOP  CMPRSM 30  2 INLPOP  CMPRSN 29 34 INLPOP  CMPRSO 29 32 INLPOP  
CMPRSP 30 22 INLPOP  CMPRSQ 30 15 INLPOP  CMPRSR 29 26 INLPOP  CMPRSS 29 18 INLPOP  
CMPRST 30  3 INLPOP  CMPRSU 30 14 INLPOP  CMPRSV 29 27 INLPOP  CMPRSX 30 21 INLPOP  
CMPRSY 30  4 INLPOP  CMPRSZ 29 28 INLPOP  COMINF 36 30 INLPOP  CTRLA   5 15 INLPOP  
CTRLC   6 37 INLPOP  CTRLD   7 26 INLPOP  CTRLDD  7 38 INLPOP  CTRLE   8  4 INLPOP  
CTRLF   8 21 INLPOP  CTRLH   8 36 INLPOP  CTRLHH  9  4 INLPOP  CTRLI   9 14 INLPOP  
CTRLII  9 25 INLPOP  CTRLJ   9 38 INLPOP  CTRLK  10  5 INLPOP  CTRLM  10 19 INLPOP  
CTRLN  10 25 INLPOP  CTRLO  11  3 INLPOP  CTRLOO 11 13 INLPOP  CTRLP  11 27 INLPOP  
CTRLPP 11 37 INLPOP  CTRLQ   5 25 INLPOP  CTRLR  12 10 INLPOP  CTRLRR 12 14 INLPOP  
CTRLS   7 10 INLPOP  CTRLT  12 28 INLPOP  CTRLU  13  8 INLPOP  CTRLUU 13 20 INLPOP  
CTRLW   5 36 INLPOP  CTRLWW  5 39 INLPOP  CTRLX  13 33 INLPOP  CTRLXX 13 38 INLPOP  
CTRLY  14 14 INLPOP  CTRLYY 14 27 INLPOP  CTRLZ   6 15 INLPOP  CTRLZZ  6 20 INLPOP  
CURLOC 32 24 INLPOP  DATJAN 18 37 INLPOP  DATPOP 18 23 INLPOP  DAY    19  2 INLPOP  
DELETM 34 14 INLPOP  DELNDX 34 19 INLPOP  EDSTAT 16 30 INLPOP  ENDLOC 32 23 INLPOP  
FPONE  22 13 INLPOP  FPTEN  22 11 INLPOP  FTENTH 22 12 INLPOP  GETCHR  4  1 INLPOP  
HOURS  19  3 INLPOP  IARSTO 36  6 INLPOP  ILLOPR 15 15 INLPOP  INFILE 16 32 INLPOP  
INSERT 17  5 INLPOP  INSRT1 35 20 INLPOP  INSRT2 35 26 INLPOP  IOPTON 36 31 INLPOP  
LABTAB 34  3 INLPOP  LDFAPP 36 12 INLPOP  LDFPOP 36 25 INLPOP  LDIAPP 36  7 INLPOP  
LISTER 34 33 INLPOP  LOCOLD 16 33 INLPOP  MAXCOM 25 16 INLPOP  MAXPOP 25 15 INLPOP  
MDE     1  5 INLPOP  MDEARG 25  4 INLPOP  MDEPOP 25  2 INLPOP  MINUTZ 18  6 INLPOP  
MOD     1  6 INLPOP  MODPOP 25 25 INLPOP  MODXRG 25 27 INLPOP  MONTH  19  1 INLPOP  
MSCNT  24 27 INLPOP  MSGXRG 24 30 INLPOP  NDNTRS 16 21 INLPOP  NDNTRX 16 23 INLPOP  
NEWRIT  4 27 INLPOP  NUMST1 18  3 INLPOP  NUMSTR 18 34 INLPOP  OLDPOS 15 20 INLPOP  
ONE    36 32 INLPOP  ONES   36 33 INLPOP  PCKAS1 30 38 INLPOP  PCKBR1 30 36 INLPOP  
PCKBR2 31  1 INLPOP  PCKBR3 31  4 INLPOP  PCKCGT 31  6 INLPOP  PCKCL7 31 12 INLPOP  
PCKCOL 31 14 INLPOP  PCKCWT 31  9 INLPOP  PCKELS 31  3 INLPOP  PCKOUT 31 13 INLPOP  
PCKTFL 31 15 INLPOP  PCKTPP 30 34 INLPOP  POSCTR 32 19 INLPOP  POSCUR 33 34 INLPOP  
POSGET 32 29 INLPOP  POSGT1 33  1 INLPOP  POSGT2 33  8 INLPOP  POSGT3 33 14 INLPOP  
POSGT4 33  3 INLPOP  POSGT5 33 26 INLPOP  POSGTR 32 35 INLPOP  POSOLD 17  2 INLPOP  
POSTMP 32 17 INLPOP  POSWDS 32 18 INLPOP  PRNTST 17  3 INLPOP  PSTRPP 23 23 INLPOP  
PTRNEW 16 39 INLPOP  PTROLD 16 38 INLPOP  PTXF   24 25 INLPOP  PTXMS  24 26 INLPOP  
PTXN   24 24 INLPOP  PTXNXT 24 20 INLPOP  PTXPOP 24 18 INLPOP  PTXR   24 21 INLPOP  
PUTBPP 28 11 INLPOP  PUTFLG 28 27 INLPOP  RANFLG 32 16 INLPOP  RANGEP 31 29 INLPOP  
RANMUL 32 21 INLPOP  RANPOS 32  9 INLPOP  RANRTN 32 20 INLPOP  RBUILD  3 15 INLPOP  
RNGEP1 32  1 INLPOP  SCOUNT 34 27 INLPOP  SEKNDZ 18  7 INLPOP  SENDIT 23 39 INLPOP  
SIC     1  4 INLPOP  SICACC 22  4 INLPOP  SICADR 22  8 INLPOP  SICBUF 22  5 INLPOP  
SICGOB 21 30 INLPOP  SICHAR 21 39 INLPOP  SICKEY 22  6 INLPOP  SICKNT 21 36 INLPOP  
SICMS  21 37 INLPOP  SICMSX 21 38 INLPOP  SICNEG 21 32 INLPOP  SICNGX 22  2 INLPOP  
SICNOE 22  3 INLPOP  SICPNC 22 19 INLPOP  SICPOP 20 31 INLPOP  SICPRT 22  1 INLPOP  
SICPTR 22 10 INLPOP  SICRTN 21 27 INLPOP  SICTKE 22  7 INLPOP  SICTX  22  9 INLPOP  
SIL10  21  2 INLPOP  SIL100 20 33 INLPOP  SIL12  21  1 INLPOP  SIL185 21  3 INLPOP  
SIL187 21  4 INLPOP  SIL21  21  6 INLPOP  SIL22  20 35 INLPOP  SIL27  21 11 INLPOP  
SIL27N 21 20 INLPOP  SIL27P 21 13 INLPOP  SIL28  21 26 INLPOP  SIL33  21  7 INLPOP  
SIL35  21  9 INLPOP  SIL40  21 10 INLPOP  SIL8   20 37 INLPOP  SIL9   20 38 INLPOP  
SNDAPP 24  2 INLPOP  SNDPOP 23 38 INLPOP  STFAPP 36 15 INLPOP  STFPOP 36 23 INLPOP  
STIAPP 36  4 INLPOP  STOREA 36 29 INLPOP  STOREB 36 28 INLPOP  STOREX 36 27 INLPOP  
STRNEW 16 36 INLPOP  STRNGP  3 13 INLPOP  STRRTN 16 29 INLPOP  STRSCN 15 34 INLPOP  
STRSCV 17  7 INLPOP  STRTMP 16 35 INLPOP  TABPOS 17  1 INLPOP  TEMPTR 17  4 INLPOP  
TIMLOC 18  8 INLPOP  TIMPOP 17 23 INLPOP  TIMPTR 18  9 INLPOP  TMPFLG 16 31 INLPOP  
TPTR   32 12 INLPOP  TPTR1  32 13 INLPOP  TPTR2  32 14 INLPOP  TPTR3  32 15 INLPOP  
WHEFRM 34 28 INLPOP  WHERTO 34 29 INLPOP  XFRPTR 28 29 INLPOP  XREG1  24 28 INLPOP  
XREG2  24 29 INLPOP  XXXINS 35 35 INLPOP  YEAR   18 39 INLPOP  ZERO   36 34 INLPOP  

ECAP ** FICHE/FRAME BREAK *****
ECAC1SYM
C-AC1COMP    ECAP VER.6    AC FIRST COMPUTE LINK
C
C*AC COMPUTE VERSION:  6.00    MAY 18,1970        T.FLORYAN
C                      6.02    JUNE 8,1970        T.FLORYAN
C                      6.03    JULY 8,1970        T.FLORYAN
C
C
C
C
C
C       M A J O R    C H A N G E S    F R O M    V E R S I O N    5
C
C
C
C  -DIFFERENT STRUCTURE OF LINK NAMES IN COMMON
C  -MOVING OF VARIABLE "NTR" TO A DIFFERENT PLACE IN COMMON
C  -DIFFERENT "CALL LINK" SEQUENCE
C  -     "CALL SLINK2" TO READ SECOND LINK FROM SAME FILE AS THE FIRST
C  -ALL OCCURRENCES OF "DIMENSION LANG(612)"
C           CHANGED TO "DIMENSION LANG(531)"
C  -REDIMENSIONING OF FLM TO 50 FROM 10
C  -REDIMENSIONING OF IROWM AND ICOLM TO 20 FROM 10
C  -MINOR CLEANUP OF FORMATS
C  -ALTMODE TEST ON ENTRY AND BRANCH
C  -FIXED SUBROUTINE ECAP53     (VER 6.03)
C
C******* FOR LOADING BY FOS, USE FILE  ECLIBIN  FOR ALL MATH
C******* AND UTILITY SUBROUTINES
C
C
C
C     THIS IS ECAP40
C
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
C\\\\\\
C   
C   
       IF ( INTRP(1) ) 9995
       ASSIGN 9995 TO ISCAPE
       CALL ALTBRU ( ISCAPE )
      GO TO[997,99],KSW         
 997  IF[ IRTN - 2 ] 898,99,99  
898   CALL ECAP41    
20    CALL ECAP42[DUM1]        
      IF [ IRTN - 2 ] 30,9995,30
30    CALL ECAP43    
      IF [ IRTN - 2 ] 35,9995,35
35    CALL ECAP44    
      CALL ECAP45[1] 
40    CALL ECAP46    
      CALL ECAP45[2] 
      CALL ECAP47[DUM1,DUM2,EQUCRL,EQUCIM,EPRL,EPIM,NNODE]   
      CALL ECAP48[DUM1,DUM2,EQUCRL,EQUCIM,EPRL,EPIM,NNODE]   
       CALL SLINK2 ( AC1 )
  99  IF[MO] 9996,9996,100  
100   CALL ECAP53    
      CALL ECAP54    
      GO TO [ 20,30,30], ITRANS 
9995  IRTN = 1  
9996  KTO=2 
       CALL LINK ( ACL )
      END   
      SUBROUTINE ECAP41 
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
C\\\\\\
C 
  997 DO 900 J = 1, NMAX        
      IF [ IABS[ MODE1[ J ]] - 2 ] 800, 801, 802    
  800 CIM[ J ] = Y[ J ]         
      ELIM[J]=  0.0   
      Y[J] =  0.0     
      GO TO 900       
  801 CIM[ J ] = 0.0  
      ELIM[ J ] = 0.0 
      GO TO 900       
  802 ELIM[ J ] = Y[ J ]        
      CIM[J] =  0.0   
      Y[J] =  0.0     
  900 CONTINUE        
      OMGINV = 1.0 / OMEGA      
      IF[ NLTRMS ] 10, 52, 10   
C     SAVE MUTUAL TERMS FOR FUTURE MODIFY 
   10 DO 11 K = 1, NLTRMS       
      FLMSAV[K] = FLM[K]        
      IRSAV[K] = IROWM[K]       
 11   ICSAV[K]=ICOLM[K]         
      DO 12 K = 1, NMAX         
 12   ELSAV[K]=ELIM[K]
   21 DO 40 L = 1, NLTRMS       
      LL = L + NLTRMS 
      FLM[LL]  =  FLM[L]        
      IROWM[ LL ] = ICOLM[ L ]  
   40 ICOLM[ LL ] = IROWM[ L ]  
   52 DO 1015 J = 1, NMAX       
      IF[ EPHA[ J ]] 1011, 1012, 1011     
 1011 ANG = EPHA[ J ] 
      WRITE[3,500] ANG,J
500   FORMAT[//$  ANG =$ ,E14.8,$    J=$,I6]  
C     MAGNITUDE * COSINE OF ANG = REAL PART         
C     MAGNITUDE * SINE OF ANG = IMAG PART 
      EPHA[ J ] = E[ J ] * SIN[ ANG ]     
      E[ J ] = E[ J ] * COS[ ANG ]        
 1012 IF[ AMPPHA[ J ]]1013, 1015, 1013    
 1013 ANG = AMPPHA[ J ]         
      WRITE[3,501] ANG,J
501   FORMAT[//$THIS IS NO.2  ANG=$E14.8,$   J=$,I6] 
      AMPPHA[ J ] = AMP[ J ] * SIN[ ANG ] 
      AMP[ J ] = AMP[ J ] * COS[ ANG ]    
 1015 CONTINUE        
      RETURN     
      END   
      SUBROUTINE ECAP42[ZPRL]   
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION ZPRL[20,20]  
      DIMENSION MOBR[20]
      DIMENSION FWK[20],FWKA[20]
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
C\\\\\\
C     INVERT + RCSTOR COMBINED  
      IRTN=1
   42 IF[NLTRMS] 43,20,43       
   43 N=0   
      DO 100 I = 1, NUMBL       
      DO 100 J = 1, NUMBL       
  100 ZPRL[ I, J ]= 0.0         
      NEQUIM=NLTRMS+NLTRMS      
      DO 3 NM = 1, NMAX         
      IF[ MODE1[NM] - 3 ] 3, 2, 3         
    2 N = N + 1       
      MOBR [ N ] = NM 
      ZPRL[ N, N ] = ELIM[ NM ] 
    3 CONTINUE        
      IF[ N - NUMBL ] 19, 21, 19
   21 DO 14 L = 1, NEQUIM       
      J = 0 
      DO 8 K = 1, NMAX
      IF[ MODE1[K] - 3 ] 8, 4, 8
    4 J = J + 1       
      IF[ IROWM[ L ] - K ] 6, 5, 6        
    5 IR = J
      GO TO 8         
    6 IF[ ICOLM[ L ] - K ] 8, 7, 8        
    7 IC = J
    8 CONTINUE        
      TEMPA = 1.0/[ ZPRL[ IC, IR ] + 1.0/FLM   [ L ]]         
      DO 9 M = 1, J   
      FWK[ M ] = ZPRL[ M, IR ]  
    9 FWKA[ M ] = ZPRL[ IC, M ] 
      DO 13 M = 1, J  
      IF[ ZPRL[ M, IR ]] 10, 13, 10       
   10 TEMPB = TEMPA * FWK[ M ]  
      DO 12 N = 1, J  
      IF[ ZPRL[ IC, N ]] 11, 12, 11       
   11 ZPRL[ M, N ] = ZPRL[ M, N ] - TEMPB * FWKA[ N ]         
   12 CONTINUE        
   13 CONTINUE        
   14 CONTINUE        
      N = 0 
      DO 16 NM = 1, NMAX        
      IF[ MODE1[NM] - 3 ] 16, 15, 16      
   15 N = N + 1       
      ELIM[ NM ] = ZPRL[ N, N ] 
   16 CONTINUE        
      IF[ N - NUMBL ] 19, 22, 19
   22 L = 0 
      DO 18 N=1,NUMBL 
      DO  18 M=1,NUMBL
      IF[N-M]  17,18,17         
   17 IF[ZPRL[N,M]] 31,18,31    
   31 L=L+1 
      FLM[L]  =  ZPRL[N,M]      
      IROWM [ L ] = MOBR [ N ]  
      ICOLM [ L ] = MOBR [ M ]  
   18 CONTINUE        
      IF[ L - NUMBL * [ NUMBL - 1 ]]20, 20, 19      
 19   WRITE  ( 1, 30 )
 30   FORMAT[//$ERROR AC1 -- EXECUTION INHIBITED$//]
      IRTN=2
  20  RETURN     
      END   
      SUBROUTINE ECAP43 
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
C\\\\\\
C 
C     TRIPRO AC       
C 
      IRTN=1
    3 DO  10  J= 1, NNODE       
      DO  10 K = 1, NNODE       
      DUM1[J,K]=0.0   
   10 DUM2[J,K] =0.0  
      DO 20 I = 1, NMAX         
      NI = NINIT[ I ] 
      NF = NFIN[ I ]  
      IF[ NI ] 21, 22, 21       
   21 IF[ NF ] 24, 25, 24       
   22 IF[ NF ] 23, 500, 23      
   25 NF = NI         
   23 IF [ IABS[ MODE1[ I ]]- 2 ] 26, 27, 28        
   26 DUM2[ NF, NF ] = DUM2[ NF, NF ] + OMEGA * CIM[ I ]      
      GO TO 20        
   27 DUM1[ NF, NF ] = DUM1[ NF, NF ] + Y[ I ]      
      GO TO 20        
   28 DUM2[ NF, NF ] = DUM2[ NF, NF ]  -OMGINV * ELIM[ I ]    
      GO TO 20        
   24 IF [ IABS[ MODE1[ I ]]- 2 ] 29, 30, 31        
   29 PROD = OMEGA * CIM[ I ]   
      DUM2[ NI, NI ] = DUM2[ NI, NI ] + PROD        
      DUM2[ NI, NF ] = DUM2[ NI, NF ] - PROD        
      DUM2[ NF, NI ] = DUM2[ NF, NI ] - PROD        
      GO TO 26        
   30 DUM1[ NI, NI ] = DUM1[ NI, NI ] + Y[ I ]      
      DUM1[ NI, NF ] = DUM1[ NI, NF ] - Y[ I ]      
      DUM1[ NF, NI ] = DUM1[ NF, NI ] - Y[ I ]      
      GO TO 27        
   31 PROD = OMGINV * ELIM[ I ] 
      DUM2[ NI, NI ] = DUM2[ NI, NI ] - PROD        
      DUM2[ NI, NF ] = DUM2[ NI, NF ] + PROD        
      DUM2[ NF, NI ] = DUM2[ NF, NI ] + PROD        
      GO TO 28        
   20 CONTINUE        
      GO TO 601       
 500  WRITE ( 1, 501 )
 501  FORMAT[//$ERROR AC2 -- EXECUTION INHIBITED$//]
      IRTN=2
601   RETURN     
      END   
      SUBROUTINE ECAP44 
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
C\\\\\\
C     SPARSE AC       
    2 KK = 0
      NSUB = NTERMS   
 1000 IF[ NSUB ] 900, 901, 900  
  900 DO 930 N = 1, NSUB        
      IF[ KK - 1 ] 800, 801, 802
C     KK = 0  $$T$$ CARD        
C     KK = 1 $$M$$ CARD         
C     KK = 2 $$RETURN$$         
  800 LR = IROWT[ N ] 
      KC = ICOLT[ N ] 
      GO TO 850       
  801 LR = IROWM[ N ] 
      KC = ICOLM[ N ] 
  850 NI1 = NINIT[ LR ]         
      NF1 = NFIN[ LR ]
      NI2 = NINIT[ KC ]         
      NF2 = NFIN[ KC ]
      IF[ NI1 ] 101, 102, 101   
  101 IF[ NI2 ] 103, 110, 103   
  103 IF[ KK - 1 ] 51, 52, 802  
  102 IF[ NF1 ] 104, 930, 104   
  104 IF[ NI2 ] 105, 120, 105   
  105 IF[ KK - 1 ] 61, 62, 802  
  120 IF[ NF2 ] 106, 930, 106   
  106 IF[ KK - 1 ] 71, 72, 802  
  110 IF[ NF2 ] 107, 102, 107   
  107 IF[ KK - 1 ] 81, 82, 802  
C     CORRECTION TERMS NI1 + NI2
   51 DUM1[ NI1, NI2 ] = DUM1[ NI1, NI2 ] + YTERM[ N ]        
      GO TO 110       
   52 DUM2[ NI1, NI2 ] = DUM2[ NI1 , NI2 ] - OMGINV * FLM[ N ]
      GO TO 110       
C     CORRECTION TERMS NF1 + NI2
   61 DUM1[ NF1, NI2 ] = DUM1[ NF1, NI2 ] - YTERM[ N ]        
      GO TO 120       
   62 DUM2[ NF1, NI2 ] = DUM2[ NF1, NI2 ] + OMGINV * FLM[ N ] 
      GO TO 120       
C     CORRECTION TERMS NF1 + NF2
   71 DUM1[ NF1, NF2 ] = DUM1[ NF1, NF2 ] + YTERM[ N ]        
      GO TO 930       
   72 DUM2[ NF1, NF2 ] = DUM2[ NF1, NF2 ] - OMGINV * FLM[ N ] 
      GO TO 930       
C     CORRECTION TERMS NI1, NF2 
   81 DUM1[ NI1, NF2 ] = DUM1[ NI1, NF2 ] - YTERM[ N ]        
      GO TO 102       
   82 DUM2[ NI1, NF2 ] = DUM2[ NI1, NF2 ] + OMGINV * FLM[ N ] 
      GO TO 102       
  930 CONTINUE        
  901 IF[ KK - 1 ] 700, 802, 802
  700 KK = 1
      NSUB=NLTRMS+NLTRMS        
      GO TO 1000      
  802 CONTINUE        
      RETURN     
      END   
      SUBROUTINE ECAP45[IA] 
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
C\\\\\\
 44   IF[ NPRINT[ 10 ] ] 4, 9996, 4       
 100  FORMAT[//5X$ROW COL$/]
 101  FORMAT[4X$NODE NODE$,10X,$NODAL ADMITTANCE MATRIX$]
 102  FORMAT[//5X$NODES$13X$EQUIVALENT CURRENT VECTOR$]
  103 FORMAT[/4HREAL, 1X I2, 1X I2, 1H-, I2, 4[1X,E13.7]]
  104 FORMAT[/4HIMAG, 9X 4[1X,E13.7]]
  105 FORMAT[/4HREAL, 1X I2, 1H-, I2, 4[1X,E14.8]]
  106 FORMAT[/4HIMAG, 6X 4[1X,E14.8]]
 4    GO TO [30, 36 ], IA       
   30 WRITE [3, 100 ] 
      WRITE [3, 101 ] 
 36   DO 22 J=1,NNODE 
      LAST = 0        
 5    K=LAST+1        
      LAST = LAST +4  
      IF[LAST - NNODE]7,7,6     
 6    LAST = NNODE    
 7    GO TO [ 15, 16 ], IA      
C     WRITE NODAL ADMITTANCE MATRIX       
 15   WRITE [3, 103 ] J, K, LAST, [DUM1 [J, N ], N = K, LAST ]
      WRITE[ 3, 104 ] [ DUM2[ J, N ], N = K, LAST ] 
      GO TO 20        
 16   WRITE [3, 102 ] 
      WRITE[ 3, 105 ] K, LAST, [ EQUCRL[ N ], N = K, LAST ]   
      WRITE[ 3, 106 ][ EQUCIM[ N ], N = K, LAST ]   
 20   IF[LAST-NNODE]5,21,21     
 21   GO TO [ 22, 9996 ], IA    
 22   CONTINUE        
9996  RETURN     
      END   
      SUBROUTINE ECAP46 
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
C\\\\\\
C     ACECA / ACECB - LMVBM     
    3 DO 4000 I = 1, NMAX       
      BAMPRL[I] = Y[I]*E[I]-[CIM[I]*OMEGA - ELIM[I]*OMGINV]*EPHA[I]     
     1  - AMP[I]      
 4000 BAMPIM[I] = Y[I]*EPHA[I]+[CIM[I]*OMEGA - ELIM[I]*OMGINV]*E[I]     
     1  - AMPPHA[I]   
      IF[NTERMS] 9000,9000,7500 
 7500 DO 8000 I = 1, NTERMS     
      L=ICOLT[I]      
      LL=IROWT[I]     
      BAMPRL[LL]=BAMPRL[LL]+YTERM[I]*E[L] 
 8000 BAMPIM[LL]=BAMPIM[LL]+YTERM[I]*EPHA[L]        
 9000 IF[NLTRMS]9099,9099,9001  
 9001 NEQUIM=NLTRMS+NLTRMS      
      DO 9098 I=1,NEQUIM        
      L=ICOLM[I]      
      LL=IROWM[I]     
      BAMPRL[LL]=BAMPRL[LL]+FLM[I]*EPHA[L]*OMGINV   
 9098 BAMPIM[LL]=BAMPIM[LL]-FLM[I]*E[L]*OMGINV      
 9099 DO 9100 K=1,NNODE         
      EQUCIM[K]=0.0   
 9100 EQUCRL[K]=0.0   
      DO 9500 I=1,NMAX
      NI=NINIT[I]     
      NF=NFIN[I]      
      IF[NI]9300,9300,9200      
 9200 EQUCRL[NI]=EQUCRL[NI]-BAMPRL[I]     
      EQUCIM[NI]=EQUCIM[NI]-BAMPIM[I]     
 9300 IF[NF]9500,9500,9400      
 9400 EQUCRL[NF]=EQUCRL[NF]+BAMPRL[I]     
      EQUCIM[NF]=EQUCIM[NF]+BAMPIM[I]     
 9500 CONTINUE        
      RETURN     
      END   
      SUBROUTINE ECAP47[AR,AI,BR,BI,XR,XI,NA]   
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION AR[20,20],AI[20,20],BR[20],BI[20],XR[20],XI[20]  
C     DOUBLE PRECISION TR,TI,T,T1R,T11  
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
C\\\\\\
C     COMPLEX EQUATION SOLVER SUB ROUTINE 
      N = NA
C     CHECK FOR SINGLE NON-DATUM NODE     
  901 IF[N-1] 40,40,41
   41 TR=1.0/[AR[1,1] * AR[1,1] + AI[1,1] * AI[1,1]]
      TI = -AI[ 1,1 ] * TR      
      TR = AR[ 1,1 ] * TR       
      DO 111 J=2,N    
      T = AR[ 1,J ] * TR - AI[ 1,J ] * TI 
      AI[ 1,J ]=AR[ 1,J ] * TI + AI[ 1,J ] * TR     
  111 AR[ 1,J ] = T   
C     CONSTANT VECTOR ELEMENT   
      T = BR[ 1 ] * TR - BI[ 1 ] * TI     
      BI[ 1 ] = BR[ 1 ] * TI + BI [ 1 ] * TR        
      BR[ 1 ] = T     
      DO 7 L = 2, N   
      LM1 = L - 1     
      LP1 = L + 1     
      J = L 
      DO 3 I = J, N   
      TR = 0.         
      TI = 0.         
      DO 2 K = 1, LM1 
      TR = AR[ I,K ] * AR[ K,J ] - AI[ I,K ] * AI[ K, J ] + TR
    2 TI = AR[ I,K ] * AI[ K,J ] + AI[ I,K ] * AR[ K,J ]+TI   
      AR[ I,J ] = AR[ I,J ] - TR
    3 AI[ I,J ] = AI[ I,J ] - TI
C 
      I = L 
      TR = 1.0 / [ AR[ I,I ] * AR[ I,I ] + AI[ I,I ] * AI[ I,I ]]       
      TI = - AI[ I,I ] * TR     
      TR = AR[ I,I ] * TR       
      IF [ N - LP1 ] 60, 50, 50 
   50 DO 5 J = LP1, N 
      T1R = 0.0       
      T1I = 0.0       
      DO 4 K = 1, LM1 
      T1R = T1R + AR[ I,K ] * AR[ K,J ] - AI[ I,K ] * AI[ K,J ]         
    4 T1I = T1I + AR[ I,K ] * AI[ K,J ] + AI[ I,K ] * AR[ K,J ]         
      AR[ I,J ] = AR[ I,J ] - T1R         
      AI[ I,J ] = AI[ I,J ] - T1I         
      T = AR[I,J] *TR - AI[I,J] * TI      
      AI[ I,J ] = AR[ I,J ] * TI + AI[ I,J ] * TR   
    5 AR[ I,J ] = T   
   60 T1R = 0.0       
      T1I = 0.0       
      DO 6 K = 1, LM1 
      T1R = T1R + AR[ I,K ] * BR[ K ] - AI[ I,K ] * BI[ K ]   
    6 T1I = T1I + AR[ I,K ] * BI[ K ] + AI[ I,K ] * BR[ K ]   
      BR[ I ] = BR[ I ] - T1R   
      BI[ I ] = BI[ I ] - T1I   
      T = BR[ I ] * TR - BI[ I ] * TI     
      BI[ I ] = BR[ I ] * TI + BI[ I] * TR
      BR[ I ] = T     
    7 CONTINUE        
40    RETURN     
      END   
      SUBROUTINE ECAP48[AR,AI,BR,BI,XR,XI,NA]   
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION AR[20,20],AI[20,20],BR[20],BI[20],XR[20],XI[20]  
C     DOUBLE PRECISION TR,TI
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
C\\\\\\
C     BACK SUBSTITUTION         
      N = NA
    4 IF[N-1] 40,40,41
   41 XR[ N ] = BR[ N ]         
      XI[ N ] = BI[ N ]         
      DO 9 L = 2, N   
      I = N - L + 1   
      IP1 = I + 1     
      TR = 0.0        
      TI = 0.0        
      DO 8 K = IP1, N 
      TR = TR + AR[ I,K ] * XR[ K ] - AI[ I,K ] * XI[ K ]     
    8 TI = TI + AR[ I,K ] * XI[ K ] + AI[ I,K ] * XR[ K ]     
      XR[ I ] = BR[ I ] - TR    
      XI[ I ] = BI[ I ] - TI    
    9 CONTINUE        
      GO TO 10        
C     CALCULATION OF SINGLE NODE VOLTAGE  
   40 TR = AR[ 1, 1] * AR[ 1, 1] + AI[ 1, 1] * AI[ 1, 1]      
      XR[1]=[BR[1]*AR[1,1] + BI[1]*AI[1,1]]/TR      
      XI[1]=[BI[1]*AR[1,1] - BR[1]*AI[1,1]]/TR      
10    RETURN     
      END   
      SUBROUTINE ECAP53 
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
C\\\\\\
C 
  997 GO TO [ 2, 21, 210 ] , MO 
    2 ITOL = 0        
      K = 0 
      MO = 0
      MODM = 0        
      ITRANS = 0      
      OMGINV = 1.0/ OMEGA       
      IRTN=1
C 
C 
      DO 10 MA = 1, NUMMO       
      M = MA
      IF[ K ] 8, 7, 8 
    7 N = MOBRN[ M ]  
      MP=IABS[MOPARM[M]]        
       IF(MP) 29,29
      GO TO [ 11,12,13,14,15,16,17,18],MP 
C     $$R + G$$ DATA  
 11   IF[ MOPARM[ M ]] 110, 29, 111       
  111 Y[ N ] = 1.0/VFIRST[ M ]  
      GO TO 29        
  110 Y[ N ] = VFIRST[ M ]      
      GO TO 29        
C     $$GM + BETA$$ DATA        
 12   IF[ MOPARM[ M ]] 112, 29, 113       
  112 YTERM[ N ] = VFIRST[ M ]  
      GO TO 29        
  113 L=ICOLT[N]      
      YTERM[N]=VFIRST[M]*Y[L]   
      GO TO 29        
C     $$E$$ DATA      
   13 E[ N ] = VFIRST[ M ]      
      MM = M + 1      
      ANG=VFIRST[MM]*  0.01745329         
      EPHA[ N ] = E[ N ] * SIN[ ANG ]     
      E[ N ] = E[ N ] * COS[ ANG ]        
      K = 1 
      GO TO 29        
C     $$I$$ DATA      
   14 AMP[ N ] = VFIRST[ M ]    
      MM = M + 1      
      ANG = VFIRST[ MM ] * .01745329      
      AMPPHA[ N ] = AMP[ N ] * SIN[ ANG ] 
      AMP[ N ] = AMP[ N ] * COS[ ANG ]    
      K = 1 
      GO TO 29        
C     $$L$$ DATA      
 15   ELSAV[ N ] = 1.0/VFIRST[M]
      ELIM[ N ] = ELSAV[ N ]    
      MODM= 1         
      GO TO 29        
C     $$C$$ DATA      
   16 CIM[N] = VFIRST[ M ]      
      GO TO 29        
C     $$M$$ DATA      
 17   FLMSAV[ N ] = VFIRST[ M ] 
      MODM = 1        
      GO TO 29        
C     $$FREQUENCY$$ DATA        
 18   OMEGA = VFIRST[ M ] * 6.283185      
      OMGINV = 1.0/OMEGA        
      GO TO 29        
C     BYPASS ONE ENTRY
    8 K = 0 
      GO TO 10        
C     TEST FOR ITERATED PARAMETER         
 29   IF[  MOSTEP[ M ]] 6, 10, 6
    6 ITOL = M        
      MOSTEP[ M ] = 0 
      MOSTEP[ M + 1 ] = 0       
      MO = 2
      LL = MP         
   10 CONTINUE        
      IF[ MODM ] 19, 31, 19     
   19 IF [ NLTRMS ] 500, 31, 500
  500 DO 200 K = 1, NMAX        
 200  ELIM[ K ] = ELSAV[ K ]    
      DO 20 K = 1, NLTRMS       
      FLM[ K ] = FLMSAV[ K ]    
      IROWM[ K ] = IRSAV[ K ]   
      ICOLM[ K ] = ICSAV[ K ]   
       KK = K + NLTRMS         ;C    JULY 8,1970
      FLM[ KK ] = FLM[ K ]      
      IROWM[ KK ] = ICOLM[ K ]  
   20 ICOLM[ KK ] = IROWM[ K ]  
      ITRANS= 1       
      GO TO 9996      
C     CHECK FOR ITERATED PARAMETER        
   21 ICOL = 2        
      MO = 3
      LL = IABS[ MOPARM[ ITOL ]]
      GO TO[23, 23, 22, 22, 23, 23, 23, 25], LL     
  210 LL = IABS[ MOPARM[ ITOL ]]
      GO TO [ 203,203,202,202,203,203,203,26],LL    
  202 ITOL = ITOL + 1 
      VFIRST[ITOL] = VFIRST[ITOL] + HNODE 
      ITOL = ITOL - 1 
C 
      GO TO 203       
   22 ITOL = ITOL + 1 
      DELTA = [VLAST[ITOL] - VFIRST[ITOL]]/VSECND[ITOL]       
      VFIRST[ITOL] = VFIRST[ITOL] + DELTA 
      HNODE = DELTA   
      ITOL = ITOL - 1 
   23 DELTA = [VLAST[ITOL] - VFIRST[ ITOL ]]/ VSECND[ ITOL ]  
  203 VFIRST[ ITOL ] = VFIRST[ ITOL ] + DELTA       
   24 IF[VLAST[ITOL]-VFIRST[ITOL]] 38,37,39         
 37   GO TO [38,38,380,380,38,38,38,38],LL
 380  IF[DELTA]38,381,38        
 381  MM = ITOL + 1   
      IF[VLAST[MM] - VFIRST[MM]]38,38,39  
   25 GO TO [ 251, 23 ], NREC   
  251 DELTA = VSECND[ ITOL ]    
  261 VFIRST[ ITOL ] = VFIRST[ ITOL ] * DELTA       
      GO TO 24        
   26 GO TO [ 261, 203 ], NREC  
   38 MO = 0
   39 M = ITOL        
      GO TO 7         
   40 GO TO [ 31,31, 31, 31,19,31,19,31],LL         
   31 ITRANS= 2       
9996  RETURN     
      END   
      SUBROUTINE ECAP54 
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
C\\\\\\
 4    IF[ITOL]55,9996,55        
 55   IF[NPRINT[1]+NPRINT[2]+NPRINT[3]+NPRINT[4]+NPRINT[5]+NPRINT[6]+   
     1NPRINT[10]]511,9996,511   
511    MART1=2H  
      GO TO [ 500,501,502,503,508,509,512,9996],LL  
 500  IF [ MOPARM[ITOL] ] 505,505,504     
 501  IF[MOPARM[ITOL]]506,506,507         
 505  MART = 2HG 
      GO TO 510       
 504  MART = 2HR 
      GO TO 510       
 506  MART = 2HGM
      GO TO 510       
 507  MART = 2HBE
      MART1=2HTA
      GO TO 510       
 502  MART = 2HE 
      GO TO 510       
 503  MART = 2HI 
      GO TO 510       
 508  MART = 2HL 
      GO TO 510       
 509  MART = 2HC  
      GO TO 510       
 512  MART = 2HM 
 510  GO TO [520,520,515,515,520,520,520,520],LL    
  515 WRITE [ 3, 526 ] MART,MART1, VFIRST[ ITOL ], VFIRST[ ITOL + 1 ]         
      GO TO 9996      
  520 WRITE [ 3, 525 ] MART,MART1, VFIRST[ ITOL ]         
  525 FORMAT[///,1X,A2,A2,2H =, E16.8]
  526 FORMAT[///,1X,A2,A2,2H =, E16.8, 2H /, E16.8]
9996  RETURN     
      END   
ECAP ** FICHE/FRAME BREAK *****
ECAC2SYM
C-AC2COMP    ECAP VER.6    AC SECOND COMPUTE LINK
C
C*AC COMPUTE VERSION:  6.00    MAY 18,1970          T.FLORYAN
C                      6.02    JUNE 8,1970          T.FLORYAN
C                      6.03    JULY 8,1970          T.FLORYAN
C
C
C
C
C
C        M A J O R    C H A N G E S    F R O M    V E R S I O N    5
C
C
C
C  -DIFFERENT STRUCTURE OF LINK NAMES IN COMMON
C  -MOVING OF VARIABLE "NTR" TO A DIFFERENT PLACE IN COMMON
C  -DIFFERENT "CALL LINK" SEQUENCE
C  -ALL OCCURRENCES OF "DIMENSION LANG(612)"
C           CHANGED TO "DIMENSION LANG(531)"
C  -COMPLETE REWRITE OF SUBROUTINE ECA100
C  -REDIMENSIONING OF FLM TO 50 FROM 10
C  -REDIMENSIONING OF IROWM AND ICOLM TO 20 FROM 10
C  -MINOR CLEANUP OF FORMATS
C  -ALTMODE TEST ON ENTRY AND BRANCH
C  -FIXED SUBROUTINE ECAP52      (VER 6.03)
C  -FIXED SUBROUTINE ECAP53      (VER 6.03)
C
C******* FOR LOADING BY FOS, USE FILE  ECLIBIN  FOR ALL MATH
C******* AND UTILITY SUBROUTINES
C
C
C
C     THIS IS ECAP49
C     SUBROUTINE ECAP49
C
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION XR[60],XI[60]   
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
C\\\\\\
C 
C 
C     BRANCH VOLTAGE CALCULATIONS         
C
       IF ( INTRP(1) ) 69
       ASSIGN 69 TO ISCAPE
       CALL ALTBRU ( ISCAPE )
      CALL ECAP50[EPRL,EPIM,NNODE,XR,XI] 
      CALL ECAP51[1,XR,XI]
      CALL ECAP52[1,XR,XI]     
      CALL ECAP60[1,XR,XI]     
       CALL ECAP50[EBRL,EBIM,NMAX,XR,XI] 
      CALL ECAP51[5,XR,XI]
       CALL ECAP52[5,XR,XI]
      CALL ECAP60[2,XR,XI]     
       CALL ECAP50[CVOLTR,CVOLTI,NMAX,XR,XI]       
      CALL ECAP51[3,XR,XI]
      CALL ECAP52[3,XR,XI]     
      CALL ECAP61[1,XR,XI] 
202   CALL ECAP50[CAMPRL,CAMPIM,NMAX,XR,XI]        
      CALL ECAP51[2,XR,XI]
      CALL ECAP52[2,XR,XI]     
      CALL ECAP61[3,XR,XI] 
      CALL ECAP51[6,XR,XI]
      CALL ECAP52[6,XR,XI]     
      CALL ECAP61[2,XR,XI] 
      SUMR=0.0        
      SUMI=0.0        
      NEQUIM=NPRINT[4]
      DO 305 I = 1, NNODE       
      SUMR = SUMR + ABS[ XR[I]] 
 305  SUMI = SUMI + ABS[ XI[I]] 
      IF[SUMR - ERROR1]306,306,307        
 306  IF[SUMI - ERROR1]308,308,307        
 307  NPRINT[4] = 1   
      CALL ECAP51[11,XR,XI]
      CALL ECAP52[11,XR,XI]    
308   CALL ECAP 50[BAMPRL,BAMPIM,NMAX,XR,XI]       
      CALL ECAP51[4,XR,XI]
      CALL ECAP52[4,XR,XI]     
      NPRINT[4] = NEQUIM        
      KSW=2 
       CALL LINK ( AC1 )
69     CALL LINK ( ACL )
      END   
      SUBROUTINE ECAP50[X,Z,NA,XR,XI]   
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION X[60],Z[60]  
      DIMENSION XR[60],XI[60],ANG[60]   
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
C\\\\\\
C 
 4    DO 50 I = 1, NA 
      IF[X[I]]20,23,17
   17 IF [ Z[ I ]] 19, 18, 18   
 18   ANG[I]= ATAN [Z[I]/X[I]] 
      GO TO 27        
 19   ANG[I]= - ATAN [ -Z[I]/X[I]]       
      GO TO 27        
   20 IF [ Z[ I ]] 22, 21, 21   
 21   ANG[I]= 3.141592653589793-ATAN[-Z[I]/X[I]]   
      GO TO 27        
 22   ANG[I]= ATAN[Z[I]/X[I]] -3.141592653589793   
      GO TO 27        
   23 IF [ Z[ I ]] 24, 25, 26   
 24   ANG[I]= -1.570796326794896
      GO TO 27        
  25  ANG[I]=0.       
      GO TO 27        
 26   ANG[I]=  1.570796326794896
 27   XR[I]=SQRT[Z[I]*Z[I]+X[I]*X[I]]    
      XI[I]=ANG[I] * 57.2957795131        
 50   CONTINUE        
      RETURN     
      END   
      SUBROUTINE ECAP51[IA,XR,XI]
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
       DIMENSION XR(1),XI(1)
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
C\\\\\\
 4    IF [ IA - 1 ] 1010,552,1010         
1010   IF[ IA - 4 ] 1000,52,1000
  552 IF[NPRINT[1]+NPRINT[2]+NPRINT[3]+NPRINT[4]+NPRINT[5]+NPRINT[6]    
     1  +NPRINT[10]]511,1000,511
 511  FREQ = OMEGA/6.283185     
C
C  NEW CODING TO PUT OUTPUT WHERE IT BELONGS - ON UNIT NO.3
C
       IF (NPRINT(16) + NPRINT(17)) 1,51,1
1      WRITE (3,525) FREQ
C      IF(NPRINT(16)) 1,2,1
C1     WRITE [3,525] FREQ
C2     IF(NPRINT(17)) 3,51,3
C3     WRITE [1,525] FREQ
51    IF(NPRINT(59))1000,1000,17
52     IF(NPRINT(59))16,1000,1000
16    K=-NPRINT(59)
      ASSIGN 112 TO IFORMT
      GO TO 171
17    K=NPRINT(59)
      ASSIGN 111 TO IFORMT
171   K1=K/100
      K2=MOD(K,100)
       DB=XR(K1)/XR(K2)
       IF(DB)91,9,92
91     DB=ABS(DB)
92     IF(DB-1.0)93,94,94
93     K3=1
       DB=1.0/DB
94     DB=20.0*(ALOG(DB)/ALOG(10.0))
       IF(K3)95,9,95
95     DB=-DB
C
C  NEW CODING TO PUT OUTPUT WHERE IT BELONGS - ON UNIT NO. 3
C
9      IF (NPRINT(16) + NPRINT(17)) 10,1000,10
10     WRITE(3,IFORMT) K1,K2,DB
C9     IF(NPRINT(16))10,11,10
C10    WRITE [3,IFORMT] K1,K2,DB
C11    IF(NPRINT(17)) 12,1000,12
C12    WRITE [1,IFORMT] K1,K2,DB
111   FORMAT(/$DB(V$,I2,$/V$,I2,$) =$,E15.8)
112   FORMAT(/$DB(B$,I2,$/B$,I2,$) =$,E15.8)
 525  FORMAT[///$FREQ =$,E16.8]
 1000 IF[IA-11]1001,30,1001     
 1001 IF[NPRINT[IA]]7,501,7     
 7    GO TO [21,22,23,24,25,26,27,28,29],IA         
 100  FORMAT[//4X$NODES$14X$NODE VOLTAGES$]
 101  FORMAT[//4X$BRANCHES$11X$ELEMENT CURRENTS$]
 102  FORMAT[//4X$BRANCHES$11X$ELEMENT VOLTAGES$]
 103  FORMAT[//4X$BRANCHES$11X$BRANCH CURRENTS$]
 104  FORMAT[//4X$BRANCHES$11X$BRANCH VOLTAGES$]
 105  FORMAT[//4X$BRANCHES$11X$BRANCH POWER$]
 106  FORMAT[///$SENSITIVITIES NOT CALCULATED$//]
 107  FORMAT[///$WORST CASE NOT CALCULATED$//]
 108  FORMAT[///$STD.DEV. NOT CALCULATED$//]
 109  FORMAT[///,$ SOLUTION NOT OBTAINED TO DESIRED TOLERANCE$,//]      
 110  FORMAT[5X$NODES$13X$CURRENT UNBALANCES$]
 21   ASSIGN 100 TO IFORMT
      GO TO 500       
 22   ASSIGN 101 TO IFORMT
      GO TO 500       
 23   ASSIGN 102 TO IFORMT
      GO TO 500       
 24   ASSIGN 103 TO IFORMT
      GO TO 500       
 25   ASSIGN 104 TO IFORMT
      GO TO 500       
 26   ASSIGN 105 TO IFORMT
      GO TO 500       
 27   WRITE [ 1, 106 ]
      GO TO 501
 28   WRITE [ 1, 107 ]
      GO TO 501
 29   WRITE [ 1, 108 ]
      GO TO 501
 30   WRITE[3,109]    
      WRITE[3,110]    
      GO TO 501
500   CALL ECA100 [IFORMT,IA]
501   RETURN     
      END   
      SUBROUTINE ECAP52[IA,XR,XI]   
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION XR[60],XI[60]   
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
C\\\\\\
       ASSIGN 9996 TO IRTN1
 4    LIMIT = NMAX    
      IF [ IA - 11] 12,5,12     
 12   IF [ NPRINT[IA]] 9996,9996, 97      
   97 IF [ IA - 1 ] 6, 5, 6     
 5    LIMIT = NNODE   
 6    LAST = 0        
 666  K = LAST + 1    
      LAST = LAST + 4 
      IF[LAST - LIMIT ]8,8,7    
 7    LAST = LIMIT    
  900 FORMAT[/,3HMAG, 1X I2, 1H- , I2, 4[E15.8]]   
  901 FORMAT[/ 3HPHA, 6X 4[E15.8]]
 902  FORMAT[/,4HREAL,1X,I2,1H-,I2,4[E15.8]]
 903  FORMAT[/,4HIMAG,6X,4[E15.8]]
 8    IF [IA - 6 ] 100, 600, 700
100   CALL ECAP63[XR,XI,IRTN1,IA]
      WRITE[3, 900] K,LAST,[XR[ J ], J=K, LAST ]    
      WRITE[3, 901]        [XI[ J ], J=K, LAST ]    
      GO TO 11        
600   CALL ECAP63[POWRL,POWRL,IRTN1,IA]
      WRITE[ 3, 900 ] K, LAST, [ POWRL[ J ], J = K, LAST ]    
      GO TO 11        
700    IF ( IA - 11 ) 701,702,701      ;C    JULY 8,1970  T.FLORYAN
701   CALL ECAP63[XR,XI,IRTN1,IA]
702   WRITE[3, 902] K,LAST,[XR[ J ], J=K, LAST ]    
      WRITE[3, 903]        [XI[ J ], J=K, LAST ]    
 11   IF [LAST-LIMIT]666,9996,9996        
9996  RETURN     
      END   
      SUBROUTINE ECAP53 
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
C\\\\\\
C 
  997 GO TO [ 2, 21, 210 ] , MO 
    2 ITOL = 0        
      K = 0 
      MO = 0
      MODM = 0        
      ITRANS = 0      
      OMGINV = 1.0/ OMEGA       
      IRTN=1
C 
C 
      DO 10 MA = 1, NUMMO       
      M = MA
      IF[ K ] 8, 7, 8 
    7 N = MOBRN[ M ]  
      MP=IABS[MOPARM[M]]        
      GO TO [ 11,12,13,14,15,16,17,18],MP 
C     $$R + G$$ DATA  
 11   IF[ MOPARM[ M ]] 110, 29, 111       
  111 Y[ N ] = 1.0/VFIRST[ M ]  
      GO TO 29        
  110 Y[ N ] = VFIRST[ M ]      
      GO TO 29        
C     $$GM + BETA$$ DATA        
 12   IF[ MOPARM[ M ]] 112, 29, 113       
  112 YTERM[ N ] = VFIRST[ M ]  
      GO TO 29        
  113 L=ICOLT[N]      
      YTERM[N]=VFIRST[M]*Y[L]   
      GO TO 29        
C     $$E$$ DATA      
   13 E[ N ] = VFIRST[ M ]      
      MM = M + 1      
      ANG=VFIRST[MM]*  0.01745329         
      EPHA[ N ] = E[ N ] * SIN[ ANG ]     
      E[ N ] = E[ N ] * COS[ ANG ]        
      K = 1 
      GO TO 29        
C     $$I$$ DATA      
   14 AMP[ N ] = VFIRST[ M ]    
      MM = M + 1      
      ANG = VFIRST[ MM ] * .01745329      
      AMPPHA[ N ] = AMP[ N ] * SIN[ ANG ] 
      AMP[ N ] = AMP[ N ] * COS[ ANG ]    
      K = 1 
      GO TO 29        
C     $$L$$ DATA      
 15   ELSAV[ N ] = 1.0/VFIRST[M]
      ELIM[ N ] = ELSAV[ N ]    
      MODM= 1         
      GO TO 29        
C     $$C$$ DATA      
   16 CIM[N] = VFIRST[ M ]      
      GO TO 29        
C     $$M$$ DATA      
 17   FLMSAV[ N ] = VFIRST[ M ] 
      MODM = 1        
      GO TO 29        
C     $$FREQUENCY$$ DATA        
 18   OMEGA = VFIRST[ M ] * 6.283185      
      OMGINV = 1.0/OMEGA        
      GO TO 29        
C     BYPASS ONE ENTRY
    8 K = 0 
      GO TO 10        
C     TEST FOR ITERATED PARAMETER         
 29   IF[  MOSTEP[ M ]] 6, 10, 6
    6 ITOL = M        
      MOSTEP[ M ] = 0 
      MOSTEP[ M + 1 ] = 0       
      MO = 2
      LL = MP         
   10 CONTINUE        
      IF[ MODM ] 19, 31, 19     
   19 IF [ NLTRMS ] 500, 31, 500
  500 DO 200 K = 1, NMAX        
 200  ELIM[ K ] = ELSAV[ K ]    
      DO 20 K = 1, NLTRMS       
      FLM[ K ] = FLMSAV[ K ]    
      IROWM[ K ] = IRSAV[ K ]   
      ICOLM[ K ] = ICSAV[ K ]   
       KK = K + NLTRMS         ;C    JULY 8,1970    T.FLORYAN
      FLM[ KK ] = FLM[ K ]      
      IROWM[ KK ] = ICOLM[ K ]  
   20 ICOLM[ KK ] = IROWM[ K ]  
      ITRANS= 1       
      GO TO 9996      
C     CHECK FOR ITERATED PARAMETER        
   21 ICOL = 2        
      MO = 3
      LL = IABS[ MOPARM[ ITOL ]]
      GO TO[23, 23, 22, 22, 23, 23, 23, 25], LL     
  210 LL = IABS[ MOPARM[ ITOL ]]
      GO TO [ 203,203,202,202,203,203,203,26],LL    
  202 ITOL = ITOL + 1 
      VFIRST[ITOL] = VFIRST[ITOL] + HNODE 
      ITOL = ITOL - 1 
C 
      GO TO 203       
   22 ITOL = ITOL + 1 
      DELTA = [VLAST[ITOL] - VFIRST[ITOL]]/VSECND[ITOL]       
      VFIRST[ITOL] = VFIRST[ITOL] + DELTA 
      HNODE = DELTA   
      ITOL = ITOL - 1 
   23 DELTA = [VLAST[ITOL] - VFIRST[ ITOL ]]/ VSECND[ ITOL ]  
  203 VFIRST[ ITOL ] = VFIRST[ ITOL ] + DELTA       
   24 IF[VLAST[ITOL]-VFIRST[ITOL]] 38,37,39         
 37   GO TO [38,38,380,380,38,38,38,38],LL
 380  IF[DELTA]38,381,38        
 381  MM = ITOL + 1   
      IF[VLAST[MM] - VFIRST[MM]]38,38,39  
   25 GO TO [ 251, 23 ], NREC   
  251 DELTA = VSECND[ ITOL ]    
  261 VFIRST[ ITOL ] = VFIRST[ ITOL ] * DELTA       
      GO TO 24        
   26 GO TO [ 261, 203 ], NREC  
   38 MO = 0
   39 M = ITOL        
      GO TO 7         
   40 GO TO [ 31,31, 31, 31,19,31,19,31],LL         
   31 ITRANS= 2       
9996  RETURN     
      END   
      SUBROUTINE ECAP54 
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
C\\\\\\
 4    IF[ITOL]55,9996,55        
 55   IF[NPRINT[1]+NPRINT[2]+NPRINT[3]+NPRINT[4]+NPRINT[5]+NPRINT[6]+   
     1NPRINT[10]]511,9996,511   
511    MART1=2H  
      GO TO [ 500,501,502,503,508,509,512,9996],LL  
 500  IF [ MOPARM[ITOL] ] 505,505,504     
 501  IF[MOPARM[ITOL]]506,506,507         
 505  MART = 2HG 
      GO TO 510       
 504  MART = 2HR 
      GO TO 510       
 506  MART = 2HGM
      GO TO 510       
 507  MART = 2HBE
      MART1=2HTA
      GO TO 510       
 502  MART = 2HE 
      GO TO 510       
 503  MART = 2HI 
      GO TO 510       
 508  MART = 2HL 
      GO TO 510       
 509  MART = 2HC  
      GO TO 510       
 512  MART = 2HM 
 510  GO TO [520,520,515,515,520,520,520,520],LL    
  515 WRITE [ 3, 526 ] MART,MART1, VFIRST[ ITOL ], VFIRST[ ITOL + 1 ]         
      GO TO 9996      
  520 WRITE [ 3, 525 ] MART,MART1, VFIRST[ ITOL ]         
  525 FORMAT[///,1X,A2,A2,2H =, E16.8]
  526 FORMAT[///,1X,A2,A2,2H =, E16.8, 2H /, E16.8]
9996  RETURN     
      END   
      SUBROUTINE ECAP60[IPTR,XR,XI] 
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
C\\\\\\
      DIMENSION XR[60],XI[60]   
      GO TO [400,401],IPTR  
400   CONTINUE        
      DO 5 J = 1, NMAX
      EBRL[ J ] = 0.0 
      EBIM[ J ] = 0.0 
      NI = NINIT[ J ] 
      NF = NFIN[ J ]  
      IF[ NI ] 2, 3, 2
    2 EBRL[ J ] = EPRL[ NI ]    
      EBIM[ J ] = EPIM[ NI ]    
    3 IF[ NF ] 4, 5, 4
    4 EBRL[ J ] = EBRL[ J ] - EPRL[ NF ]  
      EBIM[ J ] = EBIM[ J ] - EPIM[ NF ]  
    5 CONTINUE        
      GO TO 800       
401   CONTINUE        
C     COIL VOLTAGE + COIL CURRENT CALCULATIONS      
      DO 100 N = 1, NMAX        
      CVOLTR[ N ] = EBRL[ N ] + E[ N ]    
      CVOLTI[ N ] = EBIM[ N ] + EPHA[ N ] 
      IF [ IABS[ MODE1[ N ]] - 2 ] 90, 91, 92       
   90 CAMPRL[ N ] = - CIM[ N ] * OMEGA * CVOLTI[ N ]
      CAMPIM[ N ] = CIM[ N ] * OMEGA * CVOLTR[ N ]  
      GO TO 100       
   91 CAMPRL[ N ] = Y[ N ] * CVOLTR [ N ] 
      CAMPIM[ N ] = Y[ N ] * CVOLTI[ N ]  
      GO TO 100       
   92 CAMPRL[ N ] = ELIM[ N ] * OMGINV * CVOLTI[ N ]
      CAMPIM[ N ] = - ELIM[ N ] * OMGINV * CVOLTR[ N ]        
  100 CONTINUE        
800   RETURN   
      END   
      SUBROUTINE ECAP61[IPTR,XR,XI] 
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
C\\\\\\
      DIMENSION XR[60],XI[60]   
      GO TO [402,403,404],IPTR  
402   CONTINUE        
      K = 0 
      NSUB = NTERMS   
  101 IF[ NSUB ] 102, 200, 102  
  102 DO 199 M = 1, NSUB        
      IF[ K ] 103, 104, 103     
  103 NR = IROWM[ M ] 
      NC = ICOLM[ M ] 
      GO TO 106       
  104 NR = IROWT[ M ] 
      NC = ICOLT[ M ] 
      IF[ CVOLTR[ NC ]] 110, 199, 110     
  110 CAMPRL[ NR ] = CAMPRL[ NR ] + YTERM[ M ] * CVOLTR[ NC ] 
      CAMPIM[ NR ] = CAMPIM[ NR ] + YTERM[ M ] * CVOLTI[ NC ] 
      GO TO 199       
  106 IF[ CVOLTR[ NC ]] 120, 199, 120     
  120 CAMPRL[NR] = CAMPRL[NR] + FLM[M] * OMGINV * CVOLTI[NC]  
      CAMPIM[ NR ] = CAMPIM[ NR ] - FLM[ M ] * OMGINV * CVOLTR[ NC ]    
  199 CONTINUE        
200   IF[K] 800,201,800         
  201 K= 1  
      NSUB = NLTRMS + NLTRMS    
      GO TO 101       
403   CONTINUE        
      DO 300 K = 1, NNODE       
      XR[K] = 0.0     
 300  XI[K] = 0.0     
      DO 304 I = 1,NMAX         
      NI = NINIT[I]   
      NF = NFIN[I]    
      IF[NI] 302,302,301        
 301  XR[NI] = XR[NI] - BAMPRL[I]         
      XI[NI]=XI[NI]-BAMPIM[I]   
 302  IF[NF] 304,304,303        
 303  XR[NF] = XR[NF] + BAMPRL[I]         
      XI[NF] = XI[NF] + BAMPIM[I]         
 304  CONTINUE        
      GO TO 800       
404   DO 299 N=1,NMAX   
      POWRL[ N ] = CVOLTR[ N ] * CAMPRL[ N ] + CVOLTI[ N ] * CAMPIM[ N ]
      BAMPIM[ N ] = CAMPIM[ N ] - AMPPHA[ N ]       
  299 BAMPRL[ N ] = CAMPRL[ N ] - AMP[ N ]
800   RETURN     
      END   
C
C     THIS IS ECAP63
      SUBROUTINE ECAP63[X,X1,IRTN1,IA]
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION X(1),X1(1)
C   
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
C\\\\\\
C
      DO 10 I=IA*6+15,IA*6+20
      IF(NPRINT(I)) 11,10,11
11    K=1
C
C  NEW CODING HERE TO PUT OUTPUT WHERE IT BELONGS - ON UNIT NO. 3
C
       IF (NPRINT(16) + NPRINT(17)) 69,10,69
69     IF (IA-6) 269,169,269
169    WRITE (3,100) NPRINT(I),X(NPRINT(I))
       GO TO 10
269    WRITE (3,101) NPRINT(I),X(NPRINT(I)),X1(NPRINT(I))
C      IF(NPRINT(16)) 121,13,121
C121   IF(IA-6) 12,122,12
C122   WRITE (3,100) NPRINT(I),X(NPRINT(I))
C      GO TO 13
C12    WRITE (3,101) NPRINT(I),X(NPRINT(I)),X1(NPRINT(I))
C13    IF(NPRINT(17)) 141,10,141
C141   IF(IA-6) 14,142,14
C142   WRITE (1,100) NPRINT(I),X(NPRINT(I))
C      GO TO 10
C14    WRITE (1,101) NPRINT(I),X(NPRINT(I)),X1(NPRINT(I))
10    CONTINUE
      IF(K) 16,15,16
15    RETURN
16    K=0
      GO TO IRTN1
100   FORMAT(/,I2,$ =$,E14.8)
101   FORMAT(/,I2,$ =$,E14.8,2X,E14.8)
      END
       SUBROUTINE ECA100 ( IFORM1,JX3 )
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION XR[60],XI[60]   
      DIMENSION IPAD1(7)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION IROWM(20),ICOLM(20),FLML(10),FLMH(10),FLM(50)
      DIMENSION EPHA(60),AMPPHA(60)
      DIMENSION EQUCRL(60),EQUCIM(60),CIM(60),ELIM(60),EPRL(20)
      DIMENSION EPIM(20),FLMSAV(10),IRSAV(10),ICSAV(10)
      DIMENSION CVOLTI(60),DUMX(2)
      DIMENSION LANG(531)
      DIMENSION ELSAV(60),CVOLTR(60),CAMPRL(60),CAMPIM(60)
      DIMENSION DUM1(20,20)
      DIMENSION DUM2(20,20)
      DIMENSION EBIM(60),EBRL(60),BAMPRL(60),BAMPIM(60)
      DIMENSION POWRL(60)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON EQUCRL,EQUCIM,CIM,ELIM,EPRL
      COMMON EPIM,FLMSAV,IRSAV,ICSAV,HNODE,OMGINV
      COMMON CVOLTI,ITOL,LL,ITRANS,DUMX
      COMMON LANG,IPAD1,APAD41
      COMMON VFIRST,IPAD44,VSECND,VLAST,EPHA
      COMMON IROWM,ICOLM,FLML,FLMH,FLM
      COMMON MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      COMMON ELSAV,CVOLTR,CAMPRL,CAMPIM
      COMMON DUM1
      COMMON DUM2
      EQUIVALENCE (EQUCRL(1),POWRL(1)),(CVOLTI(1),EBIM(1)),
     1 (CVOLTR(1),EBRL(1)),(CAMPRL(1),BAMPRL(1)),(CAMPIM(1),BAMPIM(1))
      EQUIVALENCE (IPAD1(2),NUMMO),(IPAD1(3),MO)
       ASSIGN 1 TO IFORMT
       IFORMT=IFORM1
       DO 20 I=JX3*6+15,JX3*6+20
       IF(NPRINT(I))21,20,21
20     CONTINUE
C
C  NEW CODE HERE -
C
200    IF (NPRINT(16) + NPRINT(17)) 1,4,1
1      WRITE 3,IFORMT
C200    IF(NPRINT(16))1,2,1
C1      WRITE 3,IFORMT
C2      IF(NPRINT(17))3,4,3
C3      WRITE 1,IFORMT
4      RETURN
21     GO TO (10,11,12,13,14,15),JX3
10     ASSIGN 100 TO IFORMT
       GO TO 200
100    FORMAT(//$NO     NO VOL            PHA$)
11     ASSIGN 110 TO IFORMT
       GO TO 200
110    FORMAT(//$BR     EL CUR            PHA$)
12     ASSIGN 120 TO IFORMT
       GO TO 200
120    FORMAT(//$BR     EL VOL            PHA$)
13     ASSIGN 130 TO IFORMT
       GO TO 200
130    FORMAT(//$BR     BR CUR            PHA$)
14     ASSIGN 140 TO IFORMT
       GO TO 200
140    FORMAT(//$BR     BR VOL            PHA$)
15     ASSIGN 150 TO IFORMT
       GO TO 200
150    FORMAT(//$BR     EL PWR$)
       END
ECAP ** FICHE/FRAME BREAK *****
ECDCSYM
C-DCCOMP    ECAP VER.6   DC COMPUTE LINK
C
C*DC COMPUTE VERSION:  6.00    MAY 18,1970       T.FLORYAN
C                      6.02    JUNE 8,1970       T.FLORYAN
C
C
C
C
C  M A J O R   C H A N G E S   F R O M   V E R S I O N   5
C
C
C  -DIFFERENT STRUCTURE OF LINK NAMES IN COMMON
C  -MOVING OF VARIABLE "NTR" TO A DIFFERENT PLACE IN COMMON
C  -DIFFERENT "CALL LINK" SEQUENCE
C  -ALL OCCURRENCES OF  "DIMENSION LANG(222)"
C           CHANGED TO  "DIMENSION LANG(221)"   [12]
C  -COMPLETE REWRITE OF SUBROUTINE ECA100
C  -MINOR CLEANUP OF FORMATS
C  -ADJUSTMENT OF COMMON BY VARIABLE 'OMEGA'
C  -COMMON VARIABLE 'PAD' REDIMENSIONED TO 50 FROM 10
C  -ALTMODE TEST ON ENTRY AND BRANCH
C
C
C****** FOR LOADING BY FOS, USE FILE  ECLIBIN  FOR ALL MATH
C****** AND UTILITY SUBROUTINES
C
C
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION PAD(50),IROOM(12)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION EB(60),AMPX(60),AMPB(60)VNOM(20),STDSQ(20)
      DIMENSION DUM1(78)
      DIMENSION SMLEP(20),CURR(60),SMLE(60),EQUCUR(20)
      DIMENSION EX(60)
      DIMENSION LANG(221)
      DIMENSION YX(60)
      DIMENSION MATA(60,4,3),YB(60),YTERMX(60),YTERMB(60)
      DIMENSION WCMAX(20),WCMIN(20),ZPRL(20,20)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON EB,AMPX,AMPB,VNOM,STDSQ,L,M,ITOL
      COMMON JX1,JX4,DUM1,IPAD41
      COMMON PAD1
      COMMON AX1,SMLEP,CURR,SMLE,EQUCUR
      COMMON EX
      COMMON LANG,IXOT
       COMMON ISEQ,ID1,MSEQ,ID2,MO,NUMMO,ID3,AD1,VFIRST,ID4,VSECND,VLAST
      COMMON YX
      COMMON WCMAX,WCMIN,PAD,MOBRN,MOPARM,MOSTEP
      COMMON YTERMX,YTERM,IROOM,MATA,YB,YTERMB
      COMMON ZPRL,JX5
C\\\\\\\
C 
C 
       IF( INTRP(1) ) 9995
       ASSIGN 9995 TO ISCAPE
       CALL ALTBRU ( ISCAPE )
81462 GO TO [700,705,710,420,715,720,725],KSW       
700   GO TO [1,420,400],IRTN    
    1 JX4=0 
      DO 10 I=1,NMAX  
      YX[I]=Y[I]      
      EX[I]=E[I]      
   10 AMPX[I]=AMP[I]  
      IF[ NTERMS ] 30, 5, 30    
   30 DO 11 I=1,NTERMS
   11 YTERMX[I]=YTERM[I]        
5     CALL ECAP22
       GO TO 81462
705   IF[NPRINT[10]] 7,7,8      
    8 JX1=1 
      CALL ECAP24
       GO TO 81462
7     CALL ECAP26
       GO TO 81462
710   IF[NPRINT[10]] 3,3,4      
    4 JX1=2 
      CALL ECAP24
       GO TO 81462
3     KSW=4 
      CALL ECAP25
       GO TO 81462
  420 IF[JX4]419,419,20         
  419 I=ISEQ+1        
      GO TO [302,16,17,18,18],I 
   18 DO 19 I=1,NNODE 
   19 STDSQ[I]=0.0    
      IF[ISEQ-3]16,16,17        
   17 DO 25 K=1,3     
      DO 25 I=1,4     
      NUM=NMAX        
      IF[I-2]22,23,22 
   23 IF[NTERMS]25,25,21        
   21 NUM=NTERMS      
   22 DO 25 J=1,NUM   
      MATA[J,I,K]=0   
   25 CONTINUE        
      DO 24 I=1,NNODE 
 24   VNOM[I]=SMLEP[I]
 16   L=1   
      M=NNODE         
      GO TO 850       
   20 L=JX5 
      M=JX5 
850   KSW=5 
      CALL ECAP28
       GO TO 81462
715   IF[JX4] 9995,880,820      
  880 IF[ISEQ-2]301,800,801     
801   CALL ECAP29
       GO TO 81462
720   IF[ISEQ-3] 301,301,800    
  800 JX5=0 
      ISEQ=0
      WRITE[3,803]    
  803 FORMAT[///39H WORST CASE SOLUTIONS FOR NODE VOLTAGES/,
     1 5H NODE,5X,5HWCMIN,14X,7HNOMINAL,12X,5HWCMAX/]
820   CALL ECAP27
       GO TO 81462
725   IF[JX4-1] 302,5,5         
  301 ISEQ=0
  302 IF[MO]9995,9995,400       
  400 IF[NUMMO]402,119,402      
402   CALL ECAP30
       GO TO 81462
  119 ISEQ=MSEQ       
      IWCOUT[1]=IWCOUT[3]       
      IWCOUT[2]=IWCOUT[4]       
      IWCOUT[3]=0     
      IWCOUT[4]=0     
      MO=0  
      IF[ ITOL ]419,419,900     
  900 MOSTEP[ITOL]=0  
      GO TO 419       
 9995 IRTN=1
9996  KTO=2 
      CALL LINK(DCL)
      END   
C 
       SUBROUTINE ECAP22
C  THIS IS COMMON FOR DC
C*\*\*\
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION PAD(50),IROOM(12)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION EB(60),AMPX(60),AMPB(60)VNOM(20),STDSQ(20)
      DIMENSION DUM1(78)
      DIMENSION SMLEP(20),CURR(60),SMLE(60),EQUCUR(20)
      DIMENSION EX(60)
      DIMENSION LANG(221)
      DIMENSION YX(60)
      DIMENSION MATA(60,4,3),YB(60),YTERMX(60),YTERMB(60)
      DIMENSION WCMAX(20),WCMIN(20),ZPRL(20,20)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON EB,AMPX,AMPB,VNOM,STDSQ,L,M,ITOL
      COMMON JX1,JX4,DUM1,IPAD41
      COMMON PAD1
      COMMON AX1,SMLEP,CURR,SMLE,EQUCUR
      COMMON EX
      COMMON LANG,IXOT
       COMMON ISEQ,ID1,MSEQ,ID2,MO,NUMMO,ID3,AD1,VFIRST,ID4,VSECND,VLAST
      COMMON YX
      COMMON WCMAX,WCMIN,PAD,MOBRN,MOPARM,MOSTEP
      COMMON YTERMX,YTERM,IROOM,MATA,YB,YTERMB
      COMMON ZPRL,JX5
C\\\\\\\
C 
      DO 10 J=1,NNODE 
      DO 10 K=1,NNODE 
 10   ZPRL[J,K]=0.0   
      DO 20 I=1,NMAX  
      NI = NINIT[I]   
      NF = NFIN[I]    
      IF [ NI ] 21, 22, 21      
 22   IF [ NF ] 23, 20, 23      
 21   IF[ NF ] 24, 25, 24       
 25   NF = NI         
      GO TO 23        
 24   ZPRL[NI,NI]= ZPRL[NI,NI] + YX[I]    
      ZPRL[NI,NF]= ZPRL[NI,NF] - YX[I]    
      ZPRL[NF,NI]= ZPRL[NF,NI] - YX[I]    
 23   ZPRL[NF,NF]= ZPRL[NF,NF] + YX[I]    
 20   CONTINUE        
      IF[NTERMS]7000,7000,5500  
 5500 DO 6500 N=1,NTERMS        
      LR =IROWT[N]    
      LC=ICOLT[N]     
      TERM=YTERMX[N]  
      I=NINIT[LR]     
      IF[I]6000,6000,5600       
 5600 J=NFIN[LC]      
      IF[J]5800,5800,5700       
 5700 ZPRL[I,J]=ZPRL[I,J]-TERM  
 5800 J=NINIT[LC]     
      IF[J]6000,6000,5900       
 5900 ZPRL[I,J]=ZPRL[I,J]+TERM  
 6000 I=NFIN[LR]      
      IF[I]6500,6500,6100       
 6100 J=NINIT[LC]     
      IF[J]6300,6300,6200       
 6200 ZPRL[I,J]=ZPRL[I,J]-TERM  
 6300 J=NFIN[LC]      
      IF[J]6500,6500,6400       
 6400 ZPRL[I,J]=ZPRL[I,J]+TERM  
 6500 CONTINUE        
7000  CALL ECAP23
       RETURN
      END   
       SUBROUTINE ECAP23
C  THIS IS COMMON FOR DC
C*\*\*\
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION PAD(50),IROOM(12)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION EB(60),AMPX(60),AMPB(60)VNOM(20),STDSQ(20)
      DIMENSION DUM1(78)
      DIMENSION SMLEP(20),CURR(60),SMLE(60),EQUCUR(20)
      DIMENSION EX(60)
      DIMENSION LANG(221)
      DIMENSION YX(60)
      DIMENSION MATA(60,4,3),YB(60),YTERMX(60),YTERMB(60)
      DIMENSION WCMAX(20),WCMIN(20),ZPRL(20,20)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON EB,AMPX,AMPB,VNOM,STDSQ,L,M,ITOL
      COMMON JX1,JX4,DUM1,IPAD41
      COMMON PAD1
      COMMON AX1,SMLEP,CURR,SMLE,EQUCUR
      COMMON EX
      COMMON LANG,IXOT
       COMMON ISEQ,ID1,MSEQ,ID2,MO,NUMMO,ID3,AD1,VFIRST,ID4,VSECND,VLAST
      COMMON YX
      COMMON WCMAX,WCMIN,PAD,MOBRN,MOPARM,MOSTEP
      COMMON YTERMX,YTERM,IROOM,MATA,YB,YTERMB
      COMMON ZPRL,JX5
C\\\\\\\
      DO 4000 LL=1,NMAX         
 4000 CURR[LL] = YX[LL] * EX[LL] - AMPX[LL]         
      IF[NTERMS]9000,9000,7500  
 7500 DO 8000 I = 1, NTERMS     
      L = ICOLT[ I ]  
      LL = IROWT[ I ] 
 8000 CURR[ LL ] = CURR[ LL ] + YTERMX[ I ] * EX[ L ]         
 9000 DO 9100 K=1,NNODE         
 9100 EQUCUR[K]=0.0   
      DO 9500 LL=1,NMAX         
      II=NINIT[LL]    
      JJ=NFIN[LL]     
      IF[II]9300,9300,9200      
 9200 EQUCUR[II] = EQUCUR[II] - CURR[LL]  
 9300 IF[JJ]9500,9500,9400      
 9400 EQUCUR[JJ]=EQUCUR[JJ]+CURR[LL]      
 9500 CONTINUE        
      KSW=2 
       RETURN
      END   
       SUBROUTINE ECAP24
C 
C  THIS IS COMMON FOR DC
C*\*\*\
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION PAD(50),IROOM(12)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION EB(60),AMPX(60),AMPB(60)VNOM(20),STDSQ(20)
      DIMENSION DUM1(78)
      DIMENSION SMLEP(20),CURR(60),SMLE(60),EQUCUR(20)
      DIMENSION EX(60)
      DIMENSION LANG(221)
      DIMENSION YX(60)
      DIMENSION MATA(60,4,3),YB(60),YTERMX(60),YTERMB(60)
      DIMENSION WCMAX(20),WCMIN(20),ZPRL(20,20)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON EB,AMPX,AMPB,VNOM,STDSQ,L,M,ITOL
      COMMON JX1,JX4,DUM1,IPAD41
      COMMON PAD1
      COMMON AX1,SMLEP,CURR,SMLE,EQUCUR
      COMMON EX
      COMMON LANG,IXOT
       COMMON ISEQ,ID1,MSEQ,ID2,MO,NUMMO,ID3,AD1,VFIRST,ID4,VSECND,VLAST
      COMMON YX
      COMMON WCMAX,WCMIN,PAD,MOBRN,MOPARM,MOSTEP
      COMMON YTERMX,YTERM,IROOM,MATA,YB,YTERMB
      COMMON ZPRL,JX5
C\\\\\\\
C 
C 
C 
C 
      GO TO [2550,3400],JX1     
 3400 WRITE [ 3, 2000 ]         
 2000 FORMAT[///$NODAL IMPEDANCE MATRIX$]
      GO TO 51        
 2550 WRITE [ 3, 50 ] 
   50 FORMAT[///$NODAL CONDUCTANCE MATRIX$]
   51 WRITE [ 3, 2001 ]         
 2001 FORMAT[/$ROW COLS$]
      DO 53 I = 1, NNODE        
      LAST=0
   54 K=LAST+1        
      LAST =LAST+4    
      IF[LAST-NNODE]55,55,56    
   56 LAST=NNODE      
   55 WRITE [ 3, 57 ] I, K, LAST, [ZPRL[ I, J ], J = K, LAST ]
      IF [ NNODE - LAST ] 53, 53, 54      
   57 FORMAT[/I2, I3, 1H-I2, 2X, 4E15.8 ]
   53 CONTINUE        
 2500 IF[JX1-1]9996,940,9996    
  940 WRITE [ 3, 60 ] 
   60 FORMAT[///$EQUIVALENT CURRENT VECTOR$/$NODE NO.$6X$CURRENT$]
      DO 62 I = 1, NNODE        
   62 WRITE [ 3, 63 ] I, EQUCUR[ I ]      
   63 FORMAT[/I6,4X,E15.8]
      CALL ECAP26
       RETURN
9996  KSW=4 
      CALL ECAP25
       RETURN
      END   
       SUBROUTINE ECAP25
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION X[60]
C  THIS IS COMMON FOR DC
C*\*\*\
      DIMENSION PAD(50),IROOM(12)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION EB(60),AMPX(60),AMPB(60)VNOM(20),STDSQ(20)
      DIMENSION DUM1(78)
      DIMENSION SMLEP(20),CURR(60),SMLE(60),EQUCUR(20)
      DIMENSION EX(60)
      DIMENSION LANG(221)
      DIMENSION YX(60)
      DIMENSION MATA(60,4,3),YB(60),YTERMX(60),YTERMB(60)
      DIMENSION WCMAX(20),WCMIN(20),ZPRL(20,20)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON EB,AMPX,AMPB,VNOM,STDSQ,L,M,ITOL
      COMMON JX1,JX4,DUM1,IPAD41
      COMMON PAD1
      COMMON AX1,SMLEP,CURR,SMLE,EQUCUR
      COMMON EX
      COMMON LANG,IXOT
       COMMON ISEQ,ID1,MSEQ,ID2,MO,NUMMO,ID3,AD1,VFIRST,ID4,VSECND,VLAST
      COMMON YX
      COMMON WCMAX,WCMIN,PAD,MOBRN,MOPARM,MOSTEP
      COMMON YTERMX,YTERM,IROOM,MATA,YB,YTERMB
      COMMON ZPRL,JX5
C\\\\\\\
    4 IF[JX4]8,8,101  
C 
C     OUTPUT NODE VOLTAGES      
C 
    8 IF[NPRINT[1]]101,101,99   
99     ASSIGN 134 TO IFORMT
       IA=1
       CALL ECA100 [ IFORMT,IA ]
C 133 FORMAT[//$ NODE VOLTAGES$//]
  134 FORMAT[//6H NODES,15X,$NODE VOLTAGES$]
      DO 5 I=1,NNODE  
    5 X[I]=SMLEP[I]   
      KMAX=NNODE      
      IND=1 
      GO TO 100       
C 
C     BRANCH VOLTAGES 
C 
  101 DO 10 I=1,NMAX  
      SMLE[I] = 0.0   
      J=NINIT[I]      
      IF[J]11,11,12   
 12   SMLE[I] = SMLEP[J]        
 11   K=NFIN[I]       
      IF [ K ] 10, 10, 14       
 14   SMLE[I] = SMLE[I] - SMLEP[K]        
   10 CONTINUE        
      IF[JX4]9,9,102  
    9 IF[NPRINT[5]]102,102,15   
15     ASSIGN 132 TO IFORMT
       IA=5
       CALL ECA100 [ IFORMT,IA ]
C 131 FORMAT[//$ BRANCH VOLTAGES$//]
  132 FORMAT[//9H BRANCHES,12X,$BRANCH VOLTAGES$]
      DO 16 I=1,NMAX  
   16 X[I]=SMLE[I]    
      KMAX=NMAX       
      IND=2 
      GO TO 100       
C 
C     ELEMENT VOLTAGES
C 
  102 DO 17 I=1,NMAX  
   17 SMLE[I]=SMLE[I]+EX[I]     
      IF[JX4]7,7,103  
    7 IF[NPRINT[3]]103,103,18   
18     ASSIGN 135 TO IFORMT
       IA=3
       CALL ECA100 [ IFORMT,IA ]
  135 FORMAT[//$ BRANCHES$,12X,$ELEMENT VOLTAGES$]
      DO 19 I=1,NMAX  
   19 X[I]=SMLE[I]    
      KMAX=NMAX       
      IND=3 
      GO TO 100       
C 
C     ELEMENT CURRENTS
C 
  103 DO 20 I=1,NMAX  
   20 CURR[I]=YX[I]*SMLE[I]     
      IF[NTERMS]21,22,21        
   21 DO 23 I=1,NTERMS
      NR=IROWT[I]     
      NC=ICOLT[I]     
      IF[SMLE[NC]]24,23,24      
   24 CURR[NR]=CURR[NR]+YTERMX[I]*SMLE[NC]
   23 CONTINUE        
   22 IF[JX4]25,25,105
   25 IF[NPRINT[2]]104,104,26   
26     ASSIGN 137 TO IFORMT
       IA=2
       CALL ECA100 [ IFORMT,IA ]
C 136 FORMAT[//$ ELEMENT CURRENTS$//]
  137 FORMAT[//9H BRANCHES,12X,$ELEMENT CURRENTS$]
      DO 27 I=1,NMAX  
   27 X[I]=CURR[I]    
      KMAX=NMAX       
      IND=4 
      GO TO 100       
C 
C     BRANCH POWER LOSSES       
C 
  104 IF[NPRINT[6]]105,105,28   
   28 DO 29 I=1,NMAX  
   29 X[I]=CURR[I]*SMLE[I]      
       ASSIGN 139 TO IFORMT
       IA=6
       CALL ECA100 [ IFORMT,IA ]
C 138 FORMAT[//$ ELEMENT POWER LOSSES$//]
  139 FORMAT[//9H BRANCHES,12X,$ELEMENT POWER LOSSES$]
      KMAX=NMAX       
      IND=5 
      GO TO 100       
C 
C     BRANCH CURRENTS 
C 
  105 DO 30 I=1,NMAX  
   30 CURR[I]=CURR[I]-AMPX[I]   
C 
C     CHECK UNBALANCES
C 
      DO 33 I=1,NNODE 
   33 X[I]=0.         
      DO 36 I=1,NMAX  
      J=NINIT[I]      
      K=NFIN[I]       
      IF[K]34,34,35   
   35 X[K]=X[K]+CURR[I]         
   34 IF[J]36,36,37   
   37 X[J]=X[J]-CURR[I]         
   36 CONTINUE        
      SUM=0.
      DO 38 I=1,NNODE 
   38 SUM = SUM + ABS[ X[ I ]] 
      IF[SUM-ERROR1]106,106,40  
   40 WRITE[3,141]    
      WRITE [3,142]   
  141 FORMAT[//$ SOLUTION NOT OBTAINED TO DESIRED TOLERANCE$//]
  142 FORMAT[$ NODES$,15X,$CURRENT UNBALANCES$]
      KMAX=NNODE      
      IND=6 
      GO TO 100       
  106 IF[JX4]300,300,900        
  300 IF[NPRINT[4]]900,900,41   
   41 DO 42 I=1,NMAX  
   42 X[I]=CURR[I]    
       ASSIGN 140 TO IFORMT
       IA=4
       CALL ECA100 [ IFORMT,IA ]
  140 FORMAT[//$ BRANCHES$12X,$BRANCH CURRENTS$]
      KMAX=NMAX       
      IND=7 
C 
C     OUTPUT ROUTINE  
C 
  100 LAST=0
  150 K=LAST+1        
      LAST=LAST+4     
      IF[LAST-KMAX]200,200,201  
  201 LAST=KMAX       
200    ASSIGN 500 TO IRTN1
       CALL ECAP63 [ X,IRTN1,IA ]
      WRITE[3,203]K,LAST,[X[J],J=K,LAST]  
  203 FORMAT[/,I2,1H-,I2,2X,4[E16.8]] 
      IF[KMAX-LAST]500,500,150  
C 
  500 GO TO [101,102,103,104,105,41,900],IND        
900    RETURN
      END   
       SUBROUTINE ECAP26
C 
C 
C  THIS IS COMMON FOR DC
C*\*\*\
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION PAD(50),IROOM(12)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION EB(60),AMPX(60),AMPB(60)VNOM(20),STDSQ(20)
      DIMENSION DUM1(78)
      DIMENSION SMLEP(20),CURR(60),SMLE(60),EQUCUR(20)
      DIMENSION EX(60)
      DIMENSION LANG(221)
      DIMENSION YX(60)
      DIMENSION MATA(60,4,3),YB(60),YTERMX(60),YTERMB(60)
      DIMENSION WCMAX(20),WCMIN(20),ZPRL(20,20)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON EB,AMPX,AMPB,VNOM,STDSQ,L,M,ITOL
      COMMON JX1,JX4,DUM1,IPAD41
      COMMON PAD1
      COMMON AX1,SMLEP,CURR,SMLE,EQUCUR
      COMMON EX
      COMMON LANG,IXOT
       COMMON ISEQ,ID1,MSEQ,ID2,MO,NUMMO,ID3,AD1,VFIRST,ID4,VSECND,VLAST
      COMMON YX
      COMMON WCMAX,WCMIN,PAD,MOBRN,MOPARM,MOSTEP
      COMMON YTERMX,YTERM,IROOM,MATA,YB,YTERMB
      COMMON ZPRL,JX5
C\\\\\\\
C 
C 
C     DOUBLE PRECISION AMAX, SWAP, T      
      DIMENSION INDEX[50,2],IPIV[50]      
C 
C 
C 
C 
      N = NNODE       
    3 DO 20 J=1,N     
   20 IPIV[J]=0       
      DO 550 I=1,N    
      AMAX=0.         
      DO 105 J=1,N    
      IF[IPIV[J]-1]60,105,60    
   60 DO 100 K=1,N    
      IF[IPIV[K]-1]80,100,750   
   80 IF[ ABS[ ZPRL[ J, K ]] - ABS[ AMAX ]] 100, 100, 85    
   85 IROW=J
      ICOL=K
      AMAX=ZPRL[J,K]  
  100 CONTINUE        
  105 CONTINUE        
      IPIV[ICOL]=IPIV[ICOL]+1   
      IF[IROW-ICOL]140,260,140  
  140 DO 200 L=1,N    
      SWAP=ZPRL[IROW,L]         
      ZPRL[IROW,L]=ZPRL[ICOL,L] 
  200 ZPRL[ICOL,L]=SWAP         
  260 INDEX[I,1]=IROW 
      INDEX[I,2]=ICOL 
      ZPRL[ICOL,ICOL]=1.0       
      DO 350 L=1,N    
  350 ZPRL[ICOL,L]=ZPRL[ICOL,L]/AMAX      
      DO 550 L1=1,N   
      IF[L1-ICOL]400,550,400    
  400 T=ZPRL[L1,ICOL] 
      ZPRL[L1,ICOL]=0.0         
      DO 450 L=1,N    
  450 ZPRL[L1,L]=ZPRL[L1,L]-ZPRL[ICOL,L]*T
  550 CONTINUE        
      DO 710 I=1,N    
      L=N+1-I         
      IF[INDEX[L,1]-INDEX[L,2]]630,710,630
  630 IROW=INDEX[L,1] 
      ICOL=INDEX[L,2] 
      DO 705 K=1,N    
      SWAP=ZPRL[K,IROW]         
      ZPRL[K,IROW]=ZPRL[K,ICOL] 
      ZPRL[K,ICOL]=SWAP         
  705 CONTINUE        
  710 CONTINUE        
  750 CONTINUE        
      DO 4 I=1,N      
      SMLEP[I]=0.0    
      DO 4 J=1,N      
    4 SMLEP[I]=SMLEP[I]+ZPRL[I,J]*EQUCUR[J]         
9999  KSW=3 
       RETURN
      END   
       SUBROUTINE ECAP27
C  THIS IS COMMON FOR DC
C*\*\*\
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION PAD(50),IROOM(12)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION EB(60),AMPX(60),AMPB(60)VNOM(20),STDSQ(20)
      DIMENSION DUM1(78)
      DIMENSION SMLEP(20),CURR(60),SMLE(60),EQUCUR(20)
      DIMENSION EX(60)
      DIMENSION LANG(221)
      DIMENSION YX(60)
      DIMENSION MATA(60,4,3),YB(60),YTERMX(60),YTERMB(60)
      DIMENSION WCMAX(20),WCMIN(20),ZPRL(20,20)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON EB,AMPX,AMPB,VNOM,STDSQ,L,M,ITOL
      COMMON JX1,JX4,DUM1,IPAD41
      COMMON PAD1
      COMMON AX1,SMLEP,CURR,SMLE,EQUCUR
      COMMON EX
      COMMON LANG,IXOT
       COMMON ISEQ,ID1,MSEQ,ID2,MO,NUMMO,ID3,AD1,VFIRST,ID4,VSECND,VLAST
      COMMON YX
      COMMON WCMAX,WCMIN,PAD,MOBRN,MOPARM,MOSTEP
      COMMON YTERMX,YTERM,IROOM,MATA,YB,YTERMB
      COMMON ZPRL,JX5
C\\\\\\\
C     CALL LOAD[33] 
C     CALL LOAD[34] 
      IF[JX4-1]10,20,30         
C 
C     OUTPUT WORST CASE         
C 
 20   WRITE[3,21]JX5,AX1,VNOM[JX5],SMLEP[JX5]       
   21 FORMAT[/1X,I2,3[4X,E15.8]]
   10 JX4=2 
   11 JX5=JX5+1       
      IF[JX5-NNODE]13,13,25     
   13 J=[JX5-1]/23+1  
      L = MOD[JX5-1, 23 ] + 1   
      M=IWCOUT[J]/[2**[L-1]]-[IWCOUT[J]/[2**L]]*2   
      IF[M]11,11,12   
   25 DO 26 I=1,NMAX  
      YX[I]=Y[I]      
      EX[I]=E[I]      
   26 AMPX[I]=AMP[I]  
      IF[NTERMS]15,16,15        
   15 DO 27 I=1,NTERMS
   27 YTERMX[I]=YTERM[I]        
   16 JX4=0 
      GO TO 996       
C 
C     SET VALUES FOR WORST CASE 
C 
 12   L = MOD[ JX5-1, 19 ] + 1  
      J1=3**[L-1]     
      J2=3**L         
      L = [JX5-1]/19 + 1        
      DO 71 ICHG=1,4  
      NUM=NMAX        
      IF[ICHG-2]62,60,62        
   60 IF[NTERMS]61,71,61        
   61 NUM=NTERMS      
   62 DO 69 I=1,NUM   
      GO TO [65,65,63,64],ICHG  
   63 IF[EMAX[I]-EMIN[I]]69,69,65         
   64 IF[AMPMAX[I]-AMPMIN[I]]69,69,65     
   65 K=MATA[I,ICHG,L]/J1-[MATA[I,ICHG,L]/J2]*3     
      IF[K-1]110,100,120        
  110 GO TO [101,102,103,104],ICHG        
  101 YX[I]=YMIN[I]   
      YB[I]=YMAX[I]   
      GO TO 69        
  102 J=ICOLT[I]      
      YTERMX[I]=YX[J]*YTERMH[I]/Y[J]      
      YTERMB[I]=YB[J]*YTERML[I]/Y[J]      
      GO TO 69        
  103 EX[I]=EMAX[I]   
      EB[I]=EMIN[I]   
      GO TO 69        
  104 AMPX[I]=AMPMAX[I]         
      AMPB[I]=AMPMIN[I]         
      GO TO 69        
  100 GO TO [201,202,203,204],ICHG        
  201 YX[I]=Y[I]      
      YB[I]=Y[I]      
      GO TO 69        
  202 J=ICOLT[I]      
      YTERMX[I]=YX[J]*YTERM[I]/Y[J]       
      YTERMB[I]=YB[J]*YTERM[I]/Y[J]       
      GO TO 69        
  203 EX[I]=E[I]      
      EB[I]=E[I]      
      GO TO 69        
  204 AMPX[I]=AMP[I]  
      AMPB[I]=AMP[I]  
      GO TO 69        
  120 GO TO [301,302,303,304],ICHG        
  301 YX[I]=YMAX[I]   
      YB[I]=YMIN[I]   
      GO TO 69        
  302 J=ICOLT[I]      
      YTERMX[I]=YX[J]*YTERML[I]/Y[J]      
      YTERMB[I]=YB[J]*YTERMH[I]/Y[J]      
      GO TO 69        
  303 EX[I]=EMIN[I]   
      EB[I]=EMAX[I]   
      GO TO 69        
  304 AMPX[I]=AMPMIN[I]         
      AMPB[I]=AMPMAX[I]         
   69 CONTINUE        
   71 CONTINUE        
      GO TO 996       
   30 JX4=1 
      AX1=SMLEP[JX5]  
      DO 550 I=1,NMAX 
      YX[I]=YB[I]     
      IF[EMAX[I]-EMIN[I]]500,500,510      
  510 EX[I]=EB[I]     
  500 IF[AMPMAX[I]-AMPMIN[I]]550,550,520  
  520 AMPX[I]=AMPB[I] 
  550 CONTINUE        
      IF[NTERMS]560,996,560     
  560 DO 501 I=1,NTERMS         
  501 YTERMX[I]=YTERMB[I]       
996   KSW=7 
       RETURN
      END   
       SUBROUTINE ECAP28
C 
C 
C  THIS IS COMMON FOR DC
C*\*\*\
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION PAD(50),IROOM(12)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION EB(60),AMPX(60),AMPB(60)VNOM(20),STDSQ(20)
      DIMENSION DUM1(78)
      DIMENSION SMLEP(20),CURR(60),SMLE(60),EQUCUR(20)
      DIMENSION EX(60)
      DIMENSION LANG(221)
      DIMENSION YX(60)
      DIMENSION MATA(60,4,3),YB(60),YTERMX(60),YTERMB(60)
      DIMENSION WCMAX(20),WCMIN(20),ZPRL(20,20)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON EB,AMPX,AMPB,VNOM,STDSQ,L,M,ITOL
      COMMON JX1,JX4,DUM1,IPAD41
      COMMON PAD1
      COMMON AX1,SMLEP,CURR,SMLE,EQUCUR
      COMMON EX
      COMMON LANG,IXOT
       COMMON ISEQ,ID1,MSEQ,ID2,MO,NUMMO,ID3,AD1,VFIRST,ID4,VSECND,VLAST
      COMMON YX
      COMMON WCMAX,WCMIN,PAD,MOBRN,MOPARM,MOSTEP
      COMMON YTERMX,YTERM,IROOM,MATA,YB,YTERMB
      COMMON ZPRL,JX5
C\\\\\\\
C 
C     CALCULATE PARTIALS        
C 
      DO 971 ICHG=1,4 
      KFIRST=1        
      NUM=NMAX        
      IF[ICHG-2]962,960,962     
  960 IF[NTERMS]961,971,961     
  961 NUM=NTERMS      
  962 DO 969 I=1,NUM  
 9500 GO TO [965,965,963,964],ICHG        
  963 IF[ABS[E[I]]+EMAX[I]-EMIN[I]]965,969,965      
  964 IF[ABS[AMP[I]]+AMPMAX[I]-AMPMIN[I] ]965,969,965         
  965 DO 33 J=L,M     
   33  CURR[J]=0.     
      GO TO[12,10,210,201],ICHG 
   12 TEMP1=YX[I]*YX[I]*SMLE[I] 
      II = I
      NT = 1
      GO TO 500       
  501 IF[NTERMS]110,851,110     
  110 J=1   
  111 IF[I-ICOLT[J]]502,120,502 
  120 II=IROWT[J]     
      TEMP1=YX[I]*YTERMX[J]*SMLE[I]       
      NT = 2
      GO TO 500       
  502 J=J+1 
      IF[J-NTERMS]111,111,851   
   10 II=  IROWT[I]   
      JJ = ICOLT[I]   
      TEMP1=-SMLE[JJ]*YX[JJ]    
      NT = 3
      GO TO 500       
  210 IF[ NTERMS ]215,19,215    
  215 J=1   
  216 IF[I-ICOLT[J]]504,225,504 
  225 II= IROWT[J]    
      TEMP1=-YTERMX[J]
      NT = 4
      GO TO 500       
  504 J=J+1 
      IF[J-NTERMS]216,216,19    
   19 II=I  
      TEMP1=-YX[I]    
      NT =3 
      GO TO 500       
  201 II = I
      TEMP1 = 1.0     
      NT = 3
 500  IF[ NINIT[II] ] 22, 24, 22
 22   NI = NINIT[II]  
      DO 23 N = L,M   
 23   CURR[N]=CURR[N]+ZPRL[N,NI]*TEMP1    
 24   IF[ NFIN[II] ] 25, 27, 25 
 25   NI = NFIN[II]   
      DO 26 N= L,M    
 26   CURR[N]=CURR[N]-ZPRL[N,NI]*TEMP1    
 27   GO TO [ 501,502,851,504],NT         
  851 IF[JX4]855,855,860        
  855 IF[NPRINT[7]]11,11,302    
   11 IF[ISEQ-1]858,302,858     
C 
C     OUTPUT PARTIALS 
C 
  302 IF[KFIRST]351,351,350     
  350 KFIRST=0        
      GO TO [90,91,92,93],ICHG  
   90 WRITE[3,190]    
  190 FORMAT[//55H PARTIAL DERIVATIVES AND SENSITIVITIES OF NODE VOLTAG
     1ES//,28H WITH RESPECT TO RESISTANCES/,
     2 7H BRANCH,3X,4HNODE,10X,8HPARTIALS,9X,13HSENSITIVITIES/]         
      GO TO 351       
   91 WRITE[3,191]    
  191 FORMAT[/22H WITH RESPECT TO BETAS/,
     1 5H BETA,5X,4HNODE,10X,8HPARTIALS,9X,13HSENSITIVITIES/] 
      GO TO 351       
   92 WRITE[3,192]    
  192 FORMAT[// 32H WITH RESPECT TO VOLTAGE SOURCES/,
     1 7H BRANCH,3X,4HNODE,10X,8HPARTIALS,9X,13HSENSITIVITIES/]         
      GO TO 351       
   93 WRITE[3,193]    
  193 FORMAT[/ 32H WITH RESPECT TO CURRENT SOURCES/,
     1 7H BRANCH,3X,4HNODE,10X,8HPARTIALS,9X,13HSENSITIVITIES/]         
  351 GO TO [990,991,992,993],ICHG        
  990 TEMP1=.01/Y[I]  
      GO TO 179       
  991 J=ICOLT[I]      
      TEMP1=0.01*YTERM[I]/Y[J]  
      GO TO 179       
  992 TEMP1 = 0.01 * E[ I ]     
      GO TO 179       
  993 TEMP1 = 0.01 * AMP[ I ]   
  179 DO 89 N=1,NNODE 
      IF(IGET1(ID1,N))891,89,891
891   TEMP=CURR[N]*ABS[TEMP1]   
      WRITE[3,181]I,N,CURR[N],TEMP        
89    CONTINUE
  181 FORMAT[/1X,I3,7X,I2,2X,2[5X,E15.8]]  
  858 IF[ISEQ-2]969,600,870     
C 
C     CALCULATE STANDARD DEVIATIONS       
C 
  870 GO TO [402,403,404,405],ICHG        
  402 TEMP1=1./YMIN[I]-1./YMAX[I]         
      GO TO 410       
  403 J=ICOLT[I]      
      TEMP1=YTERMH[I]/Y[J]   -YTERML[I]/Y[J]        
      GO TO 410       
  404 TEMP1=EMAX[I]-EMIN[I]     
      GO TO 410       
  405 TEMP1=AMPMAX[I]-AMPMIN[I] 
  410 TEMP1=TEMP1*TEMP1/36.0    
      DO 420 J=1,NNODE
      IF[ CURR[J]]421,420,421   
  421 STDSQ[J]=STDSQ[J]+ CURR[J]*CURR[J]*TEMP1      
  420 CONTINUE        
      IF[ISEQ-4]969,600,969     
C 
C     STORE SIGNS OF PARTIALS   
C 
  600 DO 610 J=1,NNODE
      IF[ CURR[J]]610,602,603   
  602 K=1   
      GO TO 609       
  603 K=2   
 609  MM= 3**[MOD[J-1,19]]      
      LL= [J-1]/19 + 1
      MATA[I,ICHG,LL]=MATA[I,ICHG,LL]+MM*K
  610 CONTINUE        
      GO TO 969       
C 
C     COMPARE SIGNS OF PARTIALS 
C 
 860  J = MOD[JX5-1,19] + 1     
      NJ = [JX5-1]/19 + 1       
      K=MATA[I,ICHG,NJ]/[3**[J-1]]-[MATA[I,ICHG,NJ]/[3**J]]*3+1         
       IF(K-1.) 700,69100,69100
69100 GO TO [700,969,702],K     
  700 IF[ CURR[JX5]]969,969,750 
  702 IF[ CURR[JX5]]750,969,969 
  750 GO TO [751,752,753,754],ICHG        
 751  NJ = 1HR
      GO TO 755       
 752  NJ = 1HT
      GO TO 755       
 753  NJ = 1HE
      GO TO 755       
 754  NJ = 1HI
  755 IF[JX4-1]756,756,757      
  757 WRITE[3,760]JX5,NJ,I      
  760 FORMAT[ / 1X,I2,2X,16HPARTIAL W.R.T.  ,A1,I3,2X,        
     1   23HHAS CHANGED SIGN AT MIN/]     
      GO TO 969       
  756 WRITE[3,761]JX5,NJ,I      
  761 FORMAT[ / 1X,I2,2X,16HPARTIAL W.R.T.  ,A1,I3,2X,        
     1   23HHAS CHANGED SIGN AT MAX/]     
  969 CONTINUE        
  971 CONTINUE        
       RETURN
      END   
       SUBROUTINE ECAP29
C  THIS IS COMMON FOR DC
C*\*\*\
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION PAD(50),IROOM(12)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION EB(60),AMPX(60),AMPB(60)VNOM(20),STDSQ(20)
      DIMENSION DUM1(78)
      DIMENSION SMLEP(20),CURR(60),SMLE(60),EQUCUR(20)
      DIMENSION EX(60)
      DIMENSION LANG(221)
      DIMENSION YX(60)
      DIMENSION MATA(60,4,3),YB(60),YTERMX(60),YTERMB(60)
      DIMENSION WCMAX(20),WCMIN(20),ZPRL(20,20)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON EB,AMPX,AMPB,VNOM,STDSQ,L,M,ITOL
      COMMON JX1,JX4,DUM1,IPAD41
      COMMON PAD1
      COMMON AX1,SMLEP,CURR,SMLE,EQUCUR
      COMMON EX
      COMMON LANG,IXOT
       COMMON ISEQ,ID1,MSEQ,ID2,MO,NUMMO,ID3,AD1,VFIRST,ID4,VSECND,VLAST
      COMMON YX
      COMMON WCMAX,WCMIN,PAD,MOBRN,MOPARM,MOSTEP
      COMMON YTERMX,YTERM,IROOM,MATA,YB,YTERMB
      COMMON ZPRL,JX5
C\\\\\\\
      WRITE[3,303]    
      WRITE[3,304]    
  303 FORMAT[//37H STANDARD DEVIATIONS OF NODE VOLTAGES  ]   
  304 FORMAT[/4HNODE,4X,9HSTD. DEV.,6X,14HNOM.-STD. DEV.,4X,7HNOMINAL, 
     1 7X,14HNOM.+STD. DEV./]  
      DO 305 I=1,NNODE
      TEMP=SQRT[STDSQ[I]]       
      TEMP1=SMLEP[I]-TEMP       
      TEMP2=SMLEP[I]+TEMP       
  305 WRITE[3,306]I,TEMP,TEMP1,SMLEP[I],TEMP2       
  306 FORMAT[/I2,1X,4[1X,E15.8]]
      KSW=6 
       RETURN
      END   
       SUBROUTINE ECAP30
C 
C 
C  THIS IS COMMON FOR DC
C*\*\*\
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION PAD(50),IROOM(12)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION EB(60),AMPX(60),AMPB(60)VNOM(20),STDSQ(20)
      DIMENSION DUM1(78)
      DIMENSION SMLEP(20),CURR(60),SMLE(60),EQUCUR(20)
      DIMENSION EX(60)
      DIMENSION LANG(221)
      DIMENSION YX(60)
      DIMENSION MATA(60,4,3),YB(60),YTERMX(60),YTERMB(60)
      DIMENSION WCMAX(20),WCMIN(20),ZPRL(20,20)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON EB,AMPX,AMPB,VNOM,STDSQ,L,M,ITOL
      COMMON JX1,JX4,DUM1,IPAD41
      COMMON PAD1
      COMMON AX1,SMLEP,CURR,SMLE,EQUCUR
      COMMON EX
      COMMON LANG,IXOT
       COMMON ISEQ,ID1,MSEQ,ID2,MO,NUMMO,ID3,AD1,VFIRST,ID4,VSECND,VLAST
      COMMON YX
      COMMON WCMAX,WCMIN,PAD,MOBRN,MOPARM,MOSTEP
      COMMON YTERMX,YTERM,IROOM,MATA,YB,YTERMB
      COMMON ZPRL,JX5
C\\\\\\\
C 
    3 GO TO [2,21,210],MO       
    2 ITOL = 0        
C 
C 
      DO 10 MA=1,NUMMO
      M=MA  
    7 N = MOBRN[M]    
      MM=IABS[MOPARM[M]]        
       GO TO [11,12,13,14],MM   
C 
C     R + G DATA      
C 
   11 IF[ MOPARM[M]]110,29,111  
  111 IF[MOSTEP[M]]503,501,503  
  501 YMAX[N] = 1.0/VSECND[M]   
      YMIN[N] = 1.0/VLAST[M]    
  503 Y[N]= 1.0/VFIRST[M]       
      YX[N]=Y[N]      
      GO TO 29        
  110 IF[MOSTEP[M]]508,506,508  
  506 YMAX[N] = VLAST[M]        
      YMIN[N] = VSECND[M]       
  508 Y[N]= VFIRST[M] 
      YX[N]=Y[N]      
      GO TO 29        
C 
C     BETA + GM DATA  
C 
   12 IF[ MOPARM[M]]112,29,113  
  112 IF[MOSTEP[M]]602,601,602  
  601 YTERML[N] = VSECND[M]     
      YTERMH[N] = VLAST[M]      
  602 YTERM[N]=VFIRST[M]        
      YTERMX[N]=YTERM[N]        
      GO TO 29        
  113 II = ICOLT[N]   
      IF[MOSTEP[M]] 606,604,606 
  604 YTERML[N] = VSECND[M]*Y[II]         
      YTERMH[N] = VLAST[M]*Y[II]
  606 YTERM[N]=VFIRST[M]*Y[II]  
      YTERMX[N]=YTERM[N]        
      GO TO 29        
C     E DATA
   13 IF[MOSTEP[M]]703,701,703  
  701 EMIN[N] = VSECND[M]       
      EMAX[N] = VLAST[M]        
  703 E[N]=VFIRST[M]  
      EX[N]=E[N]      
      GO TO 29        
C     I DATA
   14 IF[MOSTEP[M]]803,801,803  
  801 AMPMIN[N] = VSECND[M]     
      AMPMAX[N] = VLAST[M]      
  803 AMP[N]=VFIRST[M]
      AMPX[N]=AMP[N]  
   29 IF[MO-2]99,9996,9996      
   99 IF[MOSTEP[M]]6,10,6       
    6 ITOL = M        
   10 CONTINUE        
      IF[ITOL]850,850,851       
  850 NUMMO=0         
      GO TO 9996      
  851 MO=2  
      GO TO 9996      
C     CHECK FOR ITERATED PARAMETER        
   21 MO=3  
      DELTA = [VLAST[ITOL]-VFIRST[ITOL]]/VSECND[ITOL]         
  210 VFIRST[ITOL] = VFIRST[ITOL]+DELTA   
   24 IF[VLAST[ITOL]-VFIRST[ITOL]]38,38,39
   38 NUMMO=0         
   39 M = ITOL        
      GO TO 7         
9996  CALL ECAP31
       RETURN
      END   
       SUBROUTINE ECAP31
C 
C  THIS IS COMMON FOR DC
C*\*\*\
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION PAD(50),IROOM(12)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION EB(60),AMPX(60),AMPB(60)VNOM(20),STDSQ(20)
      DIMENSION DUM1(78)
      DIMENSION SMLEP(20),CURR(60),SMLE(60),EQUCUR(20)
      DIMENSION EX(60)
      DIMENSION LANG(221)
      DIMENSION YX(60)
      DIMENSION MATA(60,4,3),YB(60),YTERMX(60),YTERMB(60)
      DIMENSION WCMAX(20),WCMIN(20),ZPRL(20,20)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON EB,AMPX,AMPB,VNOM,STDSQ,L,M,ITOL
      COMMON JX1,JX4,DUM1,IPAD41
      COMMON PAD1
      COMMON AX1,SMLEP,CURR,SMLE,EQUCUR
      COMMON EX
      COMMON LANG,IXOT
       COMMON ISEQ,ID1,MSEQ,ID2,MO,NUMMO,ID3,AD1,VFIRST,ID4,VSECND,VLAST
      COMMON YX
      COMMON WCMAX,WCMIN,PAD,MOBRN,MOPARM,MOSTEP
      COMMON YTERMX,YTERM,IROOM,MATA,YB,YTERMB
      COMMON ZPRL,JX5
C\\\\\\\
C 
       MART1= 1H  
    4 IF[ITOL]55,9996,55        
 55   IF[NPRINT[1]+NPRINT[2]+NPRINT[3]+NPRINT[4]+NPRINT[5]+NPRINT[6]+   
     1NPRINT[10]]511,9996,511   
 511  LL = IABS[MOPARM[ITOL]]   
      GO TO [ 500, 501, 502, 503 ], LL    
 500  IF[ MOPARM[ITOL] ] 505, 505, 504    
  501 IF[MOPARM[ITOL]]506,505,507         
 505  MART = 2HG  
      GO TO 510       
 504  MART = 2HR  
      GO TO 510       
 506  MART = 2HGM
      GO TO 510       
 507  MART = 2HBE
       MART1=2HTA
      GO TO 510       
 502  MART = 1HE
      GO TO 510       
 503  MART = 1HI
 510  WRITE[3,525] MART,MART1,VFIRST[ITOL]      
  525 FORMAT[///1X,A2,A2,2H =,E16.8]
9996  CALL ECAP22
       RETURN
      END   
       SUBROUTINE ECAP63 ( X,IRTN1,IA )
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
       DIMENSION X(1)
      DIMENSION PAD(50),IROOM(12)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION EB(60),AMPX(60),AMPB(60)VNOM(20),STDSQ(20)
      DIMENSION DUM1(78)
      DIMENSION SMLEP(20),CURR(60),SMLE(60),EQUCUR(20)
      DIMENSION EX(60)
      DIMENSION LANG(221)
      DIMENSION YX(60)
      DIMENSION MATA(60,4,3),YB(60),YTERMX(60),YTERMB(60)
      DIMENSION WCMAX(20),WCMIN(20),ZPRL(20,20)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON EB,AMPX,AMPB,VNOM,STDSQ,L,M,ITOL
      COMMON JX1,JX4,DUM1,IPAD41
      COMMON PAD1
      COMMON AX1,SMLEP,CURR,SMLE,EQUCUR
      COMMON EX
      COMMON LANG,IXOT
       COMMON ISEQ,ID1,MSEQ,ID2,MO,NUMMO,ID3,AD1,VFIRST,ID4,VSECND,VLAST
      COMMON YX
      COMMON WCMAX,WCMIN,PAD,MOBRN,MOPARM,MOSTEP
      COMMON YTERMX,YTERM,IROOM,MATA,YB,YTERMB
      COMMON ZPRL,JX5
C\\\\\\\
C
       DO 10 I=IA*6+15,IA*6+20
       IF(NPRINT(I))11,10,11
11     K=1
C
C  THE FOLLOWING TWO LINES OF CODE REPLACES THE FOUR LINES OF
C  CODE FOLLOWING IT TO PREVENT OUTPUT GOING TO THE WRONG PLACE
C
       IF(NPRINT(16)+NPRINT(17)) 12,10,12
12     WRITE(3,100) NPRINT(I),X(NPRINT(I))
C       IF(NPRINT(16))12,13,12
C12     WRITE [3,100] NPRINT(I),X(NPRINT(I))
C13     IF(NPRINT(17))14,10,14
C14     WRITE [1,100] NPRINT(I),X(NPRINT(I))
10     CONTINUE
       IF(K)16,15,16
15     RETURN
16     K=0
       GO TO IRTN1
100    FORMAT(/,I2,$ =$,E14.8)
       END
       SUBROUTINE ECA100 ( IFORM1,JX3 )
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION PAD(50),IROOM(12)
      DIMENSION NPRINT(60)
      DIMENSION E(60),EMIN(60),EMAX(60),AMP(60),AMPMIN(60),AMPMAX(60)
      DIMENSION Y(60),YMIN(60),YMAX(60),NINIT(60),NFIN(60),MODE1(60)
      DIMENSION YTERM(60),YTERMH(10),YTERML(10),IROWT(10),ICOLT(10)
      DIMENSION MOBRN(20),MOPARM(20),MOSTEP(20),IWCOUT(4)
      DIMENSION VFIRST(20),VSECND(20),VLAST(20)
      DIMENSION EB(60),AMPX(60),AMPB(60)VNOM(20),STDSQ(20)
      DIMENSION DUM1(78)
      DIMENSION SMLEP(20),CURR(60),SMLE(60),EQUCUR(20)
      DIMENSION EX(60)
      DIMENSION LANG(221)
      DIMENSION YX(60)
      DIMENSION MATA(60,4,3),YB(60),YTERMX(60),YTERMB(60)
      DIMENSION WCMAX(20),WCMIN(20),ZPRL(20,20)
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON EB,AMPX,AMPB,VNOM,STDSQ,L,M,ITOL
      COMMON JX1,JX4,DUM1,IPAD41
      COMMON PAD1
      COMMON AX1,SMLEP,CURR,SMLE,EQUCUR
      COMMON EX
      COMMON LANG,IXOT
       COMMON ISEQ,ID1,MSEQ,ID2,MO,NUMMO,ID3,AD1,VFIRST,ID4,VSECND,VLAST
      COMMON YX
      COMMON WCMAX,WCMIN,PAD,MOBRN,MOPARM,MOSTEP
      COMMON YTERMX,YTERM,IROOM,MATA,YB,YTERMB
      COMMON ZPRL,JX5
       ASSIGN 1 TO IFORMT
       IFORMT=IFORM1
       DO 20 I=JX3*6+15,JX3*6+20
       IF(NPRINT(I))21,20,21
20     CONTINUE
200    IF(NPRINT(16)+NPRINT(17))1,4,1
1      WRITE 3,IFORMT
C
C  THE ABOVE 2 LINES OF CODE REPLACES THE 4 LINES
C  OF CODE BELOW TO CORRECT OUTPUT GOING TO THE WRONG PLACE
C
C200    IF(NPRINT(16))1,2,1
C1      WRITE 3,IFORMT
C2      IF(NPRINT(17))3,4,3
C3      WRITE 1,IFORMT
4      RETURN
21     GO TO (10,11,12,13,14,15),JX3
10     ASSIGN 100 TO IFORMT
       GO TO 200
100    FORMAT(//$NO     NO VOL$)
11     ASSIGN 110 TO IFORMT
       GO TO 200
110    FORMAT(//$BR     EL CUR$)
12     ASSIGN 120 TO IFORMT
       GO TO 200
120    FORMAT(//$BR     EL VOL$)
13     ASSIGN 130 TO IFORMT
       GO TO 200
130    FORMAT(//$BR     BR CUR$)
14     ASSIGN 140 TO IFORMT
       GO TO 200
140    FORMAT(//$BR     BR VOL$)
15     ASSIGN 150 TO IFORMT
       GO TO 200
150    FORMAT(//$BR     EL PWR$)
       END
ECAP ** FICHE/FRAME BREAK *****
ECFINLSYM
C-FINLS    VER.6  ECAP INPUT LANGUAGE             -T.FLORYAN
C
C  FORTRAN SECTION OF THE INPUT LANGUAGE
C
C
C  THE FOLLOWING ROUTINE TRANSFERS CONTROL TO THE ECAP ARPAS
C  INPUT LANGUAGE.  THE DIMENSION, COMMON AND EQUIVALENCE
C  STATEMENTS ARE NEEDED SO AS TO BE ABLE TO DETERMINE THE
C  AMOUNT OF UNUSED CORE AVAILABLE DURING LOADING BY FOS
C
C
      DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION JAKE[50]
      DIMENSION LIST4[60],LABEL[60],LISTE[5],LISTI[5],NUME[5],NUMI[5]
      DIMENSION LINK1D[60],LINK1E[60]
      DIMENSION NPRINT[60]
      DIMENSION E[60],EMIN[60],EMAX[60],AMP[60],AMPMIN[60],AMPMAX[60]
      DIMENSION Y[60],YMIN[60],YMAX[60],NINIT[60],NFIN[60],MODE1[60]
      DIMENSION YTERM[60],YTERMH[10],YTERML[10],IROWT[10],ICOLT[10]
      DIMENSION VFIRST[20],VSECND[20],VLAST[20]
      DIMENSION MOBRN[20],MOPARM[20],MOSTEP[20],IWCOUT[4]
      DIMENSION FLM[50]
      DIMENSION EPHA[60]
      DIMENSION AMPPHA[60],ETIME[5,2],ATIME[5,2]
      DIMENSION ETR[5,50],AMPTR[5,50]
      DIMENSION NWORDS[72],NMCD[2,8],KLABEL[4],KPUNC[5],INDC[2,20]
      DIMENSION INPUTB[9],NBCD[20],KTYPE[5]
      DIMENSION KOUT[2,10]
      DIMENSION IROWM[20],ICOLM[20],FLML[10],FLMH[10]
      COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
      COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON NMAX,NNODE,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON E,EMIN,EMAX,AMP,AMPMIN,AMPMAX
      COMMON Y,YMIN,YMAX,NINIT,NFIN,MODE1
      COMMON YTERMH,YTERML,IROWT,ICOLT
      COMMON ERROR1
      COMMON IWCOUT,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3,ETIME,ATIME
      COMMON ETR,AMPTR
      COMMON NWORDS,NMCD,KLABEL,KPUNC,INDC
      COMMON INPUTB,NBCD,KTYPE,NBLANK,NOEXEC,ITOL,NEQUIM,IPC
      COMMON INVAL,LL,ICOL,LTYPE,KCOL,NQUIT,ITRANS,KO,KS,KELAST,NUM,M1
      COMMON M2,M3,KCARD,KG,NP,MAC,HNODE,TNUM,NOEL,NOE,NOI,NOIC
      COMMON KOUT
      COMMON ISEQ,ID1,MSEQ,ID2,MO,NUMMO,ID3,OPEN,VFIRST,ID5,VSECND
      COMMON VLAST,EPHA,IROWM,ICOLM,FLML,FLMH
      COMMON FLM,MOBRN,MOPARM,MOSTEP,AMPPHA,YTERM
      EQUIVALENCE [ISEQ,START],[MSEQ,FINISH],[NUMMO,SHORT],
     1 [VSECND[11],LABEL[1]],[YTERM[31],LIST4[1]],[IWCOUT[2],KE],
     2 [IWCOUT[4],NOSW],[FLM[26],JAKE[1]],[JAKE[31],NUMI[1]],
     3 [JAKE[36],NUME[1]],[JAKE[41],LISTI[1]],[JAKE[46],LISTE[1]],
     4 [EPHA[1],LINK1D[1]],[AMPPHA[31],LINK1E[1]],(IWCOUT(3),KI)
      CALL INLANG
      END
ECAP ** FICHE/FRAME BREAK *****
ECINLTXTSYM
[HLPMSG]

VALID COMMANDS ARE:

EDIT RANGE     RETYPES THE LINE RANGE AND ALLOWS AN EDIT.

INSERT RANGE   ALLOWS NEW LINE(S) TO BE INSERTED BEFORE THE "RANGE".
               TERMINATE THE INSERT MODE WITH A CONTROL-D.

DELETE RANGE   DELETES LINE(S) ADDRESSED BY "RANGE".

LIST           TYPES OUT THE CURRENT TEXT BLOCK.

LIST RANGE     TYPES OUT LINE(S) ADDRESSED BY "RANGE".

GO             CONTINUES AFTER A PAUSE.

QUIT           RETURNS TO THE STANDARD FRONT END.

END            RETURNS TO THE EXECUTIVE.

HELP           REPRINTS THIS LIST.


^
ECAP ** FICHE/FRAME BREAK *****
ECINLTXTSYM
[HLPMSG]

VALID COMMANDS ARE:

EDIT RANGE     RETYPES THE LINE RANGE AND ALLOWS AN EDIT.

INSERT RANGE   ALLOWS NEW LINE(S) TO BE INSERTED BEFORE THE "RANGE".
               TERMINATE THE INSERT MODE WITH A CONTROL-D.

DELETE RANGE   DELETES LINE(S) ADDRESSED BY "RANGE".

LIST           TYPES OUT THE CURRENT TEXT BLOCK.

LIST RANGE     TYPES OUT LINE(S) ADDRESSED BY "RANGE".

GO             CONTINUES AFTER A PAUSE.

QUIT           RETURNS TO THE STANDARD FRONT END.

END            RETURNS TO THE EXECUTIVE.

HELP           REPRINTS THIS LIST.


^
ECAP ** FICHE/FRAME BREAK *****
ECINTSYM
INIT   IDENT   VER.6-ECAP LINK NAME LOADER    T.FLORYAN
*
*
*  PUTS ECAP LINK NAMES IN COMMON AND RETAINS THE LOCATIONS AS STRING
*  POINTERS, WHICH ARE ALSO KEPT IN COMMON
*
*  INSTRUCTIONS FOR OPERATION ARE TYPED AT THE TERMINAL
*
*  THIS ROUTINE IS CALLED ONLY ONCE AFTER THE CALLING ROUTINE HAS
*  BEEN SAVED AS AN FOS "GO" FILE
*
$INIT  ZRO  RTN
       LDB =VERMSG; BRM MSG; LDA =73B; CAB VERSION NUMBER STORED AT 24B
       STP VERPTR; BRU *+2; WCI VERPTR; CIO 1004B; SKG =77B; BRU *-3
       LDX 402B; STX INIT; EAX* 0,2; CXA; ETR =37777B; STA PTR; ADD PTR
       ADD PTR; SUB 415B; CAB; STP PTR; LDX NEGNOF
NEXT   LDB MSG,2; BRM MSG; MIN INIT
CHARIN CIO 1004B; SKG =77B; BRU WRITE; SKE =141B; BRU TCQ; TCO =77B
       GCD PTR; BRU ERR; BRU CHARIN
TCQ    SKE =161B; BRU TCR; TCO =76B; TCO =155B; LDA PTR; STA PTR+1
       BRU CHARIN
TCR    SKE =155B; BRU CHARIN; LDP PTR; STP* INIT; STB PTR; BRX NEXT
SAVE   LDB =MSAVE; BRM MSG; LDA 1004B; LDX 415B; BRS 63; BRU ERR1
       STA F; CLA; WIO F; LDA =37777B; WIO F
       LDA =75B; WIO F; LDA COMMER; STA 75B; STA 76B; LDA BRUER; STA 77B
       LDA =4B4; CLX; BIO F; NOP; LDA F; BRS 20; LDB =EOJ; BRM MSG; BRS 10
WRITE  WCI PTR; BRU CHARIN
ERR    SKR INIT; NOP; BRU NEXT
ERR1   LDB =CNTOPN; BRM MSG; BRU SAVE
COMMER STA 1004B
BRUER BRU 36445B  FOS START
F      ZRO
PTR    BSS 2
NEGNOF DATA -8                 -(NO. OF LINK FILES)
RTN    ZRO
TX     ZRO
VERPTR EQU  22B    VERSION NUMBER STRING POINTERS
VERMSG ASC '$VERSION NUMBER: /'
M1     ASC '$ENTER LINK NAMES(12 CHAR.MAX)(CTRL-A,-Q EDITING)$$'
       ASC 'SFE LINK: /'
M2     ASC '$ DC LANG: /'
M3     ASC '$ DC COMP: /'
M4     ASC '$ AC LANG: /'
M5     ASC '$AC1 COMP: /'
M6     ASC '$AC2 COMP: /'
M7     ASC '$ TR LANG: /'
M8     ASC '$ TR COMP: /'
MSAVE  ASC '$SAVE ON: /'
EOJ    ASC '$$EOJ$$/'
CNTOPN ASC 'CANNOT OPEN FILE$/'
       DATA M1,M2,M3,M4,M5,M6,M7,M8
MSG    ZRO
       STX TX; LDA 1004B; SKE 414B; BRR MSG; CBA; LDB 420B; LDX 415B
       BRS 34; LDX TX; BRR MSG
       END
ECAP ** FICHE/FRAME BREAK *****
ECLIBSYM
*    E C A P   V E R S I O N   6   L I B R A R Y   S Y M B O L I C S
*
*
*  NOTE:  CODING FOR SIN(COS) WAS CHANGED BY THAD FLORYAN
*         IN ORDER TO MAKE IT WORK !!!!
*
*
*      ABS
*      IABS
*      MOD
*      SQRT
*      POWER
*      SIN
*      ALOG
*      EXP
*      ATAN
*      IGET1
*      SWSEE
*      LINK
*      INTRP
*      ALTBRU
*      SLINK2
*      NOTIFY
*      TRMOD
*
*
*
*
*
*
*


ABS    IDENT
LDF    OPD     125B5,1,1
$ABS   ZRO     RTN
       LDF*    EOIND
       SKA     =4B7
       BRS     21
       BRR     RTN
EOIND  EQU     402B
RTN    ZRO
       END




IABS   IDENT
$IABS  ZRO     RTN
       LDA*    EOIND
       SKA     =4B7
       CNA
       BRR     RTN
EOIND  EQU     402B
RTN    ZRO
       END




MOD    IDENT
XDV    OPD     144B5,1,1
$MOD   ZRO     RTN
       STX     TX
       LDX     EOADR
       LDA*    0,2
       XDV*    1,2
       XAB
       LDX     TX
       BRR     RTN
TX     ZRO
RTN    ZRO
EOADR  EQU     400B
       END




SQRT   IDENT         SQRT - FLOATING POINT SQUARE ROOT ROUTINE
*
$SQRT  ZRO     RETURN
       STX     TX
       EAX*    E0IND
       LDA     1,2
       LDB     0,2
       SKA     =-1             EXIT IF ZERO ARG
       BRU     *+3
       LDX     TX
       BRR     RETURN
       STA     LIB1
       STB     LIB2
       SKN     LIB1           TEST ARG NEG
       BRU     ARGPOS       NO
       SBRM*   ERROR
       BRU     SQRT7
       ASC     ' SQUARE ROOT OF A NEGATIVE NUMBER ATTEMPTED/'
SQRT7  LDP     LIB1           
       FMP     C4              YES - MAKE POSITIVE
       STP     LIB1
ARGPOS XAB 
       LCY     4
       ETR     =00000023B 
       STA     LIB6
       LDX     LIB6 
       LDA     LIB1
       MUL     C3,2            PERFORM CUBIC FIT
       ADD     C2,2
       MUL     LIB1 
       ADD     C1,2
       MUL     LIB1
       ADD     C0,2 
       STA     LIB4          LIB4 = ROOT
       LDA    LIB2 
       ETR     =00000777B
       SKA     =00000400B
       MRG     =00001000B
       ADD     =1           AE + 1
       RSH     1 
       STA     LIB6          SAVE EXPON
       STB     LIB5
       LDA     LIB1
       LDB     LIB2
       SKN     LIB5
       RSH     1
       RSH     2
       DIV     LIB4          AH,AL/ROOT
       STA     LIB3
       BAC 
       DIV     LIB4          REMAINDER/ROOT
       LCY     1 
       ETR     =77777000B
       MRG     LIB6          INSERT EXPON
       XAB
       ETR     =1
       SKA     =1           TEST NEG
       MRG     =-1
       ADD     LIB4
       ADD     LIB3
       LDX     TX
       BRR     RETURN
*
C0     DATA    3571347B     C40
       DATA    4105632B     C41
       DATA    4377337B     C42
       DATA    4653532B     C43
C1     DATA    24035556B     C50
       DATA    22100301B     C51
       DATA    20524702B     C52
       DATA    17404074B     C53
C2     DATA    64040313B     C60
       DATA    67137522B       C61
       DATA    71114033B     C62
       DATA    72364432B     C63
C3     DATA    4201570B     C70
       DATA    2442454B     C71
       DATA    1540204B     C72
       DATA    1133522B     C73
       DATA    2511007B     C00
       DATA    2731406B     C01
       DATA    3134614B     C02
       DATA    3326443B     C03
       DATA    16135622B     C10
       DATA    14642160B     C11
       DATA    13621520B       C12
       DATA    12756406B     C13
       DATA    67436343B     C20
       DATA    71611227B     C21
       DATA    73117403B     C22
       DATA    74060542B     C23
       DATA    3003710B       C30
       DATA    1641433B      C31
       DATA    1143077B     C32
       DATA    652664B     C33
C4     DATA    40000000B
       DATA    00000000B
*
TX     BSS     1
RETURN BSS     1
LIB1   BSS     1
LIB2   BSS     1
LIB3   BSS     1
LIB4   BSS     1
LIB5   BSS     1
LIB6   BSS     1
E0IND  EQU     402B
ERROR  EQU     413B
       END




POWER  IDENT         SYSTEM SUBROUTINE
*
XMP    OPD     14000000B,1,1
STD    OPD     10700000B,1,1
FLM    OPD     14100000B,1,1
FFA    OPD     11500000B,1,1
FLN    OPD     14700000B,2
LDP    OPD     12500000B,1,1
FLA    OPD     13100000B,1,1
FLS    OPD     13500000B,1,1
$240SYS ZRO    RTN                SAVE SBRM MARKER
       STX     TX                SAVE INDEX
       LDX     E0ADR
       LDA*    1,2                 SECOND ARG INTO A
       LDB*    E0ADR               FIRST ARG MODE INDIC.
       SKB     FLTIND              TEST 1ST ARG INTEGER
       BRU     FLT
       LDB*    E0IND               I INTO A
       SKG     ZERO                TEST N>0
       BRU     NZERO
NPOSS   CNA                         NEGATE N
       RCH     410B
       BRU     MULT
       XMP*    E0IND               MULTIPLY R BY I
MULT   BRX     *-1               TEST IF (N-1) MULTS
EXIT   LDX     TX                REPLACE INDEX
       BRR     RTN
NZERO  SKA     ONES                TEST N=0
       BRU     NNEG
       LDA     ONE                 R=1
       SKB     ONES                TEST I=0
       BRU     EXIT              EXIT: I**0
       BRU     ERROR             ERROR: 0**0
NNEG   RCH     412B                N TO X, 0 TO B, R = I
IM1    SKE     ONES                TEST I=-1
       BRU     I1
       BRU     MULT              (-1) ** (-N)
I1     SKE     ONE                 TEST I = 1
       BRU     IZERO
       BRU     EXIT              EXIT: I**(-N)
IZERO  XAB                         R=0, I INTO B
       SKB     ONES                TEST I = 0
       BRU     EXIT              EXIT: I ** (-N)
       LDA     MAX               R = MAXIMUM INTEGER
       BRU     ERROR             ERROR: 0 ** (-N)
FLT    LDX     1,2
       LDB     1,2                 QH INTO B
       LDX*    E0ADR
       SKB     TWOH              TEST QH FOR 2.0
       BRU     NOT2
       SKE     TWOL              TEST QL FRO 2.0
       BRU     NOT2
       LDA     1,2                 PH INTO A
       LDB     0,2                 PL INTO B
       FLM*    E0IND               MULTIPLY BY P
       BRU     EXIT              EXIT: P ** 2
NOT2   STB     QTEMP+1           SAVE QH
       STA     QTEMP             SAVE QL
       LDA     1,2                 PH INTO A
       SKG     ZERO                TEST P > 0.0
       BRU     PZERO
       LDB     0,2                 PL INTO B
LOGP   STD     PTEMP
       FFA     PTEMP
       SBRM    ALOG              LOG OF P
       FLM     QTEMP             MULTIPLY BY Q
       STD     PTEMP
       FFA     PTEMP
       SBRM    EXP                 R=EXP(Q*LOG((P))
       BRX     NEGR
       BRU     EXIT              EXIT: P ** Q
NEGR   FLN                         NEGATE RESULT
       BRU     EXIT              (-P) ** (ODD INTEGER)
PZERO  SKE     ZERO                TEST P = 0.0
       BRU     PNEG
       SKB     FLONE+1           TEST 0 NEG OR ZERO
       BRU     QPOS
       SKB     ONES                TEST Q = 0.0
       LDP     MAXFL             R = MAXIMUM FLOATING
       FLA     FLONE             R = MAX OR 1.0
ERROR   SBRM*   RTERR               ERROR: 0**(0 OR NEG)
       BRU     EXIT               EXIT
       ASC     ' ZERO RAISED TO A NONPOSITIVE POWER/'
QPOS   CAB                         R = 0.0
       BRU     EXIT              EXIT: 0.0 ** Q
PNEG   LDP     QTEMP             Q INTO A,B
        SBRM*   FIXL                TRUNCATE Q TO INTEGER
       STA     TRUNQ
       SBRM*   FLOATL              RECONVERT TO FLOATING
       FLS     QTEMP
       SKA     ONES                TEST Q=INTEGER
       BRU     ERNEG
       LDA     1,2                 PH INTO A
       LDB     TRUNQ
       SKB     ONE                 TEST Q EVEN
       LDX     NEGX
       LDB*    E0IND               PL INTO B
NEGP   FLN
       BRU     LOGP
ERNEG  LDP*    E0IND               P INTO A,B
       SBRM*   RTERR               ERROR: (-P) **Q
       BRU     NEGP
       ASC     ' NEGATIVE NUMBER RAISED TO A NONINTEGRAL POWER/'
NEGX   DATA    40000B
TWOL   DATA    00000002B
TWOH   DATA    57777777B
FLONE  DATA    1B
       DATA    20000000B
MAXFL  DATA    77777377B
MAX    DATA    37777777B
TX     BSS     1
TRUNQ  BSS     1
PTEMP  BSS     1
       BSS     1
QTEMP  BSS     1
       BSS     1
ZERO   EQU    414B
ONE    EQU    415B
SIGN   EQU    417B
ONES   EQU    420B
E0ADR  EQU    400B
E0IND  EQU    402B
FLTIND EQU     405B
FIXL   EQU     231B
FLOATL EQU     232B
RTERR  EQU    413B
RTN    ZRO     0
       END




*  SIN(COS)  - FLOATING POINT SINE
*
*
*
SIN    IDENT

$COS   ZRO     RETURN
       STX     TX
       EAX*    EOIND
       LDA     1,2
       LDB     0,2
       FAD     C1
       BRU     SNFA


$SIN   ZRO     RETURN
       STX     TX
       EAX*    EOIND
       LDA     1,2
       LDB     0,2
SNFA   STB     LIB1
       RCY     9
       RSH     15           SIGN-EXTENDED EXPONENT TO A
       SKG     =-13         CHECK FOR SMALL ANGLE
       BRU     SNFX         RESTORE REGISTERS AND EXIT
       LDA     =-1 
       STA     LIB5          INITIALIZE LIB5
       BAC 
       LDB     LIB1         RESTORE REGISTERS
       FMP     SNF2         2/PI. CONVERT ARGUMENT TO QUADRANT
       STP     LIB1         MEASURE
       FAD    SNF3    EXTRACT NO. SEMICIRCLES (2*QUADRAN
       XAB   
       SKA     SNF5            ROUND TO NEAREST SEMICERCLE
       BRU     *+2
       BRU     SNFC    1ST OR 3RD. ALREADY ROUNDED
       ADD     SNF4+1          2ND OR 4TH
       XAB
       ADC     SNF4
       SKA     SNF6         IF ARGUMENT NEGATIVES
       BRU     *+3             SUBTRACT 1 (2 TO COMPENSATE FOR ADD)
       XAB
       BRU     SNFC
       XAB     
       SUB     SNF7+1
       XAB
       SUC     SNF7
       XAB
* 
SNFC   SKA     SNF8         SET LIB5 IF 2ND OR 3RD QUADRANT
       MIN     LIB5 
       XAB 
       FSB     SNF3         FLOAT RESULT (ARG ROUNDED TO 
*                            NEAREST SEMICIRCLE
       FSB     LIB1         REDUCED ARGUMENT
       SKN     LIB5 
       BRU     *+2          2ND OR 3RD
       FMP     SNF6            1ST OR 4TH
       STP     LIB1
       FMP      LIB1
       STP     LIB3
       FMP     C15          POYNOMIAL APPROXIMATION
       FAD     C13
       FMP     LIB3
       FAD     C11 
       FMP     LIB3
       FAD     C9
       FMP     LIB3
       FAD     C7
       FMP     LIB3
       FAD     C5
       FMP     LIB3
       FAD     C3
       FMP     LIB3
       FAD     C1
       FMP     LIB1
SNFR   LDX     TX
       BRR     RETURN
*
SNFX   BAC                  SMALL ARGUMENT, RESTORE REGISTERS
       LDB     LIB1
       BRU     SNFR
*
SNF2   DATA    24276301B       2/PI
       DATA    55624000B
SNF3   DATA    30000000B
       DATA    00000046B
SNF4   DATA    0
SNF5   DATA    01000B
SNF6   DATA  4B7    ******* CHANGED BY THAD FLORYAN
SNF7   DATA    0
SNF8   DATA    00002000B
*
C1     DATA    31103755B       PI/2
       DATA    24210001B
C3     DATA    53250414B       -((PI/2)**3)/3
       DATA    31665000B
C5     DATA    24315361B       ((PI/2)**5)/5
       DATA    47353775B
C7     DATA    54645514B       -((PI/2)**7)/7
       DATA    61472771B
C9     DATA    25017015B       ((PI/2)**9)/9
       DATA    10375764B  ******* CHANGED BY THAD FLORYAN
C11    DATA    41637054B       -((PI/2)**11)/11
      DATA    02057756B
C13    DATA    36436415B       ((PI/2)**13)/13
       DATA    14733750B
C15    DATA    51027632B       -((PI/2)**15)/15
       DATA    52021742B
*
TX     BSS     1
LIB1   BSS     2
LIB3   BSS     2
LIB5   BSS     1
RETURN BSS     1
EOIND  EQU     402B
       END




ALOG   IDENT   FLOATING POINT LOGARITHM
ELOG  EXT      0
$ALOG  ZRO     RETURN
       STX     TX
       EAX*    E0IND
       LDA     1,2
       LDB     0,2
       SKG    =0             IS ARGUMENT LESS THAN OR EQUAL TO
       BRU     ERR1         YES, ERROR EXIT
       STP     LIB1 
       LDA     LIB2
       ETR     =77777000B
       STA     LIB2            SAVE FRACTIONAL PART
       LSH     39           MOVE EXP TO LEFT PART OF A
       SUB     =00040000B       I=2-I/2
       ROV
        LDX     =8
       NOD     8               NORMALIZE INTEGER PART
       STA     LIB3 
       STX     LIB4          SAVE INTEGER PART
       LDP     LIB1
       FAD     LG1
       STP     LIB5         (X+LSQ2)
       FSB     LG2     (X-1/SQ2)
       FDV    LIB5 
       STP     LIB5         Y=(X-L/SQ2)/(X+1/SQ2)
       FMP     LIB5   
       STP    LIB7         (Y**2)
       FMP     C7      C7*(YSQ)
       FAD     C5           C5+C7*(YSQ)
       FMP     LIB7         (C5+C7*(YSQ))YSQ
       FAD     C3           C3+(C5+C7*(YSQ))YSQ
       FMP     LIB7         (C3+(C5+C7*(YSQ))YSQ)YSQ
       FAD     C1           (C1+(C3+(C5+C7(YSQ)YSQ)YSQ))
       FMP    LIB5         (CL+(C3+(C5+C7(YSQ)YSQ)YSQ)Y)
       FAD    LIB3         I+LOG(FRAC.PART)
       FMP     LN2          (I+LOG F)*LN2 = LN(X)
       LDX     TX
       BRR     RETURN
*
ERR1   SBRM*   ERROR           RETURN 0
       BRU     ERR3
       ASC     ' LOG FUNCTION HAS A NON-POSITIVE ARGUMENT /'
ERR3   CLAB
       LDX     TX
       BRR     RETURN
*
*
LG1    DATA    26501171B     .707106781187
       DATA    46377000B 
LG2    DATA    26501171B       1.414213562374 = SQ2
       DATA    46377001B
C1     DATA    27052435B
       DATA    43752002B
C3     DATA    36616111B
       DATA    44322000B
C5     DATA    22346604B
       DATA    01441000B
C7     DATA   33625645B
       DATA    51342777B
LN2    DATA    26134413B     .693147180578
       DATA    76771000B
*
TX     BSS     1
RETURN BSS     1
LIB1   BSS     1
LIB2   BSS     1
LIB3   BSS     1
LIB4   BSS     1
LIB5   BSS     2
LIB7   BSS     2
*
E0IND  EQU     0402B
ERROR  EQU     0413B
       END




EXP    IDENT          FLOATING POINT EXPONENTIAL
$EXP   ZRO     RETURN
       STX     TX
       EAX*    E0IND
       LDA     1,2
       LDB     0,2
       FMP     LOGE         X=X(LOGE)
       STP     LIB4 
       RCY     9
       RSH     15
       SKG     =8             IS .X.>256
       BRU     EXFA         NO
       SKN     LIB4         YES, IS X<0
       BRU     ERR          NO, ERROR: X TOO LARGE
       CLAB                    YES, EXP(X)=0
       BRU     EXFC 
*
EXFA   LDP     LIB4         X/LN2
       FAD     EXF6         SEPARATE I AND F, ADD 1 TO I
       STB     EXF2+1       STORE I+1
       FSB     EXF6         SUBTRACT 1 FROM I. FLOAT RESULT
       STP     LIB2
       LDP     LIB4
       FSB     LIB2         I+F-I=F
       STP     LIB2
       FMP     LIB2
       STP    LIB4         F SQUARED
       FAD     E
       STP     LIB6         FSQ+E
       LDA     EXF2+1       I+1 AT 15
       RSH    9            I+1 AT 23
       ETR     =00000777B     CLEAR ALL BUT LOW ORDER 9 BITS
       STA     EXF2+1        (1/2)*2**(I+1)=2**I
       LDP     D
       FDV     LIB6         D/(FSQ+E)
       FAD     C
       FAD     LIB4
       STP     LIB6         FSQ+C-D/(FSQ+E)
       LDP     B
       FDV     LIB6 
       FSB     LIB2 
       FAD     A
       STA     LIB6
       CLA
       RCH     110B
       SUB     EXF5
       RCH     104B
       STB     LIB7            (A-F-B/FSQ+C-D/(FSQ+E)))/2
       LDP     LIB2
       FDV     LIB6
       FAD     ONE
       FMP     EXF2         MULTIPLY BY 2**I
EXFC   LDX     TX
       BRR     RETURN
*
ERR    SBRM*   ERROR
       BRU     ERR3
       ASC     ' ARGUMENT OF EXPONENTIAL FUNCTION > 176/'
ERR3   LDP     LGE
       LDX     TX
       BRR     RETURN
* 
LGE    DATA    37777777B
       DATA    77777377B
*
EXF2   DATA    20000000B
       DATA    00000000B
EXF5   DATA    00000001B
EXF6   DATA    30000000B
       DATA    00001046B
LOGE   DATA    27052435B     LOGE
       DATA    45127001B
ONE    DATA    20000000B     1.
       DATA    00000001B
A      DATA    25507713B     43.2808512267
       DATA    56662006B
B      DATA    44717116B
       DATA    31671017B 
C      DATA    30254757B     778.81042962
       DATA    02415012B
D      DATA    56676316B     -8769.5960924
       DATA    63175016B
E      DATA    27656522B
       DATA    51520007B
*
TX     BSS     1
RETURN BSS     1
LIB1   BSS     1
LIB2   BSS     2
LIB4   BSS     2
LIB6   BSS     1
LIB7   BSS     1
*
E0IND  EQU     0402B
ERROR  EQU     0413B
       END




ATAN   IDENT         FLOATING POINT ARC TANGENT SUBROUTINE
*
*
*
$ATANF EQU     *
$ATAN  ZRO     RETURN
       STX     TX
       LDA     EADR1
       SUB     =1
       SKE     E0ADR
       BRU     ATAN2
       LDX*    E0ADR           ONLY ONE ARGUMENT
       LDA     1,2
       LDB     0,2
       LDX     =-1
       STX     LIB5          SET LIB5
       LDX     =0
       STA     LIB8        SET LIB8
       SKA     =40000000B     IS Y<0
       FMP     ATF7            YES, Y=-Y
ATFA   STP     LIB1            SAVE/Y/
       FAD      ATF7             Y-1
       STA    LIB6         SET FADG 4
       SKG     =0              IS (1-Y)<0
       BRU     *+2             NO
       BRU     ATFC         YES, Y>1
       LDP     LIB1         (A,B)=U=Y
       BRU     ATFD
*  
ATFC    LDP     C1           (A,B)=1
       FDV    LIB1         (A,B)=U=1/Y
ATFD   STP     LIB1
       RCY     9
       RSH     15           SIGN EXTENDED EXPONENT
       SKG     =-4          IS U<1/16
       BRU     ATFE         YES, DO SERIES APPROXIMATION
       LDP     LIB1
       FAD     ATF6         V IN LOW ORDER BITS OF A
       SKA     =1
       ADD     =1           ROUND V TO NEAREST 1/8
       STA     LIB3
       ETR     =00000777B
       CAX                     SAVE TABLE LOOK UP NUMBER IN INDEX
       XAB
       ETR     =00000777B
       XAB
       LDA     LIB3
       FSB     ATF6         NORMALIZE V
       STP     LIB3         SAVE V
       FMP     LIB1    (A,B)=UV
       FAD     C1           (A,B)=1+UV
       XMA     LIB1         (A,B)=U, (AFT1)=(1+UV)
       XAB
       XMA     LIB2
       XAB
       FSB     LIB3         (A,B)=U-V
       FDV     LIB1    (A,B)=(U-V)/(1+UV)
       STP     LIB1    SAVE (U-V)/(1+UV)
ATFE    LDP     LIB1
       FMP     LIB1
       STP     LIB3
*
*      DO SERIES APPROXIMATION
*
       FMP     C7
       FAD     C5
       FMP     LIB3
       FAD     C3
       FMP     LIB3
       FAD     C1
       FMP     LIB1
       FAD     ATFT,2         ADD ARCTAN (U-V)
       SKN     LIB5        IS THERE ONLY ONE ARGUMENT
       BRU     ATFE2        NO
       SKN     LIB6        IS Y<1
       BRU     *+2          YES
       BRU     ATFG         NO
       STP     LIB1         SAVE THETA
       LDP     ATF4         PI/1
       FSB     LIB1         THETA=PI/2-THETA
ATFG   SKN     LIB8        IS Y<O
       BRU     *+2
       FMP     ATF7            THETA = -THETA
       LDX     TX
       BRR     RETURN
*
ATAN2  LDX*    E0ADR
       LDA     1,2
       LDB     0,2
       STA     LIB8           SET LIB8
       SKA     =40000000B     IS Y<0
       FMP     ATF7            YES, Y=-Y
ATFA2  STP     LIB1         SAVE /Y/
       LDA     E0ADR
       ADD     =1
       STA     TEMP
       LDX*    TEMP
       LDA     1,2
       LDB     0,2
       LDX     =0
       STX     LIB5        SET FADG 3
        STA     LIB7        SET FADG 5
       SKA     =40000000B         IS X<0
       FMP     ATF7            YES, SET X=-X
ATFB2  STP     LIB3         SAVE /X/
       FSB    LIB1         X-Y 
       STA    LIB6        SET FADG 4
       SKA     =40000000B      IS (X-Y)<0
       BRU     ATFC2        YES, X<Y
       SUB     LIB1      
       SKE     LIB1         IS Y=(X-Y)=0
       BRU     *+2          NO
       BRU     EXIT         YES, X=Y=0, EXIT
       LDP     LIB1            SET (A,B)=Y
       FDV    LIB3         DIVIDE BY X
       BRU     ATFD         (A,B)=U=(Y/X)
* 
ATFC2  LDP     LIB3            (A,B)=X
       FDV     LIB1            (A,B)=U=(X/Y)
       BRU     ATFD            
*
ATFE2  SKN     LIB6        IS X<Y
       BRU     ATFF2        NO
       STP     LIB1         SAVE THETA
       LDP     ATF4         PI/2
       FSB     LIB1         THETA=PI/1-THETA
ATFF2   SKN     LIB7        IS X<0
       BRU     ATFG2        NO
       STP     LIB1 
       LDP     ATF5         PI
       FSB     LIB1         THETA=IP-THETA
ATFG2   SKN     LIB8        IS Y<0
       BRU     EXIT 
       FMP     ATF7            YES, THETA = -THETA
EXIT   LDX     TX
       BRR     RETURN
*
ATF4   DATA    31103755B     PI/2
       DATA    24203001B
ATF5   DATA    31103755B      PI
       DATA    24203002B
ATF6   DATA    20000000B
       DATA    00000023B
ATF7   DATA    40000000B     -1
       DATA    00000000B
*
C1     DATA    20000000B     1
       DATA    00000001B 
C3     DATA    52525252B     1/3
       DATA    52525777B 
C5     DATA    31463146B     1/5
       DATA    31463776B 
C7     DATA    55555555B     1/7
       DATA    55556776B
*
ATFT   DATA    00000000B     ARCTAN(0)
       DATA    00000000B
       DATA    37653352B      .124354994547
       DATA    32531775B
       DATA    37266727B     .244978663127
       DATA    71131776B
       DATA    26754145B     .358770670271
       DATA    01711777B
       DATA    35530634B     .463647609001
       DATA    05304777B
       DATA    21700056B     .558599315344
       DATA    53676000B
       DATA    24457076B     .643501108793
       DATA    43115000B
       DATA    27001237B     .718829999622
       DATA    05361000B
       DATA    31103755B     .785398163397
       DATA    24210000B
*
TX     BSS     1
RETURN BSS     1
LIB1   BSS     1
LIB2   BSS     1
LIB3   BSS     2
LIB5   BSS     1
LIB6   BSS     1
LIB7   BSS      1
LIB8   BSS     1
*
E0ADR  EQU    0400B
EADR1  EQU     0403B
ERROR  EQU     0413B
TEMP   BSS     1
       END




IGET1  IDENT   9-9-68          FILE:  BITS     GARY A. GORGEN  TYMSHARE INC.
*
*      K=IGET1(IARRAY(IROW),ICOL)
*      IARRAY IS THE ARRAY CONTAINING THE MATRIX
*      IROW IS THE MATRIX ROW
*      ICOL IS THE MATRIX COLUMN
*      THE VALUE OF   (IROW,ICOL) IS RETURNED IN K.
*
*
$IGET1 HLT     RTN
 LDA 402B; STA LOC; MIN LOC; LDX* LOC; LDA* 402B; STA LOC
 LRSH -1,2; ETR =1; LDB LOC; STB* 402B; BRR RTN
RTN    ZRO
LOC    ZRO
       END





SWSEE  IDENT  FOR SENSE SWITCHES
SNDA   OPD     103B5,1,1
$SWSEE ZRO     RTN 
START  LDX     ONES
       BRS     13 
       BRU     LOOK 
       BRR     RTN 
LOOK   CLA
       CIO     ZERO 
       SUB     =20B 
       STA     DNUMB 
       SKG     =4 
       SKG     ZERO 
       BRU     BAD 
       CIO     ZERO
       SKE     ='   ;'
       BRU     BAD
       CIO     ZERO 
       SKE     ='   R' 
       BRU     *+2 
       BRU     RSET 
       SKE     ='   S' 
       BRU     BAD 
SET    CIO     ZERO
       SKE     =155B
       BRU     BAD
       CLA      
       STA     FSSW 
       BRU     CSSW 
RSET   CIO     ZERO
       SKE     =155B
       BRU     BAD
       LDA     ONES 
       STA     FSSW 
CSSW   LDA     DNUMB 
       LDB     =40000000B
       COPY    AX,BA 
       LCY     0,2 
       SKN     FSSW 
       BRU     SSW3 
       EOR     ONES 
       ETR     407B 
       BRU     SSW4 
SSW3   MRG     407B 
SSW4   STA     407B 
       BRU     START
RTN    HLT      
DNUMB  HLT      
FSSW   HLT      
BAD    SNDA    MSG
       LDX     ONES
       BRS     11
       BRU     LOOK
MSG    ASC     '$SENSE SWITCH COMMAND NOT IN FORM:  NUMBER'
       ASC     ';S(OR)R -- PLEASE RE-ENTER$/'
ONES   EQU     420B
ZERO   EQU     414B
       END




LINK   IDENT   T.FLORYAN  NOV. 28 1969
*
*  ECAP LINKING ROUTINE
*
*  REQUIRES FILE NAME AS A PAIR OF STRING POINTERS
*  RETURNS TO THE EXEC ON ANY ERROR IN CALL OR FILE NAME OR TYPE
*
*  CALL LINK(FILE)
*
*
$LINK  ZRO RTN
       BRS 113; LDX EOIND; LDP* 0,2; BRS 64; BRS 10; STA FXFER
       XAB; SKE =2; BRS 10; WIO FXFER; SKE =10273645; BRS 10
       SBRM* LNKLOC
EOIND  EQU 402B
LNKLOC EQU 777B
FXFER  EQU 1002B
RTN    ZRO
       END





INTRP  IDENT   T.FLORYAN      MARCH 12, 1970
*
*
*  IF ( INTRP(1) ) XXXX
*
*
*      THIS FUNCTION IS NEGATIVE IF AN ALTMODE OR CONTROL-SHIFT-OH
*      WAS TYPED AND POSITIVE IF NOT.  THE INTERRUPT WILL BE RESET
*      AFTER THE FUNCTION IS CALLED.  IF AN INTERRUPT OCCURRED,
*      CONTROL WILL TRANSFER TO XXXX, ELSE IT WILL GO TO THE FOLLOWING
*      STATEMENT.  'INTRP(X)' IS A FUNCTION:  DO NOT DIMENSION IT OR
*      ANYTHING.  THE EXPRESSION IN PARENTHESES IS A DUMMY AND MAY
*      CONTAIN ANYTHING -- IT IS USED TO IDENTIFY 'INTRP' AS A FUNCTION
*      TO THE FORTRAN II COMPILER.
*
*
$INTRP ZRO     RTN
       CLA
       BRS     26              TEST FOR DEFERRED ALTMODE
       BRR     RTN             NO, RETURN WITH ZERO
       LDA     =ESC            YES, RESET INTERRUPT
       STA     201B
       LDA     MASK
       BRS     78
       BRS     114             ENABLE INTERRUPTS
       CIT     ZERO            ALLOW THE INTERRUPT TO OCCUR (2B6)
MASK   NOP     0               NOP = 2B6
ESC    ZRO     ALT
       BRS     113             DISABLE INTERRUPTS
       LDA     ONES
       BRR     RTN             RETURN WITH INTRP = -1
ALT    ZRO
RTN    ZRO
ONES   EQU     420B            FOS DATA = -1
ZERO   EQU     414B            FOS DATA = 0
       END




ALTBRU IDENT
*
*  T.FLORYAN    APRIL 1970
*
*  TO BE CALLED DURING ENTRY TO A COMPUTE LINK
*
*  CAUSES AN UNCONDITIONAL 'GOTO ASSIGNED LABEL' UPON
*  RECEIPT OF AN ALTMODE
*
*  USE:
*
*      ASSIGN XXXX TO ISCAPE
*      CALL ALTBRU ( ISCAPE )
*
*
$ALTBRU ZRO RTN
       BRS 114; LDX* 402B; LDA 1,2; STA BRULOC
       LDA =GOTOIT; STA 201B; LDA =2B6; BRS 78; BRR RTN
GOTOIT ZRO
       LDX ONES; BRS 11; BRS 29
       MIN ESCOMP
       BRU* BRULOC
BRULOC ZRO
ESCOMP EQU 21B  COMPUTE LINK ALTMODE FLAG FOR INPUT LANGUAGE
ONES   EQU 420B
RTN    ZRO
       END




SLINK2 IDENT     ;*  T.FLORYAN    APRIL 27,1970
*
*  SPECIAL LINKING SUBROUTINE THAT CAUSES A LINK TO THE SECOND 'FILE'
*  STORED ON A MASTER LINK FILE CREATED BY THE PROGRAM CMBLNK
*
*  CALLING SEQUENCE:
*
*      CALL SLINK2(FILE)
*
*      WHERE 'FILE' IS A STRING POINTER PAIR
*
*  RETURNS TO THE EXEC ON ANY ERROR
*
*
$SLINK2 ZRO
       BRS 113
       LDX 402B; LDP* 0,2; BRS 64; BRS 10; STA FXFER; XAB; SKE =2
       BRS 10; WIO FXFER; SKE =10273645; BRS 10; WIO FXFER; WIO FXFER
       MUL =3; LSH 23; STA SLINK2; RCP FXFER; ADD SLINK2
       SCP FXFER; BRS 10; WIO FXFER; SBRM* LNKLOC
LNKLOC EQU  777B
FXFER  EQU 1002B
       END




NOTIFY IDENT
*
*  OUTPUTS A NON-PRINTING CHARACTER TO THE TERMINAL AFTER AN ELAPSED
*  TIME -- LETS A PROGRAM NOTIFY A USER THAT IT IS STILL RUNNING
*
*  WRITTEN BY: THAD FLORYAN
*
$NOTIFY ZRO    RTN
       BRS     42              GET CURRENT TIME OF DAY IN A-REGISTER
       SKN     START           CHECK FOR FIRST TIME THRU
       BRU     CHECK           NO. CHECK TIME
SETNXT ADD     INTVAL          YES. SET NOTIFY TIME = NOW + INTVAL
       STA     START
       BRR     RTN
CHECK  SKG     START           HAS THE NOTIFY TIME BEEN EXCEEDED
       BRR     RTN             NO. RETURN
       TCO     SOUND           YES. JOSTLE THE PRINT HEAD
       BRU     SETNXT               AND SET NEW TIME
START  DATA    -1
INTVAL DATA    240             OUTPUT INTERVAL (60THS OF A SECOND)
SOUND  DATA    140B
RTN    ZRO
       END




TRMOD  IDENT   VER.6  ECAP TR MODIFY ROUTINE    T.FLORYAN
*
*
*              SUBROUTINE TRMOD(K)
*
*
*
*  ALLOWABLE MODIFY ENTRIES ARE:
*
*      EXECUTE
*      OUTPUT INTERVAL = XX
*      1ERROR = XX.XX
*      2ERROR = XX.XX
*      3ERROR = XX.XX
*      INITIAL TIME = XX.XX
*      TIME STEP = XX.XX
*      FINISH TIME = XX.XX
*      SHORT = XX.XX
*      OPEN = XX.XX
*      END
*      EQUILIBRIUM
*
*
STF    OPD     107B5,1,1
SNDA   OPD     103B5,1,1
SIC    OPD     177B5,1,1

$TRMOD ZRO     RTN
       LDA BRUSIC; STA 177B; LDA =2; STA K
       TCO =155B
SET    SNDA GLITCH
       LDA =STORS; MUL =3; LSH 23; SUB ONE; CAB; STP MODPTR
       BRU IN; WCI MODPTR
IN     CIO ZERO
       SKG =77B; BRU IN-1
       SKE =141B; BRU CTRLQ
       GCD MODPTR; BRU *+3; TCO =77B; BRU IN; TCO =147B; BRU IN
CTRLQ  SKE =161B; BRU INTRPT; TCO =76B; BRU SET-1
INTRPT SKE =155B; BRU IN
       LDA MODPTR; CAB; STP CMPRSP; GCI MODPTR; BRU *+5
       SKG ZERO; BRU *-3; WCI CMPRSP; BRU *-5
       LDP CMPRSP; STP MODPTR; CAB; ADD =2; STF COMPTR
       LDA =COMDAT; MUL =3; LSH 23; SUB ONE; CAB; ADD =2; XAB; LDX =-11
COMCHK SKSE COMPTR
       BRU *+2; BRU COMVK,2; ADD =4; XAB; BRX COMCHK
ERROR  SNDA ERMSG; BRU SET
ERMSG  ASC '$ERROR -- RE-ENTER$$/'
GLITCH ASC '*/'
COMDAT ASC 'EXOU1E2E3EINTIFISHOPEN'
       BRU RETURN
       BRU OUTPUT
       BRU 1ERROR
       BRU 2ERROR
       BRU 3ERROR
       BRU RINITL
       BRU TIMEST
       BRU RFINIS
       BRU RSHORT
       BRU ROPEN
       BRS 10
COMVK  EQU   *
COMPTR BSS 2
MODPTR BSS 2
CMPRSP BSS 2
STORS  BSS 10
K      ZRO
RTN    ZRO
RETURN LDA K
       STA* 402B; BRR RTN
OUTPUT BRM GETDAT; SKG ZERO; BRU ERROR
       BRS 50; STA MAJOR; BRU SET
1ERROR BRM GETDAT; SKG ONES; BRU ERROR
       STF ERROR1; BRU SET
2ERROR BRM GETDAT; SKG ONES; BRU ERROR
       STF ERROR2; BRU SET
3ERROR BRM GETDAT; SKG ONES; BRU ERROR
       STF ERROR3; BRU SET
RINITL BRM GETDAT; SKG ONES; BRU ERROR
       STF START; LDA ONE; STA K; BRU SET
TIMEST BRM GETDAT; SKG ZERO; BRU ERROR
       STF DELTA; STF SAVE; BRU SET
RFINIS BRM GETDAT; SKG ZERO; BRU ERROR
       STF FINISH; BRU SET
RSHORT BRM GETDAT; SKG ZERO; BRU ERROR
       STF SHORT; BRU SET
ROPEN  BRM GETDAT; SKG ZERO; BRU ERROR
       STF OPEN; BRU SET

GETDAT ZRO
       GCI MODPTR; BRU ERROR
       SKE =35B; BRU *-3; SIC MODPTR; BRU ERROR; BRR GETDAT
BRUSIC BRU SICPOP
ONES   EQU     420B
ONE    EQU     415B
ZERO   EQU     414B
*
*  POP ROUTINE TO CONVERT A FREE-FORM NUMERIC STRING TO A FLOATING-
*  POINT REAL NUMBER
*
*  WRITTEN BY:  THAD FLORYAN    DEC.28, 1969
*
*  CALLING SEQUENCE:
*
*              SIC    STRING
*              ERROR RETURN
*              NORMAL RETURN
*
*  RETURNS:
*
*      NORMAL: FLOATING-POINT NUMBER IS IN A AND B REGISTERS WITH THE
*              EXPONENT IN THE B-REGISTER.  X-REGISTER IS LEFT
*              UNDISTURBED.  CONVERSION IS TERMINATED ON THE FIRST
*              "NON-NUMERIC" CHARACTER OR END-OF-STRING.  THE STRING
*              POINTERS ARE UPDATED IN MEMORY, I.E.:
*                   SIC  PTR      ="1E4(+10)1E5"
*                   ---
*                   1E4=(A)(B)    ="(+10)1E5"
*
*              IF FLOATING UNDERFLOW, FLOATING-POINT ZERO IS RETURNED
*              IN THE A AND B REGISTERS AND THE STRING POINTERS ARE
*              UPDATED IN MEMORY.
*
*      ERROR:  IF FLOATING OVERFLOW, THE MAXIMUM ALLOWABLE FLOATING-
*              POINT NUMBER IS RETURNED IN THE A AND B REGISTERS
*              AND THE STRING POINTERS ARE UPDATED IN MEMORY.
*
*
$SICPOP STX SICTX; EAX* 0; STX SICADR
       LDP 0,2; STP SICPTR; CLA; LDX =-9; STA SICBUF,2; BRX *-1
$SIL100 GCI SICPTR; BRU SIL35; MIN SICHAR; LDX =-15; SKE SICPNC,2
       BRU *+2; BRU SIL22; BRX *-3; WCD SICPTR; BRU SIL35
$SIL22  CXA; ADD =16; STA SICKEY; SUB =2; SKG ONES; BRU SIL100; SKE ZERO
       BRU SIL9; LDA SICNOE; SKE ZERO; BRU SIL8; MIN SICMS; BRU SIL100
$SIL8   MIN SICMSX; BRU SIL100
$SIL9   LDA SICKEY; SUB =13; SKG ONES; BRU SIL12; SKE ZERO; BRU SIL10
       MIN SICPRT; BRU SIL100
$SIL12  LDA SICNOE; SKE ZERO; BRU SIL33; BRU SIL185
$SIL10  LDA SICKEY; ADD =-15; SKG ONES; BRU SIL21; BRU SIL35
$SIL185 LDA SICPRT; SKG ZERO; BRU SIL187; MIN SICKNT
$SIL187 LDA SICKEY; SUB =3; BRS 51; STP SICTKE; LDP SICACC
       FMP FPTEN; FAD SICTKE; STP SICACC; BRU SIL100
$SIL21  MIN SICNOE; BRU SIL100
$SIL33  LDA SICNGX; MUL =10; LSH 23; ADD SICKEY; SUB =3; STA SICNGX
       BRU SIL100
$SIL35  LDA SICMSX; SKG ZERO; BRU SIL40; LDA SICNGX; CNA; STA SICNGX
$SIL40  LDA SICNGX; SUB SICKNT; STA SICNGX; SKE ZERO; BRU SIL27; BRU SIL28
$SIL27  LDA SICNGX    (CHECK EXP. FOR POS OR NEG)
       SKG ONES; BRU SIL27N; SKE ZERO; BRU SIL27P; BRU SIL28
$SIL27P CNA; CAX
       LDP FPONE
       FMP FPTEN    (1.0)*(10.0)
       BRX *-1
       FMP SICACC   SICACC*10^(SICNGX)
       STP SICACC
       BRU SIL28
$SIL27N CAX
       LDP FPONE
       FMP FTENTH   (1.0)*(0.1)
       BRX *-1
       FMP SICACC   SICACC*10^(-SICNGX)
       STP SICACC
$SIL28  LDA SICMS; SKE ZERO; BRU SICNEG
$SICRTN LDP SICPTR; LDX SICADR; STP 0,2  RETURN UPDATED POINTERS
       LDA SICACC+1; ETR =777B; SKE =377B; BRU SICGOB; LDA SICACC
       SKE =37777777B
$SICGOB MIN 0
       LDP SICACC; LDX SICTX; BRR 0
$SICNEG LDP SICACC; BRS 21; STP SICACC; BRU SICRTN
*
*  DATA AND STORAGE
*
$SICKNT ZRO
$SICMS  BSS  1   SIGN OF THE MANTISSA
$SICMSX BSS  1   SIGN OF THE EXPONENT
$SICHAR BSS  1   CHARACTER POSITION WITHIN THE STRING
$SICPRT ZRO
$SICNGX ZRO
$SICNOE ZRO
$SICACC BSS  2   ACCUMULATOR FOR CONVERTED NUMBER
$SICBUF EQU  *
$SICKEY ZRO
$SICTKE BSS  2
$SICADR ZRO
$SICTX  ZRO
$SICPTR BSS  2
$FPTEN  DATA  24B6,4              10.0
$FTENTH DATA  31463146B,31463775B  0.1
$FPONE  DATA  2B7,1                1.0
*
*  CHARACTERS:  +  -  0  1  2  3  4  5  6  7  8  9  .  E  (SPACE)
*
       DATA  13B,15B,20B,21B,22B,23B,24B,25B
       DATA  26B,27B,30B,31B,16B,45B,0
$SICPNC EQU  *
*
*
*    VARIABLE REFERENCES TO TRANSIENT COMMON
*
*
DELTA  EQU  75025B-50001B
ERROR1 EQU  75034B-50001B
ERROR2 EQU  75017B-50001B
ERROR3 EQU  75015B-50001B
FINISH EQU  72433B-50001B
MAJOR  EQU  75021B-50001B
OPEN   EQU  72426B-50001B
SAVE   EQU  66465B-50001B
SHORT  EQU  72430B-50001B
START  EQU  72435B-50001B
       END
ECAP ** FICHE/FRAME BREAK *****
ECSFETXTSYM
[HELPMG]

FOR A COMPLETE DESCRIPTION OF ALL COMMANDS, TYPE "INSTRUCTIONS".
FOR JUST A COMMAND LIST, TYPE "SUMMARY".

VALID COMMANDS ARE:

QUIT (OR) Q         RETURNS TO THE EXECUTIVE.

HELP (OR) ?         REPRINTS THIS LIST.

COMMANDS            OPENS A COMMAND FILE.

RUN                 BEGINS CONVERSATIONAL EXECUTION.

EXPERT,NOEXPERT     REDUCES CONVERSATION FOR "RUN".

BATCH               BEGINS EXECUTION WITH FORMATTED OUTPUT ASSUMED.

EXECUTE             BEGINS EXECUTION AS DETERMINED BY THE SETTING OF
                    THE OTHER AVAILABLE COMMANDS.

LOAD,READ           SPECIFIES INPUT FILE(S).

WRITE,PUNCH         SPECIFIES OUTPUT FILE.

LIST,NOLIST         WRITES INPUT CIRCUIT WITH THE SOLUTION.

SAVE,NOSAVE         WRITES THE INPUT CIRCUIT TO THE TERMINAL OR A FILE.

FORMAT,NOFORMAT     FORMATS OUTPUT FOR "SAVE" AND "LIST".

DATE,NODATE         PRINTS A HEADING FOR EACH SOLUTION.

TIME,NOTIME         PRINTS CPU AND TERMINAL TIME FOR EACH ANALYSIS.

PAUSE,NOPAUSE       STOPS PROCESSING AT LOGICAL STAGES DURING EXECUTION.
                    CONTINUE BY TYPING "GO".

RESET               NEGATES ALL PREVIOUS COMMANDS.

CATALOG             REPORT GENERATOR FOR STORED-MODEL FILES.

CONVERT             FORMATS TYMSHARE ECAP FREE-FORM PROGRAMS.

SUMMARY             LISTS ALL VALID COMMANDS TO THE TERMINAL.

CAPABILITIES        DESCRIBES TYMSHARE ECAP CAPABILITIES.

INSTRUCTIONS        DESCRIBES TYMSHARE ECAP OPERATING INSTRUCTIONS.

VERSION             TYPES CURRENT TYMSHARE ECAP VERSION NUMBER.

CHARGES             NO PREMIUM CHARGE.

CREDITS             WRITTEN BY TYMSHARE.


^
[CAPTXT]


                    TYMSHARE ECAP CAPABILITIES

A.  DC, AC OR TRANSIENT ANALYSIS MAY BE PERFORMED ON CIRCUITS UP TO
    AND INCLUDING:

                              DC    AC    TR

                 "B-CARDS"    60    60    60
                 "T-CARDS"    10    10    10
                  NODES       20    20    20
                 "M-CARDS"    --    10    10
                 "S-CARDS"    --    --     *
                 "E-CARDS"    --    --     5**
                 "I-CARDS"    --    --     5**
SIMULTANEOUS MODIFICATIONS    20    20    (SENSE SWITCH 3) ***

           *  HOWEVER MANY TO SPECIFY A MAXIMUM OF
              60 SWITCHED BRANCHES

           ** 50 SOURCE VALUES PER CARD

           ***SEE USE OF SENSE SWITCHES IN TRANSIENT ANALYSIS
              UNDER "INSTRUCTIONS"

B.  EXECUTION UNDER A COMMAND FILE.

C.  EXTENSIVE EDITING OF ALL INPUT WHETHER FROM A FILE OR THE TERMINAL.

D.  FREE-FORM PROGRAM INPUT.

    THE FOLLOWING ARE VALID INPUT EXAMPLES:

    B1    N(1,2),R=100
    B2 N(2,3),L=1E-9
    B3,N(5,4),C=1E-12; B4N(3,0),R=50

E.  FORMAT PROCESSORS FOR STORED MODEL CATALOGING AND BATCH FORMATTING
    CONVERSION.

F.  ADDITIONAL FEATURES UNDER DEVELOPMENT:

               1. INCREASED CIRCUIT SIZE CAPABILITY



                     USE OF RETRIEVABLE MODELS

                         "N-CARD" (NETWORK)

A.  PREPARATION OF MODEL FILE

    1. ALL MODELS ARE NORMALIZED; THAT IS, BRANCH NUMBERS BEGIN AT 1,
       NODE NUMBERS BEGIN AT 1, ETC.  AN UNLIMITED NUMBER OF MODELS
       MAY BE STORED ON A FILE.

    2. FILE LAYOUT EXAMPLE:

       MODEL: TRANS
       C
       C  DC MODEL
       C
       B1     N(1,2),R=350,E=-.3
       B2     N(3,2),R=10E3
       T1     B(1,2),BETA=50

       THE SEARCH ON THE MODEL FILE FOR THE SPECIFIED MODEL IS BASED
       ON THE MODEL ID, WHICH MAY BE ANY UNIQUE STRING OF CHARACTERS
       AFTER THE KEY: "MODEL:".

       EXAMPLE:

       MODEL: IIII CCCC

       WHERE - IIII IS THE MODEL ID OF INDEFINITE LENGTH UP TO THE
                    FIRST SPACE OR CARRIAGE RETURN, AND
               CCCC IS AN OPTIONAL COMMENT

B.  N-CARD GENERAL DESCRIPTION

    N--      ( RELOCATION SPECIFICATION )  (  FILE AND MODEL ID )

    RELOCATION INDICES ARE CONTAINED IN THE RELOCATION SPECIFICATION
    AND SERVE TO RELOCATE THE MODEL ON THE FILE INTO THE CURRENT
    ANALYSIS.  THE RELOCATION INDICES ARE OF THE FORM:

               RI(X1,X2,...,XN)

    WHERE RI IS THE INDEX TYPE FROM THE RELOCATION INDEX TABLE, AND
    X1 TO XN ARE THE NUMBERS TO BE ASSIGNED TO THE NORMALIZED MODEL
    VALUES (1 TO N) AS THEY ARE RELOCATED.

               RELOCATION INDEX TABLE

                   NO   FOR NODAL DATA
                   BR   FOR BRANCH DATA AND B-CARDS
                   SW   FOR S-CARDS
                   TR   FOR T-CARDS
                   MU   FOR M-CARDS
                   VO   FOR E-CARDS
                   CU   FOR I-CARDS

    CAUTION:

    USE OF RELOCATABLE MODELS DOES NOT ALLOW A LARGER ECAP PROGRAM;
    B, T, S, M, E AND I "CARDS" MUST STILL BE, AFTER RELOCATION,
    NUMBERED SEQUENTIALLY AND BE WITHIN THE SIZE CONSTRAINTS.

C.  EXAMPLE OF N-CARD USAGE

    ASSUME THAT THE FOLLOWING MODEL IS ON THE FILE /MODELS/:

               MODEL: TRANS
               B1     N(1,2),R=350,E=-.3
               B2     N(3,2),R=10E3
               T1     B(1,2),BETA=50

    N-CARD IN PROGRAM:

    N1  BR(6,13),     NO(7,8,9),    TR(1),      FI=/MODELS/,   MO=TRANS

        BRANCH          NODAL       T-CARD         MODEL        MODEL
        RELOCATION    RELOCATION    RELOCATION     FILE          ID

    RELOCATED MODEL IN CURRENT ANALYSIS:

               B6     N(7,8),R=350,E=-.3
               B13    N(9,8),R=10E3
               T1     B(6,13),BETA=50

    NOTE:

    IF THE MODEL FILE AND/OR THE MODEL ID ARE NOT SPECIFIED ON THE
    N-CARD, THE USER WILL BE ASKED TO ENTER THE MISSING PARAMETER(S)
    FROM THE TERMINAL.


^
[HLPMSG]


                    OPERATING INSTRUCTIONS

     THE USER MUST BE FAMILIAR WITH STANDARD ECAP NOTATION SUCH AS DE-
SCRIBED IN IBM ECAP APPLICATION PROGRAM DOCUMENT: H20-0170-1, IN "IBM
ELECTRONIC CIRCUIT ANALYSIS PROGRAM" BY JENSEN AND LIEBERMAN (PRENTICE-
HALL) OR IN "NETWORK COMPUTER ANALYSIS" BY ZOBRIST (BOSTON TECH.).  IN
ADDITION, TYMSHARE ECAP HAS THE CAPABILITY OF RETRIEVING STORED MODELS
FROM A FILE WHICH IS DESCRIBED BY TYPING "CAPABILITIES".

     TO INITIATE PROCESSING, TYPE "RUN".  ECAP WILL THEN ASK FOR THE
INPUT AND OUTPUT MEDIA (DISK FILES OR TERMINAL) AND INQUIRE WHETHER
VARIOUS OUTPUT AND CONTROL OPTIONS ARE DESIRED; THESE QUESTIONS MAY BE
ANSWERED BY A "YES" OR "NO" RESPONSE, AFTER WHICH EXECUTION WILL COM-
MENCE.  SHORTER QUERIES WILL RESULT IF "EXPERT" IS TYPED BEFORE "RUN".

     THERE ARE TWO ECAP LANGUAGES THAT YOU WILL ENCOUNTER; THE COMMAND
CONTROL LANGUAGE (DENOTED BY A ":" IN THE LEFT MARGIN) AND THE ANALYSIS
CONTROL LANGUAGE (DENOTED BY A "*" IN THE LEFT MARGIN).  INPUT TO
THE COMMAND CONTROL LANGUAGE FEATURES CONTROL-A, -Q AND -W EDITING.
INPUT TO THE ANALYSIS CONTROL LANGUAGE FEATURES THE USE OF ALL THE
EDITING CONTROL CHARACTERS DESCRIBED BELOW AND THE OTHER COMMANDS.
INSTRUCTIONS FOR USE OF THE ANALYSIS CONTROL LANGUAGE ARE DESCRIBED
BELOW.  TO DIRECTLY ENTER THE ANALYSIS CONTROL LANGUAGE, TYPE "EXECUTE"
AND THE ANALYSIS TYPE: DC, AC OR TR.  TO RETURN TO THE COMMAND CONTROL
LANGUAGE, TYPE "QUIT".  TO RETURN TO THE EXECUTIVE FROM THE ANALYSIS
CONTROL LANGUAGE, TYPE "END".

     THE ALTMODE KEY MAY BE USED TO ABORT THE CURRENT OPERATION; IT WILL
RETURN YOU TO EITHER A ":" OR A "*" AND CLOSE THE COMMAND FILE IF ONE IS
OPEN...TYPE IT ONLY ONCE OR POSSIBLE LOSS OF CIRCUIT DATA MAY RESULT.

     FOR A COMPLETE DESCRIPTION OF ANY COMMAND IN THE COMMAND CONTROL
LANGUAGE, TYPE "INSTRUCTIONS" AND THE COMMAND (I.E. :INSTRUCTIONS BATCH
OR  :INSTRUCTIONS BATCH,RUN).  ANY COMMAND MAY BE SHORTENED TO ITS FIRST
THREE LETTERS.  A DESCRIPTION OF ALL COMMANDS IN THE COMMAND CONTROL
LANGUAGE FOLLOWS THE DESCRIPTION OF THE ANALYSIS CONTROL LANGUAGE.


                   ANALYSIS CONTROL LANGUAGE

     CIRCUIT INPUT AND EDITING IS ON BLOCK STRUCTURES; THAT IS, ALL TEXT
BETWEEN THE ANALYSIS TYPE AND THE END OF AN ANALYSIS IS ONE BLOCK.  IN
THE EXAMPLE:

                      AC
               B1     N(1,0),R=50,E=1/0
               B2     N(1,2),R=100
               B3     N(2,0),R=50
                      FR=1E3
                      PR,NV
                      EX
                      DC
               B1     N(0,1),R=10,E=1
               B2     N(1,2),R=100
               B3     N(2,0),R=10
                      PR,NV
                      EX

THERE ARE TWO BLOCKS: "AC" TO "EX" AND "DC" TO "EX".  ALL STANDARD ECAP
INPUT IS ACCEPTABLE AS ARE THE FOLLOWING ADDITIONAL COMMANDS WHICH MAY
BE SHORTENED TO THE FIRST TWO CHARACTERS (EXCEPT FOR INSERT WHICH
REQUIRES THREE AND QUIT WHICH NEEDS ONLY ONE):

     EDIT RANGE    RETYPES THE LINE RANGE AND ALLOWS USE OF THE EDITING
                   CHARACTERS DESCRIBED BELOW.  A FORCED EDIT MODE WILL
                   RESULT IF A LINE IS IN ERROR.

     INSERT RANGE  ALLOWS NEW LINE(S) TO BE INSERTED BEFORE THE "RANGE".
                   TERMINATE THE INSERT MODE WITH A CONTROL-D.

     DELETE RANGE  DELETES LINE(S) ADDRESSED BY "RANGE".

     LIST          TYPES OUT THE CURRENT TEXT BLOCK.

     LIST RANGE    TYPES OUT LINE(S) ADDRESSED BY "RANGE".

     GO            CONTINUES AFTER A PAUSE.

     QUIT          RETURNS TO THE COMMAND CONTROL LANGUAGE.

     END           RETURNS TO THE EXECUTIVE.

     HELP          REPRINTS THIS LIST WHILE IN THE ANALYSIS CONTROL
                   LANGUAGE.

     NEW LINES ARE AUTOMATICALLY APPENDED TO THE TEXT BLOCK AS THEY ARE
ENTERED.  LINES IN THE TEXT BLOCK ARE STORED IN COMPACTED FORM WITH ALL
SUPERFLUOUS SPACES REMOVED.

"RANGE" DESCRIPTIONS
        (REFER TO BLOCK 1 ("AC" TO "EX") IN THE ABOVE EXAMPLE)

THE RANGE CONSISTS OF PHYSICAL LINE NUMBERS, ECAP "LINE LABELS", THE
SPECIAL CHARACTERS "$" AND "." AND ADDRESS ARITHMETIC ("+", "-" OR ",").

    PHYSICAL LINE NUMBERS ARE INTEGER NUMBERS DENOTING THE ACTUAL LINE
    POSITION WITHIN A BLOCK.  EXAMPLE:

                   *LIST 1
                   AC

    ECAP LINE LABELS ARE THE FIRST TWO OR THREE CHARACTERS OF A B-, T-,
    S-, M-, E- OR I-CARD.  EXAMPLE:

                   *LIST B1,B2     (B1 THROUGH B2)
                   B1 N(1,0),R=50,E=1/0
                   B2 N(1,2),R=100

    THE SPECIAL CHARACTER "$" SIGNIFIES THE LAST LINE IN THE BLOCK AND
    THE CHARACTER "." SIGNIFIES THE CURRENT LINE IN THE BLOCK.  EXAMPLE:

                   *LIST $
                   PR,NV
                   *LIST .
                   PR,NV

    ADDRESS ARITHMETIC MAY BE USED TO REFERENCE LINES WHICH MAY OR MAY
    NOT HAVE A LABEL.  EXAMPLE:

                   *LIST B1+1
                   B2 N(1,2),R=100
                   *LIST $-1
                   FR=1E3
                   *LIST $-2,$
                   B3 N(2,0),R=50
                   FR=1E3
                   PR,NV


    DURING EDIT, THE FOLLOWING CONTROL CHARACTERS ARE VALID (CONSULT
    THE EDITOR REFERENCE MANUAL OR QUICK REFERENCE CARD):

              A                 K                 S
              C          CARRIAGE RETURN          T
              D                 N                 U
              E                 O                 W
              F                 P                 X
              H                 Q                 Y
              I                 R                 Z

A CARRIAGE RETURN IS SYNONYMOUS WITH A LINE FEED IN THAT THEY BOTH
TERMINATE A LINE.

NOTE: EVEN THOUGH MANY CIRCUIT STATEMENTS MAY BE ENTERED ON A LINE
      SEPARATED BY SEMICOLONS, THE ANALYSIS CONTROL LANGUAGE WILL
      ASSIGN EACH STATEMENT A PHYSICAL LINE NUMBER.  FOR EXAMPLE:

              B1  N(1,0),R=10; B2  N(1,2),R=100

      WILL BE PLACED IN THE TEXT BLOCK AS:

              B1 N(1,0),R=10
              B2 N(1,2),R=100



               SENSE SWITCHES IN TRANSIENT ANALYSIS

     SENSE SWITCH 3 IS OPERATIONAL IN TRANSIENT ANALYSIS AND ITS SETTING
ALLOWS ENTRY OF TRANSIENT SOLUTION MODIFICATIONS AS THE ANALYSIS IS
PROGRESSING.  SENSE SWITCH 3 IS SET AT ANY TIME DURING ANALYSIS BY
TYPING:

               3;S  AND A CARRIAGE RETURN

     AND, WHEN REQUESTED BY ECAP, IS RESET BY TYPING:

               3;R  AND A CARRIAGE RETURN

     THE STATE OF SENSE SWITCH 3 IS CHECKED AFTER EACH TIME STEP, BUT
MAY APPEAR TO BE DELAYED FOR TWO REASONS:

       1) SWITCHING CALCULATIONS (S-CARD ACTION) ARE BEING PERFORMED
       2) SOLUTION OUTPUT PRIOR TO SETTING OF THE SENSE SWITCH IS
          STILL BEING TRANSMITTED BY THE COMPUTER

     INPUT TO THE TRANSIENT MODIFY ROUTINE FEATURES CONTROL-A AND
CONTROL-Q EDITING.  ALLOWABLE TRANSIENT MODIFY STATEMENTS ARE
(MAY BE SHORTENED TO THE FIRST TWO LETTERS):

       INITIAL TIME = XX.XX    RESTARTS THE SOLUTION WITH THE TIME
                               PRINTOUT AS SPECIFIED

       TIME STEP = XX.XX       INITIATES A NEW TIME STEP VALUE

       OUTPUT INTERVAL = XX    CHANGES THE NUMBER OF SOLUTION CYCLES
                               BEFORE OUTPUT

       FINISH TIME = XX.XX     REDEFINES THE FINAL SOLUTION TIME

       SHORT = XX.XX           REDEFINES THE SHORT-CIRCUIT VALUE
                               FOR CAPACITORS FOR INITIAL CONDITION
                               SOLUTIONS

       OPEN = XX.XX            REDEFINES THE OPEN-CIRCUIT VALUE FOR
                               INDUCTORS FOR INITIAL CONDITION
                               SOLUTIONS

       1ERROR = XX.XX          REDEFINES MAXIMUM ALLOWABLE CURRENT
                               UNBALANCES

       2ERROR = XX.XX          REDEFINES SWITCHING RESOLUTION

       3ERROR = XX.XX          REDEFINES TIME STEP REDUCTION FOR
                               INITIAL CONDITION SOLUTIONS

       EXECUTE                 CONTINUES THE SOLUTION

       END                     RETURNS TO THE EXECUTIVE






                    COMMAND CONTROL LANGUAGE

^
*QUIT*
[HLPB1]
         RETURNS TO THE EXECUTIVE IMMEDIATELY; A CONTINUE
                    IS NOT POSSIBLE.

^
*HELP*
[HLPB2]
         PRINTS AN ABBREVIATED FORM OF THIS LIST.

^
*COMMANDS*
[HLPBU1]
            CLOSES THE OLD COMMAND FILE IF ONE IS OPEN AND
                    OPENS THE SPECIFIED FILE AS THE NEW COMMAND FILE.
                    CONSULT THE EXECUTIVE REFERENCE MANUAL FOR FURTHER
                    DETAILS AND EXAMPLES.

^
*RUN*
[HLPB3]
                 THIS COMMAND DIRECTS ECAP TO GUIDE THE USER THROUGH
                    THE STEPS NECESSARY FOR PROCESSING THE INPUT
                    PROGRAMS.

^
*EXPERT*
[HLPB4]
     THIS INDIRECT COMMAND REDUCES THE CONVERSATION
                    FOR "RUN". IF THIS OPTION IS NOT INVOKED, "NOEXPERT"
                    WILL BE ASSUMED.

^
*BATCH*
[HLPB5]
               DIRECT COMMAND THAT INITIATES A MODE OF OPERATION
                    THAT ASSURES MAXIMUM THROUGHPUT.  AUTOMATICALLY SETS
                    "FORMAT", "LIST", "DATE" AND "TIME" OPTIONS AND
                    REQUESTS ONLY THE INPUT AND OUTPUT FILES.

^
*EXECUTE*
[HLPB6]
             BEGINS EXECUTION AS DETERMINED BY THE SETTING
                    OF THE VARIOUS OTHER OPTIONS.  IF CIRCUIT INPUT IS
                    FROM THE TERMINAL, THE TYPE OF ANALYSIS TO BE PER-
                    FORMED MUST BE ENTERED ALSO.  EXAMPLE:

                    :EXECUTE AC
                    :EXECUTE
                     ANALYSIS: AC

^
*LOAD*
[HLPB7]
           SPECIFIES INPUT FILE(S).  EACH TIME THIS OPTION
                    IS INVOKED THE OLD FILES ARE CLOSED AND NEW ONES ARE
                    OPENED, IF POSSIBLE.  FILES CAN BE STACKED BY SEPA-
                    RATING THE NAMES WITH COMMAS, SUCH AS:

                    :LOAD FILE1,FILE2

                    CIRCUIT INPUT WILL BE ASSUMED TO COME FROM THE TER-
                    MINAL IF THIS COMMAND IS NOT INVOKED.

^
*WRITE*
[HLPB8]
         SPECIFIES THE SOLUTION OUTPUT FILE.  EACH TIME
                    THIS OPTION IS INVOKED, THE OLD FILE IS CLOSED AND
                    THE NEW ONE IS OPENED, IF POSSIBLE.  IF THIS OPTION
                    IS NOT INVOKED, OUTPUT WILL BE TO THE TERMINAL UN-
                    LESS "PUNCH" IS SPECIFIED IN THE ECAP PROGRAM, AT
                    WHICH TIME THE USER WILL BE ASKED TO SPECIFY AN
                    OUTPUT FILE.

^
*LIST*
[HLPB9]
         DIRECTS ECAP TO WRITE THE INPUT CIRCUIT TOPOLOGY
                    TO THE SAME MEDIUM AS THE SOLUTION OUTPUT.  "NOLIST"
                    WILL BE ASSUMED IF THIS OPTION IS NOT INVOKED.

^
*SAVE*
[HLPB10]
         DIRECTS ECAP TO WRITE THE INPUT CIRCUIT TOPOLOGY
                    TO THE TERMINAL OR A FILE.  "NOSAVE" WILL BE ASSUMED
                    IF THIS OPTION IS NOT INVOKED.

^
*FORMAT*
[HLPB11]
     THIS OPTION SPECIFIES A FORMATTED OUTPUT FOR THE
                    "LIST" AND "SAVE" OPTIONS.  IF THIS OPTION IS NOT
                    INVOKED, "NOFORMAT" WILL BE ASSUMED.

^
*DATE*
[HLPB12]
         CAUSES A HEADING TO BE PRINTED FOR EACH ANALYSIS
                    IN FORM:

                    TYMSHARE ECAP    FEB. 1,1970  13:22   PROGRAM: T

                    WHERE 'PROGRAM' IS THE CIRCUIT INPUT FILE NAME.  IF
                    THIS OPTION IS NOT INVOKED,"NODATE" WILL BE ASSUMED.

^
*TIME*
[HLPB13]
         CAUSES TIMING DATA TO BE PRINTED FOR EACH ANALYSIS
                    IN FORM:

                    EOJ       CPU  0:00:24     TERMINAL  0:01:17

                    WHERE 'CPU' IS THE CPU TIME FOR THE CURRENT ANALYSIS
                    AND 'TERMINAL' IS THE ELAPSED TERMINAL TIME FROM
                    INPUT OF THE CIRCUIT TO THE COMPLETION OF THE ANAL-
                    YSIS.  "NOTIME" WILL BE ASSUMED IS THIS OPTION IS
                    NOT INVOKED.

^
*PAUSE*
[HLPB14]
       STOPS PROCESSING AT LOGICAL STAGES DURING EXECUTION.
                    AFTER EACH PAUSE, ANY VALID COMMAND IN THE ANALYSIS
                    COMMAND SET MAY THEN BE TYPED.  "NOPAUSE" WILL BE
                    ASSUMED IF THIS OPTION IS NOT INVOKED.

^
*RESET*
[HLPB15]
               NEGATES ALL PREVIOUS COMMANDS, CLOSES ALL FILES
                    AND ALLOWS THE USER TO CONTINUE AS IF HE HAD JUST
                    ENTERED ECAP FROM THE EXECUTIVE.

^
*CATALOG*
[HLPB16]
             DIRECTS ECAP TO PRODUCE A FORMATTED LISTING OF ALL
                    MODELS STORED ON A FILE. OUTPUT TO THE TERMINAL WILL
                    BE 56 LINES PER PAGE, OUTPUT TO A FILE WILL BE 39
                    LINES PER PAGE FOR LINE PRINTER LISTING.

^
*CONVERT*
[HLPB17]
             INVOKES A FORMAT PROCESSOR THAT CONVERTS TYMSHARE
                    FREE-FORM ECAP PROGRAMS TO A FORM SUITABLE FOR USE
                    WITH A CARD-ORIENTED ECAP.  INPUT FROM THE TERMINAL
                    IS TERMINATED BY TYPING A CONTROL-D.

^
*SUMMARY*
[HLPB18]
             LISTS ALL VALID COMMANDS TO THE TERMINAL.

^
*CAPABILITIES*
[HLPB19]
        DESCRIBES TYMSHARE ECAP CAPABILITIES.

^
*INSTRUCTIONS*
[HLPB20]
        DESCRIBES TYMSHARE ECAP OPERATING INSTRUCTIONS.
                    DESCRIPTIONS OF INDIVIDUAL COMMANDS IN THE COMMAND
                    CONTROL LANGUAGE CAN BE LISTED TO THE TERMINAL BY
                    TYPING "INSTRUCTIONS" AND THE COMMAND.  EXAMPLE:

                    :INSTRUCTIONS BATCH
                    :INSTRUCTIONS BATCH, RUN

^
*VERSION*
[HLPB21]
             TYPES CURRENT TYMSHARE ECAP VERSION NUMBER.

^
*CHARGES*
[HLPB22]
             NO PREMIUM CHARGE.

^
*CREDITS*
[HLPB23]
             WRITTEN BY TYMSHARE.

^
*DEBUG*
[HLPB24]
               ENABLED OPTIONS ARE:
                    <D>  DISABLES SFE ALTMODE CONTROL
                    <E>  ENABLES SFE ALTMODE CONTROL
                    <F>  LISTS ALL CURRENT FILE NAMES
                    <A>  TYPES OUT AUTHOR'S NAME
                    <W>  COPIES ECAP FILES FOR DEBUGGING

^
*OPTIONS*
[HLPB25]
             LISTS OPTIONS THAT ARE SET.

^
*WHY*
[HLPB26]
                 TYPES REASON FOR ERROR MESSAGE.

^
*BAD*
[HLPBX1]
                 TYPES OUT THE NAMES OF ALL "BAD" ECAP LINK FILES
                    AND THE EXECUTIVE ERROR CODE, ELSE TYPES
                    "NO BAD FILES".

^
*LINKS*
[HLPBX2]
               TYPES OUT THE NAMES OF ALL ECAP LINK FILES.

^
ECAP ** FICHE/FRAME BREAK *****
ECTRSYM
C-TRCOMP    ECAP VER.6    TR COMPUTE LINK
C
C*TR COMPUTE VERSION:  6.00    MAY 18,1970      T.FLORYAN
C                      6.02    JUNE 8,1970      T.FLORYAN
C
C
C
C
C      M A J O R    C H A N G E S    F R O M    V E R S I O N    5
C
C
C  -DIFFERENT STRUCTURE OF LINK NAMES IN COMMON
C  -MOVING OF VARIABLE "NTR" TO A DIFFERENT PLACE IN COMMON
C  -DIFFERENT "CALL LINK" SEQUENCE
C  -ALL OCCURRENCES OF "DIMENSION LANG[223]"
C           CHANGED TO "DIMENSION LANG[222]"
C  -MINOR CLEANUP OF FORMATS
C  -ALTMODE TEST ON ENTRY AND BRANCH
C  -REMOVAL OF SUBROUTINE TRRTN
C  -REMOVAL OF SUBROUTINE KLIK
C  -NEW TRANSIENT MODIFY SUBROUTINE (TRMOD)
C  -ADJUSTMENT OF COMMON BY VARIABLE 'NEWPAD'
C  -ADJUSTMENT OF COMMON BY VARIABLE 'OMEGA'
C  -IMPROVED SENSE SWITCH 3 OPERATION
C
C
C******* FOR LOADING BY FOS, USE FILE  ECLIBIN  FOR ALL MATH
C******* AND UTILITY SUBROUTINES
C
C
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
C     THIS IS ECAP70
       IF ( INTRP(1) ) 9999
       ASSIGN 9999 TO ISCAPE
       CALL ALTBRU ( ISCAPE )
      NOMORE = 1
      SAVE = DELTA
1000  CALL ECAP91
      NREC = 0
      LOCK = 0
      JX1=0
       LOCKB = 1
       LOCKD = 2
      NSTEP=KE+KI
       LOCKF = 0
      CONTINUE
      CONTINUE
      CALL ECAP97
      LATCH=1
      CALL ECAP79
      CALL ECAP87
      LATCH=2
      CALL ECAP79
      CALL ECAP88
      CALL ECAP82
      CALL ECAP96
      CALL ECAP83
      CALL ECAP89
      CALL ECAP88
      T=START
      TZERO=T
      CALL ECAP90
      IF [ LATCH ] 1900, 1900, 8710
1900  CALL ECAP81
      CALL ECAP82
      CALL ECAP83
      NUMBER=0
      MINOR=NUMBER
      CALL ECAP94
      CALL ECAP95
      IF[ LOCK ] 3300, 9999, 3300
 3000 GO TO [ 3100,3400,3400,3400,3300,3300],LOCK
 3100 LATCH = 1
      CALL ECAP79
      LATCH=2
      CALL ECAP87
      LATCH = 2
      CALL ECAP79
      DO 3125 K=1, NODES
      VO[K] = V[K]
 3125 V[K] = 0.0
      CALL ECAP88
      CALL ECAP82
      CALL ECAP83
      CALL ECAP89
      CALL ECAP88
      CALL ECAP90
      IF [ LATCH ] 3250, 3250, 8710
3250  CALL ECAP81
      CALL ECAP82
      CALL ECAP83
      JX1=0
      CALL ECAP95
       GO TO 3400
 3300  GO TO [3800, 3400], LOCKD
3800  CONTINUE
      CALL ECAP98
 3400 IF[ ERROR3 - 1.0 ] 3430, 3410, 3410
 3410 GO TO [ 3420, 3500 ], LOCKB
 3420 LOCK = 6
      GO TO 3600
 3430 IF [ LOCK - 6 ] 3440, 3600, 3600
3440  CALL ECAP84
       IF[LOCKF] 3450, 3450, 3425
3425  CALL ECAP81
      CALL ECAP82
      CALL ECAP83
      LOCKF = 0
 3450 IF[ LOCK - 5 ] 3480, 3500, 3600
 3480 NUMBER = MINOR
      T = T + DELTA
      GO TO 3804
 3500 NUMBER = MINOR
      GO TO 3700
 3600 TZERO = T
      MINOR=NUMBER
 3700 T = TZERO + SAVE
 3804 NUMBER = NUMBER + 1
      LOCKA=1
      LATCH=2
      CALL ECAP87
      DO 4000 K = 1, NODES
 4000 VO[ K ] = V[ K ]
       GO TO [4500, 5000], LOCKD
 4500  LATCH = 1
      CALL ECAP93
 5000 DO 5100 K = 1, NODES
 5100 V[ K ] = 0.0
      CALL ECAP88
      CALL ECAP89
C       TR701220
C       TR701230
      CALL ECAP88
      CALL ECAP90
      IF[LATCH]5113,5113,8710
 5113 JX1=0
      IF[NSWTCH]5110,5110,5112
5112   I=1
      LAST=NSWTCH/[2**[I-1]]-[NSWTCH/[2**I]]*2
      LAST = 2-LAST
      GO TO [5111,5110],LAST
5111   CALL ECAP95
      JX1=1
C       TR701330
C       TR701340
 5110 IF [ LOCKS ] 7700, 7700, 7000
7000  CALL ECAP86
      IF [ LOCKG ] 7550, 7600, 7550
 7550 LATCH = 3
      CALL ECAP87
      CALL ECAP80
      CALL ECAP82
      CALL ECAP83
      GO TO [ 7560, 7600 ], LOCKD
 7560 LATCH = 2
      CALL ECAP93
 7600 GO TO [ 7700, 5000, 5000, 5000, 7800 ], LOCKA
 7700 GO TO [ 8701, 3000, 3000, 3000, 8701, 8701 ], LOCK
 7800 GO TO [ 7910, 7920 ], LOCKB
7910  CALL ECAP85
      GO TO [ 7912, 7917 ], LOCKB
 7912 GO TO [ 7915, 7917 ], LOCKD
7915  CONTINUE
      CALL ECAP98
7917  CALL ECAP95
      GO TO 7930
 7920 DELTA = SAVE
      LOCK = 6
 7925 LOCKB = 1
      CALL ECAP81
      CALL ECAP82
      CALL ECAP83
 7930 GO TO [ 8701, 3000 ], LOCKB
8701   CALL NOTIFY
       CALL SWSEE
       IF ( SENSE SWITCH 3 ) 8704
      IF [ T - FINISH ] 8201, 8702, 8702
 8702 NOMORE=2
       IF[FINISH] 8703,8703,8400
 8703  WRITE 3,87042
87042  FORMAT[///$ FINAL TIME PARAMETER OMITTED, ONLY ONE TIME STEP CALC
     XULATED.$]
      GO TO 8400
 8201 IF[ NUMBER - MAJOR ] 3000, 8300, 8300
 8300 NUMBER=0
      IF [ LOCK-5 ] 8600, 8400, 8400
8400  CALL ECAP95
       CALL SWSEE
       IF(SENSE SWITCH 3)8704,8600
 8600 GO TO [ 3000, 9999 ], NOMORE
8704   TYPE 87041
87041  FORMAT(//$TRANSIENT MODIFY ROUTINE ENTERED$/)
8708   TYPE 87081
87081  FORMAT(/$TURN SENSE SWITCH 3 OFF:  $)
87082  CALL SWSEE
       IF(SENSE SWITCH 3)87082,87083
87083  CALL TRMOD(ITRANS)
       GO TO (1000,7925),ITRANS
 8710 WRITE  3, 8711 , NREC
 8711 FORMAT(//$*** JOB TERMINATED  --  EXCESSIVE ($I3$) CURRENT
     1 UNBALANCES$//)
      KTO=2
9999   CALL LINK ( TRL )
      END
C
C
       SUBROUTINE ECAP79
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
      GO TO [ 1000, 5000 ], LATCH
 1000 IF[ NUMBR ] 3000, 3000, 2000
 2000 INDEX = NUMBC
      DO 2500  I = 1, NUMBR
      INDEX = INDEX + 1
      LL = LINK1A[ INDEX ]
 2500 Y[ LL ] = Y1[ LL ]
 3000 IF[ NUMBC ] 5000, 5000, 4000
 4000 DO 4500   I= 1, NUMBC
      LL = LINK1A[ I ]
 4500 Y[ LL ] = 1.0/SHORT
 5000 IF[ NUMBL ] 9000, 9000, 6000
 6000 INDEX = NUMBC + NUMBR
      DO 8000  I = 1, NUMBL
      INDEX = INDEX + 1
      LL = LINK1A[ INDEX ]
      GO TO [6500,7000],LATCH
 6500 Y[ LL ] = 0.0
      GO TO 8000
 7000 Y[ LL ] = 1.0/OPEN
 8000 CONTINUE
9000  RETURN
      END
      SUBROUTINE ECAP80
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
       COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
      IF[ NUMBC ] 5000, 5000, 1000
 1000 DO 2000 I = 1, NUMBC
       LL = LINK1A[I]
 2000 Y[ LL ] = Y1[ LL ] / DELTA
C       TR720330
C       TR720340
5000  RETURN
       END
      SUBROUTINE ECAP81
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
      IF [ NUMBC ] 5000, 5000, 1000
 1000 DO 2000 I = 1, NUMBC
      LL = LINK1A[I]
 2000 Y[LL] = Y1[LL] / DELTA
 5000 IF[ NUMBL ] 9000, 9000, 6000
 6000 INDEX = NUMBC + NUMBR
      DO 7000 I = 1, NUMBL
       INDEX = INDEX + 1
       LL = LINK1A[INDEX]
 7000 Y[ LL ] = Y1[ LL ] * DELTA / 2.0
9000  RETURN
C       TR730400
C       TR730410
       END
      SUBROUTINE ECAP82
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
C       TR740320
       DO  1000  J=1,NODES
       DO  1000  I=1,NODES
 1000  H[I,J] = 0.0
C       TR740360
      DO 5000 I = 1, LINKS
      J = NT[ I ]
      K = NH[ I ]
      IF [ J ]2000,1500,2000
 2000 IF [ K ]3000,2500,3000
 2500 K = J
 1500 IF [ K ]1600,5000,1600
      GO TO 1600
 3000 H[J,J]=H[J,J]-Y[I]
      H[K,J]=H[K,J]+Y[I]
      H[J,K]=H[J,K]+Y[I]
 1600 H[K,K]=H[K,K]-Y[I]
 5000 CONTINUE
C       TR740500
C       TR740510
      IF [ NTERMS ] 7000, 7000, 5500
 5500 DO 6500 N=1,NTERMS
      LR = IROWT[N]
      LC = ICOLT[N]
      TERM = YTERM1[ N ] * Y[ LC ] / Y1[ LC ]
      I = NT[LR]
      IF [ I ] 6000, 6000, 5600
 5600 J = NH[LC]
      IF [ J ] 5800, 5800, 5700
 5700 H[ I, J ] = H[ I, J ] + TERM
 5800 J = NT[LC]
      IF [ J ] 6000, 6000, 5900
 5900 H[ I, J ] = H[ I, J ] - TERM
 6000 I = NH[LR]
      IF [ I ] 6500, 6500, 6100
 6100 J = NT[LC]
      IF [ J ] 6300, 6300, 6200
 6200 H[ I, J ] = H[ I, J ] + TERM
 6300 J = NH[LC]
      IF [ J ] 6500, 6500, 6400
 6400 H[ I, J ] = H[ I, J ] - TERM
 6500 CONTINUE
C       TR740740
C       TR740750
C       TR740760
C       TR740770
7000  RETURN
       END
      SUBROUTINE ECAP83
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
      IF[ NODES - 1 ] 1000, 1000, 1500
 1000 H[ 1, 1 ] = 1.0/H[ 1, 1 ]
      GO TO 9000
 1500 MINUS = NODES - 1
      I = 1
      M = 2
 2000 HZERO = H[ I, I ]
      H[ I, I ] = 1.0
      DO 2500 J = 1, NODES
 2500 H[ I, J ] = H[ I, J ] / HZERO
      DO 6000 K = M, NODES
      IF[  ABS[H[K,I]]-1.0E-20]3000,3000,4000
 3000 H[ K, I ] = 0.0
      GO TO 6000
 4000 HZERO = H[ K, I ]
      DO 5000 J = M, NODES
 5000 H[ K, J ] = H[ K, J ] - H[ I, J ] * HZERO
 6000 CONTINUE
 7000 IF[ I - MINUS ] 7500, 8000, 8000
 7500 I = I + 1
      M = I + 1
      GO TO 2000
 8000 HZERO = H[ NODES, NODES ]
      H[ NODES, NODES ] = 1.0
      DO 8500 J = 1, NODES
 8500 H[ NODES, J ] = H[ NODES, J ] / HZERO
9000  RETURN
      END
      SUBROUTINE ECAP84
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
      LOCKF = 0
      COEFF = 1.0 / ERROR3
      GO TO [ 2000, 4000, 5000, 6000, 7000, 9000 ], LOCK
 2000 LOCK=2
      LOCKB=1
      UNIT=DELTA
      PARTS = COEFF
 2250 PARTS =.3333333*[PARTS+PARTS+COEFF/[PARTS*PARTS]]
      DIFF = PARTS*PARTS*PARTS/COEFF - 1.0
      IF [ ABS [ DIFF ] - 0.000001 ] 2500, 2500, 2250
 2500 DELTA = UNIT / COEFF
      GO TO 7500
 4000 LOCK=3
      DELTA = UNIT / [ PARTS * PARTS ] - UNIT / COEFF
      GO TO 7500
 5000 LOCK=4
      DELTA=UNIT/PARTS-UNIT/[PARTS*PARTS]
      GO TO 7500
 6000 LOCK=5
      DELTA=UNIT-UNIT/PARTS
      GO TO 7500
 7000 LOCK=6
      DELTA=SAVE
 7500 LOCKF = 1
9000  RETURN
      END
      SUBROUTINE ECAP85
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
 1000 LOCKB = 2
      IF [ LIST ] 9000, 9000, 2000
 2000 DO 4000 M=1,LIST
      N=LEVER[M]
       LASTC = 0
       DO  3000  I=1,N
 3000  LASTC = LASTC + LIST4[I]
       LASTB = LASTC - LIST4[N] + 1
       DO  4000  I=LASTB,LASTC
       L = LINK1E[I]
      TRADE=BIAS1[L]
      BIAS1[L]=BIAS2[L]
      BIAS2[L]=TRADE
      TRADE=FLOW1[L]
      FLOW1[L]=FLOW2[L]
      FLOW2[L]=TRADE
      TRADE=Y1[L]
      Y1[L]=Y2[L]
      Y2[L]=TRADE
       IF[NTERMS] 4000, 4000, 3700
 3700 DO 3900 J = 1, NTERMS
      IF [ L-ICOLT[J] ] 3900, 3800, 3900
 3800 TRADE = YTERM1[J]
      YTERM1[J] = YTERM2[J]
      YTERM2[J] = TRADE
 3900 CONTINUE
 4000 CONTINUE
      RATIO = [ T - TSTAR ] / SAVE
      IF [ RATIO - 0.5 ] 5100, 5400, 5400
 5100 IF [ RATIO - ERROR2 ] 5300, 5300, 5000
 5300 T = TSTAR
      LOCKF = - 1
      GO TO 9000
 5400 IF [ 1.0 - RATIO - ERROR2 ] 5500, 5500, 5000
 5500 T = TSTAR + SAVE
      DELTA = SAVE
      TZERO = T
      MINOR = NUMBER
      LOCKB = 1
      IF [ NUMBER - MAJOR ] 5000, 5700, 5700
 5700 NUMBER = 0
      MINOR = 0
 5000 LOCKF = 1
9000  RETURN
      END
      SUBROUTINE ECAP86
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
      LOCKG = 0
      STEP = DELTA
      GO TO [ 1000, 2000, 5000, 2000, 9000 ], LOCKA
 1000 TSTAR = T - DELTA
      TLOW = 0.0
      HOLD = SAVE - [ T - STEP - TZERO ]
      LEAST = 0
      IF [ ERROR2 - 0.01001 ] 1200, 1200, 1500
 1200 TEST = 1.001*ERROR2
      GO TO 2000
 1500 TEST = 0.01001
C       TR790430
C       TR790440
C       TR790450
 2000 LIST = 0
      DO 2500 N = 1, LOCKS
      LEVER[ N ] = 0
      LL = LINK1D[ N ]
      LATCH = LABEL[ N ]
      GO TO [ 2100, 2200 ], LATCH
 2100 IF[ FLUX[ LL ]] 2500, 2400, 2400
 2200 IF[ FLUX[ LL ]] 2400, 2400, 2500
 2400 LIST = LIST + 1
      LEVER[ LIST ] = N
 2500 CONTINUE
      GO TO [ 2600, 3000, 3000, 3000 ], LOCKA
 2600 IF[ LIST - 1 ] 8000, 2800, 2800
 2800 LOCKB = 1
C       TR790600
C       TR790610
 3000 IF[ LIST - 1 ] 3400, 3300, 3100
C       TR790630
C       TR790640
 3100 LOCKA = 2
      LEAST = LIST
      DO 3200 I = 1, LIST
 3200 LEVERS[ I ] = LEVER[ I ]
      THIGH = STEP
      GO TO 4000
C       TR790710
C       TR790720
 3300 LOCKA = 3
      LEAST = 1
      LEVERS[ 1 ] = LEVER[ 1 ]
      THIGH = STEP
      GO TO 6000
C       TR790780
C       TR790790
 3400 LOCKA = 4
      TLOW = STEP
C       TR790820
C       TR790830
C       TR790840
 4000 SPAN = THIGH - TLOW
      RATIO = SPAN / SAVE
      IF[ RATIO - TEST ] 8000, 8000, 4500
C       TR790880
C       TR790890
 4500 DELTA = 0.5 * [ THIGH + TLOW ]
      T = TSTAR + DELTA
      GO TO 7000
C       TR790930
C       TR790940
 5000 N = LEVERS[ 1 ]
      LL = LINK1D[ N ]
      LATCH = LABEL[ N ]
      GO TO [ 5100, 5200 ], LATCH
 5100 IF[ FLUX[ LL ]] 5600, 8000, 5800
 5200 IF[ FLUX[ LL ]] 5800, 8000, 5600
 5600 TLOW = STEP
      GO TO 6000
 5800 THIGH = STEP
C       TR791040
C       TR791050
 6000 SPAN = THIGH - TLOW
      DELTA = 0.5 * [ THIGH + TLOW ]
      RATIO = SPAN / SAVE
      IF[ RATIO - ERROR2 * 1.001 ] 8000, 8000, 6600
 6600 T = TSTAR + DELTA
C       TR791110
C       TR791120
C       TR791130
 7000 LOCKG = 1
      GO TO 9000
C       TR791160
C       TR791170
 8000 GO TO [ 8100, 8500 ], LOCKB
 8100 LIST = LEAST
      IF[ LIST - 1 ] 9000, 8200, 8200
 8200 DO 8400 I = 1, LIST
 8400 LEVER[ I ] = LEVERS[ I ]
C       TR791230
 8500 LOCKA = 5
C       TR791250
C       TR791260
C       TR791270
9000  RETURN
      END
      SUBROUTINE ECAP87
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
      IF[ NUMBL ] 9000, 9000, 1000
 1000 GO TO [1095,1050,1095],LATCH
 1050 IF[NTERMS]1075,1075,1080
 1080 DO 1090 I=1,NTERMS
      LL=IROWT[I]
      IF[MODE1[LL]-3]1090,1085,1090
 1085 L=ICOLT[I]
      FLUX[LL]=FLUX[LL]-FLUX[L]*YTERM1[I]/Y1[L]
 1090 CONTINUE
 1075 LATCH=1
C       TR800400
 1095 INDEX=NUMBC+NUMBR
      DO 8000 I = 1, NUMBL
       INDEX = INDEX + 1
       LL = LINK1A[INDEX]
      II = NT[LL]
      IF[ II ] 1100, 1100, 1150
 1150 VI = V[II]
      VOI = VO[II]
      GO TO 1200
 1100 VI = 0.0
      VOI = 0.0
 1200 JJ = NH[LL]
      IF[ JJ ] 1300, 1300, 1350
 1350 VJ = V[JJ]
      VOJ = VO[JJ]
      GO TO 1400
 1300 VJ = 0.0
      VOJ = 0.0
 1400 GO TO [3000,9000,5000],LATCH
 3000 VALUE[LL] = FLUX[LL] + Y[LL] * [VI - VJ + BIAS1[LL]]
      GO TO 8000
 5000 VALUE[LL] = VALUE[LL] - Y[LL] * [ VOI - VOJ + BIAS1[LL]]
      Y[ LL ] = Y[ LL ] * [ DELTA / STEP ]
      VALUE[LL] = VALUE[LL] + Y[LL] * [ VOI - VOJ + BIAS1[LL]]
 8000  CONTINUE
C       TR800660
C       TR800670
9000  RETURN
       END
      SUBROUTINE ECAP88
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
C       TR810310
      DO 4000 LL = 1, LINKS
      II = NT[ LL ]
      IF [ II ] 1201, 1201, 1202
 1201 VI = 0.0
      VOI = 0.0
      GO TO 1200
 1202 VI = V[ II ]
      VOI = VO[ II ]
 1200 JJ = NH[ LL ]
      IF [ JJ ] 1401, 1401, 1402
 1401 VJ = 0.0
      VOJ = 0.0
      GO TO 1400
 1402 VJ = V[ JJ ]
      VOJ = VO[ JJ ]
 1400 MODE = MODE1[ LL ]
      GO TO [ 1000, 2000, 2000 ], MODE
 1000 IF[ LOCK ] 1500, 2000, 1500
 1500 FLUX[ LL ] = Y[ LL ] * [ VI - VJ - VOI + VOJ ]
      GO TO 4000
 2000 FLUX[ LL ] = Y[ LL ] * [ VI - VJ + BIAS1[ LL ]]
      GO TO [4100, 4000, 3000 ], MODE
 3000 FLUX[ LL ] = FLUX[ LL ] + VALUE[ LL ]
      GO TO 4000
 4100 FLUX[ LL ] = FLUX[ LL ] + Y[ LL ] * EO[ LL ]
 4000 CONTINUE
      GO TO [ 4500, 7400 ], LOCKD
 4500 IF[LOCK]4600,7400,4600
 4600 DO 7000 I = 1, 5
      IF[ LISTE[ I ]] 7400, 7400, 6000
 6000 LL = LISTE[ I ]
      IF[ MODE1[ LL ] - 1 ] 7000, 6500, 7000
 6500 FLUX[ LL ] = FLUX[ LL ] + Y1[ LL ] * ESLOPE[ I ]
 7000 CONTINUE
 7400 IF[ NTERMS ] 9000, 9000, 7500
 7500 DO 8000 I = 1, NTERMS
      L = ICOLT[ I ]
      LL = IROWT[ I ]
 8000 FLUX[ LL ] = FLUX[ LL ] + FLUX[ L ] * YTERM1[ I ] / Y1[ L ]
 9000 DO 9100 K = 1, NODES
 9100 B[ K ] = 0.0
      DO 9500 LL = 1, LINKS
      II = NH[LL]
      JJ = NT[LL]
      IF [ II ] 9300, 9300, 9200
 9200 B[ II ] = B[ II ] - FLUX[ LL ] + FLOW1[ LL ]
 9300 IF [ JJ ] 9500, 9500, 9400
 9400 B[ JJ ] = B[ JJ ] + FLUX[ LL ] - FLOW1[ LL ]
 9500 CONTINUE
9900  RETURN
C       TR810820
C       TR810830
       END
      SUBROUTINE ECAP89
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
      B[ 1 ] = B[ 1 ]*H[ 1, 1 ]
      IF [ NODES - 1 ] 1000, 1000, 2000
 1000 V[ 1 ] = B[ 1 ]
      GO TO 9000
 2000 DO 3000 I = 2, NODES
      B[ I ] = B[ I ]*H[ I, I ]
      LAST = I - 1
      DO 3000 K = 1, LAST
 3000 B[ I ] = B[ I ] - H[ I, K ]*B[ K ]
      V[ NODES ] = B[ NODES ]
      DO 5000 I = 2, NODES
      K = NODES + 1 - I
      M = K + 1
      SUM = 0.0
      DO 4000 J = M, NODES
 4000 SUM = SUM + H[ K, J ]*V[ J ]
 5000 V[ K ] = B[ K ] - SUM
9000  RETURN
      END
      SUBROUTINE ECAP90
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
C       TR830290
C       TR830300
      LATCH = 0
      SUM=0.
      DO 3000 K=1,NODES
 3000 SUM = SUM + ABS[ B[K]]
C       TR830350
C       TR830360
      IF[SUM-ERROR1] 9000, 9000, 7000
C       TR830380
C       TR830390
 7000 WRITE 3, 40, T
 40   FORMAT[//$ SOLUTION NOT OBTAINED TO DESIRED TOLERANCE$,/,
     1  $ AT TIME = $,E16.7,///]
      DO  8000  K=1,NODES
      BB = - B[ K ]
 8000 WRITE  3, 50 , K, BB
   50 FORMAT(/$ NODE NO.:$I4$, CURRENT UNBALANCE = $E11.4)
      WRITE  3, 60
      NREC = NREC + 1
      IF [ NSWTCH ] 8400, 8400, 9000
 8400 IF [ NREC - 20 ] 9000, 9000, 8500
 8500 LATCH = 1
   60 FORMAT[///]
9000  RETURN
      END
      SUBROUTINE ECAP91
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
      LOCKG = 0
      DO 1000  K = 1, NODES
       V[K] = 0.0
 1000  VO[K] = 0.0
       DO  2000  LL=1,LINKS
 2000  FLUX[LL] = AMPO[LL]
       INDEX = 0
       DO  5000  M=1,3
       DO  5000  LL=1,LINKS
       IF[MODE1[LL]-M] 5000, 3000, 5000
 3000  INDEX = INDEX + 1
       LINK1A[INDEX] = LL
 5000  CONTINUE
      RETURN
      END
      SUBROUTINE ECAP93
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
      IF[KE]5000,5000,1000
 1000 DO 4000 N=1,KE
      K=LISTE[N]
      GO TO [ 2000, 2500 ], LATCH
 2000 BIAS1[K]=BIAS1[K]+ESLOPE[N]*DELTA
      GO TO 3000
 2500 BIAS1[K]=BIAS1[K]+ESLOPE[N]*[DELTA-STEP]
 3000 BIAS2[K]=BIAS1[K]
 4000 CONTINUE
 5000 IF[KI]9000,9000,6000
 6000 DO 8000 N=1,KI
      K=LISTI[N]
      GO TO [ 7000, 7500 ], LATCH
 7000 FLOW1[K]=FLOW1[K]+ASLOPE[N]*DELTA
      GO TO 8000
 7500 FLOW1[K]=FLOW1[K]+ASLOPE[N]*[DELTA-STEP]
 8000 FLOW2[K]=FLOW1[K]
9000  RETURN
      END
      SUBROUTINE ECAP94
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
    4 IF[ OPEN / SHORT - 1.0 ] 1500, 1500, 1000
 1000 LOCK = 1
      IF[NUMBC+NUMBL+NSTEP]1500,1500,9000
 1500 LOCK = 0
      NPR =  NPRINT [ 1 ] + NPRINT [ 2 ]
      IF[ NPR ] 9000, 9000, 1600
 1600 WRITE   3, 20
   20 FORMAT[///$ STEADY STATE SOLUTION$//]
9000  RETURN
      END
      SUBROUTINE ECAP95
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
      DIMENSION X[60]
       LOST=2-(NSWTCH-((NSWTCH/2)*2))
 4    NPR = 0
      DO 5 I=1,6
 5    NPR = NPR +NPRINT[I]
      IF [ LOCKF ] 8100, 500, 500
 500  IF[LOCK] 1000, 1007, 1000
 1000 IF[ JX1 ] 1001, 1001, 8000
1001  II=1
      LOST=NSWTCH/[2**[II-1]]-[NSWTCH/[2**II]]*2
      LOST = 2-LOST
      GO TO [ 1004 , 1003 ], LOST
 1003 IF[ NPR ] 1005, 1005, 1004
C
C  CODING HERE WAS CHANGED TO CLEAR UP A BLOODY MESS
C  ONLY ONE FORMAT FOR "TIME" IS NEEDED AND THERE IS
C  NO NEED FOR CUTE FORMAT FLIP-FLOPS       -T.FLORYAN
C
1004   IF (NPRINT(16) + NPRINT(17)) 10041,1005,10041
10041  WRITE(3,10) T
10     FORMAT(///$TIME = $E14.8)
C1004   ASSIGN 10 TO IFORMT
C       DO 10045 I=21,56
C       IF(NPRINT(I))10046,10045,10046
C10045  CONTINUE
C       GO TO 10047
C10046  ASSIGN 10048 TO IFORMT
C10048  FORMAT(//$ T = $E14.8)
C10047  IF(NPRINT(16))10041,10042,10041
C10041  WRITE 3,IFORMT,T
C10042  IF(NPRINT(17))10043,10044,10043
C10043  WRITE 1,IFORMT,T
C10044  CONTINUE
C 10   FORMAT[//,$    T = $, E14.8,/]
 1005 GO TO [ 1008, 1007 ], LOST
 1007 IF[ NPRINT[1]] 1010, 1010, 1008
 1008  JX3=1
       ASSIGN 11 TO IFORMT
       CALL ECA100 ( IFORMT,JX3 )
 11   FORMAT[//$NODES$,15X,$NODE VOLTAGES$]
      LIMIT=NODES
      JX2 = 1
      DO 1009 I = 1, NODES
 1009 X[I] = V[I]
      GO TO 9010
 1010 IF[ NPRINT[5]+NPRINT[6]+NPRINT[3]]1023,1023,1011
 1011 DO 1015 I = 1, LINKS
      J = NT[I]
      IF[J]1013,1013,1012
 1012 X[I] = V[J]
 1013 J= NH[I]
      IF[ J ] 1015,1015,1014
 1014 X[I]=X[I] - V[J]
 1015 CONTINUE
      IF [ NPRINT[ 5 ]] 1018, 1018, 1016
 1016  JX3=5
       ASSIGN 1017 TO IFORMT
       CALL ECA100 ( IFORMT,JX3 )
 1017 FORMAT[//$BRANCHES$,12X,$BRANCH VOLTAGES$]
      LIMIT = LINKS
      JX2 = 2
      GO TO 9010
 1018 IF[ NPRINT[6] + NPRINT[3]] 1023, 1023, 1019
 1019 DO 1020  I = 1, LINKS
 1020 X[I] =X[I]+ BIAS1[I]
      IF[NPRINT[3]]1023,1023,1021
 1021 JX2=3
       JX3=3
      LIMIT=LINKS
       ASSIGN 1022 TO IFORMT
       CALL ECA100 ( IFORMT,JX3 )
 1022 FORMAT[//$BRANCHES$,12X,$ELEMENT VOLTAGES$]
      GO TO 9010
 1023 GO TO [ 1026, 1025 ], LOST
 1025 IF [ NPRINT[2]] 1027, 1027, 1026
1026   JX3=2
       ASSIGN 30 TO IFORMT
       CALL ECA100 ( IFORMT,JX3 )
 30   FORMAT[//$BRANCHES$,12X,$ELEMENT CURRENTS$]
      JX2 = 4
      LIMIT = LINKS
      GO TO 9010
 1027 IF [NPRINT[6]] 1031, 1031, 1028
 1028 DO 1029  I = 1, LINKS
 1029 X[I] = X[I] * FLUX[I]
       JX3=6
       ASSIGN 1030 TO IFORMT
       CALL ECA100 ( IFORMT,JX3 )
 1030 FORMAT[//$BRANCHES$,12X,$INSTANTANEOUS ELEMENT POWER$]
      JX2 = 5
      LIMIT = LINKS
      GO TO 9010
 1031 IF[ NPRINT[4]] 8000, 8000, 1032
 1032 DO 1033 I = 1, LINKS
 1033 X[I] = FLUX[I] - FLOW1[I]
       JX3=4
       ASSIGN 1034 TO IFORMT
       CALL ECA100 ( IFORMT,JX3 )
 1034 FORMAT[//$BRANCHES$,12X,$BRANCH CURRENTS$]
      JX2 = 6
      LIMIT = LINKS
 9010 LAST =0
       ASSIGN 9018 TO IRTN
 9011 K = LAST + 1
      LAST = LAST + 4
      IF [ LAST - LIMIT ] 9013, 9013, 9012
 9012 LAST = LIMIT
 9013 IF[ JX2 - 4 ] 9014, 9015, 9014
 9014  CALL ECA101 ( X,IRTN,JX3)
      WRITE 3,9016, K, LAST, [ X[J], J = K, LAST ]
      GO TO 9017
 9015  CALL ECA101 ( FLUX,IRTN,JX3)
      WRITE 3,9016, K, LAST, [FLUX[J], J = K, LAST ]
 9017 IF [LIMIT - LAST ] 9018, 9018, 9011
 9018 GO TO [ 1010, 1018, 1023, 1027, 1031, 8000], JX2
 9016 FORMAT[/,I2,$-$,I2,3X,4[2X,E14.8]]
 8000 IF [ LOCKF ] 9000, 9000, 8100
8100   CALL ECAP74
9000  RETURN
       END
      SUBROUTINE ECAP96
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
      NPR = NPRINT[ 10 ]
      IF [ NPR ] 9000, 9000, 1000
 1000 WRITE  3, 12 , DELTA, MAJOR, ERROR1, ERROR2, ERROR3, SHORT, OPEN
      WRITE  3, 18
      DO 53 I = 1, NODES
      LAST = 0
   54  K=LAST + 1
       LAST = LAST + 4
       IF[LAST-NODES] 55, 55, 56
   56  LAST = NODES
   55 WRITE   3, 17 , I, K, LAST, [ H[ I, J ], J = K, LAST]
      IF [ NODES - LAST ] 53, 53, 54
   53  CONTINUE
      WRITE   3, 14
      DO 5000 K = 1, NODES
 5000 WRITE   3, 21 , K, B[ K ]
   12 FORMAT[ // 10H TIME STEP, 7X,2H= ,E15.8/,
     119H OUTPUT INTERVAL = ,I14/,7H 1ERROR,10X,2H= ,E15.8/,
     27H 2ERROR,10X,2H= ,E15.8/,7H 3ERROR,10X,2H= ,E15.8/,
     36H SHORT,11X,2H= ,E15.8/,5H OPEN,12X,2H= ,E15.8 // ]
   14  FORMAT [//26H EQUIVALENT CURRENT VECTOR/
     1    9H NODE NO.5X7HCURRENT]
   17 FORMAT[/I2,I7,$-$,I2,3X,4E15.8 ]
   18 FORMAT[//$NODAL CONDUCTANCE MATRIX$/$ROW$5X$COLS$]
   21  FORMAT [/I6,4X,E15.8]
9000  RETURN
      END
      SUBROUTINE ECAP97
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
      IF [ KE ] 5000, 5000, 1000
 1000 DO 4000 I = 1, KE
      IF[ETIME[I,2]]2500,2400,1100
 1100 EONE = ETR[ I , 1 ]
      EZRO = ETR[ I , 2 ]
      TZRO = ETR[ I , 3 ]
      TPD = ETIME[ I , 1 ]
      TTAU[ I ] = SAVE
      JSTEPS[ I ] = 1
      NUME[I]=TPD/SAVE+0.5
      IF[NUME[I]-50]  1200,1200,1150
 1150 LE = LISTE[ I ]
      Z=50.0*SAVE
 1125 FORMAT[/$PERIOD OF SINE WAVE IN BRANCH$I3$ IS TOO LONG$
     1/$SET TO 50*TIME STEP = $E15.8///]
      WRITE  3, 1125 , LE, Z
      NUME[I]=50
 1200 IF[NUME[I]-3]1225,1250,1250
 1225 LE = LISTE[ I ]
      Z = 3. * SAVE
      WRITE  3, 1175 , LE, Z
 1175 FORMAT[/$PERIOD OF SINE WAVE IN BRANCH$I3$ IS TOO SHORT$
     1/$SET TO 3*TIME STEP = $E15.8///]
      NUME[I]=3
 1250 NE=NUME[I]
      TIME = 0.
      DO 2000 K = 1, NE
      ETR[I,K]=EZRO + EONE * SIN[ 6.283185 * [ TIME - TZRO ]/TPD ]
 2000 TIME = TIME + SAVE
      GO TO 3000
 2400 NUME[I]=NUME[I]-1
 2500 TPD = ETIME[ I, 1 ]
      TTAU[ I ] = SAVE * TPD
      JSTEPS[ I ] = TPD + 0.5
 3000 JSTEP[ I ] = JSTEPS[ I ]
      JLINE[ I ] = 0
      CALL UPDATE[ I , 1 ]
      JLINE[ I ] = 0
      LE = LISTE[ I ]
      BIAS1[ LE ] = ETR[ I, 1 ]
 4000 BIAS2[ LE ] = BIAS1[ LE ]
      LOCKD = 1
5000   CALL ECAP75
       RETURN
       END
      SUBROUTINE ECAP98
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
C       TR920280
      IF [ KE ]5000, 5000, 1000
 1000 DO 9 I = 1, KE
      IF [ JSTEP[ I ] - JSTEPS[ I ]] 8, 2, 9
    2 JSTEP[ I ] = 0
      CALL UPDATE[ I, 1 ]
    8 JSTEP[ I ] = JSTEP[ I ] + 1
    9 CONTINUE
 5000 IF [ KI ] 8000, 8000, 6000
 6000 DO 19 I = 1, KI
      J = I + 5
      IF [ JSTEP[ J ] - JSTEPS[ J ]] 18, 12, 19
   12 JSTEP[ J ] = 0
      CALL UPDATE[ I, 2 ]
   18 JSTEP[ J ] = JSTEP[ J ] + 1
   19 CONTINUE
 8000 IF [ NSTEP ] 21, 21, 9000
   21 LOCKD = 2
9000  RETURN
      END
      SUBROUTINE ECAP74
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
 8100 DO 8400 M = 1, LIST
      N = LEVER[ M ]
      LATCH = LABEL[ N ]
      GO TO [ 8200, 8250 ], LATCH
 8200 LABEL[ N ] = 2
      WRITE 3,90, N
 90   FORMAT[//,$ SWITCH$,I3,$ IS ON$]
      GO TO 8400
 8250 LABEL[ N ] = 1
      WRITE 3,91,N
 91   FORMAT[//,$ SWITCH$,I3,$ IS OFF$]
 8400 CONTINUE
      GO TO [ 8500, 8600 ], LOCKB
 8500 LOCKB = 2
      GO TO 8700
 8600 DELTA = HOLD - [ T - TSTAR ]
 8700 LOCK = 1
      LOCKF = 0
9000  RETURN
       END
      SUBROUTINE ECAP75
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
 5000 IF [ KI ] 9000, 9000, 6000
 6000 DO 8000 I = 1, KI
      IF[ATIME[I,2]]7500,7400,6100
 6100 EONE = AMPTR[ I, 1 ]
      EZRO = AMPTR[ I, 2 ]
      TZRO = AMPTR[ I, 3 ]
      TPD = ATIME[ I, 1 ]
      TTAU[ I + 5 ] = SAVE
      JSTEPS[ I + 5 ] = 1
      NUMI[I]=TPD/SAVE+0.5
      IF[NUMI[I]-50] 6200,6200,6150
 6150 LE = LISTI[ I ]
      Z=50.0*SAVE
      WRITE  3, 1125 , LE, Z
      NUMI[I] = 50
 6200 IF[NUMI[I]-3]6250,6300,6300
 6250 LE = LISTI[ I ]
      Z = 3. * SAVE
      WRITE  3, 1175 , LE, Z
      NUMI [ I ] = 3
 6300 NE=NUMI[I]
      TIME = 0.
      DO 7000 K = 1, NE
      AMPTR[I,K]=EZRO+EONE * SIN[ 6.283185 * [ TIME - TZRO ]/TPD ]
 7000 TIME = TIME + SAVE
      GO TO 7800
 7400 NUMI[I]=NUMI[I]-1
 7500 TPD=ATIME[I,1]
      TTAU[ I + 5 ] = SAVE * TPD
      JSTEPS[ I + 5 ] = TPD + 0.5
 7800 JSTEP[ I + 5 ] = JSTEPS[ I + 5 ]
      JLINE[ I + 5 ] = 0
      CALL UPDATE[ I , 2 ]
      JLINE[ I + 5 ] = 0
      LE = LISTI[ I ]
      FLOW1[ LE ] = AMPTR[ I , 1 ]
 8000 FLOW2[ LE ] = FLOW1 [ LE ]
      LOCKD = 1
1125  FORMAT[/$PERIOD OF SINE WAVE IN BRANCH$I3$IS TOO LONG$
     1/$SET TO 50*TIME STEP = $E15.8///]
1175  FORMAT[/$PERIOD OF SINE WAVE IN BRANCH$I3$IS TOO SHORT$
     1/$SET TO 3*TIME STEP = $E15.8///]
9000  RETURN
      END
      SUBROUTINE UPDATE[IA,IB]
C     THIS IS ECAP92  FORMERLY UPDATE
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
      GO TO [ 10, 20 ], IB
   10 JLINE[ IA ] = JLINE[ IA ] + 1
      LA = JLINE[ IA ]
      IF[ OPEN/SHORT - 1.0 ] 3001,3001,1000
 1000 IF[LA-NUME[IA]]2000,3000,9000
 2000 ESLOPE[ IA ] = [ETR[IA,LA+1]-ETR[IA,LA]]/TTAU[IA]
      GO TO 9000
 3000 IF [ ETIME[ IA, 2 ]] 3001, 3002, 3002
 3001 ESLOPE[ IA ] = 0.0
      JSTEPS[ IA ] = 0
      NSTEP = NSTEP - 1
      GO TO 9000
 3002 ESLOPE[ IA ] = [ETR[IA, 1 ] - ETR[ IA, LA ]]/TTAU[ IA ]
      JLINE[ IA ] = 0
      GO TO 9000
   20 IC = IA + 5
      JLINE[ IC ] = JLINE[ IC ] + 1
      LA = JLINE[ IC ]
C*********************************
C*********************************
       IF(LA-NUMI(IA))7000,8000,9000
7000   ASLOPE(IA)=(AMPTR(IA,LA+1)-AMPTR(IA,LA))/TTAU(IC)
       GO TO 9000
8000   IF(ATIME(IA,2))8001,8002,8002
8001   ASLOPE(IA)=0.0
       JSTEPS(IC)=0
       NSTEP=NSTEP-1
       GO TO 9000
8002   ASLOPE(IA)=(AMPTR(IA,1)-AMPTR(IA,LA))/TTAU(IC)
       JLINE(IC)=0
9000  RETURN
      END
       SUBROUTINE ECA100 ( IFORM1,JX3 )
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
       ASSIGN 1 TO IFORMT
       IFORMT=IFORM1
       DO 20 I=JX3*6+15,JX3*6+20
       IF(NPRINT(I))21,20,21
20     CONTINUE
C
C  CODING HERE CLEANED UP TO PUT OUTPUT ALWAYS ON UNIT NO. 3
C
200    IF(NPRINT(16) + NPRINT(17)) 1,4,1
1      WRITE 3,IFORMT
C200    IF(NPRINT(16))1,2,1
C1      WRITE 3,IFORMT
C2      IF(NPRINT(17))3,4,3
C3      WRITE 1,IFORMT
4      RETURN
21     GO TO (10,11,12,13,14,15),JX3
10     ASSIGN 100 TO IFORMT
       GO TO 200
100    FORMAT(//$NO     NO VOL$)
11     ASSIGN 110 TO IFORMT
       GO TO 200
110    FORMAT(//$BR     EL CUR$)
12     ASSIGN 120 TO IFORMT
       GO TO 200
120    FORMAT(//$BR     EL VOL$)
13     ASSIGN 130 TO IFORMT
       GO TO 200
130    FORMAT(//$BR     BR CUR$)
14     ASSIGN 140 TO IFORMT
       GO TO 200
140    FORMAT(//$BR     BR VOL$)
15     ASSIGN 150 TO IFORMT
       GO TO 200
150    FORMAT(//$BR     EL PWR$)
       END
       SUBROUTINE ECA101 (X,IRTN,JX3)
       DIMENSION LFILES(36),IFILES(44),SAVEFL(5)
      DIMENSION NPRINT[60],LINK1K[60],LINK1S[30],LDD[60],LD1[60]
      DIMENSION EO[60],BIAS1[60],BIAS2[60],AMPO[60],FLOW1[60],FLOW2[60]
      DIMENSION Y[60],Y1[60],Y2[60],NT[60],NH[60],MODE1[60],LIST4[60]
      DIMENSION YTERM2[10],YTERM1[10],IROWT[10],ICOLT[10]
      DIMENSION LABEL[60],B[20],PAD[20]
      DIMENSION LISTE[5],LISTI[5],NUME[5],NUMI[5],JSTEP[10],JSTEPS[10]
      DIMENSION JLINE[10],LINK1D[60],LINK1E[60]
      DIMENSION ETIME[5,2],ATIME[5,2],ETR[5,50],AMPTR[5,50]
      DIMENSION LANG[222]
      DIMENSION V[20],VO[20],FLUX[60],VALUE[60],LEVER[60],LEVERS[60]
      DIMENSION H[20,20],NEWPAD(80)
      DIMENSION LINK1A[60],TTAU[10],ESLOPE[5],ASLOPE[5]
       COMMON LFILES,SFE,DCL,DCC,ACL,AC1,AC2,TRL,TRC,ICON,IFROM,IOPTON
       COMMON IFILES,PTIFIL,PTIFLX,SAVEFL,PTSAVE,NTR
      COMMON LINKS,NODES,NTERMS,NUMBL,NUMBR,NUMBC,IRTN,NSWTCH,KTO,KSW
      COMMON NPRINT
      COMMON EO,BIAS1,BIAS2,AMPO,FLOW1,FLOW2
      COMMON Y,Y1,Y2,NT,NH,MODE1
      COMMON YTERM2,YTERM1,IROWT,ICOLT,ERROR1
      COMMON LOCKS,KI,KE
      COMMON IDUM,NLTRMS,DELTA,OMEGA
      COMMON NREC,MAJOR,ERROR2,ERROR3
      COMMON ETIME,ATIME,ETR,AMPTR
      COMMON LANG,START,FINISH,NSTEP
      COMMON SHORT,OPEN,LABEL,LDD,LINK1K,LINK1D,NEWPAD
      COMMON LISTE,LISTI,NUME,NUMI,JSTEP,JSTEPS,JLINE,B,PAD,LINK1S,LINK1E,LD1,LIST4
      COMMON V,VO,FLUX,VALUE,LEVER,LEVERS
      COMMON H
      COMMON LINK1A,TTAU,ESLOPE,ASLOPE,HOLD,LEAST
      COMMON LIST,LATCH,LOCK,LOCKA,LOCKB,LOCKD,LOCKF,LOCKG
      COMMON MINOR,NUMBER,PARTS,SAVE,STEP,T,TEST,THIGH,TLOW,TSTAR
      COMMON TZERO,UNIT,JX1
       DIMENSION X(1)
       DO 10 I=JX3*6+15,JX3*6+20
       IF(NPRINT(I))11,10,11
11     K=1
C
C  CODING HERE CLEANED UP...TO PUT OUTPUT ON UNIT 3 ALWAYS
C
       IF (NPRINT(16) + NPRINT(17)) 12,10,12
12     WRITE (3,100) NPRINT(I),X(NPRINT(I))
C       IF(NPRINT(16))12,13,12
C12     WRITE 3,100, NPRINT(I), X(NPRINT(I))
C13     IF(NPRINT(17))14,10,14
C14     WRITE 1,100,NPRINT(I), X(NPRINT(I))
10     CONTINUE
       IF(K)16,15,16
15     RETURN
16     K=0
       GO TO IRTN
100    FORMAT(/,I2,$ = $,E14.8)
       END
   l=+K