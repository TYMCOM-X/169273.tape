STATFIN ** FICHE/FRAME BREAK *****
ABORTED
C:ABORTED   10/21/72
C
C
       SUBROUTINE ABORTED
C
       CALL OUTPUT(1,'(ESC)$')
       RETURN
C
       END
      SUBROUTINE VERSION
C
C
       CALL DISPLAY('$B08.00$/')
C
       RETURN
C
       END
STATFIN ** FICHE/FRAME BREAK *****
ABORTED SYMSORT

SYM.  PG.LN. IDENT.

CM      1  9 G:ABORTECM      1  8 G:ABORTECM      1  5 G:ABORTE
CM      1  3 G:ABORTECMCM    1  7 G:ABORTECMCM    1  2 G:ABORTEL       1  6 G:ABORTE

STATFIN ** FICHE/FRAME BREAK *****
ANNUAL
       SUBROUTINE ANNUAL(R,N)
       INTEGER STATE
       GLOBAL SUM,STATE
       IF(N)5,10,5
5      SUM=N*((1.+R)**(1./N)-1.)
       GO TO 15
10     SUM=ALOG(1.+R)
15     DISPLAY "NOMINAL RATE OF INTEREST PER ANNUM = ",SUM
       STATE=1
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
ANNUAL SYMSORT

SYM.  PG.LN. IDENT.

10      1  7         15      1  8         5       1  5         

STATFIN ** FICHE/FRAME BREAK *****
ARR
       SUBROUTINE ARR(A,I,J,T,F)
       LOGICAL F
       GLOBAL NOOFCO,NOOFRO,SUM,TAXFREQ,BUFFER(360),STATE
       INTEGER TAXFREQ,STATE
       REAL A(NOOFCO,NOOFRO)
       IF(NOOFRO.GT.360) CALL FATALE(3)
       SUM1=0.
       SUM2=0.
       DO 10 L=1,NOOFRO
       TEMP=0.
       IF(T.GT.0.)TEMP=A(J,L)
10     BUFFER(L)=A(I,L)-TEMP
       IF(T.LE.0.) GO TO 50
       CALL TAXCOM(T)
       DO 75 L=1,NOOFRO
75     BUFFER(L)=BUFFER(L)+A(J,L)
50     DO 100 L=1,NOOFRO
       SUM1=SUM1+BUFFER(L)
100    SUM2=SUM2+A(J,L)
       SUM=SUM1/SUM2
       IF(.NOT.F) STATE=1;RETURN
       DISPLAY"AVERAGE RATE OF RETURN =  ", SUM
       STATE=1
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
ARR SYMSORT

SYM.  PG.LN. IDENT.

10      1 12         100     1 19         50      1 17         75      1 16         

STATFIN ** FICHE/FRAME BREAK *****
CALL
C:CALL   10/23/72              PARSER CALL SUBROUTINE.
C
C
       SUBROUTINE CALL(NO)
C
       NORMAL MODE IS INTEGER
C
C
       LOGICAL TALK,HUSH,ECHO,TTY
       INTEGER COM NO
       COMMON /SFE/TALK,HUSH,ECHO,TTY,COM NO
C
       COMMON /CODE/MAX CODE, P CODE, CODE(1)
C
       LOGICAL REP FLAG,  DATA IN,  FORC FLAG,  LIST FLAG,  BACK UP
       GLOBAL REP FLAG,  C COUNT,  DATA IN,  FORC FLAG,  LIST FLAG
       GLOBAL NO OF COLUMNS,  NO OF ROWS,  BACK UP
C
       LOGICAL PER FLAG
C
       REAL MKREAL
C
C
       GO TO (100, 200, 300, 400, 500, 600, 700, 800, 900, 1000,
+              1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900,
+              2000)  NO,  2100
C
C
100    P CODE=P CODE-3
       CALL RMOVE(MKREAL(CODE(P CODE-1))/MKREAL(CODE(P CODE+2)),
+              CODE(P CODE-1))
       PER FLAG=.TRUE.
       GO TO 1$
C
C
200    CALL RMOVE(MKREAL(CODE(P CODE-1))/100.0, CODE(P CODE-1))
       GO TO 1$
C
C
300    REP FLAG=.FALSE.
       C COUNT=0
       GO TO 1$
C
C
400    REP FLAG=.TRUE.
       GO TO 1$
C
C
500    C COUNT=C COUNT+1
       GO TO 1$
C
C
600    I=4
       C COUNT=0
C
       REPEAT 650,  WHILE I<=P CODE
       IF CODE(I).EQ.10 .OR. CODE(I).EQ.14,  GO TO 610
       C COUNT=C COUNT+1
       I=I+2
       GO TO 650
C
610    C COUNT=C COUNT+CODE(I+4)-CODE(I+2)+1
       I=I+5
C
650    CONTINUE
C
       CALL SET CODE(C COUNT)
       GO TO 1$
C
C
700    ESCAPE OFF
       CALL INIT MATRIX
       CLEAR SHARED PAGES 1,2
       SET SHARED REGION *, 5,6,7
       IF TALK,  CALL DISMSG(2,4)
       ESCAPE ON
       GO TO 1$
C
C
800    IF HUSH,  GO TO 1$
       CALL DISCHR(155B)
       CALL DISNUM(COM NO)
       CALL DISCHR(1R>)
       GO TO 1$
C
C
900    IF TALK,  CALL DISMSG(2,CODE(P CODE))
       P CODE=P CODE-1
       GO TO 1$
C
C
1000   C COUNT=CODE(P CODE)
       GO TO 1$
C
C
1100   FORC FLAG=.FALSE.
       GO TO 1$
C
C
1200   FORC FLAG=.TRUE.
       GO TO 1$
C
C
1300   IF TALK,  CALL DISCHR(155B)
       GO TO 1$
C
C
1400   LIST FLAG=.TRUE.
       GO TO 1$
C
C
1500   LIST FLAG=.FALSE.
       GO TO 1$
C
C
1600   I=NO OF COLUMNS
C
1605   CALL SET CODE(1)
       CALL SET CODE(2)
       CALL SET CODE(9)
       CALL SET CODE(I)
       GO TO 1$
C
C
1700   I=NO OF ROWS
       GO TO 1605
C
C
1800   CALL SET CODE(13)
       CALL SET CODE(NO OF ROWS)
       GO TO 1$
C
C
1900   C COUNT=15
       GO TO 1$
C
C
2000   IF .NOT.BACK UP,  GO TO 1$
       ESCAPE OFF
       OVERLAY WITH 'RESDATA'
       ESCAPE ON
       GO TO 1$
C
C
2100   PER FLAG=.FALSE.
       GO TO 1$
C
1$     RETURN
C
C
       END
STATFIN ** FICHE/FRAME BREAK *****
CALL SYMSORT

SYM.  PG.LN. IDENT.

+       1 18 C:CALL  +       1 15 C:CALL  +       1 14 C:CALL  
CM      2  1 C:CALL  CM      1 32 C:CALL  CM      1 12 C:CALL  CM      1 11 C:CALL  
CM      1  8 C:CALL  CM      1  7 C:CALL  CM      1  3 C:CALL  CM1$    3 11 C:CALL  
CM1605  2 31 C:CALL  CM610   1 37 C:CALL  CM650   1 39 C:CALL  CMCM    3 12 C:CALL  
CMCM    1 13 C:CALL  CMCM    1  4 C:CALL  CMCM    1  2 C:CALL  CMCM10  2 18 C:CALL  
CMCM10  1 16 C:CALL  CMCM11  2 20 C:CALL  CMCM12  2 22 C:CALL  CMCM13  2 24 C:CALL  
CMCM14  2 26 C:CALL  CMCM15  2 28 C:CALL  CMCM16  2 30 C:CALL  CMCM17  2 36 C:CALL  
CMCM18  2 38 C:CALL  CMCM19  3  2 C:CALL  CMCM20  3  4 C:CALL  CMCM20  1 21 C:CALL  
CMCM21  3  9 C:CALL  CMCM30  1 23 C:CALL  CMCM40  1 26 C:CALL  CMCM50  1 28 C:CALL  
CMCM60  1 30 C:CALL  CMCM70  2  3 C:CALL  CMCM80  2 10 C:CALL  CMCM90  2 15 C:CALL  

STATFIN ** FICHE/FRAME BREAK *****
CHECKNAME
C:CHECKNAME   03/06/72         CHECK NAME.
C
C
       LOGICAL FUNCTION CHECK NAME(FLAG)
C
       GLOBAL NO OF NODES,  P BLOCK,  BLK MAX,  BLK CODE
       GLOBAL NO OF FUNCTIONS,  NO OF BLOCKS
       GLOBAL FUNCTIONS(2,64),  BLOCKS(3,128)
       GLOBAL NAME(2)
C
       LOGICAL FLAG
C
       NORMAL MODE IS INTEGER
C
C
       CHECK NAME=.FALSE.
C
       CALL PACK NAME
C
       DO 10 I=1,NO OF FUNCTIONS
10     IF FUNCTIONS(1,I).EQ.NAME(1) .AND. FUNCTIONS(2,I).EQ.NAME(2),
+              GO TO 50
C
       DO 20 I=1,NO OF BLOCKS
       IF BLOCKS(1,I)#NAME(1) .OR. BLOCKS(2,I)#NAME(2),  GO TO 20
       IF .NOT.FLAG, GO TO 50
       IF BLOCKS(3,I)#0, GO TO 50  .ELSE. GO TO 30
20     CONTINUE
C
       IF .NOT.FLAG, RETURN
C
       IF ( (I=NO OF BLOCKS=NO OF BLOCKS+1)>BLK MAX ),
+              CALL FATAL ERROR(4)
       BLOCKS(1,I)=NAME(1)
       BLOCKS(2,I)=NAME(2)
30     BLOCKS(3,I)=NO OF NODES+1
       BLK CODE=LSH(I,17)
       P BLOCK=I
       RETURN
C
C
50     IF FLAG,  CALL ERROR(17)
       CHECK NAME=.TRUE.
       RETURN
C
C
       END
STATFIN ** FICHE/FRAME BREAK *****
CHECKNAME SYMSORT

SYM.  PG.LN. IDENT.

+       1 21 O:CHECKN+       1 13 O:CHECKN10      1 12 O:CHECKN20      1 18 O:CHECKN
30      1 24 O:CHECKNCM      1 20 O:CHECKNCM      1 19 O:CHECKN
CM      1 14 O:CHECKNCM      1 11 O:CHECKNCM      1 10 O:CHECKNCM      1  8 O:CHECKN
CM      1  7 O:CHECKNCM      1  3 O:CHECKNCMCM    1 31 O:CHECKNCMCM    1  9 O:CHECKN
CMCM    1  2 O:CHECKNCMCM50  1 28 O:CHECKN
STATFIN ** FICHE/FRAME BREAK *****
COMPILE
C:COMPILE   08/14/72           MAIN OVERLAY.
C
C
       OVERLAY COMPILE,3
C
       NORMAL MODE IS INTEGER
C
C
       SHARE BUFF(2073)
       SHARE $FILES
       SHARE SIZE,  LIST SIZE
       SHARE NO OF NODES,  NO OF FUNCTION,  NO OF BLOCKS,  NO OF NAMES
       SHARE P FUNCTION,  P BLOCK,  P TEXT,  C TEXT
       SHARE FUNCTIONS(2,64),  BLOCKS(3,128),  LISA(0/255)
       SHARE VALUE(214),  DEF(1280),  ALT(1280),  SUC(1280)
       SHARE TEXT(1749),  LIS(1536)
       EQUIVALENCE (NO OF LISTS, LISA(0))
C
C
       GLOBAL MODE
C
C
       INTEGER HEAD1(9),  HEAD2(7)
C
       DATA (BUFF(I),I=1,15)
+              /00000001B, 00000000B, 00000002B, 20400000B, 00000000B,
+               77777777B, 40000000B, 50000000B, 47624160B, 50000000B,
+               00200000B, 00000110B, 64455560B, 57620000B, 77777777B/
       DATA HEAD1
+              /40000000B, 50000000B, 54516364B, 41440000B, 00200000B,
+               00000110B, 64455560B, 57620000B, 77777777B/
       DATA HEAD2
+              /54516364B, 00000000B, 00200000B, 00000110B, 64455560B,
+               57620000B, 77777777B/
C
C
       INTEGER NAME(15),  SYMINP(2),  BINOUT(2)
       DATA SYMINP/'SYMINP'/,  BINOUT/'BINOUT'/
C
C
       LOGICAL IS TTY,  TTY,  FLAG
C
C
5      TTY=IS TTY(-1)
       IF TTY, CALL DISPLAY('CONVERT: /')
C
10     CALL NEWLINE(N)
       IF N<=0, GO TO 200
C
       IF FILE OPEN(NAME,3,IRET,SYMINP)<=0, GO TO 100
C
       IF KOMMA(0).EQ.0, GO TO 400
C
20     I=-4
       IF TTY, I=4
       IF FILE OPEN(NAME,I,IRET,BINOUT)<=0, GO TO 300
C
       OVERLAY WITH 'WORK'
C
       GO TO 900
C
100    CALL ERROR
200    IF TTY, CALL DISPLAY('FROM: /')
       GO TO 10
C
300    CALL ERROR
400    IF TTY, CALL DISPLAY('TO: /')
       CALL NEWLINE(N)
       IF N<=0, GO TO 400
       GO TO 20
C
C
C      OUTPUT SECTION.
C
900    I=2+2*NO OF NODES+P TEXT+NO OF FUNCTIONS+1+3*NO OF NAMES
       BUFF(5)=9+I+(I+7)/8-(IAND(I,7B).EQ.0)+1+3*NO OF FUNCTIONS+1+
+              9+NO OF LISTS+1+(IAND(NO OF LISTS+1,7B).EQ.0)+1+7+
+              LIST SIZE-(IAND(LIST SIZE,7B).EQ.0)+1
       BUFF(11)=BUFF(11)+I
C
       CALL OUTPUT(1,'$$DIMENSION GRAPH(/')
       CALL OUTNUM(1,I)
       CALL OUTPUT(1,'),  LIST ADDRESS(/')
       CALL OUTNUM(1,NO OF LISTS+1)
       CALL OUTPUT(1,'),  LIST(/')
       CALL OUTNUM(1,LIST SIZE)
       CALL OUTPUT(1,')$$/')
C
       MODE=0
C
       CALL SO
C
       OFFSET=2*NO OF NODES+1+P TEXT
       CALL OW(OFFSET+NO OF FUNCTIONS+2)
       CALL OW(0)
C
C
       DO 910 I=1, NO OF NODES
       CALL OW(DEF(I))
910    CALL OW(ALT(I))
C
C
       DO 920 I=1, P TEXT
920    CALL OW(TEXT(I))
C
C
       MODE=2
C
       DO 930 I=1, NO OF FUNCTIONS
930    CALL OW(I+OFFSET)
C
       MODE=0
C
C
       CALL OW(NO OF NAMES)
C
       DO 940 I=1, NO OF NAMES
       DO 940 J=1, 3
940    CALL OW(BLOCKS(J,I))
C
       CALL SB(6B7)
C
       DO 950 I=1, NO OF FUNCTIONS
       CALL REPACK(FUNCTIONS(1,I))
       CALL O(FUNCTIONS(1,I))
       CALL O(FUNCTIONS(2,I))
950    CALL O(I+OFFSET)
C
       CALL O(-1)
C
C
       HEAD1(5)=HEAD1(5)+NO OF LISTS+1
C
       DO 960 I=1,9
960    CALL O(HEAD1(I))
C
       CALL SO
C
       DO 965 I=0, NO OF LISTS
965    CALL OW(LISA(I))
C
C
       HEAD2(3)=HEAD2(3)+LIST SIZE
C
       CALL SB(5B7)
C
       DO 970 I=1,7
970    CALL O(HEAD2(I))
C
       CALL SO
C
       DO 975 I=1, LIST SIZE
975    CALL OW(LIS(I))
C
C
       CALL SB(2B7)
C
       CALL EO
C
       CLOSE 3,4
C
       DONE
C
       LOCAL SUBROUTINE ERROR
       CLOSE(-1)
       CALL DISPLAY('$?$/'),BRS(14,0,0,-1),BRS(11,0,0,-1)
       TTY=.TRUE.
       RETURN
C
       END
STATFIN ** FICHE/FRAME BREAK *****
COMPILE SYMSORT

SYM.  PG.LN. IDENT.

+       2 12 G:COMPIL+       2 11 G:COMPIL+       1 24 G:COMPIL+       1 23 G:COMPIL
+       1 21 G:COMPIL+       1 20 G:COMPIL+       1 18 G:COMPIL+       1 17 G:COMPIL
+       1 16 G:COMPIL200     2  1 G:COMPIL400     2  4 G:COMPIL910     2 28 G:COMPIL
920     2 30 G:COMPIL930     2 33 G:COMPIL940     2 38 G:COMPIL950     3  5 G:COMPIL
960     3  9 G:COMPIL965     3 12 G:COMPIL970     3 16 G:COMPIL975     3 19 G:COMPIL
CM      3 29 G:COMPILCM      3 24 G:COMPILCM      3 23 G:COMPIL
CM      3 22 G:COMPILCM      3 21 G:COMPILCM      3 18 G:COMPILCM      3 17 G:COMPIL
CM      3 15 G:COMPILCM      3 14 G:COMPILCM      3 11 G:COMPILCM      3 10 G:COMPIL
CM      3  8 G:COMPILCM      3  6 G:COMPILCM      3  1 G:COMPILCM      2 39 G:COMPIL
CM      2 36 G:COMPILCM      2 34 G:COMPILCM      2 32 G:COMPILCM      2 23 G:COMPIL
CM      2 22 G:COMPILCM      2 21 G:COMPILCM      2 14 G:COMPILCM      1 38 G:COMPIL
CM      1 37 G:COMPILCM      1 33 G:COMPILCM      1 32 G:COMPILCM      1 15 G:COMPIL
CM      1  3 G:COMPILCM10    1 30 G:COMPILCM100   1 39 G:COMPILCM20    1 34 G:COMPIL
CM300   2  3 G:COMPILCM900   2  9 G:COMPILCMCM    3 20 G:COMPILCMCM    3 13 G:COMPIL
CMCM    3  7 G:COMPILCMCM    2 35 G:COMPILCMCM    2 31 G:COMPILCMCM    2 29 G:COMPIL
CMCM    2 26 G:COMPILCMCM    1 27 G:COMPILCMCM    1 25 G:COMPILCMCM    1 14 G:COMPIL
CMCM    1 13 G:COMPILCMCM    1  4 G:COMPILCMCM    1  2 G:COMPILCMCM5   1 28 G:COMPIL
CMCMC   2  8 G:COMPIL
STATFIN ** FICHE/FRAME BREAK *****
CONST
       SUBROUTINE CONST(A,P,N,NO,I1,I2,I3,F)
       LOGICAL F,INP OK,MULTIPLE
       GLOBAL NOOFCO,NOOFRO,STATE,MULTIPLE,ROWS(2,-2:-1),NOOFPE
       INTEGER STATE,ROWS,NOOFPE
       REAL A(NOOFCO,NOOFRO)
       I=0
       IF(F) GO TO 10
       PINT=P*RATE(1)
       GO TO 15
10     PINT=0.
       I=1
15     IF(I1.EQ.0.AND.I2.EQ.0.AND.I3.EQ.0) GO TO 23
       DO 22 L=1,NOOFRO
       IF(I1.NE.0)A(I1,L)=0.
       IF(I2.NE.0) A(I2,L)=0.
22     IF(I3.NE.0) A(I3,L)=0.
23     PRPAY=A(NO,1)-PINT
       PBAL=P-PRPAY
       IF(I1.NE.0) A(I1,1)=INT(PRPAY*100.+.5)/100.
       IF(I2.NE.0) A(I2,1)=INT(PINT*100.+.5)/100.
       IF(I3.NE.0) A(I3,1)=INT(PBAL*100.+.5)/100.
       ITEMC=1
       ISMALL=N
       IF.NOT.MULTIPLE,NOOFPE=NOOFRO
       IF(N.GT.NOOFPE) ISMALL=NOOFPE
       DO 20 J=2,ISMALL
       K=ITEMC
       IF(MULTIPLE),ITEMC=ITEMC=ITEMC+ROWS(2,-(J-1));GO TO 16
       ITEMC=J
16     IF(I.EQ.0)K=ITEMC
       PINT=PBAL*RATE(K)
       PRPAY=A(NO,ITEMC)-PINT
       PBAL=PBAL-PRPAY
       IF(I1.NE.0) A(I1,ITEMC)=INT(PRPAY*100.+.5)/100.
       IF(I2.NE.0) A(I2,ITEMC)=INT(PINT*100.+.5)/100.
       IF(I3.NE.0) A(I3,ITEMC)=INT(PBAL*100.+.5)/100.
       IF(PBAL)12,25,20
12     PRPAY=PRPAY+PBAL
       PBAL=0.
       IF(I1.NE.0) A(I1,ITEMC)=INT(PRPAY*100.+.5)/100.
       IF(I2.NE.0) A(I3,ITEMC)=0.
       GO TO 25
20     CONTINUE
       DISPLAY "PAYMENT SCHEDULE INFEASIBLE."
       STATE=2
25     IF(STATE.EQ.2)RETURN
       STATE=1
       IF(I1.NE.0.OR.I2.NE.0.OR.I3.NE.0)INP OK=.FALSE.
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
CONST SYMSORT

SYM.  PG.LN. IDENT.

10      1 10         12      1 38         15      1 12         16      1 30         
20      2  4         22      1 16         23      1 17         25      2  7         

STATFIN ** FICHE/FRAME BREAK *****
A7
PVALB
NPVALB
FVALB
NFVALB
IRRB
ERRB
PAYBACKB
ARRB
TAXCOMB
PARAMETRICB
RANALB
STATFIN ** FICHE/FRAME BREAK *****
A9
INTB
ANNUALB
OPTIONB
CONSTB
SERIALB
LEVELB
EFFICIENTB
STATFIN ** FICHE/FRAME BREAK *****
COMCOMCOM
!C :COMCOMCOM  03/05/72
!C
!C
!C MAIN COMMANDS WHICH START COMMAND LINES
!C
!C
!DEFAULT TERMINATION COMMA
!NEW LIST
NEW LIST
DEFAULT
COMMENT
OPTIONS
!SYNONYMS
SFE
STANDARD FRONT END
!END SYNONYMS
SIZE
FUNCTIONS
NAME
BLOCK
END LIST
TERMINATION
!C
!C
!C OPTIONS ALLOWED ON DEFAULT AND OPTIONS COMMANDS.
!C
!C
!NEW LIST
!OPTION TERMINATION BLANK
TERMINATION
!OPTION TERMINATION BLANK
MINIMUM
EXACT
PRIORITY
NON-PRIORITY
!C
!C
!C TERMINATION TYPES.
!C
!C
!NEW LIST
ANY
NON-ALPHANUMERIC
COMMA
BLANK
!SYNONYMS
CR
CARRIAGE RETURN
!C
!C
!C END
STATFIN ** FICHE/FRAME BREAK *****
COMCOMMSG
2
35
COMMAND NUMBER TOO LARGE.  MUST BE < 512.
NUMBER TOO LARGE.  MUST BE < 4096.
RULE TOO LARGE.  MUST BE < 8.
LABEL TOO LARGE.  MUST BE < 100,000.
TERMINATION NUMBER TOO LARGE.  MUST BE < 8.
MINIMUM TOO LARGE.  MUST BE < 32.
COMMAND TOO LARGE.  MUST BE < 32.
CHARACTER MISSING.
] MISSING.
UNRECOGNIZED CHARACTERS AT END OF LINE.
LABEL NOT TERMINATED PROPERLY.
TERMINATION TYPE MISSING.
MORE THAN ONE TERMINATION SPECIFICATION IN STATEMENT.
MORE THAN ONE MINIMUM SPECIFICATION IN STATEMENT.
MORE THAN ONE PRIORITY SPECIFICATION IN STATEMENT.
UNRECOGNIZED OPTION.
NAME ALREADY IN USE.
TEXT MISSING.
STRING NOT TERMINATED PROPERLY.
NAME MISSING.
COMMAND MISSING.
NON-POSITIVE SIZE SPECIFICATION.
LABELS OUT OF SEQUENCE.
FILE #ZADGRAPH IS MISSING.
NUMBER MISSING.
NUMBER MUST BE > 0.
PREVIOUS COMMAND LIST NOT TERMINATED.$
BLOCK 
 WAS NOT DEFINED.$
NO GRAPH NAMES OCCURED.  BLOCK 
 WAS USED.$
LABEL 
 NOT DEFINED.  REFERENCE WAS AT NODE 
NO LIST CURRENTLY IN PROGRESS.
$$
10
MORE THAN 255 LIST SPECIFIED.
MORE THAN 64 FUNCTIIONS SPECIFIED.
MORE THAN 64 NAMES SPECIFIED.
MORE THAN 128 BLOCKS SPECIFIED.
MORE THAN 2048 WORDS OF COMMANDS SPECIFIED.
MORE THAN 2048 WORDS OF TEXT SPECIFIED.
MORE THAN 256 COMMANDS WERE SPECIFIED IN THE SAME COMMAND LIST.
NOT ALLOWED BEFORE FIRST GRAPH NAME.
STORAGE REQUIRED IS GREATER THAN SIZE SPECIFIED.
NO GRAPH NAMES SPECIFIED.
C
C:COMCOMMSG   03/05/72
STATFIN ** FICHE/FRAME BREAK *****
CONVERT
CONVERT IDENT  07/17/72
*
*
       BEGPR
       NOLIST  EXT,STAT
*
*
$CONVERT HEADER SETPN,4,(X,REAL,0),(L1,INTG,0),(L2,INTG,0),(L3,INTG,0)
       LDP*    X
       STA     6CEN1
       STE
       STB     6CEN2           REMOVE EXPONENT
       STX     6BE             SAVE EXPONENT
       COPY    A,B
       STB     6CEN3           SAVE THIRD WORD OF NUMBER
       STA     DE              DECIMAL EXPOMENT = 0
       STA*    L1              NO DIGITS BEFORE
       STA*    L2              NO DIGITS AFTER
       STA*    L3              NO DIGITS SIGNIFICANT
       SKE     6CEN1           IS A ZERO BEING OUTPUTTED?
       BRU     OUTRD1
       RETURN  CONVERT
OUTRD1 BSS     0
       LDA     6CEN1
       STA     ARGSGN
       SKA     =4B7
       BRM     CDB00
*
* REDUCE ARGUMENT TO NORMAL FORM
*
RNF01  SKN     6BE              TEST SIGN OF BINARY EXPONENT
       BRU     RNF04           +: REDUCE BY DIVISION
RNF02  LDA     6BE
       SKG     =-3
       BRU     RNF05
RNF03  SKG     =0
       BRU     RNF06
       MIN     DE              DE=DE+1
       BRM     FDP00           DIVIDE ARGUMENT BY 10
RNF04  LDA     6BE
       BRU     RNF03
RNF05  LDA     =-1
       ADM     DE              DE=DE-1
       BRM     FMP00           MULTIPLY ARGUEMENT BY TEN
       BRU     RNF02
RNF06  SKE     =0
       BRM     TPR00
       EAX     OUTRRC
       BRM     SICTPA          AND ADD TO NUMBER
       BRU     RNF07           NO OVERFLOW
       MIN     DE              TAKE CARE OF OVERFLOW
       LDP     TENTH
       STP     6CEN1
       LDA     TENTH2
       STA     6CEN3
RNF07  BSS     0
       LDA     DE              NUMBER OF DIGITS BEFORE DECIMAL POINT
          NDIGIT          ARE THERE TOO MANY
       SKG     =-4             OR ARE THERE TOO FEW?
       BRU     OUTEXP          YES. OUTPUT IN EXPONENTIAL FORMAT
       STA     PC              SET NUMBER OF DIGITS BEFORE COUNT
       SKA     =4B7
       COPY    A
       SUB     NDIGIT          COMPUTE NUMBER AFTER
       COPY    N
       STA     DC
       BRM     BBF00           GO OUTPUT
       COPY    A
       RETURN  CONVERT
*
* OUTPUT IN EXPONENTIAL NOTATION
*
OUTEXP BSS     0
       LDA     =1
       STA     PC              OUTPUT ONE DIGIT BEFORE DECIMAL
       LDA     NDIGIT
       SUB     =1
       STA     DC              AND THE REST AFTER
       BRM     BBF00
       LDA     =-1
       RETURN  CONVERT
*
*
BBF00  HEADER
       LDA     =-1
       STA     DCFLAG
       SKN     ARGSGN
       BRU     BBF04
       MIN*    L1
       MIN*    L3
       MIN     DCFLAG
BBF04  COPY    A
       STA     ZERO
BBF05  LDA     PC
       SKG     =0
       BRU     BBF08
       SKR     PC              PROCESS INTEGER DIGITS
       BRM     IMT00           MULTIPLY ARGUMENT BY 10
       MIN*    L1
       SKE     =0
       BRU     BBF06
       MIN     ZERO
       BRU     BBF05
BBF06  LDA     ZERO
       ADM*    L3
       MIN*    L3
       MIN     DCFLAG
       BRU     BBF04
BBF08  BSS     0
       LDA     PC
       COPY    N
       ADM     ZERO
       STA     HL2
BBF09  SKR     DC
       BRU     BBF10
       RETURN  BBF00
BBF10  BRM     IMT00           PROCESS REMAINING FRACTION DIGITS
       SKE     =0              IS IT A ZERO
       BRU     BBF11           NO. GO OUTPUT
       MIN     ZERO            YES. DON'T OUTPUT BUT REMEMBER HOW MANY
       MIN     HL2
       BRU     BBF09
BBF11  BSS     0
       LDA     ZERO            ANY ZEROS DELAYED
       SKN     DCFLAG
       ADM*    L3
       LDA     HL2
       ADM*    L2
       COPY    A
       STA     ZERO
       STA     HL2
       MIN*    L2
       MIN*    L3
       MIN     DCFLAG
       BRU     BBF09
*
TENTH  DATA    3146314B,63146314B
TENTH2 DATA    63146315B
OUTRRC DATA    0,15574B,67754727B 5*10(-11)
NDIGIT DATA    10              ALLOW 10 DIGITS FOR REAL
*
*
* DOUBLE WORD ADD. ADD WORD ADDRESS BY X TO "6CEN1,6CEN2"
*
SICDPA HEADER
       ROV
       LDA     6CEN2
       ADD     1,2
       STA     6CEN2
       LDA     6CEN1
       ADC     0,2
       STA     6CEN1
       OVT
       MIN     SICDPA
       RETURN  SICDPA
       RETURN  SICDPA
*
* TRIPLE WORD ADD. ADD WORD ADDRESSED BY X TO "6CEN1,6CEN2,6CEN3"
*
SICTPA HEADER
       ROV
       LDA     6CEN3
       ADD     2,2
       STA     6CEN3
       LDA     6CEN2
       ADC     =0
       STA     6CEN2
       LDA     6CEN1
       ADC     =0
       STA     6CEN1
       OVT
       BRU     1SICTPA
       BRM     SICDPA
       RETURN  SICTPA
1SICTP MIN     SICTPA
       RETURN  SICTPA
*
* COMPLEMENT DOUBLE PRECISION NUMBER
*
CDB00  HEADER
       LDA     6CEN3
       SKE     =0
       BRU     CDB03
       SUB     6CEN2           NEGATE TWO HIGH ORDER WORDS
       COPY    AB,A
       SUC     6CEN1
       SKA     =4B7            WAS +1 OR -1 NEGATED
       SKA     =@6B7
       BRU     CDB01           NO
       SUB     =2B7
       SKA     =4B7
       BRU     CDB02
       MIN     6BE
CDB01  BSS     0
       STP     6CEN1
       RETURN  CDB00
CDB02  BSS     0
       SKR     6BE
       BRU     CDB01
       BRU     CDB01
CDB03  BSS     0
       COPY    N               3 WORD NEGATE
       STA     6CEN3
       LDA     =-1
       SUB     6CEN2
       COPY    AB
       LDA     =-1
       SUC     6CEN1
       BRU     CDB01
*
* FLOATING DIVIDE BY TEN
*
FDP00  HEADER
       LDA     =-4
       ADM     6BE             ADJUST BINARY EXPONENT
       LDA     =24B6
       SKG     6CEN1            TEST IF RIGHT SHIFT NECESSARY
       BRU     *+2
       BRU     FDP01           NOT NEEDED
       MIN     6BE
       LDA     =-1
       BRM     TPR00
FDP01  LDP     6CEN2
       LRSH    1
       COPY    BA,B
       LRSH    1
       DIV     =24B6
       LRSH    22              POSITION IN SECOND AND THIRD WORDS
       STP     IRDT1           AND SAVE
       LDP     6CEN1
       DIV     =24B6
       STA     6CEN1            SAVE FIRST QUOTIENT
       COPY    BA,B
       DIV     =24B6
       COPY    BX,B
       LSH     1               POSITION SECOND QUOTIENT
       STA     6CEN2           AND SAVE
       COPY    XA
       DIV     =24B6
       LRSH    22              POSITION THIRD QUOTIENT
       COPY    AB,BA           ADD RESULTS OF THIRD WORD DIVIDE
       ADD     IRDT2
       COPY    AB,BA
       ADC     IRDT1
       STB     6CEN3
       ADD     6CEN2
       STA     6CEN2
       COPY    A
       ADC     6CEN1
       STA     6CEN1
       RETURN  FDP00
*
* FLOATING MULTIPLY BY TEN
*
FMP00  HEADER
       LDA     =3
       ADM     6BE             ADJUST BINARY EXPONENT
       LDP     6CEN2           UNPACK DATA
       LRSH    1               IN 6CEN2
       STA     6CEN2
       COPY    BA,B
       LRSH    1               AND
       MUL     =24B6           MULTIPLY THIRD WORD
       LRSH    22              POSITION IN WORDS 2 AND 3
       STB     6CEN3           AND SAVE
       XMA     6CEN2
       MUL     =24B6
       LSH     1
       COPY    AB,BA           ADD TO PREVIOS PRODUCT
       ADD     6CEN3
       COPY    AB,BA
       ADC     6CEN2
       STP     6CEN2
       COPY    A
       XMA     6CEN1
       MUL     =24B6           MULTIPLY FIRST WORD
       COPY    AB,BA            AND ACCUMULATE
       ADD     6CEN2
       COPY    AB,BA
       ADC     6CEN1
       STP     6CEN1
       SKA     =2B7            TEST IF PRODUCT NORMALIZED
       BRU     FMP01           IT IS
       LDA     =-1
       BRM     TPL00
       RETURN  FMP00
FMP01  MIN     6BE             CORRECT EXPONENT FOR
       RETURN  FMP00            NO POST-NORMALIZE
*
* INTEGER MULTIPLY BY TEN SUBROUTINE
*
IMT00  HEADER
       LDX     =2
       STX     IRDT4
IMT01  LDA     6CEN1,2
       MUL     =5
       STB     6CEN1,2
       SKA     =4B7
       ADD     =10
       STA     IRDT1,2
       EAX     -1,2
       SKR     IRDT4
       BRU     IMT01
       LDA     6CEN2
       ADD     IRDT3
       STA     6CEN2
       LDA     6CEN1
       ADC     IRDT2
       COPY    AB,A
       ADC     IRDT1
       LSH     1
       STA     6CEN1
       COPY    BA
       LRSH    1
       XMA     6CEN1
       RETURN  IMT00
*
* THREE-WORD LEFT-SHIFT
*
TPL00  HEADER
       COPY    N
       COPY    AX              PUT SHIFT COUNT IN X
       LDP     6CEN1
       LSH     0,2
       STA     6CEN1
       LDP     6CEN2
       LSH     0,2
       STP     6CEN2
       RETURN  TPL00
*
* THREE-WORD RIGHT-SHIFT
*
TPR00  HEADER
       COPY    N
       COPY    AX
       LDP     6CEN2
       LRSH    0,2
       STB     6CEN3
       LDP     6CEN1
       LRSH    0,2
       STP     6CEN1
       RETURN  TPR00
*
       TEMP
6CEN1  BSS     1
6CEN2  BSS     1
6CEN3  BSS     1
6BE    BSS     1
ARGSGN BSS     1
DC     BSS     1
DE     BSS     1
PC     BSS     1
DCFLAG BSS     1
IRDT1  BSS     1
IRDT2  BSS     1
IRDT3  BSS     1
IRDT4  BSS     1
ZERO   BSS     1
HL2    BSS     1
       ETEMP
*
       END
STATFIN ** FICHE/FRAME BREAK *****
CONVERT SYMSORT

SYM.  PG.LN. IDENT.

1SICTP  5 19 CONVERT 6BE     9 36 CONVERT 6CEN1   9 33 CONVERT 6CEN2   9 34 CONVERT 
6CEN3   9 35 CONVERT ARGSGN  9 37 CONVERT BBF00   3  6 CONVERT 
BBF04   3 14 CONVERT BBF05   3 16 CONVERT BBF06   3 26 CONVERT BBF08   3 31 CONVERT 
BBF09   3 36 CONVERT BBF10   3 39 CONVERT BBF11   4  6 CONVERT CDB00   5 24 CONVERT 
CDB01   5 38 CONVERT CDB02   6  2 CONVERT CDB03   6  6 CONVERT CONVER  1  8 CONVERT 
DC      9 38 CONVERT DCFLAG 10  2 CONVERT DE      9 39 CONVERT FDP00   6 18 CONVERT 
FDP01   6 28 CONVERT FMP00   7 21 CONVERT FMP01   8 14 CONVERT HL2    10  8 CONVERT 
IMT00   8 19 CONVERT IMT01   8 22 CONVERT IRDT1  10  3 CONVERT IRDT2  10  4 CONVERT 
IRDT3  10  5 CONVERT IRDT4  10  6 CONVERT NDIGIT  4 23 CONVERT OUTEXP  2 34 CONVERT 
OUTRD1  1 23 CONVERT OUTRRC  4 22 CONVERT PC     10  1 CONVERT RNF01   1 31 CONVERT 
RNF02   1 33 CONVERT RNF03   1 36 CONVERT RNF04   2  1 CONVERT RNF05   2  3 CONVERT 
RNF06   2  7 CONVERT RNF07   2 17 CONVERT SICDPA  4 28 CONVERT SICTPA  5  4 CONVERT 
TENTH   4 20 CONVERT TENTH2  4 21 CONVERT TPL00   9  8 CONVERT TPR00   9 21 CONVERT 
ZERO   10  7 CONVERT 
STATFIN ** FICHE/FRAME BREAK *****
DISP
C:DISP   O8/07/72              FINPAK PARSE MODULE.
C
C
       OVERLAY DISP,6
C
       NORMAL MODE IS INTEGER
C
C
       LOGICAL TALK,HUSH,ECHO,TTY
       INTEGER COM NO
       COMMON /SFE/TALK,HUSH,ECHO,TTY,COM NO
C
       INTEGER INPUT LINE(256), I SAVE(6)
       COMMON /LINE INPUT/INPUT LINE, I SAVE, I POINT, I COUNT, INDEX
C
       COMMON /CODE/MAX CODE, N CODE, CODE(180)
C
       LOGICAL FILE INPUT,  DATA IN,  INP OK,  APP OK
       LOGICAL NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC
       LOGICAL BACK UP,  COMPARE,  FINPAK,  IST ANALYSIS,  BAD FILE
       LOGICAL FLAG 1,  FLAG 2
       REAL TAX
C
       SHARE $FILES,  /SFE/,  /LINE INPUT/
       SHARE /CODE/
       SHARE FINPAK
       SHARE ANALYSIS(14),  NO OF ANALYSIS,  FILE NO,  COMPARE
       SHARE IST ANALYSIS,  BAD FILE
       SHARE NAME(18)
       SHARE BEGIN(9),  IN FLOW,  OUT FLOW,  TAX COLUMN,  TAX
       SHARE TAX FREQUENCY
       SHARE TITLE(2),  CPL,  C COUNT,  FLAG 1(90),  FLAG 2(9)
       SHARE FILE INPUT,  DATA IN,  INP OK,  APP OK,  STATE
       SHARE NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC,  NO OF CASES
       SHARE P COLUMNS,  P ROWS,  MAX NAMES,  BACK UP
       SHARE NAMES(423),  NO OF COLUMNS,  NO OF ROWS
       SHARE NO OF PERIODS,  COLUMNS(2,208),  ROWS(2,-2:-1)
       SHARE OVERFLOW(27)
       SHARE CRAP(500)
C
       GLOBAL SHIFT(3)
       DATA SHIFT/16, 8,0/
C
       LOGICAL PARSE
C
C
       CODE(N CODE+2)=PARSE(CODE(1))
       GO TO 1$
*
*
*
       ENTRY READ STR
C ************************
*
       CALL READ STRUCTURE(100S)
       CODE(1)=-1
C
100    GO TO 1$
C
C
C
1$     TERMINATE OVERLAY
       SUBROUTINE ERROR(ERR NO)
C
C
       CODE(1)=ERR NO
       RETURN
C
C
       END
STATFIN ** FICHE/FRAME BREAK *****
DISP SYMSORT

SYM.  PG.LN. IDENT.

+       1 27 C:DISP  +       1 12 C:DISP  C       2  3 C:DISP  
CM      1 35 C:DISP  CM      1 33 C:DISP  CM      1 16 C:DISP  CM      1 10 C:DISP  
CM      1  9 C:DISP  CM      1  7 C:DISP  CM      1  3 C:DISP  CM100   2  7 C:DISP  
CMCM    2 12 C:DISP  CMCM    2 10 C:DISP  CMCM    1 36 C:DISP  CMCM    1  4 C:DISP  
CMCM    1  2 C:DISP  CMCMCM  2  8 C:DISP  L       2  9 C:DISP  
STATFIN ** FICHE/FRAME BREAK *****
EFFICIENT
       SUBROUTINE EFFICIENT(A,IEXP,IBOUND,IRISK,F)
       GLOBAL NOOFRO,NOOFCO,STATE,ROWS(2,-2:-1),BUFFER(360)
       GLOBAL NAME(2),SPECIAL,MULTIPLE
       LOGICAL F,SPECIAL,MULTIPLE
       INTEGER STATE,ROWS,BUFFER
       REAL A(NOOFCO,NOOFRO)
       IF(NOOFRO.GT.360) CALL FATALE(3)
       DO 100 I=1,NOOFRO
100    BUFFER(I)=I
       CODE=-1
       IF(F)CODE=1
110    IVAL=0
       DO 125 I=1,(NOOFRO-1)
       IF(A(IRISK,BUFFER(I))-A(IRISK,BUFFER(I+1)))115,120,125
120    IF(CODE*(A(IEXP,BUFFER(I))-A(IEXP,BUFFER(I+1))))125,125,115
115    IVAL=BUFFER(I)
       BUFFER(I)=BUFFER(I+1)
       BUFFER(I+1)=IVAL
125    CONTINUE
       IF(IVAL)160,160,110
160    DO 200 I=1,NOOFRO-1
       IF(BUFFER(I))200,200,165
165    DO 190 J=I+1,NOOFRO
       IF(BUFFER(J))190,190,170
170    IF(CODE*(A(IEXP,BUFFER(I))-A(IEXP,BUFFER(J))))195,175,190
175    IF(A(IRISK,BUFFER(I))-A(IRISK,BUFFER(J)))195,180,195
180    IF(CODE*(A(IBOUND,BUFFER(I))-A(IBOUND,BUFFER(J))))190,185,185
185    BUFFER(J)=-BUFFER(J)
190    CONTINUE
       GO TO 200
195    BUFFER(I)=-BUFFER(I)
200    CONTINUE
       ICOUNT=0
       DISPLAY "INVESTMENTS ON THE EFFICIENT FRONTIER"
       DO 300 I=1,NOOFRO
       IF(BUFFER(I))300,250,250
250    ICOUNT=ICOUNT+1;DISPLAY" "
       IF .NOT.SPECIAL,GO TO 260
       NAME(1)=ROWS(1,-BUFFER(I))
       NAME(2)=ROWS(2,-BUFFER(I))
       GO TO 270
260    IF MULTIPLE,GO TO 265
       M=BUFFER(I)
       N=0
       GO TO 268
265    CALL GETFLOW(M,N,BUFFER(I))
268    CALL MAKERN(M,N)
270    CALL DISSYM(NAME)
300    CONTINUE
       STATE=1
       IF(ICOUNT.EQ.0) DISPLAY"NONE"
       DISPLAY" "
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
EFFICIENT SYMSORT

SYM.  PG.LN. IDENT.

100     1  9         110     1 12         115     1 16         120     1 15         
125     1 19         160     1 21         165     1 23         170     1 25         
175     1 26         180     1 27         185     1 28         190     1 29         
195     1 31         200     1 32         250     1 37         260     2  3         
265     2  7         268     2  8         270     2  9         300     2 10         

STATFIN ** FICHE/FRAME BREAK *****
ENDLIST
C:ENDLIST   03/05/72           END COMMAND LIST.
C
C
       SUBROUTINE END LIST
C
       GLOBAL COM NEXT,  NEXT COM,  LIST NO,  NO OF COMMANDS
       GLOBAL ENTRY1,  ENTRY2,  STATE,  LEVEL,  LIS(1),  LISA(0/1)
       GLOBAL DEFAULT(3,2),  CUR DEFAULT(3)
C
       NORMAL MODE IS INTEGER
C
C
       K=LISA(LIST NO)
       J=ENTRY1-K
       ENTRY1=K-1
       ENTRY2=ENTRY2-J-1
C
       DO 10 I=0,J
10     LIS(ENTRY2+I)=LIS(K+I)
C
       LISA(LIST NO)=IOR(NO OF COMMANDS*1K12, ENTRY2)
C
       COM NEXT=.FALSE.
       NEXT COM=0
       IF LEVEL.EQ.0,  GO TO 30
       CALL UNSTACK
       CALL MOVE OPTIONS(DEFAULT(1,2), CUR DEFAULT)
C
20     RETURN
C
C
30     CALL SET STATE(1)
       GO TO 20
C
       END
STATFIN ** FICHE/FRAME BREAK *****
ENDLIST SYMSORT

SYM.  PG.LN. IDENT.

10      1 12 W:ENDLISCM      1 22 W:ENDLISCM      1 14 W:ENDLIS
CM      1 13 W:ENDLISCM      1 11 W:ENDLISCM      1  6 W:ENDLISCM      1  3 W:ENDLIS
CM20    1 19 W:ENDLISCMCM    1  7 W:ENDLISCMCM    1  2 W:ENDLISCMCM30  1 20 W:ENDLIS

STATFIN ** FICHE/FRAME BREAK *****
ENDOFL
C:ENDOFL   02/11/72            END OF LINE CHECK.
C
C
       FUNCTION END OF LINE
C
       LOGICAL END OF LINE
C
C
       END OF LINE=NOWCHR(0)<0
       RETURN
C
       END
STATFIN ** FICHE/FRAME BREAK *****
ENDOFL SYMSORT

SYM.  PG.LN. IDENT.

CM      1  6 C:ENDOFLCM      1  3 C:ENDOFLCMCM    1  4 C:ENDOFL
CMCM    1  2 C:ENDOFL
STATFIN ** FICHE/FRAME BREAK *****
ERR
       SUBROUTINE ERR(A,N,M,T,F)
       LOGICAL GETBEG,F,CF,F1
       INTEGER TAXFREQ,STATE
       GLOBAL BUFFER(360),NOOFCO,NOOFRO,SUM,TAXFREQ,STATE
       REAL A(NOOFRO,NOOFCO)
       IF(NOOFRO.GT.360) CALL FATALE(3)
       CF=.FALSE.
       F1=.FALSE.
       CALL NFVAL(A,N,M,T,CF,F1)
       SUM1=SUM
       T1=0.
       CALL FVAL(A,M,T1,CF,F1)
       SUM1=SUM1+SUM
       CALL PVAL(A,M,T1,CF,F1)
       SUM2=SUM
       R=(ALOG(SUM1/SUM2))/NOOFRO
       R=EXP(R)-1.
       SUM=R
       STATE=1
       IF(.NOT.F)RETURN
       DISPLAY "EXTERNAL RATE OF RETURN PER PERIOD = ",R
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
ERR SYMSORT

SYM.  PG.LN. IDENT.


STATFIN ** FICHE/FRAME BREAK *****
FINAN1
C:FINAN1   10/21/72            FINPAK ANALYSIS OVERLAY ONE.
C
C
       OVERLAY STATA7,5
C
       NORMAL MODE IS INTEGER
C
C
       LOGICAL TALK,HUSH,ECHO,TTY
       INTEGER COM NO
       COMMON /SFE/TALK,HUSH,ECHO,TTY,COM NO
C
       INTEGER INPUT LINE(256), I SAVE(6)
       COMMON /LINE INPUT/INPUT LINE, I SAVE, I POINT, I COUNT, INDEX
C
       COMMON /CODE/MAX CODE, N CODE, CODE(180)
C
       LOGICAL FILE INPUT,  DATA IN,  INP OK,  APP OK
       LOGICAL NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC
       LOGICAL BACK UP,  COMPARE,  FINPAK,  IST ANALYSIS,  BAD FILE
       LOGICAL FLAG 1,  FLAG 2
       REAL TAX,  MATRIX
C
       SHARE MATRIX(2048)
       SHARE $FILES,  /SFE/,  /LINE INPUT/
       SHARE /CODE/
       SHARE FINPAK
       SHARE ANALYSIS(14),  NO OF ANALYSIS,  FILE NO,  COMPARE
       SHARE IST ANALYSIS,  BAD FILE
       SHARE NAME(18)
       SHARE BEGIN(9),  IN FLOW,  OUT FLOW,  TAX COLUMN,  TAX
       SHARE TAX FREQUENCY
       SHARE TITLE(2),  CPL,  C COUNT,  FLAG 1(90),  FLAG 2(9)
       SHARE FILE INPUT,  DATA IN,  INP OK,  APP OK,  STATE
       SHARE NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC,  NO OF CASES
       SHARE P COLUMNS,  P ROWS,  MAX NAMES,  BACK UP
       SHARE NAMES(423),  NO OF COLUMNS,  NO OF ROWS
       SHARE NO OF PERIODS,  COLUMNS(2,208),  ROWS(2,-2:-1)
       SHARE OVERFLOW(27)
       SHARE CRAP(500)
C
       LOGICAL FLAG,  LEV FLAG
       REAL SUM,  SUM1,  SUM2
       GLOBAL FLAG,  BUFFER(720),  SUM,  SUM1,  SUM2
       GLOBAL COL NOS(3)
       INTEGER ROW NAME(2,20)
       REAL X,  DUMMY(20,17)
C
       LOGICAL GET BEGIN
       REAL MKREAL
       EXTERNAL INT
C
C
       CONNECT OVERFLOW,  CALL ERROR(1);  GO TO 2$
C
C
       GO TO (3700, 3800, 3900, 4000, 4100, 4200, 4300, 4400, 4500,
+             4600),  CODE(2)-36,  4700
C
C
*
*
*
C      PVAL
C **************
*
3700   NUM SUM=1
       CALL SET RATE(CODE(5))
C
       X=0
       IF TAX COLUMN.EQ.CODE(4),  X=TAX
C
       CALL PVAL(MATRIX,  CODE(4),  X,  CODE(8).EQ.1,  .NOT.COMPARE)
       GO TO 1$
*
*
*
C      NPVAL
C ***************
*
3800   NUM SUM=1
       CALL SET RATE(CODE(7))
C
       X=0
       IF TAX COLUMN.EQ.CODE(4),  X=TAX
C
       CALL NPVAL(MATRIX, CODE(4), CODE(6), X, CODE(10).EQ.1, .NOT.COMPARE)
       GO TO 1$
*
*
*
C      FVAL
C **************
*
3900   NUM SUM=1
       CALL SET RATE(CODE(5))
C
       X=0
       IF TAX COLUMN.EQ.CODE(4),  X=TAX
C
       CALL FVAL(MATRIX,  CODE(4),  X,  CODE(8).EQ.1,  .NOT.COMPARE)
       GO TO 1$
*
*
*
C      NFVAL
C ***************
*
4000   NUM SUM=1
       CALL SET RATE(CODE(7))
C
       X=0
       IF TAX COLUMN.EQ.CODE(4),  X=TAX
C
       CALL NFVAL(MATRIX, CODE(4), CODE(6), X, CODE(10).EQ.1, .NOT.COMPARE)
       GO TO 1$
*
*
*
C      ERR
C *************
*
4100   NUM SUM=1
       CALL SET RATE(CODE(7))
C
       X=0
       IF TAX COLUMN.EQ.CODE(4),  X=TAX
C
       CALL ERR(MATRIX, CODE(4), CODE(6), X, .NOT.COMPARE)
       GO TO 1$
*
*
*
C      IRR
C *************
*
4200   NUM SUM=1
       X=0
       IF TAX COLUMN.EQ.CODE(4),  X=TAX
C
       CALL IRR(MATRIX, CODE(4), CODE(6), X, .NOT.COMPARE)
       GO TO 1$
*
*
*
C      ARR
C *************
*
4300   NUM SUM=1
       X=0
       IF TAX COLUMN.EQ.CODE(4),  X=TAX
C
       CALL ARR(MATRIX, CODE(4), CODE(6), X, .NOT.COMPARE)
       GO TO 1$
*
*
*
C      PAYBACK
C *****************
*
4400   NUM SUM=1
       X=0
       IF TAX COLUMN.EQ.CODE(4),  X=TAX
C
       CALL PAYBACK(MATRIX, CODE(4), CODE(6), X, .NOT.COMPARE)
       GO TO 1$
*
*
*
C      RRISK
C ***************
*
4500   I=CODE(10)
       J=0
C
4510   NUM SUM=3
       CALL SET RATE(CODE(11))
       IF CODE(15).EQ.0,  K=L=0  .ELSE.  K=CODE(16);  L=CODE(17)
C
       CALL RANAL(MATRIX, CODE(4), CODE(6), CODE(8), I, J, K, L,
+              CODE(14))
       GO TO 1$
*
*
*
C      ORISK
C ***************
*
4600   I=0
       J=CODE(10)
       GO TO 4510
*
*
*
C      PARAMETRIC
C ********************
*
4700   NUM SUM=2
       CALL SET RATE(CODE(9))
       CALL S PARAMETRIC(MATRIX, CODE(4), CODE(6), CODE(8), CODE(12),
+              .NOT.COMPARE)
       GO TO 1$
*
*
*
       ENTRY SET UP
C **********************
*
       DO 5000 I=1, NO OF ROWS
       ROWS(1,-I)=ROW NAME(1,I)
       ROWS(2,-I)=ROW NAME(2,I)
       DO 5000 J=1, NO OF COLUMNS
5000   MATRIX(J+NO OF COLUMNS*(I-1))=DUMMY(I,J)
       GO TO 5$
*
*
C
C
C
C RETURN TO MAIN OVERLAY.
C
1$     GO TO 3$
C
C
C ERROR RETURN.
C
2$     STATE=2
       IF STATE>1,  SUM=SUM1=SUM2=1E76
C
3$     IF STATE>1,  SUM=SUM1=SUM2=1E76
       IF .NOT.COMPARE,  GO TO 5$
       IF .NOT.IST ANALYSIS,  GO TO 4$
       ROW NAME(1, FILE NO)=TITLE(1)
       ROW NAME(2, FILE NO)=TITLE(2)
       IST ANALYSIS=.FALSE.
       A INDEX=0
4$     A INDEX=A INDEX+1
       DUMMY(FILE NO, A INDEX)=SUM
       IF NUM SUM>1,  A INDEX=A INDEX+1;  DUMMY(FILE NO, A INDEX)=SUM1
       IF NUM SUM>2,  A INDEX=A INDEX+1;  DUMMY(FILE NO, A INDEX)=SUM2
C
5$     TERMINATE OVERLAY
       SUBROUTINE FATAL ERROR(F ERR NO)
C
       CALL DISMSG(1,F ERR NO)
       CLOSE
       GO TO 2$
C
C
C
       SUBROUTINE ERROR(ERR NO)
C
       CALL DISMSG(2,ERR NO)
       RETURN
C
C
       END
STATFIN ** FICHE/FRAME BREAK *****
FINAN1 SYMSORT

SYM.  PG.LN. IDENT.

+       5 12 C:FINAN1+       4 31 C:FINAN1+       2  6 C:FINAN1+       1 28 C:FINAN1
+       1 12 C:FINAN13700    2 10 C:FINAN13800    2 22 C:FINAN13900    2 34 C:FINAN1
4$      6  1 C:FINAN14000    3  7 C:FINAN14100    3 19 C:FINAN14200    3 31 C:FINAN1
4300    4  3 C:FINAN14400    4 14 C:FINAN14500    4 25 C:FINAN14600    4 39 C:FINAN1
4700    5  9 C:FINAN15000    5 24 C:FINAN1C       5 18 C:FINAN1
C       5  7 C:FINAN1C       5  6 C:FINAN1C       4 37 C:FINAN1C       4 36 C:FINAN1
C       4 23 C:FINAN1C       4 22 C:FINAN1C       4 12 C:FINAN1C       4 11 C:FINAN1
C       4  1 C:FINAN1C       3 39 C:FINAN1C       3 29 C:FINAN1C       3 28 C:FINAN1
C       3 17 C:FINAN1C       3 16 C:FINAN1C       3  5 C:FINAN1C       3  4 C:FINAN1
C       2 32 C:FINAN1C       2 31 C:FINAN1C       2 20 C:FINAN1C       2 19 C:FINAN1
C       2  8 C:FINAN1CM      6 11 C:FINAN1CM      6  7 C:FINAN1CM      4 30 C:FINAN1
CM      4 17 C:FINAN1CM      4  6 C:FINAN1CM      3 34 C:FINAN1CM      3 23 C:FINAN1
CM      3 21 C:FINAN1CM      3 11 C:FINAN1CM      3  9 C:FINAN1CM      2 38 C:FINAN1
CM      2 36 C:FINAN1CM      2 26 C:FINAN1CM      2 24 C:FINAN1CM      2 14 C:FINAN1
CM      2 12 C:FINAN1CM      2  1 C:FINAN1CM      1 34 C:FINAN1CM      1 16 C:FINAN1
CM      1 10 C:FINAN1CM      1  9 C:FINAN1CM      1  7 C:FINAN1CM      1  3 C:FINAN1
CM1$    5 29 C:FINAN1CM2$    5 31 C:FINAN1CM3$    5 33 C:FINAN1CM4510  4 27 C:FINAN1
CM5$    6  5 C:FINAN1CMCM    6 13 C:FINAN1CMCM    2  5 C:FINAN1CMCM    2  4 C:FINAN1
CMCM    1  4 C:FINAN1CMCM    1  2 C:FINAN1CMCMC   5 30 C:FINAN1CMCMCM  6 10 C:FINAN1
CMCMCM  5 28 C:FINAN1L       6  6 C:FINAN1OMCM*M  2  7 C:FINAN1
STATFIN ** FICHE/FRAME BREAK *****
FINAN1FUNS
C:FINAN1FUNS   09/26/72        FINPAK ANYLYSIS OVERLAY ONE FUNCTIONS.
C
C
       LIBRARY
C
C
       SUBROUTINE PROC NAMES(A,F,ERR LABEL)
C
C
       NORMAL MODE IS INTEGER
C
       COMMON /CODE/MAX CODE, N CODE, CODE(1)
C
       LOGICAL FLAG
       GLOBAL NO OF COLUMNS,  P COLUMNS,  NAME(2)
       GLOBAL COL NOS(3),  FLAG
C
       LOGICAL F,  GEN
       INTEGER A(1)
C
       LOGICAL FIND COLUMN
C
C
       CALL SET RATE(CODE(8))
C
       GEN=.TRUE.
       I=1
       COL NOS(1)=COL NOS(2)=COL NOS(3)=0
C
       DO 20 J=1,3
       IF A(I).EQ.15,  GO TO 20
       IF F,  GO TO 5
       CALL ADD COLUMN(A(I+1),200S)
       GO TO 10
C
5      IF FIND COLUMN(A(I+1)),  GO TO 10
       CALL INS COLUMN(A(I+1), NO OF COLUMNS+1,200S)
C
10     GEN=.FALSE.
       I=I+2
       COL NOS(J)=P COLUMNS
C
20     I=I+1
C
C
       FLAG=A(I)>0
C
       IF .NOT.GEN,  GO TO 100
C
       I=0
C
       DO 50 J=1,3
C
30     I=I+1
       CALL MAKE CN(I)
       IF FIND COLUMN(NAME),  GO TO 30
C
       IF F,  GO TO 40
       CALL ADD COLUMN(NAME,200S)
       GO TO 50
C
40     CALL INS COLUMN(NAME, NO OF COLUMNS+1,200S)
C
50     COL NOS(J)=P COLUMNS
C
C
100    RETURN
C
C
200    CALL ERROR(2)
       GO TO ERR LABEL
C
C
       END
       SUBROUTINE SET RATE(A)
C
       NORMAL MODE IS INTEGER
C
       REAL MATRIX
       GLOBAL NO OF COLUMNS,  NO OF ROWS
       GLOBAL MATRIX(1)
C
       LOGICAL FLAG
       INTEGER A(3)
       REAL REAL RATE
C
       REAL MKREAL
C
C
       FLAG=A(1).EQ.5
       IF .NOT.FLAG,  GO TO 10
C
       REAL RATE=MKREAL(A(2))
       GO TO 20
C
C
10     RATE COL=A(2)
C
       (  IF .NOT.0<=MATRIX(I)<=1,  GO TO 30),
+              I=RATE COL, NO OF COLUMNS*NO OF ROWS, NO OF COLUMNS
C
C
20     RETURN
C
C
30     CALL FATAL ERROR(1)
       REAL FUNCTION RATE(ROW)
C
C
       IF .NOT.0<ROW<=NO OF ROWS,  RATE=0;  GO TO 20
C
       IF .NOT.FLAG,  GO TO 10
       RATE=REAL RATE
       GO TO 20
C
10     RATE=MATRIX(RATE COL+NO OF COLUMNS*(ROW-1))
C
C
20     RETURN
C
C
       END
STATFIN ** FICHE/FRAME BREAK *****
FINAN1FUNS SYMSORT

SYM.  PG.LN. IDENT.

+       2 19 _:FINAN1CM      2 24 _:FINAN1CM      2 18 _:FINAN1
CM      2 15 _:FINAN1CM      2 12 _:FINAN1CM      2  9 _:FINAN1CM      2  6 _:FINAN1
CM      2  5 _:FINAN1CM      1 34 _:FINAN1CM      1 30 _:FINAN1CM      1 29 _:FINAN1
CM      1 28 _:FINAN1CM      1 16 _:FINAN1CM      1 13 _:FINAN1CM      1 11 _:FINAN1
CM      1  9 _:FINAN1CM      1  6 _:FINAN1CM      1  5 _:FINAN1CM10    2 27 _:FINAN1
CM10    1 23 _:FINAN1CM20    1 26 _:FINAN1CM30    1 31 _:FINAN1CM40    1 37 _:FINAN1
CM5     1 21 _:FINAN1CM50    1 38 _:FINAN1CMCM    2 29 _:FINAN1CMCM    2 23 _:FINAN1
CMCM    2 13 _:FINAN1CMCM    2  3 _:FINAN1CMCM    1 27 _:FINAN1CMCM    1 12 _:FINAN1
CMCM    1  4 _:FINAN1CMCM    1  3 _:FINAN1CMCM    1  2 _:FINAN1CMCM10  2 17 _:FINAN1
CMCM10  1 39 _:FINAN1CMCM20  2 28 _:FINAN1CMCM20  2 20 _:FINAN1CMCM20  2  1 _:FINAN1
CMCM30  2 21 _:FINAN1L       2 22 _:FINAN1L       2  4 _:FINAN1
STATFIN ** FICHE/FRAME BREAK *****
DISPMSG
4
2
$LINE 
 OF 
7
WHAT? 


CLEARED.$
OPTIONS ARE:$  NORMAL, POISSON, EXPONETIAL, BINOMIAL, UNIFORM, OR OTHER.$$
OPTIONS ARE:$  CASH FLOWS, PROBABILISTIC, MULTIPLE, PARAMETRIC, TRIANGULAR, OR NONE.$$
OPTIONS ARE:$  STEP, LINEAR, POLYNOMIAL, XPOS, OR '=' FOLLOWED BY AN EXPRESSION.$$
0
5
CURRENT DATA HAS NOT BEEN SAVED- OK? 


CLEAR EXISTING DATA? 
ALL? 
C
C:DISPMSG   10/01/72
STATFIN ** FICHE/FRAME BREAK *****
FINAN1MSG
2
3
$THE NUMBERS IN THE RATE COLUMN ARE NOT ALL BETWEEN 0 AND 1.$$

$MORE THAN 360 ROWS.$COMMAND ABORTED.$$
12
$COMPUTATION PRODUCED EXCESSIVELY LARGE OR SMALL NUMBER.$COMMAND ABORTED.$$
$UNABLE TO ADD THE NECESSARY COLUMNS.$$





 IS A DUPLICATE COLUMN NAME.$
$MORE THAN 200 COLUMNS SPECIFIED.$
$MORE THAN 200 PERIODS SPECIFIED.$

$MORE THAN 2048 DATA ELEMENTS SPECIFIED.$
C
C:FINAN1MSG   09/26/72
STATFIN ** FICHE/FRAME BREAK *****
FINAN2
C:FINAN2   10/21/72            FINPAK ANALYSIS OVERLAY ONE.
C
C
       OVERLAY STATA9,5
C
       NORMAL MODE IS INTEGER
C
C
       LOGICAL TALK,HUSH,ECHO,TTY
       INTEGER COM NO
       COMMON /SFE/TALK,HUSH,ECHO,TTY,COM NO
C
       INTEGER INPUT LINE(256), I SAVE(6)
       COMMON /LINE INPUT/INPUT LINE, I SAVE, I POINT, I COUNT, INDEX
C
       COMMON /CODE/MAX CODE, N CODE, CODE(180)
C
       LOGICAL FILE INPUT,  DATA IN,  INP OK,  APP OK
       LOGICAL NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC
       LOGICAL BACK UP,  COMPARE,  FINPAK,  IST ANALYSIS,  BAD FILE
       LOGICAL FLAG 1,  FLAG 2
       REAL TAX,  MATRIX
C
       SHARE MATRIX(2048)
       SHARE $FILES,  /SFE/,  /LINE INPUT/
       SHARE /CODE/
       SHARE FINPAK
       SHARE ANALYSIS(14),  NO OF ANALYSIS,  FILE NO,  COMPARE
       SHARE IST ANALYSIS,  BAD FILE
       SHARE NAME(18)
       SHARE BEGIN(9),  IN FLOW,  OUT FLOW,  TAX COLUMN,  TAX
       SHARE TAX FREQUENCY
       SHARE TITLE(2),  CPL,  C COUNT,  FLAG 1(90),  FLAG 2(9)
       SHARE FILE INPUT,  DATA IN,  INP OK,  APP OK,  STATE
       SHARE NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC,  NO OF CASES
       SHARE P COLUMNS,  P ROWS,  MAX NAMES,  BACK UP
       SHARE NAMES(423),  NO OF COLUMNS,  NO OF ROWS
       SHARE NO OF PERIODS,  COLUMNS(2,208),  ROWS(2,-2:-1)
       SHARE OVERFLOW(27)
       SHARE CRAP(500)
C
       LOGICAL FLAG,  LEV FLAG
       REAL SUM,  SUM1,  SUM2
       GLOBAL FLAG,  BUFFER(720),  SUM,  SUM1,  SUM2
       GLOBAL COL NOS(3)
       INTEGER ROW NAME(2,20)
       REAL X,  DUMMY(20,17)
C
       LOGICAL GET BEGIN
       REAL MKREAL
       EXTERNAL INT
C
C
       CONNECT OVERFLOW,  CALL ERROR(1);  GO TO 2$
C
C
       GO TO (2400, 2500, 2600, 2700, 2800, 2900),  CODE(2)-23,  3000
C
C
*
*
*
C      LEVEL
C ***************
*
2400   LEV FLAG=.TRUE.
C
2410   ESCAPE OFF
       CONNECT ESCAPE,  GO TO 2480
C
       IF .NOT.DATA IN,  CALL INIT MATRIX
       CALL SAVE(0)
       IF DATA IN,  GO TO 2450
C
C ADD THE NECESSARY COLUMN NAMES, SET UP THE RATE, AND SET BEGIN FLAG.
C
       CALL PROC NAMES(CODE(11),.FALSE.,2490S)
C
C AND THE PROPER NUMBER OF ROWS.
C
       (  CALL INS ROW(I,2490S)  ),  I=1,CODE(7)
C
       DATA IN=.TRUE.
C
C
2420   ESCAPE ON
C
       IF .NOT.LEV FLAG,  GO TO 2510
       CALL LEVEL(MATRIX,MKREAL(CODE(4)),CODE(7),COL NOS(1),
+              COL NOS(2),COL NOS(3),FLAG)
       GO TO 1$
C
C INSERT THE NECESSARY COLUMNS, SET UP RATE, AND SET THE BEGIN FLAG.
C
2450   CALL PROC NAMES(CODE(11),.TRUE.,2490S)
       GO TO 2420
C
C
2480   ESCAPE OFF
       STATE=3
       GO TO 2495
C
2490   STATE=2
2495   CALL RESTORE
       DISCONNECT ESCAPE
       ESCAPE ON
       GO TO 3$
*
*
*
C      SERIAL
C ****************
*
2500   LEV FLAG=.FALSE.
       GO TO 2410
C
C
2510   CALL SERIAL(MATRIX,MKREAL(CODE(4)),CODE(7),COL NOS(1),
+              COL NOS(2),COL NOS(3),FLAG)
       GO TO 1$
*
*
*
C      EFFICIENT
C *******************
*
2600   CALL EFFICIENT(MATRIX, CODE(6), CODE(8), CODE(10), CODE(4).EQ.1)
       GO TO 3$
*
*
*
C      CONSTRAINTS
C *********************
*
2700   ESCAPE OFF
       CONNECT ESCAPE,  GO TO 2480
C
       CALL SAVE(0)
C
C INSERT THE NECESSARY COLUMNS, SET UP RATE, AND SET BEGIN FLAG.
C
       CALL PROC NAMES(CODE(13),.TRUE.,2490S)
C
       ESCAPE ON
C
       CALL CONST(MATRIX,MKREAL(CODE(4)),CODE(7),CODE(12),
+              COL NOS(1),COL NOS(2),COL NOS(3),FLAG)
       GO TO 1$
*
*
*
C      OPTION
C ****************
*
2800   ESCAPE OFF
       CONNECT ESCAPE,  GO TO 2480
C
       CALL SAVE(0)
C
C INSERT THE NECESSARY COLUMNS, SET UP RATE, AND SET BEGIN FLAG.
C
       CALL PROC NAMES(CODE(13),.TRUE.,2490S)
C
       ESCAPE ON
C
       CALL OPTION(MATRIX,MKREAL(CODE(4)),CODE(7),CODE(12),
+              COL NOS(1),COL NOS(2),COL NOS(3),FLAG)
       GO TO 1$
*
*
*
C      INT
C *************
*
2900   IF CODE(6).EQ.4,  I=CODE(7)  .ELSE.  I=0
C
       CALL INT(MKREAL(CODE(4)), I)
       GO TO 3$
*
*
*
C      ANNUAL
C ****************
*
3000   IF CODE(6).EQ.4,  I=CODE(7)  .ELSE.  I=0
C
       CALL ANNUAL(MKREAL(CODE(4)), I)
       GO TO 3$
*
C
C
C
C RETURN TO MAIN OVERLAY.
C
1$     CALL CLEAR
       DISCONNECT ESCAPE
       GO TO 3$
C
C
C ERROR RETURN.
C
2$     STATE=2
3$     TERMINATE OVERLAY
       SUBROUTINE FATAL ERROR(F ERR NO)
C
       CALL DISMSG(1,F ERR NO)
       CLOSE
       GO TO 2$
C
C
C
       SUBROUTINE ERROR(ERR NO)
C
       CALL DISMSG(2,ERR NO)
       RETURN
C
C
       END
STATFIN ** FICHE/FRAME BREAK *****
FINAN2 SYMSORT

SYM.  PG.LN. IDENT.

+       4  5 C:FINAN2+       3 29 C:FINAN2+       3  6 C:FINAN2+       2 23 C:FINAN2
+       1 28 C:FINAN2+       1 12 C:FINAN22400    2  9 C:FINAN22495    2 32 C:FINAN2
2500    3  3 C:FINAN22600    3 14 C:FINAN22700    3 22 C:FINAN22800    3 37 C:FINAN2
2900    4 13 C:FINAN23$      4 32 C:FINAN23000    4 22 C:FINAN2
C       4 20 C:FINAN2C       4 19 C:FINAN2C       4 11 C:FINAN2C       4 10 C:FINAN2
C       3 35 C:FINAN2C       3 34 C:FINAN2C       3 20 C:FINAN2C       3 19 C:FINAN2
C       3 12 C:FINAN2C       3 11 C:FINAN2C       3  1 C:FINAN2C       2 39 C:FINAN2
C       2  7 C:FINAN2CM      4 38 C:FINAN2CM      4 34 C:FINAN2CM      4 23 C:FINAN2
CM      4 14 C:FINAN2CM      4  4 C:FINAN2CM      4  3 C:FINAN2CM      4  2 C:FINAN2
CM      3 39 C:FINAN2CM      3 28 C:FINAN2CM      3 27 C:FINAN2CM      3 26 C:FINAN2
CM      3 24 C:FINAN2CM      2 21 C:FINAN2CM      2 19 C:FINAN2CM      2 18 C:FINAN2
CM      2 16 C:FINAN2CM      2 12 C:FINAN2CM      2  1 C:FINAN2CM      1 34 C:FINAN2
CM      1 16 C:FINAN2CM      1 10 C:FINAN2CM      1  9 C:FINAN2CM      1  7 C:FINAN2
CM      1  3 C:FINAN2CM1$    4 27 C:FINAN2CM2$    4 31 C:FINAN2CM2410  2 10 C:FINAN2
CM2450  2 26 C:FINAN2CM2490  2 31 C:FINAN2CMC     4  1 C:FINAN2CMC     3 25 C:FINAN2
CMC     2 25 C:FINAN2CMC     2 17 C:FINAN2CMC     2 15 C:FINAN2CMCM    5  1 C:FINAN2
CMCM    2  5 C:FINAN2CMCM    2  4 C:FINAN2CMCM    1  4 C:FINAN2CMCM    1  2 C:FINAN2
CMCM24  2 28 C:FINAN2CMCM24  2 20 C:FINAN2CMCM25  3  5 C:FINAN2CMCMC   4 30 C:FINAN2
CMCMCM  4 37 C:FINAN2CMCMCM  4 26 C:FINAN2L       4 33 C:FINAN2OMCM*M  2  6 C:FINAN2

STATFIN ** FICHE/FRAME BREAK *****
FINDATA
C:FINDATA   10/01/72           FINPAK DATA MODULE.
C
C
       OVERLAY FINDATA,5
C
       NORMAL MODE IS INTEGER
C
C
       LOGICAL TALK,HUSH,ECHO,TTY
       INTEGER COM NO
       COMMON /SFE/TALK,HUSH,ECHO,TTY,COM NO
C
       INTEGER INPUT LINE(256), I SAVE(6)
       COMMON /LINE INPUT/INPUT LINE, I SAVE, I POINT, I COUNT, INDEX
C
       COMMON /CODE/MAX CODE, N CODE, CODE(180)
C
       LOGICAL FILE INPUT,  DATA IN,  INP OK,  APP OK
       LOGICAL NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC
       LOGICAL BACK UP,  COMPARE,  FINPAK,  IST ANALYSIS,  BAD FILE
       LOGICAL FLAG 1,  FLAG 2
       REAL TAX,  MATRIX
C
       SHARE MATRIX(2048)
       SHARE $FILES,  /SFE/,  /LINE INPUT/
       SHARE /CODE/
       SHARE FINPAK
       SHARE ANALYSIS(14),  NO OF ANALYSIS,  FILE NO,  COMPARE
       SHARE IST ANALYSIS,  BAD FILE
       SHARE NAME(18)
       SHARE BEGIN(9),  IN FLOW,  OUT FLOW,  TAX COLUMN,  TAX
       SHARE TAX FREQUENCY
       SHARE TITLE(2),  CPL,  C COUNT,  FLAG 1(90),  FLAG 2(9)
       SHARE FILE INPUT,  DATA IN,  INP OK,  APP OK,  STATE
       SHARE NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC,  NO OF CASES
       SHARE P COLUMNS,  P ROWS,  MAX NAMES,  BACK UP
       SHARE NAMES(423),  NO OF COLUMNS,  NO OF ROWS
       SHARE NO OF PERIODS,  COLUMNS(2,208),  ROWS(2,-2:-1)
       SHARE OVERFLOW(27)
       SHARE MSG LIST ADDRESS(6),  MSG ADDRESS(54),  MSG TEXT(379),
     +CRAP(61)
C
       LOGICAL MOD FLAG,  ERR FLAG
       GLOBAL MOD FLAG,  ERR FLAG,  NUM INS,  INIT INS
C
       LOGICAL FLAG,  FIRST,  RED PARAMETRIC,  PAR FLAG
       REAL X, Y
C
       LOGICAL GET F 1,  GET F 2
C
*
*
*
       ENTRY INPUT
C *********************
*
       CALL INIT F 1(.TRUE.)
       CALL INIT F 2(.TRUE.)
       CALL INPUT(1,1)
       GO TO 1$
*
*
*
       ENTRY SAVE1
C *********************
*
       CALL INIT F 2(.TRUE.)
       GO TO 360
*
*
*
       ENTRY SAVE2
C *********************
*
       CALL SET FLAGS(CODE((CODE(4)+17)/3))
C
360    CALL SET SCALE(1)
       DO 380 I=0, NO OF ROW-1
       N=0
       DO 370 J=1, NO OF COLUMNS
       IF .NOT.GET F 2(J),  GO TO 370
       CALL OUTRFMT(2,MATRIX(J+NO OF COLUMNS*I),3,18,11)
       N=N+1
       K=0
       IF MOD(N,13).EQ.0,  K=155B
       CALL OUTCHR(2,K)
370    CONTINUE
380    IF K.EQ.0,  CALL OUTCHR(2,155B)
C
       ESCAPE OFF
       GO TO 1$
*
*
*
       ENTRY APPEND
C **********************
*
       IF CODE(1)>=0,  GO TO 450
       I=4
       J=1
       N=NO OF COLUMNS+1
       IF CODE(3).EQ.0,  N=NO OF ROWS+1
       GO TO 455
450    I=8
       J=2
       IF CODE(5).EQ.2,  CODE(7)=CODE(7)+1
       N=CODE(7)
C
455    IF CODE(I).EQ.6,  I=I+(CODE(I+1)+8)/3
C
       IF CODE(3).EQ.1,  GO TO 460
       CALL INIT F 2(.TRUE.)
       CALL INPUT(J,N)
       GO TO 490
C
C
460    CALL INIT F 1(.TRUE.)
       CALL INIT F 2(.FALSE.)
       NUM INS=0
       INIT INS=N
C
       ESCAPE OFF
       CALL SAVE(490S)
       FLAG=ERR FLAG=.FALSE.
C
       REPEAT 480,  WHILE CODE(I).EQ.11
       CALL INS COLUMN(CODE(I+1),N,495S)
       NUM INS=NUM INS+1
C
       IF CODE(I+3).EQ.16,  GO TO 470
       CALL SET F 2(N)
       FLAG=.TRUE.
       GO TO 475
C
470    I=I+REPLACE(N,CODE(I+4),495S)
C
475    I=I+3
       N=N+1
C
480    CONTINUE
C
       IF ERR FLAG,  GO TO 495
       IF .NOT.FLAG,  CALL CLEAR;  STATE=1;  GO TO 490
       MOD FLAG=.TRUE.
       ESCAPE ON
C
       CALL INPUT(3,1)
C
490    GO TO 1$
C
C
495    STATE=2
       CALL RESTORE
       ESCAPE ON
       GO TO 490
*
*
*
       ENTRY LIST
C ********************
*
       CALL LIST(MATRIX, CODE(1)<0)
       GO TO 1$
*
*
*
       ENTRY DELETE
C **********************
*
       FLAG=CODE(3)<=12
       CALL SET FLAGS(CODE(3))
       ESCAPE OFF
C
       IF .NOT.FLAG,  GO TO 830
C
       DO 820 I=NO OF COLUMNS,1,-1
       IF .NOT.GET F 2(I),  GO TO 820
       CALL DEL COLUMN(I)
820    CONTINUE
       GO TO 850
C
830    DO 840 I=NO OF ROWS,1,-1
       IF .NOT.GET F 1(I),  GO TO 840
       CALL DEL ROW(I)
840    CONTINUE
C
850    GO TO 1$
*
*
*
       ENTRY CHANGE
C **********************
*
       I=3
       IF CODE(3).EQ.6,  I=(CODE(4)+17)/3
       CALL SET FLAGS(CODE(I))
       CALL INPUT(4,1)
       GO TO 1$
*
*
*
       ENTRY DUPLICATE
C *************************
*
       ESCAPE OFF
       CALL SAVE(1095S)
C
       IF CODE(6).EQ.2,  CODE(8)=CODE(8)+1
C
       IF CODE(3).EQ.0,  GO TO 1050
       CALL SET FLAGS(CODE(3*CODE(4)+9))
       N=CODE(8)
C
       DO 1020 I=9,3*CODE(4)+8,3
       CALL INS COLUMN(CODE(I+1),N,495S)
1020   N=N+1
C
       J=0
       DO 1040 I=CODE(8),CODE(8)+CODE(4)-1
C
1030   J=J+1
       IF .NOT.GET F 2(J),  GO TO 1030
C
       IF J>=CODE(8),  J=J+CODE(4)
C
       (  MATRIX(I+K)=MATRIX(J+K)  ),
+              K=0, NO OF COLUMNS*NO OF ROWS-1, NO OF COLUMNS
C
1040   CONTINUE
       GO TO 1090
C
C
1050   CALL SET FLAGS(CODE(9))
C
       DO 1060 I=CODE(8),CODE(8)+CODE(4)-1
       CALL GET FLOW(NAME(1),NAME(2),I)
1060   CALL INS ROW(I,495S)
C
       J=0
       DO 1080 I=CODE(8),CODE(8)+CODE(4)-1
C
1070   J=J+1
       IF .NOT.GET F 1(J),  GO TO 1070
C
       IF J>=CODE(8),  J=J+CODE(4)
C
       M=NO OF COLUMNS*(I-1)
       N=NO OF COLUMNS*(J-1)
       (  MATRIX(M+K)=MATRIX(N+K)  ),  K=1, NO OF COLUMNS
C
1080   CONTINUE
C
C
1090   CALL CLEAR
1093   STATE=1
1095   GO TO 1$
*
*
*
       ENTRY REPLACE
C ***********************
*
       I=3
       NUM INS=0
       ESCAPE OFF
       CALL SAVE(1095S)
C
       ERR FLAG=.FALSE.
C
       REPEAT 1110,  WHILE  CODE(I).EQ.9
       I=I+REPLACE(CODE(I+1),CODE(I+3),495S)+2
1110   CONTINUE
C
       IF ERR FLAG,  GO TO 495
       GO TO 1090
C
C
1120   ERR FLAG=.TRUE.
       GO TO 1110
*
*
*
       ENTRY NUMBER
C **********************
*
       IF CODE(7).EQ.2,  CODE(9)=CODE(9)+1
C
       ESCAPE OFF
       CALL SAVE(1095S)
C
       CALL INS COLUMN(CODE(4),CODE(9),495S)
C
       J=1
       (  MATRIX(I)=J;  J=J+1  ),
+              I=CODE(9), NO OF COLUMNS*NO OF ROWS, NO OF COLUMNS
C
       GO TO 1090
*
*
*
       ENTRY RANK
C ********************
*
       IF CODE(4).EQ.2,  CODE(6)=CODE(6)+1
C
       ESCAPE OFF
       CALL SAVE(1095S)
C
       CALL INS COLUMN(CODE(8),CODE(6),495S)
C
       IF CODE(11)>=CODE(6),  CODE(11)=CODE(11)+1
C
       CALL RANK(CODE(11),CODE(6))
C
       GO TO 1090
*
*
*
       ENTRY ORDER
C *********************
*
       ESCAPE OFF
C
       CALL ORDER(CODE(5),CODE(3).EQ.0)
       GO TO 1093
*
*
*
       ENTRY COLUMNS
C ***********************
*
       CALL INIT F 2(.TRUE.)
       CALL LIST COLUMNS(0)
       GO TO 1$
*
*
*
       ENTRY NEW COLUMNS
C **************************
*
       IF CODE(CODE(1)).EQ.0,  FLAG=.FALSE.;  I=CODE(1)+1;  GO TO 100
       CALL INS COLUMN(CODE(CODE(1)+1), NO OF COLUMNS+1, 140S)
       CODE(CODE(1))=NO OF COLUMNS
       I=CODE(1)+3
C
C
100    IF CODE(I).EQ.0,  CODE(CODE(1)+1)=0;  GO TO 110
       CALL INS COLUMN(CODE(I+1), NO OF COLUMNS+1, 130S)
       CODE(CODE(1)+1)=NO OF COLUMNS
C
110    STATE=1
120    GO TO 1$
C
C
130    IF FLAG,  CALL DEL COLUMN(NO OF COLUMNS)
C
140    STATE=2
       GO TO 120
*
*
*
       ENTRY DEL COLUMNS
C ***************************
*
       IF CODE(CODE(1)+1)#0,  CALL DEL COLUMN(I=NO OF COLUMNS)
       IF CODE(CODE(1))#0,  CALL DEL COLUMN(I=NO OF COLUMNS)
       GO TO 1$
*
*
*
       ENTRY PD1 REDUCE
C **************************
*
       FLAG=.TRUE.
       GO TO 10010
*
       ENTRY PD1 P REDUCE
C ****************************
*
       FLAG=.TRUE.
       GO TO 10020
*
       ENTRY PD2 REDUCE
C **************************
*
       FLAG=.FALSE.
10010  RED PARAMETRIC=.FALSE.
       GO TO 10050
*
       ENTRY PD2 P REDUCE
C ****************************
*
       FLAG=.FALSE.
10020  RED PARAMETRIC=.TRUE.
C
10050  BAD FILE=.FALSE.
       PAR FLAG=MULTIPLE .AND. PARAMETRIC
       IF FLAG,  CALL SAVE(0)
C
       IF .NOT.PROBABILISTIC,  GO TO 10500
       FIRST=.TRUE.
       M=0
C
       NAME(3)=3HIN0
       NAME(4)=0
       NAME(5)=3HPRO
       NAME(6)=2HB0
C
       DO 10200 I=1, NO OF CASES
       IF I<10,  NAME(3)=NAME(3)+1;  NAME(6)=NAME(6)+1K8  .ELSE.
+             NAME(3)=IOR(2HIN,I/10+20B);  NAME(4)=LSH(MOD(I,10),16);
+             NAME(6)=IOR(1HB,LSH(I/10+20B,8),MOD(I,10)+20B)
       IF .NOT.FIND COLUMN(NAME(3)),  GO TO 10300
       K=P COLUMNS
       IF .NOT.FIND COLUMN(NAME(5)),  GO TO 10300
       L=P COLUMNS
C
       IF FIRST,  M1=K;  M2=L
C
       DO 10100 J=0, NO OF ROWS-1
       N=J*NO OF COLUMNS
       X=MATRIX(K+N)*MATRIX(L+N)
       IF RED PARAMETRIC,  Y=X*MATRIX(K+N)
       IF FIRST,  MATRIX(M1+N)=MATRIX(M2+N)=0
       MATRIX(M1+N)=MATRIX(M1+N)+X
10100  IF RED PARAMETRIC,  MATRIX(M2+N)=MATRIX(M2+N)+Y
C
       IF .NOT.(RED PARAMETRIC .AND. FIRST),  CALL DEL COLUMN(L)
       IF .NOT.FIRST,  CALL DEL COLUMN(K)
10200  FIRST=.FALSE.
C
       IF RED PARAMETRIC,  ( COLUMNS(1,M1)=3HMEA;  COLUMNS(2,M1)=1HN;
+                            COLUMNS(1,M2)=3HSTD;  COLUMNS(2,M2)=0 )
+              .ELSE.      ( COLUMNS(1,M1)=3HIN ;  COLUMNS(2,M1)=0 )
       IN FLOW=M1
       IF MULTIPLE .OR. RED PARAMETRIC,  GO TO 10510  .ELSE.  GO TO 10700
C
10300  CALL ERROR(26)
       IF FLAG,  CALL RESTORE
       BAD FILE=.TRUE.
       GO TO 10800
C
C
10500  IF .NOT.MULTIPLE,  GO TO 10800
C
10510  L=M1=M2=0
       RED PARAMETRIC=.FALSE.
C
       NAME(3)=3HOUT
       NAME(4)=0
       IF FIND COLUMN(NAME(3)),  L=P COLUMNS
C
       NAME(5)=2HIN
       NAME(6)=0
       IF FIND COLUMN(NAME(5)),  M1=P COLUMNS;  GO TO 10550
C
       NAME(3)=3HMEA
       NAME(4)=1HN
       IF .NOT.FIND COLUMN(NAME(3)),  GO TO 10550
       M1=P COLUMNS
       NAME(5)=3HSTD
       NAME(6)=0
       IF .NOT.FIND COLUMN(NAME(5)),  M1=0;  GO TO 10550
       M2=P COLUMNS
       RED PARAMETRIC=.TRUE.
C
10550  IF MULTIPLE,  J=NO OF PERIODS   .ELSE.  J=NO OF ROWS
       DO 10600 I=0,J-1
       N=NO OF COLUMNS*I
       IF M2#0,  ( IF PAR FLAG,  MATRIX(M2+N)=MATRIX(M2+N)*MATRIX(M2+N)
+        .ELSE.  MATRIX(M2+N)=MATRIX(M2+N)-MATRIX(M1+N)*MATRIX(M1+N) )
C
       IF .NOT.MULTIPLE,  GO TO 10600
C
       DO 10590 J=2, ROWS(2,-1-I)
       N=NO OF COLUMNS*I
       O=N+NO OF COLUMNS
       IF L#0,   MATRIX(L+N)=MATRIX(L+N)+MATRIX(L+O)
       IF M1#0,  MATRIX(M1+N)=MATRIX(M1+N)+MATRIX(M1+O)
       IF M2#0,  IF PAR FLAG,
+         MATRIX(M2+N)=MATRIX(M2+N)+MATRIX(M2+O)*MATRIX(M2+O)  .ELSE.
+         MATRIX(M2+N)=MATRIX(M2+N)+MATRIX(M2+O)-MATRIX(M1+O)*MATRIX(M1+O)
10590  CALL DEL ROW(I+2)
10600  CONTINUE
C
10700  IF .NOT.RED PARAMETRIC,  GO TO 10800
C
       DO 10750 I=0, NO OF ROWS-1
       J=I*NO OF COLUMNS
10750  MATRIX(M2+J)=SQRT(MATRIX(M2+J))
C
10800  IF FLAG,  GO TO 10900
       PROBABILISTIC=MULTIPLE=.FALSE.
       NORMAL=.NOT.(PARAMETRIC=RED PARAMETRIC)
C
10900  GO TO 1$
*
*
*
       ENTRY RES DATA
C ************************
*
       CALL RES DATA
       GO TO 1$
*
C
C
C
C RETURN TO MAIN OVERLAY.
C
1$     TERMINATE OVERLAY
       SUBROUTINE ERROR(ERR NO)
C
       CALL OUTMSG(1,1,ERR NO)
       CALL SFE CLEAR
       RETURN
C
C
       END
STATFIN ** FICHE/FRAME BREAK *****
FINDATA SYMSORT

SYM.  PG.LN. IDENT.

+      10 39 C:FINDAT+      10 38 C:FINDAT+      10 30 C:FINDAT+      10  1 C:FINDAT
+       9 39 C:FINDAT+       9 22 C:FINDAT+       9 21 C:FINDAT+       6 39 C:FINDAT
+       5 29 C:FINDAT+       1 28 C:FINDAT+       1 12 C:FINDAT10010   9  1 C:FINDAT
10020   9  8 C:FINDAT10100   9 34 C:FINDAT1020    5 22 C:FINDAT10200   9 37 C:FINDAT
10590  11  1 C:FINDAT1060    5 35 C:FINDAT10600  11  2 C:FINDAT10750  11  6 C:FINDAT
1093    6  7 C:FINDAT1095    6  8 C:FINDAT1110    6 22 C:FINDAT120     8  8 C:FINDAT
370     2 33 C:FINDAT380     2 34 C:FINDAT450     3 10 C:FINDAT820     4 29 C:FINDAT
840     4 34 C:FINDATC      11 15 C:FINDATC       9  5 C:FINDAT
C       8 37 C:FINDATC       8 31 C:FINDATC       8 25 C:FINDATC       8 16 C:FINDAT
C       7 37 C:FINDATC       7 28 C:FINDATC       7 19 C:FINDATC       7  6 C:FINDAT
C       6 31 C:FINDATC       6 13 C:FINDATC       5 12 C:FINDATC       5  1 C:FINDAT
C       4 20 C:FINDATC       4 12 C:FINDATC       3  2 C:FINDATC       2 20 C:FINDAT
C       2 12 C:FINDATC       2  2 C:FINDATCM     11 23 C:FINDATCM     11  4 C:FINDAT
CM     10 32 C:FINDATCM     10 31 C:FINDATCM     10 17 C:FINDATCM     10 14 C:FINDAT
CM     10 11 C:FINDATCM      9 38 C:FINDATCM      9 35 C:FINDATCM      9 28 C:FINDAT
CM      9 27 C:FINDATCM      9 19 C:FINDATCM      9 15 C:FINDATCM      9 12 C:FINDAT
CM      7 22 C:FINDATCM      7 14 C:FINDATCM      7 13 C:FINDATCM      7 12 C:FINDAT
CM      7 11 C:FINDATCM      7  9 C:FINDATCM      7  1 C:FINDATCM      6 37 C:FINDAT
CM      6 36 C:FINDATCM      6 34 C:FINDATCM      6 23 C:FINDATCM      6 20 C:FINDAT
CM      6 19 C:FINDATCM      6  2 C:FINDATCM      6  1 C:FINDATCM      5 36 C:FINDAT
CM      5 33 C:FINDATCM      5 28 C:FINDATCM      5 27 C:FINDATCM      5 23 C:FINDAT
CM      5 20 C:FINDATCM      5 17 C:FINDATCM      5 16 C:FINDATCM      4 26 C:FINDAT
CM      4 25 C:FINDATCM      4  2 C:FINDATCM      3 37 C:FINDATCM      3 29 C:FINDAT
CM      3 26 C:FINDATCM      3 23 C:FINDATCM      3 15 C:FINDATCM      2 35 C:FINDAT
CM      1 39 C:FINDATCM      1 37 C:FINDATCM      1 35 C:FINDATCM      1 16 C:FINDAT
CM      1 10 C:FINDATCM      1  9 C:FINDATCM      1  7 C:FINDATCM      1  3 C:FINDAT
CM*M*M  2  1 C:FINDATCM1$   11 21 C:FINDATCM1005  9  9 C:FINDATCM1030 10  4 C:FINDAT
CM1030  5 25 C:FINDATCM1040  5 30 C:FINDATCM1051 10  9 C:FINDATCM1055 10 26 C:FINDAT
CM1070 11  3 C:FINDATCM1070  5 38 C:FINDATCM1080 11  7 C:FINDATCM1080  6  5 C:FINDAT
CM1090 11 10 C:FINDATCM110   8  7 C:FINDATCM140   8 10 C:FINDATCM360   2 23 C:FINDAT
CM455   3 14 C:FINDATCM470   3 33 C:FINDATCM475   3 34 C:FINDATCM480   3 36 C:FINDAT
CM490   4  3 C:FINDATCM830   4 31 C:FINDATCM850   4 35 C:FINDATCMCM   11 26 C:FINDAT
CMCM    1  4 C:FINDATCMCM    1  2 C:FINDATCMCM10  8  4 C:FINDATCMCM10  6  6 C:FINDAT
CMCM10  5 32 C:FINDATCMCM11  6 25 C:FINDATCMCM13  8  9 C:FINDATCMCM46  3 19 C:FINDAT
CMCM49  4  4 C:FINDATCMCMCM 11 20 C:FINDATL      11 22 C:FINDATSMCM10 10  8 C:FINDAT

STATFIN ** FICHE/FRAME BREAK *****
FINDATAFUNS
C:FINDATAFUNS   04/30/72       FINDATA FUNCTIONS.
C
C
C
       SUBROUTINE SET FLAGS(A)
C
C
       NORMAL MODE IS INTEGER
C
       INTEGER A(1)
C
       LOGICAL COLS,  ROWS
C
C
       ROWS=COLS=.FALSE.
       I=1
C
       IF A(1).EQ.0,  GO TO 200
C
       CALL INIT F 1(.FALSE.)
       CALL INIT F 2(.FALSE.)
C
       REPEAT 100,  WHILE  A(I)#0
       GO TO (10, 20, 90, 90, 30) A(I)-8,  40
C
10     CALL SET F 2(A(I+1))
       COLS=.TRUE.
       GO TO 100
C
20     (  CALL SET F 2(J)  ),  J=A(I+2),A(I+4)
       COLS=.TRUE.
25     I=I+3
       GO TO 100
C
30     CALL SET F 1(A(I+1))
       ROWS=.TRUE.
       GO TO 100
C
40     (  CALL SET F 1(J)  ),  J=A(I+2),A(I+4)
       ROWS=.TRUE.
       GO TO 25
C
C
90     I=I+1
C
100    I=I+2
C
C
200    IF .NOT.ROWS,  CALL INIT F 1(.TRUE.)
       IF .NOT.COLS,  CALL INIT F 2(.TRUE.)
C
       RETURN
C
C
       END
       SUBROUTINE RANK(OLD,NEW)
C
C
       NORMAL MODE IS INTEGER
C
       REAL MATRIX
       GLOBAL MATRIX(1)
       GLOBAL NO OF COLUMNS,  NO OF ROWS
C
       REAL X, Y
C
C
       (  MATRIX(I)=0  ),
+              I=NEW, NO OF COLUMNS*NO OF ROWS, NO OF COLUMNS
C
       L=1
C
10     K=0
       X=.570E77
C
       DO 20 I=0, NO OF COLUMNS*NO OF ROWS-1, NO OF COLUMNS
       IF MATRIX(OLD+I)>X .OR. MATRIX(NEW+I)#0,  GO TO 20
       IF MATRIX(OLD+I).EQ.X,  GO TO 15
       X=MATRIX(OLD+I)
       K=0
C
15     K=K+1
C
20     CONTINUE
C
C
       IF K.EQ.0,  GO TO 40
C
       Y=0
       (  Y=Y+L  ),  L=L,L+K-1
       Y=Y/K
C
       DO 30 I=0, NO OF COLUMNS*NO OF ROWS-1, NO OF COLUMNS
30     IF MATRIX(OLD+I).EQ.X,  MATRIX(NEW+I)=Y
C
       GO TO 10
C
C
40     RETURN
C
       END
       SUBROUTINE ORDER(COL NO, FLAG)
C
C
       NORMAL MODE IS INTEGER
C
       REAL MATRIX
       GLOBAL MATRIX(1)
       GLOBAL NO OF COLUMNS,  NO OF ROWS
C
       LOGICAL SORT FLAG,  FLAG
C
C
10     SORT FLAG=.FALSE.
C
       DO 40 I=1, NO OF ROWS-1
       M=COL NO+NO OF COLUMNS*I
       N=COL NO+NO OF COLUMNS*(I-1)
       IF MATRIX(M)>=MATRIX(N),  GO TO 40
       IF FLAG,  GO TO 20
       CALL SWITCH(MATRIX(M),MATRIX(N))
       GO TO 30
C
20     (  CALL SWITCH(MATRIX(J+NO OF COLUMNS*I),
+              MATRIX(J+NO OF COLUMNS*(I-1)))  ),  J=1, NO OF COLUMNS
C
30     SORT FLAG=.TRUE.
C
40     CONTINUE
C
C
       IF SORT FLAG,  GO TO 10
C
       RETURN
C
       END
STATFIN ** FICHE/FRAME BREAK *****
FINDATAFUNS SYMSORT

SYM.  PG.LN. IDENT.

+       2 35 _:FINDAT+       1 39 _:FINDAT25      1 18 _:FINDAT30      2 16 _:FINDAT
CM      3  1 _:FINDATCM      2 39 _:FINDATCM      2 27 _:FINDAT
CM      2 25 _:FINDATCM      2 22 _:FINDATCM      2 19 _:FINDATCM      2 17 _:FINDAT
CM      2 15 _:FINDATCM      2 12 _:FINDATCM      2  4 _:FINDATCM      2  1 _:FINDAT
CM      1 37 _:FINDATCM      1 34 _:FINDATCM      1 30 _:FINDATCM      1 11 _:FINDAT
CM      1  9 _:FINDATCM      1  8 _:FINDATCM      1  5 _:FINDATCM      1  4 _:FINDAT
CM10    2  2 _:FINDATCM10    1 13 _:FINDATCM100   1 27 _:FINDATCM15    2  9 _:FINDAT
CM20    2 34 _:FINDATCM20    2 10 _:FINDATCM20    1 16 _:FINDATCM30    2 36 _:FINDAT
CM30    1 20 _:FINDATCM40    2 37 _:FINDATCM40    1 23 _:FINDATCMCM    2 38 _:FINDAT
CMCM    2 21 _:FINDATCMCM    2 11 _:FINDATCMCM    1 38 _:FINDATCMCM    1 33 _:FINDAT
CMCM    1 31 _:FINDATCMCM    1  6 _:FINDATCMCM    1  3 _:FINDATCMCM10  2 26 _:FINDAT
CMCM20  1 28 _:FINDATCMCM40  2 18 _:FINDATCMCM90  1 26 _:FINDATCMCMCM  1  2 _:FINDAT
L       2 20 _:FINDATL       1 32 _:FINDAT
STATFIN ** FICHE/FRAME BREAK *****
FINLIB
C:FINLIB   09/26/72            FINPAK LIBRARY.
C
C
       LIBRARY
C
       SUBROUTINE INIT MATRIX
C
C
       NORMAL MODE IS INTEGER
C
       LOGICAL DATA IN,  INP OK
       LOGICAL NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL
       REAL TAX
C
       GLOBAL BEGIN(9),  IN FLOW,  OUT FLOW,  TAX COLUMN,  TAX
       GLOBAL TITLE,  DATA IN,  INP OK
       GLOBAL NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL
       GLOBAL NO OF COLUMNS,  NO OF ROWS,  NO OF PERIODS,  NO OF CASES
       GLOBAL MAX NAMES
       GLOBAL COLUMNS(2,1),  ROWS(2,-2:-1)
       INTEGER C(1),  R(-4:-1)
       EQUIVALENCE (C,COLUMNS),  (R,ROWS)
C
C
C
C INITIALIZE THE FLAGS.
C
       NORMAL=PROBABILISTIC=MULTIPLE=PARAMETRIC=TRIANGULAR=SPECIAL
+              =SYMMETRIC=DATA IN=.FALSE.
       INP OK=.TRUE.
       TITLE=NO OF COLUMNS=NO OF ROWS=NO OF PERIODS=NO OF CASES=0
       (  C(I)=R(-I)=0  ), I=1,2*MAX NAMES
       (  BEGIN(I)=0  ),  I=1,9
       IN FLOW=OUT FLOW=TAX COLUMN=0
       TAX=0
C
       RETURN
       END
       SUBROUTINE MAKE CN(I)
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL NAME(2)
C
C
       IF I>=100,  GO TO 20
       NAME(2)=0
       IF I>=10,  GO TO 10
C
       NAME(1)=IOR(1HC,LSH(I+20B,8))
       GO TO 30
C
10     NAME(1)=IOR(1HC,LSH(I/10+20B,8),MOD(I,10)+20B)
       GO TO 30
C
20     NAME(1)=IOR(1HC,LSH(I/100+20B,8),MOD(I,100)/10+20B)
       NAME(2)=LSH(MOD(I,10)+20B,16)
C
C
30     RETURN
C
       END
       SUBROUTINE MAKE RN(PERIOD,FLOW)
C
C
       NORMAL MODE IS INTEGER
C
       LOGICAL MULTIPLE
C
       GLOBAL MULTIPLE
       GLOBAL NAME(2)
C
       REAL XNAME
       EQUIVALENCE (XNAME,NAME)
C
C
       NAME(3)=PERIOD/100+20B
       NAME(4)=MOD(PERIOD,100)/10+20B
       NAME(5)=MOD(PERIOD,10)+20B
       NAME(6)=1R#
C
       NAME(7)=NAME(8)=0
       IF .NOT.MULTIPLE,  GO TO 10
       IF FLOW<10,  NAME(7)=FLOW+20B;  GO TO 10
       NAME(7)=FLOW/10+20B
       NAME(8)=MOD(FLOW,10)+20B
C
C
10     NAME(1)=IOR(LSH(NAME(3),16),LSH(NAME(4),8),NAME(5))
       NAME(2)=IOR(LSH(NAME(6),16),LSH(NAME(7),8),NAME(8))
C
C
20     IF IAND(NAME(1),377K16)#1H0,  GO TO 30
       XNAME=LSHD(XNAME,8)
       GO TO 20
C
C
30     RETURN
C
       END
       SUBROUTINE LIST COLUMNS(START)
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL NO OF COLUMNS,  COLUMNS(2,1)
       GLOBAL CPL
C
       LOGICAL NAME OUT
C
       LOGICAL GET F 2
C
C
       NAME OUT=.FALSE.
       N=START
C
       DO 10 I=1, NO OF COLUMNS
       IF .NOT.GET F 2(I),  GO TO 10
       IF .NOT.NAME OUT,  CALL DISCHR(135B), DISCHR(START); GO TO 5
       CALL DISCHR(1R,)
       N=N+1
5      N=N+DISSYM(COLUMNS(1,I))
       NAME OUT=.TRUE.
       IF N+7<=CPL,  GO TO 10
       CALL DISCHR(155B)
       NAME OUT=.FALSE.
       N=START
10     CONTINUE
       IF NAME OUT,  CALL DISCHR(155B)
C
20     RETURN
C
       END
       SUBROUTINE INS COLUMN(COL NAME, COL NO, ERR LABEL)
C
C
       NORMAL MODE IS INTEGER
C
       REAL MATRIX
C
       GLOBAL MATRIX(1)
       GLOBAL NO OF COLUMNS,  NO OF ROWS,  MAX NAMES,  COLUMNS(2,1)
C
       INTEGER COL NAME(2)
C
C
       IF NO OF COLUMNS+1>MAX NAMES,
+              CALL ERROR(9);  GO TO ERR LABEL
       IF ((NO OF COLUMNS+1)*NO OF ROWS>2048),
+              CALL ERROR(12);  GO TO ERR LABEL
C
       NO OF COLUMNS=NO OF COLUMNS+1
       J=NO OF COLUMNS*NO OF ROWS
       K=MOD(COL NO, NO OF COLUMNS)
C
       DO 10 I=J-NO OF ROWS, COL NO, -1
       IF MOD(J, NO OF COLUMNS).EQ.K,  MATRIX(J)=0;  J=J-1
       MATRIX(J)=MATRIX(I)
10     J=J-1
       MATRIX(COL NO)=0
C
       DO 20 I=NO OF COLUMNS, COL NO, -1
       COLUMNS(1,I)=COLUMNS(1,I-1)
20     COLUMNS(2,I)=COLUMNS(2,I-1)
C
       COLUMNS(1, COL NO)=COL NAME(1)
       COLUMNS(2, COL NO)=COL NAME(2)
C
       RETURN
C
       END
       SUBROUTINE DEL COLUMN(COL NO)
C
C
       NORMAL MODE IS INTEGER
C
       REAL MATRIX
       GLOBAL MATRIX(1)
       GLOBAL NO OF COLUMNS,  NO OF ROWS,  COLUMNS(2,1)
C
C
       L=NO OF COLUMNS
       K=MOD(COL NO, NO OF COLUMNS)
       J=1
C
       NO OF COLUMNS=NO OF COLUMNS-1
C
       DO 10 I=1, NO OF COLUMNS*NO OF ROWS
       IF MOD(J,L).EQ.K,  J=J+1
       MATRIX(I)=MATRIX(J)
10     J=J+1
C
       DO 20 I=COL NO, NO OF COLUMNS
       COLUMNS(1,I)=COLUMNS(1,I+1)
20     COLUMNS(2,I)=COLUMNS(2,I+1)
C
       RETURN
C
       END
       LOGICAL FUNCTION ADD COLUMN(COL NAME, ERR LABEL)
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL NO OF COLUMNS,  MAX NAMES,  COLUMNS(2,1)
C
       INTEGER COL NAME(2)
C
       LOGICAL FIND COLUMN
C
C
       IF NO OF COLUMNS+1>MAX NAMES,  CALL ERROR(9);  GO TO ERR LABEL
C
       IF FIND COLUMN(COL NAME),  GO TO 10
C
       NO OF COLUMNS=NO OF COLUMNS+1
       COLUMNS(1, NO OF COLUMNS)=COL NAME(1)
       COLUMNS(2, NO OF COLUMNS)=COL NAME(2)
C
       ADD COLUMN=.TRUE.
       GO TO 20
C
C
10     ADD COLUMN=.FALSE.
C
20     RETURN
C
C
       END
       LOCAL LOGICAL FUNCTION TEST
C
C
       K=NOWCHR(1)
C
       TEST=.NOT.(1R0<=K<=1R9 .OR. 1RA<=K<=1RZ)
       RETURN
C
C
C
       LOGICAL FUNCTION PACK NAME
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL SHIFT(3)
C
       GLOBAL NAME(2)
C
       NAME(1)=NAME(2)=0
       IF .NOT.1RA<=NOWCHR(0)<=1RZ,  GO TO 2
C
C
       DO 1 I=1,2
       DO 1 J=1,3
       IF TEST,  GO TO 3
       NAME(I)=IOR(NAME(I),LSH(K,SHIFT(J)))
1      IF NEXTCHR(1).EQ.1R.,  GO TO 1
C
       IF TEST,  GO TO 3
       CALL OUTPUT(1,'$NAME IS MORE THAN SIX CHARACTERS.$/')
       CALL SFE CLEAR
C
2      PACK NAME=.FALSE.
       GO TO 4
C
C
3      PACK NAME=.TRUE.
C
4      RETURN
C
C
       END
       LOGICAL FUNCTION FIND COLUMN(COL NAME)
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL NO OF COLUMNS,  P COLUMNS,  COLUMNS(2,1)
C
       INTEGER COL NAME(2)
C
C
       DO 1 P COLUMNS=1, NO OF COLUMNS
1      IF COLUMNS(1, P COLUMNS).EQ.COL NAME(1) .AND.
+              COLUMNS(2, P COLUMNS).EQ.COL NAME(2),   GO TO 2
C
       FIND COLUMN=.FALSE.
       GO TO 3
C
C
2      FIND COLUMN=.TRUE.
C
3      RETURN
C
C
       END
       SUBROUTINE INS ROW(ROW NO, ERR LABEL)
C
C
       NORMAL MODE IS INTEGER
C
       LOGICAL MULTIPLE
       REAL MATRIX
C
       GLOBAL MATRIX(1)
       GLOBAL MULTIPLE,  NAME(2)
       GLOBAL NO OF COLUMNS,  NO OF ROWS,  MAX NAMES,  ROWS(2,-2:-1)
C
C
       IF NO OF COLUMNS*(NO OF ROWS+1)>2048,
+              CALL ERROR(12);  GO TO ERR LABEL
C
       J=NO OF COLUMNS*ROW NO
       K=NO OF COLUMNS*(ROW NO-1)
C
       IF ROW NO<=NO OF ROWS,  GO TO 10
       CALL ADD ROW(ERR LABEL)
       GO TO 30
C
C
10     DO 20 I=NO OF COLUMNS*(NO OF ROWS-ROW NO+1),1,-1
20     MATRIX(I+J)=MATRIX(I+K)
C
       NO OF ROWS=NO OF ROWS+1
C
       IF .NOT.MULTIPLE,  GO TO 30
       ROWS(2,-NAME(1))=ROWS(2,-NAME(1))+1
C
30     (  MATRIX(I+1)=0  ),  I=K, K+NO OF COLUMNS-1
C
C
       RETURN
C
       END
       SUBROUTINE DEL ROW(ROW NO)
C
C
       NORMAL MODE IS INTEGER
C
       LOGICAL MULTIPLE
       REAL MATRIX
C
       GLOBAL MATRIX(1)
       GLOBAL MULTIPLE
       GLOBAL NO OF COLUMNS,  NO OF ROWS,  NO OF PERIODS
       GLOBAL ROWS(2,-2:-1)
C
C
       J=NO OF COLUMNS*ROW NO
       K=NO OF COLUMNS*(ROW NO-1)
C
       DO 10 I=1, NO OF COLUMNS*(NO OF ROWS-ROW NO)
10     MATRIX(I+K)=MATRIX(I+J)
C
       NO OF ROWS=NO OF ROWS-1
       IF .NOT.MULTIPLE,  GO TO 20
       CALL GET FLOW(I,J,ROW NO)
C
       ROWS(2,-I)=ROWS(2,-I)-1
       IF ROWS(2,-I)>0,  GO TO 20
C
       NO OF PERIODS=NO OF PERIODS-1
       (  ROWS(1,J)=ROWS(1,J-1);  ROWS(2,J)=ROWS(2,J-1)  ),
+              J=-I, -NO OF PERIODS, -1
C
20     RETURN
C
       END
       LOGICAL FUNCTION ADD ROW(ERR LABEL)
C
C
       NORMAL MODE IS INTEGER
C
       LOGICAL MULTIPLE,  SPECIAL
C
       GLOBAL MULTIPLE,  SPECIAL
       GLOBAL NO OF PERIODS,  NO OF ROWS,  MAX NAMES,  ROWS(2,-2:-1)
       GLOBAL NAME(2)
C
       LOGICAL FIND ROW
       EXTERNAL FIND ROW
C
C
       IF .NOT. SPECIAL,  GO TO 10
       IF FIND ROW,  GO TO 200
       IF NO OF ROWS+1>MAX NAMES,  GO TO 400
C
       ROWS(1, -NO OF ROWS-1)=NAME(1)
       ROWS(2, -NO OF ROWS-1)=NAME(2)
       GO TO 100
C
C
10     IF .NOT.MULTIPLE,  GO TO 100
       IF NAME(1).EQ.NO OF PERIODS,  GO TO 20
       IF NO OF PERIODS+1>MAX NAMES,  GO TO 400
       NO OF PERIODS=NO OF PERIODS+1
       ROWS(2, -NO OF PERIODS)=1
       GO TO 100
C
20     ROWS(2, -NO OF PERIODS)=ROWS(2, -NO OF PERIODS)+1
C
C
100    NO OF ROWS=NO OF ROWS+1
       ADD ROW=.TRUE.
       GO TO 300
C
C
200    ADD ROW=.FALSE.
C
300    RETURN
C
C
400    CALL ERROR(10)
       GO TO ERR LABEL
C
C
       END
       SUBROUTINE GET FLOW(PERIOD,FLOW,ROW NO)
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL NO OF ROWS,  NO OF PERIODS,  ROWS(2,-2:-1)
C
C
       IF NO OF ROWS>=ROW NO,  GO TO 10
       PERIOD=NO OF PERIODS
       FLOW=ROWS(2,-NO OF PERIODS)+1
       GO TO 30
C
C
10     I=J=0
C
20     J=J-1
       K=I
       I=I+ROWS(2,J)
       IF ROW NO>I,  GO TO 20
C
       PERIOD=-J
       FLOW=ROW NO-K
C
C
30     RETURN
C
       END
       LOGICAL FUNCTION PACK ROW
C
C
       NORMAL MODE IS INTEGER
C
       LOGICAL MULTIPLE,  SPECIAL
C
       GLOBAL MULTIPLE,  SPECIAL
       GLOBAL NAME(2)
C
       LOGICAL PACK PERIOD,  PACK NAME
       EXTERNAL PACK PERIOD,  PACK NAME
C
C
       IF .NOT.SPECIAL,  GO TO 20
       PACK ROW=PACK NAME
10     RETURN
C
C
20     IF .NOT.(PACK ROW=PACK PERIOD),  GO TO 10
       IF .NOT.MULTIPLE,  GO TO 10
C
       PACK ROW=INTEGER(NAME(2))>0
       GO TO 10
C
C
C
C
       LOGICAL FUNCTION PACK PERIOD
C
C
       PACK PERIOD=INTEGER(NAME(1))>0
       IF .NOT.PACK PERIOD,  GO TO 10
C
       NAME(2)=0
C
       PACK PERIOD=NOWCHR(1).EQ.1R#
       CALL NEXTCHR(1)
C
10     RETURN
C
C
       END
       LOGICAL FUNCTION FIND ROW
C
C
       NORMAL MODE IS INTEGER
C
       LOGICAL MULTIPLE,  SPECIAL
C
       GLOBAL MULTIPLE,  SPECIAL
       GLOBAL NO OF PERIODS,  NO OF ROWS,  P ROWS,  ROWS(2,-2:-1)
C
       GLOBAL NAME(2)
C
C
       IF .NOT.SPECIAL,  GO TO 20
C
       DO 10 P ROWS=1, NO OF ROWS
10     IF ROWS(1, -P ROWS).EQ.NAME(1) .AND.
+              ROWS(2, -P ROWS).EQ.NAME(2),  GO TO 200
       GO TO 100
C
C
20     IF .NOT.MULTIPLE,  GO TO 30
       IF NAME(1)>NO OF PERIODS,  GO TO 100
C
       IF ROWS(2,-NAME(1))<NAME(2),  GO TO 100
C
       P ROWS=NAME(2)
       (  P ROWS=P ROWS+ROWS(2,I)  ),  I=-1, 1-NAME(1), -1
       GO TO 200
C
C
30     IF NO OF ROWS<NAME(1),  GO TO 100
       P ROWS=NAME(1)
       GO TO 200
C
C
100    FIND ROW=.FALSE.
       GO TO 300
C
C
200    FIND ROW=.TRUE.
C
300    RETURN
C
C
       END
       SUBROUTINE DUP ERROR(NAME)
C
C
       NORMAL MODE IS INTEGER
C
C
       CALL OUTCHR(1,155B)
       CALL OUTSYM(1,NAME)
       CALL ERROR(8)
C
C
       END
       SUBROUTINE SET BEGIN(COL1)
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL BEGIN(1)
C
C
       CALL LOCAL(COL1)
       BEGIN(I)=IOR(BEGIN(I),J)
       RETURN
C
C
C
       SUBROUTINE SET END(COL2)
C
       CALL LOCAL(COL2)
       BEGIN(I)=IAND(BEGIN(I),INOT(J))
       RETURN
C
C
C
       LOGICAL FUNCTION GET BEGIN(COL3)
C
       CALL LOCAL(COL3)
       GET BEGIN=BSET(BEGIN(I),J)
       RETURN
C
C
C
       LOCAL SUBROUTINE LOCAL(COL)
C
       I=(COL+23)/24
       J=LRSH(4B7,MOD(COL-1,24))
       RETURN
C
C
       END
       REAL FUNCTION MKREAL(I)
C
C
       NORMAL MODE IS INTEGER
C
       INTEGER J(2)
       EQUIVALENCE (J,MKREAL)
C
       INTEGER I(2)
C
C
       J(1)=I(1)
       J(2)=I(2)
C
       RETURN
C
C
       END
       REAL FUNCTION RMOVE(S,D)
C
C
       NORMAL MODE IS INTEGER
C
       INTEGER D(2),I(2)
       REAL S
       EQUIVALENCE (RMOVE,I)
C
C
       RMOVE=S
       D(1)=I(1)
       D(2)=I(2)
C
       RETURN
C
C
       END
       LOGICAL FUNCTION EXIST
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL NAME(1),  NAME SZ
C
       LOGICAL BRS
C
C
       I=3*LOCF(NAME)-1
       EXIST=BRS(48,I,I+NAME SZ)
C
       RETURN
C
C
       END
       SUBROUTINE INIT F 1(F)
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL FLAG1(90)
C
       LOGICAL F
C
C
       (  FLAG1(I)=F  ),  I=1,90
C
       RETURN
C
C
       END
       SUBROUTINE INIT F 2(F)
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL FLAG2(9)
C
       LOGICAL F
C
C
       (  FLAG2(I)=F  ),  I=1,9
C
       RETURN
C
C
       END
       SUBROUTINE SET F 1(N1)
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL FLAG1(1),  FLAG2(1)
C
C
       CALL LOCAL(N1)
       FLAG1(I)=IOR(FLAG1(I),J)
       RETURN
C
C
C
       SUBROUTINE SET F 2(N2)
C
       CALL LOCAL(N2)
       FLAG2(I)=IOR(FLAG2(I),J)
       RETURN
C
C
C
       LOGICAL FUNCTION GET F 1(N3)
C
       CALL LOCAL(N3)
       GET F 1=BSET(FLAG1(I),J)
       RETURN
C
C
C
       LOGICAL FUNCTION GET F 2(N4)
C
       CALL LOCAL(N4)
       GET F 2=BSET(FLAG2(I),J)
       RETURN
C
C
C
       LOCAL SUBROUTINE LOCAL(N)
C
       I=(N+23)/24
       J=LRSH(4B7,MOD(N-1,24))
       RETURN
C
C
       END
       SUBROUTINE SAVE(ESC LABEL)
C
C
       NORMAL MODE IS INTEGER
C
       COMMON /CODE/MAX CODE, N CODE, CODE(1)
C
       LOGICAL BACK UP
       GLOBAL BACK UP,  STATE
       GLOBAL NAMES(1),  MATRIX(1)
C
       LOGICAL FLAG
C
       LOGICAL ANSWER
       EXTERNAL ANSWER
C
C
       IF ESC LABEL#0,  CALL SET ESCAPE(20S)
C
       (  NAMES(I)=NAMES(I+423)  ),  I=1,423
C
       SET SHARED REGION *, 1,5,7
       (  MATRIX(I)=MATRIX(I+2048)  ),  I=1,2048
C
       IF NAMES(1)*NAMES(2)<=1024,  GO TO 10
       SET SHARED REGION *, 2,6,7
       (  MATRIX(I)=MATRIX(I+2048)  ),  I=1,2048
C
10     SET SHARED REGION *, 5,6,7
       BACK UP=.TRUE.
       RETURN
C
C
20     N CODE=1
       CODE(1)=1
       FLAG=ANSWER
       ESCAPE OFF
       IF .NOT.FLAG,  GO TO 30
       CALL CLEAR
       STATE=1
       GO TO 40
C
30     CALL RESTORE
       STATE=3
       ESCAPE ON
C
40     GO TO ESC LABEL
       SUBROUTINE RESTORE
C
C
       IF .NOT.BACK UP,  GO TO 10
C
       CALL RES DATA
C
       IF ESC LABEL#0,  DISCONNECT ESCAPE
C
10     RETURN
C
C
C
       SUBROUTINE RES DATA
C
C
       (  NAMES(I+423)=NAMES(I)  ),  I=1,423
C
       SET SHARED REGION *, 1,5,7
       (  MATRIX(I+2048)=MATRIX(I)  ),  I=1,2048
C
       IF NAMES(1)*NAMES(2)<=1024,  GO TO 10
       SET SHARED REGION *, 2,6,7
       (  MATRIX(I+2048)=MATRIX(I)  ),  I=1,2048
C
10     SET SHARED REGION *, 5,6,7
       BACK UP=.FALSE.
       RETURN
C
C
C
       SUBROUTINE CLEAR
C
C
       IF .NOT.BACK UP,  GO TO 10
       CLEAR SHARED PAGES 1,2
       BACK UP=.FALSE.
       IF ESC LABEL#0,  DISCONNECT ESCAPE
C
10     RETURN
C
C
       END
       LOGICAL FUNCTION ANSWER
C
C
       NORMAL MODE IS INTEGER
C
       LOGICAL RES CODE
       GLOBAL RES CODE
C
       LOGICAL TALK,HUSH,ECHO,TTY
       COMMON /SFE/TALK,HUSH,ECHO,TTY
C
       COMMON /CODE/MAX CODE, N CODE, CODE(1)
C
       INTEGER ARRAY(6),  ANS(5),  MASK(3)
       EQUIVALENCE (ARRAY(6),N)
       DATA ANS/3HYES, 2HYE, 1HY, 2HNO, 1HN/
       DATA MASK/77600000B, 77777400B, 77777777B/
C
C
       IF TALK,  CALL DISMSG(4,CODE(N CODE))
       N CODE=N CODE-1
C
1      N=0
       CALL GST(-1,ARRAY,18,N,ECHO)
       IF .NOT.1<=N<=3,  GO TO 50
C
       ARRAY(1)=IAND(ARRAY(1),MASK(N))
C
       (  IF ARRAY(1).EQ.ANS(I), GO TO 10  ),  I=1,5
       BACK UP=.FALSE.
       GO TO 50
C
10     ANSWER=I<=3
       RES CODE=.FALSE.
C
       RETURN
C
C
50     CALL OUTMSG(1,2,1)
       CALL SFE CLEAR
       GO TO 1
C
C
       END
STATFIN ** FICHE/FRAME BREAK *****
FINLIB SYMSORT

SYM.  PG.LN. IDENT.

+       8 29 C:FINLIB+       6 28 C:FINLIB+       5 34 C:FINLIB+       5 20 C:FINLIB
+       3 20 C:FINLIB+       3 18 C:FINLIB+       1 20 C:FINLIB+       1 12 C:FINLIB
+       1  7 C:FINLIB1       5 19 C:FINLIB1       5  5 C:FINLIB10      8 28 C:FINLIB
10      8  7 C:FINLIB10      6 20 C:FINLIB10      4  9 C:FINLIB10      3 27 C:FINLIB
10      3  7 C:FINLIB20      6  2 C:FINLIB20      4 12 C:FINLIB20      3 31 C:FINLIB
5       3  1 C:FINLIBCM     13 14 C:FINLIBCM     13  9 C:FINLIB
CM     13  8 C:FINLIBCM     12 38 C:FINLIBCM     12 37 C:FINLIBCM     12 35 C:FINLIB
CM     12 33 C:FINLIBCM     12 18 C:FINLIBCM     12 16 C:FINLIBCM     12 12 C:FINLIB
CM     12 11 C:FINLIBCM     11 30 C:FINLIBCM     11 28 C:FINLIBCM     11 27 C:FINLIB
CM     11 24 C:FINLIBCM     11 23 C:FINLIBCM     11 20 C:FINLIBCM     11 19 C:FINLIB
CM     11 13 C:FINLIBCM     11  9 C:FINLIBCM     11  5 C:FINLIBCM     11  1 C:FINLIB
CM     10 35 C:FINLIBCM     10 31 C:FINLIBCM     10 29 C:FINLIBCM     10 28 C:FINLIB
CM     10 24 C:FINLIBCM     10 22 C:FINLIBCM     10 21 C:FINLIBCM     10 17 C:FINLIB
CM     10 14 C:FINLIBCM     10 13 C:FINLIBCM     10  9 C:FINLIBCM     10  3 C:FINLIB
CM      9 38 C:FINLIBCM      9 35 C:FINLIBCM      9 33 C:FINLIBCM      9 27 C:FINLIB
CM      9 23 C:FINLIBCM      9 19 C:FINLIBCM      9 14 C:FINLIBCM      8 34 C:FINLIB
CM      8 33 C:FINLIBCM      8 27 C:FINLIBCM      8 25 C:FINLIBCM      8 23 C:FINLIB
CM      8 22 C:FINLIBCM      8 16 C:FINLIBCM      8 15 C:FINLIBCM      8 10 C:FINLIB
CM      8  3 C:FINLIBCM      8  1 C:FINLIBCM      7 39 C:FINLIBCM      7 36 C:FINLIB
CM      7 33 C:FINLIBCM      7 23 C:FINLIBCM      7  3 C:FINLIBCM      6 37 C:FINLIB
CM      6 34 C:FINLIBCM      6 33 C:FINLIBCM      6 30 C:FINLIBCM      6 26 C:FINLIB
CM      6 24 C:FINLIBCM      6 21 C:FINLIBCM      6 19 C:FINLIBCM      6 13 C:FINLIB
CM      6 11 C:FINLIBCM      6  8 C:FINLIBCM      6  4 C:FINLIBCM      6  3 C:FINLIB
CM      5 37 C:FINLIBCM      5 35 C:FINLIBCM      5 30 C:FINLIBCM      5 28 C:FINLIB
CM      5 21 C:FINLIBCM      5 17 C:FINLIBCM      5 16 C:FINLIBCM      5  6 C:FINLIB
CM      4 38 C:FINLIBCM      4 37 C:FINLIBCM      4 36 C:FINLIBCM      4 32 C:FINLIB
CM      4 25 C:FINLIBCM      4 22 C:FINLIBCM      4 21 C:FINLIBCM      4 19 C:FINLIB
CM      4 18 C:FINLIBCM      4 17 C:FINLIBCM      4 14 C:FINLIBCM      4 13 C:FINLIB
CM      4 10 C:FINLIBCM      4  6 C:FINLIBCM      4  5 C:FINLIBCM      3 38 C:FINLIB
CM      3 35 C:FINLIBCM      3 34 C:FINLIBCM      3 32 C:FINLIBCM      3 29 C:FINLIB
CM      3 24 C:FINLIBCM      3 21 C:FINLIBCM      3 16 C:FINLIBCM      3 14 C:FINLIB
CM      3 13 C:FINLIBCM      3 10 C:FINLIBCM      2 35 C:FINLIBCM      2 32 C:FINLIB
CM      2 31 C:FINLIBCM      2 29 C:FINLIBCM      2 26 C:FINLIBCM      2 15 C:FINLIB
CM      2  9 C:FINLIBCM      2  7 C:FINLIBCM      2  6 C:FINLIBCM      2  3 C:FINLIB
CM      1 35 C:FINLIBCM      1 31 C:FINLIBCM      1 27 C:FINLIBCM      1 19 C:FINLIB
CM      1  9 C:FINLIBCM      1  5 C:FINLIBCM      1  3 C:FINLIBCM1    13  5 C:FINLIB
CM10   13 12 C:FINLIBCM10   12 29 C:FINLIBCM10   12 21 C:FINLIBCM10   12 13 C:FINLIB
CM10   11 33 C:FINLIBCM10    8 18 C:FINLIBCM10    1 37 C:FINLIBCM2     5  9 C:FINLIB
CM20    7 29 C:FINLIBCM20    7 12 C:FINLIBCM20    6 29 C:FINLIBCM20    4 28 C:FINLIB
CM20    3  9 C:FINLIBCM20    1 39 C:FINLIBCM3     5 24 C:FINLIBCM30   12  5 C:FINLIB
CM30    6  6 C:FINLIBCM300   9  4 C:FINLIBCM300   7 17 C:FINLIBCM4     5 12 C:FINLIB
CM40   12  8 C:FINLIBCMCM   13 18 C:FINLIBCMCM   13  3 C:FINLIBCMCM   12 32 C:FINLIB
CMCM   12 30 C:FINLIBCMCM   12 25 C:FINLIBCMCM   12 15 C:FINLIBCMCM   12 10 C:FINLIB
CMCM   11 26 C:FINLIBCMCM   11 18 C:FINLIBCMCM   11 16 C:FINLIBCMCM   10 36 C:FINLIB
CMCM   10 34 C:FINLIBCMCM   10 32 C:FINLIBCMCM   10 30 C:FINLIBCMCM   10 27 C:FINLIB
CMCM   10 25 C:FINLIBCMCM   10 23 C:FINLIBCMCM   10 20 C:FINLIBCMCM   10 18 C:FINLIB
CMCM   10 15 C:FINLIBCMCM   10 12 C:FINLIBCMCM   10 10 C:FINLIBCMCM   10  6 C:FINLIB
CMCM   10  2 C:FINLIBCMCM    9 39 C:FINLIBCMCM    9 36 C:FINLIBCMCM    9 32 C:FINLIB
CMCM    9 30 C:FINLIBCMCM    9 15 C:FINLIBCMCM    9 13 C:FINLIBCMCM    9 11 C:FINLIB
CMCM    9  8 C:FINLIBCMCM    9  7 C:FINLIBCMCM    9  5 C:FINLIBCMCM    8 26 C:FINLIB
CMCM    8 21 C:FINLIBCMCM    8 19 C:FINLIBCMCM    8 13 C:FINLIBCMCM    8  5 C:FINLIB
CMCM    7 38 C:FINLIBCMCM    7 24 C:FINLIBCMCM    7 22 C:FINLIBCMCM    7 20 C:FINLIB
CMCM    6 39 C:FINLIBCMCM    6 32 C:FINLIBCMCM    6 17 C:FINLIBCMCM    6 10 C:FINLIB
CMCM    6  7 C:FINLIBCMCM    5 33 C:FINLIBCMCM    5 27 C:FINLIBCMCM    5 25 C:FINLIB
CMCM    5 18 C:FINLIBCMCM    5 15 C:FINLIBCMCM    5 13 C:FINLIBCMCM    5  1 C:FINLIB
CMCM    4 35 C:FINLIBCMCM    4 31 C:FINLIBCMCM    4 29 C:FINLIBCMCM    4 20 C:FINLIB
CMCM    4 16 C:FINLIBCMCM    4  2 C:FINLIBCMCM    3 37 C:FINLIBCMCM    3 17 C:FINLIB
CMCM    3 12 C:FINLIBCMCM    2 33 C:FINLIBCMCM    2 28 C:FINLIBCMCM    2 11 C:FINLIB
CMCM    2  5 C:FINLIBCMCM    1 32 C:FINLIBCMCM    1 30 C:FINLIBCMCM    1  4 C:FINLIB
CMCM    1  2 C:FINLIBCMCM10  9  1 C:FINLIBCMCM10  7 28 C:FINLIBCMCM10  7 13 C:FINLIB
CMCM10  7  6 C:FINLIBCMCM10  6  1 C:FINLIBCMCM10  4 27 C:FINLIBCMCM10  2 20 C:FINLIB
CMCM2   5 23 C:FINLIBCMCM20 11 36 C:FINLIBCMCM20  9  3 C:FINLIBCMCM20  8 31 C:FINLIB
CMCM20  8  8 C:FINLIBCMCM20  7 16 C:FINLIBCMCM20  2 22 C:FINLIBCMCM3   5 11 C:FINLIB
CMCM30  8 37 C:FINLIBCMCM30  7 35 C:FINLIBCMCM30  2 25 C:FINLIBCMCM30  2  2 C:FINLIB
CMCM40  7 18 C:FINLIBCMCM50 13 15 C:FINLIBCMCMCM 12 24 C:FINLIBCMCMCM 12 14 C:FINLIB
CMCMCM 11 12 C:FINLIBCMCMCM 11  8 C:FINLIBCMCMCM 11  4 C:FINLIBCMCMCM 10 39 C:FINLIB
CMCMCM  9 26 C:FINLIBCMCMCM  9 22 C:FINLIBCMCMCM  9 18 C:FINLIBCMCMCM  8 12 C:FINLIB
CMCMCM  4 34 C:FINLIBCMCMCM  1 18 C:FINLIBL      12 31 C:FINLIBL      12  9 C:FINLIB
L      11 17 C:FINLIBL      10 33 C:FINLIBL      10 26 C:FINLIBL      10 19 C:FINLIB
L      10 11 C:FINLIBL      10  1 C:FINLIBL       9 31 C:FINLIBL       9 12 C:FINLIB
L       9  6 C:FINLIBL       8 20 C:FINLIBL       7 37 C:FINLIBL       7 21 C:FINLIB
L       6 31 C:FINLIBL       6  9 C:FINLIBL       5 26 C:FINLIBL       5 14 C:FINLIB
L       4 30 C:FINLIBL       4 15 C:FINLIBL       3 36 C:FINLIBL       3 11 C:FINLIB
L       2 27 C:FINLIBL       2  4 C:FINLIBL       1 29 C:FINLIB
STATFIN ** FICHE/FRAME BREAK *****
FINDNAME
C:FINDNAME   02/15/72          FIND NAME AND RETURN TRUE IF FUNCTION.
C
C
       FUNCTION FIND NAME
C
       GLOBAL NO OF NODES,  BLK MAX
       GLOBAL NO OF FUNCTIONS,  P FUNCTION,  NO OF BLOCKS,  P BLOCK
       GLOBAL FUNCTIONS(2,64),  BLOCKS(3,128)
       GLOBAL NAME(2)
C
       LOGICAL FIND NAME
C
       NORMAL MODE IS INTEGER
C
C
       DO 10 I=1, NO OF FUNCTIONS
       IF FUNCTIONS(1,I)#NAME(1) .OR. FUNCTIONS(2,I)#NAME(2),
+              GO TO 10
C
       P FUNCTION=I
       FIND NAME=.TRUE.
5      RETURN
C
10     CONTINUE
C
C
       CALL GET BLOCK
       FIND NAME=.FALSE.
       GO TO 5
C
C
C
       FUNCTION GET BLOCK
C
       DO 10 P BLOCK=1, NO OF BLOCKS
10     IF BLOCKS(1,P BLOCK).EQ.NAME(1) .AND. BLOCKS(2,P BLOCK).EQ.NAME(2),
+              GO TO 20
C
       IF ( (P BLOCK=NO OF BLOCKS=NO OF BLOCKS+1)>BLK MAX ),
+              CALL FATAL ERROR(4)
       BLOCKS(1,P BLOCK)=NAME(1)
       BLOCKS(2,P BLOCK)=NAME(2)
       BLOCKS(3,P BLOCK)=0
20     GET BLOCK=LSH(P BLOCK,17)
       RETURN
C
       END
STATFIN ** FICHE/FRAME BREAK *****
FINDNAME SYMSORT

SYM.  PG.LN. IDENT.

+       1 24 O:FINDNA+       1 22 O:FINDNA+       1 11 O:FINDNA10      1 21 O:FINDNA
20      1 28 O:FINDNA5       1 14 O:FINDNACM      1 30 O:FINDNA
CM      1 23 O:FINDNACM      1 20 O:FINDNACM      1 12 O:FINDNACM      1  8 O:FINDNA
CM      1  7 O:FINDNACM      1  3 O:FINDNACM10    1 15 O:FINDNACMCM    1 16 O:FINDNA
CMCM    1  9 O:FINDNACMCM    1  2 O:FINDNACMCMCM  1 19 O:FINDNA
STATFIN ** FICHE/FRAME BREAK *****
FINPAKFUNS
C:FINPAKFUNS   10/04/72        FINPAK FUNCTIONS.
C
C
C
       SUBROUTINE GET STRUCTURE(ERR LABEL)
C
C
       NORMAL MODE IS INTEGER
C
C
       COMMON /CODE/MAX CODE, N CODE, CODE(1)
C
       LOGICAL NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL
       GLOBAL IN FLOW,  OUT FLOW
       GLOBAL NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL
       GLOBAL NO OF COLUMNS,  NO OF ROWS,  NO OF CASES
C
       GLOBAL NAME(6),  LOW,  MOST,  HIGH,  MEAN,  STD
C
       INTEGER IN(2),  OUT(2),  MEAN(2),  STD(2),  LOW(2),  MOST(2),
+              HIGH(2)
       DATA IN/'IN'/,  OUT/'OUT'/,  MEAN/'MEAN'/,  STD/'STD'/,
+              LOW/'LOW'/,  MOST/'MOST'/,  HIGH/'HIGH'/
C
       INTEGER STRUCTURE(2)
       DATA STRUCTURE/'STRUCTURE'/
C
       LOGICAL PARSE,  ADD COLUMN
C
C
       CALL INIT MATRIX
C
       POINTER=0
C
C TRY TO GET THE INFO FROM THE USER.
C
       CALL PARSE(STRUCTURE)
C
C NOW GO SORT IT OUT.
C
       GO TO (10, 20, 30, 40, 50, 55) CODE(2),  60
C
C
C NO SPECIAL FORMAT.
C
10     NORMAL=.TRUE.
       GO TO 55
C
C
C PROBABILISTIC.
C
20     PROBABILISTIC=.TRUE.
       NO OF CASES=CODE(POINTER+4)
       MULTIPLE=CODE(POINTER+5)>0
C
25     POINTER=POINTER+6
       GO TO 100
C
C
C MULTIPLE.
C
30     MULTIPLE=.TRUE.
       PROBABILISTIC=CODE(POINTER+3)>0
       IF .NOT.PROBABILISTIC,  GO TO 47
       NO OF CASES=CODE(POINTER+5)
       GO TO 25
C
C
C PARAMETRIC.
C
40     PARAMETRIC=.TRUE.
C
45     MULTIPLE=CODE(POINTER+3)>0
47     POINTER=POINTER+4
       GO TO 100
C
C
C TRIANGULAR.
C
50     TRIANGULAR=.TRUE.
C
55     POINTER=POINTER+3
       GO TO 100
C
C
C WE HAD TO QUIZ HIM.
C
60     POINTER=1
C
C WAS IT PROBABILISTIC.
       IF CODE(3)>0,  GO TO 20
C
C HOW ABOUT PARAMETRIC.
       POINTER=POINTER+1
       IF CODE(4)>0,  GO TO 40
C
C HOW ABOUT MULTIPLE.
       IF CODE(5)>0,  GO TO 45
C
C HOW ABOUT TRIANGULAR.
       POINTER=POINTER+2
       IF CODE(6)>0,  GO TO 50
C
C MUST BE NORMAL.
       POINTER=POINTER+1
       CODE(2)=6
       GO TO 55
C
C
C ADD THE NECESSARY COLUMNS.
C
100    IF CODE(2).EQ.6,  GO TO 500
       IF .NOT. TRIANGULAR,  GO TO 200
       CALL ADD COLUMN(LOW, ERR LABEL)
       CALL ADD COLUMN(MOST, ERR LABEL)
       CALL ADD COLUMN(HIGH, ERR LABEL)
       GO TO 500
C
C
200    CALL ADD COLUMN(OUT, ERR LABEL)
       OUT FLOW=NO OF COLUMNS
       CALL SET BEGIN(NO OF COLUMNS)
C
       IF .NOT.PROBABILISTIC,  GO TO 300
C
       NAME(3)=3HIN0
       NAME(4)=0
       NAME(5)=3HPRO
       NAME(6)=2HB0
C
       DO 210 I=1, NO OF CASES
       IF I<10,  NAME(3)=NAME(3)+1;  NAME(6)=NAME(6)+1K8  .ELSE.
+             NAME(3)=IOR(2HIN,I/10+20B);  NAME(4)=LSH(MOD(I,10),16);
+             NAME(6)=IOR(1HB,LSH(I/10+20B,8),MOD(I,10)+20B)
       CALL ADD COLUMN(NAME(3), ERR LABEL)
210    CALL ADD COLUMN(NAME(5), ERR LABEL)
       GO TO 500
C
C
300    IF .NOT.PARAMETRIC,  GO TO 400
C
       CALL ADD COLUMN(MEAN, ERR LABEL)
       IN FLOW=NO OF COLUMNS
       CALL ADD COLUMN(STD, ERR LABEL)
       GO TO 500
C
C
400    CALL ADD COLUMN(IN, ERR LABEL)
       INFLOW=NO OF COLUMNS
C
C
C NOW ADD THE EXTRA COLUMNS.
C
500    IF CODE(POINTER)-4,  700,505,600
C
505    DO 510 I=1,CODE(POINTER+1)
       CALL MAKE CN(I)
510    CALL ADD COLUMN(NAME(1), ERR LABEL)
       GO TO 700
C
C
600    DO 610 I=POINTER, N CODE, 3
610    IF .NOT.ADD COLUMN(CODE(I+1), ERR LABEL),
+              CALL DUP ERROR(CODE(I+1));  GO TO ERR LABEL
C
C
700    RETURN
C
C
       END
       SUBROUTINE WRITE STRUCTURE
C
C
       NORMAL MODE IS INTEGER
C
       LOGICAL PROBABILISTIC,  MULTIPLE,  PARAMETRIC,  TRIANGULAR,
+              SPECIAL
       GLOBAL IN FLOW,  OUT FLOW,  TITLE(2)
       GLOBAL PROBABILISTIC,  MULTIPLE,  PARAMETRIC,  TRIANGULAR,
+              SPECIAL
       GLOBAL NO OF CASES,  NO OF COLUMNS,  NO OF ROWS
       GLOBAL COLUMNS(2,1),  ROWS(2,-2:-1)
       GLOBAL NAME(2)
C
C
C START WITH THE TITLE.
C
       CALL OUTMSG(3,3,1)
       CALL OUTSYM(3,TITLE)
C
C CASH FLOWS.
C
       IF OUT FLOW.EQ.0,  GO TO 10
       CALL OUTMSG(3,3,2)
       CALL OUTSYM(3,COLUMNS(1, OUT FLOW))
C
10     IF IN FLOW.EQ.0,  GO TO 20
       CALL OUTMSG(3,3,3)
       CALL OUTSYM(3,COLUMNS(1, IN FLOW))
C
C DATA TYPE.
C
20     IF PROBABILISTIC,  CALL OUTMSG(3,3,4), OUTNUM(3, NO OF CASES)
       IF MULTIPLE,  CALL OUTMSG(3,3,5)
       IF PARAMETRIC,  CALL OUTMSG(3,3,6)
       IF TRIANGULAR,  CALL OUTMSG(3,3,7)
       IF SPECIAL,  CALL OUTMSG(3,3,8)
C
C DIMENSIONS.
C
       CALL OUTCHR(3,155B)
       CALL OUTNUM(3, NO OF ROWS)
       CALL OUTCHR(3,1R,)
       CALL OUTNUM(3, NO OF COLUMNS)
       CALL OUTCHR(3,155B)
C
C ROWS.
C
       DO 30 I=1, NO OF ROWS
       IF .NOT.SPECIAL,  GO TO 23
       CALL OUTSYM(3,ROWS(1,-I))
       GO TO 30
C
23     IF .NOT.MULTIPLE,  GO TO 25
       CALL GET FLOW(PERIOD,FLOW,I)
       GO TO 28
C
25     PERIOD=I
       FLOW=0
C
28     CALL MAKE RN(PERIOD,FLOW)
       CALL OUTSYM(3,NAME)
C
30     CALL OUTCHR(3,155B)
C
C COLUMNS.
C
       DO 40 I=1, NO OF COLUMNS
       IF GET BEGIN(I),  CALL OUTMSG(3,3,9)
       CALL OUTSYM(3,COLUMNS(1,I))
40     CALL OUTCHR(3,155B)
C
C
       RETURN
C
       END
       LOGICAL FUNCTION OPEN DATA(LABEL,/SIM ESC(I)/)
C
C
       NORMAL MODE IS INTEGER
C
       COMMON /CODE/MAX CODE, N CODE, CODE(1)
C
C
       GLOBAL NAME(1),  NAME SZ
C
       LOGICAL PARSE,  CK FILE
       EXTERNAL CK FILE
C
C
       IF I>0,  ASSIGN 20 TO SIM ESC(1)
C
C OPEN THE STRUCTURE FILE AFTER PROMPTING  'OLD/NEW' MESSAGE.
C
       CALL ADD TO FILE(CODE(4), NAME, 3HNAM)
       NAME SZ=CODE(4)+7
       IF .NOT.(OPEN DATA=CK FILE),  GO TO 10
C
       CALL SET ESCAPE(20S)
C
       OPEN OUTPUT,3 :  NAME,  ERROR CALL ERROR(15);  GO TO 20
C
C OPEN THE DATA FILE.
C
       CALL ADD TO FILE(CODE(4), NAME, 3HDAT)
       OPEN OUTPUT,2 :  NAME,  ERROR CALL ERROR(16);  GO TO 20
C
10     RETURN
C
C
20     ESCAPE OFF
       CLOSE
       CALL ADD TO FILE(CODE(4), NAME, 3HNAM)
       CALL IADEL(NAME)
       CALL ADD TO FILE(CODE(4), NAME, 3HDAT)
       CALL IADEL(NAME)
       GO TO LABEL
C
C
       END
       LOGICAL FUNCTION CK FILE
C
       NORMAL MODE IS INTEGER
C
       COMMON /CODE/MAX CODE, N CODE, CODE(1)
C
       LOGICAL EXIST,  ANSWER
       EXTERNAL EXIST,  ANSWER
C
C
       N CODE=1
       CODE(1)=2+EXIST
       IF .NOT.(CK FILE=ANSWER),  CALL ERROR(19)
       RETURN
C
C
       END
STATFIN ** FICHE/FRAME BREAK *****
FINPAKFUNS SYMSORT

SYM.  PG.LN. IDENT.

+       3 33 _:FINPAK+       3 30 _:FINPAK+       3 24 _:FINPAK+       3  5 _:FINPAK
+       3  4 _:FINPAK+       1 15 _:FINPAK+       1 13 _:FINPAK+       1  9 _:FINPAK
+       1  6 _:FINPAK210     3  7 _:FINPAK40      4 37 _:FINPAK47      2  4 _:FINPAK
510     3 20 _:FINPAK610     3 23 _:FINPAKCM      5 29 _:FINPAK
CM      5 28 _:FINPAKCM      5 27 _:FINPAKCM      5 15 _:FINPAKCM      5 13 _:FINPAK
CM      5 12 _:FINPAKCM      5  9 _:FINPAKCM      5  5 _:FINPAKCM      5  3 _:FINPAK
CM      4 39 _:FINPAKCM      4 34 _:FINPAKCM      4 21 _:FINPAKCM      4 15 _:FINPAK
CM      4  2 _:FINPAKCM      3 38 _:FINPAKCM      3 29 _:FINPAKCM      3 10 _:FINPAK
CM      3  2 _:FINPAKCM      2 37 _:FINPAKCM      2 36 _:FINPAKCM      1 24 _:FINPAK
CM      1 22 _:FINPAKCM      1 20 _:FINPAKCM      1 18 _:FINPAKCM      1 16 _:FINPAK
CM      1 12 _:FINPAKCM      1 11 _:FINPAKCM      1  5 _:FINPAKCM10    5 17 _:FINPAK
CM10    4  5 _:FINPAKCM10    1 26 _:FINPAKCM100   2 27 _:FINPAKCM20    4  9 _:FINPAK
CM20    1 29 _:FINPAKCM23    4 25 _:FINPAKCM25    4 28 _:FINPAKCM25    1 32 _:FINPAK
CM28    4 30 _:FINPAKCM30    4 32 _:FINPAKCM30    1 35 _:FINPAKCM40    2  2 _:FINPAK
CM45    2  3 _:FINPAKCM50    2  7 _:FINPAKCM500   3 17 _:FINPAKCM505   3 18 _:FINPAK
CM55    2  8 _:FINPAKCM60    2 11 _:FINPAKCMC     5 14 _:FINPAKCMC     5  8 _:FINPAK
CMC     4 33 _:FINPAKCMC     4 20 _:FINPAKCMC     4 14 _:FINPAKCMC     4  8 _:FINPAK
CMC     4  1 _:FINPAKCMC     2 22 _:FINPAKCMC     2 19 _:FINPAKCMC     2 17 _:FINPAK
CMC     2 14 _:FINPAKCMC     2 12 _:FINPAKCMC     1 23 _:FINPAKCMC     1 21 _:FINPAK
CMCM    5 35 _:FINPAKCMCM    5 31 _:FINPAKCMCM    5 25 _:FINPAKCMCM    5  7 _:FINPAK
CMCM    5  4 _:FINPAKCMCM    5  2 _:FINPAKCMCM    4 38 _:FINPAKCMCM    3 28 _:FINPAK
CMCM    3 26 _:FINPAKCMCM    1 19 _:FINPAKCMCM    1  4 _:FINPAKCMCM    1  3 _:FINPAK
CMCM20  5 18 _:FINPAKCMCM20  2 33 _:FINPAKCMCM30  3  9 _:FINPAKCMCM40  3 14 _:FINPAK
CMCM60  3 22 _:FINPAKCMCM70  3 25 _:FINPAKCMCMC   3 37 _:FINPAKCMCMC   3 16 _:FINPAK
CMCMC   2 26 _:FINPAKCMCMC   2 10 _:FINPAKCMCMC   2  6 _:FINPAKCMCMC   2  1 _:FINPAK
CMCMC   1 34 _:FINPAKCMCMC   1 28 _:FINPAKCMCMC   1 25 _:FINPAKCMCMCM  1  2 _:FINPAK
L       5 26 _:FINPAKL       5  1 _:FINPAKL       3 27 _:FINPAK
STATFIN ** FICHE/FRAME BREAK *****
FINPARFUNS
C:FINPARFUNS   10/21/72        FINPAK PARSER FUNCTIONS.
C
C
       LIBRARY
C
C
       LOGICAL FUNCTION EXPLAIN
C
C
       NORMAL MODE IS INTEGER
C
       LOGICAL FINPAK
       GLOBAL FINPAK
C
C
       I=KOMMAND(1)
       IF I<=0,  GO TO 10
       IF .NOT.FINPAK,  ( IF 24<=I<=49,  GO TO 10 )
       IF I>400,  I=I-325
       CALL SET CODE(I)
       EXPLAIN=.TRUE.
       GO TO 20
C
10     EXPLAIN=.FALSE.
C
20     RETURN
C
       END
       LOCAL LOGICAL FUNCTION LOCAL(RED PARAMETRIC)
C
C
       NORMAL MODE IS INTEGER
C
       LOGICAL PROBABILISTIC,  MULTIPLE,  BACK UP,  COMPARE,  BAD FILE
       GLOBAL PROBABILISTIC,  MULTIPLE,  BACK UP,  COMPARE,  BAD FILE
C
       LOGICAL RED PARAMETRIC
       INTEGER NAMES(2,4)
       DATA ( ( NAMES(I,J), I=1,2 ), J=1,4 )
+              /'PD1','RED', 'PD1','PRE', 'PD2','RED', 'PD2','PRE'/
C
C
       IF BACK UP .OR. .NOT.(PROBABILISTIC .OR. MULTIPLE),  GO TO 100
C
       ESCAPE OFF
       OVERLAY WITH NAMES(1,1-2*COMPARE-RED PARAMETRIC)
       LOCAL=.NOT.BAD FILE
       ESCAPE ON
       GO TO 200
C
C
100    LOCAL=.TRUE.
C
200    RETURN
C
C
C
       LOGICAL FUNCTION PROC DATA
C
C
       PROC DATA=LOCAL(.FALSE.)
C
       RETURN
C
C
C
       LOGICAL FUNCTION PROC P DATA
C
C
       PROC P DATA=LOCAL(.TRUE.)
C
       RETURN
C
       END
       LOGICAL FUNCTION OCNAME
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL P COLUMNS,  NAME(2),  NO OF COLUMNS
C
       LOGICAL PACK NAME,  FIND COLUMN
       EXTERNAL PACK NAME
C
C
       IF NOWCHR(0).EQ.1R$,  CALL NEXTCHR(0);  P COLUMNS=NO OF COLUMNS
+              ;  GO TO 5
C
       IF .NOT.PACK NAME,  GO TO 10
       IF .NOT.FIND COLUMN(NAME),  GO TO 10
C
5      CALL SET CODE(9)
       CALL SET CODE(P COLUMNS)
C
       OCNAME=.TRUE.
       GO TO 20
C
10     OCNAME=.FALSE.
C
20     RETURN
C
C
       END
       LOGICAL FUNCTION NCNAME
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL NAME(2)
C
       LOGICAL PACK NAME,  FIND COLUMN
       EXTERNAL PACK NAME
C
C
       IF .NOT.PACK NAME,  GO TO 10
       IF FIND COLUMN(NAME),  GO TO 10
C
       CALL SET CODE(11)
       CALL SET CODE(NAME(1))
       CALL SET CODE(NAME(2))
C
       NCNAME=.TRUE.
       GO TO 20
C
C
10     NCNAME=.FALSE.
C
20     RETURN
C
C
       END
       LOGICAL FUNCTION CNAME
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL NAME(2)
C
       LOGICAL PACK NAME
       EXTERNAL PACK NAME
C
C
       IF .NOT.(CNAME=PACK NAME),  GO TO 10
C
       CALL SET CODE(12)
       CALL SET CODE(NAME(1))
       CALL SET CODE(NAME(2))
C
C
10     RETURN
C
C
       END
       LOGICAL FUNCTION PNAME
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL P ROWS
C
       LOGICAL PACK PERIOD,  FIND ROW
       EXTERNAL PACK PERIOD,  FIND ROW
C
C
       IF .NOT.PACK PERIOD,  GO TO 10
       IF .NOT.FIND ROW,  GO TO 10
C
       CALL SET CODE(13)
       CALL SET CODE(P ROWS)
C
       PNAME=.TRUE.
       GO TO 20
C
C
10     PNAME=.FALSE.
C
20     RETURN
C
C
       END
       LOGICAL FUNCTION RNAME
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL P ROWS,  NO OF ROWS
C
       LOGICAL PACK ROW,  FIND ROW
       EXTERNAL PACK ROW,  FIND ROW
C
C
       IF NOWCHR(0).EQ.1R$,  (IF NEXTCHR(0).EQ.1R#,  CALL NEXTCHR(0));
+              P ROWS=NO OF ROWS;  GO TO 5
C
       IF .NOT.PACK ROW,  GO TO 10
       IF .NOT.FIND ROW,  GO TO 10
C
5      CALL SET CODE(13)
       CALL SET CODE(P ROWS)
C
       RNAME=.TRUE.
       GO TO 20
C
C
10     RNAME=.FALSE.
C
20     RETURN
C
C
       END
       LOGICAL FUNCTION GET TITLE
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL TITLE(2)
C
       GLOBAL NAME(2)
C
       LOGICAL PACK NAME
       EXTERNAL PACK NAME
C
C
       IF .NOT.(GET TITLE=PACK NAME),  GO TO 10
C
       TITLE(1)=NAME(1)
       TITLE(2)=NAME(2)
C
C
10     RETURN
C
C
       END
       LOGICAL FUNCTION GET IN
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL P COLUMNS
C
       INTEGER IN(2),  MEAN(2)
       DATA IN/'IN    '/,  MEAN/'MEAN  '/
C
       LOGICAL FIND COLUMN
C
C
       IF ((GET IN=FIND COLUMN(IN))),  GO TO 5
       IF .NOT.(GET IN=FIND COLUMN(MEAN)),  GO TO 10
C
5      CALL SET CODE(9)
       CALL SET CODE(P COLUMNS)
C
10     RETURN
C
C
       END
       LOGICAL FUNCTION GET OUT
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL P COLUMNS
C
       INTEGER OUT(2)
       DATA OUT/'OUT   '/
C
       LOGICAL FIND COLUMN
C
C
       IF .NOT.(GET OUT=FIND COLUMN(OUT)),  GO TO 10
C
       CALL SET CODE(9)
       CALL SET CODE(P COLUMNS)
C
10     RETURN
C
C
       END
       LOGICAL FUNCTION PERCENT
C
C
       NORMAL MODE IS INTEGER
C
       COMMON /CODE/MAX CODE, P CODE, CODE(1)
C
       REAL MKREAL
C
C
       PERCENT=0.0<=MKREAL(CODE(P CODE-1))<=1.0
C
       RETURN
C
C
       END
       LOGICAL FUNCTION CK RANGE
C
C
       NORMAL MODE IS INTEGER
C
       COMMON /CODE/MAX CODE, P CODE, CODE(1)
C
C
       CK RANGE=CODE(P CODE-2)<CODE(P CODE)
C
       RETURN
C
C
       END
       LOGICAL FUNCTION NUMERIC
C
C
       NORMAL MODE IS INTEGER
C
C
       I=NOWCHR(0)
       NUMERIC=1R0<=I<=1R9 .OR. I.EQ.1R+ .OR. I.EQ.1R- .OR. I.EQ.1R.
C
       RETURN
C
C
       END
       LOGICAL FUNCTION CK LINE
C
C
       NORMAL MODE IS INTEGER
C
       COMMON /CODE/MAX CODE, N CODE, CODE(1)
C
C
       CK LINE=13<=CODE(4)<=256
C
       RETURN
C
       END
       LOGICAL FUNCTION CK CASES
C
C
       NORMAL MODE IS INTEGER
C
       COMMON /CODE/MAX CODE,  N CODE,  CODE(1)
C
C
       CK CASES=0<CODE(N CODE)<100
C
       RETURN
C
       END
       LOGICAL FUNCTION CK LIST
C
C
       NORMAL MODE IS INTEGER
C
       LOGICAL LIST FLAG
       GLOBAL LIST FLAG
C
C
       CK LIST=LIST FLAG
C
       RETURN
C
       END
       LOGICAL FUNCTION CK DATA IN
C
C
       NORMAL MODE IS INTEGER
C
       LOGICAL DATA IN
       GLOBAL DATA IN
C
C
       CK DATA IN=DATA IN
C
       RETURN
C
       END
       LOGICAL FUNCTION CK INP OK
C
C
       NORMAL MODE IS INTEGER
C
       LOGICAL INP OK
       GLOBAL INP OK
C
C
       CK INP OK=INP OK
C
       RETURN
C
       END
       LOGICAL FUNCTION CK REP FLAG
C
C
       NORMAL MODE IS INTEGER
C
       LOGICAL REP FLAG
       GLOBAL REP FLAG
C
C
       CK REP FLAG=REP FLAG
C
       RETURN
C
       END
       LOGICAL FUNCTION CK FORC
C
C
       NORMAL MODE IS INTEGER
C
       LOGICAL FORC FLAG
       GLOBAL FORC FLAG
C
C
       CK FORC=FORC FLAG
C
       RETURN
C
       END
       LOGICAL FUNCTION CK FINPAK
C
C
       NORMAL MODE IS INTEGER
C
       LOGICAL FINPAK
       GLOBAL FINPAK
C
C
       CK FINPAK=FINPAK
C
       RETURN
C
       END
       LOGICAL FUNCTION CK TITLE
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL TITLE(2)
C
C
       CK TITLE=TITLE(1)#0
C
       RETURN
C
       END
       LOGICAL FUNCTION CK INTV
C
C
       NORMAL MODE IS INTEGER
C
       COMMON /CODE/MAX CODE, N CODE, CODE(1)
C
C
       CK INTV=0<CODE(8)<13
C
       RETURN
C
       END
       LOGICAL FUNCTION CK PLOT
C
C
       NORMAL MODE IS INTEGER
C
       COMMON /CODE/MAX CODE, N CODE, CODE(1)
C
C
       CK PLOT=N CODE<=10
C
       RETURN
C
       END
       LOGICAL FUNCTION CK STEP
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL NO OF ROWS
C
C
       CK STEP=NO OF ROWS>2
C
       RETURN
C
       END
       LOGICAL FUNCTION CK CHI
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL P COLUMNS
C
       INTEGER NAMES(2,3)
       DATA NAMES/'LRANGEURANGEFREQ  '/
C
       LOGICAL FIND COLUMN
C
C
       CK CHI=.FALSE.
C
       IF .NOT.FIND COLUMN(NAMES(1,1)),  GO TO 10
       I=P COLUMNS
C
       IF .NOT.FIND COLUMN(NAMES(1,2)),  GO TO 10
       J=P COLUMNS
C
       IF .NOT.FIND COLUMN(NAMES(1,3)),  GO TO 10
C
       CK CHI=.TRUE.
       CALL SET CODE(4)
       CALL SET CODE(I)
       CALL SET CODE(J)
       CALL SET CODE(P COLUMNS)
C
C
10     RETURN
C
       END
       LOGICAL FUNCTION CK RISK
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL P COLUMNS
C
       INTEGER NAMES(2,3)
       DATA NAMES/'LOW   MOST  HIGH  '/
C
       LOGICAL FIND COLUMN
C
C
       CK RISK=.FALSE.
C
       IF .NOT.FIND COLUMN(NAMES(1,1)),  GO TO 10
       I=P COLUMNS
C
       IF .NOT.FIND COLUMN(NAMES(1,2)),  GO TO 10
       J=P COLUMNS
C
       IF .NOT.FIND COLUMN(NAMES(1,3)),  GO TO 10
C
       CK RISK=.TRUE.
       CALL SET CODE(9)
       CALL SET CODE(I)
       CALL SET CODE(9)
       CALL SET CODE(J)
       CALL SET CODE(9)
       CALL SET CODE(P COLUMNS)
C
C
10     RETURN
C
       END
       LOGICAL FUNCTION CK PARAM
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL P COLUMNS
C
       INTEGER NAMES(2,2)
       DATA NAMES/'MEAN  STD   '/
C
       LOGICAL FIND COLUMN
C
C
       CK PARAM=.FALSE.
C
       IF .NOT.FIND COLUMN(NAMES(1,1)),  GO TO 10
       I=P COLUMNS
C
       IF .NOT.FIND COLUMN(NAMES(1,2)),  GO TO 10
C
       CK PARAM=.TRUE.
       CALL SET CODE(9)
       CALL SET CODE(I)
       CALL SET CODE(9)
       CALL SET CODE(P COLUMNS)
C
C
10     RETURN
C
       END
       LOGICAL FUNCTION CK EFF
C
C
       NORMAL MODE IS INTEGER
C
       COMMON /CODE/MAX CODE,  N CODE,  CODE(1)
       GLOBAL P COLUMNS
C
       INTEGER NAMES(2,3,2)
       DATA NAMES/'RRETRNLBOUNDRRISK ORETRNUBOUNDORISK '/
C
       LOGICAL FIND COLUMN
C
C
       CK EFF=.FALSE.
C
       IF .NOT.FIND COLUMN(NAMES(1,1,CODE(4))),  GO TO 10
       I=P COLUMNS
C
       IF .NOT.FIND COLUMN(NAMES(1,2,CODE(4))),  GO TO 10
       J=P COLUMNS
       IF .NOT.FIND COLUMN(NAMES(1,3,CODE(4))),  GO TO 10
C
       CK EFF=.TRUE.
       CALL SET CODE(9)
       CALL SET CODE(I)
       CALL SET CODE(9)
       CALL SET CODE(J)
       CALL SET CODE(9)
       CALL SET CODE(P COLUMNS)
C
C
10     RETURN
C
       END
       LOGICAL FUNCTION CK ZERO
C
C
       NORMAL MODE IS INTEGER
C
C
       COMMON /CODE/MAX CODE, N CODE, CODE(1)
C
       REAL MKREAL
C
       CK ZERO=MKREAL(CODE(N CODE-1)).EQ.0
C
       RETURN
C
       END
       LOGICAL FUNCTION CK POS
C
C
       NORMAL MODE IS INTEGER
C
       COMMON /CODE/MAX CODE, N CODE, CODE(1)
C
C
       CK POS=CODE(N CODE)>0
C
       RETURN
C
       END
       LOGICAL FUNCTION DCAT
C
C
       NORMAL MODE IS INTEGER
C
       GLOBAL C COUNT
C
C
       C COUNT=C COUNT-1
       DCAT=C COUNT<=0
C
       RETURN
C
       END
STATFIN ** FICHE/FRAME BREAK *****
FINPARFUNS SYMSORT

SYM.  PG.LN. IDENT.

+       3 24 _:FINPAR+       2  7 _:FINPAR+       1 24 _:FINPAR
CM      9 29 _:FINPARCM      9 28 _:FINPARCM      9 25 _:FINPARCM      9 22 _:FINPAR
CM      9 21 _:FINPARCM      9 19 _:FINPARCM      9 16 _:FINPARCM      9 15 _:FINPAR
CM      9 14 _:FINPARCM      9 13 _:FINPARCM      9  9 _:FINPARCM      9  1 _:FINPAR
CM      8 37 _:FINPARCM      8 35 _:FINPARCM      8 33 _:FINPARCM      8 31 _:FINPAR
CM      8 29 _:FINPARCM      8 26 _:FINPARCM      8 20 _:FINPARCM      8 19 _:FINPAR
CM      8 17 _:FINPARCM      8 15 _:FINPARCM      8 13 _:FINPARCM      8 12 _:FINPAR
CM      8  9 _:FINPARCM      8  1 _:FINPARCM      7 39 _:FINPARCM      7 37 _:FINPAR
CM      7 35 _:FINPARCM      7 33 _:FINPARCM      7 31 _:FINPARCM      7 30 _:FINPAR
CM      7 27 _:FINPARCM      7 21 _:FINPARCM      7 20 _:FINPARCM      7 18 _:FINPAR
CM      7 16 _:FINPARCM      7 14 _:FINPARCM      7 12 _:FINPARCM      7 11 _:FINPAR
CM      7  8 _:FINPARCM      7  7 _:FINPARCM      7  5 _:FINPARCM      7  2 _:FINPAR
CM      7  1 _:FINPARCM      6 38 _:FINPARCM      6 35 _:FINPARCM      6 34 _:FINPAR
CM      6 32 _:FINPARCM      6 29 _:FINPARCM      6 28 _:FINPARCM      6 26 _:FINPAR
CM      6 23 _:FINPARCM      6 22 _:FINPARCM      6 19 _:FINPARCM      6 16 _:FINPAR
CM      6 15 _:FINPARCM      6 12 _:FINPARCM      6  9 _:FINPARCM      6  8 _:FINPAR
CM      6  5 _:FINPARCM      6  2 _:FINPARCM      6  1 _:FINPARCM      5 37 _:FINPAR
CM      5 34 _:FINPARCM      5 33 _:FINPARCM      5 30 _:FINPARCM      5 27 _:FINPAR
CM      5 26 _:FINPARCM      5 23 _:FINPARCM      5 20 _:FINPARCM      5 19 _:FINPAR
CM      5 17 _:FINPARCM      5 14 _:FINPARCM      5 13 _:FINPARCM      5 11 _:FINPAR
CM      5  7 _:FINPARCM      5  1 _:FINPARCM      4 38 _:FINPARCM      4 34 _:FINPAR
CM      4 32 _:FINPARCM      4 31 _:FINPARCM      4 25 _:FINPARCM      4 23 _:FINPAR
CM      4 21 _:FINPARCM      4 20 _:FINPARCM      4 11 _:FINPARCM      4  9 _:FINPAR
CM      4  8 _:FINPARCM      4  2 _:FINPARCM      3 38 _:FINPARCM      3 37 _:FINPAR
CM      3 36 _:FINPARCM      3 29 _:FINPARCM      3 25 _:FINPARCM      3 21 _:FINPAR
CM      3 20 _:FINPARCM      3 13 _:FINPARCM      3 11 _:FINPARCM      3  7 _:FINPAR
CM      3  6 _:FINPARCM      2 38 _:FINPARCM      2 35 _:FINPARCM      2 34 _:FINPAR
CM      2 27 _:FINPARCM      2 24 _:FINPARCM      2 20 _:FINPARCM      2 19 _:FINPAR
CM      2 12 _:FINPARCM      2  8 _:FINPARCM      2  4 _:FINPARCM      2  3 _:FINPAR
CM      1 39 _:FINPARCM      1 38 _:FINPARCM      1 35 _:FINPARCM      1 26 _:FINPAR
CM      1 21 _:FINPARCM      1 19 _:FINPARCM      1 16 _:FINPARCM      1  5 _:FINPAR
CM10    4 27 _:FINPARCM10    4 16 _:FINPARCM10    2 14 _:FINPARCM10    1 14 _:FINPAR
CM20    3 32 _:FINPARCM20    3 16 _:FINPARCM20    2 30 _:FINPARCM20    2 15 _:FINPAR
CM20    1 15 _:FINPARCM200   1 32 _:FINPARCM5     4 14 _:FINPARCM5     3 27 _:FINPAR
CM5     2 10 _:FINPARCMCM    9 26 _:FINPARCMCM    9 24 _:FINPARCMCM    9 20 _:FINPAR
CMCM    9 18 _:FINPARCMCM    9 12 _:FINPARCMCM    9 11 _:FINPARCMCM    8 34 _:FINPAR
CMCM    8 28 _:FINPARCMCM    8 16 _:FINPARCMCM    8 11 _:FINPARCMCM    7 34 _:FINPAR
CMCM    7 29 _:FINPARCMCM    7 15 _:FINPARCMCM    7 10 _:FINPARCMCM    7  6 _:FINPAR
CMCM    7  4 _:FINPARCMCM    6 39 _:FINPARCMCM    6 37 _:FINPARCMCM    6 33 _:FINPAR
CMCM    6 31 _:FINPARCMCM    6 27 _:FINPARCMCM    6 25 _:FINPARCMCM    6 21 _:FINPAR
CMCM    6 18 _:FINPARCMCM    6 14 _:FINPARCMCM    6 11 _:FINPARCMCM    6  7 _:FINPAR
CMCM    6  4 _:FINPARCMCM    5 39 _:FINPARCMCM    5 36 _:FINPARCMCM    5 32 _:FINPAR
CMCM    5 29 _:FINPARCMCM    5 25 _:FINPARCMCM    5 22 _:FINPARCMCM    5 18 _:FINPAR
CMCM    5 16 _:FINPARCMCM    5 12 _:FINPARCMCM    5 10 _:FINPARCMCM    5  8 _:FINPAR
CMCM    5  5 _:FINPARCMCM    5  4 _:FINPARCMCM    5  2 _:FINPARCMCM    4 39 _:FINPAR
CMCM    4 37 _:FINPARCMCM    4 35 _:FINPARCMCM    4 33 _:FINPARCMCM    4 30 _:FINPAR
CMCM    4 28 _:FINPARCMCM    4 24 _:FINPARCMCM    4 19 _:FINPARCMCM    4 17 _:FINPAR
CMCM    4 12 _:FINPARCMCM    4  7 _:FINPARCMCM    4  5 _:FINPARCMCM    4  1 _:FINPAR
CMCM    3 35 _:FINPARCMCM    3 33 _:FINPARCMCM    3 23 _:FINPARCMCM    3 19 _:FINPAR
CMCM    3 17 _:FINPARCMCM    3  9 _:FINPARCMCM    3  5 _:FINPARCMCM    3  3 _:FINPAR
CMCM    2 37 _:FINPARCMCM    2 33 _:FINPARCMCM    2 31 _:FINPARCMCM    2 22 _:FINPAR
CMCM    2 18 _:FINPARCMCM    2 16 _:FINPARCMCM    2  6 _:FINPARCMCM    2  2 _:FINPAR
CMCM    1 37 _:FINPARCMCM    1 34 _:FINPARCMCM    1 25 _:FINPARCMCM    1 18 _:FINPAR
CMCM    1  7 _:FINPARCMCM    1  4 _:FINPARCMCM    1  3 _:FINPARCMCM    1  2 _:FINPAR
CMCM10  9  8 _:FINPARCMCM10  8 25 _:FINPARCMCM10  8  8 _:FINPARCMCM10  7 26 _:FINPAR
CMCM10  4  4 _:FINPARCMCM10  3 31 _:FINPARCMCM10  3 15 _:FINPARCMCM10  3  2 _:FINPAR
CMCM10  2 29 _:FINPARCMCM10  1 31 _:FINPARCMCMCM  1 36 _:FINPARCMCMCM  1 33 _:FINPAR
L       9 23 _:FINPARL       9 17 _:FINPARL       9 10 _:FINPARL       8 27 _:FINPAR
L       8 10 _:FINPARL       7 28 _:FINPARL       7  9 _:FINPARL       7  3 _:FINPAR
L       6 36 _:FINPARL       6 30 _:FINPARL       6 24 _:FINPARL       6 17 _:FINPAR
L       6 10 _:FINPARL       6  3 _:FINPARL       5 35 _:FINPARL       5 28 _:FINPAR
L       5 21 _:FINPARL       5 15 _:FINPARL       5  9 _:FINPARL       5  3 _:FINPAR
L       4 36 _:FINPARL       4 29 _:FINPARL       4 18 _:FINPARL       4  6 _:FINPAR
L       3 34 _:FINPARL       3 18 _:FINPARL       3  4 _:FINPARL       2 32 _:FINPAR
L       2 17 _:FINPARL       2  1 _:FINPARL       1 17 _:FINPAR
STATFIN ** FICHE/FRAME BREAK *****
FIXCHAINS
C:FIXCHAINS   04/29/72         FIX NODE REFERENCES.
C
C
       SUBROUTINE FIX CHAINS
C
       GLOBAL NO OF NODES,  P TEXT,  VALUE SHIFT
       GLOBAL DEF(1),  ALT(1),  SUC(1),  BLOCKS(3,1)
C
       NORMAL MODE IS INTEGER
C
       OFFSET=2*(NO OF NODES+1)
C
       DO 100 CUR NODE=1, NO OF NODES
       CALL GET VALUE
       GO TO (20,10,10,30,30,40,20,20,20) CUR VALUE-2,  50
C
10     DEF(CUR NODE)=DEF(CUR NODE)+ P TEXT
20     DEF(CUR NODE)=DEF(CUR NODE)+OFFSET
       GO TO 50
C
30     DEF(CUR NODE)=IOR(IAND(DEF(CUR NODE),7777B4),
+              IAND(BLOCKS(3,IAND(DEF(CUR NODE),7777B)), 7777B))
       GO TO 50
C
40     CALL LABEL VALUE(DEF(CUR NODE))
C
50     DEF(CUR NODE)=IOR(DEF(CUR NODE), LSH(CUR VALUE, VALUE SHIFT))
C
C
       CALL LABEL VALUE(ALT(CUR NODE))
       CALL LABEL VALUE(SUC(CUR NODE))
C
       ALT(CUR NODE)=IOR(LSH(ALT(CUR NODE), 12), 
+              IAND(SUC(CUR NODE), 7777B))
C
100    CONTINUE
C
       RETURN
C
C
C
       LOCAL SUBROUTINE GET VALUE
C
       GLOBAL VALUE(1)
C
       INTEGER SHIFT(0/5)
       DATA SHIFT/20, 16, 12, 8, 4, 0/
C
C
       I=(CUR NODE+5)/6
       J=CUR NODE-6*I+5
       CUR VALUE=IAND(LRSH(VALUE(I), SHIFT(J)), 17B)
C
       RETURN
C
C
C
       LOCAL SUBROUTINE LABEL VALUE(LAB)
C
       GLOBAL LABEL(0/1)
C
C
       IF LAB.EQ.4B7,  LAB=4B3;  GO TO 50
       IF LAB<=0, GO TO 50
C
       J=IAND(LAB,INOT(1K16))
C
       DO 10 I=1, NO OF NODES
10     IF LABEL(I).EQ.J, GO TO 20
C
       CALL DISMSG(1,32)
       CALL DISNUM(IAND(LAB,377777B))
       CALL DISCHR(1R/)
       CALL DISSYM(BLOCKS(1,LRSH(LAB,17)))
       CALL DISMSG(1,33)
       CALL DISNUM(IAND(LABEL(CUR NODE), 377777B))
       CALL DISCHR(1R/)
       CALL DISSYM(BLOCKS(1,LRSH(LABEL(CUR NODE),17)))
       CALL DISCHR(155B)
       I=0
C
20     LAB=IOR(I,IAND(LAB,1K16))
C
50     RETURN
C
       END
STATFIN ** FICHE/FRAME BREAK *****
FIXCHAINS SYMSORT

SYM.  PG.LN. IDENT.

+       1 21 _:FIXCHA+       1 14 _:FIXCHA10      1 38 _:FIXCHA20      1 11 _:FIXCHA
CM      2 12 _:FIXCHACM      1 39 _:FIXCHACM      1 37 _:FIXCHA
CM      1 36 _:FIXCHACM      1 33 _:FIXCHACM      1 31 _:FIXCHACM      1 26 _:FIXCHA
CM      1 25 _:FIXCHACM      1 23 _:FIXCHACM      1 20 _:FIXCHACM      1  7 _:FIXCHA
CM      1  6 _:FIXCHACM      1  5 _:FIXCHACM      1  3 _:FIXCHACM10    1 10 _:FIXCHA
CM100   1 22 _:FIXCHACM20    2 10 _:FIXCHACM30    1 13 _:FIXCHACM40    1 16 _:FIXCHA
CM50    2 11 _:FIXCHACM50    1 17 _:FIXCHACMCM    1 34 _:FIXCHACMCM    1 28 _:FIXCHA
CMCM    1 18 _:FIXCHACMCM    1  2 _:FIXCHACMCMCM  1 32 _:FIXCHACMCMCM  1 24 _:FIXCHA

STATFIN ** FICHE/FRAME BREAK *****
FIXCOLUMN
C:FIXCOLUMN   08/14/72
C
C
       SUBROUTINE FIX COLUMN(FLAG,FUDGE,COLUMN,DIGITS)
C
C
       NORMAL MODE IS INTEGER
C
       REAL MATRIX
       GLOBAL MATRIX(1),  NO OF COLUMNS,  NO OF ROWS
C
       LOGICAL F,  FLAG
       REAL X,  FUDGE
C
C
       DO 10 ROW=0, NO OF ROWS-1
       INDEX=COLUMN+NO OF COLUMNS*ROW
       F=.FALSE.
       IF MATRIX(INDEX),  1,10,2
1      F=.TRUE.
       MATRIX(INDEX)=-MATRIX(INDEX)
C
2      IF FLAG,  GO TO 5
       I=X=LOG10(MATRIX(INDEX))
       IF X<0,  J=0   .ELSE.  J=1
       MATRIX(INDEX)=AINT(10^(X-I+DIGITS-J)+FUDGE)*10.^(I+J-DIGITS)
       GO TO 10
C
5      X=10.^DIGITS
       MATRIX(INDEX)=AINT(MATRIX(INDEX)*X+FUDGE+.001)/X
C
10     IF F,  MATRIX(INDEX)=-MATRIX(INDEX)
C
       RETURN
C
C
       END
STATFIN ** FICHE/FRAME BREAK *****
FIXCOLUMN SYMSORT

SYM.  PG.LN. IDENT.

1       1 12 _:FIXCOLCM      1 22 _:FIXCOLCM      1  6 _:FIXCOL
CM      1  4 _:FIXCOLCM10    1 21 _:FIXCOLCM2     1 14 _:FIXCOLCM5     1 19 _:FIXCOL
CMCM    1 23 _:FIXCOLCMCM    1  8 _:FIXCOLCMCM    1  3 _:FIXCOLCMCM    1  2 _:FIXCOL

STATFIN ** FICHE/FRAME BREAK *****
FORCAST
C:FORCAST   09/11/72           DATA GENERATORS.
C
C
       SUBROUTINE STEP(A)
C
C
       NORMAL MODE IS INTEGER
C
       COMMON /CODE/MAX CODE, N CODE, CODE(1)
C
       LOGICAL TALK,HUSH,ECHO,TTY
       INTEGER COM NO
       COMMON /SFE/TALK,HUSH,ECHO,TTY,COM NO
C
       GLOBAL NO OF COLUMNS,  NO OF ROWS
       LOGICAL GET LINE,  END LINE
       REAL A(NO OF COLUMNS, NO OF ROWS),  X, Y
       EXTERNAL END LINE
C
C
       CALL SET POINT(257)
       IF TALK,  CALL DISMSG(2,3)
C
C
       REPEAT 100, FOR I=(1,CODE(4))
C
10     IF .NOT.END LINE,  GO TO 30
20     IF TALK,  CALL DISCHR(0),  DISSYM(CODE(6)),  DISCHR(1R(),
+              DISNUM(I),  DISMSG(2,4)
       IF GET LINE(J),  GO TO 10
       HUSH=.FALSE.
       TALK=.TRUE.
       GO TO 10
C
30     IF NUMBER(X)>0,  GO TO 50
40     CALL ERROR(13)
       GO TO 20
C
50     A(CODE(5),I)=X
C
       CALL KOMMA(0)
       IF END LINE,  GO TO 100
       IF NOWCHR(0).EQ.1R*,  CALL NEXTCHR(1)
C
       IF NUMBER(Y)<=0,  GO TO 40
       J=Y
       IF J.EQ.Y .AND. J>=1,  GO TO 60
       CALL ERROR(14)
       GO TO 20
C
60     TIMES 70, J-1
       IF (  (I=I+1)>CODE(4)  ),  GO TO 200
70     A(CODE(5),I)=X
C
100    CONTINUE
C
C
200    RETURN
C
       END
       SUBROUTINE LINEAR(A)
C
C
       NORMAL MODE IS INTEGER
C
       COMMON /CODE/MAX CODE, N CODE, CODE(1)
C
       GLOBAL NO OF COLUMNS,  NO OF ROWS
C
       LOGICAL FLAG
       REAL A(NO OF COLUMNS, NO OF ROWS), X, Y
C
       REAL MKREAL,  GET SYMBOL
C
C
       I=11
C
       REPEAT 10,  WHILE CODE(I-1).EQ.12
       CALL ADD SYMBOL(CODE(I))
10     I=I+3
C
       FLAG=CODE(I-1).EQ.9
       IF FLAG,  L=CODE(I)
C
C
       DO 100  J=1, CODE(4)
       IF FLAG,  X=A(L,1)  .ELSE.  X=MKREAL(CODE(I))
C
       DO 50 K=11, I-3, 3
       IF FLAG,  Y=A(L, (K-5)/3)  .ELSE.  Y=MKREAL(CODE(I+K-8))
50     X=X+Y*GET SYMBOL(CODE(K),J)
C
100    A(CODE(5),J)=X
C
C
       RETURN
C
       END
       SUBROUTINE POLY(A)
C
C
       NORMAL MODE IS INTEGER
C
       COMMON /CODE/MAX CODE, N CODE, CODE(1)
C
       GLOBAL NO OF COLUMNS,  NO OF ROWS
C
       LOGICAL FLAG
       REAL A(NO OF COLUMNS, NO OF ROWS),  S, I, X, Y, Z
C
       REAL MKREAL
C
C
       S=MKREAL(CODE(13))
       I=MKREAL(CODE(16))
       FLAG=CODE(18).EQ.9
C
       DO 10 J=1,CODE(4)
       IF FLAG,  X=A(CODE(19),1)  .ELSE.  X=MKREAL(CODE(19))
       Y=S+(J-1)*I
C
       DO 5 K=1,CODE(11)
       IF FLAG,  Z=A(CODE(19),K+1)  .ELSE.  Z=MKREAL(CODE(19+3*K))
5      X=X+Z*Y**K
C
10     A(CODE(5),J)=X
C
C
       RETURN
C
       END
       SUBROUTINE NON LINEAR(A)
C
C
       NORMAL MODE IS INTEGER
C
       COMMON /CODE/MAX CODE, N CODE, CODE(1)
C
       GLOBAL NO OF COLUMNS,  NO OF ROWS,  STATE
C
       INTEGER E(1),  FUN STACK(10)
       REAL A(NO OF COLUMNS, NO OF ROWS),  X,  Y,  STACK(10)
       EQUIVALENCE (E,CODE(11))
C
       REAL MKREAL,  GET SYMBOL
C
C
       CONNECT OVERFLOW,  CALL LOCAL;  IF ERR NO<6,  GO TO 209
+              .ELSE.  GO TO 2
C
C
       STATE=1
C
       DO 170 ROW=1, CODE(4)
C
       LEVEL=0
       INDEX=1
C
1      X=0
       FUN=-1
C
2      INDEX=INDEX+1
       GO TO (50,3,3,3,3,3,3,120,3,3,3,3,170,180,190,200)
+              E(INDEX-1)-4,  3
C
3      CALL ERROR(1)
       STATE=2
       RETURN
C
C
50     Y=MKREAL(E(INDEX))
       GO TO 1000
C
C
120    IF ROW.EQ.1,  CALL ADD SYMBOL(E(INDEX))
       Y=GET SYMBOL(E(INDEX),ROW)
       GO TO 1000
C
C
170    A(CODE(5),ROW)=X
       DISCONNECT OVERFLOW
       RETURN
C
C
180    LEVEL=LEVEL+1
       STACK(LEVEL)=X
       FUN STACK(LEVEL)=FUN
       GO TO 1
C
C
190    Y=X
       X=STACK(LEVEL)
       FUN=FUN STACK(LEVEL)
       LEVEL=LEVEL-1
       IF FUN>0,  GO TO 201
       GO TO 3000
C
C
200    FUN=E(INDEX+1)
       INDEX=INDEX+2
       GO TO 2
C
201    ERR NO=FUN+1
       GO TO (202, 203, 204, 205, 206) FUN,  207
C
202    IF Y<0,  GO TO 210
       Y=SQRT(Y)
       GO TO 209
C
203    IF Y<=0,  GO TO 210
       Y=LOG10(Y)
       GO TO 209
C
204    IF Y<=0,  GO TO 210
       Y=LOG(Y)
       GO TO 209
C
205    Y=EXP(Y)
       GO TO 209
C
206    Y=SIN(Y)
       GO TO 209
C
207    Y=COS(Y)
       GO TO 209
C
209    FUN=-1
       GO TO 3000
C
210    X=Y/0
C
C
1000   INDEX=INDEX+1
2000   INDEX=INDEX+1
3000   INDEX=INDEX+2
C
       ERR NO=E(INDEX-1)+5
       GO TO (3100, 3200,  3250, 3300) E(INDEX-1),  3400
C
3100   X=X+Y
       GO TO 2
C
3200   X=X-Y
       GO TO 2
C
3250   IF Y#INT(Y),  GO TO 3260
       IF X.EQ.0,  GO TO 3270
       X=X^INT(Y)
       GO TO 2
3260   IF X<0,  ERR NO=11;  GO TO 210
       GO TO 3280
3270   IF Y<=0,  ERR NO=12;  GO TO 210
3280   X=X^Y
       GO TO 2
C
3300   X=X*Y
       GO TO 2
C
3400   X=X/Y
       GO TO 2
       LOCAL SUBROUTINE LOCAL
C
C
       LOGICAL SPECIAL,  MULTIPLE
       GLOBAL SPECIAL,  MULTIPLE
       GLOBAL NAME(2),  COLUMNS(2,1),  ROWS(2,-2:-1)
C
C
       CALL ERROR(ERR NO)
       CALL DISMSG(2,1)
C
       IF SPECIAL,  GO TO 10
       IF MULTIPLE,  CALL GET FLOW(I,J,ROW)  .ELSE.  I=ROW; J=0
       CALL MAKE RN(I,J)
       GO TO 20
C
10     NAME(1)=ROWS(1,-ROW)
       NAME(2)=ROWS(2,-ROW)
C
20     CALL DISSYM(NAME)
       CALL DISMSG(2,2)
C
       STATE=2
C
       RETURN
       SUBROUTINE ERROR(NO)
C
       CALL OUTMSG(1,1,NO)
       CALL SFE CLEAR
       RETURN
C
C
       END
STATFIN ** FICHE/FRAME BREAK *****
FORCAST SYMSORT

SYM.  PG.LN. IDENT.

+       3 20 W:FORCAS+       3 11 W:FORCAS+       1 17 W:FORCAS10      2 11 W:FORCAS
20      1 16 W:FORCAS2000    4 27 W:FORCAS3000    4 28 W:FORCAS3260    4 39 W:FORCAS
3270    5  2 W:FORCAS3280    5  3 W:FORCAS40      1 23 W:FORCAS5       2 37 W:FORCAS
50      2 18 W:FORCAS70      1 36 W:FORCASCM      5 26 W:FORCAS
CM      5 24 W:FORCASCM      5 23 W:FORCASCM      5 15 W:FORCASCM      4 29 W:FORCAS
CM      3 14 W:FORCASCM      3 13 W:FORCASCM      3  9 W:FORCASCM      3  6 W:FORCAS
CM      3  5 W:FORCASCM      3  4 W:FORCASCM      3  1 W:FORCASCM      2 35 W:FORCAS
CM      2 32 W:FORCASCM      2 28 W:FORCASCM      2 26 W:FORCASCM      2 25 W:FORCAS
CM      2 24 W:FORCASCM      2 21 W:FORCASCM      2 16 W:FORCASCM      2 12 W:FORCAS
CM      2  9 W:FORCASCM      2  7 W:FORCASCM      2  5 W:FORCASCM      2  4 W:FORCAS
CM      2  3 W:FORCASCM      1 39 W:FORCASCM      1 29 W:FORCASCM      1 26 W:FORCAS
CM      1  8 W:FORCASCM      1  5 W:FORCASCM      1  4 W:FORCASCM1     3 16 W:FORCAS
CM10    5 19 W:FORCASCM10    2 38 W:FORCASCM10    1 15 W:FORCASCM100   2 19 W:FORCAS
CM100   1 37 W:FORCASCM2     3 18 W:FORCASCM20    5 21 W:FORCASCM201   4  6 W:FORCAS
CM202   4  8 W:FORCASCM203   4 11 W:FORCASCM204   4 14 W:FORCASCM205   4 17 W:FORCAS
CM206   4 19 W:FORCASCM207   4 21 W:FORCASCM209   4 23 W:FORCASCM210   4 25 W:FORCAS
CM3     3 21 W:FORCASCM30    1 22 W:FORCASCM3100  4 31 W:FORCASCM3200  4 33 W:FORCAS
CM3250  4 35 W:FORCASCM3300  5  5 W:FORCASCM3400  5  7 W:FORCASCM50    1 25 W:FORCAS
CM60    1 34 W:FORCASCMCM    5 29 W:FORCASCMCM    5 13 W:FORCASCMCM    5 10 W:FORCAS
CMCM    3 12 W:FORCASCMCM    3 10 W:FORCASCMCM    3  3 W:FORCASCMCM    2 39 W:FORCAS
CMCM    2 29 W:FORCASCMCM    2 23 W:FORCASCMCM    2 20 W:FORCASCMCM    2 14 W:FORCAS
CMCM    2  8 W:FORCASCMCM    2  2 W:FORCASCMCM    1 14 W:FORCASCMCM    1 12 W:FORCAS
CMCM    1  3 W:FORCASCMCM    1  2 W:FORCASCMCM10  4 26 W:FORCASCMCM12  3 26 W:FORCAS
CMCM17  3 29 W:FORCASCMCM18  3 32 W:FORCASCMCM19  3 36 W:FORCASCMCM20  4  3 W:FORCAS
CMCM20  1 38 W:FORCASCMCM50  3 24 W:FORCASL       5 25 W:FORCASL       5  9 W:FORCAS
L       3  2 W:FORCASL       2 22 W:FORCASL       2  1 W:FORCAS
STATFIN ** FICHE/FRAME BREAK *****
FVAL
       SUBROUTINE FVAL(A,N,T,CF,F)
       LOGICAL CF,GETBEG,F
       GLOBAL NOOFCO,NOOFRO,SUM,TAXFREQ,BUFFER(360),STATE
       INTEGER TAXFREQ,STATE
       REAL A(NOOFCO,NOOFRO)
       IF(NOOFRO.GT.360) CALL FATALE(360)
       SUM=0.
       DO 10 I=1,NOOFRO
10      BUFFER(I)=A(N,I)
       IF(T.GT.0.) CALL TAXCOM(T)
       IF(GETBEG(N)) GO TO 100
       IF(CF) GO TO 50
       DO 20 I=1,NOOFROWS-1
20     SUM=(SUM+BUFFER(I))*(1+RATE(I+1))
       SUM=SUM+BUFFER(NOOFRO)
       GO TO 1000
50     DO 30 I=1,NOOFROWS-1
30     SUM=(SUM+BUFFER(I))*EXP(RATE(I+1))
       SUM=SUM+BUFFER(NOOFRO)
       GO TO 1000
100    IF(CF) GO TO 60
       DO 40 I=0,NOOFROWS-1
40     SUM=(SUM+BUFFER(I+1))*(1+RATE(I+1))
       GO TO 1000
60     DO 70 I=0,NOOFROWS-1
70     SUM=(SUM+BUFFER(I+1))*EXP(RATE(I+1))
1000   IF(.NOT.F) RETURN
       DISPLAY "FUTURE VALUE = ",SUM
       STATE=1
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
FVAL SYMSORT

SYM.  PG.LN. IDENT.

10      1  9         100     1 21         1000    1 27         20      1 14         
30      1 18         40      1 23         50      1 17         60      1 25         
70      1 26         
STATFIN ** FICHE/FRAME BREAK *****
GETINT
C:GETINT   02/17/72            GET INTEGER
C
C
       FUNCTION GET INTEGER
C
       NORMAL MODE IS INTEGER
C
       IF INTEGER(GET INTEGER)<=0, CALL ERROR(25)
       IF GET INTEGER<0, CALL ERROR(26)
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
GETINT SYMSORT

SYM.  PG.LN. IDENT.

CM      1  4 C:GETINTCM      1  3 C:GETINTCMCM    1  2 C:GETINT

STATFIN ** FICHE/FRAME BREAK *****
GETLAB
C:GETLAB   02/17/72            GET LABEL.
C
C
       SUBROUTINE GET LABEL
C
       GLOBAL COMMAND,  NEXT COM,  COM NEXT
       GLOBAL NO OF NODES,  NEW NODE,  BLK CODE
       GLOBAL LABEL(0/1)
       LOGICAL COMMAND,  COM NEXT,  NEW NODE
       EXTERNAL GET INTEGER
       NORMAL MODE IS INTEGER
C
C
       IF ( (I=GET INTEGER)>99999 ),  CALL ERROR(4)
       IF NOWCHR(1)#1R , CALL ERROR(11)
C
       NO OF NODES=NO OF NODES+1
       NEW NODE=.TRUE.
       LABEL(NO OF NODES)=IOR(BLK CODE, I)
C
       IF IAND(IEOR(LABEL(NO OF NODES-1), LABEL(NO OF NODES)),177K17)
+              .NE.0,  GO TO 10
       IF IAND(LABEL(NO OF NODES), 377777K) <=
+              IAND(LABEL(NO OF NODES-1), 377777K),  CALL ERROR(23)
C
10     COMMAND=COM NEXT.OR.NEXT COM.OR. NEXT COM.EQ.LABEL(NO OF NODES)
       COM NEXT=.FALSE.
C
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
GETLAB SYMSORT

SYM.  PG.LN. IDENT.

+       1 17 C:GETLAB+       1 15 C:GETLABCM      1 20 C:GETLAB
CM      1 14 C:GETLABCM      1 11 C:GETLABCM      1  3 C:GETLABCM10    1 18 C:GETLAB
CMCM    1  9 C:GETLABCMCM    1  2 C:GETLAB
STATFIN ** FICHE/FRAME BREAK *****
GETREF
C:GETREF   02/23/72            GET NODE REFERENCE.
C
C
       SUBROUTINE GET REF(A)
C
       GLOBAL NO OF NODES,  SIGMA,  NULL
       DIMENSION A(1)
       EXTERNAL GET INTEGER
       NORMAL MODE IS INTEGER
C
C
       IF NOWCHR(0)#1R,, GO TO 10
       IF ( (I=NEXTCHR(0))#1R, ),  GO TO 30
C
10     A(NO OF NODES)=IOR(4B7, NO OF NODES+1)
20     RETURN
C
C
30     IF I#1RS, GO TO 40
       A(NO OF NODES)=SIGMA
35     CALL NEXTCHR(1)
       GO TO 20
C
C
40     IF I#1RE, GO TO 50
       A(NO OF NODES)=NULL
       GO TO 35
C
C
50     CALL GET L REF(A)
       GO TO 20
C
       END
C
C
C
C
       SUBROUTINE GET L REF(A)
C
       GLOBAL NO OF NODES,  BLK CODE
       DIMENSION A(1)
       EXTERNAL GET BLOCK, GET INTEGER
       NORMAL MODE IS INTEGER
C
C
       IF ( (I=GET INTEGER)>99999 ),  CALL ERROR(4)
       IF NOWCHR(1)#1R/, GO TO 10
C
       CALL NEXTCHR(1), PACK NAME
       A(NO OF NODES)=IOR(GET BLOCK, I)
       GO TO 20
C
C
10     A(NO OF NODES)=IOR(BLK CODE, I)
20     RETURN
C
       END
STATFIN ** FICHE/FRAME BREAK *****
GETREF SYMSORT

SYM.  PG.LN. IDENT.

20      1 32 C:GETREF20      1 10 C:GETREF35      1 13 C:GETREF
CM      1 33 C:GETREFCM      1 28 C:GETREFCM      1 22 C:GETREFCM      1 20 C:GETREF
CM      1  3 C:GETREFCM10    1  9 C:GETREFCMCM    1 26 C:GETREFCMCM    1  7 C:GETREF
CMCM    1  2 C:GETREFCMCM10  1 31 C:GETREFCMCM30  1 11 C:GETREFCMCM40  1 15 C:GETREF
CMCM50  1 18 C:GETREFCMCMCM  1 21 C:GETREF
STATFIN ** FICHE/FRAME BREAK *****
GETVAL
C:GETVAL   03/12/72            GET VALUE.
C
C
       FUNCTION GET VALUE
C
       GLOBAL COMMAND,  COM NO,  NO OF NODES
       GLOBAL P FUNCTION,  P BLOCK,  P TEXT,  C TEXT
       GLOBAL STATE,  DEF(1),  NAME(1),  SPC  NODES(7)
       GLOBAL CHR VAL,  STR VAL,  FUN VAL,  BLK VAL,  LAB VAL
       GLOBAL SPC VAL(6)
       GLOBAL DEFAULT(3,2),  CUR DEFAULT(3)
       EQUIVALENCE (CUR MINIMUM, CUR DEFAULT(1)),
+                  (CUR TERMINATION, CUR DEFAULT(2)),
+                  (CUR PRIORITY, CUR DEFAULT(3))
       LOGICAL COMMAND
       EXTERNAL FIND NAME
       LOGICAL FIND NAME
       NORMAL MODE IS INTEGER
C
C
       IF COMMAND, GO TO 50
       I=NEXTCHR(0)
       IF  I#1R' .AND. I#1R",  GO TO 20
C
       CALL SET VALUE(STR VAL)
       DEF(NO OF NODES)=P TEXT+1
       CALL PACK STR
C
10     CALL NEXTCHR(0)
11     GET VALUE=0
15     RETURN
C
C
20     IF I#1R$, GO TO 30
       IF ( (I=NEXTCHR(0))<0 ),  CALL ERROR(8)
       CALL SET VALUE(CHR VAL)
       DEF(NO OF NODES)=I
       GO TO 10
C
C
30     IF 1R0<=I<=1R9, GO TO 40
       CALL PACK NAME
       (  IF NAME(1).EQ.SPC  NODES(I),  GO TO 32   ), I=1,7
C
       I=0
C
31     IF FIND NAME, GO TO 35
       CALL SET VALUE(BLK VAL+I)
       DEF(NO OF NODES)=P BLOCK
       GO TO 11
C
32     IF I#7,  GO TO  33
       IF NOWCHR(0)#1R,,  CALL ERROR(20)
       CALL NEXTCHR(1)
       CALL PACK NAME
       I=1
       GO TO 31
33     CALL SET VALUE(SPC VAL(I))
       GET VALUE=I
       GO TO 15
C
C
35     CALL SET VALUE(FUN VAL+I)
       DEF(NO OF NODES)=P FUNCTION
       GO TO 11
C
C
40     CALL GET L REF(DEF)
       CALL SET VALUE(LAB VAL)
       GO TO 11
C
C
50     IF NEXTCHR(0)#1R[, GO TO 55
C
51     CALL NEXTCHR(1)
       CALL GET COMMAND
       IF ( (I=NOWCHR(0)).EQ.1R, ),  GO TO 51
C
       IF I#1R], CALL ERROR(9)
       CALL NEXTCHR(0)
       GO TO 56
C
55     CALL GET COMMAND
56     CALL MOVE OPTIONS(DEFAULT(1,STATE), CUR DEFAULT)
       COM NO=COM NO+1
       GO TO 11
C
C
C
       LOCAL SUBROUTINE GET COMMAND
C
       GLOBAL NO OF COMMANDS,  COM VAL,  LIST NO,  ENTRY1,  ENTRY2
       GLOBAL LIS(1)
       GLOBAL SHIFT(3)
       LOGICAL CUR PRIORITY
C
       IF COM NO>777K,  CALL ERROR(1)
       K=NOWCHR(0)
       IF K<0 .OR. K.EQ.1R,,  CALL ERROR(21)
C
       C LIS=0
       IF ( (P LIS=ENTRY1+2)>=ENTRY2 ),  CALL FATAL ERROR(5)
       LIS(P LIS)=0
C
1      DO 2 J=1,3
       LIS(P LIS)=LIS(P LIS)+K*SHIFT(J)
       IF ( (C LIS=C LIS+1)>32 ),  CALL ERROR(7)
       K=NEXTCHR(1)
2      IF K<0 .OR. K.EQ.1R, .OR. K.EQ.1R],  GO TO 3
C
       IF ( (P LIS=P LIS+1)>=ENTRY2 ),  CALL FATAL ERROR(5)
       LIS(P LIS)=0
       GO TO 1
C
C
3      IF CUR MINIMUM<0,  CUR MINIMUM=C LIS
       LIS(ENTRY1+1)=IOR(CUR TERMINATION*1K15, COM NO*1K6,
+              CUR MINIMUM*1K18, C LIS)
       IF CUR PRIORITY,  LIS(ENTRY1+1)=IOR(LIS(ENTRY1+1), 1K23)
C
       ENTRY1=P LIS
       IF ( (NO OF COMMANDS=NO OF COMMANDS+1)>256 ),
+              CALL FATAL ERROR(7)
C
       CALL SET VALUE(COM VAL)
       DEF(NO OF NODES)=IOR(LIST NO*1K8, NO OF COMMANDS)
C
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
GETVAL SYMSORT

SYM.  PG.LN. IDENT.

+       3 11 C:GETVAL+       3  7 C:GETVAL+       1 11 C:GETVAL+       1 10 C:GETVAL
11      1 23 C:GETVAL15      1 24 C:GETVAL2       3  1 C:GETVAL33      2  5 C:GETVAL
56      2 22 C:GETVALCM      3 14 C:GETVALCM      3 12 C:GETVAL
CM      3  9 C:GETVALCM      3  2 C:GETVALCM      2 33 C:GETVALCM      2 30 C:GETVAL
CM      2 26 C:GETVALCM      2 18 C:GETVALCM      1 33 C:GETVALCM      1 19 C:GETVAL
CM      1  3 C:GETVALCM1     2 36 C:GETVALCM10    1 22 C:GETVALCM31    1 34 C:GETVAL
CM32    1 38 C:GETVALCM51    2 15 C:GETVALCM55    2 21 C:GETVALCMCM    1 16 C:GETVAL
CMCM    1  2 C:GETVALCMCM20  1 25 C:GETVALCMCM3   3  5 C:GETVALCMCM30  1 30 C:GETVAL
CMCM35  2  8 C:GETVALCMCM40  2 11 C:GETVALCMCM50  2 14 C:GETVALCMCMCM  2 25 C:GETVAL

STATFIN ** FICHE/FRAME BREAK *****
INPUT
C:INPUT   09/05/72             INPUT DATA MATRIX.
C
C
       SUBROUTINE INPUT(MODE, ROW NO)
C
       NORMAL MODE IS INTEGER
C
C
       LOGICAL TALK,HUSH,ECHO,TTY
       INTEGER COM NO
       COMMON /SFE/TALK,HUSH,ECHO,TTY,COM NO
C
       LOGICAL FILE INPUT,  DATA IN,  INP OK,  APP OK
       LOGICAL PROBABILISTIC,  MULTIPLE,  TRIANGULAR
       LOGICAL BACK UP
       REAL MATRIX
       GLOBAL FILE INPUT,  DATA IN,  INP OK,  APP OK,  STATE
       GLOBAL PROBABILISTIC,  MULTIPLE,  TRIANGULAR,  NO OF CASES
       GLOBAL P COLUMNS,  P ROWS,  NO OF COLUMNS,  NO OF ROWS,  MAX NAMES
       GLOBAL BACK UP
       GLOBAL MATRIX(1)
C
       LOGICAL MOD FLAG
       GLOBAL NAME(8),  MOD FLAG
C
       LOGICAL TTY FLAG,  FLAG,  ESC FLAG,  SKIP,  DEL FLAG
       REAL P, X
C
       LOGICAL END LINE,  ISTTY,  GET F 1,  GET F 2
       REAL GET VALUE
       EXTERNAL END LINE
C
C
       ROW=ROW NO
       ESC FLAG=DEL FLAG=FLAG=.FALSE.
C
       IF MODE#3,  MOD FLAG=.FALSE.
C
C
C DO SPECIAL PROCESSING ON PROBABILISTIC AND TRIANGULAR TO CHECK
C THE CONSISTENCY OF THE DATA.
C
       IF FILE INPUT,  TTY FLAG=ISTTY(2)  .ELSE.  TTY FLAG=ISTTY(-1)
C
       IF NO OF COLUMNS*(NO OF ROWS+1)>2048,  CALL ERROR(7);
+              STATE=2;  GO TO 5$
C
       IF .NOT.FILE INPUT .AND. TALK,
+              CALL DISMSG(2,3),  LIST COLUMNS(4)
C
1$     IF MODE<3,  GO TO 5
       IF ROW>NO OF ROWS,  GO TO 2$
       GO TO 10
C
5      IF NO OF COLUMNS*(NO OF ROWS+1)>2048,  CALL ERROR(7);  GO TO 8$
C
       IF PROBABILISTIC,  GO TO 200
       IF TRIANGULAR,  GO TO 300
C
C
C IN ANY CASE WE END UP HERE TO PICK UP THE STANDARD DATA.
C
C PROMPT WITH THE ROW NAME.
C
10     CALL PRM ROW
C
C GET ONE DATUM FOR EACH COLUMN LEFT.
C
100    REPEAT 110, WHILE P COLUMNS<NO OF COLUMNS
110    CALL GET NEXT
C
C CHECK TERMINATION.
C
       IF .NOT.TTY FLAG,  GO TO 120
       IF END LINE,  GO TO 120
       CALL L F ERROR(11)
       GO TO 150
C
120    ESCAPE OFF
       ROW=ROW+1
       DEL FLAG=FLAG=.FALSE.
       MOD FLAG=.TRUE.
C
       ESCAPE ON
C
C GO GET ANOTHER ROW.
C
       GO TO 1$
C
C
150    ESCAPE OFF
       GO TO 6$
C
C
C
C ON PROBABILISTIC INPUT,  WE MUST CHECK THAT THE PROBABILITIES ADD
C TO ONE.  ALSO NOT EVER ROW WILL HAVE THE MAXIMUM NUMBER OF CASES,
C IN WHICH CASE THE REST HAVE TO BE SET TO ZERO.
C
C PROMPT WITH THE ROW NAME.
C
200    CALL PRM ROW
C
C GET THE OUT FLOW VALUE.
C
       CALL GET NEXT
C
C NOW START GETTING THE INFOLWS.
C
       P=0
C
       DO 220  I=1, NO OF CASES
       IF .99999<P<1.00001,  GO TO 240
C
       CALL GET NEXT
205    CALL GET NEXT
C
C ALLOW FOR FRACTIONAL PROBABILITIES.
C
       IF NOWCHR(1)#1R/,  GO TO 215
       CALL NEXTCHR(1)
       IF NUMBER(X)>0,  GO TO 210
       CALL L F ERROR(1)
       P COLUMNS=P COLUMNS-1
       GO TO 205
C
210    CALL SET VALUE(GET VALUE(P COLUMNS)/X)
       CALL KOMMA(0)
C
C ACCUMULATE PROBABILITIES.
C
215    P=P+GET VALUE(P COLUMNS)
C
C ERROR IF WE HAVE GONE OVER ONE.
C
220    IF P>1.00001,  GO TO 230
C
C WE HAVE THE MAXIMUM NUMBER OF CASES,  THEY BETTER ADD TO ONE.
C
       IF .99999<P<1.00001,  GO TO 260
C
C WE HAVE AN ERROR CONDITION.
C
230    CALL L F ERROR(2)
       GO TO 150
C
C
C SET THE REST OF THE CASES TO ZERO.
C
240    TIMES 250, 2*NO OF CASES-P COLUMNS+1
       P COLUMNS=P COLUMNS+1
250    CALL SET VALUE(0.0)
C
C GO GET THE REST OF THE COLUMNS.
C
260    GO TO 100
C
C
C
C ON TRIANGULAR INPUT,  WE MUST CHECK THAT THE THREE INFLOWS ARE
C NON-DECREASING.
C
C PROMPT WITH THE ROW NAME.
C
300    CALL PRM ROW
C
C GET THE FIRST TWO INFLOWS.
C
       CALL GET NEXT
       CALL GET NEXT
C
C CHECK THE FIRST TWO.
C
       IF GET VALUE(1)>GET VALUE(2),  GO TO 310
C
C GET THE THIRD INFLOW AND CHECK IT.
C
       CALL GET NEXT
       IF GET VALUE(2)<=GET VALUE(3),  GO TO 100
C
C WE HAVE AN ERROR CONDITION.
C
310    CALL L F ERROR(3)
       GO TO 150
C
C
C
C RETURN LOCATION.
C
2$     ESCAPE OFF
       STATE=1
       CALL CLEAR
7$     IF TTY FLAG .AND. STATE.EQ.1,  INP OK=.FALSE.
       GO TO 5$
C
C
C
C ESCAPE LOCATION.
C
3$     ESCAPE OFF
       CALL SET ESCAPE(OLD ESCAPE)
       ESC FLAG=.TRUE.
6$     IF DEL FLAG,  CALL DEL ROW(ROW)
       DEL FLAG=.FALSE.
       CALL SET POINT(257)
       ESCAPE ON
       GO TO 1$
C
C
8$     IF .NOT.TTY FLAG,  GO TO 4$
       GO TO 2$
C
C
4$     ESCAPE OFF
       STATE=2
       IF MOD FLAG,  CALL RESTORE  .ELSE.  CALL CLEAR
C
5$     RETURN
       LOCAL SUBROUTINE PRM ROW
C
C
       GLOBAL ROWS(2,-2:-1)
       GLOBAL NO OF PERIODS
C
C
C
       P COLUMNS=0
C
C IS THIS THE FIRST TIME THRU.
C
       IF NO OF ROWS#0,  GO TO 100
C
       PERIOD=FLOW=1
       IF .NOT.MULTIPLE,  FLOW=0
C
C
10     SKIP=.FALSE.
       CALL MAKE RN(PERIOD,FLOW)
C
       IF FILE INPUT.OR.HUSH,  GO TO 20
       CALL DISSYM(NAME)
       CALL DISMSG(2,5)
C
20     IF .NOT.ESC FLAG,  GO TO 30
       CALL NEXTC(-1)
       ESCAPE OFF
       CALL SET ESCAPE(3$)
       ESC FLAG=.FALSE.
       ESCAPE ON
C
C
30     IF .NOT.END LINE,  GO TO 40
       IF FILE INPUT,  CALL READ FILE(N,2)  .ELSE.
+              CALL NEW LINE(N)
       IF N,  2$,50,40
C
40     ESCAPE OFF
       IF .NOT.BACK UP,  CALL SAVE(7$);
+              IF MODE<3,  CALL SET ESCAPE(3$, OLD ESCAPE)
       IF MODE>2,  GO TO 45
       NAME(1)=PERIOD
       NAME(2)=FLOW
       CALL INS ROW(ROW,8$)
       DEL FLAG=.TRUE.
45     ESCAPE ON
       RETURN
C
C
50     IF MODE-2,  60,2$,70
60     IF FILE INPUT .AND..NOT.TTY FLAG .AND..NOT.MULTIPLE,  GO TO 30
       IF .NOT.MULTIPLE .OR. FLAG,  GO TO 2$
       IF FLOW.EQ.1, GO TO 2$
       FLAG=.TRUE.
       IF NO OF PERIODS+1>MAX NAMES,  CALL ERROR(11);  GO TO 8$
65     PERIOD=NO OF PERIODS+1
       FLOW=1
       GO TO 10
C
C
70     SKIP=.TRUE.
       GO TO 40
C
C
C
C GET THE PERIOD AND FLOW FROM THE LAST ROW NAME.
C
100    IF MODE-2,  110,130,140
C
110    IF .NOT.MULTIPLE,  GO TO 120
       IF FLAG,  GO TO 65
       PERIOD=NO OF PERIODS
115    FLOW=ROWS(2, -NO OF PERIODS)+1
       GO TO 10
C
C
120    PERIOD=ROW
       FLOW=0
       GO TO 10
C
C
130    GO TO 150
C
C
140    IF GET F 1(ROW),  GO TO 150
       ROW=ROW+1
       IF ROW>NO OF ROWS,  GO TO 2$
       GO TO 140
C
150    IF .NOT.MULTIPLE,  GO TO 120
C
       CALL GET FLOW(PERIOD,FLOW,ROW)
       GO TO 10
       LOCAL SUBROUTINE GET NEXT
C
       GLOBAL COLUMNS(2,1)
C
C
5      P COLUMNS=P COLUMNS+1
       IF P COLUMNS>NO OF COLUMNS,  GO TO 70
       IF .NOT.GET F 2(P COLUMNS),  GO TO 5
C
       IF SKIP,  SKIP=.FALSE.;  GO TO 70
C
10     IF .NOT.END LINE,  GO TO 50
15     IF FILE INPU .AND. .NOT.TTY FLAG,  GO TO 20
       IF HUSH,  GO TO 20
       CALL DISSYM(COLUMNS(1, P COLUMNS))
       CALL DISMSG(2,2)
C
20     IF FILE INPUT,  CALL READ FILE(N,2)  .ELSE.
+              CALL NEW LINE(N)
       IF N.EQ.0 .AND. MODE.EQ.4,  GO TO 70
       IF N>=0,  GO TO 10
       CALL ERROR(5)
       GO TO 4$
C
C
C
50     IF KOMMA(0)>0,  (IF MODE.EQ.4, GO TO 70  .ELSE.  X=0; GO TO 55)
       IF NUMBER(X),  60,15,53
53     IF END LINE .OR. KOMMA(0)>0,  GO TO 55
       N=NOWCHR(1)
       IF N.EQ.0 .OR. N.EQ.1R/ .OR. LASTCHR(1).EQ.0,  GO TO 54
       CALL L F ERROR(4)
       GO TO 15
C
54     CALL KOMMA(0)
55     CALL SET VALUE(X)
       GO TO 70
C
60     CALL L F ERROR(6)
       GO TO 15
C
70     RETURN
       LOCAL SUBROUTINE SET VALUE(VALUE)
C
       REAL VALUE
C
       IF MODE.EQ.4,  MOD FLAG=.TRUE.
       MATRIX(P COLUMNS+NO OF COLUMNS*(ROW-1))=VALUE
       RETURN
C
C
C
       LOCAL REAL FUNCTION GET VALUE(POINT)
C
       GET VALUE=MATRIX(POINT+NO OF COLUMNS*(ROW-1))
       RETURN
       LOCAL SUBROUTINE L F ERROR(NO)
C
       CALL ERROR(NO)
       IF .NOT.TTY FLAG,  GO TO 4$
       CALL SET POINT(257)
       RETURN
C
C
       END
STATFIN ** FICHE/FRAME BREAK *****
INPUT SYMSORT

SYM.  PG.LN. IDENT.

+       6 11 C:INPUT +       5  1 C:INPUT +       4 36 C:INPUT +       1 32 C:INPUT 
+       1 30 C:INPUT 110     2  5 C:INPUT 115     5 25 C:INPUT 15      6  6 C:INPUT 
205     2 32 C:INPUT 250     3 15 C:INPUT 45      5  7 C:INPUT 53      6 18 C:INPUT 
55      6 24 C:INPUT 6$      4  4 C:INPUT 60      5 10 C:INPUT 65      5 15 C:INPUT 
7$      3 37 C:INPUT C       3 19 C:INPUT C       2 22 C:INPUT 
C       2 21 C:INPUT C       1 27 C:INPUT CM      6 38 C:INPUT CM      6 35 C:INPUT 
CM      6 31 C:INPUT CM      6 30 C:INPUT CM      6  4 C:INPUT CM      5 39 C:INPUT 
CM      5 36 C:INPUT CM      4 25 C:INPUT CM      4 21 C:INPUT CM      4 20 C:INPUT 
CM      3 28 C:INPUT CM      3 26 C:INPUT CM      3 23 C:INPUT CM      3  8 C:INPUT 
CM      2 34 C:INPUT CM      2 31 C:INPUT CM      2 29 C:INPUT CM      2 28 C:INPUT 
CM      2 26 C:INPUT CM      2 17 C:INPUT CM      2 15 C:INPUT CM      2  7 C:INPUT 
CM      1 37 C:INPUT CM      1 31 C:INPUT CM      1 29 C:INPUT CM      1 28 C:INPUT 
CM      1 25 C:INPUT CM      1 20 C:INPUT CM      1 18 C:INPUT CM      1 16 C:INPUT 
CM      1  7 C:INPUT CM      1  3 C:INPUT CM1$    1 33 C:INPUT CM10    6  5 C:INPUT 
CM10    2  2 C:INPUT CM100   5 21 C:INPUT CM100   2  4 C:INPUT CM110   5 22 C:INPUT 
CM120   2 11 C:INPUT CM150   5 35 C:INPUT CM2$    3 34 C:INPUT CM20    6 10 C:INPUT 
CM20    4 28 C:INPUT CM200   2 24 C:INPUT CM210   3  1 C:INPUT CM215   3  4 C:INPUT 
CM220   3  6 C:INPUT CM230   3 10 C:INPUT CM240   3 13 C:INPUT CM260   3 17 C:INPUT 
CM3$    4  1 C:INPUT CM300   3 21 C:INPUT CM310   3 31 C:INPUT CM40    4 38 C:INPUT 
CM5     1 36 C:INPUT CM5$    4 14 C:INPUT CM54    6 23 C:INPUT CM60    6 26 C:INPUT 
CM70    6 28 C:INPUT CMC     4 19 C:INPUT CMC     3 30 C:INPUT CMC     3 27 C:INPUT 
CMC     3 25 C:INPUT CMC     3 22 C:INPUT CMC     3 20 C:INPUT CMC     3 16 C:INPUT 
CMC     3  9 C:INPUT CMC     3  7 C:INPUT CMC     3  5 C:INPUT CMC     3  3 C:INPUT 
CMC     2 33 C:INPUT CMC     2 27 C:INPUT CMC     2 25 C:INPUT CMC     2 23 C:INPUT 
CMC     2 16 C:INPUT CMC     2  6 C:INPUT CMC     2  3 C:INPUT CMC     2  1 C:INPUT 
CMCM    7  3 C:INPUT CMCM    4 16 C:INPUT CMCM    1 23 C:INPUT CMCM    1  4 C:INPUT 
CMCM    1  2 C:INPUT CMCM10  4 23 C:INPUT CMCM12  5 27 C:INPUT CMCM13  5 30 C:INPUT 
CMCM14  5 31 C:INPUT CMCM15  2 18 C:INPUT CMCM30  4 34 C:INPUT CMCM4$  4 11 C:INPUT 
CMCM5   6  1 C:INPUT CMCM50  5  9 C:INPUT CMCM70  5 18 C:INPUT CMCM8$  4  9 C:INPUT 
CMCMC   3 12 C:INPUT CMCMC   1 39 C:INPUT CMCMC   1 26 C:INPUT CMCMCM  6 34 C:INPUT 
CMCMCM  6 16 C:INPUT CMCMCM  5 20 C:INPUT CMCMCM  4 18 C:INPUT CMCMCM  3 39 C:INPUT 
CMCMCM  3 33 C:INPUT CMCMCM  3 18 C:INPUT CMCMCM  2 20 C:INPUT L       6 37 C:INPUT 
L       6 29 C:INPUT L       5 38 C:INPUT L       4 15 C:INPUT 
STATFIN ** FICHE/FRAME BREAK *****
INT
       SUBROUTINE INT(R,N)
       INTEGER STATE
       GLOBAL SUM,STATE
       IF(N)5,10,5
5      SUM=(1.+R/N)**N-1.
       GO TO 15
10     SUM=EXP(R)-1.
15     DISPLAY "EFFECTIVE INTEREST RATE PER ANNUM = ",SUM
       STATE=1
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
INT SYMSORT

SYM.  PG.LN. IDENT.

10      1  7         15      1  8         5       1  5         

STATFIN ** FICHE/FRAME BREAK *****
IRR
       SUBROUTINE IRR(A,N,M,T,F)
       LOGICAL GETBEG,F
       GLOBAL NOOFCO,NOOFRO,SUM,TAXFREQ,STATE,BUFFER(360)
       INTEGER STATE,TAXFREQ
       REAL A(NOOFCO,NOOFRO)
       IF(NOOFRO.GT.360) CALL FATALE(3)
       L=0;L1=0
       ICOUNT=0
       INDEX=0
       R=0.
       DO 9 I=1,NOOFRO
       IF(M.EQ.0)TEMP=0;GO TO 5
       TEMP=A(M,I)
       IF(T.LE.0.)TEMP=0.
5      BUFFER(I)=A(N,I)-TEMP
9      IF(M.EQ.0.AND.BUFFER(I).LT.0.) INDEX=-1
       IF(M.EQ.0.AND.INDEX.EQ.0)R=1.E+75;GO TO 1010
       IF(T.LE.0.) GO TO 7
       CALL TAXCOM(T)
       IF(M.EQ.0) GO TO 7
       DO 6 I=1,NOOFRO
6      BUFFER(I)=BUFFER(I)+A(M,I)
7      IF(GETBEG(N)) L=1
       IF(M.EQ.0) GO TO 8
        IF(GETBEG(M)) L1=1
8      GO TO 20
10     IF(ICOUNT.GT.50 ) R=1.E+75;GO TO 1010
       R=R-SUM/DSUM
20     SUM=0.
       DSUM=0.
       ICOUNT=ICOUNT+1
       DO 30 I=1,NOOFRO
       Y1=BUFFER(I)/(1.+R)**(I-L)
       Y2=0.
      IF(M.NE.0) Y2=A(M,I)/(1.+R)**(I-L1)
       Y=Y1-Y2
       SUM=SUM+Y
30     DSUM=DSUM-(Y1*(I-L)-Y2*(I-L1))/(1.+R)
1000   IF(ABS(SUM).GE.1.E-6 ) GO TO 10
1010   IF .NOT. F, GO TO 1011
       IF(R.EQ.1.E+75)DISPLAY "INFEASIBLE RATE OF RETURN."
       DISPLAY "INTERNAL RATE OF RETURN PER PERIOD  = ",R
1011   SUM=R
       STATE=1
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
IRR SYMSORT

SYM.  PG.LN. IDENT.

10      1 27         1000    1 39         1010    2  1         1011    2  4         
20      1 29         30      1 38         5       1 15         6       1 22         
7       1 23         8       1 26         9       1 16         

STATFIN ** FICHE/FRAME BREAK *****
FOF
(PAUL)ABORTED
(PAUL)CALL
(PAUL)CHECKNAME
(PAUL)COMCOMCOM
(PAUL)COMCOMMSG
(PAUL)COMPILE
(PAUL)DISP
(PAUL)DISPMSG
(PAUL)ENDLIST
(PAUL)ENDOFL
(PAUL)FINAN1
(PAUL)FINAN1FUNS
(PAUL)FINAN1MSG
(PAUL)FINAN2
(PAUL)FINDATA
(PAUL)FINDATAFUNS
(PAUL)FINDATAMSG
(PAUL)FINDNAME
(PAUL)FINLIB
(PAUL)FINPAKFUNS
(PAUL)FINPAKMSG
(PAUL)FINPARFUNS
(PAUL)FIXCHAINS
(PAUL)FIXCOLUMN
(PAUL)GETINT
(PAUL)GETLAB
(PAUL)GETREF
(PAUL)GETVAL
(PAUL)INPUT
(PAUL)LCOMPILE
(PAUL)LDISP
(PAUL)LFINDATA
(PAUL)LINK
(PAUL)LIST
(PAUL)LOAD
(PAUL)LTYMFLOW
(PAUL)LWORK
(PAUL)MOVEOP
(PAUL)OUTPUT
(PAUL)PACK
(PAUL)PARFUNS
(PAUL)PARSE
(PAUL)READOP
(PAUL)READSTR
(PAUL)REPLACE
(PAUL)SETVALUE
(PAUL)STACK
(PAUL)TYMFLOW
(PAUL)TYMFLOWGRAPH
(PAUL)WORK
(PAUL)ZADCF
(PAUL)ZADCFB
(PAUL)ZADPARSE
(RAJA)A7
(RAJA)A9
(RAJA)ANNUAL
(RAJA)ARR
(RAJA)CONST
(RAJA)EFFICIENT
(RAJA)ERR
(RAJA)FORCAST
(RAJA)FVAL
(RAJA)INT
(RAJA)IRR
(RAJA)LEVEL
(RAJA)NFVAL
(RAJA)NPVAL
(RAJA)OPTION
(RAJA)PARAMETRIC
(RAJA)PAYBACK
(RAJA)PVAL
(RAJA)RANAL
(RAJA)SERIAL
(RAJA)SMOOTH
(RAJA)STATA1
(RAJA)STATA2
(RAJA)STATA3
(RAJA)STATA4
(RAJA)STATA5
(RAJA)STATA5COM
(RAJA)STATA6
(RAJA)STATA8
(RAJA)STATA8FUNS
(RAJA)STATA8MSG
(RAJA)TAXCOM
(RAJA)X
(RAJA)XPOS
(RAJA)XPOSPM
(Z)COMCOM
(Z)GRAPH
(Z)LIB
(Z)MSGCOM
(Z)SMALLEDIT
(PAUL)CONVERT
(Z)CONV
STATFIN ** FICHE/FRAME BREAK *****
LCOMPILE
COMPILEB
OUTPUTB
REPACKB
LIB
STATFIN ** FICHE/FRAME BREAK *****
LDISP
DISPB
DISPMSGDB
READSTRB
TYMFLOWGRAPHB
FINPARFUNSB
CALLB
FINLIBB
ZADPARSE
LIB
STATFIN ** FICHE/FRAME BREAK *****
LEVEL
       SUBROUTINE LEVEL(A,P,N,I1,I2,I3,F)
       LOGICAL F,INP OK,MULTIPLE
       GLOBAL NOOFCO,NOOFRO,STATE,MULTIPLE,ROWS(2,-2:-1),NOOFPE
       INTEGER STATE ,ROWS,NOOFPE
       REAL A(NOOFCO,NOOFRO)
       PAY=P*RATE(1)/(1.-1./(1.+RATE(1))**N)
       I=0
       IF(F) GO TO 10
       PINT=P*RATE(1)
       GO TO 15
10     PINT=0.
       I=1
15     IF(I1.EQ.0.AND.I2.EQ.0.AND.I3.EQ.0) GO TO 23
       DO 22 L=1,NOOFRO
       IF(I1.NE.0) A(I1,L)=0.
       IF(I2.NE.0) A(I2,L)=0.
22     IF(I3.NE.0) A(I3,L)=0.
23     PRPAY=PAY-PINT
       PBAL=P-PRPAY
       IF(PBAL.EQ.P )DISPLAY"INPUTS PRODUCE NEGLIGIBLE PRINCIPAL PAYMENTS."
       IF(I1.NE.0) A(I1,1)=INT(PRPAY*100.+.5)/100.
       IF(I2.NE.0) A(I2,1)=INT(PINT*100.+.5)/100.
       IF(I3.NE.0) A(I3,1)=INT(PBAL*100+.5)/100.
       ITEMC=1
       ISMALL=N
       IF.NOT.MULTIPLE,NOOFPE=NOOFRO
       IF(N.GT.NOOFPE) ISMALL=NOOFPE
       DO 20 J=2,ISMALL
       IF(MULTIPLE),ITEMC=ITEMC+ROWS(2,-(J-1));GO TO 16
       ITEMC=J
16     K=J-I
       PINT=PBAL*RATE(1)
       PRPAY=PAY-PINT
       PBAL=PBAL-PRPAY
       IF(I1.NE.0) A(I1,ITEMC)=INT(PRPAY*100.+.5)/100.
       IF(I2.NE.0) A(I2,ITEMC)=INT(PINT*100.+.5)/100.
       IF(I3.NE.0) A(I3,ITEMC)=INT(PBAL*100.+.5)/100.
20     CONTINUE
25     STATE=1
       IF(I1.NE.0.OR.I2.NE.0.OR.I3.NE.0) INP OK=.FALSE.
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
LEVEL SYMSORT

SYM.  PG.LN. IDENT.

10      1 11         15      1 13         16      1 31         20      1 38         
22      1 17         23      1 18         25      1 39         

STATFIN ** FICHE/FRAME BREAK *****
LINK
C:LINK   07/13/72              GET PROPER LINK INTO CORE.
C
C
       SUBROUTINE LINK(N)
C
C
       NORMAL MODE IS INTEGER
C
       LOGICAL FINPAK
       GLOBAL LINK ERR,  FINPAK
       DATA FINPAK/.FALSE./
C
       LOGICAL IN(9)
       DATA IN/.FALSE./
C
       INTEGER PRIORITY(9)
       DATA PRIORITY/8, 9, 7, 5, 3, 4, 2, 6, 1/,   NO IN, MAX IN/ 0, 1/
C
       INTEGER NAME(5), ONAME(2)
       DATA NAME/'(Z)SAF '/,  WORD, SHIFT/ 3, 16/
C
C
       IF IN(N),  GO TO 60
C
       ESCAPE OFF
C
       IF NO IN#MAX IN,  GO TO 40
C
       DO 10 I=1,8
10     IF IN(PRIORITY(I)),  GO TO 20
C
20     ONAME(1)=3HSTA
       ONAME(2)=3HTA0+PRIORITY(I)
C
       RELEASE OVERLAY ONAME
       NOIN=NOIN-1
       IN(PRIORITY(I))=.FALSE.
C
C
C
40     NAME(WORD)=IOR(LSH(N+20B,SHIFT),
+              IAND(NAME(WORD),LCY(77777400B,SHIFT)))
C
       OPEN INPUT,5 :  NAME,  TYPE 1,  ERROR  GO TO LINK ERR
       LOAD OVERLAY 5
       CLOSE 5
       NOIN=NOIN+1
       IN(N)=.TRUE.
C
50     ESCAPE ON
60     RETURN
C
C
       END
STATFIN ** FICHE/FRAME BREAK *****
LINK SYMSORT

SYM.  PG.LN. IDENT.

+       1 24 C:LINK  10      1 17 C:LINK  60      1 31 C:LINK  
CM      1 25 C:LINK  CM      1 20 C:LINK  CM      1 16 C:LINK  CM      1 15 C:LINK  
CM      1 14 C:LINK  CM      1 11 C:LINK  CM      1  9 C:LINK  CM      1  7 C:LINK  
CM      1  4 C:LINK  CM20    1 18 C:LINK  CM50    1 30 C:LINK  CMCM    1 32 C:LINK  
CMCM    1 13 C:LINK  CMCM    1  3 C:LINK  CMCM    1  2 C:LINK  CMCMCM  1 23 C:LINK  

STATFIN ** FICHE/FRAME BREAK *****
LIST
C:LIST   09/26/72              LIST DATA MATRIX.
C
C
       SUBROUTINE LIST(MATRIX,HEADING)
C
C
       NORMAL MODE IS INTEGER
C
C
       COMMON /CODE/MAX CODE, N CODE, CODE(1)
C
       LOGICAL MULTIPLE,  SPECIAL
       GLOBAL MULTIPLE,  SPECIAL,  STATE
       GLOBAL CPL,  NO OF COLUMNS,  NO OF ROWS,  MAX NAMES
       GLOBAL COLUMNS(2,1),  ROWS(2,-2:-1),  TITLE(2)
       GLOBAL NAME(2)
C
       INTEGER COL WIDTH(100)
C
       LOGICAL HEADING,  I FLAG,  E FLAG
       REAL MATRIX(NO OF COLUMNS, NO OF ROWS)
C
       LOGICAL GET F 1,  GET F 2
C
C
       CALL OFF TRUNCATE
       CALL SET FLAGS(CODE(3))
       (  COL WIDTH(I)=0  ),  I=1,100
C
C
       CALL SET ESCAPE(300S)
C
       ROW WIDTH=0
       IF .NOT.HEADING,  GO TO 50
C
       DO 40 I=1, NO OF ROWS
       IF .NOT.GET F 1(I),  GO TO 40
       CALL MK ROW N
       ROW WIDTH=MAX(ROW WIDTH, COUNT(NAME))
40     CONTINUE
C
C
50     BEG=1
       NCHARS=0
C
55     IF HEADING,  NCHARS=NCHARS+ROW WIDTH
C
       DO 70 END=BEG, NO OF COLUMNS
       IF BEG.EQ.END .AND. BEG#1,  GO TO 70
       IF .NOT.GET F 2(END),  GO TO 70
C
       MAX L1=MAX L2=MAX L3=0
       I FLAG=E FLAG=.FALSE.
C
       DO 60 I=1, NO OF ROWS
       IF .NOT.GET F 1(I),  GO TO 60
C
       IF CONVERT(MATRIX(END,I),L1,L2,L3),  E FLAG=.TRUE.
       MAX L1=MAX(MAX L1, L1)
       MAX L2=MAX(MAX L2, L2)
       MAX L3=MAX(MAX L3, L3)
C
60     CONTINUE
C
       IF MAX L1+MAX L2>MAX L3+3,  E FLAG=.TRUE.
       IF MAX L2.EQ.0 .AND. .NOT.E FLAG,  I FLAG=.TRUE.
C
       CALL SET WIDTH(END)
C
       WIDTH=GET WIDTH(END)
       IF NCHARS+WIDTH>CPL,  GO TO 75
C
       NCHARS=NCHARS+WIDTH
C
70     CONTINUE
C
C
C
75     CALL DISPLAY('$$/')
C
       IF .NOT.HEADING,  GO TO 81
C
       IF N CODE<4 .AND. TITLE(1)#0,  CALL DISPLAY('TITLE- /'),
+              DISSYM(TITLE),  DISCHR(155B)
       CALL DISCHR(135B), DISCHR(ROW WIDTH)
C
       DO 80 I=BEG,END-1
       IF .NOT.GET F 2(I),  GO TO 80
       WIDTH=GET WIDTH(I)
       J=COUNT(COLUMNS(1,I))
       CALL DISCHR(135B)
       CALL DISCHR(WIDTH-J)
       CALL DISSTR(COLUMNS(1,I),J)
80     CONTINUE
C
       CALL DISCHR(155B)
C
C
81     DO 100 I=1, NO OF ROWS
       IF .NOT.GET F 1(I),  GO TO 100
       IF .NOT.HEADING,  GO TO 90
       CALL MK ROW N
C
       J=DISSYM(NAME)
       IF J.EQ.ROW WIDTH,  GO TO 90
       CALL DISCHR(135B)
       CALL DISCHR(ROW WIDTH-J)
C
90     DO 95 J=BEG,END-1
       IF .NOT.GET F 2(J),  GO TO 95
       WIDTH=GET WIDTH(J)
       IF N.EQ.3,  K=1  .ELSE.  K=0
       CALL SET SCALE(K)
       CALL OUTRFMT(-2, MATRIX(J,I), N, WIDTH, L2)
95     CONTINUE
C
       CALL DISCHR(155B)
C
100    CONTINUE
C
C
       CALL DISPLAY('$$/')
       IF END>NO OF COLUMNS,  GO TO 200
C
       NCHARS=GET WIDTH(END)
       BEG=END
       GO TO 55
C
C
200    STATE=1
       GO TO 400
C
C
300    STATE=3
C
400    DISCONNECT ESCAPE
       RETURN
       SUBROUTINE SET WIDTH(N1)
C
C
       N=2K10
       IF I FLAG,  N=1K10
       IF E FLAG,  N=3K10
       N3=LRSH(N1+1,1)
       IF E FLAG,  MAX L1=0;  MAX L2=MAX L3
       COL WIDTH(N3)=IOR(COL WIDTH(N3),
+              LSH(IOR(N,LSH(MAX L1,5),MAX L2), 12*IAND(N1,1)))
       RETURN
C
C
C
       INTEGER FUNCTION GET WIDTH(N2)
C
       GET WIDTH=IAND(LRSH(COL WIDTH(LRSH(N2+1,1)), 12*IAND(N2,1)),
+              7777B)
       N=RSH(GET WIDTH,10)
       L2=IAND(GET WIDTH,37B)
       GET WIDTH=IAND(RSH(GET WIDTH,5),37B)
       IF N-2,  3,2,1
1      GET WIDTH=L2+5
       L2=L2-1
       GO TO 3
2      GET WIDTH=GET WIDTH+L2+1
3      GET WIDTH=GET WIDTH+2
       IF HEADING,  GET WIDTH=MAX(GET WIDTH, COUNT(COLUMNS(1,N2))+1)
       RETURN
       LOCAL SUBROUTINE MK ROW N
C
C
       IF .NOT.MULTIPLE,  GO TO 85
       CALL GET FLOW(PERIOD,FLOW,I)
       GO TO 87
C
85     IF .NOT.SPECIAL,  GO TO 86
       NAME(1)=ROWS(1,-I)
       NAME(2)=ROWS(2,-I)
       GO TO 88
C
86     PERIOD=I
       FLOW=0
C
87     CALL MAKE RN(PERIOD,FLOW)
C
88     RETURN
       LOCAL INTEGER FUNCTION COUNT(A)
C
C
       INTEGER A(2),  B(2)
       REAL RB
       EQUIVALENCE (RB,B)
C
C
       B(1)=A(1)
       B(2)=A(2)
C
       DO 1 COUNT=0,5
       IF BRESET(B(1),377K16),  GO TO 2
1      RB=LSHD(RB,8)
C
2      RETURN
C
C
       END
STATFIN ** FICHE/FRAME BREAK *****
LIST SYMSORT

SYM.  PG.LN. IDENT.

+       3 21 C:LIST  +       3 17 C:LIST  +       2 11 C:LIST  1       4 14 C:LIST  
1       3 26 C:LIST  2       3 29 C:LIST  3       3 30 C:LIST  40      1 24 C:LIST  
80      2 20 C:LIST  95      2 36 C:LIST  CM      4 12 C:LIST  
CM      3 20 C:LIST  CM      3  2 C:LIST  CM      2 37 C:LIST  CM      2 26 C:LIST  
CM      2 21 C:LIST  CM      2 13 C:LIST  CM      2 10 C:LIST  CM      2  9 C:LIST  
CM      2  6 C:LIST  CM      2  4 C:LIST  CM      2  3 C:LIST  CM      2  1 C:LIST  
CM      1 35 C:LIST  CM      1 33 C:LIST  CM      1 31 C:LIST  CM      1 28 C:LIST  
CM      1 20 C:LIST  CM      1 18 C:LIST  CM      1 13 C:LIST  CM      1 11 C:LIST  
CM      1 10 C:LIST  CM      1  5 C:LIST  CM100   2 38 C:LIST  CM2     4 15 C:LIST  
CM400   3  8 C:LIST  CM55    1 27 C:LIST  CM60    1 39 C:LIST  CM70    2  7 C:LIST  
CM85    3 37 C:LIST  CM86    4  2 C:LIST  CM87    4  4 C:LIST  CM88    4  5 C:LIST  
CM90    2 30 C:LIST  CMCM    4 16 C:LIST  CMCM    4 10 C:LIST  CMCM    4  7 C:LIST  
CMCM    3 34 C:LIST  CMCM    3 11 C:LIST  CMCM    2 39 C:LIST  CMCM    1 17 C:LIST  
CMCM    1 14 C:LIST  CMCM    1  4 C:LIST  CMCM    1  3 C:LIST  CMCM    1  2 C:LIST  
CMCM20  3  5 C:LIST  CMCM30  3  7 C:LIST  CMCM50  1 25 C:LIST  CMCM81  2 22 C:LIST  
CMCMCM  3 19 C:LIST  CMCMCM  2  8 C:LIST  L       4  6 C:LIST  L       3 33 C:LIST  
L       3 10 C:LIST  
STATFIN ** FICHE/FRAME BREAK *****
LOAD
C:LOAD   09/22/72              LOAD DATA FILE.
C
C
       SUBROUTINE S LOAD
C
       NORMAL MODE IS INTEGER
C
       LOGICAL NORMAL,  SYMMETRIC
       REAL MATRIX
C
       GLOBAL NORMAL,  SYMMETRIC
       GLOBAL NO OF COLUMNS,  NO OF ROWS,  STATE
       GLOBAL MATRIX(1)
C
C
       LINE NO=1
       CALL READ FILE(N,2)
       IF N<0,  GO TO 300
C
C
       DO 100 I=0, NO OF ROWS-1
C
       IF SYMMETRIC,  K=I+1  .ELSE.  K=NO OF COLUMNS
C
       DO 30 J=1,K
10     IF NUMBER(MATRIX(J+NO OF COLUMNS*I)),  200,20,30
C
20     CALL READ FILE(N,2)
       IF N<0,  GO TO 300
       LINE NO=LINE NO+1
       GO TO 10
C
30     CONTINUE
C
C
100    CONTINUE
C
       ESCAPE OFF
       STATE=1
C
       IF .NOT.SYMMETRIC,  GO TO 110
       ( ( MATRIX(I+NO OF COLUMNS*(J-1))=MATRIX(J+NO OF COLUMNS*(I-1))
+              ), J=1,I-1 ), I=1, NO OF ROWS
       SYMMETRIC=.FALSE.
       NORMAL=.TRUE.
C
110    RETURN
C
C
200    CALL OUTMSG(1,1,1)
       CALL OUTNUM(1,LINE NO)
       CALL ERROR(13)
       GO TO 310
C
C
300    CALL ERROR(2)
C
310    STATE=2
       GO TO 110
C
C
       END
STATFIN ** FICHE/FRAME BREAK *****
LOAD SYMSORT

SYM.  PG.LN. IDENT.

+       1 26 C:LOAD  10      1 15 C:LOAD  CM      1 24 C:LOAD  
CM      1 22 C:LOAD  CM      1 14 C:LOAD  CM      1 13 C:LOAD  CM      1  6 C:LOAD  
CM      1  4 C:LOAD  CM      1  3 C:LOAD  CM110   1 29 C:LOAD  CM20    1 16 C:LOAD  
CM30    1 20 C:LOAD  CM310   1 35 C:LOAD  CMCM    1 37 C:LOAD  CMCM    1 12 C:LOAD  
CMCM    1  9 C:LOAD  CMCM    1  2 C:LOAD  CMCM10  1 21 C:LOAD  CMCM20  1 30 C:LOAD  
CMCM30  1 34 C:LOAD  
STATFIN ** FICHE/FRAME BREAK *****
MOVEOP
C:MOVEOP   02/11/72            MOVE OPTIONS.
C
C
       SUBROUTINE MOVE OPTIONS(FROM,TO)
C
       INTEGER FROM(3),TO(3)

       DO 1,I=1,3
1      TO(I)=FROM(I)

       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
MOVEOP SYMSORT

SYM.  PG.LN. IDENT.

1       1  6 C:MOVEOPCM      1  3 C:MOVEOPCMCM    1  2 C:MOVEOP

STATFIN ** FICHE/FRAME BREAK *****
NFVAL
       SUBROUTINE NFVAL(A,N,M,T,CF,F)
       LOGICAL CF,GETBEG,F
       GLOBAL NOOFCO,NOOFRO,SUM,TAXFREQ,BUFFER(360),STATE
       INTEGER TAXFREQ,STATE
       REAL A(NOOFCO,NOOFRO)
       IF(NOOFRO.GT.360) CALL FATALE(3)
       INDEX=N
       ICOUNT=0
1      SUM=0.
       DO 10 I=1,NOOFRO
       TEMP=A(M,I)
       IF(ICOUNT.EQ.1)BUFFER(I)=TEMP;GO TO 10
       IF(T.LE.0.)TEMP=0.
       BUFFER(I)=A(N,I)-TEMP
10     CONTINUE
       IF(ICOUNT.EQ.1.OR.T.LE.0.) GO TO 15
       CALL TAXCOM(T)
       DO 12 I=1,NOOFRO
12     BUFFER(I)=BUFFER(I)+A(M,I)
15     IF(GETBEG(INDEX)) GO TO 100
       IF(CF) GO TO 50
       DO 20 I=1,NOOFROWS-1
20     SUM=(SUM+BUFFER(I))*(1+RATE(I+1))
       SUM=SUM+BUFFER(NOOFRO)
       GO TO 1000
50     DO 30 I=1,NOOFROWS-1
30     SUM=(SUM+BUFFER(I))*EXP(RATE(I+1))
       SUM=SUM+BUFFER(NOOFRO)
       GO TO 1000
100    IF(CF) GO TO 60
       DO 40 I=0,NOOFROWS-1
40     SUM=(SUM+BUFFER(I+1))*(1+RATE(I+1))
       GO TO 1000
60     DO 70 I=0,NOOFROWS-1
70     SUM=(SUM+BUFFER(I+1))*EXP(RATE(I+1))
1000   IF(ICOUNT.EQ.0)GO TO 1010
       SUM2=SUM
       SUM=SUM1-SUM2
       GO TO 1020
1010   ICOUNT=1
       SUM1=SUM
       INDEX=M
       GO TO 1
1020   IF(.NOT.F) STATE=1;RETURN
       DISPLAY "NET FUTURE VALUE = ",SUM
       STATE=1
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
NFVAL SYMSORT

SYM.  PG.LN. IDENT.

1       1  9         10      1 15         100     1 30         1000    1 36         
1010    2  1         1020    2  5         12      1 19         15      1 20         
20      1 23         30      1 27         40      1 32         50      1 26         
60      1 34         70      1 35         
STATFIN ** FICHE/FRAME BREAK *****
NPVAL
       SUBROUTINE NPVAL(A,N,M,T,CF,F)
       LOGICAL CF,GETBEG,F
       GLOBAL NOOFCO,NOOFRO,SUM,TAXFREQ,BUFFER(360),STATE
       INTEGER TAXFREQ,STATE
       REAL A(NOOFCO,NOOFRO)
       IF(NOOFRO.GT.360)CALL FATALE(3)
       INDEX=N
       ICOUNT=0
1      SUM=0.
       DO 10 I=1,NOOFRO
       TEMP=A(M,I)
       IF(ICOUNT.EQ.1)BUFFER(I)=TEMP;GO TO 10
       IF(T.LE.0.)TEMP=0.
       BUFFER(I)=A(N,I)-TEMP
10     CONTINUE
       IF(ICOUNT.EQ.1.OR.T.LE.0.) GO TO 15
       CALL TAXCOM(T)
       DO 12 I=1,NOOFRO
12     BUFFER(I)=BUFFER(I)+A(M,I)
15     IF(GETBEG(INDEX)) GO TO 100
       IF(CF) GO TO 50
       DO 20 I=1,NOOFROWS
20     SUM=(SUM+BUFFER(NOOFRO-I+1))/(1+RATE(NOOFRO-I+1))
       GO TO 1000
50     DO 30 I=1,NOOFROWS
30     SUM=(SUM+BUFFER(NOOFRO-I+1))/EXP(RATE(NOOFRO-I+1))
       GO TO 1000
100    IF(CF) GO TO 60
       DO 40 I=0,NOOFROWS-1
40     SUM=(SUM+BUFFER(NOOFRO-I))/(1+RATE(NOOFRO-I-1))
       GO TO 1000
60     DO 70 I=0,NOOFROWS-1
70     SUM=(SUM+BUFFER(NOOFRO-I))/EXP(RATE(NOOFRO-I-1))
1000   IF(ICOUNT.EQ.0) GO TO 1010
       SUM2=SUM
       SUM=SUM1-SUM2
       GO TO 1020
1010   ICOUNT=1
       SUM1=SUM
       INDEX=M
       GO TO 1
1020   IF(.NOT.F) STATE=1;RETURN
       DISPLAY "NET PRESENT VALUE = ",SUM
       STATE=1
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
NPVAL SYMSORT

SYM.  PG.LN. IDENT.

1       1  9         10      1 15         100     1 28         1000    1 34         
1010    1 38         1020    2  3         12      1 19         15      1 20         
20      1 23         30      1 26         40      1 30         50      1 25         
60      1 32         70      1 33         
STATFIN ** FICHE/FRAME BREAK *****
OPTION
       SUBROUTINE OPTION(A,P,N,NO,I1,I2,I3,F)
       LOGICAL F,INP OK,MULTIPLE
       GLOBAL NOOFCO,NOOFRO,STATE,MULTIPLE,ROWS(2,-2:-1),NOOFPE
       INTEGER STATE,ROWS,NOOFPE
       REAL A(NOOFCO,NOOFRO)
       I=0
       IF(F) GO TO 10
       PINT=P*RATE(1)
       GO TO 15
10     PINT=0.
       I=1
15     IF(I1.EQ.0.AND.I2.EQ.0.AND.I3.EQ.0) GO TO 23
       DO 22 L=1,NOOFRO
       IF(I1.NE.0) A(I1,L)=0.
       IF(I2.NE.0) A(I2,L)=0.
22     IF(I3.NE.0) A(I3,L)=0.
23     PRPAY=A(NO,1)
       PBAL=P-PRPAY
       IF(I2.NE.0) A(I2,1)=INT(PINT*100.+.5)/100.
       IF(I3.NE.0) A(I3,1)=INT(PBAL*100.+.5)/100.
       ITEMC=1
       ISMALL=N
       IF.NOT.MULTIPLE,NOOFPE=NOOFRO
       IF(N.GT.NOOFPE) ISMALL=NOOFPE
      DO 20 J=2,ISMALL
       K=ITEMC
       IF(MULTIPLE),ITEMC=ITEMC+ROWS(2,-(J-1));GO TO 16
       ITEMC=J
16     IF(I.EQ.0)K=ITEMC
       PINT=PBAL*RATE(K)
       PRPAY=A(NO,ITEMC)
       PBAL=PBAL-PRPAY
       IF(I2.NE.0) A(I2,ITEMC)=INT(PINT*100.+.5)/100.
       IF(I3.NE.0) A(I3,ITEMC)=INT(PBAL*100.+.5)/100.
20     CONTINUE
       IF(PBAL)21,25,21
21     DISPLAY"PAYMENTS DO NOT EQUAL PRINCIPAL."
       STATE=2
25     IF(STATE.EQ.2) RETURN
       STATE=1
       IF(I1.NE.0.OR.I2.NE.0.OR.I3.NE.0) INP OK=.FALSE.
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
OPTION SYMSORT

SYM.  PG.LN. IDENT.

10      1 10         15      1 12         16      1 29         20      1 35         
21      1 37         22      1 16         23      1 17         25      1 39         

STATFIN ** FICHE/FRAME BREAK *****
OUTPUT
C:OUTPUT   2/23/72             OUTPUT CODE ROUTINES.
C
C
       SUBROUTINE SO
C
       NORMAL MODE IS INTEGER
C
C
       GLOBAL BUFF(1),  MODE
C
       INTEGER SHIFT(0/7)
       DATA SHIFT/0, 3, 6, 9, 12, 15, 18, 21/
C
       DATA P BUFF/15/
C
C
       CODE=0
       COUNT=7
       P BUFF=P BUFF+1
       P CODE=P BUFF
       RETURN
C
C
C
       SUBROUTINE SB(SB WORD)
C
       BUFF(P CODE)=IOR(CODE,LSH(4B,SHIFT(COUNT)))
       P BUFF=P BUFF+1
       BUFF(P BUFF)=SB WORD
       RETURN
C
C
C
       SUBROUTINE OW(OW WORD)
C
       CODE=IOR(CODE,LSH(MODE,SHIFT(COUNT)))
       P BUFF=P BUFF+1
       BUFF(P BUFF)=OW WORD
       COUNT=COUNT-1
C
       IF COUNT>=0, GO TO 10
       BUFF(P CODE)=CODE
       P CODE=P CODE+9
       P BUFF=P BUFF+1
       COUNT=7
       CODE=0
       IF P BUFF>2048,  CALL WRITE
C
10     RETURN
C
C
C
       SUBROUTINE O(O WORD)
C
       P BUFF=P BUFF+1
       BUFF(P BUFF)=O WORD
C
       IF P BUFF>=2048,  CALL WRITE
C
       RETURN
C
C
C
       SUBROUTINE EO
C
       CALL BIO(BUFF, P BUFF)
       RETURN
C
C
C
       SUBROUTINE WRITE
C
       CALL BIO(BUFF,2048)
C
       DO 10 I=2049, P BUFF
10     BUFF(I-2048)=BUFF(I)
C
       P BUFF=P BUFF-2048
       P CODE=P CODE-2048
C
       RETURN
C
C
C
       LOCAL SUBROUTINE BIO(A,C)
C
       INTEGER A(C)
C
       WRITE (4) A
C
       RETURN
C
       END
STATFIN ** FICHE/FRAME BREAK *****
OUTPUT SYMSORT

SYM.  PG.LN. IDENT.

10      2  3 C:OUTPUTCM      2 11 C:OUTPUTCM      2 10 C:OUTPUT
CM      2  9 C:OUTPUTCM      2  8 C:OUTPUTCM      2  6 C:OUTPUTCM      2  4 C:OUTPUT
CM      2  2 C:OUTPUTCM      2  1 C:OUTPUTCM      1 37 C:OUTPUTCM      1 35 C:OUTPUT
CM      1 34 C:OUTPUTCM      1 32 C:OUTPUTCM      1 23 C:OUTPUTCM      1 19 C:OUTPUT
CM      1 14 C:OUTPUTCM      1  7 C:OUTPUTCM      1  5 C:OUTPUTCM      1  3 C:OUTPUT
CM10    1 30 C:OUTPUTCMCM    1  8 C:OUTPUTCMCM    1  4 C:OUTPUTCMCM    1  2 C:OUTPUT
CMCMCM  2  7 C:OUTPUTCMCMCM  1 39 C:OUTPUTCMCMCM  1 36 C:OUTPUTCMCMCM  1 31 C:OUTPUT
CMCMCM  1 18 C:OUTPUTCMCMCM  1 13 C:OUTPUT
STATFIN ** FICHE/FRAME BREAK *****
LFINDATA
FINDATAB
ABORTEDB
FINDATAMSGDB
INPUTB
LISTB
REPLACEB
FINDATAFUNSB
FINLIBB
CONVERTB
CONV
LIB
STATFIN ** FICHE/FRAME BREAK *****
LTYMFLOW
TYMFLOWB
ABORTEDB
LINKB
LOADB
FINPAKMSGDB
FINPAKFUNSB
FIXCOLUMNB
FINMLB
FINLIBB
LIB
STATFIN ** FICHE/FRAME BREAK *****
LWORK
WORKB
FIXCHAINSB
STACKB
ENDLISTB
READOPB
MOVEOPB
GETLABB
GETVALB
GETREFB
GETINTB
CHECKNAMEB
FINDNAMEB
PACKB
SETVALUEB
ENDOFLB
COMCOMCOMDB
COMCOMMSGDB
LIB
STATFIN ** FICHE/FRAME BREAK *****
MAKESTAT
"C:MSTATFLO   06/07/72

GO COMCOM
COMCOMCOM,COMCOMCOMD

GO MSGCOM
COMCOMMSG,COMCOMMSGD

NARP
*BFMACRO
CON
ZADCF
B


CON
REPACK
B1


BFBED
P B,ZADCFB

P B1,REPACKB

Q
DEL B1
BFO
OFF ARG
COM PARSE,PARSEB

COM PARFUNS,PARFUNSB

COM COMPILE,COMPILEB

COM OUTPUT,OUTPUTB

COM WORK,WORKB

COM FIXCHAINS,FIXCHAINSB

COM STACK,STACKB

COM ENDLIST,ENDLISTB

COM READOP,READOPB

COM MOVEOP,MOVEOPB

COM GETLAB,GETLABB

COM GETVAL,GETVALB

COM GETREF,GETREFB

COM GETINT,GETINTB

COM CHECKNAME,CHECKNAMEB

COM FINDNAME,FINDNAMEB

COM PACK,PACKB

COM SETVALUE,SETVALUEB

COM ENDOFL,ENDOFLB

COM COMCOMCOMD,COMCOMCOMDB

COM COMCOMMSGD,COMCOMMSGDB

Q
BFORTRAN4
LOAD LWORK
FINISH
LOAD LCOMPILE
FINISH
DUMP GRAPH

QUIT
BFBED
LIBRARY
MERGE TO B
PARSEB
PARFUNSB
ZADCFB

INDEX B,ZADPARSE
QUIT
GO COMCOM
STATA5COM,STATA5COMD

GO GRAPH
TYMFLOWGRAPH,TYMFLOWGRAPHB

GO MSGCOM
FINPAKMSG,FINPAKMSGD

GO MSGCOM
FINDATAMSG,FINDATAMSGD

GO MSGCOM
DISPMSG,DISPMSGD

GO MSGCOM
FINAN1MSG,FINAN1MSGD

GO MSGCOM
STATA8MSG,STATA8MSGD

NARP
*BFMACRO
CON
FINML
B


CON
CONVERT
B1


BFBED
P B,FINMLB

P B1,CONVERTB

Q
DEL B1
BFO
OFF ARG
COM TYMFLOW,TYMFLOWB

COM ABORTED,ABORTEDB

COM LINK,LINKB

COM FIXCOLUMN,FIXCOLUMNB

COM FINPAKMSGD,FINPAKMSGDB

COM FINPAKFUNS,FINPAKFUNSB

COM FINLIB,FINLIBB

COM FINDATA,FINDATAB

COM FINDATAMSGD,FINDATAMSGDB

COM LOAD,LOADB

COM INPUT,INPUTB

COM LIST,LISTB

COM REPLACE,REPLACEB

COM FINDATAFUNS,FINDATAFUNSB

COM DISP,DISPB

COM DISPMSGD,DISPMSGDB

COM READSTR,READSTRB

COM FINPARFUNS,FINPARFUNSB

COM CALL,CALLB

COM FINAN1,FINAN1B

COM FINAN1MSGD,FINAN1MSGDB

COM FINAN2,FINAN2B

COM FINAN1FUNS,FINAN1FUNSB

COM PVAL,PVALB

COM NPVAL,NPVALB

COM FVAL,FVALB

COM NFVAL,NFVALB

COM IRR,IRRB

COM ERR,ERRB

COM INT,INTB

COM ANNUAL,ANNUALB

COM OPTION,OPTIONB

COM CONST,CONSTB

COM SERIAL,SERIALB

COM LEVEL,LEVELB

COM PAYBACK,PAYBACKB

COM ARR,ARRB

COM TAXCOM,TAXCOMB

COM PARAMETRIC,PARAMETRICB

COM EFFICIENT,EFFICIENTB

COM RANAL,RANALB

COM STATA1,STATA1B

COM STATA2,STATA2B

COM STATA3,STATA3B

COM STATA4,STATA4B

COM STATA5,STATA5B

COM STATA5COMD,STATA5COMDB

COM STATA6,STATA6B

COM STATA8,STATA8B

COM STATA8MSGD,STATA8MSGDB

COM STATA8FUNS,STATA8FUNSB

COM FORCAST,FORCASTB

COM XPOS,XPOSB

COM XPOSPM,XPOSPMB

COM SMOOTH,SMOOTHB

Q
BFO
LOAD LDISP *BFL
FIN
LOAD LFINDATA *BFL
FIN
LOAD LTYMFLOW *BFL
FIN
LET HELPFILE='(*6LS)SAFINFO   '
DEB LINK
LET NAME='(*6LS)SAF   '
LET WORD=4
LET FINPAK=F
DUM STATPAK

LET FINPAK=T
DEB $
LET HELPFILE='(*6LS)SAFFINO   '
DUM FINPAK

Q
BFO
LOAD FINAN1B
LOAD ABORTEDB
LOAD FINAN1MSGDB
LOAD FINAN1FUNSB
LOAD A7
LOAD FINLIBB
LOAD LIB
LOAD *BFL
WR SAF7

Q
BFO
LOAD FINAN2B
LOAD FINAN1MSGDB
LOAD FINAN1FUNSB
LOAD A9
LOAD FINLIBB
LOAD LIB
LOAD *BFL
WR SAF9

Q
BFO
LOAD STATA1B SMALLEDIT LIB *BFL
WR SAF1

Q
BFO
LOAD STATA2B LIB *BFL
WR SAF2

Q
BFO
LOAD STATA3B LIB *BFL
WR SAF3

Q
BFO
LOAD STATA4B LIB *BFL
WR SAF4

Q
BFO
LOAD STATA5B STATA5COMDB FINLIBB LIB *BFL
WR SAF5

Q
BFO
LOAD STATA6B FINLIBB SMALLEDIT LIB *BFL
WR SAF6

Q
BFO
LOAD STATA8B
LOAD STATA8MSGDB
LOAD STATA8FUNSB
LOAD FORCASTB
LOAD X
LOAD ZADPARSE
LOAD FINLIBB
LOAD SMALLEDIT
LOAD LIB
LOAD *BFL
WR SAF8

Q
COM TEL
STATFIN ** FICHE/FRAME BREAK *****
PACK
C:PACK   02/18/72              PACK CHARACTERS.
C
C
       SUBROUTINE PACK
C
       NORMAL MODE IS INTEGER
C
       CALL PACK TEXT(-1)
       RETURN
C
C
C
       SUBROUTINE PACK STR
C
       I=NOWCHR(1)
       IF NEXTCHR(1).EQ.I, CALL ERROR(18)
       CALL PACK TEXT(I)
       RETURN
C
C
C
       LOCAL SUBROUTINE PACK TEXT(TERMINATOR)
C
       GLOBAL TEXT(1),  P TEXT,  C TEXT,  TEXT MAX
       GLOBAL SHIFT(3)
       DATA SHIFT/1K16, 1K8, 1/
C
       C TEXT=0
       P=P TEXT=P TEXT+1
       K=NOWCHR(1)
C
1      P TEXT=P TEXT+1
       IF P TEXT>TEXT MAX,  CALL ERROR(6)
       TEXT(P TEXT)=0
C
       DO 2 J=1,3
       IF K.EQ.TERMINATOR, GO TO 3
       IF K<0, CALL ERROR(19)
       TEXT(P TEXT)=TEXT(P TEXT)+K*SHIFT(J)
       C TEXT=C TEXT+1
2      K=NEXTCHR(1)
       GO TO 1
C
C
3      TEXT(P)=C TEXT
       RETURN
C
C
C
       SUBROUTINE PACK NAME
C
       GLOBAL NAME(3)
C
       I=1
       NAME(1)=NAME(2)=0
       K=NOWCHR(0)
       IF .NOT.(1RA<=K<=1RZ), CALL ERROR(20)
C
C
1      DO 2 J=1,3
       IF .NOT.(1R0<=K<=1R9 .OR. 1RA<=K<=1RZ), RETURN
       NAME(I)=NAME(I)+K*SHIFT(J)
C
2      IF ( (K=NEXTCHR(1)).EQ.1R. ),  GO TO 2
C
       IF I#3, I=I+1
       GO TO 1
C
       END
STATFIN ** FICHE/FRAME BREAK *****
PACK SYMSORT

SYM.  PG.LN. IDENT.

2       1 26 C:PACK  CM      2  3 C:PACK  CM      2  1 C:PACK  
CM      1 32 C:PACK  CM      1 31 C:PACK  CM      1 21 C:PACK  CM      1 15 C:PACK  
CM      1 12 C:PACK  CM      1  7 C:PACK  CM      1  4 C:PACK  CM      1  3 C:PACK  
CM1     1 18 C:PACK  CM2     1 39 C:PACK  CMCM    1  2 C:PACK  CMCM1   1 36 C:PACK  
CMCM3   1 28 C:PACK  CMCMCM  1 30 C:PACK  CMCMCM  1 11 C:PACK  CMCMCM  1  6 C:PACK  

STATFIN ** FICHE/FRAME BREAK *****
PARAMETRIC
       SUBROUTINE S PARAMETRIC(A,IOUT,IMEAN,ISTD,IB,F)
       GLOBAL NOOFRO,NOOFCO,STATE,SUM,SUM1,BUFFER(360)
       LOGICAL F
       INTEGER STATE
       REAL A(NOOFCO,NOOFRO)
       IF(NOOFRO.GT.360) CALL FATALE(3)
       BUFFER(1)=1.
       R=1.
       DO 100 J=1,NOOFRO-IB
       L=J+IB
       R=R*(1+RATE(J))
100    BUFFER(L)=R
       SUM=0.;SUM1=0.
       DO 200 I=1,NOOFRO
       SUM=SUM+(A(IMEAN,I)-A(IOUT,I))/BUFFER(I)
200    SUM1=SUM1+A(ISTD,I)**2/BUFFER(I)**2
       SUM1=SQRT(SUM1)
       STATE=1
       IF.NOT.F,RETURN
       DISPLAY "RETURN                  = ",SUM
       DISPLAY"[MEAN OF THE DISTRIBUTION OF NET PRESENT VALUE]"
       DISPLAY" "
       DISPLAY "RISK                    = ",SUM1
       DISPLAY "[STD.DEV. OF THE DISTRIBUTION OF NET PRESENT VALUE]"
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
PARAMETRIC SYMSORT

SYM.  PG.LN. IDENT.

100     1 12         200     1 16         
STATFIN ** FICHE/FRAME BREAK *****
PARFUNS
C:PARFUNS   06/30/72           PARSER FUNCTIONS.
C
C
       LIBRARY
C
       LOGICAL FUNCTION INT
C
C
       NORMAL MODE IS INTEGER
C
       IF INTEGER(I)<=0,  GO TO 10
C
       CALL SET CODE(4)
       CALL SET CODE(I)
C
       INT=.TRUE.
       GO TO 20
C
C
10     INT=.FALSE.
C
20     RETURN
C
C
       END
       LOGICAL FUNCTION REAL
C
C
       NORMAL MODE IS INTEGER
C
       REAL X
       INTEGER I(2)
       EQUIVALENCE (X,I)
C
C
       IF NUMBER(X)<=0,  GO TO 10
C
       CALL SET CODE(5)
       CALL SET CODE(I(1))
       CALL SET CODE(I(2))
C
       REAL=.TRUE.
       GO TO 20
C
C
10     REAL=.FALSE.
C
20     RETURN
C
C
       END
       LOGICAL FUNCTION FNAME
C
C
       NORMAL MODE IS INTEGER
C
       COMMON /CODE/MAX CODE,  P CODE,  CODE(1)
C
       REAL FILE SCAN
C
C
C MAKE ROOM FOR THE FILE NAME.
C
       CALL SET CODE(6)
       TEMP=P CODE+1
       (  CALL SET CODE(0)  ),  I=1,16
C
       IF ( (CODE(TEMP)=FILE SCAN(CODE(TEMP+1)))<=0 ),  GO TO 20
       P CODE=TEMP+(CODE(TEMP)+2)/3
       FNAME=.TRUE.
       GO TO 30
C
C
20     FNAME=.FALSE.
       P CODE=TEMP-2
C
30     RETURN
C
C
       END
       LOGICAL FUNCTION CHAR
C
C
       NORMAL MODE IS INTEGER
C
C
       I=NOWCHR(0)
C
       IF (CHAR=0<I<100B),  GO TO 10
C
       CALL SET CODE(7)
       CALL SET CODE(I)
       CALL NEXTCHR(1)
C
10     RETURN
C
C
       END
STATFIN ** FICHE/FRAME BREAK *****
PARFUNS SYMSORT

SYM.  PG.LN. IDENT.

CM      2  8 S:PARFUNCM      2  7 S:PARFUNCM      1 35 S:PARFUN
CM      1 32 S:PARFUNCM      1 30 S:PARFUNCM      1 29 S:PARFUNCM      1 22 S:PARFUN
CM      1 19 S:PARFUNCM      1 15 S:PARFUNCM      1  8 S:PARFUNCM      1  6 S:PARFUN
CM      1  5 S:PARFUNCM      1  3 S:PARFUNCM10    2 11 S:PARFUNCM20    1 25 S:PARFUN
CM20    1 11 S:PARFUNCM30    2  2 S:PARFUNCMCM    2 12 S:PARFUNCMCM    2  6 S:PARFUN
CMCM    2  5 S:PARFUNCMCM    2  3 S:PARFUNCMCM    1 28 S:PARFUNCMCM    1 26 S:PARFUN
CMCM    1 18 S:PARFUNCMCM    1 14 S:PARFUNCMCM    1 12 S:PARFUNCMCM    1  4 S:PARFUN
CMCM    1  2 S:PARFUNCMCM10  1 24 S:PARFUNCMCM10  1 10 S:PARFUNCMCM20  1 39 S:PARFUN
CMCMC   1 31 S:PARFUNL       2  4 S:PARFUNL       1 27 S:PARFUNL       1 13 S:PARFUN

STATFIN ** FICHE/FRAME BREAK *****
PARSE
C:PARSE   09/26/72             PARSE INPUT LINE.
C
C
       LOGICAL FUNCTION PARSE(NAME)
C
       NORMAL MODE IS INTEGER
C
C
       COMMON /CODE/MAX CODE, P CODE, CODE(1)
C
       LOGICAL FINPAK
       GLOBAL ZADCN,  FINPAK
C
       GLOBAL GRAPH(4)
       INTEGER NAMES(1),  TEXT(1),  FUNCTIONS(1),  NODES(2,0/1)
       EQUIVALENCE (NAMES, TEXT, FUNCTIONS, NODES, GRAPH)
C
       LOGICAL TALK,HUSH,ECHO,TTY
       COMMON /SFE/TALK,HUSH,ECHO,TTY
C
       LOGICAL FLAG,  RES POINT,  RES CODE
       GLOBAL RES CODE,  RES POINT
       INTEGER NAME(2)
C
       EXTERNAL END LINE
       LOGICAL END LINE,  STRING,  ZADCF
C
C
       LEVEL=0
       RES CODE=RES POINT=.TRUE.
       P STACK=MAX CODE+1
C
       NAME BEG=GRAPH(1)+1
       NAME END=NAME BEG+3*GRAPH(NAME BEG-1)
C
       DO 10 I=NAME BEG, NAME END, 3
10     IF NAMES(I).EQ.NAME(1) .AND. NAMES(I+1).EQ.NAME(2),  GO TO 20
       CALL ERROR(1)
C
C
20     TERM=IAND(RSH(NAMES(I+2),18),7)
       NODE=IAND(NAMES(I+2),7777B)
       P CODE=0
C
30     P1 CODE=P2 CODE=0
C
C
40     CALL GET NODE
       P2 CODE=P1 CODE
       P1 CODE=P CODE
C
C
45     GO TO (100,200,300,400,410,500,510,600,700,710,800,900,1000)
+              VALUE, 1100
C
C
50     P CODE=P1 CODE
       P1 CODE=P2 CODE
       P2 CODE=0
55     NODE=ALT
       GO TO 61
C
C
60     CALL DO RULE
       NODE=SUC
61     IF NODE>0, GO TO 40
C
65     IF LEVEL>0, GO TO 90
       IF .NOT.(PARSE=NODE),  GO TO 80
       CALL SET CODE(0)
       P CODE=P CODE-1
C
C GRAPH TERMINATION CHECK.
C
       I=NOWCHR(1)
       GO TO (70, 71, 72, 74)  TERM, 80
C
C NON-ALPANUMERIC.
70     IF 1RA<=I<=1RZ .OR. 1R0<=I<=1R9,  GO TO 73
       GO TO 80
C
C COMMA, BLANK, OR RETURN.
71     IF I.EQ.1R,,  GO TO 80
C
C BLANK OR RETURN.
72     IF I.EQ.0,   GO TO 80
73     IF LASTCHR(1).EQ.0,  GO TO 80
C
C RETURN.
74     IF I<0,  GO TO 80
C
75     CALL OUTPUT(1,'$UNRECOGNIZED CHARACTERS AT END OF LINE.$/')
       CALL SFE CLEAR
       PARSE=.FALSE.
C
80     RETURN
C
90     FLAG=NODE<0
       IF FLAG,  CALL UNSTACK;  GO TO 60
       IF .NOT.RES CODE,  CALL UNSTACK;  GO TO 55
       IF .NOT.RES POINT,  GO TO 95
       CALL SET POINT(INDEX)
95     CALL UNSTACK
       GO TO 50
C
C
C      CHECK FOR COMMAND MATCH.
C
100    LIST NO=RSH(DEFINITION,8)
       COM NO=IAND(DEFINITION,377B)
C
       WORD=KOMMAND(LIST NO)
       IF ZADCN<COM NO .OR. WORD<1,  GO TO 130
       IF .NOT.FINPAK .AND. 23<=WORD<50,  GO TO 130
C
       TIMES 110, ZADCN-COM NO
       NODE=ALT
110    CALL GET NODE
C
C
120    CALL SET CODE(VALUE)
       CALL SET CODE(WORD)
       GO TO 60
C
C
130    IF ALT<=0, GO TO 50
       NODE=ALT
       CALL GET NODE
       IF VALUE.EQ.1, GO TO 130
       GO TO 45
C
C
C      CHECK FOR CHARACTER MATCH.
C
200    WORD=NOWCHR(0)
       IF WORD#DEFINITION, GO TO 50
       CALL NEXTCHR(1)
       GO TO 120
C
C
C      CHECK FOR STRING MATCH.
C
300    CALL NOWCHR(0)
       IF .NOT.STRING(TEXT(DEFINITION)), GO TO 50
C
C DON'T MOVE THE TEXT IF WE'RE GOING TO THROW IT AWAY.
       IF RULE.EQ.2, GO TO 60
C
       CALL SET CODE(VALUE)
       (CALL SET CODE(TEXT(DEFINITION+I))), I=0,(TEXT(DEFINITION)+2)/3
       GO TO 60
C
C
C      FUNCTION CALL.
C
400    GO TO 420
410    RES CODE=.FALSE.
420    IF ZADCF(FUNCTIONS(DEFINITION)),  RES CODE=.TRUE.;  GO TO 60
       IF .NOT.RES CODE,  RES CODE=.TRUE.;  GO TO 55
       GO TO 50
C
C
C      DEFINITION CALL.  MUST RECURSE.
C
500    GO TO 600
510    RES CODE=.FALSE.
600    CALL STACK
       NODE=DEFINITION
       GO TO 30
C
C
C      PROMPT NODE.
C
700    IF .NOT.END LINE,  GO TO 50
       FLAG=.FALSE.
       GO TO 720
710    FLAG=.TRUE.
720    IF TALK, CALL DISSTR(TEXT(DEFINITION+1),TEXT(DEFINITION))
       RES POINT=.TRUE.
       IF .NOT.GET LINE(I),  GO TO 730
       IF FLAG,  IF I<=0,  GO TO 50
       GO TO 60
C
730    TALK=.TRUE.
       HUSH=.FALSE.
       GO TO 700
C
C
C      ERROR NODE.
C
800    CALL OUTSTR(1,TEXT(DEFINITION+1),TEXT(DEFINITION))
       CALL SFE CLEAR
       CALL SET POINT(257)
       RES POINT=.FALSE.
       GO TO 60
C
C
C      OUTPUT NODE.
C
900    CALL SET CODE(DEFINITION)
       GO TO 60
C
C
C      CALL NODE.
C
1000   CALL CALL(DEFINITION)
       GO TO 60
C
C
C      SIGMA NODE.
C
1100   IF LEVEL>0,  CALL UNSTACK;  GO TO 60
       PARSE=.TRUE.
       GO TO 80
       LOCAL SUBROUTINE STACK
C
C
       P STACK=P STACK-2
       IF P STACK<=P CODE,  CALL ERROR(3)
C
       CALL GET POINT(INDEX)
C
       CODE(P STACK)=IOR(IAND(RES CODE, 4B7), LSH(P1 CODE, 10), P2 CODE)
       CODE(P STACK+1)=IOR(LSH(NODE, 12), INDEX)
C
       LEVEL=LEVEL+1
C
       RETURN
       LOCAL SUBROUTINE UNSTACK
C
C
       LEVEL=LEVEL-1
C
       RES CODE=CODE(P STACK)
       P1 CODE=IAND(LRSH(CODE(P STACK), 10), 1777B)
       P2 CODE=IAND(CODE(P STACK),1777B)
       NODE=LRSH(CODE(P STACK+1), 12)
       INDEX=IAND(CODE(P STACK+1), 7777B)
C
       P STACK=P STACK+2
C
       CALL GET NODE
C
       RETURN
       SUBROUTINE SET CODE(VAL)
C
C
       P CODE=P CODE+1
       IF P CODE>=P STACK,  CALL ERROR(3)
C
       CODE(P CODE)=VAL
       RETURN
       LOCAL SUBROUTINE GET NODE
C
C
       I=NODES(1,NODE)
       VALUE=LRSH(I,20)
       RULE=IAND(RSH(I,16),17B)
       DEFINITION=IAND(I,177777B)
       I=NODES(2,NODE)
       ALT=RSH(I,12)
       SUC=IAND(I,7777B)
       IF SUC.EQ.4B3, SUC=4B7
       RETURN
       LOCAL SUBROUTINE DO RULE
C
C
       GO TO (200, 100) RULE, 110
C
100    P CODE=P1 CODE
       P1 CODE=P2 CODE
       P2 CODE=0
C
110    RETURN
C
C
200    IF P2 CODE.EQ.0,  GO TO 110
       IF P CODE+P1 CODE-P2 CODE>=P STACK,  CALL ERROR(3)
C
       J=P CODE-P1 CODE+P2 CODE
       DO 210 I=P CODE-P2 CODE, 1, -1
210    CODE(I+J)=CODE(P2 CODE+I)
C
       DO 220 I=1, P CODE-P1 CODE
220    CODE(P2 CODE+I)=CODE(P CODE+I)
C
       P1 CODE=P2 CODE+P CODE-P1 CODE
       GO TO 110
       LOCAL SUBROUTINE ERROR(ERR NO)
C
C
       INTEGER MESSAGE(5)
       DATA MESSAGE/'$PARSE ERROR   '/
C
C
       MESSAGE(5)=2H #+ERR NO+20B
       CALL OUTSTR(1,MESSAGE,15)
       PAUSE
C
C
       END
       SUBROUTINE CALL(I)
C
C
       NORMAL MODE IS INTEGER
C
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
PARSE SYMSORT

SYM.  PG.LN. IDENT.

+       1 33 C:PARSE 10      1 23 C:PARSE 110     2 39 C:PARSE 210     5 28 C:PARSE 
220     5 30 C:PARSE 410     3 24 C:PARSE 420     3 25 C:PARSE 510     3 30 C:PARSE 
55      1 37 C:PARSE 600     3 31 C:PARSE 61      2  2 C:PARSE 70      2 11 C:PARSE 
71      2 14 C:PARSE 710     3 38 C:PARSE 72      2 16 C:PARSE 720     3 39 C:PARSE 
73      2 17 C:PARSE 74      2 19 C:PARSE 95      2 29 C:PARSE 
CM      6  3 C:PARSE CM      5 31 C:PARSE CM      5 29 C:PARSE CM      5 26 C:PARSE 
CM      5  6 C:PARSE CM      5  2 C:PARSE CM      5  1 C:PARSE CM      4 39 C:PARSE 
CM      4 34 C:PARSE CM      4 31 C:PARSE CM      4 30 C:PARSE CM      4 28 C:PARSE 
CM      4 27 C:PARSE CM      3 19 C:PARSE CM      2 37 C:PARSE CM      2 34 C:PARSE 
CM      2  8 C:PARSE CM      1 22 C:PARSE CM      1 20 C:PARSE CM      1 15 C:PARSE 
CM      1 12 C:PARSE CM      1 10 C:PARSE CM      1  7 C:PARSE CM      1  5 C:PARSE 
CM      1  3 C:PARSE CM100   5 20 C:PARSE CM100   2 32 C:PARSE CM1000  4 18 C:PARSE 
CM110   5 23 C:PARSE CM1100  4 21 C:PARSE CM200   3 10 C:PARSE CM30    1 28 C:PARSE 
CM300   3 15 C:PARSE CM400   3 23 C:PARSE CM500   3 29 C:PARSE CM65    2  3 C:PARSE 
CM700   3 35 C:PARSE CM730   4  5 C:PARSE CM75    2 20 C:PARSE CM80    2 23 C:PARSE 
CM800   4  9 C:PARSE CM90    2 24 C:PARSE CM900   4 15 C:PARSE CMC     3 17 C:PARSE 
CMC     2 18 C:PARSE CMC     2 15 C:PARSE CMC     2 13 C:PARSE CMC     2 10 C:PARSE 
CMC     2  7 C:PARSE CMCM    6  2 C:PARSE CMCM    5 39 C:PARSE CMCM    5 36 C:PARSE 
CMCM    5 34 C:PARSE CMCM    5 19 C:PARSE CMCM    5  9 C:PARSE CMCM    5  4 C:PARSE 
CMCM    4 33 C:PARSE CMCM    4 25 C:PARSE CMCM    1 17 C:PARSE CMCM    1  4 C:PARSE 
CMCM    1  2 C:PARSE CMCM12  3  1 C:PARSE CMCM13  3  4 C:PARSE CMCM20  5 24 C:PARSE 
CMCM20  1 25 C:PARSE CMCM40  1 29 C:PARSE CMCM45  1 32 C:PARSE CMCM50  1 34 C:PARSE 
CMCM60  1 39 C:PARSE CMCMC   4 20 C:PARSE CMCMC   4 17 C:PARSE CMCMC   4 14 C:PARSE 
CMCMC   4  8 C:PARSE CMCMC   3 34 C:PARSE CMCMC   3 28 C:PARSE CMCMC   3 22 C:PARSE 
CMCMC   3 14 C:PARSE CMCMC   3  9 C:PARSE CMCMC   2 31 C:PARSE L       6  1 C:PARSE 
L       5 33 C:PARSE L       5 18 C:PARSE L       5  8 C:PARSE L       5  3 C:PARSE 
L       4 32 C:PARSE L       4 24 C:PARSE 
STATFIN ** FICHE/FRAME BREAK *****
PAYBACK
       SUBROUTINE PAYBACK(A,I,J,T,F)
       LOGICAL F
       GLOBAL NOOFCO,NOOFRO,SUM,TAXFREQ,STATE,BUFFER(360)
       INTEGER STATE,TAXFREQ
       REAL A(NOOFCO,NOOFRO)
       IF(NOOFRO.GT.360) CALL FATALE(3)
       DO 5 L=1,NOOFRO
       TEMP=0.
       IF(T.GT.0.) TEMP=A(J,L)
5      BUFFER(L)=A(I,L)-TEMP
       IF(T.LE.0.) GO TO 25
       CALL TAXCOM(T)
       DO 20 L=1,NOOFRO
20     BUFFER(L)=BUFFER(L)+A(J,L)
25     SUM1=0.
       SUM2=0.
       DO 50 L=1,NOOFRO
50     SUM1=SUM1+A(J,L)
       DO 100 L=1,NOOFRO
       SUM2=SUM2+BUFFER(L)
       IF(SUM2.GE.SUM1) GO TO 150
100    CONTINUE
       SUM=1.E+75
       GO TO 160
150    SUM=L
160    IF(.NOT.F) STATE=1;RETURN
       DISPLAY"PAYBACK PERIOD = ",SUM
       STATE=1
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
PAYBACK SYMSORT

SYM.  PG.LN. IDENT.

100     1 22         150     1 25         160     1 26         20      1 14         
25      1 15         5       1 10         50      1 18         

STATFIN ** FICHE/FRAME BREAK *****
PVAL
C:PVAL   06/09/72
       SUBROUTINE PVAL(A,N,T,CF,F)
       LOGICAL CF,GETBEG,F
       GLOBAL NOOFCO,NOOFRO,SUM,TAXFREQ,BUFFER(360),STATE
       INTEGER TAXFREQ,STATE
       REAL A(NOOFCO,NOOFRO)
       IF(NOOFRO.GT.360)CALL FATALE(3)
       SUM=0.
       DO 10 I=1,NOOFRO
10     BUFFER(I)=A(N,I)
       IF(T.GT.0.) CALL TAXCOM(T)
       IF(GETBEG(N)) GO TO 100
       IF(CF) GO TO 50
       DO 20 I=1,NOOFROWS
20     SUM=(SUM+BUFFER(NOOFRO-I+1))/(1+RATE(NOOFRO-I+1))
       GO TO 1000
50     DO 30 I=1,NOOFROWS
30     SUM=(SUM+BUFFER(NOOFRO-I+1))/EXP(RATE(NOOFRO-I+1))
       GO TO 1000
100    IF(CF) GO TO 60
       DO 40 I=0,NOOFROWS-1
40     SUM=(SUM+BUFFER(NOOFRO-I))/(1+RATE(NOOFRO-I-1))
       GO TO 1000
60     DO 70 I=0,NOOFROWS-1
70     SUM=(SUM+BUFFER(NOOFRO-I))/EXP(RATE(NOOFRO-I-1))
1000   IF(.NOT.F) RETURN
       DISPLAY "PRESENT VALUE = ",SUM
       STATE=1
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
PVAL SYMSORT

SYM.  PG.LN. IDENT.

10      1 10 C:PVAL  100     1 20 C:PVAL  1000    1 26 C:PVAL  20      1 15 C:PVAL  
30      1 18 C:PVAL  40      1 22 C:PVAL  50      1 17 C:PVAL  60      1 24 C:PVAL  
70      1 25 C:PVAL  
STATFIN ** FICHE/FRAME BREAK *****
RANAL
       SUBROUTINE RANAL(A,IJ,J,K,L,M,IC,IM,IB)
       GLOBAL NOOFRO,NOOFCO,STATE,SUM,SUM1,SUM2,BUFFER(360)
       INTEGER STATE
       REAL A(NOOFCO,NOOFRO)
       DIMENSION EXP(360),RISKF(360)
       IF(NOOFRO.GT.360) CALL FATALE(3)
       DO 100 I=1,NOOFRO
       C1=A(IJ,I);C2=A(J,I);C3=A(K,I)
       EXP(I)=(C1+C2+C3)/3.
       VARIANCE=(C1^2+C2^2+C3^2-C1*C2-C2*C3-C3*C1)/18.
       IF(L.EQ.0) GO TO 50
       C4=A(L,I);GO TO 55
50     C1=-C3;C2=-C2;C3=-A(IJ,I);C4=-A(M,I)
55     C5=(C3-C1)*(C2-C1)*6.;RISK=0.
       IF(C4  .GT.C2)GO TO 60
       IF(C4  .LE.C1)GO TO 95
       RISK=((C1-C4)^4)/C5;GO TO 95
60     C6=(C3-C1)*(C3-C2)*6.;INDEX=0;TEMP1=C1
65     TEMP2=3.*C2^4-(8.*C4+4.*TEMP1)*C2^3+(6.*C4^2+12.*C4*TEMP1)*
     +C2^2-12.*TEMP1*C4^2*C2
       TEMP3=TEMP1^4-4.*C4*TEMP1^3+6.*(TEMP1*C4)^2
       IF(INDEX.NE.0) GO TO 80
       TEMP1=C3;INDEX=1
       IF(C5.LE.0.) GO TO 65
       RISK=(TEMP2+TEMP3)/C5
       IF(C6.LE.0.)GO TO 95.ELSE.GO TO 65
80     IF(C6.LE.0.) GO TO 95
       IF(C4.LT.C3)GO TO 90
       RISK=(TEMP2+TEMP3)/C6+RISK;GO TO 95
90     RISK=(4.*C4^3*C3-C4^4+TEMP2)/C6+RISK
95     RISKF(I)=RISK
100    CONTINUE
       BUFFER(1)=1.
       R=1.
       DO 125 IL=1,(NOOFRO-IB)
       J=IL+IB
       R=R*(1.+RATE(IL))
125    BUFFER(J)=R
       SUM=0.
       SUM1=0.
       SUM2=0.
       DO 250 I=1,NOOFRO
       SUM=SUM+EXP(I)/BUFFER(I)
       IF(L.EQ.0) GO TO 200
       SUM2=SUM2+A(IJ,I)/BUFFER(I)
       GO TO 250
200    SUM2=SUM2+A(K,I)/BUFFER(I)
250    CONTINUE
       DO 800 II=1,NOOFRO
       DO 800 J=II,NOOFRO
       CORRE=0.
       IF(IC.EQ.0) GO TO 750
       IF(II.EQ.J)CORRE=.5;GO TO 800
       IF(II.EQ.(J+1).OR.(II+1).EQ.J) CORRE=A(IC,MIN(II,J));GO TO 800
       IF(IM.EQ.0) GO TO 800
       IND1=MIN(II,J);IND2=MAX(II,J)
       CORRE=1.
       DO 745 ITEMP=IND1,(IND2-1)
745    CORRE=CORRE*A(IC,ITEMP)
       GO TO 800
750    IF(II.EQ.J) CORRE=.5
800    SUM1=SUM1+CORRE*2.*SQRT(RISKF(II)*RISKF(J))/(BUFFER(II)*BUFFER(J))
       STATE=1
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
RANAL SYMSORT

SYM.  PG.LN. IDENT.

100     1 32         125     1 38         200     2  8         250     2  9         
50      1 13         55      1 14         60      1 18         65      1 19         
745     2 20         750     2 22         80      1 27         800     2 23         
90      1 30         95      1 31         
STATFIN ** FICHE/FRAME BREAK *****
READOP
C:READOP   02/11/72            READ OPTIONS.
C
C
       SUBROUTINE READ OPTIONS(OLD OPTIONS)
C
       INTEGER OLD OPTIONS(3),NEW OPTIONS(3),MIN OPTION,TERM OPTION
       LOGICAL PRI OPTION
       LOGICAL FND OPTION(3),FND MINIMUM,FND TERMINATION,FND PRIORITY

       EQUIVALENCE (MIN OPTION,NEW OPTION(1))
+                 ,(TERM OPTION,NEW OPTION(2))
+                 ,(PRI OPTION,NEW OPTION(3))
+                 ,(FND MINIMUM,FND OPTION(1))
+                 ,(FND TERMINATION,FND OPTION(2))
+                 ,(FND PRIORITY,FND OPTION(3))


       EXTERNAL GET INTEGER
       INTEGER GET INTEGER

       FND MININUM=FND TERMINATION=FND PRIORITY=.FALSE.

5      GO TO (100,10,20,30,40,50),KOMMAND(2)+1,200
C
C TERMINATION.
C
10     IF FND TERMINATION, CALL ERROR(13)
       TERM OPTION=KOMMAND(3)-1
       IF(TERM OPTION+1) 12,18,16
12     TERM OPTION=GET INTEGER
       IF TERM OPTION>7, CALL ERROR(5)
16     FND TERM=.TRUE.
       GO TO 90
18     CALL ERROR(12)
C
C MINIMUM.
C
20     IF FND MINIMUM, CALL ERROR(14)
       MIN OPTION=GET INTEGER
       IF MIN OPTION>37K, CALL ERROR(6)
       FND MINIMUM=.TRUE.
       GO TO 90
C
C EXACT.
C
30     IF FND MINIMUM, CALL ERROR(14)
       MIN OPTION=-1; FND MINIMUM=.TRUE.
       GO TO 90
C
C PRIORITY.
C
40     IF FND PRIORITY, CALL ERROR(15)
       PRI OPTION=FND PRIORITY=.TRUE.
       GO TO 90
C
C NON-PRIORITY.
C
50     IF FND PRIORITY, CALL ERROR(15)
       PRI OPTION=.FALSE.; FND PRIORITY=.TRUE.
       GO TO 90
C
C ALLOW EITHER SPACE OR COMMA BETWEEN OPTIONS.
C
90     IF KOMMA(0).NE.0, GO TO 5

100    DO 110,I=1,3
110    IF FND OPTION(I), OLD OPTION(I)=NEW OPTION(I)
       RETURN
C
C ILLEGAL OPTION
C
200    CALL ERROR(16)
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
READOP SYMSORT

SYM.  PG.LN. IDENT.

+       1 12 C:READOP+       1 11 C:READOP+       1 10 C:READOP+       1  9 C:READOP
+       1  8 C:READOP100     2 12 C:READOP110     2 13 C:READOP12      1 25 C:READOP
16      1 27 C:READOP18      1 29 C:READOP5       1 20 C:READOP
CM      1  3 C:READOPCM10    1 22 C:READOPCM20    1 31 C:READOPCM200   2 16 C:READOP
CM30    1 37 C:READOPCM40    2  2 C:READOPCM50    2  6 C:READOPCM90    2 10 C:READOP
CMC     2 15 C:READOPCMC     2  9 C:READOPCMC     2  5 C:READOPCMC     2  1 C:READOP
CMC     1 36 C:READOPCMC     1 30 C:READOPCMC     1 21 C:READOPCMCM    1  2 C:READOP

STATFIN ** FICHE/FRAME BREAK *****
READSTR
C:READSTR   08/07/72           READ STRUCTURE FILE.
C
C
       LOCAL LOGICAL FUNCTION READ LINE
C
C
       NORMAL MODE IS INTEGER
C
C
       COMMON /CODE/MAX CODE, N CODE, CODE(1)
C
       LOGICAL NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC
       GLOBAL IN FLOW,  OUT FLOW
       GLOBAL NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC
       GLOBAL NO OF CASES
C
       INTEGER IN NAME(2),  OUT NAME(2)
C
       INTEGER FILE STRUCTURE(2)
       DATA FILE STRUCTURE/'FILESTRUCTURE'/
C
       LOGICAL PARSE
C
C
1      CALL READ FILE(N,3)
       IF N<0,  GO TO 200
       LINE NO=LINE NO+1
C
       IF .NOT.PARSE(FILE STRUCTURE),  GO TO 300
C
       IF CODE(1)-2,  5, 1, 1$
C
5      GO TO (10, 20, 30, 40, 50, 55, 1, 60, 70)  CODE(2),  80
C
C
10     PROBABILISTIC=.TRUE.
       IF 0<(NO OF CASES=CODE(4))<100,  GO TO 100
       CALL ERROR(6)
       GO TO 5$
C
C
20     MULTIPLE=.TRUE.
       GO TO 100
C
C
30     PARAMETRIC=.TRUE.
       GO TO 100
C
C
40     TRIANGULAR=.TRUE.
       GO TO 100
C
C
50     SPECIAL=.TRUE.
       GO TO 100
C
C
55     SYMMETRIC=.TRUE.
       GO TO 100
C
C
60     CALL SET BEGIN(NO OF COLUMNS+1)
       GO TO 1
C
C
70     IN NAME(1)=CODE(4)
       IN NAME(2)=CODE(5)
       GO TO 1
C
C
80     OUT NAME(1)=CODE(4)
       OUT NAME(2)=CODE(5)
       GO TO 1
C
C
100    NORMAL=.FALSE.
       GO TO 1
C
C
200    READ LINE=.FALSE.
       GO TO 400
C
C
300    READ LINE=.TRUE.
C
400    RETURN
       SUBROUTINE READ STRUCTURE(ERR LABEL)
C
C
       GLOBAL TITLE
       GLOBAL P COLUMNS,  NO OF COLUMNS,  NO OF ROWS,  NO OF CASES
C
       GLOBAL NAME(2)
C
       INTEGER INTINT(2)
       DATA INTINT/'INTINT'/
C
       LOGICAL ADD COLUMN,  ADD ROW,  PACK NAME,  PACK ROW
       LOGICAL END LINE,  FIND COLUMN
       EXTERNAL PACK NAME,  ADD ROW,  PACK ROW,  END LINE
C
C
       CALL INIT MATRIX
       NORMAL=.TRUE.
       IN NAME(1)=OUT NAME(1)=LINE NO=0
C
C GET THE NUMBER OF COLUMNS AND ROWS.
C
       IF .NOT.READ LINE,  GO TO 3$
C
       IF .NOT.PARSE(INTINT),  GO TO 1$
       NROWS=CODE(2)
       NCOLS=CODE(4)
C
C NOW GET THE ROW NAMES.
C
       TIMES 10, NROWS
       IF .NOT.READ LINE,  GO TO 3$
       IF .NOT.PACK ROW,  GO TO 1$
       IF .NOT.END LINE,  GO TO 1$
10     IF .NOT.ADD ROW(5$),  GO TO 1$
C
C NOW THE COLUMNS.
C
       TIMES 20, NCOLS
       IF .NOT.READ LINE,  GO TO 3$
       IF .NOT.PACK NAME,  GO TO 1$
       IF .NOT.END LINE,  GO TO 1$
20     IF .NOT.ADD COLUMN(NAME(1),5$),  GO TO 1$
C
C CHECK FOR CONSISTENCY.
C
       IF SPECIAL.AND.(PROBABILISTIC.OR.PARAMETRIC.OR.MULTIPLE.OR.
+              TRIANGULAR),  GO TO 2$
       IF TRIANGULAR.AND.(PROBABILISTIC.OR.PARAMETRIC.OR.MULTIPLE),
+              GO TO 2$
       IF PROBABILISTIC.AND.PARAMETRIC,  GO TO 2$
C
       IF NO OF COLUMNS<0 .OR. NO OF ROWS<0,  GO TO 2$
C
       IF IN NAME(1).EQ.0,  GO TO 30
       IF .NOT.FIND COLUMN(IN NAME),  GO TO 2$
       IN FLOW=P COLUMNS
C
30     IF OUT NAME(1).EQ.0,  GO TO 40
       IF .NOT.FIND COLUMN(OUT NAME),  GO TO 2$
       OUT FLOW=P COLUMNS
C
40     IF TITLE.EQ.0,  CALL ERROR(11);  GO TO 5$
C
C CHECK FOR MATRIX TOO BIG.
C
       IF NO OF COLUMNS*NO OF ROWS>2048,  CALL ERROR(12);  GO TO 5$
C
C CHECK FOR END OF FILE.
C
       IF READ LINE,  GO TO 1$
C
50     RETURN
C
1$     CALL OUTMSG(1,1,1)
       CALL OUTNUM(1,LINE NO)
       CALL OUTMSG(1,1,2)
       GO TO 4$
2$     CALL OUTCHR(1,155B)
4$     CALL ERROR(7)
       GO TO 5$
C
C
3$     CALL ERROR(17)
C
5$     GO TO ERR LABEL
C
C
       END
STATFIN ** FICHE/FRAME BREAK *****
READSTR SYMSORT

SYM.  PG.LN. IDENT.

+       3  4 S:READST+       3  2 S:READST+       1  9 S:READST+       1  6 S:READST
10      2 32 S:READST2$      3 23 S:READST20      2 38 S:READST4$      3 24 S:READST
CM      3 17 S:READSTCM      3 15 S:READSTCM      3  7 S:READST
CM      3  6 S:READSTCM      3  1 S:READSTCM      2 34 S:READSTCM      2 28 S:READST
CM      2 24 S:READSTCM      2 23 S:READSTCM      2 16 S:READSTCM      2 14 S:READST
CM      2 13 S:READSTCM      1 19 S:READSTCM      1 18 S:READSTCM      1 14 S:READST
CM      1 12 S:READSTCM      1 11 S:READSTCM      1  5 S:READSTCM1$    3 19 S:READST
CM30    3 10 S:READSTCM40    3 13 S:READSTCM400   2  9 S:READSTCM5     1 20 S:READST
CM5$    3 27 S:READSTCM50    3 18 S:READSTCMC     3 16 S:READSTCMC     3 14 S:READST
CMC     2 39 S:READSTCMC     2 33 S:READSTCMC     2 27 S:READSTCMC     2 22 S:READST
CMCM    3 28 S:READSTCMCM    2 19 S:READSTCMCM    2 11 S:READSTCMCM    1  4 S:READST
CMCM    1  3 S:READSTCMCM    1  2 S:READSTCMCM1   1 15 S:READSTCMCM10  2  4 S:READST
CMCM10  1 21 S:READSTCMCM20  2  6 S:READSTCMCM20  1 25 S:READSTCMCM3$  3 26 S:READST
CMCM30  2  8 S:READSTCMCM30  1 27 S:READSTCMCM40  1 29 S:READSTCMCM50  1 31 S:READST
CMCM55  1 33 S:READSTCMCM60  1 35 S:READSTCMCM70  1 37 S:READSTCMCM80  2  1 S:READST
L       2 10 S:READST
STATFIN ** FICHE/FRAME BREAK *****
REPLACE
C:REPLACE   06/17/72           REPLACE COLUMN WITH EXPRESSION.
C
C
       INTEGER FUNCTION REPLACE(COL,E, ERR LABEL)
C
C
       NORMAL MODE IS INTEGER
C
       REAL MATRIX
C
       GLOBAL NO OF COLUMNS,  NO OF ROWS,  NUM INS,  INIT INS
       GLOBAL MATRIX(1)
C
       INTEGER E(1),  FUN STACK(10)
       REAL X,  Y,  STACK(10)
C
       REAL MKREAL
C
C
       CONNECT OVERFLOW,  CALL LOCAL;  IF ERR NO<19,  GO TO 209
+              .ELSE.  GO TO 2
C
C
       DO 170 ROW=0, NO OF ROWS-1
C
       LEVEL=0
       INDEX=1
C
1      X=0
       FUN=-1
C
2      INDEX=INDEX+1
       GO TO (50,3,3,3,90,3,3,3,3,3,3,3,170,180,190,200)
+              E(INDEX-1)-4,  3
C
3      CALL ERROR(14)
       GO TO ERR LABEL
C
C
50     Y=MKREAL(E(INDEX))
       GO TO 1000
C
C
90     Y=MATRIX(E(INDEX)-(E(INDEX)>=INIT INS)*NUM INS+NO OF COLUMNS*ROW)
       GO TO 2000
C
C
170    MATRIX(COL+NO OF COLUMNS*ROW)=X
       REPLACE=INDEX
       DISCONNECT OVERFLOW
       RETURN
C
C
180    LEVEL=LEVEL+1
       STACK(LEVEL)=X
       FUN STACK(LEVEL)=FUN
       GO TO 1
C
C
190    Y=X
       X=STACK(LEVEL)
       FUN=FUN STACK(LEVEL)
       LEVEL=LEVEL-1
       IF FUN>0,  GO TO 201
       GO TO 3000
C
C
200    FUN=E(INDEX+1)
       INDEX=INDEX+2
       GO TO 2
C
201    ERR NO=FUN+14
       GO TO (202, 203, 204, 205, 206) FUN,  207
C
202    IF Y<0,  GO TO 210
       Y=SQRT(Y)
       GO TO 209
C
203    IF Y<=0,  GO TO 210
       Y=LOG10(Y)
       GO TO 209
C
204    IF Y<=0,  GO TO 210
       Y=LOG(Y)
       GO TO 209
C
205    Y=EXP(Y)
       GO TO 209
C
206    Y=SIN(Y)
       GO TO 209
C
207    Y=COS(Y)
       GO TO 209
C
209    FUN=-1
       GO TO 3000
C
210    X=Y/0
C
C
1000   INDEX=INDEX+1
2000   INDEX=INDEX+1
3000   INDEX=INDEX+2
C
       ERR NO=E(INDEX-1)+18
       GO TO (3100, 3200,  3250, 3300) E(INDEX-1),  3400
C
3100   X=X+Y
       GO TO 2
C
3200   X=X-Y
       GO TO 2
C
3250   IF Y#INT(Y),  GO TO 3260
       IF X.EQ.0,  GO TO 3270
       X=X^INT(Y)
       GO TO 2
3260   IF X<0,  ERR NO=24;  GO TO 210
       GO TO 3280
3270   IF Y<=0,  ERR NO=25;  GO TO 210
3280   X=X^Y
       GO TO 2
C
3300   X=X*Y
       GO TO 2
C
3400   X=X/Y
       GO TO 2
       LOCAL SUBROUTINE LOCAL
C
C
       LOGICAL ERR FLAG,  SPECIAL,  MULTIPLE
       GLOBAL ERR FLAG,  SPECIAL,  MULTIPLE
       GLOBAL NAME(2),  COLUMNS(2,1),  ROWS(2,-2:-1)
C
C
       CALL ERROR(ERR NO)
       CALL DISMSG(3,1)
       CALL DISSYM(COLUMNS(1,COL))
       CALL DISMSG(3,2)
C
       IF SPECIAL,  GO TO 10
       IF MULTIPLE,  CALL GET FLOW(I,J,ROW+1)  .ELSE.  I=ROW+1; J=0
       CALL MAKE RN(I,J)
       GO TO 20
C
10     NAME(1)=ROWS(1,-ROW)
       NAME(2)=ROWS(2,-ROW)
C
20     CALL DISSYM(NAME)
       CALL DISMSG(3,3)
C
       ERR FLAG=.TRUE.
C
       RETURN
C
C
       END
STATFIN ** FICHE/FRAME BREAK *****
REPLACE SYMSORT

SYM.  PG.LN. IDENT.

+       1 19 G:REPLAC+       1 11 G:REPLAC2000    2 25 G:REPLAC3000    2 26 G:REPLAC
3260    2 37 G:REPLAC3270    2 39 G:REPLAC3280    3  1 G:REPLAC
CM      3 24 G:REPLACCM      3 23 G:REPLACCM      3 15 G:REPLACCM      2 27 G:REPLAC
CM      1 13 G:REPLACCM      1  9 G:REPLACCM      1  7 G:REPLACCM      1  5 G:REPLAC
CM      1  4 G:REPLACCM1     1 15 G:REPLACCM10    3 19 G:REPLACCM2     1 17 G:REPLAC
CM20    3 21 G:REPLACCM201   2  4 G:REPLACCM202   2  6 G:REPLACCM203   2  9 G:REPLAC
CM204   2 12 G:REPLACCM205   2 15 G:REPLACCM206   2 17 G:REPLACCM207   2 19 G:REPLAC
CM209   2 21 G:REPLACCM210   2 23 G:REPLACCM3     1 20 G:REPLACCM3100  2 29 G:REPLAC
CM3200  2 31 G:REPLACCM3250  2 33 G:REPLACCM3300  3  3 G:REPLACCM3400  3  5 G:REPLAC
CMCM    3 25 G:REPLACCMCM    3 11 G:REPLACCMCM    3  8 G:REPLACCMCM    1 12 G:REPLAC
CMCM    1 10 G:REPLACCMCM    1  3 G:REPLACCMCM    1  2 G:REPLACCMCM10  2 24 G:REPLAC
CMCM17  1 26 G:REPLACCMCM18  1 30 G:REPLACCMCM19  1 34 G:REPLACCMCM20  2  1 G:REPLAC
CMCM50  1 22 G:REPLACCMCM90  1 24 G:REPLACL       3  7 G:REPLAC
STATFIN ** FICHE/FRAME BREAK *****
SERIAL
       SUBROUTINE SERIAL(A,P,N,I1,I2,I3,F)
       LOGICAL F,INP OK,MULTIPLE
       GLOBAL NOOFCO,NOOFRO,STATE,MULTIPLE,ROWS(2,-2:-1),NOOFPE
       INTEGER STATE,ROWS,NOOFPE
       REAL A(NOOFCO,NOOFRO)
       I=0
       IF(F) GO TO 10
       PINT=P*RATE(1)
       GO TO 15
10     PINT=0.
       I=1
15     IF(I1.EQ.0.AND.I2.EQ.0.AND.I3.EQ.0) GO TO 23
       DO 22 L=1,NOOFRO
       IF(I1.NE.0) A(I1,L)=0.
       IF(I2.NE.0) A(I2,L)=0.
22     IF(I3.NE.0) A(I3,L)=0.
23     PRPAY=P/N
       PBAL=P-PRPAY
       IF(I1.NE.0) A(I1,1)=INT(PRPAY*100.+.5)/100.
       IF(I2.NE.0) A(I2,1)=INT(PINT*100.+.5)/100.
       IF(I3.NE.0) A(I3,1)=INT(PBAL*100.+.5)/100.
       ITEMC=1
       ISMALL=N
       IF.NOT.MULTIPLE,NOOFPE=NOOFRO
       IF(N.GT.NOOFPE)ISMALL=NOOFPE
       DO 20 J=2,ISMALL
       K=ITEMC
       IF(MULTIPLE),ITEMC=ITEMC+ROWS(2,-(J-1));GO TO 16
       ITEMC=J
16     IF(I.EQ.0)K=ITEMC
       PINT=PBAL*RATE(K)
       PBAL=PBAL-PRPAY
       IF(I1.NE.0) A(I1,ITEMC)=INT(PRPAY*100.+.5)/100.
      IF(I2.NE.0) A(I2,ITEMC)=INT(PINT*100.+.5)/100.
       IF(I3.NE.0) A(I3,ITEMC)=INT(PBAL*100.+.5)/100.
20     CONTINUE
25     STATE=1
       IF(I1.NE.0.OR.I2.NE.0.OR.I3.NE.0)INP OK=.FALSE.
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
SERIAL SYMSORT

SYM.  PG.LN. IDENT.

10      1 10         15      1 12         16      1 30         20      1 36         
22      1 16         23      1 17         25      1 37         

STATFIN ** FICHE/FRAME BREAK *****
SETVALUE
C:SETVALUE   02/18/72          SET VALUE.
C
C
       SUBROUTINE SET VALUE(VAL)
C
       NORMAL MODE IS INTEGER
C
       GLOBAL NO OF NODES, VALUE(1)
C
       GLOBAL VAL SHIFT(0/5)
       DATA VAL SHIFT/1K20, 1K16, 1K12, 1K8, 1K4, 1K0/
C
C
       I=(NO OF NODES+5)/6
       J=NO OF NODES-6*I+5
       VALUE(I)=IOR(VALUE(I),VAL*VAL SHIFT(J))
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
SETVALUE SYMSORT

SYM.  PG.LN. IDENT.

CM      1  5 W:SETVALCM      1  4 W:SETVALCM      1  3 W:SETVAL
CMCM    1  7 W:SETVALCMCM    1  2 W:SETVAL
STATFIN ** FICHE/FRAME BREAK *****
SMOOTH
       SUBROUTINE SMOOTH(A,N1,ALPHA,BETA,GAMMA,F,IH,L,S0,R,ICOUNT,E)
       GLOBAL NOOFRO,NOOFCO
       REAL A(NOOFCO,NOOFRO)
       DIMENSION F(1)
       IF(ICOUNT.EQ.1)WRITE(-2,691)
691    FORMAT(//1X,$PERIOD$,2X,$SEASON$,2X,$AVERAGE$,5X,$TREND$,
     +6X,$SEASONAL$,4X,$ACTUAL$,3X,$FORC BASED$,/61X,$ON PREV PER$,
     +/4X,$T$,7X,$J$,7X,$S0$,10X,$R$,9X,$F(J)$,7X,$S(T)$,7X,
     +$S(T-1,1)$,/1X,71($-$)/)
355    P1=0.
       IT=0
360    J=1
370    IT=IT+1
       S1=S0
       S0=ALPHA*A(N1,IT)/F(J)+(1.-ALPHA)*(S1+R)
       F(J)=BETA*A(N1,IT)/S0+(1.-BETA)*F(J)
       R=GAMMA*(S0-S1)+(1.-GAMMA)*R
       IF(ICOUNT.EQ.0) GO TO 375
       WRITE(-2,690)IT,J,S0,R,F(J),A(N1,IT),P1
375    IF(IT.GE.IH)GO TO 400
       IF(J.GE.L) GO TO 360
       J=J+1
       GO TO 370
400    IT=IH
       P1=(S0+R)*F(1)
410    J=1
415    IT=IT+1
       S1=S0
       S0=ALPHA*A(N1,IT)/F(J)+(1.-ALPHA)*(S1+R)
       F(J)=BETA*A(N1,IT)/S0+(1.-BETA)*F(J)
       R=GAMMA*(S0-S1)+(1.-GAMMA)*R
       IF(ICOUNT.EQ.0) GO TO 418
       WRITE(-2,690)IT,J,S0,R,F(J),A(N1,IT),P1
418    E=E+(A(N1,IT)-P1)**2
420    ITEMP=J+1
       IF(ITEMP.GT.L) GO TO 450
       ITEMP=J+1
       P1=(S0+R)*F(ITEMP)
       GO TO 460
450    ITEMP=J+1-L
       P1=(S0+R)*F(ITEMP)
460    IF(IT.GE.NOOFRO) GO TO 700
       IF(J.GE.L) GO TO 410
       J=J+1
       GO TO 415
690    FORMAT(1X,I3,7X,I2,G12.4,1X,G12.4,1X,F8.4,2G12.4)
700    RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
SMOOTH SYMSORT

SYM.  PG.LN. IDENT.

355     1 10         360     1 12         370     1 13         375     1 20         
400     1 24         410     1 26         415     1 27         418     1 34         
420     1 35         450     2  1         460     2  3         690     2  7         
691     1  6         700     2  8         
STATFIN ** FICHE/FRAME BREAK *****
STACK
C:STACK   02/21/72             STACK COMMAND LIST.
C
C
       SUBROUTINE STACK
C
       GLOBAL NO OF COMMANDS,  COM NO,  LIST NO,  COM NEXT,  NEXT COM
       GLOBAL ENTRY1,  ENTRY2,  LEVEL
       GLOBAL LIS(1),  DEFAULT(3,2)
C
       NORMAL MODE IS INTEGER
C
C
       IF ENTRY1+8>=ENTRY2,  CALL FATAL ERROR(5)
C
       LIS(ENTRY1+1)=NO OF COMMANDS
       LIS(ENTRY1+2)=COM NO
       LIS(ENTRY1+3)=LIST NO
       LIS(ENTRY1+4)=DEFAULT(1,2)
       LIS(ENTRY1+5)=DEFAULT(2,2)
       LIS(ENTRY1+6)=DEFAULT(3,2)
       LIS(ENTRY1+7)=COM NEXT
       LIS(ENTRY1+8)=NEXT COM
C
       ENTRY1=ENTRY1+8
       LEVEL=LEVEL+1
C
       RETURN
C
C
C
       SUBROUTINE UNSTACK
C
       LEVEL=LEVEL-1
       ENTRY1=ENTRY1-8
C
       NO OF COMMANDS=LIS(ENTRY1+1)
       COM NO=LIS(ENTRY1+2)
       LIST NO=LIS(ENTRY1+3)
       DEFAULT(1,2)=LIS(ENTRY1+4)
       DEFAULT(2,2)=LIS(ENTRY1+5)
       DEFAULT(3,2)=LIS(ENTRY1+6)
       COM NEXT=LIS(ENTRY1+7)
       NEXT COM=LIS(ENTRY1+8)
C
       RETURN
C
       END
STATFIN ** FICHE/FRAME BREAK *****
STACK SYMSORT

SYM.  PG.LN. IDENT.

CM      1 31 C:STACK CM      1 30 C:STACK CM      1 22 C:STACK 
CM      1 20 C:STACK CM      1 18 C:STACK CM      1 16 C:STACK CM      1  8 C:STACK 
CM      1  6 C:STACK CM      1  3 C:STACK CMCM    1  7 C:STACK CMCM    1  2 C:STACK 
CMCMCM  1 19 C:STACK 
STATFIN ** FICHE/FRAME BREAK *****
STATA1
C:STATA1   07/03/72            STATPAK ANALYSIS OVERLAY ONE.
C
C
       OVERLAY STATA1,5
C
       NORMAL MODE IS INTEGER
C
C
       LOGICAL TALK,HUSH,ECHO,TTY
       INTEGER COM NO
       COMMON /SFE/TALK,HUSH,ECHO,TTY,COM NO
C
       INTEGER INPUT LINE(256), I SAVE(6)
       COMMON /LINE INPUT/INPUT LINE, I SAVE, I POINT, I COUNT, INDEX
C
       COMMON /CODE/MAX CODE, N CODE, CODE(200)
C
       LOGICAL FILE INPUT,  DATA IN,  INP OK,  APP OK
       LOGICAL NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC
       LOGICAL BACK UP
       LOGICAL FLAG 1,  FLAG 2
       REAL TAX,  MATRIX
C
       SHARE MATRIX(2048)
       SHARE $FILES,  /SFE/,  /LINE INPUT/
       SHARE /CODE/
       SHARE NAME(18)
       SHARE BEGIN(9),  IN FLOW,  OUT FLOW,  TAX COLUMN,  TAX
       SHARE TAX FREQUENCY
       SHARE TITLE(2),  CPL,  C COUNT,  FLAG 1(90),  FLAG 2(9)
       SHARE FILE INPUT,  DATA IN,  INP OK,  APP OK,  STATE
       SHARE NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC,  NO OF CASES
       SHARE P COLUMNS,  P ROWS,  MAX NAMES,  BACK UP
       SHARE NAMES(423),  NO OF COLUMNS,  NO OF ROWS
       SHARE NO OF PERIODS,  COLUMNS(2,208),  ROWS(2,-2:-1)
       SHARE OVERFLOW(27)
       SHARE CRAP(439),LINE(0/60)
C
       REAL TEMP
       COMMON /TEMP/TEMP(200)
C
       LOGICAL FLAG
C
C
       CONNECT OVERFLOW, TYPE OVERFLOW;  STATE=2;  GO TO 1$
C
C
       GO TO (5000, 5100, 5200, 5300, 5400, 5500),
+              CODE(2)-49,  5600
C
C
*
*
*
C      ELEMENTRY
C *******************
*
5000   CALL ELEMENTRY(CODE(3)#0)
C
5010   CLOSE
       GO TO 1$
*
*
*
C      CORRELATION
C *********************
*
5100   CALL CORRELATION(CODE(3)#0)
       GO TO 5010
*
*
*
C      SCATTER
C *****************
*
5200   CALL SCATTER(CODE(4), CODE(6), CODE(8)*1K16)
       GO TO 1$
*
*
*
C      CURVE
C ***************
*
5300   CALL CURVE(CODE(6), CODE(4), CODE(8), CODE(9), CODE(10))
       GO TO 1$
*
*
*
C      HISTOGRAM
C *****************
*
5400   FLAG=.TRUE.
C
5410   CALL HISTORY(CODE(4), CODE(6)*1K16, CODE(8), FLAG)
       GO TO 1$
*
*
*
C      CUMULATIVE
C ********************
*
5500   FLAG=.FALSE.
       GO TO 5410
*
*
*
C      CONTINGENCY
C *********************
*
5600   CALL CONTINGENCY
       GO TO 1$
*
C
C
C      RETURN TO MAIN OVERLAY.
C
1$     TERMINATE OVERLAY
C
C
       END
       SUBROUTINE HISTORY(JCOL,ISYM,INT,FLAG)
       INTEGER STATE
       GLOBAL LINE(0/60),NOOFRO,GFORM,STATE
       LOGICAL FLAG
       DIMENSION IFREQ(0/11)
C CALCULATE START VALUE AND INCREMENT
70     BMIN=5E76
       BMAX=-5E76
       DO 90 I=1,NOOFRO
       IF(DATA(I,JCOL)-BMIN)75,80,80
75     BMIN=DATA(I,JCOL)
80     IF(DATA(I,JCOL)-BMAX)90,90,7718
7718   BMAX=DATA(I,JCOL)
90     CONTINUE
       RANGE=BMAX-BMIN
       IF(-RANGE)92,325,92
92     MAX=BMAX
       IF(BMAX-MAX)95,7719,7719
7719   MAX=MAX+1
95     BINCR=(MAX-BMIN)/INT
100    I=RANGE/BINCR
       IF(I-(INT-1))105,110,105
105    AMAX=BMIN+(I+1)*BINCR
       BINCR=(AMAX-BMIN)/INT
       GO TO 100
C ATTEMPT TO PRODUCE INTEGER SCALE NUMBERS
110    MIN=BMIN
       IF(BMIN-MIN)120,115,125
115    INCR=BINCR
       IF(BINCR-INCR)125,148,125
120    MIN=MIN-1
125    AINCR=(RANGE+1)/INT
       INCR=AINCR
       IF(AINCR-INCR)130,135,130
130    INCR=INCR+1
135    I=(BMAX-MIN)/INCR
       IF(I-(INT-1))148,140,148
140    BINCR=INCR
       BMIN=MIN
C CALCULATE AND TYPE FREQUENCIES
148    WRITE (-2,1190)
       DO 150 I=0,INT-1
150    IFREQ(I)=0
       DO 160 I=1,NOOFRO
       II=(DATA(I,JCOL)-BMIN)/BINCR
160    IFREQ(II)=IFREQ(II)+1
C  IF CUMULATIVE HIST, ACCUMULATE FREQUENCIES
       IF FLAG, GO TO 161
       DO 163 I=1,INT-1
163    IFREQ(I)=IFREQ(I-1)+IFREQ(I)
       WRITE (-2,1058)
161    WRITE (-2,1060)
C  TYPE OUT FREQUENCIES
       DO 162 I=0,INT-1
162    WRITE (-2,1070) IFREQ(I)
       WRITE (-2,1075)
       WRITE (-2,1110)
       DO 165 I=1,INT+1
165    WRITE (-2,1120)
       WRITE (-2,1075)
C CALCULATE MAX FREQ AND FREQ INCREMENT
       MAX=-50000
       DO 180 I=0,INT-1
       IF(IFREQ(I)-MAX)180,180,7721
7721   MAX=IFREQ(I)
180    CONTINUE
       INCR=(MAX/53)+1
C PLOT
200    DO 205 I=0,60
205    LINE(I)=0
       IQ = 0
       DO 280 J=MAX,1,-INCR
       DO 212 I=INT-1,0,-1
207    IF(IFREQ(I)-J)212,7722,7722
7722   LINE(I*5+2)=ISYM
       LINE(I*5+3)=ISYM
212    CONTINUE
215    IF IQ.EQ.0, IQ=1; GO TO 220
       IQ = 0
       GO TO 225
220    WRITE (-2,1080) J
       GO TO 230
225    WRITE (-2,1090)
230    DO 240 LOC=58,2,-1
       IF(LINE(LOC))250,240,250
240    CONTINUE
250    IF(LOC-2)280,280,7723
7723   WRITE (-2,1100) (LINE(K),K=2,LOC)
280    WRITE (-2,1075)
300    WRITE (-2,1110)
       DO 310 I=1,INT+1
310    WRITE (-2,1120)
       WRITE (-2,1125)
       GFORM=1.3
       II=0
315    DO 320 I=II,INT,2
       S=BMIN+I*BINCR
320    CALL GTYPE(S)
       WRITE (-2,1075)
       IF(-II)330,7724,7724
7724   WRITE (-2,1140)
       II=1
       GO TO 315
C ERROR. CANNOT PLOT BECAUSE RANGE=0.
325    TYPE 1185
       STATE=2
       GO TO 340
330    STATE=1
340    RETURN
1058   FORMAT(/$CUMULATIVE$,Z)
1060   FORMAT(/$FREQUENCY$,Z)
1070   FORMAT(Z,12I5)
1075   FORMAT()
1080   FORMAT(I5,7X,Z)
1090   FORMAT(12X,Z)
1100   FORMAT(Z,57A1)
1110   FORMAT(2X8($-$),Z)
1120   FORMAT($+$4($-$),Z)
1125   FORMAT(/4X,Z)
1130   FORMAT(F10.3,Z)
1135   FORMAT(E10.3,Z)
1140   FORMAT(9X,Z)
1185   FORMAT(/$RANGE IS 0. CANNOT CREATE HISTOGRAM.$)
1190   FORMAT(/)
       END
       SUBROUTINE SCATTER(COL1,COL2,ISYM)
       INTEGER STATE,COL1,COL2
       GLOBAL LINE(0/60),NOOFRO,GFORM,STATE
       COMMON /TEMP/ITEMP(200,2)
       DIMENSION BMIN(2),BMAX(2),BINCR(2),LEN(2),IVAR(2)
       LEN(1)=60
       LEN(2)=35
       IVAR(1)=COL1
       IVAR(2)=COL2
C GET START VALUE AND INCREMENT
       DO 90 J=1,2
       BMIN(J)=5E76
       BMAX(J)=-5E76
       DO 80 I=1,NOOFRO
       IF(DATA(I,IVAR(J))-BMIN(J))65,70,70
65     BMIN(J)=DATA(I,IVAR(J))
70     IF(DATA(I,IVAR(J))-BMAX(J))80,80,7727
7727   BMAX(J)=DATA(I,IVAR(J))
80     CONTINUE
       BRANGE=BMAX(J)-BMIN(J)
       BINCR(J)=BRANGE/LEN(J)
C ATTEMPT TO PRODUCE INTEGER SCALE NUMBERS
       MIN=BMIN(J)
       IF(BMIN(J)-MIN)82,81,84
81     INCR=BRANGE/5.
       IF(BRANGE/5.-INCR)84,90,84
82     MIN=MIN-1
84     AINCR=(BRANGE+1)/LEN(J)
       INCR=(BRANGE+1.)/5.
       IF((BRANGE+1.)/5.-INCR)86,88,86
86     INCR=INCR+1
       AINCR=5.*INCR/LEN(J)
88     IF(BRANGE/AINCR-(LEN(J)/5)*3)90,7728,7728
7728   BINCR(J)=AINCR
       BMIN(J)=MIN
       BMAX(J)=BMIN(J)+LEN(J)*AINCR
90     CONTINUE
C CONVERT DATA TO AXIS POSITIONS
       DO 100 J=1,2
       DO 100 I=1,NOOFRO
100    ITEMP(I,J)=(DATA(I,IVAR(J))-BMIN(J))/BINCR(J)
C SORT DATA PAIRS INTO INCREASING ORDER WRT Y
       DO 150 K=NOOFRO-1,1,-1
       DO 140 I=1,K
       IF(ITEMP(I,2)-ITEMP(I+1,2))140,140,7729
7729   DO 130 J=1,2
       II=ITEMP(I,J)
       ITEMP(I,J)=ITEMP(I+1,J)
130    ITEMP(I+1,J)=II
       IK=-1
140    CONTINUE
       IF(IK)150,200,150
150    IK=0
C PLOT
200    WRITE (-2,1155)
       GFORM=3.3
       DO 202 I=0,60,12
       S=BMIN(1)+I*BINCR(1)
202    CALL GTYPE(S)
       WRITE (-2,1150)
       WRITE (-2,1160)
       DO 205 I=0,60
205    LINE(I)=0
       WRITE (-2,1150)
       GFORM=.3
       J=35
       DO 212 I=NOOFRO,1,-1
207    IF(ITEMP(I,2)-J)215,210,215
210    LINE(ITEMP(I,1))=ISYM
212    IK=-1
215    IF(MOD(J,7))225,220,225
220    S=BMIN(2)+J*BINCR(2)
       CALL GTYPE(S)
       WRITE (-2,1120)
       GO TO 230
225    WRITE (-2,1130)
230    IF(IK)235,280,235
235    DO 240 LOC=60,0,-1
       IF(LINE(LOC))250,240,250
240    CONTINUE
250    DO 260 K=0,LOC
       WRITE (-2,1140) LINE(K)
260    LINE(K)=0
       IK=0
280    WRITE (-2,1150)
       J=J-1
       IF(-J)207,207,7730
7730   GFORM=3.3
       WRITE (-2,1160)
       WRITE (-2,1150)
       DO 310 I=0,60,12
       S=BMIN(1)+I*BINCR(1)
310    CALL GTYPE(S)
       WRITE (-2,1155)
       STATE=1
       RETURN
1120   FORMAT($ +$,Z)
1130   FORMAT(10X$.$,Z)
1140   FORMAT(Z,61A1)
1150   FORMAT()
1155   FORMAT(8(/))
1160   FORMAT(11X5($+ . . . . . $)$+$,Z)
       END
       SUBROUTINE ELEMENTRY(FLAG)
       LOGICAL FLAG
       INTEGER STATE,COLUMNS
       GLOBAL NOOFRO,NOOFCO,GFORM,STATE,COLUMNS(2,1)
       DIMENSION ANS(6)
       IF .NOT.FLAG, GO TO 1
       WRITE (3,600) NO OF COLUMNS,  NO OF COLUMNS,
+              ((COLUMNS(1,I),COLUMNS(2,I)), I=1, NO OF COLUMNS)
       GO TO 2
1      WRITE (-2,560)
       WRITE (-2,500)
2      DO 150 J=1,NOOFCO
C CALCULATE ELEMENTARY STATISTICS
       SUM =0.
       SUMSQ=0.
       BMIN=5E76
       BMAX=-5E76
       DO 80 I=1,NOOFRO
       SUM=SUM+DATA(I,J)
       SUMSQ=SUMSQ+DATA(I,J)*DATA(I,J)
       IF(DATA(I,J)-BMIN)65,70,70
65     BMIN=DATA(I,J)
70     IF(DATA(I,J)-BMAX)80,80,7756
7756   BMAX=DATA(I,J)
80     CONTINUE
       ANS(1)=SUM/NOOFRO
       ANS(2)=SQRT((SUMSQ-SUM*SUM/NOOFRO)/(NOOFRO-1))
       ANS(3)=ANS(2)/SQRT(NOOFRO)
       ANS(4)=BMAX
       ANS(5)=BMIN
       ANS(6)=BMAX-BMIN
C PRINT RESULTS
       IF .NOT.FLAG, WRITE (-2,520) COLUMNS(1,J),COLUMNS(2,J)
100    K=1
102    DO 130 I=K,6
       IF I.EQ.1 .OR. I.EQ.3,  GFORM=1.3  .ELSE.  GFORM=2.3
130    IF FLAG, WRITE (2,570) ANS(I)  .ELSE. CALL GTYPE(ANS(I))
       IF FLAG, WRITE (2,550)  .ELSE. WRITE(-2,550)
150    CONTINUE
       IF .NOT.FLAG, WRITE (-2,560)
       STATE=1
       RETURN
500    FORMAT(/$VARIABLE    MEAN    STD DEV   STD ERR    MAXIMUM$
+              $    MINIMUM      RANGE$ /)
520    FORMAT(2A3,Z)
550    FORMAT()
560    FORMAT(/)
570    FORMAT(G18.11,Z)
600    FORMAT('!2 TITLE ELEM'/'!2 SPECIAL'/I',6'/N(2A3/)
+             'MEAN'/'STDEV'/'STERR'/'MAXIM'/'MINIM'/'RANGE')
       END
       SUBROUTINE CORRELATION(FLAG)
       LOGICAL FLAG
       INTEGER STATE,COLUMNS
       GLOBAL NOOFCO,NOOFRO,GFORM,STATE,COLUMNS(2,1)
       COMMON /TEMP/TEMP(200)
       DISCONNECT OVERFLOW;IGNORE OVERFLOW
       IF NOOFRO<NOOFCO,  TYPE 50;  STATE=2;  RETURN
       IF.NOT.FLAG,WRITE(-2,250)(COLUMNS(1,I),
     +COLUMNS(2,I),I=1,NOOFCO);GO TO 1
       WRITE (3,3) NO OF COLUMNS,  NO OF COLUMNS,  (NO OF COLUMNS,
+              (COLUMNS(1,I),COLUMNS(2,I), I=1, NO OF COLUMNS), J=1,2)
1      DO 25 I=1,NOOFCO
       SUMI=SUMIV=0
       DO 5 J=1,NOOFRO
       SUMI=SUMI+DATA(J,I)
5      SUMIV=SUMIV+DATA(J,I)**2
       DO 20 K=1,I
       SUMK=SUMP=SUMKV=0
       DO 10 J=1,NOOFRO
       SUMK=SUMK+DATA(J,K)
       SUMKV=SUMKV+DATA(J,K)**2
10     SUMP=SUMP+DATA(J,K)*DATA(J,I)
       COVAR=SUMP-SUMI*SUMK/NOOFRO
       VARI=SUMIV-SUMI*SUMI/NOOFRO
       VARK=SUMKV-SUMK*SUMK/NOOFRO
20     TEMP(K)=COVAR/SQRT(VARI*VARK)
       IF FLAG,WRITE(2,200)TEMP(J),J=1,I;GO TO 25
       WRITE(-2,300)COLUMNS(1,I),COLUMNS(2,I),(TEMP(L),L=1,I)
25     CONTINUE
       IF .NOT.FLAG,  WRITE (-2,400)
       STATE=1
       RETURN
C
3      FORMAT('!2 TITLE CORR'/'!2 SYMMETRIC'/'!2 SPECIAL'/
+              2I/2(N(2A3/))Z)
50     FORMAT(/$# OF ROWS MUST BE >= # OF VARIABLES.$/)
200    FORMAT(13G18.11)
300    FORMAT(/2A3/,(10F7.4,/))
250    FORMAT(/$CORRELATION MATRIX$/,10(1X,2A3)/)
400    FORMAT(/)
       END
       SUBROUTINE CONTINGENCY
       INTEGER STATE
       GLOBAL STATE,NOOFCO,NOOFRO
       N=0
       CHISQ=0
C      FIND TOTAL OBSERVATIONS
       DO 10 I=1,NOOFRO
       DO 10 J=1,NOOFCO
10     N=N+DATA(I,J)
C      CALCULATION OF CHI-SQUARE
       DO 100 J=1,NOOFCO
       DO 100 I=1,NOOFRO
       R=0
       DO 50 K=1,NOOFCO
50     R=DATA(I,K)+R
       C=0
       DO 75 K=1,NOOFRO
75     C=DATA(K,J)+C
       E=R*C/N
       CHISQ=CHISQ+((DATA(I,J)-E))**2/E
100    CONTINUE
102    WRITE (-2,2) CHISQ,(NOOFRO-1)*(NOOFCO-1)
       STATE=1
200    RETURN
2      FORMAT(//'CHI-SQUARE: 'F.5' WITH 'I'DEGREES OF FREEDOM.'/)
       END
       SUBROUTINE CURVE(IY,IX,IW,IRES,IREG)
       INTEGER STATE
       LOGICAL INP OK
       GLOBAL NOOFRO,STATE,INP OK
       COMMON /TEMP/RV(6),IOK(6),A(6),B(6),COF(6),CO(136)
       EXTERNAL SAME,RECIP,ALOG
       DO 5555 I=1,6
5555   IOK(I)=0
C
C MAKE SURE ALL POINTS CAN BE FITTED TO CURVES
C
531    DO 532 I=1,6
532    IOK(I)=1
       DO 535 I=1,NOOFRO
       IF(DATA(I,IX).EQ.0)IOK(2)=-1;IOK(4)=-1;IOK(6)=-1
       IF(DATA(I,IX).LT.0)IOK(2)=-1;IOK(6)=-1
       IF(DATA(I,IY).EQ.0)IOK(2)=-1;IOK(3)=-1;IOK(5)=-1;IOK(6)=-1
       IF(DATA(I,IY).LT.0)IOK(2)=-1;IOK(3)=-1
535    CONTINUE
C
C LOOP TO CALCULATE A,B, AND R-SQUARED USING FUNCTION CDRVAL
C
       DO 600 I=1,6
       IF(IOK(I).EQ.-1)GO TO 600
       GO TO (540,550,560,570,580)I, 590
540    N=CDRVAL(SAME,SAME,CV,DV,RV(1),IY,IX,IW)
       A(1)=CV
       B(1)=DV
       GO TO 600
550    N=CDRVAL(ALOG,ALOG,CV,DV,RV(2),IY,IX,IW)
       A(2)=EXP(CV)
       B(2)=DV
       GO TO 600
560    N=CDRVAL(ALOG,SAME,CV,DV,RV(3),IY,IX,IW)
       A(3)=EXP(CV)
       B(3)=DV
       GO TO 600
570    N=CDRVAL(SAME,RECIP,CV,DV,RV(4),IY,IX,IW)
       A(4)=CV
       B(4)=DV
       GO TO 600
580    N=CDRVAL(RECIP,SAME,CV,DV,RV(5),IY,IX,IW)
       A(5)=CV
       B(5)=DV
       GO TO 600
590    N=CDRVAL(RECIP,RECIP,CV,DV,RV(6),IY,IX,IW)
       A(6)=DV
       B(6)=CV
600    CONTINUE
       WRITE (-2,1)
1      FORMAT(//15X,$LEAST SQUARES CURVES FIT$//18X$INDEX  OF$/
+              $ CURVE TYPE     DETERMINATION        A             B$/)
603    FORMAT(Z$SORRY, CURVE CANNOT BE FIT TO DATA$)
605    FORMAT(Z3(G13.6,1X))
       WRITE (-2,2)
2      FORMAT(/Z$1. Y=A+(B*X)$6X)
       IF(IOK(1).EQ.-1)WRITE (-2,603);  GO TO 620
       WRITE (-2,605) RV(1),A(1),B(1)
620    WRITE (-2,3)
3      FORMAT(/Z$2. Y=A*(X^B)$6X)
       IF(IOK(2).EQ.-1)WRITE (-2,603);  GO TO 630
       WRITE (-2,605) RV(2),A(2),B(2)
630    WRITE (-2,4)
4      FORMAT(/Z$3. Y=A*EXP(B*X)$3X)
       IF(IOK(3).EQ.-1)WRITE (-2,603);  GO TO 640
       WRITE (-2,605) RV(3),A(3),B(3)
640    WRITE (-2,5)
5      FORMAT(/Z$4. Y=A+(B/X)$6X)
       IF(IOK(4).EQ.-1)WRITE (-2,603); GO TO 650
       WRITE (-2,605) RV(4),A(4),B(4)
650    WRITE (-2,6)
6      FORMAT(/Z$5. Y=1/(A+(B*X))$2X)
       IF(IOK(5).EQ.-1)WRITE (-2,603); GO TO 660
       WRITE (-2,605) RV(5),A(5),B(5)
660    WRITE (-2,7)
7      FORMAT(/Z$6. Y=X/(A+(B*X))$2X)
       IF(IOK(6).EQ.-1)WRITE (-2,603); GO TO 665
       WRITE (-2,605) RV(6),A(6),B(6)
665    WRITE (-2,8)
8      FORMAT(//)
800    IFLAG=0
       WRITE(-2,9)
9      FORMAT(/Z$PRINT A TABLE OF RESIDUALS? $)
       CALL NEWLINE(NCH)
       IANS=NOWCHR(0)
       IF(IANS.EQ.1RY)GO TO 820
       IF(IANS.EQ.1RN)GO TO 990
       GO TO 800
820    WRITE (-2,10)
10     FORMAT(/Z$FOR WHAT CURVE #$)
       CALL NEWLINE(NCH)
       IDE=NOWCHR(0)-20B
       IF NCH#1.OR..NOT.0<IDE<7, WRITE (-2,11);  GO TO 890
11     FORMAT($?$/)
       IF IOK(IDE)<0, WRITE (-2,12);  GO TO 890
12     FORMAT($THIS CURVE DOES NOT FIT DATA.$/)
       GO TO (831,832,833,834,835) IDE,  836
831    WRITE (-2,20);  GO TO 838
20     FORMAT(//$RESIDUALS FOR 1. Y=A+(B*X):$)
832    WRITE (-2,30);  GO TO 838
30     FORMAT(//$RESIDUALS FOR 2. Y=A*(X^B):$)
833    WRITE (-2,40);  GO TO 838
40     FORMAT(//$RESIDUALS FOR 3. Y=A*EXP(B*X):$)
834    WRITE (-2,50);  GO TO 838
50     FORMAT(//$RESIDUALS FOR 4. Y=A+(B/X):$)
835    WRITE (-2,60);  GO TO 838
60     FORMAT(//$RESIDUALS FOR 5. Y=1/(A+B*X):$)
836    WRITE (-2,70)
70     FORMAT(//$RESIDUALS FOR 6. Y=X/(A+B*X):$)
838    WRITE (-2,80)
80     FORMAT(/$Y OBSERVED     Y ESTIMATED       RESIDUAL$)
894       DO 890 I=1,NOOFRO
       GO TO (830,840,850,860,870), IDE, 880
830    YE=A(1)+B(1)*DATA(I,IX)
       GO TO 885
840    YE=A(2)*(DATA(I,IX)**B(2))
       GO TO 885
850    YE=A(3)*EXP(B(3)*DATA(I,IX))
       GO TO 885
860    YE=A(4)+B(4)/DATA(I,IX)
       GO TO 885
870    YE=1/(A(5)+B(5)*DATA(I,IX))
       GO TO 885
880    YE=DATA(I,IX)/(A(6)+B(6)*DATA(I,IX))
885    YO=DATA(I,IY)
       IF(IFLAG.EQ.1.AND.IREG.NE.0) CALL STORE(1,IREG,A(IDE));
     +  CALL STORE(2,IREG,B(IDE))
       YDIF=YO-YE
       IF(ABS(YDIF).LT.1E-8)YDIF=0
       IF(IFLAG.EQ.1.AND.IRES.NE.0) CALL STORE(I,IRES,YDIF)
       IF(IFLAG.NE.1) WRITE(-2,886) YO,YE,YDIF
886    FORMAT(/Z1PG13.6,2(3X1PG13.6))
890    CONTINUE
       IF(IFLAG.EQ.1) GO TO 995
98     WRITE(-2,99)
99     FORMAT(/Z$ANOTHER CURVE? $)
       CALL NEWLINE(NCH)
       IANS=NOWCHR(0)
       IF(IANS.EQ.1RY)GO TO 820
       IF IANS#1RN,  GO TO 98
990    IF(IREG.EQ.0.AND.IRES.EQ.0) GO TO 995
896    WRITE(-2,892)
892    FORMAT(/Z$SAVE RESIDUALS/COEFFS. FOR CURVE #$)
       CALL NEWLINE(NCH)
       IDE=NOWCHR(0)-20B
       IFLAG=1
       IF.NOT.(IDE.GT.0.AND.IDE.LT.7.AND.IOK(IDE).GE.0),GO TO 896
       DO 893 J=1,NOOFRO
       IF IREG#0,  CALL STORE(I,IREG,0.)
893    IF IRES#0,  CALL STORE(I,IRES,0.)
       GO TO 894
995    STATE=1
       IF(IRES.NE.0.OR.IREG.NE.0)INP OK=.FALSE.
       RETURN
       END
       FUNCTION CDRVAL(FUNCY,FUNCX,CV,DV,RS,IY,IX,IW)
       D1=D2=D21=D3=VBAR=S1=S2=SSR=SST=0
       GLOBAL NOOFRO
       NNR=0
       DO 500 I=1,NOOFRO
       D1=D1+FUNCX(DATA(I,IX))*FUNCY(DATA(I,IY))
       IF(IW.NE.0)D1=D1+FUNCX(DATA(I,IX))*FUNCY(DATA(I,IY))*
+(DATA(I,IW)-1)
       D2=D2+FUNCX(DATA(I,IX))
       IF(IW.NE.0)D2=D2+FUNCX(DATA(I,IX))*(DATA(I,IW)-1)
       D21=D21+FUNCY(DATA(I,IY))
       IF(IW.NE.0)D21=D21+FUNCY(DATA(I,IY))*(DATA(I,IW)-1)
       D3=D3+FUNCX(DATA(I,IX))**2
       IF(IW.NE.0)D3=D3+(FUNCX(DATA(I,IX))**2)*(DATA(I,IW)-1)
       VBAR=VBAR+FUNCY(DATA(I,IY))
       IF(IW.NE.0)NNR=NNR+DATA(I,IW);VBAR=VBAR+FUNCY(DATA(I,IY))
+*(DATA(I,IW)-1)
500    CONTINUE
       IF(NNR.EQ.0)NNR=NOOFRO
       VBAR=VBAR/NNR
       DV=(D1-D2*D21/NNR)/(D3-D2**2/NNR)
       CV=(D21-DV*D2)/NNR
       DO 600 I=1,NOOFRO
       S1=S1+(CV+DV*FUNCX(DATA(I,IX))-VBAR)**2
       IF(IW.NE.0)S1=S1+(DATA(I,IW)-1)*(CV+DV*FUNCX(DATA(I,IX))
+-VBAR)**2
       S2=S2+(FUNCY(DATA(I,IY))-(CV+DV*FUNCX(DATA(I,IX))))**2
       IF(IW.NE.0)S2=S2+(DATA(I,IW)-1)*(FUNCY(DATA(I,IY))-
+(CV+DV*FUNCX(DATA(I,IX))))**2
600    CONTINUE
       SSR=S1
       SST=S1+S2
C NEXT STATEMENT TO PREVENT BOMBOUT IF PERFECT FIT AND DV OF ZERO
       IF(SSR.EQ.0.AND.SST.EQ.0)RS=1;GO TO 610
       RS=SSR/SST
610    CDRVAL=1
       RETURN
       END
C
C FUNCTION SAME USED IN CURVE-FITTING
C
       FUNCTION SAME(X)
       SAME=X
       RETURN
       END
C
C FUNCTION RECIP USED IN CURVE-FITTING
C
       FUNCTION RECIP(X)
       RECIP=1/X
       RETURN
       END
       SUBROUTINE TTEST(T,NDF,ANS,KERR)
       D1=.636619772368
       KERR=0
       IF(NDF)10,10,1
10     KERR=1
       ANS=0
       RETURN
1      T=ABS(T)
       T1=T/SQRT(FLOAT(NDF))
       T2=1./(1.+T1**2)
       IF((NDF/2)*2-NDF)50,5,50
50     ANS=1.-D1*ATAN(T1,1.)
       IF(NDF-1)40,4,40
40     D2=D1*T1*T2
       ANS=ANS-D2
       IF(NDF-3)400,4,400
400    F1=0.
2      N=(NDF-2)/2
       DO 3 I=1,N
       F2=2*FLOAT(I)-F1
       D2=D2*T2*F2/(F2+1.)
3      ANS=ANS-D2
4      IF(ANS)60,70,70
60     ANS=0.
70     RETURN
5      D2=T1*SQRT(T2)
       ANS=1.-D2
       IF(NDF-2)80,4,80
80     F1=1.
       GO TO 2
       END
       FUNCTION REDUC(I,J,CO)
       DIMENSION CO(1)
       L=0
       DO 100 K=1,I
100    L=L+K
       L=L+J-I
       REDUC=CO(L)
       RETURN
       END
       SUBROUTINE GTYPE(ARG)
       GLOBAL GFORM
       I=GFORM
       IF(I)10,15,10
C  PRECEDING SPACES
10     DO 12 II=1,I
12     WRITE (-2,1000)
C  EXAMINE NO. OF DEC. PLACES
15     IF(GFORM-I-.5)17,20,17
17     ASSIGN 1005 TO IFORMF
       ASSIGN 1010 TO IFORME
       GO TO 25
20     ASSIGN 1015 TO IFORMF
       ASSIGN 1020 TO IFORME
25     IF(ARG)35,50,35
35     EXP=ALOG(ABS(ARG))/2.302585093
       IF(EXP+1)40,50,7770
7770   IF(EXP-4)50,40,40
40     WRITE (-2,IFORME) ARG
       RETURN
50     WRITE (-2,IFORMF) ARG
       RETURN
1000   FORMAT($ $,Z)
1005   FORMAT(F9.3,Z)
1010   FORMAT(E9.3,Z)
1015   FORMAT(F11.5,Z)
1020   FORMAT(E11.5,Z)
       END

       SUBROUTINE STORE(I,J,X)
       REAL MATRIX
       GLOBAL NO OF COLUMNS,  MATRIX(1)
       MATRIX(J+NO OF COLUMNS*(I-1))=X
       RETURN

       REAL FUNCTION DATA(L,M)
       DATA=MATRIX(M+NO OF COLUMNS*(L-1))
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
STATA1 SYMSORT

SYM.  PG.LN. IDENT.

+      13 20 C:STATA1+      11 18 C:STATA1+      10 34 C:STATA1+      10 22 C:STATA1
+      10 16 C:STATA1+       9 19 C:STATA1+       1 36 C:STATA1+       1 25 C:STATA1
+       1 12 C:STATA11      17 19 C:STATA11      13 19 C:STATA11      10 35 C:STATA1
1       9 21 C:STATA110     18 18 C:STATA110     17 16 C:STATA110     14 19 C:STATA1
10     11 33 C:STATA110     11  6 C:STATA1100    18  8 C:STATA1100    12  6 C:STATA1
100    10  6 C:STATA1100     7 27 C:STATA1100     3 38 C:STATA11000   18 35 C:STATA1
1005   18 36 C:STATA11010   18 37 C:STATA11015   18 38 C:STATA1102    12  7 C:STATA1
102    10  7 C:STATA11020   18 39 C:STATA1105     4  1 C:STATA11058    6 10 C:STATA1
1060    6 11 C:STATA11070    6 12 C:STATA11075    6 13 C:STATA11080    6 14 C:STATA1
1090    6 15 C:STATA111     14 23 C:STATA1110     4  5 C:STATA11100    6 16 C:STATA1
1110    6 17 C:STATA11120    9  5 C:STATA11120    6 18 C:STATA11125    6 19 C:STATA1
1130    9  6 C:STATA11130    6 20 C:STATA11135    6 21 C:STATA11140    9  7 C:STATA1
1140    6 22 C:STATA1115     4  7 C:STATA11150    9  8 C:STATA11155    9  9 C:STATA1
1160    9 10 C:STATA11185    6 23 C:STATA11190    6 24 C:STATA112     18 19 C:STATA1
12     14 25 C:STATA1120     4  9 C:STATA1125     4 10 C:STATA1130    10  9 C:STATA1
130     7 35 C:STATA1130     4 13 C:STATA1135     4 14 C:STATA1140     7 37 C:STATA1
140     4 16 C:STATA1148     4 19 C:STATA115     18 21 C:STATA1150    10 11 C:STATA1
150     7 39 C:STATA1150     4 21 C:STATA1160     4 24 C:STATA1161     4 30 C:STATA1
162     4 33 C:STATA1163     4 28 C:STATA1165     4 37 C:STATA117     18 22 C:STATA1
180     5  5 C:STATA12      17 29 C:STATA12      13 24 C:STATA12      12 10 C:STATA1
2       9 23 C:STATA120     18 25 C:STATA120     14 28 C:STATA120     11 10 C:STATA1
200    12  9 C:STATA1200    11 20 C:STATA1200     8  2 C:STATA1200     5  8 C:STATA1
202     8  6 C:STATA1205     8 10 C:STATA1205     5  9 C:STATA1207     8 15 C:STATA1
207     5 13 C:STATA1210     8 16 C:STATA1212     8 17 C:STATA1212     5 16 C:STATA1
215     8 18 C:STATA1215     5 17 C:STATA1220     8 19 C:STATA1220     5 20 C:STATA1
225     8 23 C:STATA1225     5 22 C:STATA1230     8 24 C:STATA1230     5 23 C:STATA1
235     8 25 C:STATA1240     8 27 C:STATA1240     5 25 C:STATA125     18 27 C:STATA1
25     11 13 C:STATA1250    11 22 C:STATA1250     8 28 C:STATA1250     5 26 C:STATA1
260     8 30 C:STATA1280     8 32 C:STATA1280     5 28 C:STATA13      17 33 C:STATA1
3      13 28 C:STATA130     14 30 C:STATA1300    11 21 C:STATA1300     5 29 C:STATA1
310     9  1 C:STATA1310     5 31 C:STATA1315     5 35 C:STATA1320     5 37 C:STATA1
325     6  5 C:STATA1330     6  8 C:STATA1340     6  9 C:STATA135     18 28 C:STATA1
4      17 34 C:STATA14      13 32 C:STATA140     18 31 C:STATA140     17 25 C:STATA1
40     14 32 C:STATA1400    17 28 C:STATA1400    11 23 C:STATA15      17 37 C:STATA1
5      13 36 C:STATA15      10 39 C:STATA150     18 33 C:STATA150     17 23 C:STATA1
50     14 34 C:STATA150     11 39 C:STATA150     11 19 C:STATA1500    10 15 C:STATA1
5000    2  1 C:STATA15100    2 10 C:STATA1520    10 17 C:STATA15200    2 18 C:STATA1
5300    2 26 C:STATA1532    12 22 C:STATA1535    12 28 C:STATA1540    12 33 C:STATA1
5400    2 34 C:STATA1550    12 37 C:STATA1550    10 18 C:STATA15500    3  4 C:STATA1
5555   12 19 C:STATA1560    13  2 C:STATA1560    10 19 C:STATA15600    3 12 C:STATA1
570    13  6 C:STATA1570    10 20 C:STATA1580    13 10 C:STATA1590    13 14 C:STATA1
6      14  1 C:STATA160     17 35 C:STATA160     14 36 C:STATA1600    13 17 C:STATA1
600    10 21 C:STATA1603    13 21 C:STATA1605    13 22 C:STATA1610    16 38 C:STATA1
620    13 27 C:STATA1630    13 31 C:STATA1640    13 35 C:STATA165      9 33 C:STATA1
65      7  2 C:STATA1650    13 39 C:STATA1660    14  4 C:STATA1665    14  8 C:STATA1
7      14  5 C:STATA170     17 36 C:STATA170     14 38 C:STATA170      9 34 C:STATA1
70      7  3 C:STATA170      3 24 C:STATA175     12  3 C:STATA175      3 28 C:STATA1
7718    3 30 C:STATA17719    3 36 C:STATA17721    5  4 C:STATA17722    5 14 C:STATA1
7723    5 27 C:STATA17724    6  1 C:STATA17727    7  4 C:STATA17728    7 20 C:STATA1
7729    7 32 C:STATA17730    8 35 C:STATA17756    9 35 C:STATA17770   18 30 C:STATA1
8      14  9 C:STATA180     18  1 C:STATA180     15  1 C:STATA180      9 36 C:STATA1
80      7  5 C:STATA180      3 29 C:STATA1800    14 10 C:STATA181      7 11 C:STATA1
82      7 13 C:STATA1820    14 18 C:STATA1830    15  4 C:STATA1831    14 27 C:STATA1
832    14 29 C:STATA1833    14 31 C:STATA1834    14 33 C:STATA1835    14 35 C:STATA1
836    14 37 C:STATA1838    14 39 C:STATA184      7 14 C:STATA1840    15  6 C:STATA1
850    15  8 C:STATA186      7 17 C:STATA1860    15 10 C:STATA1870    15 12 C:STATA1
88      7 19 C:STATA1880    15 14 C:STATA1885    15 15 C:STATA1886    15 22 C:STATA1
890    15 23 C:STATA1892    15 33 C:STATA1893    16  1 C:STATA1894    15  2 C:STATA1
896    15 32 C:STATA19      14 12 C:STATA190      7 23 C:STATA190      3 31 C:STATA1
92      3 34 C:STATA195      3 37 C:STATA198     15 25 C:STATA199     15 26 C:STATA1
990    15 31 C:STATA1995    16  3 C:STATA1C      18 20 C:STATA1
C      18 17 C:STATA1C      16 35 C:STATA1C      11 34 C:STATA1C      11 30 C:STATA1
C      10  4 C:STATA1C       9 24 C:STATA1C       8  1 C:STATA1C       7 28 C:STATA1
C       7 24 C:STATA1C       7  8 C:STATA1C       6 35 C:STATA1C       6  4 C:STATA1
C       5  7 C:STATA1C       4 39 C:STATA1C       4 31 C:STATA1C       4 25 C:STATA1
C       4 18 C:STATA1C       4  4 C:STATA1C       3 23 C:STATA1C       3 10 C:STATA1
C       3  9 C:STATA1C       3  2 C:STATA1C       3  1 C:STATA1C       2 32 C:STATA1
C       2 31 C:STATA1C       2 24 C:STATA1C       2 23 C:STATA1C       2 16 C:STATA1
C       2 15 C:STATA1C       2  8 C:STATA1C       2  7 C:STATA1C       1 38 C:STATA1
CM     12 30 C:STATA1CM      1 33 C:STATA1CM      1 31 C:STATA1CM      1 16 C:STATA1
CM      1 10 C:STATA1CM      1  9 C:STATA1CM      1  7 C:STATA1CM      1  3 C:STATA1
CM1$    3 16 C:STATA1CM3    11 17 C:STATA1CM5010  2  2 C:STATA1CM531  12 21 C:STATA1
CM5410  2 35 C:STATA1CMC    17  7 C:STATA1CMC    17  2 C:STATA1CMC    12 29 C:STATA1
CMC    12 20 C:STATA1CMCM    3 17 C:STATA1CMCM    1 35 C:STATA1CMCM    1 34 C:STATA1
CMCM    1  4 C:STATA1CMCM    1  2 C:STATA1CMCMC   3 15 C:STATA1CML    17  8 C:STATA1
CML    17  3 C:STATA1L      19  3 C:STATA1L      18 13 C:STATA1L      18  4 C:STATA1
L      17 12 C:STATA1L      16  7 C:STATA1L      12 12 C:STATA1L      11 25 C:STATA1
L      10 24 C:STATA1L       9 12 C:STATA1L       6 26 C:STATA1L       3 18 C:STATA1
OMCM*M  1 37 C:STATA1_(CV+D 16 32 C:STATA1_(DATA 16 14 C:STATA1_*(DAT 16 22 C:STATA1
_-VBAR 16 30 C:STATA1
STATFIN ** FICHE/FRAME BREAK *****
STATA2
C:STATA2   07/03/72            STATPAK ANALYSIS OVERLAY TWO.
C
C
       OVERLAY STATA2,5
C
       NORMAL MODE IS INTEGER
C
C
       LOGICAL TALK,HUSH,ECHO,TTY
       INTEGER COM NO
       COMMON /SFE/TALK,HUSH,ECHO,TTY,COM NO
C
       INTEGER INPUT LINE(256), I SAVE(6)
       COMMON /LINE INPUT/INPUT LINE, I SAVE, I POINT, I COUNT, INDEX
C
       COMMON /CODE/MAX CODE, N CODE, CODE(200)
C
       LOGICAL FILE INPUT,  DATA IN,  INP OK,  APP OK
       LOGICAL NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC
       LOGICAL BACK UP
       LOGICAL FLAG 1,  FLAG 2
       REAL TAX,  MATRIX
C
       SHARE MATRIX(2048)
       SHARE $FILES,  /SFE/,  /LINE INPUT/
       SHARE /CODE/
       SHARE NAME(18)
       SHARE BEGIN(9),  IN FLOW,  OUT FLOW,  TAX COLUMN,  TAX
       SHARE TAX FREQUENCY
       SHARE TITLE(2),  CPL,  C COUNT,  FLAG 1(90),  FLAG 2(9)
       SHARE FILE INPUT,  DATA IN,  INP OK,  APP OK,  STATE
       SHARE NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC,  NO OF CASES
       SHARE P COLUMNS,  P ROWS,  MAX NAMES,  BACK UP
       SHARE NAMES(423),  NO OF COLUMNS,  NO OF ROWS
       SHARE NO OF PERIODS,  COLUMNS(2,208),  ROWS(2,-2:-1)
       SHARE OVERFLOW(27)
       SHARE CRAP(500)
C
C
       CONNECT OVERFLOW, TYPE 10;  STATE=2;  GO TO 1$
C
C
C
       CONNECT OVERFLOW, TYPE OVERFLOW;  STATE=2;  GO TO 1$
C
C
       IF CODE(2)-58,  5700, 5800, 5900
C
*
*
*
C      DESCRIPTIVE
C *********************
*
5700   CALL DESCRIPTIVE(CODE(4))
       GO TO 1$
*
*
*
C      PLOT
C **************
*
5800   IF N CODE-8,  5810, 5820, 5830
C
5810   CALL PLOT(1, CODE(4), CODE(6))
5815   GO TO 1$
C
C
5820   CALL PLOT(1, CODE(4), CODE(6), CODE(8))
       GO TO 5815
C
C
5830   CALL PLOT(1, CODE(4), CODE(6), CODE(8), CODE(10))
       GO TO 5815
*
*
*
C      LINEAR
C ****************
*
5900   CALL LINEAR(CODE(4), CODE(6), CODE(7), CODE(8))
       GO TO 1$
*
C
C
C      RETURN TO MAIN OVERLAY.
C
1$     TERMINATE OVERLAY
C
C
C
10     FORMAT(/$DATA EXCEEDS ABSOLUTE VALUES, PROCESS TERMINATED$)
C
C
       END
       SUBROUTINE LINEAR(COL1,COL2,IRES,IREG)
       GLOBAL NOOFRO,NOOFCO,GFORM,A,B,STATE,DTEMP(200,3),ISYM(3)
       GLOBAL INP OK
       LOGICAL INP OK
       INTEGER STATE
       DIMENSION D(2,2),AMEAN(2),NAME(2)
       INTEGER COL1,COL2,IVAR(2)
       IVAR(1)=COL1
       IVAR(2)=COL2
       IF NOOFRO<3,  TYPE 2000; GO TO 410
       IF NOOFRO>200,TYPE 2000;GO TO 410
C  CALCULATE MEANS & SUMS OF CROSS PRODS OF DEVS
       DO 60 J=1,2
       DO 55 K=1,2
       SUMJ=0.
       SUMK=0.
       SUMP=0.
       DO 50 I=1,NOOFRO
       SUMJ=SUMJ+DATA(I,IVAR(J))
       SUMK=SUMK+DATA(I,IVAR(K))
50     SUMP=SUMP+DATA(I,IVAR(J))*DATA(I,IVAR(K))
55     D(J,K)=SUMP-SUMJ*SUMK/NOOFRO
60     AMEAN(J)=SUMJ/NOOFRO
C  CALCULATE OTHER STATISTICS
       B=D(1,2)/D(1,1)
       A=AMEAN(2)-B*AMEAN(1)
       IF(D(1,1)*D(2,2).EQ.0)R=1;GO TO 6200
       R=SQRT(D(1,2)*D(1,2)/(D(1,1)*D(2,2)))
6200   SSAR=R*R*D(2,2)
       SSDR=D(2,2)-SSAR
       N1=NOOFRO-1
       N2=NOOFRO-2
       S=SSDR/N2
       SE=SQRT(S)
       SB=SQRT(S/D(1,1))
       DN1=D(2,2)/N1
       IF(SSDR)61,62,61
61     F=SSAR/S
       T=B/SB
62     CONTINUE
C  PRINT RESULTS
65     WRITE (-2,1005)
       WRITE (-2,1030)
       GFORM=.5
       CALL GTYPE(A)
       WRITE (-2,1035)
       CALL GTYPE(B)
       WRITE (-2,1040)
       GFORM=.3
       CALL GTYPE(SB)
       IF(SSDR)66,67,66
66     WRITE (-2,1045)
       CALL GTYPE(T)
67     WRITE (-2,1050)
       CALL GTYPE(R)
       WRITE (-2,1055)
       CALL GTYPE(SE)
       WRITE (-2,1060)
       IF(SSDR)68,69,68
68     WRITE (-2,1061)
69     WRITE (-2,1063)
       GFORM=3.3
       DO 70 I=1,2
70     CALL GTYPE(SSAR)
       IF(SSDR)701,702,701
701    CALL GTYPE(F)
702    WRITE (-2,1070) N2
       CALL GTYPE(SSDR)
       CALL GTYPE(S)
       WRITE (-2,1075) N1
       CALL GTYPE(D(2,2))
       CALL GTYPE(DN1)
       WRITE (-2,1005)
C  ASK IF TABLE OF RESIDUALS
       DO 72 I=1,NOOFRO
       DTEMP(I,1)=A+B*DATA(I,IVAR(1))
       DTEMP(I,2)=DATA(I,IVAR(2))-DTEMP(I,1)
       IF(IRES.NE.0) CALL STORE(I,IRES,DTEMP(I,2))
72     IF(IREG.NE.0) CALL STORE(I,IREG,0.0)
       IF(IREG.NE.0) CALL STORE(1,IREG,A), STORE(2,IREG,B)
       WRITE(-2,1080)
       IF(IANS(IDUM))100,7706,7706
7706   WRITE (-2,1085)
       IF(SE)76,80,76
76     WRITE (-2, 1087)
       DO 78 I=1,NOOFRO
78     DTEMP(I,3)=DTEMP(I,2)/SE
       K=3
       GO TO 85
80     K=2
85     DO 90 I=1,NOOFRO
       WRITE (-2,1000)
       CALL GTYPE(DATA(I,IVAR(2)))
       DO 90 J=1,K
90     CALL GTYPE(DTEMP(I,J))
       CLOSE(2)
       WRITE (-2,1005)
C  PLOT
100    WRITE (-2,1090)
       IF(IANS(IDUM))500,7707,7707
7707   DO 105 I=1,NOOFRO
105    DTEMP(I,2)=DATA(I,IVAR(2))
       ISYM(1)=1HR
       ISYM(2)=1HO
       CALL PLOT(2,IVAR(1),IVAR(1),IVAR(2))
       GO TO 500
410    STATE=2
       GO TO 900
500    STATE=1
       IF(IREG.NE.0.OR.IRES.NE.0)INP OK=.FALSE.
900    RETURN
1000   FORMAT()
1005   FORMAT(//)
1030   FORMAT(15X$INTERCEPT =$,Z)
1035   FORMAT(/2X$REGRESSION COEFFICIENT =$,Z)
1040   FORMAT(//$STD. ERROR OF REG. COEF. =$,Z)
1045   FORMAT(/8X$COMPUTED T-VALUE =$,Z)
1050   FORMAT(//1X$CORRELATION COEFFICIENT =$,Z)
1055   FORMAT(/2X$STD. ERROR OF ESTIMATE =$,Z)
1060   FORMAT(//17X$ANALYSIS OF VARIANCE FOR THE REGRESSION$//3X$SOURCE
 OF VARIATION$8X$D.F.  SUM OF SQ.    MEAN SQ.$,Z)
1061   FORMAT($    F VALUE$,Z)
1063   FORMAT(/$ATTRIBUTABLE TO REGRESSION$6X$1$,Z)
1070   FORMAT(/,Z,$DEVIATION FROM REGRESSION$I8)
1075   FORMAT(/,Z,5X$TOTAL$15XI8)
1080   FORMAT(//$PRINT TABLE OF RESIDUALS$,Z)
1085   FORMAT(///$  Y OBSERVED  Y ESTIMATED   RESIDUAL$,Z)
1087   FORMAT($  STD.RESIDUAL$)
1090   FORMAT(/$PLOT Y OBSERVED AND REGRESSION LINE$,Z)
2000   FORMAT(/'3<=NUMBER OF ROWS<=200 FOR LINEAR REGRESSION.'/)
       END
       SUBROUTINE DESCRIPT(JCOL)
       GLOBAL NOOFCO,STATE,NOOFRO,DTEMP(200,3),GFORM
       INTEGER STATE
       COMMON /TEMP/,TEMP(200)
       STATE=1
       IF NOOFRO<2, TYPE 1150; STATE=2; RETURN
       IF NOOFRO>200,TYPE 1150;STATE=2;RETURN
50     GFORM=.3
       SUM=0.
       SUM1=0.
       DO 80 I=1,NOOFRO
       SUM=SUM+DATA(I,JCOL)
80     SUM1=SUM1+DATA(I,JCOL)*DATA(I,JCOL)
       AMEAN=SUM/NOOFRO
       V=(SUM1-SUM*SUM/NOOFRO)/(NOOFRO-1)
       STDEV=SQRT(V)
100    WRITE (-2,1010)
       CALL GTYPE(AMEAN)
       WRITE (-2,1015)
       CALL GTYPE(V)
       WRITE (-2,1020)
       WRITE (-2,1022)
       CALL GTYPE(STDEV)
       WRITE (-2,1025)
       CALL GTYPE(STDEV/SQRT(NOOFRO))
       IF(ABS(AMEAN)-1E-9)110,7709,7709
7709   WRITE (-2,1030)
       CALL GTYPE(STDEV/AMEAN)
C  SORT DATA, FIND ORDER STATISTICS
110    DO 115 I=1,NOOFRO
115    TEMP(I)=DATA(I,JCOL)
       DO 150 J=NOOFRO-1,1,-1
       DO 140 I=1,J
       IF(TEMP(I)-TEMP(I+1))140,140,7710
7710   T=TEMP(I)
       TEMP(I)=TEMP(I+1)
       TEMP(I+1)=T
       IK=-1
140    CONTINUE
       IF(IK)150,200,150
150    IK=0
200    P10=PERC(10)
       P25=PERC(25)
       AMED=PERC(50)
       P75=PERC(75)
       P90=PERC(90)
       I=3H1ST
       IK=3H3RD
       J=1H9
       WRITE (-2,1035)
       CALL GTYPE(TEMP(1))
       WRITE (-2,1042) I
       CALL GTYPE(P10)
       WRITE (-2,1045) I
       CALL GTYPE(P25)
       WRITE (-2,1050)
       CALL GTYPE(AMED)
       WRITE (-2,1045) IK
       CALL GTYPE(P75)
       WRITE (-2,1042) J
       CALL GTYPE(P90)
       WRITE (-2,1065)
       CALL GTYPE(TEMP(NOOFRO))
       WRITE (-2,1070)
       CALL GTYPE(TEMP(NOOFRO)-TEMP(1))
       WRITE (-2,1075)
       CALL GTYPE(P90-P10)
       WRITE (-2,1080)
       WRITE (-2,1022)
       CALL GTYPE(.5*(P75-P25))
       SUM=0.
       SUM1=0.
       DO 220 I=1,NOOFRO
       D=DATA(I,JCOL)-AMEAN
       SUM=SUM+ABS(D)
220    SUM1=SUM1+D*D*D
230    WRITE (-2,1085)
       WRITE (-2,1022)
       CALL GTYPE(SUM/NOOFRO)
       IF(STDEV)235,250,235
235    WRITE (-2,1090)
       WRITE (-2,1100)
       CALL GTYPE((SUM1/NOOFRO)/STDEV**3)
       WRITE (-2,1095)
       WRITE (-2,1100)
       CALL GTYPE(3*(AMEAN-AMED)/STDEV)
250    WRITE (-2,3000)
C  ASK ABOUT ORDERED ARRAY, DEVS FROM MEAN & STD VALUES
       IK=0
300    WRITE (-2,1110)
       IF(IANS(IDUM))305,7713,7713
7713   IK=1
       GO TO 315
305    DO 310 I=1,NOOFRO
310    TEMP(I)=DATA(I,JCOL)
315    CONTINUE
7714   DO 320 I=1,NOOFRO
320    DTEMP(I,1)=TEMP(I)-AMEAN
       WRITE (-2,1115)
       IF(IANS(IDUM))325,7715,7715
7715   IK=2
325    IF(STDEV)330,340,330
330    WRITE (-2,1120)
       IF(IANS(IDUM))340,7716,7716
7716   DO 335 I=1,NOOFRO
335    DTEMP(I,2)=DTEMP(I,1)/STDEV
       IK=IK/2+3
       GO TO 345
340    IF(IK)345,395,345
345    WRITE (-2,3000)
       WRITE (-2,1125)
       GO TO (365,350,360,355)IK
350    WRITE (-2,1130)
       GO TO 365
355    WRITE (-2,1130)
360    WRITE (-2,1135)
365    GFORM=3.3
       WRITE(-2,13500)
13500  FORMAT(/)
       DO 380 I=1,NOOFRO
       WRITE (-2,1140)
       CALL GTYPE(TEMP(I))
       GO TO(380,370,370,375)IK
370    CALL GTYPE(DTEMP(I,IK-1))
       GO TO 380
375    DO 377 J=1,2
377    CALL GTYPE(DTEMP(I,J))
380    CONTINUE
395    CONTINUE
900    WRITE(-2,3000)
       STATE=1
       RETURN
1000   FORMAT(/$COLUMN #: $Z)
1010   FORMAT(///15X$MEAN =$,Z)
1015   FORMAT(/11X$VARIANCE =$,Z)
1020   FORMAT(/$ STANDARD$,Z)
1022   FORMAT($ DEVIATION =$,Z)
1025   FORMAT(/5X$STANDARD ERROR =$,Z)
1030   FORMAT(/$COEFF. OF VARIATION =$,Z)
1035   FORMAT(//8X$MINIMUM =$,Z)
1042   FORMAT(/A1$0TH PERCENTILE =$,Z)
1045   FORMAT(/3XA3$ QUARTILE =$,Z)
1050   FORMAT(/9X$MEDIAN =$,Z)
1065   FORMAT(/8X$MAXIMUM =$,Z)
1070   FORMAT(//17X$RANGE =$,Z)
1075   FORMAT(/$10-90 PERCENTILE RANGE =$,Z)
1080   FORMAT(/4X$QUARTILE$,Z)
1085   FORMAT(/5X$AVERAGE$,Z)
1090   FORMAT(//$ MOMENT$,Z)
1095   FORMAT(/$PEARSON$,Z)
1100   FORMAT($ COEFF. OF SKEWNESS =$,Z)
3000   FORMAT(//)
1110   FORMAT(/$PRINT ORDERED ARRAY$,Z)
1115   FORMAT($ DEVIATIONS FROM MEAN$,Z)
1120   FORMAT($ STANDARDIZED VALUES$,Z)
1125   FORMAT(5X$ARRAY $,Z)
1130   FORMAT($   DEVIATIONS$,Z)
1135   FORMAT($   STD.VALUES$,Z)
1140   FORMAT()
1150   FORMAT(/'2<=NUMBER OF ROWS<=200 FOR DESCRIPTIVE STATISTICS.'/)
       END
       FUNCTION PERC(I)
       GLOBAL NOOFRO
       COMMON /TEMP/,TEMP(200)
       P=I/100.*(NOOFRO-1.)+1.
       IP=P
       FP=P-IP
       IF(IP-NOOFRO)8,7717,7717
7717   PERC=TEMP(NOOFRO)
       RETURN
8      PERC=FP*TEMP(IP+1)+(1-FP)*TEMP(IP)
       RETURN
       END
       SUBROUTINE PLOT(NN,JCOL,/IVAR(NVAR)/)
C      NN=1 MEANS REGULAR PLOT ANALYSIS
C      NN=2 MEANS CALLED FROM REGRESSION
       GLOBAL ISYM(3),NOOFRO,DTEMP(200,3),LINE(0/60),GFORM,A,B
       GLOBAL NOOFCO,STATE,COLUMNS(2,1)
       INTEGER STATE,COLUMNS
       COMMON /TEMP/,TEMP(200)
       STATE=1
       IF NOOFRO >200,TYPE 1180;STATE=2;RETURN
       IF NN.EQ.2,  GO TO 60
       TYPE 1
1      FORMAT(/'PLOT SYMBOL')
       DO 35 I=1,NVAR
32     TYPE 2
       CALL DISCHR(0)
       CALL DISSYM(COLUMNS(1,IVAR(I)))
       CALL DISCHR(1R:)
       CALL DISCHR(0)
2      FORMAT(' FOR'Z)
       CALL NEWLINE(J)
       IF J<=0,  GO TO 32
35     ISYM(I)=LSH(NOWCHR(0),16)
C  Y AXIS(HORIZONTAL)
53     DO 55 J=1,NVAR
       DO 55 I=1,NOOFRO
55     DTEMP(I,J)=DATA(I,IVAR(J))
60     YMIN=5E76
       YMAX=-5E76
       DO 90 J=1,NVAR
       DO 80 I=1,NOOFRO
       IF(DTEMP(I,J)-YMIN)65,70,70
65     YMIN=DTEMP(I,J)
70     IF(DTEMP(I,J)-YMAX)80,80,7729
7729   YMAX=DTEMP(I,J)
80     CONTINUE
90     CONTINUE
       YINCR=(YMAX-YMIN)/60
C  X AXIS (VERTICAL)
       DO 130 I=1,NOOFRO
130    TEMP(I)=DATA(I,JCOL)
       IF(1-NOOFRO)135,7730,7730
7730   XINCR=22E22
       GO TO 210
135    DO 150 K=NOOFRO-1,1,-1
       DO 140 I=1,K
       IF(TEMP(I)-TEMP(I+1))140,140,7731
7731   S=TEMP(I)
       TEMP(I)=TEMP(I+1)
       TEMP(I+1)=S
       DO 131 J=1,NVAR
       S=DTEMP(I,J)
       DTEMP(I,J)=DTEMP(I+1,J)
131    DTEMP(I+1,J)=S
       IK=-1
140    CONTINUE
       IF(IK)150,200,150
150    IK=0
200    II=1+(NOOFRO-1)/53
       XINCR=II*(TEMP(NOOFRO)-TEMP(1))/(NOOFRO-1)
C  PLOT
210    WRITE (-2,1155)
       GFORM=.3
       DO 350 I=0,60,12
       S=YMIN+I*YINCR
       WRITE (-2,1170)
350    CALL GTYPE(S)
       WRITE (-2,1150)
       WRITE (-2,1160)
       DO 340 I=0,60
340    LINE(I)=0
       J=0
       XVAL=TEMP(1)
       GO TO (353,7732) NN
7732   IK=2
       LINE((A+B*XVAL+.5*YINCR-YMIN)/YINCR)=ISYM(1)
       GO TO 354
353    IK=1
354    DO 370 I=1,NOOFRO
355    IF(XVAL+.5*XINCR-TEMP(I))390,390,7733
7733   DO 360 K=IK,NVAR
360    LINE((DTEMP(I,K)+.5*YINCR-YMIN)/YINCR)=ISYM(K)
370    II=-1
390    CALL GTYPE(XVAL)
       WRITE (-2,1130)
       IF(II)392,410,392
392    DO 395 L=60,0,-1
       IF(LINE(L))400,395,400
395    CONTINUE
400    DO 405 K=0,L
       WRITE (-2,1140) LINE(K)
405    LINE(K)=0
       II=0
410    WRITE (-2,1150)
       J=J+1
       XVAL=TEMP(1)+J*XINCR
       IF(TEMP(NOOFRO)-XVAL)420,7734,7734
7734   GO TO (355,7735) NN
7735   LINE((A+B*XVAL+.5*YINCR-YMIN)/YINCR)=ISYM(1)
       II=-1
       GO TO 355
420    WRITE (-2,1160)
       DO 425 I=0,60,12
       S=YMIN+I*YINCR
       WRITE (-2,1170)
425    CALL GTYPE(S)
       WRITE (-2,1155)
C ASK IF ANY MORE PLOTS
500    CONTINUE
900    RETURN
1130   FORMAT($ .$Z)
1140   FORMAT(Z,61A1)
1150   FORMAT()
1155   FORMAT(//)
1160   FORMAT(11X5($+ . . . . . $)$+$)
1170   FORMAT(3X,Z)
1180   FORMAT(/'NUMBER OF ROWS <=200 FOR PLOT ANALYSIS.'/)
       END
       FUNCTION IANS(IDUM)
       WRITE (-2,900)
       IANS=0
5      CALL NEWLINE(I)
       CALL IPACK(I,1,0)
       IF(I-1HY)10,25,10
10     IF(I-1HN)15,20,15
15     WRITE (-2,1010)
       GO TO 5
20     IANS=-1
25     RETURN
900    FORMAT($? $,Z)
1010   FORMAT($ERROR. TYPE YES OR NO: $,Z)
       END
       SUBROUTINE GTYPE(ARG)
       GLOBAL GFORM
       I=GFORM
       IF(I)10,15,10
C  PRECEDING SPACES
10     DO 12 II=1,I
12     WRITE (-2,1000)
C  EXAMINE NO. OF DEC. PLACES
15     IF(GFORM-I-.5)17,20,17
17     ASSIGN 1005 TO IFORMF
       ASSIGN 1010 TO IFORME
       GO TO 25
20     ASSIGN 1015 TO IFORMF
       ASSIGN 1020 TO IFORME
25     IF(ARG)35,50,35
35     EXP=ALOG(ABS(ARG))/2.302585093
       IF(EXP+1)40,50,7770
7770   IF(EXP-4)50,40,40
40     WRITE (-2,IFORME),ARG
       RETURN
50     WRITE (-2,IFORMF),ARG
       RETURN
1000   FORMAT($ $,Z)
1005   FORMAT(F9.3,Z)
1010   FORMAT(E9.3,Z)
1015   FORMAT(F11.5,Z)
1020   FORMAT(E11.5,Z)
       END

       SUBROUTINE STORE(I,J,X)
       REAL MATRIX
       GLOBAL NO OF COLUMNS,  MATRIX(1)
       MATRIX(J+NO OF COLUMNS*(I-1))=X
       RETURN

       REAL FUNCTION DATA(L,M)
       DATA=MATRIX(M+NO OF COLUMNS*(L-1))
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
STATA2 SYMSORT

SYM.  PG.LN. IDENT.

+       1 25 C:STATA2+       1 12 C:STATA21      10 29 C:STATA210     13 37 C:STATA2
10     13 24 C:STATA2100     6 17 C:STATA2100     5  7 C:STATA21000   14 15 C:STATA2
1000    9 16 C:STATA21000    5 20 C:STATA21005   14 16 C:STATA21005    5 21 C:STATA2
1010   14 17 C:STATA21010   13 30 C:STATA21010    9 17 C:STATA21015   14 18 C:STATA2
1015    9 18 C:STATA21020   14 19 C:STATA21020    9 19 C:STATA21022    9 20 C:STATA2
1025    9 21 C:STATA21030    9 22 C:STATA21030    5 22 C:STATA21035    9 23 C:STATA2
1035    5 23 C:STATA21040    5 24 C:STATA21042    9 24 C:STATA21045    9 25 C:STATA2
1045    5 25 C:STATA2105     5 10 C:STATA21050    9 26 C:STATA21050    5 26 C:STATA2
1055    5 27 C:STATA21060    5 28 C:STATA21061    5 30 C:STATA21063    5 31 C:STATA2
1065    9 27 C:STATA21070    9 28 C:STATA21070    5 32 C:STATA21075    9 29 C:STATA2
1075    5 33 C:STATA21080    9 30 C:STATA21080    5 34 C:STATA21085    9 31 C:STATA2
1085    5 35 C:STATA21087    5 36 C:STATA21090    9 32 C:STATA21090    5 37 C:STATA2
1095    9 33 C:STATA2110     6 30 C:STATA21100    9 34 C:STATA21110    9 36 C:STATA2
1115    9 37 C:STATA21120    9 38 C:STATA21125    9 39 C:STATA21130   13 10 C:STATA2
1130   10  1 C:STATA21135   10  2 C:STATA21140   13 11 C:STATA21140   10  3 C:STATA2
115     6 31 C:STATA21150   13 12 C:STATA21150   10  4 C:STATA21155   13 13 C:STATA2
1160   13 14 C:STATA21170   13 15 C:STATA21180   13 16 C:STATA212     13 38 C:STATA2
130    11 18 C:STATA2131    11 31 C:STATA2135    11 22 C:STATA213500   9  2 C:STATA2
140    11 33 C:STATA2140     6 39 C:STATA215     14  1 C:STATA215     13 25 C:STATA2
150    11 35 C:STATA2150     7  2 C:STATA217     14  2 C:STATA22      10 36 C:STATA2
20     14  5 C:STATA220     13 27 C:STATA2200    11 36 C:STATA2200     7  3 C:STATA2
2000    5 38 C:STATA2210    11 39 C:STATA2220     7 37 C:STATA2230     7 38 C:STATA2
235     8  3 C:STATA225     14  7 C:STATA225     13 28 C:STATA2250     8  9 C:STATA2
300     8 12 C:STATA23000    9 35 C:STATA2305     8 16 C:STATA2310     8 17 C:STATA2
315     8 18 C:STATA232     10 31 C:STATA2320     8 20 C:STATA2325     8 24 C:STATA2
330     8 25 C:STATA2335     8 28 C:STATA2340    12  9 C:STATA2340     8 31 C:STATA2
345     8 32 C:STATA235     14  8 C:STATA235     10 39 C:STATA2350    12  5 C:STATA2
350     8 35 C:STATA2353    12 16 C:STATA2354    12 17 C:STATA2355    12 18 C:STATA2
355     8 37 C:STATA2360    12 20 C:STATA2360     8 38 C:STATA2365     8 39 C:STATA2
370    12 21 C:STATA2370     9  7 C:STATA2375     9  9 C:STATA2377     9 10 C:STATA2
380     9 11 C:STATA2390    12 22 C:STATA2392    12 25 C:STATA2395    12 27 C:STATA2
395     9 12 C:STATA240     14 11 C:STATA2400    12 28 C:STATA2405    12 30 C:STATA2
410    12 32 C:STATA2410     5 15 C:STATA2420    13  1 C:STATA2425    13  5 C:STATA2
5      13 21 C:STATA250     14 13 C:STATA250      6  8 C:STATA250      3  7 C:STATA2
500    13  8 C:STATA2500     5 17 C:STATA253     11  2 C:STATA255     11  4 C:STATA2
55      3  8 C:STATA25700    1 37 C:STATA25800    2  6 C:STATA25815    2  8 C:STATA2
5900    2 19 C:STATA260     11  5 C:STATA260      3  9 C:STATA261      3 24 C:STATA2
62      3 26 C:STATA26200    3 15 C:STATA265     11 10 C:STATA265      3 28 C:STATA2
66      3 38 C:STATA267      4  1 C:STATA268      4  7 C:STATA269      4  8 C:STATA2
70     11 11 C:STATA270      4 11 C:STATA2701     4 13 C:STATA2702     4 14 C:STATA2
72      4 26 C:STATA276      4 32 C:STATA27706    4 30 C:STATA27707    5  9 C:STATA2
7709    6 27 C:STATA27710    6 35 C:STATA27713    8 14 C:STATA27714    8 19 C:STATA2
7715    8 23 C:STATA27716    8 27 C:STATA27717   10 13 C:STATA27729   11 12 C:STATA2
7730   11 20 C:STATA27731   11 25 C:STATA27732   12 13 C:STATA27733   12 19 C:STATA2
7734   12 36 C:STATA27735   12 37 C:STATA27770   14 10 C:STATA278      4 34 C:STATA2
8      10 15 C:STATA280     11 13 C:STATA280      6 13 C:STATA280      4 37 C:STATA2
85      4 38 C:STATA290     11 14 C:STATA290      5  3 C:STATA2900    13 29 C:STATA2
900    13  9 C:STATA2900     9 13 C:STATA2900     5 19 C:STATA2
C      13 39 C:STATA2C      13 36 C:STATA2C      13  7 C:STATA2C      11 38 C:STATA2
C      11 16 C:STATA2C      11  1 C:STATA2C      10 20 C:STATA2C      10 19 C:STATA2
C       8 10 C:STATA2C       6 29 C:STATA2C       5  6 C:STATA2C       4 21 C:STATA2
C       3 27 C:STATA2C       3 10 C:STATA2C       2 37 C:STATA2C       2 17 C:STATA2
C       2 16 C:STATA2C       2  4 C:STATA2C       2  3 C:STATA2C       1 35 C:STATA2
CM      1 16 C:STATA2CM      1 10 C:STATA2CM      1  9 C:STATA2CM      1  7 C:STATA2
CM      1  3 C:STATA2CM*M*M  1 34 C:STATA2CM1$    2 23 C:STATA2CM5810  2  7 C:STATA2
CMCM    2 25 C:STATA2CMCM    1 33 C:STATA2CMCM    1 31 C:STATA2CMCM    1  4 C:STATA2
CMCM    1  2 C:STATA2CMCM58  2 11 C:STATA2CMCM58  2  9 C:STATA2CMCMC   2 22 C:STATA2
CMCMCM  2 24 C:STATA2CMCMCM  1 32 C:STATA2L      14 22 C:STATA2L      13 32 C:STATA2
L      13 18 C:STATA2L      10 18 C:STATA2L      10  6 C:STATA2L       6  1 C:STATA2
L       2 26 C:STATA2
STATFIN ** FICHE/FRAME BREAK *****
STATA3
C:STATA3   07/03/72            STATPAK ANALYSIS OVERLAY THREE.
C
C
       OVERLAY STATA3,4
C
       NORMAL MODE IS INTEGER
C
C
       LOGICAL TALK,HUSH,ECHO,TTY
       INTEGER COM NO
       COMMON /SFE/TALK,HUSH,ECHO,TTY,COM NO
C
       INTEGER INPUT LINE(256), I SAVE(6)
       COMMON /LINE INPUT/INPUT LINE, I SAVE, I POINT, I COUNT, INDEX
C
       COMMON /CODE/MAX CODE, N CODE, CODE(200)
C
       LOGICAL FILE INPUT,  DATA IN,  INP OK,  APP OK
       LOGICAL NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC
       LOGICAL BACK UP
       LOGICAL FLAG 1,  FLAG 2
       REAL TAX,  MATRIX
C
       SHARE MATRIX(2048)
       SHARE $FILES,  /SFE/,  /LINE INPUT/
       SHARE /CODE/
       SHARE NAME(18)
       SHARE BEGIN(9),  IN FLOW,  OUT FLOW,  TAX COLUMN,  TAX
       SHARE TAX FREQUENCY
       SHARE TITLE(2),  CPL,  C COUNT,  FLAG 1(90),  FLAG 2(9)
       SHARE FILE INPUT,  DATA IN,  INP OK,  APP OK,  STATE
       SHARE NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC,  NO OF CASES
       SHARE P COLUMNS,  P ROWS,  MAX NAMES,  BACK UP
       SHARE NAMES(423),  NO OF COLUMNS,  NO OF ROWS
       SHARE NO OF PERIODS,  COLUMNS(2,208),  ROWS(2,-2:-1)
       SHARE OVERFLOW(27)
       SHARE CRAP(500)
C
C
       GLOBAL ICOL(200),  ILOOP
C
C
       CONNECT OVERFLOW, TYPE OVERFLOW;  STATE=2;  GO TO 1$
C
C
C
       IF CODE(2)-66,  6500, 6600, 6700
*
*
*
C      KENDALL
C *****************
*
6500   ILOOP=0
       DO 6510 I=4, N CODE, 2
6510   ICOL(ILOOP=ILOOP+1)=CODE(I)
C
C
       CALL KENDALL
       GO TO 1$
*
*
*
C      SPEARMAN
C ******************
*
6600   ICOL(1)=CODE(4)
       ICOL(2)=CODE(6)
C
C
       CALL SPEARMAN
       GO TO 1$
*
*
*
C      CONFIDENCE
C ********************
*
6700   CALL CONFIDENCE(CODE(4))
       GO TO 1$
*
C
C
C
C      RETURN TO MAIN OVERLAY
C
1$     TERMINATE OVERLAY
C
C
       END
       SUBROUTINE KENDALL
       INTEGER STATE,COLUMNS
       GLOBAL NOOFCO,NOOFRO,ICOL(1),STATE,COLUMNS(2,1),ILOOP
       TT=0
       RBAR=ILOOP*(NOOFRO+1)/2.
       IPRI=0
       DO 350 I=1,ILOOP
C CHECK FOR TIES IN COLUMN
       CALL CHKTIE(ICOL(I),NOOFRO,T)
C CHECK TO MAKE SURE ALL COLUMNS ADD UP TO RBAR
       IF(CHKCOL(NOOFRO,ICOL(I)).EQ.1)GO TO 350
       IF(IPRI.EQ.1)GO TO 355
       IPRI=1
       STATE=2
       TYPE 354$
354$   FORMAT(/$THE FOLLOWING COLUMNS ARE NOT RANKED PROPERLY:$/)
355    CALL OUTSYM(1,COLUMNS(1,ICOL(I)))
       TYPE 356
356    FORMAT()
350    TT=TT+T
       IF(IPRI.EQ.1) GO TO 400
C CALCULATE KENDALL
       S=0
       DO 370 I=1,NOOFRO
       Y=0
       DO 380 J=1,ILOOP
380    Y=DATA(I,ICOL(J))+Y
       S=S+(Y-RBAR)**2
370    CONTINUE
       W=S/(((ILOOP**2)*(NOOFRO**3-NOOFRO)/12.)-ILOOP*TT)
       CHISQ=ILOOP*(NOOFRO-1)*W
       IDF=NOOFRO-1
       WRITE (-2,375) W
       IF NOOFRO>7,  WRITE (-2,395) CHISQ,IDF
       STATE=1
400    RETURN
375    FORMAT(/$KENDALL COEFFICIENT OF CONCORDANCE: $F.3)
395    FORMAT($CHI-SQUARE: $F.3,1X,1H(,I,$ DEGREES OF FREEDOM)$)
       SUBROUTINE SPEARMAN
       IPRI=0
       DO 420 I=1,2
       IF(CHKCOL(NOOFRO,ICOL(I)).EQ.1)GO TO 420
       IF(IPRI.EQ.1)GO TO 410
       IPRI=1
       STATE=2
       TYPE 354$
410    CALL OUTSYM(1,COLUMNS(1,ICOL(I)))
       TYPE 456
456    FORMAT()
420    CONTINUE
       IF(IPRI.EQ.1)  GO TO 500
       D=0
       DO 430 I=1,NOOFRO
430    D=D+(DATA(I,ICOL(1))-DATA(I,ICOL(2)))**2
       TA=TB=0
       CALL CHKTIE(ICOL(1),NOOFRO,T)
       TA=T
       CALL CHKTIE(ICOL(2),NOOFRO,T)
       TB=T
       NRD=NOOFRO**3-NOOFRO
       IF(TA+TB.NE.0)GO TO 440
       R=1.-6.*D/NRD
       GO TO 480
440    X=NRD/12.-TA
       Y=NRD/12.-TB
       R=(X+Y-D)/(2.*SQRT(X*Y))
480    IF(R.EQ.1.)GO TO 490
       T=R*SQRT((NOOFRO-2)/(1-R**2))
       IDF=NOOFRO-2
       WRITE (-2,485) R,T,IDF
       GO TO 498
485    FORMAT(/$SPEARMAN RANK CORRELATION: $F.3/
+              $STUDENTS T: $F.3,1X,1H(,I,$ DEGREES OF FREEDOM)$/)
490    WRITE (-2,495) R
495    FORMAT(/$SPEARMAN RANK CORRELATION: $F.3/)
498    STATE=1
500    RETURN
       END
       FUNCTION CHKCOL(NR,NUMCOL)
       TOT=0
       CT=NR*(NR+1)/2
       DO 100 K=1,NR
100    TOT=TOT+DATA(K,NUMCOL)
       IF(ABS(TOT-CT).GT..1)GO TO 200
       CHKCOL=1
       RETURN
200    CHKCOL=2
       RETURN
       END
       SUBROUTINE CHKTIE(NUMCOL,NOOFRO,T)
       Y=0
       T=0.
4      X=100.
       IND=0
       DO 40 K=1,NOOFRO
       IF(DATA(K,NUMCOL)-Y)40,40,10
10     IF(DATA(K,NUMCOL)-X)20,40,40
20     X=DATA(K,NUMCOL)
       IND=IND+1
40     CONTINUE
       IF(IND)200,200,50
50     Y=X
       TIE=0.
       DO 90 K=1,NOOFRO
       IF(DATA(K,NUMCOL)-X)90,60,90
60     TIE=TIE+1.
90     CONTINUE
       IF(TIE.EQ.1)TIE=0.
       IF(TIE)4,4,120
120    T=T+(TIE**3-TIE)/12.0
       GO TO 4
200    RETURN
       END
       SUBROUTINE CONFIDENCE(ICL)
       INTEGER STATE
       GLOBAL STATE,NOOFRO
       SDV=FMEAN=0
       DO 670 I=1,NOOFRO
670    FMEAN=FMEAN+DATA(I,ICL)
       FMEAN=FMEAN/NOOFRO
       DO 680 I=1,NOOFRO
680    SDV=SDV+(FMEAN-DATA(I,ICL))**2
       SDV=SQRT((SDV)/(NOOFRO-1))
       SE=SDV/SQRT(NOOFRO)
       WRITE (-2,703) FMEAN,SDV,SE
703    FORMAT(/$MEAN: $1PG13.6/$STANDARD DEVIATION: $1PG13.6/
+              $STANDARD ERROR OF MEAN: $1PG13.6)
700    WRITE (-2,701)
701    FORMAT(/Z$ONE-SIDED OR TWO-SIDED TEST: $)
702    CALL NEWLINE(NCH)
       IF NCH<=0,  GO TO 700
709    IANS=NOWCHR(0)
       IF(IANS.NE.1RO.AND.IANS.NE.1RT)GO TO 700
       IF(IANS.EQ.1RO)ISIDE=1
       IF(IANS.EQ.1RT)ISIDE=2
690    WRITE (-2,689)
689    FORMAT(/Z$CONFIDENCE LEVEL(S) (%): $)
691    CALL NEWLINE(NCH)
       IF(NCH)691,690,694
692    IF(KOMMA(0))694,693,694
693    STATE=1
5      RETURN
694    IF(NUMBER(CONLEV))6945,690,695
6945   ICV=ICV+1
       TYPE 688
688    FORMAT(/$NON-NUMERIC FOUND$)
698    WRITE (-2,699) ICV
699    FORMAT(/Z$RE-ENTER VALUES FROM ENTRY $I,2H: )
       ICV=0
       CALL NEWLINE(NCH)
       IF(NCH)698,698,694
695    CONLEV=CONLEV/100.
       ICV=ICV+1
       TCONLEV=CONLEV
       IF(CONLEV.LE.0)  TYPE 1;  GO TO 698
1      FORMAT(/$CONFIDENCE LEVEL MUST BE POSITIVE$)
       IF(ISIDE.EQ.1)GO TO 730
       TCONLEV=(CONLEV+1.)/2.
       IF(TCONLEV.LT..6.OR.TCONLEV.GE.1) TYPE 2;  GO TO 698
2      FORMAT(/$CONFIDENCE LEVEL FOR TWO-SIDED TEST MUST BE = OR$
+              /$> 20% AND < 100%$)
       GO TO 710
730    IF(TCONLEV.LT..6.OR.TCONLEV.GE.1)  TYPE 3;  GO TO 698
3      FORMAT(/$CONFIDENCE LEVEL FOR ONE-SIDED TEST MUST BE = OR$/
+              $> 60% AND < 100%$)
710    T=TCALC(TCONLEV,NOOFRO-1,JCT)
       BL=FMEAN-T*SE
       BU=FMEAN+T*SE
       WRITE (-2,711) CONLEV
711    FORMAT(//Z$CONFIDENCE LEVEL $2PF.2,2H%,)
       IF(ISIDE.EQ.1)GO TO 740
       WRITE (-2,712)
712    FORMAT($ TWO-SIDED TEST$)
       GO TO 750
740    WRITE (-2,741)
       741    FORMAT($ ONE-SIDED TEST$)
750    WRITE (-2,751) BL,BU
751    FORMAT($LOWER BOUND: $1PG13.6/$UPPER BOUND: $1PG13.6)
       GO TO 692
       END
       FUNCTION TCALC(TCONLEV,IDF,IX)
       IX=0
       T1=1.
       T2=3.
       TLOOK=(1.-TCONLEV)*2.
       F0=TLOOK
       CALL TTEST(T1,IDF,F1,II)
       CALL TTEST(T2,IDF,F2,II)
1      T0=T1+((F0-F1)/(F2-F1))*(T2-T1)
       IX=IX+1
       CALL TTEST(T0,IDF,FOP,II)
       IF(ABS(FOP-F0).LT..000001)TCALC=T0;RETURN
       IF(FOP.GT.F0)F1=FOP;T1=T0;GO TO 1
       IF(FOP.LT.F0)F2=FOP;T2=T0;GO TO 1
       END
       SUBROUTINE TTEST(T,NDF,ANS,KERR)
       D1=.636619772368
       KERR=0
       IF(NDF)10,10,1
10     KERR=1
       ANS=0
       RETURN
1      T=ABS(T)
       T1=T/SQRT(FLOAT(NDF))
       T2=1./(1.+T1**2)
       IF((NDF/2)*2-NDF)50,5,50
50     ANS=1.-D1*ATAN(T1,1.)
       IF(NDF-1)40,4,40
40     D2=D1*T1*T2
       ANS=ANS-D2
       IF(NDF-3)400,4,400
400    F1=0.
2      N=(NDF-2)/2
       DO 3 I=1,N
       F2=2*FLOAT(I)-F1
       D2=D2*T2*F2/(F2+1.)
3      ANS=ANS-D2
4      IF(ANS)60,70,70
60     ANS=0.
70     RETURN
5      D2=T1*SQRT(T2)
       ANS=1.-D2
       IF(NDF-2)80,4,80
80     F1=1.
       GO TO 2
       END
       SUBROUTINE STORE(I,J,X)
       REAL MATRIX
       GLOBAL NO OF COLUMNS,  MATRIX(1)
       MATRIX(J+NO OF COLUMNS*(I-1))=X
       RETURN

       REAL FUNCTION DATA(L,M)
       DATA=MATRIX(M+NO OF COLUMNS*(L-1))
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
STATA3 SYMSORT

SYM.  PG.LN. IDENT.

+       6 36 C:STATA3+       6 32 C:STATA3+       5 37 C:STATA3+       4 22 C:STATA3
+       1 25 C:STATA3+       1 12 C:STATA31       7 35 C:STATA31       7 21 C:STATA3
1       6 27 C:STATA310      7 32 C:STATA310      5  7 C:STATA3100     4 32 C:STATA3
120     5 20 C:STATA32       8  6 C:STATA32       6 31 C:STATA320      5  8 C:STATA3
200     5 22 C:STATA3200     4 36 C:STATA33       8 10 C:STATA33       6 35 C:STATA3
350     3  8 C:STATA3354$    3  4 C:STATA3355     3  5 C:STATA3356     3  7 C:STATA3
370     3 17 C:STATA3375     3 25 C:STATA3380     3 15 C:STATA3395     3 26 C:STATA3
4       8 11 C:STATA34       5  3 C:STATA340      8  2 C:STATA340      5 10 C:STATA3
400     8  5 C:STATA3400     3 24 C:STATA3410     3 35 C:STATA3420     3 38 C:STATA3
430     4  3 C:STATA3440     4 13 C:STATA3456     3 37 C:STATA3480     4 16 C:STATA3
485     4 21 C:STATA3490     4 23 C:STATA3495     4 24 C:STATA3498     4 25 C:STATA3
5       8 14 C:STATA35       6 13 C:STATA350      7 39 C:STATA350      5 12 C:STATA3
500     4 26 C:STATA360      8 12 C:STATA360      5 16 C:STATA36500    2  1 C:STATA3
6510    2  3 C:STATA36600    2 12 C:STATA3670     5 29 C:STATA36700    2 22 C:STATA3
680     5 32 C:STATA3688     6 17 C:STATA3689     6  8 C:STATA3690     6  7 C:STATA3
691     6  9 C:STATA3692     6 11 C:STATA3693     6 12 C:STATA3694     6 14 C:STATA3
6945    6 15 C:STATA3695     6 23 C:STATA3698     6 18 C:STATA3699     6 19 C:STATA3
70      8 13 C:STATA3700     5 38 C:STATA3701     5 39 C:STATA3702     6  1 C:STATA3
703     5 36 C:STATA3709     6  3 C:STATA3710     6 37 C:STATA3711     7  2 C:STATA3
712     7  5 C:STATA3730     6 34 C:STATA3740     7  7 C:STATA3750     7  9 C:STATA3
751     7 10 C:STATA380      8 17 C:STATA390      5 17 C:STATA3
C       3 10 C:STATA3C       2 37 C:STATA3C       2 35 C:STATA3C       2 20 C:STATA3
C       2 19 C:STATA3C       2 10 C:STATA3C       2  9 C:STATA3C       1 38 C:STATA3
C       1 37 C:STATA3CM      1 16 C:STATA3CM      1 10 C:STATA3CM      1  9 C:STATA3
CM      1  7 C:STATA3CM      1  3 C:STATA3CM1$    2 26 C:STATA3CMCM    2 27 C:STATA3
CMCM    2 14 C:STATA3CMCM    2  4 C:STATA3CMCM    1 32 C:STATA3CMCM    1 31 C:STATA3
CMCM    1  4 C:STATA3CMCM    1  2 C:STATA3CMCMCM  2 25 C:STATA3CMCMCM  1 33 C:STATA3
L       8 20 C:STATA3L       7 28 C:STATA3L       7 13 C:STATA3L       5 24 C:STATA3
L       4 39 C:STATA3L       4 28 C:STATA3L       3 27 C:STATA3L       2 28 C:STATA3

STATFIN ** FICHE/FRAME BREAK *****
STATA4
C:STATA4   08/30/72            STATPAK ANALYSIS OVERLAY FOUR.
C
C
       OVERLAY STATA4,4
C
       NORMAL MODE IS INTEGER
C
C
       LOGICAL TALK,HUSH,ECHO,TTY
       INTEGER COM NO
       COMMON /SFE/TALK,HUSH,ECHO,TTY,COM NO
C
       INTEGER INPUT LINE(256), I SAVE(6)
       COMMON /LINE INPUT/INPUT LINE, I SAVE, I POINT, I COUNT, INDEX
C
       COMMON /CODE/MAX CODE, N CODE, CODE(200)
C
       LOGICAL FILE INPUT,  DATA IN,  INP OK,  APP OK
       LOGICAL NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC
       LOGICAL BACK UP
       LOGICAL FLAG 1,  FLAG 2
       REAL TAX,  MATRIX
C
       SHARE MATRIX(2048)
       SHARE $FILES,  /SFE/,  /LINE INPUT/
       SHARE /CODE/
       SHARE NAME(18)
       SHARE BEGIN(9),  IN FLOW,  OUT FLOW,  TAX COLUMN,  TAX
       SHARE TAX FREQUENCY
       SHARE TITLE(2),  CPL,  C COUNT,  FLAG 1(90),  FLAG 2(9)
       SHARE FILE INPUT,  DATA IN,  INP OK,  APP OK,  STATE
       SHARE NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC,  NO OF CASES
       SHARE P COLUMNS,  P ROWS,  MAX NAMES,  BACK UP
       SHARE NAMES(423),  NO OF COLUMNS,  NO OF ROWS
       SHARE NO OF PERIODS,  COLUMNS(2,208),  ROWS(2,-2:-1)
       SHARE OVERFLOW(27)
       SHARE CRAP(500)
C
C
C
C
       CONNECT OVERFLOW,  TYPE OVERFLOW;  STATE=2;  GO TO 1$
*
*
*
C      POLYNOMIAL
C ********************
*
6200   CALL POLYNOMIAL(CODE(6), CODE(4), CODE(8), CODE(9), CODE(10))
       GO TO 1$
*
C
C
C
C      RETURN TO MAIN OVERLAY
C
1$     TERMINATE OVERLAY
C
C
       END
       SUBROUTINE POLYNOM(IY,IX,IW,IRES,IREG)
       LOGICAL INP OK
       INTEGER SYMOUT(2)
       DATA SYMOUT/'SYMOUT'/
       INTEGER STATE
       GLOBAL NOOFRO,NOOFCO,STATE,INP OK
       DIMENSION COF(16),CO(136),FC(16)
       IFLAG=0
1      FORMAT(/Z$DEGREE OF POLYNOMIAL: $)
1000   WRITE(-2,1)
1001   CALL NEWLINE(NCH)
       IF(NCH)1001,1000,1005
1005   IF(NUMBER(X))1000,1000,1010
1010   IDEG=INT(X)
       IF(IDEG.LT.1.OR.IDEG.GT.15) TYPE '(/$DEGREE MUST BE BETWEEN 1
+AND 15$/)';GO TO 1000
       IF(IDEG.GE.NOOFRO)TYPE '(/$DEGREE MUST BE LESS THAN NUMBER OF
+ROWS$/)';GO TO 1000
C INITIALIZE COEFFICIENTS OF ALL ORTHONORMAL FUNCTIONS
1014    DO 1015 I=1,136
1015   CO(I)=0.
C      CALCULATE COEFFICIENT OF X**0 ORTHONORMAL FUNCTION
       FX=0
       IF(IW.EQ.0)C11=FLOAT(NOOFRO);GO TO 1020
       C11=0
       DO 1020 I=1,NOOFRO
       C11=C11+DATA(I,IW)
1020   CONTINUE
       C11=1/SQRT(C11)
       CO(1)=C11
C MAIN DO LOOP
       DO 1070 N=2,IDEG+1
C CALCULATE FXFX
       FXFX=0
       DO 1025 LL=1,NOOFRO
       VAL=DATA(LL,IX)**(2*(N-1))
       IF(IW.NE.0)VAL=VAL*DATA(LL,IW)
       FXFX=FXFX+VAL
1025   CONTINUE
       DK=FXFX
C CALCULATE DK
       DO 1035 I=1,N-1
       VAL=0
C CALCULATE EACH (FK,PHIK)
       DO 1030 J=1,NOOFRO
       DO 1030 K=1,I
       IF(K.EQ.1)TVAL=DATA(J,IX)**(N-1)*REDUC(I,K,CO);GO TO 1029
       TVAL=DATA(J,IX)**(N-1)*REDUC(I,K,CO)*DATA(J,IX)**(K-1)
1029   IF(IW.NE.0)TVAL=TVAL*DATA(J,IW)
1030   VAL=VAL+TVAL
       FC(I)=VAL
       DK=DK-VAL**2
1035   CONTINUE
       IB=1
       IC=0
       DK=SQRT(DK)
       CKK=1/DK
C CALCULATE COEFFICIENTS OF PHI
       DO 1050 I=1,N-1
       IK=0
C FIND CO INDEX AREA OF LAST DEGREE
       DO 1037 II=1,N
1037   IK=IK+II
       VAL=0
       VAL=-FC(I)/DK
C CALCULATE PHIS
       DO 1045 IG=IB,IB+I-1
       IC=IC+1
       CO(IK-N+IC)=CO(IK-N+IC)+VAL*CO(IG)
1045   CONTINUE
       CO(IK)=CKK
       IC=0
       IB=IG
1050   CONTINUE
1070   CONTINUE
       DO 1075 I=1,16
1075   COF(I)=0.
C CALCULATE COEFFICIENTS FOR PHIS, THEN MULTIPLY BY THEM
       IK=0
       DO 1100 I=1,IDEG+1
       AM=0
       DO 1094 J=1,NOOFRO
       Z=0
       DO 1090 K=1,I
       IF(K.EQ.1)TVAL=REDUC(I,K,CO);GO TO 1089
       TVAL=REDUC(I,K,CO)*(DATA(J,IX)**(K-1))
1089   Z=Z+TVAL
1090   CONTINUE
       AM=AM+Z*DATA(J,IY)
       IF(IW.NE.0)AM=AM+Z*DATA(J,IY)*(DATA(J,IW)-1)
       Z=0
1094   CONTINUE
       IK=IK+I
       DO 1095 L=1,I
1095   CO(IK-I+L)=CO(IK-I+L)*AM
1100   CONTINUE
       IK=0
C ADD UP ALL COEFFICIENTS
       DO 1110 I=1,IDEG+1
       DO 1110 J=I,IDEG+1
1110   COF(I)=COF(I)+REDUC(J,I,CO)
       IF IFLAG.EQ.0,  WRITE (-2,'(/$POWER OF X   COEFFICIENT$)')
1115   FORMAT(/4X,I2,6X,1PG13.6)
C PRINT OUT COEFFICIENTS
   DO 1118 I=1,IDEG+1
       IF(IFLAG.EQ.1.AND.IREG.NE.0)CALL STORE(I,IREG,COF(I));GO TO 1118
       IF(IFLAG.EQ.0) WRITE(-2,1115) I-1,COF(I)
1118   CONTINUE
       IF(IFLAG.EQ.1) GO TO 1149
       SY=SB=YBAR=WNOOFRO=0.
       DO 1116 I=1,NOOFRO
       YBAR=YBAR+DATA(I,IY)
       WNOOFRO=WNOOFRO+1
       IF(IW.NE.0)WNOOFRO=WNOOFRO+DATA(I,IW)-1;YBAR=YBAR+
+DATA(I,IY)*(DATA(I,IW)-1)
1116   CONTINUE
       YBAR=YBAR/WNOOFRO
       DO 1130 I=1,NOOFRO
       TY=0
       DO 1120 J=1,IDEG+1
       IF(J.EQ.1)YCT=COF(1);GO TO 1120
       YCT=DATA(I,IX)**(J-1)*COF(J)
1120   TY=TY+YCT
       EY=DATA(I,IY)
       VAL1=EY-TY
       VAL2=TY-YBAR
       SY=SY+VAL1**2
       SB=SB+VAL2**2
       IF(IW.NE.0)SY=SY+VAL1**2*(DATA(I,IW)-1);SB=SB+VAL2**2*(DATA(I,IW)-1)
1130   CONTINUE
       IF(WNOOFRO.LE.2)WRITE(-2,1131);GO TO 1134
1131   FORMAT(/$STANDARD ERROR IS NOT COMPUTED AND IS SET TO 0.$/)
       SE=SY/(WNOOFRO-2)
       IF(ABS(SE).LT.1E-8)SE=0; GO TO 1134
       SE=SQRT(SE)
1134   RSQ=SB/(SB+SY)
       IF(RSQ.LT.1E-8)RSQ=0
       WRITE(-2, '(/$INDEX OF DETERMINATION: $1PG13.6/$STANDARD 
+ERROR OF ESTIMATE FOR Y: $1PG13.6)'),RSQ,SE
1135   WRITE(-2, '(//Z$PRINT A TABLE OF RESIDUALS? $)')
1136   CALL NEWLINE(NCH)
       IF(NCH)1136,1135,1140
1140   IANS=NOWCHR(0)
       IF(IANS.EQ.1RY)GO TO 1141
       IF(IANS.EQ.1RN)GO TO 1145
       GO TO 1135
1141   WRITE (-2, '(/$Y OBSERVED     Y ESTIMATED       RESIDUAL$)')
1143   FORMAT(/Z1PG13.6,2(3X1PG13.6))
1149       DO 1145 I=1,NOOFRO
       YE=COF(1)
       DO 1144 J=2,IDEG+1
1144   YE=YE+DATA(I,IX)**(J-1)*COF(J)
       YO=DATA(I,IY)
       YDIF=YO-YE
     IF(ABS(YDIF).LT.1E-8)YDIF=0
       IF(IFLAG.EQ.1.AND.IRES.NE.0)CALL STORE(I,IRES,YDIF);GO TO 1145
       IF(IFLAG.EQ.0)WRITE (-2,1143),YO,YE,YDIF
1145   CONTINUE
       IF IFLAG.EQ.1,  GO TO 995
1146   WRITE(-2, '(//Z$ANOTHER FIT FOR THIS DATA? $)')
1147   CALL NEWLINE(NCH)
       IF(NCH)1147,1146,1148
1148   IANS=NOWCHR(0)
       IF(IANS.EQ.1RY) GO TO 1000
       IF IANS#1RN,  GO TO 1146
       IF(IREG.EQ.0.AND.IRES.EQ.0) GO TO 995
896    WRITE(-2,892)
892    FORMAT(/Z$SAVE RESIDUALS/COEFFS. FOR DEGREE #$)
       CALL NEWLINE(NCH)
       IF INTEGER(IDEG)<=0,GO TO 896
       IFLAG=1
       IF(.NOT.(IDEG.GT.0.AND.IDEG.LE.15.AND.IDEG.LT.NOOFRO)) GO TO 896
       DO 893 J=1,NOOFRO
       IF IREG#0,CALL STORE(I,IREG,0.)
       IF IRES#0,CALL STORE(I,IRES,0.)
893    CONTINUE
       GO TO 1014
995    STATE=1
       IF(IRES.NE.0.OR.IREG.NE.0) INP OK=.FALSE.
       RETURN
       END
       FUNCTION REDUC(I,J,CO)
       DIMENSION CO(1)
       L=0
       DO 100 K=1,I
100    L=L+K
       L=L+J-I
       REDUC=CO(L)
       RETURN
       END
       SUBROUTINE STORE(I,J,X)
       REAL MATRIX
       GLOBAL NO OF COLUMNS,  MATRIX(1)
       MATRIX(J+NO OF COLUMNS*(I-1))=X
       RETURN

       REAL FUNCTION DATA(L,M)
       GLOBAL NOOFCO,NOOFRO
       DATA=MATRIX(M+NOOFCO*(L-1))
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
STATA4 SYMSORT

SYM.  PG.LN. IDENT.

+       1 25 C:STATA4+       1 12 C:STATA4+AND    2 20 C:STATA4+ERROR  5 25 C:STATA4
1       2 13 C:STATA4100     6 33 C:STATA41000    2 14 C:STATA41001    2 15 C:STATA4
1005    2 17 C:STATA41010    2 18 C:STATA41014    2 24 C:STATA41015    2 25 C:STATA4
1020    2 32 C:STATA41025    3  4 C:STATA41029    3 14 C:STATA41030    3 15 C:STATA4
1035    3 18 C:STATA41037    3 28 C:STATA41045    3 35 C:STATA41050    3 39 C:STATA4
1070    4  1 C:STATA41075    4  3 C:STATA41089    4 13 C:STATA41090    4 14 C:STATA4
1094    4 18 C:STATA41095    4 21 C:STATA41100    4 22 C:STATA41110    4 27 C:STATA4
1115    4 29 C:STATA41118    4 34 C:STATA41120    5  9 C:STATA41130    5 16 C:STATA4
1131    5 18 C:STATA41134    5 22 C:STATA41135    5 26 C:STATA41136    5 27 C:STATA4
1140    5 29 C:STATA41141    5 33 C:STATA41143    5 34 C:STATA41144    5 38 C:STATA4
1145    6  5 C:STATA41146    6  7 C:STATA41147    6  8 C:STATA41148    6 10 C:STATA4
1149    5 35 C:STATA46200    1 38 C:STATA4892     6 15 C:STATA4893     6 23 C:STATA4
896     6 14 C:STATA4995     6 25 C:STATA4C       4 30 C:STATA4
C       4 24 C:STATA4C       4  4 C:STATA4C       3 31 C:STATA4C       3 26 C:STATA4
C       3 23 C:STATA4C       3  9 C:STATA4C       3  6 C:STATA4C       2 37 C:STATA4
C       2 35 C:STATA4C       2 26 C:STATA4C       2 23 C:STATA4C       1 36 C:STATA4
C       1 35 C:STATA4CM      1 16 C:STATA4CM      1 10 C:STATA4CM      1  9 C:STATA4
CM      1  7 C:STATA4CM      1  3 C:STATA4CM1$    2  3 C:STATA4CMCM    2  4 C:STATA4
CMCM    1  4 C:STATA4CMCM    1  2 C:STATA4CMCMCM  2  2 C:STATA4CMCMCM  1 31 C:STATA4
L       6 38 C:STATA4L       6 29 C:STATA4L       2  5 C:STATA4_DATA(  5  2 C:STATA4
_ROWS$  2 22 C:STATA4
STATFIN ** FICHE/FRAME BREAK *****
STATA5
C:STATA5   10/13/72            STATPAK ANALYSIS OVERLAY FIVE.
C
C
       OVERLAY STATA5,5
C
       NORMAL MODE IS INTEGER
C
C
       LOGICAL TALK,HUSH,ECHO,TTY
       INTEGER COM NO
       COMMON /SFE/TALK,HUSH,ECHO,TTY,COM NO
C
       INTEGER INPUT LINE(256), I SAVE(6)
       COMMON /LINE INPUT/INPUT LINE, I SAVE, I POINT, I COUNT, INDEX
C
       COMMON /CODE/MAX CODE, N CODE, CODE(200)
C
       LOGICAL FILE INPUT,  DATA IN,  INP OK,  APP OK
       LOGICAL NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC
       LOGICAL BACK UP
       LOGICAL FLAG 1,  FLAG 2
       REAL TAX,  MATRIX
C
       SHARE MATRIX(2048)
       SHARE $FILES,  /SFE/,  /LINE INPUT/
       SHARE /CODE/
       SHARE NAME(18)
       SHARE BEGIN(9),  IN FLOW,  OUT FLOW,  TAX COLUMN,  TAX
       SHARE TAX FREQUENCY
       SHARE TITLE(2),  CPL,  C COUNT,  FLAG 1(90),  FLAG 2(9)
       SHARE FILE INPUT,  DATA IN,  INP OK,  APP OK,  STATE
       SHARE NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC,  NO OF CASES
       SHARE P COLUMNS,  P ROWS,  MAX NAMES,  BACK UP
       SHARE NAMES(423),  NO OF COLUMNS,  NO OF ROWS
       SHARE NO OF PERIODS,  COLUMNS(2,208),  ROWS(2,-2:-1)
       SHARE OVERFLOW(27)
       SHARE CRAP(500)
C
C
       LOGICAL FREQ IN
       REAL S, U
       GLOBAL ICHOICE,  IFRE,  ICN,  IRES,  FREQ IN
C
C
       REAL MKREAL
C
C
       CONNECT OVERFLOW,  TYPE OVERFLOW;  STATE=2;  GO TO 1$
C
C
C
       IFRE=CODE(3)
       IF IFRE.EQ.4,  (  FREQ IN=.TRUE.;  IFRE=1  )
+              .ELSE.  FREQ IN=.FALSE.
       ICN=CODE(5-FREQ IN)
       ICHOICE=CODE(8)
C
       S=U=0
       I=9
       IF CODE(9)#5,  GO TO 1
       S=MKREAL(CODE(10))
       I=12
       IF CODE(12)#5,  GO TO 1
       U=MKREAL(CODE(13))
       I=15
C
1      IRES=CODE(I)
C
C
       IF CODE(2).EQ.64,  GO TO 6400
*
*
*
C      CHI SQUARE
C ********************
*
6300   CALL KOLMOGOROV SMIRNOV(U,S)
       GO TO 1$
*
*
*
C      KOLMOGOROV SMIRNOV
C ****************************
*
6400   CALL CHI SQUARE(U,S)
       GO TO 1$
*
C
C
C      RETURN TO MAIN OVERLAY
C
1$     TERMINATE OVERLAY
C
C
       END
       SUBROUTINE CHI SQUARE(S,U)
       INTEGER STATE
       GLOBAL SPEC(101),ICN,NINT,IM,ICHOICE,ICON,NNR,FNR,FMEF,STATE
       EXTERNAL NSHORT
       P=EX=VAL=KPR=CHI=DE=0
       ICON=-1
       DO 1000 I=1,101
1000   SPEC(I)=0
C SUBROUTINE SPECIN WILL INPUT INTERVAL SPECIFICATIONS
80     CALL SPECIN(SPEC,NINT,101)
       IF ICON>=0,  GO TO 100
85     WRITE (-2,1)
1      FORMAT(/Z$CONSIDER EXTERNAL INTERVALS? $)
       IK=NSHORT
       IF(IK.EQ.6)ICON=1; CALL FIX SPEC; GO TO 100
       IF(IK.EQ.7),ICON=0;GO TO 100
       GO TO 85
100    WRITE (-2,2)
2      FORMAT(/Z$MINIMUM EXPECTED FREQUENCY: $)
       CALL NEWLINE(NCH)
       IF(NUMBER(FMEF))100,100,90
90     CALL MAKEFILE(SPEC,ICHOICE,S,U)
110    POSITION 4,1
C MUST WE WORRY ABOUT EXTERNAL INTERVALS?
       CHI=0
       IF(ICON.EQ.1)IB=1;IE=NINT+1;EX=0
       IF(ICON.EQ.0)IB=2;IE=NINT;READ BINARY 4,EX,II
C LOOP TO CHECK FOR EXPECTANCIES BELOW MINIMUM AND TO CALCULATE
C CHI-SQUARE.
       DO 140 I=IB,IE
       EX1=EX
       READ BINARY 4,EX,II
       EXX=EX-EX1
       IF(EXX.LT.FMEF)GO TO 115
       IF(EXX.EQ.FMEF.AND.FMEF.EQ.0)GO TO 115
C CALCULATE CHI-SQUARE RIGHT HERE
       CHI=CHI+((II-EXX)**2)/EXX
C IF DE = 0, THE CHI-SQ COULD  NOT BE CALCULATED.
       DE=DE+EXX
       GO TO 140
115    IF(KPR.EQ.1)GO TO 120
       WRITE (-2,3)
3      FORMAT(/$THE FOLLOWING INTERVALS HAVE BEEN EXCLUDED:$/
+              $         INTERVAL               EXPECTED FREQUENCY$/)
       KPR=1
120    IF(I.EQ.1)WRITE (-2,4) SPEC(1),EXX;  GO TO 140
4      FORMAT($< $1PG13.6,23X,1PG13.6)
C CHECK FOR EXTRA INTERVAL OF POISSON OR BINOMIAL
       IF(I.EQ.NINT+1.AND.IM.EQ.1)WRITE (-2,5) EXX;  GO TO 140
5      FORMAT($>=$1PG13.6,23X,1PG13.6)
       IF(I.EQ.NINT+1) WRITE (-2,6) SPEC(NINT),EXX;  GO TO 140
6      FORMAT($> $1PG13.6,23X,1PG13.6)
       IF(I.EQ.NINT.AND.IM.NE.1)
+              WRITE (-2,7) SPEC(I-1),SPEC(I),EXX;  GO TO 140
7      FORMAT($>=$1PG13.6,$,<=$1PG13.6,8X,1PG13.6)
       WRITE (-2,8) SPEC(I-1),SPEC(I),EXX
8      FORMAT($>=$1PG13.6$,<$1PG13.6,9X,1PG13.6)
140    CONTINUE
       IF(KPR.EQ.0)GO TO 150
       IF(DE.EQ.0) TYPE 9;  STATE=2;  GO TO 950
9      FORMAT(/$ALL EXPECTED FREQUENCIES ARE TOO LOW,$/
+              $CHI-SQUARE NOT CALCULATED$)
145    WRITE (-2,10)
10     FORMAT(/Z$DO YOU WISH TO PROCEED? $)
       KK=NSHORT
       IF(KK.EQ.6)GO TO 150
       IF(KK.EQ.7)GO TO 900
       GO TO 145
150    IF(ABS(CHI).LT.1E-7)CHI=0.
       WRITE (-2,11) CHI
11     FORMAT(/$CHI-SQUARE STATISTIC= $1PG13.6)
C OPTIONAL OUTPUT?
       CALL CHKSPRINT(1)
900    STATE=1
950    RETURN
       END
       SUBROUTINE KOLMOGOROV SMIRNOV(S,U)
       INTEGER STATE
       GLOBAL SPEC(101),ICN,NINT,IM,ICHOICE,ICON,NNR,FNR,FMEF,STATE
       P=EX=VAL=KPR=CHI=ICON=DE=D=0
       ICON=-1
       DO 200 I=1,101
200    SPEC(I)=0
C GET INTERVAL SPECIFICATIONS
210    CALL SPECIN(SPEC,NINT,36)
       IF ICON#0,  ICON=1;  CALL FIX SPEC;  GO TO 214
       TYPE 212
212    FORMAT(/$MUST HAVE EXTERNAL INTERVALS WITH KOLMOGOROV-SMIRNOV.$/)
       STATE=2
       GO TO 950
C CREATE FILE WITH EXPECTED AND OBSERVED DATA
214    FMEF=-1
       CALL MAKEFILE(SPEC,ICHOICE,S,U)
       POSITION 4,1
       JJ=0
       DP=0
       IF(ICHOICE.NE.6)FNR=NNR
C LOOP TO CALCULATE KOLMOGOROV-SMIRNOV
       DO 300 I=1,NINT+1
       READ BINARY 4,EX,II
C CUMULATIVE OBSERVED DATA JJ, EXPECTED DATA EX
       JJ=JJ+II
       PEX=EX/FNR
       DJJ=FLOAT(JJ)
       PJJ=DJJ/NNR
       D=ABS(PEX-PJJ)
       DP=AMAX(D,DP)
300    CONTINUE
       IF(ABS(DP).LT.1E-7)DP=0
       WRITE (-2,1) DP
1      FORMAT(/$KOLMOGOROV-SMIRNOV STATISTIC: $1PG13.6)
       CALL CHKSPRINT(2)
900    STATE=1
950    RETURN
       END
       SUBROUTINE FIX SPEC
C
       GLOBAL NO OF ROWS,  NINT
C
C
       IF NO OF ROWS>0,  GO TO 1
       CALL STORE(NINT+1,1,DATA(NINT-1,2)),  STORE(NINT+1,2,1E75)
       (  CALL STORE(I+1,1,DATA(I,1)),  STORE(I+1,2,DATA(I,2))  ),
+              I=NINT-1,1,-1
       CALL STORE(1,1,-1E75),  STORE(1,2,DATA(2,1))
C
1      RETURN
C
       END
       SUBROUTINE MAKEFILE(SPEC,ICHOICE,S,U)
       EXTERNAL NSHORT
       DIMENSION SPEC(1)
       INTEGER STATE
       GLOBAL STATE
       GLOBAL  NOOFRO,NINT,ICN,IM,ICON,IFRE,IFREQ(102),NNR,FNR,FMEF
       FNR=0
       DE=0
       IF(IFRE.EQ.1)CALL ACCFREQ;GO TO 1
       IF(IFRE.EQ.2)CALL ENTFREQ;GO TO 1
C CALCULATE TOTAL OBSERVATIONS
       NNR=NOOFRO;GO TO 5
1      IF STATE>1,  GO TO 950
       NNR=0
       DO 3 I=1,NINT+1
3      NNR=NNR+IFREQ(I)
5      POSITION 4,1
       INR=NNR
       P=0
       JPR=0
       EX=0
       IBEF=0
       IAFT=0
       JAFT=0
       IF(IFRE.GT.0)IBEF=IFREQ(1);IAFT=IFREQ(NINT+1);I=1;GO TO 62
       DO 10 I=1,NOOFRO
       IF(DATA(I,ICN).LT.SPEC(1))IBEF=IBEF+1
       IF(DATA(I,ICN).GT.SPEC(NINT))IAFT=IAFT+1
C SEE IF ANOTHER INTERVAL ADDED FOR POISSON OR BINOM.
       IF(DATA(I,ICN).GE.SPEC(NINT))JAFT=JAFT+1
10     CONTINUE
       IF(IM.EQ.1)IAFT=JAFT
       I=1
       GO TO 62
50     DO 120 I=2,NINT
       IBEF=0
       IF(IFRE.GT.0)IBEF=IFREQ(I);GO TO 62
       IF(I.EQ.NINT.AND.IM.NE.1)GO TO 65
       DO 60 J=1,NOOFRO
       IF SPEC(I-1)<=DATA(J,ICN)<SPEC(I),IBEF=IBEF+1
60     CONTINUE
62     GO TO (75,80,85,90,95)ICHOICE,100
65     DO 70 J=1,NOOFRO
       IF SPEC(I-1)<=DATA(J,ICN)<=SPEC(I),IBEF=IBEF+1
70     CONTINUE
       GO TO 62
75     CALL GNDTR(SPEC(I),S,U,P)
       GO TO 110
80     CALL POISSON(SPEC(I),U,P)
       IF(I.EQ.NINT.AND.IM.EQ.2)CALL POISSON(SPEC(I)+1,U,P)
       GO TO 110
85     CALL EXPO(SPEC(I),S,U,P)
       GO TO 110
90      CALL BINOMIAL(SPEC(I),S,U,P)
       IF(I.EQ.NINT.AND.IM.EQ.2)CALL BINOMIAL(SPEC(I)+1,S,U,P)
       GO TO 110
95     CALL UNIF(SPEC(I),S,U,P)
       GO TO 110
100    IF(JPR.NE.1) WRITE (-2,6)
       JPR=1
6      FORMAT(/$ENTER EXPECTED OBSERVATIONS FOR THEFOLLOWING INTERVALS;$)
       IF(I.EQ.1.AND.ICON.EQ.0)GO TO 111
101    IF(I.EQ.1) WRITE (-2,7) SPEC(1);  GO TO 102
7      FORMAT(/Z1H<,F.5,2H: )
       IF(I.EQ.NINT) WRITE (-2,8) SPEC(I-1),SPEC(I);  GO TO 102
8      FORMAT(/Z3H>= ,F.5,5H ,<= ,F.5,2H: )
       WRITE (-2,9) SPEC(I-1),SPEC(I)
9      FORMAT(/Z3H>= ,F.5,4H ,< ,F.5,2H: )
102    CALL NEWLINE(NCH)
       IF(NUMBER(EXX))101,101,111
111    EX=EX+EXX
       GO TO 112
110    EX=P*NNR
112    WRITE BINARY 4,EX,IBEF
C GET CORRECT TOTALS FOR OBSERVED AND EXPECTED
       EF=EX-DE
       DE=EX
       IF((ICON.EQ.0.AND.I.EQ.1).OR.(FMEF.EQ.0.AND.EF.EQ.0)
+              .OR.(EF.LT.FMEF))INR=INR-IBEF;GO TO 115
       FNR=FNR+EF
115    IF(I.EQ.1)GO TO 50
120    CONTINUE
       IF(ICHOICE.NE.6.OR.ICON.EQ.0)EX=NNR;GO TO 200
130    WRITE (-2,11) SPEC(NINT)
11     FORMAT(/Z2H> ,F.5,2H: )
       CALL NEWLINE(NCH)
       IF(NUMBER(EXX))130,130,132
132    EX=EX+EXX
200    WRITE BINARY 4,EX,IAFT
       EF=EX-DE
       IF((ICON.EQ.0).OR.(FMEF.EQ.0.AND.EF.EQ.0).OR.(EF.LT.FMEF))
+              INR=INR-IAFT;GO TO 210
       FNR=FNR+EF
210    IF(ABS(FNR-INR).GE.1) WRITE (-2,12) FNR,INR
12     FORMAT(/$TOTAL OF EXPECTED FREQUENCIES DO NOT EQUAL$/
+              $OBSERVED.  EXPECTED=$F.2$, OBSERVED=$I)
900    STATE=1
950    RETURN
       END
       SUBROUTINE GNDTR(VAL,S,U,P)
       Z=(VAL-U)/S
       CALL NDTR(Z,P,D)
       RETURN
       END
       SUBROUTINE EXPO(VAL,S,U,P)
       Z=(VAL-U)/S+1
       IF(Z.LT.0)P=0;RETURN
       P=1-EXP(-Z);RETURN
       END
       SUBROUTINE BINOMIAL(VAL,S,U,P)
       IVAL=INT(VAL+.1)
       IF(P.EQ.0)L=0
       IF(VAL.GT.S)P=1;RETURN
       IF(VAL.EQ.0)P=0;RETURN
       DO 100 I=L,IVAL-1
       AB=1
       BE=1
       IF(I.EQ.0)FAC=1;GO TO 99
       FFAC=AMAX(I,(S-I))
C LOOP TO CALCULATE COEFFICIENT FOR A PONT PROBABILITY
       DO 10 K=1,INT(S-FFAC+.1)
       BE=BE*K
       AB=AB*(S-K+1)
10     CONTINUE
       FAC=AB/BE
99     P=P+FAC*U**I*(1-U)**INT(S-I+.1)
100    CONTINUE
C SAVE IVAL SO WE KNOW BEGINNING OF NEXT INTERVAL
       L=IVAL
       RETURN
       END
       SUBROUTINE POISSON(VAL,U,P)
C
C      CUMULATIVE DISTRIBUTION FOR POISSON
C      U=MEAN, VAL IS UPPER BOUND OF INTERVAL
C
       IVAL=VAL+.001
       IF (IVAL .EQ. 0) P=0.; RETURN
       IF (P .EQ. 0) L=1; PX=SPX=EXP(-U)
       IF (IVAL .EQ. 1) GO TO 200
       DO 100 I=L,IVAL-1
       PX=U*PX/I
100    SPX=SPX+PX
       L=IVAL
200    P=SPX
       RETURN
       END
       SUBROUTINE UNIF(VAL,S,U,P)
       P=(VAL-U)/(S-U)
       IF(P.GT.1)P=1
       IF(P.LT.0)P=0
       RETURN
       END
       SUBROUTINE NDTR(X,P,D)
       AX=ABS(X)
       T=1./(1.+.2316419*AX)
       D=.3989423*EXP(-X*X/2.)
       P=1.-D*T*((((1.330274*T-1.821256)*T+1.781478)*T-
+              .3565638)*T+.3193815)
       IF(X)1,2,2
1      P=1.-P
2      RETURN
       END
       SUBROUTINE SPECIN(SPEC,NINT,LAST)
       EXTERNAL NSHORT
       INTEGER CODE
       COMMON /CODE/MAX CODE,  N CODE,  CODE(1)
       DIMENSION SPEC(1)
       LOGICAL FREQIN
       GLOBAL IM,ICHOICE,NOOFRO,FREQIN,ICON
       IM=0
       IF .NOT.FREQ IN,  GO TO 1$
       ICON=-(DATA(1,CODE(4))<-5E74)
       (  SPEC(I)=DATA(I,CODE(4))  ),  I=1+ICON,NOOFRO
       IF ICON.EQ.0,  (  SPEC(NO OF ROWS+1)=DATA(NO OF ROWS,CODE(5));
+              NINT=NO OF ROWS+1  )  .ELSE.  NINT=NO OF ROWS-1
       IF(ICHOICE.NE.2.AND.ICHOICE.NE.4) GO TO 900
       WRITE(-2,800)
800    FORMAT(/$DO YOU HAVE AN ADDITIONAL INTERVAL?$Z)
       IK=NSHORT
       IF(IK.EQ.6)IM=1
       IF(IK.EQ.7)IM=2
       GO TO 900
1$     WRITE (-2,100)
100    FORMAT(/$INTERVAL SPECIFICATIONS: $)
       ICNT=1
C IM INDICATES IF EXTRA INTERVAL IS NEEDED FOR BINOM OR POISSON
       IM=0
       CALL NEWLINE(NCH)
       IF(NCH)1$,1$,10
10     IF(KOMMAND(1).NE.3)  CALL LOCAL(101S)
101    FORMAT($FIRST DESCRIPTOR MUST BE "FROM"$)
12$    FORMAT(/$ILLEGAL INTERVAL SPECIFICATION--$)
C ENTER LOWER LIMIT
       IF(NUMBER(SPEC(1)))16,16,20
C LOOK AT NEXT LINE IF CR WAS ENTERED
15     FORMAT($DESCRIPTOR NOT FOLLOWED BY A NUMBER$)
C PVAL WILL BE LOWER LIMIT OF BY OR IN INTERVALS
16     CALL LOCAL(15S)
20     PVAL=SPEC(1)
       F=PVAL
23     K=KOMMAND(1)
C IN OR BY
C IF CR ENTERED, CHECK NEXT LINE
24     IF(K.EQ.4.OR.K.EQ.5)GO TO 25
       CALL LOCAL(102S)
102    FORMAT($"BY" OR "IN" EXPECTED BUT NOT ENTERED$)
C IPC TO REMEMBER IN OR BY
25     IPC=K
       IF(NUMBER(VAL))16,16,40
40     IF(VAL.LE.0)  CALL LOCAL(103S)
103    FORMAT($NUMBER ENTERED AFTER "BY" OR "IN" IS NOT POSITIVE$)
       K=KOMMAND(1)
42     IF(K.NE.2)  CALL LOCAL(104S)
104    FORMAT($"TO" EXPECTED BUT NOT ENTERED$)
C EVAL IS NUMBER ENTERED AFTER 'TO'
       IF(NUMBER(EVAL))16,16,45
45     IF(EVAL.LE.PVAL)  CALL LOCAL(105S)
105    FORMAT($LIMITS NOT IN ASCENDING ORDER$)
       IF(IPC.EQ.4)GO TO 49
C CALCULATION FOR 'IN' AND CONVERT TO 'BY'
       IA=VAL+.1
       VAL=(EVAL-PVAL)/VAL
       GO TO 495
C LOOP TO CALCULATE INTERVALS FOR 'BY'
49     A=(EVAL-PVAL)/VAL
       IA=A+.1
       IF(ABS(A-INT(A+.1)).GT.1 E-7)GO TO 54
495    DO 500 I=1,IA
       F=F+VAL
       ICNT=ICNT+1
       IF(ICNT.GT.LAST)GO TO 55
       SPEC(ICNT)=F
500    CONTINUE
       PVAL=EVAL
       GO TO 60
C CHECK TO SEE IF LOOP ENDS OK
54     TYPE 12$;  TYPE 106,EVAL,PVAL,VAL;  GO TO 1$
106    FORMAT(1H(F.5,2H-(,F.5,3H))/,F.5$ IS NOT AN INTEGER$)
55     TYPE 12$;  TYPE 56,LAST-1;  GO TO 1$
56     FORMAT($MORE THAN $I$INTERVALS$)
60     K=KOMMAND(1)
C HAS SEMI-COLON BEEN ENTERED?
       IF(K.NE.1)GO TO 80
C CHECK IF POISSON OR BINOM OR NOT
       IF(ICHOICE.NE.2.AND.ICHOICE.NE.4)GO TO 70
C MAKE SURE INTERVALS FOR POISSON AND BINOMIAL ARE INTEGER
       DO 825 I=1,NINT
825    SPEC(I)=SPEC(I)+1E-7
       DO 83 I=1,NINT
       IF(ABS(AINT(SPEC(I))-SPEC(I)).GT.1E-6) TYPE 109;  GO TO 1$
109    FORMAT(/$ALL INTERVALS FOR THIS DISTRIBUTION MUST BEGIN$/
+              $AND END WITH AN INTEGER$)
       SPEC(I)=AINT(SPEC(I))
83     CONTINUE
64     WRITE (-2,108) SPEC(ICNT)
108    FORMAT(/Z$DO YOU WISH A SEPARATE INTERVAL FOR $I,2H? )
       IK=NSHORT
       IF(IK.EQ.6)IM=1;ICNT=ICNT+1;SPEC(ICNT)=SPEC(ICNT-1)+1;GO TO 70
       IF(IK.EQ.7)IM=2;GO TO 70
       GO TO 64
70     NINT=ICNT
       IF NOOFRO>0,  GO TO 900
       (  CALL STORE(I,1,SPEC(I)),  STORE(I,2,SPEC(I+1))  ),  I=1,NINT-1
900    RETURN
80     IF(K.EQ.4.OR.K.EQ.5)GO TO 25
       CALL LOCAL(107S)
107    FORMAT($"BY", "IN", OR ";" EXPECTED BUT NOT ENTERED$)
C
C
       LOCAL SUBROUTINE LOCAL(LABEL)
       TYPE 12$
       TYPE LABEL
       GO TO 1$
       END
       SUBROUTINE ACCFREQ
       LOGICAL FREQ IN
       INTEGER STATE,CODE
       COMMON /CODE/MAX CODE, N CODE, CODE(1)
       GLOBAL STATE,NOOFRO,FREQIN
       GLOBAL IM,SPEC(101),S,NINT,ICON,ICN,ICHOICE,IFREQ(102),IFRE
       IF(ICON.EQ.0)IFREQ(1)=0;IFREQ(NINT+1)=0;GO TO 50
       IF(NOOFRO.NE.NINT+1)TYPE 15,NOOFRO,(NINT+1);  GO TO 1000
15     FORMAT(/$NUMBER OF FREQUENCIES MUST EQUAL NUMBER OF INTERVALS$/
+              I$ENTERED, $I$REQUIRED$)
       DO 10 I=1,NOOFRO
10     IFREQ(I)=DATA(I,ICN)+.001
       GO TO 900
50     IF FREQIN,  GO TO 55
       IF(NOOFRO.NE.NINT-1)TYPE 15,NOOFRO,(NINT-1);  GO TO 1000
55     DO 60 I=1,NINT-1
60     IFREQ(I+1)=DATA(I,ICN)+.001
900    STATE=1
950    RETURN
1000   STATE=2
       GO TO 950
       END
       SUBROUTINE ENTFREQ
       INTEGER STATE
       GLOBAL STATE,NOOFRO
       GLOBAL IM,SPEC(101),S,NINT,ICON,ICN,ICHOICE,IFREQ(102),IFRE
       INTEGER SYMOUT(2)
       IONE=1
       IZ=0
       WRITE (-2,1)
1      FORMAT(/$ENTER FREQUENCY FOR THE FOLLOWING INTERVALS:$/)
       IF(ICON.NE.1)IFREQ(1)=0;IFREQ(NINT+1)=0;GO TO 50
10     WRITE (-2,2) SPEC(1)
2      FORMAT(/Z1H<,F.5,2H: )
       CALL NEWLINE(NCH)
       IF(NUMBER(X))10,10,20
20     IF(ABS(INT(X)-X).GT.1E-6)TYPE 21;GO TO 10
21     FORMAT(/$FREQUENCY MUST BE INTEGER$/)
       IFREQ(1)=INT(X)
50     DO 200 I=2,NINT
60     IF(I.EQ.NINT.AND.IM.NE.1)  WRITE (-2,3) SPEC(I-1),SPEC(I);
+              GO TO 100
3      FORMAT(/Z3H>= ,F.5,5H ,<= ,F.5,2H: )
       WRITE (-2,4) SPEC(I-1),SPEC(I);  GO TO 100
4      FORMAT(/Z3H>= ,F.5,4H ,< ,F.5,2H: )
100    CALL NEWLINE(NCH)
       IF(NUMBER(X))60,60,110
110    IF(ABS(INT(X)-X).GT.1E-6)TYPE 21;GO TO 60
       IFREQ(I)=INT(X)
200    CONTINUE
       IF(ICON.EQ.0)GO TO 900
210    IF(IM.EQ.1)  WRITE (-2,5) SPEC(NINT);  GO TO 220
5      FORMAT(/Z3H>= ,F.5,2H: )
       WRITE (-2,6) SPEC(NINT)
6      FORMAT(/Z2H> ,F.5,2H: )
220    CALL NEWLINE(NCH)
       IF(NUMBER(X))210,210,230
230    IF(ABS(INT(X)-X).GT.1E-6)TYPE 21;GO TO 210
       IFREQ(NINT+1)=INT(X)
900    STATE=1
       IF ICON#0,  GO TO 910
       J=2
       K=NINT
       NO OF ROWS=NINT-1
       GO TO 920
910    J=1
       K=NINT+1
       NO OF ROWS=NINT+1
920    L=0
       (  CALL STORE(L=L+1,3,REAL(IFREQ(I)))  ),  I=J,K
950    RETURN
       END
       SUBROUTINE CHKSPRINT(IFLAG)
       LOGICAL FLAG
       GLOBAL NNR,ICON,FNR,SPEC(101),NINT,IM,FMEF,IRES
       EXTERNAL NSHORT
1      WRITE (-2,21)
21     FORMAT(/$PRINT A TABLE OF RESIDUALS? $Z)
       IK=NSHORT
       IF IK.EQ.7,  GO TO 25
       IF IK#6,  TYPE 22;  GO TO 1
22     FORMAT($?$/)
C
25     FLAG=IK.EQ.6
       IF FLAG, IF(IFLAG.EQ.1)WRITE (-2, '(//28X,$ OBSVD.   EXPCTD.    ABSOLUTE   
+WGHTD. SQD.$/$         INTERVAL             FREQ.    FREQ.   
+ DEVIATION   DEVIATION$)');GO TO 10
       IF FLAG, WRITE (-2, '(//29X,$OBS. CUM. OBS. CUM. EXP. CUM.  ABSOLUTE$/
+$          INTERVAL             FREQ.     PROB.     PROB.   
+DEVIATION$)')
10     POSITION 4,1
       IF(ICON.EQ.1)IB=1;IE=NINT+1;EX=0
       IF(ICON.EQ.0)READ BINARY 4,EX,II;IB=2;IE=NINT
       JJ=0
       DO 400 I=IB,IE
       EX1=EX
       READ BINARY 4,EX,II
       EXX=EX-EX1
       IF(IFLAG.EQ.2)GO TO 120
       IF(EXX.LT.FMEF.OR.EXX.EQ.0)GO TO 400
       IF .NOT.FLAG,GO TO 140
120    IF .NOT.FLAG,GO TO 340
        IF(I.EQ.1)WRITE (-2, '(/Z$< $1PG11.4,15X)'),SPEC(1);
+              IF IFLAG.EQ.1, GO TO 140 .ELSE. GO TO 340
       IF(I.EQ.NINT+1.AND.IM.EQ.1)WRITE (-2, '(/Z$>=$1PG11.4,15X)'),
+              SPEC(NINT);IF IFLAG.EQ.1, GO TO 140 .ELSE. GO TO 340
        IF(I.EQ.NINT+1)WRITE (-2, '(/Z$> $1PG11.4,15X)'),SPEC(NINT);
+               IF IFLAG.EQ.1, GO TO 140 .ELSE. GO TO 340
       IF(I.EQ.NINT.AND.IM.NE.1)WRITE (-2, '(/Z$>=$1PG11.4,$,<=$1PG11.4,
+1X)'),SPEC(I-1),SPEC(I);IF IFLAG.EQ.1, GO TO 140 .ELSE. GO TO 340
        WRITE (-2, '(/Z$>=$1PG11.4$,<$1PG11.4,2X)'),SPEC(I-1),SPEC(I);
+              IF IFLAG.EQ.1, GO TO 140 .ELSE. GO TO 340
140    DEV=ABS(EXX-II)
       WSD=DEV**2/EXX
       IF FLAG, WRITE (-2, '(ZI7,1X,3(1PG11.4,1X))'),II,EXX,DEV,WSD
       IF IRES#0,  CALL STORE(I-1+ICON,IRES,DEV)
       GO TO 400
340    JJ=JJ+II
       PEX=EX/FNR
       DJJ=FLOAT(JJ)
       PJJ=DJJ/NNR
       D=ABS(PEX-PJJ)
       IF FLAG, WRITE (-2, '(Z1X,I7,3(3X,F7.5))'),JJ,PJJ,PEX,D
       IF IRES#0,  CALL STORE(I-1+ICON,IRES,D)
400    CONTINUE
900    WRITE (-2,910)
910    FORMAT(/)
       RETURN
       END
       FUNCTION NSHORT
       CALL NEWLINE(NCH)
       NSHORT=KOMMAND(1)
       RETURN
       END
       SUBROUTINE STORE(I,J,X)
       REAL MATRIX
       GLOBAL NO OF COLUMNS,  MATRIX(1)
       MATRIX(J+NO OF COLUMNS*(I-1))=X
       RETURN

       REAL FUNCTION DATA(L,M)
       DATA=MATRIX(M+NO OF COLUMNS*(L-1))
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
STATA5 SYMSORT

SYM.  PG.LN. IDENT.

+      15 29 C:STATA5+      15 25 C:STATA5+      15 23 C:STATA5+      15 21 C:STATA5
+      15  5 C:STATA5+      13 39 C:STATA5+      13  7 C:STATA5+      12 16 C:STATA5
+      10 17 C:STATA5+       9 39 C:STATA5+       8 17 C:STATA5+       8 13 C:STATA5
+       7 39 C:STATA5+       5 35 C:STATA5+       4 15 C:STATA5+       4  7 C:STATA5
+       3 36 C:STATA5+       1 38 C:STATA5+       1 25 C:STATA5+       1 12 C:STATA5
+$     15  7 C:STATA5+WGHTD 15  4 C:STATA51      14 35 C:STATA51      13 28 C:STATA5
1      10  2 C:STATA51       6 12 C:STATA51       5 25 C:STATA51       3  5 C:STATA5
1$     10 25 C:STATA510     13 30 C:STATA510     13  9 C:STATA510     10 32 C:STATA5
10      9  6 C:STATA510      6 30 C:STATA510      4 17 C:STATA5100    14  4 C:STATA5
100    10 26 C:STATA5100     9 23 C:STATA5100     9  9 C:STATA5100     7 19 C:STATA5
100     3 10 C:STATA51000   13 17 C:STATA51000    2 39 C:STATA5101    10 33 C:STATA5
101     7 23 C:STATA5102    11  9 C:STATA5102     7 29 C:STATA5103    11 14 C:STATA5
104    11 17 C:STATA5105    11 21 C:STATA5106    12  2 C:STATA5107    12 31 C:STATA5
108    12 20 C:STATA5109    12 15 C:STATA511      8  6 C:STATA511      4 24 C:STATA5
110    14  6 C:STATA5110     7 33 C:STATA5110     3 15 C:STATA5111     7 31 C:STATA5
112     7 34 C:STATA5115     8  2 C:STATA5115     3 33 C:STATA512      8 16 C:STATA5
12$    10 34 C:STATA5120    15 19 C:STATA5120     8  3 C:STATA5120     3 38 C:STATA5
130     8  5 C:STATA5132     8  9 C:STATA5140    15 30 C:STATA5140     4 11 C:STATA5
145     4 16 C:STATA515     13  6 C:STATA515     10 38 C:STATA5150     4 22 C:STATA5
16     11  1 C:STATA52      13 31 C:STATA52      10  3 C:STATA52       3 11 C:STATA5
20     13 34 C:STATA520     11  2 C:STATA5200    14  8 C:STATA5200     9 25 C:STATA5
200     8 10 C:STATA5200     4 36 C:STATA521     14 36 C:STATA521     13 35 C:STATA5
210    14 10 C:STATA5210     8 15 C:STATA5210     4 38 C:STATA5212     5  2 C:STATA5
214     5  6 C:STATA522     15  1 C:STATA5220    14 14 C:STATA523     11  4 C:STATA5
230    14 16 C:STATA524     11  7 C:STATA525     11 11 C:STATA53      14  1 C:STATA5
3       6 15 C:STATA53       3 35 C:STATA5300     5 22 C:STATA5340    15 35 C:STATA5
4      14  3 C:STATA54       3 39 C:STATA540     11 13 C:STATA5400    16  3 C:STATA5
42     11 16 C:STATA545     11 20 C:STATA549     11 28 C:STATA5495    11 31 C:STATA5
5      14 11 C:STATA55       6 16 C:STATA55       4  3 C:STATA550     13 37 C:STATA5
50     13 11 C:STATA550      6 34 C:STATA5500    11 36 C:STATA554     12  1 C:STATA5
55     13 13 C:STATA555     12  3 C:STATA556     12  4 C:STATA56      14 13 C:STATA5
6       7 21 C:STATA56       4  5 C:STATA560     13 38 C:STATA560     13 14 C:STATA5
60     12  5 C:STATA560      7  1 C:STATA562      7  2 C:STATA56300    2 18 C:STATA5
64     12 19 C:STATA56400    2 26 C:STATA565      7  3 C:STATA57       7 24 C:STATA5
7       4  8 C:STATA570     12 25 C:STATA570      7  5 C:STATA575      7  7 C:STATA5
8       7 26 C:STATA58       4 10 C:STATA580     12 29 C:STATA580      7  9 C:STATA5
80      3  2 C:STATA5800    10 20 C:STATA5825    12 12 C:STATA583     12 18 C:STATA5
85      7 12 C:STATA585      3  4 C:STATA59       7 28 C:STATA59       4 14 C:STATA5
90      7 14 C:STATA590      3 14 C:STATA5900    16  4 C:STATA5900    14 18 C:STATA5
900    13 15 C:STATA5900    12 28 C:STATA5900     8 18 C:STATA5900     5 27 C:STATA5
900     4 27 C:STATA5910    16  5 C:STATA5910    14 24 C:STATA5920    14 27 C:STATA5
95      7 17 C:STATA5950    14 29 C:STATA5950    13 16 C:STATA5950     8 19 C:STATA5
950     5 28 C:STATA5950     4 28 C:STATA599      9  8 C:STATA5
C      12 10 C:STATA5C      12  8 C:STATA5C      12  6 C:STATA5C      11 39 C:STATA5
C      11 27 C:STATA5C      11 23 C:STATA5C      11 18 C:STATA5C      11 10 C:STATA5
C      11  6 C:STATA5C      11  5 C:STATA5C      10 39 C:STATA5C      10 37 C:STATA5
C      10 35 C:STATA5C      10 28 C:STATA5C       9 16 C:STATA5C       9 10 C:STATA5
C       9  2 C:STATA5C       7 35 C:STATA5C       6 28 C:STATA5C       6 10 C:STATA5
C       5 15 C:STATA5C       5 12 C:STATA5C       5  5 C:STATA5C       4 37 C:STATA5
C       4 25 C:STATA5C       4  1 C:STATA5C       3 30 C:STATA5C       3 28 C:STATA5
C       3 21 C:STATA5C       3 20 C:STATA5C       3 16 C:STATA5C       3  1 C:STATA5
C       2 24 C:STATA5C       2 23 C:STATA5C       2 16 C:STATA5C       2 15 C:STATA5
CM      9 17 C:STATA5CM      5 38 C:STATA5CM      5 31 C:STATA5CM      2  2 C:STATA5
CM      1 16 C:STATA5CM      1 10 C:STATA5CM      1  9 C:STATA5CM      1  7 C:STATA5
CM      1  3 C:STATA5CM1     5 37 C:STATA5CM1     2 10 C:STATA5CM1$    2 30 C:STATA5
CM25   15  2 C:STATA5CMC     9 15 C:STATA5CMCM   12 32 C:STATA5CMCM    5 32 C:STATA5
CMCM    2 31 C:STATA5CMCM    2 11 C:STATA5CMCM    1 35 C:STATA5CMCM    1 34 C:STATA5
CMCM    1 31 C:STATA5CMCM    1  4 C:STATA5CMCM    1  2 C:STATA5CMCMC   2 29 C:STATA5
CMCMCM  1 36 C:STATA5L      16 13 C:STATA5L      16  8 C:STATA5L      14 31 C:STATA5
L      13 20 C:STATA5L      12 37 C:STATA5L      10  5 C:STATA5L       9 34 C:STATA5
L       9 28 C:STATA5L       9 14 C:STATA5L       8 31 C:STATA5L       8 26 C:STATA5
L       8 21 C:STATA5L       5 39 C:STATA5L       5 30 C:STATA5L       4 30 C:STATA5
L       2 32 C:STATA5_1X)') 15 27 C:STATA5_DEVIA 15  8 C:STATA5
STATFIN ** FICHE/FRAME BREAK *****
STATA6
C:STATA6   07/07/72            STATPAK ANALYSIS OVERLAY SIX.
C
C
       OVERLAY STATA6,5
C
       NORMAL MODE IS INTEGER
C
C
       LOGICAL TALK,HUSH,ECHO,TTY
       INTEGER COM NO
       COMMON /SFE/TALK,HUSH,ECHO,TTY,COM NO
C
       INTEGER INPUT LINE(256), I SAVE(6)
       COMMON /LINE INPUT/INPUT LINE, I SAVE, I POINT, I COUNT, INDEX
C
       COMMON /CODE/MAX CODE, N CODE, CODE(200)
C
       LOGICAL FILE INPUT,  DATA IN,  INP OK,  APP OK
       LOGICAL NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC
       LOGICAL BACK UP
       LOGICAL FLAG 1,  FLAG 2
       REAL TAX,  MATRIX
C
       SHARE MATRIX(2048)
       SHARE $FILES,  /SFE/,  /LINE INPUT/
       SHARE /CODE/
       SHARE NAME(18)
       SHARE BEGIN(9),  IN FLOW,  OUT FLOW,  TAX COLUMN,  TAX
       SHARE TAX FREQUENCY
       SHARE TITLE(2),  CPL,  C COUNT,  FLAG 1(90),  FLAG 2(9)
       SHARE FILE INPUT,  DATA IN,  INP OK,  APP OK,  STATE
       SHARE NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC,  NO OF CASES
       SHARE P COLUMNS,  P ROWS,  MAX NAMES,  BACK UP
       SHARE NAMES(423),  NO OF COLUMNS,  NO OF ROWS
       SHARE NO OF PERIODS,  COLUMNS(2,208),  ROWS(2,-2:-1)
       SHARE OVERFLOW(27)
       SHARE CRAP(500)
C
C
       COMMON /STOR/STOR(272)
C
C
       GLOBAL IX(0/15),  NX,  IND
C
C
       LOGICAL GET F 2
C
C
C
       CONNECT OVERFLOW,  TYPE OVERFLOW;  STATE=2;  GO TO 1$
C
C
C
       IF CODE(2).EQ.61,  GO TO 6100
*
*
*
C      MULTIPLE
C ******************
*
6000   I=3
       NX=-1
C
       REPEAT 6010,  WHILE CODE(I).EQ.9
       IX(NX=NX+1)=CODE(I+1)
6010   I=I+2
C
       IND=NX
C
C
       CALL S MULTIPLE(1, CODE(I+1), CODE(I+2))
       GO TO 1$
*
*
*
C      STEPWISE
C ******************
*
6100   I=3
       NX=-1
       CALL INIT F 2(.FALSE.)
C
       REPEAT 6110,  WHILE CODE(I).EQ.9
       CALL SET F 2(CODE(I+1))
       IX(NX=NX+1)=CODE(I+1)
6110   I=I+2
C
C
       I=I+1
       IND=NX
C
       REPEAT 6120,  WHILE CODE(I).EQ.9
       CALL SET F 2(CODE(I+1))
       IND=IND+1
6120   I=I+2
C
C
       CALL STEPWISE(CODE(I+1), CODE(I+2))
       GO TO 1$
*
C
C
C
C      RETURN TO MAIN OVERLAY
C
1$     TERMINATE OVERLAY
C
C
       END
       SUBROUTINE S MULTIPLE(MM,IRES,IREG)
C      PERFORM MULTIPLE REGRESSION ANALYSIS
C      USING THE ABBREVIATED DOOLITTLE METHOD.
       REAL MSR,MST,MSE
       GLOBAL IND,NOOFRO,NOOFCO,IOFF(0/15),IX(0/15),RB(0/15),AY(0/15),BY(0/15),
NX,F,SSDR,RSQ,IY,STATE,COLUMNS(2,1),INP OK
       LOGICAL INP OK
       INTEGER STATE,COLUMNS
       COMMON /STOR/,C(0/15),SB(0/15),T(0/15),BETA(0/15),XBAR(0/15)
       INTEGER SYMOUT(2)
       DATA SYMOUT/'SYMOUT'/
C      MM = 1 MEANS NORMAL REGRESSION
C      MM = 0 MEANS SPECIAL ENTRY FROM STEPWISE TO DO CALCULATIONS
C      MM = -1 MEANS SPECIAL ENTRY FROM STEPWISE TO DO REGRESSION
C              AND OUTPUT.
C      MM=-2 MEANS ENTRY FROM STEPWISE TO PRINT DETAILS OF STEP ONLY.
       IF(MM.EQ.1) NX=IND
       IY=IX(0)
       NC=NOOFCO
       IF(NOOFRO.LE.IND+1) TYPE 5;STATE=2;RETURN
5      FORMAT(/$NO. OF OBSERVATIONS MUST BE GREATER THAN NO. OF INDEP.
     +VARIABLES+1./$)
C      INITIALIZE OFFSET ARRAY FOR ACCESS.
C      SPECIAL ENTRY FROM STEPWISE WILL COME HERE.
62     IOFF(0) = 1
       DO 12 I=1,IND
12     IOFF(I) = IOFF(I-1) + (IND-I+2)


C      D O   C A L C U L A T I O N S

       CALL DOOLIT(IY)
C      OUTPUT STANDARD STATISTICS FROM DATA IN
C      ARRAYS LEFT BY DOOLITTLE CALCULATION.
C      CALCULATE REGRESSION COEFFICIENTS.
       DO 13 I = NX,0,-1
       RB(I) = BY(I)
       DO 13 J = I+1,NX
13     RB(I) = RB(I)-RB(J)*B(I,J)
C      CALCULATE C(II) VALUES.
       DO 14 II = 0,NX
       C(II) = 0
       DO 14 K=0,NX
14     C(II) = C(II)+AP(K,II)*BP(K,II)
C      CALCULATE ANALYSIS OF VARIANCE TABLE
C      SUM OF SQUARES ATTRIBUTABLE TO REGRESSION = SSAR
       SSAR = 0
       DO 15 I = 1,NX
15     SSAR = SSAR+AY(I)*BY(I)
C      MEAN SQUARE ATTR. TO REG = MSR = SSAR/K
       MSR = SSAR/NX
C      SUM OF SQUARES DEVIATION FROM REGRESSION = SSDR = SSE
       SSDR = 0
       DO 16 I = 1,NOOFRO
16     SSDR = SSDR + (DATA(I,IY)-YHAT(I))**2
C      MEAN SQUARE DEVIATION FROM REGRESSION= MSE= SSDR/(N-K-1)
       MSE = SSDR/(NOOFRO-NX-1)
C      TOTAL SUM OF SQUARES = SST = SSAR+SSDR
C      TOTAL MEAN SQUARE= MST = SST/N-1
       SST = SSAR + SSDR
       MST = SST/(NOOFRO-1)
C      MULTIPLE INDEX OF DETERMINATION= RSQ = SSAR/SST
C      F-STATISTIC = F = (SSAR/SSDR)(N-K-1/K)
       IF(SST.EQ.0)RSQ=1;GO TO 381
       RSQ = SSAR/SST
381    IF (SSDR) 40,41,40
40     F = (SSAR/SSDR)*(NOOFRO-NX-1)/NX
C      STANDARD ERROR OS ESTIMATE = SE = (SSDR/N-K-1)**1/2
41     SE = SQRT(SSDR/(NOOFRO-NX-1))
C      ESTIMATED VARIANCE OF REGRESSION COEFFICIENT = SB(J)
       DO 17 J= 0,NX
       SB(J) = MSE * C(J)
C      COMPUTE T-VALUES FOR REGRESSION COEFFICIENTS.
       IF (SB(J)) 42,17,42
42     T(J) = RB(J)/SQRT(SB(J))
17     CONTINUE
C      END OF CALCULATIONS.
C      RETURN TO STEPWISE IF SPECIAL ENTRY FOR REGRESSION ONLY.
C      IF NORMAL REGRESSION OR ENTRY STEPWISE FOR REGRESSION
C      AND OUTPUT, GO ON TO OUTPUT
       IF(MM.EQ.-2) GO TO 39
       IF (MM) 63,64,63
64     RETURN


C      D O   O U T P U T

C      OUTPUT RSQ,F-STATISTIC,STANDARD ERROR OF ESTIMATE.
C      IF MSE WAS 0 THERE IS NO F-VALUE.
63     WRITE(-2, '(///13X$R-SQUARED =$F8.3)'),RSQ
       IF (MSE) 43,44,43
43     WRITE(-2,'(6X$F-VALUE($I2$,$I4$) =   $F.5)'),NX,NOOFRO-NX-1,F
44     WRITE(-2,'($STD. ERROR OF ESTIMATE =$1PG13.6/)'),SE
39       WRITE(-2, '(/13X$INTERCEPT =$1PG15.6/)'), RB(0)
C      OUTPUT TABLE WITH REGRESSION COEFFICIENTS AND T-VALUES.
       WRITE(-2,'(//$VARIABLE$7X$COEFFICIENT$Z)')
       IF (MSE) 45,46,45
C      IF MSE = 0 THERE ARE NO T-VALUES AT ALL.
45     WRITE(-2,'(7X$T-VALUE$Z)')
46     WRITE(-2, '(/)')
       DO 18 J= 1,NX
      WRITE(-2,'(2A3,8X1PG14.6,Z)')COLUMNS(1,IX(J)),COLUMNS(2,IX(J)),RB(J)
       IF (MSE) 47,18,47
C      IF MSE = 0 NEVER TYPE T-VALUE. IF NOT, THEN TYPE UNDEFINED
C      IF SB(J) = 0 INDICATING THAT THAT PARTICULAR T-VALUE WAS
C      NOT CALCULATED.
47     IF (SB(J)) 48,49,48
48     WRITE(-2, '(6X1PG13.6,Z)'),T(J)
       GO TO 18
49     WRITE(-2, '(8X$UNDEFINED$Z)')
18     WRITE(-2, '()')
C      OUTPUT ANALYSIS OF VARIANCE TABLE 
       WRITE(-2, '(///10X$ANALYSIS OF VARIANCE FOR THE REGRESSION$//3X
$SOURCE OF VARIATION$8X$D.F.    SUM OF SQ.$6X$MEAN SQ.$/
$ATTRIBUTABLE TO REGRESSION$I7,2(3X1PG13.6)/$DEVIATION FROM REGRESSION$
I8,2(3X1PG13.6))'),NX,SSAR,MSR,NOOFRO-NX-1,SSDR,MSE
       WRITE(-2, '(5X$TOTAL$15XI8,2(3X1PG13.6)//)')NOOFRO-1,SST,MST
       IF(MM.EQ.-2) RETURN
       IF(IREG.EQ.0) GO TO 3
       DO 4 I=0,NX
4      CALL STORE(I+1,IREG,RB(I))

C      O P T I O N A L  O U T P U T


C      ASK ABOUT OPTIONS.
3      WRITE(-2, '(/$PRINT VARIANCE OF REG. AND BETA 
COEFFICIENTS$Z)')
       IF (IANS(I)) 23,19,19
C      CALCULATE STANDARD DEVIATIONS OF Y'S AND X'S.
19     DO 21 J = 0,NX
       XSQ = 0
       XS = 0
       DO 20 I = 1,NOOFRO
       XSQ = XSQ + DATA(I,IX(J))**2
20     XS = XS + DATA(I,IX(J))
C      STORE STANDARD DEVIATION OF X(J) TEMPORARILY IN BETA.
21     BETA(J) = SQRT((XSQ-(XS**2/NOOFRO))/(NOOFRO-1))
       IF (BETA(0))51,52,51
51     DO 22 J = 1,NX
22     BETA(J) = BETA(J)*RB(J)/BETA(0)
52     WRITE(-2, '(/$VARIABLE$7X$VARIANCE$Z)')
       IF (BETA(0)) 53,54,53
53     WRITE(-2, '(7X$BETA COEFFICIENT$Z)')
54     WRITE(-2, '(/)')
       DO 56 J = 1,NX
      WRITE(-2,'(2A3,8X1PG13.6,Z)'),COLUMNS(1,IX(J)),COLUMNS(2,IX(J)),
     +SB(J)
       IF (BETA(0)) 55,56,55
55     WRITE(-2, '(5X1PG13.6,Z)'), BETA(J)
56     WRITE(-2,'()')
23     WRITE(-2, '(///$COMPUTE DURBIN-WATSON$Z)')
       IF (IANS(I)) 32,24,24
C
C      COMPUTE DURBIN-WATSON STATISTIC
24     DZ = 0
       Z = 0
       DO 26 I = 2,NOOFRO
       XDIF = 0
       DO 25 J = 1,NX
25     XDIF = XDIF + RB(J)*(DATA(I,IX(J))-DATA(I-1,IX(J)))
26     DZ = DZ+(DATA(I,IY)-DATA(I-1,IY)-XDIF)**2
C      CALCULATE MEANS FOR X'S AND Y.
       DO 31 J = 0,NX
       XBAR(J)=0
       DO 30 I=1,NOOFRO
30     XBAR(J) = XBAR(J) + DATA(I,IX(J))
31     XBAR(J) = XBAR(J)/NOOFRO
       DO 28 I=1,NOOFRO
       XDIF = 0
       DO 27 J = 1,NX
27     XDIF = XDIF+RB(J)*(DATA(I,IX(J))-XBAR(J))
28     Z = Z+(DATA(I,IY)-XBAR(0)-XDIF)**2
       IF (Z) 57,58,57
57     DW = DZ/Z
       WRITE(-2, '(/$DURBIN-WATSON =$F7.3/)'),DW
       GO TO 32
58     TYPE '(/$DURBIN-WATSON IS UNDEFINED$/)'
C      ASK ABOUT TABLE OF RESIDUALS
32     WRITE(-2, '(//$PRINT TABLE OF RESIDUALS$Z)')
       IF (IANS(I)) 36,33,33
33     WRITE(-2,'(//$Y OBSERVED     Y ESTIMATED       RESIDUAL$/)')
       DO 35 I = 1,NOOFRO
       YEST = YHAT(I)
35     WRITE(-2,'(1PG13.6,2(3X1PG13.6))'),DATA(I,IY),YEST,DATA(I,IY)-YEST
36     IF(IRES.EQ.0) GO TO 34
       DO 37 I=1,NOOFRO
       DIF=DATA(I,IY)-YHAT(I)
37     CALL STORE(I,IRES,DIF)
34     STATE=1
       IF(IRES.NE.0.OR.IREG.NE.0) INP OK=.FALSE.
       RETURN
       END



       FUNCTION YHAT(IR)
       GLOBAL RB(0/15),NX,IX(0/15)
C      CALCULATE ESTIMATED VALUE OF DEPENDENT VAAIABLE
C      Y FOR ROW IR.
       Y = RB(0)
       DO 1 J = 1,NX
1      Y =  Y+ RB(J)*DATA(IR,IX(J))
       YHAT = Y
       RETURN
       END



       SUBROUTINE DOOLIT(IY)
       DIMENSION ROW(0/15),PROW(0/15)
       GLOBAL G(0/15),AY(0/15),BY(0/15),NOOFRO,NX
C      PERFORM ABBREVIATED DOOLITTLE METHOD AS
C      SHOWN IN "STATISTICS IN RESEARCH BY  OSTLE, P. 79.
C      IY IS COLUMN NUMBER OF DEPENDENT VARIABLE.
C      NX IS NUMBER OF DEPENDENT VAR.
C      G,AY,BY MUST BE SIZE IND+1.
C      COMPUTE X'X = AI
       DO 1 I = 0,NX
       DO 1 J = 0,NX
       IF I.GT.J, GO TO 1
       SUM = 0
       DO 11 K = 1,NOOFRO
11     SUM = SUM + X(K,I)*X(K,J)
       CALL AIS(I,J,SUM)
1      CONTINUE
C      COMPUTE X'Y = G
       DO 2 I = 0,NX
       G(I) = 0
       DO 2 K = 1,NOOFRO
2      G(I) =G(I) + X(K,I)*DATA(K,IY)
C      DO TWO ROWS AT A TIME.  FIRST FRONT HALF, THEN
C      CONSTANT, THEN BACK HALF.  "I" TELLS WHICH 
C      PAIR OF ROWS.  "K" USED FOR SUBTRACTIONS OF
C      OLD ROWS. "J" USED TO SELECT ITEMS IN NEW ROW.
       DO 5 I = 0,NX
       DO 4 J = I,NX
       ROW(J) = AI(I,J)
       DO 3 K = 0,I-1
3      ROW(J) = ROW(J)-A(K,I)*B(K,J)
       CALL AS(I,J,ROW(J))
4      CALL BS(I,J,ROW(J)/A(I,I))
5      CONTINUE
       DO 7 I = 0,NX
       YROW = G(I)
       DO 6 K = 0,I-1
6      YROW = YROW-A(K,I)*BY(K)
       AY(I) = YROW
       BY(I) = YROW/A(I,I)
7      CONTINUE
       DO 10 I = 0,NX
       DO 9 J = 0,I
       PROW(J) =  BI(I,J)
       DO 8 K = O,I-1
8      PROW(J) = PROW(J)-A(K,I)*BP(K,J)
       CALL APS(I,J,PROW(J))
9      CALL BPS(I,J,PROW(J)/A(I,I))
10     CONTINUE
       RETURN
       END
C      THE FOLLOWING ARE FUNCTION SUBROUTINES FOR
C      ACCESSING AND STORING ARRAYSS USED DURING
C      ABBREVIATED  DOOLITTLE METHOD. IN ALL CASES, KNOWLEDGE
C      ABOUT SYMMETRY AND LOCATIONS OF 1'S AND 0'S
C      IS USED TO MINIMIZE ACTUAL STORAGE REQUIREMENTS.
C      "IND" IS USED TO REFER TO MAX. NO. OF INDEPENDENT VARIABLES.
C      ARRAY SIZE IS ((IND+1)**2-IND-1)/2+IND+1
       FUNCTION A(I,J)
       COMMON /STOR/,ARRAY(136)
       GLOBAL IOFF(0/15)
C      ACCESS ARRAY
C      SEE IF REFERENCE TO UNUSED AREA.
       A = ARRAY(IOFF(I)+J)
       RETURN

       SUBROUTINE AS(K,L,X)
C      STORE INTO ARRAY
       ARRAY(IOFF(K)+L) = X
       RETURN
       END


       FUNCTION B(I,J)
       DIMENSION ARRAY(136)
       GLOBAL IOFF(0/15)
C      ACCESS ARRAY.
       B = ARRAY(IOFF(I)+J)
       RETURN

       SUBROUTINE BS(K,L,X)
C      STORE IN TO ARRAY
       ARRAY(IOFF(K)+L) = X
       RETURN
       END


C      IN AP AND BP THE UPPER RIGHT OF ARRAY IS 
C      KNOWN TO BE ALWAYS ZERO, SO NOT STORED INTO AND
C      ZERO ALWAYS RETURNED  ON ACCESS.
       FUNCTION AP(I,J)
       GLOBAL IND,IOFF(0/15)
       DIMENSION ARRAY(136)
C      ACCESS ARRAY
       IF J.GT.I, AP = 0; RETURN
       AP = ARRAY(IOFF(IND-I)+J)
       RETURN

       SUBROUTINE APS(K,L,X)
C      STORE INTO ARRAY
       IF L.GT.K, RETURN
       ARRAY(IOFF(IND-K)+L) = X
       RETURN
       END


       FUNCTION BP(I,J)
       GLOBAL IND,IOFF(0/15)
       DIMENSION ARRAY(136)
C      ACCESS ARRAY
       IF J.GT.I, BP=0 ; RETURN
       BP = ARRAY(IOFF(IND-I)+J)
       RETURN

       SUBROUTINE BPS(K,L,X)
C      STORE INTO ARRAY
       IF L.GT.K, RETURN
       ARRAY(IOFF(IND-K)+L) = X
       RETURN
       END


       FUNCTION AI(I,J)
       GLOBAL IOFF(0/15)
       DIMENSION ARRAY(136)
C      ACCESS ARRAY
       AI = ARRAY(IOFF(I)+J)
       RETURN

       SUBROUTINE AIS(K,L,X)
C      STORE INTO ARRAY
       ARRAY(IOFF(K)+L) = X
       RETURN
       END


       FUNCTION BI(I,J)
       IF I.EQ.J, BI=1 ; RETURN
       BI = 0
       RETURN
       END

       FUNCTION X(I,J)
       GLOBAL IX(0/15)
C      FIRST COLUMN IS DUMMY WITH 1'S.
       IF J.EQ.0, X=1; RETURN
       X = DATA(I,IX(J))
       RETURN
       END



       FUNCTION IANS(IDUM)
       WRITE (-2,900)
       IANS=0
5      CALL NEWLINE(I)
       I=NOWCHR(0)
       IF(I-1RY)10,25,10
10     IF (I-1RN)15,20,15
15     TYPE 1010
       GO TO 5
20     IANS=-1
25     RETURN
900    FORMAT($? $,Z)
1010   FORMAT($ERROR. TYPE YES OR NO: $,Z)
       END


       SUBROUTINE STEPWISE(IRES,IREG)
C      PERFORM STEPWISE  REGRESSION BY CALLING MULTIPLE
C      REGRESSION ITERATIVELY
      GLOBAL IY,IX(0/15),NX,NOOFCO,NOOFRO,AY(0/15),BY(0/15),RSQ,F,SSDR
       GLOBAL STATE,COLUMNS(2,1),IND,INP OK
       LOGICAL INP OK
       INTEGER STATE,COLUMNS
       LOGICAL GET F 2
       NC=NOOFCO
       NEX=NOOFCO-IND
       IY=IX(0)
       IF(NOOFRO.LE.IND+1)STATE=2;TYPE15;RETURN
15     FORMAT(/$NO. OF OBSERVATIONS MUST BE GREATER THAN NO. OF INDEP.
     +VARIABLES+1.$/)
33     WRITE(-2,'(//$DO YOU WANT LIST OF STOPPING CRITERIA$Z)')
       IF (IANS(I)) 29,27,27
27     WRITE(-2, '(//5X$1- MANUAL$//$F-TEST FOR ENTIRE REGRESSION$/5X$
2- LOWER LIMIT ON ALPHA$/5X$3- INCREASE IN ALPHA$/5X$4- LIMIT 
ON CHANGE IN ALPHA$)')
       WRITE(-2, '(/$F-TEST FOR NEWLY CHOSEN VARIABLE$/5X$5- UPPER 
LIMIT ON ALPHA$//)')
29     WRITE(-2, '(/$CODE # FOR STOPPING: $Z)')
2000   FORMAT(/$MAXIMUM NUMBER OF INDEP.VARIABLES EXCEEDED.$/)
       CALL NEWLINE(NCHAR)
       ISTOP=NOWCHR(0)-20B
       IF NCHAR>0,  GO TO 30
28     TYPE 31
31     FORMAT('?')
       GO TO 29
30     GO TO (52,32,52) ISTOP, 32
32     WRITE(-2, '(/$LIMIT: $Z)')
       CALL NEWLINE(NCHAR)
       IF NCHAR>=0,  GO TO 35
34     TYPE 31
       GO TO 32
35     IF NUMBER(CALPHA),34,2033,52
2033   TYPE '(/$LIMIT MUST BE IN RANGE 0 TO 1$/)';GO TO 32
C      START WITH STEP 1 AND ALPHA =1
52     IF .NOT.0<=CALPHA<=1,GO TO 2033
       ISTEP=0
       ALREG = 1
C      INITIALIZE NEWLY CHOSEN VARIABLE AND ITS ASSOCIATED F AND ALPHA.
36     NEWVAR = 0
       ISTEP = ISTEP + 1
       ALOLD = ALREG
       OLDF = 0
C      DO MULTIPLE REGRESSION FRO EACH VARIABLE NOT EXCLUDED OR
C      ALREADY INCLUDED.  CHOOSE ONE WITH LARGEST F-VALUE.
       DO  39 I = 1,NC
C      CHECK LIST OF INCLUDED VARIABLES.
       DO 37 J=0,NX
37     IF IX(J).EQ.I, GO TO 39
C      CHECK LIST OF EXCLUDED VARIABLES
       IF .NOT.GET F 2(I),  GO TO 39
C      VARIABLE OK. ADD TO INCLUDED LIST AND TO REGRESSION.
       NX = NX+1
       IF NX.GT.IND, TYPE 2000; GO TO 47
       IX(NX) = I
       CALL S MULTIPLE(0,IRES,IREG)
C      SEE IF THIS BETTER THAN BEST F SO FAR.
C      IF SO SAVE VITAL  STATISTICS SO WON'T HAVE TO DO REGRESSION
C      AGAIN AT END OF SEARCH AT THIS STEP.
       IF F.GT.OLDF, GO TO 53
       GO TO 54
53     NEWVAR = I
       OLDF = F
       ORSQ = RSQ
       OVARF = AY(NX)*BY(NX)/SSDR*(NOOFRO-NX-1)
54     NX = NX-1
39     CONTINUE
C      MAKE SURE A VARIABLE WAS CHOSEN.
       IF (NEWVAR) 40,40,41
40     WRITE(-2, '(/$NO MORE VARIABLES AVAILABLE.$/)')
       GO TO 47
C      CALCULATE ALPHA FOR REGRESSION AND F-STATISTIC
C      AND ALPHA FOR NEWLY CHOSEN VARIABLE.
41     NX = NX+1
       IX(NX)=NEWVAR
       ALREG = 1-FTEST(NX,NOOFRO-NX-1,OLDF)
       ALVAR = 1-FTEST(1,NOOFRO-NX-1,OVARF)
       WRITE(-2,'(///$STEP$I4//$  VARIABLE  $2A3$ SELECTED$//
     + $FOR REGRESSION:F($I2$,$I4$) =$3XG.5/$  ALPHA=$F8.3/)'),
     + ISTEP,COLUMNS(1,IX(NX)),COLUMNS(2,IX(NX)),NX,NOOFRO-NX-1,
     +OLDF,ALREG
C      OUTPUT STATISTICS FOR THIS STEP
COLUMNS(2,IX(NX)),NX,NOOFRO-NX-1,OLDF,ALREG
       WRITE(-2,'($FOR NEW VARIABLE:  F(1,$I4$) =$3XF.5/$  ALPHA =$F8.3//
$R-SQUARED =$F8.3/)'), NOOFRO-NX-1,OVARF,ALVAR,ORSQ
       CALL S MULTIPLE(-2,IRES,IREG)
C      TEST STOPPING  MODE.
       GO TO (42,43,44,45,46) ISTOP,42
C      MANUAL. IF NO STOP, GO GET NEW VARIABLE.
42     WRITE(-2, '(/$STOP$Z)')
       IF (IANS(I)) 36,47,47
C      F FOR REGRESSION. LOWER LIMIT ON ALPHA.
43     IF ALREG.LT.CALPHA, GO TO 47
       GO TO 36
C      F FOR REGRESSION. ALPHA INCREASES.
44     IF ALREG.GT.ALOLD, GO TO 47
       GO TO 36
C      F FOR REGRESSION. LOWER LIMIT ON CHANGE IN ALPHA.
45     IF ((ALOLD-ALREG).LT.CALPHA), GO TO 47
       GO TO 36
C      F FOR NEW VARIALBE. ALPHA EXCEED UPPER LIMIT.
46     IF ALVAR.GT.CALPHA, GO TO 47
       GO TO 36
C      STEPPINF FINISHED. ASK ABOUT LAST VARIABLE.
47     WRITE(-2, '(//$STEPPING COMPLETED$//$INCLUDE LAST VARIABLE$Z)')
       IF (IANS(I)) 48,49,49
C      DON'T INCLUDE LAST VARIABLE
48     NX = NX-1
49     CALL S MULTIPLE(-1,IRES,IREG)
51     STATE=1
       IF(IRES.NE.0.OR.IREG.NE.0) INP OK=.FALSE.
       END
       FUNCTION FTEST(M,N,X)
C      CALCULATE CONFIDENCE LEVEL FOR FISHER'S F-
C      DISTRIBUTION WITH M AND N DEGREES OF FREEDOM.
C      CAL CULATEDD P(F<X). BY CALLING FTEST(1,N,T**2),
C      STUDENT'S T-DISTRIBUTION WILL BE OBTAINED.
C      ALGORITHM FROM COMMUN. OF ACM,VOL.11,NO. 2,FEB. 1968,P.116
       INTEGER A,B
       A = 2*(M/2)-M+2
       B = 2*(N/2)-N+2
       W = X*M/N
       Z = 1/(1+W)
       IF A#1, GO TO 2
       IF B#1, GO TO 1
       P = SQRT(W)
       Y = .3183098862
       D = Y*Z/P
       P = 2*Y*ATAN(P)
       GO TO 4
1      P = SQRT(W*Z)
       D = .5*P*Z/W
       GO TO 4
2      IF B#1, GO TO 3
       P = SQRT(Z)
       D = .5*Z*P
       P = 1-P
       GO TO 4
3      D = Z*Z
       P = W*Z
4      Y = 2*W/Z
       DO 5 J = B+2,N,2
       D = (1+A/(J-2))*D*Z
       IF A.EQ.1, P = P+D*Y/(J-1); GO TO 5
       P = (P+W)*Z
5      CONTINUE
       Y = W*Z
       Z = 2/Z
       B = N-2
       DO 6 I=A+2,M,2
       J = I+B
       D = Y*D*J/(I-2)
       P = P-Z*D/J
6      CONTINUE
       FTEST = P
       RETURN
       END
       SUBROUTINE STORE(I,J,X)
       REAL MATRIX
       GLOBAL NO OF COLUMNS,  MATRIX(1)
       MATRIX(J+NO OF COLUMNS*(I-1))=X
       RETURN

       REAL FUNCTION DATA(L,M)
       DATA=MATRIX(M+NO OF COLUMNS*(L-1))
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
STATA6 SYMSORT

SYM.  PG.LN. IDENT.

+       1 25 C:STATA6+       1 12 C:STATA61      15 35 C:STATA61       8 24 C:STATA6
1       8  1 C:STATA610     12 10 C:STATA610      9 17 C:STATA61010   12 16 C:STATA6
11      8 22 C:STATA612      3 23 C:STATA613      3 35 C:STATA614      4  1 C:STATA6
15     12 32 C:STATA615     12 11 C:STATA615      4  6 C:STATA616      4 12 C:STATA6
17      4 33 C:STATA618      5 29 C:STATA619      6  8 C:STATA62      15 38 C:STATA6
2       8 29 C:STATA62-     12 37 C:STATA620     12 13 C:STATA620      6 13 C:STATA6
2000   13  3 C:STATA62033   13 17 C:STATA621      6 15 C:STATA622      6 18 C:STATA6
23      6 29 C:STATA624      6 32 C:STATA625     12 14 C:STATA625      6 37 C:STATA6
26      6 38 C:STATA627     12 36 C:STATA627      7  9 C:STATA628     13  7 C:STATA6
28      7 10 C:STATA629     13  2 C:STATA63      16  4 C:STATA63       8 38 C:STATA6
3       6  5 C:STATA630     13 10 C:STATA630      7  4 C:STATA631     13  8 C:STATA6
31      7  5 C:STATA632     13 11 C:STATA632      7 17 C:STATA633     12 34 C:STATA6
33      7 19 C:STATA634     13 14 C:STATA634      7 27 C:STATA635     13 16 C:STATA6
35      7 22 C:STATA636     13 23 C:STATA636      7 23 C:STATA637     13 32 C:STATA6
37      7 26 C:STATA6381     4 23 C:STATA639     14 11 C:STATA639      5 12 C:STATA6
4      16  6 C:STATA64       9  1 C:STATA64       5 38 C:STATA640     14 14 C:STATA6
40      4 24 C:STATA641     14 18 C:STATA641      4 26 C:STATA642     14 33 C:STATA6
42      4 32 C:STATA643     14 36 C:STATA643      5 10 C:STATA644     14 39 C:STATA6
44      5 11 C:STATA645     15  3 C:STATA645      5 17 C:STATA646     15  6 C:STATA6
46      5 18 C:STATA647     15  9 C:STATA647      5 25 C:STATA648     15 12 C:STATA6
48      5 26 C:STATA649     15 13 C:STATA649      5 28 C:STATA65      16 11 C:STATA6
5      12  7 C:STATA65       9  2 C:STATA65       3 17 C:STATA651     15 14 C:STATA6
51      6 17 C:STATA652     13 19 C:STATA652      6 19 C:STATA653     14  6 C:STATA6
53      6 21 C:STATA654     14 10 C:STATA654      6 22 C:STATA655      6 27 C:STATA6
56      6 28 C:STATA657      7 12 C:STATA658      7 15 C:STATA66      16 19 C:STATA6
6       9  6 C:STATA66000    2  3 C:STATA66010    2  7 C:STATA66100    2 17 C:STATA6
6110    2 23 C:STATA66120    2 29 C:STATA662      3 21 C:STATA663      5  8 C:STATA6
64      5  1 C:STATA67       9  9 C:STATA68       9 14 C:STATA69       9 16 C:STATA6
900    12 15 C:STATA6C      15 22 C:STATA6C      15 21 C:STATA6
C      15 20 C:STATA6C      15 19 C:STATA6C      15 18 C:STATA6C      15 11 C:STATA6
C      15  8 C:STATA6C      15  5 C:STATA6C      15  2 C:STATA6C      14 38 C:STATA6
C      14 35 C:STATA6C      14 32 C:STATA6C      14 30 C:STATA6C      14 26 C:STATA6
C      14 17 C:STATA6C      14 16 C:STATA6C      14 12 C:STATA6C      14  3 C:STATA6
C      14  2 C:STATA6C      14  1 C:STATA6C      13 35 C:STATA6C      13 33 C:STATA6
C      13 30 C:STATA6C      13 28 C:STATA6C      13 27 C:STATA6C      13 22 C:STATA6
C      13 18 C:STATA6C      12 22 C:STATA6C      12 21 C:STATA6C      11 35 C:STATA6
C      11 21 C:STATA6C      11 16 C:STATA6C      11  6 C:STATA6C      10 39 C:STATA6
C      10 29 C:STATA6C      10 23 C:STATA6C      10 19 C:STATA6C      10 18 C:STATA6
C      10 17 C:STATA6C      10 11 C:STATA6C      10  6 C:STATA6C       9 36 C:STATA6
C       9 31 C:STATA6C       9 30 C:STATA6C       9 26 C:STATA6C       9 25 C:STATA6
C       9 24 C:STATA6C       9 23 C:STATA6C       9 22 C:STATA6C       9 21 C:STATA6
C       9 20 C:STATA6C       8 33 C:STATA6C       8 32 C:STATA6C       8 31 C:STATA6
C       8 30 C:STATA6C       8 25 C:STATA6C       8 16 C:STATA6C       8 15 C:STATA6
C       8 14 C:STATA6C       8 13 C:STATA6C       8 12 C:STATA6C       8 11 C:STATA6
C       7 37 C:STATA6C       7 36 C:STATA6C       7 16 C:STATA6C       6 39 C:STATA6
C       6 14 C:STATA6C       6  7 C:STATA6C       6  4 C:STATA6C       6  1 C:STATA6
C       5 30 C:STATA6C       5 24 C:STATA6C       5 23 C:STATA6C       5 22 C:STATA6
C       5 16 C:STATA6C       5 13 C:STATA6C       5  7 C:STATA6C       5  6 C:STATA6
C       5  4 C:STATA6C       4 37 C:STATA6C       4 36 C:STATA6C       4 35 C:STATA6
C       4 34 C:STATA6C       4 30 C:STATA6C       4 27 C:STATA6C       4 25 C:STATA6
C       4 20 C:STATA6C       4 19 C:STATA6C       4 16 C:STATA6C       4 15 C:STATA6
C       4 13 C:STATA6C       4  9 C:STATA6C       4  7 C:STATA6C       4  3 C:STATA6
C       4  2 C:STATA6C       3 36 C:STATA6C       3 31 C:STATA6C       3 30 C:STATA6
C       3 29 C:STATA6C       3 26 C:STATA6C       3 20 C:STATA6C       3 19 C:STATA6
C       3 12 C:STATA6C       3 11 C:STATA6C       3 10 C:STATA6C       3  9 C:STATA6
C       3  8 C:STATA6C       2 38 C:STATA6C       2 37 C:STATA6C       2 15 C:STATA6
C       2 14 C:STATA6C       2  1 C:STATA6C       1 39 C:STATA6CM      2 26 C:STATA6
CM      2 20 C:STATA6CM      2  8 C:STATA6CM      2  5 C:STATA6CM      1 16 C:STATA6
CM      1 10 C:STATA6CM      1  9 C:STATA6CM      1  7 C:STATA6CM      1  3 C:STATA6
CM1$    2 34 C:STATA6CMC     6 31 C:STATA6CMCM    2 35 C:STATA6CMCM    2 30 C:STATA6
CMCM    2 24 C:STATA6CMCM    2  9 C:STATA6CMCM    1 33 C:STATA6CMCM    1 32 C:STATA6
CMCM    1 31 C:STATA6CMCM    1  4 C:STATA6CMCM    1  2 C:STATA6CMCMCM  2 33 C:STATA6
CMCMCM  1 35 C:STATA6CMCMCM  1 34 C:STATA6L      16 23 C:STATA6L      15 17 C:STATA6
L      12 20 C:STATA6L      12  4 C:STATA6L      11 33 C:STATA6L      11 27 C:STATA6
L      11 20 C:STATA6L      11 13 C:STATA6L      11  5 C:STATA6L      10 36 C:STATA6
L      10 28 C:STATA6L      10 20 C:STATA6L      10 10 C:STATA6L      10  3 C:STATA6
L       9 35 C:STATA6L       9 27 C:STATA6L       8  8 C:STATA6L       7 34 C:STATA6
L       2 36 C:STATA6LIMIT  13  1 C:STATA6ON     12 38 C:STATA6OTTRIB  5 33 C:STATA6
SOURCE  5 32 C:STATA6V-SQUA 14 28 C:STATA6_8,2(3  5 34 C:STATA6_OEFFI  6  6 C:STATA6
_OLUMN 14 27 C:STATA6_X,F,S  3  2 C:STATA6
STATFIN ** FICHE/FRAME BREAK *****
STATA8
C:STATA8   08/11/72            STATPAK ANALYSIS OVERLAY EIGHT.
C
C
       OVERLAY STATA8,5
C
       NORMAL MODE IS INTEGER
C
C
       LOGICAL TALK,HUSH,ECHO,TTY
       INTEGER COM NO
       COMMON /SFE/TALK,HUSH,ECHO,TTY,COM NO
C
       INTEGER INPUT LINE(256), I SAVE(6)
       COMMON /LINE INPUT/INPUT LINE, I SAVE, I POINT, I COUNT, INDEX
C
       COMMON /CODE/MAX CODE, N CODE, CODE(200)
C
       LOGICAL FILE INPUT,  DATA IN,  INP OK,  APP OK
       LOGICAL NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC
       LOGICAL BACK UP
       LOGICAL FLAG 1,  FLAG 2
       REAL TAX,  MATRIX
C
       SHARE MATRIX(2048)
       SHARE $FILES,  /SFE/,  /LINE INPUT/
       SHARE /CODE/
       SHARE NAME(18)
       SHARE BEGIN(9),  IN FLOW,  OUT FLOW,  TAX COLUMN,  TAX
       SHARE TAX FREQUENCY
       SHARE TITLE(2),  CPL,  C COUNT,  FLAG 1(90),  FLAG 2(9)
       SHARE FILE INPUT,  DATA IN,  INP OK,  APP OK,  STATE
       SHARE NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC,  NO OF CASES
       SHARE P COLUMNS,  P ROWS,  MAX NAMES,  BACK UP
       SHARE NAMES(423),  NO OF COLUMNS,  NO OF ROWS
       SHARE NO OF PERIODS,  COLUMNS(2,208),  ROWS(2,-2:-1)
       SHARE OVERFLOW(27)
       SHARE CRAP(500)
C
       GLOBAL NO OF NAMES
C
C
       REAL MKREAL
C
C
       CONNECT OVERFLOW, TYPE OVERFLOW;  STATE=2;  GO TO 1$
C
C
C
       IF CODE(2)#68,  GO TO 6900
*
*
*
C      XPOS
C **************
*
6800   IF CODE(3).EQ.1,  GO TO 6810
       CALL XPOS(MATRIX, CODE(5), CODE(7), CODE(9),
+              CODE(10), CODE(11), CODE(N CODE))
       GO TO 1$
C
C
6810   CALL XPOSPM(MATRIX, CODE(5), CODE(7), CODE(9),
+              MKREAL(CODE(11)),  CODE(13), CODE(14), CODE(N CODE),
+              .FALSE.)
       GO TO 1$
*
*
*
C      FORCAST
C *****************
*
6900   NO OF NAMES=0
       GO TO (6910, 6920, 6930, 6940),  CODE(9),  6950
C
C
6910   CALL STEP(MATRIX)
       GO TO 6990
C
C
6920   CALL LINEAR(MATRIX)
       GO TO 6990
C
C
6930   CALL POLY(MATRIX)
       GO TO 6990
C
C
6940   CALL XPOSPM(MATRIX, CODE(11), CODE(13), CODE(15), 0.0, 0,
+              CODE(5), CODE(4), .TRUE.)
       GO TO 6995
C
C
6950   CALL NON LINEAR(MATRIX)
       GO TO 6991
C
C
6990   STATE=1
6991   DATA IN=APP OK=.TRUE.
       INP OK=.FALSE.
6995   GO TO 1$
*
C
C
C
C      RETURN TO MAIN OVERLAY
C
1$     TERMINATE OVERLAY
C
C
       END
STATFIN ** FICHE/FRAME BREAK *****
STATA8 SYMSORT

SYM.  PG.LN. IDENT.

+       2 25 C:STATA8+       2  8 C:STATA8+       2  7 C:STATA8+       2  4 C:STATA8
+       1 25 C:STATA8+       1 12 C:STATA86800    2  2 C:STATA86900    2 16 C:STATA8
6991    2 30 C:STATA86995    2 32 C:STATA8C       2 14 C:STATA8
C       2 13 C:STATA8C       1 39 C:STATA8C       1 38 C:STATA8CM      1 31 C:STATA8
CM      1 16 C:STATA8CM      1 10 C:STATA8CM      1  9 C:STATA8CM      1  7 C:STATA8
CM      1  3 C:STATA8CM1$    2 35 C:STATA8CMCM    2 36 C:STATA8CMCM    1 33 C:STATA8
CMCM    1 32 C:STATA8CMCM    1  4 C:STATA8CMCM    1  2 C:STATA8CMCM68  2  6 C:STATA8
CMCM69  2 29 C:STATA8CMCM69  2 27 C:STATA8CMCM69  2 24 C:STATA8CMCM69  2 22 C:STATA8
CMCM69  2 20 C:STATA8CMCM69  2 18 C:STATA8CMCMCM  2 34 C:STATA8CMCMCM  1 34 C:STATA8

STATFIN ** FICHE/FRAME BREAK *****
STATA8FUNS
C:STATA8FUNS   06/03/72
C
C
       SUBROUTINE ADD SYMBOL(A)
C
C
       NORMAL MODE IS INTEGER
C
       LOGICAL TALK,HUSH,ECHO,TTY
       INTEGER COM NO
       COMMON /SFE/TALK,HUSH,ECHO,TTY,COM NO
C
       COMMON /CODE/MAX CODE, N CODE, CODE(1)
C
       GLOBAL NO OF NAMES
C
       INTEGER A(2),  NAMES(2,15)
       REAL VALUE(2,15),  X
C
       LOGICAL GET LINE,  END LINE
       REAL MKREAL
       EXTERNAL END LINE
C
C
       DO 10 I=1, NO OF NAMES
       IF NAMES(1,I)#A(1),  GO TO 10
       IF NAMES(2,I).EQ.A(2),  GO TO 20
10     CONTINUE
C
C
       NO OF NAMES=NO OF NAMES+1
       NAMES(1, NO OF NAMES)=A(1)
       NAMES(2, NO OF NAMES)=A(2)
C
C
15     IF TALK,  CALL DISPLAY(' START && STEP FOR /'),  DISSYM(A),
+              DISPLAY(': /')
C
       IF .NOT.GET LINE(I),  TALK=.TRUE.;  HUSH=.FALSE.;  GO TO 15
       IF I<=0,  GO TO 15
       IF NUMBER(X)>=0,  GO TO 18
17     CALL OUTPUT(1,'$NOT A VALID NUMBER.$$/')
       CALL SFE CLEAR
       GO TO 15
C
18     VALUE(1, NO OF NAMES)=X
C
       CALL KOMMA(0)
       IF NUMBER(X)<0,  GO TO 17
       VALUE(2, NO OF NAMES)=X
C
C
20     RETURN
       REAL FUNCTION GET SYMBOL(B,K)
C
       INTEGER B(2)
C
C
       DO 10 I=1, NO OF NAMES
       IF NAMES(1,I)#B(1),  GO TO 10
       IF NAMES(2,I).EQ.B(2),  GO TO 20
10     CONTINUE
C
       I=I-1
C
C
20     GET SYMBOL=VALUE(1,I)+(K-1)*VALUE(2,I)
C
       RETURN
C
       END
STATFIN ** FICHE/FRAME BREAK *****
STATA8FUNS SYMSORT

SYM.  PG.LN. IDENT.

+       1 22 _:STATA810      1 39 _:STATA810      1 17 _:STATA817      1 26 _:STATA8
CM      2  4 _:STATA8CM      2  3 _:STATA8CM      2  1 _:STATA8
CM      1 35 _:STATA8CM      1 30 _:STATA8CM      1 23 _:STATA8CM      1 11 _:STATA8
CM      1  9 _:STATA8CM      1  8 _:STATA8CM      1  7 _:STATA8CM      1  4 _:STATA8
CM18    1 29 _:STATA8CMCM    1 36 _:STATA8CMCM    1 18 _:STATA8CMCM    1 14 _:STATA8
CMCM    1  3 _:STATA8CMCM    1  2 _:STATA8CMCM15  1 21 _:STATA8CMCM20  2  2 _:STATA8
CMCM20  1 33 _:STATA8L       1 34 _:STATA8
STATFIN ** FICHE/FRAME BREAK *****
TAXCOM
       SUBROUTINE TAXCOM(T)
       GLOBAL TAXFREQ,NOOFRO,BUFFER(360)
       INTEGER TAXFREQ
       IF(NOOFRO.GT.360) CALL FATALE(3)
10     I=1
15     TOTAL=0.
       IT=0
20     TOTAL=TOTAL+BUFFER(I)
       IT=IT+1
       IF(I.EQ.NOOFRO.OR.IT.EQ.TAXFREQ) GO TO 50
       I=I+1
       GO TO 20
50     IF(TOTAL.LE.0.) GO TO 60
       BUFFER(I)=BUFFER(I)-T*TOTAL
60       IF(I.EQ.NOOFRO)GO TO 1000
       I=I+1
       GO TO 15
1000   RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
TAXCOM SYMSORT

SYM.  PG.LN. IDENT.

10      1  5         1000    1 18         15      1  6         20      1  8         
50      1 13         60      1 15         
STATFIN ** FICHE/FRAME BREAK *****
TYMFLOW
C:TYMFLOW   10/21/72           MAIN OVERLAY.
C
C
       OVERLAY TYMFLOW,5
C
       NORMAL MODE IS INTEGER
C
C
       LOGICAL TALK,HUSH,ECHO,TTY
       INTEGER COM NO
       COMMON /SFE/TALK,HUSH,ECHO,TTY,COM NO
C
       INTEGER INPUT LINE(256), I SAVE(6)
       COMMON /LINE INPUT/INPUT LINE, I SAVE, I POINT, I COUNT, INDEX
C
       COMMON /CODE/MAX CODE, N CODE, CODE(180)
C
       LOGICAL FILE INPUT,  DATA IN,  INP OK,  APP OK
       LOGICAL NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC
       LOGICAL BACK UP,  COMPARE,  FINPAK,  IST ANALYSIS,  BAD FILE
       LOGICAL FLAG 1,  FLAG 2
       REAL X
       REAL TAX,  MATRIX
C
       SHARE MATRIX(2048)
       SHARE $FILES,  /SFE/,  /LINE INPUT/
       SHARE /CODE/
       SHARE FINPAK
       SHARE ANALYSIS(14),  NO OF ANALYSIS,  FILE NO,  COMPARE
       SHARE IST ANALYSIS,  BAD FILE
       SHARE NAME(18)
       SHARE BEGIN(9),  IN FLOW,  OUT FLOW,  TAX COLUMN,  TAX
       SHARE TAX FREQUENCY
       SHARE TITLE(2),  CPL,  C COUNT,  FLAG 1(90),  FLAG 2(9)
       SHARE FILE INPUT,  DATA IN,  INP OK,  APP OK,  STATE
       SHARE NORMAL,  PROBABILISTIC,  MULTIPLE,  PARAMETRIC,
+              TRIANGULAR,  SPECIAL,  SYMMETRIC,  NO OF CASES
       SHARE P COLUMNS,  P ROWS,  MAX NAMES,  BACK UP
       SHARE NAMES(423),  NO OF COLUMNS,  NO OF ROWS
       SHARE NO OF PERIODS,  COLUMNS(2,208),  ROWS(2,-2:-1)
       SHARE OVERFLOW(27)
       SHARE CRAP(500)
C
       DATA MAX CODE/178/,  CPL/72/,  MAX NAMES/200/
       DATA DATA IN, APP OK/.FALSE./,  INP OK/.TRUE./
       DATA BACK UP/.FALSE./,  COMPARE/.FALSE./
       DATA OVERFLOW/'(/"COMPUTATION PRODUCED EXCESSIVELY LARGE OR
 SMALL NUMBER."/"COMMAND ABORTED."/)'/
C
       GLOBAL NAME SZ
C
       GLOBAL LINK ERR
       DATA LINK ERR/99$/
C
       INTEGER SCR FILE(5)
       GLOBAL HELP FILE(15)
       DATA HELP FILE/'(PAUL)TYMINFO'/,  SCR FILE/"STATPAK'SCR'"/
C
       GLOBAL SHIFT(3),  DIST(6)
       DATA SHIFT/16, 8, 0/,  DIST/15, 12, 3*15, 9/
C
       GLOBAL MAIN(2),  LRANGE(2),  URANGE(2),  FREQ(2),  LOAD(2)
       DATA MAIN/'MAIN'/,  LOAD/'LOAD'/
       DATA LRANGE/'LRANGE'/,  URANGE/'URANGE'/,  FREQ/'FREQ'/
C
       INTEGER A NAMES(2,14),  A COLUMNS(14),  N A COLUMNS(2,16)
       DATA ((A NAMES(I,J), I=1,2), J=1,11)/
+              3HPVA,1HL, 3HNPV,2HAL, 3HFVA,1HL, 3HNFV,2HAL,
+              3HARR,0H, 3HIRR,0H, 3HARR,0H, 3HPAY,3HBAK,
+              3HRRI,2HSK, 3HORI,2HSK, 3HPAR,2HEM/
       DATA (A COLUMNS(I), I=1,11)/11B, 21B, 31B, 41B, 51B, 61B, 71B,
+              101B, 113B, 143B, 172B/
       DATA ((N A COLUMNS(I,J), I=1,2), J=1,16)/
+              3HPVA,1HL, 3HNPV,2HAL, 3HFVA,1HL, 3HNFV,2HAL,
+              3HARA,2HTE, 3HIRA,2HTE, 3HERA,2HTE, 3HPAY,3HBAK,
+              3HRRE,3HTRN, 3HRRI,2HSK, 3HLBO,3HUND,
+              3HORE,3HTRN, 3HORI,2HSK, 3HUBO,3HUND,
+              3HRET,2HRN, 3HRIS,1HK/
C
       LOGICAL FLAG
C
       LOGICAL SFEWP,  ISTTY,  OPEN DATA,  PARSE,  CK FILE
       EXTERNAL CK FILE
       REAL MKREAL
C
C
       CALL SFE INITIALIZE
       COM NO=1
C
1$     CALL SET ESCAPE(3$)
C
C
2$     IF COMPARE,  GO TO COM LABEL
       IF DATA IN .AND. (NO OF ROWS .EQ. 0 .OR. NO OF COLUMNS .EQ. 0),
+              CALL INIT MATRIX
       IF .NOT.SFEWP(MAIN),  GO TO 2$
C
C
C
10     GO TO ( 100,  200,  300,  400,  500,  600,  700,  800,  900,
+             1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800,
+             1900, 2000, 6900, 2200),  CODE(2),  20
C
C
20     GO TO (2400, 2500, 2600, 2700, 2800, 2900, 3000, 3100, 3200,
+             3300, 3400, 3500, 3600, 3700, 3800, 3900, 4000, 4100,
+             4200, 4300, 4400, 4500, 4600, 4700),  CODE(2)-23,  30
C
C
30     GO TO (5000, 5100, 5200, 5300, 5400, 5500, 5600, 5700, 5800,
+             5900, 6000, 6100, 6200, 6300, 6400, 6500, 6600, 6700,
+             6800, 6900),  CODE(2)-49, 2$
C
C
3$     CLOSE
       STATE=3
       GO TO 2$
C
C
4$     CLOSE
5$     ESCAPE ON
       GO TO 2$
C
C
6$     CALL BRS(14,0,0,-1)
7$     IF .NOT.COMPARE,  COM NO=COM NO+1
       GO TO 2$
C
C
8$     CALL SFE CLEAR
       GO TO 2$
C
C
9$     ESCAPE ON
       GO TO 7$
*
*
*
C      LOAD
C **************
*
C
C TRY TO OPEN A STRUCTURE FILE.
C
100    CALL ADD TO FILE(CODE(4), NAME, 3HNAM)
       OPEN INPUT,3 :  NAME,  ERROR GO TO 150
C
C NOW GET THE DATA FILE.
C
       CALL ADD TO FILE(CODE(4), NAME, 3HDAT)
       OPEN INPUT,2 :  NAME,  ERROR CALL ERROR(4);  GO TO 130
C
C OK, READ THE STRUCTURE FILE.
C
       CALL READ STRUCTURE(130S)
C
C LOAD THE DATA.
C
       CALL S LOAD
       IF STATE>1,  GO TO 3$
C
C SIGNAL DATA IN AND RETURN TO COMMAND LEVEL.
C
110    DATA IN=APP OK=.TRUE.
120    IF .NOT.COMPARE,  COM NO=COM NO+1
       GO TO 4$
C
C
130    STATE=2
       GO TO 3$
C
C
C
C NO STRUCTURE FILE.  TRY FOR A REGULAR FILE.
C
150    OPEN INPUT,2 :  SOURCE CODE(5),  ERROR CALL ERROR(5);  GO TO 130
C
C SIGNAL FILE INPUT AND JOIN INPUT.
C
       FILE INPUT=.TRUE.
       GO TO 210
*
*
*
C      INPUT
C ***************
*
C
C SIGNAL TERMINAL INPUT.
C
200    FILE INPUT=.FALSE.
C
C GET A STRUCTURE FOR THE MATRIX.
C
210    CALL GET STRUCTURE(130S)
C
C CALL DATA MODULE.
C
       OVERLAY WITH 'INPUT'
       IF STATE>1,  GO TO 3$
       GO TO 110
*
*
*
C      SAVE
C **************
*
300    IF CODE((CODE(4)+17)/3)#0,  GO TO 350
C
C GET THE FILES OPEN AND GRAP THE ESCAPE.
C
       IF .NOT.OPEN DATA(320S),  GO TO 2$
C
C WRITE THE STRUCTURE FILE.
C
       CALL WRITE STRUCTURE
C
C GO WRITE THE DATA FILE.
C
       OVERLAY WITH 'SAVE1'
C
C RETURN TO COMMAND LEVEL.
C
310    INP OK=.TRUE.
315    CALL SET ESCAPE(3$)
       GO TO 120
C
C ESCAPE RECEIVED.
C
320    CALL SET ESCAPE(3$)
       GO TO 5$
C
C
C OPEN A DATA FILE AFTER PROMPTING WITH THE  'OLD/NEW' MESSAGE.
C
350    (  NAME(I)=CODE(I+4)  ),  I=1, (CODE(4)+2)/3
       NAME(I)=0
C
       NAME SZ=CODE(4)
       IF .NOT.CK FILE,  GO TO 2$
C
       CALL SET ESCAPE(390S)
C
       OPEN OUTPUT,2 :  NAME,  ERROR CALL ERROR(16);  GO TO 1$
C
C      GO WRITE THE DATA OUT.
C
       OVERLAY WITH 'SAVE2'
       GO TO 315
C
C
390    ESCAPE OFF
       CLOSE
       CALL IADEL(NAME)
       GO TO 320
*
*
*
C      APPEND
C ****************
*
400    CODE(1)=-1
       I=4
C
410    IF CODE(I)#6,  GO TO 420
C
C OPEN THE DATA FILE.
C
       OPEN INPUT,2 : SOURCE CODE(I+2), ERROR CALL ERROR(14); GO TO 2$
C
C SIGNAL FILE INPUT.
C
       FILE INPUT=.TRUE.
       GO TO 430
C
C CALL DATA MODULE.
C
420    FILE INPUT=.FALSE.
C
430    OVERLAY WITH 'APPEND'
C
440    IF STATE>1,  GO TO 3$
       INP OK=.FALSE.
       GO TO 120
*
*
*
C      LIST
C **************
*
500    CODE(1)=-1
C
510    OVERLAY WITH 'LIST'
       IF STATE>1,  GO TO 2$
       GO TO 6$
*
*
*
C      FAST
C **************
*
600    CODE(1)=0
       GO TO 510
*
*
*
C      INSERT
C ****************
*
700    CODE(1)=0
       I=8
       GO TO 410
*
*
*
C      DELETE
C ****************
*
800    IF CODE(3)#0,  GO TO 810
       ESCAPE OFF
       CALL INIT MATRIX
       GO TO 120
C
810    OVERLAY WITH 'DELETE'
       GO TO 120
*
*
*
C      CHANGE
C ****************
*
900    IF CODE(3)#6,  GO TO 910
C
C OPEN SOURCE FILE
C
       OPEN INPUT,2 :  SOURCE CODE(5), ERROR CALL ERROR(14);  GO TO 2$
       FILE INPUT=.TRUE.
       GO TO 920
C
C
910    FILE INPUT=.FALSE.
920    OVERLAY WITH 'CHANGE'
       GO TO 440
*
*
*
C      DUPLICATE
C *******************
*
1000   OVERLAY WITH 'DUPLICATE'
       GO TO 440
*
*
*
C      REPLACE
C *****************
*
1100   OVERLAY WITH 'REPLACE'
       GO TO 440
*
*
*
C      NUMBER
C ****************
*
1200   OVERLAY WITH 'NUMBER'
       GO TO 440
*
*
*
C      RENAME
C ****************
*
1300   ESCAPE OFF
C
       COLUMNS(1,CODE(4))=CODE(6)
       COLUMNS(2,CODE(4))=CODE(7)
C
       GO TO 9$
*
*
*
C      RANK
C **************
*
1400   OVERLAY WITH 'RANK'
       GO TO 440
*
*
*
C      ORDER
C ***************
*
1500   OVERLAY WITH 'ORDER'
       GO TO 440
*
*
*
C      ROWS
C **************
*
1600   IF HUSH,  GO TO 6$
C
       J=0
       FLAG=.FALSE.
C
       DO 1660 I=1, NO OF ROWS
       IF .NOT.FLAG, GO TO 1610
       CALL DISCHR(1R,)
       J=J+1
C
1610   IF .NOT.SPECIAL, GO TO 1620
       NAME(1)=ROWS(1,-I)
       NAME(2)=ROWS(2,-I)
       GO TO 1650
C
1620   IF MULTIPLE,  GO TO 1630
       M=I
       N=0
       GO TO 1640
C
1630   CALL GET FLOW(M,N,I)
1640   CALL MAKE RN(M,N)
1650   J=J+DISSYM(NAME)
       FLAG=.TRUE.
C
       IF J+7<=CPL,  GO TO 1660
       CALL DISCHR(155B)
       J=0
       FLAG=.FALSE.
C
1660   CONTINUE
C
       IF J#0,  CALL DISCHR(155B)
C
       GO TO 6$
*
*
*
C      COLUMNS
C *****************
*
1700   IF HUSH,  GO TO 6$
       OVERLAY WITH 'COLUMNS'
       GO TO 6$
*
*
*
C      SIZE
C **************
*
1800   IF HUSH,  GO TO 6$
C
       CALL DISNUM(NO OF ROWS)
       CALL DISMSG(2,2)
       CALL DISNUM(NO OF COLUMNS)
       CALL DISMSG(2,3)
       GO TO 6$
*
*
*
C      LINE
C ***************
*
1900   CPL=CODE(4)
       GO TO 7$
*
*
*
C      TITLE
C ***************
*
2000   INP OK=.FALSE.
       GO TO 7$
*
*
*
C      ROUND
C ***************
*
2200   IF CODE(4).EQ.1,  X=0   .ELSE.  X=.5
       FLAG=CODE(8).EQ.1
       K=9
C
       ESCAPE OFF
       COM NO=COM NO+1
       INP OK=.FALSE.
C
2210   IF CODE(K)-9,  5$,2220,2230
C
2220   I=J=CODE(K+1)
       K=K+2
       GO TO 2240
C
2230   I=CODE(K+2)
       J=CODE(K+4)
       K=K+5
C
2240   DO 2250 I=I,J
2250   CALL FIX COLUMN(FLAG,X,I,CODE(6))
       GO TO 2210
*
*
*
C      LEVEL
C ***************
*
2400   GO TO 90$
*
*
*
C      SERIAL
C ****************
*
2500   GO TO 90$
*
*
*
C      EFFICIENT
C *******************
*
2600   GO TO 90$
*
*
*
C      CONSTRAINTS
C *********************
*
2700   GO TO 90$
*
*
*
C      OPTION
C ****************
*
2800   GO TO 90$
*
*
*
C      INT
C *************
*
2900   GO TO 90$
*
*
*
C      ANNUAL
C ****************
*
3000   GO TO 90$
*
*
*
C      TAX
C *************
*
3100   TAX COLUMN=CODE(4)
       TAX=MKREAL(CODE(6))
       TAX FREQUENCY=CODE(9)
       GO TO 7$
*
*
*
C      BEGIN
C ***************
*
3200   CALL SET BEGIN(CODE(4))
       GO TO 7$
*
*
*
C      END
C *************
*
3300   CALL SET END(CODE(4))
       GO TO 7$
*
*
*
C      COMPARE
C *****************
*
3400   ESCAPE OFF
       CALL SET ESCAPE(3480S)
C
       COMPARE=.TRUE.
       FILE NO=1
       NO OF ANALYSIS=0
       (  ANALYSIS(I)=0  ),  I=1,14
C
       DO 3420 J=4, N CODE,2
       DO 3410 K=1, NO OF ANALYSIS
3410   IF ANALYSIS(K).EQ.CODE(J),  GO TO 3420
       NO OF ANALYSIS=NO OF ANALYSIS+1
       ANALYSIS(NO OF ANALYSIS)=CODE(J)
3420   CONTINUE
C
C
3430   ASSIGN 3440 TO COM LABEL
       ESCAPE ON
C
       IF .NOT.PARSE(LOAD),  GO TO 3460
       GO TO 100
C
3440   IF STATE>1,  GO TO 3430
       CALL SET ESCAPE(3480S)
       ASSIGN 3450 TO COM LABEL
       IST ANALYSIS=.TRUE.
C
C
       DO 3450 A INDEX=1, NO OF ANALYSIS
       IF HUSH,  GO TO 3445
       CALL DISSYM(A NAMES(1,ANALYSIS(A INDEX)))
       CALL DISCHR(155B)
3445   CALL PARSE(A NAMES(1,ANALYSIS(A INDEX)))
       GO TO 10
3450   CONTINUE
C
       ESCAPE OFF
       FILE NO=FILE NO+1
       GO TO 3430
C
C
3460   ESCAPE OFF
       CALL INIT MATRIX
C
C
       DO 3470 I=1, NO OF ANALYSIS
       J=LRSH(A COLUMNS(ANALYSIS(I)),3)
       K=IAND(A COLUMNS(ANALYSIS(I)),7)
C
       DO 3465 L=1,K
       CALL ADD COLUMN(N A COLUMNS(1,J), 3490S)
3465   J=J+1
C
3470   CONTINUE
C
C
       (  CALL ADD ROWS(3490S)  ),  I=2, FILE NO
C
C
       COMPARE=.FALSE.
       CALL LINK(7)
       OVERLAY WITH 'SETUP'
       DATA IN=SPECIAL=APP OK=.TRUE.
       INP OK=.FALSE.
       STATE=1
       COM NO=COM NO+1
       GO TO 3495
C
C
3480   ESCAPE OFF
       CLOSE
       CALL SET ESCAPE(3490S)
       GO TO 3430
C
3490   ESCAPE OFF
       COMPARE=DATA IN=.FALSE.
3495   CALL SET ESCAPE(3$)
       GO TO 4$
*
*
*
C      REDUCE
C ****************
*
3500   ESCAPE OFF
       IF N CODE>3,  OVERLAY WITH 'PD2PRED'
+            .ELSE.  OVERLAY WITH 'PD2RED'
       ESCAPE ON
       IF BAD FILE,  GO TO 5$
       GO TO 120
*
*
*
C      COLUMN
C ****************
*
3600   GO TO 100$
*
*
*
C      PVAL
C **************
*
3700   GO TO 10$
*
*
*
C      NPVAL
C ***************
*
3800   GO TO 10$
*
*
*
C      FVAL
C **************
*
3900   GO TO 10$
*
*
*
C      NFVAL
C ***************
*
4000   GO TO 10$
*
*
*
C      ERR
C *************
*
4100   GO TO 10$
*
*
*
C      IRR
C *************
*
4200   GO TO 10$
*
*
*
C      ARR
C *************
*
4300   GO TO 10$
*
*
*
C      PAYBACK
C *****************
*
4400   GO TO 10$
*
*
*
C      RRISK
C ***************
*
4500   GO TO 10$
*
*
*
C      ORISK
C ***************
*
4600   GO TO 10$
*
*
*
C      PARAMETRIC
C ********************
*
4700   GO TO 10$
*
*
*
C      ELEMENTRY
C *******************
*
5000   IF CODE(3).EQ.0,  GO TO 5200
C
C GET THE FILES OPEN AND GRAP THE ESCAPE.
C
       IF .NOT.OPEN DATA(320S, SIM ESC),  GO TO 2$
C
5010   FLAG=.TRUE.
       GO TO 20$
*
*
*
C      CORRELATION
C *********************
*
5100   GO TO 5000
*
*
*
C      SCATTER
C *****************
*
5200   FLAG=.FALSE.
       GO TO 20$
*
*
*
C      CURVE
C ***************
*
5300   IF CODE(9)+CODE(10).EQ.0,  GO TO 5200
       ASSIGN 20$ TO LABEL
C
5310   CODE(1)=9
5320   ESCAPE OFF
       CALL SET ESCAPE(5390S)
       ASSIGN 5390 TO SIM ESC
       OVERLAY WITH 'NEWCOLS'
       IF STATE>1,  GO TO 5$
       FLAG=.TRUE.
       ESCAPE ON
       GO TO LABEL
C
C
5390   ESCAPE OFF
       CALL SET ESCAPE(3$)
       IF DATA IN,  OVERLAY WITH 'DELCOLS'
       GO TO 5$
*
*
*
C      HISTOGRAM
C *******************
*
5400   GO TO 5200
*
*
*
C      CUMULATIVE
C ********************
*
5500   GO TO 5200
*
*
*
C      CONTINGENCY
C *********************
*
5600   GO TO 5200
*
*
*
C      DESCRIPTIVE
C *********************
*
5700   GO TO 5800
*
*
*
C      PLOT
C **************
*
5800   FLAG=.FALSE.
       GO TO 30$
*
*
*
C      LINEAR
C ****************
*
C
C WE MUST ADD THE NEW COLUMNS IF REQUESTED.
C
5900   IF CODE(7)+CODE(8).EQ.0,  GO TO 5800
       ASSIGN 30$ TO LABEL
       CODE(1)=7
       GO TO 5320
*
*
*
C      MULTIPLE
C ******************
*
6000   I=5
C
       REPEAT 6010,  WHILE CODE(I).EQ.9
6010   I=I+2
C
C
       I=I+1
       GO TO 6130
*
*
*
C      STEPWISE
C ******************
*
6100   I=5
       J=1
C
       TIMES 6120, 2
C
       REPEAT 6110,  WHILE CODE(I).EQ.9
       I=I+2
6110   J=J+1
C
6120   I=I+1
C
       IF J>15,  CALL ERROR(3);  GO TO 2$
C
C
6130   IF CODE(I)+CODE(I+1).EQ.0,  FLAG=.FALSE.;  GO TO 70$
       ASSIGN 70$ TO LABEL
       CODE(1)=I
       GO TO 5320
*
*
*
C      POLYNOMIAL
C ********************
*
6200   IF CODE(9)+CODE(10).EQ.0,  FLAG=.FALSE.;  GO TO 50$
       ASSIGN 50$ TO LABEL
       GO TO 5310
*
*
*
C      KOLMOGOROV-SMIRNOV
C ****************************
*
6300   IF CODE(3)#2,  GO TO 6305
       CALL INIT MATRIX
       CALL ADD COLUMN(LRANGE,2$)
       CALL ADD COLUMN(URANGE,2$)
       CALL ADD COLUMN(FREQ,2$)
C
6305   IF CODE(DIST(CODE(8))).EQ.0,  FLAG=.FALSE.;  GO TO 6310
       CODE(1)=N CODE-3
       ASSIGN 6310 TO LABEL
       GO TO 5320
C
6310   CALL SET ESCAPE(6320S)
       OPEN RANDIO,4 :  SCR FILE, BINARY,
+              ERROR CALL ERROR(20);  STATE=2;  GO TO 6330
       GO TO 60$
C
C
6320   STATE=3
6330   ESCAPE OFF
       IF STATE>1 .AND. FLAG,  OVERLAY WITH 'DELCOLS'
       CLOSE 4
       CALL IADEL(SCR FILE)
       CALL SET ESCAPE(3$)
       IF STATE.EQ.1,  NORMAL=DATA IN=APP OK=.TRUE.;  INP OK=.FALSE.
       ESCAPE ON
       IF STATE>1,  GO TO 8$   .ELSE.  GO TO 6$
*
*
*
C      CHI-SQUARE
C ********************
*
6400   GO TO 6300
*
*
*
C      KENDALL
C *****************
*
6500   GO TO 40$
*
*
*
C      SPEARMAN
C ******************
*
6600   GO TO 40$
*
*
*
C      CONFIDENCE
C ********************
*
6700   GO TO 40$
*
*
*
C      XPOS
C **************
*
6800   I=10+3*CODE(3)
       IF CODE(I)+CODE(I+1).EQ.0,  FLAG=.FALSE.;  GO TO 80$
       ASSIGN 80$ TO LABEL
       CODE(1)=I
       GO TO 5320
*
*
*
C      FORCAST
C *****************
*
6900   IF DATA IN,  GO TO 6910
       CALL INIT MATRIX
       (  CALL ADD ROW(2$)  ),  I=1,CODE(4)
       GO TO 6920
C
6910   CODE(4)=MIN(CODE(4), NO OF ROWS)
C
6920   CODE(8)=0
       CODE(1)=5
       ASSIGN 80$ TO LABEL
       GO TO 5320
*
*
*
C      CALL FIRST ANALYTICAL OVERLAY.
*
10$    CALL LINK(7)
       OVERLAY WITH 'STATA7'
       GO TO 35$
*
*
*
C      CALL STATA1
C *********************
*
20$    CALL LINK(1)
       OVERLAY WITH 'STATA1'
       GO TO 33$
*
*
*
C      CALL STATA2
C *********************
*
30$    CALL LINK(2)
       OVERLAY WITH 'STATA2'
C
33$    IF FLAG,  IF STATE>1,  GO TO SIM ESC   .ELSE.  CALL SET ESCAPE(3$)
C
35$    IF STATE-2,  6$, 8$, 1$
*
*
*
C      CALL STATA3
C *********************
*
40$    CALL LINK(3)
       OVERLAY WITH 'STATA3'
       GO TO 35$
*
*
*
C      CALL STATA4
C *********************
*
50$    CALL LINK(4)
       OVERLAY WITH 'STATA4'
       GO TO 33$
*
*
*
C      CALL STATA5
C *********************
*
60$    CALL LINK(5)
       OVERLAY WITH 'STATA5'
       GO TO 6330
*
*
*
C      CALL STATA6
C *********************
*
70$    CALL LINK(6)
       OVERLAY WITH 'STATA6'
       GO TO 33$
*
*
*
C      CALL STATA8
C *********************
*
80$    CALL LINK(8)
       OVERLAY WITH 'STATA8'
       GO TO 33$
*
*
*
C      CALL STATA9
C *********************
*
90$    CALL LINK(9)
       OVERLAY WITH 'STATA9'
       GO TO 33$
*
*
*
C      A LINK FILE IS MISSING.
C *********************************
*
99$    CALL ERROR(18)
       GO TO 2$
*
*
*
C      NOT YET
*
100$   CALL DISPLAY('$NOT IMPLIMENTED.$')
       GO TO 2$
       LOGICAL FUNCTION PARSE(PAR NAM)
C
       INTEGER PAR NAME(2)
C
       CODE(1)=PAR NAM(1)
       CODE(2)=PAR NAM(2)
       OVERLAY WITH 'DISP'
       PARSE=CODE(N CODE+2)
       RETURN
       SUBROUTINE READ STRUCTURE(RS LAB)
C
C
       OVERLAY WITH 'READSTR'
       IF CODE(1)#-1,  CALL ERROR(CODE(1));  GO TO RS LAB
       RETURN
       SUBROUTINE ERROR(ERR NO)
C
       CALL OUTMSG(1,1,ERR NO)
       CALL SFE CLEAR
       RETURN
C
C
       END
STATFIN ** FICHE/FRAME BREAK *****
TYMFLOW SYMSORT

SYM.  PG.LN. IDENT.

+      20 28 W:TYMFLO+      14 25 W:TYMFLO+       3  5 W:TYMFLO+       3  4 W:TYMFLO
+       3  2 W:TYMFLO+       3  1 W:TYMFLO+       2 38 W:TYMFLO+       2 37 W:TYMFLO
+       2 34 W:TYMFLO+       2 24 W:TYMFLO+       2 23 W:TYMFLO+       2 22 W:TYMFLO
+       2 21 W:TYMFLO+       2 20 W:TYMFLO+       2 18 W:TYMFLO+       2 16 W:TYMFLO
+       2 15 W:TYMFLO+       2 14 W:TYMFLO+       1 29 W:TYMFLO+       1 12 W:TYMFLO
10$    22 20 W:TYMFLO100$   24 31 W:TYMFLO1000    7 18 W:TYMFLO1100    7 26 W:TYMFLO
120     3 38 W:TYMFLO1200    7 34 W:TYMFLO1300    8  3 W:TYMFLO1400    8 13 W:TYMFLO
1500    8 21 W:TYMFLO1600    8 29 W:TYMFLO1640    9  6 W:TYMFLO1650    9  7 W:TYMFLO
1700    9 22 W:TYMFLO1800    9 31 W:TYMFLO1900   10  4 W:TYMFLO20$    22 29 W:TYMFLO
2000   10 12 W:TYMFLO2200   10 20 W:TYMFLO2250   10 34 W:TYMFLO2400   11  3 W:TYMFLO
2500   11 10 W:TYMFLO2600   11 17 W:TYMFLO2700   11 24 W:TYMFLO2800   11 31 W:TYMFLO
2900   11 38 W:TYMFLO30$    22 38 W:TYMFLO300     4 28 W:TYMFLO3000   12  6 W:TYMFLO
3100   12 13 W:TYMFLO315     4 37 W:TYMFLO3200   12 23 W:TYMFLO3300   12 31 W:TYMFLO
3400   12 39 W:TYMFLO3410   13  8 W:TYMFLO3420   13 11 W:TYMFLO3445   13 24 W:TYMFLO
3450   13 26 W:TYMFLO3465   13 37 W:TYMFLO3495   14 15 W:TYMFLO3500   14 23 W:TYMFLO
3600   14 35 W:TYMFLO3700   15  3 W:TYMFLO3800   15 10 W:TYMFLO3900   15 17 W:TYMFLO
40$    23  9 W:TYMFLO400     5 23 W:TYMFLO4000   15 24 W:TYMFLO4100   15 31 W:TYMFLO
4200   15 38 W:TYMFLO4300   16  6 W:TYMFLO4400   16 13 W:TYMFLO4500   16 20 W:TYMFLO
4600   16 27 W:TYMFLO4700   16 34 W:TYMFLO5$      3 10 W:TYMFLO50$    23 18 W:TYMFLO
500     6  4 W:TYMFLO5000   17  2 W:TYMFLO5100   17 13 W:TYMFLO5200   17 20 W:TYMFLO
5300   17 28 W:TYMFLO5320   17 31 W:TYMFLO5400   18 10 W:TYMFLO5500   18 17 W:TYMFLO
5600   18 24 W:TYMFLO5700   18 31 W:TYMFLO5800   18 38 W:TYMFLO60$    23 27 W:TYMFLO
600     6 14 W:TYMFLO6000   19 18 W:TYMFLO6010   19 20 W:TYMFLO6100   19 29 W:TYMFLO
6110   19 34 W:TYMFLO6200   20  8 W:TYMFLO6300   20 17 W:TYMFLO6330   20 31 W:TYMFLO
6400   21  6 W:TYMFLO6500   21 13 W:TYMFLO6600   21 20 W:TYMFLO6700   21 27 W:TYMFLO
6800   21 34 W:TYMFLO6900   22  6 W:TYMFLO7$      3 13 W:TYMFLO70$    23 36 W:TYMFLO
700     6 22 W:TYMFLO80$    24  6 W:TYMFLO800     6 31 W:TYMFLO90$    24 15 W:TYMFLO
900     7  4 W:TYMFLO920     7 10 W:TYMFLO99$    24 24 W:TYMFLO
C      24 29 W:TYMFLOC      24 22 W:TYMFLOC      24 21 W:TYMFLOC      24 13 W:TYMFLO
C      24 12 W:TYMFLOC      24  4 W:TYMFLOC      24  3 W:TYMFLOC      23 34 W:TYMFLO
C      23 33 W:TYMFLOC      23 25 W:TYMFLOC      23 24 W:TYMFLOC      23 16 W:TYMFLO
C      23 15 W:TYMFLOC      23  7 W:TYMFLOC      23  6 W:TYMFLOC      22 36 W:TYMFLO
C      22 35 W:TYMFLOC      22 27 W:TYMFLOC      22 26 W:TYMFLOC      22 18 W:TYMFLO
C      22  4 W:TYMFLOC      22  3 W:TYMFLOC      21 32 W:TYMFLOC      21 31 W:TYMFLO
C      21 25 W:TYMFLOC      21 24 W:TYMFLOC      21 18 W:TYMFLOC      21 17 W:TYMFLO
C      21 11 W:TYMFLOC      21 10 W:TYMFLOC      21  4 W:TYMFLOC      21  3 W:TYMFLO
C      20 15 W:TYMFLOC      20 14 W:TYMFLOC      20  6 W:TYMFLOC      20  5 W:TYMFLO
C      19 27 W:TYMFLOC      19 26 W:TYMFLOC      19 16 W:TYMFLOC      19 15 W:TYMFLO
C      19  5 W:TYMFLOC      19  4 W:TYMFLOC      18 36 W:TYMFLOC      18 35 W:TYMFLO
C      18 29 W:TYMFLOC      18 28 W:TYMFLOC      18 22 W:TYMFLOC      18 21 W:TYMFLO
C      18 15 W:TYMFLOC      18 14 W:TYMFLOC      18  8 W:TYMFLOC      18  7 W:TYMFLO
C      17 26 W:TYMFLOC      17 25 W:TYMFLOC      17 18 W:TYMFLOC      17 17 W:TYMFLO
C      17 11 W:TYMFLOC      17 10 W:TYMFLOC      16 39 W:TYMFLOC      16 38 W:TYMFLO
C      16 32 W:TYMFLOC      16 31 W:TYMFLOC      16 25 W:TYMFLOC      16 24 W:TYMFLO
C      16 18 W:TYMFLOC      16 17 W:TYMFLOC      16 11 W:TYMFLOC      16 10 W:TYMFLO
C      16  4 W:TYMFLOC      16  3 W:TYMFLOC      15 36 W:TYMFLOC      15 35 W:TYMFLO
C      15 29 W:TYMFLOC      15 28 W:TYMFLOC      15 22 W:TYMFLOC      15 21 W:TYMFLO
C      15 15 W:TYMFLOC      15 14 W:TYMFLOC      15  8 W:TYMFLOC      15  7 W:TYMFLO
C      15  1 W:TYMFLOC      14 39 W:TYMFLOC      14 33 W:TYMFLOC      14 32 W:TYMFLO
C      14 21 W:TYMFLOC      14 20 W:TYMFLOC      12 37 W:TYMFLOC      12 36 W:TYMFLO
C      12 29 W:TYMFLOC      12 28 W:TYMFLOC      12 21 W:TYMFLOC      12 20 W:TYMFLO
C      12 11 W:TYMFLOC      12 10 W:TYMFLOC      12  4 W:TYMFLOC      12  3 W:TYMFLO
C      11 36 W:TYMFLOC      11 35 W:TYMFLOC      11 29 W:TYMFLOC      11 28 W:TYMFLO
C      11 22 W:TYMFLOC      11 21 W:TYMFLOC      11 15 W:TYMFLOC      11 14 W:TYMFLO
C      11  8 W:TYMFLOC      11  7 W:TYMFLOC      11  1 W:TYMFLOC      10 39 W:TYMFLO
C      10 18 W:TYMFLOC      10 17 W:TYMFLOC      10 10 W:TYMFLOC      10  9 W:TYMFLO
C      10  2 W:TYMFLOC      10  1 W:TYMFLOC       9 29 W:TYMFLOC       9 28 W:TYMFLO
C       9 20 W:TYMFLOC       9 19 W:TYMFLOC       8 27 W:TYMFLOC       8 26 W:TYMFLO
C       8 19 W:TYMFLOC       8 18 W:TYMFLOC       8 11 W:TYMFLOC       8 10 W:TYMFLO
C       8  1 W:TYMFLOC       7 39 W:TYMFLOC       7 32 W:TYMFLOC       7 31 W:TYMFLO
C       7 24 W:TYMFLOC       7 23 W:TYMFLOC       7 16 W:TYMFLOC       7 15 W:TYMFLO
C       7  2 W:TYMFLOC       7  1 W:TYMFLOC       6 29 W:TYMFLOC       6 28 W:TYMFLO
C       6 20 W:TYMFLOC       6 19 W:TYMFLOC       6 12 W:TYMFLOC       6 11 W:TYMFLO
C       6  2 W:TYMFLOC       6  1 W:TYMFLOC       5 21 W:TYMFLOC       5 20 W:TYMFLO
C       4 26 W:TYMFLOC       4 25 W:TYMFLOC       4 12 W:TYMFLOC       4 11 W:TYMFLO
C       3 23 W:TYMFLOC       3 22 W:TYMFLOCM     25  6 W:TYMFLOCM     24 35 W:TYMFLO
CM     24 34 W:TYMFLOCM     19 36 W:TYMFLOCM     19 32 W:TYMFLOCM     19 31 W:TYMFLO
CM     19 19 W:TYMFLOCM     17  4 W:TYMFLOCM     13 35 W:TYMFLOCM     13 27 W:TYMFLO
CM     13 14 W:TYMFLOCM     13  6 W:TYMFLOCM     13  2 W:TYMFLOCM     10 23 W:TYMFLO
CM      9 32 W:TYMFLOCM      9 15 W:TYMFLOCM      9 14 W:TYMFLOCM      9  9 W:TYMFLO
CM      8 32 W:TYMFLOCM      8 30 W:TYMFLOCM      8  6 W:TYMFLOCM      8  4 W:TYMFLO
CM      7  6 W:TYMFLOCM      5 29 W:TYMFLOCM      5 27 W:TYMFLOCM      5 11 W:TYMFLO
CM      5  9 W:TYMFLOCM      5  8 W:TYMFLOCM      5  6 W:TYMFLOCM      4 34 W:TYMFLO
CM      4 32 W:TYMFLOCM      4 30 W:TYMFLOCM      4 19 W:TYMFLOCM      4  6 W:TYMFLO
CM      3 34 W:TYMFLOCM      3 32 W:TYMFLOCM      3 29 W:TYMFLOCM      2 26 W:TYMFLO
CM      2 25 W:TYMFLOCM      2 12 W:TYMFLOCM      2  9 W:TYMFLOCM      2  7 W:TYMFLO
CM      2  4 W:TYMFLOCM      2  2 W:TYMFLOCM      2  1 W:TYMFLOCM      1 35 W:TYMFLO
CM      1 17 W:TYMFLOCM      1 10 W:TYMFLOCM      1  9 W:TYMFLOCM      1  7 W:TYMFLO
CM      1  3 W:TYMFLOCM1$    2 31 W:TYMFLOCM100   3 26 W:TYMFLOCM110   3 37 W:TYMFLO
CM150   4  4 W:TYMFLOCM1610  8 36 W:TYMFLOCM1620  9  1 W:TYMFLOCM1630  9  5 W:TYMFLO
CM1660  9 13 W:TYMFLOCM200   4 15 W:TYMFLOCM210   4 17 W:TYMFLOCM2210 10 26 W:TYMFLO
CM2220 10 27 W:TYMFLOCM2230 10 30 W:TYMFLOCM2240 10 33 W:TYMFLOCM310   4 36 W:TYMFLO
CM320   5  1 W:TYMFLOCM33$  23  1 W:TYMFLOCM3440 13 16 W:TYMFLOCM3470 13 38 W:TYMFLO
CM3490 14 13 W:TYMFLOCM35$  23  2 W:TYMFLOCM350   5  4 W:TYMFLOCM410   5 25 W:TYMFLO
CM420   5 32 W:TYMFLOCM430   5 33 W:TYMFLOCM440   5 34 W:TYMFLOCM5010 17  5 W:TYMFLO
CM510   6  5 W:TYMFLOCM5310 17 30 W:TYMFLOCM5900 19  8 W:TYMFLOCM6120 19 35 W:TYMFLO
CM6305 20 22 W:TYMFLOCM6310 20 26 W:TYMFLOCM6910 22 10 W:TYMFLOCM6920 22 11 W:TYMFLO
CM810   6 35 W:TYMFLOCMC    19  7 W:TYMFLOCMC    17  3 W:TYMFLOCMC     7  5 W:TYMFLO
CMC     5 31 W:TYMFLOCMC     5 28 W:TYMFLOCMC     5 26 W:TYMFLOCMC     5 10 W:TYMFLO
CMC     4 39 W:TYMFLOCMC     4 35 W:TYMFLOCMC     4 33 W:TYMFLOCMC     4 31 W:TYMFLO
CMC     4 29 W:TYMFLOCMC     4 18 W:TYMFLOCMC     4 16 W:TYMFLOCMC     4 14 W:TYMFLO
CMC     4  5 W:TYMFLOCMC     3 36 W:TYMFLOCMC     3 33 W:TYMFLOCMC     3 31 W:TYMFLO
CMC     3 28 W:TYMFLOCMC     3 25 W:TYMFLOCMCM   25  9 W:TYMFLOCMCM   25  2 W:TYMFLO
CMCM   19 21 W:TYMFLOCMCM   14  1 W:TYMFLOCMCM   13 39 W:TYMFLOCMCM   13 32 W:TYMFLO
CMCM   13 20 W:TYMFLOCMCM    2 29 W:TYMFLOCMCM    1  4 W:TYMFLOCMCM    1  2 W:TYMFLO
CMCM13  4  1 W:TYMFLOCMCM2$  2 32 W:TYMFLOCMCM20  2 39 W:TYMFLOCMCM3$  3  6 W:TYMFLO
CMCM30  3  3 W:TYMFLOCMCM34 14  9 W:TYMFLOCMCM34 13 30 W:TYMFLOCMCM34 13 12 W:TYMFLO
CMCM39  5 13 W:TYMFLOCMCM4$  3  9 W:TYMFLOCMCM53 17 39 W:TYMFLOCMCM6$  3 12 W:TYMFLO
CMCM61 19 37 W:TYMFLOCMCM63 20 30 W:TYMFLOCMCM8$  3 15 W:TYMFLOCMCM9$  3 17 W:TYMFLO
CMCM91  7  9 W:TYMFLOCMCMC   5  3 W:TYMFLOCMCMCM  4  3 W:TYMFLOCMCMCM  2 36 W:TYMFLO
L      25  5 W:TYMFLOL      25  1 W:TYMFLOL      24 33 W:TYMFLO
STATFIN ** FICHE/FRAME BREAK *****
TYMFLOWGRAPH
!C :TYMFLOWGRAPH   10/23/72
!C
!C
!C     FINPAK MAIN SYNTAX GRAPH.


!      FUNCTIONS FNAME,  INT,  REAL,  CHAR
!      FUNCTIONS OCNAME,  NCNAME,  CNAME,  PNAME,  GET.TITLE,  CK.ZERO
!      FUNCTIONS END.LINE,  GET.IN,  GET.OUT,  PERCENT,  PROC.P.DATA
!      FUNCTIONS CK.RANGE,  NUMERIC,  RNAME,  CK.LINE
!      FUNCTIONS CK.LIST,  CK.DATA,  CK.INP.OK,  ANSWER,  EXPLAIN
!      FUNCTIONS CK.REP.FLAG,  CK.CASES,  CK.TITLE,  DCAT,  CK.EFF
!      FUNCTIONS CK.INTV,  CK.PLOT,  CK.STEP,  CK.CHI,  PROC.DATA
!      FUNCTIONS CK.POS,  CK.FORC,  CK.FINPAK,  CK.RISK,  CK.PARAM

!      TERMINATION CARRIAGE RETURN

!      NAME MAIN
!C *****************

!C PROMPT FOR A LINE OF INPUT.
1      C,8
2      U,1,,
3      C,13

!      NEW LIST

!  DEFAULT TERMINATION BLANK


100    LOAD,200
110    CLR.ALL,E
120    'FROM ',1/FN.W.ERR,1/FN.W.ERR   /2

!  OPTION TERMINATION CARRIAGE RETURN
200    INPUT,300
210    CLR.ALL,E,S

300    SAVE,400
310    IN.A.EXT,E
320    END.LINE,,343
330    'ON ',,343              /2
340    390,350,345
343    FN.W.ERR,E
345    CK.TITLE,,S
348    P.F.TITLE,E,S
!C
350    370,365
360    FN.W.ERR,E,S            /1
365    COL.REQ,350,350
!C
370    CS,E
375    END.LINE,,S
380    'ON ',370,S             /2
!C
390    FNAME,E
395    END.LINE,E,S

400    APPEND,500
405    IN.A.EXT,E
420    END.LINE,430
425    O,0,S
430    L.F.FROM,450
440    O,0,1/FN.W.ERR
!C
450    O,1
455    470,,460
458    U,458,455,COLUMNS TO BE APPENDED: 
460    465,E,S                 /1
465    L.F.FROM,S,1/FN.W.ERR
!C
470    C,3
475    CN.W.DEF,E
480    END.LINE,,S
485    488,S,475
!C
488    L.F.FROM,S,E

500    LIST,600
510    IN.A.EXT,E
515    C,14
520    CL.RL,,S
530    U,530,520,DATA TO BE LISTED: 

600    FAST,700,510

700    INSERT,800
703    IN.A.EXT,E
710    END.LINE,725
715    O,0
720    P.BOA,E,1/P.RNAME
!C
725    L.F.BOA,750
730    O,0                     /1
735    P.RNAME,E
740    L.F.FROM,S,1/FN.W.ERR
!C
750    O,1
755    770,,765
760    U,760,755,COLUMNS TO BE INSERTED: 
765    780,E                   /1
766    768,E,S                 /1
!C
768    'FROM ',S,1/FN.W.ERR    /2
!C
770    C,3
771    CN.W.DEF,E
774    END.LINE,,S
775    779,S,771
!C
779    L.F.BOA,S,E
!C
780    END.LINE,788
785    P.BOA,E,1/P.OCNAME
788    L.F.BOA,,1/P.OCNAME
789    Q.MARK,785,785

800    DELETE,900
805    IN.A.EXT,E
810    END.LINE,830
820    O,5
825    ANSWER,,S
828    U,828,,DATA TO BE DELETED: 
!C
830    885,870
840    860,,S
850    COL.REQ,840,840
!C
860    CS,E
865    END.LINE,860,S
!C
870    890,,S
880    ROW.REQ,870,870
!C
885    NUMERIC,,E
886    '$#',S,E
!C
890    RS,E
895    END.LINE,890,S

900    CHANGE,1000
910    IN.A.EXT,E
920    L.F.FROM,970
930    FN.W.ERR,E
940    C,14
950    O,5
960    ANSWER,995,S
970    C,15
972    END.LINE,980
974    O,5
976    ANSWER,995,S
980    CL.RL,995
983    985,S,S                 /1
985    CK.LIST,,E
990    L.F.FROM,E,1/FN.W.ERR
!C
995    U,995,980,DATA TO BE CHANGED: 

1000   DUPLICATE,1100
1010   IN.A.EXT,E
!C
1011   END.LINE,1018
1012   U,1012,,ROWS OR COLUMNS: 
!  NEW LIST
1013   ROWS,,1080              /2
1014   COLUMNS,,1020           /2
!  END LIST
1015   Q.MARK,1012,1012
!C
1018   885,1080
1020   O,1
1023   END.LINE,,1028
1025   1050,,1030
1028   U,1028,1025,COLUMNS TO BE DUPLICATED: 
1030   C,6                     /1
1035   1230,1035               /1
1040   1070,1040,S             /1
!C
1050   CS,E
1055   1095,S,1050
!C
1070   'AS '                   /2
1071   END.LINE,1073
1072   U,1072,,NEW NAMES: 
1073   NCNAME,1/NCN.ERR
1074   $,                      /2
1075   DCAT,,1077
1076   P,1073,1076,NEXT COLUMN NAME: 
1077   END.LINE,,S
1078   E,E,$TOO MANY COLUMN NAME.$
!C
1080   O,0
1081   END.LINE,,1083
1082   1086,,1084
1083   U,1083,1082,ROWS TO BE DUPLICATED: 
1084   C,6                     /1
1085   1088,E,S                /1
!C
1086   RS,E
1087   1095,S,1086
!C
1088   END.LINE,1092
1089   60/P.BOA
1090   END.LINE,1092
1091   C,17,S
1092   40/P.BOA,1088,1/P.RNAME
!C
1095   L.F.BOA,,E
1098   END.LINE,S,E

1100   REPLACE,1200
1110   IN.A.EXT,E
1120   END.LINE,,1140
1130   1150,,S
1140   U,1140,1130,REPLACEMENTS: 
!C
1150   C,4
1160   CN.W.DEF,E
1170   END.LINE,1160,S

1200   NUMBER,1300
1205   IN.A.EXT,E
1220   P.NCNAME,E
!C
1230   END.LINE,1260
1235   60/P.BOA
1240   END.LINE,1260
1250   C,16,S
1260   40/P.BOA,1230,1/P.OCNAME

1300   RENAME,1400
1310   IN.A.EXT,E
1320   P.OCNAME,E
1330   'AS ',,1/P.NCNAME       /2
1340   $,,1/P.NCNAME,1/P.NCNAME        /2

1400   RANK,1500
1410   IN.A.EXT,E
1420   1480,1420
1430   1450,1430,S             /1
!C
1450   1470,1450
1460   1230,1460,S             /1
1470   'IN ',1/P.NCNAME,1/P.NCNAME     /2
1480   P,,1480,COLUMN TO BE RANKED: 
1490   OCNAME,1/COL.ERR,S

1500   ORDER,1600
1510   IN.A.EXT,E
1520   END.LINE,1550
1530   U,1530,,ORDER COLUMN OR MATRIX: 
!  NEW LIST
1535   COLUMN,,1570            /2
1540   MATRIX,,1560            /2
!  END LIST
1545   Q.MARK,1535,1535
!C
1550   1580,1570
1560   O,0,1/P.OCNAME
1570   O,1,1/P.OCNAME
!C
!  NEW LIST
!  DEFAULT TERMINATION BLANK
1580   BASED,E                 /2
1590   'ON ',E,S               /2

!  OPTION TERMINATION CARRIAGE RETURN
1600   ROWS,1700
1610   IN.A.EXT,E,S

!  OPTION TERMINATION CARRIAGE RETURN
1700   COLUMNS,1710,1610
!  17
1710   COLS,1800,1610

!  OPTION TERMINATION CARRIAGE RETURN
1800   SIZE,1900,1610

!  OPTION PRIORITY,  EXACT
1900   LINE,2000
1910   END.LINE,,1930
1920   1950,,S
1930   U,1930,1920,LINE LENGTH: 
!C
1950   INT,1970
1960   CK.LINE,,S
1970   E,E,$INVALID LINE LENGTH.$$

2000   TITLE,2100
2010   DATA.IN,E
2020   P,,2020,TITLE: 
2030   GET.TITLE,,S
2040   Q.MARK,2020,2020

2100   COLUMN,,2110
!  21
2101   FORECAST,2200
2105   CK.DATA.IN,2110
2108   C,20
2110   P,,2110,# OF PERIODS: 
2120   GET.POS,2110
2130   P,,2130,VARIABLE NAME: 
2140   NCNAME,,2160
2150   E,2130,$NOT A NEW VARIABLE NAME.$$
2160   GET.TYPE,,S
2170   O,7
2180   C,9,2160

2200   ROUND,2400
2210   IN.A.EXT,E
2215   P,,2215,UP OR DOWN: 
!  NEW LIST
!  DEFAULT TERMINATION BLANK
2220   DOWN,,2240
2225   UP,,2240
!  END LIST
2230   Q.MARK,2215,2215
!C
2240   P,,2240,COLUMNS: 
2242   2250,2240
2245   2270,E,S                /1
!C
2250   CS,E
2255   2260,S,2250
!C
2260   'TO ',,E                /2
2265   END.LINE,S,E
!C
2270   'TO '                   /2
2272   END.LINE,,2282
2275   INT,2280
2278   2290,E,S
!C
2280   REAL.ERR
2282   2290
2284   2286,2280,S             /1
!C
2286   P,,2286,NUMBER: 
2288   INT,E,S
!C
2290   P,,2290,DECIMAL PLACES OR SIGNIFICANT DIGITS: 
!  NEW LIST
!  DEFAULT TERMINATION CARRIAGE RETURN
2292   DECIMAL PLACES,,S
2294   SIGNIFICANT DIGITS,,S
!  END LIST
2296   E,2290,?$$PLEASE TYPE 

!  24

2400   LEVEL,2500
2405   CK.DATA.IN,2410
2408   C,20
2410   PNR,E
2415   $,                      /2
2420   2425,2420,S
!C
2425   P,,,TO: 
2428   ENDLINE,,2435
2430   $,,2440                 /2
2435   O,15,2445
2440   2495,E
2445   END.LINE,,2490
2450   $,,2460                 /2
2455   O,15,2465
2460   2495,E
2465   END.LINE,,2493
2470   2495,E
2475   END.LINE,1/Q.MARK
2480   U,2480,,PAYMENTS AT BEGINNING? 
2485   D,YES.OR.NO,S,S
!C
2490   O,15
2493   O,15,2480
!C
2495   NCNAME,1/NCN.ERR
2498   $,,S,S                  /2

2500   SERIAL,2600,2405

2600   EFFICIENT,2700
2605   DATA.IN,E
2608   END.LINE,,2625
!  NEW LIST
!  DEFAULT TERMINATION CARRIAGE RETURN
2610   RRISK,,2630
2615   ORISK,,2630
!  END LIST
2620   Q.MARK
2625   U,2625,2610,RRISK OR ORISK? 
!C
2630   CK.EFF,,S
2635   P,,2635,COLUMN FOR RETURNS: 
2640   2690,2635
2645   P,,2645,COLUMN FOR BOUNDS: 
2650   2690,2645
2655   P,,2655,COLUMN FOR RISK: 
2660   2690,2655,S
!C
2690   OCNAME,1/COL.ERR
2695   $,,S,S

2700   CONSTRAINTS,2800
2705   IN.A.EXT,E
2710   PNR,E
2720   $,                      /2
2730   P,,2730,CONSTRAINTS: 
2740   OCNAME,,2415
2750   COL.ERR,2730,2730

2800   OPTION,2900
2810   IN.A.EXT,E
2820   PNR,E
2830   $,                      /2
2840   P,,2840,SCHEDULE: 
2850   OCNAME,,2415
2860   COL.ERR,2840,2840

2900   INT,3000
2910   P,,2910,RATE: 
2920   REAL,,2940
2930   REAL.ERR,2910,2910
2940   $%,2960                 /2
2950   C,2
2960   CK.PERCENT,2910
2970   END.LINE,2980
2975   O,1,S
2980   $,,,2990                /2
2985   NUMERIC,3770
2990   INT,,S
2995   REAL.ERR
2998   P,2990,2998,NO OF PERIODS: 

3000   ANNUAL,3100,2910

3100   TAX,3200
3105   IN.A.RED,E
3110   END.LINE,3130
3120   GET.IN,3140,3150
3130   L.F.RATE,3180
3140   P.IN,E
3150   3160,3150,S
!C
3160   P,,3160,TAX RATE: 
3162   'AT ',,3166             /2
3164   $@                      /2
3166   REAL,1/REAL.ERR
3168   $%,3172                 /2
3170   C,2
3172   CK.PERCENT,E
3174   $/                      /2
3175   CK.ZERO,3178
3176   O,4
3177   O,0,S
3178   P,10/GET.POS,3178,FREQUENCY: 
!C
3180   GET.IN,,3150
3190   COL.ERR,3140,3140

3200   BEGIN,3300
3210   IN.A.RED,E
3220   IN.OR.OCNAME,E,S

3300   END,3400,3210

3400   COMPARE,3500
3410   CLR.ALL,E
3415   3420,3415,S
!C
3420   P,,3420,ANALYSIS: 
!  NEW LIST
!  DEFAULT EXACT,  TERMINATION COMMA
3421   PVAL,,3490
3425   NPVAL,,3490
3430   FVAL,,3490
3435   NFVAL,,3490
3440   ARR,,3490
3445   IRR,,3490
3450   ERR,,3490
3455   PAYBACK,,3490
3460   RRISK,,3490
3465   ORISK,,3490
3470   PARAMETRIC,,3490
!  END LIST
3480   E,E,$NAME NOT RECOGNIZED.$$
!C
3490   $,                      /2
3495   END.LINE,3421,S

3500   REDUCE,3700
3510   IN.A.EXT,E
3520   CK.INP.OK,,3590
3530   O,1
3540   ANSWER,50/CLR.ALL
!  NEW LIST
!  DEFAULT TERMINATION CARRIAGE RETURN
3590   PARAMETRIC,S,S

! 37

3700   PVAL,3800
3710   IN.A.RED,E
3720   END.LINE,3740
3730   GET.IN,3750,3760
3740   L.F.RATE,3780
3750   P.IN,E
3760   RATE,E
!  NEW LIST
3770   CONTINUOUS,S,S
!C
3780   GET.IN,,3760
3790   M.COL.ERR,3750,3750

3800   NPVAL,3900
3810   IN.A.RED,E
3820   CN.CN,E
3830   $,,3760,3760            /2

3900   FVAL,4000,3710

4000   NFVAL,4100,3810

4100   ERR,4200
4105   IN.A.RED,E
4110   END.LINE,4160
4115   IN.A.OUT,,4195
4120   P.IN,4120
4125   END.LINE,4140
4130   P.OUT,,4190
4135   4250,E,4195
!C
4140   L.F.RATE,4135
4150   P.OUT,4150,4190
!C
4160   L.F.RATE,,4120
4170   IN.A.OUT,,4195
4180   M.COL.ERR,4120,4120
!C
4190   $,                      /2
4195   RATE,E,S

4200   IRR,4300
4205   IN.A.RED,E
4210   END.LINE,4270
4220   IN.A.OUT,,S
4230   P.IN,4230
4240   P.OUT,,S
4250   O,9
4260   O,0,S
!C
4270   P.IN,4270
4280   END.LINE,,4250
4290   P.OUT,4290,S

4300   ARR,4400
4310   IN.A.RED,E
4320   END.LINE,4340
4330   IN.A.OUT,,S
4340   P.IN,4340
4350   P.OUT,4350,S

4400   PAYBACK,4700,4205

! 47

4700   PARAMETRIC,5000
4710   DATA.IN,E
4712   PROC.P.DATA,E
4715   GET.OUT,,4745
4720   P,,,COLUMN OF OUT FLOWS: 
4725   END.LINE,4740
4730   O,9
4735   O,0,4745
4740   4790,4720
!C
4745   CK.PARAM,,4770
4750   P,,4750,COLUMN OF MEANS: 
4755   4790,4750
4760   P,,4760,COLUMN OF STANDARD DEVIATIONS: 
4765   4790,4760
!C
4770   3760,E
!C
4775   P,,4775,IN FLOWS AT BEGINNING? 
4780   D,YES.OR.NO,S,S
!C
4790   OCNAME,1/COL.ERR
4795   $,,S,S


!  50

5000   ELEMENTARY,5100
5010   DATA.IN,E
5020   'TO ',S,1/FN.W.ERR      /2

5100   CORRELATION,5200,5010

5200   SCATTER,5300
5210   DATA.IN,E
5220   P,,5220,X-VARIABLE: 
5230   OCNAME,,5250
5240   VAR.ERR,5220,5220
5250   $,                      /2
5255   P,,5250,Y-VARIABLE: 
5260   OCNAME,,5280
5270   VAR.ERR,5255,5255
5280   P.WITH.C,E,S

5300   CURVE,5400
5310   DATA.IN,E
5320   5920,E
5330   $,                      /2
5340   P,,,COLUMN OF WEIGHTS: 
5350   END.LINE,,5380
5360   OCNAME,,5940
5370   COL.ERR,5340,5340
5380   O,0
5390   O,0,5940

5400   HISTOGRAM,5500
5410   DATA.IN,E
5420   P.OVNAME,E
5430   P.WITH.C,E
!C
5440   U,5440,,# OF INTERVALS: 
5450   5460,5440,S
5460   INT,1/Q.MARK
5470   CK.INTV,,S
5480   E,E,$# OF INTEVALS MUST BE BETWEEN 1 AND 12.$

5500   CUMULATIVE,5600,5410

5600   CONTINGENCY,5700
5610   DATA.IN,E,S

5700   DESCRIPTIVE,5800
5710   DATA.IN,E,1/P.OVNAME

5800   PLOT,5900
5810   DATA.IN,E
5820   P.IND.VAR,E
5825   C,3
5830   5838
5835   5840,5825,S
5838   P,S,5838,DEP VARIABLES: 
!C
5840   OCNAME,1/VAR.ERR
5850   C,5
5860   $,,,5840                /2
5870   END.LINE,5840
5880   CK.PLOT,,S
5890   E,E,$# OF DEPENDENT VARIABLES MUST BE BETWEEN 1 AND 3.$$

5900   LINEAR,6000
5910   DATA.IN,E
5915   5920,E,5940
5920   P.IND.VAR,E
5925   P,,5925,DEP. VARIABLE: 
5930   OCNAME,,S
5935   VAR.ERR,5925,5925
5940   5943,E,5955
5943   $,                      /2
5945   P,,,COLUMN FOR RESIDUALS: 
5950   5980,5945,S
5955   $,                      /2
5960   P,,,COLUMN FOR COEFFICIENTS: 
5965   5980,5960,S
!C
5980   END.LINE,5990
5985   O,0,S
5990   NCNAME,1/NCN.ERR,S

6000   MULTIPLE,6100
6010   DATA.IN,E
6020   5925,E
6025   $,                      /2
6030   6080
6040   6050,6030
6045   O,15,5940
!C
6050   OCNAME,1/VAR.ERR
6060   $,,,6050                /2
6070   END.LINE,6050,S
!C
6080   P,S,6080,IND. VARIABLES: 

6100   STEPWISE,6200
6110   DATA.IN,E
6115   CK.STEP,6190
6120   5925,E
6130   $,                      /2
6140   P,,,FORCED IND. VARIABLES: 
6145   END.LIN,,6160
6150   6050,6140
6160   O,15
6170   P,,,OTHER IND. VARIABLES: 
6175   END.LINE,,6045
6180   6050,6170,6045
!C
6190   E,E,$STEPWISE REGRESSION REQUIRES AT LEAST THREE ROWS OF DATA.$$

6200   POLYNOMIAL,6300,5310

6300   KOLMOGOROV-SMIRNOV,6400
6310   CK.DATA.IN,,6320
6311   O,2
6312   O,9
6313   O,1,6355
6320   CK.CHI,,6360
6340   P.OCNAME,E
6350   6390,E                  /1
6355   O,0
6360   GET.DIST,6360
6370   5943,E
6385   O,0,S
!C
6390   P,,6390,DOES COLUMN CONTAIN FREQUENCY OF OBSERVATIONS? 
6395   D,YES.OR.NO,S,S

6400   CHI-SQUARE,6500,6310

6500   KENDALL,6600
6510   DATA.IN,E
6520   6590
6530   6540,6520,S
!C
6540   OCNAME,1/VAR.ERR
6545   $,                      /2
6550   END.LINE,6560
6555   6690
6560   OCNAME,1/VAR.ERR
6570   $,,,6560                /2
6580   END.LINE,6560,S
!C
6590   P,S,6590,VARIABLES: 

6600   SPEARMAN,6700
6610   DATA.IN,E
6615   6620,6615,S
6620   6590
6630   OCNAME,,6650
6640   VAR.ERR,6620,6620
!C
6650   $,                      /2
6655   6690
6660   OCNAME,,6680
6670   VAR.ERR,6655,6655
!C
6680   $,,,6688                /2
6685   OCNAME,S
6688   E,E,SPEARMAN TAKES ONLY TWO ARGUMENTS.$$
!C
6690   P,S,6690,SECOND VARIABLE: 

6700   CONFIDENCE,6800,5710

6800   XPOS,9900
6803   DATA.IN,E
6805   'WITH ',,6870            /2
6808   O,0
6810   P.OCNAME
6815   $,                      /2
6820   P,,6820,INITIAL PERIODS: 
6825   GET.POS,6820
6830   6835,6830,6840
6835   P,,6835,# OF SEASONS: 
6838   GET.POS,6835,S
!C
6840   P,,,COLUMN FOR PARAMETERS: 
6842   5980,6840
6844   $,                      /2
6846   P,,,COLUMN FOR FORECASTS:
6848   END.LINE,6858
6850   O,0
6852   6854,6852,S
6854   6865
6856   GET.N.NEQ,E,S
6858   NCNAME,,6861
6860   NCN.ERR,6846,6846
6861   $,                      /2
6862   6865
6864   GET.POS,E,S
6865   P,S,S,# OF FORECASTS: 
!C
6870   O,1
6872   6898
6876   OCNAME,,6880
6878   COL.ERR,6872,6872
6880   $,                      /2
6882   P,,6882,# OF SEASONS: 
6884   GET.POS,6882
6886   P,,6886,SEASON FOR CURRENT PERIOD: 
6888   GET.POS,6886
6890   P,,6890,VALUE FOR CURRENT PERIOD: 
6892   REAL,,6896
6894   REAL.ERR,6892,6892
6896   $,,6840,6840            /2
!C
6898   P,S,6898,PARAMETERS: 



!C   STANDARD FRONT END COMMANDS.
!C         NODES START AT  9900.
!C         COMMANDS AT  401.

!      401

!  DEFAULT TERMINATION CARRIAGE RETURN

9900   HELP,,S
!  401
9901   ?,,S
9902   CAPABILITIES,,S
9903   INSTRUCTIONS,,S
9904   SAMPLE,,S
!  OPTION TERMINATION BLANK
9905   EXPLAIN,9909
9906   P,,9906,COMMAND: 
9907   EXPLAIN,,S
9908   E,E,$PLEASE TYPE 'HELP' FOR A LIST OF THE VALID COMMANDS.$
9909   VERSION,,S
9910   CREDITS,,S
9911   CHARGES,,S
9912   QUIT,,S
9913   TALK,,S
9914   HUSH,,S
9915   ECHO ON,,S
9916   ECHO OFF,,S
!  DEFAULT TERMINATION BLANK
9917   DO,,9919
9918   TOUT,9920
!  END LIST
9919   FN.W.ERR,E,S
!C
9920   E,E,COMMAND NOT RECOGNIZED.$


!      NAME LOAD
!C *****************

1      O,1
2      O,1
3      U,E,,$$FILE NAME: 
4      3/FN.W.ERR,3,S


!      NAME PVAL
!C *****************

1      O,1
2      O,37,3710/MAIN


!      NAME NPVAL
!C ******************

1      O,1
2      O,38,3810/MAIN


!      NAME FVAL
!C *****************

1      O,1
2      O,39,3710/MAIN


!      NAME NFVAL
!C ******************

1      O,1
2      O,40,3810/MAIN


!      NAME ARR
!C ****************

1      O,1
2      O,43,4310/MAIN


!      NAME IRR
!C ****************

1      O,1
2      O,42,4205/MAIN


!      NAME ERR
!C ****************

1      O,1
2      O,41,4105/MAIN


!      NAME PAYBAK
!C *******************

1      O,1
2      O,44,4205/MAIN


!      NAME RRISK
!C ******************

10     O,1
15     O,45
20     CK.RISK,,55
25     P,,25,LOWEST IN FLOWS: 
30     100,25
35     P,,35,MOST LIKELY IN FLOWS: 
40     100,35
45     P,,45,HIGHEST IN FLOWS: 
50     100,45
!C
55     P,,55,RISK COLUMN: 
60     100,55
70     RATE,70
75     P,,75,FLOWS AT BEGINNNING? 
80     D,YES.OR.NO
85     U,S,,INTER-PERIOD CORRELATION COEFFICIENTS: 
90     100,85
95     P,,95,CONSTRUCT CORRELATION MATRIX? 
98     D,YES.OR.NO,S,S
!C
100    OCNAME,1/COL.ERR
110    $,,S,S                  /2


!      NAME ORISK
!C ******************

1      O,1
2      O,46,20/RRISK


!      NAME PAREM
!C ******************

1      O,1
2      O,47,4710/MAIN



!      BLOCK CL.RL
!C *******************

10     END.LINE,,S
15     '$#',20                 /2
16     C,18,65
20     NUMERIC,,60
30     OCNAME,1/COL.ERR
35     $:,50                   /2
38     O,10                    /1
40     OCNAME,1/RGE.ERR
45     CK.RANGE,1/RGE.ERR
50     $,                      /2
51     CK.LIST,,55
52     80,S
55     END.LINE,15,S
!C
60     RNAME,1/ROW.ERR
65     $:,50                   /2
68     O,14                    /1
70     RNAME,1/RGE.ERR,45
!C
80     'FROM ',S,E


!      BLOCK CS
!C ****************

10     OCNAME,1/COL.ERR
20     $:,60                   /2
30     O,10                    /1
40     OCNAME,1/RGE.ERR
50     CK.RANGE,1/RGE.ERR
60     $,,S,10                 /2


!      BLOCK RS
!C ****************

10     RNAME,1/ROW.ERR
20     $:,60                   /2
30     O,14                    /1
40     RNAME,1/RGE.ERR
50     CK.RANGE,1/RGE.ERR
60     $,,S,10                 /2


!      BLOCK PNR
!C *****************

10     P,,10,PRINCIPAL: 
20     REAL,,40
30     REAL.ERR,10,10
!C
40     $,                      /2
50     2998/MAIN
!C
60     $,                      /2
70     RATE,E,S


!      BLOCK CN.W.DEF
!C **********************

30     CK.REP.FLAG,,45
35     NCNAME,1/NCN.ERR,60
40     'AS ',60,80             /2
!C
45     OCNAME,1/COL.ERR
50     'WITH ',,80             /2
60     $=,,80                  /2
70     $_,,80                  /2
73     CK.REP.FLAG,90
75     END.LINE,,79
78     E,E,$INVALID REPLACEMENT.$
79     U,79,,WITH: 
80     COL.EXP,E
90     $,,S,30                 /2


!      BLOCK COL.REQ
!C *********************

1      U,1,S,COLUMNS: 


!      BLOCK ROW.REQ
!C *********************

1      U,1,S,ROWS: 


!      BLOCK IN.OR.OCNAME
!C **************************

10     END.LINE,1/P.OCNAME
20     GET.IN,1/P.OCNAME,S


!      BLOCK P.OCNAME
!C **********************

1      P,,1,COLUMN: 
2      OCNAME,,S
3      COL.ERR,1,1


!      BLOCK P.IND.VAR
!C ***********************

1      P,,1,IND. VARIABLE: 
2      OCNAME,6
3      $,,,S                   /2
!  NEW LIST
!  DEFAULT EXACT
4      VERSUS,,S               /2
5      VS,S,S                  /2
6      VAR.ERR,1,1


!      BLOCK P.OVNAME
!C **********************

1      P,,1,VARIABLE: 
2      OCNAME,,S
3      VAR.ERR,1,1


!      BLOCK P.NCNAME
!C **********************

1      P,,1,NEW COLUMN NAME: 
2      NCNAME,,S
3      NCN.ERR,1,1


!      BLOCK P.RNAME
!C *********************

1      P,,1,ROW: 
2      RNAME,,S
3      ROW.ERR,1,1


!      BLOCK FN.W.ERR
!C **********************

1      P,,1,FILE NAME: 
2      3,1,S
3      FNAME,5
4      END.LINE,,S
5      E,E,$NOT A VALID FILE NAME.$$


!      BLOCK Q.MARK
!C ********************

1      E,E,$?$


!      BLOCK COM.ERR
!C *********************

1      E,E,$INVALID COMMAND FORMAT.$$


!      BLOCK COL.ERR
!C *********************

1      E,E,$NOT A COLUMN NAME.$$


!      BLOCK VAR.ERR
!C *********************

1      E,E,$NOT A VARIABLE NAME.$$


!      BLOCK NCN.ERR
!C *********************

1      E,E,$NOT A NEW COLUMN NAME.$$


!      BLOCK M.COL.ERR
!C ***********************

1      E,E,$COLUMN IS MISSING.$$


!      BLOCK ROW.ERR
!C *********************

1      E,E,$NOT A ROW NAME.$$


!      BLOCK RGE.ERR
!C *********************

1      E,E,$INVALID RANGE SPECIFICATION.$$


!      BLOCK REAL.ERR
!C **********************

1      E,E,$NOT A VALID NUMBER.$


!      BLOCK LOC
!C *****************

10     NCNAME,E
20     $,                      /2
30     END.LINE,10,S


!      BLOCK L.F.FROM
!C **********************

1      'FROM ',E,S             /2


!      BLOCK L.F.BOA
!C *********************

!  NEW LIST
!  DEFAULT EXACT,  TERMINATION BLANK
1      BEFORE,,S
2      AFTER,E,S


!      BLOCK P.BOA
!C *******************

10     60
20     END.LINE,,10
30     40,10,S
!  NEW LIST
40     BEFORE,,S
50     AFTER,1/Q.MARK,S
!  END LIST
60     U,S,S,BEFORE OR AFTER: 


!      BLOCK L.F.RATE
!C **********************

10     'AT ',,E
20     $@,,E
30     NUMERIC,S,E


!      BLOCK RATE
!C ******************

5      10,5,S
!C
10     P,,10,PERIODIC RATE: 
15     'AT ',,25               /2
20     $@                      /2
25     REAL,70
28     C,21
30     $%,40                   /2
35     C,2
40     $/,1/CK.PERCENT         /2
45     REAL,90
50     C,1,1/CK.PERCENT
!C
70     OCNAME,90
80     O,0,S
!C
90     E,E,$INVALID RATE.$$


!      BLOCK CK.PERCENT
!C ************************

1      PERCENT,,S
2      E,E,$RATE IS NOT BETWEEN 0 AND 1.$$


!      BLOCK P.WITH.C
!C **********************

1      'WITH '                 /2
2      P,,2,PLOT SYMBOL: 
3      CHAR,,S
4      Q.MARK,2,2


!      BLOCK CN.CN
!C ******************

10     END.LINE,30
20     IN.A.OUT,40,S
30     L.F.RATE,80
40     P.IN,40
50     P.OUT,50,S
!C
80     IN.A.OUT,,S
90     M.COL.ERR,40,40


!      BLOCK IN.A.OUT
!C **********************

1      GET.IN,E
2      GET.OUT,E,S


!      BLOCK P.IN
!C ******************

1      P,3,,IN FLOWS: 
2      END.LINE,,E
3      OCNAME,5
4      $,,S,S                  /2
5      COL.ERR,1,1


!      BLOCK P.OUT
!C *******************

1      P,3,,OUT FLOWS: 
2      END.LINE,,E
3      OCNAME,,S
4      COL.ERR,1,1


!      BLOCK GET.DISTRIBUTION
!C ******************************

10     P,,,DISTRIBUTION: 
20     END.LINE,,710
!C
!  NEW LIST
!C
100    NORMAL,200
110    1000,E
120    $,                      /2
130    P,,130,STANDARD DEVIATION: 
140    2000,130,S
!C
200    POISSON,300,1000
!C
300    EXPONETIAL,400,110
!C
400    BINOMIAL,500
410    P,,410,PROBABILITY OF SUCCESS: 
420    2000,410
430    PERCENT,,450
440    E,410,$MUST BE BETWEEN 0 AND 1.$$
450    $,                      /2
460    P,,460,# OF TRIALS: 
470    INT,,S
480    REAL.ERR,460,460
!C
500    UNIFORM,600
510    P,,510,LOWER LIMIT: 
520    2000,510
530    $,                      /2
540    P,,540,UPPER LIMIT: 
550    2000,540,S
!C
600    OTHER,700,S
!C
!  END LIST
!C
700    Q.MARK
710    O,5
720    C,9,10
!C
1000   P,,1000,MEAN: 
1010   2000,1000,S
!C
2000   REAL,1/REAL.ERR,S


!      BLOCK GET.TYPE
!C **********************

10     P,,10,TYPE: 
!  NEW LIST
! DEFAULT TERMINATION BLANK
! OPTION TERMINATION CARRIAGE RETURN
100    STEP,,S

200    LINEAR,300
210    C,3
220    6080/MAIN
230    240,210
235    265,235,S
!C
240    CNAME,1/COL.ERR
245    C,5
250    $,                      /2
255    'WITH ',,S              /2
260    END.LINE,240,S
!C
265    P,,265,CONSTANT && COEFFICIENTS: 
266    NUMERIC,,270
267    DATA.IN,E
268    OCNAME,,S
269    COL.ERR,265,265
270    298,265
275    280,275,S
280    P,,280,COEFFICIENTS: 
285    P,,285,NEXT COEFFICIENT: 
290    298,E
295    DCAT,285,S
!C
298    REAL,1/REAL.ERR
299    $,,S,S                  /2

300    POLYNOMIAL,400
!  NEW LIST
!  DEFAULT TERMINATION BLANK
310    DEGREE                  /2
!  END LIST
320    P,,320,DEGREE: 
330    GET.POS,320
340    C,10
345    'WITH '                 /2
350    265,350
355    360,355,S               /1
360    P,,360,START && STEP: 
370    298,360
380    P,,380,STEP: 
390    298,380,S

400    XPOS,500
410    DATA.IN,E
420    'WITH '                 /2
430    6898/MAIN
440    OCNAME,,460
450    COL.ERR,430,430
460    $,                      /2
465    6835/MAIN
470    P,,470,SEASON FOR NEXT PERIOD: 
480    GET.POS,470,S

500    AS,,520
!  5
!  OPTION TERMINATION ANY
510    =,1/Q.MARK
!  END LIST
520    C,12
530    P,,530,EXPRESSION: 
540    10/COL.EXP,530,S


!      NAME STRUCTURE
!C **********************

100    P.F.TITLE,100
110    200,110,S

200    CK.FINPAK,640
205    U,640,,SPECIAL DATA FORMAT: 
!  NEW LIST
!  DEFAULT TERMINATION CARRIAGE RETURN
210    CASH FLOWS,,600
!  OPTION TERMINATION BLANK
220    PROBABILISTIC,,330
230    MULTIPLE,270
240    800
250    D,YES.OR.NO,600
260    700,E,600
270    PARAMETRIC,,340
280    TRIANGULAR,,600
290    NONE,,650

300    YES,,310
!  END LIST
301    Q.MARK
302    O,6
303    C,9,E
!C
310    800
320    D,YES.OR.NO,360
330    700,E
340    900
350    D,YES.OR.NO,600,600
360    U,,,PARAMETRIC? 
370    D,YES.OR.NO,,340
380    900
390    D,YES.OR.NO,,600
400    U,,,TRIANGULAR? 
410    D,YES.OR.NO,,600
420    U,,,CASH FLOWS? 
430    D,YES.OR.NO,650,600

600    U,S,,$EXTRA COLUMN TITLES OR #: 
!  NEW LIST
!  DEFAULT TERMINATION CARRIAGE RETURN
601    YES,,605                /2
602    NO,610,S                /2
!  END LIST
605    1000
606    END.LINE,,S
610    INT,,S
620    LOC,,S
630    Q.MARK,600,600

640    O,1
645    O,6
650    U,650,,$COLUMN TITLES OR #: 
!  NEW LIST
651    YES,,655                /2
652    NO,660                  /2
!  END LIST
655    1000
656    END.LINE,,655
660    INT,,S
670    LOC,,S
680    Q.MARK,650,650

700    P,,,MAXIMUM NO OF CASES: 
710    720,700,S
!C
720    INT,1/Q.MARK
730    CK.CASES,750
740    END.LINE,1/Q.MARK,S
750    E,E,$MAXIMUM NUMBER OF CASES MUST BE BETWEEN 1 AND 99.

800    U,S,S,PROBABILISTIC? 

900    U,S,S,MULTIPLE CASH FLOWS? 

1000   U,S,S,PLEASE SPECIFY: 

!      BLOCK P.F.TITLE
!C ***********************

10     U,10,,TITLE: 
20     GET.TITLE,1/Q.MARK
30     END.LINE,1/Q.MARK,S


!      NAME INT.INT
!C ********************

10     INT,E
20     $,                      /2
30     INT,E
40     ' ',S,40                 /2


!      NAME FILE.STRUCTURE
!C ***************************

10     $!,E                    /2
20     $2,,30                  /2
25     O,2,90
30     40,,S
33     O,3
38     S
!  NEW LIST
!  DEFAULT TERMINATION CARRIAGE RETURN
!  OPTION TERMINATION BLANK
40     PROBABILISTIC,50
45     710/STRUCTURE,E,S
50     MULTIPLE,,S
60     PARAMETRIC,,S
65     TRIANGULAR,,S
68     SPECIAL,,S
70     SYMMETRIC,,S
!  OPTION TERMINATION BLANK
73     TITLE,80
75     GET.TITLE,E
78     END.LINE,E,S
80     BEGIN,,S
!  OPTION TERMINATION BLANK
90     IN FLOW,110
100    CNAME,E,S
!  OPTION TERMINATION BLANK
110    OUT FLOW,E,100


!      BLOCK GET.POS
!C *********************

10     END.LINE,,E
20     INT,1/REAL.ERR
30     CK.POS,50
40     $,,S,S                  /2
50     E,E,$MUST BE POSITIVE.$$


!      BLOCK GET.N.NEQ
!C ***********************

10     END.LINE,20/GET.POS
20     O,4
30     O,0,40/GET.POS


!      BLOCK IN.A.RED
!C **********************

10     DATA.IN,E
20     PROC.DATA,E,S


!      BLOCK IN.A.EXT
!C **********************

10     DATA.IN,E
20     C,20,S


!      BLOCK DATA.IN
!C *********************

10     CK.DATA.IN,,S
20     E,E,NO DATA.$


!      BLOCK CLR.ALL
!C *********************

10     CK.INP.OK,,S
20     O,4
30     ANSWER,50
40     C,7,S
50     E,E,NOT CLEARED.$


!      BLOCK YES.OR.NO
!C ***********************

!  NEW LIST
!  DEFAULT TERMINATION CARRIAGE RETURN
10     YES,30                  /2
20     O,1,S
30     NO,50                   /2
40     O,0,E
!  END LIST
50     E,,WHAT? 
60     U,50,10, 


!      BLOCK COL.EXP
!C *********************

5      C,11
10     O,16
15     30,E
20     O,17
22     $),S                    /2
25     $),,25                  /2
28     E,E,$EXCESS ')'.$$
!C
30     100,50
35     PRIMARY,E
40     O,1
45     O,1
!C
!  NEW LIST
!  DEFAULT EXACT,  TERMINATION ANY
50     +,,90
60     -,,90
65     **,,90
!  3
68     ^,,90
70     *,,90
80     /,S
!C
90     PRIMARY,E,50            /1
!C
100    $+,,E
110    $-,S,E


!      BLOCK PRIMARY
!C *********************

10     $(,100                  /2
20     O,18
30     30/COL.EXP,E
40     $),60                   /2
50     O,19,S
!C
60     E,E,$PARENTHESES DO NOT MATCH PROPERLY.$$
!C
!C
100    110,200,20
!C
110    O,20
!  NEW LIST
!  DEFAULT EXACT,  TERMINATION ANY
120    SQR,,190
130    LGT,,190
140    LOG,,190
150    EXP,,190
160    SIN,,190
170    COS,E
190    $(,E,S                  /2
!C
!C
200    NUMERIC,300
210    REAL,1/REAL.ERR,S
!C
!C
300    CK.FORC,,320
310    OCNAME,1/COL.ERR,S
320    CNAME,1/COL.ERR,S


!C     END
STATFIN ** FICHE/FRAME BREAK *****
TYMFLOWGRAPH SYMSORT

SYM.  PG.LN. IDENT.

!      40  6 !C      !      40  5 !C      !      39 33 !C      !      39 24 !C      
!      39 20 !C      !      39  5 !C      !      38 39 !C      !      38 34 !C      
!      38 33 !C      !      38 30 !C      !      38 20 !C      !      38 13 !C      
!      38  6 !C      !      37 38 !C      !      37 30 !C      !      37 20 !C      
!      37 16 !C      !      37 13 !C      !      37  8 !C      !      36 39 !C      
!      36 38 !C      !      36 37 !C      !      36 28 !C      !      36 19 !C      
!      36 11 !C      !      35 30 !C      !      35 27 !C      !      35 17 !C      
!      35 14 !C      !      35 13 !C      !      34 33 !C      !      34 22 !C      
!      34 20 !C      !      34 19 !C      !      34 11 !C      !      34  5 !C      
!      34  3 !C      !      34  2 !C      !      33 17 !C      !      33 15 !C      
!      33 14 !C      !      32 25 !C      !      32 24 !C      !      32 23 !C      
!      32 19 !C      !      31 20 !C      !      31 11 !C      !      31  1 !C      
!      30 33 !C      !      30 21 !C      !      30 12 !C      !      30  5 !C      
!      29 25 !C      !      29 17 !C      !      29 13 !C      !      29 10 !C      
!      29  4 !C      !      28 38 !C      !      28 37 !C      !      28 34 !C      
!      28 28 !C      !      28 20 !C      !      28 14 !C      !      28  8 !C      
!      28  2 !C      !      27 35 !C      !      27 29 !C      !      27 23 !C      
!      27 17 !C      !      27 11 !C      !      27  5 !C      !      26 34 !C      
!      26 26 !C      !      26 18 !C      !      26 10 !C      !      26  4 !C      
!      26  3 !C      !      25 36 !C      !      25 28 !C      !      25 21 !C      
!      25 15 !C      !      25  9 !C      !      24 30 !C      !      24 18 !C      
!      24  7 !C      !      23 35 !C      !      23 12 !C      !      23  4 !C      
!      22 36 !C      !      22 11 !C      !      22  4 !C      !      21 36 !C      
!      21 29 !C      !      21 22 !C      !      21 15 !C      !      21  8 !C      
!      21  1 !C      !      20 33 !C      !      20 24 !C      !      20 19 !C      
!      20 16 !C      !      20  3 !C      !      19 37 !C      !      19 34 !C      
!      19 32 !C      !      14 25 !C      !      14  2 !C      !      12 29 !C      
!      12 20 !C      !      12 17 !C      !      12 16 !C      !      12  6 !C      
!      11 33 !C      !      11 32 !C      !       9 32 !C      !       9 29 !C      
!       9 28 !C      !       8 35 !C      !       8 32 !C      !       8 29 !C      
!       8 28 !C      !       8  9 !C      !       8  6 !C      !       8  5 !C      
!       7 28 !C      !       7 12 !C      !       7  9 !C      !       7  6 !C      
!       7  4 !C      !       6 39 !C      !       6 35 !C      !       6 29 !C      
!       6 26 !C      !       4 29 !C      !       4 26 !C      !       1 33 !C      
!       1 26 !C      !       1 24 !C      !       1 16 !C      !       1 14 !C      
!       1 12 !C      !       1 11 !C      !       1 10 !C      !       1  9 !C      
!       1  8 !C      !       1  7 !C      !       1  6 !C      !       1  5 !C      
!C     40 21 !C      !C     39 34 !C      !C     39  6 !C      !C     38 31 !C      
!C     38 21 !C      !C     38 14 !C      !C     38  7 !C      !C     37 39 !C      
!C     37 31 !C      !C     37 21 !C      !C     36 29 !C      !C     36 20 !C      
!C     36 12 !C      !C     34 12 !C      !C     32 20 !C      !C     31 21 !C      
!C     31 12 !C      !C     31  2 !C      !C     30 34 !C      !C     30 22 !C      
!C     30 13 !C      !C     30  6 !C      !C     29 26 !C      !C     29 18 !C      
!C     29  5 !C      !C     28 35 !C      !C     28 29 !C      !C     28 21 !C      
!C     28 15 !C      !C     28  9 !C      !C     28  3 !C      !C     27 36 !C      
!C     27 30 !C      !C     27 24 !C      !C     27 18 !C      !C     27 12 !C      
!C     27  6 !C      !C     26 35 !C      !C     26 27 !C      !C     26 19 !C      
!C     26 11 !C      !C     25 37 !C      !C     25 29 !C      !C     25 22 !C      
!C     25 16 !C      !C     25 10 !C      !C     24 31 !C      !C     24 19 !C      
!C     24  8 !C      !C     23 36 !C      !C     23 13 !C      !C     23  5 !C      
!C     22 37 !C      !C     22 12 !C      !C     22  5 !C      !C     21 37 !C      
!C     21 30 !C      !C     21 23 !C      !C     21 16 !C      !C     21  9 !C      
!C     21  2 !C      !C     20 34 !C      !C     20 25 !C      !C     19 30 !C      
!C     19 29 !C      !C     19 28 !C      !C      1 19 !C      !C      1 17 !C      
!CM!   39 19 !C      !CM!   32 10 !C      !CM!   31 25 !C      !CM!    6 34 !C      
!CM!CM  1  2 !C      !CM10  29 29 !C      !CM100 39 29 !C      !CM100 32 14 !C      
!CM100 31 26 !C      !CM100 22 32 !C      !CM101  4 31 !C      !CM101  4 24 !C      
!CM105  4 39 !C      !CM107  5  2 !C      !CM108  5 19 !C      !CM108  5 17 !C      
!CM108  5 11 !C      !CM109  5 24 !C      !CM110 40  4 !C      !CM115  5 32 !C      
!CM123  5 39 !C      !CM145  6 16 !C      !CM155  6 31 !C      !CM195  7 17 !C      
!CM200 32 16 !C      !CM200 31 31 !C      !CM224  8 11 !C      !CM225  8 14 !C      
!CM226  8 16 !C      !CM227  8 18 !C      !CM228  8 25 !C      !CM228  8 22 !C      
!CM229  8 27 !C      !CM240 32 33 !C      !CM242  9  4 !C      !CM249  9 20 !C      
!CM249  9 18 !C      !CM263  9 35 !C      !CM265 32 38 !C      !CM269 10  3 !C      
!CM298 33 10 !C      !CM30  39 15 !C      !CM300 31 32 !C      !CM310 34 37 !C      
!CM316 11  7 !C      !CM318 11 19 !C      !CM342 11 31 !C      !CM349 12  8 !C      
!CM350  2  6 !C      !CM370  2  9 !C      !CM378 12 31 !C      !CM390  2 12 !C      
!CM40  24 24 !C      !CM400 31 33 !C      !CM414 13 12 !C      !CM416 13 14 !C      
!CM419 13 17 !C      !CM427 13 28 !C      !CM45  24 36 !C      !CM450  2 21 !C      
!CM470  2 26 !C      !CM474 14 13 !C      !CM477 14 19 !C      !CM477 14 18 !C      
!CM479 14 21 !C      !CM488  2 30 !C      !CM500 32  3 !C      !CM544 15 20 !C      
!CM55  22 23 !C      !CM584 16  2 !C      !CM598 16 23 !C      !CM60  40  2 !C      
!CM60  24 26 !C      !CM60  23 28 !C      !CM600 32  9 !C      !CM605 16 34 !C      
!CM608 16 37 !C      !CM619 17 12 !C      !CM639 17 28 !C      !CM654 17 37 !C      
!CM659 18  5 !C      !CM665 18 13 !C      !CM668 18 17 !C      !CM669 18 20 !C      
!CM684 18 35 !C      !CM687 19 11 !C      !CM689 19 24 !C      !CM70  29 39 !C      
!CM700 32 11 !C      !CM720 35 39 !C      !CM725  3  6 !C      !CM750  3 10 !C      
!CM768  3 15 !C      !CM770  3 16 !C      !CM779  3 20 !C      !CM780  3 21 !C      
!CM80  30 29 !C      !CM80  23 32 !C      !CM830  3 32 !C      !CM860  3 35 !C      
!CM870  3 37 !C      !CM885  3 39 !C      !CM890  4  2 !C      !CM90  39 28 !C      
!CM90  30  2 !C      !CM992 20 21 !C      !CM995  4 20 !C      1      31 14 !C      
1      31  4 !C      1      30 36 !C      1      30 15 !C      1      30  8 !C      
1      28 39 !C      1      28 31 !C      1      28 17 !C      1      28 11 !C      
1      28  5 !C      1      27 38 !C      1      27 32 !C      1      27 26 !C      
1      27 20 !C      1      27 14 !C      1      27  8 !C      1      26 37 !C      
1      26 29 !C      1      26 21 !C      1      26 13 !C      1      25 39 !C      
1      25 31 !C      1      25 18 !C      1      25 12 !C      1      23  7 !C      
1      22 39 !C      1      22  7 !C      1      21 39 !C      1      21 32 !C      
1      21 25 !C      1      21 18 !C      1      21 11 !C      1      21  4 !C      
1      20 36 !C      1      20 27 !C      1       1 20 !C      10     39 36 !C      
10     39  9 !C      10     38 35 !C      10     38 23 !C      10     38 16 !C      
10     38  9 !C      10     38  2 !C      10     37 33 !C      10     37 23 !C      
10     36 31 !C      10     36 22 !C      10     36 14 !C      10     32 22 !C      
10     31 23 !C      10     30 24 !C      10     29 20 !C      10     29  7 !C      
10     28 23 !C      10     25 24 !C      10     24 21 !C      10     24 10 !C      
10     23 38 !C      10     23 15 !C      10     22 14 !C      100    37 15 !C      
100    34 14 !C      100    32 26 !C      100     1 29 !C      1000   36  9 !C      
1000    4 22 !C      1010   32 15 !C      1010    4 23 !C      1012    4 25 !C      
1013    4 27 !C      1014    4 28 !C      1015    4 30 !C      1020    4 32 !C      
1023    4 33 !C      1025    4 34 !C      1028    4 35 !C      1030    4 36 !C      
1035    4 37 !C      1040    4 38 !C      1055    5  1 !C      1071    5  3 !C      
1072    5  4 !C      1073    5  5 !C      1074    5  6 !C      1075    5  7 !C      
1076    5  8 !C      1077    5  9 !C      1078    5 10 !C      1081    5 12 !C      
1082    5 13 !C      1083    5 14 !C      1084    5 15 !C      1085    5 16 !C      
1087    5 18 !C      1089    5 20 !C      1090    5 21 !C      1091    5 22 !C      
1092    5 23 !C      1098    5 25 !C      110    39 30 !C      110    37 17 !C      
110    34 15 !C      110    31 27 !C      110    22 33 !C      110     1 30 !C      
1100    5 27 !C      1110    5 28 !C      1120    5 29 !C      1130    5 30 !C      
1140    5 31 !C      1160    5 33 !C      1170    5 34 !C      120    40  7 !C      
120    31 28 !C      120     1 31 !C      1200    5 36 !C      1205    5 37 !C      
1220    5 38 !C      1235    6  1 !C      1240    6  2 !C      1250    6  3 !C      
1260    6  4 !C      130    40  8 !C      130    31 29 !C      1300    6  6 !C      
1310    6  7 !C      1320    6  8 !C      1330    6  9 !C      1340    6 10 !C      
140    40  9 !C      140    31 30 !C      1400    6 12 !C      1410    6 13 !C      
1420    6 14 !C      1430    6 15 !C      1460    6 17 !C      1470    6 18 !C      
1480    6 19 !C      1490    6 20 !C      15     39 10 !C      15     29 30 !C      
15     23 16 !C      15     22 15 !C      150    40 10 !C      1500    6 22 !C      
1510    6 23 !C      1520    6 24 !C      1530    6 25 !C      1535    6 27 !C      
1540    6 28 !C      1545    6 30 !C      1560    6 32 !C      1570    6 33 !C      
1580    6 36 !C      1590    6 37 !C      16     23 17 !C      160    40 11 !C      
1600    7  1 !C      1610    7  2 !C      170    40 12 !C      1700    7  5 !C      
1710    7  7 !C      1800    7 10 !C      190    40 13 !C      1900    7 13 !C      
1910    7 14 !C      1920    7 15 !C      1930    7 16 !C      1960    7 18 !C      
1970    7 19 !C      1CM!CM 40 16 !C      1CM!CM 40 14 !C      1CM!CM 40  3 !C      
2      31 15 !C      2      31  5 !C      2      30 37 !C      2      30 16 !C      
2      30  9 !C      2      29  1 !C      2      26 38 !C      2      26 30 !C      
2      26 22 !C      2      26 14 !C      2      26  1 !C      2      25 32 !C      
2      23  8 !C      2      23  1 !C      2      22  8 !C      2      22  1 !C      
2      21 33 !C      2      21 26 !C      2      21 19 !C      2      21 12 !C      
2      21  5 !C      2      20 37 !C      2      20 28 !C      2       1 21 !C      
20     39 37 !C      20     39 11 !C      20     38 36 !C      20     38 24 !C      
20     38 17 !C      20     38 10 !C      20     38  3 !C      20     37 34 !C      
20     37 24 !C      20     36 32 !C      20     36 23 !C      20     36 15 !C      
20     31 24 !C      20     30 25 !C      20     29 31 !C      20     29 21 !C      
20     29  8 !C      20     28 24 !C      20     25 25 !C      20     24 22 !C      
20     24 11 !C      20     23 39 !C      20     23 18 !C      20     22 16 !C      
200    34 17 !C      200    32 28 !C      200     1 34 !C      2000    7 21 !C      
2010    7 22 !C      2020    7 23 !C      2030    7 24 !C      2040    7 25 !C      
205    34 18 !C      210    40 15 !C      210    34 21 !C      210    32 29 !C      
210     1 35 !C      2100    7 27 !C      2101    7 29 !C      2105    7 30 !C      
2108    7 31 !C      2110    7 32 !C      2120    7 33 !C      2130    7 34 !C      
2140    7 35 !C      2150    7 36 !C      2160    7 37 !C      2170    7 38 !C      
2180    7 39 !C      22     39 12 !C      220    34 23 !C      220    32 30 !C      
2200    8  2 !C      2210    8  3 !C      2215    8  4 !C      2220    8  7 !C      
2225    8  8 !C      2230    8 10 !C      2242    8 12 !C      2245    8 13 !C      
2255    8 15 !C      2265    8 17 !C      2272    8 19 !C      2275    8 20 !C      
2278    8 21 !C      2282    8 23 !C      2284    8 24 !C      2288    8 26 !C      
2292    8 30 !C      2294    8 31 !C      2296    8 33 !C      230    34 24 !C      
230    32 31 !C      235    32 32 !C      240    34 25 !C      2400    8 37 !C      
2405    8 38 !C      2408    8 39 !C      2410    9  1 !C      2415    9  2 !C      
2420    9  3 !C      2428    9  5 !C      2430    9  6 !C      2435    9  7 !C      
2440    9  8 !C      2445    9  9 !C      245    32 34 !C      2450    9 10 !C      
2455    9 11 !C      2460    9 12 !C      2465    9 13 !C      2470    9 14 !C      
2475    9 15 !C      2480    9 16 !C      2485    9 17 !C      2493    9 19 !C      
2498    9 21 !C      25     39 13 !C      25     36 33 !C      25     29 32 !C      
25     22 17 !C      250    34 26 !C      250    32 35 !C      2500    9 23 !C      
255    32 36 !C      260    34 27 !C      260    32 37 !C      2600    9 25 !C      
2605    9 26 !C      2608    9 27 !C      2610    9 30 !C      2615    9 31 !C      
2620    9 33 !C      2625    9 34 !C      2635    9 36 !C      2640    9 37 !C      
2645    9 38 !C      2650    9 39 !C      2655   10  1 !C      266    32 39 !C      
2660   10  2 !C      267    33  1 !C      268    33  2 !C      269    33  3 !C      
2695   10  4 !C      270    34 28 !C      270    33  4 !C      2700   10  6 !C      
2705   10  7 !C      2710   10  8 !C      2720   10  9 !C      2730   10 10 !C      
2740   10 11 !C      275    33  5 !C      2750   10 12 !C      28     39 14 !C      
28     29 33 !C      280    34 29 !C      280    33  6 !C      2800   10 14 !C      
2810   10 15 !C      2820   10 16 !C      2830   10 17 !C      2840   10 18 !C      
285    33  7 !C      2850   10 19 !C      2860   10 20 !C      290    34 30 !C      
290    33  8 !C      2900   10 22 !C      2910   10 23 !C      2920   10 24 !C      
2930   10 25 !C      2940   10 26 !C      295    33  9 !C      2950   10 27 !C      
2960   10 28 !C      2970   10 29 !C      2975   10 30 !C      2980   10 31 !C      
2985   10 32 !C      299    33 11 !C      2990   10 33 !C      2995   10 34 !C      
2998   10 35 !C      3      31 16 !C      3      31  6 !C      3      30 17 !C      
3      26 39 !C      3      26 31 !C      3      26 23 !C      3      26 15 !C      
3      26  2 !C      3      25 33 !C      3      20 29 !C      3       1 22 !C      
30     39 38 !C      30     38 37 !C      30     38 25 !C      30     37 35 !C      
30     37 25 !C      30     36 34 !C      30     36 24 !C      30     36 16 !C      
30     30 26 !C      30     29 34 !C      30     29 22 !C      30     29  9 !C      
30     28 25 !C      30     24 33 !C      30     24 23 !C      30     24 12 !C      
30     24  1 !C      30     23 19 !C      30     22 18 !C      300    34 32 !C      
300    33 13 !C      300     1 37 !C      3000   10 37 !C      301    34 34 !C      
302    34 35 !C      303    34 36 !C      310    40 17 !C      310    33 16 !C      
310     1 38 !C      3100   10 39 !C      3105   11  1 !C      3110   11  2 !C      
3120   11  3 !C      3130   11  4 !C      3140   11  5 !C      3150   11  6 !C      
3162   11  8 !C      3164   11  9 !C      3166   11 10 !C      3168   11 11 !C      
3170   11 12 !C      3172   11 13 !C      3174   11 14 !C      3175   11 15 !C      
3176   11 16 !C      3177   11 17 !C      3178   11 18 !C      3190   11 20 !C      
320    40 18 !C      320    34 38 !C      320    33 18 !C      320     1 39 !C      
3200   11 22 !C      3210   11 23 !C      3220   11 24 !C      33     36 35 !C      
330    34 39 !C      330    33 19 !C      330     2  1 !C      3300   11 26 !C      
340    35  1 !C      340    33 20 !C      340     2  2 !C      3400   11 28 !C      
3410   11 29 !C      3415   11 30 !C      3421   11 34 !C      3425   11 35 !C      
343     2  3 !C      3430   11 36 !C      3435   11 37 !C      3440   11 38 !C      
3445   11 39 !C      345    33 21 !C      345     2  4 !C      3450   12  1 !C      
3455   12  2 !C      3460   12  3 !C      3465   12  4 !C      3470   12  5 !C      
348     2  5 !C      3480   12  7 !C      3495   12  9 !C      35     39 16 !C      
35     29 35 !C      35     24 34 !C      35     23 20 !C      35     22 19 !C      
350    35  2 !C      350    33 22 !C      3500   12 11 !C      3510   12 12 !C      
3520   12 13 !C      3530   12 14 !C      3540   12 15 !C      355    33 23 !C      
3590   12 18 !C      360    35  3 !C      360    33 24 !C      360     2  7 !C      
365     2  8 !C      370    35  4 !C      370    33 25 !C      3700   12 22 !C      
3710   12 23 !C      3720   12 24 !C      3730   12 25 !C      3740   12 26 !C      
375     2 10 !C      3750   12 27 !C      3760   12 28 !C      3770   12 30 !C      
3790   12 32 !C      38     36 36 !C      38     23 21 !C      380    35  5 !C      
380    33 26 !C      380     2 11 !C      3800   12 34 !C      3810   12 35 !C      
3820   12 36 !C      3830   12 37 !C      390    35  6 !C      390    33 27 !C      
3900   12 39 !C      395     2 13 !C      4      31 17 !C      4      31  7 !C      
4      30 18 !C      4      27  1 !C      4      26  5 !C      4      20 30 !C      
40     39 39 !C      40     39 17 !C      40     38 38 !C      40     38 26 !C      
40     37 26 !C      40     37  1 !C      40     36 25 !C      40     30 27 !C      
40     29 36 !C      40     29 11 !C      40     24 35 !C      40     24 13 !C      
40     24  2 !C      40     23 22 !C      40     22 20 !C      400    35  7 !C      
400    33 29 !C      400     2 15 !C      4000   13  2 !C      405     2 16 !C      
410    35  8 !C      410    33 30 !C      410    31 34 !C      4100   13  4 !C      
4105   13  5 !C      4110   13  6 !C      4115   13  7 !C      4120   13  8 !C      
4125   13  9 !C      4130   13 10 !C      4135   13 11 !C      4150   13 13 !C      
4170   13 15 !C      4180   13 16 !C      4195   13 18 !C      420    35  9 !C      
420    33 31 !C      420    31 35 !C      420     2 17 !C      4200   13 20 !C      
4205   13 21 !C      4210   13 22 !C      4220   13 23 !C      4230   13 24 !C      
4240   13 25 !C      425     2 18 !C      4250   13 26 !C      4260   13 27 !C      
4280   13 29 !C      4290   13 30 !C      430    35 10 !C      430    33 32 !C      
430    31 36 !C      430     2 19 !C      4300   13 32 !C      4310   13 33 !C      
4320   13 34 !C      4330   13 35 !C      4340   13 36 !C      4350   13 37 !C      
440    33 33 !C      440    31 37 !C      440     2 20 !C      4400   13 39 !C      
45     39 18 !C      45     37  2 !C      45     29 37 !C      45     23 23 !C      
45     22 21 !C      450    33 34 !C      450    31 38 !C      455     2 22 !C      
458     2 23 !C      460    33 35 !C      460    31 39 !C      460     2 24 !C      
465    33 36 !C      465     2 25 !C      470    33 37 !C      470    32  1 !C      
4700   14  4 !C      4710   14  5 !C      4712   14  6 !C      4715   14  7 !C      
4720   14  8 !C      4725   14  9 !C      4730   14 10 !C      4735   14 11 !C      
4740   14 12 !C      475     2 27 !C      4750   14 14 !C      4755   14 15 !C      
4760   14 16 !C      4765   14 17 !C      4780   14 20 !C      4795   14 22 !C      
480    33 38 !C      480    32  2 !C      480     2 28 !C      485     2 29 !C      
5      39  8 !C      5      31  8 !C      5      29 28 !C      5      27  2 !C      
5      26  6 !C      50     40  1 !C      50     39 21 !C      50     39  1 !C      
50     38 27 !C      50     37 27 !C      50     37  3 !C      50     30 28 !C      
50     29 38 !C      50     29 12 !C      50     24 37 !C      50     24 25 !C      
50     24 14 !C      50     24  3 !C      50     23 24 !C      50     22 22 !C      
500    34  1 !C      500     2 32 !C      5000   14 27 !C      5010   14 28 !C      
5020   14 29 !C      51     23 25 !C      510    34  4 !C      510    32  4 !C      
510     2 33 !C      5100   14 31 !C      515     2 34 !C      52     23 26 !C      
520    34  6 !C      520    32  5 !C      520     2 35 !C      5200   14 33 !C      
5210   14 34 !C      5220   14 35 !C      5230   14 36 !C      5240   14 37 !C      
5250   14 38 !C      5255   14 39 !C      5260   15  1 !C      5270   15  2 !C      
5280   15  3 !C      530    34  7 !C      530    32  6 !C      530     2 36 !C      
5300   15  5 !C      5310   15  6 !C      5320   15  7 !C      5330   15  8 !C      
5340   15  9 !C      5350   15 10 !C      5360   15 11 !C      5370   15 12 !C      
5380   15 13 !C      5390   15 14 !C      540    34  8 !C      540    32  7 !C      
5400   15 16 !C      5410   15 17 !C      5420   15 18 !C      5430   15 19 !C      
5450   15 21 !C      5460   15 22 !C      5470   15 23 !C      5480   15 24 !C      
55     23 27 !C      550    32  8 !C      5500   15 26 !C      5600   15 28 !C      
5610   15 29 !C      5700   15 31 !C      5710   15 32 !C      5800   15 34 !C      
5810   15 35 !C      5820   15 36 !C      5825   15 37 !C      5830   15 38 !C      
5835   15 39 !C      5838   16  1 !C      5850   16  3 !C      5860   16  4 !C      
5870   16  5 !C      5880   16  6 !C      5890   16  7 !C      5900   16  9 !C      
5910   16 10 !C      5915   16 11 !C      5920   16 12 !C      5925   16 13 !C      
5930   16 14 !C      5935   16 15 !C      5940   16 16 !C      5943   16 17 !C      
5945   16 18 !C      5950   16 19 !C      5955   16 20 !C      5960   16 21 !C      
5965   16 22 !C      5985   16 24 !C      5990   16 25 !C      6      26  7 !C      
60     39 22 !C      60     39  2 !C      60     37  4 !C      60     29 14 !C      
60     24 38 !C      60     24 15 !C      60     24  4 !C      60     22 24 !C      
600    35 12 !C      600     2 38 !C      6000   16 27 !C      601    35 15 !C      
6010   16 28 !C      602    35 16 !C      6020   16 29 !C      6025   16 30 !C      
6030   16 31 !C      6040   16 32 !C      6045   16 33 !C      605    35 18 !C      
606    35 19 !C      6060   16 35 !C      6070   16 36 !C      610    35 20 !C      
6100   16 39 !C      6110   17  1 !C      6115   17  2 !C      6120   17  3 !C      
6130   17  4 !C      6140   17  5 !C      6145   17  6 !C      6150   17  7 !C      
6160   17  8 !C      6170   17  9 !C      6175   17 10 !C      6180   17 11 !C      
620    35 21 !C      6200   17 14 !C      630    35 22 !C      6300   17 16 !C      
6310   17 17 !C      6311   17 18 !C      6312   17 19 !C      6313   17 20 !C      
6320   17 21 !C      6340   17 22 !C      6350   17 23 !C      6355   17 24 !C      
6360   17 25 !C      6370   17 26 !C      6385   17 27 !C      6395   17 29 !C      
640    35 24 !C      6400   17 31 !C      645    35 25 !C      65     39 23 !C      
65     37  5 !C      65     23 29 !C      650    35 26 !C      6500   17 33 !C      
651    35 28 !C      6510   17 34 !C      652    35 29 !C      6520   17 35 !C      
6530   17 36 !C      6545   17 38 !C      655    35 31 !C      6550   17 39 !C      
6555   18  1 !C      656    35 32 !C      6560   18  2 !C      6570   18  3 !C      
6580   18  4 !C      660    35 33 !C      6600   18  7 !C      6610   18  8 !C      
6615   18  9 !C      6620   18 10 !C      6630   18 11 !C      6640   18 12 !C      
6655   18 14 !C      6660   18 15 !C      6670   18 16 !C      6685   18 18 !C      
6688   18 19 !C      670    35 34 !C      6700   18 22 !C      68     39 25 !C      
68     37  6 !C      68     23 30 !C      680    35 35 !C      6800   18 24 !C      
6803   18 25 !C      6805   18 26 !C      6808   18 27 !C      6810   18 28 !C      
6815   18 29 !C      6820   18 30 !C      6825   18 31 !C      6830   18 32 !C      
6835   18 33 !C      6838   18 34 !C      6842   18 36 !C      6844   18 37 !C      
6846   18 38 !C      6848   18 39 !C      6850   19  1 !C      6852   19  2 !C      
6854   19  3 !C      6856   19  4 !C      6858   19  5 !C      6860   19  6 !C      
6861   19  7 !C      6862   19  8 !C      6864   19  9 !C      6865   19 10 !C      
6872   19 12 !C      6876   19 13 !C      6878   19 14 !C      6880   19 15 !C      
6882   19 16 !C      6884   19 17 !C      6886   19 18 !C      6888   19 19 !C      
6890   19 20 !C      6892   19 21 !C      6894   19 22 !C      6896   19 23 !C      
70     39 26 !C      70     37  7 !C      70     24 39 !C      70     24 27 !C      
70     23 31 !C      70     22 25 !C      700    35 37 !C      700     3  1 !C      
703     3  2 !C      710    35 38 !C      710    32 12 !C      710     3  3 !C      
715     3  4 !C      720    32 13 !C      720     3  5 !C      73     37  9 !C      
73     25  1 !C      730    36  1 !C      730     3  7 !C      735     3  8 !C      
740    36  2 !C      740     3  9 !C      75     37 10 !C      75     25  2 !C      
75     22 26 !C      750    36  3 !C      755     3 11 !C      760     3 12 !C      
765     3 13 !C      766     3 14 !C      771     3 17 !C      774     3 18 !C      
775     3 19 !C      78     37 11 !C      78     25  3 !C      785     3 22 !C      
788     3 23 !C      789     3 24 !C      79     25  4 !C      80     39 27 !C      
80     37 12 !C      80     30  1 !C      80     25  5 !C      80     22 27 !C      
800    36  5 !C      800     3 26 !C      805     3 27 !C      810     3 28 !C      
820     3 29 !C      825     3 30 !C      828     3 31 !C      840     3 33 !C      
85     22 28 !C      850     3 34 !C      865     3 36 !C      880     3 38 !C      
886     4  1 !C      895     4  3 !C      90     37 14 !C      90     30 30 !C      
90     25  6 !C      90     22 29 !C      900    36  7 !C      900     4  5 !C      
910     4  6 !C      920     4  7 !C      930     4  8 !C      940     4  9 !C      
95     22 30 !C      950     4 10 !C      960     4 11 !C      970     4 12 !C      
972     4 13 !C      974     4 14 !C      976     4 15 !C      98     22 31 !C      
980     4 16 !C      983     4 17 !C      985     4 18 !C      990     4 19 !C      
9900   19 36 !C      9901   19 38 !C      9902   19 39 !C      9903   20  1 !C      
9904   20  2 !C      9905   20  4 !C      9906   20  5 !C      9907   20  6 !C      
9908   20  7 !C      9909   20  8 !C      9910   20  9 !C      9911   20 10 !C      
9912   20 11 !C      9913   20 12 !C      9914   20 13 !C      9915   20 14 !C      
9916   20 15 !C      9917   20 17 !C      9918   20 18 !C      9919   20 20 !C      

STATFIN ** FICHE/FRAME BREAK *****
WORK
C:WORK   08/14/72              WORK OVERLAY.
C
C
       OVERLAY WORK,4
C
       NORMAL MODE IS INTEGER
C
C
       SHARE $FILES
       SHARE SIZE,  LIST SIZE
       SHARE NO OF NODES,  NO OF FUNCTION,  NO OF BLOCKS,  NO OF NAMES
       SHARE P FUNCTION,  P BLOCK,  P TEXT,  C TEXT
       SHARE FUNCTIONS(2,64),  BLOCKS(3,128),  LISA(0/255)
       SHARE VALUE(214),  DEF(1280),  ALT(1280),  SUC(1280)
       SHARE TEXT(1749),  LIS(1536)
       EQUIVALENCE (NO OF LISTS, LISA(0))
       DATA NO OF NODES,  NO OF LISTS,  SIZE/0/
       DATA P FUNCTION,  P BLOCK,  P TEXT,  C TEXT/0/
C
C
       GLOBAL LABEL(0/1280),  NAME(3)
       GLOBAL LIS MAX,  LISA MAX,  TEXT MAX,  STATE,  ENTRY1,  ENTRY2
       DATA LABEL(0)/0/,  LIS MAX/1536/,  LISA MAX/255/,  TEXT MAX/1792/
       DATA STATE/1/,  ENTRY1/0/,  ENTRY2/1537/
C
       GLOBAL STD DEFAULT(3),  DEFAULT(3,2),  CUR DEFAULT(3)
       LOGICAL STD PRIORITY,  CUR PRIORITY
       EQUIVALENCE (STD MINIMUM,STD DEFAULT(1)),
+                  (STD TERMINATION, STD DEFAULT(2)),
+                  (STD PRIORITY, STD DEFAULT(3)),
+                  (CUR MINIMUM, CUR DEFAULT(1)),
+                  (CUR TERMINATION, CUR DEFAULT(2)),
+                  (CUR PRIORITY, CUR DEFAULT(3))
       DATA STD MINIMUM,  STD TERMINATION,  STD PRIORITY/0,1,.FALSE./
C
       GLOBAL COMMAND,  COM NEXT,  NEXT COM,  COM NO,  NO OF COMMANDS
       LOGICAL COMMAND,  COM NEXT
       DATA COM NEXT/.FALSE./,  NEXT COM/0/
C
       GLOBAL LIST NO,  SIGMA,  NULL,  NEW NODE,  LEVEL
       LOGICAL NEW NODE
       DATA SIGMA/4B7/,  NULL/0/,  LEVEL/0/
C
       GLOBAL FUN MAX,  NAM MAX,  BLK MAX
       DATA FUN MAX/64/,  NAM MAX/64/,  BLK MAX/128/
C
       GLOBAL COM VAL,  CHR VAL,  STR VAL,  FUN VAL,  BLK VAL
       GLOBAL BLK VAL,  LAB VAL,  SPC VAL(6)
       DATA COM VAL,  CHR VAL,  STR VAL,  FUN VAL,  BLK VAL,  LAB VAL
+              /1, 2, 3, 4, 6, 8/
       DATA SPC VAL/9, 10, 11, 12, 13, 14/
C
       GLOBAL SPC NODES(7)
       DATA SPC NODES/1HP, 1HU, 1HE, 1HO, 1HC, 1HS, 1HD/
C
       GLOBAL VALUE SHIFT,  TERM SHIFT
       DATA VALUE SHIFT/20/,  RULE SHIFT/16/,  TERM SHIFT/18/
       DATA NAME TERM/4K18/
C
       LOGICAL NEED BLOCK,  STD COMMAND,  FLAG
       DATA NEED BLOCK/.TRUE./,  STD COMMAND/.FALSE./,  LINE NO/0/
C
C
       LOGICAL END OF LINE,  CHECK NAME
       EXTERNAL GET VALUE,  END OF LINE,  GET INTEGER
C
C
C
       CALL MOVE OPTIONS(STD DEFAULT,DEFAULT(1,1))
       CALL MOVE OPTIONS(DEFAULT(1,1),CUR DEFAULT)
C
C
C      MAIN LOOP.
C
100$   CALL READ FILE(NCHARS,3+STD COMMAND)
       IF NCHARS<0,
+              IF STD COMMAND,  CLOSE 2;  STD COMMAND=.FALSE.;
+                              GO TO 100$  .ELSE.  GO TO 900

       IF .NOT.STD COMMAND,  LINE NO=LINE NO+1
       NEW NODE=.FALSE.

       IF NOWCHR(0).NE.1R!, GO TO 500
       CALL NEXTCHR(1)

       GO TO (210,220,230,240,250,260,270,280,290,300,310)
+              KOMMAND(1), 400

C
C NEW LIST.
C
210    IF STATE>1,   CALL STACK,  SET STATE(1)
       CALL SET STATE(2)
       LIST NO=(NO OF LIST=NO OF LIST+1)
       IF NO OF LIST>LISA MAX,  CALL FATAL ERROR(1)
       LISA(LIST NO)=ENTRY1+1
       COM NO=1
       NO OF COMMANDS=0
       COM NEXT=.TRUE.
       GO TO 410
C
C DEFAULT.
C
220    CALL READ OPTIONS(DEFAULT(1,STATE))
       CALL MOVE OPTIONS(DEFAULT(1,STATE),CUR DEFAULT)
       GO TO 410
C
C COMMENT.
C
230    GO TO 100$
C
C OPTIONS.
C
240    CALL READ OPTIONS(CUR DEFAULT)
       GO TO 410
C
C SFE.
C
250    OPEN INPUT,2,ZADPARSFE :  ERROR   CALL ERROR(24)
       STD COMMAND=.TRUE.
       GO TO 410
C
C SIZE.
C
260    IF ( (I=GET INTEGER)<=0 ),  CALL ERROR(22)
       SIZE=I
       GO TO 410
C
C FUNCTIONS.
C
270    IF CHECK NAME(.FALSE.),  GO TO 275
       IF ( ( NO OF FUNCTIONS=NO OF FUNCTIONS+1)>FUN MAX ),
+              CALL FATAL ERROR(2)
       FUNCTION(1,NO OF FUNCTION)=NAME(1)
       FUNCTION(2,NO OF FUNCTION)=NAME(2)
275    IF NOWCHR(0).EQ.1R,, CALL NEXTCHR(0);  GO TO 270
       GO TO 100$
C
C NAME.
C
280    FLAG=.TRUE.
285    IF STATE#1, CALL END LIST,  RET ERROR(27)
       CALL CHECK NAME(.TRUE.)
       NEED BLOCK=.FALSE.
       IF .NOT.FLAG, GO TO 410
       BLOCKS(3, P BLOCK)=IOR(BLOCKS(3, P BLOCK), 4B7, NAME TERM)
       GO TO 410
C
C BLOCK.
C
290    FLAG=.FALSE.
       GO TO 285
C
C END LIST.
C
300    IF STATE.EQ.1, CALL ERROR(34)
       CALL END LIST
       GO TO 410
C
C TERMINATION FOR GRAPH SCANS.
C
310    NAME TERM=(I=KOMMAND(3))-1
       IF I,  311,313,312
311    NAME TERM=GET INTEGER
       IF NAME TERM>7,  CALL ERROR(5)
312    NAME TERM=LSH(NAME TERM, TERM SHIFT)
       GO TO 410
313    CALL ERROR(12)
C
C COMMAND NUMBER
C
400    IF ( (I=GET INTEGER)>777K ),  CALL ERROR(1)
       COM NO=I
C
C CHECK FOR PROPER LINE TERMINATION.
C
410    IF NOWCHR(0)>0, CALL RET ERROR(10)
       GO TO 100$
C
C READ IN A NODE.
C
500    IF END OF LINE, GO TO 100$
C
       IF NEED BLOCK, CALL FATAL ERROR(8)
C
       CALL GET LABEL
       GO TO (510, 510, 511, 520, 520, 530) GET VALUE, 550
C
C
510    CALL GET REF(ALT)
       CALL GET REF(SUC)
       IF NOWCHR(0)#1R,, CALL ERROR(11)
       CALL NEXTCHR(1)
       GO TO 512
511    ALT(NO OF NODES)=NULL
       CALL GET REF(SUC)
       IF NOWCHR(0)#1R,, CALL ERROR(11)
       IF NEXTCHR(1)<0, CALL ERROR(18)
512    DEF(NO OF NODES)=P TEXT+1
       CALL PACK
       GO TO 100$
C
C
520    CALL NEXTCHR(0)
       IF ( (I=GET INTEGER)>7777K ),  CALL ERROR(2)
       DEF(NO OF NODES)=I
       ALT(NO OF NODES)=NULL
521    CALL GET REF(SUC)
522    IF END OF LINE, GO TO 100$
       IF NOWCHR(0)#1R/, CALL ERROR(10)
       CALL NEXTCHR(0)
       IF ( (I=GET INTEGER)>7 ),  CALL ERROR(3)
       DEF(NO OF NODES)=IOR(DEF(NO OF NODES), LSH(I, RULE SHIFT))
       IF END OF LINE, GO TO 100$
       CALL ERROR(10)
C
C
530    ALT(NO OF NODES)=SUC(NO OF NODES)=SIGMA
       GO TO 522
C
C
550    CALL GET REF(ALT)
       IF .NOT.COMMAND, GO TO 521
       IF ALT(NO OF NODES).EQ.NULL .OR. ALT(NO OF NODES).EQ.SIGMA,
+              CALL END LIST  .ELSE.  NEXT COM=ALT(NO OF NODES)
       GO TO 521
C
C END OF GRAPH.
C
900    CALL OUTMSG(1,1,35)
C
905    IF STATE>1, CALL END LIST,  DISMSG(1,27);  GO TO 905
C
       ENTRY2=ENTRY2-1
       DO 910 I=1, NO OF LISTS
910    LISA(I)=LISA(I)-ENTRY2
       DO 920 LIST SIZE=1,LIS MAX-ENTRY2
920    LIS(LIST SIZE)=LIS(LIST SIZE+ENTRY2)
       LIST SIZE=LIST SIZE-1
C
       DO 930 I=1, NO OF BLOCKS
       IF BLOCKS(3,I)#0, GO TO 930
       CALL DISMSG(1,28)
       CALL DISSYM(BLOCKS(1,I))
       CALL DISMSG(1,29)
       BLOCKS(3,I)=4B3
930    CONTINUE
C
       CALL FIX CHAINS
C
       NO OF NAMES=0
       IF NO OF BLOCKS<=0,  CALL FATAL ERROR(10)
       DO 940 I=1, NO OF BLOCKS
       IF BLOCKS(3,I)>=0, GO TO 940
       NO OF NAMES=NO OF NAMES+1
       BLOCKS(1, NO OF NAMES)=BLOCKS(1,I)
       BLOCKS(2, NO OF NAMES)=BLOCKS(2,I)
       BLOCKS(3, NO OF NAMES)=IAND(BLOCKS(3,I),37777777B)
940    CONTINUE
C
       IF NO OF NAMES>0,  GO TO 950
       CALL DISMSG(1,30)
       CALL DISSYM(BLOCKS)
       CALL DISMSG(1,31)
       NO OF NAMES=1
C
950    I=2
       I=I+2*NO OF NODES
       I=I+P TEXT
       I=I+NO OF FUNCTIONS
       I=I+3*NO OF NAMES+1
       I=I+NO OF LISTS+1
       I=I+ENTRY1
       IF SIZE#0, IF I>SIZE, CALL FATAL ERROR(9)
C
       TERMINATE OVERLAY


       SUBROUTINE SET STATE(S)

       IF S-STATE,  1,4,2
1      CALL MOVE OPTIONS(DEFAULT(1,S),CUR DEFAULT)
       GO TO 3
2      CALL MOVE OPTIONS(CUR DEFAULT,DEFAULT(1,S))
3      STATE=S
4      RETURN

       SUBROUTINE ERROR(ERR NO)
       CALL DIS ERROR(1,ERR NO)
       GO TO 100$

       SUBROUTINE FATAL ERROR(F ERR NO)
       CALL DIS ERROR(2,F ERR NO)
       CLOSE; CLOSE -1
       CALL BRS(11,0,0,-1)
       QUIT

       SUBROUTINE RET ERROR(R ERR NO)
       CALL DIS ERROR(1,R ERR NO)
       RETURN

       SUBROUTINE DIS ERROR(ERR LIST,ERR NUM)
       CALL DISPLAY('$LINE #/')
       CALL DISNUM(LINE NO)
       CALL DISCHR(155K)
       CALL GET COUNT(N)
       CALL DIS INPUT(1,N+1)
       CALL DISCHR(155K)
       CALL GET POINT(N)
       DO 5,I=1,N-1
5      CALL DISCHR(0)
       CALL DISPLAY('^$/')

       CALL DISMSG(ERR LIST,ERR NUM)
       CALL DISCHR(155K)
       IF NEW NODE, NO OF NODES=NO OF NODES-1
       RETURN

       END
STATFIN ** FICHE/FRAME BREAK *****
WORK SYMSORT

SYM.  PG.LN. IDENT.

+       5  8 C:WORK  +       3 18 C:WORK  +       2 25 C:WORK  +       2 16 C:WORK  
+       2 15 C:WORK  +       1 38 C:WORK  +       1 25 C:WORK  +       1 24 C:WORK  
+       1 23 C:WORK  +       1 22 C:WORK  +       1 21 C:WORK  1       6 16 C:WORK  
2       6 18 C:WORK  275     3 21 C:WORK  285     3 25 C:WORK  3       6 19 C:WORK  
311     4  2 C:WORK  312     4  4 C:WORK  313     4  6 C:WORK  4       6 20 C:WORK  
5       7  6 C:WORK  511     4 23 C:WORK  512     4 27 C:WORK  521     4 34 C:WORK  
522     4 35 C:WORK  910     5 15 C:WORK  920     5 17 C:WORK  930     5 25 C:WORK  
940     5 35 C:WORK  CM      6 10 C:WORK  CM      5 36 C:WORK  
CM      5 27 C:WORK  CM      5 26 C:WORK  CM      5 19 C:WORK  CM      5 13 C:WORK  
CM      4 16 C:WORK  CM      4 15 C:WORK  CM      2  6 C:WORK  CM      2  3 C:WORK  
CM      2  1 C:WORK  CM      1 35 C:WORK  CM      1 33 C:WORK  CM      1 30 C:WORK  
CM      1 27 C:WORK  CM      1 18 C:WORK  CM      1  3 C:WORK  CM100$  2 13 C:WORK  
CM210   2 28 C:WORK  CM220   2 38 C:WORK  CM230   3  3 C:WORK  CM240   3  5 C:WORK  
CM250   3  8 C:WORK  CM260   3 12 C:WORK  CM270   3 16 C:WORK  CM280   3 24 C:WORK  
CM290   3 32 C:WORK  CM300   3 35 C:WORK  CM310   3 39 C:WORK  CM400   4  8 C:WORK  
CM410   4 11 C:WORK  CM500   4 14 C:WORK  CM900   5 11 C:WORK  CM905   5 12 C:WORK  
CM950   6  2 C:WORK  CMC     5 10 C:WORK  CMC     4 13 C:WORK  CMC     4 10 C:WORK  
CMC     4  7 C:WORK  CMC     3 38 C:WORK  CMC     3 34 C:WORK  CMC     3 31 C:WORK  
CMC     3 23 C:WORK  CMC     3 15 C:WORK  CMC     3 11 C:WORK  CMC     3  7 C:WORK  
CMC     3  4 C:WORK  CMC     3  2 C:WORK  CMC     2 37 C:WORK  CMC     2 27 C:WORK  
CMCM    2  8 C:WORK  CMCM    1 14 C:WORK  CMCM    1  4 C:WORK  CMCM    1  2 C:WORK  
CMCM51  4 18 C:WORK  CMCM52  4 30 C:WORK  CMCM53  5  3 C:WORK  CMCM55  5  5 C:WORK  
CMCMC   2 12 C:WORK  CMCMCM  2 10 C:WORK  
STATFIN ** FICHE/FRAME BREAK *****
XPOS
       SUBROUTINE XPOS(A,N1,IH,L,N2,N3,NF)
       GLOBAL NOOFCO,NOOFRO,STATE,INP OK
       LOGICAL INP OK
       INTEGER STATE
       REAL A(NOOFCO,NOOFRO)
       DIMENSION V(30),F(30),FTEMP(60)
       IF((NOOFRO/L).GT.30) TYPE 100 ;STATE=2;RETURN
       IF(L.GT.30)TYPE 150 ;STATE=2;RETURN
       IF(IH.GE.NOOFRO)TYPE 160;STATE=2;RETURN
       IF((IH/L).LT.2)TYPE 165;STATE=2;RETURN
100    FORMAT(/$NO. OF YEARS CANNOT EXCEED 30 $/)
150    FORMAT(/$NO. OF SEASONS CANNOT EXCEED 30 $/)
160    FORMAT(/$NO. OF INITIAL PERIODS MUST BE LESS THAN TOTAL PERIODS$/)
165    FORMAT(/$NO. OF INITIAL PERIODS MUST BE GREATER THAN AND$/
     +$ A MULTIPLE OF NO. OF SEASONS$/)
170    FORMAT(/$PRINT PAST SMOOTHED SERIES ? $Z)
171    FORMAT(A1)
172    FORMAT(/$PRINT COMPUTED PARAMETERS ? $Z)
       ICOUNT=0
       IT=0
       I=1
210    V(I)=0.
220    IT=IT+1
       V(I)=V(I)+A(N1,IT)
       ITEMP=L*I
       IF(IT-ITEMP)220,225,225
225    V(I)=V(I)/FLOAT(L)
       IF(IT-IH)228,230,230
228    I=I+1
       GO TO 210
230    ITEMP=IH-L
       R=(V(I)-V(1))/FLOAT(ITEMP)
       S0=V(1)
       CL2=(FLOAT(L)+1.)/2.
       STEMP=S0
       RTEMP=R
240    IT=0
250    I=1
260    J=1
270    IT=IT+1
       TEMP=CL2-FLOAT(J)
       F(IT)=A(N1,IT)/(V(I)-(TEMP)*R)
       FTEMP(IT)=F(IT)
       ITEMP=L*I
       IF(IT.GE.ITEMP) GO TO 280
       J=J+1
       GO TO 270
280    IF(IT.GE.IH) GO TO 290
       I=I+1
       GO TO 260
290    M=IH/L
       F1=0.
       J=1
300    K=1
310    IF(K.GE.M) GO TO 320
       ITEMP=J+K*L
       F(J)=F(J)+F(ITEMP)
       K=K+1
       GO TO 310
320    F(J)=F(J)/FLOAT(M)
       F1=F1+F(J)
       IF(J.GE.L) GO TO 330
       J=J+1
       GO TO 300
330    F2=FLOAT(L)/F1
       J=1
340    F(J)=F2*F(J)
       FTEMP(J)=F(J)
       IF(J.GE.L) GO TO 350
       J=J+1
       GO TO 340
350    EMIN=1.E76
       ICOUNT=0
       DO 500 IX=1,9
       DO 500 IY=1,9
       DO 500 IZ=1,9
       ALPHA=FLOAT(IX)/10.
       BETA=FLOAT(IY)/10.
       GAMMA=FLOAT(IZ)/10.
       S0=STEMP
       R=RTEMP
       DO 352 J=1,L
352    F(J)=FTEMP(J)
       E=0.
       CALL SMOOTH(A,N1,ALPHA,BETA,GAMMA,F,IH,L,S0,R,ICOUNT,E)
       IF(E.GT.EMIN) GO TO 500
       EMIN=E
       ALPMIN=ALPHA
       BETMIN=BETA
       GAMMIN=GAMMA
500    CONTINUE
       ITEM=NOOFRO-IH-1
       TEMP=EMIN/FLOAT(ITEM)
       EMIN=SQRT(TEMP)
       SEFORC=EMIN
173       TYPE 170 
       READ(-1,171)INPUT
       IF(INPUT.EQ.1HY) ICOUNT=1
       IF(INPUT.NE.1HN.AND.ICOUNT.EQ.0) GO TO 173
       E=0.
       ALPHA=ALPMIN
       BETA=BETMIN
       GAMMA=GAMMIN
       S0=STEMP
       R=RTEMP
174    WRITE(-2,172)
       READ(-1,171)INPUT
       IOPT=0
       IF(INPUT.EQ.1HY)IOPT=1
       IF(INPUT.NE.1HN.AND.IOPT.EQ.0) GO TO 174
       DO 625 J=1,L
625    F(J)=FTEMP(J)
       E=0.
       CALL SMOOTH(A,N1,ALPHA,BETA,GAMMA,F,IH,L,S0,R,ICOUNT,E)
       IF(IOPT.EQ.0) GO TO 627
       WRITE(-2,655)S0,R,ALPHA,BETA,GAMMA
       WRITE(-2,659)
       DO 656 I=1,L
656    WRITE(-2,657)I,F(I)
627    IF(N2.EQ.0) GO TO 629
       A(N2,1)=S0
       A(N2,2)=R
       A(N2,3)=ALPHA
       A(N2,4)=BETA
       A(N2,5)=GAMMA
       DO 628 I=1,L
628    A(N2,5+I)=F(I)
629       IQUOT=NOOFRO/L
       INDEX=NOOFRO-IQUOT*L
       IF(NF.EQ.0) RETURN
       IF(N3.EQ.0)WRITE(-2,630)
630    FORMAT(/$    FORECASTS$/$    ---------$/)
948    DO 770 IT=1,NF
       ITEMP=INDEX+IT
   IF(ITEMP.GT.L) GO TO 755
       FORC=(S0+R*IT)*F(ITEMP)
       GO TO 769
755    ITEMP=ITEMP-L
       FORC=(S0+R*IT)*F(ITEMP)
769       IF(N3.EQ.0)WRITE(-2,760)IT,FORC  ;GO TO 770
          A(N3,IT)=FORC
770    CONTINUE
       WRITE(-2,631)SEFORC
631    FORMAT(/$STANDARD ERROR OF FORECAST IS $G13.4/)
655    FORMAT(/$ S0 = $,G13.4,
     +/$ R= $,G13.4,
     +/$ A= $,G13.4,
     +/$ B= $,G13.4,
     +/$ C= $,G13.4/)
659    FORMAT(/$SEASONAL FACTORS$/)
657    FORMAT($F($,I3,$ ) = $,G13.4)
760    FORMAT(/(1X,I3,8X,G13.4))
       STATE=1
       IF(N2.NE.0.OR.N3.NE.0) INP OK=.FALSE.
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
XPOS SYMSORT

SYM.  PG.LN. IDENT.

100     1 11         150     1 12         160     1 13         165     1 14         
170     1 16         171     1 17         172     1 18         173     3 18         
174     3 28         210     1 22         220     1 23         225     1 27         
228     1 29         230     1 31         240     1 37         250     1 38         
260     1 39         270     2  1         280     2  9         290     2 12         
300     2 15         310     2 16         320     2 21         330     2 26         
340     2 28         350     2 33         352     3  5         500     3 13         
625     3 34         627     4  3         628     4 10         629     4 11         
630     4 15         631     4 27         655     4 28         656     4  2         
657     4 34         659     4 33         755     4 21         760     4 35         
769     4 23         770     4 25         948     4 16         

STATFIN ** FICHE/FRAME BREAK *****
XPOSPM
       SUBROUTINE XPOSPM(A,IPAR,L,IC,V,NPAR,NFOR,NF,FLAG)
       GLOBAL NOOFCO,NOOFRO,STATE,INP OK
       LOGICAL FLAG,INP OK
       INTEGER STATE
       REAL A(NOOFCO,NOOFRO)
       DIMENSION F(30)
       S0=A(IPAR,1)
       R=A(IPAR,2)
       DO 200 I=1,L
200    F(I)=A(IPAR,5+I)
       IF(FLAG) GO TO 650
500    S0=A(IPAR,3)*V/A(IPAR,IC+5)+(1.-A(IPAR,3))*(A(IPAR,1)+A(IPAR,2))
       F(IC)=A(IPAR,4)*V/S0+(1.-A(IPAR,4))*A(IPAR,5+IC)
       R=A(IPAR,5)*(S0-A(IPAR,1))+(1.-A(IPAR,5))*A(IPAR,2)
600    IF(NPAR.EQ.0) GO TO 640
       A(NPAR,1)=S0
       A(NPAR,2)=R
       DO 610 I=3,5
610    A(NPAR,I)=A(IPAR,I)
       DO 620 I=1,L
620    A(NPAR,I+5)=F(I)
640    WRITE(-2,601)
601    FORMAT(/$PRINT UPDATED PARAMETERS ?$Z)
       READ (-1,602)INPUT
602    FORMAT(A1)
       IF(INPUT.EQ.1HN) GO TO 650
       IF(INPUT.NE.1HY) GO TO 640
       WRITE(-2,603)S0,R,A(NPAR,3),A(NPAR,4),A(NPAR,5)
       WRITE(-2,604)
       DO 605 I=1,L
605    WRITE(-2,606)I,F(I)
650    IF(NF.EQ.0) STATE=1;RETURN
       ITEMP=IC
       IF(FLAG)ITEMP=ITEMP-1
       IF(NFOR.EQ.0) WRITE(-2,789)
       DO 770 IT=1,NF
       ITEMP=ITEMP+1
       IF(ITEMP.GT.L) GO TO 755
       FORC=(S0+R*IT)*F(ITEMP)
       GO TO 769
755    ITEMP=ITEMP-L
       FORC=(S0+R*IT)*F(ITEMP)
769       IF(NFOR.EQ.0)WRITE(-2,760)IT,FORC;GO TO 770
       A(NFOR,IT)=FORC
770    CONTINUE
760    FORMAT(/(1X,I3,8X,G13.4))
603    FORMAT(/$ S0 = $,G13.4,
     +/$ R = $,G13.4,
     +/$ A = $,G13.4,
     +/$ B = $,G13.4,
     +/$ C = $,G13.4/)
604    FORMAT(/$SEASONAL FACTORS$/)
789    FORMAT(/$     FORECASTS$/$     ---------$/)
606    FORMAT($F($,I3,$ ) = $,G13.4)
       STATE=1
       IF(NPAR.NE.0.OR.NFOR.NE.0)INP OK=.FALSE.
       RETURN
       END
STATFIN ** FICHE/FRAME BREAK *****
XPOSPM SYMSORT

SYM.  PG.LN. IDENT.

200     1 10         500     1 12         600     1 15         601     1 23         
602     1 25         603     2  8         604     2 13         605     1 31         
606     2 15         610     1 19         620     1 21         640     1 22         
650     1 32         755     2  2         760     2  7         769     2  4         
770     2  6         789     2 14         
STATFIN ** FICHE/FRAME BREAK *****
ZADCF
ZADCF  IDENT   03/03/72
*
*
       BEGPR
       NOLIST  EXT,STAT
*
$ZADCF HEADER  SETP1,(FUN,INTG,0)
       LDX     FUN
       BRM*    0,2
       ZRO     0
       RETURN  ZADCF
*
       ENDPRG
       END
STATFIN ** FICHE/FRAME BREAK *****
ZADCF SYMSORT

SYM.  PG.LN. IDENT.

ZADCF   1  7 ZADCF   
STATFIN ** FICHE/FRAME BREAK *****
X
XPOSB
SMOOTHB
XPOSPMB
   q"