MICAP ** FICHE/FRAME BREAK *****
MICWORK
C        M I C R O W A V E     S O L U T I O N     O V E R L A Y
C
C     OCTOBER 15, 1969
C
C     IMPLEMENTED BY DON PETERS
C
C     DIMENSIONS FOR ARRAYS STORED IN NO-SWAP COMMON
      DIMENSION LINK(200,5),PAR(200)
      DIMENSION NI(19),NL(2,19),NC(101),NE(2,19),JK(7)
      DIMENSION FR(20),IDPLCH(10),KOUT(0/10),KFORMS(10,5)
      DIMENSION MERG1(16),MERG2(16),MERG3(16),JIST(3)
      DIMENSION IDUMNO(81),IBUFF(165)
C
C     ARRAYS NEEDED ONLY IN THIS OVERLAY
      DIMENSION STOREJ(15,2,2,2),AM(2,2,2),BM(2,2,2),PROD(2,2,2),ANS(2,2,2)
      DIMENSION END(2,2,2),B(20),LC(5,44),KSTAT(200),KFORMAT(7)
      DIMENSION NOUT(8),TITLE(37),KA(2),KB(2),PUD(6)
C
C
      COMMON LINK,PAR
      COMMON NI,NL,NC,NE,JK
      COMMON FR,LIMITS,FROM,TO,AMB,BW,LINLOG,NSTEPS,BY,REFREQ
      COMMON IDPLCH,KOUT,LOADBL,KSOURCE,KFORMS,IOSTOR,NOHED,IOSTOP
      COMMON KFROUT,MPLOT,NPLCH,INCPAR,INCREM,FRINC,BYINC,TOINC
      COMMON IMERGE,KSERPAR,MERG1,MERG2,MERG3,ITAKE,IDIOT,JIST,NPAR
      COMMON IDUMNO,IBUFF
      COMMON LI,RL,XL,GL,BL,RG,XG,LC,B,PUD,KSTAT
C
C
C      DEFINE AN OPEN CIRCUIT END BLOCK
      END(1,1,1)=1
      END(1,2,2)=1
C
C    INITIALIZATIONS
      ICONTRLF=102*256*256
      KFORMAT(1)=1H(
      KFORMAT(7)=1H)
      KA(1)=3HAMP
      KA(2)=3HPHA
      KB(1)=2HRE
      KB(2)=2HIM
C
      CALL LDDONE
      IF(INIT) 55,1,1
C
C     READ IN THE LC ARRAY
C
C    READ IN MICFORMLIB
1     INIT=-1
      OPEN(4,INPUT,SYMBOLIC,(@6LM)MICFLIB)
      DO 10 J=1,44
10    READ 4,20,(LC(I,J), I=1,5)
20    FORMAT(5F/)
      READ 4,30,(NOUT(I), I=1,7)
30    FORMAT(7I/)
      DO 40 I=1,37
40    READ 4,50, TITLE(I)
50    FORMAT(A5/)
      CLOSE(4)
C
C
      CALL TERMOV
55    CALL DCLESC(ESC)
      ASSIGN 2050 TO ESC
      CALL ARM
      CALL SETESC
C
      CALL ESCOFF
C    STORE ACTIVE/INACTIVE STATUS OF BLOCKS
      DO 80 J=1,200
      IF(LINK(J,1)) 60,60,70
60    KSTAT(J)=1
      GO TO 80
70    KSTAT(J)=-1
80    CONTINUE
      CALL ESCON
C
      TYPE 570
      IF(IOSTOP) 100,100,90
90    PAUSE 1
C
100   KABORT=0
C    CHECK TO SEE THAT A SOURCE HAS BEEN DEFINED
      IF(KSOURCE) 110,110,105
C    CHECK IF SOURCE IS IN ACTIVE STRING
105   IF(LINK(KSOURCE,1)) 106,106,130
106   TYPE 108
108   FORMAT($ SOURCE BLOCK IS NOT IN ACTIVE NETWORK$/)
      GO TO 125
110   TYPE 120
120   FORMAT($ DEFINE A SOURCE BLOCK$/)
125   KABORT=1
C
C    CHECK TO SEE THAT A LOAD HAS BEEN DEFINED
130   IF(LOADBL) 140,140,134
C    CHECK IF LOAD IS IN ACTIVE STRING
134   IF(LINK(LOADBL,1)) 136,136,160
136   TYPE 138
138   FORMAT($ LOAD BLOCK IS NOT IN ACTIVE NETWORK$/)
      GO TO 155
140   TYPE 150
150   FORMAT($ DEFINE A LOAD BLOCK$/)
155   KABORT=1
C
C    CHECK TO SEE THAT AT LEAST ONE OUTPUT HAS BEEN SPECIFIED
160   IF(KOUT(0)) 170,170,190
170   TYPE 180
180   FORMAT($ SPECIFY AT LEAST ONE OUTPUT$/)
      KABORT=1
C
C    HAS A REFERENCE FREQUENCY BEEN SPECIFIED?
190   IF(REFREQ) 200,200,250
C    NO - BUT DO WE NEED ONE (ONLY TYPES 11,12, AND 17 DO)
200   DO 240 J=1,200
      IF(LINK(J,1)) 240,240,210
210   K=NI(LINK(J,1))
      IF((K-11)*(K-12)*(K-17)) 240,220,240
220   TYPE 230
230   FORMAT($ SPECIFY A REFERENCE FREQUENCY$/)
      KABORT=1
      GO TO 250
240   CONTINUE
C
C    CHECK FOR A FREQUENCY SPEC
250   IF(LINLOG) 260,290,290
260   IF(FR(1)) 270,270,290
270   TYPE 280
      JIST(2)=JIST(2)+1
280   FORMAT($ SPECIFY FREQUENCY TEST DATA$/)
      KABORT=1
290   IF(FROM) 291,291,293
291   TYPE 292
292   FORMAT($ SPECIFY A "FROM" FREQUENCY$/)
      KABORT=1
293   IF(TO) 294,294,299
294   TYPE 295
295   FORMAT($ SPECIFY A "TO" FREQUENCY$/)
      KABORT=1
299   IF(KABORT) 310,310,300
300   CALL TERMOV
C
C    CHECK IF DOING A LIST OF ANSWERS OR A PLOT
310   IF(MPLOT) 330,330,320
C    DOING A PLOT - OPEN A SCRATCH FILE AS UNIT NO. 3
320   OPEN(3,OUTPUT,/*SCRATCH*/)
C    NOW SKIP HEADINGS AND GO TO COMPUTATIONS
      GO TO 630
C
330   IF(INCREM) 350,350,340
C    DOING PARAMETER INCREMENTATION - STORE ORIGINAL VALUE AND
C    REPLACE IT WITH "FROM" VALUE
340   PARSAV=PAR(INCPAR)
      PAR(INCPAR)=FRINC
C
C    HEADING PRINTING
350   CONTINUE
      NFIELD=0
      IF(NOHED) 360,360,630
360   IF(KSERPAR) 370,370,630
370   DO 620 IO=1,2
      IF(IO-IOSTOR) 380,620,380
380   WRITE IO,390
390   FORMAT($ FREQUENCY $,2X)
C
      DO 550 LTIT=1,KOUT(0)
C
C    DECODE THE OUTPUT SPECIFICATION
      CALL UNCODE(KOUT(LTIT),IVAR,IMRE,JRECPOL,JFORM)
      GO TO (400,430,510,430) IMRE+1
400   IF(N12(IVAR,NOUT)) 410,410,430
C
C    WRITE 1 REAL OUTPUT
410   WRITE IO,420,TITLE(IVAR)
420   FORMAT(2X,A5,6X)
      NFIELD=NFIELD+1
      GO TO 550
C
C    WRITE A COMPLEX OUTPUT
430   WRITE IO,440,TITLE(IVAR)
440   FORMAT(A5,1X)
      NFIELD=NFIELD+1
      IF(JRECPOL-1) 450,450,470
C
C    AMPLITUDE
450   WRITE IO,460,KA(1)
460   FORMAT(A3,4X)
      GO TO 490
C
C    REAL
470   WRITE IO,480,KB(1)
480   FORMAT(A2,5X)
C
490   IF(IMRE) 510,510,500
500   IF(IMRE-3) 550,510,550
C
510   WRITE IO,440,TITLE(IVAR)
      NFIELD=NFIELD+1
520   IF(JRECPOL-1) 530,530,540
C
C    PHASE
530   WRITE IO,460,KA(2)
      GO TO 550
C
C    IMAGINARY
540   WRITE IO,480,KB(2)
550   CONTINUE
C
560   WRITE IO,570
570   FORMAT(/)
C
C    TYPE OUT UNDERLINES
580   WRITE IO,590
590   FORMAT(11($-$))
      DO 600 LTIT=1,NFIELD
600   WRITE IO,610
610   FORMAT(2X,11($-$))
      WRITE IO,570
C
620   CONTINUE
C
C
630   CONTINUE
C
C    ENTRY POINT FOR INCREMENTAL PARAMETER VARIATION
640   NLINES=0
C    TURN OFF ESCAPE
      CALL ESCOFF
C
C
650   CONTINUE
C
C    CHECK IF DOING INCREMENTAL PARAMETER VARIATION
      IF(INCREM) 700,700,660
660   DO 690 IO=1,2
      IF(IO-IOSTOR) 670,690,670
670   WRITE IO,680,PAR(INCPAR)
680   FORMAT(/$PARAMETER VALUE =$,1PE11.4/)
690   CONTINUE
C
C
C
C               F R E Q U E N C Y        S P E C I F I C A T I O N
C
C    INITIAL ENTRY POINT
C
700   CONTINUE
      IF(LIMITS) 720,720,710
710   FROM=AMB*(1-BW/2)
      TO=AMB*(1+BW/2)
720   IF(LINLOG) 730,740,760
C
C    DISCRETE LIST OF FREQUENCIES
730   IFREQ=1
      GO TO 800
C
C    LINEAR SWEEP
740   IF(IFF(BY,0.,6)) 770,750,770
750   FINCR=(TO-FROM)/NSTEPS
      GO TO 770
760   FRATIO=EXP(ALOG(TO/FROM)/NSTEPS)
770   FREQ=FROM
      GO TO 850
C
C    FREQUENCY INCRIMENTATION SECTION
C
C    DETERMINE TYPE OF FREQUENCY SWEEP DESIRED
C
780   IF(LINLOG) 790,810,840
C
C    DISCRETE LIST
790   IFREQ=IFREQ+1
800   FREQ=FR(IFREQ)
      IF(FREQ) 1960,1960,880
C
C    LINEAR SWEEP
810   IF(IFF(BY,0.,6)) 830,820,830
820   FREQ=FREQ+FINCR
      GO TO 850
C
C    USER SUPPLIED INCRIMENTAL STEP FREQUENCY
830   FREQ=FREQ+BY
      GO TO 850
C
C    LOGARITHMETIC SWEEP
840   FREQ=FREQ*FRATIO
C
C    TEST WHETHER THE "TO" FREQUENCY HAS BEEN EXCEEDED
850   IF(IFF(TO,FROM,8)) 870,1960,860
860   IF(IFF(FREQ,TO,8)) 880,880,1960
870   IF(IFF(FREQ,TO,8)) 1960,880,880
C
C
880   CONTINUE
C
C    SET ALL JUNCTION INDICES TO ZERO
      DO 910 I=1,200
      IF(LINK(I,1)) 890,910,890
890   IF(JUNCT(I)) 910,910,900
900   LINK(I,5)=0
910   CONTINUE
C
920   JPT=1
C
C    SCAN THRU ALL BLOCKS TO FIND A BRANCH END - IGNORING INACTIVE BLOCK STRINGS
930   IWORK=0
      ISCAN=1
940   IF(LINK(ISCAN,1)) 950,950,970
950   ISCAN=ISCAN+1
      IF(ISCAN-200) 940,940,960
960   IF(IWORK) 1230,1230,930
C
C    IS BLOCK A JUNCTION BLOCK
970   IF(JUNCT(ISCAN)) 980,980,950
C    IS BLOCK A BRANCH END BLOCK
980   IF(LINK(ISCAN,2)*LINK(ISCAN,3)) 950,990,950
C
C    A NON-JUNCTION, ACTIVE, END BLOCK HAS BEEN FOUND
C    COMPUTE MATRIX OF END BLOCK
990   IWORK=1
      CALL MATGET(PROD,ISCAN,FREQ)
      LINK(ISCAN,1)=-LINK(ISCAN,1)
      IF(ISCAN-LOADBL) 1000,1200,1000
C    FIND NEXT BLOCK
1000  NOW=NEXTBL(0,ISCAN)
1010  LAST=ISCAN
C    TEST THE NOW BLOCK FOR A JUNCTION
1020  IF(JUNCT(NOW)) 1040,1040,1030
1030  NEXT=NOW
      GO TO 1080
C
1040  CALL MATGET(AM,NOW,FREQ)
      CALL ABMOVE(BM,PROD)
      CALL MTRXMY(AM,BM,PROD)
      LINK(NOW,1)=-LINK(NOW,1)
      IF(NOW-LOADBL) 1050,1210,1050
1050  NEXT=NEXTBL(LAST,NOW)
1060  IF(JUNCT(NEXT)) 1070,1070,1080
1070  LAST=NOW
      NOW=NEXT
      GO TO 1040
C
C    "NEXT" BLOCK IS A JUNCTION - IS IT A TWO LINKAGE JUNCTION?
1080  IF(LINK(NEXT,2)*LINK(NEXT,3)*LINK(NEXT,4)) 1090,1120,1090
C
C    NORMAL JUNCTION - DOES IT HAVE A STORED VALUE?
1090  IF(LINK(NEXT,5)) 1100,1100,1190
1100  DO 1110 M1=1,2
      DO 1110 M2=1,2
      DO 1110 M3=1,2
1110  STOREJ(JPT,M1,M2,M3)=PROD(M1,M2,M3)
      LINK(NEXT,5)=JPT
      JPT=JPT+1
      GO TO 950
C
C    ONLY TWO LINKAGES TO THIS JUNCTION
1120  IF(LINK(NEXT,1)-20) 1150,1130,1150
1130  TYPE 1140,NEXT
1140  FORMAT($ ERROR--> JUNCTION BLOCK $,I,$IS A SERIES TYPE$/)
      TYPE 570
      GO TO 2030
C
1150  CONTINUE
C
C    FIND AN UNPROCESSED BLOCK LEADING AWAY FROM THE JUNCTION
1160  LINK(NEXT,1)=-LINK(NEXT,1)
      DO 1170 LB=2,4
      MB=LINK(NEXT,LB)
      IF(LINK(MB,1)) 1170,1170,1180
1170  CONTINUE
      PAUSE 4
C
C    BLOCK MB IS THE ONE
1180  NOW=NEXT
      NEXT=MB
      GO TO 1060
C
C    BLOCK "NEXT" IS A NORMAL JUNCTION BLOCK WITH A STORED VALUE
1190  CALL JUNGET(AM,STOREJ,LINK(NEXT,5))
C
C    JUNCTION STORED INFORMATION IS NOW STORED IN THE "AM" MATRIX
C    COMPUTE ITS INPUT (R+JX) IMPEDANCE
      LI=2
      GL=0
      BL=0
      CALL OUTPUT(AM,1,PUTR,PUTI)
C    I1=13 FOR A SERIES IMPEDANCE, 14 FOR A PARALLEL IMPEDANCE
      I1=LINK(NEXT,1)-7
      CALL DECODE(JK,NE,I1)
      B(1)=PUTR
      B(11)=PUTI
      CALL LIBRARY(AM,B,I1,JIST)
C    DESIRED MATRIX IS NOW STORED IN "AM"
C    MOVE THE "PROD" MATRIX INTO THE "BM" MATRIX
      CALL ABMOVE(BM,PROD)
      CALL MTRXMY(AM,BM,PROD)
      GO TO 1160
C
C
1200  LOADP=NEXTBL(0,ISCAN)
      GO TO 1220
1210  LOADP=NEXTBL(LAST,NOW)
1220  LI=2
      GL=0
      BL=0
      CALL OUTPUT(PROD,1,PUTR,PUTI)
      RL=PUTR
      XL=PUTI
      GO TO 950
C
C     FINAL STRING SECTION
1230  CONTINUE
C
C
C    FOLLOWING SECTION STARTS ITS SCAN FROM THE LOAD BLOCK AND WORKS
C    TOWARD THE SOURCE BLOCK, GETTING AND MULTIPLYING SUCCESSIVE
C    "A" MATRICIES ALONG THE WAY - UPON ENCOUNTERING THE GENERATOR,
C    CONTROL IS TRANSFERRED TO SECTION WHICH COMPUTES EQUIVALENT
C    SOURCE RESISTANCE AND REACTANCE
C
1240  NOW=LOADBL
      NEXT=LOADP
      CALL ABMOVE(PROD,END)
      IWHERE=1
      IF(NEXT-KSOURCE) 1310,1250,1310
1250  TYPE 1260
1260  FORMAT($ SOURCE AND LOAD MUST HAVE AT LEAST ONE INTERVENING BLOCK$/)
      GO TO 2030
C
C
C    BRANCH, DEPENDING UPON IF WE ARE IN OUTPUT STRING OR SOURCE STRING
1270  GO TO (1280,1300) IWHERE
1280  IF(NEXT-KSOURCE) 1310,1290,1310
1290  CALL ABMOVE(ANS,PROD)
C    NOW PUT UNIT MATRIX INTO PROD AND CONTINUE WORKING TOWARD SOURCE
      CALL ABMOVE(PROD,END)
      IWHERE=2
      GO TO 1310
1300  IF(NEXT+1) 1310,1370,1310
1310  IF(JUNCT(NEXT)) 1320,1320,1340
C
C    PROCESS A NORMAL BLOCK
1320  CALL ABMOVE(BM,PROD)
      CALL MATGET(AM,NEXT,FREQ)
      CALL MTRXMY(AM,BM,PROD)
1325  LINK(NEXT,1)=-LINK(NEXT,1)
1330  LAST=NOW
      NOW=NEXT
      NEXT=NEXTBL(LAST,NOW)
      GO TO 1270
C
C    PROCESS A JUNCTION
C     CHECK IF A TWO LINKAGE JUNCTION - SKIP IT IF IT IS TYPE PJ
C     TYPE ERROR MESSAGE IF IT IS TYPE SJ
1340   IF(LINK(NEXT,2)*LINK(NEXT,3)*LINK(NEXT,4)) 1345,1342,1345
1342   IF(LINK(NEXT,1)-20) 1325,1130,1325
1345  CALL JUNGET(AM,STOREJ,LINK(NEXT,5))
      LI=2
      GL=0
      BL=0
      CALL OUTPUT(AM,1,PUTR,PUTI)
      I1=LINK(NEXT,1)-7
      CALL DECODE(JK,NE,I1)
      B(1)=PUTR
      B(11)=PUTI
      CALL LIBRARY(AM,B,I1,JIST)
      CALL ABMOVE(BM,PROD)
      CALL MTRXMY(AM,BM,PROD)
      LINK(NEXT,1)=-LINK(NEXT,1)
C    FIND AN UNPROCESSED BLOCK LEADING AWAY FROM JUNCTION
      DO 1350 LB=2,4
      MB=LINK(NEXT,LB)
      IF(LINK(MB,1)) 1350,1350,1360
1350  CONTINUE
      PAUSE 3
1360  NOW=NEXT
      NEXT=MB
      GO TO 1270
C
C
C    COMPUTE EQUIVALENT SOURCE RESISTANCE & REACTANCE
1370  CONTINUE
      RG=0
      XG=0
      LI=1
      CALL OUTPUT(PROD,3,PUTR,PUTI)
      RG=PUTR
      XG=PUTI
      GO TO 1380
C
C    ARE ANSWERS TO BE LISTED OR PLOTTED?
1380  IF(MPLOT) 1390,1390,1810
C
C    ANSWER PRINTOUT SECTION
C
1390  DO 1800 IO=1,2
      IF(IO-IOSTOR) 1400,1800,1400
1400  DO 1410 J=1,5
1410  KFORMAT(J+1)=KFORMS(KFROUT,J)
      IF(KSERPAR) 1440,1440,1420
1420  WRITE IO,1430
1430  FORMAT($FREQUENCY =$)
1440  WRITE IO,KFORMAT,FREQ
      TYPE 1450,ICONTRLF
1450  FORMAT(A1)
      IF(KSERPAR) 1470,1470,1460
1460  WRITE IO,570
      WRITE IO,570
C
C
1470  DO 1780 INDEX=1,KOUT(0)
C
C    DECODE THE KOUT(INDEX) WORD INTO REQUIRED OUTPUT INFORMATION
      CALL UNCODE(KOUT(INDEX),IVAR,IMRE,JRECPOL,JFORM)
C    HAS A FORMAT BEEN SPECIFIED?
      IF(JFORM) 1480,1480,1510
C
C    NO, SO DETERMINE WHETHER OR NOT A SINGLE FORMAT SHOULD BE USED
C    FUNCTION N12 DECIDES WHETHER OUTPUT ITEM IVAR IS
C    COMPLEX (N12=1) OR REAL (N12=0)
1480  IF(N12(IVAR,NOUT)) 1490,1490,1500
1490  JFORM=1
      GO TO 1510
1500  JFORM=1+JRECPOL
C
C    DONE - NOW PUT THE ARRAY OF FORMATS INTO A SINGLE ARRAY
1510  DO 1520 J=1,5
1520  KFORMAT(J+1)=KFORMS(JFORM,J)
C
C    GET THE OUTPUT VALUES
      CALL OUTPUT(ANS,IVAR,PUTR,PUTI)
C
C    CONVERT TO POLAR FORM IF RECPOL FLAG IS SET AND OUTPUT IS COMPLEX
      IF(N12(IVAR,NOUT)) 1540,1540,1525
1525  IF(JRECPOL-1) 1540,1530,1540
1530  CALL RECPOL(PUTR,PUTI)
1540  IF(KSERPAR) 1550,1550,1570
1550  WRITE IO,1560
1560  FORMAT(2X)
      GO TO 1710
C
C    IDENTIFICATION OF COMPRESSED OUTPUT
1570  GO TO (1580,1590,1590,1640) IMRE+1
1580  IF(N12(IVAR,NOUT)) 1690,1690,1640
C    1 PART OF COMPLEX OUTPUT SPECIFIED
C
C
1590  IF(JRECPOL-1) 1600,1600,1620
C    POLAR FORM
1600  WRITE IO,1610,TITLE(IVAR),KA(IMRE)
1610  FORMAT(4X,A5,$($,A3,$) =$)
      GO TO 1710
C    RECTANGULAR FORM
1620  WRITE IO,1630,TITLE(IVAR),KB(IMRE)
1630  FORMAT(5X,A5,$($,A2,$) =$)
      GO TO 1710
C
C    FULL COMPLEX OUTPUT
1640  IF(JRECPOL-1) 1650,1650,1670
1650  WRITE IO,1660,TITLE(IVAR)
1660  FORMAT(A5,$(AMP PHA) =$)
      GO TO 1710
1670  WRITE IO,1680,TITLE(IVAR)
1680  FORMAT(2X,A5,$(RE IM) =$)
      GO TO 1710
C
C    NON-COMPLEX OUTPUT (REAL)
1690  WRITE IO,1700,TITLE(IVAR)
1700  FORMAT(9X,A5,$ =$)
C
1710  GO TO (1720,1730,1740,1750) IMRE+1
1720  IF(N12(IVAR,NOUT)) 1730,1730,1750
1730  WRITE IO,KFORMAT,PUTR
      GO TO 1760
1740  WRITE IO,KFORMAT,PUTI
      GO TO 1760
1750  WRITE IO,KFORMAT,PUTR,PUTI
C
1760  IF(KSERPAR) 1780,1780,1770
1770  WRITE IO,570
1780  CONTINUE
1790  WRITE IO,570
C
1800  CONTINUE
      GO TO 1940
C
C
C    FOLLOWING CODE IS FOR PLOTTING
1810  TYPE 1450,ICONTRLF
      NLINES=NLINES+1
      NCOLS=0
      WRITE 3,1820,FREQ
1820  FORMAT(1PE11.4,2X)
      DO 1930 INDEX=1,KOUT(0)
C    DECODE EACH OUTPUT DATA WORD INTO ITS COMPONENTS
      CALL UNCODE(KOUT(INDEX),IVAR,IMRE,JRECPOL,JFORM)
C    COUNT NUMBER OF OUTPUTS
C    GET OUTPUT VALUES
      CALL OUTPUT(ANS,IVAR,PUTR,PUTI)
C    CONVERT TO POLAR FORM IF RECPOL FLAG IS SET AND OUTPUT IS COMPLEX
      IF(N12(IVAR,NOUT)) 1840,1840,1825
1825  IF(JRECPOL-1) 1840,1830,1840
1830  CALL RECPOL(PUTR,PUTI)
1840  IF(IMRE) 1850,1850,1860
1850  IF(N12(IVAR,NOUT)) 1870,1870,1900
1860  IF(IMRE-2) 1870,1890,1900
1870  WRITE 3,1880,PUTR
      NCOLS=NCOLS+1
1880  FORMAT(1PE10.3,2X)
      GO TO 1920
1890  WRITE 3,1880,PUTI
      NCOLS=NCOLS+1
      GO TO 1920
1900  WRITE 3,1910,PUTR,PUTI
      NCOLS=NCOLS+2
1910  FORMAT(1PE10.3,2X,E10.3,2X)
1920  CONTINUE
1930  CONTINUE
C
      WRITE 3,570
C
C
C    WAIT FOR TELETYPE OUTPUT BUFFER TO EMPTY BEFORE PROCEEDING
1940  CALL BRS(14,0,0,-1)
C    NOW TEST FOR A PENDING ESCAPE
      CALL TPEND
      DO 1950 J=1,200
1950  LINK(J,1)=LINK(J,1)*KSTAT(J)
      GO TO 780
C
C    DONE WITH DATA COMPUTATION - RETURN IF NO PLOT BEING MADE
1960  IF(MPLOT) 1980,1980,1970
1970  MERG3(1)=NLINES
      MERG3(2)=NCOLS
C      NOW TO THE PLOT OVERLAY
      CALL CALLOV(4)
C
       IF(ITAKE) 1980,1980,2050
C    CHECK IF DOING INCREMENTAL PARAMETER VARIATION
1980  IF(INCREM) 2010,2010,1990
1990  PAR(INCPAR)=PAR(INCPAR)+BYINC
      IF(IFF(PAR(INCPAR),TOINC,8)) 640,640,2000
2000  PAR(INCPAR)=PARSAV
C
2010  IF(IOSTOP) 2030,2030,2020
2020  PAUSE 9
2030  DO 2040 J=1,200
2040  LINK(J,1)=-IABS(LINK(J,1))*KSTAT(J)
      CALL TERMOV
C
2050  CALL ARM;ITAKE=1
      CLOSE
C    TURN THE ESCAPE BACK ON
      CALL ESCON
C    CLEAR OUTPUT BUFFER
      CALL BRS(29,0,0,-1)
      TYPE 570
      IF(INCREM) 2030,2030,2000
      END
      SUBROUTINE ABMOVE(A,B)
      DIMENSION A(2,2,2),B(2,2,2)
      DO 5 I=1,2
      DO 5 J=1,2
      DO 5 K=1,2
5     A(I,J,K)=B(I,J,K)
      RETURN
      END
C
C
C
      SUBROUTINE JUNGET(A,B,INDX)
      DIMENSION A(2,2,2),B(15,2,2,2)
      DO 5 I=1,2
      DO 5 J=1,2
      DO 5 K=1,2
5     A(I,J,K)=B(INDX,I,J,K)
      RETURN
      END
C
C
C
      FUNCTION N12(IVAL,NOUT)
      DIMENSION NOUT(1)
      DO 10 J=1,8
      IF(IVAL-NOUT(J)) 10,20,10
10    CONTINUE
      N12=1
      RETURN
20    N12=0
      RETURN
      END
      SUBROUTINE UNCODE(IOUT,IVAR,IMRE,JRECPOL,JFORM)
C     THIS SUBROUTINE DIVIDES THE WORD IOUT INTO ITS COMPONENTS
C
      JRECPOL=IOUT/100
      JFORM=IOUT-JRECPOL*100
      IMRE=JRECPOL/10
      JRECPOL=JRECPOL-IMRE*10
      IVAR=IMRE/10
      IMRE=IMRE-IVAR*10
      RETURN
      END
C
C
      SUBROUTINE RECPOL(PUTR,PUTI)
C    THIS SUBROUTINE CONVERTS FROM RECTANGULAR TO POLAR FORM
C
      TEMP=SQRT(PUTR*PUTR+PUTI*PUTI)
      PUTI=ATAN(PUTI,PUTR)*57.29578
      IF(PUTI-180.0) 4150,4150,4145
4145  PUTI=PUTI-360.0
4150  PUTR=TEMP
      RETURN
      END
      SUBROUTINE MATGET(A,IB,FREQ)
C
C    THIS SUBROUTINE GETS THE "A" MATRIX FOR BLOCK "IB" AT FREQUENCY "FREQ"
C
C     DIMENSIONS FOR ARRAYS STORED IN NO-SWAP COMMON
       DIMENSION LINK(200,5),PAR(200)
       DIMENSION NI(19),NL(2,19),NC(101),NE(2,19),JK(7)
       DIMENSION FR(20),IDPLCH(10),KOUT(0/10),KFORMS(10,5)
      DIMENSION MERG1(16),MERG2(16),MERG3(16),JIST(3)
       DIMENSION IDUMNO(81),IBUFF(165)
C DIMENSIONS IN THIS SUBROUTINE
      DIMENSION A(2,2,2),B(20),LC(5,44),PUD(6),KSTAT(200)
C
C
       COMMON LINK,PAR
       COMMON NI,NL,NC,NE,JK
       COMMON FR,LIMITS,FROM,TO,AMB,BW,LINLOG,NSTEPS,BY,REFREQ
       COMMON IDPLCH,KOUT,LOADBL,KSOURCE,KFORMS,IOSTOR,NOHED,IOSTOP
       COMMON KFROUT,MPLOT,NPLCH,INCPAR,INCREM,FRINC,BYINC,TOINC
       COMMON IMERGE,KSERPAR,MERG1,MERG2,MERG3,ITAKE,IDIOT,JIST,NPAR
       COMMON IDUMNO,IBUFF
       COMMON LI,RL,XL,GL,BL,RG,XG,LC,B,PUD,KSTAT
C
C
      JTP1=IABS(LINK(IB,1))
      IF(JTP1) 20,20,50
50    IF(JUNCT(IB)) 70,70,20
20    TYPE 30,IB,JTP1
      JIST(3)=JIST(3)+100000
30    FORMAT($ TOPOLOGY ERROR, CHECK SOURCE AND LOAD DECLARATIONS$/
             $ ( MATGET $,2I,$)$/)
C    PRESERVE STATUS OF ACTIVE BLOCKS BEFORE RETURNING
      DO 35 IB=1,200
35    LINK(IB,1)=-IABS(LINK(IB,1))*KSTAT(IB)
      CALL TERMOV
40    RETURN
C
C    CHECK IF BLOCK IS A USER DEFINED BLOCK
70    IF((JTP1-21)*(28-JTP1)) 300,300,100
C
C    USER DEFINED SECTION
100   NOUD=JTP1-21
      DO 108 KK=1,LINK(IB,5)
      IF(INCPAR-(LINK(IB,4)+KK-1)) 105,106,105
105   PUD(KK)=PAR(LINK(IB,4)+KK-1)
      GO TO 108
106   PUD(KK)=PAR(INCPAR)
108   CONTINUE
C
      GO TO (110,120,130,140,150,160) NOUD
C
110   CALL UD1(A,FREQ,PUD)
      RETURN
C
120   CALL UD2(A,FREQ,PUD)
      RETURN
C
130   CALL UD3(A,FREQ,PUD)
      RETURN
C
140   CALL UD4(A,FREQ,PUD)
      RETURN
C
150   CALL UD5(A,FREQ,PUD)
      RETURN
C
160   CALL UD6(A,FREQ,PUD)
      RETURN
C
C
C
300   CONTINUE
      CALL DECODE(JK,NE,JTP1)
      IORDER=0
      DO 420 J=7,1,-1
      IF(JK(J)) 420,420,406
406   IF(JK(J)-6) 410,408,410
408   B(JK(J))=FREQ
      GO TO 420
410   IF(JK(J)-10) 414,412,414
412   B(JK(J))=REFREQ
      GO TO 420
414   B(JK(J))=PAR(LINK(IB,4)+IORDER)
      IORDER=IORDER+1
420   CONTINUE
C
      CALL LIBRARY(A,B,JTP1,JIST)
      RETURN
      END
      SUBROUTINE DECODE(JK,NE,ITYPE)
      DIMENSION JK(7),NE(2,19)
C
C    THIS SUBROUTINE DECODES THE 'NE' ARRAY INTO THE 'JK' ARRAY
C
1062  JK(3)=NE(2,ITYPE)/10000
      I1=NE(2,ITYPE)-JK(3)*10000
      JK(2)=I1/100
      JK(1)=I1-JK(2)*100
      JK(7)=NE(1,ITYPE)/1000000
      I1=NE(1,ITYPE)-JK(7)*1000000
      JK(6)=I1/10000
      I1=I1-JK(6)*10000
      JK(5)=I1/100
      JK(4)=I1-JK(5)*100
      RETURN
      END
C
C
C
C
      FUNCTION JUNCT(K)
C    THIS FUNCTION RETURNS A ZERO IF BLOCK IB IS NOT A JUNCTION
C    AND RETURNS +1 IF IT IS
C
      DIMENSION LINK(200,5)
      COMMON LINK
       L=IABS(LINK(K,1))
      IF((L-20)*(L-21)) 5,10,5
5     JUNCT=0
      RETURN
10    JUNCT=1
      RETURN
      END
      FUNCTION NEXTBL(IB,JB)
C    THIS FUNCTION RETURNS THE VALUE OF THE NEXT BLOCK
C    BLOCK JB MUST NOT BE A JUNCTION BLOCK
C    BLOCKS IB AND JB MUST BOTH BE NON-ZERO AND POSITIVE
      DIMENSION LINK(200,5)
      COMMON LINK
      IF(LINK(JB,2)-IB) 20,10,20
10    NEXTBL=LINK(JB,3)
      RETURN
20    IF(LINK(JB,3)-IB) 40,30,40
30    NEXTBL=LINK(JB,2)
      RETURN
40    TYPE 50,IB,JB
50    FORMAT($ERROR IN NEXTBL ARGUMENTS, $,I,$TO $,I/)
      RETURN
      END
       SUBROUTINE LIBRARY(A,B,I,JIST)
C
C    ARGUMENT I IS THE TYPE OF THE BLOCK
C    ARGUMENT B IS THE ARRAY OF BLOCK PARAMETER VALUES
C    ARGUMENT A IS THE COMPUTED BLOCK ABCD MATRIX
C
       DIMENSION A(2,2,2),JK(7),B(20),NEC(2),NL(2,19),NI(19)
       DIMENSION NE(2,19),NC(101),N(36)
      DIMENSION LINK(200,5),PAR(200),JIST(3)
C
       COMMON LINK,PAR
      COMMON NI,NL,NC,NE,JK
C
C              SECTION RETRIEVAL
C
      NP=I
      IF(I-20) 110,100,100
100    TYPE 105,I,(JK(K),K=1,7)
      JIST(3)=JIST(3)+10000
  105  FORMAT(/$LIBRARY ERROR, TYPE $,I/$ JK--> $,7I/)
      PAUSE 1
      DO 106 JJ=1,17
106   TYPE 107,JJ,NE(1,JJ),NE(2,JJ),NI(JJ)
107   FORMAT(I3,2I8,I4/)
       RETURN
  110  L=0
C
C         DECODING COMPUTATION CODE
C
       DO 200 K=NL(1,NP),NL(2,NP)
       L=L+1
       N(L)=NC(K)/10000
       I1=NC(K)-N(L)*10000
       L=L+1
       N(L)=I1/100
       L=L+1
  200  N(L)=I1-N(L-1)*100
C
C              MATRIX GENERATION
C
       DO 50 M=1,L
       GO TO(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
     X 20,21,22,23,24,25,26,27,28,29,30,31) N(M)
    1  JM=1; GO TO 50
    2  JM=2; GO TO 50
    3  JM=3; GO TO 50
    4  JM=4; GO TO 50
    5  V=Q+W; GO TO 50
    6  A(JM,1,1)=W; GO TO 50
    7  A(1,2,2)=A(1,1,1); GO TO 50
    8  A(1,1,1)=1.0; A(1,2,2)=1.0
       A(1,1,2)=0.0; A(1,2,1)=0.0
       A(2,1,1)=0.0; A(2,2,2)=0.0
       A(2,1,2)=0.0; A(2,2,1)=0.0; GO TO 50
    9  A(JM,1,2)=W; GO TO 50
   10  GO TO 300
   11  A(JM,2,1)=W; GO TO 50
   12  W=B(JK(JM)); GO TO 50
   13  ARG=B(5)*B(6)*B(7)/B(10); GO TO 50
   14  W=6.2831853*B(6); GO TO 50
   15  W=W*B(JK(JM)); GO TO 50
   16  W=-W; GO TO 50
   17  IF(W) 177,277,177
177    W=1./W ; GO TO 50
277    W=1E30 ; GO TO 50
   18  W=W*W; GO TO 50
   19  Q=W; GO TO 50
   20  DEN=Q+W; GO TO 50
   21  Q=1; GO TO 50
   22  EX=EXP(B(4)*B(7))
       EXI=1./EX
       COSH=(EX+EXI)/2.
       SINH=(EX-EXI)/2.
       A(1,1,1)=COSH*W
       S=SINH*W; T=COSH*U
       UR=S*B(1); UI=T*B(1)
       VR=T*B(11); VI=S*B(11)
      DEN=B(1)*B(1)+B(11)*B(11)
       A(1,1,2)=UR-VR
       A(1,2,1)=(UR-VR)/DEN
       A(2,1,1)=SINH*U
       A(2,2,2)=A(2,1,1)
       A(2,1,2)=UI+VI
       A(2,2,1)=(UI-VI)/DEN; GO TO 50
   23  W=COS(ARG); GO TO 50
   24  U=SIN(ARG); GO TO 50
   25  ARG=.01745327*B(8)*B(6)/B(10); GO TO 50
   26  U=W; GO TO 50
   27  W=W/DEN; GO TO 50
   28  W=W*U; GO TO 50
   29  W=U; GO TO 50
   30  W=V; GO TO 50
31    JM=5
   50  CONTINUE
C
C    TEST "A" MATRIX FOR EXTREME VALUES
300   DO 350 I=1,2
      DO 350 J=1,2
      DO 350 K=1,2
350   X=A(I,J,K)
      IF(X) 310,340,320
310   X=AMIN(X,-1E-30)
      X=AMAX(X,-1E30)
      RETURN
320   X=AMIN(X,1E30)
      X=AMAX(X,1E-30)
340   RETURN
      END
C
C
C      THE FOLLOWING SUBROUTINE COMPUTES THE PRODUCT OF
C      TWO 2 BY 2 COMPLEX MATRICES:  C = A * B .
C
C
       SUBROUTINE MTRXMY(A,B,C)
       DIMENSION A(2,2,2),B(2,2,2),C(2,2,2)
       C(1,1,1)=A(1,1,1)*B(1,1,1)+A(1,1,2)*B(1,2,1)
+              -A(2,1,1)*B(2,1,1)-A(2,1,2)*B(2,2,1)
       C(1,1,2)=A(1,1,1)*B(1,1,2)+A(1,1,2)*B(1,2,2)
+              -A(2,1,1)*B(2,1,2)-A(2,1,2)*B(2,2,2)
       C(1,2,1)=A(1,2,1)*B(1,1,1)+A(1,2,2)*B(1,2,1)
+              -A(2,2,1)*B(2,1,1)-A(2,2,2)*B(2,2,1)
       C(1,2,2)=A(1,2,1)*B(1,1,2)+A(1,2,2)*B(1,2,2)
+              -A(2,2,1)*B(2,1,2)-A(2,2,2)*B(2,2,2)
       C(2,1,1)=A(1,1,1)*B(2,1,1)+A(1,1,2)*B(2,2,1)
+              +A(2,1,1)*B(1,1,1)+A(2,1,2)*B(1,2,1)
       C(2,1,2)=A(1,1,1)*B(2,1,2)+A(1,1,2)*B(2,2,2)
+              +A(2,1,1)*B(1,1,2)+A(2,1,2)*B(1,2,2)
       C(2,2,1)=A(1,2,1)*B(2,1,1)+A(1,2,2)*B(2,2,1)
+              +A(2,2,1)*B(1,1,1)+A(2,2,2)*B(1,2,1)
       C(2,2,2)=A(1,2,1)*B(2,1,2)+A(1,2,2)*B(2,2,2)
+              +A(2,2,1)*B(1,1,2)+A(2,2,2)*B(1,2,2)
       RETURN
       END
       SUBROUTINE OUTPUT(A,LT,PUTR,PUTI)
C
C      LI=1 IF LOAD IS GIVEN AS IMPEDANCE
C      LI=2 IF LOAD IS GIVEN AS ADMITTANCE
C     A IS THE ABCD MATRIX IN CONSIDERATION
C     LT IS THE TYPE OF OUTPUT QUANTITY DESIRED
C     PUTR IS THE REAL PART OF THE OUTPUT
C     PUTI IS THE IMAGINARY PART OF THE OUTPUT
C     LC IS THE ARRAY FOR OUTPUT SEQUENCE COMPUTATION
C     RL IS THE LOAD RESISTANCE
C     XL IS THE LOAD REACTANCE
C     GL IS THE LOAD CONDUCTANCE
C     BL IS THE LOAD SUSCEPTANCE
C     RG IS THE GENERATOR RESISTANCE
C     XG IS THE GENERATOR REACTANCE
C
C
C     DIMENSIONS FOR ARRAYS STORED IN NO-SWAP COMMON
       DIMENSION LINK(200,5),PAR(200)
       DIMENSION NI(19),NL(2,19),NC(101),NE(2,19),JK(7)
       DIMENSION FR(20),IDPLCH(10),KOUT(0/10),KFORMS(10,5)
      DIMENSION MERG1(16),MERG2(16),MERG3(16),JIST(3)
       DIMENSION IDUMNO(81),IBUFF(165)
C
C     DIMENSIONS FOR ARRAYS NEEDED IN THIS SUBROUTINE
       DIMENSION A(2,2,2),B(20),NEC(2),N(12),LC(5,44),PUD(6)
C
C    ARRAYS NEEDED ONLY IN THIS ROUTINE
       COMMON LINK,PAR
       COMMON NI,NL,NC,NE,JK
       COMMON FR,LIMITS,FROM,TO,AMB,BW,LINLOG,NSTEPS,BY,REFREQ
       COMMON IDPLCH,KOUT,LOADBL,KSOURCE,KFORMS,IOSTOR,NOHED,IOSTOP
       COMMON KFROUT,MPLOT,NPLCH,INCPAR,INCREM,FRINC,BYINC,TOINC
      COMMON IMERGE,KSERPAR,MERG1,MERG2,MERG3,ITAKE,IDIOT,JIST,NPAR
       COMMON IDUMNO,IBUFF
       COMMON LI,RL,XL,GL,BL,RG,XG,LC,B,PUD
C
C
      ALOG10(X)=ALOG(X)/ALOG(10)
C
C    HAS A USER DEFINED SUBROUTINE BEEN CALLED
      IF(LT-32) 500,510,510
C    YES
C    LOAD RESISTANCE IS PARAMETER 1 (PUD(1))
C    LOAD REACTANCE IS PARAMETER 2 (PUD(2))
C    GENERATOR RESISTANCE IS PARAMETER 3 (PUD(3))
C    GENERATOR REACTANCE IS PARAMETER 4 (PUD(4))
C    RESULTANT REAL OUTPUT (PUTR) IS PARAMETER 5 (PUD(5))
C    RESULTANT IMAGINARY OUTPUT (PUTI) IS PARAMETER 6 (PUD(6))
C
510   PUD(1)=RL
      PUD(2)=XL
      PUD(3)=RG
      PUD(4)=XG
C
      GO TO (520,530,540,550,560,570) LT-31
520   CALL UD1(A,FREQ,PUD)
      GO TO 580
530   CALL UD2(A,FREQ,PUD)
      GO TO 580
540   CALL UD3(A,FREQ,PUD)
      GO TO 580
550   CALL UD4(A,FREQ,PUD)
      GO TO 580
560   CALL UD5(A,FREQ,PUD)
      GO TO 580
570   CALL UD6(A,FREQ,PUD)
C
580   PUTR=PUD(5)
      PUTI=PUD(6)
      RETURN
C
C
500    AR=A(1,1,1); AI=A(2,1,1)
       BR=A(1,1,2); BI=A(2,1,2)
       CR=A(1,2,1); CI=A(2,2,1)
       DR=A(1,2,2); DI=A(2,2,2)
C
C              FORMULA RETRIEVAL
C
       LEC=100*LI+LT
       DO 100 NP=1,44
       IF(NP-30)80,80,85
   80  IF(LEC-LC(1,NP)) 100,110,100
   85  IF(LT-LC(1,NP)) 100,110,100
  100  CONTINUE
       TYPE 105,LI,LT
      JIST(3)=JIST(3)+10000
  105  FORMAT($OUTPUT ERROR, LI= $I,$LT= $I/)
      IF(LI-1) 109,106,106
106   IF(LI-2) 107,107,109
107   IF(LT-31) 108,108,109
108   DO 111 NP=1,44
111   TYPE 112,LC(1,NP)
112   FORMAT(I)
109    RETURN
  110  L=0
C
C          DECODING COMPUTATION CODE
C
       DO 200 K=2,5
       L=L+1
       N(L)=LC(K,NP)/10000
       I1=LC(K,NP)-N(L)*10000
       L=L+1
       N(L)=I1/100
       L=L+1
  200  N(L)=I1-N(L-1)*100
C
C          COMPUTATION OF OUTPUT
C
       DO 70 M=1,12
       GO TO(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
+            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,
+            36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
+            52,53,54,55) N(M)
    1  U=AR*RL-AI*XL+BR; V=AR*XL+AI*RL+BI
   45  S=CR*RL-CI*XL+DR; T=CR*XL+CI*RL+DI
       GO TO 70
    2  U=AR+BR*GL-BI*BL; V=AI+BR*BL+BI*GL
   46  S=CR+DR*GL-DI*BL; T=CI+DR*BL+DI*GL
       GO TO 70
    3  U=DR*RG-DI*XG+BR; V=DR*XG+DI*RG+BI
   47  S=CR*RG-CI*XG+AR; T=CR*XG+CI*RG+AI
       GO TO 70
    4  G=S*RL-T*XL+U; H=S*XL+T*RL+V
       P=RG+RL; Q=XG+XL
       GO TO 70
    5  G=U*GL-V*BL+S; H=U*BL+V*GL+T
       P=RG*GL-XG*BL+1.0; Q=XG*GL+RG*BL
       GO TO 70
    6  DEN=P*P+Q*Q
       R=(G*P+H*Q)/DEN; W=(P*H-G*Q)/DEN
       PUTR=10.*ALOG10(R*R+W*W)
       GO TO 70
    7  USVT=U*S+V*T; GO TO 70
    8  DEN=S*S+T*T; GO TO 70
    9  DEN=U*U+V*V
       PUTI=(U*T-V*S)/DEN
       GO TO 70
   10  RETURN
   11  DEN=GL; GO TO 70
   12  DEN=RL; GO TO 70
   13  PUTR=USVT/DEN; GO TO 70
   14  PUTR=10.*ALOG10(USVT/DEN); GO TO 70
   15  G=AR*RL-AI*XL+BR-T*XG
       P=AR*XL+AI*RL+BI+S*XG
       GO TO 70
   16  G=AR+BR*GL-BI*BL-T*XG
       P=AI+BR*BL+BI*GL-S*XG
       GO TO 70
   17  H=S*RG
       Q=T*RG
   49  DEN=(G+H)**2+(P+Q)**2
       GO TO 70
   18  GMR=(G*G-H*H+P*P-Q*Q)/DEN
       GMI=2.*(H*P-G*Q)/DEN
       GO TO 70
   19  GMR=(H*H-G*G+P*P-Q*Q)/DEN
       GMI=2.*(G*P-H*Q)/DEN
       GO TO 70
   20  GM=SQRT(GMR*GMR+GMI*GMI); GO TO 70
21     IF(1.-GM)212,211,212
211    PUTR=1.E76;GO TO 70
212    PUTR=(1.+GM)/(1.-GM); GO TO 70
   22  PUTI=ATAN(GMI,GMR); GO TO 70
   23  PUTI=(V*S-U*T)/DEN; GO TO 70
   24  ZR=(S*S-T*T)/DEN; ZI=2.*S*T/DEN
       ALR=GMR*ZR-GMI*ZI; ALI=GMR*ZI+GMI*ZR
       GO TO 70
   25  PUTR=GM; GO TO 70
26    PUTR=57.295779513*ATAN(ALI,ALR)
126   IF(PUTR-180.) 70,70,226
226   PUTR=PUTR-360.; GO TO 70
27    PUTR=360.-57.295779513*ATAN(V,U); GO TO 126
   28  ALR=U*RL+V*XL; ALI=U*XL-V*RL
       GO TO 70
   29  PUTR=-10.*ALOG10(GMR*GMR+GMI*GMI); GO TO 70
   30  PUTR=-10.*ALOG10(ALR*ALR+ALI*ALI); GO TO 70
   31  RLDRG=SQRT(RL/RG)
       RLRG=SQRT(RL*RG)
       ANR=AR*RLDRG; ANI=AI*RLDRG
       BNR=BR/RLRG; BNI=BI/RLRG
       CNR=CR*RLRG; CNI=CI*RLRG
       DNR=DR/RLDRG; DNI=DI/RLDRG
       S=ANR+BNR+CNR+DNR; T=ANI+BNI+CNI+DNI
       GO TO 70
   32  U=ANR+BNR-CNR-DNR; V=ANI+BNI-CNI-DNI
       GO TO 70
   33  U=2.*(ANR*DNR-ANI*DNI-BNR*CNR+BNI*CNI)
       V=2.*(ANR*DNI+ANI*DNR-BNR*CNI-BNI*CNR)
       GO TO 70
   34  U=2.; V=0.
       GO TO 70
   35  U=-ANR+BNR-CNR+DNR; V=-ANI+BNI-CNI+DNI
       GO TO 70
   36  S=BR; T=BI; GO TO 70
   37  S=CR; T=CI; GO TO 70
   38  U=AR; V=AI; GO TO 70
   39  U=AR*DR-AI*DI-BR*CR+BI*CI
       V=AR*DI+AI*DR-BR*CI-BI*CR
       GO TO 70
   40  U=1.; V=0.; GO TO 70
   41  U=DR; V=DI; GO TO 70
   42  U=-1.; V=0.; GO TO 70
   43  U=BR*CR-BI*CI-AR*DR+AI*DI
       V=BR*CI+BI*CR-AR*DI-AI*DR
       GO TO 70
   44  PUTI=0.; GO TO 70
   48  G=DR*RG-DI*XG+BR-T*XL
       P=DR*XG+DI*RG+BI+S*XL
       H=S*RL; Q=T*RL
       GO TO 70
   50  G=CR*RG-CI*XG+AR-V*BL
       P=CR*XG+CI*RG+AI+U*BL
       H=U*GL; Q=V*GL
       GO TO 70
   51  PUTR=GMR; PUTI=GMI
       GO TO 70
   52  PUTR=ALR; PUTI=ALI
       GO TO 70
   53  PUTR=0.; GO TO 70
   54  GO TO(154,254,354,454) LT-27
  154  PUTR=AR; PUTI=AI; RETURN
  254  PUTR=BR; PUTI=BI; RETURN
  354  PUTR=CR; PUTI=CI; RETURN
  454  PUTR=DR; PUTI=DI; RETURN
   55  ALR=-ALR; ALI=-ALI
   70  CONTINUE
       END
MICAP ** FICHE/FRAME BREAK *****
MICWORK SYMSORT

SYM.  PG.LN. IDENT.

+      24 23 C       +      24 22 C       +      24 21 C       +      22  2 C       
+      21 39 C       +      21 37 C       +      21 35 C       +      21 33 C       
+      21 31 C       +      21 29 C       +      21 27 C       1       1 37 C       
10     18 32 C       10     18 22 C       10     15 20 C       10      2  1 C       
100    19 14 C       100    16 39 C       1000    7 25 C       1010    7 26 C       
1020    7 28 C       1030    7 29 C       105    17  3 C       105     2 30 C       
1050    7 36 C       106    24  2 C       106    19 19 C       106    17  5 C       
106     2 31 C       1060    7 37 C       107    24  3 C       107    19 20 C       
1070    7 38 C       108    24  4 C       108    17  6 C       108     2 32 C       
1080    8  3 C       109    24  7 C       1090    8  5 C       110     2 34 C       
1100    8  6 C       111    24  5 C       1110    8  9 C       112    24  6 C       
1120    8 14 C       1130    8 15 C       1140    8 16 C       1160    8 21 C       
1170    8 25 C       1180    8 28 C       1190    8 32 C       120     2 35 C       
1210    9 13 C       1220    9 14 C       1230    9 22 C       125     2 36 C       
1250    9 33 C       126    26  2 C       1260    9 34 C       1270    9 37 C       
1280    9 38 C       1290    9 39 C       130     2 38 C       1300   10  5 C       
1310   10  6 C       1320   10  8 C       1325   10 11 C       1330   10 12 C       
134     3  1 C       1340   10 19 C       1342   10 20 C       1345   10 21 C       
1350   10 38 C       136     3  2 C       1360   11  1 C       1370   11  5 C       
138     3  3 C       1380   11 14 C       140     3  5 C       1400   11 18 C       
1410   11 19 C       1420   11 21 C       1430   11 22 C       1440   11 23 C       
1450   11 25 C       1460   11 27 C       1480   11 37 C       1490   11 38 C       
150     3  6 C       1500   12  1 C       1510   12  3 C       1520   12  4 C       
1525   12  9 C       1530   12 10 C       1540   12 11 C       155     3  7 C       
1550   12 12 C       1560   12 13 C       1570   12 16 C       1580   12 17 C       
160     3  9 C       1600   12 21 C       1610   12 22 C       1620   12 25 C       
1630   12 26 C       1640   12 29 C       1650   12 30 C       1660   12 31 C       
1670   12 33 C       1680   12 34 C       1690   12 37 C       170     3 10 C       
1700   12 38 C       1720   13  1 C       1730   13  2 C       1740   13  4 C       
1750   13  6 C       177    20 17 C       1770   13  8 C       1780   13  9 C       
1790   13 10 C       180     3 11 C       1810   13 14 C       1820   13 18 C       
1825   13 27 C       1830   13 28 C       1840   13 29 C       1850   13 30 C       
1860   13 31 C       1870   13 32 C       1880   13 34 C       1890   13 36 C       
190     3 14 C       1900   13 39 C       1910   14  2 C       1920   14  3 C       
1930   14  4 C       1940   14  7 C       1950   14 11 C       1960   14 14 C       
1970   14 15 C       1980   14 21 C       1990   14 22 C       20     18 34 C       
20     16 27 C       20     15 23 C       20      2  2 C       200     3 16 C       
2000   14 24 C       2020   14 26 C       2030   14 27 C       2040   14 28 C       
21     25 31 C       210     3 18 C       211    25 32 C       212    25 33 C       
220     3 20 C       226    26  3 C       230     3 21 C       240     3 24 C       
250     3 26 C       26     26  1 C       260     3 27 C       27     26  4 C       
270     3 28 C       277    20 18 C       280     3 30 C       290     3 32 C       
291     3 33 C       292     3 34 C       293     3 36 C       294     3 37 C       
295     3 38 C       299     4  1 C       30     18 35 C       30     16 29 C       
30      2  4 C       300    21 10 C       300     4  2 C       31     21  7 C       
310    21 15 C       310     4  4 C       320    21 18 C       320     4  6 C       
340    21 20 C       340     4 12 C       35     16 33 C       350    21 13 C       
350     4 15 C       360     4 18 C       370     4 19 C       380     4 21 C       
390     4 22 C       40     18 37 C       40     16 35 C       40      2  6 C       
400     4 27 C       406    17 25 C       408    17 26 C       410    17 28 C       
410     4 29 C       412    17 29 C       414    17 31 C       4145   16  2 C       
4150   16  3 C       420    17 33 C       420     4 30 C       430     4 34 C       
440     4 35 C       450     4 39 C       460     5  1 C       470     5  4 C       
480     5  5 C       5      18 20 C       5      15 13 C       5      15  5 C       
50     18 38 C       50     16 26 C       50      2  7 C       500     5  7 C       
520    23 12 C       520     5 10 C       530    23 14 C       530     5 12 C       
540    23 16 C       540     5 15 C       55      2 10 C       550    23 18 C       
550     5 16 C       560    23 20 C       570    23 22 C       570     5 18 C       
580     5 20 C       590     5 21 C       60      2 18 C       600     5 23 C       
610     5 24 C       640     5 29 C       660     5 35 C       670     5 37 C       
680     5 38 C       690     5 39 C       70     16 37 C       70      2 20 C       
710     6  5 C       720     6  7 C       730     6  9 C       740     6 12 C       
750     6 13 C       760     6 15 C       770     6 16 C       790     6 22 C       
80      2 21 C       800     6 23 C       810     6 26 C       820     6 27 C       
830     6 30 C       840     6 33 C       850     6 35 C       860     6 36 C       
870     6 37 C       890     7  3 C       90      2 25 C       900     7  4 C       
910     7  5 C       930     7  8 C       940     7 10 C       950     7 11 C       
960     7 13 C       970     7 15 C       980     7 17 C       990     7 20 C       
C      23  6 C       C      23  5 C       C      23  4 C       
C      23  3 C       C      23  2 C       C      23  1 C       C      22 39 C       
C      22 18 C       C      22 17 C       C      22 16 C       C      22 15 C       
C      22 14 C       C      22 13 C       C      22 12 C       C      22 11 C       
C      22 10 C       C      22  9 C       C      22  8 C       C      22  7 C       
C      21 23 C       C      19  5 C       C      19  4 C       C      18 28 C       
C      18 27 C       C      18 26 C       C      18 15 C       C      18 14 C       
C      16 31 C       C      15 37 C       C      15 27 C       C      14 34 C       
C      14 32 C       C      14 20 C       C      14 17 C       C      14  8 C       
C      13 25 C       C      13 23 C       C      13 22 C       C      13 20 C       
C      12 24 C       C      12 20 C       C      12 18 C       C      11 36 C       
C      11 35 C       C      11 32 C       C      10 34 C       C      10 18 C       
C      10 17 C       C      10  1 C       C       9 27 C       C       9 26 C       
C       9 25 C       C       9 24 C       C       9  7 C       C       9  6 C       
C       8 39 C       C       8 34 C       C       7 27 C       C       7 24 C       
C       7 19 C       C       7 16 C       C       5 30 C       C       4 11 C       
C       4 10 C       C       4  7 C       C       4  5 C       C       3 15 C       
C       2 39 C       C       2 29 C       C       2 27 C       C       2 15 C       
CM     24 19 C       CM     24 10 C       CM     23 31 C       CM     23 11 C       
CM     19 33 C       CM     19 24 C       CM     19 12 C       CM     19  9 C       
CM     19  6 C       CM     18 16 C       CM     17 34 C       CM     17  7 C       
CM     15 38 C       CM     15 28 C       CM     14 19 C       CM     14  5 C       
CM      4 23 C       CM      2 23 C       CM      2 14 C       CM      1 33 C       
CM100   2 26 C       CM1040  7 31 C       CM1062 18  1 C       CM110  17  8 C       
CM1150  8 19 C       CM120  17 10 C       CM1240  9 28 C       CM130  17 12 C       
CM1390 11 16 C       CM140  17 14 C       CM150  17 16 C       CM160  17 18 C       
CM1710 12 39 C       CM1760 13  7 C       CM1800 13 11 C       CM2010 14 25 C       
CM2050 14 30 C       CM330   4  9 C       CM490   5  6 C       CM510  23  7 C       
CM510   5  8 C       CM560   5 17 C       CM580  23 23 C       CM620   5 26 C       
CM700   6  3 C       CM780   6 20 C       CM920   7  6 C       CMC    24 18 C       
CMC    24  9 C       CMC    23 30 C       CMC    22 37 C       CMC    22 27 C       
CMC    22 25 C       CMC    22  6 C       CMC    21  9 C       CMC    19 32 C       
CMC    19 23 C       CMC    19 11 C       CMC    19  3 C       CMC    17 39 C       
CMC    16 38 C       CMC    16 36 C       CMC    16 14 C       CMC    16  8 C       
CMC    16  7 C       CMC    14 13 C       CMC    12 36 C       CMC    12 28 C       
CMC    12 15 C       CMC    12  7 C       CMC    12  5 C       CMC    12  2 C       
CMC    11 34 C       CMC    11 30 C       CMC    11 15 C       CMC    11 13 C       
CMC    10 16 C       CMC    10  7 C       CMC     9 21 C       CMC     8 33 C       
CMC     8 31 C       CMC     8 27 C       CMC     8 20 C       CMC     8 13 C       
CMC     8  4 C       CMC     8  2 C       CMC     7 18 C       CMC     7 14 C       
CMC     7  7 C       CMC     6 39 C       CMC     6 34 C       CMC     6 32 C       
CMC     6 29 C       CMC     6 25 C       CMC     6 21 C       CMC     6 19 C       
CMC     6 18 C       CMC     6 11 C       CMC     6  8 C       CMC     6  2 C       
CMC     5 33 C       CMC     5 28 C       CMC     5 19 C       CMC     5 14 C       
CMC     5 11 C       CMC     5  3 C       CMC     4 38 C       CMC     4 33 C       
CMC     4 28 C       CMC     4 24 C       CMC     4 14 C       CMC     4  3 C       
CMC     3 25 C       CMC     3 13 C       CMC     3  8 C       CMC     2 37 C       
CMC     1 36 C       CMC     1 35 C       CMC     1 25 C       CMC     1 10 C       
CMC     1  4 C       CMC     1  3 C       CMC     1  2 C       CMCM   22 36 C       
CMCM   21 24 C       CMCM   16 24 C       CMCM   16 16 C       CMCM   15 36 C       
CMCM    2  9 C       CMCM    1 14 C       CMCM12  9 11 C       CMCM14 11 29 C       
CMCM15 12 19 C       CMCM50 23 26 C       CMCM63  5 27 C       CMCM65  5 32 C       
CMCM88  6 38 C       CMCMC  22 19 C       CMCMC  21 22 C       CMCMC  14  6 C       
CMCMC  13 13 C       CMCMC  11  4 C       CMCMC   9 36 C       CMCMC   9 23 C       
CMCMC   1 22 C       CMCMCM 18 13 C       CMCMCM 15 16 C       CMCMCM 15  8 C       
CMCMCM  6  1 C       SMCMCM 17 20 C       
MICAP ** FICHE/FRAME BREAK *****
MICCAP

MICAP OFFERS THE CIRCUIT DESIGNER AN INTERACTIVE STEADY STATE ANALYSIS
PROGRAM CAPABLE OF SOLVING A WIDE VARIETY OF MICROWAVE AND LOW 
FREQUENCY CIRCUIT PROBLEMS.  THOSE CIRCUITS MUST BE AMENABLE TO
REPRESENTATION AS A CASCADE OF TWO-PORT SECTIONS OR SEVERAL CASCADED
STRINGS INTERCONNECTED THROUGH SERIES AND/OR PARALLEL JUNCTIONS. ALSO,
CLOSED LOOPS OF CASCADED STRINGS CAN BE ANALYZED.  THE PROGRAM TAKES
ADVANTAGE OF THE RELATIVELY FAST ABCD-MATRIX APPROACH IN SOLVING
NETWORKS BELONGING TO THIS CLASS.  IT CAN ACCOMMODATE A NETWORK CON-
SISTING OF ALMOST TWO HUNDRED SECTIONS.

A LIBRARY OF 21 STANDARD SECTIONS IS AVAILABLE, INCLUDING LOSSLESS AND
DISSIPATIVE TRANSMISSION LINES.  ASSOCIATED PARAMETER VALUES MAY BE
SPECIFIED IN COMMONLY-USED ENGINEERING UNITS (PF FOR PICOFARAD, NH FOR
NANOHENRY, ETC.) IF DESIRED. BY USING THE 'MICLIB' PACKAGE WITH
MICAP, SEVERAL CIRCUIT BLOCKS ARE MADE AVAILABLE WHICH ARE NOT
INCLUDED IN THE LIBRARY OF STANDARD SECTIONS. THIS ADDITIONAL
LIBRARY INCLUDES 'SERIES-PARALLEL' ELEMENTS,WAVEGUIDE SECTIONS,
'TWIN-TEE' NETWORK, LOW FREQUENCY AND MICROWAVE TRANSISTORS,
MULTIPORT MICROWAVE DEVICES, INTEGRATOR NETWORK, AND AN OPER-
ATIONAL AMPLIFIER NETWORK. THIS LIBRARY IS ACCESSED BY TYPING
'MICLIB' AT EXECUTIVE LEVEL.

A CHOICE OF 29 OUTPUT PARAMETERS IS AVAILABLE INCLUDING SUCH QUAN-
TITIES AS VSWR, REFLECTION COEFFICIENT, SCATTERING MATRIX, IMPEDANCE,
AND ADMITTANCE MATRICES, AS WELL AS THE ABCD-MATRIX ELEMENTS.  OUTPUT
DATA MAY BE OBTAINED SELECTIVELY AND DISPLAYED IN EITHER RECTANGULAR
OR POLAR FORM.

A UNIQUE FEATURE OF MICAP IS THE CAPABILITY TO SPECIFY THE OUTPUT
FORMAT.  FIVE PLACE ACCURACY IS STANDARD, BUT ANYWHERE FROM ONE TO
ELEVEN SIGNIFICANT FIGURES MAY BE SPECIFIED FOR EACH OUTPUT.

THE USE OF MICAP REQUIRES NO KNOWLEDGE OF PROGRAMMING.  THE USER
CONTROLS THE PROGRAM BY ISSUING COMMANDS WHICH ENABLE HIM TO SPECIFY
THE CIRCUIT, ITS INPUTS AND OUTPUTS, AS WELL AS MODIFICATIONS AND
STORAGE FOR SUBSEQUENT USE.

THE PROGRAM ACCOMMODATES A MAXIMUM NUMBER OF 200 CIRCUIT BLOCKS
AND 15 JUNCTIONS.
MICAP ** FICHE/FRAME BREAK *****
MICCOMLIST
19
42
3
ENTER
2
ADD
3
DELETE
3
READ
3
WRITE
3
LIST
3
QUIT
2
FOS
4
TAKE FROM
3
SOURCE
3
LOAD
4
REFERENCE
3
MERGE
4
INACTIVE
3
FROM
2
TO
2
LIN
2
LOG
2
BY
2
MB
2
BW
3
F LIST
3
OUTPUT
3
START
3
OVFOS
4
F USING
3
FORMAT
3
CHANGE
3
MODIFY
2
CUT
4
CONNECT
4
INCREMENT
4
VERSION
2
RUN
4
CREDITS
4
CHARGES
5
INSTRUCTIONS
2
?
3
HELP
5
CAPABILITIES
4
EXAMPLE
3
MICLIB
27
2
SR
2
PR
2
SL
2
PL
2
SC
2
PC
2
PRC
2
PRL
3
PRLC
2
PLC
2
DTL
2
LTL
2
SZ
2
PZ
2
PG
2
PY
3
LTLA
3
XFMR
2
AMP
2
SJ
2
PJ
2
UD1
2
UD2
2
UD3
2
UD4
2
UD5
2
UD6
11
2
UF
2
PF
2
MH
2
UH
2
NH
2
PH
2
KHZ
2
MHZ
2
GHZ
2
K
2
MEG
1
5
NO HEADING
20
5
RESISTANCE
5
INDUCTANCE
5
CAPACITANCE
5
ATTENUATION
5
WAVE NUMBER
4
FREQUENCY
6
SECTION LENGTH
7
ELECTRICAL LENGTH
5
CONDUCTANCE
8
REFERENCE FREQUENCY
4
REACTANCE
5
SUSCEPTANCE
5
TURNS RATIO
5
VOLTAGE GAIN
2
P1
2
P2
2
P3
2
P4
2
P5
2
P6
14
2
R
2
L
2
C
3
ATTEN
3
WAV NO
2
F
4
SEC LEN
3
EL LEN
2
G
3
REF F
2
X
2
B
4
T RATIO
3
GAIN
1
3
ABCD
4
3
SOURCE
3
LOAD
4
REFERENCE
6
F SPECIFICATION
1
2
DB
3
2
KHZ
2
MHZ
2
GHZ
1
2
%
37
2
ZIN
2
YIN
3
ZOUT
3
YOUT
2
IL
2
TL
3
VSWRS
3
VSWRL
2
RCS
3
**RPS
2
RCL
3
**RPL
2
PH
2
RLS
2
RLL
2
S11
2
S12
2
S21
2
S22
2
Y11
2
Y12
2
Y21
2
Y22
2
Z11
2
Z12
2
Z21
2
Z22
2
A
2
B
2
C
2
D
2
UD1
2
UD2
2
UD3
2
UD4
2
UD5
2
UD6
1
2
;
7
5
RECTANGULAR
3
POLAR
3
USING
3
REAL
4
IMAGINARY
4
AMPLITUDE
3
PHASE
6
3
FILE
4
TELETYPE
5
NO HEADING
3
PLOT
4
INCREMENT
4
COMPRESS
1
2
ALL
1
4
GENERATOR
3
3
FROM:
2
BY:
2
TO:
4
3
SERIES
4
PARALLEL
2
S-P
2
P-S
MICAP ** FICHE/FRAME BREAK *****
MICDCS
      SUBROUTINE UD1(A,FREQ,PUD)
      DIMENSION PUD(6),A(2,2,2)
      CALL UDERR(1)
      FREQ=-1
      RETURN
      END
C
C
      SUBROUTINE UD2(A,FREQ,PUD)
      DIMENSION PUD(6),A(2,2,2)
      CALL UDERR(2)
      FREQ=-2
      RETURN
      END
C
C
      SUBROUTINE UD3(A,FREQ,PUD)
      DIMENSION PUD(6),A(2,2,2)
      CALL UDERR(3)
      FREQ=-3
      RETURN
      END
C
C
      SUBROUTINE UD4(A,FREQ,PUD)
      DIMENSION PUD(6),A(2,2,2)
      CALL UDERR(4)
      FREQ=-4
      RETURN
      END
C
C
      SUBROUTINE UD5(A,FREQ,PUD)
      DIMENSION PUD(6),A(2,2,2)
      CALL UDERR(5)
      FREQ=-5
      RETURN
      END
C
C
      SUBROUTINE UD6(A,FREQ,PUD)
      DIMENSION PUD(6),A(2,2,2)
      CALL UDERR(6)
      FREQ=-6
      RETURN
      END
C
C
      SUBROUTINE UDERR(K)
      TYPE 5,K
5     FORMAT($ UD$,I,$IS NOT INCLUDED ON BINARY FILE /CS/..CHECK SUBROUTINE.$/)
      RETURN
      END
MICAP ** FICHE/FRAME BREAK *****
MICDOC
INTERNAL DOCUMENTATION FOR MICAP VERSION 5.00.

THE FOLLOWING FILES ARE THE SYMBOLICS NECESSARY TO MAKE
MICAP:

MICMAIN: CONTAINS THE USER INTERFACE AND INITIALIZATION ROUTINES.

MICWORK: CONTAINS THE ARITHEMETIC

MICDCS: CONTAINS DUMMY SUBROUTINES FOR THE USER SUPPLIED SUBROUTINE
        CAPABILITY.

MICLINKUP: DOES SOME TOPOLOGICAL BOOKEEPING FOR MICAP CIRCUITS.

MICUPDATE: RECORDS MICAP USEAGE DATA ON A FILE (@6LM)@MICUPD.

MICPLOT: PLOTTING ROUTINE FOR MICAP.

THE FOLLOWING INITIALIZATION FILES ARE READ BY MICAP AT THE TIME
THE OVERLAYS ARE MADE:

MICSECLIB: CONTAINS FORMATS, ETC.

MICCOMLIST: THE COMMAND LIST FOR MICAP.

MICFLIB:

THE FOLLOWING FILES CONTAIN THE HELP,CAPABILITIES,INSTRUCTIONS, AND
EXAMPLES FOR MICAP:

MICHELP
MICINST
MICCAP
MICEXAM

THE FOLLOWING ARE COMMAND FILES FOR COMPILING AND CREATING THE
OVERLAYS AND 'GO' FILE FOR MICAP:

MICAPC
MICAPM

THE FOLLOWING FILES MUST BE IN THE TYMSHARE LIBRARY FOR MICAP:

*MICAP
*FL1
*FL2
*FL3
*FL4
*FL5
*COMMAND
*NSWAP

(@6LM)MICTRAN:  A COMMAND FILE WHICH CALLS MICLIB
(@6LM)MICFOS: A COMMAND FILE WHICH CREATS THE USER SUBROUTINES TO MICAP.
(@6LM)MICWORKB
(@6LM)MICDCSB
(@6LM)MICHELP
(@6LM)MICINST
(@6LM)MICCAP
(@6LM)MICEXAM
(@6LM)MICFLIB

MICAP ** FICHE/FRAME BREAK *****
MICEXAM

ALL USER TYPING IS IN QUOTES ("), CARRAIGE RETURNS ARE INDICATED
BY (R)

-"MICAP(R)"

TYMSHARE MICROWAVE PROGRAM

  15:30    3/20 


:"ENTER(R)"

->"5 SR G ; 20(R)"

->"10 LTLA 5(R)"
RESISTANCE: "17.4(R)"
ELECTRICAL LENGTH: "90(R)"

->"15 LTLA 10(R)"
RESISTANCE: "14.142(R)"
ELECTRICAL LENGTH: "90(R)"

->"20 LTLA 15 ; 11.5, 90(R)"

->"25 PR 20(R)"
RESISTANCE: "10(R)"

->"(R)"

:"LIST(R)"

NO.  TYPE  FROM   TO
---  ----  ----  ----
  5  SR     (G)   10  R=2.0000E  1 
 10  LTLA    5    15  R=1.7400E  1  EL LEN=9.0000E  1 
 15  LTLA   10    20  R=1.4142E  1  EL LEN=9.0000E  1 
 20  LTLA   15    25  R=1.1500E  1  EL LEN=9.0000E  1 
 25  PR     20     0  R=1.0000E  1 

:"WRITE /TLINE/(R)"
 NEW FILE"(R)"

:"START(R)"

 DEFINE A SOURCE BLOCK
 DEFINE A LOAD BLOCK
 SPECIFY AT LEAST ONE OUTPUT
 SPECIFY A REFERENCE FREQUENCY
 SPECIFY FREQUENCY TEST DATA

:"SOURCE 5(R)"

:"LOAD 25(R)"

:"OUTPUT VSWRS ; ZIN ;(R)"

:"REFER 100MHZ(R)"

:"FROM 40 MHZ TO 250 MHZ LOG 10(R)"

:"START(R)"

 FREQUENCY     VSWRS        ZIN AMP      ZIN PHA    
-----------  -----------  -----------  -----------
 4.0000E  7   1.2905E  0   2.1458E  1        13.90
 4.8045E  7   1.1367E  0   2.1653E  1         5.74
 5.7708E  7   1.0034E  0   2.0060E  1          .09
 6.9314E  7   1.0877E  0   1.8399E  1          .59
 8.3255E  7   1.0947E  0   1.8763E  1         3.67
 1.0000E  8   1.0010E  0   2.0020E  1          .00
 1.2011E  8   1.1029E  0   1.8475E  1        -3.29
 1.4427E  8   1.0259E  0   2.0444E  1         -.75
 1.7329E  8   1.5998E  0   1.7214E  1       -24.62
 2.0814E  8   1.9551E  0   1.0835E  1        14.54
 2.5000E  8   1.1050E  0   2.1429E  1         4.13

:"CHANGE 20, RESIS(R)"
 20  LTLA   15    25  R=1.1500E  1  EL LEN=9.0000E  1 
RESISTANCE: "26(R)"

:"LIN 4(R)"

:"START NO HEAD(R)"

 4.0000E  7   2.2494E  0   1.8400E  1       -41.84
 9.2500E  7   5.1272E  0   5.5119E  1        54.13
 1.4500E  8   3.6348E  0   5.8020E  0        17.10
 1.9750E  8   1.9910E  0   1.0259E  1        -9.01
 2.5000E  8   3.1529E  0   8.5702E  0       -37.25

:"QUIT(R)"

-

MICAP ** FICHE/FRAME BREAK *****
MICHELP

ADD - TO ADD BLOCKS TO CIRCUIT DESCRIPTION
BW - TO DECLARE FRACTIONAL BANDWIDTH FOR FREQUENCY SWEEP
BY - TO DECLARE LINEAR INCREMENT FREQUENCY FOR FREQUENCY SWEEP
CAPABILITIES - TO PRINT CAPABILITIES OF PROGRAM
CHANGE - SAME AS MODIFY, BUT LISTS BLOCK INFORMATION FIRST
CHARGES - TO DETERMINE ADDITIONAL BILLING FOR USE OF PROGRAM
CONNECT - TO MAKE THE CONNECTION BETWEEN TWO SPECIFIED BLOCKS
CREDITS - TO DETERMINE SOURCE OF PROGRAM
CUT - TO BREAK THE CONNECTION BETWEEN TWO SPECIFIED BLOCKS
DELETE - TO DELETE ELEMENT BLOCKS
ENTER - TO ENTER A CIRCUIT DESCRIPTION
EXAMPLE - TO PRINT A SAMPLE RUN OF MICAP
F LIST - TO SPECIFY A DISCRETE SET OF TEST FREQUENCIES
F SPECIFICATION - TO LIST FREQUENCY SWEEP SPECIFICATION
F USING - TO SPECIFY A FORMAT FOR FREQUENCY PRINTING
FORMAT - TO CHANGE ANY OF THE TEN INTERNALLY STORED FORMATS
FROM - TO DECLARE STARTING FREQUENCY FOR FREQUENCY SWEEP
HELP - TO GET ALL THIS INFORMATION
INACTIVE - TO OBTAIN A LISTING OF INACTIVE BLOCK NUMBERS
INCREMENT - TO AUTOMATICALLY INCREMENT A BLOCK'S PARAMETER VALUE
INSTRUCTIONS - INSTRUCTIONS ON THE USE OF MICAP
LIN - TO DECLARE LINEAR SWEEP AND NUMBER OF INTERVALS
LIST - TO LIST BLOCK INFORMATION, SOURCE, LOAD, ETC.
LOAD - TO DECLARE THE BLOCK FROM WHICH THE EQUIVALENT LOAD EXTENDS
LOG - TO DECLARE LOGARITHMETIC SWEEP AND NUMBER OF INTERVALS
MB - TO DECLARE MIDBAND FREQUENCY FOR FREQUENCY SWEEP
MERGE - TO MERGE TWO ABCD MATRIX FILES IN SERIES, PARALLEL,
       SERIES-PARALLEL, OR PARALLEL-SERIES.
MODIFY - TO ALTER A BLOCK'S TYPE AND/OR PARAMETER VALUES
OUTPUT - TO SPECIFY THE OUTPUT ITEMS DESIRED
QUIT - TO QUIT MICAP AND RETURN TO EXECUTIVE LEVEL
READ - TO READ BLOCK INFORMATION FROM A FILE
REFERENCE - TO DECLARE THE REFERENCE FREQUENCY FOR TRANSMISSION LINES
SOURCE - TO DECLARE THE BLOCK TO WHICH THE SOURCE EXTENDS
START - TO START THE SOLUTION PROCESS
RUN - SAME AS START
TAKE FROM - TO INSTRUCT MICAP TO TAKE ALL FOLLOWING COMMANDS FROM A FILE
TO - TO DECLARE ENDING FREQUENCY FOR FREQUENCY SWEEP
VERSION - TO DETERMINE CURRENT VERSION OF PROGRAM
WRITE - TO WRITE BLOCK INFORMATION ON A FILE
MICAP ** FICHE/FRAME BREAK *****
MICINST

TYPE "EXAMPLE" FOR A SAMPLE PROBLEM RUN.  THE FOLLOWING TABLES WILL
LIST THE OUTPUT ITEMS AVAILABLE AND THE BLOCK TYPES THAT MAY BE USED.

OUTPUT ITEMS AVAILABLE
----------------------

IDENTIFIER                     ITEM
---------------   -------------------------------------
ABCD              ABCD-MATRIX ELEMENTS.
IL                INSERTION LOSS (DB)
PH                PHASE SHIFT FROM SOURCE TO LOAD.
RCL               REFLECTION COEFFICIENT AT LOAD.
RCS               REFLECTION COEFFICIENT AS SOURCE.
RLL               RETURN LOSS AT LOAD (DB).
RLS               RETURN LOSS AT SOURCE (DB).
S11 S12 S21 S22   SCATTERING MATRIX ELEMENTS.
TL                TRANSMISSION LOSS (DB).
UD1-UD6           USER-DEFINED OUTPUT ITEMS.
VSWRL             VOLTAGE STANDING WAVE RATIO AT LOAD.
VSWRS             VOLTAGE STANDING WAVE RATIO AT SOURCE.
Y11 Y12 Y21 Y22   ADMITTANCE MATRIX ELEMENTS.
YIN               INPUT ADMITTANCE.
YOUT              OUTPUT ADMITTANCE.
Z11 Z12 Z21 Z22   IMPEDANCE MATRIX ELEMENTS.
ZIN               INPUT IMPEDANCE.
ZOUT              OUTPUT IMPEDANCE.



BLOCK TYPES AVAILABLE
---------------------

IDENTIFIER           MEANING
-----------       -----------------------------------
AMP               IDEAL AMPLIFIER
DTL               DISSIPATIVE TRANSMISSION LINE
LTL               LOSSLESS TRANSMISSION LINE
LTLA              LOSSLESS TRANSMISSION LINE, TYPE A
PC                PARALLEL CAPACITOR
PG                PARALLEL CONDUCTANCE
PJ                PARALLEL JUNCTION
PL                PARALLEL INDUCTOR
PLC               PARALLEL, SERIES LC
PR                PARALLEL RESISTOR
PRC               PARALLEL, SERIES RC
PRL               PARALLEL, SERIES RL
PRLC              PARALLEL, SERIES RLC
PY                PARALLEL ADMITTANCE
PZ                PARALLEL IMPEDANCE
SC                SERIES CAPACITOR
SJ                SERIES JUNCTION
SL                SERIES INDUCTOR
SR                SERIES RESISTOR
SZ                SERIES IMPEDANCE
UD1-UD6           USER-DEFINED BLOCKS
XFMR              IDEAL TRANSFORMER

MICAP ** FICHE/FRAME BREAK *****
MICLINKUP
C    THIS OVERLAY HANDLES SOME TOPOLOGY BOOKEEPING THAT MUST BE
C    DONE IN THE MAIN PROGRAM, EXCEPT THAT THERE IS NO ROOM THERE.
C
C    THE FOLLOWING ARE DIMENSIONS FOR THE NO SWAP COMMON
C
      DIMENSION LINK(200,5),PAR(200)
      DIMENSION NI(19),NL(2,19),NC(101),NE(2,19),JK(7)
      DIMENSION FR(20)
      DIMENSION IDPLCH(10),KOUT(0/10),KFORMS(10,5)
      DIMENSION MERG1(16),MERG2(16),MERG3(16),JIST(3)
      DIMENSION IDUMNO(81),IBUFF(165)
C
C    DIMENSIONS FOR ARRAYS IN THIS OVERLAY
      DIMENSION A(2,2,2),B(2,2,2),C(2,2,2)
C
C    NO-SWAP COMMON
C
      COMMON LINK,PAR
      COMMON NI,NL,NC,NE,JK
      COMMON FR,LIMITS,FROM,TO,AMB,BW,LINLOG,NSTEPS,BY,REFREQ
      COMMON IDPLCH,KOUT,LOADBL,KSOURCE,KFORMS,IOSTOR,NOHED,IOSTOP
      COMMON KFROUT,MPLOT,NPLCH,INCPAR,INCREM,FRINC,BYINC,TOINC
      COMMON IMERGE,KSERPAR,MERG1,MERG2,MERG3,ITAKE,IDIOT,JIST,NPAR
      COMMON IDUMNO,IBUFF
C
C
C    IMERGE=0 IF ONLY LINKAGE ROUTINES ARE TO BE USED
C    IMERGE=1 IF FILE MERGING ROUTINES ARE TO BE USED
C    IMERGE=2 IF CPU AND TERMINAL TIME IS TO BE INITIALIZED
C    IMERGE=3 IF USAGE FILE IS TO BE UPDATED (@UPDATE IN @7DON)
C
C    KSERPAR=1 FOR SERIES MERGE, 2 FOR PARALLEL MERGE,3 FOR SERIES-PAR,
C     AND 4 FOR PAR-SERIES MERGE.
C
      CALL LDDONE
      CALL DCLESC(ESC)
      ASSIGN 100 TO ESC
      CALL ARM
      CALL SETESC
C
C
      GO TO (4,385,425,455,495,680,930,960,1230,1250,1505,1760,
      1810,1860,1920,2210,2260,2800,2860,3050,3090,3770,4270,
      625,3690,4070) IDIOT+1
4     GO TO (10,200,500,600) IMERGE+1
10    CALL SETLINK(IRETURN,JIST)
      IF(IRETURN) 100,100,50
50    CALL DANGLE
100   CALL TERMOV
C
C
C    THIS SECTION MERGES TWO FILES ONTO A THIRD AND CREATES A
C    SCRATCH FILE IN THE PROCESS - SCRATCH FILE MUST BE USED IN
C    ORDER TO MINIMIZE THE NUMBER OF FILES OPEN AT ONE TIME.
C
C
C    IN FILE MERGING, UNITS 2 AND 3 ARE USED
C
200   CONTINUE
      IMERGE=0
      XMODE=6HSYMINP
      OPEN(3,OUTPUT,BINARY,/*SCRATCH*/)
      CALL AOPEN(2,MERG1,XMODE)
      ICOUNT=0
      ON END FILE CNTRL,IVAR
      ASSIGN 250 TO CNTRL
C
210   READ 2,220,F,(((A(I,J,K), I=1,2), K=1,2), J=1,2)
220   FORMAT(9F)
      WRITE BINARY 3,F,(((A(I,J,K), I=1,2), K=1,2), J=1,2)
      ICOUNT=ICOUNT+1
      GO TO 210
C
C    "ICOUNT" LINES HAVE BEEN READ
250   CLOSE(2)
      CALL AOPEN(2,MERG2,XMODE)
      DO 270 L=1,ICOUNT
      READ 2,220,F,(((A(I,J,K), I=1,2), K=1,2), J=1,2)
270   WRITE BINARY 3,F,(((A(I,J,K), I=1,2), K=1,2), J=1,2)
C
C
C    NOW MERGE FIRST AND SECOND SET OF DATA USING RANDOM ACCESS FILES
      CLOSE(2)
      CLOSE(3)
      OPEN(3,RANDIO,BINARY,/*SCRATCH*/)
      XMODE=6HSYMOUT
      CALL AOPEN(2,MERG3,XMODE)
      DO 400 L=1,ICOUNT
      READ BINARY 3,F,(((A(I,J,K), I=1,2), K=1,2), J=1,2)
      MOVE=(ICOUNT-1)*18
      CALL FSPACE(3,MOVE)
      READ BINARY 3,F,(((B(I,J,K), I=1,2), K=1,2), J=1,2)
      MOVE=-ICOUNT*18
      CALL FSPACE(3,MOVE)
C
      CALL COMB(KSERPAR,A,B,C,JIST)
C
400   WRITE 2,410,F,(((C(I,J,K), I=1,2), K=1,2), J=1,2)
410   FORMAT(1PE15.7,2X,8(E15.7)/)
C
      CLOSE(2)
      CLOSE(3)
      CALL TERMOV
C    INITIALIZATION OF CPU AND TERMINAL TIME
500   PROGID=5HMICAP
      CALL UPDATE(0,PROGID,JIST)
      CALL TIME(MONTH,IDAY,IHR,MINS)
      K=MINS+100
      TYPE 520,IHR,K,MONTH,IDAY
520   FORMAT(2X,I2,$:$,I2,3X,I2,$/$,I//)
      CALL TERMOV
C
C    WRITE TOTAL CPU AND TERMINAL TIME
600   JIST(1)=MIN(JIST(1),9)
      DO 620 IB=1,200
      IF(LINK(IB,1)) 610,620,610
610   JIST(1)=JIST(1)+1000
      IF(LINK(IB,1)-22) 620,615,615
615   JIST(1)=JIST(1)+10
620   CONTINUE
      CALL UPDATE(1,PROGID,JIST)
      JIST(1)=0
      JIST(2)=0
      JIST(3)=0
      CALL TERMOV
C
C
C
C
C  THESE ARE THE ERROR MESSAGES MOVED HERE FROM THE MAIN OVERLAY
C  TO CREATE MORE ROOM THERE..
C
C
385   TYPE 395
395   FORMAT($ TYPE BLOCK NUMBER FIRST$/)
      GO TO 5000
425   TYPE 435
435   FORMAT($ BLOCK NO. NOT 1-200$/)
      GO TO 5000
455   TYPE 465
465   FORMAT($ OLD BLOCK...DATA IGNORED.$/)
      GO TO 5000
495   TYPE 505
505   FORMAT($ INVALID BLOCK TYPE$/)
      GO TO 5000
625   TYPE 435
      GO TO 5000
680   TYPE 690
690   FORMAT($ ILLEGAL LINKAGE$/)
      GO TO 5000
930   TYPE 940
940   FORMAT($ WARNING-->OVER 190 PARAMETER VALUES - WRITE, THEN READ$/)
      GO TO 5000
960   TYPE 970
970   FORMAT($ TOO MUCH DATA - EXCESS IGNORED$/)
      GO TO 5000
1230  TYPE 1240
1240  FORMAT($ FILE NON-EXISTANT$/)
      GO TO 5000
1250  TYPE 1260
1260  FORMAT($ WRONG TYPE FILE$/)
      GO TO 5000
1505  TYPE 1510
1510  FORMAT(/$ NO PROBLEM$/)
      GO TO 5000
1760  TYPE 1770
1770  FORMAT($ SOURCE UNDEFINED$/)
      GO TO 5000
1810  TYPE 1820
1820  FORMAT($ LOAD UNDEFINED$/)
      GO TO 5000
1860  TYPE 1870
1870  FORMAT($ REFERENCE FREQUENCY UNDEFINED$/)
      GO TO 5000
1920  TYPE 1930
1930  FORMAT($ NO FREQUENCY SPEC$/)
      GO TO 5000
2210  TYPE 2220
2220  FORMAT($ UNRECOGNIZABLE SUFFIX, RETYPE$)
      GO TO 5000
2260  TYPE 2270
2270  FORMAT($ IMPROPER SPECIFICATION$/)
      GO TO 5000
2800  TYPE 2810
2810  FORMAT($ INVALID OUTPUT PARAMETER, RE-ENTER$/)
      GO TO 5000
2860  TYPE 2870
2870  FORMAT($ ILLEGAL MODIFIER, RE-ENTER$/)
      GO TO 5000
3050  TYPE 3060
3060  FORMAT($ SPECIFY TEST FREQUENCIES$/)
      GO TO 5000
3090  TYPE 3100
3100  FORMAT($ INVALID MODIFIER$/)
      GO TO 5000
3690  TYPE 940
      GO TO 5000
3770  TYPE 3780
3780  FORMAT($ IMPROPER ARGUMENTS$/)
      GO TO 5000
4070  TYPE 4080
4080  FORMAT($ FROM/TO/BY SPEC ERROR$/)
      GO TO 5000
4270  TYPE 4280
4280  FORMAT($ FILE /CS/ NOT PRESENT OR NOT "BIN" FILE$/)
5000   CALL TERMOV
      END
      SUBROUTINE SETLINK(IRETURN,JIST)
C    THIS SUBROUTINE SETS UP ALL LINKAGES BETWEEN BLOCKS
C
      DIMENSION LINK(200,5),JIST(3)
      COMMON LINK
      IRETURN=1
      DO 300 IB=1,200
C    CHECK TO SEE IF BLOCK HAS BEEN DEFINED
      IF(LINK(IB,1)) 5,300,5
C    CHECK IF BLOCK LINKS TO ITSELF
5     DO 8 I=2,JUNCT(IB)
      IF(LINK(IB,I)-IB) 8,10,8
8     CONTINUE
      GO TO 17
10    TYPE 30,IB
      IRETURN=-1
      GO TO 300
C
C    CHECK THAT TWO LINKAGES ARE NOT IDENTICAL
17    DO 19 I=2,2+JUNCT(IB)
      DO 19 J=I+1,3+JUNCT(IB)
      IF(LINK(IB,I)*LINK(IB,J)) 18,19,18
18    IF(LINK(IB,I)-LINK(IB,J)) 19,20,19
19    CONTINUE
      GO TO 90
20    TYPE 30,IB
      JIST(2)=JIST(2)+100
30    FORMAT($ ERROR--> CHECK LINKAGES ON BLOCK $I/)
      IRETURN=-1
      GO TO 300
C
C
C    RUN THROUGH ALL THE LINKAGES OF BLOCK IB
90    DO 250 I=2,3+JUNCT(IB)
      IF(LINK(IB,I)) 250,250,95
95    MB=LINK(IB,I)
C
C    LOOK FOR A MATCH ON ONE OF MB'S LINKS
      DO 100 J=2,3+JUNCT(MB)
      IF(LINK(MB,J)-IB) 100,250,100
100   CONTINUE
C
C    NO MATCH WAS FOUND - FILL IN THE FIRST ZERO LINK
      DO 150 J=2,3+JUNCT(MB)
      IF(LINK(MB,J)) 150,120,150
120   LINK(MB,J)=IB
      GO TO 250
150   CONTINUE
C
C    NO EMPTY SLOT (ZERO LINK) WAS FOUND - LINKAGE CONFLICT
      TYPE 160,MB,IB
160   FORMAT($ BLOCK $,I,$HAS TOO MANY LINKAGES, FROM: $,I)
      JIST(2)=JIST(2)+100
      DO 176 J=2,3+JUNCT(MB)
      IF(LINK(MB,J)) 170,175,175
170   TYPE 172
172   FORMAT($(G) $)
      GO TO 176
175   TYPE 180,LINK(MB,J)
176   CONTINUE
180   FORMAT(I)
      TYPE 185
185   FORMAT(/)
      IRETURN=-1
250   CONTINUE
300   CONTINUE
      RETURN
      END
      SUBROUTINE DANGLE
C
C    THIS SUBROUTINE SCANS THE LINK ARRAY AND SETS THE BLOCK NAME
C    INTEGER NEGATIVE FOR ANY GROUP OF BLOCKS THAT IS NOT IN THE
C    MAIN SOURCE-LOAD GROUP
C    THIS SUBROUTINE USES FUNCTIONS "NEXTBL" AND "JUNCT"
C
      DIMENSION LINK(200,5)
      COMMON LINK
C    FIRST SET ALL IDENTIFIERS NEGATIVE
      DO 10 IB=1,200
      IF(LINK(IB,1)) 10,10,5
5     LINK(IB,1)=-LINK(IB,1)
10    CONTINUE
C    START AT SOURCE AND WORK TOWARD JUNCTION OR BRANCH END
C     SET ALL BLOCK ID'S UP TO JUNCTION POSITIVE
C    FIRST FIND BLOCK TIED TO SOURCE
      DO 20 IB=1,200
      IF(LINK(IB,1)) 12,20,12
12    DO 18 JB=2,3+JUNCT(IB)
      IF(LINK(IB,JB)+1) 18,14,18
14    IF(JUNCT(IB)) 16,16,17
16    NOW=LINK(IB,3-(JB-1)/2)
      GO TO 30
17    JB=0
      JPROC=0
      GO TO 300
18    CONTINUE
20    CONTINUE
C    NO SOURCE IN CIRCUIT - ALL BLOCKS INACTIVE
      RETURN
C
C    SOURCE HAS BEEN FOUND
30    LAST=IB
      LINK(LAST,1)=-LINK(LAST,1)
C    IS THE "NOW" BLOCK UNCOMITTED?
50    IF(NOW) 70,60,70
60    RETURN
70    IF(JUNCT(NOW)) 73,73,150
73    LINK(NOW,1)=-LINK(NOW,1)
75    NEXT=NEXTBL(LAST,NOW,JIST)
      IF(NEXT) 80,60,80
80    IF(JUNCT(NEXT)) 90,90,150
90    LINK(NEXT,1)=-LINK(NEXT,1)
      LAST=NOW
      NOW=NEXT
      GO TO 75
C    START PROCESSING ALL BLOCK STRINGS CONNECTED TO JUNCTIONS
150   JPROC=0
155   JB=1
158   IF(JB-200) 180,180,160
160   IF(JPROC) 170,170,150
170   RETURN
180   IF(LINK(JB,1)) 185,190,190
185   IF(JUNCT(JB)) 190,190,200
190   JB=JB+1
      GO TO 158
C    BLOCK JB IS A JUNCTION BLOCK - SEE IF IT HAS BEEN PROCESSED
200   DO 250 KB=2,4
      LB=LINK(JB,KB)
      IF(LB) 250,250,210
210   IF(LINK(LB,1)) 250,250,220
220   LINK(JB,1)=-LINK(JB,1)
      JPROC=1
      GO TO 300
250   CONTINUE
C
      GO TO 190
C
C    BLOCK JB IS A JUNCTION IN THE ACTIVE PROBLEM
C    BLOCK GROUP.  NOW FIND A BRANCHING STRING OF BLOCKS THAT LEAVES
C    THE JUNCTION
C
300   CONTINUE
      DO 450 KB=2,4
      LB=LINK(JB,KB)
      IF(LB) 450,450,320
320   IF(JUNCT(LB)) 340,340,450
340   IF(LINK(LB,1)) 400,450,450
C
400   LINK(LB,1)=-LINK(LB,1)
410   LAST=JB
      NOW=LB
420   NEXT=NEXTBL(LAST,NOW,JIST)
      IF(NEXT) 450,450,430
430   IF(JUNCT(NEXT)) 440,440,450
440   LINK(NEXT,1)=-LINK(NEXT,1)
      LAST=NOW
      NOW=NEXT
      GO TO 420
450   CONTINUE
      GO TO 190
      END
      FUNCTION NEXTBL(IB,JB,JIST)
C    THIS FUNCTION RETURNS THE VALUE OF THE NEXT BLOCK
C    BLOCK JB MUST NOT BE A JUNCTION BLOCK
C    BLOCKS IB AND JB MUST BOTH BE NON-ZERO AND POSITIVE
      DIMENSION LINK(200,5),JIST(3)
      COMMON LINK
      IF(LINK(JB,2)-IB) 20,10,20
10    NEXTBL=LINK(JB,3)
      RETURN
20    IF(LINK(JB,3)-IB) 40,30,40
30    NEXTBL=LINK(JB,2)
      RETURN
40    TYPE 50,IB,JB
      JIST(2)=JIST(2)+100
      CALL TERMOV
50    FORMAT($NEXTBL ERROR, $,I,$TO $,I/)
      RETURN
      END
      FUNCTION JUNCT(IB)
C    THIS FUNCTION RETURNS A ZERO IF BLOCK IB IS NOT A JUNCTION
C    AND RETURNS +1 IF IT IS
C
      DIMENSION LINK(200,5)
      COMMON LINK
      L=IABS(LINK(IB,1))
      IF((L-20)*(L-21)) 5,10,5
5     JUNCT=0
      RETURN
10    JUNCT=1
      RETURN
      END
      SUBROUTINE COMB(IU,U,V,W,JIST)
C
C     IU=1 DENOTES SERIES-SERIES MERGE.
C     IU=2 DENOTES PARALLEL-PARALLEL MERGE.
C     IU=3 DENOTES SERIES-PARALLEL MERGE.
C     IU=4 DENOTES PARALLEL-SERIES MERGE.
C     U,V ARE THE INPUT ABCD MATRICES.
C     W IS THE RESULTANT MERGED ABCD MATRIX.
C
      DIMENSION U(2,2,2),V(2,2,2),W(2,2,2),JIST(3)
C
C     CHECK FOR THE MERGE WHICH HAS BEEN SPECIFIED,
C     AND THEN CHECK TO SEE IF THE DENOMINATOR VANISHES.
C
      IF((IU-1)*(IU-2)*(IU-3)*(IU-4)) 40,15,40
15    GO TO (22,23,24,25) IU
22    JA=2;JB=1;JE=1;JG=2;JH=1;JJ=2;JS=2;JT=2;JW=1;JX=1
      GO TO 26
23    JA=1;JB=2;JE=2;JG=1;JH=2;JJ=1;JS=2;JT=2;JX=1;JW=1
      GO TO 26
24    JA=1;JB=2;JE=1;JG=2;JH=1;JJ=2;JS=1;JT=2;JX=1;JW=2
      GO TO 26
25    JA=2;JB=1;JE=2;JG=1;JH=1;JJ=2;JS=2;JT=1;JX=2;JW=1
26    SR=U(1,JG,JB)+V(1,JG,JB)
      SI=U(2,JG,JB)+V(2,JG,JB)
      IF(SR+SI) 36,27,36
27    GO TO (28,28,34,34) IU
28    DO 33 K=1,2
      IF(U(1,K,K)-1.) 42,29,42
29    IF(V(1,K,K)-1.) 42,30,42
30    IF(U(2,K,K)) 42,31,42
31    IF(V(2,K,K)) 42,32,42
32    W(1,K,K)=1.;W(2,K,K)=0
      W(K,JG,JB)=0
33    W(K,JB,JG)=U(K,JB,JG)+V(K,JB,JG)
      RETURN
34    DO 35 K=1,2
      W(K,JA,JA)=U(K,JA,JA)+V(K,JA,JA)
35    W(K,JB,JB)=0
      W(1,1,2)=1.;W(2,1,2)=0
      W(1,2,1)=1.;W(2,2,1)=0
      RETURN
C
C      NOW TO CALCULATE THE RESULTANT MATRIX..
C
36    DEN=SR*SR+SI*SI
      PR1=U(1,JA,JB)*V(1,JB,JB)-U(2,JA,JB)*V(2,JB,JB)
      PR2=U(1,JB,JB)*V(1,JA,JB)-U(2,JB,JB)*V(2,JA,JB)
      PR=PR1+PR2
      PI1=U(1,JA,JB)*V(2,JB,JB)+V(1,JB,JB)*U(2,JA,JB)
      PI2=V(1,JA,JB)*U(2,JB,JB)+U(1,JB,JB)*V(2,JA,JB)
      PI=PI1+PI2
      W(1,JE,JB)=(SR*PR+SI*PI)/DEN
      W(2,JE,JB)=(SR*PI-PR*SI)/DEN
      PR1=U(1,JG,JH)*V(1,JG,JJ)-U(2,JG,JH)*V(2,JG,JJ)
      PR2=V(1,JG,JH)*U(1,JG,JJ)-V(2,JG,JH)*U(2,JG,JJ)
      PR=PR1+PR2
      PI1=U(1,JG,JH)*V(2,JG,JJ)+V(1,JG,JJ)*U(2,JG,JH)
      PI2=V(1,JG,JH)*U(2,JG,JJ)+U(1,JG,JJ)*V(2,JG,JH)
      PI=PI1+PI2
      W(1,JG,JA)=(SR*PR+SI*PI)/DEN
      W(2,JG,JA)=(SR*PI-PR*SI)/DEN
      BR=U(1,JG,JB)*V(1,JG,JB)-U(2,JG,JB)*V(2,JG,JB)
      BI=U(1,JG,JB)*V(2,JG,JB)+U(2,JG,JB)*V(1,JG,JB)
      W(1,JG,JB)=(BR*SR+BI*SI)/DEN
      W(2,JG,JB)=(BI*SR-BR*SI)/DEN
      DR=U(1,JS,JT)-V(1,JS,JT)
      DI=U(2,JS,JT)-V(2,JS,JT)
      AR=V(1,JW,JX)-U(1,JW,JX)
      AI=V(2,JW,JX)-U(2,JW,JX)
      PR=DR*AR-DI*AI
      PI=DR*AI+DI*AR
      QR=(PR*SR+PI*SI)/DEN
      QI=(PI*SR-PR*SI)/DEN
      W(1,JE,JA)=U(1,JE,JA)+V(1,JE,JA)+QR
      W(2,JE,JA)=U(2,JE,JA)+V(2,JE,JA)+QI
38    RETURN
40    TYPE 41,IU
      JIST(2)=JIST(2)+10
41    FORMAT($MERGE ERROR--> IU=$I/)
      GO TO 38
42    TYPE 43
      JIST(2)=JIST(2)+10
43    FORMAT($ERROR--> MERGE FAILURE$)
      GO TO 38
      END
MICAP ** FICHE/FRAME BREAK *****
MICMAIN
C    MAIN PROGRAM FOR MICROWAVE - STARTED 8-29-69
C
C    THIS PROGRAM IMPLEMENTED BY DON PETERS AND STRUCTURALLY
C    MODELED AFTER "ANALOG".
C
C    PRESENT PROGRAM CAPACITY IS 200 BLOCKS
C
      DIMENSION NAME(10),FR(20),KOUT(0/10),KFORMS(10,5)
      DIMENSION NE(2,19),NI(19),NL(2,19),NC(101),JK(7)
      DIMENSION LINK(200,5),PAR(200),TEMP(6),IDPLCH(10),LTEMP(4)
      DIMENSION LIST(538),LISTADDRESS(20),KFILE1(5),KFILE2(5),KFILE3(5)
      DIMENSION KFILE4(5)
      DIMENSION IDUMNO(81),IBUFF(165)
      DIMENSION MERG1(16),MERG2(16),MERG3(16),JIST(3)
      DIMENSION IALL(1824)
C
      COMMON LINK,PAR
      COMMON NI,NL,NC,NE,JK
      COMMON FR,LIMITS,FROM,TO,AMB,BW,LINLOG,NSTEPS,BY,REFREQ
      COMMON IDPLCH,KOUT,LOADBL,KSOURCE,KFORMS,IOSTOR,NOHED,IOSTOP
      COMMON KFROUT,MPLOT,NPLCH,INCPAR,INCREM,FRINC,BYINC,TOINC
      COMMON IMERGE,KSERPAR,MERG1,MERG2,MERG3,ITAKE,IDIOT,JIST,NPAR
      COMMON IDUMNO,IBUFF
C
      EQUIVALENCE(LINK(1000),IALL(1824))
C
      IF(JREAD) 100,10,160
10    CALL TOVER(1)
C
C    READ IN THE COMMAND LISTS
      OPEN(2,INPUT,MICCOMLIST)
      CALL RDLIST(LIST,LISTADDRESS,2)
      CLOSE(2)
C
C    READ IN THE 'NE','NI', AND 'NL' ARRAYS
      OPEN(2,INPUT,MICSECLIB)
      DO 20 I=1,10
20    READ 2,30,(KFORMS(I,J), J=1,5)
30    FORMAT(5A3/)
      DO 40 J=1,19
40    READ 2,50,NE(1,J),NE(2,J),NI(J),NL(1,J),NL(2,J)
50    FORMAT(5F)
C    NOW READ IN THE NC ARRAY
      DO 60 J=1,101
60    READ 2,70,NC(J)
70    FORMAT(I)
C
C
      CLOSE(2)
C
      ASSIGN 140 TO IESCAPE
C    CHANGE 260 TO 140 FOR TYMSHARE SYSTEM
      ASSIGN 140 TO JESCAPE
      ASSIGN 330 TO KESCAPE
       ASSIGN 980 TO PESCAPE
C
C    DEFINE ACTIVE OVERLAY
      LACTIVE=2
       IDIOT=0
C
C
      IREADF=0
      ITAKE=0
C    DEFINE HELP AND CAPABILITIES FILE ARRAYS
      KFILE1(1)=3H(@6 ; KFILE1(2)=3HLM) ; KFILE1(3)=3HMIC ; KFILE1(4)=3HHEL ; KFILE1(5)=3HP  
      KFILE2(1)=3H(@6 ; KFILE2(2)=3HLM) ; KFILE2(3)=3HMIC ; KFILE2(4)=3HCAP ; KFILE2(5)=3H   
      KFILE3(1)=3H(@6 ; KFILE3(2)=3HLM) ; KFILE3(3)=3HMIC ; KFILE3(4)=3HINS ; KFILE3(5)=3HT  
      KFILE4(1)=3H(@6 ; KFILE4(2)=3HLM) ; KFILE4(3)=3HMIC ; KFILE4(4)=3HEXA ; KFILE4(5)=3HM  
C     SET NO. OF PLOT SPACES IN PLOT FIELD
      KFROUT=1
      IDPLCH(1)=1H*;IDPLCH(2)=1H+;IDPLCH(3)=1H#;IDPLCH(4)=1H.;IDPLCH(5)=1H,
      IDPLCH(6)=1H@;IDPLCH(7)=1H-;IDPLCH(8)=1H';IDPLCH(9)=1H";IDPLCH(10)=1H0
C
C    NOW READ IN SOLUTION OVERLAY
80    TYPE 85
85    FORMAT(/$LOADING WORK$/)
      CALL FOSLD(2)
      CALL CALLOV(2)
C
C    NOW READ IN CIRCUIT MODIFICATION OVERLAY
      TYPE 90
90    FORMAT($LOADING LINKUP$/)
      CALL FOSLD(3)
C
C    NOW READ IN THE PLOTTING OVERLAY
      TYPE 95
95    FORMAT($LOADING PLOT$/)
      CALL FOSLD(4)
      CALL CALLOV(4)
C
C
      JREAD=-1
      STOP
100   TYPE 105
105   FORMAT(/$TYMSHARE MICROWAVE PROGRAM$//)
      ICL=0
      IMERGE=2
      CALL CALLOV(3)
C
110   CONTINUE
      IF(JREAD) 120,120,180
120   JREAD=1
      INPUT=1
      INCPAR=0
      LINLOG=-1
      GO TO 170
C
140   CALL ARM
C    FOLLOWING BRS CLEARS TELETYPE OUTPUT BUFFER TO PROVIDE
C    IMMEDIATE RETURN TO COMMAND LEVEL
      CALL BRS(29,0,0,-1)
      INPUT=1
C    CHANGE 260 TO 140 FOR TYMSHARE SYSTEM
      ASSIGN 140 TO JESCAPE
      TYPE 150
150   FORMAT(//)
160   CLOSE
C
C    FOLLOWING BRS WAITS FOR TELETYPE OUTPUT BUFFER TO EMPTY
C    BEFORE TRANSFERRING CONTROL BACK TO PROGRAM
170   IF(ITAKE) 177,177,175
175   INPUT=1;ITAKE=0
177   CALL BRS(14,0,0,-1)
      CALL DCLESC(JESCAPE)
      CALL ARM
C    TYPE THE 'READY' SYMBOL
180   TYPE 190
190   FORMAT(/$:$)
      IF(ICL) 191,191,200
191   IF(INPUT-4) 192,200,200
192   JNPUT=3
      ICL=1
      IFN=0
      IF(LINGET(JNPUT,JFN,IESCAPE)) 195,200,220
195   CLOSE (0)
200   IF(LINGET(MAX(2,INPUT),IFN,IESCAPE)) 210,180,220
210   INPUT=1
C    CHANGE 260 TO 140 FOR TYMSHARE SYSTEM
      ASSIGN 140 TO JESCAPE
      GO TO 200
220   K=KOM(1,1)
      IF(K) 230,170,250
230   CALL PACKF(ERROR,6,1)
      TYPE 240,ERROR
240   FORMAT(A,$IS NOT A VALID COMMAND$/)
      GO TO 170
250   GO TO (280,1030,1040,1200,1310,1490,260,2100,2110,2130,
      2170,2190,2250,2380,2450,2480,2510,2530,2550,2580,
      2610,2650,2700,3030,3010,3230,3250,3370,3370,3700,
      3700,3930,4190,3030,4310,4330,4350,4370,4370,4380,
      4390,254) K
C    -----------------------------------------------------------------
C  NOW EXIT DIRECTLY TO THE 'MICLIB' PACKAGE.
254    OPEN(9,OUTPUT,BINARY,/*LAST*/)
       WRITE BINARY 9,IALL
       CLOSE (9)
       OPEN(0,INPUT,SYMBOLIC,(@6LM)MICTRAN)
       OPEN(1,OUTPUT,N)
C    ----------------------------------------------------------------
C    QUIT
260   CONTINUE
270   CLOSE
      IMERGE=3
C    TURN OFF ESCAPE SO WE CAN BE SURE TO GET UPDATE INFORMATION
      CALL BRS(113)
      CALL CALLOV(3)
C    TURN ESCAPE BACK ON
      CALL BRS(114)
C    GO DIRECTLY TO EXECUTIVE LEVEL, DO NOT PASS GO
      CALL BRS(10)
C    -------------------------------------------------------------------
C
C    ENTER
280   DO 290 I=1,200
      DO 290 J=1,5
290   LINK(I,J)=0
      DO 300 I=1,4
300   LTEMP(I)=0
      DO 310 I=1,200
310   PAR(I)=0
      NPAR=1
320   IF(IREADF-1) 330,360,330
330   TYPE 340
340   FORMAT(/)
C
C    OLD PROBLEM HAS BEEN ERASED
      TYPE 350
      CALL DCLESC(PESCAPE)
      CALL ARM
350   FORMAT($->$)
360   NCH=LINGET(MAX(2,INPUT),IFN,KESCAPE)
      IF(NCH) 990,980,370
C
C    SCAN FOR THE BLOCK NUMBER
370   K=NBR(X)
      IF(K) 380,980,400
380   IDIOT=1
      GO TO 6000
400   NUMBLK=X+.5
410   IF((NUMBLK-0)*(201-NUMBLK)) 420,420,440
420   IDIOT=2
      GO TO 6000
C
C    SEE IF THIS BLOCK HAS BEEN PREVIOUSLY DEFINED
440   IF(LINK(NUMBLK,1)) 450,480,450
450   IDIOT=3
      GO TO 6000
470   GO TO 320
C
C    NOW SCAN FOR THE BLOCK TYPE
480   LTEMP(1)=KOMEX(2)
      IF(LTEMP(1)) 490,510,540
490   IDIOT=4
      GO TO 6000
510   TYPE 520
520   FORMAT($ BLOCK TYPE: $)
530   NCH=LINGET(INPUT,IFN,IESCAPE)
      IF(NCH) 530,510,480
C
C    NOW GET BLOCKS IT LINKS TO
540   KHI=3
C    TEST FOR SERIES OR PARALLEL JUNCTION
      IF((LTEMP(1)-20)*(LTEMP(1)-21)) 570,560,570
560   KHI=4
570   DO 580 I=2,KHI
580   LTEMP(I)=0
      DO 710 I=2,KHI
      IF(KOM(13,1)) 590,630,720
590   IF(NBR(X)) 670,630,600
600   LTEMP(I)=X+.5
610   IF(LTEMP(I)*(200-LTEMP(I))) 620,710,710
620   IDIOT=23
      GO TO 6000
625   LTEMP(I)=0
630   IF(I-2) 640,640,720
640   TYPE 650
650   FORMAT($ LINK TO: $)
660   IF(LINGET(INPUT,9,IESCAPE)) 660,720,590
670   K=KOM(17,1)
      IF(K) 680,630,700
680   IDIOT=5
      GO TO 6000
700   LTEMP(I)=-K
710   CONTINUE
C    NATURAL FINISH - SKIP OVER POSSIBLE REDUNDANT SEMI-COLON
      K=KOM(13,1)
720   IF(KHI-3) 730,730,890
C
C    NOW GET ASSOCIATED PARAMETERS
C    CHECK IF BLOCK IS A USER DEFINED BLOCK
730   IF((LTEMP(1)-21)*(28-LTEMP(1))) 830,830,738
C    YES, IT IS
738    KM=LTEMP(1)-7
740   DO 820 KPM=1,6
750   IF(NUMBER(X)) 800,770,760
760   CALL  EDIT RESTORE
       CALL EDIT SAVE
       TEMP(KPM)=PARAM(KM,INPUT,KCR)
      GO TO 820
770   TYPE 780,KPM
780   FORMAT($ P$,I,$= $)
790   IF(LINGET(INPUT,IFN,IESCAPE)) 790,770,750
800   TYPE 810
810   FORMAT($ ?$/)
      GO TO 770
820   CONTINUE
C
C    ALL DATA GATHERED, NOW PUT IT IN ITS FINAL STORAGE LOCATIONS
      INDEX1=6
      GO TO 890
C    UNPACK THE 'NE' ARRAY INTO THE 'JK' ARRAY TO FIND WHICH
C    PARAMETERS ARE NEEDED
C
830   CALL DECODE(JK,NE,LTEMP(1))
840   INDEX1=0
      DO 880 INDEX=7,1,-1
      JKI=JK(INDEX)
      IF(JKF(JKI)) 850,880,850
850   INDEX1=INDEX1+1
860   TEMP(INDEX1)=PARAM(JKI,INPUT,KCR)
      IF(KCR) 880,880,870
870   TEMP(INDEX1)=0
880   CONTINUE
C
890   DO 900 I=1,KHI
900   LINK(NUMBLK,I)=LTEMP(I)
      IF(KHI-4) 910,320,910
C
910   LINK(NUMBLK,4)=NPAR
      LINK(NUMBLK,5)=INDEX1
      DO 920 KK=1,INDEX1
      PAR(NPAR)=TEMP(KK)
920   NPAR=NPAR+1
C
C     CHECK FOR TOO MANY PARAMETERS
      IF(NPAR-190) 950,950,930
930   IDIOT=6
      JIST(2)=JIST(2)+100000
      GO TO 6000
C    CHECK FOR EXCESS DATA
950   IF(NBR(X)) 960,320,960
960   IDIOT=7
      GO TO 6000
C
C    IGNORE BLANK LINES IF EXECUTING A READ STATEMENT
980   IMERGE=0
      CALL CALLOV(3)
      IF(IREADF) 170,170,360
C
C    AN END OF FILE ON READING HAS BEEN ENCOUNTERED
C    WERE WE TAKING COMMANDS FROM A FILE OR EXECUTING A READ STATEMENT
C
990   IF(IREADF) 1010,1010,1000
C    EXECUTING A READ STATEMENT
1000  INPUT=ITEMP1
      IFN=ITEMP2
      IREADF=0
      IMERGE=0
      CALL CALLOV(3)
      GO TO 170
1010  CONTINUE
      INPUT=1
      IFN=0
      GO TO 170
C    ---------------------------------------------------------
C
C    ADD
1030  GO TO 320
C     -------------------------------------------------------------
C
C    DELETE
1040  IF(NBR(X)) 1050,1070,1110
1050  TYPE 1060
1060  FORMAT($ NON-NUMERIC BLOCK ID, RETYPE $)
1070  TYPE 1080
1080  FORMAT($ BLOCKS: $)
1090  IF(LINGET(INPUT,IFN,IESCAPE)) 1090,1070,1040
1100  IF(NBR(X)) 1050,170,1110
1110  IB=X+.5
C     FIRST DELETE ALL REFERENCES TO BLOCK TO BE DELETED
      DO 1150 L=2,3+JUNCT(IB)
      LL=LINK(IB,L)
C     DON'T LOOK FOR A NEGATIVE, OR UNDEFINED BLOCK
      IF(LL) 1150,1150,1120
C     CYCLE THRU ALL LINKS OF BLOCKS LINKING TO BLOCK THAT IS TO BE DELETED
1120  DO 1140 K=2,3+JUNCT(LL)
      IF(LINK(LL,K)-IB) 1140,1130,1140
1130  LINK(LL,K)=0
1140  CONTINUE
1150  CONTINUE
C
C     IF BLOCK IS NOT A JUNCTION, DELETE ITS PARAMETERS
      IF(JUNCT(IB)) 1160,1160,1180
1160  DO 1170 JB=1,LINK(IB,5)
1170  PAR(LINK(IB,4)+JB-1)=0
C
C     NOW WE CAN FINALLY DELETE ALL LINKAGE DATA
1180  DO 1190 JB=1,5
1190  LINK(IB,JB)=0
C    BLOCK IS NOW DELETED - CHECK FOR ANOTHER ON LIST
      GO TO 1100
C    -----------------------------------------------------------
C
C    READ FROM
1200  KBIN=0
      XMODE=6HSYMINP
      IF(KOM(16,1)) 1220,1220,1210
1210  KBIN=1
      XMODE=6HBININP
1220  LBIN=OPENFILE(3,INPUT,IESCAPE,0,XMODE)+1.5
      GO TO (1230,1250,1250,1270,1290,1250) LBIN+1
1230  IDIOT=8
      GO TO 6000
1250  IDIOT=9
      GO TO 6000
C    BINARY TYPE FILE - HAS IT BEEN CALLED FOR?
1270  IF(KBIN) 1250,1250,1280
1280  READ BINARY 3,IALL
      CLOSE(3)
       GO TO 170
C    SYMBOLIC TYPE FILE - HAS IT BEEN CALLED FOR?
1290  IF(KBIN) 1300,1300,1250
1300  ITEMP1=INPUT
      ITEMP2=IFN
      INPUT=3
      IFN=3
      IREADF=1
      GO TO 280
C    -------------------------------------------------------------
C
C    WRITE ON
1310  KBIN=0
      XMODE=6HSYMOUT
      IF(KOM(16,1)) 1330,1330,1320
1320  KBIN=1
      XMODE=6HBINOUT
1330  CALL OPENFILE(3,INPUT,IESCAPE,1,XMODE)
C    CHECK FOR A BINARY WRITE
      IF(KBIN) 1350,1350,1340
1340  WRITE BINARY 3,IALL
      CLOSE(3)
      GO TO 170
C    BEGIN FILE WRITING
1350  DO 1480 IB=1,200
C    DO NOT WRITE OUT BLOCK IF IT'S UNDEFINED
      IF(LINK(IB,1)) 1360,1480,1360
1360  WRITE 3,1370,IB
1370  FORMAT(I4,1X)
C    WRITE OUT BLOCK ID
      CALL LENTRY(2,IABS(LINK(IB,1)),-4,3)
C    NOW CHECK IF BLOCK IS A JUNCTION BLOCK
1380  DO 1430 J=2,3+JUNCT(IB)
      MB=LINK(IB,J)
      IF(MB+1) 1390,1390,1410
1390  WRITE 3,1400
1400  FORMAT($   G$)
      GO TO 1430
1410  WRITE 3,1420,MB
1420  FORMAT(I4)
1430  CONTINUE
      IF(JUNCT(IB)) 1440,1440,1470
1440  DO 1450 JB=1,LINK(IB,5)
1450  WRITE 3,1460,PAR(LINK(IB,4)+JB-1)
1460  FORMAT(2X,1PE11.4)
1470  WRITE 3,340
1480  CONTINUE
      CLOSE(3)
      GO TO 170
C    ------------------------------------------------------------
C
C    LIST
1490  DO 1500 J=1,200
      IF(LINK(J,1)) 1520,1500,1520
1500  CONTINUE
      IDIOT=10
      GO TO 6000
1520  TYPE 340
      GO TO (1530,1540,1740,1800,1850,1900) KOM(8,1)+2
1530  IF(KOM(4,1)) 1590,1540,1580
C
C    LIST ALL BLOCKS
1540  TYPE 1600
1550  DO 1570 K=1,200
      IF(LINK(K,1)) 1560,1570,1560
1560  CALL LISTBL(K)
1570  CONTINUE
      GO TO 170
C
1580  IF(NBR(X)) 1680,1550,1620
C
1590  TYPE 1600
1600  FORMAT($NO.  TYPE  FROM   TO$/$---  ----  ----  ----$/)
C    SCAN FOR A BLOCK NUMBER
1610  IF(NBR(X)) 1680,170,1620
1620  IF(X) 1650,1610,1630
1630  IB=X+.5
C    IS BLOCK DEFINED?
      IF(LINK(IB,1)) 1640,1610,1640
1640  CALL LISTBL(IB)
      GO TO 1610
C    BLOCK IS NEGATIVE, A RANGE OF BLOCKS IS THEREFORE INDICATED
1650  JB=.5-X
      DO 1670 KB=IB+1,JB
      IF(LINK(KB,1)) 1660,1670,1660
1660  CALL LISTBL(KB)
1670  CONTINUE
      GO TO 1610
C
C    LIST ALL BLOCKS OF A PARTICULAR TYPE
1680  N=KOMEX(2)
      IF(N) 1690,170,1710
1690  CALL PACKF(RET,6,1)
      TYPE 1700,RET
1700  FORMAT($ THE STRING $,A,$ IS UNRECOGNIZABLE$/)
      JIST(2)=JIST(2)+10000
      GO TO 170
1710  DO 1730 J=1,200
      IF(IABS(LINK(J,1))-N) 1730,1720,1730
1720  CALL LISTBL(J)
1730  CONTINUE
      GO TO 1610
C
C    SOURCE(1) AND LOAD(2) LISTING
1740  CONTINUE
1750  IF(KSOURCE) 1760,1760,1780
1760  IDIOT=11
      GO TO 6000
1780  TYPE 1790,KSOURCE
1790  FORMAT($ SOURCE: TO $,I/)
      GO TO 2090
1800  IF(LOADBL) 1810,1810,1830
1810  IDIOT=12
      GO TO 6000
1830  TYPE 1840,LOADBL
1840  FORMAT($ LOAD: FROM $,I/)
      GO TO 2090
C
C    REFERENCE FREQUENCY LISTING
1850  IF(REFREQ) 1860,1860,1880
1860  IDIOT=13
      GO TO 6000
1880  TYPE 1890,REFREQ
1890  FORMAT($ REFERENCE FREQUENCY = $,1PE10.4/)
      GO TO 2090
C
C    FREQUENCY
1900  IF(LINLOG) 1910,2000,2070
1910  IF(FR(1)) 1920,1920,1940
1920  IDIOT=14
       GO TO 6000
1940  TYPE 1950
1950  FORMAT($ FREQUENCY LIST:$/)
      INDX=1
1960  IF(FR(INDX)) 1990,1990,1970
1970  TYPE 1980,FR(INDX)
1980  FORMAT(1PE12.4,/)
      INDX=INDX+1
      GO TO 1960
1990  TYPE 340
      GO TO 2090
C
C
2000  TYPE 2010
2010  FORMAT($ LINEAR $)
      TYPE 2020,FROM,TO
2020  FORMAT($SWEEP$/$ FROM $,1PE11.4,3X,$HZ TO $,E11.4,3X,$HZ $)
      IF(BY) 2050,2030,2050
2030  TYPE 2040,NSTEPS
2040  FORMAT($IN $,I,$STEPS$/)
      GO TO 2090
2050  TYPE 2060,BY
2060  FORMAT($BY $,1PE11.4,$ HZ$/)
      GO TO 2090
C
C
2070  TYPE 2080
2080  FORMAT($ LOG $)
      TYPE 2020,FROM,TO
      TYPE 2040,NSTEPS
C
C
2090  GO TO (1690,170,1740,1800,1850,1900) KOM(8,1)+2
C    --------------------------------------------------------------
C
C    STOP
2100  STOP
C    ---------------------------------------------------------------
C
C    TAKE FROM
2110  XMODE=6HSYMINP
      IF(OPENFILE(9,INPUT,IESCAPE,0,XMODE)) 170,170,2120
2120  ASSIGN 140 TO JESCAPE
      INPUT=4
      IFN=9
      GO TO 170
C    ---------------------------------------------------------------
C
C    SOURCE SPECIFICATION
2130  IF(NBR(X)) 2140,2140,2160
2140  TYPE 2150
2150  FORMAT($ ?$/$ RE-ENTER$/)
      GO TO 170
2160  KSOURCE=X+.5
      GO TO 170
C    ----------------------------------------------------------------
C
C    LOAD
2170  IF(NBR(X)) 2140,2140,2180
2180  LOADBL=X+.5         ;C    LOAD BLOCK
      GO TO 170
C    -------------------------------------------------------------
C
C    REFERENCE FREQUENCY
2190  IF(NBR(X)) 2140,2140,2200
2200  K=KOM(3,1)
      GO TO (2210,2240,2210,2210,2210,2210,2210,2210,2230,
      2230,2230,2210,2210,2210) K+2
2210  IDIOT=15
      GO TO 6000
2230  REFREQ=X*1000**(K-6)
      GO TO 170
2240  REFREQ=X
      GO TO 170
C    -----------------------------------------------------------------
C
C    MERGE (REPLACES JOIN COMMAND)
2250  IF(FILETYPE(MERG1,ITYPE)) 2260,2260,2280
2260  IDIOT=16
      GO TO 6000
C    PICK UP A POSSIBLE COMMA
2280  IF(KOMMA(0)) 2290,2260,2290
2290  IF(ITYPE-3) 2300,2310,2300
2300  IDIOT=9
      GO TO 6000
2310  IF(FILETYPE(MERG2,ITYPE)) 2260,2260,2320
2320  IF(ITYPE-3) 2300,2330,2300
2330  IF(KOMMA(0)) 2340,2260,2340
2340  IF(FILETYPE(MERG3,ITYPE)) 2260,2260,2350
C
C    NOTE! NO NEW/OLD FILE WARNING IS GIVEN FOR MERGE FILE
2350  IF(KOMMA(0)) 2360,2260,2360
2360  K=KOM(19,1)
      IF(K) 2260,2260,2370
2370  KSERPAR=K
      IMERGE=1
      JIST(1)=JIST(1)+1
      CALL CALLOV(3)
      GO TO 170
C    -----------------------------------------------------------------
C
C    INACTIVE, OR UNCOMITTED BLOCK STRINGS LISTING
2380  CONTINUE
      DO 2390 IB=1,200
      IF(LINK(IB,1)) 2410,2390,2390
2390  CONTINUE
      TYPE 2400
2400  FORMAT($ NO INACTIVE BLOCKS$/)
      GO TO 170
2410  TYPE 2420
2420  FORMAT($ UNCOMMITTED BLOCKS: $)
      DO 2440 IB=1,200
      IF(LINK(IB,1)) 2430,2440,2440
2430  TYPE 70,IB
2440  CONTINUE
      TYPE 340
      GO TO 170
C    -----------------------------------------------------------------
C
C             F R E Q U E N C Y       S P E C I F I C A T I O N
C
C    FROM  (START FREQUENCY)
2450  IF(NBR(X)) 230,170,2460
2460  FROM=X
      LIMITS=0
      K=KOM(10,1)
      IF(K) 220,170,2470
2470  FROM=FROM*1000**K
      GO TO 220
C
C    TO   (STOP FREQUENCY)
2480  IF(NBR(X)) 230,170,2490
2490  TO=X
      LIMITS=0
      K=KOM(10,1)
      IF(K) 220,170,2500
2500  TO=TO*1000**K
      GO TO 220
C
C    LIN   (LINEAR SWEEP)
2510  IF(NBR(X)) 230,170,2520
2520  LINLOG=0
      BY=0
      NSTEPS=X+.5
      GO TO 220
C
C    LOG   (LOGARITHMIC SWEEP)
2530  IF(NBR(X)) 230,170,2540
2540  LINLOG=+1
      NSTEPS=X+.5
      GO TO 220
C
C    BY   (USER SPECIFIED INCRIMENTAL LINEAR FREQUENCY)
2550  IF(NBR(X)) 230,170,2560
2560  BY=X
      LINLOG=0
      K=KOM(10,1)
      IF(K) 220,170,2570
2570  BY=BY*1000**K
      GO TO 220
C
C    MB   (MID-BAND FREQUENCY SPECIFICATION)
2580  IF(NBR(X)) 230,170,2590
2590  AMB=X
      LIMITS=1
      K=KOM(10,1)
      IF(K) 220,170,2600
2600  AMB=AMB*1000**K
      GO TO 220
C
C    BW    (BAND-WIDTH)
2610  IF(NBR(X)) 230,170,2620
2620  IF(KOM(11,1)) 230,2630,2640
2630  BW=X
      GO TO 220
2640  BW=X/100
      GO TO 220
C
C    FLIST  (DISCRETE FREQUENCY LIST)
2650  DO 2660 J=1,20
2660  FR(J)=0
      LINLOG=-1
      KPOINT=0
2670  IF(NBR(X)) 220,170,2680
2680  KPOINT=KPOINT+1
      FR(KPOINT)=X
      K=KOM(10,1)
      IF(K) 2670,170,2690
2690  FR(KPOINT)=FR(KPOINT)*1000**K
      GO TO 2670
C    -----------------------------------------------------------------
C
C    OUTPUT
2700  KPOINT=1
      GO TO 2740
2710  TYPE 2720,KPOINT
2720  FORMAT($ #$,I2,$: $)
C
C    INITIALIZATIONS
2730  IF(LINGET(INPUT,IFN,IESCAPE)) 2730,2820,2740
2740  IMRE1=0
      IMRE2=0
      JRECPOL=1
      JFORM=0
C    SCAN FOR AN OUTPUT COMMAND
2750  KO=KOM(12,1)
      IF(KO) 2760,2820,2840
2760  IF(KOM(7,1)) 2800,2800,2770
2770  DO 2790 KAM=28,31
      IF(KPOINT-11) 2780,2830,2830
2780  KOUT(KPOINT)=KAM*10000+200
2790  KPOINT=KPOINT+1
      IF(KOM(13,-1)) 2710,2710,2740
2800  IDIOT=17
      GO TO 6000
2820  IF(KPOINT-1) 2710,2710,2830
2830  KOUT(0)=KPOINT-1
      GO TO 170
C
C    SCAN FOR OUTPUT MODIFIERS
2840  GO TO (2850,2850,2910,2920,2930,2950,2970,2980,3000) KOM(14,1)+2
C    NO VALID MODIFIER - SCAN FOR A SEMI-COLON
2850  K=KOM(13,-1)
      IF(K) 2860,2880,2880
2860  IDIOT=18
      GO TO 6000
2880  IMRE=IMRE1+IMRE2
2890  KOUT(KPOINT)=JFORM+JRECPOL*100+IMRE*1000+KO*10000
      KPOINT=KPOINT+1
      IF(KPOINT-11) 2900,2830,2830
2900  IF(K) 2710,2710,2740
C    RECTANGULAR
2910  JRECPOL=2
      GO TO 2840
C    POLAR
2920  JRECPOL=1
      GO TO 2840
C    USING (FORMAT #)
2930  IF(NBR(X)) 2860,2940,2940
2940  JFORM=X+.5
      GO TO 2840
C    REAL
2950  IMRE1=1
2960  JRECPOL=2
      GO TO 2840
C    IMAGINARY
2970  IMRE2=2
      GO TO 2960
C    AMPLITUDE
2980  IMRE1=1
2990  JRECPOL=1
      GO TO 2840
C    PHASE
3000  IMRE2=2
      GO TO 2990
C    -----------------------------------------------------------------
C
C    OVFOS   (OVERLAY FOS)
3010  IF(NBR(X)) 170,170,3020
3020  IOSTOP=X+.5
      GO TO 170
C    -----------------------------------------------------------------
C
C     START
C     CHECK FOR A FREQUENCY SPECIFICATION
3030  IF(LINLOG) 3040,3070,3070
3040  IF(FR(1)) 3050,3070,3070
3050  IDIOT=19
      GO TO 6000
3070  NOHED=0
      IO1=0
      IO2=0
      MPLOT=0
      NPLCH=59
C    BORROW KSERPAR FOR THE COMPRESS FLAG (NORMALLY USED IN MERGE)
      KSERPAR=0
      INCREM=0
3080  GO TO (3090,3110,3160,3170,3180,3190,3210,3220) KOM(15,1)+2
3090  IDIOT=20
      GO TO 6000
3110  CONTINUE
      IF(IO1-1) 3140,3120,3140
3120  TYPE 3130
3130  FORMAT($ WRITE$)
      XMODE=6HSYMOUT
      CALL OPENFILE(2,INPUT,IESCAPE,1,XMODE)
3140  IOSTOR=IO1+IO2
      IF(IOSTOR) 3150,3150,4210
3150  IOSTOR=2
      GO TO 4210
C
C    OUTPUT TO FILE
3160  IO1=1
      GO TO 3080
C
C    OUTPUT TO TELETYPE
3170  IO2=2
      GO TO 3080
C
C    "NO HEADING" SPECIFIED
3180  NOHED=1
      GO TO 3080
C
C    "PLOT" SPECIFIED
3190  MPLOT=1
      IF(NBR(X)) 3080,3080,3200
3200  NPLCH=X+.5
      NPLCH=MIN(NPLCH,135)
      GO TO 3080
C
C    "INCREMENT" SPECIFIED
3210  INCREM=1
      GO TO 3080
C
C    "COMPRESS" SPECIFIED
3220  KSERPAR=1
      GO TO 3080
C    -----------------------------------------------------------------
C
C    F USING (TO SPECIFY A FORMAT FOR FREQUENCY TYPEOUT)
3230  IF(NBR(X)) 2140,2140,3240
3240  KFROUT=X+.5
      GO TO 170
C    -----------------------------------------------------------------
C
C    FORMAT  (USER DEFINED)
3250  IF(NBR(X)) 3260,3270,3280
3260  TYPE 3270
3270  FORMAT($ BAD FORMAT NO.$/)
      GO TO 170
3280  NMBR=X+.5
      IF(NMBR*(11-NMBR)) 3260,3260,3290
3290  IF(NOWCHR(0)-3H  :) 3260,3300,3260
3300  NEG=0
      INDEX=1
3310  DO 3340 IND=1,3
      K=NEXTCHR(1)
      IF(K) 3320,3330,3330
3320  NEG=1
      LTEMP(IND)=0
      GO TO 3340
3330  LTEMP(IND)=K
3340  CONTINUE
3350  KFORMS(NMBR,INDEX)=LTEMP(1)*65536+LTEMP(2)*256+LTEMP(3)
      IF(NEG) 3360,3360,170
3360  INDEX=INDEX+1
      IF(INDEX-6) 3310,170,3310
C    ---------------------------------------------------------------
C
C    CHANGE/MODIFY
3370  IF(NBR(X)) 3380,3380,3410
3380  TYPE 3390
3390  FORMAT($ BLOCK NO.: $)
3400  IF(LINGET(INPUT,IFN,IESCAPE)) 3400,3380,3370
3410  IB=X+.5
      IF(IB*(201-IB)) 3380,3380,3420
3420  IF(K-29) 3430,3440,3430
3430  CALL LISTBL(IB)
C    ---------------------------------------------------------------
C
C    MODIFY
3440  KM=KOM(5,1)
      IF(KM) 230,3450,3500
C
3450  LTEMP(1)=KOMEX(2)
      K=0
      IF(LTEMP(1)) 3460,3460,3490
3460  TYPE 3470
3470  FORMAT($ TYPE: $)
C    DON'T CHANGE BLOCK TYPE IF ANS TO "TYPE: " IS CARRIAGE RETURN
3480  IF(LINGET(INPUT,IFN,IESCAPE)) 3480,3500,3450
3490  LINK(IB,1)=LTEMP(1)
      K=1
C
C    DO NOT ATTEMPT TO MODIFY PARAMETERS IF BLOCK IS A JUNCTION BLOCK
3500  LTEMP(1)=LINK(IB,1)
      IF(JUNCT(IB)) 3512,3512,3510
3510  LINK(IB,4)=0
      GO TO 170
C
3512  IF((LTEMP(1)-21)*(28-LTEMP(1))) 3520,3520,3581
C
3520  CALL DECODE(JK,NE,IABS(LINK(IB,1)))
      INDEX1=0
      DO 3670 INDEX=7,1,-1
      JKI=JK(INDEX)
      IF(JKF(JKI)) 3530,3670,3530
3530  IF(KM) 3550,3550,3540
C
C    MODIFY PARAMETER "JKI"?
3540  IF(JKI-KM) 3650,3550,3650
C
C    MODIFY PARAMETER(S)
3550  TEMP(1)=PARAM(JKI,INPUT,KCR)
C    MODIFY ONE OR ALL (KM=0) PARAMETER VALUES
3560  IF(KM) 3590,3590,3570
3570  IF(KCR) 3580,3580,170
3580  PAR(LINK(IB,4)+INDEX1)=TEMP(1)
      GO TO 170
C
3581  INDEX1=0
      IF(KM) 3584,3584,3582
3582  KJ=KM
      MJ=LINK(IB,4)
      MJ=MJ+KM-15
      KP=KM-14
      TEMP(KP)=PARAM(KJ,INPUT,KCR)
      IF(KCR) 3583,3583,170
3583  PAR(MJ)=TEMP(KP)
      GO TO 170
3584  DO 3588 KP=1,6
      KJ=KP+14
3585  TEMP(KP)=PARAM(KJ,INPUT,KCR)
      IF(KCR) 3586,3586,3587
3586  PAR(NPAR)=TEMP(KP)
3587  INDEX1=INDEX1+1
      NPAR=NPAR+1
3588  CONTINUE
      GO TO 3680
C
C    TYPE CHANGE? - IF SO, PUT NEW DATA AT END OF "PAR" ARRAY
C    IF OLD, WRITE OVER OLD "PAR" DATA
3590  IF(K) 3600,3600,3620
C    NO TYPE CHANGE
3600  IF(KCR) 3610,3610,3660
3610  PAR(LINK(IB,4)+INDEX1)=TEMP(1)
      GO TO 3660
C    TYPE CHANGE
3620  IF(KCR) 3640,3640,3630
3630  PAR(NPAR)=0
      GO TO 3650
3640  PAR(NPAR)=TEMP(1)
3650  NPAR=NPAR+1
3660  INDEX1=INDEX1+1
3670  CONTINUE
      IF(K) 170,170,3680
3680  LINK(IB,4)=NPAR-INDEX1
      LINK(IB,5)=INDEX1
      IF(NPAR-190) 170,170,3690
3690  IDIOT=24
C    ---------------------------------------------------------------
C
C    CUT/CONNECT COMMON CODE
3700  M=0
      DO 3740 N=1,2
      IF(NBR(X)) 3720,3720,3710
3710  LTEMP(N)=X+.5
      GO TO 3740
3720  IF(KOM(17,1)) 3770,3770,3730
3730  LTEMP(N)=-1
      M=3-N
3740  CONTINUE
3750  IF(K-30) 3760,3760,3840
3760  IF(M) 3790,3790,3800
3770  IDIOT=21
      GO TO 6000
3790  DO 3820 M=1,2
3800  DO 3820 N=2,3+JUNCT(LTEMP(M))
      IF(LINK(LTEMP(M),N)-LTEMP(3-M)) 3820,3810,3820
3810  LINK(LTEMP(M),N)=0
3820  CONTINUE
      IMERGE=0
      CALL CALLOV(3)
      GO TO 170
C    ---------------------------------------------------------------
C
C    CONNECT
3830  CONTINUE
3840  IF(M) 3860,3860,3870
3850  GO TO 3770
3860  DO 3910 M=1,2
3870  DO 3880 N=2,3+JUNCT(LTEMP(M))
      IF(LINK(LTEMP(M),N)) 3880,3900,3880
3880  CONTINUE
      TYPE 3890,LTEMP(M)
      JIST(2)=JIST(2)+1000
3890  FORMAT($ BLOCK $,I,$LINKAGES ARE FULL$/)
C    ERROR CONDITION - BREAK ANY LINKS THAT MAY HAVE JUST BEEN MADE
      GO TO 3790
3900  LINK(LTEMP(M),N)=LTEMP(3-M)
      IF(M) 3910,3910,3920
3910  CONTINUE
3920  IMERGE=0
      CALL CALLOV(3)
      GO TO 170
C    -----------------------------------------------------------------
C
C    INCREMENT
3930  DO 3940 J=1,3
3940  TEMP(J)=0
3950  IF(NBR(X)) 3960,3960,3980
3960  TYPE 3390
3970  IF(LINGET(INPUT,IFN,IESCAPE)) 3970,3960,3950
3980   IB=X+.5
      KTYBL=LINK(IB,1)
      IF(JUNCT(IB)) 3990,3990,3982
3982  TYPE 3984
3984  FORMAT($  JUNCTION BLOCKS HAVE NO PARAMETERS...$/)
      GO TO 170
3990  KM=KOM(5,1)
      IF(KM) 4000,4000,4030
4000  TYPE 4010
4010  FORMAT($ PARAMETER: $)
4020  IF(LINGET(INPUT,IFN,IESCAPE)) 4020,4000,3990
C    PICK UP ALL DEFINED DATA
4030  DO 4050 J=1,3
      K=KOM(18,1)
      IF(K) 4050,4090,4040
4040  TEMP(K)=PARAM(KM,INPUT,KCR)
4050  CONTINUE
C
C    ANY MORE DATA IS ILLEGAL - CHECK FOR MORE ON LINE
4060  IF(NBR(X)) 4070,4090,4070
4070  IDIOT=25
      GO TO 6000
4090  DO 4150 J=1,3
4095  IF(TEMP(J)) 4100,4100,4150
4100  TYPE 4110
      CALL LENTRY(18,J,0,1)
      TYPE 4110
4110  FORMAT(1X)
4120  IF(LINGET(INPUT,IFN,IESCAPE)) 4120,4100,4130
4130  IF(NUMBER(X)) 4100,4100,4135
4135   CALL EDIT RESTORE
       CALL EDIT SAVE
4140  TEMP(J)=PARAM(KM,INPUT,KCR)
       KR=KOM(18,1)
       IF(KR) 4090,4090,4145
4145   J=KR;GO TO 4140
4150  CONTINUE
C
C    NOW PUT DATA INTO ITS FINAL STORAGE LOCATIONS
      FRINC=TEMP(1)
      BYINC=TEMP(2)
      TOINC=TEMP(3)
      IF((KTYBL-21)*(28-KTYBL)) 4158,4158,4152
4152  INCPAR=LINK(IB,4)+KM-15
      GO TO 170
4158  CALL DECODE(JK,NE,LINK(IB,1))
      INDEX1=0
      DO 4180 INDEX=7,1,-1
      JKI=JK(INDEX)
      IF(JKF(JKI)) 4160,4180,4160
4160  INDEX1=INDEX1+1
      IF(KM-JKI) 4180,4170,4180
4170  INCPAR=LINK(IB,4)+INDEX1-1
      GO TO 170
4180  CONTINUE
      GO TO 4000
C    ----------------------------------------------------------------
C
C    VERSION
4190  TYPE 4200
4200  FORMAT($ VERSION 5.01 OCTOBER 1971$/)
      GO TO 170
C    -----------------------------------------------------------------
C
C    CALL THE SOLUTION OVERLAY
4210  IF(LOADUD) 4220,4220,4300
C    CHECK FOR A USER DEFINED BLOCK
4220  DO 4230 IB=1,200
      IF(LINK(IB,1)-22) 4230,4250,4250
4230  CONTINUE
C
C    CHECK FOR USER DEFINED OUTPUT
      DO 4240 IB=1,KOUT(0)
      IF(KOUT(IB)/10000-32) 4240,4250,4250
4240  CONTINUE
      GO TO 4300
C
C    EXTERNAL  (FOR USER DEFINED SUBROUTINES)
C    BORROW THE MERG3 ARRAY FOR A QUICK TEST
4250  MERG3(1)=3H/CS ; MERG3(2)=1H/
C    FOLLOWING COMMAND PACKAGE FUNCTION IS FIRST USED TO CHECK FILE
C    FOR TYPE AND PRESENCE OF USER DEFINED COMPILED FILE /CS/
      XMODE=6HBININP
      K=IWORK(MERG3,4,+1,0,ITYPE,XMODE)
4260  IF(K-1) 4270,4265,4270
4265  IF(ITYPE-2) 4270,4290,4270
4270  IDIOT=22
      GO TO 6000
C    NOW THAT FILE IS LEGITIMATE, OPEN IT
4290  TYPE 4292
4292  FORMAT(/$(NOW LOADING /CS/)$/)
      OPEN(0,INPUT,(@6LM)MICFOS)
      OPEN(1,OUTPUT,N)
      NWLEFT=IFOSLD(5)
      CLOSE(0)
      CLOSE(1)
      IF(NWLEFT-500) 4294,4294,4296
4294  TYPE 4295,NWLEFT
4295  FORMAT($($,I,$WORDS LEFT)$/)
4296  CALL CALLOV(5)
      LACTIVE=5
      LOADUD=1
C
4300  CALL CALLOV(LACTIVE)
C
C    CLOSE THE DATA FILE
      CLOSE(2)
      GO TO 170
C    -----------------------------------------------------------------
C
C    CREDITS
4310  TYPE 4320
4320  FORMAT($ TYMSHARE$/)
      GO TO 170
C    -----------------------------------------------------------------
C
C    CHARGES
4330  TYPE 4340
4340  FORMAT($ YOUR REGULAR CHARGES AT PRESENT$/
             $   FUTURE PREMIUM CHARGE TO BE DETERMINED$/)
      GO TO 170
C    -----------------------------------------------------------------
C
C    INSTRUCTIONS
4350  CALL COPY(KFILE3,2HTE)
      GO TO 170
C    -----------------------------------------------------------------
C
C    HELP OR <QUESTION MARK>
4370  CALL COPY(KFILE1,2HTE)
      GO TO 170
C    -----------------------------------------------------------------
C
C    CAPABILITIES
4380  CALL COPY(KFILE2,2HTE)
      GO TO 170
C    -----------------------------------------------------------------
C
C    EXAMPLE
4390  CALL COPY(KFILE4,2HTE)
      GO TO 170
C    ----------------------------------------------------------------
C
6000  CALL CALLOV(3)
       IDRET=IDIOT
       IDIOT=0
      GO TO (340,340,470,510,630,950,320,170,170,170,2090,2090,
      2090,2090,170,170,2710,2710,170,170,170,170,625,170,
      4090) IDRET
C
C    END OF MICAP MAIN PROGRAM
C
      END
      FUNCTION JUNCT(K)
      DIMENSION LINK(200,5)
      COMMON LINK
      L=IABS(LINK(K,1))
      IF((L-20)*(L-21)) 5,10,5
5     JUNCT=0
      RETURN
10    JUNCT=1
      RETURN
      END
      FUNCTION OPENFILE(NOFIL,INPUT,IESCAPE,IO,XMODE)
      DIMENSION NAME(20)
C
C    FUNCTION INTERACTS WITH USER IN TRYING TO OPEN A FILE
C    'NOFIL' IS NUMBER OF FILE TO BE OPENED
C    'INPUT' INDICATES WHERE AND HOW INPUT IS TO COME IN
C    'IESCAPE' IS TRANSFER POINT WHEN AN ESCAPE IS RECEIVED
C    'IO' IS 0 IF A FILE IS BEING OPENED FOR INPUT, AND +1 IF FOR OUTPUT
C
      KTYPE=0
      OPENFILE=-1
      CLOSE(NOFIL)
10    LTYPE=FILETYPE(NAME,KTYPE)
      IF(KTYPE) 500,40,140
20    TYPE 30
30    FORMAT($ILLEGAL FILE NAME, RETYPE: $)
      GO TO 60
40    IF(IO) 42,42,46
42    TYPE 44
44    FORMAT($ FROM: $)
      GO TO 60
46    TYPE 50
50    FORMAT($ ON: $)
60    IF(LINGET(INPUT,9,IESCAPE)) 60,40,10
140   OPENFILE=KTYPE
      IF(IO) 400,400,200
200   IF(KTYPE) 220,220,260
220   TYPE 240
240   FORMAT($ NEW FILE$)
      GO TO 300
260   TYPE 280
280   FORMAT($ OLD FILE$)
300   IF(LINGET(INPUT,9,IESCAPE)) 300,380,320
320   OPENFILE=-1
      RETURN
380    OPENFILE=1
400    CALL  AOPEN(NOFIL,NAME,XMODE)
480   RETURN
500   IF(IO) 550,550,220
550   RETURN
      END
      FUNCTION PARAM(JTYPE,INPUT,KCR)
C
C    THIS FUNCTION READS IN A VALUE FOR A PARTICULAR
C    TYPE OF ELEMENT(JTYPE) FROM SOURCE DEFINED BY 'INPUT'
C    IF A CARRIAGE RETURN IS TYPED IN RESPONSE TO A PARAMETER
C    REQUEST, KCR IS RETURNED AS +1.  OTHERWISE KCR IS ZERO.
C
C
      KCR=0
90    IF(NBR(X)) 100,110,320
100   FORMAT($UNRECOGNIZABLE DATA, RETYPE $)
110   CALL LENTRY(5,JTYPE,0,1)
300   TYPE 310
310   FORMAT($: $)
315   IF(LINGET(INPUT,9,IESCAPE)) 315,110,90
C
317   PARAM=0
      KCR=1
      RETURN
C
C    NOW SCAN FOR AN ACCEPTABLE SUFFIX MULTIPLIER
320   FACTOR=1.0
340   GO TO (350,900,380,390,410,420,430,440,460,470,480,500,510) KOMEX(3)+2
350    KP=KOMMAND(18,1)
       IF(KP) 352,352,960
352    CALL EDIT RESTORE
       CALL EDIT SAVE
      IF(NUMBER(A)) 360,960,850
360   CALL EDIT RESTORE
      CALL EDIT SAVE
      TYPE 370
370   FORMAT($INVALID SUFFIX, RETYPE $)
      GO TO 110
C
C    CAPACITANCE SUFFIXES
380   FACTOR=1E-6
      GO TO 400
390   FACTOR=1E-12
400   IF((JTYPE-14)*(21-JTYPE)) 404,404,900
404   IF(JTYPE-3) 800,900,800
C
C    INDUCTANCE SUFFIXES
410   FACTOR=1E-3
      GO TO 450
420   FACTOR=1E-6
      GO TO 450
430   FACTOR=1E-9
      GO TO 450
440   FACTOR=1E-12
450   IF((JTYPE-14)*(21-JTYPE)) 454,454,900
454   IF(JTYPE-2) 800,900,800
C
C    FREQUENCY SUFFIXES
460   FACTOR=1E3
      GO TO 490
470   FACTOR=1E6
      GO TO 490
480   FACTOR=1E9
490   IF((JTYPE-14)*(21-JTYPE)) 494,494,900
494  IF(JKF(JTYPE)) 800,900,800
C
C    RESISTANCE SUFFIXES
500   FACTOR=1E3
      GO TO 520
510   FACTOR=1E6
520   IF((JTYPE-14)*(21-JTYPE)) 524,524,900
524   IF(JTYPE-1) 525,900,525
525   IF(JTYPE-11) 800,900,800
800   TYPE 810
810   FORMAT($WRONG MULTIPLIER SUFFIX, RETYPE $)
       GO TO 110
C
850   CALL EDIT RESTORE
      CALL EDIT SAVE
       PARAM=X*FACTOR
       RETURN
900   PARAM=X*FACTOR
      RETURN
960    CALL EDIT RESTORE
       CALL EDIT SAVE
       PARAM=X*FACTOR
       RETURN
      END
      SUBROUTINE LISTBL(IB)
C    THIS SUBROUTINE HANDLES THE LISTING OF BLOCK ASSOCIATED INFORMATION
      DIMENSION LINK(200,5),PAR(200),NE(2,19),JK(7),NI(19),NL(2,19),NC(101)
C
      COMMON LINK,PAR
      COMMON NI,NL,NC,NE,JK
C
      TYPE 10,IB
10    FORMAT(I3,1X)
12    ITYP=LINK(IB,1)
      IF(ITYP) 13,910,20
13    TYPE 14
14    FORMAT($-$)
      ITYP=-ITYP
      GO TO 30
20    TYPE 25
25    FORMAT(1X)
C    CHECK FOR A SERIES OR PARALLEL JUNCTION BLOCK
30    IF(ITYP-20) 40,300,32
32    IF(ITYP-21) 40,350,40
C
C    TYPE OUT THE BLOCK NAME
40    CALL LENTRY(2,ITYP,-4,1)
C
C    TYPE THE FROM AND TO NODES
      DO 50 ICONN=2,3
      IF(LINK(IB,ICONN)) 45,47,47
45    TYPE 46
46    FORMAT(3X$(G)$)
      GO TO 50
47    TYPE 48,LINK(IB,ICONN)
48    FORMAT(I5,1X)
50    CONTINUE
C
C    CHECK FOR USER DEFINED BLOCK
52    IF((ITYP-22)*(27-ITYP)) 55,400,400
C
55    CALL DECODE(JK,NE,ITYP)
      LF=0
      INDEX1=0
      DO 100 J=7,1,-1
      JKI=JK(J)
      IF(JKF(JKI))65,100,65
65    TYPE 70
70    FORMAT(1X)
      INDEX1=INDEX1+1
      IF(LF) 80,80,90
80    IF(INDEX1-3) 90,90,84
84    TYPE 87
87    FORMAT(/23X)
      LF=1
90    CALL LENTRY(6,JKI,0,1)
      TYPE 92
92    FORMAT($=$)
      TYPE  95,PAR(LINK(IB,4)+INDEX1-1)
95    FORMAT(1PE.4)
100   CONTINUE
      GO TO 900
C
C
300   TYPE 310
310   FORMAT($SJ    LINKING: $)
312   TYPE 330,(LINK(IB,J), J=2,4)
330   FORMAT(3I)
      GO TO 900
350   TYPE 360
360   FORMAT($PJ    LINKING: $)
      GO TO 312
C
C
C    LISTING OF USER DEFINED BLOCK PARAMETERS
400   K1=LINK(IB,4)
      K2=K1+5
      TYPE 410,(PAR(K3),K3=K1,K2)
410   FORMAT($  P1=$,1PE.4,$ P2=$,E.4,$ P3=$E.4,/23X
      $P4=$E.4,$ P5=$E.4,$ P6=$E.4)
C
900   TYPE 910
910   FORMAT(/)
      RETURN
      END
      SUBROUTINE DECODE(JK,NE,ITYPE)
      DIMENSION JK(7),NE(2,19)
C
C    THIS SUBROUTINE DECODES THE 'NE' ARRAY INTO THE 'JK' ARRAY
C
      JK(3)=NE(2,ITYPE)/10000
      I1=NE(2,ITYPE)-JK(3)*10000
      JK(2)=I1/100
      JK(1)=I1-JK(2)*100
      JK(7)=NE(1,ITYPE)/1000000
      I1=NE(1,ITYPE)-JK(7)*1000000
      JK(6)=I1/10000
      I1=I1-JK(6)*10000
      JK(5)=I1/100
      JK(4)=I1-JK(5)*100
      RETURN
      END
C
C
C
      FUNCTION JKF(I)
      JKF=I*(I-6)*(I-10)
      RETURN
      END
      FUNCTION KOMEX(LISTNO)
C    THIS FUNCTION SEARCHES COMMAND LIST 'LISTNO' FOR AN EXACT MATCH
C    ON AN INPUT STRING OF CHARACTERS.  PRECEEDING BLANKS ARE IGNORED.
C    THUS, LIST ENTRIES CAN BE ABBREVIATIONS OF ONE ANOTHER.
C
C    "MFLAG" ARRAY IS DIMENSIONED TO MAXIMUM EXPECTED ENTRIES IN LIST
C
      DIMENSION MFLAG(35)
C
C    FIRST FIND NO. OF ENTRIES IN THE COMMAND LIST
      NENTRY=0
1     IF(IGETCH(1,NENTRY+1,LISTNO)) 3,2,2
2     NENTRY=NENTRY+1
      GO TO 1
3     DO 4 J=1,NENTRY
4     MFLAG(J)=1
      K=NOWCHR(1)
      GO TO 10
7     K=NEXTCHR(1)
10    IF(K) 12,7,20
C    THERE ARE NO MORE CHARACTERS ON THE LINE
12    KOMEX=0
      RETURN
20    JCH=1
22    DO 30 J=1,NENTRY
      IF(K-IGETCH(JCH,J,LISTNO)) 25,30,25
25    MFLAG(J)=-1
30    CONTINUE
      JCH=JCH+1
      K=NEXTCHR(1)
      IF(K) 50,50,40
C    CHECK FOR A COMMA
40    IF(K-12) 22,45,22
C    SKIP OVER THE COMMA SO IT DOESN'T LOUSE UP SCAN FOR A NUMBER
45    K=NEXTCHR(1)
C    THERE IS NO NEXT CHARACTER ON THE INPUT LINE, OR IT IS A SPACE
50    DO 60 J=1,NENTRY
      IF(MFLAG(J)) 60,60,52
52    IF(IGETCH(JCH,J,LISTNO)) 53,53,60
53    KOMEX=J
54    CALL EDIT CLEAR
      CALL EDIT SAVE
      GO TO 80
60    CONTINUE
      KOMEX=-1
70    CALL EDIT RESTORE
      CALL EDIT SAVE
80    RETURN
      END
      SUBROUTINE LENTRY(NLIST,NENTRY,IFORM,IO)
      DIMENSION M(30)
C
C    THIS SUBROUTINE PRINTS OUT THE COMMAND, OR ENTRY, CONTAINED
C    IN LIST 'NLIST', ENTRY 'NENTRY'.  THE ARGUMENT 'IFORM' CONTROLS
C    THE PRINTOUT IN THE FOLLOWING MANNER:
C
C       IFORM                  MEANING
C       -----      -----------------------------------------------
C        -K         PRINT ENTRY: APPEND SPACES (IF NECESSARY) TO MAKE
C                   TOTAL FIELD WIDTH EQUAL TO 'K'
C
C         0         PRINT ENTRY WITH NO TRAILING OR LEADING BLANKS
C
C        +K         PRINT ENTRY: INSERT SPACES AT BEGINNING OF FIELD
C                   (IF NECESSARY) TO MAKE TOTAL FIELD WIDTH EQUAL TO 'K'
C
C    'IO' IS THE UNIT NO. THE OUTPUT IS TO GO ON (1 FOR TELETYPE)
C
C    FIRST STORE UP ALL CHARACTERS IN THE LIST ENTRY
C
      JCH=1
5     KAR=IGETCH(JCH,NENTRY,NLIST)
      IF(KAR) 20,10,10
10    M(JCH)=KAR
      JCH=JCH+1
      GO TO 5
C    NO MORE CHARACTERS - FIND LAST NON-BLANK CHARACTER
20    DO 30 MX=JCH-1,1,-1
      IF(M(MX)) 30,30,40
30    CONTINUE
C    THERE ARE EXACTLY 'MX' CHARACTERS IN THE ENTRY
C    NOW SET THEM UP FOR OUTPUT IN A1 FORMAT
40    DO 50 L=1,MX
50    M(L)=M(L)*65536
      IF(IFORM) 60,60,100
60    DO 70 L=1,MX
70    WRITE IO,80,M(L)
80    FORMAT(A1)
      IF(IFORM) 90,85,85
85    RETURN
90    IFORM=-IFORM
      KAR=1
C    TYPE OUT SPACES (SKIP OVER IF IFORM=JCH)
100   IF(IFORM-MX) 130,130,105
105   DO 110 L=1,IFORM-MX
110   WRITE IO,120
120   FORMAT(1X)
130   IF(KAR) 60,85,85
      END
      FUNCTION NBR(X)
C    THIS FUNCTION SCANS FOR A NUMBER AND RETURNS THE NUMBER IN X.
C    NBR IS +1 IF A NUMBER WAS SCANNED, 0 IF NOTHING MORE IS ON LINE,
C    AND -1 IF THERE IS A NON-NUMERIC BEING SCANNED.  TRAILING BLANKS
C    AND COMMAS ARE IGNORED.
C
      NBR=NUMBER(X)
      IF(NBR) 10,15,22
C
C    NON-NUMERIC STRING
10    CALL EDIT RESTORE
      CALL EDIT SAVE
15    RETURN
C    A NUMBER HAS BEEN SCANNED
22     CALL EDIT CLEAR
      CALL EDIT SAVE
25    IF(KOMMA(0)) 10,15,22
      END
      FUNCTION KOM(LI,MIN)
C    THIS FUNCTION SCANS FOR A COMMAND IN LIST 'LI' HAVING A MINIMUM
C    OF 'MIN' CHARACTERS THAT MUST MATCH.  IF MATCH FAILS, POINTER
C    DOESN'T MOVE.  IF MATCH SUCCEEDS, POINTER ADVANCES, PAST
C    MATCH, AND ANY SPACES OR COMMA.
C
C
      KOM=KOMMAND(LI,MIN)
      IF(KOM) 10,20,30
C
C    NO UNIQUE COMMAND
10    CALL EDIT RESTORE
      CALL EDIT SAVE
20    RETURN
C
C
30    CALL EDIT CLEAR
      CALL EDIT SAVE
32    IF(KOMMA(0)) 10,20,30
      END
      FUNCTION LINGET(INPUT,IFN,IESCAPE)
C
C    THIS FUNCTION GETS A NEW LINE OF INPUT, EITHER FROM THE USERS
C    TERMINAL OR FROM A FILE.  LINGET IS RETURNED AS THE NUMBER OF
C    CHARACTERS IN THE INPUT LINE OR -1 IF AN END OF FILE WAS
C    ENCOUNTERED.  THE ARGUMENT 'INPUT' DETERMINES HOW THE LINE IS TO
C    BE TAKEN IN.  IN FILE INPUT, 'IFN' IS THE FILE BEING READ
C
C     INPUT             MEANING
C    -------   -------------------------------------------------------
C       1       GET A NEW LINE FROM USER TERMINAL
C       2       SAME AS 1, BUT RESET ESCAPE TO 'IESCAPE' AFTER FIRST CHAR.
C       3       GET A NEW LINE FROM FILE IFN, BUT DON'T ECHO IT
C       4       SAME AS 3, BUT ECHO THE LINE
C
C    THE ARGUMENT 'IESCAPE' IS USED WHEN 'INPUT' IS 2.  CONTROL IS THEN
C    TRANSFERRED TO THE MAIN PROGRAM LOCATION DECLARED BY THE
C    ARGUMENT 'IESCAPE'.
C
C
      IF(IENTER) 20,10,20
10    IRED = 110*256*256 ;C RED SHIFT
      IBLACK=111*256*256 ;C BLACK SHIFT
      IENTER=1
C
C
20    IF(INPUT-3) 25,35,35
C    SHIFT TO RED FOR USER TYPING
25    TYPE 30,IRED
30    FORMAT(A1)
C
C    GET A LINE OF INPUT
35    GO TO (100,200,300,400) INPUT
100   CALL NEW LINE(NCH)
      GO TO 500
C
200   CALL ESC NEW(NCH,IESCAPE)
      GO TO 500
C
300   CALL READ FILE(NCH,IFN)
      GO TO 500
C
400   CALL ECHO FILE(NCH,IFN)
500   LINGET=NCH
C
C    SET SAVED POINTER POSITION TO FIRST CHARACTER IN INPUT LINE
      IF(LINGET) 510,520,510
510   CALL EDIT SAVE
520   IF(INPUT-3) 550,570,570
C
C    SHIFT BACK TO BLACK
550   TYPE 30,IBLACK
570   IF(NCH) 700,600,600
600   RETURN
C
700   INPUT=1
      RETURN
      END
MICAP ** FICHE/FRAME BREAK *****
MICPLOT
C    P L O T T I N G   O V E R L A Y
C
C    THIS OVERLAY WAS CREATED BECAUSE THERE WAS NO ROOM IN THE WORK
C    OVERLAY
C
C
C     DIMENSIONS FOR ARRAYS STORED IN NO-SWAP COMMON
      DIMENSION LINK(200,5),PAR(200)
      DIMENSION NI(19),NL(2,19),NC(101),NE(2,19),JK(7)
      DIMENSION FR(20),IDPLCH(10),KOUT(0/10),KFORMS(10,5)
      DIMENSION MERG1(16),MERG2(16),MERG3(16),JIST(3)
      DIMENSION IDUMNO(81),IBUFF(165)
C
C
      COMMON LINK,PAR
      COMMON NI,NL,NC,NE,JK
      COMMON FR,LIMITS,FROM,TO,AMB,BW,LINLOG,NSTEPS,BY,REFREQ
      COMMON IDPLCH,KOUT,LOADBL,KSOURCE,KFORMS,IOSTOR,NOHED,IOSTOP
      COMMON KFROUT,MPLOT,NPLCH,INCPAR,INCREM,FRINC,BYINC,TOINC
      COMMON IMERGE,KSERPAR,MERG1,MERG2,MERG3,ITAKE,IDIOT,JIST,NPAR
      COMMON IDUMNO,IBUFF
C
C
C    ARRAYS NEEDED ONLY IN THIS OVERLAY
      DIMENSION LC(5,44),NOUT(8),TITLE(37)
      DIMENSION KFORMAT(7)
      DIMENSION PLMIN(10),PLMAX(10),B(20),LPOS(135)
C
C
      KFORMAT(1)=1H(
      KFORMAT(7)=1H)
C
      CALL LDDONE
      IF(INIT) 55,1,1
C
C
C    READ IN THE "LC", "NOUT", AND "TITLE" ARRAYS
C     "LC" ARRAY IS NOT USED IN THIS OVERLAY
C
1     INIT=-1
      OPEN(2,INPUT,MICFORMLIB)
      DO 10 J=1,44
10    READ 2,20,(LC(I,J), I=1,5)
20    FORMAT(5F/)
      READ 2,30,(NOUT(I), I=1,7)
30    FORMAT(7I/)
      DO 40 I=1,37
40    READ 2,50, TITLE(I)
50    FORMAT(A5/)
      CLOSE(2)
C
      CALL TERMOV
55    CALL DCLESC(ESC)
      ASSIGN 6000 TO ESC
      CALL ARM
      CALL SETESC
C
C
      NLINES=MERG3(1)
      NCOLS=MERG3(2)
C    CLOSE AND RE-OPEN SCRATCH FILE
1780  CLOSE(3)
      OPEN(3,INPUT,/*SCRATCH*/)
      IF(NLINES-2) 5000,5000,1790
C    READ IN FIRST LINE AND SET PLMIN AND PLMAX TO THEM
1790  READ 3,1800,F,(PLMIN(I),I=1,NCOLS)
1800  FORMAT(12F)
      READ 3,1600
1600  FORMAT(/)
      DO 1810 I=1,NCOLS
1810  PLMAX(I)=PLMIN(I)
C
C    NOW READ IN REMAINDER OF LINE
      DO 1830 J=1,NLINES-1
      READ 3,1800,F,(B(I),I=1,NCOLS)
      READ 3,1600
      DO 1820 I=1,NCOLS
      PLMIN(I)=AMIN(PLMIN(I),B(I))
1820  PLMAX(I)=AMAX(PLMAX(I),B(I))
1830  CONTINUE
      IF(NOHED) 1840,1840,2070
1840  DO 2060 IO=1,2
      IF(IO-IOSTOR) 1850,2060,1850
C
C    TYPE TITLES
1850  NFIELD=0
      DO 2040 I=1,KOUT(0)
      CALL UNCODE(KOUT(I),IVAR,IMRE,JRECPOL,JFORM)
      GO TO (1860,1890,1960,1890) IMRE+1
1860  IF(N12(IVAR,NOUT)) 1870,1870,1890
C
C    WRITE ONE REAL OUTPUT
1870  WRITE IO,1880,TITLE(IVAR)
1880  FORMAT(2X,A5,2X)
      GO TO 2010
C
C    WRITE A COMPLEX OUTPUT
1890  WRITE IO,400,TITLE(IVAR)
400   FORMAT(A5,1X)
      IF(JRECPOL-1) 1900,1900,1920
C
C    AMPLITUDE
1900  WRITE IO,1910
1910  FORMAT($AMP$)
      GO TO 1940
C
C    REAL
1920  WRITE IO,1930
1930  FORMAT($RE $)
1940  NFIELD=NFIELD+1
      UNPOS=ABS((PLMAX(NFIELD)-PLMIN(NFIELD))/NPLCH)
      WRITE IO,2030,IDPLCH(NFIELD),PLMIN(NFIELD),PLMAX(NFIELD),UNPOS
      IF(IMRE) 1960,1960,1950
1950  IF(IMRE-3) 2020,1960,2020
C
1960  WRITE IO,400,TITLE(IVAR)
      IF(JRECPOL-1) 1970,1970,1990
C
C    PHASE
1970  WRITE IO,1980
1980  FORMAT($PHA$)
      GO TO 2010
C
C    IMAGINARY
1990  WRITE IO,2000
2000  FORMAT($IM $)
2010  NFIELD=NFIELD+1
      UNPOS=ABS((PLMAX(NFIELD)-PLMIN(NFIELD))/NPLCH)
      WRITE IO,2030,IDPLCH(NFIELD),PLMIN(NFIELD),PLMAX(NFIELD),UNPOS
2020  CONTINUE
2030  FORMAT($ = $,A1,3X,$MIN =$,1PE9.2,3X,$MAX =$,E9.2,3X,$UNITS/POS =$,E9.2/)
2040  CONTINUE
C
C    TYPE SERIES OF UNDERLINES
      WRITE IO,2050
2050  FORMAT(70($-$)/)
2060  CONTINUE
C
C    CLOSE AND RE-OPEN SCRATCH FILE
2070  CLOSE(3)
      OPEN(3,INPUT,/*SCRATCH*/)
      DO 2170 J=1,NLINES
      READ 3,1800,F,(B(I),I=1,NCOLS)
      READ 3,1600
C
C    ZERO OUT THE LINE POSITION ARRAY
      DO 2080 K=1,NPLCH
2080  LPOS(K)=0
C
      DO 2090 K=NCOLS,1,-1
      PL=PLMAX(K)-PLMIN(K)
       IF(PL) 2088,2086,2088
2086   L=5;GO TO 2090
2088  L=((B(K)-PLMIN(K))/(1.001*PL))*NPLCH+1
2090  LPOS(L)=IDPLCH(K)
C
C    FIND RIGHTMOST PLOT CHARACTER
      DO 2100 LIM=NPLCH,1,-1
      IF(LPOS(LIM)) 2110,2100,2110
2100  CONTINUE
C
2110  DO 2160 IO=1,2
      IF(IO-IOSTOR) 2120,2160,2120
2120  DO 2130 K=1,5
2130  KFORMAT(K+1)=KFORMS(KFROUT,K)
      WRITE IO,KFORMAT,F
      DO 2140 K=1,LIM
2140  WRITE IO,2150,LPOS(K)
2150  FORMAT(A1)
C
      WRITE IO,1600
2160  CONTINUE
2170  CONTINUE
      DO 2190 IO=1,2
      IF(IO-IOSTOR) 2180,2190,2180
2180  WRITE IO,2050
2190  CONTINUE
      CLOSE(3)
5000  CONTINUE
      CALL TERMOV
6000   CONTINUE
       ITAKE=1
       CLOSE (3)
       CALL TERMOV
      END
C
C
C
      FUNCTION N12(IVAL,NOUT)
      DIMENSION NOUT(1)
      DO 10 J=1,8
      IF(IVAL-NOUT(J)) 10,20,10
10    CONTINUE
      N12=1
      RETURN
20    N12=0
      RETURN
      END
C
C
C
      SUBROUTINE UNCODE(IOUT,IVAR,IMRE,JRECPOL,JFORM)
C     THIS SUBROUTINE DIVIDES THE WORD IOUT INTO ITS COMPONENTS
C
      JRECPOL=IOUT/100
      JFORM=IOUT-JRECPOL*100
      IMRE=JRECPOL/10
      JRECPOL=JRECPOL-IMRE*10
      IVAR=IMRE/10
      IMRE=IMRE-IVAR*10
      RETURN
      END
MICAP ** FICHE/FRAME BREAK *****
MICSECLIB
1PE11.4
1PE11.4,0PF13.2
1PE11.4,E13.4
-3PF7.3,$ KHZ$
-6PF7.3,$ MHZ$
-9PF7.3,$ GHZ$
2(1PE13.6)
2(1PE15.8)
2(F9.2,2X)
2(F10.4,1X)
0 1 1 1 2
0 1 2 4 5
0 206 3 10 11
0 206 4 13 15
0 306 5 17 19
0 306 6 21 22
0 10306 7 24 30
0 10206 8 32 38
1 20306 9 40 51
0 20306 10 52 57
1040506 71011 11 58 59
105 60710 12 61 67
0 111 13 69 71
0 111 14 73 79
0 9 15 7 8
0 912 16 81 83
1 60810 17 85 91
0 13 18 93 95
0 14 19 97 101
80112
91010
0
80112
171110
0
80112
111010
0
81402
150910
0
81402
151617
111010
0
81402
151617
91010
0
81402
151110
0
81402
152603
151821
202927
21128
31501
111010
0
81402
152618
190312
182012
270111
291627
21110
0
81426
280315
21516
210530
181929
152604
151820
302802
271129
180415
12711
100000
81426
180315
21516
212029
152711
100000
132324
220710
0
81323
10607
242931
150209
311217
280211
101010
0
80112
20912
10910
0
80112
181902
121820
122701
111216
270211
101010
0
80112
21112
11110
0
82523
10607
242904
150209
41217
280211
101010
0
80112
170607
120610
0
80112
191605
300607
121706
101010
MICAP ** FICHE/FRAME BREAK *****
MICUPDATE
     SUBROUTINE UPDATE(K,PROGID,KDATA)
      DIMENSION UPDTE(3),KDATA(3)
C
C    THIS ROUTINE UPDATES A SYSTEM USAGE FILE CALLED (@6LM)@MICUPD
C     WHENEVER IT IS CALLED.  THE INFORMATION RECORDED IS:
C
C     1.  NAME OF PROGRAM
C     2.  MONTH AND DAY ACCESSED
C     3.  USER ACCOUNT AND HIS USER NUMBER
C     4.  CPU AND TERMINAL TIME USED
C     5.  INTEGER WORDS OF PROGRAM FEEDBACK
C
C    ARGUMENT "K" IS ZERO TO INITIALIZE CPU AND TERMINAL TIMES, +1 TO
C        UPDATE USAGE FILE
C    ARGUMENT "PROGID" CONTAINS NAME OF PROGRAM (6 CHARACTERS MAXIMUM)
C    ARGUMENT "KDATA" IS AN ARRAY OF 3 INTEGER WORDS THAT ARE TO BE
C        SAVED ON UPDATE FILE IN 3I6 FORMAT
C
      IF(K) 100,100,150
C
C    INITIALIZE CPU AND TERMINAL TIME
100   CONTINUE
      CALL BRS(88,KSEC,KDUMMY,LDUMMY)
      CALL TIME(MONTH,IDAY,IHR,MINS)
      RETURN
150   UPDTE(1)=6H(A1MNO ; UPDTE(2)=6H)MICUS ; UPDTE(3)=4HE
C    CHECK IF UPDATE FILE EXISTS
      CALL FILEID(IFT,UPDTE)
      IF(IFT-3) 250,200,250
C
C    COMPUTE AND WRITE OUT ACCUMULATED CPU AND TERMINAL TIME
200   CONTINUE
C    FIRST TURN OFF ESCAPE, IF DESIRED
C     CALL BRS(113)
      CALL BRS(88,LSEC,KDUMMY,LDUMMY)
      MSEC=(LSEC-KSEC)/60
      CALL TIME(MONTH,IDAY,IHR1,MINS1)
      IHR2=IHR1-IHR
      MINS2=MINS1-MINS
      IF(MINS2) 210,212,212
210   MINS2=MINS2+60
      IHR2=IHR2-1
212   XMODE=6HSYMOUT
      CALL AOPEN(4,UPDTE,XMODE)
C    FIND USER NUMBER (ARGUMENTS TO FOLLOWING BRS MUST BE VARIABLES)
      KON1=8
      KON2=LOCF(NUSER)
      KON3=1
      CALL BRS(67,KON1,KON2,KON3)
C    FIND HIS ACCOUNT NUMBER AND DETERMINE IF HE HAS IN-HOUSE STATUS
      CALL BRS(39,I1,I2)
      I1=(I2/32768+32)*65536
      I2=(MOD(I2/4096,8)+16)*256
      KACCT=I1+I2
C    OUTPUT AN ASTERISK IF USER IS A CUSTOMER
      IF(I1-1H@) 214,218,214
214   IF(I1-1HA) 216,218,216
216   KSTAT=1H*
218   CONTINUE
C
      WRITE 4,220,PROGID,MONTH,IDAY,IHR,MINS,KACCT,NUSER,KSTAT,
     +MSEC,IHR2,MINS2,KDATA(1),KDATA(2),KDATA(3)
220   FORMAT(A6,3X,I2,$/$,I2,I4,$:$,I2,2X,A2,O4,A1,I6,I5,$:$,I2,4X,3I6/)
      CLOSE(4)
C    RESET INITIAL TIMES
      KSEC=LSEC
      IHR=IHR1
      MINS=MINS1
C    TURN ESCAPE BACK ON, IF DESIRED
C     CALL BRS(114)
250   RETURN
      END
'V-^