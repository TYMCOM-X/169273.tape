CONFILE ** FICHE/FRAME BREAK *****
CONFILESYM
CONFILE IDENT  SEPT 1970
*
*              VERSION 2 SEPT 1970
*      MODIFICATIONS BY JIM FAULKNER
*                              AT 1001 WATERTOWN ST.
*                              WEST NEWTON MA.
*
*      1.      CONVERTED TO NARP RATHER THAN ARPAS(SUBTITUTE
*              '3*' FOR '(R)' AND 'OPD 103B5,1,1' BECOMES 'OPD 103B5,2')
*      2.      CHANGE TO CONSIDER 137B TO BE JUST LIKE ANY OTHER
*              CHAR. EVEN IF IT IS THE LAST WORD OF THE FILE
*
PRQ    OPD 103B5,2    DEFINE POP TO PRINT MESSAGE
       BRU *+2
       BRS 10  IN CASE OF CONTINUE ATTEMPT
       STA COMFL  STORE COMMAND FILE NO.
       STA COMFL1
       CLB
       SKE =0
       LDB =-1
       STB CMFLG  0 IF PROG CALLED FROM TEL, -1 IF FROM COM FILE
       LDA BPR  BRU PRQPOP IS IN BPR
       STA 103B
RESET  CLA
       STA ERFLG  USED IN ROUTINE "ERR"
PRCHK  TCO =155B
       TCO =155B
       SKN CMFLG
       BRU GLTCH
       BRU IN1  DO NOT PRINT GLITCH IF PROG CALLED FROM COM FILE
GLTCH  TCO =32B  PRINT COLON
IN1    CIO COMFL
       SKE =155B IF CR ONLY, PRINT COLON AGAIN
       BRU IN11
       TCO =155B
       BRU PRCHK
IN11   SKE =137B  HIT END OF COM FILE BEFORE QUIT
       BRU IN2
       LDA COMFL
       BRS 20  CLOSE COM FILE
       CLA
       STA COMFL  RESET TO TTY "MODE"
       STA CMFLG
       BRU RESET  ERFLG MAY HAVE BEEN SET IN READ ROUTINE
IN2    LRSH 8
       CIO COMFL
       SKE =155B
       BRU *+2
       BRU CHK1  1 CHAR. SEE IF IT IS Q OR ?
       LRSH 8
       CIO COMFL
       SKE =155B
       BRU *+2
       BRU ERR  2 CHARS
       LRSH 8
IN4    CIO COMFL
       SKE =155B
       BRU IN4  WAIT FOR CR
       LDX =CTBL-CTBLND
       CBA  MOVE COMMAND INTO 'A' REGISTER
       SKE CTBLND,2  SEARCH FOR COMMAND
       BRX *-1
       BRU* BTBLND,2  FALL THRU BRX MEANS COMMAND NOT FOUND
CHK1   CLA
       LSH 8
       SKE =61B  (Q)
       BRU *+2
       BRS 10  QUIT
       SKE =37B  (QUESTION MARK)
       BRU ERR  NOT Q OR ?
       BRU HEL
CAP    PRQ MSG1
       BRU RESET
INS    PRQ MSG2
       BRU RESET
VER    PRQ MSG3
       BRU RESET
CHA    PRQ MSG4
       BRU RESET
CRE    PRQ MSG5
       BRU RESET
QUI    BRS 10
HEL    PRQ MSG6
       BRU RESET
RUN    CLA
       STA CMFLG1  (LATER SET IF FILE NAME INPUT FROM COM FILE)
       SKN CMFLG  SKIP IF PROG CALLED FROM COM FILE
       BRU ASK1
       CIO COMFL  READ "COM" OR "TEL" FROM COM FILE (ALSO ALLOW "T")
       BRM SPCHK
       SKE =137B
       BRU *+2
       BRU ERR1  RUN WAS LAST ENTRY IN COM FILE
       SKE =155B
       BRU *+2
       BRU ERR1  CR ONLY
       LRSH 8
       CIO COMFL  2ND CHAR
       BRM SPCHK
       SKE =155B
       BRU RDCM0
       CLA
       LSH 8
       SKE =64B  (T)
       BRU ERR1
       BRU INTEL
RDCM0  LRSH 8
       CIO COMFL  3RD CHAR
       BRM SPCHK
       SKE =155B
       BRU *+2
       BRU ERR1
       LRSH 8
       CIO COMFL
       SKE =155B
       BRU *-2  WAIT FOR CR
       CBA
       SKE COM
       BRU RDCM2
       LDA =-1
       STA CMFLG1  SET CMFLG1 IF FILE NAME INPUT FROM COM FILE
       BRU RUN1
RDCM2  SKE TEL
       BRU ERR1
INTEL  CLA
       STA COMFL  WILL LATER RESET USING COMFL1
ASK1   PRQ MSG7  REQUEST INPUT SOURCE
RUN1   LDA COMFL
       BRS 62  OPEN FILE FOR INPUT
       BRU ERR2  COULDNT OPEN FILE
       SKE =0  SKIP IF INPUT FILE IS TEL
       BRU PNCHK
       LDA =-1
       STA RDFLG  SET RDFLG IF INPUT FROM TEL
       BRU OPEND
PNCHK  XAB   FILE TYPE INTO A TO CHECK IT, FILE NO. INTO B
       SKE =3
       BRU ERR4  FILE NOT SYMBOLIC
       STB INFL
       CXA
       SKG =1377B
       BRU *+3
       SUB =1400B
       BRU *-3
       STA INLBSZ  INFL SIZE MOD 1400B
       CLA
       STA RDFLG
OPEND  CIO COMFL  GET INPUT FILE TERMINATOR OUT OF INPUT BUFFER
       SKN CMFLG1  FN INPUT FROM COM FILE?
ASK2   PRQ MSG8  REQUESTS OUTPUT FILE
       LDA COMFL
       LDX =3
       BRS 63  OPEN FILE FOR OUTPUT
       BRU ERR5  CANNOT OPEN OUTPUT FILE
       SKE =1  FILE NUMBER
       BRU RDCHK
       SKN RDFLG  NEG. IF INPUT FROM TEL
       BRU OPEND1  NO ERROR. FILE IN, FILE OUT.
       BRU ERR3  TEL IN, TEL OUT
RDCHK  SKN RDFLG
       BRU ERR3  FILE IN, FILE OUT
       STA OUTFL  NO ERROR. TEL IN, FILE OUT.
*FINISHED OPENING INPUT AND OUTPUT SOURCES AND CHECKING FOR ERRORS.
*NOW ASK FOR TABLE FILE NAME.
OPEND1 LDA COMFL1
       STA COMFL
       CLA
       STA OPTFLG  SET LATER IF LF OPTION AFTER FN IS TAKEN
       SKN CMFLG  SKIP IF PROGRAM CALLED FROM COM FILE
ASK3   PRQ MSG9  REQUESTS NAME OF TABLE FILE
*USE STRING PTRS & CHECK TERMINATOR (CAR. RETURN OR LINE FEED?).
       LDA FPTR  ALWAYS 3*FN-1. WCI INCREMENTS END PTR
       STA FPTR+1
*LEADING CHARACTER INPUT:
       CIO COMFL
       BRM SPCHK  IGNORE LEADING SPACES
       SKE =155B
       BRU *+2
       BRU OPTBL  WILL YIELD ERROR MESSAGE
       SKE =152B
       BRU *+2
       BRU OPTBL  WILL YIELD ERROR MESSAGE
       SKE =137B
       BRU *+2
       BRU ERR11  INSUFFICIENT INFO IN COMMAND FILE
*NON-LEADING CHARACTER INPUT & STORE
FNSTOR WCI FPTR
       CIO COMFL
       SKE =155B
       BRU *+2
       BRU OPTBL
       SKE =152B
       BRU FNSTOR
*SET FLAG. BEFORE ASKING OPTION QUESTION, SEE IF TABLE FILE CAN
*BE OPENED.
       LDA =-1
       STA OPTFLG
OPTBL  LDP FPTR
       BRS 64  OPEN FILE FOR INPUT
       BRU ERR6  CANNOT OPEN TABLE FILE
       XAB   MOVE FILE TYPE TO A TO CHECK IT, MOVE FILE NO. TO B
       SKE =3
       BRU ERR7  TABLE FILE NOT SYMBOLIC
       STB TBFL
       STX TBFLSZ
*NOW ASK OPTION QUESTION IF LINE FEED WAS TYPED AFTER TABLE FILE NAME
       SKN OPTFLG  SKIP IF LF TERMINATOR
       BRU RDTBL
       SKN RDFLG  SKIP IF INPUT FROM TEL
       BRU OPTBL1
       SKN CMFLG
       PRQ MSG91  DO YOU WANT TO CONVERT RUBOUTS?
       BRU ANSCHK
OPTBL1 SKN CMFLG
       PRQ MSG92  WANT TO CONVERT MULT BLANK CHARACTER?
ANSCHK BRM ANSRD  SKIP IF YES REPLY
       MIN OPTFLG  ANSWER WAS NO. UNSET FLAG.
*READ IN CONTENTS OF TABLE FILE
RDTBL  LDA =3B4   LIMIT OF TABLE FILE LENGTH
       LDX =ITBL
       BIO TBFL
       NOP
       LDA BIPTR
       STA IPTR  INITIALIZE BEGINNING STRING PTR
       ADD TBFLSZ
       STA IPTR+1
*ZERO OUT TBL
       CLA
       LDX =-256
       STA TBL+256,2
       BRX *-1
*EXTRACT AND STORE ENTRIES FROM TABLE FILE INPUT
       LDA =-1
       STA TFLG INIT TO "ENTRY NOT WAITING TO BE STORED"
       CLA
       STA CNT  NO. OF ENTRIES STORED
       LDA =TBL-1
       STA PTR
NXNUM  CLA
       STA HOLD
       LDX =-3
NXCH   GCI IPTR  INCREMENTS BEGINNING PTR
       BRU END
*TEST FOR 137 IN CASE FILE WAS WRITTEN INCORRECTLY AND CHARACTER COUNT
*INCLUDES 137'S IN LAST WORD
       SKE =137B
       BRU *+2
       BRU END
       SKE =135B
       BRU NXCH1
       GCI IPTR
       NOP
       BRU TRMCH
NXCH1  SKG =31B
       SKG =17B
       BRU TRMCH
       SUB =20B
       XMA HOLD
       CLB
       STB TFLG
       LSH 3
       ADM HOLD
       BRX NXCH
       BRU STORE
TRMCH  SKN TFLG  SKIP IF ENTRY NOT WAITING TO BE STORED (MULT TERM CHAR)
       BRU *+2
       BRU NXCH
STORE  BRM STCNT
       BRU PRMSG  HERE IF EXCEEDED MAX. TABLE LENGTH
       LDA =-1  HERE IF STORED ENTRY (TABLE LENGTH OK)
       STA TFLG
       BRU NXNUM
END    SKN TFLG
       BRU *+2
       BRU CHK
       BRM STCNT  SKIP IF ENTRY IS STORED (TABLE LENGTH OK)
PRMSG  PRQ ERMS12  TABLE LENGTH EXCEEDS MAX. LENGTH, ONLY 1ST 256 READ
*FINISHED SETTING UP TABLE FILE ENTRIES. BRANCH TO PUNCH OR READ ROUTINE
CHK    SKN RDFLG
       BRU PUNCH
*READ TAPE INPUT AND SET UP STRING PTRS
       LDA =ITBL-1
       STA IPTR
       PRQ MSG10  TURN ON READER
       LDX =-1
       LDA =40000400B
       BRS 12  SET 8 LEVEL INPUT
       LDX =-1
       BRS 13  SKIP IF INPUT BUFFER EMPTY
       BRU *+2
       BRU *-2
BGNRD  CLB
       LDA =2
       STA DIFF
       BRM RDSUB
       LSH 16
       STA HOLD
       CLA
       STA DIFF
       BRM RDSUB
       LSH 8
       ADM HOLD
       LDA =1
       STA DIFF
       BRM RDSUB
       ADD HOLD
       MIN IPTR
       STA* IPTR
       BRU BGNRD
ENDRD  LDX =-1
       LDA =2
       BRS 12  TERMINATE 8 LEVEL INPUT
       LDA DIFF
       SKE =2  IS 2 IF WE FILLED (& STORED) LAST WORD
       BRU *+2
       BRU ENDRD1
       LDA HOLD
       MIN IPTR
       STA* IPTR  STORE LAST WORD
ENDRD1 LDA IPTR
       MUL =3
       LSH 23
       ADD DIFF
       STA IPTR+1  END STRING PTR TO TAPE INPUT
       LDA BIPTR
       STA IPTR  CHANGE IPTR FROM END WD PTR TO BEGINNING STR PTR
*BEGIN CONVERSION PROCESS
       CLA
       STA ERFLG  SET LATER IF CODE NOT FOUND IN TABLE
       STA CNT1  NO. OF CHARACTERS WRITTEN
       LDA BOPTR
       STA OPTR  INIT BEGINNING PTR
SRCH   LDA =1377B
       STA BCTR
       LDA BOPTR
       STA OPTR+1  REINIT END PTR
SRCH1  GCI IPTR  GET CHARACTER OF TAPE INPUT
       BRU COUNT
       CLX
SRCH2  SKE TBL,2
       BRU *+2
       BRU MTCH
       XXA
       SKE CNT  ARE WE AT TABLE END YET?
       BRU *+2  NO
       BRU NOMTCH  YES
       ADD =1
       XXA
       BRU SRCH2
MTCH   CXA
       WCI OPTR
       SKR BCTR
       BRU SRCH1
       LDA =256  HAVE FILLED OTBL
       LDX =OTBL
       BIO OUTFL
       NOP
       MIN CNT1  COUNT NO. OF FULL BLOCKS WRITTEN
       BRU SRCH
*SET ERROR FLAG AND STORE CODE NOT FOUND IN TABLE. (PRINT ERROR
*MESSAGE AFTER WRITING OUT ALL CONVERTED CHARS THUS FAR NOT WRITTEN
NOMTCH LDA =-1
       STA ERFLG
       STX DIFF  CAN'T USE HOLD SINCE HOLD IS USED AT CONVND
       BRU CONVND
*CALCULATE NO. OF CHARS. WRITTEN
COUNT  LDA CNT1  NO. OF FULL BLOCKS WRITTEN
       MUL =1400B
       LSH 23
       ADD OPTR+1
       SUB BOPTR
       STA CNT1  TOTAL NO. OF CHARS. WRITTEN
*WRITE OUT CONVERTED CHARS REMAINING IN OTBL.
CONVND LDA OPTR+1  LOC OF LAST CONV CHAR WRITTEN IN OTBL
       RSH 23
       DIV =3
       STB HOLD
       SUB =OTBL  BIO UP TO WD BEFORE LAST WD WRITTEN INTO OTBL
       LDX =OTBL
       BIO OUTFL
       NOP
       COPY AX,A  ADDR OF LAST WD WRITTEN INTO OTBL (1,2 OR 3 CHARS IN IT)
       LDB 0,2
       LSH 8
       CIO OUTFL
       SKR HOLD  0 IF 1 CHAR LEFT, 1 IF 2, 2 IF 3
       BRU *-3
       SKN ERFLG
       BRU *+2
       BRU ERR9
       PRQ MSG11 NO. OF CHARS. WRITTEN IS...
       LDA CNT1
       LDB =10
       LDX =1
       BRS 36  PRINT CHAR. COUNT
       BRS 147
       BRU RESET
*PUNCH ROUTINE
PUNCH  LDP BTPTR
       STP TPTR  (RE)INITIALIZE TITLE PTR
       SKN CMFLG
       PRQ MSG12  REQUEST TITLE
INTL   CIO COMFL
       SKG =77B
       BRU TSTORE
       SKE =155B
       BRU *+2
       BRU ENTL  TERMINATES ON CR
       SKE =137B  END OF COM FILE HIT BEFORE TITLE
       BRU INTL  IGNORES OTHER CTRL CHARS
       BRU ERR11
TSTORE WCI TPTR
       BRU INTL
ENTL   PRQ MSG13  TURN ON PUNCH
       CIO =0
       SKE =155B
       BRU *-2
*PUNCH RUBOUTS, TITLE (IF ANY), & MORE RUBOUTS
       LDX =-1
       BRS 14  DISMISS UNTIL OUTPUT BUFFER EMPTY
       BRS 85  SET 8 LEVEL OUTPUT
       LDX =-30
       BRM LDR
       GCI TPTR
       BRU OUTND1  HERE IF NO TITLE SPECIFIED
OUTL   TCO =0
       TCO =0
       MUL =3
       LSH 23
       ADD =CHTB
       MUL =3
       LSH 23
       SUB =1
       STA CPTR  SET BEGINNING PTR FOR CHARACTER
OUTL1  GCI CPTR
       NOP 0  WON'T FALL THRU
       SKG =177B  SKIP IF FINISHED PUNCHING CHARACTER
       BRU OUTL2
       GCI TPTR
       BRU OUTND  HERE WHEN FINISHED PUNCHING TITLE
       BRU OUTL
OUTL2  CIO =1
       BRU OUTL1
OUTND  TCO =0
       TCO =0
OUTND1 LDX =-50
       BRM LDR
*CONVERT AND PUNCH FILE CONTENTS
       CLA
       STA TFLG
       LDA BOPTR
       ADD =1400B
       STA OPTR+1  RESET TO LAST CHAR IN OTBL. NOT CHANGED BY GCI.
NXBLK  LDA BOPTR
       STA OPTR RESET TO BEGINNING OF OTBL
       LDA =256
       LDX =OTBL
       BIO INFL
       BRU EOF  HERE IF HIT END OF FILE
NX1    GCI OPTR  HERE IF READ 256 WORDS
       BRU NXBLK  HAVE CONVERTED & PUNCHED ENTIRE BLOCK
       BRM CPSUB
       BRU NX1
EOF    LDA BOPTR
       ADD INLBSZ
       STA OPTR+1
NX2    GCI OPTR
       BRU ENDP
       BRM CPSUB
       BRU NX2
*PUNCH TRAILER
ENDP   LDX =-60
       BRM LDR
       BRS 147
       LDX =-1
       BRS 14  DISMISS UNTIL OUTPUT BUFFER EMPTY
       BRS 86  CLEAR 8 LEVEL OUTPUT
       BRU RESET
*POP TO PRINT A MESSAGE
PRQPOP EAX* 0
       CXA
       ETR =37777B
       LDB =-1
       LDX =1
       BRS 34
       BRR 0
*SUBROUTINE TO IGNORE SPACES. MUST BE GIVEN IMMEDIATELY AFTER CIO.
*RETURNS AS USUAL IF CHAR ISN'T SPACE. RETURNS TO INSTRUCTION RIGHT
*BEFORE CALL (CIO) IF CHAR IS SPACE)
SPCHK  NOP
       SKE =0
       BRU *+2
       BRU SUB
       SKE =135B
       BRR SPCHK
       CIO COMFL
SUB    LDA SPCHK
       SUB =2  CHANGES RETURN ADR FROM 1 PAST CALL TO 1 BEFORE CALL
       STA SPCHK
       BRR SPCHK
*SUBROUTINE TO READ REPLY TO RUBOUT/MULT BLANK OPTION QUESTION.
*SKIP IF YES REPLY, NO SKIP IF NO. SAME ERROR MESSAGE EXCEPT IN COM FILE
*CASE, WHEN RDFLG IS CHECKED TO DETECT PROPER MESSAGE.
ANSRD  NOP
ANSRD1 CIO COMFL  READ 1ST CHAR
       BRM SPCHK
       SKE =155B
       BRU *+2
       BRU ERR8
       SKE =137B  END OF COM FILE HIT BEFORE REPLY
       BRU *+2
       BRU ERR81
       LRSH 8
       CIO COMFL  READ 2ND CHAR
       BRM SPCHK
       SKE =155B
       BRU RNXT
       CLA
       LSH 8
       SKE =71B  (Y)
       BRU *+3
       MIN ANSRD
       BRR ANSRD
       SKE =56B  (N)
       BRU ERR8  (1 CHAR, NOT Y OR N)
       BRR ANSRD
RNXT   LRSH 8
       CIO COMFL  READ 3RD CHAR
       BRM SPCHK
       SKE =155B
       BRU RNXT1
       CLA
       LSH 16
       SKE NO
       BRU ERR8  (2 CHARS, NOT NO)
       BRR ANSRD
RNXT1  LRSH 8
       CIO COMFL  READ 4TH CHAR
       SKE =155B
       BRU ERR8  (MORE THAN 3 CHARS)
       CBA
       SKE YES
       BRU ERR8  (3 CHARS, NOT YES)
       MIN ANSRD
       BRR ANSRD
*SUBROUTINE TO CHECK TABLE LENGTH & STORE ENTRY IF TABLE LENGTH OK
*(MAX.=256 ENTRIES) IF TABLE LENGTH OK, WILL SKIP RETURN. IF TABLE
*LENGTH EXCEEDS MAX., NO SKIP RETURN
STCNT  NOP
       LDA CNT  NO. OF ENTRIES ALREADY STORED
       SKE =256
       BRU *+2
       BRR STCNT  NO SKIP RETURN IF TABLE EXCEEDS MAX. LENGTH
       MIN CNT
       LDA HOLD
       MIN PTR
       STA* PTR
       MIN STCNT
       BRR STCNT  SKIP RETURN IF TABLE LENGTH OK
*SUBROUTINE TO SEE IF INPUT BUFFER IS EMPTY AND DISMISS FOR 3 SECS IF
*IT IS. IF EMPTY FOR 6 SECS, STOPS TAPE READING. OTHERWISE READS A
*CHARACTER (IGNORES RUBOUTS IF REQUIRED)
RDSUB  NOP
       LDX =-1
MTCHK  BRS 13   SKIP IF INPUT BUFFER EMPTY
       BRU MTCHK1  INPUT BUFFER NOT EMPTY
       LDA TFLG
       SKE =2  WILL BE 2 AFTER 6 SECS OF NO INPUT
       BRU *+2
       BRU ENDRD
       MIN TFLG
       LDA =3000
       TCO =161B  CTRL Q (TURN ON RDR FOR SOME TTY'S)
       BRS 81  DISMISS (FOR 3 SECS)
       TCO =163B  CTRL S (TURN OFF RDR FOR SOME TTY'S)
       BRU MTCHK
MTCHK1 CLA
       STA TFLG
       CIO =0
       SKN OPTFLG  SKIP IF CONVERT RUBOUTS
       BRU *+2  HERE IF IGNORE RUBOUTS
       BRR RDSUB  RETURN & STORE CHAR READ
       SKE =377B
       BRU *+2
       BRU MTCHK
       SKE =177B
       BRR RDSUB
       BRU MTCHK
*SUBROUTINE TO PUNCH LEADER/TRAILER. NEGATIVE OF NUMBER OF RUBOUTS
*TO BE PUNCHED MUST BE IN X REGISTER
LDR    NOP
       TCO =377B
       BRX *-1
       BRR LDR
*SUBROUTINE TO EXAMINE CHAR IN A REGISTER & CONVERT IT & PUNCH IT
*UNLESS TABLE ENTRY IS 400.  HANDLES 135'S AS REQUIRED.
CPSUB  NOP
       SKN OPTFLG  SKIP IF 135'S ARE TO BE CONVERTED
       BRU MBLNK  135 IS MULT BLANK CHAR
CPSUB1 CAX
       LDA TBL,2
       SKE =400B
       CIO =1
       BRR CPSUB
MBLNK  SKN TFLG  SKIP IF LAST BLOCK ENDED WITH MULT BLANK CHAR
       BRU MBCHK
       MIN TFLG
       BRU MBLNK2
MBCHK  SKE =135B
       BRU CPSUB1
       GCI OPTR
       BRU SET  MULT BLANK CHAR IS LAST CHAR IN BLOCK
MBLNK2 CNA   BLANK COUNT IS IN A REGISTER
       CAX
       LDA TBL
       SKE =400B
       BRU *+2
       BRR CPSUB
       CIO =1
       BRX *-1
       BRR CPSUB
SET    LDA =-1
       STA TFLG  FIRST CHAR OF NEXT BLOCK IS MULT BLANK COUNT
       BRR CPSUB
*SUBROUTINE USED IN ERR2 TO ERR5 (INPUT FROM/OUTPUT TO ERRORS)
*CLOSES ALL FILES & RETURNS TO EXEC IF FN INPUT FROM COMFL.
*CLEARS INPUT BUFFER AND RETURNS (BRR) IF FN INPUT FROM COMFL.
ERCHK  NOP
       SKN CMFLG1
       BRU *+3
       BRS 17
       BRS 10
       LDX =-1
       BRS 11
       BRR ERCHK
*ERROR ROUTINES AND MESSAGES:
*ILLEGAL COMMAND ENTERED AFTER COLON
ERR    SKN CMFLG
       BRU ERR0
       PRQ ERMSG1
       BRS 17  CLOSES ALL FILES, INCL. COM FILE
       BRS 10
ERR0   LDA ERFLG
       SKE =0
       BRU ERR01
       MIN ERFLG  INDICATE NEXT CONSEC ERROR SHOULD PRINT COM LIST
       PRQ ERMSG  PRINT ? AND CR
       BRU GLTCH
ERR01  PRQ ERMSG0
       BRU RESET
*"COM" OR "TEL" OR "T" NOT IN COMMAND FILE
ERR1   PRQ ERMSG2
       BRS 17
       BRS 10
*END OF COM FILE HIT PREMATURELY. INSUFFICIENT  INFO IN COM FILE.
ERR11  PRQ ERM11
       BRS 17
       BRS 10
*CANNOT OPEN INPUT FILE
ERR2   PRQ ERMSG3
       BRM ERCHK
       BRU ASK1
*INCORRECT COMBINATION ERROR
ERR3   PRQ ERMSG4
ERR31  BRM ERCHK
       BRS 147  CLOSE FILE(S) EXCEPT COMMAND FILE
       BRU ASK1
*FILE NOT SYMBOLIC
ERR4   PRQ ERMSG5
       BRU ERR31
*CANNOT OPEN OUTPUT FILE
ERR5   PRQ ERMSG6
       BRM ERCHK
       BRU ASK2
*CANNOT OPEN TABLE FILE
ERR6   PRQ ERMSG7
ERR61  SKN CMFLG
       BRU ERR62
       BRS 17
       BRS 10
ERR62  LDX =-1
       BRS 11
       BRU ASK3
*TABLE FILE NOT SYMBOLIC
ERR7   PRQ ERMSG5
       BRU ERR61
*INCORRECT REPLY TO RUBOUT/MULT BLANK QUESTION
ERR8   SKN CMFLG
       BRU ERR82
ERR81  PRQ ERMSG9  ERR0R. TYPE YES OR NO IN REPLY TO:
       SKN RDFLG
       BRU *+3
       PRQ MSG91  RUBOUT QUESTION
       BRU *+2
       PRQ MSG92  MULT BLANK QUESTION
       BRS 17
       BRS 10
ERR82  LDX =-1
       BRS 11
       PRQ ERMSG8
       BSRD1
*CODE NOT FOUND IN TABLE
ERR9   PRQ ERMS10  ERROR. CODE...
       LDA DIFF
       LDB =8
       LDX =1
       BRS 36
       PRQ ERMS11  CANNOT BE FOUND IN TABLE.
       SKN CMFLG
       BRU *+3
       BRS 17
       BRS 10
       BRS 147
       BRU RESET
ERMSG  ASC '$ ?$$$/'
ERMSG0 ASC '$FOR ASSISTANCE, TYPE  HELP.$/'
ERMSG1 ASC '$ILLEGAL COMMAND.$/'
ERM11  ASC '$ERROR. INSUFFICIENT INFORMATION IN COMMAND FILE.$/'
ERMSG2 ASC '$AFTER CALLING CONFILE FROM A COMMAND FILE AND GIVING THE RUN COMMAND,'
       ASC '$TYPE "COM" (FOLLOWED BY A CARRIAGE RETURN) IF THE "INPUT FROM"'
       ASC '$AND "OUTPUT TO" REPLIES ARE IN THE COMMAND FILE, AND "T"'
       ASC '$IF THEY ARE TO BE ENTERED FROM THE TERMINAL.$/'
ERMSG3 ASC '$ERROR. CANNOT OPEN INPUT FILE.$/'
ERMSG4 ASC '$ERROR. TO PUNCH TAPE, SPECIFY A FILE FOR INPUT AND T FOR OUTPUT.'
       ASC '$TO READ TAPE, SPECIFY INPUT FROM T AND OUTPUT TO A FILE.$/'
ERMSG5 ASC '$ERROR. FILE MUST BE SYMBOLIC.$/'
ERMSG6 ASC '$ERROR. CANNOT OPEN OUTPUT FILE.$/'
ERMSG7 ASC '$ERROR. CANNOT OPEN TABLE FILE.$/'
ERMSG8 ASC '$ERROR. TYPE YES OR NO: /'
ERMSG9 ASC '$ERROR. TYPE YES OR NO IN THE COMMAND FILE IN REPLY TO: $/'
ERMS10 ASC '$ERROR. CODE /'
ERMS11 ASC ' CANNOT BE FOUND IN TABLE.$/'
ERMS12 ASC '$TABLE EXCEEDS MAXIMUM LENGTH. ONLY FIRST 256 ENTRIES HAVE BEEN READ.$/'
MSG1   ASC '$3.5 MINUTES OF PRINTOUT'
       ASC '$$THIS PROGRAM MAY BE USED TO PERFORM FILE-TO-TAPE CONVERSION OR TAPE-TO-'
       ASC '$FILE CONVERSION, SPECIFIED BY A TABLE WHICH THE USER ENTERS FROM A'
       ASC '$FILE.'
       ASC '$$CONFILE IS MORE FLEXIBLE FOR FILE-TO-TAPE CONVERSION; IT IS DESIGNED'
       ASC '$MORE FOR THE USER WHO STARTS OUT WITH A FILE TO BE CONVERTED THAN'
       ASC '$FOR THE USER WITH TAPE TO BE CONVERTED. (THE TAPE-TO-FILE CAPABILITY'
       ASC '$IS IMPLEMENTED MAINLY SO THAT A TAPE PRODUCED BY CONFILE CAN BE READ'
       ASC '$BACK IN USING THE SAME TABLE.) CONSIDER THE FOLLOWING FEATURES OF'
       ASC '$CONFILE:'
       ASC '$$            FILE-TO-TAPE                        TAPE-TO-FILE'
       ASC '$             (PUNCHING)                          (READING)'
       ASC '$$SEVERAL DIFFERENT FILE CHAR-              SEVERAL DIFFERENT TAPE CODES'
       ASC '$ACTERS CAN BE PUNCHED AS THE      BUT     CANNOT BE STORED AS THE SAME'
       ASC '$SAME TAPE CODE.                           FILE CHARACTER.'
       ASC '$$ANY NUMBER OF DIFFERENT FILE              ONLY RUBOUTS ON THE TAPE CAN'
       ASC '$CHARACTERS CAN BE IGNORED.        BUT     BE IGNORED.'
       ASC '$$NO "ERROR CHECKING"                       "ERROR CHECKING" IS PERFORMED,'
       ASC '$(SEE ADJACENT COLUMN)             BUT     SINCE PROGRAM EXECUTION TERM-'
       ASC '$                                          INATES IF A TAPE CODE IS READ'
       ASC '$                                          THAT IS NOT IN THE TABLE.'
       ASC '$$SOME ADDITIONAL FEATURES ARE LISTED BELOW.'
       ASC '$$DURING PUNCHING, A TITLE OF READABLE CHARACTERS MAY BE PUNCHED AT THE'
       ASC '$BEGINNING OF THE TAPE. RUBOUTS ARE PUNCHED BEFORE THE TITLE (IF ANY),'
       ASC '$AND BEFORE AND AFTER THE CONVERTED OUTPUT.'
       ASC '$$DURING READING, THE PROGRAM TYPES A CONTROL Q OR CONTROL S EVERY 3'
       ASC '$SECONDS TO FURTHER REGULATE THE TAPE READING ON THOSE TERMINALS WHICH'
       ASC '$HAVE X ON AND X OFF ENABLED (WHERE CONTROL Q TURNS ON THE TAPE READER'
       ASC '$AND CONTROL S TURNS IT OFF). ON TERMINALS WHICH DO NOT HAVE THIS'
       ASC '$FEATURE, THE EMISSION OF CONTROL Q AND CONTROL S WILL HAVE ABSOLUTELY'
       ASC '$NO EFFECT ON THE TAPE READING.$/'
MSG2   ASC '$4.5 MINUTES OF PRINTOUT'
       ASC '$$NOTE: THE INSTRUCTIONS LISTED BELOW ARE MINIMAL; MORE DETAILED'
       ASC '$DOCUMENTATION MAY BE OBTAINED FROM YOUR TYMSHARE MARKETING'
       ASC '$REPRESENTATIVE.'
       ASC '$$THIS PROGRAM MAKES TWO REQUESTS INITIALLY:'
       ASC '$$INPUT FROM'
       ASC '$OUTPUT TO'
       ASC '$$TO SPECIFY FILE-TO-TAPE CONVERSION, TYPE THE INPUT FILE NAME AFTER'
       ASC '$"INPUT FROM", AND TYPE T (INDICATING THE TERMINAL) AFTER "OUTPUT TO".'
       ASC '$$TO SPECIFY TAPE-TO-FILE CONVERSION, TYPE T AFTER "INPUT FROM", AND'
       ASC '$TYPE THE OUTPUT FILE NAME AFTER "OUTPUT TO".'
       ASC '$$THE PROGRAM NEXT REQUESTS THE TABLE FILE NAME.'
       ASC '$$***WHEN FILE-TO-TAPE CONVERSION IS SPECIFIED:'
       ASC '$$FOLLOW THE TABLE FILE NAME BY A CARRIAGE RETURN IF THE FILE CHARACTER'
       ASC '$WHOSE CODE IS 135 OCTAL IS TO BE CONSIDERED A MULTIPLE BLANK'
       ASC '$CHARACTER (THIS IS A CONVENTION OF THE TYMSHARE LANGUAGES).'
       ASC '$IN SPECIAL CASES WHERE 135 SHOULD BE PROCESSED AS ANY ORDINARY DATA'
       ASC '$CHARACTER, TYPE A LINE FEED AFTER THE TABLE FILE NAME. THE PROGRAM'
       ASC '$WILL THEN ASK "DO YOU WANT TO CONVERT THE MULTIPLE BLANK CHARACTER?".'
       ASC '$CONFIRM BY REPLYING WITH YES (OR Y) FOLLOWED BY A CARRIAGE RETURN.'
       ASC '$NO (OR N) WOULD ABORT THE OPTION.'
       ASC '$$THE TITLE IS THEN REQUESTED. REPLY WITH A CARRIAGE RETURN IF NO'
       ASC '$TITLE IS DESIRED, OR TYPE THE TITLE FOLLOWED BY A CARRIAGE RETURN. IF'
       ASC '$NECESSARY, A LINE FEED MAY BE TYPED TO CONTINUE THE TITLE ON THE NEXT'
       ASC '$LINE.'
       ASC '$$***WHEN TAPE-TO-FILE CONVERSION IS SPECIFIED:'
       ASC '$$FOLLOW THE TABLE FILE NAME BY A CARRIAGE RETURN IF RUBOUTS (CODES'
       ASC '$377 AND 177 OCTAL) ON THE TAPE ARE TO BE IGNORED. IN SPECIAL CASES'
       ASC '$WHERE RUBOUTS SHOULD BE PROCESSED AS ANY ORDINARY DATA CHARACTERS,'
       ASC '$TYPE A LINE FEED AFTER THE TABLE FILE NAME. THE PROGRAM WILL THEN ASK'
       ASC '$"DO YOU WANT TO CONVERT RUBOUTS?". CONFIRM BY REPLYING WITH YES (OR Y)'
       ASC '$FOLLOWED BY A CARRIAGE RETURN. NO (OR N) WOULD ABORT THE OPTION.'
       ASC '$$THE PROGRAM WILL TELL YOU WHEN TO TURN ON THE TAPE READER. EITHER'
       ASC '$TURN OFF THE READER WHEN THE RUBOUT TRAILER IS ENCOUNTERED OR,'
       ASC '$IF YOU LET THE TAPE BE READ TO ITS END, BE SURE THERE ARE NO "JUNK"'
       ASC '$CHARACTERS ON THE END (TRIM THE TAPE EVENLY ON ONE OF THE TRAILING '
       ASC '$RUBOUTS). THE PROGRAM WILL STOP ACCEPTING TAPE INPUT AFTER THERE HAS'
       ASC '$BEEN NO FURTHER INPUT FOR 6 SECONDS.'
       ASC '$$***WHEN THE PROGRAM IS CALLED FROM A COMMAND FILE:'
       ASC '$$THE "INPUT FROM" AND "OUTPUT TO" REPLIES MAY BE ENTERED FROM'
       ASC '$THE TERMINAL OR FROM THE COMMAND FILE. (OTHER REPLIES, SUCH AS'
       ASC '$TO THE TABLE FILE NAME REQUEST, ARE TAKEN FROM THE COMMAND FILE).'
       ASC '$AFTER TYPING THE PROGRAM NAME AND THE RUN COMMAND, TYPE COM'
       ASC '$(FOLLOWED BY A CARRIAGE RETURN) IN THE COMMAND FILE IF THE "INPUT'
       ASC '$FROM" AND "OUTPUT TO" REPLIES WILL BE ENTERED IN THE COMMAND FILE;'
       ASC '$TYPE T IF THEY ARE TO BE ENTERED FROM THE TERMINAL.$/'
MSG3   ASC '$VERSION 2    SEPTEMBER 1970$/'
MSG4   ASC '$NO PREMIUM CHARGE$/'
MSG5   ASC '$WRITTEN BY TYMSHARE$/'
MSG6   ASC '$LEGAL COMMANDS:'
       ASC '$$     HELP  (OR) ?   REPRINTS THIS LIST'
       ASC '$     CAPABILITIES   DESCRIBES PROGRAM CAPABILITIES'
       ASC '$     INSTRUCTIONS   HOW TO EXECUTE THE PROGRAM'
       ASC '$     CREDITS        THOSE RESPONSIBLE FOR THIS PROGRAM'
       ASC '$     CHARGES        ADDITIONAL COST (IF ANY)'
       ASC '$     VERSION        LATEST UPDATE'
       ASC '$     RUN            BEGINS EXECUTION'
       ASC '$     QUIT  (OR) Q   QUITS TO EXEC'
       ASC '$$     ANY OF THESE COMMANDS MAY BE SHORTENED TO THE'
       ASC '$     FIRST THREE LETTERS$/'
MSG7   ASC '$INPUT FROM /'
MSG8   ASC '$OUTPUT TO /'
MSG9   ASC '$NAME OF TABLE FILE: /'
MSG91  ASC 'DO YOU WANT TO CONVERT RUBOUTS? /'
MSG92  ASC 'DO YOU WANT TO CONVERT THE MULTIPLE BLANK CHARACTER? /'
MSG10  ASC '$TURN ON READER.$$/'
MSG11  ASC '$$NUMBER OF CHARACTERS WRITTEN IS /'
MSG12  ASC '$TITLE: /'
MSG13  ASC '$TURN ON PUNCH.'
       ASC '$THEN TYPE CARRIAGE RETURN.$/'
CTBL   ASC 'PAC'
       ASC 'SNI'
       ASC 'REV'
       ASC 'AHC'
       ASC 'ERC'
       ASC 'IUQ'
       ASC 'LEH'
       ASC 'NUR'
CTBLND DATA 0
       DATA CAP
       DATA INS
       DATA VER
       DATA CHA
       DATA CRE
       DATA QUI
       DATA HEL
       DATA RUN
BTBLND DATA ERR
COM    ASC 'MOC'
TEL    ASC 'LET'
NO     ASC ' ON'
YES    ASC 'SEY'
CHTB   DATA      200B   
       DATA        0B
       DATA        0B
       DATA 27700000B  !
       DATA        0B
       DATA        0B
       DATA  1600007B  "
       DATA 40000000B
       DATA        0B
       DATA 13016054B  #
       DATA  7406416B
       DATA  3300000B
       DATA 11021177B  $
       DATA 12411200B
       DATA        0B
       DATA 20020020B  %
       DATA 32661405B
       DATA   600600B
       DATA 14446505B  &
       DATA 12410050B
       DATA 20100000B
       DATA  1700000B  '
       DATA        0B
       DATA        0B
       DATA  7021101B  (
       DATA 40000000B
       DATA        0B
       DATA 20221034B  )
       DATA 40000000B
       DATA        0B
       DATA 22426030B  *
       DATA 37414054B
       DATA 22500000B
       DATA  2004074B  +
       DATA  2004200B
       DATA        0B
       DATA 24030200B  ,
       DATA        0B
       DATA        0B
       DATA  2004010B  -
       DATA  2004200B
       DATA        0B
       DATA 20100000B  .
       DATA        0B
       DATA        0B
       DATA 20020020B  /
       DATA  2000004B
       DATA   500000B
       DATA 17440501B  0
       DATA 20237200B
       DATA        0B
       DATA 20477500B  1
       DATA 40000000B
       DATA        0B
       DATA 30450521B  2
       DATA 22243200B
       DATA        0B
       DATA 10244515B  3
       DATA 22630600B
       DATA        0B
       DATA  2006012B  4
       DATA 37604200B
       DATA        0B
       DATA 13644511B  5
       DATA 22230600B
       DATA        0B
       DATA 17444511B  6
       DATA 22231200B
       DATA        0B
       DATA   260421B  7
       DATA  2202403B
       DATA 40000000B
       DATA 15444511B  8
       DATA 22244466B
       DATA 40000000B
       DATA 21444511B  9
       DATA 22244476B
       DATA 40000000B
       DATA 11100000B  :
       DATA        0B
       DATA        0B
       DATA 25032200B  ;
       DATA        0B
       DATA        0B
       DATA  2010044B  <
       DATA 20500000B
       DATA        0B
       DATA  3006014B  =
       DATA  3006200B
       DATA        0B
       DATA 20422020B  >
       DATA  2100000B
       DATA        0B
       DATA   400531B  ?
       DATA   203200B
       DATA        0B
       DATA 17041131B  @
       DATA 25256521B
       DATA 23440200B
       DATA 37404411B  A
       DATA  2277200B
       DATA        0B
       DATA 37644511B  B
       DATA 22233200B
       DATA        0B
       DATA 17440501B  C
       DATA 20221200B
       DATA        0B
       DATA 37640501B  D
       DATA 20237200B
       DATA        0B
       DATA 37644511B  E
       DATA 22244600B
       DATA        0B
       DATA 37604411B  F
       DATA  2204600B
       DATA        0B
       DATA 17440501B  G
       DATA 24231020B
       DATA 40000000B
       DATA 37604010B  H
       DATA  2077600B
       DATA        0B
       DATA 20240577B  I
       DATA 20240600B
       DATA        0B
       DATA 10240501B  J
       DATA 17600401B
       DATA 40000000B
       DATA 37604024B  K
       DATA 10440600B
       DATA        0B
       DATA 37640100B  L
       DATA 20040200B
       DATA        0B
       DATA 37601004B  M
       DATA  2002002B
       DATA 37700000B
       DATA 37601004B  N
       DATA  2010040B
       DATA 37700000B
       DATA 17440501B  O
       DATA 20237200B
       DATA        0B
       DATA 37604411B  P
       DATA  2203200B
       DATA        0B
       DATA 17440501B  Q
       DATA 30277100B
       DATA 40000000B
       DATA 37604431B  R
       DATA 12243200B
       DATA        0B
       DATA 11444511B  S
       DATA 22231200B
       DATA        0B
       DATA   200577B  T
       DATA   200600B
       DATA        0B
       DATA 17640100B  U
       DATA 20037600B
       DATA        0B
       DATA  3610040B  V
       DATA 20020020B
       DATA  3700000B
       DATA 17640040B  W
       DATA  4020100B
       DATA 17700000B
       DATA 20221024B  X
       DATA  2012042B
       DATA 20300000B
       DATA   201004B  Y
       DATA 36002002B
       DATA   300000B
       DATA 30250511B  Z
       DATA 21241501B
       DATA 40000000B
       DATA 37640501B  [
       DATA 40000000B
       DATA        0B
       DATA   402000B  \
       DATA  2010040B
       DATA 20100000B
       DATA 20240577B  ]
       DATA 40000000B
       DATA        0B
       DATA  1001177B  ^
       DATA   402200B
       DATA        0B
       DATA  2014054B  _
       DATA  2004010B
CHTBND DATA  2100000B
ERFLG  BSS 1
COMFL  BSS 1
COMFL1 BSS 1
CMFLG  BSS 1
CMFLG1 BSS 1
RDFLG  BSS 1
INFL   BSS 1
INLBSZ BSS 1
OUTFL  BSS 1
OPTFLG BSS 1
FN     BSS 25
FPTR   DATA 3*FN-1
       DATA 3*FN-1
TBFL   BSS 1
TBFLSZ BSS 1
ITBL   EQU 1B4
BIPTR  DATA 3*ITBL-1
IPTR   BSS 2
TFLG   BSS 1
HOLD   BSS 1
PTR    BSS 1
TBL    BSS 256
CNT    BSS 1
CNT1   BSS 1
DIFF   BSS 1
OTBL   BSS 256
BOPTR  DATA 3*OTBL-1
OPTR   BSS 2
BCTR   BSS 1
TITL   BSS 40  SPACE FOR TITLE
BTPTR  DATA 3*TITL-1
       DATA 3*TITL-1
TPTR   BSS 2
CPTR   BSS 1
       DATA 3*CHTBND+3
BPR    BRU PRQPOP
       END
 A=I¯