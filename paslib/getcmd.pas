
		    (* COMMAND PARSER *)

PROCEDURE GETCMD;
LABEL 1;
VAR CURTOK:TOKENDESC; BADLINE:BOOLEAN; I:INTEGER; SAVECMD:COMMAND;
    NEWTABS: TABARRAY; NEWTABCNT: 0..MAXTABS;
    NEWPOSN: POSARRAY;  NEWLEVNUM: LEVARRAY;
    NEWLEVCNT: 0..MAXLEVELS;  NEWLEVEL: INTEGER;
    FID: FILE_ID;
    TIDX: CMDLINEIDX;
    JOB_ID: JOB_NUM_STRING;
    ENTRY_FILE_NAME: FILE_NAME;

  PROCEDURE ERROR;
  VAR LNUM:LINENUM; LCNT:INTEGER;
  BEGIN
    IF NOT BADLINE THEN
    BEGIN
      GETLNR(LNUM,LCNT);
      IF LNUM='-----' THEN WRITE(TTY,LCNT:5)
      ELSE WRITE(TTY,LNUM);
      WRITE(TTY,' ');
      WRTLINE(TTYOUTPUT,CMDLN,CMDLEN,FALSE,FALSE, MAP, TERMINAL);
      WRITELN(TTY);
      WRITELN(TTY,' ':CURTOK.TOKPOS+5,'^');
      WRITELN(TTY,'ERROR IN COMMAND');
      BREAK(TTY);
      BADLINE:= TRUE
    END
  END;						(*ERROR*)



  PROCEDURE MAKE_MAPPING;			(* handles translate command *)

    VAR
      STRINGTO,					(* domain string *)
      STRINGFROM: PSTRGDESC;			(* domain string *)


    BEGIN
      STRINGTO := NIL;
      STRINGFROM := NIL;
      WITH CURTOK DO
      IF TOKTYP = EOL THEN			(* reinitialize translation vector *)
	INIT_TABLE
      ELSE
      IF TOKTYP <> STRTOK THEN
      BEGIN
	ERROR;
	RETURN
      END
      ELSE
      BEGIN
	NEW(STRINGFROM);
	STRINGFROM^ := STRINFO;
	SCAN(CURTOK);
	IF TOKTYP <> STRTOK THEN
	BEGIN
	  ERROR;
	  RETURN
	END;
	NEW(STRINGTO);
	STRINGTO^ := STRINFO;
	IF STRINGFROM^.STRLEN < STRINGTO^.STRLEN THEN	(* first string len must be greater *)
	BEGIN
	  ERROR;
	  RETURN
	END;
	FOR I := 1 TO STRINGTO^.STRLEN DO
	  MAP[STRINGFROM^.STRVAL[I].VALUE] := STRINGTO^.STRVAL[I].VALUE
      END
    END;
  PROCEDURE GETHDRTRLR(OLDHDR:PSTRGDESC; VAR NEWHDR:PSTRGDESC);
  VAR NEWHT: PSTRGDESC;

    PROCEDURE GETAHDR(VAR P:PSTRGDESC);
    VAR JUST:JUSTYPE;

    BEGIN
      P:= NIL;
      WITH CURTOK DO
	IF NOT ((TOKTYP = EOL) OR (TOKTYP = CMD)) THEN BEGIN
	  IF TOKTYP=WRD THEN BEGIN
	    IF WRDTYP=RIGHTWD THEN JUST:= JUSRIGHT
	    ELSE IF WRDTYP=LEFTWD THEN JUST:= JUSLEFT
	    ELSE IF WRDTYP=OFFWD THEN
	    BEGIN SCAN(CURTOK);
	      IF NOT ((TOKTYP = EOL) OR (TOKTYP = CMD)) THEN ERROR;
	      RETURN
	    END
	    ELSE BEGIN ERROR; RETURN END;
	    SCAN(CURTOK)
	  END
	  ELSE JUST:= JUSCENTER;
	  IF TOKTYP<>STRTOK THEN
	    BEGIN ERROR; RETURN END
	  ELSE BEGIN
	     NEW(P); P^:= STRINFO;
	    WITH P^ DO BEGIN
	      STRGJUST:= JUST;
	      SCAN(CURTOK);
	      GETAHDR(NEXTSTRG)
	    END
	  END					(*STRTOK*)
	END					(*NOT EOL*)
    END (*GETAHDR*);

  BEGIN						(*GETHDRTRLR*)
    GETAHDR(NEWHT);
    IF BADLINE THEN FREEHDRTRLR(NEWHT)
    ELSE BEGIN
      IF NEWHDR<>OLDHDR THEN FREEHDRTRLR(NEWHDR);
      IF NEWHT<>NIL THEN WITH NEWHT^ DO
	IF (NEXTSTRG=NIL)AND(STRLEN=0)AND(STRGJUST=JUSCENTER)THEN
	BEGIN					(*SINGLE NULL STRTOK SAME AS OFF*)
	  DISPOSE(NEWHT); NEWHT:= NIL
	END;
      NEWHDR:= NEWHT
    END
  END (*GETHDRTRLR*);

BEGIN						(*GETCMD*)
  BADLINE:= FALSE;
  CMDPTR := 1;		(* initialize the scanner *)
  SCAN(CURTOK);
  WITH CURTOK DO
  BEGIN
    REPEAT
    IF TOKTYP<>CMD THEN ERROR
    ELSE
    BEGIN
      SAVECMD:= CMDTYP;
      SCAN(CURTOK);				(*GET NEXT TOKEN NOW*)
      CASE SAVECMD OF
      PAGE: BEGIN PAGE_TOP := TRUE; DOPAGE END;
      JUSTIFY:
	IF (TOKTYP = EOL) OR (TOKTYP = CMD) THEN CURSTATE:= JUSTIFYING
	ELSE IF (TOKTYP=WRD)AND(WRDTYP=LEFTWD) THEN
	  CURSTATE:= LEFTJUST
	ELSE ERROR;
      CENTER: CURSTATE:= CENTERING;
      RIGHT: CURSTATE:= RIGHTJUST;
      VERBATIM: CURSTATE:= READING;
      PARAGRAPH:
	IF NOT ((TOKTYP = EOL) OR (TOKTYP = CMD)) THEN
	  IF (TOKTYP<>INTGR) AND (TOKTYP<>SINTGR) THEN ERROR
	  ELSE PINDENT:= INTVAL
	ELSE PINDENT:= 0;
      SKIP:
	IF (ATTOP AND PAGE_TOP) OR (NOT ATTOP) THEN
	BEGIN
	  IF (TOKTYP = EOL) OR (TOKTYP = CMD) THEN
	    BEGIN IF ATTOP THEN DOTOP; WRITENL END
	  ELSE
	    IF TOKTYP<>INTGR THEN ERROR
	    ELSE IF INTVAL>0 THEN
	    BEGIN
	      IF ATTOP THEN DOTOP; WRITENL;
	      FOR I:= 1 TO INTVAL-1 DO IF NOT ATTOP THEN WRITENL
	    END
	END;
      HACKEOF: DONE:= TRUE;
      TITLE:GETHDRTRLR(CTITLE,NTITLE);
      FOOTNOTES: GETHDRTRLR(CFOOT,NFOOT);
      ENTRY: BEGIN   (* ENTRY A TABLE OF CONTENTS LINE *)
	IF ENTRY_F = NILF THEN BEGIN
          JOB_ID := JOBNUM;
	  REWRITE (ENTRY_F, SUBSTR(JOB_ID,MAX(1,LENGTH(JOB_ID)-5)) || 'STO.TMP');
	  CENTRY := NIL;      (* GET THINGS INITIALIZED *)
	  NENTRY := NIL
	END;
	IF IOSTATUS <> IO_OK THEN BEGIN
	  ERROR;
	  GOTO 100  (* ABORT *)
	END;
	GETHDRTRLR (CENTRY, NENTRY);
	IF CENTRY <> NENTRY THEN BEGIN
	  FREEHDRTRLR (CENTRY);
	  CENTRY := NENTRY
	END;

	IF CENTRY = NIL THEN S_LEN := 0
	ELSE BEGIN
	  S_VAL := CENTRY^.STRVAL;
	  S_LEN := CENTRY^.STRLEN
	END;
	FOR I := 1 TO S_LEN DO
	  IF BACKSLASH (S_VAL[I]) THEN
	    IF ATTOP THEN WRITE (ENTRY_F, NNUMBER.NUM :0)
	    ELSE WRITE (ENTRY_F, CNUMBER.NUM :0)
	  ELSE BEGIN
	    ENTRY_F^ := S_VAL[I].VALUE;
	    PUT(ENTRY_F)
	  END;
	WRITELN (ENTRY_F)
      END; (* ENTRY *)

      TOC: BEGIN
	IF INF_DEPTH = 8 THEN ERROR
	ELSE
	  IF ENTRY_F = NILF THEN ERROR
	  ELSE BEGIN
	    ENTRY_FILE_NAME := FILENAME ( ENTRY_F );
	    CLOSE (ENTRY_F);
	    RESET (ENTRY_F, ENTRY_FILE_NAME, [ASCII]);
	    IF IOSTATUS = IO_OK THEN BEGIN
	      INF_DEPTH := INF_DEPTH + 1;
	      INF [INF_DEPTH] := ENTRY_F
	    END
	  END
	END;  (* TOC *)
      DECAP:
	IF TOKTYP<>WRD THEN ERROR
	ELSE IF WRDTYP=OFFWD THEN DODECAP := FALSE
	ELSE IF WRDTYP=ONWD THEN BEGIN
		DODECAP := TRUE;
		NODECAP := FALSE
	     END
	ELSE ERROR;
      UNDER:
	IF TOKTYP<>WRD THEN ERROR
	ELSE IF WRDTYP=OFFWD THEN BEGIN
		DOUNDER := FALSE;
		UNDER_STATE := []
	     END
	ELSE IF WRDTYP=ONWD THEN BEGIN
		DOUNDER := TRUE;
		UNDER_STATE := []
	     END
	ELSE ERROR;
      INDENT:
	IF TOKTYP<>WRD THEN 
	BEGIN
	  IF TOKTYP = INTGR THEN CLINDENT := INTVAL
	  ELSE IF TOKTYP = SINTGR THEN CLINDENT := CLINDENT + INTVAL
	  ELSE IF (TOKTYP = EOL) OR (TOKTYP = CMD) THEN CLINDENT := 0
	  ELSE ERROR
	END
	ELSE IF WRDTYP=RIGHTWD THEN
	BEGIN
	  SCAN(CURTOK);
	  IF TOKTYP=INTGR THEN CRINDENT:= INTVAL
	  ELSE IF TOKTYP=SINTGR THEN CRINDENT:= CRINDENT+INTVAL
	  ELSE IF (TOKTYP = EOL) OR (TOKTYP = CMD) THEN CRINDENT:= 0
	  ELSE ERROR
	END
	ELSE IF WRDTYP=LEFTWD THEN
	BEGIN
	  SCAN(CURTOK);
	  IF TOKTYP=INTGR THEN CLINDENT:= INTVAL
	  ELSE IF TOKTYP=SINTGR THEN CLINDENT:= CLINDENT+INTVAL
	  ELSE IF (TOKTYP = EOL) OR (TOKTYP = CMD) THEN CLINDENT:= 0
	  ELSE ERROR
	END;
      SPACING:
	IF (TOKTYP = EOL) OR (TOKTYP = CMD) THEN CSPACING:= 0
	ELSE IF TOKTYP=INTGR THEN CSPACING:= INTVAL-1
	ELSE ERROR;
      WIDTH:
	IF TOKTYP=WRD THEN
	  IF WRDTYP<>TERWD THEN ERROR
	  ELSE
	  BEGIN
	    WRITE(TTY,'WIDTH: ');BREAK(TTY);
	    READLN(TTY); READ(TTY,I);
	    IF (I > 0) AND (I < 133) THEN NWIDTH := I
	    ELSE ERROR
	  END
	ELSE IF TOKTYP=INTGR THEN NWIDTH:= INTVAL
	ELSE ERROR;
      MARGIN:
	IF TOKTYP=WRD THEN
	  IF WRDTYP<>TERWD THEN ERROR
	  ELSE
	  BEGIN
	    WRITE(TTY,'MARGIN: ');BREAK(TTY);
	    READLN(TTY); READ(TTY,I);
	    IF (I >= 0) AND (I < 133) THEN NMARGIN := I
	    ELSE ERROR
	  END
	ELSE IF TOKTYP=INTGR THEN NMARGIN:= INTVAL
	ELSE ERROR;
      TOP:
	IF TOKTYP=WRD THEN
	  IF WRDTYP<>TERWD THEN ERROR
	  ELSE
	  BEGIN
	    WRITE(TTY,'TOP: ');BREAK(TTY);
	    READLN(TTY); READ(TTY,NTOP)
	  END
	ELSE IF TOKTYP=INTGR THEN NTOP:= INTVAL
	ELSE ERROR;
      BOTTOM:
	IF TOKTYP=WRD THEN
	  IF WRDTYP<>TERWD THEN ERROR
	  ELSE
	  BEGIN
	    WRITE(TTY,'BOTTOM: ');BREAK(TTY);
	    READLN(TTY); READ(TTY,NBOTTOM)
	  END
	ELSE IF TOKTYP=INTGR THEN NBOTTOM:= INTVAL
	ELSE ERROR;
      LENCMD:
	IF TOKTYP=WRD THEN
	  IF WRDTYP<>TERWD THEN ERROR
	  ELSE
	  BEGIN
	    WRITE(TTY,'LENGTH: ');BREAK(TTY);
	    READLN(TTY); READ(TTY,NLENGTH)
	  END
	ELSE IF TOKTYP=INTGR THEN NLENGTH:= INTVAL
	ELSE ERROR;
      NUMBER:
	WITH NNUMBER DO
	BEGIN
	  ALTRNT := FALSE;
	  IF TOKTYP=WRD THEN BEGIN
	    IF WRDTYP=BOTTOMWD THEN
	      BEGIN WHERE:= NUMBOT; SCAN(CURTOK) END
	    ELSE IF WRDTYP=TOPWD THEN
	      BEGIN WHERE:= NUMTOP; SCAN(CURTOK) END
	    ELSE IF WRDTYP=OFFWD THEN
	      BEGIN WHERE:= NONUM; GOTO 1 END
	    ELSE WHERE:= NUMBOT			(*DEFAULT*)
	  END
	  ELSE IF TOKTYP<>INTGR THEN
	    BEGIN ERROR; GOTO 1 END;

	  IF TOKTYP=WRD THEN
	  BEGIN
	    IF WRDTYP = ALTERWD THEN
	    BEGIN
	      ALTRNT := TRUE;
	      SCAN(CURTOK)
	    END
	  END;
	  IF TOKTYP=WRD THEN
	  BEGIN
	    IF WRDTYP=RIGHTWD THEN JUST:= JUSRIGHT
	    ELSE IF WRDTYP=LEFTWD THEN JUST:= JUSLEFT
	    ELSE BEGIN ERROR; GOTO 1 END;
	    SCAN(CURTOK)
	  END
	  ELSE JUST:= JUSCENTER;
	  IF TOKTYP=INTGR THEN NUM:= INTVAL;
1:
	END;					(*NUMBER CASE*)
      NEED:
	IF TOKTYP <> INTGR THEN ERROR
	ELSE
	  IF ((INTVAL+LINECNT) > (CLENGTH-CBOTTOM)) AND (CLENGTH>0)
	    THEN DOPAGE;
      TABS: BEGIN
	NEWTABCNT:= 0;
	WHILE (TOKTYP=INTGR) AND (NOT BADLINE) DO
	  IF NEWTABCNT<MAXTABS THEN
	  BEGIN
	    IF NEWTABCNT>0 THEN
	      IF INTVAL<=NEWTABS[NEWTABCNT] THEN ERROR;
	    NEWTABCNT:= NEWTABCNT+1;
	    NEWTABS[NEWTABCNT]:= INTVAL;
	    SCAN(CURTOK);
	    IF (TOKTYP=SPECIAL) AND (SPECCHAR=',') THEN
	    BEGIN SCAN(CURTOK);
	      IF TOKTYP<>INTGR THEN ERROR
	    END
	  END
	  ELSE ERROR;				(*TOO MANY TABS*)
	IF (TOKTYP = EOL) OR (TOKTYP = CMD) THEN
	BEGIN
	  IF NOT BADLINE THEN
	    BEGIN CURTABCNT:= NEWTABCNT; CURTABS:= NEWTABS END
	END
	ELSE IF NOT BADLINE THEN ERROR				(*JUNK ON END OF LINE*)
      END;					(*TABS*)

      TRANSLATE: MAKE_MAPPING;

      CONTROL:
      IF TOKTYP <> WRD THEN ERROR
      ELSE IF WRDTYP=OFFWD THEN BEGIN
		DOCONTROL := FALSE;
		CURRENT_STATE := []
	   END
      ELSE IF WRDTYP=ONWD THEN BEGIN
		DOCONTROL := TRUE;
		CURRENT_STATE := []
	   END
      ELSE ERROR;

      POSITIONS: BEGIN
	NEWLEVCNT:= 0;   (* COUNT THE POSITIONS *)
	WHILE (TOKTYP=INTGR) AND (NOT BADLINE) DO
	  IF NEWLEVCNT<MAXLEVELS THEN BEGIN   (* STORE THE POSITION *)
	    NEWLEVCNT:= NEWLEVCNT+1;
	    NEWPOSN[NEWLEVCNT]:= INTVAL;
	    SCAN(CURTOK);
	    IF (TOKTYP=SPECIAL) AND (SPECCHAR=',') THEN BEGIN (*EAT DELIMITER*)
	      SCAN(CURTOK);
	      IF TOKTYP<>INTGR THEN ERROR
	    END
	  END
	  ELSE ERROR;
	IF (TOKTYP=EOL) OR (TOKTYP=CMD) THEN BEGIN
	  IF NOT BADLINE THEN BEGIN  (* IF PREV. SUCCESSFUL PARSE *)
	    IF NEWLEVCNT=0 THEN  (* INITIALIZE POSITIONS TO DEFAULT *)
	      FOR I:=1 TO MAXLEVELS DO CURPOSN[I]:= 1
	    ELSE BEGIN   (* SET NEW POSITIONS *)
	      FOR I:= NEWLEVCNT+1 TO MAXLEVELS DO  (* PROPAGATE LAST POSN *)
		NEWPOSN[I]:= NEWPOSN[NEWLEVCNT];
	      CURPOSN:= NEWPOSN   (* COPY NEW POSITIONS IN *)
	    END;
	    CURLEVNUM[1]:= 0;   (* SET TO FIRST LEVEL COUNTING FROM ZERO *)
	    CLEVEL:= 1;
	    CLINDENT:= CURPOSN[1]-1;   (*INDENTATION IS MINUS ONE COLUMN POSN*)
	  END
	END
	ELSE IF NOT BADLINE THEN ERROR
      END (*POSITIONS*);

      LEVEL: BEGIN
	IF TOKTYP IN [SINTGR,INTGR] THEN BEGIN
	  IF TOKTYP=SINTGR THEN NEWLEVEL:= CLEVEL + INTVAL  (*INCREMENT*)
	  ELSE NEWLEVEL:= INTVAL;   (*ABSOLUTE LEVEL*)
	  IF (NEWLEVEL>=1) AND (NEWLEVEL<=MAXLEVELS) THEN BEGIN
	    IF NEWLEVEL>CLEVEL THEN   (* ZERO NUMBERS OF INTERVENING LEVELS *)
	      FOR I:= CLEVEL+1 TO NEWLEVEL DO CURLEVNUM[I]:= 0;
	    CLEVEL:= NEWLEVEL;   (*SET NEW LEVEL*)
	    CLINDENT:= CURPOSN[CLEVEL]-1   (*SET NEW INDENTATION*)
	  END
	  ELSE ERROR   (* LEVEL NUMBER NO GOOD *)
	END
	ELSE ERROR   (* EXPECTED INTEGER *)
      END (*LEVEL*);

      SECTION: BEGIN
	IF (TOKTYP=CMD) OR (TOKTYP=EOL) THEN BEGIN  (* BUMP CURRENT NUMBER *)
	  CURLEVNUM[CLEVEL]:= CURLEVNUM[CLEVEL]+1;
	  CLINDENT:= CURPOSN[CLEVEL]-1
	END
	ELSE IF (TOKTYP=INTGR) THEN BEGIN  (* NEW SECTION NUMBER *)
	  NEWLEVCNT:= 0;   (* FILL UP NEW SECTION NUMBER VECTOR *)
	  REPEAT
	    IF NEWLEVCNT<MAXLEVELS THEN BEGIN  (* STORE ONE *)
	      NEWLEVCNT:= NEWLEVCNT+1;
	      NEWLEVNUM[NEWLEVCNT]:= INTVAL;
	      SCAN(CURTOK);   (*CHECK FOR PERIOD*)
	      IF (TOKTYP=SPECIAL) AND (SPECCHAR='.') THEN BEGIN
		SCAN(CURTOK);
		IF TOKTYP<>INTGR THEN ERROR
	      END
	    END
	    ELSE ERROR (* TOO MANY LEVELS *)
	  UNTIL (TOKTYP<>INTGR) OR BADLINE;
	  IF (TOKTYP=EOL) OR (TOKTYP=CMD) THEN BEGIN
	    IF NOT BADLINE THEN BEGIN
	      CLEVEL:= NEWLEVCNT;
	      CURLEVNUM:= NEWLEVNUM;
	      CLINDENT:= CURPOSN[CLEVEL]-1
	    END
	  END
	  ELSE IF NOT BADLINE THEN ERROR  (*JUNK ON END*)
	END
	ELSE ERROR  (* EXPECTED SOMETHING USEFUL *)
      END; (*SECTION*)

      INCLUDE:
	BEGIN
	  TOKTYP := WRD;        (* TO PREVENT LATER ERRORS *)
	  F_NAME := '';
	  FOR I := TOKPOS TO CMDLEN DO F_NAME := F_NAME || CMDLN[I].VALUE;
	  CMDPTR := CMDLEN + 1;
	  TIDX := 1;
	  IF NOT PR_FILE_ID (F_NAME, TIDX, FID) THEN ERROR
	  ELSE IF INF_DEPTH = 8 THEN BEGIN  (* TOO MANY INCLUDES *)
		 WRITELN(TTY, '? Include files nested too deeply');
		 ERROR
	       END
	       ELSE BEGIN (* START A NEW INCLUDE FILE *)
		 RESET (INF [INF_DEPTH+1], '.SCR ' || FID, [ASCII]);
		 IF IOSTATUS = IO_OK THEN INF_DEPTH := INF_DEPTH + 1
		 ELSE BEGIN  (* BAD FILE GIVEN *)
		   WRITELN(TTY, '? Unable to open file ', F_NAME);
		   ERROR
		 END
	       END
	END;     (* END INCLUDE *)

      EOINCLUDE:		(* command to end an include file *)
	BEGIN
	  IF INF [INF_DEPTH] = ENTRY_F
	  THEN BEGIN
	    ENTRY_FILE_NAME := FILENAME ( ENTRY_F );
	    CLOSE (ENTRY_F);
	    REWRITE (ENTRY_F, ENTRY_FILE_NAME);
	    SCRATCH (ENTRY_F);
	    ENTRY_F := NILF
	    END
	  ELSE CLOSE (INF [INF_DEPTH]);
	  INF_DEPTH := INF_DEPTH - 1
	END; (* EOINCLUDE *)

      END;					(*CASE COMMAND*)
      IF NOT ((TOKTYP = EOL) OR (TOKTYP = CMD)) THEN
      BEGIN
	SCAN(CURTOK);
	IF NOT ((TOKTYP = EOL) OR (TOKTYP = CMD)) THEN
	  IF NOT BADLINE THEN ERROR
      END
    END						(*COMMAND PARSING*)
      UNTIL (TOKTYP = EOL) OR (BADLINE = TRUE)
  END						(*WITH CURTOK*)
END;						(*GETCMD*)
   