

PROCEDURE WRITOBJ ( VAR REC: OBJECTRECORD ) ;

BEGIN
  IF NOT OFFSWITCH['K'] THEN
    WRITOFILE( REC, PDP11OBJ (*$Z+*), OUTPHGH (*$Z-*))
  ELSE
    REC.LEN := 1;
END;

(*$Y-*)   (* NO MODULE SPLITTING FOR A WHILE *)




FUNCTION RAD50 ( FSTR: ALFA ; FINDEX: INTEGER ): INTEGER ;

VAR
    I,J: INTEGER ;


  FUNCTION RAD50C ( CH: CHAR ): INTEGER ;

  BEGIN
    IF CH IN LETTERS THEN
      RAD50C := ORD(CH) - 64
    ELSE IF CH IN DIGITS THEN
      RAD50C := ORD(CH) - 18
    ELSE IF CH = ' ' THEN
      RAD50C := 0
    ELSE IF CH = '$' THEN
      RAD50C := 27
    ELSE IF CH = '.' THEN
      RAD50C := 28
    ELSE
      RAD50C := 29
  END ;

BEGIN (* RAD50 *)
  J := 0 ;
  FOR I := FINDEX TO FINDEX + 2 DO
    J := 40 * J + RAD50C ( FSTR[I] ) ;
  RAD50 := J
END ;

PROCEDURE PUTGR50 ( R50N1,R50N2,FLAGS,FVAL: INTEGER ) ;

BEGIN
  WITH GSD DO BEGIN
    IF LEN > 17 THEN
      WRITOBJ ( GSD ) ;
    VALUE[LEN+1] := R50N1 ;
    VALUE[LEN+2] := R50N2 ;
    VALUE[LEN+3] := FLAGS ;
    VALUE[LEN+4] := FVAL ;
    LEN := LEN + 4 ;
  END
END ;

PROCEDURE PUTGSD ( FNAM: ALFA ; FLAGS,FVAL: INTEGER ) ;

BEGIN
  PUTGR50 ( RAD50(FNAM,1) , RAD50(FNAM,4), FLAGS, FVAL )
END;

PROCEDURE PUTRLD ( FNAM: ALFA ; FTYP,FDISPL,FVAL: INTEGER ) ;

BEGIN
  WITH RLD DO BEGIN
    VALUE[LEN+1] := FTYP + 256 * FDISPL ;
    IF FTYP <> 8 THEN BEGIN
      VALUE [ LEN+2 ] := RAD50 ( FNAM, 1 ) ;
      VALUE [ LEN + 3 ] := RAD50 ( FNAM, 4 ) ;
      LEN := LEN + 2
    END;
    VALUE [ LEN + 2 ] := FVAL ;
    LEN := LEN + 2 ;
    IF LEN > 17 THEN BEGIN
      WRITOBJ(CODE) ;
      WRITOBJ(RLD)
    END ;
  END ;
  (*$Z+*)
  IF PRCODE AND (FTYP = RELOCFCN) THEN
    WRITELN( CEX, ';', FNAM:60 ); (*$Z-*)
END ;

PROCEDURE GLOBALDEF ( FNAM: ALFA ; FADDR: CODERANGE ) ;

BEGIN
  IF GLOBALINDEX = GBLDFMAX THEN
    ERROR ( 999 )
  ELSE BEGIN
    GLOBALINDEX := GLOBALINDEX + 1 ;
    WITH GLOBALENTRY [ GLOBALINDEX ] DO BEGIN
      EPADDR := FADDR ;
      R50P1 := RAD50 ( FNAM, 1 ) ;
      R50P2 := RAD50 ( FNAM, 4 ) ;
    END
  END
END ;

PROCEDURE PSECTDEF ( FNAM: ALFA ;  FSIZE: CODERANGE) ;

VAR
    I: INTEGER ;

BEGIN
  PUTGSD ( FNAM, PSECTDEFFLAGS, FSIZE ) ;
  FOR I := OLDGLOBALINDEX+1 TO GLOBALINDEX DO
    WITH GLOBALENTRY [ I ] DO
      PUTGR50 ( R50P1, R50P2, GLOBALDEFFLAGS, EPADDR ) ;
END ;

PROCEDURE INCCIX;

BEGIN
  CIX := CIX + 1;
  IF CODE.LEN = 21 THEN BEGIN
    WRITOBJ ( CODE ) ;
    IF RLD.LEN > 1 THEN
      WRITOBJ ( RLD ) ;
  END ;
  WITH CODE DO BEGIN
    IF LEN = 1 THEN BEGIN
      LEN := 2 ;
      VALUE [ 2 ] := 2 * CIX
    END ;
    LEN := LEN + 1
  END
END;

(*$Z+*)





PROCEDURE WRITEREG(MODE,REG: INTEGER );

BEGIN
  IF ODD(MODE DIV 8) THEN
    WRITE(CEX,'@');
  CASE MODE DIV 16 OF
    0:
      WRITE(CEX,REGNAMES[REG]);
    1:
	WRITE(CEX,'(',REGNAMES[REG],')+');
    2:
      WRITE(CEX,'-(',REGNAMES[REG],')');
    3:
      WRITE(CEX,'X(',REGNAMES[REG],')')
  END
END (*WRITEREG *);

(*$Z-*)




PROCEDURE GEN1(OPCODE: INSTRRANGE; MODE, REGISTER: INTEGER);

VAR
    BYTE: PACKED ARRAY[1..4] OF CHAR;

BEGIN
  INCCIX;
  WITH CODE DO BEGIN
    VALUE [ LEN ] := INSTRVAL[OPCODE] + MODE + REGISTER ;
    (*$Z+*)
    IF PRCODE THEN BEGIN
      IF OPCODE < CLR THEN
	BYTE := 'B   '
      ELSE
	BYTE := '    ';
      WRITE(CEX,2*CIX:6:O,'    ',VALUE[LEN]:6:O,MN[OPCODE]:10,BYTE);
      WRITEREG(MODE,REGISTER);
      WRITELN(CEX)
    END
    (*$Z-*)
  END
END;
(*GEN1*)




PROCEDURE GEN2(OPCODE: INSTRRANGE; SRCMODE, SRCREG, DSTMODE, DSTREG: INTEGER);

VAR
    BYTE: PACKED ARRAY[1..4] OF CHAR;

BEGIN
  INCCIX;
  WITH CODE DO BEGIN
    VALUE [ LEN ] := INSTRVAL[OPCODE] + 64 * (SRCMODE + SRCREG)
      + DSTMODE + DSTREG ;
      (*$Z+*)
    IF PRCODE THEN BEGIN
      IF OPCODE < CLR THEN
	BYTE :='B   '
      ELSE
	BYTE:='    ';
      WRITE(CEX,2*CIX:6:O,'    ',VALUE[LEN]:6:O,MN[OPCODE]:10,BYTE);
      WRITEREG(SRCMODE,SRCREG);
      WRITE(CEX,',');
      WRITEREG(DSTMODE,DSTREG);
      WRITELN(CEX)
    END
    (*$Z-*)
  END
END;
(*GEN2*)




PROCEDURE GENBR(BRCODE: INSTRRANGE; OFFS: INTEGER);

VAR
    OFFSET: INTEGER;

BEGIN
  INCCIX;
  IF OFFS < 0 THEN
    OFFSET := OFFS + 256
  ELSE
    OFFSET := OFFS;
  WITH CODE DO BEGIN
    VALUE [ LEN ] := INSTRVAL[BRCODE] + OFFSET ;
    (*$Z+*)
    IF PRCODE THEN
      WRITELN(CEX,2*CIX:6:O,'    ',VALUE[LEN]:6:O, MN[BRCODE]:10,OFFS:8,
	'    ;  ',2*(CIX+1+OFFS):6:O)
	(*$Z-*)
  END
END;
(*GENBR*)




PROCEDURE GENCONST(CNST: INTEGER);

BEGIN
  INCCIX;
  WITH CODE DO
    VALUE [LEN] := CNST ;
    (*$Z+*)
  IF PRCODE THEN
    WRITELN(CEX,2*CIX:6:O,'    ',CNST:6:O,'       ',CNST:12)
    (*$Z-*)
END (*GENCONST*);

PROCEDURE GENSUBRCALL (SUBRNAME:RUNTIMEROUTS );

FORWARD;

PROCEDURE LINENODEF;

BEGIN
  IF LINENO <> OLDLINENO THEN BEGIN
    OLDLINENO := LINENO;
    IF TRACE THEN
      GENSUBRCALL ( TRACK );
    GEN2(MOV,AUTINC,PC,INDEX,GP);
    GENCONST(LINENO);
    GENCONST(LINEADDR);
    IF FREQUENCE OR DEBUG THEN
      WITH LASTLINE DO BEGIN
	GEN1 ( TST,AUTINC,PC );
	GENCONST ( 0 );
	IF LLADDR <> 0 THEN
	  PUTRLD ( LLPSECT,15B (*PSECT ADD.REL.*),2*CODE.LEN-2,2*LLADDR);
	LLPSECT := PSECT;
	LLADDR := CIX - 4;
      END;
    IF FREQUENCE THEN BEGIN
      GEN1( INC,AUTINC,PC );
      GENCONST ( 0 )
    END;
  END
END (* LINENODEF *);

PROCEDURE MOVETOSP( N: INTEGER );

VAR
    I: INTEGER;

BEGIN
  IF N > 4 THEN BEGIN
    GENSUBRCALL(MOVTS);
    GENCONST( N );
  END
  ELSE
    FOR I:=1 TO N DO
      GEN2( MOV,AUTDEC,AD,AUTDEC,SP );
END (* MOVE TO SP *);

PROCEDURE MOVEFROMSP( N: INTEGER );

VAR
    I: INTEGER;

BEGIN
  IF N > 4 THEN BEGIN
    GENSUBRCALL( MOVFS );
    GENCONST( N );
  END
  ELSE
    FOR I:=1 TO N DO
      GEN2( MOV,AUTINC,SP,AUTINC,AD );
END (* MOVE FROM SP *);

PROCEDURE LOD (P: LEVRANGE; Q,SIZE: ADDRRANGE); (*FOR ADDRESSING VARI-*)


VAR
    I, REGISTER: INTEGER; (*ABLES ON INTERMEDIATE*)


BEGIN (*LEVELS*)
  IF SIZE = 2 THEN BEGIN
    IF P = 0 THEN
      REGISTER := MP
    ELSE BEGIN
      REGISTER := AD;
      GEN2(MOV,REGDEF,MP,REG,AD);
      FOR I := 2 TO P DO
	GEN2(MOV,REGDEF,AD,REG,AD)
    END;
    IF COMPTYPES( GATTR.TYPTR, CHARPTR ) THEN BEGIN
      GEN1(CLR, AUTDEC,SP);
      GEN2(MOVB,INDEX,REGISTER,REGDEF,SP)
    END
    ELSE
      GEN2(MOV,INDEX,REGISTER,AUTDEC,SP);
    GENCONST(Q)
  END (*SIZE = 2*)
  ELSE BEGIN
    IF P = 0 THEN
      GEN2(MOV,REG,MP,REG,AD)
    ELSE BEGIN
      GEN2(MOV,REGDEF,MP,REG,AD);
      FOR I := 2 TO P DO
	GEN2(MOV,REGDEF,AD,REG,AD)
    END;
    GEN2(ADD,AUTINC,PC,REG,AD);
    GENCONST(Q + SIZE); (*Q AND SIZE IN BYTES*)
    MOVETOSP( SIZE DIV 2 );
  END
END;
(*LOD *)



  PROCEDURE STATICPUBLIC (LCP: CTP; OFFSET: INTEGER);

  BEGIN
    IF LCP <> NIL THEN BEGIN
      GENCONST (0);
      IF LCP^.VCLASS = STATICSY THEN
	PUTRLD (STATICPSECT,STATICRELOC,2*CODE.LEN-2,OFFSET)
      ELSE BEGIN
	PUTRLD (LCP^.NAME,DIRECTRELOC,2*CODE.LEN-2,OFFSET);
	IF LCP^.VNOTUSED THEN BEGIN
	  LCP^.VNOTUSED := FALSE;
	  PUTGSD (LCP^.NAME,GLOBALREFFLAGS,0);
	END
      END
    END
  END;

PROCEDURE LDO (OFFSET, SIZE: ADDRRANGE; LCP: CTP); (*FOR LOADING GLOBALLY DECLARED*)


VAR
    I: INTEGER; (*VARIABLES*)


BEGIN
  IF (LCP <> NIL) ANDIF (LCP^.VCLASS = DEFAULTSY) THEN BEGIN
    IF SIZE = 2 THEN 
      IF COMPTYPES (GATTR.TYPTR,CHARPTR) THEN BEGIN
	GEN1 (CLR,AUTDEC,SP);
	GEN2 (MOVB,INDEX,GP,REGDEF,SP);
	GENCONST (OFFSET);
      END
      ELSE BEGIN
	GEN2 (MOV,INDEX,GP,AUTDEC,SP);
	GENCONST (OFFSET);
      END
    ELSE BEGIN
      GEN2 (MOV,REG,GP,REG,AD);
      GEN2 (ADD,AUTINC,PC,REG,AD);
      GENCONST (OFFSET+SIZE);
      MOVETOSP (SIZE DIV 2);
    END
  END
  ELSE IF SIZE = 2 THEN BEGIN
    IF COMPTYPES( GATTR.TYPTR , CHARPTR ) THEN BEGIN
      GEN1(CLR,AUTDEC,SP);
      GEN2(MOVB,AUTINCDEF,PC,REGDEF,SP);
    END
    ELSE
      GEN2(MOV,AUTINCDEF,PC,AUTDEC,SP);
    STATICPUBLIC (LCP,OFFSET)
  END
  ELSE BEGIN
    GEN2(MOV,AUTINC,PC,REG,AD);
    STATICPUBLIC (LCP,OFFSET+SIZE);
    MOVETOSP( SIZE DIV 2 );
  END
END;
(*LDO *)




PROCEDURE GENSUBRCALL; (*GENERATES RTRCALLS*)


VAR
    ID: ALFA ;
    I: INTEGER ;

BEGIN
  ID[1] := '$' ;
  FOR I := 1 TO 5 DO
    ID[I+1] := RNA[SUBRNAME][I] ;
  FOR I := 7 TO ALFALENG DO
    ID[I] := ' ' ;
  GEN2( JSR, REG, MP, INDEX, PC ) ;
  GENCONST ( 0 ) ;
  PUTRLD ( ID, RELOCFCN, 2*CODE.LEN-2, 0 ) ;
  IF NOTCALLED [SUBRNAME] THEN BEGIN
    NOTCALLED [SUBRNAME] := FALSE ;
    PUTGSD ( ID, GLOBALREFFLAGS, 0 )
  END ;
END;
(*GENSUBRCALL*)




PROCEDURE GENUJP(LADDR: CODERANGE);

BEGIN
  IF (LADDR <> 0) AND (CIX - LADDR <= 126) THEN
    GENBR(BR,LADDR - CIX - 2)
  ELSE BEGIN
    GEN1(JMP,INDEX,PC);
    IF LADDR<>0 THEN
      GENCONST(2 * (LADDR-CIX-2))
    ELSE
      GENCONST(0)
  END;
END;
(*GENUJP*)




PROCEDURE INSERT(ADDRS: CODERANGE; OFFST: ADDRRANGE);

BEGIN
  IF CODE.LEN > 1 THEN
    WRITOBJ( CODE ) ;
  WITH RLD DO BEGIN
    IF LEN > 19 THEN
      WRITOBJ ( RLD ) ;
    VALUE [ LEN+1 ] := 8 ; (* REDEFINE CURRENT LOCATION POINTER *)
    VALUE [ LEN+2 ] := 2 * ADDRS ; (* NEW LOCATION *)
    LEN := LEN + 2 ;
    WRITOBJ ( RLD )
  END ;
  WITH CODE DO BEGIN
    VALUE [ 2 ] := 2*ADDRS ;
    VALUE [ 3 ] := OFFST ;
    LEN := 3 ;
    WRITOBJ ( CODE ) ;
  END ;
  WITH RLD DO BEGIN
    VALUE [ 2 ] := 8 ;
    VALUE [ 3 ] := 2 * CIX + 2 ;
    LEN := 3 ;
    WRITOBJ ( RLD ) ;
  END ;
  (*$Z+*)
  IF PRCODE THEN BEGIN
    WRITELN(CEX,';');
    WRITELN(CEX,2*ADDRS:6:O,'    ',OFFST:6:O);
    WRITELN(CEX,';');
  END
  (*$Z-*)
END ;

PROCEDURE LOAD;

VAR
    I: INTEGER;

BEGIN
  WITH GATTR DO
    IF TYPTR <> NIL THEN BEGIN
      CASE KIND OF
	CST:
	  IF TYPTR^.FORM = SCALAR THEN
	    IF TYPTR = REALPTR THEN BEGIN
	    (*HERE A  REAL  VALUE   IS   REPRESENTED BY TWO PDP-11 INTEGERS*)
	      GEN2(MOV,AUTINC,PC,AUTDEC,SP);
	      GENCONST(CVAL.VALP^.TAIL);
	      GEN2(MOV,AUTINC,PC,AUTDEC,SP);
	      GENCONST(CVAL.VALP^.HEAD);
	    END
	    ELSE IF CVAL.IVAL = 0 THEN
	      GEN1(CLR,AUTDEC,SP)
	    ELSE BEGIN
	      GEN2(MOV,AUTINC,PC,AUTDEC,SP);
	      GENCONST(CVAL.IVAL)
	    END (*FORM = SCALAR*)
	  ELSE IF TYPTR = NILPTR THEN
	    GEN1(CLR,AUTDEC,SP)
	  ELSE
	    ERROR(400);
	VARBL:
	  CASE ACCESS OF
	    DRCT:
	      IF VLEVEL <= 1 THEN
		LDO(DPLMT,TYPTR^.SIZE,VID)
	      ELSE
		LOD(LEVEL - VLEVEL,DPLMT,TYPTR^.SIZE);
	    INDRCT:
	      IF TYPTR^.SIZE = 2 THEN
		IF COMPTYPES ( TYPTR , CHARPTR ) THEN BEGIN
		  GEN2(MOV,AUTINC,SP,REG,AD);
		  GEN1(CLR,AUTDEC,SP);
		  IF IDPLMT = 0 THEN
		    GEN2(MOVB,REGDEF,AD,REGDEF,SP)
		  ELSE BEGIN
		    GEN2(MOVB,INDEX,AD,REGDEF,SP);
		    GENCONST(IDPLMT)
		  END
		END
		ELSE IF IDPLMT = 0 THEN
		  GEN2(MOV,AUTINCDEF,SP,AUTDEC,SP)
		ELSE BEGIN
		  GEN2(MOV,AUTINC,SP,REG,AD);
		  GEN2(MOV,INDEX,AD,AUTDEC,SP);
		  GENCONST(IDPLMT)
		END
	      ELSE BEGIN
		GEN2(MOV,AUTINC,SP,REG,AD);
		GEN2(ADD,AUTINC,PC,REG,AD);
		GENCONST(IDPLMT + TYPTR^.SIZE);
		MOVETOSP( TYPTR^.SIZE DIV 2 );
	      END;
	    PACKD:
	      IF TYPTR = BOOLPTR THEN
		GENSUBRCALL(LPB)
	      ELSE
		ERROR(400)
	  END;
	EXPR:
      END;
      KIND := EXPR
    END
END (*LOAD*);

PROCEDURE GENFJP(LADDR: CODERANGE);

BEGIN
  LOAD;
  IF GATTR.TYPTR <> NIL THEN
    IF GATTR.TYPTR <> BOOLPTR THEN
      ERROR(144);
  GEN1(TST,AUTINC,SP);
  IF (LADDR <> 0) AND (CIX - LADDR <= 126) THEN
    GENBR(BEQ,LADDR - CIX - 2) (*BACKWARD JUMP WITH OFFSET <= 128*)
  ELSE BEGIN
    GENBR(BNE, 2);
    GEN1(JMP,INDEX,PC);
    IF LADDR <> 0 THEN
      GENCONST(2 * (LADDR - CIX - 2))
    ELSE
      GENCONST(0)
  END
END;
(*GENFJP*)

(*$Y+*)     (*   MODULE SPLITTING   *)




PROCEDURE STORE(VAR FATTR: ATTR);

VAR
    I,P,REGISTER: INTEGER;

BEGIN
  WITH FATTR DO
    IF TYPTR <> NIL THEN
      CASE ACCESS OF
	DRCT:
	  IF VLEVEL <= 1 THEN (*STORE AT GLOBAL LEVEL*)
	  BEGIN
	    IF TYPTR^.SIZE = 2 THEN BEGIN
	      IF COMPTYPES ( TYPTR , CHARPTR ) THEN BEGIN
		GEN2(MOV,AUTINC,SP,REG,R);
		GEN2(MOVB,REG,R,AUTINCDEF,PC)
	      END
	      ELSE
		GEN2(MOV,AUTINC,SP,AUTINCDEF,PC);
	      STATICPUBLIC (VID,DPLMT);
	    END
	    ELSE BEGIN
	      GEN2(MOV,AUTINC,PC,REG,AD);
	      STATICPUBLIC (VID,DPLMT);
	      MOVEFROMSP( TYPTR^.SIZE DIV 2 );
	    END
	  END
	  ELSE BEGIN
	    P := LEVEL - VLEVEL;
	    IF TYPTR^.SIZE = 2 THEN BEGIN
	      IF P = 0 THEN
		REGISTER := MP
	      ELSE BEGIN
		REGISTER := AD;
		GEN2(MOV,REGDEF,MP,REG,AD);
		FOR I := 2 TO P DO
		  GEN2(MOV,REGDEF,AD,REG,AD)
	      END;
	      IF COMPTYPES ( TYPTR , CHARPTR ) THEN BEGIN
		GEN2(MOV,AUTINC,SP,REG,R);
		GEN2(MOVB,REG,R,INDEX,REGISTER)
	      END
	      ELSE
		GEN2(MOV,AUTINC,SP,INDEX,REGISTER);
	      GENCONST(DPLMT)
	    END
	    ELSE BEGIN
	      IF P = 0 THEN
		GEN2(MOV,REG,MP,REG,AD)
	      ELSE BEGIN
		GEN2(MOV,REGDEF,MP,REG,AD);
		FOR I := 2 TO P DO
		  GEN2(MOV,REGDEF,AD,REG,AD)
	      END;
	      GEN2(ADD,AUTINC,PC,REG,AD);
	      GENCONST(DPLMT);
	      MOVEFROMSP( TYPTR^.SIZE DIV 2 );
	    END
	  END;
	INDRCT:
	  IF IDPLMT <> 0 THEN
	    ERROR(400)
	  ELSE BEGIN
	    IF TYPTR^.SIZE = 2 THEN
	      IF COMPTYPES ( TYPTR , CHARPTR ) THEN BEGIN
		GEN2(MOV,AUTINC,SP,REG,R);
		GEN2(MOVB,REG,R,AUTINCDEF,SP)
	      END
	      ELSE
		GEN2(MOV,AUTINC,SP,AUTINCDEF,SP)
	    ELSE BEGIN
	      GEN2(MOV,INDEX,SP,REG,AD);
	      GENCONST(TYPTR^.SIZE);
	      MOVEFROMSP( TYPTR^.SIZE DIV 2 );
	      GEN1(TST,AUTINC,SP)
	    END
	  END;
	PACKD:
	  IF TYPTR = BOOLPTR THEN
	    GENSUBRCALL(STPB)
	  ELSE
	    ERROR(400)
      END
END (*STORE*);

(*$Y+*)     (*  MODULE SPLITTING  *)



PROCEDURE LOADADDRESS;

VAR
    I,J: INTEGER;

BEGIN
  WITH GATTR DO
    IF TYPTR <> NIL THEN BEGIN
      CASE KIND OF
	CST:
	  IF NOT STRING(TYPTR) THEN
	    ERROR(400);
	VARBL:
	  CASE ACCESS OF
	    DRCT: BEGIN
	      IF VLEVEL <= 1 THEN BEGIN
		IF VSCLASS = DEFAULTSY THEN BEGIN
		  GEN2 (MOV,REG,GP,AUTDEC,SP);
		END
		ELSE BEGIN
		  GEN2 (MOV,AUTINC,PC,AUTDEC,SP);
		  STATICPUBLIC (VID,DPLMT);
		  DPLMT := 0;
		END;
	      END
	      ELSE BEGIN
		I := LEVEL - VLEVEL;
		IF I = 0 THEN
		  GEN2(MOV,REG,MP,AUTDEC,SP)
		ELSE IF I = 1 THEN
		  GEN2(MOV,REGDEF,MP,AUTDEC,SP)
		ELSE BEGIN
		  GEN2(MOV,REGDEF,MP,REG,AD);
		  FOR J := 3 TO I DO
		    GEN2(MOV,REGDEF,AD,REG,AD);
		  GEN2(MOV,REGDEF,AD,AUTDEC,SP)
		END
	      END;
	      IF DPLMT <> 0 THEN BEGIN
	        GEN2(ADD,AUTINC,PC,REGDEF,SP);
	        GENCONST(DPLMT)
		END;
	    END;
	    INDRCT:
	      IF IDPLMT <> 0 THEN BEGIN
		GEN2(ADD,AUTINC,PC,REGDEF,SP);
		GENCONST(IDPLMT)
	      END;
	    PACKD:
	  END;
	EXPR:
	  ERROR(616)
      END;
      KIND := VARBL;
      IF ACCESS <> PACKD THEN BEGIN
	ACCESS := INDRCT;
	IDPLMT := 0
      END
    END
END;
(*LOADADDRESS*)

(*$Y+*)     (*  NEW MODULE  *)




PROCEDURE STATEMENT(FSYS: SETOFSYS);

LABEL
    1;

VAR
    LCP: CTP;
    LLP: LBP;


  PROCEDURE MULTIPLY;

  BEGIN
    IF EXTSET THEN BEGIN
      GEN2(MOV,AUTINC,SP,REG,R);
      GEN2(MULT,REG,R,AUTINC,SP);
      GEN2(MOV,REG,R,AUTDEC,SP);
    END
    ELSE
      GENSUBRCALL(MPI);
  END;

  (*MULTIPLY*)





  PROCEDURE EXPRESSION(FSYS: SETOFSYS);

  FORWARD;


  PROCEDURE SELECTOR(FSYS: SETOFSYS; FCP: CTP);

  VAR
      LATTR: ATTR;
      LCP: CTP;
      LMIN,LMAX: INTEGER;
      P,SUBSTRSIZE: INTEGER;
      LSP1: STP;

  BEGIN
    IF FCP <> NIL THEN
    (*FCP = NIL INDICATES EITHER A STRINGCONSTANT OR A FUNCTIONRESULT OF*)
    (*MULTIPLE TYPE FROM WHICH AN ELEMENT MUST BE SELECTED*)
      WITH FCP^, GATTR DO BEGIN
	TYPTR := IDTYPE;
	KIND := VARBL;
	CASE KLASS OF
	  VARS:
	    IF VKIND = ACTUAL THEN BEGIN
	      ACCESS := DRCT;
	      VLEVEL := VLEV;
	      VSCLASS := VCLASS;
	      VID := FCP;
	      DPLMT := VADDR;
	    END
	    ELSE BEGIN
	      P:= VADDR;
	      IF TYPTR <> NIL THEN
		IF TYPTR^.FORM = STRINGPARM THEN
		  LOD(LEVEL - VLEV,P,4)
		ELSE BEGIN
		  IF TYPTR^.FORM = BOUNDLESS THEN
		    P := P + 2 * (TYPTR^.UNSPECLEVEL - 1);
		    (*HYP.ADDR. OF BOUNDLESS ARRAYS ON LOCATION P*)
                  IF COMPTYPES(TYPTR,CHARPTR) THEN  (* BYTE, ASCII, ETC. *)
		    TYPTR := INTPTR;
		    (*ADDRESS MUST BE LOADED INSTEAD OF CHARACTERVALUE*)
		  LOD(LEVEL - VLEV, P, 2);
		  TYPTR := IDTYPE;
		END;
	      ACCESS := INDRCT;
	      IDPLMT := 0
	    END;
	  FIELD:
	    WITH DISPLAY[DISX] DO
	      IF OCCUR = CREC THEN BEGIN
		ACCESS := DRCT;
		VLEVEL := CLEV;
		DPLMT := CDSPL + FLDADDR
	      END
	      ELSE BEGIN

		(* BASE ADDRESS IS ALWAYS STORED AT OFFSET FROM MP.
		   GET BASE ADDRESS ON STACK. *)

		GEN2(MOV,INDEX,MP,AUTDEC,SP);
		GENCONST(VDSPL);
		TYPTR := IDTYPE;
		ACCESS := INDRCT;
		IDPLMT := FLDADDR
	      END;
	  FUNC:
	    IF PFDECKIND = STANDARD THEN
	      ERROR(150)
	    ELSE IF PFLEV = 0 THEN
	      ERROR(150) (*EXTERNAL FCT*)
	    ELSE IF PFKIND = FORMAL THEN
	      ERROR(151)
	    ELSE BEGIN
	      ACCESS := DRCT;
	      VLEVEL := PFLEV + 1;
	      DPLMT := PARLISTSIZE; (*ADDRESS OF FUNCTIONRESULT*)
	      IF IDTYPE^.FORM=ARRAYS THEN
		DPLMT := DPLMT - IDTYPE^.ADDRCORR
	    END
	END (*CASE*)
      END (*WITH*);
    IF NOT (SY IN SELECTSYS OR FSYS) THEN BEGIN
      ERROR(59);
      SKIP(SELECTSYS OR FSYS)
    END;
    WHILE SY IN SELECTSYS DO BEGIN
    (*[*)
      IF SY = LBRACK THEN BEGIN
	REPEAT
	  WITH GATTR DO
	    IF TYPTR <> NIL THEN
	      IF NOT (TYPTR^.FORM IN [ARRAYS,STRINGPARM,BOUNDLESS]) THEN BEGIN
		ERROR(138);
		GATTR.TYPTR := NIL
	      END;
	  LATTR := GATTR;
	  LOADADDRESS;
	  INSYMBOL;
	  EXPRESSION(FSYS OR [COMMA,COLON,RBRACK]);
	  LOAD;
	  IF GATTR.TYPTR <> NIL THEN
	    IF GATTR.TYPTR^.FORM <> SCALAR THEN
	      ERROR(113);
	  IF LATTR.TYPTR <> NIL THEN
	    WITH LATTR.TYPTR^ DO BEGIN
	      SUBSTRSIZE := -1;
	      WITH GATTR DO BEGIN
		KIND := VARBL;
		ACCESS:= INDRCT;
		IDPLMT :=0
	      END;
	      IF SY = COLON TEGIN
		IF FORM = BOUNDLESS THEN
		  ERROR(615)
		ELSE IF FORM = ARRAYS THEN BEGIN
		  IF AELTYPE <> CHARPTR THEN
		    ERROR(615);
		  LSP1 := INXTYPE;
		  IF LSP1 <> NIL THEN
		    GETBOUNDS(INXTYPE,LMIN,LMAX);
		END
		ELSE BEGIN
		  LSP1 := INTPTR; (*INDEXTYPE OF STRINGPARAMETER*)
		  LMIN := 0;
		END;
		IF NOT COMPTYPES(LSP1,GATTR.TYPTR) THEN
		  ERROR(613);
		LSP1 := GATTR.TYPTR;
		INSYMBOL;
		EXPRESSION(FSYS OR [RBRACK]);
		LOAD;
		IF NOT COMPTYPES(LSP1,GATTR.TYPTR) THEN
		  ERROR(614);
		IF RUNTMCHECK THEN BEGIN
		  GEN2(MOV,AUTINC,PC,AUTDEC,SP);
		  GENCONST(LMIN);
		  IF FORM = ARRAYS THEN BEGIN
		    GEN2(MOV,AUTINC,PC,AUTDEC,SP);
		    GENCONST(LMAX);
		  END
		  ELSE BEGIN
		    GEN2(MOV,INDEX,SP,AUTDEC,SP);
		    GENCONST(6);
		  END;
		  GENSUBRCALL(SUBSTRCHECK);
		END;
		GEN2(MOV,AUTINC,SP,REG,R);
		GEN2(SUB,REGDEF,SP,REG,R);
		GEN1(INC,REG,R);
		GEN2(ADD,AUTINC,SP,REGDEF,SP);
		GEN2(MOV,REG,R,AUTDEC,SP);
		GATTR.KIND := EXPR;
		IF LATTR.TYPTR^.FORM = STRINGPARM THEN
		  GATTR.TYPTR := LATTR.TYPTR
		ELSE
		  NEW(GATTR.TYPTR,STRINGPARM);
	      END
	      ELSE IF FORM = BOUNDLESS THEN BEGIN
		IF NOT COMPTYPES(INDEXTYPE,GATTR.TYPTR) THEN
		  ERROR(139);
		IF UNSPECLEVEL > 1 THEN
		(*LOAD THE REQUIRED SIZE COMPONENT OF THE BOUNDLESS ARRAY-*)
		(*PARAMETER FROM ITS PLACE IN THE PARAMETERLIST*)
		BEGIN
		  IF FCP <> NIL THEN BEGIN
		    IF (LEVEL - FCP^.VLEV) = 0 THEN
		      P := MP
		    ELSE BEGIN
		      P := AD;
		      GEN2(MOV,REGDEF,MP,REG,AD);
		      FOR P := 2 TO LEVEL - FCP^.VLEV DO
			GEN2(MOV,REGDEF,AD,REG,AD);
		    END;
		    GEN2(MOV,INDEX,P,AUTDEC,SP);
		    GENCONST(FCP^.VADDR + 2 * (UNSPECLEVEL - 2))
		  END;
		  MULTIPLY;
		  GEN2(ADD,AUTINC,SP,REGDEF,SP);
		END
		ELSE IF SUBSTRUCT <> NIL THEN
		  SUBSTRSIZE := SUBSTRUCT^.SIZE;
		  (*IF UNSPECLEVEL = 1 THEN SIZE = SIZE OF SUBSTRUCTURE*)
		GATTR.TYPTR := SUBSTRUCT
	      END
	      ELSE (*FORM = ARRAYS*)
	      IF FORM = ARRAYS THEN BEGIN
		IF INXTYPE <> NIL THEN
		  GETBOUNDS(INXTYPE,LMIN,LMAX);
		IF RUNTMCHECK THEN BEGIN
		  GENSUBRCALL(SUBRCHK);
		  GENCONST(LMIN);
		  GENCONST(LMAX);
		END;
		IF PACKOPT THEN BEGIN
		  GATTR.ACCESS := PACKD;
		  IF INXTYPE <> NIL THEN BEGIN
		    IF LMIN <> 0 THEN BEGIN
		      GEN2(SUB, AUTINC,PC,REGDEF,SP);
		      GENCONST(LMIN)
		    END
		  END
		  ELSE
		    ERROR(606)
		END
		ELSE IF AELTYPE <> NIL THEN
		  SUBSTRSIZE := AELTYPE^.SIZE;
		IF NOT COMPTYPES(INXTYPE,GATTR.TYPTR) THEN
		  ERROR(139);
		GATTR.TYPTR := AELTYPE
	      END
	      ELSE (*FORM = STRINGPARM*)
	      BEGIN
		IF RUNTMCHECK THEN
		  GENSUBRCALL(STRINGINDEX);
		SUBSTRSIZE := 1;
		IF NOT COMPTYPES(GATTR.TYPTR,INTPTR) THEN
		  ERROR(139);
		GATTR.TYPTR := CHARPTR;
		GEN2(MOV,AUTINC,SP,REGDEF,SP);
	      END;
	      IF SUBSTRSIZE <> -1 THEN BEGIN
		IF GATTR.TYPTR <> NIL THEN BEGIN
		  IF (SUBSTRSIZE <> 6) AND (SUBSTRSIZE <= 8) THEN BEGIN
		    IF NOT COMPTYPES ( GATTR.TYPTR , CHARPTR ) THEN
		      WHILE SUBSTRSIZE > 1 DO BEGIN
			SUBSTRSIZE := SUBSTRSIZE DIV 2;
			GEN1(ASL,REGDEF,SP)
		      END;
		  END
		  ELSE BEGIN
		    GEN2(MOV,AUTINC,PC,AUTDEC,SP);
		    GENCONST(SUBSTRSIZE);
		    MULTIPLY;
		  END;
		  GEN2(ADD,AUTINC,SP,REGDEF,SP);
		END
	      END
	    END
	UNTIL SY <> COMMA;
	IF SY = RBRACK THEN
	  INSYMBOL
	ELSE
	  ERROR(12)
      END (*IF SY = LBRACK*)
      ELSE
      (*.*)
      IF SY = PERIOD THEN BEGIN
	WITH GATTR DO BEGIN
	  IF TYPTR <> NIL THEN
	    IF TYPTR^.FORM <> RECORDS THEN BEGIN
	      ERROR(140);
	      TYPTR := NIL
	    END;
	  INSYMBOL;
	  IF SY = IDENT THEN BEGIN
	    IF TYPTR <> NIL THEN BEGIN
	      SRCHSECTION(TYPTR^.FSTFLD,LCP);
	      IF LCP = NIL THEN BEGIN
		ERROR(152);
		TYPTR := NIL
	      END
	      ELSE
		WITH LCP^ DO BEGIN
		  TYPTR := IDTYPE;
		  CASE ACCESS OF
		    DRCT:
		      DPLMT := DPLMT + FLDADDR;
		    INDRCT:
		      IDPLMT := IDPLMT + FLDADDR;
		    PACKD:
		      ERROR(400)
		  END
		END
	    END;
	    INSYMBOL
	  END (*SY = IDENT*)
	  ELSE
	    ERROR(2)
	END (*WITH GATTR*)
      END (*IF SY = PERIOD*)
      ELSE
      (*^*)
      BEGIN
	IF GATTR.TYPTR <> NIL THEN
	  WITH GATTR,TYPTR^ DO
	    IF FORM IN [POINTER,FILES] THEN BEGIN
	      LOAD;
	      IF FORM = POINTER THEN
		TYPTR := ELTYPE
	      ELSE
		TYPTR := FILTYPE ;
              IF NOIO AND (FORM IN [FILES]) THEN
                ERROR(185);
	      IF TYPTR^.FORM = ARRAYS THEN
		IF TYPTR^.ADDRCORR <> 0 THEN BEGIN
		  GEN2(SUB,AUTINC,PC,REGDEF,SP);
		  GENCONST(ELTYPE^.ADDRCORR)
		END;
	      KIND := VARBL;
	      ACCESS := INDRCT;
	      IDPLMT := 0
	    END
	    ELSE
	      ERROR(141);
	INSYMBOL
      END;
      IF NOT (SY IN FSYS OR SELECTSYS) THEN BEGIN
	ERROR(6);
	SKIP(FSYS OR SELECTSYS)
      END
    END;
    (* WHILE*)
    IF GATTR.TYPTR^.FORM = BOUNDLESS THEN
      IF GATTR.TYPTR^.UNSPECLEVEL > 1 THEN
	LOD(LEVEL - FCP^.VLEV, FCP^.VADDR, 2 * (GATTR.TYPTR^.UNSPECLEVEL - 1 ))
  END (*SELECTOR*);


  FUNCTION LARGESET(FATTR: ATTR): BOOLEAN;
  (*CHECKS IF CONVERSIONS ARE NECESSARY*)


  VAR
      L1,L2: INTEGER; (*AND  CALLS THE CONVERSION ROUTINES*)
      RTR: RUNTIMEROUTS;

  BEGIN
    IF NOT COMPTYPES(GATTR.TYPTR,FATTR.TYPTR) THEN BEGIN
      ERROR(606);
      GATTR.TYPTR := NIL
    END
    ELSE BEGIN
      L1 := FATTR.TYPTR^.SIZE;
      L2 := GATTR.TYPTR^.SIZE;
      IF L1 = L2 THEN BEGIN
	IF (FATTR.KIND = VARBL) AND (GATTR.KIND = VARBL) AND
	  (FATTR.TYPTR^.ELTYPE <> GATTR.TYPTR^.ELTYPE) THEN BEGIN
	    ERROR(605);
	    GATTR.TYPTR := NIL
	  END
      END
      ELSE BEGIN
	IF L1 > L2 THEN
	  IF GATTR.KIND = VARBL THEN BEGIN
	    L1 := 2;
	    RTR := REDSN
	  END
	  ELSE
	    RTR := EXPST
	ELSE IF FATTR.KIND = VARBL THEN
	  RTR := REDST
	ELSE BEGIN
	  L1 := 8;
	  RTR := EXPSN
	END;
	GENSUBRCALL(RTR);
      END;
      IF L1 = 8 THEN
	LARGESET := TRUE
      ELSE
	LARGESET := FALSE
    END
  END;
  (*LARGESET*)
    Q))É