    U S E R     M A N U A L  (VERSION 2) APRIL 1979
  
LEXGEN:  AN AUTOMATIC LEXICAL ANALYZER GENERATOR
  
  
1. INPUT
  
INPUT TO LEXGEN IS A SET OF REGULAR EXPRESSIONS USING NOTATION
SIMILAR TO BNF.  THE LEXEMES OF THIS NOTATION ARE TERMINALS,
SETNAMES, NONTERMINALS, AND THE METASYMBOLS ::= ! * + ( ) ; [ ] /
  
(A) ALL NONTERMINAL LEXEMES ( REGULAR EXPRESSION NAMES ) ARE
ENCLOSED WITHIN THE POINTED BRACKETS  <  AND  >.  IF THE CHARACTER
>  IS DESIRED WITHIN THE NONTERMINAL NAME THEN IT MUST APPEAR
TWICE.  THE NONTERMINAL <> IS INVALID.
  
(B) ALL TERMINAL LEXEMES ARE ENCLOSED WITHIN APOSTROPHES.  IF
AN APOSTROPHE IS DESIRED WITHIN THE TERMINAL NAME THEN IT MUST
APPEAR TWICE.  THE TERMINAL '' REPRESENTS THE "NULL STRING."
NOTE:  CONSECUTIVE TERMINALS MUST BE SEPARATED BY ONE OR MORE
BLANKS, OTHERWISE THEY WOULD BE INTERPRETED AS A SINGLE TERMINAL
WITH AN EMBEDDED APOSTROPHE A PART OF THE NAME.
  
(C) NAMES OF SETS OF TERMINALS ( SETNAMES ) ARE ENCLOSED WITHIN
DOUBLE QUOTES.  IF A DOUBLE QUOTE IS DESIRED WITHIN A SETNAME
THEN IT MUST APPEAR TWICE.  THE NULL SETNAME "" IS INVALID.  NOTE:
CONSECUTIVE SETNAMES MUST BE SEPARATED BY ONE OR MORE BLANKS.
  
(D) THE METASYMBOL  ::=  IS USED TO SEPARATE THE REGULAR EXPRESSION
NAME ON THE LEFT FROM ITS DEFINING REGULAR EXPRESSION ON THE RIGHT
OR A SETNAME ON THE LEFT FROM ITS DEFINING SET OF TERMINALS ON THE
RIGHT.
  
(E)  THE PARENTHESES  (  AND  )  ARE USED FOR UNAMBIGUOUSLY
DEMARCATING A REGULAR EXPRESSION.
  
(F)  THE METASYMBOL  !  IS USED AS THE BINARY INFIX OPERATOR
FOR THE UNION OF REGULAR EXPRESSIONS. I.E. IF R1 AND R2 ARE
REGULAR EXPRESSIONS AND L1 AND L2 ARE THE RESPECTIVE LANGUAGES
DENOTED BY THOSE REGULAR EXPRESSIONS, THEN (R1) ! (R2) DENOTES
THE LANGUAGE L1 UNION L2.  THE OPERATOR  !  IS LEFT-ASSOCIATIVE.
  
(G) THE METASYMBOL  *  IS USED FOR THE POSTFIX UNARY OPERATOR
FOR THE (KLEENE) CLOSURE OF A REGULAR EXPRESSION.  I.E. IF R
IS A REGULAR EXPRESSION AND L IS THE LANGUAGE DENOTED BY R THEN
(R)* IS THE REGULAR EXPRESSION DENOTING L* (THE SET OF ALL
STRINGS MADE UP OF ZERO OR MORE REPETITIONS OF STRINGS IN L).
  
(H)  THE METASYMBOL  +  IS USED AS THE POSTFIX UNARY OPERATOR
FOR POSITIVE CLOSURE. I.E. IF R IS A REGULAR EXPRESSION AND L
IS THE LANGUAGE DENOTED BY R THEN (R)+ IS THE REGULAR EXPRESSION
DENOTING  L+ = LL* = L*L ( THE SET OF ALL STRINGS MADE UP OF ONE
OR MORE REPETITIONS OF STRINGS IN L).
  
(I)  THE HIERARCHY OF PRECEDENCE OF THE REGULAR EXPRESSION
OPERATORS ( WHEN NOT ALTERED BY PARENTHESES ) IS
  
        (1)  +  *       (HIGHEST)
        (2) CONCATENATION ( IMPLIED BY JUXTAPOSITION OF ITS
                OPERANDS; CONCATENATION IS LEFT-ASSOCIATIVE)
        (3)  !           (LOWEST)
  
(J)  THE METASYMBOL  ;  IS USED TO SEPARATE INDIVIDUAL SETNAME
OR REGULAR EXPRESSION DEFINITIONS.  NOTE:  NO ; MUST FOLLOW THE
LAST DEFINITION.
  
(K)  THE METASYMBOLS  [  AND  ]  ARE USED TO DEMARCATE A SET OF
TERMINALS TO BE GIVEN A SETNAME.  EACH TERMINAL IN THE SET IS
SEPARATED BY ONE OR MORE BLANKS FROM ADJACENT TERMINALS IN THE
SET.  THE NULL SET  [ ] IS PERFECTLY VALID.
  
(L)  THE USAGE OF SETNAMES ALLOWS FOR SIMPLIFICATION OF THE
CONSTRUCTION OF THE FINITE AUTOMATON FOR A REGULAR EXPRESSION.
( HEREAFTER THE FOLLOWING ABBREVIATIONS WILL BE USED: NFA
FOR NONDETERMINISTIC FINITE AUTOMATON , AND DFA FOR DETERMINISTIC
FINITE AUTOMATON. )
FOR EXAMPLE THE REGULAR EXPRESSION DEFINED BY
  
"DIGIT" ::= [ '0' '1' '2' '3' '4' '5' '6' '7' '8' '9' ] ;
<INTEGER> ::=  "DIGIT" +
  
IS EQUIVALENT TO
  
<INTEGER> ::= ( '0'!'1'!'2'!'3'!'4'!'5'!'6'!'7'!'8'!'9')+
  
THE FIRST FORM IS PREFERRED SINCE IT IS MUCH MORE QUICKLY
CONVERTED TO ITS CORRESPONDING DFA THAN THE LATTER.
  
(M)  PRECEDING THE REGULAR EXPRESSION AND SETNAME DEFINITIONS IS
A LIST OF ALL REGULAR EXPRESSION NAMES WHICH WILL BE THE ACTUAL
TOKENS OF THE REGULAR LANGUAGE--THESE WILL HAVE THEIR CORRESPONDING
FINAL STATES MARKED IN THE FINAL COMBINED DFA.    ALL
REGULAR EXPRESSION NAMES NOT FOUND IN THIS LIST WILL BE CONSIDERED
AS INTERMEDIATE NAMES USED TEMPORARILY IN DEFINING MORE COMPLICATED
REGULAR EXPRESSIONS.  NO SEPARATOR IS USED BETWEEN THE NONTERMINALS
IN THIS LIST.  A SEMICOLON MUST SEPARATE THIS LIST FROM THE
SUCCEEDING REGULAR EXPRESSION AND SETNAME DEFINITIONS.
  
(N)  ALL NONTERMINAL AND SETNAME SYMBOLS USED IN A REGULAR
EXPRESSION DEFINING A NONTERMINAL MUST BE DEFINED PREVIOUSLY.
  
(O)  BLANKS AND TABS ARE COMPLETELY IGNORED EXCEPT WITHIN TERMINALS,
NONTERMINALS, AND SETNAMES.  ALSO THE METASYMBOL ::= MUST NOT HAVE
EMBEDDED BLANKS OR TABS.
  
(P)  NONE OF THE LEXEMES MAY BE SPLIT BETWEEN LINES.  HOWEVER, IT
IS PERFECTLY OKAY TO START A NEW LINE AT ANY TIME AFTER A TOKEN HAS
BEEN COMPLETED ON A LINE.
  
(Q)  ANY LINE WITH  *  IN THE FIRST COLUMN IS TREATED AS A COMMENT.
  
(R)  TABS AND ALL CHARACTERS FROM 40B TO 137B EXCEPT  \ ( WHICH
IS USED INTERNALLY AS AN END OF LINE INDICATOR) MAY OCCUR WITHIN
TERMINALS, SETNAMES, OR NONTERMINALS.
  
(S)  IF A LINE IS LONGER THAN 80 CHARACTERS THEN IT IS SPLIT UP
INTO SEVERAL LINES, ALL BUT POSSIBLY THE LAST OF WHICH ARE 80
CHARACTERS IN LENGTH.
  
(T)  INPUT TO LEXGEN IS A DISK FILE WITH A FILE NAME OF YOUR
CHOICE.
  
(U)  THE REGULAR EXPRESSION FOR THE NULL STRING CAN BE
REPRESENTED BY '' OR ().  ALSO IF IT IS CLEAR FROM THE
CONTEXT SIMPLY CODING NOTHING WILL SUFFICE FOR THE NULL STRING.
THE FOLLOWING IS THE COMPLETE LIST OF SITUATIONS FOR WHICH THE NULL
STRING IS CONSIDERED TO OCCUR BETWEEN THE SYMBOLS (THE SYMBOL $
REPRESENTS END OF INPUT DATA):
::=  $          (  )            !  $
::=  ;          (  !            !  ;
::=  /          /  $            !  /
::=  *          /  ;            !  *
::=  +          /  *            !  +
::=  !          /  +            !  )
(    *          /  !            !  !
(    +
  
FOR EXAMPLE, EACH DEFINITION IN EACH COLUMN BELOW IS EQUIVALENT
TO THE OTHERS IN THAT COLUMN:
  
        <NULL> ::=;             <NULL*> ::= *;
        <NULL> ::= ;            <NULL*> ::= ()*;
        <NULL> ::= '';          <NULL*> ::= ''*;
  
(V) THE REGULAR EXPRESSION FOR THE EMPTY SET MAY BE DEFINED USING
THE NULL SETNAME:
  
"NULL" ::= [  ];
<EMPTY SET> ::= "NULL"
  
(W)  COMPLETE EXAMPLE:
  
***************************************************
* STANDARD PASCAL CONSTANT: [1, P.138]
***************************************************
* TWO TOKENS--CONSTANT AND INTEGER-- ARE DESIRED.
* UNSIGNED INTEGER IS JUST AN INTERMEDIATE NONTERMINAL
***************************************************
<CONSTANT>    <INTEGER>   ;
  
"SIGN" ::=  [  ''  '+'  '-'  ];
"DIGIT" ::= [  '0' '1' '2' '3' '4' '5' '6' '7' '8' '9' ];
<UNSIGNED INTEGER> ::= "DIGIT" +;
<INTEGER> ::= "SIGN" <UNSIGNED INTEGER>;
<CONSTANT> ::= <INTEGER> (  '.'  <UNSIGNED INTEGER>
        !                   '.' <UNSIGNED INTEGER> 'E' <INTEGER>
        !                   'E' <INTEGER>          )
  
  
(X)  THE NFA FOR THE DEFINITION
        <**END-OF-DATA**> ::= '**END-OF-DATA**'
IS AUTOMATICALLY GENERATED BY LEXGEN.  <**END-OF-DATA**> IS
ALSO AUTOMATICALLY MADE A TOKEN.  THUS THE CONVENTION IS THAT
INPUT TO THE SCANNER DEFINED IN APPENDIX B WILL ALWAYS BE
TERMINATED BY THE UNIQUE TERMINAL '**END-OF-DATA**' AND THAT
THE FINAL TOKEN RETURNED FROM THE SCANNER WILL BE <**END-OF-DATA**>.
  
(Y) ADVANCED FEATURE:  THE METASYMBOL  /  IS USED TO SEPARATE THE
ACTUAL REGULAR EXPRESSION DEFINITION ON THE LEFT FROM THE
LOOKAHEAD REGULAR EXPRESSION ON THE RIGHT.  THIS IS THE SAME
NOTATION AS IN [ 1,PP.108-9,115 ].
  
(Z)  THE FORMAL BNF SYNTAX FOR THE INPUT TO LEXGEN IS GIVEN BELOW.
EXPRESSIONS FOLLOW THE PRECEDENCE RULES OF LALR1 WITH ALL OPERATORS
LEFT ASSOCIATIVE [ 2 ]:
  
*************
*  LEXEMES  *
*************
<SYM> ::= "ANY VALID PASCAL CHARACTER EXCEPT \";
<NONTERMINAL> ::= '<' <SYM>+ '>'  ;
<TERMINAL> ::= '''' <SYM>* '''';
<SETNAME> ::= '"' <SYM>+ '"';
***********
* GRAMMAR *
***********
<COMPLETE> ::= <TOKENS> ';' <PRODSET>;
<TOKENS> ::= <NONTERMINAL>
        ! <TOKENS> <NONTERMINAL>;
<PRODSET> ::= <PRODUCTION>
        ! <PRODSET> ';' <PRODUCTION>;
<PRODUCTION> ::= + <NONTERMINAL> '::=' <EXPRESSION>
        ! + <NONTERMINAL> '::=' <EXPRESSION> '/' <EXPRESSION>
        ! <SETNAME> '::=' <TERMINALSET>;
<EXPRESSION> ::= + <EXPRESSION> '*'
        ! + <EXPRESSION> '+'
        ! + <EXPRESSION> <EXPRESSION>
        ! + <TERMINAL>
        ! + <NONTERMINAL>
        ! + <SETNAME>
        ! + '(' <EXPRESSION> ')'
        ! + <EXPRESSION> '!' <EXPRESSION>
        ! ''  ;
<TERMINALSET> ::= <TERMINALHEAD> ']';
<TERMINALHEAD> ::= '['  !  <TERMINALHEAD> <TERMINAL>
  
  
2.  RUNNING LEXGEN
  
  
TO INVOKE LEXGEN TYPE
  
.RUN LEXGEN
  
LEXGEN WILL NEXT SUCCESSIVELY PROMPT
  
INPUT:
OUTPUT:
  
ASKING FOR STANDARD DEC-10 PHYSICAL FILE DESCRIPTIONS FOR THOSE
CORRESPONDING LOGICAL FILES ( DEFAULTS ARE THE RESPECTIVE
DSK:INPUT.  AND DSK:OUTPUT.  ).
  
LEXGEN NEXT PROMPTS WITH
  
        PRINT NFA DIAGRAMS?:
  
IF THE RESPONSE IS Y THEN THE COMPLETE SET OF NFA DIAGRAMS
CREATED DURING THE PROCESSING  WILL BE PRINTED, OTHERWISE
THIS INFORMATION IS NOT PRINTED.  THE NEXT PROMPT IS
  
        PRINT NFA GRAPHS?:
  
IF THE RESPONSE IS Y THEN THE NFA GRAPHS WILL BE
PRINTED, OTHERWISE THEY WILL NOT BE PRINTED.
IF THERE WERE FATAL ERRORS IN THE INPUT THEN THE MESSAGE
  
        FATAL ERROR(S)
  
APPEARS AT THE TERMINAL AND PROCESSING HALTS ( SEE APPENDIX A
FOR THE ERROR MESSAGES AND WARNINGS).  OTHERWISE AFTER COMPLETING
THE CREATION OF THE DFA LEXGEN PROMPTS WITH
  
        MINIMIZE THE DFA?:
  
IF THE RESPONSE IS Y THEN THE DFA WILL BE MINIMIZED AND
THE TABULAR FORM OF THE MINIMIZED DFA WILL BE PRINTED.
  
  
3. OUTPUT
  
  
THE PRINTOUT FOR LEXGEN WILL BE FOUND IN THE LOGICAL FILE OUTPUT.
THE FOLLOWING DESCRIBES EACH SECTION OF THE PRINTOUT ( IF THAT
SECTION HAS BEEN REQUESTED):
  
(A) THE FIRST SECTION OF THE PRINTOUT IS A LISTING OF THE USER
DEFINITIONS.  IF THERE WERE ANY ERRORS OR WARNINGS DURING THE
INITIAL PROCESSING OF THE INPUT THEY WILL BE SHOWN IMMEDIATELY
AFTER THE CORRESPONDING LINE IN ERROR ( SEE APPENDIX A FOR THE
ERROR MESSAGES AND WARNINGS).  IF THE NFA DIAGRAMS HAVE BEEN
REQUESTED THEN  THE ACTUAL CREATION STEPS FOR EACH NFA WILL
FOLLOW EACH CORRESPONDING USER INPUT LINE.  THE NFA DIAGRAMS
ARE OF THE FOLLOWING FORMS:
  
  
TERMINAL TRANSITION
-------- ----------
                     'TERMINAL'
  K:      O-------------------------------->(O)
  
  
TERMINAL SET TRANSITION
-------- --- ----------
                     "SETNAME"
  K:      O-------------------------------->(O)
  
  
UNION OF TWO NFA'S
----- -- --- -----
                    ___________
                   /           \
                  /             \
               ->( 0      L    0 )____
              /   \             /     \
             /     \___________/       \
            /                           !
           /                            V
  K:      O                            (O)
           \                           /\
            \       ___________        /
             \     /           \      /
              \   /             \    /
               ->( 0      M    0 )__/
                  \             /
                   \___________/
  
  
  
POSITIVE CLOSURE OF NFA
-------- ------- -- ---
                    ____________
                   /            \
                  !              \
                  ! ___________   !
                  V/           \  !
                  /             \/
               ->( 0      L    0 )____
              /   \             /     \
             /     \___________/       \
            /                           !
           /                            V
  K:      O                            (O)
  
  
CONCATENATION OF TWO NFA'S
------------- -- --- -----
                  ___________            ___________
                 /           \          /           \
                /             \        /             \
  K:      O--->( 0      L    0 )----->( 0    M    (O) )
                \             /        \             /
                 \___________/          \___________/
  
  
(KLEENE) CLOSURE OF NFA
-------- ------- -- ---
                    ____________
                   /            \
                  !              \
                  ! ___________   !
                  V/           \  !
                  /             \/
               ->( 0      L    0 )____
              /   \             /     \
             /     \___________/       \
            /                           !
           /                            V
  K:      O                            (O)
           \                           /\
            \                          /
             \________________________/
  
  
RELABEL A NFA
------- - ---
  K******* IS THE NEW LABEL FOR ****  L
  
  
ASSIGN NFA TO A REGULAR EXPRESSION NAME
------ --- -- - ------- ---------- ----
<NONTERMINAL>*******IS ASSIGNED THE NFA****  K
  
  
COPY NFA FROM REGULAR EXPRESSION NAME
---- --- ---- ------- ---------- ----
K****** IS COPIED FROM ******<NONTERMINAL>
  
  
  
THE SYMBOL K REPRESENTS THE INTEGER LABEL TO BE  ASSOCIATED WITH THE
CURRENT NFA.  THE LABELS L AND M REPRESENT THE MOST CURRENT
NFA WHICH HAS THAT RESPECTIVE LABEL.  ANY TRANSITIONS WITHOUT
AN ARC LABEL ARE ASSUMED TO BE LABELLED WITH EPSILON (NULL STRING).
THE INITIAL STATE OF EACH NFA IS INDICATED BY "OH" AND THE
FINAL STATE BY A PARENTHESIZED "OH."  AS SUCH THE DIAGRAMS ARE
VERY SIMILAR TO THOSE FOUND IN THE DRAGON BOOK [ 1 ,PP. 95-99]
WITH THE FOLLOWING EXCEPTIONS: (1) A SINGLE ARC OF A TRANSITION
DIAGRAM MAY BE LABELLED WITH A SETNAME, (2) POSITIVE CLOSURE HAS
BEEN ADDED, (3) CONCATENATION USES TWO ADDITIONAL "EPSILON"
TRANSITIONS ( THIS SIMPLIFIES THE CONSTRUCTION ALGORITHM ).
  
  
(B) THE NEXT SECTION ( IF REQUESTED ) IS THE SET OF NFA'S FOR
EACH NONTERMINAL WHICH HAS BEEN DESIGNATED AN ACTUAL TOKEN
IN THE USER'S INPUT DEFINITIONS.   THE DATA STRUCTURE
FOR THE NFA IS A GRAPH WITH EACH NODE CONSISTING OF AN ARC-LABEL
WHICH MAY BE EITHER A SINGLE TERMINAL OR THE SETNAME FOR A
SET OF TERMINALS, AND TWO POINTER FIELDS.  FOR EXAMPLE THE NFA
  
                 'CONSTANT'
  K:    O--------------------------------->(O)
  
WOULD BE REPRESENTED BY TWO NODES SUCH AS
  
10000:'CONSTANT'       10001    ****NIL****
10001:''         ****NIL****    ****NIL****
  
PRECEDING THE NFA FOR EACH NONTERMINAL IS THE HEADING
  
*** NFA <X>:
  
INDICATING THAT THE NFA FOR THE REGULAR EXPRESSION NAME X
FOLLOWS.
  
  
(C) THE NEXT SECTION OF THE OUTPUT IS THE DFA CREATED FROM
THE COMBINED NFA'S.  THE TABULAR FORMAT IS SIMILAR TO THE
DRAGON BOOK [  1,. 94] WITH THE ROWS BEING LABELLED WITH
THE STATES ( STATE 1 IS THE INITIAL STATE ) AND THE COLUMNS
BEING LABELLED WITH THE CODES FOR THE TERMINALS ( SEE ALSO
THE NEXT SECTION OF OUTPUT: CODES FOR THE TERMINAL SYMBOLS ).
EACH ENTRY DELTA[S, T] REPRESENTS THE NEW STATE AFTER
A TRANSITION ALONG AN ARC LABELLED WITH T FROM STATE S.  THE STATE
0 REPRESENTS NO TRANSITION ( OR EQUIVALENTLY TRANSITION TO
THE SPECIAL "ERROR" OR "DEAD" STATE LABELLED ZERO).
  
  
(D)  THIS NEXT SECTION IS THE CODES FOR THE TERMINAL SYMBOLS
USED IN THE DFA.
  
(E) THE NEXT SECTION LISTS ALL TOKENS WHICH HAVE FINAL STATES
OR BACKUP STATES WITHIN THE CORRESPONDING DFA STATE (SEE APPENDIX
B FOR DEFINITIONS OF BACKUP AND FINAL STATES ).
  
(F) IF REQUESTED THE MINIMIZED DFA TABLE WILL APPEAR NEXT.
IT FOLLOWS THE SAME FORMAT AS THE ORIGINAL DFA TABLE EXCEPT
THAT THE NEW START STATE WILL NOT NECESSARILY BE STATE 1
AND SO IS INDICATED IMMEDIATELY AFTER THE TABLE.
  
(G) IF THE DFA HAS BEEN MINIMIZED THE TOKENS HAVING FINAL
STATES OR BACKUP STATES  IN EACH MINIMIZED DFA STATE ARE LISTED NEXT.
  
(H) ONE OF THE FOLLOWING MESSAGES COMES NEXT:
  
NO ERRORS
WARNING(S) GIVEN
RECOVERY FROM MAJOR ERROR(S)
FATAL ERROR(S)
  
SEE APPENDIX A FOR ANY WARNINGS OR MESSAGES ASSOCIATED WITH
THE LATTER THREE MESSAGES.
  
(I) THE FINAL LINE OF THE PRINTOUT IS THE TOTAL RUN TIME
IN SECONDS.
  
REFERENCES
  
  
[1] AHO, A.V., AND ULLMAN, J.D. PRINCIPLES OF COMPILER DESIGN.
        ADDISON-WESLEY, READING, MASS., 1977.
  
  
[2] JEFFORDS, R.D.  USER MANUAL (VERSION 2) ,
        LALR1:  AN AUTOMATIC LALR(1) PARSER GENERATOR,
        UNIV. MISS., APR. 1979.
  
APPENDIX A -- ERROR MESSAGES
  
  
  
-----------------------------------------------------------
W A R N I N G S :
  
  
*****     WARNING: SYMBOL TRUNCATED
        OCCURS WHEN A TERMINAL, SETNAME, OR NONTERMINAL IS
        LONGER THAN 20 CHARACTERS AND HAS BEEN TRUNCATED TO
        20 CHARACTERS.  THE USER MUST ENSURE THAT THE FIRST 20
        CHARACTERS OF DIFFERENT SYMBOLS OF THE SAME TYPE
        ARE UNIQUE (SYMGET).
  
*****     WARNING: LINE IS SPLIT
        THIS WARNING OCCURS IF A LINE IS LONGER THAN 80 CHARACTERS.
        IN THIS CASE THE LINE IS SPLIT UP INTO TWO OR MORE LINES, ALL
        BUT POSSIBLY THE LAST OF WHICH ARE 80 CHARACTERS (SYMGET).
  
*****     WARNING: <NONTERMINAL> REASSIGNED
        THE USER HAS TWO OR MORE DEFINITIONS FOR THIS NONTERMINAL.
        LEXGEN USES THE LAST ONE (SEMANT).
  
*****     WARNING: DUPLICATE TOKEN
        A NONTERMINAL OCCURS TWO OR MORE TIMES IN THE INITIAL LIST
        OF TOKENS.  EXTRA OCCURRENCES ARE SIMPLY IGNORED (SEMANT).
  
*****     WARNING: "SETNAME" REASSIGNED
        THE USER HAS TWO OR MORE DEFINITIONS FOR THIS SETNAME.
        LEXGEN USES THE LAST ONE (SEMANT).
  
*****     WARNING: NO NFA <NONTERMINAL>
        THE NONTERMINAL WAS SPECIFIED TO BE A TOKEN BUT NO
        VALID DEFINITION WAS FOUND.  THE NONTERMINAL IS IGNORED
        IN FURTHER PROCESSING (INPUTG).
  
  
------------------------------------------------------
R E C O V E R A B L E    E R R O R S
  
THESE ARE MAJOR ERRORS BUT LEXGEN IS ABLE TO PATCH THINGS
UP AND CONTINUE PROCESSING.
  
*****     <NONTERMINAL> IS UNDEFINED; USE NULL STRING NFA & CONT.
        ALL NONTERMINALS USED IN A REGULAR EXPRESSION DEFINITION
   MUST BE PREVIOUSLY DEFINED.  THE PATCH IN THIS CASE IS TO
        USE THE NULL STRING NFA AND TO CONTINUE (SEMANT).
  
*****     "SETNAME" IS UNDEFINED; USE NULL STRING NFA & CONT.
        ALL SETNAMES USED IN A REGULAR EXPRESSION DEFINITION MUST
        BE PREVIOUSLY DEFINED.  THE PATCH IN THIS CASE IS TO USE
        THE NULL STRING NFA AND TO CONTINUE (SEMANT).
  
*****     SYNTAX ERROR: WILL FLUSH TO NEXT ;/EOF & CONT.
        THE LEXGEN PARSER HAS ENCOUNTERED A SYNTAX ERROR. THE
        INPUT IS FLUSHED PAST ; OR TO END-OF-INPUT AND
        PROCESSING CONTINUES (INPUTG).
  
*****     <> OR "" INVALID
        THE INVALID <> OR "" IS COMPLETELY IGNORED (SYMGET).
  
*****     ::= MISTYPED
        THE MISTYPED LEXEME IS COMPLETELY IGNORED (SYMGET).
  
*****     ILLEGAL CHARACTER 'X'
        THIS MESSAGE OCCURS IF AN INVALID INPUT CHARACTER IS
        FOUND.  THE ILLEGAL CHARACTER 'X' IS COMPLETELY
        IGNORED (SYMGET).
  
*****     SYMBOL CONTINUES PAST END OF LINE
        LEXEMES MUST NOT EXTEND ACROSS LINE BOUNDARIES.  THIS
        MESSAGE ALSO OCCURS IF SPLITTING A LONG LINE BREAKS
        UP A LEXEME.  THE LEXEME IS COMPLETELY IGNORED (SYMGET).
  
  
-----------------------------------------------
F A T A L        E R R O R S
  
PROCESSING HALTS IMMEDIATELY AFTER THE MESSAGE.
THESE MESSAGES ARE CAUSED BY ATTEMPTS TO SURPASS
ARRAY BOUNDS.  THESE MESSAGES ALL APPEAR AT THE TERMINAL.
  
  
  
TERMINAL SYMBOL TABLE OVERFLOW
SETNAME SYMBOL TABLE OVERFLOW
NONTERMINAL SYMBOL TABLE OVERFLOW
        IT IS NECESSARY TO INCREASE MAXTER AND RECOMPILE
        IN THE FIRST CASE, OR TO INCREASE MAXNONTER/MAXTERSETS
        AND MAXNS AND RECOMPILE IN THE LATTER TWO CASES (INPUTG).
  
  
  
TOO MANY I-F STATES
        IT IS NECESSARY TO INCREASE MAXIFSTATES AND RECOMPILE
        SINCE MORE THAN THIS BOUND OF IMPORTANT/FINAL STATES
        WERE REQUIRED FOR THE CREATION OF THE DFA (CREATEDFA).
  
  
  
TOO MANY DFA STATES
        IT IS NECESSARY TO INCREASE MAXDFASTATES AND RECOMPILE
        (CREATEDFA).
  
  
  
PARSER STACK OVERFLOW
        IT IS NECESSARY TO INCREASE MAXSTACK AND RECOMPILE OR REVISE
        THE INPUT TO USE FEWER LEVELS OF PARENTHESIZATION(INPUTG).
  
APPENDIX B -- SCANNER ALGORITHMS
  
THE SCANNER ALGORITHMS USE EITHER THE NON-MINIMIZED OR THE
MINIMIZED TABLE ( HEREAFTER CALLED DELTA ) FOR THE DFA AND
THE RESPECTIVE FINAL/BACKUP STATE CORRESPONDENCES.  THE USER
MUST FILL IN THE BOUNDS INDICATED BY ??? AND ANY OTHER
REQUIRED INFORMATION.  THE SIMPLER ALGORITHM NOT REQUIRING THE
LOOKAHEAD FEATURE IS OBTAINED BY DELETING ALL LINES PRECEDED BY @.
  
FINAL STATES (CONTAINING TOKENS MARKED * IN THE OUTPUT)
INDICATE STATES WHICH REPRESENT HAVING RECOGNIZED A COMPLETE
TOKEN OF THE USER'S REGULAR LANGUAGE (MAY INCLUDE LOOKAHEAD).
IF THE LOOKAHEAD WAS REQUIRED THEN IT IS NECESSARY TO BACKUP
TO THE CORRESPONDING BACKUP STATE (CONTAINING THE MATCHING
TOKEN NOT MARKED *).
  
EACH TOKEN CAN ONLY BE ASSOCIATED UNAMBIGUOUSLY WITH ONE
FINAL STATE SO THE CONVENTION IS TO GIVE PRIORITY TO THE
FIRST OF THE CONFLICTING TOKENS AS ORDERED BY THE INITIAL
LIST OF TOKENS.  THIS PROCEDURE IS DONE AUTOMATICALLY
BEFORE MINIMIZATION OF THE DFA SO IN FACT THE MINIMIZED
DFA HAS AT MOST ONE FINAL TOKEN ASSOCIATED WITH EACH STATE.
NOTE, HOWEVER, THAT IT IS NECESSARY TO RETAIN ALL BACKUP
TOKENS ASSOCIATED WITH A STATE.
  
IMPORTANT :  NOTE THE  DISTINCTION IN THIS
APPENDIX BETWEEN TOKEN, WHICH IS USED TO INDICATE THE
NONTERMINALS IN THE USER'S INITIAL LIST PRECEDING HIS
REGULAR EXPRESSION DEFINITIONS, AND LEXEME, WHICH HERE
REFERS TO THE ACTUAL COMPLEX SYMBOL RETURNED BY THE SCANNER.
  
 (********************************************)
 (*   SCANNER ALGORITHM FOR DELTA CREATED    *)
 (*      BY LEXGEN                           *)
@(*    INCORPORATES THE LOOKAHEAD FEATURE    *)
 (********************************************)
CONST
@MINSTACK = 0; (* INDEX OF BOTTOM OF STACK-NEVER USED *)
@MAXSTACK = ???;
 MININDEX = 0; (* MIN INDEX USED TO ACCESS BUFFER *)
 MAXINDEX = ???;
 BUFFERSIZE = MAXINDEX+1;
 ERROR = 0; (* ERROR TOKEN CODE *)
 MINTOKEN = 1; (* MIN CODE FOR NON-ERROR TOKEN *)
 MAXTOKEN = ???;
 DEAD = 0; (* CODE FOR THE DEAD OR ERROR STATE *)
 DFASTATE1 = ???; (* CODE FOR INITIAL STATE OF DFA *)
 MINDFASTATE = 1; (* CODE FOR MIN STATE OF DFA *)
 MAXDFASTATE = ???; (* CODE FOR MAX STATE OF DFA *)
 MINTERMINAL = ???; (* MIN TERMINAL CODE *)
 EODATA = -1; (* CODE FOR END-OF-DATA *)
  
TYPE
 STATERANGE = MINDFASTATE..MAXDFASTATE;
 EXSTATERANGE = DEAD..MAXDFASTATE;
 TOKENRANGE = MINTOKEN..MAXTOKEN;
 EXTOKENRANGE = ERROR..MAXTOKEN;
 TERMINALRANGE = MINTERMINAL..EODATA;
 INDEXRANGE = MININDEX..MAXINDEX;
@STACKRANGE = MINSTACK..MAXSTACK;
 LEXTOKEN = RECORD
              TOKEN_TYPE: ???;
              MORE: ??? (* POINTER TO SYMBOL TABLE,
                           CODE TO DIFFERENTIATE
                           DIFFERENT SYMBOLS SUCH
                           AS RELATIONAL OPERATORS
                           OF THE SAME TOKEN_TYPE, ETC. *)
            END;
  
VAR
 DELTA: ARRAY[STATERANGE,TERMINALRANGE] OF EXSTATERANGE;
  
 FINAL: ARRAY[EXSTATERANGE] OF EXTOKENRANGE;  (* IF STATE
       IS FINAL THEN FINAL[STATE] IS TOKEN ASSOCIATED WITH THAT
       STATE; OTHERWISE FINAL[STATE] IS ERROR *)
  
@BACKUP: ARRAY[STATERANGE] OF SET OF TOKENRANGE; (* BACKUP[STATE]
@       IS THE SET OF ALL BACKUP TOKENS ASSOCIATED WITH THAT STATE*)
  
@LOOKAHEADFINAL: ARRAY[EXSTATERANGE] OF BOOLEAN;
@       (* LOOKAHEADFINAL[STATE] IS TRUE IF LOOKAHEAD WAS
@       REQUIRED FOR RECOGNIZING THAT TOKEN ASSOCIATED WITH
@       THAT STATE *)
 BEGIN_INDEX,END_INDEX: INDEXRANGE;
 LEXEME: LEXTOKEN;
(***************************************)
PROCEDURE SCAN(VAR BEGIN_INDEX,END_INDEX: INDEXRANGE;
               LEXEME: LEXTOKEN);
  
VAR
  NEWTOKEN: BOOLEAN;
  CURRSTATE,CURRFINAL: EXSTATERANGE;
  BUFFER: ARRAY[INDEXRANGE] OF TERMINALRANGE;
  OLDINDEX: INDEXRANGE;
@ STACK: ARRAY[STACKRANGE] OF
@         RECORD
@          INDEX: INDEXRANGE;
@          STATE: STATERANGE
@         END;
@ TOS: STACKRANGE; (* CURRENT TOP OF STACK INDEX *)
@(*******************************************************)
@PROCEDURE PUSH(ININDEX: INDEXRANGE; INSTATE: STATERANGE);
@BEGIN (* PUSH *)
@  TOS := TOS + 1;
@  WITH STACK[TOS] DO
@    BEGIN
@      INDEX := ININDEX;
@      STATE := INSTATE
@    END
@END (* PUSH *);
  
(****************************)
PROCEDURE SEMANTICS(CURRSTATE: EXSTATERANGE);
BEGIN (* SEMANTICS *)
< DO SEMANTICS ASSOCIATED WITH CURRSTATE.
 NOTE THAT EXCEPT FOR THE INITIAL CALL OF SEMANTICS
 BY SCAN THAT END_INDEX POINTS TO CHARACTER LABELLING
 ARC LEADING TO CURRSTATE >
END (* SEMANTICS *);
  
(************************************)
PROCEDURE GETCHAR(NEWTOKEN: BOOLEAN);
BEGIN (* GETCHAR *)
  < THIS PROCEDURE OBTAINS THE NEXT INPUT CHARACTER
  ( WHICH IS ASSUMED TO BE **END-OF-DATA** IF NO
  MORE DATA ) AND MODIFIES BEGIN_INDEX AND END_INDEX
  AS NECESSARY DEPENDING UPON THE BUFFERING SCHEME
  SO THAT (1) IF NEWTOKEN THEN BEGIN_INDEX POINTS TO THE
  INPUT CHARACTER JUST OBTAINED, ELSE BEGIN_INDEX POINTS TO
  SAME CHARACTER THAT IT POINTED TO BEFORE, AND (2)
  END_INDEX IS THE INDEX OF THE NEW CHARACTER JUST
  OBTAINED.  SCAN ALLOWS FOR EITHER SEQUENTIAL
  OR CIRCULAR BUFFER >
END (* GETCHAR *);
  
  
BEGIN (* SCAN *)
  NEWTOKEN := TRUE;
@ TOS := MINSTACK;
  CURRSTATE := DFASTATE1; (* START IN INITIAL STATE *)
  CURRFINAL := DEAD; (* WILL BACK UP TO DEAD IF NOTHING ELSE *)
  OLDINDEX := 0;
  
  WHILE (CURRSTATE <> DEAD) DO
    BEGIN
      SEMANTICS(CURRSTATE);
@     IF (BACKUP[CURRSTATE] <> [ ])
@     THEN PUSH((END_INDEX-BEGIN_INDEX) MOD BUFFERSIZE,CURRSTATE);
      IF (FINAL[CURRSTATE] <> ERROR)
      THEN
       BEGIN
        CURRFINAL := CURRSTATE;
        OLDINDEX := ( END_INDEX - BEGIN_INDEX ) MOD BUFFERSIZE;
       END;
      GETCHAR(NEWTOKEN);
      NEWTOKEN := FALSE;
      CURRSTATE := DELTA[CURRSTATE,BUFFER[END_INDEX]];
    END;
@  IF (LOOKAHEADFINAL[CURRFINAL]
@  THEN
@   BEGIN
@     WHILE NOT (FINAL[CURRFINAL] IN BACKUP[STACK[TOS].STATE) DO
@     TOS := TOS - 1;
@     END_INDEX := (STACK[TOS].INDEX + BEGIN_INDEX) MOD BUFFERSIZE
@   END  ELSE
    END_INDEX := (BEGIN_INDEX + OLDINDEX) MOD BUFFERSIZE;
   < COMPUTE LEXEME GIVEN FINAL[CURRFINAL], BEGIN_INDEX,
     END_INDEX, ETC. >
END (* SCAN *);
BEGIN (* MAIN *)
        .
        .
        .
    SCAN(BEGIN_INDEX,END_INDEX,LEXEME); (* AS NEEDED UNTIL
         END-OF-DATA LEXEME IS RETURNED *)
        .
        .
        .
END (* MAIN *).
    @fç