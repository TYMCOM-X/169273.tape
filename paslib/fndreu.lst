            File DSK:SCNREU.PAS[3,136773]   Compiled 25-Apr-83 16:08   Pascal, Version 1B

            File DSK:SCNREU.PAS[3,136773]   Compiled 25-Apr-83 16:08   Pascal, Version 1B

            File DSK:SCNREU.PAS[3,136773]   Compiled 25-Apr-83 16:08   Pascal, Version 1B

            File DSK:SCNREU.PAS[3,136773]   Compiled 25-Apr-83 16:08   Pascal, Version 1B





			     $$$     $$$    $   $   $$$$    $$$$$   $   $
			    $   $   $   $   $$  $   $   $   $       $   $
			    $       $       $ $ $   $   $   $       $   $
			     $$$    $       $  $$   $$$$    $$$     $   $
			        $   $       $   $   $ $     $       $   $
			    $   $   $   $   $   $   $  $    $       $   $
			     $$$     $$$    $   $   $   $   $$$$$    $$$ 


			    scnreu - SCANNR Regular Expression Utilities


Options in effect: 

	CHECK, NOSPECIAL, NOMAP, NOSYMBOLS, NOCALLS, NOASSEMBLY, NOXREF, TRACE, QBLOCKS, NOOPTIMIZE, 
	CODE, NODEBUG, FINISH, NOGLOBAL, NOMAINSEG, NOOVERLAY, AUTOQUICK, AUTOSOURCE, NOSTANDARD, 
	LENGTH (43), WIDTH (102), STORAGE (2048), ALLOC (0), ENABLE(P10, CHAR)




            File DSK:SCNREU.PAS[3,136773]   Compiled 25-Apr-83 16:08   Pascal, Version 1B

            File DSK:SCNREU.PAS[3,136773]   Compiled 25-Apr-83 16:08   Pascal, Version 1B

            File DSK:SCNREU.PAS[3,136773]   Compiled 25-Apr-83 16:08   Pascal, Version 1B

            File DSK:SCNREU.PAS[3,136773]   Compiled 25-Apr-83 16:08   Pascal, Version 1B
            File DSK:SCNREU.PAS[3,136773]   Compiled 25-Apr-83 16:08   Pascal, Version 1B

            File DSK:SCNREU.PAS[3,136773]   Compiled 25-Apr-83 16:08   Pascal, Version 1B

            File DSK:SCNREU.PAS[3,136773]   Compiled 25-Apr-83 16:08   Pascal, Version 1B

            File DSK:SCNREU.PAS[3,136773]   Compiled 25-Apr-83 16:08   Pascal, Version 1B





			     $$$     $$$    $   $   $$$$    $$$$$   $   $
			    $   $   $   $   $$  $   $   $   $       $   $
			    $       $       $ $ $   $   $   $       $   $
			     $$$    $       $  $$   $$$$    $$$     $   $
			        $   $       $   $   $ $     $       $   $
			    $   $   $   $   $   $   $  $    $       $   $
			     $$$     $$$    $   $   $   $   $$$$$    $$$ 


			    scnreu - SCANNR Regular Expression Utilities


Options in effect: 

	CHECK, NOSPECIAL, NOMAP, NOSYMBOLS, NOCALLS, NOASSEMBLY, NOXREF, TRACE, QBLOCKS, NOOPTIMIZE, 
	CODE, NODEBUG, FINISH, NOGLOBAL, NOMAINSEG, NOOVERLAY, AUTOQUICK, AUTOSOURCE, NOSTANDARD, 
	LENGTH (43), WIDTH (102), STORAGE (2048), ALLOC (0), ENABLE(P10, CHAR)




            File DSK:SCNREU.PAS[3,136773]   Compiled 25-Apr-83 16:08   Pascal, Version 1B

            File DSK:SCNREU.PAS[3,136773]   Compiled 25-Apr-83 16:08   Pascal, Version 1B

            File DSK:SCNREU.PAS[3,136773]   Compiled 25-Apr-83 16:08   Pascal, Version 1B

            File DSK:SCNREU.PAS[3,136773]   Compiled 25-Apr-83 16:08   Pascal, Version 1B
MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 0                                                                                       PAGE 1

    1	$TITLE scnreu - SCANNR Regular Expression Utilities
    2	$LENGTH 43
    3	
    4	(*   +--------------------------------------------------------------+
    5	     |                                                              |
    6	     |                         S C N R E U                          |
    7	     |                         - - - - - -                          |
    8	     |                                                              |
    9	     +--------------------------------------------------------------+
   10	     
   11	     MDSI, Company Confidential
   12	     
   13	     SYSTEM:  SCANNR Lexical Scanner Builder
   14	     
   15	     STARTED:  12 June 1978
   16	     
   17	     PURPOSE:   This  module  manipulates  regular   expressions.   A
   18	        regular expression is represented as a linked tree structure,
   19	        where nodes may represent literal expressions  or  functional
   20	        combinations of expressions.
   21	     
   22	     ENTRY POINTS:
   23	     
   24	        lambda      is  a public variable containing a pointer to the
   25	                    regular expression representing the null string.
   26	     
   27	        phi         is a public variable containing a pointer to  the
   28	                    regular expression representing the empty set.
   29	     
   30	        anychar     is  a public variable containing a pointer to the
   31	                    regular  expression   representing   any   single
   32	                    character.
   33	     
   34	        anystring   is  a public variable containing a pointer to the
   35	                    regular expression representing any string.
   36	     
   37	        initre      is called  to  initialize  the  'lambda',  'phi',
   38	                    'anychar',  and  'anystring'  regular  expression
   39	                    constants.  It must be called before the rest  of
   40	                    this module is used.MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 0                                                                                       PAGE 2

   41	     
   42	        clearre     frees   the   'lambda',   'phi',  'anychar',  and
   43	                    'anystring' regular expression constants.
   44	     
   45	        literal     is called with a  data  element,  and  returns  a
   46	                    literal  regular expression with the data element
   47	                    as its literal value.
   48	     
   49	        lit_range   is called with  a  pair  of  data  elements,  and
   50	                    returns  a literal range regular expression whose
   51	                    endpoints are the literal values  represented  by
   52	                    the data elements.
   53	     
   54	        iterate     is  called  with  a  regular  expression "X", and
   55	                    returns the regular expression "X *".
   56	     
   57	        negate      is called with an  operand,  and  returns  a  not
   58	                    operator applied to the operand.
   59	     
   60	        conjoin     is called with a pair of operands, and returns an
   61	                    and operator applied to the operands.
   62	     
   63	        alternate   is called with a pair of operands, and returns an
   64	                    or operator applied to the operands.
   65	     
   66	        catenate    is  called with a pair of operands, and returns a
   67	                    concatenation operator applied to the operands.
   68	     
   69	        derivative  is called with a regular expression  and  a  data
   70	                    element  (representing  a  literal  symbol),  and
   71	                    returns  a  regular  expression  which   is   the
   72	                    derivative  of  the input expression with respect
   73	                    to the literal.
   74	     
   75	        re_compare  is called with a pair of regular expressions, and
   76	                    returns  a  relation  code indicating whether the
   77	                    first is less than, similar to  or  greater  than
   78	                    the second.  Similarity is a weaker relation than
   79	                    equality  of  regular  expressions.  Two  regular
   80	                    expressions are defined to be similar if they areMODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 0                                                                                       PAGE 3

   81	                    both phi or lambda, if they are the same  literal
   82	                    or  literal  range,  or  if  they  have  the same
   83	                    operator and similar operands.  The  ordering  on
   84	                    regular  expressions  is  purely  arbitrary,  but
   85	                    useful.
   86	     
   87	        re_null     is a predicate which takes a regular  expression,
   88	                    and  returns  true if the null string (lambda) is
   89	                    in the set of strings denoted by the expression.
   90	     
   91	        litval      is called with a regular expression and  an  data
   92	                    element variable.  If the regular expression is a
   93	                    simple  literal  expression,  Litval   sets   the
   94	                    variable  to the literal value, and returns true.
   95	                    Otherwise, litval returns false and the  variable
   96	                    is unchanged.
   97	     
   98	        lithead     is  called  with  a  regular expression, two data
   99	                    element  variables,  and  a  regular   expression
  100	                    variable.  If  the regular expression begins with
  101	                    a literal or a literal range,  Lithead  sets  the
  102	                    variables  to the minimum and maximum elements of
  103	                    the  range  and  the  remainder  of  the  regular
  104	                    expression, and returns true.  Otherwise, Lithead
  105	                    returns false.
  106	     
  107	     NOTES:  These routines apply  various  simplification  rules  as
  108	        they create their results.  Since all regular expressions are
  109	        created by the routines in this module, this means  that  all
  110	        regular  expressions  are  guaranteed  to  be  in  simplified
  111	        (canonical) form.
  112	     
  113	        A single regular expression may be an operand of  any  number
  114	        of  other regular expressions.  (That is, regular expressions
  115	        are really represented as  directed  acyclic  graphs,  rather
  116	        than  as  trees.)   Consequently,  a regular expression, once
  117	        created, must never be modified.
  118	     
  119	        The following conditional compilation switches are defined:
  120	     MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 0                                                                                       PAGE 4

  121	        CHAR controls the  basic  data  type  (data_element)  of  the
  122	             regular expression type.  It is used in SCNRE.TYP.
  123	     
  124	        DUMP  controls  whether  code is compiled for dumping regular
  125	             expressions.  If DUMP is not  enabled,  then  the  PrtRe
  126	             routine will be a no-op.
  127	     
  128	     ---------------------------------------------------------------- *)MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 1            declarations                                                               PAGE 5

    2	
    3	$INCLUDE scannr.typ
    1	const
    2	
    3	    line_size = 255;
    4	
    5	type
    6	
    7	    number = 0 .. 32767;
    8	
    9	    reg_exp = ^ reg_exp_node;
   10	
   11	    line_index = 0 .. line_size + 1;
   12	
   13	    parm_string = packed array [1..*] of char;
   14	
   15	    relation = ( lss, eql, gtr );
    4	$INCLUDE scnre.typ
    1	
    2	(*********   Regular Expressions   **********
    3	
    4	    Regular expressions are represented internally by pointers of type
    5	    'reg_exp', which point to 'reg_exp_node's.  Regular expression nodes
    6	    are created and disposed by the SCNREA (Regular Expression Allocation)
    7	    module.  SCNREA contains NewRe, which creates skeletal nodes; UseRe,
    8	    which records references to nodes; and FreeRe, which deletes references
    9	    and disposes the nodes.  The contents of nodes are manipulated by the
   10	    SCNREU (Regular Expression Utility) module.  SCNREU contains a collec-
   11	    tion of routines for creating regular expressions with specified oper-
   12	    ators and operands; Derivative, which returns the derivative of an
   13	    expression with respect to a given symbol; and Similar, which tests
   14	    two expressions for similarity.  Outside SCNREA and SCNREU, only the
   15	    pointers to regular expression nodes should be manipulated.  No routine
   16	    outside of these modules should ever create or dispose of a regular
   17	    expression node, or access any field of one.
   18	
   19	    The fields of a regular expression node are:
   20	
   21	    REFS -- The number of extant references to the node.  This field should
   22	        be accessed only by routines in the SCNREA module, which use it forMODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 2-0          declarations                                                               PAGE 6

   23	        node allocation and deallocation.
   24	
   25	    L_IN -- A boolean flag, indicating whether the empty string (lambda) is
   26	        in the set of strings denoted by this regular expression.  This
   27	        field is set by the creation routines in SCNREU, and tested by the
   28	        Derivative routine.
   29	
   30	    REG_OP -- The type of regular expression this is.  This field is set
   31	        when the node is created by NewRe, and is determined by which of
   32	        the SCNREU routines the node is created by.  The regular expression
   33	        operators are:
   34	            lambda_op:      The empty string
   35	            phi_op:         The set containing no strings (the empty set)
   36	            literal_op:     A string containing a single literal symbol
   37	            lit_range_op:   The set of strings containing single literal
   38	                            symbols from some range
   39	            star_op:        The set of all sequences of zero or more strings
   40	                            from a given regular expression
   41	            not_op:         The set of all strings which are not in a
   42	                            given regular expression
   43	            cat_op:         The set of all strings formed by concatenation
   44	                            of strings from two given regular expressions
   45	            or_op:          The set of all strings which are in either of
   46	                            two other given regular expressions
   47	            and_op:         The set of all strings which are in both of
   48	                            two other given regular expressions
   49	
   50	    The following fields are set by the creation routines in SCNREU:
   51	
   52	    LIT_VAL -- The literal symbol for a 'literal_op' node.
   53	
   54	    MIN_LIT, MAX_LIT -- The bounds of the range of literal symbols for a
   55	        'lit_range_op' node.
   56	
   57	    OPERAND -- The given regular expressions for a 'star_op' or 'not_op'
   58	        node.
   59	
   60	    LEFTOP, RIGHTOP -- The two given regular expressions for a 'cat_op',
   61	        'or_op', or 'and_op' node.
   62	MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 2-0          declarations                                                               PAGE 7

   63	    The conditional compilation flag CHAR controls the type of the basic data
   64	    elements from which regular expressions are constructed.  If CHAR is true,
   65	    the DataElement type is equivalent to type Char.  Normally, DataElement is
   66	    equivalent to type Integer.  *)
   67	
   68	
   69	type
   70	
   71	$IF    char  data_element = char;
   72 *	$IFNOT char  data_element = 0 .. maximum (integer);
   73	
   74	    reg_ops =
   75	      ( lambda_op, phi_op, literal_op, lit_range_op,
   76	        star_op, not_op, cat_op, or_op, and_op );
   77	
   78	    reg_exp_node = packed record
   79	      refs: integer;
   80	      l_in: boolean;
   81	      case reg_op: reg_ops of
   82	        lambda_op,
   83	        phi_op:
   84	          ( );
   85	        literal_op:
   86	          ( lit_val: data_element );
   87	        lit_range_op:
   88	          ( min_lit, max_lit: data_element );
   89	        star_op,
   90	        not_op:
   91	          ( operand: reg_exp );
   92	        cat_op,
   93	        or_op,
   94	        and_op:
   95	          ( leftop, rightop: reg_exp )
   96	    end (* reg_exp_node *);
    5	
    6	$INCLUDE scnrea
    1	
    2	(*********   S C N R E A  - -  SCANNR Regular Expression Allocation   *********)
    3	
    4	external procedure rea_init;MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 3-0          declarations                                                               PAGE 8

    5	external procedure rea_finish;
    6	external function  new_re ( kind: reg_ops; lambda_in: boolean ): reg_exp;
    7	external function  use_re ( re: reg_exp ): reg_exp;
    8	external procedure free_re ( re: reg_exp );
    9	external procedure test_re ( re: reg_exp );
   10	external procedure del_re ( re: reg_exp );
    7	
    8 *	$IF dump
    9 *	$INCLUDE scnnam
   10 *	$INCLUDE scnlst
   11 *	$INCLUDE fio
   12 *	$ENDIF
   13	
   14	
   15	public var
   16	    lambda   : reg_exp; (* Matches the null string. *)
   17	    phi      : reg_exp; (* Doesn't match any string. *)
   18	    anychar  : reg_exp; (* Matches any single-character string. *)
   19	    anystring: reg_exp; (* Matches any string. *)
   20	
   21	
   22	function binary ( op: reg_ops; left, right: reg_exp ): reg_exp;  forward;MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 2            literal                                                                    PAGE 9

    2	
    3	(*  Literal is called with a data element, and returns a literal reg
    4	    expression for that value.  *)
    5	
    6	public function literal ( n: data_element ): reg_exp;
    7	
    8	begin
    9	  literal := new_re ( literal_op, false ); (* Literals don't contain lambda. *)
   10	  literal^.lit_val := n; (* Set the literal value. *)
   11	end (* literal *);MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 3            lit_range                                                                 PAGE 10

    2	
    3	(*  LitRange is called with a pair of data elements, and returns a regular
    4	    expression representing the range with the two data elements as its
    5	    end-points.  *)
    6	
    7	public function lit_range ( min, max: data_element ): reg_exp;
    8	
    9	begin
   10	  lit_range := new_re ( lit_range_op, false ); (* Literals don't contain lambda. *)
   11	  with lit_range^ do begin (* Fill in the range bounds. *)
   12	    min_lit := min;
   13	    max_lit := max;
   14	  end;
   15	end (* lit_range *);MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 4            iterate                                                                   PAGE 11

    2	
    3	(*  Iterate is called with a regular expression, and returns a new regular
    4	    expression representing its star closure.  *)
    5	
    6	public function iterate ( op: reg_exp ): reg_exp;
    7	
    8	begin
    9	
   10	  if op = lambda then
   11	    iterate := lambda (*  lambda *  =  lambda  *)
   12	
   13	  else if op = phi then
   14	    iterate :=  phi (*  phi *  =  phi  *)
   15	
   16	  else begin
   17	    iterate := new_re ( star_op, true ); (* Star closures always contain lambda. *)
   18	    iterate^.operand := use_re (op); (* Set the operand. *)
   19	  end;
   20	
   21	end (* iterate *);MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 5            negate                                                                    PAGE 12

    2	
    3	(*  Negate is called with a regular expression, and returns a new regular
    4	    expression representing its complement.  *)
    5	
    6	public function negate ( op: reg_exp ): reg_exp;
    7	
    8	begin
    9	  negate := new_re ( not_op, not op^.l_in ); (* Negation contains lambda iff operand doesn't. 
	*)
   10	  negate^.operand := use_re (op); (* Set the operand. *)
   11	end (* negate *);MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 6            conjoin                                                                   PAGE 13

    2	
    3	(*  Conjoin is called with a pair of regular expressions, and returns a new
    4	    regular expression representing their conjunction.  *)
    5	
    6	public function conjoin ( left, right: reg_exp ): reg_exp;
    7	
    8	begin
    9	
   10	  if (left = phi) or (right = phi) then begin
   11	    conjoin := phi; (*  phi & X  =  X & phi  = phi  *)
   12	    test_re (left);
   13	    test_re (right);
   14	  end
   15	
   16	  else if left = lambda then begin
   17	    if right^.l_in
   18	      then conjoin := lambda (*  lambda & (lambda | X)  =  lambda  *)
   19	      else conjoin := phi; (*  lambda & (lambda' & X)  =  phi  *)
   20	    test_re (right);
   21	  end
   22	
   23	  else if right = lambda then begin
   24	    if left^.l_in
   25	      then conjoin := lambda (*  (lambda | X) & lambda  =  lambda  *)
   26	      else conjoin := phi; (*  (lambda' & X) & lambda  =  phi  *)
   27	    test_re (left);
   28	  end
   29	
   30	  else
   31	    conjoin := binary ( and_op, left, right );
   32	
   33	end (* conjoin *);MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 7            alternate                                                                 PAGE 14

    2	
    3	(*  Alternate is called with a pair of regular expressions, and returns a new
    4	    regular expression representing their alternation.  *)
    5	
    6	public function alternate ( left, right: reg_exp ): reg_exp;
    7	
    8	begin
    9	
   10	  if left = phi then
   11	    alternate := right (*  phi | X  =  X  *)
   12	
   13	  else if right = phi then
   14	    alternate := left (*  X | phi  =  X  *)
   15	
   16	  else
   17	    alternate := binary ( or_op, left, right );
   18	
   19	end (* alternate *);MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 8            catenate                                                                  PAGE 15

    2	
    3	(*  Catenate is called with a pair of regular expressions, and returns a new
    4	    regular expression representing their concatenation.  *)
    5	
    6	public function catenate ( left, right: reg_exp ): reg_exp;
    7	
    8	var
    9	    leftv: reg_exp; (* Scans the left operand expression. *)
   10	    l_in_right: boolean; (* True if the right operand includes lambda. *)
   11	    cat: reg_exp; (* Used in building an expression. *)
   12	
   13	begin
   14	
   15	  if (left = phi) or (right = phi) then begin
   16	    catenate := phi; (*  X phi  =  phi X  =  phi  *)
   17	    test_re (left);
   18	    test_re (right);
   19	  end
   20	
   21	  else if left = lambda then
   22	    catenate := right (*  lambda X  =  X  *)
   23	
   24	  else if right = lambda then
   25	    catenate := left (*  X lambda  =  X  *)
   26	
   27	  else begin
   28	
   29	    (*  The canonical form for concatenated regular expressions is:
   30	
   31	            cat
   32	            / \
   33	           r1  cat
   34	               / \      or    (r1 . (r2 . ... (rn-1 . rn) ... ) )
   35	              r2  cat
   36	                    .
   37	                     .
   38	                      cat
   39	                      / \
   40	                   rn-1  rn
   41	MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 8            catenate                                                                  PAGE 16

   42	        If the left operand of this call is itself concatenated, then we
   43	        must create a copy of the left operand (since it may be in use
   44	        elsewhere) with the right operand concatenated onto its tail.  I.e.,
   45	
   46	            CAT [ (r1 . (r2 . ... (rn-1 . rn) ... ) ) , s ] =>
   47	                (r1 . (r2 . ... (rn-1 . (rn . s) ) ... ) )
   48	
   49	        The algorithm is an iterative realization of the function:
   50	
   51	            CAT[r,s]  = (r . s)                  , if r.op <> cat
   52	                      = (r.left . CAT[r.right,s]), if r.op  = cat           *)
   53	
   54	    leftv := left;
   55	    l_in_right := right^.l_in;
   56	    catenate := new_re ( cat_op, leftv^.l_in and l_in_right );
   57	    cat := catenate;
   58	    while leftv^.reg_op = cat_op do
   59	      with cat^ do begin
   60	        leftop := use_re (leftv^.leftop);
   61	        leftv := leftv^.rightop;
   62	        rightop := use_re ( new_re ( cat_op, leftv^.l_in and l_in_right ) );
   63	        cat := rightop;
   64	      end;
   65	    with cat^ do begin
   66	      leftop := use_re (leftv);
   67	      rightop := use_re (right);
   68	    end;
   69	    test_re (left); (* Operand may be copied. *)
   70	  end;
   71	
   72	end (* catenate *);MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 9            initre                                                                    PAGE 17

    2	
    3	(*  InitRE is called to initialize the 'lambda' and 'phi' constant regular
    4	    expressions.  *)
    5	
    6	public procedure initre;
    7	
    8	begin
    9	  lambda := use_re ( new_re ( lambda_op, true ) );
   10	  phi := use_re ( new_re ( phi_op, false ) );
   11	  anychar := use_re ( lit_range ( minimum (data_element), maximum (data_element) ) );
   12	  anystring := use_re ( iterate ( anychar ) );
   13	end (* initre *);MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 10           clearre                                                                   PAGE 18

    2	
    3	(*  Clearre is called to free 'lambda' and 'phi' again.  *)
    4	
    5	public procedure clearre;
    6	
    7	begin
    8	  free_re (lambda);
    9	  free_re (phi);
   10	  free_re (anychar);
   11	  free_re (anystring);
   12	end (* clearre *);MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 11           derivative                                                                PAGE 19

    2	
    3	(*  Derivative takes a regular expression and a data element, and returns the
    4	    derivative of the regular expression with respect to the data element.  *)
    5	
    6	public function derivative ( re: reg_exp; a: data_element ): reg_exp;
    7	
    8	begin
    9	  with re^ do
   10	    case reg_op of
   11	
   12	      lambda_op,
   13	      phi_op:
   14	        derivative := phi;
   15	
   16	      literal_op:
   17	        if lit_val = a
   18	          then derivative := lambda
   19	          else derivative := phi;
   20	
   21	      lit_range_op:
   22	        if (min_lit <= a) and (a <= max_lit)
   23	          then derivative := lambda
   24	          else derivative := phi;
   25	
   26	      star_op:
   27	        derivative := catenate ( derivative (operand, a), re );
   28	
   29	      cat_op:  begin
   30	        derivative := catenate ( derivative (leftop, a), rightop );
   31	        if leftop^.l_in then
   32	          derivative := alternate ( derivative, derivative (rightop, a) );
   33	      end;
   34	
   35	      or_op:
   36	        derivative := alternate ( derivative (leftop, a), derivative (rightop, a) );
   37	
   38	      and_op:
   39	        derivative := conjoin ( derivative (leftop, a), derivative (rightop, a) );
   40	
   41	      not_op:MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 11           derivative                                                                PAGE 20

   42	        derivative := negate ( derivative (operand, a) )
   43	
   44	    end (* case reg_op *);
   45	end (* derivative *);MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 12           re_compare                                                                PAGE 21

    2	
    3	(*  ReCompare takes a pair of regular expressions, and returns a 'relation'
    4	    code indicating the relation between them.  This relation may be 'lss'
    5	    (less than), 'eql' (similar to), or 'gtr' (greater than).  Note that
    6	    the 'similar to' relation is not the same as equality of regular
    7	    expressions.  The ordering is arbitrary, but makes it possible to
    8	    define the canonical form for binary operators, which in turn makes
    9	    it possible to efficiently test regular expressions for similarity.  *)
   10	
   11	public function re_compare ( re1v, re2v: reg_exp ): relation;
   12	
   13	
   14	    (*  LitComp compares two data elements.  *)
   15	
   16	    function lit_comp ( lit1, lit2: data_element ): relation;
   17	    begin
   18	      if lit1 < lit2 then
   19	        lit_comp := lss
   20	      else if lit1 > lit2 then
   21	        lit_comp := gtr
   22	      else
   23	        lit_comp := eql;
   24	    end (* lit_comp *);
   25	
   26	
   27	var
   28	    re1, re2: reg_exp;
   29	
   30	label
   31	    100 (* Compare re1 and re2 *);
   32	
   33	begin
   34	  re1 := re1v;
   35	  re2 := re2v;
   36	
   37	100 (* Compare re1 and re2 *):
   38	
   39	  if re1 = re2 then
   40	    re_compare := eql (* An expression is similar to itself. *)
   41	MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 12           re_compare                                                                PAGE 22

   42	  else
   43	    if re1^.reg_op < re2^.reg_op then
   44	      re_compare := lss
   45	    else if re1^.reg_op > re2^.reg_op then
   46	      re_compare := gtr
   47	    else (* Same operators:  expressions may be similar. *)
   48	      case re1^.reg_op of
   49	
   50	        star_op,
   51	        not_op: begin
   52	          re1 := re1^.operand;
   53	          re2 := re2^.operand;
   54	          goto 100; (* Compare the operands. *)
   55	        end;
   56	
   57	        or_op,
   58	        and_op,
   59	        cat_op:  begin
   60	          re_compare := re_compare (re1^.leftop, re2^.leftop); (* Compare the left operands. *
	)
   61	          if re_compare = eql then begin
   62	            re1 := re1^.rightop;
   63	            re2 := re2^.rightop;
   64	            goto 100; (* If the same, compare the right operands. *)
   65	          end;
   66	        end;
   67	
   68	        literal_op:
   69	          re_compare := lit_comp (re1^.lit_val, re2^.lit_val); (* Compare literal symbols. *)
   70	
   71	        lit_range_op:  begin
   72	          re_compare := lit_comp (re1^.min_lit, re2^.min_lit); (* Compare min literals. *)
   73	          if re_compare = eql then
   74	            re_compare := lit_comp (re1^.max_lit, re2^.max_lit); (* If the same, compare max l
	iterals. *)
   75	        end
   76	
   77	    end (* case reg_op *);
   78	end (* re_compare *);MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 13           binary                                                                    PAGE 23

    2	
    3	(*  Binary is the function which actually creates a regular expression with
    4	    a "&" or "|" operator.  It is called with the operator to be used and a
    5	    pair of regular expressions, and returns the regular expression which is
    6	    the operator applied to the two operands.
    7	
    8	    'And' and 'or' regular expressions have the canonical form:
    9	
   10	        op
   11	        /\
   12	       r1 op
   13	          /\      or    (r1 . (r2 . ... (rn-1 . rn) ... ) )
   14	         r2 op
   15	             .
   16	              .
   17	               op
   18	               /\
   19	            rn-1 rn
   20	
   21	    There is also the requirement that r1 < r2 .. < rn, where the ordering is
   22	    that defined by the Compare function.  If one or both of the arguments to
   23	    Binary contain the operator already, then a completely new expression,
   24	    containing all the operands of each argument expression, is created.  A
   25	    merge procedure is necessary to create the new expression in canonical
   26	    form.   For example,
   27	
   28	        (a . (c . e) ) . (b . (c . d) )  =>  (a . (b . (c . (d . e) ) ) )    *)
   29	
   30	
   31	function binary (* op: reg_ops; left, right: reg_exp ): reg_exp *);
   32	
   33	var
   34	    leftv, rightv: reg_exp; (* For traversing the argument expressions. *)
   35	    leftval, rightval: reg_exp; (* Single left and right operands. *)
   36	    result: reg_exp; (* Used in constructing the result. *)
   37	    rel: relation; (* Used in comparing operands. *)
   38	
   39	begin
   40	  if left = right then begin
   41	    binary := left; (*  X op X  =  X  *)MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 13           binary                                                                    PAGE 24

   42	    return; (* <---- *)
   43	  end;
   44	
   45	  rel := re_compare (left, right);
   46	  if rel = eql then begin
   47	    binary := left;
   48	    test_re (right);
   49	    return; (* <---- *)
   50	  end;
   51	
   52	  if (left^.reg_op <> op) and (right^.reg_op <> op) then begin
   53	    binary := new_re (op, false);
   54	    if rel = lss then begin
   55	      binary^.leftop := use_re (left);
   56	      binary^.rightop := use_re (right);
   57	    end
   58	    else begin
   59	      binary^.leftop := use_re (right);
   60	      binary^.rightop := use_re (left);
   61	    end;
   62	    if op = and_op
   63	      then binary^.l_in := left^.l_in and right^.l_in
   64	      else binary^.l_in := left^.l_in or right^.l_in;
   65	    return;     (* <---- *)
   66	  end;
   67	
   68	(*  The first phase of Binary performs the merge procedure, leaving an
   69	    inverted tree structure:
   70	
   71	        op              op                       op
   72	        /\              /\                       /\
   73	       a  op    OP     b  op        =>         op  e
   74	          /\              /\                   /\
   75	         c  e            c  d                op  d
   76	                                             /\
   77	                                           op  c
   78	                                           /\
   79	                                         op  b
   80	                                         /\
   81	                                      nil  a                            *)MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 13           binary                                                                    PAGE 25

   82	
   83	  rel := eql; (* Forces a "get left op" and a "get right op". *)
   84	  result := nil; (* The bottom of the inverted tree. *)
   85	  leftv := left;
   86	  rightv := right;
   87	
   88	  loop
   89	    if rel <> gtr then (* Get the next left operand. *)
   90	      if leftv = nil then
   91	        leftval := nil
   92	      else with leftv^ do
   93	        if reg_op <> op then begin
   94	          leftval := leftv;
   95	          leftv := nil;
   96	        end
   97	        else (* reg_op = op *) begin
   98	          leftval := leftop;
   99	          leftv := rightop;
  100	        end;
  101	
  102	    if rel <> lss then (* Get the next right operand. *)
  103	      if rightv = nil then
  104	        rightval := nil
  105	      else with rightv^ do
  106	        if reg_op <> op then begin
  107	          rightval := rightv;
  108	          rightv := nil;
  109	        end
  110	        else (* reg_op = op *) begin
  111	          rightval := leftop;
  112	          rightv := rightop;
  113	        end;
  114	
  115	  exit if (leftval = nil) and (rightval = nil);
  116	
  117	    if leftval = nil then
  118	      rel := gtr (* No left op -- use the right. *)
  119	    else if rightval = nil then
  120	      rel := lss (* No right op -- use the left. *)
  121	    else MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 13           binary                                                                    PAGE 26

  122	      rel := re_compare ( leftval, rightval ); (* Compare the two operands. *)
  123	
  124	    binary := new_re ( op, false ); (* Create a new result tree node. *)
  125	    with binary^ do begin
  126	      leftop := result; (* Hang the rest of the tree on it. *)
  127	      if rel = lss
  128	        then rightop := leftval (* Hang the new operand on it. *)
  129	        else rightop := rightval;
  130	    end;
  131	    result := binary;
  132	  end (* loop *);
  133	
  134	(*  The second phase of Binary reverses the tree pointers, propagates the
  135	    correct l_in values up the tree, sets the reference counts in the
  136	    operand nodes, and disposes of the unused (nil . a) node:
  137	
  138	                op              op
  139	                /\              /\
  140	              op  e            a  op
  141	              /\                  /\
  142	            op  d                b  op
  143	            /\        =>            /\
  144	          op  c                    c  op
  145	          /\                          /\
  146	        op  b                        d  e
  147	        /\
  148	     nil  a                                                             *)
  149	
  150	  binary := result^.rightop; (* Get the last element. *)
  151	  while result^.leftop <> nil do begin
  152	    result^.rightop := use_re (binary); (* The right part so far. *)
  153	    binary := result;
  154	    with binary^ do begin
  155	      result := leftop; (* The rest of the tree. *)
  156	      leftop := use_re ( result^.rightop ); (* Copy another operand. *)
  157	      if op = and_op (* Set the 'lambda_in' flag. *)
  158	        then l_in := leftop^.l_in and rightop^.l_in
  159	        else l_in := leftop^.l_in or  rightop^.l_in;
  160	    end;
  161	  end;MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 13           binary                                                                    PAGE 27

  162	
  163	  del_re (result); (* Discard the redundant pointer. *)
  164	  test_re (left); (* The operands may have been copied. *)
  165	  test_re (right);
  166	
  167	end (* binary *);MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 14           re_null                                                                   PAGE 28

    2	
    3	(*  ReNull tests whether lambda is in the set of strings denoted by a regular
    4	    expression.  This is just a wrapper for the L_In field, since other
    5	    modules don't have access to the fields of a regular expression record.  *)
    6	
    7	public function re_null ( re: reg_exp ): boolean;
    8	
    9	begin
   10	  re_null := re^.l_in;
   11	end;MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 15           litval                                                                    PAGE 29

    2	
    3	(*  Only the SCNREA and SCNREU routines are permitted to look at the fields
    4	    of a regular expression node.  Unfortunately, the parser semantic routines
    5	    sometimes need the literal value of a literal regular expression, either
    6	    to construct a literal range expression, or to record the minimum and max-
    7	    imum literal values used.  Therefore, Litval will return a boolean value
    8	    indicating whether a regular expression is a literal, and will store its
    9	    value in a data element variable if it is.  *)
   10	
   11	public function litval ( re: reg_exp; var result: data_element ): boolean;
   12	
   13	begin
   14	  with re^ do begin
   15	    litval := (reg_op = literal_op);
   16	    if litval then
   17	      result := lit_val;
   18	  end;
   19	end (* litval *);MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 16           lithead                                                                   PAGE 30

    2	
    3	(*  Lithead is similar in function and justification to Litval.  However,
    4	    Lithead determines whether a regular expression has the form "X alpha",
    5	    where X is a literal or literal range, and alpha is any regular expression.
    6	    If so, then Lithead returns the minimum and maximum range values, and the
    7	    expression alpha.  *)
    8	
    9	public function lithead ( re: reg_exp;
   10	                          var min_result, max_result: data_element;
   11	                          var remainder: reg_exp ): boolean;
   12	
   13	var r: reg_exp;
   14	
   15	begin
   16	  with re^ do begin
   17	    if reg_op = cat_op then begin
   18	      r := leftop;
   19	      remainder := rightop;
   20	    end
   21	    else begin
   22	      r := re;
   23	      remainder := lambda;
   24	    end;
   25	  end (* with re^ *);
   26	
   27	  with r^ do begin
   28	    if reg_op = literal_op then begin
   29	      lithead := true;
   30	      min_result := lit_val;
   31	      max_result := lit_val;
   32	    end
   33	    else if reg_op = lit_range_op then begin
   34	      lithead := true;
   35	      min_result := min_lit;
   36	      max_result := max_lit;
   37	    end
   38	    else
   39	      lithead := false;
   40	  end (* with r^ *);
   41	end (* lithead *);MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 17           print_regular_expression                                                  PAGE 31

    2	
    3	(*  PRINT REGULAR EXPRESSION is called with a regular expression pointer,
    4	    and prints the regular expression in external form.  The Paren flag
    5	    indicates whether parentheses are to be printed before and after the
    6	    regular expression.  *)
    7	
    8 *	$IF dump
    9 *	
   10 *	procedure print_regular_expression ( re: reg_exp; paren: boolean );
   11 *	
   12 *	const
   13 *	    pr: array [reg_ops] of 1..6 = (* Operator Priorities *)
   14 *	     (  6, 6, 6, 1, 5, 5, 4, 2, 3  );
   15 *	
   16 *	    opname: array [reg_ops] of string [5] = (* Operator Names *)
   17 *	     (  '^', '#', '', '', '*', '''', ' ', ' | ', ' & '  );
   18 *	
   19 *	
   20 *	var re1: reg_exp;
   21 *	    paren1: boolean;
   22 *	    paren_count: number;
   23 *	
   24 *	begin
   25 *	  re1 := re;
   26 *	  paren1 := paren;
   27 *	  paren_count := 0;
   28 *	  while re1 <> nil do begin
   29 *	    if paren1 then begin
   30 *	      fio_write (listfb, '(');
   31 *	      paren_count := paren_count + 1;
   32 *	    end;
   33 *	    with re1^ do begin
   34 *	      case reg_op of
   35 *	
   36 *	        lambda_op, phi_op:
   37 *	          begin
   38 *	            fio_write (listfb, opname [reg_op]);
   39 *	            re1 := nil;
   40 *	          end;
   41 *	MODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 17           print_regular_expression                                                  PAGE 32

   42 *	        literal_op:
   43 *	          begin
   44 *	            prt_symbol (lit_val, '');
   45 *	            re1 := nil;
   46 *	          end;
   47 *	
   48 *	        lit_range_op:
   49 *	          begin
   50 *	            prt_symbol (min_lit, '');
   51 *	            fio_write (listfb, '..');
   52 *	            prt_symbol (max_lit, '');
   53 *	            re1 := nil;
   54 *	          end;
   55 *	
   56 *	        cat_op, and_op, or_op:
   57 *	          begin
   58 *	            print_regular_expression (leftop, (pr[leftop^.reg_op] <= pr[reg_op]));
   59 *	            fio_write (listfb, opname[reg_op]);
   60 *	            re1 := rightop;
   61 *	            paren1 := (pr[rightop^.reg_op] < pr[reg_op]);
   62 *	          end;
   63 *	
   64 *	        star_op, not_op:
   65 *	          begin
   66 *	            print_regular_expression (operand, (pr[operand^.reg_op] < pr[reg_op]));
   67 *	            fio_write (listfb, opname[reg_op]);
   68 *	            re1 := nil;
   69 *	          end;
   70 *	
   71 *	      end (* case reg_op *);
   72 *	    end (* with re1^ *);
   73 *	  end (* while re1 <> nil *);
   74 *	
   75 *	  while paren_count <> 0 do begin
   76 *	    fio_write (listfb, ')');
   77 *	    paren_count := paren_count - 1;
   78 *	  end;
   79 *	end (* print_regular_expression *);
   80 *	
   81 *	$ENDIFMODULE  SCNREU       scnreu - SCANNR Regular Expression Utilities                      25-Apr-83 16:08
SECTION 18           prt_re                                                                    PAGE 33

    2	
    3	(*  PRT RE prints a regular expression on the listing file.  It is merely a
    4	    publicly accessible wrapper for PrintRegularExpression.  *)
    5	
    6	public procedure prt_re ( re: reg_exp );
    7	
    8	begin
    9 *	$IF dump  print_regular_expression (re, false);
   10	end.

File   level   on page     name

  0	 0	    1	DSK:SCNREU.PAS[3,136773]
  1	 1	    5	DSK:SCANNR.TYP[3,136773]
  2	 1	    5	DSK:SCNRE.TYP[3,136773]
  3	 1	    7	DSK:SCNREA.INC[3,136773]



Section   in file   on page     title

     7	      0	        14    alternate
    13	      0	        23    binary
     8	      0	        15    catenate
    10	      0	        18    clearre
     6	      0	        13    conjoin
     1	      0	         5    declarations
    11	      0	        19    derivative
     9	      0	        17    initre
     4	      0	        11    iterate
     2	      0	         9    literal
    16	      0	        30    lithead
    15	      0	        29    litval
     3	      0	        10    lit_range
     5	      0	        12    negate
    17	      0	        31    print_regular_expression
    18	      0	        33    prt_re
    12	      0	        21    re_compare
    14	      0	        28    re_null
 OD	9