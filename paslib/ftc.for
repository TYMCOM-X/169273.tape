	IMPLICIT INTEGER (A-Z)

	INTEGER RECORD	(500)
	INTEGER DSKREC	(256)
	INTEGER CMD	(2)
	INTEGER FILBLK	(2)
	INTEGER IFILE	(2)

	LOGICAL	TTYFLG

	COMMON /FLAG/	TTYFLG

	DATA TTYFLG	/.TRUE./

	CALL ECHO (0)
	CALL ACKLIN
C	WRITE (5,9000)
9000	FORMAT ('+ACK',/)
	CALL NOCRLF
C
C
	IFILE(1) = 'BG.EX'
	IFILE(2) = 'E'
	GO TO 81
	CALL INREC (RECORD,E,ISIZE,ITYPE,.FALSE.)
	IF (E .EQ. 0) GO TO 10
C	  WRITE (5,9001) E,ISIZE,ITYPE,(RECORD(I),I=1,5)
	CALL YUCK ('NO INITIAL ACK',14)	! Nexer to return
9001	FORMAT (' ',I1,I4,1X,A1,1X,5A5)
C
10	IF (ITYPE .EQ. 'C') GO TO 20
	  CALL YUCK ('Not a Communications record',27)	! Never to return
C
C
20	CALL GETCOM (RECORD,ISIZE,CMD)
	IF (CMD(1) .EQ. 'ACK') GO TO 40
	  CALL YUCK ('ACK not received',16)	! Never to return
C
C
40	CALL ENCODE (RECORD,'TYM-1','S',5,ISIZE)
	CALL OUTREC (RECORD)
C
C
45	CALL INREC (RECORD,E,ISIZE,ITYPE,.FALSE.)
	IF (E.EQ.0 .AND. ITYPE.EQ.'C') GO TO 60
	  CALL YUCK ('Version not acknowledged',24)	! Never to return
C
50	CALL INREC (RECORD,E,ISIZE,ITYPE,.FALSE.)
	IF (E.EQ.0 .AND. ITYPE.EQ.'C') GO TO 60
	  CALL YUCK ('ILLEGAL COMMAND',15)	! Never to return
C
C
60	CALL GETCOM (RECORD,ISIZE,CMD)
	IF (RECORD(1).NE.'EXIT' .AND. RECORD(1).NE.'ABORT') GO TO 70
	  CALL ENCODE (RECORD,'ACK','C',3,ISIZE)
	  CALL OUTREC (RECORD)
	CALL QEXIT
	  STOP
C
70	IF (CMD(1) .EQ. 'GET') GO TO 80
	  CALL YUCK ('Not a GET',9)	! Never to return
C
C
80	CALL GETFIL (RECORD,ISIZE,IFILE)
81	CALL MAKFIL (IFILE,FILBLK)
	IS = FILSIZ (FILBLK,IERR)
	OPEN (UNIT=1,DEVICE='DSK',FILE=IFILE,MODE='IMAGE',ACCESS='RANDIN',
     &		RECORDSIZE=1,ERR=90)
	GO TO 105
C
C
90	  CALL ENCODE (RECORD,'NEW','C',3,ISIZE)
	  CALL OUTREC (RECORD)
	CALL INREC (RECORD,E,ISIZE,ITYPE,.FALSE.)
	IF (RECORD(1) .NE. 'ABORT') CALL QEXIT
	    CALL ENCODE (RECORD,'ACK','C',3,ISIZE)
	  CALL OUTREC (RECORD)
	    GO TO 50
	  STOP
C
C
100	CALL ENCODE (RECORD,'OLDBIN','C',6,ISIZE)
	CALL OUTREC (RECORD)
	CALL INREC (RECORD,E,ISIZE,ITYPE,.FALSE.)
	CALL GETCOM (RECORD,ISIZE,CMD)
	IF (CMD(1) .EQ. 'ACK') GO TO 105
	  CALL YUCK ('File opening ACK not acknowledged',33)	! Never to return
C
105	ADDR = 1
	REM = IS
110	CALL GETDIR (1,DSKREC,ADDR,IS,256,CNT,REM)
	DO 140 I = 1,CNT,32
	  WDCNT = 32
	  IF ((I+31) .GT. CNT) WDCNT = (CNT-I) + 1
120	  CALL MAKREC (DSKREC(I),WDCNT,RECORD)
125	  CALL OUTREC (RECORD)
	  RECCNT = RECCNT + 1
	  GO TO 140
	  CALL INREC (RECORD,E,ISIZE,ITYPE,.FALSE.)
	  CALL GETCOM (RECORD,ISIZE,CMD)
	  IF (CMD(1) .EQ. 'ACK') GO TO 140
	    IF (CMD(1) .EQ. 'NAK') GO TO 120
	      IF (CMD(1) .EQ. 'ABORT') GO TO 130
	      CALL YUCK ('Cannot send block',17)	! Never to return
130	  CALL ENCODE (RECORD,'ACK','C',3,ISIZE)
	CALL OUTREC (RECORD)
	GO TO 50
140	  CONTINUE
C
	IF (REM .GT. 0) GO TO 110
C
	CALL ENCODE (RECORD,'EOF','C',3,ISIZE)
	CALL OUTREC (RECORD)
	GO TO 50
	END
	SUBROUTINE GETDIR (UNIT,DIR,DPTR,NE,MAX,CNT,REM)
	IMPLICIT INTEGER (A-Z)

	INTEGER DIR	(MAX)

	CNT = 0
	IF (NE .LE. 0) RETURN

	CPTR = DPTR
	IF (REM .NE. 0) CPTR = CPTR + (NE-REM)
	CNT = REM
	IF (CNT .GT. MAX) CNT = MAX
	DO 5 I = 1,CNT
	  READ (UNIT#CPTR+(I-1)) DIR(I)
5	  CONTINUE
8	REM = REM - CNT
10	RETURN
	END
	SUBROUTINE ENCODE (RECORD,STRING,ITYPE,ISIZE,III)
	IMPLICIT INTEGER (A-Z)

	INTEGER RECORD	(500)
	integer string	(2)

	DO 10 I = 1,500
	  RECORD(I) = ' '
10	  CONTINUE
C
C
	CALL GETC (1,ITYPE,TMP)
	CALL GETC (1,ITYPE,RECORD(1))
	CK = RECORD(1)
	DO 20 I = 1,ISIZE
	  CALL GETC (I,STRING(1),RECORD(I+3))
	  CK = IXOR (CK,RECORD(I+3))
20	  CONTINUE
	MSIZE = ISIZE + 2
	record(2) = msize
	RECORD(3) = IXOR(CK,RECORD(2))
	RETURN
	END
	SUBROUTINE INREC (RECORD,E,ISIZE,ITYPE,HIBFLG)
	IMPLICIT INTEGER (A-Z)

	INTEGER RECORD	(500)
	INTEGER TYPE	(5)
	INTEGER INLINE	(30)

	LOGICAL HIBFLG
	LOGICAL HIBERN

	DATA TYPE /"102,"103,"120,"123,"130/

	isize = 0
	itype = ' '
	e = 0
	
	IF (.NOT. HIBFLG) GO TO 5
	IF (.NOT. HIBERN(30)) GO TO 40
C
5	DO 35 K = 1,2
	READ (5,9000) INLINE
9000	FORMAT (30A5)
	DO 30 I = 30,1,-1
10	  IF (INLINE(I) .EQ. ' ') GO TO 30
	  DO 20 J = 5,1,-1
	    CALL GETC (J,INLINE(I),TMP)
	    IF (TMP .EQ. "40) GO TO 20
	      CHRCNT = (I-1)*5 + J
	      GO TO 100
20	    CONTINUE
	    E = 2
30	  CONTINUE
35	CONTINUE
40	E = 5
50	RETURN
C
C
100	CALL GETC (1,INLINE(1),TMP)
	DO 110 I = 1,5
	  IF (TMP .EQ. TYPE(I)) GO TO 130
110	  CONTINUE
	  E = 1
	  RETURN
C
C
130	CALL PUTC (1,ITYPE,TMP)
	CALL GETC (2,INLINE(1),IS)
	ACCUM = IXOR (TMP,IS)
	CALL GETC (3,INLINE(1),CK)
	IS = IS - "41
	IF (IS .EQ. (CHRCNT-1)) GO TO 135
	  E = 2
	  RETURN
C
135	IF (TMP .NE. "103) GO TO 200
C
C
C   Process a Communications record
C
C
	DO 140 I = 1,10
	  RECORD(I) = ' '
140	  CONTINUE
C
	DO 150 I = 4,IS+1
	  CALL GETC (I,INLINE(1),TMP)
	  ACCUM = IXOR (ACCUM,TMP)
	  CALL PUTC (I-3,RECORD(1),TMP)
150	  CONTINUE
160	ACCUM = IAND (ACCUM,"77)
	CK = IAND (CK-"41,"77)
	IF (ACCUM .NE. CK) E = 3
	ISIZE = IS - 2
	RETURN
C
C
C
200	DO 210 I = 1,24
	  RECORD(I) = 0
210	  CONTINUE
C
	IWD = 1
	IPOS = 0
	DO 250 I = 4,IS+1
	  CALL GETC (I,INLINE(1),TMP)
	  TMP = TMP - "41
	  ACCUM = IXOR (ACCUM,TMP)
	  CALL SETBIT (RECORD(IWD),IPOS,6,TMP)
	  IPOS = IPOS + 6
	  IF (IPOS .LT. 36) GO TO 250
	    IPOS = 0
	    IWD = IWD + 1
250	  CONTINUE
C
	ACCUM = IAND (ACCUM,"77)
	CK = IAND(CK,"77)
	IF (ACCUM .NE. CK) E = 3
	ISIZE = IS - 2
	RETURN
	END
	SUBROUTINE OUTREC (RECORD)
	IMPLICIT INTEGER (A-Z)

	INTEGER RECORD	(500)

	LOGICAL TTYFLG

	COMMON /FLAG/	TTYFLG
	COMMON /BSIZES/	REALLN

	LEN = RECORD(2) + 1
	IF (REALLN .NE. 0) LEN = REALLN
	REALLN = 0
	IF (TTYFLG) GO TO 100

	DO 50 I = 1,LEN
	  CALL W8LEV (RECORD(I))
50	  CONTINUE
	CALL W8LEV ("36)
	RETURN
C
C
100	TYPE 9000,LEN
	WRITE (5,9001) (RECORD(I),I=1,LEN)
	RETURN
	
C
C


9000	FORMAT (' SIZE= ',I5)
9001	FORMAT (10(' ',O3))
	END
	SUBROUTINE GETCOM (RECORD,ISIZE,CMD)
	IMPLICIT INTEGER (A-Z)

	INTEGER RECORD	(500)
	INTEGER CMD	(2)

	DATA GET	/'GET'/
	DATA RESTA1	/'RESTA'/
	DATA RESTA2	/'RT'/
	DATA ACK	/'ACK'/
	DATA NAK	/'NAK'/
	DATA CKS	/'CKS'/
	DATA NEW	/'NEW'/
	DATA OLD	/'OLD'/
	DATA TYPE	/'BIN'/
	DATA EOF	/'EOF'/
	DATA ABORT	/'ABORT'/

	CMD(1) = ' '
	CMD (2) = ' '
	DO 10 I = 1,3
	  CALL GETC (I,RECORD,TMP)
	  CALL PUTC (I,CMD(1),TMP)
10	  CONTINUE
C
	IF (CMD(1) .EQ. 'ABO') GO TO 20
	  IF (CMD(1) .EQ. 'RES') GO TO 30
	    RETURN
C
20	CMD(1) = ABORT
	RETURN
C
30	CMD(1) = RESTA1
	CMD(2) = RESTA2
	RETURN
	END
	SUBROUTINE GETFIL (RECORD,ISIZE,FILE)
	IMPLICIT INTEGER (A-Z)

	INTEGER RECORD	(500)
	INTEGER FILE	(2)

	FILE(1) = ' '
	FILE(2) = ' '
	DO 10 I = 4,ISIZE
	  CALL GETC (I,RECORD(1),TMP)
	  CALL PUTC (I-3,FILE,TMP)
10	  CONTINUE
20	  RETURN
	  END
	SUBROUTINE MAKREC (INREC,WDCNT,RECORD)
	IMPLICIT INTEGER (A-Z)

	INTEGER INREC	(32)
	INTEGER RECORD	(500)
	INTEGER TEMP	(32)

	COMMON /BSIZES/	REALLN
	DATA B	/"102/

	DO 10 I = 1,500
	  RECORD(I) = 0
10	  CONTINUE

	REALLN = 0
	RECORD(1) = B
	CK = B
	IF (MOD(WDCNT,2) .NE. 0) INREC(WDCNT+1) = 0
	RECORD(2) = (WDCNT/2)*9 + 2
15	IF (MOD(WDCNT,2) .NE. 0) RECORD(2) = RECORD(2) + 5
	PTR = 4
	SKIP = 0
	IF (RECORD(2) .NE. "200) GO TO 20
	  RECORD(3) = "200
	  PTR = PTR + 1
	  SKIP = 1
	  REALLN = REALLN + 1
20	DO 100 I = 1,WDCNT,2
	  CALL MAK8WD (INREC(I),INREC(I+1),TEMP(1))
	  DO 50 J = 1,9
	  CK = IXOR(CK,TEMP(J))
	    IF (TEMP(J) .EQ. "200) GO TO 30
	      IF (TEMP(J) .NE. "36) GO TO 40
		RECORD(PTR) = "200
		RECORD(PTR+1) = 0
		REALLN = REALLN + 1
		PTR = PTR + 2
		GO TO 50
30	      RECORD(PTR) = "200
	      RECORD(PTR+1) = "200
	      REALLN = REALLN + 1
	      PTR = PTR + 2
	      GO TO 50
40	    RECORD(PTR) = TEMP(J)
	    PTR = PTR + 1
50	  CONTINUE
100	CONTINUE
150	RECORD(3+SKIP) = IXOR(CK,RECORD(2))
	IF(RECORD(3+SKIP).NE."36.AND.RECORD(3+SKIP).NE."200)GO TO 200
	  DO 180 I = PTR-1,4,-1
	    RECORD(I+1) = RECORD(I)
180	    CONTINUE
	  PTR = PTR + 1
	  REALLN = REALLN + 1
	  RECORD(4+SKIP) = 0
	  IF (RECORD(3+SKIP) .EQ. "200) RECORD(4+SKIP) = "200
	  RECORD(3+SKIP) = "200
200	REALLN = RECORD(2) + REALLN + 1
	RETURN
	END
	subroutine makfil (filnam,filblk)
	IMPLICIT INTEGER (A-Z)

	INTEGER FILNAM	(2)
	INTEGER FILBLK	(2)

	LOGICAL AFTDOT

	IPOS = 0
	FILBLK(1) = 0
	FILBLK(2) = 0
	AFTDOT = .FALSE.

	DO 15 I = 1,10
	  CALL GETC (I,FILNAM(1),CH)
	  IF (CH .EQ. "40) GO TO 20
	    IF (AFTDOT) GO TO 10
	      IF (CH .EQ. "56) GO TO 5
	        CALL SETBIT (FILBLK(1),IPOS,6,CH-"40)
	        IPOS = IPOS + 6
	        GO TO 15
5	      aftdot = .TRUE.
	      IPOS = 0
	      GO TO 15
10	    CALL SETBIT (FILBLK(2),IPOS,6,CH-"40)
	    IPOS = IPOS + 6
15	  CONTINUE
C
20	RETURN
	END
	SUBROUTINE YUCK (STRING,CNT)
	IMPLICIT INTEGER (A-Z)

	INTEGER STRING	(10)
	INTEGER RECORD	(500)

	CALL ENCODE (RECORD,STRING,'Z',CNT,ISIZE)
	CALL OUTREC (RECORD)
	CALL QEXIT
	STOP
	END
  