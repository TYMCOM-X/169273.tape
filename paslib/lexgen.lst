               File DSK:LEXGEN.PAS[3,136773]   Compiled 26-Apr-83 11:01   Pascal, Version 1B

               File DSK:LEXGEN.PAS[3,136773]   Compiled 26-Apr-83 11:01   Pascal, Version 1B

               File DSK:LEXGEN.PAS[3,136773]   Compiled 26-Apr-83 11:01   Pascal, Version 1B

               File DSK:LEXGEN.PAS[3,136773]   Compiled 26-Apr-83 11:01   Pascal, Version 1B





			       $       $$$$$   $   $    $$$$   $$$$$   $   $
			       $       $       $   $   $       $       $$  $
			       $       $        $ $    $       $       $ $ $
			       $       $$$       $     $ $$$   $$$     $  $$
			       $       $        $ $    $   $   $       $   $
			       $       $       $   $   $   $   $       $   $
			       $$$$$   $$$$$   $   $    $$$    $$$$$   $   $


				   LEXGEN: lexical analyzer generator


Options in effect: 

	CHECK, NOSPECIAL, NOMAP, SYMBOLS, CALLS, NOASSEMBLY, XREF, TRACE, QBLOCKS, NOOPTIMIZE, CODE, 
	NODEBUG, FINISH, NOGLOBAL, NOMAINSEG, NOOVERLAY, AUTOQUICK, SOURCE, NOSTANDARD, LENGTH (45), 
	WIDTH (107), STORAGE (8192), ALLOC (0), ENABLE(P10)




               File DSK:LEXGEN.PAS[3,136773]   Compiled 26-Apr-83 11:01   Pascal, Version 1B

               File DSK:LEXGEN.PAS[3,136773]   Compiled 26-Apr-83 11:01   Pascal, Version 1B

               File DSK:LEXGEN.PAS[3,136773]   Compiled 26-Apr-83 11:01   Pascal, Version 1B

               File DSK:LEXGEN.PAS[3,136773]   Compiled 26-Apr-83 11:01   Pascal, Version 1B
               File DSK:LEXGEN.PAS[3,136773]   Compiled 26-Apr-83 11:01   Pascal, Version 1B

               File DSK:LEXGEN.PAS[3,136773]   Compiled 26-Apr-83 11:01   Pascal, Version 1B

               File DSK:LEXGEN.PAS[3,136773]   Compiled 26-Apr-83 11:01   Pascal, Version 1B

               File DSK:LEXGEN.PAS[3,136773]   Compiled 26-Apr-83 11:01   Pascal, Version 1B





			       $       $$$$$   $   $    $$$$   $$$$$   $   $
			       $       $       $   $   $       $       $$  $
			       $       $        $ $    $       $       $ $ $
			       $       $$$       $     $ $$$   $$$     $  $$
			       $       $        $ $    $   $   $       $   $
			       $       $       $   $   $   $   $       $   $
			       $$$$$   $$$$$   $   $    $$$    $$$$$   $   $


				   LEXGEN: lexical analyzer generator


Options in effect: 

	CHECK, NOSPECIAL, NOMAP, SYMBOLS, CALLS, NOASSEMBLY, XREF, TRACE, QBLOCKS, NOOPTIMIZE, CODE, 
	NODEBUG, FINISH, NOGLOBAL, NOMAINSEG, NOOVERLAY, AUTOQUICK, SOURCE, NOSTANDARD, LENGTH (45), 
	WIDTH (107), STORAGE (8192), ALLOC (0), ENABLE(P10)




               File DSK:LEXGEN.PAS[3,136773]   Compiled 26-Apr-83 11:01   Pascal, Version 1B

               File DSK:LEXGEN.PAS[3,136773]   Compiled 26-Apr-83 11:01   Pascal, Version 1B

               File DSK:LEXGEN.PAS[3,136773]   Compiled 26-Apr-83 11:01   Pascal, Version 1B

               File DSK:LEXGEN.PAS[3,136773]   Compiled 26-Apr-83 11:01   Pascal, Version 1B
MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 0                                                                                            PAGE 1

    1	$TITLE LEXGEN: lexical analyzer generator
    2	$WIDTH (107)
    3	$SOURCE
    4	  
    5	  
    6	(*      LEXGEN  -  lexical analyzer generator
    7	  
    8	        Ralph D. Jeffords,  University of Mississippi,  April 1979
    9	        Version 2  (first distribution)
   10	  
   11	  
   12	        Modifications by Dave Wilson:
   13	  
   14	            - Totally reformatted and cleaned up for readability (according to my private
   15	              prejudices).
   16	   
   17	            - Minimization always done, not optional, since minimization takes only a small
   18	              fraction of the running time.  Unminimized DELTA is not printed at all.
   19	    
   20	            - Representation of DFA states changed from packed arrays of booleans to arrays of
   21	              sets, since sets are operated on a word at a time, rather than bit by bit.  Speed
   22	              improvement was a factor of 100 on a large example.
   23	    
   24	            - Intermediate-backup node numbering changed to not be wasteful, as recommended in the
   25	              implementation notes.
   26	    
   27	            - DELTA rows allocated as needed, and packed.  The packing saves a great deal of core
   28	              with no apparent loss of efficiency, while allocating rows means only large DFAs
   29	              need use a lot of core for DELTA.
   30	    
   31	            - Added routine to print the scanner program from Appendix B of the LEXGEN user
   32	              manual, filling in all the constants and tables that LEXGEN has information about. 
   33	              The additional code and tables required for the lookahead feature are included just
   34	              if they are required.
   35	    
   36	            - The two options for printing NFA diagrams and graphs have been combined.
   37	    
   38	            - INTEGER types have been eliminated, and tag fields added to record variants that
   39	              didn't have them, so that the "special" compiler option isn't required.
   40	    
   41	            - When handling semantics of productions that build terminal sets, the sets are
   42	              kept on the stack, rather than carried "off the side", resulting in consistentMODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 0                                                                                            PAGE 2

   43	              handling of semantic information.
   44	    
   45	            - Ascii "delete" character used as internal end-of-line mark rather than backslash to
   46	              avoid any interference with use of the entire printable set of characters.
   47	    
   48	            - MINIMIZE_DFA changed to add DFA states to end of equivalence class member lists
   49	              rather than at the beginning, making reindexing unnecessary.
   50	  
   51	            - Implemented transition table compaction technique described in Aho & Ullman.  The
   52	              user is given the choice of having the compacted or uncompacted form of DELTA
   53	              incorporated in the output scanner program.
   54	  
   55	            - Bug in minimization algorithm removed.
   56	  
   57	          --------------------
   58	  
   59	            - Representation of DFA states further changed from arrays of sets to just sets
   60	              to take advantage of the "long" set capability of the MDSI compiler.
   61	
   62	            - The setup of nextif, the transition function of the NFAs, was leaving the
   63	              entries for the final and intermediate-backup states unitialized, but
   64	              was accessing those entries (unnecessarily) when performing the breadth
   65	              first search.  It worked on the DEC 10, but not on other machines.
   66	
   67	            - Altered scanning of input to eliminate any restriction on input line lengths.
   68	
   69	            - Exhaustively reworked the entire program.
   70	*)MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 1            constant definitions                                                            PAGE 3

    2	program lexgen
    3	      options storage (8192), xref, symbols, calls;
    4	  
    5	const 
    6	      maxsymlen     =   25;           (* the maximum length of a symbol *)
    7	      maxcols       =   24;           (* max # of columns across page for delta *)
    8	      lambda        =    0;           (* code for null *)
    9	      maxnonter     =   40;           (* max # of nonterminals for input grammar *)
   10	      maxtermsets   =   20;           (* max # of sets of terminals for input grammar *)
   11	      min_term      = -107;           (* minimum code for terminals for input grammar *)
   12	      maxifstates   =  287;           (* max # of important/backup/final states *)
   13	      dead          =    0;           (* dead state of DFA *)
   14	      maxdfastates  =  150;           (* max # of DFA states *)
   15	      firstblock    =    0;           (* first equivalence class *)
   16	      maxblocks     = maxdfastates;   (* max possible equivalence classes *)
   17	      max_com_tab   =  750;           (* max size of compacted tables *)
   18	      word_size     =   36;           (* bits per word *)
   19	
   20	      (* constants used by parser: *)
   21	
   22	      maxparsest    =   18;           (* last state of parser *)
   23	      minparcode    = -521;           (* smallest code for parsing table *)
   24	
   25	      meta_lbrack   =  -13;           (*     ]     *)
   26	      meta_rbrack   =  -12;           (*     [     *)
   27	      meta_or       =  -11;           (*     !     *)
   28	      meta_rparen   =  -10;           (*     )     *)
   29	      meta_lparen   =   -9;           (*     (     *)
   30	      terminal      =   -8;           (*  ' ... '  *)
   31	      meta_plus     =   -7;           (*     +     *)
   32	      meta_star     =   -6;           (*     *     *)
   33	      setname       =   -5;           (*  " ... "  *)
   34	      meta_slash    =   -4;           (*     /     *)
   35	      meta_define   =   -3;           (*    ::=    *)
   36	      nonterminal   =   -2;           (*  < ... >  *)
   37	      meta_end      =   -1;           (*     ;     *)
   38	      eodata        =    0;           (*     $     *)
   39	
   40	      terminalhead  =    7;           (* last nonterminal code for parser *)MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 2            type definitions                                                                PAGE 4

    2	type 
    3	     term_range    = min_term..lambda;               (* range of terminals in input *)
    4	     ifstateset    = set of 0..maxifstates;
    5	     dfastaterange = dead..maxdfastates;             (* range of DFA states *)
    6	     errstatus     = (ok, warning, recover);  (* indicators of (nonfatal) error status for lexgen *
	)
    7	  
    8	     nfa_node = 
    9	        record
   10	           arc:  min_term..maxtermsets;       (* arc label *)
   11	           ptr1: ^nfa_node;                   (* major pointer to another node *)
   12	           case node_kind: (skeletal_node, normal_node,
   13	                            important_node, inter_backup_node, final_node) of
   14	              skeletal_node,                     (* initially given to all nodes *)
   15	              normal_node:                      (* after "fix" *)
   16	                   (ptr2: ^nfa_node;          (* secondary pointer used by union and closures *)
   17	                    skeletal_form: (ordinary, union, concatenation,
   18	                                    kleene_closure, positive_closure);
   19	                    scanned: ^nfa_node);      (* special marker to prevent infinite search in NFA *
	)
   20	              important_node,                 (* important state *)
   21	              inter_backup_node,              (* intermediate-backup state (lookahead feature using
   22	                                                 "/") *)
   23	              final_node:                    (* final state *)
   24	                   (ifcode: 1..maxifstates)  (* index this important/backup/final ("ibf") state *)
   25	        end;
   26	  
   27	     delta_row = packed array [min_term..-1] of dfastaterange;
   28	     blockrange = firstblock..maxblocks;     (* range of blocks *)
   29	     member = record
   30	                 state: dfastaterange;
   31	                 next_mem: ^member
   32	              end;
   33	  
   34	     stackrange = 1..maximum (integer);               (* range of parser stack *)
   35	     elementrange = minparcode..maxparsest;  (* range of parse table entries *)
   36	  
   37	     stacktype = ^array [minimum (stackrange) .. *] of
   38	        record
   39	           stackstate: 1..maxparsest;                     (* parser states *)
   40	           case variant: (symbol_variant, nfa_variant, set_variant) of
   41	              symbol_variant: (symbol: min_term..maxnonter);  (* term.<0, lambda=0, 0<nonterm. *)MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 2            type definitions                                                                PAGE 5

   42	              nfa_variant:    (initial, final: ^nfa_node);  (* point to initial,final nodes of NFA 
	*)
   43	              set_variant:    (term_set: set of lambda .. -min_term) (* set of terminals *)
   44	        end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 3            variable declarations                                                           PAGE 6

    2	var 
    3	     p: array [1..maxparsest, meta_lbrack..terminalhead]
    4	           of elementrange;  (* parsing action/goto table *)
    5	     lhs: array [-21..-2] of 1..terminalhead;  (* left hand sides of parser productions *)
    6	     rhslength: array [-21..-2] of 0..5;  (* length of right hand side of each parser production *)
    7	     st: 1..maxparsest;
    8	     la: meta_lbrack..terminalhead;
    9	   
   10	     t: record   (* terminal symbol table *)
   11	           symmax:   term_range;
   12	           symtable: array [term_range] of
   13	                        record
   14	                           sym:     string [maxsymlen]
   15	                        end
   16	        end;
   17	     
   18	     s: record   (* terminal set symbol table *)
   19	           symmax:   0..maxtermsets;
   20	           symtable: array [1..maxtermsets] of
   21	                        record
   22	                           sym:     string [maxsymlen];
   23	                           defined: boolean;
   24	                           term_set: set of lambda .. -min_term
   25	                        end
   26	        end;
   27	  
   28	     n: record   (* nonterminal symbol table *)
   29	           symmax:   1..maxnonter;
   30	           symtable: array [1..maxnonter] of
   31	                        record
   32	                           sym:     string [maxsymlen];
   33	                           initial,           (* pointer to initial node of associated NFA *)
   34	                           intermed,          (*    "    "  interm.-backup node of assoc. NFA *)
   35	                           final:   ^nfa_node (*    "    "  final node of associated NFA *)
   36	                        end
   37	        end;
   38	  
   39	     errors:        errstatus;
   40	     last_int_back: 1..maxifstates;           (* actual index of last intermediate-backup state *)
   41	     which_nfa:     packed array [1..maxifstates]
   42	                       of 1..maxnonter;       (* cross ref. backup states to NFAs *)
   43	     last_nfa:      1..maxnonter;             (* actual index of last final state *)MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 3            variable declarations                                                           PAGE 7

   44	     last_ibf:      1..maxifstates;           (* actual last ibf state *)
   45	     last_dfa:      dfastaterange;            (* actual last DFA state *)
   46	     delta:         array [dfastaterange]
   47	                       of ^delta_row;         (* transition table for DFA *)
   48	     dfastate:      array [dfastaterange]
   49	                       of ifstateset;         (* DFA states repr. as sets of ibf states *)
   50	  
   51	     whichblock: array [dfastaterange] of blockrange; (* xref DFA states to equivalence classes *)
   52	     block: array [blockrange] of
   53	               record
   54	                  element_cnt: dfastaterange; (* no. of members in block *)
   55	                  first_mem,
   56	                  last_mem: ^member   (* ^ chain of member DFA states in this equivalence class *)
   57	               end;
   58	     last_block: blockrange;          (* actual last equivalence class of minimized DFA *)
   59	     la_feature: boolean;             (* flag indicating use of the lookahead feature *)MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 4            semantics declarations                                                          PAGE 8

    2	procedure semantics (var stack:     stacktype;
    3	                         action:    elementrange; 
    4	                         tos:       stackrange;
    5	                     var print_nfa: boolean); 
    6	
    7	   var 
    8	      temp_initial, temp_final: ^nfa_node;
    9	      tsym: term_range;
   10	      tsetsym: 1..maxtermsets;
   11	
   12	  
   13	  
   14	   procedure newnode (var n: ^nfa_node);   
   15	
   16	      begin
   17	         new (n, skeletal_node);   (* allocate node with skeletal variant *)
   18	         n^ := (lambda, nil, skeletal_node, nil, ordinary, nil)
   19	      end;
   20	  
   21	  
   22	  
   23	   procedure errout (mtype: errstatus;
   24	                     msg:   packed array [1..*] of char);
   25	
   26	      begin
   27	         write ('     *****      ');
   28	         if errors < mtype then             (* most serious error so far *)
   29	            errors := mtype;
   30	         case mtype of
   31	            warning:
   32	               writeln (msg);
   33	            recover:
   34	               writeln (msg, ' is undefined - will use null string nfa and continue.')
   35	         end
   36	      end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                26-Apr-83 11:01
SECTION 5            copy   in semantics                                                             PAGE 9

    2	   procedure copy (var i, f:   ^nfa_node;
    3	                       ti, tf: ^nfa_node);
    4	  
    5	   (* copy the skeletal NFA (ti,tf) to (i,f)  *)
    6	
    7	      begin
    8	         newnode (i);
    9	         i^.arc := ti^.arc;
   10	         i^.skeletal_form := ti^.skeletal_form;
   11	  
   12	         case i^.skeletal_form of
   13	            ordinary: begin                              (* terminal or terminal-set NFA *)
   14	               newnode (f);
   15	               i^.ptr1 := f;
   16	               i^.ptr2 := nil
   17	            end;
   18	
   19	            union: begin
   20	               newnode (f);
   21	               copy (i^.ptr2, f^.ptr2, ti^.ptr2, tf^.ptr2);          (* dupl. 2nd component NFA *)
   22	               copy (i^.ptr1, f^.ptr2^.ptr1, ti^.ptr1, tf^.ptr2^.ptr1);
   23	                                                                     (*  "    1st     "      "  *)
   24	               f^.ptr2^.ptr1^.ptr1 := f
   25	            end;
   26	
   27	            concatenation: begin
   28	               copy (i^.ptr1, i^.ptr2, ti^.ptr1, ti^.ptr2);          (* dupl. 1st component NFA *)
   29	               copy (i^.ptr2^.ptr1, f, ti^.ptr2^.ptr1, tf)           (*  "    2nd     "      "  *)
   30	            end;
   31	
   32	            kleene_closure, positive_closure: begin
   33	               newnode (f);
   34	               copy (i^.ptr1, f^.ptr2, ti^.ptr1, tf^.ptr2);          (* dupl. component NFA *)
   35	               i^.ptr2 := f;
   36	               f^.ptr2^.ptr1 := f
   37	            end
   38	         end
   39	      end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 6            print_term_nfa, print_termset_nfa, print_union_nfa   in semantics              PAGE 10

    2	   procedure print_term_nfa (symbol: term_range);    (* print terminal NFA *)
    3	
    4	      begin
    5	         writeln;
    6	         writeln;
    7	         writeln (' ':21, '''', t.symtable [symbol].sym, '''');
    8	         writeln (tos:3, ':      O-------------------------------->(O)')
    9	      end;
   10	
   11	
   12	   procedure print_termset_nfa (symbol: 1..maxtermsets);    (* print terminal set NFA *)
   13	
   14	      begin
   15	         writeln;
   16	         writeln;
   17	         writeln (' ':21, '"', s.symtable [symbol].sym, '"');
   18	         writeln (tos:3, ':      O-------------------------------->(O)')
   19	      end;
   20	
   21	  
   22	   procedure print_union_nfa; (* print union NFA *)
   23	
   24	      begin
   25	         writeln;
   26	         writeln;
   27	         writeln ('                    ___________');
   28	         writeln ('                   /           \');
   29	         writeln ('                  /             \');
   30	         writeln ('               ->( 0    ', tos:3, '    0 )____');
   31	         writeln ('              /   \             /     \');
   32	         writeln ('             /     \___________/       \');
   33	         writeln ('            /                           !');
   34	         writeln ('           /                            V');
   35	         writeln (tos:3, ':      O                            (O)');
   36	         writeln ('           \                           /\');
   37	         writeln ('            \       ___________        /');
   38	         writeln ('             \     /           \      /');
   39	         writeln ('              \   /             \    /');
   40	         writeln ('               ->( 0    ', tos+2:3, '    0 )__/');
   41	         writeln ('                  \             /');
   42	         writeln ('                   \___________/')
   43	      end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 7            print_closure_nfa, print_concat_nfa   in semantics                             PAGE 11

    2	   procedure print_closure_nfa; (* print closure NFA *)
    3	
    4	      begin
    5	         writeln;
    6	         writeln;
    7	         writeln ('                    ____________');
    8	         writeln ('                   /            \');
    9	         writeln ('                  !              \');
   10	         writeln ('                  ! ___________   !');
   11	         writeln ('                  V/           \  !');
   12	         writeln ('                  /             \/');
   13	         writeln ('               ->( 0    ', tos:3, '    0 )____');
   14	         writeln ('              /   \             /     \');
   15	         writeln ('             /     \___________/       \');
   16	         writeln ('            /                           !');
   17	         writeln ('           /                            V');
   18	         writeln (tos:3, ':      O                            (O)');
   19	
   20	         if action = -10  (* kleene closure *) then
   21	            begin
   22	               writeln ('           \                           /\');
   23	               writeln ('            \                          /');
   24	               writeln ('             \________________________/')
   25	            end
   26	      end;
   27	
   28	  
   29	  
   30	   procedure print_concat_nfa; (* print concatenation NFA *)
   31	
   32	      begin
   33	         writeln;
   34	         writeln;
   35	         writeln ('                  ___________            ___________');
   36	         writeln ('                 /           \          /           \');
   37	         writeln ('                /             \        /             \');
   38	         writeln (tos:3, ':      O--->( 0    ', tos:3, '    0 )----->( 0   ', tos+1:3, '   (O) )');
   39	         writeln ('                \             /        \             /');
   40	         writeln ('                 \___________/          \___________/')
   41	      end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 8            semantics                                                                      PAGE 12

    2	   begin (* semantics *)
    3	
    4	      case action of
    5	  
    6	         -3, (* <tokens> ::= 'nonterminal' *)
    7	         -4: (* <tokens> ::= <tokens> 'nonterminal' *)
    8	      
    9	         (* The form of the productions ensures that this list of nonterminals to
   10	            be recognized is completely processed before the first regular expression
   11	            is parsed.  Therefore we can use LAST_NFA to mark where the nonterminal
   12	            symbol table ended after this list is seen, and any later nonterminals
   13	            encountered must be merely intermediate names.  *)
   14	  
   15	         begin
   16	            if last_nfa+1 <> n.symmax then      (* if nonterm. new, FIND just put it in table *)
   17	               errout (warning, 'WARNING: Duplicate token.');
   18	            last_nfa := n.symmax
   19	         end;
   20	
   21	  
   22	  
   23	         -7: (* <production> ::= 'nonterminal' '::=' <expression> *)
   24	  
   25	         with n.symtable [stack^[tos].symbol] do begin
   26	            if initial <> nil then              (* already NFA associated with nonterminal? *)
   27	               errout (warning, 'WARNING: <' || sym || '> reassigned.');
   28	            initial := stack^[tos+2].initial;   (* identify NFA with nonterminal *)
   29	            final := stack^[tos+2].final;
   30	            intermed := nil;                    (* no lookahead nfa *)
   31	            if print_nfa then begin
   32	               writeln;
   33	               writeln;
   34	               writeln ('   <', sym, '> ******* IS ASSIGNED THE NFA ****', tos+2:3)
   35	            end
   36	         end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 8            semantics                                                                      PAGE 13

   38	         -8: (* <production> ::= 'nonterminal' '::=' <expression> '/' <expression> *)
   39	  
   40	         with n.symtable [stack^[tos].symbol] do begin
   41	            if initial <> nil then              (* already NFA associated with nonterminal? *)
   42	               errout (warning, 'WARNING: <' || sym || '> reassigned.');
   43	
   44	            (* concat. the two NFAs and identify resulting lookahead NFA with nonterm. *)
   45	
   46	            intermed := stack^[tos+2].final;    (* token actually ends with end of expr1 *)
   47	            newnode (initial);                  (* initial node of concatenation NFA *)
   48	            initial^.skeletal_form := concatenation;
   49	            initial^.ptr1 := stack^[tos+2].initial; (* arc to expr1 NFA's initial node *)
   50	            initial^.ptr2 := intermed;          (* hook new initial to expr1 final (for copying) *)
   51	            stack^[tos+2].final^.ptr1 := stack^[tos+4].initial;
   52	                                                (* from token NFA to lookahead NFA *)
   53	            final := stack^[tos+4].final;
   54	            if print_nfa then begin
   55	               writeln;
   56	               writeln;
   57	               writeln ('   <', sym, '> **** IS ASSIGNED THE NFA ****', tos+2:3, '//', tos+4:3)
   58	            end
   59	         end;
   60	
   61	  
   62	  
   63	         -9: (* <production> ::= 'setname' '::=' <terminalset> *)
   64	  
   65	         with s.symtable [stack^[tos].symbol] do begin
   66	            if defined then                     (* already set associated with setname? *)
   67	               errout (warning, 'WARNING: "' || sym || '" reassigned.');
   68	            term_set := stack^[tos+2].term_set;
   69	            defined := true
   70	         end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 8            semantics                                                                      PAGE 14

   72	         -10, (* <expression> ::= <expression> '*' *)
   73	         -11: (* <expression> ::= <expression> '+' *)
   74	  
   75	         begin
   76	            newnode (temp_initial);                       (* initial node of closure NFA *)
   77	            newnode (temp_final);                         (* final    "   "     "    "   *)
   78	            with temp_initial^ do
   79	               begin
   80	                  if action = -10 then
   81	                     skeletal_form := kleene_closure
   82	                  else
   83	                     skeletal_form := positive_closure;
   84	                  ptr1 := stack^[tos].initial;            (* arc from new initial to old
   85	                                                             init. node *)
   86	                  temp_final^.ptr2 := stack^[tos].final;  (* connect new final to old
   87	                                                             (for copying) *)
   88	                  ptr2 := temp_final;                     (* arc from initial to final node *)
   89	                  stack^[tos].final^.ptr1 := temp_final;  (* from old final to new final *)
   90	                  stack^[tos].initial := temp_initial;    (* identify new NFA with expr. *)
   91	                  stack^[tos].final := temp_final;        (*    "      "   "    "    "   *)
   92	                  if print_nfa then
   93	                     print_closure_nfa
   94	               end
   95	         end;
   96	
   97	  
   98	  
   99	         -12: (* <expression> ::= <expression><expression> *)
  100	  
  101	         begin
  102	            newnode (temp_initial);                       (* initial node of concat. NFA *)
  103	            temp_initial^.skeletal_form := concatenation;
  104	            temp_initial^.ptr1 := stack^[tos].initial;    (* arc to expr1 NFA's init. node *)
  105	            temp_initial^.ptr2 := stack^[tos].final;      (* conn. new init. to expr1 final
  106	                                                             (for copying)  *)
  107	            stack^[tos].final^.ptr1 := stack^[tos+1].initial; (* from expr1 final to expr2 init. *)
  108	            stack^[tos].initial := temp_initial;          (* identify new NFA with expr. *)
  109	            stack^[tos].final := stack^[tos+1].final;     (*    "      "   "    "    "   *)
  110	            if print_nfa then
  111	               print_concat_nfa
  112	         end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 8            semantics                                                                      PAGE 15

  114	         -14: (* <expression> ::= 'nonterminal' *)
  115	  
  116	         with n.symtable [stack^[tos].symbol] do begin
  117	            stack^[tos].variant := nfa_variant;
  118	            if initial = nil then begin       (* undefined - recover by assuming null string NFA *)
  119	               errout (recover, '<' || sym || '>');
  120	               newnode (stack^[tos].initial);
  121	               newnode (stack^[tos].final);
  122	               stack^[tos].initial^.ptr1 := stack^[tos].final;
  123	               if print_nfa then
  124	                  print_term_nfa (lambda)
  125	            end
  126	            else begin   (* yes - copy NFA from nonterminal *)
  127	               copy (stack^[tos].initial, stack^[tos].final, initial, final);
  128	               if print_nfa then begin
  129	                  writeln;
  130	                  writeln;
  131	                  writeln (tos:3, ': ****** IS COPIED FROM ***** <', sym, '>')
  132	               end
  133	            end
  134	         end;
  135	  
  136	
  137	         -16: (* <expression> ::= '(' <expression> ')' *)
  138	  
  139	         begin
  140	            stack^[tos].variant := nfa_variant;
  141	            stack^[tos].initial :=  stack^[tos+1].initial;
  142	            stack^[tos].final := stack^[tos+1].final;
  143	            if print_nfa then begin
  144	               writeln;
  145	               writeln;
  146	               writeln (tos:3, ': ******* IS THE NEW LABEL FOR ****', tos+1:3)
  147	            end
  148	         end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 8            semantics                                                                      PAGE 16

  150	         -17: (* <expression> ::= <expression> '!' <expression> *)
  151	  
  152	         begin
  153	            newnode (temp_initial);                      (* initial node of union NFA *)
  154	            temp_initial^.skeletal_form := union;
  155	            temp_initial^.ptr1 := stack^[tos].initial;   (* arc to expr1 NFA's initial node *)
  156	            temp_initial^.ptr2 := stack^[tos+2].initial; (*  "   " expr2   "      "     "   *)
  157	            newnode (temp_final);                        (* final node of union NFA *)
  158	            stack^[tos].final^.ptr1 := temp_final;       (* arc from expr1 final to new final *)
  159	            temp_final^.ptr2 := stack^[tos+2].final;     (* connect new final to expr2 final
  160	                                                            (for copying)  *)
  161	            stack^[tos+2].final^.ptr1 := stack^[tos].final;
  162	                                                         (* conn. expr2 final to expr1 (for
  163	                                                            copying) *)
  164	            stack^[tos].initial := temp_initial;         (* identify new NFA with expression *)
  165	            stack^[tos].final :=  temp_final;            (*     "     "   "   "        "     *)
  166	            if print_nfa then
  167	               print_union_nfa
  168	         end;
  169	  
  170	  
  171	         -18, (* <expression> ::= '' *)
  172	         -13: (* <expression> ::= 'terminal' *)
  173	  
  174	         begin
  175	            tsym := stack^[tos].symbol;              (* save the symbol from rhs *)
  176	            stack^[tos].variant := nfa_variant;
  177	            newnode (stack^[tos].initial);               (* initial node of NFA *)
  178	            newnode (stack^[tos].final);                 (* final node of NFA *)
  179	            with stack^[tos].initial^ do begin
  180	               arc := tsym;                              (* label arc with terminal (codes<=0) *)
  181	               ptr1 := stack^[tos].final;                (* arc from initial to final node *)
  182	               if print_nfa then
  183	                  print_term_nfa (arc)
  184	            end
  185	         end;
  186	
  187	
  188	         -15: (* <expression> ::= 'setname'  *)
  189	  
  190	         begin
  191	            tsetsym := stack^[tos].symbol;              (* save the symbol from rhs *)MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 8            semantics                                                                      PAGE 17

  192	            stack^[tos].variant := nfa_variant;
  193	            newnode (stack^[tos].initial);               (* initial node of NFA *)
  194	            newnode (stack^[tos].final);                 (* final node of NFA *)
  195	            with stack^[tos].initial^ do begin
  196	               if not s.symtable [tsetsym].defined then begin
  197	                  errout (recover, '"' || s.symtable [stack^[tos].symbol].sym || '"');
  198	                  arc := lambda
  199	               end
  200	               else
  201	                  arc := tsetsym;                           (* label arc with terminal (codes<=0) *
	)
  202	               ptr1 := stack^[tos].final;                (* arc from initial to final node *)
  203	               if print_nfa then
  204	                  print_termset_nfa (arc)
  205	            end
  206	         end;
  207	
  208	         -20: (* <terminalhead> := '[' *)
  209	  
  210	         begin
  211	            stack^[tos].variant := set_variant;
  212	            stack^[tos].term_set := []                   (* initialize set to be empty *)
  213	         end;
  214	
  215	  
  216	   
  217	         -21: (* <terminalhead> ::= <terminalhead> 'terminal' *)
  218	  
  219	            stack^[tos].term_set := stack^[tos].term_set + [ -stack^[tos+1].symbol];
  220	                                                         (* add terminal to set *)
  221	
  222	  
  223	         others: (* -2: <complete> ::= <tokens> ';' <prodset>
  224	                    -5: <prodset> ::= <production>
  225	                    -6: <prodset> ::= <prodset> ';' <production>
  226	                   -19: <terminalset> ::= <terminalhead> ']'     *)
  227	
  228	                         (*  --- no semantics ---  *)
  229	  
  230	      end (* case action *)
  231	   end (* semantics *);MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 9            parse_regular_expressions  declarations                                        PAGE 18

    2	procedure parse_regular_expressions;     (* parse input and create NFA's *)
    3	  
    4	   const 
    5	      accept     =  -1;   (* code for accept action *)
    6	      errorstate =   0;   (* code for parsing error *)
    7	      lr0reduce  =-500;   (* addend to indicate special code for replaced lr0-reduce state *)
    8	      shift      =   0;   (* code for shift *)
    9	      eod_term   =  -1;   (* code for end-of-data terminal *)
   10	      stack_allocation_increment = 25;
   11	
   12	   var 
   13	      stack:        stacktype;
   14	      currentstate: 1..maxparsest;
   15	      tos:          stackrange;
   16	      action, oldaction: elementrange;
   17	      print_nfa:    boolean;
   18	      curr_nfa:     1..maxnonter;
   19	      tsym:         term_range;
   20	
   21	
   22	  
   23	   procedure newnode (var n: ^nfa_node);
   24	
   25	      begin
   26	         new (n, skeletal_node);   (* allocate node with skeletal variant *)
   27	         n^ := (lambda, nil, skeletal_node, nil, ordinary, nil)
   28	      end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 10           next_lexeme  in parse_regular_expressions                                      PAGE 19

    2	   (* NEXT LEXEME obtains the next lexeme from the input file.  NEWSYM_TYPE will
    3	      be set to indicate the lexeme, and in the case of terminal, terminal-set,
    4	      or nonterminal, NEWSYM will be the actual character string.  BUFFER and
    5	      BUFFER_POS preserve the state of the input scanning from one call to the next. *)
    6	
    7	   const
    8	      buffer_allocation_increment = 100;
    9	   
   10	   type
   11	      input_text_string = ^string [*];
   12	
   13	   var
   14	      buffer: input_text_string;
   15	      buffer_pos: 0..maximum (integer);
   16	   
   17	   procedure init_next_lexeme;
   18	      begin
   19	         new (buffer, buffer_allocation_increment);
   20	         buffer^ := '';
   21	         buffer_pos := 0
   22	      end;
   23	
   24	   procedure term_next_lexeme;
   25	      begin
   26	         dispose (buffer)
   27	      end;
   28	
   29	   procedure next_lexeme (var newsym_type: meta_lbrack..eodata; var newsym: string [maxsymlen]);
   30	
   31	      var 
   32	         truncated, lexeme_found: boolean;
   33	         end_char: char;
   34	         scan_state: (init, got_end_char, end_of_line, done);
   35	         temp_buffer: input_text_string;
   36	         next_line_seg: string [buffer_allocation_increment];
   37	
   38	      const
   39	         char_to_lexeme_table: array [meta_lbrack..eodata] of char :=
   40	               ('[', ']', '!', ')', '(', '''', '+', '*', '"', '/', ':', '<', ';', chr (127));
   41	
   42	
   43	      procedure next_line;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 10           next_lexeme  in parse_regular_expressions                                      PAGE 20

   44	         begin
   45	            if not eof (input) then begin
   46	               read (input, buffer^);
   47	               while not eoln (input) do begin
   48	                  read (input, next_line_seg);
   49	                  new (temp_buffer, upperbound (buffer^) + buffer_allocation_increment);
   50	                  temp_buffer^ := buffer^ || next_line_seg;
   51	                  dispose (buffer);
   52	                  buffer := temp_buffer
   53	               end;
   54	               readln (input);
   55	               writeln ('INPUT:   ', buffer^)
   56	            end
   57	            else
   58	               buffer^ := '';
   59	            buffer^ := buffer^ || chr (127);        (* internal end-of-line marker *)
   60	            buffer_pos := 0
   61	         end;
   62	
   63	      procedure errout (mtype: errstatus; msg: packed array [1..*] of char);
   64	
   65	         begin
   66	            write ('     *****      ');
   67	            if (errors < mtype) then                    (* most serious error so far? *)
   68	               errors := mtype;
   69	            writeln (msg)
   70	         end (* errout *);
   71	
   72	
   73	      procedure insertch; (* insert char into sym *)
   74	
   75	         begin
   76	            if length (newsym) < upperbound (newsym) then
   77	               newsym := newsym || buffer^ [buffer_pos]
   78	            else begin
   79	               if not truncated (* had already run out of room? *) then
   80	                  errout (warning, 'WARNING: Symbol too long - had to be truncated.');
   81	               truncated := true                     (* remember warning already given *)
   82	            end
   83	         end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 10           next_lexeme  in parse_regular_expressions                                      PAGE 21

   85	      begin (* next_lexeme *)
   86	
   87	         repeat   (* until lexeme found *)
   88	            lexeme_found := false;
   89	
   90	            if buffer_pos >= length (buffer^) then       (* has buffer's contents been used up? *)
   91	               repeat
   92	                  next_line                              (* setup buffer with next input line *)
   93	               until buffer^ [1] <> '*';                 (* until not a comment line *)
   94	            repeat 
   95	               buffer_pos := buffer_pos + 1
   96	            until buffer^ [buffer_pos] <> ' ';
   97	
   98	            newsym_type := lowerbound (char_to_lexeme_table);
   99	            repeat
  100	             exit if buffer^ [buffer_pos] = char_to_lexeme_table [newsym_type];
  101	               newsym_type := newsym_type + 1
  102	            until newsym_type = upperbound (char_to_lexeme_table);
  103	
  104	            if buffer^ [buffer_pos] <> char_to_lexeme_table [newsym_type] then
  105	               errout (recover, 'Illegal character ''' || buffer^ [buffer_pos] || '''.')
  106	            else if buffer^ [buffer_pos] in ['"', '''', '<'] then begin  (* language symbols *)
  107	               newsym := '';
  108	               if buffer^ [buffer_pos] = '<' then
  109	                  end_char := '>' (* reading nonterminal name *)
  110	               else
  111	                  end_char := buffer^ [buffer_pos]; (* reading terminal or terminal-set name *)
  112	               truncated := false;
  113	               scan_state := init;
  114	               repeat
  115	                  buffer_pos := buffer_pos + 1;
  116	                  case scan_state of
  117	                     init:
  118	                          if buffer^ [buffer_pos] = end_char then
  119	                             scan_state := got_end_char
  120	                          else if buffer^ [buffer_pos] = chr (127) then
  121	                             scan_state := end_of_line
  122	                          else
  123	                             insertch;
  124	                     got_end_char:
  125	                          if buffer^ [buffer_pos] = end_char then begin (* doubled? *)
  126	                             insertch;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 10           next_lexeme  in parse_regular_expressions                                      PAGE 22

  127	                             scan_state := init
  128	                          end
  129	                          else begin
  130	                             scan_state := done; (* was really end *)
  131	                             buffer_pos := buffer_pos - 1 (* back up one char *)
  132	                          end
  133	                  end
  134	               until (scan_state = done) or (scan_state = end_of_line);
  135	
  136	               if scan_state = end_of_line then
  137	                  errout (recover, 'Symbol continues across end of line.')
  138	               else if (newsym_type <> terminal) and (newsym = '') then
  139	                  errout (recover, '<> or "" invalid.')
  140	               else
  141	                  lexeme_found := true
  142	            end (* language symbols *)
  143	
  144	            else if buffer^ [buffer_pos] = ':' then begin
  145	               lexeme_found := true;
  146	               if ((length (buffer^) - buffer_pos) < 3) orif (buffer^ [buffer_pos:3] <> '::=') then
  147	                  errout (recover, '::= mistyped.');
  148	               if buffer^ [buffer_pos + 1] in [':', '='] then  (* allow for slight scrambling *)
  149	                  buffer_pos := buffer_pos + 1;
  150	               if buffer^ [buffer_pos + 1] in [':', '='] then
  151	                  buffer_pos := buffer_pos + 1
  152	            end
  153	
  154	            else if (newsym_type <> eodata) or eof (input) then
  155	               lexeme_found := true
  156	         until lexeme_found
  157	
  158	      end (* next_lexeme *);MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 11           find  in parse_regular_expressions                                             PAGE 23

    2	   procedure find (newsym_type: meta_lbrack..eodata; newsym: string [maxsymlen]);   
    3	
    4	      procedure tablefull;
    5	
    6	         begin
    7	            case newsym_type of
    8	               terminal:    write (ttyoutput, 'TERMINAL');
    9	               setname:     write (ttyoutput, 'SETNAME');
   10	               nonterminal: write (ttyoutput, 'NONTERMINAL')
   11	            end;
   12	            writeln (ttyoutput, ' SYMBOL TABLE OVERFLOW');
   13	            stop
   14	         end (* tablefull *);
   15	
   16	
   17	      begin (* find *)
   18	  
   19	         stack^[tos].variant := symbol_variant;
   20	         case newsym_type of
   21	  
   22	            terminal:
   23	               with t do begin
   24	                  if symmax <= min_term then
   25	                     tablefull;                         (* no room to put symbol I'm looking for *)
   26	                  stack^[tos].symbol := lambda;
   27	                  symtable [symmax-1].sym := newsym;    (* insert at end of table *)
   28	                  while (length (symtable [stack^[tos].symbol].sym) <> length (newsym)) or
   29	                        (symtable [stack^[tos].symbol].sym <> newsym) do   (* search table *)
   30	                     stack^[tos].symbol := stack^[tos].symbol - 1;
   31	                  if stack^[tos].symbol < symmax then   (* it wasn't in table? *)
   32	                     symmax := symmax - 1               (* now it is *)
   33	               end;
   34	
   35	            setname:
   36	               with s do begin
   37	                  if symmax >= maxtermsets then
   38	                     tablefull;                         (* no room to put symbol I'm looking for *)
   39	                  stack^[tos].symbol := 1;
   40	                  symtable [symmax+1].sym := newsym;    (* insert at end of table *)
   41	                  while (symtable [stack^[tos].symbol].sym <> newsym) do   (* search table *)
   42	                     stack^[tos].symbol := stack^[tos].symbol + 1;
   43	                  if stack^[tos].symbol > symmax then begin (* it wasn't in table? *)MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 11           find  in parse_regular_expressions                                             PAGE 24

   44	                     symmax := symmax + 1;              (* now it is ... *)
   45	                     symtable [symmax].defined := false (* ... but it hasn't any definition yet *)
   46	                  end
   47	               end;
   48	
   49	            nonterminal:
   50	               with n do begin
   51	                  if symmax >= maxnonter then
   52	                     tablefull;                         (* no room to put symbol I'm looking for *)
   53	                  stack^[tos].symbol := 1;
   54	                  symtable [symmax+1].sym := newsym;    (* insert at end of table *)
   55	                  while (symtable [stack^[tos].symbol].sym <> newsym) do   (* search table *)
   56	                     stack^[tos].symbol := stack^[tos].symbol + 1;
   57	                  if stack^[tos].symbol > symmax then begin (* it wasn't in table? *)
   58	                     symmax := symmax + 1;              (* now it is ... *)
   59	                     symtable [symmax].initial := nil;  (* ... but it has no associated nfa *)
   60	                     symtable [symmax].intermed := nil;
   61	                     symtable [symmax].final := nil
   62	                  end
   63	               end
   64	         end
   65	  
   66	      end (* find *);MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 12           pushsymbol   in parse_regular_expressions                                      PAGE 25

    2	   procedure pushsymbol (action: elementrange;
    3	                         newsym_type: meta_lbrack..eodata;
    4	                         newsym: string [maxsymlen]);    (* push symbol onto parser stack *)
    5	
    6	      var
    7	         tempstack: stacktype;
    8	         stackindex: stackrange;
    9	
   10	      begin
   11	         tos := tos + 1;
   12	         if tos > upperbound (stack^) then begin
   13	            new (tempstack, upperbound (stack^) + stack_allocation_increment);
   14	            for stackindex := lowerbound (stack^) to upperbound (stack^) do
   15	               tempstack^[stackindex] := stack^[stackindex];
   16	            dispose (stack);
   17	            stack := tempstack
   18	         end;
   19	         if action = shift then begin
   20	            if (newsym_type = terminal) or
   21	                 (newsym_type = nonterminal) or
   22	                   (newsym_type = setname) then
   23	               find (newsym_type, newsym)     (* put symbol table index of new symbol onto stack *)
   24	         end
   25	         else
   26	            semantics (stack, action, tos, print_nfa)
   27	      end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 13           printnode  in parse_regular_expressions                                        PAGE 26

    2	   procedure printnode (i: ^nfa_node);    (* print a node of NFA *)
    3	
    4	      begin
    5	         write (ord (i):10:o, ':');
    6	         if i^.arc > lambda then
    7	            with s.symtable [i^.arc] do
    8	               write ('"', sym, '"', ' ':maxsymlen-length (sym)+2)
    9	         else
   10	            with t.symtable [i^.arc] do
   11	               write ('''', sym, '''', ' ':maxsymlen-length (sym)+2);
   12	         if i^.ptr1 = nil then
   13	            write ('  - NIL -   ')
   14	         else
   15	            write (ord (i^.ptr1):10:o, '  ');
   16	         if i^.ptr2 = nil then
   17	            writeln ('  - NIL -  ')
   18	         else
   19	            writeln (ord (i^.ptr2):10:o)
   20	      end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 14           fix  in parse_regular_expressions                                              PAGE 27

    2	   procedure fix (var i, f: ^nfa_node);   (* fix up NFA: convert NFA from skeletal to final form *)
    3	
    4	      begin
    5	         case i^.skeletal_form of
    6	            union: begin
    7	               fix (i^.ptr1, f^.ptr2^.ptr1);
    8	               if print_nfa then
    9	                  printnode (f^.ptr2^.ptr1);
   10	               fix (i^.ptr2, f^.ptr2);
   11	               f^.ptr2^.ptr1 := f;
   12	               if print_nfa then
   13	                  printnode (f^.ptr2);
   14	               f^.ptr2 := nil
   15	            end;
   16	
   17	            concatenation: begin
   18	               fix (i^.ptr2^.ptr1, f);
   19	               fix (i^.ptr1, i^.ptr2);
   20	               if print_nfa then
   21	                  printnode (i^.ptr2);
   22	               i^.ptr2 := nil
   23	            end;
   24	
   25	            kleene_closure, positive_closure: begin
   26	               fix (i^.ptr1, f^.ptr2);
   27	               f^.ptr2^.ptr2 := i^.ptr1;
   28	               if print_nfa then
   29	                  printnode (f^.ptr2);
   30	               f^.ptr2 := nil;
   31	               if i^.skeletal_form = positive_closure then
   32	                  i^.ptr2 := nil
   33	            end;
   34	
   35	            ordinary: (* no fixing required *)
   36	         end;
   37	 
   38	         i^.node_kind := normal_node;
   39	         f^.node_kind := normal_node;
   40	
   41	         if print_nfa then
   42	            printnode (i)               (* print initial node - caller will print final node *)
   43	      end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 15           parse_regular_expressions                                                      PAGE 28

    2	   var
    3	      fname: file_name;
    4	      newsym:       string [maxsymlen];
    5	      newsym_type:  meta_lbrack..eodata;
    6	
    7	   begin (* parse_regular_expressions *)
    8	
    9	      (* query user *)
   10	
   11	      rewrite (ttyoutput);
   12	      open (tty);
   13	      repeat
   14	         writeln (ttyoutput);
   15	         write (ttyoutput, 'INPUT FILE-- ');
   16	         break (ttyoutput);
   17	         readln (tty);
   18	         read (tty, fname);
   19	         reset (input, fname);
   20	         if eof (input) then
   21	            writeln (ttyoutput, '?INPUT FILE EMPTY OR NONEXISTENT')
   22	      until not eof (input);
   23	  
   24	  
   25	      write (ttyoutput, 'OUTPUT FILE-- ');
   26	      break (ttyoutput);
   27	      readln (tty);
   28	      read (tty, fname);
   29	      rewrite (output, fname);
   30	  
   31	      repeat
   32	         write (ttyoutput, 'PRINT NFA GRAPH (S)? ');
   33	         break (ttyoutput);
   34	         readln (tty);
   35	         tty^ := uppercase (tty^);
   36	         print_nfa := (tty^ = 'Y');
   37	         if (tty^ <> 'Y') and (tty^ <> 'N') then
   38	            writeln (ttyoutput, '?"YES" OR "NO", PLEASE.')
   39	      until (tty^ = 'Y') or (tty^ = 'N');MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 15           parse_regular_expressions                                                      PAGE 29

   41	      (* initialize nonterminal symbol table and create NFA for eod *)
   42	
   43	      n.symmax := 1;                           (* table starts with eod *)
   44	      with n.symtable [1] do begin
   45	         sym := '*****END OF DATA*****';
   46	         newnode (initial);                    (* initial node of NFA for eod *)
   47	         newnode (final);                      (* final     "  "   "   "   "  *)
   48	         initial^.ptr1 := final;               (* arc from initial to final node *)
   49	         initial^.arc := eod_term;             (* label exiting arc *)
   50	         intermed := nil
   51	      end;
   52	      last_nfa := 1; (* initialize *)
   53	
   54	  
   55	      (* initialize terminal symbol table *)
   56	
   57	      t.symmax := eod_term;                    (* table starts with lambda and eod *)
   58	      t.symtable [lambda].sym := '';
   59	      t.symtable [eod_term].sym := '*****END OF DATA*****';
   60	
   61	  
   62	      (* initialize terminal setname symbol table *)
   63	
   64	      s.symmax := 0;                           (* table is empty *)MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 15           parse_regular_expressions                                                      PAGE 30

   66	      (* parse input  (see Appendix B of LALR1 user manual) *)
   67	
   68	      errors := ok;
   69	      init_next_lexeme; (* initialize the input scanner *)
   70	      new (stack, stack_allocation_increment);
   71	      tos := lowerbound (stack^);   (* initial top of stack *)
   72	      currentstate := 1;
   73	      next_lexeme (newsym_type, newsym);
   74	
   75	      repeat
   76	         stack^[tos].stackstate := currentstate;   (* push current state onto parser stack *)
   77	         action := p [currentstate, newsym_type];
   78	
   79	         (* shift *)
   80	  
   81	         if action > errorstate then begin
   82	            pushsymbol (shift, newsym_type, newsym);
   83	            currentstate := action;
   84	            next_lexeme (newsym_type, newsym)
   85	         end
   86	
   87	         (* reduce *)
   88	  
   89	         else if action < accept then begin
   90	            if action < lr0reduce then begin       (* eliminated lr0 reduce? *)
   91	               pushsymbol (shift, newsym_type, newsym);
   92	               next_lexeme (newsym_type, newsym);
   93	               action := action - lr0reduce        (* modify to prod. # *)
   94	            end;
   95	
   96	            repeat
   97	               tos := tos - rhslength [action];    (* pop parser stack *)
   98	               oldaction := action;
   99	               action := p [stack^[tos].stackstate, lhs [action]];
  100	               pushsymbol (oldaction, newsym_type, newsym)
  101	            until  action >= accept;
  102	  
  103	            if action >= 1 then
  104	               currentstate := action
  105	         end;
  106	
  107	         (* error *)MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 15           parse_regular_expressions                                                      PAGE 31

  108	  
  109	         if action = errorstate then begin
  110	            writeln ('*****SYNTAX ERROR:WILL FLUSH TO NEXT ";" OR EOF AND CONTINUE');
  111	            errors := recover;
  112	            if newsym_type <> eodata then begin
  113	               while (newsym_type <> eodata) and (newsym_type <> meta_end) do
  114	                  next_lexeme (newsym_type, newsym);
  115	               if newsym_type = meta_end then begin
  116	                  next_lexeme (newsym_type, newsym);     (* get symbol after *)
  117	                  action := 1                      (* dummy up for continuing *)
  118	               end;
  119	
  120	               (* reinitialize stack and currentstate *)
  121	               stack^[2].stackstate := 2;
  122	               tos := 3;
  123	               currentstate := 3
  124	            end
  125	         end
  126	      until (action = errorstate) or (action = accept);
  127	      term_next_lexeme; (* terminate the input scanner *)
  128	  
  129	  
  130	
  131	      (* convert skeletal NFA's to final form and (optionally) print them *)
  132	
  133	      for curr_nfa := 1 to last_nfa do
  134	         with n.symtable [ curr_nfa ] do
  135	            if initial <> nil then begin
  136	               if print_nfa then begin
  137	                  writeln;
  138	                  writeln;
  139	                  writeln ('*** NFA <', sym, '>:');
  140	                  writeln
  141	               end;
  142	               fix (initial, final);
  143	               if print_nfa then
  144	                  printnode (final)
  145	            end
  146	            else
  147	               writeln ('     *****     WARNING: NO NFA <', sym, '>');
  148	
  149	MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 15           parse_regular_expressions                                                      PAGE 32

  150	      (*  print codes for terminals,  and for nonterminals to be recognized *)
  151	
  152	      page;
  153	      writeln ('****** CODES FOR TERMINAL SYMBOLS ******');
  154	      writeln;
  155	      writeln ('          CODE   SYMBOL');
  156	      for tsym := t.symmax to -1 do
  157	         writeln ('          ', tsym:3, '   ''', t.symtable [tsym].sym, '''');
  158	
  159	      writeln;
  160	      writeln;
  161	      writeln ('****** CODES FOR NONTERMINALS TO BE RECOGNIZED ******');
  162	      writeln;
  163	      writeln ('          CODE   NONTERMINAL');
  164	      for curr_nfa := 1 to last_nfa do
  165	         writeln ('          ', curr_nfa:3, '   ''', n.symtable [curr_nfa].sym, '''')
  166	  
  167	   end (* parse_regular_expressions *);MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 16           create_dfa  declarations                                                       PAGE 33

    2	procedure create_dfa;
    3	  
    4	   type 
    5	      queuenode =      (* queue to save important states for later processing to create nextif *)
    6	         record
    7	            imp:    ^nfa_node;        (* ^ important state's successor *)
    8	            ifcode: 1..maxifstates; (* index of important state *)
    9	            next:   ^queuenode
   10	         end;
   11	
   12	   var 
   13	      tdfastate: array [min_term..-1]
   14	                    of ifstateset;  (* temporary DFA states for each possible transition *)
   15	      notnull:   array [min_term..-1] of boolean;     (* indicates if transition exists *)
   16	  
   17	      (* nextif[x] has nextset = set of all ibf states reachable from x under a transition via
   18	                   symbol. (Note that each NFA node has at most one non-lambda exiting arc due
   19	                   to the construction method utilizing lambda transitions)                     *)
   20	  
   21	      nextif: array [1..maxifstates] of
   22	                 record
   23	                    symbol:  min_term..maxtermsets;
   24	                    nextset: ifstateset
   25	                 end;
   26	
   27	      tsym:         min_term..-1;
   28	      nsym:         1..maxnonter;
   29	      currdfa,
   30	      nextdfa:      dfastaterange;
   31	      ifstate:      1..maxifstates;
   32	      finalfound:   boolean;
   33	      headqueue,
   34	      tailqueue,
   35	      queue:        ^queuenode;
   36	      oldi:         ^nfa_node;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 17           createnextif  in create_dfa                                                    PAGE 34

    2	   procedure createnextif (var i: ^nfa_node; var iff: ifstateset);
    3	  
    4	      (* find all ibf states reachable under lambda transition from I and add to IFF *)
    5	
    6	      begin 
    7	         if i <> nil then
    8	  
    9	            case i^.node_kind of
   10	  
   11	               normal_node:
   12	                  if i^.arc <> lambda then begin    (* important (i.e. has non-lambda exiting
   13	                                                       arc) not yet marked *)
   14	                     i^.node_kind := important_node;
   15	                     if last_ibf = maxifstates then begin
   16	                        writeln (tty, 'TOO MANY I-F STATES');
   17	                        stop
   18	                     end;
   19	                     last_ibf := last_ibf + 1;
   20	                     i^.ifcode := last_ibf;
   21	                     iff := iff + [i^.ifcode];      (* put into set *)
   22	
   23	                     with nextif [i^.ifcode] do begin
   24	                        symbol := i^.arc;
   25	                        if symbol > lambda then     (* terminal set? *)
   26	                           if lambda in s.symtable [symbol].term_set then  (* lambda in set? *)
   27	                              createnextif (i^.ptr1, iff)
   28	                     end;
   29	                     new (tailqueue^.next);
   30	                     tailqueue := tailqueue^.next;
   31	                     tailqueue^.imp := i^.ptr1;     (* add i^.ptr1 to queue of nodes whose
   32	                                                       arcs haven't been explored yet      *)
   33	                     tailqueue^.ifcode := i^.ifcode;
   34	                     tailqueue^.next := nil
   35	                  end
   36	
   37	                  else if i^.scanned <> oldi then begin (* nonfinal with arc = lambda *)
   38	                     i^.scanned := oldi;            (* mark to avoid infinite loops *)
   39	                     createnextif (i^.ptr1, iff);
   40	                     createnextif (i^.ptr2, iff)
   41	                  end;
   42	
   43	  MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 17           createnextif  in create_dfa                                                    PAGE 35

   44	               important_node,  (* important already marked *)
   45	               final_node:  (* final state *)
   46	                  iff := iff + [i^.ifcode];         (* put into set *)
   47	
   48	               inter_backup_node: begin  (* intermediate-backup state *)
   49	                  createnextif (i^.ptr1, iff);      (* will always have single lambda transition *)
   50	                  iff := iff + [i^.ifcode]          (* put into set *)
   51	               end
   52	            end
   53	      end (* createnextif *);MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 18           duplicate  in create_dfa                                                       PAGE 36

    2	   function duplicate: boolean;
    3	  
    4	      (* compare tdfastate[tsym] with all DFA states already generated and assign
    5	         delta[currdfa,tsym] the one which matches (or nextdfa if none matches) *)
    6	
    7	      var 
    8	         st:   dfastaterange;
    9	         found_dupl: boolean;
   10	
   11	      begin
   12	         st := 1;
   13	         while st < nextdfa do begin
   14	            found_dupl := true;
   15	            if tdfastate [tsym] <> dfastate [st] then
   16	               found_dupl := false;
   17	            if found_dupl then begin
   18	               delta [currdfa]^[tsym] :=  st;
   19	               st := nextdfa (* force exit *)
   20	            end;
   21	            st := st + 1
   22	         end;
   23	
   24	         if not found_dupl then
   25	            delta [currdfa]^[tsym] := nextdfa;
   26	         duplicate := found_dupl
   27	      end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 19           create_dfa                                                                     PAGE 37

    2	   begin (* create_dfa *)
    3	  
    4	      (* first, number the final and intermediate-backup nodes in the NFAs *)
    5	   
    6	      last_int_back := last_nfa;     (* nos. for inter.-backup nodes will follow final node nos. *)
    7	      for nsym := 1 to last_nfa do
    8	         with n.symtable [nsym] do
    9	            if final <> nil then begin
   10	               final^.node_kind := final_node;
   11	               final^.ifcode := nsym;                   (* no. for final node = nonter. code *)
   12	               if intermed <> nil then begin
   13	                  intermed^.node_kind := inter_backup_node;
   14	                  last_int_back := last_int_back+1;     (* allocate a no. for backup node *)
   15	                  intermed^.ifcode := last_int_back;
   16	                  which_nfa [last_int_back] := nsym     (* cross ref. backup node to NFA *)
   17	               end
   18	            end;
   19	  
   20	      new (delta [dead]);
   21	      for tsym := -1 downto t.symmax do
   22	         delta [dead]^[tsym] := dead;  (* initialize dead state to point to itself *)
   23	      dfastate [dead] := [];           (* no NFA states in DFA dead state *)
   24	      last_ibf := last_int_back;       (* numbers for important nodes (i.e.nodes with non-lambda
   25	                                          exiting arcs) will follow the intermediate-backup nodes*)
   26	      new (headqueue);                 (* init. queue with an unused entry so that createnextif
   27	                                          need not handle special case of adding to empty queue *)
   28	      tailqueue := headqueue;
   29	      tailqueue^.next := nil;
   30	
   31	  
   32	      (* put all ibf states of all NFA's initially reachable by lambda transitions
   33	         into the initial DFA state *)
   34	
   35	      dfastate [1] := [];
   36	      for nsym := 1 to last_nfa do begin
   37	         oldi := n.symtable [nsym].initial;
   38	         createnextif (oldi, dfastate [1])
   39	      end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 19           create_dfa                                                                     PAGE 38

   41	      (* build nextif - the set-valued transition function of the NFAs *)
   42	
   43	      queue := headqueue^.next;
   44	      while queue <> nil do begin          (* while there are nodes whose exiting arcs haven't been
   45	                                              explored *)
   46	         nextif [queue^.ifcode].nextset := [];
   47	         oldi := queue^.imp;
   48	         createnextif (oldi, nextif [queue^.ifcode].nextset);
   49	         queue := queue^.next
   50	      end;
   51	  
   52	  
   53	      (* create DFA by breadthfirst search of the NFA's transition function nextif *)
   54	  
   55	      currdfa := 1;
   56	      nextdfa := 2;
   57	
   58	      repeat
   59	         new(delta [currdfa]);                         (* allocate a row for currdfa *)
   60	         for tsym := -1 downto t.symmax do begin
   61	            delta [currdfa]^[tsym] := dead;            (* initially trans. from currdfa are dead *)
   62	            notnull [tsym] := false;                   (* assume no transitions from currdfa *)
   63	            tdfastate [tsym] := []                     (* all temporary DFA states set to null *)
   64	         end;
   65	
   66	         (* find all transitions from currdfa *)
   67	  
   68	         for ifstate := last_int_back + 1 to last_ibf do  (* for each NFA state ...         *)
   69	            if ifstate in dfastate [currdfa] then         (* ... in the current DFA state: *)
   70	               with nextif [ifstate] do
   71	                  if symbol < lambda then begin            (* terminal? *)
   72	                     notnull [symbol] := true;         (* transition from currdfa under symbol *)
   73	                     tdfastate [symbol] := tdfastate [symbol] + nextset
   74	                                                       (* add NFA states reachable under symbol *)
   75	                  end
   76	                  else (* terminal set - process transitions for each terminal in it *)
   77	                     for tsym := -1 downto t.symmax do
   78	                        if -tsym in s.symtable [symbol].term_set then begin
   79	                           notnull [tsym] := true;     (* transition under tsym *)
   80	                           tdfastate [tsym] := tdfastate [tsym] + nextset
   81	                                                       (* add NFA states reachable under tsym *)
   82	                        end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 19           create_dfa                                                                     PAGE 39

   83	
   84	         (* add all DFA state transitions from currdfa to delta *)
   85	
   86	         for tsym := -1 downto t.symmax do
   87	            if notnull [tsym] then
   88	               if not duplicate then begin
   89	                  dfastate [nextdfa] := tdfastate [tsym];
   90	                  if nextdfa = maxdfastates then begin
   91	                     writeln (ttyoutput, 'TOO MANY DFA STATES');
   92	                     stop
   93	                  end;
   94	                  nextdfa := nextdfa + 1
   95	               end;
   96	
   97	         currdfa := currdfa + 1
   98	      until currdfa = nextdfa;                         (* no more new states *)
   99	      last_dfa := currdfa - 1;
  100	  
  101	  
  102	      (* clean up each DFA state in preparation for minimization - only the highest precedence
  103	         final NFA state and the backup states are required to determine the initial partition *)
  104	
  105	      for currdfa := 1 to last_dfa do begin
  106	         finalfound := false;
  107	         for ifstate := 1 to last_nfa do
  108	            if ifstate in dfastate [currdfa] then begin
  109	               if finalfound then   
  110	                  dfastate [currdfa] := dfastate [currdfa] - [ifstate];
  111	               finalfound := true                   (* found highest prec. final - kill the rest *)
  112	            end;
  113	         for ifstate := last_int_back + 1 to last_ibf do
  114	            dfastate [currdfa] := dfastate [currdfa] - [ifstate]
  115	      end
  116	  
  117	   end (* create_dfa *);MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 20           minimize_dfa declarations                                                      PAGE 40

    2	procedure minimize_dfa;
    3	
    4	   var 
    5	      first_state,
    6	      currdfa:        dfastaterange;
    7	      currblock:      blockrange;
    8	      prev_mem,
    9	      curr_mem:       ^member;
   10	      match,
   11	      newblock,
   12	      nochange,
   13	      nomore_deletes: boolean;
   14	      tsym:           term_range;
   15	      lb, ub:         min_term..0;
   16	      ifstate:        1..maxifstates;
   17	
   18	
   19	  
   20	   procedure insert (newstate: dfastaterange; x: blockrange);  
   21	
   22	      begin
   23	         with block [x] do begin
   24	            if first_mem = nil then begin    (* equivalence class empty? *)
   25	               new (first_mem);               (* newstate is only member *)
   26	               last_mem := first_mem
   27	            end
   28	            else begin
   29	               new (last_mem^.next_mem);      (* add newstate to end of list *)
   30	               last_mem := last_mem^.next_mem
   31	            end;
   32	            last_mem^.state := newstate;     (* fill in the next member *)
   33	            last_mem^.next_mem := nil;       (* its the last member *)
   34	            element_cnt := element_cnt + 1
   35	         end
   36	      end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 21           minimize_dfa body                                                              PAGE 41

    2	   begin (* minimize_dfa *)
    3	  
    4	  
    5	      (* initialize *)
    6	  
    7	      for currblock := firstblock to maxblocks do begin
    8	         block [currblock].element_cnt := 0;
    9	         block [currblock].first_mem := nil
   10	      end;
   11	  
   12	
   13	  
   14	      (* find initial partition: each distinct DFA state (as determined by intermediate-backup
   15	         states and highest precedence final state in it) is assigned a different block      *)
   16	
   17	  
   18	      insert (dead, firstblock);              (* dead belongs to firstblock.  initially, all other
   19	                                                 DFA states not containing final or backup states
   20	                                                 will be put there too. *)
   21	      whichblock [dead] := firstblock;       (* cross reference *)
   22	      last_block := firstblock;              (* so far, only have the one block *)
   23	  
   24	      for currdfa := 1 to last_dfa do begin
   25	         currblock := firstblock;
   26	
   27	         repeat
   28	            match := true;
   29	            if dfastate [currdfa] <> dfastate [block [currblock].first_mem^.state] then
   30	               match := false;               (* DFA state is distinct from those in curr. block *)
   31	            if not match then
   32	               currblock := currblock + 1    (* keep looking *)
   33	         until match or (currblock > last_block);
   34	
   35	         whichblock [currdfa] := currblock;   (* indicate currdfa's block *)
   36	         if currblock = last_block+1 then    (* distinct DFA state? *)
   37	            begin
   38	               last_block := last_block + 1; (* allocate new block *)
   39	               insert (currdfa, last_block)    (* put state into new block *)
   40	            end
   41	         else
   42	            insert (currdfa, currblock)        (* put state into block with similar states *)
   43	      end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 21           minimize_dfa body                                                              PAGE 42

   45	      (* Find equivalent states by refining the partition until each block contains only DFA
   46	         states that are equivalent to each other.  At worst, each block will contain only one
   47	         DFA state.  *)
   48	
   49	      repeat
   50	         nochange := true;
   51	         currblock := firstblock;
   52	  
   53	         while currblock <= last_block do begin
   54	            tsym := t.symmax;
   55	
   56	            while (block [currblock].element_cnt > 1) and (tsym <= -1) do begin
   57	               newblock := false;
   58	               first_state := delta [ block [currblock].first_mem^.state ]^[tsym];
   59	  
   60	               repeat   (* until no more DFA states are removed from currblock *)
   61	                  nomore_deletes := true;
   62	                  prev_mem := block [currblock].first_mem;  (* get first consecutive pair *)
   63	                  curr_mem := prev_mem^.next_mem;
   64	
   65	                  while curr_mem <> nil do   (* compare members of the current block *)
   66	                     if whichblock [ delta [curr_mem^.state]^[tsym] ]
   67	                              <> whichblock [first_state] then begin
   68	                        (* if delta(first_mem,tsym) isn't in same block as
   69	                           delta(curr_mem,tsym), curr_mem isn't equivalent to first_mem *)
   70	                        whichblock [curr_mem^.state] := last_block + 1;
   71	                        nochange := false;
   72	                        newblock := true;
   73	                        insert (curr_mem^.state, last_block+1);
   74	                        prev_mem^.next_mem := curr_mem^.next_mem;   (* delete from currblock *)
   75	                        nomore_deletes := false;
   76	                        block [currblock].element_cnt := block [currblock].element_cnt - 1;
   77	                        curr_mem := curr_mem^.next_mem
   78	                     end
   79	                     else begin
   80	                        prev_mem := curr_mem;   (* shift over to next pair in current block *)
   81	                        curr_mem := curr_mem^.next_mem
   82	                     end
   83	               until nomore_deletes;
   84	
   85	               if newblock then
   86	                  last_block := last_block + 1;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 21           minimize_dfa body                                                              PAGE 43

   87	               tsym := tsym + 1
   88	            end;
   89	
   90	            currblock := currblock + 1
   91	         end
   92	      until nochange;
   93	  
   94	  
   95	      (* print minimized delta *)
   96	
   97	      lb := t.symmax;
   98	      repeat
   99	         if (lb + maxcols - 1) <= -1 then   (* need full width of page? *)
  100	            ub := lb + maxcols - 1
  101	         else
  102	            ub := -1;   (* only need portion of width of this page *)
  103	         page;
  104	         writeln ('****** MINIMIZED DFA NEXT STATE TABLE ******');
  105	         writeln;
  106	         write ('      ');
  107	         for tsym := lb to ub do
  108	            write (tsym:3, ' ');
  109	         writeln;
  110	         write ('    __');
  111	         for tsym := lb to ub do
  112	            write ('____');
  113	         writeln;
  114	         for currblock := 1 to last_block do begin
  115	            writeln ('    !');
  116	            write (currblock:3, ' ! ');
  117	            for tsym := lb to ub do
  118	               write (whichblock [delta [block [currblock].first_mem^.state]^[tsym]]:3, ' ');
  119	            writeln
  120	         end;
  121	         lb := ub + 1
  122	      until lb > -1;
  123	      writeln;
  124	      writeln ('****** START STATE: ', whichblock [1]:4);MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 21           minimize_dfa body                                                              PAGE 44

  126	      (* print intermediate-backup and high precedence final states in each DFA state *)
  127	
  128	      page;
  129	      writeln ('****** FINAL/BACKUP STATES IN MINIMIZED DFA ******');
  130	      writeln;
  131	      writeln ('          DFA STATE   FINAL/BACKUP STATE (S)');
  132	      writeln ('            0      *<**ERROR**>');
  133	      la_feature := false;                           (* assume lookahead feature isn't required *)
  134	      for currblock := 1 to last_block do
  135	         with block [currblock] do begin
  136	            write ('          ', currblock:3, '      ');
  137	            for ifstate := 1 to last_int_back do
  138	               if ifstate in dfastate [first_mem^.state] then
  139	                  if ifstate <= last_nfa then
  140	                     with n.symtable [ifstate] do
  141	                        write ('*<', sym, '> ')  (* final state *)
  142	                  else begin
  143	                     with n.symtable [which_nfa [ifstate]] do
  144	                        write (' <', sym, '> '); (* intermediate-backup state *)
  145	                     la_feature := true              (* lookahead feature really is required *)
  146	                  end;
  147	            writeln
  148	         end;
  149	      page
  150	  
  151	   end (* minimize_dfa *);MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 22           print_program declarations and local proc. compact                             PAGE 45

    2	procedure print_program;
    3	  
    4	   type
    5	      com_tab_range = 0..max_com_tab;
    6	      bit_range     = 0..10;
    7	   
    8	   var
    9	      line_width:  0..80;
   10	      width:       0..5;
   11	      currblock:   blockrange;
   12	      tsym:        min_term..-1;
   13	      use_compacted, finalfound, needed_la: boolean;
   14	      ifstate:     1..maxifstates;
   15	      token_la:    packed array [1..maxnonter] of boolean;
   16	      default:     packed array [1..maxblocks] of blockrange;
   17	      base:        array [1..maxblocks] of com_tab_range;
   18	      next,
   19	      check:       array [1..max_com_tab] of blockrange;
   20	      last_next_check,
   21	      temp_base:   com_tab_range;
   22	      per_word, per_word2: 1..word_size;
   23	  
   24	  
   25	   procedure compact;
   26	     
   27	      var
   28	         pagenum:   1..10;
   29	         col, cols: 1..4;
   30	         chosen_base, next_free, line, ub:  com_tab_range;
   31	         currblock, best_state, temp_state:  blockrange;
   32	         curr_row:  array [term_range] of blockrange;
   33	         num_same, best_same, first_in_template:  0..-min_term;
   34	         conflict, found_free:  boolean;
   35	         template:  array [term_range] of boolean;
   36	     
   37	     
   38	      begin (* compact *)
   39	  
   40	         (* put row of delta for first state directly into table *)
   41	  
   42	         default [1] := 0;   (* no default required - all entries will be entered explicitly *)
   43	         base [1] := 0;      (* first state will use positions 1 to -t.symmax in next and check *)MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 22           print_program declarations and local proc. compact                             PAGE 46

   44	         for tsym := -1 downto t.symmax do begin   (* put row into next and check *)
   45	            next [-tsym] := whichblock [delta [block [1].first_mem^.state]^[tsym]];
   46	            check [-tsym] := 1
   47	         end;
   48	         last_next_check := -t.symmax;
   49	     
   50	  
   51	         (* fill in remaining states, taking advantage of similar states already in the table
   52	            whenever possible.  (see Aho & Ullman ch. 3 for explanation of compaction method) *)
   53	  
   54	         for currblock := 2 to last_block do begin
   55	  
   56	            for tsym := -1 downto t.symmax do      (* make copy of current row (for efficiency) *)
   57	               curr_row [tsym] := whichblock [delta [block [currblock].first_mem^.state]^[tsym]];
   58	
   59	            best_same := 0;
   60	            for temp_state := 1 to currblock-1 do begin   (* search for similar state *)
   61	               num_same := 0;
   62	               for tsym := -1 downto t.symmax do
   63	                  if whichblock [delta [block [temp_state].first_mem^.state]^[tsym]]
   64	                        = curr_row [tsym] then
   65	                     num_same := num_same + 1;
   66	               if num_same > best_same then begin      (* a new "best"? *)
   67	                  best_same := num_same;
   68	                  best_state := temp_state    (* new candidate *)
   69	               end
   70	            end;
   71	
   72	            if best_same = 0 then begin   (* don't have a "similar" state? *)
   73	               (* do not have a similar state - enter current state directly into table *)
   74	               default [currblock] := 0;
   75	               base [currblock] := last_next_check;
   76	               if last_next_check - t.symmax <= max_com_tab then
   77	                  last_next_check := last_next_check - t.symmax
   78	               else begin
   79	                  writeln (ttyoutput, 'COMPACTED TABLE OVERFLOW');
   80	                  stop
   81	               end;
   82	               for tsym := -1 downto t.symmax do begin
   83	                  next [base [currblock]-tsym] := curr_row [tsym];
   84	                  check [base [currblock]-tsym] := currblock
   85	               endMODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 22           print_program declarations and local proc. compact                             PAGE 47

   86	            end
   87	
   88	            else begin   (* I have a similar state *)
   89	               default [currblock] := best_state;   (* default to the similar state *)
   90	               first_in_template := 0;
   91	               for tsym := -1 downto t.symmax do   (* construct template of positions where curr.
   92	                                                      state doesn't match the similar one *)
   93	                  if whichblock [delta [block [best_state].first_mem^.state]^[tsym]]
   94	                         <> curr_row [tsym] then begin
   95	                     template [tsym] := true;
   96	                     if first_in_template = 0 then
   97	                        first_in_template := -tsym   (* remember position of first non-match *)
   98	                  end
   99	                  else
  100	                     template [tsym] := false;
  101	               next_free := 0;
  102	               if first_in_template = 0 then   (* state exactly matches similar state? *)
  103	                  chosen_base := 0 (* align with 1st state - default (the similar state)
  104	                                      always taken *)
  105	               else                (* have to find place for non-matching entries *)
  106	                  repeat           (* slide template down table looking for first fit *)
  107	                     found_free := false;
  108	                     repeat        (* find next position that might fit *)
  109	                        next_free := next_free + 1;
  110	                        if next_free > last_next_check then
  111	                           found_free := true   (* anything past current end of table is free *)
  112	                        else if check [next_free] = 0 then
  113	                           found_free := true
  114	                     until found_free;
  115	                     chosen_base := next_free - first_in_template;
  116	                     conflict := false;
  117	                     if first_in_template < -t.symmax then
  118	                        for tsym := -first_in_template-1 downto t.symmax do
  119	                           if template [tsym] then                (* if I need this position ... *)
  120	                              if chosen_base - tsym <= last_next_check then
  121	                                 if check [chosen_base-tsym] > 0 then (* ... but its not free ...*)
  122	                                    conflict := true           (* ... then template doesn't fit *)
  123	                  until not conflict;
  124	               base [currblock] := chosen_base;
  125	               if chosen_base - t.symmax > last_next_check then  (* need to expand table? *)
  126	                  if chosen_base - t.symmax <= max_com_tab then begin
  127	                     for temp_base := last_next_check+1 to chosen_base-t.symmax doMODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 22           print_program declarations and local proc. compact                             PAGE 48

  128	                        begin
  129	                           next [temp_base] := 0;
  130	                           check [temp_base] := 0
  131	                        end;
  132	                     last_next_check := chosen_base - t.symmax
  133	                  end
  134	                  else begin
  135	                     writeln (ttyoutput, 'COMPACTED TABLE OVERFLOW');
  136	                     stop
  137	                  end;
  138	               for tsym := -1 downto t.symmax do
  139	                  if template [tsym] then begin
  140	                     next [chosen_base-tsym] := curr_row [tsym];
  141	                     check [chosen_base-tsym] := currblock
  142	                  end
  143	            end
  144	         end (* for currblock *);
  145	  
  146	  
  147	         (* print the compacted tables *)
  148	  
  149	         writeln ('****** COMPACTED VERSION OF MINIMIZED DFA NEXT STATE TABLE ******');
  150	         writeln;
  151	  
  152	         for pagenum := 1 to (last_block+199) div 200 do begin (* fit 4 columns of 50 to a page *)
  153	            if 200 + (pagenum-1)*200 <= last_block then        (* need to fill this page? *)
  154	               ub := 200 + (pagenum-1)*200                     (* last entry on this page *)
  155	            else
  156	               ub := last_block;                               (* only need part of this page *)
  157	            cols := (ub - (pagenum-1)*200 + 49) div 50;
  158	            for col := 1 to cols do
  159	               write ('             DEFAULT  BASE');
  160	            writeln;
  161	            writeln;
  162	            if ub > 50 + (pagenum-1)*200 then
  163	               ub := 50 + (pagenum-1)*200;   (* last entry in left column on this page *)
  164	            for line := 1 + (pagenum-1)*200 to ub do begin
  165	               for col := 1 to cols do
  166	                  if line+(col-1)*50 <= last_block then
  167	                     write (line+(col-1)*50:12, default [line+(col-1)*50]:7,
  168	                                                base [line+(col-1)*50]:7);
  169	                  writelnMODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 22           print_program declarations and local proc. compact                             PAGE 49

  170	            end;
  171	            page
  172	         end;
  173	  
  174	         for pagenum := 1 to (last_next_check+199) div 200 do begin  (* fit 4 col of 50 per page *)
  175	            if 200 + (pagenum-1)*200 <= last_next_check then   (* need to fill this page? *)
  176	               ub := 200      + (pagenum-1)*200   (* last entry on this page *)
  177	            else
  178	               ub := last_next_check;             (* only need part of this page *)
  179	            cols := (ub - (pagenum-1)*200 + 49) div 50;
  180	            for col := 1 to cols do
  181	               write ('              NEXT  CHECK');
  182	            writeln;
  183	            writeln;
  184	            if ub > 50 + (pagenum-1)*200 then
  185	               ub := 50 + (pagenum-1)*200;        (* last entry in left column on this page *)
  186	            for line := 1 + (pagenum-1)*200 to ub do begin
  187	               for col := 1 to cols do
  188	                  if line + (col-1)*50 <= last_next_check then
  189	                     write (line+(col-1)*50:12, next [line+(col-1)*50]:6,
  190	                                                check [line+(col-1)*50]:7);
  191	                  writeln
  192	            end;
  193	            page
  194	         end
  195	  
  196	      end (* compact *);MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 23           print_program local procedures                                                 PAGE 50

    2	   function bits (maxval: com_tab_range): bit_range;
    3	  
    4	      var
    5	         temp_val: com_tab_range;
    6	  
    7	      begin
    8	         bits := 0;
    9	         temp_val := maxval;
   10	         repeat
   11	            bits := bits + 1;
   12	            temp_val := temp_val div 2
   13	         until temp_val = 0
   14	      end;
   15	  
   16	  
   17	   procedure print (val: com_tab_range);
   18	  
   19	      var
   20	         temp_val: com_tab_range;
   21	  
   22	      begin
   23	         temp_val := val;
   24	         width := 0;
   25	         repeat                                  (* calculate required field width *)
   26	            temp_val := temp_val div 10;
   27	            width := width + 1
   28	         until temp_val = 0;
   29	         if (line_width + width + 1) > 75 then begin   (* need new line? *)
   30	            line_width := width + 7;
   31	            writeln;
   32	            write ('      ')
   33	         end;
   34	         line_width := line_width + width + 1;
   35	         write (val:width)
   36	      end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 24           print_program body                                                             PAGE 51

    2	   begin (* print_program *)
    3	  
    4	      (* compact the minimized version of delta *)
    5	  
    6	      compact;
    7	  
    8	      (* let user choose between compacted and uncompacted froms *)
    9	  
   10	      per_word := word_size div bits (last_block);
   11	      per_word2 := word_size div bits (last_next_check);
   12	      writeln (ttyoutput);
   13	      writeln (ttyoutput, 'THE UNCOMPACTED FORM OF DELTA REQUIRES',
   14	               (-t.symmax*last_block + per_word - 1) div per_word:6, ' WORDS FOR STORAGE');
   15	      writeln (ttyoutput, 'THE COMPACTED FORM REQUIRES',
   16	            (last_block + per_word - 1) div per_word                        (* for default      *)
   17	          + (last_block + per_word2 - 1) div per_word2                      (*  "  base         *)
   18	          + 2*((last_next_check + per_word - 1) div per_word):17, ' WORDS'); (*  "  next & check *)
   19	      writeln (ttyoutput);
   20	      repeat
   21	         write (ttyoutput, 'DO YOU WANT THE COMPACTED FORM? ');
   22	         break (ttyoutput);
   23	         readln (tty);
   24	         tty^ := uppercase (tty^);
   25	         use_compacted := (tty^ = 'Y');
   26	         if (tty^ <> 'Y') and (tty^ <> 'N') then
   27	            writeln (ttyoutput, '?"YES" OR "NO", PLEASE.')
   28	      until (tty^ = 'Y') or (tty^ = 'N');
   29	  
   30	  
   31	      (* print scanner program with appropriate constants, tables, and code *)
   32	  
   33	      writeln ('(********************************************)');
   34	      writeln ('(*   SCANNER ALGORITHM CREATED BY LEXGEN    *)');
   35	      if la_feature then
   36	         writeln ('(*    INCORPORATES THE LOOKAHEAD FEATURE    *)');
   37	      writeln ('(********************************************)');
   38	      writeln;
   39	      writeln ('PROGRAM ??????;');
   40	      writeln;
   41	  
   42	      writeln ('CONST');
   43	      if la_feature thenMODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 24           print_program body                                                             PAGE 52

   44	         writeln ('   MAXSTACK    =  ???;  (* MAX INDEX IN STACK FOR LOOKAHEAD *)');
   45	      writeln ('   MAXINDEX    =  ???;  (* MAX INDEX USED TO ACCESS BUFFER *)');
   46	      writeln ('   BUFFERSIZE  =  ???;  (* MAXINDEX + 1 *)');
   47	      writeln ('   MAXTOKEN    = ', last_nfa:4, ';');
   48	      writeln ('   DFASTATE1   = ', whichblock [1]:4, ';  (* CODE FOR INITIAL STATE OF DFA *)');
   49	      writeln ('   MAXDFASTATE = ', last_block:4, ';  (* CODE FOR MAX STATE OF DFA *)');
   50	      writeln ('   MINTERMINAL = ', t.symmax:4, ';  (* MIN TERMINAL CODE *)');
   51	      writeln ('   EODATA      =   -1;  (* CODE FOR END-OF-DATA *)');
   52	      writeln;
   53	      writeln;
   54	  
   55	      writeln ('TYPE');
   56	      writeln ('   STATERANGE  = 1..MAXDFASTATE;');
   57	      writeln ('   EXSTATERANGE= 0..MAXDFASTATE;');
   58	      writeln ('   INDEXRANGE  = 0..MAXINDEX;');
   59	      writeln ('   LEXTOKEN    = RECORD');
   60	      writeln ('                    TOKEN_TYPE: ???;');
   61	      writeln ('                    MORE: ???  (* POINTER TO SYMBOL TABLE, CODE');
   62	      writeln ('                                  TO DIFFERENTIATE DIFFERENT SYMBOLS');
   63	      writeln ('                                  SUCH AS RELATIONAL OPERATORS OF THE');
   64	      writeln ('                                  SAME TOKEN_TYPE, ETC.  *)');
   65	      writeln ('                 END;');
   66	      writeln;
   67	      writeln ('VAR');
   68	  
   69	      if use_compacted then begin
   70	         write ('   DEFAULT: PACKED ARRAY [STATERANGE] OF EXSTATERANGE := (');
   71	         line_width := 75;   (* force first line *)
   72	         for currblock := 1 to last_block do begin
   73	            print (default [currblock]);
   74	            if currblock < last_block then
   75	               write (',')
   76	         end;
   77	         writeln (');');
   78	         writeln;
   79	         write ('   BASE: PACKED ARRAY [STATERANGE] OF 0..', last_next_check:4, ' := (');
   80	         line_width := 75;   (* force first line *)
   81	         for currblock := 1 to last_block do begin
   82	            print (base [currblock]);
   83	            if currblock < last_block then
   84	               write (',')
   85	         end;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 24           print_program body                                                             PAGE 53

   86	         writeln (');');
   87	         writeln;
   88	         writeln ('   NEXT: PACKED ARRAY [1..', last_next_check:4, '] OF EXSTATERANGE := (');
   89	         line_width := 75;   (* force first line *)
   90	         for temp_base := 1 to last_next_check do begin
   91	            print (next [temp_base]);
   92	            if temp_base < last_next_check then
   93	               write (',')
   94	         end;
   95	         writeln (');');
   96	         writeln;
   97	         write ('   CHECK: PACKED ARRAY [1..', last_next_check:4, '] OF EXSTATERANGE := (');
   98	         line_width := 75;   (* force first line *)
   99	         for temp_base := 1 to last_next_check do begin
  100	            print (check [temp_base]);
  101	            if temp_base < last_next_check then
  102	               write (',')
  103	         end;
  104	         writeln (');');
  105	         writeln;
  106	      end
  107	      else begin
  108	         write ('   DELTA: PACKED ARRAY [STATERANGE, MINTERMINAL..EODATA] OF EXSTATERANGE := (');
  109	         line_width := 75;   (* force first line *)
  110	         for currblock := 1 to last_block do
  111	            for tsym := t.symmax to -1 do begin
  112	               print (whichblock [delta [block [currblock].first_mem^.state]^[tsym]]);
  113	               if (currblock < last_block) or (tsym < -1) then
  114	                  write (',')
  115	            end;
  116	         writeln (');');
  117	         writeln
  118	      end;
  119	  
  120	      writeln ('   (* FINAL [X] = 0 IF STATE X IS NOT A FINAL STATE');
  121	      for ifstate := 1 to last_nfa do
  122	         with n.symtable [ifstate] do
  123	            writeln ('               ', ifstate:3, ' IF STATE X RECOGNIZES <', sym, '>');
  124	      writeln (' ':65, '*)');
  125	      write ('   FINAL: PACKED ARRAY [EXSTATERANGE] OF 0..MAXTOKEN := (');
  126	      line_width := 75;   (* force first line *)
  127	      for currblock := firstblock to last_block do beginMODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 24           print_program body                                                             PAGE 54

  128	         finalfound := false;
  129	         for ifstate := 1 to last_nfa do
  130	            if ifstate in dfastate [block [currblock].first_mem^.state] then begin
  131	               print (ifstate);
  132	               finalfound := true
  133	            end;
  134	         if not finalfound then
  135	            print (0);
  136	         if currblock < last_block then
  137	            write (',')
  138	      end;
  139	      writeln (');');
  140	      writeln;
  141	  
  142	      if la_feature then begin
  143	         writeln ('   (* BACKUP [X] = SET OF ALL BACKUP TOKENS ASSOCIATED WITH STATE X.');
  144	         writeln ('                  SEE "FINAL" COMMENT FOR TOKEN CODES. *)');
  145	         writeln;
  146	         write ('   BACKUP: ARRAY [STATERANGE] OF SET OF 1..MAXTOKEN := (');
  147	         line_width := 75;   (* force first line *)
  148	         for ifstate := 1 to last_nfa do
  149	            token_la [ifstate] := false;  (* assume no tokens require lookahead to be recognized *)
  150	         for currblock := 1 to last_block do begin
  151	            if line_width > 60 then
  152	               begin
  153	                  writeln;
  154	                  write ('      ');
  155	                  line_width := 6
  156	               end;
  157	            write ('[');
  158	            finalfound := false;
  159	            for ifstate := last_nfa+1 to last_int_back do
  160	               if ifstate in dfastate [block [currblock].first_mem^.state] then
  161	                  begin
  162	                     if finalfound then
  163	                        write (',');
  164	                     write (which_nfa [ifstate]:3);
  165	                     finalfound := true;
  166	                     line_width := line_width + 4;
  167	                     token_la [which_nfa [ifstate]] := true  (* this token requires lookahead *)
  168	                  end;
  169	            write (']');MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 24           print_program body                                                             PAGE 55

  170	            if currblock < last_block then
  171	               write (',');
  172	            line_width := line_width + 2
  173	         end;
  174	         writeln (');');
  175	         writeln;
  176	
  177	         writeln ('   (* LOOKAHEADFINAL [X] = TRUE IFF LOOKAHEAD WAS REQUIRED TO RECOGNIZE');
  178	         writeln ('          TOKEN ASSOCIATED WITH STATE X.  "FINAL" INDICATES WHICH TOKEN');
  179	         writeln ('          THAT IS,  AND "BACKUP" IS USED TO FIGURE OUT WHERE TO BACKUP TO. *)');
  180	         writeln;
  181	         write ('   LOOKAHEADFINAL: PACKED ARRAY [EXSTATERANGE] OF BOOLEAN := (');
  182	         line_width := 75;   (* force first line *)
  183	         for currblock := firstblock to last_block do begin
  184	            needed_la := false;
  185	            for ifstate := 1 to last_nfa do
  186	               if ifstate in dfastate [block [currblock].first_mem^.state] then
  187	                  if token_la [ifstate] then
  188	                     needed_la := true;
  189	            if line_width + 6 > 75 then begin
  190	               writeln;
  191	               write ('      ');
  192	               line_width := 6
  193	            end;
  194	            line_width := line_width + 6;
  195	            write (needed_la:5);
  196	            if currblock < last_block then
  197	               write (',')
  198	         end;
  199	         writeln (');');
  200	         writeln
  201	      end;
  202	  
  203	      writeln ('   BEGIN_INDEX, END_INDEX: INDEXRANGE;');
  204	      writeln ('   LEXEME: LEXTOKEN;');
  205	      writeln ('   BUFFER: ARRAY [INDEXRANGE] OF MINTERMINAL..EODATA;');
  206	      writeln;
  207	      writeln;
  208	  
  209	      writeln ('PROCEDURE SCAN (VAR BEGIN_INDEX, END_INDEX: INDEXRANGE;');
  210	      writeln ('               VAR LEXEME: LEXTOKEN);');
  211	      writeln;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 24           print_program body                                                             PAGE 56

  212	      writeln ('   VAR');
  213	      writeln ('      NEWTOKEN:  BOOLEAN;');
  214	      writeln ('      CURRSTATE, CURRFINAL: EXSTATERANGE;');
  215	      writeln ('      OLDINDEX:  INDEXRANGE;');
  216	      if la_feature then begin
  217	         writeln ('      STACK: ARRAY [0..MAXSTACK] OF');
  218	         writeln ('                RECORD');
  219	         writeln ('                   INDEX: INDEXRANGE;');
  220	         writeln ('                   STATE: STATERANGE');
  221	         writeln ('                END;');
  222	         writeln ('      TOS: 0..MAXSTACK;  (* CURRENT TOP OF STACK INDEX *)');
  223	         writeln;
  224	         writeln;
  225	         writeln ('   PROCEDURE PUSH (ININDEX: INDEXRANGE; INSTATE: STATERANGE);');
  226	         writeln ('      BEGIN');
  227	         writeln ('         TOS := TOS + 1;');
  228	         writeln ('         STACK [TOS].INDEX := ININDEX;');
  229	         writeln ('         STACK [TOS].STATE := INSTATE');
  230	         writeln ('      END (* PUSH *);')
  231	      end;
  232	      writeln;
  233	      writeln;
  234	  
  235	      writeln ('   PROCEDURE GETCHAR (NEWTOKEN: BOOLEAN);');
  236	      writeln ('      BEGIN');
  237	      writeln ('         <  THIS PROCEDURE OBTAINS THE NEXT INPUT CHARACTER (WHICH');
  238	      writeln ('            IS ASSUMED TO BE EODATA IF NO MORE INPUT) AND MODIFIES');
  239	      writeln ('            BEGIN_INDEX AND END_INDEX AS NECESSARY DEPENDING ON');
  240	      writeln ('            THE BUFFERING SCHEME SO THAT');
  241	      writeln ('             (1) IF NEWTOKEN, THEN BEGIN_INDEX POINTS TO THE INPUT');
  242	      writeln ('                 CHARACTER JUST OBTAINED, ELSE BEGIN_INDEX POINTS');
  243	      writeln ('                 TO THE SAME CHARACTER IT POINTED TO BEFORE.');
  244	      writeln ('             (2) END_INDEX IS THE INDEX OF THE NEW CHARACTER JUST');
  245	      writeln ('                 OBTAINED.');
  246	      writeln ('            SCAN ALLOWS FOR EITHER SEQUENTIAL OR CIRCULAR BUFFER  >');
  247	      writeln ('      END (* GETCHAR *);');
  248	      writeln;
  249	      writeln;
  250	  
  251	      writeln ('   BEGIN (* SCAN *)');
  252	      writeln ('      NEWTOKEN  := TRUE;');
  253	      if la_feature thenMODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 24           print_program body                                                             PAGE 57

  254	         writeln ('      TOS := 0;');
  255	      writeln ('      CURRSTATE := DFASTATE1;  (* START IN INITIAL STATE *)');
  256	      writeln ('      CURRFINAL := 0;');
  257	      writeln ('      OLDINDEX  := 0;  (* WIDTH OF LEXEME AS OF LAST FINAL STATE *)');
  258	      writeln;
  259	      writeln ('      WHILE CURRSTATE <> 0 DO');
  260	      writeln ('         BEGIN');
  261	      if la_feature then begin
  262	         writeln ('            IF BACKUP [CURRSTATE] <> [] THEN');
  263	         writeln ('               PUSH ((END_INDEX-BEGIN_INDEX) MOD BUFFERSIZE, CURRSTATE);')
  264	      end;
  265	      writeln ('            IF FINAL [CURRSTATE] <> 0 THEN');
  266	      writeln ('               BEGIN');
  267	      writeln ('                  CURRFINAL := CURRSTATE;');
  268	      writeln ('                  OLDINDEX := (END_INDEX - BEGIN_INDEX) MOD BUFFERSIZE');
  269	      writeln ('               END;');
  270	      writeln ('            GETCHAR (NEWTOKEN);');
  271	      writeln ('            NEWTOKEN := FALSE;');
  272	      if use_compacted then begin
  273	         writeln ('            WHILE CHECK [BASE [CURRSTATE]-BUFFER [END_INDEX]] <> CURRSTATE DO');
  274	         writeln ('               CURRSTATE := DEFAULT [CURRSTATE];');
  275	         writeln ('            CURRSTATE := NEXT [BASE [CURRSTATE]-BUFFER [END_INDEX]]')
  276	      end
  277	      else
  278	         writeln ('            CURRSTATE := DELTA [CURRSTATE, BUFFER [END_INDEX]]');
  279	      writeln ('         END;');
  280	      if la_feature then begin
  281	         writeln ('      IF LOOKAHEADFINAL [CURRFINAL] THEN');
  282	         writeln ('         BEGIN');
  283	         writeln ('            WHILE NOT (FINAL [CURRFINAL] IN BACKUP [STACK [TOS].STATE]) DO');
  284	         writeln ('               TOS := TOS - 1;');
  285	         writeln ('            END_INDEX := (STACK [TOS].INDEX + BEGIN_INDEX) MOD BUFFERSIZE');
  286	         writeln ('         END');
  287	         writeln ('      ELSE');
  288	         write ('   ')
  289	      end;
  290	      writeln ('      END_INDEX := (BEGIN_INDEX + OLDINDEX) MOD BUFFERSIZE;');
  291	      writeln;
  292	      writeln ('       < COMPUTE LEXEME GIVEN FINAL [CURRFINAL], BEGIN_INDEX, END_INDEX, ');
  293	      writeln ('         ETC.                                                          >');
  294	      writeln;
  295	      writeln ('   END (* SCAN *);');MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 24           print_program body                                                             PAGE 58

  296	      writeln;
  297	      writeln;
  298	  
  299	      writeln ('BEGIN (* MAINLINE *)');
  300	      writeln ('          .');
  301	      writeln ('          .');
  302	      writeln ('          .');
  303	      writeln ('   SCAN (BEGIN_INDEX, END_INDEX, LEXEME);');
  304	      writeln ('              (* AS NEEDED UNTIL END-OF-DATA LEXEME IS OBTAINED *)');
  305	      writeln ('          .');
  306	      writeln ('          .');
  307	      writeln ('          .');
  308	      writeln ('END. (* MAINLINE *)');
  309	      writeln;
  310	  
  311	   end (* print_program *);MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 25           mainline                                                                       PAGE 59

    2	begin (* lexgen *)
    3	
    4	   (* initialize parsing tables *)
    5	
    6	   for st := 1 to maxparsest do
    7	      for la := meta_lbrack to terminalhead do
    8	         p [st, la] := lambda;
    9	   p [ 1,  -2] := -503;  p [ 1,   1] :=  -1;   p [ 1,   2] :=   2;
   10	   p [ 2,  -2] := -504;  p [ 2,  -1] :=   3;
   11	   p [ 3,  -5] :=   6;   p [ 3,  -2] :=   5;   p [ 3,   3] :=   4;   p [ 3,   4] :=  -5;
   12	   p [ 4,  -1] :=   7;   p [ 4,   0] :=  -2;
   13	   p [ 5,  -3] :=   8;
   14	   p [ 6,  -3] :=   9;
   15	   p [ 7,  -5] :=   6;   p [ 7,  -2] :=   5;   p [ 7,   4] :=  -6;
   16	   p [ 8, -11] := -18;   p [ 8,  -9] :=  11;   p [ 8,  -8] := -513;  p [ 8,  -7] := -18;
   17	   p [ 8,  -6] := -18;   p [ 8,  -5] := -515;  p [ 8,  -4] := -18;   p [ 8,  -2] := -514;
   18	   p [ 8,  -1] := -18;   p [ 8,   0] := -18;   p [ 8,   5] :=  10;
   19	   p [ 9, -13] := -520;  p [ 9,   6] :=  -9;   p [ 9,   7] :=  12;
   20	   p [10, -11] :=  15;   p [10,  -9] :=  11;   p [10,  -8] := -513;  p [10,  -7] := -511;
   21	   p [10,  -6] := -510;  p [10,  -5] := -515;  p [10,  -4] :=  13;   p [10,  -2] := -514;
   22	   p [10,  -1] :=  -7;   p [10,   0] :=  -7;   p [10,   5] :=  14;
   23	   p [11, -11] := -18;   p [11, -10] := -18;   p [11,  -9] :=  11;   p [11,  -8] := -513;
   24	   p [11,  -7] := -18;   p [11,  -6] := -18;   p [11,  -5] := -515;  p [11,  -2] := -514;
   25	   p [11,   5] :=  16;
   26	   p [12, -12] := -519;  p [12,  -8] := -521;
   27	   p [13, -11] := -18;   p [13,  -9] :=  11;   p [13,  -8] := -513;  p [13,  -7] := -18;
   28	   p [13,  -6] := -18;   p [13,  -5] := -515;  p [13,  -2] := -514;  p [13,  -1] := -18;
   29	   p [13,   0] := -18;   p [13,   5] :=  17;
   30	   p [14, -11] := -12;   p [14, -10] := -12;   p [14,  -9] := -12;   p [14,  -8] := -12;
   31	   p [14,  -7] := -511;  p [14,  -6] := -510;  p [14,  -5] := -12;   p [14,  -4] := -12;
   32	   p [14,  -2] := -12;   p [14,  -1] := -12;   p [14,   0] := -12;   p [14,   5] :=  14;
   33	   p [15, -11] := -18;   p [15, -10] := -18;   p [15,  -9] :=  11;   p [15,  -8] := -513;
   34	   p [15,  -7] := -18;   p [15,  -6] := -18;   p [15,  -5] := -515;  p [15,  -4] := -18;
   35	   p [15,  -2] := -514;  p [15,  -1] := -18;   p [15,   0] := -18;   p [15,   5] :=  18;
   36	   p [16, -11] :=  15;   p [16, -10] := -516;  p [16,  -9] :=  11;   p [16,  -8] := -513;
   37	   p [16,  -7] := -511;  p [16,  -6] := -510;  p [16,  -5] := -515;  p [16,  -2] := -514;
   38	   p [16,   5] :=  14;
   39	   p [17, -11] :=  15;   p [17,  -9] :=  11;   p [17,  -8] := -513;  p [17,  -7] := -511;
   40	   p [17,  -6] := -510;  p [17,  -5] := -515;  p [17,  -2] := -514;  p [17,  -1] :=  -8;
   41	   p [17,   0] :=  -8;   p [17,   5] :=  14;
   42	   p [18, -11] := -17;   p [18, -10] := -17;   p [18,  -9] :=  11;   p [18,  -8] := -513;
   43	   p [18,  -7] := -511;  p [18,  -6] := -510;  p [18,  -5] := -515;  p [18,  -4] := -17;MODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 25           mainline                                                                       PAGE 60

   44	   p [18,  -2] := -514;  p [18,  -1] := -17;   p [18,   0] := -17;   p [18,   5] :=  14;
   45	
   46	   lhs [ -2] := 1; rhslength [ -2] := 3;  (* <complete>   ::=  <tokens> ';' <prodset>            *)
   47	   lhs [ -3] := 2; rhslength [ -3] := 1;  (* <tokens>     ::=  'nonterminal'                     *)
   48	   lhs [ -4] := 2; rhslength [ -4] := 2;  (*                   <tokens> 'nonterminal'            *)
   49	   lhs [ -5] := 3; rhslength [ -5] := 1;  (* <prodset>    ::=  <production>                      *)
   50	   lhs [ -6] := 3; rhslength [ -6] := 3;  (*                   <prodset> ';' <production>        *)
   51	   lhs [ -7] := 4; rhslength [ -7] := 3;  (* <production> ::=  'nonterminal' '::=' <expression>  *)
   52	   lhs [ -8] := 4; rhslength [ -8] := 5;  (*                   'nonterminal' '::='
   53	                                                                   <expression> '/' <expression> *)
   54	   lhs [ -9] := 4; rhslength [ -9] := 3;  (*                   'setname' '::=' <terminalset>     *)
   55	   lhs [-10] := 5; rhslength [-10] := 2;  (* <expression> ::=  <expression> '*'                  *)
   56	   lhs [-11] := 5; rhslength [-11] := 2;  (*                   <expression> '+'                  *)
   57	   lhs [-12] := 5; rhslength [-12] := 2;  (*                   <expression> <expression>         *)
   58	   lhs [-13] := 5; rhslength [-13] := 1;  (*                   'terminal'                        *)
   59	   lhs [-14] := 5; rhslength [-14] := 1;  (*                   'nonterminal'                     *)
   60	   lhs [-15] := 5; rhslength [-15] := 1;  (*                   'setname'                         *)
   61	   lhs [-16] := 5; rhslength [-16] := 3;  (*                   '(' <expression> ')'              *)
   62	   lhs [-17] := 5; rhslength [-17] := 3;  (*                   <expression> '!' <expression>     *)
   63	   lhs [-18] := 5; rhslength [-18] := 0;  (*                   ''                                *)
   64	   lhs [-19] := 6; rhslength [-19] := 2;  (* <terminalset> ::= <terminalhead> ']'                *)
   65	   lhs [-20] := 7; rhslength [-20] := 1;  (* <terminalhead>::= '['                               *)
   66	   lhs [-21] := 7; rhslength [-21] := 2;  (*                   <terminalhead> 'terminal'         *)
   67	
   68	  
   69	  
   70	   parse_regular_expressions;            (* process input and create NFA's *)
   71	
   72	   create_dfa;
   73	   minimize_dfa;
   74	   print_program;
   75	
   76	   writeln;
   77	   writeln (ttyoutput);
   78	  
   79	   case errors of
   80	      ok: begin
   81	         writeln ('NO ERRORS');
   82	         writeln (ttyoutput, 'NO ERRORS')
   83	      end;
   84	  
   85	      warning: beginMODULE  LEXGEN       LEXGEN: lexical analyzer generator                                     26-Apr-83 11:01
SECTION 25           mainline                                                                       PAGE 61

   86	         writeln ('WARNING (S) GIVEN');
   87	         writeln (ttyoutput, 'WARNING (S) GIVEN')
   88	      end;
   89	  
   90	      recover: begin
   91	         writeln ('RECOVERY FROM MAJOR ERROR (S)');
   92	         writeln (ttyoutput, 'RECOVERY FROM MAJOR ERROR (S)')
   93	      end
   94	   end
   95	
   96	end (* lexgen *).

File   level   on page     name

  0	 0	    1	DSK:LEXGEN.PAS[3,136773]



Section   in file   on page     title

     1	      0	         3    constant definitions
     5	      0	         9    copy   in semantics
    17	      0	        34    createnextif  in create_dfa
    19	      0	        37    create_dfa
    16	      0	        33    create_dfa  declarations
    18	      0	        36    duplicate  in create_dfa
    11	      0	        23    find  in parse_regular_expressions
    14	      0	        27    fix  in parse_regular_expressions
    25	      0	        59    mainline
    21	      0	        41    minimize_dfa body
    20	      0	        40    minimize_dfa declarations
    10	      0	        19    next_lexeme  in parse_regular_expressions
    15	      0	        28    parse_regular_expressions
     9	      0	        18    parse_regular_expressions  declarations
    13	      0	        26    printnode  in parse_regular_expressions
     7	      0	        11    print_closure_nfa, print_concat_nfa   in semantics
    24	      0	        51    print_program body
    22	      0	        45    print_program declarations and local proc. compact
    23	      0	        50    print_program local procedures
     6	      0	        10    print_term_nfa, print_termset_nfa, print_union_nfa   in semantics
    12	      0	        25    pushsymbol   in parse_regular_expressions
     8	      0	        12    semantics
     4	      0	         8    semantics declarations
     2	      0	         4    type definitions
     3	      0	         6    variable declarationsPascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 63




Program LEXGEN

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     BLOCK: array			   static var	       3/52	      +006172
	20/23R	      20/24V	    20/25M	  20/26M	20/26V	      20/29V	    20/30M
	20/30V	      20/32V	    20/33V	  20/34M	20/34V	      21/8M	    21/9M
	21/29V	      21/56V	    21/58V	  21/62V	21/76M	      21/76V	    21/118V
	21/135R	      21/138V	    22/45V	  22/57V	22/63V	      22/93V	    24/112V
	24/130V	      24/160V	    24/186V
     BLOCKRANGE				   subrange type       2/28	      
	3/51R	      3/52R	    3/58R	  20/7R		20/20R	      22/11R	    22/16R
	22/19R	      22/31R	    22/32R
     CONCATENATION: subrange		   const	       2/17	      
	5/27V	      8/48V	    8/103V	  14/17V
     CREATE_DFA				   procedure	       16/2	      
	25/72V
     DEAD: INTEGER			   const	       1/13	      
	2/5V	      19/20V	    19/22V	  19/22V	19/23V	      19/61V	    21/18V
	21/21V
     DELTA: array			   static var	       3/46	      +003224
	18/18V	      18/25V	    19/20M	  19/22V	19/59M	      19/61V	    21/58V
	21/66V	      21/118V	    22/45V	  22/57V	22/63V	      22/93V	    24/112V
     DELTA_ROW				   packed array type   2/27	      
	3/47R
     DFASTATE: array			   static var	       3/48	      +003453
	18/15V	      19/23M	    19/35M	  19/38P	19/69V	      19/89M	    19/108V
	19/110M	      19/110V	    19/114M	  19/114V	21/29V	      21/29V	    21/138V
	24/130V	      24/160V	    24/186V
     DFASTATERANGE			   subrange type       2/5	      
	2/27R	      2/30R	    3/45R	  3/46R		3/48R	      3/51R	    3/54R
	16/30R	      18/8R	    20/6R	  20/20R
     ELEMENTRANGE			   subrange type       2/35	      
	3/4R	      4/3R	    9/16R	  12/2R
     EODATA: INTEGER			   const	       1/38	      
	10/29V	      10/29V	    10/39V	  10/39V	10/154V	      11/2V	    11/2V
	12/3V	      12/3V	    15/5V	  15/5V		15/112V	      15/113V
     ERRORS: ERRSTATUS			   static var	       3/39	      +003137
	4/28V	      4/29M	    10/67V	  10/68M	15/68M	      15/111M	    25/79V
     ERRSTATUS				   subrange type       2/6	      
	3/39R	      4/23R	    10/63RPascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 64
Program LEXGEN (continued)


     FINAL_NODE: subrange		   const	       2/13	      
	2/23V	      17/45V	    19/10V
     FIRSTBLOCK: INTEGER		   const	       1/15	      
	2/28V	      21/7V	    21/18V	  21/21V	21/22V	      21/25V	    21/51V
	24/127V	      24/183V
     IFSTATESET				   set type	       2/4	      
	3/49R	      16/14R	    16/24R	  17/2R
     IMPORTANT_NODE: subrange		   const	       2/13	      
	2/20V	      17/14V	    17/44V
     INTER_BACKUP_NODE: subrange	   const	       2/13	      
	2/21V	      17/48V	    19/13V
     KLEENE_CLOSURE: subrange		   const	       2/18	      
	5/32V	      8/81V	    14/25V
     LA: subrange			   static var	       3/8	      +000643
	25/7M	      25/8V
     LAMBDA: INTEGER			   const	       1/8	      
	2/3V	      2/3V	    2/43V	  3/24V		4/18V	      8/124V	    8/198V
	9/27V	      11/26V	    13/6V	  15/58V	17/12V	      17/25V	    17/26V
	19/71V	      25/8V
     LAST_BLOCK: BLOCKRANGE		   static var	       3/58	      +007077
	21/22M	      21/33V	    21/36V	  21/38M	21/38V	      21/39V	    21/53V
	21/70V	      21/73V	    21/86M	  21/86V	21/114V	      21/134V	    22/54V
	22/152V	      22/153V	    22/156V	  22/166V	24/10V	      24/14V	    24/16V
	24/17V	      24/49V	    24/72V	  24/74V	24/81V	      24/83V	    24/110V
	24/113V	      24/127V	    24/136V	  24/150V	24/170V	      24/183V	    24/196V
     LAST_DFA: DFASTATERANGE		   static var	       3/45	      +003223
	19/99M	      19/105V	    21/24V
     LAST_IBF: subrange			   static var	       3/44	      +003222
	17/15V	      17/19M	    17/19V	  17/20V	19/24M	      19/68V	    19/113V
     LAST_INT_BACK: subrange		   static var	       3/40	      +003140
	19/6M	      19/14M	    19/14V	  19/15V	19/16V	      19/24V	    19/68V
	19/113V	      21/137V	    24/159V
     LAST_NFA: subrange			   static var	       3/43	      +003221
	8/16V	      8/18M	    15/52M	  15/133V	15/164V	      19/6V	    19/7V
	19/36V	      19/107V	    21/139V	  24/47V	24/121V	      24/129V	    24/148V
	24/159V	      24/185V
     LA_FEATURE: BOOLEAN		   static var	       3/59	      +007100
	21/133M	      21/145M	    24/35V	  24/43V	24/142V	      24/216V	    24/253V
	24/261V	      24/280V
     LHS: array				   static var	       3/5	      +000572
	15/99V	      25/46M	    25/47M	  25/48M	25/49M	      25/50M	    25/51MPascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 65
Program LEXGEN (continued)


	25/52M	      25/54M	    25/55M	  25/56M	25/57M	      25/58M	    25/59M
	25/60M	      25/61M	    25/62M	  25/63M	25/64M	      25/65M	    25/66M
     MAXBLOCKS: INTEGER			   const	       1/16	      
	2/28V	      2/28V	    21/7V	  22/16V	22/16V	      22/17V	    22/17V
     MAXCOLS: INTEGER			   const	       1/7	      
	21/99V	      21/100V
     MAXDFASTATES: INTEGER		   const	       1/14	      
	1/16V	      2/5V	    2/5V	  19/90V
     MAXIFSTATES: INTEGER		   const	       1/12	      
	2/4V	      2/4V	    2/24V	  2/24V		3/40V	      3/40V	    3/41V
	3/41V	      3/44V	    3/44V	  16/8V		16/8V	      16/21V	    16/21V
	16/31V	      16/31V	    17/15V	  20/16V	20/16V	      22/14V	    22/14V
     MAXNONTER: INTEGER			   const	       1/9	      
	2/41V	      2/41V	    3/29V	  3/29V		3/30V	      3/30V	    3/42V
	3/42V	      3/43V	    3/43V	  9/18V		9/18V	      11/51V	    16/28V
	16/28V	      22/15V	    22/15V
     MAXPARSEST: INTEGER		   const	       1/22	      
	2/35V	      2/35V	    2/39V	  2/39V		3/3V	      3/3V	    3/7V
	3/7V	      9/14V	    9/14V	  25/6V
     MAXSYMLEN: INTEGER			   const	       1/6	      
	3/14V	      3/22V	    3/32V	  10/29V	11/2V	      12/4V	    13/8V
	13/11V	      15/4V
     MAXTERMSETS: INTEGER		   const	       1/10	      
	2/10V	      2/10V	    3/19V	  3/19V		3/20V	      3/20V	    4/10V
	4/10V	      6/12V	    6/12V	  11/37V	16/23V	      16/23V
     MAX_COM_TAB: INTEGER		   const	       1/17	      
	22/5V	      22/5V	    22/19V	  22/19V	22/76V	      22/126V
     MEMBER				   record type	       2/29	      
	3/56R	      20/9R
     META_DEFINE: INTEGER		   const	       1/35	      
     META_END: INTEGER			   const	       1/37	      
	15/113V	      15/115V
     META_LBRACK: INTEGER		   const	       1/25	      
	3/3V	      3/8V	    10/29V	  10/39V	11/2V	      12/3V	    15/5V
	25/7V
     META_LPAREN: INTEGER		   const	       1/29	      
     META_OR: INTEGER			   const	       1/27	      
     META_PLUS: INTEGER			   const	       1/31	      
     META_RBRACK: INTEGER		   const	       1/26	      
     META_RPAREN: INTEGER		   const	       1/28	      
     META_SLASH: INTEGER		   const	       1/34	      Pascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 66
Program LEXGEN (continued)


     META_STAR: INTEGER			   const	       1/32	      
     MINIMIZE_DFA			   procedure	       20/2	      
	25/73V
     MINPARCODE: INTEGER		   const	       1/23	      
	2/35V
     MIN_TERM: INTEGER			   const	       1/11	      
	2/3V	      2/10V	    2/27V	  2/41V		2/43V	      2/43V	    3/24V
	3/24V	      11/24V	    16/13V	  16/15V	16/23V	      16/27V	    20/15V
	22/12V	      22/33V	    22/33V
     N: record				   static var	       3/28	      +002366
	8/16V	      8/18V	    8/25R	  8/26V		8/27V	      8/28M	    8/29M
	8/30M	      8/34V	    8/40R	  8/41V		8/42V	      8/46M	    8/47P
	8/48V	      8/49V	    8/50V	  8/50V		8/53M	      8/57V	    8/116R
	8/118V	      8/119V	    8/127V	  8/127V	8/131V	      11/50R	    11/51V
	11/54M	      11/54V	    11/55V	  11/57V	11/58M	      11/58V	    11/59M
	11/59V	      11/60M	    11/60V	  11/61M	11/61V	      15/43M	    15/44R
	15/45M	      15/46P	    15/47P	  15/48V	15/48V	      15/49V	    15/50M
	15/134R	      15/135V	    15/139V	  15/142P	15/142P	      15/144V	    15/147V
	15/165V	      19/8R	    19/9V	  19/10V	19/11V	      19/12V	    19/13V
	19/15V	      19/37V	    21/140R	  21/141V	21/143R	      21/144V	    24/122R
	24/123V
     NFA_NODE				   record type	       2/8	      
	2/16R	      2/19R	    2/42R	  3/35R		4/8R	      4/14R	    5/2R
	5/3R	      9/23R	    13/2R	  14/2R		16/7R	      16/36R	    17/2R
     NFA_VARIANT: subrange		   const	       2/40	      
	2/42V	      8/117V	    8/140V	  8/176V	8/192V
     NONTERMINAL: INTEGER		   const	       1/36	      
	11/10V	      11/49V	    12/21V
     NORMAL_NODE: subrange		   const	       2/12	      
	2/15V	      14/38V	    14/39V	  17/11V
     OK: ERRSTATUS			   const	       2/6	      
	15/68V	      25/80V
     ORDINARY: subrange			   const	       2/17	      
	4/18V	      5/13V	    9/27V	  14/35V
     P: array				   static var	       3/3	      +000000
	15/77V	      15/99V	    25/8M	  25/9M		25/9M	      25/9M	    25/10M
	25/10M	      25/11M	    25/11M	  25/11M	25/11M	      25/12M	    25/12M
	25/13M	      25/14M	    25/15M	  25/15M	25/15M	      25/16M	    25/16M
	25/16M	      25/16M	    25/17M	  25/17M	25/17M	      25/17M	    25/18M
	25/18M	      25/18M	    25/19M	  25/19M	25/19M	      25/20M	    25/20M
	25/20M	      25/20M	    25/21M	  25/21M	25/21M	      25/21M	    25/22MPascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 67
Program LEXGEN (continued)


	25/22M	      25/22M	    25/23M	  25/23M	25/23M	      25/23M	    25/24M
	25/24M	      25/24M	    25/24M	  25/25M	25/26M	      25/26M	    25/27M
	25/27M	      25/27M	    25/27M	  25/28M	25/28M	      25/28M	    25/28M
	25/29M	      25/29M	    25/30M	  25/30M	25/30M	      25/30M	    25/31M
	25/31M	      25/31M	    25/31M	  25/32M	25/32M	      25/32M	    25/32M
	25/33M	      25/33M	    25/33M	  25/33M	25/34M	      25/34M	    25/34M
	25/34M	      25/35M	    25/35M	  25/35M	25/35M	      25/36M	    25/36M
	25/36M	      25/36M	    25/37M	  25/37M	25/37M	      25/37M	    25/38M
	25/39M	      25/39M	    25/39M	  25/39M	25/40M	      25/40M	    25/40M
	25/40M	      25/41M	    25/41M	  25/42M	25/42M	      25/42M	    25/42M
	25/43M	      25/43M	    25/43M	  25/43M	25/44M	      25/44M	    25/44M
	25/44M
     PARSE_REGULAR_EXPR			   procedure	       9/2	      
	25/70V
     POSITIVE_CLOSURE: subrange		   const	       2/18	      
	5/32V	      8/83V	    14/31V	  14/25V
     PRINT_PROGRAM			   procedure	       22/2	      
	25/74V
     RECOVER: ERRSTATUS			   const	       2/6	      
	4/33V	      8/119V	    8/197V	  10/105V	10/137V	      10/139V	    10/147V
	15/111V	      25/90V
     RHSLENGTH: array			   static var	       3/6	      +000616
	15/97V	      25/46M	    25/47M	  25/48M	25/49M	      25/50M	    25/51M
	25/52M	      25/54M	    25/55M	  25/56M	25/57M	      25/58M	    25/59M
	25/60M	      25/61M	    25/62M	  25/63M	25/64M	      25/65M	    25/66M
     S: record				   static var	       3/18	      +002055
	6/17V	      8/65R	    8/66V	  8/67V		8/68M	      8/69M	    8/196V
	8/197V	      11/36R	    11/37V	  11/40M	11/40V	      11/41V	    11/43V
	11/44M	      11/44V	    11/45M	  11/45V	13/7R	      13/8V	    13/8V
	15/64M	      17/26V	    19/78V
     SEMANTICS				   procedure	       4/2	      
	12/26V
     SETNAME: INTEGER			   const	       1/33	      
	11/9V	      11/35V	    12/22V
     SET_VARIANT: subrange		   const	       2/40	      
	2/43V	      8/211V
     SKELETAL_NODE: subrange		   const	       2/12	      
	2/14V	      4/17V	    4/18V	  9/26V		9/27V
     ST: subrange			   static var	       3/7	      +000642
	25/6M	      25/8V
     STACKRANGE				   subrange type       2/34	      Pascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 68
Program LEXGEN (continued)


	2/37R	      4/4R	    9/15R	  12/8R
     STACKTYPE				   pointer type	       2/37	      
	4/2R	      9/13R	    12/7R
     SYMBOL_VARIANT: subrange		   const	       2/40	      
	2/41V	      11/19V
     T: record				   static var	       3/10	      +000644
	6/7V	      11/23R	    11/24V	  11/27M	11/27V	      11/28V	    11/29V
	11/31V	      11/32M	    11/32V	  13/10R	13/11V	      13/11V	    15/57M
	15/58M	      15/59M	    15/156V	  15/157V	19/21V	      19/60V	    19/77V
	19/86V	      21/54V	    21/97V	  22/44V	22/48V	      22/56V	    22/62V
	22/76V	      22/77V	    22/82V	  22/91V	22/117V	      22/118V	    22/125V
	22/126V	      22/127V	    22/132V	  22/138V	24/14V	      24/50V	    24/111V
     TERMINAL: INTEGER			   const	       1/30	      
	10/138V	      11/8V	    11/22V	  12/20V
     TERMINALHEAD: INTEGER		   const	       1/40	      
	3/3V	      3/3V	    3/5V	  3/5V		3/8V	      3/8V	    25/7V
     TERM_RANGE				   subrange type       2/3	      
	3/11R	      3/12R	    4/9R	  6/2R		9/19R	      20/14R	    22/32R
	22/35R
     UNION: subrange			   const	       2/17	      
	5/19V	      8/154V	    14/6V
     WARNING: ERRSTATUS			   const	       2/6	      
	4/31V	      8/17V	    8/27V	  8/42V		8/67V	      10/80V	    25/85V
     WHICHBLOCK: array			   static var	       3/51	      +005743
	21/21M	      21/35M	    21/66V	  21/67V	21/70M	      21/118V	    21/124V
	22/45V	      22/57V	    22/63V	  22/93V	24/48V	      24/112V
     WHICH_NFA: packed array		   static var	       3/41	      +003141
	19/16M	      21/143V	    24/164V	  24/167V
     WORD_SIZE: INTEGER			   const	       1/18	      
	22/22V	      22/22V	    24/10V	  24/11V


Procedure SEMANTICS

  Enclosing blocks:
     LEXGEN				   program	       		      Level=1

  Called from:
     PUSHSYMBOL

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINEDPascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 69
Procedure SEMANTICS (continued)


     ACTION: ELEMENTRANGE		   value parameter     4/3	      +000057
	7/20V	      8/4V	    8/80V
     COPY				   procedure	       5/2	      
	5/21V	      5/22V	    5/28V	  5/29V		5/34V	      8/127V
     ERROUT				   procedure	       4/23	      
	8/17V	      8/27V	    8/42V	  8/67V		8/119V	      8/197V
     NEWNODE				   procedure	       4/14	      
	5/8V	      5/14V	    5/20V	  5/33V		8/47V	      8/76V	    8/77V
	8/102V	      8/120V	    8/121V	  8/153V	8/157V	      8/177V	    8/178V
	8/193V	      8/194V
     PRINT_CLOSURE_NFA			   procedure	       7/2	      
	8/93V
     PRINT_CONCAT_NFA			   procedure	       7/30	      
	8/111V
     PRINT_NFA: BOOLEAN			   var parameter       4/5	      +000061
	8/31V	      8/54V	    8/92V	  8/110V	8/123V	      8/128V	    8/143V
	8/166V	      8/182V	    8/203V
     PRINT_TERMSET_NFA			   procedure	       6/12	      
	8/204V
     PRINT_TERM_NFA			   procedure	       6/2	      
	8/124V	      8/183V
     PRINT_UNION_NFA			   procedure	       6/22	      
	8/167V
     STACK: STACKTYPE			   var parameter       4/2	      +000056
	8/25V	      8/28V	    8/29V	  8/40V		8/46V	      8/49V	    8/51V
	8/51V	      8/53V	    8/65V	  8/68V		8/84V	      8/86V	    8/89V
	8/90V	      8/91V	    8/104V	  8/105V	8/107V	      8/107V	    8/108V
	8/109V	      8/109V	    8/116V	  8/117V	8/120V	      8/121V	    8/122V
	8/122V	      8/127V	    8/127V	  8/140V	8/141V	      8/141V	    8/142V
	8/142V	      8/155V	    8/156V	  8/158V	8/159V	      8/161V	    8/161V
	8/164V	      8/165V	    8/175V	  8/176V	8/177V	      8/178V	    8/179V
	8/181V	      8/191V	    8/192V	  8/193V	8/194V	      8/195V	    8/197V
	8/202V	      8/211V	    8/212V	  8/219V	8/219V	      8/219V
     TEMP_FINAL: pointer		   var		       4/8	      +000063
	8/77P	      8/86V	    8/88V	  8/89V		8/91V	      8/157P	    8/158V
	8/159V	      8/165V
     TEMP_INITIAL: pointer		   var		       4/8	      +000062
	8/76P	      8/78V	    8/90V	  8/102P	8/103V	      8/104V	    8/105V
	8/108V	      8/153P	    8/154V	  8/155V	8/156V	      8/164V
     TOS: STACKRANGE			   value parameter     4/4	      +000060
	6/8V	      6/18V	    6/30V	  6/35V		6/40V	      7/13V	    7/18VPascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 70
Procedure SEMANTICS (continued)


	7/38V	      7/38V	    7/38V	  8/25V		8/28V	      8/29V	    8/34V
	8/40V	      8/46V	    8/49V	  8/51V		8/51V	      8/53V	    8/57V
	8/57V	      8/65V	    8/68V	  8/84V		8/86V	      8/89V	    8/90V
	8/91V	      8/104V	    8/105V	  8/107V	8/107V	      8/108V	    8/109V
	8/109V	      8/116V	    8/117V	  8/120V	8/121V	      8/122V	    8/122V
	8/127V	      8/127V	    8/131V	  8/140V	8/141V	      8/141V	    8/142V
	8/142V	      8/146V	    8/146V	  8/155V	8/156V	      8/158V	    8/159V
	8/161V	      8/161V	    8/164V	  8/165V	8/175V	      8/176V	    8/177V
	8/178V	      8/179V	    8/181V	  8/191V	8/192V	      8/193V	    8/194V
	8/195V	      8/197V	    8/202V	  8/211V	8/212V	      8/219V	    8/219V
	8/219V
     TSETSYM: subrange			   var		       4/10	      +000065
	8/191M	      8/196V	    8/201V
     TSYM: TERM_RANGE			   var		       4/9	      +000064
	8/175M	      8/180V


Procedure NEWNODE

  Enclosing blocks:
     SEMANTICS				   procedure	       4/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     SEMANTICS		 COPY

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     N: pointer				   var parameter       4/14	      +000004
	4/17M	      4/18V


Procedure ERROUT

  Enclosing blocks:
     SEMANTICS				   procedure	       4/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     SEMANTICS

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINEDPascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 71
Procedure ERROUT (continued)


     MSG: fixed string			   value parameter     4/24	      +000070
	4/32V	      4/34V
     MTYPE: ERRSTATUS			   value parameter     4/23	      +000066
	4/28V	      4/29V	    4/30V


Procedure COPY

  Enclosing blocks:
     SEMANTICS				   procedure	       4/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     SEMANTICS		 COPY

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     F: pointer				   var parameter       5/2	      +000005
	5/14P	      5/15V	    5/20P	  5/21V		5/22V	      5/24V	    5/24V
	5/29P	      5/33P	    5/34V	  5/35V		5/36V	      5/36V
     I: pointer				   var parameter       5/2	      +000004
	5/8P	      5/9V	    5/10V	  5/12V		5/15V	      5/16V	    5/21V
	5/22V	      5/28V	    5/28V	  5/29V		5/34V	      5/35V
     TF: pointer			   value parameter     5/3	      +000007
	5/21V	      5/22V	    5/29V	  5/34V
     TI: pointer			   value parameter     5/3	      +000006
	5/9V	      5/10V	    5/21V	  5/22V		5/28V	      5/28V	    5/29V
	5/34V


Procedure PRINT_TERM_NFA

  Enclosing blocks:
     SEMANTICS				   procedure	       4/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     SEMANTICS

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     SYMBOL: TERM_RANGE			   value parameter     6/2	      +000066
	6/7VPascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 72



Procedure PRINT_TERMSET_NFA

  Enclosing blocks:
     SEMANTICS				   procedure	       4/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     SEMANTICS

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     SYMBOL: subrange			   value parameter     6/12	      +000066
	6/17V


Procedure PRINT_UNION_NFA

  Enclosing blocks:
     SEMANTICS				   procedure	       4/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     SEMANTICS


Procedure PRINT_CLOSURE_NFA

  Enclosing blocks:
     SEMANTICS				   procedure	       4/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     SEMANTICS


Procedure PRINT_CONCAT_NFA

  Enclosing blocks:
     SEMANTICS				   procedure	       4/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:Pascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 73
Procedure PRINT_CONCAT_NFA (continued)


     SEMANTICS


Procedure PARSE_REGULAR_EXPR

  Enclosing blocks:
     LEXGEN				   program	       		      Level=1

  Called from:
     LEXGEN

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     ACCEPT: INTEGER			   const	       9/5	      
	15/89V	      15/101V	    15/126V
     ACTION: ELEMENTRANGE		   var		       9/16	      +000007
	15/77M	      15/81V	    15/83V	  15/89V	15/90V	      15/93M	    15/93V
	15/97V	      15/98V	    15/99M	  15/99V	15/101V	      15/103V	    15/104V
	15/109V	      15/117M	    15/126V	  15/126V
     BUFFER: INPUT_TEXT_STRING		   var		       10/14	      +000014
	10/19M	      10/20V	    10/26V	  10/46V	10/49V	      10/50V	    10/51V
	10/52M	      10/55V	    10/58V	  10/59V	10/59V	      10/77V	    10/90V
	10/93V	      10/96V	    10/100V	  10/104V	10/105V	      10/106V	    10/108V
	10/111V	      10/118V	    10/120V	  10/125V	10/144V	      10/146V	    10/146V
	10/148V	      10/150V
     BUFFER_ALLOCATION_: INTEGER	   const	       10/8	      
	10/19V	      10/36V	    10/49V
     BUFFER_POS: subrange		   var		       10/15	      +000015
	10/21M	      10/60M	    10/77V	  10/90V	10/95M	      10/95V	    10/96V
	10/100V	      10/104V	    10/105V	  10/106V	10/108V	      10/111V	    10/115M
	10/115V	      10/118V	    10/120V	  10/125V	10/131M	      10/131V	    10/144V
	10/146V	      10/146V	    10/148V	  10/149M	10/149V	      10/150V	    10/151M
	10/151V
     CURRENTSTATE: subrange		   var		       9/14	      +000005
	15/72M	      15/76V	    15/77V	  15/83M	15/104M	      15/123M
     CURR_NFA: subrange			   var		       9/18	      +000012
	15/133M	      15/134V	    15/164M	  15/165V	15/165V
     EOD_TERM: INTEGER			   const	       9/9	      
	15/49V	      15/57V	    15/59V
     ERRORSTATE: INTEGER		   const	       9/6	      
	15/81V	      15/109V	    15/126V
     FIND				   procedure	       11/2	      Pascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 74
Procedure PARSE_REGULAR_EXPR (continued)


	12/23V
     FIX				   procedure	       14/2	      
	14/7V	      14/10V	    14/18V	  14/19V	14/26V	      15/142V
     FNAME: FILE_NAME			   var		       15/3	      +000016
	15/18M	      15/19V	    15/28M	  15/29V
     INIT_NEXT_LEXEME			   procedure	       10/17	      
	15/69V
     INPUT_TEXT_STRING			   pointer type	       10/11	      
	10/14R	      10/35R
     LR0REDUCE: INTEGER			   const	       9/7	      
	15/90V	      15/93V
     NEWNODE				   procedure	       9/23	      
	15/46V	      15/47V
     NEWSYM: varying string		   var		       15/4	      +000037
	15/73P	      15/82V	    15/84P	  15/91V	15/92P	      15/100V	    15/114P
	15/116P
     NEWSYM_TYPE: subrange		   var		       15/5	      +000045
	15/73P	      15/77V	    15/82V	  15/84P	15/91V	      15/92P	    15/100V
	15/112V	      15/113V	    15/113V	  15/114P	15/115V	      15/116P
     NEXT_LEXEME			   procedure	       10/29	      
	15/73V	      15/84V	    15/92V	  15/114V	15/116V
     OLDACTION: ELEMENTRANGE		   var		       9/16	      +000010
	15/98M	      15/100V
     PRINTNODE				   procedure	       13/2	      
	14/9V	      14/13V	    14/21V	  14/29V	14/42V	      15/144V
     PRINT_NFA: BOOLEAN			   var		       9/17	      +000011
	12/26P	      14/8V	    14/12V	  14/20V	14/28V	      14/41V	    15/36M
	15/136V	      15/143V
     PUSHSYMBOL				   procedure	       12/2	      
	15/82V	      15/91V	    15/100V
     SHIFT: INTEGER			   const	       9/8	      
	12/19V	      15/82V	    15/91V
     STACK: STACKTYPE			   var		       9/13	      +000004
	11/19V	      11/26V	    11/28V	  11/29V	11/30V	      11/30V	    11/31V
	11/39V	      11/41V	    11/42V	  11/42V	11/43V	      11/53V	    11/55V
	11/56V	      11/56V	    11/57V	  12/12V	12/13V	      12/14V	    12/14V
	12/15V	      12/16V	    12/17M	  12/26P	15/70M	      15/71V	    15/76V
	15/99V	      15/121V
     STACK_ALLOCATION_I: INTEGER	   const	       9/10	      
	12/13V	      15/70V
     TERM_NEXT_LEXEME			   procedure	       10/24	      Pascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 75
Procedure PARSE_REGULAR_EXPR (continued)


	15/127V
     TOS: STACKRANGE			   var		       9/15	      +000006
	11/19V	      11/26V	    11/28V	  11/29V	11/30V	      11/30V	    11/31V
	11/39V	      11/41V	    11/42V	  11/42V	11/43V	      11/53V	    11/55V
	11/56V	      11/56V	    11/57V	  12/11M	12/11V	      12/12V	    12/26V
	15/71M	      15/76V	    15/97M	  15/97V	15/99V	      15/122M
     TSYM: TERM_RANGE			   var		       9/19	      +000013
	15/156M	      15/157V	    15/157V


Procedure NEWNODE

  Enclosing blocks:
     PARSE_REGULAR_EXPR			   procedure	       9/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     PARSE_REGULAR_EXPR

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     N: pointer				   var parameter       9/23	      +000050
	9/26M	      9/27V


Procedure INIT_NEXT_LEXEME

  Enclosing blocks:
     PARSE_REGULAR_EXPR			   procedure	       9/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     PARSE_REGULAR_EXPR


Procedure TERM_NEXT_LEXEME

  Enclosing blocks:
     PARSE_REGULAR_EXPR			   procedure	       9/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:Pascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 76
Procedure TERM_NEXT_LEXEME (continued)


     PARSE_REGULAR_EXPR


Procedure NEXT_LEXEME

  Enclosing blocks:
     PARSE_REGULAR_EXPR			   procedure	       9/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     PARSE_REGULAR_EXPR

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     CHAR_TO_LEXEME_TAB: array		   const	       10/39	      
	10/98R	      10/100V	    10/102R	  10/104V
     DONE: subrange			   const	       10/34	      
	10/130V	      10/134V
     END_CHAR: CHAR			   var		       10/33	      +000054
	10/109M	      10/111M	    10/118V	  10/125V
     END_OF_LINE: subrange		   const	       10/34	      
	10/121V	      10/134V	    10/136V
     ERROUT				   procedure	       10/63	      
	10/80V	      10/105V	    10/137V	  10/139V	10/147V
     GOT_END_CHAR: subrange		   const	       10/34	      
	10/119V	      10/124V
     INIT: subrange			   const	       10/34	      
	10/113V	      10/117V	    10/127V
     INSERTCH				   procedure	       10/73	      
	10/123V	      10/126V
     LEXEME_FOUND: BOOLEAN		   var		       10/32	      +000053
	10/88M	      10/141M	    10/145M	  10/155M	10/156V
     NEWSYM: varying string		   var parameter       10/29	      +000051
	10/76V	      10/76R	    10/77M	  10/77V	10/107M	      10/138V
     NEWSYM_TYPE: subrange		   var parameter       10/29	      +000050
	10/98M	      10/100V	    10/101M	  10/101V	10/102V	      10/104V	    10/138V
	10/154V
     NEXT_LINE				   procedure	       10/43	      
	10/92V
     NEXT_LINE_SEG: varying string	   var		       10/36	      +000057
	10/48M	      10/50V
     SCAN_STATE: subrange		   var		       10/34	      +000055Pascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 77
Procedure NEXT_LEXEME (continued)


	10/113M	      10/116V	    10/119M	  10/121M	10/127M	      10/130M	    10/134V
	10/134V	      10/136V
     TEMP_BUFFER: INPUT_TEXT_STRING	   var		       10/35	      +000056
	10/49M	      10/50V	    10/52V
     TRUNCATED: BOOLEAN			   var		       10/32	      +000052
	10/79V	      10/81M	    10/112M


Procedure NEXT_LINE

  Enclosing blocks:
     NEXT_LEXEME			   procedure	       10/29	      Level=3
     PARSE_REGULAR_EXPR			   procedure	       9/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     NEXT_LEXEME


Procedure ERROUT

  Enclosing blocks:
     NEXT_LEXEME			   procedure	       10/29	      Level=3
     PARSE_REGULAR_EXPR			   procedure	       9/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     NEXT_LEXEME	 INSERTCH

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     MSG: fixed string			   value parameter     10/63	      +000106
	10/69V
     MTYPE: ERRSTATUS			   value parameter     10/63	      +000104
	10/67V	      10/68V


Procedure INSERTCH

  Enclosing blocks:
     NEXT_LEXEME			   procedure	       10/29	      Level=3
     PARSE_REGULAR_EXPR			   procedure	       9/2	      Level=2Pascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 78
Procedure INSERTCH (continued)


     LEXGEN				   program	       		      Level=1

  Called from:
     NEXT_LEXEME


Procedure FIND

  Enclosing blocks:
     PARSE_REGULAR_EXPR			   procedure	       9/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     PUSHSYMBOL

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     NEWSYM: varying string		   value parameter     11/2	      +000057
	11/27V	      11/28V	    11/29V	  11/40V	11/41V	      11/54V	    11/55V
     NEWSYM_TYPE: subrange		   value parameter     11/2	      +000056
	11/7V	      11/20V
     TABLEFULL				   procedure	       11/4	      
	11/25V	      11/38V	    11/52V


Procedure TABLEFULL

  Enclosing blocks:
     FIND				   procedure	       11/2	      Level=3
     PARSE_REGULAR_EXPR			   procedure	       9/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     FIND


Procedure PUSHSYMBOL

  Enclosing blocks:
     PARSE_REGULAR_EXPR			   procedure	       9/2	      Level=2
     LEXGEN				   program	       		      Level=1Pascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 79
Procedure PUSHSYMBOL (continued)


  Called from:
     PARSE_REGULAR_EXPR

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     ACTION: ELEMENTRANGE		   value parameter     12/2	      +000050
	12/19V	      12/26V
     NEWSYM: varying string		   value parameter     12/4	      +000052
	12/23V
     NEWSYM_TYPE: subrange		   value parameter     12/3	      +000051
	12/20V	      12/21V	    12/22V	  12/23V
     STACKINDEX: STACKRANGE		   var		       12/8	      +000054
	12/14M	      12/15V	    12/15V
     TEMPSTACK: STACKTYPE		   var		       12/7	      +000053
	12/13M	      12/15V	    12/17V


Procedure PRINTNODE

  Enclosing blocks:
     PARSE_REGULAR_EXPR			   procedure	       9/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     PARSE_REGULAR_EXPR	 FIX

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     I: pointer				   value parameter     13/2	      +000004
	13/5V	      13/6V	    13/7V	  13/10V	13/12V	      13/15V	    13/16V
	13/19V


Procedure FIX

  Enclosing blocks:
     PARSE_REGULAR_EXPR			   procedure	       9/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     PARSE_REGULAR_EXPR	 FIX

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINEDPascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 80
Procedure FIX (continued)


     F: pointer				   var parameter       14/2	      +000005
	14/7V	      14/9V	    14/10V	  14/11V	14/11V	      14/13V	    14/14V
	14/18P	      14/26V	    14/27V	  14/29V	14/30V	      14/39V
     I: pointer				   var parameter       14/2	      +000004
	14/5V	      14/7V	    14/10V	  14/18V	14/19V	      14/19V	    14/21V
	14/22V	      14/26V	    14/27V	  14/31V	14/32V	      14/38V	    14/42V


Procedure CREATE_DFA

  Enclosing blocks:
     LEXGEN				   program	       		      Level=1

  Called from:
     LEXGEN

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     CREATENEXTIF			   procedure	       17/2	      
	17/27V	      17/39V	    17/40V	  17/49V	19/38V	      19/48V
     CURRDFA: DFASTATERANGE		   var		       16/29	      +006740
	18/18V	      18/25V	    19/55M	  19/59V	19/61V	      19/69V	    19/97M
	19/97V	      19/98V	    19/99V	  19/105M	19/108V	      19/110V	    19/110V
	19/114V	      19/114V
     DUPLICATE: BOOLEAN			   function	       18/2	      
	19/88V
     FINALFOUND: BOOLEAN		   var		       16/32	      +006743
	19/106M	      19/109V	    19/111M
     HEADQUEUE: pointer			   var		       16/33	      +006744
	19/26M	      19/28V	    19/43V
     IFSTATE: subrange			   var		       16/31	      +006742
	19/68M	      19/69V	    19/70V	  19/107M	19/108V	      19/110V	    19/113M
	19/114V
     NEXTDFA: DFASTATERANGE		   var		       16/30	      +006741
	18/13V	      18/19V	    18/25V	  19/56M	19/89V	      19/90V	    19/94M
	19/94V	      19/98V
     NEXTIF: array			   var		       16/21	      +001707
	17/23R	      17/24M	    17/25V	  17/26V	19/46M	      19/48P	    19/70R
	19/71V	      19/72V	    19/73V	  19/73V	19/73V	      19/78V	    19/80V
     NOTNULL: array			   var		       16/15	      +001534
	19/62M	      19/72M	    19/79M	  19/87V
     NSYM: subrange			   var		       16/28	      +006737Pascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 81
Procedure CREATE_DFA (continued)


	19/7M	      19/8V	    19/11V	  19/16V	19/36M	      19/37V
     OLDI: pointer			   var		       16/36	      +006747
	17/37V	      17/38V	    19/37M	  19/38P	19/47M	      19/48P
     QUEUE: pointer			   var		       16/35	      +006746
	19/43M	      19/44V	    19/46V	  19/47V	19/48V	      19/49M	    19/49V
     QUEUENODE				   record type	       16/5	      
	16/35R
     TAILQUEUE: pointer			   var		       16/34	      +006745
	17/29V	      17/30M	    17/30V	  17/31V	17/33V	      17/34V	    19/28M
	19/29V
     TDFASTATE: array			   var		       16/13	      +000004
	18/15V	      19/63M	    19/73M	  19/73V	19/80M	      19/80V	    19/89V
     TSYM: subrange			   var		       16/27	      +006736
	18/15V	      18/18V	    18/25V	  19/21M	19/22V	      19/60M	    19/61V
	19/62V	      19/63V	    19/77M	  19/78V	19/79V	      19/80V	    19/80V
	19/86M	      19/87V	    19/89V


Procedure CREATENEXTIF

  Enclosing blocks:
     CREATE_DFA				   procedure	       16/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     CREATE_DFA		 CREATENEXTIF

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     I: pointer				   var parameter       17/2	      +000004
	17/7V	      17/9V	    17/12V	  17/14V	17/20V	      17/21V	    17/23V
	17/24V	      17/27V	    17/31V	  17/33V	17/37V	      17/38V	    17/39V
	17/40V	      17/46V	    17/49V	  17/50V
     IFF: IFSTATESET			   var parameter       17/2	      +000005
	17/21M	      17/21V	    17/27P	  17/39P	17/40P	      17/46M	    17/46V
	17/49P	      17/50M	    17/50V


Function DUPLICATE

  Enclosing blocks:
     CREATE_DFA				   procedure	       16/2	      Level=2Pascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 82
Function DUPLICATE (continued)


     LEXGEN				   program	       		      Level=1

  Called from:
     CREATE_DFA

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     DUPLICATE: BOOLEAN			   function value      18/2	      +006762
	18/26M
     FOUND_DUPL: BOOLEAN		   var		       18/9	      +006764
	18/14M	      18/16M	    18/17V	  18/24V	18/26V
     ST: DFASTATERANGE			   var		       18/8	      +006763
	18/12M	      18/13V	    18/15V	  18/18V	18/19M	      18/21M	    18/21V


Procedure MINIMIZE_DFA

  Enclosing blocks:
     LEXGEN				   program	       		      Level=1

  Called from:
     LEXGEN

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     CURRBLOCK: BLOCKRANGE		   var		       20/7	      +000006
	21/7M	      21/8V	    21/9V	  21/25M	21/29V	      21/32M	    21/32V
	21/33V	      21/35V	    21/36V	  21/42V	21/51M	      21/53V	    21/56V
	21/58V	      21/62V	    21/76V	  21/76V	21/90M	      21/90V	    21/114M
	21/116V	      21/118V	    21/134M	  21/135V	21/136V
     CURRDFA: DFASTATERANGE		   var		       20/6	      +000005
	21/24M	      21/29V	    21/35V	  21/39V	21/42V
     CURR_MEM: pointer			   var		       20/9	      +000010
	21/63M	      21/65V	    21/66V	  21/70V	21/73V	      21/74V	    21/77M
	21/77V	      21/80V	    21/81M	  21/81V
     FIRST_STATE: DFASTATERANGE		   var		       20/5	      +000004
	21/58M	      21/67V
     IFSTATE: subrange			   var		       20/16	      +000020
	21/137M	      21/138V	    21/139V	  21/140V	21/143V
     INSERT				   procedure	       20/20	      
	21/18V	      21/39V	    21/42V	  21/73V
     LB: subrange			   var		       20/15	      +000016
	21/97M	      21/99V	    21/100V	  21/107V	21/111V	      21/117V	    21/121MPascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 83
Procedure MINIMIZE_DFA (continued)


	21/122V
     MATCH: BOOLEAN			   var		       20/10	      +000011
	21/28M	      21/30M	    21/31V	  21/33V
     NEWBLOCK: BOOLEAN			   var		       20/11	      +000012
	21/57M	      21/72M	    21/85V
     NOCHANGE: BOOLEAN			   var		       20/12	      +000013
	21/50M	      21/71M	    21/92V
     NOMORE_DELETES: BOOLEAN		   var		       20/13	      +000014
	21/61M	      21/75M	    21/83V
     PREV_MEM: pointer			   var		       20/8	      +000007
	21/62M	      21/63V	    21/74V	  21/80M
     TSYM: TERM_RANGE			   var		       20/14	      +000015
	21/54M	      21/56V	    21/58V	  21/66V	21/87M	      21/87V	    21/107M
	21/108V	      21/111M	    21/117M	  21/118V
     UB: subrange			   var		       20/15	      +000017
	21/100M	      21/102M	    21/107V	  21/111V	21/117V	      21/121V


Procedure INSERT

  Enclosing blocks:
     MINIMIZE_DFA			   procedure	       20/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     MINIMIZE_DFA

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     NEWSTATE: DFASTATERANGE		   value parameter     20/20	      +000030
	20/32V
     X: BLOCKRANGE			   value parameter     20/20	      +000031
	20/23V


Procedure PRINT_PROGRAM

  Enclosing blocks:
     LEXGEN				   program	       		      Level=1

  Called from:
     LEXGENPascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 84
Procedure PRINT_PROGRAM (continued)


  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     BASE: array			   var		       22/17	      +000064
	22/43M	      22/75M	    22/83V	  22/84V	22/124M	      22/168V	    24/82V
     BITS: BIT_RANGE			   function	       23/2	      
	24/10V	      24/11V
     BIT_RANGE				   subrange type       22/6	      
	23/2R
     CHECK: array			   var		       22/19	      +001670
	22/46M	      22/84M	    22/112V	  22/121V	22/130M	      22/141M	    22/190V
	24/100V
     COMPACT				   procedure	       22/25	      
	24/6V
     COM_TAB_RANGE			   subrange type       22/5	      
	22/17R	      22/21R	    22/30R	  23/2R		23/5R	      23/17R	    23/20R
     CURRBLOCK: BLOCKRANGE		   var		       22/11	      +000006
	24/72M	      24/73V	    24/74V	  24/81M	24/82V	      24/83V	    24/110M
	24/112V	      24/113V	    24/127M	  24/130V	24/136V	      24/150M	    24/160V
	24/170V	      24/183M	    24/186V	  24/196V
     DEFAULT: packed array		   var		       22/16	      +000016
	22/42M	      22/74M	    22/89M	  22/167V	24/73V
     FINALFOUND: BOOLEAN		   var		       22/13	      +000011
	24/128M	      24/132M	    24/134V	  24/158M	24/162V	      24/165M
     IFSTATE: subrange			   var		       22/14	      +000013
	24/121M	      24/122V	    24/123V	  24/129M	24/130V	      24/131V	    24/148M
	24/149V	      24/159M	    24/160V	  24/164V	24/167V	      24/185M	    24/186V
	24/187V
     LAST_NEXT_CHECK: COM_TAB_RANGE	   var		       22/20	      +003246
	22/48M	      22/75V	    22/76V	  22/77M	22/77V	      22/110V	    22/120V
	22/125V	      22/127V	    22/132M	  22/174V	22/175V	      22/178V	    22/188V
	24/11V	      24/18V	    24/79V	  24/88V	24/90V	      24/92V	    24/97V
	24/99V	      24/101V
     LINE_WIDTH: subrange		   var		       22/9	      +000004
	23/29V	      23/30M	    23/34M	  23/34V	24/71M	      24/80M	    24/89M
	24/98M	      24/109M	    24/126M	  24/147M	24/151V	      24/155M	    24/166M
	24/166V	      24/172M	    24/172V	  24/182M	24/189V	      24/192M	    24/194M
	24/194V
     NEEDED_LA: BOOLEAN			   var		       22/13	      +000012
	24/184M	      24/188M	    24/195V
     NEXT: array			   var		       22/18	      +000312
	22/45M	      22/83M	    22/129M	  22/140M	22/189V	      24/91V
     PER_WORD: subrange			   var		       22/22	      +003250Pascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 85
Procedure PRINT_PROGRAM (continued)


	24/10M	      24/14V	    24/14V	  24/16V	24/16V	      24/18V	    24/18V
     PER_WORD2: subrange		   var		       22/22	      +003251
	24/11M	      24/17V	    24/17V
     PRINT				   procedure	       23/17	      
	24/73V	      24/82V	    24/91V	  24/100V	24/112V	      24/131V	    24/135V
     TEMP_BASE: COM_TAB_RANGE		   var		       22/21	      +003247
	22/127M	      22/129V	    22/130V	  24/90M	24/91V	      24/92V	    24/99M
	24/100V	      24/101V
     TOKEN_LA: packed array		   var		       22/15	      +000014
	24/149M	      24/167M	    24/187V
     TSYM: subrange			   var		       22/12	      +000007
	22/44M	      22/45V	    22/45V	  22/46V	22/56M	      22/57V	    22/57V
	22/62M	      22/63V	    22/64V	  22/82M	22/83V	      22/83V	    22/84V
	22/91M	      22/93V	    22/94V	  22/95V	22/97V	      22/100V	    22/118M
	22/119V	      22/120V	    22/121V	  22/138M	22/139V	      22/140V	    22/140V
	22/141V	      24/111M	    24/112V	  24/113V
     USE_COMPACTED: BOOLEAN		   var		       22/13	      +000010
	24/25M	      24/69V	    24/272V
     WIDTH: subrange			   var		       22/10	      +000005
	23/24M	      23/27M	    23/27V	  23/29V	23/30V	      23/34V	    23/35V


Procedure COMPACT

  Enclosing blocks:
     PRINT_PROGRAM			   procedure	       22/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     PRINT_PROGRAM

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     BEST_SAME: subrange		   var		       22/33	      +003456
	22/59M	      22/66V	    22/67M	  22/72V
     BEST_STATE: BLOCKRANGE		   var		       22/31	      +003277
	22/68M	      22/89V	    22/93V
     CHOSEN_BASE: COM_TAB_RANGE		   var		       22/30	      +003272
	22/103M	      22/115M	    22/120V	  22/121V	22/124V	      22/125V	    22/126V
	22/127V	      22/132V	    22/140V	  22/141V
     COL: subrange			   var		       22/29	      +003270
	22/158M	      22/165M	    22/166V	  22/167V	22/167V	      22/168V	    22/180MPascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 86
Procedure COMPACT (continued)


	22/187M	      22/188V	    22/189V	  22/189V	22/190V
     COLS: subrange			   var		       22/29	      +003271
	22/157M	      22/158V	    22/165V	  22/179M	22/180V	      22/187V
     CONFLICT: BOOLEAN			   var		       22/34	      +003460
	22/116M	      22/122M	    22/123V
     CURRBLOCK: BLOCKRANGE		   var		       22/31	      +003276
	22/54M	      22/57V	    22/60V	  22/74V	22/75V	      22/83V	    22/84V
	22/84V	      22/89V	    22/124V	  22/141V
     CURR_ROW: array			   var		       22/32	      +003301
	22/57M	      22/64V	    22/83V	  22/94V	22/140V
     FIRST_IN_TEMPLATE: subrange	   var		       22/33	      +003457
	22/90M	      22/96V	    22/97M	  22/102V	22/115V	      22/117V	    22/118V
     FOUND_FREE: BOOLEAN		   var		       22/34	      +003461
	22/107M	      22/111M	    22/113M	  22/114V
     LINE: COM_TAB_RANGE		   var		       22/30	      +003274
	22/164M	      22/166V	    22/167V	  22/167V	22/168V	      22/186M	    22/188V
	22/189V	      22/189V	    22/190V
     NEXT_FREE: COM_TAB_RANGE		   var		       22/30	      +003273
	22/101M	      22/109M	    22/109V	  22/110V	22/112V	      22/115V
     NUM_SAME: subrange			   var		       22/33	      +003455
	22/61M	      22/65M	    22/65V	  22/66V	22/67V
     PAGENUM: subrange			   var		       22/28	      +003267
	22/152M	      22/153V	    22/154V	  22/157V	22/162V	      22/163V	    22/164V
	22/174M	      22/175V	    22/176V	  22/179V	22/184V	      22/185V	    22/186V
     TEMPLATE: array			   var		       22/35	      +003462
	22/95M	      22/100M	    22/119V	  22/139V
     TEMP_STATE: BLOCKRANGE		   var		       22/31	      +003300
	22/60M	      22/63V	    22/68V
     UB: COM_TAB_RANGE			   var		       22/30	      +003275
	22/154M	      22/156M	    22/157V	  22/162V	22/163M	      22/164V	    22/176M
	22/178M	      22/179V	    22/184V	  22/185M	22/186V


Function BITS

  Enclosing blocks:
     PRINT_PROGRAM			   procedure	       22/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     PRINT_PROGRAMPascal, Version 1B Symbol Table Dump   26-Apr-83 11:01 Module: LEXGEN Page 87
Function BITS (continued)


  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     BITS: BIT_RANGE			   function value      23/2	      +003267
	23/8M	      23/11M	    23/11V
     MAXVAL: COM_TAB_RANGE		   value parameter     23/2	      +003270
	23/9V
     TEMP_VAL: COM_TAB_RANGE		   var		       23/5	      +003271
	23/9M	      23/12M	    23/12V	  23/13V


Procedure PRINT

  Enclosing blocks:
     PRINT_PROGRAM			   procedure	       22/2	      Level=2
     LEXGEN				   program	       		      Level=1

  Called from:
     PRINT_PROGRAM

  NAME [:TYPE]				   CLASS/KIND	       DECLARED	      DEFINED
     TEMP_VAL: COM_TAB_RANGE		   var		       23/20	      +003270
	23/23M	      23/26M	    23/26V	  23/28V
     VAL: COM_TAB_RANGE			   value parameter     23/17	      +003267
	23/23V	      23/35V
    n 