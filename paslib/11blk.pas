

PROCEDURE BLOCK(FSYS: SETOFSYS; FSY: SYMBOL; FPROCP: CTP);

VAR
    LSY: SYMBOL;
    FLABP: LBP;
    TESTPACKED: BOOLEAN; (*TEST FOR PACKED STRUCTURES*)
    HEAPM: INTP;
    OLDCIX: INTEGER ;
    OLDPSECT: ALFA ;
    OLDGLOBALINDEX: GBLDFRANGE ;
    STCLASS: SYMBOL;


  PROCEDURE SKIP(FSYS: SETOFSYS);
  (*SKIP INPUT STRING UNTIL RELEVANT SYMBOL FOUND*)


  BEGIN
    WHILE NOT (SY IN FSYS) DO
      INSYMBOL
  END (*SKIP*);


  PROCEDURE CONSTANT(FSYS: SETOFSYS; VAR FSP: STP; VAR FVALU: VALU);

  VAR
      LSP,LSP1: STP;
      LCP: CTP;
      LVP: CSP;
      SIGN: (NONE,POS,NEG);
      STEST: REAL;

  BEGIN
    LSP := NIL;
    FVALU.IVAL := 0;
    IF NOT (SY IN CONSTBEGSYS) THEN BEGIN
      ERROR(50);
      SKIP(FSYS OR CONSTBEGSYS)
    END;
    IF SY IN CONSTBEGSYS THEN BEGIN
      IF SY = STRINGCONSTSY THEN BEGIN
	IF LGTH = 1 THEN
	  LSP := CHARPTR
	ELSE BEGIN
	  NEW(LSP,ARRAYS);
	  NEW(LSP1,SUBRANGE);
	  WITH LSP^ DO BEGIN
	    AELTYPE := CHARPTR;
	    INXTYPE := LSP1;
	    PACKOPT := FALSE;
	    ADDRCORR := 0;
	    SIZE := 2 * ((LGTH + 1) DIV 2);
	  END ;
	  WITH LSP1^ DO BEGIN
	    SIZE := 2;
	    RANGETYPE := INTPTR;
	    MIN.IVAL := 0;
	    MAX.IVAL := LGTH-1;
	  END
	END;
	FVALU := VAL;
	INSYMBOL
      END
      ELSE BEGIN
	SIGN := NONE;
	IF (SY = ADDOP) AND (OP IN [PLUS,MINUS]) THEN BEGIN
	  IF OP = PLUS THEN
	    SIGN := POS
	  ELSE
	    SIGN := NEG;
	  INSYMBOL
	END;
	IF SY = IDENT THEN BEGIN
	  SEARCHID([KONST],LCP);
	  WITH LCP^ DO BEGIN
	    LSP := IDTYPE;
	    FVALU := VALUES
	  END;
	  IF SIGN <> NONE THEN
	    IF LSP = INTPTR THEN BEGIN
	      IF SIGN = NEG THEN
		FVALU.IVAL := -FVALU.IVAL
	    END
	    ELSE IF LSP = REALPTR THEN BEGIN
	      IF SIGN = NEG THEN BEGIN
		NEW (LVP,REEL);
		WITH LVP^ DO BEGIN
		  RVAL := -FVALU.VALP^.RVAL;
		  HEAD := FVALU.VALP^.HEAD;
		  STEST := HEAD;
		  IF (STEST>=32768.0 (*CROSS COMPILOR*)) OR
		    (STEST<0 (*PDP-11 COMPILOR*)) THEN
		      HEAD := HEAD - 100000B
		    ELSE
		      HEAD := HEAD + 100000B
		END;
	      END
	    END
	    ELSE
	      ERROR(105);
	  INSYMBOL;
	END
	ELSE IF SY = INTCONST THEN BEGIN
	  IF SIGN = NEG THEN
	    VAL.IVAL := -VAL.IVAL;
	  LSP := INTPTR;
	  FVALU := VAL;
	  INSYMBOL
	END
	ELSE IF SY = REALCONST THEN BEGIN
	  IF SIGN = NEG THEN
	    WITH VAL.VALP^ DO BEGIN
	      RVAL := -RVAL;
	      HEAD := HEAD + 100000B
	    END;
	  LSP := REALPTR;
	  FVALU := VAL;
	  INSYMBOL
	END
	ELSE BEGIN
	  ERROR(106);
	  SKIP(FSYS)
	END
      END;
      IF NOT (SY IN FSYS) THEN BEGIN
	ERROR(6);
	SKIP(FSYS)
      END
    END;
    FSP := LSP
  END (*CONSTANT*);


  FUNCTION COMPTYPES(FSP1,FSP2: STP) : BOOLEAN;
  (*DECIDE WHETHER STRUCTURES POINTED AT BY FSP1 AND FSP2 ARE COMPATIBLE*)


  VAR
      NXT1,NXT2: CTP;
      COMP: BOOLEAN;
      LMIN, LMAX, I: INTEGER;

  BEGIN
    IF FSP1 = FSP2 THEN
      IF FSP1^.FORM = BOUNDLESS THEN
	COMPTYPES := FALSE
      ELSE
	COMPTYPES := TRUE
    ELSE IF (FSP1 <> NIL) AND (FSP2 <> NIL) THEN
      IF FSP1^.FORM = FSP2^.FORM THEN
	CASE FSP1^.FORM OF
	  SCALAR:
	    COMPTYPES := FALSE;
	    (* IDENTICAL SCALARS DECLARED ON DIFFERENT LEVELS ARE
	     NOT RECOGNIZED TO BE COMPATIBLE*)
	  SUBRANGE:
	    COMPTYPES := COMPTYPES(FSP1^.RANGETYPE,FSP2^.RANGETYPE);
	  POINTER:
	    IF (FSP1=NILPTR) OR (FSP2=NILPTR) THEN
	      COMPTYPES := TRUE
	    ELSE IF POINTERCNT = 10 THEN
	      COMPTYPES := FALSE
	    ELSE BEGIN
	      POINTERCNT := POINTERCNT + 1;
	      COMPTYPES := COMPTYPES(FSP1^.ELTYPE,FSP2^.ELTYPE);
	      POINTERCNT := POINTERCNT - 1;
	    END;
	  POWER:
	    COMPTYPES := COMPTYPES(FSP1^.ELSET,FSP2^.ELSET);
	  ARRAYS: BEGIN
	    COMP := COMPTYPES(FSP1^.AELTYPE,FSP2^.AELTYPE) AND
	      (FSP1^.SIZE = FSP2^.SIZE);
	    IF FSP1^.PACKOPT OR FSP2^.PACKOPT THEN BEGIN
	      GETBOUNDS(FSP1^.INXTYPE,LMIN,LMAX);
	      I := LMAX - LMIN;
	      GETBOUNDS(FSP2^.INXTYPE,LMIN,LMAX);
	      COMP := COMP AND (I = LMAX - LMIN)
	    END (*COMPATIBILITY OF PACKED STRUCTURES*);
	    COMPTYPES := COMP
	  END;
	  (*ALTERNATIVES: -- ADD A THIRD BOOLEAN TERM: INDEXTYPE MUST
	   BE COMPATIBLE.
	   -- ADD A FOURTH BOOLEAN TERM: LOWBOUNDS MUST
	   BE THE SAME*)
	  RECORDS: BEGIN
	    NXT1 := FSP1^.FSTFLD;
	    NXT2 := FSP2^.FSTFLD;
	    COMP := TRUE;
	    WHILE (NXT1 <> NIL) AND (NXT2 <> NIL) DO BEGIN
	      COMP := COMP AND COMPTYPES(NXT1^.IDTYPE,NXT2^.IDTYPE);
	      NXT1 := NXT1^.NEXT;
	      NXT2 := NXT2^.NEXT
	    END;
	    COMPTYPES := COMP AND (NXT1 = NIL) AND (NXT2 = NIL) AND
	      (FSP1^.RECVAR = NIL) AND (FSP2^.RECVAR = NIL)
	  END;
	  (*IDENTICAL RECORDS ARE RECOGNIZED TO BE COMPATIBLE
	   IFF NO VARIANTS OCCUR*)
	  FILES:
	    COMPTYPES := COMPTYPES(FSP1^.FILTYPE,FSP2^.FILTYPE);
	  BOUNDLESS:
	    COMPTYPES := FALSE;
	  STRINGPARM:
	    COMPTYPES := TRUE
	END (*CASE*)
      ELSE (*FSP1^.FORM <> FSP2^.FORM*)
      IF FSP1^.FORM = SUBRANGE THEN
	COMPTYPES := COMPTYPES(FSP1^.RANGETYPE,FSP2)
      ELSE IF FSP2^.FORM = SUBRANGE THEN
	COMPTYPES := COMPTYPES(FSP1,FSP2^.RANGETYPE)
      ELSE BEGIN
	COMPTYPES := FALSE;
	IF FSP1^.FORM = STRINGPARM THEN BEGIN
	  IF FSP2^.FORM = ARRAYS THEN
	    COMPTYPES := FSP2^.AELTYPE = CHARPTR
	END
	ELSE IF FSP2^.FORM = STRINGPARM THEN
	  IF FSP1^.FORM = ARRAYS THEN
	    COMPTYPES := FSP1^.AELTYPE = CHARPTR
      END
    ELSE
      COMPTYPES := TRUE
  END (*COMPTYPES*);


  FUNCTION STRING(FSP: STP) : BOOLEAN;

  BEGIN
    STRING := FALSE;
    IF FSP <> NIL THEN
      IF FSP^.FORM = ARRAYS THEN
	IF COMPTYPES(FSP^.AELTYPE,CHARPTR) THEN
	  STRING := TRUE
  END (*STRING*);


  PROCEDURE TYP(FSYS: SETOFSYS; VAR FSP: STP; VAR FSIZE: ADDRRANGE) (*$Y+*);

  VAR
      LSP,LSP1,LSP2: STP;
      OLDTOP: DISPRANGE;
      LCP: CTP;
      LSIZE,DISPL: ADDRRANGE;
      LMIN,LMAX: INTEGER;
      PSIZE, CORRECTION: INTEGER;
      PACKFLAG: BOOLEAN;


    PROCEDURE SIMPLETYPE(FSYS: SETOFSYS; VAR FSP: STP; VAR FSIZE: ADDRRANGE);

    VAR
	LSP,LSP1: STP;
	LCP,LCP1: CTP;
	TTOP: DISPRANGE;
	LCNT: INTEGER;
	LVALU: VALU;

    BEGIN
      FSIZE := 2;
      IF NOT (SY IN SIMPTYPEBEGSYS) THEN BEGIN
	ERROR(1);
	SKIP(FSYS OR SIMPTYPEBEGSYS)
      END;
      IF SY IN SIMPTYPEBEGSYS THEN BEGIN
	IF SY = LPARENT THEN BEGIN
	  TTOP := TOP; (*DECL. CONSTS LOCAL TO INNERMOST BLOCK*)
	  WHILE DISPLAY[TOP].OCCUR <> BLCK DO
	    TOP := TOP - 1;
	  NEW(LSP,SCALAR,DECLARED);
	  LSP^.SIZE := 2;
	  LSP^.SELFSTP := 0;
	  LCP1 := NIL;
	  LCNT := 0;
	  REPEAT
	    INSYMBOL;
	    IF SY = IDENT THEN BEGIN
	      NEW(LCP,KONST);
	      WITH LCP^ DO BEGIN
		NAME := ID;
		IDTYPE := LSP;
		NEXT := LCP1;
		VALUES.IVAL := LCNT;
	      END;
	      ENTERID(LCP);
	      LCNT := LCNT + 1;
	      LCP1 := LCP;
	      INSYMBOL
	    END
	    ELSE
	      ERROR(2);
	    IF NOT (SY IN FSYS OR [COMMA,RPARENT]) THEN BEGIN
	      ERROR(6);
	      SKIP(FSYS OR [COMMA,RPARENT])
	    END
	  UNTIL SY <> COMMA;
	  LSP^.FCONST := LCP1;
	  TOP := TTOP;
	  IF SY = RPARENT THEN
	    INSYMBOL
	  ELSE
	    ERROR(4)
	END
	ELSE BEGIN
	  IF SY = IDENT THEN BEGIN
	    SEARCHID([TYPES,KONST],LCP);
	    INSYMBOL;
	    IF LCP^.KLASS = KONST THEN BEGIN
	      NEW(LSP,SUBRANGE);
	      WITH LSP^, LCP^ DO BEGIN
		RANGETYPE := IDTYPE;
		SELFSTP := 0;
		IF STRING(RANGETYPE) THEN BEGIN
		  ERROR(148);
		  RANGETYPE := NIL
		END;
		IF RANGETYPE <> NIL THEN
		  SIZE := RANGETYPE^.SIZE;
		MIN := VALUES
	      END;
	      IF SY = COLON THEN
		INSYMBOL
	      ELSE
		ERROR(5);
	      CONSTANT(FSYS,LSP1,LVALU);
	      LSP^.MAX := LVALU;
	      IF LSP^.RANGETYPE <> LSP1 THEN
		ERROR(107)
	    END
	    ELSE
	      LSP := LCP^.IDTYPE
	  END (*SY = IDENT*)
	  ELSE BEGIN
	    NEW(LSP,SUBRANGE);
	    CONSTANT(FSYS OR [COLON],LSP1,LVALU);
	    IF STRING(LSP1) THEN BEGIN
	      ERROR(148);
	      LSP1 := NIL
	    END;
	    WITH LSP^ DO BEGIN
	      RANGETYPE := LSP1;
	      MIN := LVALU;
	      IF RANGETYPE <> NIL THEN
		SIZE := RANGETYPE^.SIZE
	    END;
	    IF SY = COLON THEN
	      INSYMBOL
	    ELSE
	      ERROR(5);
	    CONSTANT(FSYS,LSP1,LVALU);
	    LSP^.MAX := LVALU;
	    LSP^.SELFSTP := 0;
	    IF LSP^.RANGETYPE <> LSP1 THEN
	      ERROR(107)
	  END;
	  IF LSP <> NIL THEN
	    WITH LSP^ DO
	      IF FORM = SUBRANGE THEN
		IF RANGETYPE <> NIL THEN
		  IF RANGETYPE = REALPTR THEN BEGIN
		    IF MIN.VALP^.RVAL > MAX.VALP^.RVAL THEN
		      ERROR(102)
		  END
		  ELSE IF MIN.IVAL > MAX.IVAL THEN
		    ERROR(102)
	END;
	FSP := LSP;
	IF NOT (SY IN FSYS) THEN BEGIN
	  ERROR(6);
	  SKIP(FSYS)
	END
      END
      ELSE
	FSP := NIL;
      IF FSP = NIL THEN
	FSIZE := 2
      ELSE
	FSIZE := FSP^.SIZE
    END (*SIMPLETYPE*);


    PROCEDURE FIELDLIST(FSYS: SETOFSYS; VAR FRECVAR: STP);

    LABEL
	1;

    VAR
	LCP,LCP1,NXT,NXT1: CTP;
	LSP,LSP1,LSP2,LSP3,LSP4: STP;
	MINSIZE,MAXSIZE,LSIZE: ADDRRANGE;
	LVALU: VALU;
	LID: ALFA;

    BEGIN
      NXT1 := NIL;
      LSP := NIL;
      IF NOT (SY IN [IDENT,CASESY]) THEN BEGIN
	ERROR(19);
	SKIP(FSYS OR [IDENT,CASESY])
      END;
      WHILE SY = IDENT DO BEGIN
	NXT := NXT1;
	LOOP
	  IF SY = IDENT THEN BEGIN
	    NEW(LCP,FIELD);
	    WITH LCP^ DO BEGIN
	      NAME := ID;
	      IDTYPE := NIL;
	      NEXT := NXT
	    END;
	    NXT := LCP;
	    ENTERID(LCP);
	    INSYMBOL
	  END
	  ELSE
	    ERROR(2);
	  IF NOT (SY IN [COMMA,COLON]) THEN BEGIN
	    ERROR(6);
	    SKIP(FSYS OR [COMMA,COLON,SEMICOLON,CASESY])
	  END;
	EXIT IF SY <> COMMA;
	  INSYMBOL
	END;
	IF SY = COLON THEN
	  INSYMBOL
	ELSE
	  ERROR(5);
	TYP(FSYS OR [CASESY,SEMICOLON],LSP,LSIZE);
	WHILE NXT <> NXT1 DO
	  WITH NXT^ DO BEGIN
	    IDTYPE := LSP;
	    FLDADDR := DISPL;
	    IF LSP <> NIL THEN
	      IF LSP^.FORM = ARRAYS THEN BEGIN
		FLDADDR := FLDADDR - LSP^.ADDRCORR;
		IF NOT PACKFLAG THEN (*PACKFLAG INDICATES PACKED ARR*)
		BEGIN
		  LSP1 := LSP;
		  WHILE LSP1^.AELTYPE^.FORM = ARRAYS DO
		    LSP1 := LSP1^.AELTYPE;
		  PACKFLAG := LSP^.PACKOPT
		END
	      END;
	    NXT := NEXT;
	    DISPL := DISPL + LSIZE
	  END;
	NXT1 := LCP;
	IF SY = SEMICOLON THEN BEGIN
	  INSYMBOL;
	  IF NOT (SY IN [IDENT,CASESY]) THEN BEGIN
	    ERROR(19);
	    SKIP(FSYS OR [IDENT,CASESY])
	  END
	END
      END (*WHILE*);
      NXT := NIL;
      WHILE NXT1 <> NIL DO
	WITH NXT1^ DO BEGIN
	  LCP := NEXT;
	  NEXT := NXT;
	  NXT := NXT1;
	  NXT1 := LCP
	END;
      IF SY = CASESY THEN BEGIN
	LCP := NIL ; (*POSSIBLY NO TAGFIELDIDENTIFIER*)
	INSYMBOL;
	IF SY = IDENT THEN BEGIN
	  LID := ID;
	  INSYMBOL;
	  IF (SY <> COLON) AND (SY <> OFSY) THEN BEGIN
	    ERROR(169);
	    SKIP(FSYS OR [LPARENT])
	  END
	  ELSE BEGIN
	    IF SY = COLON THEN BEGIN
	      NEW(LSP,TAGFWITHID);
	      NEW(LCP,FIELD);
	      WITH LCP^ DO BEGIN
		NAME := LID;
		IDTYPE := NIL;
		NEXT := NIL;
		FLDADDR := DISPL
	      END;
	      ENTERID(LCP);
	      INSYMBOL;
	      IF SY <> IDENT THEN BEGIN
		ERROR(2);
		SKIP(FSYS OR [LPARENT]);
		GOTO 1
	      END
	      ELSE BEGIN
		LID := ID;
		INSYMBOL;
		IF SY <> OFSY THEN BEGIN
		  ERROR(8);
		  SKIP(FSYS OR [LPARENT]);
		  GOTO 1
		END;
	      END
	    END
	    ELSE
	      NEW(LSP,TAGFWITHOUTID);
	    WITH LSP^ DO BEGIN
	      SIZE := 0;
	      FSTVAR := NIL;
	      SELFSTP := 0;
	      IF FORM = TAGFWITHID THEN
		TAGFIELDP := NIL
	      ELSE
		TAGFIELDTYPE := NIL;
	    END;
	    FRECVAR := LSP;
	    ID := LID;
	    KK := ALFALENG; (*RESTAURATION*)
	    SEARCHID([TYPES],LCP1);
	    LSP1 := LCP1^.IDTYPE;
	    IF LSP1 <> NIL THEN
	      IF (LSP1^.FORM <= SUBRANGE) OR STRING(LSP1) THEN BEGIN
		IF COMPTYPES(REALPTR,LSP1) THEN
		  ERROR(109)
		ELSE IF STRING(LSP1) THEN
		  ERROR(399);
		WITH LSP^ DO BEGIN
		  IF FORM = TAGFWITHID THEN BEGIN
		    DISPL := DISPL + LSP1^.SIZE;
		    TAGFIELDP := LCP;
		    IF LCP <> NIL THEN
		      IF LCP <> NIL THEN
			LCP^.IDTYPE := LSP1;
		  END
		  ELSE
		    TAGFIELDTYPE := LSP1
		END;
	      END
	      ELSE
		ERROR(110);
	    INSYMBOL;
	  END
	END
	ELSE BEGIN
	  ERROR(2);
	  SKIP(FSYS OR [LPARENT])
	END;
	1:
	  LSP^.SIZE := DISPL;
	LSP1 := NIL;
	MINSIZE := DISPL;
	MAXSIZE := DISPL;
	LOOP
	  LSP2 := NIL;
	  LOOP
	    CONSTANT(FSYS OR [COMMA,COLON,LPARENT],LSP3,LVALU);
	    IF LSP <> NIL THEN
	      IF LSP^.FORM = TAGFWITHID THEN BEGIN
		IF LSP^.TAGFIELDP <> NIL THEN
		  IF NOT COMPTYPES(LSP^.TAGFIELDP^.IDTYPE,LSP3) THEN
		    ERROR(111)
	      END
	      ELSE IF NOT COMPTYPES(LSP^.TAGFIELDTYPE,LSP3) THEN
		ERROR(111);
	    NEW(LSP3,VARIANT);
	    WITH LSP3^ DO BEGIN
	      NXTVAR := LSP1;
	      SUBVAR := LSP2;
	      VARVAL := LVALU;
	      SELFSTP := 0
	    END;
	    LSP1 := LSP3;
	    LSP2 := LSP3;
	  EXIT IF SY <> COMMA;
	    INSYMBOL
	  END;
	  IF SY = COLON THEN
	    INSYMBOL
	  ELSE
	    ERROR(5);
	  IF SY = LPARENT THEN
	    INSYMBOL
	  ELSE
	    ERROR(9);
	  FIELDLIST(FSYS OR [RPARENT,SEMICOLON],LSP2);
	  IF DISPL > MAXSIZE THEN
	    MAXSIZE := DISPL;
	  WHILE LSP3 <> NIL DO BEGIN
	    LSP4 := LSP3^.SUBVAR;
	    LSP3^.SUBVAR := LSP2;
	    LSP3^.SIZE := DISPL;
	    LSP3 := LSP4
	  END;
	  IF SY = RPARENT THEN BEGIN
	    INSYMBOL;
	    IF NOT (SY IN FSYS OR [SEMICOLON]) THEN BEGIN
	      ERROR(6);
	      SKIP(FSYS OR [SEMICOLON])
	    END
	  END
	  ELSE
	    ERROR(4);
	EXIT IF SY <> SEMICOLON;
	  DISPL := MINSIZE;
	  INSYMBOL
	END;
	DISPL := MAXSIZE;
	LSP^.FSTVAR := LSP1;
      END
      ELSE IF LSP <> NIL THEN
	IF LSP^.FORM = ARRAYS THEN
	  FRECVAR := LSP
	ELSE
	  FRECVAR := NIL
    END (*FIELDLIST*);

  BEGIN (*TYP*)
    IF NOT (SY IN TYPEBEGSYS) THEN BEGIN
      ERROR(10);
      SKIP(FSYS OR TYPEBEGSYS)
    END;
    IF SY IN TYPEBEGSYS THEN BEGIN
      CORRECTION := 0;
      IF SY IN SIMPTYPEBEGSYS THEN
	SIMPLETYPE(FSYS,FSP,FSIZE)
      ELSE
      (*^*)
      IF SY = ARROW THEN BEGIN
	NEW(LSP,POINTER);
	FSP := LSP;
	WITH LSP^ DO BEGIN
	  ELTYPE := NIL;
	  SIZE := 2;
	  SELFSTP := 0
	END;
	INSYMBOL;
	IF SY = IDENT THEN BEGIN
	  PRTERR := FALSE; (*NO ERROR IF SEARCH NOT SUCCESSFUL*)
	  SEARCHID([TYPES],LCP);
	  PRTERR := TRUE;
	  IF LCP = NIL THEN (*FORWARD REFERENCED TYPE ID*)
	  BEGIN
	    NEW(LCP,TYPES);
	    WITH LCP^ DO BEGIN
	      NAME := ID;
	      IDTYPE := LSP;
	      NEXT := FWPTR
	    END;
	    FWPTR := LCP
	  END
	  ELSE BEGIN
	    IF LCP^.IDTYPE <> NIL THEN
	      IF LCP^.IDTYPE^.FORM = FILES THEN
		ERROR(108)
	      ELSE
		LSP^.ELTYPE := LCP^.IDTYPE
	  END;
	  INSYMBOL;
	END
	ELSE
	  ERROR(2);
      END
      ELSE BEGIN
	IF SY = PACKEDSY THEN BEGIN
	  INSYMBOL;
	  PACKFLAG := TRUE;
	  IF NOT (SY IN TYPEDELS) THEN BEGIN
	    ERROR(10);
	    SKIP(FSYS OR TYPEDELS)
	  END
	END
	ELSE
	  PACKFLAG := FALSE;
	  (*ARRAY*)
	IF SY = ARRAYSY THEN BEGIN
	  INSYMBOL;
	  IF SY = LBRACK THEN
	    INSYMBOL
	  ELSE
	    ERROR(11);
	  LSP1 := NIL;
	  LOOP
	    NEW(LSP,ARRAYS);
	    WITH LSP^ DO BEGIN
	      AELTYPE := LSP1;
	      INXTYPE := NIL;
	      SELFSTP := 0;
	      SIZE := 2;
	      PACKOPT := FALSE
	    END;
	    LSP1 := LSP;
	    SIMPLETYPE(FSYS OR [COMMA,RBRACK,OFSY],LSP2,LSIZE);
	    IF LSP2 <> NIL THEN
	      IF LSP2^.FORM <= SUBRANGE THEN BEGIN
		IF LSP2 = REALPTR THEN BEGIN
		  ERROR(109);
		  LSP2 := NIL
		END
		ELSE IF LSP2 = INTPTR THEN BEGIN
		  ERROR(149);
		  LSP2 := NIL
		END;
		LSP^.INXTYPE := LSP2
	      END
	      ELSE BEGIN
		ERROR(113);
		LSP2 := NIL
	      END;
	  EXIT IF SY <> COMMA;
	    INSYMBOL
	  END;
	  IF SY = RBRACK THEN
	    INSYMBOL
	  ELSE
	    ERROR(12);
	  IF SY = OFSY THEN
	    INSYMBOL
	  ELSE
	    ERROR(8);
	  TYP(FSYS,LSP,LSIZE);
	  IF LSP <> NIL THEN (*FOR CALCULATION OF HYPOTH.ADDR*)
	    IF LSP^.FORM = ARRAYS THEN
	      CORRECTION := LSP^.ADDRCORR;
	  REPEAT
	    WITH LSP1^ DO BEGIN
	      LSP2 := AELTYPE;
	      AELTYPE := LSP;
	      IF PACKFLAG AND (LSP = BOOLPTR) THEN
		PACKOPT := TRUE;
	      IF INXTYPE <> NIL THEN BEGIN
		GETBOUNDS(INXTYPE,LMIN,LMAX);
		IF PACKOPT THEN BEGIN
		  IF AELTYPE = BOOLPTR THEN
		    LSIZE := 2 * ((LMAX - LMIN + 16) DIV 16)
		END
		ELSE BEGIN
		  IF COMPTYPES(AELTYPE,CHARPTR) THEN (* BYTE, ASCII, ETC. *)
		  (*ACTUAL CHARSIZE = 1*)
		  BEGIN
		    CORRECTION := CORRECTION + LMIN;
		    LSIZE := 2 * ((LMAX - LMIN + 2) DIV 2);
		  END
		  ELSE BEGIN
		    CORRECTION := CORRECTION + LMIN * LSIZE;
		    LSIZE := LSIZE * (LMAX - LMIN + 1)
		  END
		END;
		ADDRCORR := CORRECTION;
		SIZE := LSIZE
	      END
	    END;
	    LSP := LSP1;
	    LSP1 := LSP2
	  UNTIL LSP1 = NIL
	END
	ELSE
	(*RECORD*)
	IF SY = RECORDSY THEN BEGIN
	  INSYMBOL;
	  OLDTOP := TOP;
	  IF TOP < DISPLIMIT THEN BEGIN
	    TOP := TOP + 1;
	    DISPLAY[TOP].FNAME := NIL
	  END
	  ELSE
	    ERROR(250);
	  DISPL := 0;
	  FIELDLIST(FSYS-[SEMICOLON] OR [ENDSY],LSP1);
	  NEW(LSP,RECORDS);
	  WITH LSP^ DO BEGIN
	    FSTFLD := DISPLAY[TOP].FNAME;
	    SELFSTP := 0;
	    RECVAR := LSP1;
	    SIZE := DISPL;
	    PACKSTRUCT := PACKFLAG
	  END;
	  TOP := OLDTOP;
	  IF SY = ENDSY THEN
	    INSYMBOL
	  ELSE
	    ERROR(13)
	END
	ELSE
	(*SET*)
	IF SY = SETSY THEN BEGIN
	  INSYMBOL;
	  IF SY = OFSY THEN
	    INSYMBOL
	  ELSE
	    ERROR(8);
	  SIMPLETYPE(FSYS,LSP1,LSIZE);
	  IF LSP1 <> NIL THEN
	    IF LSP1^.FORM > SUBRANGE THEN BEGIN
	      ERROR(115);
	      LSP1 := NIL
	    END
	    ELSE IF LSP1 = REALPTR THEN
	      ERROR(114);
	  NEW(LSP,POWER);
	  WITH LSP^ DO BEGIN
	    ELSET := LSP1;
	    SELFSTP := 0;
	    IF LSP1 = CHARPTR THEN BEGIN
	      LMIN := 0;
	      LMAX := 63
	    END
	    ELSE IF LSP1 <> NIL THEN BEGIN
	      GETBOUNDS(LSP1,LMIN,LMAX);
	      IF (LSP1^.FORM = SUBRANGE) AND (LSP1^.RANGETYPE = CHARPTR)
		THEN BEGIN
		  LMIN := 0;
		  LMAX := LMAX - 40B
		END
	    END
	    ELSE
	      LMAX := 0;
	    IF (LMIN < 0) OR (LMAX = 0) THEN
	      ERROR(604);
	    IF LMAX <= 15 THEN
	      SIZE := 2
	    ELSE IF LMAX < 64 THEN
	      SIZE := 8
	    ELSE
	      ERROR(604)
	  END
	END
	ELSE
	(*FILE*)
	IF SY = FILESY THEN BEGIN
	  INSYMB	  IF SY = OFSY THEN
	    INSYMBOL
	  ELSE
	    ERROR(8);
	  TYP(FSYS,LSP1,LSIZE);
	  NEW(LSP,FILES);
	  WITH LSP^ DO BEGIN
	    FILTYPE := LSP1;
	    SIZE := 2;
	    SELFSTP := 0;
	  END;
	  IF LSP1 <> NIL THEN
	    IF LSP1^.FORM = FILES THEN BEGIN
	      ERROR(108);
	      LSP^.FILTYPE := NIL
	    END;
	END;
	FSP := LSP
      END;
      IF NOT (SY IN FSYS) THEN BEGIN
	ERROR(6);
	SKIP(FSYS)
      END
    END
    ELSE
      FSP := NIL;
    IF NOIO AND (FSP <> NIL) THEN
      IF FSP^.FORM = FILES THEN ERROR(185);
    IF FSP = NIL THEN
      FSIZE := 2
    ELSE
      FSIZE := FSP^.SIZE
  END (*TYP*);


  PROCEDURE LABELDECLARATION (*$Y+*);

  LABEL
      1;

  VAR
      LLP: LBP;

  BEGIN
    LOOP
      IF SY = INTCONST THEN BEGIN
	LLP := FSTLABP;
	WHILE LLP <> FLABP DO
	  IF LLP^.LABVAL = VAL.IVAL THEN BEGIN
	    ERROR(166);
	    GOTO 1
	  END
	  ELSE
	    LLP := LLP^.NEXTLAB;
	NEW(LLP);
	WITH LLP^ DO BEGIN
	  LABVAL := VAL.IVAL;
	  DEFINED := FALSE;
	  LABCHAIN := NIL;
	  NEXTLAB := FSTLABP;
	  DECLARED := TRUE
	END;
	FSTLABP := LLP;
	1:
	  INSYMBOL
      END
      ELSE
	ERROR(15);
      IF NOT (SY IN FSYS OR [COMMA,SEMICOLON]) THEN BEGIN
	ERROR(6);
	SKIP(FSYS OR [COMMA,SEMICOLON])
      END;
    EXIT IF SY <> COMMA;
      INSYMBOL
    END;
    IF SY = SEMICOLON THEN
      INSYMBOL
    ELSE
      ERROR(14)
  END (*LABELDECLARATION*);


  PROCEDURE CONSTDECLARATION (*$Y+*);

  VAR
      LCP: CTP;
      LSP: STP;
      LVALU: VALU;

  BEGIN
    IF SY <> IDENT THEN BEGIN
      ERROR(2);
      SKIP(FSYS OR [IDENT])
    END;
    WHILE SY = IDENT DO BEGIN
      NEW(LCP,KONST);
      WITH LCP^ DO BEGIN
	NAME := ID;
	IDTYPE := NIL;
	NEXT := NIL;
	KADDR := 0;
	BODYINDEX:= 0
      END;
      INSYMBOL;
      IF (SY = RELOP) AND (OP = EQOP) THEN
	INSYMBOL
      ELSE
	ERROR(16);
      CONSTANT(FSYS OR [SEMICOLON],LSP,LVALU);
      ENTERID(LCP);
      LCP^.IDTYPE := LSP;
      LCP^.VALUES := LVALU;
      IF SY = SEMICOLON THEN BEGIN
	INSYMBOL;
	IF NOT (SY IN FSYS OR [IDENT]) THEN BEGIN
	  ERROR(6);
	  SKIP(FSYS OR [IDENT])
	END
      END
      ELSE
	ERROR(14)
    END
  END (*CONSTANTDECLARATION*);


  PROCEDURE TYPEDECLARATION (*$Y+*);

  VAR
      LCP,LCP1,LCP2: CTP;
      LSP: STP;
      LSIZE: ADDRRANGE;

  BEGIN
    IF SY <> IDENT THEN BEGIN
      ERROR(2);
      SKIP(FSYS OR [IDENT])
    END;
    WHILE SY = IDENT DO BEGIN
      NEW(LCP,TYPES);
      WITH LCP^ DO BEGIN
	NAME := ID;
	IDTYPE := NIL
      END;
      INSYMBOL;
      IF (SY = RELOP) AND (OP = EQOP) THEN
	INSYMBOL
      ELSE
	ERROR(16);
      TYP(FSYS OR [SEMICOLON],LSP,LSIZE);
      ENTERID(LCP);
      LCP^.IDTYPE := LSP;
      (*HAS ANY FORWARD REFERENCE BEEN SATISFIED:*)
      LCP1 := FWPTR;
      WHILE LCP1 <> NIL DO BEGIN
	IF LCP1^.NAME = LCP^.NAME THEN BEGIN
	  LCP1^.IDTYPE^.ELTYPE := LCP^.IDTYPE;
	  IF LCP1 <> FWPTR THEN
	    LCP2^.NEXT := LCP1^.NEXT
	  ELSE
	    FWPTR := LCP1^.NEXT;
	END;
	LCP2 := LCP1;
	LCP1 := LCP1^.NEXT
      END;
      IF SY = SEMICOLON THEN BEGIN
	INSYMBOL;
	IF NOT (SY IN FSYS OR [IDENT]) THEN BEGIN
	  ERROR(6);
	  SKIP(FSYS OR [IDENT])
	END
      END
      ELSE
	ERROR(14)
    END;
    IF FWPTR <> NIL THEN BEGIN
      ERROR(117);
      WRITELN;
      REPEAT
	WRITELN('   TYPE-ID ',FWPTR^.NAME);
	FWPTR := FWPTR^.NEXT
      UNTIL FWPTR = NIL;
      IF NOT EOLN(INPUT) THEN
	WRITE(' ':CHCNT + 8)
    END
  END (*TYPEDECLARATION*);


  PROCEDURE VARDECLARATION (*$Y+*);

  VAR
      LCP,NXT: CTP;
      LSP: STP;
      LSIZE: ADDRRANGE;

  BEGIN
    IF (LEVEL = 1) AND (STCLASS = DEFAULTSY) THEN
      STCLASS := STATICSY;
    NXT := NIL;
    REPEAT
      LOOP
	IF SY = IDENT THEN BEGIN
	  NEW(LCP,VARS);
	  WITH LCP^ DO BEGIN
	    NAME := ID;
	    NEXT := NXT;
	    IDTYPE := NIL;
	    VKIND := ACTUAL;
	    VCLASS := STCLASS;
	    VNOTUSED := TRUE;
	    VLEV := LEVEL
	  END;
	  ENTERID(LCP);
	  NXT := LCP;
	  INSYMBOL;
	END
	ELSE
	  ERROR(2);
	IF NOT (SY IN FSYS OR [COMMA,COLON] OR TYPEDELS) THEN BEGIN
	  ERROR(6);
	  SKIP(FSYS OR [COMMA,COLON,SEMICOLON] OR TYPEDELS)
	END;
      EXIT IF SY <> COMMA;
	INSYMBOL
      END;
      IF SY = COLON THEN
	INSYMBOL
      ELSE
	ERROR(5);
      TYP(FSYS OR [SEMICOLON] OR TYPEDELS,LSP,LSIZE);
      WHILE NXT <> NIL DO
	WITH NXT^ DO BEGIN
	  IDTYPE := LSP;
	  IF STCLASS = STATICSY THEN BEGIN
	    IF LSP^.FORM=FILES THEN BEGIN
	      STATBASE := STATBASE + FILESIZECORR;
	      IF LSP^.FILTYPE=CHARPTR THEN
		STATBASE := STATBASE+TEXTBUFFSIZE;
	      VADDR := STATBASE;
	      STATBASE := STATBASE+LSIZE+LSP^.FILTYPE^.SIZE;
	    END
	    ELSE BEGIN
	      VADDR := STATBASE;
	      STATBASE := STATBASE+LSIZE
	    END
	  END
	  ELSE IF STCLASS = DEFAULTSY THEN BEGIN
	    LC := LC - LSIZE;
	    VADDR := LC;
	    IF LSP <> NIL THEN BEGIN
	      IF LSP^.FORM = FILES THEN BEGIN
		LSIZE := LSP^.FILTYPE^.SIZE;
		VADDR := VADDR - LSIZE; (* ALLOCATE SPACE FOR RECORD BUFFER *)
		LC := LC-FILESIZECORR-LSIZE;
		IF LEVEL > 1 THEN
		  ERROR(108);
		IF LSP^.FILTYPE = CHARPTR THEN
		  LC := LC - TEXTBUFFSIZE
	      END;
	    END;
	  END
	  ELSE VADDR := 0;
	  IF LSP <> NIL THEN IF LSP^.FORM = ARRAYS THEN
	    VADDR := VADDR - LSP^.ADDRCORR;
	  NXT := NEXT
	END;
      IF STCLASS = DEFAULTSY THEN
	IF LSP <> NIL THEN
	  IF LSP^.FORM = ARRAYS THEN BEGIN
	    IF NOT TESTPACKED THEN BEGIN
	      WHILE LSP^.AELTYPE^.FORM = ARRAYS DO
		LSP := LSP^.AELTYPE;
	      TESTPACKED := LSP^.PACKOPT (*BASE LEVEL OF ARRAY PACKED?*)
	    END
	  END
	  ELSE IF LSP^.FORM = RECORDS THEN
	  (*CHECK  IF A RECORD CONTAINS PACKED ARRAYSTRUCTURES*)
	    TESTPACKED := TESTPACKED OR LSP^.PACKSTRUCT;
      IF SY = SEMICOLON THEN BEGIN
	INSYMBOL;
	IF NOT (SY IN FSYS OR [IDENT]) THEN BEGIN
	  ERROR(6);
	  SKIP(FSYS OR [IDENT])
	END
      END
      ELSE
	ERROR(14)
    UNTIL (SY <> IDENT) AND NOT (SY IN TYPEDELS);
    IF FWPTR <> NIL THEN BEGIN
      ERROR(117);
      WRITELN;
      REPEAT
	WRITELN('   TYPE-ID ',FWPTR^.NAME);
	FWPTR := FWPTR^.NEXT
      UNTIL FWPTR = NIL;
      IF NOT EOLN(INPUT) THEN
	WRITE(' ':CHCNT + 8)
    END
  END (*VARIABLEDECLARATION*);


  PROCEDURE PROCEDUREDECLARATION(FSY: SYMBOL);

  VAR
      OLDLEV: LEVRANGE;
      LSY: SYMBOL;
      LCP,LCP1: CTP;
      LSP: STP;
      INTRPT: BOOLEAN;
      FORW: BOOLEAN;
      OLDTOP: DISPRANGE;
      LLC,LCM, PARLC,PARSIZE: ADDRRANGE;


    PROCEDURE PARAMTRLIST(FSY: SETOFSYS; VAR FPAR: CTP) (*$Y+*);

    VAR
	LCP,LCP1,LCP2,LCP3: CTP;
	LSP: STP;
	LKIND: IDKIND;
	LCP4: CTP;
	LSP1,LSP2: STP;
	DIM: INTEGER;


      PROCEDURE PARAMETERSPECIFICATION(FSY: SETOFSYS; VAR FPAR: CTP);

      VAR
	  LCP,LCP1,LCP2: CTP;
	  LSP: STP;
	  LKIND: IDKIND;
	  OK, ERRFOUND: BOOLEAN;
	  (*DIGESTS THE ADDED  SYNTACTIC UNIT: <FORMAL FORMAL PARAM. SECTION>*)





	PROCEDURE PSERROR(ERRORNO: INTEGER; STOPSYS: SETOFSYS);

	BEGIN
	  IF NOT ERRFOUND THEN BEGIN
	    ERRFOUND := TRUE;
	    ERROR(ERRORNO)
	  END;
	  SKIP(STOPSYS)
	END;
	(* PSERROR*)



      BEGIN
	LCP1 := NIL;
	ERRFOUND := FALSE;
	WHILE SY IN [LPARENT,SEMICOLON] DO BEGIN
	  INSYMBOL;
	  OK := FALSE;
	  IF SY = PROCEDURESY THEN BEGIN
	    NEW(LCP,PROC,DECLARED,FORMAL);
	    WITH LCP^ DO BEGIN
	      IDTYPE := NIL;
	      NEXT := LCP1;
	      PARMLIST := NIL
	    END;
	    LCP1 := LCP ;
	    INSYMBOL;
	    IF SY = LPARENT THEN BEGIN
	      PARAMETERSPECIFICATION(FSY,LCP2);
	      LCP1^.PARMLIST := LCP2
	    END ;
	    OK := TRUE
	  END
	  ELSE IF SY = FUNCTIONSY THEN BEGIN
	    NEW(LCP,FUNC,DECLARED,FORMAL);
	    WITH LCP^ DO BEGIN
	      NEXT := LCP1;
	      PARMLIST := NIL;
	      IDTYPE := NIL
	    END;
	    LCP1 := LCP;
	    INSYMBOL;
	    IF SY = LPARENT THEN BEGIN
	      PARAMETERSPECIFICATION(FSY, LCP2);
	      LCP1^.PARMLIST := LCP2
	    END ;
	    IF SY = COLON THEN BEGIN
	      INSYMBOL;
	      IF SY = IDENT THEN BEGIN
		SEARCHID([TYPES],LCP);
		LSP := LCP^.IDTYPE;
		INSYMBOL;
		IF LSP <> NIL THEN
		  IF LSP^.FORM >= FILES THEN BEGIN
		    ERROR(120);
		    LSP := NIL
		  END;
		LCP1^.IDTYPE := LSP;
		OK := TRUE
	      END
	    END
	  END (*IF FUNCTIONSY*)
	  ELSE BEGIN
	    IF SY = VARSY THEN BEGIN
	      INSYMBOL;
	      LKIND := FORMAL;
	      IF SY <> COLON THEN
		ERROR(607)
	      ELSE
		INSYMBOL
	    END
	    ELSE
	      LKIND := ACTUAL;
	    IF SY = IDENT THEN BEGIN
	      SEARCHID([TYPES],LCP);
	      LSP := LCP^.IDTYPE;
	      IF LSP <> NIL THEN
		IF (LKIND = ACTUAL) AND (LSP^.FORM = FILES) THEN
		  ERROR(121);
	      NEW(LCP,VARS);
	      WITH LCP^ DO BEGIN
		VKIND := LKIND;
		VCLASS := DEFAULTSY;
		IDTYPE := LSP;
		NEXT := LCP1
	      END;
	      LCP1 := LCP;
	      INSYMBOL;
	      OK := TRUE
	    END
	  END;
	  IF NOT (SY IN [RPARENT,SEMICOLON]) OR NOT OK THEN BEGIN
	    PSERROR(608,[LPARENT,RPARENT,SEMICOLON] OR FSY);
	    WHILE SY = LPARENT DO BEGIN
	      PARAMETERSPECIFICATION(FSY,LCP2);
	      SKIP([LPARENT,RPARENT,SEMICOLON] OR FSY)
	    END
	  END
	END;
	(*WHILE SY*)
	IF SY = RPARENT THEN
	  INSYMBOL;
	IF ERRFOUND THEN
	  FPAR := NIL
	ELSE BEGIN
	  LCP := NIL;
	  WHILE LCP1 <> NIL DO
	    WITH LCP1^ DO BEGIN
	      LCP2 := NEXT;
	      NEXT := LCP;
	      LCP := LCP1;
	      LCP1 := LCP2;
	    END;
	  FPAR := LCP
	END
      END;
      (*PARAMETERSPECIFICATION*)



    BEGIN
      LCP1 := NIL;
      PARLC := 2; (*ADDRESS OF LAST PARAMETER IN THE LIST*)
      IF NOT (SY IN FSY OR [LPARENT]) THEN BEGIN
	ERROR(7);
	SKIP(FSYS OR FSY OR [LPARENT])
      END;
      IF SY = LPARENT THEN BEGIN
	IF FORW THEN
	  ERROR(119);
	INSYMBOL;
	IF NOT (SY IN [IDENT,VARSY,PROCEDURESY,FUNCTIONSY]) THEN BEGIN
	  ERROR(7);
	  SKIP(FSYS OR [IDENT,RPARENT])
	END;
	WHILE SY IN [IDENT,VARSY,PROCEDURESY,FUNCTIONSY] DO BEGIN
	  IF SY = PROCEDURESY THEN BEGIN
	    LCP4 := LCP1; (*FOR PARAMETERSPECIFICATION*)
	    REPEAT
	      INSYMBOL;
	      IF SY = IDENT THEN BEGIN
		NEW(LCP,PROC,DECLARED,FORMAL);
		WITH LCP^ DO BEGIN
		  NAME := ID;
		  IDTYPE := NIL;
		  NEXT := LCP1;
		  PFLEV := LEVEL;
		  PARMLIST := NIL;
		  (*ADDRESSING OF PARAMETERS CAN ONLY BE DONE AFTER
		   THEIR TOTAL LENGTH HAS BECOME KNOWN*)
		END;
		ENTERID(LCP);
		LCP1 := LCP;
		INSYMBOL
	      END
	      ELSE
		ERROR(2);
	      IF NOT (SY IN FSYS OR [LPARENT,COMMA,SEMICOLON,RPARENT])
		THEN BEGIN
		  ERROR(7);
		  SKIP(FSYS OR [COMMA,LPARENT, SEMICOLON,RPARENT])
		END
	    UNTIL SY <> COMMA;
	    IF SY = LPARENT THEN
	      PARAMETERSPECIFICATION(FSYS OR [SEMICOLON,RPARENT],LCP)
	    ELSE
	      LCP := NIL;
	    LCP2 := LCP1 ; (*COPY POINTER TO PROCEDURE-ID LIST*)
	    WHILE LCP2 <> LCP4 DO (*CHAIN SPECIF.LIST TO PROCEDURE-ID*)
	    BEGIN
	      LCP2^.PARMLIST := LCP;
	      LCP2 := LCP2^.NEXT
	    END;
	  END
	  ELSE BEGIN
	    IF SY = FUNCTIONSY THEN BEGIN
	      LCP2 := NIL;
	      REPEAT
		INSYMBOL;
		IF SY = IDENT THEN BEGIN
		  NEW(LCP,FUNC,DECLARED,FORMAL);
		  WITH LCP^ DO BEGIN
		    NAME := ID;
		    IDTYPE := NIL;
		    NEXT := LCP2;
		    PFLEV := LEVEL;
		    PARMLIST := NIL;
		  END;
		  ENTERID(LCP);
		  LCP2 := LCP;
		  INSYMBOL;
		END;
		IF NOT (SY IN [COMMA,COLON,LPARENT]) THEN BEGIN
		  ERROR(7);
		  SKIP(FSYS OR [COMMA,SEMICOLON, RPARENT])
		END;
	      UNTIL SY <> COMMA;
	      IF SY = LPARENT THEN
		PARAMETERSPECIFICATION(FSYS OR [SEMICOLON,COLON,RPARENT] ,LCP4)
	      ELSE
		LCP4 := NIL;
	      IF SY = COLON THEN BEGIN
		INSYMBOL;
		IF SY = IDENT THEN BEGIN
		  SEARCHID([TYPES],LCP);
		  LSP := LCP^.IDTYPE;
		  IF LSP <> NIL THEN
		    IF LSP^.FORM >= FILES THEN BEGIN
		      ERROR(120);
		      LSP := NIL
		    END;
		  LCP3 := LCP2;
		  WHILE LCP2 <> NIL DO BEGIN
		    LCP2^.IDTYPE := LSP;
		    LCP := LCP2;
		    LCP2^.PARMLIST := LCP4;
		    LCP2 := LCP2^.NEXT
		  END;
		  LCP^.NEXT := LCP1;
		  LCP1 := LCP3;
		  INSYMBOL
		END
		ELSE
		  ERROR(2);
		IF NOT (SY IN FSYS OR [SEMICOLON,RPARENT]) THEN BEGIN
		  ERROR(7);
		  SKIP(FSYS OR [SEMICOLON,RPARENT])
		END
	      END
	      ELSE
		ERROR(5)
	    END
	    ELSE BEGIN
	      IF (SY = IDENT) AND (ID = 'STRING    ') THEN BEGIN
		PARSIZE := 4;
		NEW(LSP,STRINGPARM);
		LSP^.SIZE := PARSIZE;
		REPEAT (*READ NEXT IDENTIFIER*)
		  INSYMBOL;
		  IF SY = IDENT THEN BEGIN
		    NEW(LCP,VARS);
		    WITH LCP^ DO BEGIN
		      NAME := ID;
		      NEXT := LCP1;
		      IDTYPE := LSP;
		      VKIND := FORMAL;
		      VCLASS := DEFAULTSY;
		      VLEV := LEVEL;
		      VADDR := PARSIZE; (*TEMPORARILY CONTAINS SIZE*)
		    END;
		    ENTERID(LCP);
		    LCP1 := LCP;
		    INSYMBOL;
		  END
		  ELSE
		    ERROR(2);
		  IF NOT (SY IN [COMMA,SEMICOLON,RPARENT]) THEN BEGIN
		    ERROR(7);
		    SKIP(FSYS OR [COMMA,SEMICOLON,RPARENT])
		  END;
		UNTIL SY <> COMMA;
	      END
	      ELSE BEGIN
		IF SY = VARSY THEN BEGIN
		  LKIND := FORMAL;
		  INSYMBOL
		END
		ELSE
		  LKIND := ACTUAL;
		LCP2 := NIL;
		LOOP
		  IF SY = IDENT THEN BEGIN
		    NEW(LCP,VARS);
		    WITH LCP^ DO BEGIN
		      NAME := ID;
		      IDTYPE := LSP;
		      VKIND := LKIND;
		      VCLASS := DEFAULTSY;
		      NEXT := LCP2;
		      VLEV := LEVEL;
		    END;
		    ENTERID(LCP);
		    LCP2 := LCP;
		    INSYMBOL;
		  END;
		  IF NOT (SY IN [COMMA,COLON] OR FSYS) THEN BEGIN
		    ERROR(7);
		    SKIP(FSYS OR [COMMA,SEMICOLON, RPARENT])
		  END;
		EXIT IF SY <> COMMA;
		  INSYMBOL
		END;
		IF SY = COLON THEN BEGIN
		  INSYMBOL;
		  IF NOT (SY IN [IDENT,ARRAYSY]) THEN
		    ERROR(601)
		  ELSE BEGIN
		    IF SY = ARRAYSY THEN BEGIN
		      IF LKIND <> FORMAL THEN
			ERROR(602);
		      INSYMBOL;
		      LSP1 := NIL;
		      IF SY = LBRACK THEN
			INSYMBOL
		      ELSE
			ERROR(11);
		      LOOP
			NEW(LSP, BOUNDLESS);
			LSP^.SUBSTRUCT := LSP1;
			LSP1 := LSP;
			TYP(FSYS OR [COMMA,RBRACK,OFSY],LSP2,DIM);
			IF LSP2 <> NIL THEN
			  IF LSP2^.FORM = SCALAR THEN BEGIN
			    IF LSP2 = REALPTR THEN BEGIN
			      ERROR(109);
			      LSP2 := NIL
			    END
			  END
			  ELSE BEGIN
			    ERROR(600);
			    LSP2 := NIL
			  END;
			LSP^.INDEXTYPE := LSP2;
		      EXIT IF SY <> COMMA;
			INSYMBOL
		      END;
		      IF SY = RBRACK THEN
			INSYMBOL
		      ELSE
			ERROR(12);
		      IF SY = OFSY THEN
			INSYMBOL
		      ELSE
			ERROR(8);
		      IF SY = IDENT THEN BEGIN
			SEARCHID([TYPES], LCP);
			LSP2 := LCP^.IDTYPE
		      END
		      ELSE
			ERROR(2);
		      LSP := LSP2;
		      DIM := 1;
		      REPEAT
			WITH LSP1^ DO BEGIN
			  LSP2 := SUBSTRUCT;
			  SUBSTRUCT := LSP;
			  UNSPECLEVEL := DIM;
			  SIZE := 0
			END;
			DIM := DIM + 1;
			LSP := LSP1;
			LSP1 := LSP2;
		      UNTIL LSP1 = NIL;
		      PARSIZE := 2 * (DIM - 1)
		    END
		    ELSE IF SY = IDENT THEN BEGIN
		      SEARCHID([TYPES],LCP);
		      LSP := LCP^.IDTYPE;
		      IF (LSP <> NIL) AND (LKIND = ACTUAL) THEN BEGIN
			IF LSP^.FORM = FILES THEN
			  ERROR(121);
			PARSIZE := LSP^.SIZE
		      END
		      ELSE
			PARSIZE := 2;
		    END;
		    LCP3 := LCP2;
		    WHILE LCP2 <> NIL DO BEGIN
		      LCP2^.IDTYPE := LSP;
		      LCP := LCP2;
		      LCP2^.VADDR := PARSIZE;
		      (*VADDR TEMPORARILY CONTAINS THE SIZE  OF THE
		       PARAMETER  IN THE PARAMETERLIST *)
		      LCP2 := LCP2^.NEXT
		    END;
		    LCP^.NEXT := LCP1;
		    LCP1 := LCP3;
		    INSYMBOL;
		  END;
		  IF NOT (SY IN FSYS OR [SEMICOLON,RPARENT]) THEN BEGIN
		    ERROR(7);
		    SKIP(FSYS OR [SEMICOLON,RPARENT])
		  END
		END
		ELSE
		  ERROR(5);
	      END;
	    END;
	  END;
	  IF SY = SEMICOLON THEN BEGIN
	    INSYMBOL;
	    IF NOT (SY IN FSYS OR [IDENT,VARSY,PROCEDURESY,FUNCTIONSY])
	      THEN BEGIN
		ERROR(7);
		SKIP(FSYS OR [IDENT,RPARENT])
	      END
	  END
	END (*WHILE*);
	IF SY = RPARENT THEN BEGIN
	  INSYMBOL;
	  IF NOT (SY IN FSY OR FSYS) THEN BEGIN
	    ERROR(6);
	    SKIP(FSY OR FSYS)
	  END
	END
	ELSE
	  ERROR(4);
	LCP3 := NIL;
	(*REVERSE POINTERS   AND  ASSIGN ADDRESSES  TO THE PARAMETERS*)
	WHILE LCP1 <> NIL DO
	  WITH LCP1^ DO BEGIN
	    IF (KLASS = PROC) OR (KLASS = FUNC) THEN BEGIN
	      PFADDR := PARLC;
	      PARLC := PARLC + 4
	    END
	    ELSE BEGIN
	      PARSIZE := VADDR; (*KLASS = VARS*)
	      VADDR := PARLC;
	      PARLC := PARLC + PARSIZE;
	      IF (VKIND = ACTUAL) AND ( IDTYPE^.FORM = ARRAYS) THEN
		VADDR := VADDR - IDTYPE^.ADDRCORR
	    END;
	    LCP2 := NEXT;
	    NEXT := LCP3 ;
	    LCP3 := LCP1;
	    LCP1 := LCP2
	  END;
	FPAR := LCP3
      END
      ELSE
	FPAR := NIL
    END (* PARAMETERLIST *);


    PROCEDURE EXTERNALDECL(FCP:CTP) (*$Y+*);

    VAR
	LCP: CTP;

    BEGIN
      FCP^.DECLPLACE := EXTRNL;
      IF SY = LPARENT THEN
	WITH FCP^ DO BEGIN
	  INSYMBOL;
	  IF SY = IDENT THEN BEGIN
	    IF ID = 'ALTX      ' THEN
	      DECLPLACE := EXTERNALTX
	    ELSE IF ID = 'FORTRAN   ' THEN
	      DECLPLACE := EXTERNFORTRAN
	    ELSE
	      ERROR(399) ;
	    INSYMBOL;
	    IF SY = COMMA THEN
	      INSYMBOL
	    ELSE IF SY <> RPARENT THEN
	      ERROR(20);
	  END (* IF IDENT *);
	  IF SY = STRINGCONST THEN BEGIN
	    NEW(EXTNAME);
	    WITH VAL.VALP^ DO
	      FOR I := 0 TO ALFALENG-1 DO
		IF I > SLGTH THEN
		  EXTNAME^[I+1] := ' '
		ELSE
		  EXTNAME^[I+1] := SVAL[I];
	    INSYMBOL
	  END (* IF STRING *);
	  IF SY = RPARENT THEN
	    INSYMBOL
	  ELSE
	    ERROR(4);
	END (* IF LPARENT *)
      ELSE IF SY = IDENT THEN
	IF ID = 'FORTRAN   ' THEN BEGIN
	  INSYMBOL;
	  FCP^.DECLPLACE := EXTERNFORTRAN
	END;
      IF SY = SEMICOLON THEN
	INSYMBOL
      ELSE
	ERROR(14);
      IF NOT ( SY IN FSYS ) THEN BEGIN
	ERROR(6);
	SKIP(FSYS)
      END;
      LCP := FCP^.NEXT;
      IF FCP^.DECLPLACE = EXTERNFORTRAN THEN
	WHILE LCP <> NIL DO BEGIN
	  IF LCP^.VKIND <> FORMAL THEN
	    ERROR(182);
	  LCP^.VKIND := FORMAL;
	  LCP := LCP^.NEXT;
	  FCP^.PFLEV := 0;
	END;
    END (* EXTERNALDECL *);


    PROCEDURE FINDEXTNAME( FCP: CTP );

    LABEL
	1,
	99;

    VAR
	DOT,I: INTEGER;
	LCP: CTP;
	CH: CHAR;
	SLOW: ALFA;


      FUNCTION COMPSTR(S1,S2: ALFA): BOOLEAN;

      VAR
	  I: INTEGER;
	  B: BOOLEAN;

      BEGIN
	B:=TRUE;
	FOR I:=1 TO 6 DO
	  B := B AND ( S1[I]=S2[I] );
	COMPSTR := B;
      END (* COMPSTR *);


      FUNCTION COMP(FCP:CTP):BOOLEAN;

      LABEL
	  9,
	  99;

      BEGIN
	IF FCP = NIL THEN
	  COMP := FALSE
	ELSE IF NOT (FCP^.KLASS IN [PROC,FUNC]) THEN
	  GOTO 9
	ELSE IF COMPSTR(FCP^.NAME,SLOW) THEN
	  COMP := TRUE
	ELSE IF FCP^.PFDECKIND<>DECLARED THEN
	  GOTO 9
	ELSE IF FCP^.PFKIND<>ACTUAL THEN
	  GOTO 9
	ELSE IF FCP^.EXTNAME=NIL THEN
	  GOTO 9
	ELSE IF COMPSTR(FCP^.EXTNAME^,SLOW) THEN
	  COMP := TRUE
	ELSE
	  GOTO 9;
	GOTO 99;
	9:
	  IF COMP(FCP^.LLINK) THEN
	    COMP := TRUE
	  ELSE
	    COMP := COMP(FCP^.RLINK);
	99:
      END (* COMP *);

    BEGIN (* FINDEXTNAME *)
      SLOW := FCP^.NAME;
      DOT := 7;
      CH := ' ';
      1:
	FOR I := TOP DOWNTO 1 DO BEGIN
	  IF COMP(DISPLAY[I].FNAME) THEN BEGIN
	    IF DOT = 1 THEN BEGIN
	      ERROR(931);
	      GOTO 99
	    END
	    ELSE BEGIN
	      SLOW[DOT] := CH;
	      DOT := DOT-1;
	      CH := SLOW[DOT];
	      SLOW[DOT] := '.';
	      GOTO 1;
	    END
	  END (* IF COMP *)
	END (*FOR *);
      99:
	IF DOT = 7 THEN
	  FCP^.EXTNAME := NIL
	ELSE BEGIN
	  NEW(FCP^.EXTNAME);
	  FCP^.EXTNAME^ := SLOW;
	END;
    END (* FINDEXTNAME *);


    (*$Y+*)     (*   NEW MODULE   *)



  BEGIN (*PROCEDUREDECLARATION*)
    PARLC := 0;
    LLC := LC;
    IF ONSWITCH['D'] THEN
      LC := -4
    ELSE
      LC := -2;
    IF SY = IDENT THEN BEGIN
      SRCHSECTION(DISPLAY[TOP].FNAME,LCP); (*DECIDE WHETHER FORW.*)
      IF LCP <> NIL THEN BEGIN
	IF LCP^.KLASS = PROC THEN
	  FORW := (LCP^.DECLPLACE=FORWDECL) AND (FSY = PROCEDURESY) AND
	    (LCP^.PFKIND = ACTUAL)
	ELSE IF LCP^.KLASS = FUNC THEN
	  FORW := (LCP^.DECLPLACE=FORWDECL) AND (FSY = FUNCTIONSY) AND
	    (LCP^.PFKIND = ACTUAL)
	ELSE
	  FORW := FALSE;
	IF NOT FORW THEN
	  ERROR(160)
      END
      ELSE
	FORW := FALSE;
      IF NOT FORW THEN BEGIN
	IF FSY = PROCEDURESY THEN
	  NEW(LCP,PROC,DECLARED,ACTUAL)
	ELSE
	  NEW(LCP,FUNC,DECLARED,ACTUAL);
	WITH LCP^ DO BEGIN
	  NAME := ID;
	  IDTYPE := NIL;
	  NEXT := NIL;
	  FINDEXTNAME(LCP);
	  PFLEV := LEVEL;
	  PNOTUSED := TRUE;
	  PFADDR := 0;
	  DECLPLACE := INTERNAL;
	END;
	ENTERID(LCP)
      END;
      INSYMBOL
    END
    ELSE BEGIN
      ERROR(2);
      IF FSY = PROCEDURESY THEN
	LCP := UPRCPTR
      ELSE
	LCP := UFCTPTR;
    END;
    OLDLEV := LEVEL;
    OLDTOP := TOP;
    LEVEL := LEVEL + 1;
    IF TOP < DISPLIMIT THEN BEGIN
      TOP := TOP + 1;
      WITH DISPLAY[TOP] DO BEGIN
	IF FORW THEN
	  FNAME := LCP^.NEXT
	ELSE
	  FNAME := NIL;
	OCCUR := BLCK
      END
    END
    ELSE
      ERROR(250);
    IF FSY = PROCEDURESY THEN BEGIN
      PARAMTRLIST([SEMICOLON],LCP1);
      IF NOT FORW THEN
	LCP^.NEXT := LCP1
    END
    ELSE BEGIN
      PARAMTRLIST([SEMICOLON,COLON],LCP1);
      IF NOT FORW THEN
	LCP^.NEXT := LCP1;
      IF SY = COLON THEN BEGIN
	INSYMBOL;
	IF SY = IDENT THEN BEGIN
	  IF FORW THEN
	    ERROR(122);
	  SEARCHID([TYPES],LCP1);
	  LSP := LCP1^.IDTYPE;
	  LCP^.IDTYPE := LSP;
	  IF LSP <> NIL THEN
	    IF LSP^.FORM >= FILES THEN BEGIN
	      ERROR(120);
	      LCP^.IDTYPE := NIL
	    END;
	  INSYMBOL
	END
	ELSE BEGIN
	  ERROR(2);
	  SKIP(FSYS OR [SEMICOLON])
	END
      END
      ELSE IF NOT FORW THEN
	ERROR(123)
    END;
    IF NOT FORW THEN
      LCP^.PARLISTSIZE := PARLC;
    IF SY = SEMICOLON THEN
      INSYMBOL
    ELSE
      ERROR(14);
    IF STCLASS = EXTERNALSY THEN
      EXTERNALDECL (LCP)
    ELSE IF SY = FORWARDSY THEN BEGIN
      IF FORW THEN
	ERROR(161)
      ELSE
	LCP^.DECLPLACE := FORWDECL ;
      INSYMBOL;
      IF SY = SEMICOLON THEN
	INSYMBOL
      ELSE
	ERROR(14);
      IF NOT (SY IN FSYS) THEN BEGIN
	ERROR(6);
	SKIP(FSYS)
      END
    END
    ELSE IF SY = EXTERNSY THEN BEGIN
      IF STCLASS <> DEFAULTSY THEN
	ERROR (302);
      INSYMBOL;
      EXTERNALDECL(LCP)
    END
    ELSE BEGIN
      WITH LCP^ DO
	IF DECLPLACE = FORWDECL THEN
	  DECLPLACE := FORWFOUND ;
	BLOCK(FSYS,SEMICOLON,LCP);
	IF SY = SEMICOLON THEN BEGIN
	  INSYMBOL;
	  IF NOT (SY IN BLOCKBEGSYS) THEN BEGIN
	    ERROR(6);
	    SKIP(FSYS)
	  END
	END
	ELSE IF MAIN OR (LEVEL > 2) THEN
	  ERROR(14)
    END;
    LEVEL := OLDLEV;
    TOP := OLDTOP;
    LC := LLC;
  END (*PROCEDUREDECLARATION*);
  u0%,