PROCEDURE NEWPAGE;

BEGIN
  PAGENO := PAGENO + 1;
  PAGE(OUTPUT);
  WRITELN( 'PASCAL  PDP-11  VERSION ',HEADER,DATESTR:12,' ':6,TIMESTR:8,' ':10,
    ' PAGE ',PAGENO:3);
  WRITELN( FILENAME, ' ':4, OBJIDENT, ' ':4, PSECT );
  WRITELN;
  PAGEEJECT := FALSE;
  LINECNT := 0;
END (* NEWPAGE *);

PROCEDURE WTTERR( N: INTEGER );

EXTERN;

PROCEDURE WTTINT( N: INTEGER );

EXTERN;

PROCEDURE WTTEOL;

EXTERN;

PROCEDURE WTTSTAT( E: BOOLEAN; P,D,DD,T: INTEGER );

EXTERN;

PROCEDURE WTTHEAD( VAR HDR,DAY,TIM: ALFA );

EXTERN;

PROCEDURE COPYSTP ( SP: STP );

EXTERN;

PROCEDURE COPYCTP ( CP: CTP );

EXTERN;

PROCEDURE SAVEFDB ( VAR FDB: TEXTFDB; VAR F: TEXT; VAR FN : STR20 );

EXTERN;

PROCEDURE UNSAVEFDB ( VAR F: TEXT; VAR FDB: TEXTFDB );

EXTERN;

PROCEDURE ERRMES ( N: INTEGER );

EXTERN;

PROCEDURE HEAPMARK( VAR M: INTP );

EXTERN;

PROCEDURE HEAPRELEASE( M: INTP );

EXTERN;

PROCEDURE ENDOFLINE;

VAR
    LASTPOS,FREEPOS,CURRPOS,CURRNMR,F,K: INTEGER;

BEGIN
  IF ERRINX > 0 THEN (*OUTPUT ERROR MESSAGES*)
  BEGIN
    WTTERR( LINENO );
    FOR K := 1 TO ERRINX DO BEGIN
      WTTINT(ERRLIST[K].NMR);
      IF ERRLIST[K].NMR<900 THEN
	ERRDETECTED := TRUE
    END;
    WTTEOL;
    IF LIST THEN BEGIN
      WRITELN;
      WRITE('*****  ');
      IF PRCODE THEN
	WRITE(' ':9);
      LASTPOS := 0;
      FREEPOS := 1;
      FOR K := 1 TO ERRINX DO BEGIN
	WITH ERRLIST[K] DO BEGIN
	  CURRPOS := POS;
	  CURRNMR := NMR
	END;
	IF CURRPOS = LASTPOS THEN
	  WRITE(',')
	ELSE BEGIN
	  WHILE FREEPOS < CURRPOS DO BEGIN
	    WRITE(' ');
	    FREEPOS := FREEPOS + 1
	  END;
	  WRITE('^');
	  LASTPOS := CURRPOS
	END;
	IF CURRNMR < 10 THEN
	  F := 1
	ELSE IF CURRNMR < 100 THEN
	  F := 2
	ELSE
	  F := 3;
	WRITE(CURRNMR:F);
	FREEPOS := FREEPOS + F + 1 ;
      END;
      WRITELN;
      LINECNT := LINECNT + 2;
    END (* IF LIST *);
    ERRINX := 0;
  END;
  IF LIST THEN BEGIN
    WRITELN;
    IF (LINECNT > PAGEWIDTH) OR PAGEEJECT THEN
      NEWPAGE;
    IF PRCODE THEN
      IF DP THEN
	WRITE('-',-LC:6:O,'  ')
      ELSE
	WRITE(2 * CIX + 2:6:O,'   ');
  END;
  LINECNT := LINECNT + 1;
  CHCNT := 0;
  IF SRCLEVEL >= 0 THEN
    IF EOLN (INPUT) THEN BEGIN
      LOOP
	READLN;
      EXIT IF NOT EOF(INPUT);
	IF SRCLEVEL > 0 THEN
	  WITH SRCNEST[SRCLEVEL] DO BEGIN
	    CLOSEINCLUDE;
	    FILENAME := FNAME;
	    SRCLEVEL := SRCLEVEL - 1;
	    LINENO := LINNR;
	    NEWPAGE
	  END
	ELSE BEGIN
	  WRITELN('*****   EOF   *****');
	  ERRMES ( 4 (* AND EXIT *));
	END
      END;
      LINENO := LINENO + 1;
      IF LIST THEN
	WRITE( LINENO:5,'   ');
    END
    ELSE IF LIST THEN BEGIN
      WRITE(' ':20);
      CHCNT := CHCNT + 12;
    END;
END (*ENDOFLINE*);

PUBLIC PROCEDURE ERROR(FERRNR: INTEGER);

BEGIN
  IF WARNINGS OR (FERRNR < 900) THEN BEGIN
    IF ERRINX >= 9 THEN BEGIN
      ERRLIST[10].NMR := 255;
      ERRINX := 10
    END
    ELSE BEGIN
      ERRINX := ERRINX + 1;
      ERRLIST[ERRINX].NMR := FERRNR
    END;
    ERRLIST[ERRINX].POS := CHCNT
  END (* WARNINGS *)
END (*ERROR*);

PROCEDURE INSYMBOL;
(*READ NEXT BASIC SYMBOL OF SOURCE PROGRAM AND RETURN ITS
 DESCRIPTION IN THE GLOBAL VARIABLES SY, OP, ID, VAL AND LGTH*)

LABEL
    1,
    2, 900;

CONST
    DIGMAX = 9;

VAR
    I,J,K,SCALE,EXP,IVAL: INTEGER;
    S: STRING;
    MANT,RVAL,R,FAC: REAL;
    CASECONV,STAR,SIGN,OLDLIST: BOOLEAN;
    DIGIT: ARRAY [1..DIGMAX] OF 0..9;
    STRING: ARRAY [0..MAXSTRGUB] OF CHAR;
    LVP: CSP;
    BINEXP, SGN: INTEGER;


  PROCEDURE NEXTCH;

  VAR
      ORDCH: 0..255;

  BEGIN
    IF EOLN(INPUT) THEN
      CH :=' '
    ELSE BEGIN
      READ(CH);
      ORDCH := ORD(CH) ;
      IF ORDCH > 127 THEN BEGIN
	ORDCH := ORDCH - 128;
	CH := CHR(ORDCH)
      END;
      IF ORDCH = 12 (*FF*)THEN
	PAGEEJECT := TRUE;
      IF ORDCH < 32 THEN
	CH := ' ';
      IF LIST THEN BEGIN
	IF ORDCH = 9 (*TAB*)THEN BEGIN
	  ORDCH := 7-CHCNT MOD 8;
	  WRITE('        ':ORDCH);
	  CHCNT := CHCNT + ORDCH;
	END;
	WRITE(CH);
      END;
      CHCNT := CHCNT + 1;
      IF (ORDCH > 95) AND CASECONV THEN
	CH := CHR( ORDCH - 32 );
    END
  END;


  (*$Y+*)     (*   NEW MODULE   *)



  PROCEDURE OPTIONS;

  VAR
      LCH: CHAR;
      B: BOOLEAN;
      S: PACKED ARRAY[1..6] OF CHAR;
      III: INTEGER;

  BEGIN
    REPEAT
      NEXTCH;
      LCH := CH;
      NEXTCH;
      IF NOT (CH IN ['+','-']) THEN
	ERROR(902)
      ELSE BEGIN
	IF LCH IN ['A'..'Z'] THEN
	  B := (CH = '+') AND NOT OFFSWITCH[LCH] OR ONSWITCH[LCH]
	ELSE
	  B := FALSE;
	CASE LCH OF
	  'C': BEGIN
	    PRCODE := B;
	    (*$Z+*)
	    IF PRCODE THEN
	      IF CXPOPENED THEN BEGIN
		WRITELN(CEX);
		WRITELN(CEX,';************');
		WRITELN(CEX)
	      END
	      ELSE BEGIN
		CXPOPENED := TRUE;
		FOR III := 1 TO 6 DO
		  S[III] := FILENAME[III-1];
		REWRITE (CEX,S || '.CEX');
	      END
	      (*$Z-*)
	  END;
	  'E','F', 'G','M','N':
	    IF B THEN
	      ONSWITCH[LCH]:=TRUE
	    ELSE
	      OFFSWITCH[LCH]:=TRUE;
	  'P':
	    PAGEEJECT := B;
	  'T':
	    HEAPCHECK := B;
	  'L':
	    LIST := B;
	  'V': BEGIN
	    I := 1;
	    NEXTCH;
	    WHILE (CH IN LETTERS OR DIGITS) AND (I < 7) DO BEGIN
	      OBJIDENT[I] := CH;
	      I := I + 1;
	      NEXTCH
	    END
	  END;
	  'W':
	    WARNINGS := B;
	  'S':
	    TRACE := B;
	  'Q':
	    FREQUENCE := B AND NOT NOIO;
	  'D':
	    DEBUG := B;
	  'H': BEGIN
	    SELECTOR := 0;
	    NEXTCH;
	    ONSWITCH['H'] := TRUE;
	    WHILE CH IN DIGITS DO BEGIN
	      SELECTOR := SELECTOR*10 + ORD(CH) - ORD('0');
	      NEXTCH;
	    END
	  END;
	  'X':
	    CONDCOMP := CH = '-';
	  'I': BEGIN
	    ERROR (303); (* USE $INCLUDE *)
	    IF SRCLEVEL = SRCNESTMAX THEN
	      ERROR ( 940 )
	    ELSE BEGIN
	      SRCLEVEL := SRCLEVEL + 1;
	      WITH SRCNEST[SRCLEVEL] DO BEGIN
		FNAME := FILENAME;
		LINNR := LINENO;
		SAVEFDB ( FDB, INPUT, FILENAME );
		IF FDB[-19] = 0 THEN BEGIN
		  FILENAME := FNAME;
		  SRCLEVEL := SRCLEVEL - 1;
		END
		ELSE BEGIN
		  PAGEEJECT := TRUE;
		  LINENO := 0;
		END
	      END
	    END;
	  END;
	  'Y':
	    PSECTGEN := B ;
	  'Z':
	    IF CONDCOMP THEN BEGIN
	      OLDLIST := LIST;
	      LIST := FALSE;
	      CONDCOMP := FALSE;
	      REPEAT
		WHILE CH <> '$' DO
		  IF EOLN(INPUT) THEN
		    ENDOFLINE 
		  ELSE
		    NEXTCH;
		NEXTCH;
		IF CH = 'Z' THEN BEGIN
		  NEXTCH;
		  IF CH = '-' THEN
		    CONDCOMP := TRUE
		END;
	      UNTIL CONDCOMP;
	      LIST := OLDLIST
	    END;
	  'R':
	    RUNTMCHECK := B
	END;
      END;
      IF EOLN(INPUT) THEN
	ENDOFLINE ;
      IF NOT ( CH IN ['\','*'] ) THEN
	NEXTCH;
    UNTIL CH <> ','
  END (*OPTIONS*);

  (*$Y+*)     (*   NEW MODULE   *)


BEGIN (*INSYMBOL*)
  CASECONV := TRUE ;
  1:
    IF CHCNT > LINEWIDTH THEN
      ENDOFLINE ;
  LOOP
    WHILE CH = ' ' DO BEGIN
      IF EOLN(INPUT) OR (CHCNT > LINEWIDTH) THEN
	ENDOFLINE ;
      NEXTCH
    END EXIT IF CH <> '%';
    NEXTCH;
    IF CH = OPTIONCONSTR THEN
      OPTIONS;
    LOOP
      IF EOLN(INPUT) OR (CHCNT > LINEWIDTH) THEN
	ENDOFLINE ;
    EXIT IF CH = '\';
      NEXTCH
    END;
    NEXTCH
  END;
  CASE CH OF
    'A','B','C','D','E','F','G','H','I', 'J','K','L','M','N','O','P','Q','R',
      'S','T','U','V','W','X','Y','Z': BEGIN
	K := 0;
	REPEAT
	  IF K < ALFALENG THEN BEGIN
	    K := K + 1;
	    ID[K] := CH
	  END ;
	  NEXTCH
	UNTIL NOT (CH IN IDENTCHARS);
	IF K >= KK THEN
	  KK := K
	ELSE
	  REPEAT
	    ID[KK] := ' ';
	    KK := KK - 1
	  UNTIL KK = K;
	FOR I := FRW[K] TO FRW[K+1] - 1 DO
	  IF RW[I] = ID THEN BEGIN
	    SY := RSY[I];
	    OP := ROP[I];
	    GOTO 2
	  END;
	SY := IDENT;
	OP := NOOP;
	2:
      END;
    '0','1','2','3', '4','5','6', '7','8','9': BEGIN
      SY := INTCONST;
      OP := NOOP;
      I := 0;
      REPEAT
	I := I + 1;
	IF I <= DIGMAX THEN
	  DIGIT[I] := ORD(CH) - ORD('0');
	NEXTCH
      UNTIL NOT (CH IN DIGITS);
      IF I > DIGMAX THEN BEGIN
	ERROR(203);
	I:= DIGMAX
      END;
      IVAL := 0;
      RVAL := 0;
      IF CH = 'B' THEN BEGIN
	IF (I>6) OR ((I=6) AND (DIGIT[1]>1)) THEN BEGIN
	  ERROR(203);
	  IVAL := 0
	END
	ELSE
	  FOR K := 1 TO I DO BEGIN
	    IF DIGIT[K] > 7 THEN
	      ERROR(204);
	    IVAL := 8*IVAL + DIGIT[K];
	  END;
	VAL.IVAL := IVAL;
	NEXTCH
      END
      ELSE BEGIN
	SCALE := 0;
	IF CH = '.' THEN BEGIN
	  NEXTCH;
	  IF CH = '.' THEN
	    CH := ':'
	  ELSE IF CH = ')' THEN
	    CH := ']'
	  ELSE BEGIN
	    FOR K := 1 TO I DO
	      RVAL := RVAL*10E0+DIGIT[K];
	    SY := REALCONST;
	    IF NOT (CH IN DIGITS) THEN
	      ERROR(201)
	    ELSE
	      REPEAT
		RVAL := 10E0*RVAL + (ORD(CH) - ORD('0'));
		SCALE := SCALE - 1;
		NEXTCH
	      UNTIL NOT (CH IN DIGITS)
	  END
	END;
	IF CH = 'E' THEN BEGIN
	  IF SCALE = 0 THEN BEGIN
	    FOR K := 1 TO I DO
	      RVAL := RVAL * 10E0 + DIGIT[K];
	    SY := REALCONST
	  END;
	  SIGN := FALSE;
	  NEXTCH;
	  IF CH = '+' THEN
	    NEXTCH
	  ELSE IF CH = '-' THEN BEGIN
	    SIGN := TRUE;
	    NEXTCH
	  END;
	  EXP := 0;
	  IF NOT (CH IN DIGITS) THEN
	    ERROR(201)
	  ELSE
	    REPEAT
	      EXP := 10*EXP + (ORD(CH) - ORD('0'));
	      NEXTCH
	    UNTIL NOT (CH IN DIGITS);
	  IF SIGN THEN
	    SCALE := SCALE - EXP
	  ELSE
	    SCALE := SCALE + EXP
	END;
	IF SCALE <> 0 THEN BEGIN
	  R := 1E0; (*NOTE POSSIBLE OVERFLOW OR UNDERFLOW*)
	  IF SCALE < 0 THEN BEGIN
	    FAC := 0.1;
	    SCALE := -SCALE
	  END
	  ELSE
	    FAC := 10E0;
	  REPEAT
	    IF ODD(SCALE) THEN
	      R := R*FAC;
	    FAC := SQR(FAC);
	    SCALE := SCALE DIV 2
	  UNTIL SCALE = 0; (*NOW R = 10^SCALE*)
	  RVAL := RVAL*R
	END;
	IF SY = INTCONST THEN BEGIN
	  IF I > 4 THEN
	    J := 4
	  ELSE
	    J := I;
	  FOR K := 1 TO J DO
	    IVAL := 10 * IVAL + DIGIT[K];
	  IF (I<5) OR (((I=5) AND (IVAL<3276)) OR ((I=5) AND (IVAL=3276) AND
	    (DIGIT[5]<8))) THEN BEGIN
	      IF I = 5 THEN
		IVAL := 10*IVAL + DIGIT[5];
	      VAL.IVAL := IVAL
	    END
	    ELSE BEGIN
	      ERROR(203);
	      IVAL := 0
	    END
	END
	ELSE BEGIN
	  NEW(LVP,REEL);
	  VAL.VALP := LVP;
	  LVP^.RVAL := RVAL;
	  BINEXP := 0;
	  IF RVAL < 0E0 THEN BEGIN
	    SGN := 100000B;
	    RVAL := -RVAL
	  END
	  ELSE
	    SGN := 0;
	  IF RVAL = 0E0 THEN
	    MANT := 0E0
	  ELSE BEGIN
	    WHILE RVAL < 8388608E0 DO BEGIN
	      RVAL := RVAL * 2E0;
	      BINEXP := BINEXP - 1
	    END;
	    WHILE RVAL > 16777216E0 DO BEGIN
	      RVAL := RVAL/2E0;
	      BINEXP := BINEXP + 1
	    END;
	    BINEXP := BINEXP + 24;
	    MANT := RVAL;
	  END;
	  IF (BINEXP < -128) OR (BINEXP > 127) THEN BEGIN
	    ERROR(205);
	    MANT := 0E0
	  END;
	  WITH LVP^ DO BEGIN
	    IF MANT = 0E0 THEN BEGIN
	      HEAD := 0;
	      TAIL := 0
	    END
	    ELSE BEGIN
	      TAIL := TRUNC(MANT-TRUNC(MANT/32768E0)*32768E0);
	      HEAD := TRUNC((MANT-8388608E0)/65536E0) + 128 * (BINEXP + 128)
		+ SGN ;
	      IF ODD(TRUNC(MANT/32768E0)) THEN
		TAIL := TAIL + 100000B
	    END;
	  END
	END
      END
    END;
    '''': BEGIN
      LGTH := 0;
      SY := STRINGCONST;
      OP := NOOP;
      REPEAT
        CASECONV := FALSE ;
	REPEAT
	  NEXTCH;
	  STRING[LGTH] := CH;
	  LGTH := LGTH + 1
	UNTIL EOLN(INPUT) OR (CH = '''');
        CASECONV := TRUE;
	IF EOLN(INPUT) AND (CH <> '''') THEN
	  ERROR(202)
	ELSE
	  NEXTCH
      UNTIL CH <> '''';
      LGTH := LGTH - 1; (*NOW LGTH = NR OF CHARS IN STRING*)
      IF LGTH = 1 THEN
	VAL.IVAL := ORD(STRING[0])
      ELSE BEGIN
	NEW(LVP,STRG:LGTH-1);
	WITH LVP^ DO BEGIN
	  SLGTH := LGTH-1;
	  FOR I := 0 TO SLGTH DO
	    SVAL[I] := STRING[I]
	END;
	VAL.VALP := LVP
      END
    END;
    ':': BEGIN
      OP := NOOP;
      NEXTCH;
      IF CH = '=' THEN BEGIN
	SY := BECOMES;
	NEXTCH
      END
      ELSE
	SY := COLON
    END;
    '.': BEGIN
      OP := NOOP;
      NEXTCH;
      IF CH = '.' THEN BEGIN
	SY := COLON;
	NEXTCH
      END
      ELSE IF CH = ')' THEN BEGIN
	SY:=RBRACK;
	NEXTCH
      END
      ELSE
	SY := PERIOD
    END;
    '(': BEGIN
      NEXTCH;
      IF CH = '*' THEN BEGIN
	NEXTCH;
	IF CH = OPTIONCONSTR THEN
	  OPTIONS;
	LOOP
	  IF EOLN(INPUT) OR (CHCNT > LINEWIDTH) THEN
	    ENDOFLINE ;
	  STAR := CH = '*';
	  WHILE CH = '*' DO
	    NEXTCH;
	EXIT IF STAR AND ( CH = ')' ) ;
	  NEXTCH;
	END;
	NEXTCH;
	GOTO 1;
      END
      ELSE BEGIN
	IF CH = '.' THEN BEGIN
	  SY:= LBRACK;
	  OP := NOOP;
	  NEXTCH
	END
	ELSE BEGIN
	  SY := LPARENT;
	  OP := NOOP
	END
      END;
    END;
    '$': 
      IF CHCNT <> 1 THEN GOTO 900
      ELSE BEGIN
	S := '';
	NEXTCH;
	WHILE NOT EOLN (INPUT) AND (CH IN ['A'..'Z']) DO BEGIN
	  S := S || CH;
	  NEXTCH;
	END;
	IF S = 'INCLUDE' THEN BEGIN
	  IF SRCLEVEL = SRCNESTMAX THEN ERROR (940)
	  ELSE BEGIN
	    SRCLEVEL := SRCLEVEL + 1;
	    WITH SRCNEST[SRCLEVEL] DO BEGIN
	      FNAME := FILENAME;
	      LINNR := LINENO;
	      S := '';
	      REPEAT
		NEXTCH;
		S := S || CH;
	      UNTIL EOLN (INPUT);
	      IF INCLUDE (S) THEN BEGIN
		FOR I := 1 TO LENGTH(S) DO
		  FILENAME[I-1] := S[I];
		FOR I := LENGTH(S) TO 20 DO
		  FILENAME[I] := ' ';
		CH := ' ';
		IF LIST THEN BEGIN
		  WRITELN;
		  NEWPAGE;
		  IF PRCODE THEN
		    IF DP THEN WRITE ('-',-LC:6:O)
		    ELSE WRITE (2*CIX+2:6:O);
		END;
		LINECNT := LINECNT+1;
		CHCNT := 0;
		LINENO := 1;
		IF LIST THEN WRITE ('    1   ');
		GOTO 1;
	      END
	      ELSE BEGIN
		ERROR (304);
		SRCLEVEL := SRCLEVEL - 1;
	      END
	    END
	  END
	END
	ELSE ERROR (305);
	WHILE NOT EOLN (INPUT) DO NEXTCH;
	CH := ' ';
	GOTO 1;
      END;
    '?','*','/','&','+','-','\', '@','"','#','=','!', ')','[',']',',',';','^',
      '_': BEGIN
	900: SY := SSY[CH];
	OP := SOP[CH];
	NEXTCH
      END;
    '<','>': BEGIN
      SY := SSY[CH];
      OP := SOP[CH];
      NEXTCH;
      IF CH = '=' THEN BEGIN
	IF OP = LTOP THEN
	  OP := LEOP
	ELSE
	  OP := GEOP;
	NEXTCH
      END
      ELSE IF ( CH = '>' ) AND ( OP = LTOP ) THEN BEGIN
	OP := NEOP ;
	NEXTCH
      END
    END;
    OTHERS: BEGIN
      ERROR(6);	(* ILLEGAL SYMBOL *)
      NEXTCH;
      GOTO 1
    END
  END (*CASE*)
END (*INSYMBOL*);

PROCEDURE ENTERID(FCP: CTP);
(*ENTER ID POINTED AT BY FCP INTO THE NAME-TABLE,
 WHICH ON EACH DECLARATION LEVEL IS ORGANISED AS
 AN UNBALANCED BINARY TREE*)

VAR
    NAM: ALFA;
    LCP, LCP1: CTP;
    LLEFT: BOOLEAN;

BEGIN
  NAM := FCP^.NAME;
  FCP^.SELFCTP := 0;
  LCP := DISPLAY[TOP].FNAME;
  IF LCP = NIL THEN
    DISPLAY[TOP].FNAME := FCP
  ELSE BEGIN
    REPEAT
      LCP1 := LCP;
      IF LCP^.NAME = NAM THEN (*NAME CONFLICT, FOLLOW RIGHT LINK*)
      BEGIN
	ERROR(101);
	LCP := LCP^.RLINK;
	LLEFT := FALSE
      END
      ELSE IF LCP^.NAME < NAM THEN BEGIN
	LCP := LCP^.RLINK;
	LLEFT := FALSE
      END
      ELSE BEGIN
	LCP := LCP^.LLINK;
	LLEFT := TRUE
      END
    UNTIL LCP = NIL;
    IF LLEFT THEN
      LCP1^.LLINK := FCP
    ELSE
      LCP1^.RLINK := FCP
  END;
  FCP^.LLINK := NIL;
  FCP^.RLINK := NIL
END (*ENTERID*);

PROCEDURE SRCHSECTION(FCP: CTP; VAR FCP1: CTP);
(*TO FIND RECORD FIELDS AND FORWARD DECLARED PROCEDURE ID'S
 --> PROCEDURE PROCEDUREDECLARATION
 --> PROCEDURE SELECTOR*)

LABEL
    1;

BEGIN
  WHILE FCP <> NIL DO
    IF FCP^.NAME = ID THEN
      GOTO 1
    ELSE IF FCP^.NAME < ID THEN
      FCP := FCP^.RLINK
    ELSE
      FCP := FCP^.LLINK;
  1:
    FCP1 := FCP
END (*SEARCHSECTION*);

PROCEDURE SEARCHID(FIDCLS: SETOFIDS; VAR FCP: CTP);

LABEL
    1;

VAR
    LCP: CTP;

BEGIN
  FOR DISX := TOP DOWNTO 0 DO BEGIN
    LCP := DISPLAY[DISX].FNAME;
    WHILE LCP <> NIL DO
      IF LCP^.NAME = ID THEN
	IF LCP^.KLASS IN FIDCLS THEN
	  GOTO 1
	ELSE BEGIN
	  IF PRTERR THEN
	    ERROR(103);
	  LCP := LCP^.RLINK
	END
      ELSE IF LCP^.NAME < ID THEN
	LCP := LCP^.RLINK
      ELSE
	LCP := LCP^.LLINK
  END;
  (*SEARCH NOT SUCCSESSFUL; SUPPRESS ERROR MESSAGE IN CASE
   OF FORWARD REFERENCED TYPE ID IN POINTER TYPE DEFINITION
   --> PROCEDURE SIMPLETYPE*)
  IF PRTERR THEN BEGIN
    ERROR(104);
    (*TO AVOID RETURNING NIL, REFERENCE AN ENTRY
     FOR AN UNDECLARED ID OF APPROPRIATE CLASS
     --> PROCEDURE ENTERUNDECL*)
    IF TYPES IN FIDCLS THEN
      LCP := UTYPPTR
    ELSE IF VARS IN FIDCLS THEN
      LCP := UVARPTR
    ELSE IF FIELD IN FIDCLS THEN
      LCP := UFLDPTR
    ELSE IF KONST IN FIDCLS THEN
      LCP := UCSTPTR
    ELSE IF PROC IN FIDCLS THEN
      LCP := UPRCPTR
    ELSE
      LCP := UFCTPTR;
  END;
  1:
    FCP := LCP
END (*SEARCHID*);

PROCEDURE GETBOUNDS(FSP: STP; VAR FMIN,FMAX: INTEGER);
(*GET INTERNAL BOUNDS OF SUBRANGE OR SCALAR TYPE*)
(*ASSUME (FSP <> NIL) AND (FSP^.FORM  <=   SUBRANGE) AND (FSP <> INTPTR)
     AND  NOT COMPTYPES(REALPTR,FSP)*)

BEGIN
  WITH FSP^ DO
    IF FORM = SUBRANGE THEN BEGIN
      FMIN := MIN.IVAL;
      FMAX := MAX.IVAL
    END
    ELSE BEGIN
      FMIN := 0;
      IF FSP = CHARPTR THEN BEGIN
	FMIN := 40B;
	FMAX := 140B
      END
      ELSE IF FSP = INTPTR THEN
	FMAX := 0
      ELSE IF FSP^.FCONST <> NIL THEN
	FMAX := FSP^.FCONST^.VALUES.IVAL
      ELSE
	FMAX := 0
    END
END (*GETBOUNDS*);
   