C     PROGRAM SLR1 -- PARSER GENERATOR PROGRAM
C
      INTEGER HEADER (18)
      COMMON /PRHEAD/ HEADER
      COMMON /LUNITS/ LUI, LUO, LUP
      INTEGER PRFLAG (10)
      INTEGER SPACE
C
C***********************************************************************
C
C     PDP-10 SPECIFIC CODE
C
      DOUBLE PRECISION FNAME
      TYPE 9901
 9901 FORMAT (' INPUT FILE?')
      ACCEPT 9902, FNAME
 9902 FORMAT (A10)
      OPEN ( UNIT=LUI, ACCESS='SEQIN', DEVICE = 'DSK', FILE=FNAME )
      TYPE 9903
 9903 FORMAT (' LISTING FILE?')
      ACCEPT 9902, FNAME
      OPEN ( UNIT=LUO, ACCESS='SEQOUT', DEVICE = 'DSK', FILE=FNAME )
      TYPE 9904
 9904 FORMAT (' OUTPUT FILE?')
      ACCEPT 9902, FNAME
      OPEN ( UNIT=LUP, ACCESS='SEQOUT', DEVICE = 'DSK', FILE=FNAME )
C
C***********************************************************************
C
      DATA SPACE /1H /
C
C
      READ (LUI,1000) HEADER, PRFLAG
 1000 FORMAT (18A4 / 10I2)
      ISP = ICHR(SPACE,1)
      DO 10 I = 1,72
	 I1 = 73 - I
	 IF (ICHR(HEADER,I1) .NE. ISP) GO TO 20
   10 CONTINUE
      GO TO 50
   20 CONTINUE
	 IS = I / 2
	 IF (IS .EQ. 0) GO TO 50
	 DO 30 I = 1,I1
	    I2 = I1 + 1 - I
	    I3 = I2 + IS
	 CALL SETCHR (HEADER,I3,ICHR(HEADER,I2))
   30	 CONTINUE
	 DO 40 I = 1,IS
	 CALL SETCHR (HEADER,I,ISP)
   40	 CONTINUE
   50 CONTINUE
C
      CALL INPUT
      IF (PRFLAG(1) .EQ. 0) CALL INPRNT
      CALL STATES
      IF (PRFLAG(2) .EQ. 1) CALL STPRNT
      CALL FOLLOW
      IF (PRFLAG(3) .EQ. 1) CALL PRFT1
      CALL PARSER
      IF (PRFLAG(4) .NE. 1) GO TO 110
	 WRITE (LUO,2100) HEADER
 2100	 FORMAT (1H1,41X,38HSLR(1) ANALYSER -- BASIC PARSER TABLES,/
     +		 1H0,24X,18A4,/)
	 CALL PAPRNT
  110 CONTINUE
      CALL PARCHK (PRFLAG)
      CALL ORDERC
      CALL DELCHN
      IF (PRFLAG(5) .EQ. 0) GO TO 120
	 WRITE (LUO,2200) HEADER
 2200	 FORMAT (1H1,40X,39HSLR(1) ANALYSER -- AFTER CHAIN DELETION,/
     +		 1H0,24X,18A4,/)
	 CALL PAPRNT
  120 CONTINUE
      CALL TDEF
      CALL GDEF
      IF (PRFLAG(6) .EQ. 0) GO TO 130
	 WRITE (LUO,2300) HEADER
 2300	 FORMAT (1H1,40X,39HSLR(1) ANALYSER -- WITH DEFAULT ACTIONS,/
     +		 1H0,24X,18A4,/)
	 CALL PAPRNT
  130 CONTINUE
	 CALL TDUP
	 CALL GDUP
      IF (PRFLAG (7) .NE. 0) GO TO 140
	 WRITE (LUO,2400) HEADER
 2400	 FORMAT (1H1,44X,31HSLR(1) ANALYSER -- FINAL PARSER,/
     +		 1H0,24X,18A4)
	   CALL PAPRNT
  140 CONTINUE
      IF (PRFLAG(8) .EQ. 0) CALL PUNCH
      STOP
      END
      BLOCK DATA
C
      COMMON /TEMPS/ TVARS(1000)
      COMMON /LOOK/ LVARS(1400)
      COMMON /LUNITS/ LUI, LUO, LUP
      INTEGER STATE(500,3), MAXST, NST, ITEM(5000), MAXIT
      COMMON /IGTAB/ STATE, MAXST, NST, ITEM, MAXIT
      INTEGER NRST, PARSE(500,2), GOTO(200,2), ACT(2000,2), MAXACT
      COMMON /PTABLE/ NRST, PARSE, GOTO, ACT, MAXACT
C
      DATA LUI/5/, LUO/6/, LUP/7/
      DATA MAXST/500/, MAXIT/5000/
      DATA MAXACT/2000/
      END
      SUBROUTINE INPUT
      INTEGER CARDNO, NCH, CARD(20)
      COMMON /IN/ CARDNO, NCH, CARD
      INTEGER NSYMBS, NTERMS, SYMBS(2,200)
      COMMON /SYMBOL/ NSYMBS, NTERMS, SYMBS
      INTEGER NPRODS, LHS(200), PLEN(200), RHS(8,200)
      COMMON /PRODCT/ NPRODS, LHS, PLEN, RHS
      LOGICAL CHAIN(200)
      COMMON /CHNPRD/ CHAIN
      INTEGER HEADER (18)
      COMMON /PRHEAD/ HEADER
      COMMON /LUNITS/ LUI, LUO, LUP
      INTEGER ACCEPT(2), ENDMRK(2)
      DATA ACCEPT/4H* AC,4HCEPT/, ENDMRK/4H* EN,4HD   /
C
      CARDNO = 0
      NCH = 0
      NSYMBS = 1
      NTERMS = 1
      SYMBS(1,1) = ACCEPT(1)
      SYMBS(2,1) = ACCEPT(2)
      DO 10 I = 1,200
      DO 10 J = 1,8
   10 RHS(J,I) = 0
      NPRODS = 1
      LHS(1) = 1
      PLEN(1) = 1
      RHS(1,1) = 2
      CHAIN(1) = .FALSE.
C
      WRITE (LUO,1000) HEADER
 1000 FORMAT (1H1,44X,32HSLR(1) ANALYSER -- INPUT LISTING,/
     +	      1H0,24X,18A4,//)
      CALL RDPROD
      NSYMBS = NSYMBS + 1
      SYMBS(1,NSYMBS) = ENDMRK(1)
      SYMBS(2,NSYMBS) = ENDMRK(2)
      RETURN
      END
      SUBROUTINE RDPROD
C
C***********************************************************************
C
C	 THIS SUBROUTINE READS IN THE SET OF PRODUCTIONS FROM THE INPUT
C     UNIT.  NPRODS WILL BE THE NUMBER OF PRODUCTIONS, LHS(I) WILL BE
C     THE LEFT HAND SIDE OF THE I-TH PRODUCTION, AND RHS(1,I), . . .
C     RHS(PLEN(I),I) WILL BE THE SYMBOLS IN THE RIGHT HAND SIDE OF THE
C     I-TH PRODUCTION (PLEN(I) .LE. 8).  EACH PRODUCTION MUST BEGIN
C     ON A NEW LINE, AND AN EOL SYMBOL (-1) IS RECOGNIZED AS THE END
C     OF A PRODUCTION.	A BLANK LINE (THAT IS, AN EOL NOT PRECEDED BY A
C     SYMBOL) IS RECOGNIZED AS THE END OF THE PRODUCTIONS.
C
C***********************************************************************
C
      INTEGER NPRODS, LHS(200), PLEN(200), RHS(8,200)
      COMMON /PRODCT/ NPRODS, LHS, PLEN, RHS
      INTEGER NSYMBS, NTERMS, SYMBS(2,200)
      COMMON /SYMBOL/ NSYMBS, NTERMS, SYMBS
      LOGICAL CHAIN(200)
      COMMON /CHNPRD/ CHAIN
      COMMON /LUNITS/ LUI, LUO, LUP
      INTEGER SYM
      LOGICAL NIL
C
   10 CONTINUE
	 NIL = .FALSE.
   14	 CALL RDSYM (SYM)
	 IF (SYM .EQ. -1) GO TO 10
	 IF (SYM .EQ. -2) RETURN
	 IF (SYM .NE. -3) GO TO 16
	    NIL = .TRUE.
	    GO TO 14
   16	 CALL NTRMNL (SYM)
	 NPRODS = NPRODS + 1
	 IF (NPRODS .LE. 200) GO TO 20
	    WRITE (LUO,1000)
 1000	    FORMAT (36H0***  PRODUCTION TABLE OVERFLOW	***,///)
	    STOP
   20	 LHS(NPRODS) = SYM
	 CALL RDSYM (SYM)
	 DO 40 LEN = 1,9
	    IF (SYM .EQ. -1) GO TO 50
	    IF (SYM .LT. -1) GO TO 60
	    RHS(LEN,NPRODS) = SYM
	    CALL RDSYM (SYM)
   40	 CONTINUE
	 WRITE (LUO,2000)
 2000	 FORMAT (35H0***  RIGHT HAND SIDE TOO LONG  ***,///)
	 STOP
   50	 CONTINUE
	 PLEN(NPRODS) = LEN - 1
	 CHAIN(NPRODS) = NIL .AND. (PLEN(NPRODS).EQ.1)
      GO TO 10
C
   60 CONTINUE
      WRITE (LUO,3000)
 3000 FORMAT (50H0***  $$NIL OR $$END NOT FIRST SYMBOL ON CARD	***,///)
      STOP
      END
      SUBROUTINE RDSYM (NUM)
C
C***********************************************************************
C
C	 THIS SUBROUTINE USES RDCHAR TO SCAN THE INPUT FILE UNTIL IT
C     FINDS A NON-BLANK CHARACTER OR EOL.  AN EOL CODE IS RETURNED
C     DIRECTLY IN NUM.	OTHERWISE, RDSYM SCANS UP TO EIGHT NON-BLANK
C     CHARACTERS, CONSTRUCTING A SYMBOL OUT OF THEM.  IF THIS SYMBOL IS
C     NOT IN THE TABLE IN /SYMBOL/, THEN IT IS ADDED TO IT.
C     THE INDEX OF THE SYMBOL IN THE TABLE IS RETURNED IN NUM.
C
C***********************************************************************
C
      INTEGER NSYMBS, NTERMS, SYMBS(2,200)
      COMMON /SYMBOL/ NSYMBS, NTERMS, SYMBS
      COMMON /LUNITS/ LUI, LUO, LUP
      LOGICAL RESOLV
      COMMON /RESOLV/ RESOLV
      INTEGER CHAR, SPACE, SYM(2), ENDSYM(2), NILSYM(2), RESSYM(2)
      DATA SPACE/1H /, ENDSYM/4H$$EN,1HD/, NILSYM/4H$$NI,1HL/
      DATA RESSYM/4H$$RE,4HSOLV/
C
C		    LOCATE THE NEXT NON-BLANK
   10 CONTINUE
	 CALL RDCHAR (CHAR)
      IF (CHAR .EQ. 0) GO TO 10
C		    IF EOL, RETURN SPECIAL CODE
      IF (CHAR .NE. -1) GO TO 20
	 NUM = -1
	 LAST = 0
	 RETURN
C		    READ THE SYMBOL.  IF MORE THAN 8 CHARACTERS, ERROR.
   20 CONTINUE
      DO 30 I = 1,8
	 CALL SETCHR (SYM,I,CHAR)
	 CALL RDCHAR (CHAR)
	 IF (CHAR .EQ. 0) GO TO 40
   30 CONTINUE
      WRITE (LUO,1000)
 1000 FORMAT (42H0***  SYMBOL LONGER THAN 8 CHARACTERS	***,///)
      STOP
   40 CONTINUE
      IF (I .EQ. 8) GO TO 60
	 I1 = I + 1
	 DO 50 I = I1,8
	    CALL SETCHR (SYM,I,SPACE)
   50	 CONTINUE
   60 CONTINUE
C		    LOCATE THE SYMBOL IN THE TABLE--IF NOT THERE, ADD IT
      NUM = -3
      IF (SYM(1).EQ.NILSYM(1) .AND. SYM(2).EQ.NILSYM(2)) RETURN
      NUM = -2
      IF (SYM(1).EQ.ENDSYM(1) .AND. SYM(2).EQ.ENDSYM(2)) RETURN
      RESOLV = SYM(1).EQ.RESSYM(1) .AND. SYM(2).EQ.RESSYM(2)
      IF (RESOLV) RETURN
      DO 80 NUM = 1,NSYMBS
	 IF (SYM(1).EQ.SYMBS(1,NUM) .AND. SYM(2).EQ.SYMBS(2,NUM)) RETURN
   80 CONTINUE
      IF (NSYMBS .LT. 199) GO TO 90
	 WRITE (LUO,2000)
 2000	 FORMAT (33H ***  SYMBOL TABLE	OVERFLOW  ***,///)
	 STOP
   90 CONTINUE
      NSYMBS = NSYMBS + 1
      SYMBS(1,NSYMBS) = SYM(1)
      SYMBS(2,NSYMBS) = SYM(2)
      NUM = NSYMBS
      RETURN
      END
      SUBROUTINE RDCHAR (CHAR)
      INTEGER CHAR
C
C***********************************************************************
C
C     THIS SUBVROUTINE READS THE NEXT CHARACTER FROM THE INPUT UNIT,
C     LUI, AND RETURNS IT IN CHAR.  ONLY 71 CHARACTERS PER LINE ARE
C     RETURNED.  BLANKS ARE RETURNED AS INTEGER 0.  OTHER CHARACTERS
C     ARE RETURNED IN A1 FORMAT (LEFT JUSTIFIED, BLANK FILLED).  AFTER
C     THE 71 CHARACTERS FROM A CARD HAVE BEEN RETURNED, A ZERO IS
C     RETURNED.  THEN, IF COLUMN 72 IS BLANK, AN INTEGER 1 IS RETURNED
C     BEFORE BEGINNING TO READ CHARACTERS FROM THE NEXT LINE.  IF
C     COLUMN 72 IS NON-BLANK, THEN NO END-OF-LINE ONE CODE IS RETURNED.
C
C***********************************************************************
C
      INTEGER CARDNO, NCH, CARD(20)
      COMMON /IN/ CARDNO, NCH, CARD
      COMMON /LUNITS/ LUI, LUO, LUP
      INTEGER SPACE
      DATA SPACE/1H /
C
      IF (NCH) 10,20,30
   10 CONTINUE
	 NCH = 0
	 CHAR = -1
	 RETURN
   20 CONTINUE
	 READ (LUI,1000) CARD
 1000	 FORMAT (20A4)
	 CARDNO = CARDNO + 1
	 WRITE (LUO,2000) CARDNO, CARD
 2000	 FORMAT (I4,2H. ,18A4,2X,2A4)
	 NCH = 1
   30 CONTINUE
      IF (NCH .EQ. 72) GO TO 40
	 CHAR = ICHR(CARD,NCH)
	 IF (CHAR .EQ. ICHR(SPACE,1)) CHAR = 0
	 NCH = NCH + 1
	 RETURN
   40 CONTINUE
	 CHAR = 0
	 NCH = -1
	 IF (ICHR(CARD,72) .EQ. ICHR(SPACE,1)) RETURN
	 NCH = 0
	 RETURN
      END
      SUBROUTINE NTRMNL (SYM)
      INTEGER SYM
C
C***********************************************************************
C
C	 THIS SUBROUTINE INSURES THAT THE SYMBOL -SYM-, WHICH IS KNOWN
C     TO BE A NON-TERMINAL, WILL BE STORED WITH THE NON-TERMINALS IN
C     THE -SYMBS- ARRAY.  THE CONVENTION IS THAT -NTERMS- IS THE TOTAL
C     NUMBER OF NON-TERMINALS, AND THAT THE FIRST -NTERMS- ENTRIES IN
C     -SYMBS- ARE THE NON-TERMINALS.
C
C***********************************************************************
C
      INTEGER NSYMBS, NTERMS, SYMBS(2,200)
      COMMON /SYMBOL/ NSYMBS, NTERMS, SYMBS
      INTEGER NPRODS, LHS(200), PLEN(200), RHS(8,200)
      COMMON /PRODCT/ NPRODS, LHS, PLEN, RHS
      INTEGER SYMBL(2)
C
      IF (SYM .GT. NTERMS) NTERMS = NTERMS + 1
      IF (SYM .LE. NTERMS) RETURN
      SYMBL(1) = SYMBS(1,SYM)
      SYMBL(2) = SYMBS(2,SYM)
      MOVE = SYM - NTERMS
      DO 10 I = 1,MOVE
	 II = SYM - I + 1
	 SYMBS(1,II) = SYMBS(1,II-1)
	 SYMBS(2,II) = SYMBS(2,II-1)
   10 CONTINUE
      SYMBS(1,NTERMS) = SYMBL(1)
      SYMBS(2,NTERMS) = SYMBL(2)
      NDIF = SYM - NTERMS + 1
      DO 30 IP = 1,NPRODS
	 LEN = PLEN(IP)
	 DO 20 L = 1,LEN
	    IPSYM = RHS(L,IP) - NTERMS + 1
	    IF (IPSYM.GE.1 .AND. IPSYM.LE.NDIF)
     +	       RHS(L,IP) = NTERMS + MOD(IPSYM,NDIF)
   20	 CONTINUE
   30 CONTINUE
      SYM = NTERMS
      RETURN
      END
      SUBROUTINE INPRNT
      INTEGER NSYMBS, NTERMS, SYMBS(2,200)
      COMMON /SYMBOL/ NSYMBS, NTERMS, SYMBS
      INTEGER NPRODS, LHS(200), PLEN(200), RHS(8,200)
      COMMON /PRODCT/ NPRODS, LHS, PLEN, RHS
      LOGICAL CHAIN(200)
      COMMON /CHNPRD/ CHAIN
      INTEGER HEADER (18)
      COMMON /PRHEAD/ HEADER
      COMMON /LUNITS/ LUI, LUO, LUP
      INTEGER SYM(2,9)
      COMMON /TEMPS/ SYM
      INTEGER ICHN(2,2)
      DATA ICHN / 1H ,1H ,4H(CHA,3HIN) /
C
      WRITE (LUO,1000) HEADER
 1000 FORMAT (1H1,39X,42HSLR(1) ANALYSER -- SYMBOLS AND PRODUCTIONS,/
     +	      1H0,24X,18A4)
      WRITE (LUO,2000) (I,SYMBS(1,I),SYMBS(2,I),I=1,NTERMS)
 2000 FORMAT (/30H0THE NON-TERMINAL SYMBOLS ARE:,//(5(I9,3H.  ,2A4)))
      NT1 = NTERMS + 1
      WRITE (LUO,3000) (I,SYMBS(1,I),SYMBS(2,I),I=NT1,NSYMBS)
 3000 FORMAT (/26H0THE TERMINAL SYMBOLS ARE:,//(5(I9,3H.  ,2A4)))
      WRITE (LUO,5000)
 5000 FORMAT (//21H0THE PRODUCTIONS ARE:,/)
      DO 60 IP = 1,NPRODS
	 I = LHS(IP)
	 SYM(1,1) = SYMBS(1,I)
	 SYM(2,1) = SYMBS(2,I)
	 LEN = PLEN(IP)
	 IF (LEN .EQ. 0) GO TO 20
	 DO 10 I = 1,LEN
	    J = RHS(I,IP)
	    SYM(1,I+1) = SYMBS(1,J)
	    SYM(2,I+1) = SYMBS(2,J)
   10	 CONTINUE
   20	 LEN = LEN + 1
	 ITP = 1
	 IF (CHAIN(IP)) ITP = 2
	 WRITE (LUO,3100) IP, ICHN(1,ITP),ICHN(2,ITP),
     +			  (SYM(1,I),SYM(2,I),I=1,LEN)
 3100	 FORMAT (I4,2H. ,4A4,4H ::=,8(1X,2A4))
   60 CONTINUE
      RETURN
      END
      SUBROUTINE STATES
C
C***********************************************************************
C
C	 THIS SUBROUTINE COMPUTES THE ITEM SETS AND TRANSITIONS FOR THE
C     STATES OF THE PARSER.  -STATE- IS AN ARRAY, WHERE EACH ROW
C     CORRESPONDS TO A PARSER STATE.  -STATE(I,1)- IS A POINTER TO THE
C     START OF THE LIST OF ITEMS FOR STATE I IN THE -ITEM- TABLE, WHERE
C     EACH ITEM HAS THE FORM (PROD*100+LOC), PROD BEING A PRODUCTION
C     NUMBER, AND LOC BEING THE POSITION IN THE PRODUCTION WHERE THE
C     DOT IS INSERTED.	-ITEM(I,2)- IS THE NUMBER OF ITEMS FOR THE
C     STATE.  -STATE(I,3)- IS THE NUMBER OF TRANSITIONS, WHERE EACH
C     TRANSITION IS A TWO-WORD ENTRY IN THE -ITEM- TABLE, REPRESENTING
C     THE TRANSITION SYMBOL AND THE NEXT STATE.
C
C***********************************************************************
C
      INTEGER STATE(500,3), MAXST, NST, ITEM(5000), MAX
      COMMON /IGTAB/ STATE, MAXST, NST, ITEM, MAX
      COMMON /LUNITS/ LUI, LUO, LUP
C
      ITEM(1) = 100
      STATE(1,1) = 1
      STATE(1,2) = 1
      CALL CLOSE (ITEM,STATE(1,2),MAX)
      NXTGT = STATE(1,2) + 1
      CALL GSET (ITEM,STATE(1,2),ITEM(NXTGT),STATE(1,3),(MAX-NXTGT+1)/2)
      NXT = NXTGT + STATE(1,3)*2
      IST = 1
      NST = 1
  100 CONTINUE
	 ITI = STATE(IST,1)
	 NTI = STATE(IST,2)
	 NGT = STATE(IST,3)
	 IF (NGT .EQ. 0) GO TO 120
	 IGT1 = ITI + NTI
	 IGT2 = IGT1 + NGT*2 - 2
	 DO 110 IGT = IGT1,IGT2,2
	    CALL STGEN (ITEM(ITI),NTI,ITEM(IGT),ITEM(NXT),NTNEW,
     +			MAX-NXT+1)
	    CALL STNDX (NXT,NTNEW,ITEM(IGT+1))
  110	 CONTINUE
  120	 CONTINUE
	 IST = IST + 1
      IF (IST .LE. NST) GO TO 100
      RETURN
      END
      SUBROUTINE GSET (ITEM,M,GOTOS,N,MAX)
      INTEGER ITEM(M), GOTOS(2,MAX)
C
C***********************************************************************
C
C	 -ITEM- IS THE SET OF ITEMS FOR SOME STATE, I, OF THE GRAMMAR.
C     SUBROUTINE -GSET- COMPUTES THE SET OF SYMBOLS S(J) FOR WHICH
C     GOTO(I,S(J)) IS NOT EMPTY.  THESE SYMBOLS ARE STORED IN -GOTOS-.
C
C***********************************************************************
C
      INTEGER NPRODS, LHS(200), PLEN(200), RHS(8,200)
      COMMON /PRODCT/ NPRODS, LHS, PLEN, RHS
      COMMON /LUNITS/ LUI, LUO, LUP
C
      N = 0
      DO 30 I = 1,M
	 IPROD = ITEM(I) / 100
	 IPT = MOD(ITEM(I),100)
	 IF (IPT .EQ. PLEN(IPROD)) GO TO 30
	 ISYM = RHS(IPT+1,IPROD)
	 IF (N .EQ. 0) GO TO 20
	 DO 10 J = 1,N
	    IF (GOTOS(1,J) .EQ. ISYM) GO TO 30
   10	 CONTINUE
   20	 CONTINUE
	 N = N + 1
	 IF (N .GT. MAX) GO TO 40
	 GOTOS(1,N) = ISYM
	 GOTOS(2,N) = 0
   30 CONTINUE
      RETURN
C
   40 CONTINUE
      WRITE (LUO,1000)
 1000 FORMAT (35H0***  ITEM/GOTO TABLE OVERFLOW  ***,///)
      STOP
      END
      SUBROUTINE STGEN (OLD,M,SYM,ITEM,N,MAX)
      INTEGER OLD(M), SYM, ITEM(MAX)
C
C***********************************************************************
C
C	 -OLD- IS THE SET OF ITEMS CORRESPONDING TO SOME STATE I.  THIS
C     SUBROUTINE COMPUTES IN -ITEM- THE SET OF ITEMS IN GOTO(I,SYM).
C
C***********************************************************************
C
      INTEGER NPRODS, LHS(200), PLEN(200), RHS(8,200)
      COMMON /PRODCT/ NPRODS, LHS, PLEN, RHS
      COMMON /LUNITS/ LUI, LUO, LUP
C
      N = 0
      DO 10 I = 1,M
	 IPROD = OLD(I) / 100
	 IPT = MOD(OLD(I),100)
	 IF (IPT .EQ. PLEN(IPROD)) GO TO 10
	 IF (RHS(IPT+1,IPROD) .NE. SYM) GO TO 10
	 N = N + 1
	 IF (N .GT. MAX) GO TO 20
	 ITEM(N) = IPROD*100 + IPT+1
   10 CONTINUE
      CALL CLOSE (ITEM,N,MAX)
      RETURN
C
   20 CONTINUE
      WRITE (LUO,1000)
 1000 FORMAT (35H0***  ITEM/GOTO TABLE OVERFLOW  ***,///)
      STOP
      END
      SUBROUTINE CLOSE (ITEM,N,MAX)
      INTEGER ITEM(MAX)
C
C***********************************************************************
C
C	 ON INPUT, -ITEM- IS AN ARRAY OF -N- ITEMS, WITH A MAXIMUM
C     CAPACITY OF -MAX- ITEMS.	SUBROUTINE CLOSE COMPUTES THE CLOSURE
C     OF THIS SET OF ITEMS, AND RETURNS WITH THE APPROPRIATE NEW ITEMS
C     STORED IN -ITEM-, AND WITH -N- SET TO ITS NEW VALUE.
C
C***********************************************************************
C
      INTEGER NPRODS, LHS(200), PLEN(200), RHS(8,200)
      COMMON /PRODCT/ NPRODS, LHS, PLEN, RHS
      INTEGER NSYMBS, NTERMS, SYMBS(2,200)
      COMMON /SYMBOL/ NSYMBS, NTERMS, SYMBS
      COMMON /LUNITS/ LUI, LUO, LUP
C
      I = 1
   10 CONTINUE
      IPROD = ITEM(I) / 100
      IPT = MOD(ITEM(I),100)
      IF (IPT .EQ. PLEN(IPROD)) GO TO 40
      KEY = RHS(IPT+1,IPROD)
      IF (KEY .GT. NTERMS) GO TO 40
      DO 30 IPROD = 1,NPRODS
	 IF (LHS(IPROD) .NE. KEY) GO TO 30
	 NEW = IPROD * 100
	 DO 20 J = 1,N
	    IF (ITEM(J) .EQ. NEW) GO TO 30
   20	 CONTINUE
	 N = N + 1
	 IF (N .GT. MAX) GO TO 90
	 ITEM(N) = NEW
   30 CONTINUE
   40 CONTINUE
      I = I + 1
      IF (I .LE. N) GO TO 10
C
C     BEFORE RETURNING, WE SORT THE SET OF ITEMS FOR LATER COMPARISONS
C
      CALL SORT (ITEM,N)
      RETURN
C
   90 CONTINUE
      WRITE (LUO,1000)
 1000 FORMAT (35H0***  ITEM/GOTO TABLE OVERFLOW  ***,///)
      STOP
      END
      SUBROUTINE SORT (ITEM,N)
      INTEGER ITEM(N)
C
C***********************************************************************
C
C	 THIS SUBROUTINE SORTS THE ARRAY -ITEM- INTO ASCENDING ORDER.
C
C***********************************************************************
C
      LOGICAL DONE
C
      IF (N .LE. 1) RETURN
      N1 = N - 1
      DO 60 I = 1,N1
	 DONE = .TRUE.
	 I1 = I + 1
	 DO 50 J = I1,N
	    IF (ITEM(J-1) .LT. ITEM(J)) GO TO 50
	    DONE = .FALSE.
	    IT = ITEM(J-1)
	    ITEM(J-1) = ITEM(J)
	    ITEM(J) = IT
   50	 CONTINUE
	 IF (DONE) RETURN
 CONTINUE
      RETURN
      END
      SUBROUTINE STNDX (J,N,IST)
C
C***********************************************************************
C
C	 THIS SUBROUTINE DETECTS WHETHER THERE IS A STATE HAVING THE
C     SAME -N- ITEMS AS THOSE BEGINNING AT ITEM(J).  IF SO, THE INDEX
C     OF THAT STATE IS RETURNED.  IF NOT, THE NUMBER OF STATES IS
C     INCREMENTED, THE GOTO SET FOR THE NEW FUNCTION IS COMPUTED, AND
C     THE RELEVANT INFORMATION ABOUT THE NEW STATE IS STORED IN THE
C     STATE TABLE.  THE NUMBER OF THE NEWLY CREATED STATE IS THEN
C     RETURNED.
C
C***********************************************************************
C
      INTEGER STATE(500,3), MAXST, NST, ITEM(5000), MAX
      COMMON /IGTAB/ STATE, MAXST, NST, ITEM, MAX
      COMMON /LUNITS/ LUI, LUO, LUP
C
      DO 120 IST = 1,NST
	 IF (STATE(IST,2) .NE. N) GO TO 120
	 ITI = STATE(IST,1)
	 DO 110 K = 1,N
	    IF (ITEM(ITI+K-1) .NE. ITEM(J+K-1)) GO TO 120
  110	 CONTINUE
	 RETURN
  120 CONTINUE
      NST = NST + 1
      IF (NST .GT. MAXST) GO TO 200
      STATE(NST,1) = J
      STATE(NST,2) = N
      NXTGT = J + N
      CALL GSET (ITEM(J),N,ITEM(NXTGT),STATE(NST,3),(MAX-NXTGT+1)/2)
      J = NXTGT + STATE(NST,3)*2
      IST = NST
      RETURN
C
  200 CONTINUE
      WRITE (LUO,1000)
 1000 FORMAT (31H0***  STATE TABLE OVERFLOW  ***,///)
      STOP
      END
      SUBROUTINE STPRNT
      INTEGER NPRODS, LHS(200), PLEN(200), RHS(8,200)
      COMMON /PRODCT/ NPRODS, LHS, PLEN, RHS
      INTEGER NSYMBS, NTERMS, SYMBS(2,200)
      COMMON /SYMBOL/ NSYMBS, NTERMS, SYMBS
      INTEGER STATE(500,3), MAXST, NST, ITEM(5000), MAXIT
      COMMON /IGTAB/ STATE, MAXST, NST, ITEM, MAXIT
      INTEGER HEADER (18)
      COMMON /PRHEAD/ HEADER
      COMMON /LUNITS/ LUI, LUO, LUP
      INTEGER DOT(2), SYM(2,10)
      COMMON /TEMPS/ SYM
      DATA DOT(1)/4H   */, DOT(2)/4H*   /
C
      WRITE (LUO,1000) HEADER
 1000 FORMAT (1H1,34X,42HSLR(1) ANALYSER -- CONFIGURATION SETS AND ,
     +	      11HTRANSITIONS,/1H0,24X,18A4,/)
      DO 50 IST = 1,NST
	 IIST = IST - 1
	 WRITE (LUO,2000) IIST
 2000	 FORMAT (6H0STATE,I4,/)
	 ITI = STATE(IST,1)
	 NTI = ITI + STATE(IST,2) - 1
	 DO 30 IT = ITI,NTI
	    IP = ITEM(IT) / 100
	    IPT = MOD(ITEM(IT),100)
	    LEN = PLEN(IP) + 1
	    I = LHS(IP)
	    SYM(1,1) = SYMBS(1,I)
	    SYM(2,1) = SYMBS(2,I)
	    K = 2
	    DO 20 L = 1,LEN
	       IF (L .NE. IPT+1) GO TO 10
	       SYM(1,K) = DOT(1)
	       SYM(2,K) = DOT(2)
	       K = K + 1
   10	       IF (L .EQ. LEN) GO TO 20
	       I = RHS(L,IP)
	       SYM(1,K) = SYMBS(1,I)
	       SYM(2,K) = SYMBS(2,I)
	       K = K + 1
   20	    CONTINUE
	    K = K - 1
	    WRITE (LUO,3000) (SYM(1,I),SYM(2,I),I=1,K)
 3000	    FORMAT (4X,2A4,4H ::=,9(2X,2A4))
   30	 CONTINUE
	 IF (STATE(IST,3) .EQ. 0) GO TO 50
	 ITI = NTI + 1
	 NTI = ITI + STATE(IST,3)*2 - 2
	 DO 40 IT = ITI,NTI,2
	    IS = ITEM(IT)
	    IG = ITEM(IT+1) - 1
	    WRITE (LUO,4000) SYMBS(1,IS), SYMBS(2,IS), IG
 4000	    FORMAT (4X,5HGOTO(,2A4,3H) =,I4)
   40	 CONTINUE
   50 CONTINUE
      RETURN
      END
      SUBROUTINE FOLLOW
C
C***********************************************************************
C
C	 THIS SUBROUTINE COMPUTES THE LOOKAHEAD SETS FOR ALL THE
C     NON-TERMINALS, AND STORES THEM IN THE ARRAY -FT1- IN /LOOK/.
C
C***********************************************************************
C
      INTEGER NSYMBS, NTERMS, SYMBS(2,200)
      COMMON /SYMBOL/ NSYMBS, NTERMS, SYMBS
      INTEGER NPRODS, LHS(200), PLEN(200), RHS(8,200)
      COMMON /PRODCT/ NPRODS, LHS, PLEN, RHS
      INTEGER STATE(500,3), MAXST, NST, ITEM(5000), MAXIT
      COMMON /IGTAB/ STATE, MAXST, NST, ITEM, MAXIT
      INTEGER FT1 (7,200)
      COMMON /LOOK/ FT1
      INTEGER H(7,200), F(7,200), T(7,200), FH(7,200)
      EQUIVALENCE (T(1,1), H(1,1))
      LOGICAL NUL (200)
      COMMON /PTABLE/ F, H, FH, NUL
C     WE HAVEN'T PUT THE PARSE TABLES IN /PTABLE/ YET, SO
C     WE CAN BORROW IT FOR TEMPORARY STORAGE.
      LOGICAL FLAG
      DATA NBITS /32/
C
C     COMPUTE ARRAY NUL -- NUL(I) = .TRUE. IF SYM(I) ->* LAMBDA
C	 (THE EMPTY STRING)
C
      DO 10 I = 1, NSYMBS
   10 NUL(I) = .FALSE.
   20 CONTINUE
	 FLAG = .FALSE.
	 DO 50 IP = 1,NPRODS
	    I = LHS(IP)
	    IF (NUL(I)) GO TO 50
	    L = PLEN(IP)
	    IF (L .EQ. 0) GO TO 40
	    DO 30 L1 = 1,L
	       J = RHS(L1,IP)
	       IF (.NOT. NUL(J)) GO TO 50
   30	    CONTINUE
   40	    CONTINUE
	    NUL(I) = .TRUE.
	    FLAG = .TRUE.
   50	 CONTINUE
      IF (FLAG) GO TO 20
C
C     COMPUTE ARRAY H -- H(I,J) = 1 IF SYM(I) ->* NU SYM(J) RHO,
C	 WHERE RHO IS IN V*, AND NU IS IN NUL*, AND SYM(I) AND
C	 SYM(J) ARE ANY TWO SYMBOLS.
C
      NWIDE = (NSYMBS+NBITS-1) / NBITS
      DO 110 I = 1,NSYMBS
      DO 110 J = 1,NWIDE
  110 CALL CLRWRD (T(J,I))
C		    COMPUTE THE BASIC RELATION
      DO 130 IP = 1,NPRODS
	 L = PLEN(IP)
	 I = LHS(IP)
	 L1 = 1
  120	 CONTINUE
	    IF (L1 .GT. L) GO TO 130
	    J = RHS(L1,IP)
	    CALL SETBIT (T(1,J),I)
	    L1 = L1 + 1
	 IF (NUL(J)) GO TO 120
  130 CONTINUE
C		    APPLY WARSHALL'S ALGORITHM TO FIND THE CLOSURE
      DO 160 I = 1,NSYMBS
	 DO 150 J = 1,NSYMBS
	 IF (IBIT(H(1,J),I) .EQ. 0) GO TO 150
	    DO 140 K = 1,NWIDE
  140	    CALL IOR (H(K,J),H(K,I),H(K,J))
  150	 CONTINUE
  160 CONTINUE
C		    ADD THE DIAGONAL BITS TO MAKE IT SYMMETRIC
      DO 170 I = 1,NSYMBS
  170 CALL SETBIT (H(1,I),I)
C
C     COMPUTE ARRAY F -- F(I,J) = 1 IF FOR SOME NON-TERMINAL A,
C	 A -> RHO SYM(I) NU SYM(J) SIGMA, WHERE RHO AND SIGMA
C	 ARE IN V*, NU IS IN NUL*, SYM(I) IS A NON-TERMINAL,
C	 AND SYM(J) IS A SYMBOL.
C
      DO 210 I = 1,NTERMS
      DO 210 J = 1,NWIDE
  210 CALL CLRWRD (F(J,I))
C		    SET F(*ACCEPT,*END)
      CALL SETBIT (F(1,1),NSYMBS)
C		    COMPUTE THE REST OF THE RELATION
      DO 250 IP = 1,NPRODS
	 L = PLEN(IP)
	 L1 = L - 1
  220	IF (L1 .LE. 0) GO TO 250
	    I = RHS(L1,IP)
	    IF (I .GT. NTERMS) GO TO 240
	    L2 = L1 + 1
  230	    CONTINUE
	       J = RHS(L2,IP)
	       CALL SETBIT (F(1,I),J)
	       IF (L2 .EQ. L) GO TO 240
	       L2 = L2 + 1
	    IF (NUL(J)) GO TO 230
  240	    CONTINUE
	    L1 = L1 - 1
	 GO TO 220
  250 CONTINUE
C
C     COMPUTE FH = F * H', WHERE H' IS THE SAME AS H, BUT IS
C	 DEFINED ONLY FOR TERMINAL SYMBOLS SYM(J).
C
      DO 310 I = 1,NSYMBS
      DO 310 J = 1,NWIDE
  310 CALL CLRWRD (FH(J,I))
      NT = NTERMS + 1
      DO 340 I1 = NT,NSYMBS
      DO 340 J = 1,NTERMS
	 DO 320 K = 1,NWIDE
	    IF (IFANY(F(K,J),H(K,I1)) .NE. 0) GO TO 330
  320	 CONTINUE
	 GO TO 340
  330	 CONTINUE
	 I = I1 - NTERMS
	 CALL SETBIT (FH(1,I),J)
  340 CONTINUE
C
C     COMPUTE ARRAY T -- T(I,J) = 1 IF SYM(J) ->* RHO SYM(I) NU,
C	 WHERE RHO IS IN V*, NU IS IN NUL*, AND SYM(I) AND
C	 SYM(J) ARE NON-TERMINALS.
C
      NWIDE = (NTERMS+NBITS-1) / NBITS
      DO 410 I = 1,NTERMS
      DO 410 J = 1,NWIDE
  410 CALL CLRWRD (T(J,I))
C		    COMPUTE THE BASIC RELATION
      DO 430 IP = 1,NPRODS
	 L = PLEN(IP)
	 J = LHS(IP)
	 L1 = L
  420	 CONTINUE
	    IF (L1 .EQ. 0) GO TO 430
	    I = RHS(L1,IP)
	    IF (I .LE. NTERMS) CALL SETBIT (T(1,I),J)
	    L1 = L1 - 1
	 IF (NUL(I)) GO TO 420
  430 CONTINUE
C		    APPLY WARSHALL'S ALGORITHM TO FIND THE CLOSURE
      DO 460 I = 1,NTERMS
	 DO 450 J = 1,NTERMS
	 IF (IBIT(T(1,J),I) .EQ. 0) GO TO 450
	    DO 440 K = 1,NWIDE
  440	    CALL IOR (T(K,J),T(K,I),T(K,J))
  450	 CONTINUE
  460 CONTINUE
C		    ADD THE DIAGONAL BITS TO MAKE IT SYMMETRIC
      DO 470 I = 1,NTERMS
  470 CALL SETBIT (T(1,I),I)
C
C     COMPUTE FT1 = T * FH
C
      NT = NSYMBS - NTERMS
      DO 510 I = 1,NT
      DO 510 J = 1,NWIDE
  510 CALL CLRWRD (FT1(J,I))
      DO 540 I = 1,NT
      DO 540 J = 1,NTERMS
	 DO 520 K = 1,NWIDE
	    IF (IFANY(T(K,J),FH(K,I)) .NE. 0) GO TO 530
  520	 CONTINUE
	 GO TO 540
  530	 CONTINUE
	 CALL SETBIT (FT1(1,I),J)
  540 CONTINUE
C
      RETURN
      END
      SUBROUTINE PRFT1
      INTEGER HEADER (18)
      COMMON /PRHEAD/ HEADER
      COMMON /LUNITS/ LUI, LUO, LUP
      INTEGER NSYMBS, NTERMS, SYMBS(2,200)
      COMMON /SYMBOL/ NSYMBS, NTERMS, SYMBS
      INTEGER FT1(7,200)
      COMMON /LOOK/ FT1
      INTEGER BIT(100)
      COMMON /TEMPS/ BIT
      DATA NBITS/32/
C
      NWIDE = (NTERMS+NBITS-1) / NBITS
      NS1 = NTERMS
    5 WRITE (LUO,1000) HEADER
 1000 FORMAT (1H1,37X,44HSLR(1) ANALYSER -- LOOKAHEAD SET COMPUTATION,/
     +	      1H0,24X,18A4,/)
      NT1 = NS1 + 1
      NS1 = MIN0(NSYMBS,NS1+100)
      NT = NS1 - NT1 + 1
      DO 20 I = 1,8
	 DO 10 J = NT1,NS1
	    JJ = J - NT1 + 1
	    CALL SETCHR (BIT(JJ),1,ICHR(SYMBS(1,J),I))
   10	 CONTINUE
	 WRITE (LUO,2000) (BIT(J),J=1,NT)
 2000	 FORMAT (9X,10(1X,10A1))
   20 CONTINUE
      DO 120 I = 1,NTERMS
	 IF (MOD(I,10) .EQ. 1) WRITE (LUO,3000)
 3000	 FORMAT (1X)
	 DO 110 J = 1,NT
	    BIT(J) = IBIT(FT1(1,J),I)
  110	 CONTINUE
	 WRITE (LUO,4000) SYMBS(1,I), SYMBS(2,I), (BIT(J),J=1,NT)
 4000	 FORMAT (1X,2A4,10(1X,10I1))
  120 CONTINUE
      IF (NS1 .LT. NSYMBS) GO TO 5
      RETURN
      END
      SUBROUTINE PARSER
C
C***********************************************************************
C
C	 THIS ROUTINE COMPUTES THE PARSER ACTION AND GOTO TABLES.
C     PARSE(I,1) IS THE START OF THE ACTIONS IN -ACT- FOR STATE I, AND
C     PARSE(I,2) IS THE NUMBER OF ACTIONS FOR STATE I.	GOTO(I,1) IS
C     THE START OF THE GOTOS IN -ACT- FOR SYMBOL I, AND GOTO(I,2) IS
C     THE NUMBER OF GOTOS FROM SYMBOL I.
C
C	 AN ACTION ENTRY IN -ACT- HAS THE FORM,
C
C     ACT(I,1) = M -- IF (INPUT = SYM(N)) ...
C	       =  0 -- DEFAULT ACTION
C     ACT(I,2) = 1000+N -- REDUCE N
C	       = 2000+N -- SHIFT, REDUCE N
C	       = 3000+N -- SHIFT, GOTO N
C	       = 4000	-- ERROR
C
C	 A GOTO ENTRY IN -ACT- HAS THE FORM,
C
C     ACT(I,1) = M -- IF (STATE = M) ...
C	       = 0 -- DEFAULT ACTION
C     ACT(I,2) = 2000+N -- REDUCE N
C	       = 3000+N -- GOTO N
C
C***********************************************************************
C
      COMMON /LUNITS/ LUI, LUO, LUP
      INTEGER NSYMBS, NTERMS, SYMBS(2,200)
      COMMON /SYMBOL/ NSYMBS, NTERMS, SYMBS
      INTEGER NPRODS, LHS(200), PLEN(200), RHS(8,200)
      COMMON /PRODCT/ NPRODS, LHS, PLEN, RHS
      INTEGER STATE(500,3), MAXST, NST, ITEM(5000), MAXIT
      COMMON /IGTAB/ STATE, MAXST, NST, ITEM, MAXIT
      INTEGER FT1(7,200)
      COMMON /LOOK/ FT1
      INTEGER RSTATE(500)
      COMMON /TEMPS/ RSTATE
      INTEGER NRST, PARSE(500,2), GOTO(200,2), ACT(2000,2), MAXACT
      COMMON /PTABLE/ NRST, PARSE, GOTO, ACT, MAXACT
      DATA NBITS/32/
C
      NWIDE = (NTERMS+NBITS-1) / NBITS
      CALL LR0MRK (NRST,RSTATE)
      NT = NSYMBS - NTERMS
      NXT = 1
      DO 60 IST = 1,NST
	 IF (RSTATE(IST)/1000 .NE. 3) GO TO 60
	 IRST = MOD(RSTATE(IST),1000)
	 PARSE(IRST,1) = NXT
	 ITI = STATE(IST,1)
	 NTI = STATE(IST,2)
	 NGT = STATE(IST,3)
	 IF (NGT .EQ. 0) GO TO 20
	 IG1 = ITI + NTI
	 IG2 = IG1 + NGT*2 - 2
	 DO 10 IG = IG1,IG2,2
	    IF (ITEM(IG) .LE. NTERMS) GO TO 10
	    IGOTO = ITEM(IG+1)
	    CALL ADDPA (NXT,ITEM(IG),RSTATE(IGOTO))
   10	 CONTINUE
   20	 CONTINUE
	 IRED = 0
	 IT2 = ITI + NTI - 1
	 DO 40 IT = ITI,IT2
	    IP = ITEM(IT) / 100
	    IF (PLEN(IP) .NE. MOD(ITEM(IT),100)) GO TO 40
	    DO 30 J = 1,NT
	       IF (IBIT(FT1(1,J),LHS(IP)) .EQ. 0) GO TO 30
	       IF (IP .NE. 1) IRED = 1
	       CALL ADDPA (NXT,NTERMS+J,IP+1000)
   30	    CONTINUE
   40	 CONTINUE
	 IF (IRED.EQ.0) CALL ADDPA (NXT,0,4000)
	 PARSE(IRST,2) = NXT - PARSE(IRST,1)
   60 CONTINUE
C
      DO 140 I = 1,NTERMS
	 GOTO(I,1) = NXT
	 DO 130 IST = 1,NST
	    IG1 = STATE(IST,1) + STATE(IST,2)
	    IG2 = IG1 + STATE(IST,3)*2 - 2
	    DO 110 IG = IG1,IG2,2
	       IF (ITEM(IG) .EQ. I) GO TO 120
  110	    CONTINUE
	    GO TO 130
  120	    CONTINUE
	    IGOTO = ITEM(IG+1)
	    CALL ADDPA (NXT,MOD(RSTATE(IST),1000),RSTATE(IGOTO))
  130	 CONTINUE
	 GOTO(I,2) = NXT - GOTO(I,1)
  140 CONTINUE
      RETURN
      END
      SUBROUTINE LR0MRK (NRST,RSTATE)
      INTEGER NRST, RSTATE(500)
C
C***********************************************************************
C
C	 THIS ROUTINE WILL EXAMINE ALL THE CONFIGURATION SETS.	IF ANY
C     SET CONTAINS ONLY ONE ITEM, WHICH IS COMPLETED, THEN IT COR-
C     RESPONDS TO AN LR(0) REDUCE STATE, WHICH WILL BE OPTIMIZED OUT.
C     NRST IS THE NUMBER OF REAL -- THAT IS, NON-LR(0) -- STATES.
C     IF STATE I IS NOT LR(0), THEN RSTATE(I) WILL BE 3000 PLUS ITS
C     INDEX AMONG THE NON-LR(0) STATES.  IF IT IS LR(0), THEN RSTATE(I)
C     WILL BE THE CORRESPONDING NUMBER, PLUS 2000.
C
C***********************************************************************
C
      INTEGER STATE(500,3), MAXST, NST, ITEM(5000), MAXIT
      COMMON /IGTAB/ STATE, MAXST, NST, ITEM, MAXIT
C
      NRST = 0
      DO 20 IST = 1,NST
	 IF (STATE(IST,2) .NE. 1) GO TO 10
	 IF (STATE(IST,3) .NE. 0) GO TO 10
	 ITI = STATE(IST,1)
	 IF (ITEM(ITI)/100 .EQ. 1) GO TO 10
	    RSTATE(IST) = ITEM(ITI)/100 + 2000
	    GO TO 20
   10	 CONTINUE
	    NRST = NRST + 1
	    RSTATE(IST) = NRST + 3000
   20 CONTINUE
      RETURN
      END
      SUBROUTINE ADDPA (NXT,VAL1,VAL2)
      INTEGER VAL1, VAL2
C
      INTEGER NST, PARSE(500,2), GOTO(200,2), ACT(2000,2), MAXACT
      COMMON /PTABLE/ NST, PARSE, GOTO, ACT, MAXACT
C
      IF (NXT .GT. MAXACT) GO TO 100
      ACT(NXT,1) = VAL1
      ACT(NXT,2) = VAL2
      NXT = NXT + 1
      RETURN
C
  100 WRITE (LUO,1000)
 1000 FORMAT (37H0***  ACTION/GOTO TABLE OVERFLOW  ***,///)
      STOP
      END
      SUBROUTINE PAPRNT
      INTEGER HEADER (18)
      COMMON /LUNITS/ LUI, LUO, LUP
      INTEGER NSYMBS, NTERMS, SYMBS(2,200)
      COMMON /SYMBOL/ NSYMBS, NTERMS, SYMBS
      INTEGER NST, PARSE(500,2), GOTO(200,2), ACT(2000,2), MAXACT
      COMMON /PTABLE/ NST, PARSE, GOTO, ACT, MAXACT
C
      WRITE (LUO,2000)
 2000 FORMAT (13H0ACTION TABLE,//)
      DO 40 IST = 1,NST
	 IF (PARSE(IST,1) .LT. 0) GO TO 40
	 WRITE (LUO,2100) IST
 2100	 FORMAT (1H0,I3,1H:)
	 IF (IST .EQ. NST) GO TO 20
	 IST1 = IST + 1
	 DO 10 IST2 = IST1,NST
	    IF (PARSE(IST2,1) .NE. -IST) GO TO 10
	    WRITE (LUO,2200) IST2
 2200	    FORMAT (I4,1H:)
   10	 CONTINUE
   20	 IF (PARSE(IST,2) .EQ. 0) GO TO 40
	 NA1 = PARSE(IST,1)
	 NA2 = NA1 + PARSE(IST,2) - 1
	 DO 30 IA = NA1,NA2
	    CALL PRACT (ACT(IA,1),ACT(IA,2))
   30	 CONTINUE
   40 CONTINUE
      WRITE (LUO,3000)
 3000 FORMAT (11H1GOTO TABLE,//)
      DO 80 ISYM = 1,NTERMS
	 IF (GOTO(ISYM,1) .LT. 0) GO TO 80
	 IF (GOTO(ISYM,2) .EQ. 0) GO TO 80
	 WRITE (LUO,3100) SYMBS(1,ISYM), SYMBS(2,ISYM)
 3100	 FORMAT (1H0,2A4,2H :)
	 IF (ISYM .EQ. NTERMS) GO TO 60
	 ISYM1 = ISYM + 1
	 DO 50 ISYM2 = ISYM1,NTERMS
	    IF (GOTO(ISYM2,1) .EQ. -ISYM)
     +	       WRITE (LUO,3200) SYMBS(1,ISYM2), SYMBS(2,ISYM2)
 3200	    FORMAT (1H ,2A4,2H :)
   50	 CONTINUE
   60	 NG1 = GOTO(ISYM,1)
	 NG2 = NG1 + GOTO(ISYM,2) - 1
	 DO 70 IG = NG1,NG2
	    CALL PRGOTO (ACT(IG,1),ACT(IG,2))
   70	 CONTINUE
   80 CONTINUE
      RETURN
      END
      SUBROUTINE PRACT (INSYM,IACT)
      INTEGER NSYMBS, NTERMS, SYMBS(2,200)
      COMMON /SYMBOL/ NSYMBS, NTERMS, SYMBS
      INTEGER NPRODS, LHS(200), PLEN(200), RHS(8,200)
      COMMON /PRODCT/ NPRODS, LHS, PLEN, RHS
      COMMON /LUNITS/ LUI, LUO, LUP
      INTEGER SYM(2,9)
      COMMON /TEMPS/ SYM
      INTEGER KTYPE(2,2)
      DATA KTYPE(1,1)/4HREDU/, KTYPE(1,2)/2HCE/,
     +	   KTYPE(2,1)/4HSHIF/, KTYPE(2,2)/2HT,/
C
      IACTYP = IACT / 1000
      IVAL = MOD(IACT,1000)
      GO TO (300,300,200,100), IACTYP
C
  100 CONTINUE
      WRITE (LUO,1000)
 1000 FORMAT (6X,5HERROR)
      RETURN
C
  200 CONTINUE
      WRITE (LUO,2100) SYMBS(1,INSYM), SYMBS(2,INSYM), IVAL
 2100 FORMAT (6X,12HIF (INPUT = ,2A4,7H) SHIFT,I4)
      RETURN
C
  300 CONTINUE
      I = LHS(IVAL)
      SYM(1,1) = SYMBS(1,I)
      SYM(2,1) = SYMBS(2,I)
      LEN = PLEN(IVAL)
      IF (LEN .EQ. 0) GO TO 306
      DO 304 L = 1,LEN
	 I = RHS(L,IVAL)
	 SYM(1,L+1) = SYMBS(1,I)
	 SYM(2,L+1) = SYMBS(2,I)
  304 CONTINUE
  306 LEN = LEN + 1
      IF (INSYM) 310,310,320
  310 CONTINUE
	 WRITE (LUO,3100) (SYM(1,I),SYM(2,I),I=1,LEN)
 3100	 FORMAT (6X,7HREDUCE ,2A4,4H ::=,8(1X,2A4))
	 RETURN
  320 CONTINUE
	 WRITE (LUO,3200) SYMBS(1,INSYM), SYMBS(2,INSYM),
     +			  KTYPE(IACTYP,1), KTYPE(IACTYP,2),
     +			  (SYM(1,I),SYM(2,I),I=1,LEN)
 3200	 FORMAT (6X,12HIF (INPUT = ,2A4,2H) ,A4,A3,
     +		 2A4,4H ::=,8(1X,2A4))
	 RETURN
C
      END
      SUBROUTINE PRGOTO (INST,NXTST)
C
      INTEGER NSYMBS, NTERMS, SYMBS(2,200)
      COMMON /SYMBOL/ NSYMBS, NTERMS, SYMBS
      INTEGER NPRODS, LHS(200), PLEN(200), RHS(8,200)
      COMMON /PRODCT/ NPRODS, LHS, PLEN, RHS
      COMMON /LUNITS/ LUI, LUO, LUP
      INTEGER SYM(2,9)
      COMMON /TEMPS/ SYM
C
      NXTYP = NXTST / 1000
      NXTVAL = MOD(NXTST,1000)
      GO TO (200,200,100), NXTYP
C
  100 CONTINUE
      IF (INST) 110,110,120
  110 CONTINUE
	 WRITE (LUO,1100) NXTVAL
 1100	 FORMAT (12X,5HGO TO,I4)
	 RETURN
  120 CONTINUE
	 WRITE (LUO,1200) INST, NXTVAL
 1200	 FORMAT (12X,11HIF (STATE =,I4,7H) GO TO,I4)
	 RETURN
C
  200 CONTINUE
      I = LHS(NXTVAL)
      SYM(1,1) = SYMBS(1,I)
      SYM(2,1) = SYMBS(2,I)
      LEN = PLEN(NXTVAL)
      IF (LEN .EQ. 0) GO TO 206
      DO 204 L = 1,LEN
	 I = RHS(L,NXTVAL)
	 SYM(1,L+1) = SYMBS(1,I)
	 SYM(2,L+1) = SYMBS(2,I)
  204 CONTINUE
  206 LEN = LEN + 1
      IF (INST) 210,210,220
  210 CONTINUE
	 WRITE (LUO,2100) (SYM(1,I),SYM(2,I),I=1,LEN)
 2100	 FORMAT (12X,7HREDUCE ,2A4,4H ::=,8(1X,2A4))
	 RETURN
  220 CONTINUE
      WRITE (LUO,2200) INST, (SYM(1,I),SYM(2,I),I=1,LEN)
 2200	 FORMAT (12X,11HIF (STATE =,I4,9H) REDUCE ,
     +		 2A4,4H ::=,8(1X,2A4))
	 RETURN
C
      END
      SUBROUTINE PARCHK (PRFLAG)
      INTEGER PRFLAG(10)
C
C***********************************************************************
C
C	 THIS SUBROUTINE TESTS THE PARSER TABLES FOR THE PRESENCE OF
C     CONFLICTS.  IF THERE ARE ANY, THEN IT ABORTS THE PROGRAM.
C
C***********************************************************************
C
      INTEGER NSYMBS, NTERMS, SYMBS(2,200)
      COMMON /SYMBOL/ NSYMBS, NTERMS, SYMBS
      INTEGER NST, PARSE(500,2), GOTO(200,2), ACT(2000,2), MAXACT
      COMMON /PTABLE/ NST, PARSE, GOTO, ACT, MAXACT
      COMMON /LUNITS/ LUI, LUO, LUP
      INTEGER HEADER (18)
      COMMON /PRHEAD/ HEADER
C     -SYMS- IS USED IN SUBROUTINE -PRACT-
      INTEGER SYMS(2,9), SEL(200,2)
      COMMON /TEMPS/ SYMS, SEL
      LOGICAL RESOLV
      COMMON /RESOLV/ RESOLV
      LOGICAL CONFL
C
      CONFL = .FALSE.
      DO 40 IST = 1,NST
	 NACT = PARSE(IST,2)
	 IF (NACT .EQ. 0) GO TO 35
	 IF (NACT .EQ. 1) GO TO 40
	 IACT1 = PARSE(IST,1)
	 IACT2 = IACT1 + NACT - 1
	 NSEL = 1
	 SEL(1,1) = -1
	 DO 30 IACT = IACT1,IACT2
	    KSYM = ACT(IACT,1)
	    DO 10 ISEL = 1,NSEL
	       IF (SEL(ISEL,1) .EQ. KSYM) GO TO 20
   10	    CONTINUE
	    NSEL = NSEL + 1
	    SEL(NSEL,1) = KSYM
	    SEL(NSEL,2) = 1
	    GO TO 30
   20	    CONTINUE
	    SEL(ISEL,2) = SEL(ISEL,2) + 1
   30	 CONTINUE
	 DO 34 ISEL = 2,NSEL
	    IF (SEL(ISEL,2) .EQ. 1) GO TO 34
	    KSYM = SEL(ISEL,1)
	    WRITE (LUO,1000) IST, SYMBS(1,KSYM), SYMBS(2,KSYM)
 1000	    FORMAT (23H0***  CONFLICT IN STATE,I4,12H ON INPUT = ,2A4)
	    IF (.NOT. RESOLV) CONFL = .TRUE.
	    IF (CONFL) GO TO 34
	    READ (LUI,4000) ISTR, ISYMR1, ISYMR2, NACTR
 4000	    FORMAT (I3,1X,2A4,1X,I2)
	    CONFL = ISTR.NE.IST .OR. ISYMR1.NE.SYMBS(1,KSYM) .OR.
     +		    ISYMR2.NE.SYMBS(2,KSYM) .OR. NACTR.GT.SEL(ISEL,2)
     +		    .OR. NACTR.LE.0
	    IF (CONFL) GO TO 34
	    IACTR = 1
	    IACT2 = IACT2 - SEL(ISEL,2) + 1
	    JACT = IACT1
	    DO 33 IACT = IACT1,IACT2
   31	       IF (ACT(JACT,1).NE.KSYM .OR. IACTR.EQ.NACTR) GO TO 32
		  JACT = JACT + 1
		  IACTR = IACTR + 1
		  GO TO 31
   32	       ACT(IACT,1) = ACT(JACT,1)
	       ACT(IACT,2) = ACT(JACT,2)
	       JACT = JACT + 1
	       IF (ACT(IACT,1) .NE. KSYM) GO TO 33
		  CALL PRACT (KSYM,ACT(IACT,2))
		  IACTR = IACTR + 1
   33	    CONTINUE
	    PARSE(IST,2) = IACT2 - IACT1 + 1
   34	 CONTINUE
	 GO TO 40
   35	 CONTINUE
	 WRITE (LUO,1500) IST
 1500	 FORMAT (40H0***  NO INPUT SYMBOLS ACCEPTED IN STATE,I4)
	 CONFL = .TRUE.
   40 CONTINUE
      IF (.NOT. CONFL) RETURN
C
      IF (PRFLAG(1) .EQ. 1) CALL INPRNT
      IF (PRFLAG(2) .EQ. 0) CALL STPRNT
      IF (PRFLAG(3) .EQ. 0) CALL PRFT1
      IF (PRFLAG(4) .NE. 0) GO TO 100
	 WRITE (LUO,2000) HEADER
 2000	 FORMAT (1H1,41X,38HSLR(1) ANALYSER -- BASIC PARSER TABLES,/
     +		 1H0,24X,18A4,/)
	 CALL PAPRNT
  100 CONTINUE
      WRITE (LUO,3000)
 3000 FORMAT (///)
      STOP
      END
      SUBROUTINE ORDERC
C
C***********************************************************************
C
C	 THIS ROUTINE APPLIES THE TOPOLOGICAL SORTING ALGORITHM OF KNUTH
C     (THE ART OF COMPUTER PROGRAMMING, VOL. 1, PP. 258-263) TO THE PAR-
C     TIAL ORDERING DEFINED BY:  A < B IF THERE IS A CHAIN PRODUCTION
C     A ::= B.	THE LINEAR ORDERING IS USED TO ORDER THE APPLICATION OF
C     THE CHAIN-PRODUCTION ELIMINATION PROCESS.
C
C***********************************************************************
C
      INTEGER NSYMBS, NTERMS, SYMBS(2,200)
      COMMON /SYMBOL/ NSYMBS, NTERMS, SYMBS
      INTEGER NPRODS, LHS(200), PLEN(200), RHS(8,200)
      COMMON /PRODCT/ NPRODS, LHS, PLEN, RHS
      LOGICAL CHAIN(200)
      COMMON /CHNPRD/ CHAIN
      INTEGER COUNT(200), QLINK(200), SUC(200), NEXT(200), TOP(200)
      COMMON /TEMPS/ COUNT, QLINK, SUC, NEXT, TOP
      INTEGER NAMES, NAME(200), OUT(200)
      COMMON /LOOK/ NAMES, NAME, OUT
      COMMON /LUNITS/ LUI, LUO, LUP
      INTEGER N, AVAIL, P, R, F
C
C     T1.  INITIALIZE
C
      NAMES = 0
      AVAIL = 0
      DO 10 K = 1,200
	 COUNT(K) = 0
	 QLINK(K) = 0
	 TOP(K) = 0
   10 CONTINUE
C
C     T2.  NEXT RELATION
C
      DO 20 IPROD = 1,NPRODS
	 IF (.NOT. CHAIN(IPROD)) GO TO 20
	 IF (RHS(1,IPROD) .GT. NTERMS) GO TO 20
	 J = INSERT(RHS(1,IPROD))
	 K = INSERT(LHS(IPROD))
C
C     T3.  RECORD THE RELATION
C
	 COUNT(K) = COUNT(K) + 1
	 AVAIL = AVAIL + 1
	 P = AVAIL
	 SUC(P) = K
	 NEXT(P) = TOP(J)
	 TOP(J) = P
   20 CONTINUE
C
C     T4.  SCAN FOR ZEROS
C
      IF (NAMES .EQ. 0) RETURN
      N = NAMES
      R = 200
      DO 30 K = 1,N
	 IF (COUNT(K) .NE. 0) GO TO 30
	 QLINK(R) = K
	 R = K
   30 CONTINUE
      F = QLINK(200)
C
C     T5.  OUTPUT FRONT OF QUEUE
C
   40 IF (F .EQ. 0) RETURN
	 OUT(N) = F
	 N = N - 1
	 P = TOP(F)
C
C     T6.  ERASE RELATIONS
C
   50	 IF (P .EQ. 0) GO TO 70
	    ISP = SUC(P)
	    COUNT(ISP) = COUNT(ISP) - 1
	    IF (COUNT(ISP) .NE. 0) GO TO 60
	       QLINK(R) = SUC(P)
	       R = SUC(P)
   60	    CONTINUE
	    P = NEXT(P)
	 GO TO 50
C
C     T7.  REMOVE FROM QUEUE
C
   70	 F = QLINK(F)
      GO TO 40
      END
      FUNCTION INSERT(ISYM)
C
      INTEGER NAMES, NAME(200), OUT(200)
      COMMON /LOOK/ NAMES, NAME, OUT
C
      IF (NAMES .EQ. 0) GO TO 20
      DO 10 INS = 1,NAMES
	 IF (NAME(INS) .EQ. ISYM) GO TO 30
   10 CONTINUE
   20 NAMES = NAMES + 1
      NAME(NAMES) = ISYM
      INSERT = NAMES
      RETURN
   30 INSERT = INS
      RETURN
      END
      SUBROUTINE DELCHN
C
C***********************************************************************
C
C	 THIS ROUTINE MODIFIES THE PARSER TABLES TO BYPASS ANY REDUC-
C     TIONS BY CHAIN PRODUCTIONS, WHICH CAN BE ELIMINATED WITHOUT
C     INCREASING THE TOTAL NUMBER OF STATES.
C
C***********************************************************************
C
      INTEGER NPRODS, LHS(200), PLEN(200), RHS(8,200)
      COMMON /PRODCT/ NPRODS, LHS, PLEN, RHS
      LOGICAL CHAIN(200)
      COMMON /CHNPRD/ CHAIN
      INTEGER NST, PARSE(500,2), GOTO(200,2), ACT(2000,2), MAXACT
      COMMON /PTABLE/ NST, PARSE, GOTO, ACT, MAXACT
      INTEGER NAMES, NAME(200), OUT(200)
      COMMON /LOOK/ NAMES, NAME, OUT
C
      IF (NAMES .EQ. 0) RETURN
      DO 20 I = 1,NAMES
	 IOUT = OUT(I)
	 INAME = NAME(IOUT)
	 IF (GOTO(INAME,2) .EQ. 0) GO TO 40
	 IA1 = GOTO(INAME,1)
	 IA2 = IA1 + GOTO(INAME,2) - 1
	 DO 10 IA = IA1,IA2
	    IST = ACT(IA,1)
	    ASSIGN 10 TO IBACK
	    GO TO 100
   10	 CONTINUE
   20 CONTINUE
      DO 40 IST = 1,NST
	 IA1 = PARSE(IST,1)
	 IA2 = IA1 + PARSE(IST,2) - 1
	 DO 30 IA = IA1,IA2
	    ASSIGN 30 TO IBACK
	    GO TO 100
   30	 CONTINUE
   40 CONTINUE
      RETURN
C
  100 CONTINUE
      IF (ACT(IA,2)/1000 .NE. 2) GO TO IBACK, (10,30)
      IP = MOD(ACT(IA,2),1000)
      IF (.NOT. CHAIN(IP)) GO TO IBACK, (10,30)
      ILHS = LHS(IP)
      IL1 = GOTO(ILHS,1)
      IL2 = IL1 + GOTO(ILHS,2) - 1
      DO 110 IL = IL1,IL2
	 IF (ACT(IL,1) .EQ. IST) GO TO 120
  110 CONTINUE
  120 ACT(IA,2) = ACT(IL,2)
      GO TO IBACK, (10,30)
C
      END
      SUBROUTINE TDEF
C
C***********************************************************************
C
C	 THIS ROUTINE REDUCES THE SIZE OF THE PARSER ACTION TABLES BY
C     ELIMINATING ALL REFERENCES TO THE MOST COMMON REDUCE ACTION (IF
C     ANY) IN EACH STATE, AND INTRODUCING A DEFAULT ACTION FOR IT.
C
C***********************************************************************
C
      INTEGER NST, PARSE(500,2), GOTO(200,2), ACT(2000,2), MAXACT
      COMMON /PTABLE/ NST, PARSE, GOTO, ACT, MAXACT
      INTEGER LRED(200), NRED(200)
      COMMON /TEMPS/ LRED, NRED
C
      LRED(1) = 0
      NRED(1) = 0
      DO 80 IST = 1,NST
      IA1 = PARSE(IST,1)
      IA2 = IA1 + PARSE(IST,2) - 1
      IF (ACT(IA2,1).EQ.0) GO TO 80
      NL = 1
      DO 30 IA = IA1,IA2
	 IF (ACT(IA,2)/1000 .NE. 1) GO TO 30
	 DO 10 IL = 1,NL
	    IF (LRED(IL) .EQ. ACT(IA,2)) GO TO 20
   10	 CONTINUE
	 NL = NL + 1
	 LRED(NL) = ACT(IA,2)
	 NRED(NL) = 0
	 IL = NL
   20	 NRED(IL) = NRED(IL) + 1
   30 CONTINUE
      NDEF = 0
      DO 40 IL = 1,NL
	 IF (NRED(IL) .LT. NDEF) GO TO 40
	 LDEF = LRED(IL)
	 NDEF = NRED(IL)
   40 CONTINUE
      IA2 = IA2 - NDEF
      IF (NDEF .EQ. PARSE(IST,2)) GO TO 75
      IAM = IA1
      DO 70 IA = IA1,IA2
   50	 IF (ACT(IAM,2) .NE. LDEF) GO TO 60
	    IAM = IAM + 1
	    GO TO 50
   60	 ACT(IA,1) = ACT(IAM,1)
	 ACT(IA,2) = ACT(IAM,2)
	 IAM = IAM + 1
   70 CONTINUE
   75 ACT(IA2+1,1) = 0
      ACT(IA2+1,2) = LDEF
      PARSE(IST,2) = PARSE(IST,2) - NDEF + 1
   80 CONTINUE
      RETURN
      END
      SUBROUTINE GDEF
C
C***********************************************************************
C
C     THIS ROUTINE REDUCES THE SIZE OF THE PARSER GOTO TABLES BY
C     INTRODUCING A DEFAULT ACTION FOR THE MOST COMMON ACTION ON
C     EACH SYMBOL.
C
C***********************************************************************
C
      INTEGER NST, PARSE(500,2), GOTO(200,2), ACT(2000,2), MAXACT
      COMMON /PTABLE/ NST, PARSE, GOTO, ACT, MAXACT
      INTEGER NSYMBS, NTERMS, SYMBS(2,200)
      COMMON /SYMBOL/ NSYMBS, NTERMS, SYMBOL
      INTEGER LGO(200), NGO(200)
      COMMON /TEMPS/ LGO, NGO
C
      LGO(1) = 0
      NGO(1) = 0
      DO 90 ISYM = 1,NTERMS
	 IF (GOTO(ISYM,2) .EQ. 0) GO TO 90
	 NG1 = GOTO(ISYM,1)
	 NG2 = NG1 + GOTO(ISYM,2) - 1
	 NL = 1
	 DO 30 IG = NG1,NG2
	    DO 10 IL = 1,NL
	       IF (LGO(IL) .EQ. ACT(IG,2)) GO TO 20
   10	    CONTINUE
	    NL = NL + 1
	    LGO(NL) = ACT(IG,2)
	    NGO(NL) = 0
	    IL = NL
   20	    NGO(IL) = NGO(IL) + 1
   30	 CONTINUE
	 NDEF = 0
	 DO 40 IL = 1,NL
	    IF (NGO(IL) .LT. NDEF) GO TO 40
	    LDEF = LGO(IL)
	    NDEF = NGO(IL)
   40	 CONTINUE
	 NG2 = NG2 - NDEF
	 IF (NDEF .EQ. GOTO(ISYM,2)) GO TO 80
	 IGM = NG1
	 DO 70 IG = NG1,NG2
   50	    IF (ACT(IGM,2) .NE. LDEF) GO TO 60
	       IGM = IGM + 1
	       GO TO 50
   60	    ACT(IG,1) = ACT(IGM,1)
	    ACT(IG,2) = ACT(IGM,2)
	    IGM = IGM + 1
   70	 CONTINUE
   80	 ACT(NG2+1,1) = 0
	 ACT(NG2+1,2) = LDEF
	 GOTO(ISYM,2) = GOTO(ISYM,2) - NDEF + 1
   90 CONTINUE
      RETURN
      END
      SUBROUTINE TDUP
      INTEGER NST, PARSE(500,2), GOTO(200,2), ACT(2000,2), MAXACT
      COMMON /PTABLE/ NST, PARSE, GOTO, ACT, MAXACT
      NST1 = NST - 1
      DO 50 IST = 1,NST1
	 IF (PARSE(IST,1) .LT. 0) GO TO 50
	 NA1 = PARSE(IST,1)
	 NA2 = NA1 + PARSE(IST,2) - 1
	 IST1 = IST + 1
	 DO 40 JST = IST1,NST
	    IF (PARSE(JST,1) .LT. 0) GO TO 40
	    IF (PARSE(JST,2) .NE. PARSE(IST,2)) GO TO 40
	    JA = PARSE(JST,1)
	    NAJ = JA + PARSE(JST,2) - 1
	    DO 30 IA = NA1,NA2
	       DO 10 JA1 = JA,NAJ
		  IF (ACT(JA1,1) .NE. ACT(IA,1)) GO TO 10
		  IF (ACT(JA1,2) .EQ. ACT(IA,2)) GO TO 20
   10	       CONTINUE
	       GO TO 40
   20	       IF (JA1 .EQ. JA) GO TO 25
		  ITEMP = ACT(JA,1)
		  ACT(JA,1) = ACT(JA1,1)
		  ACT(JA1,1) = ITEMP
		  ITEMP = ACT(JA,2)
		  ACT(JA,2) = ACT(JA1,2)
		  ACT(JA1,2) = ITEMP
   25	       JA = JA + 1
   30	    CONTINUE
	    PARSE(JST,1) = -IST
   40	 CONTINUE
   50 CONTINUE
      RETURN
      END
      SUBROUTINE GDUP
C
C***********************************************************************
C
C     THIS ROUTINE REDUCES THE SIZE OF THE GOTO TABLES BY TESTING FOR
C     SYMBOLS WITH IDENTICAL GOTO SETS.  IF SYM(I) AND SYM(J) HAVE THE
C     SAME GOTO SETS, WHERE I < J, THEN GOTO(J,1) IS SET TO -GOTO(I,1)
C     (THE MINUS SIGN INDICATES THAT THIS IS NOT THE FIRST SYMBOL WITH
C     THIS SET).
C
C***********************************************************************
C
      INTEGER NSYMBS, NTERMS, SYMBS(2,200)
      COMMON /SYMBOL/ NSYMBS, NTERMS, SYMBS
      INTEGER NST, PARSE(500,2), GOTO(200,2), ACT(2000,2), MAXACT
      COMMON /PTABLE/ NST, PARSE, GOTO, ACT, MAXACT
C
      NTRM1 = NTERMS - 1
      DO 30 ISYM = 1,NTRM1
	 IF (GOTO(ISYM,2) .EQ. 0) GO TO 30
	 IF (GOTO(ISYM,1) .LT. 0) GO TO 30
	 IS1 = ISYM + 1
	 NG1 = GOTO(ISYM,1)
	 NG2 = NG1 + GOTO(ISYM,2) - 1
	 DO 20 JSYM = IS1,NTERMS
	    IF (GOTO(JSYM,2) .NE. GOTO(ISYM,2)) GO TO 20
	     JG = GOTO(JSYM,1)
	    DO 10 IG = NG1,NG2
	       IF (ACT(IG,1) .NE. ACT(JG,1)) GO TO 20
	       IF (ACT(IG,2) .NE. ACT(JG,2)) GO TO 20
	       JG = JG + 1
   10	    CONTINUE
	    GOTO(JSYM,1) = -ISYM
   20	 CONTINUE
   30 CONTINUE
      RETURN
      END
      SUBROUTINE PUNCH
C
      COMMON /LUNITS/ LUI, LUO, LUP
      INTEGER NSYMBS, NTERMS, SYMBS(2,200)
      COMMON /SYMBOL/ NSYMBS, NTERMS, SYMBS
      INTEGER NPRODS, LHS(200), PLEN(200), RHS(8,200)
      COMMON /PRODCT/ NPRODS, LHS, PLEN, RHS
      INTEGER NST, PARSE(500,2), GOTO(200,2), ACT(2000,2), MAXACT
      COMMON /PTABLE/ NST, PARSE, GOTO, ACT, MAXACT
C     WE AREN'T USING THE /IGTAB/ COMMON BLOCK ANY MORE,
C     SO WE CAN USE IT TO STORE OUR COMPRESSED ACTION AND GOTO TABLES.
      INTEGER ACTBL (2000,2)
      COMMON /IGTAB/ ACTBL
C
      WRITE (LUP,2000) NSYMBS, NTERMS
      WRITE (LUP,1000) (SYMBS(1,ISYM),SYMBS(2,ISYM),ISYM=1,NSYMBS)
C
      WRITE (LUP,2000) NPRODS
      DO 110 IP = 1,NPRODS
	 LEN = PLEN(IP)
	 IF (LEN .EQ. 0) WRITE (LUP,2000) LHS(IP), LEN
	 IF (LEN .NE. 0)
     +	    WRITE (LUP,2000) LHS(IP), LEN, (RHS(I,IP),I=1,LEN)
  110 CONTINUE
C
      NACT = 1
      DO 220 IST = 1,NST
	 IF (PARSE(IST,1) .LT. 0) GO TO 220
	 IA1 = PARSE(IST,1)
	 IA2 = IA1 + PARSE(IST,2) - 1
	 PARSE(IST,1) = NACT
	 DO 220 IA = IA1,IA2
	    ACTBL(NACT,1) = ACT(IA,1)
	    ACTBL(NACT,2) = ACT(IA,2)
	    NACT = NACT + 1
  210	 CONTINUE
  220 CONTINUE
      NACT = NACT - 1
      WRITE (LUP,2000) NST, NACT
      WRITE (LUP,2000) (PARSE(IST,1),PARSE(IST,2),IST=1,NST)
      WRITE (LUP,2000) (ACTBL(IA,1),ACTBL(IA,2),IA=1,NACT)
C
      NGOTO = 1
      DO 320 ISYM = 1,NTERMS
	 IF (GOTO(ISYM,1) .LT. 0) GO TO 320
      IF (GOTO(ISYM,2) .EQ. 0) GO TO 320
	 IG1 = GOTO(ISYM,1)
	 IG2 = IG1 + GOTO(ISYM,2) - 1
	 GOTO(ISYM,1) = NGOTO
	 DO 310 IG = IG1,IG2
	    ACTBL(NGOTO,1) = ACT(IG,1)
	    ACTBL(NGOTO,2) = ACT(IG,2)
	    NGOTO = NGOTO + 1
  310	 CONTINUE
  320 CONTINUE
      NGOTO = NGOTO - 1
      WRITE (LUP,2000) NTERMS, NGOTO
      WRITE (LUP,2000) (GOTO(ISYM,1),GOTO(ISYM,2),ISYM=1,NTERMS)
      WRITE (LUP,2000) (ACTBL(IG,1),ACTBL(IG,2),IG=1,NGOTO)
      RETURN
C
 1000 FORMAT (8(2A4,2X))
 2000 FORMAT (16I5)
      END
    c{gH