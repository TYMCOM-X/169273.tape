begin "TUMS"

require "(SAILIB)SAIL.DEF" source!file;
require "(SAILIB)FRMRUN.REQ" source!file;
require "ARGS.REQ" source!file;
require "FLIB.REQ" source!file;
require "CORE0.REQ" source!file;
require "MAILIB.REQ" source!file;
!get!module(RANDIO);
!get!definitions(ASSERT);
!get!definitions(GOGTAB);
!get!definitions(PROCES);
!get!definitions(TYMINT);

require 2048 new!items;
require 40960 string!space;
require 100 polling!interval;
require processes;

require !xwd('45,'6) version;

preload!with
"version 14:

   o	RESEND command generates message with old headers intact but adds
	new addressees - an alternative to FORWARD.

   o	FORWARD command inserts text automatically.

   o	Profile variable AUTO.BCC is address(es) to automatically copy on all
	messages you send - allows it to be on another system.

   o	Fixed bug in LIST ? causing messages to be listed following help.
",
"version 15:

   o	Fixed bug causing text field to disappear when messages are RESENT.
",
"version 16:

   o	Added new profile variable, PSEUDONYMS, which may be set to a list of
	names you go by for use in deciding if a message is from you or not:
		SET PSEUDONYMS JOHN JDOE TYM.J/DOE
	Do not include the host name or domain.

   o	Added new message element selectors, TO ME and FROM ME (use TO ""ME""
	or FROM ""ME"" if you mean it literally) will select from your logged
	in name and all your pseudonyms:
		LIST FROM ME

   o	The UNDELETE command no longer requires ""ALL"".

   o	New profile variable ARCHIVE.FILE (normally null) may contain the
	name of a .MSG file to move messages to when they are expunged:
		SET ARCHIVE.FILE (USER)ARCHIV.MSG
	Note: always include user name in case you run TUMS when you're
	GFD'd to another directory!

   o	Added NEWS command to show whats new.
",
"version 17:

   o	ALIASes may now contain a list of addresses, including other
	aliases.  Recursion is detected and gracefully suppressed.

   o	Fixes bug in automatic news.

   o	Fixes bug causing runtim error when message file is empty.

   o	Automatically adds new messages to READ set if no arguments
	were given in last READ command.  This makes NEXT behave
	more intuitively.
",
"version 20:

   o	Corrected alphabetization of commands in help message.

   o	Fixed address labels.

   o	Now recognizes labels/aliases inside input text mode.
",
"version 21:

   o	Added ^C trapping.
",
"version 22:

   o	Fixed SET <boolean> to indicate value changed.
",
"version 23:

   o	Added keywords: KEYWORDS command, KEY/KEYWORDS message expression
	functions, ""K"" format in LIST.FORMAT.

   o	New message expression function #n selects the last ""n"" messages.

   o	Changed ^C trapping code to use defered interrupts so everything
	can get cleaned up properly.
",
"version 24:

   o	Added ~k subcommand in text input mode to allow specification of
	Keywords.
",
"version 25:

   o	Added ""Re:"" to automatic subject line in REPLY command.
",
"version 26:

   o	Fixed bug causing nulls to appear in address lists.
",
"version 27:

   o	Enhanced ANSWER command to show more of generated header.
",
"version 30:

   o	Enhanced ANSWER command to show original message ID in header.

   o	Added MAILER command to attempt immediate delivery of queued
	non-local messages.

   o	Automatically runs MAILER on QUIT, EXIT, LOGOUT if there have
	been any non-local messages queued.

   o	Fixes bug omiting message text in COPY and MOVE commands.
",
"version 31:

   o	Fixes problem when run with empty mail file.

   o	Allows CCL call if only want to send:
		TUMS address-list
	This will not check for new mail or execute INIT commands.
	It will process TUMS.INI if it exists.
",
"version 32:

   o	Automatic subject field now ignores tokens that begin with punctuation.
",
"version 33:

   o	Profile variable LIST.DEFAULT may be set to a default message
	expression for the LIST command (e.g. ""SET LIST.DEFAULT *"").

   o	Added ID to message set expressions (e.g. ""READ ID A12345"").

   o	""TO"" message set expression now scans both TO and CC fields.
",
"version 34:

   o	Changed automatic check for mail to work with new mail waiting
	scheme in P034/N10 and later.
",
"version 35:

   o	Changed LOGOUT command to abort in the presence of arguments.
",
"version 36:

   o	Added HEADINGS command.
",
"version 37:

   o	Changed handling of n:m in message set expressions where m is
	beyond last message.

   o	Changed ""illegal"" to ""unrecognized"" in all error messages.

   o	Removed fields RECEIVED, RETURN-PATH and OTHER from TIX file to
	make it smaller, faster and allow more messages before running
	out of string space.

   o	Now updates message file when keywords are added/deleted.

   o	Removed MAIL.FILE from the profile in preparation for alternate files.
",
"version 40:

   o	Added REPLY.ALIAS to allow aliases to be applied to the From: field
	in conjunction with the ANSWER and REPLY commands.

   o	Added special processing to message archiving.  The following special
	strings may be included in the profile variable ARCHIVE.FILE to allow
	messages to be collected in different archive files based on the date
	of the message:
		<y>	year (2 digits)
		<q>	quarter (1 digit)
		<m>	month (2 digits)
		<d>	day (2 digits)
	For example, setting ARCHIVE.FILE with the command
		SET ARCHIVE.FILE AR<YM>.MSG
		PROFILE
	will create archive files of the form ARyymm.MSG.  This facilitates
	searching for old messages and file cleanup.
",
"version 41:

   o	Added NOARCHIVE option to following commands:
		DELETE[ NOARCHIVE]
		MOVE[ ARCHIVE] filename message-expression
		MOVE[ NOARCHIVE] filename message-expression
		NEXT[ DELETE[ NOARCHIVE]]
	NOARCHIVE may be abbreviated as NOARC, ARCHIVE may be abbreviated
	as ARC.  If the archive option is absent from the MOVE command,
	the action is determined by the ARCHIVE.MOVED profile variable.

   o	Added profile variable ARCHIVE.MOVED which defaults to true.  May
	be reset with
		SET NO ARCHIVE.MOVED
		PROFILE
	If set, messages deleted by the MOVE command will be archived by
	the next expunging operation.
",
"version 42:

   o	Made changes to RESEND command to include all fields from original
	message except Return-Path in new message.  Also provides hooks
	for maiRPath to fix bug causing resent messages to be returned to
	the original sender in case of delivery failure.
",
"version 43:

   o	Clear CORE on exit to conserve virtual memory (disk).
",
"version 44:

   o	Include ""Marked"" flag in message banner if appropriate.

   o	Improved I/O package.

   o	Defaults message file extension to .MSG and print to .PRT.

   o	Added ""OPEN"" and ""CLOSE"" commands to open alternate message
	files.  Must close alternate file to receive mail.

   o	The PRINT command will now write the default file in the user's
	logged in directory (as opposed to the GFD'd directory).

   o	Handles distribution list and journal addresses as in:
		SEND username/filename
	where the file (username)filename.TUM begins with
		#TUMS EXEC program	- for a received process
		#TUMS JOURNAL		- for a journal file
		#TUMS LIST		- for a distribution list

   o	Improved address parsing to closer follow RFC-821.

   o	OPEN now defaults to extension .MSG.

   o	Fixed several bugs causing SCHPTR past EOF error.

   o	Fixed bug causing record garbage collect routine to ILL INST or
	ILL MEM REF when processing deleted records.

   o	Don't print news for alternate message files.

   o	Added SHOW ALIAS <STR> command to show all aliases referencing the
	specified string.
",
"version 45:

   o	Improved tollerance of phase errors.

   o	Asks user to save unsaved profile variables before leaving TUMS.

   o	Generates security warning if last access by non-owner.

   o	Enables NOTICE TO QUIT interrupt and cleans up when received.

   o	SHOW ALIAS name1 name2 ... namen -- now takes more than one name
	and ignores case on names.

   o	Changes reply and answer to use return path if available.  This
	is more reliable for usenet mail and shouldn't make any difference
	for other mail.

   o	Runs MAILER if necessary after each command rather than waiting
	for end of session.  (makes delivery faster)

   o	Fixes bugs in CONTINUE command.

   o	Improved tollerance of NULLs in messages.
";
string array NEWS['14:'45];

item CmdProcess;		! process item for commands;
item IntProcess;		! interrupt process;
boolean QUIT;			! true to quit program;
set profileChanges;		! set of changed profile variables;
string CmdLine;			! command line being processed;
r!p(file) MailF;		! Mail file record descriptor;
boolean AlternateMF;		! set if alternate message file open;
integer Mail.RPTR;		! Mail counters;
integer deletedChars;		! count of deleted characters;
integer LastNMSG;		! used to notice new messages;
boolean PutNewInRSET;		! used to flag default READ command;

itemvar IV;			! very local temps;
string itemvar SIV;
real itemvar RIV;
integer itemvar IIV;
set itemvar TIV;
list itemvar LIV;

redefine
    !rbEXT = '3,
    !rbSIZ = '5,
    !rbPPN = '1,
    !rbAUT = '26;

record!class MD (
    integer	MSG#;		! number of message;
    integer	FLAGS;		! status flags (see below);
    integer	MSGPTR;		! character pointer of message in file;
    integer	MSGLEN;		! length of message;
    integer	TXTPTR;		! character pointer to text field in file;
    integer	TXTLEN;		! length of text field;
    r!p(MAI)	M );		! pointer to parsed message in memory;

r!p(MD) itemvar array MSGS[1:999];	! messages;
r!p(MD) itemvar MDIV;		! very local temp;

integer NMSG;			! number of current messages;
r!p(MD) itemvar CMSG;		! current message;
set CSET;			! current message set;
set RSET;			! read message set (used by NEXT,PREV);
r!p(MAI) DRAFT;			! draft message;

define mdfDeleted = 1;		! message marked for deletion;
define mdfOld = 2;		! message from previous run;
define mdfRead = 4;		! message has been read (ie. text);
define mdfAnswered = '10;	! message has been answered (ie. reply);
define mdfMarked = '20;		! message has been marked (ie. MARK);
define mdfNoArchive = '40;	! don't archive when expunging;

simple procedure MSGSini;
begin
    integer I;
    own r!p(MD) D;
    for I := 999 downto 1 do
	MSGS[i] := new(D);
end;
require MSGSini initialization;

string JBTUNM;			! logged in user name;
integer brkTrim;		! trim blanks;
integer brkLine;		! line break table;
integer brkTime;		! date/time parsing break table;
integer brkTok;			! upper-case token break table;
integer brkToc;			! any-case token break table;
integer brkQuote;		! quote break table;
integer brkEOT;			! end of text break;
integer brkExprTok;		! expression style tokens;
integer brkPunct;		! break on punct;
integer brkUpCase;		! convert to upper case;
integer brkBlam;		! break on "!";

simple procedure BreakIni;
begin
    define LicReq = !bit(2)+!bit(3)+2*!bit(17);
    if ( calli(!xwd(-1,-'20),'41) land LicReq ) neq LicReq
	then usererr(0,0,"?TUMS.SAV: license OP SY WF required","X");
    JBTUNM :=
	cv6str(calli(!xwd(-1,-'22),'41)) &
	cv6str(calli(!xwd(-1,-'21),'41)) ;
    DEFSSS := DEFPSS := 1024;	! default stacks;
    setbreak( brkTrim_getbreak," "&#ht,null,"XR" );
    setbreak( brkLine_getbreak, #lf&#ff, #cr, "SIN" );
    setbreak( brkTime_getbreak,
	"-./;, "&#ht&crlf, "-./;, "&#ht&crlf, "STINK" );
    setbreak( brkTok_getbreak, ";, "&#ht&crlf, " "&#ht&crlf, "STINK" );
    setbreak( brkToc_getbreak, ";, "&#ht&crlf, " "&#ht&crlf, "STIN" );
    setbreak( brkQuote_getbreak, """", null, "SIN" );
    setbreak( brkEOT_getbreak, #EOT, null, "SIN" );
    setbreak( brkExprTok_getbreak, "()&+- "&#ht, " "&#ht, "RTINK" );
    setbreak( brkPunct_getbreak, "\""<>:,; "&#ht&crlf, " "&#ht&crlf, "STIN" );
    setbreak( brkUpCase_getbreak, null, null, "INK" );
    setbreak( brkBlam_getbreak, "!", null, "SINK" );
end;
require BreakIni initialization[1];
    
simple string procedure getExprTok( reference string S );
begin
    integer B;
    string S1;
    S1 := scan( S, brkExprTok, B );
    return( if length(S1) or not B then S1 else lop(S) );
end;

comment
    This won't compile as an inline expression, so this little procedure
seems to be necessary.  Seems to have something to do with r!p temps.
;
string procedure MyAddress;
begin
    r!p(adr) A;
    A := maiMyAddress;
    return( maiAMake( A ));
end;

set item ALIAS;			! aliases for addresses;
string item ARCHIVE.FILE;	! if non-null - file to put expunged msgs in;
item ARCHIVE.MOVED;		! set to archive moved messages;
string item AUTO.BCC;           ! automatic copies on send;
string item LIST.DEFAULT;	! default set for list command;
string item LIST.FORMAT;	! default format for list command;
string item INCLUDE.SEP;	! included message seperator;
list item INIT;			! init commands;
set item MACRO;			! command macros;
item MACRO.ECHO;		! echo macro expansions;
string item MAIL.FILE;		! the users default mail holding file;
string item PROMPT;		! the prompt string;
string item PROMPT.TEXT;	! the text prompt string;
list item PSEUDONYMS;		! other names I'm known as;
set item REPLY.ALIAS;		! aliases for ANSWER/REPLY;
string item SEND.FROM;		! the default FROM for new messages;

list PROFILE;			! list of profile variables;

define props!set = 1;		! changed by the SET command;
define props!true = 2;	! truth value of boolean (untyped) items;

simple procedure ProfileIni;
begin
    datum(AUTO.BCC) := MyAddress;
    props(ARCHIVE.MOVED) := props!true;
    datum(INCLUDE.SEP) :=
	"----------------------------------------------------------------";
    datum(LIST.DEFAULT) := "CMSG";
    datum(LIST.FORMAT) := "#! D  A  S";
    new!pname( SIV := new( "NEXT DELETE" ), "^K" );
    put SIV in datum(MACRO);
    new!pname( SIV := new( "NEXT" ), "^N" );
    put SIV in datum(MACRO);
    new!pname( SIV := new( "PREVIOUS" ), "^P" );
    put SIV in datum(MACRO);
    props(MACRO.ECHO) := props!true;
    datum(MAIL.FILE) := "DSK:("&JBTUNM&")TUMS.MSG";
    datum(PROMPT) := ">";
    datum(PROMPT.TEXT) := "Enter text (~? for help):";
    datum(SEND.FROM) := MyAddress;
    PROFILE := {{ALIAS,ARCHIVE.FILE,ARCHIVE.MOVED,AUTO.BCC,INCLUDE.SEP,INIT,
	LIST.FORMAT,LIST.DEFAULT,MACRO,MACRO.ECHO,PROMPT,PROMPT.TEXT,
	PSEUDONYMS,SEND.FROM,REPLY.ALIAS}};
end;
require ProfileIni initialization[2];

procedure NtqSvc;
begin
    auxclv( -1, 0, 7 );				! .axCBO (flush output buffer);
    print( crlf& "[notice to quit]" );
    QUIT := "KJOB";
    terminate( CmdProcess );
end;

procedure EscSvc;
begin
    auxclv( -1, 0, 6 );				! .axCBI (flush input buffer);
    auxclv( -1, 0, 7 );				! .axCBO (flush output buffer);
    print( "^C"& crlf );
    terminate( CmdProcess );
end;

simple procedure OnInt;
begin
    own integer array NtqBlk[1:2];
    own integer array EscBlk[1:2];
    IntSet( IntProcess );
    NtqBlk[1] := 2;
    NtqBlk[2] := !hl(-1)+location(NtqSvc);
    EscBlk[1] := 2;
    EscBlk[2] := !hl(-1)+location(EscSvc);
    intmap ( intass('13,10), dfrint, location(NtqBlk[1]) );	! .iaNTQ ;
    enable ( newenb(10) );
    intmap ( tinass(-1,0,11), dfrint, location(EscBlk[1]) );	! .iaESC ;
    enable ( newenb(11) );
end;

define ON = -1, OFF = 0;
simple integer procedure License( integer LIC );
begin
    integer JBTLIC;
    JBTLIC := calli( !xwd(-1,-'20), '41 );	! GETTAB JBTLIC;
    calli( !xwd(LIC lor JBTLIC,JBTLIC), -'10 );	! SETLIC;
    return( !lh(JBTLIC) );			! return old license;
end;

simple boolean procedure MailWaiting;
begin
    boolean JBTPRV;
    JBTPRV := calli( !xwd(-1,6), '41 );		! GETTAB JBTPRV;
    calli( JBTPRV land lnot !bit(8), -'11 );	! SETPRV to turn off bit;
    return( JBTPRV land !bit(8) );		! return true if it was set;
end;

procedure printHelp( string S("M") );
begin
    while length(S) do case lop(S) of begin
	["A"] print( "
Address syntax:
    <adr> ::= one of following:
	username	local user
	username@host	user on host number ""host""
	acct.id@ONTYME	address on Ontyme
	path@tymix.UUCP	address on USENET
	aliasname	address defined by ""SET ALIAS""
    <lst> ::= one of following:
	<adr>		simple address
	<adr>,<lst>	two or more
	TO: <lst>;	labeled list (names for TO field)
	CC: <lst>;	labeled list (names for CC field)
	BCC: <lst>;	labeled list (names for BCC field)
");
	["M"] print( "
Message set expression syntax:
    <ele> ::= one of following:
	n		message number ""n""
	n:m		messages numbered ""n"" through ""m""
	n:*		messages numbered ""n"" or greater
	n#m		""m"" messages beginning with message number ""n""
	#n		last ""n"" messages
	*		all messages
	DELETED		all deleted messages
	NEW		all messages since last QUIT
	READ		all messages that have been read
	ANSWERED	all messages that have been answered
	MARKED		all messages that have been marked by command
	UNDELETED	all messages not deleted
	OLD		all messages before last QUIT
	UNREAD		all messages not read
	UNANSWERED	all messages not answered
	UNMARKED	all messages not marked
	CMSG		current message (most recently read)
	.		abbreviation of ""CMSG""
	CSET		current message-set (most recently selected)
	$		abbreviation of ""CSET""
	LAST		last message
	%		abbrevistion of ""LAST""
	TO x		all messages containing ""x"" in TO or CC fields
	TO ME		all messages sent to current user
	FROM x		all messages containing ""x"" in FROM field
	FROM ME		all message sent from current user
	ID x		all messages containing ""x"" in MESSAGE-ID field
	KEY x		all messages containing ""x"" in KEYWORDS field
	KEYWORDS x	all messages containing ""x"" in KEYWORDS field
	SUBJECT x	all messages containing ""x"" in SUBJECT field
	TEXT x		all messages containing ""x"" in TEXT field
	ANY x		all messages containing ""x"" in any field
	( <exp> )	a parenthesized expression
	NOT <ele>	all messages not specified by <ele>
    <trm> ::= one of the following:
	<ele>		a trivial term
	<trm> & <ele>	set intersection (and)
	<trm> AND <ele>	set intersection
    <exp> ::= one of the following:
	<trm>		a trivial expression
	<exp> <trm>	set union (or) implied operation
	<+ <trm>	set union (or)
	<exp> OR <trm>	set union
	<exp> - <trm>	set subtraction (and not)
	ALL <exp>	include deleted messages
	
Examples:
    1:5 TO ""bob"" FROM ""bob""
			-- any message numbered 1 through 5 or with ""bob"" in
			the TO or FROM field
    $ SUBJECT ""bob""	-- add to the messages in the last set (CSET) any
			message with ""bob"" in the SUBJECT field
" );
	["P"] begin
	    print( "Valid profile variables are:"& crlf );
	    foreach IV | IV in PROFILE do
		print( "  ", IV, crlf );
	end;
	[else]
    end;
end;

simple string procedure strScan( reference string S; reference integer B );
comment
    Behaves like intscan and realscan.  Returns next token if begins with a
    quote ("), then returns text between quotes.
;
begin
    string SS;
    SS := scan( S, brkToc, B );
    if SS = """" then begin
	S := SS[2 to inf]& (if B then B&S else S);
	SS := scan( S, brkQuote, B );
	while S = """" do
	    SS := SS& lop(S)& scan( S, brkQuote, B );
    end;
    return( SS );
end;

simple string procedure cvss( string S );
comment
    Convert a string in the argument to a quoted string for printing.
    Escape embedded quotes, if any.
;
begin
    string SS;
    integer B;
    SS := """"& scan( S, brkQuote, B )& """";
    while B do
	SS := SS& B& scan( S, brkQuote, B )& """";
    return( SS );
end;

simple string procedure Trim( string S );
begin
    integer B;
    scan( S, brkTrim, B );
    return( S );
end;

simple string procedure upper.case( string S );
begin
    integer B;
    return( scan( S, brkUpCase, B ));
end;

simple boolean procedure skequ( string TARG,S );
comment
    Search for a substring kequ TARG within S.
;
begin
    integer TLEN;
    TLEN := length(TARG);
    while length(S) geq TLEN do begin
	if kequ( TARG, S[1 to length(TARG)] ) then return( true );
	lop( S );
    end;
    return( false );
end;

simple boolean procedure CheckToken( reference string S; string T );
begin
    string S1;
    integer B;
    if equ( getExprTok( S1:=S ), T )
	then begin
	    S := S1;
	    return( true );
	end
	else
	    return( false );
end;

simple boolean procedure yes!no( string PROMPT, HELP(null) );
begin
    string S;
    label RETRY;
RETRY:
    print( PROMPT );
    S := inchwl;
    if kequ( S, "NO"[1 to length(S)] ) then return( false );
    if kequ( S, "YES"[1 to length(S)] ) then return( true );
    if length(HELP) and S="?" then begin
	print( HELP& crlf );
	goto RETRY;
    end;
    print( "Answer YES or NO."& crlf );
    goto RETRY;
end;

record!class tim (
    integer YR;
    integer MO;
    integer DA;
    integer HR;
    integer MN;
    integer SC;
    integer TZ );

preload!with
    "Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec";
string array MONTH[1:12];

r!p(tim) procedure TParse( string TIME );
begin
    r!p(tim) T;
    integer SS;
    SS := 0;
    T := new!record( tim );
    while length(TIME) do begin
	string TOK;
	integer X;
	TOK := scan( TIME, brkTime, X );
	if "0" leq TOK leq "9" then begin
	    X := cvd(TOK);
	    case SS of begin
		[0] tim:MO[T] := X;
		[1] tim:DA[T] := X;
		[2] tim:YR[T] := if length(TOK)>2 then X else 1900+X;
		[3] tim:HR[T] := X;
		[4] tim:MN[T] := X;
		[5] tim:SC[T] := X;
		[else]
	    end;
	    SS := SS + 1;
	end
	else begin
	    if SS = 1 then
		for X := 1 upto 12 do 
		    if kequ( MONTH[X], TOK ) then begin
			tim:DA[T] := tim:MO[T];
			tim:MO[T] := X;
			SS := 2;
			done;
		    end;
	end;
    end;
    return( T );
end;

string procedure NameFixup( string SRC, TIME );
begin
    r!p(tim) T;
    string DST;
    T := null!record;
    DST := null;
    while length(SRC) do begin
	integer C;
	C := lop(SRC);
	if C = "<" then begin
	    if T = null!record then T := TParse( TIME );
	    while length(SRC) do case C := lop(SRC) of begin
		["d"]["D"] DST := DST& cvs(100+tim:DA[T])[2 to 3];
		["m"]["M"] DST := DST& cvs(100+tim:MO[T])[2 to 3];
		["q"]["Q"] DST := DST& cvs((tim:MO[T]+2)%3);
		["y"]["Y"] DST := DST& cvs(tim:YR[T])[3 to 4];
		[">"] done;
		[else] DST := DST& C
	    end;
	end
	else DST := DST& C;
    end;
    return( DST );
end;

boolean procedure isMe( string Addr );
begin
    r!p(ADR) A;
    string S;
    integer B;
    A := maiAParse(Addr);
    do S := scan(adr:User[A], brkBlam, B) until B neq "!";
    if kequ(S, JBTUNM) then return (true);
    foreach SIV | SIV in datum(PSEUDONYMS) do
	if kequ(S, datum(SIV)) then return (true);
    return (false);
end;

string procedure AddrsNotMe( string ADDRS );
begin
    string ALIST;
    ALIST := null;
    while length(ADDRS) do begin "NextAddr"
	string AS;
	integer B;
	AS := maiAScan( ADDRS, B );
	if not isMe( AS ) then
	    maiCatList( ALIST, AS );
    end "NextAddr";
    return( ALIST );
end;

forward procedure command!PROFILE;
procedure CheckProfile;
if ProfileChanges neq phi then begin
    print( "
Warning: the following profile variables have been changed but not saved:
", ProfileChanges, crlf );
    if yes!no(
	"Do you wish to save the changes? ", "
Reply YES to save the changes in your TUMS.INI file, or
reply NO to leave TUMS without saving the changes, or
type ^C/Escape to return to TUMS.
" )
	then command!PROFILE;
end;

procedure printHeadings( r!p(md) D; string HCS );
begin
    integer C,N;
    string BQ;
    r!p(MAI) M;
    define BLANKS = {"                                                                                                                                    "};
    procedure pf( string S; integer N!(15) );
    begin
	if N=0 then N := N!;
	S := S[1 to N];
	if length(S)
	    then print( BQ, S )
	    else N := N + length(BQ);
	BQ := BLANKS[1 for N-length(S)];
	N := 0;
    end;
    BQ := null;
    N := 0;
    M := md:M[d];
    while length(HCS) do case C:=lop(HCS) of begin
	["0"]["1"]["2"]["3"]["4"]["5"]["6"]["7"]["8"]["9"]
	    N := N * 10 + C - "0";
	["D"] pf( mai:DATE[m], 15 );
	["A"] pf( if isMe( mai:FROM[m] )
	    then "To: "& mai:To[m]
	    else mai:From[m],    22 );
	["F"] pf( mai:FROM[m], 22 );
	["T"] pf( mai:TO[m], 22 );
	["K"] pf( mai:KEYWORDS[m], 30 );
	["L"] pf( if md:MSGLEN[d] < 10000
	    then cvs(md:MSGLEN[d])
	    else cvs(md:MSGLEN[d]%1024)&"k",    4 );
	["S"] pf( mai:SUBJECT[m], 30 );
	["T"] pf( mai:TO[m], 24 );
	["#"] pf( cvs(md:MSG#[d]), 3 );
	["!"] pf( 
	    (if md:FLAGS[d] land mdfDeleted then "D" else " ")&
	    (if md:FLAGS[d] land mdfOld then " " else "N")&
	    (if md:FLAGS[d] land mdfRead then "R" else " ")&
	    (if md:FLAGS[d] land mdfAnswered then "A" else " ")&
	    (if md:FLAGS[d] land mdfMarked then "M" else " "),  5 );
	["@"] begin
	    pf( cvs(md:MSGPTR[d]), 8 );
	    pf( cvs(md:MSGLEN[d]), 8 );
	    pf( cvs(md:MSGPTR[d]+md:MSGLEN[d]), 8 );
	    pf( cvs(md:TXTPTR[d]), 8 );
	    pf( cvs(md:TXTLEN[d]), 8 );
	    pf( cvs(md:TXTPTR[d]+md:TXTLEN[d]), 8 );
	end;
	["/"] begin print( crlf ); BQ := null; N := 0 end;
	[" "] pf( null, 1 );
	[else] pf( "?"&C, 3 )
    end;
    print( crlf );
end;

procedure cprintBanner( integer C; r!p(MD) D );
begin
    integer F;
    F := md:FLAGS[d];
    cprint( C,
	"Message ", md:MSG#[d],
	" (", md:MSGLEN[d], " chars):",
	if F land mdfDeleted then " Deleted" else null,
	if F land mdfOld then null else " New",
	if F land mdfRead then " Read" else null,
	if F land mdfAnswered then " Answered" else null,
	if F land mdfNoArchive then " NoArchive" else null,
	if F land mdfMarked then " Marked" else null,
	crlf );
end;

procedure printBanner( r!p(MD) D );
    cprintBanner( -1, D );

integer procedure findEOT ( integer MSGPTR );
begin
    integer P;
    for P := MSGPTR downto 0 do begin
	schptr( file:Chan[MailF], P );
	if wordin( file:Chan[MailF] ) = #EOT then return( P );
    end;
    return( -1 );
end;

string procedure GetMSG( r!p(MD) D );
begin
    string S;
    boolean IndexOkay;
    schptr( file:Chan[MailF], md:MSGPTR[d] );
    file:Count[MailF] := md:MSGLEN[d];
    S := input( file:Chan[MailF], brkEOT );
    IndexOkay := false;
    if file:Break[MailF] then
	print( "% phase error; EOT found in message"& crlf )
    else if wordin( file:Chan[MailF] ) neq #EOT then
	print( "% phase error; EOT expected"& crlf )
    else if length(S) > md:MSGLEN[d] then
	print( "% phase error; message too long"& crlf )
    else if length(S) < md:MSGLEN[d] then
	print( "% phase error; message too short"& crlf )
    else IndexOkay := true;
    if not IndexOkay then begin
	r!p(MAI) M;
	if length(S) < md:MSGLEN[D] % 2 then
	    md:MSGPTR[D] := md:MSGPTR[D] + length(S) + 1;
	md:MSGPTR[D] := findEOT( md:MSGPTR[D] ) + 1;
	schptr( file:Chan[MailF], md:MSGPTR[D] );
	S := null;
	do S := S& input( file:Chan[MailF], brkEOT )
	until file:Break[MailF] or file:EOF[MailF];
	md:MSGLEN[D] := length(S);
	M := maiMParse( S );
	md:TXTLEN[D] := length(mai:Text[M]);
	md:TXTPTR[D] := md:MSGPTR[D] + md:MSGLEN[D] - md:TXTLEN[D];
    end;
    return( S );
end;

string procedure GetTXT( r!p(MD) D );
begin
    string S;
    schptr( file:Chan[MailF], md:TXTPTR[d] );
    file:Count[MailF] := md:TXTLEN[d];
    S := input( file:Chan[MailF], brkEOT );
    return( S );
end;

procedure printHdg( r!p(md) D );
begin
    r!p(MAI) M;
    M := md:M[D];
    printBanner( D );
    print( maiMMake( M ));
end;

procedure printMsg( r!p(md) D );
begin
    r!p(MAI) M;
    printBanner( D );
    M := maiMParse( GetMSG( D ));
    print( maiMMake( M ) );
    md:FLAGS[d] := md:FLAGS[d] lor mdfRead;
end;

comment		Message Expression Evaluator
;

item ERROR;		! expression error;
boolean ExprALL;	! flag to include deleted messages;
forward recursive set procedure EvalExp( reference string EXP );

recursive set procedure EvalElement( reference string EXP );
begin
    set T;
    string TOK;
    integer B,I;

    boolean procedure XXF( string KeyWord; integer Mask,Value );
    begin
	if not equ( TOK, KeyWord ) then return( false );
	if not ExprALL then 
	    Mask := Mask lor mdfDeleted;
	for I := 1 upto NMSG do
	    if (md:FLAGS[datum(MDIV_MSGS[i])] land Mask) = Value
		then put MSGS[i] in T;
	return( true );
    end;

    boolean procedure XXN( string KeyWord; integer MSG );
    begin
	if not equ( TOK, KeyWord ) then return( false );
	while 1 leq MSG leq NMSG do begin
	    if ExprALL or (md:FLAGS[datum(MDIV_MSGS[MSG])] land mdfDeleted = 0)
		then begin
		    put MSGS[MSG] in T;
		    done;
		end;
	    MSG := MSG - 1;
	end;
	return( true );
    end;

    T := phi;
    TOK := getExprTok( EXP );
    if length(TOK)=0 then return( phi );
    if "0" leq TOK leq "9" then begin
	integer N1,N2;
	N1 := intscan( TOK, B );
	case B of begin
	    [0] N2 := N1;
	    [":"] if 0 = ( N2 := cvd(TOK[2 to inf]) ) then N2 := NMSG;
	    ["#"] N2 := N1 - 1 + cvd(TOK[2 to inf]);
	    [else] begin
		print( "?EvalElement: unrecognized terminator ",cvss(B),crlf );
		return( {ERROR} );
	    end
	end;
	if N1 < 1 then
	    print( "[EvalElement: using ",N1:=1,":",N2,"]"&crlf );
	if N2 > NMSG then
	    print( "[EvalElement: using ",N1,":",N2:=NMSG,"]"&crlf );
	if N1 > N2 then
	    print( "[EvalElement: using empty set]"&crlf );
	for I := N1 upto N2 do
	    if ExprALL
	    or (md:FLAGS[datum(MDIV_MSGS[i])] land mdfDeleted = 0)
		then put MSGS[i] in T;
	return( T );
    end;
    if length(TOK) = 1 then case TOK of begin
	["."] TOK := "CMSG";
	["$"] TOK := "CSET";
	["%"] TOK := "LAST";
	[else]
    end
    else if TOK = "#" then begin
	integer N;
	N := cvd(TOK[2 to inf]);
	for I := NMSG downto 1 do begin
	    if length( T ) geq N then done;
	    if ExprALL
	    or (md:FLAGS[datum(MDIV_MSGS[i])] land mdfDeleted = 0)
		then put MSGS[i] in T;
	end;
	return( T );
    end;
    if  XXF( "UNDELETED", mdfDeleted, 0 ) or
	XXF( "OLD", mdfOld, mdfOld ) or
	XXF( "UNREAD", mdfRead, 0 ) or
	XXF( "UNANSWERED", mdfAnswered, 0 ) or
	XXF( "UNMARKED", mdfMarked, 0 ) or
	XXF( "DELETED", mdfDeleted, mdfDeleted ) or
	XXF( "NEW", mdfOld, 0 ) or
	XXF( "RECENT", mdfOld, 0 ) or
	XXF( "READ", mdfRead, mdfRead ) or
	XXF( "ANSWERED", mdfAnswered, mdfAnswered ) or
	XXF( "MARKED", mdfMarked, mdfMarked ) or
	XXF( "*", 0, 0 ) or
	XXN( "LAST", NMSG ) 
	    then return( T );
    if equ( TOK, "CMSG" )
	then return( if typeit(CMSG)=13 then {CMSG} else phi );
    if equ( TOK, "CSET" )
	then return( CSET );
    if equ( TOK, "(" )
	then return( EvalExp( EXP ));
    if( equ(TOK,"TO") or equ(TOK,"FROM") )and checkToken(EXP,"ME")
	then begin
	    for I := 1 upto NMSG do begin
		if ExprALL
		or (md:FLAGS[datum(MDIV_MSGS[i])] land mdfDeleted = 0)
		    then begin
			r!p(MAI) M;
			M := md:M[datum(MDIV_MSGS[i])];
			if case TOK of (
			    ["T"] isMe(mai:TO[m]) or isMe(mai:CC[m]),
			    ["F"] isMe(mai:FROM[m])
			) then
			    put MSGS[i] in T;
		    end;
	    end;
	    return( T );
	end;
    if equ(TOK,"TO") or equ(TOK,"FROM") or equ(TOK,"SUBJECT")
    or equ(TOK,"KEY") or equ(TOK,"KEYWORDS") or equ(TOK,"TEXT")
    or equ(TOK,"ID") or equ(TOK,"ANY")
	then begin
	    string TARG;
	    TARG := strScan( EXP, B );
	    for I := 1 upto NMSG do 
		if ExprALL
		or (md:FLAGS[datum(MDIV_MSGS[i])] land mdfDeleted = 0)
		    then begin
			r!p(MAI) M;
			M := md:M[datum(MDIV_MSGS[i])];
			if skequ( TARG, case TOK of (
			    ["A"] GetMSG(datum(MDIV)),
			    ["F"] mai:FROM[m],
			    ["I"] mai:MESSAGE.ID[m],
			    ["K"] mai:KEYWORDS[m],
			    ["S"] mai:SUBJECT[m],
			    ["T"] (if equ(TOK,"TO")
				then mai:TO[m]& mai:CC[m]
				else GetTXT(datum(MDIV)) )
			)) then
			    put MSGS[i] in T;
		    end;
	    return( T );
	end;
    if XXF( "NOT", mdfDeleted, 0 )
	then return( T - EvalElement( EXP ));
    print( "EvalElement: unrecognized message set element ",cvss(TOK),crlf );
    return( {ERROR} );
end;

recursive set procedure EvalTerm( reference string EXP );
begin
    set T;
    integer B;
    T := EvalElement( EXP );
    while length(EXP) do begin
	string TOK,EXP!;
	TOK := getExprTok( EXP! := EXP );
	if equ( TOK, "&" ) or equ( TOK, "AND" ) then
	    T := T inter EvalElement( EXP := EXP! )
	else
	    done;
    end;
    return( T );
end;

recursive set procedure EvalExp( reference string EXP );
begin
    set T;
    integer B;
    integer SAVE.ExprALL;
    SAVE.ExprALL := ExprALL;
    while CheckToken( EXP, "ALL" )
	do ExprALL := true;
    T := phi;
    while length(EXP) do begin
	string TOK,EXP!;
	EXP! := EXP;
	TOK := getExprTok( EXP );
	if equ( TOK, "-" ) then
	    T := T - EvalTerm( EXP )
	else if equ( TOK, "+" ) or equ( TOK, "OR" ) then
	    T := T union EvalTerm( EXP )
	else if equ( TOK, ")" ) then
	    done
	else
	    T := T union EvalTerm( EXP := EXP! );
    end;
    ExprALL := SAVE.ExprALL;
    return( T );
end;

set procedure EvalMsg( reference string ARGS; string ARGS1("CMSG") );
begin
    string ExpSave;
    if CheckToken( ARGS, "?" ) then begin
	printHelp( "M" );
	return( CSET := phi );
    end;
    ExpSave := ARGS;
    CSET := if length(ARGS) then EvalExp(ARGS) else EvalExp(ARGS1);
    if ERROR in CSET then begin
	print( "?error in message set expression:"& crlf&
	    #ht, cvss(ExpSave), crlf );
	CSET := phi;
    end;
    return( CSET );
end;

procedure RFile( r!p(mai)M; string FileName );
begin
    integer Len1,LIC;
    r!p(file) F;
    LIC := License( OFF );
    Len1 := length( mai:Text[M] );
    FileName := Trim( FileName );
    F := fOpen( FileName, "rb1E:.MSG" );
    print( file:Name[F], ": " );
    while not file:EOF[F] do
	mai:Text[M] := mai:Text[M]& input( file:Chan[F], 0 );
    fClose( F );
    print( length(mai:Text[M])-Len1, " chars."& crlf );
    License( LIC );
end;

procedure WFile( r!p(mai)M; string FileName );
begin
    integer LIC;
    r!p(file) F;
    string S;
    LIC := License( OFF );
    FileName := Trim( FileName );
    F := fOpen( FileName, "wb1E:.MSG" );
    if not file:EOF[F] then begin
	print( file:Name[F], ": " );
	cprint( file:Chan[F], S := maiMMake( M ) );
	print( length(S), " chars."& crlf );
    end;
    fClose( F );
    License( LIC );
end;

procedure EditMessage( reference r!p(mai)M; string EDITOR );
begin
    integer FERR;
    r!p(file) F;
    string FileName, S;
    License( OFF );
    FileName := cvs(1000+call(0,"PJOB"))[2 for 3]& "MSG.TMP";
    F := fOpen( FileName, "wb1E" );
    if file:EOF[F] then return;
    cprint( file:Chan[F], maiMMake( M ) );
    fClose( F );
    FERR := if kequ(EDITOR,"EDITOR")
	then FRMRUN( "(SYS)EDITOR", F.CCL, !SKIP!, "EDT", FileName )
	else FRMRUN( "(SYS)"&EDITOR, F.CCL, !SKIP!, "EDS", "MOD "&FileName );
    if FERR then begin
	print( "?unable to run (SYS)", EDITOR, ", frmrun error ", FERR, crlf );
	return;
    end;
    S := null;
    F := fOpen( FileName, "rob1E" );
    if file:EOF[F] then return;
    while not file:EOF[F] do
	S := S& input( file:Chan[F], 0 );
    fRename( F, null );
    fClose( F );
    F := fOpen( ".BAK", "rx1E:"& FileName );
    if not file:EOF[F] then
	fRename( F, null );
    fClose( F );
    M := maiMParse( S );
    print( crlf& "Text: (continued)"& crlf );
end;

procedure intout( r!p(file) F; integer I );
begin
    integer C;
    C := file:Chan[F];
    if I land '777774000000 then begin
	wordout( C, '100 lor I lsh -(5*7) );
	wordout( C, I lsh -(4*7) );
	wordout( C, I lsh -(3*7) );
    end;
    wordout( C, I lsh -(2*7) );
    wordout( C, I lsh -(1*7) );
    wordout( C, I );
end;

procedure strout( r!p(file) F; string S );
begin
    intout( F, length(S) );
    out( file:Chan[F], S );
end;

procedure WriteTIX;
begin
    integer N;
    r!p(MD) D;
    r!p(MAI) M;
    r!p(file) F;
    if MailF = null!record or file:Chan[MailF] leq 0 then
	fError( F, "WriteTIX called with no message file open." );
    F := fOpen( ".TIX", "wb4E:"& file:Name[MailF] );
    wordout( file:Chan[F], 0 );		! file must begin with null so we can
	    				  tell if anyone edited it;
    intout( F, memory['137] );
    intout( F, NMSG );
    intout( F, Mail.RPTR );
    intout( F, deletedChars );
    for N := 1 upto NMSG do begin
	M := md:M[ D := datum(MDIV_MSGS[n]) ];
	intout( F, md:FLAGS[d] lor mdfOld );
	intout( F, md:MSGPTR[d] );
	intout( F, md:MSGLEN[d] );
	intout( F, md:TXTPTR[d] );
	intout( F, md:TXTLEN[d] );
	strout( F, mai:Reply.to[m] );
	strout( F, mai:From[m] );
	strout( F, mai:Sender[m] );
	strout( F, mai:Date[m] );
	strout( F, mai:To[m] );
	strout( F, mai:Cc[m] );
	strout( F, mai:Bcc[m] );
	strout( F, mai:Message.id[m] );
	strout( F, mai:Keywords[m] );
	strout( F, mai:Subject[m] );
    end;    
    fClose( F );
end;

procedure CloseMailFile;
if MailF neq null!record then begin
    if file:Chan[MailF] > 0 then WriteTIX;
    fClose( MailF );
end;

integer DULCHL,DULEOF,DULBLK;
integer array DULARY[0:127];
define DULHSH = 101;

simple procedure INIDUL;
begin
    DULCHL _ DULBLK _ -1;
end;
require INIDUL initialization;

string procedure LOKDUL( integer PPN );
begin	"LOKDUL"
    integer I;
    string ST;
    simple string procedure BRKPPN( integer PPN );
    return( "["& cvos(PPN LSH -18)& ","& cvos(PPN LAND '777777)& "]" );

    if DULCHL<0 then open( DULCHL_getchan,"DSK",'16,0,0,DULEOF,DULEOF,DULEOF);
    if DULBLK<0 then lookup( DULCHL, "DUL.SYS[1,4]", DULEOF );
    if DULEOF neq 0 then return( BRKPPN(PPN) );
    useti( DULCHL, I_PPN mod DULHSH+1 );
    while true do begin "ARRSRC"
	if I neq DULBLK then arryin( DULCHL, DULARY[0], 128 );
	DULBLK := I;
	for I := 0 step 3 until 127 do
	    if DULARY[I] = PPN then done "ARRSRC"
	    else if DULARY[I] = 0 then return( BRKPPN(PPN) )
	    else if DULARY[I] < 0 then done;
	useti( DULCHL, I_DULARY[I] LAND '777777+1 );
    end "ARRSRC";
    ST := cvxstr( DULARY[I+1] )& cvxstr( DULARY[I+2] );
    while ST[inf for 1] = " " do ST := ST[1 for inf-1];
    return( "("& ST& ")" );
end	"LOKDUL";

integer procedure intin( r!p(file) F );
begin
    integer I,C;
    C := file:Chan[F];
    I := wordin( C ) lsh (2*7)
	lor wordin( C ) lsh (1*7)
	lor wordin( C );
    if I land '4000000 then I := I lsh (3*7)
	lor wordin( C ) lsh (2*7)
	lor wordin( C ) lsh (1*7)
	lor wordin( C );
    return( I );
end;

string procedure strin( r!p(file) F );
begin
    file:Count[F] := intin( F );
    return( input( file:Chan[F], 0 ));
end;

boolean procedure ReadTIX;
begin
    integer N,I;
    integer TIX.VER;
    r!p(MD) D;
    r!p(MAI) M;
    r!p(file) F;
    if MailF = null!record or file:Chan[MailF] leq 0 then
	fError( F, "ReadTIX called with no message file open." );
    F := fOpen( ".TIX", "rbx4E:"& file:Name[MailF] );
    if file:EOF[F] then begin
	print( "[creating ", cvss(file:Name[F]), "]"& crlf );
	return( false );
    end;
    if wordin( file:Chan[F] ) then
	fError( F, "Format error, index is corrupt." );
    TIX.VER := intin( F );	! get version;
    if not AlternateMF and ( TIX.VER neq memory['137] ) then begin
	integer I;
	print( #bel&
	    "%index ", cvss(file:Name[F]),
	    " created by version ",
	    cvos(!lh(TIX.VER)),".",cvos(!rh(TIX.VER)),
	    crlf& crlf );
	for I := !lh(TIX.VER) upto !lh(memory['137]) do
	    if arrinfo(NEWS,1) leq !lh(TIX.VER) leq arrinfo(NEWS,2)
		then print( NEWS[I], crlf );
    end;
    NMSG := intin( F );
    Mail.RPTR := intin( F );
    deletedChars := intin( F );
    for N := 1 upto NMSG do begin
	datum(MDIV_MSGS[n]) := D := new!record(MD);
	md:M[d] := M := new!record(MAI);
	md:MSG#[d] := N;
	md:FLAGS[d] := intin( F );
	md:MSGPTR[d] := intin( F );
	md:MSGLEN[d] := intin( F );
	md:TXTPTR[d] := intin( F );
	md:TXTLEN[d] := intin( F );
	if TIX.VER < '37 then begin
	    mai:Received[m] := strin( F );
	    mai:Return.path[m] := strin( F );
	end;
	mai:Reply.to[m] := strin( F );
	mai:From[m] := strin( F );
	mai:Sender[m] := strin( F );
	mai:Date[m] := strin( F );
	mai:To[m] := strin( F );
	mai:Cc[m] := strin( F );
	mai:Bcc[m] := strin( F );
	mai:Message.id[m] := strin( F );
	if TIX.VER geq '23 then mai:Keywords[m] := strin( F );
	mai:Subject[m] := strin( F );
	if TIX.VER < '37 then mai:Other[m] := strin( F );
    end;    
    if file:LKB[F][!rbPPN] neq file:LKB[F][!rbAUT] then print(
	file:Name[F],
	" last access by ",
	LOKDUL( file:LKB[F][!rbAUT] ),
	" on ",
	cvDaTi(
	    ((file:LKB[F][3] lsh -2) land '30000) lor
	    (file:LKB[F][4] land '7777),
	    ((file:LKB[F][4] lsh -12) land '3777) * 3600 +
	    ((file:LKB[F]['14] lsh -18) land '77) * 60  ),
	crlf );
    fClose( F );
    return( true );
end;

procedure OpenMailFile( string FileName );
begin
    integer I;
    r!p(MD) D;
    r!p(MAI) M;
    CloseMailFile;
    CMSG := any;
    CSET := RSET := phi;
    deletedChars := 0;
    Mail.RPTR := 0;
    NMSG := 0;
    AlternateMF := not kequ( FileName, datum(MAIL.FILE) );
    MailF := fOpen( FileName, "rxb4E:.MSG" );
    if file:EOF[MailF] then begin
	print( "[creating ", cvss(file:Name[MailF]), "]"& crlf );
	MailF := fOpen( FileName, "wnb4E" );
	fClose( MailF );
	MailF := fOpen( FileName, "rob4E" );
	return;
    end;
    ReadTIX;
    LastNMSG := NMSG;
    if Mail.RPTR then schptr( file:Chan[MailF], Mail.RPTR );
    while not file:EOF[MailF] do begin
	integer RPTR;
	string MS;
	MS := null;
	do MS := MS& input( file:Chan[MailF], brkEOT )
	until file:Break[MailF] or file:EOF[MailF];
	if length(MS) = 0 then continue;
	RPTR := Mail.RPTR;
	Mail.RPTR := rchptr(file:Chan[MailF]);
	D := new!record( MD );
	md:MSG#[d] := NMSG := NMSG + 1;
	datum(MDIV_MSGS[NMSG]) := D;
	md:M[d] := M := maiMParse( MS );
	md:MSGPTR[d] := RPTR;
	md:MSGLEN[d] := length(MS);
	md:TXTPTR[d] := RPTR+length(MS)-length(mai:Text[M]);
	md:TXTLEN[d] := length(mai:Text[M]);
	mai:Text[M] := null;
    end;
end;

procedure AFILE( string FileName; r!p(mai)M; integer N(0) );
comment
    Append message (M) to message file (FileName).  If (N) is
    specified, delete old message N and replace message N.  If (N)
    is not specified, assign a new message number for the filed message.
;
begin
    r!p(file) F;
    string MSG;
    r!p(MD) D;
    r!p(MD) itemvar DIV;
    if length(FileName)=0 then FileName := file:Name[MailF];
    mai:RCPT[M] := null;
    MSG := maiMMake( M );
    F := fOpen( FileName, "ab4E:.MSG" );
    cprint( file:Chan[f], MSG, #EOT );
    fClose( F );
    if kequ( FileName, file:Name[MailF] ) then begin
	if 1 leq N leq NMSG
	    then deletedChars := deletedChars + md:MSGLEN[datum(DIV_MSGS[N])]
	    else N := NMSG := NMSG + 1;
	datum(DIV_MSGS[N]) := D := new!record( MD );
	if PutNewInRSET then put DIV in RSET;
	md:Msg#[D] := N;
	md:M[D] := M;
	md:MSGPTR[D] := Mail.RPTR;
	md:MSGLEN[D] := length(MSG);
	md:TXTPTR[D] := Mail.RPTR + length(MSG) - length(mai:Text[M]);
	md:TXTLEN[D] := length(mai:Text[M]);
	Mail.RPTR := Mail.RPTR + length(MSG) + 1;
    end;
    mai:Text[M] := null;
end;

procedure CheckAdr( reference string Addrs );
begin
    string Addrs1,Addr;
    integer B,LIC;
    LIC := License( ON );
    Addrs1 := null;
    while length(Addrs) do begin
    	Addr := maiAScan( Addrs, B );
	if not length(maiQFile( Addr ))
	    then print( "%unknown address deleted: ", cvss(Addr), crlf )
	    else maiCatList( Addrs1, Addr );
    end;
    Addrs := Addrs1;
    License( LIC );
end;

procedure ApplyAlias( reference string ARGS; set itemvar ALIAS );
begin
    string A,B;
    boolean FLAG;
    A := maiAScan( B:=ARGS, FLAG );
    SIV := cvsi( upper.case(A), FLAG );
    if not FLAG and SIV in datum(ALIAS) then
	ARGS := datum(SIV);
end;

boolean procedure inputAdr( r!p(MAI) M; string ARGS(null) );
begin
    label pTo;
    string F#;
    integer B;
    set ExpandedAliases;
    if length(ARGS)=0 then begin
pTo:	print( "To: " );
	ARGS := inchwl;
    end;
    F# := null;		! To: ;
    if CheckToken( ARGS, "?" ) then begin
	printHelp( "A" );
	goto pTo;
    end;
    while length(ARGS) do begin
	string A;
	A := maiAScan( ARGS, B );
	if B=":"
	    then begin
		if kequ( A, "TO" ) then F# := 0& F#
		else if kequ( A, "CC" ) then F# := 1& F#
		else if kequ( A, "BCC" ) then F# := 2& F#
		else print("%unrecognized field name ignored: ",cvss(A),crlf);
	    end
	    else begin
		boolean FLAG;
		SIV := cvsi( upper.case(A), FLAG );
		if not FLAG and SIV in datum(ALIAS) then begin
		    if not SIV in ExpandedAliases then begin
			put SIV in ExpandedAliases;
			ARGS := datum(SIV)&
			    (if length(ARGS)
				then (if B=0
				    then ","
				    else B) & ARGS
				else null);
		    end
		    else begin
			if B=";" then lop(F#);
		    end;
		end
		else begin
		    if length(A) then CheckAdr( A );
		    case F# of begin
			[0] maiCatList( mai:To[m], A );
			[1] maiCatList( mai:Cc[m], A );
			[2] maiCatList( mai:Bcc[m], A )
		    end;
		    if B=";" then lop(F#);
		end;
	    end;
    end;
    if length( mai:To[M] )=0 then goto pTo;
end;

boolean procedure inputText( reference r!p(mai) M );
begin
    print( datum(PROMPT.TEXT), crlf );
    if length(mai:Text[M]) then
	print( "[appending to existing text]"& crlf );
    while true do begin
	string S;
	S := inchwl;
	if !SKIP! = #eot or !SKIP! = #sub then begin
	    if length(S) then begin
		mai:Text[M] := mai:Text[M]& S& crlf;
		print( crlf );
	    end;
	    done;
	end;
	if S = "~" then case S[2 to 2] of begin
	    ["?"] print("
The following commands may be entered while entering text.  They must
begin with the ""~"" in column 1.
  ~?		help - print this message
  ~b address	blind copy - add address to blind carbon copy field (Bcc:)
  ~c address	copy - add address to carbon copy field (Cc:)
  ~e		invoke EDITOR on message
  ~i		insert original message (use in ANSWER/REPLY)
  ~i msgs	insert specified messages
  ~k words	add words to Keywords: field
  ~p		print message entered so far
  ~q		quit, leave message in draft
  ~r filename	read contents of file into message
  ~t address	to - add address to primary recipient field (To:)
  ~v		invoke PEAK on message
  ~w filename	write message entered so far to file
  ~~line	puts line in buffer following single ~
  ^D		finish input (control-D, end of text)

");	    ["b"]["B"] inputAdr( M, "BCC:"& S[3 to inf] );
	    ["c"]["C"] inputAdr( M, "CC:"& S[3 to inf] );
	    ["e"]["E"] EditMessage( M, "EDITOR" );
	    ["i"]["I"] begin
		r!p(MD) itemvar DIV;
		integer TL;
		set T;
		T := CSET;
		TL := length( mai:Text[M] );
		EvalMsg( S:=S[3 to inf], "CSET" );
		if length(CSET)
		    then print( "Message" )
		    else print( "?No message(s) to insert"& crlf );
		foreach DIV | DIV in CSET do begin
		    mai:Text[M] := mai:Text[M]&
			datum(INCLUDE.SEP)& crlf&
			GetMSG(datum(DIV));
		    print( " ", md:Msg#[datum(DIV)] );
		end;
		if length(CSET) then begin
		    mai:Text[M] := mai:Text[M]&
			datum(INCLUDE.SEP)& crlf;
		    print( ": ", length(mai:Text[M])-TL, " chars."& crlf );
		end;
		CSET := T;
	    end;
	    ["k"]["K"] maiCatList( mai:Keywords[M], upper.case(S[3 to inf]) );
	    ["p"]["P"] print( maiMMake( M ) );
	    ["q"]["Q"] begin
		DRAFT := M;
		return( false );
	    end;
	    ["r"]["R"] RFile( M, S[3 to inf] );
	    ["t"]["T"] inputAdr( M, S[3 to inf] );
	    ["v"]["V"] EditMessage( M, "PEAK" );
	    ["w"]["W"] WFile( M, S[3 to inf] );
	    ["~"] mai:Text[M] := mai:Text[M]& S[2 to inf]& crlf;
	    [else] print( "?unrecognized command: ",
		cvss(S), " - type ~? for help"& crlf )
	end
	else mai:Text[M] := mai:Text[M]& S& crlf;
    end;
    print( "[EOT]"& crlf );
    return( true );
end;

procedure Send( r!p(MAI) M );
comment
    Send the message (M).
;
begin
    integer LIC;
    CheckAdr( mai:To[M] );
    CheckAdr( mai:Cc[M] );
    CheckAdr( mai:Bcc[M] );
    inputAdr( M, "BCC: "& datum(AUTO.BCC) );
    LIC := License( ON );
    maiQueue( M );
    License( LIC );
end;

procedure MakeAssoc( reference set T; string NAME, VALUE );
begin
    integer B;
    SIV := cvsi( NAME, B );
    if B
	then begin "new item"
	    if length(VALUE) then begin
		new!pname( SIV := new(VALUE), NAME );
		put SIV in T;
	    end;
	end
	else begin "old item"	
	    if SIV in T
		then if length(VALUE)
		    then datum(SIV) := VALUE
		    else begin
			remove SIV from T;
			delete( SIV );
		    end
		else print( "?name """, NAME, """ in use or reserved"& crlf );
	end;
end;

string procedure CheckAssoc( set T; string NAME );
begin
    string itemvar SIV;
    boolean ERR;
    SIV := cvsi( NAME, ERR );
    !SKIP! := not ERR and SIV in T;
    return( if !SKIP!
	then datum(SIV)
	else NAME	);
end;

procedure FileSvc( reference string MSG );
begin
    r!p(MAI) M;
    if length(MSG) = 0 then return;
    M := maiMParse( MSG );
    mai:RCPT[M] := mai:Bcc[M] := null;
    if length(mai:Subject[M]) = 0 then begin
	integer B;
	string S,X;
	S := null;
	X := mai:Text[M];
	while length(S) < 30 and length(X) do begin
	    string TOK;
	    TOK := scan( X, brkToc, B );
	    if  ("0" leq TOK leq "9") or 
	 	("A" leq TOK leq "Z") or 
		("a" leq TOK leq "z") then
		    S := S& TOK& (if B leq " " then " " else B&" ");
	end;
	mai:Subject[M] := """"& S[1 to inf-1]& """...";
    end;
    AFile( file:Name[MailF], M );
end;

procedure GetMail;
begin
    string Q;
    integer LIC;
    own integer Qsize;
    Q := "(MAIL)'"& cvos(calli(!xwd(-1,-'23),'41))& ".MAI";
    LIC := License( ON );
    MailWaiting;			! clear it if its set;
    if kequ( file:Name[MailF], datum(MAIL.FILE) )
	then begin
	    maiFEMessage( FileSvc, Q, true );
	    Qsize := 0;
	end
	else begin
	    r!p(file) F;
	    F := fOpen( Q, "r" );
	    if file:EOF[F] = 0 and file:LKB[F][!rbSIZ] > Qsize then begin
		print( "[new mail waiting]"& crlf );
		Qsize := file:LKB[F][!rbSIZ];
	    end;
	    fClose( F );
	end;
    License( LIC );
    if LastNMSG neq NMSG then begin
	print( "[", NMSG-LastNMSG, " new message",
	    if NMSG-LastNMSG=1 then null else "s",
	    " just arrived]"& crlf );
	LastNMSG := NMSG;
    end;
end;

procedure printAliases( string S );
begin
    foreach SIV | SIV in datum(ALIAS) do begin
	string AName;
	AName := cvis(SIV,!SKIP!);
	if kequ(S, AName) or skequ(S, datum(SIV)) then
	    print( cvss(AName), " ", cvss(datum(SIV)), crlf );
    end;
end;

procedure printProfile( list PL; integer PropsMask(-1) );
begin
    integer I;
    simple string procedure PF;
    return( if PropsMask = -1
	then if props(IV) land props!set
	    then "* " else "  "
	else null );
    foreach IV | IV in PL do
      if PropsMask = -1 or props(IV) land PropsMask then
	case typeit(IV) of begin
	    [1] if props(IV) land props!true
		then print( PF, IV, crlf )
		else print( PF, "NOT ", IV, crlf );
	    [3] print( PF, IV, " ", cvss(datum(SIV_IV)), crlf );
	    [4] print( PF, IV, " ", datum(RIV_IV), crlf );
	    [5] print( PF, IV, " ", datum(IIV_IV), crlf );
	    [6] begin
		TIV := IV;
		foreach SIV | SIV in datum(TIV) do
		    print( PF, IV, " ", cvss(cvis(SIV,I)),
			" ", cvss(datum(SIV)), crlf );
	    end;
	    [7] if length(datum(LIV_IV)) then begin
		print( PF, IV );
		foreach SIV | SIV in datum(LIV) do
		    print( " ", cvss(datum(SIV)) );
		print( crlf );
	    end;
	    [else] usererr(typeit(IV),2,"?printProfile: illegal typeit: ")
	end;
end;

procedure mark( set T; integer MASK );
begin
    integer LEN;
    integer CMASK,SMASK;
    r!p(MD) itemvar DIV;
    CMASK := SMASK := 0;
    if MASK < 0
	then CMASK := -MASK
	else SMASK := MASK;
    if length(T)
	then print( "Messages ",if CMASK then "un" else null,"marked:" )
	else print( "No messages processed." );
    foreach DIV | DIV in T do begin
	integer F,X;
	F := md:FLAGS[datum(DIV)] land lnot CMASK lor SMASK;
	if X := F xor md:FLAGS[datum(DIV)] then begin
	    md:FLAGS[datum(DIV)] := F;
	    print( " ", md:MSG#[datum(DIV)] );
	    if X land mdfDeleted then
		deletedChars := deletedChars + ( md:MSGLEN[datum(DIV)] + 1 ) *
		    (if F land mdfDeleted then +1 else -1);
	end;
    end;
    print( crlf );
end;

procedure Expunge;
begin
    integer I,NOUT;
    r!p(file) F;
    print( "[expunging message" );
    F := fOpen( file:Name[MailF], "wbo4E" );
    NOPOLL := NOPOLL + 1;
    NOUT := Mail.RPTR := 0;
    for I := 1 upto NMSG do begin
	r!p(MD) D;
	D := datum(MDIV_MSGS[i]);
	datum(MDIV) := null!record;
	if md:FLAGS[d] land mdfDeleted = 0 then begin
	    cprint( file:Chan[F], GetMSG(D), #eot );
	    NOUT := NOUT + 1;
	    datum(MDIV_MSGS[NOUT]) := D;
	    md:Msg#[D] := NOUT;
	    md:MSGPTR[D] := Mail.RPTR;
	    md:TXTPTR[D] := Mail.RPTR + md:MSGLEN[D] - md:TXTLEN[D];
	    Mail.RPTR := Mail.RPTR + md:MSGLEN[D] + 1;
	end
	else begin
	    print( " ", I );
	    if length(datum(ARCHIVE.FILE))
		and md:FLAGS[d] land mdfNoArchive = 0
		then begin
		    r!p(mai) M;
		    M := maiMParse( GetMSG( D ));
		    AFile( NameFixup( datum(ARCHIVE.FILE), mai:Date[M] ), M );
		end;
	end;
    end;
    NMSG := LastNMSG := NOUT;
    deletedChars := 0;
    fClose( F );
    print( "]" );
    OpenMailFile( file:Name[MailF] );
    print( crlf );
    CMSG := any;
    CSET := RSET := phi;
    NOPOLL := NOPOLL - 1;
end;

simple integer procedure DeletedPerCent;
    return(  ( DeletedChars * 100 + Mail.RPTR ) % ( Mail.RPTR + 1 ) );

define
    commandProcedure(CMD,HLP) = {
	redefine TCMD = cvms(TCMD)& {,"}& {CMD}& {"};
	redefine HCMD = cvms(HCMD)& {,"}& {HLP}& {"};
	redefine CCMD = cvms(CCMD)& {;command!}& {CMD};
	redefine NCMD = NCMD + 1;
	procedure command!}&{CMD
    },
    TCMD = {"?","HELP"},
    HCMD = {"same as HELP","display this list"},
    CCMD = {command!HELP;command!HELP},
    NCMD = 1;

commandProcedure(ANSWER,send reply to message);
begin
    set T;
    string S;
    r!p(MD) D;
    r!p(MAI) M,DRAFT;
    T := EvalMsg( ARGS );
    foreach CMSG | CMSG in T do begin
	M := maiMParse( GetMSG( D := datum(CMSG) ));
	print( "Reply to message ", md:MSG#[d], ":"& crlf );
	DRAFT := new!record(MAI);
	mai:Other[DRAFT] := "In-reply-to: "&
	    (if length(mai:Message.id[M])
		then mai:Message.id[M]
		else "your message")&
	    " of "& mai:Date[M]& crlf;
	mai:Subject[DRAFT] := if kequ(mai:SUBJECT[M][1 to 3],"Re:")
	    then mai:SUBJECT[M]
	    else "Re: "& mai:SUBJECT[M];
	mai:From[DRAFT] := datum(SEND.FROM);
	mai:Date[DRAFT] := maiDate;
	mai:To[DRAFT] :=
	    if length(mai:Reply.to[M])
		then mai:Reply.to[M]
		else maiRPath(M);
	ApplyAlias( mai:To[DRAFT], REPLY.ALIAS );
	print( "To: ", mai:To[DRAFT], crlf&
	    "Subject: ", mai:Subject[DRAFT], crlf,
	    mai:Other[DRAFT] );
	S := AddrsNotMe( mai:To[m]& ","& mai:Cc[m] );
	if length(S) and yes!no( "Cc to original recipients? ", S )
	    then print( "Cc: ", mai:Cc[DRAFT] := S, crlf );
	CSET := {CMSG};
	if inputText( DRAFT ) then begin
	    Send( DRAFT );
	    md:FLAGS[d] := md:FLAGS[d] lor mdfAnswered;
	end;
    end;
    CSET := T;
end;

ifcr compiler!switch("B") thenc
    commandProcedure(BAIL,call BAIL - debug command);
    begin
	usererr(0,0,0,"B");
	print( crlf );
    end;
endc

commandProcedure(BUG,report bug to TUMS wizard);
begin
    r!p(mai) M;
    M := new!record(mai);
    mai:To[M] := "Mail Wizard <MAIL>";
    mai:From[M] := datum(SEND.FROM);
    mai:Subject[M] := "TUMS-10 bug report (v"& cvos(memory['137])&
	" of "& cvms(date!part$c)[1 to 9]& ")";
    if inputText( M )
	then Send( M );
end;

commandProcedure(CHECK,check for new mail);
begin
    integer B,N,N1;
    if kequ( file:Name[MailF], datum(MAIL.FILE) )
    then begin
	N1 := NMSG+1;
	maiFEMessage( FileSvc, "(~)MAIL", true );
	for N := N1 upto NMSG do begin
	    md:FLAGS[datum(MDIV_MSGS[N])] := mdfRead;
	    if PutNewInRSET then remove MSGS[N] from RSET;
	end;
    end
    else print( "%alternate message file open: ", file:Name[MailF], crlf );
    GetMail;			! in case not interactive;
end;

commandProcedure(CLOSE,close alternate message file);
begin
    string S;
    if not kequ( S := file:Name[MailF], datum(MAIL.FILE) ) then begin
	OpenMailFile( datum(MAIL.FILE) );
	print( "[file closed: ", S, "]"& crlf );
    end;
end;

commandProcedure(CONTINUE,continue with message draft);
begin
    integer B;
    string FN;
    r!p(FILE) F;
    procedure DraftSVC( reference string MSG );
    begin
	if DRAFT = null!record
	    then begin
		DRAFT := maiMParse( MSG );
		print( FN, ": ", length(MSG), " characters read."& crlf );
	    end
	    else print( FN, ": ",
		length(MSG), " characters ignored following EOT."& crlf );
    end;
    if length(ARGS) then begin
	F := fOpen( strScan( ARGS, B ), "ro1E:.MSG" );
	if file:EOF[F] then return;
	FN := file:Name[F];
	fClose( F );
	DRAFT := null!record;
	maiFEMessage( DraftSVC, FN );
    end;
    if DRAFT = null!record then begin
	print( "[no draft]"& crlf );
	return;
    end;
    if inputText( DRAFT ) then begin
	Send( DRAFT );
	DRAFT := null!record;
    end;
end;

commandProcedure(COPY,copy messages to file);
begin
    string FileName;
    integer B;
    FileName := strScan( ARGS, B );
    EvalMsg( ARGS );
    if length(CSET)
	then print( "Messages copied:" )
	else print( "No messages copied."& crlf );
    foreach MDIV | MDIV in CSET do
	if md:FLAGS[datum(MDIV)] land mdfDeleted = 0 then begin
	    r!p(mai) M;
	    mai:Text[ M := md:M[datum(MDIV)] ] := GetTXT( datum(MDIV) );
	    AFile( FileName, M );
	    mai:Text[M] := null;
	    print( " ", md:Msg#[datum(MDIV)] );
	end;
    print( crlf );
end;

commandProcedure(COUNT,count messages);
begin
    integer I;
    EvalMsg( ARGS );
    print( I:=length(CSET), " message", if I=1 then null else "s", "."& crlf );
end;

commandProcedure(DAYTIME,display date and time);
begin
    print( maiDate, crlf );
end;

commandProcedure(DELETE,mark message for deletion);
begin
    boolean Del!;
    Del! := if CheckToken( ARGS, "NOARCHIVE" ) or CheckToken( ARGS, "NOARC" )
	then mdfDeleted+mdfNoArchive
	else mdfDeleted;
    mark( EvalMsg( ARGS ), Del! );
end;

commandProcedure(EDIT,edit message);
begin
    string MSG;
    r!p(MD) D;
    r!p(MAI) M;
    EvalMsg( ARGS );
    case length(CSET) of begin
	[0] print( "No messages."& crlf );
	[1] begin
	    D := datum( CMSG := cop(CSET) );
	    printBanner( D );
	    M := maiMParse( GetMSG( D ));
	    print( crlf );
	    if inputText( M ) then
		AFile( file:Name[MailF], M, md:Msg#[D] );
	end;
	[else] print( "%EDIT: too many messages specified: ",
	    length(CSET), crlf )
    end;
end;

commandProcedure(ERASE,erase draft);
begin
    DRAFT := null!record;
end;

commandProcedure(EXIT,terminate TUMS);
begin
    CheckProfile;
    if DeletedChars then Expunge;
    Quit := true;
    terminate( myproc );
end;

commandProcedure(EXPUNGE,expunge deleted messages);
begin
    integer PerCent,B;
    if length(ARGS)
	then begin
	    PerCent := intScan( ARGS, B );
	    if not CheckToken( ARGS, "%" ) then begin
		print( CmdLine, crlf&
		    "? ""nn%"" expected"& crlf );
		return;
	    end;
	end
	else PerCent := 1;
    if DeletedPerCent geq PerCent
	then Expunge;
end;

commandProcedure(FORWARD,forward a message to other recipients);
begin
    r!p(MAI) M;
    r!p(MD) itemvar DIV;
    EvalMsg( ARGS );
    if length(CSET)=0 then begin
	print( "No messages."& crlf );
	return;
    end;
    M := new!record(MAI);
    mai:From[M] := datum(SEND.FROM);
    mai:Date[M] := maiDate;
    mai:Subject[M] := mai:Subject[md:M[datum(MDIV_cop(CSET))]];
    mai:Text[M] :=
	"(begin forwarded message"&
	(if length(CSET) > 1 then "s)" else ")")& crlf;
    print( "Message" );
    foreach DIV | DIV in CSET do begin
	mai:Text[M] := mai:Text[M]&
	    datum(INCLUDE.SEP)& crlf&
	    GetMSG(datum(DIV));
	print( " ", md:Msg#[datum(DIV)] );
    end;
    if length(CSET) then begin
	mai:Text[M] := mai:Text[M]&
	    datum(INCLUDE.SEP)& crlf&
	    "(end forwarded message"&
	    (if length(CSET) > 1 then "s)" else ")")& crlf& crlf;
	print( ": ", length(mai:Text[M]), " chars."& crlf );
    end;
    inputAdr( M );
    if inputText( M ) then begin
	Send( M );
    end;
end;

commandProcedure(HEADINGS,display message headings);
begin
    evalMsg( ARGS );
    foreach CMSG | CMSG in CSET do
	printHdg( datum( CMSG ));
end;

commandProcedure(KEYWORDS,add keywords to messages);
begin
    string KW;
    integer B;
    KW := upper.case(strscan( ARGS, B ));
    while B="," do
	maiCatList( KW, upper.case(strscan( ARGS, B )));
    evalMsg( ARGS );
    foreach CMSG | CMSG in CSET do begin
	r!p(MD) D;
	r!p(mai) M;
	D := datum( CMSG );
	M := maiMParse( GetMSG( D ));
	maiCatList( mai:Keywords[M], KW );
	AFile( file:Name[MailF], M, md:Msg#[D] );
    end;
end;

commandProcedure(LIST,list messages one per line);
begin
    set T;
    integer B;
    string FORMAT;
    r!p(MD) itemvar DIV;
    FORMAT := if CheckToken( ARGS, "FORMAT" )
	then strScan( ARGS, B )
	else datum(LIST.FORMAT);
    EvalMsg( ARGS, datum(LIST.DEFAULT) );
    foreach DIV | DIV in CSET do
	printHeadings( datum(DIV), FORMAT );
end;

commandProcedure(LOGOUT,terminate TUMS and log out);
begin
    string S;
    integer B;
    if length( scan( S:=ARGS, brkTok, B )) then begin
	print( CmdLine, crlf&
	    "?aborted by extraneous arguments: ", cvss(ARGS), crlf );
	Args := null;
	return;
    end;
    CheckProfile;
    calli(0,-6);		! detach;
    if DeletedChars
	then Expunge;
    QUIT := "KJOB";
    terminate( myproc );
end;

commandProcedure(OPEN,open alternate message file);
begin
    integer B;
    string S,FileName;
    r!p(file) F;
    FileName := scan( ARGS, brkTok, B );
    if length(FileName) = 0 then begin
	print( "%message file name expected"& crlf );
	return;
    end;
    F := fOpen( FileName, "ro1E:.MSG" );
    if file:EOF[F] then return;
    fClose( F );
    if not kequ( S := file:Name[MailF], datum(MAIL.FILE) ) then
	print( "[file closed: ", S, "]"& crlf );
    OpenMailFile( FileName );
end;

commandProcedure(MAILER,run MAILER to deliver non-local messages);
begin
    print( "This command is obsolete."& crlf );
end;

commandProcedure(MARK,mark messages);
begin
    mark( EvalMsg( ARGS ), mdfMarked );
end;

commandProcedure(MOVE,move messages to file);
begin
    string FileName;
    integer B;
    r!p(MD) D;
    boolean Del!;		! flags to set to delete message;
    Del! := if props(ARCHIVE.MOVED) land props!true
	then mdfDeleted
	else mdfDeleted+mdfNoArchive;
    if CheckToken( ARGS, "NOARCHIVE" ) or CheckToken( ARGS, "NOARC" )
	then Del! := mdfDeleted+mdfNoArchive;
    if CheckToken( ARGS, "ARCHIVE" ) or CheckToken( ARGS, "ARC" )
	then Del! := mdfDeleted;
    FileName := strScan( ARGS, B );
    EvalMsg( ARGS );
    if length(CSET)
	then print( "Messages moved:" )
	else print( "No messages moved."& crlf );
    foreach MDIV | MDIV in CSET do
	if md:FLAGS[D:=datum(MDIV)] land mdfDeleted = 0 then begin
	    r!p(mai) M;
	    md:FLAGS[D] := md:FLAGS[D] lor Del!;
	    deletedChars := deletedChars + md:MSGLEN[D];
	    M := maiMParse( GetMSG( D ));
	    AFile( FileName, M );
	    print( " ", md:Msg#[D] );
	end;
    print( crlf );
end;

commandProcedure(NETMAIL,start MAILER to process net mail immediately);
begin
    maiRunMailer;
    print( "[MAILER started]"& crlf );
end;

commandProcedure(NEWS,display news about recent versions of TUMS);
begin
    integer I;
    for I := arrinfo( NEWS, 2 ) downto arrinfo( NEWS, 1 )
	do print( NEWS[i], crlf );
end;

forward procedure command!READ;

commandProcedure(NEXT,display next message);
begin
    boolean Del!;
    Del! := if CheckToken( ARGS, "DELETE" )
	then if CheckToken( ARGS, "NOARCHIVE" ) or CheckToken( ARGS, "NOARC" )
	    then mdfDeleted+mdfNoArchive
	    else mdfDeleted
	else 0;
    if length(RSET)=0
	then command!READ
	else begin
	    integer I;
	    CSET := RSET;
	    I := listx( RSET, CMSG, 1 );
	    if Del! and I
		then mark( {CMSG}, Del! );
	    if 0 < I < length(RSET)
		then printMsg( datum( CMSG := RSET[i+1] ))
		else print( "[no next message]"& crlf );
	end;
end;

commandProcedure(PREVIOUS,display previous message);
begin
    integer I;
    CSET := RSET;
    I := listx( RSET, CMSG, 1 );
    if 1 < I
	then printMsg( datum( CMSG := RSET[i-1] ))
	else print( "[no previous message]"& crlf );
end;

commandProcedure(PRINT,queue messages for printing);
begin
    string FileName;
    boolean FileSeen;
    integer B;
    FileName := "(~)TUMS.PRT";
    if FileSeen := CheckToken( Args, "FILE" ) then
	FileName := strScan( ARGS, B );
    EvalMsg( ARGS );
    if length(CSET)
	then begin
	    r!p(file) F;
	    r!p(MD) D;
	    r!p(MAI) M;
	    r!p(MD) itemvar DIV;
	    F := fOpen( FileName, "ab15T4E:.PRT" );
	    if not file:EOF[F] then begin
		print( "Messages printed:" );
		foreach DIV | DIV in CSET do begin
		    D := datum(DIV);
		    print( " ", md:Msg#[D] );
		    cprintBanner( file:Chan[F], D );
		    M := maiMParse( GetMSG( D ));
		    cprint( file:Chan[F],
			maiMMake( M ),
			#ff );
		end;
		print( crlf );
	    end;
	    fClose( F );
	end
	else
	    print( "No messages printed."& crlf );
end;

commandProcedure(PROFILE,create TUMS.INI file for current profile);
begin
    NOPOLL := NOPOLL + 1;
    setprint( "("&JBTUNM&")TUMS.INI", "F" );
    printProfile( PROFILE, props!set );
    setprint( null, "T" );
    ProfileChanges := phi;
    NOPOLL := NOPOLL - 1;
end;

commandProcedure(QUIT,terminate TUMS without expunging deleted messages);
begin
    CheckProfile;
    QUIT := true;
    terminate( myproc );
end;

commandProcedure(READ,read messages);
begin
    PutNewInRSET := 0 = length( ARGS );
    EvalMsg( ARGS, "UNREAD" );
    if length( CSET )
	then printMsg( datum( CMSG := cop( RSET := CSET )))
	else print( "No messages read."& crlf );
end;

commandProcedure(RECGC,record garbage collect - debug command);
begin
    external procedure $RECGC;
    external integer array GOGTAB[0:ENDREN];
    if length(ARGS) = 0 then $RECGC;
    if CheckToken( ARGS, "OFF" ) then
	GOGTAB[RGCOFF] := true;
    if CheckToken( ARGS, "ON" ) then
	GOGTAB[RGCOFF] := false;
end;

commandProcedure(REPLY,send reply to message);
begin
    command!ANSWER;
end;

commandProcedure(RESEND,resend message to new recipients);
begin
    r!p(MAI) NewAdrs;
    EvalMsg( ARGS );
    NewAdrs := new!record( MAI );
    if length( CSET ) = 0 then begin
        print( "No messages."& crlf );
	return;
    end;
    inputAdr( NewAdrs );
    maiCatList( mai:RCPT[NewAdrs] := mai:To[NewAdrs], mai:Cc[NewAdrs] );
    maiCatList( mai:RCPT[NewAdrs], mai:Bcc[NewAdrs] );
    print( "Messages resent:" );
    foreach CMSG | CMSG in CSET do begin
	r!p(MD) D;
	r!p(MAI) M;
	print( " ", md:Msg#[D:=datum(CMSG)] );
	M := maiMParse( GetMSG( D ));
	mai:RCPT[M] := mai:RCPT[NewAdrs];
	mai:Return.path[M] := null;
	mai:Resent.from[M] := datum(SEND.FROM);
	mai:Resent.date[M] := maiDate;
	mai:Resent.to[M] := mai:To[NewAdrs];
	mai:Resent.cc[M] := mai:Cc[NewAdrs];
	Send( M );
    end;
    print( crlf );
end;

commandProcedure(SAVE,save current draft on file);
if DRAFT then begin
    integer B;
    AFile( strScan( ARGS, B ), DRAFT );
end
else print( "[no draft]"& crlf );

commandProcedure(SEND,compose and send a message);
begin
    label pSubject,pText;;
    r!p(mai) M;
    M := new!record( mai );
    mai:From[M] := datum(SEND.FROM);
    mai:Date[M] := maiDate;
    inputAdr( M, ARGS );
    ARGS := null;
pSubject:
    print( "Subject: " );
    mai:Subject[M] := inchwl;
    if mai:Subject[M] = "?" then begin
	print("
Enter a brief description of the general subject of the message.  This
appears in the heading of the message for informational purposes only.

");	goto pSubject;
    end;
pText:
    if inputText( M ) then begin
	Send( M );
    end;
end;

commandProcedure(SET,set profile option);
begin
    string VAR;
    integer B;
    boolean BOOL;
    VAR := scan( ARGS, brkTok, B );
    if length(VAR) = 0 then return;
    if equ( VAR, "?" ) then begin
	printHelp( "P" );
	return;
    end;
    if kequ( VAR, "NO" ) or kequ( VAR, "NOT" )
	then begin
	    BOOL := false;
	    VAR := scan( ARGS, brkTok, B );
	end
	else BOOL := true;
    IV := cvsi( VAR, B );
    if B or not (IV in PROFILE) then begin
	print( CmdLine, crlf,
	    "?profile option """, VAR, """ not recognized"& crlf );
	return;
    end;
    put IV in ProfileChanges;
    case typeit(IV) of begin
	[1] props(IV) := (if BOOL then props!true else 0);
	[3] datum(SIV:=IV) := strScan( ARGS, B );
	[4] datum(RIV:=IV) := realScan( ARGS, B );
	[5] datum(IIV:=IV) := intScan( ARGS, B );
	[6] begin
	    string NAME,VALUE;
	    NAME := upper.case(strScan( ARGS, B ));
	    VALUE := strScan( ARGS, B );
	    MakeAssoc( datum(TIV:=IV), NAME, VALUE );
	end;
	[7] begin
	    LIV := IV;
	    while length(datum(LIV)) do
		delete( lop(datum(LIV)) );
	    while length(ARGS) do begin
		string CMD;
		CMD := strScan( ARGS, B );
		if length(CMD) then put new(CMD) in datum(LIV) after inf;
	    end;
	end;
	[else] usererr(typeit(IV),2,"?illegal item type in command!SET")
    end;
    props(IV) := props(IV) lor props!set;
end;

commandProcedure(SHOW,show current profile option settings);
begin
    string VAR;
    integer B;
    VAR := scan( ARGS, brkTok, B );
    if equ(VAR,"?") then begin
	printHelp( "P" );
	return;
    end;
    if length(VAR)
	then begin
	    itemvar IV;
	    boolean FLAG;
	    IV := cvsi( VAR, FLAG );
	    if not FLAG and (IV in PROFILE)
		then begin
		    if IV = ALIAS then begin
			string S;
			boolean SOME;
			SOME := false;
			while length( S := scan( ARGS, brkTok, B ) ) do begin
			    printAliases( S );
			    SOME := true;
			end;
			if SOME then return;
		    end;
		    printProfile( {IV} );
		end
		else print( CmdLine, crlf&
		    "?profile option ", cvss(VAR), " not recognized"& crlf );
	end
	else printProfile( PROFILE );
end;

commandProcedure(STATISTICS,show internal program statistics);
begin
    external integer array GOGTAB[0:ENDREN];
    print(
	"Mail file ", cvss(file:Name[MailF]), ":"& crlf&
	"  size: ", Mail.RPTR + 1, " bytes"&
	    " (", NMSG, " msgs)"& crlf&
	"  marked deleted: ", deletedChars, " bytes"&
	    " (", DeletedPerCent, " %)"& crlf&
	"Free items remaining: ", GOGTAB[freitm], crlf&
	"String garbage collects: ", GOGTAB[sgccnt],
	    " (", GOGTAB[sgcnum], " strings)"& crlf&
	"Low segment: ", (memory['44]+511)%512, " pages"& crlf );
end;

commandProcedure(TYPE,type message on terminal);
begin
    r!p(MD) itemvar DIV;
    EvalMsg( ARGS );
    foreach DIV | DIV in CSET do
	printMsg( datum(DIV) );
end;

commandProcedure(UNANSWER,mark messages as not answered);
begin
    mark( EvalMsg( ARGS ), -mdfAnswered );
end;

commandProcedure(UNDELETE,mark messages as not deleted);
begin
    ARGS := "ALL "& ARGS;
    mark( EvalMsg( ARGS ), -(mdfDeleted lor mdfNoArchive) );
end;

commandProcedure(UNKEYWORD,remove keyword from messages);
begin
    string KW;
    integer B;
    KW := upper.case(strscan( ARGS, B ));
    if B="," then begin
	print( CmdLine, crlf,
	    "?Keyword list not allowed here"& crlf );
	return;
    end;
    evalMsg( ARGS );
    foreach CMSG | CMSG in CSET do begin
	string Si;
	r!p(MD) D;
	r!p(Mai) M;
	D := datum( CMSG );
	M := maiMParse( GetMSG( D ));
	Si := mai:Keywords[M];
	NOPOLL := NOPOLL + 1;
	mai:Keywords[M] := null;
	while length(Si) do begin
	    string S;
	    S := strscan(Si,B);
	    if not kequ(S,KW)
		then maiCatList( mai:Keywords[M], S );
	end;
	NOPOLL := NOPOLL - 1;
	AFile( file:Name[MailF], M, md:Msg#[D] );
    end;
end;

commandProcedure(UNMARK,unmark messages);
begin
    mark( EvalMsg( ARGS ), -mdfMarked );
end;

commandProcedure(UNREAD,mark messages as not read);
begin
    mark( EvalMsg( ARGS ), -mdfRead );
end;

commandProcedure(VERIFY,verify integrity of index - debug command);
begin
    integer N;
    boolean IndexBad;
    for N := 1 upto NMSG do begin
	string S;
	r!p(MD) D;
	integer B;
	D := datum(MDIV_MSGS[n]);
	printHeadings( D, "#  @" );
	schptr( file:Chan[MailF], md:MSGPTR[d] );
	file:Count[MailF] := md:MSGLEN[d];
	S := input( file:Chan[MailF], 0 );
	if wordin( file:Chan[MailF] ) neq #EOT then begin
	    print( "?EOT expected at end of message at ",
		md:MSGPTR[d] + md:MSGLEN[d],
		crlf );
	    IndexBad := true;
	end;
	scan( S, brkEOT, B );
	if B then begin
	    print( "?EOT found in message at ",
		 md:MSGPTR[d] + md:MSGLEN[d] - length(s) - 1,
		 crlf );
	    IndexBad := true;
	end;
    end;
    print( "[index ",if IndexBad then "corrupt" else "okay","]"& crlf );
end;

commandProcedure(VERSION,display program version);
begin
    print( "TUMS-10 version ",
	cvos(!lh(memory['137])),".",
	cvos(!rh(memory['137])),
	" of "& cvms(date!part$c)[1 to 9]& crlf );
end;

preload!with TCMD;
string array CmdTab[0:NCMD];
preload!with HCMD;
string array CmdHlp[0:NCMD];
redefine commandProcedure = null;

procedure command!HELP;
begin
    integer I;
    print( "Valid commands are:"& crlf );
    for I := 1 upto NCMD do
	print( "  ", CmdTab[i],
	    (#ht&#ht&#ht)[(2+length(CmdTab[i]))%8+1 to inf],
	    CmdHlp[i], crlf );
end;

procedure Process( string CmdLine! );
begin
    string Cmd, CmdN;
    integer I, N, B;
    set RecurSet;
    CmdLine := CmdLine!;
    RecurSet := phi;
    while true do begin "expand macros"
	Cmd := scan( ARGS:=CmdLine!, brkTok, B );
	if length(Cmd) = 0 then return;
	SIV := cvsi( Cmd, B );
	if B or not (SIV in datum(MACRO)) then done;
	if SIV in RecurSet then begin
	    print( CmdLine, crlf&
		"?macro ", cvss(Cmd), " called recursively"& crlf );
	    return;
	end;
	put SIV in RecurSet;
	CmdLine! := datum(SIV)& " "& ARGS;
	if props(MACRO.ECHO) land props!true then print( CmdLine!, crlf );
    end;
    CmdN := null;
    for I := 0 upto NCMD do
	if equ( Cmd, CmdTab[i][1 to length(Cmd)] )
	    then if length(Cmd) = length(CmdTab[i])
		then begin
		    CmdN := char!w( I, 36 );
		    done;
		end
		else CmdN := CmdN& char!w( I, 36 );
    if length(CmdN) < 1 then begin
	print( CmdLine, crlf&
	    "?command ", cvss(Cmd), " not recognized"& crlf );
	return;
    end;
    if length(CmdN) > 1 then begin
	print( Cmd, " ", Args, crlf,
	    "?command """, Cmd, """ is ambiguous among the following:", crlf );
	while length(CmdN) do print( "  ", CmdTab[lop(CmdN)], crlf );
	return;
    end;
    case CmdN of begin
	CCMD;			! this macro expands to procedure calls;
    end;
    if length(ARGS) then begin
	string S;
	integer B;
	if length( scan( S:=ARGS, brkTok, B ))
	    then print( CmdLine, crlf&
		"%extraneous arguments ignored: ", cvss(ARGS), crlf );
	ARGS := null;
    end;
end;

procedure ProcessCmds;
begin
    string CMD;
    integer B;
    while true do begin
	ARGS := null;
	auxclv( -1, 0, '50 );	! skip if line waiting - to clear ^O;
	License( OFF );		! in case somebody was sloppy;
	print( datum(PROMPT) );
	CMD := inchwl; B := !SKIP!;
	if B neq #cr then begin
	    CMD := "^"& ("@"+B)& " "& CMD;
	    print( if B=#lf then #cr else crlf );
	end;
	Process( CMD );
	getMail;
	maiSend;
    end;
end;

procedure Process!TUMS.INI;
begin
    r!p(file) F;
    string SaveARGS;
    SaveARGS := ARGS;
    CmdLine := "processing TUMS.INI";
    F := fOpen( "(~)TUMS.INI", "rbx" );
    while not file:EOF[F] do begin
	ARGS := input( file:Chan[F], brkLine );
	command!SET;
    end;
    fClose( F );
    ARGS := SaveARGS;
    ProfileChanges := phi;
end;

    License( OFF );
    ifcr compiler!switch("B") thenc
	begin
	    external procedure BAIL;
	    if CheckToken( ARGS, "BAIL" ) then BAIL;
	end;
    endc
    command!VERSION;
    Process!TUMS.INI;
    if ARGC > 1 or kequ(ARGV[0],"SENDMAIL"[1 to length(ARGV[0])])
	then begin "CCL"
	    command!SEND;
	    maiSend;
	end
	else begin "SUBCOMMAND"
	    list L;
	    OpenMailFile( datum(MAIL.FILE) );
	    LastNMSG := NMSG;
	    command!CHECK;
	    L := datum(INIT);
	    while length(L) do process( datum(SIV_lop(L)) );
	    OnInt;
	    while not QUIT do begin
		sprout( CmdProcess, ProcessCmds );
		join( {CmdProcess} );
	    end;
	    CloseMailFile;
	end;
    if QUIT = "KJOB" then calli( 0, -'130 );	! logout;
    print( "End of SAIL execution" );
    CORE0;

end "TUMS"
$
 oZ