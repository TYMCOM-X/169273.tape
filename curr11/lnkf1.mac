	.TITLE	LNKF1  - Interrupt routines for Tymshare host without KMC11
	.SBTTL	LNKF1  - Nexilis/JRG

	XLPAR			;DON'T LIST PARAMETER FILES
	CODE

	.SBTTL	LNKF1  - Input interrupt routine

;HERE FROM CODE IN COMMON ON INPUT READY INTERRUPT
;  THE CODE EXECUTED BEFORE WE GET HERE IS AS FOLLOWS:
;	LKFIn:	PUSH	R4		;SAVE R4
;		MOV	#LKFn$,R4	;GET ADDRESS OF DDB
;		JMP	LKFIIN		;GO TO COMMON ROUTINE

LKFIN1::PUSH	R0
	MOV	@DDLFIR#(R4),R0		;GET DATA WORD
	BIC	#$DVACP,@DDLFSR#(R4)	;CLEAR THE HARDWARE FLAG
	PUSH	R1			;SAVE ANOTHER AC
	MOVB	DDLFIS#(R4),R1		;GET INPUT STATE
.IF NE ..BUG
	MOVB	R1,@DBRNGP#		;STORE STATE IN DEBUG RING
	INC	DBRNGP#
	MOVB	DDLFIC#(R4),@DBRNGP#	;STORE INPUT COUNT IN DEBUG RING
	INC	DBRNGP#
	MOV	R0,@DBRNGP#		;STORE DATA IN DEBUG RING
	SWAB	@DBRNGP#
	ADD	#2,DBRNGP		;BUMP POINTER
	CMP	#DBRNGE#,DBRNGP		;AT END OF RING?
	BHI	2$			;NO
	MOV	#DBRING#,DBRNGP		;YES-RESET POINTER
.ENDC
2$:	ASL	R1
	JMP	@INPDSP(R1)		;DISPATCH ON THE INPUT STATE

;INPUT STATE DISPATCH TABLE

	PURE

INPDSP:	.WORD	INPIDL			;.ISIDL =  0 - INPUT IS IDLE
	.WORD	INPDAT			;.ISDAT =  1 - WAITING FOR DATA WORD
	.WORD	INPMSG			;.ISMSG =  2 - WAITING FOR MESSAGE
	.WORD	INPWAT			;.ISWAT =  3 - INPUT IS WAITING FOR
					;		 MAIN PROGRAM LEVEL
	.WORD	INPBKX			;.ISIDX =  4
	.WORD	INPBKX			;.ISDAX =  5
	.WORD	INPBKX			;.ISMSX =  6
	.WORD	INPRST			;.ISRST =  7 - RESET
	.WORD	INPBKB			;.ISIDB = 10
	.WORD	INPBKB			;.ISDAB = 11
	.WORD	INPBKB			;.ISMSB = 12

	CODE

;HERE IF INPUT IS IDLE NOW

INPIDL:	CMP	#-1,R0			;PREFIX VALUE?
	BEQ	INPXXX			;YES
INPID2:	MOV	R0,DDLFIX#(R4)		;NO-STORE DATA IN DDB
	BMI	4$			;IF DATA MESSAGE
	SWAB	R0
	CMPB	#MAXMSG#,R0		;NO-VALID MESSAGE?
	BGE	3$			;YES
	CLR	R0			;NO!
	CLRB	DDLFIX#+1(R4)
3$:	BIC	#^C177,R0		;REMOVE JUNK
	MOVB	MSGLEN#(R0),DDLFIC#(R4)	;STORE WORD COUNT
	BISB	#1,DDLFIC#(R4)		;ROUND UP TO WHOLE PDP-10 WORDS
	MOV	#DDLFIX#+2,R0		;GET POINTER TO MESSAGE BUFFER
	ADD	R4,R0
	MOV	R0,DDLFIP#(R4)
	MOVB	#.ISMSG,DDLFIS#(R4)	;SET NEW INPUT STATE
	JMP	INPACP			;AND DISMISS

;HERE IF DATA STRING

4$:	SWAB	R0
	BIC	#^C177,R0		;GET BYTE COUNT
	MOV	R0,DDLFCC#(R4)		;STORE BYTE COUNT
	INC	R0			;CHANGE TO WORD COUNT
	ASR	R0
	ASR	R0
	INC	R0
	ASL	R0
	DEC	R0
	MOV	R0,DDLFIC#(R4)		;STORE WORD COUNT
	CALL	MAKPKI			;GET A PACKET
	MOV	R1,DDLFIK#(R4)		;STORE ADDRESS OF PACKET
	MOV	R1,DDLFIQ#(R4)
	ADD	#PKDATA,R1		;POINT TO FIRST DATA WORD
	MOV	R1,DDLFIP#(R4)		;STORE POINTER
	MOVB	#PKCMAX/2,DDLFPC#(R4)	;STORE COUNT IN PACKET
	INCB	DDLFIS#(R4)		;BUMP INPUT STATE
	BR	INPACP			;AND DISMISS INTERRUPT FOR NOW

;HERE WHEN EXPECTING WORD FOLLOWING PREFIX VALUE

INPBKX:	TST	R0			;WAS THE PREFIX REALLY DATA?
	BNE	INPXX2			;NO-GO ON
	MOV	#-1,R0			;YES-GET ITS VALUE
	BICB	#^C3,DDLFIS#(R4)	;RESTORE STATE
	MOVB	DDLFIS#(R4),R1		;GET STATE
	ASL	R1			;AND DISPATCH ON IT
	ADD	R1,PC
	BR	INPID2			;.ISIDL =  0 - IDLE
	BR	INPDA2			;.ISDAT =  1 - DATA
	BR	INPMS2			;.ISMSG =  2 - MESSAGE

;HERE WITH BLOCK MODE OUTPUT DATA FROM THE HOST

INPXX2:	CALL	MAKPKI			;GET A PACKET
	MOV	R1,DDLFBK#(R4)		;SAVE ADDRESS OF PACKET
	MOV	R1,DDLFBQ#(R4)
	ADD	#PKDATA,R1		;MAKE DATA POINTER
	MOV	R1,DDLFBW#(R4)		;AND STORE IT
	MOVB	#PKCMAX/2,DDLFBY#(R4)	;START COUNT
INPXXX:	ADD	#4,DDLFIS#(R4)		;BUMP STATE
	BR	INPACP			;THATS ALL FOR THIS TIME

;HERE WHEN EXPECTING DATA WORD FOR BLOCK MODE

INPBKB:	SWAB	R0			;PUT BYTES IN RIGHT ORDER
	MOV	R0,@DDLFBW#(R4)		;STORE IN PACKET
	DEC	DDLFBC#(R4)		;MORE COMING?
	BLE	INPBDN			;NO-FINISHED WITH THIS
	DECB	DDLFBY#(R4)		;YES-MORE ROOM IN THIS PACKET?
	BEQ	2$			;NO
	ADD	#2,DDLFBW#(R4)		;YES-JUST BUMP POINTER
	BR	INPACP			;AND DISMISS

;HERE IF MUST START A NEW PACKET

2$:	CALL	MAKPKI			;GET A PACKET
	MOV	R1,@DDLFBQ#(R4)		;LINK TO PREVIOUS PACKET
	MOV	R1,DDLFBQ#(R4)
	ADD	#PKDATA,R1		;POINT TO START OF DATA
	MOV	R1,DDLFBW#(R4)		;STORE POINTER
	MOVB	#PKCMAX/2,DDLFBY#(R4)	;RESET COUNT
	BR	INPACP			;AND DISMISS

;HERE WHEN BLOCK MODE IS FINISHED

INPBDN:	BICB	#^C3,DDLFIS#(R4)	;RESTORE THE STATE
	BISB	#$RQBLK,DDLFRQ#(R4)	;REQUEST MAIN PROGRAM SERVICE
	BR	INPDSM			;AND DISMISS

;HERE WHEN WAITING FOR RESET

INPRST:	SWAB	R0
	CMPB	#.MSHSI,R0		;IS IT "SPECIFY HOST PORTS"?
	BNE	INPACP			;NO-IGNORE IT!
	CLRB	DDLFIS#(R4)		;YES-CHANGE STATE
	SWAB	R0			;RESTORE DATA WORD
	JMP	INPID2			;AND GO PROCESS THE MESSAGE

;HERE WHEN EXPECTING A DATA WORD

INPDAT:	CMP	#-1,R0			;PREFIX VALUE?
	BEQ	INPXXX			;YES
INPDA2:	SWAB	R0			;GET BYTES IN RIGHT ORDER!
	MOV	R0,@DDLFIP#(R4)		;STORE DATA
	DECB	DDLFIC#(R4)		;REDUCE THE WORD COUNT
	BEQ	INPDON			;IF FINISHED NOW
	DECB	DDLFPC#(R4)		;MORE TO GET-WILL IT FIT IN THE CURRENT
					;  PACKET?
	BEQ	INPDA6			;NO-GO GET ANOTHER PACKET
INPDA4:	ADD	#2,DDLFIP#(R4)		;BUMP POINTER
INPACP:	BIS	#$DVACP+$DVENB,@DDLFSR#(R4);ACCEPT THE INPUT
INPDSM:	POP	R1			;RESTORE AC'S
	POP	R0
	POP	R4
	RTI				;DISMISS INTERRUPT

;HERE IF MUST ALLOCATE ANOTHER PACKET FOR A LONG DATA MESSAGE

INPDA6:	CALL	MAKPKI			;GET A PACKET
	MOV	R1,@DDLFIQ#(R4)		;LINK IN THE NEW PACKET
	MOV	R1,DDLFIQ#(R4)		;SAVE ITS ADDRESS
	ADD	#PKDATA,R1		;POINT TO FIRST DATA WORD
	MOV	R1,DDLFIP#(R4)		;STORE POINTER
	MOVB	#PKCMAX/2,DDLFPC#(R4)
	BR	INPACP			;GO FINISH UP

;HERE WHEN EXPECTING AN ARGUMENT WORD FOR A CONTROL MESSAGE


INPMSG:	CMP	#-1,R0			;PREFIX VALUE?
	BEQ	INPXXX			;YES
	SWAB	R0			;NO-PUT BYTES IN RIGHT ORDER
	MOV	R0,@DDLFIP#(R4)		;STORE DATA
INPMS2:	DECB	DDLFIC#(R4)		;EXPECTING MORE?
	BGT	INPDA4			;YES
					;NO-FALL INTO INPDON

;HERE WHEN FINISHED DOING INPUT - NOTIFY MAIN PROGRAM LEVEL

INPDON:	MOVB	#.ISWAT,DDLFIS#(R4)	;SET NEW INPUT STATE
	BISB	#$RQINP,DDLFRQ#(R4)	;REQUEST INPUT SERVICE
	BR	INPDSM			;AND DISMISS INTERRUPT

;HERE IF GET INPUT INTERRUPT WHILE WAITING FOR MAIN PROGRAM LEVEL TO PROCESS
;  SOME INPUT - THIS IS AN ERROR SINCE WE HAVE NOT YET ACCEPTED THE LAST
;  INPUT WORD!

INPWAT:	INC	DDERSI#(R4)		;COUNT THE FUNNY INTERRUPT!
	BR	INPDSM			;AND TRY TO CONTINUE (PROBABLY WE ARE
					;  TOO SICK TO CONTINUE AT THIS POINT!)
	.PAGE
;SUBROUTINE TO GET A PACKET FOR INPUT INTERRUPT ROUTINE
;	CALL	MAKPKI
;	C(R1) = ADDRESS OF PACKET
;  WARNING *** WHEN CALLED THE STACK MUST BE SET UP AS FOLLOWS:
;	C((SP))    = SAVED C(R1)
;	C((SP)-2)  = SAVED C(R0)
;	C((SP)-4)  = SAVED C(R4)
;	C((SP)-6)  = INTERRUPT RETURN ADDRESS
;	C((SP)-10) = INTERRUPT RETURN PSW

MAKPKI:	MAKPKT	.PLOPT#			;GET A PACKET
	BCS	2$			;If none available
	RETURN				;Finished if got one

;Here if no packet is available now

2$:	TST	DDLFXR#(R4)		;NONE AVAILABLE-ARE WE RECOVERING NOW?
	BEQ	4$			;NO-OK
	FSTOP	PWE			;[PACKET WAIT ERROR]

4$:	POP	DDLFX1#(R4)		;SAVE RETURN ADDRESS
	MOV	#INTRCV,DDLFXR#(R4)	;STORE ADDRESS OF RECOVERY ROUTINE
	BR	INPDSM			;AND GIVE UP FOR NOW!

;HERE AT MAIN PROGRAM LEVEL WHEN HAVE A PACKET AVAILABLE

INTRCV:	SETPSW	DDLFPL#(R4)		;RAISE TO INTERRUPT LEVEL
	MOV	(SP),R0			;GET RETURN ADDRESS
	CLR	(SP)			;PUT FAKE PSW ON THE STACK
	PUSH	R0			;THEN THE RETURN ADDRESS
	PUSH	R4			;THEN R4
	SUB	#4,SP			;THEN 2 GRABBAGE WORDS
	JMP	@DDLFX1#(R4)		;CONTINUE WHERE WE LEFT OFF!
	.PAGE
	.SBTTL	LNKF1  - Output interrupt routine

;HERE FROM CODE IN COMMON ON OUTPUT DONE INTERRUPT
;  THE CODE EXECUTED BEFORE WE GET HERE IS AS FOLLOWS:
;	LKFOn:	PUSH	R4		;SAVE R4
;		MOV	$HSn$,R4	;GET ADDRESS OF DDB
;		JMP	LKFOIN		;GO TO COMMON ROUTINE

LKFOU1::BIC	#$DVOUT,@DDLFSR#(R4)	;CLEAR THE OUTPUT FLAG
	PUSH	R0			;SAVE ANOTHER AC
	ADD	DDLFOS#(R4),PC		;DISPATCH ON OUTPUT STATE
	BR	LFONRM			;.OSNRM = 0 - NORMAL OUTPUT
	BR	LFOHLD			;.OSHLD = 2 - OUTPUT HELD BLOCK DATA
	BR	LFOBLK			;.OSODD = 4 - OUTPUT NON-ALLIGNED DATA
	BR	LFONRM			;.OSBMO = 6 - START OF BLOCK MODE -
					;		SAME AS .OSNRM

;HERE TO OUTPUT NON-ALLIGNED DATA

LFOBLK:	DECB	DDLFOC#(R4)		;MORE TO OUTPUT?
	BLT	OUTDON			;NO
	CLR	R0			;YES-GET THE WORD TO OUTPUT
	BISB	@DDLFOP#(R4),R0
	INC	DDLFOP#(R4)
	SWAB	R0
	BISB	@DDLFOP#(R4),R0
	INC	DDLFOP#(R4)
	BR	OUTPTI			;AND GO OUTPUT IT

;HERE TO OUTPUT 2ND WORD OF THE BLOCK MODE HOLD BUFFER

LFOHLD:	CLR	DDLFOS#(R4)		;ASSUME ALLIGNED
	BIT	#1,DDLFOP#(R4)		;IS THE FOLLOWING OUTPUT WORD ALLIGNED?
	BEQ	2$			;YES
	MOV	#.OSODD,DDLFOS#(R4)	;NO-MUST DO IT THE HARD WAY!
2$:	MOV	DDLFOZ#(R4),R0		;GET ADDRESS OF SDB
	MOV	SDLFVH#+2(R0),R0	;GET WORD TO OUTPUT
	BR	OUTPTX			;AND GO OUTPUT IT

;HERE FOR NORMAL OUTPUT

LFONRM:	DECB	DDLFOC#(R4)		;ANY MORE TO OUTPUT?
	BLT	OUTDON			;NO
	MOV	@DDLFOP#(R4),R0		;YES-GET WORD
	ADD	#2,DDLFOP#(R4)		;BUMP OUTPUT POINTER
OUTPTX:	SWAB	R0			;PUT BYTES IN RIGHT ORDER
OUTPTI:	MOV	R0,@DDLFOR#(R4)		;OUTPUT IT
	BIS	#$DVOUT+$DVENB,@DDLFSR#(R4);MAKE IT VISIBLE
OUTDSM:	POP	R0			;RESTORE AC'S
	POP	R4
	RTI				;AND DISMISS

;HERE IF FINISHED WITH THIS MESSAGE

OUTDON:	BISB	#$RQOUT,DDLFRQ#(R4)	;REQUEST OUTPUT SERVICE
	BR	OUTDSM			;AND DISMISS


; LKFENB -SUBROUTINE TO ENABLE THE DR11

LKFENB:: TBBE	$DVDON,@DDLFSR#(R4),10$	;IS THE INTERFACE IN GOOD CONDITION
	CMP	#-1,@DDLFIR#(R4)	;NO, AND IS THE CABLE HANGING LOOSE
	BEQ	30$			;YES, DON'T ENABLE IT
;	BIT	#^C<.MSHSI*400+177>,@DDLFIR#(R4) ;IS THE BIT PATTERN REASONABLE
;	BNE	30$			;NO, DON'T ENABLE
;	PUSH	R0			;GET A REG FOR USE
;	MOV	@DDLFIR#(R4),R0		;GET THE DATA
;	SWAB	R0			;MOVE DATA WE WANT TO TEST TO LOW BYTE
;	CMPB	#.MSHSI,R0		;TEST FOR CORRECT HOST PORTS MSG (RESTART)
;	BNE	20$			;NOT RESTART, DON'T ENABLE
10$:	MOV	#$DVENB,@DDLFSR#(R4)	;ENABLE THE INTERFACE
;	ADD	#2,2(SP)		;SKIP RETURN ON SUCCESS
	ADD	#2,(SP)			;SKIP RETURN ON SUCCESS
20$:;	POP	R0
30$:	RETURN				;THATS ALL

; LKFDII - DISABLE THE DR11 INTERFACE

LKFDII:: CLR	@DDLFSR#(R4)		;DISABLE THE INTERFACE
	RETURN

; LKFACP - ACCEPT THE LAST WORD OF A BLOCK AND ENABLE FOR MORE DATA

LKFACP:: BIS	#$DVACP+$DVENB,@DDLFSR#(R4);ACCEPT THE LAST INPUT WORD
	RETURN

;LKFSTO - START AN OUTPUT SEQUENCE

LKFSTO:: MOV	R0,@DDLFOR#(R4)		;OUTPUT THE WORD
	BIS	#$DVOUT+$DVENB,@DDLFSR#(R4);MAKE IT VISIBLE
	RETURN

;LKFCLR - CLEAR OUR BITS IN THE DR11C

LKFCLR:: BIC	#$DVACP!$DVOUT,@DDLFSR#(R4);CLEAR THE HARDWARE FLAG BITS
	RETURN
	.END
 