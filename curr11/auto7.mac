	.TITLE	AUTO7  - AUTO BAUD ROUTINES FOR TYPE 7
	.SBTTL	AUTO7  - NEXILIS/JRG

;These auto-baud detect routines use a DL11 type Async Interface as a high
;  speed clock for timing detect events.  Only DZ11 or DZV11 interfaces may be
;  used for the auto-baud ports.  The DL11 interface may also be used to drive
;  Tymshare watchdog timer.  This routine will output something to the DL11
;  port at least once a second.  This routine may be mixed with other auto-baud
;  routines except for type 6.  The watchdog timer module DOG should not be
;  loaded with this module.  All necessary watchdog timer functions are
;  done by this module.

	XLPAR
	CODE

;SUBROUTINE TO INITIALIZE AUTO-BAUD DETECT ROUTINE
;	C(R1) = ADDRESS OF 2ND WORD IN DETECT TABLE
;	C(SD) = ADDRESS OF SDB
;	CALL	AINI7

AINI7::	MOV	#CHKRAT,SDTRC1#(SD)	;STORE INITIAL DISPATCH
	MOV	(R1),R1			;GET DETECT RATE
	BIC	#$T3IRT!$T3ORT,SDTRS3#(SD);Store it in the SDB
	BISB	R1,SDTRS3#(SD)
	BISB	R1,SDTRS3#+1(SD)
	MOV	#.LFSET,R0		;Setup the interface hardware
	CALL	TRMFNC#
	TBBN	$T0HWR,SDTRS0#(SD),2$	;HARD WIRED TERMINAL?
	MOV	#JIFX20#,R0		;NO-ALLOW 20 SECONDS FOR DETECT
	MOV	#BRDTMO#,R1
	CALL	TIMREQ#
2$:	MOV	#BAUDMS,SDTRIP#(SD)	;YES-SETUP FOR FUNNY OUTPUT
	MOV	#OUTIDL#,SDTROD#(SD)
	CLR	SDTRC3#(SD)
	SETPSW	#340			;;NO INTERRUPTS NOW
	MOV	FSCOUT,SDTRCP#(SD)	;;PUT THIS SDB INTO THE FUNNY OUTPUT
	MOV	SD,FSCOUT		;;  LIST
	MOV	#100,@#FSCCSR#		;;START THE DL INTERRUPTING IF NOT GOING
	CLRPSW				;;INTERRUPTS OK NOW
RTN002:	RETURN				;THATS ALL (THATS ENOUGH!)
	.PAGE
;SUBROUTINE TO RESET AUTO-DETECT ROUTINE - THIS IS A HARD RESET IN THAT THE
;  "FUNNY CHARACTER" OUTPUT IS STOPPED IMMEDIATELY, EVEN IF IS IN THE MIDDLE
;  OF A CHARACTER!  WHEN THIS SUBROUTINE RETURNS, ALL SHARED WORDS IN THE
;  TERMINAL SDB ARE CLEAR.
;	CALL	ARST7

ARST7::	SETPSW	#340			;;NO INTERRUPTS HERE!!
	MOV	FSCOUT,R0		;;GET FIRST SDB IN OUTPUT LIST
	BEQ	4$			;;IF LIST EMPTY
	CMP	R0,SD			;;IS IT OURS?
	BNE	2$			;;NO
	MOV	SDTRCP#(SD),FSCOUT	;;YES-REMOVE IT FROM THE LIST
	BR	12$			;;CONTINUE

;;HERE IF WE ARE NOT FIRST IN THE LIST

2$:	MOV	SDTRCP#(R0),R1		;;GET NEXT IN LIST
	BNE	5$			;;GO ON IF MORE THERE
4$:	CLRPSW				;;END OF LIST-INTERRUPTS OK
	BR	ARST7B

5$:	CMP	R1,SD			;;IS THIS ONE OURS?
	BEQ	6$			;;YES
	MOV	R1,R0			;;NO-ADVANCE POINTER
	BR	2$			;;AND CONTINUE

;;HERE WITH MATCH

6$:	MOV	SDTRCP#(SD),SDTRCP#(R0)	;;REMOVE FROM LIST
12$:	CLRPSW				;;INTERRUPTS OK NOW
	MOV	SDTRAD#(SD),R4		;GET ADDRESS OF ADB FOR LINE
	MOV	#.LFEBK,R0		;SET UP FUNCTION TO STOP BREAK
	CALL	@ADFUNC#(R4)		;CALL FUNCTION ROUTINE
	CLR	SDTRCP#(SD)		;CLEAR OUT THE POINTERS
	CLR	SDTRIP#(SD)
ARST7B:	TBBE	$T6FSC,SDTRS6#(SD),20$	;ARE WE USING THE FAST CLOCK?
	CALL	STPFSC			;YES-BUT NOT ANY MORE
20$:	MOV	#HAVRAT,R1		;KILL ALL POSSIBLE TIMERS
	CALL	TIMKIL#
	MOV	#SECTMO,R1
	CALL	TIMKIL#
	MOV	#BRDTMO#,R1
	CJMP	TIMKIL#
	.PAGE
;SUBROUTINE TO STOP USING THE FAST CLOCK
;	CALL	STPFSC

STPFSC:	TBBE	$T6FSC,SDTRS6#(SD),20$	;;ARE WE USING TH FAST CLOCK
	SETPSW	#340			;;YES - NO INTERRUPTS NOW!
	BIC	#$T6FSC,SDTRS6#(SD)	;;NOT USING FAST CLOCK NOW!
	DECB	FSCUSR			;;REDUCE FAST CLOCK USER COUNT
	BGE	2$			;;JUST TO BE SAFE!!
	RSTOP	BCC			;;[Bad Clock Count]

2$:	CLRPSW				;;INTERRUPTS OK NOW
20$:	RETURN				;THATS ALL
	.PAGE
;HERE WHEN DETECT CHARACTER RECEIVED WHEN DETECT CODE IS IDLE
;	C(R0) = CHARACTER
;	C(R1) = BAUD RATE CODE
;	C(SD) = ADDRESS OF SDB
;	CALL	CHKRAT

CHKRAT:	ASL	R1			;ADJUST FOR WORD INDEXING
	MOV	ATOTXX#(R1),R3		;GET POINTER TO TABLE
	ADD	#6,R3			;POINT TO FIRST ENTRY
	BR	AUTO0			;CONTINUE

;HERE WITH DETECT CHARACTER WHEN EXPECTING SECONDARY CHARACTER
;	C(R0) = CHARACTER
;	C(SD) = ADDRESS OF SDB
;	CALL	CHKSND

CHKSND:	CLR	R1			;CALCULATE TIME INTERVAL
	BISB	FSCTIC,R1
	CLR	R2
	BISB	SDTRC2#+1(SD),R2
	SUB	R2,R1
	BGE	2$
	ADD	#400,R1
2$:	MOVB	SDTRC2#(SD),R2		;GET SECONDARY TABLE INDEX
	MOV	SECTBL#(R2),R3		;GET ADDRESS OF SECONDARY TABLE
AUTO0:	CMP	#CHKSND,SDTRC1#(SD)	;ARE WE SCANNING A SECONDARY TABLE?
	BNE	4$			;NO-GO ON
	CMPB	R1,(R3)+		;YES-LESS THAN MINIMUM TIME?
	BLT	AUTO7			;YES-RESET DETECT
	CMPB	R1,(R3)+		;GREATER THAN MAXIMUM TIME?
	BLE	4$			;NO-WE ARE IN THE WINDOW!
	ADD	#6,R3			;NO-BUMP TO NEXT ENTRY
	BR	AUTO5			;AND CONTINUE

;HERE IF WE ARE IN THE TIME WINDOW FOR THIS ENTRY

4$:	MOV	R0,R2			;COPY CHARACTER
	BICB	(R3)+,R2		;REMOVE DON'T CARE BITS
	CMPB	(R3)+,R2		;THIS ONE?
	BEQ	AUTO8			;YES
	INC	R3
AUTO4:	ADD	#3,R3			;BUMP TO NEXT ENTRY
AUTO5:	CMPB	#377,(R3)		;MORE THERE?
	BNE	AUTO0			;YES-CONTINUE
AUTO7:	MOV	#SECTMO,R1		;CLEAR POSSIBLE TIMER
	CALL	TIMKIL#
AUTO7A:	MOV	#CHKRAT,SDTRC1#(SD)	;RESET DETECT DISPATCH
	CJMP	STPFSC			;STOP THE FAST CLOCK AND RETURN

;HERE WITH MATCH ON THE CHARACTER

AUTO8:	MOVB	(R3)+,R1		;GET FLAGS
	BPL	AUTO9			;GO ON IF DON'T CARE ABOUT FRAMING
	TBBN	100,R1,14$		;SHOULD THERE BE A FRAMING ERROR?
	TST	R0			;NO-WAS THERE ONE?
	BMI	AUTO4			;YES-NOT A MATCH!
	BR	AUTO9			;NO-GO ON

;HERE IF SHOULD HAVE A FRAMING ERROR

14$:	TST	R0			;WAS THERE A FRAMING ERROR?
	BPL	AUTO4			;NO-NO MATCH!

;HERE WITH MATCH ON EVERYTHING

AUTO9:	MOVB	(R3),R1			;YES-GET RATE
	SWAB	R1			;IN BOTH HALVES
	BISB	(R3)+,R1
	BNE	22$			;GO ON IF FINISHED NOW
	MOVB	(R3),SDTRC2#(SD)	;GET INDEX FOR SECONDARY TABLE
	CMP	#CHKSND,SDTRC1#(SD)	;ARE WE ALREADY IN A SECONDARY TABLE?
	BEQ	10$			;YES - DON'T START TWO TIMERS
	SETPSW	#340			;;NEED TO GET SECONDARY CHARACTER
	MOV	#100,@#FSCCSR#		;;START THE FAST CLOCK
	INCB	FSCUSR			;;
	BIS	#$T6FSC,SDTRS6#(SD)	;;REMEMBER WE ARE USING THE FAST CLOCK
	CLRPSW				;;
	MOV	#CHKSND,SDTRC1#(SD)	;CHANGE DISPATCH FOR SECONDARY STUFF
	MOV	#10.,R0			;GET TIMEOUT TIME
	MOV	#SECTMO,R1		;AND TIMEOUT ADDRESS
	MOVB	FSCTIC,SDTRC2#+1(SD)	;SAVE CURRENT FAST TIME
	CJMP	TIMREQ#			;START TIMER AND LEAVE
10$:	RETURN

;HERE WHEN RATE IS FINALLY KNOWN

22$:	CALL	STPFSC			;STOP THE FAST CLOCK
	PUSH	R3			;SAVE POINTER
	BIC	#$T3IRT!$T3ORT,SDTRS3#(SD);STORE RATE IN SDB
	BIS	R1,SDTRS3#(SD)
	MOV	#.LFSET,R0		;SETUP THE INTERFACE HARDWARE
	CALL	TRMFNC#
	MOV	SDTRIP#(SD),R0		;ARE WE OUTPUTING A MESSAGE?
	BEQ	24$			;NO
	SETPSW	#340			;;NO INTERRUPTS NOW
	MOVB	#-40,SDTRC3#+1(SD)	;;SET STATE TO STOP AFTER CURRENT BYTE
23$:	CLRPSW				;;INTERRUPTS OK NOW
24$:	CALL	ARST7B			;CLEAR ALL POSSIBLE TIMERS
	MOVB	@0(SP),R0		;GET TERMINAL TYPE
	BMI	26$			;IF SHOULD NOT SET IT
	CALL	SETTTP#			;SETUP THE TERMINAL TYPE PARAMETERS
	  NOP				;Should not fail!
26$:	MOV	#.LFSET,R0
	CALL	TRMFNC#
	INC	(SP)			;POINT TO CODE
	MOVB	@(SP)+,SDTRXC#(SD)	;STORE CODE IN THE SDB
	MOV	#RTN002,SDTRC1#(SD)	;CHANGE DISPATCH SO WILL IGNORE INPUT
					;  FOR A WHILE
	MOV	#HAVRAT,R1		;DELAY FOR 1/2 SECOND
	MOV	#JIFO2#,R0
	CJMP	TIMREQ#

;HERE 1/2 SECOND AFTER BAUD RATE IS DETERMINED

HAVRAT:	CALL	ARST7			;MAKE SURE ALL TIMERS ARE CLEAR
	CJMP	BRDRDY#			;CONTINUE

;HERE ON SECONDARY DETECT TIMEOUT

SECTMO:;CALL	STPFSC			;STOP THE FAST CLOCK
	MOVB	SDTRC2#(SD),R2		;GET INDEX FOR SECONDARY TABLE
	MOV	SECTBL#(R2),R3		;GET ADDRESS OF SECONDARY TABLE
	TSTB	(R3)			;IS THIS A DEFAULT ENTRY?
	BNE	AUTO7A			;NO-FALSE ALARM-RESET US
	ADD	#5,R3			;YES-POINT TO DATA
	BR	AUTO9			;AND GO SET THE RATE
	.PAGE
	.SBTTL	AUTO7  - Watchdog timer

;Subroutine called once a second to poke the watchdog timer if necessary

	ONCSEC	WATCHD

WATCHD:	CLR	FSCHNG			;Clear the hung counter
	BIT	#100,@#FSCCSR#		;Is the fast clock running?
	BNE	10$			;Yes
	MOV	#'!,@#FSCCSR#+2		;No-poke the watchdog!
10$:	RETURN				;Thats all
	.PAGE
	.SBTTL	AUTO7  - INTERRUPT LEVEL ROUTINES

;"Clock" interrupt routine - this routine is entered directly from the output
;  done interrupt for the DL11 used as the clock device.  No registers have
;  been saved.
;This subroutine uses several terminal sdb words for its data.  These are
;  words which are used by the terminal service for other things, but this
;  is OK since they are only used for input or for command mode.  Since this
;  routine is only active when in baud detect state, there is no possible
;  conflict (we hope).
;    THESE WORDS ARE USED AS FOLLOWS:
;	C(SDTRIP(SD))   = POINTER TO CURRENT OUTPUT BYTE (WORD)
;	C(SDTRCP(SD))   = ADDRESS OF NEXT SDB IN OUTPUT LIST (WORD)
;	C(SDTRC3(SD))   = BIT MASK FOR OUTPUT STREAM (BYTE)
;	C(SDTRC3+1(SD)) = OUTPUT STATE COUNTER (BYTE)
;	C(SDTRC4(SD))   = INDICATOR OF THE LAST BIT OUTPUT

	VECTOR	FSCVEC#,FSCINT,5

FSCINT:	INC	FSCHNG			;Bump the hung timer
	CMP	#5000.,FSCHNG		;Are we hung?
	BHI	1$			;No
	RSTOP	HNG			;[HuNG]

1$:	DECB	FSCCNT			;TIME FOR NEXT BAUD?
	BGE	42$			;NO-GO ON
	DECB	FSCCN2			;YES-REDUCE 2ND LEVEL COUNTER
	BGE	2$			;DID IT RUN OUT?
	MOVB	#4,FSCCN2		;YES-RESET IT
2$:	PUSH	SD			;Save registers
	PUSH	R0
	MOVB	FSCCN2,R0		;GET 2ND LEVEL COUNT
	MOVB	CNTTBL(R0),FSCCNT	;SET 1ST LEVEL COUNT TO 19.2 CHARS PER 300 BAUD
	MOV	#FSCOUT,SD		;MAKE FAKE LIST PRED.
	SUB	#SDTRCP#,SD
	CLR	FSCINH			;RESET INHIBITOR
4$:	MOV	SD,R0			;ADVANCE POINTER
6$:	MOV	SDTRCP#(R0),SD		;GET NEXT SDB IN OUTPUT LIST
	BEQ	40$			;IF NO MORE
	TSTB	@#FSCCSR#		;DID XMIT DONE GO ON WHILE WE WERE PROCESSING
	BPL	7$			;NO - CONTINUE
	MOVB	#'!,@#FSCCSR#+2		;YES-"OUTPUT" A CHARACTER
	DECB	FSCCNT			;COUNT THE TICK
	INC	FSCTIC			;HELP BAUD RATE DETECTION
7$:	TSTB	SDTRC3#+1(SD)		;CHECK STATE (AND CLEAR CARRY)
	BGT	26$			;IF NEED MORE DELAY FOR STOP BITS
	BEQ	9$			;IF NEED START BIT
	ROLB	SDTRC3#(SD)		;POSITION MASK FOR NEXT BIT TO TEST
	BNE	14$			;CONTINUE WITH MIDDLE OF BYTE
	BCC	12$			;IS THIS RIGHTMOST BIT?
	CMPB	#-40,SDTRC3#+1(SD)	;NO-ARE WE BEING STOPPED?
	BGE	8$			;YES
	INC	SDTRIP#(SD)		;NO-ADVANCE POINTER
	TSTB	@SDTRIP#(SD)		;END OF STRING?
	BNE	10$			;NO
8$:	MOVB	#200,SDTRC3#(SD)	;MAKE SURE WE GET HERE AGAIN
	TSTB	SDTRC4#(SD)		;WAS THE LAST CHAR THE SAME AS A STOP BIT
	BEQ	16$			;NO - SEND FIRST STOP BIT
	MOV	SDTRCP#(SD),SDTRCP#(R0)	;YES-REMOVE THIS SDB FROM THE LIST
	CLR	SDTRCP#(SD)
	CLR	SDTRIP#(SD)
	BR	6$			;GO LOOK FOR MORE TO DO
9$:	TST	FSCINH			;HAVE WE STARTED ANOTHER CHAR THIS  TRIP
	BNE	4$			;YES - WAIT UNTIL NEXT BAUD
	INC	FSCINH			;INHIBIT FURTHER NEW CHARACTERS
	BR	22$

;HERE TO OUTPUT THE STOP BIT

10$:	MOVB	#24.,SDTRC3#+1(SD)	;SET COUNTER FOR 2 STOP BITS AND TWO ADDITIONAL CHARS
	BR	16$			;GO OUTPUT STOP BIT

12$:	MOVB	#1,SDTRC3#(SD)		;SET MASK BYTE

;HERE FOR NEXT BIT IN CHARACTER

14$:	BITB	SDTRC3#(SD),@SDTRIP#(SD);IS THE BIT SET?
	BEQ	20$			;NO
	TSTB	SDTRC4#(SD)		;WHAT WAS THE LAST BIT SENT
	BNE	26$			;SAME AS THIS ONE - NOTHING TO DO
16$:	INCB	SDTRC4#(SD)		;FLAG THIS CHAR WAS A 1
	MOV	#.LFEBK,R0		;SET UP FUNCTION TO STOP BREAK
	BR	24$

;HERE IF BIT IS 0

20$:	TST	SDTRC4#(SD)		;CHECK SIGN OF LAST BIT
	BEQ	26$			;ALREADY IN CORRECT STATE
22$:	CLRB	SDTRC4#(SD)		;SET FLAG TO INDICATE LAST BIT WAS 0
	MOV	#.LFSBK,R0		;SET UP FUNCTION TO START BREAK
24$:	PUSH	R2
	PUSH	R3
	PUSH	R4
	MOV	SDTRAD#(SD),R4		;GET ADB ADDRESS FOR THE SDB
	CALL	@ADFUNC#(R4)		;CALL FUNCTION ROUTINE
	POP	R4
	POP	R3
	POP	R2
26$:	DECB	SDTRC3#+1(SD)		;ADVANCE STATE
	BR	4$			;CONTINUE

;HERE AFTER DOING ALL OF THE OUTPUT STUFF IF NEEDED THIS INTERRUPT

40$:	POP	R0			;Restore registers
	POP	SD
42$:	TST	FSCOUT			;Do we still need the clock?
	BNE	44$			;Yes
	TST	FSCUSR			;Maybe
	BEQ	50$			;No
44$:	TSTB	@#FSCCSR#		;WAS XMIT DONE SATISFIED AT 7$
	BPL	49$			;YES - JUST RETURN
47$:	MOVB	#'!,@#FSCCSR#+2		;YES-"OUTPUT" A CHARACTER
	INC	FSCTIC			;BUMP THE TICK COUNT
49$:	RTI				;THATS ALL

;HERE IF SHOULD STOP THE FAST CLOCK NOW

50$:	CLR	@#FSCCSR#		;Clear interrupt enable
	RTI				;AND RETURN
	.PAGE
	.SBTTL	PURE DATA

;TABLE OF VALUES USED TO RESET 1ST LEVEL COUNTER

	PURE
; THE FOLLOWING BTYES CONTINE THE NUMBER OF 19,200 BAUD INTERRUPTS THAT ARE 
;EQUIVALENT TO 300 BAUD.  tHE REAL VALUE SHOULD BE 6.4, WHICH IS THE AVERAGE
;OF THESE VALUES.  tHE REAL VALUE IS DERIVED FROM THE FACT THAT THE RATE 
;19,200 IS 64 TIME 300, BUT SINCE WE ARE DEALING WITH CHARACTER INTERRUPTS
;FROM THE DL WE HAVE TO DIVIDE BY THE NUMBER OF BITS PER INTERRUPT WHICH IS
;10(1 START + 8 DATA + 1 STOP) BITS.

CNTTBL:	.BYTE	6,7,6,7,6




;DEFINE MACRO WHICH GENERATES THE PARITY BIT FOR A CHARACTER

	.LIST	MEB

	.MACRO	CHAR  CCC
CC=!CCC
$M=!1
$X=!0
	.REPT	7
.IF NE CC&$M
  $X=!$X+1
.ENDC
$M=!$M*2
	.ENDR
.IF NE $X&1
  CC=!CC!200
.ENDC
	.BYTE	CC
	.ENDM

;GENERATE THE BIT STRING FOR THE MESSAGES WITH EVEN PARITY

BAUDMS:	.BYTE	377,377,377,377,377,377,377 ;START OFF WITH 7 DELS
	CHAR	CR
	CHAR	LF
	.BYTE	377,377,377,377		;ALLOW FOR SLOW CARRIAGE RETURN
	.IRPC	C,<please type your terminal identifier>
.IF NB C
	CHAR	''C
.IFF
	CHAR	SPA
.ENDC
	.ENDM
BAUDME:	.BYTE	0,0

	.EVEN
	.PAGE
	.SBTTL	AUTO7  - IMPURE DATA

	IMPURE

FSCUSR::.WORD	0		;FAST CLOCK USER COUNT
FSCTIC::.WORD	0		;FAST CLOCK TICK COUNTER
FSCCNT:	.BYTE	0		;FAST CLOCK 4 TICK COUNTER
FSCCN2:	.BYTE	0
FSCHNG:	.WORD	0		;Hung node counter
FSCOUT:	.WORD	0		;FAST CLOCK OUTPUT SDB LIST HEAD POINTER
FSCINH:	.WORD	0		;FLAG TO INHIBIT STARTING TO MANY CHARS
	.END
    