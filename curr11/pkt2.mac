	.TITLE	PKT2  SEND PACKET ROUTINES
	.SBTTL	NEXILIS/JRG

	XLPAR				;DON'T LIST PARAMETER FILE

;THIS MODULE CONTAINS ROUTINES TO SEND PACKETS FROM ONE DEVICE TO ANOTHER

	CODE

;A PACKET IS DIVIDED INTO 2 AREAS.  THE FIRST AREA IS A FIXED
;  SIZE AND CONTAINS THE PACKET HEADER, THE OTHER AREA IS OF VARIABLE
;  SIZE AND CONTAINS DATA WHICH IS DEPENDENT ON THE PACKET TYPE.

;HEADER AREA: (LENGTH = 6 BYTES)
;  PKLINK/	ADDRESS OF NEXT PACKET IN A LINKED LIST (2 BYTES)
;  PKCNT /	SIZE OF DATA AREA IN BYTES (1 BYTE)
;  PKTYPE/	TYPE OF PACKET (1 BYTE)
;  PKSOC /	SOCKET NUMBER ( 1 BYTE)
;   PKPNT/	POINTER TO CURRENT DATA BYTE (1 BYTE OVERLAYING PKSOC)
;  PKSEQ /	SEQUENCE NUMBER ( 1 BYTE)

;DATA AREA: (LENGTH = PKCNT BYTES)

	.SBTTL	SNDPKT - SUBROUTINE TO SEND PACKET

;A PACKET WHICH HAS BEEN SENT IS NO LONGER AVAILABLE TO THE SOURCE.  THE NEXT
;  BYTE STORED WILL START A NEW PACKET.
;	C(R1) = ADDRESS OF PACKET
;	PACKET MUST BE ADDRESSABLE
;	CALL	SNDPKT

SNDPKT::CMP	R1,#PKTBGN#		;IS THIS A VALID PACKET?
	BLO	2$			;NO!
	TBBE	77,R1,4$		;YES-GO ON
2$:	RSTOP	BPA			;[BAD PACKET ADDRESS]

4$:	MOVB	PKTYPE(R1),R0		;GET PACKET TYPE
	MOVB	SDSTS1#(SD),R3		;GET STATE OF THIS DEVICE
.IF NE ..BUG
	CMPB	#PKCMAX,PKCNT(R1)	;IS THERE TOO MUCH DATA IN THIS PACKET?
	BHIS	6$			;NO, CONTINUE
	FSTOP	TMP			;[TOO MANY BYTES] IN PACKET
6$:	CMPB	#PKCMAX-10,PKCNT(R1)	;IS THERE ROOM FOR TRACE DATA
	BLT	8$			;NO, SKIP THIS STUFF
	MOV	(SP),76(R1)		;SAVE TRACE OF CALLERS ADDRESS
	MOV	(SD),74(R1)		;SAVE DESTINATION SDB
	MOVB	R0,73(R1)		;SAVE PACKET TYPE IN CASE OF CHANGE
	MOVB	R3,72(R1)		;SAVE DISPATCH FUNCTION
8$:	CMP	#MAXPKT,R0		;IS THIS A VALID PACKET TYPE?
	BHIS	10$			;YES
	FSTOP	BPT

10$:	CMPB	R3,#.SSRIP		;BIGGER THAN A BREAD BOX?
	BLOS	20$			;NO
	FSTOP	BST			;YES
.ENDC

20$:	ASL	R0			;TIMES 2 FOR WORD INDEXING
	PUSH	R4			;Save the DDB pointer
	CALL	@STADSP(R3)		;DISPATCH ON THE STATE
	POP	R4			;Restore the DDB pointer
	RETURN				;Leave for now
	.PAGE
;A few words are in order here about the socket states.  The socket state is
;  used when a packet is sent from a socket (SNDPKT is called) to determine
;  how it should be processed.  Each state value represents a resonably
;  identifiable condition relative to connections as follows:
;    .SSDIS	The socket is disconnected.  The socket is not linked to
;		another socket.  The only packet which should ever be sent
;		from a disconnected socket is a Connect packet (.PTCON).
;    .SSCTP	Connection to the socket is pending.  A Connect packet has
;		been sent to the socket but a Connect ACK or Connect NAK has
;		not been received yet.  The only packets which should be sent
;		from a socket in this state are Connect ACK, Connect NAK, or
;		possibly Kill.
;    .SSCFP	Connection from the socket is pending.  A connect packet has
;		been sent from the socket but a Connect ACK or Connect NAK has
;		not been received yet.  A socket in this state is always linked
;		to one in the .SSCTP state.  The only packet which should be
;		sent from a socket in this state is Kill.
;    .SSCON	This socket is fully connected.  The linked socket must have
;		the same state.
;    .SSDTP	This socket has received a Disconnect packet but has not yet
;		sent a Disconnect ACK packet.  The linked socket must be in
;		the .SSDFP state.
;    .SSDFP	Disconnect from socket is pending.  This socket has sent a
;		Disconnect packet but has not yet received a Disconnect ACK
;		packet.  The state of the linked socket must be .SSDTP
	.PAGE
;Socket state dispatch table

	PURE

STADSP:	.WORD	STADIS		;.SSDIS =  0 - Disconnected
	.WORD	STACTP		;.SSCTP =  2 - Connect to socket pending
	.WORD	STACFP		;.SSCFP =  4 - Connect from socket pending
	.WORD	STACON		;.SSCON =  6 - Connected
	.WORD	STADTP		;.SSDTP = 10 - Disconnect to socket pending
	.WORD	STADFP		;.SSDFP = 12 - Disconnect from socket pending
	.WORD	STADTP		;.SSKT1 = 14 - Kill to socket pending - 1
	.WORD	STADTP		;.SSKT2 = 16 - Kill to socket pending - 2
	.WORD	STAZAP		;.SSZTR = 20 - Zap to socket requested
	.WORD	JNKOWN		;.STZFR = 22 - Zap from socket requested
	.WORD	STARTP#		;.SSRTP = 24 - Reconnect to socket pending
	.WORD	STARFP#		;.SSRFP = 26 - Reconnect from socket pending
	.WORD	STARTW#		;.SSRTW = 30 - Reconnect to socket waiting
	.WORD	STARFW#		;.SSRFW = 32 - Reconnect from socket waiting
	.WORD	STARIP#		;.SSRIP = 34 - Reconnect in progress

	CODE
	.PAGE
;HERE FOR STATE = .SSDIS = 0 (DISCONNECTED)

STADIS:	JMP	@DSPDSC(R0)		;DISPATCH ON THE PACKET TYPE

;DISPATCH TABLE FOR STATE = .SSDIS = 0 (DISCONNECTED)

	PURE

DSPDSC:	.WORD	JNKOWN		;.PTDAT =  0 - DATA
	.WORD	CONNCT		;.PTCON =  1 - CONNECT REQUEST
	.WORD	JNKOWN		;.PTACK =  2 - CONNECT ACK
	.WORD	JNKOWN		;.PTNAK =  3 - CONNECT NAK
	.WORD	JNKOWN		;.PTFUN =  4 - FUNCTION
	.WORD	JNKOWN		;.PTINT =  5 - INTERRUPT FUNCTION
	.WORD	JNKOWN		;.PTEAT =  6 - EAT FUNCTION
	.WORD	JNKOWN		;.PTDIS =  7 - DISCONNECT
	.WORD	JNKOWN		;.PTKIL = 10 - KILL CONNECTION
	.WORD	JNKOWN		;.PTDAK = 11 - DISCONNECT ACK
	.WORD	JNKOWN		;.PTRCR = 12 - RECONNECT REQUEST
	.WORD	JNKOWN		;	     - ILLEGAL
MAXPKT==!<.-DSPDSC-2>/2

	CODE

;HERE FOR STATE = .SSCTP = 2 (CONNECTION TO SOCKET PENDING)

STACTP:	JMP	@DSPCTP(R0)		;DISPATCH ON THE PACKET TYPE

;DISPATCH TABLE FOR STATE = .SSCTP = 2 (CONNECTION TO SOCKET PENDING)

	PURE

DSPCTP:	.WORD	KILKIX		;.PTDAT =  0 - DATA
	.WORD	CONCOL		;.PTCON =  1 - CONNECT REQUEST
	.WORD	SNDACK		;.PTACK =  2 - CONNECT ACK
	.WORD	SNDNAK		;.PTNAK =  3 - CONNECT NAK
	.WORD	KILKIX		;.PTFUN =  4 - FUNCTION
	.WORD	KILKIX		;.PTINT =  5 - INTERRUPT FUNCTION
	.WORD	KILKIX		;.PTEAT =  6 - EAT FUNCTION
	.WORD	SNDNAK		;.PTDIS =  7 - DISCONNECT
	.WORD	SNDNAK		;.PTKIL = 10 - KILL CONNECTION
	.WORD	KILKIX		;.PTDAK = 11 - DISCONNECT ACK
	.WORD	KILKIX		;.PTRCR = 12 - RECONNECT REQUEST
	.WORD	KILKIX		;	     - ILLEGAL

	CODE
	.PAGE
;HERE FOR STATE = .SSCFP = 4 (CONNECTION FROM SOCKET PENDING)

STACFP:	JMP	@DSPCFP(R0)		;DISPATCH ON THE PACKET TYPE

;DISPATCH TABLE FOR STATE = .SSCFP = 3 (CONNECTION FROM SOCKET PENDING)

	PURE

DSPCFP:	.WORD	KILKIW		;.PTDAT =  0 - DATA
	.WORD	KILKIW		;.PTCON =  1 - CONNECT REQUEST
	.WORD	KILKIW		;.PTACK =  2 - CONNECT ACK
	.WORD	KILKIW		;.PTNAK =  3 - CONNECT NAK
	.WORD	KILKIW		;.PTFUN =  4 - FUNCTION
	.WORD	KILKIW		;.PTINT =  5 - INTERRUPT FUNCTION
	.WORD	KILKIW		;.PTEAT =  6 - EAT FUNCTION
	.WORD	SNDKIW		;.PTDIS =  7 - DISCONNECT
	.WORD	SNDKIW		;.PTKIL = 10 - KILL CONNECTION
	.WORD	KILKIW		;.PTDAK = 11 - DISCONNECT ACK
	.WORD	KILKIW		;.PTRCR = 12 - RECONNECT REQUEST
	.WORD	KILKIW		;	     - ILLEGAL

	CODE

;HERE FOR STATE = .SSCON = 6 (CONNECTED)

STACON:	JMP	@DSPCON(R0)		;DISPATCH ON THE PACKET TYPE

;DISPATCH TABLE FOR STATE = .SSCON = 6 (CONNECTED)

	PURE

DSPCON:	.WORD	SNDDTP		;.PTDAT =  0 - DATA
	.WORD	KILKIL		;.PTCON =  1 - CONNECT REQUEST
	.WORD	KILKIL		;.PTACK =  2 - CONNECT ACK
	.WORD	KILKIL		;.PTNAK =  3 - CONNECT NAK
	.WORD	SNDDAT		;.PTFUN =  4 - FUNCTION
	.WORD	SNDINT		;.PTINT =  5 - INTERRUPT FUNCTION
	.WORD	SNDEAT		;.PTEAT =  6 - EAT FUNCTION
	.WORD	SNDDIS		;.PTDIS =  7 - DISCONNECT
	.WORD	SNDKIL		;.PTKIL = 10 - KILL CONNECTION
	.WORD	KILKIL		;.PTDAK = 11 - DISCONNECT ACK
	.WORD	SNDRCR#		;.PTRCR = 12 - RECONNECT REQUEST
	.WORD	KILKIL		;	     - ILLEGAL

	CODE
	.PAGE
;HERE FOR STATE = .SSDTP = 10 (DISCONNECT TO SOCKET PENDING)

STADTP:	JMP	@DSPDTP(R0)		;DISPATCH ON THE PACKET TYPE

;DISPATCH TABLE FOR STATE = .SSDTP = 10 (DISCONNECT TO SOCKET EPNDING)

	PURE

DSPDTP:	.WORD	JNKOWN		;.PTDAT =  0 - DATA
	.WORD	JNKOWN		;.PTCON =  1 - CONNECT REQUEST
	.WORD	JNKOWN		;.PTACK =  2 - CONNECT ACK
	.WORD	JNKOWN		;.PTNAK =  3 - CONNECT NAK
	.WORD	JNKOWN		;.PTFUN =  4 - FUNCTION
	.WORD	JNKOWN		;.PTINT =  5 - INTERRUPT FUNCTION
	.WORD	JNKOWN		;.PTEAT =  6 - EAT FUNCTION
	.WORD	SNDDAK		;.PTDIS =  7 - DISCONNECT
	.WORD	SNDDAK		;.PTKIL = 10 - KILL CONNECTION
	.WORD	SNDDAK		;.PTDAK = 11 - DISCONNECT ACK
	.WORD	JNKOWN		;.PTRCR = 12 - RECONNECT REQUEST
	.WORD	JNKOWN		;	     - ILLEGAL

	CODE

;Here for state = .SSDFP = 12 (Disconnect from socket pending)

STADFP:	JMP	@DSPDFP(R0)		;Dispatch on the packet type

;Dispatch table for state = .SSDFP = 12 (Disconnect from socket pending)

	PURE

DSPDFP:	.WORD	KILKIQ		;.PTDAT =  0 - DATA
	.WORD	KILKIQ		;.PTCON =  1 - CONNECT REQUEST
	.WORD	KILKIQ		;.PTACK =  2 - CONNECT ACK
	.WORD	KILKIQ		;.PTNAK =  3 - CONNECT NAK
	.WORD	KILKIQ		;.PTFUN =  4 - FUNCTION
	.WORD	KILKIQ		;.PTINT =  5 - INTERRUPT FUNCTION
	.WORD	KILKIQ		;.PTEAT =  6 - EAT FUNCTION
	.WORD	SNDKIQ		;.PTDIS =  7 - DISCONNECT
	.WORD	SNDKIQ		;.PTKIL = 10 - KILL CONNECTION
	.WORD	KILKIQ		;.PTDAK = 11 - DISCONNECT ACK
	.WORD	KILKIQ		;.PTRCR = 12 - RECONNECT REQUEST
	.WORD	KILKIQ		;	     - ILLEGAL

	CODE
	.PAGE
	.SBTTL	ROUTINES FOR UNEXPECTED OR OUT-OF SEQUENCE PACKETS

;HERE FOR UNEXPECTED PACKET WHEN CONNECTION PENDING TO SOCKET

KILKIX::CALL	CLRCTP			;CLEAR THE CONNECT TO SOCKET PENDING
					;  STATE
	BR	KILKIL			;CONTINUE

;Here for unexpected packet when disconnect pending from socket

KILKIQ:	CALL	CLRDFP			;Clear the pending state
	BR	KILKIL			;Continue

;HERE FOR UNEXPECTED PACKET WHEN CONNECTION PENDING FROM SOCKET

KILKIW::CALL	CLRCFP			;CLEAR PENDING CONNECTION

;HERE FOR UNEXPECTED PACKET WHEN NOT DISCONNECTED - SEND KILL PACKETS IN
;  BOTH DIRECTIONS!

KILKIL::CMP	R1,SDPKCP#(SD)		;IS THE PACKET WE ARE GOING TO CHANGE TO
	BNE	1$			; A KILL THE CURRENT PACKET?
	CLR	SDPKCP#(SD)		;YES - KEEP CLRSDV FROM RETURNING IT
1$:	CALL	CLRSDV			;CLEAR DST LIST OF SRC
	CALL	CLRDDV			;AND CLEAR DST LIST OF DST
	CALL	DECOWN#			;FIX UP OUR PACKET COUNT
	MOV	#.ERISP,R0		;Reason = Illegal sequence of packets
	CALL	SETKIL#			;Setup the kill packet
	MOV	(SD),R2			;POINT TO DST
;	BNE	2$			;BE SURE!
;	RSTOP	NSL			;[NO SOCKET LINKED]
	BEQ	KILKI2			;DST WENT BYE-BYE SO JUST DO SRC

2$:	CLR	(SD)			;UNLINK
	CLR	(R2)
	MOVB	#.SSDTP,SDSTS1#(R2)	;Update DST socket state
	BIC	#$S1DPS,SDSTS1#(R2)
	CALL	SNDDA0			;SEND KILL PACKET TO DST
KILKI2::MOV	#.ERISP,R0		;Reason = Illegal sequence of packets
KILKI3::MAKPKT	.PLTRM#			;MAKE ANOTHER PACKET
	BCC	STAZA2			;GO ON IF GOT ONE
	MOVB	#.SSZTR,SDSTS1#(SD)	;Can't get a packet-indicate we have
					;  been zapped!
	MOV	R0,SDPKDH#(SD)		;Remember the reason
	RETURN				;Thats the best we can do!!

;Here for any packet from socket in the .SSZTR state - the only reason a
;  socket is placed in this state is that were out of packets when we wanted
;  to send a kill or disconnect to this socket.  Thus this socket is really
;  disconnected - it just does not know it yet!

STAZAP:	CALL	DECOWN#
	MOVB	SDPKDH#(SD),R0		;Get saved reason
	CLR	SDPKDH#(SD)
STAZA2:	CLRB	SDPCNT#(SD)		;Make sure his packet counts are right
	MOVB	#1,SDXCNT#(SD)
	MOVB	#.SSDTP,SDSTS1#(SD)	;Update socket state
	BIC	#$S1DPS,SDSTS1#(SD)	;Clear timer sync bit
	CALL	SETKIL#			;Change it into a Kill packet
	CJMP	SNDSRC			;Send it back to the SRC
	.PAGE
	.SBTTL	CONNCT - ROUTINE TO HANDLE A CONNECT PACKET

;THE CONNECT PACKET IS DIVIDED INTO 6 AREAS.  THE FIRST 3 AREAS ARE A FIXED
;  SIZE, THE LAST 3 ARE VARIABLE SIZE.

;PREFIX AREA: (LENGTH = 4 BYTES)
;  PKDATA+ 0/	VERSION NUMBER (ALWAYS 200 NOW)
;		100 IS ADDED TO THE VERSION NUMBER IF THIS PACKET WAS
;		  GENERATED BY A RECONNECT SEQUENCE
;  PKDATA+ 1/	SIZE OF DATA AREA (BYTES)
;  PKDATA+ 2/	SIZE OF DST EXTENSION AREA (BYTES)
;  PKDATA+ 3/	SIZE OF SRC EXTENSION AREA (BYTES)
;DST SPECIFICATION AREA: (LENGTH = 8 BYTES)
;  PKDATA+ 4/	DST DEVICE I.D.
;  PKDATA+ 5/	DST SOCKET NUMBER
;  PKDATA+ 6/	1ST CHARACTER OF DST NAME
;  PKDATA+ 7/	2ND CHARACTER OF DST NAME
;  PKDATA+10/	3RD CHARACTER OF DST NAME
;  PKDATA+11/	4TH CHARACTER OF DST NAME
;  PKDATA+12/	5TH CHARACTER OF DST NAME
;  PKDATA+13/	6TH CHARACTER OF DST NAME
;SRC SPECIFICATION AREA: (LENGTH = 8 BYTES)
;  PKDATA+14/	SRC DEVICE I.D.
;  PKDATA+15/	SRC SOCKET NUMBER
;  PKDATA+16/	1ST CHARACTER OF SRC NAME
;  PKDATA+17/	2ND CHARACTER OF SRC NAME
;  PKDATA+20/	3RD CHARACTER OF SRC NAME
;  PKDATA+21/	4TH CHARACTER OF SRC NAME
;  PKDATA+22/	5TH CHARACTER OF SRC NAME
;  PKDATA+23/	6TH CHARACTER OF SRC NAME
;DATA AREA: (VARIABLE LENGTH, MINIMUM = 11 BYTES)
;  PKDATA+24/	PRIV. LEVEL
;  PKDATA+25/	PRIV. CLASS
;  PKDATA+26/	LINK PRIORITY
;  PKDATA+27/	CONNECTION TYPE
;		200 = SUPERVISORY CONNECTION
;		100 = RECONNECT
;  PKDATA+30/	CONNECTION SUB-TYPE
;  PKDATA+31/	Maximum number of packets which may be buffered for
;		  this connection
;  PKDATA+32/	Not used
;  PKDATA+33/	SRC "Terminal type"
;  PKDATA+34/	SRC "Baud rate"
;  PKDATA+35/	Flag bits
;		For normal connections:
;		  200 = Report terminal parameters
;		  100 = Enable deferred echo mode
;		  040 = Login string available
;		  020 = Password already varified
;		  010 = Don't enable echoing
;		  004 = Don't hold input if output is active
;		  002 = Local copy terminal
;		  001 = Don't clear login mode
;		For supervisory connections:
;		  200 = Host is available for connections (answered)
;  PKDATA+36/	TERMINAL PROFILE PLUS 1 (0 IF SHOULD NOT SET PROFILE)
;  PKDATA+../	ADDITIONAL BYTES MAY BE ADDED HERE AS NEEDED
;DST EXTENSION AREA: (VARIABLE LENGTH, MINIMUM = 0 BYTES)
;  ........./	THIS AREA CONTAINS ADDITIONAL BYTES REQUIRED TO SPECIFY THE
;		  DST ADDRESS
;SRC EXTENSION AREA: (VARIABLE LENGTH, MINIMUM = 0 BYTES)
;  ........./	THIS AREA CONTAINS ADDITIONAL BYTES REQUIRED TO SPECIFY THE
;		  SRC ADDRESS

CONNCT:	CALL	CONNSB			;Try to connect
	  RETURN			;OK-just return for now
	MOVB	#1,SDXCNT#(SD)		;Failed immediately-fix up the count
	CJMP	SNDSRC			;And send NAK packet back to the SRC
	.PAGE
;Subroutine to connect - also called by PKT3 for a reconnect sequence
;	C(R1) = address of connect packet
;	C(SD) = address of SRC SDB
;	CALL	CONNSB
;	  return if everything worked
;	return if immediate failure occured
;	C(R1) = address of NAK packet

CONNSB::CLR	76(R1)			;JUST IN CASE
	CALL	SETINU			;MAKE SURE SOCKET IS "IN USE"
	MOV	SDDDB#(SD),R4		;Make sure R4 points to the SRC DDB
	TBBE	$D1LCK,DDSTS1#(R4),3$	; Go on if connections allowed
	MOV	#.ERLKL,R0		; Indicate error reason
	JMP	CONNF1			; Now fail

3$:	TBBE	$D0LNK,(R4),1$		;Is this connect packet from a link?
	CMPB	DDPRIV#(R4),PKDATA+24(R1);Yes-is the priviledge level too high?
	BHIS	1$			;OK-continue
	MOVB	DDPRIV#(R4),PKDATA+24(R1);Too high-reduce it
1$:	MOV	#PKDATA+6,R2		;GET ADDRESS OF FIRST CHARACTER OF DST
	ADD	R1,R2			;  NAME
	CALL	XXRD50#			;CONVERT FIRST PART TO RADIX 50
	PUSH	R0			;SAVE FIRST PART
	CALL	XXRD50#			;CONVERT SECOND PART
	POP	R2			;RESTORE FIRST PART
	TSTB	PKDATA+4(R1)		;IS THE DST A HOST?
	BNE	CONN14			;NO-GO ON

;HERE IF CONNECTION REQUEST IS DIRECTED TO A HOST

	MOV	#HSTN$X#-4,R3		;GET INDEX FOR HOST TABLE
	BMI	6$			;JUST TO BE VERY SAFE!!
2$:	CMP	HSTN$1#(R3),R2		;THIS ONE?
	BNE	4$			;NO
	CMP	HSTN$2#(R3),R0		;MAYBE
	BEQ	CONN13			;YES
4$:	SUB	#4,R3			;NO-DECREMENT INDEX
	BGE	2$			;CONTINUE IF MORE TO CHECK
6$:	TSTB	DFTHST#			;DO WE HAVE A DEFAULT HOST?
	BEQ	20$			;NO-FAIL NOW!
	TSTB	PKDATA+2(R1)		;YES-DO WE ALREADY HAVE A DST EXTENSION?
	BNE	20$			;YES-ANOTHER REASON TO FAIL
	MOVB	PKDATA+1(R1),R0		;NO-COPY DST TO DST EXTENSION
	ADD	#PKDATA+24,R0
	ADD	R1,R0
	MOV	#PKDATA+6,R2
	ADD	R1,R2
	MOV	#6,R3
10$:	MOVB	(R2),(R0)+
	BEQ	12$
	CLRB	(R2)+
	INCB	PKCNT(R1)
	INCB	PKDATA+2(R1)
	SOB	R3,10$
12$:	TSTB	PKDATA+2(R1)		;DO WE HAVE AN EXTENSION NOW?
	BEQ	20$			;NO-FAIL!
	MOV	#DFTHST#,R0		;YES-COPY DEFAULT TO DST
	MOV	#PKDATA+6,R2
	ADD	R1,R2
	MOV	#6,R3
14$:	MOVB	(R0)+,(R2)+
	BEQ	1$
	SOB	R3,14$
	BR	1$			;AND GO TRY THIS OVER AGAIN!

;HERE IF DO NOT KNOW ABOUT THE HOST HE WANTS

20$:	MOV	#.ERNSH,R0		;GET CONNECTION FAILURE CODE (NO SUCH
	BR	CONF5A			;  HOST)

;HERE WITH MATCH ON HOST NAME

CONN13:	ADD	#HSOF$X#,R3		;ADD IN HOST OFFSET FOR CONNECT TABLE
	BR	CONN17			;CONTINUE

;HERE IF CONNECTION REQUEST IS DIRECTED TO A DEVICE

CONN14:	MOV	R2,R3			;COPY FIRST HALF OF NODE NUMBER
	BIS	R0,R3			;ADD IN SECOND HALF
	BEQ	CONN18			;NULL - USE THIS NODE
	MOV	#NODN$X#-4,R3		;GET INDEX
	BMI	CONN15			;JUST TO BE VERY SAFE!!
2$:	CMP	NODN$1#(R3),R2		;THIS NODE?
	BNE	4$			;NO
	CMP	NODN$2#(R3),R0		;MAYBE
	BEQ	CONN17			;YES
4$:	SUB	#4,R3			;NO-DECREMENT INDEX
	BGE	2$			;CONTINUE IF MORE TO CHECK
CONN15:	MOV	#.ERNSN,R0		;GET ERROR CODE (NO SUCH NODE)
	BR	CONF5A			;GO SEND NAK BACK

;HERE WITH MATCH ON DST NODE NAME

CONN17:	MOVB	PTHPR$#(R3),R0		;GET DEVICE INDEX FOR DST
	BGT	CONN22			;IF HOST OR REMOTE DEVICE
	BEQ	CONN15			;If routing table is messed up!

;	DEVICE IS SUPPOSED TO BE ON THIS NODE

CONN18:	MOVB	PKDATA+4(R1),R2		;GET DEVICE I.D.
	CMP	#NIDMAX#,R2		;VALID I.D.?
	BLE	2$			;NO!
	MOVB	NIDDX#(R2),R0		;YES-GET DEVICE INDEX
	BGE	CONN22			;CONTINUE IF WE HAVE THIS DEVICE
2$:	MOV	#.ERNSD,R0		;FAIL (NO SUCH DEVICE)
	BR	CONF5A

;HERE WITH DEVICE INDEX FOR DEVICE IN R0

CONN22:	MOV	DXTBL#(R0),R0		;GET ADDRESS OF DDB
CONN23:	MOV	R3,76(R1)		;SAVE FOR RETRY
	TBBN	$D1DWN!$D1OFF!$D1DIS,DDSTS1#(R0),10$ ; Go on if link down
	TBBN	$D1UNV,DDSTS1#(R0),20$	; Go on if hardware unavailable
	TBBE	$D1LCK,DDSTS1#(R0),CONN24 ; Go on if connections allowed
	MOV	#.ERLKL,R0		; Indicate no connections now
	BR	CONF1A			; Go retry if we can

10$:	TBBE	$D1OFF,DDSTS1#(R0),20$	; Go on if down, not disabled
	MOV	#.ERLKO,R0		; Assume link disabled
	BR	CONF1A

20$:	TBBN	$D0HST,(R0),2$		;Is this a host?
	TBBN	$D0GTW,(R0),3$		;No-is this a gateway?
	MOV	#.ERLKD,R0		;No-error = Link down
	BR	CONF1A			;Go retry if we can

2$:	MOV	#.ERHSD,R0		;Error = Host down
	BR	CONF1A			;Go see if another host interface is up
;	BR	CONF5A			;Don't retry other wise supervisory
					;connections may wander into another gateway

3$:	MOV	#.ERGWD,R0		;Error = Gateway down
	BR	CONF1A			;Go see if the is another up gateway

;HERE IF DEVICE IS UP

CONN24:	TBBN	$D0LNK,(R0),CONN30	;Is this a link?
	CMPB	DDPRIV#(R0),PKDATA+24(R1);No-check priviledge level
	BLOS	4$			;Go on if OK
	MOV	#.ERPRV,R0		;Not enough priviledge-fail!
	BR	CONF1A			;See if he can make it over another route

;Here if the priviledge level in the connect pais high enough

4$:	CLR	R2			;Get socket number
	BISB	PKDATA+5(R1),R2
	BEQ	CONN32			;If for wild socket
	CMPB	DDSOC#(R0),R2		;VALID SOCKET NUMBER?
	BLO	CONN25			;NO
	ASL	R2			;YES-CALCULATE SOCKET INDEX
	ADD	DDSX#(R0),R2		;PLUS BASE OF SX TABLE FOR DEVICE
	MOV	-(R2),R2		;GET ADDRESS OF SDB
	TBBN	$S1AVL,SDSTS1#(R2),CONN26;IF SOCKET IS AVAILABLE
CONN25:	MOV	#.ERNSS,R0		;FAIL (NO SUCH SOCKET)
	BR	CONF5A

;HERE IF SOCKET IS AVAILABLE

CONN26:	MOVB	SDSTS1#(R2),R3		;GET STATE OF DST
	BNE	CONN27			;FAIL IF NOT DISCONNECTED
	TBBE	$S1INU,SDSTS1#(R2),CONN40;CONTINUE IF DEVICE NOT "IN USE"
CONN27:	MOV	#.ERSIU,R0		;FAIL (REQUESTED SOCKET IN USE)
CONF5A:	JMP	CONNF5

;HERE IF CONNECTING TO DEVICE OR HOST ON ANOTHER NODE

CONN30:	MOV	R3,76(R1)		;STORE PATH TABLE INDEX IN THE PACKET
	CMP	R0,SDDDB#(SD)		;Compare SRC and DST DDBs
	BEQ	CONF1A			;Try alternate path if going wrong way
					;Fall into wild socket routine

;HERE IF CONNECTING TO WILD SOCKET

CONN32:	TBBE	$D0WLD,(R0),CONN25	;Does this device like the wild socket
	PUSH	R4			;Yes-save registers we use
	PUSH	SD
	MOV	R0,R4			;Get address of DST DDB
	CALL	GRBSDB			;Get an SDB on the DST
	MOV	SD,R2			;We want R2 to point to the DST SDB
	POP	SD			;Restore SRC SDB
	POP	R4
	BCC	CONN40			;Go on if got an SDB
	TBBE	$D0LNK,(R0),CONN39	;None available-is this a link?
	MOV	#.ERLKF,R0		;Yes-get connect failure code (link
					;  full)
CONF1A:	JMP	CONNF1			;Go fail (allow retry)

;HERE IF NO SOCKETS ARE AVAILABLE ON A DEVICE OR HOST (NOT A LINK)

CONN39:	MOV	#.ERNSA,R0		;GET ERROR CODE
	JMP	CONNF5			;GO FAIL (NO RETRY)

;HERE WITH ADDRESS OF SDB FOR SOCKET TO CONNECT TO

CONN40:	BIS	#$S1INU,SDSTS1#(R2)	;MAKE SURE THE IN-USE BIT IS SET IN THE
					;  DST SDB
	PUSH	R4			;SAVE R4
	TBBN	$NSNOT,NODSTS#,2$	;GO ON IF NO TIME-OUT WANTED
	PUSH	R1			;SAVE PACKET ADDRESS
	PUSH	R2			;SAVE DST SDB ADDRESS
	PUSH	SD			;AND SRC SDB ADDRESS
	MOV	R2,SD			;POINT TO DST
	MOV	#JIFX20#,R0		;START HUNG CONNECT TIME-OUT
	MOV	#HNGCON,R1
	CALL	TIMREQ#
	POP	SD			;RESTORE SRC SDB ADDRESS
	POP	R2			;AND DST SDB ADDRESS
	POP	R1			;AND PACKET ADDRESS
	BCS	6$			;FAIL IF COULD NOT ENTER TIMER REQUEST
2$:	PUSH	R1			;SAVE CURRENT PACKET
	MAKPKT	.PLSTP#			;ALLOCATE ANOTHER PACKET
	MOV	R1,R4			;COPY ADDRESS OF NEW PACKET
	POP	R1			;RESTORE ADDRESS OF CONNECT PACKET
	BCC	CONN44			;GO ON IF GOT ONE
6$:	POP	R4			;RESTORE R4
	BIC	#^C<$S1AVL>,SDSTS1#(R2)	;FREE UP THE SOCKET WE JUST ALLOCATED
	MOV	#.ERBFF,R0		;GET CONECT FAILURE CODE (BUFFER SPACE
					;  FULL)
	BR	CONNF1			;GO FAIL

;HERE WITH EXTRA PACKET ALLOCATED FOR COPY OF CONNECT PACKET

CONN44:	MOV	#PKTWDS,R0		;PACKET SIZE
	MOV	R1,R3			;COPY ADDRSES OF PACKET FOR POINTER
	MOV	R4,SDPKDT#(R2)		;REMEMBER ADDRESS OF COPY
1$:	MOV	(R3)+,(R4)+		;COPY CONNECT PACKET
	SOB	R0,1$
	POP	R4			;RESTORE R4
	MOV	R2,(SD)			;LINK DST DEVICE TO THE SRC DEVICE
	MOV	SD,(R2)			;AND THE OTHER WAY TOO
	CLRB	SDPCNT#(R2)		;Clear the packet counts
	MOVB	#.SSCTP,SDSTS1#(R2)	;SET NEW STATE FOR DST
	MOVB	#.SSCFP,SDSTS1#(SD)	;SET NEW STATE FOR SRC
	BIC	#$S1HLD!$S1STP!$S1BC2,SDSTS1#(R2);AND CLEAR SOME BITS
	BIC	#$S1HLD!$S1STP!$S1BC2,SDSTS1#(SD)
	MOV	SDDDB#(R2),R0		;GET DST DDB ADDRESS
	INC	DDNCON#(R0)		;BUMP ITS COUNT OF CONNECTIONS
	TBBN	$D0TAX,(R0),10$		;Can an "aux" connection go this way?
	BICB	#020,PKDATA+35(R1)	;No!
10$:	MOV	SDDDB#(SD),R0		;DO THE SAME FOR THE SRC
	INC	DDNCON#(R0)
	TBBN	$D0FAX,(R0),11$		;Check for this side too
	BICB	#020,PKDATA+35(R1)
11$:	MOVB	PKDATA+31(R1),R3	;GET MAXIMUM PACKET COUNT
	CMP	#12,R3			;IS IT TOO BIG?
	BHI	12$			;NO
	MOV	#12,R3			;YES-REDUCE IT
12$:	CMP	#1,R3			;IS IT TOO SMALL?
	BLO	14$			;NO
	MOV	#1,R3			;YES-INCREASE IT
14$:	MOVB	R3,SDPMAX#(SD)		;STORE VALUE
	MOVB	R3,SDPMAX#(R2)
	MOVB	PKDATA+26(R1),R3	;GET LINK PRIORITY
	CMP	#2,R3			;VALID?
	BHIS	16$			;YES
	MOV	#2,R3			;NO-MAKE IT AS LOW AS WE CAN!
16$:	TBBE	$D0LVL,@SDDDB#(SD),20$	;DOES THIS DEVICE USE THE LEVEL?
	MOVB	R3,SDLKLV#(SD)		;YES-STORE LEVEL
	CLRB	SDACNT#(SD)		;CLEAR THE FLOW-CONTROL BYTES
	CLRB	SDFCNT#(SD)
20$:	TBBE	$D0LVL,@SDDDB#(R2),22$	;DOES THIS DEVICE USE THE LEVEL?
	MOVB	R3,SDLKLV#(R2)		;YES-STORE LEVEL
	CLRB	SDACNT#(R2)		;CLEAR THE FLOW-CONTROL BYTES
	CLRB	SDFCNT#(R2)
22$:	BIS	#$S1BC2,SDSTS1#(R2)	;INDICATE DIRECTION OF CONNECTION
	MOVB	PKDATA+4(R1),SDSDID#(SD);REMEMBER KINDS OF DEVICES
	MOVB	PKDATA+14(R1),SDSDID#(R2)
	MOV	R1,SDPKDH#(R2)		;SET DST HEAD POINTER
	JMP	SNDDA3			;AND GO SEND THE CONNECT PACKET

;HERE IF CANNOT MAKE CONNECTION FOR SOME REASON
;	C(R0) = CONNECTION FAILURE CODE

CONNF1:	MOV	76(R1),R3		;YES-GET PATH TABLE INDEX
	BEQ	CONNF5			;REALLY FAIL IF HAVE ALREADY DONE
					;  RETRY!
	BLT	10$			;WORKING ON SECONDARY
	MOVB	PTHSC$#(R3),R2		;YES-GET DEVICE INDEX FOR LINK FOR
					;  SECONDARY PATH
	BLE	CONNF5			;IF NO SECONDARY PATH DEFINED
	MOV	DXTBL#(R2),R0		;GET ADDRESS OF DDB
	NEG	R3			;GET MAKE R3 INTO FLAG FOR SECONDARY
	JMP	CONN23			;TRY AGAIN
10$:	NEG	R3			;MAKE USEABLE AS INDEX AGAIN
	MOVB	PTHTE$#(R3),R2		;YES-GET DEVICE INDEX FOR LINK FOR
					;  TERTIARY PATH
	BLE	CONNF5			;IF NO TERTIARY PATH DEFINED
	MOV	DXTBL#(R2),R0		;GET ADDRESS OF DDB
	CLR	R3			;ONLY RETRY ONCE!
	JMP	CONN23			;GO TRY THAT PATH!

;HERE IF CANNOT RETRY FOR ONE REASON OR ANOTHER

CONNF5:	PUSH	R0
	CALL	DECOWN#			;FIX UP THE PACKET COUNTS
	POP	R0
	TBBE	$D0CLN,@SDDDB#(SD),2$	;Want clean-up for this device?
	BIC	#^C<$S1AVL>,SDSTS1#(SD)	;Yes-do that
2$:	ADD	#2,(SP)			;Give skip return
	CJMP	SETNAK#			;Setup a NAK packet and return
	.PAGE
;HERE ON CONNECTION REQUEST COLLESION - GET HERE IF BOTH ENDS OF A LINK
;  ALLOCATE A SOCKET AT THE SAME TIME - IN THIS CASE, THE PRIMARY IGNORES
;  THE CONNECTION REQUEST, THE SECONDARY RETRIES THE PENDING CONNECTION, WHICH
;  WILL RESULT IN A DIFFERENT SOCKET BEING ALLOCATED IF IT IS A WILD REQUEST
;  OR IN A HARD FAILURE IF IT IS NOT A WILD REQUEST.  IT THEN PROCESSES THE
;  NEW REQUEST NORMALLY

CONCOL::MOV	SDDDB#(SD),R4		;GET DDB ADDRESS
	TBBE	$D0PRI,(R4),4$		;ARE WE PRIMARY?
2$:	JMP	JNKOWN			;YES-IGNORE THIS!

;HERE IF THIS NODE IS SECONDARY

4$:	PUSH	R1			;SAVE NEW CONNECT PACKET
	MAKPKT	.PLSTP#			;Get another packet
	BCC	6$			;Go on if got one
	POP	R1			;None available-restore Connect packet
	BR	2$			;  and go junk it and let both sides
					;  time out (this is about the best we
					;  can do if we can't get a packet!)

;Here with another packet

6$:	MOV	#.ERNSA,R0		;MAKE INTO NAK PACKET, REASON = NO
	CALL	SETNAK#			;  SOCKETS AVAILABLE
	CALL	SNDPKT			;SEND IT
	POP	R1			;RESTORE CONNECT PACKET
	JMP	SNDPKT			;AND GO PROCESS THE NEW CONNECTION
					;  REQUEST
	.PAGE
	.SBTTL	SNDACK - ROUTINE TO HANDLE CONNECT ACK PACKET

;HERE FOR CONNECT ACK WHEN A CONNECTION IS PENDING FROM THE DEVICE
;  (STATE = .SSCPF)

;FORMAT OF THE CONNECT ACK PACKET
;  PKDATA+ 0/	NUMBER OF SOCKET ALLOCATED
;  PKDATA+ 1/	FLAG BITS (OPTIONAL)
;		200 = REPORT TERMINAL PARAMETERS
;		100 = ENABLE DEFERED ECHO MODE
;		040 = LOGIN STRING REQUIRED
;		020 = NOT USED
;		010 = DON'T ENABLE ECHOING
;		004 = DON'T HOLD INPUT IF OUTPUT IS ACTIVE
;		002 = LOCAL COPY TERMINAL
;		001 = DON'T CLEAR LOGIN MODE
;  PKDATA+ 2/	TERMINAL PROFILE PLUS 1 (OPTIONAL, 0 OR MISSING IF SHOULD NOT
;		  SET PROFILE)

SNDACK:	CALL	CLRCTP			;CLEAR CONNECT TIMER AND GIVE UP
					;  SAVED CONNECT PACKET
	MOV	(SD),R2			;GET POINTER TO LINKED SDB
	MOVB	#.SSCON,SDSTS1#(SD)	;SET NEW STATE FOR SRC
	MOVB	#.SSCON,SDSTS1#(R2)	;AND FOR DST
	CJMP	SNDDA0			;SEND THE PACKET ON AND RETURN
	.PAGE
	.SBTTL	SNDNAK - ROUTINE TO HANDLE CONNECTION NAK PACKET

;HERE FOR CONNECTION NAK PACKET WHEN CONNECTION IS PENDING TO THE DEVICE
;  (STATE = .SSCTP)

SNDNAK:	MOV	(SD),R2			;GET LINKED SDB (SOURCE OF CONNECT)
;	BNE	2$			;FOR DEBUGGING
;	RSTOP	NSL			;[NO SOCKET LINKED]
	BEQ	SNDKL1			;DST WENT BYE-BYE SO JUST GIVE UP PACKET

	CALL	RTYNAK			;Retry this connection if we can
	  RETURN			;Retry worked-all finished here
	CLRB	SDSTS1#(R2)		;Connect failed-clear state of DST socket
	MOV	SDDDB#(R2),R0		;Get DST DDB
	DEC	DDNCON#(R0)		;Reduce connection
	BGE	6$
	CLR	DDNCON#(R0)
6$:	TBBE	$D0CLN,(R0),10$		;Does DST socket need clean-up?
	BIC	#^C<$S1AVL>,SDSTS1#(R2)	;Yes
10$:	TST	PKFCNT#			;Are there any packet available now?
	BEQ	SNDKLX			;No-this is somewhat of a problem here!
	CJMP	SNDDA0			;Yes-send the NAK packet and return

;Here if there are no free packets now

SNDKLX:	MOVB	#.SSZTR,SDSTS1#(R2)	;No-indicate Kill was zapped
	MOVB	PKDATA(R1),SDPKDH#(R2)	;Remember the reason
	CLRB	SDXCNT#(R2)
SNDKL1:	FREPKT				;Give up the packet
	RETURN				;And return


;Subroutine to do connect retry for a Connect NAK packet
;      (also called from PKT3)
;	C(R1) = address of Connect NAK packet
;	C(SD) = address of SDB which returned NAK
;	CALL	RTYNAK
;	  return if retry done
;	return if no retry possible

RTYNAK::CALL	DECOWN#			;Keep packet count right
4$:	MOVB	#.PTNAK,PKTYPE(R1)	;MAKE SURE THIS IS REALLY A NAK PACKET
	PUSH	R1			;SAVE ADDRESS OF PACKET
	PUSHB	PKDATA(R1)		;And save error reason
	MOV	#HNGCON,R1		;KILL CONNECT TIMER
	CALL	TIMKIL#
	MOV	SDPKDH#(SD),R1		;Is there a packet on the DST list?
	BEQ	10$			;No-go on
	CLR	SDPKDH#(SD)		;Yes-get rid of it (must be the
	FREPKT				;  connect packet - this can happen
					;  if we got here because of a kill)
10$:	MOV	(SD),R2			;GET LINKED SDB (SOURCE OF CONNECT)

	CLR	(SD)			;UNLINK THE SDB'S
	CLR	(R2)
	MOV	SDDDB(SD),R4		;Get address of SRC DDB
	DEC	DDNCON#(R4)		;Reduce the connection count
	BGE	20$
	CLR	DDNCON#(R4)
20$:	BIC	#^C<$S1AVL>,SDSTS1#(SD)	;GIVE UP THE SRC SOCKET
	MOV	SDPKDT#(SD),R1		;GET SAVED CONNECT PACKET
	BNE	30$			;MAKE SURE WE HAVE ONE!
	RSTOP	CNS			;[CONNECT PACKET NOT SAVED]

30$:	CMPB	#.ERTRY,(SP)+		;CAN WE RETRY THIS ERROR?
	BLT	40$			;NO
	TBBN	$D1DWN,DDSTS1#(R4),40$	;Don't bother to retry if down now
	MOV	76(R1),R3		;GET INDEX FOR PATH
	BEQ	40$			;IF ALREADY HAVE RETRIED
	BLT	32$			;HANDLE TERTIARY PATH
	MOVB	PTHSC$#(R3),R0		;GET DX FOR SECONDARY PATH
	BLE	40$			;IF NO SECONDARY PATH DEFINED
	NEG	R3			;POINT TO TERTIARY NODE FOR NEXT TRY
	BR	34$
32$:	NEG	R3			;MAKE R3 USABLE AGAIN
	MOVB	PTHTE$#(R3),R0
	BLE	40$			;IF NO TERTIARY PATH DEFINED
	CLR	R3			;CLEAR PATH INDEX
34$:	POP	R1			;RESTORE ADDRESS OF NAK PACKET
	FREPKT				;GIVE IT UP
	MOV	SDPKDT#(SD),R1		;GET ADDRESS OF CONNECT PACKET
	CLR	SDPKDT#(SD)		;CLEAR POINTER
	PUSH	SD			;SAVE OUR SDB ADDRESS
	PUSH	R2			;SAVE THE DESTINATION SDB ADDRESS
	MOV	R2,SD			;TURN THINGS AROUND!
	CALL	CONN22			;PROCESS LIKE LAST PART OF CONNECT
	 BR	 35$			 ;HANDLE SUCCESS RETURN
	POP	R2			;FAILURE RETURN - RESTORE DEST SDB
	POP	SD			;RESTORE SRC SDB
	BR	50$			;HANDLE FAILURE OF RETRY
35$:	POP	R2			;RESTORE DEST SDB
	POP	SD			;RESTORE SRC SDB
	RETURN

;Here if cannot retry

40$:	FREPKT				;GIVE UP THE SAVED CONNECT PACKET
	CLR	SDPKDT#(SD)		;MAKE SURE POINTER IS CLEAR
;	TST	(SP)+			;FIX UP THE STACK
	POP	R1			;RESTORE ADDRESS OF NAK PACKET
50$:	ADD	#2,(SP)			;Give skip return to indicate failure
;	MOV	SDDDB(SD),R4		;Get address of SRC DDB
;	DEC	DDNCON#(R4)		;Reduce the connection count
;	BGE	52$
;	CLR	DDNCON#(R4)
;52$:	BIC	#^C<$S1AVL>,SDSTS1#(SD)	;GIVE UP THE SRC SOCKET
RTN006:	RETURN
	.PAGE
	.SBTTL	HNGCON - ROUTINE TO HANDLE CONNECT TIME-OUT

;Here when have not received ACK or NAK within 2 minutes of sending a connect
;  packet - we generate a fake connect NAK packet and process it just as if
;  it had been received, then we put the socket which timed-out in the .SSZTR
;  state.  This will cause a Kill packet to be sent within a minute if nothing
;  is received.  We could have sent a kill directly from here, but that would
;  make the routine longer and this is really just about as good!  This routine
;  should really never be executed anyway!!

HNGCON:;	CALL	CLRCTP			;Clear saved connect packet
	CALL	CLRSDV			;Clear out the DST list
	MAKPKT	.PLOPT#			;Get a packet
	BCS	4$			;If can't get one now
	MOVB	#1,SDPCNT#(SD)		;Make sure packet count is right!
	MOV	#.ERTIM,R0		;Error = time-out
	CALL	SETNAK#			;Set up the packet
	CALL	SNDPKT			;Process just like a real NAK
	MOVB	#.SSZTR,SDSTS1#(SD)	;Set new socket state
	MOV	#.ERTIM,SDPKDH#(SD)	;Store error code
	MOV	SDDDB#(SD),R4		;Get DDB address
	DEC	DDNCON#(R4)		;Fix up the connect count
	RETURN				;Thats all

;Here if cannot get a packet now for the NAK

4$:	MOV	#JIFSEC#,R0		;Try again in 1 second
	MOV	#HNGCON,R1
	CJMP	TIMREQ#			;Should not fail since we got here
					;  because of a time-out so there must
					;  be a timer slot free!!!
	.PAGE
	.SBTTL	SNDKIQ - ROUTINE TO HANDLE KILL CONNECTION PACKET

;FORMAT OF THE KILL CONNECTION PACKET
;  PKDATA+ 0/	DISCONNECT REASON CODE

;Here for Kill or Disconnect packet when state = .SSDFP

SNDKIQ:	CALL	CLRDFP			;Clear the disconnect pending state
	BR	SNDKIL			;Continue

;Here for Kill packet when state = .SSCFP

SNDKIW:	CALL	CLRCFP			;CLEAN UP THE PENDING CONNECTION

;HERE FOR KILL CONNECTION PACKET WHEN DEVICE IS CONNECTED (STATE = .SSCON)

SNDKIL::MOVB	#.PTKIL,PKTYPE(R1)	;Make sure this is a Kill packet
	CMP	R1,SDPKCP#(SD)		;IS THE PACKET WE ARE GOING TO CHANGE TO
	BNE	1$			; A KILL THE CURRENT PACKET?
	CLR	SDPKCP#(SD)		;YES - KEEP CLRSDV FROM RETURNING IT
1$:	CALL	CLRDDV			;Clear DST list for DST
	CALL	CLRSDV			;Clear DST list for SRC
	CLRB	SDPCNT#(SD)		;Clear some packet counts
	MOV	(SD),R2			;Get DST SDB
	CLR	(SD)			;Unlink
	CMP	(R2),SD			;Still connected to us?
	BNE	SNDKL6			;Skip clearing the destination
	CLR	(R2)
	CLRB	SDPCNT#(R2)
	TST	PKFCNT#			;Any free packets left?
	BNE	6$			;Yes-go on
	CALL	SNDKLX			;No-zap it!
	BR	SNDKL5			;Continue

6$:	MOVB	#.SSKT1,SDSTS1#(R2)	;Update DST state
	MOVB	#1,SDXCNT#(R2)		;Set count
	CALL	SNDDA0			;Send the Kill packet
SNDKL5::MAKPKT	.PLSTP#			;Get another packet
	BCC	SNDKL7			;Go on if got one
	MOVB	#.SSZFR,SDSTS1#(SD)	;Indicate the Disconnect ACK was zapped
	CLRB	SDXCNT#(SD)
	RETURN				;Thats all

SNDKL6:	TST	PKFCNT#			;Any free packets left?
	BNE	SNDKL7			;Yes-go on
	CALL	SNDKLX			;No-zap it!
	BR	SNDKL8			;Continue

SNDKL7:	CLRB	SDSTS1#(SD)		;Clear SRC state
	MOVB	#1,SDXCNT#(SD)
	MOV	#.PTDAK*400,PKCNT(R1)	;Make into Disconnect ACK packet
	CALL	SNDSRC			;Send DAK to SRC
SNDKL8:	TBBE	$D0CLN,@SDDDB#(SD),22$	;Should we do clean-up here?
	BIC	#^C<$S1AVL>,SDSTS1#(SD)	;Yes
22$:	RETURN				;Finished
	.PAGE
	.SBTTL	SNDDSI - Routine to handle a disconnect packet

;FORMAT OF THE DISCONNECT PACKET
;  PKDATA+ 0/	Disconnect reason code (+200 if want special disconnect)

;Here for Disconnect packet when device is connected (STATE = .SSCON)

SNDDIS:	TST	PKFCNT#			;Do we have any packets?
	BEQ	SNDKIL			;No-change this into kill!
	TSTB	PKDATA(R1)		;Does he want a time-out?
	BPL	4$			;No-go on
	BICB	#200,PKDATA(R1)		;Yes-clear the flag
	PUSH	R1
	MOV	#JIF150#,R0		;Timeout = 2.5 min.
	MOV	#DISTMO,R1
	CALL	TIMREQ#			;Request disconnect timeout
	POP	R1
	BCS	SNDKIL			;Change this into a Kill if cannot do
					;  the timeout!
4$:	CMP	R1,SDPKCP#(SD)		;IS THE PACKET WE ARE GOING TO SEND
	BNE	1$			;  THE CURRENT PACKET?
	CLR	SDPKCP#(SD)		;YES - KEEP CLRSDV FROM RETURNING IT
1$:	CALL	CLRSDV			;Clear out DST list for SRC
	MOV	(SD),R2			;Get DSB SDB
	MOVB	#.SSDFP,SDSTS1#(SD)	;Update the socket states
	MOVB	#.SSDTP,SDSTS1#(R2)	;Update DST SDB state
	CBR	SNDDA0			;Send the packet and return

;Here when the Disconnect timer runs out

DISTMO:	MAKPKT	.PLOPT#			;Get a packet
	BCS	4$			;If none available now
	MOV	#.ERTIM,R0		;Reason = timeout
	CALL	SETKIL#			;Setup the Kill packet
	CJMP	SNDPKT			;Send it and return

;Here if cannot get a packet

4$:	MOV	#JIFSEC#,R0		;Try again in 1 second
	MOV	#DISTMO,R1
	CJMP	TIMREQ#
	.PAGE
	.SBTTL	SNDDAK - ROUTINE TO HANDLE  DISCONNECT ACK PACKET

;HERE FOR DISCONNECT ACK PACKET

SNDDAK:	MOV	(SD),R2			;Get linked SDB
	BNE	SNDDK4			;Go on if linked
	FREPKT				;Not linked-give up the packet
SNDDK2:	CLRB	SDSTS1#(SD)		;Update socket state
	CLRB	SDPCNT#(SD)		;Clear the packet counts
	CLRB	SDXCNT#(SD)
	MOV	SDDDB#(SD),R0		;Get address of DDB
	DEC	DDNCON#(R0)		;Reduce connection count
	BGE	2$
	CLR	DDNCON#(R0)
2$:	TBBE	$D0CLN,(R0),4$		;Does this device need clean-up here?
	BIC	#^C<$S1AVL>,SDSTS1#(SD)	;Yes-give up the sockeet
4$:	RETURN

;Here if linked to another SDB now

SNDDK4:	CLR	(SD)			;Unlink
	CLR	(R2)
	PUSH	SD			;Clean up DST socket
	MOV	R2,SD
	PUSH	R1			;Save packet address
	MOV	#DISTMO,R1		;Kill possible disconnect timer
	CALL	TIMKIL#
	POP	R1			;Restore R1
	MOV	SD,R2			;And restore R2
	CALL	SNDDK2
	POP	SD
	CALL	SNDDK2			;Clean up SRC socket
	MOV	#.PTDAK*400,PKCNT(R1)	;Make sure this is a Disconnect Ack
					;  packet
	MOVB	#1,SDXCNT#(R2)		;Fix up the packet count
	CBR	SNDDA0			;Send the packet and return
	.PAGE
	.SBTTL	SNDEAT - ROUTINE TO HANDLE AN EAT PACKET

;HERE FOR EAT PACKET PACKET - THIS PACKET DELETES ALL BUFFERED PACKETS FOR THIS
;  SOCKET OF THIS DEVICE

SNDEAT::CALL	CLRDDV			;CLEAR THE DST LIST
	BR	SNDDAT			;AND GO SEND IT!
	.PAGE
	.SBTTL	SNDINT - ROUTINE TO HANDLE AN INTERRUPT FUNCTION PACKET

;HERE FOR INTERRUPT FUNCTION PACKET

SNDINT::MOV	(SD),R2			;GET SDB OF DST
	MOV	#SDPKDH#,R3		;MAKE FAKE PREDICESSOR POINTER
	ADD	R2,R3
	MOV	(R3),R0			;GET FIRST PACKET ON THE LIST
	BEQ	SNDDAT			;GO ON IF NONE THERE
	TSTB	PKPNT(R0)		;HAVE ONE-IS IT BEING PROCESSED NOW?
	BEQ	4$			;NO
	TSTB	PKTYPE(R0)		;YES-IS IT A DATA PACKET
	BEQ	6$			;YES
2$:	MOV	R0,R3			;ADVANCE POINTER
	MOV	(R3),R0			;GET NEXT PACKET
	BEQ	SNDDAT			;IF NO MORE
4$:	CMPB	#.PTINT,PKTYPE(R0)	;IS NEXT PACKET AN INTERRUPT PACKET?
	BEQ	2$			;YES
6$:	CLRB	PKPNT(R1)		;NO-CLEAR CHARACTER POINTER
	MOV	R1,(R3)			;INSERT THIS PACKET INTO THE LIST
	MOV	R0,(R1)
	BNE	10$			;FINISHED IF NOT AT END
	MOV	R1,SDPKDT#(R2)		;END-UPDATE TAIL POINTER TOO
10$:	CMP	R1,SDPKDH#(R2)		;IS THIS PACKET AT THE HEAD NOW?
	BEQ	REQXR1			;YES-GO POKE THE DST
RTN007:	RETURN				;NO-THATS ALL
	.PAGE
	.SBTTL	SNDDTP - ROUTINE TO HANDLE DATA PACKETS

;HERE FOR DATA PACKET

SNDDTP::MOV	(SD),R2			;GET LINKED SDB
	TBBE	$S1JNK,SDSTS1#(R2),SNDDA0;GO ON IF NOT JUNKING PACKETS
	BR	JNKOWN			;JUNK THIS PACKET!
	.PAGE
	.SBTTL	PACKET TRANSFER ROUTINES

;HERE TO SEND PACKET BACK TO THE SRC
;	C(R1) = ADDRESS OF PACKET
;	C(SD) = ADDRESS OF SDB FOR SRC
;	CALL	SNDSRC

SNDSRC::MOV	SD,R2			;GET SDB ADDRESS IN RIGHT AC
	BR	SNDDA0			;CONTINUE

;HERE FOR PACKETS WHICH DO NOT REQUIRE SPECIAL PROCESSING AT THIS POINT
;  PACKET IS SENT TO DST
;	C(R1) = ADDRESS OF PACKET
;	C(SD) = ADDRESS OF SDB FOR SRC
;	CALL	SNDDAT

SNDDAT::MOV	(SD),R2			;GET SDB OF DST SOCKET
SNDDA0::MOV	SDPKDT#(R2),R3		;GET POINTER TO LAST PACKET FOR DST
	BNE	SNDDA4			;GO ON IF LIST NOT EMPTY
	MOV	R1,SDPKDT#(R2)		;LIST WAS EMPTY-PUT THIS PACKET ON THE
	MOV	R1,SDPKDH#(R2)		;  LIST
SNDDA3::CLR	(R1)			;MAKE SURE LINK-WORD IS CLEAR
	CLRB	PKPNT(R1)		;AND CLEAR CHARACTER POINTER
	TST	SDPKCP#(R2)		;Is there a "current" packet?
	BNE	RTN009			;Yes-don't bother poking him!
REQXR1::BISB	#$RQPOK,SDREQB#(R2)	;SET THE REQUST BIT
REQXR2::CMP	#-1,SDREQL#(R2)		;ALREADY IN REQUEST LIST?
	BNE	100$			;YES-FINISHED NOW
	MOV	REQSTT#,R0		;NO-GET LAST SDB IN LIST
	BEQ	40$			;IF LIST IS EMPTY
	MOV	R2,SDREQL#(R0)		;NOT EMPTY-LINK TO END OF LIST
	BR	60$			;CONTINUE

40$:	MOV	R2,REQSTH#		;EMTPY-SET HEAD POINTER
60$:	MOV	R2,REQSTT#		;IN ANY CASE, UPDATE TAIL POINTER
	CLR	SDREQL#(R2)		;CLEAR THE LINK WORD
100$:	RETURN				;THATS ALL

;HERE IF ALREADY HAVE SOME PACKETS IN LIST FOR DESTINATION

SNDDA4:	CLR	(R1)			;MAKE SURE LINK-WORD IS CLEAR
	CLRB	PKPNT(R1)		;;AND CLEAR CHARACTER POINTER
	TSTB	PKTYPE(R1)		;IS THIS A DATA PACKET?
	BNE	SNDDA5			;NO-GO ON
	TSTB	PKTYPE(R3)		;YES-IS LAST PACKET IN LIST A DATA
					;  PACKET?
	BNE	SNDDA5			;NO
	MOVB	PKPNT(R3),R0		;GET OFFSET OF START OF DATA IN PACKET
	DEC	R0
	BGE	20$
	CLR	R0
20$:	ADD	PKCNT(R3),R0
	NEG	R0
	ADD	#PKCMAX,R0		;NOW C(R0) = AMOUNT LEFT
	CMPB	PKCNT(R1),R0		;CAN WE MERGE THESE PACKETS?
	BHI	SNDDA5			;NO
	MOVB	PKCNT(R1),R0		;YES-CALCULATE NEW BYTE COUNT
.IF NE	..BUG
	BNE	26$			;GOOD VALUE
24$:	RSTOP	TMP			;A ZERO AMOUNT HERE IS AN ERROR
26$:
.ENDC
	CLR	-(SP)
	MOVB	PKCNT(R3),(SP)
	ADD	R0,PKCNT(R3)
	MOVB	PKPNT(R3),R2		;MAKE DST POINTER
	DEC	R2
	BGE	30$
	CLR	R2
30$:	ADD	(SP)+,R2
	ADD	#PKDATA,R2
	ADD	R2,R3
	MOV	R1,R2			;MAKE SRC POINTER
	ADD	#PKDATA,R2
40$:	MOVB	(R2)+,(R3)+		;COPY A CHARACTER
	SOB	R0,40$			;LOOP UNTIL DONE
JNKOWN::FREPKT				;GIVE UP THE PACKET
	CJMP	DECOWN#			;FIX UP THE PACKET COUNTS AND RETURN

;HERE IF CANNOT MERGE PACKETS

SNDDA5:	MOV	(R3),(R1)		;NOTE: THIS IS NEEDED TO HANDLE A 
					;  "BLOCKED" DST LIST - THIS LIST HAS
					;  BEEN LINKED INTO A RING WITH THE
					;  LAST PACKET POINTING TO THE FIRST.
					;  THIS WILL DO NO HARM FOR A NORMAL
					;  DST LIST SINCE R3 POINTS TO THE
					;  CURRENT TAIL WHOSE LINK-WORD WILL
					;  BE 0, WHICH IS THE RIGHT VALUE FOR
					;  THE LINK-WORD FOR THE NEW TAIL!
	MOV	R1,(R3)			;LINK THIS PACKET TO END OF LIST
	MOV	R1,SDPKDT#(R2)		;UPDATE TAIL POINTER
RTN009:	RETURN				;RETURN
	.PAGE
	.SBTTL	Once-a-minute routine

;This routine is executed once each minute to check for zapped sockets and for
;  sockets which have been in a Kill to socket pending state for more than a
;  minute.

	ONCSEC	SECPKT

SECPKT:	DEC	MINCNT			;Time for this yet?
	BGT	RTN012			;No
	MOV	#60.,MINCNT		;Yes-reset count
	MOV	#SXTBL#,R2		;Point to start of SX table
SECPK2:	MOV	(R2)+,SD		;Get next SDB
	BEQ	SECNXT
	MOVB	SDSTS1#(SD),R0		;Get socket state
	ADD	R0,PC			;Dispatch on the state
	BR	SECNXT		;.SSDIS =  0 - Disconnected
	BR	SECNXT		;.SSCTP =  2 - Connect to socket pending
	BR	SECNXT		;.SSCFP =  4 - Connect from socket pending
	BR	SECNXT		;.SSCON =  6 - Connected
	BR	SECNXT		;.SSDTP = 10 - Disconnect to socket pending
	BR	SECNXT		;.SSDFP = 12 - Disconnect from socket pending
	BR	SECKT1		;.SSKT1 = 14 - Kill to socket pending - 1
	BR	SECKT2		;.SSKT2 = 16 - Kill to socket pending - 2
	BR	SECZTR		;.SSZTR = 20 - Zap to socket requested
	BR	SECZFR		;.STZFR = 22 - Zap from socket requested
	BR	SECNXT		;.SSRTP = 24 - Reconnect to socket pending
	BR	SECNXT		;.SSRFP = 26 - Reconnect from socket pending
	BR	SECNXT		;.SSRTW = 30 - Reconnect to socket waiting
	BR	SECNXT		;.SSRFW = 32 - Reconnect from socket waiting
	BR	SECNXT		;.SSRIP = 34 - Reconnect in progress

;Here when state = .SSKT1 = 14  (Kill to socket pending - state 1)

SECKT1:	MOVB	#.SSKT2,SDSTS1#(SD)	;Advance the state
	BR	SECNXT			;Thats all!

;Here when state = .SSKT2 = 16  (Kill to socket pending - state 2)

SECKT2:	CALL	SNDDK2			;Clear output the socket just as if we
	CALL	FRESOC			;  had received a disconnect ack!
	BR	SECNXT			;Continue

;Here for state = .SSZTR = 20  (Zap to socket requested)

SECZTR:	MAKPKT	.PLOPT#			;Get a packet
	BCS	RTN012			;Opps!
	MOVB	SDPKDH#(SD),R0		;Get reason
	CALL	SETKIL#			;Setup a Kill packet
	BR	SECPK4			;Continue

;Here for state = .SSZFR = 22  (Zap from socket requested)

SECZFR:	MAKPKT	.PLOPT#			;Get a packet
	BCS	RTN012			;Oh well!
	MOV	#.PTDAK*400,PKCNT(R1)	;Make into Disconnect ACK packet
SECPK4:	CLRB	SDSTS1#(SD)		;Clear socket state
	PUSH	R2			;Save table pointer
	CALL	SNDSRC			;Send the packet
	POP	R2			;Restore pointer
	CMP	PKFCNT#,#6		;Do we have enough free packets to go
					;  on with this?
	BLO	RTN012			;No-forget it for now!

;Here to step to next SDB

SECNXT:	CMP	R2,#SXTOP#		;Finished?
	BLO	SECPK2			;No-continue
RTN012:	RETURN				;Yes
	.PAGE
	.SBTTL	SETINU - SUBROUTINE TO MARK DEVICE AS IN USE

;	C(SD) = ADDRESS OF SDB
;	CALL	SETINU

SETINU::BIS	#$S1INU,SDSTS1#(SD)	;INDICATE IN USE
	RETURN				;THATS ALL!!

	.SBTTL	FINDIS - Subroutine to finish processing Disconnect packet

;	C(R1) = address of Disconnect packet
;	CALL	FINDIS

FINDIS::MOV	#.PTDAK*400,PKCNT(R1)	;Change it to a Disconnect ACK packet
	CALL	PKTRTX#			;Send it back to the SRC
					;Fall into FRESOC

	.SBTTL	FRESOC - Free up a socket

;Subroutine to free up a socket
;	C(SD) = Address of SDB for socket
;	CALL	FRESOC

FRESOC::BIC	#^C<$S1AVL>,SDSTS1#(SD)	;Clear socket status + state
	RETURN				;Thats all!!
	.PAGE
	.SBTTL	GRBSDB - Grab a free SDB

;Subroutine to grab a free SDB for use
;	C(R4) = Address of DDB
;	CALL	GRBSDB
;	C:set = None available
;	C:clr = Normal return
;	C(SD) = Address of SDB
;  SDB is marked as "in use"
;  All other registers are preserved

GRBSDB::PUSH	R0			;FREE UP A REGISTER OR 2
	PUSH	R3
	CLR	R0			;GET NUMBER OF SOCKETS ON DEVICE
	BISB	DDSOC#(R4),R0
	MOV	DDSX#(R4),R3		;GET START OF SX TABLE FOR DEVICE
	TBBE	$D0PRI,(R4),4$		;IF WE ARE SECONDARY ON THIS LINK
2$:	MOV	(R3)+,SD		;GET NEXT SDB
	TBBN	$S1INU,SDSTS1#(SD),3$	;IS IT AVAILABLE?
	TBBN	$S1AVL,SDSTS1#(SD),12$	;MAYBE
3$:	SOB	R0,2$			;NO-MORE TO CHECK?
	BR	10$			;NO-FAIL

;HERE IF THIS NODE IS SECONDARY ON THIS LINK

4$:	ASL	R0			;FIND END OF SX TABLE FOR DEVICE
	ADD	R0,R3
	ASR	R0			;RESTORE COUNT
6$:	MOV	-(R3),SD		;GET NEXT SDB
	TBBN	$S1INU,SDSTS1#(SD),7$	;IS IT AVAILABLE?
	TBBN	$S1AVL,SDSTS1#(SD),12$	;MAYBE
7$:	SOB	R0,6$			;NO-MORE TO CHECK?
10$:	POP	R3			;RESTORE REGISTERS
	POP	R0
	SEC				;NO-INDICATE FAILURE
	RETURN				;AND RETURN

12$:	POP	R3			;RESTORE REGISTERS
	POP	R0
	CLC				;INDICATE GOOD RETURN
	BR	SETINU			;GO MARK SDB IN USE AND RETURN
	.PAGE
	.SBTTL	LOCAL SUBROUTINES

;SUBROUTINE TO CLEAR DST LIST FOR DST SOCKET
;	C(SD) = ADDRESS OF SDB FOR SRC SOCKET
;	CALL	CLRDDV

CLRDDV::PUSH	SD			;SAVE SRC SDB ADDRESS
	MOV	(SD),SD			;GET DST SDB
	BEQ	2$			;FORGET IT IF NONE!
	CMP	(SD),(SP)		;DOES THE OTHER SOCKET POINT AT US
	BNE	2$			;FORGET ABOUT THIS ONE
	CALL	CLRSDV			;CLEAR THE LIST
2$:	POP	SD			;RESTORE SRC SDB
	RETURN				;THATS ALL

;SUBROUTINE TO CLEAR DST LIST FOR SRC DEVICE
;	C(SD) = ADDRESS OF SDB FOR SOCKET
;	CALL	CLRSDV

CLRSDV::PUSH	R1			;Save R1
2$:	MOV	SDPKDH#(SD),R1		;Get head pointer
	BEQ	4$			;If nothing buffered
	CALL	JNKPKT#			;Get rid of the packet!
	BR	2$			;Continue

;Here after DST list is empty

4$:	TBBE	$D0TRM,@SDDDB#(SD),6$	;Go on if not terminal
	CALL	TRMSTP#			;Terminal-stop output now!
6$:	MOV	SDPKCP#(SD),R1		;Get current output packet
	BEQ	10$			;If none
	CALL	JNKCPK#			;Give it up
10$:	POP	R1			;Restore R1
	RETURN				;And return
	.PAGE
;SUBROUTIE TO GIVE UP SAVED CONNECT PACKET AND CLEAR CONNECT TIMER FOR
;  SOCKET IN .SSCTP STATE
;	CALL	CLRCTP

CLRCTP::PUSH	R1			;RESPECT R1
	MOV	#HNGCON,R1		;CLEAR CONNECT TIMER
	CALL	TIMKIL#
	MOV	SDPKDT#(SD),R1		;GET SAVED CONNECT PACKET
	BNE	4$			;MUST HAVE ONE HERE!
	RSTOP	CNS			;[CONNECT PACKET NOT SAVED]

4$:	FREPKT				;GIVE UP THE PACKET
	CLR	R1			;Assume no DST list (usual case)
	MOV	SDPKDH#(SD),R2		;Get first packet on DST list
	BEQ	10$			;If none
6$:	MOV	R2,R1			;Advance pointer
	MOV	(R1),R2			;Get next packet
	BNE	6$			;Go on if more
10$:	MOV	R1,SDPKDT#(SD)		;Have last one-update tail pointer
RTNPR1:	POP	R1			;RESTORE R1
	RETURN				;AND RETURN

;SUBROUTINE TO GIVE UP SAVED CONNECT PACKET AND CLEAR CONNECT TIMER FOR
;  SOCKET IN .SSCFP STATE
;	CALL	CLRCFP

CLRCFP::PUSH	SD			;SAVE SDB ADDRESS
	MOV	(SD),SD			;POINT TO DST SDB
	BNE	2$			;BE SAFE!
	RSTOP	NSL			;[NO SOCKET LINKED]

2$:	CALL	CLRCTP			;DO THE WORK
	POP	SD			;RESTORE SD
	RETURN				;And return

;Subroutine to kill disconnect timer when state = .SSDFP

CLRDFP:	PUSH	R1			;Respect R1
	MOV	#DISTMO,R1		;Kill disconnect timer
	CALL	TIMKIL#
	BR	RTNPR1			;Restore R1 and return
	.PAGE
	.SBTTL	Data

;Pure data

	PURE
	.EVEN

;Impure data

	IMPURE
	.EVEN

MINCNT:	.WORD	0		;Minute counter

	.END
    ?9