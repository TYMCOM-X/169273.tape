	.TITLE	LNK2	LINK SERVICE ROUTINES
	.SBTTL	LNK2   - NEXILIS/JRG

	XLPAR				;DON'T LIST PARAMETER FILE

	CODE

	.SBTTL	LKPOKE - SUBROUTINE TO START OUTPUT

;SUBROUTINE TO POKE A RESPONSE PROTOCOL LINK
;	C(R1) = ADDRESS OF PACKET
;	C(R4) = ADDRESS OF DDB
;	C(SD) = ADDRESS OF SDB
;	CALL	LKPOKE

RSPOKE::TBBN	$D1DWN,DDSTS1#(R4),LKPDWN;IS THIS LINK DOWN?
	CALL	CHKRSP			;SEE IF WE CAN SEND MORE NOW
	BMI	4$			;NOPE
	CALL	LKPOKE			;YEP-TRY TO DO IT
	BCC	4$			;IF FINISHED
	MOV	SDPKDH#(SD),R1		;CAN TAKE MORE-DO WE HAVE MORE?
	BNE	RSPOKE			;YES-DO THIS AGAIN
4$:	RETURN				;FINISHED

;SUBROUTINE TO SEE IF A RESPONSE LINK SHOULD OUTPUT A PACKET NOW
;	C(R1) = ADDRESS OF NEXT PACKET TO OUTPUT
;	C(SD) = ADDRESS OF SDB
;	CALL	CHKRSP
;	N:CLR = OUTPUT OK
;	N:SET = NO OUTPUT NOW

CHKRSP::TBBE	$S1HLD,SDSTS1#(SD),RTN001;HAS HE BEEN STOPPED?
CHKRS2:	MOVB	PKTYPE(R1),R0		;YES-GET PACKET TYPE
	TSTB	CHKTBL(R0)		;SEND THIS PACKET ANYWAY?
RTN001:	RETURN				;RETURN WITH Z SET CORRECTLY

;SUBROUTINE TO POKE A FLAG PROTOCOL LINK
;	C(R1) = ADDRESS OF PACKET
;	C(R4) = ADDRESS OF DDB
;	C(SD) = ADDRESS OF SDB
;	CALL	FGPOKE

FGPOKE::TBBN	$D1DWN,DDSTS1#(R4),LKPDWN;IS THIS LINK DOWN?
	CALL	CHKFLG			;CAN WE SEND MORE NOW?
	BMI	4$			;NO
	CALL	LKPOKE			;YES-TRY TO DO THAT
	BCC	4$			;IF MADE IT
	MOV	SDPKDH#(SD),R1		;HE WANTS MORE-DO WE HAVE MORE?
	BNE	FGPOKE			;YES-CONTINUE
4$:	RETURN				;NO-FINISHED

;SUBROUTINE TO SEE IF SHOULD DO OUTPUT ON A FLAG PROTOCOL LINK
;	C(R1) = ADDRESS OF NEXT PACKET TO SEND
;	C(SD) = ADDRESS OF SDB
;	CALL	CHKFLG
;	N:CLR = OUTPUT OK
;	N:SET = NO OUTPUT NOW

CHKFLG::CMPB	SDPMAX#(SD),SDACNT#(SD)	;HAS HE SENT ENOUGH NOW?
	BLE	CHKRS2			;YES-GO CHECK SOME MORE
	RETURN				;NO-RETURN WITH N CLR

;TABLE WHICH INDICATES ACTION TO TAKE BASED ON PACKET TYPE WHEN A LINK HAS
;  BEEN STOPPED - BYTE IS NEGATIVE IF PACKET CANNOT BE SENT ON A STOPPED LINK,
;  ZERO IF IT CAN BE SENT AT ANYTIME

	PURE
	.EVEN
CHKTBL:	.BYTE	200		;.PTDAT =  0 - DATA
	.BYTE	000		;.PTCON =  1 - CONNECT
	.BYTE	000		;.PTACK =  2 - CONNECT ACK
	.BYTE	000		;.PTNAK =  3 - CONNECT NAK
	.BYTE	200		;.PTFUN =  4 - FUNCTION
	.BYTE	000		;.PTINT =  5 - INTERRUPT
	.BYTE	000		;.PTEAT =  6 - EAT
	.BYTE	000		;.PTDIS =  7 - DISCONNECT
	.BYTE	000		;.PTKIL = 10 - KILL
	.BYTE	000		;.PTDAK = 11 - DISCONNECT ACK
	.BYTE	000		;.PTRVR = 12 - RECOVER
	.BYTE	000		;.PTRTY = 13 - RETRY
	.BYTE	200		;.PTPAC = 14 - PACKET ACK
	CODE
	.PAGE
;SUBROUTINE TO POKE A LINK - CALL HERE AFTER DETERMINING THAT THE LINK REALLY
;  WANTS TO DO OUTPUT NOW - THIS SUBROUTINE ONLY OUTPUTS A SINGLE PACKET
;  THE CALLING ROUTINE MUST LOOP ON A CARRY SET RETURN WHEN MORE PACKETS ARE
;  AVAILABLE FOR OUTPUT!!
;	C(R1) = ADDRESS OF PACKET TO OUTPUT
;	C(SD) = ADDRESS OF SDB
;	C(R4) = ADDRESS OF DDB
;	CALL	LKPOKE
;	C:SET = LINK WANTS MORE OUTPUT
;	C:CLR = LINK CANNOT DO ANY MORE OUTPUT NOW

LKPOKE::TBBN	$D1ACT,DDSTS1#(R4),LKPOK0;IS THIS LINK ACTIVE?
	CALL	REMOVE#			;NO-REMOVE PACKET FROOM DST LIST
3$:	CLR	(R1)
	PUSH	R1			;SAVE PACKET ADDRESS
	CALL	DECPCN#			;DECREMENT SENDER'S PACKET COUNT
	POP	R1			;RESTORE PACKET ADDRESS
	CJMP	@DDLKST#(R4)		;SEND THE PACKET AND RETURN

;HERE IF LINK IS ACTIVE NOW

LKPOK0::CMP	#-1,SDLKLK#(SD)		;IS THIS SDB IN A SEND LIST?
	BNE	RTNCC3			;YES-NOTHING MORE NEEDED HERE!
	MOVB	SDLKLV#(SD),R0		;NO-GET LINK PRIORITY LEVEL
	MOVB	LVLOFS(R0),R3		;GET OFFSET IN DDB FOR POINTERS
	ADD	R4,R3			;PLUS BASE OF DDB
	MOV	DDLKXT#(R3),R2		;GET LAST SDB
	BNE	LKPOK2			;IF LIST NOT EMPTY
	MOV	SD,(R3)			;EMPTY-UPDATE HEAD POINTER
	BISB	LVLBTS(R0),DDLKPS#(R4)	;SET STATE BIT FOR THIS LEVEL
	BR	LKPOK3			;CONTINUE

;HERE IF LIST NOT EMPTY

LKPOK2:	MOV	SD,SDLKLK#(R2)		;LINK TO LAST IN LIST
LKPOK3:	MOV	SD,DDLKXT#(R3)		;UPDATE TAIL POINTER
	CLR	SDLKLK#(SD)		;CLEAR FORWARD LINK
	BR	RTNCC3			;THATS ALL

;HERE IF LINK IS DOWN NOW

LKPDWN::MOV	#.PTKIL*400,PKCNT(R1)	;CHANGE PACKET TO KILL PACKET
	CLR	R0			;ERROR = LINK DOWN
	CALL	SETEPK#			;SETUP THE ERROR PACKET
	CJMP	PKTRTN#			;AND RETURN IT BACK TO THE SRC
	.PAGE
	.SBTTL	NXTPKT - SUBROUINE TO FETCH NEXT PACKET TO SEND

;THIS SUBROUTINE IS CALLED BY THE PROTOCOL ROUTINES TO GET THE NEXT PACKET
;  TO SEND ON A LINK.  SINCE IT IS CALLED AT MAIN PROGRAM LEVEL EVERY TIME
;  AROUND THE LOOP, ITS CHECK FOR ANY PACKETS TO SEND MUST BE VERY FAST!
;	C(R4) = ADDRESS OF DDB FOR LINK
;	CALL	NXTPKT
;	C:SET = NOTHING TO SEND
;	Z:SET = FLAG OR SUPERVISORY PACKET
;	Z:CLR = NORMAL PACKET
;	C(R1) = ADDRESS OF PACKET TO SEND
;	C(SD) = ADDRESS OF SDB FOR PACKET

;NOTE:  THERE ARE 3 LISTS OF SOCKETS WHICH HAVE PACKETS READY TO SEND, ONE
;	FOR EACH PRIORITY.  WITHIN THE DDB, THE POINTERS TO THESE LISTS
;	ARE STORED AS FOLLOWES FOR EACH LIST:
;		DDLKnH		;HEADER POINTER FOR LEVEL n
;		DDLKnT		;TAIL POINTER FOR LEVEL n

;PACKETS ARE SCHEDULED FOR TRANSMISSION OVER A LINK USING 3 SEND LISTS AND
;  IN 1 FLAG LIST.  ANY SOCKET MAY BE 1 SEND LIST AND IN THE FLAG LIST AT ANY
;  TIME.  WHICH SEND LIST IS USED IS DETERMINED BY THE SOCKET'S LINK
;  PRIORITY (STORED IN SDLKLV).  A SOCKET IS PLACED IN A SEND LIST WHENEVER
;  A PACKET IS LINKED TO ITS DST LIST (SEE SNDPKT) AND ITS FLAG COUNT (SDFCNT)
;  IS LESS THAN THE MAXIMUM VALUE (SDPMAX).  IT WILL ALSO BE PLACED IN A SEND
;  LIST WHEN FLAGS ARE RECEIVED FOR IT WHICH REDUCE ITS FLAG COUNT TO LESS THAN
;  HALF THE WARNING LEVEL IF IT WAS NOT ALREADY IN A SEND LIST.  WHENEVER A
;  PACKET IS SENT, THE SOCKET EITHER REMOVED FROM THE SEND LIST OR IS REQUEUED
;  TO THE END OF THE SEND LIST, DEPENDING ON THE VALUE OF THE SOCKET'S FLAG
;  COUNT.  IF IT GREATER THAN THE WARNING VALUE, THE SOCKET IS REMOVED FROM
;  THE SEND LIST.  IT WILL ALSO BE REMOVED, OF COURSE, IF ITS DST LIST IS
;  EMPTY.  THE RESULT OF THIS IS THAT WITHIN EACH PRIORITY LEVEL PACKETS ARE
;  SENT ON A ROUND-ROBIN BASIS.

NXTPKT::MOVB	DDLKPS#(R4),R0		;GET STATUS BITS
	ADD	R0,PC			;DISPATCH
	BR	NXTCFR			;00000 - NOTHING TO SEND - CHECK FOR
					;          FLAGS OR RESPONSES
	BR	NXTLV2			;00010 - LEVEL 2
	BR	NXTLV1			;00100 - LEVEL 1
	BR	NXTLV1			;00110 - LEVEL 1
	BR	NXTLV0			;01000 - LEVEL 0
	BR	NXTLV0			;01010 - LEVEL 0
	BR	NXTLV0			;01100 - LEVEL 0
	BR	NXTLV0			;01110 - LEVEL 0
	BR	NXTSUP			;10000 - SUPERVISOR
	BR	NXTSUP			;10010 - SUPERVISOR
	BR	NXTSUP			;10100 - SUPERVISOR
	BR	NXTSUP			;10110 - SUPERVISOR
	BR	NXTSUP			;11000 - SUPERVISOR
	BR	NXTSUP			;11010 - SUPERVISOR
	BR	NXTSUP			;11100 - SUPERVISOR
;	BR	NXTSUP			;11110 - SUPERVISOR

;HERE TO SEND SUPERVISORY PACKET

NXTSUP:	SETADR	DDLKSP#(R4),R1		;GET ADDRESS OF PACKET
	CLR	DDLKSP#(R4)		;CLEAR POINTER
	BICB	#20,DDLKPS#(R4)		;CLEAR STATUS BIT
NXTSU2:	MOV	DDWLD#(R4),SD		;USE WILD SDB FOR SUPERVISORY PACKETS!
NXTSU3:	SEZ				;INDICATE SUPERVISORY OR FLAG PACKET
	BR	RTNCC3			;RETURN WITH C CLEAR

;HERE FOR LEVEL 2 PACKET

NXTLV2:	MOV	#DDLK2H#,R3		;GET OFFSET IN DDB
	BR	NXTPK2			;CONTINUE

;HERE FOR LEVEL 1 PACKET

NXTLV1:	MOV	#DDLK1H#,R3		;GET OFFSET IN DDB
	BR	NXTPK2

;HERE FOR LEVEL 0 PACKET

NXTLV0:	MOV	#DDLK0H#,R3		;GET OFFSET IN DDB
NXTPK2:	DECB	DDLKFN#(R4)		;TIME TO CHECK FOR FLAGS?
	BGT	NXTPK3			;NO
	MOV	DDLKFH#(R4),SD		;YES-ANY FLAGS TO SEND NOW?
	BNE	NXTCF0			;YES-GO DO THAT
NXTPK3:	ADD	R4,R3			;GET ADDRESS OF POINTER
	MOV	(R3),SD			;GET ADDRESS OF SDB
	MOV	SDLKLK#(SD),(R3)	;REMOVE SDB FROM LIST
	BNE	2$			;GO ON IF NOT LAST IN LIST
	CLR	DDLKXT#(R3)		;LAST IN LIST-CLEAR TAIL POINTER
	BICB	LVLBTX(R0),DDLKPS#(R4)	;AND CLEAR STATUS BIT
2$:	MOV	#-1,SDLKLK#(SD)		;INDICATE SOCKET NOT IN SEND LIST
	MOV	SDPKDH#(SD),R1		;GET PACKET
	BEQ	NXTPKT			;FALSE ALARM-GO TRY AGAIN!
					;GOT ONE (NOTE THAT Z IS CLEAR NOW)
RTNCC3:	CLC				;RETURN WITH C CLEAR
RTN003:	RETURN

;HERE IF NO PACKETS TO SEND - CHECK FOR FLAGS OR RESPONSES TO SEND

NXTCFR::MOV	DDLKFH#(R4),SD		;GET FIRST SDB IN FLAG LIST
	BEQ	RTNCS3			;NOTHING TO DO IF NO FLAGS
NXTCF0:	MOVB	#VLLKFC#,DDLKFN#(R4)	;RESET COUNTER
	MAKPKT	.PLOPT#			;GET A PACKET
	BCC	NXTCF1			;GO ON IF GOT ONE
	CLR	R1			;NO SPACE-FORGET IT FOR NOW!
RTNCS3:	SEC				;RETURN WITH C SET
	RETURN

;HERE WITH PACKET

NXTCF1:	CALL	@DDLKFP#(R4)		;BUILD THE FLAG PACKET
	BCC	NXTSU3			;FINISHED IF HAVE SOMETHING TO SEND
	FREPKT				;FALSE ALARM-GIVE UP THE PACKET
	BR	NXTPKT			;AND GO TRY AGAIN (SHOULD NOT HAPPEN
					;  TWICE IN A ROW!!!)
	.PAGE
	.SBTTL	MOVPKT - SUBROUTINE TO RECEIVE PACKET FROM LINK

;THIS SUBROUTINE IS CALLED BY THE PROTOCOL ROUTINES TO TRANSFER A PACKET
;  INTO PACKET SPACE IN THIS NODE
;	C(R1) = ADDRESS OF PACKET
;	C(R4) = ADDRESS OF DDB FOR LINK
;	CALL	MOVPKT
;	C(SD) = SDB FOR SOCKET (0 IF SUPERVISORY PACKET)

MOVPKT::MOVB	PKSOC(R1),R2		;GET SOCKET NUMBER
	BEQ	MOVPK2			;YES-GO HANDLE THAT
	CMPB	DDSOC#(R4),R2		;VALID SOCKET NUMBER?
	BLO	SIIPK4			;NO-BUMP ERROR COUNT AND DISCARD
					;  PACKET
	ASL	R2			;GET SDB ADDRESS
	ADD	DDSX#(R4),R2
	MOV	-(R2),SD
MOVPK1:	INCB	SDPCNT#(SD)		;BUMP PACKET COUNT
	CJMP	SNDPKT#			;AND GO SEND THE PACKET

;ENTER HERE IF ALREADY HAVE SD SET UP

MOVPK0::TSTB	SDSOC(SD)		;WILD SOCKET?
	BNE	MOVPK1			;NO
					;YES-FALL INTO MOVPK2

;HERE TO PROCESS PACKET FROM THE WILD SOCKET

MOVPK2:	MOVB	PKTYPE(R1),R0		;GET PACKET TYPE
	CMP	#PKTMAX,R0		;VALID TYPE?
	BHI	MOVPK3			;YES
MOVPKE::INC	DDERIP#(R4)		;NO-COUNT ILLEGAL PACKET TYPE ERROR
	BR	SIIPK6			;GIVE UP PACKET AND RETURN

;HERE WITH VALID PACKET TYPE

MOVPK3:	ASL	R0			;TIMES 2
	JMP	@PKTDSP(R0)		;DISPATCH ON THE PACKET TYPE

;PACKET TYPE DISPATCH TABLE

PKTDSP:	.WORD	FLGPK0			;.SPFLG =  0 - FLAG PACKET
	.WORD	WLDPKT			;.SPCON =  1 - CONNECT PACKET
	.WORD	WLDPKT			;.SPACK =  2 - CONNECT ACK PACKET
	.WORD	WLDPKT			;.SPNAK =  3 - CONNECT NAK PACKET
	.WORD	SIIPKT			;.SPSII =  4 - SOCKET IS IDLE
	.WORD	SIAPKT			;.SPSIA =  5 - SOCKET IS ACTIVE
	.WORD	MOVPKE			;	   6 - ILLEGAL TYPE
	.WORD	WLDPKT			;	   7 - 
	.WORD	WLDPKT			;	  10 - 
PKTMAX=!<.-PKTDSP>/2

;HERE FOR PACKET FROM WILD SOCKET WHICH IS HANDLED SAME AS IF FROM NORMAL
;  SOCKET (CON, ACK, OR NAK)

WLDPKT:	MOV	DDWLD#(R4),SD		;GET ADDRESS OF SDB
	BR	MOVPK1			;CONTINUE

;HERE FOR "SOCKET IS IDLE" PACKET

SIIPKT:	CLR	R2			;GET SOCKET NUMBER
	BISB	PKDATA(R1),R2
	CMPB	DDSOC#(R4),R2		;VALID SOCKET?
	BLO	SIIPK4			;NO-IGNORE THIS!
	ASL	R2			;YES-GET SDB ADDRESS
	ADD	DDSX#(R4),R2
	MOV	-(R2),SD
	CMPB	#.SSCON,SDSTS1#(SD)	;IS THIS SOCKET IDLE?
	BNE	SIIPK6			;YES-GO ON
	MOVB	#.SPSIA,PKTYPE(R1)	;NO-CHANGE PACKET TO "SOCKET IS ACTIVE"
					;  PACKET
LNKSPR:	MOV	DDWLD#(R4),SD		;POINT TO WILD SDB
	TBBN	$D1ACT,DDSTS1#(R4),2$	;IS THE LINK ACTIVE NOW?
	CJMP	@DDLKST#(R4)		;NO-GO DO OUTPUT NOW

;HERE IF DEVICE IS ACTIVE NOW

2$:	TST	DDLKSP#(R4)		;ALREADY HAVE A SUPERVISORY PACKET
					;  WAITING?
	BNE	SIIPK6			;YES-FORGET ABOUT THIS ONE!!
	MOV	R1,DDLKSP#(R4)		;NO-STORE THIS ONE
	BISB	#20,DDLKPS#(R4)		;SET STATE BIT
	RETURN				;THATS ALL

;HERE FOR "SOCKET IS ACTIVE" PACKET

SIAPKT:	CLR	R2			;GET SOCKET NUMBER
	BISB	PKDATA(R1),R2
	CMPB	DDSOC#(R4),R2		;VALID SOCKET NUMBER?
	BLO	SIIPK4			;NO
	ASL	R2			;YES-GET SDB ADDRESS
	ADD	DDSX#(R4),R2
	MOV	-(R2),SD
	TSTB	SDSTS1#(SD)		;IS THIS SOCKET ACTIVE?
	BNE	SIIPK6			;YES
	MOVB	#.PTKIL,PKTYPE(R1)	;CHANGE TO "KILL" PACKET
	MOVB	#1,PKCNT(R1)		;CONTAINING 1 DATA BYTE
	MOVB	#.ERILD,PKDATA(R1)	;ERROR CODE = "INCONSISTANT LINK DATA"
	INCB	SDPCNT(SD)		;FIX UP THE PACKET COUNT
	CALL	SNDPKT#			;SEND THE PACKET
	BR	SIIPK7			;AND RETURN

;HERE IF ILLEGAL SOCKET

SIIPK4:	INC	DDERIS#(R4)		;BUMP ERROR COUNT

;HERE IF WE AGREE ABOUT THE STATE OF THIS SOCKET

SIIPK6:	FREPKT				;GIVE UP THE PACKET
SIIPK7:	MOV	DDWLD#(R4),SD		;INDICATE SUPERVISORY PACKET
	RETURN				;AND RETURN

;HERE FOR FLAG PACKET

FLGPK0:	JMP	@DDLKP0#(R4)		;GO TO CORRECT ROUTINE FOR THIS LINK
	.PAGE
	.SBTTL	LKCONT - SUBROUTINE TO CONTINUE OUTPUT ON SOCKET

;	C(SD) = ADDRESS OF SDB
;  R1,R2,R4 ARE PRESERVED

LKCONT::TST	SDPKDH#(SD)		;ANYTHING TO SEND NOW?
	BEQ	RTN004			;NO
	CMP	#-1,SDLKLK#(SD)		;YES-IS THIS SDB LINKED NOW?
	BNE	RTN004			;YES
	STRPNT	R1,-(SP)		;NO-SAVE ADDRESS OF FLAG PACKET
	PUSH	R2			;AND POINTERS FOR OUR CALLER
	PUSH	R4
	SETADR	SDPKDH#(SD),R1		;GET ADDRESS OF PACKET TO SEND
	CALL	LKPOKE			;START IT OUT
	POP	R4			;RESTORE POINTERS
	POP	R2
	SETADR	(SP)+,R1
RTN004:	RETURN				;FINISHED
	.PAGE
	.SBTTL	LNKDWN - SUBROUTINE TO MARK A LINK AS DOWN

;	C(R4) = ADDRESS OF DDB FOR LINK
;	CALL	LNKDWN

LNKDWN::TBBN	$D1DWN,DDSTS1#(R4),RTN013;FORGET IT IF ALREADY DOWN
	BIS	#$D1DWN,DDSTS1#(R4)	;MARK AS DOWN
	MOV	DDSX#(R4),R0		;GET POINTER TO SX TABLE
	CLR	R1			;GET NUMBER OF SOCKETS
	BISB	DDSOC#(R4),R1
DWNSC2:	MOV	(R0)+,SD		;GET NEXT SDB
DWNSC3:	TSTB	SDSTS1#(SD)		;DISCONNECTED?
	BEQ	DWNNXT			;YES
	PUSH	R4			;SAVE REGISTERS
	PUSH	R1
	PUSH	R0
	INCB	SDPCNT#(SD)		;KEEP PACKET COUNT RIGHT
	MOV	#.ERLKD,R0		;Error code = Link down
	TBBE	$D0HST,(R4),2$		;IS IT REALLY A HOST?
	MOV	#.ERHSD,R0		;YES-CORRECT THE ERROR CODE
2$:	TBBE	$D0GTW,(R4),3$		;Is it a gateway?
	MOV	#.ERGWD,R0		;Yes-get right error code
3$:	CALL	MAKKIL#			;Make a Kill packet
	CALL	SNDPKT#			;SEND IT (SINCE WE ARE DOWN, SNDPKT WILL
					;  NOT RETURN A DISCONNECT NAK PACKET)
	CALL	FRESOC#			;GIVE UP THE SOCKET (SNDPKT WILL HAVE
					;  ALREADY DONE THIS IF WE ARE A LINK
					;  BUT NOT IF WE ARE A HOST - IN ANY
					;  CASE, IT DOES NO HARM TO DO IT AGAIN
					;  HERE!)
	POP	R0			;RESTORE REGISTERS
	POP	R1
	POP	R4
DWNNXT:	SOB	R1,DWNSC2		;YES-CONTINUE IF MORE SOCKETS
	TSTB	DDNCON#(R4)		;FINISHED-STILL HAVE ANY CONNECTIONS?
	BEQ	DWNNX0			;NO-GO ON
	CLRB	DDNCON#(R4)		;YES-CLEAR OUT THE COUNT!!
	INC	DDERBC#(R4)		;COUNT THE ERROR
DWNNX0:	CLRB	DDLKPS#(R4)		;CLEAR STATUS BITS
DWNNX1:	MOV	DDLKSP#(R4),R1		;GET SUPERVISORY PACKET
	BEQ	DWNNX2			;IF NONE
	MOV	(R1),DDLKSP#(R4)	;UNLINK IT
	FREPKT				;GIVE IT UP
	BR	DWNNX1			;CONTINUE

;HERE WITH ALL WAITING SUPERVISORY PACKETS GIVEN UP

DWNNX2:	MOV	#DDLK0H#,R3		;GET LEVEL 0 POINTER
	CALL	DWNSS2			;CHECK FOR WAITING SDB
	MOV	#DDLK1H#,R3		;ALSO FOR LEVEL 1
	CALL	DWNSS2
	MOV	#DDLK2H#,R3		;AND FOR LEVEL 2
DWNSS2:	ADD	R4,R3			;ADD IN BASE OF DDB
DWNSS3:	MOV	(R3),SD			;GET SDB
	BEQ	RTN013			;IF NO MORE WAITING
	MOV	SDLKLK#(SD),(R3)	;REMOVE FROM LIST
	BNE	2$			;IF NOT LAST
	CLR	DDLKXT#(R3)		;LAST-CLEAR TAIL POINTER
2$:	MOV	#-1,SDLKLK#(SD)		;INDICATE NOT LINKED NOW
4$:	MOV	SDPKDH#(SD),R1		;ANY PACKETS WAITING?
	BEQ	DWNSS3			;NO
	CALL	REMOVE#			;Yes-remove packet from DST list
	FREPKT				;Give it up
	BR	4$			;Continue
	.PAGE
	.SBTTL	LNKUP  - SUBROUTINE TO MARK LINK AS UP

;	C(R4) = ADDRESS OF DDB FOR LINK
;	CALL	LNKUP
;	C:SET = CANNOT BRING LINK UP
;	C:CLR = NORMAL, LINK IS NOW UP

LNKUP::	TSTB	DDNCON#(R4)		;ANY CONNECTIONS LEFT
	BNE	RTNCS9			;YES-CAN'T BRING IT UP NOW!
	BIC	#$D1DWN,DDSTS1#(R4)	;NO-CLEAR THE DOWN FLAG BIT
	CLC				;INDICATE LINK IS UP NOW
RTN013:	RETURN				;THATS ALL!

RTNCS9:	SEC				;INDICATE LINK STILL DOWN!
	RETURN
	.PAGE
	.SBTTL	ONCE-A-SECOND ROUTINES

	ONCSEC	LNKSEC			;INSERT CALL INTO ONCE-A-SECOND LOOP

;THIS SUBROUTINE IS CALLED EACH SECOND AT MAIN PROGRAM LEVEL
;	CALL	LNKSEC

LNKSEC:	MOV	CURSX#,R0		;GET CURRENT SOCKET INDEX
	CMP	#MXLKSX#,R0		;AT TOP YET?
	BHIS	LNKSC1			;NO
	MOV	#MNLKSX#,R0		;YES-RESET INDEX
LNKSC1:	MOV	(R0)+,SD		;GET SDB
	BEQ	LNKSC1
	TSTB	SDSOC#(SD)		;WILD SOCKET?
	BEQ	LNKSC1			;YES-SKIP IT
	MOV	R0,CURSX#		;STORE INDEX
	MOV	SDDDB#(SD),R4		;GET ADDRESS OF DDB
	TBBE	$D0SII,(R4),LNKSC6	;IF DOES NOT USE "SOCKET IS IDLE" STUFF
	TBBN	$D1DWN,DDSTS1#(R4),LNKSC6;IF LINK IS DOWN
	TSTB	SDSTS1#(SD)		;IS THIS SOCKET DISCONNECTED?
	BNE	RTN009			;NO-GO ON
	TST	DDLKSP#(R4)		;YES-DO WE HAVE A SUPERVISORY PACKET
					;  WAITING NOW?
	BNE	LNKSC6			;YES-ASSUME LINK IS HUNG AND FORGET IT
					;  FOR THIS TIME AROUND!
	MAKPKT	.PLOPT#+5		;NO-GET A PACKET
	BCC	LNKSC2			;GO ON IF GOT ONE
	SUB	#2,CURSX#		;NO PACKETS AVAILABLE-WAIT UNTIL NEXT
					;  TIME!
	RETURN				;DON'T BOTHER WITH REST SINCE WE ARE
					;  OUT OF PACKETS!

;HERE WITH PACKET

LNKSC2:	CLR	PKSOC(R1)		;SOCKET = 0, SEQ = 0
	MOV	#<.SPSII*400>+1,PKCNT(R1);TYPE = .SPSII, COUNT = 1
	MOVB	SDSOC#(SD),PKDATA(R1)	;STORE SOCKET NUMBER IN PACKET
	CJMP	LNKSPR			;Send supervisory packet if we can
					;  and return

;HERE IF LINK IS DOWN OR DOES NOT USE "SOCKET IS IDLE" PROTOCOL

LNKSC6:	MOV	DDSX#(R4),R0		;GET SX ADDRESS FOR FIRST SOCKET
	MOVB	DDSOC#(R4),R1		;GET NUMBER OF SOCKETS
	INC	R1
	ASL	R1
	ADD	R1,R0			;CALCULATE FIRST SX ADDRESS FOR NEXT
					;  LINK
	MOV	R0,CURSX#		;SAVE FOR NEXT TIME
RTN009:	RETURN				;Finished
	.PAGE
	.SBTTL	LOCAL DATA

;PURE DATA

	PURE

;TABLE OF OFFSETS IN DDB FOR SDB LIST HEAD POINTER FOR EACH LEVEL - INDEX IS
;  LEVEL

LVLOFS:	.BYTE	DDLK0H#		;LEVEL 0
	.BYTE	DDLK1H		;LEVEL 1
	.BYTE	DDLK2H#		;LEVEL 2

;TABLE OF STATUS BITS FOR EACH LEVEL - INDEX IS LEVEL

LVLBTS:	.BYTE	10		;LEVEL 0
	.BYTE	04		;LEVEL 1
	.BYTE	02		;LEVEL 2

;TABLE OF HIGHEST PRIORITY BIT FOR EACH STATUS VALUE - INDEX IS BY STATUS VALUE

	.EVEN
LVLBTX:	.WORD	00		;0000
	.WORD	02		;0010
	.WORD	04		;0100
	.WORD	04		;0110
	.WORD	10		;1000
	.WORD	10		;1010
	.WORD	10		;1100
	.WORD	10		;1110

	.END
