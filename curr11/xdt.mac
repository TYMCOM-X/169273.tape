	.TITLE	.XDT.  - EXTENDED DEBUGGING TECHNIQUE
	.SBTTL	XDT1 - NEXILIS SYSTEMS, INC./JRG
	.SBTTL	XDT1 - XDT PARAMETERS
	.NLIST	TTM,BEX

;  ************************************************************************
;  *                                                                      *
;  *             N E X I L I S   S Y S T E M S,   I N C .                 *
;  *                        TUCSON, ARIZONA                               *
;  *                                                                      *
;  *     THIS  PROGRAM IS THE PROPERTY OF  NEXILIS SYSTEMS, INC.  AND     *
;  *     MAY NOT BE REPORDUCED IN ANY FORM WITHOUT WRITTEN PERMISSION     *
;  *                                                                      *
;  ************************************************************************

	.ENABL	LC
.IF NDF ..CTY
  ..CTY=!1
.ENDC
.IF NDF ..EIS
  ..EIS=!1
.ENDC
.IF NDF ..PSW
  ..PSW=!0
.ENDC
.IF NDF PATSIZ
  PATSIZ=!100
.ENDC
.IF NDF	..PIC
 ..PIC=!0
.ENDC
.IF NDF	..SAT
 ..SAT=!0
.ENDC

.IF EQ ..CTY
	.MCALL	..V2..
	..V2..
	.MCALL	.TTYIN,.TTYOUT
  PCHR=!RA			;PROMPT FOR USER MODE IS RIGHT ANGLE
.IFF
  PCHR=!'%			;PROMPT FOR EXEC MODE IS "%"
.ENDC

;DEFINE FLAGS FOR FLAG1

$DLSEQ=040000		;DOING INPUT DELETE SEQUENCE
$OPEN =020000		;LOCATION IS OPEN
$NOPCT=002000		;DON'T TYPE "%" BEFORE AC NUMBER
$TMPLC=001000		;TEMP. LOCATION IS OPEN
$USINP=000400		;USE LAST VALUE TYPED AS INPUT
$USSRC=000200		;USE SOURCE FIELD FOR ADDRESS
$NOADR=000100		;DON'T TYPE ADDRESS OF LOCATION
$ACTIV=000040		;XDT IS ACTIVE (USER STATE HAS BEEN SAVED)
$SMLIN=000020		;DON'T SKIP LINE BEFORE PROMPT IF NO LOCATION OPEN
$HVARG=000010		;ALREADY HAVE ARGUMENT VALUE IN WORD1
$NOOUP=000004		;NO OUTPUT FROM TYPINS

;DEFINE MODE FLAGS FOR FLAGT AND FLAGP

$G    =040000		;FORCE OUTPUT TO BE SIGNED
$U    =020000		;FORCE OUTPUT TO BE UNSIGNED
$UT   =010000		;TEMPORY UNSIGNED OUTPUT FLAG
$N    =004000		;NUMERIC OUTPUT (NO SYMBOLS, BUT TYPE OPCODES IF X)
$S    =002000		;SYMBOLIC OUTPUT
$A    =001000		;TYPE WORDS AS ASCII
$5    =000400		;TYPE WORDS AS 3 RADIX 50 CHARACTERS
$GT   =000200		;TEMP. SIGNED OUTPUT FLAG
$BYTE =000002		;BYTE IS OPEN
$INSTR=000001		;INSTRUCTION IS OPEN

;DEFINE BITS FOR FLAGW

$SRCOK=100000		;SOURCE IS VALID
$SRCAC=040000		;SOURCE IS AN AC
$DSTOK=020000		;DESTINATION IS VALID
$DSTAC=010000		;DESTINATION IS AN AC
$REGOK=004000		;REGISTER IS VALID
$VALOK=002000		;VALUE IS VALID

;DEFINE VARIOUS CONSTANTS

NUMBKP=20		;NUMBER OF BREAKPOINTS
ADSKSZ=5		;LENGTH OF ADDRESS STACK (NUMBER OF ADDRESSES)
BCKAMT=100		;AMOUNT TO BACKUP FOR BACKUP SYNC SCAN

;DEFINE STATUS BITS FOR ATOMS AND SYMBOL TABLE ENTRIES
;  THESE BITS MATCH (ALMOST) THE STATUS BITS IN THE GSD RLD BLOCK IN THE
;  OBJ FILE

$GLBL =000100		;GLOBAL SYMBOL
$RELOC=000040		;RELOCATABLE SYMBOL
$SUPR =000020		;SYMBOL IS SUPPRESSED
$PRGM =000010		;PROGRAM NAME
$XDEF =000004		;DEFINED OR REDEFINED BY $: COMMAND
$LABEL=000002		;LABEL
$AC   =000001		;VALUE IS AC NUMBER

;DEFINE LOCATIONS IN THE JOB DATA AREA

.JBXDT=14		;STARTING ADDRESS OF XDT
.JBSTA=40		;STARTING ADDRESS
.JBSTK=42		;INITIAL VALUE OF STACK POINTER
.JBSTS=44		;JOB STATUS WORD
  $JSLC =040000		;  ACCEPT LOWER CASE KEYBOARD INPUT
  $JSREN=020000		;  ALLOW RE-ENTER COMMAND
  $JSBAC=010000		;  BREAK ON CHARACTER MODE (ALSO TURNS OFF ECHOING!)
.JBUSR=46		;USR LOAD ADDRESS
.JBTOP=50		;HIGH MEMORY ADDRESS ASSIGNED
.JBERR=52		;EMT ERROR CODE
.JBMON=54		;ADDRESS OF BEGINNING OF RESIDENT MONITOR
.JBFIL=56		;TERMINAL FILL DATA

;DEFINE OFFSETS FOR THE SYMBOL TABLE ENTRIES

.SYNM1=0		;FIRST HALF OF NAME (RADIX 50)
.SYNM2=2		;SECOND HALF OF NAME (RADIX 50)
.SYBTS=4		;BITS
.SYVAL=6		;VALUE
.SYSIZ=10

;DEFINE VALUES FOR SPECIAL ASCII CHARACTERS

BS =10		;BACK SPACE
HT =11		;TAB
LF =12		;LINE FEED
CR =15		;RETURN
CU =25		;CONTROL-U
ESC=33		;ESCAPE
SPA=40		;SPACE
LA =74		;LEFT ANGLE BRACKET
RA =76		;RIGHT ANGLE BRACKET
ACT=140
VBR=174
TLD=176
RUB=177		;RUB-OUT

;DEFINE REGISTERS

	.DSABL	REG

R0=%0
R1=%1
R2=%2
R3=%3
R4=%4
R5=%5
SP=%6
PC=%7

;DEFINE COMMONLY USED MACROS

	.MACRO	PUSH	A
	MOV	A,-(SP)
	.ENDM

	.MACRO	POP	A
	MOV	(SP)+,A
	.ENDM

;DEFINE MACROS FOR BIT TESTING THE MOST EFFICIENT WAY

	.MACRO	TBBN	A,B,C
N=0
.IF EQ A-100000
	TST	B
	BMI	C
N=1
	.ENDC
.IF EQ A-200
	TSTB	B
	BMI	C
N=1
	.ENDC
.IF EQ N
	BIT	#A,B
	BNE	C
	.ENDC
	.ENDM

	.MACRO	TBBE	A,B,C
N=0
.IF EQ A-100000
	TST	B
	BPL	C
N=1
	.ENDC
.IF EQ A-200
	TSTB	B
	BPL	C
N=1
	.ENDC
.IF EQ N
	BIT	#A,B
	BEQ	C
	.ENDC
	.ENDM
	.PAGE
	.SBTTL	.XDT.  - MACROS AND SUBROUTINES TO SIMULATE EIS INSTRUCTIONS

;DEFINE MACROS FOR EIS INSTRUCTIONS FOR MACHINES WHICH DON'T HAVE THEM!!!!

.IF NE ..EIS			;IF WE DO HAVE EIS!

	.MACRO	ASHI  S,LOC
	ASH	#S,LOC
	.ENDM

.IFF				;IF NO EIS!!!!

	.MACRO	ASHI  S,LOC
.IF GT S
	.REPT	S
	ASL	LOC
	.ENDR
.ENDC
.IF LT S
	.REPT	-S
	ASR	LOC
	.ENDR
.ENDC
	.ENDM

	.MACRO	ASHC  S,LOC
	.ERROR	0;ILLEGAL INSTRUCTION -- ASHC !! NO EIS !!
	.ENDM

	.MACRO	SOB  R,LOC
	DEC	R
	BNE	LOC
	.ENDM

	.MACRO	MUL  LOC,R
	PUSH	LOC
	PUSH	R
	CALL	MULSUB
	POP	R
	POP	%<R!1>
	.ENDM

	.MACRO	DIV  LOC,R
	PUSH	LOC
	PUSH	R
	PUSH	%<R!1>
	CALL	DIVSUB
	POP	R
	POP	%<R!1>
	.ENDM

	.MACRO	XOR  SRC,R
	PUSH	SRC
	PUSH	R
	CALL	XORSUB
	POP	R
	.ENDM

.ENDC			;.IF XX ..EIS
	.PAGE
	.SBTTL	XDT1 - COMMAND DECODER

	.ASECT
.=.JBXDT
	.WORD	.XDT.			;PUT STARTING ADDRESS OF XDT IN THE
	.WORD	340			;  RIGHT PLACE

	.PSECT	.XDT.,I,RW,GBL,REL,OVR

XDTLOW=.				;LOWEST ADDRESS IN XDT

;XDT DISPATCH AND POINTER TABLE - THIS TABLE MUST BE FIRST THING IN THE .XDT.
;  PSECT!

.XDT.:	BR	XDT1			; 0 - INITIAL ENTRY
	BR	XDT1			; 2 - RE-ENTRY
SYMPNT:	.IF EQ	..CTY
	.BLKW	1			; 4 - POINTER TO SYMBOL TABLE
.IFF
	.WORD	USYMBL			; 4 - POINTER TO MICRO-NODE SYMBOL TABLE
.ENDC
BRKDSP:	.WORD	BRKPNT			; 6 - ENTRY FOR RSTS MONITOR

;END OF TABLE - START OF XDT CODE

XDT1:	TBBN	$ACTIV,FLAG1,2$		;GO ON IF XDT ALREADY ACTIVE
	PUSH	#340			;NO INTERRUPTS NOW
	CALL	SETPSW
.IF EQ ..CTY				;IF USER MODE
	CLR	-(SP)			;INITIALIZE PSW TO 0
.IFF					;IF EXEC MODE
	MOV	#340,-(SP)		;INITIALIZE PSW TO 340
.ENDC
	CLR	-(SP)			;INITIALIZE PC TO 0 ALWAYS
	CALL	USRSAV			;SAVE STATE
.IF EQ	..PIC
	MOV	#BRKENT,R0
.IFF
	MOV	#BRKENT-1$,R0		;SETUP ENTRY POINT
	ADD	PC,R0
.ENDC
1$:	TST	#<GO#-1000>		;CHECK FOR MXV VERSION
	BEQ	15$			;NO -NORMAL VERSION
	MOV	#137,@#20014		;MXV - PUT IN ABSOLUTE JUMP
	MOV	R0,@#20016		; PUT IN ADDRESS
	BR	18$
15$:	MOV	R0,@#14			;SAVE IT @ 14
	MOV	#340,@#16		;AND SAVE A PSW
18$:	CALL	BPTSET			;SETUP BREAKPOINTS
2$:	MOV	#$U,FLAGP		;CLEAR FLAGS
	BIC	#^C$ACTIV,FLAG1		;CLEAR ALL BUT ACTIVE FLAG
	MOV	#10,RADIXP		;DEFAULT RADIX IS 8
	CLR	WORDC			;CLEAR CURRENT ADDRESS
	MOV	#2,SIZEC		;SIZE = 2 BYTES
	MOV	#IDMESS-MSGBAS,R0	;TELL HIM WHO WE ARE
	JSR	PC,OUTSTR
.IF EQ	..PIC
	JMP	READYC
	CODE				;PUT THE REST OF THIS STUFF IN THE PROTECTED AREA
.ENDC

;HERE TO GET NEW COMMAND

READYC:	BIC	#$OPEN+$TMPLC+$USSRC,FLAG1;NO LOCATION OPEN NOW
READY:	BIC	#$UT+$GT,FLAGT		;CLEAR TEMPORY UNSIGNED OUTPUT FLAG
	BIC	#$HVARG,FLAG1		;DON'T HAVE ARGUMENT IN WORD1
	TBBN	$OPEN,FLAG1,READ2	;CONTINUE IF LOCATION IS OPEN
	MOV	FLAGP,FLAGT		;OTHERWISE RESET TEMP. MODE
	MOV	RADIXP,RADIXT
	TBBN	$SMLIN,FLAG1,2$		;WANT TO SKIP LINE?
	JSR	PC,CRLF			;YES-START NEW LINE
2$:	BIC	#$SMLIN,FLAG1		;CLEAR FLAG
	BR	READ3

READ2:	MOV	#PCHR,R0		;PROMPT HIM
	JSR	PC,PUTCCC
READ3:	MOV	#PCHR,R0
	JSR	PC,PUTCCC
READ4:	JSR	PC,GETINP		;GET INPUT
.IF EQ	..PIC
	ADD	#ACTDSP,R2
	JMP	@(R2)
ACTBAS=!0
.IFF
	ADD	#<ACTDSP-2$>,R2		;DISPATCH ON THE ACTION CHARACTER
	ADD	PC,R2
2$:	MOV	(R2),R2			;GET DISPATCH
	ADD	PC,R2			;FIX IT UP
ACTBAS:	JMP	(R2)			;GO TO ROUTINE
.ENDC
	.PAGE
;HERE FOR "/" - EXAMINE LOCATION AS INSTRUCTION

SLASH:	MOV	FLAGT,R0		;SAVE CURRENT FLAGS
	BIC	#$BYTE,FLAGT		;INDICATE NOT BYTE
	BIS	#$INSTR,FLAGT		;INDICATE INSTRUCTION
	BR	EXMINE			;CONTINUE

;HERE FOR "[" - EXAMINE LOCATION AS DATA

OPNNUM:	MOV	FLAGT,R0		;SAVE CURRENT FLAGS
	BIC	#$BYTE+$INSTR,FLAGT	;INDICATE WE HAVE A WORD OPEN
	BR	EXMINE			;CONTINUE

;HERE ON "\" - EXAMINE BYTE AS DATA

BCKSLH:	MOV	FLAGT,R0		;SAVE CURRENT FLAGS
	BIS	#$BYTE,FLAGT		;INDICATE ITEM IS A BYTE
	BIC	#$INSTR,FLAGT		;AND NOT AN INSTRUCTION
EXMINE:	TBBN	$TMPLC,FLAG1,EXMIN1	;GO ON IF TEMP. LOCATION NOW
	MOV	R0,FLGTT		;SAVE FLAGS
	MOV	SIZEC,SIZET		;AND ITEM SIZE
EXMIN1:	JSR	PC,ITEM			;GET INPUT
	BCS	READYC			;IF ERROR
	TBBN	$HVARG,FLAG1,EXMIN2	;IF ARGUMENT FOLLOWED BY $X
	TBBN	$USINP,FLAG1,EXMIN3
	TSTB	BUFFER			;OR IF VALUE TYPED
	BGT	EXMIN3
	JSR	PC,GETADR		;OTHERWISE USE CONTENTS AS ADDRESS
	BCS	READY			;IF ERROR
	MOV	R0,ADDRES
	MOV	R1,BITSA
	BIS	#$TMPLC,FLAG1		;INDICATE TEMP LOCATION OPEN
	BR	RETYP3

;HERE IF ARGUMENT TYPED FOLLOWED BY MODE SPECIFIER

EXMIN2:	TSTB	BUFFER			;ANYTHING AFTER THE MODE?
	BGT	SYNER0			;YES-ERROR

;HERE IF WE SHOULD USE THE VALUE HE TYPED

EXMIN3:	CLR	ADRSTP			;RESET ADDRESS STACK POINTER
	CMP	#2,SIZEX		;SINGLE WORD VALUE?
	BGE	EXMIN6			;YES-OK
	MOV	#NTSGMS-MSGBAS,R0	;MORE THAN ONE WORD-COMPLAIN
	JSR	PC,OUTSTR
READC4:	BR	READYC

EXMIN6:	MOV	WORD1,ADDRES		;STORE ADDRESS
	MOV	WORD1,WORDC
	MOV	BITS1,BITSA
	MOV	BITS1,BITSC
	MOV	FLAGT,FLAGQ		;SAVE BITS
	BIC	#$USINP,FLAG1
	BR	RETYP3			;CONTINUE

;HERE FOR ":" - RETYPE CURRENT VALUE AS SIGNED NUMBER

COLON:	BIS	#$GT,FLAGT		;SET FLAG
	BR	RETYPE			;CONTINUE

;HERE FOR "=" - RETYPE CURRENT VALUE AS UNSIGNED NUMBER

EQUALS:	BIS	#$UT,FLAGT		;INDICATE TEMPORARY UNSIGNED OUTPUT
					;FALL INTO RETYPE ROUTINE

;HERE FOR ";" - RETYPE CURRENT VALUE

RETYPE:	JSR	PC,ITEM			;GET VALUE OF INPUT
	BCS	READC4			;IF ERROR
	TBBN	$HVARG,FLAG1,RETYP1	;IF ARGUMENT FOLLOWED BY $X
	TBBN	$USINP,FLAG1,RETYP2	;GO ON IF HAVE HAD INPUT
	TSTB	BUFFER			;HAVE INPUT THIS TIME?
	BGT	RETYP2			;YES
	BIT	#$OPEN,FLAG1		;NO-"RE"OPEN LOCATION
	BR	RETYP3			;AND GO TYPE ITS CONTENTS

;HERE IF ARGUMENT TYPED FOLLOWED BY MODE SPECIFIER

RETYP1:	TSTB	BUFFER			;ANYTHING AFTER THE MODE?
	BLE	RETYP2			;NO-GO ON
SYNER0:	JMP	SYNERR			;YES-ERROR

;HERE TO DISPLAY PREVIOUS TYPE-IN

RETYP2:	BIS	#$USINP,FLAG1		;REMEMBER WE HAVE INPUT
	MOV	SIZEX,SIZEC		;GET SIZE
.IF EQ	..PIC
	MOV	#WORD1,R1
.IFF
	MOV	#<WORD1-2$>,R1		;GET ADDRESS OF OUR INPUT
	ADD	PC,R1
.ENDC
2$:	MOV	R1,ADDRES
	CLR	BITSA
RETYP3:	BIS	#$NOADR,FLAG1		;INDICATE NOT TO TYPE ADDRESS
	BR	OPNNX3			;CONTINUE

;HERE FOR "^" - BACKUP ONE ITEM
;  THIS OPERATION IS SIMPLE WHEN EITHER A WORD OR A BYTE IS OPEN.  WHEN AN
;  INSTRUCTION IS OPEN, HOWEVER, IT IS NOT SIMPLE.  IN FACT, IT IS NOT
;  POSSIBLE, IN GENERAL TO FIND THE PREVIOUS INSTRUCTION SINCE WE CANNOT
;  DETERMINE ITS LENGTH UNTIL WE KNOW WHERE IT STARTS, BUT WE DO NOT KNOW
;  WHERE IT STARTS UNTIL WE HAVE DETERMINED ITS LENGTH!  PDP-11 INSTRUCTIONS
;  ARE SUCH THAT IF AN INSTRUCTION OUTPUT SCAN IS BEGUN AT ANY POINT IN
;  MEMORY, IT WILL ALMOST ALWAYS CONVERGE TO THE CORRECT INSTRUCTION SPACING
;  IN A VERY FEW WORDS.  THIS IS A RESULT OF THE FACT THAT MOST 16 BIT VALUES,
;  WHEN INTERPTED AS INSTRUCTIONS, REPRESENT SINGLE WORD INSTRUCTIONS.  THIS
;  ALLOWS SYNCING WITH THE ACTUAL INSTRUCTION STREAM VERY QUICKLY.  INORDER
;  TO BACK UP TO THE PREVIOUS INSTRUCTION, WE BACKUP A FAIRLY LONG WAY
;  (ABOUT 40 OR SO INSTRUCTIONS) AND START INTERPTING MEMORY AS INSTRUCTIONS.
;  IF WE GET BACK TO OUR STARTING POINT EXACTLY WE ASSUME WE HAVE FOUND THE
;  CORRECT PREVIOUS INSTRUCTION!  THIS IS NOT 100% CERTAIN, BUT IT IS VERY
;  CLOSE.  IF WE DO NOT GET AN EXACT MATCH, WE CHANGE TO WORD MODE AND DISPLAY
;  THE PREVIOUS WORD.  THIS IS NOT VERY GOOD, BUT IT IS THE BEST WE CAN DO.
;  IT WOULD BE POSSIBLE TO TRY THE 3 PREVIOUS WORDS AS INSTRUCTIONS, BUT
;  THIS HAS A FAIRMY HIGH CHANCE OF GIVING A FALSE RESULT.  THIS METHOD HAS
;  THE ADVANTAGE THAT IF IT DOES DISPLAY AN INSTRUCTION, IT IS ALMOST
;  CERTAINLY CORRECT.  IT IS MOST LIKELY TO FAIL WHEN LOOKING AT AREAS OF
;  CODE FOLLOWING DATA AREAS.  IF THE WORD BACKED UP FROM IS A DOZEN OR SO
;  WORDS INTO THE INSTRUCTION AREA, IT SHOULD WORK WELL.

OPNPRV:	JSR	PC,CRLF
	JSR	PC,CLOSEL		;CLOSE CURRENT LOCATION IF OPEN
	BCS	READC4			;IF ERROR
	TBBN	$AC,BITSC,OPNPR9	;IF AC
	TBBE	$INSTR,FLAGT,OPNPR7	;GO ON IF NOT INSTRUCTION
	MOV	WORDC,FIELD		;REMEMBER CURRENT ADDRESS
	CMP	#BCKAMT,WORDC		;ARE WE AT THE VERY BOTTOM?
	BLO	OPNPR2			;NO
	CLR	ADDRES			;YES-SO START AT 0
	BR	OPNPR3

OPNPR2:	MOV	WORDC,ADDRES		;USE CURRENT ADDRESS
	SUB	#BCKAMT,ADDRES		;BACK UP SOME
OPNPR3:	BIS	#$NOOUP,FLAG1		;NO OUTPUT WHILE WE SCAN
OPNPR4:	JSR	PC,TYPINS		;GET SIZE OF THIS INSTRUCTION
	ADD	SIZEC,ADDRES		;BUMP ADDRESS
	CMP	ADDRES,FIELD		;ARE WE BACK WHERE WE STARTED?
	BLO	OPNPR4			;NO-CONTINUE
	BEQ	OPNPR6			;YES-IS IT EXACT?
	BIC	#$INSTR,FLAGT		;NO-WE LOOSE-CHANGE TO WORD MODE
	MOV	#2,SIZEC
OPNPR6:	BIC	#$NOOUP,FLAG1		;ENABLE OUTPUT
OPNPR7:	SUB	SIZEC,WORDC		;BACK UP WORD OR BYTE
	BR	OPNNX2			;AND CONTINUE

OPNPR9:	DEC	WORDC			;BACK UP AC
	BR	OPNNX2			;CONTINUE

;HERE FOR LINE-FEED - EXAMINE NEXT INSTRUCTION, WORD, OR BYTE

OPNNXT:	JSR	PC,CLOSEL		;CLOSE CURRENT LOCATION
	BCS	READC4			;IF ERROR
	TBBN	$AC,BITSC,OPNNX1	;IF AC NUMBER
	ADD	SIZEC,WORDC		;BUMP ADDRESS
	BR	OPNNX2

OPNNX1:	INC	WORDC			;BUMP AC NUMBER
OPNNX2:	MOV	WORDC,ADDRES
	MOV	BITSC,BITSA

;HERE TO TYPE THE CONTENTS OF A LOCATION - THE FORMAT OF THE OUTPUT IS
;  DETERMINED BY FLAGS IN FLAGT AND THE VALUE OF RADIXT AS FOLLOWS:
;	FLAGT:
;	  $INSTR = SET IF LOCATION IS TO BE TYPED AS AN INSTRUCTION
;	  $BYTE  = SET LOCATION IS A SINGLE BYTE TO BE TYPED AS A DATA VALUE
;		   IF BOTH BITS ARE CLEAR, A WORD IS TYPED AS A DATA VALUE
;	  $U     = SET IF NUMERIC VALUES ARE TO BE TYPED AS UNSIGNED VALUES
;	  $S     = SET IF NUMERIC VALUES ARE TO BE TYPED AS SIGNED VALUES
;		   IF BOTH BITS ARE CLEAR, VALUES ARE TYPED AS SIGNED VALUES
;		     UNLESS THEY ARE KNOWN TO BE ADDRESSES, IN WHICH CASE THEY
;		     ARE TYPED AS UNSIGNED VALUES
;	  $A     = EACH VALUE IS TYPED AS 1 OR 2 ASCII CHARACTERS
;	  $5     = EACH 16 BIT VALUE IS TYPED AS 3 RADIX-50 CHARACTERS
;	  $N     = EACH VALUE IS TYPED AS A NUMERIC VALUE ONLY, NO SYMBOL TABLE
;		     SEARCHES ARE MADE
;	RADIXT:
;		CONTAINS THE OUTPUT RADIX; VALUE MAY BE 2, 8, 10, OR 16

OPNNX3:	TBBN	$NOADR,FLAG1,OPNNX4	;WANT TO TYPE ADDRESS?
	JSR	PC,TYPADR		;YES-TYPE THE ADDRESS
OPNNX4:	BIC	#$NOADR+$USSRC,FLAG1	;CLEAR ADDRESS FLAG
	JSR	PC,TAB			;TYPE A TAB
.IF EQ	..PIC
	MOV	#WORD1,R1
.IFF
	MOV	#<WORD1-2$>,R1		;ARE WE TYPING THE INPUT VALUE?
	ADD	PC,R1
.ENDC
2$:	CMP	R1,ADDRES
	BNE	OPNNX5			;NO-GO ON
	TBBE	$AC,BITS1,OPNNXX	;YES-GO ON IF NOT AC NUMBER
	MOV	WORD1,R1		;GET AC NUMBER
	MOV	R1,DSTFLD		;STORE AS FIELD VALUE
	MOV	#$DSTOK+$DSTAC,FLAGW	;SET BITS
	JSR	PC,TYPAC		;TYPE AC NUMBER
	BR	MRKOPT			;CONTINUE

OPNNX5:	MOV	ADDRES,DOT		;UPDATE VALUE OF "."
	BIS	#$OPEN,FLAG1		;INDICATE LOCATION IS OPEN
	TBBN	$AC,BITSA,OPNNX7	;IF AC, DON'T TYPE AS INSTRUCTION OR
					;  BYTE
	TBBN	$BYTE,FLAGT,PRTBYT	;IF BYTE OPEN
OPNNXX:	TBBN	$UT+$GT,FLAGT,OPNNX8	;IF WANT TEMPORARY UNSIGNED OUTPUT
	TBBN	$INSTR,FLAGT,PRTINS	;IF INSTRUCTION OPEN
OPNNX7:	MOV	#2,SIZEC		;WORD IS 2 BYTES
OPNNX8:	MOV	SIZEC,R3		;GET SIZE
	ASR	R3			;AS COUNT
	MOV	ADDRES,FIELD		;COPY ADDRESS
OPNNX9:	MOV	FIELD,R1		;GET ADDRESS
	MOV	BITSA,R2		;GET BITS FOR ADDRESS
	JSR	PC,REDWRD		;GET CONTENTS
	BCS	READC5			;IF ERROR
	MOV	R0,DSTFLD		;STORE FOR LATER
	MOV	#$DSTOK,FLAGW		;INDICATE WORD VALUE IS VALID
	MOV	R0,R1			;GET VALUE IN RIGHT AC
	JSR	PC,TYPNUM		;TYPE AS DATA
	DEC	R3			;MORE TO DO?
	BLE	MRKOPT			;NO
	ADD	#2,FIELD		;YES-BUMP ADDRESS
	MOV	#WRDSMS-MSGBAS,R0	;TYPE SEPERATOR
	JSR	PC,OUTSTR
	BR	OPNNX9			;AND CONTINUE

;HERE TO TYPE INSTRUCTION

PRTINS:	JSR	PC,TYPINS		;TYPE IT AS AN INSTRUCTION
	BCS	READC5
	BR	MRKOPT			;CONTINUE

;HERE TO TYPE BYTE

PRTBYT:	MOV	#1,SIZEC		;ITEM IS 1 BYTE
	MOV	ADDRES,R1		;GET CONTENTS
	MOV	BITSA,R2
	JSR	PC,REDBYT
	BCS	READC5			;IF ERROR
	CLR	FLAGW			;INDICATE NOT VALID AS ADDRESS
	MOV	R0,R1			;GET VALUE IN RIGHT AC
	JSR	PC,TYPNUM		;TYPE AS DATA
MRKOPT:	.IF EQ	..PIC
	MOV	#WORD1,R1
.IFF
	MOV	#<WORD1-2$>,R1		;TYPING SOMETHING HE TYPED?
	ADD	PC,R1
.ENDC
2$:	CMP	R1,ADDRES
	BEQ	READC5			;YES-START A NEW LINE
	JSR	PC,TAB			;NO-STAY ON THE SAME LINE
READY5:	JMP	READY			;CONTINUE

;HERE ON TAB - PUSH ADDRESS

INDIR1:	JSR	PC,CRLF
	JSR	PC,CLOSEL		;CLOSE THE LOCATION FIRST
	BCS	READC5			;IF ERROR
	CMP	#<ADRSTE-ADRSTK>,ADRSTP	;IS ADDRESS STACK FULL?
	BLE	ADSTFL			;YES-GO COMPLAIN
	MOV	ADRSTP,R2		;GET POINTER
.IF EQ	..PIC
	ADD	#ADRSTK,R2
.IFF
	ADD	#<ADRSTK-2$>,R2		;CALUCLATE ACTUAL ADDRESS
	ADD	PC,R2
.ENDC
2$:	MOV	ADDRES,(R2)+		;STORE ADDRESS
	MOV	BITSA,(R2)+		;AND ADDRESS BITS
	MOV	FLAGT,(R2)		;AND CURRENT FLAG BITS
	ADD	#6,ADRSTP		;UPDATE POINTER
	JSR	PC,GETADR		;GET NEW ADDRESS
	BCS	READC5			;IF ERROR
	BR	INDIR4			;AND GO OPEN THAT LOCATION

;HERE IF ADDRESS STACK OVERFLOW

ADSTFL:	MOV	#ADFLMS-MSGBAS,R0	;GET ERROR MESSAGE
READE5:	JSR	PC,OUTSTR		;COMPLAIN
READC5:	JMP	READYC

;HERE ON RIGHT ANGLE - POP ADDRESS

INDIR2:	JSR	PC,CRLF
	JSR	PC,CLOSEL		;CLOSE LOCATION
	BCS	READC5			;IF ERROR
	MOV	ADRSTP,R2		;GET POINTER
	BLE	NOADPP			;NOTHING THERE-ERROR
.IF EQ	..PIC
	ADD	#ADRSTK,R2
.IFF
	ADD	#<ADRSTK-2$>,R2		;CALCULATE ACUTAL ADDRESS
	ADD	PC,R2
.ENDC
2$:	MOV	-(R2),FLAGT		;RESTORE CURRENT FLAGS
	MOV	-(R2),R1		;GET ADDRESS BITS
	MOV	(R2),R0			;GET ADDRESS
	SUB	#6,ADRSTP		;UPDATE POINTER
INDIR4:	MOV	R0,ADDRES		;MAKE IT THE CURRENT ADDRESS
	MOV	R0,WORDC
	MOV	R1,BITSA
	MOV	R1,BITSC
	JMP	OPNNX3			;GO OPEN THAT LOCATION

;HERE IF ADDRESS STACK IS EMPTY

NOADPP:	MOV	#NOADMS-MSGBAS,R0	;GET MESSAGE
	BR	READE5
	.PAGE
;HERE ON RETURN - CLOSE CURRENT LOCATION

CLSWRD:	JSR	PC,CLOSEL		;CLOSE CURRENT LOCATION
	BCS	CLSWR2			;IF ERROR
	BIS	#$SMLIN,FLAG1		;DON'T SKIP LINE BEFORE PROMPT
CLSWR2:	JMP	READYC			;THATS ALL

;SUBROUTINE TO CLOSE CURRENT LOCATION
;	JSR	PC,CLOSEL
;	C:SET = ERROR

CLOSEL:	TBBE	$OPEN,FLAG1,CLOS20	;FORGET IT IF NO LOCATION OPEN
	TBBE	$HVARG,FLAG1,2$		;IF NO MODE SPECIFIED
	TSTB	BUFFER			;ANYTHING AFTER THE MO	BLE	4$			;NO-OK
	JMP	GETAIS			;YES-FAIL

2$:	TSTB	BUFFER			;ANY INPUT?
	BLE	CLOS16			;NO-NOTHING TO DO HERE!
	JSR	PC,ITEM			;GET INPUT VALUE
	BCS	RT0004
4$:	MOV	BITSA,R2		;GET BITS FOR ADDRESS
	TBBN	$AC,R2,CLOSE1		;AC'S ARE ALWAYS ADDRESSED AS WORDS
	TBBN	$INSTR,FLAGT,CLOSE6	;IF INSTRUCTION IS OPEN
	TBBN	$BYTE,FLAGT,CLOSE3	;IF BYTE IS OPEN

;HERE IF WORD WAS OPEN

CLOSE1:	CMP	#2,SIZEX		;SINGLE WORD VALUE?
	BGE	CLOSE2			;YES-OK
	MOV	#OFWSMS-MSGBAS,R0	;TOO LONG-WARN HIM
	JSR	PC,OUTSTR
CLOSE2:	MOV	ADDRES,R1		;GET ADDRESS
	MOV	WORD1,R0		;GET CONTENTS
	JSR	PC,WRTWRD		;STORE
	BR	CLOS14

;HERE IF BYTE WAS OPEN

CLOSE3:	CMP	#2,SIZEX		;IS NEW ITEM TOO BIG?
	BLT	CLOSE4			;NO-TELL HIM ITS BEEN TRUNCATED
	MOVB	WORD1+1,R0		;MAYBE
	BEQ	CLOSE5
	TSTB	WORD1
	SXT	R1
	CMP	R1,R0
	BEQ	CLOSE5			;OK
CLOSE4:	MOV	#TRUNMS-MSGBAS,R0	;TELL HIM IT HAS BEEN TRUNCATED
	JSR	PC,OUTSTR
CLOSE5:	MOV	ADDRES,R1		;GET ADDRESS
	MOV	WORD1,R0		;GET VALUE
	JSR	PC,WRTBYT		;STORE
	BR	CLOS14

;HERE IF INSTRUCTION WAS OPEN

CLOSE6:	CMP	SIZEC,SIZEX		;SAME SIZE?
	BEQ	CLOS10			;YES
	BGT	CLOSE8
	MOV	#NILNMS-MSGBAS,R0	;TELL HIM NEW INSTR IS LONGER
	BR	CLOSE9

CLOSE8:	MOV	#NISTMS-MSGBAS,R0	;TELL HIM NEW INSTR IS SHORTER
CLOSE9:	JSR	PC,OUTSTR
	MOV	SIZEX,SIZEC		;UPDATE SIZE
CLOS10:	MOV	SIZEX,R5		;GET SIZE
	SUB	#2,R5			;MINUS 2
CLOS12:	.IF EQ	..PIC
	MOV	#WORD1,R0
.IFF
	MOV	#<WORD1-2$>,R0		;CALCULATE ADDRESS OF DATA
	ADD	PC,R0
.ENDC
2$:	ADD	R5,R0
	MOV	(R0),R0			;GET DATA
	MOV	ADDRES,R1		;GET ADDRESS
	ADD	R5,R1
	JSR	PC,WRTWRD		;STORE WORD
	SUB	#2,R5			;DECREMENT INDEX
	BGE	CLOS12			;CONTINUE IF MORE TO DO
CLOS14:	MOV	FLAGX,FLAGW		;UPDATE DATA
	MOV	SRCFLX,SRCFLD
	MOV	DSTFLX,DSTFLD
CLOS16:	TBBE	$TMPLC,FLAG1,RT0CC4	;TEMP. LOCATION OPEN?
	MOV	SIZET,SIZEC		;YES-RESTORE SIZE
	MOV	FLGTT,FLAGT		;AND FLAGS
	BIC	#$TMPLC,FLAG1		;CLEAR FLAG
RT0CC4:	CLC
RT0004:	RTS	PC			;RETURN

;HERE IF NO LOCATION OPEN

CLOS20:	BIC	#^C<$INSTR!$BYTE>,FLAGQ	;RESTORE TYPEOUT MODE FROM LAST WORD
	BIC	#$INSTR!$BYTE,FLAGT	;  EXAMINED
	BIS	FLAGQ,FLAGT
	BR	RT0CC4			;THATS ALL
	.PAGE
	.SBTTL	XDT2 - ESCAPE CHARACTER ROUTINES

;HERE ON ESC - NEXT CHARACTER IS SPECIAL COMMAND

ESCAPE:	JSR	PC,GETCHX		;GET CHARACTER AFTER THE ESC
	MOV	#ES1NUM,R2		;SET POINTER
	CLR	R1			;CLEAR R1 AS A FLAG THAT THIS IS THE
					;  FIRST ESC
	BR	ESCLOP			;GO SEARCH FOR THE CHARACTER

;HERE IF HAVE TWO ESCAPE'S IN A ROW

ESCAP2:	JSR	PC,GETCHX		;GET NEXT CHARACTER
	MOV	#ES2NUM,R2		;SET POINTER
	MOV	R2,R1			;SET R1 NON-ZERO TO INDICATE THIS IS
					;  THE SECOND ESC
ESCLOP:	.IF EQ	..PIC
	MOV	#ESCCHR-1,R3
.IFF
	MOV	#<ESCCHR-1-2$>,R3
	ADD	PC,R3
.ENDC
2$:	ADD	R2,R3
	CMPB	(R3),R0			;THIS CHARACTER?
	BEQ	ESCCHX			;YES
	SOB	R2,ESCLOP		;NO-LOOP IF MORE TO CHECK
SYNERR:	MOV	#SYNEMS-MSGBAS,R0	;GET MESSAGE
	JSR	PC,OUTSTR
READY0:	JMP	READY

;HERE WITH VALID CHARACTER AFTER ESCAPE

ESCCHX:	ASL	R2			;SET FOR WORD INDEXING
.IF EQ	..PIC
	MOV	#ESPDSP-2,R3
.IFF
	MOV	#<ESPDSP-2-1$>,R3
	ADD	PC,R3
.ENDC
1$:	ADD	R2,R3
	MOV	(R3),R3			;GET DISPATCH ADDRESS
.IF EQ	..PIC
ESCBAS=!0
.IFF
	ADD	PC,R3			;FIX IT UP
ESCBAS:
.ENDC
	ROR	R3			;GET LOW ORDER BIT IN C
	BCS	2$			;IF WANT TO BYPASS CALL TO ITEM
	PUSH	R3			;SAVE ADDRESS
	PUSH	R1			;AND SAVE DOUBLE ESCAPE FLAG
	JSR	PC,ITEM			;PROCESS THE ARGUMENT
	POP	R1			;RESTORE FLAG
	POP	R3			;RESTORE ADDRESS
	BCS	READY0			;IF ERROR
2$:	ASL	R3			;ADJUST ADDRESS
	JMP	(R3)			;DISPATCH
	.PAGE
	.SBTTL	XDT2 - ESCAPE CHARACTER TABLES

;DEFINE MACRO TO GENERATE THE ESCAPE CHARACTER TABLES

	.MACRO	ESCTBL
	XX	<CU> ,1,READY		;CONTROL-U - DELETE COMMAND
	XX	<'F> ,0,DFTSGN		;USE DEFAULT SIGNED OR UNSIGNED OUTPUT
	XX	<'U> ,0,UNSIGN		;FORCE UNSIGNED OUTPUT
	XX	<'C> ,0,SIGNED		;FORCE SIGNED OUTPUT
	XX	<'A> ,0,ASCCHR		;OUTPUT AS ASCII CHARACTER(S)
	XX	<'X> ,0,R50CHR		;OUTPUT AS RADIX-50
	XX	<'Y> ,0,SYMVAL		;USE SYMBOLIC OUTPUT
	XX	<'N> ,0,NUMVAL		;USE NUMERIC OUTPUT
	XX	<'0> ,0,DECRAD		;SET OUTPUT RADIX TO 10
	XX	<'2> ,0,BINRAD		;SET OUTPUT RADIX TO 2
	XX	<'8> ,0,OCTRAD		;SET OUTPUT RADIX TO 8
	XX	<'6> ,0,HEXRAD		;SET OUTPUT RADIX TO 16
	XX	<'=> ,0,SRCEQL		;SEARCH FOR WORD EQUAL TO VALUE
	XX	<'#> ,0,SRCNEQ		;SEARCH FOR WORD NOT EQUAL TO VALUE
	XX	<'?> ,1,QUESTN		;TYPE INFO ABOUT A SYMBOL OR VALUE
	XX	<'/> ,0,CHGINS		;TYPE AS INSTRUCTION
	XX	<'[> ,0,CHGWRD		;TYPE AS DATA WORD
	XX	<'\> ,0,CHGBYT		;TYPE AS BYTE
	YY	<ESC>,1,ESCAP2		;SECOND ESC
	YY	<'W> ,1,EXMPSW		;DISPLAY PSW
	YY	<'O> ,1,EXMOFS		;DISPLAY OFFSET REGISTER
	YY	<'P> ,1,PRCEED		;PROCEED FROM BREAKPOINT
	YY	<'E> ,1,SNGSTP		;SINGLE STEP FROM BREAKPOINT
	YY	<'I> ,0,GOSNGL		;SINGLE STEP FROM ADDRESS
	YY	<'G> ,0,STRPRG		;START AT ADDRESS
	YY	<'B> ,0,SETBPS		;SET BREAKPOINT
	YY	<'R> ,0,RMVBPS		;REMOVE BREAKPOINT
	YY	<'L> ,1,EXMLSL		;TYPE LOW SEARCH LIMIT REGISTER
	YY	<'H> ,1,EXMHSL		;TYPE HIGH SEARCH LIMIT REGISTER
	YY	<'M> ,1,EXMSMK		;TYPE SEARCH MASK REGISTER
	YY	<'"> ,1,SELPRG		;SELECT SYMBOL TABLE FOR PROGRAM
	YY	<':> ,1,DEFSYM		;DEFINE SYMBOL VALUE
	YY	<'K> ,1,RMVSYM		;REMOVE SYMBOL FROM SYMBOL TABLE
	YY	<'S> ,0,USESRC		;USE SOURCE FIELD FOR ADDRESS
	.ENDM

;GENERATE THE CHARACTER TABLE

	.MACRO	XX A,B,C
	.BYTE	A
ES1NUM=ES1NUM+1
ES2NUM=ES2NUM+1
	.ENDM
	.MACRO	YY A,B,C
	.BYTE	A
ES1NUM=ES1NUM+1
	.ENDM

ES1NUM=0
ES2NUM=0
ESCCHR:	ESCTBL
	.EVEN

;GENERATE THE ESC DISPATCH TABLE

	.MACRO	XX A,B,C
	.WORD	B+C-ESCBAS
	.ENDM
	.MACRO	YY A,B,C
	.WORD	B+C-ESCBAS
	.ENDM

ESPDSP:	ESCTBL
	.PAGE
	.SBTTL	XDT2 - COMMANDS WHICH SET TYPEOUT MODES

;HERE TO SET FOR DEFAULT NUMERIC OUTPUT *** $F ***

DFTSGN:	MOV	#$G+$U+$A+$5,R4		;CLEAR FLAGS
	BR	FLGCLA

;HERE TO SET FOR UNSIGNED NUMERIC OUTPUT *** $U ***

UNSIGN:	MOV	#$G+$A+$5,R4		;CLEAR FLAGS
	MOV	#$U,R5			;AND SET FLAG
	BR	FLGCOM

;HERE TO SET FOR SIGNED NUMERIC OUTPUT *** $C ***

SIGNED:	MOV	#$U+$A+$5,R4		;CLEAR FLAGS
	MOV	#$G,R5			;AND SET FLAG
	BR	FLGCOM

;HERE TO SET FOR ASCII OUTPUT *** $A ***

ASCCHR:	MOV	#$5,R4			;NOT RADIX 50
	MOV	#$A,R5			;ASCII
	BR	FLGCOM

;HERE TO SET FOR RADIX-50 OUTPUT *** $X ***

R50CHR:	MOV	#$A,R4			;NOT ASCII
	MOV	#$5,R5			;RADIX 50
	BR	FLGCOM

;HERE TO SET FOR SYMBOLIC OUTPUT *** $Y ***

SYMVAL:	MOV	#$N+$A+$5,R4		;CLEAR FLAGS
FLGCLA:	CLR	R5
	BR	FLGCOM

;HERE TO SET FOR NON-SYMBOLIC OUTPUT *** $N ***

NUMVAL:	MOV	#$A+$5,R4		;CLEAR FLAGS
	MOV	#$N,R5			;AND INDICATE NUMBERIC OUTPUT
	BR	FLGCOM

;HERE TO CHANGE TO INSTRUCTION TYPEOUT *** $/ ***

CHGINS:	MOV	#$BYTE,R4
	MOV	#$INSTR,R5
	BR	FLGCOM

;HERE TO CHANGE TO WORD TYPEOUT *** $[ ***

CHGWRD:	MOV	#$BYTE+$INSTR,R4
	BR	FLGCLA

;HERE TO CHANGE TO BYTE TYPEOUT *** $\ ***

CHGBYT:	MOV	#$INSTR,R4
	MOV	#$BYTE,R5
FLGCOM:	BIC	R4,FLAGT		;CLEAR BITS
	BIS	R5,FLAGT		;AND SET BITS
	TST	R1			;SHOULD THESE BITS BE PERM. TOO?
	BEQ	ESCDNT			;NO
	BIC	R4,FLAGP
	BIS	R5,FLAGP
	BR	ESCDNP			;CONTINUE

;HERE TO SET FOR DECIMAL OUTPUT (RADIX = 10) *** $0 ***

DECRAD:	MOV	#12,R2			;GET RADIX
	BR	RADCOM

;HERE TO SET FOR BINARY OUTPUT (RADIX = 2) *** $2 ***

BINRAD:	MOV	#2,R2			;GET RADIX
	BR	RADCOM

;HERE TO SET FOR OCTAL OUTPUT (RADIX = 8) *** $8 ***

OCTRAD:	MOV	#10,R2			;GET RADIX
	BR	RADCOM

;HERE TO SET FOR HEX OUTPUT (RADIX = 16) *** $6 ***

HEXRAD:	MOV	#20,R2			;GET RADIX
RADCOM:	MOV	R2,RADIXT		;SET TEMP. RADIX
	TST	R1			;SHOULD WE SET PERMANATE RADIX TOO?
	BEQ	ESCDNT			;NO
	MOV	R2,RADIXP		;YES-DO SO
ESCDNP:	JSR	PC,TAB
	JMP	READY			;CONTINUE (PROMPT)

ESCDNT:	TSTB	BUFFER			;ARGUMENT TYPED?
	BLE	ESCDN2			;NO
	BIS	#$HVARG,FLAG1		;YES-INDICATE ALREADY HAVE ARGUMENT
ESCDN2:	JMP	READ4			;CONTINUE (DON'T PROMPT)

;HERE TO SET TO USE SOURCE ADDRESS *** $S ***

USESRC:	BIS	#$USSRC,FLAG1		;SET FLAG
	BR	ESCDNT
	.PAGE
	.SBTTL	XDT2 - COMMAND TO DISPLAY INFORMATION

;HERE TO TYPE DATA ABOUT A SYMBOL OR VALUE OR ABOUT BREAKPOINTS *** $? ***

QUESTN:	TST	R1			;DID HE TYPE TWO $'S?
	BNE	QUEST0			;YES
	TSTB	BUFFER			;NO-DO WE HAVE AN ARGUMENT?
	BGT	2$			;YES-GO ON
	JMP	DSPBPS			;NO-GO TELL HIM ABOUT BREAKPOINTS

2$:	CALL	GETX50			;GET RADIX-50
	BCC	QUESTA			;IF NO ERRORS
QUESTE:	JMP	SYNERR			;ERROR

QUESTA:	MOV	R4,SYMBL1		;SAVE SYMBOL
	MOV	R5,SYMBL2
	BR	QUEST1			;CONTINUE

;HERE IF HE TYPED TWO $'S

QUEST0:	CALL	ITEM			;GET ARGUMENT
	BCS	QUESTE			;IF ERROR
	CLR	SYMBL1			;INDICATE SHOULD USE NUMERIC VALUE
QUEST1:.IF EQ	..SAT
	MOV	#QUESHD-MSGBAS,R0	;TYPE HEADER
	JSR	PC,OUTSTR
	MOV	SYMPNT,R3		;GET POINTER TO SYMBOL TABLE
	BEQ	QUEST9			;IF NO SYMBOL TABLE LOADED
	MOV	(R3)+,R4		;GET COUNT
	TST	(R3)+			;POINT TO FIRST ENTRY
QUEST2:	TBBE	$PRGM,.SYBTS(R3),QUEST3	;PROGRAM NAME?
	MOV	(R3),BSTDIF		;YES-REMEMBER IT
	MOV	.SYNM2(R3),BSTSYM
QUEST3:	TST	SYMBL1			;ARE WE SEARCHING FOR A SYMBOL?
	BEQ	QUEST4			;NO-VALUE
	CMP	SYMBL1,(R3)		;SYMBOL-THIS ONE?
	BNE	QUEST8			;NO
	CMP	SYMBL2,.SYNM2(R3)
	BNE	QUEST8			;NO
	BR	QUEST5			;YES

;HERE IF TYPING DATA ABOUT A VALUE

QUEST4:	CMP	WORD1,.SYVAL(R3)	;THIS ONE?
	BNE	QUEST8			;NO
	MOV	.SYBTS(R3),R1		;MAYBE
	MOV	BITS1,R2		;MUST MATCH TYPE (AC OR MEMORY)
	XOR	R2,R1
	TBBN	$AC,R1,QUEST8		;IF NOT SAME
QUEST5:	PUSH	R4			;SAVE SOME AC'S
	PUSH	R3
	JSR	PC,X50OUT		;TYPE SYMBOL
	JSR	PC,TAB
.IF EQ	..PIC
	MOV	#BSTDIF,R3
.IFF
	MOV	#<BSTDIF-2$>,R3		;TYPE PROGRAM NAME
	ADD	PC,R3
.ENDC
2$:	JSR	PC,X50OUT
	JSR	PC,TAB
	POP	R3			;RESTORE POINTER
	MOV	#SPA,R0			;ASSUME NOT PROGRAM NAME
	TBBE	$PRGM,.SYBTS(R3),4$	;IS IT?
	MOV	#'P,R0			;YES
4$:	TBBE	$GLBL,.SYBTS(R3),6$	;IS IT GLOBAL?
	MOV	#'G,R0			;YES
6$:	JSR	PC,PUTCCC		;TELL HIM WHAT IT IS
	MOV	#SPA,R0			;ASSUME NOT RELOCATABLE
	TBBE	$RELOC,.SYBTS(R3),10$	;IS IT?
	MOV	#'R,R0			;YES
10$:	CALL	PUTCCC			;TELL HIM WHICH
	MOV	#SPA,R0			;ASSUME NOT SUPPRESSED
	TBBE	$SUPR,.SYBTS(R3),11$;RIGHT?
	MOV	#'S,R0			;NO-IT IS SUPPRESSED
11$:	CALL	PUTCCC
	MOV	#SPA,R0			;ASSUME LABEL
	TBBN	$LABEL!$PRGM,.SYBTS(R3),12$;IS IT?
	MOV	#'=,R0			;NO
12$:	TBBE	$XDEF,.SYBTS(R3),14$	;WAS IT DEFINED OR REDEFINED WITH $:?
	MOV	#'X,R0			;YES-INDICATE THAT
14$:	CALL	PUTCCC
	MOV	#SPA,R0
	CALL	PUTCCC
	TBBE	$AC,.SYBTS(R3),16$	;AC NUMBER?
	MOV	#'%,R0			;YES
	CALL	PUTCCC
16$:	MOV	.SYVAL(R3),R1		;GET VALUE
	CALL	TYPNM0			;TYPE IT
	CALL	CRLF			;END THE LINE
	POP	R4			;RESTORE THE COUNT
QUEST8:	ADD	#.SYSIZ,R3		;BUMP POINTER
	DEC	R4			;DECREMENT COUNT
	BGT	QUEST2			;CONTINUE IF MORE
.ENDC
QUEST9:	JMP	READYC			;FINISHED

;HERE TO DISPLAY ADDRESSES OF ALL BREAKPOINTS

DSPBPS:	MOV	#BKPTHD-MSGBAS,R0	;TYPE HEADER
	JSR	PC,OUTSTR
	CLR	R2			;CLEAR POINTER
	MOV	#NUMBKP,R3		;SET COUNT
DSPBP2:	.IF EQ	..PIC
	MOV	#BKPADR,R1
.IFF
	MOV	#<BKPADR-2$>,R1		;IS THIS TABLE ENTRY SET?
	ADD	PC,R1
.ENDC
2$:	ADD	R2,R1
	TST	(R1)
	BEQ	DSPBP4			;NO-GO ON
	MOV	#BPL1MS-MSGBAS,R0	;YES
	JSR	PC,OUTSTR
.IF EQ	..PIC
	MOV	#BKPCNT,R1
.IFF
	MOV	#<BKPCNT-4$>,R1		;GET PROCEED COUNT
	ADD	PC,R1
.ENDC
4$:	ADD	R2,R1
	MOV	(R1),R1
	JSR	PC,TYPNM0		;TYPE IT
	MOV	#BPL2MS-MSGBAS,R0
	JSR	PC,OUTSTR
.IF EQ	..PIC
	MOV	#BKPADR,R1
.IFF
	MOV	#<BKPADR-6$>,R1		;GET ADDRESS
	ADD	PC,R1
.ENDC
6$:	ADD	R2,R1
	MOV	(R1),R1
	JSR	PC,TYPNMU		;TYPE IT
DSPBP4:	ADD	#2,R2			;BUMP POINTER
	SOB	R3,DSPBP2		;LOOP IF MORE TO DO
.IF EQ	..SAT
	MOV	#PRGMHD-MSGBAS,R0	;TYPE NEXT HEADER
	JSR	PC,OUTSTR
	MOV	FSTSYM,R3		;GET ADDRESS OF PROGRAM NAME
	CMP	#177777-.SYSIZ,R3	;IS THERE ONE?
	BEQ	DSPBP6			;NO
	JSR	PC,X50OUT		;TYPE PROGRAM NAME
.ENDC
DSPBP6:	JSR	PC,CRLF
	JMP	SNGST6			;GO FINISH UP
	.PAGE
	.SBTTL	XDT2 - COMMANDS WHICH OPEN SPECIAL REGISTERS

;HERE TO TYPE THE LOWER SEARCH LIMIT REGISTER *** $L ***

EXMLSL:	MOV	#LOWLIM-DSPBAS,R1	;GET ADDRESS
	BR	DSPSPL			;CONTINUE

;HERE TO TYPE THE UPPER SEARCH LIMIT REGISTER *** $H ***

EXMHSL:	MOV	#HGHLIM-DSPBAS,R1	;GET ADDRESS
	BR	DSPSPL			;CONTINUE

;HERE TO TYPE THE SEARCH MASK REGISTER *** $M ***

EXMSMK:	MOV	#SRCMSK-DSPBAS,R1	;GET ADDRESS
	BR	DSPSPL			;CONTINUE

;HERE TO TYPE THE OFFSET REGISTER *** $O ***

EXMOFS:	MOV	#OFFSET-DSPBAS,R1	;GET ADDDRESS
	BR	DSPSPL			;CONTINUE

;HERE TO TYPE THE PSW *** $W ***

EXMPSW:	MOV	#UPSW-DSPBAS,R1		;GET ADDRESS OF PSW
DSPSPL:	TSTB	BUFFER			;NO ARGUMENT ALLOWED
	BGT	SYNER1
.IF EQ	..PIC
DSPBAS=!0
.IFF
	ADD	PC,R1			;FIX UP THE ADDRESS
DSPBAS:
.ENDC
	MOV	R1,ADDRES		;STORE ADDRESS
	CLR	BITSA
	BIC	#$INSTR+$BYTE,FLAGT
	BIC	#$USINP,FLAG1
	MOV	#'[,R0			;MAKE IT LOOK NICE
	JSR	PC,PUTCCC
	JSR	PC,TAB
	BIS	#$OPEN,FLAG1		;INDICATE LOCATION IS OPEN
	JMP	OPNNXX			;GO DO IT

;HERE IF SYNTAX ERROR

SYNER1:	JMP	SYNERR
	.PAGE
	.SBTTL	XDT2 - COMMANDS TO SEARCH MEMORY

;HERE TO SEARCH FOR ALL WORDS EQUAL TO A VALUE *** $= ***

SRCEQL:	CLR	R5			;SEARCH FOR EQUALITY
	BR	SRCCOM			;CONTINUE

;HERE TO SEARCH FOR ALL WORDS NOT EQUAL TO A VALUE *** $# ***

SRCNEQ:	MOV	#177777,R5		;SEARCH FOR INEQUALITY
SRCCOM:	JSR	PC,CRLF			;NEW LINE
	TSTB	BUFFER			;ARGUMENT?
	BGT	7$			;YES
	CLR	WORD1			;NO-DEFAULT IS 0
7$:	MOV	SRCMSK,R3		;GET MASK
	BIC	#$INSTR+$BYTE,FLAGT	;ASSUME WORD SEARCH
	MOV	#2,SIZEC
	TST	R1			;RIGHT?
	BEQ	1$			;YES
	BIS	#$BYTE,FLAGT		;NO-BYTE SEARCH
	BIC	#^C377,R3		;JUST LOOK AT 8 BITS
	DEC	SIZEC
1$:	COM	R3			;SINCE DON'T REALLY HAVE AND INSTR!
	MOV	WORD1,R4		;GET VALUE
	BIC	R3,R4			;MASK OUT DON'T CARE BITS
	MOV	LOWLIM,R1		;GET FIRST ADDRESS TO CHECK
	TBBN	$BYTE,FLAGT,SRCLP1	;GO ON IF BYTE SEARCH
	BIC	#1,R1			;IF WORD SEARCH, MAKE SURE WORD ADDR
SRCLP1:	CLR	R2			;CLEAR BITS FOR REDWRD
	MOV	R1,ADDRES		;SAVE ADDRESS
	TBBN	$BYTE,FLAGT,10$		;BYTE SEARCH?
	JSR	PC,REDWRD		;NO-READ WORD
	BR	12$

10$:	JSR	PC,REDBYT		;YES-READ BYTE
12$:	BCS	SRCDON			;IF ERROR
	MOV	R0,R2			;SAVE FOR POSSIBLE TYPEOUT
	BIC	R3,R0			;CLEAR DON'T CARE BITS
	XOR	R4,R0			;COMPARE WITH VALUE
	BEQ	2$
	MOV	#177777,R0
2$:	XOR	R5,R0			;GET THE SENSE RIGHT
	BNE	SRCLP3			;IF DON'T WANT THIS ONE
	PUSH	R4			;SAVE REGISTERS
	PUSH	R5
	JSR	PC,TYPADR		;TYPE ADDRESS
	JSR	PC,TAB
	MOV	R2,R1			;GET CONTENTS
	JSR	PC,TYPNUM		;TYPE IT
	JSR	PC,CRLF			;END THE LINE
	POP	R5
	POP	R4
SRCLP3:	MOV	ADDRES,R1		;RESTORE ADDRESS
1$:	ADD	SIZEC,R1		;BUMP ADDRESS
	CMP	HGHLIM,R1		;FINISHED?
	BLO	SRCDON			;YES
.IF EQ	..PIC
	CMP	#XDTLOW,R1
.IFF
	MOV	#<XDTLOW-2$>,R2		;IS ADDRESS WITHIN XDT?
	ADD	PC,R2
2$:	CMP	R2,R1
.ENDC
	BHI	SRCLP1			;NO-CONTINUE
.IF EQ	..PIC
	MOV	#XDTHGH,R2
.IFF
	MOV	#<XDTHGH-4$>,R2
	ADD	PC,R2
.ENDC
4$:	CMP	R2,R1
	BLO	SRCLP1
	MOV	R2,R1			;YES-SKIP XDT
	BR	1$

SRCDON:	JMP	READYC			;FINISHED
	.PAGE
	.SBTTL	XDT2 - SYMBOL TABLE COMMANDS

;HERE TO OPEN THE SYMBOL TABLE FOR A PROGRAM *** $" ***

SELPRG:	.IF EQ	..SAT
	TSTB	BUFFER			;WAS AN ARGUMENT TYPED?
	BGT	SELPR1			;YES-GO ON
	MOV	#177777-.SYSIZ,FSTSYM	;NO-INDICATE NO PROGRAM IS OPEN
	MOV	#177777-.SYSIZ,LSTSYM
	JMP	TABX2

;HERE IF PROGRAM NAME TYPED

SELPR1:	JSR	PC,GETX50		;GET SYMBOL
SYNCS1:	BCS	SYNER1			;IF ERROR
	MOV	SYMPNT,R1		;GET SYMBOL TABLE POINTER
	BEQ	SELPR5			;IF NO SYMBOL TABLE LOADED
	MOV	(R1)+,R2		;GET LENGTH
	TST	(R1)+			;POINT TO FIRST ENTRY
SELPR2:	TBBE	$PRGM,.SYBTS(R1),SELPR4	;IS THIS A PROGRAM NAME?
	CMP	R4,(R1)			;YES-IS IT THE ONE WE WANT?
	BNE	SELPR4			;NO
	CMP	R5,.SYNM2(R1)
	BEQ	SELPR6			;YES
SELPR4:	ADD	#.SYSIZ,R1		;NO-BUMP POINTER
	SOB	R2,SELPR2		;CONTINUE IF MORE TO CHECK
SELPR5:	MOV	#UNDFMS-MSGBAS,R0	;COMPLAIN
	JSR	PC,OUTSTR
	JMP	TABX2

;HERE IF FOUND THE PROGRAM NAME

SELPR6:	MOV	R1,FSTSYM		;STORE ADDRESS OF START OF SYMBOL TABLE
					;  FOR THIS PROGRAM
SELPR7:	ADD	#.SYSIZ,R1		;BUMP POINTER
	DEC	R2			;IS THERE ANOTHER ENTRY?
	BLE	SELPR9			;NO
	TBBE	$PRGM,.SYBTS(R1),SELPR7	;YES-CONTINUE IF NOT START OF NEXT
					;  PROGRAM'S TABLE
SELPR9:	SUB	#.SYSIZ,R1		;POINT TO LAST ENTRY FOR THIS PROGRAM
	MOV	R1,LSTSYM		;STORE IT
.ENDC	;..SAT
	BR	TABX2			;THATS ALL

;HERE TO DEFINE A SYMBOL *** $: ***

DEFSYM:	.IF EQ	..SAT
	JSR	PC,GETX50		;GET SYMBOL
	BCS	SYNCS1			;IF ERROR
	MOV	FSTSYM,R1		;ONLY SEARCH IN CURRENTLY OPEN PROGRAM
	MOV	LSTSYM,R0
	CMP	#177777-.SYSIZ,R1	;IS A PROGRAM OPEN?
	BEQ	UDFSYM			;NO-SAY "UNDEFINED SYMBOL"!
DEFSY2:	ADD	#.SYSIZ,R1		;BUMP POINTER
	CMP	R0,R1			;FINISHED?
	BLO	DEFSY6			;YES
	CMP	R4,(R1)			;NO-THIS SYMBOL?
	BNE	DEFSY2
	CMP	R5,.SYNM2(R1)
	BNE	DEFSY2
DEFSY4:	MOV	WORDC,.SYVAL(R1)	;STORE NEW VALUE
	BIC	#$AC,.SYBTS(R1)		;MAKE SURE AC FLAG IS CLEAR
	BIS	BITSC,.SYBTS(R1)	;AND SET IT IF NEW VALUE IS AC NUMBER
	BIS	#$XDEF,.SYBTS(R1)	;INDICATE $: COMMAND USED
	BR	TABX2			;FINISHED

;HERE IF SYMBOL NOT DEFINED NOW

DEFSY6:	MOV	SYMPNT,R2		;GET SYMBOL TABLE POINTER
	TST	2(R2)			;ANY PATCH SPACE LEFT?
	BLE	DEFSYE			;NO-GO COMPLAIN
	PUSH	R5			;YES-SAVE SYMBOL
	PUSH	R4
	MOV	R0,R5			;CALCULATE POSITION OF LAST
	SUB	R2,R5			;  SYMBOL OF CURRENT PROGRAM IN
	CLR	R4			;  THE TABLE
	DIV	#.SYSIZ,R4
	INC	R4
	MOV	(R2),R0
	SUB	R0,R4
	MUL	#-.SYSIZ,R4		;CALCULATE NUMBER OF WORDS TO MOVE
	MOV	R5,R4
	ROR	R5			;COUNT = NUMBER OF WORDS / 2
	ADD	R1,R4			;SET UP ADDRESSES FOR THE MOVE
	TST	R5			;ANYTHING TO MOVE?
	BEQ	DEFSY9			;NO-GO STORE NEW SYMBOL AT END

;HERE IF HAVE TO MOVE SOME ENTRIES UP TO MAKE ROOM

DEFSY7:	MOV	R4,R3
	ADD	#.SYSIZ,R3
DEFSY8:	MOV	-(R4),-(R3)		;COPY A WORD
	SOB	R5,DEFSY8		;LOOP IF MORE
DEFSY9:	POP	(R4)+			;STORE SYMBOL
	POP	(R4)+
	MOV	BITSC,(R4)		;STORE BITS
	BIS	#$XDEF,(R4)+		;INDICATE $: COMMAND USED
	MOV	WORDC,(R4)		;STORE VALUE
	INC	(R2)+			;FIX UP THE COUNTS
	DEC	(R2)
	ADD	#.SYSIZ,LSTSYM		;INDICATE ONE MORE SYMBOL IN THIS
					;  PROGRAM
	BR	TABX			;FINISHED

;HERE IF NO MORE SPACE IN SYMBOL TABLE

DEFSYE:	MOV	#STFLMS-MSGBAS,R0
	JSR	PC,OUTSTR
.ENDC	;..SAT
TABX2:	BR	TABX

;HERE TO REMOVE SYMBOL FROM THE SYMBOL TABLE *** $K ***

RMVSYM:	.IF EQ	..SAT
	JSR	PC,GETX50		;GET SYMBOL
	BCS	SYNER2			;IF ERROR
	MOV	FSTSYM,R3		;ONLY SEARCH IN CURRENTLY OPEN PROGRAM
	MOV	LSTSYM,R2
RMVSY2:	ADD	#.SYSIZ,R3		;BUMP POINTER
	CMP	R2,R3			;FINISHED
	BHIS	RMVSY3			;NO-GO ON
UDFSYM:	MOV	#UNDFMS-MSGBAS,R0	;YES-COMPLAIN
	JSR	PC,OUTSTR
	BR	TABX

RMVSY3:	CMP	R4,(R3)			;NO-THIS SYMBOL?
	BNE	RMVSY2			;NO
	CMP	R5,.SYNM2(R3)
	BNE	RMVSY2			;NO
RMVSY4:	MOV	SYMPNT,R5		;GET ADDRESS OF START OF TABLE
	MOV	(R5),R0			;GET COUNT
	MOV	R3,R4
	SUB	R5,R3			;CALCULATE NUMBER TO MOVE
	CLR	R2
	DIV	#.SYSIZ,R2
	SUB	R2,R0
	DEC	R0
	BEQ	TABX			;IF NOTHING AT ALL TO MOVE
	MUL	#.SYSIZ/2,R0		;CHANGE TO WORDS
	MOV	R4,R2
	ADD	#.SYSIZ,R2
RMVSY5:	MOV	(R2)+,(R4)+		;COPY WORD
	SOB	R1,RMVSY5		;LOOP IF MORE
	DEC	(R5)+			;FIX UP THE COUNTS
	INC	(R5)
	SUB	#.SYSIZ,LSTSYM
.ENDC	;..SAT
	BR	TABX			;FINISHED
	.PAGE
	.SBTTL	XDT2 - BREAKPOINT COMMANDS

;HERE TO SET A BREAKPOINT *** $B ***

SETBPS:	TSTB	BUFFER			;ARGUMENT?
	BLE	SYNER2			;NO-ERROR
	MOV	WORD1,R0		;GET ADDRESS
	JSR	PC,FNDBKP		;ALREADY HAVE A BREAKPOINT HERE?
	BCC	SETBP2			;YES-DON'T PUT IT IN AGAIN
	CLR	R0			;NO-LOOK FOR FIRST HOLE IN THE TABLE
	JSR	PC,FNDBKP
	BCS	BKPERR			;IF TABLE IS FULL
SETBP2:	PUSH	R1			;SAVE LOCATION IN TABLE
	MOV	WORD1,R1		;GET ADDRESS
	MOV	BITS1,R2		;GET BITS
	TBBE	$AC,R2,SETBP4		;AC NUMBER?
	BIS	#100,R1			;YES-MAKE THE ADDRESS ILLEGAL
SETBP4:	JSR	PC,REDWRD		;GET CONTENTS
	POP	R2			;RESTORE INDEX
	BCS	TABX			;DON'T SET BREAKPOINT IF BAD ADDRESS
	MOV	WORD1,(R2)		;STORE ADDRESS
	MOV	R1,BKPINS-BKPADR(R2)	;STORE CONTENTS
	CLR	BKPCNT-BKPADR(R2)	;CLEAR COUNT
	BR	TABX			;CONTINUE

;HERE IF BREAKPOINT ERROR (TABLE FULL OR NO SUCH BREAKPOINT)

BKPERR:	MOV	#BKERMS-MSGBAS,R0	;COMPLAIN
	JSR	PC,OUTSTR
	BR	TABX

;HERE TO REMOVE A BREAKPOINT *** $R ***

RMVBPS:	TSTB	BUFFER			;ARGUMENT GIVEN?
	BLE	RMVABP			;NO-REMOVE ALL BREAKPOINTS
	MOV	WORD1,R0		;YES-SEARCH FOR BREAKPOINT AT THIS ADDRESS
	JSR	PC,FNDBKP
	BCS	BKPERR			;IF NOT IN TABLE
	CLR	(R1)			;CLEAR TABLE ENTRY
	BR	TABX			;CONTINUE

SYNER2:	JMP	SYNERR

;HERE TO REMOVE ALL BREAKPOINTS

RMVABP:	.IF EQ	..PIC
	MOV	#BKPADR,R1
.IFF
	MOV	#<BKPADR-1$>,R1		;GET ADDRESS OF TABLE
	ADD	PC,R1
.ENDC
1$:	MOV	#NUMBKP,R2		;AND GET COUNT
2$:	CLR	(R1)+			;CLEAR ENTRY
	SOB	R2,2$			;LOOP IF MORE TO CLEAR
TABX:	JSR	PC,TAB
READY7:	JMP	READY
	.PAGE
	.SBTTL	XDT2 - PROGRAM CONTROL COMMANDS

;HERE TO PROCEED FROM A BREAKPOINT *** $P ***

PRCEED:	CLR	WORD1			;DEFAULT IS 0
	JSR	PC,ITEM			;GET VALUE
	BCS	READ6S			;IF ERROR
	JSR	PC,CRLF
	MOV	ACSAV7,R0		;GET ADDRESS
	JSR	PC,FNDBKP		;GET INDEX FOR THE BREAKPOINT
	BCS	PRCED0			;WILL HAPPEN IF USER PROCEEDS AFTER
					;  SINGLE STEPPING
	MOV	WORD1,BKPCNT-BKPADR(R1)	;SET COUNT
PRCED0:	.IF EQ	..PIC
	MOV	#PRCED2,R0
.IFF
	MOV	#<PRCED2-PRCED1>,R0	;GET TRAP ADDRESS
PRCEDX:	ADD	PC,R0
.ENDC
PRCED1:	TST	ACSAV7			;IS THERE AN ADDRESS?
	BEQ	2$			;NO-FAIL
	BIT	#1,ACSAV7		;YES-IS IT A WORD ADDRESS?
	BEQ	PRCED3			;YES-ITS OK
2$:	MOV	#CNPRMS-MSGBAS,R0	;NO-COMPLAIN
PRCEDE:	JSR	PC,OUTSTR
	JMP	READYC

PRCED3:	PUSH	#340			;PUT NEW PSW ON THE STACK
	CALL	SETPSW			;SET NEW PSW
	MOV	R0,BRKDSP		;STORE TRAP ADDRESS
	MOV	ACSAV0,R0		;RESTORE USER AC'S
	MOV	ACSAV1,R1
	MOV	ACSAV2,R2
	MOV	ACSAV3,R3
	MOV	ACSAV4,R4
	MOV	ACSAV5,R5
.IF EQ ..CTY
	MOV	SAVSTS,@#.JBSTS		;RESTORE USER STATUS WORD
.IFF
	MOV	SAVKEY,@#177560		;RESTORE CTY KEYBOARD STATUS
	MOV	SAVXMT,@#177564		;RESTORE CTY OUTPUT STATUS
.ENDC
	PUSH	UPSW			;GET USER PSW
	BIS	#360,(SP)		;SET THE TRACE TRAP BIT AND LOCK OUT
					;  INTERRUPTS FOR ONE INSTRUCTION!
	PUSH	ACSAV7			;GET PC ON THE STACK
	BIC	#$ACTIV,FLAG1		;INDICATE XDT NOT ACTIVE NOW
	RTT				;DISMISS FOR ONE INSTRUCTIN

;HERE AFTER EXECUTING THE FIRST INSTRUCTION AFTER THE BREAKPOINT

PRCED2:	PUSH	R0			;FREE UP SOME AC'S
	PUSH	R1
	PUSH	R2
	PUSH	R3
	PUSH	R4
.IF EQ	..PIC
	MOV	#BKPADR,R3
.IFF
	MOV	#<BKPADR-2$>,R3		;SET POINTER
	ADD	PC,R3
.ENDC
2$:	CLR	R2			;CLEAR ADDRESS BITS
	MOV	#NUMBKP,R4		;SET COUNTER
PRCED4:	MOV	(R3)+,R1		;IS THIS ONE IN USE?
	BEQ	PRCED6			;NO
	JSR	PC,REDWRD		;YES-GET THE USER'S INSTRUCTION
	MOV	R0,BKPINS-BKPADR-2(R3)	;SAVE IT
	MOV	#3,R0			;REPLACE IT WITH A "BPT" INSTRUCTION
	JSR	PC,WRTWRD
PRCED6:	SOB	R4,PRCED4		;LOOP IF MORE
.IF EQ	..PIC
	MOV	#BRKPNT,BRKDSP
.IFF
	MOV	#<BRKPNT-2$>,R4		;SET TRAP VECTOR FOR BREAKPOINT ROUTINE
	ADD	PC,R4
2$:	MOV	R4,BRKDSP
.ENDC
	POP	R4			;RESTORE AC'S
	POP	R3
	POP	R2
	POP	R1
	POP	R0
;	BIT	#$NSMMU,NODSTS#		;HAS THE MMU BEEN TURNED ON
;	BEQ	4$			;NO
;	MOV	#1,@#177572		;TURN IT ON
;	NXMJMP	4$			;IGNORE NXM IF NODSTS HAS BEEN CORRUPTED
4$:	BIC	#360,2(SP)		;CLEAR INTERRUPT LEVEL AND T BIT
	BIC	#^C340,UPSW		;CLEAR ALL SAVED BITS BUT INTERRUPT LEVEL
	BIS	UPSW,2(SP)		;RESTORE USERS INTERRUPT LEVEL
SETPSW:	RTI				;RETURN TO USER

;HERE TO EXECUTE ONE INSTRUCTION *** $E ***

SNGSTP:	CLR	WORD1			;DEFAULT IS 0
	JSR	PC,ITEM			;GET ARGUMENT
READ6S:	BCS	READC6			;IF ERROR
	JSR	PC,CRLF
	MOV	WORD1,SNGCNT		;STORE REPEAT COUNT
SNGST0:	.IF EQ	..PIC
	MOV	#SNGST2,R0
	BR	PRCED1
.IFF
	MOV	#<SNGST2-PRCED1>,R0	;GET TRACE TRAP VECTOR
	BR	PRCEDX			;OTHERWISE JUST LIKE DISMISSING A
					;  BREAKPOINT
.ENDC

;HERE AFTER EXECUTING ONE INSTRUCTION

SNGST2:	CALL	USRSVX			;SAVE USER'S STUFF
	DEC	SNGCNT			;WANT TO DO MORE?
	BGT	SNGST0			;YES
	MOV	#PRFXMS-MSGBAS,R0	;NO
	JSR	PC,OUTSTR
SNGST6:	MOV	#SNGIMS-MSGBAS,R0	;TELL HIM WHAT IS GOING ON
	BR	BRKPN3			;OTHERWISE JUST LIKE A BREAKPOINT

;HERE TO START PROGRAM AND EXECUTE A SINGLE INSTRUCTION *** $I ***

GOSNGL:	MOV	#20,R5			;PICK UP THE TRACE TRAP BIT
	CLR	SNGCNT			;CLEAR REPEAT COUNT
	BR	STRPR1			;CONTINUE

;HERE TO START PROGRAM *** $G ***

STRPRG:	CLR	R5			;NO TRACE TRAP BIT
STRPR1:	JSR	PC,CRLF
	TSTB	BUFFER			;WAS AN ARGUMENT TYPED?
	BLE	2$			;NO
	MOV	WORD1,R0		;YES-USE IT
	BR	4$

2$:	MOV	@#.JBSTA,R0		;NO-USE THE JOB'S STARTING ADDRESS
	BEQ	5$			;ERROR IF 0
4$:	BIT	#1,R0			;IS IT A WORD ADDRESS?
	BEQ	6$			;YES-GO ON
5$:	MOV	#BDSAMS-MSGBAS,R0	;NO-COMPLAIN
	JMP	PRCEDE

;HERE WITH VALID STARTING ADDRESS

6$:	MOV	R0,ACSAV7		;STORE
	BIC	#20,UPSW			;CLEAR THE TRACE TRAP BIT
	BIS	R5,UPSW			;AND SET IT IF WE WANT IT
	TST	R5			;SINGLE INSTRUCTION?
	BNE	12$			;YES
.IF EQ	..PIC
	MOV	#PRCED2,R0
10$:
.IFF
	MOV	#<PRCED2-11$>,R0	;NO-GET TRAP ADDRESS
10$:	ADD	PC,R0
.ENDC
11$:	JMP	PRCED3			;CONTINUE

;HERE IF ONLY WANTS ONE INSTRUCTION

12$:	.IF EQ	..PIC
	MOV	#SNGST2,R0
.IFF
	MOV	#<SNGST2-11$>,R0	;GET TRAP ADDRESS
.ENDC
	BR	10$			;CONTINUE
	.PAGE
;HERE WHENEVER BPT INSTRUCTION IS EXECUTED

BRKENT:	JMP	@BRKDSP			;JUMP TO ENTRY POINT
BRKPNT:	CALL	USRSAV			;SAVE USER'S STATE
;	BIT	#$NSMMU,NODSTS#		;IS THE MMU ACTIVE
;	BEQ	2$			;NO
;	CLR	@#177572		;TURN OFF PROTECTION
;	NXMJMP	2$			;IGNORE NXM IF NODSTS MESSED UP
2$:	CALL	BPTSET			;SETUP BREAKPOINTS
	SUB	#2,ACSAV7		;FIX UP THE PC
	MOV	ACSAV7,R0		;GET RETURN ADDRESS
	JSR	PC,FNDBKP		;IS THIS BREAKPOINT IN THE TABLE?
	BCC	BRKPN2			;YES
	MOV	#PRFXMS-MSGBAS,R0	;NO-START THE MESSAGE
	JSR	PC,OUTSTR
	MOV	#UKBPMS-MSGBAS,R0	;TELL HIM WHAT IS HAPPENING
	BR	BRKPN3

BRKPN2:	TST	BKPCNT-BKPADR(R1)	;IS THIS A NEGATIVE COUNT
	BGE	10$			;NO
	INC	BKPCNT-BKPADR(R1)	;REDUCE COUNT
	BGE	20$			;IF 0 THEN TYPE OUT ALL THE STUFF
	MOV	#7,R0			;OUTPUT A BELL
	CALL	PUTCCC
	BR	BRKPN5			;THEN PROCEED
10$:	DEC	BKPCNT-BKPADR(R1)	;REDUCE COUNT
	BGT	BRKPN5			;IF NOT 0, JUST PROCEED
20$:	CLR	BKPCNT-BKPADR(R1)	;MAKE SURE COUNT STAYS AT 0
	MOV	#PRFXMS-MSGBAS,R0	;START THE MESSAGE
	JSR	PC,OUTSTR
	MOV	#BKPTMS-MSGBAS,R0	;NORMAL MESSAGE
BRKPN3:	JSR	PC,OUTSTR
	MOV	ACSAV7,R1		;GET PC
	JSR	PC,TYPNMU		;TYPE IT
	MOV	#BKP2MS-MSGBAS,R0	;TYPE SOME MORE MESSAGE
	JSR	PC,OUTSTR
	MOV	UPSW,R1			;GET HIS PSW
	JSR	PC,TYPUNS		;TYPE IT
READC6:	JMP	READYC			;AND GO GET A COMMAND

BRKPN5:	JMP	PRCED0
	.PAGE
	.SBTTL	XDT2 - SUBROUTINES

;SUBROUTINE TO SAVE THE USER'S STATE WHEN ENTERING XDT
;	C((SP))   = PC
;	C((SP)+2) = PSW
;	JSR	PC,USRSAV
;  AT RETURN, 2 WORDS HAVE BEEN REMOVED FROM THE SACK

USRSVX:	BIC	#340,4(SP)		;CLEAR OUT INTERRUPT LEVEL
	BIC	#^C340,UPSW		;CLEAR ALL BUT INTERRUPT LEVEL
	BIS	UPSW,4(SP)		;MERGE BITS
USRSAV:	MOV	R0,ACSAV0		;STORE USER AC 0
.IF EQ	..PIC
	MOV	#ACSAV1,R0
.IFF
	MOV	#<ACSAV1-2$>,R0		;GET POINTER
	ADD	PC,R0
.ENDC
2$:	MOV	R1,(R0)+		;STORE REST OF USER AC'S
	MOV	R2,(R0)+
	MOV	R3,(R0)+
	MOV	R4,(R0)+
	MOV	R5,(R0)+
	POP	R5			;GET RETURN ADDRESS
	POP	ACSAV7			;STORE USER PC
	POP	UPSW			;STORE USER PSW
	BIC	#20,UPSW			;WITHOUT THE T BIT
	MOV	SP,(R0)			;STORE USER STACK POINTER
.IF EQ ..CTY
	MOV	@#.JBSTS,SAVSTS		;STORE USER STATUS WORD
	BIS	#$JSBAC+$JSLC,@#.JBSTS	;AND SET THE STATUS BITS WE NEED
.IFF
	MOV	@#177560,SAVKEY		;SAVE CTY KEYBOARD STATUS
	CLR	@#177560		;DISABLE CTY KEYBOARD INTERRUPT
	MOV	@#177564,SAVXMT		;SAVE CTY OUTPUT STATUS
	CLR	@#177564		;DISABLE CTY OUTPUT INTERRUPT
.ENDC
	BIS	#$ACTIV,FLAG1		;INDICATE XDT IS ACTIAVE NOW
	JMP	(R5)			;RETURN
					;  TO WHAT IT WAS BEFORE THE TRAP

;SUBROUTINE TO SETUP BREAKPOINTS
;	CALL	BPTSET

BPTSET:	MOV	#NUMBKP,R4		;SET COUNTER
.IF EQ	..PIC
	MOV	#BKPADR,R3
.IFF
	MOV	#<BKPADR-2$>,R3		;SET POINTER
	ADD	PC,R3
.ENDC
2$:	CLR	R2			;CLEAR ADDRESS BITS
BPTSE2:	MOV	(R3)+,R1		;IS THIS BREAKPOINT DEFINED?
	BEQ	BPTSE4			;NO-GO ON
	MOV	BKPINS-BKPADR-2(R3),R0	;YES-GET INSTRUCTION
	JSR	PC,WRTWRD		;AND STORE IT IN MEMORY
BPTSE4:	SOB	R4,BPTSE2		;LOOP IF MORE
	RETURN				;FINISHED

;SUBROUTINE TO FIND ENTRY IN BREAKPOINT TABLE
;	C(R0) = VALUE TO SEARCH FOR
;	JSR	PC,FNDBKP
;	C:SET = NOT FOUND
;	C(R1) = ADDRESS OF ENTRY

FNDBKP:	.IF EQ	..PIC
	MOV	#BKPADR,R1
.IFF
	MOV	#<BKPADR-1$>,R1		;SET POINTER
	ADD	PC,R1
.ENDC
1$:	MOV	#NUMBKP,R2		;SET COUNTER
2$:	CMP	(R1)+,R0		;THIS ONE?
	BEQ	6$			;IF SAME
	SOB	R2,2$			;LOOP IF MORE TO CHECK
	BR	RT1CS9			;GIVE ERROR RETURN

6$:	TST	-(R1)			;DECREMENT ADDRESS AND CLEAR C
	RTS	PC

;SUBROUTINE TO FETCH RADIX-50 SYMBOL
;	JSR	PC,GETX50
;	C:SET = ERROR
;	C(R4) = FIRST WORD
;	C(R5) = SECOND WORD

GETX50:	JSR	PC,GETCHU		;GET A CHARACTER
	CMP	#'A,R0			;IS IT A LETTER?
	BGT	GETX5B			;NO
	CMP	#'Z,R0
	BGE	GETX5C			;YES
GETX5B:	CMP	#'.,R0			;SPECIAL CHARACTER?
	BEQ	GETX5C			;YES
	CMP	#'$,R0
	BNE	RT1CS9			;NO-ERROR
GETX5C:	DEC	BUFPNT			;PUT THE CHARACTER BACK
	JSR	PC,GETR50		;GET THE SYMBOL
	BCS	RT1009			;IF ERROR
	TST	R0			;ANYTHING AFTER THE SYMBOL?
	BGT	RT1CS9			;YES-ERROR
	CMP	#^R.  ,R4		;RESERVED SYMBOL?
	BNE	RT1CC9			;NO-OK
RT1CS9:	SEC
RT1009:	RTS	PC

RT1CC9:	CLC				;CLEAR ERROR FLAG
	RETURN				;RETURN
	.PAGE

	.SBTTL	XDT3 - OUTPUT SUBROUTINES

;SUBROUTINE TO TYPE ADDRESS OF LOCATION
;	C(ADDRES) = ADDRESS
;	JSR	PC,TYPADR

TYPADR:	MOV	ADDRES,R1		;GET ADDRESS
	TBBE	$AC,BITSA,TYPAD1	;IS THIS AN AC ADDRESS?
	JSR	PC,TYPAC		;YES-HANDLE THAT CASE
	BR	TYPAD2

;HERE IF ADDRESS IS NOT AC NUMBER

TYPAD1:	JSR	PC,TYPSYM		;TRY TO TYPE AS SYMBOLIC
	BEQ	TYPAD2			;IF EXACT VALUE TYPED
	JSR	PC,TYPUNS		;TYPE NUMERIC PART
TYPAD2:	TBBN	$AC,BITSA,2$		;IS AN AC OPEN?
	TBBN	$BYTE,FLAGT,TYPAD3	;NO-IS A BYTE OPEN?
	TBBN	$INSTR,FLAGT,TYPAD4	;NO-IS IT OPEN AS AN INSTRUCTION?
2$:	MOV	#'[,R0			;NO-ITS OPEN AS DATA
	BR	TYPAD6

;HERE IF BYTE IS OPEN NOW

TYPAD3:	MOV	#'\,R0
	BR	TYPAD6

;HERE IF WORD OPEN AS INSTRUCTION

TYPAD4:	MOV	#'/,R0			;TYPE "/" AS FINAL CHARACTER
TYPAD6:	JMP	PUTCCC			;AND RETURN

;SUBROUTINE TO TYPE LOCATION AS AN INSTRUCTION
;	C(ADDRES) = ADDRESS OF LOCATION
;	JSR	PC,TYPINS
;	C:SET = ERROR

TYPINS:	CLR	FLAGW			;CLEAR BITS
	MOV	#2,SIZEC		;ASSUME 2 WORD INSTRUCTION
	MOV	ADDRES,R1		;GET FIRST (MAYBE ONLY) WORD
	MOV	BITSA,R2
	JSR	PC,REDWRD		;READ MEMORY
	BCS	RT1009			;IF ERROR
	MOV	R0,R5			;GET IN RIGHT AC
	MOV	R0,INSWRD		;AND SAVE IT FOR LATER
	CLR	R4			;GET FIRST 4 BITS
.IF NE ..EIS
	ASHC	#4,R4
.IFF
	ROL	R5
	ROL	R4
	ROL	R5
	ROL	R4
	ROL	R5
	ROL	R4
	ROL	R5
	ROL	R4
.ENDC
.IF EQ	..PIC
	ADD	#ST,R4
.IFF
	ADD	#<ST-2$>,R4
	ADD	PC,R4
.ENDC
2$:	MOVB	(R4),R3			;GET LEVEL 0 INDEX
	BLE	TYPIN2			;IF HAVE SYMBOL ENTRY
	ASL	R3
	CLR	R4			;GET NEXT 4 BITS
.IF NE ..EIS
	ASHC	#4,R4
.IFF
	ROL	R5
	ROL	R4
	ROL	R5
	ROL	R4
	ROL	R5
	ROL	R4
	ROL	R5
	ROL	R4
.ENDC
	ADD	R4,R3
.IF EQ	..PIC
	ADD	#STBGN-2,R3
.IFF
	ADD	#<STBGN-2-4$>,R3
	ADD	PC,R3
.ENDC
4$:	MOVB	(R3),R3			;GET LEVEL 1 INDEX
	BLE	TYPIN2			;IF HAVE SYMBOL ENTRY
	ASL	R3
	CLR	R4			;GET NEXT 2 BITS
.IF NE ..EIS
	ASHC	#2,R4
.IFF
	ROL	R5
	ROL	R4
	ROL	R5
	ROL	R4
.ENDC
	ADD	R4,R3
.IF EQ	..PIC
	ADD	#STBGN-2,R3
.IFF
	ADD	#<STBGN-2-6$>,R3
	ADD	PC,R3
.ENDC
6$:	MOVB	(R3),R3			;GET LEVEL 2 INDEX
	BLE	TYPIN2			;IF HAVE SYMBOL ENTRY
TYPIN1:	ASL	R3
	CLR	R4			;GET NEXT 3 BITS
.IF NE ..EIS
	ASHC	#3,R4
.IFF
	ROL	R5
	ROL	R4
	ROL	R5
	ROL	R4
	ROL	R5
	ROL	R4
.ENDC
	ADD	R4,R3
.IF EQ	..PIC
	ADD	#STBGN-2,R3
.IFF
	ADD	#<STBGN-2-10$>,R3
	ADD	PC,R3
.ENDC
10$:	MOVB	(R3),R3			;GET INDEX
	BGT	TYPIN1			;IF NEED TO GO ANOTHER LEVEL
TYPIN2:	BEQ	TYPIN4			;IF NO SUCH INSTRUCTION DEFINED
	MUL	#10,R3			;CALCULATE ADDRESS OF SYMBOL DATA
.IF EQ	..PIC
	ADD	#INBGN+2000,R3
.IFF
	ADD	#<INBGN+2000-2$>,R3
	ADD	PC,R3
.ENDC
2$:	TBBN	$NOOUP,FLAG1,4$		;IF DON'T WANT OUTPUT HERE
	JSR	PC,X50OUT		;TYPE RADIX 50 NAME
	MOV	(R3),R3			;GET INDEX FOR DISPATCH TABLE
	BR	6$

4$:	MOV	4(R3),R3		;GET INDEX
.IF EQ	..PIC
6$:	ADD	#OUTTBL,R3
	JMP	@(R3)
OUTBAS=!0
.IFF
6$:	ADD	#<OUTTBL-10$>,R3	;DISPATCH TO ROUTINE TO TYPE ADDRESS
	ADD	PC,R3			;  FIELDS (IF ANY)
10$:	MOV	(R3),R3			;GET ADDRESS
	ADD	PC,R3			;FIX IT UP
OUTBAS:	JMP	(R3)			;DISPATCH
.ENDC

;HERE IF INSTRUCTION IS NOT DEFINED

TYPIN4:	TBBN	$NOOUP,FLAG1,RT2CC3	;FINISHED IF DON'T WANT OUTPUT
	MOV	ADDRES,R1		;GET ADDRESS IN RIGHT AC
	MOV	BITSA,R2		;AND GET BITS
	JSR	PC,REDWRD		;GET CONTENTS
	MOV	R0,DSTFLD		;STORE AS DST FIELD
	MOV	#$DSTOK,FLAGW
	MOV	R0,R1			;GET IN RIGHT AC
					;AND FALL INTO TYPNUM TO OUTPUT IT

;SUBROUTINE TO TYPE NUMERIC VALUE IN CURRENT RADIX
;	C(R1) = NUMBER TO TYPE
;	JSR	PC,TYPNUM

TYPNUM:	TBBN	$UT,FLAGT,TYPNM9	;$UT MUST OVERRIDE $A AND $5!
	TBBN	$GT,FLAGT,TYPNMX	;DITTO FOR $GT
	TBBN	$A+$5,FLAGT,TYPALP	;IF WANT ALPHA OUTPUT
TYPNMX:	TBBN	$U+$UT,FLAGT,TYPNM9	;IF WANT UNSIGNED OUTPUT
	JSR	PC,TYPSYM		;TYPE AS SYMBOL
	BEQ	RT2CC3			;IF EXACT VALUE TYPED
TYPNM0:	PUSH	R2			;RESPECT R2
	PUSH	R3			;AND R3
	MOV	R1,R3			;COPY VALUE
	BGE	TYPNM1			;IF POSITIVE
	NEG	R3			;NEGATIVE
	MOV	#'-,R0
	JSR	PC,PUTCCC
TYPNM1:	CLR	R1			;CLEAR DIGIT COUNT
2$:	CLR	R2			;GET NEXT DIGIT
	DIV	RADIXT,R2
	PUSH	R3			;SAVE DIGIT
	INC	R1			;AND COUNT IT
	MOV	R2,R3			;FINISHED?
	BNE	2$			;NO
4$:	POP	R0			;YES-GET DIGIT
	CMP	#11,R0			;REAL DIGIT?
	BGE	6$			;YES
	ADD	#7,R0			;NO-MUST BE HEX-FIX IT UP
6$:	ADD	#'0,R0			;CONVERT TO ASCII
	JSR	PC,PUTCCC		;TYPE IT
	SOB	R1,4$			;IF MORE
	CMP	#12,RADIXT		;DECIMAL NUMBER?
	BNE	10$			;NO-GO ON
	MOV	#'.,R0			;YES-END IT WITH "."
	JSR	PC,PUTCCC
10$:	POP	R3			;RESTORE R3
	POP	R2			;RESTORE R2
RT2CC3:	CLC
RT2003:	RTS	PC			;FINISHED

;HERE IF WANT ALPHA OUTPUT

TYPALP:	TBBE	$OPEN,FLAG1,TYPAS1	;GO ON IF LOCATION NOT OPEN
	TBBE	$BYTE,FLAGT,TYPAS1	;OR IF NOT OPEN AS BYTE
	BIC	#^C377,R1		;BYTE-REMOVE JUNK
TYPAS1:	TBBN	$5,FLAGT,TYPR50		;IF WANT RADIX 50 OUTPUT
	BIT	#^C377,R1		;HAVE 2 CHARACTERS?
	BEQ	TYPAS2			;NO-GO ON
	PUSH	R1			;YES-SAVE SECOND
	JSR	PC,TYPAS2		;TYPE FIRST
	POP	R1			;GET SECOND
	SWAB	R1
TYPAS2:	BIC	#^C377,R1		;REMOVE JUNK
	BIT	#200,R1			;IS THE 8TH BIT SET?
	BNE	TYPAS4			;YES-TYPE LIKE CONTROL CHARACTER
	CMP	#SPA,R1			;NO-PRINTING CHARACTER?
	BGT	TYPAS4			;NO
	CMP	#177,R1
	BEQ	TYPAS4
	MOV	R1,R0			;YES-JUST TYPE IT
TYPAS3:	JSR	PC,PUTCCC
	BR	RT2CC3

;HERE IF NOT A PRINTING CHARACTER

TYPAS4:	MOV	#LA,R0			;START WITH LEFT ANGLE
	JSR	PC,PUTCCC
	JSR	PC,TYPNM0		;THEN THE VALUE
	MOV	#RA,R0			;FINISH WITH RIGHT ANGLE
	BR	TYPAS3

;HERE TO TYPE VALUE AS RADIX 50 CHARACTERS

TYPR50:	JSR	PC,TYPR5A		;TYPE INITIAL DELIMITER
	MOV	R1,R5			;GET IN RIGHT AC
	MOV	SP,R1			;INSURE R1 NOT 0
	JSR	PC,X50OU2		;TYPE IT
TYPR5A:	MOV	#'/,R0			;TYPE DELIMITER
	BR	TYPAS3			;AND RETURN

;SUBROUTINE TO TYPE UNSIGNED NUMBER
;	C(R1) = NUMBER TO TYPE
;	JSR	PC,TYPNMU

TYPNMU:	TBBN	$G+$GT,FLAGT,TYPNMX	;IF WANT SIGNED NUMBERS
TYPNM9:	JSR	PC,TYPSYM		;TYPE AS SYMBOL IF POSSIBLE
	BEQ	RT2CC3			;IF FINISHED NOW
	TBBE	$OPEN,FLAG1,TYPUNS	;GO ON IF NO LOCATION OPEN
	TBBE	$BYTE,FLAGT,TYPUNS	;OR THIS IS NOT A BYTE
	BIC	#^C377,R1		;BYTE-JUST 8 BITS
TYPUNS:	PUSH	R2			;SAVE AC'S
	PUSH	R3
	MOV	R1,R3			;COPY VALUE
	BR	TYPNM1			;GO TO COMMON ROUTINE

;SUBROUTINE TO TYPE AC NUMBER
;	C(R1) = AC NUMBER
;	JSR	PC,TYPAC

TYPAC:	JSR	PC,TYPSAC		;TRY TO TYPE AS SYMBOL
	BEQ	6$			;IF COMPLETELY FINISHED
	BCC	4$			;IF PARTLY FINISHED
	TBBN	$NOPCT,FLAG1,4$		;WANT "%" FIRST?
	MOV	#'%,R0			;YES
	JSR	PC,PUTCCC
4$:	JSR	PC,TYPUNS		;AND GO TYPE NUMBER
6$:	BIC	#$NOPCT,FLAG1		;CLEAR FLAG
	BR	RT2CC3			;FINISHED
	.PAGE
;SUBROUTINE TO TYPE AC NUMBER AS SYMBOLIC
;	C(R1) = VALUE TO TYPE
;	JSR	PC,TYPSAC
;	Z:SET = FINISHED
;	C:SET = NO MATCH FOUND
;	C(R1) = REMAINDING VALUE TO TYPE

TYPSAC:	MOV	#$AC,R5			;INDICATE VALUE IS AC NUMBER
	BR	TYPSY0			;CONTINUE

;SUBROUTINE TO TYPE VALUE AS SYMBOLIC
;	C(R1) = VALUE TO TYPE
;	JSR	PC,TYPSYM
;	Z:SET = FINISHED
;	C:SET = NO MATCH FOUND
;	C(R1) = REMAINDING VALUE TO TYPE

TYPSYM:	CLR	R5			;INDICATE VALUE NOT AC NUMBER
TYPSY0:	SEC				;RETURN WITH C SET IF DON'T SYMBOL HERE
.IF EQ	..SAT
	TBBN	$N+$UT+$GT,FLAGT,RT2006	;IF DON'T WANT SYMBOLIC OUTPUT
	PUSH	R2			;RESPECT R2 AND R3
	PUSH	R3
	MOV	#177777,BSTDIF
	CLR	BSTSYM
	MOV	SYMPNT,R3		;GET POINTER TO SYMBOL TABLE
	BEQ	TYPSNO			;IF NO SYMBOLS LOADED
	MOV	(R3)+,R4		;GET SIZE OF SYMBOL TABLE
	TST	(R3)+			;POINT TO FIRST ENTRY
TYPSY2:	TST	(R3)			;NULL SYMBOL?
	BEQ	TYPSY6			;YES-IGNORE IT (MUST BE BAD SYMBOL
					;  TABLE!)
	MOV	.SYBTS(R3),R0		;GET FLAGS FOR SYMBOL
	XOR	R5,R0			;IS AC FLAG RIGHT FOR WHAT WE WANT?
	TBBN	$AC+$PRGM+$SUPR,R0,TYPSY6;GO ON IF NOT OR IF PROGRAM NAME OR
					 ;  IF SUPPRESSED SYMBOL
	MOV	.SYVAL(R3),R2		;IS VALUE SAME SIGN AS SYMBOL?
	XOR	R1,R2
	BMI	TYPSY6			;FORGET THIS SYMBOL IF NOT
	MOV	R1,R2			;GET DIFFERENCE
	SUB	.SYVAL(R3),R2
	BLT	TYPSY6			;SYMBOL IS TOO LARGE
	CMP	OFFSET,R2		;IS DIFFERENCE TOO LARGE?
	BLT	TYPSY6			;YES-GO ON
	TBBN	$GLBL,.SYBTS(R3),TYPSY4	;IF THIS IS A GLOBAL SYMBOL
	CMP	FSTSYM,R3		;IS IT A LOCAL SYMBOL?
	BHI	TYPSY5			;NO
	CMP	LSTSYM,R3
	BLO	TYPSY5			;NO-GO HANDLE IT

;HERE WITH LOCAL SYMBOL

	TST	R2			;EXACT MATCH?
	BEQ	TYPSY8			;YES
TYPSY4:	CMP	BSTDIF,R2		;BEST SO FAR?
	BLOS	TYPSY6			;NO-GO ON
	MOV	R2,BSTDIF		;YES-REMEMBER IT AS NEW BEST
	MOV	R3,BSTSYM
	BR	TYPSY6			;CONTINUE

;HERE WITH NON-LOCAL, NON-GLOBAL SYMBOL

TYPSY5:	TST	R2			;EXACT MATCH?
	BEQ	TYPSY4			;YES
TYPSY6:	ADD	#.SYSIZ,R3		;BUMP POINTER
	SOB	R4,TYPSY2		;CONTINUE IF MORE TO CHECK
	MOV	BSTSYM,R3		;GET ADDRESS OF SYMBOL
	BNE	TYPSY9			;GO ON IF WE FOUND ONE
TYPSNO:	POP	R3			;FAILURE-RESTORE R3 AND R2
	POP	R2
	SEC				;INDICATE FAILURE
.ENDC	;..SAT
	CLZ
RT2006:	RTS	PC			;AND RETURN

;HERE IF EXACT MATCH ON LOCAL SYMBOL

.IF EQ	..SAT
TYPSY8:	CLR	BSTDIF			;CLEAR DIFFERENCE

;HERE WITH SYMBOL TO TYPE

TYPSY9:	PUSH	R3			;SAVE ADDRESS OF TABLE ENTRY
	JSR	PC,X50OUT		;TYPE IT
	POP	R3
	TBBN	$GLBL,.SYBTS(R3),4$	;GO ON IF GLOBAL SYMBOL
	CMP	FSTSYM,R3		;LOCAL SYMBOL?
	BHI	2$			;NO
	CMP	LSTSYM,R3
	BHIS	4$			;YES
2$:	MOV	#'#,R0			;NO-FLAG THIS AS NON-LOCAL SYMBOL
	JSR	PC,PUTCCC
4$:	POP	R3			;RESTORE R3 AND R2
	POP	R2
	MOV	BSTDIF,R1		;GET DIFFERENCE
	BEQ	RT2CC7			;IF EXACT MATCH FOUND
	MOV	#'+,R0			;NOT EXACT-TYPE "+"
	JSR	PC,PUTCCC
	CLZ
	BR	RT2CC7
.ENDC	;..SAT
	.PAGE
;FOLLOWING ROUTINES ARE CALLED TO TYPE THE SOURCE AND DESTINATION FIELDS
;  OF AN INSTRUCTION

;HERE FOR INSTRUCTIONS WITH SOURCE AND REGISTER FIELDS

RSSOUT:	MOV	INSWRD,R0		;GET INSTRUCTION WORD
	MOV	R0,R1			;IN 2 AC'S
	ASHI	6,R0			;PUT SOURCE FIELD IN RIGHT PLACE
	BIC	#^C7700,R0		;REMOVE JUNK
	ASHI	-6,R1			;PUT AC NUMBER IN DST FIELD
	BIC	#^C7,R1			;REMOVE JUNK
	BIS	R1,R0			;COMBINE FIELDS
	MOV	R0,INSWRD		;STORE MODIFIED FIELDS
	BR	SSDDOU			;CONTINUE WITH COMMON CODE

;HERE FOR INSTRUCTIONS WITH REGISTER AND DESTINATION FIELDS

RDDOUT:	BIC	#7000,INSWRD		;MAKE REGISTER FIELD LOOK RIGHT
					;FALL INTO SSDDOU

;HERE FOR 2 ADDRESS INSTRUCTIONS

SSDDOU:	JSR	PC,TAB1
	MOV	ADDRES,R3
	ADD	#2,R3
	MOV	INSWRD,R0		;GET SOURCE FIELD
	ASHI	-6,R0
	JSR	PC,ADRFLD		;TYPE THE FIELD
	BCS	RT2007
	MOV	R0,SRCFLD
	TBBN	$NOOUP,FLAG1,4$		;IF NO OUTPUT
	JSR	PC,COMMA		;OTHERWISE TYPE COMMA
4$:	MOV	#$SRCOK,FLAGW
	TBBE	$AC,R1,DSTFL2		;AC?
	BIS	#$SRCAC,FLAGW		;YES
	BR	DSTFL2


;HERE FOR INSTRUCTIONS WITH REGISTER FIELD ONLY

REGOUT:	BIC	#70,INSWRD		;MAKE FULL FIELD LOOK LIKE MODE 0
					;FALL INOT XXOUT ROUTINE

;HERE FOR DESTINATION ONLY OR SOURCE ONLY INSTRUCTIONS

XXOUT:	JSR	PC,TAB1
DSTFL1:	MOV	ADDRES,R3		;GET ADDRESS OF DESTINATION OPERAND
	ADD	#2,R3
DSTFL2:	MOV	INSWRD,R0		;GET DESTINATIN FIELD
	JSR	PC,ADRFLD		;TYPE DESTINATION FIELD
	BCS	RT2007			;IF ERROR
	MOV	R0,DSTFLD
	BIS	#$DSTOK,FLAGW
	TBBE	$AC,R1,RT2CC7		;AC?
	BIS	#$DSTAC,FLAGW		;YES
RT2CC7:	CLC
RT2007:	RTS	PC

;HERE FOR INSTRUCTIONS WITH A 6 BIT NUMERIC FIELD

NNOUT:	JSR	PC,TAB1
	BCS	RT2CC7			;IF NO OUTPUT
	MOV	INSWRD,R1		;GET INSTRUCTION
	BIC	#^C77,R1		;GET JUST THE FIELD
	BR	NNNOU5			;TYPE IT AND RETURN

;HERE FOR INSTRUCTIONS WITH A 8 BIT NUMERIC FIELD

NNNOUT:	JSR	PC,TAB1
	BCS	RT2CC7			;IF NO OUTPUT
	MOV	INSWRD,R1		;GET INSTRUCTIN
	BIC	#^C377,R1		;GET JUST THE FIELD
NNNOU5:	JSR	PC,TYPNMU		;TYPE IT
					;FALL INTO NONOUT TO SET SIZEC

;HERE FOR INSTRUCTIONS WITH NO OTHER FIELDS

NONOUT:	BR	RT2CC7

;HERE FOR BRANCH INSTRUCTIONS

BROUT:	JSR	PC,TAB1
	BCS	RT2CC7			;IF NO OUTPUT
	MOV	INSWRD,R1		;GET INSTRUCTION
	BIC	#^C377,R1		;GET JUST OFFSET PART
	ASL	R1			;TIMES 2
	BIT	#400,R1			;NEGATIVE VALUE?
	BEQ	BROUT2			;NO
	BIS	#177400,R1		;YES-EXTEND THE SIGN
BROUT2:	ADD	DOT,R1			;ADD IN CURRENT PC
	ADD	#2,R1
	MOV	R1,DSTFLD		;STORE AS VALUE
	MOV	#$DSTOK,FLAGW		;INDICATE HAVE VALUE
	BR	NNNOU5			;TYPE VALUE AND RETURN

;HERE FOR THE SOB INSTRUCTION

SOBOUT:	JSR	PC,TAB1
	BCS	RT2CC7			;IF NO OUTPUT
	MOV	INSWRD,R1		;GET INSTRUCTION
	ASHI	-6,R1			;GET AC FIELD
	BIC	#^C7,R1
	CALL	TYPAC			;TYPE AC FIELD
	CALL	COMMA
	MOV	INSWRD,R1		;GET INSTRUCTION AGAIN
	BIC	#^C77,R1		;GET JUST OFFSET FIELD
	ASL	R1			;TIMES 2
	NEG	R1			;MAKE NEGATIVE
	BR	BROUT2			;CONTINUE
	.PAGE
;SUBROUTINE TO TYPE INITIAL TAB AFTER OP-CODE FIELD
;	JSR	PC,TAB1
;	C:SET = NO OUTPUT WANTED

TAB1:	TBBN	$NOOUP,FLAG1,RT2CS8	;IF NO OUTPUT
	JSR	PC,TAB			;TYPE TAB
	BR	RT2CC8			;MAKE SURE C IS CLEAR

RT2CS8:	SEC
	RTS	PC

;SUBROUTINE TO TYPE SOURCE OR DESTINATION FIELD
;	C(R0) = 6 BIT SOURCE OR DESTINATION FROM INSTRUCTION WORD (RIGHT JUSTIFIED)
;	C(R3) = ADDRESS OF OPERAND
;	JSR	PC,ADRFLD
;	C:SET = ERROR
;	C(R0) = VALUE OF FIELD
;	C(R1) = STATUS BITS FOR FIELD
;	C(R2) = UNCHANGED
;	C(R3) = ADDRESS OF NEXT OPERAND

ADRFLD:	MOV	R0,R1			;SEPERATE REGISTER AND MODE
	ASHI	-3,R0
	BIC	#^C7,R0			;C(R0) = MODE
	BIC	#^C7,R1			;C(R1) = REGISTER
	ASL	R0			;FIX UP FOR WORD INDEXING
.IF EQ	..PIC
	ADD	#SIZTBL,R0
.IFF
	ADD	#<SIZTBL-2$>,R0
	ADD	PC,R0
.ENDC
2$:	CMP	#7,R1			;PC ADDRESSING?
	BNE	ADRFL1			;NO
	MOVB	(R0),R4			;YES-GET SIZE ADJUSTMENT
	MOV	ADRDPC-SIZTBL(R0),R0	;GET DISPATCH ADDRESS
	BR	ADRFL2			;CONTINUE

;HERE IF NOT PC ADDRESSING

ADRFL1:	MOVB	1(R0),R4		;GET SIZE ADJUSTMENT
	MOV	ADRDSP-SIZTBL(R0),R0	;GET DISPATCH ADDRESS
ADRFL2:	ADD	R4,SIZEC		;ADJUST THE INSTRUCTION SIZE
	TBBN	$NOOUP,FLAG1,RT2CC8	;FINISHED IF NO OUTPUT
.IF EQ	..PIC
	JMP	(R0)
ADRBAS=!0
.IFF
	ADD	PC,R0			;FIX UP THE ADDRESS
ADRBAS:	JMP	(R0)			;DISPATCH TO ROUTINE
.ENDC

;DISPATCH TABLE INDEXED ON ADDRESSING MODE (REGISTER = PC)

ADRDPC:	.WORD	MODE0-ADRBAS
	.WORD	MODE1-ADRBAS
	.WORD	MODEP2-ADRBAS
	.WORD	MODEP3-ADRBAS
	.WORD	MODE4-ADRBAS
	.WORD	MODE5-ADRBAS
	.WORD	MODEP6-ADRBAS
	.WORD	MODEP7-ADRBAS

;DISPATCH TABLE INDEXED ON ADDRESSING MODE (REGISTER NOT PC)

ADRDSP:	.WORD	MODE0-ADRBAS
	.WORD	MODE1-ADRBAS
	.WORD	MODE2-ADRBAS
	.WORD	MODE3-ADRBAS
	.WORD	MODE4-ADRBAS
	.WORD	MODE5-ADRBAS
	.WORD	MODE6-ADRBAS
	.WORD	MODE7-ADRBAS

;TABLE OF INSTRUCTION SIZE ADJUSTMENTS - THIS AMOUNT IS ADDED TO THE
;  CURRENT INSTRUCTION SIZE IN SIZEC - THE LOW ORDER BYTE IN EACH ENTRY IS
;  THE ADJUSTMENT FOR PC MODES, THE HIGH ORDER BYTE IS FOR NON-PC MODES

SIZTBL:	.BYTE	0,0			;MODE 0
	.BYTE	0,0			;MODE 1
	.BYTE	2,0			;MODE 2
	.BYTE	2,0			;MODE 3
	.BYTE	0,0			;MODE 4
	.BYTE	0,0			;MODE 5
	.BYTE	2,2			;MODE 6
	.BYTE	2,2			;MODE 7

;HERE FOR MODE 0 - REGISTER

MODE0:	PUSH	R1			;SAVE AC NUMBER
	CALL	TYPAC			;TYPE AC NUMBER
MODE0A:	MOV	#$AC,R1			;GET BITS FOR FIELD
MODE0B:	POP	R0			;GET VALUE OF FIELD
RT2CC8:	CLC
RT2008:	RTS	PC			;RETURN

;HERE FOR MODE 1 - REGISTER DEFERRED

MODE1:	PUSH	R1			;SAVE AC NUMBER
MODE1A:	JSR	PC,MODE1D		;OUTPUT "(REG)"
	BR	MODE0A			;CONTINUE

;SUBROUTINE TO OUTPUT "(REG)"
;	JSR	PC,MODE1D

MODE1D:	MOV	#'(,R0			;INCLOSE IT IN PARA.
	JSR	PC,PUTCCC
	BIS	#$NOPCT,FLAG1		;DON'T TYPE % BEFORE AC NUMBER
	CALL	TYPAC			;TYPE REGISTER NUMBER
	MOV	#'),R0
	JMP	PUTCCC			;OUTPUT AND RETURN

;HERE FOR MODE 3 - AUTO-INCREMENT DEFERRED

MODE3:	MOV	#'@,R0			;START OUT WITH "@"
	JSR	PC,PUTCCC		;FALL INTO MODE 2 ROUTINE

;HERE FOR MODE 2 - AUTO-INCREMENT

MODE2:	JSR	PC,MODE1		;ALMOST LIKE MODE 1
	PUSH	R0			;SAVE VALUE
	MOV	#'+,R0			;BUT ADD "+"
	JSR	PC,PUTCCC
	BR	MODE0B			;RESTORE VALUE AND RETURN

;HERE FOR MODE 5 - AUTO-DECREMENT DEFERRED

MODE5:	MOV	#'@,R0			;START OUT WITH "@"
	JSR	PC,PUTCCC		;FALL INTO MODE 4 ROUTINE

;HERE FOR MODE 4 - AUTO-DECREMENT

MODE4:	MOV	#'-,R0			;START OUT WITH "-"
	JSR	PC,PUTCCC
	BR	MODE1			;REST IS JUST LIKE MODE 1

;HERE FOR MODE 7 - INDEXED DEFERRED

MODE7:	MOV	#'@,R0			;START OUT WITH "@"
	JSR	PC,PUTCCC		;FALL INTO MODE 6 ROUTINE

;HERE FOR MODE 6 - INDEXED

MODE6:	PUSH	R1			;SAVE REGISTER NUMBER
	PUSH	R1			;PLUS AN EXTRA WORD ON THE STACK
	JSR	PC,GETVAL		;GET OFFSET
	BCS	MODE6X			;IF ERROR
	MOV	R1,2(SP)		;AND SAVE FOR LATER
	JSR	PC,TYPNUM		;TYPE NUMBER
	POP	R1			;GET REGISTER NUMBER
	JSR	PC,MODE1D		;TYPE "(REG)"
MODE6B:	POP	R0			;GET VALUE OF FIELD
	CLR	R1			;NO BITS
	BR	RT2CC8			;RETURN

;HERE IF ERROR REFERENCING MEMORY

MODE6X:	ADD	#4,SP			;FIX UP THE STACK
	SEC				;INDICATE ERROR
RT2010:	RTS	PC			;RETURN

;HERE FOR MODE 2 WITH PC - IMMEDIATE

MODEP2:	MOV	#'#,R0			;START OUT WITH "#"
	JSR	PC,PUTCCC
	JSR	PC,GETVAL		;GET VALUE
	BCS	RT2010			;IF ERROR
	PUSH	R1			;SAVE IT FOR LATER
	JSR	PC,TYPNUM		;TYPE AS SIGNED VALUE
	BR	MODE6B			;GO FINISH UP

;HERE FOR MODE 3 WITH PC - ABSOLUTE

MODEP3:	MOV	#MOD3MS-MSGBAS,R0	;START OUT WITH "@#"
	JSR	PC,OUTSTR
	JSR	PC,GETVAL		;GET VALUE
	BCS	RT2010			;IF ERROR
MODE3B:	PUSH	R1			;SAVE FOR LATER
	JSR	PC,TYPNMU		;TYPE IT
	BR	MODE6B			;CONTINUE

;HERE FOR MODE 7 WITH PC - RELATIVE DEFERRED

MODEP7:	MOV	#'@,R0			;START OUT WITH "@"
	JSR	PC,PUTCCC		;AND FALL INTO MODE 6 ROUTINE

;HERE FOR MODE 6 WITH PC - RELATIVE

MODEP6:	JSR	PC,GETVAL		;GET OFFSET
	BCS	RT2010			;IF ERROR
	ADD	DOT,R1			;PLUS ADDRESS
	ADD	SIZEC,R1
	BR	MODE3B			;CONTINUE
	.PAGE
;SUBROUTINE TO GET VALUE FROM MEMORY FOR THE FIELD OUTPUT ROUTINES
;	C(R3) = ADDRESS
;	JSR	PC,GETVAL
;	C:SET = ERROR
;	C(R1) = CONTENTS
;	C(R3) = C(R3) + 2

GETVAL:	MOV	R3,R1			;GET ADDRESS IN RIGHT AC
	CLR	R2			;CLEAR ADDRESS BITS
	JSR	PC,REDWRD		;GET WORD FROM MEMORY
	BCS	RT2005
	MOV	R0,R1			;GET CONTENTS IN RIGHT AC
	ADD	#2,R3			;BUMP ADDRESS
	CLC				;MAKE SURE CARRY IS CLEAR
RT2005:	RTS	PC			;RETURN

;SUBROUTINE TO TYPE 2 WORDS AS RADIX-50 WITH BLANKS SUPPRESSED
;	C(R3) = ADDRESS OF FIRST WORD TO TYPE
;	JSR	PC,X50OUT

X50OUT:	CLR	R1			;DON'T TYPE BLANKS
	MOV	(R3)+,R5		;GET FIRST WORD
	JSR	PC,X50OU2		;CONVERT IT
	MOV	(R3)+,R5		;GET SECOND WORD
X50OU2:	CLR	R4
	DIV	#50,R4			;GET LAST CHARACTER
	PUSH	R5			;SAVE IT
	MOV	R4,R5
	CLR	R4
	DIV	#50,R4			;GET NEXT TO LAST CHARACTER
	PUSH	R5
	JSR	PC,X50OU4		;OUTPUT THE FIRST CHARACTER
	POP	R4			;GET NEXT CHARACTER
	JSR	PC,X50OU4		;OUTPUT IT
	POP	R4			;GET LAST CHARACTER
X50OU4:	TST	R4			;SPACE?
	BNE	2$			;NO
	TST	R1			;YES-DO WE WANT IT?
	BEQ	RT2005			;NO-FINISHED
	BR	17$			;YES

;HERE IF NOT SPACE

2$:	CMP	#33,R4
	BGT	16$			;IF LETTER
	BEQ	14$			;IF $
	CMP	#35,R4
	BNE	15$			;IF DIGIT OR PERIOD
	ADD	#7,R4			;MINUS
14$:	ADD	#-11,R4			;$
15$:	ADD	#-56,R4			;DIGIT OR PERIOD
16$:	ADD	#40,R4			;LETTER
17$:	ADD	#40,R4			;SPACE
	MOV	R4,R0			;GET IN RIGHT AC
	JMP	PUTCCC			;OUTPUT CHARACTER AND RETURN
	.PAGE
;SUBROUTINE TO TYPE CR-LF
;	JSR	PC,CRLF

CRLF:	MOV	#CRLFM-MSGBAS,R0	;GET ADDRESS OF STRING
					;FALL INTO OUTSTR

;SUBROUTINE TO TYPE ASCII STRING
;	C(R0) = ADDRESS OF STRING
;	JSR	PC,OUTSTR

OUTSTR:	PUSH	R1			;SAVE AN AC
	MOV	R0,R1			;GET POINTER IN SAFE AC
.IF EQ ..PIC
MSGBAS=!0
.IFF
	ADD	PC,R1			;REMOVE OFFSET
MSGBAS:
.ENDC
10$:	MOVB	(R1)+,R0		;GET CHARACTER
	BEQ	4$			;IF FINISHED
	JSR	PC,PUTCCC		;OUTPUT THE CHARACTER
	BR	10$			;CONTINUE

;HERE WHEN FINISHED

4$:	POP	R1			;RESTORE R1
	RTS	PC			;RETURN

;SUBROUTINE TO TYPE TAB
;	JSR	PC,TAB

TAB:	MOV	#HT,R0
PUTCC0:	JMP	PUTCCC

;SUBROUTINE TO TYPE COMMA
;	JSR	PC,COMMA

COMMA:	MOV	#',,R0
	BR	PUTCC0
	.PAGE
;SUBROUTINE TO READ INPUT INTO THE INPUT BUFFER - THE INPUT IS DEFINED AS
;  A NUMBER OF CHARACTERS TERMINATED BY ONE OF THE ACTION CHARACTERS
;	JSR	PC,GETINP
;	C(R2) = DISPATCH INDEX

GETINP:	.IF EQ	..PIC
	MOV	#BUFFER,R1
.IFF
	MOV	#<BUFFER-2$>,R1		;GET POINTER TO BUFFER
	ADD	PC,R1
.ENDC
2$:	MOV	R1,BUFPNT		;SET POINTER FOR GETCHR
GETIN1:	JSR	PC,GETCCC		;GET CHARACTER
	CMP	#'_,R0			;IS IT UNDERLINE?
	BEQ	GETINU			;YES
	TBBE	$DLSEQ,FLAG1,GETIN2	;ARE WE IN A DELETE SEQUENCE NOW?
	PUSH	R0			;YES-SAVE CHARACTER
	MOV	#'\,R0			;TERMINATE THE DELETE SEQUENCE
	JSR	PC,PUTCCC
	BIC	#$DLSEQ,FLAG1
	POP	R0			;RESTORE CHARACTER
GETIN2:	CMP	#RUB,R0			;IS IT RUB-OUT?
	BEQ	GETINB			;YES
	CMP	#LF,R0			;IS IT LINE-FEED?
	BEQ	GETINF			;YES
	CMP	#ESC,R0			;IS IT ESC?
	BEQ	GETINE			;YES
	CMP	#CU,R0			;IS IT CONTROL-U?
	BEQ	GETICU			;YES
	JSR	PC,PUTCCC		;NO-ECHO IT
	CMP	#CR,R0			;IS IT RETURN?
	BEQ	GETINR			;YES
	CMP	#HT,R0			;HORIZONTAL TAB?
	BEQ	2$			;YES-THATS OK
	CMP	#SPA,R0			;SOME OTHER NON-PRINTING CHARACTER?
	BGT	ERRCHR			;YES
2$:	MOV	#NUMACT,R2		;NO-SET COUNTER
GETIN3:	.IF EQ	..PIC
	MOV	#ACTTBL-1,R3
.IFF
	MOV	#<ACTTBL-1-2$>,R3	;IS IT THIS CHARACTER?
	ADD	PC,R3
.ENDC
2$:	ADD	R2,R3
	CMPB	(R3),R0
	BEQ	GETIN4			;YES
	SOB	R2,GETIN3		;NO-LOOP IF MORE TO CHECK
	BR	GETIN5			;NOT ACTION CHARACTER-JUST STORE IT

;HERE IF WE HAVE AN ACTION CHARACTER

GETIN4:	ADD	#4,R2			;ADJUST FOR ENTIRES AT START OF
	ASL	R2			;  TABLE AND SET FOR WORD INDEXING
GETINX:	CLRB	(R1)			;PUT NULL AT END OF BUFFER
	RTS	PC			;RETURN

;HERE WITH ILLEGAL CHARACTER

ERRCHR:	MOV	#6,R2			;GET DISPATCH
	BR	GETINX			;GO STORE IT AND RETURN

;HERE WITH NORMAL CHARACTER

GETIN5:	MOVB	R0,(R1)+		;STORE IN BUFFER
	BR	GETIN1			;GO BACK FOR ANOTHER CHARACTER

;HERE WITH RETURN

.IF EQ ..CTY
GETINR:	JSR	PC,GETCCC		;GET CHARACTER
	CMP	#LF,R0			;LINE-FEED?
	BNE	GETINR			;NO-JUNK IT
.IFF
GETINR:	MOV	#LF,R0			;GET A LINE-FEED
.ENDC
	JSR	PC,PUTCCC		;YES-ECHO IT
	CLR	R2			;DISPATCH = 0
	BR	GETINX

;HERE WITH LINE-FEED

GETINF:	JSR	PC,CRLF			;ECHO AS CR-LF
	MOV	#2,R2			;DISPATCH = 2
	BR	GETINX

;HERE WITH ESC

GETINE:	MOV	#'$,R0			;ECHO AS "$"
	JSR	PC,PUTCCC
	MOV	#4,R2			;DISPATCH = 4
	BR	GETINX

;HERE WITH CONTROL-U

GETICU:	MOV	#CNTUMS-MSGBAS,R0	;ECHO AS " XXX"<TAB>
	JSR	PC,OUTSTR
	MOV	#10,R2			;DISPATCH = 10
	BR	GETINX

;HERE WITH RUB-OUT

GETINB:	.IF EQ	..PIC
	MOV	#BUFFER,R2
.IFF
	MOV	#<BUFFER-2$>,R2		;AT START OF BUFFER NOW?
	ADD	PC,R2
.ENDC
2$:	CMP	R2,R1
	BHIS	GETIN1			;YES-JUNK IT
	DEC	R1			;NO-BACK UP THE POINTER
	MOV	#BSSPBS-MSGBAS,R0	;ECHO A BACK-SPACE
	JSR	PC,OUTSTR
GETI1A:	BR	GETIN1			;CONTINUE

;HERE WITH UNDERLINE - DELETE CHARACTER WITH FUNNY ECHO

GETINU:	.IF EQ	..PIC
	MOV	#BUFFER,R1
.IFF
	MOV	#<BUFFER-2$>,R1		;AT BEGINNING OF BUFFER?
	ADD	PC,R2
.ENDC
2$:	CMP	R2,R1
	BHIS	GETIN9			;YES
	TBBN	$DLSEQ,FLAG1,GETIN7	;IN DELETE SEQUENCE NOW?
	MOV	#'\,R0			;NO-BUT WE ARE NOW?
	JSR	PC,PUTCCC
	BIS	#$DLSEQ,FLAG1
GETIN7:	MOVB	-(R1),R0		;GET PREVIOUS CHARACTER
	JSR	PC,PUTCCC		;ECHO IT
	BR	GETIN1			;CONTINUE

;HERE WITH UNDERLINE WHEN BUFFER IS EMPTY

GETIN9:	TBBE	$DLSEQ,FLAG1,GETIN1	;IGNORE IF NOT IN DELETE SEQUENCE NOW
	MOV	#'\,R0			;CLOSE OUT THE DELETE SEQUENCE
	JSR	PC,PUTCCC
	BIC	#$DLSEQ,FLAG1
	BR	GETI1A			;AND CONTINUE
	.PAGE
	.SBTTL	XDT3 - ACTION TABLE

;DEFINE MACRO FOR GENERATING THE ACTION CHARACTER TABLES

	.MACRO	ACTION
	XX	<'=> ,EQUALS		;RETYPE AS UNSIGNED NUMBER
	XX	<':> ,COLON		;RETYPE AS SIGNED NUMBER
	XX	<'/> ,SLASH		;OPEN INSTRUCTION
	XX	<'\> ,BCKSLH		;OPEN BYTE
	XX	<'^> ,OPNPRV		;OPEN PREVIOUS
	XX	<HT> ,INDIR1		;PUSH ADDRESS
	XX	<RA> ,INDIR2		;POP ADDRESS
	XX	<'[> ,OPNNUM		;OPEN WORD AS DATA
	XX	<';> ,RETYPE		;RETYPE VALUE
	.ENDM

;GENERATE THE ACTION CHARACTER TABLE

	.MACRO	XX A,B
	.BYTE	A
	.ENDM

ACTTBL:	ACTION
NUMACT=.-ACTTBL
	.EVEN

;GENERATE THE ACTION DISPATCH TABLE

	.MACRO	XX A,B
	.WORD	B-ACTBAS
	.ENDM

ACTDSP:	.WORD	CLSWRD-ACTBAS		;RETURN
	.WORD	OPNNXT-ACTBAS		;LINE-FEED
	.WORD	ESCAPE-ACTBAS		;ESC
	.WORD	SYNERR-ACTBAS		;ILLEGAL CHARACTER
	.WORD	READY-ACTBAS		;CONTROL-U
	ACTION				;ACTION CHARACTERS DEFINED ABOVE

	.PAGE
;SUBROUTINE TO GET CHARACTER FROM BUFFER
;	JSR	PC,GETCHR
;	C(R0) = ASCII CHARACTER

GETCHR:	MOVB	@BUFPNT,R0		;GET CHARACTER
	BLE	RT5CC8			;IF END OF BUFFER
	INC	BUFPNT			;NOT END-BUMP POINTER
	TST	R0			;GET RIGHT CONDITION BITS
RT5CC8:	CLC
RT5008:	RTS	PC			;RETURN

;SUBROUTINE TO GET SINGLE CHARACTER - THIS SUBROUTINE IS CALLED AFTER AN
;  ESCAPE IS SEEN TO GET THE SINGLE CHARACTER FOLLOWING WHICH DETERMINES
;  THE MEANING OF THE ESCAPE SEQUENCE
;	JSR	PC,GETCHX
;	C(R0) = ASCII CHARACTER

GETCHX:	JSR	PC,GETCCC		;GET CHARACTER
	CMP	#CR,R0			;IS IT A RETURN?
	BEQ	GETCX4			;YES-MUST GO EAT THE LINE-FEED WHICH
					;  FOLLOWS!
	CMP	#ESC,R0			;IS IT ESC?
	BEQ	GETCX2			;YES-GO HANDLE IT
	CMP	#CU,R0			;IS IT CONTROL-U?
	BEQ	GETCX8			;YES
	CMP	#RUB,R0			;IS IT RUBOUT?
	BEQ	GETCX8			;YES-MAKE IT LOOK LIKE CONTROL-U
	CMP	#SPA,R0			;IS IT A PRINTING CHARACTER?
	BGT	GETCX3			;NO-DON'T ECHO IT
	CMP	#140,R0			;YES-IS IT LOWER CASE?
	BGT	GETCH1			;NO
	CMP	#172,R0			;MAYBE
	BLT	GETCH1			;NO
	BIC	#40,R0			;YES-MAKE UPPER CASE
GETCH1:	JSR	PC,PUTCCC		;YES-ECHO THE CHARACTER
	BR	GETCX3			;CONTINUE

;HERE WITH ESC

GETCX2:	MOV	#'$,R0			;ECHO AS "$"
	JSR	PC,PUTCCC
	MOV	#ESC,R0			;BUT RETURN THE ACTUAL CODE
GETCX3:	TST	R0			;GET THE CONDITION BITS RIGHT
	RTS	PC			;RETURN

;HERE IF CHARACTER IS RETURN

GETCX4:
.IF EQ ..CTY
	JSR	PC,GETCCC		;GET NEXT CHARACTER
	CMP	#LF,R0			;IS IT LINE-FEED?
	BNE	GETCX4			;NO-JUNK IT
.ENDC
	CLR	R0			;RETURN 0
	RTS	PC

;HERE IF CHARACTER IS CONTROL-U

GETCX8:	MOV	#CNTUMS-MSGBAS,R0	;ECHO AS " XXX"<TAB>
	JSR	PC,OUTSTR
	MOV	#CU,R0			;RECOVER CHARACTER
	RTS	PC			;RETURN
	.PAGE
;SUBROUTINE TO GET CHARACTER FROM TERMINAL - THIS IS ONLY PLACE THAT ACTUAL
;  IO IS DONE FROM THE TERMINAL
;	JSR	PC,GETCCC
;	C(R0) = ASCII CHARACTER

.IF EQ ..CTY				;IF NOT USING CTY DIRECTLY
GETCCC:	.TTYIN				;GET CHARACTER
	TST	R0			;IGNORE NULLS
	BEQ	GETCCC
	RTS	PC			;RETURN

.IFF					;IF USING CTY DIRECTLY (NO MONITOR)
GETCCC:	TBBE	200,@#177560,GETCCC	;WAIT FOR INPUT
	MOV	@#177562,R0		;GET DATA
	BIC	#^C177,R0		;ONLY 7 BITS
	BEQ	GETCCC			;IGNORE NULLS
	RTS	PC			;RETURN
.ENDC

;SUBROUTINE TO OUTPUT CHARACTER TO TERMINAL - THIS IS ONLY PLACE THAT ACTUAL
;  IO IS DONE TO THE TERMINAL
;	C(R0) = ASCII CHARACTER
;	JSR	PC,PUTCCC

.IF EQ ..CTY				;IF NOT USING CTY DIRECTLY
PUTCCC:	.TTYOUT				;OUTPUT THE CHARACTER
	RTS	PC			;AND RETURN

.IFF					;IF USING CTY DIRECTLY (NO MONITOR)
PUTCCC:	CMP	#SPA,R0			;PRINTING CHARACTER?
	BGT	PUTCC2			;NO
PUTCCX:	INC	HPOS			;YES-BUMP HORIZONTAL POSITION
PUTCC1:	PUSH	R1			;FREE UP AN AC
	CLR	R1			;INITIALIZE COUNTER
2$:	TBBN	200,@#177564,4$		;GO ON IF READY TO DO OUTPUT NOW
	SOB	R1,2$			;NOT READY-WAIT (BUT FOR LONG!)
4$:	MOV	R0,@#177566		;OUTPUT THE CHARACTER
	POP	R1			;RESTORE AC
	RTS	PC			;RETURN

;HERE IF NOT PRINTING CHARACTER

PUTCC2:	CMP	#HT,R0			;HORIZONTAL TAB?
	BEQ	PUTCC3			;YES
	CMP	#BS,R0			;NO-BACKSPACE?
	BEQ	PUTCC4			;YES
	CMP	#CR,R0			;NO-RETURN?
	BNE	PUTCC1			;NO-JUST OUTPUT THE CHARACTER
	CLR	HPOS			;YES-CLEAR HORIZONTAL POSITION
	BR	PUTCC1			;AND OUTPUT THE RETURN

;HERE IF HORIZONTAL TAB

PUTCC3:	MOV	#SPA,R0			;OUTPUT SPACES
	JSR	PC,PUTCCX
	BIT	#7,HPOS			;AT NEXT TAB STOP YET?
	BNE	PUTCC3			;NO-MORE SPACES
	MOV	#HT,R0			;YES-RESTORE R0
	RTS	PC			;AND RETURN

;HERE IF BACKSPACE

PUTCC4:	DEC	HPOS			;DECREMENT POSITION
	BR	PUTCC1			;CONTINUE
.ENDC
	.PAGE
	.SBTTL	XDT3 - ROUTINES TO READ AND WRITE MEMORY

;SUBROUTINE TO READ A WORD FROM MEMORY
;	C(R1) = ADDRESS TO READ
;	C(R2) = BITS FOR ADDRESS
;	JSR	PC,REDWRD
;	C:SET = ILLEGAL ADDRESS
;	C(R0) = CONTENTS

REDWRD:	PUSH	#6			;GET DISPATCH
	BR	ACSMEM			;CONTINUE

;SUBROUTINE TO READ A BYTE FROM MEMORY
;	C(R1) = ADDRESS TO READ
;	C(R2) = BITS FOR ADDRESS
;	JSR	PC,REDBYT
;	C:SET = ILLEGAL ADDRESS
;	C(R0) = CONTENTS

REDBYT:	PUSH	#4			;GET DISPATCH
	BR	ACSMEM			;CONTINUE

;SUBROUTINE TO WRITE A WORD TO MEMORY
;	C(R0) = DATA TO WRITE
;	C(R1) = ADDRESS TO WRITE
;	C(R2) = BITS FOR ADDRESS
;	JSR	PC,WRTWRD
;	C:SET = ILLEGAL ADDRESS

WRTWRD:	PUSH	#2			;GET DISPATCH
	BR	ACSMEM			;CONTINUE

;SUBROUTINE TO WRITE A BYTE TO MEMORY
;	C(R0) = DATA TO WRITE
;	C(R1) = ADDRESS TO WRITE
;	C(R2) = BITS FOR ADDRESS
;	JSR	PC,WRTBYT
;	C:SET = ILLEGAL ADDRESS

WRTBYT:	CLR	-(SP)			;GET DISPATCH
ACSMEM:	PUSH	R2			;SAVE ANOTHER AC
	BIT	#$NSMMU,NODSTS#		;IS THE MMU ACTIVE
	BEQ	2$			;NO
	CLR	@#177572		;TURN OFF PROTECTION
	NXMJMP	2$			;IGNORE NXM IF NODSTS MESSED UP
2$:
.IF NE ..PSW				;IF THIS MACHINE HAS A PSW ADDRESS
	CLC				;CLEAR C FOR RETURN
	PUSH	@#177776		;SAVE CURRENT PSW
.IFF					;IF THIS MACHINE USES PSW INSTRUCTIONS
	CLR	-(SP)			;CLEAR A WORD ON THE STACK (ALSO
					;  CLEARS C)
	MFPS	(SP)			;SAVE CURRENT PSW (NOTE:  MUST DO
					;  THIS LIKE THIS SINCE MFPS IS A
					;  BYTE INSTRUCTION AND WE WILL
					;  RESTORE THE PSW WITH A RTI WHICH
					;  USES THE WHOLE WORD!  IF WE DID
					;  A "MFPS -(SP)" IT WOULD LEAVE
					;  JUNK IN THE HIGH ORDER BYTE WHICH
					;  WOULD MAKE PROCESSORS WHICH USE
					;  THE HIGH ORDER HALF OF THE PSW VERY
					;  UNHAPPY!!!!!)
.ENDC
	PUSH	#340			;NO INTERRUPTS NOW
	CALL	SETPSW
.IF EQ	..PIC
	MOV	#BADMEM,R2
.IFF
	MOV	#<BADMEM-4$>,R2		;GET NEW MEMORY FAIL VECTOR
	ADD	PC,R2
.ENDC
4$:	TST	#<GO#-1000>		;CHECK FOR MXV VERSION
	BEQ	5$			;NOT MXV
	PUSH	@#20006			;SAVE CURRENT MEM FAIL VECTOR
	PUSH	R0			;SAVE A SPOT ON THE STACK
	MOV	R2,@#20006		;SET IN NEW VALUE
	MOV	#137,@#20004		;SET UP IN CASE FIRST USAGE
	BR	55$
5$:	PUSH	@#4			;SAVE CURRENT MEM FAIL VECTOR
	PUSH	@#6
	MOV	R2,@#4
	MOV	#340,@#6
55$:	TBBE	$AC,6(SP),6$		;GO ON IF NOT AC
	BIT	#^C7,R1			;VALID AC NUMBER?
	BNE	BADMMA			;NO-FAIL
	ASL	R1			;YES-MAKE IT POINT TO USER'S SAVED AC'S
.IF EQ	..PIC
	ADD	#ACSAV0,R1
.IFF
	ADD	#<ACSAV0-6$>,R1
	ADD	PC,R1
.ENDC
6$:	MOV	10(SP),R2		;GET DISPATCH INDEX
	ADD	R2,PC			;DISPATCH
	BR	WRTBYX			; 0
	BR	WRTWRX			; 2
	BR	REDBYX			; 4
;	BR	REDWRX			; 6

;HERE TO READ WORD

REDWRX:	TBBN	1,R1,BADMMA		;FAIL IF NOT WORD ADDRESS
	MOV	(R1),R0			;READ THE WORD
	BR	FINMEM			;CONTINUE

;HERE READ BYTE

REDBYX:	MOVB	(R1),R0			;READ THE BYTE
	BR	FINMEM			;CONTINUE

;HERE TO WRITE WORD

WRTWRX:	TBBN	1,R1,BADMMA		;FAIL IF NOT WORD ADDRESS
	MOV	R0,(R1)			;WRITE THE WORD
	BR	FINMEM			;CONTINUE

;HERE TO WRITE BYTE

WRTBYX:	MOVB	R0,(R1)			;WRITE THE BYTE
	BR	FINMEM			;CONTINUE

;HERE IF FAILURE OCCURED (4 TRAP)

BADMEM:	ADD	#4,SP			;FIX UP THE STACK
BADMMA:	MOV	#BDADMS-MSGBAS,R0	;COMPLAIN
	JSR	PC,OUTSTR
	BIS	#1,4(SP)		;SET C
FINMEM:	TST	#<GO#-1000>		;CHECK FOR MXV AGAIN
	BEQ	10$			;NOT MXV
	TST	(SP)+			;POP DUMMY
	POP	@#20006			;RESTORE VECTOR
	BR	20$
10$:	POP	@#6			;RESTORE TRAP VECTOR
	POP	@#4
20$:	BIT	#$NSMMU,NODSTS#		;HAS THE MMU BEEN TURNED ON
	BEQ	4$			;NO
	MOV	#1,@#177572		;TURN IT ON
	NXMJMP	4$			;IGNORE NXM IF NODSTS HAS BEEN CORRUPTED
4$:	CALL	SETPSW			;RESTORE PSW
	POP	R2			;RESTORE R2
	BIT	R0,(SP)+		;REMOVE DISPATCH (DON'T CHANGE C)
	RETURN				;FINISHED!
	.PAGE
	.SBTTL	XDT4 - INPUT SUBROUTINES

;SUBROUTINE TO INPUT ITEM FORM KEYBOARD
;	JSR	PC,ITEM
;	C:SET = ERROR
;	C(R0) = INDEX FOR TERMINATING ACTION CHARACTER
;	C(WORD1)  = VALUE OF FIRST WORD OF ITEM
;	C(WORD2)  = VALUE OF SECOND WORD OF ITEM
;	C(WORD3)  = VALUE OF THIRD WORD OF ITEM
;	C(INSSIZ) = NUMBER OF WORDS IN INSTR - 1 (0,1,2)
;	C(SRCFLX) = VALUE OF FIRST FIELD
;	C(DSTFLX) = VALUE OF LAST OR ONLY FIELD
;	C(FLAGX)  = FIELD BITS

ITEM:	TSTB	BUFFER			;NULL INPUT?
	BLE	RT3CC7			;YES-JUST RETURN
	CLR	FLAGX
	CLR	BITS1
	MOV	#2,SIZEX		;ASSUME 1 WORD ITEM
	JSR	PC,GETCHU		;PEEK AT NEXT CHARACTER
	DEC	BUFPNT
	CMP	#'A,R0			;IS IT A LETTER?
	BGT	ITEM05			;NO
	CMP	#'Z,R0
	BLT	ITEM05
	MOV	BUFPNT,ITMPNT		;YES-SAVE CURRENT POINTER
	JSR	PC,GETR50		;COLLECT A SYMBOL
	BCS	RT3XX6			;IF ERROR
	MOV	#NUMOPC,R1		;SET TO SEARCH OP-CODE TABLE
.IF EQ	..PIC
	MOV	#INBGN,R2
.IFF
	MOV	#<INBGN-ITEM01>,R2
	ADD	PC,R2
.ENDC
ITEM01:	CMP	(R2)+,R4		;THIS ONE?
	BEQ	ITEM08			;MAYBE
	BHI	ITEM03			;IF NO MATCH POSSIBLE NOW
	ADD	#6,R2			;BUMP POINTER
ITEM02:	SOB	R1,ITEM01		;LOOP BACK IF MORE TO CHECK
ITEM03:	MOV	ITMPNT,BUFPNT		;NOT OPCODE-RESET POINTER
ITEM05:	.IF EQ	..PIC
	MOV	#WORD1,R1
.IFF
	MOV	#<WORD1-2$>,R1		;SET POINTER
	ADD	PC,R1
.ENDC
2$:	MOV	R1,INSWRD
	CLR	BITS1
ITEM06:	JSR	PC,GETFLD		;GET VALUE OF FIELD
	BCS	RT3XX6			;IF ERROR
	MOV	R1,@INSWRD		;STORE VALUE
	BIS	R2,BITS1
	MOV	R1,DSTFLX		;AND STORE AS DESTINATION FIELD
	MOV	#$DSTOK,FLAGX		;INDICATE FIELD IS VALID
	CMP	#',,R0			;DID IT END WITH ","?
	BEQ	ITEM07			;YES
	TST	R0			;NO-ANY JUNK AFTER THE FIELD?
	BGT	GETAS2			;ERROR
	TBBE	$AC,BITS1,RT3CC8	;FINISHED IT NOT AC NUMBER
	CMP	#2,SIZEX		;AC NUMBER-MUST BE SINGLE WORD
	BNE	GETAS2			;ERROR IF NOT
	BIS	#$DSTAC,FLAGX		;OK-INDICATE ITS AN AC NUMBER
RT3CC7:	BR	RT3CC8			;RETURN

;HERE IF FIELD ENDED BY ","

ITEM07:	ADD	#2,SIZEX		;INCREMENT ITEM SIZE
	ADD	#2,INSWRD		;BUMP POINTER
	CMP	#6,SIZEX		;TOO BIG?
	BGE	ITEM06			;NO-CONTINUE
GETAS2:	JMP	GETAIS			;YES-ERROR

;HERE TO CHECK SECOND HALF OF OP-CODE

ITEM08:	CMP	(R2)+,R5		;THIS ONE?
	BEQ	ITEM09			;YES-FOUND IT!
	ADD	#4,R2			;NO-BUMP POINTER
	BR	ITEM02			;AND CONTINUE

;HERE WITH A MATCH ON THE OP-CODE

ITEM09:	MOV	2(R2),WORD1		;STORE VALUE OF OP-CODE
	MOV	(R2),R1			;GET DISPATCH INDEX
.IF EQ	..PIC
	ADD	#INTBL,R1
	JMP	@(R1)
INTBAS=!0
.IFF
	ADD	#<INTBL-2$>,R1
	ADD	PC,R1
2$:	MOV	(R1),R1			;GET ADDRESS OF ROUTINE
	ADD	PC,R1			;FIX IT UP
INTBAS:	JMP	(R1)			;DISPATCH
.ENDC
	.PAGE
;HERE FOR 2 ADDRESS INSTRUCTIONS

SSDDIN:	CALL	GETSS			;PROCESS SOURCE FIELD
RT3XX6:	BCS	RT3008			;IF ERROR
	ASHI	6,R1			;POSITION FIELD
	BIS	R1,WORD1		;MERGE INTO INSTRUCTION
					;FALL INTO XXIN FOR DST FIELD

;HERE FOR DESTINATION ONLY OR SOURCE ONLY INSTRUCTIONS

XXIN:	JSR	PC,GETSDF		;GET DESTINATION FIELD
	BCS	RT3008			;IF ERROR
	TST	R0			;DID IT END RIGHT?
	BGT	GETAIX			;NO-ERROR
	BIS	R1,WORD1		;STORE FIELD IN INSTRUCTION WORD
	MOV	R2,DSTFLX		;STORE VALUE OF FIELD
	TST	R3			;DETERMINE TYPE OF FIELD
	BLT	RT3CC8			;IF NOTHING MORE NEEDED
	BIS	#$DSTOK,FLAGX		;INDICATE FIELD IS VALID AS ADDRESS
	TST	R3
	BGT	XXIN2			;IF NOT AC
	BIS	#$DSTAC,FLAGX		;INDICATE FIELD IS AC NUMBER
RT3CC8:	CLC
RT3008:	RETURN

;HERE IF SECOND FIELD REQUIRES ADDITIONAL WORD

XXIN2:	MOV	SIZEX,R3		;GET SIZE OF INSTRUCTION
.IF EQ	..PIC
	ADD	#WORD1-2,R3
.IFF
	ADD	#<WORD1-2-2$>,R3
	ADD	PC,R3
.ENDC
2$:	MOV	R2,(R3)			;STORE 2ND OR 3RD WORD
	BR	RT3CC8			;FINISHED

;HERE FOR INSTRUCTIONS WITH SOURCE AND REGISTER FIELDS

RSSIN:	CALL	GETSS			;PROCESS SOURCE FIELD
	BCS	RT3008			;IF ERROR
	BIS	R1,WORD1		;MERGE INTO INSTRUCTION
	CALL	GETACV			;GET AC VALUE
	BCS	RT3008			;IF ERROR
	TST	R0			;END OF ITEM?
	BNE	GETAIX			;NO-ERROR
	MOV	R1,DSTFLX		;YES-STORE AS VALUE OF DST FIELD
	BIS	#$DSTOK+$DSTAC,FLAGX	;INDICATE DST IS VALID AND IS AN AC
	ASHI	6,R1			;POSITION THE VALUE
	BIS	R1,WORD1		;MERGE INTO INSTRUCTION WORD
	BR	RT3CC8			;FINISHED

;HERE FOR INSTRUCTIONS WITH REGISTER AND DESTINATION FIELDS

RDDIN:	JSR	PC,GETACV		;GET VALUE OF AC FIELD
	BCS	RT3008			;IF ERROR
	CMP	#',,R0			;MAKE SURE FIELD WAS ENDED RIGHT
	BNE	GETAIX
	MOV	R1,SRCFLX		;STORE AS VALUE OF FIELD
	BIS	#$SRCOK+$SRCAC,FLAGX	;INDICATE SOURCE FIELD IS VALID AND IS
					;  AN AC ADDRESS
	ASHI	6,R1			;POSITION AC VALUE
	BIS	R1,WORD1		;PUT INTO INSTRUCTION
	BR	XXIN			;CONTINUE WITH COMMON CODE

;HERE FOR INSTRUCTIONS WITH JUST A REGISTER FIELD

REGIN:	JSR	PC,GETACV		;GET VALUE OF AC FIELD
	BCS	RT3008			;IF ERROR
	MOV	R1,DSTFLX		;STORE AC NUMBER AS DESTINATION FIELD
	BIS	#$DSTOK+$DSTAC,FLAGX	;AND SET FLAGS
	TST	R0			;MAKE SURE NO JUNK AFTER AC
	BLE	BRIN5			;OK-GO PUT AC NUMBER INTO INSTRUCTION
GETAIX:	JMP	GETAIS

;HERE FOR INSTRUCTIONS WITH 6 BIT NUMERIC FIELD

NNIN:	JSR	PC,GETFLD		;GET INPUT FIELD
	BCS	RT3008			;IF ERROR
	TST	R0			;DID IT END RIGHT?
	BGT	GETAIX			;NO!
	BIT	#177700,R1		;TOO BIG?
	BR	NNNIN2

;HERE FOR INSTRUCTION WITH 8 BIT NUMERIC FIELD

NNNIN:	JSR	PC,GETFLD		;GET INPUT FIELD
	BCS	RT3008			;IF ERROR
	TST	R0			;DID IT END RIGHT?
	BGT	GETAIX			;NO!
	BIT	#177400,R1		;TOO BIG?
NNNIN2:	BNE	OPRERR			;YES
	TST	R0			;MAKE SURE NO EXTRA JUNK
	BNE	GETAIX
	TBBE	$AC,R2,BRIN5		;NO-OK IF NOT AC VALUE
OPRERR:	MOV	#OPERMS-MSGBAS,R0	;COMPLAIN ABOUT OPERAND
	BR	ERROU5

;HERE FOR BRANCH INSTRUCTIONS

BRIN:	JSR	PC,GETRLA		;GET RELATIVE ADDRESS
	BCS	RT3008			;IF ERROR
	MOV	R1,R2			;GET MAGNITUDE
	BGT	2$
	NEG	R2
2$:	BIT	#177401,R2		;VALID ADDRESS?
	BNE	BADADD			;NO
	BIC	#^C777,R1		;YES-REMOVE JUNK
BRIN4:	ASR	R1			;DIVIDE BY 2
BRIN5:	BIS	R1,WORD1		;PUT INTO INSTRUCTION WORD

;HERE FOR INSTRUCTION WITH NO OPERAND FIELDS

NONIN:	BR	RT3CC8

;HERE FOR THE SOB INSTRUCTION

SOBIN:	JSR	PC,GETACV		;GET AC NUMBER
	BCS	RT3008			;IF ERROR
	CMP	#',,R0			;AC FIELD MUST END WITH ","
	BNE	GETAIX
	ASHI	6,R1			;POSITION IT
	BIS	R1,WORD1		;PUT INTO INSTRUCTION
	JSR	PC,GETRLA		;GET RELATIVE ADDRESS
	BCS	RT3008			;IF ERROR
	NEG	R1			;MAKE PLUS
	BLT	BADADD			;MUST BE PLUS NOW
	BIT	#177601,R1		;VALID ADDRESS?
	BEQ	BRIN4			;YES-GO FINISH UP

;HERE IF ADDRESS IS OUT OF RANGE

BADADD:	MOV	#BDADMS-MSGBAS,R0	;COMPLAIN
ERROU5:	JSR	PC,OUTSTR
	SEC
	RTS	PC

;SUBROUTINE TO PROCESS SOURCE FIELD
;	CALL	GETSS

GETSS:	JSR	PC,GETSDF		;GET SOURCE FIELD
	BCS	RT3009			;IF ERROR
	CMP	#',,R0			;DID IT END RIGHT?
	BNE	GETAIX			;NO-ERROR
	MOV	R2,SRCFLX		;SAVE VALUE OF FIELD
	MOV	R2,WORD2
	TST	R3			;TEST FIELD TYPE
	BLT	RT3CC9			;IF NOTHING MORE NEEDED
	BIS	#$SRCOK,FLAGX		;INDICATE FIELD CAN BE USED AS ADDRESS
	TST	R3
	BGT	RT3CC9			;GO ON IF NOT AC NUMBER
	BIS	#$SRCAC,FLAGX		;INDICATE FIELD IS AC VALUE
RT3CC9:	CLC
RT3009:	RETURN

;SUBROUTINE TO FETCH RELATIVE ADDRESS FOR BRANCH AND SOB INSTRUCTIONS
;	JSR	PC,GETRLA
;	C(R1) = RELATIVE ADDRESS
;	C:SET = ERROR

GETRLA:	JSR	PC,GETFLD		;GET VALUE
	BCS	RT3009			;IF ERROR
	TBBN	$AC,R2,OPRERR		;CAN'T BE AC
	TST	R0			;MAKE SURE FIELD ENDED RIGHT
	BLE	2$
	JMP	GETAIS

2$:	MOV	R1,DSTFLX		;STORE ADDRESS AS VALUE OF FIELD
	MOV	#$DSTOK,FLAGX
	SUB	DOT,R1			;MAKE ADDRESS RELATIVE
	SUB	#2,R1
	BR	RT3CC9			;RETURN

;SUBROUTINE TO GET VALUE OF AC FIELD OF INSTRUCTION
;	JSR	PC,GETACV
;	C(R1) = AC NUMBER
;	C:SET = ERROR

GETACV:	JSR	PC,GETFLD		;GET INPUT FIELD
	BCS	RT3009			;IF ERROR
	TBBN	$AC,R2,RT3009		;MUST BE AC
	BR	OPRERR			;OTHERWISE COMPLAIN
	.PAGE
;SUBROUTINE TO INPUT GENERAL SOURCE OR DESTINATION FIELD OF AN INSTRUCTION
;	JSR	PC,GETSDF
;	C(R0) = NEXT CHARACTER
;	C(R1) = VALUE OF FIELD (6 BITS, RIGHT JUSTIFIED)
;	C(R2) = OPERAND, IF ANY
;	C(R3) = .LT. 0 IF FIELD CANNOT BE USED AS ADDRESS (NO ADDITIONAL WORD
;			 NEEDED)
;		.EQ. 0 IF FIELD CAN BE USED AS ADDRESS (NO ADDITIONAL WORD
;			 NEEDED)
;		.GT. 0 IF FIELD CAN BE USED AS ADDRESS (ADDITIONAL WORD NEEDED)
;	C:SET = ERROR

GETSDF:	JSR	PC,GETCHR		;GET FIRST CHARACTER
	CMP	#'#,R0			; # ?
	BEQ	GSDLIT			;YES
	CMP	#'@,R0			; @ ?
	BEQ	GSDIND			;YES
	CMP	#'(,R0			; ( ?
	BEQ	GSDLPR			;YES
	CMP	#'-,R0			; - ?
	BEQ	GSDMNS			;YES
GSDVAL:	DEC	BUFPNT			;NO-PUT IT BACK
	JSR	PC,GETFLD		;GET FIELD
	BCS	RT3003			;IF ERROR
	TBBN	$AC,R2,GSDFAC		;IF AC NUMBER
	CMP	#'(,R0			; ( AFTER FIELD?
	BNE	GSDF01			;NO
	PUSH	R1			;YES-SAVE VALUE OF FIELD
	JSR	PC,GSDGTR		;GET AC
	POP	R2			;RESTORE FIELD TO RIGHT AC
	BCS	RT3003			;IF BAD AC NUMBER
	BR	GSDF02			;CONTINUE

;HERE IF AC NUMBER GIVEN AS ARGUMENT

GSDFAC:	CLR	R3			;SET FLAG
	MOV	R1,R2			;GET AC NUMBER IN RIGHT PLACE
	RTS	PC			;RETURN

;HERE IF NO (AC) AFTER FIELD

GSDF01:	MOV	R1,R2			;GET VALUE OF FIELD IN RIGHT AC
	SUB	DOT,R2			;MAKE RELATIVE
	SUB	SIZEX,R2
	SUB	#2,R2
	MOV	#7,R1			;REGISTER = 7 (PC)
GSDF02:	BIS	#60,R1			;MODE = 6
GSDF03:	MOV	R1,R3			;SET R3 .GT. ZERO
	ADD	#2,SIZEX		;BUMP INSTRUCTION SIZE
RT3003:	RTS	PC			;RETURN

;HERE IF FIRST CHARACTER IS #

GSDLIT:	JSR	PC,GETFLD		;GET FIELD
	BCS	RT3003			;IF ERROR
	MOV	R1,R2			;GET VALUE IN RIGHT AC
	MOV	#27,R1			;MODE = 2, REGISTER = 7
	BR	GSDF03			;CONTINUE

;HERE IF FIRST CHARACTER IS -

GSDMNS:	JSR	PC,GETCHR		;GET NEXT CHARACTER
	CMP	#'(,R0			;IS IT ( ?
	BEQ	GSDF11			;YES
	DEC	BUFPNT			;NO-PUT IT BACK
	BR	GSDVAL			;AND TRY FOR OTHER POSSIBILTIY

;HERE IF FIRST TWO CHARACTERS ARE -(

GSDF11:	JSR	PC,GSDGTR		;GET REGISTER
	BCS	RT3003			;IF ERROR
	BIS	#40,R1			;MODE = 4
GSDF14:	CLR	R3			;INDICATE NO ADDITIONAL DATA NEEDED
	NEG	R3			;INDICATE NOT VALID AS ADDRESS
	RTS	PC			;RETURN

;HERE IF FIRST CHARACTER IS (

GSDLPR:	JSR	PC,GSDGTR		;GET REGISTER
	BCS	RT3003			;IF ERROR
	CMP	#'+,R0			; + AFTER REGISTER?
	BEQ	GSDF21			;YES
	BIS	#10,R1			;NO-MODE = 1
	BR	GSDF14			;THATS ALL

;HERE IF + IS CHARACTER AFTER (REG)

GSDF21:	JSR	PC,GETCHR		;GET NEXT CHARACTER
	BIS	#20,R1			;MODE = 2
	BR	GSDF14

;HERE IF FIRST CHARACTER IS @

GSDIND:	JSR	PC,GETCHR		;GET NEXT CHARACTER
	CMP	#'#,R0			; # ?
	BEQ	GSDABS			;YES
	CMP	#'(,R0			; ( ?
	BEQ	GSDRGD			;YES
	CMP	#'-,R0			; - ?
	BEQ	GSDADD			;YES
GSDIN2:	JSR	PC,GSDVAL		;PROCESS REST OF FIELD
	BCS	RT3003			;IF ERROR
	BIS	#10,R1			;CHANGE MODE FROM 6 TO 7
	RTS	PC			;RETURN

;HERE IF FIRST TWO CHARACTERS ARE @#

GSDABS:	JSR	PC,GETFLD		;GET VALUE OF FIELD
	BCS	RT3003			;IF ERROR
	MOV	R1,R2			;GET VALUE IN RIGHT AC
	MOV	#37,R1			;MODE = 3, REGISTER = 7
	BR	GSDF03

;HERE IF FIRST TWO CHARACTERS ARE @(

GSDRGD:	JSR	PC,GSDGTR		;GET REGISTER
	BCS	RT3003			;IF ERROR
	CMP	#'+,R0			;WAS REGISTER FOLLOWED BY + ?
	BNE	GETAIY			;NO-ERROR!
	JSR	PC,GETCHR		;YES-EAT CHARACTER
	BIS	#30,R1			;MODE = 3
	BR	GSDF14

;HERE IF FIRST TWO CHARACTERS ARE @-

GSDADD:	JSR	PC,GETCHR		;GET NEXT CHARACTER
	CMP	#'(,R0			; ( ?
	BEQ	2$			;YES-GO ON
	DEC	BUFPNT			;NO-PUT IT BACK
	BR	GSDIN2			;AND GO TRY SOMETHING ELSE!

2$:	JSR	PC,GSDGTR		;GET REGISTER
	BCS	RT3003			;IF ERROR
	BIS	#50,R1			;MODE = 5
	BR	GSDF14

;SUBROUTINE TO PROCESS REGISTER SPECIFICATION
;	JSR	PC,GSDGTR
;	C(R1) = REGISTER NUMBER
;	C:SET = ERROR

GSDGTR:	JSR	PC,GETFLD		;GET FIELD
	BCS	RT3003			;IF ERROR
	BIT	#^C7,R1			;VALID VALUE FOR AC NUMBER?
	BNE	GETAIY			;NO-FAIL!
	CMP	#'),R0			;YES-MUST BE ENDED BY )
	BNE	GETAIY
	JMP	GETCHR			;EAT CHARACTER AND RETURN

GETAIY:	JMP	GETAIS
	.PAGE

;SUBROUTINE TO GET VALUE OF A GENERAL INPUT FIELD, WHERE A FIELD MAY CONTAIN
;  ANY COMBINATION OF SYMBOLS AND CONSTAMNTS SEPERATED BY ARITHMETIC
;  OPERATORS.  A FIELD IS TERMINATED BY ANY CHARACTER WHICH IS NOT A VALID
;  CHARACTER FOR A SYMBOL OR CONSTANT OR A VALID OPERATOR.
;	C(R1) = ADDRESS OF NEXT CHARACTER
;	JSR	PC,GETFLD
;	C:SET = ERROR
;	C(R0) = CHARACTER WHICH TERMINATED THE FIELD
;	C(R1) = VALUE OF FIELD (16 BITS)
;	C(R2) = STATUS BITS FOR FIELD

GETFLD:	JSR	PC,GETATM		;GET FIRST ATOM
	BCS	RT3002			;IF ERROR
	PUSH	R4			;RESPECT R4
	MOV	R1,FIELD		;STORE VALUE
	MOV	R2,FBITS		;AND INITIAL BITS
GETFL2:	MOV	#NUMOPR,R3		;SET POINTER
2$:	.IF EQ	..PIC
	MOV	#OPRTBL-1,R4
.IFF
	MOV	#<OPRTBL-1-4$>,R4	;IS IT THIS OPERATOR?
	ADD	PC,R4
.ENDC
4$:	ADD	R3,R4
	CMPB	(R4),R0
	BEQ	GETFL3			;YES
	SOB	R3,2$			;NO-LOOP IF MORE TO CHECK
	MOV	FIELD,R1		;NOT OPERATOR-FINISHED
	MOV	FBITS,R2
	CLC				;INDICATE GOOD RETURN
GETFLE:	POP	R4			;RESTORE R4
RT3002:	RTS	PC

;HERE WITH AN OPERATOR

GETFL3:	PUSH	R3			;SAVE INDEX
	JSR	PC,GETATM		;GET NEXT ATOM
	POP	R3			;RESTORE INDEX
	BCS	GETFLE			;IF ERROR
	ASL	R3			;FOR WORD INDEXING
.IF EQ	..PIC
	ADD	#OPRDSP-2,R3
	JMP	@(R3)
OPRBAS=!0
.IFF
	ADD	#<OPRDSP-2-2$>,R3	;DISPATCH ON THE OPERATOR
	ADD	PC,R3
2$:	MOV	(R3),R3			;GET ADDRESS
	ADD	PC,R3			;FIX IT UP
OPRBAS:	JMP	(R3)			;DISPATCH
.ENDC

;DEFINE MACRO FOR GENERATING THE OPERATOR TABLES

	.MACRO	OPRATR
	XX	<'-> ,MINUS
	XX	<'+> ,PLUS
	XX	<'*> ,TIMES
	XX	<ACT>,DIVID
	XX	<LA> ,SHIFT
	XX	<'!> ,IORX
	XX	<'&> ,ANDX
	XX	<VBR>,XORX
	.ENDM

;GENERATE THE CHARACTER TABLE

	.MACRO	XX A,B
	.BYTE	A
	.ENDM

OPRTBL:	OPRATR
NUMOPR=.-OPRTBL
	.EVEN

;GENERATE THE DISPATCH TABLE

	.MACRO	XX A,B
	.WORD	B-OPRBAS
	.ENDM

OPRDSP:	OPRATR

;HERE IF OPERATOR WAS +

PLUS:	ADD	R1,FIELD		;ADD IN THIS VALUE
	BR	GETFL7			;CONTINUE

;HERE IF OPERATOR WAS -

MINUS:	SUB	R1,FIELD		;SUBTRACT THIS VALUE
	BR	GETFL7			;CONTINUE

;HERE IF OPERATOR WAS *

TIMES:	MUL	FIELD,R1		;MULTIPLY BY THIS VALUE
	MOV	R1,FIELD		;STORE RESULT
	BR	GETFL7			;CONTINUE

;HERE IF OPERATOR WAS /

DIVID:	PUSH	R2			;RESPECT R2
	MOV	FIELD,R3		;GET VALUE IN RIGHT AC
	SXT	R2			;EXTEND THE SIGN
	DIV	R1,R2
	MOV	R2,FIELD		;STORE RESULT
	POP	R2			;RESTORE R2
	BR	GETFL7			;CONTINUE

;HERE IF OPERATOR WAS LEFT ANGLE (SHIFT)

SHIFT:	MOV	FIELD,R3
.IF NE ..EIS
	ASH	R1,R3			;DO THE SHIFT
.IFF
	TST	R1			;WHICH WAY?
	BEQ	4$			;NOTHING!
	BMI	2$			;RIGHT
1$:	ASL	R3			;SHIFT ONE BIT!
	DEC	R1			;REDUCE COUNT
	BGT	1$			;CONTINUE IF MORE TO DO
	BR	4$			;IF FINISHED

2$:	ASR	R3			;SHIFT ONE BIT!
	INC	R1			;MORE TO DO?
	BLT	2$			;YES
4$:
.ENDC
	MOV	R3,FIELD
	BR	GETFL7			;CONTINUE

;HERE IF OPERATOR WAS ! (INCLUSIVE OR)

IORX:	BIS	R1,FIELD		;DO IT
	BR	GETFL7			;CONTINUE

;HERE IF OPERATOR WAS VERTICAL BAR (EXCLUSIVE OR)

XORX:	XOR	R1,FIELD		;DO IT
	BR	GETFL7

;HERE IF OPERATOR WAS & (AND)

ANDX:	COM	R1			;CRAZY MACHINE DOES NOT HAVE AND INSTR!
	BIC	R1,FIELD		;BUT IT COMES CLOSE!
GETFL7:	BIS	R2,FBITS		;MERGE IN NEW STATUS BITS
	BR	GETFL2			;CONTINUE
	.PAGE
;SUBROUTINE TO FETCH ATOM: AN ATOM IS EITHER A SYMBOL OR A CONSTANT
;	C(R5) = POINTER TO NEXT CHARACTER
;	JSR	PC,GETATM
;	C:SET = ERROR
;	C(R0) = TERMINATING CHARACTER
;	C(R1) = VALUE OF ATOM
;	C(R2) = STATUS BITS FOR ATOM

GETATM:	CLR	SYMBL1
	JSR	PC,GETCHU		;GET UPPER CASE CHARACTER
	CMP	#SPA,R0			;IGNORE LEADING SPACES
	BEQ	GETATM
	CMP	#'-,R0			;NEGATIVE VALUE?
	BNE	GETA00			;NO-GO ON
	JSR	PC,GETCHU		;YES-GET NEXT CHARACTER
	JSR	PC,GETA00		;AND GET VALUE
	BCS	RT4000			;IF ERROR
	NEG	R1			;MINUS
	CLC
RT4000:	RTS	PC

;HERE IF FIRST CHARACTER NOT "-"

GETA00:	CMP	#'A,R0			;LETTER?
	BGT	GETA01			;NO
	CMP	#'Z,R0			;MAYBE
	BGE	GETSYM			;YES-GO GET VALUE OF SYMBOL
GETA01:	CMP	#'$,R0			;SOME OTHER SYMBOL CHARACTER?
	BEQ	GETSYM
	CMP	#'.,R0
	BEQ	GETSYM
	CMP	#'%,R0			;AC VALUE?
	BNE	1$			;NO
	JMP	GETAAC			;YES

1$:	CMP	#'',R0			;ASCII CHARACTER?
	BNE	2$			;NO
	JMP	GETASC			;YES

2$:	CMP	#'",R0			;TWO ASCII CHARACTERS?
	BNE	3$			;NO
	JMP	GETAST

3$:	CMP	#TLD,R0			;RADIX 50 CHARACTERS?
	BNE	4$			;NO
	JMP	GETARX			;YES

4$:	CMP	#'0,R0			;IS THIS A DIGIT?
	BGT	GETA27			;NO-FINISHED
	CMP	#'9,R0
	BLT	GETA27
GETA02:	MOV	BUFPNT,NUMPNT		;SAVE START OF NUMBER
	DEC	NUMPNT
	MOV	#20,RADIX		;ASSUME RADIX IS 16
GETA03:	CLR	R2			;CLEAR REGISTER
	CLR	R4			;CLEAR ERROR FLAG
GETA04:	BIC	#^C17,R0		;GET VALUE OF DIGIT
	CMP	RADIX,R0		;VALID?
	BGT	GETA11			;YES-GO ON
	JMP	ILLNUM			;NO-ERROR

GETA11:	MUL	RADIX,R2		;YES
	TST	R2			;NUMBER TOO LARGE?
	BEQ	GETA12			;NO
	INC	R4			;YES-REMEMBER THAT
GETA12:	MOV	R3,R2
	ADD	R0,R2			;ADD IN THIS DIGIT
	BCC	GETA13			;CAN BE TOO LARGE HERE TOO!
	INC	R4
GETA13:	JSR	PC,GETCHR		;GET NEXT CHARACTER
	CMP	#'0,R0			;ANOTHER DIGIT?
	BGT	GETA14			;NO-FINISHED
	CMP	#'9,R0
	BGE	GETA04			;YES-CONTINUE
	CMP	#'A,R0			;MAYBE
	BGT	GETA14			;NO
	CMP	#'F,R0			;LAST CHANCE!
	BLT	GETA14			;NO!
	SUB	#7,R0			;YES-FIX IT UP
	BR	GETA04			;CONTINUE

;HERE IF NEXT CHARACTER NOT A DIGIT

GETA14:	CMP	#'H,R0			;STOPPED BY "H"?
	BEQ	GETA25			;YES-FINISHED
	CMP	#'.,R0			;NO-STOPPED BY "."?
	BNE	GETA15			;NO
	CMP	#12,RADIX		;YES-WAS THE RADIX 10?
	BEQ	GETA25			;YES-FINISHED
	MOV	#12,RADIX		;NO-SET RADIX TO 10
	BR	GETA18			;AND DO IT AGAIN!

GETA15:	BEQ	GETA25			;YES-FINISHED
	CMP	#'I,R0			;STOPPED BY "I"?
	BNE	GETA16			;NO
	CMP	#2,RADIX		;YES-WAS THE RADIX 2?
	BEQ	GETA25			;YES-FINISHED
	MOV	#2,RADIX		;NO-SET RADIX = 2
	BR	GETA18			;AND CONTINUE

GETA16:	CMP	#10,RADIX		;NO-WAS THE RADIX 8?
	BEQ	GETA26			;YES-FINISHED!
	MOV	#10,RADIX		;NO-SET RADIX = 8
GETA18:	MOV	NUMPNT,BUFPNT		;BACK UP AND DO IT AGAIN!
	JSR	PC,GETCHR
	BR	GETA03

GETA25:	JSR	PC,GETCHR		;EAT THE PERIOD
GETA26:	TST	R4			;IS NUMBER TOO BIG?
	BNE	ILLNUM			;YES!
GETA27:	MOV	R2,R1			;GET RESULT IN RIGHT AC
GETA28:	CLR	R2			;CLEAR ATOM STATUS BITS
RT4006:	RTS	PC			;RETURN

;HERE IF FIRST CHARACTER IS SYMBOLIC - THIS MUST BE A SYMBOL

GETSYM:	DEC	BUFPNT			;GET LAST CHARACTER BACK
	JSR	PC,GETR50		;GET SYMBOL
	BCS	RT4006			;IF ERROR
	CMP	#^R.  ,R4		;WAS THE SYMBOL "."?
	BNE	GETSY1			;NO-GO ON
	MOV	WORDC,R1		;YES-RETURN CURRENT ADDRESS AS VALUE
	MOV	BITSC,R2
RT4CC1:	BR	RT4CC2

;HERE IF SYMBOL NOT SPECIAL

GETSY1:	CLR	BSTGLB			;CLEAR POINTERS
	CLR	BSTRMT
	MOV	SYMPNT,R1		;GET ADDRESS OF SYMBOL TABLE
	BEQ	UNDSYM			;JUST IN CASE NO TABLE
	MOV	(R1)+,R2		;GET NUMBER OF ACTUAL ENTRIES
	TST	(R1)+			;BUMP POINTER
SYMSR0:	CMP	(R1),R4			;COMPARE FIRST HALF
	BNE	SYMSR8			;NO
	CMP	.SYNM2(R1),R5		;COMPARE SECOND HALF
	BNE	SYMSR8			;NO
	TBBN	$PRGM,.SYBTS(R1),SYMSR8	;IGNORE PROGRAM NAMES
	CMP	FSTSYM,R1		;IS THIS SYMBOL IN THE CURRENT PROGRAM?
	BHI	SYMSR4			;NO
	CMP	LSTSYM,R1
	BHIS	SYMSR9			;YES
SYMSR4:	TBBN	$GLBL,.SYBTS(R1),SYMSR6	;NO-IS IT A GLOBAL SYMBOL?

;HERE IF MATCH ON LOCAL SYMBOL DEFINED IN OTHER THAN THE CURRENT PROGRAM

	TST	BSTGLB			;ALREADY HAVE A GLOBAL MATCH?
	BNE	SYMSR8			;YES-DON'T CARE ABOUT THIS MATCH!
	MOV	BSTRMT,R3		;YES-ALREADY HAVE A REMOTE MATCH?
	BNE	SYMSR7			;YES-GO CHECK SOME MORE
	MOV	R1,BSTRMT		;NO-BUT WE DO NOW
	BR	SYMSR8			;CONTINUE

;HERE IF MATCH ON GLOBAL SYMBOL

SYMSR6:	MOV	BSTGLB,R3		;ALREADY HAVE A GLOBAL MATCH?
	BNE	SYMSR7			;YES-GO CHECK SOME MORE
	MOV	R1,BSTGLB		;NO-STORE THIS MATCH
	BR	SYMSR8			;CONTINUE

;HERE FOR REMOTE OR GLOBAL MATCH IF ALREADY HAVE REMOTE OR GLOBAL MATCH

SYMSR7:	CMP	.SYVAL(R3),.SYVAL(R1)	;SAME VALUE?
	BNE	SYMABG			;NO-ERROR
	MOV	.SYBTS(R3),R3		;MAYBE
	MOV	.SYBTS(R1),-(SP)	;IS AC FLAG THE SAME FOR BOTH?
	XOR	R3,(SP)
	TBBE	$AC,(SP)+,SYMSR8	;YES-GO ON
SYMABG:	MOV	#AMBGMS-MSGBAS,R0	;NO-SAY ITS AMBIGUOUS
	BR	GETAOS

;HERE TO STEP TO NEXT SYMBOL TABLE ENTRY

SYMSR8:	ADD	#.SYSIZ,R1		;BUMP POINTER
	SOB	R2,SYMSR0		;LOOP IF MORE TO CHECK
	MOV	BSTGLB,R1		;DID WE GET A MATCH ON A GLOBAL SYMBOL?
	BNE	SYMSR9			;YES-GO USE IT
	MOV	BSTRMT,R1		;DID WE GET A MATCH ON A LOCAL SYMBOL
					;  FROM OTHER THAN THE CURRENT PROGRAM?
	BEQ	UNDSYM			;NO-GO COMPLAIN ABOUT UNDEFINED SYMBOL

;HERE WITH SYMBOL MATCH

SYMSR9:	MOV	.SYBTS(R1),R2		;GET BITS FOR SYMBOL
	MOV	.SYVAL(R1),R1		;GET VALUE OF SYMBOL
	BR	RT4CC2			;AND GIVE GOOD RETURN

;HERE IF SYMBOL NOT DEFINED

UNDSYM:	MOV	#UNDFMS-MSGBAS,R0	;COMPLAIN
GETAOS:	JSR	PC,OUTSTR
RT4CS2:	SEC
	RTS	PC

;HERE IF ATOM STARTED WITH % - THIS MUST BE AN AC NUMBER

GETAAC:	JSR	PC,GETCHR		;GET NEXT CHARACTER
	CMP	#'0,R0			;DIGIT?
	BGT	ILLNUM			;NO-ERROR
	CMP	#'7,R0
	BLT	ILLNUM
	JSR	PC,GETA02		;GET VALUE
	BIT	#177770,R1		;VALID AC NUMBER?
	BNE	ILLNUM			;NO-ERROR
	MOV	#$AC,R2			;INDICATE THIS IS AN AC VALUE
RT4CC2:	CLC
	RTS	PC

;HERE IF ILLEGAL NUMBER

ILLNUM:	MOV	#ILNMMS-MSGBAS,R0	;COMPLAIN
	BR	GETAOS

;HERE TO INPUT VALUE OF TWO ASCII CHARACTERS

GETAST:	JSR	PC,GETCHR		;GET FIRST CHARACTER
	BLE	GETAIS			;ERROR IF END
	PUSH	R0			;SAVE CHARACTER
	JSR	PC,GETCHR		;GET SECOND CHARACTER
	BLE	GETAIS			;ERROR IF END
	SWAB	R0			;GET IN RIGHT PLACE
	BIS	R0,(SP)			;MERGE WITH FIRST CHARACTER
	BR	GETAS4			;CONTINUE

;HERE TO INPUT VALUE OF ASCII CHARACTER

GETASC:	JSR	PC,GETCHR		;GET A CHARACTER
	BLE	GETAIS			;ERROR IF END
	PUSH	R0			;SAVE IT
GETAS4:	JSR	PC,GETCHR		;GET NEXT CHARACTER
	POP	R1			;GET VALUE IN RIGHT PLACE
GETA8B:	JMP	GETA28			;AND GO RETURN IT

;HERE TO INPUT 3 CHARACTERS AS A RADIX 50 WORD

GETARX:	CLR	R5			;CLEAR AC TO RECEIVE DATA
	JSR	PC,CHARAX		;GET RADIX 50 CHARACTER
	BCS	RT4008			;IF ERROR
	MOV	R0,R5			;SAVE FIRST CHARACTER
	MUL	#<50*50>,R5		;GET IN RIGHT PLACE
	JSR	PC,CHARAX		;GET NEXT CHARACTER
	BCS	RT4008			;IF ERROR
	MUL	#50,R0			;PUT IN RIGHT PLACE
	ADD	R1,R5			;ADD IT IN
	JSR	PC,CHARAX		;GET FINAL CHARACTER
	BCS	RT4008			;IF ERROR
	ADD	R0,R5			;ADD IN THE FINAL CHARACTER
	JSR	PC,GETCHR		;GET NEXT CHARACTER
	MOV	R5,R1			;GET VALUE IN RIGHT AC
	BR	GETA8B			;AND GO RETURN IT

;SUBROUTINE CALLED FROM ABOVE TO GET RADIX 50 CHARACTER
;	JSR	PC,CHARAX
;	C(R0) = CHARACTER (RADIX 50 CODE)
;	C:SET = ERROR

CHARAX:	JSR	PC,CHARAN		;GET RADIX 50 CHARACTER
	BVC	RT4CC2			;OK IF VALID RADIX 50 CHARACTER
	CMP	#SPA,R0			;SPACE IS VALID TOO HERE
	BNE	CHARX2			;ERROR IF NOT SPACE
	CLR	R0			;SPACE = 0
RT4008:	RTS	PC			;RETURN

;HERE IF INVALID RADIX 50 CHARACTER

CHARX2:	MOV	#BDCHMS-MSGBAS,R0	;COMPLAIN
	BR	GETAOS			;AND RETURN WITH C SET
	.PAGE
;SUBROUTINE TO FETCH SYMBOL NAME FROM ASCIZ STRING
;	JSR	PC,GETR50
;	C(R0) = TERMINATING CHARACTER
;	C(R4) = FIRST PART OF ATOM (RADIX 50)
;	C(R5) = SECOND PART OF ATOM (RADIX 50)
;	C:SET = ERROR

GETR50:	JSR	PC,GETAM3		;GET FIRST PART OF ATOM
	BCS	RT4004			;IF ERROR
	BVC	GETAM1			;CONTINUE IF MORE
	MOV	R5,R4			;STORE FIRST PART IN RIGHT PLACE
	CLR	R5			;FINISHED-CLEAR 2ND HALF
RT4004:	RTS	PC			;RETURN

;HERE IF THERE ARE MORE THAN 3 CHARACTERS IN THE ATOM

GETAM1:	MOV	R5,R4			;PUT FIRST PART IN RIGHT PLACE
	JSR	PC,GETAM3		;GET SECOND PART
	BCS	GETAIS			;IF ERROR
	BVS	RT4004			;OK IF LESS THAN 6 CHARACTERS
	JSR	PC,CHARAN		;GET ANOTHER CHARACTER
	BVS	RT4004			;OK IF EXACTLY 6 CHARACTERS

GETAIS:	MOV	#SYNEMS-MSGBAS,R0	;ERROR-COMPLAIN
	JSR	PC,OUTSTR
	SEC
	RTS	PC

;SUBROUTINE USED BY GETATM TO FETCH EACH HALF OF THE ATOM
;	C(R1) = ADDRESS OF FIRST CHARACTER TO FETCH
;	JSR	PC,GETAM3
;	C(R0) = TERMINATING CHARACTER IF LESS THAN 3 CHARACTERS
;	C(R5) = RADIX 50 PACKED OUTPUT
;	S:SET = ERROR
;	V:SET = ATOM CONTAINS 3 CHARACTERS OR LESS

GETAM3:	CLR	R5			;CLEAR AC INCASE ATOM IS NULL
	JSR	PC,CHARAN		;GET CHARACTER
	BVS	RT4004			;IF INVALID CHARACTER
	MOV	R0,R5			;GET IN RIGHT AC
	MUL	#<50*50>,R5		;GET CHARACTER IN RIGHT PLACE
	JSR	PC,CHARAN		;GET NEXT CHARACTER
	BVS	RT4004			;IF INVALID CHARACTER
	PUSH	R1			;SAVE R1
	MUL	#50,R0			;PUT IN RIGHT PLACE IN THE WORD
	ADD	R1,R5			;ADD IN
	POP	R1			;RESTORE R1
	JSR	PC,CHARAN		;GET LAST CHARACTER
	BVS	RT4004			;IF NOT VALID CHARACTER
	ADD	R0,R5			;ADD IN CHARACTER
	.WORD	243			;CLC!CLV
	RTS	PC			;RETURN

;SUBROUTINE TO FETCH ALPHA-NUMERIC CHARACTER AS RADIX 50 CODE
;	C(R1) = ADDRESS OF CHARACTER
;	JSR	PC,CHARAN
;	C:SET = ERROR
;	V:SET = INVALID CHARACTER
;	C(R0) = CHARACTER
;	C(R1) = ADDRESS OF NEXT CHARACTER

CHARAN:	JSR	PC,GETCHU		;GET CHARACTER
	BLE	RT4SV5			;IF END OF LINE
	CMP	#'0,R0			;IS IT A DIGIT?
	BGT	CHARA1			;NO
	CMP	#'9,R0			;MAYBE
	BLT	CHARA1			;NO
	SUB	#22,R0			;YES-CONVERT TO RADIX 50 CODE
	BR	CHARAR			;AND RETURN

;HERE IF NOT A DIGIT

CHARA1:	CMP	#'$,R0			;IS IT $ ?
	BNE	CHARA2			;NO
	MOV	#33,R0			;YES-GET RADIX 50 VALUE
	BR	CHARAR			;AND RETURN WITH IT

CHARA2:	CMP	#'.,R0			;IS IT PERIOD?
	BNE	CHARA3			;NO
	MOV	#34,R0			;YES-GET RADIX 50 VALUE
	BR	CHARAR			;AND RETURN WITH IT

CHARA3:	CMP	#'A,R0			;IS IT A LETTER?
	BGT	RT4SV5			;NO
	CMP	#'Z,R0			;MAYBE
	BLT	RT4SV5			;NO
	BIC	#^C77,R0		;YES-CONVERT TO RADIX 50 CODE
CHARAR:	TST	R0
RT4007:	RTS	PC

RT4SV5:	SEV
	RTS	PC

;SUBROUTINE TO GET UPPER CASE CHARACTER
;	JSR	PC,GETCHU
;	C(R0) = CHARACTER
;	C(R1) = ADDRESS OF NEXT CHARACTER

GETCHU:	JSR	PC,GETCHR		;GET CHARACTER
	BLE	RT4007			;IF END OF LINE
	CMP	#140,R0			;IS IT LOWER CASE?
	BGT	RT4007			;NO-JUST RETURN
	CMP	#172,R0			;MAYBE
	BLT	RT4007			;NO
	BIC	#40,R0			;YES-MAKE UPPER CASE
	RTS	PC			;RETURN
	.PAGE
;SUBROUTINE TO GET ADDRESS TO EXAMINE FROM CURRENTLY OPEN LOCATION
;	JSR	PC,GETADR
;	C:SET = ERROR
;	C(R0) = ADDRESS
;	C(R1) = BITS

GETADR:	CLR	R1			;ASSUME NOT AC
	TBBN	$USSRC,FLAG1,GETAD2	;WANT TO USE SOURCE ADDRESS?
	TBBE	$DSTOK,FLAGW,GETAER	;NO-FAIL IF DST FIELD NOT VALID
	MOV	DSTFLD,R0		;GET VALUE OF FIELD
	TBBN	$DSTAC,FLAGW,GETAXX	;IF AC NUMBER
RT4CC9:	CLC
	RTS	PC

;HERE IF WANT SROUCE FIELD

GETAD2:	TBBE	$SRCOK,FLAGW,GETAER	;ERROR IF FIELD NOT VALID
	MOV	SRCFLD,R0		;GET VALUE
	TBBE	$SRCAC,FLAGW,RT4CC9	;FINISHED IF NOT AC NUMBER
GETAXX:	MOV	#$AC,R1			;INDICATE VALUE IS AC NUMBER
	BR	RT4CC9			;RETURN

;HERE IF ERROR

GETAER:	JMP	SYMABG
	.PAGE
.IF EQ ..EIS				;ONLY IF DO NOT HVAE EIS!!

;SUBROUTINE TO SIMULATE "XOR" INSTRUCTION
;	PUSH	SRC
;	PUSH	R
;	CALL	XORSUB
;	POP	R

XORSUB:	PUSH	2(SP)
	BIS	6(SP),(SP)
	COM	4(SP)
	BIC	4(SP),6(SP)
	BIC	6(SP),(SP)
	POP	4(SP)
	POP	(SP)
	RETURN

;SUBROUTINE TO SIMULATE "MUL" INSTRUCTION
;	PUSH	SRC
;	PUSH	R
;	CALL	MULSUB
;	POP	R
;	POP	R!1

MULSUB:	PUSH	R0			;SAVE THE OUTSIDE WORLD
	PUSH	R1
	PUSH	R2
	PUSH	R3
	PUSH	R4
	CLR	-(SP)			;CLEAR THE SIGN FLAG
	MOV	20(SP),R3		;GET SRC
	BPL	1$			;OK IF +
	NEG	R3			;MAKE +
	INC	(SP)			;REMEMBER IT WAS -
1$:	MOV	16(SP),R2		;GET R
	BPL	2$			;OK IF +
	NEG	R2			;MAKE +
	INC	(SP)			;REMEMBER IT WAS -
2$:	CLR	R0			;CLEAR REGISTERS FOR RESULT
	CLR	R1
	MOV	#16.,R4			;INITIALIZE THE STEP COUNTER
4$:	ROR	R3			;GET A BIT
	BCC	6$			;IF 0
	ADD	R2,R0			;IF 1
6$:	ROR	R0			;SHIFT RESULT
	ROR	R1
	DEC	R4			;MORE?
	BGT	4$			;YES-CONTINUE
	ROR	(SP)+			;SHOULD RESULT BE -?
	BCC	10$			;NO
	COM	R0			;YES-MAKE IT -
	COM	R1
	ADD	#1,R1
	ADC	R0
10$:	MOV	R0,14(SP)		;RETURN RESULT
	MOV	R1,16(SP)
	POP	R4			;RESTORE THE STATE OF THE WORLD
	POP	R3
	POP	R2
	POP	R1
	POP	R0
	RETURN				;THATS ALL!!

;SUBROUTINE TO SIMULATE "DIV" INSTRUCTION
;	PUSH	SRC
;	PUSH	R
;	PUSH	R!1
;	CALL	DIVSUB
;	POP	R
;	POP	R!1

DIVSUB:	PUSH	R0			;SAVE THE WORLD
	PUSH	R1
	PUSH	R2
	PUSH	R3
	PUSH	R4
	CLR	-(SP)			;CLEAR THE SIGN FLAG
	MOV	22(SP),R2		;GET SRC
	BPL	1$			;OK IF +
	NEG	R2			;MAKE +
	INC	(SP)			;REMEMBER IT WAS -
1$:	MOV	16(SP),R1		;GET R
	MOV	20(SP),R0
	BPL	2$			;OK IF +
	COM	R0			;MAKE -
	COM	R1
	ADD	#1,R1
	ADC	R0
	INC	(SP)			;REMEMBER IT WAS -
2$:	CLR	R3			;CLEAR FOR RESULT
	MOV	#16.,R4			;INITIALIZE THE STEP COUNTER
4$:	CLC
	ROL	R3
	CLC
	ROL	R1
	ROL	R0
	CMP	R0,R2			;SHOULD WE SUBTRACT?
	BLO	6$			;NO
	SUB	R2,R0			;YES
	INC	R3			;PUT A BIT IN THE RESULT
6$:	DEC	R4			;MORE?
	BGT	4$			;YES
	ROR	(SP)+			;SHOULD RESULT BE -?
	BCC	12$			;NO
	NEG	R3			;YES
12$:	TST	16(SP)			;SHOULD REMAINDER BE -?
	BPL	14$			;NO
	NEG	R0			;YES
14$:	MOV	R3,16(SP)		;STORE RESULT
	MOV	R0,20(SP)		;AND REMAINDER
	POP	R4			;RESTORE THE STATE OF THE WORLD
	POP	R3
	POP	R2
	POP	R1
	POP	R0
	POP	(SP)			;FIX UP THE RETURN
	RETURN				;FINISHED AT LAST!!

.ENDC	;  .IF EQ ..EIS
	.PAGE
	.SBTTL	XDT5 - TEXT STRINGS

.IF EQ ..CTY
IDMESS:	.ASCII	"XDT"
.IFF
  .IF EQ ..PIC
	PURE				;PROTECT THIS DATA
  .ENDC
IDMESS:	.ASCII	"XDT (EXEC)"
.ENDC
	.ASCIZ	"  V1.3"
NTSGMS:	.ASCIZ	<15><12>"? Address must be one word value"
OFWSMS:	.ASCIZ	"% Only first word stored"<15><12>
TRUNMS:	.ASCIZ	"% Only 8 bits stored"<15><12>
NILNMS:	.ASCIZ	"% New item longer than old"<15><12>
NISTMS:	.ASCIZ	"% New item shorter than old"<15><12>
WRDSMS:	.ASCIZ	", "
ADFLMS:	.ASCIZ	"? Address stack full"
NOADMS:	.ASCIZ	"? Address stack empty"
PRFXMS:	.ASCIZ	<15><12>"%%% "
UKBPMS:	.ASCIZ	"Unexpected breakpoint at "
BKPTMS:	.ASCIZ	"Breakpoint at "
BKP2MS:	.ASCIZ	"; PSW = "
SNGIMS:	.ASCIZ	"PC = "
CNPRMS:	.ASCIZ	"? Cannot proceed"
BDSAMS:	.ASCIZ	"? Illegal starting address"
BPL1MS:	.ASCIZ	<15><12>"	Cnt = "
BPL2MS:	.ASCIZ	" 	Addr = "
BKPTHD:	.ASCIZ	<15><12><15><12>"Breakpoints:"
PRGMHD:	.ASCIZ	<15><12>"Program:  "
QUESHD:	.ASCII	<15><12><15><12>"Symbol	Prgm	     Value"
CRLFM:	.ASCIZ	<15><12>
MOD3MS:	.ASCIZ	"@#"
BSSPBS:	.ASCIZ	<BS><SPA><BS>
CNTUMS:	.ASCIZ	" XXX	"
BDADMS:	.ASCIZ	" ??A	"
BKERMS:	.ASCIZ	" ??B	"
BDCHMS:	.ASCIZ	" ??C	"
STFLMS:	.ASCIZ	" ??F	"
AMBGMS:	.ASCIZ	" ??M	"
ILNMMS:	.ASCIZ	" ??N	"
OPERMS:	.ASCIZ	" ??O	"
SYNEMS:	.ASCIZ	" ??S	"
UNDFMS:	.ASCIZ	" ??U	"
	.EVEN
	.PAGE
	.SBTTL	XDT5 - XDT TABLES

;SYMBOL TRANSLATE TABLES

;FORMAT OF THE TABLES:
;  EACH LEVEL OF TABLE IS INDEXED BY A FIELD EXTRACTED FROM THE INSTRUCTION
;  WORD.  THE INSTRUCTION IS DIVIDED AS FOLLOWS:
;	LEVEL 0   BITS 15-12
;	LEVEL 1   BITS 11- 8
;	LEVEL 2   BITS  7- 6
;	LEVEL 3   BITS  5- 3
;	LEVEL 4   BITS  2- 0

;EACH TABLE ENTRY IS ONE BYTE ENCODED AS FOLLOWS:
;	  0     = INSTRUCTION IS UNDEFINED
;	  1-177 = INDEX OF NEXT TABLE TO USE
;	200-377 = INDEX OF INSTRUCTION SYMBOL ENTRY

;FOR EXAMPLE, SINCE THE "MOV" INSTRUCTION IS DEFINED BY ONLY THE LEFT-MOST
;  4 BITS, THE CORRESPONDING ENTRY IN THE LEVEL 0 TABLE POINTS DIRECTLY TO
;  THE INSTRUCTION SYMBOL ENTRY FOR "MOV".  ON THE OTHER HAND, THE "HALT"
;  INSTRUCTION IS DEFINED BY ALL 16 BITS IN THE INSTRUCTION, REQUIRING
;  REFERENCES TO ALL LEVEL OF TABLES.  THE LEVEL 4 TABLE FINALLY CONTAINS
;  THE INDEX OF THE "HALT" INSTRUCTION SYMBOL ENTRY.

;DEFINE MACRO USED TO DEFINE INDEX FOR EACH TABLE

	.MACRO	STAB	S
S=<.-STBGN+2>/2
	.ENDM

;FIRST TABLE IS INDEXED BY THE FIRST 4 BITS OF THE INSTRUCTION

ST:	.BYTE	ST00		;GROUP 00
	.BYTE	XMOV
	.BYTE	XCMP
	.BYTE	XBIT
	.BYTE	XBIC
	.BYTE	XBIS
	.BYTE	XADD
	.BYTE	ST07		;GROUP 07 (MOSTLY EIS)
	.BYTE	ST10		;GROUP 10
	.BYTE	XMOVB
	.BYTE	XCMPB
	.BYTE	XBITB
	.BYTE	XBICB
	.BYTE	XBISB
	.BYTE	XSUB
	.BYTE	0

STBGN=.

;THE FOLLOWING TABLES ARE INDEXED BY BITS 11-8 OF THE INSTRUCTION

;TABLE FOR GROUP 0

	STAB	ST00
	.BYTE	ST0000		;GROUP 0000
	.BYTE	XBR
	.BYTE	XBNE
	.BYTE	XBEQ
	.BYTE	XBGE
	.BYTE	XBLT
	.BYTE	XBGT
	.BYTE	XBLE
	.BYTE	XJSR
	.BYTE	XJSR
	.BYTE	ST0050		;GROUP 0050
	.BYTE	ST0054		;GROUP 0054
	.BYTE	ST0060		;GROUP 0060
	.BYTE	ST0064		;GROUP 0064
	.BYTE	0
	.BYTE	0

;TABLE FOR GROUP 7

	STAB	ST07
	.BYTE	XMUL
	.BYTE	XMUL
	.BYTE	XDIV
	.BYTE	XDIV
	.BYTE	XASH
	.BYTE	XASH
	.BYTE	XASHC
	.BYTE	XASHC
	.BYTE	XXOR
	.BYTE	XXOR
	.BYTE	ST0750		;GROUP 0750 (FLOATING POINT)
	.BYTE	0
	.BYTE	0
	.BYTE	0
	.BYTE	XSOB
	.BYTE	XSOB

;TABLE FOR GROUP 010

	STAB	ST10
	.BYTE	XBPL
	.BYTE	XBMI
	.BYTE	XBHI
	.BYTE	XBLOS
	.BYTE	XBVC
	.BYTE	XBVS
	.BYTE	XBCC
	.BYTE	XBCS
	.BYTE	XEMT
	.BYTE	XTRAP
	.BYTE	ST1050		;GROUP 1050
	.BYTE	ST1054		;GROUP 1054
	.BYTE	ST1060		;GROUP 1060
	.BYTE	ST1064		;GROUP 1064
	.BYTE	0
	.BYTE	0

;FOLLOWING TABLES ARE INDEXED BY BITS 7-6 OF THE INSTRUCTION WORD

;TABLE FOR 0000

	STAB	ST0000
	.BYTE	STOPR		;GROUP OPR (OPERATE TYPE INSTUCTIONS)
	.BYTE	XJMP
	.BYTE	STRTS		;GROUP RTS
	.BYTE	XSWAB

;TABLE FOR GROUP 0050

	STAB	ST0050
	.BYTE	XCLR
	.BYTE	XCOM
	.BYTE	XINC
	.BYTE	XDEC

;TABLE FOR GROUP 0054

	STAB	ST0054
	.BYTE	XNEG
	.BYTE	XADC
	.BYTE	XSBC
	.BYTE	XTST

;TABLE FOR GROUP 0060

	STAB	ST0060
	.BYTE	XROR
	.BYTE	XROL
	.BYTE	XASR
	.BYTE	XASL

;TABLE FOR GROUP 0064

	STAB	ST0064
	.BYTE	XMARK
	.BYTE	0
	.BYTE	0
	.BYTE	XSXT

;TABLE FRO GROUP 0750

	STAB	ST0750
	.BYTE	STFLT		;GROUP FLT (FLOATING POINT)
	.BYTE	0
	.BYTE	0
	.BYTE	0

;TABLE FOR GROUP 1050

	STAB	ST1050
	.BYTE	XCLRB
	.BYTE	XCOMB
	.BYTE	XINCB
	.BYTE	XDECB

;TABLE FOR GROUP 1054

	STAB	ST1054
	.BYTE	XNEG
	.BYTE	XADCB
	.BYTE	XSBCB
	.BYTE	XTSTB

;TABLE FOR GROUP 1060

	STAB	ST1060
	.BYTE	XRORB
	.BYTE	XROLB
	.BYTE	XASRB
	.BYTE	XASLB

;TABLE FOR GROUP 1064

	STAB	ST1064
	.BYTE	XMTPS
	.BYTE	0
	.BYTE	0
	.BYTE	XMFPS

;FOLLOWING TABLES ARE INDEXED BY BITS 5-3 OF THE INSTRUCTION WORD

	STAB	STOPR
	.BYTE	STOPRA
	.BYTE	0
	.BYTE	0
	.BYTE	0
	.BYTE	0
	.BYTE	0
	.BYTE	0
	.BYTE	0

	STAB	STRTS
	.BYTE	XRTS
	.BYTE	0
	.BYTE	0
	.BYTE	0
	.BYTE	STCON4
	.BYTE	STCON5
	.BYTE	STCON6
	.BYTE	STCON7

	STAB	STFLT
	.BYTE	XFADD
	.BYTE	XFSUB
	.BYTE	XFMUL
	.BYTE	XFDIV
	.BYTE	0
	.BYTE	0
	.BYTE	0
	.BYTE	0

;FOLLOWING TABLES ARE INDEXED BY BITS 2-0 OF THE INSTRUCTION

	STAB	STOPRA
	.BYTE	XHALT
	.BYTE	XWAIT
	.BYTE	XRTI
	.BYTE	XBPT
	.BYTE	XIOT
	.BYTE	XRESET
	.BYTE	XRTT
	.BYTE	0

	STAB	STCON4
	.BYTE	XNOP
	.BYTE	XCLC
	.BYTE	XCLV
	.BYTE	XCLCV
	.BYTE	XCLZ
	.BYTE	XCLCZ
	.BYTE	XCLVZ
	.BYTE	XCLCVZ

	STAB	STCON5
	.BYTE	XCLN
	.BYTE	XCLCN
	.BYTE	XCLVN
	.BYTE	XCLCVN
	.BYTE	XCLZN
	.BYTE	XCLCZN
	.BYTE	XCLVZN
	.BYTE	XCCC

	STAB	STCON6
	.BYTE	XNOP
	.BYTE	XSEC
	.BYTE	XSEV
	.BYTE	XSECV
	.BYTE	XSEZ
	.BYTE	XSECZ
	.BYTE	XSEVZ
	.BYTE	XSECVZ

	STAB	STCON7
	.BYTE	XSEN
	.BYTE	XSECN
	.BYTE	XSEVN
	.BYTE	XSECVN
	.BYTE	XSEZN
	.BYTE	XSECZN
	.BYTE	XSEVZN
	.BYTE	XSCC

	.PAGE
;GENERATE THE INSTRUCTION SYMBOL TABLE
;  FORMAT OF TABLE:
;	WORD 0/	1ST HALF OF NAME (RADIX 50)
;	WORD 1/	2ND HALF OF NAME (RADIX 50)
;	WORD 2/	INDEX FOR INPUT AND OUTPUT DISPATCH TABLES
;	WORD 3/	VALUE OF OP-CODE

	.MACRO	INSM	VAL,INS,INDX
X'INS=<.-INBGN>/10+200
$L=.
	.RAD50	/INS/
.IF EQ .-$L-2
	.WORD	0
.ENDC
	.WORD	INDX
	.WORD	VAL
	.ENDM

INBGN=.
	INSM	005500,ADC   ,DD
	INSM	105500,ADCB  ,DD
	INSM	060000,ADD   ,SSDD
	INSM	072000,ASH   ,RSS
	INSM	073000,ASHC  ,RSS
	INSM	006300,ASL   ,DD
	INSM	106300,ASLB  ,DD
	INSM	006200,ASR   ,DD
	INSM	106200,ASRB  ,DD
	INSM	103000,BCC   ,XB
	INSM	103400,BCS   ,XB
	INSM	001400,BEQ   ,XB
	INSM	002000,BGE   ,XB
	INSM	003000,BGT   ,XB
	INSM	101000,BHI   ,XB
	INSM	103000,BHIS  ,XB
	INSM	040000,BIC   ,SSDD
	INSM	140000,BICB  ,SSDD
	INSM	050000,BIS   ,SSDD
	INSM	150000,BISB  ,SSDD
	INSM	030000,BIT   ,SSDD
	INSM	130000,BITB  ,SSDD
	INSM	003400,BLE   ,XB
	INSM	103400,BLO   ,XB
	INSM	101400,BLOS  ,XB
	INSM	002400,BLT   ,XB
	INSM	001000,BNE   ,XB
	INSM	100400,BMI   ,XB
	INSM	100000,BPL   ,XB
	INSM	000003,BPT   ,NONE
	INSM	000400,BR    ,XB
	INSM	102000,BVC   ,XB
	INSM	102400,BVS   ,XB
	INSM	000257,CCC   ,NONE
	INSM	000241,CLC   ,NONE
	INSM	000251,CLCN  ,NONE
	INSM	000243,CLCV  ,NONE
	INSM	000253,CLCVN ,NONE
	INSM	000247,CLCVZ ,NONE
	INSM	000245,CLCZ  ,NONE
	INSM	000255,CLCZN ,NONE
	INSM	000250,CLN   ,NONE
	INSM	005000,CLR   ,DD
	INSM	105000,CLRB  ,DD
	INSM	000242,CLV   ,NONE
	INSM	000252,CLVN  ,NONE
	INSM	000246,CLVZ  ,NONE
	INSM	000256,CLVZN ,NONE
	INSM	000244,CLZ   ,NONE
	INSM	000254,CLZN  ,NONE
	INSM	020000,CMP   ,SSDD
	INSM	120000,CMPB  ,SSDD
	INSM	005100,COM   ,DD
	INSM	105100,COMB  ,DD
	INSM	005300,DEC   ,DD
	INSM	105300,DECB  ,DD
	INSM	071000,DIV   ,RSS
	INSM	104000,EMT   ,NNN
	INSM	075000,FADD  ,R
	INSM	075030,FDIV  ,R
	INSM	075020,FMUL  ,R
	INSM	075010,FSUB  ,R
	INSM	000000,HALT  ,NONE
	INSM	005200,INC   ,DD
	INSM	105200,INCB  ,DD
	INSM	000004,IOT   ,NONE
	INSM	000100,JMP   ,DD
	INSM	004000,JSR   ,RDD
	INSM	006400,MARK  ,NN
	INSM	106700,MFPS  ,DD
	INSM	010000,MOV   ,SSDD
	INSM	110000,MOVB  ,SSDD
	INSM	106400,MTPS  ,SS
	INSM	070000,MUL   ,RSS
	INSM	005400,NEG   ,DD
	INSM	105400,NEGB  ,DD
	INSM	000240,NOP   ,NONE
	INSM	000005,RESET ,NONE
	INSM	006100,ROL   ,DD
	INSM	106100,ROLB  ,DD
	INSM	006000,ROR   ,DD
	INSM	106000,RORB  ,DD
	INSM	000002,RTI   ,NONE
	INSM	000200,RTS   ,R
	INSM	000006,RTT   ,NONE
	INSM	005600,SBC   ,DD
	INSM	105600,SBCB  ,DD
	INSM	000277,SCC   ,NONE
	INSM	000261,SEC   ,NONE
	INSM	000265,SECN  ,NONE
	INSM	000263,SECV  ,NONE
	INSM	000273,SECVN ,NONE
	INSM	000267,SECVZ ,NONE
	INSM	000265,SECZ  ,NONE
	INSM	000275,SECZN ,NONE
	INSM	000270,SEN   ,NONE
	INSM	000262,SEV   ,NONE
	INSM	000272,SEVN  ,NONE
	INSM	000266,SEVZ  ,NONE
	INSM	000276,SEVZN ,NONE
	INSM	000264,SEZ   ,NONE
	INSM	000274,SEZN  ,NONE
	INSM	077000,SOB   ,XS
	INSM	160000,SUB   ,SSDD
	INSM	000300,SWAB  ,DD
	INSM	006700,SXT   ,DD
	INSM	104400,TRAP  ,NNN
	INSM	005700,TST   ,DD
	INSM	105700,TSTB  ,DD
	INSM	000001,WAIT  ,NONE
	INSM	074000,XOR   ,RDD
NUMOPC=<.-INBGN>/10

;GENERATE DISPATCH TABLE FOR OPCODE INPUT AND OUTPUT

	.MACRO	TABLE
	XX	DD  ,XXIN  ,XXOUT
	XX	SS  ,XXIN  ,XXOUT
	XX	SSDD,SSDDIN,SSDDOU
	XX	RSS ,RSSIN ,RSSOUT
	XX	RDD ,RDDIN ,RDDOUT
	XX	R   ,REGIN ,REGOUT
	XX	XB  ,BRIN  ,BROUT
	XX	XS  ,SOBIN ,SOBOUT
	XX	NN  ,NNIN  ,NNOUT
	XX	NNN ,NNNIN ,NNNOUT
	XX	NONE,NONIN ,NONOUT
	.ENDM

	.MACRO	XX	A,B,C
A=.-INTBL
	.WORD	B-INTBAS
	.ENDM

INTBL:	TABLE

	.MACRO	XX	A,B,C
	.WORD	C-OUTBAS
	.ENDM

OUTTBL:	TABLE
	.PAGE
	.SBTTL	MICRONODE SYMBOL TABLE
.IF NE	..CTY

	.MACRO	SYMBOL,NAME,LOC
	.RAD50	/NAME/
	.WORD	$GLBL!$LABEL
 .IF NB	LOC
	.WORD	LOC'#
 .IFF
	.WORD	NAME'#
 .ENDC
	.ENDM

.IF EQ	..PIC
	PSECT	.SYM.  ,RW,D,GBL,REL,OVR
.ENDC

USYMBL:	.WORD	<SYMEND-USYMBL>/.SYSIZ	;LENGTH OF SYMBOL TABLE
	.WORD	<PATEND-SYMEND>/.SYSIZ	;LENGTH OF USED DEFINED SYMBOLS

	.RAD50	/MNODE /	;MICRO NODE PROGRAM TABLE
	.WORD	$PRGM		;PROGRAM SYMBOL
	.WORD	0		;VALUE 0

.IF EQ	..SAT
	SYMBOL	<SX    >
	SYMBOL	MAIN
	SYMBOL	SECOND
	SYMBOL	TENTHS
	SYMBOL	<DDB   >
	SYMBOL	<LDB   >,LDBBGN
	SYMBOL	<SDB   >
	SYMBOL	IMPURE,IMPBGN
	SYMBOL	PDATA
	SYMBOL	STKBGN
	SYMBOL	TRRNGT
	SYMBOL	MAINLP
	SYMBOL	PKTINI
	SYMBOL	MAKPAC
	SYMBOL	FREPAC
	SYMBOL	PKFLST
	SYMBOL	FRESOC
	SYMBOL	SNDPKT
.ENDC
SYMEND:	.BLKB	10.*.SYSIZ	;USER DEFINED SYMBOLS
PATEND:
.ENDC
	.PAGE
	.SBTTL	XDT5 - IMPURE STORAGE

.IF EQ	..PIC
	PSECT	PDATA ,RW,D,LCL,REL,CON
.ENDC
FLAG1:	.WORD	0		;FLAG WORD 1
FLAGT:	.BLKW	1		;TEMP. FLAGS
FLGTT:	.BLKW	1		;PLACE TO SAVE FLAGT WHILE TEMP. LOCATION IS
				;  OPEN
FLAGQ:	.BLKW	1		;PLACE TO SAVE $INSTR AND $BYTE
FLAGP:	.WORD	0		;PERM. FLAGS
WORD1:	.BLKW	1
WORD2:	.BLKW	1
WORD3:	.BLKW	1
WORDC:	.WORD	0
SIZEC:	.WORD	2		;SIZE OF CURRENT LOCATION
SIZEX:	.BLKW	1		;SIZE OF ITEM BEING INPUT
SIZET:	.BLKW	1		;PLACE TO SAVE SIZEC WHILE TEMP. LOCATION IS
				;  OPEN
ADDRES:	.BLKW	1		;ADDRESS TO EXAMINE
DOT:	.BLKW	1		;VALUE OF "."
BITS1:	.BLKW	1
BITSC:	.BLKW	1
BITSA:	.BLKW	1
ADRSTP:	.WORD	0		;ADDRESS STACK POINTER
ADRSTK:	.BLKW	ADSKSZ*3	;ADDRESS STACK
ADRSTE=.-2
SRCFLD:	.BLKW	1
SRCFLX:	.BLKW	1
DSTFLD:	.BLKW	1
DSTFLX:	.BLKW	1
INSWRD:	.BLKW	1		;SCRATCH FOR TYPINS
FIELD:	.BLKW	1		;SCRATCH FOR GETFLD
FBITS:	.BLKW	1		;SCRATCH FOR GETFLD
FLAGW:	.BLKW	1		;FLAG BITS FOR CURRENTLY OPEN INSTRUCTION
FLAGX:	.BLKW	1		;FLAG BITS FOR ITEM BEING INPUT
ACSAV0:	.BLKW	1		;USER AC 0
ACSAV1:	.BLKW	1		;USER AC 1
ACSAV2:	.BLKW	1		;USER AC 2
ACSAV3:	.BLKW	1		;USER AC 3
ACSAV4:	.BLKW	1		;USER AC 4
ACSAV5:	.BLKW	1		;USER AC 5
ACSAV6:	.BLKW	1		;USER AC 6 (STACK POINTER)
ACSAV7:	.BLKW	1		;USER AC 7 (PROGRAM COUNTER)
UPSW:	.BLKW	1		;USER PROGRAM STATUS WORD
.IF EQ ..CTY
SAVSTS:	.BLKW	1		;USER .JBSTS
.IFF
SAVKEY:	.BLKW	1		;CTY KEYBOARD STATUS
SAVXMT:	.BLKW	1		;CTY OUTPUT STATUS
.ENDC
SRCMSK:	.WORD	177777		;SEARCH MASK
LOWLIM:	.WORD	0		;LOW LIMIT FOR WORD SEARCH
HGHLIM:	.WORD	177776		;HIGH LIMIT FOR WORD SEARCH
BKPADR:	.REPT	NUMBKP		;BREAKPOINT ADDRESS TABLE
	.WORD	0
	.ENDR
BKPINS:	.BLKW	NUMBKP		;BREAKPOINT INSTRUCTION TABLE
BKPCNT:	.BLKW	NUMBKP		;BREAKPOINT PROCEED COUNT TABLE
SNGCNT:	.BLKW	1		;SINGLE INSTRUCTION REPEAT COUNT
RADIXT:	.WORD	8.		;CURRENT RADIX
RADIXP:	.WORD	8.		;PERIMENT RADIX
RADIX:	.WORD	8.		;INPUT RADIX
.IF NE ..CTY
HPOS:	.WORD	0		;HORIZONTAL POSITION ON LINE
.ENDC
BUFFER:	.BLKW	^D140/2		;BUFFER
BUFPNT:	.BLKW	1		;POINTER TO BUFFER
NUMPNT:	.BLKW	1		;POINTER TO START OF NUMBER
ITMPNT:	.BLKW	1		;POINTER TO START OF ITEM
OFFSET:	.WORD	777		;MAXIMUM OFFSET ALLOWED FOR SYMBOLIC OUTPUT
BSTLCL:	.BLKW	1		;BEST MATCH FOR LOCAL SYMBOL
BSTGLB:	.BLKW	1		;BEST MATCH FOR GLOBAL SYMBOL
BSTRMT:	.BLKW	1		;BEST MACTH FOR REMOTE SYMBOL
BSTDIF:	.BLKW	1
BSTSYM:	.BLKW	1		;MUST BE BSTDIF+2 (SEE CODE AT QUESTN)
FSTSYM:	.WORD	177777-.SYSIZ	;FIRST SYMBOL ENTRY FOR CURRENT PROGRAM
LSTSYM:	.WORD	177777-.SYSIZ	;LAST SYMBOL ENTRY FOR CURRENT PROGRAM
SYMBL1:	.BLKW	1		;LAST SYMBOL PROCESSED
SYMBL2:	.BLKW	1
XDTHGH=.-2			;HIGHEST ADDRESS IN XDT

.IF NE PATSIZ
.PAT.::	.BLKW	PATSIZ-1	;USER PATCH SPACE
.ENP.::	.BLKW	1
.ENDC

	.END
   &C5