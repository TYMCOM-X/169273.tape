	.TITLE	LKIPK1 - LINK I - TYMSHARE TYMNET II T.201 PROTOCOL - PACKET LEVEL ROUTINES
	.SBTTL	LKIPK1 - Nexilis/JRG Tymshare/DRE


	XLPAR
.HLIST=!1
	CODE

;DEFINE SYMBOLS FOR SOME UNUSED STANDARD ENTRIES

LKISTR==!0
LKILOD==!0

	.SBTTL	LKIINI - DDB INITALIZATION SUBROUTINE

;THIS SUBROUTINE IS CALLED BY THE START-UP ROUTINE IN EXEC TO INITIALIZE OUR
;  DDB'S - CALLED ONCE FOR EACH DDB - WE LOOP IN THIS ROUTINE FOR THE LDB'S
;	C(R4) = ADDRESS OF DDB
;	CALL	LKIINI

LKIINI::MOV	#DDLIFC#,R0		;CLEAR IMPURE PART OF DDB
	ADD	R4,R0
	MOV	#DDLICZ#,R2
2$:	CLR	(R0)+
	SOB	R2,2$
	MOV	DDLINN#(R4),R0		;GET NODE NUMBER OF SUP MESSAGES
	BIS	#^H8000,R0		;PUT IN ANTI ESCAPE BIT
	SWAB	R0			;GET INTO CORRECT ORDER
	MOV	R0,SUPNOD#
	MOV	DDLILD#(R4),R3		;GET FIRST LDB
4$:	MOV	#LDIFCL#,R0		;CLEAR COMMON INPURE PART OF LDB
	ADD	R3,R0
	MOV	#LDICSZ#,R2
10$:	CLR	(R0)+
	SOB	R2,10$
11$:	MOV	LDINXT#(R3),R0		; Get pointer to next LDB
	BEQ	14$			; No more LDBs
12$:	CMP	LDISTX#(R3),LDISTX#(R0)	; Is this the same type LDB?
	BEQ	14$			; Yes
	MOV	LDINXT#(R0),R0		; Get pointer to next LDB
	BNE	12$			; Check LDB if there is one
14$:	MOV	R0,LDINXS#(R3)		; Save it away
	CALL	@LDIINX#(R3)		;INITIALIZE THE LDB
	MOV	LDINXT#(R3),R3		;STEP TO NEXT LDB
	BNE	4$			;CONTINUE IF MORE
.IF EQ ..SAT
	MOV	#DDLIHD,R0		;MAKE POINTER TO THE HOST DESCRIPTORS
	ADD	R4,R0
	MOVB	DDLINH#(R4),R2		;SET COUNTER TO NUMBER OF HOSTS
	ASL	R2
20$:	BIC	#100000,(R0)+		;CLEAR THE ANSWERED BIT
	SOB	R2,20$			;CONTINUE IF MORE
.ENDC
	RETURN				;FINISHED
	.PAGE
	.SBTTL	LKIINS - SDB INITALIZATION SUBROUTINE

;THIS SUBROUTINE IS CALLED BY THE START-UP ROUTINE IN EXEC TO INITIALIZE OUR
;  SDB'S - CALLED ONCE FOR EACH SDB
;	C(R4) = ADDRESS OF DDB
;	C(SD) = ADDRESS OF SDB
;	CALL	LKIINS

LKIINS::MOV	#SDLIFC#,R2		;CLEAR IMPURE PART OF SDB
	ADD	SD,R2
	MOV	#SDLICZ#,R0
2$:	CLR	(R2)+
	SOB	R0,2$
RTN001:	RETURN				;THATS ALL
	.PAGE
	.SBTTL	LHRSUM - RESUME SUBROUTINE

;SUBROUTINE CALLED WHEN LINKED SOCKET IS READY TO RECEIVE AGAIN AFTER BEING
;  STOPPED
;	C(SD) = ADDRESS OF SDB
;	C(R4) = ADDRESS OF DDB
;	CALL	LHRSUM

;  THIS SUBROUTINE IS NOT USED BY THE TYPE H LINK SINCE FLOW CONTROL IS DONE
;  FOR ALL SOCKETS AT A REGULAR INTERVAL (1/2 SECOND).

LIRSUM::RETURN				;NOTHING NEEDED HERE!
	.PAGE
	.SBTTL	LIPOKE - POKE SUBROUTINE

;THIS SUBROUTINE IS CALLED BY SNDPKT WHEN A PACKET IS SENT TO AN IDLE SOCKET
;	C(R1) = ADDRESS OF PACKET TO SEND (PACKET IS ON DST LIST)
;	C(R4) = ADDDRES OF DDB
;	C(SD) = ADDDRES OF SDB FOR PACKET
;	CALL	LIPOKE

LIPOKE::MOVB	PKTYPE(R1),R0		;GET PACKET TYPE
	CMP	SDACNT#(SD),#2		;CAN WE SEND NORMAL PACKETS NOW?
	BGE	4$			;YES
	TSTB	TYPTBL(R0)		;NO-SHOULD THIS PACKET BE SENT ANYWAY?
	BPL	RTN001			;NO-FORGET IT FOR NOW!
4$:	MOV	SDLILD#(SD),R3		;OK TO SEND PACKET-GET LDB ADDRESS
	BNE	6$			;GO ON IF HAVE ONE NOW
	ASL	R0			;NO LDB-DISPATCH ON PACKET TYPE
	CALL	@NEWDSP(R0)		;Call routine for the packet
	MOV	SDPKDH#(SD),R1		;Any more packets now?
	BNE	LIPOKE			;Yes-go process next one
	RETURN				;Nope-finished for now

;HERE IF HAVE LDB LINKED TO THIS SDB

6$:	CMP	#-1,SDLKLK#(SD)		;ALREADY IN THE SEND LIST?
	BNE	LKIBGN			;YES
	MOV	LDIXLT#(R3),R2		;NO-LINK THIS SDB TO THE TAIL OF THE SEND
	BEQ	10$			;  LIST FOR THIS LDB
	MOV	SD,SDLKLK#(R2)
	BR	11$

10$:	MOV	SD,LDIXLH#(R3)
11$:	MOV	SD,LDIXLT#(R3)
	CLR	SDLKLK#(SD)
LKIBGN::TBBN	$L1BSY,LDIST1#(R3),RTN001;IS THIS LINE BUSY NOW?
	PUSH	R4			;DOES NOT RESPECT R4
	CALL	@LDISTX#(R3)		;NO-GO START IT UP (THIS ROUTINE WILL
					;  CALL US AT FILFRM)
	POP	R4
	RETURN
	.PAGE
;BIT TABLE INDEXED ON PACKET TYPE - SIGN BIT OF BYTE IF SET IF PACKET SHOULD BE
;  BE SENT EVEN IF SOCKET IS BEING HELD

	PURE

TYPTBL:	.BYTE	000		;.PTDAT =  0 - DATA PACKET
	.BYTE	200		;.PTCON =  1 - CONNECTION REQUEST
	.BYTE	200		;.PTACK =  2 - CONNECT ACK
	.BYTE	200		;.PTNAK =  3 - CONNECT NAK
	.BYTE	000		;.PTFUN =  4 - FUNCTION
	.BYTE	200		;.PTINT =  5 - INTERRUPT
	.BYTE	200		;.PTEAT =  6 - EAT
	.BYTE	000		;.PTDIS =  7 - DISCONNECT
	.BYTE	200		;.PTKIL = 10 - KILL CONNECTION
	.BYTE	200		;.PTDAK = 11 - DISCONNECT ACK

;PACKET TYPE DISPATCH TABLE FOR "NEW CIRCUITS"

	.EVEN
NEWDSP:	.WORD	NEWDAT		;.PTDAT =  0 - DATA PACKET
	.WORD	NEWCON		;.PTCON =  1 - CONNECTION REQUEST
.IF EQ ..SAT
	.WORD	NEWACK		;.PTACK =  2 - CONNECT ACK
	.WORD	NEWNAK		;.PTNAK =  3 - CONNECT NAK
.IFF
	.WORD	NEWZAP
	.WORD	NEWZAP
.ENDC
	.WORD	NEWFUN		;.PTFUN =  4 - FUNCTION
	.WORD	NEWFUN		;.PTINT =  5 - INTERRUPT
	.WORD	NEWZAP		;.PTEAT =  6 - EAT
	.WORD	NEWKIL		;.PTDIS =  7 - DISCONNECT
	.WORD	NEWKIL		;.PTKIL = 10 - KILL CONNECTION
	.WORD	NEWDAK		;.PTDAK = 11 - DISCONNECT ACK

	CODE
	.PAGE
	.SBTTL	NEWCON - Connection request on inactive SDB (new circuit)

;HERE FOR CONNECTION REQUEST ON "NEW CIRCUIT"

NEWCON:
	TST	DDLIUP#(R4)		;DO WE HAVE AN UPSTREAM LINE?
	BNE	2$			;YES-GO ON
1$:	MOV	#.ERGWD,R0		;NO-GET ERROR CODE
	BR	NEWCO9			;AND REFUSE THE CONNECTION


;HERE IF HAVE A PATH TO THE SUPERVISOR NOW

2$:	TSTB	PKDATA+27(R1)		;Is this a supervisory connection?
	BMI	1$			;Yes-THIS CAN HAPPEN IN A NETWORK WITH 
					;MULTIPLE GATEWAYS
	CLR	SDLIS1#(SD)		;INIT THE STATUS WORD
	CLR	SDLIHC#(SD)		;INIT CONNECTED HOST WORD
	CALL	REMOVE#			;Remove packet from DST list

.IF EQ ..SAT
;IF WE HAVE BASE SUPPORT WE MUST HANDLE "AUX-CIRCUIT" CONNECTIONS (THIS IS
;  ONE WHERE A PASSWORD WILL NOT BE REQUIRED)

	BITB	#020,PKDATA+35(R1)	;SHOULD THIS BE AN AUX CIRCUIT?
	BNE	NEWAUX			;YES
.ENDC
	BIS	#$I1CRD,SDLIS1#(SD)	;ASSUME CR DELAY FLAG SHOULD BE SET
	CALL	TYNGTT#			;GET TYMNET TERMINAL TYPE CODE
	BNE	6$			;GOT BACK A 0 TYPE, MUST BE HOST ORIGINATED
	MOV	#12.,R0			;DECLARE 1200 BAUD CIRCUIT
6$:	CMP	#4,R0			;SHOULD CR DELAY BE SET?
	BNE	8$			;YES
	BIC	#$I1CRD,SDLIS1#(SD)	;NO-CLEAR IT
8$:	CMP	#8.,R0			;IS THIS A SELECTRIC?
	BEQ	10$			;YES
	CMP	#9.,R0			;MAYBE
	BNE	14$			;NO
10$:	BIS	#$I1SEL,SDLIS1#(SD)	;YES-REMEMBER THAT
14$:	BITB	#002,PKDATA+35(R1)	;LOCAL COPY TERMINAL?
	BEQ	18$			;NO
	BIS	#$I1LCT,SDLIS1#(SD)	;YES-REMEMBER THAT
18$:	BITB	#040,PKDATA+35(R1)	;DOES HIS COMMAND DECODER HANDLE LOGIN
					;  STRINGS?
	BEQ	20$			;NO
	BIS	#$I1TCD,SDLIS1#(SD)	;YES-REMEMBER THAT
20$:
.IF EQ ..SAT
	PUSH	R1			;SAVE ADDRESS OF CONNECT PACKET
	MAKPKT	.PLSTP#			;GET ANOTHER PACKET
	BCS	30$			;COULDN'T GET ONE - HANDLE ERROR
	POP	SDLISC#(SD)		;REMEMBER ADDRESS OF CONNECT PACKET
.ENDC
	BIS	#300,R0			;MAGIC FOR THE SUPERVISOR!
	MOVB	R0,SDLISP#(SD)		;SAVE TERMINAL TYPE FOR WHEN WHOLE STRING ARRIVES
	MOV	#77777,SDACNT#(SD)	;TURN OFF "BACK-PRESSURE" SO WILL
					;  ACCEPT THE LOG-IN STRING
	MOV	#P.TYMS*400+155,R2	;ACCEPT THE CONNECTION
	CLR	R0
	CALL	ACCEPT#
	BR	NEWCDN			;REDUCE HIS PACKET COUNT AND RETURN

.IF EQ	..SAT
30$:	POP	R1			;RECOVER CONNECT PKT IF NO MORE PACKETS
	MOV	#.ERBFF,R0		;ERROR = BUFFER FULL
.ENDC
NEWCO9:	CALL	REFUSE#			;REFUSE THE CONNECTION
	CJMP	FRESOC#


;HERE TO BUILD AN AUX CIRCUIT

.IF EQ ..SAT
NEWPNF:	MOV	#.ERCRF,R0		;DECLARE PROTOCOL ERROR
	BR	NEWCO9			;AND REFUSE THE CONNECTION

NEWAUX:	MOV	R1,SDLISC#(SD)		;Save the connect packet
	CALL	FNDHST			;FIND THE SRC HOST IN OUR TABLE
	  BR	NEWPNF			;IF NOT THERE!
	TST	DDLISS#(R0)		;DO WE KNOW ABOUT THIS HOST
	BNE	NEWAU4			;YES, HANDLE NORMALLY
	CLRB	LKIMNC#			;NO, STIMULATE LOGIC TO TRY CONNECTING
	BR	NEWPNF			;REJECT REQUEST, SUP WILL NOT ACCEPT REQUEST FROM DOWN HOST
NEWAU4:	MOV	#^H8110,SUPMSG		;START MESSAGE HEADER
	MOVB	SDSOC#(SD),R1		;GET THE PORT NUMBER
	SWAB	R1
	MOV	R1,SUPMSG+2
	MOV	DDLIHD#(R0),R1		;GET HOST NUMBER
	MOV	R1,SDLIHC#(SD)		;SAVE AWAY FOR PSTAT COMMAND
	BIS	#^H8000,R1
	SWAB	R1
	MOV	R1,SUPMSG+4		;PUT HOST NUMBER IN MESSAGE
	MOV	#6,R0			;4 BYTE MESSAGE
	CALL	SNDSPR#			;SEND TO SUPERVISOR
	BIS	#$I1AUX,SDLIS1#(SD)	;INDICATE THIS IS AN AUX CIRCUIT
	CLRB	SDLISP#(SD)		;CLEAR THE SAVED TID
	MOV	#JIFX60#,R0		;SET 60 SECOND TIMER
	MOV	#LKIATO#,R1
	CALL	TIMREQ#
.ENDC
NEWCDN:	CJMP	DECPCN#			;REDUCE HIS PACKET COUNT AND RETURN
	.PAGE
	.SBTTL	NEWACK - Connect ACK on unused SDB (new circuit)

;Here for a CONNECT ACK packet - this should only get here for a supervisory
;  connection

.IF EQ ..SAT

NEWACK:	TBBN	$I1SPR,SDLIS1#(SD),2$	;Is this a supervisory connection?
	JMP	NEWZAP			;No

2$:	PUSHB	PKDATA+1(R1)		;Save flag byte
	CALL	JNKPKT#			;Give up the packet
	MOV	#77777,SDACNT#(SD)	;ACCEPT INPUT
	MOV	SDLIVH#(SD),R0		;GET INDEX AGAIN
	ADD	R4,R0			;PLUS BASE OF DDB
	MOV	DDLIHD#(R0),R2		;GET HOST NUMBER
	MOV	R2,SDLIVL#(SD)		;SAVE FOR LATER USE
	CALL	NWSSHT			;Declare host up but shut
	TSTB	(SP)+			;Is the host answered now?
	BPL	90$			;No-just send shut message
	JMP	NWSANS			;Declare host unshut
90$:	RETURN

;Here for connect NAK packet on "new circuit"

NEWNAK:	CALL	JNKPKT#			;Give up the packet
	TBBE	$I1SPR,SDLIS1#(SD),4$	;Is this a supervisory connection?
	CALL	LKINKL			;Yes-clean it up
4$:	CJMP	FRESOC#			;Give up the socket and return

.ENDC
	.PAGE
	.SBTTL	NEWDAT - Handle data packet on new circuit

;HERE FOR DATA PACKET ON "NEW CIRCUIT"

NEWDAT:	TBBN	$S1JNK,SDSTS1#(SD),NEWIGN;SHOULD WE JUNK THIS PACKET?
	MOVB	PKPNT(R1),R2		;NO-MAKE POINTER TO DATA IN PACKET
	BNE	1$
	INC	R2
	INCB	PKPNT(R1)
1$:	ADD	#PKDATA-1,R2
	ADD	R1,R2
	MOV	#SUPMSG#,R3		;POINT TO BEGINING OF MESSAGE BUFFER
	MOV	#.SMLGC,(R3)+		;USE CHARACTER MODE
	MOVB	#^H80,(R3)+
	MOVB	SDSOC#(SD),(R3)+	;PUT IN PORT NUMBER
	TSTB	SDLISP#(SD)		;DO WE HAVE A TID?
	BEQ	12$			;NO - JUST SEND CHARACTERS
	MOV	#.SMLGI,SUPMSG#		;YES - USE TID MODE 
	MOV	THOST#,R0		;GET TERMINAL HOST
	BIT	#^C^H0080,R0		;DO WE HAVE SOMETHING BESIDES ZERO
	BNE	11$			;GOT ONE USE IT
	MOV	#^HFFC0,R0		;FAKE UP HOST NUMBER
11$:	MOV	R0,(R3)+		;SET UP HOST NUMBER
	MOV	R3,FILSVA		;SAVE POINTER FOR STRING CALCULATION
	MOVB	SDLISP#(SD),(R3)+	;GET TID OUT OF SPECIAL HIDING PLACE
	CLRB	SDLISP#(SD)		;CLEAR FOR LATER PASSES
	BR	2$
12$:	MOV	R3,FILSVA		;SAVE POINTER FOR STRING CALCULATION
2$:	DECB	PKCNT(R1)		;MORE THERE?
	BLT	NEWIGN			;NO
	INCB	PKPNT(R1)
21$:	MOVB	(R2)+,R0		;YES-GET BYTE
	BIC	#^C177,R0		;ONLY 7 BITS
	CMP	#';,R0			;IS IT A SEMI-COLON?
	BEQ	NEWTRM			;YES
	CMP	#CR,R0			;OR A CR?
	BEQ	NEWTRM			;YES
	CMP	#ESC,R0			;NO-IS IT ESCAPE?
	BEQ	NEWFIN			;YES
	CMP	#BS,R0			;Check for CTL-H
	BNE	3$			;NO
	TBBN	$I1PWM,SDLIS1#(SD),3$	;YES - BUT DONT DO ANYTHING SPECIAL IF IN PASSWORD
	BIS	#$I1LCT,SDLIS1#(SD)	;REMEMBER THAT
3$:	BIS	#200,R0			;TURN ON HIGH BIT TO PREVENT ESCAPING
	MOVB	R0,(R3)+		;PUT CHAR IN PACKET
	CMP	#SUPMSG+4+39.,R3	;HAS THE USER EXCEEDED A LEGAL NAME OR PW
	BHIS	2$			;NO - GO HANDLE NEXT CHAR
	MOVB	#CR,R0			;FORM A TERMINATOR
	BR	NEWTRM			;FORCE THE STRING TO TERMINATE

;HERE TO GIVE UP THE INPUT PACKET - EITHER BECAUSE WE ARE FINISHED PROCESSING
;  IT OR BECAUSE WE WANT TO IGNORE IT

NEWIGN:	CJMP	JNKPKT#			;Give up the packet and return

;HERE WITH SEMI-COLON OR CR

NEWTRM:
.IF EQ ..SAT
	TST	SDLISC#(SD)		;YES-DO WE STILL HAVE A SAVED CONNECT?
	BEQ	NEWFIN			;NO-GO ON
	PUSH	R0			;YES-SAVE CURRENT STATE
	PUSH	R1
	PUSH	R2
	MOV	SDLISC#(SD),R1		;POINT TO SAVED CONNECT PACKET
	TSTB	PKDATA+2(R1)		;DO WE HAVE A DST EXTENSION?
	BEQ	40$			;NO-FORGET THIS JUNK
	MOVB	#':+200,(R3)+		;YES-SEND A COLON TO THE SUPERVISOR
	MOVB	PKDATA+1(R1),R2		;POINT TO DST EXTENSION
	ADD	R1,R2
	ADD	#PKDATA+24,R2
11$:	MOVB	(R2)+,(R3)+
	DECB	PKDATA+2(R1)		;MORE THERE?
	BGT	11$			;GO ON IF THERE ARE MORE CHARACTERS TO SEND
40$:	FREPKT				;FINISHED-GIVE UP THE CONNECT PACKET
	CLR	SDLISC#(SD)
	POP	R2			;RESTORE STATE
	POP	R1
	POP	R0			;RESTORE NEXT CHARACTER
.ENDC
NEWFIN:	BIS	#200,R0
	MOVB	R0,(R3)+		;PUT IN TERMINATOR
	BIT	#1,R3			;EVEN OR ODD NUMBER OF BYTES?
	BEQ	60$			;EVEN
	MOVB	R0,(R3)+		;PAD OUT ODD MESSAGE
60$:	MOV	R3,R0
	SUB	FILSVA,R3		;CALCULATE NUMBER OF CHARS IN SUP MSG
	BIS	#^H80,R3		;SET 80 BIT FOR NO IIX
	MOVB	R3,SUPMSG#+1
	SUB	#SUPMSG#,R0		;CALCULATE LENGTH OF ENTIRE MESSAGE
	PUSH	R1			;SAVE PACKET POINTER OVER CALL
	CALL	SNDSPR#
	POP	R1
	BIC	#$I1INX,SDLIS1#(SD)	;INDICATE NOT EXPECTING INPUT NOW
	CLR	SDACNT#(SD)		;HOLD THIS SOCKET FOR NOW
	TSTB	PKCNT(R1)		;ANYTHING LEFT IN THE PACKET?
	BEQ	NEWIGN			;NO-GO GIVE UP THE EMPTY PACKET
RTN002:	RETURN				;YES-RETURN FOR NOW
	.PAGE
	.SBTTL	NEWFUN - Handle function packet on a new circuit
;HERE FOR FUNCTION OR INTERRUPT PACKET

NEWFUN:	TSTB	PKCNT(R1)		;ANY DATA THERE?
	BLE	NEWIGN			;No-ignore it
	MOVB	PKDATA(R1),R0		;Yes-get function type
	CMP	#.FNGRN,R0		;Is it a green ball?
	BEQ	NEWGRN			;Yes-go handle it
.IF EQ ..SAT
	CMP	#.FNREQ,R0		;Is it a yellow ball?
	BEQ	NEWYEL			;Yes
	CMP	#.FNRQC,R0		;Is this a "Request buffer clear"?
	BNE	2$			;No-go on
	CJMP	ACKOPS#			;Yes-go acknowledge it

2$:	CMP	#.FNDCN,R0		;IS THIS A "DEVICE CONTROL" FUNCTION?
	BEQ	NEWSPF			;YES-THIS IS SPECIAL
.ENDC
	CMP	#.FNOSA,R0		;YES-IS IT AN "OUTPUT SUPPRESS ACK"
	BNE	NEWIGN			;NO-IGNORE IT
	BIC	#$S1JNK,SDSTS1(SD)	;YES-CLEAR THE JUNK BIT
	BR	NEWIGN			;AND GOTO NEWIGN TO GIVE IT UP

;HERE FOR GREEN BALL

NEWGRN:	TBBN	$I1INX,SDLIS1#(SD),NEWRTN;JUST BOUNCE IT BACK IF EXPECTING INPUT
	BIS	#$I1GBR,SDLIS1#(SD)	;NOT EXPECTING INPUT-REMEMBER THE
	BR	NEWIGN			;  BALL FOR LATER

;Here for yellow ball - just echo back a orange ball

.IF EQ ..SAT
NEWYEL:	MOVB	#.FNRSP,PKDATA(R1)	;Change it to an orange ball
	CJMP	PKTRTN#			;And send the packet back
.ENDC

;HERE FOR "DEVICE CONTROL" FUNCTION - THIS IS USED ONLY ON SUPERVISORY
;  CONNECTIONS TO PASS DATA BETWEEN A TYMSHARE HOST AND THE TYMNET GATEWAY

.IF EQ ..SAT
NEWSPF:	PUSHB	PKDATA+1(R1)		;Save sub-type
	CALL	JNKPKT#			;Give up the packet
	POPB	R0			;Get sub-type
	CMP	R0,#MAXSPF		;LEGAL VALUE?
	BHI	RTN002			;NO-IGNORE IT
	ASL	R0			;FOR WORD INDEXING
	ADD	R0,PC			;YES-DISPATCH ON IT
	BR	NWSSHT			;.SFSHT =  0 - HOST IS SHUT
	BR	NWSANS			;.SFANS =  1 - HOST IS ANSWERED
	BR	NWSSAD			;.SFSAD =  2 - HOST SAD BITS
	BR	NWSTOD			;.SFTOD =  3 - TIME OF DAY REQUEST
	BR	NWSRHK			;.SFRHK =  4 - REPORT HOST KEY
	BR	NWSHOP			;.SFHOP =  5 - HOST OUT OF PORTS
;	BR	NWSHHP			;.SFHHP =  6 - HOST HAS PORTS
MAXSPF=!6

;HERE FOR .SFHHP = 6 HOST HAS FREE PORTS AFTER REPORTING OUT OF PORTS

NWSHHP:	MOV	#^H9014,SUPMSG		;REPORT AVAILABLE PORTS TO SUP
	BR	NWSHST			;ADD HOST TO MESSAGE

;HERE FOR .SFHOP = 5 - HOST OUT OF PORTS MESSAGE

NWSHOP:	MOV	#^H8F14,SUPMSG		;REPORT SHORTAGE OF PORTS
	BR	NWSHST			;APPEND HOST AND SEND MESSAGE

;HERE FOR .SFRHK = 4 - REPORT HOST KEY

NWSRHK:	MOV	#^H8C14,SUPMSG		;PUT IN HEADER
	MOV	SDLIVL#(SD),R0		;GET HOST NUMBER
	SWAB	R0
	MOV	R0,SUPMSG+2		;PUT HOST IN MESSAGE
	MOVB	PKDATA+2(R1),SUPMSG+5	;PUT HOST KEY IN MESSAGE
	MOV	#6,R0			;SET UP MESSAGE LENGTH
	BR	NWSSND			;SEND REQUEST TO SUP

;HERE FOR .SFTOD = 3 - TIME REQUEST

NWSTOD:	MOV	#^H9114,SUPMSG		;REQUEST TIME FROM SUP
	BR	NWSHST			;PUT IN HOST AND SEND

;HERE FOR .SFSAD = 2 - HOST SAD BITS

NWSSAD:;	PUSH	#.SMMDR*10000		;SR1
;	MOV	SDLIVL#(SD),R0		;GET HOST NUMBER
;	ASHI	6,R0			;POSITION IT FOR SR2
;	BIS	#100000,R0
;	PUSH	R0			;SR2
;	PUSH	PKDATA+2(R1)		;SR3 (THE SAD BITS)
;	BR	NWSSND			;CONTINUE
	RETURN

;HERE FOR .SFANS = 1 - HOST IS ANSWERED

NWSANS:	MOV	#^H8011,R0		;GET VALUE FOR HEADER
	BR	NWSASS			;CONTINUE

;HERE FOR .SFSHT = 0 - HOST IS SHUT

NWSSHT:	MOV	#^H8211,R0		;GET VALUE FOR HEADER
NWSASS:	MOV	R0,SUPMSG
	MOV	SDLIVH#(SD),R0		;FIND HOST DESCRIPTOR
	ADD	R4,R0
	BIC	#100000,DDLIHD#+2(R0)	;ASSUME SHUT
	TBBN	<^H200>,SUPMSG,10$	;RIGHT?
	BIS	#100000,DDLIHD#+2(R0)	;NO-IT IS ANSWERED
10$:
NWSHST:	MOV	SDLIVL#(SD),R0		;GET HOST NUMBER
	BIS	#^H8000,R0		;SET ESCAPE BIT
	SWAB	R0
	MOV	R0,SUPMSG+2
	MOV	#4,R0			;SET LENGTH OF MESSAGE
NWSSND:	CJMP	SNDSPR#			;SEND TO SUPERVISOR
.ENDC		;.IF EQ ..SAT

;HERE FOR UNACCEPTABLE PACKET ON "NEW CIRCUIT"

NEWZAP:;	MOV	#.CCZAP,R0		;SEND ZAPPER TO THE SUPERVISOR
	CALL	LKISCM
	CALL	SETKIL#			;CHANGE PACKET INTO A KILL PACKET
NEWRTN:	CJMP	PKTRTN#			;AND SEND IT BACK AND RETURN
	.PAGE
	.SBTTL	NEWKIL - Handle disconnect or kill on new circuit

;HERE FOR DISCONNECT OR KILL PACKET ON "NEW CIRCUIT"

NEWKIL:
	CALL	FINDIS#
.IF EQ ..SAT
	TBBN	$I1SPR,SDLIS1#(SD),NEWKLS;IS THIS A SUPERVISORY CONNECTION?
.ENDC
;	MOV	#.CCZAP,R0		;NO-SEND A ZAPPER TO THE SUPERVISOR
;	CJMP	LKISCM
;****	added 5/28/81 to release buffer block assignments (the cause of
;	"bisy circuits"/dre
	CALL	LKISCM			; TO TERMINATE LOGIN SEQUENCE
	CJMP	CLRCIR#			;CLEAN UP ANY JUNK LEFT

;SUBROUTINE TO SEND ZAPPER FOR LOGIN TO SUP

LKISCM:	MOV	#SUPMSG,R0		;POINT TO SUP STRING
	MOV	#.SMLGC+^H8200,(R0)+	;SET UP LOGIN STRING CONT
	MOVB	#^H80,(R0)+		;PUT OUT JUNK
	MOVB	SDSOC#(SD),(R0)+	;SET UP PORT NUMBER
	MOV	#.CCZAP,(R0)+		;PUT OUT ZAPPER
	SUB	#SUPMSG,R0		;SET UP COUNT
	CJMP	SNDSPR#			;SEND TO SUP

;HERE TO DISCONNECT A SUPERVISORY CONNECTION

.IF EQ ..SAT

NEWKLS:	MOV	#^H8111,SUPMSG		;DECLARE HOST DOWN
	MOV	SDLIVL#(SD),R0		;GET HOST NUMBER
	SWAB	R0			;SWAP BYTES
	MOV	R0,SUPMSG+2
	MOV	#4,R0			;SHORT MESSAGE
	CALL	SNDSPR#			;SEND TO SUPERVISOR
LKINKL::MOV	SDLIVH#(SD),R0		;GET INDEX
	ADD	R4,R0
	BIC	#100000,DDLIHD+2(R0)	;AND NOT ANSWERED
	CLR	DDLISS#(R0)		;CLEAR POINTER BACK TO THE SDB
	CLR	SDLIVH#(SD)		;AND CLEAR SOME SDB DATA
	CLR	SDLIVL#(SD)
	RETURN

.ENDC		;.IF EQ ..SAT

;HERE FOR DISCONNECT ACK PACKET ON "NEW CIRCUIT"

NEWDAK:	CALL	JNKPKT#			;GIVE UP THE PACKET
	CALL	CLRCIR#			;CLEAN UP ANY JUNK
	CJMP	FRESOC#			;FREE THE SOCKET AND RETURN
	.PAGE
	.SBTTL	FILFRM - Fill a frame - Flow control record

;THIS SUBROUTINE IS CALLED BY THE FRAME LEVEL ROUTINES WHENEVER IT IS READY TO
;  TRANSMIT A FRAME
;	C(R2) = ADDRESS OF FRAME BUFFER
;	C(R3) = ADDRESS OF LDB
;	CALL	FILFRM
;	C(R2) = ADDRESS OF FIRST BYTE NOT USED

FILFRM::MOV	#56.,LKILFT		;INITIALIZE NUMBER OF BYTES AVAILABLE
	TBBE	$L1FLW,LDIST1#(R3),FILSPR;TIME FOR FLOW CONTROL RECORD?

;HERE TO GENERATE FLOW CONTROL RECORD

FILFLW:	CMP	PKFCNT#,#.PLOPT#	;Are we very low on packets?
	BLO	FILSPR			;Yes-don't send any flow control
	MOV	LDIFLF#(R3),R4		;Are there any SDBs left over from last pass
	BEQ	1$			;NO
	MOV	LDILSD#(R3),R1		;Get sdb table value for next SDB
	BR	4$			;Continue with rest of SDBs
1$:	MOV	LDISDB#(R3),R1		;POINT TO SDB TABLE
	CLR	R4
	BISB	LDICHN#(R3),R4		;GMBER OF CHANNELS
4$:	MOV	R1,R0			;Calculate current channel
	SUB	LDISDB#(R3),R0
	ASR	R0			;Convert from offset to channel
	PUSH	R3			;Save R3
	CLR	R3			;Assume we are low on packets
	MOV	#3,FLWLMT		;Set a low limit on number of channels to flow
	CMP	PKFCNT#,PKFHLF#		;Are we low on packets?
	BLO	2$			;YES-go on
	MOV	#31.,FLWLMT		;Set high limit for flow control bytes
.IF NE ..SAT
	MOV	#6,R3			;Allow 6 packets if TYMSAT
.IFF
	MOV	#8.,R3			;Allow 8 packets if TYMBAS
.ENDC
2$:	MOVB	#300,(R2)+		;STORE FLAG IN BYTE COUNT FIELD
	MOV	R2,FILSVA		;REMEMBER ADDRESS OF FIRST DATA WORD
	CLRB	(R2)+			;Always allow data on channel 0
6$:	MOV	(R1)+,SD		;GET NEXT SDB
	BEQ	10$			;IF NONE THERE
	CMPB	R3,SDPCNT#(SD)		;ARE WE READY FOR MORE ON THIS SDB?
	BLT	10$			;NO
	CMPB	SDLISP#(SD),SDPCNT#(SD)	;IS DATA IN USE LIKE SPEED
	BLT	10$			;NO
;	TST	SDSTS1#(SD)		;MAYBE-IS IT ACTIVE?
;	BEQ	10$			;NO
	TST	FLWGTF			;CHECK THE GUSH TRICKLE FLAG
	BLOS	8$			;RELIEVE BACKPRESURE OCCASIONALY
	TST	SDLIGT#(SD)		;TEST GUSH - TICKLE WORD
	BMI	10$			;BR IF NOT ENOUGH DATA IN FOR FLOW CONT
8$:	MOV	#-8.,SDLIGT#(SD)	;RESET GUSH TRICKLE COUNTER
	MOVB	R0,(R2)+		;STORE BYTE IN RECORD
	DEC	FLWLMT			;Are we at limit for flow control record
	BEQ	20$			;End of the record
10$:	INC	R0			;Handle next channel
	SOB	R4,6$			;MORE BITS FOR THIS BYTE?
20$:	MOV	R2,R3			;Copy byte pointer
	MOV	FILSVA,R0		;Get pointer to begining of record
	SUB	R0,R3			;Get number of channels unpreasured
	BISB	R3,-1(R0)		;Set byte count
	INC	R3			;Account for header byte
	SUB	R3,LKILFT		;Fix remaining room counter
	POP	R3			;Restore R3
	MOV	R1,LDILSD#(R3)		;SAVE ADDRESS OF NEXT SDB TO BE SERVICED
	MOV	R4,LDIFLF#(R3)		;SAVE RESIDUAL CHANNEL COUNT
	BNE	FILSPR			;DON'T CLEAR FLAG IF CHANNELS LEFT TO PROCRESS
	DEC	FLWGTF			;DECREMENT GUSH TRICKLE FLAG
	BPL	30$			;STILL IN RANGE
	MOV	#8.,FLWGTF		;RESET GUSH TRICKLE FLAG
30$:	BIC	#$L1FLW,LDIST1#(R3)	;CLEAR FLOW CONTROL REQUEST
					;FALL INTO FILSPR
	.PAGE
	.SBTTL	FILSPR - Fill a frame - Supervisor record

;HERE TO PROCESS ANY SUPERVISOR MESSAGES THAT HAVE BEEN QUEUED FOR THIS LINE

FILSPR:	MOV	LDISLH#(R3),R1		;ANY SUPERVISOR MESSAGES QUEUED?
	BEQ	FILZAP			;NO-GO SEE IF NEED TO ZAP SOMEONE
	CLR	R0
	BISB	(R1)+,R0		;SET LIMIT ON TRANSFER
	CMPB	R0,LKILFT		;IS THERE ENOUGH ROOM FOR THIS MESSAGE
	BHI	FILZAP			;NO- GO CHECK FOR ZAPS
	SUB	#2,R0			;COUNT INCLUDED CHANNEL AND COUNT BYTES
	MOVB	R0,(R2)+		;STORE BYTE COUNT IN FRAME
	ADD	#2,R0			;CONVERT BACK TO USABLE COUNT
	BR	3$			;ACCOUNT FOR COUNT BYTE AND CHECK FOR NEXT PACKET
2$:	MOVB	(R1)+,(R2)+		;COPY THE SUPERVISOR MESSAGE
3$:	DEC	LKILFT
	CMP	LDISLT#(R3),R1		;END OF LIST?
	BEQ	4$			;YES
	BIT	#77,R1			;NO-END OF PACKET?
	BNE	12$			;NO-CONTINUE
4$:	DEC	R1			;GET BACK INSIDE THE PACKET
	BIC	#77,R1			;YES-POINT TO START OF PACKET
	PUSH	(R1)			;SAVE ADDRESS OF NEXT MESSAGE
	FREPKT				;GIVE UP THE PACKET
	POP	R1			;GET ADDRESS OF NEXT MESSAGE BYTE
	BNE	12$			;GOT ONE
	DEC	R0			;COUNT THE LAST CHAR
	BEQ	14$			;COUNTS OK
	FSTOP	CNE			;COUNTS NOT EQUAL
12$:	SOB	R0,2$			;ROOM LEFT FOR ANOTHER ONE?

;HERE WHEN FINISHED SENDING SUPERVISOR MESSAGES, EITHER BECAUSE THERE ARE NO 
;  MORE QUEUED OR BECAUSE WE HAVE FILLED THE FRAME

14$:	MOV	R1,LDISLH#(R3)		;UPDATE HEAD POINTER
	BNE	FILSPR			;IS THE LIST EMPTY NOW?
	CLR	LDISLT#(R3)		;YES-CLEAR TAIL POINTER
;16$:	BR	FILSPR			;TRY FOR ANOTHER ONE
	.PAGE
	.SBTTL	FILZAP - Fill a frame - Circuit Zappers

;HERE TO PROCESS REQUESTS TO ZAP A CHANNEL

FILZAP:
.IF EQ	..SAT
	MOV	LDIZLH#(R3),R1		;ANY REQUESTS?
	BEQ	FILPKT			;NO-GO PROCESS OUTPUT PACKETS
2$:	SUB	#4,LKILFT		;YES-ROOM FOR A 2 BYTE RECORD?
	BLT	6$			;NO-STOP FOR THIS TIME
	MOVB	#2,(R2)+		;YES-BYTE COUNT = 2
	ASR	R1			;GET CHANNEL NUMBER
	MOVB	R1,(R2)+		;PUT IN RECORD HEADER
	MOVB	#.CCZAP,(R2)+		;CIRCUIT ZAPPER
	MOVB	#.ZCHRD,(R2)+		; OF THE HARD VARITY
	ASL	R1			;GET NEXT REQUEST
	ADD	LDISDB#(R3),R1
	BIC	#1,R1
	BNE	2$			;CONTINUE IF HAVE ANOTHER
6$:	MOV	R1,LDIZLH#(R3)		;FINISHED-UPDATE HEAD POINTER
	BNE	FILPKT			;IF LIST NOT EMPTY NOW
	CLR	LDIZLT#(R3)		;EMPTY-CLEAR TAIL POINTER
					;FALL INTO FILPKT
.ENDC
	.PAGE
	.SBTTL	FILPKT - Fill a frame - Process output packets

;HERE TO PROCESS OUTPUT PACKETS

FILPKT:	CMP	#4,LKILFT		;ROOM FOR A 2 BYTE RECORD?
	BGT	1$			;NO-THATS ALL FOR THIS FRAME
	MOV	LDIXLH#(R3),SD		;YES-ANY SOCKETS QUEUED?
	BNE	10$			;YES-GO ON

;HERE WHEN NOTHING MORE LEFT TO PUT IN THE FRAME OR WHEN THE FRAME IS
;  FULL - BEFORE WE RETURN WITH THIS FRAME TO SEND, WE MUST CHECK TO SEE
;  IF WE QUEUED SOME SUPERVISOR MESSAGES FOR THE UPSTREAM LINE WHILE WE
;  WERE FILLING THIS PACKET (IF THIS IS THE UPSTREAM LINE, THIS IS NOT
;  NECESSARY!) - IF WE DID QUEUE SOME, WE WILL START OUTPUT FOR THE
;  UPSTREAM LINE BEFORE WE RETURN WITH THIS FRAME

1$:	MOV	LDIDDB#(R3),R4		;GET ADDRESS OF DDB
	MOV	DDLIUP#(R4),R0		;GET UPSTREAM LINE LDB
	BEQ	4$			;FINISHED IF NONE
	CMP	R0,R3			;IS THIS THE UPSTREAM LINE?
	BEQ	4$			;YES-NOTHING MORE NEEDED
	TST	LDISLH#(R0)		;ANY SUPERVISOR MESSAGES WAITING?
	BEQ	4$			;NO
	TBBN	$L1BSY,LDIST1#(R0),4$	;YES-IS THE LINE BUSY?
	PUSH	R3			;NO-START IT UP NOW
	PUSH	R4			;LDISTX DOES NOT RESPECT R4
	MOV	R0,R3
	PUSH	R2
	CALL	@LDISTX#(R3)
	POP	R2
	POP	R4
	POP	R3
4$:	RETURN				;FINISHED HERE

;HERE IF MORE ROOM IN THE FRAME AND A SOCKET(S) IS QUEUED FOR OUTPUT

10$:	CMP	#56.,LKILFT		;HAVE WE PUT ANYTHING IN THIS PACKET
	BNE	20$			;YES
	CMPB	#2,LDIUFC#(R3)		;HAVE WE BUILT 2 PACKETS AHEAD ALREADY
	BLO	1$			;YES, WAIT A WHILE
20$:	MOV	SDPKDH#(SD),R1		;GET PACKET TO SEND
	BEQ	DONSDB			;IF FALSE ALARM!
	MOVB	PKTYPE(R1),R0		;GET PACKET TYPE
	ASL	R0			;FOR WORD INDEXING
	JMP	@FILDSP(R0)		;DISPATCH ON THE PACKET TYPE

;PACKET TYPE DISPATCH TABLE

	PURE
	.EVEN

FILDSP:	.WORD	FILDAT		;.PTDAT =  0 - DATA PACKET
	.WORD	FILCON		;.PTCON =  1 - CONNECTION REQUEST
.IF EQ ..SAT
	.WORD	FILACK		;.PTACK =  2 - CONNECT ACK
	.WORD	FILNAK		;.PTNAK =  3 - CONNECT NAK
.IFF
	.WORD	DONPKT		;.PTACK =  2 - CONNECT ACK
	.WORD	DONPKT		;.PTNAK =  3 - CONNECT NAK
.ENDC
	.WORD	FILFUN		;.PTFUN =  4 - FUNCTION
	.WORD	FILFUN		;.PTINT =  5 - INTERRUPT
	.WORD	FILEAT		;.PTEAT =  6 - EAT
	.WORD	FILDIS		;.PTDIS =  7 - DISCONNECT
	.WORD	FILKIL		;.PTKIL = 10 - KILL CONNECTION
	.WORD	FILDAK		;.PTDAK = 11 - DISCONNECT ACK

	CODE
	.PAGE
	.SBTTL	FILDAT - Fill a frame - Data packets for existing circuit

;HERE FOR DATA PACKET

FILDAT:	TBBN	$S1JNK,SDSTS1#(SD),DONPKT;SHOULD WE IGNORE THIS PACKET?
	CALL	SETPNT			;SETUP R4, FILSVA, FILCNT AND START OF LOGICAL RECORD
.IF NE ..TPC
	TBBE	$I1TPC,SDLIS1#(SD),FILDA2;Go on if protocol conversion not needed
	PUSH	R3			;Must respect R3 here
	CALL	LHOTPC#			;Do protocol conversion
	  BR	NOROOX			;If ran out of space in the frame
	  BR	STPSDX			;If ran out of send-ahead count
	POP	R3			;Restore R3
	BR	DONREC			;If ran out of data in the packet
.ENDC

FILDA2:	DEC	SDACNT#(SD)		;Reduce send-ahead count
	BLT	STPSDB			;Stop him if he has sent enough
	MOVB	(R4)+,R0		;Get data byte
	CALL	LKIBYO			;Store byte in the frame
	  BR	STRCNT			;If frame was full
	INCB	PKPNT(R1)		;Bump pointer
	DECB	PKCNT(R1)		;Reduce count
	BGT	FILDA2			;Continue if more there
	BR	DONREC			;No more data-go finish up

;HERE IF FRAME IS FULL - MUST STOP NOW BUT WE LEAVE THE SDB ON THE SEND LIST
;  SO WE WILL CONTINUE WITH IT NEXT TIME

.IF NE ..TPC
NOROOX:	POP	R3			;Restore R3
.ENDC
STRCNT:	MOV	FILCNT,R0		;GET BYTE COUNT
	BNE	2$			;MAKE SURE REALLY OUTPUT SOMETHING!
	SUB	#2,R2			;OPPS-RESET POINTER
	ADD	#2,LKILFT		;AND COUNT
	RETURN				;THATS ALL

2$:	MOVB	R0,@FILSVA		;STORE BYTE COUNT
.IF EQ ..SAT
	ADD	R0,SDLIO1#(SD)		;UPDATE OUTPUT CHARACTER COUNT
	ADC	SDLIO2#(SD)
.ENDC
	RETURN

;HERE WHEN FINISHED EMPTYING THE PACKET

DONREC:	CALL	STRCNT			;STORE BYTE COUNT
DONPKT:	TST	R1			;Do we still have a packet?
	BEQ	DONSDB			;No-go on
	PUSH	R2			;FINISHED WITH THE PACKET-GIVE IT UP
	PUSH	R3
	CALL	JNKPKT#
DONPK9:	POP	R3
	POP	R2
	BR	DONSDB			;CONTINUE

;HERE IF MUST STOP OUTPUT FOR THIS SDB BECAUSE ITS SEND-AHEAD COUNT RAN OUT

.IF NE ..TPC
STPSDX:	POP	R3
.ENDC
STPSDB:	CALL	STRCNT			;STORE BYTE COUNT IN ROECORD
DONSDB:	MOV	SDLKLK#(SD),LDIXLH#(R3)	;TAKE THE SDB OUT OF THE SEND LIST
	BNE	2$			;LIST EMPTY NOW?
	CLR	LDIXLT#(R3)		;YES-CLEAR TAIL POINTER
2$:	MOV	#-1,SDLKLK#(SD)		;INDICATE NOT IN LIST
	TST	SDPKDH#(SD)		;More to send now?
.IF EQ ..TPC
	BEQ	10$			;No
.IFF
	BNE	3$			;Yes-go on
	TBBE	$I1GBP,SDLIS1#(SD),10$	;No-is a green ball pending?
	BIC	#$I1GBP,SDLIS1#(SD)	;Yes-but any longer!
	MOV	#.FNGRN,R0		;Send back a green ball
	CALL	BALBCK#
.ENDC
3$:	CMP	SDACNT#(SD),#2		;CAN THIS SOCKET SEND MORE NOW?
	BLT	10$			;NO
	MOV	LDIXLT#(R3),R0		;YES-LINK TO END OF SEND LIST
	BEQ	4$
	MOV	SD,SDLKLK#(R0)
	BR	5$

4$:	MOV	SD,LDIXLH#(R3)
5$:	MOV	SD,LDIXLT#(R3)
	CLR	SDLKLK#(SD)
10$:	JMP	FILPKT			;CONTINUE

;	Routine to setup frame building pointers

SETPNT:	MOV	R2,FILSVA		;REMEMBER ADDRESS OF BYTE COUNT
	INC	R2			;BUMP POINTER PAST COUNT BYTE
	MOVB	SDLICN#(SD),(R2)+	;PUT CHANNEL NUMBER IN HEADER
	SUB	#2,LKILFT		;ACCOUNT FOR THE HEADER BYTES
	CLR	FILCNT			;CLEAR BYTE COUNT FOR RECORD
	MOVB	PKPNT(R1),R4		;POINT TO FIRST DATA BYTE
	BNE	4$
	INC	R4
	INCB	PKPNT(R1)
4$:	ADD	#PKDATA-1,R4		;BUILD DIRECT POINTER TO DATA IN R4
	ADD	R1,R4
	RETURN

	.SBTTL	FILCON - Fill a frame - Connect packet

;HERE FOR CONNECT PACKET

FILCON:	FSTOP	ILP			;[ILLEGAL PACKET TYPE] - THIS IS
					;  PROCESSED LONG BEFORE IT GETS HERE!
	.PAGE
	.SBTTL	FILACK - Fill a frame - Connect ACK packet for in use circuit

;HERE FOR CONNECT ACK PACKET

.IF EQ ..SAT

FILACK:	PUSHB	PKDATA+1(R1)		;Save the flag byte
	PUSH	R2			;Save some AC's
	PUSH	R3
.IF NE ..TPC
	BITB	#100,PKDATA+1(R1)	;Does he want deferred echo mode?
	BNE	10$			;Yes-this is easy!
	MOVB	PKDATA+2(R1),R0		;No-get terminal profile
	BLE	10$			;We can't help him if no profile!
	CMP	#P..MAX,R0		;Or if its illegal!
	BLO	10$
	CMP	#12.,LKILFT		;Room for a 10 byte record now?
	BLT	2$			;OK-go on
	POP	R3			;No room-wait until later
	POP	R2
	TST	(SP)+			;Clean up stack
	RETURN				;Finish off packet here

2$:	SUB	#12.,LKILFT		;Account for the 10 byte record
	BIS	#$I1TPC,SDLIS1#(SD)	;Indicate need protocol conversion
	BIC	#$T1ECH,SDLIT1#(SD)	;Assume no echo wanted
	BITB	#010,PKDATA+1(R1)	;Right?
	BNE	4$			;Yes
	BIS	#$T1ECH,SDLIT1(SD)	;No
4$:	PUSH	R1			;Save another AC
	DEC	R0			;Store the profile bits
	ASL	R0
	MOV	TPFBTS#(R0),SDLIT5#(SD)
	MOVB	TPFLFH#(R0),SDLIT2#(SD)
	MOV	#PRFPNT#+2,R1		;Copy other profile parameters
	MOV	#PRFSIZ#-1,R2
	MOV	#SDTRLP#+1,R3
	CALL	CPYPRM#
	POP	R1
	MOVB	TPFDFS#(R0),SDLIBS#(SD)	;Store the break set bits
10$:
.ENDC
	CALL	JNKPKT#			;Give up the ACK packet
	POP	R3
	POP	R2
.IF NE ..TPC
	TBBE	$I1TPC,SDLIS1#(SD),12$;Want terminal protocol conversion?
	MOVB	#10.,(R2)+		;Yes-store byte count
	MOVB	SDLICN#(SD),(R2)+	;Store channel number
	MOV	#.PCSBT!.QBECN,R0	;Echo control function
	BIT	#$T1ECH,SDLIT1#(SD)	;Test our bit
	CALL	PUTTFN			;Store the function
	MOV	#.PCSBT!.QBELC,R0	;Echo LF after CR function
	BIT	#$T2ELC,SDLIT2#(SD)	;Test our bit
	CALL	PUTTFN			;Store the function
	MOV	#.PCSBT!.QBECL,R0	;Echo CR after LF function
	BIT	#$T2ECL,SDLIT2#(SD)	;Test our bit
	CALL	PUTTFN			;Store the function
	MOV	#.PCSBT!.QBRXE,R0	;Reverse X-enable function
	BIT	#$T4HOE,SDLIT4#(SD)	;Test our bit
	CALL	PUTTFN			;Store the function
	MOV	#.PCSBT!.QBXEN,R0	;X-enable function
	BIT	#$T4HIE,SDLIT4#(SD)	;Test our bit
	CALL	PUTTFN			;Store the function
12$:
.ENDC
	POP	R0			;Get the flag byte
	MOV	SDLISC#(SD),R1		;ANY DATA TO SEND?
	BEQ	50$			;NO-FINISHED
	CLR	SDLISC#(SD)		;YES-CLEAR THE POINTER
	PUSH	(R1)			;Save linked packet
	TBBN	040,R0,14$		;Should we send the login string?
	FREPKT				;Junk the login string
13$:	POP	R1			;Get linked pointer
	BEQ	50$			;Nothing there - we are finished
	PUSH	(R1)			;Save linked packet
14$:	CALL	LKISPK#			;Send it
	BR	13$			;Check next packet

50$:	JMP	DONSDB			;Finished

.ENDC

;Subroutine called from above to store terminal parameter function into the
;  frame buffer
;	Z:set = value should be 0
;	Z:clr = value should be 1
;	C(R0) = function
;	CALL	PUTTFN

.IF NE ..TPC

PUTTFN:	BEQ	2$			;Go on if value should be 0
	INC	R0			;Make it 1
2$:	MOVB	#.CCPRE,(R2)+		;Store prefix code
	MOVB	R0,(R2)+		;Store function and value
	RETURN				;Thats all

.ENDC
	.PAGE
	.SBTTL	FILEAT - EAT PACKETS

;HERE FOR EAT PACKETS

FILEAT:
.IF EQ ..SAT
	TSTB	PKCNT(R1)		;Empty eat packet?
	BEQ	2$			;Yes-it always generates a gobbler
	CMPB	#.FNOSA,PKDATA(R1)	;No-output suppress ACK?
	BEQ	FILFUN			;Yes-does not generate a gobbler
2$:	SUB	#4,LKILFT		;No-reduce amount left in frame
	MOVB	#2,(R2)+		;Store byte count
	MOVB	SDLICN#(SD),(R2)+	;Store channel number
	MOVB	#.CCZAP,(R2)+		;Store zapper
	MOVB	#.ZCGOB,(R2)+		;Gobbler subtype
	MOVB	#.PTINT,PKTYPE(R1)	;Change packet type to function in
					;  case we must re-do this
.ENDC

	.SBTTL	FILFUN - FILL A FRAME - FUNCTION AND INTERRUPT PACKETS

;HERE FOR FUNCTION OR INTERRUPT PACKET

FILFUN:	TSTB	PKCNT(R1)		;At least one data byte?
	BLE	DONP2T			;No-ignore it
	MOVB	PKDATA(R1),R0		;Yes-get function
	ASL	R0			;FOR WORD INDEXING
	CMP	#FNCMAX,R0		;LEGAL FUNCTION?
	BLO	DONP2T			;NO-IGNORE IT
	JMP	@FNCDSP(R0)		;YES-DISPATCH ON THE FUNCTION

;FUNCTION DISPATCH TABLE

	PURE

	.EVEN
FNCDSP:	.WORD	DONPKT		;.FNNUL =  0 - NULL
	.WORD	FNCOPS		;.FNHRD =  1 - HARD INTERRUPT
	.WORD	DONPKT		;.FNSFT =  2 - SOFT INTERRUPT
	.WORD	FNCOSA		;.FNOSA =  3 - OUTPUT SUPPRESS ACK
	.WORD	FNCOPS		;.FNOPS =  4 - OUTPUT SUPPRESS
	.WORD	DONPKT		;.FNOPH =  5 - HOLD OUTPUT
	.WORD	DONPKT		;.FNOPA =  6 - ALLOW OUTPUT
	.WORD	FNCCDP		;.FNCDP =  7 - CHANGE DEVICE PARAMETERS
	.WORD	FNCSDP		;.FNSDP = 10 - SET DEVICE PARAMETERS
	.WORD	FNCADP		;.FNADP = 11 - ACCESS DEVICE PARAMETERS
	.WORD	FNCSDP		;.FNRDP = 12 - REPLY WITH DEVICE PARAMETERS
	.WORD	DONPKT		;.FNDCN = 13 - DEVICE CONTROL
	.WORD	DONPKT		;.FNDST = 14 - DEVICE STATUS
	.WORD	DONPKT		;.FNADS = 15 - ACCESS DEVICE STATUS
	.WORD	DONPKT		;.FNCON = 16 - CONTINUE OUTPUT (^Q)
	.WORD	DONPKT		;.FNFHI = 17 - FORCE HARD INTERRUPT
	.WORD	FNCDEM		;.FNDEM = 20 - DEFERRED ECHO MODE CONTROL
	.WORD	FNCRQD		;.FNRQD = 21 - REQUEST DISCONNECT
	.WORD	FNCOPS		;.FNRQC = 22 - REQUEST BUFFER CLEAR
	.WORD	FNCREQ		;.FNREQ = 23 - REQUEST (YELLOW BALL)
	.WORD	FNCRSP		;.FNRSP = 24 - RESPONSE (ORANGE BALL)
	.WORD	FNCGRN		;.FNGRN = 25 - GREEN BALL
	.WORD	FNCRED		;.FNRED = 26 - RED BALL
	.WORD	FNCLST		;.FNLST = 27 - LOST DATA INDICATION (BLACK BALL)
	.WORD	FNCLSX		;.FNLSX = 30 - REFLECTED LOST DATA INDICATION
				;		 (GRAY BALL)
	.WORD	FNCBRK		;.FNBRK = 31 - BREAK RECEIVED OR REQUEST
	.WORD	FNCHNG		;.FNHNG = 32 - HANG UP REQUEST
	.WORD	FNCXHG		;.FNXHG = 33 - HARRD HANG UP REQUEST
	.WORD	DONPKT		;.FNRCC = 34 - Reconnect control
.IF NE ..TPC
	.WORD	FNCXGB		;.FNXGB = 35 - Character gobbler
	.WORD	DONPKT		;.FNSRQ = 36 - Status request
	.WORD	DONPKT		;.FNCLI = 37 - Clear login mode
	.WORD	FNCBIN		;.FNBIN = 40 - Output binary characters
	.WORD	FNCFLR		;.FNFLR = 41 - Force line re-type
.ENDC
FNCMAX=!.-FNCDSP

	CODE
	.PAGE
;HERE FOR .FNHRD, .FNOSA, OR .FNRQC - ANY FUNCTION WHICH REQUIRES .FNOSA REPLY

FNCOPS:	PUSH	R2			;Save valuable AC's
	PUSH	R3
	CALL	ACKOPS#			;Call common routine
	JMP	DONPK9			;Thats all

;HERE FOR .FNOSA - OUTPUT SUPPRESS ACK

FNCOSA:	BIC	#$S1JNK,SDSTS1#(SD)	;CLEAR THE JUNK BIT
DONP2T:	JMP	DONPKT			;Thats all

;HERE FOR .FNDEM = 20 - DEFERED ECHO MODE CONTROL

FNCDEM:	MOV	#.CCEDE,R0		;ASSUME WANT TO ENTER DEFERED ECHO
	TSTB	PKDATA+1(R1)		;RIGHT?
	BNE	CHRONE			;YES
	MOV	#.CCLDE,R0		;NO-SHOULD LEAVE
	BR	CHRONE			;GO SEND CHARACTER

;HERE FOR .FNRQD = 21 - REQUEST DISCONNECT

FNCRQD:;	MOV	#.ERREQ,R0		;MAKE A KILL PACKET
;	CALL	SETKIL#
;	CALL	LKISPK#
;	JMP	FILKIL			;AND GO ZAP THE TYMNET CIRCUIT

	PUSH	R2
	PUSH	R3
	CALL	REMOVE#			;REMOVE IT FROM THE DESTINATION LIST
	CLR	(R1)			;CLEAR THE LINK FIELD, PLAY IT SAFE.
	PUSH	R1			;SAVE PKT. POINTER
	CALL	DECPCN#			;DECREMENT SENDER'S PKT COUNT
	POP	R1			;RETRIVE PKT. PTR. TO SEND KILL PACKET.

	MOV	#.ERREQ,R0		;MAKE A KILL PACKET
	CALL	SETKIL#
	CALL	LKISPK#
	POP	R3
	POP	R2
;---
; By this time, there should be a Disconnect Ack packet queued on the 
;  Destination List of this socket (by (PKT2)SNDKIL module).  It is changed 
;  to a Disconnect packet here and branch to FILDIS so that a yellow ball 
;  will be sent to TYMNET and a zapper sent after an orange ball is bounced 
;  back.
;---
	MOV	SDPKDH#(SD),R1		;A PACKET ON THE DESTINATION LIST ?
	BNE	10$			;YES, BRANCH

	MOV	#.ERREQ,-(SP)		;NO, MUST BE LOW ON FREE PACKETS
	JMP	FILKL2			;WE WILL JUST SEND A ZAPPER
10$:
	MOV	#<.PTDIS*400+1>,PKCNT(R1) ;CHANGE IT TO DISCONNECT WITH REASON
	MOVB	#.ERREQ,PKDATA(R1)
	JMP	FILDIS			;


;HERE FOR .FNREQ = 23 - REQUEST (YELLOW BALL)

FNCREQ:	MOV	#<.PCCON!.CIYEL>*400+.CCPRE,R0;GET CHARACTERS TO SEND
	BR	CHRTWO			;CONTINUE

;HERE FOR .FNRSP = 24 - RESPONSE (ORANGE BALL)

FNCRSP:	MOV	#<.PCCON!.CIORG>*400+.CCPRE,R0;GET CHARACTERS TO SEND
	BR	CHRTWO			;CONTINUE

;HERE FOR .FNGRN = 25 - GREEN BALL

FNCGRN:	MOV	#.CCGRN,R0		;GET CHARACTER TO SEND
	BR	CHRONE

;HERE FOR .FNRED = 26 - RED BALL

FNCRED:	MOV	#.CCRED,R0		;GET CHARACTER TO SEND
CHRONE:	SUB	#3,LKILFT		;REDUCE AMOUNT LEFT IN FRAME
	MOVB	#1,(R2)+		;STORE BYTE COUNT
	MOVB	SDLICN#(SD),(R2)+	;STORE CHANNEL NUMBER
	DEC	SDACNT#(SD)		;REDUCE SEND-AHEAD COUNT
	BR	CHRTW2			;GO STORE DATA AND FINISH UP
	.PAGE
;HERE FOR .FNLST = 27 - LOST DATA INDICATION (BLACK BALL)

FNCLST:	MOV	#<.PCCON!.CIBLK>*400+.CCPRE,R0;GET CHARACTERS TO SEND
	BR	CHRTWO

;HERE FOR .FNLSX = 30 - REFLECTED LOST DATA INDICATION (GRAY BALL)

FNCLSX:	MOV	#<.PCCON!.CIGRY>*400+.CCPRE,R0;GET CHARACTERS TO SEND
	BR	CHRTWO

;HERE FOR .FNBRK = 31 - BREAK RECEIVED OR REQUEST

FNCBRK:	MOV	#<.PCCON!.CIBRK>*400+.CCPRE,R0;GET CHARACTERS TO SEND
	BR	CHRTWO

;HERE FOR .FNHNG = 32 - HANG UP REQUEST

FNCHNG:	MOV	#<.PCCON!.CIHNG>*400+.CCPRE,R0;GET CHARACTERS TO SEND
	BR	CHRTWO

;HERE FOR .FNXHG = 33 - HARD HANG UP REQUEST

FNCXHG:	MOV	#<.PCCON!.CITRH>*400+.CCPRE,R0;GET CHARACTERS TO SEND
CHRTWO:	SUB	#4,LKILFT		;REDUCE AMOUNT LEFT IN FRAME
	MOVB	#2,(R2)+		;STORE BYTE COUNT
	MOVB	SDLICN#(SD),(R2)+	;STORE CHANNEL NUMBER
	MOVB	R0,(R2)+		;STORE FIRST CHARACTER
	SWAB	R0			;STORE SECOND CHARACTER
CHRTW2:	MOVB	R0,(R2)+
DONP4T:	JMP	DONPKT			;THATS ALL
	.PAGE
;Here for special character gobbler function - this function is used by the
;  terminal protocol converter to handle the hard interrupt and output suppress
;  characters.  This function is sent back to the TYMNET port (see PKTSLF)
;  in an EAT packet.  When received (here) we send a character gobbler to
;  TYMNET, followed by the echo of the character typed (3rd byte in the
;  packet) and send a hard interrupt function or an output suppress function
;  the other way (away from TYMNET)

.IF NE ..TPC

FNCXGB:	SUB	#8.,LKILFT		;Room for 8 bytes?
	BGE	2$			;Yes-go on
	JMP	STRCNT			;No-wait until next time

2$:	MOVB	#6,(R2)+		;Store 5 character data record
	MOVB	SDLICN#(SD),(R2)+
	MOVB	#.CCZAP,(R2)+		;First is a character gobbler
	MOVB	#.ZCGOB,(R2)+
	MOVB	#'^,(R2)+		;Next is "^X CR LF", where X is the
	MOVB	PKDATA+1(R1),(R2)	;  control character from the packet
	BISB	#100,(R2)+
	MOVB	#CR,(R2)+
	MOVB	#LF,(R2)+
	MOV	#.FNHIN*400+.PTEAT,R0	;Assume hard interrupt
	TSTB	PKDATA+2(R1)		;Right?
	BNE	4$			;Yes
	MOV	#.FNOPS*400+.PTINT,R0	;No-its output suppress
4$:	MOVB	#2,PKCNT(R1)		;Fix up the packet
	MOVB	R0,PKTYPE(R1)
	SWAB	R0
	MOVB	R0,PKDATA(R1)
	PUSH	R2
	PUSH	R3
	CALL	PKTRTN#			;Send it
	POP	R3
	POP	R2
	JMP	DONSDB			;Thats all

.ENDC
	.PAGE
;Here for .FNBIN = 40 - Output binary character

.IF NE ..TPC
FNCBIN:	TSTB	PKPNT(R1)		;Is this the first call for this packet
	BNE	10$			;No - skip tweek of pkpnt
	INCB	PKPNT(R1)		;Add bias required by SETPNT
	TST	SDACNT#(SD)		;Check send ahead count
	BEQ	10$			;No room - remove packet from send list
	INCB	PKPNT(R1)		;Skip over function subcode
	DECB	PKCNT(R1)		;Deduct function subcode from count
	CALL	SETPNT			;SETUP R4, FILSVA, FILCNT AND START OF LOGICAL RECORD
	JMP	FILDA2			;Continue
10$:	JMP	DONSDB			;Remove SDB from send list
.ENDC

;Here for .FNFLR = 41 - Force line re-type

.IF NE ..TPC
FNCFLR:	PUSH	R2
	PUSH	R3
	CALL	JNKPKT#			;Give up the packet
	CALL	LHIRE2#			;Re-echo the current input line
	JMP	DONPK9			;Thats all
.ENDC
	.PAGE
	.SBTTL	FNCSDP - Fill a frame - Terminal parameter functions

;Here for .FNSDP = 10 or .FNRDP = 12 - Set or Reply with device parameters

FNCSDP:	PUSH	#-1			;Indicate should change value but not
	BR	FNCTPR			;  report anything

;Here for .FNCDP = 7, Change device parameters

FNCCDP:	PUSH	#1			;Indicate should change value and
	BR	FNCTPR			;  report new value

;Here for .FNADP = 11 - Access device parameters

FNCADP:	CLR	-(SP)			;Indicate should not change value but
					;  should report current value
FNCTPR:	MOV	R2,FILSVA		;SAVE ADDRESS FOR BYTE COUNT
	INC	R2			;BUMP POINTER PAST COUNT BYTE
	MOVB	SDLICN#(SD),(R2)+	;PUT CHANNEL NUMBER IN RECORD
	SUB	#2,LKILFT		;ACCOUNT FOR THE HEADER
	CLR	FILCNT			;INITIALIZE THE BYTE COUNT
	MOVB	PKPNT(R1),R4		;GET POINTER INTO PACKET
	BNE	2$			;GO ON IF WE'VE USED THIS PACKET BEFORE
	INCB	PKPNT(R1)		;NEW PACKET-FIX UP THE POINTER
	DECB	PKCNT(R1)		;AND THE COUNT
	ASRB	PKCNT(R1)
	INC	R4
	CLRB	PKSEQ(R1)
2$:	ASL	R4			;MAKE POINTER
	ADD	R1,R4
	ADD	#PKDATA-1,R4
TPRNXT:	CMP	SDACNT#(SD),#2		;CAN WE SEND MORE NOW?
	BGE	2$			;YES
	TST	(SP)+			;NO-FIX UP THE STACK
	JMP	STPSDB			;AND STOP THIS SDB

2$:	CMP	#4,LKILFT		;Room for 2 more character pairs?
	BLE	4$			;YES
	TSTB	PKCNT(R1)		;NO-ANY MORE LEFT IN PACKET?
	BEQ	5$			;NO
	TST	(SP)+			;YES-FIX UP THE STACK POINTER
	JMP	STRCNT			;AND STOP THIS

4$:	DECB	PKCNT(R1)		;MORE THERE?
	BGE	20$			;YES
5$:	TST	(SP)+			;NO-FINISHED-FIX UP THE STACK
.IF NE ..TPC
	MOVB	PKSEQ(R1),R0		;Need to send something back?
	BEQ	14$			;No-continue
	ASL	R0			;Yes-calculate byte count
	INC	R0
	MOVB	R0,PKCNT(R1)		;Store byte count
	MOVB	#.FNRDP,PKDATA(R1)	;Change to "Reply with parameters" function
	PUSH	R2			;Send it back
	PUSH	R3
	CALL	PKTRTN#
	POP	R3
	POP	R2
	CLR	R1			;Indicate no packet now
.ENDC
14$:
.IF NE ..TPC
	TSTB	SDLIBS#(SD)		;Break on all character?
	BMI	15$			;Yes
	TSTB	SDLIIL#(SD)		;No-input buffer limit in effect?
	BEQ	16$			;No-go on
	CMPB	SDLIIL#(SD),SDLIIC#(SD)	;Yes-is the buffer too big now?
	BHI	16$			;No
15$:	PUSH	R1			;Yes-must forward everything here!
	PUSH	R2
	PUSH	R3
	PUSH	R4
	CALL	SNDTRP#
	POP	R4
	POP	R3
	POP	R2
	POP	R1
.ENDC
16$:	JMP	DONREC			;And go finish up

;Here for next parameter-value pair

20$:	MOVB	(R4)+,R0		;GET PARAMETER
	BIC	#^C177,R0		;Just 7 bits
	INCB	PKPNT(R1)		;Bump pointer
	CMP	#MAXTPR,R0		;VALID PARAMETER?
	BLOS	TPRSKP			;NO-SKIP IT!
	MOVB	TPRDSP(R0),R0		;YES-GET DISPATCH OFFSET
	BIC	#^C377,R0
	ASL	R0			;CHANGE TO WORD OFFSET
	ADD	R0,PC			;GO TO ROUTINE FOR PARAMETER
TPRBAS:
	.PAGE
;TERMINAL PARAMETER DISPATCH TABLE

	.MACRO	DSP  ADDR
.IF NB ADDR
	.BYTE	<ADDR-TPRBAS>/2
.IFF
	.BYTE	<TPRSKP-TPRBAS>/2
.ENDC
	.ENDM

.IF NE ..TPC
	.MACRO	DSPTPC  ADDR
	DSP	ADDR
	.ENDM
.IFF
	.MACRO	DSPTPC  ADDR
	DSP
	.ENDM
.ENDC

	PURE

TPRDSP:	DSP			;	=   0 - ILLEGAL
	DSPTPC	TPRCIC		;.TPCIC =   1 - COMMAND INTERRUPT CHARACTER
	DSP	TPRECH		;.TPECH =   2 - ECHO CONTROL
	DSPTPC	TPRBST		;.TPBST =   3 - BREAK SET
	DSPTPC	TPRITD		;.TPITD =   4 - IDLE TIMER DELAY
	DSP			;.TPTAP =   5 - "PAPER TAPE" MODE
	DSPTPC	TPRNMC		;.TPSNM =   6 - SUPPRESS NETWORK MESSAGES
	DSPTPC	TPRBRK		;.TPBRK =   7 - BREAK HANDLING
	DSP			;.TPPRF =  10 - TERMINAL PROFIL
	DSP	TPRRAT		;.TPRAT =  11 - BAUD RATE
	DSPTPC	TPRWID		;.TPWID =  12 - LINE WIDTH
	DSP			;.TPLEN =  13 - PAGE LENGTH
	DSP	TPROHE		;.TPOHE =  14 - OUTPUT HOLD ENABLE
	DSPTPC	TPRHIC		;.TPHIC =  15 - HARD INTERRUPT CHARACTER
	DSPTPC	TPRSIC		;.TPSIC =  16 - SOFT INTERRUPT CHARACTER
	DSPTPC	TPROSC		;.TPOSC =  17 - OUTPUT SUPPRESS CHARACTER
	DSPTPC	TPRDEL		;.TPDEL =  20 - DELETE CHARACTER
	DSPTPC	TPRLDC		;.TPLDC =  21 - LINE DELETE CHARACTER
	DSPTPC	TPRLRC		;.TPLRC =  22 - LINE RETYPE CHARACTER
	DSPTPC	TPRSHT		;.TPSHT =  23 - SIMULATE HORIZONTAL TAB
	DSPTPC	TPRSVT		;.TPSVT =  24 - SIMULATE VERTICAL TAB
	DSPTPC	TPRSFF		;.TPSFF =  25 - SIMULATE FORM FEED
	DSP	TPRMCD		;.TPMCD =  26 - MIN/MAX C.R. DELAY
	DSP	TPRFCD		;.TPFCD =  27 - FIXED C.R. DELAY
	DSP	TPRVCD		;.TPVCD =  30 - VARIABLE C.R. DELAY
	DSP	TPRLFD		;.TPLFD =  31 - LINE FEED DELAY
	DSP			;.TPHTD =  32 - HORIZONTAL TAB DELAY
	DSP			;.TPVTD =  33 - VERTICAL TAB DELAY
	DSP			;.TPFFD =  34 - FIXED FORM FEED DELAY
	DSP			;.TPVFD =  35 - VARIABLE FORM FEED DELAY
	DSP			;.TPBSD =  36 - BACKSPACE DELAY
	DSP	TPXLFI		;.TPLFI =  37 - LINE FEED INSERSION
	DSP	TPXCRI		;.TPCRI =  40 - CARRIAGE RETURN INSERSION
	DSPTPC	TPRIMI		;.TPIMI =  41 - Image mode input
	DSPTPC	TPRIMO		;.TPIMO =  42 - Image mode output
	DSPTPC	TPRXLI		;.TPXLI =  43 - XLATE LOWER CASE INPUT
	DSPTPC	TPRXLO		;.TPXLO =  44 - XLATE LOWER CASE OUTPUT
	DSPTPC	TPRBDE		;.TPBDE =  45 - BACKSPACE DELETE ENABLE
	DSPTPC	TPREDB		;.TPEDB =  46 - ECHO DELETE CHAR. AS BACKSPACE
	DSPTPC	TPRXBD		;.TPXBD =  47 - EXTENDED DELETE ECHO
	DSP	TPRLCP		;.TPLCP =  50 - LOCAL COPY
	DSP			;.TPBC1 =  51 - 1ST ADDITIONAL BREAK CHARACTER
	DSP			;.TPBC2 =  52 - 2ND ADDITIONAL BREAK CHARACTER
	DSP			;.TPOPT =  53 - OUTPUT PENDING TIMER
	DSPTPC	TPRCCE		;.TPCCE =  54 - CONTROL CHARACTER ECHO
	DSPTPC	TPRESC		;.TPESC =  55 - "ESC" CHARACTER ECHO CONTROL
	DSPTPC	TPRCHS		;.TPCHS =  56 - Convert high spec char to "ESC"
	DSP			;.TPTYP =  57 - TERMINAL TYPE
	DSPTPC	TPXESQ		;.TPESQ =  60 - ESC SEQUENCE CONTROL
	DSP			;	=  61 - Not assigned
	DSPTPC	TPRFCR		;.TPFCR =  62 - ALLOW FREE CR/LF
	DSP			;	=  63 - NOT ASSIGNED
	DSP	TPRTRN		;.TPTRN =  64 - TRANSPARENCY MODE
	DSP	TPRADM		;.TPADM =  65 - ALTERNATE DEVICE MODE
	DSP	TPRIRT		;.TPIRT =  66 - INPUT BAUD RATE
	DSP	TPRORT		;.TPORT =  67 - OUTPUT BAUD RATE
	DSP	TPRIHE		;.TPIHE =  70 - INPUT HOLD ENABLE
	DSP	TPRKAT		;.TPKAT =  71 - KATAKANA
	DSP	TPRPAR		;.TPPAR =  72 - PARITY CONTROL
	DSPTPC	TPRALF		;.TPALF =  73 - AUTO-LINE FEED
	DSP			;.TPVTS =  74 - VERTICAL TAB SPACING
	DSP	TPXCRD		;.TPBLT =  75 - BELT PRINTER CONTROL
	DSP	TPXEHT		;.TPEHT =  76 - ECHO HORIZONTAL TAB
	DSP			;.TPSRC =  77 - Status request character
	DSP	TPXEBS		;.TPEBS = 100 - Echo backspace
	DSPTPC	TPXSCE		;.TPSCE = 101 - Suppress control char echo
	DSPTPC	TPXIBL		;.TPIBL = 102 - Input buffer limit
	DSP			;.TPTOB = 103 - Terminate output on break (TYMNET)
	DSP			;.TPECE = 104 - Echo ESC local (TYMNET)
	DSP			;.TPQMD = 105 - "Q" Mode (TYMCOM-370 3270 emulation)
	DSPTPC	TPXSOP		;.TPSOP = 106 - Suppress output(X.3 parameter))
	DSPTPC	TPXEDT		;.TPEDT = 107 - Line editing enable(X.3 parameter))
MAXTPR=!.-TPRDSP

	CODE
	.PAGE
;Define macro to generate instruction to pick up bit and SDB offset for a
;  status bit

.IF NE ..TPC
	.MACRO	GETBIT  BIT,OFFSET
.IF LT BIT-400
	MOV	#BIT*400+OFFSET'#,R0
.IFF
	MOV	#BIT+1+OFFSET'#,R0
.ENDC
	.ENDM

.ENDC

;HERE FOR ILLEGAL TERMINAL PARAMETER

TPRSKP:	INC	R4			;BUMP POINTER PAST VALUE
	BR	TPRNXT			;FINISHED WITH THIS PARAMETER


;HERE FOR TERMINAL PARAMETER .TPCIC = 1 - COMMAND INTERRUPT CHARACTER

.IF	NE	..TPC
TPRCIC:
	MOV	#SDLICI#,R0
	BR	TPRNXV
.ENDC

;HERE FOR TERMINAL PARAMETER .TPECH = 2 - ECHO CONTROL

TPRECH:
.IF NE ..TPC
	TST	(SP)			;Access parameter ?
	BEQ	2$			;Yes
	BIS	#$T1ECH,SDLIT1#(SD)	;Assume he wants to echo
	BITB	#1,(R4)			;Right?
	BNE	2$			;Yes
	BIC	#$T1ECH,SDLIT1#(SD)	;No-clear our flag
.ENDC
2$:	MOV	#.QBECN,R0		;GET TYMNET CODE
	JMP	TPRBIT			;CONTINUE

;Here for terminal parameter .TPBST = 3 - Break set

.IF NE ..TPC
TPRBST:	MOV	#SDLIBS#,R0		;Get SDB offset
	BR	TPRNXV			;Continue
.ENDC

;Here for terminal parameter .TPITD = 4 - Idle time delay

.IF NE ..TPC
TPRITD:
	TST	(SP)			;Should the value be changed?
	BEQ	5$			;No, go on.
	MOV	#SDLIT6#,R0		;Yes, change the idle time down counter
	ADD	SD,R0
	MOVB	(R4),(R0)
5$:	MOV	#SDLIIT#,R0		;Get SDB offset for idle timer
	BR	TPRNXV
.ENDC

;Here for terminal parameter .TPBRK = 7 - Procedure on break

.IF NE ..TPC
TPRBRK:	MOV	#SDLIPB#,R0
	BR	TPRNXV
.ENDC

;Here for terminal parameter .TPNMC = 6 - Network message control

.IF NE ..TPC
TPRNMC:	GETBIT	$T5NMC,SDLIT5
	BR	TPRN2B
.ENDC

;Here for terminal parameter .TPWID = 12 - Line width

.IF NE ..TPC
TPRWID:	MOV	#SDLILW#,R0		;Get SDB offset
	BR	TPRNXV			;Continue
.ENDC

;HERE FOR TERMINAL PARAMETER .TPOHE = 14 - OUTPUT HOLD ENABLE

TPROHE:	MOV	#.QBRXE,R0		;GET TYMNET CODE
	JMP	TPRBIT			;CONTINUE
	.PAGE
;Here for terminal parameter .TPHIC = 15 - Hard interrupt character

.IF NE ..TPC
TPRHIC:	MOV	#SDLIHI#,R0		;Get SDB offset
	BR	TPRNXV			;Continue
.ENDC

;Here for terminal parameter .TPSIC = 16 - Soft interrupt character

.IF NE ..TPC
TPRSIC:	MOV	#SDLISI#,R0		;Get SDB offset
	BR	TPRNXV			;Continue
.ENDC

;Here for terminal parameter .TPOSC = 17 - Output suppress character

.IF NE ..TPC
TPROSC:	MOV	#SDLISO#,R0		;Get SDB offset
	BR	TPRNXV			;Continue
.ENDC

;Here for terminal parameter .TPDEL = 20 - Delete character

.IF NE ..TPC
TPRDEL:	MOV	#SDLIDL#,R0		;Get SDB offset
	BR	TPRNXV			;Continue
.ENDC

;Here for terminal parameter .TPLDC = 21 - Line delete character

.IF NE ..TPC
TPRLDC:	MOV	#SDLILX#,R0		;Get SDB offset
	BR	TPRNXV			;Continue
.ENDC
	.PAGE
;Here for terminal parameter .TPLRC = 22 - Line retype character

.IF NE ..TPC
TPRLRC:	MOV	#SDLIRE#,R0		;Get SDB offset
TPRNXV:	ADD	SD,R0			;Get address of value in SDB
	TST	(SP)			;Should we change the value?
	BEQ	4$			;No-go on
	MOVB	(R4),(R0)		;Yes-change it
	TST	(SP)			;Should we report the value?
	BMI	10$			;No-finished with this one
4$:	PUSH	R3			;Free up another AC
	MOVB	PKSEQ(R1),R3		;Get pointer
	ASL	R3			;Calculate address
	ADD	R1,R3
	MOVB	-1(R4),PKDATA+1(R3)	;Copy parameter
	MOVB	(R0),PKDATA+2(R3)	;Copy value
	INCB	PKSEQ(R1)		;Bump pointer
	POP	R3
10$:	INC	R4			;Bump pointer
	JMP	TPRNXT			;Thats all
.ENDC
	.PAGE
;Here for terminal parameter .TPSHT = 23 - Simulate horizontal tab

.IF NE ..TPC
TPRSHT:	GETBIT	$T4HTS,SDLIT4		;Get bit and SDB offset
	BR	TPRN2B
.ENDC

;Here for terminal parameter .TPSVT = 24 - Simulate vertical tab

.IF NE ..TPC
TPRSVT:	GETBIT	$T4VTS,SDLIT4		;Get bit and SDB offset
	BR	TPRN2B
.ENDC

;Here for terminal parameter .TPSFF = 25 - Simulate form feed

.IF NE ..TPC
TPRSFF:	GETBIT	$T4FFS,SDLIT4		;Get bit and SDB offset
	BR	TPRN2B			;Continue
.ENDC

;HERE FOR TERMINAL PARAMETER .TPMCD = 26 - MIN/MAX C.R. DELAY

TPRMCD:	PUSH	#.PCPMC			;GET TYMNET CODE
	BR	TPRFNF			;GO APPLY "FUNCTION F"

;HERE FOR TERMINAL PARAMETER .TPFCD = 27 - FIXED C.R. DELAY

TPRFCD:	PUSH	#.PCPMB			;GET TYMNET CODE
	BR	TPRVAL			;CONTINUE

;HERE FOR TERMINAL PARAMETER .TPVCD = 30 - VARIABLE C.R. DELAY

TPRVCD:	PUSH	#.PCPMA			;GET TYMNET CODE
TPRVAL:	MOVB	(R4)+,R0		;GET VALUE
	CMP	#17,R0			;CAN WE HANDLE THIS VALUE?
	BHIS	TPRPOP			;YES
	MOV	#17,R0			;NO-DO THE BEST WE CAN
	BR	TPRPOP

;HERE FOR TERMINAL PARAMETER .TPLFD = 31 - LINE FEED DELAY

TPRLFD:	PUSH	#.PCPMD			;GET TYMNET CODE
TPRFNF:	MOVB	(R4)+,R0		;GET VALUE
	TST	-2(SP)			;SET OR ACCESS?
	BEQ	6$			;ACCESS-DON'T BOTHER WITH "FUNCTION-F"
	CALL	TYNFIV#			;SET-APPLY INVERSE OF "FUNCTION-F"
	BR	TPRPOP			;CONTINUE

;HERE IF FUNCTION IS ACCESS

6$:	POP	R0			;GET FUNCTION
	BR	TPRPO2			;CONTINUE
	.PAGE
;Here for terminal parameter .TPIMO = 41 - Image mode output

.IF NE ..TPC
TPRIMO:	BIC	#$T2CRO,SDLIT2#(SD)	;Clear CR was output last flag
	GETBIT	$T1IMO,SDLIT1		;Get bit and SDB offset
	BR	TPRN2B			;Continue
.ENDC

;Here for terminal parameter .TPIMI = 42 - Image mode input

.IF NE ..TPC
TPRIMI:	GETBIT	$T1IMI,SDLIT1		;Get bit and SDB offset
	BR	TPRN2B			;Continue
.ENDC
	.PAGE
;Here for terminal parameter .TPXLI = 43 - Xlate lower case input

.IF NE ..TPC
TPRXLI:	GETBIT	$T5LCI,SDLIT5		;Get bit and SDB offset
	BR	TPRINV			;Continue
.ENDC

;Here for terminal parameter .TPXLO = 44 - Xlate lower case output

.IF NE ..TPC
TPRXLO:	GETBIT	$T5LCO,SDLIT5		;Get bit and SDB offset
	BR	TPRINV			;Continue
.ENDC

;Here for terminal parameter .TPBDE = 45 - Backspace delete enable

.IF NE ..TPC
TPRBDE:	GETBIT	$T5BDE,SDLIT5		;Get bit and SDB offset
	BR	TPRN2B			;Continue
.ENDC

;Here for terminal parameter .TPEDB = 46 - Echo delete character as backspace

.IF NE ..TPC
TPREDB:	GETBIT	$T4EDB,SDLIT4		;Get bit and SDB offset
	BR	TPRN2B			;Continue
.ENDC

;Here for terminal parameter .TPXBD = 47 - Extended delete echo

.IF NE ..TPC
TPRXBD:	GETBIT	$T4XBE,SDLIT4		;Get bit and SDB offset
	BR	TPRN2B			;Continue
.ENDC
	.PAGE
;HERE FOR TERMINAL PARAMETER .TPLCP = 50 - LOCAL COPY

TPRLCP:
.IF NE ..TPC
	BIC	#$T4LCP,SDLIT4#(SD)	;Assume not local copy
	BITB	#1,(R4)			;Right?
	BEQ	2$			;Yes
	BIS	#$T4LCP,SDLIT4#(SD)	;No-set our bit
.ENDC
2$:	MOV	#.QBHDP,R0		;GET TYMNET CODE
	BR	TPRBIT			;CONTINUE

;Here for terminal parameter .TPCCE = 54 - Control character echo control

.IF NE ..TPC
TPRCCE:	GETBIT	$T5ECC,SDLIT5		;Get bit and SDB offset
	BR	TPRN2B			;Continue
.ENDC

;Here for terminal parameter .TPESC = 55 - "ESC" character echo control

.IF NE ..TPC
TPRESC:	GETBIT	$T5EED,SDLIT5		;Get bit and SDB offset
TPRN2B:	BR	TPRNXB			;Continue
.ENDC

;Here for terminal parameter .TPCHS = 56 - Convert high special chrs to "ESC"

.IF NE ..TPC
TPRCHS:	GETBIT	$T4HSP,SDLIT4		;Get bit and SDB offset
	BR	TPRNXB
.ENDC

;Here for terminal parameter .TPFCR = 62 - Allow free CR/LF

.IF NE ..TPC
TPRFCR:	GETBIT	$T4NFC,SDLIT4		;Get bit and SDB offset
TPRINV:	COMB	(R4)			;Invert the value
	PUSH	R4			;Indicate should invert returned value
	BR	TPRNX2			;Continue
.ENDC

;HERE FOR TERMINAL PARAMETER .TPTRN = 64 - TRANSPARANCY MODE CONTROL

TPRTRN:	MOV	#<.PCCON+.CILTR>*400+<.PCCON+.CIETR>,R0;GET POSSIBLE VALUES
	BR	TPRCTL			;CONTINUE

;HERE FOR TERMINAL PARAMETER .TPADM = 65 - ALTERNATE DEVICE MODE CONTROL

TPRADM:	MOV	#<.PCCON+.CILAD>*400+<.PCCON+.CIEAD>,R0;GET POSSIBLE VAUES
TPRCTL:	TST	(SP)			;ACCESS OR SET?
	BNE	2$			;No-OK
	JMP	TPRSKP			;Yes-thats wrong!

2$:	BITB	#1,(R4)+		;SET-TEST VALUE
	BNE	TPRSTR			;OK IF 1
	SWAB	R0			;GET ALTERNATE CODE IF 0
	BR	TPRSTR

;HERE FOR TERMINAL PARAMETER .TPIRT = 66 - INPUT BAUD RATE

TPRIRT:;CALL	TPSIRT			;HANDLE THE INPUT BAUD RATE
;	INC	R4			;BUMP POINTER
;	BR	TPRNXT			;CONTINUE

;HERE FOR TERMINAL PARAMETER .TPRAT = 11 - BAUD RATE (SETS BOTH INPUT AND OUTPUT
;  RATES)

TPRRAT:;CALL	TPSIRT			;FIRST HANDLE THE INPUT BAUD RATE
					;FALL INTO OUTPUT BAUD RATE ROUTINE

;HERE FOR TERMINAL PARAMETER .TPORT = 67 - OUTPUT BAUD RATE

TPRORT:	PUSH	#.PCOBR			;GET TYMNET CODE
	MOVB	(R4)+,R0		;GET RATE
	BIC	#^C177,R0		;Just 7 bits
	CMP	#MAXRNT#,R0		;LEGAL RATE?
	BHIS	2$			;YES
	MOV	#MAXRNT#,R0		;NO
2$:	MOVB	TYNRNT#(R0),R0		;GET TYMNET RATE CODE
TPRPOP:	BIS	(SP)+,R0		;MERGE IN REST OF VALUE
	TST	(SP)			;SET OR ACCESS?
	BNE	TPRSTR			;SET
TPRPO2:	ASHI	-4,R0			;ACCESS-GET IN RIGHT PLACE
	BIS	#.PCQFL,R0		;ADD OTHER BITS
	BR	TPRSTR			;CONTINUE

;HERE FOR TERMINAL PARAMETER .TPIHE = 70 - INPUT HOLD ENABLE

TPRIHE:	MOV	#.QBXEN,R0		;GET TYMNET CODE
	BR	TPRBIT			;CONTINUE

;HERE FOR TERMINAL PARAMETER .TPKAT = 71 - KATAKANA MODE CONTROL

TPRKAT:	MOV	#.QBKAT,R0		;GET TYMNET CODE
TPRBIT:	BITB	#1,(R4)+		;SHOULD THE BIT BE SET?
	BEQ	TPRQSB			;NO
	INC	R0			;YES-SET IT
	BR	TPRQSB

;BRIDGES FOR OUT OF RANGE ROUTINES
TPXCRD:	BR	TPRCRD
TPXEHT:	BR	TPREHT
TPXEBS:	BR	TPREBS
TPXLFI:	BR	TPRLFI
TPXCRI:	JMP	TPRCRI
.IF NE	..TPC
TPXSCE:	BR	TPRSCE
TPXSOP:	JMP	TPRSOP
TPXEDT:	JMP	TPREDT
TPXIBL:	JMP	TPRIBL
TPXESQ:	BR	TPRESQ
.ENDC


;HERE FOR TERMINAL PARAMETER .TPPAR = 72 - PARITY CONTROL

TPRPAR:	MOVB	(R4)+,R0		;GET DATA BYTE
	TBBE	100,R0,2$		;DO WE REALLY WANT TO CHANGE PARITY?
	JMP	TPRNXT			;NO

2$:	ASR	R0			;YES-GET NEW VALUE
	ASR	R0
	BIC	#^C1,R0
	BIS	#.QBPAR,R0		;ADD TYMNET CODE
TPRQSB:	TST	(SP)			;SET OR ACCESS?
	BEQ	2$
	BIS	#.PCSBT,R0		;SET
	BR	TPRSTR

2$:	BIS	#.PCQBT,R0		;ACCESS
	BR	TPRSTR

;Here for terminal parameter .TPALF = 73 - Auto line feed

.IF NE ..TPC
TPRALF:	GETBIT	$T4ALF,SDLIT4		;GET BIT AND SDB OFFSET
	BR	TPRNXB			;CONTINUE
.ENDC

;Here for terminal parameter .TPBLT = 75 - Belt printer control (Tymnet
;  CR delay parameter)

TPRCRD:	COMB	(R4)			;Invert the value
	BIS	#$I1CRD,SDLIS1#(SD)	;Assume set
	BITB	#1,(R4)			;Right?
	BNE	2$			;Yes
	BIC	#$I1CRD,SDLIS1#(SD)	;No
2$:	MOV	#.QBCRD,R0		;Get Tymnet code
	BR	TPRBIT			;Continue

;HERE FOR TERMINAL PARAMETER .TPEHT = 76 - ECHO HORIZONTAL TAB

TPREHT:	MOV	#.QBECI,R0		;GET TYMNET CODE
	BR	TPRBIT			;CONTINUE

;Here for terminal parameter .TPEBS = 77 - Echo backspace

TPREBS:	MOV	#.QBECH,R0		;GET TYMNET CODE
	BR	TPRBIT			;Continue

;HERE TO STORE TERMINAL PARAMETER INTO RECORD IN THE FRAME

TPRSTR:	CALL	TPSSTR			;Store parameter byte
	JMP	TPRNXT			;Continue
	.PAGE
;Here for terminal parameter .TPSCE = 101 - Suppress control character echo

.IF NE ..TPC
TPRSCE:	GETBIT	$T5SCE,SDLIT5		;Get bit and SDB offset
	BR	TPRNXB			;Continue
.ENDC

;Bridges for out-of-range routines!!

;TPXLFI:	BR	TPRLFI
;.IF NE ..TPC
;.ENDC
	.PAGE
;Here for terminal parameter .TPESQ = 60 - ESC sequence control

.IF NE ..TPC
TPRESQ:	GETBIT	$T5ESQ,SDLIT5		;Get bit and SDB offset
TPRNXB:	CLR	-(SP)			;Indicate value not inverted
TPRNX2:	PUSH	R2			;Free up an AC
	MOV	R0,R2			;Seperate bit and offset
	SWAB	R2
	BIC	#^C377,R0
	ADD	SD,R0			;Get address of bit
	TST	4(SP)			;Want to change the bit?
	BEQ	6$			;No-go on
	RORB	(R4)			;Yes-get new value into C
	BCS	2$			;Should we set it?
	BICB	R2,(R0)			;No-clear it
	BR	4$

2$:	BISB	R2,(R0)			;Yes-set it
4$:	TST	4(SP)			;Should we report the current value?
	BMI	20$			;No-go on
6$:	PUSH	R3			;Yes-free up another AC
	MOVB	PKSEQ(R1),R3		;Get pointer
	ASL	R3			;Calculate address
	ADD	R1,R3
	ADD	#PKDATA+1,R3
	MOVB	-1(R4),(R3)+		;Copy parameter
	CLRB	(R3)			;Assume should return 0
	BITB	R2,(R0)			;Right?
	BEQ	12$			;Yes
	INCB	(R3)			;No-return 1
12$:	TSTB	4(SP)			;Should value be inverted?
	BEQ	14$			;No
	COMB	(R3)			;Yes-do that
	BICB	#^C1,(R3)
14$:	INCB	PKSEQ(R1)		;Increment return pointer
	POP	R3			;Restore register
20$:	POP	R2
	TST	(SP)+			;Remove flag from the stack
	INC	R4			;Bump pointer
	JMP	TPRNXT			;Thats all
.ENDC
	.PAGE
;HERE FOR TERMINAL PARAMETER .TPLFI = 37 - LINE FEED INSERSION

TPRLFI:
.IF NE ..TPC
	PUSH	R3			;Free up an AC
	TST	2(SP)			;Should we change anything?
	BEQ	4$			;No-go on
	MOVB	(R4),R0			;Yes-get new bits
	MOV	R0,R3			;Copy them
	ASHI	-4,R3			;Make mask
	COM	R3
	BIC	#^C17,R3
	BIC	R3,SDLIT2#(SD)		;Clear bits we are changing
	COM	R3
	BICB	R3,R0			;Remove extra bits
	BISB	R0,SDLIT2#(SD)		;Set desired bits
4$:	MOVB	SDLIT2#(SD),R0		;Get bits
	BIC	#^C17,R0		;Only 4 bits
	CALL	RTNINB			;Return the bits
	POP	R3			;Restore AC
.ENDC
	MOV	#.QBECL,R0		;Get tymnet code
	BR	TPREXX			;CONTINUE

;HERE FOR TERMINAL PARAMETER .TPCRI = 40 - CARRIAGE RETURN INSERSION

TPRCRI:
.IF NE ..TPC
	PUSH	R3			;Free up another AC
	TST	2(SP)			;Should we change anything here?
	BEQ	4$			;No-go on
	MOVB	(R4),R0			;Yes-get new bits
	MOV	R0,R3			;Copy them
	COM	R3			;Make into mask
	BIC	#^C160,R3
	BIC	R3,SDLIT2#(SD)		;Clear the bits we are changing
	ASHI	4,R0			;Position the bits
	COM	R3			;Remove any we are not changing
	BICB	R3,R0
	BISB	R0,SDLIT2#(SD)		;Set any bits we want to set
4$:	MOVB	SDLIT2#(SD),R0		;Get current bits
	ASHI	-4,R0			;In the right place
	BIC	#^C7,R0			;Only 3 bits
	CALL	RTNINB			;Return them
	POP	R3			;Restore AC
.ENDC
	MOV	#.QBELC,R0		;Get tymnet code
TPREXX:	BITB	#100,(R4)		;Are we changing the one TYMNET cares
					;  about?
	BEQ	2$			;Yes-go on
	JMP	TPRSKP			;No-forget it!

2$:	BITB	#4,(R4)+		;Should the bit be set?
	BEQ	4$			;No
	INC	R0			;YES
4$:	JMP	TPRQSB			;CONTINUE
	.PAGE
;Here for terminal parameter .TPIBL = 102 - Input buffer limit

.IF NE ..TPC
TPRIBL:	MOV	#SDLIIL#,R0		;Get SDB offset
	JMP	TPRNXV			;Continue
.ENDC

;Here for terminal parameter .TPSOP = 106 - Suppress output

.IF NE ..TPC 
TPRSOP:	GETBIT	$S1JNK,SDSTS1
	BR	TPRNXB
.ENDC

;Here for terminal parameters .TPEDT = 107 - Line editing enable

.IF NE ..TPC
TPREDT:	GETBIT	$T5EDT,SDLIT5
	BR	TPRNXB
.ENDC
	.PAGE
	.SBTTL	FILNAK - Fill a frame - Connect NAK packet

;HERE FOR CONNECT NAK PACKET

.IF EQ ..SAT
FILNAK:	PUSH	R2			;GIVE UP THE PACKET
	PUSH	R3
	PUSHB	PKDATA(R1)		;GET ERROR CODE
	CALL	JNKPKT#
;	POP	R3
;	POP	R2
	CALL	FRESOC			;CLEAN UP THE IN USE BIT
	BR	FILKL2			;CONTINUE
.ENDC

	.SBTTL	FILDIS - Fill a frame - Disconnect packet

;HERE FOR DISCONNECT PACKET

FILDIS:	TBBN	$I1DTP,SDLIS1#(SD),10$
	SUB	#4,LKILFT		;Account for 4 byte record?
;	BGE	4$			;Yes
;	JMP	STRCNT			;No-can't do it this time!

4$:	BIS	#$I1DTP,SDLIS1#(SD)	;Yes-indicate we have a disconnect pending
	MOVB	#2,(R2)+		;Store byte count
	MOVB	SDLICN#(SD),(R2)+	;Store channel number
	MOVB	#.CCPRE,(R2)+		;Store prefix character
	MOVB	#.PCCON!.CIYEL,(R2)+	;Store yellow ball character
10$:	CLR	SDACNT#(SD)		;Stop output
	JMP	DONSDB			;Thats all (when we get the orange
					;  ball back we will change the
					;  disconnect packet to a kill packet
					;  and process it!)

	.SBTTL	FILKIL - Fill a frame - Kill packet (on existing circuit)

;HERE FOR KILL CONNECTION PACKET

FILKIL:
	PUSH	R2
	PUSH	R3
.IF EQ ..SAT
	PUSHB	PKDATA(R1)		;GET ERROR CODE
.ENDC
	CALL	FINDIS#			;Finish processing the Disconnect or
					;  Kill packet
;	POP	R3
;	POP	R2
FILKL2:.IF EQ ..SAT
	MOV	#.S7OCZ*10000,R0	;ASSUME NOT HERE DUE TO HOST DOWN
	CMPB	#.ERHSD,(SP)+		;RIGHT?
	BNE	2$			;YES-REPORT HOST ZAP AS REASON
	MOV	#.S7OCH*10000,R0	;NO-SET HOST DOWN AS REASON
2$:
.ENDC
	MOV	SDDDB#(SD),R4
	CALL	BRKCIR#			;AND BREAK THE CIRCUIT
	POP	R3
	POP	R2
	SUB	#4,LKILFT		;NEED 4 BYTES FOR THIS ONE
	MOVB	#2,(R2)+
	MOVB	SDLICN#(SD),(R2)+	;PUT CHANNEL NUMBER IN RECORD
	MOVB	#.CCZAP,(R2)+		;STORE A CIRCUIT ZAPPER
	MOVB	#.ZCHRD,(R2)+		;STORE A HARD ZAPPER
	CLR	SDACNT#(SD)		;CLEAR THE SEND-AHEAD COUNT FOR THE SDB
	JMP	FILPKT			;THATS ALL

	.SBTTL	FILDAK - Fill a frame - Disconnect ACK packet (on existing curcuit)

;HERE FOR DISCONNECT ACK PACKET

FILDAK:	PUSH	R2			;SAVE OUR STATE
	PUSH	R3
	CALL	JNKPKT#			;GIVE UP THE PACKET
.IF EQ ..SAT
	MOV	#.S7OCU*10000,R0	;GET REASON
.ENDC
	MOV	SDDDB#(SD),R4
	CALL	BRKCIR#			;BREAK THE CIRCUIT
	CALL	FRESOC#			;GIVE UP THE SOCKET
	POP	R3			;RESTORE OUR STATE
	POP	R2
	JMP	FILPKT			;THATS ALL
	.PAGE
	.SBTTL	Subroutines used by terminal parameter routine

;Subroutine to handle input baud rate parameter
;	CALL	TPSIRT
.IF NE 0
TPSIRT:	MOVB	(R4),R0			;Get value
	BIC	#^C177,R0		;Just 7 bits
	CMP	#MAXRNT#,R0		;Legal value?
	BHIS	2$			;Yes
	MOV	#MAXRNT#,R0		;No-use highest legal value
2$:	MOVB	TYNRNT#(R0),R0		;Get Tymnet value
	TBBE	$I1CRD,SDLIS1#(SD),4$	;Is the CR delay flag set?
	BIS	#10,R0			;Yes
4$:	BIS	#.PCCIR,R0		;Put in the function bits
.ENDC					;Fall into TPSSTR to store byte

;Subroutine to store terminal parameter byte in output frame
;	C(R0) = Byte to store
;	CALL	TPSSTR

TPSSTR:	SUB	#2,LKILFT		;Reduce amount left in frame
	SUB	#2,SDACNT#(SD)		;Reduce send-ahead count for the SDB
	ADD	#2,FILCNT		;Increase record byte count
	MOVB	#.CCPRE,(R2)+		;Store prefix character
	MOVB	R0,(R2)+		;Store data character
	RETURN				;Finished

;Subroutine to return 3 or 4 bits
;	C(R0) = New value for bits
;	C(R1) = Address of packet
;	C(R4) = Pointer to current parameter in packet
;	CALL	RTNINB

RTNINB:	TST	4(SP)			;Should we return anything?
	BMI	10$			;No-forget it!
	MOVB	PKSEQ(R1),R3		;Get pointer
	ASL	R3			;Calculate address
	ADD	R1,R3
	ADD	#PKDATA+1,R3
	MOVB	-1(R4),(R3)+		;Copy parameter
	MOVB	(R4),(R3)		;Copy value
	BICB	#17,(R3)		;Clear low 4 bits
	BISB	R0,(R3)			;Put in new bits
	INCB	PKSEQ(R1)		;Bump pointer
10$:	RETURN				;Return
	.PAGE
	.SBTTL	LKIBYO - Store data byte in output frame

;Subroutine to store byte in frame buffer - if value of byte is less than
;  10 an escape code is stored before it
;	C(R0) = byte to store
;	CALL	LKIBYO
;	  failure return, byte not stored
;	normal return

LKIBYO::CMP	#10,R0			;IS IT ONE OF THE SPECIAL CODES?
	BLOS	LKIBY2			;NO-GO ON
	SUB	#2,LKILFT		;YES-DO WE HAVE ROOM FOR 2 BYTES?
	BLT	RTN009			;No-give error return
	ADD	#2,FILCNT		;Yes-increase byte count
	DEC	SDACNT(SD)		;And reduce send-ahead count to account
					;  for the extra byte
	CLRB	(R2)+			;Insert escape
	BR	LKIBY4			;Continue

;HERE FOR NORMAL CHARACTER

LKIBY2:	DEC	LKILFT			;Reduce space left in frame
	BLT	RTN009			;If no room for character
	INC	FILCNT			;Increase byte count
LKIBY4:	MOVB	R0,(R2)+		;STORE DATA BYTE IN FRAME
	ADD	#2,(SP)			;Give skip return
RTN009:	RETURN
	.PAGE
	.SBTTL	FNDHST - FIND SOURCE HOST

;SUBROUTINE TO FIND SOURCE HOST FOR A CONNECT PACKET
;	C(R1) = ADDRESS OF CONNECT PACKET
;	CALL	FNDHST
;	  ERROR RETURN - UNKNOWN HOST
;	NORMAL RETURN
;	C(R0) = INDEX * 4 + R4

.IF EQ ..SAT

FNDHST:	MOV	R1,R2			;POINT TO SRC NAME
	TSTB	PKDATA+3(R1)		;IS THERE AN EXTENSION
	BEQ	2$			;NO
	ADD	#PKDATA+24,R0		;POINT TO BEGINING OF VARIABLE DATA
	MOVB	PKDATA+1(R1),R0		;GET LENGTH OF VARIABLE LENGTH DATA AREA
	ADD	R0,R2			;OFFSET POINTER BY IT
	MOVB	PKDATA+2(R1),R0		;GET LENGTH OF DEST EXTENSION
	ADD	R0,R2			;OFFSET POINTER BY IT
	BR	4$			;GO START LOOKING
2$:	ADD	#PKDATA+16,R2
4$:	CALL	XXRD50#			;CONVERT TO RADIX 50
	PUSH	R0
	CALL	XXRD50#
	PUSH	R0
	MOV	#DDLIDH#,R0		;POINT TO TABLE IN THE DDB
	ADD	R4,R0
	MOV	#4,R2			;SCAN ALL THE SLOTS FOR THIS FUNCTION
8$:	CMP	(R0)+,2(SP)		;THIS ONE?
	BEQ	10$			;MAYBE
	TST	(R0)+			;NO-BUMP POINTER
	BR	12$			;CONTINUE

10$:	CMP	(R0)+,(SP)		;CHECK 2ND HALF
	BEQ	20$			;THIS IS IT!
12$:	SOB	R2,8$			;CONTINUE IF MORE TO CHECK
	BR	22$			;NOT THERE-GIVE ERROR RETURN

;HERE WITH MATCH ON NAME

20$:;	SUB	R4,R0			;GET INDEX
	SUB	#DDLIDH#+4,R0
;	ASR	R0
	ADD	#2,4(SP)		;GIVE GOOD RETURN
22$:	ADD	#4,SP			;FIX UP THE STACK POINTER
	RETURN				;RETURN

.ENDC		;.IF EQ ..SAT
	.PAGE
	.SBTTL	DATA

;IMPURE DATA

	IMPURE
	.EVEN

FILSVA:	.WORD	0		;ADDRESS OF BYTE COUNT FOR RECORD
LKILFT::.WORD	0		;NUMBER OF BYTES LEFT IN FRAME
FLWLMT:	.WORD	0		;NUMBER OF BYTE LEFT IN FLOW CONTROL RECORD
FLWGTF:	.WORD	0		;GUSH - TRICKLE FLAG
FILCNT:	.WORD	0		;BYTE COUNT FOR CURRENT RECORD

;Pure data

	PURE
	.EVEN			;Need this to make sure its even!

	.END

 
f	