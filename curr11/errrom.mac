	.TITLE	ERROR  - NETWORK ERROR ROUTINES
	.SBTTL	ERROR  - NEXILIS/JRG

	XLPAR				;DON'T LIST PARAMETER FILE

	CODE

;STORE THE TRAP VECTORS USED IN THIS ROUTINE

	VECTOR	 4,NXMCOD,7		;MEMORY FAILURE TRAP
	VECTOR	10,ILLERR,7		;ILLEGAL INSTRUCTION
	VECTOR	24,PWFERR,7		;POWER FAILURE
	VECTOR	34,FATERR,7		;TRAP INSTRUCTION TRAP

ERROR::!
	.SBTTL	ERROR  - MEMORY TRAP SERVICE ROUTINE

;THIS ROUTINE IS CALLED FOR ALL "4 TRAPS". IT LOOKS FOR A "NXMJMP" INSTRUCTION
;  FOLLOWING THE INSTRUCTION WHICH CAUSED THE TRAP AND SIMULATES A JMP TO
;  THE ADDRESS SPECIFIED WITH THE "NXMJMP".  IF THE OFFENDING INSTRUCTION
;  IS NOT FOLLOWED BY A "NXMJMP" INSTRUCTION, A FATAL NODE ERROR RESULTS!
;  NOTE THAT THE SIMULATED JMP DOES NOT EFFECT THE PSW IN ANY WAY!
;  THE ADDRESS OF THE INSTRUCTION
;  WHICH CAUSED THE "4 TRAP" IS NOT REPORTED (IT IS ASSUMED THAT A SEPERATE
;  NXMJMP ADDRESS WILL BE USED FOR EACH LOCATION WHICH CAN CAUSE A FAILURE).
;  ALL REGISTERS ARE PRESERVED.
;  THE CONTENTS OF LOCATIONS 4 AND 6 ARE SET AT ONCE-ONLY TIME AS FOLLOWS:
;	4/	.WORD	NXMCOD
;	6/	.WORD	000340

NXMCOD:	MOV	R0,SAVER0		;SAVE AN AC
	MOV	(SP),R0			;GET PC
	CMP	#400,R0			;IS IT BELOW THE CODE?
	BHIS	NXMERR			;YES
	CMP	#CODTOP#,R0		;IS IT ABOVE THE CODE?
	BLO	NXMERR			;YES
	BIT	#1,R0			;NO-IS AN ODD ADDRESS?
	BNE	NXMERR			;YES
	CMP	#401,(R0)+		;NO-IS IT FOLLOWED BY A "NXMJMP" INSTR?
	BEQ	NXMRT2			;YES
	CMP	#401,(R0)+		;CHECK NEXT WORD TOO IN CASE ITS THE
					;  FIRST REFERENCE OF A 3 WORD INSTR
	BEQ	NXMRT2			;YES
.IF EQ	..EIS
;IF THIS IS A FALCON IT WILL HAVE EXECUTED AN INSTRUCTION AFTER THE NXM.
; TO CHECK FOR THIS WE BACK UP OVER THE ERROR ADDRESS (AND THE AUTO INCREMENTS ABOVE)
	SUB	#10,R0			;POINT BACK WARDS
	CMP	#401,(R0)+		;CHECK FOR BRANCH OVER ERROR ROUTINE ADDRESS
	BEQ	NXMRT2			;MUST BE NON-FATAL
.ENDC
NXMERR:: MOV	#^RNXM,R0		;NO-GET FATAL ERROR CODE
	MOV	(SP)+,SAVEPC		;SAVE PC
	CLR	SAVEEI			;MAKE NON-FATAL
	BR	FATER2			;GO DIE!

;HERE IF WE FOUND A "NXMJMP" INSTRUCTION AFTER THE OFFENDING INSTRUCTION

NXMRT2:	MOV	(R0),(SP)		;PUT ADDRESS ON THE STACK
	MOV	SAVER0,R0		;RESTORE AC
	RTI				;AND "DISMISS" INTERRUPT
	.PAGE
	.SBTTL	ERROR  - STACK UNDERFLOW ROUTINE

;HERE IF ATTEMPT IS MADE TO RETURN AFTER TO MUCH HAS BEEN REMOVED FROM THE
;  STACK!

STKUND::MOV	SP,BADSTK		;SAVE BAD STACK POINTER
	MOV	#STKBGN#-40,SP		;GIVE US A NEW STACK POINTER THAT WILL
					;  LET US LOOK AT THE BOTTOM OF THE
					;  STACK!
	FSTOP	SUF			;[STACK UNDERFLOW]
	.PAGE
	.SBTTL	ERROR  - ILLEGAL TRAP ROUTINES

;HERE FOR ILLEGAL INSTRUCTION TRAP (10 AND 20)

ILLERR:	MOV	R0,SAVER0		;SAVE R0
	MOV	(SP)+,R0		;GET PC OF ERROR
	MOV	R0,SAVEPC		;SAVE PC
	MOV	(R0),BUGBUF+4		;SAVE INSTRUCTION IN ERROR
	MOV	-(R0),BUGBUF+2
	MOV	-(R0),BUGBUF
	CLR	SAVEEI			;MAKE THIS NON-FATAL
	MOV	#^RILL,R0		;GET ERROR CODE
	BR	FATER2			;CONTINUE

;HERE FOR ROWER FAILURE (24)

PWFERR:	MOV	R0,SAVER0		;SAVE R0
	MOV	#^RRWF,R0		;GET ERROR CODE
	MOV	(SP)+,SAVEPC		;SAVE PC
	CLR	SAVEEI			;MAKE THIS NON-FATAL
	BR	FATER2			;CONTINUE

;ALL UNUSED TRAP VECTORS ARE SET TO POINT TO ONE OF THE FOLLOWING FOUR
;  ROUTINES.  THE ADDRESS OF THE ACTUAL VECTOR IS ENCODED IN THE CONDITION
;  CODE BITS FOR EACH VECTOR.  THIS ALLOWS US TO DISPLAY THE ACTUAL VECTOR
;  WHICH WAS USED

;***************************************************************************
;  WARNING --- IF THE CODE BETWEEN TRPER0 AND TRPERR IS CHANGED, ALSO CHANGE
;              THE CODE IN ONCE AT FIXLP1 TO MATCH!!!!  THIS CODE IN ONCE
;              CHANGES THESE INSTRUCTIONS TO USE THE MFPS INSTRUCTION IF WE
;              ARE RUNNING ON A LSI-11!
;***************************************************************************

TRPER0::;MOV	@#PSW,@#SAVER1		;GET CONDITION BITS *** ONCE ***
	MFPS	@#SAVER1		;GET CONDITION BITS *** ONCE ***
	NOP				; EXTRA ROOM FOR ONCE
	MOV	#0,SAVER2		;INDICATE FIRST GROUP
	BR	TRPERR			;CONTINUE

TRPER1::;MOV	@#PSW,@#SAVER1		;GET CONDITION BITS *** ONCE ***
	MFPS	@#SAVER1		;GET CONDITION BITS *** ONCE ***
	NOP				; EXTRA ROOM FOR ONCE
	MOV	#20,SAVER2		;INDICATE SECOND GROUP
	BR	TRPERR			;CONTINUE

TRPER2::;MOV	@#PSW,@#SAVER1		;GET CONDITION BITS *** ONCE ***
	MFPS	@#SAVER1		;GET CONDITION BITS *** ONCE ***
	NOP				; EXTRA ROOM FOR ONCE
	MOV	#40,SAVER2		;INDICATE THIRD GROUP
	BR	TRPERR			;CONTINUE

TRPER3::;MOV	@#PSW,@#SAVER1		;GET CONDITION BITS *** ONCE ***
	MFPS	@#SAVER1		;GET CONDITION BITS *** ONCE ***
	NOP				; EXTRA ROOM FOR ONCE
	MOV	#60,SAVER2		;INDICATE FORTH GROUP
	BR	TRPERR			;CONTINUE

TRPER4::;MOV	@#PSW,@#SAVER1		;GET CONDITION BITS *** ONCE ***
	MFPS	@#SAVER1		;GET CONDITION BITS *** ONCE ***
	NOP				; EXTRA ROOM FOR ONCE
	MOV	#100,SAVER2		;INDICATE FIFTH GROUP
	BR	TRPERR			;CONTINUE

TRPER5::;MOV	@#PSW,@#SAVER1		;GET CONDITION BITS *** ONCE ***
	MFPS	@#SAVER1		;GET CONDITION BITS *** ONCE ***
	NOP				; EXTRA ROOM FOR ONCE
	MOV	#120,SAVER2		;INDICATE SIXTH GROUP
	BR	TRPERR			;CONTINUE

TRPER6::;MOV	@#PSW,@#SAVER1		;GET CONDITION BITS *** ONCE ***
	MFPS	@#SAVER1		;GET CONDITION BITS *** ONCE ***
	NOP				; EXTRA ROOM FOR ONCE
	MOV	#140,SAVER2		;INDICATE SEVENTH GROUP
	BR	TRPERR			;CONTINUE

TRPER7::;MOV	@#PSW,@#SAVER1		;GET CONDITION BITS *** ONCE ***
	MFPS	@#SAVER1		;GET CONDITION BITS *** ONCE ***
	NOP				; EXTRA ROOM FOR ONCE
	MOV	#160,SAVER2		;INDICATE EIGHTH GROUP

TRPERX==!TRPER1-TRPER0			;DEFINE SYMBOL USED BY ONCE

TRPERR:	MOV	R0,SAVER0		;SAVE R0
	MOV	2(SP),R0		;COPY PSW
	MOV	R0,-(SP)		;COPY PSW
	MOV	SAVER1,R0		;GET CONDITION BITS IN R0
	BIC	#^C17,R0		;MASK OFF JUNK
	BIS	SAVER2,R0		;GET VECTOR NUMBER
	ASL	R0			;TIMES 4
	ASL	R0			;GIVES ADDRESS
	MOV	R0,SAVEPC		;SAVE ADDRESS OF VECTOR
	MOV	#^RILV,R0		;GET ERROR CODE
	MOV	R0,SAVEEI		;SET THIS CELL TO NON ZERO TO INDICATE FATAL
	BR	FATER2			;CONTINUE
	.PAGE
	.SBTTL	ERROR  - FATAL NODE ERROR ROUTINE (FSTOP)

;THIS ROUTINE PROCESSES THE TRAP INSTRUCTION WHICH IS ONLY USED FOR REPORTING
;  FATAL NODE ERROR (FSTOP MACRO).  THE ARGUMENT OF THE FSTOP MACRO IS A 3
;  LETTER ERROR CODE WHICH IS STORED AS RADIX-50 IN THE WORD FOLLOWING THE
;  TRAP INSTRUCTION
;  THE CONTENTS OF LOCATIONS 34 AND 36 ARE SETUP BY ONCE-ONLY AS FOLLOWS:
;	34/	.WORD	FATERR
;	36/	.WORD	000340

FATERR:	RESET				;RESET THE WORLD!
	MOV	R0,SAVER0		;STORE R0
	MOV	@0(SP),R0		;GET RADIX-50 ERROR CODE
	SUB	#2,(SP)			;POINT TO TRAP INSTRUCTION
	MOV	(SP)+,SAVEPC		;SAVE PC
	MOV	@SAVEPC,SAVEEI		;SAVE THE ERROR INSTRUCTION
FATER2:	MOV	(SP)+,SAVEPS		;SAVE PSW
	MOV	R0,SAVEEC		;PUT ERROR CODE
	MOV	#SAVER1,R0		;AND SAVE OTHER AC'S
	MOV	R1,(R0)+
	MOV	R2,(R0)+
	MOV	R3,(R0)+
	MOV	R4,(R0)+
	MOV	SD,(R0)+
	MOV	SP,(R0)			;INCLUDING STACK POINTER
;	ADD	#2,(R0)
	MOV	#FATMS1,R1		;OUTPUT FIRST PART OF MESSAGE
	CALL	CTYSTR
	MOV	#3,R4			;SET COUNTER
	MOV	SAVEEC,R2		;GET ERROR CODE
FATER3:	MOV	R2,R3			;DIVIDE BY 50
	CLR	R2
	DIV	#50,R2
	CMP	#33,R3			;Is this a letter?
	BGT	3$			;Yes
	SUB	#56,R3			;No-its a number
3$:	ADD	#100,R3			;Convert to ASCII
	MOV	R3,-(SP)		;STACK THE LETTER
	SOB	R4,FATER3		;CONTINUE IF MORE
	MOV	#3,R4			;RESET COUNTER
FATER4:	MOV	(SP)+,R0		;GET LETTER
	CALL	CTYCHR			;TYPE IT
	SOB	R4,FATER4		;CONTINUE IF MORE
	MOV	#FATMS2,R1		;FINISH OFF THE LINE
	CALL	CTYSTR
	MOV	#SAVER0,R2		;SET POINTER
FATER5:	MOV	(R2)+,R1		;GET CONTENTS OF AC
	CALL	CTYOCT			;OUTPUT VALUE
	CMP	#SAVEPS,R2		;FINISHED?
	BHIS	FATER5			;NO-CONTINUE
	MOV	#FATMS5,R1		;START NEXT PART (STACK DUMP)
	CALL	CTYSTR
	MOV	SAVESP,R2		;GET STACK POINTER
	MOV	#8.,R3			;SET STACK COPY COUNTER
	MOV	R2,R1			;GET STACK POINTER
	MOV	#STKBUG,R0		;POINT TO PLACE TO SAVE STACK
10$:	MOV	(R1)+,(R0)+		;COPY A WORD
	SOB	R3,10$
	MOV	#12.,R3			;ONLY OUTPUT 12 LINES
FATER6:	MOV	#8.,SD			;8 PER LINE
	MOV	R2,R1			;GET ADDRESS
	CALL	CTYOCN			;OUTPUT WITH NO LEADING SPACES
	MOV	#':,R0
	CALL	CTYCHR			;MARK AS SUCH
FATER7:	CMP	#STKBGN#,R2		;FINISHED?
	BLOS	FATER8			;YES
	MOV	(R2)+,R1		;NO-GET NEXT VALUE
	CALL	CTYOCT			;OUTPUT IT
	SOB	SD,FATER7		;IF MORE FOR THIS LINE
	MOV	#FATMS6,R1		;END THE LINE
	CALL	CTYSTR
	CMP	R3,#6			;MIDDLE OF STACK
	BNE	10$			;NO
	MOV	#STKBGN-60,R2		;MAKE SURE WE GET START OF PROBLEM
10$:	SOB	R3,FATER6		;CONTINUE IF NOT TOO MANY

;HERE WHEN FINISHED DUMPING THE STACK

FATER8:	MOV	#FATMS4,R1		;TYPE HEADER
	CALL	CTYSTR
	MOV	#BUGBUF,R2		;DUMP "BUGBUF"
	MOV	#8.,SD
2$:	MOV	(R2)+,R1
	CALL	CTYOCT
	SOB	SD,2$			;LOOP UNTIL DONE HERE
	MOV	#FATMS9,R1		;FINISH UP
	CALL	CTYSTR
	MOV	#SAVER0,SD		;RESTORE AC'S FOR XDT
	MOV	(SD)+,R0
	MOV	(SD)+,R1
	MOV	(SD)+,R2
	MOV	(SD)+,R3
	MOV	(SD)+,R4
	MOV	(SD),SD
	JMP	.XDT.#+2		;GO START XDT OR RING BELLS DEPENDING
					;  IF XDT IS LOADED
	.PAGE
	.SBTTL	ERROR  - SUBROUTINES FOR DIRECT CTY IO

;DEFINE CTY DEVICE REGISTERS

CTYRSR==174004			;CTY RECEIVE (INPUT) STATUS REGISTER
CTYRBF==174000			;CTY RECEIVE (INPUT) DATA BUFFER
CTYXSR==174004			;CTY XMIT (OUTPUT) STATUS REGISTER
CTYXBF==174002			;CTY XMIT (OUTPUT) DATA BUFFER

;SUBROUTINE TO OUTPUT CHARACTER TO THE CTY
;	C(R0) = CHARACTER TO OUTPUT
;	CALL	CTYCHR

CTYCHR::
	MOV	R0,-(SP)		;--KSA4
	MOV	R1,-(SP)		;RESPECT R1
	CLR	R1			;INIT COUNTER
CTYOU2:	TBBN	4,CTYXSR,CTYOU3		;CONTINUE IF CTY IS READY
	SOB	R1,CTYOU2		;BUSY-WAIT (BUT ONLY FOR A SHORT TIME!)
CTYOU3:	MOVB	R0,CTYXBF		;OUTPUT THE CHARACTER
	CMPB	#CR,R0			;WAS THIS A CARRIAGE RETURN
	BNE	CTYOU4			;NO
	MOV	#NULSTR,R1		;POINT TO STRING OF NULLS
	CALL	CTYSTR			;"LETS GET RECURSIVE"
CTYOU4:	MOV	(SP)+,R1		;RESTORE R1
	MOV	(SP)+,R0		;--KSA4
RTN002:	RETURN				;RETURN

;SUBROUTINE TO OUTPUT STRING TO THE CTY
;	C(R1) = ADDRESS OF ASCIZ STRING
;	CALL	CTYSTR

CTYSTR::
	MOV	R0,-(SP)		;--KSA4
	MOV	#9.,CTYRSR+2		;POINT TO INT ENABLE REG
	CLR	CTYRSR+2		;SET REG TO ZERO
10$:	MOVB	(R1)+,R0		;GET CHARACTER
	BEQ	20$			;FINISHED IF NULL
	CALL	CTYCHR			;OUTPUT CHARACTER
	BR	10$			;CONTINUE
20$:	MOV	#9.,CTYRSR+2		;RENABLE INTERRUPTS
	MOV	#11,CTYRSR+2
	MOV	(SP)+,R0
	RETURN

;SUBROUTINE TO OUTPUT OCTAL VALUE TO THE CTY
;	C(R1) = VALUE
;	CALL	CTYOCT

CTYOCT::MOV	R1,-(SP)		;SAVE VALUE
	MOV	#FATMS7,R1		;START OUT WITH 2 SPACES
	CALL	CTYSTR
	MOV	(SP)+,R1		;RESTORE VALUE
CTYOCN:
	MOV	R0,-(SP)		;--KSA4
	MOV	R4,-(SP)		;--KSA4
	MOV	#6,R4			;6 DIGITS
	CLR	R0			;GET FIRST DIGIT
	ROL	R1			;GET FIRST DIGIT
	ROL	R0
CTYOC2:	ADD	#'0,R0			;MAKE INTO ASCII
	CALL	CTYCHR			;OUTPUT IT
	CLR	R0			;GET NEXT DIGIT
	ROL	R1
	ROL	R0
	ROL	R1
	ROL	R0
	ROL	R1
	ROL	R0
	SOB	R4,CTYOC2		;CONTINUE IF MORE
	MOV	(SP)+,R4		;--KSA4
	MOV	(SP)+,R0		;--KSA4
	RETURN				;FINISHED
	.PAGE
	.SBTTL	ERROR  - MESSAGES

FATMS1:	.ASCIZ	<CR><LF><LF>"Fatal node error "
FATMS2:	.ASCIZ	<CR><LF>"Registers:"<CR><LF>
FATMS4:	.ASCIZ	<CR><LF>"Debug:"<CR><LF>
FATMS5:	.ASCII	<CR><LF>"Stack:"
FATMS6:	.ASCIZ	<CR><LF>
FATMS7:	.ASCIZ	<177>" "<177>" "<177>
FATMS9:	.ASCIZ	<CR><LF><LF><CR><LF>
NULSTR:	.BYTE	177,177,177,177,177,177,177,177,177,177,0
	.EVEN
	.PAGE
	.SBTTL	ERROR  - IMPURE STORAGE

	.PSECT	PDATA ,RW,D,LCL,REL,CON

BUGBUF::.BLKW	8.			;DEBUG BUFFER
STKBUG:	.BLKW	8.			;PLACE TO SAVE TOP OF STACK
SAVEEC:: .WORD	4			;PLACE TO SAVE ERROR CODE
SAVEEI:: .WORD	0			;PLACE TO SAVE ERROR INSTRUCTION
SAVER0:	.WORD	0			;PLACE TO SAVE R0
SAVER1::.WORD	0			;PLACE TO SAVE R1
SAVER2:	.WORD	0			;PLACE TO SAVE R2
SAVER3:	.WORD	0			;PLACE TO SAVE R3
SAVER4:	.WORD	0			;PLACE TO SAVE R4
SAVESD:	.WORD	0			;PLACE TO SAVE R5
SAVESP:	.WORD	0			;PLACE TO SAVE STACK POINTER (R6)
SAVEPC::.WORD	0			;PLACE TO SAVE PC (R7)
SAVEPS:	.WORD	0			;PLACE TO SAVE PSW (R8)
BADSTK::.WORD	0			;PLACE TO SAVE BAD STACK POINTER ON
					;  STACK UNDERFLOW

	.END
   