	.TITLE	PKT1  PACKET SERVICE
	.SBTTL	PKT1   - NEXILIS/JRG

	XLPAR			;DON'T LIST PARAMETER FILE

	CODE

;THIS MODULE CONTAINS ROUTINES WHICH MANAGE PACKET STORAGE WITHIN THE NODE.
;INCLUDED ARE BOTH CHARACTER AND PACKET LEVEL ROUTINES.

	.SBTTL	PKT1   - PKTINI - INITIALIZE PACKET SPACE

;Subroutine to initialize packet space
;	CALL	PKTINI

PKTINI::MOV	#PKTBGN#,R3		;GET ADDRESS OF FIRST PACKET
	DEC	R3
	BIS	#77,R3
	INC	R3
	MOV	R3,PKFLST		;INITIALIZE FREE LIST POINTER
	MOV	NUMPKT,SD		;GET NUMBER OF PACKETS
	MOV	SD,PKFCNT		;INITIALIZE FREE LIST COUNT
	MOV	SD,PKFCMN
PKTIN2:	MOV	#PKTWDS-1,R0		;NUMBER OF WORDS PER PACKET - 1
	MOV	R3,R1			;ADDRESS OF START OF PACKET
	ADD	#PKTWDS*2,R3		;ADDRESS OF NEXT PACKET
	MOV	R3,(R1)+		;STORE LINK TO NEXT PACKET
	MOV	#PKTWDS-1,R2
PKTIN4:	CLR	(R1)+			;CLEAR A WORD
	SOB	R2,PKTIN4		;CONTINUE IF MORE WORDS TO CLEAR
	SOB	SD,PKTIN2		;CONTINUE IF MORE PACKETS TO MAKE
	CLR	-PKTWDS*2(R1)		;CLEAR ITS LINK
	RETURN				;AND RETURN
	.PAGE
	.SBTTL	PKT1   - GETBYT - GET CHARACTER FROM DATA PACKET

;	CALL	GETBYT
;	C:SET,Z:SET = NOTHING AVAILABLE
;	C:SET,Z:CLR = CONTROL PACKET CODE RETURNED
;	C:CLR,Z:CLR = NORMAL, DATA CHARACTER RETURN
;	C(R0) = VALUE RETURNED
;	C(R1) = ADDRESS OF PACKET

;NOTE:  THE PROGRAM CALLING GETBYT CAN PROCEED IN TWO WAYS WHEN C IS SET
;	INDICATING A CONTROL PACKET.  THE SUBROUTINE GETCTL MAY BE CALLED
;	REPEATEDLY TO FETCH BYTES FROM THE PACKET ONE AT A TIME.  GETCTL
;	WILL RETURN WITH C SET WHEN THE PACKET IS EXAUSTED.  AT THIS TIME
;	THE PACKET HAS BEEN GIVEN UP.  IF ALL OF THE BYTES ARE NOT FETCHED
;	BY CALLING GETCTL, THE SUBROUTINE FINCTL MUST BE CALLED TO GIVE UP
;	THE PACKET.  IT MAY BE CALLED IN EITHER CASE, ACUTALLY, WHICH IS A
;	GOOD IDEA.  WHEN THIS SEQUENCE IS USED, THE VALUE RETURNED IN R1
;	IS NOT USED AND R1 MAY BE DESTROYED.  THE OTHER OPTION, WHICH IS MORE
;	EFFICIENT IN MANY CASES, IS FOR THE CALLER TO DIRECTLY USE THE VALUE
;	IN R1 TO ACCESS THE PACKET.  IN THIS CASE THE OFFSETS PKCNT AND PKDATA
;	SHOULD BE USED WHEN INDEXING INTO THE PACKET.  WHEN FINISHED, JNKPKT
;	SHOULD BE CALLED TO GIVE UP THE PACKET, OR IF DESIRED, THE PACKET MAY
;	BE SENT BACK TO THE SRC BY CALLING SNDPKT.  IN ANY CASE, THE VALUE OF
;	R1 MUST BE PRESERVED UNTIL EITHER JNKPKT OR SNDPKT IS CALLED.  THESE
;	TWO METHODS SHOULD NOT BE MIXED WHEN ACCESSING A GIVEN PACKET!

GETBYT::CALL	GETPKT			;Get current packet
	BEQ	GETBY9			;If no packets now
	MOVB	PKTYPE(R1),R0		;Get packet type
	BNE	10$			;If not data packet
	MOVB	PKPNT(R1),R2		;Data packet-get character offset
	BGT	2$			;Go on if not first character
	INC	R2			;Bump pointer
	MOVB	R2,PKPNT(R1)		;And store it back
2$:	ADD	R1,R2			;Calculate address of character
	MOVB	PKDATA-1(R2),R0		;Get character
	INCB	PKPNT(R1)		;Increment character pointer
	DECB	PKCNT(R1)		;Decrement character count in packet
	BGT	4$			;Finished if still something there
	BLT	6$			;If packet was empty to begin with!
	PUSH	R0			;Packet now empty-save data byte
	CALL	JNKCPK			;Give up the packet
	POP	R0			;Restore data
4$:	CLCZ				;Give normal return
	RETURN

;Here if packet was empty when this subroutine was called

6$:	CALL	JNKCPK			;Give up the packet
	BR	GETBYT			;And try again

;Here if not data packet

10$:	SEC				;Indicate control packet
	RETURN				;And return

;Here if no packets now

GETBY9:	SECZ				;SET BOTH C AND Z
	RETURN				;RETURN
	.PAGE
	.SBTTL	PKT1   - GETCTL - GET BYTE FROM CONTROL PACKET

;	CALL	GETCTL
;	C:SET = NOTHING AVAILABLE
;	C(R0) = DATA

GETCTL::CALL	GETPKT			;Get address of packet
	DECB	PKCNT(R1)		;Decrement byte count
	BLT	GETBY9			;If no more there
2$:	MOVB	PKPNT(R1),R2		;Get character pointer
	BNE	4$			;Go on if initialized
	INCB	PKPNT(R1)		;Skip packet type!
	BR	2$

4$:	INCB	PKPNT(R1)		;Bump pointer
	ADD	R1,R2			;Calculate address of data
	MOVB	PKDATA-1(R2),R0		;Get data byte
	CLC				;Clear C
	RETURN				;And return
	.PAGE
	.SBTTL	PKT1   - PUTBYT - PLACE DATA CHARACTER INTO PACKET

;	C(R0) = CHARACTER
;	CALL	PUTBYT
;	  error return, character not stored, R0 unchanged
;	normal return, character stored, R0 not preserved
;THIS SUBROUTINE IS USED BY ALL CHARACTER AT A TIME DEVICES EXCEPT THE TERMINAL
;  SERVICE.  THE TERMINAL USES THE SUBROUTINE PUTCHR WHICH ALSO HANDLES
;  LINE MODE BUFFERING.

PUTBYT::MOV	SDPKSP#(SD),R1		;GET POINTER TO CURRENT PACKET
	BNE	PUTBY5			;GO ON IF HAVE ONE
	CMPB	SDPMAX#(SD),SDPCNT#(SD)	;TOO MANY PACKETS NOW?
	BGT	PUTBY4			;NO-GO ON
	BIS	#$S1STP,SDSTS1#(SD)	;YES-INDICATE WE HAVE BEEN STOPPED
RTN002:	RETURN				;RETURN

;HERE TO GET ANOTHER PACKET

PUTBY4: MAKPKT	.PLSTP#			;GET A NEW PACKET
	BCS	RTN002			;IF PACKET SPACE FULL (BIG TROUBLE!)
	INCB	SDPCNT#(SD)		;INCREASE PACKET COUNT
	MOV	R1,SDPKSP#(SD)		;STORE POINTER TO PACKET
	CLR	PKCNT(R1)		;CLEAR COUNT AND PACKET TYPE (PKTYPE =
					;  PKCNT + 1)
	CLRB	PKPNT(R1)		;CLEAR POINTER
	MOV	R1,R2			;COPY ADDRESS
	BR	PUTBY6			;CONTINUE

;HERE WITH EXISTING PACKET

PUTBY5:	MOVB	PKPNT(R1),R2		;GET CHARACTER POINTER
	ADD	R1,R2			;CALCULATE ADDRESS OF NEXT CHARACTER
PUTBY6:	MOVB	R0,PKDATA(R2)		;STORE CHARACTER
	INCB	PKCNT(R1)		;INCREMENT COUNT
	INCB	PKPNT(R1)		;INCREMENT POINTER
	ADD	#2,(SP)			;Give good return
	CMPB	#PKCMAX,PKPNT(R1)	;IS THIS PACKET FULL?
	BHI	RTN002			;NO-JUST GIVE NORMAL RETURN
	CJMP	SNDDP2			;Yes-send the packet and return
	.PAGE
	.SBTTL	PKT1   - JNKCPK - Give up current packet

;	CALL	JNKCPX			;Entry if address not set up

JNKCPX::MOV	SDPKCP#(SD),R1		;Get address
	BEQ	RTN002			;Forget it if no packet
					;Fall into JNKCPK

;	C(R1) = Address of packet
;	CALL	JNKCPK

JNKCPK::CMP	SDPKCP#(SD),R1		;Is this the current packet?
	BNE	2$			;No-go on
	CLR	SDPKCP#(SD)		;Yes-but not any more!
2$:	FREPKT				;Give up the packet
	BR	DECPCN			;Continue

	.SBTTL	PKT1   - JNKPKT - Give up packet

;	CALL	JNKPKX			;Entry if address not set up

JNKPKX::MOV	SDPKDH#(SD),R1		;Get address
	BEQ	RTN002			;Forget it if no packet
					;Fall into JNKPKT

;	C(R1) = Address of packet
;	CALL	JNKPKT

JNKPKT::CMP	SDPKDH#(SD),R1		;Is this packet on the DST list?
	BNE	2$			;No-go on
	CALL	REMOVE			;Yes-remove it from the DST list
2$:	FREPKT				;Give up the packet
					;Fall into DECPCN

	.SBTTL	PKT1   - DECPCN - Decrement packet count (SDPCNT) for linked SDB

;Subroutine to decrement packet count (SDPCNT) for linked SDB
;	C(SD) = address of calling SDB
;	CALL	DECPCN

DECPCN::TSTB	SDXCNT#(SD)		;Any excess packets for this socket?
	BEQ	4$			;No-go on
	DECB	SDXCNT#(SD)		;Yes-reduce it
	RETURN				;And return

4$:	MOV	(SD),R2			;Get linked socket
	BNE	DECPC4			;Go on if someone is linked
	RETURN				;Otherwise forget it!

	.SBTTL	PKT1   - DECOWN - Decrement packet count (SDPCNT) for calling SDB

;Subroutine to decrement packet count (SDPCNT) for calling SDB
;	C(SD) = address of SDB
;	CALL	DECOWN

DECOWN::MOV	(SD),R2			;Get linked SDB
	BEQ	4$			;Go on if none linked
	TSTB	SDXCNT#(R2)		;Is his extra packet count up?
	BEQ	4$			;No
	DECB	SDXCNT#(R2)		;Yes-reduce it
	RETURN				;Thats all

4$:	mov	SD,R2			;Point to the source SDB
DECPC4:	DECB	SDPCNT#(R2)		;Reduce packet count
	BGE	WAKCHK			;OK?
	CLRB	SDPCNT#(R2)		;No-fix it up!
					;Fall into WAKCHK

	.SBTTL	PKT1   - WAKCHK - Wake up linked socket if necessary

;	C(R2) = Address of SDB of linked socket
;	C(SD) = address of SDB for this socket
;	CALL	WAKCHK

WAKCHK::TBBN	$D0FLG,@SDDDB#(R2),WAKCH2;Is it a link socket which uses flags?
	TBBE	$S1STP,SDSTS1#(R2),RTN002;No-has the device been stopped?
	MOVB	SDPMAX#(SD),R3		;Yes-get limit
	ASR	R3			;Divided by 2
	CMPB	R3,SDPCNT#(R2)		;Can he resume now?
	BLT	RTN002			;No
	BIC	#$S1STP,SDSTS1#(R2)	;Yes-indicate not stopped now
WAKCH2:	BISB	#$RQRSM,SDREQB#(R2)	;Set request bit
	INCB	SDRSMC#(R2)		;Increase resume count
	CJMP	REQXR2			;Put SDB into request list and return
	.PAGE
;SUBROUTINE TO REMOVE PACKET FROM THE DST LIST
;	C(R1) = ADDRESS OF PACKET
;	C(SD) = ADDRESS OF SDB
;	CALL	REMOVE

REMOVE::MOV	(R1),SDPKDH#(SD)	;UPDATE HEAD POINTER
	BNE	6$			;GO ON IF NOT LAST IN LIST
	CMP	SDPKDT#(SD),R1		;LAST-IS THE TAIL POINTER RIGHT?
	BEQ	4$			;YES-GO ON
	CMPB	#.SSCTP,SDSTS1#(SD)	;NO-IS THIS SDB IN THE CONNECT TO
					;  PENDING STATE?
	BEQ	6$			;YES-THIS IS OK SINCE THE TAIL POINTER
					;  IS BEING USED TO POINT TO THE SAVED
					;  CONNECT PACKET!
	CMPB	#.SSRTP,SDSTS1#(SD)	;No-is this SDB in the reconnect to
					;  pending state?
	BEQ	6$			;Yes-this is like .SSCTP
	CMPB	#.SSRFW,SDSTS1#(SD)	;NO-IS THIS SDB IN THE RECONNECT FROM
					;  WAITING STATE?
	BEQ	6$			;YES-THIS IS OK SINCE IN THIS CASE THE
					;  SEND LIST HAS BEEN "BLOCKED"
	RSTOP	BTP			;[BAD TAIL POINTER]

4$:	CLR	SDPKDT#(SD)		;LIST EMPTY-CLEAR TAIL POINTER
6$:	RETURN				;RETURN
	.PAGE
	.SBTTL	PKT1   - SNDDPK - SEND DATA PACKET

;	CALL	SNDDPK

SNDDPK::MOV	SDPKSP#(SD),R1		;GET POINTER TO PACKET
	BEQ	RTN004			;FORGET IT IF NONE THERE
SNDDP2:	CLR	SDPKSP#(SD)		;CLEAR POINTER
	JMP	SNDPKT			;GO SEND PACKET AND RETURN
	.PAGE
	.SBTTL	PKT1   - CTLPKT - BEGIN CONTROL PACKET

;	C(R0) = PACKET TYPE
;	CALL	CTLPKT
;	C:SET       = FAILURE, CHARACTER DISCARDED
;	C:CLR,Z:SET = WARNING, CHARACTER ACCEPTED
;	C:CLR,Z:CLR = NORMAL, CHARACTER ACCEPTED
;	C(R1) = ADDRESS OF PACKET

;NOTE:  CONTROL PACKETS MAY BE GENERATED IN TWO WAYS.  IN EITHER CASE CTLPKT
;	IS CALLED FIRST TO SET UP THE PACKET.  IN THE FIRST METHOD CTLSTR IS
;	THEN CALLED FOR EACH CHARACTER TO BE INSERTED IN THE PACKET.  WHEN
;	FINISHED SNDPKT IS CALLED TO SEND THE PACKET.  OPTIONALLY, CTLSTE
;	MAY BE CALLED TO STORE THE LAST CHARACTER, WHICH ALSO SENDS THE PACKET.
;	THE OTHER METHOD IS TO USE THE POINTER RETURNED IN R1 DIRECTLY TO STORE
;	DATA INTO THE PACKET.  IN THIS CASE THE CALLER MUST SET PKCNT HIMSELF
;	(IT IS CLEARED BY CTLPKT).  THE PACKET IS SEND BY CALLING SNDPKT.
;	IN EITHER CASE, THE VALUE OF R1 MUST BE RESPECTED UNTIL EITHER SNDPKT
;	OR CTLSTE IS CALLED.

CTLPKT::CMPB	SDPMAX#(SD),SDPCNT#(SD)	;CAN WE HAVE ANY MORE PACKETS?
	BGT	CTLPKX			;Yes-go on
	SEC				;No-fail
	RETURN

CTLPKX::MAKPKT	.PLTRM#			;YES-GET A PACKET
	BCS	RTN004			;IF NONE AVAILABLE
	CLRB	PKCNT(R1)		;CLEAR COUNT
	MOVB	R0,PKTYPE(R1)		;STORE PACKET TYPE
	INCB	SDPCNT#(SD)		;BUMP PACKET COUNT
	RETURN				;Note:  Z will always be clear here!

	.SBTTL	PKT1   - CTLSTR - PLACE BYTE INTO CONTROL PACKET

;	C(R0) = BYTE TO STORE
;	C(R1) = ADDRESS OF PACKET
;	CALL	CTLSTR

CTLSTR::MOVB	PKCNT(R1),R2		;GET CHARACTER COUNT
	INCB	PKCNT(R1)		;BUMP CHARACTER COUNT
	ADD	R1,R2			;CALCULATE ADDRESS FOR CHARACTER
	MOVB	R0,PKDATA(R2)		;STORE CHARACTER
RTNCC4:	CLC
RTN004:	RETURN				;FINISHED

	.SBTTL	PKT1   - CTLSTE - STORE BYTE AND END CONTROL PACKET

;	C(R0) = BYTE TO STORE
;	C(R1) = ADDRESS OF PACKET
;	CALL	CTLSTE

CTLSTE::CALL	CTLSTR			;STORE CHARACTER
	JMP	SNDPKT			;AND GO SEND THE PACKET
	.PAGE
	.SBTTL	PKT1   - GETPKT - GET NEXT PACKET FROM DST LIST

;Subroutine to get next packet - if there is a current packet, it is returned
;  again, if not, the first packet on the DST list is make the curent packet
;  and returned
;	CALL	GETPKT
;	Z:clr = Normal
;	Z:set = Nothing in list
;	C(R1) = Address of packet

GETPKT::MOV	SDPKCP#(SD),R1		;Get current output packet
	BNE	10$			;Finished if have one
	MOV	SDPKDH#(SD),R1		;Get packet from DST list
	BEQ	10$			;If none
	CALL	REMOVE			;Remove from DST list
	MOV	R1,SDPKCP#(SD)		;Store as current packet
10$:	RETURN				;Thats all
	.PAGE
	.SBTTL	PKT1   - FREPKT - PLACE PACKET ON THE FREE LIST

;THIS SUBROUTINE IS CALLED WITH AN "IOT" INSTRUCTION WHICH USES A TRAP VECTOR
;  AT LOCATION 20.  THIS IS DONE TO PROVIDE A SIMPLE WAY TO DISABLE INTERRUPTS
;  WHEN CALLING THIS SUBROUTINE.  IT MAY BE CALLED FROM MAIN PROGRAM LEVEL OR
;  FROM ANY INTERRUPT LEVEL.  THE MACRO "FREPKT" IS PROVIDED WHICH GENERATES
;  AN "EMT" INSTRUCTION.
;	C(R1) = ADDRESS OF PACKET
;	PACKET MUST BE ADDRESSABLE
;	FREPKT
;  ALL REGISTERS ARE PRESERVED

	VECTOR	20,FREPAC,7

FREPAC:
.IF NE ..BUG
	CMP	R1,#PKTBGN#		;CAN THIS BE A PACKET?
	BLO	10$			;NO!!!
	BIT	#77,R1			;MAYBE-IS IT REALLY?
	BEQ	20$			;YES-WE ARE HAPPY WITH IT
10$:	RSTOP	BPA			;[BAD PACKET ADDRESS]

20$:	PUSH	R1			;SAVE PACKET POINTER
	MOV	#PKFLST,R1		;GET FREE LIST POINTER ADDRESS

    .REPT  5.				;CHECK 1ST FEW FREE PACKETS
	MOV	(R1),R1			;GET NEXT FREE PACKET POINTER
	BEQ	30$			;STOP CHECKING AT END OF LIST
	CMP	R1,(SP)			;PACKET TO FREE ALREADY ON LIST?
	BEQ	10$			;YES - ERROR
    .ENDR

30$:	POP	R1			;RESTORE PACKET POINTER

.ENDC
	MOV	PKFLST,(R1)		;LINK THIS PACKET ONTO THE FREE LIST
	MOV	R1,PKFLST		;THIS PACKET BECOMES NEW FIRST ON FREE
					;  LIST
	INC	PKFCNT			;INCREASE COUNT OF FREE PACKETS
	CLR	R1			;Make it clear so it can't be used
	RTI				;RETURN
	.PAGE
	.SBTTL	PKT1   - MAKPKT - GET PACKET FROM THE FREE LIST

;This subroutine is called with an "EMT" instruction which uses a trap vector
;  at location 30.  This is done to provide a simple way to disable interrupts
;  when calling this subroutine.  It may be called from main program level or
;  from any interrupt level.  The macro "MAKPKT" is provided which generates
;  an "IOT" instruction.

;Packets are fixed length buffer "chunks" which are used for a varity of uses
;  in the node.  Unallocated packets are linked into a "free list" with the
;  first word of each packet containing the address of the next packet in
;  the list.  The word PKFLST points to the first packet in the list.  The
;  word PKFCNT contains a count of the number of packets in the list.  Normally
;  the last packet in the free list is not available; it is reserved for use
;  by the MAKKIL routine to ensure that a Kill packet can always be obtained
;  when necessary.  MAKKIL will increase PKFCNT by 1 before calling MAKPAC to
;  make the last packet available!

;	MAKPKT	LIMIT
;	C:SET = None available
;	C:CLR = Normal
;	C(R1) = Address of packet (first word has been cleared)

	VECTOR	30,MAKPAC,7

MAKPAC:	CMP	PKFCNT,#20		;ARE WE LOW ON PACKETS?
	BGT	6$			;NO-DON'T BOTHER TO CHECK LIMIT!
	MOV	(SP),R1			;YES-GET LIMIT
	MOVB	-2(R1),R1
	CMP	PKFCNT,R1
	BLE	50$			;NOT ENOUGH-GO FAIL!
6$:	MOV	PKFLST,R1		;Get pointer to first packet on free
					;  list
	BEQ	50$			;If none there
.IF NE ..BUG
	CMP	R1,#PKTBGN#		;Can this be a packet?
	BLO	10$			;No
	BIT	#77,R1			;Maybe-really?
	BEQ	20$			;Yep
10$:	RSTOP	BPA			;[Bad Packet Address]
.ENDC

20$:	MOV	(R1),PKFLST		;Remove this packet from the free list
	BEQ	24$			;IF LIST IS EMPTY NOW
	DEC	PKFCNT			;NOT EMPTY-REDUCE COUNT
	BGT	30$			;MAKE SURE COUNT IS OK
	BR	26$

24$:	DEC	PKFCNT			;LIST IS EMPTY-REDUCE COUNT
	BEQ	30$			;MUST BE ZERO NOW!
26$:	RSTOP	BFC			;[BAD FREE COUNT]

30$:	CMP	PKFCNT,PKFCMN		;IS THIS A NEW MINIMUM?
	BGE	32$			;NO
	MOV	PKFCNT,PKFCMN		;YES
32$:	CLR	(R1)			;Clear the link word
	BIC	#1,2(SP)		;Clear C
	RTI				;And return

;HERE IF NO PACKETS AVAILABLE NOW

50$:	BIS	#1,2(SP)		;Set C
	CLR	R1			;Make sure R1 is zero
	RTI				;And return
	.PAGE
	.SBTTL	PKT1   - GIVPKT - RETURN PACKET WITH CHECK FOR HOLDING

;	C(R1) = ADDRESS OF PACKET
;	C(R4) = ADDRESS OF DDB FOR DEVICE GIVING UP THE PACKET
;	CALL	GIVPKT

GIVPKT::FREPKT				;DO THIS FOR REAL LATER!!
RTN008:	RETURN
	.PAGE
	.SBTTL	PKT1   - PKTAGN - PUT A PACKET BACK

;	C(R1) = ADDRESS OF PACKET
;	CALL	PKTAGN

PKTAGN::MOV	(SD),R2			;GET LINKED SDB
	BEQ	2$			;IF NONE
	INCB	SDPCNT#(R2)		;BUMP HIS COUNT
2$:	MOV	SDPKDH#(SD),R2		;GET FIRST PACKET ON DST LIST
	MOV	R1,SDPKDH#(SD)		;PUT OUR PACKET AT THE HEAD
	MOV	R2,(R1)
	BNE	4$			;IF NOT ONLY PACKET IN LIST
	MOV	R1,SDPKDT#(SD)		;ONLY ONE IN LIST-UPDATE TAIL POINTER
4$:	RETURN				;THATS ALL
	.PAGE
	.SBTTL	PKT1   - ACCEPT - ACCEPT CONNECTION

;	C(R1) = ADDRESS OF CONNECT PACKET
;	C(R2) = TRM PROFILE * 400 + FLAG BITS (IF PROFILE = 377, DON'T
;		  CHANGE THE CURRENT PROFILE PARAMETERS)
;	CALL	ACCEPT
;	C(R0) = Priviledge level value from Connect packet

ACCEPT::MOV	#.PTACK*400+3,PKCNT(R1)	;CHANGE THIS TO AN ACK PACKET
	MOVB	SDSOC#(SD),PKDATA(R1)	;STORE SOCKET NUMBER AS DATA
	MOVB	R2,PKDATA+1(R1)		;STORE FLAG BITS
	SWAB	R2			;AND STORE TERMINAL PROFILE
	INC	R2
	MOVB	R2,PKDATA+2(R1)
	PUSHB	PKDATA+24(R1)		;Save priviledge level
	CALL	PKTRTX			;SEND PACKET BACK TO SRC
	POPB	R0			;Get priviledge level
	CLC				;INDICATE GOOD RETURN
	RETURN				;FINISHED

	.SBTTL	PKT1   - REFUSE - REFUSE CONNECTION

;	C(R0) = CONNECTION FAILURE CODE (.ERXXX)
;	C(R1) = ADDRESS OF CONNECT PACKET
;	CALL	REFUSE

REFUSE::CALL	SETNAK			;SETUP A NAK PACKET
	CALL	PKTRTX			;SEND IT
RTNCS8:	SEC
	RETURN
	.PAGE
	.SBTTL	PKT1   - MAKKIL - MAKE A KILL PACKET

;Subroutine to generate a Kill packet - this subroutine will use the reserve
;  packet on the free list if necessary to garrentee that a Kill packet can
;  always be obtained!  The routine calling MAKKIL !must! call SNDPKT to send
;  the Kill packet before returning to the main program loop.  This subroutine
;  !must not! be called from interrupt level!!!!
;	C(R0) = ERROR CODE
;	CALL	MAKKIL
;	C(R1) = Address of Kill packet

MAKKIL::MAKPKT	.PLKIL#			;Get a packet
	BCC	SETKIL			;We should always get one here!!
	RSTOP	NPA			;[No Packet Available]

	.SBTTL	PKT1   - SETKIL - SET UP A KILL PACKET

;	C(R0) = ERROR CODE
;	C(R1) = ADDRESS OF PACKET
;	CALL	SETKIL
;	C(R1) = ADDRESS OF KILL PACKET

SETKIL::MOV	#.PTKIL*400,PKCNT(R1)	;STORE TYPE, CLEAR COUNT BYTE
	BR	SETEPK			;CONTINUE

	.SBTTL	PKT1   - SETDIS - SETUP A DISCONNECT PACKET

;SUBROUTINE TO SETUP A DISCONNECT PACKET
;	C(R0) = REASON CODE
;	C(R1) = ADDRESS OF PACKET
;	CALL	SETDIS

SETDIS::MOV	#.PTDIS*400,PKCNT(R1)	;MAKE IT A DISCONNECT PACKET
	BR	SETEPK			;CONTINUE

	.SBTTL	PKT1   - SETNAK - SETUP A NAK PACKET

;	C(R0) = CONNECTION FAILURE CODE (.ERXXX)
;	C(R1) = ADDRESS OF PACKET
;	CALL	SETNAK

SETNAK::MOV	#.PTNAK*400,PKCNT(R1)	;MAKE A NAK PACKET FROM THE CONNECT
SETEPK::MOVB	R0,PKDATA(R1)		;STORE DATA BYTE
	PUSH	R2			;SAVE REGISTERS
	PUSH	R3
	MOV	#THSNOD#,R3		;GET ADDRESS OF THE NAME OF THIS NODE
	MOV	R1,R2			;MAKE POINTER TO PACKET
	ADD	#PKDATA+1,R2
2$:	INCB	PKCNT(R1)		;BUMP BYTE COUNT
	MOVB	(R3)+,(R2)+		;COPY CHARACTER
	BNE	2$			;CONTINUE IF MORE
	POP	R3			;RESTORE REGISTERS
	POP	R2
RTN012:	RETURN				;FINISHED
	.PAGE
	.SBTTL	PKT1   - CPKRTN - Send current packet back to its source

;	C(R1) = Address of packet which may be the current packet
;	CALL	CPKRTN

PKTRTX::TST	SDPKCP#(SD)
	BEQ	PKTRTN
CPKRTN::CMP	SDPKCP#(SD),R1		;Is this the current packet?
	BNE	PKTRT4			;No
	CLR	SDPKCP#(SD)		;Yes-but not any more!
	BR	PKTRT2			;Continue

	.SBTTL	PKT1   - PKTRTN - Send packet back to its source

;	C(R1) = Address of packet which may be at head of DST list
;	CALL	PKTRTN

PKTRTN::CMP	SDPKDH#(SD),R1		;Is the packet still on the DST list?
	BNE	PKTRT4			;No
	CALL	REMOVE			;Yes-remove packet from the DST list
PKTRT2:	CALL	DECPCN			;Reduce his packet count
PKTRT4:	INCB	SDPCNT#(SD)		;Increment our packet count
	CJMP	SNDPKT			;Send it and return
	.PAGE
	.SBTTL	PKT1   - OUTSUP - SUPPRESS OUTPUT

OUTSUP::MOV	#.FNOPS,R0		;GET FUNCTION
	BR	CLRIN2			;CONTINUE

	.SBTTL	PKT1   - CLRINP - CLEAR INPUT BUFFER

CLRINP::MOV	#.FNRQC,R0		;GET FUNCTION
CLRIN2:	MAKPKT	.PLSTP#			;GET A PACKET
	BCS	RTN012			;FORGET IT CAN'T GET ONE
	BIS	#$S1JNK,SDSTS1#(SD)	;GOT ONE-INDICATE SHOULD JUNK DATA PKTS
	MOV	#.PTINT*400+1,PKCNT(R1)	;MAKE THIS A 1 CHARACTER INTERRUPT PKT
	MOVB	R0,PKDATA(R1)		;STORE FUNCTION
	CJMP	SNDPKT			;SEND THE PACKET AND RETURN
	.PAGE
	.SBTTL	PKT1   - DATA STORAGE

;PURE DATA FOR PACKET SPACE (SET UP AT ONCE-ONLY TIME)

	PSECT	PURE,RW,D,LCL,REL,CON

NUMPKT::.WORD	0		;NUMBER OF PACKETS IN PACKET SPACE

;IMPURE DATA FOR PACKET SPACE

	PSECT	IMPURE,RW,D,LCL,REL,CON

PKFLST::.WORD	0		;FREE LIST HEAD POINTER
PKFCNT::.WORD	0		;COUNT OF NUMBER OF PACKETS ON FREE LIST
PKFCMN::.WORD	0		;MINIMUM VALUE SEEN FOR PKFCNT

;	.END
;	.TITLE	PKT2  SEND PACKET ROUTINES
	.SBTTL	NEXILIS/JRG

	XLPAR				;DON'T LIST PARAMETER FILE

;THIS MODULE CONTAINS ROUTINES TO SEND PACKETS FROM ONE DEVICE TO ANOTHER

	CODE

	.SBTTL	SUBROUTINE TO SEND PACKET

;A PACKET WHICH HAS BEEN SENT IS NO LONGER AVAILABLE TO THE SOURCE.  THE NEXT
;  BYTE STORED WILL START A NEW PACKET.
;	C(R1) = ADDRESS OF PACKET
;	PACKET MUST BE ADDRESSABLE
;	CALL	SNDPKT

SNDPKT::CMP	R1,#PKTBGN#		;IS THIS A VALID PACKET?
	BLO	2$			;NO!
	TBBE	77,R1,4$		;YES-GO ON
2$:	RSTOP	BPA			;[BAD PACKET ADDRESS]

4$:	PUSH	R4			;Save the DDB pointer
	MOVB	PKTYPE(R1),R0		;GET PACKET TYPE
	CMP	#MAXPKT,R0		;IS THIS A VALID PACKET TYPE?
	BHIS	10$			;YES
	MOV	#MAXPKT,R0		;NO
	MOVB	R0,PKTYPE(R1)		;FIX THE VALUE IN THE PACKET TOO!
10$:	ASL	R0			;TIMES 2 FOR WORD INDEXING
	MOVB	SDSTS1#(SD),R3		;GET STATE OF THIS DEVICE
	CALL	@STADSP(R3)		;DISPATCH ON THE STATE
	POP	R4			;Restore the DDB pointer
	RETURN				;Leave for now
	.PAGE
;A few words are in order here about the socket states.  The socket state is
;  used when a packet is sent from a socket (SNDPKT is called) to determine
;  how it should be processed.  Each state value represents a resonably
;  identifiable condition relative to connections as follows:
;    .SSDIS	The socket is disconnected.  The socket is not linked to
;		another socket.  The only packet which should ever be sent
;		from a disconnected socket is a Connect packet (.PTCON).
;    .SSCTP	Connection to the socket is pending.  A Connect packet has
;		been sent to the socket but a Connect ACK or Connect NAK has
;		not been received yet.  The only packets which should be sent
;		from a socket in this state are Connect ACK, Connect NAK, or
;		possibly Kill.
;    .SSCFP	Connection from the socket is pending.  A connect packet has
;		been sent from the socket but a Connect ACK or Connect NAK has
;		not been received yet.  A socket in this state is always linked
;		to one in the .SSCTP state.  The only packet which should be
;		sent from a socket in this state is Kill.
;    .SSCON	This socket is fully connected.  The linked socket must have
;		the same state.
;    .SSDTP	This socket has received a Disconnect packet but has not yet
;		sent a Disconnect ACK packet.  The linked socket must be in
;		the .SSDFP state.
;    .SSDFP	Disconnect from socket is pending.  This socket has sent a
;		Disconnect packet but has not yet received a Disconnect ACK
;		packet.  The state of the linked socket must be .SSDTP
	.PAGE
;Socket state dispatch table

	PURE

STADSP:	.WORD	STADIS		;.SSDIS =  0 - Disconnected
	.WORD	STACTP		;.SSCTP =  2 - Connect to socket pending
	.WORD	STACFP		;.SSCFP =  4 - Connect from socket pending
	.WORD	STACON		;.SSCON =  6 - Connected
	.WORD	STADTP		;.SSDTP = 10 - Disconnect to socket pending
	.WORD	STADFP		;.SSDFP = 12 - Disconnect from socket pending
	.WORD	STADTP		;.SSKT1 = 14 - Kill to socket pending - 1
	.WORD	STADTP		;.SSKT2 = 16 - Kill to socket pending - 2
	.WORD	STAZAP		;.SSZTR = 20 - Zap to socket requested
	.WORD	JNKOWN		;.STZFR = 22 - Zap from socket requested
	.WORD	STARTP		;.SSRTP = 24 - Reconnect to socket pending
	.WORD	STARFP		;.SSRFP = 26 - Reconnect from socket pending
	.WORD	STARTW		;.SSRTW = 30 - Reconnect to socket waiting
	.WORD	STARFW		;.SSRFW = 32 - Reconnect from socket waiting
	.WORD	STARIP		;.SSRIP = 34 - Reconnect in progress

	CODE
	.PAGE
;HERE FOR STATE = .SSDIS = 0 (DISCONNECTED)

STADIS:	JMP	@DSPDSC(R0)		;DISPATCH ON THE PACKET TYPE

;DISPATCH TABLE FOR STATE = .SSDIS = 0 (DISCONNECTED)

	PURE

DSPDSC:	.WORD	JNKOWN		;.PTDAT =  0 - DATA
	.WORD	CONNCT		;.PTCON =  1 - CONNECT REQUEST
	.WORD	JNKOWN		;.PTACK =  2 - CONNECT ACK
	.WORD	JNKOWN		;.PTNAK =  3 - CONNECT NAK
	.WORD	JNKOWN		;.PTFUN =  4 - FUNCTION
	.WORD	JNKOWN		;.PTINT =  5 - INTERRUPT FUNCTION
	.WORD	JNKOWN		;.PTEAT =  6 - EAT FUNCTION
	.WORD	JNKOWN		;.PTDIS =  7 - DISCONNECT
	.WORD	JNKOWN		;.PTKIL = 10 - KILL CONNECTION
	.WORD	JNKOWN		;.PTDAK = 11 - DISCONNECT ACK
	.WORD	JNKOWN		;.PTRCR = 12 - RECONNECT REQUEST
	.WORD	JNKOWN		;	     - ILLEGAL
MAXPKT==!<.-DSPDSC-2>/2

	CODE

;HERE FOR STATE = .SSCTP = 2 (CONNECTION TO SOCKET PENDING)

STACTP:	JMP	@DSPCTP(R0)		;DISPATCH ON THE PACKET TYPE

;DISPATCH TABLE FOR STATE = .SSCTP = 2 (CONNECTION TO SOCKET PENDING)

	PURE

DSPCTP:	.WORD	KILKIX		;.PTDAT =  0 - DATA
	.WORD	CONCOL		;.PTCON =  1 - CONNECT REQUEST
	.WORD	SNDACK		;.PTACK =  2 - CONNECT ACK
	.WORD	SNDNAK		;.PTNAK =  3 - CONNECT NAK
	.WORD	KILKIX		;.PTFUN =  4 - FUNCTION
	.WORD	KILKIX		;.PTINT =  5 - INTERRUPT FUNCTION
	.WORD	KILKIX		;.PTEAT =  6 - EAT FUNCTION
	.WORD	SNDNAK		;.PTDIS =  7 - DISCONNECT
	.WORD	SNDNAK		;.PTKIL = 10 - KILL CONNECTION
	.WORD	KILKIX		;.PTDAK = 11 - DISCONNECT ACK
	.WORD	KILKIX		;.PTRCR = 12 - RECONNECT REQUEST
	.WORD	KILKIX		;	     - ILLEGAL

	CODE
	.PAGE
;HERE FOR STATE = .SSCFP = 4 (CONNECTION FROM SOCKET PENDING)

STACFP:	JMP	@DSPCFP(R0)		;DISPATCH ON THE PACKET TYPE

;DISPATCH TABLE FOR STATE = .SSCFP = 3 (CONNECTION FROM SOCKET PENDING)

	PURE

DSPCFP:	.WORD	KILKIW		;.PTDAT =  0 - DATA
	.WORD	KILKIW		;.PTCON =  1 - CONNECT REQUEST
	.WORD	KILKIW		;.PTACK =  2 - CONNECT ACK
	.WORD	KILKIW		;.PTNAK =  3 - CONNECT NAK
	.WORD	KILKIW		;.PTFUN =  4 - FUNCTION
	.WORD	KILKIW		;.PTINT =  5 - INTERRUPT FUNCTION
	.WORD	KILKIW		;.PTEAT =  6 - EAT FUNCTION
	.WORD	SNDKIW		;.PTDIS =  7 - DISCONNECT
	.WORD	SNDKIW		;.PTKIL = 10 - KILL CONNECTION
	.WORD	KILKIW		;.PTDAK = 11 - DISCONNECT ACK
	.WORD	KILKIW		;.PTRCR = 12 - RECONNECT REQUEST
	.WORD	KILKIW		;	     - ILLEGAL

	CODE

;HERE FOR STATE = .SSCON = 6 (CONNECTED)

STACON:	JMP	@DSPCON(R0)		;DISPATCH ON THE PACKET TYPE

;DISPATCH TABLE FOR STATE = .SSCON = 6 (CONNECTED)

	PURE

DSPCON:	.WORD	SNDDTP		;.PTDAT =  0 - DATA
	.WORD	KILKIL		;.PTCON =  1 - CONNECT REQUEST
	.WORD	KILKIL		;.PTACK =  2 - CONNECT ACK
	.WORD	KILKIL		;.PTNAK =  3 - CONNECT NAK
	.WORD	SNDDAT		;.PTFUN =  4 - FUNCTION
	.WORD	SNDINT		;.PTINT =  5 - INTERRUPT FUNCTION
	.WORD	SNDEAT		;.PTEAT =  6 - EAT FUNCTION
	.WORD	SNDDIS		;.PTDIS =  7 - DISCONNECT
	.WORD	SNDKIL		;.PTKIL = 10 - KILL CONNECTION
	.WORD	KILKIL		;.PTDAK = 11 - DISCONNECT ACK
	.WORD	SNDRCR		;.PTRCR = 12 - RECONNECT REQUEST
	.WORD	KILKIL		;	     - ILLEGAL

	CODE
	.PAGE
;HERE FOR STATE = .SSDTP = 10 (DISCONNECT TO SOCKET PENDING)

STADTP:	JMP	@DSPDTP(R0)		;DISPATCH ON THE PACKET TYPE

;DISPATCH TABLE FOR STATE = .SSDTP = 10 (DISCONNECT TO SOCKET EPNDING)

	PURE

DSPDTP:	.WORD	JNKOWN		;.PTDAT =  0 - DATA
	.WORD	JNKOWN		;.PTCON =  1 - CONNECT REQUEST
	.WORD	JNKOWN		;.PTACK =  2 - CONNECT ACK
	.WORD	JNKOWN		;.PTNAK =  3 - CONNECT NAK
	.WORD	JNKOWN		;.PTFUN =  4 - FUNCTION
	.WORD	JNKOWN		;.PTINT =  5 - INTERRUPT FUNCTION
	.WORD	JNKOWN		;.PTEAT =  6 - EAT FUNCTION
	.WORD	SNDDAK		;.PTDIS =  7 - DISCONNECT
	.WORD	SNDDAK		;.PTKIL = 10 - KILL CONNECTION
	.WORD	SNDDAK		;.PTDAK = 11 - DISCONNECT ACK
	.WORD	JNKOWN		;.PTRCR = 12 - RECONNECT REQUEST
	.WORD	JNKOWN		;	     - ILLEGAL

	CODE

;Here for state = .SSDFP = 12 (Disconnect from socket pending)

STADFP:	JMP	@DSPDFP(R0)		;Dispatch on the packet type

;Dispatch table for state = .SSDFP = 12 (Disconnect from socket pending)

	PURE

DSPDFP:	.WORD	KILKIQ		;.PTDAT =  0 - DATA
	.WORD	KILKIQ		;.PTCON =  1 - CONNECT REQUEST
	.WORD	KILKIQ		;.PTACK =  2 - CONNECT ACK
	.WORD	KILKIQ		;.PTNAK =  3 - CONNECT NAK
	.WORD	KILKIQ		;.PTFUN =  4 - FUNCTION
	.WORD	KILKIQ		;.PTINT =  5 - INTERRUPT FUNCTION
	.WORD	KILKIQ		;.PTEAT =  6 - EAT FUNCTION
	.WORD	SNDKIQ		;.PTDIS =  7 - DISCONNECT
	.WORD	SNDKIQ		;.PTKIL = 10 - KILL CONNECTION
	.WORD	KILKIQ		;.PTDAK = 11 - DISCONNECT ACK
	.WORD	KILKIQ		;.PTRCR = 12 - RECONNECT REQUEST
	.WORD	KILKIQ		;	     - ILLEGAL

	CODE
	.PAGE
	.SBTTL	ROUTINES FOR UNEXPECTED OR OUT-OF SEQUENCE PACKETS

;HERE FOR UNEXPECTED PACKET WHEN CONNECTION PENDING TO SOCKET

KILKIX::CALL	CLRCTP			;CLEAR THE CONNECT TO SOCKET PENDING
					;  STATE
	BR	KILKIL			;CONTINUE

;Here for unexpected packet when disconnect pending from socket

KILKIQ:	CALL	CLRDFP			;Clear the pending state
	BR	KILKIL			;Continue

;HERE FOR UNEXPECTED PACKET WHEN CONNECTION PENDING FROM SOCKET

KILKIW::CALL	CLRCFP			;CLEAR PENDING CONNECTION

;HERE FOR UNEXPECTED PACKET WHEN NOT DISCONNECTED - SEND KILL PACKETS IN
;  BOTH DIRECTIONS!

KILKIL::CMP	R1,SDPKCP#(SD)		;IS THE PACKET WE ARE GOING TO CHANGE TO
	BNE	1$			; A KILL THE CURRENT PACKET?
	CLR	SDPKCP#(SD)		;YES - KEEP CLRSDV FROM RETURNING IT
1$:	CALL	CLRSDV			;CLEAR DST LIST OF SRC
	CALL	CLRDDV			;AND CLEAR DST LIST OF DST
	CALL	DECOWN			;FIX UP OUR PACKET COUNT
	MOV	#.ERISP,R0		;Reason = Illegal sequence of packets
	CALL	SETKIL			;Setup the kill packet
	MOV	(SD),R2			;POINT TO DST
	BNE	2$			;BE SURE!
	RSTOP	NSL			;[NO SOCKET LINKED]

2$:	CLR	(SD)			;UNLINK
	CLR	(R2)
	MOVB	#.SSDTP,SDSTS1#(R2)	;Update DST socket state
	BIC	#$S1DPS,SDSTS1#(R2)
	CALL	SNDDA0			;SEND KILL PACKET TO DST
KILKI2::MOV	#.ERISP,R0		;Reason = Illegal sequence of packets
KILKI3::MAKPKT	.PLTRM#			;MAKE ANOTHER PACKET
	BCC	STAZA2			;GO ON IF GOT ONE
	MOVB	#.SSZTR,SDSTS1#(SD)	;Can't get a packet-indicate we have
					;  been zapped!
	MOV	R0,SDPKDH#(SD)		;Remember the reason
	RETURN				;Thats the best we can do!!

;Here for any packet from socket in the .SSZTR state - the only reason a
;  socket is placed in this state is that were out of packets when we wanted
;  to send a kill or disconnect to this socket.  Thus this socket is really
;  disconnected - it just does not know it yet!

STAZAP:	CALL	DECOWN
	MOVB	SDPKDH#(SD),R0		;Get saved reason
	CLR	SDPKDH#(SD)
STAZA2:	CLRB	SDPCNT#(SD)		;Make sure his packet counts are right
	MOVB	#1,SDXCNT#(SD)
	MOVB	#.SSDTP,SDSTS1#(SD)	;Update socket state
	BIC	#$S1DPS,SDSTS1#(SD)	;Clear timer sync bit
	CALL	SETKIL			;Change it into a Kill packet
	CJMP	SNDSRC			;Send it back to the SRC
	.PAGE
	.SBTTL	CONNECT PACKET

;THE CONNECT PACKET IS DIVIDED INTO 6 AREAS.  THE FIRST 3 AREAS ARE A FIXED
;  SIZE, THE LAST 3 ARE VARIABLE SIZE.

;PREFIX AREA: (LENGTH = 4 BYTES)
;  PKDATA+ 0/	VERSION NUMBER (ALWAYS 200 NOW)
;		100 IS ADDED TO THE VERSION NUMBER IF THIS PACKET WAS
;		  GENERATED BY A RECONNECT SEQUENCE
;  PKDATA+ 1/	SIZE OF DATA AREA (BYTES)
;  PKDATA+ 2/	SIZE OF DST EXTENSION AREA (BYTES)
;  PKDATA+ 3/	SIZE OF SRC EXTENSION AREA (BYTES)
;DST SPECIFICATION AREA: (LENGTH = 8 BYTES)
;  PKDATA+ 4/	DST DEVICE I.D.
;  PKDATA+ 5/	DST SOCKET NUMBER
;  PKDATA+ 6/	1ST CHARACTER OF DST NAME
;  PKDATA+ 7/	2ND CHARACTER OF DST NAME
;  PKDATA+10/	3RD CHARACTER OF DST NAME
;  PKDATA+11/	4TH CHARACTER OF DST NAME
;  PKDATA+12/	5TH CHARACTER OF DST NAME
;  PKDATA+13/	6TH CHARACTER OF DST NAME
;SRC SPECIFICATION AREA: (LENGTH = 8 BYTES)
;  PKDATA+14/	SRC DEVICE I.D.
;  PKDATA+15/	SRC SOCKET NUMBER
;  PKDATA+16/	1ST CHARACTER OF SRC NAME
;  PKDATA+17/	2ND CHARACTER OF SRC NAME
;  PKDATA+20/	3RD CHARACTER OF SRC NAME
;  PKDATA+21/	4TH CHARACTER OF SRC NAME
;  PKDATA+22/	5TH CHARACTER OF SRC NAME
;  PKDATA+23/	6TH CHARACTER OF SRC NAME
;DATA AREA: (VARIABLE LENGTH, MINIMUM = 11 BYTES)
;  PKDATA+24/	PRIV. LEVEL
;  PKDATA+25/	PRIV. CLASS
;  PKDATA+26/	LINK PRIORITY
;  PKDATA+27/	CONNECTION TYPE
;		200 = SUPERVISORY CONNECTION
;		100 = RECONNECT
;  PKDATA+30/	CONNECTION SUB-TYPE
;  PKDATA+31/	Maximum number of packets which may be buffered for
;		  this connection
;  PKDATA+32/	Not used
;  PKDATA+33/	SRC "Terminal type"
;  PKDATA+34/	SRC "Baud rate"
;  PKDATA+35/	Flag bits
;		For normal connections:
;		  200 = Report terminal parameters
;		  100 = Enable deferred echo mode
;		  040 = Login string available
;		  020 = Password already varified
;		  010 = Don't enable echoing
;		  004 = Don't hold input if output is active
;		  002 = Local copy terminal
;		  001 = Don't clear login mode
;		For supervisory connections:
;		  200 = Host is available for connections (answered)
;  PKDATA+36/	TERMINAL PROFILE PLUS 1 (0 IF SHOULD NOT SET PROFILE)
;  PKDATA+../	ADDITIONAL BYTES MAY BE ADDED HERE AS NEEDED
;DST EXTENSION AREA: (VARIABLE LENGTH, MINIMUM = 0 BYTES)
;  ........./	THIS AREA CONTAINS ADDITIONAL BYTES REQUIRED TO SPECIFY THE
;		  DST ADDRESS
;SRC EXTENSION AREA: (VARIABLE LENGTH, MINIMUM = 0 BYTES)
;  ........./	THIS AREA CONTAINS ADDITIONAL BYTES REQUIRED TO SPECIFY THE
;		  SRC ADDRESS

CONNCT:	CALL	CONNSB			;Try to connect
	  RETURN			;OK-just return for now
	MOVB	#1,SDXCNT#(SD)		;Failed immediately-fix up the count
	CJMP	SNDSRC			;And send NAK packet back to the SRC
	.PAGE
;Subroutine to connect - also called by PKT3 for a reconnect sequence
;	C(R1) = address of connect packet
;	C(SD) = address of SRC SDB
;	CALL	CONNSB
;	  return if everything worked
;	return if immediate failure occured
;	C(R1) = address of NAK packet

CONNSB::CLRB	77(R1)			;JUST INCASE
	CALL	SETINU			;MAKE SURE SOCKET IS "IN USE"
	MOV	SDDDB#(SD),R4		;Make sure R4 points to the SRC DDB
	TBBE	$D1LCK,DDSTS1#(R4),3$	; Go on if connections allowed
	MOV	#.ERLKL,R0		; Indicate error reason
	JMP	CONNF1			; Now fail

3$:	TBBE	$D0LNK,(R4),1$		;Is this connect packet from a link?
	CMPB	DDPRIV#(R4),PKDATA+24(R1);Yes-is the priviledge level too high?
	BHIS	1$			;OK-continue
	MOVB	DDPRIV#(R4),PKDATA+24(R1);Too high-reduce it
1$:	MOV	#PKDATA+6,R2		;GET ADDRESS OF FIRST CHARACTER OF DST
	ADD	R1,R2			;  NAME
	CALL	XXRD50#			;CONVERT FIRST PART TO RADIX 50
	PUSH	R0			;SAVE FIRST PART
	CALL	XXRD50#			;CONVERT SECOND PART
	POP	R2			;RESTORE FIRST PART
	TSTB	PKDATA+4(R1)		;IS THE DST A HOST?
	BNE	CONN14			;NO-GO ON

;HERE IF CONNECTION REQUEST IS DIRECTED TO A HOST

	MOV	#HSTN$X#,R3		;GET INDEX FOR HOST TABLE
	BEQ	6$			;JUST TO BE VERY SAFE!!
2$:	CMP	HSTN$1#-2(R3),R2	;THIS ONE?
	BNE	4$			;NO
	CMP	HSTN$2#-2(R3),R0	;MAYBE
	BEQ	CONN13			;YES
4$:	DEC	R3			;NO-DECREMENT INDEX
	SOB	R3,2$			;CONTINUE IF MORE TO CHECK
6$:	TSTB	DFTHST#			;DO WE HAVE A DEFAULT HOST?
	BEQ	20$			;NO-FAIL NOW!
	TSTB	PKDATA+2(R1)		;YES-DO WE ALREADY HAVE A DST EXTENSION?
	BNE	20$			;YES-ANOTHER REASON TO FAIL
	MOVB	PKDATA+1(R1),R0		;NO-COPY DST TO DST EXTENSION
	ADD	#PKDATA+24,R0
	ADD	R1,R0
	MOV	#PKDATA+6,R2
	ADD	R1,R2
	MOV	#6,R3
10$:	MOVB	(R2),(R0)+
	BEQ	12$
	CLRB	(R2)+
	INCB	PKCNT(R1)
	INCB	PKDATA+2(R1)
	SOB	R3,10$
12$:	TSTB	PKDATA+2(R1)		;DO WE HAVE AN EXTENSION NOW?
	BEQ	20$			;NO-FAIL!
	MOV	#DFTHST#,R0		;YES-COPY DEFAULT TO DST
	MOV	#PKDATA+6,R2
	ADD	R1,R2
	MOV	#6,R3
14$:	MOVB	(R0)+,(R2)+
	BEQ	1$
	SOB	R3,14$
	BR	1$			;AND GO TRY THIS OVER AGAIN!

;HERE IF DO NOT KNOW ABOUT THE HOST HE WANTS

20$:	MOV	#.ERNSH,R0		;GET CONNECTION FAILURE CODE (NO SUCH
	BR	CONF5A			;  HOST)

;HERE WITH MATCH ON HOST NAME

CONN13:	ADD	#HSOF$X#,R3		;ADD IN HOST OFFSET FOR CONNECT TABLE
	BR	CONN17			;CONTINUE

;HERE IF CONNECTION REQUEST IS DIRECTED TO A DEVICE

CONN14:	MOV	R2,R3			;COPY FIRST HALF OF NODE NUMBER
	BIS	R0,R3			;ADD IN SECOND HALF
	BEQ	CONN18			;NULL - USE THIS NODE
	MOV	#NODN$X#,R3		;GET INDEX
	BEQ	CONN15			;JUST TO BE VERY SAFE!!
2$:	CMP	NODN$1#-2(R3),R2	;THIS NODE?
	BNE	4$			;NO
	CMP	NODN$2#-2(R3),R0	;MAYBE
	BEQ	CONN17			;YES
4$:	DEC	R3			;NO-DECREMENT INDEX
	SOB	R3,2$			;CONTINUE IF MORE TO CHECK
CONN15:	MOV	#.ERNSN,R0		;GET ERROR CODE (NO SUCH NODE)
	BR	CONF5A			;GO SEND NAK BACK

;HERE WITH MATCH ON DST NODE NAME

CONN17:	MOVB	PTHPR$#-2(R3),R0	;GET DEVICE INDEX FOR DST
	BGT	CONN22			;IF HOST OR REMOTE DEVICE
	BEQ	CONN15			;If routing table is messed up!

;	DEVICE IS SUPPOSED TO BE ON THIS NODE

CONN18:	MOVB	PKDATA+4(R1),R2		;GET DEVICE I.D.
	CMP	#NIDMAX#,R2		;VALID I.D.?
	BLE	2$			;NO!
	MOVB	NIDDX#(R2),R0		;YES-GET DEVICE INDEX
	BGE	CONN22			;CONTINUE IF WE HAVE THIS DEVICE
2$:	MOV	#.ERNSD,R0		;FAIL (NO SUCH DEVICE)
	BR	CONF5A

;HERE WITH DEVICE INDEX FOR DEVICE IN R0

CONN22:	MOV	DXTBL#(R0),R0		;GET ADDRESS OF DDB
CONN23:	MOVB	R3,77(R1)		;SAVE FOR RETRY
	TBBN	$D1DWN!$D1OFF!$D1DIS,DDSTS1#(R0),10$ ; Go on if link down
	TBBN	$D1UNV,DDSTS1#(R0),20$	; Go on if hardware unavailable
	TBBE	$D1LCK,DDSTS1#(R0),CONN24 ; Go on if connections allowed
	MOV	#.ERLKL,R0		; Indicate no connections now
	BR	CONF1A			; Go retry if we can

10$:	TBBE	$D1OFF,DDSTS1#(R0),20$	; Go on if down, not disabled
	MOV	#.ERLKO,R0		; Assume link disabled
	BR	CONF1A

20$:	TBBN	$D0HST,(R0),2$		;Is this a host?
	TBBN	$D0GTW,(R0),3$		;No-is this a gateway?
	MOV	#.ERLKD,R0		;No-error = Link down
	BR	CONF1A			;Go retry if we can

2$:	MOV	#.ERHSD,R0		;Error = Host down
	BR	CONF5A			;No retry allowed

3$:	MOV	#.ERGWD,R0		;Error = Gateway down
	BR	CONF5A			;Cannot retry this one

;HERE IF DEVICE IS UP

CONN24:	TBBN	$D0LNK,(R0),CONN30	;Is this a link?
	CMPB	DDPRIV#(R0),PKDATA+24(R1);No-check priviledge level
	BLOS	4$			;Go on if OK
	MOV	#.ERPRV,R0		;Not enough priviledge-fail!
	BR	CONF5A

;Here if the priviledge level in the connect packet is high enough

4$:	CLR	R2			;Get socket number
	BISB	PKDATA+5(R1),R2
	BEQ	CONN32			;If for wild socket
	CMPB	DDSOC#(R0),R2		;VALID SOCKET NUMBER?
	BLO	CONN25			;NO
	ASL	R2			;YES-CALCULATE SOCKET INDEX
	ADD	DDSX#(R0),R2		;PLUS BASE OF SX TABLE FOR DEVICE
	MOV	-(R2),R2		;GET ADDRESS OF SDB
	TBBN	$S1AVL,SDSTS1#(R2),CONN26;IF SOCKET IS AVAILABLE
CONN25:	MOV	#.ERNSS,R0		;FAIL (NO SUCH SOCKET)
	BR	CONF5A

;HERE IF SOCKET IS AVAILABLE

CONN26:	MOVB	SDSTS1#(R2),R3		;GET STATE OF DST
	BNE	CONN27			;FAIL IF NOT DISCONNECTED
	TBBE	$S1INU,SDSTS1#(R2),CONN40;CONTINUE IF DEVICE NOT "IN USE"
CONN27:	MOV	#.ERSIU,R0		;FAIL (REQUESTED SOCKET IN USE)
CONF5A:	JMP	CONNF5

;HERE IF CONNECTING TO DEVICE OR HOST ON ANOTHER NODE

CONN30:	MOVB	R3,77(R1)		;STORE PATH TABLE INDEX IN THE PACKET
	CMP	R0,R4			;Compare SRC and DST DDBs
	BEQ	CONF1A			;Try alternate path if going wrong way
					;Fall into wild socket routine

;HERE IF CONNECTING TO WILD SOCKET

CONN32:	TBBE	$D0WLD,(R0),CONN25	;Does this device like the wild socket
	PUSH	R4			;Yes-save registers we use
	PUSH	SD
	MOV	R0,R4			;Get address of DST DDB
	CALL	GRBSDB			;Get an SDB on the DST
	MOV	SD,R2			;We want R2 to point to the DST SDB
	POP	SD			;Restore SRC SDB
	POP	R4
	BCC	CONN40			;Go on if got an SDB
	TBBE	$D0LNK,(R0),CONN39	;None available-is this a link?
	MOV	#.ERLKF,R0		;Yes-get connect failure code (link
					;  full)
CONF1A:	JMP	CONNF1			;Go fail (allow retry)

;HERE IF NO SOCKETS ARE AVAILABLE ON A DEVICE OR HOST (NOT A LINK)

CONN39:	MOV	#.ERNSA,R0		;GET ERROR CODE
	JMP	CONNF5			;GO FAIL (NO RETRY)

;HERE WITH ADDRESS OF SDB FOR SOCKET TO CONNECT TO

CONN40:	BIS	#$S1INU,SDSTS1#(R2)	;MAKE SURE THE IN-USE BIT IS SET IN THE
					;  DST SDB
	PUSH	R4			;SAVE R4
	TBBN	$NSNOT,NODSTS#,2$	;GO ON IF NO TIME-OUT WANTED
	PUSH	R1			;SAVE PACKET ADDRESS
	PUSH	R2			;SAVE DST SDB ADDRESS
	PUSH	SD			;AND SRC SDB ADDRESS
	MOV	R2,SD			;POINT TO DST
	MOV	#JIFX20#,R0		;START HUNG CONNECT TIME-OUT
	MOV	#HNGCON,R1
	CALL	TIMREQ#
	POP	SD			;RESTORE SRC SDB ADDRESS
	POP	R2			;AND DST SDB ADDRESS
	POP	R1			;AND PACKET ADDRESS
	BCS	6$			;FAIL IF COULD NOT ENTER TIMER REQUEST
2$:	PUSH	R1			;SAVE CURRENT PACKET
	MAKPKT	.PLSTP#			;ALLOCATE ANOTHER PACKET
	MOV	R1,R4			;COPY ADDRESS OF NEW PACKET
	POP	R1			;RESTORE ADDRESS OF CONNECT PACKET
	BCC	CONN44			;GO ON IF GOT ONE
6$:	POP	R4			;RESTORE R4
	BIC	#^C<$S1AVL>,SDSTS1#(R2)	;FREE UP THE SOCKET WE JUST ALLOCATED
	MOV	#.ERBFF,R0		;GET CONECT FAILURE CODE (BUFFER SPACE
					;  FULL)
	BR	CONNF1			;GO FAIL

;HERE WITH EXTRA PACKET ALLOCATED FOR COPY OF CONNECT PACKET

CONN44:	MOV	#PKTWDS,R0		;PACKET SIZE
	MOV	R1,R3			;COPY ADDRSES OF PACKET FOR POINTER
	MOV	R4,SDPKDT#(R2)		;REMEMBER ADDRESS OF COPY
1$:	MOV	(R3)+,(R4)+		;COPY CONNECT PACKET
	SOB	R0,1$
	POP	R4			;RESTORE R4
	MOV	R2,(SD)			;LINK DST DEVICE TO THE SRC DEVICE
	MOV	SD,(R2)			;AND THE OTHER WAY TOO
	CLRB	SDPCNT#(R2)		;Clear the packet counts
	MOVB	#.SSCTP,SDSTS1#(R2)	;SET NEW STATE FOR DST
	MOVB	#.SSCFP,SDSTS1#(SD)	;SET NEW STATE FOR SRC
	BIC	#$S1HLD!$S1STP!$S1BC2,SDSTS1#(R2);AND CLEAR SOME BITS
	BIC	#$S1HLD!$S1STP!$S1BC2,SDSTS1#(SD)
	MOV	SDDDB#(R2),R0		;GET DST DDB ADDRESS
	INC	DDNCON#(R0)		;BUMP ITS COUNT OF CONNECTIONS
	TBBN	$D0TAX,(R0),10$		;Can an "aux" connection go this way?
	BICB	#020,PKDATA+35(R1)	;No!
10$:	MOV	SDDDB#(SD),R0		;DO THE SAME FOR THE SRC
	INC	DDNCON#(R0)
	TBBN	$D0FAX,(R0),11$		;Check for this side too
	BICB	#020,PKDATA+35(R1)
11$:	MOVB	PKDATA+31(R1),R3	;GET MAXIMUM PACKET COUNT
	CMP	#12,R3			;IS IT TOO BIG?
	BHI	12$			;NO
	MOV	#12,R3			;YES-REDUCE IT
12$:	CMP	#3,R3			;IS IT TOO SMALL?
	BLO	14$			;NO
	MOV	#3,R3			;YES-INCREASE IT
14$:	MOVB	R3,SDPMAX#(SD)		;STORE VALUE
	MOVB	R3,SDPMAX#(R2)
	MOVB	PKDATA+26(R1),R3	;GET LINK PRIORITY
	CMP	#2,R3			;VALID?
	BHIS	16$			;YES
	MOV	#2,R3			;NO-MAKE IT AS LOW AS WE CAN!
16$:	TBBE	$D0LVL,@SDDDB#(SD),20$	;DOES THIS DEVICE USE THE LEVEL?
	MOVB	R3,SDLKLV#(SD)		;YES-STORE LEVEL
	CLRB	SDACNT#(SD)		;CLEAR THE FLOW-CONTROL BYTES
	CLRB	SDFCNT#(SD)
20$:	TBBE	$D0LVL,@SDDDB#(R2),22$	;DOES THIS DEVICE USE THE LEVEL?
	MOVB	R3,SDLKLV#(R2)		;YES-STORE LEVEL
	CLRB	SDACNT#(R2)		;CLEAR THE FLOW-CONTROL BYTES
	CLRB	SDFCNT#(R2)
22$:	BIS	#$S1BC2,SDSTS1#(R2)	;INDICATE DIRECTION OF CONNECTION
	MOVB	PKDATA+4(R1),SDSDID#(SD);REMEMBER KINDS OF DEVICES
	MOVB	PKDATA+14(R1),SDSDID#(R2)
	MOV	R1,SDPKDH#(R2)		;SET DST HEAD POINTER
	JMP	SNDDA3			;AND GO SEND THE CONNECT PACKET

;HERE IF CANNOT MAKE CONNECTION FOR SOME REASON
;	C(R0) = CONNECTION FAILURE CODE

CONNF1:	MOVB	77(R1),R3		;YES-GET PATH TABLE INDEX
	BEQ	CONNF5			;REALLY FAIL IF HAVE ALREADY DONE
					;  RETRY!
	MOVB	PTHSC$-2(R3),R3		;YES-GET DEVICE INDEX FOR LINK FOR
					;  SECONDARY PATH
	BLE	CONNF5			;IF NO SECONDARY PATH DEFINED
	MOV	DXTBL#(R3),R0		;GET ADDRESS OF DDB
	CLR	R3			;ONLY RETRY ONCE!
	JMP	CONN23			;GO TRY THAT PATH!

;HERE IF CANNOT RETRY FOR ONE REASON OR ANOTHER

CONNF5:	PUSH	R0
	CALL	DECOWN			;FIX UP THE PACKET COUNTS
	POP	R0
	TBBE	$D0CLN,@SDDDB#(SD),2$	;Want clean-up for this device?
	BIC	#^C<$S1AVL>,SDSTS1#(SD)	;Yes-do that
2$:	ADD	#2,(SP)			;Give skip return
	CJMP	SETNAK			;Setup a NAK packet and return
	.PAGE
;HERE ON CONNECTION REQUEST COLLESION - GET HERE IF BOTH ENDS OF A LINK
;  ALLOCATE A SOCKET AT THE SAME TIME - IN THIS CASE, THE PRIMARY IGNORES
;  THE CONNECTION REQUEST, THE SECONDARY RETRIES THE PENDING CONNECTION, WHICH
;  WILL RESULT IN A DIFFERENT SOCKET BEING ALLOCATED IF IT IS A WILD REQUEST
;  OR IN A HARD FAILURE IF IT IS NOT A WILD REQUEST.  IT THEN PROCESSES THE
;  NEW REQUEST NORMALLY

CONCOL::MOV	SDDDB#(SD),R4		;GET DDB ADDRESS
	TBBE	$D0PRI,(R4),4$		;ARE WE PRIMARY?
2$:	JMP	JNKOWN			;YES-IGNORE THIS!

;HERE IF THIS NODE IS SECONDARY

4$:	PUSH	R1			;SAVE NEW CONNECT PACKET
	MAKPKT	.PLSTP#			;Get another packet
	BCC	6$			;Go on if got one
	POP	R1			;None available-restore Connect packet
	BR	2$			;  and go junk it and let both sides
					;  time out (this is about the best we
					;  can do if we can't get a packet!)

;Here with another packet

6$:	MOV	#.ERNSA,R0		;MAKE INTO NAK PACKET, REASON = NO
	CALL	SETNAK			;  SOCKETS AVAILABLE
	CALL	SNDPKT			;SEND IT
	POP	R1			;RESTORE CONNECT PACKET
	JMP	SNDPKT			;AND GO PROCESS THE NEW CONNECTION
					;  REQUEST
	.PAGE
	.SBTTL	CONNECT ACK PACKET

;HERE FOR CONNECT ACK WHEN A CONNECTION IS PENDING FROM THE DEVICE
;  (STATE = .SSCPF)

;FORMAT OF THE CONNECT ACK PACKET
;  PKDATA+ 0/	NUMBER OF SOCKET ALLOCATED
;  PKDATA+ 1/	FLAG BITS (OPTIONAL)
;		200 = REPORT TERMINAL PARAMETERS
;		100 = ENABLE DEFERED ECHO MODE
;		040 = LOGIN STRING REQUIRED
;		020 = NOT USED
;		010 = DON'T ENABLE ECHOING
;		004 = DON'T HOLD INPUT IF OUTPUT IS ACTIVE
;		002 = LOCAL COPY TERMINAL
;		001 = DON'T CLEAR LOGIN MODE
;  PKDATA+ 2/	TERMINAL PROFILE PLUS 1 (OPTIONAL, 0 OR MISSING IF SHOULD NOT
;		  SET PROFILE)

SNDACK:	CALL	CLRCTP			;CLEAR CONNECT TIMER AND GIVE UP
					;  SAVED CONNECT PACKET
	MOV	(SD),R2			;GET POINTER TO LINKED SDB
	MOVB	#.SSCON,SDSTS1#(SD)	;SET NEW STATE FOR SRC
	MOVB	#.SSCON,SDSTS1#(R2)	;AND FOR DST
	CJMP	SNDDA0			;SEND THE PACKET ON AND RETURN
	.PAGE
	.SBTTL	CONNECTION NAK PACKET

;HERE FOR CONNECTION NAK PACKET WHEN CONNECTION IS PENDING TO THE DEVICE
;  (STATE = .SSCTP)

SNDNAK:	CALL	RTYNAK			;Retry this connection if we can
	  RETURN			;Retry worked-all finished here
	CLRB	SDSTS1#(R2)		;Retry failed-clear state of DST socket
	MOV	SDDDB#(R2),R0		;Get DST DDB
	DEC	DDNCON#(R0)		;Reduce connection
	BGE	6$
	CLR	DDNCON#(R0)
6$:	TBBE	$D0CLN,(R0),10$		;Does DST socket need clean-up?
	BIC	#^C<$S1AVL>,SDSTS1#(R2)	;Yes
10$:	TST	PKFCNT			;Are there any packet available now?
	BEQ	SNDKLX			;No-this is somewhat of a problem here!
	CJMP	SNDDA0			;Yes-send the packet and return

;Here if there are no free packets now

SNDKLX:	MOVB	#.SSZTR,SDSTS1#(R2)	;No-indicate Kill was zapped
	MOVB	PKDATA(R1),SDPKDH#(R1)	;Remember the reason
	CLRB	SDXCNT#(R2)
	FREPKT				;Give up the packet
	RETURN				;And return


;Subroutine to do connect retry for a Connect ACK packet (also called from PKT3)
;	CALL	RTYNAK
;	  return if retry done
;	return if no retry possible
;	C(R1) = address of Connect NAK packet
;	C(R2) = address of DST SDB

RTYNAK::CALL	DECOWN			;Keep packet count right
4$:	MOVB	#.PTNAK,PKTYPE(R1)	;MAKE SURE THIS IS REALLY A NAK PACKET
	PUSH	R1			;SAVE ADDRESS OF PACKET
	PUSHB	PKDATA(R1)		;And save error reason
	MOV	#HNGCON,R1		;KILL CONNECT TIMER
	CALL	TIMKIL#
	MOV	SDPKDH#(SD),R1		;Is there a packet on the DST list?
	BEQ	10$			;No-go on
	CLR	SDPKDH#(SD)		;Yes-get rid of it (must be the
	FREPKT				;  connect packet - this can happen
					;  if we got here because of a kill)
10$:	MOV	(SD),R2			;GET LINKED SDB
	BNE	20$			;FOR DEBUGGING
	RSTOP	NSL			;[NO SOCKET LINKED]

20$:	CLR	(SD)			;UNLINK THE SDB'S
	CLR	(R2)
	MOV	SDPKDT#(SD),R1		;GET SAVED CONNECT PACKET
	BNE	30$			;MAKE SURE WE HAVE ONE!
	RSTOP	CNS			;[CONNECT PACKET NOT SAVED]

30$:	TBBN	$D1DWN,DDSTS1#(R4),40$	;Don't bother to retry if down now
	MOVB	77(R1),R3		;GET INDEX FOR PATH
	BEQ	40$			;IF ALREADY HAVE RETRIED
	MOVB	PTHSC$#-2(R3),R0	;GET DX FOR SECONDARY PATH
	BLE	40$			;IF NO SECONDARY PATH DEFINED
	CMPB	#.ERTRY,(SP)		;CAN WE RETRY THIS ERROR?
	BLT	40$			;NO
	TST	(SP)+			;YES-FIX UP THE STACK
	POP	R1			;RESTORE ADDRESS OF NAK PACKET
	FREPKT				;GIVE IT UP
	MOV	SDPKDT#(SD),R1		;GET ADDRESS OF CONNECT PACKET
	CLR	SDPKDT#(SD)		;CLEAR POINTER
	PUSH	SD			;SAVE OUR SDB ADDRESS
	MOV	R2,SD			;TURN THINGS AROUND!
	CLR	R3			;CLEAR PATH INDEX
	CALL	CONN22			;PROCESS LIKE LAST PART OF CONNECT
	POP	SD			;RESTORE SRC SDB
	BR	50$			;Continue

;Here if cannot retry

40$:	FREPKT				;GIVE UP THE SAVED CONNECT PACKET
	CLR	SDPKDT#(SD)		;MAKE SURE POINTER IS CLEAR
	TST	(SP)+			;FIX UP THE STACK
	POP	R1			;RESTORE ADDRESS OF NAK PACKET
	ADD	#2,(SP)			;Give skip return
50$:	MOV	SDDDB(SD),R4		;Get address of SRC DDB
	DEC	DDNCON#(R4)		;Reduce the connection count
	BGE	52$
	CLR	DDNCON#(R4)
52$:	BIC	#^C<$S1AVL>,SDSTS1#(SD)	;GIVE UP THE SRC SOCKET
RTN006:	RETURN
	.PAGE
	.SBTTL	CONNECT TIME-OUT

;Here when have not received ACK or NAK within 2 minutes of sending a connect
;  packet - we generate a fake connect NAK packet and process it just as if
;  it had been received, then we put the socket which timed-out in the .SSZTR
;  state.  This will cause a Kill packet to be sent within a minute if nothing
;  is received.  We could have sent a kill directly from here, but that would
;  make the routine longer and this is really just about as good!  This routine
;  should really never be executed anyway!!

HNGCON:	CALL	CLRSDV			;Clear out the DST list
	MAKPKT	.PLOPT#			;Get a packet
	BCS	4$			;If can't get one now
	MOVB	#1,SDPCNT#(SD)		;Make sure packet count is right!
	MOV	#.ERTIM,R0		;Error = time-out
	CALL	SETNAK			;Set up the packet
	CALL	SNDPKT			;Process just like a real NAK
	MOVB	#.SSZTR,SDSTS1#(SD)	;Set new socket state
	MOV	#.ERTIM,SDPKDH#(SD)	;Store error code
	MOV	SDDDB#(SD),R4		;Get DDB address
	INC	DDNCON#(R4)		;Fix up the connect count
	RETURN				;Thats all

;Here if cannot get a packet now for the NAK

4$:	MOV	#JIFSEC#,R0		;Try again in 1 second
	MOV	#HNGCON,R1
	CJMP	TIMREQ#			;Should not fail since we got here
					;  because of a time-out so there must
					;  be a timer slot free!!!
	.PAGE
	.SBTTL	KILL CONNECTION PACKET

;FORMAT OF THE KILL CONNECTION PACKET
;  PKDATA+ 0/	DISCONNECT REASON CODE

;Here for Kill or Disconnect packet when state = .SSDFP

SNDKIQ:	CALL	CLRDFP			;Clear the disconnect pending state
	BR	SNDKIL			;Continue

;Here for Kill packet when state = .SSCFP

SNDKIW:	CALL	CLRCFP			;CLEAN UP THE PENDING CONNECTION

;HERE FOR KILL CONNECTION PACKET WHEN DEVICE IS CONNECTED (STATE = .SSCON)

SNDKIL::MOVB	#.PTKIL,PKTYPE(R1)	;Make sure this is a Kill packet
	CMP	R1,SDPKCP#(SD)		;IS THE PACKET WE ARE GOING TO CHANGE TO
	BNE	1$			; A KILL THE CURRENT PACKET?
	CLR	SDPKCP#(SD)		;YES - KEEP CLRSDV FROM RETURNING IT
1$:	CALL	CLRDDV			;Clear DST list for DST
	CALL	CLRSDV			;Clear DST list for SRC
	MOV	(SD),R2			;Get DST SDB
	CLR	(SD)			;Unlink
	CLR	(R2)
	CLRB	SDPCNT#(SD)		;Clear some packet counts
	CLRB	SDPCNT#(R2)
	TST	PKFCNT			;Any free packets left?
	BNE	6$			;Yes-go on
	CALL	SNDKLX			;No-zap it!
	BR	SNDKL5			;Continue

6$:	MOVB	#.SSKT1,SDSTS1#(R2)	;Update DST state
	MOVB	#1,SDXCNT#(R2)		;Set count
	CALL	SNDDA0			;Send the Kill packet
SNDKL5::MAKPKT	.PLSTP#			;Get another packet
	BCC	20$			;Go on if got one
	MOVB	#.SSZFR,SDSTS1#(SD)	;Indicate the Disconnect ACK was zapped
	CLRB	SDXCNT#(SD)
	RETURN				;Thats all

20$:	CLRB	SDSTS1#(SD)		;Clear SRC state
	MOVB	#1,SDXCNT#(SD)
	MOV	#.PTDAK*400,PKCNT(R1)	;Make into Disconnect ACK packet
	CALL	SNDSRC			;Send DAK to SRC
	TBBE	$D0CLN,@SDDDB#(SD),22$	;Should we do clean-up here?
	BIC	#^C<$S1AVL>,SDSTS1#(SD)	;Yes
22$:	RETURN				;Finished
	.PAGE
	.SBTTL	Disconnect packet

;FORMAT OF THE DISCONNECT PACKET
;  PKDATA+ 0/	Disconnect reason code (+200 if want special disconnect)

;Here for Disconnect packet when device is connected (STATE = .SSCON)

SNDDIS:	TST	PKFCNT			;Do we have any packets?
	BEQ	SNDKIL			;No-change this into kill!
	TSTB	PKDATA(R1)		;Does he want a time-out?
	BPL	4$			;No-go on
	BICB	#200,PKDATA(R1)		;Yes-clear the flag
	PUSH	R1
	MOV	#JIF150#,R0		;Timeout = 2.5 min.
	MOV	#DISTMO,R1
	CALL	TIMREQ#			;Request disconnect timeout
	POP	R1
	BCS	SNDKIL			;Change this into a Kill if cannot do
					;  the timeout!
4$:	CMP	R1,SDPKCP#(SD)		;IS THE PACKET WE ARE GOING TO SEND
	BNE	1$			;  THE CURRENT PACKET?
	CLR	SDPKCP#(SD)		;YES - KEEP CLRSDV FROM RETURNING IT
1$:	CALL	CLRSDV			;Clear out DST list for SRC
	MOV	(SD),R2			;Get DSB SDB
	MOVB	#.SSDFP,SDSTS1#(SD)	;Update the socket states
	MOVB	#.SSDTP,SDSTS1#(R2)	;Update DST SDB state
	CBR	SNDDA0			;Send the packet and return

;Here when the Disconnect timer runs out

DISTMO:	MAKPKT	.PLOPT#			;Get a packet
	BCS	4$			;If none available now
	MOV	#.ERTIM,R0		;Reason = timeout
	CALL	SETKIL			;Setup the Kill packet
	CJMP	SNDPKT			;Send it and return

;Here if cannot get a packet

4$:	MOV	#JIFSEC#,R0		;Try again in 1 second
	MOV	#DISTMO,R1
	CJMP	TIMREQ#
	.PAGE
	.SBTTL	DISCONNECT ACK PACKET

;HERE FOR DISCONNECT ACK PACKET

SNDDAK:	MOV	(SD),R2			;Get linked SDB
	BNE	SNDDK4			;Go on if linked
	FREPKT				;Not linked-give up the packet
SNDDK2:	CLRB	SDSTS1#(SD)		;Update socket state
	CLRB	SDPCNT#(SD)		;Clear the packet counts
	CLRB	SDXCNT#(SD)
	MOV	SDDDB#(SD),R0		;Get address of DDB
	DEC	DDNCON#(R0)		;Reduce connection count
	BGE	2$
	CLR	DDNCON#(R0)
2$:	TBBE	$D0CLN,(R0),4$		;Does this device need clean-up here?
	BIC	#^C<$S1AVL>,SDSTS1#(SD)	;Yes-give up the sockeet
4$:	RETURN

;Here if linked to another SDB now

SNDDK4:	CLR	(SD)			;Unlink
	CLR	(R2)
	PUSH	SD			;Clean up DST socket
	MOV	R2,SD
	PUSH	R1			;Save packet address
	MOV	#DISTMO,R1		;Kill possible disconnect timer
	CALL	TIMKIL#
	POP	R1			;Restore R1
	MOV	SD,R2			;And restore R2
	CALL	SNDDK2
	POP	SD
	CALL	SNDDK2			;Clean up SRC socket
	MOV	#.PTDAK*400,PKCNT(R1)	;Make sure this is a Disconnect Ack
					;  packet
	MOVB	#1,SDXCNT#(R2)		;Fix up the packet count
	CBR	SNDDA0			;Send the packet and return
	.PAGE
	.SBTTL	EAT PACKET

;HERE FOR EAT PACKET PACKET - THIS PACKET DELETES ALL BUFFERED PACKETS FOR THIS
;  SOCKET OF THIS DEVICE

SNDEAT::CALL	CLRDDV			;CLEAR THE DST LIST
	BR	SNDDAT			;AND GO SEND IT!
	.PAGE
	.SBTTL	INTERRUPT FUNCTION PACKET

;HERE FOR INTERRUPT FUNCTION PACKET

SNDINT::MOV	(SD),R2			;GET SDB OF DST
	MOV	#SDPKDH#,R3		;MAKE FAKE PREDICESSOR POINTER
	ADD	R2,R3
	MOV	(R3),R0			;GET FIRST PACKET ON THE LIST
	BEQ	SNDDAT			;GO ON IF NONE THERE
	TSTB	PKPNT(R0)		;HAVE ONE-IS IT BEING PROCESSED NOW?
	BEQ	4$			;NO
	TSTB	PKTYPE(R0)		;YES-IS IT A DATA PACKET
	BEQ	6$			;YES
2$:	MOV	R0,R3			;ADVANCE POINTER
	MOV	(R3),R0			;GET NEXT PACKET
	BEQ	SNDDAT			;IF NO MORE
4$:	CMPB	#.PTINT,PKTYPE(R0)	;IS NEXT PACKET AN INTERRUPT PACKET?
	BEQ	2$			;YES
6$:	CLRB	PKPNT(R1)		;NO-CLEAR CHARACTER POINTER
	MOV	R1,(R3)			;INSERT THIS PACKET INTO THE LIST
	MOV	R0,(R1)
	BNE	10$			;FINISHED IF NOT AT END
	MOV	R1,SDPKDT#(R2)		;END-UPDATE TAIL POINTER TOO
10$:	CMP	R1,SDPKDH#(R2)		;IS THIS PACKET AT THE HEAD NOW?
	BEQ	REQXR1			;YES-GO POKE THE DST
RTN007:	RETURN				;NO-THATS ALL
	.PAGE
	.SBTTL	DATA PACKET

;HERE FOR DATA PACKET

SNDDTP::MOV	(SD),R2			;GET LINKED SDB
	TBBE	$S1JNK,SDSTS1#(R2),SNDDA0;GO ON IF NOT JUNKING PACKETS
	BR	JNKOWN			;JUNK THIS PACKET!
	.PAGE
	.SBTTL	PACKET TRANSFER ROUTINES

;HERE TO SEND PACKET BACK TO THE SRC
;	C(R1) = ADDRESS OF PACKET
;	C(SD) = ADDRESS OF SDB FOR SRC
;	CALL	SNDSRC

SNDSRC::MOV	SD,R2			;GET SDB ADDRESS IN RIGHT AC
	BR	SNDDA0			;CONTINUE

;HERE FOR PACKETS WHICH DO NOT REQUIRE SPECIAL PROCESSING AT THIS POINT
;  PACKET IS SENT TO DST
;	C(R1) = ADDRESS OF PACKET
;	C(SD) = ADDRESS OF SDB FOR SRC
;	CALL	SNDDAT

SNDDAT::MOV	(SD),R2			;GET SDB OF DST SOCKET
SNDDA0::MOV	SDPKDT#(R2),R3		;GET POINTER TO LAST PACKET FOR DST
	BNE	SNDDA4			;GO ON IF LIST NOT EMPTY
	MOV	R1,SDPKDT#(R2)		;LIST WAS EMPTY-PUT THIS PACKET ON THE
	MOV	R1,SDPKDH#(R2)		;  LIST
SNDDA3::CLR	(R1)			;MAKE SURE LINK-WORD IS CLEAR
	CLRB	PKPNT(R1)		;AND CLEAR CHARACTER POINTER
	TST	SDPKCP#(R2)		;Is there a "current" packet?
	BNE	RTN009			;Yes-don't bother poking him!
REQXR1::BISB	#$RQPOK,SDREQB#(R2)	;SET THE REQUST BIT
REQXR2::CMP	#-1,SDREQL#(R2)		;ALREADY IN REQUEST LIST?
	BNE	10$			;YES-FINISHED NOW
	MOV	REQSTT#,R0		;NO-GET LAST SDB IN LIST
	BEQ	4$			;IF LIST IS EMPTY
	MOV	R2,SDREQL#(R0)		;NOT EMPTY-LINK TO END OF LIST
	BR	6$			;CONTINUE

4$:	MOV	R2,REQSTH#		;EMTPY-SET HEAD POINTER
6$:	MOV	R2,REQSTT#		;IN ANY CASE, UPDATE TAIL POINTER
	CLR	SDREQL#(R2)		;CLEAR THE LINK WORD
10$:	RETURN				;THATS ALL

;HERE IF ALREADY HAVE SOME PACKETS IN LIST FOR DESTINATION

SNDDA4:	CLR	(R1)			;MAKE SURE LINK-WORD IS CLEAR
	CLRB	PKPNT(R1)		;;AND CLEAR CHARACTER POINTER
	TSTB	PKTYPE(R1)		;IS THIS A DATA PACKET?
	BNE	SNDDA5			;NO-GO ON
	TSTB	PKTYPE(R3)		;YES-IS LAST PACKET IN LIST A DATA
					;  PACKET?
	BNE	SNDDA5			;NO
	MOVB	PKPNT(R3),R0		;GET OFFSET OF START OF DATA IN PACKET
	DEC	R0
	BGE	2$
	CLR	R0
2$:	ADD	PKCNT(R3),R0
	NEG	R0
	ADD	#PKCMAX,R0		;NOW C(R0) = AMOUNT LEFT
	CMPB	PKCNT(R1),R0		;CAN WE MERGE THESE PACKETS?
	BHI	SNDDA5			;NO
	MOVB	PKCNT(R1),R0		;YES-CALCULATE NEW BYTE COUNT
	CLR	-(SP)
	MOVB	PKCNT(R3),(SP)
	ADD	R0,PKCNT(R3)
	MOVB	PKPNT(R3),R2		;MAKE DST POINTER
	DEC	R2
	BGE	3$
	CLR	R2
3$:	ADD	(SP)+,R2
	ADD	#PKDATA,R2
	ADD	R2,R3
	MOV	R1,R2			;MAKE SRC POINTER
	ADD	#PKDATA,R2
4$:	MOVB	(R2)+,(R3)+		;COPY A CHARACTER
	SOB	R0,4$			;LOOP UNTIL DONE
JNKOWN::FREPKT				;GIVE UP THE PACKET
	CJMP	DECOWN			;FIX UP THE PACKET COUNTS AND RETURN

;HERE IF CANNOT MERGE PACKETS

SNDDA5:	MOV	(R3),(R1)		;NOTE: THIS IS NEEDED TO HANDLE A 
					;  "BLOCKED" DST LIST - THIS LIST HAS
					;  BEEN LINKED INTO A RING WITH THE
					;  LAST PACKET POINTING TO THE FIRST.
					;  THIS WILL DO NO HARM FOR A NORMAL
					;  DST LIST SINCE R3 POINTS TO THE
					;  CURRENT TAIL WHOSE LINK-WORD WILL
					;  BE 0, WHICH IS THE RIGHT VALUE FOR
					;  THE LINK-WORD FOR THE NEW TAIL!
	MOV	R1,(R3)			;LINK THIS PACKET TO END OF LIST
	MOV	R1,SDPKDT#(R2)		;UPDATE TAIL POINTER
RTN009:	RETURN				;RETURN
	.PAGE
	.SBTTL	Once-a-minute routine

;This routine is executed once each minute to check for zapped sockets and for
;  sockets which have been in a Kill to socket pending state for more than a
;  minute.

	ONCSEC	SECPKT

SECPKT:	DEC	MINCNT			;Time for this yet?
	BGT	RTN013			;No
	MOV	#60.,MINCNT		;Yes-reset count
	MOV	#SXTBL#,R2		;Point to start of SX table
SECPK2:	MOV	(R2)+,SD		;Get next SDB
	BEQ	SECNXT
	MOVB	SDSTS1#(SD),R0		;Get socket state
	ADD	R0,PC			;Dispatch on the state
	BR	SECNXT		;.SSDIS =  0 - Disconnected
	BR	SECNXT		;.SSCTP =  2 - Connect to socket pending
	BR	SECNXT		;.SSCFP =  4 - Connect from socket pending
	BR	SECNXT		;.SSCON =  6 - Connected
	BR	SECNXT		;.SSDTP = 10 - Disconnect to socket pending
	BR	SECNXT		;.SSDFP = 12 - Disconnect from socket pending
	BR	SECKT1		;.SSKT1 = 14 - Kill to socket pending - 1
	BR	SECKT2		;.SSKT2 = 16 - Kill to socket pending - 2
	BR	SECZTR		;.SSZTR = 20 - Zap to socket requested
	BR	SECZFR		;.STZFR = 22 - Zap from socket requested
	BR	SECNXT		;.SSRTP = 24 - Reconnect to socket pending
	BR	SECNXT		;.SSRFP = 26 - Reconnect from socket pending
	BR	SECNXT		;.SSRTW = 30 - Reconnect to socket waiting
	BR	SECNXT		;.SSRFW = 32 - Reconnect from socket waiting
	BR	SECNXT		;.SSRIP = 34 - Reconnect in progress

;Here when state = .SSKT1 = 14  (Kill to socket pending - state 1)

SECKT1:	MOVB	#.SSKT2,SDSTS1#(SD)	;Advance the state
	BR	SECNXT			;Thats all!

;Here when state = .SSKT2 = 16  (Kill to socket pending - state 2)

SECKT2:	CALL	SNDDK2			;Clear output the socket just as if we
	CALL	FRESOC			;  had received a disconnect ack!
	BR	SECNXT			;Continue

;Here for state = .SSZTR = 20  (Zap to socket requested)

SECZTR:	MAKPKT	.PLOPT#			;Get a packet
	BCS	RTN013			;Opps!
	MOVB	SDPKDH#(SD),R0		;Get reason
	CALL	SETKIL			;Setup a Kill packet
	BR	SECPK4			;Continue

;Here for state = .SSZFR = 22  (Zap from socket requested)

SECZFR:	MAKPKT	.PLOPT#			;Get a packet
	BCS	RTN013			;Oh well!
	MOV	#.PTDAK*400,PKCNT(R1)	;Make into Disconnect ACK packet
SECPK4:	CLRB	SDSTS1#(SD)		;Clear socket state
	PUSH	R2			;Save table pointer
	CALL	SNDSRC			;Send the packet
	POP	R2			;Restore pointer
	CMP	PKFCNT,#6		;Do we have enough free packets to go
					;  on with this?
	BLO	RTN013			;No-forget it for now!

;Here to step to next SDB

SECNXT:	CMP	R2,#SXTOP#		;Finished?
	BLO	SECPK2			;No-continue
RTN013:	RETURN				;Yes
	.PAGE
	.SBTTL	SETINU - SUBROUTINE TO MARK DEVICE AS IN USE

;	C(SD) = ADDRESS OF SDB
;	CALL	SETINU

SETINU::BIS	#$S1INU,SDSTS1#(SD)	;INDICATE IN USE
	RETURN				;THATS ALL!!

	.SBTTL	Subroutine to finish processing Disconnect packet

;	C(R1) = address of Disconnect packet
;	CALL	FINDIS

FINDIS::MOV	#.PTDAK*400,PKCNT(R1)	;Change it to a Disconnect ACK packet
	CALL	PKTRTX			;Send it back to the SRC
					;Fall into FRESOC

	.SBTTL	FRESOC - Free up a socket

;Subroutine to free up a socket
;	C(SD) = Address of SDB for socket
;	CALL	FRESOC

FRESOC::BIC	#^C<$S1AVL>,SDSTS1#(SD)	;Clear socket status + state
	RETURN				;Thats all!!
	.PAGE
	.SBTTL	GRBSDB - Grab a free SDB

;Subroutine to grab a free SDB for use
;	C(R4) = Address of DDB
;	CALL	GRBSDB
;	C:set = None available
;	C:clr = Normal return
;	C(SD) = Address of SDB
;  SDB is marked as "in use"
;  All other registers are preserved

GRBSDB::PUSH	R0			;FREE UP A REGISTER OR 2
	PUSH	R3
	CLR	R0			;GET NUMBER OF SOCKETS ON DEVICE
	BISB	DDSOC#(R4),R0
	MOV	DDSX#(R4),R3		;GET START OF SX TABLE FOR DEVICE
	TBBE	$D0PRI,(R4),4$		;IF WE ARE SECONDARY ON THIS LINK
2$:	MOV	(R3)+,SD		;GET NEXT SDB
	TBBN	$S1INU,SDSTS1#(SD),3$	;IS IT AVAILABLE?
	TBBN	$S1AVL,SDSTS1#(SD),12$	;MAYBE
3$:	SOB	R0,2$			;NO-MORE TO CHECK?
	BR	10$			;NO-FAIL

;HERE IF THIS NODE IS SECONDARY ON THIS LINK

4$:	ASL	R0			;FIND END OF SX TABLE FOR DEVICE
	ADD	R0,R3
	ASR	R0			;RESTORE COUNT
6$:	MOV	-(R3),SD		;GET NEXT SDB
	TBBN	$S1INU,SDSTS1#(SD),7$	;IS IT AVAILABLE?
	TBBN	$S1AVL,SDSTS1#(SD),12$	;MAYBE
7$:	SOB	R0,6$			;NO-MORE TO CHECK?
10$:	POP	R3			;RESTORE REGISTERS
	POP	R0
	SEC				;NO-INDICATE FAILURE
	RETURN				;AND RETURN

12$:	POP	R3			;RESTORE REGISTERS
	POP	R0
	CLC				;INDICATE GOOD RETURN
	BR	SETINU			;GO MARK SDB IN USE AND RETURN
	.PAGE
	.SBTTL	LOCAL SUBROUTINES

;SUBROUTINE TO CLEAR DST LIST FOR DST SOCKET
;	C(SD) = ADDRESS OF SDB FOR SRC SOCKET
;	CALL	CLRDDV

CLRDDV::PUSH	SD			;SAVE SRC SDB ADDRESS
	MOV	(SD),SD			;GET DST SDB
	BEQ	2$			;FORGET IT IF NONE!
	CALL	CLRSDV			;CLEAR THE LIST
2$:	POP	SD			;RESTORE SRC SDB
	RETURN				;THATS ALL

;SUBROUTINE TO CLEAR DST LIST FOR SRC DEVICE
;	C(SD) = ADDRESS OF SDB FOR SOCKET
;	CALL	CLRSDV

CLRSDV::PUSH	R1			;Save R1
2$:	MOV	SDPKDH#(SD),R1		;Get head pointer
	BEQ	4$			;If nothing buffered
	CALL	JNKPKT			;Get rid of the packet!
	BR	2$			;Continue

;Here after DST list is empty

4$:	TBBE	$D0TRM,@SDDDB#(SD),6$	;Go on if not terminal
	CALL	TRMSTP#			;Terminal-stop output now!
6$:	MOV	SDPKCP#(SD),R1		;Get current output packet
	BEQ	10$			;If none
	CALL	JNKCPK			;Give it up
10$:	POP	R1			;Restore R1
	RETURN				;And return
	.PAGE
;SUBROUTIE TO GIVE UP SAVED CONNECT PACKET AND CLEAR CONNECT TIMER FOR
;  SOCKET IN .SSCTP STATE
;	CALL	CLRCTP

CLRCTP::PUSH	R1			;RESPECT R1
	MOV	#HNGCON,R1		;CLEAR CONNECT TIMER
	CALL	TIMKIL#
	MOV	SDPKDT#(SD),R1		;GET SAVED CONNECT PACKET
	BNE	4$			;MUST HAVE ONE HERE!
	RSTOP	CNS			;[CONNECT PACKET NOT SAVED]

4$:	FREPKT				;GIVE UP THE PACKET
	CLR	R1			;Assume no DST list (usual case)
	MOV	SDPKDH#(SD),R2		;Get first packet on DST list
	BEQ	10$			;If none
6$:	MOV	R2,R1			;Advance pointer
	MOV	(R1),R2			;Get next packet
	BNE	6$			;Go on if more
10$:	MOV	R1,SDPKDT#(SD)		;Have last one-update tail pointer
RTNPR1:	POP	R1			;RESTORE R1
	RETURN				;AND RETURN

;SUBROUTINE TO GIVE UP SAVED CONNECT PACKET AND CLEAR CONNECT TIMER FOR
;  SOCKET IN .SSCFP STATE
;	CALL	CLRCFP

CLRCFP::PUSH	SD			;SAVE SDB ADDRESS
	MOV	(SD),SD			;POINT TO DST SDB
	BNE	2$			;BE SAFE!
	RSTOP	NSL			;[NO SOCKET LINKED]

2$:	CALL	CLRCTP			;DO THE WORK
	POP	SD			;RESTORE SD
	RETURN				;And return

;Subroutine to kill disconnect timer when state = .SSDFP

CLRDFP:	PUSH	R1			;Respect R1
	MOV	#DISTMO,R1		;Kill disconnect timer
	CALL	TIMKIL#
	BR	RTNPR1			;Restore R1 and return
	.PAGE
	.SBTTL	Data

;Pure data

	PURE
	.EVEN

;Impure data

	IMPURE
	.EVEN

MINCNT:	.WORD	0		;Minute counter

;	.END
;	.TITLE	PKT3D  - DUMMY RECONNECT ROUTINES
	.SBTTL	PKT3D  - NEXILIS/JRG

	XLPAR				;Don't list parameter file
	CODE

;This module contains dummy routines loaded to satify global references
;  for nodes which do not support reconnect.

;Define symboles for the socket state dispatch table - the reconnect states
;  will never be used in this node, so we just define these symbols to be 0!

STARTP==!0
STARFP==!0
STARTW==!0
STARFW==!0
STARIP==!0

;Routine for reconnect packet when in normal connected state - this just
;  looks like a normal function packet in this case

SNDRCR::JMP	SNDDAT			;Just like a function packet

;Define symbol for the common subroutine used to set up the SRC field of the
;  reconnect generated connect packet - it is impossible to call this
;  subroutine in this node, so just define the symbol to be 0!

XXSSRC==!0

	.END
  I6Ht