	.TITLE	LNKE		- Link type E (SNAP protocol on DUV-11/DUP-11)
	.SBTTL	LNKE		- Definitions

	XLPAR				; Don't list parameter file

.IIF	NDF	..DPV,..DPV=0
.IF	EQ	<..DPV-1>

;-----
; BIT DEFINITION IN DPV RECEIVE CNTRL AND STATUS REGISTER (RXCSR, BASE+0)
;-----
;		MODEM CONTROL BITS
DSCHG	=	100000		;DATA SET CHANGE
DSRING	=	040000		;RING INDICATOR
DSCTS	=	020000		;CLEAR TO SEND
DSCARY	=	010000		;CARRIER INDICATOR
DSMODR	=	001000		;MODEM READY
DSITEN	=	000040		;DATA SET INTERRUPT ENABLE
DSLOOP	=	000010		;DATA SET LOOPBACK
DSRTS	=	000004		;REQUEST TO SEND
DSDTR	=	000002		;DATA TERMINAL READY
DSSEL	=	000001		;SELECT FREQUENCY

;		RECEIVER CONTROL BITS
RXACT	=	004000		;RECEIVER ACTIVE
RXSRDY	=	002000		;RECEIVER STATUS READY
RXFLAG	=	000400		;RECEIVER FLAG DETECT
RXDONE	=	000200		;RECEIVER DONE
RXITEN	=	000100		;RECEIVER INTERRUPT ENABLE
RXREN	=	000020		;RECEIVER ENABLE

;-----
; BIT DEFINITION OF DPV RECEIVE DATA AND STATUS REGISTER (RDSR, BASE+2, R/O)
;-----
RXERR	=	100000		;RECEIVER CRC ERROR
RXABC	=	070000		;RECEIVER ASSEMBLED BIT COUNT
RXOVRN	=	004000		;RECEIVER DATA OVERRUN
RXABRT	=	002000		;RECEIVED ABORT
RXENDM	=	001000		;RECEIVED END OF MESSAGE
RXSTRM	=	000400		;RECEIVED START OF MESSAGE

;-----
; BIT DEFINITION OF DPV PARAMETER CNTRL SYNC/ADDRESS REG. (PCSAR, BASE+2, W/O)
;-----
DPAPA	=	100000		;ALL PARTY ADDRESSED
DPPROT	=	040000		;PROTOCOL SELECTION
DPLPMD	=	020000		;LOOP MODE
DPSECS	=	010000		;SDLC/ADCCP SECONDARY STATION SELECT
DPIDLE	=	004000		;IDLE MODE SELECT
DPCRC	=	0*400		;CRC CCITT, BOTH CRC BYTES STARTS WITH ALL ONES

;-----
; BIT DEFINITION OF DPV PARAMETER CNTRL AND CHAR. LENGTH REG. (PCSCR, BASE+4)
;-----
TCLEN	=	160000		;TRANSMITTER CHARACTER LENGTH
EXADD	=	010000		;EXTENDED ADDRESS FIELD
EXCON	=	004000		;EXTENDED CONTROL FIELD
RCLEN	=	003400		;RECEIVE CHARACTER LENGTH
TXITEN	=	000100		;TRANSMITTER INTERRUPT ENABLE
TXREN	=	000020		;TRANSMITTER ENABLE
TXMAI	=	000010		;MAINTENANCE MODE SELECT
TXDONE	=	000004		;TRANSMITTER DONE
TXACT	=	000002		;TRANSMITTER ACTIVE
TXRES	=	000001		;DEVICE RESET

;-----
; BIT DEFINITION OF DPV TRANSMIT DATA AND STATUS REG. (TDSR, BASE+6)
;-----
TXLATE	=	100000		;TRANSMITTER DATA LATE (UNDERRUN)
TXGO	=	004000		;TRANSMIT GO AHEAD (NOT USED FOR HDLC)
TXABRT	=	002000		;TRANSMITTER ABORT
TXENDM	=	001000		;TRANSMIT END OF MESSAGE
TXSTRM	=	000400		;TRANSMIT START OF MESSAGE

	.MACRO	CHKLAT,?OK	;DEFINE A MACRO TO CHECK XMIT DATA LATE ERROR

	MOV	DDLEXB#(R4),R0	;GET ADDRESS OF DPV TDSR REGISTER
	TBBE	TXLATE,(R0),OK	;BRANCH IF NOT DATA LATE
	JMP	OFRAM1		;GO CLEAR ERROR, SEND FLAG AND TRY AGAIN
OK:
	.ENDM	CHKLAT

.ENDC		; .IF ..DPV=1



;-----
; Macro to return from interrupt (RTI) after restoring R0 and R4
;-----
.MACRO	RTI04
	MOV	(SP)+,R0
	MOV	(SP)+,R4
	RTI
.ENDM

;-----
; Flags (in DDLEFG field of DDB - link type E flag word)
;-----
$DLE	=! $BIT00			; DLE seen (for input DLE sequences)
$CRC	=! $BIT01			; Reading the 2 CRC bytes
$REJ	=! $BIT02			; Input is in reject condition
$CMDR	=! $BIT03			; CMDR condition exists on this side
$TIMER	=! $BIT04			; Time-out recovery is in progress
$IBUSY	=! $BIT05			; This side of link is busy
$OBUSY	=! $BIT06			; Other end of link is busy
$ABORT	=! $BIT07			; Abort this output frame
$ICPF	=! $BIT08			; Poll bit was set on input command
$OCPF	=! $BIT09			; Final bit should be set in output cmd
$FRXMT	=! $BIT10			; This output frame is retransmission
$REXMT	=! $BIT11			; Retransmit 1st frame on transmit ring
$RR	=! $BIT12			; Pending RR response for info frame
$SYNCH	=! $BIT13			; Need to synchronize link
$SARM1	=! $BIT14			; Sending first SARM
$DISC1	=! $BIT15			; Sending first DISC

;-----
; Flags (in DDLEF2 field of DDB - link type E 2nd flag word
;-----
$IRMA	=! $BIT11			; IRMA timer flag for output interrupt
$RUA	=! $BIT12			; Link needs to receive UA for SARM
$XUA	=! $BIT13			; Link needs to send UA to SARM
$RESET	=! $BIT14			; Link has been reset after cold start
$RDISC	=! $BIT15			; Resetting link with DISC (not SARM)

;-----
; Bit test and set values
;-----
$INFO	=! $BIT00			; Bit 0 of frame control byte
$SUPV	=! $BIT01			; Bit 1 of frame control byte
$PFBIT	=! $BIT04			; Bit 4 of frame control byte

$RSTRP	=! $BIT08			; Receiver control strip synch bit
$RSRCH	=! $BIT04			; Receiver control search for synch bit

$XSMSG	=! $BIT08			; Transmitter data start of message bit
$XMSTR	=! $BIT08			; Transmitter control master reset bit
$XSEND	=! $BIT04			; Transmitter control send bit

;-----
; Constants - base for modulus arithmetic
;-----
.MODN	=! 10				; Modulus (base) for arithmetic on
					;   V(R), V(S), N(R), N(S)
;-----
; Bit masks
;-----
$MASKN	=! ^C<.MODN-1>			; Bit clear mask for isolating (e.g.
					;   performing modulus arithmetic on)
					;   V(R), V(S), N(R), N(S)
;-----
; Constants - initialization values for the device registers
;-----
.PRDUV	=! <3*$BIT12>!<3*$BIT10>!SYN	; DUV-11 parameter reg initial value:
					;   Intern synch, 8-bit, SYN synch
.PRDUP	=! $BIT15!$BIT09!SYN		; DUP-11 parameter reg initial value:
					;   DEC mode, CRC inhib, SYN synch
.RINIT	=! $BIT08!$BIT06!$BIT04!$BIT02!$BIT01 ; Receiver cntl reg init value:
					;   Strip synch, Rec int enable, Search
					;   synch, Req to send, Data term rdy
.XINIT	=! $BIT06			; Xmitter control reg initial value:
					;   Xmit int enable
;-----
; Constants - timer duration values
;-----
.T3	=! 10.				; Idle output RR frame timer duration
.T4	=! 60.				; Reject condition timer duration
.T5	=! 60.				; Command Reject timer duration
.T6	=! 60.				; Idle input take-down timer duration

;-----
; Constants - shift counts
;-----
.SHFNR	=! 5				; Shift count to right justify N(R)

;-----
; Constants - frame control byte values
;-----
.SARM	=! 17				; Set Asynchronous Response Mode cmd
.DISC	=! 103				; DISConnect command
.UA	=! 143				; Unnumbered Acknowledge response
.CMDR	=! 207				; CoMmanD Reject response

.RR	=! 1				; Receive Ready supervisory response
.RNR	=! 5				; Receive Not Ready supv response
.REJ	=! 11				; REJect supervisory response

;-----
; Constants - input detected error status values
;-----
ER.IGN	=! 0				; Return after discarding frame
ER.OVF	=! 2				; Frame overflow
ER.UND	=! 4				; Frame underflow
ER.IVF	=! 6				; Invalid frame format
ER.INR	=! 10				; Invalid N(R)
ER.NIA	=! 12				; No info field allowed
ER.STO	=! 14				; Start output after dicarding frame
ER.RST	=! 16				; Reset link after discarding frame

;-----
; Constants - CMDR (CoMmanD Reject response) reasons
;-----
.CRSNW	=! $BIT03			; CMDR reason W (invalid control byte)
.CRSNX	=! $BIT02			; CMDR reason X (info fld not allowed)
.CRSNY	=! $BIT01			; CMDR reason Y (frame overflow)
.CRSNZ	=! $BIT00			; CMDR reason Z (invalid N(R))

;-----
; Constants - size parameters
;-----
.P1MAX	=! PKCMAX+3			; Maximum # bytes in 1st info field pkt

.SHSYN	=! 3				; # synch bytes for short frame synch
.LNSYN	=! 12.				; # synch bytes for long synch (init,
					;   reset link)
	CODE
	.SBTTL	LKEISV	- Input interrupt handler
;-----
; LKEISV - Processes input interrupts from the DUV-11/DUP-11 interface
;
; The following code has been executed to get here:
;	<input ready interrupt>
;	PUSH	R4			; Save R4
;	MOV	<address of DDB>,R4	; R4 --> DDB of link needing service
;	JMP	LKEISV			; Go to common input interrupt routine
;-----
LKEISV::
	PUSH	R0			; Save R0
	MOV	@DDLERB#(R4),R0		; Get byte from interface

.IF	EQ	<..DPV-1>	;IF USING DPV
	TBBE	<RXERR!RXABC!RXOVRN!RXABRT>,R0,10$  ;BRANCH IF NO ERROR
	TBBE	<RXERR!RXABC>,R0,5$	;BRANCH IF NOT CRC ERROR OR BIT MISSING
	INC	DDERCS#(R4)		;COUNT IT AS CHECKSUM ERROR
	BR	IABORT			;GO FREE PACKETS IF ANY

; GET HERE FOR DATA OVERRUN OR ABORT RECEIVED
;  IF ABORT RECEIVED, JUST FREE THE PACKETS IF ANY
;  IF DATA OVERRUN, THE RECEIVER MUST BE DISABLED MOMENTARILY SO THAT IT
;	WILL IGNORE THE REST OF THE CURRENT FRAME.
;
5$:
	TBBE	RXOVRN,R0,IABORT	;BRANCH IF NOT DATA OVERRUN(I.E. ABORT RCVD)
	INC	DDEROR#(R4)		;COUNT IT
	BR	IABOR0			;GO DISABLE RECEIVER AND FREE PACKETS

; NO ERROR INDICATION

10$:
	TBBE	RXSTRM,R0,20$		;BRANCH IF NOT SOM
	TST	DDLEIS#(R4)		;WAS INPUT IDLE?
	BEQ	15$			;YES, BRANCH
12$:	INC	DDERBF#(R4)		;NO, AN SOM IN THE MIDDLE OF A FRAME!
	BR	IABOR0			;GO DISABLE RECEIVER AND FREE PACKETS
15$:
	MOVB	DDLEK3#(R4),DDLEIK#(R4)	;SET FRAME BYTE COUNT TO MAX
	MOVB	#ER.UND,DDLEIZ#(R4)	;INIT INPUT STATUS TO UNDERFLOW (FRAME TOO SHORT)
	MOVB	R0,DDLEIA#(R4)		;SAVE FRAME ADDRESS BYTE
	MOV	#ICNTL,DDLEIS#(R4)	;NEXT STATE = GET FRAME CNTRL BYTE
	RTI04				;
20$:
	TST	DDLEIS#(R4)		;INPUT ACTIVE?
	BEQ	12$			;NO, GO RESET RECEIVER
	JMP	@DDLEIS#(R4)		;DISPATCH ON INPUT STATE

.IFF		;IF NOT USING DPV
	BPL	1$			; If no error, process  byte
	INC	DDEROR#(R4)		; Bump overrun error count
	BR	IABORT			; Might as well abort this input frame

1$:	BIC	#$RSTRP,@DDLERS#(R4)	; Clear device strip synch

	TBBN	$CRC,DDLEFG#(R4),ICCRC	; CRC bytes always computed into CRC
	TBBN	$DLE,DDLEFG#(R4),LKEIS1	; If DLE seen flag set, check DLE seq.

	CMPB	R0,#DLE			; This byte == DLE?
	BNE	ICCRC			; No - go calculate CRC-16 for byte
	BIS	#$DLE,DDLEFG#(R4)	; Yes - set DLE seen flag
	RTI04				; Return from interrupt
;-----
; Here to check for <DLE><STX>
;-----
LKEIS1:	BIC	#$DLE,DDLEFG#(R4)	; Clear DLE seen flag
	CMPB	R0,#STX			; Byte == STX?
	BNE	LKEIS2			; No

	TST	DDLEIF#(R4)		; In middle of previous frame?
	BEQ	1$			; No

	INC	DDERCS#(R4)		; Yes - bump checksum error count
	BR	IABOR1			; Discard frame info field

1$:	CLR	DDLECI#(R4)		; Clear input CRC
	MOVB	DDLEK3#(R4),DDLEIK#(R4)	; Set frame byte count to maximum
	MOVB	#ER.UND,DDLEIZ#(R4)	; Init input status to underflow
	MOV	#IADDR,DDLEIS#(R4)	; Input state <-- frame address byte
	RTI04				; Return from interrupt
;-----
; Here to check for <DLE><ETX>
;-----
LKEIS2:	TST	DDLEIS#(R4)		; Input active?
	BEQ	ISPURI			; No - spurious interrupt

	CMPB	R0,#ETX			; Byte == ETX?
	BNE	LKEIS3			; No - bypass
	MOV	#IENDTR,DDLEIS#(R4)	; Input state <-- end transparency
	BR	ICCRC			; Go calculate CRC
;-----
; Here to check for <DLE><SYN>, <DLE><DLE>, and frame abort (<DLE><???>)
;-----
LKEIS3:	CMPB	R0,#SYN			; Byte == SYN?
	BEQ	RTI000			; Yes - ignore it
	CMPB	R0,#DLE			; Byte == DLE?
	BNE	IABORT			; No - abort flag - abort frame
;-----
; Here to calculate partial CRC-16 for input byte
;-----
ICCRC:	TST	DDLEIS#(R4)		; Input active?
	BEQ	ISPURI			; No - spurious interrupt

	PUSH	R0			; Save registers
	PUSH	R1

	MOV	DDLECI#(R4),R1		; Get old partial CRC
	XOR	R1,R0			; XOR old CRC and new byte
	BIC	#177400,R0		; Clear high byte
	ASL	R0			; Convert to word index
	MOV	CRCTAB#(R0),R0		; Get modifier word
	CLRB	R1			; Clear low byte of old CRC
	SWAB	R1			; Move high byte of old CRC to low
	XOR	R0,R1			; XOR modifier and old CRC
	MOV	R1,DDLECI#(R4)		; Save new partial CRC

	POP	R1			; Restore registers
	POP	R0

	JMP	@DDLEIS#(R4)		; Dispatch to correct input state

;-----
; Here on unexpected interrupt when input is idle (spurious interrupt)
;-----
ISPURI:	INC	DDERSI#(R4)		; Bump spurious interrupt count

.IFTF
;-----
; Here to abort input frame
;-----
IABOR0:

.IFT		;IF USING DPV
;-----
; MOMENTARILY RESET 'RXREN' IN ORDER TO FORCE RECEIVER RE-SYNC.  THIS
;  IS REQUIRED FOR ANY ERROR WHICH TERMINATES THE RECEIVE OPERATION IN 
;  MID-FRAME.
;-----
	BIC	#RXREN,@DDLERS#(R4)
	BIS	#RXREN,@DDLERS#(R4)
.IFTF
IABORT:	TST	DDLEIF#(R4)		; Information field?
	BEQ	ISYNCH			; If no info field, search for synch

IABOR1:	PUSH	R1			; Save R1
	MOV	DDLEIF#(R4),R1		; Get 1st packet address
	CLR	DDLEIF#(R4)		; Clear packet list header

1$:	PUSH	(R1)			; Save forward packet link
	FREPKT				; Free the packet
	POP	R1			; Retrieve forward packet link
	BNE	1$			; Continue until whole list freed

	POP	R1			; Restore R1

;-----
; Here to establish character synchronization over the link
;   IT IS NOT NECESSARY FOR DPV TO ESTABLISH SYNCHRONIZATION ON THE NORMAL
;   COMPLETION OF A FRAME.
;-----
ISYNCH:
.IFF		;IF NOT USING DPV
	BIC	#$RSRCH,@DDLERS#(R4)	; Clear receiver search synch bit
	BIS	#<$RSRCH!$RSTRP>,@DDLERS#(R4) ; Set synch search & strip synch
	BIC	#<$DLE!$CRC>,DDLEFG#(R4); Clear frame transparency flags
.IFTF
	CLR	DDLEIS#(R4)		; Clear input state (go idle)
;-----
; Here to return from interrupt level
;-----
RTI000:	RTI04				; Return from interrupt
	.SBTTL	Protocol input states - frame address & control bytes
.IFF		;IF NOT USING DPV
;-----
; Here on frame address byte input
;-----
IADDR:	MOV	#ICNTL,DDLEIS#(R4)	; Input state <-- frame control byte
	MOVB	R0,DDLEIA#(R4)		; Save the address byte
	RTI04				; Return from interrupt
.IFTF
;-----
; Here on frame control byte input
;-----
ICNTL:
	MOVB	R0,DDLEIX#(R4)		; Save control byte
	CLRB	DDLEIZ#(R4)		; Frame format OK so far
.IF	EQ	<..DPV-1>	;IF USING DPV
	TBBN	RXENDM,R0,IMSEND	;BRANCH IF EOM RECEIVED
.ENDC
	MOV	#IINF0,DDLEIS#(R4)	; Input state <-- 1st byte of info fld
	RTI04				; Return from interrupt
	.SBTTL	Protocol input states - frame information field
;-----
; Here on first byte of information field
;-----
IINF0:	MOV	#IINFO,DDLEIS#(R4)	; Input state <-- rest of info field
	MOV	#DDLEIF#,DDLEIP#(R4)	; Let new packet code set 1st pkt ptr
	ADD	R4,DDLEIP#(R4)		;   by setting "link" of current to 1st
	MOV	#PKTYPE,DDLEIB#(R4)	; Start putting bytes into pkt type
	MOVB	#.P1MAX,DDLEIC#(R4)	; 1st pkt has more bytes (incl. header)
	BR	INEWP1			; Merge with new packet code

;-----
; Here to get a new packet for additional information field bytes
;-----
INEWPK:	MOV	#PKDATA,DDLEIB#(R4)	; Start putting bytes into pkt data
	MOVB	#PKCMAX,DDLEIC#(R4)	; Init packet byte counter

INEWP1:	PUSH	R1			; Save R1
	MAKPKT	.PLSTP#			; Get a free packet
	BCC	INEWP2			; Got a packet ==> go initialize it
;-----
; No packets available for frame information field bytes
;-----
IBUSY:	INC	DDERNP#(R4)		; Bump "No Packets Available" count
	BR	IABOR0			; Go  re-synch the interface & clean up

;-----
; Here to initialize new packet for information field bytes
;-----
INEWP2:	MOV	R1,@DDLEIP#(R4)		; Set link to new packet
	MOV	R1,DDLEIP#(R4)		; Save link to new current packet
	ADD	R1,DDLEIB#(R4)		; Init packet byte pointer
	MOVB	#PKCMAX,PKCNT(R1)	; Set full packet count
	CLRB	PKTYPE(R1)		; Clear packet type
	CLRB	PKSOC(R1)		; Clear packet socket number
	CLRB	PKSEQ(R1)		; Clear packet sequence number
	POP	R1			; Restore R1

;-----
; Here to input a byte of the information field
;-----
IINFO:	TSTB	DDLEIK#(R4)		; Check frame byte count
	BNE	1$			; Still room left - stuff byte

	MOVB	#ER.OVF,DDLEIZ#(R4)	; Frame status <-- overflow
					;WHO IS GOING TO SEE THIS ???
	BR	IABOR0			; Go re-synch the interface & clean up

1$:	TSTB	DDLEIC#(R4)		; Check packet byte count
	BEQ	INEWPK			; Packet full ==> get new packet

	MOVB	R0,@DDLEIB#(R4)		; Put byte into packet
	INC	DDLEIB#(R4)		; Bump byte pointer
	DECB	DDLEIK#(R4)		; Bump frame byte count
	DECB	DDLEIC#(R4)		; Bump packet byte count

.IF	EQ	<..DPV-1>	;IF USING DPV
	TBBE	RXENDM,R0,5$		;BRANCH IF NOT EOM YET
	CLR	R0			; Clear residue in register
	BISB	DDLEIC#(R4),R0		; Get # of bytes until packet full
	NEG	R0			; Negate # bytes until full
	ADD	#PKCMAX,R0		; PKCMAX-(#bytes until full)=#bytes
	ADD	#PKCNT,DDLEIP#(R4)	; Point pkt ptr at PKCNT to store count
	MOVB	R0,@DDLEIP#(R4)		; Store packet byte counter in packet
	BR	IMSEND			;and send to mainloop
5$:
.ENDC	;DPV

	RTI04				; Return from interrupt
	.SBTTL	Protocol input states - end frame & verify CRC

.IFF		;IF NOT USING DPV
;-----
; Here to end transparency
;-----
IENDTR:	MOV	#ICRC1,DDLEIS#(R4)	; Input state <-- CRC byte 1
	BIS	#$CRC,DDLEFG#(R4)	; Next bytes are CRC bytes
	TST	DDLEIF#(R4)		; Information field?
	BEQ	1$			; If no info field, return (RTI)

	CLR	R0			; Clear residue in register
	BISB	DDLEIC#(R4),R0		; Get # of bytes until packet full
	NEG	R0			; Negate # bytes until full
	ADD	#PKCMAX,R0		; PKCMAX-(#bytes until full)=#bytes
	ADD	#PKCNT,DDLEIP#(R4)	; Point pkt ptr at PKCNT to store count
	MOVB	R0,@DDLEIP#(R4)		; Store packet byte counter in packet
1$:	RTI04				; Return from interrupt

;-----
; Here on CRC byte 1
;-----
ICRC1:	MOV	#ICRC2,DDLEIS#(R4)	; Input state <-- CRC byte 2
	RTI04				; Return from interrupt

;-----
; Here on CRC byte 2 - end frame, verify, and send to main if CRC ok
;-----
ICRC2:	BIC	#$CRC,DDLEFG#(R4)	; Got 2nd CRC byte
	TST	DDLECI#(R4)		; Input CRC result == 0?
	BEQ	IMSEND			; Yes - frame assumed to be good
	INC	DDERCS#(R4)		; Bump checksum error count (CRC error)
	JMP	IABORT			; CRC result non-zero ==> discard frame

.IFTF
;-----
; Here to insert frame into input-to-main ring
;-----
IMSEND:	MOV	DDLEQP#(R4),R0		; Get input done ring putter
	MOV	DDLEIF#(R4),(R0)+	; Store info field packet list header
	MOVB	DDLEIX#(R4),(R0)+	; Store frame control byte
	MOVB	DDLEIZ#(R4),(R0)+	; Store input to main status byte
	CMP	R0,DDLEQE#(R4)		; End of ring?
	BLO	1$			; No
	MOV	DDLEQB#(R4),R0		; Yes - reset putter to start of ring
1$:	CMP	R0,DDLEQT#(R4)		; Ring full?
	BNE	2$			; No - go resynch device
	INC	DDEROR#(R4)		; Yes - bump overrun error count
	JMP	IABORT			; Throw this frame away

2$:	MOV	R0,DDLEQP#(R4)		; Update ring putter
	CLR	DDLEIF#(R4)		; Clear packet list pointer
	JMP	ISYNCH			; Go resynch device

.ENDC		;INPUT INTERRUPT SERVICE ROUTINE
	.SBTTL	LKEOSV	- Output interrupt handler
;-----
; LKEOSV - Processes output interrupts from the DUV-11/DUP-11 interface
;
; The following code has been executed to get here:
;	<output done interrupt>
;	PUSH	R4
;	MOV	<address of DDB>,R4
;	JMP	LKEOSV
;-----
LKEOSV::PUSH	R0			; Save R0
	BIS	#$IRMA,DDLEF2#(R4)	; Set IRMA timer flag
	MOV	DDLEOS#(R4),R0		; Get output state - output active?
	BEQ	ONEXTF			; No - check for new frame to send
	JMP	(R0)			; Yes - dispatch to output state
;-----
; Here to find next frame to send (if there is one)
;-----
ONEXTF:	TBBN	<$RUA!$XUA>,DDLEF2#(R4),ONEXT1 ; Bypass if not info xfr phase
	BIC	#$ABORT,DDLEFG#(R4)	; Clear abort flag (not sending yet)
	TBBN	$TIMER,DDLEFG#(R4),1f timer recovery, don't send info
	CMP	DDLELN#(R4),DDLELT#(R4)	; Info frames pending?
	BNE	OFINFO			; Yes - send info frame
	BR	2$			; Go check for pending RR frame

1$:	TBBN	$REXMT,DDLEFG#(R4),OFRXMT ; If retransmit flag set, retransmit
					;   1st frame on transmit ring
2$:	TBBN	$RR,DDLEFG#(R4),OFRR	; If pending RR response for info frame
					;   go send RR (or RNR if input busy)
ONEXT1:	MOVB	DDLECM#(R4),DDLEOX#(R4)	; Get pending command - anything there?
	BNE	OFCMND			; Yes - send command frame
	MOVB	DDLEAK#(R4),DDLEOX#(R4)	; Get pending ACK - anything there?
	BNE	OFRESP			; Yes - send response frame
;-----
; Here to go idle when there is no frame to output
;-----
OFIDLE:
.IF	EQ	<..DPV-1>	;IF USING DPV
	BIC	#TXITEN,@DDLEXS#(R4)	;DISABLE XMIT INTERRUPT
	MOV	DDLEXB#(R4),R0		;GET ADDRESS OF THE XMITTER BUFFER REG
	INC	R0			;POINTS TO UPPER BYTE
	MOVB	#TXSTRM/400,(R0)	;TSOM=1, TGA=TABORT=TEOM=0
					;SINCE DDLEPR(IDLE)=0, FLAGS WILL BE 
					;  SENT AND XMIT DATA LATE ERROR WILL
					;  SUPPRESSED.
.IFF				;IF NOT USING DPV
	TST	DDLEPX#(R4)		; DUP-11 or DU-11/DUV-11
	BMI	1$			; Skip if DUP-11

	BIC	#$XSEND,@DDLEXS#(R4)	; DU-11 or DUV-11 - Clear tranmitter
					;   send (idle w/marks)
.IFTF
1$:	CLR	DDLEOS#(R4)		; Clear output state (go inactive)
RTI001:	RTI04				; Return from interrupt
.ENDC

	.SBTTL	Set up for response frame (RR, RNR, REJ, UA, CMDR)
;-----
; Here to begin sending response frame
;-----
OFRESP:	CLRB	DDLEAK#(R4)		; Clear pending response function
	CMPB	DDLEOX#(R4),#.UA	; Unnumbered Acknowledge response?
	BEQ	OFRESX			; Yes
;-----
; Make sure all is well before sending a supervisory response frame
;-----
	BIC	#$RR,DDLEFG#(R4)	; Clear RR pending flag
	TBBN	<$RUA!$XUA>,DDLEF2#(R4),OFIDLE ; Go idle if not info xfr phase
	TBBE	$CMDR,DDLEFG#(R4),OFSUPV; If not CMDR state, send supervisory
;-----
; Begin sending CMDR frame
;-----
OFCMDR:	MOVB	#.CMDR,DDLEOX#(R4)	; Frame control byte <-- CMDR
	MOV	#OINFCR,DDLEOI#(R4)	; Info fld dispatch <-- CMDR info fld
	BR	OFRAME			; Start sending frame

;-----
; Here when received frames to be ACK'd and no info frame to piggyback ACK
;-----
OFRR:	BIC	#$RR,DDLEFG#(R4)	; Clear RR pending flag
	MOVB	#.RR,DDLEOX#(R4)	; Frame control byte <-- RR
;	TBBE	$IBUSY,DDLEFG#(R4),OFSUPV ; Input busy?
;	MOVB	#.RNR,DDLEOX#(R4)	; Yes - frame control byte <-- RNR

;-----
; Here to get N(R) for supervisory frame and finish setup
;-----
OFSUPV:	MOVB	DDLEVR#(R4),R0		; Get V(R) for supervisory frame
	ASHI	.SHFNR,R0		; Shift into N(R) position
	BISB	R0,DDLEOX#(R4)		; Put N(R) into control byte

;-----
; Here to set frame address and information field dispatch then start sending
;-----
OFRESX:	MOV	#OENDTR,DDLEOI#(R4)	; Info fld dispatch <-- no info fld
	MOVB	DDLEXR#(R4),DDLEOA#(R4)	; Frame address <-- outgoing response
	TBBE	$ICPF,DDLEFG#(R4),OFRAME; Should Final bit be set?
	BIC	#$ICPF,DDLEFG#(R4)	; Yes - clear input cmd Poll bit flag
	BISB	#$PFBIT,DDLEOX#(R4)	; Set Final bit in response frame
	BR	OFRAME			; Start sending frame


	.SBTTL	Set up for command frame (SARM, DISC, information)
;-----
; Here to prepare to retransmit 1st info frame on transmit ring
;-----
OFRXMT:	BIC	#$REXMT,DDLEFG#(R4)	; Clear retransmit flag
	BIS	#$FRXMT,DDLEFG#(R4)	; Flag this frame is retransmission
	MOVB	DDLEK1#(R4),DDLET1#(R4)	; Reset timer T1
	MOV	@DDLELH#(R4),DDLEOF#(R4); Get ptr to 1st frame on transmit ring
	BNE	1$			; Ok if something is there
	FSTOP	ZPR			; [Zero Packet list in Retransmission]

1$:	MOVB	DDLENR#(R4),DDLEOX#(R4)	; Control byte N(S) <-- stored N(R)
	BR	OFINF1			; Merge with info frame setup code

;-----
; Here for setup to send an information frame
;-----
OFINFO:	TBBE	$ICPF,DDLEFG#(R4),1$	; Was cmd frame read with Poll bit set?
	TBBN	$RR,DDLEFG#(R4),OFRR	; Yes - if it was info, send RR w/F bit

1$:	BIC	#$FRXMT,DDLEFG#(R4)	; Flag this frame not a retransmission
	MOV	@DDLELN#(R4),DDLEOF#(R4); Get ptr to next frame to send
	MOVB	DDLEVS#(R4),DDLEOX#(R4)	; Put V(S) into N(S) of control byte

OFINF1:	ASLB	DDLEOX#(R4)		; Position N(S) in control byte
	MOV	#OINF0,DDLEOI#(R4)	; Info fld dispatch <-- info frame kind
	MOVB	DDLEVR#(R4),R0		; Get V(R)
	ASHI	.SHFNR,R0		; Position N(R) for control byte
	BISB	R0,DDLEOX#(R4)		; Put N(R) into control byte
	BR	OFCMN1			; Merge with end of command frame setup

;-----
; Here to begin sending command frame
;-----
OFCMND:	CLRB	DDLECM#(R4)		; Clear pending command function
	MOV	#OENDTR,DDLEOI#(R4)	; Info fld dispatch <-- no info fld

OFCMN1:	MOVB	DDLEXC#(R4),DDLEOA#(R4)	; Frame address <-- outgoing command
	TBBE	$OCPF,DDLEFG#(R4),OFRAME; Send frame if P/F bit should be clear
	BIC	#$OCPF,DDLEFG#(R4)	; Clear output cmd frame Poll bit flag
	BISB	#$PFBIT,DDLEOX#(R4)	; Set Poll bit in frame control byte
;-----
; Drop through into beginning of frame output code...
;-----
	.SBTTL	Protocol output states - start sending frame
OFRAME:
.IF	EQ	<..DPV-1>	;IF USING DPV
;-----
; HERE TO START A NEW OUTPUT FRAME - SEND FRAME ADDRESS BYTE WITH TSOM OFF
;-----
	MOV	DDLEXB#(R4),R0	;GET ADDRESS OF XMIT BUFFER
	BIS	#TXITEN!TXREN,@DDLEXS#(R4) ; XMITTER ENABLE AND INTERRUPT ENABLE
	TBBE	TXLATE,(R0),OFRAM2	;BRANCH IF NOT UNDERRUN
;-----
; WE MAY GET HERE BECAUSE THE 1ST BYTE OF A FRAME TO ABUT IS SUPPLIED TOOU
;  LATE TO THE XMITTER
;-----
OFRAM1:
	INC	R0			;POINTS TO UPPER BYTE OF XMIT BUF REG
	MOVB	#TXSTRM/400,(R0)	;TSOM=1, CLEAR THE DATA LATE ERROR
	CLR	DDLEOS#(R4)		;CLEAR OUPUT STATE
	RTI04				;ABORT HAS BEEN SENT BY DPV;
					; HERE WE SEND A FLAG AND TRY TO 
					; RESTART THE XMISSION
OFRAM2:	
	MOV	#OCNTL,DDLEOS#(R4)	;NEXT STATE = OUTPUT CNTRL BYTE
	CLR	R0
	BISB	DDLEOA#(R4),R0		;GET FRAME ADDRESS FOR OUTPUT
OFRAM3:
	MOV	R0,@DDLEXB#(R4)		;OUTPUT A BYTE 
					;  WITH TSOM=TEOM=TGA=TABORT=0
	RTI04
.IFF		;NOT USING DPV
;-----
; Here to start a new output frame - send frame synch, start of transparency,
; address, and control bytes - <frame synch><DLE><STX><address><control>
;-----
	MOV	#OFRSYN,DDLEOS#(R4)	; Output state <-- send frame synch
	CLR	DDLECO#(R4)		; Initialize CRC-16 for this frame

	MOVB	#.SHSYN,DDLEOC#(R4)	; Output byte count <-- short synch
	TBBE	$SYNCH,DDLEFG#(R4),1$	; Should extra synch bytes be sent?
	BIC	#$SYNCH,DDLEFG#(R4)	; Yes - clear long synch flag
	MOVB	#.LNSYN,DDLEOC#(R4)	; Byte count <-- long synch string

1$:	TST	DDLEPX#(R4)		; DUP-11 or DU-11/DUV-11?
	BMI	OFRSYN			; Skip if DUP-11

	BIS	#$XSEND,@DDLEXS#(R4)	; DU-11 or DUV-11 - set send bit

;-----
; Here to send a frame synch byte
;-----
OFRSYN:	DECB	DDLEOC#(R4)		; Bump byte count
	BMI	OFRDLE			; When done, send <DLE><STX>
	MOV	#<$XSMSG!SYN>,@DDLEXB#(R4) ; Send <SYN> byte w/o CRC calc
					;   and set start of message bit
	RTI04				; Return from interrupt

;-----
; Here to send <DLE> byte before <STX> (start of transparency)
;-----
OFRDLE:	MOV	#OFRSTX,DDLEOS#(R4)	; Output state <-- send <STX> byte
	MOVB	#DLE,@DDLEXB#(R4)	; Send <DLE> byte w/o CRC calc
	RTI04				; Return from interrupt

;-----
; Here to send <STX> byte to start frame transparency
;-----
OFRSTX:	MOV	#OADDR,DDLEOS#(R4)	; Output state <-- frame address byte
	MOVB	#STX,@DDLEXB#(R4)	; Send <STX> byte w/o CRC calc
	RTI04				; Return from interrupt

;-----
; Here to output frame address byte
;-----
OADDR:	MOV	#OCNTL,DDLEOS#(R4)	; Output state <-- frame control byte
	CLR	R0			; Clear residue
	BISB	DDLEOA#(R4),R0		; Get frame address byte
	JMP	OTRANS			; Output byte with transparency
.IFTF
;-----
; Here to output frame control byte
;-----
OCNTL:
.IFT
	CHKLAT				;CHECK XMITER DATA LATE
.IFTF
	MOV	DDLEOI#(R4),DDLEOS#(R4)	; Output state <-- info field (if any)
	CLR	R0			; Clear residue
	BISB	DDLEOX#(R4),R0		; Get frame control byte
.IFT
	JMP	OFRAM3
.IFF
	JMP	OTRANS			; Output byte with transparency
.ENDC	;OFRAME
;-----
; **** NOTE ****
;
; Next output state is the beginning of the information field...  Only 2 frame
; formats have information fields: information command frame and CMDR response
; frame...  The other frame formats (SARM, DISC, UA, RR, RNR, REJ) are not
; allowed information fields...  When frame output is initialized at ONEXTF,
; the frame information field dispatch location is placed in the DDB (DDLEOI)
; depending on frame format...  This is one of: OINF0 (1st byte of information
; command frame information field), OINFCR (1st byte of CMDR response frame
; information field), or OENDTR (end transparency - i.e. no information field)
;-----
	.SBTTL	Protocol output states - information frame info field
;-----
; Here to begin output of information frame info field
;-----
OINF0:	MOV	#OINFO,DDLEOS#(R4)	; Output state <-- rest of info field
	MOV	DDLEOF#(R4),R0		; Get 1st packet pointer
	BNE	1$			; Ok if something is there
	FSTOP	ZPL			; [Zero Packet List]

1$:	MOV	R0,DDLEOP#(R4)		; Save current packet pointer
	MOV	R0,DDLEOB#(R4)		; Init packet byte pointer
	ADD	#PKTYPE,DDLEOB#(R4)	; Start taking bytes from packet type
	MOVB	PKCNT(R0),R0		; Get packet byte count
	ADD	#<PKDATA-PKTYPE>,R0	; 1st packet has more bytes
	MOVB	R0,DDLEOC#(R4)		; Store length of 1st packet
	BR	OINFO			; Go send 1st information field byte

;-----
; Here to get a new packet for additional information field bytes
;-----
ONEWPK:	MOV	@DDLEOP#(R4),R0		; Get link to new current packet
	BEQ	OINFET			; Quit if end of packet list

	MOV	R0,DDLEOP#(R4)		; Save current packet pointer
	MOV	R0,DDLEOB#(R4)		; Init packet byte pointer
	ADD	#PKDATA,DDLEOB#(R4)	; Start taking bytes from pkt data
	MOVB	PKCNT(R0),DDLEOC#(R4)	; Get packet byte count

;-----
; Here to send an information field byte
;-----
OINFO:	TBBN	$ABORT,DDLEFG#(R4),OABORT ; If time to abort, go do it
	TSTB	DDLEOC#(R4)		; Any bytes left in packet?
	BEQ	ONEWPK			; No - get next packet

.IF	EQ	<..DPV-1>	;IF USING DPV
	CHKLAT			;CHECK XMITER DATA LATE
.IFTF
	CLR	R0			; Clear residue
	BISB	@DDLEOB#(R4),R0		; Get byte from packet
	INC	DDLEOB#(R4)		; Bump byte pointer
	DECB	DDLEOC#(R4)		; Bump packet byte count
.IFT	;DPV
	JMP	OFRAM3
.IFF
	JMP	OTRANS			; Output byte with transparency
.ENDC

;-----
; Here to end info frame info field and update V(S)
;-----
OINFET:
.IF	EQ	<..DPV-1>	;USING DPV
	CHKLAT			;CHECK XMITER DATA LATE

	INC	R0			;POINTS TO UPPER BYTE OF XMIT BUF REG
	MOVB	#TXENDM/400,(R0)	;SET TEOM TO SEND CRC1, CRC2, FLAG
					; OUTPUT DONE INTERRUPT SHOULD THEN
					;  OCCUR
	MOV	#ONEXTF,DDLEOS#(R4)	;NEXT STATE=SENDING A NEW FRAME IF 
					;  THERE IS ONE
.IFTF
	BIC	#$RR,DDLEFG#(R4)	; Clear RR pending flag
	TSTB	DDLET1#(R4)		; Timer T1 set?
	BNE	1$			; Yes - don't reset it
	MOVB	DDLEK1#(R4),DDLET1#(R4)	; No - set it
	MOV	#XXINFO,DDLETX#(R4)	; Timer expire state <-- sending info
1$:	TBBE	$FRXMT,DDLEFG#(R4),2$	; If not retransmission, bump V(S)
	BIC	#$FRXMT,DDLEFG#(R4)	; Retransmission - clear flag
	BR	20$

2$:	INCB	DDLEVS#(R4)		; Bump V(S)
	BICB	#$MASKN,DDLEVS#(R4)	; Perform modulus addition
	ADD	#2,DDLELN#(R4)		; Bump next-frame-to-send pointer
	CMP	DDLELN#(R4),DDLELE#(R4)	; End of ring?
	BLO	20$
	MOV	DDLELB#(R4),DDLELN#(R4)	; Yes - reset next frame pointer
20$:
.IFT
	RTI04			;TEOM WAS SET, ALL DONE IF DPV
.IFF
	BR	OENDTR		;GO END TRANSPARENCY IF NOT DPV
.ENDC

;-----
; Here to abort output frame
;-----
OABORT:
.IF	EQ	<..DPV-1>	;IF USING DPV
	MOV	DDLEXB#(R4),R0
	INC	R0
	BISB	#TXABRT/400,(R0)	;SET TXABORT,
	MOV	#ONEXTF,DDLEOS#(R4)	;

.IFF	;NOT USING DPV
	MOV	#OABOR1,DDLEOS#(R4)	; Output state <-- send <EOT>
	MOVB	#DLE,@DDLEXB#(R4)	; Send <DLE> byte w/o CRC calc
	RTI04				; Return from interrupt

;-----
; Here to complete frame abort
;-----
OABOR1:	MOV	#OPAD1,DDLEOS#(R4)	; Output state <-- send pad byte
	MOVB	#EOT,@DDLEXB#(R4)	; Send <EOT> byte w/o CRC calc

.IFTF
	BIC	#<$ABORT!$FRXMT>,DDLEFG(R4) ; Clear abort and retransmitted
					;   frame flags
	RTI04				; Return from interrupt
.ENDC
	.SBTTL	Protocol output states - CMDR frame information field
;-----
; Here to begin information field of CMDR frame
;-----
OINFCR:
.IF	EQ	<..DPV-1>	;USING DPV
	CHKLAT
.IFTF
	MOV	#OCVRVS,DDLEOS#(R4)	; Output state <-- send V(R) and V(S)
	CLR	R0			; Clear residue
	BISB	DDLECX#(R4),R0		; Get bad control byte
.IFT
	JMP	OFRAM3
.IFF
	BR	OTRANS			; Output byte with transparency
.ENDC

;-----
; Here to send V(R) and V(S) in CMDR info field
;-----
OCVRVS:
.IF	EQ	<..DPV-1>	;IF USING DPV
	CHKLAT
.IFTF
	MOV	#OCRSN,DDLEOS#(R4)	; Output state <-- send CMDR reason
	CLR	R0			; Clear residue
	BISB	DDLEVR#(R4),R0		; Get V(R)
	ASHI	<.SHFNR-1>,R0		; Partially align V(R)
	BISB	DDLEVS#(R4),R0		; Get V(S)
	ASL	R0			; Align V(R) and V(S)
.IFT
	JMP	OFRAM3
.IFF
	BR	OTRANS			; Output byte with transparency
.ENDC
;-----
; Here to send CMDR reason in CMDR frame info field
;-----
OCRSN:
.IF	EQ	<..DPV-1>
	CHKLAT
.IFTF
	MOV	#OENDTR,DDLEOS#(R4)	; Output state <-- end transparency
	CLR	R0			; Clear residue
	BISB	DDLECR#(R4),R0		; Get CMDR reason
.IFT
	JMP	OFRAM3
.IFF
	BR	OTRANS			; Output byte with transparency
.ENDC
	.SBTTL	Protocol output states - <DLE><ETX>, CRC, pad byte
;-----
; Here to end transparency
;-----
OENDTR:
.IF 	EQ	<..DPV-1>	;IF USING DPV
	MOVB	#.T3,DDLET3#(R4)	;RESTART THE IDLE OUTPUT RR TIMER
	CHKLAT
	INC	R0		;POINTS TO UPPER BYTE OF TDSR
	MOVB	#TXENDM/400,(R0) ;SET EOM TO SEND CRC1, CRC2, FLAG
	MOV	#ONEXTF,DDLEOS(R4) ; NEXT STATE WHEN ABOVE SEQUENCE IS DONE
	RTI04
.IFF				;NOT USING DPV
	MOV	#ONEXTF,DDLEOS#(R4) ;
	MOV	#OENDT1,DDLEOS#(R4)	; Output state <-- send <ETX>
	MOVB	#DLE,@DDLEXB#(R4)	; Send <DLE> byte w/o CRC calc
	RTI04				; Return from interrupt
;-----
; Here to send <ETX>
;-----
OENDT1:	MOV	#OCRC1,DDLEOS#(R4)	; Output state <-- send CRC byte 1
	MOV	#ETX,R0			; Send <ETX>
	BR	OCCRC			; Go calc CRC and send byte

;-----
; Here to send CRC byte 1
;-----
OCRC1:	MOV	#OCRC2,DDLEOS#(R4)	; Output state <-- send CRC byte 2
	MOVB	DDLECO#(R4),@DDLEXB#(R4); Send CRC byte 1
	RTI04				; Return from interrupt

;-----
; Here to send CRC byte 2
;-----
OCRC2:	MOV	#OPAD,DDLEOS#(R4)	; Output state <-- send pad byte
	MOVB	DDLECO#+1(R4),@DDLEXB#(R4) ; Send CRC byte 2
	RTI04				; Return from interrupt

;-----
; Here to send pad byte following frame
;-----
OPAD:	MOVB	#.T3,DDLET3#(R4)	; Restart the idle output RR frame timer
OPAD1:	MOV	#ONEXTF,DDLEOS#(R4)	; Output state <-- next frame to send
	MOV	#377,@DDLEXB#(R4)	; Send pad byte & clear start msg bit
	RTI04				; Return from interrupt
	.SBTTL	Protocol output states - CRC & send byte to device
;-----
; Here to perform transparent byte output - double each <DLE> byte
;-----
OTRANS:	CMPB	R0,#DLE			; Byte == <DLE>?
	BNE	OCCRC			; No - calculate CRC and send byte
	MOV	DDLEOS#(R4),DDLETS#(R4)	; Save output state
	MOV	#OTRAN1,DDLEOS#(R4)	; Output state <-- duplicate <DLE> byte
	MOVB	R0,@DDLEXB#(R4)		; Send 1st <DLE> w/o CRC calc
	RTI04				; Return from interrupt
;-----
; Here to send 2nd <DLE> byte for transparency
;-----
OTRAN1:	MOV	DDLETS#(R4),DDLEOS#(R4)	; Restore output state to normal
	MOV	#DLE,R0			; Get 2nd <DLE> byte

;-----
; Here to calculate partial CRC-16 for output byte
;-----
OCCRC:	MOVB	R0,@DDLEXB#(R4)		; Send byte accross interface

	PUSH	R1			; Save register

	MOV	DDLECO#(R4),R1		; Get old partial CRC
	XOR	R1,R0			; XOR old CRC and new byte
	BIC	#177400,R0		; Clear high byte
	ASL	R0			; Convert to word index
	MOV	CRCTAB#(R0),R0		; Get modifier word
	CLRB	R1			; Clear low byte of old CRC
	SWAB	R1			; Move high byte of old CRC to low
	XOR	R0,R1			; XOR modifier and old CRC
	MOV	R1,DDLECO#(R4)		; Save new partial CRC

	POP	R1			; Restore register

	RTI04				; Return from interrupt
.ENDC	;OENDTR
	.SBTTL	Main program level entry points
;-----
; LKEINI - Subroutine to initialize the DDB
;
; Linkage:
;	C(R4) = address of DDB
;	CALL	LKEINI
;-----
LKEINI::CLR	@DDLEXB#(R4)		; Does device exist?
	NXMJMP	NOLINK#			; No - mark it so

.IF	EQ	<..DPV-1>	;IF USING DPV
	CLR	DDLEPX#(R4)	;DPV PCSAR INITIAL VALUE
				;NO APA, BOP, NOT LOOP MODE, FLAG TO OPEN 
				; AND CLOSE A FRAME( NOT GO AHEAD),
				; NO SECONDARY ADDRESS CHECKING, SENDS ABORT
				; IF DATA UNDERRUN, CRC CCITT STARTING WITH
				; ALL ONES
.IFF			;IF NOT USING DPV

	TBBN	$XSMSG,@DDLEXB#(R4),1$	; This is DU-11 if bit not affected
	MOV	#$XSMSG,@DDLEXB#(R4)	; DUP-11 or DUV-11?
	TBBE	$XSMSG,@DDLEXB#(R4),1$	; DUV-11 if bit not accected

	MOV	#.PRDUP,DDLEPX#(R4)	; DUP-11 - get parameter reg init val
	BR	2$

1$:	MOV	#.PRDUV,DDLEPX#(R4)	; DU-11/DUV-11 - get param reg init val
2$:
.ENDC
	MOV	#$D1DWN,DDSTS1#(R4)	; Indicate link down - once a second
					;   will try to start link
	MOV	#DDLECZ#,R1		; Get number of words to clear
	MOV	#DDLEFC#,R2		; Set pointer to first word to clear
	ADD	R4,R2			; Set pointer into DDB

3$:	CLR	(R2)+			; Clear word
	SOB	R1,3$			; Continue until all words clear

	MOV	DDLEQB#(R4),DDLEQP#(R4)	; Init input to main ring putter
	MOV	DDLEQB#(R4),DDLEQT#(R4)	; Init taker
	MOV	DDLELB#(R4),DDLELH#(R4)	; Init transmit ring head pointer
	MOV	DDLELB#(R4),DDLELN#(R4)	; Init Xmit ring next-to-send ptr
	MOV	DDLELB#(R4),DDLELT#(R4)	; Init transmit ring tail pointer
	MOV	#$RDISC,DDLEF2#(R4)	; Start resetting link with DISC

	RETURN				; Return to caller

;-----
; LKEINS - Subroutine to initialize device dependent part of SBD
;
; Linkage:
;	C(SD) = address of SDB
;	CALL	LKEINS
;-----
LKEINS::MOV	#SDLECZ#,R1		; Get number of words to clear
	MOV	#SDLEFC#,R2		; Set pointer to first word to clear
	ADD	SD,R2			; Set pointer into DDB

1$:	CLR	(R2)+			; Clear word
	SOB	R1,1$			; Continue until all words clear

	RETURN				; Return to caller

;-----
; LKEMAI - main loop entry point to link type E protocol (SNAP)
;-----
	MAINXX	LKEMAI

LKEMAI:	MOV	#LKEDDB#,R4		; Get 1st type E link DDB
;-----
; Check link for input activity
;-----
LKEMA1:	TBBN	$D1UNV,DDSTS1#(R4),LKEMA3 ; If link hardware not there, check
					;   next type E link
	CMP	DDLEQP#(R4),DDLEQT#(R4)	; Something in input done ring?
	BEQ	LKEMA2			; No - check for new frames to send
	CALL	MINPUT			; Yes - get input frame
;-----
; Check link for new frames to send
;-----
LKEMA2:	TBBE	$D1ACT,DDSTS1#(R4),LKEMA3 ; Check next link if device inactive
	CMPB	DDLEVT#(R4),DDLEK0#(R4)	; Device active - room in Xmit ring?
	BHIS	LKEMA3			; No - check output state
	CALL	LKENXT#			; Yes - get next packet to send and
					;   start output if idle
;-----
; Advance to next type E link
;-----
LKEMA3:	MOV	DDLKNS#(R4),R4		; Get next type E link DDB
	BNE	LKEMA1			; If another link, check for activity

	RETURN				; All done - return to caller
	.SBTTL	Main level frame input verification and completion
;-----
; Here when activity detected on input side (frame has been read)
;-----
MINPUT:	MOV	DDLEQT#(R4),R0		; Get input done ring taker
	MOV	(R0)+,DDLEMF#(R4)	; Get packet list header
	MOVB	(R0)+,DDLEMX#(R4)	; Get frame control byte
	MOVB	(R0)+,R2		; Get frame status byte
	CMP	R0,DDLEQE#(R4)		; Beyond end of ring?
	BLO	1$			; No
	MOV	DDLEQB#(R4),R0		; Yes - reset ring taker
1$:	MOV	R0,DDLEQT#(R4)		; Update taker

	TST	R2			; Error detected on frame input?
	BEQ	MINPOK			; No - frame input ok

	INC	DDERSZ#(R4)		; Size error detected at interrupt level

MINBAD:	MOV	DDLEMF#(R4),R1		; Yes - get packet list ptr
	BEQ	2$			; Nothing to free
	CLR	DDLEMF#(R4)		; Clear packet list pointer

1$:	PUSH	(R1)			; Store forward packet pointer
	FREPKT				; Free the packet
	POP	R1			; Retrieve forward pointer
	BNE	1$			; Continue until packet list free

2$:	JMP	@MIERDT(R2)		; Dispatch to error code
;-----
; Input error dispatch table
;-----
	PURE
	.EVEN
MIERDT:	.WORD	RTN000			; ER.IGN =  0 ignore this frame
	.WORD	ERROVF			; ER.OVF =  2 frame overflow
	.WORD	ERRIVF			; ER.UND =  4 frame underflow
	.WORD	ERRIVF			; ER.IVF =  6 invalid frame
	.WORD	RTN000			; ER.INR = 10 invalid N(R)
	.WORD	ERRNIA			; ER.NIA = 12 no info field allowed
	.WORD	STARTO			; ER.STO = 14 start output
	.WORD	LRESET			; ER.RST = 16 reset the link
	CODE

;-----
; Here if no error status reported from input
;-----
MINPOK:	MOVB	#.T6,DDLET6#(R4)	; Start idle input take-down timer
	BITB	#$INFO,DDLEMX#(R4)	; Information frame?
	BEQ	1$			; Yes - go do flow control
	BITB	#$SUPV,DDLEMX#(R4)	; Supervisory frame?
	BNE	MIUNUM			; No - check unnumbered frame

	TST	DDLEMF#(R4)		; Yes - information field?
	BEQ	1$			; No - go do flow control
	MOV	#ER.NIA,R2		; Yes - none allowed with supervisory
	BR	MINBAD			; Discard this frame

1$:	BIC	#<$SARM1!$DISC1>,DDLEFG#(R4) ; Clear 1st SARM & 1st DISC flags
	TBBN	<$RUA!$XUA>,DDLEF2#(R4),MINBAD ; Ignore if not info xfr phase
	JMP	MACKNR			; Go perform flow control update
					;   (free acknowledged frames)
;-----
; Here to complete input of unnumbered command/response frame
;-----
MIUNUM:	MOVB	DDLEMX#(R4),R0		; Get frame control byte
	BIC	#<177400!$PFBIT>,R0	; Clear Poll/Final bit

	CMPB	R0,#.SARM		; Set Asynchronous Response Mode?
	BEQ	MIUCMD			; Yes
	BIC	#$SARM1,DDLEFG#(R4)	; No - clear 1st SARM flag

	CMPB	R0,#.DISC		; DISConnect?
	BEQ	MIUCMD			; Yes
	BIC	#$DISC1,DDLEFG#(R4)	; No - clear 1st DISC flag

	CMPB	R0,#.UA			; Unnumbered Acknowledge?
	BEQ	MIUA			; Yes

	CMPB	R0,#.CMDR		; CoMmanD Reject?
	BEQ	MICMDR			; Yes

	MOV	#ER.IVF,R2		; Unrecognized command/response
	BR	MINBAD			; DIscard this frame & process error

;-----
; Here on CMDR unnumbered response frame
;-----
MICMDR:	MOV	#ER.RST,R2		; Indicate link must be reset
	BR	MINBAD			; Go reset link

;-----
; Here on unnumbered commands (SARM or DISC)
;-----
MIUCMD:	TST	DDLEMF#(R4)		; Information field?
	BEQ	1$			; No

	MOV	#ER.NIA,R2		; Yes - none allowed
	BR	MINBAD			; Discard frame & process error

1$:	BITB	#$PFBIT,DDLEMX#(R4)	; Poll bit set in command frame?
	BEQ	2$			; No
	BIS	#$ICPF,DDLEFG#(R4)	; Yes - flag it
2$:	MOVB	#.UA,DDLEAK#(R4)	; Pending ACK <-- UA
	CALL	STARTO			; Start output if idle

	BIC	#$CMDR,DDLEFG#(R4)	; Clear command reject condition
	CLRB	DDLET5#(R4)		; Clear CMDR condition timer

	CMPB	R0,#.SARM		; Is this a SARM?
	BNE	MIDISC			; No - it is a DISC

;-----
; Here on SARM unnumbered frame
;-----
MISARM:	CLRB	DDLEVR#(R4)		; V(R) <-- 0
	BIC	#<$IBUSY!$REJ!$TIMER!$REXMT>,DDLEFG#(R4) ; Clear flags
	CLRB	DDLET4#(R4)		; Clear reject condition timer
	BIC	#$XUA,DDLEF2#(R4)	; Indicate this side Xmitted UA for SARM
	TBBN	$RUA,DDLEF2#(R4),2$	; Need to send SARM?
	TBBN	$SARM1,DDLEFG#(R4),2$	; Is this a 1st SARM?
	CALL	MOSARM			; Yes - send SARM to init other side

2$:	BIS	#$SARM1,DDLEFG#(R4)	; Set received 1st SARM flag
	TBBN	<$RUA!$XUA>,DDLEF2#(R4),3$ ; Bypass if not info xfr phase now
	CJMP	RSTX25#			; Go restart the link

3$:
	CMP	DDLELN#(R4),DDLELT#(R4)	; Frames waiting to be sent?
	BEQ	RTN000			; No
	CJMP	STARTO			; Yes - try to start output

;-----
; Here on DISC unnumbered frame
;-----
MIDISC:	TBBE	$RUA,DDLEF2#(R4),1$	; Skip if not waiting for UA to SARM
	JMP	MOSARM			; Make sure other side gets SARM

1$:	CALL	LKEDWN			; Declare link down
	TBBN	$RUA,DDLEF2#(R4),2$	; Bypass if waiting for UA to SARM
	TBBN	$DISC1,DDLEFG#(R4),2$	; Is this a 1st DISC?
	TBBE	$D0PRI,DDSTS0#(R4),2$	; Yes - is this side a DTE?
	CALL	MODISC			; No - send DISC frame

2$:	BIS	#$DISC1,DDLEFG#(R4)	; Set received 1st DISC flag
	BIS	#$XUA,DDLEF2#(R4)	; Indicate now in disconnected phase
	BIC	#$RUA,DDLEF2#(R4)	; Indicate need SARM output now
RTN000:	RETURN				; Return to main

;-----
; Here on UA unnumbered response frame
;-----
MIUA:	TST	DDLEMF#(R4)		; Information field?
	BEQ	1$			; No - OK
	MOV	#ER.NIA,R2		; Yes - none allowed
	JMP	MINBAD			; Discard this frame & process error

1$:	BIC	#$OBUSY,DDLEFG#(R4)	; Indicate other side of link not busy
	MOV	DDLEUR#(R4),R0		; Anyone waiting for UA response?
	BEQ	RTN000			; No - return
	CLR	DDLEUR#(R4)		; Yes - clear UA input wait dispatch
	JMP	(R0)			; Dispatch to UA wait code
;-----
; Here when UA received after SARM sent
;-----
URSARM:	CLRB	DDLET1#(R4)		; Stop timer T1
	MOVB	DDLEK2#(R4),DDLEN2#(R4)	; Reset retransmission counter
	CLRB	DDLEVS#(R4)		; V(S) <-- 0
	CLRB	DDLENR#(R4)		; Clear last N(R) received
	BIC	#$RUA,DDLEF2#(R4)	; Indicate this side got UA for SARM
	BIC	#<$IBUSY!$REJ!$TIMER!$REXMT>,DDLEFG#(R4) ; Clear flags
	CLRB	DDLET4#(R4)		; Clear reject condition timer
	TBBN	<$RUA!$XUA>,DDLEF2#(R4),RTN000 ; Return if not info xfr phase
	CJMP	RSTX25#			; Restart link if now info xfr phase
;-----
; Here when UA received after DISC sent
;-----
URDISC:	CALL	LKEDWN			; Declare link down
	CLRB	DDLET1#(R4)		; Stop timer T1
	MOVB	DDLEK2#(R4),DDLEN2#(R4)	; Reset retransmission counter
	BIC	#$RDISC,DDLEF2#(R4)	; Now reset link with SARMs
	CJMP	MOSARM			; Send a SARM to initiate the link

;-----
; Here to free packets held by acknowledged frames on transmit ring
;-----
MACKNR:	MOV	DDLELH#(R4),R0		; Get frame transmit ring header

	MOVB	DDLEMX#(R4),R2		; Get frame control byte
	ASHI	-.SHFNR,R2		; Right justify N(R)
	BIC	#$MASKN,R2		; Isolate N(R)

	CMPB	R2,DDLENR#(R4)		; Any frames to acknowledge?
	BEQ	MACKN3			; No
;-----
; Here to free a frame from the frame transmit ring
;-----
MACKN1:	CMPB	DDLENR#(R4),DDLEVS#(R4)	; Trying to free unsent frame?
	BEQ	MIERNR			; Yes - new N(R) is bad
	MOV	(R0),R1			; Maybe - get info fld pkt list header
	BEQ	MIERNR			; Yes - new N(R) is bad

	BIC	#$REXMT,DDLEFG#(R4)	; New ACK - don't do retransmission
	CLR	(R0)+			; Clear packet pointer from Xmit ring
	CMP	R0,DDLELE#(R4)		; End of ring?
	BLO	MACKN2			; No
	MOV	DDLELB#(R4),R0		; Yes - reset ring pointer
;-----
; Here to free packets from frame transmit ring when frames acknowledged
;-----
MACKN2:	PUSH	(R1)			; Save forward packet link
	FREPKT				; Free the packet
	POP	R1			; Retrieve forward packet link
	BNE	MACKN2			; Continue until all packets free

	DECB	DDLEVT#(R4)		; Decrement transmit ring frame count
	INCB	DDLENR#(R4)		; Bump stored N(R)
	BICB	#$MASKN,DDLENR#(R4)	; Perform modulus addition

	MOV	R0,DDLELH#(R4)		; Update head pointer

	CMPB	DDLENR#(R4),R2		; Stored N(R) == new N(R)?
	BNE	MACKN1			; No - continue until all frames freed

;-----
; Newly ACK'd frames freed from output ring
;-----
	MOVB	DDLEK2#(R4),DDLEN2#(R4)	; Reset retransmission counter

	MOVB	DDLEK1#(R4),DDLET1#(R4)	; Something ACK'd - reset timer T1
	TSTB	DDLEVT#(R4)		; Anything left in ring?
	BNE	MACKN3			; Yes

	CLRB	DDLET1#(R4)		; No - clear timer T1
	BIC	#$TIMER,DDLEFG#(R4)	; Clear timer state when nothing left
;-----
; Here after frames acknowledged and packets freed
;-----
MACKN3:	CLR	R3			; Clear residue
	BISB	DDLEMX#(R4),R3		; Get frame control byte

	TBBE	$INFO,R3,MIINFO		; Go process info frame
	TBBE	$PFBIT,R3,MISUPV	; Go process SUPV w/Poll bit clear

	BIC	#$TIMER,DDLEFG#(R4)	; Yes - clear timer recovery condition
	MOVB	R2,DDLEVS#(R4)		; V(S) <-- N(R) of supervisory frame
	MOV	R0,DDLELN#(R4)		; Next to send pointer <-- head of ring
;-----
; Here to complete supervisory frame input
;-----
MISUPV:	ASR	R3			; Make word index of SUPV function
	BIC	#$MASKN,R3		; Isolate supervisory function
	JMP	@MISUDT(R3)		; Dispatch on supervisory function
;-----
; Input supervisory function dispatch table
;-----
	PURE
	.EVEN
MISUDT:	.WORD	MIRR			; Receive Ready
	.WORD	MIRNR			; Receive Not Ready
	.WORD	MIREJ			; REJect
	.WORD	MIERSU			; Undefined supervisory function
	CODE
;-----
; Here on RNR supervisory response frame
;-----
MIRNR:	BIS	#$OBUSY,DDLEFG#(R4)	; Indicate other side of link busy
	MOVB	DDLEK2#(R4),DDLEN2#(R4)	; Reset retransmission counter
	RETURN				; Return to caller
;-----
; Here on REJ supervisory response frame
;-----
MIREJ:	TBBN	$TIMER,DDLEFG#(R4),MIRR1; Don't change V(S) if in timer state
	BIS	#$ABORT,DDLEFG#(R4)	; Abort info frame if sending one
	MOVB	R2,DDLEVS#(R4)		; V(S) <-- N(R) received
	MOV	R0,DDLELN#(R4)		; Set next frame pointer to 1st frame
;-----
; Here on RR supervisory response frame
;-----
MIRR:	BIC	#$OBUSY,DDLEFG#(R4)	; Indicate other side of link not busy
	CMP	DDLELN#(R4),DDLELT#(R4)	; Frames waiting to be sent?
	BEQ	MIRR1			; No - return
	CJMP	STARTO			; Yes - start output if idle

MIRR1:	RETURN				; Return to caller

;-----
; Here on N(R) errors (trying to ACK unsent or already ACK'd frames)
;-----
MIERNR:
;	BITB	#$INFO,DDLEMX#(R4)	; Information frame?
;	BNE	MIERSU			; No - SUPV with bad N(R) - reset link
	INC	DDERPC#(R4)		; Bump protocol error count
	MOV	#ER.INR,R2		; Declare N(R) error
	JMP	MINBAD			; Discard frame & process error
;-----
; Here on undefined supervisory function in control byte
;-----
MIERSU:	INC	DDERPC#(R4)		; Bump protocol error count
	MOV	#ER.RST,R2		; Declare link must be reset
	JMP	MINBAD			; Discard frame & reset link

;-----
; Here to complete information frame input
;-----
MIINFO:	TBBE	$PFBIT,R3,1$		; Poll bit set in info frame?
	BIS	#$ICPF,DDLEFG#(R4)	; Yes - flag incoming command w/Poll bit

1$:	ASR	R3			; Right justify N(S)
	BIC	#$MASKN,R3		; Isolate N(S)
	CMPB	R3,DDLEVR#(R4)		; Is this the next expected frame?
	BEQ	4$			; Yes

	MOV	#ER.STO,R2		; No - flag start output after frame
					;   is discarded
	TBBN	$REJ,DDLEFG#(R4),2$	; Skip if already in reject condition

	BIS	#$REJ,DDLEFG#(R4)	; Set reject condition flag
	MOVB	#.T4,DDLET4#(R4)	; Start reject condition timer
	MOVB	#.REJ,DDLEAK#(R4)	; Pending ACK <-- REJ
	JMP	MINBAD			; Discard frame & send REJ frame

2$:	TBBE	$ICPF,DDLEFG#(R4),3$	; Poll bit set in this frame?
	BIS	#$RR,DDLEFG#(R4)	; Yes - send RR frame w/Final bit set
	JMP	MINBAD			; Discard frame & send RR frame

3$:	CLR	R2			; Flag this frame should be ignored
	JMP	MINBAD			; Discard frame

4$:	BIC	#$REJ,DDLEFG#(R4)	; Clear reject condition
	CLRB	DDLET4#(R4)		; Clear reject condition timer

	MOVB	DDLEVR#(R4),R0		; Get V(R)
	INC	R0			; Bump V(R)
	BIC	#$MASKN,R0		; Perform modulus arithmetic
	MOVB	R0,DDLEVR#(R4)		; Update V(R)

	BIS	#$RR,DDLEFG#(R4)	; Indicate pending RR frame
	CALL	STARTO			; Start output if idle

	MOV	DDLEMF#(R4),R1		; Get packet list - anything there?
	BEQ	5$			; No - must have been ignored or bad

	CLR	DDLEMF#(R4)		; Yes - clear packet list pointer
	CJMP	LKEMOV#			; Translate & send packets into node

5$:	RETURN				; Return to main loop
	.SBTTL	Main level error states (causes for sending CMDR)
;-----
; Here if frame format error or unknown command/response in control byte
;-----
ERRIVF:	MOVB	#.CRSNW,DDLECR#(R4)	; Set CMDR reason W (invalid cntl byte)
	BR	MOCMDR			; Go send CMDR frame

;-----
; Here if frame had information field when not allowed to have one
;-----
ERRNIA:	MOVB	#<.CRSNW!.CRSNX>,DDLECR#(R4) ; Set CMDR reasons W and X (bad
					;   cntl byte, info field not allowed)
	BR	MOCMDR			; Go send CMDR frame

;-----
; Here if frame overflowed (too many bytes)
;-----
ERROVF:	MOVB	#.CRSNY,DDLECR#(R4)	; Set CMDR reason Y (overflow)
	BR	MOCMDR			; Go send CMDR frame

;-----
; Here if N(R) (frame receive number) was bad
;-----
ERRINR:	MOVB	#.CRSNZ,DDLECR#(R4)	; Set CMDR reason Z (invalid N(R))
;	BR	MOCMDR			; Go send CMDR frame

;-----
; Here to send a CMDR frame
;-----
MOCMDR:	CLRB	DDLET1#(R4)		; Clear timer T1
	BIC	#$TIMER,DDLEFG#(R4)	; Clear timer recovery flag

	MOVB	DDLEMX#(R4),DDLECX#(R4)	; Save bad control byte
	BIS	#<$CMDR!$ABORT>,DDLEFG#(R4) ; Abort current output frame and
					;   set CoMmanD Reject condition
	MOVB	#.T5,DDLET5#(R4)	; Set command reject condition timer
	MOVB	#.CMDR,DDLEAK#(R4)	; Pending response <-- 1st CMDR

	.SBTTL	STARTO/LKESTO - Start output INTERRUPT SERVICE if idle
;-----
; Here to start output if output is idle
;
; **** WARNING ****
;
; This label MUST be entered with nothing added to the stack - it assumes
; that the return address is on the top of the stack...
;-----
LKESTO::				; Global entry point for STARTO
STARTO:	SETPSW	DDLELV#(R4)		; Raise processor level
	PUSH	(SP)			; Duplicate return addr on stack
	CLR	2(SP)			; Clear PSW on stack

	TST	DDLEOS#(R4)		; Output in progress?
	BEQ	1$			; No - fake an output done interrupt
	RTI				; Yes - let output do it when finished

1$:	PUSH	R4			; Push contents of R4 to simulate what
					;   happens at device interrupt handler
	PUSH	R0			; Push contents of R0 to simulate what
					;   happens at common interrupt handler
	JMP	ONEXTF			; Transfer to output interrupt service
					;   to start output frame
	.SBTTL	Once a second routines (and reset link routine)
;-----
; LKESEC - Once a second entry point
;-----
	ONCSEC	LKESEC

LKESEC:	MOV	#LKEDDB#,R4		; Get base DDB pointer

LKESE1:	TBBN	$D1UNV,DDSTS1#(R4),LKESE2 ; If device not there, check next DDB
	TBBE	$D1DWN,DDSTS1#(R4),1$	; If link UP, CHECK TIMERS
	TBBE	$RESET,DDLEF2#(R4),47$	; If link down & needs reset, do it
					;   after this, timers should do it
;-----
; Here to check IRMA timer for lost output interrupt
;-----
1$:	TBBE	$IRMA,DDLEF2#(R4),2$	; If IRMA clear, maybe lost interrupt

	BIC	#$IRMA,DDLEF2#(R4)	; IRMA bit set - clear it
	BR	3$			; Check next timer
;-----
; IRMA flag clear - non-zero output state means interrupt was lost for 1 sec
;-----
2$:	TST	DDLEOS#(R4)		; Output idle?
	BEQ	3$			; Yes
;-----
; Interrupt lost for 1 second - fake an output done interrupt
;-----
	SETPSW	DDLELV#(R4)		; No - raise to interrupt level
	CLR	-(SP)			; Push clear PSW
	PUSH	#3$			; Push return address
	PUSH	R4			; Simulate what happens at interrupt
	CJMP	LKEOSV			; Go process fake interrupt

;-----
; Check timer T1 (non-response timer)
;-----
3$:	TSTB	DDLET1#(R4)		; Timer T1 set for this link?
	BEQ	4$			; No - check OTHER TIMERS
	DECB	DDLET1#(R4)		; Yes - decrement timer count
	BNE	4$			; If time left, check other timers
;-----
; Timer T1 expired for a link
;-----
	TST	DDLETX#(R4)		; Anyone want to recover this?
	BEQ	4$			; No - check other timers
;-----
; Call one of the timer T1 recovery routines:
;	XXSARM - unacknowledged SARM frame transmitted
;	XXDISC - unacknowledged DISC frame transmitted
;	XXINFO - unacknowledged information frame(s) transmitted
;-----
	CALL	@DDLETX#(R4)		; CALL timer recovery routine

;-----
; Here to check idle input take-down timer
;-----
4$:	TSTB	DDLET6#(R4)		; Timer set?
	BEQ	5$			; No - check next timer
	DECB	DDLET6#(R4)		; Yes - count down
	BEQ	47$			; Reset link if timer expires

;-----
; Check information transfer state timers - start with idle link RR frame timer
;-----
5$:	TBBN	<$RUA!$XUA>,DDLEF2#(R4),LKESE2 ; Check next link if not info
					;   xfr phase
	TSTB	DDLET3#(R4)		; Idle link RR frame timer set?
	BEQ	6$			; No - check next timer
	DECB	DDLET3#(R4)		; Yes - decrement timer count
	BNE	6$			; If still time left, check next timer
	BIS	#$RR,DDLEFG#(R4)	; Set RR frame pending flag
	CALL	STARTO			; Start output if idle
;-----
; Check reject condition timer
;-----
6$:	TSTB	DDLET4#(R4)		; Reject condition timer set?
	BEQ	7$			; No - check next timer
	DECB	DDLET4#(R4)		; Yes - decrement timer count
	BEQ	47$			; Timer expired - reset link
;-----
; Check command reject condition timer
;-----
7$:	TSTB	DDLET5#(R4)		; Command reject condition timer set?
	BEQ	LKESE2			; No - check next link
	DECB	DDLET5#(R4)		; Yes - decrement timer count
	BNE	LKESE2			; If time left, check next link
;-----
; Reset the link and advance to next type E link
;-----
47$:	CALL	LRESET			; Timer expired - reset link

;-----
; Here to get next type E link DDB
;-----
LKESE2:	MOV	DDLKNS#(R4),R4		; Get next type E link DDB
	BNE	LKESE1			; Continue if more links
	RETURN				; Return to once-a-second processing

;-----
; Here to send SARM frame
;-----
MOSARM:	CALL	LKEDWN			; Declare link down
	MOVB	DDLEK2#(R4),DDLEN2#(R4)	; Init retransmission count
	MOV	#URSARM,DDLEUR#(R4)	; UA input wait <-- SARM awaiting UA
	MOV	#XXSARM,DDLETX#(R4)	; Timer expire state <-- sending SARM
	BIS	#$RUA,DDLEF2#(R4)	; Flag this side needs UA to SARM
;-----
; Here to recover if timer T1 expires while waiting for UA after sending SARM
;-----
XXSARM:	DECB	DDLEN2#(R4)		; Bump retransmit count
	BPL	1$			; Haven't sent SARM N2 times yet
	BIS	#$RDISC,DDLEF2#(R4)	; Have sent SARM N2 times - send DISC
	BR	LRESET			; Reset link if transmitted N2 times
1$:	MOVB	#.SARM,DDLECM#(R4)	; Output command pending <-- SARM
	MOVB	DDLEK1#(R4),DDLET1#(R4)	; Set timer T1
	BR	STARTO			; Start output if possible and return

;-----
; Here to send DISC frame
;-----
MODISC:	CALL	LKEDWN			; Declare link down
	MOVB	DDLEK2#(R4),DDLEN2#(R4)	; Init retransmission count
	MOV	#URDISC,DDLEUR#(R4)	; UA input wait <-- DISC awaiting UA
	MOV	#XXDISC,DDLETX#(R4)	; Timer expire state <-- sending DISC
	BIS	#$XUA,DDLEF2#(R4)	; Flag this side needs to send UA for
					;   SARM before info xfr phase
	BIC	#$RUA,DDLEF2#(R4)	; Indicate need SARM output now
;-----
; Here to recover if timer T1 expires while waiting for UA after sending DISC
;-----
XXDISC:	DECB	DDLEN2#(R4)		; Bump retransmit count
	BMI	LRESET			; Reset link if DISC sent N2 times
	MOVB	#.DISC,DDLECM#(R4)	; Output command pending <-- DISC
	MOVB	DDLEK1#(R4),DDLET1#(R4)	; Set timer T1
	CJMP	STARTO			; Start output if possible and return

;-----
; Here to recover if timer T1 expires after sending information frame
;-----
XXINFO:	TSTB	DDLEVT#(R4)		; Anything in ring to retransmit?
	BNE	1$			; Yes - go do it
	INC	DDLEBX#(R4)		; No - bump bad retransmission count
	BIC	#$TIMER,DDLEFG#(R4)	; Clear timer recovery state
	RETURN				; Return to caller

1$:	DECB	DDLEN2#(R4)		; Bump retransmit count
	BLE	LRESET			; Reset link if transmitted N2 times

	BIS	#<$ABORT!$REXMT!$OCPF!$TIMER>,DDLEFG#(R4)
					;   Abort info frame output, retransmit
					;   1st frame on Xmit ring w/ Poll bit,
					;   timer recovery in progress
	INC	DDERRX#(R4)		; Bump retransmission count
	CJMP	STARTO			; Start output if possible and return

;-----
; Here to try to set up (or reset) the link for communication
;-----
LRESET:	BIS	#$RESET,DDLEF2#(R4)	; Flag link has been reset since start
					;   (timers should do the resetting now)
	SETPSW	DDLELV#(R4)		; Raise processor priority level
	CLR	@DDLEXS#(R4)		; Clear transmitter status/control reg

;-----
; Reset device
;-----

.IF	EQ	<..DPV-1>	;USING DPV
	MOV	#TXRES,@DDLEXS#(R4)	;MASTER RESET DEVICE
.IFF
	MOV	#$XMSTR,@DDLEXS#(R4)	; Master reset device
.IFTF
	CLR	DDLEIS#(R4)		; Clear input state while waiting for
					;   device to stabilize after reset
	CLR	DDLEOS#(R4)		; Clear output state
.IFT
	BIS	#TXREN,@DDLEXS(R4)	;ENABLE THE XMITTER
	PUSH	R0
	MOV	DDLEXB#(R4),R0		;GET THE ADDRESS OF TDSR ON DPV
	INC	R0			;POINTS TO UPPER BYTE
	MOVB	#TXSTRM/400,(R0)		;SET SOM TO SENDS
	POP	R0
	MOV	#RXITEN!RXREN!DSRTS!DSDTR,@DDLERS(R4) 
	MOV	DDLEPX#(R4),@DDLEPR#(R4) ;INITIALIZE PCSAR TO ZERO
.IFF
	MOV	DDLEPX#(R4),@DDLEPR#(R4); Initialize device parameter register
	MOV	#.RINIT,@DDLERS#(R4)	; Initialize receiver control/status
	MOV	#.XINIT,@DDLEXS#(R4)	; Init transmitter control/status reg

	TST	DDLEPX#(R4)		; DUP-11 or DU-11/DUV-11?
	BPL	1$			; DU-11/DUV-11

	BIS	#$XSEND,@DDLEXS#(R4)	; Set DUP-11 send bit
	MOV	#<377!$XSMSG>,@DDLEXB#(R4) ; Init DUP-11 to send marks
1$:
	BIS	#$SYNCH,DDLEFG#(R4)	; Set long synch flag
.IFTF
	CLRPSW				; Lower processor priority level
	BIC	#$DISC1,DDLEFG#(R4)	; Clear received 1st DISC flag
	BR	MODISC			; Go send a DISC
.ENDC
	.SBTTL	LKEDWN - Subroutine to declare link down & clean up
;-----
; LKEDWN - Subroutine to reset link sockets (declare link down)
;
; Linkage:
;	C(R4) = Address of DDB
;	CALL	LKEDWN
;
; Unpreserved registers:
;	R0, R2, SD
;-----
LKEDWN::CALL	LNKDWN#			; Declare link down
	BIC	#$D1ACT,DDSTS1#(R4)	; Declare link inactive
	MOVB	DDLEVS#(R4),DDLENR#(R4)	; Reset last N(R) received
	BIC	#<$IBUSY!$REJ!$TIMER!$REXMT!$CMDR>,DDLEFG#(R4) ; Clear flags
	CLRB	DDLET3#(R4)		; Clear idle output RR frame timer
	CLRB	DDLET4#(R4)		; Clear reject condition timer
	CLRB	DDLET5#(R4)		; Clear command reject condition timer
	CLRB	DDLET6#(R4)		; Clear idle input take-down timer

	MOV	DDSX#(R4),R0		; Get 1st SX table entry addr
	TST	-(R0)			; Point to wild socket

	CLR	R2			;
	BISB	DDSOC#(R4),R2		; GET NUMBER OF SOCKET
	INC	R2			; PLUS THE WILD SOCKET

1$:	MOV	(R0)+,SD		; Get SDB address
	CLR	SDLES1#(SD)		; Clear packet level status word
	CLRB	SDLEVR#(SD)		; Clear last P(R) received for socket
	CLRB	SDLEPR#(SD)		; Clear P(R) for socket
	CLRB	SDLEPS#(SD)		; Clear P(S) for socket
	CLRB	SDACNT#(SD)		; Clear send ahead count for socket
	CLRB	SDFCNT#(SD)		; Clear flag count (# RR pkts pending)
	CLRB	SDLERR#(SD)		; Clear pending RR pkt count
	MOV	SDLESP#(SD),R1		; GET ADDRESS OF SAVED PACKETS
	BEQ	99$			; BRANCH IF THERE ISN'T ANY
	CALL	X25FRE#			; FREE THE PACKETS OTHERWISE
99$:
	SOB	R2,1$			; Continue until all sockets reset

	TSTB	DDLEVT#(R4)		; Anything left in transmit ring?
	BEQ	6$			; No - check send back list

	SETPSW	DDLELV#(R4)		; Raise processor priority level
	MOV	DDLELH#(R4),R0		; Get Xmit ring head pointer

2$:	MOV	(R0),R1			; Get frame packet list pointer
	BEQ	4$			; No packets on list (shouldn't happen)

3$:	PUSH	(R1)			; Store forward packet link
	FREPKT				; Free the packet
	POP	R1			; Retrieve forward pointer
	BNE	3$			; Continue until all packets freed

4$:	CLR	(R0)+			; Clear packet list head pointer
	CMP	R0,DDLELE#(R4)		; End of ring?
	BLO	5$			; No
	MOV	DDLELB#(R4),R0		; Yes - reset ring pointer
5$:	CMP	R0,DDLELT#(R4)		; Freed all lists from xmit ring?
	BNE	2$			; No - continue until all lists freed

	CLRB	DDLEVT#(R4)		; Clear transmit ring frame counter
	CLRB	DDLET1#(R4)		; Clear timer (can't retransmit if link
					;   down & nothing in ring)
	MOV	R0,DDLELH#(R4)		; Update head pointer
	MOV	R0,DDLELN#(R4)		; Update next-to-send pointer
	BIS	#$ABORT,DDLEFG#(R4)	; Abort output frame is sending one
	CLRPSW				; Lower processor priority level

6$:	MOV	DDLEAH#(R4),R1		; Get send back list head
	BEQ	8$			; Bypass if nothing there

7$:	PUSH	(R1)			; Save forward packet link
	FREPKT				; Free the packet
	POP	R1			; Retrieve forward packet link
	BNE	7$			; Continue until list freed

	CLR	DDLEAH#(R4)		; Clear send back list head
	CLR	DDLEAT#(R4)		; Clear send back list tail

8$:	RETURN				; Return to caller

LKELOD:: SEC				;we don'T know how to load
	RETURN

	.END
   eN}H