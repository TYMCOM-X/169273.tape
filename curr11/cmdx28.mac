
 	.TITLE	CMDX28 - X.28 PAD COMMAND DECODER ROUTINES
 
	.SBTTL	CMDX28 - Tymshare

	XLPAR				;DON'T LIST PARAMETER FILE

	CODE

;DEFINE MACRO FOR INLINE MESSAGES

	.MACRO	INLMES  MES
	CALL	INLOUT#
	.ASCIZ	MES
	.EVEN
	.ENDM

;GENERATE COMMAND DECODER ENTRY TABLE

	PURE

X28ENT::.WORD	X28CMD		;.CXCMD =  0 - ENTER COMMAND LEVEL
	.WORD	X28ESC		;.CXCIN =  2 - COMMAND INTERRUPT
	.WORD	X28ECL		;.CXECL =  4 - END OF COMMAND LINE
	.WORD	X28RST		;.CXRST =  6 - RESET COMMAND DECODER
	.WORD	X28ACK		;.CXACK = 10 - CONNECT ACK PACKET
	.WORD	X28NAK		;.CXNAK = 12 - CONNECT NAK PACKET
	.WORD	X28DIS		;.CXDIS = 14 - DISCONNECT PACKET
	.WORD	X28DAK		;.CXDAK = 16 - DISCONNECT ACK PACKET

	CODE
	.PAGE
;HERE TO ENTER NETWORK COMMAND LEVEL
;	ENTRY INDEX = .CXCMD

X28CMD:	CALL	WATIDL#			;MAKE SURE OUTPUT IS IDLE
	MOVB	#100,SDTRBS#(SD)	;FORCE COMMAND MODE BREAK SET
	BIS	#$T1CMD,SDTRS1#(SD)	;Indicate command mode
	TBBN	$T3TRM,SDTRS3#(SD),CMDM52;SHOULD WE ASK HIM FOR HIS TERMINAL
					 ;  TYPE NOW?
CMDMO1:	TSTB	SDSTS1#(SD)		;CONNECTED NOW?
	BNE	CMDMO3			;YES
	TBBN	$T3ACA,SDTRS3#(SD),CMDMO3;NO-HAVE WE ATTEMPTED TO CONNECT YET?
	BIS	#$T3ACA,SDTRS3#(SD)	;NO-BUT WE HAVE NOW!

;HERE IF WANT TO START AUTO-CONNECT SEQUENCE NOW

CMDATO:	MOVB	SDTRS0#+1(SD),R0	;DO WE HAVE A HOST CONNECT LIST?
	BIC	#^C<$T0HCL/400>,R0
	BEQ	CMDMO3			;NO-GO ON
	JMP	ATOCON			;YES-GO TRY TO CONNECT

;HERE IF REALLY WANT TO STAY AT NETWORK COMMAND LEVEL

CMDMO3:	TBBN	$T0CMD,SDTRS0#(SD),2$	;Can we be at command level?
	JMP	X28HNG			;No-he looses!

;Here if network command is allowed for this terminal

2$:	INLMES	<<CR><LF>"PAD Command Level (">
	MOV	#THSNOD#,R1		;GET ADDRESS OF NODE NAME
	CALL	OUTSTR#			;TYPE IT
	INLMES	<"-">
	MOVB	SDSOC#(SD),R1		;GET SOCKET NUMBER OF THIS TERMINAL
	CALL	OUTDEC#			;TYPE IT
	INLMES	<")"<CR><LF>>		;END THE LINE
CMDMO4:
;	BIC	#$T1SOP,SDTRS1#(SD)	;CLEAR OUTPUT SUPPRESS FLAG
	TBBN	$T1CMD,SDTRS1#(SD),CMDMO5;GO ON IF STAYING IN COMMAND MODE
	MOV	#OUTGET#,SDTROD#(SD)	;LEAVING COMMAND MODE-RESET OUTPUT DONE
					;  DISPATH ADDRESS
	MOVB	SDTRBX#(SD),SDTRBS#(SD)	;RESTORE BREAK SET
	JMP	OUTGET#			;AND LEAVE!

;HERE IF STAYING IN COMMAND MODE

CMDMO5:	TBBN	$T3TRM,SDTRS3#(SD),CMDM52 ;SHOULD WE ASK FOR THE TERMINAL TYPE?
CMDM51:
	INLMES	<<CR><LF>"!">		;NO-TYPE THE NORMAL PROMPT
	CLR	SDTRC4#(SD)		;clear NAK reason if any--us701
	BIS	#$T1TLG,SDTRS1#(SD)	;enable login mode(x.28)
	BR	CMDMO6			;CONTINUE

CMDM52:	INLMES	<<CR><LF>"Terminal = ">	;YES-TYPE SPECIAL PROMPT
CMDMO6:	BIC	#$T3ECL,SDTRS3#(SD)
	TST	SDTRCP#(SD)		;ANY COMMANDS READY NOW?
	BNE	CMDBR0			;YES-GO PROCESS ONE
	BIS	#$T6CMW,SDTRS6#(SD)	;NO-INDICATE READY FOR COMMAND NOW
CMDMO7:	MOV	#INPGET#,SDTROD#(SD)	;RESET OUTPUT DISPATCH VECTOR
	TBBE	$T4SEL,SDTRS4#(SD),2$	;2741 TERMINAL?
	JMP	ENBKEY#			;YES-GO ENABLE ITS KEYBOARD

2$:	JMP	INPGET#			;NO-THATS ALL
	.PAGE
;
; HERE ON PAD RECALL CHARACTER
;	ENTRY INDEX = .CXCIN
X28ESC:
	CALL	WATIDL#			;
	MOVB	#100,SDTRBS#(SD)	;USE TOPS-10 BREAK SET
	BIS	#$T1CMD,SDTRS1#(SD)	;IN CMD MODE NOW
	TBBN	$T0CMD,SDTRS0#(SD),CMDM51 ;ALLOWED IN CMD MODE? BRANCH IF YES.
	JMP	X28HNG			; NOT ALLOWED,
	.PAGE
;HERE ON END OF LINE WHEN IN COMMAND MODE
;	ENTRY INDEX = .CXECL
; ENTER HERE FROM (TRMP)SNDTRP

X28ECL:	BIC	#$T3ECL,SDTRS3#(SD)	;INDICATE NOT END OF LINE
	TBBN	$T6PND,SDTRS6#(SD),EATLI1;Ignore if handshake is pending!
	TBBE	$T6CMW,SDTRS6#(SD),RTN003;FORGET IT IF NOT EXPECTING COMMAND
;	BIC	#$T1SOP,SDTRS1#(SD);CLEAR SOME BITS
	BIC	#$T6CMW,SDTRS6#(SD)
CMDBR0:	CALL	WATIDL#			;MAKE SURE OUTPUT IS IDLE
	BIC	#$T1ACT!$T1ACX,SDTRS1#(SD)
CMDBR1:	TBBE	$T3TRM,SDTRS3#(SD),2$	;ARE WE ASKING FOR TERMINAL TYPE?
	JMP	X28TRM			;YES

2$:	CALL	GETATM			;NO-GET COMMAND ATOM
	TST	R2			;NULL ATOM?
	BNE	4$			;NO-GO ON
; WAS
;	TST	R0			;YES-NULL LINE?
;	BNE	SYNERR			;NO-ERROR
;	BR	CMDMO4			;YES-IGNORE IT
; 
	CMPB	R0,#LF			;YES, NULL LINE?
	BNE	SYNERR			;    NO, ERROR. START WITH FUNNY CHAR.
	TST	(SD)			;    YES, CONNECTED/BEING CONNECTED?
	BEQ	CMDMO4			;	NO, STAY IN CMD MODE
	JMP	CMDAC3			;	YES, RETURN TO DATA XFER MODE

;HERE IF NOT NULL ATOM

4$:	MOV	#CMDTBX#,R1		;INDEX FOR COMMAND TABLE
6$:	CMP	R2,CMDTB1#-2(R1)	;THIS ONE?
	BEQ	CMDBR6			;IF MATCH
10$:	DEC	R1			;STEP TO NEXT ENTRY
	SOB	R1,6$			;CONTINUE IF MORE TO CHECK
; WAS
;	INLMES	<"? No such command"<CR><LF>>
	JMP	X28TPM			;GO CHECK IF ATOM IS ONE OF TERM. PAR.
CMDSTP:				;come here if command stops halfway
CMDBR5:	CALL	EATLIN			;Eat rest of command line
	BR	CMDMO4

;HERE WITH MATCH ON COMMAND ATOM
;
;CMDHAV:	TST	R0			;END OF LINE?
;	BEQ	CMDBR6			;YES-OK
;	CMP	#SPA,R0			;NO-SPACE?
;	BEQ	CMDBR6			;YES-THATS OK TOO
;					;NO-FALL INTO SYNTAX ERROR ROUTINE
EATLI1: JMP	EATLIN
RTN003:	RETURN

;HERE ON SYNTAX ERROR IN COMMAND

SYNERR:	INLMES	<"? Syntax error"<CR><LF>>
	BR	CMDBR5

;HERE IF ATOM TERMINATED CORRECTLY

CMDBR6:	JMP	@CMDTBD#-2(R1)		;DISPATCH TO COMMAND ROUTINE
	.PAGE
	.SBTTL	X28CON - Connect command processing

;HERE FOR CONNECT COMMAND FROM TERMINAL

X28CAL::TST	(SD)			;ARE WE ALREADY CONNECTED?
	BEQ	2$			;NO-GO ON
	INLMES	<"? Already connected"<CR><LF>>
	BR	CMDBR5			;FAIL
2$:
	MOV	#S#,R2		;temp storage
	MOV	#40,R0		;40 words
60$:	CLR	(R2)+		;initial them to zero
	SOB	R0,60$		;

	CALL	EATBLK#		;get first non-blank char from command line
	MOV	#PKDATA+10.,R2 ;make R2 point to a random harmless place
	ADD	#S#,R2		;to store facilities temporily
;+--US801
	CMPB	#100,R0		;IS IT AN ALPHABET?
	BHI	CALADR		;NO, GO SEE IF IT IS ADDRESS.
	INCB	PKDATA+9.+S#	;got facility, count yourself as total-fac-len
FACNXT:				;next facility
	CMPB	#100,R0		;IS IT AN ALPHABET?
	BHI	BADFAC		;HI, no, complain about it
	BIC	#177740,R0	;YES, CAPITALIZE AND INDEX
	ASL	R0		;WORD INDEX
	JMP	@FACDSP(R0)	;DISPATCH BY FACILITY INDEX

;DISPATCH TABLE FOR FACILITY CODES
	PURE
FACDSP:	.WORD	BADFAC		;@,\
	.WORD	BADFAC		;A
	.WORD	BADFAC		;B - Bilateral CUG
	.WORD	BADFAC		;C - Charging information
	.WORD	BADFAC		;D - Throughput class negotiation
	.WORD	BADFAC		;E - 
	.WORD	BADFAC		;F - Fast select
	.WORD	FACCUG		;G - Closed user group(CUG)
	.WORD	BADFAC		;H - 
	.WORD	BADFAC		;I - 
	.WORD	BADFAC		;J - 
	.WORD	BADFAC		;K - 
	.WORD	BADFAC		;L - 
	.WORD	BADFAC		;M - Called line address modified note
	.WORD	FACNUI		;N - Network user identification(NUI)
	.WORD	FACOGO		;O - CUG with outgoing access
	.WORD	BADFAC		;P - Packet size negotiation
	.WORD	BADFAC		;Q - 
	.WORD	FACREV		;R - Reverse charging
	.WORD	BADFAC		;S - Called DTE reselection
	.WORD	BADFAC		;T - RPOA transit network selection
	.WORD	BADFAC		;U - Call redirection notification
	.WORD	BADFAC		;V - 
	.WORD	BADFAC		;W - Window size negotiation
	.WORD	BADFAC		;X
	.WORD	BADFAC		;Y
	.WORD	BADFAC		;Z
	.WORD	BADFAC		;[{
	.WORD	BADFAC		;\:
	.WORD	BADFAC		;]}
	.WORD	BADFAC		;36~
	.WORD	BADFAC		;37DEL
	CODE
BADFAC:				;HERE FOR BAD FACILITY CODE
	INLMES	<"? Bad Facility Code"<CR><LF>>
	JMP	CMDSTP
	IMPURE
NUILGP:	.WORD	0	;NUI length address, actually could be used for
			; any facility with multiple length
	CODE
SYNE32:	JMP	SYNE22		;restore stack then syntax error process
FACNUI:
	MOVB	#^HC6,(R2)+	;NUI facility code and zil length for now
;	INCB	PKDATA+9.+S#	;count in NUI code
	MOV	R2,NUILGP	;save length's address in NUILGP
	TSTB	(R2)+		;adjust the pointer
	INCB	PKDATA+9.+S#	;count in NUI length
80$:	PUSH	R2		;save R2, since GETCMC will destroy R2
	CALL	GETCMC#		;get a byte from command line to R0
	  BR	SYNE32		; if EOL, no address, error
	POP	R2		;if got a char
	CMPB	#'-,R0		;end of facilities?
	BEQ	FACEND		;eq, yes
	CMPB	#',,R0		;add any facility here
	BEQ	FACOMA		;EQ, go prepare for next facility
	MOVB	R0,(R2)+	;store a byte of NUI string
	INCB	PKDATA+9.+S#	;one more for total facility length
	INCB	@NUILGP		;also increment NUI length
	BR	80$		;continue
;here for a comma in facility string
FACOMA:	PUSH	R2		;save R2
	CALL	GETCMC#		;get next char
	  BR	SYNE32		;if error
	POP	R2		;restore R2 as facility pointer
	BR	FACNXT		;go process next facility

SYNE2N:	JMP	SYNERN		;go complain no address
SYNE2A:	JMP	SYNERA
SYNE2B:	JMP	SYNERB

;HERE IF DISCONNECTED OR OUT OF RESOURCES - HANG HIM UP!
RETMS1:	POP	R1
	FREPKT
RETMSG:	INLMES	<<CR><LF>"no path available...disconnecting">
HANGSH:	CJMP	HUNGUP#			;CLEAN UP AFTER HIM

;here if '-' found, end-of-facilities, next must be address
FACEND:	CALL	GETCMC#		;get next char
	  BR	SYNE2N		;address is mandatory
;	BR	CALADR		;got one, should be address

CALADR:		;HERE FOR CALLED ADDRESS
100$:	MOV	#S#,R2		;R2 is address pointer now
	ADD	#PKDATA+1,R2	;
	CLR	FLG		;Initial flag to higher nibble first
	CALL	GETBT		;R0=Nibble(R0) if R0='0'..'9'
	BCS	SYNE2N		;CS, no,, at least should have one

110$:	CALL	PUTNIB		;store R0 to area pointed by R2
	INCB	PKSEQ+S#	;count one more address digit
	CMPB	#14.,PKSEQ+S#	;shall not exceed 14.
	BLT	SYNE2A		;LT, error
	PUSH	R2		;
	CALL	GETCMC#		;get next char
	  BR	140$		;EOL, go move NUI and send it to LKEPKT
	POP	R2		;
	CALL	GETBT		;pack R0 if it Is a digit
	BCC	110$		;CC, yes, go pack it and save
	CMPB	#'*,R0		;Does CUD follow right after address?
	BNE	SYNE2B		;NE, complain about it
;CALCUD:
115$:
	CALL	XMVNUI		;move NUI to where it should be
				;it should follow right after address
	MOVB	#1,(R2)+	;first 4 bytes are CUD protocol ID
	CLRB	(R2)+		;
	CLRB	(R2)+		;
	CLRB	(R2)+		;
	PUSH	12.		;max byte count for CUD
120$:	PUSH	R2		;save pointer of CUD
	CALL	GETCMC#		;get next char
	  BR	130$		;EOL, go send this packet
				; even null CUD
	POP	R2
	MOVB	R0,(R2)+	;store a byte
	DEC	(SP)		;
	BNE	120$		;continue until EOL or exceeding limit
	JMP	SYNE2C		;
130$:	POP	R2		;EOL terminates CUD
	TST	(SP)+		;
	BR	190$		;
;here for address without CUD follows
140$:	POP	R2		;EOL terminates Address, restore R2
	BR	115$		;go put on our identifier as CUD

; Here a good X.25 call command
190$:	MAKPKT	.PLOPT#			;GET A PACKET
	BCS	RETMSG			;TELL THE USER TO HANG ON
	PUSH	R1			;save for connect pk
	MAKPKT	.PLOPT#			;GET Another PACKET
	BCS	RETMS1			;TELL THE USER TO HANG ON
	MOV	R1,SDTRC5#(SD)	;save this function pk for X28ACK
	MOVB	#.PTFUN,PKTYPE(R1)	;This will be a function pk
	SUB	#S#,R2		;calculate the data size
	SUB	#PKDATA,R2	;
	MOVB	R2,PKCNT(R1)	; and store it
	MOVB	#.FNX51,PKDATA+S#	;function = call req
	MOV	#S#,R2		;
	ADD	#4,R2		;start from data area-2(packet type
				; of X.25 call request, with first 
				; 2 bytes different)
	ADD	#4,R1		;start from data area-2
	MOV	#36,R0		;
79$:	MOV	(R2)+,(R1)+	;copy storage to pk
	SOB	R0,79$		;

	POP	R1		;get second pk
	MOV	R1,R2			;CLEAR THE PACKET
	MOV	#24,R0
14$:	CLR	(R2)+
	SOB	R0,14$
	MOV	#.PTCON*400+37,PKCNT(R1);SETUP THE CONNECT PACKET
	MOV	#13*400+200,PKDATA(R1)	;say we got terminal profile
	MOVB	#P.X28+1,PKDATA+36(R1)	;and it is X28, PAD
	MOVB	#.IDTR#,PKDATA+14(R1)	;Our device ID
;	MOVB	#3,PKDATA+31(R1)	;Setup warning value
	MOVB	#2,PKDATA+31(R1)	;Setup warning value, default packet
					; window size is 2
	MOVB	SDSOC#(SD),PKDATA+5(R1)	;Our socket no.
	MOV	#"31,PKDATA+6(R1)	;'31080' shall map to Link-E
	MOV	#"08,PKDATA+10(R1)	;
	MOV	#'0,PKDATA+12(R1)	;
	INCB	SDPCNT#(SD)		;BUMP PACKET COUNT
	CJMP	SNDPKT#			;AND SEND THE CONNECT PACKET

FACCUG:	MOVB	#^H03,(R2)+	;facility code = CUG
	BR	FACOG1
FACOGO:
	MOVB	#^H09,(R2)+	;facility code = CUG with outgoing access
FACOG1:;	INCB	PKDATA+9.+S#	;count CUG-fac-code
	INCB	PKDATA+9.+S#	;count CUG-parameter
	CLR	FLG
80$:	PUSH	R2		;save R2, since GETCMC will destroy R2
	CALL	GETCMC#		;get a byte from command line to R0
	  BR	SYNE22		; if EOL, no address, error
	POP	R2		;if got a char
	CMPB	#'-,R0		;end of facilities?
	BEQ	FACEN2		;eq, yes
	CMPB	#',,R0		;add any facility here
	BEQ	FACOM2		;EQ, go prepare for next facility
	CALL	GETBT		;convert R0 to a nibble
	BCS	SYNERG		;if error
	CALL	PUTNIB
	BR	80$		;continue

FACREV:	MOVB	#^H01,(R2)+	;facility code = reverse charge
;	INCB	PKDATA+9.+S#	;count fac-code
	MOVB	#^H01,(R2)+	;facility parameter = reverse charge
	INCB	PKDATA+9.+S#	;count fac-parameter
80$:	PUSH	R2		;save R2, since GETCMC will destroy R2
	CALL	GETCMC#		;get a byte from command line to R0
	  BR	SYNE22		; if EOL, no address, error
	POP	R2		;if got a char
	CMPB	#'-,R0		;end of facilities?
	BEQ	FACEN2		;eq, yes
	CMPB	#',,R0		;add any facility here
	BEQ	FACOM2		;EQ, go prepare for next facility
	JMP	FACNXT		;go process next facility

FACEN2:	JMP	FACEND
FACOM2:	JMP	FACOMA
SYNE22:	TST	(SP)+		;restore stack
SYNER2:
SYNERN:	INLMES	<"? No address specified"<CR><LF>>
CMDST1:	JMP	CMDSTP		;and stop this command

SYNERA:	INLMES	<"? Address too long"<CR><LF>>
	BR	CMDST1		;command stops halfway
SYNERB:	INLMES	<"? Bad address terminator"<CR><LF>>
	BR	CMDST1		;command stops halfway
SYNE2C:	TST	(SP)+
	INLMES	<"? CUD too long"<CR><LF>>
	BR	CMDST1		;command stops halfway
SYNERG:	INLMES	<"? Bad CUG parameter"<CR><LF>>
	BR	CMDST1		;command stops halfway
;---us701

	CLR	SDTRC4#(SD)		;INDICATE NOT AUTO-CONNECT
CMDCN2:	CLR	R0			;GET FLAG BITS
	CALL	CMDCON#			;CALL COMMON SUBROUTINE FOR CONNECT (CMDS)
	ADD	R1,PC			;DISPATCH ON THE RETURN INDEX
	 BR	SYN1RR			; IF SYNTAX ERROR
	 BR	BADDEV			; IF BAD DEVICE NAME
	 BR	NOSP2C			; IF NO PACKET AVAILABLE
	 BR	ATOCON			; IF NULL ARGUMENT
EATLIN:	CALL	GETCMC#			;Eat the rest of the line
RTN002:	  RETURN			;If end of line
	BR	EATLIN			;Continue if more there

;HERE IF BAD DEVICE NAME GIVEN

BADDEV:	INLMES	<"? No such device"<CR><LF>>
	JMP	CMDBR5
SYN1RR:	JMP	SYNERR

;HERE IF NO PACKET WAS AVAILABLE

NOSP2C:	JMP	NOSPAC
	.PAGE
	.SBTTL	ATOCON - Process auto-connect sequence

;HERE TO START AUTO-CONNECT SEQUENCE

ATOCON:	MOV	HCLTBL#-2(R0),SDTRC4#(SD);POINT TO START OF LIST

;HERE TO CONTINUE AUTO-CONNECT SEQUENCE AFTER FAILURE

ATOCN2:	TSTB	@SDTRC4#(SD)		;ANY MORE?
	BNE	CMDCN2			;YES-CONTINUE
					;NO-TELL HIM ABOUT IT
	INLMES	<<CR><LF>"? Cannot connect to host system"<CR><LF>>
	JMP	CMDNK8			;Continue
	.PAGE
	.SBTTL	X28RST - RESET COMMAND DECODER ENTRY

;HERE TO RESET COMMAND DECODER
;	ENTRY INDEX = .CXRST

X28RST:	MOV	#HUNGUP,R1		;CLEAR POSSIBLE TIMER
	CJMP	TIMKIL#			;AND RETURN
	.PAGE
	.SBTTL	X28ACK - Process Connect ACK packet

;HERE FOR CONNECT ACK PACKET
;	ENTRY INDEX = .CXACK

X28ACK:
	MOV	SDTRC5#(SD),R1	;get call req function pk	
	CLR	SDTRC5#(SD)	;clean it
	INCB	SDPCNT#(SD)	;count this pk as ours
	JMP	SNDPKT#		;send it to LKEPKT
			; and wait for .FNX47 then leave command mode

; subroutine XMVNUI moves all facilities from S#+PKDATA+9. to follow
; Address field
;  R2 contains address right next to address field
;  FLG flags odd address length if FLG is odd
;  S#+PKSEQ contains the length of address field
;  S#+PKDATA+9. contains total-facility-length, and followed by
;   facilities, one by one
;  CALL XMVNUI
;  facility field will follow right after Address field and
;  R2 points to next available address
XMVNUI:		;move NUi to where it shall belong
	TBBE	1,FLG,10$	;branch if even number of nible(address)
	TSTB	(R2)+		;pad a zero nibble and update R2
10$:
	MOV	#PKDATA+9.,R3	;R3 points to temp total-facility-length
	ADD	#S#,R3		;
	MOVB	(R3),R0		;no facility string?
	BEQ	90$		;EQ, no facility field
; here we move all facilities(pointed by R3) to empty place right after
; address field(pointed by R2)
	DEC	R3		;just to let next loop work
20$:	CLRB	(R3)+		;clear previous byte and point to current
	MOVB	(R3),(R2)+	;move one byte 
	BNE	20$		;until done
	DEC	R2		;count R2 back to point to next available
	RETURN
90$:	CLRB	(R2)+		;null NUI then zero fac-length
	RETURN
	IMPURE
FLG:	.word	0
	CODE
GETBT:		;R0 = a byte from command line
		;call GETBT
		;CS, R0 is not a digit
		;CC, R0 = nibble
	CMP	R0,#'0
	BLO	10$
	CMP	R0,#'9
	BHI	10$
	BIC	#60,R0		;make it a nibble
	CLC
	BR	20$
10$:	SEC
20$:	RETURN

PUTNIB:		;put a nibble in R0 to area pointed by R2
	TBBN	1,FLG,10$	;branch if lower nibble
	ASHI	4,R0		;shift left 4 for higher nibble
	BISB	R0,(R2)		;store nibble w/o update pointer
	BR	20$		;
10$:	BISB	R0,(R2)+	;store nibble and update pointer
20$:	INC	FLG		;toggle the flag
	RETURN
;---us701
	TBBN	$T0SIM,SDTRS0#(SD),CMDAC3;SHOULD WE TYPE THIS MESSAGE?

;	INLMES	<"Connected to socket ">;YES
;	MOV	SDTRC4#(SD),R1		;GET SOCKET NUMBER
;	BEQ	2$			;IF NO SOCKET NUMBER GIVEN!
;	CALL	OUTDEC#			;OUTPUT AS DECIMAL VALUE
	INLMES	<"Connected ">		;YES
	BR	CMDAC3			;CONTINUE

;HERE IF NO SOCKET NUMBER GIVEN IN THE ACK PACKET

2$:	INLMES	<"???">
CMDAC3:	BIC	#$T1CMD!$T1ECM,SDTRS1#(SD);LEAVE COMMAND MODE
	MOVB	SDTRBX#(SD),SDTRBS#(SD)	;MAKE CURRENT BREAK SET THE ACTIVE
					;  BREAK SET
	CALL	ENDLIN#
	JMP	CMDBR5			;CONTINUE
	.PAGE
	.SBTTL	X28NAK - Process Connect NAK packet

;HERE FOR CONNECT NAK PACKET
;	ENTRY INDEX = .CXNAK

X28NAK:	TST	SDTRC4#(SD)		;ARE WE USING A HOST CONNECT LIST?
	BEQ	2$			;NO-GO ON
	CALL	JNKCPX#			;YES-JUNK THE NAK PACKET
	JMP	ATOCN2			;AND CONTINUE WITH THE HOST CONNECT LIST

2$:	BIC	#$S1HLD,SDSTS1#(SD)	;DON'T HOLD OUTPUT NOW
	BIC	#$T3RDC,SDTRS3#(SD)	;INDICATE THIS IS NOT A DISCONNECT!
	TBBN	$T0SFM,SDTRS0#(SD),CMDNK6;If no message wanted
	INLMES	<"? Cannot connect - ">
CMDNK0:	CALL	GETCTL#			;GET REASON FOR FAILURE
	BCS	CMDNK2			;THERE SHOULD BE ONE!
	MOV	R0,SDTRC4#(SD)		;SAVE CODE
CMDNK1:
;	INLMES	<"Reason = ">
;	MOV	SDTRC4#(SD),R1		;RESTORE CODE
;	CALL	OUTDEC#			;TYPE THE VALUE OF THE CODE
;	INLMES	<": ">
	MOV	SDTRC4#(SD),R0		;GET CODE FOR THE LAST TIME!
	ASL	R0			;FOR WORD INDEXING
	CMP	#CONERX#,R0		;DO WE HAVE A MESSAGE FOR THIS ONE?
	BHI	2$			;YES-GO ON
	CLR	R0			;No-just type some question marks!
2$:	MOV	CONERM#(R0),R1		;GET ADDRESS OF MESSAGE
	CALL	OUTSTR#			;TYPE IT
CMDNK2:
;	INLMES	<" (">
	INLMES	<" ">
CMDNK3:	CALL	GETCTL#			;GET NODE NAME WHERE ERROR OCCURED
	BCS	CMDNK5			;IF FINISHED
	TSTB	R0			;End of link name?
	BEQ	10$			;EQ, yes, next shall be diagnostic
;	CALL	OUTCH0			;OUTPUT CHARACTER
	BR	CMDNK3			;CONTINUE
10$:	CALL	GETCTL#			;Get diagnostic code of CLEAR IND
	BCS	CMDNK5			;If finished
	CLR	R1			;
	BISB	R0,R1			;R1 contains diagnostic now
	CALL	OUTDEC#			;output diagnostic in decimal

;HERE AFTER OUTPUTING NA NODE WHICH REPORTED THE PROBLEM

CMDNK5:
;	INLMES	<")"<CR><LF>>
	INLMES	<<CR><LF>>
CMDNK6:	CALL	JNKCPX#			;GIVE UP THE NAK OR DISCONNECT PACKET
	TBBE	$T3RDC,SDTRS3#(SD),CMDNK8;Go on if not here due to disconnect
	MOV	#.PTDAK,R0		;Get a Disconnect ACK packet
	CALL	CTLPKX#
	BCS	1$			;We tried!
	CALL	SNDPKT#			;Send the packet
1$:	TBBN	$S1BC2,SDSTS1#(SD),X28HNG;Always hang him up if he was connected
					 ;  to
	TBBE	$T0ACD,SDTRS0#(SD),CMDNK8;Does he want auto-connect here?
	MOV	SDTRC4#(SD),R0		;Yes-get reason for the disconnect
	CALL	CHKREA			;Was it a normal disconnect?
	  BR	CMDNK9			;No-try again!
CMDNK8:	TBBE	$T0CMX,SDTRS0#(SD),X28HNG;Yes-should he stay at command level?
	JMP	X28CMD			;Yes

	.SBTTL	X28HNG - RELEASE COMMAND PROCESSING

;HERE FOR RELEASE COMMAND

X28HNG::MOV	#JIFO2#,R0		;DELAY A HALF SECOND
	MOV	#HUNGUP#,R1		;AND THEN HANG HIM UP
	CJMP	TIMREQ#

CMDNK9:	JMP	CMDATO
	.PAGE
	.SBTTL	X28DIS - Process Disconnect and Kill packets

;Here for Disconnect or Kill connection packet after initial processing in CMDS
;	Entry index = .CXDIS

X28DIS:
;----- add the following line to make the clear reason come out right
	BIS	#$T1CMD,SDTRS1#(SD)	;CONSIDER IT IS IN COMMAND MODE NOW!
;-----
	BIS	#$T3RDC,SDTRS3#(SD)	;INDICATE HAVE RECEIVED DISCONNECT
	TBBN	$T0SFM,SDTRS0#(SD),CMDNK6;Should we type a message?
	CALL	GETCTL#			;Maybe-get reason
	BCS	CMDNK2			;There should be one!
	CALL	CHKREA			;Check the reason
	  BR	10$			;Abnormal reason-always print message
	TBBN	$T0SIM,SDTRS0#(SD),CMDNK6;Does he want "informative" messages?
10$:	MOV	R0,SDTRC4#(SD)		;Yes-save error code
;	INLMES	<<CR><LF><CR><LF>"*** Cleared *** ">
	INLMES	<<CR><LF>"CLR ">	;Clear indication
	CALL	RSTTRM			; SEE BELOW
	BR	CMDNK1			;CONTINUE WITH COMMON CODE

;-----
; RSTTRM - RESET TERMINAL PROFILE AND PARAMETERS
;-----
RSTTRM:
	BIC	#$S1HLD,SDSTS1#(SD)	;MAKE SURE OUTPUT HOLD FLAG IS CLEARED
	BIS	#<$T1ECH!$T1HIA!$T1DEX>,SDTRS1#(SD) ;
	BIC	#<$T1IMI!$T1IMO!$T1SOP!$T1DEA!$T1DEM>,SDTRS1#(SD)
	BIC	#<$T6RBF!$T6GBF!$T6BOF>,SDTRS6#(SD)
	BIC	#$T1XXX,SDTRS1#(SD)	;--us701

	RETURN
;-----
	.SBTTL	X28DAK - Process Disconnect ACK packet

;HERE FOR DISCONNECT ACK PACKET
;	ENTRY INDEX = .CXDAK

X28DAK:
	BIC	#$T1XXX,SDTRS1#(SD)	;--us701
	INLMES	<<CR><LF>"CLR CONF"<CR><LF>>
CMDDA2:	CALL	JNKCPX#			;GIVE UP THE PACKET
	JMP	CMDBR5			;CONTINUE
	.PAGE
	.SBTTL	X28CLR - Clear command processing

X28CLR::TST	(SD)			;CONNECTED NOW?
	BNE	CMDDC1			;YES-GO ON
CMDDC0:	INLMES	<"? Not connected"<CR><LF>>
	JMP	CMDBR5

;HERE IF HAVE A CONNECTION NOW

CMDDC1:	BIC	#$T1XXX,SDTRS1#(SD)	;--us701
	CALL	MAKDSC#			;DISCONNECT
	BCS	NOSPAC			;IF CAN'T GET A PACKET
	RETURN

;HERE IF CAN'T MAKE PACKET

NOSPAC:	BIC	#$T6PND,SDTRS6#(SD)	;CLEAR BIT
	BIS	#$T1CMD!$T1ECM,SDTRS1#(SD);MAKE SURE STAY IN COMMAND MODE
	MOVB	#100,SDTRBS#(SD)
	INLMES	<"? Buffer space full"<CR><LF>>
	JMP	CMDBR5
;	.PAGE
;	.SBTTL	X28RSM - Resume command processing

;X28RSM::TST	(SD)			;CONNECTED NOW?
	BEQ	CMDDC0			;NO-ERROR
	MOV	#.PTINT,R0		;YES-MAKE INTERRUPT PACKET
	CALL	CTLPKT#
	BCS	NOSPAC			;IF NO SPACE!
	MOV	#.FNOPA,R0		;FUNCTION = OUTPUT ALLOW
	CALL	CTLSTE#			;STORE FUNCTION AND SEND PACKET
	JMP	CMDAC3			;GO LEAVE COMMAND MODE
	.PAGE
	.SBTTL	X28TRM - Terminal command processing

;THIS COMMAND ACCEPTS A TERMINAL TYPE AS ARGUMENT
;  AND SETS THE TYPE PARAMETER ACCORDINGLY

X28TRM::CALL	GETATX			;GET NEXT ATOM
	TST	R0			;VALID STOPPER?
	BEQ	CMDTR1			;YES
SYNE3R:	JMP	SYNERR			;NO

CMDTR1:	
	TST	R2			;NULL ATOM?
	BNE	1$			;NO
	MOVB	SDTRTT#(SD),R0		;YES-GET DEFAULT TERMINAL TYPE
	BR	CMDTR5			;CONTINUE

1$:	MOV	#T..MAX*2+2,R0		;GET INDEX FOR TABLE
2$:	CMP	R2,TTPNM1#-2(R0)	;THIS ONE?
	BEQ	4$			;MAYBE
3$:	DEC	R0			;NO
	SOB	R0,2$		;CONTINUE SEARCH IF MORE THERE

	INLMES	<"? No such terminal type"<CR><LF>>
	JMP	CMDBR5			;FAIL

;HERE WITH MATCH ON FIRST PART OF TERMINAL TYPE NAME

4$:	CMP	R3,TTPNM2#-2(R0)	;REALLY THIS ONE?
	BNE	3$			;NO-CONTINUE
	ASR	R0			;YES-FIX UP THE INDEX
	DEC	R0
CMDTR5:	CALL	SETTTP#			;SET TERMINAL TYPE PARAMETERS
	  NOP				;Should not fail!
TRMDON:	TBBE	$T3TRM,SDTRS3#(SD),10$	;WERE WE ASKING FOR TERMINAL TYPE?
	BIC	#$T3TRM,SDTRS3#(SD)	;YES-CLEAR TERMINAL QUESTION FLAG
	JMP	CMDMO3			;AND GO TELL HIM WHO WE ARE
10$:	JMP	CMDMO4
	.PAGE
	.SBTTL	X28PRO - PROFILE COMMAND
;-----
; THIS COMMAND ACCEPT A TERMINAL PROFILE AS THE ARGUMENT AND SETS THE
;  PROFILE PARAMETER ACCORDINGLY
;-----
X28PRO::
	CALL	GETATX			;GET ANOTHER ATOM
	TST	R0			;ANYTHING AFTER IT?
	BNE	SYNE3R			;YES-COMPLAIN
	TST	R2			;OK-NULL ATOM?
	BEQ	20$			;YES-FINISHED
	MOV	#P..MAX*2+2,R0		;NO-GET INDEX FOR TABLE
12$:	CMP	TPFNM1#-2(R0),R2	;THIS ONE?
	BEQ	14$			;YES
13$:	DEC	R0			;NO
	SOB	R0,12$			;CONTINUE IF MORE TO CHECK
	INLMES	<"? No such terminal profile"<CR><LF>>
	JMP	CMDBR5			;FAIL

;HERE WITH MATCH ON FIRST PART OF PROFILE NAME

14$:	CMP	TPFNM2#-2(R0),R3	;REALLY THIS ONE?
	BNE	13$			;NO-CONTINUE CHECKING
	ASR	R0			;YES-FIX UP THE INDEX
	DEC	R0
	CALL	SETPRF#			;SET PROFILE PARAMETERS
	  NOP				;Should not fail!
20$:	JMP	CMDMO4
	.PAGE

; HERE TO PROCESS A RESET COMMAND

X28RES::
	CALL	POBRST#			;(TRM), TO SEND A RESET PACKET
	BR	X28IN2

; HERE TO PROCESS A STATUS COMMAND

X28STA::
	TST	(SD)			;DISCONNECTED?
	BEQ	10$			;YES, BRANCH
	TBBE	$T1XXX,SDTRS1,10$	;branch if linkE is not connected
	INLMES	<<CR><LF>"ENGAGED"<CR><LF>>
	BR	X28IN2
10$:	INLMES	<<CR><LF>"FREE"<CR><LF>>
	BR	X28IN2

; HERE TO PROCESS INTERRUPT COMMAND
X28INT::
	CALL	POBINT#			;(TRM), TO SEND AN INTERRUPT PACKET
X28IN2:
	JMP	CMDBR5
	.PAGE
	.SBTTL	X28PAR - Parameter command processing
;
; THREE KINDS OF "PAR" COMMAND ARE SUPPORTED.
;	"PAR" WILL GIVE A SYMBOLIC DISPLAY OF ALL PARAMETERS
;	"PAR?" AND "PAR?m,n,o,p" WILL GIVE WHAT'S RECOMMENDED IN X.28
;
X28PAR::
	CMPB	#'?,R0			;IS THERE A "?" AFTER "PAR"?
	BEQ	10$			;YES, BRANCH
	TST	R0			;NO,  E.O.L. SEEN?
	BNE	SYNER1			;    NO
	JMP	DSPPAR			;    YES
;
; HERE IF PAR? HAS BEEN SCANNED
;
10$:
	INLMES	<"PAR ">
	CALL	GETDEC#			;TRY GET A PARAMETER REFERENCE
	BCC	20$			;FOUND ONE IN R1, BRANCH
	CMPB	#LF,R0			;NUMBER NOT FOUND, E.O.L. SEEN?
	BNE	SYNER1			;NO, SYNTAX ERROR
	JMP	LSTPAR			;YES, GO OUTPUT PARAMETER VALUE PAD
					;  SERVICE SIGNAL.
;
; HERE AFTER PAR?m IS SEEN,  m IN R1
;
20$:
	MOVB	R0,SDTRC4#+1(SD)	;SAVE TERMINATING CHAR
	ASL	R1
	MOVB	R1,SDTRC4#(SD)		;SAVE PARAMETER INDEX

	CALL	OPAIR			;OUTPUT PARAMETER REFERENCE AND VALUE PAIR
	MOVB	SDTRC4#+1(SD),R0	;GET THE TERMINATING CHARACTER BACK
	TST	R0			;E.O.L.?
	BEQ	PARX00			;YES
	CMPB	#',,R0			;NO, IS IT ","
	BNE	SYNER1			;    NO,  ERROR
	INLMES	<",">			;    YES, OUTPUT ONE
	CALL	GETDEC#			;TRY GET NEXT PARAMETER REFERENCES
	BCS	SYNER1			;NUMBER NOT FOUND, ERROR
	BR	20$
;
PARX00: JMP	CMDMO4			;
SYNER1:	JMP	SYNERR
;
; HERE IF "PAR?" COMMAND WAS THE INPUT
;
LSTPAR:
	MOV	#2,SDTRC4#(SD)		;START WITH 2
10$:
	CALL	OPAIR			;OUTPUT PARAMETER REFERENCE AND VALUE
	MOV	SDTRC4#(SD),R1		;GET PARAMETER INDEX
	TST	(R1)+			;INCREMENT BY 2
	CMP	R1,#CMDTSX#		;ALL DONE?
	BHI	PARX00			;YES
	MOV	R1,SDTRC4#(SD)		;NO, SAVE THE INDEX
	INLMES	<",">
	BR	10$			;AND GO AGAIN
;
; OPAIR - OUTPUT A PARAMETER REFERENCE AND VALUE PAIR
;	(SDTRC4#(SD)) = PARAMETER REFERENCE * 2
;	CALL OPAIR
;		EITHER m:n  OR m:INV WILL BE SENT TO TERMINAL
;
OPAIR:
	POP	SDTRC5#(SD)		;SAVE RETURN ADDRESS, 
					;  KEEP STACK IN MAIN LOOP LEVEL
	CLR	R1
	BISB	SDTRC4#(SD),R1		;GET PARAMETER REFERENCE*2
	ASR	R1			;HALF IT
	CALL	OUTDEC#			;OUTPUT IT
	INLMES	<":">
	CLR	R4
	BISB	SDTRC4#(SD),R4		;GET PARAMETER REFERENCE*2
	BEQ	OPAIR2			;BRANCH IF ZERO
	CMP	R4,#CMDTSX#		;OUT-OF-BOUND?
	BHI	OPAIR2			;YES, BRANCH
	CLR	R1
	MOVB	CMDTST#-2(R4),R1	;GET SDB OFFSET
	ADD	SD,R1
	MOVB	CMDIDX#-2(R4),R0	;GET DISPATCH INDEX
	JMP	@DSPLST#(R0)		;DISPATCH
OPAIR2:	INLMES	<"INV">
	BR	LSTFIN
;
; ROUTINE TO DISPLAY PARAMETER VALUE FOR THOSE PARAMETERS THAT CAN BE 0 OR 1
;
LSTBIT::
	BITB	CMDTSB#-2(R4),(R1)	;TEST THE BIT
	BEQ	30$			;IT IS ZERO
	MOV	#1,R1			;
	BR	40$			;
30$:	CLR	R1
40$:	CALL	OUTDEC#			;OUTPUT IT
	BR	LSTFIN
;
; LSTDFS - DISPLAY DATA FORWARDING SIGNALS BASED ON X.3 DEFINITION
;
LSTDFS::
	CALL	GETDFS			;GET BREAK SET AND CONVERT IT 
	BR	LSTVA2			;
;
; LSTSPE - DISPLAY TERMINAL SPEED BASED ON X.3 DEFINITION
;
LSTSPE::
	CALL	GETSPE
	BR	LSTVA2
;
; LSTLFI - DISPLAY LINE FEED INSERTION OPTION
;
LSTLFI::
	CALL	GETLFI
	BR	LSTVA2
;
; LSTVAL - ROUTINE TO DISPLAY PARAMETER VALUE FOR THOSE PARAMETER THAT TAKES
;		ONE BYTE TO STORE.
LSTVAL::
	MOVB	(R1),R1
	BIC	#177400,R1		;CLEAR HIGH ORDER BYTE
LSTVA2:	CALL	OUTDEC#			;
;	BR	LSTFIN

;
; LSTFIN - RETURN TO ADDRESS SAVED IN SDTRC5
;
LSTFIN:	JMP	@SDTRC5#(SD)
;
	.PAGE
	.SBTTL 	X28SET - SET command processing
;
; HERE AFTER "SET" COMMAND HAS BEEN RECOGNIZED IN THE COMMAND LINE
;
X28SET::
	CLR	SDTRC4#(SD)		;
	CMPB	R0,#'?			;NEXT CHARACTER "?"
	BEQ	20$			;YES, BRANCH 
	CMPB	R0,#SPA			;NO,  IS IT A SPACE?
	BEQ	X28SE1			;    YES, BRANCH
	BR	SYNE4R			;    NO,  SYNTAX ERROR
20$:
	BIS	#100000,SDTRC4#(SD)	;REMEMBER NEED TO DISPLAY AFTER SET
	INLMES	<"PAR ">
X28SE1:	CALL	GETDEC#			;GET PAR. REF.
	BCS	SYNE4R			;NO NUMBER FOUND WHEN EXPECTING ONE
	CMPB	R0,#':			;NEXT CHAR. IS ":" ?
	BNE	SYNE4R			;NO, BRANCH
	ASL	R1			;DOUBLE IT
	MOVB	R1,SDTRC4#(SD)		;AND SAVE FOR LATER
	CALL	GETDEC#			;TRY GET PARAMETER VALUE
	BCS	SYNE4R	
	BICB	#177,SDTRC4#+1(SD)	;
	BISB	R0,SDTRC4#+1(SD)	;SAVE THE TERMINATOR
	CLR	R4
	BISB	SDTRC4#(SD),R4		;GET PARAMETER REF*2 IN R4
	CMPB	R4,#CMDTSX#		;OUT OF BOUND ?
	BLOS	X28SE4			;NO, BRANCH
X28SE2:	
	ASR	R4
	MOV	R4,R1
	CALL	OUTDEC#
	INLMES	<":INV,">
	MOV	#1,R1			;REMEMBER NO NEED TO OUTPUT A COMMA
	JMP	ENTFIN
;
; (R4) = PARAMETER REFERENCE * 2
; (R1) = PARAMETER VALUE
;
X28SE4:
	CLR	R3
	MOVB	CMDTST#-2(R4),R3	;GET SDB OFFSET
	ADD	SD,R3
	MOVB	CMDIDX#-2(R4),R0	;GET DISPATCH INDEX
	JMP	@DSPENT#(R0)		;

SYNE4R:	JMP	SYNERR
	.PAGE
;
; HERE TO HANDLE THE REAL X.28 PARAMETER SETTING COMMAND
;
ENTBIT::
	CMP	R1,#1			;MAKE SURE R1=0 OR 1
	BHI	X28SE2			;OUT OF BOUND
	BEQ	10$			;=0, GO SET THE BIT
	BICB	CMDTSB#-2(R4),(R3)	;=1, CLEAR THE BIT
	BR	ENTB02
10$:	BISB	CMDTSB#-2(R4),(R3)
ENTB02:
	TST	SDTRC4#(SD)		;NEED TO DISPLAY THE NEW SETTING?
	BPL	30$			;NO, GO LOOK FOR NEXT TOKEN
	CALL	OPAIR			;GO DISPLAY THE NEW SETTING
	CLR	R1			;NO NEED TO OUTPUT AN EXTRA COMMA
30$:	JMP	ENTFIN
;
; HERE IF THE PARAMETER CAN TAKE ANY BYTE VALUE
;
ENTVAL::
	CMP	R1,#377
	BHI	X28SE2			;BAD VALUE
	MOVB	R1,(R3)			;STORE IT
	BR	ENTB02
;
; HERE IF THE PARAMETER CAN TAKE ANY ASCII CHARACTER
;
ENTCHR::
	CMP	R1,#177
	BHI	X28SE2			;BAD VALUE, 
	MOVB	R1,(R3)			;O.K., STORE IT
	BR	ENTB02
;
; ENTDFS - ENTERING DATA FORWARDING SIGNALS TO SDB AFTER CONVERTING
;     X.3 INPUT TO MICRONET BREAK SET VALUE
;
ENTDFS::
	CALL	CNVDFS
	BCS	X28SE2			;IF INVALID
	MOVB	R1,(R3)			;STORE THE NEW VALUE
	BR	ENTB02
;
; ENTSPE - ENTERING TERMINAL SPEED, AN ILLEGAL OPERATION
;
ENTSPE::
	BR	X28SE2
;
; ENTLFI - ENTERING LINE FEED INSERTION OPTION
;
ENTLFI::
	CMP	R1,#7			;VALID?
	BHI	X28SE2			;NO
	BIC	#17,(R3)		;CLEAR THE CURRENT VALUE
	BIS	R1,(R3)			;AND ENTERING THE NEW VALUE
	BR	ENTB02			;

;
; HERE WHEN DONE WITH ENTERING A NEW PARAMETER VALUE INTO SDB.
; CHECK THE TERMINATOR SAVED EARLIER TO SEE IF IT IS A COMMA OR E.O.L.
;
ENTFIN:
	MOVB	SDTRC4#+1(SD),R0	;GET TERMINATOR SAVED EARLIER
	BIC	#^C177,R0		;USE ONLY 7 BITS
	CMPB	R0,#',			;IS IT A COMMA?
	BNE	30$			;NO, GO CHECK IF E.O.L.
	TSTB	SDTRC4#+1(SD)		;YES, DISPLAY REQUESTED?
	BPL	10$			;    NO
	TST	R1			;    YES, NEED TO OUTPUT A COMMA?
	BNE	10$			;	NO
	INLMES	<",">			;	YES, 
10$:	JMP	X28SE1			;GO BACK TO LOOK FOR MORE INPUT
30$:
	TST	R0			;E.O.L.?
	BNE	40$			;NO, SYNTAX ERROR
	JMP	CMDMO4			;YES, DONE
40$:	JMP	SYNERR
	.PAGE
;
; HERE FOR TERMINAL PARAMETER SYMBOLIC SET/DISPLAY
;
X28TPM:
	MOV	#CMDTSX#,R4		;GET INDEX FOR TABLE
4$:	CMP	R2,CMDTS1#-2(R4)	;THIS ONE?
	BEQ	CMDSE4			;IF MATCH
	DEC	R4			;STEP TO NEXT ENTRY
	SOB	R4,4$			;CONTINUE IF MORE TO CHECK
	INLMES	<"ERR - no such settable parameter"<CR><LF>>
CMDB5B:	JMP	CMDBR5			;GO CLEAN UP

;HERE WITH MATCH ON PARAMETER NAME

CMDSE4:	MOVB	CMDIDX#-2(R4),R0	;GET DISPATCH INDEX
	JMP	@DSPSET#(R0)		;DISPATCH TO ROUTINE FOR PARAMETER

;HERE FOR PARAMETERS WHICH SET BITS "ON" OR "OFF"

SETBIT::CALL	GETATM			;GET NEXT ATOM
	TST	R0			;END OF LINE?
	BNE	SYN55R			;NO-ERROR
	TST	R2			;ANY ARGUMENT GIVEN?
	BEQ	SETBI2			;NO-GO OUTPUT CURRENT VALUE
	MOVB	CMDTST#-2(R4),R1	;GET OFFSET OF BYTE
	ADD	SD,R1			;PLUS ADDRESS OF SDB
	TST	R3			;MUST BE 3 CHARACTERS OR LESS
	BNE	SYN55R
	CMP	#^RON ,R2		;DID HE SAY "ON"?
	BEQ	SETBON			;YES
	CMP	#^ROFF,R2		;DID HE SAY "OFF"?
	BNE	SYN55R			;NO-ERROR
SETBOF:	BICB	CMDTSB#-2(R4),(R1)	;YES-CLEAR BIT IN TABLE
CMDMX0:	JMP	CMDMO4			;CONTINUE

;HERE TO SET BIT

SETBON:	BISB	CMDTSB-2(R4),(R1)	;SET BIT IN TABLE
	BR	CMDMX0			;FINISHED

;HERE TO OUTPUT CURRENT VALUE (ON OR OFF)

SETBI2:	CALL	SETOUT			;OUTPUT INITIAL STUFF
	BITB	CMDTSB-2(R4),(R1)	;IS THE BIT SET?
	CALL	OUTONO			;OUTPUT "ON" OR "OFF"
	JMP	SETCH9			;GO FINISH UP

;HERE FOR PARAMETERS WHICH SET BITS FOR "REAL" OR "SIMULATED"

;SETSIM::CALL	GETATM			;GET NEXT ATOM
;SETSI1:	TST	R0			;END OF LINE?
;	BNE	SYNE5R			;NO-ERROR
;	TST	R2			;WAS ARGUMENT GIVEN?
;	BEQ	SETSI4			;NO
;	MOVB	CMDTST-2(R4),R1		;GET OFFSET OF BYTE
;	ADD	SD,R1			;PLUS SDB ADDRESS
;	CMP	#^RREA,R2		;DID HE SAY "REAL"?
;	BNE	SETSI2			;NO
;	TST	R3			;OK IF ONLY 3 CHARACTERS
;	BEQ	SETBOF
;	CMP	#^RL  ,R3		;MAYBE
;	BEQ	SETBOF			;YES
;	BR	SYNE5R			;NO-ERROR

;HERE IF HE DID NOT SAY "REAL"

;SETSI2:	CMP	#^RSIM,R2		;DID HE SAY "SIMULATED"?
;	BNE	SYNE5R			;NO-ERROR
;	TST	R3			;OK IF ONLY 3 CHARACTERS
;	BEQ	SETBON
;	CMP	#^RULA,R3		;MAYBE
;	BEQ	SETBON			;YES
;	BR	SYNE5R			;NO-ERROR
;
;HERE TO TYPE CURRENT VALUE (REAL OR SIMULATED)
;
;SETSI4:	CALL	SETOUT			;DO INITIAL OUTPUT
;	BITB	CMDTSB-2(R4),(R1)	;IS THE BIT SET?
;	CALL	OUTSMR			;OUTPUT "SIMULATED" OR "REAL"
;	BR	SETCH9			;CONTINUE

;HERE FOR PARAMETER WHICH SETS NUMBERIC VALUE

SETVAL::CALL	GETDEC#			;GET VALUE
	BCS	SETVA6			;IF NO VALUE GIVEN
SETVA2:	TST	R0			;END OF LINE?
	BNE	SYN55R			;NO-ERROR
	MOVB	CMDTST-2(R4),R3		;GET OFFSET OF BYTE
	ADD	SD,R3			;PLUS ADDRESS OF SDB
	MOVB	R1,(R3)			;STORE VALUE
	BR	CMDMX0			;FINISHED

;HERE IF NO VALUE GIVEN

SETVA6:	TST	R0			;END OF LINE?
	BNE	SYN55R			;NO-ERROR
	CALL	SETOUT			;DO INITIAL OUTPUT
	MOVB	(R1),R1			;GET VALUE
	BIC	#^C377,R1		;REMOVE JUNK
SETVA8:	CALL	OUTDEC#			;OUTPUT IT
	JMP	SETCH9			;GO FINISH UP

SYN55R:	JMP	SYNERR			;

;
; HERE FOR DATA FORWARDING SIGNALS
;
SETDFS::
	CALL	GETDEC#			;GET NEW VALUE OF D.F.S.
	BCS	SETDF3			;NOT FOUND
	CALL	CNVDFS			;CONVERT FROM X.3 VALUE TO MICRONET
	BCC	SETVA2
SETDF1:	INLMES	<"ERR - invalid parameter value">	
	JMP	CMDBR5
SETDF3:
	TST	R0			;E.O.L.?
	BNE	SYN55R			;NO,  BRANCH
	CALL	SETOUT			;OUTPUT HEADING
	CALL	GETDFS			;GET DFS AND CONVERT 
	BCC	SETVA8			;GOOD RETURN, GO OUTPUT THE VALUE
	INLMES	<"invalid">
	BR	SETCH9
;
; SETSPE - HERE FOR SET/DISPLAY TERMINAL SPEED
;
SETSPE::
	CALL	GETDEC#			;TRY GET A VALUE
	BCS	10$			;NOT FOUND, BRANCH
	INLMES	<"ERR - terminal speed can not be set">
	JMP	CMDBR5
10$:
	TST	R0			;E.O.L.?
	BNE	SYN55R			;NO, BRANCH
	CALL	SETOUT			;OUTPUT HEADING
	CALL	GETSPE
	BR	SETVA8
;
; SETLFI - SET/DISPLAY LINE FEED INSERTION OPTION
;
SETLFI::
	CALL	GETDEC#			;GET PARAMETER VALUE
	BCS	20$			;NOT FOUND
	TST	R0			;E.O.L.?
	BNE	SYN55R			;NO, BRANCH
	CMP	R1,#7			;VALID VALUE?
	BHI	SETDF1			;NO, BRANCH
	MOVB	CMDTST-2(R4),R3		;GET SDB OFFSET
	ADD	SD,R3
	BIC	#17,(R3)		;CLEAR CURRENT VALUE
	BIS	R1,(R3)			;STORE NEW VALUE
	BR	CMDMX0
20$:
	TST	R0			;E.O.L.?
	BNE	SYN55R			;NO, ERROR
	CALL	SETOUT
	CALL	GETLFI
	BR	SETVA8
;
; SETESC - HERE TO SET/DISPLAY THE PAD RECALL CHARACTER
;
SETESC::
	CALL	SETCSB
	BCS	SYN55R			;IF ERROR
	BEQ	20$			;IF NO CHARACTER GIVEN
	CMPB	R0,#DLE			;USER WANT ^P?
	BNE	10$			;NO
	MOV	#1,R0			;YES, SET THE VALLUE TO ONE
10$:	MOVB	R0,(R1)
	BR	CMDMY0
20$:
	CALL	SETOUT			;OUTPUT THE HEADING
	CALL	GETESC
	BR	SETCH7
;
;HERE FOR PARAMETER WHICH SETS A CHARACTER
;
SETCHR::CALL	SETCSB			;DO MOST OF THE WORK
	BCS	SYN55R			;IF ERROR
	BEQ	SETCH3			;IF NO CHARACTER GIVEN
SETCH2:	MOVB	R0,(R1)			;STORE CHARACTER
	BR	CMDMY0			;FINISHED

;HERE FOR PARAMETER WHICH SETS A CHARACTER WHICH MUST BE A CONTROL CHARACTER

SETCCH::CALL	SETCSB			;DO MOST OF THE WORK
	BCS	SYN55R			;IF ERROR
	BEQ	SETCH3			;FINISHED IF NO CHARACTER GIVEN
	CMP	#SPA,R0			;DID HE GIVE USE A CONTROL CHARACTER?
	BGT	SETCH2			;YES-GO STORE IT
	INLMES	<"? Must be control character"<CR><LF>>
	JMP	CMDBR5			;CONTINUE

;HERE IF NO CHARACTER GIVEN - TYPE CURRENT CHARACTER

SETCH3:	CALL	SETOUT			;OUTPUT INITIAL STUFF
	MOVB	(R1),R0			;GET CHARACTER
SETCH7:	CALL	OUTCXX			;OUTPUT CHARACTER
SETCH9:	CALL	ENDLIN#
CMDMY0:	JMP	CMDMO4			;FINISHED
;
;  ROUTINES USED TO DO CONVERSION BETWEEN X.3 PARAMETER VALUE AND MICRONET
;   TERMINAL PARAMETER VALUE.
;

;  FETCH LINE FEED INSERTION OPTION FROM SDB
GETLFI:	MOVB	(R1),R1
	BIC	#^C17,R1		;ISOLATE LINE FEED OPTION
	RETURN
;  FETCH COMMAND INTERRUPT CHARACTER AND CONVERT ONE TO DLE
GETESC:
	CLR	R0
	BISB	(R1),R0
	CMPB	R0,#1
	BNE	30$
	MOVB	#DLE,R0
30$:	RETURN
;
; CNVDFS - CONVERT THE X.3 DATA FORWARDING SIGNAL TO MICRONET BREAK SET
;
;	(R1) = X.3 DATA FORWARDING SIGNAL
;	CALL	CNVDFS
;	C-CLEARED, (R1) = MICRONET BREAK SET
;	C-SET, INVALID INPUT VALUE
;
CNVDFS:
	CLR	R2
	CMP	R1,#94.			;ALL CNTRL CHAR.+<DEL>-(<HT><LF><VT><FF>) ?
	BEQ	18$			;YES
	CMP	R1,#2			;<CR> ONLY?
	BEQ	19$			;YES
	TST	R1			;R1 = 0?
	BEQ	21$			;YES
	MOV	#200,R2			;SET IT TO BREAK ON ALL
	CMP	R1,#255.
	BEQ	20$			;YES
	SEC				;NONE OF THE ABOVE
	RETURN
18$:	INC	R2
19$:	INC	R2
20$:	MOV	R2,R1
21$:	CLC
	RETURN
;
; GETDFS - FETCH CURRENT BREAK SET AND CONVERT IT TO X.3 DATA FORWARDING
;	SIGNAL
;		X.3 	!     MICRONET BREAK SET
;		---------------------------------
;		0	!	0
;		2	!	1	<CR> ONLY
;		94.	!	2	ALL CNTRL CHARS -(<HT><LF><VT><FF>)+<DEL>
;		255.	!	200	BREAK ON ANY CHARACTER.
;
GETDFS:
	CLR	R0
	BISB	(R1),R0			;GET CURRENT BREAK SET
	CMP	R0,#200			;BREAK ON ANY CHAR.?
	BNE	10$			;NO, BRANCH
	MOV	#255.,R1
	RETURN
10$:
	CMP	R0,#2			;BREAK SET > 2?
	BLOS	20$			;YES, BRANCH
	MOV	#77777,R1		;SET TO A HUGE NUMBER
	RETURN
20$:
	MOVB	DFSTBL(R0),R1		;GET X.3 VALUE
	RETURN

	PURE
DFSTBL:	.BYTE	0	;NO D.F.S.
	.BYTE	2	;ONLY <CR> IS D.F.S.
	.BYTE 	94.	;<ALL CNTRL CHAR.> - (<HT><LF><VT><FF>) + <DEL>
	.EVEN
	CODE

; GETSPE - FETCH MICRONET TERMINAL SPEED CODE AND CONVERT TO X.3 SPEED CODE
;
GETSPE:
	MOV	(R1),R0		;GET SDTRS3
	MOV	R0,R1		;MAKE A COPY
	BIC	#^C$T3IRT,R0	;ISOLATE INPUT RATE
	SWAB	R0		;GET IT TO LOWER BYTE
	BIC	#^C$T3ORT,R1	;ISOLATE OUTPUT RATE
	CMP	R0,R1		;ARE THEY THE SAME RATE?
	BEQ	20$		;YES, BRANCH
	CMP	R0,#R.75	;NO,  IS IT 75/1200 SPLIT SPEED?
	BNE	50$		;    NO, A CODE NOT DEFINED IN X.3
	CMP	R1,#R.1200	;    MAYBE
	BNE	50$		;    NO
	MOV	#R.75S,R1	;    YES.
;	MOV	#R.SPL1,R1	;    YES.
20$:
	CMP	R1,#R.MAX	;VALID CODE?
	BHI	50$		;NO
	MOVB	NXLRAT#(R1),R1	;USE THE TABLE IN X25Q
	RETURN
50$:	MOV	#77777,R1	;MAKE IT HUGE
	RETURN
	.PAGE
;SUBROUTINE TO DO MOST OF THE WORK FOR PARAMETERS WHICH SET A CHARACTER
;	C(R4) = INDEX FOR PARAMETER
;	CALL	SETCSB
;	Z:CLR = CHARACTER TYPED, C(R0) = CHARACTER,  (R1) = SDB OFFSET
;	Z:SET = NO CHARACTER TYPED,
;	C:SET = SYNTAX ERROR

SETCSB:	CALL	EATBLK#			;GET NEXT NON-BLANK CHARACTER
	BEQ	RTN005			;IF NO CHARACTER GIVEN
	CMP	#'^,R0			;IS HE SPECIFYING A CONTROL CHARACTER?
	BNE	SETCS4			;NO-GO ON
	CALL	GETCMC#			;YES-GET NEXT CHARACTER
	  BR	2$			;If end of line
	BR	SETCS2			;GO ON IF HAVE ANOTHER

2$:	MOV	#'^,R0			;END OF LINE-NOT CONTROL CHARACTER!
	BR	SETCS5			;CONTINUE

;HERE TO CHANGE PRINTING CHARACTER TO CONTROL CHARACTER

SETCS2:	CMP	#140,R0			;LOWER CASE CHARACTER?
	BGT	SETCS3			;NO-GO ON
	BIC	#40,R0			;YES-CHANGE TO UPPER CASE
SETCS3:	CMP	#'A,R0			;VALID CONTROL CHARACTER?
	BGT	RTNCS5			;NO-ERROR
	CMP	#'_,R0			;MAYBE
	BLT	RTNCS5			;NO
	BIC	#100,R0			;YES-CHANGE TO CONTROL CHARACTER
SETCSX:	PUSH	R0			;SAVE THE CHARACTER
SETCX2:	CALL	GETCMC#			;TRY TO GET NEXT CHARACTER
	  BR	SETCS6			;OK if end of line
	BR	SETCS8

SETCS6:	POP	R0			;RESTORE CHARACTER
SETCS5:	MOVB	CMDTST-2(R4),R1		;GET OFFSET OF BYTE
	ADD	SD,R1			;PLUS SDB ADDRESS
	CLC				;MAKE SURE C IS CLEAR
RTN005:	RETURN				;RETURN (Z IS CLEAR)

;HERE IF NORMAL PRINTING CHARACTER

SETCS4:	PUSH	R0			;SAVE THE CHARACTER
	CALL	GETAT0			;GET ATOM FROM NEXT CHARACTERS
	TST	R2			;NULL ATOM?
	BEQ	SETCX2			;YES-MUST HAVE BEEN NON-LETTER
	TST	R0			;END OF LINE NEXT?
	BNE	SETCS8			;NO-ERROR
	MOV	R2,R1			;YES-JUST ONE LETTER?
	CLR	R0
	DIV	#3100,R0
	TST	R1
	BEQ	SETCX2			;YES
	MOV	R4,(SP)			;SAVE R4
	MOV	#CMXDEX#,R4		;INIT INDEX
2$:	CMP	CMXDE1#-2(R4),R2	;THIS ONE?
	BEQ	SETCS9			;YES
	DEC	R4			;DECREMENT INDEX
	SOB	R4,2$			;CONTINUE IF MORE TO CHECK
SETCS8:	TST	(SP)+			;FIX UP THE STACK
RTNCS5:	SEC				;SET C
	RETURN

;HERE WITH MATCH ON ATOM

SETCS9:	MOVB	CMXDEL#-2(R4),R0	;GET CHARACTER
	POP	R4			;RESTORE R4
	BR	SETCS5			;CONTINUE
	.PAGE
;SUBROUTINE TO OUTPUT PARAMETER NAME FOLLOWED BY " = "
;	C(R4) = INDEX FOR COMMAND TABLES
;	CALL	SETOUT
;	C(R1) = ADDRESS OF DATA TABLE FOR PARAMETER
;	C(R4) = UNCHANGED

SETOUT:	POP	SDTRC2#(SD)		;SAVE RETURN ADDRESS
	MOVB	R4,SDTRC4#(SD)		;SAVE INDEX
	MOV	CMDTS1-2(R4),R1		;TYPE PARAMETER
	CALL	OUTRDX
	INLMES	<" = ">
	MOVB	SDTRC4#(SD),R4		;RESTORE INDEX
	MOVB	CMDTST-2(R4),R1		;GET OFFSET OF BYTE CONTAINING CHAR
	ADD	SD,R1			;PLUS SDB ADDRESS
	JMP	@SDTRC2#(SD)		;RETURN

SYNE5R:	JMP	SYNERR
	.PAGE
;HERE TO DISPLAY ALL PARAMETER VALUES

DSPPAR:	TST	R0			;END OF LINE?
	BNE	SYNE5R			;NO-ERROR
	INLMES	<<CR><LF>"Terminal type = ">
	MOVB	SDTRCT#(SD),R0		;GET TERMINAL TYPE
	ASL	R0
	MOV	TTPNM1#(R0),R1		;GET FIRST 3 CHARACTERS
	CALL	OUTRDX			;OUTPUT THEM
	MOVB	SDTRCT#(SD),R0		;GET TYPE AGAIN
	ASL	R0
	MOV	TTPNM2#(R0),R1		;GET SECOND 3 CHARACTERS
	CALL	OUTRDX			;OUTPUT THEM
	INLMES	<<CR><LF><CR><LF>"X.3 terminal parameters"<CR><LF>>
	MOV	#2,SDTRC4#(SD)		;INITIALIZE INDEX
CMDPA1:
;	CMP	#PRFPAR#+2,SDTRC4#(SD)	;IS THIS FIRST PROFILE PARAMETER?
;	BNE	CMDPA2			;NO-GO ON
;	INLMES	<<CR><LF><CR><LF>"Terminal profile parameters"<CR><LF>>
CMDPA2:	MOVB	SDTRC4#(SD),R4		;GET INDEX
	CALL	SETOUT			;DO FIRST PART
	MOVB	CMDIDX#-2(R4),R2	;GET DISPATCH ADDRESS
	JMP	@DSPPRT#(R2)		;GO OUTPUT VALUE

;HERE TO OUTPUT PARAMETER AS "ON" OR "OFF"

PARBIT::BITB	CMDTSB#-2(R4),(R1)	;IS THE BIT SET?
	CALL	OUTONO			;OUTPUT "ON" OR "OFF"
	BR	PARFIN			;CONTINUE

;HERE TO OUTPUT VALUE AS "REAL" OR "SIMULATED"
;
;PARSIM::BITB	CMDTSB#-2(R4),(R1)	;IS THE BIT SET?
;	CALL	OUTSMR			;OUTPUT "REAL" OR "SIMULATED"
;	BR	PARFIN			;CONTINUE

; HERE TO OUTPUT LINE FEED OPTION

PARLFI::
	CALL	GETLFI			;FETCH IT FROM SDB
	BR	PARVA2			;OUTPUT IT

; HERE TO OUTPUT CURRENT DATA FORWARDING SIGNALS

PARDFS::
	CALL	GETDFS
	BR	PARVA2
; HERE TO OUTPUT TERMINAL SPEED CODE
;
PARSPE::
	CALL	GETSPE
	BR	PARVA2

;HERE TO OUTPUT VALUE AS DECIMAL VALUE

PARVAL::MOVB	(R1),R1			;GET VALUE
	BIC	#^C377,R1		;REMOVE JUNK
PARVA2:	CALL	OUTDEC#			;OUTPUT IT
	BR	PARFIN			;CONTINUE

; HERE TO OUTPUT PAD RECALL CHARACTER

PARESC::
	CALL	GETESC
	BR	PARCH2
;HERE TO OUTPUT VALUE AS ASCII CHARACTER

PARCHR::MOVB	(R1),R0			;GET CHARACTER
PARCH2:	CALL	OUTCXX			;OUTPUT THE CHARACTER
PARFIN:	ADD	#2,SDTRC4#(SD)		;INCREMENT INDEX
	CMP	#CMDTSX,SDTRC4#(SD)	;FINISHED YET?
	BLT	CMDPA5			;YES-GO ON
;	MOV	#20.,R4			;GET FIELD SIZE
;	CALL	ENDFLD			;END THIS FIELD
	CALL	ENDLIN#
	BR	CMDPA1			;CONTINUE

;HERE WHEN FINISHED

CMDPA5:	CALL	ENDLIN#
	JMP	CMDMO4
	.PAGE
	.SBTTL	Command processor subroutines

;Subroutine to check for normal Disconnect or NAK reason code
;	C(R0) = reason code
;	CALL	CHKREA
;	  return if abnormal reason
;	return if normal reason

CHKREA:	CMPB	#.ERREQ,R0		;Is this a normal reason?
	BEQ	4$			;Yes
	CMPB	#.ERTRM,R0
	BEQ	4$
	CMPB	#.ERRLS,R0
	BNE	10$			;No!
4$:	ADD	#2,(SP)			;Yes-give skip return
10$:	RETURN

;SUBROUTINE TO TERMINATE FIELD FOR PARAMETER COMMAND
;	C(R4) = SIZE OF FIELD
;	CALL	ENDFLD

;ENDFLD:
;	br	14$			; ALWAYS START ON A NEW LINE
;
;	CLR	R0			;GET POSITION ON LINE
;	BISB	SDTRHP#(SD),R0
;	MOV	R0,R3			;COPY IT
;	CLR	R2			;CALCULATE END OF FIELD
;	DIV	R4,R2
;	INC	R2
;	MUL	R4,R2
;	CLR	R1			;GET LINE WIDTH
;	BISB	SDTRLW#(SD),R1
;	BNE	2$			;IF WIDTH SET
;	MOV	#72.,R1			;DEFAULT IS 72.
;2$:	SUB	R4,R1			;WILL ANOTHER FIELD FIT?
;	CMP	R3,R1
;	BGT	14$			;NO
;	SUB	R3,R0			;YES-CALCULATE NUMBER OF SPACES NEEDED
;	POP	SDTRC3#(SD)		;SAVE RETURN ADDRESS
;	MOV	R0,SDTRC2#(SD)		;SAVE COUNT
;	MOV	#10$,SDTROD#(SD)	;SET OUTPUT DISPATCH
;10$:	INC	SDTRC2#(SD)		;NEED MORE?
;	BGT	OUTDON			;NO-FINISHED
;	MOV	#SPA,R0			;YES-GET A SPACE
;	BR	OUTCH1			;AND GO OUTPUT IT
;
;HERE IF ANOTHER FIELD WILL NOT FIT ON THIS LINE
;
;14$:	JMP	ENDLIN#			;END THE LINE
	.PAGE
;SUBROUTINE TO OUTPUT ONE WORD AS 3 RADIX-50 CHARACTERS
;	C(R1) = WORD TO OUTPUT
;	CALL	OUTRDX

OUTRDX:	POP	SDTRC3#(SD)		;SAVE RETURN ADDRESS
	TST	R1			;NULL ITEM?
	BEQ	OUTDON			;YES-DO NOTHING!
	CLR	R0			;DIVIDE
	DIV	#50,R0			;TO GET 3RD CHARACTER
	MOVB	R1,SDTRC1#+1(SD)	;SAVE 3RD CHARACTER
	MOV	R0,R1			;DIVIDE
	CLR	R0			;TO GET 2ND CHARACTER
	DIV	#50,R0
	MOVB	R1,SDTRC1#(SD)		;SAVE 2ND CHARACTER
	CALL	OUTCHX			;OUTPUT 1ST CHARACTER
	MOVB	SDTRC1#(SD),R0		;GET 2ND CHARACTER
	BEQ	OUTDON			;FINISHED IF SPACE
	CALL	OUTCHX			;OUTPUT 2ND CHARACTER
	MOVB	SDTRC1#+1(SD),R0	;GET 3RD CHARACTER
	BEQ	OUTDON			;FINISHED IF SPACE
	CALL	OUTCHX			;OUTPUT 3RD CHARACTER
OUTDON:	BIC	#$T1ACT!$T1ACX,SDTRS1#(SD);CLEAR OUTPUT ACTIVE FLAG
	JMP	@SDTRC3#(SD)		;RETURN
	.PAGE
;SUBROUTINE TO OUTPUT "ON" OR "OFF"
;	Z:SET = OUTPUT "OFF"
;	Z:CLR = OUTPUT "ON"
;	CALL	OUTONO

OUTONO:	BEQ	OUTON2			;IF BIT NOT SET
	MOV	#MSBTON,R1		;GET ADDRESS OF MESSAGE
	BR	OUTSR1			;AND GO OUTPUT IT

;HERE IF BIT IS SET

OUTON2:	MOV	#MSBTOF,R1		;GET ADDRESS OF MESSAGE
	BR	OUTSR1			;AND GO OUTPUT IT

;SUBROUTINE TO OUTPUT "REAL" OR "SIMULATED"
;	Z:SET = OUTPUT "REAL"
;	Z:CLR = OUTPUT "SIMULATED"
;	CALL	OUTSMR

OUTSMR:	BEQ	OUTSM2			;IF BIT NOT SET
	MOV	#MSBTSM,R1		;GET ADDRESS OF MESSAGE
	BR	OUTSR1			;AND GO OUTPUT IT

;HERE IF BIT IS NOT SET

OUTSM2:	MOV	#MSBTRL,R1		;GET ADDRESS OF MESSAGE
OUTSR1:	JMP	OUTSTR#			;AND GO OUTPUT IT
	.PAGE
;SUBROUTINE TO OUTPUT SINGLE CHARACTER WHICH MAY BE CONTROL CHARACTER
;	C(R0) = CHARACTER TO OUTPUT
;	CALL	OUTCXX

OUTCXX:	POP	SDTRC3#(SD)		;STORE RETURN ADDRESS
	CMP	#DEL,R0			;IS IT RUBOUT?
	BEQ	OUTCX4			;YES
	CMP	#SPA,R0			;IS IT A PRINTING CHARACTER?
	BLT	OUTCX1			;YES
	BEQ	OUTCX2			;IF IT IS A SPACE
	MOV	R0,SDTRC2#(SD)		;CONTROL CHARACTER-STORE CHARACTER
	BEQ	OUTCX6			;IF NULL
	INLMES	<"^">
	MOV	SDTRC2#(SD),R0		;RESTORE CHARACTER
	BIS	#100,R0			;CHANGE TO PRINTING CHARACTER
OUTCX1:	CALL	OUTCH0			;OUTPUT IT
	BR	OUTDON			;AND RETURN

;HERE IF CHARACTER IS SPACE

OUTCX2:	MOV	#SPAMES,R1		;GET MESSAGE
	BR	OUTCX7			;AND OUTPUT IT

;HERE IF CHARACTER IS RUB-OUT

OUTCX4:	MOV	#RUBMES,R1		;GET MESSAGE
	BR	OUTCX7			;AND OUTPUT IT

;HERE IF CHARACTER IS NULL (NO CHARACTER STORED)

OUTCX6:	MOV	#NULMES,R1		;GET MESSAGE
OUTCX7:	JMP	OUTST1#			;AND OUTPUT IT

;SUBROUTINE TO OUTPUT RADIX-50 CHARACTER
;	C(R0) = CHARACTER TO OUTPUT
;	CALL	OUTCHX

OUTCHX:	CMP	#33,R0			;Convert to ASCII valuee
	BGT	3$			;If letter
	BEQ	1$			;If $
	CMP	#35,R0
	BNE	2$			;If number of period
	MOV	#66,R0			;If undefined character (convert to ?)
1$:	SUB	#11,R0
2$:	SUB	#56,R0
3$:	ADD	#100,R0
					;Fall into OUTCH0

;SUBROUTINE TO OUTPUT SINGLE CHARACTER
;	C(R0) = ASCII CHARACTER TO OUTPUT
;	CALL	OUTCH0

OUTCH0:	POP	SDTROD#(SD)		;SET OUTPUT DONE DISPATCH ADDRESS
OUTCH1:	JMP	OUTCHR#			;AND GO START OUTPUT
	.PAGE
;SUBROUTINE TO FETCH COMMAND ATOM
;	CALL	GETATM		;ENTER AT GETATX IF WANT DIGITS TOO
;	C(R2) = FIRST HALF OF ATOM (RADIX-50)
;	C(R3) = SECOND HALF OF ATOM (RADIX-50)

GETATM:	MOV	(PC)+,-(SP)		;SET WORD NON-0 AS FLAG THAT WE DO NOT
					;  WANT DIGITS - THIS SKIPS NEXT INSTR.
GETATX:	CLR	-(SP)			;CLEAR WORD AS FLAG THAT WE WANT DIGITS
	CALL	EATBLK#			;SKIP PAST LEADING BLANKS
	POP	R2			;GET FLAG WORD INTO R2
GETAT0:	CALL	GETX5A			;CONVERT FIRST CHARACTER TO RADIX-50
	CALL	GETAT5			;GET FIRST ATOM
	BCC	GETAT1			;CONTINUE IF MORE
	MOV	R3,R2			;FINISHED-STORE 1ST HALF IN RIGHT PLACE
	CLR	R3			;CLEAR 2ND HALF
RTN007:	RETURN				;RETURN

;HERE IF THERE ARE MORE THAN 3 CHARACTERS IN THE ATOM

GETAT1:	PUSH	R3			;SAVE 1ST PART OF ATOM
	CALL	GETX50			;GET FIRST CHARACTER
	CALL	GETAT5			;GET 2ND PART OF ATOM
	BCS	GETAT3			;IF FINISHED
GETAT2:	CALL	GETX50			;MORE THERE-EAT NEXT CHARACTER
	BCC	GETAT2			;LOOP IF MORE TO EAT
GETAT3:	POP	R2			;RESTORE FIRST PART OF ATOM
	RETURN				;RETURN

;SUBROUTINE USED BY GETATM TO FETCH EACH HALF OF THE ATOM
;	C(R0) = RADIX 50 CODE FOR FIRST CHARACTER
;	C(R2) = 0 IF WANT DIGITS, NON-0 IF DO NOT
;	CALL	GETAT5
;	C(R0) = TERMINATING CHARACTER IF LESS THAN 3 CHARACTERS
;	C(R2) = UNCHANGED
;	C(R3) = RADIX-50 PACKED OUTPUT
;	C:SET = ATOM CONTAINS 3 CHARACTERS OR LESS

GETAT5:	BCS	GETAT6			;IF INVALID CHARACTER
	MOV	R0,R3			;GET IN RIGHT AC
	MUL	#<50*50>,R3		;GET CHARACTER IN RIGHT PLACE
	CALL	GETX50			;GET NEXT CHARACTER
	BCS	RTN007			;IF INVALID CHARACTER
	MUL	#50,R0			;PUT IN RIGHT PLACE IN THE WORD
	ADD	R1,R3			;ADD IN
	CALL	GETX50			;GET LAST CHARACTER
	BCS	RTN007			;IF INVALID CHARACTER
	ADD	R0,R3			;ADD IN CHARACTER
RTNCC7:	CLC
	RETURN				;RETURN

;HERE IF THIS PART OF ATOM IS NULL

GETAT6:	CLR	R3
RTNCS7:	SEC
	RETURN

;SUBROUTINE USED BY GETATM TO FETCH CHARACTER AS RADIX-50 VALUE
;	C(R2) = 0 IF WANT DIGITS, NON-0 IF DO NOT
;	CALL	GETX50
;	C(R0) = CHARACTER (RADIX-50 VALUE IF VALID RADIX-50 CHARACTER, ASCII
;		  VALUE OTHERWISE)
;	C:SET = NOT VALID RADIX-50 CHARACTER

GETX50:	PUSH	R3			;SAVE R3
	PUSH	R2			;AND R2
	CALL	GETCMC#			;GET CHARACTER
	  CLR	R0			;If end of line
	POP	R2			;RESTORE R2
	POP	R3			;AND R3
GETX5A:	TST	R0
	BEQ	RTNCS7			;IF NOTHING THERE
	CMP	#140,R0			;LOWER CASE?
	BGT	GETX5B			;NO-GO ON
	BIC	#40,R0			;YES-MAKE UPPER CASE
GETX5B:	CMP	#'A,R0			;IS IT A LETTER?
	BGT	GETX5C			;NO
	CMP	#'Z,R0			;MAYBE
	BLT	RTNCS7			;NO
	BIC	#^C77,R0		;YES-CONVERT TO RADIX-50 CODE
	BR	RTNCC7			;CLEAR C AND RETURN

;HERE IF NOT A LETTER

GETX5C:	TST	R2			;DO WE WANT DIGITS?
	BNE	RTNCS7			;NO
	CMP	#'0,R0			;YES-IS THIS A DIGIT?
	BGT	RTNCS7			;NO
	CMP	#'9,R0			;MAYBE
	BLT	RTNCS7			;NO
	SUB	#22,R0			;YES-CONVERT TO RADIX-50
	BR	RTNCC7			;AND RETURN
	.PAGE
	.SBTTL	CMDX28 - Text strings

	PURE

MSBTON:	.ASCIZ	"On"
MSBTOF:	.ASCIZ	"Off"
MSBTRL:	.ASCIZ	"Real"
MSBTSM:	.ASCIZ	"Sim"
SPAMES:	.ASCIZ	"Space"
RUBMES:	.ASCIZ	"Rubout"
NULMES:	.ASCIZ	"None"
	.EVEN

	.END
    a@