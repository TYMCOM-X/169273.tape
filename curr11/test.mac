	.TITLE	LING - ASYNC LINE DRIVER TYPE G (SCC)
	.SBTTL	LING - TYMSHARE/DRE

	XLPAR				;DON'T LIST PARAMETER FILE

.IF NDF ..SAT
  ..SAT=!0
.ENDC

	CODE
.=.+70036
	.SBTTL	LING - RESET ROUTINE

;THIS ROUTINE IS CALLED WHEN THE NODE IS STARTED OR RESTARTED
;	C(R4) = ADDRESS OF ADB
;	CALL	ASGINT

ASGINT::CLR	SDTXGP#(SD)		;Clear packet pointer
	CLR	@ADGCON#(R4)		;Point to reg zero
	NXMJMP	ASGIN6			;If hardware not there!
	MOV	#INILEN,R0		;Set up length of initilization code
	MOV	#SIOINI,R1		;Point to initilization code
10$:	MOVB	(R1)+,@ADGCON#(R4)	;Send an initialization sequence
	SOB	R1,10$
	MOVB	ADGVEC#(R4),@ADGCON#(R4) ;Set up interrupt vector
	BIS	#$S1AVL,SDSTS1#(SD)	;Indicate socket is available
	BISB	#$A1AVL,ADSTS1#(R4)	;And that interface is available
	RETURN				;Thats all

;HERE IF INTERFACE HARDWARE DOES NOT EXIST

ASGIN6:	BICB	#$A1AVL,ADSTS1#(R4)	;Indicate hardware does not exist
	RETURN
	PURE
.=.+15666
SIOINI:	.BYTE	4,304,22
INILEN=	.-SIOINI
	CODE
	.PAGE
	.SBTTL	LING - INTERRUPT LEVEL ROUTINES

;HERE FOR INPUT READY INTERRUPT
;BEFORE GETTING HERE THE FOLLOWING CODE HAS BEEN EXECUTED:
;	ASnIN:	PUSH	R4		;SAVE R4
;		MOV	#ADBn$,R4	;GET ADDRESS OF ADB
;		JMP	ASGINI		;GO TO COMMON ROUTINE

ASGINI::PUSH	R0			;SAVE R0 TOO
	PUSH	R1			;ALSO R1
	MOV	#21,@ADGCON#(R4)	;POINT TO STATUS REGISTER
	MOV	@ADGSTA#(R4),R0		;SAVE STATUS BYTE
	SWAB	R0
	BISB	@ADGRCV#(R4),R0
	CMP	#CTYRSR#,ADGCON#(R4)
	BNE	ASGIN3
	PUSH	R0			;SAVE CHARACTER
	BIC	#^C177,R0		;JUST 7 BITS
	CMP	#RS,R0			;IS IT SPECIAL?
	BNE	ASGIN2			;NO-GO ON
BPTINS::BPT				;YES-GO TO XDT IF ITS LOADED
	TST	(SP)+			;FIX UP THE STACK
	BR	DISMIS			;AND GO AWAY

;HERE IF NOT SPECIAL

ASGIN2:	POP	R0			;RESTORE CHARACTER
ASGIN3: MOV	#.LFDAT,R1		;DAFAULT TO DATA TYPE
	TBBE	040000,R0,2$		;TEST FOR BREAK
	MOV	#.LFBRK,R1		;SET BREAK TYPE
2$:	BIC	#^C377,R0		;CLEAR UPPER PART
	ADD	ADINDX#(R4),R0		;GET SDB ADDRESS FOR PORT
	BR	CALLTR			;GO CALL TERMINAL SERVICE

;HERE ON TRAP FROM BPT IF XDT NOT LOADED

	VECTOR	14,BPTLOC,7

BPTLOC:	CMP	#BPTINS+2,(SP)		;WAS IT FROM THE RIGHT PLACE?
	BEQ	2$			;YES-OK
	FSTOP	BPT			;[BAD BPT INSTRUCTION]

2$:	MOV	#ASGIN2,(SP)		;MODIFY RETURN ADDRESS
	RTI				;AND DISMISS
	.PAGE
;HERE FOR OUTPUT DONE INTERRUPT
;BEFORE GETTING HERE THE FOLLOWING CODE HAS BEEN EXECUTED:
;	ASnOU:	PUSH	R4		;SAVE R4
;		MOV	#ADBn$,R4	;GET ADDRESS OF ADB
;		JMP	ASGOUI		;GO TO COMMON ROUTINE

ASGOUI::PUSH	R0			;Save R0
	PUSH	R1			;And R1
	MOVB	ADINDX#+1(R4),R0	;Find the SDB for this line
	ASL	R0
	MOV	T0SX#(R0),R0
	MOV	SDTXGP#(R0),R1		;Do we have a packet?
	BEQ	6$			;No-go on
	TSTB	PKCNT(R1)		;Yes-anything in it now?
	BEQ	6$			;No
	PUSH	R2			;Yes-free up another register
.IF EQ ..SAT
	MOVB	SDTRLW#(R0),R2		;Get line width
	BEQ	2$			;If not specified
	CMPB	SDTRHP#(R0),R2		;At end of line now?
	BHIS	4$			;Yes-must stop here!
.ENDC
2$:	MOVB	PKPNT(R1),R2		;Yes-get next character
	ADD	R1,R2
	MOVB	PKDATA-1(R2),R2
	TBBE	140,R2,4$		;Stop output if not simple printing
					;  character
	INCB	PKPNT(R1)		;Simple character-bump pointer
	DECB	PKCNT(R1)		;And reduce count
.IF EQ	..SAT
	INC	COTCNT#			;Count the character output
.ENDC
	INCB	SDTRHP#(R0)		;bump the horizontal position
	MOVB	R2,@ADGXMT#(R4)		;Output the character
	POP	R2
	BR	DISMIS			;And go restore registers and dismiss

;Here if must stop output now

4$:	POP	R2
6$:	MOV	ADINDX#(R4),R0		;Get index
	CLR	R1			;Function = 0 = .LFRDY
CALLTR:	CALL	TRINTR#			;Call terminal service
DISMIS:	POP	R1			;Restore R1
	POP	R0			;And R0
	POP	R4			;And R4
	MOV	#70,@ADGCON#(R4)	;Clear interrupt cause
	RTI				;Dismiss interrupt
	.PAGE
	.SBTTL	LING   - TEN-TIMES-A-SECOND ROUTINES

;GET HERE ONCE EACH TENTH SECOND AT MAIN PROGRAM LEVEL

	TNHSEC	ASGSEC			;PUT CALL INTO TEN-TIMES-A-SECOND LOOP

ASGSEC:	MOV	#ASGADB#,R4		;GET ADDRESS OF FIRST TYPE G ADB
ONCSE1:	TBBE	$A1AVL,ADSTS1(R4),10$	;GO ON IF INTERFACE NOT AVAILABLE
	MOV	@ADGSTA#(R4),R1		;Get a copy of the inturrupt cause
	BIC	#^C30,R1		;Get mode bits
	CMPB	R1,ADGMSB#(R4)		;Compare with modem status bits
	BEQ	10$			;No change
	PUSH	SD			;Save a register
	MOVB	ADINDX#+1(R4),R0	;Find the SDB for this line
	ASL	R0
	MOV	T0SX#(R0),SD		;Get the SDB pointer to the right reg for
	CALL	MODCHG			;Update modem changes
	POP	SD
10$:	MOV	ADNEXT#(R4),R4		;STEP TO NEXT ADB
	BNE	ONCSE1			;CONTINUE IF ANOTHER
RTN004:	RETURN				;NO MORE-FINISHED


MODCHG:	MOV	#20,@ADGCON#(R4)	;Reset external change latches
	MOVB	ADGMSB#(R4),R0		;Get the old values
	XOR	R1,R0			;Form mask of changed values
	MOVB	R1,ADGMSB#(R4)		;Update changes
	BIT	#10,R0			;Did DCD change
	BEQ	30$			;No
	BIT	#10,R1			;Did DCD come on
	BNE	10$			;Yes
	CJMP	CARLOS#			;No
10$:	CJMP	CARDET#
30$:	BIT	#20,R1			;Did ring come on
	BEQ	40$			;No
	CJMP	RNGDET#
40$:	RETURN
	.PAGE
	.SBTTL	LING - OUTPUT ROUTINES

;Subroutine to output data character
;	C(R0) = Character to output
;	C(R1) = Address of packet for continued output
;	C(R4) = Address of ADB
;	C(SD) = Address of SDB
;	CALL	ASGOUT

ASGOUT::MOV	R1,SDTXGP#(SD)		;Store address of packet (if any)
	MOV	R0,@ADGXMT#(R4)		;Output the character
	RETURN				;And return

;Subroutine to perform output function
;	C(R0) = Function code
;	C(R4) = Address of ADB
;	CALL	ASGFNC

ASGFNC::ADD	R0,PC			;Dispatch on the function
	BR	SNDBRK			; 0 = .LFSBK	Send break
	BR	SETHWR			; 2 = .LFSET	Setup hardware
	BR	ANSWER			; 4 = .LFANS	Answer line (NO-OP)
	BR	HANGUP			; 6 = .LFFHG	Force hang-up (NO-OP)
	BR	STPOUT			;10 = .LFSTP	Stop output
	BR	ENDBRK			;12 = .LFEBK	End break

;Here for stop output function

STPOUT:	CLR	SDTXGP#(SD)		;Clear packet pointer
	RETURN				;Thats all

;Here to setup hardware

SETHWR:	MOVB	SDTRS3#(SD),R1		;Get output baud rate
	BIC	#^C$BRORT,R1
	ASL	R1			;*2
	PUSH	R0
	PUSH	R2
	MOV	R1,R0
	ASL	R0			;*4
	ADD	R0,R1			;*6
	ADD	#ASGRAT,R1		;POINT TO FIRST ENTRY IN TABLE
	MOVB	2(R1),ADGWR5#(R4)	;SET UP MASTER COPY OF WR5
	CLRB	ADGMSB#(R4)		;INITIALIZE MODEM CONTROL STATUS
	MOV	ADGCON#(R4),R0		;POINT AT CONTROL REGISTER
	MOV	#INISEQ,R2		;POINT TO INITAILIZATION SEQUENCE
	PUSH	#INILEN
10$:	MOVB	(R2)+,@R0
	MOVB	(R1)+,@R0		;SET BITS IN THE HARDWARE
	DEC	(SP)
	BGT	10$			;CONTINUE IF MORE TO GO
	MOV	#ADDINI,R1		;GET LENGTH OF OTHER INITIALIZATION
20$:	MOVB	(R2)+,@R0
	SOB	R1,20$
	POP	R2
	POP	R0
	BR	NULFNC			;DO OK RETURN

	PURE
INISEQ:	.BYTE	4,23,25,11.,12.,13.
INILEN=	.-INISEQ
	.BYTE	21,22,9.,11,14.,3
ADDINI=	.-INISEQ-INILEN
	CODE

;Here for start break command

SNDBRK:	MOV	#5,@ADGCON#(R4)		;Point to send break register
	MOV	#372,@ADGCON		;Turn on break bit
	RETURN

;Here for end of break command

ENDBRK:	MOV	#5,@ADGCON#(R4)		;Point to send break register
	MOV	#352,@ADGCON	;Clear the break bit
	RETURN

;Here to answer data set

ANSWER:	BISB	#202,ADGWR5#(R4)
	MOV	#5,@ADGCON#(R4)		;POINT TO REGISTER 5
	MOV	ADGWR5#(R4),@ADGCON#(R4) ;TURN ON DTR
	BR	NULFNC

;Here to hangup data set

HANGUP:	BICB	#202,ADGWR5#(R4)
	MOV	#5,@ADGCON#(R4)		;POINT TO REGISTER 5
	MOV	ADGWR5#(R4),@ADGCON#(R4) ;TURN OFF DTR
	BR	NULFNC

;Here for No-op

NULFNC:	CLC				;MAKE SURE C IS CLEAR
	RETURN

;HERE FOR ILLEGAL FUNCTION

BADFNC:	SEC				;SET C AS ERROR FLAG
	RETURN
	.PAGE
	.SBTTL	LING - ONCE-A-SECOND ROUTINE

;SUBROUTINE CALLED ONCE EACH SECOND AT MAIN PROGRAM LEVEL
;	THIS SUBROUTINE MAKES SURE THAT EACH SIO HAS ITS INTERRUPTS ENABLED!
;	CALL	ASGSEC
.if eq 1
		ONCSEC	ASGSEC

ASGSEC:	MOV	#ASGADB#,R4		;GET FIRST TYPE G ADB
2$:	TBBE	$A1AVL,ADSTS1#(R4),4$	;DOES THIS INTERFACE EXIST?
	MOV	#1,@ADGCON#(R4)		;YES-POINT AT INTERRUPT WORD
	MOV	#23,@ADGCON#(R4)	;SET ITS INTERRUPT ENABLE BITS!
4$:	MOV	ADNEXT#(R4),R4		;ADVANCE TO NEXT TYPE G ADB
	BNE	2$			;CONTINUE IF ANOTHER ONE THERE
	RETURN				;THATS ALL
.endc
	PURE
;	THIS TABLE HAS THE CONSTANTS FOR REGISTERS 4,3,5, AND 11 AND
;	 THE BAUD RATE GENERATOR
	.EVEN	
ASGRAT:	.BYTE	304,301,352,120
	.WORD	<31250./4800.>+2	; 0 =  AUTO-DETECT(4800)BAUD
	.BYTE	310,1,212,120
	.WORD	<31250./50.>+2	; 1 =    50   BAUD, 5 BITS, 1.5 STOP BITS
	.BYTE	310,1,212,120
	.WORD	<31250./75.>+2	; 2 =    75   BAUD, 5 BITS, 1.5 STOP BITS
	.BYTE	314,301,352,120
	.WORD	<31250./110.>+2	; 3 =   110   BAUD, 8 BITS, 2   STOP BITS
	.BYTE	304,101,252,120
	.WORD	<31250./269.>+2	; 4 =   134.5 BAUD, 7 BITS, 1   STOP BIT
	.BYTE	304,301,352,120
	.WORD	<31250./150.>+2	; 5 =   150   BAUD, 8 BITS, 1   STOP BIT
	.BYTE	304,301,352,120
	.WORD	<31250./200.>+2	; 6 =   200   BAUD, 8 BITS, 1   STOP BIT
	.BYTE	304,301,352,120
	.WORD	<31250./300.>+2	; 7 =   300   BAUD, 8 BITS, 1   STOP BIT
	.BYTE	304,101,252,120
	.WORD	<31250./300.>+2	;10 =   300   BAUD, 7 BITS, 1   STOP BIT
	.BYTE	304,301,352,120
	.WORD	<31250./400.>+2	;11 =   400   BAUD, 8 BITS, 1   STOP BIT
	.BYTE	304,301,352,120
	.WORD	<31250./600.>+2	;12 =   600   BAUD, 8 BITS, 1   STOP BIT
	.BYTE	304,301,352,120
	.WORD	<31250./1200.>+2	;13 =  1200   BAUD, 8 BITS, 1   STOP BIT
	.BYTE	304,301,352,120
	.WORD	<31250./1800.>+2	;14 =  1800   BAUD, 8 BITS, 1   STOP BIT
	.BYTE	304,301,352,120
	.WORD	<31250./2000.>+2	;15 =  2000   BAUD, 8 BITS, 1   STOP BIT
	.BYTE	304,301,352,120
	.WORD	<31250./2400.>+2	;16 =  2400   BAUD, 8 BITS, 1   STOP BIT
	.BYTE	104,301,352,120
	.WORD	<25000./<3600./5>>+2	;17 =  3600   BAUD, 8 BITS, 1   STOP BIT
	.BYTE	104,301,352,120
	.WORD	<31250./<4800./5>>+2	;20 =  4800   BAUD, 8 BITS, 1   STOP BIT
	.BYTE	104,301,352,120
	.WORD	<25000./<7200./5>>+2	;21 =  7200   BAUD, 8 BITS, 1   STOP BIT
	.BYTE	104,301,352,120
	.WORD	<25000./<9600./5>>+2	;22 =  9600   BAUD, 8 BITS, 1   STOP BIT
	.BYTE	104,301,352,120
	.WORD	<25000./<19200./5>>+2	;23 = 19200   BAUD, 8 BITS, 1   STOP BIT
	.BYTE	304,301,352,120
	.WORD	<31250./100.>+2		;24 =   100   BAUD, 8 BITS, 1   STOP BIT
	.BYTE	104,301,352,120
	.WORD	<2500./<3840./5>>+2	;25 = 38400   BAUD, 8 BITS, 1   STOP BIT

	.END

    