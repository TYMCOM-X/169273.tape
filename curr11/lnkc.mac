	.TITLE	LNKC  LINK PROTOCOL MODULE - TYPE C (16 BIT PARALLEL)
	.SBTTL	LNKC   - NEXILIS/JRG/BRN

	XLPAR		;DON'T LIST PARAMETER FILE

	CODE

;THIS MODULE IMPLEMENTS THE NODE-TO-NODE OR NODE-TO-HOST PROTOCOL USED
;  WITH 16 BIT PARALLEL, WORD-AT-A-TIME INTERFACES SUCH AS THE DR-11C OR
;  THE DRV-11

;DEFINE BITS FOR THE DEVICE STATUS REGISTER

$DVENB=!000140		;ENABLE INTERRUPT BITS
$DVOUT=!000001		;BIT TO SET TO MAKE OUTPUT VISIBLE
$DVACP=!000002		;BIT TO SET TO ACCEPT INPUT

;DEFINE INPUT STATE VALUES (STORED IN DDLCIS)

.ISIDL=!0		;IDLE
.ISCNT=!1		;EXPECTING PACKET TYPE AND BYTE COUNT
.ISDAT=!2		;EXPECTING DATA WORD
.ISDED=!3		;IGNORE ALL INPUT!
.ISRST=!4		;RESET IN PROGRESS
.ISAC1=!5		;Waiting on ACK

;DEFINE OUTPUT STATE VALUES (STORED IN DDLCOS)

.OSIDL=!0		;IDLE
.OSCNT=!1		;READY FOR BYTE COUNT
.OSDAT=!2		;READY FOR DATA WORD
.OSFIN=!3		;FINISHED WITH OUTPUT
.OSLOD=!4		;Output load data

;DEFINE FUNCTION CODES FOR THE INTERFACE - FUNCTIONS ARE SENT IN THE LEFT
;  BYTE OF A WORD WHOSE RIGHT BYTE IS EQUAL TO THE PREFIX VALUE

PREFIX==!307		;PREFIX VALUE

;THE TWO HIGH ORDER BITS OF THE FUNCTION BYTE ARE INTERPETED INDEPENDLY OF
;  THE FUNCTION VALUE AS FOLLOWS

$FNACK=!200		;ACKNOWLEDGES THAT A PACKET WAS RECEIVED
$FNHLD=!100		;INDICATES THAT NO MORE PACKETS SHOULD BE SEND ON THIS
			;  SOCKET UNTIL A RESPONSE IS SENT FOR IT

;THE REMAINING SIX BITS OF THE BYTES ARE INTERPETED AS FOLLOWS

.FNNOP=!0		;NO-OP
.FNRST=!1		;RESET LINK
.FNRSA=!2		;RESET ACK
.FNPKT=!3		;START OF PACKET

;DEFINE BITS FOR THE REQUEST BYTE IN THE DDB

$RQIND=!2		;INPUT DONE
$RQOUD=!4		;OUTPUT DONE
$RQLOD=!10		;Main load mode

;Load mode defines

$SEQ=!400		;Sequence bit in ack
LODACK=!100307		;The ack
	.PAGE
	.SBTTL	LKCINI - INITIALIZATION

;SUBROUTINE TO INITIALIZE PROTOCOL AND HARDWARE LEVEL ROUTINES
;	C(R4) = ADDRESS OF DDB
;	CALL	LKCINI

LKCINI::MOV	#DDLCCZ#,R1		;Get number of words to clear
	MOV	#DDLCFC#,R2		;GET FIRST WORD TO CLEAR
	ADD	R4,R2
2$:	CLR	(R2)+			;CLEAR THIS PART OF THE DDB
	SOB	R1,2$
	MOVB	#.ISRST,DDLCIS#(R4)	;INITIAL INPUT STATE
	CLR	@DDLCSR#(R4)		;DOES THIS DEVICE EXIST?
	NXMJMP	NOLINK#			;NO-GO MARK IT THAT WAY
	MOV	#$D1DWN,DDSTS1#(R4)	;INDICATE LINK IS DOWN
;	TBBE	100000,@DDLCSR#(R4),10$	;IS THE HARDWARE READY?
;	CMP	#-1,@DDLCIB#(R4)	;IS THE CABLE HANGING LOOSE
;	BEQ	LKCINS			;YES, DON'T LET THE INTERRUPTS GET US
	CMP	#<.FNRSA*400>+PREFIX,@DDLCIB#(R4) ;SENDING US AN ACK?
	BEQ	10$			;YES, HANDLE IT
	CMP	#<.FNRST*400>+PREFIX,@DDLCIB#(R4) ;SENDING US A RESET
	BNE	LKCINS			;NO, IGNORE FOR NOW
10$:	MOV	#$DVENB,@DDLCSR#(R4)	;ENABLE THE INTERFACE
LKCINS::RETURN				;THATS ALL-THE ONCE-A-SECOND ROUTINE
					;  WILL START THINGS GOING SOON!
	.PAGE
	.SBTTL	LKCOIN - INTERRUPT LEVEL OUTPUT ROUTINES

;HERE FROM CODE IN COMMON ON OUTPUT DONE INTERRUPT
;  THE CODE EXECUTED BEFORE WE GET HERE IS AS FOLLOWS:
;	LKCOn:	PUSH	R4		;SAVE R4
;		MOV	#LKn$,R4	;GET ADDRESS OF DDB
;		JMP	LKCOIN		;GO TO COMMON ROUTINE

LKCOIN::PUSH	R0			;SAVE R0 TOO
	BIC	#$DVOUT,@DDLCSR#(R4)	;CLEAR THE HARDWARE FLAG
	MOVB	DDLCOS#(R4),R0		;GET OUTPUT STATE
	ASL	R0			;FOR WORD INDEXING
	ADD	R0,PC			;DISPATCH ON THE STATE
	BR	OUTIDL			;.OSIDL =  0  OUTPUT IS IDLE
	BR	OUTCNT			;.OSCNT =  1  READY FOR BYTE COUNT
	BR	OUTDAT			;.OSDAT =  2  READY FOR DATA WORD
	BR	OUTFIN			;.OSFIN =  3  FINISHED WITH OUTPUT
	BR	OUTLOD			;.OSLOD =  4  Output load data

;HERE WHEN FINISHED DOING OUTPUT

OUTFIN:	CLRB	DDLCOS#(R4)		;CLEAR OUTPUT STATE
	BISB	#$RQOUD,DDLCRQ#(R4)	;SET REQUEST FOR MAIN PROGRAM LEVEL
	BR	OUTDS2			;DONE

;HERE IF OUTPUT IS IDLE (SPERIOUS INTERRUPT!)

OUTIDL:	INC	DDERSI#(R4)		;COUNT THE SPERIOUS INTERRUPT
	BR	OUTDS2			;THATS ALL

;HERE IF READY FOR BYTE COUNT

OUTCNT:	MOV	@DDLCOP#(R4),R0		;GET THE COUNT + PACKET TYPE
	MOV	R0,DDLCOX#(R4)		;INITIALIZE CHECK-SUM
	INCB	DDLCOS#(R4)		;BUMP OUTPUT STATE
	BR	OUTDA1			;GO OUTPUT DATA AND DISMISS

;HERE IF READY FOR NEXT DATA WORD

OUTDAT:	DECB	DDLCOC#(R4)		;DECREMENT COUNT
	BLT	OUTDA2			;IF FINISHED
	MOV	@DDLCOP(R4),R0		;GET WORD
	ADD	R0,DDLCOX#(R4)		;ADD INTO CHECK-SUM WORD
OUTDA1:	MOV	R0,@DDLCOB#(R4)		;OUTPUT IT
	ADD	#2,DDLCOP#(R4)		;BUMP POINTER
OUTDSM:	BIS	#$DVOUT,@DDLCSR#(R4)	;INDICATE WE HAVE DONE OUTPUT
OUTDS2:	POP	R0			;RESTORE R0
	POP	R4			;AND R4
	RTI				;DISMISS INTERRUPT

;HERE WHEN FINISHED OUTPUTTING DATA

OUTDA2:	MOV	DDLCOX#(R4),R0		;GET CHECK-SUM WORD
	MOV	R0,@DDLCOB#(R4)		;OUTPUT IT
	INCB	DDLCOS#(R4)		;INCREMENT OUTPUT STATE
	BR	OUTDSM			;THATS ALL
	.PAGE
	.SBTTL	OUTLOD - Interrupt level output of load data

OUTLOD:	DECB	DDLCOC#(R4)		;Decrement word count
	BLT	OUTLO1			;If negative we are done
	MOV	@DDLCOP#(R4),@DDLCOB#(R4);Output the word
	ADD	#2,DDLCOP#(R4)		;Point to the next to do
	BR	OUTDSM			;Make the word visible and leave

OUTLO1:	CLRB	DDLCOS#(R4)		;Clear the output state
	BR	OUTDS2			;Just leave
	.PAGE
	.SBTTL	LKCIIN - INTERRUPT LEVEL INPUT ROUTINES

;HERE FROM CODE IN COMMON ON INPUT READY INTERRUPT
;  THE CODE EXECUTED BEFORE WE GET HERE IS AS FOLLOWS:
;	LKCIn:	PUSH	R4		;SAVE R4
;		MOV	#LKn$,R4	;GET ADDRESS OF DDB
;		JMP	LKCIIN		;GO TO COMMON ROUTINE

LKCIIN::PUSH	R0			;SAVE R0 TOO
	BIC	#$DVACP,@DDLCSR#(R4)	;CLEAR THE HARDWARE BIT
	MOVB	DDLCIS#(R4),R0		;GET INPUT STATE
	ASL	R0			;FOR WORD INDEXING
	ADD	R0,PC			;DISPATCH ON THE STATE
	BR	INPIDL			;.ISIDL = 0  INPUT IS IDLE
	BR	INPCNT			;.ISCNT = 1  EXPECTING BYTE COUNT
	BR	INPDAT			;.ISDAT = 2  EXPECTING DATA WORD
	BR	INPDSM			;.ISDED = 3  IGNORE ALL INPUT!
	BR	INPRST			;.ISRST = 4  RESET
	BR	INPAC1			;.ISAC1 = 5 The ACK/NAK word

;HERE WHEN A RESET IS PENDING (WILL ONLY ACCEPT RESET OR POKE NOW)

INPRST:	MOV	@DDLCIB#(R4),R0		;GET DATA
	CMP	#.FNRST*400+PREFIX,R0	;IS IT A RESET?
	BEQ	4$			;YES
	CMP	#.FNRSA*400+PREFIX,R0	;IS IT A RESET ACK?
	BNE	INPDSM			;NO-IGNORE IT!
4$:	CLRB	DDLCIS#(R4)		;YES-FIX UP THE STATE
	BR	INPID2			;CONTINUE

;HERE WHEN EXPECTING DATA WORD

INPDAT:	MOV	@DDLCIB#(R4),R0		;GET DATA WORD
	DECB	DDLCIC#(R4)		;MORE DATA EXPECTED?
	BLT	INPDA2			;NO
	MOV	R0,@DDLCIP#(R4)		;YES-STORE IN PACKET
	ADD	R0,DDLCIX#(R4)		;AND ADD INTO CHECK-SUM
	ADD	#2,DDLCIP#(R4)		;BUMP POINTER
INPDSM:	BIS	#$DVACP!$DVENB,@DDLCSR#(R4);ACCEPT THE INPUT
INPDS2:	POP	R0			;RESTORE REGISTERS
	POP	R4
	RTI				;DISMISS INTERRUPT

;HERE WHEN HAVE CHECK-SUM WORD

INPDA2:	CMP	R0,DDLCIX#(R4)		;IS IT RIGHT?
	BEQ	INPDA3			;YES-GO ON
INPDAE:	CLR	DDLCIW#(R4)		;INDICATE INPUT ERROR
INPDA3:	BISB	#$RQIND,DDLCRQ#(R4)	;SET INPUT DONE REQUEST BIT
	MOVB	#.ISDED,DDLCIS#(R4)	;SET NEW INPUT STATE
	BR	INPDS2			;THATS ALL

;HERE WHEN EXPECTING BYTE COUNT AND PACKET TYPE

INPCNT:	MOV	@DDLCIB#(R4),R0		;GET DATA
	CMPB	#PKCMAX,R0		;IS THE COUNT OK?
	BLO	SIZERR			;NO-TOO LARGE!
	TST	DDLCIK#(R4)		;DO WE HAVE A PACKET NOW?
	BNE	INPOVR			;YES-GO HANDLE THE OVERRUN
	PUSH	R1			;NO-SAVE R1
	MAKPKT	.PLOPT#			;GET A PACKET
	BCS	INPCGP			;IF CAN'T GET A PACKET!
	MOV	R1,DDLCIK#(R4)		;STORE ADDRESS OF PACKET
	ADD	#4,R1			;POINT TO FIRST DATA WORD
	MOV	R1,DDLCIP#(R4)		;STORE POINTER
	MOV	R0,-(R1)		;STORE COUNT AND PACKET TYPE
	MOV	R0,DDLCIX#(R4)		;INITIALIZE CHECK-SUM
	ADD	#3,R0			;CHANGE BYTE COUNT TO WORD COUNT
	ASRB	R0
	MOVB	R0,DDLCIC#(R4)		;STORE WORD COUNT
	POP	R1			;RESTORE R1
INPINC:	INCB	DDLCIS#(R4)		;BUMP INPUT STATE
	BR	INPDSM			;AND DISMISS INTERRUPT

;HERE IF CAN'T GET PACKET  (WE ARE PROBABLY IN BIG TROUBLE IF GET HERE!)

INPCGP:	MOV	#JIFO10#,R0		;SET UP TENTH SEC INT
	MOV	#10$,R1
	PUSH	SD			;SAVE DURING TIMREQ
	MOV	R4,SD			;WE NEED THE DDB TO GET RESTARTED AT 10$
	CALL	TIMREQ			;MAYBE THINGS WILL BE BETTER LATER
	POP	SD
	POP	R1			;RESTORE R1
	INC	DDERNP#(R4)		;COUNT THE ERROR
	BR	INPDS2			;RETURN FROM INTERRUPT
10$:	MOV	SD,R4			;GET DDB BACK
	MOV	(SP),R0			;GET RETURN ADDRESS
	CLR	(SP)			;CLEAR FAKE PSW
	PUSH	R0			;SAVE RETURN ADDRESS
	SUB	#4,SP			;ADD R4 AND R0 TO STACK
	BR	INPCNT			;TRY INPUTTING COUNT AGAIN

;HERE IF PACKET OVERRUN  (THIS MEANS THE OTHER END IS VERY MIXED UP!)

INPOVR:	INC	DDEROR#(R4)		;COUNT THE ERROR
	BR	INPDAE			;CONTINUE

;HERE IF THE WORD COUNT IS TOO LARGE

SIZERR:	INC	DDERSZ#(R4)		;COUNT THE ERROR
	BR	INPDAE			;CONTINUE

;HERE WHEN INPUT IS IDLE

INPIDL:	MOV	@DDLCIB#(R4),R0		;GET THE DATA
INPID2:	MOV	R0,DDLCIW#(R4)		;STORE FOR MAIN PROGRAM LEVEL
	BIC	#140000,R0		;YES-REMOVE EXTRA BITS
	CMP	#.FNPKT*400+PREFIX,R0	;IS THIS THE START OF A PACKET?
	BEQ	INPINC			;YES
	BR	INPDA3			;NO
	.PAGE
	.SBTTL	INPAC1 - Input ack for load mode

INPAC1:	MOV	@DDLCIB#(R4),R0		;Get the word
	BIC	#$SEQ,R0		;Zap sequence bit
	MOVB	#.ISDED,DDLCIS#(R4)	;Igore input till later
	CMP	#LODACK,R0		;Is it an ACK?
	BEQ	INPACK			;Yes? oh joy!
INPABT:	CLRB	DDLCRQ#(R4)		;Stop main
	CLRB	DDLCOS#(R4)		;Idle output
	BR	INPDSM			;Leave

INPACK:	MOVB	#$RQLOD,DDLCRQ#(R4)	;Make main get us the next one
	BR	INPDSM
	.PAGE
	.SBTTL	LKCMAI   - MAIN PROGRAM ROUTINES

;MAIN PROGRAM ROUTINE - CALLED ONCE EACH TIME THRU THE MAIN PROGRAM LOOP
;	CALL	LKCMAI

	MAINXX	LKCMAI			;INSERT CALL INTO THE MAIN PROGRAM LOOP

LKCMAI:	MOV	#LKCDDB#,R4		;POINT TO FIRST TYPE C DDB
2$:	MOVB	DDLCRQ#(R4),R0		;GET REQUEST BITS
	CALL	@DISP(R0)			;Dispatch
	MOV	DDLKNS#(R4),R4		;STEP TO NEXT TYPE C DDB
	BNE	2$			;GO ON IF MORE
RTN002:	RETURN				;FINISHED

;Dispatch table for main program

	PURE

DISP:	.WORD	RTN002			;	= 0 - IDLE
	.WORD	LKCIND			;$RQIND = 2 - INPUT DONE
	.WORD	OUTDON			;$RQOUD = 4 - OUTPUT DONE
	.WORD	OUTDON			;	= 6 - INPUT AND OUTPUT DONE
	.WORD	LKCLDM			;$RQLOD =10 - Main level load entry

	CODE

;HERE IF INPUT DONE

LKCIND:	BICB	#$RQIND,DDLCRQ#(R4)	;CLEAR INPUT DONE REQUEST
	MOVB	#40.,DDLCTM#(R4)	;RESET MESSAGE TIMER
	MOV	DDLCIW#(R4),R0		;GET HEADER WORD
	CMPB	#PREFIX,R0		;CHECK FOR PREFIX VALUE
	BNE	ILLFUN			;PANIC IF NOT RIGHT!
	TBBE	$FNACK*400,R0,LKCIN4	;GO ON IF NOT ACK
	TST	DDLCOK#(R4)		;ACK-ARE WE EXPECTING IT?
	BNE	LKCIN1			;YES-GO ON
	INC	DDERPC#(R4)		;NO-COUNT THE ERROR
	BR	LKCIN4			;AND IGNORE IT

;HERE WITH ACK WHICH WE ARE EXPECTING NOW

LKCIN1:	CLRB	DDLCTD#(R4)		;CLEAR DATA TIMER
	PUSH	R0			;SAVE FUNCTION WORD
	TBBE	$FNHLD*400,R0,PKTDON	;SHOULD WE HOLD IT?

;HERE WHEN PACKET OUTPUT IS FINISHED BUT SHOULD NOT SEND ANY MORE PACKETS ON
;  THIS SOCKET

PKTHLD:	MOV	DDLCOD#(R4),SD		;GET ADDRESS OF SDB
	BEQ	PKTDN1			;IF NO SDB
	TSTB	SDSOC#(SD)		;SOCKET 0?
	BNE	PKTDN1			;NO-GO ON
	BR	PKTDN0			;YES-DON'T HOLD IT OFF!

;HERE WHEN PACKET OUTPUT IS FINISHED (HAVE RECEIVED ACK FROM OTHER END OF THE
;  LINK)

PKTDON:	MOV	DDLCOD#(R4),SD		;GET SDB ADDRESS
	BEQ	PKTDN1			;IF NONE
	CLR	DDLCOD#(R4)
PKTDN0:	BIC	#$S1HLD,SDSTS1#(SD)	;INDICATE NOT HELD NOW
	TST	SDPKDH#(SD)		;ANY MORE PACKETS TO SEND?
	BEQ	PKTDN1			;NO-GO ON
	CALL	LKPOK0#			;YES-PUT SDB ON THE SEND LIST
PKTDN1:	MOV	DDLCOK#(R4),R1		;POINT TO THE PACKET
	BEQ	2$			;IF NO PACKET!
	CLR	DDLCOK#(R4)
	CALL	GIVPKT#			;GIVE UP THE PACKET
2$:	BIC	#$D1ACP,DDSTS1#(R4)	;INDICATE PACKET OUTPUT NOT ACTIVE NOW
	TBBN	$D1ACH,DDSTS1#(R4),LKCIN3;IS HARDWARE ACTIVE NOW?
	CALL	OUTDN2			;NO-SEE IF MORE OUTPUT TO DO NOW
LKCIN3:	POP	R0			;RESTORE INPUT WORD

;HERE AFTER PROCESSING ACK (IF ANY)

LKCIN4:	SWAB	R0			;GET FUNCTION
	BIC	#^C17,R0		;REMOVE JUNK
	CMP	#3,R0			;LEGAL FUNCTION?
	BLO	ILLFUN			;NO-PANIC!
	ASL	R0			;YES-DISPATCH ON IT
	ADD	R0,PC
	BR	LKCIFN			;.FNNOP = 0 - NO-OP
	BR	LKCRST			;.FNRST = 1 - RESET LINK
	BR	LKCRSA			;.FNRSA = 2 - RESET ACK
;	BR	INPRDY			;.FNPKT = 3 - START OF PACKET

;HERE WITH INPUT PACKET

INPRDY:	MOV	DDLCIK#(R4),R1		;GET PACKET ADDRESS
	BEQ	ILLFUN			;JUST TO BE SAFE!
	CLR	DDLCIK#(R4)		;CLEAR THE POINTER
	PUSH	R4			;SAVE ADDRESS OF OUR DDB
	CALL	MOVPKT#			;SEND THE PACKET ON (ALSO SETS UP SD)
	POP	R4			;RESTORE DDB ADDRESS
	MOV	#$FNACK*400,R0		;GET ACK BIT
	TSTB	SDSOC#(SD)		;SUPERVISORY PACKET?
	BEQ	INPRD3			;YES
	CMPB	SDPMAX#(SD),SDPCNT#(SD)	;NO-HAVE TOO MANY PACKETS NOW?
	BHIS	INPRD3			;NO
	BIS	#$FNHLD*400,R0		;YES-STOP HIM FOR A WHILE!
	BIS	#$S1STP,SDSTS1#(SD)	;INDICATE WE HAVE BEEN STOPPED
INPRD3:	TBBE	$D1ACT,DDSTS1#(R4),6$	;GO ON IF NOT ACTIVE
	SWAB	R0			;ACTIVE
	MOVB	R0,DDLCXA#(R4)		;STORE ACK/NAK BITS
	BR	LKCIFN			;THATS ALL

;HERE IF OUTPUT NOT ACTIVE

6$:	CALL	PUTACK			;OUTPUT ACK
	BR	LKCIFN			;THATS ALL

;HERE ON ILLEGAL INPUT

ILLFUN:	INC	DDERPC#(R4)		;COUNT THIS AS A PROTOCOL ERROR
INPPAN:	CALL	LKCDWN			;PUT THE LINK DOWN
	BR	LKCIF2			;THATS ALL


;HERE WITH RESET ACK FUNCTION

LKCRSA:	TBBE	$D1DWN,DDSTS1#(R4),LKCIFN;IS THE LINK DOWN NOW?
	CALL	LNKUP#			;YES-BUT NOT ANY LONGER!
	BR	LKCIFN			;THATS ALL

;HERE WITH RESET FUNCTION

LKCRST:	TBBE	$D1DWN,DDSTS1#(R4),INPPAN;PANIC IF WE ARE UP NOW!
	CALL	LNKUP#			;OTHERWISE COME UP
	MOV	#<.FNRSA*400>+PREFIX,R0	;SEND BACK RESET ACK
	CALL	PUTFNC
LKCIFN:	CLRB	DDLCIS#(R4)		;RESET INPUT STATE
	BIS	#$DVACP!$DVENB,@DDLCSR#(R4);ACCEPT LAST INPUT WORD
LKCIF2:	BITB	#$RQOUD,DDLCRQ#(R4)	;OUTPUT REQUEST NOW?
	BNE	OUTDON			;YES
	RETURN				;No
	.PAGE
	.SBTTL	LKCDON - OUTPUT DONE

;HERE WHEN OUTPUT IS FINISHED

OUTDON:	BICB	#$RQOUD,DDLCRQ#(R4)	;CLEAR OUTPUT DONE REQUEST
	CLRB	DDLCTD#(R4)		;NO-CLEAR THE DATA TIMER
	BIC	#$D1ACH,DDSTS1#(R4)	;CLEAR HARDWARE ACTIVE BIT
	TBBN	$D1ACP,DDSTS1#(R4),OUTDN4;IS PACKET OUTPUT STILL ACTIVE?
OUTDN2:	CALL	NXTPKT#			;GET ANOTHER PACKET
	BCS	OUTDN4			;If none go on to next
	BEQ	LKCST0			;If supervisory packet

	CALL	DECPCN#			;Drop our P count
	CALL	REMOVE#			;Remove packet from DST list
	CBR	LKCSTR			;Send the packet on and return
					;Fall into LKCSTR

;SUBROUTINE CALLED WHEN A PACKET IS READY FOR A LINK WHICH HAS BEEN STOPPED
;  BY A NO-PACKET RETURN FROM NXTPKT
;	C(R1) = ADDRESS OF PACKET
;	C(R4) = ADDRESS OF DDB
;	C(SD) = ADDRESS OF DDB
;	CALL	LKCSTR
;	C:SET = ALWAYS (ALWAYS STARTS OUTPUT WHEN CALLED!)

LKCSTR::CALL	LKCST0			;Start output
	MOV	SDPKDH#(SD),R1		;Is there more to output now?
	BEQ	6$			;No
	CALL	CHKRSP#			;Yes-can we send it now?
	BMI	6$			;No
	CALL	LKPOK0#			;Yes-put SDB on the send list
6$:	CLC				;Be safe and clear C here!
	RETURN				;Thats all
	.PAGE
;HERE IF NO PACKETS TO OUTPUT NOW

OUTDN4:	CLR	R0			;NEED ACK NOW?
	BISB	DDLCXA#(R4),R0
	BEQ	OUTDN7			;NO
	CLRB	DDLCXA#(R4)		;YES
	SWAB	R0
PUTACK:	BIS	#<.FNNOP*400>+PREFIX,R0	;ADD NO-OP FUNCTIN TO ACK BITS
PUTFNC:	MOVB	#.OSFIN,DDLCOS#(R4)	;SET OUTPUT STATE
	BIS	#$D1ACT!$D1ACH,DDSTS1#(R4);INDICATE HARDWARE IS ACTIVE
	BR	PUTWRD			;OUTPUT THE WORD AND RETURN

;HERE IF NOTHING TO DO NOW

OUTDN7:	TBBN	$D1ACP,DDSTS1#(R4),4$	;ARE WE OUTPUTTING A PACKET NOW?
	BIC	#$D1ACT!$D1ACH!$D1ACP,DDSTS1#(R4);NO-LINK NOT ACTIVE NOW
4$:	RETURN
	.PAGE
	.SBTTL	LKCST0 - START OUTPUT

;Next level subroutine to start output - does everything except put socket
;  back on the send list if necessary

LKCST0:	BIS	#$S1HLD,SDSTS1#(SD)	;INDICATE THIS SOCKET IS BEING HELD!
	MOV	SD,DDLCOD#(R4)		;STORE ADDRESS OF SDB
	MOVB	SDSOC#(SD),PKSOC(R1)	;STORE SOCKET NUMBER IN PACKET
	MOV	R1,DDLCOK#(R4)		;STORE ADDRESS OF PACKET
	CLR	R0			;GET BYTE COUNT
	BISB	PKCNT(R1),R0
	ADD	#3,R0			;CONVERT TO WORDS + 1
	ASR	R0
	MOVB	R0,DDLCOC#(R4)		;STORE TOTAL WORD COUNT
	ADD	#2,R1			;POINT TO FIRST WORD TO SEND
	MOV	R1,DDLCOP#(R4)		;SET OUTPUT POINTER
	CLR	R0			;GET ACK/NAK BITS (IF ANY)
	BISB	DDLCXA#(R4),R0
	CLRB	DDLCXA#(R4)		;CLEAR THEM
	SWAB	R0
	BIS	#<.FNPKT*400>+PREFIX,R0	;MERGE IN BEGINNING OF PACKET FUNCTION
	MOVB	#.OSCNT,DDLCOS#(R4)	;SET NEW OUTPUT STATE
	BIS	#$D1ACT!$D1ACH!$D1ACP,DDSTS1#(R4);INDICATE LINK IS ACTIVE
PUTWRD:	MOV	R0,@DDLCOB#(R4)		;OUTPUT DATA WORD
	BIS	#$DVOUT!$DVENB,@DDLCSR#(R4);SET HARDWARE BITS
	MOVB	#3,DDLCTD#(R4)		;START THE DATA TIMER
RTN004:	RETURN				;THATS ALL
	.PAGE
	.SBTTL	LKCLDM - Load level for main

LKCLDM:	MOV	DDLCOK#(R4),R1		;Get the old packet if any
	BEQ	1$			;None
	CLR	DDLCOK#(R4)		;Clear old pointer
	FREPKT
1$:	CALL	NXTLOD#			;Get the next to send
;	BR	LKCLOD			;Fall into LKCLOD
	.PAGE
	.SBTTL	LKCLOD   - DOWN-LINE LOADING ROUTINES

;SUBROUTINE TO CONTROL DOWN-LINE LOADING
;	C(R0) = FUNCTION
;	C(R4) = ADDRESS OF DDB
;	CALL	LKCLOD

LKCLOD::JMP	@DSPLOD(R0)		;Jump on load state

	PURE
DSPLOD:	.WORD	RTN004			; 0 = No data
	.WORD	LKCDAT			; 2 = Normal load data
	.WORD	LKCELM			; 4 = Enter load mode
	.WORD	LKCTLM			; 6 = Terminate load mode
	.WORD	LKCLDP			; 10= Load mode poke
	CODE

;Here for function = 2 - Load data

LKCDAT:	MOV	R1,DDLCOK#(R4)		;Save the packet pointer
	CLR	R0
	BISB	PKCNT(R1),R0		;Get the character count
	ASR	R0			;Make into word count
	DEC	R0			;Minus the word we send
	MOVB	R0,DDLCOC#(R4)		;Save word count
	ADD	#PKDATA,R1		;Point to the data
	MOV	(R1)+,R0		;Get the word to send
	MOV	R1,DDLCOP#(R4)		;Save the out pointer
	MOVB	#.OSLOD,DDLCOS#(R4)	;Tell output service what to do
	MOVB	#.ISAC1,DDLCIS#(R4)	;Tell input what to expect
	CLRB	DDLCRQ#(R4)		;We go idle
	MOVB	#10.,LKCTNS		;Hold of the reset stuff for 10 secs
	CLR	@DDLCSR#(R4)		;Clear the CSR so setting $DVOUT will work
	CBR	PUTWRD			;Send the first one

;Here for function = 4 - Enter load mode

LKCELM:	MOVB	#$RQLOD,DDLCRQ#(R4)	;Tell main we are now loading
	MOVB	#.ISDED,DDLCIS#(R4)	;Stop input
	CLRB	DDLCOS#(R4)		;No output
	RETURN

;Here for function = 6 - Leave load mode

LKCTLM:	CLRB	DDLCRQ#(R4)		;Stop main
	MOVB	#.ISRST,DDLCIS#(R4)	;Wait for resets
	CLRB	DDLCOS#(R4)		;No output
	MOV	DDLCOK#(R4),R1		;Any packets laying around?
	BEQ	1$
	CLR	DDLCOK#(R4)		;
	FREPKT
1$:	RETURN
	.PAGE
	.SBTTL	LKCLDP - Load mode poke

LKCLDP:	RETURN				;We dont need this entry right
					;now
	.PAGE
	.SBTTL	LKCSEC - ONCE-A-SECOND ROUTINES

	ONCSEC	LKCSEC

LKCSEC:	MOV	#LKCDDB#,R4		;GET ADDRESS OF FIRST TYPE A DDB
1$:	TBBN	$D1UNV!$D1DIS!$D1OFF,DDSTS1#(R4),26$;SHOULD WE USE THIS INTERFACE?
	TSTB	DDLCTD#(R4)		;YES-IS THE DATA TIMER ACTIVE?
	BEQ	2$			;NO-GO ON
	DECB	DDLCTD#(R4)		;YES-HAS IT RUN OUT?
	BLE	10$			;YES
2$:	TSTB	DDLCTM#(R4)		;NO-IS MESSAGE TIMER ACTIVE?
	BEQ	12$			;NO-GO ON
	DECB	DDLCTM#(R4)		;YES-HAS IT RUN OUT?
	BGT	12$			;NO
10$:	TBBN	$NSNOT,NODSTS#,12$	;BRANCH IF SHOULDN'T TIME-OUT
	CALL	LKCDWN			;YES-MARK THIS LINK DOWN
12$:;	MOV	DDLKNS#(R4),R4		;STEP TO NEXT TYPE A LINK DDB
;	BNE	1$			;CONTINUE IF MORECB	LKCTNS			;TIME FOR EVERY TEN SECONDS STUFF?
	TSTB	LKCTNS			;TIME FOR EVERY TEN SECONDS STUFF?
;	BGT	RTN004			;NO-FINISHED FOR THIS TIME
	BGT	26$			;NO-FINISHED FOR THIS TIME
;	MOVB	#10.,LKCTNS		;YES-RESET COUNTER
;	MOV	#LKCDDB#,R4		;GET FIRST TYPE C DDB
22$:;	TBBN	$D1DIS!$D1OFF,DDSTS1#(R4),26$	;SKIP THIS IF DISABLED
	TBBN	$D1DWN,DDSTS1#(R4),24$	;IF LINK IS DOWN

;HERE IF LINK IS UP

	TBBN	$D1ACT,DDSTS1#(R4),26$	;NOTHING NEEDED IF ACTIVE
	MOV	#<.FNNOP*400>+PREFIX,R0	;SEND NO-OP
	CALL	PUTFNC
	BR	26$			;CONTINUE

;HERE IF LINK IS DOWN

24$:	BIC	#$DVOUT,@DDLCSR#(R4)	;CLEAR INTERRUPT BIT
	MOV	#<.FNRST*400>+PREFIX,@DDLCOB#(R4);OUTPUT RESET MESSAGE
;	TBBE	100200,@DDLCSR#(R4),25$	;IS THE INTERRUPT TO US ON?
;	CMP	#-1,@DDLCIB#(R4)	;YES, AND IS THE CABLE HANGING LOOSE
;	BEQ	26$			;YES DON'T DO ANYTHING
	CMP	#<.FNRSA*400>+PREFIX,@DDLCIB#(R4) ;SENDING US AN ACK?
	BEQ	25$			;YES, HANDLE IT
	CMP	#<.FNRST*400>+PREFIX,@DDLCIB#(R4) ;SENDING US A RESET
	BNE	26$			;NO, IGNORE FOR NOW
25$:	BIS	#$DVOUT!$DVENB,@DDLCSR#(R4) ;SET INTERRUPT BIT
26$:	MOV	DDLKNS#(R4),R4		;STEP TO NEXT TYPE C DDB
	BNE	1$			;CONTINUE IF MORE
	DECB	LKCTNS			;TIME FOR EVERY TEN SECONDS STUFF?
	BGE	28$			;NO-FINISHED FOR THIS TIME
	MOVB	#10.,LKCTNS		;YES-RESET COUNTER
28$:	RETURN				;FINISHED
	.PAGE
	.SBTTL	LOCAL SUBROUTINES

;SUBROUTINE TO MARK LINK AS DOWN
;	C(R4) = ADDRESS OF DDB
;	CALL	LKCDWN

LKCDWN:	CLR	@DDLCSR#(R4)		;DISABLE THE INTERFACE
	MOV	DDLCOK#(R4),R1		;GET OUTPUT PACKET
	BEQ	2$			;GO ON IF NONE
	CLR	DDLCOK#(R4)
	MOV	DDLCOD#(R4),SD		;GET ITS SDB
	CALL	GIVPKT#			;GIVE IT UP
2$:	MOV	DDLCIK#(R4),R1		;GET INPUT PACKET
	BEQ	4$			;GO ON IF NONE
	CLR	DDLCIK#(R4)
	FREPKT				;GIVE IT UP
4$:	CLRB	DDLCTD#(R4)		;CLEAR TIMERS
	CLRB	DDLCTM#(R4)
	MOVB	#.ISRST,DDLCIS#(R4)	;RESET INPUT STATE
	CLRB	DDLCOS#(R4)		;CLEAR OUTPUT STATE
	CLRB	DDLCXA#(R4)		;CLEAR ACK/NAK BITS
	BIC	#$D1ACT!$D1ACH!$D1ACP,DDSTS1#(R4);CLEAR ACTIVE FLAGS
	CALL	LNKDWN#			;MARK AS DOWN AT LINK LEVEL
	BIS	#$D1DIS,DDSTS1#(R4)	;INDICATE DISABLED
	MOV	#JIFX10#,R0		;Wait for 10 seconds
	MOV	#LKCAGN,R1
	MOV	R4,SD
	CALL	TIMREQ#
	BCC	RTN009			;WAIT IF REQUEST WAS ENTERED

;HERE AFTER 10 SECOND DELAY

LKCAGN:	BIC	#$D1DIS,DDSTS1#(SD)	;INDICATE ENABLED
RTN009:	RETURN				;FINISHED NOW
	.PAGE
	.SBTTL	DATA

	IMPURE

LKCTNS:	.WORD	0			;TEN SECOND COUNTER

	.END
e ,Å