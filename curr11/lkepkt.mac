
	.TITLE	LKEPKT		- X.25 packet level translation
	.SBTTL	LKEPKT		- Definitions

	XLPAR

;-----
; Packet "class" identification bits
;-----
$DATA	=! $BIT00			; Data packet indicator bit
$SUPV	=! $BIT01			; Supervisory packet indicator bit
$MBIT	=! $BIT04			; More data bit
$QBIT	=! $BIT07			; Qualified data bit

;-----
; SDB flag bits (in SDLES1)
;-----
$X1UNO	=! $BIT15			; Unnumbered packet outstanding
$X1JTX	=! $BIT14			; Junk data packets to X.25 port
$X1JFX	=! $BIT13			; Junk data packets from X.25 port
$X1RSO	=! $BIT12			; Restart packet outstanding
$X1X25	=! $BIT07			; X.25-TO-X.25 circuit within a Micronet

;-----
; Constants - base for modulus arithmetic and bit mask for remaindering
;-----
.MODP	=! 10				; Modulus base for arith on P(R), P(S)
$MASKP	=! ^C<.MODP-1>			; Mask for performing modulus arith on
					;   P(R), P(S)
;-----
; Constants - shift counts
;-----
.SHFPR	=! 5				; Shift count to position P(R) in pkt

;-----
; Constants - 1st X.25 header byte value
;-----
.LCG	=! $BIT04			; X.25 pkt logical channel group byte
					;   00010000 len = 1, LCG = 0

;-----
; X.25 packet type values
;-----
.XDATA	=! 000				; X.25 data packet "type"
.XRR	=! 001				; X.25 RR packet type
.XRNR	=! 005				; X.25 RNR packet type
.XREJ	=! 011				; X.25 DTE REJ packet type
.XCARQ	=! 013				; X.25 Call Request packet type
.XCACF	=! 017				; X.25 Call Confirmation packet type
.XCLRQ	=! 023				; X.25 Clear Request packet type
.XCLCF	=! 027				; X.25 Clear Confirmation pkt type
.XRERQ	=! 033				; X.25 Reset Request packet type
.XRECF	=! 037				; X.25 Reset Confirmation packet type
.XINTR	=! 043				; X.25 Interrupt packet type
.XITCF	=! 047				; X.25 Interrupt Confirmation pkt type
.XDIAG	=! 361				; X.25 pkt type
.XRSRQ	=! 373				; X.25 Restart Request packet type
.XRSCF	=! 377				; X.25 Restart Confirmation packet type

;-----
; X.25 clear cause code
;-----
.XCCDO	=	000	;DTE originated
.XCCNB	=	001	;Number busy
.XCCOO	=	011	;Out of order
.XCCRE	=	021	;Remote procedure error
.XCCRX	=	031	;Reverse charging not subscribed
.XCCID	=	041	;Incompatible destination
.XCCFX	=	051	;Fast select not subscribed
.XCCIF	=	003	;Invalid facility request
.XCCAB	=	013	;Access barred
.XCCLE	=	023	;Local procedure error
.XCCNC	=	005	;Network congestion
.XCCNO	=	015	;Not obtainable
.XCCRO	=	025	;RPOA out of order

;-----
; X.25 Reset Cause Code
;-----
.XRCDO	=	!000	;DTE originated
.XRCOO	=	!001	;Out of order
.XRCRE	=	!003	;Remote procedure error
.XRCLE	=	!005	;Local procedure error
.XRCNC	=	!007	;Network congestion
.XRCRO	=	!011	;Remote DTE operational
.XRCNO	=	!017	;Network operational
.XRCID	=	!021	;Incompatible destination

;-----
; X.25 Restart Cause Code
;-----
.XSCDO	=	!000	;DTE originated
.XSCLE	=	!001	;Local error
.XSCNC	=	!003	;Network congestion
.XSCNO	=	!007	;Network operational

;-----	
; X.25 Diagnostic Code 
;-----
.XDNUL	=	000	;No additional information
.XDIPS	=	001.	;Invalid P(S)
.XDIPR	=	002.	;Invalid P(R)
;
.XDPNA	=	032.	;Packet not allowed
.XDUFO	=	033.	;Unidentifiable packet
.XDCOW	=	034.	;Call on one-way channel (in the wrong direction)
.XDIPP	=	035.	;Invalid packet type on PVC
.XDPUC	=	036.	;Packet on unassigned channel
.XDRNS	=	037.	;Reject not subscribed (probably will never be offered)
.XDPTS	=	038.	;Packet too short
.XDPTL	=	039.	;Packet too long
.XDIGF	=	040.	;Invalid general format identifier
.XDBRS	=	041.	;Restart on non-zero logical channel
.XDPNF	=	042.	;Packet type not compatible with facility
.XDUIC	=	043.	;Unauthorized interrupt confirmation
.XDUIT	=	044.	;Unauthorized interrupt
;
.XDTMO	=	048.	;Time-out
.XDTOC	=	049.	;Time-out on call
.XDTOL	=	050.	;Time-out on clear
.XDTOR	=	051.	;Time-out on reset
.XDTOS	=	052.	;Time-out on restart
;
.XDCSP	=	064.	;Call setup problem
.XDFCN	=	065.	;Facility code not allowed
.XDFPN	=	066.	;Facility parameter not allowed
.XDICD	=	067.	;Invalid called address
.XDICG	=	068.	;Invalid calling address

;-----
; Constants - packet send ahead window size
;-----
;  .W	=! 2				; Packet level flow control window
	.PAGE
	CODE
;----- 
; DEFINE A MACRO TO FETCH 4 BITS POINTED BY R0, CHECK FOR VALID BCD DIGIT,
;	CONVERT THEM TO ASCII CODE, AND STORE TO THE BYTE POINTED BY R1.
;-----
	.MACRO	GETNIB
	CALL	GETNB
	.ENDM

GETNB:	COMB	ADRFLG		;FLIP THE BITS OF ADRFLG FOR EACH DIGIT
				;ON BYTE BOUNDARY ?
	BEQ	10$		;NO, BRANCH
	MOVB	(R0),R3
	ASHI	-4,R3		;YES, SHIFT HIGH ORDER 4 BITS RIGHT BY 4.
	BR	20$
10$:	MOVB	(R0)+,R3	;FINISHED WITH THIS BYTE, POINTS TO NEXT
20$:	BIC	#^C17,R3	;ISOLATE THE LOWER FOUR BITS
	CMP	R3,#9.		;LEGAL ?
	BGT	30$		;NO, BRANCH
	CLC			;
	RETURN
30$:	SEC
	RETURN

;-----
; DEFINE A MACRO TO CONVERT A BCD NIBBLE STORED IN THE LEAST SIGNIFICANT 4
;  BITS TO ASCII AND STORED IN A BYTE POINTED BY R1
;-----
	.MACRO	PUTBYT
	ADD	#'0,R3		;BCD TO ASCII
	MOVB	R3,(R1)+	;AND STORE IT
	.ENDM

;-----
; MACRO TO STORE THE BCD NIBBLE IN R3 TO THE NIBBLE POINTED BY R1 AND
;  ADRFL1.
; IF BITS OF ADRFL1 = 1 THEN
;	STORE THE BCD IN THE LOW  NIBBLE (THE 4 L.S.Bits OF A BYTE)
; OTHERWISE
;	STORE THE BCD IN THE HIGH NIBBLE (THE 4 M.S.Bits OF A BYTE)
; UPDATE ADRFL1 AND R1 IF NECESSARY
;-----
	.MACRO	PUTNIB
	CALL	PUTNB
	.ENDM

PUTNB:	COMB	ADRFL1		;ALWAYS SET THE FLAG
				;HIGH/LOW NIBBLE TO STORE ?
	BEQ	10$		;LOWER ONE, BRANCH
	ASHI	4,R3		;SHIFT LEFT BY 4 
	BISB	R3,(R1)		;STORE THE BCD WITHOUT BUMPING R1
	BR	20$
10$:	BISB	R3,(R1)+	;STORE THE BCD WITHOUT SHIFTING; BUMP R1
20$:
	RETURN

;-----
; MACRO TO FETCH AN ASCII CHARACTER (@R0), CHECK IT FOR A VALID DIGIT, CONVERT
;  IT TO BCD AND RETURN IT IN THE LEAST SIGNIFICANT 4 BITS OF R3
;-----
	.MACRO	GETBYT
	CALL	GETBT
	.ENDM

GETBT:
	CLR	R3
	BISB	(R0)+,R3
	CMP	R3,#'0		;GREATER THAN 0 ?
	BLO	10$		;NO, TOO BAD
	CMP	R3,#'9		;YES. LESS THAN 9?
	BHI	10$		;     NO.
	BIC	#60,R3		;ASCII -> BCD
	CLC
	BR	20$
10$:	SEC
20$:	RETURN


	.PAGE
	.SBTTL	LKENXT - Get NEXILIS packet, translate to X.25 and send
;-----
; LKENXT - Subroutine to get the next packet from the node to send on the link
;
; Linkage:
;	C(R4) = Address of DDB
;
;	CALL LKENXT
;
; Unpreserved registers:
;	R0, R1, R2, R3
;-----
LKENXT::MOV	DDLEAH#(R4),R1		; Get send back message header
	BEQ	2$			; Nothing there - get next packet

	MOV	(R1),DDLEAH#(R4)	; Update send back message head
	BNE	1$			; Another message pending
	CLR	DDLEAT#(R4)		; List empty - clear tail
1$:	JMP	XMTPKT			; Insert this message in Xmit Ring

;-----
; No messages were buffered for send back - get next packet from packet service
;-----
2$:	CALL	NXTPKT#			; Get next packet from pkt service
	BCS	3$			; Quit if nothing to get
	CALL	LKESTR			; Got a packet - Xlate and Xmit
	BCS	2$			; Get next packet if no output done
	RETURN				; Return if output was started

3$:	BIC	#$D1ACT,DDSTS1#(R4)	; Declare link inactive
	RETURN				; Return to caller
	.PAGE
	.SBTTL	LEPOKE - Poke entry for link type E
;-----
; LEPOKE - called when packet linked to empty destination list
;-----
LEPOKE::TBBE	$D1DWN,DDSTS1#(R4),LEPOK1 ; Is link up?
	JMP	LKPDWN#			; Link down - fail

LEPOKC:	MOV	SDPKDH#(SD),R1		; Get destination list header
	BEQ	RTN004			; Return if nothing there

LEPOK1:	MOVB	PKTYPE(R1),R0		; Get packet type
	TSTB	TYPBTS(R0)		; Test the bits
	BEQ	1$			; If want full flow control
	BMI	2$			; If no flow control
	TBBN	$X1UNO,SDLES1#(SD),RTN004 ; Interrupt - interrupt outstanding?
	BIS	#$X1UNO,SDLES1#(SD)	; No - but it is now
	BR	2$			; Continue

;-----
; Here for packet which requires full flow control checking
;-----
1$:	CMPB	SDACNT#(SD),SDPMAX#(SD)	; Room for another packet?
	BGE	RTN004			; No - forget about it
2$:	JMP	LKPOKE#			; Yes - go start it out

;-----
; Table of packet type status bits
;
;	200 = No flow control at all
;	100 = "Interrupt" type packet
;	000 = Full flow control
;-----
	PURE

TYPBTS:	.BYTE	000		; .PTDAT =  0 - Data
	.BYTE	200		; .PTCON =  1 - Connect
	.BYTE	200		; .PTACK =  2 - Connect ACK
	.BYTE	200		; .PTNAK =  3 - Connect NAK
	.BYTE	000		; .PTFUN =  4 - Function
	.BYTE	100		; .PTINT =  5 - Interrupt
	.BYTE	000		; .PTEAT =  6 - Eat
	.BYTE	200		; .PTDIS =  7 - Disconnect
	.BYTE	200		; .PTKIL = 10 - Kill
	.BYTE	200		; .PTDAK = 11 - Disconnect ACK
	.BYTE	200		; .PTRVR = 12 - Recover
	.BYTE	200		; .PTRTY = 13 - Retry
	.BYTE	000		; .PTPAC = 14 - Packet ACK

	CODE
	.SBTTL	LERSUM - Resume entry for link type E
;-----
; LERSUM - called to resume packet output
;-----
LERSUM::TSTB	SDLERR#(SD)		; Any pending RR's?
	BNE	5$		;Yes, outstanding xpk exists
	FSTOP	BRR		;[Bad X.25 RR]
;	JMP	CRESET		;Error, Reset the channel
5$:	CMPB	SDLERR#(SD),SDPMAX#(SD)	; Was window closed?
	BLO	10$			; LO, no,
	INCB	SDLEPR#(SD)		; Our duty to open it
10$:	DECB	SDLERR#(SD)		; Yes - reduce RR count

; Here to decide piggyback or RR to send back P(R)
	MOVB	SDLEPR#(SD),R0		; Get P(R) for channel
	BIC	#$MASKP,R0		; Perform modulus arithmetic
	MOVB	R0,SDLEPR#(SD)		; Update P(R)
	CMPB	SDLEPR#(SD),SDLEXR#(SD)	; Is P(R) already piggyback out?
	BEQ	RTN004			; Eq, yes, just return
	ASHI	.SHFPR,R0		; Shift P(R) into position for RR pkt
	BIS	#.XRR,R0		; Get RR packet type
	CLR	R2			; No data field
	JMP	SNDBAK			; Send RR xpk
RTN004:	RETURN				; 

;+++++++
; The following two instructions are added to make up for the differences
;  between the X.25 flow control mechanism and that of Micronet.
; Since an X.25 data packet can be broken into several Micronet data packets
;  and a Resume Request is made whenever a packet is removed from the linked
;  SDB, the following check must be made before an RR packet can be queued
;  to this SDB.						10/15/82  IW

;	CMPB	SDPCNT#(SD),SDPMAX#(SD)	; If send-ahead count is too high
;	BHI	RTN004			;    then just return
;-------
;	DECB	SDLERR#(SD)		; Yes - reduce RR count
;	INCB	SDFCNT#(SD)		; Bump flag count
;	CMP	#-1,SDLKFL#(SD)		; Already in flag list?
;	BNE	RTN004			; Yes - nothing more needed
;
;	MOV	DDLKFT#(R4),R2		; No - get last SDB in list
;	BNE	1$			; Not empty
;
;	MOV	SD,DDLKFH#(R4)		; Empty - put on head
;	BR	2$
;
;1$:	MOV	SD,SDLKFL#(R2)		; Link on tail of list
;2$:	MOV	SD,DDLKFT#(R4)		; Update tail pointer
;	CLR	SDLKFL#(SD)		; Clear forward link
;	TBBN	$D1ACT,DDSTS1$(R4),RTN004 ; Thats all if link is active now
;
;	CALL	NXTCFR#			; Find a flag packet to send
;	BCC	3$			; Go on if got one
;	FSTOP	CFF			; [Can't Find Flag] but just set one!
;	BCS	RTN004			; Must be low on free packets, try 
					;  later.

;3$:	CJMP	@DDLKST#(R4)		; Start the link and return

	.PAGE
	.SBTTL	LKEFLG - Flag packet processing for NXTPKT
;-----
; LKEFLG - subroutine called by NXTPKT to generate an X.25 RR packet equivalent
;
;	C(R1) = address of packet to use
;	C(R4) = address of DDB
;	C(SD) = address of first SDB on flag list
;
;	CALL	LKEFLG
;
;	C:set = nothing to send
;	C(R1) = address of packet to send
;	C(SD) = address of SDB for packet
;-----
LKEFLG::
;	MOV	SDLKFL#(SD),DDLKFH#(R4)	; Update flag list head pointer
;	BNE	1$			; Anything left on list?
;	CLR	DDLKFT#(R4)		; No - clear tail pointer
;1$:	MOV	#-1,SDLKFL#(SD)		; Remove SBD from flag list
;	MOVB	SDFCNT#(SD),R0		; Get flag count - non-zero?
;	BNE	2$			; Yes - make an RR equivalent packet
;	MOV	DDLKFH#(R4),SD		; No - try next SDB
;	BNE	LKEFLG			; Continue until flag list all checked

	SEC				; No more - indicate no packet
	RETURN				; Return to caller

;-----
; Here on SDB with non-zero flag count
;-----
;2$:	CLRB	SDFCNT#(SD)		; Clear flag count
;	MOV	#.PTXRR*400+1,PKCNT(R1)	; Store packet type and count
;	MOVB	R0,PKDATA(R1)		; Store flag count in packet
;	CLC				; Indicate there is a packet
;	RETURN				; Return to caller
	.PAGE
	.SBTTL	LKESTR - Inactive link startup entry point
;-----
; LKESTR - Subroutine to start link output when inactive
;-----
LKESTR::
	MOVB	PKSEQ(R1),F51TMP	;--us701, for .FNX51 func pk only
	CLRB	PKSEQ(R1)		; CLEAR THE BYTE TO STORE P(R),M,P(S)
	CLR	R0			; Clear residue
	BISB	PKTYPE(R1),R0		; Get packet type of this packet
;	CMPB	R0,#.PTXRR		; Valid packet type?
	CMPB	R0,#.PTDAK		; Valid packet type?
	BHI	JNKX25			; No - discard packet
	ASL	R0			; Yes - convert to word index
	JMP	@NEXDSP(R0)		; Dispatch on NEXILIS packet type

;-----
; Packet dispatch for translating NEXILIS packets to X.25 packets
;-----
	PURE
	.EVEN

NEXDSP:	.WORD	DATPKT			; .PTDAT =  0 - Data
	.WORD	CONPKT			; .PTCON =  1 - Connection Request
	.WORD	ACKPKT			; .PTACK =  2 - Connection ACK
	.WORD	KILPKT			; .PTNAK =  3 - Connection NAK
	.WORD	FNCPKT			; .PTFUN =  4 - Function
	.WORD	INTPKT			; .PTINT =  5 - Interrupt
	.WORD	EATPKT			; .PTEAT =  6 - Eat
	.WORD	KILPKT			; .PTDIS =  7 - Disconnect
	.WORD	KILPKT			; .PTKIL = 10 - Kill
	.WORD	DAKPKT			; .PTDAK = 11 - Disconnect ACK
;	.WORD	JNKX25			; .PTRVR = 12 - Recover
;	.WORD	JNKX25			; .PTRTY = 13 - Retry
;	.WORD	JNKX25			; .PTPAC = 14 - Packet ACK
;	.WORD	JNKX25			; .PTXXX = 15 - Undefined
;	.WORD	JNKX25			; .PTXXX = 16 - Undefined
;	.WORD	JNKX25			; .PTXXX = 17 - Undefined
;	.WORD	JNKX25			; .PTXXX = 20 - Undefined
;	.WORD	XRRPKT			; .PTXRR = 21 - X.25 RR Equivalent

	CODE
	.SBTTL	NEXILIS to X.25 packet translation
;-----
; Here on ill-typed, non-translateable, or junked packets
;-----
JNKX25::CALL	GIVPKT#			; Give up the packet
JK1X25::CALL	LEPOKC			; See if window closed yet
	SEC				; Signal nothing was sent
	RETURN				; Return with failure

;-----
; Here on X.25 RR equivalent packet that Link E sent to itself
;-----
;XRRPKT:	MOVB	PKDATA(R1),R0		; Get number of packets to acknowledge
;	MOVB	SDLEPR#(SD),R2		; Get P(R) for channel
;	ADD	R2,R0			; Add # ACK's to P(R)
;	BIC	#$MASKP,R0		; Perform modulus arithmetic
;	MOVB	R0,SDLEPR#(SD)		; Update P(R)
;
;	CLRB	PKCNT(R1)		; No data bytes in RR packet
;	ASHI	.SHFPR,R0		; Shift P(R) into position for RR pkt
;	BIS	#.XRR,R0		; Get RR packet type
;	MOVB	R0,PKSEQ(R1)		; Store RR packet type byte
;	JMP	INSER1			; Go send packet (pkt type alrdy done)

;-----
; Here on data packet
;-----
DATPKT:	TBBN	$X1JTX,SDLES1#(SD),JNKX25 ; Discard packet if junking to X.25
	MOVB	#.LCG,PKTYPE(R1)	; Store logical channel group byte

	TBBE	$X1X25,SDLES1#(SD),X25DT1 ; BRANCH IF NOT X.25-TO-X.25
	MOV	#SDLESP#,R2		; GET OFFSET OF SAVED PACKET ADDRESS
	ADD	SD,R2			; POINTS TO SDLESP IN THE SDB
5$:
	MOV	(R2),R0			; GET PACKET POINTER
	BEQ	10$			; BRANCH IF NO PACKET
	MOV	R0,R2			; MAKE R2 POINT TO NEXT PACKET IN LIST
	BR	5$			; AND CHECK AGAIN
10$:
	MOV	R1,(R2)			; ADD THIS PACKET TO THE END OF LIST
	CJMP	LEPOKC			; AN X.25 MARKER FUNCTION PACKET WILL
					;  START SENDING THIS LIST OF DATA PACKETS.
;-----
; HERE TO SEND A LIST OF INTERNAL PACKET
;	ENTERED FROM PRECEEDING CODE, THE PAD MESSAGE PROCESSING MODULE(X25Q),
;	AND AFTER THE ARRIVAL OF AN X.25 MARKER FUNCTION PACKET.
;-----
X25DT1::
;	MOVB	SDFCNT#(SD),R0		; Get socket flag count
;	CLRB	SDFCNT#(SD)		; Clear flag count
;	MOVB	SDLEPR#(SD),R2		; Get P(R) for channel
;	ADD	R2,R0			; Add to # of new ACK's
;	BIC	#$MASKP,R0		; Perform modulus arithmetic
;	MOVB	R0,SDLEPR#(SD)		; Update P(R)

	MOVB	SDLEPR#(SD),R0		; Get P(R) for channel
	MOVB	R0,SDLEXR#(SD)		; XR# will be the P(R) sent
	ASHI	<.SHFPR-1>,R0		; Partially align P(R) for data pkt
	BISB	SDLEPS#(SD),R0		; Get P(S) for channel
	ASL	R0			; Position P(S) & P(R) in pkt type byte
	BISB	R0,PKSEQ(R1)		; Store data packet type byte

	INCB	SDLEPS#(SD)		; Bump P(S)
	BICB	#$MASKP,SDLEPS#(SD)	; Perform modulus arithmetic
	INCB	SDACNT#(SD)		; Bump send ahead count
	JMP	INSER2			; Go send packet (pkt type and LCG
					;   already done)

;-----
; HERE TO PROCESS A FUNCTION PACKET
;-----
FNCPKT:
;+--us701	;add call req function process here
	CMPB	PKDATA(R1),#.FNX51	;call request?
	BNE	5$			;NE, no, go check destination
	MOVB	F51TMP,PKDATA(R1)	;replace function code with the
			; length of called and calling address, which
			; borrows PKSEQ byte from LKESTR --us701
	MOVB	#.XCARQ,PKSEQ(R1)	;call request
	JMP	INSER1
5$:
;---us701
	TBBN	$X1X25,SDLES1#(SD),10$	;BRANCH IF IT IS X.25-TO-X.25
	JMP	FNCX25#
;-----
; HERE TO PROCESS A FUNCTION PACKET SENT FROM ANOTHER X.25 DEVICE, IT SHOULD
;  BE EITHER A X.25 MARKER OR A X.25 INTERRUPT CONFIRMATION PACKET
;-----
10$:
	CMPB	PKDATA(R1),#.FNXMK	;X.25 MARKER ?
	BNE	40$			;NO, BRANCH
	MOV	SDLESP#(SD),R0		;GET ADDRESS OF SAVED PACKETS
	BEQ	30$			;BRANCH IF NO DATA PACKET
	BISB	PKDATA+1(R1),PKTYPE(R0)	;ADD Q-BIT IF THERE IS ONE
	BISB	PKDATA+2(R1),PKSEQ(R0)	;ADD M-BIT IF THERE IS ONE
	CLR	SDLESP#(SD)		;CLEAR THE SAVED PACKETS POINTER
30$:
	CALL	PKTFRE			;FREE THE FUNCTION PACKET
	MOV	R0,R1			;GET SAVED DATA PACKETS
	BNE	X25DT1			;GO SEND THE PACKETS IN ONE FRAME
	RETURN				;RETURN IF NO SAVED PACKETS.
40$:
	CMPB	PKDATA(R1),#.FNXIC	;INTERRUPT CONFIRMATION?
	BNE	50$			;YES, BRANCH.
;-----
; HERE TO SEND A INTERRUPT CONFIRMATION PACKET
;-----
	MOVB	#.XITCF,PKSEQ(R1)	;INTERRUPT CONFIRMATION
	CLRB	PKCNT(R1)		;COUNT = 0
	JMP	INSER1
50$:
	FSTOP	IFP			;ILLEGAL FUNCTION PACKET
;-----
; HERE TO PROCESS AN INTERRUPT PACKET
;-----
INTPKT:
	TBBN	$X1X25,SDLES1#(SD),10$	;BRANCH IF X.25-TO-X.25
	JMP	INTX25#
10$:
	CMPB	PKDATA(R1),#.FNXIT	;X.25 INTERRUPT?
	BEQ	INTPKX			;BRANCH IF EQUAL
	FSTOP	IFP			;ILEEGAL FUNCTION PACKET
INTPKX::
	MOVB	PKDATA+1(R1),PKDATA(R1)	;STORE THE INTERRUPT USER DATA
	MOVB	#.XINTR,PKSEQ(R1)	;X.25 INTERRUPT 
	MOVB	#1,PKCNT(R1)		;COUNT=1 BYTE
	JMP	INSER1
;-----
; HERE TO PROCESS AN INTERRUPT CONFIRMATION PACKET (ENTERED FROM X25Q)
;-----
XITCPK::
	CLRB	PKCNT(R1)		;NO DATA FIELD
	MOVB	#.XITCF,PKSEQ(R1)	;SET UP X.25 TYPE CODE
	JMP	INSER1
;-----
; HERE TO PROCESS AN EAT PACKET
;-----
EATPKT:
	TBBN	$X1X25,SDLES1#(SD),10$	;BRANCH IF X.25-TO-X.25
	JMP	EATX25#
10$:
	PUSH	R1
	MOV	SDLESP#(SD),R1		;ARE THERE SAVED PACKET ?
	BEQ	15$			;NO, BRANCH
	CALL	PKTFRE			;GO FREE THEM
15$:	POP	R1
	CMPB	PKDATA(R1),#.FNXRS	;X.25 RESET ?
	BNE	EATPK4			;NO, BRANCH
;-----
; HERE TO MAKE A X.25 RESET PACKET WITH CAUSE + DIAGNOSTIC CODE IF ANY
;-----
EATPX1::
	DECB	PKCNT(R1)		;ACCOUNT FOR THE FUNCTION CODE
	MOVB	PKCNT(R1),R3	
	MOVB	PKDATA+1(R1),PKDATA(R1)	RESETTING CAUSE
	DEC	R3
	BLE	20$			;BRANCH TO SEND PACKET IF DONE
	MOVB	PKDATA+2(R1),PKDATA+1(R1)  ;SET DIAGNOSTIC CODE
	DEC	R3
	BEQ	20$			;BRANCH IF DONE
	FSTOP	IFP
20$:
	MOVB	#.XRERQ,PKSEQ(R1)	;SET UP X.25 PACKET TYPE (RESET REQ.)
EATPK2:
	CLRB	SDLEVR#(SD)		; Clear last received P(R)
	CLRB	SDLEPR#(SD)		; Clear this end's P(R)
	CLRB	SDLEPS#(SD)		; Clear this end's P(S)
	CLRB	SDLERR#(SD)		; Clear this end's pending RR count
	CLRB	SDFCNT#(SD)		; Clear socket flag count
	CLRB	SDACNT#(SD)		; Clear socket send ahead count
	BIS	#$X1JFX,SDLES1#(SD)	; JUNK DATA PACKET FROM X.25 UNTIL A
					; RESET CONF. RCVD FROM LINK
;-----
; CLEAR $X1UNO BECAUSE THIS RESET MAY GOBBLE AN INTERRUPT SENT EARLIER
; CLEAR $X1JFX BECAUSE THIS RESET MAY COLLIDE WITH ANOTHER RESET. IN THAT CASE 
;   THIS RESET IS CONSIDERED AS A RESET CONFIRMATION.
;-----
	BIC	#$X1UNO!$X1JTX,SDLES1#(SD)

	JMP	INSER1
;-----
; HERE TO PROCESS AN EAT PACKET WITH FUNCTION CODE = X.25 RESET CONFIRMATION
;-----
EATPK4::
	CMPB	PKDATA(R1),#.FNXRC	;X.25 RESET CONFIRMATION ?
	BEQ	EATPX2			;BRANCH IF YES
	FSTOP	IFP			;ILLEGAL FUNCTION PACKET
;-----
; HERE TO MAKE A RESET CONFIRMATION PACKET.  CAN BE ENTERED FROM X25Q
;-----
EATPX2::
	BIC	#$X1JTX,SDLES1#(SD)	;CLEAR THE JUNK TO X.25 FLAG
	CLRB	PKCNT(R1)		;COUNT = 0
	MOVB	#.XRECF,PKSEQ(R1)
	BR	EATPK2
	
;-----
; HERE TO PROCESS A CONNECT REQUEST PACKET AND TRANSLATE IT INTO AN X.25 CALL 
; PACKET.
; IF IT IS A SUPERVISORY CONNECTION REQUEST (FROM A TYMNET GATEWAY), THEN
;	SEND A CONNECT ACK PACKET BACK.
; OTHERWISE
;	TRANSLATE CONNECT REQUEST PACKET TO X.25 CALL REQUEST PACKET
;-----

CONPKT:   
	BIC	#$X1X25,SDLES1#(SD)	;CLEAR X.25-TO-X.25 FLAG--usB01
	BITB	#200,PKDATA+27(R1)	;SUPERVISORY CIRCUIT ?
	BEQ	10$			;NO, BRANCH
	MOV	#<3+<400*.PTACK>>,PKCNT(R1)  ;3 BYTES LONG CONN AC
	MOVB	SDSOC#(SD),PKDATA(R1)	;DESTINATION SOCKET NUMBER
	MOVB	#200,PKDATA+1(R1)	;HOST ANSWERED
	MOVB	#P.X25+1,PKDATA+2(R1)	;PROFIL = X.25
	JMP	LKESND			;SEND IT INTO NODE

10$:
;+--us701, for ATCX25
	CMPB	PKDATA+1(R1),#13	;DOES THIS PACKET HAVE A TERM PROFILE?
	BLO	11$			; NO, BRANCH
	CMPB	PKDATA+36(R1),#<P.X28+1>; YES, are you PAD?
	BNE	11$			;  NO, BRANCH
	MOV	#P.X25*400+24,R2	;ACCEPT THE CONNECTION
					;do not set profile, P.X25 is dummy
					;do not clear $T1HIA
					;clear $T3LGI, leave login mode
	CLR	R0			;privilege will be returned by
; We are not X.25-to-X.25 link, i.e. we are PAD-to-x.25 link
;	BIS	#$X1X25,SDLES1#(SD)	;  YES, SET THE X.25-TO-X.25 FLAG
; shall mark time half second to hung this connection up
; shall set $X1JTX to prevent data get in before function of call request
	CJMP	ACCEPT#			;ACCEPT# to R0 low byte
11$:
;---us701
	MOV	#S#,R0
	MOV	#40,R2			;CLEAR THE SCRATCH AREA FOR 100 BYTES
12$:	CLR	(R0)+
	SOB	R2,12$

;-----
; HERE TO SET A FLAG IN SDLES1 IF THIS CONNECT PACKET CAME FROM AN X.25 DEVICE
;-----
	BIC	#$X1X25,SDLES1#(SD)	;CLEAR X.25-TO-X.25 FLAG
	CMPB	PKDATA+1(R1),#13	;DOES THIS PACKET HAVE A TERM PROFILE?
	BLO	14$			; NO, BRANCH
	CMPB	PKDATA+36(R1),#<P.X25+1>; YES, IS IT X.25?
	BNE	14$			;  NO, BRANCH
	BIS	#$X1X25,SDLES1#(SD)	;  YES, SET THE X.25-TO-X.25 FLAG
;-----
; HERE TO FREE ANY PACKETS POINTED BY SDLESP
;-----
14$:
	PUSH	R1			;SAVE THE POINTER OF THE CONNECT REQUEST
	MOV	SDLESP#(SD),R1		;GET HEAD OF THE LIST
	BEQ	141$			;BRANCH IF LIST EMPTY
	CALL	PKTFRE			;FREE THE PACKETS OTHERWISE
	CLR	SDLESP#(SD)		;CLEAR THE POINTER
;-----
; HERE TO BEGIN TRANSLATING A CONNECT REQUEST TO A X.25 CALL PACKET
;-----
141$:
	CLR	ADRFLG			;CLEAR BOTH FLAGS FOR ADDRESS MANIPULATION
	PUSH	SD
	PUSH	R4

	MOV	#PKDATA+6,R0
	ADD	4(SP),R0		;R0 -> DEST. DEVICE NAME
	PUSH	R0			;SAVE IT FOR LATER

; HERE TO FIND OUT HOW MANY LEADING ZEROS ARE NEEDED TO MAKE CALLED ADDRESS 
;  5 DIGITS LONG

	MOV	#5,R2			;MAX. BYTE TO SCAN FOR
15$:	TSTB	(R0)+			;NULL?
	BEQ	20$			;YES, BRANCH
	SOB	R2,15$
20$:
	POP	R0		;(R2)=# OF LEADING ZEROS NEEDED
	MOV	#S#+1,R1	;R1 -> CALLED ADDRESS FIELD
	CLR	R5		;COUNTER FOR LENGTH OF CALLED ADDRESS
	TST	R2		;ANY LEADING ZERO NEEDED?
	BEQ	30$		;NO, BRANCH
	CLR	R3		;YES, MAKE R3 = 0
25$:
	PUTNIB			;MOV THE BCD IN R3 TO LOCATION @ R1
	INC	R5		;COUNT THE LENGTH
	SOB	R2,25$		;LOOP UNTIL DONE
30$:
	GETBYT			;NOW GET BYTE @ R0, CONVERT IT TO BCD
	BCS	35$		;BRANCH IF END OF NAME SEEN.
	PUTNIB			;MOVE THE BCD IN R3 TO LOCATION @ R1
	INC	R5		;COUNT IT
	BR	30$
35$:
	MOV	#PKDATA+24,R0	;OFFSET OF DATA AREA
	MOV	4(SP),R2	;GET PACKET POINTER
	MOVB	PKDATA+1(R2),R3	;GET LENGTH OF DATA AREA
	ADD	R3,R0		;OFFSET OF DESTINATION EXT.
	ADD	R2,R0		;R0 -> DEST EXT.
	MOVB	PKDATA+2(R2),R2	;BYTE COUNT OF DEST. EXT.
	BEQ	40$		;BRANCH IF NOTHING THERE

	MOV	2(SP),R3	;GET SDB POINTER
	TBBE	$X1X25,SDLES1#(R3),37$	; THIS CIRCUIT X.25-TO-X.25
;-----
; HERE IF CONN. REQ. FROM AN X.25 DEVICE, THE DESTINATION EXTENSION
;  IS PACKED (TWO DIGITS PER BYTE)
;-----
	ASL	R2		;DOUBLE THE BYTE COUNT
36$:
	GETNIB			;GET A NIBBLE (I.E. A DIGIT)
	BCS	40$		;END OF VALID DIGITS
	PUTNIB			;PUT IT IN THE CALLED ADDRESS FIELD
	INC	R5		;INCREMENT LENGTH OF CALLED DTE ADDR 
	SOB	R2,36$
	BR	40$
;-----
; HERE IF CONN. REQ. IS NOT FROM A X.25 DEVICE
;   DESTINATION EXTENSION IS NOT PACKED THEN.
;-----
37$:
;-----
; TYMNET SPECIAL - HERE TO ADD ENOUGH LEADING ZEROS TO MAKE A FIVE DIGIT HOST 
; NUMBER.  IT IS ASSUMED THAT THE DESTINATION NAME FIELD CONTAINS A DNIC + '0'
;	
	PUSH	R2		;SAVE COUNT OF DEST. EXT.
	NEG	R2
	ADD	#5,R2		;
	BLE	39$		;NO NEED TO ADD ANY
38$:
	CLR	R3		;LEADING ZERO
	PUTNIB
	INC	R5		;COUNT THE CALLED ADDRESS LENGTH
	SOB	R2,38$
39$:
	POP	R2		;RESTORE BYTE COUNT OF DEST. EXT.
;-----
1$:	GETBYT			;GET A BYTE, CONVERT IT TO BCD
	PUTNIB			;STORE THE BCD
	INC	R5		;COUNT IT
	SOB	R2,1$
40$:
	CMP	R5,#14.		;CALLED ADDRESS TOO LONG ?
	BLOS	41$		;NO, CONTINUE
	JMP	CONBD0		;BAD DEST. NAME, RETURN CONN. NAK.
41$:	BISB	R5,S#		;SET CALLED ADDRESS LENGTH


	.PAGE
;-----
; HERE TO SET UP CALLING ADDRESS BASED ON SOURCE DEVICE NAME
;-----
SETCLG:
	CLR	R5		;R5 TO COUNT LENGTH OF CALLING ADDRESS
	TBBE	$D0GTW,DDSTS0#(R4),10$	;BRANCH IF NOT GATEWAY

;-----
; IF THIS DEVICE IS A GATEWAY TO A PUBLIC DATA NETWORK THEN
;   USE THIS DEVICE'S NAME AS DNIC OF THE CALLING ADDRESS.
;------
	MOV	#5,R2		;SCAN THE DEVICE NAME FOR # OF LEADING ZEROS NEEDED
	MOV	#DDLKNA#,R0	;
	ADD	(SP),R0		;TOP OF STACK = DDB ADDRESS
	PUSH	R0
3$:
	TSTB	(R0)+		;END OF STRING REACHED ?
	BEQ	5$		;YES, BRANCH
	SOB	R2,3$		;
5$:	TST	R2		;ANY LEADING ZEROS NEEDED ?
	BEQ	7$		;NO

	CLR	R3
6$:	PUTNIB			;FILL WITH LEADING ZEROS
	INC	R5		;COUNT IT
	SOB	R2,6$
7$:
	POP	R0
9$:	GETBYT			;GET A BYTE, CONVERT TO BCD
	BCS	10$		;DONE, BRANCH
	PUTNIB			;
	INC	R5
	BR	9$
10$:
	MOV	4(SP),R0	;GET PACKET PTR AGAIN
	MOV	2(SP),R2	;GET SDB ADDRESS
	TBBE	$X1X25,SDLES1#(R2),20$	;BRANCH IF NOT X.25-TO-X.25
;-----
; HERE IF SOURCE IS AN X.25 DEVICE, THEN SOURCE DEVICE NAME = 
;  CALLING ADDRESS STORED IN PACKED FORMAT
;  '1111'B IS STORED AFTER THE LAST BYTE IF THE CALLING ADDRESS HAS ODD
;  NUMBER OF DIGITS
;-----
	CLRB	ADRFLG		;CLEAR THE FLAG WHICH CONTROL THE FETCHING
				;  OF CALLING ADDRESS NIBBLES.
	
	ADD	#PKDATA+16,R0	;R0 -> SOURCE DEVICE NAME
	MOV	#12.,R2		;MAX. COUNT OF DIGITS IN SRC NAME FIELD
12$:
	GETNIB			;GET A BCD @R0
	BCS	30$		;END OF NAME SEEN, BRANCH
	PUTNIB			;PUT A BCD @R1
	INC	R5
	SOB	R2,12$
;-----
; NOW CHECK SOURCE DEVICE EXTENSION
;-----
	MOV	4(SP),R3	;GET PACKET POINTER AGAIN
	MOVB	PKDATA+3(R3),R2	;ANYTHING IN SRC. EXT. AREA ?
	BNE	30$		;NO, BRANCH
	ASL	R2		;CONVERT # OF BYTES TO # OF DIGITS
	MOV	R3,R0		;PACKET ADDRESS
	ADD	#PKDATA+24,R0	;BUMP TO DATA AREA
	ADD	#PKDATA+1,R3	;R3 -> BYTE COUNT OF DATA AREA
	MOVB	(R3)+,R4	
	ADD	R4,R0		;BUMP R0 TO DEST. EXT.
	MOVB	(R3)+,R4
	ADD	R4,R0		;BUMP R0 TO SRC. EXT. AREA
14$:
	GETNIB			;GET A BCD FROM SRC. EXT.
	BCS	30$		;BRANCH IF DONE 
	PUTNIB
	INC	R5		;COUNT THE LENGTH
	SOB	R2,14$		;
	BR	30$
;-----
; HERE IF THE SOURCE DEVICE IS NOT X.25.  THEN THE ADDRESS IN SRC. NAME 
;  AND EXT. AREA IS STORED IN ASCII.
;	R0 -> CONNECT REQUEST PACKET
;-----
20$:
	ADD	#PKDATA+16,R0	;R0 -> SRC. DEVICE NAME
	MOV	#6,R2		;MAX. # OF BYTES TO PROCESS
22$:
	GETBYT
	BCS	30$		;END OF NAME SEEN
	INC	R5		;COUNT IT
	PUTNIB
	SOB	R2,22$

	MOV	4(SP),R3	;GET PACKET POINTER AGAIN
	MOVB	PKDATA+3(R3),R2 ;GET BYTE COUNT OF SRC. EXT.
	BEQ	30$		;NOTHING THERE, BRANCH
	MOV	R3,R0		;COPY PACKET POINTER
	ADD	#PKDATA+24,R0	;
	ADD	#PKDATA+1,R3
	MOVB	(R3)+,R4
	ADD	R4,R0
	MOVB	(R3)+,R4
	ADD	R4,R0		;R0 -> SRC. EXT. AREA
24$:
	GETBYT			;GET A BYTE AND CONVERT TO BCD
	BCS	30$		;NOT A DIGIT !
	PUTNIB
	INC	R5		;COUNT THE LENGTH
	SOB	R2,24$

;-----
; SOURCE NAME AND EXTENSION CONVERTED.  NOW FILL IN THE CALLING ADDRESS
;  LENGTH AND BUMP R1 IF ADDRESSES DON'T END UP ON A BYTE BOUNDARY
;-----
30$:
	CMP	R5,#14.		;CALLING ADDRESS TOO LONG ?
	BLOS	32$		;NO, CONTINUE
	JMP	CONBD0		;YES, CONN. NAK WITH .ERNSH CODE
32$:
	ASHI	4,R5		;SHIFT LEFT BY 4
	BISB	R5,S#		;SET LENGTH OF CALLING ADDRESS
	TSTB	ADRFL1		;ODD NUMBER OF DIGITS IN ADDRESSES ?
	BEQ	FILFCR		;NO, BRANCH
	INC	R1		;YES, FORCE BYTE ALIGNMENT
				;FALL THROUGH TO FILFCR


;-----
; FIXED PORTION OF THE FACILITY REQUESTS
;-----

	PURE
FIXFCR:	.BYTE	FCREND-.-1	;LENGTH OF FIXED FACILITY REQUEST
	.BYTE	102,7,7		;PACKET SIZE = 128 IN BOTH DIRECTIONS
	.BYTE	103,2,2		;WINDOW SIZE = 2 IN BOTH DIRECTIONS
	.BYTE	002,167		;THROUGHPUT CLASS = 1200 BPS
FCREND:
FCRLEN=.-FIXFCR

	.EVEN



	CODE
;-----
; HERE TO SET THE FIXED PORTION OF THE FACILITY REQUEST
;-----
FILFCR:
	PUSH	R1		;SAVE THE ADDRESS OF THE FACILITY LENGTH
;***********
; Disable the following 4 instructions so that facility requests are not made
;
;	MOV	#FIXFCR,R0
;	MOV	#FCRLEN,R2
;40$:
;	MOVB	(R0)+,(R1)+	;COPY FIXED PORTION OF FACILITY REQUEST
;	SOB	R2,40$		; INCLUDING THE FACILITY LENGTH
;
	clrb	(r1)+		;length of facility field = 0
;***********
;-----
; HERE TO CHECK ANY ADDITIONAL FACILITY REQUEST
;-----
	POP	R5		;RETRIVE THE FACILITY LENGTH POINTER
	MOV	4(SP),R0	;GET PACKET ADDRESS
	MOVB	PKDATA+25(R0),R2  ; C.U.G. REQUESTED ?
	BEQ	42$		;NO, BRANCH TO CHECK REVERSE CHARGING
	MOVB	#3,(R1)+	;YES, C.U.D. FACILITY CODE
	INCB	(R5)		;INCREMENT FACILITY LENGTH
	MOVB	R2,(R1)+	;MOVE THE C.U.D. VALUE
	INCB	(R5)		;INCREMENT FACILITY LENGTH
42$:	BITB	#1,PKDATA+32(R0)  ;REVERSE CHARGING REQUESTED ?
	BEQ	43$		;NO, BRANCH
	MOVB	#1,(R1)+	;REVERSE CHARGING FACILITY CODE
	INCB	(R5)
	MOVB	#1,(R1)+	;REVERSE CHARGING VALUE
	INCB	(R5)

;-----
; HERE TO MOVE ANY CALL USER DATA FROM CONNECT PACKET TO CALL PACKET
;-----
43$:
	MOV	2(SP),R2		;GET SDB POINTER
	TBBE	$X1X25,SDLES1#(SD),50$	;NO CALL USER DATA IF NOT FROM X.25
	MOV	#24,R2			;OFFSET IN DATA AREA
	MOV	#PKDATA+1,R3		;OFFSET TO LENGTH OF DATA AREA
	ADD	R0,R3			;R3 -> LENGTH OF DATA AREA
	MOV	#3,R5			;COUNTER
45$:
	MOVB	(R3)+,R4		;GET LENGTH OF DATA AREA, DEST. EXT.
	ADD	R4,R2			; & SRC EXT.
	SOB	R5,45$

; R2 HAS THE OFFSET TO CALL USER DATA FIELD.  IF PKCNT(R0) > R2 THEN C.U.D.
;  EXISTS.

	MOVB	PKCNT(R0),R4		;GET PKCNT
	SUB	R2,R4			;R4 = # OF BYTES OF USER DATA
	BEQ	50$			;NO C.U.D.
	ADD	#PKDATA,R2
	ADD	R0,R2			;R2 -> C.U.D.
48$:
	MOVB	(R2)+,(R1)+		;MOVE C.U.D.
	SOB	R4,48$
	BR	60$

;-----
; HERE IF NO CALL USER DATA.  IF CALL COMES FROM A TERMINAL, SET THE C.U.D.
;  TO 1,0,0,0 (PAD ORIGINATED CALL)
;-----
50$:
	CMPB	PKDATA+14(R0),#.IDTR#	;SRC DEVICE = TERMINAL ?
	BNE	60$			;NO, BRANCH

	MOVB	#1,(R1)+
	CLRB	(R1)+
	CLRB	(R1)+
	CLRB	(R1)+

;-----
; COMPUTE THE LENGTH OF THE X.25 CALL PACKET AND PUT IT INTO TRANSMIT RING
;-----
60$:
	MOV	R1,R3			;GET ADDR. OF NEXT BYTE IN SCRATCH AREA	
	SUB	#S#,R3			;SUBSTRACT THE BASE ADDR

	POP	R4
	POP	SD
	POP	R1

	MOVB	R3,PKCNT(R1)		;SET LENGTH OF CALL 
	INC	R3			;
	ASR	R3			;CHANGE TO WORD COUNT
	
	MOV	#S,R0			; Get scratch area pointer
	MOV	#PKDATA,R2		; Get pointer to packet data area
	ADD	R1,R2			; Add packet base address

2$:	MOV	(R0)+,(R2)+		; Move word from scratch area to packet
	SOB	R3,2$			; Continue until packet loaded

	MOVB	#2,SDPMAX#(SD)		; Store max value for socket

	CLRB	SDLEVR#(SD)		; Clear last received P(R)
	CLRB	SDLEPR#(SD)		; Clear this end's P(R)
	CLRB	SDLEPS#(SD)		; Clear this end's P(S)
	CLRB	SDLERR#(SD)		; Clear this end's pending RR count
	CLRB	SDFCNT#(SD)		; Clear socket flag count
	CLRB	SDACNT#(SD)		; Clear socket send ahead count
	BIC	#<$X1JTX!$X1JFX>,SDLES1#(SD) ; Clear I/O supress bits

	JMP	INSERT			; Insert packet into link transmit ring
;------------------------------------------------------------------

;-----
; Here on errors in translation of Connection Request packet
; Note: This code assumes that subroutine "REFUSE" returns with carry set
;-----
CONBD0:	POP	R4
	POP	SD
	POP	R1

CONBAD:	MOV	#.ERCRJ,R0		; Set command reject error code
	CJMP	REFUSE#			; Refuse the connection (and return
					;   with C bit set)

;-----
; Here on Connection ACK packet
;-----
ACKPKT:	CLRB	SDLEVR#(SD)		; Clear last received P(R)
	CLRB	SDLEPR#(SD)		; Clear this end's P(R)
	CLRB	SDLEPS#(SD)		; Clear this end's P(S)
	CLRB	SDLERR#(SD)		; Clear this end's pending RR count
	CLRB	SDFCNT#(SD)		; Clear socket flag count
	CLRB	SDACNT#(SD)		; Clear socket send ahead count

	CMPB	PKCNT(R1),#3		; HAS A TERMINAL PROFILE CODE?
	BLO	2$			; NO, BRANCH
	CMPB	PKDATA+2(R1),#<P.X25+1>	; YES, IS IT FROM AN X.25 DEVICE?
	BNE	2$			;   NO, BRANCH
	BIS	#$X1X25,SDLES1#(SD)	;   YES, SET THE X.25-TO-X.25 FLAG
2$:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	PUSH	R1			; Save ACK packet pointer
;
;	MAKPKT	.PLSTP#			; Make a new packet
;	BCS	1$			; Ignore if can't get packet
;
;	MOV	#<3+<400*.PTFUN>>,PKCNT(R1) ; Count = 3 bytes, type = function
;	MOV	#<.FNSDP+<400*.TPBST>>,PKDATA(R1) ; Set device params, break set
;	MOVB	#2,PKDATA+2(R1)			; Break on <CR>
;
;	CALL	PKTAGN#			; Put packet on this socket's dest list
;
;	MAKPKT	.PLSTP#			; Make another packet
;	BCS	1$			; Ignore if can't get packet
;
;	MOV	#<2+<400*.PTFUN>>,PKCNT(R1) ; Count = 2, type = function
;	MOV	#<.FNDEM+<400*0>>,PKDATA(R1) ; Function = deferred echo mode,
;					;   value = leave deferred echo mode
;	CALL	LKESND			; Send packet into node
;
;1$:	POP	R1			; Retrieve ACK packet pointer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	CLRB	PKCNT(R1)		; MAKE IT A CALL ACCEPTED PACKET
					; W/O ADDRESSES & FACILITIES
	BR	INSERT			; Go transmit packet and return

;-----
; Here to send X.25 Restart Request packet
;-----
RSTX25::CALL	LKEDWN#			; Declare link down to restart it
	CALL	LNKUP#			; Declare link up for restart

	MAKPKT	.PLSTP#			; Make a packet
	BCC	1$			; If got a packet
	RETURN				; No packet available - just return

1$:	MOV	#<.LCG*400+1>,PKCNT(R1)	; Count = 1, channel group = 0 ; 4/13/82
	MOV	#<.XRSRQ*400>,PKSOC(R1)	; Type = Restart Request, channel = 0

	CLRB	PKDATA(R1)		; resatrt cause code = 0, DTE restart
	TBBE	$D0PRI,DDSTS0#(R4),5$	; branch if this end is DTE (secondary)
	MOVB	#7,PKDATA(R1)		; Restart cause code = 7, Network operational
5$:
	MOV	DDSX#(R4),R0		; GET POINTER TO 1ST SDB
	MOV	-(R0),SD		; SET UP SD TO WILD SDB FOR LATER
					;  LEPOKC CALL
	BIS	#$X1RSO,SDLES1#(SD)	; RESTART PACKET OUTSTANDING

	BR	XMTPKT			; Transmit the packet

;-----
; Here to translate Kill & Disconnect packets
;-----
KILPKT:	CLRB	SDLEVR#(SD)		; Clear last received P(R)
	CLRB	SDLEPR#(SD)		; Clear this end's P(R)
	CLRB	SDLEPS#(SD)		; Clear this end's P(S)
	CLRB	SDLERR#(SD)		; Clear this end's pending RR count
	CLRB	SDFCNT#(SD)		; Clear socket flag count
	CLRB	SDACNT#(SD)		; Clear socket send ahead count
	BIC	#<$X1JTX!$X1JFX!$X1X25>,SDLES1#(SD) ; Clear I/O supress bits
;-----
; HERE TO FREE DATA PACKETS QUEUED AT SDLESP(SD)
;-----
	PUSH	R1
	MOV	SDLESP#(SD),R1
	BEQ	5$			; BRANCH IF NOTHING THERE
	CALL	PKTFRE			; FREE THE PACKET IF THERE IS ANY
	CLR	SDLESP#(SD)
5$:	POP	R1

	CLR	R0			; Clear residue
	BISB	PKDATA(R1),R0		; Pick up clear reason
	CMP	R0,#X25R		; Valid reason?
	BLO	10$			; Yes
	CLR	R0			; No - indicate remote procedure error
10$:	MOVB	X25RSN(R0),PKDATA(R1)	; Pick up X.25 clear reason
	MOV	R1,R0			; Copy packet pointer
	ADD	#PKDATA+1,R0		; Point at node name
20$:	TSTB	(R0)+			; Scan for first null
	BNE	20$
	MOVB	(R0),PKDATA+1(R1)	; Copy the diagnostic byte
	MOVB	#2,PKCNT(R1)		; Packet byte count = 2
	BR	INSERT			; Go insert packet into transmit ring

;-----
; NEXILIS Disconnnect to X.25 Call Clearing reason translation table
;
; X.25 has the following Call Clearing reasons:
;	000	DTE clearing
;	001	number busy
;	003	invalid facility request
;	005	network congestion
;	011	out of order
;	013	access barred
;	015	not obtainable
;	021	remote procedure error
;	023	local procedure error
;	025	RPOA out of order
;	031	number refuses reverse charging
;	041	incompatable destination
;-----
	PURE

X25RSN:	.BYTE	005			; .ER??? =  0 - undefined
	.BYTE	005			; .ERLKF =  1 - link full
	.BYTE	005			; .ERBFF =  2 - buffer space full
	.BYTE	005			; .ERTIM =  3 - time-out
	.BYTE	005			; .ER??? =  4 - undefined
	.BYTE	011			; .ERLKD =  5 - link down
	.BYTE	013			; .ERLKO =  6 - link disabled(by status device)
	.BYTE	013			; .ER??? =  7 - link locked(no new connections)?
	.BYTE	005			; .ER??? = 10 - undefined
	.BYTE	005			; .ER??? = 11 - undefined
	.BYTE	005			; .ER??? = 12 - undefined
	.BYTE	005			; .ER??? = 13 - undefined
	.BYTE	005			; .ER??? = 14 - undefined
	.BYTE	001			; .ERNSA = 15 - no sockets avail on dst
	.BYTE	001			; .ERSIU = 16 - socket in use on dst
	.BYTE	015			; .ERNSN = 17 - no such node
	.BYTE	015			; .ERNSH = 20 - no such host
	.BYTE	015			; .ERNSD = 21 - no such device
	.BYTE	015			; .ERNSS = 22 - no such socket on device
	.BYTE	011			; .ERHSD = 23 - host down
	.BYTE	015			; .ERHNA = 24 - host not available
	.BYTE	015			; .ERCRF = 25 - connection refused
	.BYTE	015			; .ERPNF = 26 - gateway down
	.BYTE	005			; .ER??? = 27 - undefined
	.BYTE	013			; .ERPRV = 30 - priviledge failure
	.BYTE	021			; .ERISP = 31 - illegal seq of pkts
	.BYTE	013			; .ERPLS = 32 - please see your rep
	.BYTE	005			; .ER??? = 33 - undefined
	.BYTE	000			; .ERREQ = 34 - request
	.BYTE	013			; .ERHNG = 35 - hangup
	.BYTE	005			; .ERILD = 36 - inconsistent link data
	.BYTE	005			; .ERDER = 37 - device service error
	.BYTE	001			; .ERNSJ = 40 - no space for job data
	.BYTE	001			; .ERJCX = 41 - job capacity exceeded
	.BYTE	015			; .ERCRJ = 42 - network command reject
	.BYTE	015			; .ERUNE = 43 - user name error
	.BYTE	005			; .ERSPR = 44 - tymnet supervisor error
	.BYTE	005			; .ERMUD = 45 - Tymnet MUD error
	.BYTE	005			; .ERFER = 46 - TYMnet format error
	.BYTE	005			; .ERRCC = 47 - recconnect seq complete
	.BYTE	005			; .ERTRM = 50 - process terminated
	.BYTE	005			; .ERRLS = 51 - device released
	.BYTE	005			; .EROOP = 52 - out of originating ports
	.BYTE	005			; .ERAQF = 53 - aux circut queue full
	.BYTE	015			; .ERSVR = 54 - supervisor request 
	.BYTE	003			; .ERIFR = 55 - invalid fac request
	.BYTE	021			; .ERRPE = 56 - remote proc error
	.BYTE	023			; .ERLPE = 57 - local proc error
	.BYTE	031			; .ERNRC = 60 - number refuses rchg
	.BYTE	041			; .ERICD = 61 - incompatable destination
X25R	=! .-X25RSN

	CODE

;-----
; Here on Disconnect ACK packet
;-----
DAKPKT:	CLRB	SDLEVR#(SD)		; Clear last received P(R)
	CLRB	SDLEPR#(SD)		; Clear this end's P(R)
	CLRB	SDLEPS#(SD)		; Clear this end's P(S)
	CLRB	SDLERR#(SD)		; Clear this end's pending RR count
	CLRB	SDFCNT#(SD)		; Clear socket flag count
	CLRB	SDACNT#(SD)		; Clear socket send ahead count
	BIC	#<$X1JTX!$X1X25>,SDLES1#(SD) ; Clear I/O supress bits & X.25 BIT
	CALL	FRESOC#			; Put socket back on free list

;-----
; Fall through into the code to insert the X.25 packet into the frame level
; transmit ring to be sent across the gateway
;-----
	.PAGE
	.SBTTL	INSERT - Insert X.25 packet into frame level transmit ring
;-----
; Here to insert packet into frame transmit ring
;-----
INSERT:	CLR	R0			; Clear residue
	BISB	PKTYPE(R1),R0		; Pick up packet type
	MOVB	X25PKT(R0),PKSEQ(R1)	; Store X.25 packet type

;-----
; Here to insert pkt into transmit ring without setting packet type
;-----
INSER1:	MOVB	#.LCG,PKTYPE(R1)	; Store X.25 logical channel group byte

;-----
; Here to insert pkt into transmit ring only setting socket #
;-----
INSER2:	MOVB	SDSOC#(SD),PKSOC(R1)	; Store socket # (X.25 channel #)

;-----
; Here to really insert packet into transmit ring
;-----
XMTPKT:	MOV	DDLELT#(R4),R0		; Pick up frame transmit ring tail

	MOV	R1,(R0)+		; Store packet addr in ring
	CMP	R0,DDLELE#(R4)		; End of ring?
	BLO	1$			; No
	MOV	DDLELB#(R4),R0		; Yes - reset ring tail

1$:	INCB	DDLEVT#(R4)		; Bump transmit ring frame count
	CMPB	DDLEVT#(R4),DDLEK0#(R4)	; Ring full?
	BLO	2$			; No
	BIS	#$D1ACT,DDSTS1#(R4)	; Yes - declare link active

2$:	MOV	R0,DDLELT#(R4)		; Update ring tail ptr
	CALL	LKESTO#			; Start output if idle
	CALL	LEPOKC			; See if window closed yet
	CLC				; Indicate output was started
	RETURN				; Return to caller

;-----
; NEXILIS to X.25 packet type translation table
;-----
	PURE

X25PKT:	.BYTE	000			; Data
	.BYTE	.XCARQ			; Connection Request
	.BYTE	.XCACF			; Connection ACK
	.BYTE	.XCLRQ			; Connection NAK
	.BYTE	000			; Function
	.BYTE	.XINTR			; Interrupt
	.BYTE	.XRERQ			; Eat
	.BYTE	.XCLRQ			; Disconnect
	.BYTE	.XCLRQ			; Kill
	.BYTE	.XCLCF			; Disconnect ACK
	.BYTE	000			; Recover
	.BYTE	000			; Retry
	.BYTE	000			; Packet ACK
	.BYTE	000			; Undefined
	.BYTE	000			; Undefined
	.BYTE	000			; Undefined
	.BYTE	000			; Undefined
	.BYTE	000			; X.25 RR equivalent

	.page
	.SBTTL  Get packets from link and move them into the node
	CODE
	.SBTTL	LKEMOV - Translate X.25 packet to NEXILIS and move into node
;-----
; LKEMOV - Subroutine to move an X.25 packet into the node
;
; Linkage:
;	C(R1) = address of the 1st packet in a list of packet.
;		pktype(r1) = GFI and LCG
;		pksoc(r1)  = LCN
;		pkseq(r1)  = packet type identifier
;	C(R4) = address of DDB
;
;	CALL LKEMOV
;
; Returns:
;	C(SD) = address of SDB
;
; Unpreserved registers:
;	R0, R2, R3
;-----
LKEMOV:: BITB	#157,PKTYPE(R1)		; Is the D-bit, mod128 bit and LCG zero
	BNE	PKTILL			; Yes, ignore it for now
	CLR	R0			; Clear residue
	BISB	PKSOC(R1),R0		; Get logical channel # (socket #)
	BNE	100$			; Ok if non-zero channel

	CMPB	PKSEQ(R1),#.XRSRQ	; Is this a Restart Request?
	BEQ	100$			; Yes - ok
	CMPB	PKSEQ(R1),#.XRSCF	; No - is it a Restart Confirmation?
;	BEQ	100$			; Yes - ok
;	JMP	PKTILL			; No - discard this packet
	BNE	PKTILL			; No - discard this packet

100$:	CMPB	DDSOC#(R4),R0		; Is it in range
	BLO	PKTILL			; No, ignore for now
	ASL	R0			; Convert socket # to word index
	ADD	DDSX#(R4),R0		; Add socket base for this link
	MOV	-(R0),SD		; Pick up SDB ptr

	MOVB	PKSEQ(R1),R0		; Get X.25 packet type (sign extend)
	TBBE	$DATA,R0,PKTDAT		; Go process if data packet
	TBBE	$SUPV,R0,PKTSUP		; Go process if sup (RR, RNR or Diag.)

	ASR	R0			; Unnumbered packet - shift out
					;   rightmost bit
	ADD	#3,R0			; Adjust for 0 base, not -4 (1 is still
					;   in rightmost bit)
	CMP	R0,#X25D		; Valid index?
	BHIS	PKTILL			; No

	MOV	X25DSP(R0),R2		; Yes - get dispatch addr from pkt type
	ASR	R0			; Convert index to byte index
;-----
; Watch! The following instruction overwrite GFI field (including D-bit)
;  and LCGN (It should be zero anyway) in an X.25 call packet
;-----
	MOVB	NEXPKT(R0),PKTYPE(R1)	; Get NEXILIS pkt type

	JMP	(R2)			; Dispatch on X.25 packet type

;-----
; Dispatch table for translating X.25 packets to NEXILIS packets
;-----
	PURE
	.EVEN

X25DSP:	.WORD	PKTRST			; Restart Request(373)
	.WORD	PKTRSC			; Restart Confirmation(377)
	.WORD	PKTILL			; Undefined
	.WORD	PKTILL			; Undefined
	.WORD	PKTCON			; Call Request(013)
	.WORD	PKTACK			; Call Accepted(017)
	.WORD	PKTDIS			; Clear Request(023)
	.WORD	PKTDAK			; Clear Confirmation(027)
	.WORD	PKTRES			; Reset Request(033)
	.WORD	PKTREC			; Reset Confirmation(037)
	.WORD	PKTINT			; Interrupt(043)
	.WORD	PKTITC			; Interrupt Confirmation(047)
X25D	=! .-X25DSP

;-----
; X.25 to NEXILIS packet translation table
;-----
NEXPKT:	.BYTE	.LCG			; Restart Request
	.BYTE	0			; Restart Confirmation
	.BYTE	0			; Undefined
	.BYTE	0			; Undefined
	.BYTE	.PTCON			; Call Request
;	.BYTE	.PTACK			; Call Accepted
	.BYTE	.PTFUN			; Call Accepted--us701
	.BYTE	.PTDIS			; Clear Request
	.BYTE	.PTDAK			; Clear Confirmation
	.BYTE	.PTEAT			; Reset Request
	.BYTE	.PTEAT			; Reset Confirmation
	.BYTE	.PTINT			; Interrupt
	.BYTE	.PTFUN			; Interrupt Confirmation
NEXP	=! .-NEXPKT

	CODE
	.SBTTL	X.25 to NEXILIS packet translation
;-----
; Here on bad packet type translation
;-----
PKTILL:	INC	DDLEBP#(R4)		; Bump Link E bad packet count
	BR	PKTFRE			; Junk the packet

;-----
; Here on reset confirmation packet
;-----
PKTREC:	CLRB	SDLEVR#(SD)		; Clear last received P(R)
	CLRB	SDLEPR#(SD)		; Clear this end's P(R)
	CLRB	SDLEPS#(SD)		; Clear this end's P(S)
	CLRB	SDLERR#(SD)		; Clear this end's pending RR count
	CLRB	SDFCNT#(SD)		; Clear socket flag count
	CLRB	SDACNT#(SD)		; Clear socket send ahead count
	BIC	#$X1JFX,SDLES1#(SD)	;

	TBBN	$X1X25,SDLES1#(SD),10$	; Branch if X.25-to-X.25
	CMPB	SDSDID#(SD),#.IDTR#	; Is the other end a terminal ?
	BNE	PKTUAK			; No, go free the packet
;-----
; Here to send an Eat Packet with function code = X.25 Reset Confirmation
;-----
10$:
	MOV	#<.PTEAT*400+1>,PKCNT(R1) ; Eat Packet, Count=1
	MOVB	#.FNXRC,PKDATA(R1)	; Function code
	JMP	LKESND			; Send it into node
;-----
; Here on Restart Confirmation packet
;	If Restart Outstanding, clear the condition
;	else report error (To Be Implemented)
;-----
PKTRSC:
	BIC	#$X1RSO,SDLES1(SD)

;-----
; Here when unnumbered packet sent from here is acknowledged
;-----
PKTUAK:	BIC	#$X1UNO,SDLES1#(SD)	; Clear outstanding unnumbered pkt flag
	PUSH	R1			; Save packet pointer
	CALL	LEPOKC			; See if window opened now
	POP	R1			; Restore packet pointer

;-----
; Here to free the packet list pointed to by R1
;-----
X25FRE::				; Global entry for PKTFRE
PKTFRE:	PUSH	(R1)			; Save forward packet link
	FREPKT				; Free a packet
	POP	R1			; Retrieve forward packet link
	BNE	PKTFRE			; Continue until packet list freed

	RETURN				; Return to caller

;-----
; Here to discard data packets while junking input from X.25 port
;-----
X25JNK::CALL	PKTFRE			; Discard packet list
	INCB	SDPCNT#(SD)		; Bump packet count for socket
	CJMP	DECOWN#			; Now decrement it and return

;-----
; Here on X.25 data packet
;-----
PKTDAT:
	TBBN	$X1JFX,SDLES1#(SD),X25JNK ;JUNK DATA PACKET FROM X.25 LINK IF
					  ; WE'RE WAITING FOR RESET CONFIRM
	INCB	SDLERR#(SD)		; Bump pending RR count

; Here to check if P(S) legal?
	CLR	R2			; Clear residue
	BISB	SDLEPR#(SD),R2		; Pick up P(R) for logical channel
	CLR	R3			; Clear residue
	BISB	SDPMAX#(SD),R3		; Pick up max value (window size)
	ADD	R2,R3			; Add P(R) to get top of window

	ASR	R0			; Right justify P(S) from packet
	BIC	#$MASKP,R0		; Isolate P(S) from packet
	CMP	R0,R2			; New P(S) inside window?
	BHIS	100$			; Maybe - check high end
	ADD	#.MODP,R0		; No - too low, add modulus so it is

100$:	CMP	R0,R3			; New P(S) still inside window?
	BHI	CRESET			; HI, no, go reset channel
;	BLOS	PKTFLW			; Yes - go check P(R)
;					; No - fall into channel reset code
	CMPB	SDLERR#(SD),SDPMAX#(SD)	; Window closed?
	BHIS	PKTFLW			; HIS, closed
	INCB	R0			; P(S)+1 will be our ack
	BIC	#$MASKP,R0		; Rotating the ring
	MOVB	R0,SDLEPR#(SD)		; Update P(R) direction link-e to DCE
	BR	PKTFLW			; Go check P(R) sent from DCE

;-----
; Here to reset the logical channel and return
;-----
CRESET:	CLRB	SDLEVR#(SD)		; Clear last received P(R)
	CLRB	SDLEPR#(SD)		; Clear this end's P(R)
	CLRB	SDLEPS#(SD)		; Clear this end's P(S)
	CLRB	SDLERR#(SD)		; Clear this end's pending RR count
	CLRB	SDFCNT#(SD)		; Clear socket flag count
	CLRB	SDACNT#(SD)		; Clear socket send ahead count

	PUSH	R1			; Save a packet for send back
	MOV	(R1),R1			; Get pointer to rest of packet list
	BEQ	100$			; Skip if nothing there

	CALL	PKTFRE			; Discard all but 1st packet on list

100$:	POP	R1			; Retrieve packet for sendback
	MOV	#<.LCG*400+1>,PKCNT(R1)	; Count = 0, logical channel group = 0
	MOVB	#.XRERQ,PKSEQ(R1)	; X.25 packet type = Reset Request
	CLRB	PKDATA(R1)		; ZERO AS RESET CAUSE (NOT TOO GOOD!)
	JMP	SNDBA1			; Send this packet back to other side

;-----
; Here on supervisory packets
;-----
PKTSUP:
	CMPB	R0,#.XDIAG		; Diagnostic Packet
	BNE	5$			; No, check for RR & RNR
	INC	DDLEDG#(R4)		; Inc counter for Diagnostic Packet
	BR	PKTFRE			; And free the packet
5$:
	ASR	R0			; Convert SUPV function to word index
	BIC	#$MASKP,R0		; Isolate supervisory function code
	JMP	@PKSUDT(R0)		; Dispatch on SUPV function
;-----
; Supervisory function dispatch table
;-----
	PURE
	.EVEN

PKSUDT:	.WORD	PKTFLW			; RR packet
	.WORD	PKTFLW			; RNR packet
	.WORD	PKTFLW			; REJ packet
	.WORD	CRESET			; Undefined supervisory function

	CODE

;-----
; Here to do flow control update from P(R) of supervisory and info frames
;
; Note: P(R) contained in the new packet MUST be greater than or equal to the
;	last P(R) received (last acknowledged packet number) AND less than or
;	equal to P(S) for the channel (the next packet to be sent from
;       this side)
;
;	P(S), P(R), and the previous P(R) are compared in a circular fashion
;	using modulus arithmetic
;-----
PKTFLW:	MOVB	PKSEQ(R1),R0		; Get X.25 packet type
	ASHI	-.SHFPR,R0		; Right justify P(R)
	BIC	#$MASKP,R0		; Isolate P(R)

	CLR	R2			; Clear residue
	BISB	SDLEVR#(SD),R2		; Pick up last P(R) received
	MOVB	R0,SDLEVR#(SD)		; Store newly received P(R)

	CLR	R3			; Clear residue
	BISB	SDLEPS#(SD),R3		; Pick up P(S) for channel
; Here to check if P(R) legal?
	CMP	R3,R2			; Channel P(S) >= last P(R) received?
	BHIS	1$			; Yes
	ADD	#.MODP,R3		; No - too low - add modulus so it is

1$:	CMP	R0,R2			; New P(R) >= last P(R) received?
	BHIS	2$			; Yes
	ADD	#.MODP,R0		; No - too low - add modulus so it is

2$:	CMP	R0,R3			; New P(R) <= channel P(S)?
	BHI	CRESET			; No - reset channel
;-----
; Update socket send ahead count
;-----
	SUB	R2,R0			; Yes - get # of packets to acknowledge
	BEQ	4$			; Bypass if nothing ACK'd

	CMPB	R0,SDACNT#(SD)		; Greater than send ahead count?
	BLOS	3$			; No
	MOVB	SDACNT#(SD),R0		; Yes - now it isn't
	INC	DDERBF#(R4)		; Count buffer error
3$:	MOVB	SDACNT#(SD),R3		; Get send ahead count
	SUB	R0,R3			; Adjust by # packets ACK'd
	MOVB	R3,SDACNT#(SD)		; Update send ahead count

	PUSH	R1			; Save packet pointer
	CALL	LEPOKC			; See if window opened now
	POP	R1			; Restore packet pointer

4$:	BITB	#$DATA,PKSEQ(R1)	; Data packet?
	BNE	PKTFRE			; No - discard supervisory packet

;-----
; Here to check for qualified and unqualified data packets
;-----
PKTQAL:
	TBBN	$X1X25,SDLES1#(SD),10$	; Branch if X.25-TO-X.25
	TSTB	PKTYPE(R1)		; Qualified data packet?
	BPL	10$			; No - go Xlate unqualified data pkt
	CJMP	X25QAL#			; Yes - go translate it

;-----
; Here to send unqualified data packet into node
;-----
10$:
	PUSHB	PKTYPE(R1)		; SAVE GFI & LCGN (INCLUDING Q-BIT)
	PUSHB	PKSEQ(R1)		; SAVE P(R), M AND P(S)
	CALL	XPDSND			; Send X.25 data packet into node
	MAKPKT	.PLSTP			; GET A PACKET
	BCC	23$			; O.K IF GET ONE
	FSTOP	NPA			; CRASH OTHERWISE
23$:
	POPB	R0			; UNSAVE P(R), M, & P(S)
	BICB	#^C$MBIT,R0		; CLEAR EVERYTHING EXCEPT M BIT
	MOVB	R0,PKDATA+2(R1)		; STORE IN THE PACKET

	POPB	R0			; UNSAVE GFI AND LCGN
	BICB	#^C$QBIT,R0		; CLEAR EVERYTHING EXCEPT Q-BIT
	MOVB	R0,PKDATA+1(R1)		; 

	MOVB	#.FNXMK,PKDATA(R1)	; FUNCTION CODE = X.25 MARKER
	MOV	#<.PTFUN*400+3>,PKCNT(R1)  ; FUNCTION PACKET, 3 BYTES
	INCB	SDPCNT#(SD)
	CJMP	SNDPKT#

; Subroutine to send an X.25 marker function pk into node
SNDXMK::				;  and don't care m-bit nor q-bit.
	MAKPKT	.PLSTP			; GET A PACKET
	BCC	25$			; O.K IF GET ONE
	FSTOP	NPA			; CRASH OTHERWISE
25$:	MOVB	#.FNXMK,PKDATA(R1)	; FUNCTION CODE = X.25 MARKER
	MOV	#<.PTFUN*400+3>,PKCNT(R1)  ; FUNCTION PACKET, 3 BYTES
	INCB	SDPCNT#(SD)
	CJMP	SNDPKT#

;-----
; Subroutine to send an X.25 data packet (xpk) into node, since its max 
;  length = 133., an xpk will take 3 nexilis packets (pk) to move it across.
;-----
XPDSND:
	PUSH	(R1)			; Save next pkt ptr on list
	CLR	(R1)			; clear the link word
	CLRB	PKTYPE(R1)		; Store data packet type
	INCB	SDPCNT#(SD)		; Bump packet count
	CALL	SNDPKT#			; Send packet into node
	POP	R1			; Retrieve linked pkt ptr
	BNE	XPDSND			; Continue until all packets sent
RTN000:	RETURN

	.PAGE
	.SBTTL	X.25 INCOMING CALL PACKET PROCESSING
;-----
; Here on Call Request packet
;-----
PKTCON:
	CLR	ADRFLG			; INITIALIZE FLAG FOR ADDRESS NIBBLE
					;   PROCESSING
	MOV	#S#,R0			; Get pointer to scratch area
	MOV	#40,R2			; Get length of scratch area in words
1$:	CLR	(R0)+			; Clear a word
	SOB	R2,1$			; Continue until scratch area clear

	MOVB	PKDATA(R1),R2		; LENGTH OF CALLING & CALLED ADDRESS
	PUSH	R2			; AND MAKE A COPY
	BIC	#^C17,R2		; ISOLATE CALLED ADDR LENGTH
	MOV	#PKDATA+1,R0		; MAKE R0 POINT TO BEGINING OF
	ADD	R1,R0			;   THE CALLED ADREESS
	TBBN	$D0GTW,DDSTS0#(R4),10$	; BRANCH IF THE CALL COMES IN FROM A 
					;   PDN (I.E. THIS IS GATEWAY)
;-----
; Call Request is from a host computer.
;-----
	CALL	SETDST			; MOVE CALLED ADDR TO DST NAME & DST 
					;   XTENSION
	POP	R2			; RECOVER ADDR LENGTH (WON'T CHANGE C-BIT)
	BCC	5$			; BRANCH IF O.K.
	JMP	BADCDA			; OTHERWISE BAD CALLED ADDR.
5$:
	CLRB	ADRFL1			; REINITIALIZE ADRFL1 TO PROCESS 
					;   CALLING ADDRESS.
	ASHI	-4,R2			;GET THE LENGTH OF THE CALLING ADDR
	BIC	#^C17,R2		; ISOLATE LENGTH
	CALL 	SETSRC			; MOVE CALLING ADDR (IF ANY) TO SRC
					;   NAME & SRC XTENSION
	BR	20$			; BRANCH TO PROCESS FACILITIES AND CUD

;-----
; CALL REQUEST IS FROM ANOTHER NETWORK
;-----
10$:
	CALL	CHKNIC			; CHECK IF CALLED DNIC=THIS DEVICE'S NAME
					;   BUMP R0 OVER IT IF YES
					;   SET C-BIT IF NO.
	BCC	15$			; CONTINUE IF O.K.
	POP	R2
	JMP	BADCDA			; GO SEND A CLEAR REQUEST BACK IF C SET

15$:	SUB	#5,R2			; DEDUCT 5 FROM LENGTH OF CALLED ADDR 
	CALL	SETDST			; MOVE CALLED ADDR TO DST NAME & XTENSION
	POP 	R2			; GET ADDR LENGTHS BACK
	CLRB	ADRFL1
	ASHI	-4,R2			; 
	BIC	#^C17,R2		; ISOLATE LENGTH OF CALLING ADDR
	CALL	SETSRC			; GO MOVE CALLING ADDR (IF ANY) TO 
					; SRC NAME & SRC XTENSION
;-----
; HERE TO PROCESS FACILITY REQUESTS
;-----
20$:
	CALL	CHKEOF			; END OF INPUT FRAME? (I.E. NO FACILITY
					;   REQUESTS NOR CUD)
	BCS	40$			; BRANCH IF YES.
	CLR	R2
	BISB	(R0)+,R2		; GET FACILITY LENGTH
	BEQ	40$			; BRANCH IF ZERO
21$:
	CLR	R3			;
	BISB	(R0)+,R3		;GET FACILITY CODE
	TBBN	200,R3,211$		; FACILITY CODE NOT SUPPORTED
;	TBBN	200,R3,BADFCC		; FACILITY CODE NOT SUPPORTED
	TBBN	100,R3,30$		; BRANCH FOR CLASS B FACILITY
;-----
; HERE TO PROCESS CLASS A FACILITIES (THOSE FACILITIES WITH ONE BYTE OF VALUE)
;-----
	DEC	R3
	BEQ	22$		;BRANCH FOR REVERSE CHARGING/FAST SELECT
	DEC	R3
	BEQ	24$		;BRANCH FOR THROUGHPUT NEGOTIATION
	DEC	R3
	BEQ	25$		;BRANCH FOR CLOSED USER GROUP
211$:	BR	BADFCC		;BAD FACILITY CODE
22$:
	BITB	#200,(R0)	;FAST SELECT ?
	BNE	BADFCC		;YES, BUT IT'S NOT SUPPORTED YET 
	BITB	#1,(R0)		;REVERSE CHARGING?
	BEQ	23$		;NO, CHECK FOR OTHER FLAGS
	BISB	#1,S#+32	;SET THE REVERSE CHARGE BIT IN CONNECT PACKET
23$:
	BICB	#301,(R0)+	;CLEAR FAST SELECT & REVERSE CHARGING
	BNE	BADFCC		;IF STILL NOT ZERO, BAD FACILITY CODE 
	BR	28$		;CHECK NEXT FACILITY
24$:
	INC	R0		;BUMP POINTER, CONSIDER THROUGHPUT NEGO AS NOP
	BR	28$
25$:
	MOVB	(R0)+,S#+25	;MOVE CLOSED USER GROUP CODE
28$:
	SUB	#2,R2		;DECRESE FACILITY BYTE COUNT BY TWO
29$:	BGT	21$		;LOOP IF MORE
	BR	40$		;GO PROCESS CUD IF DONE WITH FACILITY REQUEST
;-----
; HERE FOR CLASS B FACILITY REQUEST
;-----
30$:
	BIC	#^C77,R3	;ISOLATE FACILITY CODE
	SUB	#2,R3		;
	BEQ	32$		;BRANCH IF PACKET SIZE NEGOTIATION
	DEC	R3		;
	BEQ	32$		;BRANCH IF WINDOW SIZE NEGOTIATION
	BR	BADFCC		;OTHERWISE, BAD FACILITY CODE
32$:
	ADD	#2,R0		;POINT TO NEXT FACILITY REQUEST
	SUB	#3,R2		;DECREASE FACILITY BYTE COUNT BY 3
	BR	29$
;-----
; HERE TO PROCESS CALLED USER DATA
;
;  R0= ADDRESS OF THE NEXT BYTE IN THE X.25 CALL PACKET TO BE PROCESSED.
;  FIRST CHECK IF ANY CUD EXIST.
;  THEN CHECK IF FIRST BYTE=1 (PAD ORIGINATED CALL)
;  IN ANY CASE, MOVE ALL CUD INTO THE MICRONET CONNECTION PACKET FOLLOWING
;    THE SOURCE EXTENSION FIELD.
;-----
40$:
	MOV	#S#+37,R3	;BEGINING OF DESTINATION EXTENSION AREA
	CLR	R2
	BISB	S#+2,R2		;GET LENGTH OF DESTINATION EXTENSION
	ADD	R2,R3		;BUMP OVER IT
	CLR	R2
	BISB	S#+3,R2		;GET LENGTH OF SOURCE EXTENSION AREA
	ADD	R2,R3		;BUMP OVER IT

	CALL	CHKEOF		;REACHED END OF X.25 CALL PACKET?
	BCS	50$		;YES, BRANCH TO FINISH UP
	CMPB	#1,(R0)		;PROTOCOL ID = PAD CALL ?
	BNE	42$		;NO, BRANCH
	MOVB	#.IDTR#,S#+14	;SET SOURCE DEVICE ID
42$:
	MOV	#16.,R2		;MAXIMUM CUD BYTE COUNT
45$:
	MOVB	(R0)+,(R3)+	;
	CALL	CHKEOF		;END OF X.25 CALL PACKET REACHED?
	BCS	50$		;YES, BRANCH
	SOB	R2,45$		;NO, MOVE ANOTHER BYTE, UP TO 16 BYTES
; xxxxx ERROR IF EVER GET HERE - CUD TOO LONG xxxxx


;-----
; HERE WHEN ALL FIELDS IN THE X.25 CALL PACKET HAVE BEEN EXAMINED.
; WE NOW COMPUTE THE LENGTH OF THE CONNECTION PACKET AND FILL THOSE
;  FIELDS THAT HAVE NO COUNTER PART IN THE X.25 CALL PACKET.
;
;	R3  = ADDRESS OF THE FIRST UNUSED BYTE IN THE CONNECTION 
;	      REQUEST PACKET.
;-----
50$:
	SUB	#S#,R3		;LENGTH OF DATA AREA OF THE CONNECT PACKET
	CMP	R3,#PKCMAX-1	;PACKET TOO LONG ? (LAST BYTE TO BE USED
				;  BY PKT2)
	BLE	55$		;NOT TOO LONG, BRANCH
	FSTOP	CPO		;CONNECT PACKET OVERFLOWED
55$:
	push	r3
	MOV	#<200+<11.*400>>,S#	; Store version # and data area length
	MOVB	#377,S#+24		; Store priv level

	MOV	#S#+31,R3		; Set ptr to data area
	MOVB	#2,(R3)+		; Store DEFAULT WINDOW SIZE
	INC	R3			; BUMP OVER THE X.25 FLAG FIELD
	MOVB	#T.CRT,(R3)+		; Store "terminal type"
	MOVB	#R.1200,(R3)+		; Store "baud rate"
	CLRB	(R3)+			; CLEAR FLAGS
	MOVB	#<P.X25+1>,(R3)+	;

	MOV	#PKDATA,R2
	ADD	R1,R2			; R2 -> DATA AREA OF THE CALL PACKET
	MOV	#S#,R0			; R0 -> DATA AREA OF THE CONN. PACKET
	
	pop	r3
	MOVB	R3,PKCNT(R1)		; Store in packet byte count
	INC	R3			; Round up byte count
	ASR	R3			; Convert byte count to word count

;-----
; Move translated packet from scratch area back into packet
;-----
58$:	MOV	(R0)+,(R2)+		; Move word from scratch area to pkt
	SOB	R3,58$			; Continue until whole pkt stored

	CLRB	SDLEVR#(SD)		; Clear last received P(R)
	CLRB	SDLEPR#(SD)		; Clear this end's P(R)
	CLRB	SDLEPS#(SD)		; Clear this end's P(S)
	CLRB	SDLERR#(SD)		; Clear this end's pending RR count
	CLRB	SDFCNT#(SD)		; Clear socket flag count
	CLRB	SDACNT#(SD)		; Clear socket send ahead count
	CLR	SDLES1#(SD)		; Clear SOCKET STATUS BITS


	.SBTTL	LKESND - Subroutine to send translated packet into node
;-----
; Here to send translated packet into node
;-----
LKESND::INCB	SDPCNT#(SD)		; Bump packet count
	CJMP	SNDPKT#			; Go send pkt into node

	.PAGE
	.SBTTL	X.25 CALL PACKET ERROR HANDLING
;-----
; HERE FOR BAD FACILITY CODE
;-----
BADFCC:
	MOV	#<.XCCIF+<400*.XDFCN>>,R0 ;CLEARING CAUSE=INVALID FACILITY REQUEST
					;DIAGNOSTIC=FACILITY CODE NOT ALLOWED
	BR	CLRCAL

;-----
; HERE FOR BAD CALLED ADDRESS
;-----
BADCDA:
	MOV	#<.XCCNO+<400*.XDICD>>,R0 ;CLEARING CAUSE=NOT OBTAINABLE
					;DIAGNOSTICS=INVALID CALLED ADDRESS


;-----
; HERE TO SEND A CLEAR PACKET IN RESPONSE TO CALL REQUEST
;
;	R0 = CLEAR CAUSE CODE & DIAGNOSTICS
;	R1 = ADDRESS OF THE X.25 CALL PACKET
;-----
CLRCAL:
	PUSH	R0			;SAVE CAUSE CODES
	PUSH	R1			;SAVE ADDRESS OF 1ST PACKET OF X.25 CALL
	MOV	(R1),R1			;
	BEQ	1$			;BRANCH IF IT WAS THE ONLY ONE
	CALL	PKTFRE			;
1$:
	POP	R1
	MOV	(SP)+,PKDATA(R1)	;STORE CAUSE CODE & DIAGNOSTICS
	MOV	#<.LCG*400+2>,PKCNT(R1)	;BYTE COUNT=2
	MOVB	SDSOC#(SD),PKSOC(R1)	;SET UP CHANNEL NUMBER
	MOVB	#.XCLRQ,PKSEQ(R1)	;PACKET TYPE = CLEAR REQUEST
	JMP	SNDBA1

	.PAGE
	.SBTTL	SUBROUTINES TO HANDLE X.25 CALL REQUEST PACKET

;-----
; SETDST -
;   SETUP DESTINATION DEVICE NAME AND EXTENSION AREA IN A MICRONET CONNECTION
;    REQUEST PACKET FROM THE CALLED DTE ADDRESS IN AN X.25 CALL REQUEST 
;    PACKET
;   INPUT CONDITION - 
;	R0 = ADDRESS OF THE CALLED DTE ADDRESS FIELD IN AN X.25 CALL PACKET
;	R2 = LENGTH OF CALLED ADDRESS (NUMBER OF BCD DIGITS)
;   EXIT CONDITION -
;	C-BIT CLEAR - NORMAL;  C-BIT SET - ERROR IN CALLED DTE ADDRESS
;	R0 = ADDRESS OF THE BYTE CONTAINING THE THE LAST DIGIT OF THE CALLED
;		DTE ADDRESS (IF ADRFLG IS SET) OR THE BYTE FOLLOWING THE LAST
;		DIGIT OF THE CALLED ADDRESS (IF ADRFLG IS CLEAR)
;	ADRFLG: CLEARED IF CALLED ADDRESS HAS EVEN NUMBER OF DIGITS;
;		SET IF ODD.
;----
	LDSEEN	=	%4	;R4 : LEADING NON-ZERO DIGIT SEEN FLAG

SETDST:
	PUSH	R1
	MOV	#S#+6,R1	;R1 -> DESTINATION DEVICE NAME FIELD
	PUSH	R5
	MOV	#5,R5		; UP TO 5 DIGITS FOR DESTINATION DEVICE NAME
	PUSH	LDSEEN		; SAVE R4
	CLR	LDSEEN		; CLEAR FLAG

	TST	R2		; IS THERE A CALLED DTE ADDRESS ?
	BLE	CLRC		; NO, GO POP & RETURN
5$:
	CLR	R3
	BISB	(R0),R3		; GET TWO DIGITS
	TSTB	ADRFLG		; ON BYTE BOUNDARY ?
	BNE	8$		; NO, BRANCH
	ASHI	-4,R3		; YES, SHIFT HIGHER 4 BITS DOWN BY 4
	BR	9$
8$:	INC	R0		; DONE WITH THIS BYTE, POINT TO NEXT
9$:	COMB	ADRFLG		; Flip the bits of adrflg.
	BIC	#^C17,R3	; ISOLATE A BCD DIGIT
	BNE	10$		; NON ZERO, BRANCH

	TST	LDSEEN		; HAS A NONZERO DIGIT SEEN ?
	BEQ	15$		; NOT YET, BRANCH
10$:	CMP	R3,#9.		; VALID DIGIT ?
	BGT	SETC		; NO, BRANCH
	INC	LDSEEN		; SET THE FLAG (MAKE R4 NONZERO)
	ADD	#60,R3		; BCD TO ASCII
	MOVB	R3,(R1)+	; STORE THE DIGIT
15$:
	DEC	R2		; DONE WITH ALL DIGITS IN CALLED ADDR ?
	BEQ	CLRC		; YES, GIVE GOOD RETURN
	SOB	R5,5$		; LOOP FOR UP TO 5 DIGITS
;-----
; HERE IF DONE WITH FIRST 5 DIGITS. MOVE THE REST INTO DESTINATION EXTENSION
;-----
	MOV	#S#+37,R1	; ADDR OF DESTINATION EXTENSION AREA
	CLR	R4		; 
25$:
	GETNIB
	BCS	SETC
	TST	R4		; 1ST DIGIT AFTER DEST. DTE NUMBER ?
	BNE	26$		; NO, BRANCH
	MOVB	R3,S#+4		; YES, USE IT AS DEST. DEVICE ID
26$:
	PUTNIB
	DEC	R2		; DONE WITH CALLED ADDRESS ?
	BNE	30$		; NOT YET, BRANCH
;-----
; ODD NUMBER OF DIGITS IN DEST. EXT. AREA; FILL THE LAST NIBBLE WITH B'1111'
;-----
	MOVB	#17,R3
	INC	R2		; MAKE SURE IT EXITS THE LOOP
	BR	35$
;-----
; HERE TO PROCESS THE EVEN NUMBERED NIBBLE IN THE DEST. EXT. AREA
;-----
30$:	GETNIB
	BCS	SETC
	TST	R4		; PROCESSING THE 2ND DIGIT AFTER THE DEST. DTE 
				; NUMBER ?
	BNE	35$		;   NO, BRANCH
	TSTB	S#+4		;   YES, DEST. DEV. ID. = 0?
	BEQ	32$		;     YES, BRANCH
	MOVB	R3,S#+5		;     NO, USE THIS DIGIT AS THE SOCKET NUMBER
32$:
	INC	R4		; INDACATE THAT 1ST 2 DIGITS AFTER DEST. DTE
				; IS PASSED.
35$:	PUTNIB
	INCB	S#+2		; INCREMENT LENGTH OF DESTINATION EXTENSION
	SOB	R2,25$		; LOOP UNTIL DONE WITH THE CALLED ADDRESS
CLRC:
	CLC
CLRC01:
	POP	LDSEEN
	POP	R5
	POP	R1
	RETURN

SETC:
	SEC
	BR	CLRC01
	.PAGE
;-----
; SETSRC -
;  SET SOURCE DEVICE NAME AND SOURCE EXTENSION AREA BASED ON THE CALLING
;    ADDRESS FIELD IN THE X.25 CALL PACKET
;   INPUT CONDITION - 
;	R0 = ADDRESS OF THE CALLING DTE ADDRESS FIELD IN AN X.25 CALL PACKET
;	R2 = LENGTH OF CALLING ADDRESS (NUMBER OF BCD DIGITS)
;   EXIT CONDITION -
;	C-BIT CLEAR - NORMAL;  C-BIT SET - ERROR IN CALLING DTE ADDRESS
;	R0 = ADDRESS OF THE BYTE CONTAINING THE THE LAST DIGIT OF THE CALLING
;		DTE ADDRESS (IF ADRFLG IS SET) OR THE BYTE FOLLOWING THE LAST
;		DIGIT OF THE CALLING ADDRESS (IF ADRFLG IS CLEAR)
;	ADRFLG: CLEARED IF CALLING ADDRESS HAS EVEN NUMBER OF DIGITS;
;		SET IF ODD.
;-----
SETSRC:
	PUSH	R1
	MOV	#S#+16,R1	; ADDRESS OF SOURCE DEVICE NAME
	PUSH	R5
	MOV	#12.,R5		; MAXIMUM # OF DIGITS THAT SOURCE DEVICE 
				;  NAME FIELD CAN HOLD.
	PUSH	R4		; SO THAT "CLRC" CODE ABOVE CAN BE SHARED
	TST	R2		; IS THERE A CALLING ADDRESS ?
	BEQ	30$		; NO, BRANCH
5$:
	GETNIB
	PUTNIB
	DEC	R2		; DONE WITH CALLING ADDRESS ?
	BEQ	40$		; YES, BRANCH
	SOB	R5,5$		; NO, DONE WITH FIRST 6 DIGITS

;-----
; HERE IF DONE WITH FIRST 12. DIGITS OF THE CALLING ADDRESS
;  MOVE THE REST TO SOURCE EXTENSION AREA
;-----
	MOV	#S#+37,R1	; POINTS TO DESTINATION EXTENSION AREA
	ADD	S#+2,R1		; ADD THE LENGTH OF DESTINATION EXT.
				; (LENGTH OF SOURCE EXT. SHOULD STILL BE ZERO)
25$:
	GETNIB
	PUTNIB
	INCB	S#+3		; INCREMENT LENGTH OF SOURCE EXTENSION AREA
	SOB	R2,25$		; LOOP UNTIL DONE WITH CALLING ADDRESS
	BR	40$

;-----
; HERE IF NO CALLING DTE ADDRESS IS SPECIFIED
;   USE THE NAME OF THIS DEVICE AS THE SOURCE DEVICE NAME, PREFIX
;     WITH ZEROS TO FOUR DIGITS IF NECESSARY.
;-----
30$:
	MOV	(SP),R4		; GET DDB ADDRESS
	ADD	#DDLKNA#,R4	; POINTS TO DEVICE NAME FIELD
	PUSH	R0
	MOV	R4,R0
	MOV	#4,R5
32$:
	TSTB	(R4)+		; NULL ?
	BEQ	35$
	SOB	R5,32$		; LOOP TO COUNT THE NUMBER OF CHARACTERS IN 
				; DEVICE NAME
35$:	
	NEG	R5		; TWO'S COMPLEMENT
	ADD	#4,R5		; HOW MANY CHARACTER IN THE NAME ?
	BEQ	39$		; NO NAME IN DDB FOR THIS DEVICE (UNLIKELY)
38$:
	GETBYT
	PUTNIB
	SOB	R5,38$
39$:	POP	R0		;
40$:
	TSTB	ADRFLG		; ON BYTE BOUUNDARY ?
	BEQ	50$		;YES, BRANCH
	INC	R0		;NO, FORCE POINTER TO NEXT BYTE
50$:
	TSTB	ADRFL1		;SOURCE DEVICE NAME ON BYTE BOUNDARY ?
	BEQ	CLRC		;YES, BRANCH.
	MOVB	#17,R3		;NO, SET IT TO B'1111'
	PUTNIB
	BR	CLRC

;-----
; CHKNIC -
;   CHECK DNIC OF CALLED ADDRESS IN AN X.25 CALL PACKET THAT CAME IN ON A 
;     GATEWAY.  THE FIRST 5 DIGITS SHOULD AGREE WITH THE DEVICE NAME OF THE 
;     GATEWAY.  IF IT DOES, R0 WILL POINT TO THE BYTE FOLLOWING THE FIRST 5
;     DIGITS OF THE CALLED DTE ADDRESS.
;     * NOTICE THAT LEADING ZERO IN DNIC IS ALLOWED EVEN THOUGH NONE IS
;	USED IN THE RECOMMENDATION X.121.
;   INPUT:
;	R2 = LENGTH OF CALLED ADDRESS
;	R0 = ADDRESS OF THE CALLED ADDRESS
;   EXIT:
;	C-BIT SET, FIRST 5 DIGITS DOES NOT MATCH;  C-BIT CLEAR, O.K.
;	R0 = ADDRESS OF THE BYTE FOLLOWING THE FIRST 5 DIGITS OF CALLED ADDR
;-----
CHKNIC:
	PUSH	R1
	PUSH	R3
	PUSH	R5
	PUSH	LDSEEN		;SAVE R4
	CLR	LDSEEN		;CLEAR THE LEADING (NONZERO) DIGIT SEEN FLAG
	MOV	#DDLKNA#,R1
	ADD	(SP),R1		;R1 POINTS TO DEVICE NAME IN ASCII
	MOV	#5,R5		;NUMBER OF DIGITS TO COMPARE
	CMP	R2,R5		;ENOUGH DIGITS IN CLD ADDRESS?
	BLT	40$		;NO, COMPLAIN TO CALLER
5$:
	MOVB	(R0),R3		;GET TWO DIGITS
	COMB	ADRFLG		;FLIP FLAG BITS ALWAYS
				;ON BYTE BOUNDARY ?
	BEQ	8$		;NO, BRANCH
	ASHI	-4,R3		;YES, SHIFT HIGHER 4 BITS DOWN BY 4
	BR	9$
8$:	INC	R0		;DONE WITH THIS BYTE
9$:	BIC	#^C17,R3	;ISOLATE LOWER FOUR BITS
	BEQ	30$		;ZERO, BRANCH
	INC	LDSEEN		;LEADING ZERO SEEN IS TRUE
10$:	ADD	#'0,R3		;BCD TO ASCII
	CMPB	R3,(R1)+	;MATCH DEVICE NAME ?
	BNE	40$		;NO, SET C-BIT AND RETURN
15$:	SOB	R5,5$		;LOOP UNTIL FIRST 5 DIGITS CHECKED
	TST	LDSEEN		;NON-ZERO DIGIT SEEN ?
	BEQ	40$		;NO, DNIC CAN NOT BE ZERO (ERROR!)
	CLC			;YES, GOOD RETURN
	BR	50$
30$:
	TST	LDSEEN
	BNE	10$
	BR	15$		;IF LEADING ZERO, DON'T CHECK WITH DEVICE NAME
40$:
	SEC			;GIVE BAD RETURN
50$:	POP	LDSEEN
	POP	R5
	POP	R3
	POP	R1
	RETURN

;-----
; CHKEOF -
;   HERE TO CHECK IF END OF X.25 CALL PACKETIS REACHED
;  INPUT:
;	R0 = ADDRESS OF NEXT BYTE TO PROCESS IN THE X.25 CALL PACKET
;	PKCNT(R1) = # OF BYTES IN THE DATA AREA
;  EXIT:
;	C-BIT SET - END OF PACKET REACHED;  C-BIT CLEARED OTHERWISE
;-----
CHKEOF:
	PUSH	R2
	clr	r2
	bisb	pkcnt(r1),r2
	add	r1,r2
	add	#pkdata,r2	;R2 now points to the byte beyond the x.25 
				;  frame

	CMP	R0,R2		;
	BHIS	10$		;BRANCH IF END OF PACKET REACHED
	CLC
	BR	20$
10$:	SEC
20$:	POP	R2
	RETURN
	

	.PAGE
	.SBTTL	X.25 CALL CONNECTED/ACCEPTED PROCESSING

;-----
; Here on call connected packet
;-----
PKTACK:
;+--us701
	BIC	#$X1UNO,SDLES1#(SD)	;CLEAR UNNUMBERED FRAME OUTSTANDING
	MOVB	#1,PKCNT(R1)		;
	MOVB	#.FNX47,PKDATA(R1)	;FUNCTION = X.25 call accepted
	JMP	LKESND
;---us701
	MOVB	#3,PKCNT(R1)		; Packet byte count = 3
	MOVB	SDSOC#(SD),PKDATA(R1)	; Store socket #

	MOVB	#024,PKDATA+1(R1)	; TELL TERM. DRIVER NOT TO SET PROFILE
					;   AND DON'T HOLD INPUT WHEN OUTPUT ACTIVE
	MOVB	#P.X25+1,PKDATA+2(R1)	; TELL THE OTHER END THIS IS X.25

	BIC	#$X1UNO,SDLES1#(SD)	; Clear outstanding unnumbered pkt flag
	CALL	LKESND			; Send pkt into node
	RETURN

;-----
; Here on interrupt packet
;-----
PKTINT:	TBBN	$X1X25,SDLES1#(SD),20$	; BRANCH IF X.25-TO-X.25
	CMPB	SDSDID#(SD),#.IDTR#	;IS THE OTHER END A TERMINAL ?
	BEQ	20$			;BRANCH IF YES
	MOV	#.XITCF,R0		; Send back pkt type = intrpt confirm
	CLR	R2			; Data area is empty

	PUSH	R1			; Save R1
	CALL	SNDBAK			; Send interrupt confirmation back
	POP	R1			; Restore packet pointer

	CLR	PKDATA(R1)		; Null marker is noop function
10$:	MOVB	#2,PKCNT(R1)		; Data area has 2 bytes
	JMP	LKESND			; Send interrupt pkt into node
;-----
; HERE IF X.25-TO-X.25 OR X.25 TO A TERMINAL,
;   SEND A INTERRUPT PACKET WITH THE INTERRUPT USER DATA
;-----
20$:	MOVB	PKDATA(R1),R0		; GET INTERRUPT USER DATA
	SWAB	R0			; SWAP IT TO HIGHER BYTE
	BISB	#.FNXIT,R0		; ADD THE FUNC. CODE (X.25 INTERRUPT)
	MOV	R0,PKDATA(R1)
	BR	10$
;-----
; HERE ON THE RECEPTION OF INTERRUPT CONFIRMATION PACKET
;-----
PKTITC:	TBBN	$X1X25,SDLES1#(SD),10$	;BRANCH IF X.25-TO-X.25
	CMPB	SDSDID#(SD),#.IDTR#	;IS THE OTHER END A TERMINAL ?
	BEQ	10$			;BRANCH IF YES
	JMP	PKTUAK
10$:
	BIC	#$X1UNO,SDLES1#(SD)	;CLEAR UNNUMBERED FRAME OUTSTANDING
	MOVB	#1,PKCNT(R1)		;
	MOVB	#.FNXIC,PKDATA(R1)	;FUNCTION = X.25 INTERRUPT CONFIRMATION
	JMP	LKESND
;-----
; Here on clear request packet
;-----
PKTDIS:
	CMPB	SDSTS1#(SD),#.SSCTP	; CONNECT TO PENDING STATE ?
	BNE	10$			; BRANCH
;-----
; IF THE SOCKET IS IN CONNECT-TO-PENDING STATE, A CLEAR CONFIRMATION PACKET 
;  NEEDS TO BE SEND BACK TO THE X.25 LINK IN ADDITION TO THE DISCONNECT
;  PACKET TO BE SEND INTO THE NODE
;-----
	PUSH	R1			; SAVE THE DISCONNECT PACKET
	MAKPKT	.PLSTP#			; GET A PACKET
	BCC	5$			; FINE IF GET ONE
	FSTOP	NPA			; NO PACKET AVAILABLE
5$:
	MOV	#<.LCG*400>,PKCNT(R1)	; COUNT = 0,
	MOVB	SDSOC#(SD),PKSOC(R1)	; SET UP CHANNEL NUMBER
	MOVB	#.XCLCF,PKSEQ(R1)	; X.25 CLEAR CONFIRMATION
	CALL	SNDBA1			; ADD IT TO SEND BACK LIST
	POP	R1			; RESTORE THE DISCONNECT PACKET POINTER
10$:
	MOVB	PKDATA(R1),R0		; Get X.25 clearing reason
	CMP	R0,#NEXR		; Valid reason?
	BLO	100$			; Yes
	MOVB	#.ERILD,PKDATA(R1)	; No - indicate system error in network
	BR	120$			; Go put gateway name into packet

100$:	MOVB	NEXRSN(R0),PKDATA(R1)	; Pick up NEXILIS equivalent reason

120$:	PUSH	R1			; Save packet pointer
	PUSH	R4			; Save DDB address
	PUSHB	PKDATA+1(R1)		; Save diagnostic

;	MOV	#2,R0			; Already 1 byte in packet, add 1 later
	MOV	#3,R0			; Already 1 byte in packet, add 2 later
					;  1 null and 1 diagnostic
	ADD	#PKDATA+1,R1		; Get pointer to packet data area
	ADD	#DDLKN1#,R4		; Get pointer to gateway name

	CALL	RD50XX#			; Convert 1st half of name to ASCII
	CALL	RD50XX#			; Convert 2nd half of name to ASCII
	CLRB	(R1)+			; Put a null byte as seperator;usB01
	POPB	(R1)			; Restore the diagnostic
	POP	R4			; Restore DDB address
	POP	R1			; Restore packet pointer

	CLRB	SDLEVR#(SD)		; Clear last received P(R)
	CLRB	SDLEPR#(SD)		; Clear this end's P(R)
	CLRB	SDLEPS#(SD)		; Clear this end's P(S)
	CLRB	SDLERR#(SD)		; Clear this end's pending RR count
	CLRB	SDFCNT#(SD)		; Clear socket flag count
	CLRB	SDACNT#(SD)		; Clear socket send ahead count
	BIC	#<$X1JTX!$X1JFX!$X1X25>,SDLES1#(SD) ; Clear I/O supress & X.25 bits 

	MOVB	R0,PKCNT(R1)		; Store packet byte count
	JMP	LKESND			; Send pkt into node

;-----
; X.25 Call Clearing to NEXILIS Disconnect reason translation table
;-----
	PURE

NEXRSN:	.BYTE	.ERREQ			; DTE clearing(0)
	.BYTE	.ERSIU			; Number busy(1)
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERIFR			; Invalid call(3)
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERBFF			; Network congestion(5)
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERLKD			; Out of order(11)
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERCRF			; Access barred(13)
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERHNA			; Not obtainable(15)
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERRPE			; Remote procedure error(21)
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERLPE			; Local procedure error(23)
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERGWD			; RPOA out of order
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERNRC			; Number refuses reverse charging(31)
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERRPE			; Undefined
	.BYTE	.ERICD			; Incompatable destination(41)
NEXR	=! .-NEXRSN

	CODE

;-----
; Here on clear confirmation packet
;-----
PKTDAK:	CLRB	SDLEVR#(SD)		; Clear last received P(R)
	CLRB	SDLEPR#(SD)		; Clear this end's P(R)
	CLRB	SDLEPS#(SD)		; Clear this end's P(S)
	CLRB	SDLERR#(SD)		; Clear this end's pending RR count
	CLRB	SDFCNT#(SD)		; Clear socket flag count
	CLRB	SDACNT#(SD)		; Clear socket send ahead count

	CLRB	PKCNT(R1)		; Null data area
	BIC	#$X1UNO,SDLES1#(SD)	; Clear outstanding unnumbered pkt flag
	JMP	LKESND			; Send pkt into node

;-----
; Here on restart request packet
;	If Restart Outstanding, we have a collision on Restart.
;	The Restart is considered as completed.  No Restart Confirmation
;	will be sent.
;-----
PKTRST:
	TBBE	$X1RSO,SDLES1#(SD),10$	; If no Restart outstanding, send confirmation
	BIC	#$X1RSO,SDLES1#(SD)	; else clear the condition
	FREPKT				; free the restart request packet
	RETURN				; and return
10$:
	PUSH	R1			; Save packet pointer
	CALL	LKEDWN#			; Declare link down for now
	CALL	LNKUP#			; Declare link up to reset this side
	POP	R1			; Restore packet pointer
	CLRB	PKCNT(R1)		; No data in packet
	MOVB	#.XRSCF,PKSEQ(R1)	; Send back packet = restart confirm
	BR	SNDBA1			; Send back restart confirmation pkt

;-----
; Here on reset request packet
;-----
PKTRES:	PUSH	R1			; Save first packet for sendback

	MOV	(R1),R1			; Get rest of list
	BEQ	1$			; Skip if nothing there

	CALL	PKTFRE			; Discard all but 1st pkt on list
1$:	POP	R1			; Retrieve packet pointer

	CLRB	SDLEVR#(SD)		; Clear last received P(R)
	CLRB	SDLEPR#(SD)		; Clear this end's P(R)
	CLRB	SDLEPS#(SD)		; Clear this end's P(S)
	CLRB	SDLERR#(SD)		; Clear this end's pending RR count
	CLRB	SDFCNT#(SD)		; Clear socket flag count
	CLRB	SDACNT#(SD)		; Clear socket send ahead count
	
	BIC	#$X1UNO,SDLES1#(SD)	; THIS PACKET MAY AN GOBBLE AN 
					;  INTERRUPT CONFIRMATION SENT EARLIER.

	TBBN	$X1X25,SDLES1#(SD),10$	;BRANCH IF X.25-TO-X.25
	CMPB	SDSDID#(SD),#.IDTR#	;OR IF THE OTHER END IS A TERMINAL
	BEQ	10$
	MOV	#.LCG*400,PKCNT(R1)
	MOVB	#.XRECF,PKSEQ(R1)	; Store X.25 reset confirm pkt type
	BR	SNDBA1			; Send back the prepared packet
10$:
	CLR	R3
	BISB	PKCNT(R1),R3		;GET BYTE COUNT
	CMP	R3,#2			;TWO BYTES OR LESS ?
	BLOS	15$			;YES, BRANCH
	MOV	#2,R3			;FORCE IT TO TWO
	MOVB	R3,PKCNT(R1)
15$:
	MOV	#PKDATA,R2
	ADD	R1,R2
	ADD	R3,R2			;R2 -> END OF RESET CAUSE & DIAG. CODE
	MOV	R2,R0
	INC	R0
20$:
	MOVB	-(R2),-(R0)
	SOB	R3,20$
	MOVB	#.FNXRS,(R2)		;FUNCTION CODE = X.25 RESET
	INCB	PKCNT(R1)
	BIC	#$X1JFX,SDLES1#(SD)	;IN CASE OF A RESET COLLISION
	BIS	#$X1JTX,SDLES1#(SD)	;SET JUNK-TO-X.25 FLAG
	JMP	LKESND
	.SBTTL	SNDBAK - Subroutine to send generated response back
;-----
; SNDBAK - Subroutine to send a packet back to the other end of the link
;
; Linkage:
;	C(R0) = X.25 packet type
;	C(R2) = # bytes in data field
;	S (transient scratch area) = data field bytes
;
; Unpreserved registers:
;	R0, R1, R2
;-----
SNDBAK:	MAKPKT	.PLSTP#			; Get a packet
	BCC	1$			; Ok if got a packet
	FSTOP	NPA			; [No Packets Available]

1$:	MOVB	#.LCG,PKTYPE(R1)	; Store logical channel group byte
	MOVB	SDSOC#(SD),PKSOC(R1)	; Store logical channel number
	MOVB	R0,PKSEQ(R1)		; Store packet type byte
	MOVB	R2,PKCNT(R1)		; Store packet byte count
	BEQ	SNDBA1			; Bypass if nothing to do

	PUSH	R1			; Save packet pointer
	ADD	#PKDATA,R1		; Add offset to packet data area
	MOV	#S#,R0			; Pick up pointer to scratch area
	ASR	R2			; Convert byte count to word count

2$:	MOV	(R0)+,(R1)+		; Move scratch word to packet
	SOB	R2,2$			; Continue until packet data stored

	POP	R1			; Restore packet pointer

;-----
; Send packet directly back or buffer it in send back list
;-----
SNDBA1:	TBBN	$D1ACT,DDSTS1#(R4),1$	; If active - buffer packet
	JMP	XMTPKT			; Inactive - go send packet

1$:	TST	DDLEAT#(R4)		; Anything on send back list?
	BEQ	2$			; No
	MOV	R1,@DDLEAT#(R4)		; Yes - link this packet into list
	BR	3$			; Go update tail pointer
2$:	MOV	R1,DDLEAH#(R4)		; Update send back list header
3$:	MOV	R1,DDLEAT#(R4)		; Update send back list tail
	RETURN				; Return to caller
;---------------------------------------------------------------


	IMPURE
;-----
F51TMP:	.WORD	0	;for function pk .FNX51 --us701
; THE FOLLOWING TWO BYTES MUST GO TOGETHER IN THIS ORDER
ADRFLG:	.BLKB	1	;FLAG FOR X.25 CALL PACKET ADDRESSES FETCHING OPERATION
ADRFL1:	.BLKB	1	;FLAG FOR X.25 CALL PACKET ADDRESSES STORING OPERATION
;-----
	.EVEN

	.END
cr Q