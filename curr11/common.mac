	.TITLE	COMMON CONFIGURATION DEPENDENT DATA
	.SBTTL	COMMON - NEXILIS/JRG

.IF NDF	VERNO
	VERNO==!256		; V256		15-JULY-84
.ENDC
.IF NDF	EDTNO
	EDTNO==!0		; V256.0	15-JULY-86
.ENDC

	XLPAR			;DON'T LIST PARAMETER FILE
	.ENABL	SCM		;SUPPRESS COMMENTS IN MACROS SO WILL ASSEMBLE
				;  IN A REASONABLE AMOUNT OF MEMORY!

	.SBTTL	PASS1 - DETERMINE WHICH DEVICES EXIST ON THIS NODE


;.IF     EQ  .PASS2                      ;JUST DURING PASS 1!
;DEFINE MACRO USED TO DEFINE SYMBOLS

	.MACRO	DEFINE  SYM,VAL
SYM==!VAL
	.ENDM

	.MACRO	NAME  XXX
	.ENDM

	.MACRO	FATAL		;INVOKE THIS TO MAKE ALL NODE CRASHES FATAL
..FTL=!1			;  FOR DEBUGGING
	.ENDM
..FTL=!0

	.MACRO	TYMSAT
..SAT=!1
	.ENDM
..SAT=!0

	.MACRO	ROM	RAMSTA
ROMFLG==!1
NODFLG==!NODFLG!$NSNCS
.IF NB	RAMSTA
PKTBGN==!RAMSTA
.IFF
PKTBGN==!100000
.ENDC
	.ENDM
ROMFLG==!0
NODFLG==!0

LK.NUM=!0
TR.NUM=!0



	.MACRO	LINK  NAME,PRIV,AUX,SOC,PS,TYPE,XXX
.IF EQ .PASS2
 .IF NDF LK'TYPE'NUM
   LK'TYPE'NUM=!1
 .IFF
   LK'TYPE'NUM=!LK'TYPE'NUM+1
 .ENDC
.ENDC
XLINK=!-1			;This symbol useful for Tymnet links
.IF IDN <TYPE><H>		;If this is a type H link
	LINKHX	XXX
.ENDC
.IF IDN <TYPE><I>		;If this is a type I link
	LINKIX	\LK.NUM,XXX
.ENDC

 LK.NUM=!LK.NUM+1
	.ENDM	LINK

	.MACRO	LINKHX  X1,X2,X3
.IF IDN <X3><TPC>
  LHTPC=!1
.ENDC
	.MACRO	LNKH  TYMHST,NEXHST,HOSPRT
LHBASE=!1
	.ENDM	LNKH

LHALNS=!0
LHBLNS=!0
	.MACRO	LNKL  CHN,NBR,SPEED,SAT,SUBTYP,XXXX
LH'SUBTYP'LNS=!LH'SUBTYP'LNS+1
	.ENDM	LNKL

	.ENDM	LINKHX

	.MACRO	LINKIX  DEV,X1,X2,X3
.IF IDN <X3><TPC>
  LITPC=!1
.ENDC
L.NH'DEV=!0
	.MACRO	LNKH  TYMHST,NXLHST,DEVTYP,PRODID
LIBASE=!1
	.IRP	HOST,<\L.NH'DEV>
LD'DEV'.'HOST=!100000!^D'TYMHST'.;FIRST WORD OF HOST DESCRIPTOR
L'DEV'.D'HOST=!0
.IF NB	<DEVTYP>
 L'DEV'.D'HOST=!.ID'DEVTYP	;DEVICE TYPE IF NODE AND DEVICE FORMAT
.ENDC
	.WR50	1,NXLHST,L.'HOST'A'DEV;DEFINE SYMBOLS FOR NEXILIS HOST NAME
	.WR50	4,NXLHST,L.'HOST'B'DEV
	.ENDM
L.NH'DEV=!L.NH'DEV+1
	.ENDM	LNKH

L.NL'DEV=!0
LIALNS=!0
LIBLNS=!0
	.MACRO	LNKL  CHN,NBR,SPEED,SAT,SUBTYP,XXXX
LI'SUBTYP'LNS=!LI'SUBTYP'LNS+1
L.NL'DEV=!L.NL'DEV+1
	.ENDM	LNKL
	.ENDM	LINKIX


	.MACRO	DEV  DV,D1,D2
DV'.NUM=!1
DV'.S0==!0
	.MACRO	SOC  SCN,TYPE,XXX
DV'.S0==!DV'.S0+1
.IF EQ .PASS2
.IF NDF DV''TYPE'NUM
  DV''TYPE'NUM=!1
.IFF
  DV''TYPE'NUM=!DV''TYPE'NUM+1
.ENDC
.ENDC
	.ENDM
	.ENDM

	.MACRO	HCL  A,LIST
	.ENDM

	.MACRO	DHOST  HOST
	.ENDM

	.MACRO	KHOST  HOST,XRAY,DLOAD
	.ENDM

	.MACRO	THOST	HOST
	.ENDM

	.MACRO	LINX  TYPE,XXX
TR.NUM=!TR.NUM+1
.IF EQ .PASS2
.IF NDF TR'TYPE'NUM
  TR'TYPE'NUM=!1
.IFF
  TR'TYPE'NUM=!TR'TYPE'NUM+1
.ENDC
.ENDC
	.ENDM

	.MACRO	LINE  LN,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
L..LN=LN
	.ENDM

	.MACRO	PVCXX	LNN,PVCSTR,P1,P2
	.PSECT	PURE,RW,D,LCL,REL,CON
PVC'LNN:: .BYTE	P1+4
	.BYTE	P2
	.ASCIZ	PVCSTR
	.EVEN
	.ENDM

        .MACRO  PVC     PVCSTR,P1,P2
	PVCXX	\<L..LN>,<PVCSTR>,P1,P2
        .ENDM

	.MACRO	MOD	STRING
	.ENDM

	.MACRO	TRMMSG	STRING
	.ENDM

	.PSECT	LOWMEM,RW,D,LCL,REL,CON

	.SBTTL	PASS1 - INVOKE THE CONFIGURATION MACRO TO COUNT DEVICES

	CONFIG

;.ENDC			;.IF EQ .PASS2

        .MACRO  PVC     PVCSTR,P1,P2
        .ENDM
	.PAGE
	.SBTTL	DEFINE ORDER OF LOADING PSECT'S

;MUST DO THIS HERE SINCE SOME OF THE CONFIGURATION MACROS PLACE CODE IN VARIOUS
;  PSECTS WHEN THEY ARE INVOKED BY THE CONFIGURATION FILE.  THIS MUST COME
;  FIRST


;THE FOLLOWING PSECT'S ARE PURE AND CONTAIN DATA

	.PSECT	SX    ,RW,D,LCL,REL,CON
SXTBL::
	.PSECT	PURE  ,RW,D,LCL,REL,CON

;THE FOLLOWING PSECT'S ARE PURE AND CONTAIN INSTRUCTIONS

	.PSECT	MAIN  ,RW,I,LCL,REL,CON
	.PSECT	CODE  ,RW,I,LCL,REL,CON
	.PSECT	SECOND,RW,I,LCL,REL,CON
SECOND::
	.PSECT	TENTHS,RW,I,LCL,REL,CON
TENTHS::
	.PSECT	INIT  ,RW,I,LCL,REL,CON
INISUB::

.IF NE	ROMFLG
	.PSECT	FALCBT,RW,I,LCL,REL,CON
	JMP	GO#			;HANDLE NORMAL STARTUP
	CMP	#137,@4			;IS THE JUMP TABLE SET UP
	BNE	10$			;NO
	JMP	@4			;HANDLE RESTART
10$:	JMP	NXMERR#

	.PSECT	INIDAT,RW,D,LCL,REL,CON
INIDAT::
	.PSECT	INIBYT,RW,D,LCL,REL,CON
INIBYT::
.ENDC

;THE FOLLOWING PSECT'S ARE IMPURE AND CONTAIN THE DEBUGGER AND ITS SYMBOL
;  TABLE (IF LOADED)

	.PSECT	.XDT. ,RW,I,GBL,REL,OVR
	.PSECT	.SYM. ,RW,D,GBL,REL,OVR


;THE FOLLOWING PSECT'S ARE IMPURE AND CONTAIN DATA

;*****	THE PDATA PSECT ADDED BY DRE 11/20/80 FOR CRASH SAVE SUPPORT
;	PDATA CONTAINS DATA WHICH IS SAVED ACROSS NODE CRASHES
	.PSECT	PDATA ,RW,D,LCL,REL,CON
PDATA::
	.PSECT	DDB   ,RW,D,LCL,REL,CON
DDBBGN::
	.PSECT	LDB   ,RW,D,LCL,REL,CON
LDBBGN::
	.PSECT	ADB   ,RW,D,LCL,REL,CON
	.PSECT	SDB   ,RW,D,LCL,REL,CON
SDBBGN::
	.PSECT	IMPURE,RW,D,LCL,REL,CON
IMPBGN::
CKSVAL::.WORD	0			;MEMORY CHECKSUM VALUE
CKSFLG::.WORD	0			;MEMORY CHECKSUM FLAG (0 MEANS TO
					;  RE-STORE CHECKSUM VALUE)
IMPCLR::

;THE FOLLOWING PSECT'S ARE IMPURE AND CONTAIN ONCE-ONLY INSTRUCTIONS AND DATA
;  (WHEN THE NODE IS RUNNING, PACKET SPACE STARTS HERE)

	.PSECT	ONCE  ,RW,I,LCL,REL,CON
.IF EQ	ROMFLG
PKTBGN::
.ENDC

	.PSECT	VECTBL,RW,D,LCL,REL,CON
VECTBL::!

;SWITCH TO THE BLANK PSECT SO ITS EASIER TO CATCH ERRORS!!!

	.PSECT

;DEFINE DUMMY MACRO WHICH IS INVOKED BY SEVERAL OTHER MACROS

	.MACRO	RESTOR
	.ENDM
	.PAGE
	.SBTTL	DEFINE MACROS FOR THE CONFIGURATION DEFINITION FILE

;DEFINE MACRO TO SPECIFY NAME OF THIS NODE

	.MACRO	NAME  XXX
	.NCHR	.N,<XXX>
.IF EQ	ROMFLG
	PURE
THSNOD::.ASCIZ	"XXX"
.IFF
	.PSECT	PDATA,RW,D,LCL,REL,CON
	.MACRO	RESTOR
	.PSECT	PDATA,RW,D,LCL,REL,CON
	.ENDM
THSNOD::
	.IRPC	$$$$$C,<XXX>
	BX	''$$$$$C
	.ENDM
	BX	00
.ENDC
.IF GT 5-.N
	.REPT	5-.N
	BX	00
	.ENDR
.ENDC
	.EVEN
	.ENDM	NAME

;DEFINE MESSAGE OF THE DAY MACRO

	.MACRO	MOD	STRING
	.PSECT	PURE,RW,D,LCL,REL,CON
..MOD::	.ASCIZ	STRING
	.EVEN
	.ENDM


;DEFINE MESSAGE AT CONNECTION TO A TERMINAL MACRO

	.MACRO	TRMMSG	STRING
	.PSECT	PURE,RW,D,LCL,REL,CON
..TRMM:: .ASCIZ	/STRING/
	.EVEN
	.ENDM
	.PAGE
;DEFINE MACROS FOR LINKS TO OTHER NODES OR HOSTS

.IF NE LK.NUM
	.MACRO	LINK  NAME,PRIV,AUX,SOC,PS,TYPE,XXX
	.IRP	DEV,<\.LK>
LK.S'DEV=!SOC
$$$PL=!PRIV
$$$S=!0
.IF IDN <PS><P>
  $$$S=!$$$S!$D0PRI
.ENDC
.IF IDN <AUX><F>
  $$$S=!$$$S!$D0FAX
.ENDC
.IF IDN <AUX><T>
  $$$S=!$$$S!$D0TAX
.ENDC
.IF IDN <AUX><TF>
  $$$S=!$$$S!$D0FAX!$D0TAX
.ENDC
$$$T=!''TYPE
	.WR50	1,NAME,$$$1	;FIRST HALF OF NODE NAME
	.WR50	4,NAME,$$$2	;SECOND HALF OF NODE NAME
$$$=!0
$$$N0=!0
$$$N1=!0
$$$N2=!0
$$$N3=!0
$$$N4=!0
$$$N5=!0
	.IRPC	QQ,<NAME>
	.IRP	XX,<\$$$>
$$$N'XX=''QQ
	.ENDM
$$$=!$$$+1
	.ENDM
.IF EQ DEV
	.PSECT	SX,RW,D,LCL,REL,CON
  MNLKSX::!
.ENDC
	LINK'TYPE  DEV,SOC,XXX
	.ENDM
.LK=!.LK+1
	.ENDM
.LK=0
HSNUM=!0
	.PAGE
	.SBTTL	LINKB - DUP11/DUV11 USING DDCMP PROTOCOL

;DEFINE MACRO FOR TYPE B LINK (8 BIT SERIAL LINK USING DDCMP PROTOCOL.DUV-11)

.IF DF LKBNUM
	.MACRO	LINKB  DEV,SOC,DRG,VEC,LEV,LIN
$$$R=DRG			;ADDRESS OF FIRST DEVICE REGISTER
$$$P=!LEV			;Processor level at interrupt level
$$$S=!$$$S!$D0FLG!$D0SII!$D0LNK!$D0CLN!$D0LVL!$D0WLD
				;THIS LINK USES FLAG PROTOCOL WITH SOCKET IS
				;  IDLE MESSAGES AND REQUIRES CLEANUP BY
				;  SNDPKT
.IF B <LIN>
  $$$L=!-1			;If no line no. defined we are line -1
.IFF
  $$$L=!LIN			;The line number on the interface when
  $$$VC=!VEC				;The device vector to set up
.ENDC				; using multiline synchronous devices
LOADDV=!1			;This link uses the load device

	VECTOR	VEC  ,LKI'DEV,LEV;Input vector
.IF B <LIN>			;If not using a DCP we need output vec
	VECTOR	VEC+4,LKO'DEV,LEV;Output vector
.ENDC				;.IF B <LIN>

	.PSECT	CODE,RW,I,LCL,REL,CON

LKI'DEV:PUSH	R4		;Save the users register
	MOV	#L'DEV'$,R4	;Get the DDB address in R4
	JMP	LKBISV#		;Go to the common link type B input service

LKO'DEV:PUSH	R4		;Save the users register
	MOV	#L'DEV'$,R4	;Get the DDB address in R4

	JMP	LKBOSV#		;Go to the common link type B output service


	XDDB	LK,L,DEV,SOC,B,FGPOKE#,FGRSUM#,0,<NXTFLG#,FLGPKT#>

.S=!1
	.REPT	SOC		;GENERATE THE SDB'S
	XSDB	LK,L,DEV,\.S,B
.S=!.S+1
	.ENDR
.LKB=!.LKB+1
	.ENDM
.LKB=!0
.ENDC
	.PAGE
	.SBTTL	LINKC - DR11-C/DRV11 USING RESPONSE PROTOCOL

;DEFINE MACRO FOR TYPE C LINK DRIVERS (16 BIT PARALLEL LINK USING DR-11C OR
;  DRV-11 USING REQUEST PROTOCOL)

.IF DF LKCNUM
	.MACRO	LINKC	DEV,SOC,DRG,VEC,LEV
$$$R=DRG			;ADDRESS OF FIRST DEVICE REGISTER
$$$P=!LEV			;PRIORITY LEVEL
$$$S=!$$$S!$D0SII!$D0LNK!$D0CLN!$D0LVL!$D0WLD;This link uses socket is idle
					     ;  packets and requires cleanup by
					     ;  SNDPKT
LOADDV=!1			;THIS LINK USES THE LOAD DEVICE

	VECTOR	VEC  ,LKI'DEV,LEV;INPUT VECTOR
	VECTOR	VEC+4,LKO'DEV,LEV;OUTPUT VECTOR

	.PSECT	CODE,RW,I,LCL,REL,CON;GENERATE INTERRUPT CODE

LKI'DEV:PUSH	R4		;SAVE REGISTER
	MOV	#L'DEV'$,R4	;GET ADDRESS OF DDB
	JMP	LKCIIN#		;GO TO COMMON ROUTINE

LKO'DEV:PUSH	R4		;SAVE REGISTER
	MOV	#L'DEV'$,R4	;GET ADDRESS OF DDB
	JMP	LKCOIN#		;GO TO COMMON ROUTINE

	XDDB	LK,L,DEV,SOC,C,RSPOKE#,RSRSUM#,0,<NXTRSP#,RSPPKT#>

.S=!1
	.REPT	SOC			;GENERATE THE SDB'S
	XSDB	LK,L,DEV,\.S,C
.S=!.S+1
	.ENDR
.LKC=!.LKC+1
	.ENDM
.LKC=!0
.ENDC
	.PAGE
	.SBTTL	LINKD - HOST INTERFACE TO RT-11 AND RSTS-11 USING DR11-C/DRV11

;DEFINE MACRO FOR TYPE D LINK DRIVERS (RT-11,RSX-11M OR RSTS-11 HOST 
; INTERFACE USING DR11-C OR DRV11 INTERFACE)

.IF DF LKDNUM
	.MACRO	LINKD	DEV,SOC,DRG,VEC,LEV,OPTION1
$$$R=!DRG			;ADDRESS OF FIRST DEVICE REGISTER
$$$P=!LEV			;PRIORITY LEVEL
$$$S=!$$$S!$D0SII!$D0HST!$D0CLN!$D0LVL!$D0WLD;This link uses socket is idle
					     ;  packets and wants SNDPKT to do
					     ;  cleanup on Disconnects and NAKS

	VECTOR	VEC  ,LKI'DEV,LEV;INPUT VECTOR
	VECTOR	VEC+4,LKO'DEV,LEV;OUTPUT VECTOR

	.PSECT	CODE,RW,I,LCL,REL,CON;GENERATE INTERRUPT CODE

LKI'DEV:PUSH	R4		;SAVE REGISTER
	MOV	#L'DEV'$,R4	;GET ADDRESS OF DDB
	JMP	LKDIIN#		;GO TO COMMON ROUTINE

LKO'DEV:PUSH	R4		;SAVE REGISTER
	MOV	#L'DEV'$,R4	;GET ADDRESS OF DDB
	JMP	LKDOIN#		;GO TO COMMON ROUTINE

	XDDB	LK,L,DEV,SOC,D,RSPOKE#,LDRSUM#,XXSSRC#,<LDOUTX#,MOVPKE#>

.S=!1
	.REPT	SOC			;GENERATE THE SDB'S
	XSDB	LK,L,DEV,\.S,D
.S=!.S+1
	.ENDR
.LKD=!.LKD+1
	.ENDM
.LKD=!0
.ENDC
	.PAGE
	.SBTTL	LINKE - DUP11/DUV11/DPV11 Using X.25 (LAP/LAPB) protocol

;Define MACRO for type E link drivers (serial link using DUP-11/DUV11/DPV11
;  and modified flag protocol)


.IF DF LKENUM
;**	.MACRO	LINKE	DEV,SOC,DRG,VEC,LEV,DEST,ADEST,K,T1,N1,N2
	.MACRO	LINKE	DEV,SOC,DRG,VEC,LEV,FUNC,K,T1,N1,N2
$$$R=!DRG			;Address of first device register
$$$VC=!VEC		;--KSB2, ATC WANTS VECTOR, (search DDLEVC)
$$$P=!LEV			;PRIORITY LEVEL
;** $$$S=!$$$S!$D0GTW!$D0FLG!$D0WLD!$D0CLN
;$$$S=!$$$S!$D0FLG!$D0WLD!$D0CLN
$$$S=!$$$S!$D0WLD!$D0CLN
.IF	IDN	<FUNC><H>	;HOST INTERFACE
	$$$S=!$$$S!$D0HST
.IFF
	.IF	IDN	<FUNC><G>	;GATEWAY TO A PDN
		$$$S=!$$$S!$D0GTW
	.IFF
		.ERROR	0;LINK E FUNC PARAMETER NOT 'H' OR 'G'
	.ENDC
.ENDC

.IF EQ $$$S&$D0PRI
  $$$A=!1			; DTE outgoing command frame address
  $$$B=!3			; DTE incoming response frame address
.IFF
  $$$A=!3			; DCE outgoing command frame address
  $$$B=!1			; DCE incoming response frame address
.ENDC
$$$C=!K;			; Frame level window size (K)
$$$D=!T1			; No-response timer duration (T1)
$$$E=!N2			; Retransmission max (N2)
$$$F=!N1			; Max # bytes in frame info fld (N1/8)

;	.WR50	1,DEST,$$$3	; 1st half of X.25 dest DTE name
;	.WR50	4,DEST,$$$4	; 2nd half of X.25 dest DTE name
;	.WR50	1,ADEST,$$$5
;	.WR50	4,ADEST,$$$6

	VECTOR	VEC  ,LKI'DEV,LEV;Input vector
	VECTOR	VEC+4,LKO'DEV,LEV;Output vector

	.PSECT	CODE,RW,I,LCL,REL,CON;Generate interrupt code

LKI'DEV:PUSH	R4		;Save register
	MOV	#L'DEV'$,R4	;Get address of DDB
	JMP	LKEISV#		;Go to common routine

LKO'DEV:PUSH	R4		;Save register
	MOV	#L'DEV'$,R4	;Get address of DDB
	JMP	LKEOSV#		;Go to common routine

	XDDB	LK,L,DEV,SOC,E,LEPOKE#,LERSUM#,XXSSRC#,<LKEFLG#,0>

.S=!1
	.REPT	SOC			;GENERATE THE SDB'S
	XSDB	LK,L,DEV,\.S,E
.S=!.S+1
	.ENDR
.LKE=!.LKE+1
	.ENDM
.LKE=!0
.ENDC
	.PAGE
	.SBTTL	LINKF - HOST INTERFACE TO TYMSHARE 2020 USING DR11-C

;DEFINE MACRO FOR TYPE F LINK DRIVERS (TYMSHARE 2020 HOST INTERFACE USING
;  DR11-C OR DRV11 INTERFACE)

.IF DF LKFNUM
	.MACRO	LINKF	DEV,SOC,DRG,VEC,LEV,RNGSIZ,XKMC
$$$R=!DRG			;ADDRESS OF FIRST DEVICE REGISTER
$$$P=!LEV			;PRIORITY LEVEL
$$$S=!$$$S!$D0HST!$D0WLD
$$$W=!RNGSIZ			;SIZE OF HOST'S INPUT RING BUFFER

.IF NB <XKMC>
  .IF DIF <XKMC><KMC>
	.ERROR	0;LINKF KMC PARAMETER NOT BLANK OR KMC!
  .IFF
    $$$S=!$$$S!$D0DV0
  .ENDC
.ENDC

	VECTOR	VEC  ,LKI'DEV,LEV;INPUT VECTOR
	VECTOR	VEC+4,LKO'DEV,LEV;OUTPUT VECTOR

	.PSECT	CODE,RW,I,LCL,REL,CON;GENERATE INTERRUPT CODE

LKI'DEV:PUSH	R4		;SAVE REGISTER
	MOV	#L'DEV'$,R4	;GET ADDRESS OF DDB
.IF DIF <XKMC><KMC>
	JMP	LKFIN1#		;GO TO COMMON ROUTINE
.IFF
	JMP	LKFIN2#
.ENDC

LKO'DEV:PUSH	R4		;SAVE REGISTER
	MOV	#L'DEV'$,R4	;GET ADDRESS OF DDB
.IF DIF <XKMC><KMC>
	JMP	LKFOU1#		;GO TO COMMON ROUTINE
.IFF
	JMP	LKFOU2#
.ENDC

	XDDB	LK,L,DEV,SOC,F,RSPOKE#,LFRSUM#,XXSSRC#,<LFOUTX#,0>

.S=!1
	.REPT	SOC			;GENERATE THE SDB'S
	XSDB	LK,L,DEV,\.S,F
.S=!.S+1
	.ENDR
.LKF=!.LKF+1
	.ENDM
.LKF=!0
.ENDC
	.PAGE
	.SBTTL	LINKH - GATEWAY TO TYMNET T.201 PROTOCOL

;DEFINE MACRO FOR TYPE H LINK DRIVERS (GATEWAY TO TYMNET T.201 PROTOCOL)

.IF DF LKHNUM
	.MACRO	LINKH	DEV,SOC,NODNUM,NSPH,XTPCX
$L0DIR=!100000;			;DEFINE STATUS BITS
$L0SAT=!000200
$$$S=!$$$S!$D0GTW!$D0WLD
$$$NN=!NODNUM;			;NODE NUMBER
$$$ND=!100			;NODE DESCRIPTOR
.IF LT $$$NN-1000		;IF WE ARE A BASE
  $$$ND=!140			;WE LOOK LIKE AN ISIS NODE!
.ENDC
$$$NL=!L.NL'DEV			;NUMBER OF LINES
L.NL'DEV=!0

;DEFINE MACRO USED TO DEFINE A TYMNET "LINE"

	.MACRO	LNKL  CHN,NBR,SPEED,SAT,TYPE,XXX
L.NL'DEV=!L.NL'DEV+1		;COUNT THIS LINE
	.IRP	LINE,<\.L>
$$$Q=!SPEED;			;LINE SPEED
$$$C=!<CHN+17>&^C17;		;NUMBER OF CHANNELS ON THE LINE (MUST BE
				;  MULTIPLE OF 16.)
$$$N=!NBR;			;NUMBER OF NEIGHBOR NODE
$$$S=!0;			;VALUE FOR PURE STATUS WORD
$$$X=!4;			;NORMAL LINE HAS 4 OUTSTANDING FRAMES
.IF IDN <S><SAT>;		;IF THIS IS A SATELLITE LINK
  $$$S=!$L0SAT;			;  SET CORRESPONDING PURE STATUS BIT
  $$$X=!10;			;  SATELLITE LINE HAS 8 OUTSTANDING FRAMES
.ENDC
.IF LT NODNUM-NBR;		;ALSO SET THE DIRECTION BIT CORRECTLY
  $$$S=!$$$S!$L0DIR
.ENDC
	.IRP	LX,<\<.L+1>>
.IF DF	L'DEV'.'LX
  L'DEV'H'LINE=!L'DEV'.'LX
.IFF
  L'DEV'H'LINE=!0
.ENDC
	.ENDM
	.ENDM
.LKH'TYPE=!.L
	LNKL'TYPE  DEV,\.L,CHN,XXX
.L=!.L+1;			;BUMP LINE NUMBER ON GATEWAY
	.ENDM

;END OF DEFINITION OF LNKL MACRO

.L=!0;				;INITIALIZE LINE NUMBER ON GATEWAY

;DEFINE MACRO USED TO DEFINE A TYMNET "HOST" ON THIS BASE

	.MACRO	LNKH	TYMHST,NXLHST,HOSPRT ;MACRO FOR "HOST" ON THE GATEWAY
L.NH'DEV=!L.NH'DEV+1;		;COUNT THE HOST
.IF EQ .H			;IF THIS IS FIRST HOST ON GATEWAY
	.PSECT	IMPURE,RW,D,LCL,REL,CON;GENERATE HOST BUFFER TABLE
  HBFT'DEV:.BLKW  200
.ENDC
	.PSECT	PURE,RW,D,LCL,REL,CON
.IF NDF L.HM'DEV
  L.HM'DEV:
.ENDC
	.WORD	$$$SH*100+100002
	.WORD	.H*10000+^D'TYMHST
	.IRP	HOST,<\.H>
LD'DEV'.'HOST=!100000!^D'TYMHST'.;FIRST WORD OF HOST DESCRIPTOR
LD'DEV'.'HOST'P=!$$$PH
.IF NB	<HOSPRT>
 .IF GT	$$$PH-HOSPRT
   LD'DEV'.P'HOST=!HOSPRT
 .ENDC
.ENDC 
	.WR50	1,NXLHST,L.'HOST'A'DEV;DEFINE SYMBOLS FOR NEXILIS HOST NAME
	.WR50	4,NXLHST,L.'HOST'B'DEV
	.ENDM
.H=!.H+1;			;BUMP HOST NUMBER ON GATEWAY
	.ENDM

;END OF DEFINITION OF LNKH MACRO

$$$NH=!0			;ASSUME NO HOSTS

.IF DF LHBASE			;ONLY NEED THIS IF HAVE BASE SUPPORT ON THIS
				;  NODE

$$$NH=!L.NH'DEV
L.NH'DEV=!0
.H=!0
.IF GE $$$NH-3
  $$$SH=!100
  $$$SO=!4
.IFF
  $$$SO=!10
  .IF GE $$$NH-2
    $$$SH=!200
  .IFF
    $$$SH=!400
  .ENDC
.ENDC

$$$PH=!NSPH			;NUMBER OF AVAILABLE PORTS PER HOST
.IF GT $$$PH-$$$SH		;MUST BE LESS THAN TOTAL NUMBER
  $$$PH=!$$$SH
.ENDC
.IF GT $$$PH-SOC+$$$NH
  $$$PH=!SOC-$$$NH
.ENDC

.IF EQ $$$NH			;IF NO HOSTS ON THIS GATEWAY
  $$$0A=!0
  $$$0B=!0
  $$$1A=!0
  $$$1B=!0
  $$$2A=!0
  $$$2B=!0
  $$$3A=!0
  $$$3B=!0
  $$$S0=!-1
  $$$S1=!-1
  $$$S2=!-1
  $$$S3=!-1
.ENDC
.IF EQ $$$NH-1			;IF 1 HOST
  $$$0A=!L.0A'DEV
  $$$0B=!L.0B'DEV
  $$$1A=!L.0A'DEV
  $$$1B=!L.0B'DEV
  $$$2A=!L.0A'DEV
  $$$2B=!L.0B'DEV
  $$$3A=!L.0A'DEV
  $$$3B=!L.0B'DEV
  $$$S0=!$$$SH-2
  $$$S1=!-1
  $$$S2=!-1
  $$$S3=!-1
.ENDC
.IF EQ $$$NH-2			;IF 2 HOSTS
  $$$0A=!L.0A'DEV
  $$$0B=!L.0B'DEV
  $$$1A=!L.0A'DEV
  $$$1B=!L.0B'DEV
  $$$2A=!L.1A'DEV
  $$$2B=!L.1B'DEV
  $$$3A=!L.1A'DEV
  $$$3B=!L.1B'DEV
  $$$S0=!$$$SH-2
  $$$S1=!-1
  $$$S2=!$$$S0+200
  $$$S3=!-1
.ENDC
.IF GE $$$NH-3			;3 OR 4 HOSTS
  $$$0A=!L.0A'DEV
  $$$0B=!L.0B'DEV
  $$$1A=!L.1A'DEV
  $$$1B=!L.1B'DEV
  $$$2A=!L.2A'DEV
  $$$2B=!L.2B'DEV
  $$$S0=!$$$SH-2
  $$$S1=!$$$S0+100
  $$$S2=!$$$S0+200
  .IF DF L.3A'DEV
    $$$3A=!L.3A'DEV
    $$$3B=!L.3B'DEV
    $$$S3=!$$$S0+300
  .IFF
    $$$3A=!0
    $$$3B=!0
    $$$S3=!-1
  .ENDC
.ENDC
.ENDC		;.IF DF LHBASE

	XDDB	LK,L,DEV,SOC,H,LHPOKE#,LHRSUM#,XXSSRC#,<0,0>

.S=!1
	.REPT	SOC		;GENERATE THE SDB'S
	XSDB	LK,L,DEV,\.S,H
.S=!.S+1
	.ENDR
.LKH=!.LKH+1
	.ENDM
.LKH=!0

.ENDC		;.IF DF LKHNUM
	.PAGE
;DEFINE MACRO FOR TYPE A LINE ON TYPE H LINK

.IF DF LKHNUM
.IF NE LHALNS
	.MACRO	LNKLA  DEV,LINE,CHN,DRG,VEC,LEV
$$$R=DRG;			;ADDRESS OF FIRST DEVICE REGISTER
$$$P=!LEV;			;PRIORITY LEVEL

	VECTOR	VEC  ,LI'DEV'.'LINE,LEV;INPUT VECTOR
	VECTOR	VEC+4,LO'DEV'.'LINE,LEV;OUTPUT VECTOR

	.PSECT	CODE,RW,I,LCL,REL,CON;;GENERATE INTERRUPT CODE

LI'DEV'.'LINE:PUSH  R3;		;SAVE REGISTER
	MOV	#L'DEV'.'LINE,R3;GET ADDRESS OF LDB
	JMP	LHAISV#;	;GO TO COMMON ROUTINE

LO'DEV'.'LINE:PUSH  R3;		;SAVE REGISTER
	MOV	#L'DEV'.'LINE,R3;GET ADDRESS OF LDB
	JMP	LHAOSV#;	;GO TO COMMON ROUTINE

	.PSECT	IMPURE,RW,D,LCL,REL,CON;GENERATE THE SDB TABLES FOR EACH LINE

LS'DEV'.'LINE:.BLKW  CHN;	;ONE ENTRY FOR EACH CHANNEL ON THE LINE

	XHLDB	DEV,LINE,A

	.ENDM
.ENDC		;.IF NE LHALNS

;DEFINE MACRO FOR TYPE B LINE ON TYPE H LINK

.IF NE LHBLNS
	.MACRO	LNKLB  DEV,LINE,CHN,DRG,VEC,LEV,PORT
$$$R=DRG;			;ADDRESS OF FIRST DEVICE REGISTER
$$$P=!LEV;			;PRIORITY LEVEL
$$$PN=!PORT			; Port number on DCP
$$$VC=!VEC			; Interrupt vector for DCP port

	VECTOR	VEC  ,LI'DEV'.'LINE,LEV	;Interrupt vector

	.PSECT	CODE,RW,I,LCL,REL,CONERATE INTERRUPT CODE

LI'DEV'.'LINE:PUSH  R3;		;SAVE REGISTER
	MOV	#L'DEV'.'LINE,R3;GET ADDRESS OF LDB
	JMP	LHBINT#;	;GO TO COMMON ROUTINE

	.PSECT	IMPURE,RW,D,LCL,REL,CON;GENERATE THE SDB TABLES FOR EACH LINE

LS'DEV'.'LINE:.BLKW  CHN;	;ONE ENTRY FOR EACH CHANNEL ON THE LINE

	XHLDB	DEV,LINE,B

	.ENDM
.ENDC		;.IF NE LHBLNS
.ENDC		;.IF DF LKHNUM
	.PAGE
	.SBTTL	LINKI - GATEWAY TO TYMNET II PROTOCOL (T201 AND SDLC)

;DEFINE MACRO FOR TYPE I LINK DRIVERS (GATEWAY TO TYMNET II PROTOCOL)

.IF DF LKINUM
	.MACRO	LINKI	DEV,SOC,NODNUM,NSPH,XTPCX
$$$S=!$$$S!$D0GTW!$D0WLD
$$$NN=!NODNUM;			;NODE NUMBER
$$$NL=!L.NL'DEV			;NUMBER OF LINES

;DEFINE MACRO USED TO DEFINE A TYMNET "LINE"

	.MACRO	LNKL  CHN,NBR,SPEED,SAT,TYPE,XXX
	.IRP	LINE,<\.L>
$$$Q=!SPEED;			;LINE SPEED
$$$C=!<CHN+17>&^C17;		;NUMBER OF CHANNELS ON THE LINE (MUST BE
				;  MULTIPLE OF 16.)
$$$N=!NBR;			;NUMBER OF NEIGHBOR NODE
$$$S=!0;			;VALUE FOR PURE STATUS WORD
$$$X=!4;			;NORMAL LINE HAS 4 OUTSTANDING FRAMES
.IF IDN <S><SAT>;		;IF THIS IS A SATELLITE LINK
  $$$X=!10;			;  SATELLITE LINE HAS 8 OUTSTANDING FRAMES
.ENDC
	.IRP	LX,<\<.L+1>>
.IF DF	L'DEV'.'LX
  L'DEV'I'LINE=!L'DEV'.'LX
.IFF
  L'DEV'I'LINE=!0
.ENDC
	.ENDM
	.ENDM
.LKI'TYPE=!.L
	LNKL'TYPE  DEV,\.L,$$$C,XXX
.L=!.L+1;			;BUMP LINE NUMBER ON GATEWAY
	.ENDM

;END OF DEFINITION OF LNKL MACRO

.L=!0;				;INITIALIZE LINE NUMBER ON GATEWAY

;DEFINE MACRO USED TO DEFINE A TYMNET "HOST" ON THIS BASE

	.MACRO	LNKH	TYMHST,NXLHST,DEVTYP ;MACRO FOR "HOST" ON THE GATEWAY
	.ENDM

;END OF DEFINITION OF LNKH MACRO

$$$NH=!0			;ASSUME NO HOSTS

.IF DF LIBASE			;ONLY NEED THIS IF HAVE BASE SUPPORT ON THIS
				;  NODE

$$$NH=!L.NH'DEV
;L.NH'DEV=!0
.H=!0

.ENDC		;.IF DF LIBASE

	XDDB	LK,L,DEV,SOC,I,LIPOKE#,LIRSUM#,XXSSRC#,<0,0>

.S=!1
	.REPT	SOC		;GENERATE THE SDB'S
	XSDB	LK,L,DEV,\.S,I
.S=!.S+1
	.ENDR
.LKH=!.LKH+1
	.ENDM
.LKH=!0

.ENDC		;.IF DF LKINUM
	.PAGE
;DEFINE MACRO FOR TYPE A LINE ON TYPE I LINK

.IF DF LKINUM
.IF NE LIALNS
	.MACRO	LNKLA  DEV,LINE,CHN,DRG,VEC,LEV
$$$R=DRG;			;ADDRESS OF FIRST DEVICE REGISTER
$$$P=!LEV;			;PRIORITY LEVEL
$$$VC=!VEC			; Interrupt vector for device

	VECTOR	VEC  ,LI'DEV'.'LINE,LEV;INPUT VECTOR
	VECTOR	VEC+4,LO'DEV'.'LINE,LEV;OUTPUT VECTOR

	.PSECT	CODE,RW,I,LCL,REL,CON;;GENERATE INTERRUPT CODE

LI'DEV'.'LINE:PUSH  R3;		;SAVE REGISTER
	MOV	#L'DEV'.'LINE,R3;GET ADDRESS OF LDB
	JMP	LIAISV#;	;GO TO COMMON ROUTINE

LO'DEV'.'LINE:PUSH  R3;		;SAVE REGISTER
	MOV	#L'DEV'.'LINE,R3;GET ADDRESS OF LDB
	JMP	LIAOSV#;	;GO TO COMMON ROUTINE

	.PSECT	IMPURE,RW,D,LCL,REL,CON;GENERATE THE SDB TABLES FOR EACH LINE

LS'DEV'.'LINE:.BLKW  CHN;	;ONE ENTRY FOR EACH CHANNEL ON THE LINE

	XILDB	DEV,LINE,A

	.ENDM
.ENDC		;.IF NE LIALNS

;DEFINE MACRO FOR TYPE B LINE ON TYPE I LINK

.IF NE LIBLNS
	.MACRO	LNKLB  DEV,LINE,CHN,DRG,VEC,LEV,PORT
$$$R=DRG;			;ADDRESS OF FIRST DEVICE REGISTER
$$$P=!LEV;			;PRIORITY LEVEL
$$$PN=!PORT			; Port number on DCP
$$$VC=!VEC			; Interrupt vector for DCP port

	VECTOR	VEC  ,LI'DEV'.'LINE,LEV	;Interrupt vector

	.PSECT	CODE,RW,I,LCL,REL,CON;;GENERATE INTERRUPT CODE

LI'DEV'.'LINE:PUSH  R3;		;SAVE REGISTER
	MOV	#L'DEV'.'LINE,R3;GET ADDRESS OF LDB
	JMP	LIBINT#;	;GO TO COMMON ROUTINE

	.PSECT	IMPURE,RW,D,LCL,REL,CON;GENERATE THE SDB TABLES FOR EACH LINE

LS'DEV'.'LINE:.BLKW  CHN;	;ONE ENTRY FOR EACH CHANNEL ON THE LINE

	XILDB	DEV,LINE,B

	.ENDM
.ENDC		;.IF NE LIBLNS
.ENDC		;.IF DF LKINUM
.ENDC		;.IF NE LK.NUM
	.PAGE
	.SBTTL	MACROS FOR PARAMETERS FOR DEVICES

	.MACRO	DEV  DV,PRIV,XXX
$$$N=DV'.S0			;NUMBER OF SOCKETS ON DEVICE
DV'.S0==!0
$$$S=!0				;Initialize symbol for pure status word
$$$PL=!PRIV			;Privildge level
	DV'XX	XXX		;Define the "SOC" macro for this device and
				;  create the DDB
	.ENDM
	.PAGE
;DEFINE MACROS FOR DEFINING PARAMETERS FOR THE STATUS DEVICE

.IF DF ST.NUM
	.MACRO	STXX,EPL,DPL
	.MACRO	SOC  SN
.IF NE ST.S0+1-SN
	.ERROR	SN;SOC MACRO OUT OF ORDER FOR DEVICE ST
.ENDC
ST.S0==!ST.S0+1
	XSDB	ST,S,0,\SN
	.ENDM
$$$S=!$$$S!$D0WLD
$$$EPL=!EPL			;Priviledge level for examine and status
				;  changing commands
$$$DPL=!DPL			;Priviledge level for deposit command
	XDDB	ST,S,0,\$$$N,,STPOKE#,STRSUM#,XXSSRC#
	.ENDM
.ENDC

;DEFINE MACROS FOR THE LOAD DEVICE

.IF DF WD.NUM
	.MACRO	WDXX
	.MACRO	SOC  SN
.IF NE WD.S0+1-SN
	.ERROR	SN;SOC MACRO OUT OF ORDER FOR DEVICE WD
.ENDC
WD.S0==!WD.S0+1
	XSDB	WD,W,0,\SN
	.ENDM
	XDDB	WD,W,0,\$$$N,,WDPOKE#,WDRSUM#,XXSSRC#
	.ENDM
.ENDC
	.PAGE
;DEFINE MACROS FOR DEFINING PARAMETERS FOR EACH TYPE OF HARDWARE DEVICE DRIVER

;LINE PRINTER

.IF DF LP.NUM
	.MACRO	LPXX
	.MACRO	SOC  SN,TYPE,XXX
.IF NE LP.S0+1-SN
	.ERROR	SN;SOC MACRO OUT OF ORDER FOR DEVICE LP
.ENDC
LP.S0==!LP.S0+1
	SOCLP'TYPE  \SN,XXX
	.ENDM
	XDDB	LP,P,0,\$$$N,,LPPOKE#,LPRSUM#,XXSSRC#
	.ENDM

;LINE PRINTER TYPE A (USES EITHER LP-11A PARALLEL INTERFACE OR MODIFIED DL-11
;  SERIAL INTERFACE)

.IF DF LPANUM
	.MACRO	SOCLPA  SN,REG,VEC,EREG
$$$R=!REG
.IF B <EREG>
  $$$E=!REG
.IFF
  $$$E=!EREG
.ENDC

	VECTOR	VEC,LP'SN'I,7

	.PSECT	CODE,RW,I,LCL,REL,CON

LP'SN'I:PUSH	SD
	MOV	#P0$'SN,SD
	JMP	LPACMI#

	XSDB	LP,P,0,SN,A

	.ENDM
.ENDC

;LINE PRINTER TYPE B (USES ONE PORT ON DZ-11 OR DZV-11 SERIAL INTERFACE)

.IF DF LPBNUM
	.MACRO	SOCLPB  SN

	.PSECT	CODE,RW,I,LCL,REL,CON

LPB'SN'X:PUSH	SD		;SAVE SD
	MOV	P0$'SN,SD	;POINT TO OUR SDB
	JMP	LPBXTR#		;GO TO COMMON CODE

	.ENDM
.ENDC
.ENDC			;.IF NE LP.NUM
	.PAGE
;DEFINE MACRO FOR GENERATING THE HOST CONNECT LIST DATA

	.MACRO	HCL  X,LIST
	.PSECT	PURE,RW,D,LCL,REL,CON
	.IRP	H,<\.HCL>
HOST.'X=.HCL*2+2
HST$'H:
	.ENDM
	.IRP	NAME,<LIST>
	.ASCIZ	"NAME"
	.ENDM
	.BYTE	0
	.EVEN
.HCL=.HCL+1
	.ENDM
.HCL=!0

;DEFINE MACRO FOR DEFINING DEFAULT HOST

	.MACRO	DHOST  HOST
DFTH$$=!1
	.PSECT	PURE,RW,D,LCL,REL,CON
DFTHST::.ASCIZ	"HOST"
	.EVEN
	.ENDM

;DEFINE MACRO FOR DEFINING KERNAL HOST

	.MACRO	KHOST  HOST,XRAY,DLOAD
KHST$$=!1
.IF EQ	ROMFLG
	.PSECT	PURE,RW,D,LCL,REL,CON
.IFF
	.PSECT	PDATA,RW,D,LCL,REL,CON
	.MACRO	RESTOR
	.PSECT	PDATA,RW,D,LCL,REL,CON
	.ENDM
.ENDC
	.EVEN
KERHST::BX	<^H80+<^D'HOST/400>>
	BX	<<^D'HOST>&377>
	.PSECT	PURE,RW,D,LCL,REL,CON
XRAYNM::.ASCIZ	"XRAY"
	.ASCIZ	"DLOAD"
	.BYTE	0
	.EVEN
	.ENDM

;DEFINE MACRO FOR DEFINING THE TERMINAL HOST

	.MACRO	THOST  HOST
THST$$=!1
.IF EQ	ROMFLG
	.PSECT	PURE,RW,D,LCL,REL,CON
.IFF
	.PSECT	PDATA,RW,D,LCL,REL,CON
	.MACRO	RESTOR
	.PSECT	PDATA,RW,D,LCL,REL,CON
	.ENDM
.ENDC
	.EVEN
THOST::	.BYTE	^H80+<^D'HOST/400>
	.BYTE	<^D'HOST>&377
	.ENDM
	.PAGE
	.SBTTL	MACROS FOR PARAMETERS FOR ASYNC LINE INTERFACES

.IF NE	TR.NUM
	.MACRO	LINX  TYPE,XXX
	.IRP	UNIT,<\.TT>
$$$M=!L.'UNIT'LN
L.'UNIT'LN=!0
$$$X=!L..LN
	LINX'TYPE  UNIT,XXX
	.ENDM
.TT=!.TT+1
	.ENDM
TR.S0=!L..LN
L..LN=!0
.TT=!0

;DEFINE COMMON MACRO THAT IS USED TO DEFINE LINE PARAMETERS FOR TERMINAL LINES

	.MACRO	LINEX  LNN,UNIT,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
$$$LN=!L.'UNIT'LN
$$$ADB=!ADB'UNIT'$
L.'UNIT'LN=!L.'UNIT'LN+1
L..LN=!L..LN+1
.IF NE LNN-L..LN
	.ERROR	LNN;LINE MACRO FOR LINE LNN OUT OF ORDER
.ENDC
.IF IDN <AF><A>
;USE LINE BLELOW FOR NEXT RELEASE
;  $$$B=!<ABX.'OBR+1>*2+RATAT0
  $$$B=!<ABX.'OBR+1>+RATAT0
  ABR$'OBR=!1
  ABR$=!1
 .IF NB IBR
  $$$B=!$$$B!<R.'IBR*400>
 .ENDC
.IFF
  .IF NB IBR
    $$$B=!R.'IBR*400!R.'OBR
  .IFF
    $$$B=!R.'OBR*400!R.'OBR
  .ENDC
.ENDC
;DELETE NEXT LINE FOR NEXT RELEASE
$$$B=!$$$B+<<.XX'COD*20>&340>;	;INSERT CODE INTO BAUD RATE WORD
$$$B=!$$$B+<<.XX'COD*10000>&170000>;	;INSERT CODE INTO BAUD RATE WORD

X$$'COD=!1			;CAUSE ENTRY FOR XLATE TABLES TO BE MADE

.IF DF C.'CMD
  $$$C=!C.'CMD
.IFF
  .ERROR ;ILLEGAL COMMAND DECODER TYPE CMD FOR TERMINAL LINE LNN
.ENDC
C$'CMD=!1
$$$S=!0
.IF IDN <XX><HW>
  $$$S=!$$$S!$T0HWR		;IF HARDWIRED TERMINAL
.ENDC
.IF IDN <XX><TY>
  $$$S=!$$$S!$T0HWR!$T0DDD	;IF HARDWIRED TYMSHARE TERMINAL
.ENDC
.IF IDN <AS><Y>
  $$$S=!$$$S!$T0ASK		;IF SHOULD ASK ABOUT TYPE AND PROFILE
.ENDC

.IF DIF <CM><N>
  $$$S=!$$$S!$T0CMD		;IF SHOULD ALLOW CMD MODE
  .IF DIF <CM><R>
    .IF IDN <CM><Y>
      $$$S=!$$$S!$T0CMX		;If CMD mode should be default
    .IFF
      .ERROR	0;Illegal value for command mode line parameter
    .ENDC
  .ENDC
.ENDC
.IF IDN <ACD><Y>		;If want auto-connect on disconnect
  $$$S=!$$$S!$T0ACD
.ENDC
.IF IDN <ROB><Y>		;IF WANT TO RELEASE ON BREAK
  $$$S=!$$$S!$T0ROB
.ENDC
.IF NB HCL
  $$$S=!$$$S!<HOST.'HCL*400>	;HOST CONNECT LIST INDEX
.ENDC
.IF IDN <SNM><Y>
  $$$S=!$$$S!$T0SFM!$T0SIM	;If should suppress all network messages
.ENDC
.IF IDN <SNM><I>
  $$$S=!$$$S!$T0SIM		;If should suppress informative network messages
.ENDC
$$$CL=!CL			;DEFINE SYMBOL FOR PRIV. CLASS
$$$T=T.'TT			;DEFINE SYMBOL FOR DEFAULT TERMINAL TYPE
$$$P=!P.'TP			;DEFINE SYMBOL FOR DEFAULT TERMINAL PROFILE

	.ENDM
	.PAGE
	.SBTTL	LINXA - SINGLE LINE DRIVER FOR DL11/DLV11

.IF DF TRANUM
;DL11/DLV11 DRIVER (SINGLE LINE)

	.MACRO	LINXA  UNIT,REG,VEC
$$$R=REG			;REGISTER BASE ADDRESS

	VECTOR	VEC  ,A'UNIT'II,5
	VECTOR	VEC+4,A'UNIT'OI,5

	.PSECT	CODE,RW,I,LCL,REL,CON

A'UNIT'II:PUSH	R4		;SAVE REGISTER
	MOV	#ADB'UNIT'$,R4	;GET ADDRESS OF ADB
	JMP	ASAINI#		;GO TO COMMON ROUTINE

A'UNIT'OI:PUSH	R4		;SAVE REGISTER
	MOV	#ADB'UNIT'$,R4	;GET ADDRESS OF ADB
	JMP	ASAOUI#		;GO TO COMMON ROUTINE

	.MACRO	LINE  LN,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	LINEX	LN,UNIT,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	XSDB	TR,T,0,\LN,A
	.ENDM

$$$AS=!0

	XADB	UNIT,A

	.ENDM
.ENDC
	.PAGE
	.SBTTL	LINXB - MULTIPLE LINE DRIVER FOR DZ11/DZV11

.IF DF TRBNUM
;DZ11/DZV11 DRIVER (UP TO 8 LINES/DEVICE)

	.MACRO	LINXB  UNIT,REG,VEC
$$$R=!REG			;REGISTER BASE ADDRESS

	VECTOR	VEC  ,A'UNIT'II,5
	VECTOR	VEC+4,A'UNIT'OI,5

	.PSECT	CODE,RW,I,LCL,REL,CON

A'UNIT'II:PUSH	R4		;SAVE REGISTER
	MOV	#ADB'UNIT'$,R4	;GET ADDRESS OF ADB
	JMP	ASBINI#		;GO TO COMMON ROUTINE

A'UNIT'OI:PUSH	R4		;SAVE REGISTER
	MOV	#ADB'UNIT'$,R4	;GET ADDRESS OF ADB
	JMP	ASBOUI#		;GO TO COMMON ROUTINE

	.MACRO	LINE  LN,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
.IF IDN <AF>,<L>			;IF SPECIAL LINE PRINTER PORT
	SETXTR	LN
	.IRP	$$$,<\CMD>
	.WORD	LPB'$$$'X
	.ENDM
  LPB'$$$'R=!$$$R
.IFF
  .IF IDN <AF>,<C>			;IF SPECIAL HIGH SPEED CLOCK PORT
	SETXTR	LN
	.WORD	FSCINT#
    FSCLNX==!L.'UNIT'LN
	.SHFT	$$$,1,FSCLNX
    FSCBIT==!$$$
    FSCREG==!$$$R
    FSCFLG==!ADB'UNIT'$+ADBFLG+FSCLNX
  .IFF
	LINEX	LN,UNIT,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	XSDB	TR,T,0,\LN,B
  .ENDC
.ENDC
	.ENDM

$$$AS=!$A1CHG

	XADB	UNIT,B

	.ENDM
.ENDC

	.MACRO	SETXTR  LN
	.EVEN
.IF NDF DSPXTR
  MINXTR==!<LN-1>*400
  MINXT2==!<LN-1>*2
  DSPXTR::
  DSXXTR==!.-MINXT2
.ENDC
	.ENDM
	.PAGE
	.SBTTL	LINXC - MULTIPLE LINE DRIVER FOR DH11

.IF DF TRCNUM
;DH11 DRIVER (UP TO 16 LINES/DEVICE)

	.MACRO	LINXC  UNIT,REG,VEC,REGDS,VECDS
$$$R=!REG			;REGISTER BASE ADDRESS
.IF NB REGDS
  $$$E=!REGDS			;DATA-SET REGISTER BASE ADDRESS
.IFF
  $$$E=!0
.ENDC

	VECTOR	VEC  ,A'UNIT'II,5
	VECTOR	VEC+4,A'UNIT'OI,5
.IF NB REGDS
	VECTOR	VECDS,A'UNIT'DS,7
.ENDC

	.PSECT	CODE,RW,I,LCL,REL,CON

A'UNIT'II:PUSH	R4		;SAVE REGISTER
	MOV	#ADB'UNIT'$,R4	;GET ADDRESS OF ADB
	JMP	ASCINI#		;GO TO COMMON ROUTINE

A'UNIT'OI:PUSH	R4		;SAVE REGISTER
	MOV	#ADB'UNIT'$,R4	;GET ADDRESS OF ADB
	JMP	ASCOUI#		;GO TO COMMON ROUTINE

.IF NB REGDS
  A'UNIT'DS:PUSH  R4		;SAVE REGISTER
	MOV	#ADB'UNIT'$,R4	;GET ADDRESS OF ADB
	JMP	ASCDSI#		;GO TO COMMON ROUTINE
.ENDC

	.MACRO	LINE  LN,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	LINEX	LN,UNIT,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	XSDB	TR,T,0,\LN,C
	.ENDM

$$$AS=!$A1CHG!$A1SPT

	XADB	UNIT,C

	.ENDM
.ENDC
.ENDC			;.IF NE TR.NUM
	.PAGE
	.SBTTL	LINXD - SOFTWARE DE-MUX DRIVER FOR INFOTRON SUPER-MUX

.IF DF TRDNUM
;INFOTRON SUPER MUX DRIVER USING DUP11 OR DU11/DUV11

	.MACRO	LINXD  UNIT,REG,VEC
$$$R=!REG			;REGISTER BASE ADDRESS
A'UNIT'PL=5		;PROCESOR STATUS WORD FOR INTERUPT LEVEL

	VECTOR	VEC,A'UNIT'II,A'UNIT'PL;RECEIVE VECTOR
	VECTOR	VEC+4,A'UNIT'OI,A'UNIT'PL;TRANSMIT VECTOR

	.PSECT	CODE,RW,I,LCL,REL,CON

A'UNIT'II: PUSH	R4		;SAVE R4
	MOV	#ADB'UNIT'$,R4	;GET THE ADB POINTER
	JMP	ASDINI#		;DO COMMON CODE

A'UNIT'OI: PUSH	R4		;SAVE R4
	MOV	#ADB'UNIT'$,R4	;GET THE ADB POINTER
	JMP	ASDOUI#		;DO COMMON OUTPUT SERVICE

	.MACRO	LINE  LN,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	LINEX	LN,UNIT,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	$$$S=!$$$S!$T0FWN	;For a multiplexer fill with nulls
	XSDB	TR,T,0,\LN,D
	.ENDM

$$$AS=!0

$$$L=!5
	XADB	UNIT,D

	.ENDM
.ENDC
	.PAGE
	.SBTTL	LINXE - SOFTWARE DE-MUX DRIVER FOR INFOTRON SUPER-MUX
;-----
; The LINXE driver is similar to the LINXD driver except that the SuperMux
; that we talk to does NOT invert the CRC from normal for a bit stuffed
; interface.
;-----

.IF DF TRENUM
;INFOTRON SUPER MUX DRIVER USING DUP11

	.MACRO	LINXE  UNIT,REG,VEC
$$$R=!REG			;REGISTER BASE ADDRESS
A'UNIT'PL=5		;PROCESOR STATUS WORD FOR INTERUPT LEVEL

	VECTOR	VEC,A'UNIT'II,A'UNIT'PL;RECEIVE VECTOR
	VECTOR	VEC+4,A'UNIT'OI,A'UNIT'PL;TRANSMIT VECTOR

	.PSECT	CODE,RW,I,LCL,REL,CON

A'UNIT'II: PUSH	R4		;SAVE R4
	MOV	#ADB'UNIT'$,R4	;GET THE ADB POINTER
	JMP	ASEINI#		;DO COMMON CODE

A'UNIT'OI: PUSH	R4		;SAVE R4
	MOV	#ADB'UNIT'$,R4	;GET THE ADB POINTER
	JMP	ASEOUI#		;DO COMMON OUTPUT SERVICE

	.MACRO	LINE  LN,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	LINEX	LN,UNIT,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	$$$S=!$$$S!$T0FWN	;For a multiplexer fill with nulls
	XSDB	TR,T,0,\LN,E
	.ENDM

$$$AS=!0
$$$L=!5

	XADB	UNIT,E

	.ENDM
.ENDC
	.PAGE
	.SBTTL	LINXF - Nexilis 8086 IO processor

.IF DF TRFNUM
;Nexilis 8086 IO processor for LSI-11

	.MACRO	LINXF  UNIT,REG,VEC
$$$R=!REG			;Register base address
A'UNIT'PL=!5			;Processor status word for interrupt level
$$$VC=VEC			;Address of vector

	VECTOR	VEC,A'UNIT'XI,A'UNIT'PL;Interrupt vector (there's only one!)

	.PSECT	CODE,RW,I,LCL,REL,CON

A'UNIT'XI: PUSH	R4		;Save R4
	MOV	#ADB'UNIT'$,R4	;Get the ADB pointer
	JMP	ASFXXI#		;Go to common code

	.MACRO	LINE  LN,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	LINEX	LN,UNIT,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	XSDB	TR,T,0,\LN,F
	.ENDM

$$$AS=!0
	XADB	UNIT,F

	.ENDM
.ENDC
	.SBTTL	LINXG - SCC based I/O for micro sat

.IF DF TRGNUM

	.MACRO	LINXG  UNIT,REG,VEC
$$$R=!REG			;Register base address
$$$VC=VEC			;Address of vector

	VECTOR	VEC,A'UNIT'OI,6 ;Output interrupt vector
	VECTOR	VEC+4,A'UNIT'II,6 ;Input interrupt vector

	.PSECT	CODE,RW,I,LCL,REL,CON

A'UNIT'II: PUSH	R4		;Save R4
	MOV	#ADB'UNIT'$,R4	;Get the ADB pointer
	JMP	ASGINI#		;Go to common code

A'UNIT'OI: PUSH	R4		;Save R4
	MOV	#ADB'UNIT'$,R4	;Get the ADB pointer
	JMP	ASGOUI#		;Go to common code

	.MACRO	LINE  LN,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	LINEX	LN,UNIT,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	XSDB	TR,T,0,\LN,G
	.ENDM

$$$AS=!0
	XADB	UNIT,G

	.ENDM
.ENDC
	.PAGE
	.SBTTL	DEFINE CONTENTS OF DATA BLOCKS

;DEFINE MACRO'S USED IN DEFINING THE DATA BLOCKS

.IF EQ	ROMFLG
	.MACRO	W  LABEL,CNTS
LABEL==!OS
OS=!OS+2
	.WORD	CNTS
	.ENDM

	.MACRO	WX  CNTS
OS=!OS+2
	.WORD	CNTS
	.ENDM

	.MACRO	B  LABEL,CNTS
LABEL==!OS
OS=!OS+1
	.BYTE	CNTS
	.ENDM

	.MACRO	BX  CNTS
OS=!OS+1
	.BYTE	CNTS
	.ENDM
.IFF
	.MACRO	W  LABEL,CNTS
LABEL==!OS
OS=!OS+2
	.WORD	CNTS
.IF DIF	<CNTS>,<0>
LOC=!	.-2
	.PSECT	INIDAT,RW,D,LCL,REL,CON
	.WORD	CNTS
	.WORD	LOC
	RESTOR
.ENDC
	.ENDM

	.MACRO	WX  CNTS
OS=!OS+2
	.WORD	CNTS
.IF DIF	<CNTS>,<0>
LOC=!	.-2
	.PSECT	INIDAT,RW,D,LCL,REL,CON
	.WORD	CNTS
	.WORD	LOC
	RESTOR
.ENDC
	.ENDM

	.MACRO	B  LABEL,CNTS
LABEL==!OS
OS=!OS+1
	.BYTE	CNTS
.IF DIF	<CNTS>,<0>
LOC=!	.-1
	.PSECT	INIBYT,RW,D,LCL,REL,CON
	.WORD	CNTS
	.WORD	LOC
	RESTOR
.ENDC
	.ENDM

	.MACRO	BX  CNTS
OS=!OS+1
	.BYTE	CNTS
.IF DIF	<CNTS>,<0>
LOC=!	.-1
	.PSECT	INIBYT,RW,D,LCL,REL,CON
	.WORD	CNTS
	.WORD	LOC
	RESTOR
.ENDC
	.ENDM
.ENDC
	.MACRO	M  LABEL,SIZE
LABEL==!OS
OS=!OS+<SIZE>
	.BLKB	SIZE
	.ENDM

	.MACRO	L  LABEL
LABEL==!OS
	.ENDM

	.PAGE
	.SBTTL	DEVICE DATA BLOCKS (DDB'S)

;DEFINE MACRO USED TO GENERATE EACH DDB

	.MACRO	XDDB  DV,DX,DEV,SOC,TYPE,POKE,RSUM,SSRC,QQQ

	.PSECT	DDB,RW,D,LCL,REL,CON
	.MACRO	RESTOR
	.PSECT	DDB,RW,D,LCL,REL,CON
	.ENDM

	.EVEN
OS=!0
DX'DEV'$::
W  DDSTS0,$$$S;			;PURE STATUS WORD
B  DDPRIV,$$$PL;		;Privilege level associated with device
BX        0
W  DDSOC ,SOC;			;HIGHEST VALID SOCKET FOR DEVICE
B  DDID  ,.ID'DV;		;DEVICE I.D.
B  DDINDX,.DX'DEV'DX		;DEVICE INDEX
W  DDPOKE,POKE;			;ADDRESS OF POKE SUBROUTINE FOR DEVICE
W  DDRSUM,RSUM;			;ADDRESS OF RESUME SUBROUTINE FOR DEVICE
W  DDSSRC,SSRC;			;ADDRESS OF SRC SETUP SUBROUTINE FOR RECONNECT
W  DDDDBI,DV'DDBI#		;ADDRESS OF DDB INITIALIZATION ROUTINE
W  DDSDBI,DV'SDBI#		;ADDRESS OF SDB INITIALIZATION ROUTINE
W  DDSX  ,DX'DEV'SX		;ADDRESS OF SX TABLE ENTRY FOR SOCKET
.IF DF DX'DEV'$0		;DO WE HAVE A WILD SOCKET SDB FOR THIS DEVICE
W  DDWLD ,DX'DEV'$0		;ADDRESS OF SDB FOR WILD SOCKET (SOCKET 0)
.IFF
W  DDWLD ,00			;DEFINE ITS VALUE AS 0!
.ENDC
L  DDCBGN			;FIRST WORD TO CLEAR ON STARTUP
W  DDSTS1,0			;IMPURE STATUS WORD
W  DDNCON,0			;NUMBER OF CONNECTIONS ON THE DEVICE
L  DDCEND			;LAST WORD TO CLEAR ON STARTUP + 2
DDCSIZ==!<DDCEND-DDCBGN>/2
	DDB'DV	DEV,SOC,TYPE,QQQ
	.PSECT	INIDAT,RW,D,LCL,REL,CON
$'DEV'DX'$:
	RESTOR

	.ENDM

;DEFINE MACROS FOR GENERATING THE DEVICE DEPENDENT PARTS OF THE DDB'S

.IF DF ST.NUM
	.MACRO	DDBST  DEV,SOC,TYPE,QQQ
B  DDSTEP,$$$EPL;		;Priviledge level for examine and status
				;  changing commands
B  DDSTDP,$$$DPL;		;Priviledge level for deposit command
	.ENDM
.ENDC

.IF NE TR.NUM
	.MACRO	DDBTR  DEV,SOC,TYPE,QQQ
	.ENDM
.ENDC

.IF DF TX.NUM
	.MACRO	DDBTX  DEV,SOC,TYPE,QQQ
	.ENDM
.ENDC

.IF DF TY.NUM
	.MACRO	DDBTY  DEV,SOC,TYPE,QQQ
	.ENDM
.ENDC

.IF DF TZ.NUM
	.MACRO	DDBTZ  DEV,SOC,TYPE,QQQ
	.ENDM
.ENDC

.IF DF LP.NUM
	.MACRO	DDBLP  DEV,SOC,TYPE,QQQ
	.ENDM
.ENDC

.IF DF CR.NUM
	.MACRO	DDBCR  DEV,SOC,TYPE,QQQ
	.ENDM
.ENDC

.IF DF MT.NUM
	.MACRO	DDBMT  DEV,SOC,TYPE,QQQ
	.ENDM
.ENDC

.IF DF FD.NUM
	.MACRO	DDBFD  DEV,SOC,TYPE,QQQ
	.ENDM
.ENDC

.IF DF WD.NUM
	.MACRO	DDBWD  DEV,SOC,TYPE,QQQ
	.ENDM
.ENDC
	.PAGE
	.SBTTL	MACROS FOR LINK DDB'S

.IF NE LK.NUM
	.MACRO	DDBLK  DEV,SOC,TYPE,NXTPKT,MOVPKT
L'DEV'$'TYPE=!L'DEV'$

$$$=!0
	.IRP	DVX,<\DEV+1>
.IF DF L'DVX'$
  $$$=!L'DVX'$
.ENDC
	.ENDM
W  DDLKNX,$$$;			;ADDRESS OF NEXT LINK DDB

$$$=!0
$$$$N=!DEV+1
	.REPT	LK.NUM-DEV	;SCAN ALL REMAINING DEVICES
.IF GT	$$$$N
	.IRP	DVX,<\$$$$N>
.IF DF L'DVX'$'TYPE
  $$$=!L'DVX'$'TYPE
  $$$$N=-11
.ENDC
	.ENDM
$$$$N=!$$$$N+1
.ENDC
	.ENDR
W  DDLKNS,$$$;			;ADDRESS OF NEXT LINK DDB OF SAME TYPE
W  DDLKIN,LK'TYPE'INI#;		;ADDRESS OF SUBROUTINE TO INITIALIZE PROTOCOL
				;  ROUTINE AT DEVICE LEVEL
W  DDLKIS,LK'TYPE'INS#;		;ADDRESS OF SUBROUTINE TO INITIALIZE PROTOCOL
				;  ROUTINE AT SOCKET LEVEL
W  DDLKST,LK'TYPE'STR#;		;ADDRESS OF SUBROUTINE TO START IDLE LINK
W  DDLKLD,LK'TYPE'LOD#;		;ADDRESS OF SUBROUTINE TO CONTROL DOWN-LINE
				;  LOADING OVER THE LINK
W  DDLKFP,NXTPKT		;ADDRESS OF LAST PART OF NXTPKT
W  DDLKP0,MOVPKT		;ADDRESS OF LAST PART OF MOVPKT
W  DDLKN1,$$$1			;FIRST HALF OF NAME OF NODE
W  DDLKN2,$$$2			;SECOND HALF OF NAME OF NODE
B  DDLKNA,$$$N0			;Node name in ASCIZ
BX        $$$N1
BX        $$$N2
BX        $$$N3
BX        $$$N4
BX        $$$N5
BX        0			;This must be 0 to end the string!
B  DDLKTP,$$$T			;Link type (ASCII)
B  DDLKEC,LK'DEV'EC/2		;Number of error counters for this link
BX        0
L  DDLKFC			;FIRST WORD TO CLEAR ON STARTUP
W  DDLK0H,0			;LEVEL 0 SOCKET LIST HEAD POINTER
W  DDLK0T,0			;LEVEL 0 SOCKET LIST TAIL POINTER
DDLKXT==!DDLK0T-DDLK0H
W  DDLK1H,0			;LEVEL 1 SOCKET LIST HEAD POINTER
W  DDLK1T,0			;LEVEL 1 SOCKET LIST TAIL POINTER
W  DDLK2H,0			;LEVEL 2 SOCKET LIST HEAD POINTER
W  DDLK2T,0			;LEVEL 2 SOCKET LIST TAIL POINTER
W  DDLKSP,0			;SUPERVISORY SOCKET LIST POINTER
W  DDLKFH,0			;FLAG SOCKET LIST HEAD POINTER
W  DDLKFT,0			;FLAG SOCKET LIST TAIL POINTER
B  DDLKFN,0			;FLAG COUNTER
B  DDLKPS,0			;STATE BITS
L  DDLKER			;Address of first error counter (for status dev)
W  DDERIS,0			;ERROR COUNT - ILLEGAL SOCKET NUMBER
W  DDERBF,0			;ERROR COUNT - BAD FLAG COUNT
W  DDERIP,0			;ERROR COUNT - ILLEGAL PACKET TYPE
W  DDEROR,0			;ERROR COUNT - OVERRUN
W  DDERNP,0			;ERROR COUNT - NO PACKET AVAILABLE
L  DDERFW			;	     - LINKE FRMR REASON W
W  DDERSZ,0			;ERROR COUNT - SIZE ERROR
W  DDERPC,0			;ERROR COUNT - PROTOCOL ERROR
W  DDERCS,0			;ERROR COUNT - CHECKSUM ERROR
W  DDERBC,0			;ERROR COUNT - BAD CONNECTION COUNT
L  DDERFX			;	     - LINKE FRMR REASON X
W  DDERSI,0			;ERROR COUNT - SPERIOUS INTERRUPT
L  DDERFY			;	     - LINKE FRMR REASON Y
W  DDERHO,0			;ERROR COUNT - HARD OUTPUT ERROR
L  DDERFZ			;	     - LINKE FRMR REASON Z
W  DDERFT,0			;ERROR COUNT - FATAL ERROR
W  DDERRX,0			;ERROR COUNT - MESSAGE RETRANSMISSION
L  DDLKLC			;LAST WORD TO CLEAR ON STARTUP + 2
DDLKCZ==!<DDLKLC-DDLKFC+1>/2
	DDBLK'TYPE  DEV,SOC
	.ENDM
	.PAGE
	.SBTTL	DDB FOR TYPE B LINKS

.IF DF LKBNUM
	.MACRO	DDBLKB  DEV,SOC
.IF NDF LKBDDB
  LKBDDB==!L'DEV'$		;LABEL FOR FIRST DDB FOR TYPE B LINK
.ENDC
;-----
; These are the error counters for the NAK reasons
;-----
W  DDERHB,0				;Header Block Check error
W  DDERDB,0				;Data Block Check error
W  DDERRR,0				;Rep response
W  DDERHF,0				;Message header format error
;-----
; These are the local error counters (Local to this node)
;-----
W  DDLBAE,0				;Ack error
W  DDERRC,0				;Sent rep counter
W  DDCDWN,0				;Current down time
W  DDTDW2,0				;High order total down time
W  DDTDW1,0				;Low order total down time
W  DDERTU,0				;Transmitter under runs
W  DDERHE,0				;Header CRC error
W  DDERFH,0				;Header format error
W  DDERBU,0				;Buffer unavailable
W  DDERML,0				;Message too large
W  DDERDE,0				;Data CRC error
W  DDERRO,0				;Receiver overrun
W  DDERH2,0				;Header CRC error in qsync block
W  DDERF2,0				;Header format error in qsync block
W  DDERD2,0				;Data CRC error in qsync block
LK'DEV'EC=!OS-DDLKER

.IF EQ	$$$L+1			;If no DCP is being used
W  DDLBRS,$$$R			;RXCSR - Reciver status register
W  DDLBRB,$$$R+2		;RXDBUF- Reciever data buffer
W  DDLBPR,$$$R+2		;PARCSR- Parameter status register
W  DDLBTS,$$$R+4		;TXCSR - Transmitter status register
W  DDLBTB,$$$R+6		;TXDBUF- Transmitter data buffer
W  DDOCRC,0			;Output CRC
W  DDICRC,0			;Input CRC
	.ENDC

.IF NE $$$L+1			;If we are using a DCP
W  DDLBRX,$$$R			;The DCP recieve control word
W  DDLBRB,$$$R+2		;The DCP recieve buffer word
W  DDLBTX,$$$R+10		;The DCP transmit control word
W  DDLBTB,$$$R+12		;The DCP transmit buffer word
W  DDLBVC,$$$VC				;The device vector to init
	.ENDC

W  DDPSLV,$$$P*40		;Processor status level at interrupt
W  DDLBLN,<$$$L*400>		;The line number on the DCP
W  DDHNDR,LKO'DEV		;Starting address of output handler
W  DDCIMI,0			;Input to main in pointer
W  DDCIMO,0			;Input to main out pointer
W  DDCIME,DDIMEX+L'DEV'$	;Input to main end pointer
W  DDCIMB,DDIMSX+L'DEV'$	;Input to main beginning pointer
W  DDCMOI,0			;Main to output in pointer
W  DDCMOO,0			;Main to output out pointer
W  DDCMOE,DDMOEX+L'DEV'$	;Main to output end pointer
W  DDCMOB,DDMOSX+L'DEV'$	;Main to output beginning pointer
W  DDSTHO,DDLBBF+L'DEV'$	;Start of header buffer
W  DDEDHO,DDLBEB+L'DEV'$	;End of header buffer
W  DDLBEP,DDLBLP+L'DEV'$	;End of input buffer
W  DDLBBP,DDLBFP+L'DEV'$	;Beginning of input buffer
L  DDLBFC			;First location to clear on init.
W  DDLBIP,0			;The in pointer for the input buffer
W  DDCNTI,0			;Input character count for SOH
W  DDCNTO,0			;Output character count for SOH
W  DDLBOH,0			;The output head pointer
W  DDPKTI,0			;Current input packet pointer
W  DDPKTO,0			;Current output packet pointer
W  DDPKTC,0			;Current packet being filled
W  DDPKTT,0			;Packet list, tail pointer
W  DDPKTH,0			;Packet list, head pointer
W  DDDCP ,0			;DDCMP current header pointer
W  DDFLAG,0			;Status flags for protocol
W  DDFLG2,0			;  "      "    "      "
W  DDLBPO,0			;Packet to send for Remote Loading
W  DDOST,0			;Output state
W  DDLBT1,0			;LOAD TYPE
W  DDLBP1,0			;PREFIX
W  DDLBC1,0			;LOAD CHECK SUM
W  DDLBLS,0			;LOAD STATE
W  DDCTHO,0			;
W  DDSNAK,0			;Current nak reason
W  DDSACK,0			;send ack flag
W  DDSREP,0			;Send rep flag
W  DDLBWT,0			;Packet waiting to go out
W  DDREPT,0			;Reply threshold count(Till link down)
B  DDSYN ,0			;Synchronize flag for protocol
B  DDSTAT,0			;The state of the protocol
B  DDNUM ,0			;NUM(Number of packet)
B  DDRESP,0			;RESP(Respose field)
B  DDACK ,0			;A(Last number ack'ed)
B  DDCTRN,0			;X(Last currently transmitted)
B  DDTRNS,0			;T(Next to be transmitted)
B  DDTIMR,0			;Rep timer
B  DDCACK,0			;The DDCMP packet number relating to
B  DDLBSS,0			;The Send Synch counter
B  DDSCNT,0			;The send ahead counter
B  DDLBSN,0			;The dummy byte to keep it even
M  DDLBBF,6			;DDCMP header block
L  DDLBEB			;End of header + 2
M  DDLBFP,6			;The input buffer
L  DDLBLP			;The end of the input buffer + 2
M  DDIMSX,IMSIZ*10.		;The input to main circular buffer
L  DDIMEX			;The end of the buffer + 2
M  DDMOSX,MOSIZ*10.		;The main to output circular buffer
L  DDMOEX			;The end of the buffer + 2
L  DDLBLC			;The last location to clear + 2
DDLBCZ==!<DDLBLC-DDLBFC+1>/2
	XSDB	LK,L,DEV,0,B	;THIS LINK USES A WILD SOCKET SDB
	.ENDM
.ENDC
	.PAGE
	.SBTTL	DDB FOR TYPE C LINKS

.IF DF LKCNUM
	.MACRO	DDBLKC  DEV,SOC
.IF NDF LKCDDB
  LKCDDB==!L'DEV'$;		;LABEL FOR FIRST DDB FOR TYPE C LINK
.ENDC
LK'DEV'EC=!OS-DDLKER
W  DDLCIB,$$$R+4		;ADDRESS OF DEVICE INPUT BUFFER
W  DDLCOB,$$$R+2		;ADDRESS OF DEVICE OUTPUT BUFFER
W  DDLCSR,$$$R			;ADDRESS OF DEVICE CONTROL AND STATUS REGISTER
L  DDLCFC			;FIRST LOCATION TO CLEAR ON STARTUP
B  DDLCTM,0			;MESSAGE TIMER
B  DDLCTD,0			;DATA TIMER
B  DDLCRQ,0			;MAIN PROGRAM REQUEST BYTE
B  DDLCXX,0
W  DDLCIK,0			;POINTER TO START OF INPUT PACKET
W  DDLCIP,0			;POINTER TO CURRENT INPUT WORD
W  DDLCIX,0			;INPUT CHECKSUM
B  DDLCIC,0			;INPUT WORD COUNT
B  DDLCIS,0			;INPUT STATE
W  DDLCIW,0			;INPUT HEADER WORD
W  DDLCOK,0			;POINTER TO START OF OUTPUT PACKET
W  DDLCOP,0			;POINTER TO CURRENT OUTPUT WORD
W  DDLCOD,0			;ADDRESS OF SDB FOR OUTPUT PACKET
W  DDLCOX,0			;OUTPUT CHECKSUM
B  DDLCOC,0			;OUTPUT WORD COUNT
B  DDLCOS,0			;OUTPUT STATE
B  DDLCXA,0			;BITS FOR PENDING ACK/NAK REQUESTS
L  DDLCLC			;LAST LOCATION + 2 TO CLEAR ON STARTUP
DDLCCZ==!<DDLCLC-DDLCFC+1>/2
	XSDB	LK,L,DEV,0,C	;THIS LINK USES A WILD SOCKET SDB
	.ENDM
.ENDC
	.PAGE
	.SBTTL	DDB FOR TYPE D LINKS

.IF DF LKDNUM
	.MACRO	DDBLKD  DEV,SOC
.IF NDF LKDDDB
  LKDDDB==!L'DEV'$;		;LABEL FOR FIRST DDB FOR TYPE D LINK
.ENDC
LK'DEV'EC=!OS-DDLKER
W  DDLDIR,$$$R+4		;ADDRESS OF DEVICE INPUT REGISTER
W  DDLDOR,$$$R+2		;ADDRESS OF DEVICE OUTPUT REGISTER
W  DDLDSR,$$$R			;ADDRESS OF DEVICE CONTROL AND STATUS REGISTER
L  DDLDFC			;FIRST LOCATION TO CLEAR ON STARTUP
W  DDLDOZ,0			;ADDRESS OF SDB FOR CURRENT OUTPUT PACKET
W  DDLDOK,0			;ADDRESS OF CURRENT OUTPUT PACKET
W  DDLDOP,0			;ADDRESS OF CURRENT OUTPUT WORD
B  DDLDOC,0			;OUTPUT WORD COUNT
B  DDLDIS,0			;INPUT STATE
W  DDLDIX,0			;INPUT DATA WORD
W  DDLDIP,0			;ADDRESS OF INPUT WORD
W  DDLDIK,0			;ADDRESS OF INPUT PACKET
B  DDLDIC,0			;INPUT WORD COUNT
B  DDLDCC,0			;INPUT CHARACTER COUNT (MUST BE DDLDIC+1!)
B  DDLDTM,0			;INPUT MESSAGE TIMER
B  DDLDTD,0			;OUTPUT DATA TIMER
B  DDLDRQ,0			;SERVICE REQUEST BITS
B  DDLDXX,0
L  DDLDLC			;LAST LOCATION + 2 TO CLEAR ON STARTUP
DDLDCZ==!<DDLDLC-DDLDFC+1>/2
	XSDB	LK,L,DEV,0,D	;THIS LINK USES A WILD SOCKET SDB
	.ENDM
.ENDC
	.PAGE
	.SBTTL	DDB FOR TYPE E LINKS

.IF DF LKENUM
	.MACRO	DDBLKE  DEV,SOC
.IF NDF LKEDDB
  LKEDDB==!L'DEV'$;		; Label for first DDB for type E link
.ENDC
W  DDLEBP,0			; LINK E BAD PACKET COUNT
W  DDLEDG,0			; LINK E DIAGNOSTIC PACKET COUNT
LK'DEV'EC=!OS-DDLKER
W  DDLERS,$$$R			; Receiver status register
W  DDLERB,$$$R+2		; Receiver data buffer
W  DDLEPR,$$$R+2		; Parameter control register
W  DDLEXS,$$$R+4		; Transmitter status register
W  DDLEXB,$$$R+6		; Transmitter data buffer
W  DDLEPX,0			; Parameter control register initial value
W  DDLELV,$$$P*40		; Interrupt priority level
W  DDLEVC,$$$VC		;--KSB2, INTERRUPT VECTOR
W  DDLELB,L'DEV'$+DDLELR	; Ptr to beginning of TRANSMIT ring
W  DDLELE,L'DEV'$+DDLELR+<2*<$$$C+1>>; Pointer to end of TRANSMIT ring
W  DDLELH,L'DEV'$+DDLELR	; Ring pointer to head of XMIT RING
W  DDLELN,L'DEV'$+DDLELR	; Ring pointer to next frame to send
W  DDLELT,L'DEV'$+DDLELR	; Ring pointer to tail of XMIT RING
W  DDLEQB,L'DEV'$+DDLEQR	; Ptr to start of input to main ring
W  DDLEQE,L'DEV'$+DDLEQR+<4*<$$$C+3>> ; Ptr to end of input to main ring
W  DDLEQP,L'DEV'$+DDLEQR	; Input to main ring putter
W  DDLEQT,L'DEV'$+DDLEQR	; Input to main ring taker

;W  DDLED1,$$$3			; 1ST HALF OF X.25 DESTINATION NAME
;W  DDLED2,$$$4			; 2ND HALF OF X.25 DESTINATION NAME
;W  DDLEX1,$$$5
;W  DDLEX2,$$$6

B  DDLEXC,$$$A			; TRANSMITted command frame address
B  DDLEXR,$$$B			; Transmitted response frame address
B  DDLERC,$$$B			; Received command frame address
B  DDLERR,$$$A			; Received response frame address
B  DDLEK0,$$$C			; FRAME TRANSMIT RING WINDOW SIZE
B  DDLEK1,$$$D			; DURATION OF NO-RESPONSE TIMER T1
B  DDLEK2,$$$E			; RETRANSMISSION COUNTER N2
B  DDLEK3,$$$F			; MAX # BYTES IN FRAME INFO FIELD
L  DDLEFC			; 1st word to clear on STARTUP
B  DDLET3,0			; IDLE OUTPUT RR FRAME TIMER
B  DDLET4,0			; REJECT CONDITION TIMER
B  DDLET5,0			; COMMAND REJECT CONDITION TIMER
B  DDLET6,0			; Idle input take-down timer
W  DDLEBX,0			; ERROR COUNT - BAD RETRANSMISSIONS
				;   (NOTHING IN RING TO RETRANSMIT)
W  DDLEAH,0			; PACKET LEVEL SEND BACK LIST HEAD
W  DDLEAT,0			; PACKET LEVEL SEND BACK LIST TAIL
W  DDLEFG,0			; Protocol flags word
W  DDLEF2,0			; 2ND FLAG WORD
W  DDLEIS,0			; Input state dispatch
W  DDLEOS,0			; Output state dispatch
W  DDLETS,0			; Temp storage for output state
				;   dispatch during transparent output
W  DDLEOI,0			; Dispatch for output frame info field
W  DDLECI,0			; Input CRC-16
W  DDLECO,0			; Output CRC-16
W  DDLEIF,0			; Input packet list head pointer
W  DDLEMF,0			; Main level packet list head pointer
W  DDLEOF,0			; Output packet list head pointer
W  DDLEIP,0			; Input current packet pointer
W  DDLEOP,0			; Output current packet pointer
W  DDLEIB,0			; Input byte pointer
W  DDLEOB,0			; Output byte pointer
W  DDLETX,0			; Timer T1 expiration dispatch
W  DDLEUR,0			; Waiting to receive UA frame dispatch
B  DDLEIA,0			; Input frame address byte
B  DDLEOA,0			; Output frame address byte
B  DDLEIX,0			; Input frame control byte
B  DDLEMX,0			; Main level frame control byte
B  DDLEOX,0			; Output frame control byte
B  DDLEIK,0			; Input frame byte count
B  DDLEIC,0			; Input current packet byte count
B  DDLEOC,0			; Output currenmt packet byte count
B  DDLEIZ,0			; Input frame error status function
B  DDLET1,0			; Timer T1
B  DDLEN2,0			; Retransmission count N2
B  DDLENR,0			; N(R) of last good info or SUPV frame
B  DDLEVR,0			; V(R) next info frame expected
B  DDLEVS,0			; V(S) next info frame to send
B  DDLEVT,0			; Tranmit ring frame count
B  DDLEAK,0			; Response function (acknowledgement)
B  DDLECM,0			; Pending command function to send
B  DDLECR,0			; CMDR reason byte
B  DDLECX,0			; Bad control byte causing CMDR
B  DDLEXX,0			; Temp storage for 1 byte at main level
M  DDLELR,2*<$$$C+1>		; Send list ring (window of K frames)
M  DDLEQR,4*<$$$C+3>		; Input to main ring
L  DDLELC			; Last word (+2) to clear on startup
DDLECZ==!<DDLELC-DDLEFC+1>/2
	XSDB	LK,L,DEV,0,E	;THIS LINK USES A WILD SOCKET SDB
	.ENDM
.ENDC
	.PAGE
	.SBTTL	DDB FOR TYPE F LINKS

.IF DF LKFNUM
	.MACRO	DDBLKF  DEV,SOC
.IF NDF LKFDDB
  LKFDDB==!L'DEV'$;		;LABEL FOR FIRST DDB FOR TYPE F LINK
.ENDC
LK'DEV'EC=!OS-DDLKER
W  DDLFIR,$$$R+4		;ADDRESS OF DEVICE INPUT REGISTER
W  DDLFOR,$$$R+2		;ADDRESS OF DEVICE OUTPUT REGISTER
W  DDLFSR,$$$R			;ADDRESS OF DEVICE CONTROL AND STATUS REGISTER
W  DDLFAV,$$$W			;SIZE OF HOST'S INPUT RING BUFFER IN PDP-10
				;  WORDS
W  DDLFPL,$$$P*40		;INTERRUPT PRIORITY LEVEL
L  DDLFFC			;FIRST LOCATION TO CLEAR ON STARTUP
W  DDLFBI,0			;BLOCK MODE-TO HOST-CHARACTER COUNT
W  DDLFOV,0			;BLOCK MODE-TO HOST-ADDRESS OF DATA TO SEND
W  DDLFBH,0			;BLOCK MODE-FROM HOST-LIST HEAD POINTER
W  DDLFBT,0			;BLOCK MODE-FROM HOST-LIST TAIL POINTER
W  DDLFBS,0			;BLOCK MODE-FROM HOST-SDB ADDRESS
W  DDLFBC,0			;BLOCK MODE-FROM HOST-TOTAL WORD COUNT
W  DDLFBJ,0			;BLOCK MODE-FROM HOST-TOTAL CHARACTER COUNT
W  DDLFBK,0			;BLOCK MODE-FROM HOST-ADDRESS OF FIRST PACKET
W  DDLFBQ,0			;BLOCK MODE-FROM HOST-ADDRESS OF CURRENT PACKET
W  DDLFBW,0			;BLOCK MODE-FROM HOST-DATA POINTER
B  DDLFBY,0			;BLOCK MODE-FROM HOST-WORDS LEFT IN PACKET
B  DDLFBP,0			;BLOCK MODE-NUMBER OF CHANNELS
W  DDLFXR,0			;PACKET WAIT-RECOVERY ADDRESS
W  DDLFXS,0			;PACKET WAIT-SDB ADDRESS
W  DDLFX1,0			;PACKET WAIT-DATA WORD
W  DDLFX2,0			;PACKET WAIT-DATA WORD
W  DDLFX3,0			;PACKET WAIT-DATA WORD
W  DDLFX4,0			;PACKET WAIT-DATA WORD
W  DDLFT1,0			;TEST PATTERN-FIRST WORD
W  DDLFT2,0			;TEST PATTERN-SECOND WORD
W  DDLFS1,0			;HOST SAD BITS-FIRST WORD
W  DDLFS2,0			;HOST SAD BITS-SECOND WORD
W  DDLFPO,0			;PORT OFFSET ON HOST
W  DDLFAL,0			;NUMBER OF PDP-10 WORDS TO END OF HOST'S INPUT
				;  RING BUFFER
W  DDLFGS,0			;Address of current supervisory SDB
W  DDLFIQ,0			;ADDRESS OF CURRENT INPUT PACKET
W  DDLFIK,0			;ADDRESS OF FIRST INPUT PACKET
W  DDLFIP,0			;INPUT POINTER
W  DDLFIC,0			;INPUT WORD COUNT
W  DDLFCC,0			;INPUT CHARACTER COUNT
B  DDLFIS,0			;INPUT STATE (MUST BE EVEN ADDRESS)
B  DDLFPC,0			;SPACE LEFT IN CURRENT INPUT PACKET
M  DDLFIX,20.			;INPUT MESSAGE BUFFER
W  DDLFOK,0			;ADDRESS OF OUTPUT PACKET
W  DDLFOP,0			;OUTPUT POINTER
W  DDLFOC,0			;OUTPUT WORD COUNT
W  DDLFOZ,0			;ADDRESS OF SDB FOR OUTPUT PACKET
W  DDLFQX,0			;WORD USED FOR TERMINAL PARAMETER MESSAGES
				;  (MUST PRECEED DDLFOX!)
DDLFQQ==!DDLFQX/2+1
M  DDLFOX,PKCMAX*2-2		;OUTPUT MESSAGE BUFFER
W  DDLFOS,0			;OUTPUT STATE
B  DDLFRQ,0			;MAIN PROGRAM LEVEL REQUEST BITS
B  DDLFTM,0			;MESSAGE TIMER
B  DDLFTD,0			;DATA TIMER (MUST BE EVEN BYTE)
B  DDLFTP,0			;POKE TIMER (MUST BE DDLFTD + 1)
L  DDLFLC			;LAST LOCATION + 2 TO CLEAR ON STARTUP
DDLFCZ==!<DDLFLC-DDLFFC+1>/2
	XSDB	LK,L,DEV,0,F;	;THIS LINK USES A WILD SOCKET SDB
	.ENDM
.ENDC
	.PAGE
	.SBTTL	DDB FOR TYPE H LINKS

.IF DF LKHNUM
	.MACRO	DDBLKH  DEV,SOC
.IF NDF LKHDDB
  LKHDDB==!L'DEV'$;		;LABEL FOR FIRST DDB FOR TYPE H LINK
.ENDC
LK'DEV'EC=!OS-DDLKER
W  DDLHNN,$$$NN;		;TYMNET NODE NUMBER
W  DDLHND,$$$ND;		;NODE DESCRIPTOR
W  DDLHLD,L'DEV'.0;		;ADDRESS OF FIRST LDB
W  DDLHNL,$$$NL;		;NUMBER OF LINES ON GATEWAY
W  DDLHMX,204+<$$$NH*4>		;HIGHEST LEGAL ADDRESS IN SUPERVISOR AREA
W  DDLHTR,120000+<$$$NH*100>+$$$NL;SR2 WORD FOR TAKEOVER RESPONSE
.IF DF LHBASE			;ONLY IF HAVE TYM-BASE SUPPORT
  W  DDLHXP,$$$S0		;TABLE OF PORTS TO USE AS KEYS FOR BUILDING
  WX        $$$S1		;  AUX-CIRCUITS
  WX        $$$S2
  WX        $$$S3
  W  DDLHNH,$$$NH		;NUMBER OF HOSTS ON THIS TYMBASE
  W  DDLHSH,$$$SH		;NUMBER OF PORTS ALLOCATED TO EACH HOST
  W  DDLHPH,$$$PH		;NUMBER OF PORTS ACTUALLY AVAILABLE TO EACH HOST
  W  DDLHHM,L.HM'DEV		;ADDRESS OF MESSAGE TABLE FOR THIS TYMBASE
  W  DDLHBF,HBFT'DEV;		;ADDRESS OF HOST BUFFER TABLE
  W  DDLHDH,$$$0A;		;LIST OF NAMES FOR DST HOSTS
  WX        $$$0B
  WX        $$$1A
  WX        $$$1B
  WX        $$$2A
  WX        $$$2B
  WX        $$$3A
  WX        $$$3B
  W  DDLHHY,$$$SO		;HOST TABLE OFFSET VALUE
.ENDC
L  DDLHFC;			;FIRST LOCATION TO CLEAR ON STARTUP
.IF DF LHBASE
  M  DDLHXS,8.			;ADDRESSES OF SDB'S FOR AUX-CIRCUIT DIALOGS
  M  DDLHSS,16.			;ADDRESSES OF SUPERVISORY SDB'S FOR EACH HOST
  W  DDLHVH,0			;HIGH ORDER PART OF INVOICE NUMBER LAST SENT TO SUP
  W  DDLHVL,0			;LOW ORDER PART OF INVOICE NUMBER LAST SENT TO SUP
.ENDC
B  DDLHNU,0;			;NUMBER OF LINES WHICH ARE UP
BX        0
W  DDLHUP,0;			;UPSTREAM SWITCH
W  DDLHDW,0;			;DOWNSTREAM SWITCH
B  DDLHTY,0;			;SUPERVISOR TYPE
B  DDLHSN,0;			;CURRENT SUPERVISOR NUMBER
M  DDLHSM,212;			;SUPERVISOR MEMORY AREA
L  DDLHLC;			;LAST LOCATION + 2 TO CLEAR ON STARTUP
DDLHCZ==!<DDLHLC-DDLHFC+1>/2
.IF DF LHBASE
  .IF DF LD'DEV'.0
    W  DDLHHD,LD'DEV'.0
    WX        $$$PH
  .IFF
    W  DDLHHD,0
    WX        0
  .ENDC
  .IF DF LD'DEV'.1
    WX         LD'DEV'.1
    WX         $$$PH
  .IFF
    WX         0
    WX         0
  .ENDC
  .IF DF LD'DEV'.2
    WX         LD'DEV'.2
    WX         $$$PH
  .IFF
    WX         0
    WX         0
  .ENDC
  .IF DF LD'DEV'.3
    WX         LD'DEV'.3
    WX         $$$PH
  .IFF
    WX         0
    WX         0
  .ENDC
.ENDC
	.ENDM
.ENDC
	.PAGE
	.SBTTL	DDB FOR TYPE I LINKS

.IF DF LKINUM
	.MACRO	DDBLKI  DEV,SOC
.IF NDF LKIDDB
  LKIDDB==!L'DEV'$;		;LABEL FOR FIRST DDB FOR TYPE I LINK
.ENDC
LK'DEV'EC=!OS-DDLKER
W  DDLINN,$$$NN;		;TYMNET NODE NUMBER
W  DDLILD,L'DEV'.0;		;ADDRESS OF FIRST LDB
B  DDLINL,$$$NL;		;NUMBER OF LINES ON GATEWAY
BX	0;
L  DDLIFC;			;FIRST LOCATION TO CLEAR ON STARTUP
B  DDLINU,0;			;NUMBER OF LINES WHICH ARE UP
B  DDLISC,0;			;UPSTREAM CHANNEL
W  DDLIUP,0;			;UPSTREAM LDB
W  DDSUSD,0;			;UPSTREAM SDB
B  DDLITY,0;			;SUPERVISOR TYPE
B  DDLISN,0;			;CURRENT SUPERVISOR NUMBER
.IF DF LIBASE
  M  DDLISS,$$$NH*4		;ADDRESSES OF SUPERVISORY SDB'S FOR EACH HOST
				;USES EVERY OTHER WORD BECAUSE HOSTS (IN
				;DDLIDH) ARE DOUBLE WORDS
  W  DDLIVH,0			;HIGH ORDER PART OF INVOICE NUMBER LAST SENT TO SUP
  W  DDLIVL,0			;LOW ORDER PART OF INVOICE NUMBER LAST SENT TO SUP
.ENDC
L  DDLILC;			;LAST LOCATION + 2 TO CLEAR ON STARTUP
DDLICZ==!<DDLILC-DDLIFC+1>/2
.IF DF LIBASE			;ONLY IF HAVE TYM-BASE SUPPORT
  B  DDLINH,$$$NH		;NUMBER OF HOSTS ON THIS TYMBASE
  BX	0
  L  DDLIDH			;LIST OF NAMES IN RADIX-50
				;FOR DST HOSTS (DOUBLE WORD TABLE)
  ..H=!0
	.REPT	$$$NH
	.IRP	HOST,<\..H>
    WX	L.'HOST'A'DEV
    WX	L.'HOST'B'DEV
	.ENDM
  ..H=!..H+1
	.ENDR

  L	DDLIHD			;EQUIVALENT TYMNET INTEGER HOST NUMBERS FOR THE
				;NEXNET NAMES IN DDLIDH
..H=!0
	.REPT	$$$NH
	.IRP	HOST,<\..H>
   WX	LD'DEV'.'HOST
   WX	L'DEV'.D'HOST
	.ENDM
..H=!..H+1
	.ENDR
.ENDC
	.ENDM
.ENDC
.ENDC				;.IF NE LK.NUM
	.PAGE
	.SBTTL	LINE DATA BLOCKS FOR LINKS (LDB'S)

.IF DF LKHNUM			;ONLY HAVE LDB'S IF HAVE TYPE H LINKS

;DEFINE MACRO USED TO GENERATE COMMON PART OF EACH LDB

	.MACRO	XHLDB  DEV,LINE,TYPE
	.PSECT	LDB,RW,D,LCL,REL,CON
	.MACRO	RESTOR
	.PSECT	LDB,RW,D,LCL,REL,CON
	.ENDM
OS=!0
L'DEV'.'LINE::
W  LDHSTX,LH'TYPE'STX#;		;ADDRESS OF FRAME LEVEL START ROUTINE
W  LDHDWX,LH'TYPE'DWX#;		;ADDRESS OF FRAME LEVEL "DOWN" ROUTINE
W  LDHINX,LH'TYPE'INX#;		;ADDRESS OF FRAME LEVEL INITIALIZATION ROUTINE
W  LDHSDB,LS'DEV'.'LINE		;ADDRESS OF SDB TABLE FOR THIS LINE
B  LDHSPD,$$$Q;			;LINE SPEED
B  LDHGRP,$$$C/10;		;NUMBER OF 8 LINE GROUPS
B  LDHCHN,$$$C;			;NUMBER OF CHANNELS
B  LDHLNO,LINE;			;LINE NUMBER
W  LDHDDB,L'DEV'$;		;ADDRESS OF DDB
W  LDHNBR,$$$N;			;NUMBER OF NEIGHBOR NODE
W  LDHNXT,L'DEV'H'LINE;		;ADDRESS OF NEXT LDB
W  LDHNXS,0;			;NEXT LDB OF SAME LINE TYPE
W  LDHST0,$$$S;			;PURE STATUS WORD
W  LDHNPT,L'DEV'$+DDLHSM+<<65+LINE>*2> ;POINTER TO NODE NUMBER IN FAKE MEMORY
W  LDHBPT,L'DEV'$+DDLHSM+<<5+LINE>*2> ;POINTER TO BORI IN FAKE MEMORY
L  LDHFCL;			;FIRST LOCATION TO CLEAR ON STARTUP
W  LDHST1,0;			;IMPURE STATUS WORD
W  LDHST2,0;			;IMPURE STATUS WORD
W  LDHZLH,0;			;ZAP LIST HEAD POINTER
W  LDHZLT,0;			;ZAP LIST TAIL POINTER
W  LDHSLH,0;			;SUPERVISOR LIST HEAD POINTER
W  LDHSLT,0;			;SUPERVISOR LIST HEAD POINTER
W  LDHXLH,0;			;SEND LIST HEAD POINTER
W  LDHXLT,0;			;SEND LIST TAIL POINTER
W  LDHZCN,0;			;NUMBER OF TIMES BUFFERS ZAPPED BY LNKH
W  LDHSR0,0;			;Place to save R0 if no packets
W  LDHSR2,0;			;Place to save R2 if no packets
W  LDHSSD,0;			;PLACE TO SAVE SD IF NO PACKETS
W  LDHSFC,0;			;Place to save frame count if no packets
W  LDHSRC,0;			;Place to save record count if no packets
W  LDHSPC,0;			;Place to save PC if no packets
W  LDPKOT,0;			;Packets sent out
W  LDPKIN,0;			;Packets received
B  LDHACK,0;			;ACK number (last record read)
B  LDHAIA,0;			;ACK received on input
B  LDHLRA,0;			;Last record ACK'd & removed from output queue
B  LDHNOR,0;			;Next record number to output
B  LDHUAC,0;			;Unsent ACK count
B  LDHTDT,0;			;Timer - retransmission state take down
B  LDHIIT,0;			;Timer - idle input master reset
B  LDHIRT,0;			;Timer - ignore reset pattern
W  LDERBD,0;			;ERROR COUNT - BAD DATA IN FRAME
W  LDHERC,0;			;ERROR COUNT - BAD CHECKSUM
W  LDHERB,0;			;ERROR COUNT - LOOP BACK
W  LDHERS,0;			;ERROR COUNT - FRAMES RECEIVED OUT OF SEQUENCE
W  LDHERX,0;			;ERROR COUNT - FRAMES RETRANSMITTED
W  LDHEBA,0;			;Error count - bad ACK received
W  LDHELD,0;			;Error count - line take down timer expired
W  LDHEBN,0;			;Error count - bad neighbor in reset pattern
L  LDHLCL;			;LAST LOCATION TO CLEAR ON STARTUP
LDHCSZ==!<LDHLCL-LDHFCL>/2
	LDB'TYPE  DEV,LINE
	.ENDM

;Define interface dependent part for type A interface

.IF DF LHALNS
	.MACRO	LDBA  DEV,LINE
.IF NDF LHALDB
  LHALDB==!L'DEV'.'LINE
.ENDC
W  LDHARS,$$$R;			;Device receiver control status register
W  LDHARB,$$$R+2;		;Device receiver data buffer
W  LDHAPR,$$$R+2;		;Device parameter control status register
W  LDHAXS,$$$R+4;		;Device transmitter control status register
W  LDHAXB,$$$R+6;		;Device transmitter data buffer
W  LDHAPL,$$$P*40		;Interrupt priority level
W  LDHASB,L'DEV'.'LINE+LDHASX;	;Pointer to beginning of input sector storage
W  LDHASE,L'DEV'.'LINE+LDHASX+<2*$$$X>; End of input sectors
W  LDHAST,L'DEV'.'LINE+LDHASX;	;Input sector storage taker
W  LDHAQB,L'DEV'.'LINE+LDHAQX;	;Pointer to beginning of output queue
W  LDHAQE,L'DEV'.'LINE+LDHAQX+<2*<$$$X+1>>; End of output queue
W  LDHAQT,L'DEV'.'LINE+LDHAQX;	;Output queue taker (1st frame in queue)
W  LDHAQN,L'DEV'.'LINE+LDHAQX;	;Output queue next to send pointer
W  LDHAQP,L'DEV'.'LINE+LDHAQX;	;Output queue putter (1st available slot)
W  LDHAKB,L'DEV'.'LINE+LDHAKX;	;Pointer to beginning of INTERRUPT RING
W  LDHAKE,L'DEV'.'LINE+LDHAKX+12; End of INTERRUPT RING
W  LDHAKT,L'DEV'.'LINE+LDHAKX;	;INTERRUPT RING taker (1st frame in queue)
W  LDHAKP,L'DEV'.'LINE+LDHAKX;	;INTERRUPT RING putter (1st available slot)
B  LDHAMX,$$$X;			;Maximum number of frames outstanding
B  LDHAMD,<^C<<2*$$$X>-1>>;	; Bit mask for modulus arith on REC & ACK
L  LDHAFC;			;First location to clear on startup
W  LDHAEI,0;			;Error count - lost input (idle too long)
W  LDHAEL,0;			;Error count - lost output interrupt (IRMA)
W  LDHAEO,0;			;Error count - input overrun
W  LDHAEP,0;			;Error count - hardware output error
W  LDHASC,0;			;Shift count for input byte synchronization
W  LDHAIS,0;			;Input state
W  LDHAOS,0;			;Output state
W  LDHAIF,0;			;Input frame pointer
W  LDHAIW,0;			;Input word pointer
W  LDHAOW,0;			;Output word pointer
W  LDHAIL,0;			;Input longitudinal checksum word
W  LDHAID,0;			;Input diagonal checksum word
W  LDHAOL,0;			;Output longitudinal checksum word
W  LDHAOD,0;			;Output diagonal checksum word
B  LDHAIB,0;			;Input high byte of word
B  LDHAOB,0;			;Output low byte of word
B  LDHAIC,0;			;Input word count
B  LDHAOC,0;			;Output word count
B  LDHAIX,0;			;Input word left-over bit storage
B  LDHAFR,0;			;Output queue frame count
M  LDHASX,20;			;Input sector storage area (big enough for WS8)
M  LDHAQX,22;			;Output frame queue (big enough for WS8)
M  LDHAKX,12;			;INPUT INTERRUPT LEVEL TO MAIN PROGRAM RING
L  LDHALC;			;Last location + 2 to clear on startup
LDHACZ==!<LDHALC-LDHAFC+1>/2
	.ENDM
.ENDC		;.IF DF LHALNS

;Define interface dependent part for type B interface

.IF DF LHBLNS
	.MACRO	LDBB  DEV,LINE
.IF NDF LHBLDB
  LHBLDB==!L'DEV'.'LINE
.ENDC
W  LDHBRS,$$$R;			;Device receiver function register
W  LDHBRB,$$$R+2;		;Device receiver data buffer
W  LDHBXS,$$$R+10;		;Device transmitter function register
W  LDHBXB,$$$R+12;		;Device transmitter data buffer
W  LDHBPL,$$$P*40		;Interrupt priority level
W  LDHBFN,$$$PN*$BIT08;		;Function byte (low) and DCP port number (hi)
W  LDHBVC,$$$VC			;Interrupt vector for DCP port
W  LDHBSB,L'DEV'.'LINE+LDHBSX;	;Pointer to beginning of input sector storage
W  LDHBSE,L'DEV'.'LINE+LDHBSX+<2*$$$X>; End of input sectors
W  LDHBST,L'DEV'.'LINE+LDHBSX;	;Input sector storage taker
W  LDHBQB,L'DEV'.'LINE+LDHBQX;	;Pointer to beginning of output queue
W  LDHBQE,L'DEV'.'LINE+LDHBQX+<2*<$$$X+1>>; End of output queue
W  LDHBQT,L'DEV'.'LINE+LDHBQX;	;Output queue taker (1st frame in queue)
W  LDHBQN,L'DEV'.'LINE+LDHBQX;	;Output queue next to send pointer
W  LDHBQP,L'DEV'.'LINE+LDHBQX;	;Output queue putter (1st available slot)
W  LDHBKB,L'DEV'.'LINE+LDHBKX;	;Pointer to beginning of interrupt ring
W  LDHBKE,L'DEV'.'LINE+LDHBKX+<2*<$$$X+1>>; End of interrupt ring
W  LDHBKT,L'DEV'.'LINE+LDHBKX;	;Interrupt ring taker (1st frame in queue)
W  LDHBKP,L'DEV'.'LINE+LDHBKX;	;Interrupt ring putter (1st available slot)
B  LDHBMX,$$$X;			;Maximum number of frames outstanding
B  LDHBMD,<^C<<2*$$$X>-1>>;	;Bit mask for modulus arith on REC & ACK
L  LDHBFC;			;First location to clear on startup
W  LDHBEC,0			;Error count - DCP device error
W  LDHBEI,0;			;Error count - lost input (idle too long)
W  LDHBEL,0;			;Error count - lost output interrupt (IRMA)
W  LDHBEO,0;			;Error count - input overrun
W  LDHBEP,0;			;Error count - hardware output error
W  LDHBLK,0			;Interrupt code lock, 0 = locked, 2 = unlocked
W  LDHBIS,0;			;Input state
W  LDHBOS,0;			;Output state
W  LDHBIF,0;			;Input frame pointer
W  LDHBIW,0;			;Input word pointer
W  LDHBOW,0;			;Output word pointer
W  LDHBIL,0;			;Input longitudinal checksum word
W  LDHBID,0;			;Input diagonal checksum word
W  LDHBOL,0;			;Output longitudinal checksum word
W  LDHBOD,0;			;Output diagonal checksum word
B  LDHBIB,0;			;Input high byte of word
B  LDHBOB,0;			;Output low byte of word
B  LDHBIC,0;			;Input word count
B  LDHBOC,0;			;Output word count
B  LDHBIX,0;			;Input word left-over bit storage
B  LDHBFR,0;			;Output queue frame count
M  LDHBSX,20;			;Input sector storage area (big enough for WS8)
M  LDHBQX,22;			;Output frame queue(big enough fo WS8)
M  LDHBKX,22;			;Input interrupt level to main program ring
L  LDHBLC;			;Last location + 2 to clear on startup
LDHBCZ==!<LDHBLC-LDHBFC+1>/2
	.ENDM
.ENDC		;.IF DF LHBLNS
.ENDC		;.IF DF LKHNUM
	.PAGE
	.SBTTL	LINE DATA BLOCKS FOR  TYPE I LINKS (LDB'S)

.IF DF LKINUM			;ONLY HAVE LDB'S IF HAVE TYPE I LINKS

;DEFINE MACRO USED TO GENERATE COMMON PART OF EACH LDB

	.MACRO	XILDB  DEV,LINE,TYPE
	.PSECT	LDB,RW,D,LCL,REL,CON
	.MACRO	RESTOR
	.PSECT	LDB,RW,D,LCL,REL,CON
	.ENDM
OS=!0
L'DEV'.'LINE::
W  LDISTX,LI'TYPE'STX#;		;ADDRESS OF FRAME LEVEL START ROUTINE
W  LDIDWX,LI'TYPE'DWX#;		;ADDRESS OF FRAME LEVEL "DOWN" ROUTINE
W  LDIINX,LI'TYPE'INX#;		;ADDRESS OF FRAME LEVEL INITIALIZATION ROUTINE
W  LDISDB,LS'DEV'.'LINE		;ADDRESS OF SDB TABLE FOR THIS LINE
B  LDISPD,$$$Q;			;LINE SPEED
B  LDIGRP,$$$C/10;		;NUMBER OF 8 LINE GROUPS
B  LDICHN,$$$C;			;NUMBER OF CHANNELS
B  LDILNO,LINE;			;LINE NUMBER
W  LDIDDB,L'DEV'$;		;ADDRESS OF DDB
W  LDINBR,$$$N;			;NUMBER OF NEIGHBOR NODE
W  LDINXT,L'DEV'I'LINE;		;ADDRESS OF NEXT LDB
W  LDINXS,0;			;NEXT LDB OF SAME LINE TYPE
W  LDIST0,$$$S;			;PURE STATUS WORD
W  LDIPSB,L'DEV'.'LINE+LDIPSX;	;Pointer to beginning of input sector storage
W  LDIPSE,L'DEV'.'LINE+LDIPSX+<2*$$$X>; End of input sectors
W  LDIPST,L'DEV'.'LINE+LDIPSX;	;Input sector storage taker
W  LDIPQB,L'DEV'.'LINE+LDIPQX;	;Pointer to beginning of output queue
W  LDIPQE,L'DEV'.'LINE+LDIPQX+<2*<$$$X+1>>; End of output queue
W  LDIPQT,L'DEV'.'LINE+LDIPQX;	;Output queue taker (1st frame in queue)
W  LDIPQN,L'DEV'.'LINE+LDIPQX;	;Output queue next to send pointer
W  LDIPQP,L'DEV'.'LINE+LDIPQX;	;Output queue putter (1st available slot)
W  LDIPKB,L'DEV'.'LINE+LDIPKX;	;Pointer to beginning of INTERRUPT RING
W  LDIPKE,L'DEV'.'LINE+LDIPKX+10 ; End of INTERRUPT RING
W  LDIPKT,L'DEV'.'LINE+LDIPKX;	;INTERRUPT RING taker (1st frame in queue)
W  LDIPKP,L'DEV'.'LINE+LDIPKX;	;INTERRUPT RING putter (1st available slot)
B  LDIPMX,$$$X;			;Maximum number of frames outstanding
B  LDIPMD,<^C<<2*$$$X>-1>>;	; Bit mask for modulus arith on REC & ACK
L  LDIFCL;			;FIRST LOCATION TO CLEAR ON STARTUP
W  LDIST1,0;			;IMPURE STATUS WORD
W  LDIST2,0;			;SECOND IMPURE STATUS WORD
W  LDIBOR,0;			;BORI FOR FOR THE OTHER GUY
W  LDIBOT,0;			;OUR BORI
B  LDIPPR,0;			;LAST RECEIVED PING-PONG RESET
B  LDIPPT,0;			;NEXT PING-PONG RESET TO SEND
W  LDIZLH,0;			;ZAP LIST HEAD POINTER
W  LDIZLT,0;			;ZAP LIST TAIL POINTER
W  LDISLH,0;			;SUPERVISOR LIST HEAD POINTER
W  LDISLT,0;			;SUPERVISOR LIST HEAD POINTER
W  LDIXLH,0;			;SEND LIST HEAD POINTER
W  LDIXLT,0;			;SEND LIST TAIL POINTER
W  LDIFLF,0;			;FLOW CONTROL CHANNELS LEFT COUNT
W  LDILSD,0;			;POINTER TO NEXT FLOW CONTROL SDB TO PROCESS
W  LDIZCN,0;			;NUMBER OF TIMES BUFFERS ZAPPED BY LNKI
W  LDISR0,0;			;Place to save R0 if no packets
W  LDISR2,0;			;Place to save R2 if no packets
W  LDISSD,0;			;PLACE TO SAVE SD IF NO PACKETS
W  LDISFC,0;			;Place to save frame count if no packets
W  LDISRC,0;			;Place to save record count if no packets
W  LDISPC,0;			;Place to save PC if no packets
W  LDPKOT,0;			;Packets sent out
W  LDPKIN,0;			;Packets received
W  LDIIFP,0;			;Input frame pointer
W  LDIIWP,0;			;Input word pointer
W  LDIOFP,0;			;Output frame pointer for retransmission--OS31
W  LDIOWP,0;			;Output word pointer
W  LDIILC,0;			;Input longitudinal checksum word
W  LDIIDC,0;			;Input diagonal checksum word
W  LDIOLC,0;			;Output longitudinal checksum word
W  LDIODC,0;			;Output diagonal checksum word
W  LDIIAK,0;			;ACK received on input
B  LDIOAK,0;			;ACK number (last record read)
B  LDIILA,0;			;Last record ACK'd & removed from output queue
B  LDIORN,0;			;Next record number to output
BX	  0;
B  LDIAFR,0;			;Output queue frame count
B  LDIUFC,0;			;Unsent frame count
B  LDIAUA,0;			;Unsent ACK count
B  LDIATD,0;			;Timer - retransmission state take down
B  LDIATI,0;			;Timer - idle input master reset
B  LDIATR,0;			;Timer - ignore reset pattern
M  LDIPKX,10;			;INPUT INTERRUPT LEVEL TO MAIN PROGRAM RING
M  LDIPSX,22;			;Input sector storage area (big enough for WS8)
M  LDIPQX,22;			;Output frame queue (big enough for WS8)
W  LDERBD,0;			;ERROR COUNT - BAD DATA IN FRAME
W  LDIERC,0;			;ERROR COUNT - BAD CHECKSUM
W  LDIERB,0;			;ERROR COUNT - LOOP BACK
W  LDIERS,0;			;ERROR COUNT - FRAMES RECEIVED OUT OF SEQUENCE
W  LDIERX,0;			;ERROR COUNT - FRAMES RETRANSMITTED
W  LDIAEA,0;			;Error count - bad ACK received
W  LDIAED,0;			;Error count - line take down timer expired
W  LDIAEI,0;			;Error count - lost input (idle too long)
W  LDIAEL,0;			;Error count - lost output interrupt (IRMA)
W  LDIAEN,0;			;Error count - bad neighbor in reset pattern
W  LDIAEO,0;			;Error count - input overrun
W  LDIAEP,0;			;Error count - hardware output error
L  LDILCL;			;LAST LOCATION TO CLEAR ON STARTUP
LDIESZ==!<LDILCL-LDERBD>/2	;SIZE OF ERROR COUNTERS
LDICSZ==!<LDILCL-LDIFCL>/2
	LDB'TYPE  DEV,LINE
	.ENDM

;Define interface dependent part for type A interface

.IF DF LIALNS
	.MACRO	LDBA  DEV,LINE
.IF NDF LIALDB
  LIALDB==!L'DEV'.'LINE
.ENDC
W  LDIARS,$$$R;			;Device receiver control status register
W  LDIARB,$$$R+2;		;Device receiver data buffer
W  LDIAPR,$$$R+2;		;Device parameter control status register
W  LDIAXS,$$$R+4;		;Device transmitter control status register
W  LDIAXB,$$$R+6;		;Device transmitter data buffer
W  LDIAPL,$$$P*40		;Interrupt priority level
W  LDIAVC,$$$VC			;Interrupt vector
;W  LDIA1P,L'DEV'.'LINE+LDIA2P	;First buffer points to second buffer
;M  LDIA1B,128.			;128.BYTE INPUT BUFFER, MUST FOLLOW LDIA1P
;W  LDIA2P,L'DEV'.'LINE+LDIA1P	;Second buffer points to first buffer
;M  LDIA2B,128.			;128.BYTE INPUT BUFFER, MUST FOLLOW LDIA2P
L  LDIAFC;			;First location to clear on startup
;W  LDIM12,0;			;INPUT BUFFER INDICATOR FOR MAIN LOOP
W  LDIASC,0;			;Shift count for input byte synchronization
W  LDIAIS,0;			;Input state
W  LDIAOS,0;			;Output state
W  LDIAIB,0;			;Input high byte of word
B  LDIAOB,0;			;Output low byte of word
B  LDIAIC,0;			;Input word count
B  LDIAOC,0;			;Output word count
B  LDIAIX,0;			;Input word left-over bit storage
B  LDIAHD,0;			;Protocol switch flag, SYNC=0, HDLC=-1
B  LDIATH,0;			;Protocol switch timer, used for ATC
				; while detecting reset pattern
L  LDIALC;			;Last location + 2 to clear on startup
LDIACZ==!<LDIALC-LDIAFC+1>/2
	.ENDM
.ENDC		;.IF DF LIALNS

;Define interface dependent part for type B interface

.IF DF LIBLNS
	.MACRO	LDBB  DEV,LINE
.IF NDF LIBLDB
  LIBLDB==!L'DEV'.'LINE
.ENDC
W  LDIBRS,$$$R;			;Device receiver function register
W  LDIBRB,$$$R+2;		;Device receiver data buffer
W  LDIBXS,$$$R+10;		;Device transmitter function register
W  LDIBXB,$$$R+12;		;Device transmitter data buffer
W  LDIBPL,$$$P*40		;Interrupt priority level
W  LDIBFN,$$$PN*$BIT08;		;Function byte (low) and DCP port number (hi)
W  LDIBVC,$$$VC			;Interrupt vector for DCP port
L  LDIBFC;			;First location to clear on startup
;L  LDIAFG;			;Label for flag word (used by LKHPK2)
W  LDIBEC,0			;Error count - DCP device error
W  LDIBLK,0			;Interrupt code lock, 0 = locked, 2 = unlocked
W  LDIBIS,0;			;Input state
W  LDIBOS,0;			;Output state
W  LDIBIB,0;			;Input high byte of word
B  LDIBOB,0;			;Output low byte of word
B  LDIBIC,0;			;Input word count
B  LDIBOC,0;			;Output word count
B  LDIBIX,0;			;Input word left-over bit storage
L  LDIBLC;			;Last location + 2 to clear on startup
LDIBCZ==!<LDIBLC-LDIBFC+1>/2
	.ENDM
.ENDC		;.IF DF LIBLNS
.ENDC		;.IF DF LKINUM
	.PAGE
	.SBTTL	ASYNC INTERFACE DATA BLOCKS (ADB'S)

;DEFINE MACRO USED TO GENERATE COMMON PART OF EACH ADB

	.MACRO	XADB  UNIT,TYPE
	.PSECT	ADB,RW,D,LCL,REL,CON
	.MACRO	RESTOR
	.PSECT	ADB,RW,D,LCL,REL,CON
	.ENDM
	.EVEN
OS=!0
ADB'UNIT'$::
A'UNIT'$'TYPE=!ADB'UNIT'$
.IF NDF AS'TYPE'ADB
  AS'TYPE'ADB==!ADB'UNIT'$
.ENDC
W  ADOUTP,AS'TYPE'OUT#		;ADDRESS OF OUTPUT SUBROUTINE
W  ADFUNC,AS'TYPE'FNC#		;ADDRESS OF FUNCTION SUBROUTINE
W  ADINIT,AS'TYPE'INT#		;ADDRESS OF INITIALIZE SUBROUTINE
W  ADINDX,$$$X*400		;LINE INDEX FOR FIRST LINE ON UNIT (POSITIONED
				;  FOR THE TERMINAL SERVICE INTERRUPT RING)
	.IRP	UNTX,<\UNIT+1>
.IF DF A'UNTX'$'TYPE
  $$$=!A'UNTX'$'TYPE
.IFF
  $$$=!0
.ENDC
W  ADNEXT,$$$;			;ADDRESS OF ADB FOR NEXT INTERFACE OF SAME
	.ENDM			;  TYPE
B  ADSTS1,$$$AS;		;STATUS BYTE
B  ADMAXI,$$$M;			;HIGHEST VALID INDEX FOR UNIT + 1
	ADB'TYPE  UNIT
	.ENDM

;DEFINE INTERFACE DEPENDENT PART FOR TYPE A INTERFACE (DL11/DLV11)

.IF DF TRANUM
	.MACRO	ADBA  UNIT
W  ADARSR,$$$R;			;ADDRESS OF RECEIVE STATUS REGISTER
W  ADARBF,$$$R+2;		;ADDRESS OF RECEIVE BUFFER
W  ADAXSR,$$$R+4;		;ADDRESS OF XMIT STATUS REGISTER
W  ADAXBF,$$$R+6;		;ADDRESS OF XMIT BUFFER
	.ENDM
.ENDC

;DEFINE INTERFACE DEPENDENT PART FOR TYPE B INTERFACE (DZ11/DZV11)

.IF DF TRBNUM
	.MACRO	ADBB  UNIT
W  ADBCSR,$$$R;			;ADDRESS OF CONTROL AND STATUS REGISTER (R/W)
L  ADBRBF			;ADDRESS OF RECEIVE BUFFER (RO)
W  ADBLPR,$$$R+2;		;ADDRESS OF LINE PARAMETER REGISTER (WO)
W  ADBTCR,$$$R+4;		;ADDRESS OF XMIT CONTROL REGISTER (R/W)
L  ADBMSR			;ADDRESS OF MODEM STATUS REGISTER (RO)
W  ADBTDR,$$$R+6;		;ADDRESS OF XMIT DATA REGISTER (WO)
W  ADBBRK,$$$R+7;		;ADDRESS OF BREAK REGISTER (WO)
B  ADBBRB,0;			;CURRENT BREAK BITS
BX        0
W  ADBMSB,0;			;CURRENT MODEM STATUS BITS
M  ADBFLG,8.;			;Output available flag byte
M  ADBBFR,8.;			;Output character buffer
	.ENDM
.ENDC

;DEFINE INTERFACE DEPENDENT PART FOR TYPE C INTERFACE (DH11)

.IF DF TRCNUM
	.MACRO	ADBC  UNIT
W  ADCSCR,$$$R;			;ADDRESS OF SYSTEM CONTROL REGISTER
W  ADCRCR,$$$R+2;		;ADDRESS OF RECEIVED CHARACTER REGISTER
W  ADCLPR,$$$R+4;		;ADDRESS OF LINE PARAMETER REGISTER
W  ADCCAR,$$$R+6;		;ADDRESS OF CURRENT ADDRESS REGISTER
W  ADCBCR,$$$R+10;		;ADDRESS OF BYTE COUNT REGISTER
W  ADCBAR,$$$R+12;		;ADDRESS OF BUFFER ACTIVE REGISTER
W  ADCBKR,$$$R+14;		;ADDRESS OF BREAK CONTROL REGISTER
W  ADCSSR,$$$R+16;		;ADDRESS OF SILO STATUS REGISTER
W  ADCCSR,$$$E;			;ADDRESS OF DATA SET CONTROL AND STATUS
				;  REGISTER (CSR)
W  ADCLSR,$$$E+2;		;ADDRESS OF DATA SET LINE STATUS REGISTER (LSR)
W  ADCBAX,0			;SOFTWARE LINE ENABLE BITS
W  ADCBRB,0;			;CURRENT BREAK BITS
W  ADCMSB,0;			;CURRENT MODEM STATUS BITS
	.ENDM
.ENDC

;DEFINE INTERFACE DEPENDENT PART FOR TYPE D INTERFACE (INFOTRON SUPER-MUX)

.IF DF TRDNUM
	.MACRO	ADBD  UNIT
W  ADDRS,$$$R;			;RECEIVER STATUS
W  ADDRB,$$$R+2;		;RECEIVER BUFFER
W  ADDPR,$$$R+2;		;PARAMETER REGISTER
W  ADDTS,$$$R+4;		;TRANSMITTER STATUS
W  ADDTB,$$$R+6;		;TRANSMITTER BUFFER
W  ADDLNX,$$$X;			;line index on mux
W  ADDIMB,ADIMSX+ADB'UNIT'$;	;POINTER TO THE BEGINNING OF BUFFER
W  ADDIME,ADIMEX+ADB'UNIT'$;	;POINTER TO THE END OF THE BUFFER
W  ADDPSL,$$$L*40;		;THE INTERRUPT LEVEL OF THIS ADB'S HANDLER
W  ADDOSR,A'UNIT'OI;		;THE OUTPUT SERVICE ROUTINE ADDRESS
W  ADDPRB,ADDBUG+ADB'UNIT'$	;**DEBUG**
W  ADDPRE,ADDDBE+ADB'UNIT'$	;**DEBUG**
L  ADDFTC;			;THE FIRST LOCATION TO CLEAR ON STARTUP
W  ADDABT,0;			;THE ABORT MESSAGE COUNTER
W  ADDBLN,0;			;Bad line number from supermux
W  ADDLPA,0;			;Local packet address
W  ADDCDN,0;			;COUNT DOWN OF CHARACTERS LEFT
W  ADDCRI,0;			;The input CRC
W  ADDCRO,0;			;The output CRC
W  ADDCLC,0;			;CURRENT LINE COUNT (MARKER MESSAGE)
W  ADDCLN,0;			;CURRENT LINE NUMBER OF INFOTRON MUX
W  ADDCPK,0;			;CURRENT PACKET NUMBER
W  ADDCRC,0;			;CRC ERROR COUNTER
W  ADDCTT,0;			;CHARACTER COUNT, TOTAL
W  ADDFLG,0;			;ADB FLAG WORD
W  ADDTCL,0;			;The transmit clock loss counter
W  ADDRCL,0;			;The receive clock loss counter
W  ADDFPK,0;			;FIRST PACKET IN CHAIN
W  ADDFCP,0;			;First control packet
W  ADDGLP,0;			;GARBAGE PACKET COUNTER
W  ADDHLE,0;			;HIGH SPEED LINE ERROR COUNTER
W  ADDIBO,0;			;INPUT BUFFER OVERFLOW COUNTER
W  ADDIMI,0;			;BUFFER IN POINTER
W  ADDIMO,0;			;BUFFER OUT POINTER
W  ADDIP,0;			;IN POINTER
W  ADDOP,0;			;OUT POINTER
W  ADDIST,0;			;INPUT STATE
W  ADDOST,0;			;OUTPUT STATE
W  ADDIC1,0;			;The first input character
W  ADDIC2,0;			;The second input character
W  ADDTBL,0;			;Table pointer into P and R tables
W  ADDCCT,0;			;LOCAL CHARACTER COUNTER (MAIN)
W  ADDMRK,0;			;THE MARKER MESSAGE (MAIN)
W  ADDNFG,0;			;THE NAK MESSAGE FLAGS
W  ADDOC,0;			;OUTPUT COUNT
W  ADDOVR,0;			;OVERRUN ERROR COUNTER
W  ADDPIP,0;			;PACKET IN PROGRESS POINTER
W  ADDPKI,0;			;PACKET IN POINTER
W  ADDOPP,0;			;(Output interrupt) packet pointer
W  ADDOTP,0;			;Output tail pointer (Linked list)
W  ADDOHP,0;			;Output head pointer (Linked list)
W  ADDATP,0;			;Output ack tail pointer (Linked list)
W  ADDAHP,0;			;Output ack head pointer (Linked list)
W  ADDPTU,0;			;Number of packets we can use
W  ADDPHE,0;			;Number of phase errors we have had
W  ADDLBA,0;			;Local buffer address (Pseudo 12k buffer)
W  ADDPPT,0;			;(MAIN) PACKET POINTER
W  ADDRBA,0;			;REMOTE BUFFER ADDRESS
W  ADDPTZ,0;			;PACKET TO ZAP
W  ADDTCT,0;			;TOTAL CHARACTER COUNT
W  ADDLCT,0;			;Local count of characters in current packet
B  ADDTSY,0;			;"Sync loss" timer byte
BX        0
W  ADDPRI,0;			;**DEBUG**
M  ADDBUG,20*2;			;**DEBUG**
L  ADDDBE;			;**DEBUG**
M  ADIMSX,40.*2;		;CIRCULAR BUFFER FOR INTERRUPT SERVICE
L  ADIMEX;			;LAST WORD OF BUFFER + 2
L  ADDLTC;			;LAST WORD TO CLEAR ON STARTUP + 2
	.ENDM
.ENDC
	.PAGE
;DEFINE INTERFACE DEPENDENT PART FOR TYPE E INTERFACE (INFOTRON SUPER-MUX)

.IF DF TRENUM
	.MACRO	ADBE  UNIT
W  ADERS,$$$R;			;RECEIVER STATUS
W  ADERB,$$$R+2;		;RECEIVER BUFFER
W  ADEPR,$$$R+2;		;PARAMETER REGISTER
W  ADETS,$$$R+4;		;TRANSMITTER STATUS
W  ADETB,$$$R+6;		;TRANSMITTER BUFFER
W  ADELNX,$$$X;			;line index on mux
W  ADEIMB,ADESIM+ADB'UNIT'$;	;POINTER TO THE BEGINNING OF BUFFER
W  ADEIME,ADEEIM+ADB'UNIT'$;	;POINTER TO THE END OF THE BUFFER
W  ADEPSL,$$$L*40;		;THE INTERRUPT LEVEL OF THIS ADB'S HANDLER
W  ADEOSR,A'UNIT'OI;		;THE OUTPUT SERVICE ROUTINE ADERESS
W  ADEPRB,ADEBUG+ADB'UNIT'$	;**DEBUG**
W  ADEPRE,ADEDBE+ADB'UNIT'$	;**DEBUG**
L  ADEFTC;			;THE FIRST LOCATION TO CLEAR ON STARTUP
W  ADEABT,0;			;THE ABORT MESSAGE COUNTER
W  ADEBLN,0;			;Bad line number from supermux
W  ADELPA,0;			;Local packet ADEress
W  ADECDN,0;			;COUNT DOWN OF CHARACTERS LEFT
W  ADECLC,0;			;CURRENT LINE COUNT (MARKER MESSAGE)
W  ADECLN,0;			;CURRENT LINE NUMBER OF INFOTRON MUX
W  ADECPK,0;			;CURRENT PACKET NUMBER
W  ADECRC,0;			;CRC ERROR COUNTER
W  ADECTT,0;			;CHARACTER COUNT, TOTAL
W  ADEFLG,0;			;ADB FLAG WORD
W  ADETCL,0;			;The transmit clock loss counter
W  ADERCL,0;			;The receive clock loss counter
W  ADEFPK,0;			;FIRST PACKET IN CHAIN
W  ADEFCP,0;			;First control packet
W  ADEGLP,0;			;GARBAGE PACKET COUNTER
W  ADEHLE,0;			;HIGH SPEED LINE ERROR COUNTER
W  ADEIBO,0;			;INPUT BUFFER OVERFLOW COUNTER
W  ADEIMI,0;			;BUFFER IN POINTER
W  ADEIMO,0;			;BUFFER OUT POINTER
W  ADEIP,0;			;IN POINTER
W  ADEOP,0;			;OUT POINTER
W  ADEIST,0;			;INPUT STATE
W  ADEOST,0;			;OUTPUT STATE
W  ADETBL,0;			;Table pointer into P and R tables
W  ADECCT,0;			;LOCAL CHARACTER COUNTER (MAIN)
W  ADEMRK,0;			;THE MARKER MESSAGE (MAIN)
W  ADENFG,0;			;THE NAK MESSAGE FLAGS
W  ADEOC,0;			;OUTPUT COUNT
W  ADEOVR,0;			;OVERRUN ERROR COUNTER
W  ADEPIP,0;			;PACKET IN PROGRESS POINTER
W  ADEPKI,0;			;PACKET IN POINTER
W  ADEOPP,0;			;(Output interrupt) packet pointer
W  ADEOTP,0;			;Output tail pointer (Linked list)
W  ADEOHP,0;			;Output head pointer (Linked list)
W  ADEATP,0;			;Output ack tail pointer (Linked list)
W  ADEAHP,0;			;Output ack head pointer (Linked list)
W  ADEPTU,0;			;Number of packets we can use
W  ADEPHE,0;			;Number of phase errors we have had
W  ADELBA,0;			;Local buffer ADEress (Pseudo 12k buffer)
W  ADEPPT,0;			;(MAIN) PACKET POINTER
W  ADERBA,0;			;REMOTE BUFFER ADERESS
W  ADEPTZ,0;			;PACKET TO ZAP
W  ADETCT,0;			;TOTAL CHARACTER COUNT
W  ADELCT,0;			;Local count of characters in current packet
B  ADETSY,0;			;"Sync loss" timer byte
BX        0
W  ADEPRI,0;			;**DEBUG**
M  ADEBUG,20*2;			;**DEBUG**
L  ADEDBE;			;**DEBUG**
M  ADESIM,40.*2;		;CIRCULAR BUFFER FOR INTERRUPT SERVICE
L  ADEEIM;			;LAST WORD OF BUFFER + 2
L  ADELTC;			;LAST WORD TO CLEAR ON STARTUP + 2
	.ENDM
.ENDC

;Define interface dependent part for type F interface (Nexilis 8086 IO
;  processor)

.IF DF TRFNUM
	.MACRO	ADBF  UNIT
W  ADFRFR,$$$R			;Receive function register
W  ADFRDR,$$$R+2		;Receive data register
W  ADFXFR,$$$R+10		;Xmit function register
W  ADFXDR,$$$R+12		;Xmit data register
W  ADFXDA,$$$R+14		;Xmit DMA address register
W  ADFVEC,$$$VC			;Address of vector
	.ENDM
.ENDC

;DEFINE INTERFACE DEPENDENT PART FOR TYPE G INTERFACE (SCC)

.IF DF TRGNUM
	.MACRO	ADBG  UNIT
W  ADGRCV,$$$R;			;ADDRESS OF RECEIVE DATA BUFFER
W  ADGXMT,$$$R+2		;ADRESS OF TRANSMIT DATA REGISTER
W  ADGSTA,$$$R+4;		;ADDRESS OF STATUS REGISTER
W  ADGCON,$$$R+6;		;ADDRESS OF CONTROL
B  ADGVEC,$$$VC			;INTERRUPT VECTOR BASE
  .IF	EQ	<$$$R&10>
B  ADGEST,20			;CHANNEL A TX IP BIT
  .IFF
B  ADGEST,2			;CHANNEL B TX IP BIT
  .ENDC
W  ADGST0,0;			;Status word
B  ADGMSB,0			;MODEM STATUS BITS
B  ADGWR3,0			;SAVE BYTE FOR WR3
B  ADGWR4,0			;SAVE BYTE FOR WR4
B  ADGWR5,0			;WRITE REGISTER SAVE BYTE
	.ENDM
.ENDC

	.PAGE
	.SBTTL	SOCKET DATA BLOCKS (SDB'S)

;DEFINE MACRO FOR GENERATING EACH SOCKET DATA BLOCK

	.MACRO	XSDB  DV,DX,DEV,SOC,TYPE
NUMSOC=!NUMSOC+1

.IF NE SOC
	.PSECT	SX,RW,D,LCL,REL,CON
  .IF EQ SOC-1
    .IF DF DX'DEV'$0
	.WORD	DX'DEV'$0
    .IFF
	.WORD	0
    .ENDC
    DX'DEV'SX::
  .ENDC
  .IF EQ .PASS2
    .IF IDN <LK>,<DV>
      MXLKSX==!.
    .ENDC
  .ENDC
	.WORD	DX'DEV'$'SOC
.ENDC

	.PSECT	SDB,RW,D,LCL,REL,CON
	.MACRO	RESTOR
	.PSECT	SDB,RW,D,LCL,REL,CON
	.ENDM
	.EVEN
OS=!0
DX'DEV'$'SOC::
W  SDLINK,0			;Address of linked SDB
B  SDPMAX,0			;Maximum number of packets which may be
				;  buffered for this socket
B  SDSOC ,SOC			;Socket number on device
.IF	DF	DX'DEV'$
W  SDDDB ,DX'DEV'$		;Address of DDB for device
.IFF
W  SDDDB ,00			;If a dummy SDB is defined for node w/o terminal
.ENDC
W  SDDBUG,0			;Debug or trace data
L  SDCBGN			;First word to clear on startup
W  SDSTS1,0			;Device status word
W  SDPKDH,0			;Head pointer for packet destionation list
W  SDPKDT,0			;Tail pointer for packet destination list
W  SDPKCP,0			;Pointer to current packet (from DST list)
W  SDPKSP,0			;Pointer to packet SRC list
B  SDPCNT,0			;Number of packets which are buffered for
				;  this socket **** MUST BE EVEN BYTE! ****
B  SDXCNT,0			;Excess packet count (packets buffered for this
				;  SDB but included in SDPCNT for the linked
				;  SDB)
B  SDSDID,0			;device I.D. for linked DEVICE
B  SDSDSC,0			;Socket number for linked device
W  SDREQL,0			;Request link word
B  SDREQB,0			;Request bits
B  SDRSMC,0			;Resume count
L  SDCEND			;Last word to clear on startup + 2
SDCSIZ==!<SDCEND-SDCBGN>/2
	SDB'DV	DEV,SOC,TYPE
	.PSECT	INIDAT,RW,D,LCL,REL,CON
$'DEV'DX'$'SOC:
	RESTOR

	.ENDM
NUMSOC=!0

;DEFINE MACROS FOR GENERATING THE DEVICE DEPENDENT PARTS OF THE SDB'S

;STATUS DEVICE DEVICE DEPENDENT PART

	.MACRO	SDBST  DEV,SOC,TYPE
L  SDSTFC			;FIRST WORD TO CLEAR ON STARTUP
W  SDSTSS,0			;STATUS WORD
W  SDSTID,0			;Input dispatch address
B  SDSTCC,0			;Command character
B  SDSTPL,0			;Priviledge level of connected device
B  SDSTSC,0			;Place to save character on failure return from
				;  PUTCHR
B  SDSTD5,0		;---KS601,PADMGR USES

;BX        0
W  SDSTR1,0			;LEVEL 1 SUBROUTINE RETURN ADDRESS
W  SDSTSR,0			;Return address for failure return from PUTCHR
W  SDSTD1,0			;Data word 1
W  SDSTD2,0			;Data word 2
W  SDSTD3,0			;Data word 3
W  SDSTD4,0			;Data word 4
W  SDSTD6			;DATA WORD 6
W  SDSTD7			;DATA WORD 7
W  SDSTD8			;DATA WORD 8
W  SDSTD9			;DATA WORD 9
W  SDSTDA			;DATA WORD 10
W  SDSTDB			;DATA WORD 11

W  SDSTS3,0			;Place to save R3


W  SDSTTA,0			;Watching address of T-command
W  SDSTTK,0			;No. ticks of T-command
W  SDSTTC,0			;event count, means how many mart-time 
				;	elapsed before data is changed
				;=0, initially
W  SDSTTV,0			;saved @SDSTTA(SD), so we can output
				;	only when data is changed

L  SDSTCF			;FIRST WORD TO CLEAR AT COMMAND END
B  SDSTVP,0			;Value pointer
B  SDSTER,0			;Error code
W  SDSTV1,0			;First argument value
W  SDSTV2,0			;Second argument value
W  SDSTV3,0			;Third argument value
L  SDSTLC			;LAST WORD TO CLEAR ON STARTUP OR COMMAND
				;  END + 2
SDSTCZ==!<SDSTLC-SDSTFC+1>/2
SDSTCY==!<SDSTLC-SDSTCF+1>/2
	.ENDM

;TERMINAL DEVICE DEPENDENT PART

; .IF NE TR.NUM			;Define the following offset even if no terminal
	.MACRO	SDBTR  DEV,SOC,TYPE
W  SDTRS0,$$$S;			;"PURE" STATUS WORD 0
W  SDTRBR,$$$B;			;DEFAULT BAUD RATES
B  SDTRTT,$$$T;			;DEFAULT TERMINAL TYPE FOR TERMINAL
.IF EQ ..SAT
  B  SDTRPC,$$$CL;		;PRIV. CLASS
  B  SDTRCX,$$$C;		;COMMAND DECODER INDEX
  B  SDTRTP,$$$P;		;DEFAULT TERMINAL PROFILE FOR TERMINAL
.IFF
  B  SDTRXC,0;			;TRANSLATION CODE
.ENDC
.IF	DF	$$$ADB
W  SDTRAD,$$$ADB;		;ADDRESS DDB FOR ASYNC INTERFACE
.IFF
W  SDTRAD,00
.ENDC
L  SDTRFC			;FIRST TO CLEAR ON STARTUP
W  SDTRIP,0			;Packet pointer for input hold list
W  SDTRCP,0			;Packet pointer for command input list
W  SDTROD,0			;OUTPUT READY DISPATCH ADDRESS
W  SDTRS1,0			;IMPURE STATUS WORD 1
W  SDTRS2,0			;IMPURE STATUS WORD 2
W  SDTRS3,0			;IMPURE STATUS WORD 3
W  SDTRS4,0			;IMPURE STATUS WORD 4
W  SDTRS5,0			;IMPURE STATUS WORD 5
W  SDTRS6,0			;IMPURE STATUS WORD 6
B  SDTROS,0			;OUTPUT STATE
B  SDTRBS,0			;Active break character set bits
B  SDTRIL,0			;Input buffer limit value
B  SDTRIC,0			;Input buffer character count

.IF EQ ..SAT
  L  SDTRLP			;WARNING *** The following 11. bytes must be
				;  in the same order as the entries in the
				;  PRFPNT table in TRMT!!
  B  SDTRBX,0			;Current break character set bits
  B  SDTRIT,0			;Idle timer initial value (X.3 parameter)
  B  SDTRPB,0			;Procedure on break (X.3 parameter)
  B  SDTRDL,0			;Delete character
  L  SDTRSL			;Start of list of special echo characters
  B  SDTRLX,0			;Line delete character
  B  SDTRSO,0			;Suppress output character
  B  SDTRRE,0			;Line retype character
  B  SDTRHI,0			;Hard interrupt character
  B  SDTRSI,0			;Soft interrupt character
  B  SDTRCI,0			;Command interrupt character
  B  SDTRSR,0			;Status request character
  L  SDTRSE			;Last of special echo characters + 1
  B  SDTREC,0;			;Error counter
  B  SDTRT6,0			;Idle time down counter
  BX	    0			;Filler
  SDTRSN==!SDTRSE-SDTRSL
.ENDC

L  SDTRLT			;WARNING *** The following 10 bytes must be
				;  in the same order as the entries in the
				;  TYPPNT table in TRMT!!
B  SDTRCD,0			;Fixed carriage return delay constant
B  SDTRCV,0			;Variable carriage return delay constant
B  SDTRCM,0			;Min/max carriage return delay constant
B  SDTRHD,0			;Horizontal tab delay constant
B  SDTRBD,0			;Backspace delay constant
B  SDTRLD,0			;Line feed delay constant
B  SDTRVD,0			;Vertical tab delay constant
B  SDTRFD,0			;Fixed form feed delay constant
.IF EQ  ..SAT
  B  SDTRFV,0			;Variable form feed delay constant
  B  SDTRLW,0			;Line width
.IFF
  B  SDTREC,0			;Error count for TYMNET command decoder
  B  SDTRHP,0			;Horizontal position on line
.ENDC
B  SDTRCL,0;			;COUNT OF CHARACTERS PER LINE
BX        0
B  SDTRSC,0			;2nd level saved character
B  SDTRFP,0			;2nd level filler pointer
B  SDTRSX,0			;1st level saved character
B  SDTRFX,0			;1st level filler pointer
B  SDTRDY,0			;Delay count
B  SDTRBL,0			;Number of bells to output
.IF EQ ..SAT
  B  SDTRVT,0			;Vertical tab spacing
  B  SDTRPG,0			;Page size
  B  SDTRHP,0			;Current horizontal position on line
  B  SDTRVP,0			;Current vertical position on page
  B  SDTRES,0			;Input ESC sequence processing state
  B  SDTRXC,0			;Translation code
.ENDC
B  SDTRCT,0			;Current terminal type
B  SDTRCS,0			;Carrier State
W  SDTRC1,0			;Command decoder data word 1
W  SDTRC2,0			;Command decoder data word 2
W  SDTRC3,0			;Command decoder data word 3
W  SDTRC4,0			;Command decoder data word 4
W  SDTRC5,0			;Command decoder data word 5
W  SDTR18		;TERMINAL UP-TIME---KS601
WX 0		;USED IN PADMGR AS COMMAND, 4 BYTES
W  SDTR19	;NUMBER OF TIMES OF TERMINAL SESSIONS SINCE NODE IS UP

L  SDTRLC			;Last word to clear on startup + 2
SDTRCZ==!<SDTRLC-SDTRFC+1>/2
.IF DF PVC'SOC
W  SDTPVC,PVC'SOC               ;ADDRESS OF PVC STRING
.IFF
W  SDTPVC,0			;, OR NULL (0).
.ENDC
	SDBTR'TYPE  SOC
	.ENDM

;INTERFACE DEPENDENT PARTS OF THE TERMINAL SDB'S

;TYPE A INTERFACE - DL11/DLV11

; .IF DF TRANUM		;Get the following macro defined even if no terminal
	.MACRO	SDBTRA	DEV,SOC
W  SDTXAP,0;			;Output packet pointer
	.ENDM
; .ENDC

;TYPE B INTERFACE - DZ11/DZV11

.IF DF TRBNUM
	.MACRO	SDBTRB	DEV,SOC
B  SDTRXA,$$$LN;		;INDEX ON INTERFACE
BX        0
W  SDTXBP,0;			;Output packet pointer
	.ENDM
.ENDC

;TYPE C INTERFACE - DH11

.IF DF TRCNUM
	.MACRO	SDBTRC	DEV,SOC
B  SDTRXA,$$$LN;		;INDEX ON INTERFACE
B  SDTRCC,0			;CURRENT OUTPUT CHARACTER BUFFER
W  SDTXCP,0;			;Output packet pointer
	.ENDM
.ENDC

;TYPE D INTERFACE - INFOTRON SUPER MUX

.IF DF TRDNUM
	.MACRO	SDBTRD	DEV,SOC
B  SDDLIN,$$$LN;		;The line number of this port
B  SDDCHR,0;			;Where to save the held character
L  SDDFTC;			;FIRST LOCATION TO CLEAR
W  SDDBTW,0;			;BIT WORD FOR MARKER MESSAGES
W  SDDCCT,0;			;COUNT LEFT TO DO
W  SDDCPP,0;			;CURRENT POINTER IN PACKET
W  SDDFLG,0;			;SDB FLAG WORD
W  SDDMOP,0;			;MARKER MESSAGE POINTER
W  SDDPAD,0;			;PACKET ADDRESS
W  SDDPCT,0;			;PACKET CHARACTER COUNT
W  SDDUT1,0;			;TIMER FOR OUTGOING CHARACTERS (LOW ORDER)
W  SDDUT2,0;			;"			"      (HIGH ORDER)
L  SDDLTC;			;LAST TO CLEAR + 2
	.ENDM
.ENDC
;TYPE E INTERFACE - INFOTRON SUPER MUX

.IF DF TRENUM
	.MACRO	SDBTRE	DEV,SOC
B  SDELIN,$$$LN;		;The line number of this port
B  SDECHR,0;			;Where to save the held character
L  SDEFTC;			;FIRST LOCATION TO CLEAR
W  SDEBTW,0;			;BIT WORD FOR MARKER MESSAGES
W  SDECCT,0;			;COUNT LEFT TO DO
W  SDECPP,0;			;CURRENT POINTER IN PACKET
W  SDEFLG,0;			;SDB FLAG WORD
W  SDEMOP,0;			;MARKER MESSAGE POINTER
W  SDEPAD,0;			;PACKET ADDRESS
W  SDEPCT,0;			;PACKET CHARACTER COUNT
W  SDEUT1,0;			;TIMER FOR OUTGOING CHARACTERS (LOW ORDER)
W  SDEUT2,0;			;"			"      (HIGH ORDER)
L  SDELTC;			;LAST TO CLEAR + 2
	.ENDM
.ENDC

.IF DF TRFNUM
	.MACRO	SDBTRF  DEV,SOC
B  SDTRXA,$$$LN;		;Index on interface
BX        0
W  SDTXFP,0;			;Current packet pointer
	.ENDM
.ENDC

.IF DF TRGNUM
	.MACRO	SDBTRG  DEV,SOC
W  SDTXGP,0;			;Output packet pointer
	.ENDM
.ENDC
; .ENDC				; See .IF NE TR.NUM severval pages back.

;OTHER TERMINAL DEVICES DEVICE DEPENDENT PARTS

.IF DF TX.NUM
	.MACRO	SDBTX  DEV,SOC,TYPE
	.ENDM
.ENDC

.IF DF TY.NUM
	.MACRO	SDBTY  DEV,SOC,TYPE
	.ENDM
.ENDC

.IF DF TZ.NUM
	.MACRO	SDBTZ  DEV,SOC,TYPE
	.ENDM
.ENDC

;LINE PRINTER DEVICE DEPENDENT PART

.IF DF LP.NUM
	.MACRO	SDBLP	DEV,SOC,TYPE
	SDBLP'TYPE  SOC,DEV
	.ENDM

;LINE PRINTER SOCKET DEPENDENT PART - DRIVER TYPE A

.IF DF LPANUM
	.MACRO	SDBLPA  DEV,SOC,TYPE
W  SDPAER,$$$E;			; Device error status register
W  SDPAOR,$$$R;			; Device output status register
W  SDPAOB,$$$R+2;		; Device output buffer
L  SDPAFC			; First word to clear at startup
W  SDPASR,0			; Socket status register
W  SDPASI,0			; Spurious interrupt counter
W  SDPAHZ,0			; Horizontal carriage position
W  SDPASP,0			; Pending spaces for tab simulation
L  SDPALC			; Last word to clear + 2
SDPACZ==!<SDPALC-SDPAFC+1>/2
	.ENDM
.ENDC

;LINE PRINTER DRIVER DEPENDENT PART - DRIVER TYPE B

.IF DF LPBNUM
	.MACRO	SDBLPB  DEV,SOC,TYPE
	.ENDM
.ENDC
.ENDC			;.IF DF LP.NUM

;CARD READER DEVICE DEPENDENT PART

.IF DF CR.NUM
	.MACRO	SDBCR	DEV,SOC,TYPE
	.ENDM
.ENDC

;MAGNETIC TAPE DEVICE DEPENDENT PART

.IF DF MT.NUM
	.MACRO	SDBMT	DEV,SOC,TYPE
	.ENDM
.ENDC

;FLOPPY DISK DEVICE DEPENDENT PART

.IF DF FD.NUM
	.MACRO	SDBFD	DEV,SOC,TYPE
	.ENDM
.ENDC

;LOAD DEVICE DEVICE DEPENDENT PART

.IF DF WD.NUM
	.MACRO	SDBWD	DEV,SOC,TYPE
L  SDWDFC
W  SDWDLK,0			;ADDRESS OF DDB FOR LINK BEING USED
W  SDWDPP,0			;POINTER TO DATA PACKET
W  SDWDTO,0			;THE 1 MINUTE TIMER LOCATION
W  SDWDFG,0			;STATUS FLAG WORD
W  SDWDDP,0			;POINTER TO DATA BYTE
W  SDWDBC,0			;BYTE COUNT
W  SDWDSA,0			;STATE
W  SDWDN1,0			;FIRST HALF OF NAME OF NODE BEING LOADED
W  SDWDN2,0			;SECOND HALF OF NAME OF NODE BEING LOADED
L  SDWDLC
SDWDCZ==!<SDWDLC-SDWDFC+1>/2
	.ENDM
.ENDC

;LINK DEVICE DEPENDENT PART

.IF NE LK.NUM
	.MACRO	SDBLK	DEV,SOC,TYPE
L  SDLKFC			;FIRST WORD TO CLEAR ON STARTUP
W  SDLKLK,0			;SOCKET SEND LIST LINK WORD
W  SDLKFL,0			;SOCKET FLAG LIST LINK WORD
B  SDACNT,0			;SEND-AHEAD COUNT **** MUST BE EVEN BYTE! ****
B  SDLKLV,0			;LINK PRIORITY LEVEL *** MUST FOLLOW SDACNT -
				;  SOME ROUTINES REFERENCE SDACNT AS A WORD AND
				;  EXPECT THIS BYTE TO BE THE HIGH ORDER
				;  HALF!! ***
B  SDFCNT,0			;FLAG COUNT **** MUST BE EVEN BYTE! ****
B  SDLKXX,0			;DUMMY (THIS BYTE IS USED BY SOME OF THE LINK
				;  TYPE DEPENDENT ROUTINES)
L  SDLKLC			;LAST WORD TO CLEAR ON STARTUP + 2
SDLKCZ==!<SDLKLC-SDLKFC+1>/2
	SDBLK'TYPE  DEV,SOC
	.ENDM

;LINK TYPE DEPENDENT PARTS

;LINK TYPE B

.IF DF LKBNUM
	.MACRO	SDBLKB  DEV,SOC
	.ENDM
.ENDC

;LINK TYPE C

.IF DF LKCNUM
	.MACRO	SDBLKC  DEV,SOC
	.ENDM
.ENDC

;LINK TYPE D

.IF DF LKDNUM
	.MACRO	SDBLKD  DEV,SOC
	.ENDM
.ENDC

;LINK TYPE E

.IF DF LKENUM
	.MACRO	SDBLKE	DEV,SOC
L  SDLEFC			; 1st word to clear on startup
W  SDLES1,0			; PACKET LEVEL IMPURE STATUS WORD
W  SDLESP,0			; SAVED DATA PACKET POINTER
W  SDLEBP,0			; ERROR COUNT - BAD X.25 PACKET TYPE
B  SDLEPR,0			; P(R) for logical channel
B  SDLEPS,0			; P(S) for logical channel
B  SDLEVR,0			; Saved P(R) from last numbered packet
B  SDLERR,0			; PENDING RR COUNT FOR CHANNEL
L  SDLELC			; Last word to clear on startup
SDLECZ==!<SDLELC-SDLEFC+1>/2
	.ENDM
.ENDC

;LINK TYPE F

.IF DF LKFNUM
	.MACRO	SDBLKF	DEV,SOC
L  SDLFFC			;FIRST LOCATION TO CLEAR ON START-UP
W  SDLFBI,0			;BLOCK MODE-TO HOST-COUNT
W  SDLFI0,0			;BLOCK MODE-TO HOST-ADDRESS-LOW ORDER PART
W  SDLFI1,0			;BLOCK MODE-TO HOST-ADDRESS-HIGH ORDER PART
W  SDLFXF,0			;BLOCK MODE-TO HOST-AMOUNT ACTUALLY INPUT
M  SDLFVH,4			;BLOCK MODE-TO HOST-INPUT HOLD BUFFER
B  SDLFVC,0			;BLOCK MODE-TO HOST-INPUT HOLD BUFFER COUNT
B  SDLFQN,0			;DIALOG NUMBER FOR CONNECTION PROTOCOL
W  SDLFBO,0			;BLOCK MODE-FROM HOST-COUNT
W  SDLFO0,0			;BLOCK MODE-FROM HOST-ADDRESS-LOW ORDER PART
W  SDLFO1,0			;BLOCK MODE-FROM HOST-ADDRESS-HIGH ORDER PART
W  SDLFBL,0			;BLOCK MODE-FROM HOST-LIST LINK WORD
W  SDLFRQ,0			;MESSAGE REQUEST BITS
W  SDLFS1,0			;HOST PORT STATUS REGISTER
W  SDLFAX,0			;PACKET POINTER FOR SUPERVISOR DIALOG
L  SDLFLC			;LAST LOCATION + 2 TO CLEAR ON START-UP
SDLFCZ==!<SDLFLC-SDLFFC+1>/2
	.ENDM
.ENDC

;LINK TYPE H

.IF DF LKHNUM
	.MACRO	SDBLKH	DEV,SOC
L  SDLHFC			;FIRST LOCATION TO CLEAR ON STARTUP
.IF EQ ..SAT			;DON'T NEED NEXT WORD IF SIMPLE TYMSAT
  W  SDLHSC,0			;ADDRESS OF SAVED CONNECT PACKET
.ENDC
W  SDLHLD,0			;ADDRESS OF LINKED LDB
B  SDLHCN,0			;CHANNEL NUMBER
B  SDLHSP,0			;CIRCUIT SPEED
W  SDLHS1,0			;IMPURE STATUS WORD 1
.IF DF LHTPC			;Only need these words if have terminal
				;  protocol conversion support
				;WARNING *** These entries must line up with the
				;  corresponding entries in the terminal (TR)
				;  SDB's!  There are exactly 8 words between
				;  the end of the common part of the SDB's and
				;  the start of this area!!
  W  SDLHT1,0			;* SDTRS1 *  Terminal status word 1
  W  SDLHT2,0			;* SDTRS2 *  Terminal status word 2
  W  SDLHT3,0			;* SDTRS3 *  Terminal status word 3
  W  SDLHT4,0			;* SDTRS4 *  Terminal status word 4
  W  SDLHT5,0			;* SDTRS5 *  Terminal status word 5
  B  SDLHLW,0			;* SDTRS6 *  Terminal line width
  B  SDLHHP,0			;* SDTRS6 *  Terminal current horizontal position
  B  SDLHES,0			;* SDTROS *  Input ESC processing state
  B  SDLHBS,0			;* SDTRBS *  Active break set
  B  SDLHIL,0			;* SDTRIL *  Input buffer limit value
  B  SDLHIC,0			;* SDTRIC *  Input buffer character count
  BX        0			;* SDTRBX *  Current break set (Not used here!)
  B  SDLHIT,0			;* SDTRIT *  Idle timer initial value
  B  SDLHPB,0			;* SDTRPB *  Procedure on break
  B  SDLHDL,0			;* SDTRDL *  Terminal delete character
  B  SDLHLX,0			;* SDTRLX *  Terminal line delete character
  B  SDLHSO,0			;* SDTRSO *  Terminal suppress output character
  B  SDLHRE,0			;* SDTRRE *  Terminal line retype character
  B  SDLHHI,0			;* SDTRHI *  Terminal hard interrupt character
  B  SDLHSI,0			;* SDTRSI *  Terminal soft interrupt character
  B  SDLHCI,0			;* SDTRCI *  Cmd interrupt char. (not used here)
  B  SDLHSR,0			;* SDTRSR *  Status request char.
				;End of entries which must match terminal
				;  service entries!!!
  B  SDLHT6,0			;* SDTRT6 *  Idle time down counter

.ENDC

W  SDLHS2,0			;IMPURE STATUS WORD 2

.IF DF LHBASE			;ONLY NEED THESE WORDS IF HAVE BASE SUPPORT
  W  SDLHVH,0			;HIGH ORDER PART OF INVOICE NUMBER
  W  SDLHVL,0			;LOW ORDER PART OF INVOICE NUMBER
  W  SDLHI2,0			;HIGH ORDER PART OF INPUT CHARACTER COUNT
  W  SDLHI1,0			;LOW ORDER PART OF INPUT CHARACTER COUNT
  W  SDLHO2,0			;HIGH ORDER PART OF OUTPUT CHARACTER COUNT
  W  SDLHO1,0			;LOW ORDER PART OF OUTPUT CHARACTER COUNT
  W  SDLHPC,0			;PLACE TO ACCUMULATE PROJECT CODE CHARACTERS
  B  SDLHBF,0			;"BUFFER NUMBER"/2 OR "PORT NUMBER"
  BX        0
.ENDC				;END OF BASE SUPPORT ONLY STUFF
L  SDLHLC			;LAST LOCATION + 2 TO CLEAR ON STARTUP
SDLHCZ==!<SDLHLC-SDLHFC+1>/2
	.ENDM
.ENDC

;LINK TYPE I

.IF DF LKINUM
	.MACRO	SDBLKI	DEV,SOC
L  SDLIFC			;FIRST LOCATION TO CLEAR ON STARTUP
W  SDLILD,0			;ADDRESS OF LINKED LDB
B  SDLICN,0			;CHANNEL NUMBER
B  SDLISP,0			;CIRCUIT SPEED
B  SDLINL,0			;CIRCUIT LINK COUNT	    --KS
B  SDLICT,0			;CIRCUIT CHARACTERISTIC TYPE--KS
W  SDLIS1,0			;IMPURE STATUS WORD 1
W  SDLISC,0			;ADDRESS OF SAVED CONNECT PACKET

.IF DF LITPC			;Only need tIese words if have terminal
				;  protocol conversion support
				;WARNING *** These entries must line up with the
				;  corresponding entries in the terminal (TR)
				;  SDB's!  There are exactly 8 words between
				;  the end of the common part of the SDB's and
				;  the start of this area!!
  W  SDLIT1,0			;* SDTRS1 *  Terminal status word 1
  W  SDLIT2,0			;* SDTRS2 *  Terminal status word 2
  W  SDLIT3,0			;* SDTRS3 *  Terminal status word 3
  W  SDLIT4,0			;* SDTRS4 *  Terminal status word 4
  W  SDLIT5,0			;* SDTRS5 *  Terminal status word 5
  B  SDLILW,0			;* SDTRS6 *  Terminal line widtI
  B  SDLIHP,0			;* SDTRS6 *  Terminal current horizontal position
  B  SDLIES,0			;* SDTROS *  Input ESC processing state
  B  SDLIBS,0			;* SDTRBS *  Active break set
  B  SDLIIL,0			;* SDTRIL *  Input buffer limit value
  B  SDLIIC,0			;* SDTRIC *  Input buffer character count
  BX        0			;* SDTRBX *  Current break set (Not used here!)
  B  SDLIIT,0			;* SDTRIT *  Idle timer initial value
  B  SDLIPB,0			;* SDTRPB *  Procedure on break
  B  SDLIDL,0			;* SDTRDL *  Terminal delete character
  B  SDLILX,0			;* SDTRLX *  Terminal line delete character
  B  SDLISO,0			;* SDTRSO *  Terminal suppress output character
  B  SDLIRE,0			;* SDTRRE *  Terminal line retype character
  B  SDLIHI,0			;* SDTRHI *  Terminal hard interrupt character
  B  SDLISI,0			;* SDTRSI *  Terminal soft interrupt character
  B  SDLICI,0			;* SDTRCI *  Cmd interrupt char.
  B  SDLISR,0			;* SDTRSR *  Status request char.
				;End of entries which must match terminal
				;  service entries!!!
  B  SDLIT6,0			;* SDTRT6 *  Idle time down counter

.ENDC

W  SDLIS2,0			;IMPURE STATUS WORD 2
W  SDLIGT,0			;GUSH - TRICKLE WORD
W  SDLIHC,0			;CONNECTED HOST

.IF DF LIBASE			;ONLY NEED THESE WORDS IF HAVE BASE SUPPORT
  W  SDLIVH,0			;HIGH ORDER PART OF INVOICE NUMBER
  W  SDLIVL,0			;LOW ORDER PART OF INVOICE NUMBER
  W  SDLII2,0			;HIGH ORDER PART OF INPUT CHARACTER COUNT
  W  SDLII1,0			;LOW ORDER PART OF INPUT CHARACTER COUNT
  W  SDLIO2,0			;HIGH ORDER PART OF OUTPUT CHARACTER COUNT
  W  SDLIO1,0			;LOW ORDER PART OF OUTPUT CHARACTER COUNT
  W  SDLIPC,0			;PLACE TO ACCUMULATE PROJECT CODE CHARACTERS
.ENDC				;END OF BASE SUPPORT ONLY STUFF
L  SDLILC			;LAST LOCATION + 2 TO CLEAR ON STARTUP
SDLICZ==!<SDLILC-SDLIFC+1>/2
	.ENDM
.ENDC

.IFF			;.IF NE LK.NUM
SDLKLV==!0			;DUMMY IF NO LINKS SINCE PKT2 REFERENCES IT!
.ENDC			;.IF NE LK.NUM
	.PAGE
	.SBTTL	PASS2 - INVOKE CONFIG FILE TO DEFINE PARAMTERS AND BUILD THE DATA BLOCKS

;INVOKE THE CONFIGURATION MACRO TO DEFINE PARAMTERS AND TO BUILD THE DATA BLOCKS


	CONFIG

;GENERATE THE TERMINAL DDB IF IT IS NEEDED SINCE THERE IS NOTHING IN THE
;  CONFIG FILE TO DO THIS NICELY!

.IF NE TR.NUM
$$$S=!$D0TRM
$$$PL=!0
	XDDB	TR,T,0,TR.S0,,TRPOKE#,TRRSUM#,TRSSRC#
  TRMTTL==!L..LN
.IFF		;In case no terminal is defined for this node
	.IF DF	LHTPC ! LITPC
	$$$S = 0	;Pure status word SDTRS0
	$$$B = 0	;Terminal baud rate
	$$$T = 0	;Terminal type code
	$$$CL= 0	;Privilege class
	$$$C = 0	;Command decoder index
	XSDB	TR,T,0,0,A
	.ENDC
.ENDC
	.PAGE
	.SBTTL	DEFINE GENERAL PARAMETERS

	.PSECT	PURE,RW,D,LCL,REL,CON

;DEFINE SOME PARAMETERS AND CONSTANTS

	.GLOBL	PKTWDS,PKCMAX

.IF NDF MXNPKT			;If no maximum number of packet specified,
  MXNPKT==!77777		;  make this a very large number!
.ENDC

.IF NDF TRMPLM			;If no packet limit for terminal ESC
  TRMPLM==!40.			;  is specified, assume resonable limit
.ENDC

.IF NDF JIFSEC
  JIFSEC==!60.			;Default clock freqency is 60 hertz
.ENDC
	JIFO10==!JIFSEC/10.	;Define symbols for various time intervals
	JIFO4 ==!JIFSEC/4.
	JIFO2 ==!JIFSEC/2.
	JIFX2 ==!JIFSEC*2.
	JIFX8 ==!JIFSEC*8.
	JIFX10==!JIFSEC*10.
	JIFX15==!JIFSEC*15.
	JIFX16==!JIFSEC*16.
	JIFX20==!JIFSEC*20.
	JIFX30==!JIFSEC*30.
	JIFX60==!JIFSEC*60.
	JIFX90==!JIFSEC*90.
	JIF150==!JIFSEC*150.
	JIF180==!JIFSEC*180.
	JIFM05==!JIFSEC*60.*5.
	JIFM10==!JIFSEC*60.*10.
	JIFM15==!JIFSEC*60.*15.
	MAXTIME==!177777
.IF EQ JIFSEC-60.
  JIFMUL==!3			;MULTIPLIER TO CONVERT FROM 100'S TO 60'S
  JIFDIV==!5			;DIVISOR TO CONVERT FROM 100'S TO 60'S
.ENDC
.IF EQ JIFSEC-50.
  JIFMUL==!1			;MULTIPLIER TO CONVERT FROM 100'S TO 50'S
  JIFDIV==!2			;DIVISOR TO CONVERT FROM 100'S TO 50'S
.ENDC
.IF NDF JIFMUL
	.ERROR ;POWER FREQUENCY NOT DEFINED AS 50 OR 60 HERTZ
.ENDC
.IF NDF CLKREG
  CLKREG==177546		;LINE CLOCK STATUS REGISTER ADDRESS
.ENDC
.IF NDF TRPWRN
  TRPWRN==!6.			;NUMBER OF PACKETS FOR WARNING FOR TERMINALS
.ENDC
	TRPWRX==!<TRPWRN+1>/2
.IF NDF TRPMAX
  TRPMAX==!16.			;MAXIMUM NUMBER OF PACKETS FOR TERMINALS
.ENDC

;Define limit parameters for MAKPKT

  .PLKIL==!0			;For making Kill Packets - only used by MAKKIL
  .PLTRM==!2			;Terminal input packet
  .PLZAP==!6			;Auto-zap routine
  .PLSTP==!10.			;Stoppable or don't care routines
  .PLOPT==!15.			;Optional routines
.IF DF LKINUM!LKHNUM		;Define special values if have type I link(s)
  .PLSPR==!1			;For buffering supervisor messages for type
				;  I link
  .PLTRM==!3			;Terminal input packet
  .PLZAP==!12.			;Auto-zap routine
  .PLSTP==!16.			;Stoppable or don't care routines
  .PLOPT==!20.			;Optional routines
.ENDC

;DEFINE SOME PARAMETERS FOR LINKS

VLLK0C==!10.			;VALUE FOR LINK LEVEL 0 FAIRNESS COUNT
VLLK1C==!10.			;VALUE FOR LINK LEVEL 1 FAIRNESS COUNT
VLLKFC==!6.			;VALUE FOR LINK FLAG FAIRNESS COUNT

;GENERATE THE HOST CONNECT LIST POINTER TABLE - EACH ENTRY POINTS TO THE START
;  OF A HOST CONNECT LIST

	.EVEN
.N=!0
HCLTBL::.REPT	.HCL
	.IRP	NN,<\.N>
	.WORD	HST$'NN
	.ENDM
.N=!.N+1
	.ENDR
	.PAGE
	.SBTTL	PURE DATA

	.PSECT	PURE,RW,D,LCL,REL,CON
;	.EVEN

.IF NDF VERNUM			;IF VERSION NUMBER NOT DEFINED
  VERNUM==!250			;  THIS IS VERSION 2
.ENDC

.IF NDF EDTNUM			;If edit number not defined
  EDTNUM==!1			;  This is edit 1
.ENDC

.IF NDF DFTH$$
  DFTHST::.BYTE	0		;NULL DEFAULT HOST NAME
.ENDC

.IF NDF ..MOD			;Check for message of the day
  ..MOD::.BYTE 0
.IFF
 .IF EQ ..MOD-.
  ..MOD::.BYTE 0
 .ENDC
.ENDC

.IF NDF ..TRMM			;Check for terminal connection message
  ..TRMM::.BYTE 0
.IFF
 .IF EQ ..TRMM-.
  ..TRMM::.BYTE 0
 .ENDC
.ENDC


.IF NDF	KHST$$
	  .EVEN
 XRAYNM::	;GLOBAL REF FOR PADMGR.MAC
 KERHST:: .WORD 0
.ENDC

.IF NDF	THST$$
	  .EVEN
 THOST:: .WORD 0
.ENDC
	.PAGE
	.SBTTL	PURE TABLES INDEXED BY NETWORK DEVICE I.D.

	.PSECT	PURE,RW,D,LCL,REL,CON
	.EVEN

;DEFINE MACRO WHICH CONTAINS ALL OF THE DATA FOR THE FOLLOWING TABLES

	.MACRO	DVXX
	DVX	ST,S,4,5	; 1  STATUS DEVICE
	DVX	TR,T,4,5	; 2  USER TERMINAL
	DVX	LP,P,4,5	; 3  LINE PRINTER
	DVX	WD,W,4,5	; 4  LOAD DEVICE
.IF EQ ..SAT
	DVX	TX,X,4,5	; 5  AUX TERMINAL
	DVX	TY,Y,4,5	; 6  AUX TERMINAL
	DVX	TZ,Z,4,5	; 7  AUX TERMINAL
	DVX	CR,C,4,5	;10  CARD READER
	DVX	MT,M,4,5	;11  MAGNETIC TAPE
	DVX	FD,F,4,5	;12  FLOPPY DISK
.ENDC
	.ENDM

;GENERATE TABLE OF NETWORK DEVICE NAMES - INDEXED BY 2 TIMES THE NETWORK
;  DEVICE I.D.

	.MACRO	DVX  DV,D,PWRN,PMAX
	.WORD	"DV
.ID'DV==!.N
.N=!.N+1
	.ENDM

.N=!1
DEVNAM::.WORD	"HS		;FIRST ENTRY IS FOR HOSTS
	DVXX			;REST ARE FOR DEVICES
DEVMAX==!.-DEVNAM

.IDLK==!0

;Generate table of single device specifiers

	.MACRO	DVX  DV,D,PWRN,PMAX
	.BYTE	''D
	.ENDM

DEVLTR::.BYTE	'L		;First is a "link"
	DVXX

;GENERATE TABLE OF DX'S INDEXED BY NETWORK DEVICE I.D.

	.MACRO	DVX  DV,D,PWRN,PMAX
.IF DF DV'.NUM
	.BYTE	.N
  .N=!.N+2
.IFF
	.BYTE	-1
.ENDC
	.ENDM

.N=!0
NIDDX::	.BYTE	-1		;HOST
	DVXX
NIDMAX==!.-NIDDX

;GENERATE TABLE OF WARNING VALUES FOR EACH TYPE OF DEVICE

	.MACRO	DVX  DV,D,PWRN,PMAX
	.BYTE	PWRN
	.ENDM

NIDPWN::.BYTE	4			;VALUE FOR HOSTS
	DVXX

;GENERATE TABLE OF MAXIMUM PACKET COUNTS VALUES FOR EACH TYPE OF DEVICE

	.MACRO	DVX  DV,D,PWRN,PMAX
	.BYTE	PMAX
	.ENDM

NIDPMX::.BYTE	5			;VALUE FOR HOSTS
	DVXX
	.EVEN
	.PAGE
	.SBTTL	DEVICE INDEX (DX) TABLE

	PURE

	.MACRO	DVX  DV,D,PWRN,PMAX
.IF DF DV'.NUM
	.IF NE DV'.NUM
		.WORD	D'0$
	.DX0'D=!.N
	.N=!.N+1
	.ENDC
.ENDC
	.ENDM

.N=!0
	.EVEN
DXTBL::	DVXX

LKOFS$==!.-DXTBL			;OFFSET FOR FIRST LINK ENTRY

NN=!0
	.REPT	LK.NUM			;ONCE FOR EACH LINK
	.IRP	DEV,<\NN>
	.WORD	L'DEV'$
.DX'DEV'L=!.N
	.ENDM
NN=!NN+1
.N=!.N+1
	.ENDR

MAXDX==!.-DXTBL-2
DXSIZE==!<.-DXTBL>/2
DXTOP==!.-2

;Define symbol for top of SXTBL

	.PSECT	SX,RW,D,LCL,REL,CON

SXTOP::!
	.PAGE
	.SBTTL	COMMAND DECODER TABLES

	PURE

;GENERATE TABLE OF ADDRESSES OF ENTRY TABLES FOR EACH COMMAND DECODER

.N=!0

CMDETB::.IRP	CMD,<NEX,TYM,SAT,X28,DBG>
.IF DF C$'CMD
  C.'CMD=!.N
	.WORD	CMD'ENT#
  .N=!.N+2
.ENDC
	.ENDM
	.PAGE
	.SBTTL	AUTO-BAUD RATE DETECT TABLES

	PURE

.IF DF ABR$				;NEED THIS IF ANY LINES HAVE AUTO-

.LIST BEX,MEB
;DEFINE SYMBOLS FOR TERMINAL ID, USED IN THE AUTO BAUD TABLE
;NOTE: FIRST BYTE OF EACH ENTRY = 377, MEANS END-OF-TABLE
;      SO NO TERMINAL ID CODE HAS THE VALUE = 1.
.TIDA=2.		;TERMINAL ID="A"
.TIDB=4.		;TERMINAL ID="B"
.TIDC=8.		;TERMINAL ID="C"
.TIDD=16.		;TERMINAL ID="D"
.TIDE=32.		;TERMINAL ID="E"
.TIDG=64.		;TERMINAL ID="G"
.TIDI=128.		;TERMINAL ID="I"
.TIDP=256.		;TERMINAL ID="P"
.TIDQ=512.		;TERMINAL ID="Q" (corresponding "P")
.TIDY=1024.		;TERMINAL ID="Y"
.TIDJ=2048.		;TERMINAL ID="J"
.TIDO=4096.		;TERMINAL ID="O" PRISM TERMINAL
.TIDT=8192.		;TERMINAL ID="T" Split Baud TERMINAL
.TIDX=177776		;TERMINAL ID=ANY CHAR.
	.MACRO ABIDF XXX
;ABIDF MACRO IS USED TO
;	1. CHECK THE SYNTAX OF TERMINAL ID IN "AB" .MACRO
;	2. RECURSIVELY SEARCH FOR ALL LEGAL TID AND PUT THE
;	   CODE TO $$$I
	.IRP	XX1,<XXX>
.IF NDF .TID'XX1
	.ERROR	;illegal TERMINAL ID CODE
.ENDC
$$$I=$$$I!.TID'XX1
	.ENDM
	.EVEN
	.WORD	$$$I
	.ENDM
					;  BAUD RATE SPECIFIED

;DEFINE MACRO WHICH DEFINES AN AUTO-BAUD DETECT CLASS
;  PARAMETERS ARE AS FOLLOWS:
;	ABC	N,DET,STR,RST
;  WHERE:
;	N   = AUTO-BAUD RATE NUMBER (AS USED IN THE LINE MACRO IN CONFIG -
;		MUST BE TIGHT MOMOTONIC INCREASING STARTING AT 1)
;	DET = BAUD RATE TO BE USED FOR RATE DETECTION
;	SET = ADDRESS OF SETUP ROUTINE
;	RST = ADDRESS OF RESET ROUTINE

	.MACRO	ABC  N,DET,SET,RST
	TRMLST			;TERMINATE PREVIOUS LIST IF NECESSARY
	.EVEN
RAT$'N:	.WORD	SET'#
	.WORD	R.'DET
	.WORD	RST'#
	.ENDM

	.MACRO	TRMLST
	.MACRO	TRMLST
	.BYTE	377
	.ENDM
	.ENDM

;DEFINE MACRO WHICH DEFINES EACH ENTRY IN THE AUTO-BAUD DETECT TABLES
;  PARAMETERS ARE AS FOLLOWS:
;	AB	RAT,TYP,COD,CHR,MSK,F
;  WHERE:
;	RAT = ACTUAL BAUD RATE CORRESPONDING TO CHARACTER
;	TYP = TERMINAL TYPE OR SECONDARY TABLE NUMBER IF RAT IS BLANK
;	COD = TERMINAL CODE
;	CHR = CHARACTER FOR MATCH
;	MSK = MASK FOR MATCH
;	F   = F IF MUST HAVE FRAMING ERROR, BLANK IF CANNOT HAVE FRAMING
;		ERROR, X IF DON'T CARE

	.MACRO	AB  RAT,TYP,COD,CHR,MSK,FFF,TID
.IF NB <TID>		;FOR AUTO-BAUD-TABLE-11
  $$$I=0
  ABIDF	<TID>		;INVOKE TERMINAL-ID .WORD
  .ENDC

.FLG=!200
.IF IDN <FFF><X>
  .FLG=!000
.ENDC
.IF IDN <FFF><F>
  .FLG=!300
.ENDC
.IF NB <RAT>
  .IF NB <TYP>
    .IF NDF T.'TYP
	.ERROR ;ILLEGAL TERMINAL TYPE IN AB MACRO FOR AUTO-BAUD TABLE
    .ENDC
    $$$T=!T.'TYP
  .IFF
    $$$T=!-1
  .ENDC
	.BYTE	^C<MSK>,CHR,.FLG,R.'RAT,$$$T
.IFF
  .IF NDF SEC.'TYP
	.ERROR ;UNDEFINED SECONDARY TABLE IN AB MACRO FOR AUTO-BAUD TABLE
  .ENDC
	.BYTE	^C<MSK>,CHR,.FLG,0,SEC.'TYP
  SBT$'TYP=!1
  SBT$=!1
.ENDC
.IF B <COD>
	.BYTE	0
.IFF
  .IF NDF .XX'COD
	.ERROR ;ILLEGAL TERMINAL CODE IN AB MACRO FOR AUTO-BAUD TABLE
  .ENDC
	.BYTE	.XX'COD
  X$$'COD=!1
.ENDC
	.ENDM

.B0=!0

;GENERATE TABLES
;  THE FORMAT OF EACH TABLE IS AS FOLLOWS:
;RAT$n::.WORD	SET		;ADDRESS OF SETUP ROUTINE
;	.WORD	DET		;RATE TO USE FOR DETECT
;	.WORD	RST		;ADDRESS OF RESET ROUTINE
;	.BYTE	MSK		;COMPLEMENT OF DETECT MASK FOR FIRST RATE
;	.BYTE	CHR		;DETECT CHARACTER FOR FIRST RATE
;	.BYTE	FLG		;FLAG BITS FOR FIRST RATE
;				;  200 = CHECK FRAMING ERROR
;				;  100 = MUST HAVE FRAMING ERROR
;	.BYTE	RAT		;FIRST RATE
;	.BYTE	TYP		;TERMINAL TYPE OR INDEX FOR NEXT LEVEL TABLE
;				;  IF RATE = 0
;	.BYTE	COD		;TERMINAL CODE
;	.BYTE	MSK		;COMPLEMENT OF DETECT MASK FOR SECOND RATE
;	.BYTE	CHR		;DETECT CHARACTER FOR SECOND RATE
;	.BYTE	RAT		;SECOND RATE
;	.BYTE	TYP		;TYPE FOR SECOND RATE
;	....
;	.BYTE	377		;END OF TABLE

;GENERATE TABLES FOR AUTO-BAUD DETECT TYPE 1

.IF DF ABR$1
	ABC	1,300,AINI13,ARST13	;DETECT AT 300 FOR 110,135,150,300
	AB	300  ,    ,ASC,015,177,X	;CR -  300 BAUD, ASCII
	AB	150  ,    ,ASC,346,377,X	;CR -  150 BAUD, ASCII
	AB	134X ,SEL ,CRS,300,337,X	;D  -  134.5 BAUD, CORRESPONDENCE
	AB	110  ,    ,ASC,014,155,X	;CR -  110 BAUD, ASCII
.ENDC

;GENERATE TABLES FOR AUTO-BAUD DETECT TYPE 2

.IF DF ABR$2
	ABC	2,600,AINI13,ARST13	;DETECT AT 600 FOR 110,135,300,1200
	AB	1200 ,    ,ASC,370,370,X	;CR - 1200 BAUD, ASCII
	AB	300  ,    ,ASC,302,336,X	;CR -  300 BAUD, ASCII
	AB	300  ,    ,ASC,312,336,X
	AB	300  ,    ,ASC,322,336,X
	AB	300  ,    ,ASC,304,336,X
	AB	300  ,    ,ASC,314,336,X
	AB	300  ,    ,ASC,324,336,X
	AB	300  ,    ,ASC,306,336,X
	AB	300  ,    ,ASC,316,336,X
	AB	300  ,    ,ASC,326,336,X
	AB	134X ,SEL ,CRS,135,377,X	;D  -  134.5 BAUD, CORRESPONDENCE
	AB	110  ,    ,ASC,340,357,X	;CR -  110 BAUD, ASCII
.ENDC

;GENERATE TABLES FOR AUTO-BAUD DETECT TYPE 3

.IF DF ABR$3
;	ABC	3,4800,AINI13,ARST13	;DETECT AT 4800 FOR 300,600,1200,1800,
;					;  2400,4800,9600
;	AB	     ,   1,   ,000,377,F	;CR -  300 BAUD, ASCII
;	AB	600  ,    ,ASC,200,377		;CR -  600 BAUD, ASCII
;	AB	1200 ,    ,ASC,170,377,F	;CR - 1200 BAUD, ASCII
;	AB	1800 ,    ,ASC,214,355		;CR - 1800 BAUD, ASCII
;	AB	2400 ,    ,ASC,346,377		;CR - 2400 BAUD, ASCII
;	AB	4800 ,    ,ASC,015,177		;CR - 4800 BAUD, ASCII
;	AB	9600 ,    ,ASC,360,360		;CR - 9600 BAUD, ASCII
	ABC	3,9600,AINI13,ARST13	;DETECT AT 4800 FOR 300,600,1200,1800,
					;  2400,4800,9600
	AB	 300 ,    ,ASC,000,377,F	;CR -  300 BAUD, ASCII
	AB	1200 ,    ,ASC,200,377		;CR - 1200 BAUD, ASCII
	AB	1800 ,    ,ASC,360,377		;CR - 1800 BAUD, ASCII
	AB	2400 ,    ,ASC,170,377,F	;CR - 2400 BAUD, ASCII
	AB	3600 ,    ,ASC,214,355		;CR - 3600 BAUD, ASCII
	AB	4800 ,    ,ASC,346,377		;CR - 4800 BAUD, ASCII
	AB	9600 ,    ,ASC,015,177		;CR - 9600 BAUD, ASCII
	AB	19200,    ,ASC,360,360		;CR - 19.2K BAUD, ASCII
.ENDC

;GENERATE TABLES FOR AUTO-BAUD DETECT TYPE 4

.IF DF ABR$4
	ABC	4,300,AINI45,ARST45	;TYMNET STYLE DETECT AT 300 FOR 110,
					;  134,150,300
	AB	110  ,CRT ,ASC,000,177		;D - 110 BAUD, TERMINAL = CRT
	AB	150  ,TRMB,ASC,030,377,F	;B - 150 BAUD, TERMINAL = TRMB
	AB	300  ,CRT ,ASC,101,137		;A - 300 BAUD, TERMINAL = CRT
	AB	300  ,TRMC,ASC,103,137		;C - 300 BAUD, TERMINAL = TRMC
	AB	300  ,TRME,ASC,105,137		;E - 300 BUAD, TERMINAL = TRME
	AB	300  ,TRMG,ASC,107,137		;G - 300 BAUD, TERMINAL = TRMG
.ENDC

;GENERATE TABLES FOR AUTO-BAUD DETECT TYPE 5

.IF DF ABR$5
	ABC	5,1200,AINI45,ARST45	;TYMNET STYLE DETECT AT 1200 FOR 110,
					;  300,1200
	AB	     ,   2,   ,000,377,F	;D - 110 BAUD, TERMINAL = CRT
	AB	300  ,CRT ,ASC,170,377,F	;A - 300 BAUD, TERMINAL = CRT
	AB	300  ,TRMC,ASC,370,377		;C - 300 BAUD, TERMINAL = TRMC
	AB	1200 ,CRTA,ASC,101,137		;A - 1200 BAUD, TERMINAL = CRTA
	AB	1200 ,TRMG,ASC,107,137		;G - 1200 BAUD, TERMINAL = TRMG
	AB	1200 ,TRMJ,ASC,111,137		;I - 1200 BAUD, TERMINAL = TRMJ
.ENDC

;GENERATE TABLES FOR AUTO-BAUD DETECT TYPE 6

.IF DF ABR$6
	ABC	6,1200,AINI6,ARST6	;TYMNET STYLE DETECT AT 1200 FOR 110,
					;  134.5,300, AND 1200 USING SPECIAL
					;  HIGH SPEED CLOCK FOR SECONDARY
					;  DETECT CHARACTER TIMING
	AB	1200 ,CRTA,ASC,101,137		;A - 1200 BAUD, TERMINAL = CRTA
	AB	1200 ,TRMG,ASC,107,137		;G - 1200 BAUD, TERMINAL = TRMG
	AB	1200 ,TRMJ,ASC,111,137		;I - 1200 BAUD, TERMINAL = TRMJ
	AB	     ,   3,   ,170,377,F	;A,E - 300 BAUD, TERMINAL = CRTA
						;        OR TRME
	AB	     ,   4,   ,370,377		;C,G - 300 BAUD, TERMINAL = TRMC
						;	 OR TRMG
	AB	     ,   5,   ,000,377,F	;B,D - 150 BAUD, TERMINAL = TRMB
						;	 OR 110 BAUD, TERMINAL =
						;	 TTY
	AB	     ,   6,   ,000,177		;P - 134.5 BAUD, TERMINAL = SEL,
						;	CODE = CRS OR EBD
.ENDC

;Generate tables for auto-baud detect type 7

.IF DF ABR$7
	ABC	7,1200,AINI7,ARST7	;TYMNET STYLE DETECT AT 1200 FOR 110,
					;  134.5,300, AND 1200 USING SPECIAL
					;  HIGH SPEED CLOCK FOR SECONDARY
					;  DETECT CHARACTER TIMING
	AB	1200 ,CRTA,ASC,101,137		;A - 1200 BAUD, TERMINAL = CRTA
	AB	1200 ,TRGE,ASC,107,377		;G - 1200 BAUD, TERMINAL = TRMG
	AB	1200 ,TRGE,ASC,347,377		;g - 1200 BAUD, TERMINAL = TRMG
	AB	1200 ,TRIE,ASC,311,377		;I - 1200 BAUD, TERMINAL = TRMJ
	AB	1200 ,TRIE,ASC,151,377		;i - 1200 BAUD, TERMINAL = TRMJ
	AB	     ,   7,   ,170,377,F	;A,E,I,Y - 300 BAUD, TERMINAL =
						; CRTA OR TRME OR TRMI OR TRMY
	AB	     ,  10,   ,360,363		;C,G - 300 BAUD OR A 2400 BAUD
;	AB	     ,  10,   ,370,377		;C,G - 300 BAUD, TERMINAL = TRMC
						;	 OR TRMG
	AB	     ,  11,   ,000,377,F	;B,D - 150 BAUD, TERMINAL = TRMB
						;	 OR 110 BAUD, TERMINAL =
						;	 TTY
	AB	     ,  12,   ,000,177		;P - 134.5 BAUD, TERMINAL = SEL,
						;	CODE = CRS OR EBD
;	AB	2400 ,CRTA,ASC,360,363		;A - 2400 BAUD, TERMINAL =CRT
	AB	2400 ,TRMG,ASC,361,363		;G - 2400 BAUD, TERMINAL = TRMG
	AB	4800 ,CRTA,ASC,376,376		;A - 4800 BAUD, TERMINAL = CRT
.ENDC

;Generate tables for auto-baud detect type 10

.IF DF ABR$10
	ABC	10,9600,AINI7,ARST7	;TYMNET STYLE DETECT AT 9600 FOR 110,
					;  134.5,300, AND 9600 USING SPECIAL
					;  HIGH SPEED CLOCK FOR SECONDARY
					;  DETECT CHARACTER TIMING
	AB	4800 ,CRTA,ASC,006,377,F	;A - 4800 BAUD, TERMINAL = CRTA
	AB	     ,  13,ASC,170,377,F	;A,I - 2400 BAUD
	AB	     ,  14,   ,200,377		;A,I,G 1200 BAUD
	AB	     ,  15,   ,000,377,F	;A,B,C,D,E,F,G,I,Y AT 300 BAUD AND LOWER
	AB	9600 ,TRGE,ASC,107,377		;G - 9600 BAUD, TERMINAL = TRMG
	AB	9600 ,TRGE,ASC,347,377		;g - 9600 BAUD, TERMINAL = TRMG
	AB	9600 ,TRIE,ASC,311,377		;I - 9600 BAUD, TERMINAL = TRMJ
	AB	9600 ,TRIE,ASC,151,377		;i - 9600 BAUD, TERMINAL = TRMJ
	AB	4800 ,TRMG,ASC,176,377,F	;G - 4800 BAUD, TERMINAL = TRMG
	AB	4800 ,TRMI,ASC,206,377		;I - 4800 BAUD, TERMINAL = TRMJ
	AB	2400 ,TRMG,ASC,370,377		;G - 2400 BAUD, TERMINAL = TRMG
	AB	9600 ,CRTA,ASC,101,137		;A - 9600 BAUD, TERMINAL = CRTA
	AB	38400,CRTA,ASC,376,376		;A- 38400 BAUD, TERMINAL = CRT
	AB	19200,CRTA,ASC,360,363		;A- 19200 BAUD, TERMINAL = CRT
.ENDC

.IF DF ABR$11          ;USE 9600 SAMPLING RATE TO DETECT SYNCRONOUSLY
                        ;19200, 9600,4800,2400, 1200, 300,150, 134.5
                        ;AND 110 BY TERMINAL ID.

        ABC     11,SYNC,AINI11,ARST11
        AB      4800,CRTO,ASC,376,377,,O        ;O- 4800
        AB           ,  27,   ,370,377,,<G,O> ;G,O- 2400
        AB      19200,CRTA,ASC,370,371,,A       ;A- 19200
        AB       9600,CRTA,ASC,101,137,,A    ;A-  9600
        AB       9600,TRIE,ASC,111,137,,I    ;I-  9600
        AB       9600,TRGE,ASC,107,137,,G    ;G-  9600
        AB       9600,CRTO,ASC,117,137,,O    ;O-  9600
        AB      4800,CRTA,ASC,006,377,,A        ;A- 4800
        AB      4800,TRMI,ASC,206,377,,I        ;I- 4800
        AB      4800,TRMG,ASC,176,377,,G	;G- 4800
        AB           ,  27,   ,170,377,,<A,I> ;A,I- 2400
        AB           ,  30,   ,000,077,,X    ;<=1200
.ENDC 						;.IF DF ABR$11

;GENERATE THE SECONDARY TABLES

.IF DF SBT$

;  THE FORMAT OF EACH TABLE IS AS FOLLOWS:
;SEC$n::.BYTE	MIN TIME	;MINIMUM TIME SINCE PRIMARY CHARACTER (OPTIONAL)
;	.BYTE	MAX TIME	;MAXIMUM TIME SINCE PRIMARY CHARACTER (OPTIONAL)
;	.BYTE	MSK		;COMPLEMENT OF DETECT MASK FOR FIRST RATE
;	.BYTE	CHR		;DETECT CHARACTER FOR FIRST RATE
;	.BYTE	FLG		;FLAG BITS FOR FIRST RATE
;				;  200 = CHECK FRAMING ERROR
;				;  100 = MUST HAVE FRAMING ERROR
;	.BYTE	RAT		;FIRST RATE
;	.BYTE	TYP		;TERMINAL TYPE OR INDEX FOR NEXT LEVEL TABLE
;				;  IF RATE = 0
;	.BYTE	COD		;TERMINAL CODE
;	....

	.MACRO BBB B1,B2
.B=0
.IRPC BX,<B2>
.IF EQ .B
B1=''BX
.B=.B+1
.ENDC
.ENDM
	.ENDM

;DEFINE MACRO WHICH DEFINES A SECONDARY TABLE:
;	ABS	N,TIM
;  WHERE:
;	N   = NUMBER OF SECONDARY TABLE
;	TIM = NUMBER OF TICKS TO WAIT FOR SECOND DETECT CHARACTER

	.MACRO	ABS  N
	.BYTE	377			;TERMINATE PREVIOUS TABLE
	.EVEN

SEC$'N:
	.ENDM

;DEFINE MACRO WHICH DEFINES EACH ENTRY IN THE SECONDARY DETECT TABLES
;  PARAMETERS ARE AS FOLLOWS:
;	AB	RAT,TYP,COD,CHR,MSK,F,MIN,MAX
;  WHERE:
;	RAT = ACTUAL BAUD RATE CORRESPONDING TO CHARACTER
;	TYP = TERMINAL TYPE OR SECONDARY TABLE NUMBER IF RAT IS BLANK
;	COD = TERMINAL CODE
;	CHR = CHARACTER FOR MATCH
;	MSK = MASK FOR MATCH
;	F   = F IF MUST HAVE FRAMING ERROR, BLANK IF CANNOT HAVE FRAMING
;		ERROR, X IF DON'T CARE
;	MIN = MINIMUM NUMBER OF FAST CLOCK TICKS SINCE PRIMARY CHARACTER
;		A ZERO IN THIS FIELD OF THE FIRST AB ENTRY OF A SECONDARY
;		TABLE INDICATES THIS IS THE DEFAULT IF A SECONDARY TIMEOUT OCCURS
;		(OPTIONAL, MUST BE BLANK IF DETECT ROUTINE DOES NOT USE IT!)
;	MAX = MAXIMUM NUMBER OF FAST CLOCK TICKS SINCE PRIMARY CHARACTER
;		(OPTIONAL, MUST BE BLANK IF DETECT ROUTINE DOES NOT USE IT!)

	.MACRO	AB  RAT,TYP,COD,CHR,MSK,FFF,MIN,MAX
.FLG=!200
.IF IDN <FFF><X>
  .FLG=!000
.ENDC
.IF IDN <FFF><F>
  .FLG=!300
.ENDC
.IF NB <MAX>
	.BYTE	MIN,MAX

.IFF
  .IF NB <MIN>		;FOR AUTO-BAUD-TABLE-11
  $$$I=0
  ABIDF	<MIN>		;INVOKE TERMINAL-ID .WORD
  .ENDC

.ENDC
.IF NB <RAT>
  .IF NB <TYP>
    .IF NDF T.'TYP
	.ERROR ;ILLEGAL TERMINAL TYPE IN AB MACRO FOR AUTO-BAUD TABLE
    .ENDC
    $$$T=!T.'TYP
  .IFF
    $$$T=!-1
  .ENDC
	.BYTE	^C<MSK>,CHR,.FLG,R.'RAT,$$$T
.IFF
  .IF NDF SEC.'TYP
	.ERROR ;UNDEFINED SECONDARY TABLE IN AB MACRO FOR AUTO-BAUD TABLE
  .ENDC
	.BYTE	^C<MSK>,CHR,.FLG,0,SEC.'TYP
  SBT$'TYP=!1
  SBT$=!1
.ENDC
.IF B <COD>
	.BYTE	0
.IFF
  .IF NDF .XX'COD

	BBB B1,<COD>	;GET THE VALUE OF 1ST CHAR OF COD
  .IF GE <B1-60>
    .IF GE <71-B1>
	.BYTE	COD	;SELF-REPEAT-COUNTER
    .IFF
	.BYTE	.XX'COD ;TERMINAL-CODE-TABLE-INDEX
	X$$'COD=!1
    .ENDC
  .IFF
	.BYTE	.XX'COD ;TERMINAL-CODE-TABLE-INDEX
	X$$'COD=!1
  .ENDC
.IFF
;;	.ERROR ;ILLEGAL TERMINAL CODE IN AB MACRO FOR AUTO-BAUD TABLE
;  .ENDC
	.BYTE	.XX'COD
  X$$'COD=!1
.ENDC
.ENDC

	.ENDM
;GENERATE SECONDARY TABLE TYPE 1 (USED WITH DETECT TYPE 3)

.IF DF SBT$1
	ABS	1
	AB	300  ,    ,ASC,000,377,F	;CR - 300 BAUD, ASCII
.ENDC

;GENERATE SECONDARY TABLE TYPE 2 (USED WITH DETECT TYPE 5)

.IF DF SBT$2
	ABS	2
	AB	110  ,CRT ,ASC,000,177,F	;D - 110 BAUD, TERMINAL = CRT
.ENDC

;GENERATE SECONDARY TABLE TYPE 3 (USED WITH DETECT TYPE 6)

.IF DF SBT$3
	ABS	3
	AB	300  ,CRT ,ASC,000,377, , 0., 0.;A - 300 BAUD, TERMINAL = CRT
	AB	300  ,TRME,ASC,000,177,X, 8.,24.;E - 300 BAUD, TERMINAL = TRME
	AB	300  ,CRT ,ASC,370,377, ,25.,40.;A - 300 BAUD, TERMINAL = CRT
.ENDC

;GENERATE SECONDARY TABLE TYPE 4 (USED WITH DETECT TYPE 6)

.IF DF SBT$4
	ABS	4
	AB	300  ,TRMC,ASC,000,377,F, 8.,14.;C - 300 BAUD, TERMINAL = TRMC
	AB	300  ,TRMG,ASC,000,177,X,15.,25.;G - 300 BAUD, TERMINAL = TRMG
.ENDC

;GENERATE SECONDARY TABLE TYPE 5 (USED WITH DETECT TYPE 6)

.IF DF SBT$5
	ABS	5
	AB	150  ,TRMB,ASC,000,377,F,10.,37.;B - 150 BAUD, TERMINAL = TRMB
	AB	110  ,TTY ,ASC,000,377,F,38.,60.;D - 110 BAUD, TERMINAL = TTY
.ENDC

;GENERATE SECONDARY TABLE TYPE 6 (USED WITH DETECT TYPE 6)

.IF DF SBT$6
	ABS	6
	AB	134X ,SEL ,EBC,000,377,F,12.,21.;P - 134.5 BAUD, TERMINAL =
						;	SEL, CODE = EBC
	AB	134X ,SEL ,CRS,000,177, ,22.,45.;P - 134.5 BAUD, TERMINAL =
						;	SEL, CODE = CRS
.ENDC

;Generate secondary table type 7 (used with detect type 7)

.IF DF SBT$7
	ABS	7
	AB	300  ,CRTA,ASC,000,377, , 0., 0.;TIMEOUT .. A - 300 BAUD, TERMINAL = CRT
	AB	300  ,TRME,ASC,000,177,X,20.,33.;E - 300 BAUD, TERMINAL = TRME
	AB	300  ,TRMI,ASC,200,207, ,27.,26.;I - 300 BAUD, TERMINAL = TRMI
;	AB	300X ,SEL ,EBC,370,377, ,27.,34.;CR - 300 BAUD, TERMINAL =
						;	3767, CODE = EBC
	AB	300  ,TRMY,ASC,170,177,X,34.,40.;Y - 300 BAUD, TERMINAL = TRMY
	AB	300  ,CRTA,ASC,370,377, ,41.,64.;CATCH ANY PARITY BIT AND DEFAULT
						; TO A - 300 BAUD, TERMINAL = CRT
.ENDC

;GENERATE SECONDARY TABLE TYPE 10 (USED WITH DETECT TYPE 7)

.IF DF SBT$10
	ABS	10
	AB	2400 ,CRTA,ASC,377,377,X,0,0	;A -2400 BAUD, CRT
	AB	300  ,TRMC,ASC,000,377,F,12.,21.;C - 300 BAUD, TERMINAL = TRMC
	AB	300  ,TRMG,ASC,000,177,X,22.,37.;G - 300 BAUD, TERMINAL = TRMG
.ENDC

;GENERATE SECONDARY TABLE TYPE 11 (USED WITH DETECT TYPE 7)

.IF DF SBT$11
	ABS	11
	AB	150  ,TRMB,ASC,000,377,F,15.,56.;B - 150 BAUD, TERMINAL = TRMB
	AB	110  ,TTY ,ASC,000,377,F,57.,90.;D - 110 BAUD, TERMINAL = TTY
.ENDC

;GENERATE SECONDARY TABLE TYPE 12 (USED WITH DETECT TYPE 7)

.IF DF SBT$12
	ABS	12
	AB	134X ,SEL ,EBC,000,377,F,18.,32.;P - 134.5 BAUD, TERMINAL =
						;	SEL, CODE = EBC
	AB	134X ,SEL ,CRS,000,177, ,33.,77.;P - 134.5 BAUD, TERMINAL =
						;	SEL, CODE = CRS
.ENDC

;GENERATE SECONDARY TABLE TYPE 13 (USED WITH DETECT TYPE 10)

.IF DF SBT$13
	ABS	13
	AB	2400 ,CRTA ,ASC,170,377, ,0.,0.	;A - 2400 BAUD CRTA
	AB	2400 ,TRMI ,ASC,200,377, ,1.,7.	;I - 2400 BAUD TRMI
	AB	2400 ,TRMI ,ASC,370,377, ,1.,4.	;i - 2400 BAUD TRMI
	AB	2400 ,CRTA ,ASC,370,377, ,5.,9.	;A - 2400 BAUD CRTA
.ENDC

;GENERATE SECONDARY TABLE TYPE 14 (USED WITH DETECT TYPE 10)

.IF DF SBT$14
	ABS	14
	AB	     ,  16,   ,000,377,F,1., 4.	; A,I 1200 BAUD
	AB	1200 ,TRMG,ASC,000,377,F,5.,10.	;G - 1200 BAUD
.ENDC

;GENERATE SECONDARY TABLE TYPE 15 (USED WITH DETECT TYPE 10)

.IF DF SBT$15
	ABS	15
	AB	     ,   17,ASC,000,377,F, 7.,14.;A,E,I,Y - 300 BAUD
	AB	300  ,TRMC ,ASC,000,377,F,15.,20.;C - 300 BAUD TRMC
	AB	300  ,TRMG ,ASC,000,377,F,21.,27.;G - 300 BAUD TRMG
	AB	134X ,SEL  ,EBC,000,377,F,25.,30.;P - 134 BAUD TRMP
	AB	150  ,TRMB ,ASC,000,377,F,35.,40.;B - 150 BAUD TRMB
;	AB	150  ,TRMJ ,ASC,000,377,F,35.,41.;B - 150 BAUD TRMB
	AB	134X ,SEL  ,CRS,000,377,F,41.,51.;P - 134 BAUD TRMP
	AB	110  ,TTY  ,ASC,000,377,F,60.,72.;D - 110 BAUD TRMD
.ENDC

;GENERATE SECONDARY TABLE TYPE 16 (USED WITH DETECT TYPE 10)

.IF DF SBT$16
	ABS	16
	AB	1200 ,CRTA ,ASC,170,377, ,0.,0.	;A - 1200 BAUD TRMA
	AB	1200 ,TRMI ,ASC,200,377, ,4.,9. ;i - 1200 BAUD TRMI
	AB	1200 ,TRMI ,ASC,000,377,F,4.,16. ;I - 1200 BAUD TRMI
	AB	1200 ,CRTA ,ASC,200,377, ,10.,20.;A - 1200 BAUD TRMA
.ENDC

;GENERATE SECONDARY TABLE TYPE 17 (USED WITH DETECT TYPE 10)

.IF DF SBT$17
	ABS	17
	AB	300  ,CRTA ,ASC,000,377,F, 0., 0.;TIMEOUT - 300 BAUD TRMA
	AB	300  ,TRME ,ASC,000,377,F,20.,28.;E - 300 BAUD TRME
	AB	300  ,TRMI ,ASC,000,377,F,29.,34.;I - 300 BAUD TRMI
	AB	300  ,TRMY ,ASC,000,377,F,35.,42.;Y - 300 BAUD TRMY
	AB	300  ,CRTA ,ASC,000,377,F,43.,59.;A - 300 BAUD CRTA
.ENDC

.IF DF SBT$27
        ABS     20      ;2400_3 (THE 3rd BYTE OF RATE-2400)
        AB      2400,CRTA,ASC,000,077,,A        ;A- 2400
        AB      2400,TRMG,ASC,000,077,,G        ;G- 2400
        AB      2400,TRMI,ASC,007,077,,I        ;I- 2400
        AB      2400,CRTO,ASC,007,077,,O        ;O- 2400

        ABS     21      ;A-1200 6th byte
        AB      1200,CRTA,ASC,000,010,,A        ;A- 1200
        AB      1200,TRMG,ASC,000,010,,G        ;G- 1200
        AB      1200,TRMI,ASC,000,010,,I        ;I- 1200
        AB      1200,CRTO,ASC,000,010,,O        ;O- 1200

	ABS	22	;(ACEGIOY)-300 23rd byte
	AB	 300,CRTA,ASC,000,010,,A		;A- 300
	AB	 300,TRMC,ASC,000,010,,C		;C- 300
	AB	 300,TRME,ASC,000,010,,E		;E- 300
	AB	 300,TRMG,ASC,  0,010,,G		;G- 300
	AB	 300,TRMI,ASC,000, 10,,I		;I- 300
	AB	 300,CRTO,ASC,000,010,,O		;O- 300
	AB	 300,TRMY,ASC, 10, 10,,Y		;Y- 300

	ABS	23	;B-150 45th byte
	AB	 150,TRMB,ASC,  0,010,,B		;B- 150
	AB	 150,TRMJ,ASC,000,010,,J		;J- 150	

;	ABS	24	;P-134.5 49th byte
;	AB	134X, SEL,EBC,010,010,,P	;P- 134.5
;	AB	134X, SEL,CRS,000,010,,Q	;Q- 134.5

	ABS	25	;D-110 61th byte
	AB	 110, TTY,ASC,000,010,,D	;D- 110

	ABS	26	;T-75s 89th byte
;	AB	 75S,CRTA,ASC,010,010,,B	;CR(fake B)- 75
	AB	 75S,CRTA,ASC,010,010,,T	;T- 75

	ABS	27	;(AGIO)-2400 2nd byte
	AB	    ,  20,   ,000,077,,<A,I>	;A,I- 2400
	AB	    ,  20,   ,077,077,,<G,O>	;G,O- 2400

	ABS	30	;(AGIO)-1200_2 or <=300_2-4
	AB	    ,  31,    ,010,010,,<A,G,I,O>	;AGIO-1200
	AB	    ,  32,   3,000,010,,x		;<=300

        ABS     31  	;(AGIO)-1200_3-4
        AB          ,  33,  2,000,010,,<A,I>    ;A,I- 1200
        AB          ,  33,  2,010,010,,<G,O>    ;G,O- 1200

        ABS     33      ;(AGIO)-1200_5
        AB          ,  21,   ,000,010,,<A,G>    ;A,G- 1200
        AB          ,  21,   ,010,010,,<I,O>    ;I,O- 1200

        ABS     32 	;(ACEGIOY)-300_5-8 or <=150_5-14.
        AB          ,  34,  4,010,010,,<A,C,E,G,I,O,Y>  ;ACEGIOY- 300
	AB	    ,  35,10.,000,010,,<B,D,J,T>	;<=150

	ABS	34	;300_9-_12
        AB	    ,  36,  4,000, 10,,<A,E,I,Y>	;AEIY- 300
	AB          ,  36,  4, 10, 10,,<C,G,O>		;C,G- 300

	ABS	36	;300_13-16
	AB	    ,  37,  4,000,010,,<A,C,I,Y>	;ACIY- 300
	AB	    ,  37,  4,010,010,,<E,G,O>		;EGO- 300

	ABS	37	;300_17-20
	AB	    ,  22,  6,000,010,,<A,C,E,G>	;ACEG- 300
	AB	    ,  22,  4,010, 10,,<I,O,Y>		;IOY- 300

	ABS	35	;<=150_15.-18.
	AB	   ,  40,  4,000,000,,<B,D,J,T>		;Don't care

	ABS	40	;150_19.-21. or <=110_19.-28.
	AB	    ,  41,  3,010,010,,<B,J>	;B,J- 150
	AB	    ,  42,10.,000,010,,<D,T>	;<=110

	ABS	41	;B,J-150_22.-28.
	AB	    ,  43,  7,000,000,,<B,J>	;Don't care

	ABS	43	;B,J-150_29.-30.
	AB	    ,  44,  2,000,010,,<B,J>	;BJ- 150

	ABS	44	;B,J-150_31.-36.
	AB	    ,  45,  6,000,000,,<B,J>	;Don't care

	ABS	45	;B,J-150_37.-38.
	AB	    ,  46,  2,000,010,,B	;B- 150
	AB	    ,  46,  2,010,010,,J	;J- 150

	ABS	46	;B,J-150_39.-44.
	AB	    ,  23,  6,000,000,,<B,J>	;Don't care

	ABS	42	;<=110_29.-37.
	AB	    ,  47, 9.,000,000,,<D,T>	;Don't care

	ABS	47	;110_38.-39. or 75_38.-42.
	AB	    ,  50,  2,010,010,,D	;D- 110
	AB	    ,  51,  5,000,010,,T	;T- 75s

	ABS	50	;110_40.-49.
	AB	    ,  52,10.,000,000,,D	;Don't care

	ABS	52	;110_50.-51.
	AB	    ,  53,  2,000,010,,D	;D- 110

	ABS	53	;110_52.-60.
	AB	    ,  25, 9.,000,000,,D	;Don't care

	ABS	51	;75s_43.-54.
	AB	    ,  54,12.,000,000,,T	;Don't care

	ABS	54	;75s_55.-56.
	AB	    ,  55,  2,010,010,,T	;T- 75s

	ABS	55	;75s_57.-72.
	AB	    ,  56,16.,000,000,,T	;Don't care

	ABS	56	;75s_73.-74.
	AB	    ,  57,  2,000,010,,T	;T- 75s

	ABS	57	;75s_75.-88.
	AB	    ,  26,14.,000,000,,T	;Don't care


.ENDC	;.IF DF SBT$27



.ENDC		;.IF DF SBT$

	.BYTE	377			;FLAG END OF LAST TABLE
	.EVEN

;GENERATE INDEX TABLES

.N=!1
.X=!0
ATOTBL::.REPT	11
		;BE SURE TO INCREASE THIS COUNT IF MORE
				;  AUTO-BAUD DETECT TYPES ARE ADDED!!
	.IRP	NN,<\.N>
.IF DF ABR$'NN
	.WORD	RAT$'NN
  ABX.'NN=!.X
.X=.X+1
.ENDC
	.ENDM
.N=!.N+1
	.ENDR

ATOTXX==!ATOTBL-2-<RATAT0*2>
;USE LINE BELOW FOR NEXT RELEASE
;ATOTXX==!ATOTBL-2-RATAT0

SECTBL::
.IF DF SBT$
.N=!1
.X=!0
	.REPT	57
		;BE SURE TO CHANGE THIS COUNT IF MORE
				;  SECONDARY TABLES ARE DEFINED!!
	.IRP	NN,<\.N>
.IF DF SBT$'NN
	.WORD	SEC$'NN
  SEC.'NN=!.X
  .X=!.X+2
.ENDC
	.ENDM
.N=!.N+1
	.ENDR
.ENDC

.IFF		;.IF NDF ABR$
  ATOTXX==!0			;THIS IS REFERENCED BY THE TERMINAL SERVICE
.ENDC		;.IF DF/NDF ABR$
.NLIST BEX,MEB

	.PAGE
	.SBTTL	TERMINAL CODE TRANSLATION INDEX TABLES

;TABLES WHICH CONTAIN POINTERS TO THE CODE TRANSLATION TABLES AND TABLES
;  WHICH CONTAIN THE UPPER AND LOWER SHIFT CODES FOR THOSE CODES WHICH USE
;  THEM

;FIRST DEFINE THE INDEXES USED FOR THESE TABLES

.XXASC==!0			;ASCII IS ALWAYS 0

.N=!2
	.IRP	CODE,<CRS,EBC,BCD,CAL>
.IF DF X$$'CODE
  .XX'CODE==!.N
  .N=!.N+2
.IFF
  .XX'CODE==!-1
.ENDC
	.ENDM

;NOW GENERATE THE TABLES WHOSE ENTRIES POINT TO THE TRANSLATION TABLES

	.MACRO	TABLE  NAME,TBL
NAME==!.-2
	.IRP	CODE,<CRS,EBC,BCD,CAL>
.IF DF X$$'CODE
	.WORD	TBL''CODE#
.ENDC
	.ENDM
	.ENDM

	TABLE	CODTIU,XCU		;UPPER CASE INPUT TABLE
	TABLE	CODTIL,XCL		;LOWER CASE INPUT TABLE
	TABLE	CODTIP,XCP		;PREFIXED INPUT TABLE
	TABLE	CODTOU,XCO		;OUTPUT TABLE
	TABLE	CODTOX,XCX		;SPECIAL OUTPUT TABLE

;GENERATE THE TWO TABLES WHICH CONTAIN THE UPPER AND LOWER CASE SHIFT CODES
;  THESE TABLES HAVE 1 BYTE ENTRIES AND THE TWO TABLES ARE INTERLEAVED

CODTSU==!.-2
CODTSL==!CODTSU+1
	.IRP	CODE,<CRS,EBC,BCD,CAL>
.IF DF X$$'CODE
	.BYTE	XSU'CODE#,XSL'CODE#
.ENDC
	.ENDM
	.PAGE
	.SBTTL	IMPURE DATA

	.PSECT	IMPURE,RW,D,LCL,REL,CON

;"THE STACK"

STKEND::.BLKW	100.
STKBGN::.BLKW	2

.IF EQ	..SAT
S::	.BLKB	100		;SCRATCH BUFFER
.ENDC

REQSTH::.WORD	0		;REQUEST HEAD POINTER
REQSTT::.WORD	0		;REQUEST TAIL POINTER

;TIMER DATA

TMRFRE::.WORD	0		;TIMER INDEX FREE LIST HEAD POINTER

TMRLST::.BLKW	NUMSOC+41	;INDEX OF NEXT ENTRY IN TIMER LIST (FIRST WORD
TMRTOP==!.-2			;  IN THIS TABLE IS THE HEAD POINTER)

TMRCNT::.BLKW	NUMSOC+41	;TIMER COUNT TABLE (FIRST WORD IN THIS TABLE IS
				;  THE CURRENT TIMER COUNT VALUE)

TMRSDB==.-2
	.BLKW	NUMSOC+40	;ADDRESS SDB FOR TIMER REQUEST (FIRST WORD OF
				;  OF THIS TABLE DOES NOT EXIST!)

TMRDSP==.-2
	.BLKW	NUMSOC+40	;DISPATCH ADDRESS FOR TIMER REQUEST (FIRST WORD
	.EVEN			;  OF THIS TABLE DOES NOT EXIST!)

;INTERRUPT BUFFER POINTERS FOR TERMINAL MODULE (TRM)

.IF NE TR.NUM

TRRNGT::.WORD	0		;BUFFER TAKER POINTER
TRRNGP::.WORD	0		;BUFFER PUTTER POINTER
TR0CON==!T0$+DDNCON
.ENDC

;Interrupt ring for type A line printers

.IF DF LPANUM
LPRING::.BLKW	2*LP.S0+2	; 1 word per socket plus safety margin
LPRNGE::			; End of ring (+2)
LPRNGP::.WORD	0		; Ring putter pointer
LPRNGT::.WORD	0		; Ring taker pointer
.ENDC
	.PAGE
	.SBTTL	DUMMY XDT USED IF XDT NOT LOADED

;THIS ROUTINE IS USED IN PLACE OF XDT IF XDT IS NOT LOADED - IF XDT IS LOADED
;  IT WILL OVERLAY THIS CODE

	.PSECT	.XDT.,RW,I,GBL,REL,OVR

.XDT.::	BR	XDT4			;INITIAL ENTRY - START NODE IF NO XDT
	BR	XDT2			;CRASH ENTRY - HALT
	.BLKW	1			;MUST KEEP THIS WORD OPEN SO XDT'S
					;  SYMBOL TABLE POINTER WILL WORK!

;HERE AFTER A NODE CRASH - CHECK ERROR TYPE - IF FATAL HALT, IF NON-FATAL
;  RESTART NODE

XDT2:
.IF EQ ..FTL
 .IF EQ	ROMFLG
	TSTB	SAVEEI#			;CHECK ERROR TYPE
	BNE	XDT3			;IF FATAL ERROR
	BIT	#$NSFTL,NODSTS#		; Should it be fatal anyway?
	BNE	XDT3			; Yes, so die big
	CMP	#30.,CRSCNT#		;DON'T LET THIS GO ON TOO LONG!
	BLO	XDT3
	JMP	START#			;OK-LETS TRY IT ALL AGAIN!
 .IFF
	JMP	GO#			;REINITIALIZE ON ERROR IN ROM
 .ENDC
.ENDC

;HERE FOR FATAL CRASH - HALT THE NODE!!

.IF EQ	ROMFLG
XDT3:	RESET
.IF EQ	..EIS
	BR	.			;DO THIS INSTEAD OF HALT FOR FALCON
.IFF
	HALT
.ENDC
.ENDC

;HERE FOR INITIAL STARTUP ENTRY - JUST START THE NODE

XDT4:	JMP	GO#
	.PAGE
;HANDLE TRACE LOGIC USED BY STATUS DEVICE
TRCINT::.IF DF	ST.NUM			;Do this if status device defined
	CMP	(SP),TRCADD#		;Is this the trace address
	BNE	10$			;Continue if not
	JMP	TRCCOD#			;Yes, dump registers
10$:	CLRPSW				;Allow interrupts
	CMP	@(SP),#6		;Is ths instruction to be executed a RTT
	BHI	30$			;No, neither RTT or RTI
	BEQ	20$			;Yes, a RTT
	CMP	@(SP),#2		;Is it a RTI
	BNE	30$			;No, continue as normal
20$:	CLR	2(SP)			;Let him restore PS, if we restore the 
					;T-bit then we get an extra interrupt
	BIS	#20,6(SP)		;Make sure T-bit is on in that PSW
.ENDC
30$:	RTT				;No, continue checking

;INSURE THAT SOME PSECTS END ON WORD BOUNDRIES AND DEFINE FINAL SYMBOLS
;  TO CHECK FOR PHASE ERRORS (MACRO-11 WILL NOT REPORT PHASE ERRORS UNLESS
;  THERE IS A LABEL INVOLVED!)

	.MACRO	PCHK  NAME,PAR
	.PSECT	NAME,PAR,REL
$.'NAME:	;AN ERROR ON THIS LINE MEANS IT HAS AN ODD NUMBER OF BYTES
	.EVEN
	.ENDM

	PCHK	LOWMEM,<RW,D,LCL,CON>
	PCHK	SX    ,<RW,D,LCL,CON>
	PCHK	PURE  ,<RW,D,LCL,CON>
	PCHK	CODE  ,<RW,I,LCL,CON>
	PCHK	MAIN  ,<RW,I,LCL,CON>
	PCHK	SECOND,<RW,I,LCL,CON>
	PCHK	TENTHS,<RW,I,LCL,CON>
	PCHK	INIT  ,<RW,I,LCL,CON>
	PCHK	FALCBT,<RW,I,GBL,OVR>
	PCHK	INIDAT,<RW,D,LCL,CON>
	PCHK	INIBYT,<RW,D,LCL,CON>
	PCHK	VECTBL,<RW,D,LCL,CON>
	PCHK	.XDT. ,<RW,I,GBL,OVR>
	PCHK	.SYM. ,<RW,D,GBL,OVR>
	PCHK	DDB   ,<RW,D,LCL,CON>
	PCHK	LDB   ,<RW,D,LCL,CON>
	PCHK	ADB   ,<RW,D,LCL,CON>
	PCHK	SDB   ,<RW,D,LCL,CON>
	PCHK	IMPURE,<RW,D,LCL,CON>
	PCHK	ONCE  ,<RW,I,LCL,CON>

	.END

[@lb