	.TITLE	LNKF3  - Interrupt routines for Tymshare host with DTE20 
	.SBTTL	LNKF3  - Tymshare/DRE

	XLPAR			;DON'T LIST PARAMETER FILES

;	Define the various DTE20 registers we expect to use

DLYCNT=	174400
DEXWD3=	174402
DEXWD2=	177404
DEXWD1=	177406
TENAD1=	177410
TENAD2=	177412
DIAG1=	177430
DIAG2=	177432
STATUS=	177434
DIAG3=	177436

	CODE


	.SBTTL	LNKF3 - MAIN CODE ROUTINE FOR DOING INPUT AND OUTPUT

	MAINXX	LKFPOL

LKFPOL:	MOV	#LKFDDB#,R4		;GET FIRST DDB
10$:	CALL	LKFINP			;SEE IF THER IS ANY INPUT FROM HOST
	CALL	LKFOUT			;SET IF WE HAVE ANY UNFINISHED BUSINESS WITH THE HOST
	MOV	DDLKNS#(R4),R4		;GET THE NEXT DDB
	BNE	10$			;GO PROCESS IT
	RETURN

;	LKFINP - INPUT CHECK AND TRANSFER ROUTINE

LKFINP:	TST	DDLFIK#(R4)		;IS MAIN STILL PROCESSING THE PREVIOUS PACKET
	BNE	50$			;YES, JUST RETURN
	MOV	#ORPPDP,R0
	CALL	EXMMEM			;READ THE 20'S MEMORY
	CMP	DDLIFP#(R4),DEXWD3	;HAS THE HOST OUTPRU RING POINTER CHANGED
	BNE	INPID2			;YES
50$:	RETURN				;NO - JUST RETURN
INPID2:	MOV	DDLIFP#(R4),R0		;GET THE RING OFFSET FOR THE DATA
	ADD	#ORING,R0		;ADD OFFSET TO DATA
	CALL	EXMMEM			;GET THE FIRST DATA
	MOV	DEXWD1,R2		;GET HIGH ORDER PART OF DATA
	MOV	DEXWD2,R0		;GET MIDDLE PART OF DATA
	MOV	DEXWD3,R3		;GET LOW PART OF DATA
	.REPT	4			;SHIFT DATA OVER FOUR BYTES
	ROR	R2			;COPY HIGH BIT TO CARRY
	ROR	R0			;COPY HIGHBIT TO MIDDLE WORD
	ROR	R3			;COPY MIDDLE BIT TO LOW WORD
	.ENDR
	MOV	R3,DDLFIX#(R4)		;STORE LOW DATA IN DDB
	MOV	R0,DDLFIX#(R4)		;STORE HIGH DATA IN DDB
	BMI	4$			;IF DATA MESSAGE
	SWAB	R0
	CMPB	#MAXMSG#,R0		;NO-VALID MESSAGE?
	BGE	3$			;YES
	CLR	R0			;NO!
	CLRB	DDLFIX#+1(R4)
3$:	BIC	#^C177,R0		;REMOVE JUNK
	MOVB	MSGLEN#(R0),DDLFIC#(R4)	;STORE WORD COUNT
	BISB	#1,DDLFIC#(R4)		;ROUND UP TO WHOLE PDP-10 WORDS
	MOV	#DDLFIX#+4,R0		;GET POINTER TO MESSAGE BUFFER
	ADD	R4,R0
	MOV	R0,DDLFIP#(R4)
	MOVB	#.ISMSG,DDLFIS#(R4)	;SET NEW INPUT STATE
	JMP	INPACP			;AND DISMISS

;HERE IF DATA STRING

4$:	SWAB	R0
	BIC	#^C177,R0		;GET BYTE COUNT
	MOV	R0,DDLFCC#(R4)		;STORE BYTE COUNT
	INC	R0			;CHANGE TO WORD COUNT
	ASR	R0
	ASR	R0
	INC	R0
	ASL	R0
	DEC	R0
	MOV	R0,DDLFIC#(R4)		;STORE WORD COUNT
	CALL	MAKPKI			;GET A PACKET
	MOV	R1,DDLFIK#(R4)		;STORE ADDRESS OF PACKET
	MOV	R1,DDLFIQ#(R4)
	ADD	#PKDATA,R1		;POINT TO FIRST DATA WORD
	MOV	R1,DDLFIP#(R4)		;STORE POINTER
	MOVB	#PKCMAX/2,DDLFPC#(R4)	;STORE COUNT IN PACKET
	INCB	DDLFIS#(R4)		;BUMP INPUT STATE
	BR	INPACP			;AND DISMISS INTERRUPT FOR NOW

;HERE WHEN EXPECTING WORD FOLLOWING PREFIX VALUE

INPBKX:	TST	R0			;WAS THE PREFIX REALLY DATA?
	BNE	INPXX2			;NO-GO ON
	MOV	#-1,R0			;YES-GET ITS VALUE
	BICB	#^C3,DDLFIS#(R4)	;RESTORE STATE
	MOVB	DDLFIS#(R4),R1		;GET STATE
	ASL	R1			;AND DISPATCH ON IT
	ADD	R1,PC
	BR	INPID2			;.ISIDL =  0 - IDLE
	BR	INPDA2			;.ISDAT =  1 - DATA
	BR	INPMS2			;.ISMSG =  2 - MESSAGE

;HERE WITH BLOCK MODE OUTPUT DATA FROM THE HOST

INPXX2:	CALL	MAKPKI			;GET A PACKET
	MOV	R1,DDLFBK#(R4)		;SAVE ADDRESS OF PACKET
	MOV	R1,DDLFBQ#(R4)
	ADD	#PKDATA,R1		;MAKE DATA POINTER
	MOV	R1,DDLFBW#(R4)		;AND STORE IT
	MOVB	#PKCMAX/2,DDLFBY#(R4)	;START COUNT
INPXXX:	ADD	#4,DDLFIS#(R4)		;BUMP STATE
	BR	INPACP			;THATS ALL FOR THIS TIME

;HERE WHEN EXPECTING DATA WORD FOR BLOCK MODE

INPBKB:	SWAB	R0			;PUT BYTES IN RIGHT ORDER
	MOV	R0,@DDLFBW#(R4)		;STORE IN PACKET
	DEC	DDLFBC#(R4)		;MORE COMING?
	BLE	INPBDN			;NO-FINISHED WITH THIS
	DECB	DDLFBY#(R4)		;YES-MORE ROOM IN THIS PACKET?
	BEQ	2$			;NO
	ADD	#2,DDLFBW#(R4)		;YES-JUST BUMP POINTER
	BR	INPACP			;AND DISMISS

;HERE IF MUST START A NEW PACKET

2$:	CALL	MAKPKI			;GET A PACKET
	MOV	R1,@DDLFBQ#(R4)		;LINK TO PREVIOUS PACKET
	MOV	R1,DDLFBQ#(R4)
	ADD	#PKDATA,R1		;POINT TO START OF DATA
	MOV	R1,DDLFBW#(R4)		;STORE POINTER
	MOVB	#PKCMAX/2,DDLFBY#(R4)	;RESET COUNT
	BR	INPACP			;AND DISMISS

;HERE WHEN BLOCK MODE IS FINISHED

INPBDN:	BICB	#^C3,DDLFIS#(R4)	;RESTORE THE STATE
	BISB	#$RQBLK,DDLFRQ#(R4)	;REQUEST MAIN PROGRAM SERVICE
	BR	INPDSM			;AND DISMISS

;HERE WHEN WAITING FOR RESET

INPRST:	SWAB	R0
	CMPB	#.MSHSI,R0		;IS IT "SPECIFY HOST PORTS"?
	BNE	INPACP			;NO-IGNORE IT!
	CLRB	DDLFIS#(R4)		;YES-CHANGE STATE
	SWAB	R0			;RESTORE DATA WORD
	JMP	INPID2			;AND GO PROCESS THE MESSAGE

;HERE WHEN EXPECTING A DATA WORD

INPDAT:	CMP	#-1,R0			;PREFIX VALUE?
	BEQ	INPXXX			;YES
INPDA2:	SWAB	R0			;GET BYTES IN RIGHT ORDER!
	MOV	R0,@DDLFIP#(R4)		;STORE DATA
	DECB	DDLFIC#(R4)		;REDUCE THE WORD COUNT
	BEQ	INPDON			;IF FINISHED NOW
	DECB	DDLFPC#(R4)		;MORE TO GET-WILL IT FIT IN THE CURRENT
					;  PACKET?
	BEQ	INPDA6			;NO-GO GET ANOTHER PACKET
INPDA4:	ADD	#2,DDLFIP#(R4)		;BUMP POINTER
INPACP:
INPDSM:	POP	R1			;RESTORE AC'S
	POP	R0
	POP	R4
	RTI				;DISMISS INTERRUPT

;HERE IF MUST ALLOCATE ANOTHER PACKET FOR A LONG DATA MESSAGE

INPDA6:	CALL	MAKPKI			;GET A PACKET
	MOV	R1,@DDLFIQ#(R4)		;LINK IN THE NEW PACKET
	MOV	R1,DDLFIQ#(R4)		;SAVE ITS ADDRESS
	ADD	#PKDATA,R1		;POINT TO FIRST DATA WORD
	MOV	R1,DDLFIP#(R4)		;STORE POINTER
	MOVB	#PKCMAX/2,DDLFPC#(R4)
	BR	INPACP			;GO FINISH UP

;HERE WHEN EXPECTING AN ARGUMENT WORD FOR A CONTROL MESSAGE


INPMSG:	CMP	#-1,R0			;PREFIX VALUE?
	BEQ	INPXXX			;YES
	SWAB	R0			;NO-PUT BYTES IN RIGHT ORDER
	MOV	R0,@DDLFIP#(R4)		;STORE DATA
INPMS2:	DECB	DDLFIC#(R4)		;EXPECTING MORE?
	BGT	INPDA4			;YES
					;NO-FALL INTO INPDON

;HERE WHEN FINISHED DOING INPUT - NOTIFY MAIN PROGRAM LEVEL

INPDON:	MOVB	#.ISWAT,DDLFIS#(R4)	;SET NEW INPUT STATE
	BISB	#$RQINP,DDLFRQ#(R4)	;REQUEST INPUT SERVICE
	BR	INPDSM			;AND DISMISS INTERRUPT

;HERE IF GET INPUT INTERRUPT WHILE WAITING FOR MAIN PROGRAM LEVEL TO PROCESS
;  SOME INPUT - THIS IS AN ERROR SINCE WE HAVE NOT YET ACCEPTED THE LAST
;  INPUT WORD!

INPWAT:	INC	DDERSI#(R4)		;COUNT THE FUNNY INTERRUPT!
	BR	INPDSM			;AND TRY TO CONTINUE (PROBABLY WE ARE
					;  TOO SICK TO CONTINUE AT THIS POINT!)
	.PAGE
;SUBROUTINE TO GET A PACKET FOR INPUT INTERRUPT ROUTINE
;	CALL	MAKPKI
;	C(R1) = ADDRESS OF PACKET
;  WARNING *** WHEN CALLED THE STACK MUST BE SET UP AS FOLLOWS:
;	C((SP))    = SAVED C(R1)
;	C((SP)-2)  = SAVED C(R0)
;	C((SP)-4)  = SAVED C(R4)
;	C((SP)-6)  = INTERRUPT RETURN ADDRESS
;	C((SP)-10) = INTERRUPT RETURN PSW

MAKPKI:	MAKPKT	.PLOPT#			;GET A PACKET
	BCS	2$			;If none available
	RETURN				;Finished if got one

;Here if no packet is available now

2$:	TST	DDLFXR#(R4)		;NONE AVAILABLE-ARE WE RECOVERING NOW?
	BEQ	4$			;NO-OK
	FSTOP	PWE			;[PACKET WAIT ERROR]

4$:	POP	DDLFX1#(R4)		;SAVE RETURN ADDRESS
	MOV	#INTRCV,DDLFXR#(R4)	;STORE ADDRESS OF RECOVERY ROUTINE
	BR	INPDSM			;AND GIVE UP FOR NOW!

;HERE AT MAIN PROGRAM LEVEL WHEN HAVE A PACKET AVAILABLE

INTRCV:	SETPSW	DDLFPL#(R4)		;RAISE TO INTERRUPT LEVEL
	MOV	(SP),R0			;GET RETURN ADDRESS
	CLR	(SP)			;PUT FAKE PSW ON THE STACK
	PUSH	R0			;THEN THE RETURN ADDRESS
	PUSH	R4			;THEN R4
	SUB	#4,SP			;THEN 2 GRABBAGE WORDS
	JMP	@DDLFX1#(R4)		;CONTINUE WHERE WE LEFT OFF!
	.SBTTL	LNKF3  - Input interrupt routine - ignore door bell

;HERE FROM CODE IN COMMON ON INPUT READY INTERRUPT
;  THE CODE EXECUTED BEFORE WE GET HERE IS AS FOLLOWS:
;	LKFIn:	PUSH	R4		;SAVE R4
;		MOV	#LKFn$,R4	;GET ADDRESS OF DDB
;		JMP	LKFIIN		;GO TO COMMON ROUTINE

LKFIN1:: POP	R4
	RTI

	.PAGE
	.SBTTL	LNKF3  - Output interrupt routine

;HERE FROM CODE IN COMMON ON OUTPUT DONE INTERRUPT
;  THE CODE EXECUTED BEFORE WE GET HERE IS AS FOLLOWS:
;	LKFOn:	PUSH	R4		;SAVE R4
;		MOV	$HSn$,R4	;GET ADDRESS OF DDB
;		JMP	LKFOIN		;GO TO COMMON ROUTINE

LKFOU1::	PUSH	R0			;SAVE ANOTHER AC
	ADD	DDLFOS#(R4),PC		;DISPATCH ON OUTPUT STATE
	BR	LFONRM			;.OSNRM = 0 - NORMAL OUTPUT
	BR	LFOHLD			;.OSHLD = 2 - OUTPUT HELD BLOCK DATA
	BR	LFOBLK			;.OSODD = 4 - OUTPUT NON-ALLIGNED DATA
	BR	LFONRM			;.OSBMO = 6 - START OF BLOCK MODE -
					;		SAME AS .OSNRM

;HERE TO OUTPUT NON-ALLIGNED DATA

LFOBLK:	DECB	DDLFOC#(R4)		;MORE TO OUTPUT?
	BLT	OUTDON			;NO
	CLR	R0			;YES-GET THE WORD TO OUTPUT
	BISB	@DDLFOP#(R4),R0
	INC	DDLFOP#(R4)
	SWAB	R0
	BISB	@DDLFOP#(R4),R0
	INC	DDLFOP#(R4)
	BR	OUTPTI			;AND GO OUTPUT IT

;HERE TO OUTPUT 2ND WORD OF THE BLOCK MODE HOLD BUFFER

LFOHLD:	CLR	DDLFOS#(R4)		;ASSUME ALLIGNED
	BIT	#1,DDLFOP#(R4)		;IS THE FOLLOWING OUTPUT WORD ALLIGNED?
	BEQ	2$			;YES
	MOV	#.OSODD,DDLFOS#(R4)	;NO-MUST DO IT THE HARD WAY!
2$:	MOV	DDLFOZ#(R4),R0		;GET ADDRESS OF SDB
	MOV	SDLFVH#+2(R0),R0	;GET WORD TO OUTPUT
	BR	OUTPTX			;AND GO OUTPUT IT

;HERE FOR NORMAL OUTPUT

LFONRM:	DECB	DDLFOC#(R4)		;ANY MORE TO OUTPUT?
	BLT	OUTDON			;NO
	MOV	@DDLFOP#(R4),R0		;YES-GET WORD
	ADD	#2,DDLFOP#(R4)		;BUMP OUTPUT POINTER
OUTPTX:	SWAB	R0			;PUT BYTES IN RIGHT ORDER
OUTPTI:;	MOV	R0,@DDLFOR#(R4)		;OUTPUT IT
OUTDSM:	POP	R0			;RESTORE AC'S
	POP	R4
	RTI				;AND DISMISS

;HERE IF FINISHED WITH THIS MESSAGE

OUTDON:	BISB	#$RQOUT,DDLFRQ#(R4)	;REQUEST OUTPUT SERVICE
	BR	OUTDSM			;AND DISMISS


; LKFENB -SUBROUTINE TO ENABLE THE DTE20

LKFENB:: ADD	#2,(SP)			;SKIP RETURN ON SUCCESS
20$:	RETURN				;THATS ALL

; LKFDII - DISABLE THE INTERFACE

LKFDII::; CLR	@DDLFSR#(R4)		;DISABLE THE INTERFACE
	RETURN

; LKFACP - ACCEPT THE LAST WORD OF A BLOCK AND ENABLE FOR MORE DATA

LKFACP:: RETURN

;LKFSTO - START AN OUTPUT SEQUENCE

LKFSTO::;MOV	R0,@DDLFOR#(R4)		;OUTPUT THE WORD
	RETURN

;LKFCLR - CLEAR OUR BITS IN THE DR11C

LKFCLR:: RETURN
	.END
