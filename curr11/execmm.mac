	.TITLE	EXEC NETWORK EXECUTIVE ROUTINES
	.SBTTL	EXEC   - NEXILIS/JRG

	XLPAR			;DON'T LIST PARAMETER FILE

.IIF NDF ..MM  ..MM=!1		;DEFAULT IS MEMORY MANAGEMENT STUFF

;GENERATE SPECIAL LOW MEMORY LOCATIONS

	.PSECT	LOWMEM,RW,D,LCL,REL,CON

GO::	JMP	@#ONCXDT#	;1000 - NORMAL NODE STARTING ADDRESS
DBGENT::JMP	@#ONCXDT#	;1004 - XDT STARTING ADDRESS
	.WORD	0		;1010 - RESERVED
	.WORD	0		;1012 - RESERVED
	.WORD	0		;1014 - RESERVED
	.WORD	0		;1016 - RESERVED
NODSTS::.WORD	0		;1020 - NODE STATUS WORD
CRSCNT::.WORD	0		;1022 - RESTART COUNT
PUREST:	.WORD	DDB#		;1024 - BEGINING OF DDBS
	.WORD	LDB#		;1026 - BEGINING OF LDBS
	.WORD	SDB#		;1030 - BEGINING OF SDBS
	.WORD	SXTBL#		;1032 - BEGINING OF SDB TABLE
VERLOC::.WORD	VERNO#		;1034 - Version number
	.WORD	EDTNO#		;1036 - Edit number
	.ASCII	'COPYRIGHT 1981, Tymshare, Inc., Cupertino, Ca.'
	.EVEN
	.PAGE
	.SBTTL	EXEC   - RESTART ROUTINE

	PSECT	MAIN,RW,I,LCL,REL,CON

;HERE TO RESTART NODE

START::	RESET				;RESET THE WORLD
	MOV	#STKBGN#,SP		;INITIALIZE STACK POINTER
	SETPSW	#340			;NO INTERRUPTS NOW
	INC	CRSCNT			;BUMP THE RESTART COUNT

;HERE TO CLEAR IMPURE AREA

	MOV	#IMPCLR#,R0		;GET FIRST ADDRESS TO CLEAR
	MOV	#IMPEND#,R1		;GET NUMBER OF WORDS TO CLEAR
	SUB	R0,R1
	ASR	R1
CLRIMP:	CLR	(R0)+			;CLEAR A WORD
	SOB	R1,CLRIMP		;CONTINUE IF MORE TO CLEAR
	MOV	#STKUND#,STKBGN#	;SET UP STACK UNDERFLOW TRAP
	MOV	#STKUND,STKBGN+2

;HERE TO INITIALIZE PACKET SPACE

	CALL	PKTINI#			;INITIALIZE PACKET SPACE

;HERE TO INITIALIZE ALL OPTIONAL SERVICE ROUTINES

	MOV	#DXTBL#,R0		;SET POINTER TO DX TABLE
DEVIN1:	MOV	(R0)+,R4		;GET ADDRESS OF DDB
	PUSH	R0			;SAVE POINTER
	MOV	#DDCBGN#,R1		;FIRST WORD TO CLEAR
	ADD	R4,R1
	MOV	#DDCSIZ#,R2		;NUMBER OF WORDS TO CLEAR
2$:	CLR	(R1)+			;CLEAR A WORD
	SOB	R2,2$			;LOOP IF MORE
	CLRB	DDNCON#(R4)
	CALL	@DDDDBI#(R4)		;CALL INITIALIZATION ROUTINE
	MOV	DDSX#(R4),R1		;GET ADDRESS OF FIRST SX TABLE ENTRY
					;  FOR DEVICE
	CLR	R2			;GET NUMBER OF SOCKETS ON DEVICE
	BISB	DDSOC#(R4),R2
	MOV	DDWLD#(R4),SD		;GET WILD SDB
	BEQ	DEVIN3			;IF NONE
	INC	R2			;HAVE ONE-INCLUDE IT IN THE COUNT
	BR	DEVIN4			;CONTINUE

DEVIN3:	MOV	(R1)+,SD		;GET ADDRESS OF SDB
DEVIN4:	PUSH	R1			;SAVE THE POINTER
	PUSH	R2			;AND SAVE THE COUNT
	CLR	(SD)			;CLEAR LINK WORD
	MOV	#SDCBGN#,R1		;ADDRESS OF FIRST WORD TO CLEAR
	ADD	SD,R1
	MOV	#SDCSIZ#,R2		;NUMBER OF WORDS TO CLEAR
2$:	CLR	(R1)+			;CLEAR A WORD
	SOB	R2,2$			;LOOP IF MORE
	CLRB	SDPCNT#(SD)
	DEC	SDREQL#(SD)		;SET THE REQUEST LINK WORD TO -1
	CALL	@DDSDBI#(R4)		;INITIALIZE DEVICE DEPENDENT PART
	POP	R2			;RESTORE COUNT
	POP	R1			;AND RESTORE POINTER
	SOB	R2,DEVIN3		;CONTINUE IF MORE SDB'S
	POP	R0			;FINISHED-RESTORE DX TABLE POINTER
	CMP	#DXTOP#,R0		;FINISHED WITH ALL DEVICES?
	BHIS	DEVIN1			;NO-CONTINUE
	CALL	INISUB#			;YES-INITIALIZE SOME OPTIONAL STUFF

;HERE TO INITIALIZE THE TIMER INDEX FREE LIST

	MOV	#TMRLST+2,R0		;INITIALIZE POINTER
	MOV	#4,R1			;INITIALIZE VALUE
TIMINI:	MOV	R1,(R0)+		;STORE VALUE
	ADD	#2,R1			;BUMP VALUE
	CMP	#TMRTOP#,R0		;FINISHED?
	BHI	TIMINI			;NO-CONTINUE
	MOV	#2,TMRFRE#		;YES-SET HEAD POINTER

;HERE TO INITIALIZE LINE FREQUENCY CLOCK IF NECESSARY

	MOV	#100,@#CLKREG#		;ENABLE THE CLOCK
	NXMJMP	2$			;DON'T WORRY IF ITS NOT THERE!
2$:	CLR	LPSCNT			;CLEAR THE LOOPS-PER-SECOND COUNTER

;HERE TO WRITE PROTECT SEGMENT 0 IF WE HAVE AN MMU

.IF NE ..MM				;THIS IS OPTIONAL!

	TST	@#177572		;DO WE HAVE AN MMU?
	NXMJMP	INICMP			;NO
	CLR	R0			;YES-SETUP ADDRESS REGISTERS FOR 1-TO-1
	MOV	#172340,R1		;  VIRTUAL TO PHYSICAL MAPPING
	MOV	#7,R2
25$:	MOV	R0,(R1)+
	ADD	#200,R0			;BUMP PHYICAL ADDRESS
	SOB	R2,25$
	MOV	#7600,(R1)		;AND THE I/O PAGE
	MOV	#172300,R1		;SETUP PARAMETER REGISTERS
	mov	#purend#,r2
	ashi	-13.,r2			;The number of pure pages
	bic	#177770,r2
	push	r2
;	MOV	#<PUREND/20000>,R2	;The number of pure pages
3$:	MOV	#77402,(R1)+		;SEGMENT IS READ ONLY
	SOB	R2,3$
	MOV	#77406,R0		;ALL OTHERS ARE READ-WRITE
	mov	#8.,r2
	sub	(sp)+,r2
;	MOV	#8.-<PUREND/20000>,R2
4$:	MOV	R0,(R1)+
	SOB	R2,4$
	MOV	#MMVIOL,@#250		;SETUP THE VECTOR
	MOV	#340,@#252
	MOV	#1,@#177572		;ENABLE THE MMU
	BR	INICMP			;THATS ALL

;HERE WHEN WE HAVE MMU VIOLATION

MMVIOL:	FSTOP	MMV			;[MEMORY MANAGEMENT VIOLATION]

.ENDC	; .IF NE ..MM

;HERE WITH INITIALIZATION COMPLETE

INICMP:	CLRPSW				;ALLOW INTERRUPTS NOW
					;FALL INTO THE MAIN PROGRAM LOOP
	.PAGE
	.SBTTL	EXEC   - MAIN PROGRAM LOOP

MAINLP::MOV	CKSPNT,R0		;GET CHECK-SUM POINTER
	CMP	R0,#NODSTS		;DOES IT POINT TO THE LOW MEMORY AREA?
	BNE	1$			;NO-GO ON
	MOV	#PUREST,R0		;YES-BUMP IT PAST THE IMPURE STUFF
1$:	ADD	(R0)+,CKSWRD		;ADD INTO CURRENT TOTAL
	CMP	#PUREND#,R0		;AT TOP YET?
	BHI	10$			;NO-GO ON
	TST	CKSFLG#			;YES-HAS THE CHECK-SUM BEEN SET YET?
	BNE	2$			;YES
	MOV	CKSWRD,CKSVAL#		;NO-SET IT NOW
	INC	CKSFLG#			;INDICATE ITS SET NOW
	BR	6$			;CONTINUE

;HERE IF CHECK-SUM VALUE HAS ALREADY BEEN SET

2$:	TBBN	$NSNCS,NODSTS,6$	;GO ON IF DO NOT WANT TO CHECK HERE!
	TBBE	$NSRCS,NODSTS,3$	;SHOULD WE RECALCULATE THE CHECKSUM?
	CLR	CKSFLG#			;YES-INDICATE WANT NEW VALUE
	BIC	#$NSRCS,NODSTS		;CLEAR THE REQUEST
	BR	6$			;AND RESTART

3$:	CMP	CKSVAL#,CKSWRD		;IS THE CHECKSUM RIGHT?
	BEQ	6$			;YES
	FSTOP	CSE			;[CHECK-SUM ERROR]

;HERE TO BEGIN MEMORY SCAN AGAIN

6$:	CLR	CKSWRD			;CLEAR RUNNING TOTAL
	CLR	R0			;AND CLEAR POINTER
10$:	MOV	R0,CKSPNT		;UPDATE THE POINTER

;HERE WHEN FINISHED WITH THE MEMORY CHECK-SUM ROUTINE

MAINL2:	INC	LPSCNT			;INCREMENT THE LOOP COUNTER
	BPL	10$			;DO WE HAVE A RESONABLE NUMBER?
	MOV	#LTCMSG,R1		;NO- TYPE MESSAGE TO THAT EFFECT
	CALL	CTYSTR#			;CHUG OUT A MESSAGE
	CLR	LPSCNT
10$:	TST	CLKFLG			;HAS CLOCK TICKED?
	BEQ	MAINL6			;NO-GO ON
	DEC	CLKFLG			;YES-DECREMENT CLOCK FLAG
	ADD	#1,UPTIME		;INCREASE UP-TIME
	ADC	UPTIME+2
TIMLP1:	MOV	TMRLST,R2		;GET FIRST ENTRY IN CLOCK QUEUE
	BEQ	TIMLP5			;IF QUEUE IS EMPTY NOW
	CMP	TMRCNT#(R2),TMRCNT	;TIME TO SERVICE FIRST ENTRY?
	BHI	TIMLP3			;NO-GO ON
	MOV	TMRLST#(R2),TMRLST#	;YES-REMOVE IT FROM THE QUEUE
	MOV	TMRSDB#(R2),SD		;POINT TO THE SDB
	MOV	SDDDB#(SD),R4		;AND TO THE DDB
	MOV	TMRFRE#,TMRLST#(R2)	;PUT TIMER INDEX ON THE FREE LIST
	MOV	R2,TMRFRE#
	CALL	@TMRDSP#(R2)		;DISPATCH TO ROUTINE
	BR	TIMLP1			;AND CHECK NEXT ENTRY IN CLOCK QUEUE
LTCMSG:	.ASCIZ	<CR><LF>"LTC FAILURE"

;HERE IF FIRST ENTRY IN CLOCK QUEUE DOES NOT NEED SERVICE YET

TIMLP3:	BIT	#140000,TMRCNT#		;GET TIME COUNT WORD
	BEQ	TIMLP6			;GO ON IF IT HASN'T OVERFLOWED

;HERE IF THE TIME COUNT WORD IS TOO LARGE - WHEN THIS HAPPENS WE SCAN THE CLOCK
;  QUEUE AND SUBTRACT THE CURRENT VALUE OF CURTIM FROM SDTCNT FOR EACH ENTRY
;  IN THE QUEUE.  THIS DOES NOT CHANGE THE TIME AT WHICH EACH ENTRY WILL BE
;  SERVICED.  THIS WILL BE REQUIRED VERY SELDOM, IF EVER!  DOING THIS ALLOWS
;  US TO USE CONVENTIONAL INSTEAD OF CIRCULAR COMPARES WHEN CHECKING THE TIME
;  COUNT WORDS!

	MOV	TMRCNT#,R0		;GET TIME COUNT WORD
	MOV	TMRLST,R2		;SET TO SCAN CLOCK QUEUE
TIMLP4:	SUB	R0,TMRCNT#(R2)		;FIX UP TIME COUNT IN QUEUE ENTRY
	MOV	TMRLST#(R2),R2		;STEP TO NEXT ENTRY
	BNE	TIMLP4			;CONTINUE IF NOT FINISHED
					;FALL INTO TIMLP5 TO CLEAR COUNT

;HERE IF CLOCK QUEUE IS EMPTY - THIS ALLOWS US TO RESET THE TIME COUNT INORDER
;  TO MAKE OVERFLOWS (SEE TIMLP3) VERY UNLIKELY!

TIMLP5:	CLR	TMRCNT#			;CLEAR TIME COUNT WORD

;HERE WHEN FINISHED WITH THE CLOCK QUEUE FOR THIS TIME

TIMLP6:	INC	TMRCNT#			;INCREMENT TIME COUNT
	DECB	TENCNT			;TIME FOR TEN-TIMES-A-SECOND STUFF?
	BGT	TIMLP7			;NO-GO ON
	MOVB	#JIFO10#,TENCNT		;YES-RESET COUNTER
	CALL	TENTHS#			;CALL TENTH-SECOND ROUTINES

TIMLP7:	DECB	SECCNT			;TIME FOR ONCE-A-SECOND STUFF?
	BGT	TIMLP8			;NO-GO ON
	MOVB	#JIFSEC#,SECCNT		;YES-RESET COUNTER
	MOV	LPSAVG,R0		;GET CURRENT LOOPS-PER-SECOND AVERAGE
	ASR	R0			;TIMES (1-ALPHA) = 0.75
	MOV	R0,R1
	ASR	R1
	ADD	R1,R0
	MOV	LPSCNT,R2		;GET NUMBER OF LOOPS THIS TIME
	ASR	R2			;TIMES ALPHA = 0.25
	ASR	R2
	ADD	R2,R0			;CALCULATE NEW AVERAGE
	MOV	R0,LPSAVG		;AND STORE IT
	CLR	LPSCNT			;RESET THE COUNTER
	CALL	SECOND#			;CALL ONCE-A-SECOND ROUTINES
TIMLP8:	TST	CLKFLG			;SEE IF WE GOT THE CLOCK DOWN TO ZERO
	BEQ	MAINL6			;EVERY THING IS FINE
	DEC	CLKFLG			;DECREASE COUNT
	ADD	#1,UPTIME
	ADC	UPTIME+2
	BR	TIMLP7			;GO CHECK ONCE A SECOND AGAIN

;HERE WHEN FINISHED WITH CLOCK STUFF - THIS IS THE REAL MAIN PROGRAM FOR THE
;  NODE

MAINL6:	MOV	REQSTH#,SD		;GET SDB WITH REQUEST
	BEQ	MAINL8			;IF NO MORE REQUESTS
	MOVB	SDREQB#(SD),R0		;GET REQUEST BITS
	BNE	2$			;FOR DEBUGGING
	RSTOP	NRB			;[NO REQUEST BITS SET]

2$:	CLR	R2			;CLEAR COUNTER
4$:	INC	R2			;BUMP COUNTER
	ROLB	R0			;GET NEXT BIT
	BCC	4$			;CONTINUE IF NOT SET
	BICB	BITTBL-1(R2),SDREQB#(SD);CLEAR THE REQUEST BIT
	BNE	10$			;LEAVE SDB IN LIST IF OTHER REQUEST(S)
	MOV	SDREQL#(SD),REQSTH#	;OTHERWISE REMOVE FROM LIST
	BNE	6$			;IS LIST EMPTY NOW?
	CLR	REQSTT#			;YES-CLEAR TAIL POINTER
6$:	MOV	#-1,SDREQL#(SD)		;INDICATE THIS SDB NOT IN LIST NOW
10$:	MOV	SDDDB#(SD),R4		;GET ADDRESS OF DDB
	ASL	R2			;FOR WORD INDEXING
	CALL	@REQDSP-2(R2)		;DISPATCH ON THE REQUEST
	BR	MAINL6			;GO CHECK FOR OTHER REQUESTS

;HERE AFTER ALL REQUESTS HAVE BEEN SERVICED

MAINL8:					;CALLS TO MAIN PROGRAM ROUTINES ARE
					;  LINKED HERE FOLLOWED BY "JMP MAINLP"

;REQUEST DISPATCH TABLE

	PURE

	.EVEN
REQDSP:	.WORD	POKSER		;.RQPOK = 200 - POKE
	.WORD	RSMSER		;.RQRSM = 100 - RESUME

;BIT TABLE

BITTBL:	.BYTE	200,100

	CODE
	.PAGE
	.SBTTL	EXEC   - POKSER - POKE SERVICE

POKSER:	MOV	SDPKDH#(SD),R1		;GET DST PACKET ADDRESS
	BEQ	RTN001			;FORGET IT NO PACKET!
	JMP	@DDPOKE#(R4)		;DISPATCH TO ROUTINE FOR DEVICE

	.SBTTL	EXEC   - RSMSER - RESUME SERVICE

RSMSER:	CALL	@DDRSUM#(R4)		;CALL ROUTINE FOR DEVICE
	DECB	SDRSMC#(SD)		;REDUCE RESUME COUNT
	BGT	RSMSER			;IF SHOULD DO IT AGAIN
RTN001:	RETURN				;FINISHED
	.PAGE
	.SBTTL	EXEC   - 60 CYCLE CLOCK INTERRUPT ROUTINE

	CODE

;THIS INTERRUPT ROUTINE IS EXECUTED EACH TIME THE 60 CYCLE CLOCK INTERRUPTS.
;  ALL IT DOES IS SET A FLAG WHICH IS CHECKED IN THE MAIN PROGRAM LOOP

	VECTOR	100,CLKINT,7

CLKINT:	INC	CLKFLG			;SET THE FLAG
RTNRTI::RTI				;DISMISS INTERRUPT

	.SBTTL	EXEC   - GO TO BOOTSTRAP

;COME HERE TO STOP NODE AND START BOOTSTRAP

GOBOOT::SETPSW	#340			;NO MORE INTERRUPTS (EVER!)
	CMP	#GO,#1000		;IS THIS A NORMAL NODE?
	BNE	2$			;NO-ITS A MXV NODE!!
	JMP	@#173000		;YES-JUST JUMP TO THE BOOTSTRAP

;HERE FOR MXV NODE

2$:	JMP	@24			;FAKE A "POWER FAIL TRAP"!
	.PAGE
	.SBTTL	EXEC   - COMMON SUBROUTINES

;SUBROUTINE TO PLACE REQUEST INTO THE TIMER LIST
;	C(R0) = NUMBER OF TICKS UNTIL REQUEST IS SERVICED
;	C(R1) = DISPATCH INDEX
;	C(SD) = ADDRESS OF SDB
;	CALL	TIMREQ
;	C:SET = CANNOT ENTER REQUEST
;  R0 AND R1 ARE DESTROYED

TIMREQ::PUSH	R3			;SAVE R3
	MOV	TMRFRE#,R3		;GET TIMER INDEX FROM FREELIST
	BEQ	TIMERR			;IF NONE LEFT
	PUSH	R2			;SAVE R2 TOO
	MOV	TMRLST#(R3),TMRFRE#	;REMOVE FROM FREELIST
	MOV	SD,TMRSDB#(R3)		;STORE SDB ADDRESS
	ADD	TMRCNT#,R0		;CALCULATE STOP TIME
	BCC	10$			;EVERYTHING IS OK NOW
	MOV	#MAXTIME#,R0		;SET TIME TO MAXIMUM POSSIBLE
10$:	MOV	R0,TMRCNT#(R3)		;STORE IT
	MOV	R1,TMRDSP#(R3)		;STORE DISPATCH ADDRESS
	CLR	R1			;GET INITIAL PRED. POINTER
TIMRQ1:	MOV	TMRLST#(R1),R2		;GET NEXT ENTRY
	BEQ	TIMRQ2			;IF END OF LIST
	CMP	TMRCNT#(R2),R0		;DOES THE NEW ENTRY GO HERE?
	BHIS	TIMRQ2			;YES
	MOV	R2,R1			;NO-ADVANCE POINTER
	BR	TIMRQ1			;CONTINUE

;HERE WITH POSITION FOR NEW ENTRY

TIMRQ2:	MOV	R2,TMRLST#(R3)		;LINK IN THE NEW ENTRY
	MOV	R3,TMRLST#(R1)
	POP	R2			;RESTORE R2
TIMRQ4:	POP	R3			;RESTORE R3
	CLC				;GIVE GOOD RETURN
	RETURN

;SUBROUTINE TO REMOVE REQUEST FROM THE TIMER LIST
;	C(R1) = DISPATCH INDEX FOR ENTRY TO REMOVE
;	C(SD) = ADDRESS OF SDB
;	CALL	TIMKIL
;	C:SET = NO SUCH ENTRY IN TIMER LIST
;  R0 AND R1 ARE DESTROYED

TIMKIL::PUSH	R3			;SAVE R3
	CLR	R0			;GET INITIAL PRED. POINTER
TIMKL1:	MOV	TMRLST#(R0),R3		;GET NEXT ENTRY
	CMP	TMRSDB#(R3),SD		;FOR THIS SDB?
	BNE	2$			;NO-GO ON
	CMP	TMRDSP#(R3),R1		;YES-FOR THIS DISPATCH?
	BEQ	TIMKL2			;YES-FOUND IT!
2$:	MOV	R3,R0			;NO-ADVANCE TO NEXT ENTRY
	BNE	TIMKL1			;CONTINUE IF MORE TO CHECK
TIMERR:	POP	R3			;RESTORE R3
RTNCS3:	SEC				;END OF LIST-INDICATE FAILURE
RTN003:	RETURN				;AND RETURN

;HERE WITH ENTRY TO REMOVE

TIMKL2:	MOV	TMRLST#(R3),TMRLST#(R0)	;REMOVE FROM TIMER LIST
	MOV	TMRFRE#,TMRLST#(R3)	;AND PUT ON FREELIST
	MOV	R3,TMRFRE#
	TST	TMRLST#			;IS TIMER LIST EMPTY NOW?
	BNE	TIMRQ4			;NO-FINISHED
	CLR	TMRCNT			;YES-CLEAR COUNT
	BR	TIMRQ4			;FINISHED NOW
	.PAGE
;SUBROUTINE CALLED TO SET NEW PROCESSOR STATUS
;  THIS SUBROUTINE IS USUALLY CALLED WITH THE "SETPSW" MACRO AS FOLLOWS:
;	SETPSW	VALUE
;  THIS GENERATES ONE OF THE FOLLOWING:
;	PUSH	VALUE			;IF VALUE .NE. 0
;	CALL	RTNRTI
;  OR
;	CLR	-(SP)			;IF VALUE .EQ. 0
;	CALL	RTNRTI

;RTNRTI::RTI			;NO NEED TO PUT THIS HERE - JUST USES THE
				;  RTI INSTRUCTION IN THE CLOCK ROUTINE!!

;SUBROUTINE TO GET PROCESSOR STATUS
;	CALL	GETPSW
;	C(R0) = PROCESSOR STATUS WORD

GETPSW::MOV	@#PSW,R0		;GET PROCESSOR STATUS *** ONCE ***
	RETURN				;THATS ALL!
	.PAGE
;SUBROUTINE TO CONVERT 3 ASCII CHARACTERS TO RADIX-50
;	C(R2) = ADDRESS OF FIRST CHARACTER
;	CALL	XXRD50
;	C(R0) = RADIX-50 WORD
;	C(R1) = UNCHANGED

XXRD50::PUSH	R1			;SAVE R1
	CLR	R1			;CLEAR RESULT REEGISTER
	MOV	#3,R3			;SET COUNTER
XXRD5A:	MOVB	(R2)+,R0		;GET CHARACTER
	BEQ	XXRD5H			;TREAT NULLS LIKE SPACE!
	CMP	#140,R0			;IS IT LOWER CASE?
	BGT	XXRD5B			;NO-GO ON
	BIC	#40,R0			;YES-CHANGE TO UPPER CASE
XXRD5B:	CMP	#'A,R0			;IS IT A LETTER?
	BGT	XXRD5C			;NO
	CMP	#'Z,R0			;MAYBE
	BLT	XXRD5G			;NO
	BIC	#100,R0			;YES-CONVERT TO RADIX 50 VALUE
	BR	XXRD5H			;AND CONTINUE

;HERE IF NOT LETTER

XXRD5C:	CMP	#'0,R0			;IS IT A NUMBER?
	BGT	XXRD5D			;NO
	CMP	#'9,R0			;MAYBE
	BLT	XXRD5G			;NO
	SUB	#22,R0			;YES-CONVERT TO RADIX 50 VALUE
	BR	XXRD5H			;AND CONTINUE

;HERE IF NOT NUMBER

XXRD5D:	CMP	#'$,R0			;IS IT $ ?
	BNE	XXRD5E			;NO
	MOV	#33,R0			;YES
	BR	XXRD5H			;CONTINUE

;HERE IF NOT $

XXRD5E:	CMP	#'.,R0			;IS IT . ?
	BNE	XXRD5F			;NO
	MOV	#34,R0			;YES
	BR	XXRD5H			;CONTINUE

;HERE IF NOT .

XXRD5F:	CMP	#SPA,R0			;IS IT SPACE?
	BNE	XXRD5G			;NO
	CLR	R0			;YES
	BR	XXRD5H			;CONTINUE

;HERE IF NOT SPACE

XXRD5G:	MOV	#35,R0			;UNKNOWN CHARACTER-USE UNDEFINED VAUE!
XXRD5H:	MUL	#50,R1			;MAKE ROOM IN R1
	ADD	R0,R1			;ADD IN THIS CHARACTER
	SOB	R3,XXRD5A		;CONTINUE IF MORE TO DO
	MOV	R1,R0			;GET RESULT IN RIGHT AC
	POP	R1			;RESTORE R1
	RETURN				;OTHERWISE FINISHED
	.PAGE
;SUBROUTINE TO CONVERT RADIX-50 WORD TO ASCII STRING
;	C(R0) = INITIAL COUNT1 
;	C(R1) = POINTER TO OUTPUT STRING
;	C(R4) = ADDRESS OF RADIX-50 WORD
;	CALL	RD50XX
;	C(R0) = PREVIOUS CONTENTS + NUMBER OF CHARACTER CONVERTED
;	C(R1) = UPDATED POINTER (POINTS AFTER LAST CHARACTER CONVERTED)
;	C(R4) = ADDRESS OF NEXT WORD AFTER RADIX-50 WORD

RD50XX::PUSH	SD			;SAVE A REGISTER
	CLR	SD			;INITIALIZE OUR COUNTER
	MOV	(R4)+,R3		;GET RADIX-50 WORD
RD50X1:	CLR	R2			;DIVIDE BY 50
	DIV	#50,R2
	PUSH	R3			;SAVE REMAINDER
	INC	SD			;COUNT IT
	MOV	R2,R3			;GET IN RIGHT AC
	BNE	RD50X1			;CONTINUE IF MORE
RD50X2:	POP	R2			;GET CHARACTER
	BEQ	RD50X6			;IGNORE SPACES
	CMP	#33,R2			;CONVERT TO ASCII VALUE
	BGT	3$			;IF LETTER
	BEQ	1$			;IF $
	CMP	#35,R2
	BNE	2$			;IF NUMBER OR PERIOD
	ADD	#31,R2			;IF UNDEFINED CHARACTER (CONVERT TO ?)
1$:	SUB	#11,R2
2$:	SUB	#56,R2
3$:	ADD	#100,R2
	MOVB	R2,(R1)+		;STORE ASCII CHARACTER
	INC	R0			;BUMP COUNT
RD50X6:	SOB	SD,RD50X2		;CONTINUE IF MORE
	POP	SD			;RESTORE REGISTER
	RETURN				;FINISHED
	.PAGE
	.SBTTL	EXEC   - SUBROUTINES FOR FUNCTION PACKETS

;SUBROUTINE TO ACKNOWLEDGE RECEIPT OF FUNCTION WHICH SUPPRESSES OUTPUT (EITHER
;  .FNOPS OR .FNHIN)
;	C(R1) = ADDRESS OF PACKET
;	CALL	ACKOPS

ACKOPS::MOV	#.PTFUN*400+1,PKCNT(R1)	;STORE PACKET TYPE AND COUNT
	MOVB	#.FNOSA,PKDATA(R1)	;FUNCTION = OUTPUT SUPPRESS ACK
	CJMP	PKTRTX#			;RETURN THE PACKET AND RETURN
	.PAGE
	.SBTTL	EXEC   - SUBROUTINES TO SIMULATE EIS INSTRUCTIONS

.IF EQ ..EIS				;ONLY IF DO NOT HVAE EIS!!

;SUBROUTINE TO SIMULATE "MUL" INSTRUCTION
;	PUSH	SRC
;	PUSH	R
;	CALL	MULSUB
;	POP	R
;	POP	R!1

MULSUB::PUSH	R0			;SAVE THE OUTSIDE WORLD
	PUSH	R1
	PUSH	R2
	PUSH	R3
	PUSH	R4
	CLR	-(SP)			;CLEAR THE SIGN FLAG
	MOV	20(SP),R3		;GET SRC
	BPL	1$			;OK IF +
	NEG	R3			;MAKE +
	INC	(SP)			;REMEMBER IT WAS -
1$:	MOV	16(SP),R2		;GET R
	BPL	2$			;OK IF +
	NEG	R2			;MAKE +
	INC	(SP)			;REMEMBER IT WAS -
2$:	CLR	R0			;CLEAR REGISTERS FOR RESULT
	CLR	R1
	MOV	#16.,R4			;INITIALIZE THE STEP COUNTER
4$:	ROR	R3			;GET A BIT
	BCC	6$			;IF 0
	ADD	R2,R0			;IF 1
6$:	ROR	R0			;SHIFT RESULT
	ROR	R1
	DEC	R4			;MORE?
	BGT	4$			;YES-CONTINUE
	ROR	(SP)+			;SHOULD RESULT BE -?
	BCC	10$			;NO
	COM	R0			;YES-MAKE IT -
	COM	R1
	ADD	#1,R1
	ADC	R0
10$:	MOV	R0,14(SP)		;RETURN RESULT
	MOV	R1,16(SP)
	POP	R4			;RESTORE THE STATE OF THE WORLD
	POP	R3
	POP	R2
	POP	R1
	POP	R0
	RETURN				;THATS ALL!!

;SUBROUTINE TO SIMULATE "DIV" INSTRUCTION
;	PUSH	SRC
;	PUSH	R
;	PUSH	R!1
;	CALL	DIVSUB
;	POP	R
;	POP	R!1

DIVSUB::PUSH	R0			;SAVE THE WORLD
	PUSH	R1
	PUSH	R2
	PUSH	R3
	PUSH	R4
	CLR	-(SP)			;CLEAR THE SIGN FLAG
	MOV	22(SP),R2		;GET SRC
	BPL	1$			;OK IF +
	NEG	R2			;MAKE +
	INC	(SP)			;REMEMBER IT WAS -
1$:	MOV	16(SP),R1		;GET R
	MOV	20(SP),R0
	BPL	2$			;OK IF +
	COM	R0			;MAKE -
	COM	R1
	ADD	#1,R1
	ADC	R0
	INC	(SP)			;REMEMBER IT WAS -
2$:	CLR	R3			;CLEAR FOR RESULT
	MOV	#16.,R4			;INITIALIZE THE STEP COUNTER
4$:	CLC
	ROL	R3
	CLC
	ROL	R1
	ROL	R0
	CMP	R0,R2			;SHOULD WE SUBTRACT?
	BLO	6$			;NO
	SUB	R2,R0			;YES
	INC	R3			;PUT A BIT IN THE RESULT
6$:	DEC	R4			;MORE?
	BGT	4$			;YES
	ROR	(SP)+			;SHOULD RESULT BE -?
	BCC	12$			;NO
	NEG	R3			;YES
12$:	TST	16(SP)			;SHOULD REMAINDER BE -?
	BPL	14$			;NO
	NEG	R0			;YES
14$:	MOV	R3,16(SP)		;STORE RESULT
	MOV	R0,20(SP)		;AND REMAINDER
	POP	R4			;RESTORE THE STATE OF THE WORLD
	POP	R3
	POP	R2
	POP	R1
	POP	R0
	POP	(SP)			;FIX UP THE RETURN
	RETURN				;FINISHED AT LAST!!

.ENDC	;  .IF EQ ..EIS
	.PAGE
	.SBTTL	EXEC   - IMPURE STORAGE

	IMPURE

CLKFLG::.BLKW	1			;FLAG THAT 60 CYCLE  HAS TICKED
SECCNT:	.BLKB	1			;SECOND TIMER
TENCNT:	.BLKB	1			;TENTH-SECOND TIMER
UPTIME::.BLKW	2			;NUMBER OF TICKS NODE HAS BEEN RUNNING
CKSPNT::.BLKW	1			;MEMORY CHECKSUM POINTER
CKSWRD::.BLKW	1			;MEMORY CHECKSUM VALUE BEING CALCULATED
LPSCNT:	.BLKW	1			;LOOPS-PER-SECOND COUNTER
LPSAVG::.BLKW	1			;LOOPS-PER-SECOND AVERAGE
S::	.BLKW	200			;SCRATCH BUFFER

	.END	GO


-@N¤