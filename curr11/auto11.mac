	.TITLE	AUTO11  - AUTO BAUD ROUTINES FOR TYPE 11
	.SBTTL	AUTO11  - NEXILIS/JRG
;	Sampling clock: 9600 baud, sync mode
;	Funny output  : 1200 baud, restricted speed= 10 cps(4800 speed)
;	Auto baud detect tables: primary table 11, secondary tables 20-40

	xlpar	;do't list parameter file
.IF NDF ..ATCR
 ..ATCR=!0
.ENDC
.IF NDF ..CAS
 ..CAS=!0
.ENDC
.IF NDF ..BUG
 ..BUG=!0
.ENDC
	code
;These auto-baud detect routines use a SCC type Async Interface as a high
;  speed clock for timing detect events.

;DEFINE OFFSETS FOR AUTO-BAUD TABLE
;
IDFLAG=0		;TERMINAL ID FLAG
MASK  =2		;MASK OF DON'T CARE BIT
MATCH =3		;MATCH CHAR
FRAME =4		;FRAMING FLAG
RATE  =5		;RESULT BAUD RATE
TYPE  =6		;..     TERMINAL TYPE,EG,CRTA,TRMG...
CODE  =7		;..     TERMINAL CODE,EG,ASC,EBCDIC...
INDEX =6		;SAME LOCATION OF TYPE, WHEN RATE=0
			; THIS BYTE SHOWS THE SECONDARY TABLE INDEX
COUNT =7		;SAME LOCATION OF CODE, WHEN RATE=0
			; THIS BYTE SHOWS THE REPEATED SEARCH TIMES
			; OF THE SAME SECONDARY TABLE
	IMPURE
FLG:		.WORD	0	;flag to let only one terminal
				;use SAVZON
TWOOUT::	.WORD	0	;ERROR COUNTER IF THERE EXIST 2 TIMERS
				; FOR OUTPUT FUNNY
.if NE ..BUG
	IMPURE
  .IF NE 0
PTRRR0:		.WORD	0	;POINTER TO SAnRR0
SA1RR0:		.WORD	0,0,0	;SAVE 5 RR0 (1 FUNNY CHAR= 5 OUTPUTS)
SAVRR0::	.WORD	0	;SAVE RR0 STATUS TO SOLVE EXCESS INTERRUPT
				; FROM FUNNY OUTPUT, LING-ASGOUI USE.
SAVZOC:		.WORD	0	;count of excess interrupts
SAVZ2::		.WORD	0	;pointer to next available SAVZON
SAVZON::	.BLKW	100	;zone for saving excess intr. while doing
				; funny output.
		.BLKW	4	;CUSHION AREA FOR OUTFNY:-9$
SAVZ1=.				;end address of SAVZON
  .ENDC ;.IF NE 0
SZON:		.BLKW	100	;zone for saving bytes of auto-b-detect
SZ1=.				;end address of SZON
.ENDC
	CODE

;SUBROUTINE TO INITIALIZE AUTO-BAUD DETECT ROUTINE
;	C(R1) = ADDRESS OF 2ND WORD IN DETECT TABLE
;	C(SD) = ADDRESS OF SDB
;	CALL	AINI11

AINI11::
.IF NE ..BUG	;Initialization of impure area for debugging stuff
	TST	FLG		;are we the first to do AINI11?
	BNE	22$		;ne, no, already initialized
	INC	FLG		;Yes, say we did it
	PUSH	R1		;free one register
	MOV	#SZON,R0	;get starting address to clear
	MOV	#100,R1		;totally 100 words
20$:	MOV	#-1,(R0)+	;-1 the content
	SOB	R1,20$		;loop until count to zero
  .IF NE 0
	CLR	SAVZOC
	MOV	#SAVZON,SAVZ2
	PUSH	R1
	MOV	#SAVZON,R0
	MOV	#100,R1
21$:	MOV	#-1,(R0)+
	SOB	R1,21$
  .ENDC ;.IF NE 0
	POP	R1
22$:
	MOV	#SZON,SDDBUG#(SD)	;SDDBUG NOW IS THE POINTER
.ENDC
	MOV	#CHKRAT,SDTRC1#(SD)	;STORE INITIAL DISPATCH
	MOV	(R1),R1			;GET SAMPLING CLOCK
	BIC	#$T3IRT!$T3ORT,SDTRS3#(SD);Store it in the SDB
	BISB	R1,SDTRS3#(SD)		;Set input and output baud rate
	BISB	R1,SDTRS3#+1(SD)
;	PUSH	R4
;	MOV	SDTRAD#(SD),R4		;Get ADB address
;	CMPB	ADGWR4#(R4),#60		;Are we already in auto-b-d mode?
;	BEQ	26$			;EQ, yes, don`t reset SCC
	MOV	#.LFSET,R0		;Setup the interface hardware
	CALL	TRMFNC#
	CALL	DPLLSH			;DPLL search and SYNC hunt
;26$:	POP	R4
	TBBN	$T0DDD,SDTRS0#(SD),24$	;TYMshare terminal?
	TBBN	$T0HWR,SDTRS0#(SD),30$	;HARD WIRED TERMINAL?
24$:	MOV	#JIFX20#,R0		;NO-ALLOW 20 SECONDS FOR DETECT
;	MOV	#BRDTMO#,R1	;add disabling receiver
	MOV	#HANGIT#,R1	;HANGIT on affects tymshare terminal
	CALL	TIMREQ#
30$:	MOV	#BAUDMS,SDTRIP#(SD)	;YES-SETUP FOR FUNNY OUTPUT
;	CLR	SDTRC3#(SD)	;TRY NOT TO USE SDTRC3
	JMP	OUTFNY			;BEGIN FUNNY OUTPUT

; add to prevent OVX crash
NORCVR::
	PUSH	R4
	MOV	SDTRAD#(SD),R4		;GET ADB ADDRESS
	MOVB	#3,@ADGCON#(R4)		;select WR3
	MOVB	#300,ADGWR3#(R4)	;SAVE WR3
	MOVB	#300,@ADGCON#(R4)	;disable the receiver
	POP	R4
	RETURN

DPLLSH:	PUSH	R4
	MOV	SDTRAD#(SD),R4		;GET ADB ADDRESS
	MOV	#SCCLE1,R0		;GET COUNT OF INITILIZATION BYTES
	MOV	#SCCINI,R1		;MAKE POINTER TO INITILIZATION DATA
10$:	MOVB	(R1)+,@ADGCON#(R4)	;MOVE DATA TO CONTROL REGISTER
	SOB	R0,10$			;CONTINUE UNTIL END
	MOVB	#321,ADGWR3#(R4)	;SAVE WR3
	POP	R4
	RETURN


	PURE
SCCINI:	.BYTE	3,300			;TURN OFF RX ENABLE TO FLUSH DATA BUFFER
	.BYTE	6,377			;SET UP SYNC REGISTERS
	.BYTE	7,377
	.BYTE	15.,0		;DISABLE BREAK INTERRUPT WHILE IN SYNC MODE
	.BYTE	14.,43			;START DPLL, LEAVING ON BR GENERATOR
	.BYTE	3,321			;RX ENABLE, enter hunt mode
SCCLE1=	.-SCCINI
	CODE
	.PAGE
;SUBROUTINE TO RESET AUTO-DETECT ROUTINE - THIS IS A HARD RESET IN THAT THE
;  "FUNNY CHARACTER" OUTPUT IS STOPPED IMMEDIATELY, EVEN IF IS IN THE MIDDLEE
;  OF A CHARACTER!  WHEN THIS SUBROUTINE RETURNS, ALL SHARED WORDS IN THE
;  TERMINAL SDB ARE CLEAR.
;	CALL	ARST11

ARST11::
	CLR	SDTRIP#(SD)		;CLEAR THE POINTER TO STOP FNY OUTPUT
	CALL	NORCVR	;DISABLE RCVER SO 20S TIME-OUT WILL NOT
			; GENERATE "377" TO TRM-DATA00, CALLED BY TRM-HANGIT
	MOV	#HAVRAT,R1		;KILL ALL POSSIBLE TIMERS
	CALL	TIMKIL#
	MOV	#OUTFNY,R1
	CALL	TIMKIL#
	MOV	#OUTFNY,R1	;MAKE SURE THERE ARE NO 2 OUT
	CALL	TIMKIL#		;	FUNNY EXIST
	BCC	2$		;CC- NO SUCH TIMER
	INC	TWOOUT		;COUNT AS ABNORMAL CONDITION
2$:	MOV	#SECTMO,R1
	CALL	TIMKIL#
;	MOV	#BRDTMO#,R1	; 
	MOV	#HANGIT#,R1
	CJMP	TIMKIL#

	.PAGE
;HERE WHEN DETECT CHARACTER RECEIVED WHEN DETECT CODE IS IDLE
;	C(R0) = CHARACTER
;	C(R1) = BAUD RATE CODE
;	C(SD) = ADDRESS OF SDB
;	CALL	CHKRAT

CHKRAT:
.IF NE ..BUG
	MOVB	R0,@SDDBUG#(SD)		;SAVE EVERY BYTE
	INC	SDDBUG#(SD)		;UPDATE TO NEXT POINTER
	MOVB	#200,@SDDBUG#(SD)	;JUST SAY WE'RE IN PRIMARY TABLE
	INC	SDDBUG#(SD)		;UPDATE TO NEXT POINTER
	CMP	#SZ1,SDDBUG#(SD)	;DON'T EXCEED THE BOUNDARY?
	BHI	41$			;NOT YET, 
	MOV	#SZON,SDDBUG#(SD)	;EXCEED, START FROM THE HEAD
41$:
.ENDC
	ASL	R1			;WORD INDEXING	
	MOV	ATOTXX#(R1),R3		;GET POINTER TO TABLE
	ADD	#6,R3			;POINT TO FIRST ENTRY of 8-byte record
	BR	AUTO0			;CONTINUE

;HERE WITH DETECT CHARACTER WHEN EXPECTING SECONDARY CHARACTER
;	C(R0) = CHARACTER
;	C(SD) = ADDRESS OF SDB
;	CALL	CHKSND

CHKSND:
.IF NE ..BUG
	MOVB	R0,@SDDBUG#(SD)		;SAVE EVERY BYTE
	INC	SDDBUG#(SD)		;UPDATE TO NEXT POINTER
	MOVB	SDTRC2#(SD),@SDDBUG#(SD);SECONDARY TABLE INDEX
	INC	SDDBUG#(SD)		;UPDATE TO NEXT POINTER
	CMP	#SZ1,SDDBUG#(SD)	;DON'T EXCEED THE BOUNDARY?
	BHI	41$			;NOT YET, 
	MOV	#SZON,SDDBUG#(SD)	;EXCEED, START FROM THE HEAD
41$:
.ENDC
	PUSH	R0			;RESPECT R0
	MOV	#SECTMO,R1		;CLEAR POSSIBLE TIMER
	CALL	TIMKIL#
	POP	R0			;RESTORE R0
	CLR	R2			;HAVE TO CLEAR R2
;	MOVB	SDTRC2#(SD),R2		;GET SECONDARY TABLE INDEX
	BISB	SDTRC2#(SD),R2		;GET SECONDARY TABLE INDEX
	MOV	SECTBL#(R2),R3		;GET ADDRESS OF SECONDARY TABLE
AUTO0:
	CMP	#CHKSND,SDTRC1#(SD)	;ARE WE SCANNING A SECONDARY TABLE?
	BNE	4$			;NO-GO ON
	BIT	IDFLAG(R3),SDTRC5#(SD)	;CHECK TERMINAL ID
	BEQ	AUTO4			;EQ, NOT THIS ENTRY, TRY NEXT

;HERE IF WE ARE MATCH OF TERMINAL ID FOR THIS ENTRY

4$:
	MOV	R0,R2			;COPY CHARACTER
	BICB	MASK(R3),R2		;REMOVE DON'T CARE BITS
	CMPB	MATCH(R3),R2		;THIS ONE?
	BEQ	AUTO8			;YES
AUTO4:
	ADD	#10,R3			;BUMP TO NEXT ENTRY
	CMPB	#377,(R3)		;MORE THERE?
	BNE	AUTO0			;YES-CONTINUE
	MOV	#RTN002,SDTRC1#(SD)	;CHANGE DISPATCH SO WILL IGNORE INPUT
					;  FOR A WHILE
	CALL	NORCVR	;Disable receiver, so not to allow garbage interrut us
	MOV	#SECTMO,R1		;DELAY FOR 1/2 SECOND
	MOV	#JIFO2#,R0
	CJMP	TIMREQ#
SECTMO:
	CALL	DPLLSH			;HUNT SCC FOR NEW DETECT
	MOV	#CHKRAT,SDTRC1#(SD)	;RESET DETECT DISPATCH
RTN002:	RETURN

;HERE WITH MATCH ON THE CHARACTER

AUTO8:
;	MOVB	FRAME(R3),R1		;GET FLAGS
;	BPL	AUTO9			;GO ON IF DON'T CARE ABOUT FRAMING
;	TBBN	100,R1,14$		;SHOULD THERE BE A FRAMING ERROR?
;	TST	R0			;NO-WAS THERE ONE?
;	BMI	AUTO4			;YES-NOT A MATCH!
;	BR	AUTO9			;NO-GO ON

;HERE IF SHOULD HAVE A FRAMING ERROR

;14$:	TST	R0			;WAS THERE A FRAMING ERROR?
;	BPL	AUTO4			;NO-NO MATCH!

;HERE WITH MATCH ON EVERYTHING

AUTO9:
	CLR	R1			;FOR SAVETY
;	MOVB	RATE(R3),R1			;YES-GET RATE
	BISB	RATE(R3),R1			;YES-GET RATE
	SWAB	R1			;IN BOTH HALVES
	BISB	RATE(R3),R1
	BNE	22$			;GO ON IF FINISHED NOW
;
; HERE WITH EVERYTHING MATCH EXCEPT RATE(R3)=0
;
	MOVB	COUNT(R3),R1		;NEED TO REPEAT THIS TABLE?
	BEQ	19$			;EQ, NO NEED, TRY NEXT TABLE
	DECB	R1			;NE, MAYBE 1?
	BEQ	19$			;EQ, NO NEED, TRY NEXT TABLE
					;COUNT(R3)>=2
	TSTB	SDTRC2#+1(SD)		;FIRST SEARCH OF TABLE?
	BNE	18$			;NE, NOT FIRST
					;SRTRC2#+1(R3)=0, FIRST SEARCH
	MOVB	R1,SDTRC2#+1(SD)	;SAVE COUNTER
	BR	191$			;WAITING FOR NEXT CHAR.
18$:					;NOT FIRST
	DECB	SDTRC2#+1(SD)		;DO WE FINISH?
	BGT	10$			;GT, NOT YET
;
;HERE WE NEED CHANGE ANOTHER SECONDARY TABLE
;
19$:
	MOVB	INDEX(R3),SDTRC2#(SD)	;SAVE INDEX FOR SECONDARY TABLE
	CLRB	SDTRC2#+1(SD)		;INITIAL THE SAVE COUNT
191$:	MOV	IDFLAG(R3),R0		;get terminal ID flag(mask)
	CMP	#CHKRAT,SDTRC1#(SD)	;if in primary table
	BEQ	192$			; then save the terminal ID mask
	COM	SDTRC5#(SD)		;else
	BIC	SDTRC5#(SD),R0		; AND current and previous TID mask
192$:	MOV	R0,SDTRC5#(SD)		;endif
10$:	MOV	#CHKSND,SDTRC1#(SD)	;CHANGE DISPATCH FOR SECONDARY STUFF
	MOV	#10.,R0			;GET TIMEOUT TIME
	MOV	#SECTMO,R1		;AND TIMEOUT ADDRESS
	CJMP	TIMREQ#			;START TIMER AND LEAVE

;HERE WHEN RATE IS FINALLY KNOWN

22$:
;	PUSH	R3			;SAVE POINTER
	BIC	#$T3IRT!$T3ORT,SDTRS3#(SD);STORE RATE IN SDB
	BIS	R1,SDTRS3#(SD)
;	MOV	SDTRIP#(SD),R0		;ARE WE OUTPUTING A MESSAGE?
;	BEQ	24$			;NO
;	MOVB	#-40,SDTRC3#+1(SD)	;;SET STATE TO STOP AFTER CURRENT BYTE
;24$:
	CALL	ARST11			;CLEAR ALL POSSIBLE TIMERS, AND
;					;DISABLE RECVER AND STOP FUNNY OUTPUT
;	POP	R3
	MOVB	TYPE(R3),R0		;GET TERMINAL TYPE
	BMI	26$			;IF SHOULD NOT SET IT
	CMPB	#T.CRTO,R0		;Is it Prism?
	BNE	23$			;NE, no
	BIS	#$T2SPP,SDTRS2#(SD)	;Enable space parity output
23$:	PUSH	R3
	CALL	SETTTP#			;SETUP THE TERMINAL TYPE PARAMETERS
	  NOP				;Should not fail!
	POP	R3
26$:
	MOVB	CODE(R3),SDTRXC#(SD)	;STORE CODE IN THE SDB
.IF NE ..BUG
	MOV	#RTNBUG,SDTRC1#(SD)	;TO RCV "P,EOT"
.IFF
	MOV	#RTN002,SDTRC1#(SD)	;CHANGE DISPATCH SO WILL IGNORE INPUT
					;  FOR A WHILE
.ENDC
;	MOV	#JIFO2#,R0		;delay for 1/2 second
	MOV	#JIFO10#,R0		;DELAY FOR 1/10 SECOND
	MOV	#HAVRAT,R1		; then tell TRM baud-is-ready
	CJMP	TIMREQ#
.IF NE ..BUG
RTNBUG:
	MOVB	R0,@SDDBUG#(SD)		;SAVE EVERY BYTE
	INC	SDDBUG#(SD)		;UPDATE TO NEXT POINTER
	MOVB	#177,@SDDBUG#(SD)	;JUST SAY WE'RE IN AFTER TABLE
	INC	SDDBUG#(SD)		;UPDATE TO NEXT POINTER
	CMP	#SZ1,SDDBUG#(SD)	;DON'T EXCEED THE BOUNDARY?
	BHI	41$			;NOT YET, 
	MOV	#SZON,SDDBUG#(SD)	;EXCEED, START FROM THE HEAD
41$:	RETURN
.ENDC

;HERE 1/2 SECOND AFTER BAUD RATE IS DETERMINED

HAVRAT:
	CALL	ARST11			;MAKE SURE ALL TIMERS ARE CLEAR
	MOV	#.LFSET,R0	;Set the SCC hardware
	CALL	TRMFNC#
	CJMP	BRDRDY#			;CONTINUE

	.PAGE
	.SBTTL	AUTO11  - FUNNY OUTPUT ROUTINE

;Funny output routine - this routine is entered directly from the output
;  done interrupt from the SCC.  No registers have
;  been saved.
;This subroutine uses several terminal sdb words for its data.  These are
;  words which are used by the terminal service for other things, but this
;  is OK since they are only used for input or for command mode.  Since this
;  routine is only active when in baud detect state, there is no possible
;  conflict (we hope).
;    THESE WORDS ARE USED AS FOLLOWS:
;	C(SDTRIP(SD))   = POINTER TO CURRENT OUTPUT BYTE (WORD)
;			=0, STOP FUNNY OUTPUT RIGHT AWAY
;       TRY NOT TO USE SDTRC3
;	C(SDTRC3(SD))   = BIT MASK FOR OUTPUT STREAM (BYTE)
;	C(SDTRC3+1(SD)) = OUTPUT STATE COUNTER (BYTE)
;			 =1, MEANS 10 BYTES OUTPUT DONE
;			 =2, MEANS 0.1 SECOND REACHED BEFORE 10-BYTE-DONE
;			  = -40,    AUTO BAUD ALREADY DETECTED
;				    NO MORE FUNNY OUTPUT
;	C(SDTRC4(SD)= COUNTER FOR THREE(LOW BYTE)
;		      WORK AREA FOR STORING CURRENT OUTPUTING BYTE(HIGH BYTE)

OUTFNY:					;DO FUNNY OUTPUT
	MOV	#33,SDTXGP#(SD)	;FOR IMPROVE PERFORMANCE OF FUNNY OUTPUT
				; affects LING_ASGOUI routine
	TST	SDTRIP#(SD)		;ARST11 ORDERS US TO STOP?
	BEQ	OUTDON			;YES, SIR.
	TSTB	@SDTRIP#(SD)		; STILL SOMETHING TO OUTPUT?
	BEQ	OUTDON			;EQ, NO MORE
					;ELSE, YES
;	CMPB	#-40,SDTRC3#+1(SD)	;ARE WE BEING STOPPED?
;	BEQ	OUTDON			;EQ, YES
;	CLRB	SDTRC3#+1(SD)		;CLEAR FLAG
	MOV	#OUTFNY,R1		;GOTO OUTFNY, AFTER .1 SECOND
	MOV	#JIFO10#,R0		;UNTIL NEXT TENTH SECOND
;	MOV	#5,R0		;UNTIL NEXT TENTH SECOND
	CALL	TIMREQ#			;MARK TIME FOR TENTH SECOND
;
; HERE WE OUTPUT 5 BYTES(4800-BAUD) AS ONE 1200-BAUD CHAR.
;
	MOV	#1$,SDTROD#(SD)		;AFTER START-BIT GOTO 1$
	MOVB	@SDTRIP#(SD),R0		;GET THE BYTE TO OUTPUT
	ASL	R0			;ONLY RIGHTMOST BIT AND START BIT
	JMP	STUFFO			;GO OUTPUT START BIT AND BIT 0
1$:					;NEXT ARE 7-BIT DATA AND STOP BIT
	TST	SDTRIP#(SD)		;ARST11 ORDERS US TO STOP?
	BEQ	OUTDON			;YES, SIR.
.IF NE 0
	MOVB	SAVRR0,SA1RR0	;SAVE RR0 OF THE 1ST OUTPUT
	MOV	#SA1RR0+1,PTRRR0	;POINT TO STORAGE OF 2ND RR0
.ENDC
	MOV	#2$,SDTROD#(SD)		;OUPUT DONE, GOTO 2$
	MOVB	@SDTRIP#(SD),R0		;GET THE BYTE TO OUTPUT AGAIN
	ASR	R0			;KICK OFF THE RIGHTMOST BIT
	BIS	#200,R0			;WELCOME STOP BIT
;	MOV	#3,SDTRC4#(SD)		;STILL 3 BYTES TO OUTPUT
	MOVB	#4,SDTRC4#(SD)		;STILL 3 BYTES TO OUTPUT
	MOVB	R0,SDTRC4#+1(SD)	;SAVE IT
	BR	STUFFO			;GO OUTPUT BIT 1 AND 2
2$:
	TST	SDTRIP#(SD)		;ARST11 ORDERS US TO STOP?
	BEQ	OUTDON			;YES, SIR.
.IF NE 0
	MOVB	SAVRR0,@PTRRR0	;SAVE RR0(2ND,3RD,4TH AND 5TH)
	INC	PTRRR0		;POINT TO NEXT
	CMP	PTRRR0,#SA1RR0+5
	BLO	29$
	MOV	#SA1RR0+1,PTRRR0
29$:
.ENDC
	DECB	SDTRC4#(SD)		;FINISHED?
	BLE	8$			;EQ, YES, DONE
	MOVB	SDTRC4#+1(SD),R0	;GET THE OUTPUT BYTE
	ASR	R0			;SHIFT 2 BITS
	ASR	R0			;
	MOVB	R0,SDTRC4#+1(SD)	;SAVE IT AGAIN
	BR	STUFFO			;GO OUTPUT NEXT 2 BITS
;
;HERE IS THE ROUTINE, AFTER OUTPUT EVERY FIVE BYTES(4800 BAUD)
; FINISHED OUTPUT ONE CHAR.(1200 BAUD)
;
8$:	
	MOV	#9$,SDTROD#(SD)		;JUST FOR SURE
;	TST	SDTRIP#(SD)	
;	BEQ	OUTDON		
	INC	SDTRIP#(SD)		;ADVANCE OUTBUF POINTER
	RETURN				;AFTER .1SEC, OUTFNY WILL START
					;A NEW OUTPUT(5 BYTES)
;
9$:
.IF NE 0
	INC	SAVZOC		;count up one more excess interrupt
	MOV	SAVZ2,R0	;keep the record of the last char
	MOV	SDTRIP#(SD),R1	; in the "PLS LOGIN" string
	DEC	R1
	MOV	R1,(R0)+
;	MOVB	@R1,(R0)+
	MOVB	SAVRR0,(R0)+	;FIND OUT THE REASON
	MOVB	SDSOC#(SD),(R0)+	;	 OF EXCSEE INTERRUPTS
	MOV	SA1RR0,(R0)+	;SAVE 1ST AND 2ND RR0'S
	MOV	SA1RR0+2,(R0)+	;3RD AND 4TH
	MOV	SA1RR0+4,(R0)+	;5TH AND NULL
; add to prevent NXM crash
	CMP	R0,#SAVZ1	;check the upper limit
	BLO	91$		;still inside SAVZON
	MOV	#SAVZON,R0	;no, start again
91$:
	MOV	R0,SAVZ2
.ENDC
	RETURN				

;HERE IF NO MORE FUNNY OUTPUT
;
OUTDON:
	CLR	SDTXGP#(SD)		;no more escape from LING ASGOUI
	CLR	SDTRIP#(SD)		;CLEAR WORK AREA
;	CLR	SDTRC3#(SD)		;TRY NOT TO USE THIS VARIABLE
	CLR	SDTRC4#(SD)		;
	MOV	#OUTIDL#,SDTROD#(SD)	;DON'T COME HERE ANYMORE
	RETURN
;
; SUBROUTINES OF FUNNY OUTPUT
;
STUFFO:
	TST	SDTRIP#(SD)		;ARST11 ORDERS US TO STOP?
	BEQ	OUTDON			;YES, SIR.
;	CMPB	#-40,SDTRC3#+1(SD)	;ARE WE BEING STOPPED?
;	BEQ	OUTDON			;EQ, YES
	BIC	#^C3,R0			;TWO BITS AT A TIME
	MOVB	TABLE4(R0),R0		;TRANSFER 2-BIT TO 8-BIT
	BIS	#$T1ACX,SDTRS1#(SD)	;CLAIM WAITING FOR OUTPUT DONE
	MOV	SDTXGP#(SD),R1		;SPEEDUP THE FUNNY OUTPUT
;	CLR 	R1			;NO PACKET TO OUTPUT
	PUSH	R4
	MOV	SDTRAD#(SD),R4		;GO OUTPUT 1 BYTE
	CALL	@(R4)			;THEN, WAITING FOR OUTPUT DONE
	POP	R4
	RETURN

	.PAGE



;DEFINE MACRO WHICH GENERATES THE PARITY BIT FOR A CHARACTER

	.MACRO	CHAR  CCC
CC=!CCC
$M=!1
$X=!0
	.REPT	7
.IF NE CC&$M
  $X=!$X+1
.ENDC
$M=!$M*2
	.ENDR
.IF NE $X&1
  CC=!CC!200
.ENDC
	.BYTE	CC
	.ENDM

;GENERATE THE BIT STRING FOR THE MESSAGES WITH EVEN PARITY

.IF EQ ..ATCR	;If not ATC microdata R-mode
BAUDMS:	.BYTE	377,377,377,377,377,377,377 ;START OFF WITH 7 DELS
.IF NE ..CAS	;--PIR2009
	CHAR	FF
	.BYTE	377,377,377,377		;ALLOW FOR SLOW CARRIAGE RETURN
.ENDC
	CHAR	CR
	CHAR	LF
	.BYTE	377,377,377,377		;ALLOW FOR SLOW CARRIAGE RETURN
	.IRPC	C,<please type your terminal identifier >
.IF NB C
	CHAR	''C
.IFF
	CHAR	SPA
.ENDC
	.ENDM
.IFF	;IF EQ ..ATCR	;If support ATC microdata R-mode
BAUDMS:	.BYTE	177,177,177,177,177,177,177	;space parity
	.BYTE	CR
	.BYTE	LF
	.BYTE	177,177,177,177			;for slow carriage return
	.ASCII	/please type your terminal identifier /
.ENDC	;IF EQ ..ATCR
BAUDME:	.BYTE	0,0
TABLE4:	.BYTE	0,17,360,377		;RELATIVE TO 00,01,10,11
	.EVEN
	.END
 