	.TITLE	LINC   - LINE INTERFACE DRIVER TYPE C (DH11)
	.SBTTL	LINC   - NEXILIS/JRG

	XLPAR				;DON'T LIST PARAMETER FILE
.IF NDF	..SAT
..SAT=!0
.ENDC

	CODE

	.SBTTL	LINC   - RESET ROUTINE

;THIS ROUTINE IS CALED WHEN THE NODE IS STARTED OR RESTARTED

ASCINT::TST	@ADCSCR#(R4)		;DOES THE HARDWARE FOR THIS LINE EXIST?
	NXMJMP	ASCIN8			;NO!
	BIS	#$S1AVL,SDSTS1#(SD)	;YES-INDICATE THIS LINE IS AVAILABLE
	MOVB	SDTRXA#(SD),R2		;GET INDEX FOR LINE ON INTERFACE
	BNE	ASCIN2			;CONTINUE IF NOT FIRST LINE
	BIS	#004000,@ADCSCR#(R4)	;FIRST LINE-RESET THE INTERFACE
	CLR	ADCBAX#(R4)		;AND CLEAR IN-MEMORY COPY OF ENABLE
					;  BITS
	BISB	#$A1AVL,ADSTS1#(R4)	;INDICATE INTERFACE IS AVAILABLE
ASCIN2:	TST	ADCCSR#(R4)		;IS THERE DATA SET CONTROL HARDWARE FOR
					;  THIS LINE?
	BEQ	4$			;NO
	TST	@ADCCSR#(R4)		;YES-DOES IT REALLY EXIST?
	NXMJMP	2$			;NO
	BR	ASCIN4			;YES-GO ON


;HERE IF HAVE NO DATA SET CONTROL HARDWARE FOR THIS LINE

2$:	CLR	ADCCSR#(R4)		;No data set control
4$:	BIS	#$T0HWR,SDTRS0#(SD)	;FORCE THIS LINE TO BE HARDWIRED!
ASCIN4:	TBBN	$T0HWR,SDTRS0#(SD),ASCIN6;NOTHING NEEDED HERE IF HARDWIRE
	MOVB	R2,@ADCCSR#(R4)		;POINT HARDWARE TO THIS LINE
	MOV	#1,@ADCLSR#(R4)		;SET HARDWARE BITS TO DETECT RING
ASCIN6:	INC	R2			;IS THIS THE LAST LINE ON INTERFACE?
	CMPB	ADMAXI#(R4),R2
	BGT	RTN001			;NO
	MOV	#020100,@ADCSCR#(R4)	;YES-ENABLE THE INTERFACE
	TST	ADCCSR#(R4)		;IS THERE DATA SET CONTROL HARDWARE FOR
					;  THIS LINE?
	BEQ	RTN001			;NO
	MOV	#140,@ADCCSR#(R4)	;YES, TURN ON SCANNER AND INTERRUPTS
RTN001:	RETURN				;FINISHED

;HERE IF HARDWARE FOR INTERFACE DOES NOT EXIST

ASCIN8:	BICB	#$A1AVL,ADSTS1#(R4)	;Indicate hardware does not exist
	RETURN				;THATS ALL
	.PAGE
	.SBTTL	LINC   - INTERRUPT LEVEL ROUTINES

;HERE FOR INPUT READY INTERRUPT
;BEFORE GETTING HERE THE FOLLOWING CODE HAS BEEN EXECUTED:
;	ASnIN:	PUSH	R4		;SAVE R4
;		MOV	#ADCn$,R4	;GET ADDRESS OF ADB
;		JMP	ASCINI		;GO TO COMMON ROUTINE

ASCINI::PUSH	R0			;SAVE R0 TOO
	PUSH	R1			;AND R1
INPGET:	MOV	@ADCRCR#(R4),R0		;GET CHARACTER
	BPL	INPDON			;FINISHED IF NOTHING THERE
	MOV	#.LFDAT,R1		;FUNCTION = .LFDAT
	TBBE	020000,R0,INPGE1	;BREAK ON LINE?

;CHECK HERE FOR INPUT OF BREAK CHARACTER

	MOV	#.LFBRK,R1		;FUNCTION = .LFBRK
INPGE1:	BIC	#170000,R0		;REMOVE JUNK
	ADD	ADINDX#(R4),R0		;ADD THE LINE INDEX
	CALL	TRINTR#			;CALL THE TERMINAL SERVICE
	BR	INPGET			;GO CHECK FOR ANOTHER CHARACTER

;HERE FOR OUTPUT DONE INTERRUPT
;BEFORE GETTING HERE THE FOLLOWING CODE HAS BEEN EXECUTED:
;	ASnOU:	PUSH	R4		;SAVE R4
;		MOV	#ADCn$,R4	;GET ADDRESS OF ADB
;		JMP	ASCOUI		;GO TO COMMON ROUTINE

ASCOUI::PUSH	R0			;SAVE R0
	PUSH	R1			;AND R1
OUTLP0:	BIC	#100000,@ADCSCR#(R4)	;CLEAR OUTPUT DONE HARDWARE FLAG
	MOV	ADCBAX#(R4),R1		;GET BITS FOR LINES WE THINK ARE ACTIVE
	MOV	@ADCBAR#(R4),R0		;GET THE INTERFACE'S BITS
	BIC	R0,R1			;GET JUST THOSE WHICH ARE DONE
	BEQ	OUTDON			;FINISHED IF FALSE ALARM!
	PUSH	R2			;Free up some more registers
	PUSH	SD
	MOV	R0,ADCBAX#(R4)		;UPDATE OUR BITS
	MOV	#20,R0			;INITIALIZE COUNTER
OUTLP1:	ROL	R1			;GET NEXT BIT
;	BCC	200$
	BCS	OUTSVC			;SERVICE OUTPUT READY
OUTLP2:	SOB	R0,OUTLP1		;CONTINUE IF MORE TO CHECK
	POP	SD
	POP	R2
OUTDON:	TST	@ADCSCR#(R4)		;DID ANOTHER ONE SNEEK IN?
	BMI	OUTLP0			;YES-GO HANDLE IT NOW
INPDON:	POP	R1			;RESTORE R1
	POP	R0			;AND R0
	POP	R4			;AND R4
	RTI				;DISMISS INTERRUPT

OUTSVC:	PUSH	R0			;SAVE AC'S
	PUSH	R1
	DEC	R0			;GET LINE INDEX
;	SWAB	R0			;IN THE RIGHT PLACE
;	MOV	R0,SD			;Find this line's SDB
;	ADD	ADINDX(R4),SD
;	SWAB	SD
	MOVB	ADINDX+1(R4),SD		;Get absolute # of first term on this device
	ADD	R0,SD			;Form absolute terminal number
	ASL	SD			;Convert to word index
	MOV	T0SX#(SD),SD
	MOV	SDTXCP#(SD),R1		;Get output packet
	BEQ	100$			;If none
	TSTB	PKCNT(R1)		;Is it empty?
	BEQ	100$			;Yes
	MOVB	PKPNT(R1),R0		;Calculate address of next character
	ADD	R1,R0
	ADD	#PKDATA-1,R0		;Point to start of string
	PUSH	R0			;Save start of string address
	MOVB	PKCNT(R1),R2		;Get count of characters
	CMP	#5,R2			;More than 5 bytes left?
	BGE	40$			;No
	MOV	#5,R2			;Limit DMA to five bytes at a time
40$:	BITB	#140,(R0)+		;Printable character?
	BEQ	60$			;Stop if not printable character
.IF EQ	..SAT
	TSTB	SDTRLW#(SD)		;Get line width
	BEQ	50$			;If none set
	CMPB	SDTRHP#(SD),SDTRLW#(SD)	;Are we at the end of the line?
	BHIS	60$			;Yes-must stop now!
50$:	INC	COTCNT#			;Count the character
.ENDC
	INCB	SDTRHP#(SD)
	INCB	PKPNT(R1)		;Advance packet pointer
	DECB	PKCNT(R1)		;Decrement remaining bytes in packet
	SOB	R2,40$			;Continue search
	INC	R0			;Pretend next character failed test
60$:	SUB	(SP),R0			;Get count of characters
	DEC	R0			;Compensate for auto increment
	BLE	70$			;Tell TRINTR if no chars left
	NEG	R0			;NEGATE BYTE COUNT FOR DH11
	MOVB	SDTRXA#(SD),R2		;GET OFFSET OF THIS LINE ON THE
					;  INTERFACE
	MOV	R2,R1			;MAKE LINE OFFSET INTO WORD INDEX
	ASL	R1
	MOV	ASCBIT(R1),R1		;GET BIT FOR LINE
	BIS	#100,R2			;KEEP RECEIVE ENABLE SET!
	MOVB	R2,@ADCSCR#(R4)		;SELECT LINE
	MOV	R0,@ADCBCR#(R4)		;SET BYTE COUNT
	POP	@ADCCAR#(R4)		;SET ADDRESS
	BIS	R1,@ADCBAR#(R4)		;START THE LINE
	BIS	R1,ADCBAX#(R4)		;REMEMBER WE DID IT
	BR 	150$
70$:	TST	(SP)+			;CLEAR STARTING ADDRESS FROM STACK
	MOV	2(SP),R0		;GET BACK LINE NUMBER
	DEC	R0			;CONVERT TO INDEX

100$:	SWAB	R0			;PUT TERM NUMBER IN LEFT HALF
	ADD	ADINDX#(R4),R0		;PLUS OFFSET
	CLR	R1			;INDICATE OUTPUT DONE
	CALL	TRINTR#			;CALL TERMINAL SERVICE
150$:	POP	R1			;RESTORE AC'S
	POP	R0
	BR	OUTLP2

;HERE FOR DATA-SET INTERRUPT
;BEFORE GETTING HERE THE FOLLOWING CODE HAS BEEN EXECUTED:
;	ASnDS:	PUSH	R4		;SAVE R4
;		MOV	#ADCn$,R4	;GET ADDRESS OF ADB
;		JMP	ASCDSI		;GO TO COMMON ROUTINE

ASCDSI::PUSH	R0			;SAVE R0
	PUSH	R1			;SAVE R1
	MOV	@ADCCSR#(R4),R0		;GET DATA-SET WORD
	BPL	ASCDS2			;GO ON IF NOT RING INDICATOR
	PUSH	R0			;SAVE BITS
	MOV	#.LFRNG,R1		;GET FUNCTION = RING INDICATION
	CALL	SNDDSF			;SEND IT TO THE TERMINAL SERVICE
	POP	R0			;RESTORE BITS
ASCDS2:	TBBE	040000,R0,ASCDS4	;CARRIER CHANGE?
	MOV	#.LFCDT,R1		;YES-REPORT CARRIER DETECT
	TBBN	100,@ADCLSR#(R4),2$	;YES-DO WE HAVE CARRIER NOW?
	MOV	#.LFCLS,R1		;NO-REPORT CARRIER LOSS
;	BR	4$

2$:
4$:	CALL	SNDDSF			;SEND TO THE TERMINAL SERVICE
ASCDS4:	MOV	#140,@ADCCSR#(R4)	;CLEAR DONE TO RE-ENABLE THE SCANNER!
	BR	INPDON			;AND GO DISMISS INTERRUPT

;SUBROUTINE TO SEND DATA-SET FUNCTION TO TERMINAL SERVICE
;	C(R1) = FUNCTION
;	CALL	SNDDSF

SNDDSF:	MOV	@ADCCSR#(R4),R0		;GET OFFSET ON INTERFACE
	BIC	#^C17,R0		;REMOVE JUNK
	SWAB	R0			;GET THINGS IN THE RIGHT PLACE
	ADD	ADINDX#(R4),R0		;ADD IN BASE OFFSET FOR INTERFACE
	CJMP	TRINTR#			;CALL TERMINAL SERVICE AND RETURN
	.PAGE
	.SBTTL	LINC   - OUTPUT ROUTINES

;SUBROUTINE TO OUTPUT DATA - CALLED ONLY AT MAIN PROGRAM LEVEL
;	C(R0) = CHARACTER TO OUTPUT
;	C(R1) = Address of output packet (if any)
;	C(R4) = ADDRESS OF ADB
;	C(SD) = ADDRESS OF SDB
;	CALL	ASCOUT
ASCOUT::MOV	R1,SDTXCP#(SD)		;SAVE OUTPUIT PACKET POINTER
	MOVB	SDTRXA#(SD),R1		;GET OFFSET OF THIS LINE ON THE
					;  INTERFACE
	MOV	#SDTRCC#,R2		;GET ADDRESS OF CHARACTER
	ADD	SD,R2
	MOVB	R0,(R2)			;STORE CHARACTER
	MOV	R1,R3			;MAKE LINE OFFSET INTO WORD INDEX
	ASL	R3
	MOV	ASCBIT(R3),R3		;GET BIT FOR LINE
	BIS	#100,R1			;KEEP RECEIVE ENABLE SET!
	SETPSW	#340			;NO INTERRUPTS NOW!
	MOVB	R1,@ADCSCR#(R4)		;SELECT LINE
	MOV	#-1,@ADCBCR#(R4)	;SET BYTE COUNT = 1
	MOV	R2,@ADCCAR#(R4)		;SET ADDRESS
	BIS	R3,@ADCBAR#(R4)		;START THE LINE
	BIS	R3,ADCBAX#(R4)		;REMEMBER WE DID IT
	CLRPSW				;INTERRUPTS OK NOW!
	RETURN				;THATS ALL
	.PAGE
;SUBROUTINE TO PROFORM FUNCTION - CALLED ONLY AT MAIN PROGRAM LEVEL
;	C(R0) = FUNCTION
;	C(R1) = DATA (IF ANY)
;	C(R4) = ADDRESS OF ADB
;	C(SD) = ADDRESS OF SDB
;	CALL	ASCFNC
;	C:SET = ERROR

ASCFNC::MOVB	SDTRXA#(SD),R2		;GET OFFSET OF LINE ON INTERFACE
	BIS	#100,R2			;SET INTERRUPT ENABLE BIT
	ADD	R0,PC			;DISPATCH ON THE FUNCTION
	BR	SNDBRK			;.LFSBK =  0  SEND BREAK
	BR	SETHWR			;.LFSET =  2  Set interface parameters
	BR	ANSWER			;.LFANS =  4  Answer line
	BR	HANGUP			;.LFFHG =  6  Force hang up
	BR	STPOUT			;.LFSTP = 10  Stop output
;	BR	ENDBRK			;.LFEBK = 12  End break sequence

;Here to end break sequence

ENDBRK:	BIC	R3,ADCBRB#(R4)		;Clear bit in saved array
	MOV	ADCBRB#(R4),@ADCBKR#(R4) ;Move new value to break register
	RETURN

;HERE TO SEND BREAK ON LINE

SNDBRK:	BIS	R3,ADCBRB#(R4)		;Set bit in saved array
	MOV	ADCBRB#(R4),@ADCBKR#(R4) ;Move new value to break register
	RETURN

;Here to stop output immediately

STPOUT:	CLR	SDTXCP#(SD)		;Clear packet pointer to stop output
	RETURN				;And return


;HERE TO FORCE HANGUP ON LINE

HANGUP:	TST	ADCCSR#(R4)		;Data set control?
	BEQ	RTNSEC			;No
	BIC	#40,@ADCCSR#(R4)	;DISABLE DATA-SET SCANNER
10$:	TBBN	20,@ADCCSR#(R4),10$	;Wait until busy has gone off
	SETPSW	#340			;NO INTERRUPTS NOW
	MOV	R2,@ADCCSR#(R4)		;SET LINE
	BIC	#6,@ADCLSR#(R4)		;TURN OFF DTR AND RTS
	BR	ENBSCN			;THATS ALL

;HERE TO ANSWER LINE

ANSWER:	TST	ADCCSR#(R4)		;Data set control?
	BEQ	RTNSEC
	BIC	#40,@ADCCSR#(R4)	;DISABLE DATA-SET SCANNER
10$:	TBBN	20,@ADCCSR#(R4),10$	;Wait until busy has gone off
	SETPSW	#340			;NO INTERRUPTS NOW
	MOVB	R2,@ADCCSR#(R4)		;SET LINE
	BIS	#2,@ADCLSR#(R4)		;TURN ON DTR
ENBSCN:	BIS	#140,@ADCCSR#(R4)	;ENABLE DATA-SET SCANNER
	BR	CLRRTN			;THATS ALL

;Here to setup interface parameters to match values stored in the SDB -
;  input speed, output speed, character size, number of stop bits, parity
;  enable, and parity sense are setup
;	C(R2) = Offset for line on interface plus input interrupt enable bit

SETHWR:	MOVB	SDTRS3#+1(SD),R1	;Get input baud rate
	BIC	#^C<$BRIRT/400>,R1
	ASL	R1			;For word indexing
	MOV	ASCRAT(R1),R0		;Get bits for the hardware
	BEQ	RTNSEC			;Error if hardware can't handle this rate
	BIC	#^C036000,R0		;Isolate the baud rate
	ASHI	-4,R0			;Position for input rate field
	MOVB	SDTRS3#(SD),R1		;Get output baud rate
	BIC	#^C$BRORT,R1
	ASL	R1			;For word indexing
	BIS	ASCRAT(R1),R0		;Get bits for the hardware
	BEQ	RTNSEC			;Error if no data for this rate
	TBBE	$T4PAR,SDTRS4#(SD),4$	;Do we want parity handling?
	TBBN	$T1IMO,SDTRS1#(SD),4$	;Really?
	TBBE	3,R0,4$			;Yes-can we do it for this baud rate?
	DEC	R0			;Yes-adjust character size
	BIS	#20,R0			;Indicate want parity handling
	TBBE	$T4ODD,SDTRS4#(SD),4$	;Want odd parity?
	BIS	#40,R0			;Yes
4$:	SETPSW	#340			;No interrupts now
	MOVB	R2,@ADCSCR#(R4)		;Set hardware to this line
	MOV	R0,@ADCLPR#(R4)		;Set bits in hardware
	TST	ADCCSR#(R4)		;Check for data set control
	BEQ	CLRRTN
	CLRPSW				;Turn on interrupts
	BIC	#40,@ADCCSR#(R4)	;Clear scan enable
10$:	TBBN	20,@ADCCSR#(R4),10$	;Wait until busy has gone off
	SETPSW	#340			;Disable interrupts
	MOVB	R2,@ADCCSR#(R4)		;Point to line control register
	BISB	#5,@ADCLSR#(R4)		;Turn on RTS and line enable
	BIS	#140,@ADCCSR#(R4)	;Turn scanner and ints on
CLRRTN:	CLRPSW				;Interupts OK now
RTNCLC:	CLC				;GIVE GOOD RETURN
	RETURN				;THATS ALL

;HERE IF ERROR

RTNSEC:	SEC				;GIVE ERROR RETURN
	RETURN
	.PAGE
	.SBTTL	LINC   - PURE DATA

	PURE

;TABLE OF BITS POSITIONED FOR EACH LINE

ASCBIT:	.WORD	000001		; 0TH LINE
	.WORD	000002		; 1ST LINE
	.WORD	000004		; 2ND LINE
	.WORD	000010		; 3RD LINE
	.WORD	000020		; 4TH LINE
	.WORD	000040		; 5TH LINE
	.WORD	000100		; 6TH LINE
	.WORD	000200		; 7TH LINE
	.WORD	000400		; 8TH LINE
	.WORD	001000		; 9TH LINE
	.WORD	002000		;10TH LINE
	.WORD	004000		;11TH LINE
	.WORD	010000		;12TH LINE
	.WORD	020000		;13TH LINE
	.WORD	040000		;14TH LINE
	.WORD	100000		;15TH LINE

;TABLE OF VALUES FOR LPR FOR EACH BAUD RATE

ASCRAT:	.WORD	000000		; 0 =  AUTO-DETECT
	.WORD	002004		; 1 =    50   BAUD, 5 BITS, 1.5 STOP BITS
	.WORD	004004		; 2 =    75   BAUD, 5 BITS, 1.5 STOP BITS
	.WORD	006007		; 3 =   110   BAUD, 8 BITS, 2   STOP BITS
	.WORD	010001		; 4 =   134.5 BAUD, 7 BITS, 1   STOP BIT
	.WORD	012003		; 5 =   150   BAUD, 8 BITS, 1   STOP BIT
	.WORD	014003		; 6 =   200   BAUD, 8 BITS, 1   STOP BIT
	.WORD	016003		; 7 =   300   BAUD, 8 BITS, 1   STOP BIT
	.WORD	016002		;10 =   300   BAUD, 7 BITS, 1   STOP BIT
	.WORD	000000		;11 =   400   BAUD, 8 BITS, 1   STOP BIT
	.WORD	020003		;12 =   600   BAUD, 8 BITS, 1   STOP BIT
	.WORD	022003		;13 =  1200   BAUD, 8 BITS, 1   STOP BIT
	.WORD	024003		;14 =  1800   BAUD, 8 BITS, 1   STOP BIT
	.WORD	000000		;15 =  2000   BAUD, 8 BITS, 1   STOP BIT
	.WORD	024003		;16 =  2400   BAUD, 8 BITS, 1   STOP BIT
	.WORD	000000		;17 =  3600   BAUD, 8 BITS, 1   STOP BIT
	.WORD   030003		;20 =  4800   BAUD, 8 BITS, 1   STOP BIT
	.WORD	000000		;21 =  7200   BAUD, 8 BITS, 1   STOP BIT
	.WORD	032003		;22 =  9600   BAUD, 8 BITS, 1   STOP BIT
	.WORD	000000		;23 = 19200   BAUD, 8 BITS, 1   STOP BIT

	.END
  