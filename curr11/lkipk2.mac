	.TITLE	LKIPK2 - LINK I - TYMNET II T.201 PROTOCOL - PACKET LEVEL ROUTINES
	.SBTTL	LKIPK2 - tymshare/DRE

	XLPAR
.HLIST=!1

	CODE

	.SBTTL	EMPFRM - Empty a frame - Entry from line level routine

;Subroutine to empty a T.201 frame.  This subroutine is called by the line
;  level module whenever a frame is received.
;	C(R0) = Number of data bytes in frame
;	C(R2) = Address of frame buffer
;	C(R3) = Address of LDB for line
;	CALL	EMPFRM
;	  error return, frame not completely processed
;	normal return, frame completely processed and ready to be "ACK'ed"

EMPFRM::MOV	LDIDDB#(R3),R4		;setup R4 as the DDB pointer
	MOV	LDISPC#(R3),R1		;Get recovery address
	BEQ	EMPFR1			;Go on if recovery not needed now
	BIC	#77,R2			;Get packet pointer for this round
	MOV	LDISR2#(R3),R0		;Get the current position in packet chain
	BIC	#77,R0			;Convert to packet pointer
5$:	CMP	R2,R0			;Is the packet we are stopped on in the chain
	BEQ	10$			;Yes, continue with recovery
	MOV	(R2),R2			;Get next packet in chain
	BNE	5$			;Continue if one
	FSTOP	ZPP			;Zero packet pointer
10$:	CLR	LDISPC#(R3)		;Clear the address
	PUSH	LDISFC#(R3)		;Put frame byte count on the stack
	PUSH	LDISRC#(R3)		;And the record byte count
	MOV	LDISSD#(R3),SD		;RESTORE SD
	MOV	LDISR2#(R3),R2		;Get R2
	MOV	LDISR0#(R3),R0		;Restore R0
	PUSH	R1			;Put return address for LKINPK on the
					;  stack and fall into LKINPK

	.SBTTL	LKINPK - Get a packet

;Subroutine to get a packet - does not return until one if available!
;  **** WARNING ****  This subroutine must be called at the proper stack level!
;	C(C(SP)+4) = Frame byte count
;	C(C(SP)+2) = Record byte count
;	C(C(SP)+0) = Return address for EMPFRM call
;	CALL	LKINPK
;	C(R1) = Address of packet

LKINPK::MAKPKT	.PLSTP			;Get a packet
	BCC	RTN001			;Just return if got one

	TST	ZAPCNT			; ARE WE WAITING TO ZAP BUFFERS
	BNE	20$			; YES, JUST KEEP ON WAITING
	MOV	#3,ZAPCNT		; START ZAP COUNTER

;If no packets are available, the record and frame byte counts are saved in
;  the LDB and the error return from EMPFRM is given

20$:	MOV	R2,LDISR2#(R3)		;Save R2
	MOV	R0,LDISR0#(R3)		;And save R0
	POP	LDISPC#(R3)		;Save return address
	POP	LDISRC#(R3)		;Save record byte count
	POP	LDISFC#(R3)		;Save frame byte count
	MOV	SD,LDISSD#(R3)		;SAVE SD
RTN001:	RETURN				;And give error return from EMPFRM
	.PAGE
	.SBTTL	EMPFRM - Empty a frame - dispatch on record type

;Here when really ready to process the frame

EMPFR1:	PUSH	R0			;PUT COUNT ON THE STACK
LKINXT::SUB	#2,(SP)			;ANY MORE THERE?
	BGT	10$			;YES
2$:	TST	(SP)+			;NO-FIX UP THE STACK
	ADD	#2,(SP)			;GIVE GOOD RETURN
	CLR	ZAPCNT			;CLEAR THE ZAP COUNTER
	MOV	DDLIUP#(R4),R0		;GET UPSTREAM LINE LDB ADDRESS
	BEQ	4$			;IF NONE
	TST	LDISLH#(R0)		;ANY SUPERVISOR MESSAGES QUEUED?
	BEQ	4$			;NO
.IF EQ	..SAT
	TBBN	$L1BSY,LDIST1#(R0),4$	;YES-IS THE LINE BUSY NOW?
	PUSH	R3			;NO-START IT UP
	MOV	R0,R3
	CALL	@LDISTX#(R3)
	POP	R3
	MOV	LDIDDB#(R3),R4		;LDISTX@ SOMETIMES SMASHES R4
.IFF
	BIS	#$L1BSY,LDIST1#(R0)	;MAKE BUSY FOR NEXT ROUND
.ENDC
4$:	RETURN				;AND RETURN

;HERE IF FRAME NOT EMPTY YET

10$:	CALL	NXTCHR			;GET BYTE COUNT
	TSTB	R0
	BEQ	2$			;END OF RECORDS
	BMI	20$			;CHECK FOR FLOW CONTROL REC
	CLR	R1			;PREPARE R1 TO RECEIVE CHANNEL NUMBER
	BISB	(R2)+,R1		;GET CHANNEL NUMBER
	CALL	CHEKR2			;CHECK R2 AND ADVANCE IT IF NECESSARY
	SUB	R0,(SP)			;ACCOUNT FOR THE DATA
	BLT	ERRFRM			;MAKE SURE COUNTS ARE OK
	TST	R1			;CHECK FOR SPECIAL CHANNEL
	BNE	LKIDAT			;IF DATA RECORD
	JMP	TRCREC			;IF TRACE CIRCUIT RECORD (CHANNEL 0)

20$:	MOV	R0,R1			;COPY POSSIBLE FLOW CONTROL HEADER
	BIC	#^C^HE0,R1		;CLEAR EXTRANEOUS BITS
	CMP	#^HC0,R1		;CHECK FOR VALID HEADER
	BNE	ERRFRM			;WE CAN'T HANDLE THIS
	INC	(SP)			;COMPENSATE FOR TRYING TO HANDLE NORMAL COUNT
	BIC	#^HFFE0,R0		;CLEAR EXTRANEOUS BITS IN COUNT FIELD
	BEQ	LKINXT			;NULL COUNT - GO BACK FOR MORE
	SUB	R0,(SP)			;FIX UP RECORD DATA COUNT
	BMI	ERRFRM			;NOT ENOUGH DATA LEFT
	JMP	FLWREC			;GO HANDLE FLOW RECORD

ERRFRM:;	MOV	#.EFRL0,R0		;REASON = RECORD LENGTH = 0 (THIS IS
					;  NOT REALLY RIGHT HERE BUT ITS THE
					;  CLOSEST WE CAN GET!
	JMP	BADFRM			;GO FAIL
	.PAGE

	.SBTTL	EMPFRM - EMPTY A FRAME - DATA RECORDS
;
;	call FREPKT when orange ball is received and disconnect is
;		pending				6/29/81
;
;HERE WITH DATA RECORD

LKIDAT:	CMPB	LDICHN#(R3),R1		;LEGAL CHANNEL NUMBER?
	BLOS	ERRFRM			;NO - CALL IT AN ILLEGAL FRAME

	MOV	R1,SD			;START TO CALCULATE THE SDB FOR THIS CHANNEL
	ASL	SD			;YES-FIX IT FOR WORD INDEXING
	ADD	LDISDB#(R3),SD		;FIND CORRESPONDING SDB
	MOV	(SD),SD			;IS THERE AN SDB ASSIGNED TO THE CHANNEL;
	BEQ	LKIDA1			;NO, HANDLE NEW CIRCUIT IF NO SDB
	CMPB	R1,SDLICN#(SD)		;YES, DOES THE SDB THINK THIS IS ITS CHANNELL
	BNE	LKIDA1			;NO, MUST BE NEW DATA OR CONFUSION
	TBBE	$I2COM,SDLIS2#(SD),LKIDA2 ;CHECK FOR ORDINARY CIRCUIT
	JMP	CMDCIR			;GO HANDLE SUPERVISOR RECORDS
LKIDA1:	CALL	GRBSDB#			;GET AN SDB
	BCS	LKINXT			;CONTINUE IF CAN'T GET SOCKET
	CALL	SETINU#
	MOVB	R1,SDLICN#(SD)		;SAVE CHANNEL NUMBER IN SDB
	MOV	R3,SDLILD#(SD)		;POINT TO CORRECT LDB
	ASL	R1			;FIX CHANNEL FOR WORD INDEXING
	ADD	LDISDB#(R3),R1		;FIND CORRESPONDING SDB SLOT
	MOV	SD,(R1)			;ASSIGN CHANNEL NUMBER
	JMP	INICIR			;HANDLE CIRCUIT INITIALIZATION

;HERE WITH SDB CORRESPONDING TO THE CHANNEL

LKIDA2:	PUSH	R0			;PUT BYTE COUNT ON THE STACK
	ADD	R0,SDLIGT#(SD)		;COUNT FOR GUSH TRICKLE
.IF EQ ..SAT
	ADD	R0,SDLII1#(SD)		;UPDATE INPUT CHARACTER COUNT
	ADC	SDLII2#(SD)
.ENDC
DATLP1:	DEC	(SP)			;MORE THERE?
	BMI	DATDN3			;NO-FINISHED
DATLP2:	CALL	NXTCHR			;YES - GET NEXT BYTE
DATLP3:	CMP	#10,R0			;SPECIAL?
	BLOS	DATLP4			;NO
	JMP	DATSP4			;YES
DATLP4:
.IF NE ..TPC
	TBBN	$I1TPC,SDLIS1#(SD),DATLP6;Don't get a packet here if doing
					 ;  terminal protocol conversion
.ENDC
	CALL	LKINPK			;Get a packet
	CLRB	PKTYPE(R1)		;Make into a data packet
	ADD	#PKDATA,R1		;POINT TO FIRST DATA BYTE
DATLP6:
.IF EQ ..SAT
	TBBE	$I1PRJ,SDLIS1#(SD),20$	;IS THIS A PROJECT CODE CHARACTER?
	PUSH	R0			;Yes-save the character
	PUSH	R2			;   and the character pointer
	BIC	#^C177,R0		;JUST 7 BITS
	TSTB	SDLIPC#(SD)		;IS 1ST SLOT EMPTY?
	BNE	4$			;NO
	MOVB	R0,SDLIPC#(SD)		;YES-STORE CHARACTER
	BR	10$			;AND CONTINUE

4$:	TSTB	SDLIPC#+1(SD)		;IS 2ND SLOT EMPTY?
	BNE	6$			;NO
	MOVB	R0,SDLIPC#+1(SD)	;YES-STORE CHARACTER
	BR	10$			;CONTINUE

6$:	PUSH	R0			;SAVE THIS CHARACTER
	CALL	SNDPRJ			;SEND 3 CHARACTERS TO THE SUPERVISOR
	POP	R0			;RESTORE CHARACTER
	CMP	#40.,SDLII1#(SD)	;More than 40 chars input?
	BLO	12$			;Yes, terminate Project Code
10$:	CMP	#CR,R0			;IS THIS THE END OF THE PROJECT CODE?
	BEQ	12$			;YES
	CMP	#';,R0			;MAYBE
	BNE	16$			;No-go on
12$:	BIC	#$I1PRJ,SDLIS1#(SD)	;INDICATE NO MORE PROJECT CODE!
	TST	SDLIPC#(SD)		;ANY LEFT UNSENT?
	BEQ	16$			;NO-ALL FINISHED WITH THIS
	CLR	R0			;YES-CLEAR OUT 3RD CHARACTER
	CALL	SNDPRJ			;AND SEND 1 OR 2 CHARACTERS
16$:	POP	R2			;Restore character pointer
	POP	R0			;Restore character
20$:
.ENDC
.IF NE ..TPC
	TBBN	$I1TPC,SDLIS1#(SD),30$	;Doing terminal protocol conversion?
.ENDC
	MOVB	R0,(R1)+		;No-just store byte
	BIT	#77,R1			;Did we overflow the packet
	BNE	25$			;NO
	CALL	SNDTYM			;FLUSH THE DATA IN CASE FOR ONE USER
	CALL	LKINPK			;GET ANOTHER PACKET
	CLRB	PKTYPE(R1)		;MAKE IT A DATA TYPE PACKET
	ADD	#PKDATA,R1		;POINT TO FIRST DATA BYTE
25$:
.IF NE ..TPC
	BR	DATLP9			;Continue

30$:	PUSH	R2			;Save frame pointer
        PUSH    R3                      ;ADDED JWR 11-19-80, FOR CYTROL.
                                        ;***********PATCH***************
	CALL	LHITPC#			;Do the work
        POP     R3                      ;*********ALSO ADDED JWR********
                                        ;END OF CYTROL PATCH.
	POP	R2			;Restore frame pointer
	CLR	R1			;Remember no packet to send
.ENDC
DATLP9:	DEC	(SP)			;MORE?
	BMI	DATDN1			;NO-FINISHED
	CALL	NXTCHR			;YES - GET NEXT DATA BYTE
	CMP	#10,R0			;SPECIAL
	BLOS	DATLP6			;No-continue
	BR	DATSP1			;Yes

;HERE WHEN FINISHED

DATDN1:	TST	R1			;NULL PACKET POINTER?
.IF NE	..TPC
	BNE	DATDN2			;NO - DO REGULAR STUFF
	TBBE	$I1TPC,SDLIS1#(SD),DATDN3 ;SKIP THIS NOT DOING TPC
	CMPB	#200,SDLIBS#(SD)	;CHECK FOR DELAYED BREAK SET
	BNE	DATDN3			;EVERYTHING IS OK THEN
	CALL	SNDTPK			;SEND DATA PACKETS ON THEIR WAY
	BR	DATDN3
.IFF
	BEQ	DATDN3			;YES - DON'T TRY TO SEND IT
.ENDC
DATDN2:	CALL	SNDTYM			;SEND PENDING PACKET
DATDN3:	TST	(SP)+			;FIX UP THE STACK
DATDN4:	JMP	LKINXT			;CONTINUE WITH THE FRAME


;	NXTCHR -GET NEXT CHARACTER (LINKING TO NEXT PACKET IF NECESSARY)
;	CHEKR2 - CHECK FOR OVERFLOW INTO NEXT PACKET

NXTCHR:	MOVB	(R2)+,R0		;GET THE NEXT BYTE
CHEKR2:	BIT	#77,R2			;DID WE OVERFLOW THE PACKET
	BNE	99$			;NO
	MOV	-100(R2),R2		;LINK TO NEXT PACKET
	ADD	#2,R2			;POINT TO FIRST DATA BYTE IN PACKET
99$:	RETURN
	.PAGE
;HERE FOR SPECIAL CHARACTER CODE WHEN DATA PACKET IS BEING BUILT

DATSP1:	TST	R0			;IS THIS AN ESCAPE CODE?
	BNE	DATSP3			;NO-GO ON
DATSP2:	DEC	(SP)			;YES-DO WE HAVE ANOTHER BYTE?
	BMI	BADCPR			;No-this is very serious!
	CALL	NXTCHR			;Yes-get next byte
.IF EQ ..TPC
	BR	DATLP6			;CONTINUE
.IFF
	TBBE	$I1TPC,SDLIS1#(SD),DATLP6;Continue if doing TPC
	BIC	#77,R1			;POINT TO HEAD OF PACKET IF ANY
	BEQ	DATLP6			;NO PACKET - CONTINUE
	FREPKT				;GIVE UP THE PACKET
	BR	DATLP6
.ENDC

DATSP3:	PUSH	R0			;SAVE THE CODE
.IF NE	..TPC
	TST	R1
	BEQ	20$
	TBBE	$I1TPC,SDLIS1#(SD),10$	;SKIP THIS IF NOT DOING TPC
	CALL	SNDTPK			;SEND TERMINAL PACKET
	BR	20$
10$:
.ENDC
	CALL	SNDTYM			;SEND THE DATA PACKET
20$:	POP	R0			;RESTORE CODE
DATSP4:	CALL	LKINPK			;Get a packet
	MOVB	#.PTFUN,PKTYPE(R1)	;Make into a function packet
	ADD	#PKDATA,R1		;Point to first byte
	MOVB	#24.,PARCNT		;INITIALIZE TERMINAL PARAMETER COUNT
	ASL	R0			;FOR WORD INDEXING
	ADD	R0,PC			;DISPATCH ON THE SPECIAL CHARACTER
	BR	ESCAPE			;.CCESC = 0 - ESCAPE
	BR	PREFXC			;.CCPRE = 1 - PREFIX
	BR	GOBBLR			;.CCGBL = 2 - GOBBLER (OBSOLETE)
	BR	ZAPPER			;.CCZAP = 3 - ZAPPER
	BR	LEVDEM			;.CCLDE = 4 - LEAVE DEFERED ECHO MODE
	BR	GRNBAL			;.CCGRN = 5 - GREEN BALL
	BR	REDBAL			;.CCRED = 6 - RED BALL
	BR	ENTDEM			;.CCEDE = 7 - ENTER DEFERED ECHO MODE

;Here for escape character if do not currently have packet

ESCAPE:	CLRB	PKTYPE-PKDATA(R1)	;CHANGE TO A DATA PACKET
	BR	DATSP2			;CONTINUE

;HERE IF CHARACTER PAIR IS SPLIT AT THE END OF A RECORD

BADCPR:	DEC	R1
	BIC	#77,R1			;Point to start of packet
	FREPKT				;Give it back
;	MOV	#.ERLNS,R0		;ERROR - LINE SNIP - CHARACTER PAIR SPLIT
	INC	DDERSZ#(R4)		;Count the error
	TST	(SP)+			;CLEAR RECORD BYTE COUNT FROM STACK
	JMP	BADFRM			;GO SNIP LINE
	.PAGE
;HERE FOR ENTER DEFERED ECHO MODE CHARACTER

ENTDEM:
.IF NE ..TPC
	TBBE	$I1TPC,SDLIS1#(SD),4$	;If not doing protocol conversion
	BIC	#$T4LEM,SDLIT4#(SD)	;Indicate not local echo mode
	BR	LKIJPK			;Continue
.ENDC

4$:	PUSH	#1*400+.FNDEM		;GET TWO BYTES FOR PACKET
	BR	PKTTWO			;CONTINUE

;HERE FOR LEAVE DEFERED ECHO MODE CHARACTER

LEVDEM:
.IF NE ..TPC
	TBBE	$I1TPC,SDLIS1#(SD),4$	;If not doing protocol conversion
	BIS	#$T4LEM,SDLIT4#(SD)	;Indicate local echo mode
	BR	LKIJPK			;Continue
.ENDC

4$:	PUSH	#0*400+.FNDEM		;GET TWO BYTES FOR PACKET
PKTTWO:	PUSH	#2			;BYTE COUNT = 2
	JMP	PKTFNX			;CONTINUE

;HERE FOR RED BALL CHARACTER

REDBAL:
.IF NE ..TPC
	TBBE	$I1TPC,SDLIS1#(SD),10$	;Go on if not doing protocol conversion
	BIC	#$I1GBP,SDLIS1#(SD)	;Green ball no longer pending if it was
	MOV	#.FNRED,R0		;Echo back a red ball
	BR	PKTBCK
.ENDC

10$:	PUSH	#.FNRED			;GET SINGLE BYTE FOR PACKET
	BR	PKTO2E			;CONTINUE

;HERE FOR GREEN BALL CHARACTER

GRNBAL:
.IF NE ..TPC
	TBBE	$I1TPC,SDLIS1#(SD),GRNBA4;If not doing protocol conversion
	TBBN	$T1DEA,SDLIT1#(SD),LKIJPK;Ignore this if delete echo is active
	TST	SDPKDH#(SD)		;Any output pending now?
	BEQ	GRNBA2			;No
	BIS	#$I1GBP,SDLIS1#(SD)	;Yes-indicate green ball is pending
LKIJPK:	BIC	#77,R1			;Point to beginning of packet
	FREPKT				;Give up the packet
	JMP	DATLP1			;Continue

;Here if no output for this socket

GRNBA2:	MOV	#.FNGRN,R0		;Echo back the green ball
PKTBCK:	BIC	#77,R1			;POINT TO START OF PACKET
	CALL	BALBC2			;Send the ball back to ourselves!
	JMP	DATLP1			;Thats all
.ENDC

GRNBA4:	PUSH	#.FNGRN			;GET SINGLE BYTE FOR PACKET
PKTO2E:	JMP	PKTONE			;CONTINUE

;HERE FOR CHARACTER GOBBLER CHARACTER

GOBBLR:	BIC	#77,R1			;Point to start of packet
	MOV	#.PTEAT*400+1,PKCNT(R1)	;MAKE THIS A 1 BYTE EAT PACKET
	CLRB	PKDATA(R1)		;FUNCTION = NULL
SNDPKY:	CALL	LKISPK			;SEND THE PACKET
	JMP	DATLP1			;CONTINUE

PREFXC:	BR	PREFXX			;HANDLE PREFIX CHAR

;HERE FOR CIRCUIT ZAPPER AND GOBBLER CHARACTERS

ZAPPER:	DEC	(SP)			;CHECK FOR NEXT BYTE
ZAPPE0:	BLT	BADCPR			;NOT THERE - BAD NEWS
	CALL	NXTCHR			;GET NEXT BYTE
	CMPB	#.ZCNGB,R0		;CHECK FOR SHORT ZAPPER
	BGE	5$			;GOT HARD, SOFT OR NON-GOBBLING
	CMPB	#.ZCGOB,R0		;CHECK FOR GOBBLER
	BEQ	GOBBLR
	SUB	#4,(SP)			;ALL OTHERS HAVE 4 MORE BYTES
	BLT	BADCPR			;NOT ENOUGH - ERROR
	PUSH	R0			;SAVE THE CHARACTER
	CALL	NXTCHR
	CALL	NXTCHR
	CALL	NXTCHR
	CALL	NXTCHR
	POP	R0			;GET BACK SECOND CHAR OF ZAPPER
	CMPB	#.ZCFGB,R0		;CHECK FOR FAT GOBBLER
	BEQ	GOBBLR
	CMPB	#.ZCFZP,R0		;CHECK FOR FAT ZAPPER
	BEQ	5$			;FINISH UP FAT ZAP
	JMP	DATLP1			;IGNORE EVERYTHING ELSE
5$:	TBBE	$I1DTP,SDLIS1#(SD),10$	;DO WE HAVE A DISCONNECT PENDING
	MOV	SDPKDH#(SD),R0		;YES - GET SAVED PACKET POINTER
	BEQ	10$			;NO SAVED PACKET?????
	CMPB	#.PTDIS,PKTYPE(R0)	;IS IT A DISCONNECT
	BNE	10$			;NO - VERY STRANGE?????
	JMP	ORGBAL			;TREAT LIKE ORANGE BALL
10$:	PUSH	R1
.IF EQ ..SAT
	MOV	#.S7OCU*10000,R0	;GET REASON FOR ZAP
.ENDC
	MOV	SDDDB#(SD),R4
	CALL	BRKCIR			;BREAK THE CIRCUIT TO TYMNET
	POP	R1
	BIC	#77,R1			;Point to start of packet
	MOV	#.ERREQ+200,R0		;NEXNET REASON = "REQUEST"
	CALL	SETDIS#			;SETUP THE PACKET
	BR	SNDPKY			;GO SEND IT AND CONTINUE
	.PAGE
;HERE FOR PREFIX CHARACTER

PREFXX:	DEC	(SP)			;IS THERE ANOTHER CHARACTER?
	BLT	ZAPPE0			;NO-BIG TROUBLE!!
	CLR	R0			;GET NEXT CHARACTER
	BISB	(R2),R0
PREFX2:	TSTB	PARCNT			;ROOM FOR MORE PARAMETERS IN THIS PACKET?
	BGT	PREFX4			;YES-GO ON
PREFX3:	CALL	SNDTYM			;NO-SEND THE PACKET
	INC	(SP)			;PUT BACK THE LAST CHARACTER
	DEC	R2
	JMP	DATLP2			;AND GO PROCESS THE REST FROM THE TOP

PREFX4:	ASHI	-4,R0			;GET SUBTYPE
	ASL	R0			;FOR WORD INDEXING
	PUSH	R0			;Stack the index
	CALL	NXTCHR			;Get low order bits back
	ADD	(SP)+,PC		;DISPATCH ON THE SUBTYPE
	BR	ECHCON		;.PCECH =   0 - ECHO CONTROL (OLD STYLE)
	BR	INPRAT		;.PCCIR =  20 - CR delay flag and input baud
				;		  rate (old style)
	BR	CONDNX		;	=  40 - ILLEGAL
	BR	CONDNX		;	=  60 - ILLEGAL
	BR	PARAMD		;.PCPMD = 100 - PARAMETER D
	BR	PARAMC		;.PCPMC = 120 - PARAMETER C
	BR	PARAMB		;.PCPMB = 140 - PARAMETER B
	BR	PARAMA		;.PCPMA = 160 - PARAMETER A
	BR	OUTRAT		;.PCOBR = 200 - OUTPUT BAUD RATE
	BR	QRYFLD		;.PCQFL = 220 - QUERY FIELD
	BR	QRYBIT		;.PCQBT = 240 - QUERY BIT
	BR	QRYBIT		;	= 260 - QUERY BIT
	BR	SETBIT		;.PCSBT = 300 - SET BIT
	BR	SETBIT		;	= 320 - SET BIT
	BR	CONDNX		;	= 340 - ILLEGAL
	JMP	CONINF		;.PCCON = 360 - CONTROL INFORMATION

CONDNX:	JMP	CONDON

;HERE FOR SUBTYPE .PCECH = 0 - ECHO CONTROL (OLD STYLE)

ECHCON:	PUSH	#.TPECH*400		;GET TERMINAL PARAMETER FOR ECHOING
	TBBE	$ECECO,R0,2$		;SHOULD ECHOING BE ON?
	INC	(SP)			;YES
2$:	PUSH	#.TPSHT*400		;GET HORIZONTAL TAB PARAMETER
	TBBE	$ECECI,R0,4$		;SHOULD IT BE SET?
	INC	(SP)			;YES
4$:	PUSH	#.TPCRI*400		;GET CARRIAGE RETURN INSERSION PARAMETER
	TBBE	$ECELC,R0,6$		;SHOULD IT BE SET?
	BIS	#4,(SP)			;YES
6$:	PUSH	#.TPLFI*400		;GET LINE FEED INSERSION PARAMETER
	TBBE	$ECECL,R0,10$		;SHOULD IT BE SET?
	BIS	#4,(SP)			;YES
10$:	MOV	#4,R0			;GET COUNT
	BR	PARSN1			;CONTINUE

;Here for subtype .PCCIR = 020 - Set/report CR delay flag and input baud rate
;  (old style)

INPRAT:	PUSH	#.TPBLT*400		;Get first terminal parameter
	TBBN	$ECCRD,R0,2$		;Check value
	INC	(SP)			;Set it
2$:	PUSH	#.TPIRT*400		;Get second terminal parameter
	BIC	#^C$ECIBR,R0		;Just 3 bits
	MOVB	TYNRTN#(R0),(SP)	;Get Nexilis baud rate code
	MOV	#2,R0			;Get number of parameters
	BR	PARSN1			;Continue

;HERE FOR SUBTYPE .PCPMD = 100 - SET/REPORT PARAMETER D

PARAMD:	PUSH	#.TPLFD*400		;GET CORRESPONDING TERMINAL PARAMETER
	BR	PARAM2			;CONTINUE

;HERE FOR SUBTYPE .PCPMC = 120 - SET/REPORT PARAMETER C

PARAMC:	PUSH	#.TPMCD*400		;GET CORRESPONDING TERMINAL PARAMETER
PARAM2:	BIC	#^C17,R0		;VALUE IF 4 BITS
	MOVB	TYNFNF#(R0),(SP)	;APPLY "FUNCTION F"
	BR	PARSND			;Continue

;HERE FOR SUBTYPE .PCPMB = 140 - SET/REPORT PARAMETER B

PARAMB:	PUSH	#.TPFCD*400		;GET CORRESPONDING TERMINAL PARAMETER
	BR	PARAM3			;CONTINUE

;HERE FOR SUBTYPE .PCPMA = 160 - SET/REPORT PARAMETER A

PARAMA:	PUSH	#.TPVCD*400		;GET CORRESPONDING TERMINAL PARAMETER
PARAM3:	BIC	#^C17,R0		;VALUE IS 4 BITS
PARAM4:	MOVB	R0,(SP)			;STORE VALUE ON THE STACK
	BR	PARSND			;CONTINUE

;HERE FOR SUBTYPE .PCOBR = 200 - SET/REPORT OUTPUT BAUD RATE

OUTRAT:	PUSH	#.TPORT*400		;GET TERMINAL PARAMETER
	BIC	#^C17,R0		;JUST 4 BITS
	MOVB	TYNRTN#(R0),(SP)	;GET NEXILIS BAUD RATE CODE
	BR	PARSND			;Continue
	.PAGE
;HERE FOR SUBTYPE .PCQFL = 220 - QUERY FIELD

QRYFLD:	BIC	#^C17,R0		;ONLY 4 BITS
	CLR	-(SP)
	MOVB	FLDTBL(R0),1(SP)	;GET CORRESPONDING TERMINAL PARAMETER
	BR	QRYSND			;CONTINUE

;TABLE TO CONVERT TO TERMINAL PARAMETER

	PURE

FLDTBL:	.BYTE	0		;	=  0 - ILLEGAL
	.BYTE	0		;	=  1 - ILLEGAL
	.BYTE	0		;	=  2 - ILLEGAL
	.BYTE	.TPIRT		;	=  3 - INPUT BAUD RATE
	.BYTE	.TPLFD		;.QFPMD =  4 - PARAMETER D
	.BYTE	.TPMCD		;.QFPMC =  5 - PARAMETER C
	.BYTE	.TPFCD		;.QFPMB =  6 - PARAMETER B
	.BYTE	.TPVCD		;.QFPMA =  7 - PARAMETER A
	.BYTE	.TPORT		;.QFOBR = 10 - OUTPUT BAUD RATE
	.BYTE	0		;	= 11 - ILLEGAL
	.BYTE	0		;	= 12 - ILLEGAL
	.BYTE	0		;	= 13 - ILLEGAL
	.BYTE	0		;	= 14 - ILLEGAL
	.BYTE	0		;	= 15 - ILLEGAL
	.BYTE	0		;	= 16 - ILLEGAL
	.BYTE	0		;	= 17 - ILLEGAL

	CODE

;HERE FOR SUBTYPE .PCQBT = 240 - QUERY BIT

QRYBIT:	BIC	#^C36,R0		;JUST 4 BITS
	ASR	R0
	CLR	-(SP)
	MOVB	BITTPR(R0),1(SP)	;GET CORRESPONDING TERMINAL CODE
QRYSND:	BEQ	QRYBAD			;IF ILLEGAL
	BIS	#100000,(SP)		;Indicate should nonge parameter
	BR	PARSND			;CONTINUE

;HERE FOR SUBTYPE .PCSBT = 300 - SET/REPORT BIT

SETBIT:	BIC	#^C37,R0		;ONLY 4 BITS
	ROR	R0
	PUSH	R0			;MAKE A HOLE ON THE STACK WITHOUT
					;  CHANGING C !!!!!
	MOVB	BITTPR(R0),1(SP)	;GET TERMINAL PARAMETER ON THE STACK
	BEQ	QRYBAD			;IF ILLEGAL
	MOVB	BITTRU(R0),(SP)		;ASSUME VALUE IS 1
	BCS	PARSND			;IF IT WAS
	MOVB	BITFLS(R0),(SP)		;NO-ITS = 0
	BR	PARSND

;HERE IF ERROR

QRYBAD:	TST	(SP)+			;FIX UP THE STACK
	JMP	CONDON			;CONTINUE

;TABLES TO CONVERT TO TERMINAL PARAMETER

	PURE

	.MACRO	TBL
	XX	.TPECH,  0,  1	;.QBECN =  0 - ECHO CONTROL
	XX	.TPEHT,  0,  1	;.QBECI =  2 - ECHO CONTROL-I
	XX	.TPLFI,  0,  4	;.QBECL =  4 - ECHO CR WITH LF
	XX	.TPCRI,  0,  4	;.QBELC =  6 - ECHO LF WITH CR::RUBOUT
	XX	.TPLCP,  0,  1	;.QBHDP = 10 - HALF DUPLEX
	XX	.TPPAR,  0,  4	;.QBPAR = 12 - PARITY
	XX	.TPIHE,  0,  1	;.QBXEN = 14 - XON/OFF ENABLE
	XX	.TPBLT,  1,  0	;.QBCRD = 16 - CR DELAY FLAG
	XX	.TPEBS,  0,  1	;.QBECH = 20 - ECHO CONTROL-H
	XX	.TPOHE,  0,  1	;.QBRXE = 22 - REVERSE X-ENABLE
	XX	.TPKAT,  0,  1	;.QBKAT = 24 - KATAKANA
	XX	.TPTOB,	 0,  1	;	= 26 - TERMINATE OUTPUT ON BREAK
	XX	.TPECE,	 0,  1	;	= 30 - ECHO ESCAPE MODE
	XX	.TPQMD,	 0,  1	;	= 32 - "Q" MODE FOR 3270 TERMINAL EMULATION
	XX			;	= 34 - ILLEGAL
	XX			;	= 36 - ILLEGAL
	.ENDM

;GENERATE TABLE OF NEXILIS TERMINAL PARAMETERS

	.MACRO	XX  PAR,FLS,TRU
.IF NB PAR
	.BYTE	PAR
.IFF
	.BYTE	0
.ENDC
	.ENDM

BITTPR:	TBL

;GENERTE TABLE OF PARAMETER VALUES USED WHEN TYMSHARE VALUE IS 0

	.MACRO	XX  PAR,FLS,TRU
.IF NB PAR
	.BYTE	FLS
.ENDC
	.ENDM

BITFLS:	TBL

;GENERATE TABLE OF PARAMETER VALUES USED WHEN TYMSHARE VALUE IS 1

	.MACRO	XX  PAR,FLS,TRU
.IF NB PAR
	.BYTE	TRU
.ENDC
	.ENDM

BITTRU:	TBL

	CODE
	.PAGE
;HERE TO SEND A "REPLY WITH" OR "SET" PARAMETER FUNCTION DEPENDING ON THE
;  DIRECTION

PARSND:	MOV	#1,R0			;GET COUNT

;Here when all ready to generate a terminal parameter function packet
;	C(R0)      = FUNCTION FOR PACKET
;	C(R0)      = NUMBER OF PARAMETER PAIRS
;	C(C(SP))   = FIRST PARAMETER PAIR
;	C(C(SP)+2) = SECOND PARAMETER PAIR
;	.....

PARSN1:	TBBN	71,R1,4$		;Is this first parameter for the packet?
	MOVB	#.FNRDP,(R1)		;YES-assume should be report parameters
	CMPB	#.IDTR#,SDSDID#(SD)	;Are we connected to a terminal?
	BNE	2$			;No
	MOVB	#.FNCDP,(R1)		;Yes-should be change parameters
2$:	INC	R1			;Bump pointer
4$:	DECB	PARCNT			;COUNT THIS PARAMETER PAIR
	MOVB	1(SP),(R1)+		;Store parameter in packet
	POPB	(R1)+			;Store value in packet
	SOB	R0,4$			;CONTINUE IF MORE
CONDON:	DEC	(SP)			;ANY MORE CHARACTERS THERE?
	BPL	2$			;YES
	JMP	DATDN2			;Continue

2$:	MOVB	(R2)+,R0		;GET NEXT CHARACTER
	CMPB	#1,R0			;PREFIX CHARACTER?
	BNE	5$			;NO
	DEC	(SP)			;Is there another character?
	BPL	3$			;Yes-go on
	JMP	BADCPR			;No-this is serious!

3$:	BIT	#77,R2			;Did we overflow the block
	BNE	4$			;NO
	MOV	-100(R2),R0		;GET POINTER TO NEXT BLOCK
	ADD	#2,R0			;POINT TO FIRST DATUM
	CMPB	(R0),#360		;IS IT ANOTHER TERMINAL PARAMETER
	BHIS	6$			;No
	MOV	R0,R2			;COPY POINTER
4$:	CLR	R0			;Get next character
	BISB	(R2),R0
	CMP	R0,#360			;Another terminal parameter?
	BHIS	6$			;No
	JMP	PREFX2			;Yes-go process it

5$:	DEC	(SP)
6$:	JMP	PREFX3
	.PAGE
;HERE FOR SUBTYPE .PCCON = 360 - CONTROL INFORMATION

CONINF:	BIC	#^C17,R0		;ONLY 4 BITS
	ASL	R0			;FOR WORD INDEXING
	JMP	@CONDSP(R0)		;Dispatch on the code

;Dispatch table for control information

	PURE

CONDSP:	.WORD	HNGCHR		;.CIHNG =  0 - HANG CHARACTER
	.WORD	TRNHNG		;.CITRH =  1 - TURNAROUND HANG CHARACTER
	.WORD	ENTTRN		;.CIETR =  2 - ENTER TRANSPARANCY MODE
	.WORD	LEVTRN		;.CILTR =  3 - LEAVE TRANSPARANCY MODE
	.WORD	ENTADM		;.CIEAD =  4 - ENTER ALTERNATE DEVICE MODE
	.WORD	LEVADM		;.CILAD =  5 - LEAVE ALTERNATE DEVICE MODE
	.WORD	CONDON		;	=  6 - ILLEGAL
	.WORD	CONDON		;	=  7 - ILLEGAL
	.WORD	CONDON		;	= 10 - ILLEGAL
	.WORD	CONDON		;	= 11 - ILLEGAL
	.WORD	CONDON		;	= 12 - ILLEGAL
	.WORD	HAVBRK		;.CIBRK = 13 - BREAK DETECTED
	.WORD	GRYBAL		;.CIGRY = 14 - GRAY BALL
	.WORD	BLKBAL		;.CIBLK = 15 - BLACK BALL
	.WORD	ORGBAL		;.CIORG = 16 - ORANGE BALL
	.WORD	YELBAL		;.CIYEL = 17 - YELLOW BALL

	CODE

;HERE FOR CODE .CIHNG = 0 - HANG CHARACTER

HNGCHR:	PUSH	#.FNHNG			;GET FUNCTION
	BR	PKTONE			;CONTINUE

;HERE FOR CODE .CITRH = 1 - TURNAROUND HANG CHARACTER

TRNHNG:	PUSH	#.FNXHG			;GET FUNCTION
	BR	PKTONE

;HERE FOR CODE .CIETR = 2 - ENTER TRANSPARANCY MODE

ENTTRN:	PUSH	#.TPTRN*400+1		;GET PARAMETER AND VALUE
	BR	PARSND			;CONTINUE

;HERE FOR CODE .CILTR = 3 - LEAVE TRANSPARANCY MODE

LEVTRN:	PUSH	#.TPTRN*400+0		;GET PARAMETER AND VALUE
	BR	PARSND			;CONTINUE

;HERE FOR CODE .CIEAD = 4 - ENTER ALTERNATE DEVICE MODE

ENTADM:	PUSH	#.TPADM*400+1		;GET PARAMETER AND VALUE
	BR	PARSND			;CONTINUE

;HERE FOR CODE .CILAD = 5 - LEAVE ALTERNATE DEVICE MODE

LEVADM:	PUSH	#.TPADM*400+0		;GET PARAMETER AND VALUE
	BR	PARSND			;CONTINUE

;HERE FOR CODE .CIBRK = 13 - BREAK DETECTED

HAVBRK:	PUSH	#.FNBRK			;GET FUNCTION
	BR	PKTONE			;CONTINUE

;HERE FOR CODE .CIBRY = 14 - GRAY BALL

GRYBAL:	PUSH	#.FNLSX			;GET FUNCTION
	BR	PKTONE			;CONTINUE

;HERE FOR CODE .CIBLK = 15 - BLACK BALL

BLKBAL:	PUSH	#.FNLST			;GET FUNCTION
	BR	PKTONE			;CONTINUE

;HERE FOR CODE .CIORG = 16 - ORANGE BALL

ORGBAL:	TBBE	$I1DTP,SDLIS1#(SD),10$	;Is a disconnect pending?
	BIC	#77,R1			;YES, POINTS TO BEGINING OF THE PACKET
	FREPKT				;free the packet allocated
	MOV	SDPKDH#(SD),R1		;Get the packet on the Dest_List
	BEQ	10$			;No packet - verry strange
	CMPB	#.PTDIS,PKTYPE(R1)	;Is it a disconnect packet?
	BNE	10$			;No-someone is very mixed up!
	MOVB	#.PTKIL,PKTYPE(R1)	;Change it to a kill packet
	MOV	#77777,SDACNT#(SD)	;Allow output now
	PUSH	R2
	PUSH	R3
	CALL	LIPOKE#			;Wake up the output side 
	POP	R3
	POP	R2
	POP	R1			;Get count of remaining data
	BEQ	5$			;No more data in this record
4$:	CALL	NXTCHR			;Data remains, get rid of it
	SOB	R1,4$			;Zap it all
;	JMP	DATLP1			;Thats all
5$:	JMP	LKINXT			;End of record, get next one

10$:	PUSH	#.FNRSP			;GET FUNCTION
	BR	PKTONE			;CONTINUE

;HERE FOR CODE .CIYEL = 17 - YELLOW BALL

YELBAL:	PUSH	#.FNREQ			;GET FUNCTION
PKTONE:	PUSH	#1			;GET BYTE COUNT
PKTFNX:	BIC	#77,R1			;Point to beginning of packet
	MOVB	#.PTFUN,PKTYPE(R1)	;THIS IS A FUNCTION PACKET
	POPB	PKCNT(R1)		;STORE COUNT
	POP	PKDATA(R1)		;STORE DATA
	JMP	SNDPKY			;SEND IT AND CONTINUE
	.PAGE
	.SBTTL	LKITNS - 10 times a second routine

;THIS SUBROUTINE IS CALLED 10 TIMES A SECOND (WE REALLY ONLY NEED IT 2 TIMES A
;  SECOND, BUT THE EXEC DOES NOT DO THINGS AT THAT RATE!)
;	CALL	LKITNS

	TNHSEC	LKITNS

LKITNS:	MOV	#LKIDDB#,R4		;POINT TO FIRST DDB
2$:	TSTB	HLFCNT			;TIME TO DO SOMETHING HERE?
	BGT	40$			;NO-NOTHING THIS TIME
	MOV	DDLILD#(R4),R3		;POINT TO FIRST LDB
3$:	TBBN	$L1UNV!$L1DWN!$L1IGN,LDIST1#(R3),4$ ;IS THIS LINE BUSY NOW?
	BIS	#$L1FLW!$L1BSY,LDIST1#(R3) ;INIDCATE TIME FOR FLOW CONTROL RECORD
	INCB	LDIAUA#(R3)		;COUNT FLOW CONTROL REQUEST AS UNSENT ACK
4$:	TST	LKI256			;TIME FOR EVERY-256-SECONDS STUFF?
	BGT	30$			;NO-GO ON
	MOV	#ERRTBS,SD		;YES-POINT TO ERROR TABLE
	CLR	SUPMSG			;USE THIS AS A FLAG
10$:	MOV	(SD)+,R2		;GET OFFSET FOR WORD WHICH CONTAINS
					; COMPARISON VALUE
	BEQ	20$			;IF FINISHED
	ADD	R3,R2			;PLUS BASE OF LDB
	PUSH	(R2)			;SAVE VALUE ON STACK
	MOV	(SD)+,R1		;GET OFFSET FOR ERROR COUNTER 
	ADD	R3,R1			;PLUS OFFSET OF LDB
	MOV	(R1),R2			;GET ERROR COUNTER VALUE
	CLR	(R1)			;CLEAR ERROR COUNTER
	MOV	(SD)+,R1		;GET MULTIPLIER
	MUL	R2,R1			;FORM ERROR COUNTER * FACTOR
	CMP	R1,(SP)			;COMPARE TO THRESHOLD
	BLOS	14$			;GO ON IF NOT OVER THE THRESHOLD
					;REPORT IT IF TOO BIG
	MOV	(SP),R1			;GET THE NUMBER OF PACKETS
	PUSH	SD			;SAVE THE BASE REGISTER FOR LATER
	MOV	#SUPMSG,R0		;POINT TO START OF MESSAGE
	MOV	#^H8012,(R0)+		;SEND ERROR LOG REPORT MESSAGE 
	MOVB	(SD),(R0)+		;GET MESSAGE TEMPLATE

	MOVB	LDILNO#(R3),(R0)+	;PUT IN LINE NUMBER
	MOV	LDINBR#(R3),SD		;GET THE NEIGHBOR NUMBER
	BIS	#^H8000,SD		;PUTIN ESCAPE BIT
	SWAB	SD
	MOV	SD,(R0)+
	SWAB	R2			;SHIFT BITS AROUND IN COUNT
	MOV	R2,(R0)+		;PUT COUNT IN BUFFER
	SUB	#SUPMSG,R0		;SET IN LENGTH OF MESSAGE	
	CALL	SNDSPR			;SEND TO SUPERVISOR
	POP	SD			;RESTORE BASE REGISTER
14$:	CMP	(SD)+,(SP)+		;ADVANCE TO NEXT TABLE ENTRY AND CLEAN UP STACK
	BR	10$			;CONTINUE
20$:	TST	SUPMSG			;DID WE SEND ANY REPORTS
	BEQ	25$			;NO
	MOVB	#^H80,SUPMSG+2		;PUT IN TOTAL COUNT MESSAGE
	MOV	LDPKIN#(R3),SUPMSG+4	;STORE PACKET IN COUNTER
	SWAB	SUPMSG+4		;PUT IN SUP ORDER
	MOV	LDPKOT#(R3),SUPMSG+6
	SWAB	SUPMSG+6
	MOV	#10,R0
	CALL	SNDSPR			;SEND IN THE TOTALS
25$:	CLR	LDPKOT#(R3)		;CLEAR THE PACKET OUT COUNTER
	CLR	LDPKIN#(R3)		;CLEAR THE PACKET IN COUNTER

30$:	MOV	LDINXT#(R3),R3		;STEP TO NEXT LDB
	BNE	3$			;CONTINUE IF MORE
;*******************************************************************
;
; 	Code added below to handle X.3 idle timer.
;
;*******************************************************************

40$:
.IF NE	..TPC
	MOV	DDSX#(R4),R1		;R1 -> SDB TABLE
	MOVB	DDSOC#(R4),R2		;GET NUMBER # OF SDBS

47$:	MOV	(R1)+,SD		;GET NEXT SDB ADDRESS 
	TSTB	SDLIT6#(SD)		;TEST THE RUNNING IDLE TIMER.
	BEQ	60$			;BRANCH IF IT IS NOT ACTIVE
	TBBN	$T5EDT,SDLIT5#(SD),60$	; OR IF LINE-EDITING IS ENABLED.
	DECB	SDLIT6#(SD)		;OTHERWISE RUN DOWN THE TIMER
	BEQ	50$			;TIME IS UP.
	DECB	SDLIT6#(SD)		;
	BNE	60$			;NOT TIME YET
50$:	PUSH	R1			;SAVE TABLE POINTER
	CALL	SNDTPK			;SEND THE TERMINAL PACKET
					; IT SAVES R2 AND R3
					;AND IDLE TIMER WILL BE RESTARTED
					; WHEN DATA COME IN AGAIN
	POP	R1			;GET SDB TABLE POINTER AGAIN
60$:	SOB	R2,47$			;LOOP IF MORE SDB TO TEST
.ENDC
	MOV	DDLKNS#(R4),R4		;STEP TO NEXT DDB
	BNE	2$			;CONTINUE IF MORE
	DECB	HLFCNT			;TIME TO DO SOMETHING HERE?
	BGE	70$			;NO-NOTHING THIS TIME
	MOVB	#4,HLFCNT		;YES-RESET COUNTER
70$:	DEC	LKI256			;DECREMENT 256 SECOND COUNTER
	BGE	RTN009			;TIME TO RESET IT?
	MOV	#512.,LKI256		;YES-DO THAT
RTN009:	RETURN				;THATS ALL
	.PAGE
	.SBTTL	LKISEC - Once a second routine

;This subroutine is called once a second (we really only need it once a
;  minute!)
;	CALL	LKISEC

	ONCSEC	LKISEC

LKISEC:	TST	ZAPCNT			;IS THE ZAP COUNTER ACTIVE?
	BEQ	LKIMIN			;NO
	DEC	ZAPCNT			;YES-COUNT IT DOWN
	BGT	LKIMIN			;DID IT RUN OUT?
	CALL	ZAPBUF#			;YES-ZAP A BUFFER
	  NOP				;DON'T WORRY IF IT FAILED!
;	MOV	#3,ZAPCNT		;DO THIS AGAIN IN 3 SECONDS IF CAN'T
					;  DO OUTPUT NOW!
LKIMIN:
.IF EQ ..SAT
	DECB	LKIMNC			;Time to do something here?
	BGT	RTN011			;No-nothing this time
	MOVB	#60.,LKIMNC		;Yes-reset counter
	MOV	#LKIDDB#,R4		;Point to first type I DDB
2$:	TST	DDLIUP#(R4)		;Has this link been "taken over"?
	BEQ	24$			;No-skip it
	MOV	R4,R3			;Yes-initialize index
	PUSHB	DDLINH#(R4)		;And count
4$:	MOV	DDLISS#(R3),SD		;Does this connection exist now?
	BEQ	6$			;No, see if it needs a supervisory circuit
	CMPB	#.SSCON,SDSTS1#(SD)	;Is it still connected?
	BNE	6$			;No, make a new circuit
	TBBN	$I1SPR,SDLIS1#(SD),20$	;Skip if it thinks it is a supervisory circuit
6$:	TSTB	DDLIHD#+2(R3)		;Is this a device on a node
	BNE	20$			;Yes, declared up at takeover
	PUSH	R3			;No, try to bring it up
	CALL	GRBSDB#			;Get an SDB
	BCS	14$			;Forget it if none available now!
	MAKPKT	.PLSTP#			;Get a packet
	BCC	8$			;Go on if got one
	CALL	FRESOC#			;Opps-give back the SDB
	BR	14$			;And forget it for now!

;Here with SDB and packet

8$:	BIS	#$I1SPR,SDLIS1#(SD)	;Indicate supervisory connection
	MOV	SD,DDLISS#(R3)		;REMEMBER THIS SDB
	SUB	R4,R3			;CALCULATE INDEX
	MOV	R3,SDLIVH#(SD)		;Save it for later use
	MOV	R1,R2			;Clear the packet
	MOV	#30,R0
10$:	CLR	(R2)+
	SOB	R0,10$
	PUSH	R4			;Save registers
	PUSH	R1
	MOV	4(SP),R4		;Point to host name
	ADD	#DDLIDH#,R4
	ADD	#PKDATA+6,R1
	CALL	RD50XX#			;Put name into connect packet
	CALL	RD50XX#
	POP	R1			;Restore registers
	POP	R4
	MOVB	#200,PKDATA+27(R1)	;Indicate supervisory connection
	MOV	#.PTCON*400+37,PKCNT(R1);Store packet type and count
	CALL	TYMCON#			;Finish making the connect packet and
					;  send it
14$:	POP	R3			;Restore registers
20$:	ADD	#4,R3			;Bump pointer
	DECB	(SP)			;Count down
	BGT	4$			;Continue if more to do here
	TST	(SP)+			;Clear stack
24$:	MOV	DDLKNS#(R4),R4		;Step to next type I link
	BNE	2$			;Continue if more
.ENDC
RTN011:	RETURN				;Thats all
	.PAGE
	.SBTTL	SNDTYM - SEND DATA PACKET INTO NODE

;	C(R1) = CURRENT POINTER INTO PACKET BEING BUILT
;	CALL	SNDTYM
;  R2 AND R3 ARE RESPECTED

SNDTYM::MOV	R1,R0			;CALCULATE SIZE OF PACKET
	DEC	R1			;IN CASE THE PACKET IS FULL!
	BIC	#77,R1			;POINT TO START OF PACKET
	SUB	R1,R0
	SUB	#PKDATA,R0
	BNE	2$			;Go on if packet not empty
	FREPKT				;Empty-just give it back!
	RETURN				;And return

2$:	MOVB	R0,PKCNT(R1)		;Store count
LKISPK::
.IF EQ	..SAT
	MOV	SDLISC#(SD),R0		;GET SAVED PACKET POINTER IF ANNY
	BNE	10$			;SAVING DATA BECAUSE CIRCUIT NOT COMPLETE
.ENDC
	PUSH	R2			;SAVE VALUABLE REGISTERS
	PUSH	R3
	INCB	SDPCNT#(SD)
	CALL	SNDPKT#			;SEND THE PACKET
	POP	R3			;RESTORE REGISTERS
	POP	R2
	RETURN				;AND RETURN
.IF EQ	..SAT
5$:	MOV	(R0),R0			;TRACE DOWN LINK TO NEXT PACKET
10$:	TST	(R0)			;LINKED TO ANOTHER PACKET
	BNE	5$			;YES
	MOV	R1,(R0)			;LINK IN THIS PACKET
	RETURN
.ENDC

; SNDTPK - SEND OFF TERMINAL PACKETS FORMED BY PUTCHR

.IF NE	..TPC
SNDTPK:	PUSH	R3			;SAVE THE LDB POINTER
	PUSH	R2			;SAVE THE INPUT FRAME POINTER
	CALL	SNDTRP#			;SEND THE PACKETS ON THEIR WAY
	POP	R2
	POP	R3
	RETURN
.ENDC
	.PAGE
	.SBTTL	SNDPRJ - SEND PROJECT CODE CHARACTER TO SUPERVISOR

;SUBROUTINE TO SEND 3 PROJECT CODE CHARACTERS TO THE SUPERVISOR
;	C(R0) = 3RD CHARACTER
;	CALL	SNDPRJ

.IF EQ ..SAT

SNDPRJ:	MOV	LDIDDB#(R3),R4		;MAKE SURE R4 IS RIGHT!
	PUSH	R1			;SAVE R1
	CALL	SPRINV			;SEE IF WE SHOULD SEND INVOICE NUMBER
	 BR	 10$			;INVOICE NOT SET OR NO SUP
	PUSH	#.S7PRJ*10000		;SR2
	MOVB	SDLIPC#(SD),(SP)	;PUT 1ST CHARACTER INTO SR2
	MOVB	R0,SDLIPC#(SD)		;STORE 3RD CHARACTER FOR SR3
	PUSH	SDLIPC#(SD)		;SR3
	CALL	SNDACT			;SEND TO SUPERVISOR
	CLR	SDLIPC#(SD)		;CLEAR THE CHARACTERS WE HAVE SENT
10$:	POP	R1			;RESTORE R1
	RETURN				;THATS ALL

.ENDC
	.PAGE
	.SBTTL	Send ball back to TYMnet

;Subroutine to send a ball back to TYMnet
;	C(R0) = Function value for ball
;	CALL	BALBCK

BALBCK::MAKPKT	.PLSTP#			;Get a packet
	BCS	BALBC4			;Oh-well
BALBC2:	MOV	#.PTFUN*400+1,PKCNT(R1)	;Make into 1 byte function packet
	MOVB	R0,PKDATA(R1)		;Store function value
	PUSH	R2			;Save valuable AC's
	PUSH	R3
	CALL	PKTSLF#			;Send the packet back to us
	POP	R3			;Restore AC's
	POP	R2
BALBC4:	RETURN				;And return
	.PAGE
	.SBTTL	DATA

;PURE DATA

	PURE
	.EVEN

;GENERATE TABLE FOR ERROR REPORTING ROUTINE

ERRTBS:	.WORD	LDPKIN#,LDIERC#,64.,^H84	;CHECKSUM ERRORS
	.WORD	LDPKIN#,LDIERB#,1,^H88		;LOOPBACK ERRORS
	.WORD	LDPKIN#,LDIERS#,8.,^H85		;RETRANSMISSIONS RECEIVED
	.WORD	LDPKOT#,LDIERX#,8.,^H86 	;RETRANSMISSIONS SENT
	.WORD	0

;IMPURE DATA

	IMPURE
	.EVEN

PARCNT:	.BYTE	0		;TERMINAL PARAMETER COUNT
HLFCNT:	.BYTE	0		;HALF SECOND COUNTER
LKI256:	.WORD	0		;256 SECOND COUNTER
ZAPCNT::.WORD	0		;BUFFER ZAP TIMER/COUNTER
.IF EQ ..SAT
  LKIMNC::.WORD	0		;Minute counter
.ENDC
	CODE
	.PAGE
	.SBTTL	EMPFRM - Empty a frame - Flow control record

;HERE WITH POSSIBLE FLOW CONTROL RECORD

FLWREC:	CLR	REQCNT			;CLEAR COUNTER
	PUSH	R4			;Respect R4
	PUSH	R0			;PUT COUNT ON THE STACK
	MOV	LDISDB#(R3),R4		;POINT TO LIST OF SDB'S
2$:	CALL	NXTCHR
	ASL	R0			;CONVERT TO WORD OFFSET
	ADD	R4,R0
	MOV	(R0),SD			;GET SDB THAT CORRESPONDS TO THE CHANNELL
	BEQ	10$			;GO ON IF NONE					;  SET!)
	PUSH	R0			;BIT WAS SET-FREE UP AN AC
	MOVB	SDLISP#(SD),R0		;GET LINE SPEED
	MOV	SPDTBL-2(R0),SDACNT#(SD) ;RESET SEND-AHEAD COUNT
	TST	SDPKDH#(SD)		;DOES IT HAVE ANYTHING TO SEND NOW?
	BEQ	9$			;NO
	CMP	#-1,SDLKLK#(SD)		;YES-ALREADY IN THE LIST?
	BNE	9$			;YES-NOTHING MORE NEEDED HERE
	MOV	LDIXLT#(R3),R0		;NO-PUT THIS SDB ON THE SEND LIST
	BEQ	5$
	MOV	SD,SDLKLK#(R0)
	BR	6$

5$:	MOV	SD,LDIXLH#(R3)
6$:	MOV	SD,LDIXLT#(R3)
	CLR	SDLKLK#(SD)
	INC	REQCNT			;INDICATE SOMETHING TO DO FOR THIS LINE
9$:	POP	R0			;RESTORE R0
10$:	DEC	(SP)			;MORE WORDS TO PROCESS?
	BGT	2$			;YES-CONTINUE
	TST	(SP)+			;NO-FIX UP THE STACK
	POP	R4			;RESTORE R4
	TST	REQCNT			;DID WE START UP ANYONE?
	BEQ	20$			;NO
	PUSH	R2			;YES-POKE THE LINE IF ITS IDLE NOW
	CALL	LKIBGN#
	POP	R2
20$:	JMP	LKINXT			;CONTINUE WITH THE FRAME

;LINE SPEED TABLE

	PURE

	.EVEN
SPDTBL:	.WORD	32.		; 0 - 64 CHARACTERS PER SECOND
	.WORD	80.		; 1 - 160 CHARACTERS PER SECOND
	.WORD	256.		; 2 - 512 CHARACTERS PER SECOND
	.WORD	1024.		; 3 - 2048 CHARACTERS PER SECOND

	CODE
	.PAGE
	.SBTTL	INICIR - DATA HANDLER FOR INITIAL CIRCUIT OR CONTROL CIRCUIT


INICIR:	PUSH	R0			;SAVE DATA COUNT ON STACK
	TST	LKIPPK			;Do we have a reserve packet now?
	BNE	6$			;Yes-go on
	CALL	LKINPK			;No-get one now
	MOV	R1,LKIPPK		;Store address of reserve packet
6$:
INICI1:	PUSH	R4			;SAVE A REGISTER
	PUSH	R3			; AND ANOTHER
	CALL	NXTCHR			;GET THE NEXT BYTE
	CMPB	#^H03,R0		;CHECK FOR FIRST PART OF NEEDLE
	BNE	DAUNCH			;SOME OTHER JUNK - DATA ON UNASSIGNED CHANNEL
	CMPB	#^H10,(R2)		;CHECK FOR SECOND PART OF A NEEDLE
	BNE	DAUNCH			;ZAPPER OF SOME SORT
	CALL	NXTCHR			;GET ANOTHER BYTE
	CALL	NXTCHR			;GET THE ZERO STUFFING BYTE
	CALL	NXTCHR			;GET THE COUNT OF BYTES IN THE NEEDLE
	SUB	R0,4(SP)		;CALCULATE CHARACTERS LEFT AFTER NEEDLE
	DEC	R0			;COMPENSATE FOR NULL BYTE SKIPED
;	MOVB	R0,PKCNT(R1)		;GET COUNT AFTER THIS RECORD IS PROCESSED
	SUB	#3,R0			;COMPENSATE FOR CHARACERS WE HAVE SKIPED
ADDDAT:;	MOV	#PKDATA+3,R4		;POINT TO START OF DATA IN PACKET
;	MOV	R4,PKPNT(R1)		;INIT PACKET
;	ADD	R1,R4			;MAKE INTO REAL MEMORY POINTER
	MOV	#SUPBUF+3,R4
10$:	MOVB	(R2)+,R3		;GET THE NEXT DATA BYTE
	BNE	20$			;HANDLE NORMAL DATA
;	DECB	PKCNT(R1)		;COMPENSATE FOR PREFIXED DATA
	DEC	R0			;DECREMENT COUNT
	BMI	SNIPE2			;SHOULDN'T GO TO ZERO YET
	BIT	#77,R2			;ARE WE AT THE END OF THE RECORD
	BNE	15$			;NO
	MOV	-100(R2),R2		;GET NEXT RECORD ADDRESS
	BEQ	SNIPE2
	ADD	#2,R2			;POINT TO FIRST DATA
15$:	MOVB	(R2)+,R3		;GET NEXT DATA BYTE
20$:	MOVB	R3,(R4)+		;MOVE THE DATA BYTE
	BIT	#77,R2			;ARE WE AT THE END OF THE RECORD
	BNE	28$			;NO
	MOV	-100(R2),R2		;GET NEXT RECORD ADDRESS ONTO STACK
	BEQ	SNIPE2
	ADD	#2,R2			;POINT TO FIRST DATA
28$:	SOB	R0,10$			;CONTINUE UNTIL END
	POP	R3
	POP	R4
	CALL	NEDPNT			;GO HANDLE NEEDLE POINT
	POP	R0			;GET REMAINING BYTE COUNT
	BLE	50$			;NONE LEFT GO ON TO NEXT RECORD
	JMP	LKIDA2			;GO HANDLE DATA
50$:	JMP	LKINXT

DAUNCH:	;FREPKT				;give up packet
	CALL	BRKCIR			;DO TYMNET CLEANUP
	CALL	FRESOC#			;FREE PREASIGNED SOCKET
	POP	R3
	POP	R4
	POP	R1
	DEC	R1			;ACCOUNT FOR DATA READ SO FAR
	BLE	11$
10$:	CALL	NXTCHR			;SCAN THROUGH PACKET LIST
	SOB	R1,10$
11$:	JMP	LKINXT
;SNIP0:	POP	R0
SNIPED:	FREPKT				;GIVE UP PACKET WE HAVE BEEN USING
SNIPE2:	CALL	FRESOC#
	POP	R3
	POP	R4
SNIPE5:	POP	R0
	JMP	BADFRM
	.PAGE
	.SBTTL	CMDCIR - HANDLE DATA RECEIVED OVER COMMAND CIRCUIT

;	THIS CODE EXPECTS A PAIR OF BYTES AS THE MINIMUM FIRST DATA OVER
;	THE COMMAND CIRCUIT.
;	THERE ARE TWO POSSIBILITIES, A ZAPPER OR THE BYTE COUNT OF THE RECORD
;	THE RECORD COUNT APPEARS AS A ESCAPED DATA ITEM AND THEREFORE SHOULD
;	NEVER BE SPLIT.

CMDCIR:	PUSH	R0			;SAVE COUNT OVER CALL
	TST	LKIPPK			;Do we have a reserve packet now?
	BNE	6$			;Yes-go on
	CALL	LKINPK			;No-get one now
	MOV	R1,LKIPPK		;Store address of reserve packet
6$:	MOV	SDLISC#(SD),R1		;GET ADDRESS OF CURRENT PACKET
	BNE	8$			;GO CHECK START OF PACKET
	CALL	LKINPK
	MOV	R1,SDLISC#(SD)		;SAVE ADDRESS OF PACKET
	CLRB	PKCNT(R1)		;CLEAR COUNT
8$:	TSTB	PKCNT(R1)		;IS THIS A OLD PACKET?
	BNE	10$			;YES
	CLRB	PKPNT(R1)		;INITIALIZE DATA POINTER
	CALL	NXTCHR			;GET THE NEXT BYTE
	CMPB	#.CCZAP,R0		;CHECK FOR ZAPPER FIRST
	BNE	9$			;NOT ONE, CHECK FOR ZERO PREFIX
	JMP	ZAPCMD			;HANDLE ZAP OF COMMAND CIRCUIT
9$:	TSTB	R0			;IS THIS REALLY THE ZERO PREFIX
	BNE	SNIPE5			;BAD FRAME OF SOME SORT KILL CIRCUIT
	CALL	NXTCHR			;GET THE MESSAGE BYTE COUNT
	SUB	#2,R0			;DON'T NEED BYTE COUNT FIELD
	MOVB	R0,PKSEQ(R1)		;STORE THE MESSAGE BYTE COUNT IN THE SEQ FIELD
	SUB	#2,(SP)			;ALLOW FOR TWO BYTES WE JUST SKIPPED
	BEQ	60$			;SHORT RECORD
10$:	MOV	(SP),R0			;GET BYTE COUNT BACK
	PUSH	R4			;SAVE A REGISTER
	PUSH	R3			; AND ANOTHER
	CLR	R4
	BISB	PKCNT(R1),R4		;GET CURRENT PACKET COUNT
	CLR	R3
	BISB	PKSEQ(R1),R3		;GET DESIRED COUNT
	SUB	R4,R3			;GET COUNT NEEDED TO COMPLETE THIS RCORD
	SUB	R3,R0			;FORM COUNT OF BYTES LEFT IN T-II RECORD
	BGE	15$			;WILL THERE BE ENOUGH BYTES IN THIS LRECL
	MOV	4(SP),R3		;NO - COPY ONLY AS MANY BYTES AS THERE ARE
15$:	MOV	R0,4(SP)		;SAVE FOR HANDLING NEXT RECORD
	ADD	R3,R4			;UPDATE COUNT
	MOVB	R4,PKCNT(R1)
	CLR	R4			;PREPARE TO READ FULL 8 BITS
	BISB	PKPNT(R1),R4		;ISOLATE NEXT BYTE POINTER
	MOV	R4,R0			; AND COPY
	ADD	R3,R0			; FORM PKPNT IN CASE RECORD NOT COMPLETE
	MOVB	R0,PKPNT(R1)
	MOV	R1,R0			;GET ADDRESS OF FIRST PACKET TO TEMP
16$:	SUB	#PKCMAX,R4		;DO COUNT OVERFLOW THIS PACKET
	BLT	18$			;YES, FOUND LAST PACKET
	MOV	(R0),R0			;CALCULATE NEXT PACKET ADDRESS
	BR	16$			;SEE IF LAST PACKET IN STRING
18$:	ADD	#PKCMAX+PKDATA,R4	;ADD OFFSET INTO PACKET
	ADD	R0,R4			;FORM POINTER TO NEXT DATA BYTE
20$:	CALL	NXTCHR			;GET THE NEXT BYTE
	TSTB	R0			;CHECK THE BYTE
	BEQ	22$			;GO HANDLE ESCAPED DATA
	CMPB	#.CCZAP,R0		;CHECK FOR ZAPPER FIRST
	BEQ	ZAPCM0			;HANDLE ZAP OF COMMAND CIRCUIT
	MOVB	R0,(R4)+		;COPY DATA BYTE
	BR	30$			;CONTINUE
22$:	MOVB	(R2)+,(R4)+		;GET THE NEXT DATA BYTE
	DEC	R3			;COUNT DOWN
	BLE	SNIPED			;NO BYTES LEFT ?
	DECB	PKCNT(R1)		;WE AREN'T GOING TO HAVE THAT MANY BYTES WHEN DONE
	DECB	PKSEQ(R1)		;WE WONT NEED THAT MANY BYTES FOR A RECORD
	DECB	PKPNT(R1)		;PNT WON'T POINT THAT FAR WHEN FINISHED
25$:	BIT	#77,R2			;ARE WE AT THE END OF THE RECORD
	BNE	30$			;NO
	MOV	-100(R2),R2		;GET NEXT RECORD ADDRESS ONTO STACK
	BEQ	SNIPED
	ADD	#2,R2			;POINT TO FIRST DATA
30$:	BIT	#77,R4			;OVERFLOW THE RECORD?
	BNE	40$			;NO, CONTINUE
	PUSH	R1			;YES, SAVE POINTER TO CURRENT PACKET
32$:	MAKPKT	.PLZAP			;MAKE A PACKET
	BCC	 36$			;GOT ONE
	 CALL	 ZAPBUF#		;DIDN'T GET ONE, HUNT ONE DOWN AND KILL IT
	  BR	  34$
	 BR	 32$			;TRY AGAIN
34$:	RSTOP	NPA			;OUT OF PACKETS
36$:	MOV	R1,-100(R4)		;LINK IN NEW PACKET
	MOV	R1,R4			;POINT TO NEW DATA AREA
	POP	R1
	ADD	#PKDATA,R4		;PUT DATA IN PACKET AT DATA AREA
40$:	SOB	R3,20$			;CONTINUE UNTIL END
	POP	R3			;GET BACK IMPORTANT REGISTERS
	POP	R4
	CMPB	PKCNT(R1),PKSEQ(R1)	;DO WE HAVE A COMPLETE RECORD YET?
	BLO	60$			;NO - WAIT FOR REST OF IT
	PUSH	R2			;SAVE IMPORTANT REGISTERS
	PUSH	SD			;SD WILL BE USED FOR MESSAGES TO PORTS
	CALL	SPRREC			;YES - PROCESS RECORD
	POP	SD
	POP	R2			;GET BACK TEAR DOWN-POINTER
	MOV	SDLISC#(SD),R0		;GET HEAD OF PACKET CHAIN
	BEQ	60$			;COULD BE ZERO IF BAD SUP MESSAGE AND LINE CLEARED
	MOV	(R0),R1			;GET LINK FIELD OF PACKET
	BEQ	55$			;NOTHING THERE
45$:	PUSH	(R1)			;SAVE LINKED ADDRESS
	FREPKT				;RETURN THIS LINKED PACKET
	POP	R1			;GET BACK LINKED ADDRESS
	BNE	45$			;CONTINUE FREEING IF MORE
	CLR	(R0)			;DO GOOD CLEANUP OF PACKET
55$:	MOV	R0,R1			;GET SAVED PACKET ADDRESS
	CLRB	PKCNT(R1)		;SAY NO DATA LEFT IN PACKET
	POP	R0			;RESTORE CHARS LEFT IN LOGICAL RECORD
	BGT	CMDCI9			;PROCESS REST OF LOGICAL RECORD
	FREPKT
	CLR	SDLISC#(SD)		;CLEAR PACKET POINTER
	JMP	LKINXT
60$:	POP	R0
	BGT	CMDCI9			;GOT HERE WITH ANOTHER SUP COMMAND IN LOGICAL RECORD
	JMP	LKINXT			;GO HANDLE REST OF FRAME
CMDCI9:	JMP	CMDCIR

ZAPCMD:	BR	ZAPCM1
ZAPCM0:	ADD	R3,4(SP)		;ADD CHARS REMAINING IN THIS SEGMENT TO
					;CHARACTERS REMAINING IN RECORD
	POP	R3
	POP	R4
ZAPCM1:	SUB	#2,(SP)			;COUNT DOWN
	BGE	10$			;TWO CHARS LEFT?
	JMP	SNIPE5			;NO BAD FRAME
10$:	CALL	NXTCHR			;GET THE NEXT BYTE
	CMPB	#.ZCFIX,R0		;IS THIS A REBUILD MESSAGE
	BLOS	200$			;YES
	CLRB	PKCNT(R1)		;GET RID OF ANY SAVED DATA
	CMPB	#.ZCFGB,R0		;IS THIS A FAT GOBBLER
	BEQ	200$			;YES
	CMPB	#.ZCGOB,R0		;IS THIS A GOBBLER?
	BEQ	100$			;YES
	CMPB	#.ZCFZP,R0		;IS THIS A FAT ZAPPER
	BNE	20$			;NO
	SUB	#4,(SP)			;ENOUGH DATA?
	BGE	15$			;YES
	JMP	SNIPE5			;NO- SNIP CIRCUIT
15$:	MOV	#4,R1			;START COUNTER
16$:	CALL	NXTCHR			;CLEAN UP THE FAT
	SOB	R1,16$
20$:	CALL	CLRCIR			;CLEAN UP LINK TO SDB
	CALL	FRESOC#			;MAKE THIS SOCKET AVAILABLE
	CMP	SD,DDSUSD#(R4)		;IS THIS THE REAL COMMAND CIRCUIT
	BNE	100$			;NO
	CLR	DDLIUP#(R4)		;YES - DECLARE SUP GONE
	CLRB	DDLISN#(R4)		;CLEAR SUP NUMBER
	PUSH	R2			;SAVE POINTER
	CALL	CLRSUP
	POP	R2
100$:	POP	R0			;RESTORE CHARACTER COUNT
;	BLE	110$			;HANDLE END OF RECORD
;	JMP	CMDCIR			;GO HANDLE REST OF LOGICAL RECORD
	BGT	CMDCI9			;GO HANDLE REST OF LOGICAL RECORD
110$:	JMP	LKINXT
200$:	SUB	#4,(SP)			;ACCOUNT FOR ALL FAT MESSAGES HERE
	BLT	210$			;NOT ENOUGH DATA SNIP LINE
	MOV	#4,R1			;HANDLE NORMAL CASE
205$:	CALL	NXTCHR			;ADVANCE POINTER OVER "FAT"
	SOB	R1,205$
	BR	100$
210$:	JMP	SNIPE5			;NOT ENOUGH DATA SNIPE LINE
	.PAGE
	.SBTTL	NEDPNT - HANDLE NEEDLE POINT WHEN IT ARRIVES

;	FORMAT  03,10,00,CNT,00,LINK COUNT+80, 32 BITS OF INVOICE, FLAGS + 8080
;			REQUESTING NODE, PORT, LIST OF NODES IN CIRCUIT, HOST+8000,
;			TID, USERNAME

NEDPNT:;	MOV	PKDATA+10(R1),R0	;GET FLAGS FROM NEEDLE POINT
	MOV	SUPBUF+10,R0		;GET FLAGS FROM NEEDLE POINT
	SWAB	R0
	BIC	#^H8080,R0		;CLEAR JUNK
	MOV	R0,SDLIS2#(SD)		;SET UP FLAGS
	ASHI	-3,R0			;GET SPEED BITS
	BIC	#^C6,R0			;CLEAR JUNK
	ADD	#2,R0			;ADD 2 SO NUMBER WILL RELATE TO PACKET COUNTS
	MOVB	R0,SDLISP#(SD)		;CHUCK AWAY
	MOV	SPDTBL-2(R0),SDACNT#(SD) ;SETUP SEND AHEAD COUNT
	TBBE	$I2COM,SDLIS2#(SD),1$	;IS THIS A COMMAND CIRCUIT?
	MOV	KERHST#,R0		;YES, PROCESS IT
	SWAB	R0			;GET BYTES IN CORRECT ORDER
	BIC	#100000,R0
	MOV	R0,SDLIHC#(SD)		;SAVE KERNEL HOST AS CONNECTED HOST
;	FREPKT				;FREE UP THE NEEDLE POINT PACKET
	RETURN

;HANDLE ORDINARY INCOMING CIRCUIT

1$:	PUSH	R2
	PUSH	R1
	MOV	#$I1INC!$I1PRJ,SDLIS1#(SD);INITIALIZE THE STATUS BITS
;	MOV	R1,R2			;COPY PACKET POINTER

.IF EQ	..SAT
;	ADD	#PKDATA+4,R2
	MOV	#SUPBUF+4,R2
	MOV	(R2)+,R0		;GET INVERTED HIGH BYTE OF INVOICE
	SWAB	R0			;PUT IN 11 ORDER
	MOV	R0,SDLIVH#(SD)		;STORE HIGH BYTE OF INVOICE NUMBER
	MOV	(R2)+,R0		;GET LOW BYTES OF INVOICE NUMBER
	SWAB	R0
	MOV	R0,SDLIVL#(SD)		;STORE LOW BYTES OF INVOICE
	CLR	SDLIO2#(SD)		;Clear output character count
	CLR	SDLIO1#(SD)
	CLR	SDLII2#(SD)		;CLEAR INPUT CHARACTER COUNT
	CLR	SDLII1#(SD)
	CLR	SDLIPC#(SD)		;CLEAR PROJECT CODE BUFFER
.IFF
;	ADD	#PKDATA+10,R2		;SKIP OVER INVOICE NUMBER IN A SAT
	MOV	#SUPBUF+10,R2		;SKIP OVER INVOICE NUMBER IN A SAT
.ENDC

	CALL	LKIRPK			;GET THE RESERVE PACKET

	PUSH	R3			;FREE UP A REGISTER
	MOV	R1,R3			;CLEAR THE PACKET
	MOV	#37,R0
3$:	CLR	(R3)+
	SOB	R0,3$
	MOV	#.PTCON*400+37,PKCNT(R1);SET PACKET TYPE AND BYTE COUNT
	TST	(R2)+			;SKIP OVER FLAGS
	MOV	(R2)+,R0		;GET THE NODE NUMBER
	SWAB	R0			;SWITCH BYTES TO OUR FORMAT
	ASHI	4,R0			;POSITION IT IN LEFT 12 BITS
	PUSH	R4			;FREE UP A REGISTER
	MOV	R1,R4
	ADD	#PKDATA+16,R4		;POINT TO START OF SRC NAME
	MOV	#4,R3			;SET COUNTER
	CALL	PUTNUM			;PUT NODE NUMBER INTO THE PACKET
	MOV	(SP),R4			;GET BACK R4
	INC	R2			;SKIP OVER HIGH ORDER BITS OF PORT
	MOVB	(R2)+,PKDATA+15(R1)	;STORE THE SRC SOCKET NUMBER

6$:	CMP	(R2)+,#-1		;SEARCH FOR THE HOST NAME
	BEQ	6$
	PUSH	R2			;PRESERVE R2
	MOV	-2(R2),R0		;GET HOST NUMBER
	CMP	KERHST#,R0		;IS THIS THE KERNEL HOST

.IF EQ	..SAT
	BEQ	12$			;YES
	PUSH	R1			;SAVE REGISTERS WE WILL USE
	SWAB	R0			;PUT IN OUR ORDER
	BIC	#100000,R0		;CLEAR ESCAPE BIT
	MOV	DDLINH#(R4),R1		;GET THE COUNT OF HOSTS
	MOV	R4,R3			;COPY DDB POINTER
8$:	CMP	DDLIHD#(R4),R0		;IS THIS THE CORRECT HOST
	BEQ	10$			;YES
	ADD	#4,R4			;MOVE ON TO THE NEXT HOST
	SOB	R1,8$
	POP	R1
	JMP	200$			;GO SEND ZAPPER		
10$:	MOV	R0,SDLIHC#(SD)		;SAVE NUMBER OF CONNECTED HOST
	POP	R1
	MOVB	DDLIHD#+2(R4),PKDATA+4(R1) ;STORE POSSIBLE DEVICE CODE
	ADD	#DDLIDH#,R4
	ADD	#PKDATA+6,R1		;PLACE TO PUT THE DST
	CALL	RD50XX#			;PUT DST INTO THE CONNECT PACKET
	CALL	RD50XX#
	BIC	#77,R1			;POINT BACK TO BEGINING OF PACKET
	BR	14$
.IFF
	BNE	200$			;HANDLE NON-KERNEL IN SAT MODE
.ENDC

12$:	SWAB	R0
	BIC	#100000,R0
	MOV	R0,SDLIHC#(SD)		;SAVE AS HOST NUMBER
	MOVB	#.IDST#,PKDATA+4(R1)	;STORE DEVICE CODE FOR STATUS DEVICE
14$:	POP	R2
	BISB	#060,PKDATA+35(R1)	;STORE FLAG BITS (INDICATE THAT THE
					;  LOGIN STRING IS AVAILABLE AND THAT
					;  THE PASSWORD HAS BEEN CHECKED)
	MOV	#<13*400+200>,PKDATA(R1);STORE CONNECT HEADER
	MOVB	#377,PKDATA+24(R1)	;STORE PRIV. LEVEL
	MOVB	#4,PKDATA+31(R1)	;STORE PACKET COUNT MAX
	MOVB	(R2)+,R0		;GET TYMNET TERMINAL TYPE
	BIT	#40,R0			;CHECK FOR HALF DUPLEX
	BEQ	16$			;NOT HALF DUPLEX
	MOVB	#2,PKDATA+35(R1)	;SET HALF DUPLEX BIT
16$:
.IF EQ	..SAT
	BIC	#^C37,R0		;ONLY 5 BITS
	CMP	R0,#MAXTYT		;VALID TYPE?
	BLO	20$			;YES
	MOV	#12.,R0			;NO - PICK A SAFE TYPE
20$:	TST	R0			;REALLY A TERMINAL?
	BEQ	22$			;NO
	MOVB	#.IDTR#,PKDATA+14(R1)	;YES
22$:	MOVB	TYNTYR(R0),PKDATA+34(R1);STORE TERMINAL BAUD RATE
.IF EQ ..TPC
	MOVB	TYNTYT(R0),PKDATA+33(R1);STORE TERMINAL TYPE
.IFF
	MOVB	TYNTYT(R0),R0		;Get terminal type
	MOVB	R0,PKDATA+33(R1)	;Store it in the connect packet
	ASL	R0			;Get terminal type bits in case we need
	MOV	TTPBTS#(R0),SDLIT4#(SD)	;  them later!
	MOVB	TTPWID#(R0),SDLILW#(SD)	;Get line width too
	CLR	SDLIT1#(SD)		;Clear all these flags
.ENDC
.ENDC

;	Handle username here by saving in a data packet which will be
;	sent after the connect ACK has been received

	PUSH	R1			;SAVE ADDRESS OF CONNECT PACKET
	ADD	#3,R2			;SKIP OVER REST OF FLAGS AND REQUESTING HOST
26$:	TSTB	(R2)+			;FIND FIRST CHAR WITH OUT PARITY
	BMI	26$			;NOT YET
	DEC	R2			;POINT TO FIRST CHAR OF USER NAME
	MOV	SDLISC#(SD),R1		;GET ADDRESS OF CURRENT PACKET
	BNE	28$			;GO CHECK START OF PACKET
	CALL	LKINPK
28$:
;	MOV	R2,R1			;COPY NEEDLE POINT PACKET
;	BIC	#77,R1			;USE NEEDLE POINT PACKET AS FIRST DATA PACKET
	CLR	PKCNT(R1)		;CLEAR TYPE AND COUNT
	MOV	R1,SDLISC#(SD)		;MAKE THIS THE SAVED DATA PACKET
	MOV	R1,R0			;RELOCATE TO PACKET
	ADD	#PKDATA,R0
30$:
.IF EQ	..SAT
	CMPB	#':,(R2)		;IS THIS THE START OF A PORT SPECIFICATION
	BNE	34$			;NO
	PUSH	R2			;SAVE STARTING POINT OF PORT SPECIFICATION
31$:	MOVB	(R2)+,(R0)		;YES - SCAN FOR TERMINATOR
	BMI	31$			;NOT IT
	POP	R2
	INC	R2			;SKIP OVER COLON
	CMPB	#'.,(R2)+		;CHECK FOR TRUE PORT SPECIFICATION
	BNE	36$			;MUST BE TRANSPARENT LOGIN
	CLR	R0			;CLEAR ACCUMULATOR
32$:	TSTB	(R2)			;CHECK FOR END OF NUMBER
	BMI	33$			;END OF STRING
	ASHI	3,R0			;MULTIPLY BY 8
	MOVB	(R2)+,R4		;GET NEXT NUMBER 
	SUB	#'0,R4			;CONVERT FROM ASCII
	ADD	R4,R0			;ADD IN NEXT NUMBER
	BR	32$			;CONTINUE
33$:	MOV	(SP),R4			;GET BACK CONNECT PACKET POINTER
	MOVB	R0,PKDATA+5(R4)		;DEPOSIT AS DEST SOCKET NUMBER
	BR	36$
.ENDC

34$:	INCB	PKCNT(R1)		;BUMP COUNT
	MOVB	(R2)+,(R0)+		;STORE NEXT CHARACTER
;	BMI	36$			;WAS IT THE LAST OF THE STRING
	BPL	30$			;CONTINUE IF NOT END
36$:	POP	R1			;GET CONNECT PACKET ADDRESS
	INCB	SDPCNT#(SD)		;AND SEND IT
	CALL	SNDPKT#
.IF EQ	..SAT
	CALL	RPTCN2			;PUT IN TIMER REQUEST
.ENDC

;HERE FOR A HANG CHARACTER

99$:	POP	R4
	POP	R3
	POP	R1
	POP	R2
	RETURN

;HANDLE NEEDLE ERRORS

200$:;	FREPKT				;FREE UP CONNECT PACKET
;	POP	R1			;POP NEEDLE POINTER
	POP	R2			;POP NEEDLE POINTER
;	BIC	#77,R1
	CALL	BADNED
	BR	99$

;HERE WHEN TIMER REQUEST FOR ACCOUNTING RUNS OUT
.IF EQ	..SAT
RPTCNT:	MOV	#JIFM10#,R0		;PUT IN A NEW TIMER REQUEST
	MOV	#RPTCN1,R1		;FOR 10 MINUTES FROM NOW
	CJMP	TIMREQ#			;THATS ALL
RPTCN1:	MOV	SDDDB#(SD),R4		;GET ADDRESS OF DDB
	MOV	#.S7OCC*10000,R0	;GET REASON
	CALL	ACOUNT			;TELL THE SUPERVISOR
RPTCN2:	MOV	#JIFM10#,R0		;PUT IN A NEW TIMER REQUEST
	MOV	#RPTCNT,R1		;FOR 10 MINUTES FROM NOW
	CJMP	TIMREQ#			;THATS ALL
.ENDC

BADNED:	MOV	#.ERHSD,R0		;SET HOST DOWN AS REASON
	CALL	SETKIL#			;BUILD A FILL PACKET
	PUSH	R3			;SAVE THIS IMPORTANT REGISTER
	CALL	SNDSRC#			;SEND IT TO OURSELVES
	POP	R3
	RETURN
	.PAGE
	.SBTTL	EMPFRM - EMPTY A FRAME - SUPERVISOR RECORD

;HERE WITH SUPERVISOR RECORD

SPRREC:	MOV	R1,R2			;Prepare to decompress command packet
	ADD	#PKDATA,R2		;Point to first data byte
	BIS	#200,(R2)		;SOME MESSAGES COME WITHOUT THIS
	CMP	SUPNOD,(R2)+		;Is the node number correct?
	BNE	100$			;NO-Sombody is confused
	MOVB	(R2)+,R0		;GET MESSAGE TYPE
	CMP	#^H12,R0		;Is the message in range
	BLOS	200$			;No, report bad sup record
	SUB	#^H8,R0			;Form message index
	BMI	200$			;Skip out if bad sup record
	ASL	R0			;AS WORD INDEX
	CJMP	@SPRDSP(R0)		;DISPATCH ON THE MESSAGE TYPE
100$:	PUSH	R0			;PUT DUMMY ON STACK FOR BADFRM
	JMP	BADFRM
200$:	JMP	BADSPR
;DISPATCH TABLE FOR SUPERVISOR MESSAGE TYPES

	PURE
	.EVEN

SPRDSP:	.WORD	TAKOVR		;.SMTKO = 8 - TAKE OVER
	.WORD	NEEDLE		;.SMNED = 9 - NEEDLE
	.WORD	IGNSPR		;.SMUPD = A - UPDATE
	.WORD	TRACEC		;.SMTRA = B - TRACE CIRCUIT
	.WORD	BADSPR		;.SMSPS = C - SEND PILL TO SUP
	.WORD	LGICRS		;.SMLCR = D - TALK TO TERMINAL
	.WORD	AUXRES		;.SMLGI = E - AUX CIRCUIT LOGIN STATUS
	.WORD	GENMSG		;.SMGEN = F - GENERAL MESSAGE
	.WORD	PSTATR		;	= 10 - PORT STATUS REQUEST
	.WORD	BADSPR		;	= 11 - ASSIGN CHANNEL TO TYMNET 1


	CODE
	.PAGE
;HERE FOR SUPERVISOR MESSAGE .SMTKO = 0 - TAKE OVER OR UNTAKER

;	TAKE OVER FORMAT
;	8, Supern+80

TAKOVR:	MOVB	(R2)+,R0		;GET SUPERVISOR NUMBER
	CMPB	R0,DDLISN#(R4)		;OLD SUP?
	BEQ	10$			;YES - SKIP ALL THIS STUFF
	MOVB	R0,DDLISN#(R4)		;NO - STORE SUPERVISOR NUMBER
	PUSH	R3			;SAVE LDB ADDRESS FOR THIS LINE
	PUSH	R2			;SAVE R2
	PUSH	SD			;SR2
	PUSH	R0			;Save supervisor number
	CALL	CLRSUP			;CLEAR ALL SUPERVISOR DIALOGS
	MOV	(SP),R0			;GET COPY OF SUP NUMBER
	SWAB	R0			;Put sup number in correct half
	BIS	#^H0A,R0		;Set message type
	MOV	R0,SUPMSG
	MOV	#2,R0			;Set up count
	CALL	SNDSPR			;Send message to current supervisor
	POP	R0
	POP	SD
	POP	R2			;RESTORE R2
	POP	R3			;RESTORE ADDRESS OF OUR LDB
10$:	MOV	R3,DDLIUP#(R4)		;SET UPSTREAM SWITCH TO NEW SUPERVISOR
	MOV	SD,DDSUSD#(R4)		;SAVE SUPERVISOR SDB
	MOVB	SDLICN#(SD),DDLISC#(R4)	;SAVE SUPERVISOR CHANNEL NUMBER
	MOV	#SUPMSG,R2		;POINT TO SUP RESPONSE ARRAY
	MOVB	#.SMTKR,(R2)+
	MOVB	R0,(R2)+
	MOV	VERLOC#,(R2)
	SWAB	(R2)+			;Version #
	MOV	SAVEEC#,(R2)
	SWAB	(R2)+			;Crash code
	MOV	#^H8080,R0		;PREPARE FOR NEXT TEST
	MOV	R0,(R2)			;ZERO CRASHES AN ZERO LINKS
	ADD	CRSCNT#,(R2)+		;ADD IN CRASH COUNT
	TSTB	KERHST#			;DO WE HAVE A KERNEL HOST
	BEQ	14$
	INC	R0			;INDICATE ONE HOST
14$:
.IF EQ ..SAT
	ADD	DDLINH#(R4),R0		;ADD IN ALL THE HOSTS
.ENDC
	MOV	R0,(R2)+		;Set in host count
	CLR	(R2)+			;Set zero passthroughs
	PUSH	R3			;Save sup LDB
	MOV	DDLILD#(R4),R3		;Get the first LDB of the device
	PUSH	R3			;Save for second round
20$:	TBBN	$L1DWN,LDIST1#(R3),24$	;Is the line up?
	MOV	LDINBR#(R3),R0		;Yes
	BIS	#^H8000,R0
	SWAB	R0			;put bytes in sup order
	MOV	R0,(R2)+		;Store neighbor number
	INCB	SUPMSG+7		;add to count of links
24$:	MOV	LDINXT#(R3),R3		;Get the next LDB
	BNE	20$			;Continue if more
	POP	R3			;Get back first LDB address
30$:	TBBN	$L1DWN,LDIST1#(R3),36$	;Is the line up?
	MOVB	LDISPD#(R3),R0		;Yes - get speed junk
	BIS	#^H80,R0		;Put in escape bit
;	CMPB	#8.,LDIPMX#(R3)		;WS8 (OR MORE)
;	BGT	34$			;NO
;	BIS	#^H40,R0		;YES
34$:	MOVB	R0,(R2)+		;Store speed byte
36$:	MOV	LDINXT#(R3),R3		;Get the next LDB
	BNE	30$			;Continue if more
	POP	R3			;Get back sup LDB address
	MOVB	KERHST#,R0		;Get first byte of kernel host
	BEQ	40$			;None - all done here
	MOVB	R0,(R2)+		;Put in first byte
	MOVB	KERHST#+1,(R2)+		; and second byte

.IF EQ ..SAT
40$:	MOV	DDLINH#(R4),R0		;Get counter of hosts
	BEQ	50$			;Skip this stuff for zero hosts	
	MOV	#DDLIHD#,R1		;Point to list of hosts
	ADD	R4,R1			;Make real pointer
44$:	MOVB	(R1)+,1(R2)		;Put lower byte into message
	MOVB	(R1)+,(R2)		;Put upper byte into message
	BISB	#^H80,(R2)+		;Turn on sign bit
	INC	R2			;Skip over lower byte
	TST	(R1)+			;Skip over host port junk
	SOB	R0,44$			;Go on to next one
50$:	PUSH	DDLINH#(R4)		;Get count of hosts
	MOV	#3,R0			;SET COUNT OF HOSTS TO PROCESS THIS LOP
	CLRB	(R2)			;SET ALL HOSTES ANSWERED
	MOV	#40,SD			;PUT SHUT/DOWN BIT IN SD
	MOV	R4,R1			;COPY DDB POINTER
60$:	TSTB	DDLIHD#+2(R1)		;IS THIS A DEVICE ON A NODE?
	BNE	64$			;YES, THEY ARE ALWAYS UP
	TST	DDLISS#(R1)		;IS THE HOST UP?
	BEQ	70$			;NO
	TST	DDLIHD#+2(R1)		;ANSWERED OR SHUT
	BMI	64$			;ANSWERED
	BISB	SD,(R2)			;SET THE SHUT BIT IN THE RESPONSE BYTE
64$:	ASR	SD			;SHIFT OVER TO NEXT POSITION
	BR	72$
70$:	ASR	SD			;SHIFT TO DOWN POSITION
	BISB	SD,(R2)			;SET THE DOWN BIT
72$:	DEC	(SP)			;COUNT DOWN HOSTS LEFT
	BLE	80$			;ALL DONE
	ASR	SD
	ADD	#4,R1			;ADVANCE TO NEXT HOST
	SOB	R0,60$			;CONTINUE FOR REST OF THIS BYTE
	MOV	#4,R0			;DO 4 MORE HOSTS
	INC	R2			;POINT TO NEXT STATUS BYTE
	CLR	(R2)			;CLEAR IT
	MOV	#200,SD			;START MASK BIT OVER
	BR	60$
80$:	TST	(SP)+			;CLEAR STACK
	MOVB	#2.,LKIMNC		;TRY TO MAKE SUPERVISORY CONNECTIONS
					;  IN 2 SECONDS
.IFF
	MOVB	#^H15,(R2)		;Declare kernel answered the rest shut
	BR	90$
40$:	DEC	R2			;No byte for kernel
.ENDC
90$:	MOV	R2,R0
	SUB	#SUPMSG-1,R0		;CALCULATE LENGTH OF MESSAGE
;+--KS701 TO ADD PRODUCT ID
	CALL	SNDSPR			;SEND TO NEW SUPERVISOR
	MOV	KERHST#,R0		;DO WE HAVE KERNAL HOST?
	BNE	92$			;NE, WE HAVE,  REPORT HOST STATUS
	RETURN				;ELSE, FORGET IT
92$:	MOV	#SUPMSG,R2		;
	MOV	#.SMHOS+^H6000,(R2)+	;HOST STATUS REPORT
	MOV	R0,(R2)+
	MOV	#^H3680,(R2)
	TST	#ROMFLG#		;ROM BASED
	BEQ	94$			;NO, LEAVE AS MICRO SAT
	MOV	#^H7D80,(R2)
94$:	MOV	#6,R0			;LENGTH
;---KS701
	CJMP	SNDSPR			;SEND TO NEW SUPERVISOR

;	CLEAR ALL SUPERVISORY CONNECTIONS

CLRSUP:	PUSH	R3			;SAVE CURRENT LDB
	MOV	DDLILD#(R4),R3		;SCAN ALL LDB'S
4$:	CALL	CLRSPR			;AND CLEAR THEIR SUPERVISOR OUTPUT LISTS
	MOVB	#<TIME.D*3>,LDIATD#(R3)	;START TIMER TO SEND LINE DOWN MESSAGE
6$:	MOV	LDINXT#(R3),R3		;STEP TO NEXT
	BNE	4$
	POP	R3			;GET BACK LDB
;	CJMP	CLRNEW			;DISCONNECT ALL SDB'S WHICH ARE WAITING
					;  FOR THE SUPERVISOR

;SUBROUTINE TO DISCONNECT ALL SOCKETS WAITING FOR SUPERVISOR RESPONSE
;	C(R4) = ADDRESS OF DDB
;	CALL	CLRNEW

CLRNEW:	MOV	DDSX#(R4),R0		;POINT TO SX TABLE
	CLR	R2			;GET NUMBER OF SOCKETS
	BISB	DDSOC#(R4),R2
2$:	MOV	(R0)+,SD		;GET NEXT SDB
	TSTB	SDSTS1#(SD)		;CONNECTED?
	BEQ	10$			;NO
	TST	SDLILD#(SD)		;YES-DOES IT HAVE A CHANNEL?
	BNE	10$			;YES
.IF EQ ..SAT
	TBBN	$I1SPR,SDLIS1#(SD),10$	;IS THIS A SUPERVISORY SDB?
.ENDC
	PUSH	R0
	PUSH	R2
.IF EQ	..SAT
	TBBE	$I1AUX,SDLIS1#(SD),5$	;IS THIS AN AUX CIRCUIT
	PUSH	R1			;YES
	MOV	#LKIATO,R1		;KILL TIMER
	CALL	TIMKIL#
	POP	R1			;RESTORE REGISTERS
.ENDC
5$:	CLR	SDLIS1#(SD)
	MOV	#.S7OCU*10000!.ERSPR,R0	;REASON = SUPERVISOR ERROR
	CALL	KILSUB			;Kill the connection
	POP	R2			;RESTORE R2
	POP	R0			;RESTORE R0
10$:	SOB	R2,2$			;CONTINUE IF MORE TO DO
	RETURN				;RETURN WHEN FINISHED
	.PAGE
; NEEDLE RECEIVED
;	FORMAT:
;		9,LINK COUNT+80,INVOICE #, FLAGS, REQUESTING NODE AND PORT,
;			NODE,...,NODE,DESTINATION,FLAGS & TID,
;			REQUESTING HOST,CONTROL CHAR, USER NAME

NEEDLE:	CLRB	-(R2)			;CLEAR 09
	MOV	12(R2),SD		;GET PORT NUMBER
	SWAB	SD			;COMPENSATE FOR DIFFERENT WORD ORDER
	ASL	SD
	ADD	DDSX#(R4),SD		;FIND SDB
	MOV	-(SD),SD

2$:	CMPB	#.SSCON,SDSTS1#(SD)	;IS THIS SDB CONNECTED?
	BNE	100$			;NO - SOME KIND OF ERROR
	MOVB	1(R2),R0		;GET LINK COUNT OF NEW CKT	+-KS
	BIC	#^HFF80,R0		;ONLY 7 BITS
	MOVB	R0,SDLINL#(SD)		;SAVE IT FOR XRAY	--KS
	MOV	6(R2),R0		;GET FLAGS FROM NEEDLE
	SWAB	R0
;	TBBN	$I2COM,R0,100$		;WE ARE NOT A SUP BASE
	BIC	#^H8080,R0		;CLEAR JUNK
	MOV	R0,SDLIS2#(SD)		;SAVE THE FLAGS
	ASHI	-3,R0			;GET SPEED BITS
	BIC	#^C6,R0			;CLEAR JUNK
	ADD	#2,R0			;ADD 2 SO NUMBER WILL CORRELATE WITH PACKET COUNTS
	MOVB	R0,SDLISP#(SD)		;CHUCK AWAY
	MOV	SPDTBL-2(R0),SDACNT#(SD) ;SETUP SEND AHEAD COUNT
	MOV	14(R2),R0		;GET NEXT NODE IN LIST
	SWAB	R0			;PUT IN 11 ORDER
	MOV	R0,R1			;COPY (AND CHECK 8000 BIT)
	BMI	300$			;GO HANDLE HOST ON THIS NODE
	BIS	#^H8000,R1		;TURN ON XLINK BIT
	PUSH	R3			;SAVE R3 OVER THIS LOOP
	MOV	#LIALDB#,R3		;GET FIRST LSB
10$:	CMP	R0,LDINBR#(R3)		;IS THIS OUR NEIGHBOR
	BEQ	20$			;YES
	CMP	R1,LDINBR#(R3)		;IS THIS OUR XLINK NEIGHBOR
	BEQ	20$			;YES
	MOV	LDINXS#(R3),R3		;POINT TO NEXT LDB
	BNE	10$			;CHECK NEXT NEIGHBOR
	BR	200$			;NONE LEFT - HANDLE OWNER OF BAD NEEDLE
20$:	MOV	#-1,14(R2)		;CLEAR OUT NUMBER FROM THE LIST
	MOV	LDISDB#(R3),R0		;GET POINTER TO SDB BLOCK
	ADD	#4,R0			;SKIP OVER CHANNELS 0 AND 1
	MOV	#2,R1			;R1 HAS CHANNEL NUMBER
40$:	TST	(R0)+			;IS THIS CHANNEL UNUSED?
	BEQ	50$			;YES, ALLOCATE IT 
	INC	R1			;INCREMENT THE CHANNEL NUMBER
	CMPB	R1,LDICHN#(R3)		;HAVE WE RUN OUT YET
	BLO	40$			;NO
	BR	200$			;JUST DROP IT
50$:	MOV	SD,-(R0)		;POINT CHANNEL AT THE SDB
	MOVB	R1,SDLICN#(SD)		;SAVE CHANNEL NUMBER FOR OTHER DIRECTION
	MOV	R3,SDLILD#(SD)		;SAVE LDB ADDRESS FOR OTHER DIRECTION
	MOVB	PKCNT-PKDATA-2(R2),R0	;GET BYTE COUNT
	SUB	#4,R0			;PKCNT INCLUDES DEST NODE AND 09
	CALL	SNDNED			;SEND THE NEEDLE OUT
	 BR	 200$			 ;ERROR RETURN
	CALL	LKIRPK			;GET THE RESERVE PACKET
	MOV	#.PTFUN*400+1,PKCNT(R1)	;SET UP PACKET TYPE AND COUNT
	MOVB	#.FNCLI,PKDATA(R1)	;FUNCTION = CLEAR LOGIN MODE
	CALL	LKISPK			;SEND THE PACKET
	POP	R3
100$:	RETURN

200$:	POP	R3
300$:	CALL	LKIRPK			;GET THE RESERVE PACKET
	MOV	#.ERREQ,R0
	CALL	SETDIS#			;SET UP DISCONNECT
	CJMP	LKISPK			;SEND THE PACKET
	.PAGE
;TYMNET TERMINAL TYPE TO NEXILIS TERMINAL TYPE AND BAUD RATE TABLES

.IF EQ ..SAT

	PURE

	.MACRO	XXX
	XX	AUX ,300	;  0 - HOST (AUX CIRCUIT)
	XX	CRT ,300	;  1 - 300 BAUD, TIC = A
	XX	TRMC,300	;  2 - 300 BAUD, TIC = C
	XX	TRME,300	;  3 - 300 BAUD, TIC = E
	XX	TRMG,300	;  4 - 300 BAUD, TIC = G
	XX	TRMB,150	;  5 - 150 BAUD, TIC = B
	XX	TRMC,150	;  6 - 150 BAUD, TIC = C
	XX	TRMJ,150	;  7 - 150 BAUD, TIC = J
	XX	SEL ,300X	;  8 - 300 BAUD, SELECTRIC
	XX	SEL ,134X	;  9 - 134 BAUD, SELECTRIC
	XX	CRT ,110	; 10 - 110 BAUD, TIC = D
	XX	2780,300	; 11 - 2780 ?
	XX	CRTA,1200	; 12 - 1200 BAUD, TIC = A
	XX	CRTA,300	; 13 - Borroughs polled
	XX	AUX ,300	; 14 - AUX through gateway
	XX	BAUD,50		; 15 - Baudot
	XX	CRTA,2400	; 16 - 2400 BAUD
	XX	3270,300	; 17 - 3270
	XX	3270,300	; 18 - 3270 Printer
	XX	CRTA,4800	; 19 - 4800 BAUD
	XX	CRTA,9600	; 20 - 9600 BAUD
	XX	CRTA,1200	; 21 - MULTIPLEXED PVC
	XX	AUDIO,300	; 22 - AUDIO RESPONSE UNIT
	XX	CRTA,1200	; 23 - 75/1200 BAUD TERMINALS
	XX	3270,300	; 24 - SDLC
	XX	TRMY,300	; 25 - TRANSACTION TERMINALS
	XX	AUX,300		; 26 - "HOST ORIENTED"
	.ENDM

;GENERATE TYMNET TERMINAL TYPE TO NEXILIS TERMINAL TYPE TABLE

	.MACRO	XX  TYPE,RATE
.IF NB TYPE
	.BYTE	T.'TYPE
.IFF
	.BYTE	0
.ENDC
	.ENDM

TYNTYT:	XXX
MAXTYT=!.-TYNTYT

;GENERATE TYMNET TERMINAL TYPE TO NEXILIS BAUD RATE TABLE

	.MACRO	XX  TYPE,RATE
.IF NB RATE
	.BYTE	R.'RATE
.IFF
	.BYTE	0
.ENDC
	.ENDM

TYNTYR:	XXX

	CODE

.ENDC		;.IF EQ ..SAT
	.PAGE
;HERE FOR SUPERVISOR MESSAGE .SMCMM = F - MISCELLANEOUS
;	0F,SUBTYPE+80


GENMSG:	MOVB	(R2)+,R0		;GET MISCELLANEOUS FUNCTION
	MOV	R0,R1			;SAVE SR2 FOR THOSE FUNCTIONS THAT NEED IT
	BIC	#^C<^H1F>,R0		;
	SUB	#8.,R0
	BLT	1$
	CMP	#<^H14-^H8>,R0		;VALID FUNCTION?
	BGE	2$			;YES
1$:	JMP	BADSPR			;NO

2$:	ASL	R0			;FOR WORD INDEXING
	JMP	@MISDSP(R0)		;DISPATCH ON THE SUB-TYPE

;DISPATCH TABLE FOR SUB-TYPE FOR MESSAGE TYPE .SMCMM

	PURE

	.EVEN
MISDSP:	.WORD	SPRTOD		;.SFTOD =  8 - SUPERVISOR TIME OF DAY
	.WORD	IGNSPR		;	=  9 - STOP TALKING TO NODE
	.WORD	IGNSPR		;	=  A - START TALKING TO NODE
	.WORD	BADSPR		;	=  B - REBUILD ABORTED
	.WORD	GOBOOT#		;.S3CBF =  C - GO TO BOOTSTRAP
	.WORD	IGNSPR		;	=  D - LOGIN ZAPPER CONFIRMATION
	.WORD	SYNPRT		;	=  E - SYNC PORT REQUEST
	.WORD	SPEEDS		;	=  F - LINK SPEED REQUEST
	.WORD	IGNSPR		;	= 10 - HOST REJECTION
	.WORD	IGNSPR		;	= 11 - BAD GUY LIST REQ
	.WORD	IGNSPR		;.S3SCT = 12 - REMOVE FROM BAD GUY LIST
	.WORD	IGNSPR		;	= 13 - ADD TO BAD GUY LIST
	.WORD	SUPTIM		;	= 14 - SUP TIMING DIAGNOSTIC

	CODE
	.PAGE
;HERE FOR TRACE CIRCUIT COMMAND
;	0B80, HOST# + 8000, PORT #

TRACEC:	INC	R2			;POINT TO NEXT DATA WORD
	MOV	#SUPMSG+4,R1		;POINT TO BEGINING OF TRACE RECORD
	MOV	(R2)+,R0		;GET HOST NUMBER
	MOV	R0,(R1)+		;START STORING AWAY IN RESPONSE
	SWAB	R0			;GET INTO 11 ORDER
	CMP	#-2,R0			;CHECK FOR SUP CIRCUIT TRACE
	BEQ	20$			;HANDEL SUP TRACE CIRCUIT
	MOV	(R2)+,R0		;GET PORT NUMBER
	BEQ	99$			;WE NEVER ASSIGN PORT ZERO
	SWAB	R0			;PUT IN 11 ORDER
	CMPB	R0,DDSOC#(R4)		;CHECK FOR PORT IN RANGE
	BHI	99$			;OUT OF RANGE
	ASL	R0			;CONVERT TO WORD OFFSET
	ADD	DDSX#(R4),R0		;POINT TO SDB POINTER ARRAY
	MOV	-(R0),SD		;GET SDB
	BR	30$
20$:	MOV	DDSUSD#(R4),SD		;GET SUPERVISOR SDB
	MOV	#-5,SUPMSG+5		;INDICATE COMMAND CIRCUIT
30$:	CLRB	(R1)+
	MOVB	SDSOC#(SD),(R1)+	;PUT IN PORT NUMBER
	MOV	SDLILD#(SD),R3		;GET THE LDB
	BEQ	99$			;UNASIGNED
	PUSH	R3			;SET UP CALLING SEQUENCE
	PUSH	R2
	MOV	DDLINN#(R4),R0		;GET OUT NODE NUMBER
	SWAB	R0
	MOV	R0,(R1)+		;STORE REST
	MOV	LDINBR#(R3),R0		;GET THE NEIGHBOR NUMBER
	SWAB	R0
	MOV	R0,(R1)+		;STORE NUMBER OF NEIGHBOR
	CLRB	(R1)+			;CLEAR UPPER PART OF CHANNEL
	MOVB	SDLICN#(SD),(R1)+	;STORE CHANNEL NUMBER
	MOV	#SUPMSG+2,R2		;POINT TO LAST OF FIXED DATA
	MOV	#^H0280,(R2)		;PUT IN 8002 FOR COUNT
	MOV	#^H0003,-(R2)		;PUT IN HEADER
	MOV	#17*400,-(R2)		;PUT IN COUNT OF 17 AND CHANNEL ZERO
	MOVB	#21,-(R2)		;PUT IN HEADER COUNT
;	MOV	#SUPMSG-3,R2		;POINT TO MESSAGE
	MOV	#21,R0			;SET UP COUNT
	CJMP	SNDSP2			;COPY MESSAGE INTO RING
99$:	BIC	#77,R2			;RESET PACKET POINTER
	ADD	#PKDATA+4,R2		;POINT TO REQUEST
	MOV	#SUPMSG,R1		;POINT OT REPLY BUFFER
	MOV	#^H8A14,(R1)+		;FORM TRACE RESPONSE
	MOV	#^H0180,(R1)+		;SAY ONE NODE FOUND
	MOV	(R2)+,(R1)+		;COPY HOST
	MOV	(R2)+,(R1)+		;COPY PORT
	MOV	DDLINN#(R4),(R1)	;COPY OUR NODE INTO LIST
	SWAB	(R1)+			;PUT BYTES INTO CORRECT ORDER
	MOV	#-1,(R1)+		;SAY DEAD END
	CLR	(R1)			;CLEAR THE PORT
	MOV	#16,R0			;16 BYTES INT THE RESPONSE
	CJMP	SNDSPR	
	.PAGE
;HERE FOR TYPE .S3LCR = 0D - LOGIN CHARACTER RESPONSE
;	0D,N+FLAGS,PORT,#OF CHAR, CHAR....CHAR

LGICRS:	MOVB	(R2)+,R0		;GET FLAGS AND MESSAGE NUMBER
	PUSH	R0
	MOV	(R2)+,SD		;GET PORT NUMBER
	SWAB	SD			;COMPENSATE FOR DIFFERENT WORD ORDER
	ASL	SD
	ADD	DDSX#(R4),SD		;FIND SDB
	MOV	-(SD),SD

2$:	CMPB	#.SSCON,SDSTS1#(SD)	;IS THIS SDB CONNECTED?
	BEQ	4$			;YES-GO ON
;	MOV	#.CCZAP,R0		;NO-SEND A ZAPPER TO THE SUPERVISOR
	CALL	LKISCM#
	TST	(SP)+			;IF ERROR, FIX UP THE STACK
	RETURN

4$:	TBBE	<^H20>,(SP),10$		;WANT TO CLEAR OUTPUT BUFFER?
	MAKPKT	.PLSTP#			;YES-SEND EAT PACKET
	BCS	10$
	MOV	#.PTEAT*400+1,PKCNT(R1)
	CLRB	PKDATA(R1)
	CALL	LKISPK
10$:	BIS	#$I1PWM,SDLIS1#(SD)	;ASSUME DEFAULT OF PASSWORD ENTRY
	TBBE	<^H40>,(SP),20$		;WANT TO ENABLE ECHOING?
	BIC	#$I1PWM,SDLIS1#(SD)	;YES - CLEAR PASSWORD ENTRY MODE
	MAKPKT	.PLSTP#
	BCS	20$
	MOV	#.PTFUN*400+3,PKCNT(R1)
	MOV	#.TPECH*400+.FNSDP,PKDATA(R1)
	MOVB	#1,PKDATA+2(R1)
	CALL	LKISPK
20$:	TBBE	<^H80>,(SP),30$		;WANT TO CLEAR INPUT BUFFER?
	PUSH	R2			;YES-SAVE OUR SPECIAL AC'S
	PUSH	R3
	CALL	CLRINP#			;AND DO IT!
	POP	R3
	POP	R2
30$:	MOV	(SP),R0			;GET MESSAGE NUMBER
	BIC	#^C^H1F,R0		;CLEAR EXTRANEOUS BITS
	SUB	#^H8,R0			;DESCALE
	CMP	#<^H10-^H8>,R0		;NON-PROGRAMMED ERROR MESSAGE ?
	BNE	301$			;NO
	MOVB	(R2)+,R1		;GET CHARACTER COUNT
	MOV	R2,R0			;POINT TO MESSAGE
	CALL	SNDMSG			;SEND THIS MESSAGE TO THE OTHER END
	MOV	#<^H10-^H8>,R0		;RESTORE ERROR CODE
301$:
.IF EQ ..SAT
	MOVB	ERRTBL(R0),R1		;GET ERROR CODE
	BEQ	31$			;IF NO ERROR CODE
	TBBE	$I1TCD,SDLIS1#(SD),31$	;OR IF NOT TYMNET COMMAND DECODER
	PUSH	R1			;SAVE ERROR CODE
;	MOV	#.CCZAP,R0		;SEND A ZAPPER TO THE SUPERVISOR
	CALL	LKISCM#
	POP	R0			;RESTORE ERROR CODE
	CALL	LKIRPK			;GET A PACKET
	MOV	#.PTDIS*400,PKCNT(R1)	;MAKE INTO A DISCONNECT PACKET
	CALL	SETEPK#
	CALL	LKISPK			;AND SEND IT
	BR	LGIC40			;THATS ALL
.ENDC

;HERE IF WANT TO SEND MESSAGE FROM HERE

31$:	ASL	R0			;FIX IT UP FOR WORD ADDRESSING
	MOV	MSGPNT(R0),R0		;GET ADDRESS OF MESSAGE
	BEQ	LGIC36			;GO ON IF NO MESSAGE
32$:	CLR	R1			;CLEAR CHARACTER LIMIT
	CALL	SNDMSG
	TSTB	@R0			;ARE WE ASKING FOR HIS PASSWORD?
	BNE	LGIC36			;NO-GO ON
	TBBE	$I1LCT,SDLIS1#(SD),LGIC36;YES-IS THIS A LOCAL COPY TERMINAL?
	MOV	#PWMASK,R0		;YES-TYPE A MASK
	TBBE	$I1SEL,SDLIS1#(SD),32$	;IS IT A SELECTRIC?
	MOV	#SLMASK,R0		;YES-USE RIGHT MASK
	BR	32$

;HERE WHEN FINISHED WITH TEXT

LGIC36:	BIS	#$I1INX,SDLIS1#(SD)	;INDICATE EXPECTING INPUT NOW
	MOV	#77777,SDACNT#(SD)	;ACCEPT OUTPUT NOW
	TBBE	$I1GBR,SDLIS1#(SD),10$	;HAVE WE SEEN A GREEN BALL?
	BIC	#$I1GBR,SDLIS1#(SD)	;YES
	CALL	LKIRPK			;SEND HIM A GREEN BALL
	MOV	#.PTFUN*400+1,PKCNT(R1)
	MOVB	#.FNGRN,PKDATA(R1)
	CALL	LKISPK
10$:	MOV	SDPKDH#(SD),R1		;ANYTHING PENDING?
	BEQ	LGIC40			;NO-FINISHED HERE
	PUSH	R2			;YES-SAVE VALUABLE AC'S
	PUSH	R3
	CALL	LIPOKE#			;START THINGS UP AGAIN
	POP	R3
	POP	R2
LGIC40:	POP	R0			;GET ERROR CODE
	BIC	#^C^H1F,R0
	CMPB	#^H11,R0		;IS THIS A HANG USER COMMAND
	BNE	10$			;NO
	CALL	LKIRPK			;GET OUR RESERVE PACKET
	MOV	#.ERSVR+200,R0		;REPORT DISCONNECT AS SUP REQUEST
	CALL	SETDIS#			;SETUP DISCONNECT PACKET
	CALL	LKISPK			;SEND TO TERMINAL HANDLER
10$:	RETURN

SNDMSG:	PUSH	R1			;SAVE CHARACTER COUNT
	MAKPKT	.PLZAP#			;GET A PACKET
	BCS	30$			;WE TRIED!
	CLRB	PKTYPE(R1)		;MAKE IT A DATA PACKET
	ADD	#PKDATA,R1		;POINT TO DATA AREA
	MOV	#<LF*400>+CR,(R1)+	;START OFF WITH CARRIAGE RETURN LF
10$:	MOVB	(R0)+,(R1)+		;COPY MESSAGE
	BEQ	20$			;IF END OF STRING
	DEC	(SP)			;DECREMENT COUNTER
	BEQ	20$			;END OF STRING
	BIT	#77,R0			;ARE WE ON A BUFFER BOUNDRY
	BNE	16$			;NO
	CMP	R0,#PKTBGN#		;ARE WE COPYING FROM A PACKET BUFFER
	BLO	16$			;NO, CONTINUE AS USUAL
	CMP	R0,PKTBND#		;ARE WE SURE THIS IS A PACKET
	BHI	16$			;NOT A PACKET
	MOV	-100(R0),R0		;POINT TO NEXT PACKET
	ADD	#PKDATA,R0		;POINT TO DATA PART OF PACKET
16$:	TBBN	77,R1,10$		;CONTINUE IF PACKET NOT FULL
	PUSH	R0			;FULL-SEND THE PACKET
	CALL	SNDTYM
	POP	R0
	MAKPKT	.PLZAP#			;GET ANOTHER PACKET
	BCS	30$			;WE TRIED!
	CLRB	PKTYPE(R1)		;MAKE IT A DATA PACKET
	ADD	#PKDATA,R1		;POINT TO DATA AREA
	BR	10$

;HERE AT END OF STRING

20$:	PUSH	R0			;SAVE THE POINTER TO THE STRING
	DEC	R1			;FIX UP POINTER TO THE PACKET
	CALL	SNDTYM			;SEND THE DATA PACKET
	POP	R0
30$:	TST	(SP)+			;CLEAR STACK
	RETURN

;MESSAGE TABLES FOR .S3LCR

	PURE

	.EVEN
MSGPNT:	.WORD	0		; 8 - NO MESSAGE
	.WORD	MSG001		; 9 - "please log in: "
	.WORD	MSG002		; A - "error, type username: "
	.WORD	MSG003		; B - "error, type password: "
	.WORD	MSG004		; C - "username: "
	.WORD	MSG005		; D - "password: "
	.WORD	0		; E - ILLEGAL
	.WORD	0		; F - ILLEGAL
	.WORD	0		; 10 - SEND STRING
	.WORD	0		; 11 - SEND HANG PAIR
	.WORD	0		; 12 - SEND HALF DUX HANG PAIR
	.WORD	MSG010		; 13 - "please see your rep..."
	.WORD	MSG011		; 14 - "bad mud"
	.WORD	MSG012		; 15 - "circuits busy"
	.WORD	MSG013		; 16 - "host not available"
	.WORD	MSG014		; 17 - "host out of ports"
	.WORD	MSG015		; 18 - " host down"
	.WORD	MSG016		; 19 - "host shut"
	.WORD	MSG017		; 1A - "try again in 2 minutes"
	.WORD	MSG020		; 1B - "access not permited"
	.WORD	MSG021		; 1C - "No host specified"
	.WORD	MSG022		; 1D - "bad host number"
	.WORD	MSG023		; 1E - "mud error"


;MESSAGE TEXT STRINGS - ALL STRINGS END IN A ZERO BYTE - IF A STRING ENDS IN
;  TWO ZERO BYTES, A PASSWORD MASK IS TYPED AFTER THE STRING IF FOR A LOCAL
;  COPY TERMINAL (NOTE: THE MASK IS OUTPUT USING THE SAME CODE AS THE STRINGS,
;  THUS IT MUST BE FOLLOWED BY A SINGLE ZERO BYTE UNLESS WE WANT TO OUTPUT IT
;  FOREVER!)

PWMASK:	.ASCII	<377><377>	;THIS IS THE PASSWORD MASK
	.ASCII	"###############"<CR><377><377>
	.ASCII	"+++++++++++++++"<CR><377><377>
	.ASCIZ	"OOOOOOOOOOOOOOO"<CR>
	.BYTE	1			;THIS IS NOT A PASSWORD REQUEST

SLMASK:	.ASCII	"###############"	;PASSWORD MASK FOR SELECTRICS
	.BYTE	BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS
	.ASCII	"+++++++++++++++"
	.BYTE	BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS
	.ASCII	"OOOOOOOOOOOOOOO"
	.BYTE	BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS,BS
	.BYTE	0			;WARNING-NEXT BYTE MUST NOT BE 0!
	.BYTE	1			;THIS IS NOT A PASSWORD REQUEST

MSG001:	.ASCIZ	"please log in: "
MSG002:	.ASCIZ	"error, type user name: "
MSG003:	.ASCIZ	"error, type password: "
	.BYTE	0			;THIS FLAGS THAT A PASSWORD MASK MAY BE
					;  NEEDED NEXT
MSG004:	.ASCIZ	"user name: "
MSG005:	.ASCIZ	"password: "
	.BYTE	0			;THIS FLAGS THAT A PASSWORD MASK MAY BE
					;  NEEDED NEXT
MSG010:	.ASCII	"please see your representative"
	.ASCIZ	<CR><LF>"if you are having trouble logging in"
MSG011:	.ASCIZ	"bad mud"<CR><LF>
MSG012:	.ASCIZ	"circuits busy"<CR><LF>
MSG013:	.ASCIZ	"host not available thru network"<CR><LF>
MSG014:	.ASCIZ	"host out of ports"<CR><LF>
MSG015:	.ASCIZ	"host down"<CR><LF>
MSG016:	.ASCIZ	"host shut"<CR><LF>
MSG017:	.ASCIZ	"try again in 2 minutes"<CR><LF>
MSG020:	.ASCIZ	"access not permitted"<CR><LF>
MSG021:	.ASCIZ	"no host specified"<CR><LF>
MSG022:	.ASCIZ	"bad host number"<CR><LF>
MSG023:	.ASCIZ	"mud error"<CR><LF>
ERRSUP:	.ASCIZ	"unknown network error"<CR><LF>

;TABLE OF NETWORK ERROR CODES FOR SPECIAL MESSAGES - USED WHEN CONNECTED TO
;  A TYMNET MODE COMMAND DECODER

.IF EQ ..SAT
ERRTBL:	.BYTE	0		; 8 - NO MESSAGE
	.BYTE	.ERREQ		; 9 - "please log in: "
	.BYTE	.ERUNE		; A - "error, type username: "
	.BYTE	0		; B - "error, type password: "
	.BYTE	.ERREQ		; C - "username: "
	.BYTE	0		; D - "password: "
	.BYTE	0		; E - ILLEGAL
	.BYTE	0		; F - ILLEGAL
	.BYTE	0		; 10 - SEND STRING
	.BYTE	.ERSVR		; 11 - HANG PAIR
	.BYTE	0		; 12 - HALF DUX HANG PAIR
	.BYTE	0		; 13 - PLEASE SEE YOUR REP...
	.BYTE	0		; 14 - BAD MUD
	.BYTE	0		; 15 - CIRCUITS BUSY
	.BYTE	0		; 16 - HOST NOT AVAILABLE
	.BYTE	0		; 17 - HOST OUF OF PORTS
	.BYTE	0		; 18 - HOST DOWN
	.BYTE	0		; 19 - HOST SHUT
	.BYTE	0		; 1A - TRY AGAIN IN TWO
	.BYTE	0		; 1B - ACCESS NOT PERMITED
	.BYTE	0		; 1C - NO HOST SPECIFIED
	.BYTE	0		; 1D - BAD HOST NUMBER
	.BYTE	0		; 1E - MUD ERROR
.ENDC

	CODE
	.PAGE
;HERE FOR SUB-TYPE .S3CBF = 4 - CLEAR BUFFER
;	SR2 = (16) 100004
;	SR3 = (16) BUFFER NUMBER
.IF EQ  1
CLRBUF:	SPRWRD	SD			;GET BUFFER NUMBER
	CLC				;GET DIRECTION BIT IN C, SOCKET IN SD
	ROR	SD
	ROR	R0			;REMEMBER DIRECTION IN SIGN BIT OF R0
	CALL	GETSD2			;GET THE SDB
	BCS	10$			;IF NONE
	CMPB	#.SSCON,SDSTS1#(SD)	;IS THE SOCKET CONNECTED?
	BNE	10$			;NO-FORGET THIS
	CALL	LKIRPK			;GET A PACKET
	MOV	#.PTEAT*400+1,PKCNT(R1)	;MAKE INTO A NULL FUNCTION EAT PACKET
	CLRB	PKDATA(R1)
	TST	R0			;WHICH DIRECTION?
	BMI	4$			;AWAY FROM NETWORK
	MOV	(SD),SD			;TOWARD NETWORK-POINT TO LINKED SDB
4$:	PUSH	R4			;MAKE SURE R4 IS PRESERVED
	CALL	LKISPK			;SEND THE PACKET
	POP	R4
10$:	JMP	NXTSPR			;THATS ALL
.ENDC
	.PAGE
;HERE FOR SUB-TYPE .S3RLS = 14 - REPORT LINE SPEEDS
;	SR2 = (16) 100016
;	SR3 = NOT USED

SPEEDS:	PUSH	R3			;SAVE R3
	MOV	DDLILD#(R4),R3		;POINT TO FIRST LDB
10$:	CALL	SNDSPD
	MOV	LDINXT#(R3),R3		;STEP TO NEXT LINE
	BNE	10$			;CONTINUE IF MORE
	POP	R3			;RESTORE R3
	TST	(R2)+			;FIX UP R2
	RETURN				;THATS ALL

SNDSPD:	MOV	#.SMCLC+^HE000,SUPMSG	;SEND CHANGE LINE/LINK MESSAGE
	MOVB	LDISPD#(R3),R0		;GET LINE SPEED
	BISB	R0,SUPMSG+1		;PUT SPEED IN FIRST PART OF MESSAGE
	SWAB	R0			;PUT IN RIGHT PLACE
	BISB	LDILNO#(R3),R0		;GET LINE NUMBER
	BIS	#^H8080,R0
	MOV	R0,SUPMSG+2		;SR2
	MOV	LDINBR#(R3),R0		;GET THE NEIGHBOR
	BIS	#^H8000,R0		;TURN ON HIGH BIT
	SWAB	R0			;PUT IN SUP ORDER
	MOV	R0,SUPMSG+4
	MOV	#6,R0
	CJMP	SNDSPR			;SEND TO CURRENT SUPERVISOR (AND RETURN)

;SUPERVISOR TIMING DIAGNOSTIC

SUPTIM:	MOV	#SUPMSG,R0		;POINT TO RESPONSE
	MOV	#^H9514,(R0)+		;FORM HEADER
	MOV	(R2)+,(R0)+		;COPY TIME
	MOV	(R2)+,(R0)+		;COPY TIME
	MOV	(R2)+,(R0)+		;COPY COUNT
	MOV	#14,R0			;SET UP COUNT
	CJMP	SNDSPR			;SEND IT

	.PAGE
;HERE FOR TYPE .SS = 5 - INTERNALLY INITIATED LOGIN STATUS
;  THIS MESSAGE HAS TWO USES:
;    ACKNOWLEDGEMENT TO A REQUEST TO BUILD AN AUX-CIRCUIT
;	0E,80
;    TERMINATION OF AUX-CIRCUIT BUILDING DIALOG
;	0E,80+ERROR CODE
;     WHERE ERROR CODE IS DEFINED AS FOLLOWS:
;	1 = FORMAT ERROR IN LOGIN STRING
;	2 = USER NAME ERROR
;	3 = MUD ERROR
;	4 = SYSTEM UNAVAILABLE
;	5 = COMMAND REJECT
;	6 = TIME OUT
;	7 = UNDEFINED
;	8 = OUT OF ORGINATING PROTS
;	9 = REQUEST NOT HONORED (AUX CIRCUIT QUEUE FULL)
;	A = INVALID REQUESTING HOST NUMBER
;	B = REQUESTING HOST NOT UP ON NODE

AUXRES:
.IF EQ ..SAT
	MOVB	(R2)+,R0		;GET THE ERROR CODE
	BIC	#^C17,R0		;CLEAR EXTRANEOUS BIT
	PUSH	R0			;SAVE THE ERROR CODE
	MOV	(R2)+,SD		;GET THE PORT
	SWAB	SD
	ASL	SD			;CONVERT TO WORD INDEX
	ADD	DDSX#(R4),SD		;POINT TO SDB ARRAY AT PORT
	MOV	-(SD),SD
	PUSH	R1			;CLEAR TIMER
	PUSH	R2
	PUSH	R3
	MOV	#LKIATO,R1
	CALL	TIMKIL#
	POP	R3
	POP	R2
	POP	R1
5$:	POP	R0			;RESTORE ERROR CODE
	CMP	R0,#ERCMAX		;KNOWN VALUE?
	BLOS	6$			;YES
	MOV	#ERCMAX,R0		;NO
6$:;	TBBN	100000,R1,20$		;FINAL MESSAGE?
	TST	R0			;SEND LOGIN STRING MESSAGE?
	BNE	20$			;NO
	CMPB	#.SSCTP,SDSTS1#(SD)	;YES-IS A CONNECTION PENDING?
	BNE	LGIERR			;NO-ERROR
	CALL	LKIRPK			;YES-GET A PACKET
	MOV	#77777,SDACNT#(SD)	;TURN OFF BACKPRESSURE SO WILL ACCEPT
					;  THE LOGIN STRING
	PUSH	R2			;SAVE THE IMPORTANT REGISTERS
	PUSH	R3
	MOV	#P.TYMS*400+155,R2	;OK-ACCEPT THE CONNECTION
	CLR	R0
	CALL	ACCEPT#
14$:	POP	R3			;RESTORE REGISTERS
	POP	R2
	BR	24$			;CONTINUE

;HERE FOR SECOND MESSAGE WHICH TERMINATES THE LOGIN SEQUENCE FOR AUX CIRCUITS

20$:	MOVB	ERCTBL(R0),R0		;YES-GET NEXILIS ERROR CODE
22$:	CALL	MAKKIL#			;Error-make a Kill packet
	CALL	LKISPK			;Send it
	CALL	CLRCIR			;Be safe and break possible link to
24$:	RETURN				;THATS ALL
LGIERR:	JMP	BADSPR			;NO-ERROR!



;HERE ON AUX-CIRCUIT BUILDING TIME-OUT

LKIATO:: MOV	SDDDB#(SD),R4
	CALL	LKIRPK			;GET A NEW PACKET
	MOV	#.ERTIM,R0		;REPORT TIMEOUT ERROR
	CALL	REFUSE#			;NAK THE CIRCUIT REQUEST
	CJMP	CLRCIR

;TABLE TO TRANSLATE FROM TYMNET ERROR CODES TO NEXILIS ERROR CODES

	PURE

ERCTBL:	.BYTE	0		; 0 - NO ERROR
	.BYTE	.ERFER		; 1 - FORMAT ERROR
	.BYTE	.ERUNE		; 2 - USER NAME ERROR
	.BYTE	.ERMUD		; 3 - MUD ERROR
	.BYTE	.ERHNA		; 4 - SYSTEM UNAVAILABLE
	.BYTE	.ERCRJ		; 5 - COMMAND REJECT
	.BYTE	.ERTIM		; 6 - TIME-OUT
	.BYTE	.ERPRV		; 7 - ACCESS BARRED
	.BYTE	.EROOP		; 8 - OUT OF ORIGINATING PORTS
	.BYTE	.ERAQF		; 9 - REQUEST NOT HONORED (AUX CIRCUIT QUEUE
				;	FULL)
	.BYTE	.ERCRJ		; A - INVALID REQUESTING HOST
	.BYTE	.ERCRJ		; B - REQUESTING HOST NOT UP ON NODE
	.BYTE	.ERSPR		;   - UNDEFINED ERROR
ERCMAX=!.-ERCTBL-1

	CODE
.IFF
	JMP	BADSPR
.ENDC
	.PAGE
;HERE FOR SUPERVISOR MESSAGE .SMTOD = 6 - SUPERVISOR TIME-OF-DAY
;	(16) host (0= all), (16) TIME HIGH WORD, (16) TIME LOW WORD

SPRTOD:	MOV	(R2)+,R0		;GET DESIRED HOST
	SWAB	R0			;PUT IN 11 ORDER
	BIC	#^H8000,R0		;CLEAR ESCAPE BIT
	PUSH	R0
	MOV	(R2)+,R0		;GET DATA AND STACK IT
	SWAB	R0			;PUT IN NODE ORDER
	MOV	R0,SUPTOD
;	PUSH	R0
	MOV	(R2)+,R0
	SWAB	R0
	MOV	R0,SUPTOD+2
.IF EQ	..SAT
;	PUSH	R0
	MOV	R4,R0
	MOV	DDLINH#(R4),R1		;SCAN ONLY THE HOST TABLE ENTRIES THAT EXIST
2$:	MOV	DDLISS#(R0),SD		;GET SDB
	BEQ	10$			;IF NONE IN THIS SLOT
	TST	(SP)			;IS THIS TOD SPECIFIC TO ONE HOST
	BEQ	4$			;NO
	CMP	(SP),DDLIHD#(R0)	;YES - IS THIS IT?
	BNE	10$			;NO
4$:	PUSH	R0			;SAVE REGISTERS
	PUSH	R1
	MAKPKT	.PLSTP#			;GET A PACKET
	BCS	6$			;OH WELL-WE TRIED!
	MOV	#.PTFUN*400+6,PKCNT(R1)	;STORE TYPE AND COUNT
	MOV	#.SFTIM*400+.FNDCN,PKDATA(R1);STORE FIRST TWO BYTES
	MOV	SUPTOD,PKDATA+2(R1)	;STORE FIRST TIME WORD
	MOV	SUPTOD+2,PKDATA+4(R1)	;STORE SECOND TIME WORD
	INCB	SDPCNT#(SD)
	CALL	LKISPK			;SEND THE PACKET
6$:	POP	R1			;RESTORE REGISTERS
	POP	R0
10$:	CMP	(R0)+,(R0)+		;POINT AT NEXT HOST DESCRIPTOR
	SOB	R1,2$			;CONTINUE IF MORE TO DO
;	POP	R0			;GET BACK LOW PART OF TIME
.ENDC
;	MOV	R0,SUPTOD+2
;	POP	SUPTOD
	TST	(SP)+			;CLEAR HOST OFF STACK
	RETURN
	.PAGE
	.SBTTL	SYNPRT - SYNC PORTS REQUEST

SYNPRT:	PUSH	R3		;SAVE R3
	MOV	DDLILD#(R4),R3		;POINT TO FIRST LDB
	MOV	#SUPMSG,R0		;POINT TO MESSAGE BUFFER
	MOV	#^H8D14,(R0)+		;START BUILDING MESSAGE
	MOV	#^H8080,(R0)+		;PUT IN DE-ESCAPERS
2$:	MOV	LDINBR#(R3),R1		;GET NEIGHBOR NUMBER
	TBBN	$L1DWN,LDIST1#(R3),3$	;IS THE NEIGHBOR UP
	BIS	#^H8000,R1		;YES
3$:	CMP	#-1,R1			;UNASSIGNED XLINK?
	BNE	4$			;NO
	CLR	R1			;YES, DECALRE NO LINE
4$:	SWAB	R1			;PUT BYTES IN CORRECT ORDER
	MOV	R1,(R0)+		;PUT AWAY FOR SUP MESSAGE
	INCB	SUPMSG+3		;COUNT THE LINE
	MOV	LDINXT#(R3),R3		;STEP TO NEXT LINE
	BNE	2$			;CONTINUE IF MORE
	SUB	#SUPMSG,R0		;CALCULATE LENGTH OF MESSAGE
	CALL	SNDSPR			;SEND TO CURRENT SUPERVISOR
	POP	R3			;RESTORE R3
	RETURN				;THATS ALL
	.PAGE

TRCREC:	PUSH	R0			;SAVE DATA COUNT
	INC	R2			;SKIP OVER BYTE COUNT BYTE
	CALL	CHEKR2			;CHECK FOR PHYSICAL RECORD OVERFLOW
	DEC	R0
	MOV	#SUPMSG,R1		;POINT TO SUP MESSAGE AREA
10$:	MOVB	(R2)+,(R1)+		;COPY THE RECORD
	CALL	CHEKR2			;CHECK FOR PHYSICAL RECORD OVERFLOW
15$:	SOB	R0,10$
	POP	R0			;GET COUNT BACK
	CMPB	#3,SUPMSG		;IS THIS REALLY A TRACE MESSAGE
	BNE	50$			;NO, SKIP MESSAGE
	INC	R0			;FORM FINAL COUNT OF MESSAGE
	MOV	#^H8A14,SUPMSG		;REPLACE HEADER
	MOV	SUPMSG-4(R0),SD		;GET CHANNEL NUMBER
	SWAB	SD
	ASL	SD			;CONVERT TO WORD OFFSET
	MOV	#-1,SUPMSG-4(R0)	;DEFAULT TO DEAD END
	ADD	LDISDB#(R3),SD		;POINT TO SDB
	MOV	(SD),SD			;GET THE SDB
	BEQ	30$			;NONE THERE MUST BE DEAD END
	MOVB	SDSOC#(SD),R1		;GET PORT NUMBER
	SWAB	R1
	MOV	R1,SUPMSG-2(R0)		;STORE PORT
.IF EQ	..SAT
;	MOV	KERHST#,SUPMSG-4(R0)	;PUT IN HOST
	MOV	SDLIHC#(SD),R1		;GET HOST
	BIS	#^H8000,R1
	SWAB	R1			;PUT BYTES IN SUP ORDER
	MOV	R1,SUPMSG-4(R0)		;PUT IN HOST NUMBER
	TBBN	$I1INC!$I1AUX,SDLIS1#(SD),20$ ;IS THIS A TERMINAL
.ENDC
	MOV	#^HF8FF,SUPMSG-4(R0)	;YES - DECLARE TERMINATION TO BE TYMSAT
20$:	TBBE	$I2COM,SDLIS2#(SD),30$	;IS THIS A SUP CONNECTION
	MOV	#^HFBFF,SUPMSG-4(R0)	;YES - PUT IN LEP CODE FOR DESTINATION
30$:	PUSH	R2			;SAVE THIS VERY IMPORTANT REGISTER OVER CALL
	CALL	SNDSPR			;SEND TO THE SUP
	POP	R2
50$:	JMP	LKINXT			;HANDLE NEXT DATA RECORD
	.PAGE
; HANDLE THE PSTAT COMMAND HERE
;	10,80+N,HOST#+8000      N=PORT ARRAY


PSTATR:	MOVB	(R2)+,R0		;GET ARRAY NUMBER
	BIC	#^C^H3F,R0		;CLEAR EXTRANEOUS BITS
	BIS	#^H8000,R0		;PUT IN ESCAPE BIT
	SWAB	R0			;PUT BYTES IN CORRECT ORDER
	MOV	R0,SUPMSG+4		;PUT IN REPLY
	MOV	(R2)+,R0		;GET HOST NUMBER
	MOV	R0,SUPMSG+2		;PUT INTO REPLY
5$:	SWAB	R0			;GET BYTES INTO 11 ORDER
	CMP	#-2,R0			;FOR SUP PORTS?
	BEQ	10$			;YES
	BIC	#^H8000,R0		;CLEAR HIGH BIT
10$:	PUSH	R0			;SAVE ON STACK
	PUSH	#SUPMSG+6		;POINT TO START OF PORT DATA IN SUP MSG
	MOV	DDSX#(R4),R2		;POINT TO FIRST SDB
	MOV	#7,R0			;DO THIS COUNT FIRST TINE THROUGH
15$:	CLR	R1			;CLEAR BIT ARRAY BYTE
20$:	ASL	R1			;SHIFT EVERY THING OVER ONE BIT
	MOV	(R2)+,SD		;POINT TO NEXT SDB
	BEQ	40$			;END OF THE LINE
	TST	SDLILD#(SD)		;IS AN LDB ASSIGNED
	BEQ	30$			;NO
	CMP	SDLIHC#(SD),2(SP)	;IS THIS THE CORRECT HOST
	BEQ	25$
	TST	2(SP)			;IS THIS REQUEST FOR SUP PORTS
	BPL	30$			;NO
	TBBE	$I2COM,SDLIS2#(SD),30$	;YES - IS IT A SUP CIRCUIT
25$:	INC	R1			;SET THE LOW BIT
30$:	SOB	R0,20$			;CHECK OUT THE NEXT ONE
	MOVB	R1,@(SP)		;MOVE BITS TO SUP MSG
	INC	(SP)			;POINT TO NEXT BYTE
	MOV	#8.,R0			;SET UP COUNTER
	CMP	#SUPMSG+26,(SP)		;END OF MESSAGE YES
	BHI	15$			;CONTINUE
	POP	R0
	BR	50$			;SEND OFF MESSAGE
35$:	ASL	R1
40$:	SOB	R0,35$			;CONTINUE UNTIL DONE WITH THIS BYTE
	POP	R0			;GET POINTER TO NEXT BYTE
	MOVB	R1,(R0)+		;MOVE IN LAST BYTE
45$:	CMP	#SUPMSG+26,R0		;CHECK FOR LAST BYTE
	BEQ	50$
	CLRB	(R0)+			;SET REST OF PORTS NOT IN USE
	BR	45$
50$:	MOV	#^H8B14,SUPMSG		;PUT IN HEADER
	MOV	#26,R0			;26 BYTE SUP MESSAGE
	TST	(SP)+			;CLEAR STACK
	CJMP	SNDSPR
	.PAGE

;HERE FOR ERROR IN SUP MESSAGE

BADSPR:	MOV	#SUPMSG,R0		;POINT TO SUP MESSAGE BUFFER
	MOV	#^H8012,(R0)+		;REPORT TO SUP LOG
	MOV	#^H1300,(R0)+		;REPORT AS BAD COMMAND
	BIC	#77,R2			;GET BACK TO GEGINING OF MESSAGE
	ADD	#PKDATA+2,R2		;POINT TO COMMAND PART
	MOV	(R2)+,(R0)+
	MOV	(R2)+,(R0)+
	MOV	#8.,R0
	CALL	SNDSPR			;SEND REJECT TO SUPERVISOR
IGNSPR:					;AND FALL INTO NXTSPR

;HERE WHEN FINISHED WITH A SUPERVISOR MESSAGE

NXTSPR:	RETURN



;HERE IF FATAL ERROR IN FRAME (BAD CHANNEL NUMBER, BAD COUNT, ETC.)
;	C(R0) = ERROR CODE WORD FOR CAUSE OF ERROR
BADFRM:	PUSH	R0			;SAVE ERROR CODE
	MOV	#4,R0			;TELL SUP BORI ZAP
	CALL	LKIDWN			;TAKE IT DOWN!
	POP	R0			;RESTORE ERROR CODE
	INC	LDERBD#(R3)		;COUNT THE ERROR
	MOV	LDIDDB#(R3),R4		;Get the DDB
	INC	DDERPC#(R4)		;COUNT IT AS A DEVICE ERROR
	TST	(SP)+			;FIX UP THE STACK
	RETURN				;USE ERROR RETURN TO INDICATE BAD FRAME
	.PAGE
	.SBTTL	SNDSPR - ORIGINATE SUPERVISOR MESSAGE

;	MOV	SR1,SUPMSG		;C(SR1) = MESSAGE TYPE 
;	...
;	MOV	SRn,SUPMSG+2n
;	MOV	#2n,R0
;	CALL	SNDSPR

;SUPERVISOR MESSAGES ARE BUFFERED USING A LIST OF PACKETS FOR EACH T.201 LINE.
;  MESSAGES ARE PACKED.  THE FIRST WORD OF EACH PACKET IS USED AS
;  A LINK WORD, REST OF THE PACKET IS USED FOR DATA
;  THE FOLLOWING POINTERS ARE USED IN THE LDB:
;
;	LDISLH = SUPERVISOR LIST HEAD POINTER (TAKER POINTER)
;	LDISLT = SUPERVISOR LIST TAIL POINTER (PUTTER POINTER)
;  POINTERS POINT TO THE NEXT BYTE IN A PACKET.  THE FACT THAT PACKETS
;  ALWAYS BEGIN MODULO 100 IS USED TO DETERMINE WHEN THE END OF A PACKET HAS
;  BEEN REACHED.  WHEN THE LIST IS EMPTY, NO PACKETS ARE ALLOCATED AND THE HEAD
;  AND TAIL POINTERS ARE 0.

SNDSPR:: PUSH	R3
	MOV	DDLIUP#(R4),R3		;POINT TO CURRENT UPSTREAM LINE
	BEQ	SNDSPE			;FORGET IT IF NONE!
	PUSH	R2			;Save this very important register
	MOV	#SUPBUF+1,R1		;POINT TO DESTINATION
	MOVB	DDLISC#(R4),(R1)+	;SAVE THE CHANNEL NUMBER

	MOV	#SUPMSG-2,R2		;POINT TO MESSAGE SOURCE
	MOV	SUPNOD,(R2)		;Place node + 8000 in buffer
	ADD	#2,R0			;ACCOUNT FOR THE NODE NUMBER
	CALL	EXPSPR			;EXPAND SUPERVISOR MESSAGE
	MOV	R1,R0			;SAVE FOR STOREAGE LOOP
SNDSP1:	MOV	#SUPBUF,R2		;POINT AT FIRST BYTE TO SEND
SNDSP2:	MOV	LDISLT#(R3),R1		;GET CURRENT POINTER
	BNE	10$			;GOT ONE
	MOV	#LDISLH,R1		;GET READY TO DO SOME MAGIC
	ADD	R3,R1			;POINT TO LDISLH(R3)
	INC	R0			;PRETEND WE COPYED A CHAR
	BR	20$

10$:	MOVB	(R2)+,(R1)+		;COPY DATA
	BIT	#77,R1			;DID WE OVERFLOW THE PACKET?
	BNE	30$
	SUB	#100,R1			;YES-POINT TO START OF PACKET
20$:	PUSH	R1			;SAVE ADDRESS
22$:	MAKPKT	.PLZAP#			;GET ANOTHER PACKET
	BCC	26$			;GO ON IF GOT ONE
	CALL	ZAPBUF#			;NONE AVAILABLE-ZAP A BUFFER!
	  BR	50$			;NOTHING TO ZAP-FORGET IT! (WE TRIED
					;  REAL HARD!)
	BR	22$			;SHOULD HAVE SPACE NOW-TRY AGAIN

;HERE WITH A PACKET

26$:	CLR	(R1)+			;POINT TO FIRST BUFFER
	MOV	R1,@(SP)+		;LINK TO PREVIOUS PACKET
30$:	SOB	R0,10$
	MOV	R1,LDISLT#(R3)		;FIX UP TAIL POINTER
	BR	SNDRET

;HERE IF CANNOT SEND MESSAGE FOR SOME REASON - JUST RETURN WITH NO ERROR
;  INDICATION!!

50$:	TST	(SP)+			;Fix up the stack
SNDRET:	POP	R2
SNDSPE:	POP	R3			;RESTORE CURRENT LDB ADDRESS
	RETURN


;	EXPSPR	- EXPAND SUPERVISOR MESSAGES


EXPSPR:	CMPB	#3,(R2)			;IS THE NEXT BYTE A CONFLICT
	BLO	14$			;NO
	CLRB	(R1)+			;YES - ADD ESCAPE CHAR
14$:	MOVB	(R2)+,(R1)+		;COPY A BYTE
	CMP	R1,#SUPEND-1		;OVERFLOW?
	BHIS	20$			;YES!!!
	BIT	#77,R2			;ARE WE ON A BUFFER BOUNDRY
	BNE	16$			;NO
	CMP	R2,#PKTBGN#		;ARE WE COPYING FROM A PACKET BUFFER
	BLO	16$			;NO, CONTINUE AS USUAL
	CMP	R2,PKTBND#		;ARE WE SURE THIS IS A PACKET
	BHI	16$			;NOT A PACKET
	MOV	-100(R2),R2		;POINT TO NEXT PACKET
	ADD	#PKDATA,R2		;POINT TO DATA PART OF PACKET
16$:	SOB	R0,EXPSPR
20$:	SUB	#SUPBUF,R1		;CALCULATE NUMBER OF BYTES IN BUFFER
	MOVB	R1,SUPBUF		;SAVE COUNT	
	RETURN
	.PAGE
; SPECIALIZED MESSAGE SENDING ROUTINES

;SNDACT - SEND ACCOUNTING TO SUPERVISOR

SNDACT:	POP	R0			;GET RETURN ADDRESS
	MOV	#SUPMSG,R1		;POINT AT SUPERVISOR MESSAGE BUFFER
	MOV	#^H8914,(R1)+		;FORM ACCOUNTING MESSAGE HEADER
	POP	SUPMSG+4
	POP	(R1)			;GET SUPMSG+2
	SWAB	(R1)+			;PUT IN ENGINE ORDER
	SWAB	(R1)+			;PUT IN ENGINE ORDER
	PUSH	R0
	MOV	#6,R0			;SET UP COUNT
	BR	SNDSPR			;GO SEND OFF MESSAGE

;	SNDNED	- SEND NEEDLE POINT OVER ANY CHANNEL

;	SAME CALLING SEQUENCE AS SNDSPR EXCEPT
;		R0 = DATA COUNT
;		R1 = CHANNEL TO SEND OVER
;		R2 = POINTER TO MESSAGE SOURCE
;		R3 = LDB OF DEST
;	RETURNS ON ERROR
;	SKIP RETURN IF EVERY THING OK

SNDNED:	PUSH	R3			;SAVE THESE REGISTERS LIKE SNDSPR
	PUSH	R2
	MOVB	R1,SUPBUF+1		;SAVE THE CHANNEL NUMBER
	MOV	#^H1003,SUPBUF+2	;PUT IN NEEDLE POINT
	MOV	#SUPBUF+6,R1		;POINT TO DESTINATION (SAVING ROOM FOR COUNT
	MOV	(R2)+,(R1)+		;COPY OVER LINK COUNT UN EXPANDED
	CALL	EXPSPR			;EXPAND DATA STRING
;	CMP	R1,#56.			;COMPARE WITH MAX LENGTH
;	BHI	SNDRET			;TOO LONG TO SEND
	ADD	#2,4(SP)		;SET UP SKIP RETURN
	MOV	R1,R0			;COPY STRING LENGTH
	SUB	#2,R1			;COUNT CONTIAINS CHANNEL AND LRECL
	SWAB	R1			;REORDER
	MOV	R1,SUPBUF+4		;STORE COUNT IN NEEDLE POINT
	BR	SNDSP1
	.PAGE

	.SBTTL	BRKCIR - BREAK CONNECTION BETWEEN SDB AND LINE

;SUBROUTINE TO BREAK THE CONNECTION BETWEEN A CHANNEL ON A TYMNET LINE AN AN SDB
;	C(R0) = REASON CODE (ONLY IF BASE SUPPORT)
;	C(R4) = ADDRESS OF DDB
;	C(SD) = ADDRESS OF SDB
;	CALL	BRKCIR

BRKCIR::
.IF EQ ..SAT
	TBBE	$I1AUX!$I1INC,SDLIS1#(SD),CLRCIR;If this connection is from a
						;  terminal
	TBBN	$I1AUX,SDLIS1#(SD),BRKCR4;IF AUX CIRCUIT
	CALL	ACOUNT			;INCOMING CIRCUIT-SEND THE ACCOUNTING
					;  DATA
BRKCR2:	MOV	#RPTCNT,R1		;CLEAR ACCOUNTING TIMER
	CALL	TIMKIL#
	MOV	#RPTCN1,R1		;CLEAR ACCOUNTING TIMER
	CALL	TIMKIL#
BRKCR4:	CLR	SDLIVL#(SD)		;CLEAR THE INVOICE NUMBER
	CLR	SDLIVH#(SD)
.ENDC
CLRCIR::
.IF EQ ..SAT
	MOV	SDLISC#(SD),R1		;ANY PACKETS SAVED?
	BEQ	16$			;NO
	CLR	SDLISC#(SD)		;YES-CLEAR POINTER
12$:	PUSH	(R1)			;SAVE NEXT ONE
	FREPKT				;GIVE UP THIS ONE
	POP	R1			;GET NEXT
	BNE	12$			;IF MORE
.ENDC
16$:	PUSH	R3			;Save current LDB
	MOV	SDLILD#(SD),R3		;Get LDB for this socket
	BNE	20$			;Go on if have one
	CMP	#-1,SDLKLK#(SD)		;None-make sure not in send list!
	BEQ	34$			;OK
	FSTOP	BSL			;[Bad Send List]

20$:	CLR	SDLILD#(SD)		;UNLINK
	MOVB	SDLICN#(SD),R0		;GET CHANNEL NUMBER
	ASL	R0			;FIND ADDRESS OF LINK TO SDB
	ADD	LDISDB#(R3),R0
	CMP	(R0),SD			;FOR DEBUGGING!
	BEQ	22$
	FSTOP	ISD			;[Incorrect SDB Address]

22$:	CLR	(R0)			;UNLINK
	CMP	#-1,SDLKLK#(SD)		;IS THIS SDB IN THE SEND LIST?
	BEQ	34$			;NO-FINISHED
	PUSH	R2			;YES-FREE UP ANOTHER AC
	MOV	#LDIXLH#,R0		;MAKE DUMMY PRED. POINTER
	SUB	#SDLKLK#,R0
	ADD	R3,R0
25$:	MOV	SDLKLK#(R0),R2		;GET NEXT IN LIST
	CMP	R2,SD			;THIS ONE?
	BEQ	26$			;YES
	MOV	R2,R0			;NO-CONTINUE SEARCHING
	BNE	25$			;IT MUST BE ON THE LIST!!
	FSTOP	BSL			;[BAD SEND LIST]

26$:	MOV	SDLKLK#(SD),SDLKLK#(R0)	;REMOVE FROM LIST
	BNE	30$			;GO ON IF THIS WAS NOT LAST IN LIST
	TST	LDIXLH#(R3)		;LAST-WAS IT THE ONLY ONE?
	BNE	27$			;NO
	CLR	R0			;YES-CLEAR POINTER
27$:	MOV	R0,LDIXLT#(R3)		;UPDATE TAIL POINTER
30$:	MOV	#-1,SDLKLK#(SD)
	POP	R2			;RESTORE R2
34$:	CLR	SDLIS1#(SD)		;CLEAR THE SOCKET STATUS WORD
	POP	R3			;Restore LDB address
	MOV	(SP),SDDBUG#(SD)	;Save return address to help find *'s
	RETURN				;FINISHED
	.PAGE
	.SBTTL	ACOUNT - SEND ACCOUNTING DATA TO SUPERVISOR

;SUBROUTINE TO SEND ACCOUNTING MESSAGES TO SUPERVISOR TO REPORT CHARACTER COUNTS
;	C(R0) = REASON CODE
;	CALL	ACOUNT

.IF EQ ..SAT

ACOUNT:	CALL	SPRINV			;SEND INVOICE NO# IF NECESSARY
	 RETURN				;CONDITIONS FOR SENDING REST OF ACCOUNTING NOT RIGHT

;HERE IF HAVE NON-ZERO INVOICE NUMBER

	PUSH	R0			;SAVE REASON
	MOV	SDLII2#(SD),R0		;GET HIGH PART OF INPUT CHARACTER COUNT
	BIC	#170000,R0
	BIS	#.S7ICC*10000,R0	;PUT IN MESSAGE SUB-TYPE
	PUSH	R0			;SR2
	PUSH	SDLII1#(SD)		;SR3
	CALL	SNDACT			;SEND INPUT CHARACTER COUNT TO SPR
	MOV	SDLIO2#(SD),R0		;GET HIGH PART OF OUTPUT CHARACTER COUNT
	BIC	#170000,R0
	BIS	(SP)+,R0		;PUT IN MESSAGE SUB-TYPE
	PUSH	R0			;SR2
	PUSH	SDLIO1#(SD)		;SR3
	CALL	SNDACT			;SEND OUTPUT CHARACTER COUNT TO SPR
	RETURN				;!!! DO NOT CHANGE TO CJMP !!!

;SEND INVOICE NUMBER TO SUP ACCOUNTING

SPRINV:: TST	DDLIUP#(R4)		;Do we have an upstream line?
	BEQ	2$			;No-forget this stuff!
	PUSH	R0			;PRESERVE R0
	MOV	SDLIVH#(SD),R0		;GET HIGH PART OF INVOICE NUMBER
	BNE	4$			;GO ON IF NON-ZERO
	TST	SDLIVL#(SD)		;ZERO-IS IT ALL ZERO?
	BNE	4$			;NO-GO ON
	POP	R0
2$:	RETURN				;AND FORGET ABOUT THIS!

;HERE IF HAVE NON-ZERO INVOICE NUMBER

4$:	CMP	R0,DDLIVH#(R4)		;IS THIS THE PREVIOUS INVOICE NUMBER SENT?
	BNE	6$			;NO
	CMP	SDLIVL#(SD),DDLIVL#(R4)	;MAYBE - IS THE PART THE SAME
	BEQ	10$			;YES, SKIP SENDING INVOICE AGAIN
6$:	MOV	R0,DDLIVH#(R4)		;INDICATE THIS WAS THE LAST INVOICE SENT
	MOV	SDLIVL#(SD),DDLIVL#(R4)
	BIC	#177400,R0		;CLEAR UPPER BYTE
	BIS	#.S7INV*10000,R0	;PUT IN INVOICE MESSAGE SUB-TYPE
	PUSH	R0			;SR2 (UPPER 16 BITS OF INVOICE)
	PUSH	SDLIVL#(SD)		;SR3
	CALL	SNDACT			;SEND INVOICE NUMBER TO SUPERVISOR
10$:	POP	R0
	ADD	#2,(SP)			;SUCCESS RETURN
	RETURN

.ENDC
	.PAGE
	.SBTTL	CLRSPR - CLEAR SUPERVISOR MESSAGE LIST FOR LINE

;SUBROUTINE TO CLEAR OUT THE SUPERVISOR MESSAGE LIST FOR A LINE
;	C(R3) = ADDRESS OF LDB
;	C(R4) = ADDRESS OF DDB
;	CALL	CLRSPR

CLRSPR:	MOV	LDISLH#(R3),R1		;GET HEAD POINTER
	BEQ	RTN012			;NOTHING TO DO IF LIST IS EMPTY
2$:	BIC	#77,R1			;POINT TO BEGINNING OF PACKET
	PUSH	(R1)			;SAVE LINK
	FREPKT				;GIVE UP THE PACKET
	POP	R1			;GET NEXT PACKET
	BNE	2$			;CONTINUE IF MORE TO GIVE UP
	CLR	LDISLH#(R3)		;FINISHED-CLEAR HEAD AND TAIL POINTERS
	CLR	LDISLT#(R3)
RTN012:	RETURN				;THATS ALL
	.PAGE
	.SBTTL	QUEZAP - QUEUE REQUEST FOR CIRCUIT ZAPPER

;SUBROUTINE TO QUEUE A CIRCUIT ZAPPER FOR A CHANNEL NOT ASSOCIATED WITH A SDB
;	C(R0) = CHANNEL NUMBER
;	C(R3) = ADDRESS OF LDB
;	CALL	QUEZAP
;  R2 IS DESTROYED
.IF NE	0
QUEZAP:	ASL	R0			;GET CHANNEL * 2
	MOV	LDIZLT#(R3),R2		;LIST ENTRIES ARE CHANNEL*2+1 AND ARE
	BEQ	4$			;  LINKED THRU THE LDISDB TABLE
	ADD	LDISDB#(R3),R2
	MOV	R0,(R2)
	INC	(R2)
	BR	5$

4$:	MOV	R0,LDIZLH#(R3)
5$:	MOV	R0,LDIZLT#(R3)
	RETURN
.ENDC

;Subroutine to get reserve packet
;	CALL	LKIRPK
;	C(R1) = Address of packeet

LKIRPK:	MOV	LKIPPK,R1		;Get address of reserve packet
	BNE	4$			;OK if have one
	MAKPKT	.PLSTP			;Try to get one
	BCC	4$			;Got it
	FSTOP	NRP			;[No Reserve Packet] This should never
					;  happen since this routine is never
					;  called more than once for each
					;  supervisor record!

4$:	CLR	LKIPPK			;Clear pointer
	RETURN				;And return
	.PAGE
	.SBTTL	PUTNUM - PUT OCTAL NUMBER INTO PACKET AS STRING

;SUBROUTINE TO CONVERT OCTAL NUMBER TO STRING AND STORE STRING IN A PACKET
;	C(R0) = NUMBER TO CONVERT LEFT JUSTIFIED
;	C(R1) = ADDRESS OF START OF PACKET
;	C(R3) = NUMBER OF CHARACTERS TO CONVERTS
;	C(R4) = POINTER FOR STORING CHARACTERS
;	CALL	PUTNUM
;	C(R4) = UPDATED POINTER

PUTNUM:	ROL	R0			;GET HIGH ORDER BIT INTO C
4$:	ROL	R0			;GET NEXT OCTAL DIGIT IN LOW 3 BITS
	ROL	R0
	ROL	R0
	BIT	#7,R0			;IS IT NON-0?
	BNE	6$			;YES-GO ON
	SOB	R3,4$			;NO-CONTINUE IF NOT LAST DIGIT
6$:	MOVB	R0,(R4)			;STORE DIGIT
	BICB	#370,(R4)		;CHANGE INTO ASCII NUMBER
	BISB	#'0,(R4)+
	ROL	R0			;GET NEXT DIGIT
	ROL	R0
	ROL	R0
	DEC	R3			;MORE TO DO?
	BGT	6$			;YES-CONTINUE
	RETURN				;FINISHED
	.PAGE
	.SBTTL	LKIUP  - UP A TYMSHARE LINK

LKIUP::	MOV	LDIDDB#(R3),R4		;Get address of DDB
	BIC	#$D1DWN,DDSTS1#(R4)	;INDICATE DEVICE IS UP (SORT OF)
	TBBE	$L1DWN,LDIST1#(R3),10$	;IS THE LINE ALREADY UP?
	BIC	#$L1DWN,LDIST1#(R3)	;INDICATE LINE IS UP NOW
	INCB	DDLINU#(R4)		;INCREASE COUNT OF UP LINES
10$:	CJMP	SNDSPD			;Send speed message to sup
	.PAGE
	.SBTTL	LKIDWN - DOWN A TYMSHARE LINK

;THIS SUBROUTINE DOES MUCH THE SAME THING AS LNKDWN IN LNK BUT CANNOT USE LNKDWN
;  SINCE IT WOULD DOWN THE ENTIRE LINK - HERE WE JUST WANT TO KILL THOSE
;  CONNECTIONS ASSOCATIATED WITH ONE OF OUR LINES
;
;	C(R0) = Error code
;		1 = No good records received on line
;		3 = Reset received
;		4 = BORI zap (line snip or sup command)
;	C(R3) = Address of LDB for line
;	CALL	LKIDWN

LKIDWN:: PUSH	R0			;Save error code
	MOV	LDIDDB#(R3),R4		;Get address of DDB
	CALL	CLRSPR			;Clear the supervisor list for this line
	CMP	DDLIUP#(R4),R3		;Was this the upstream line?
	BNE	5$			;No
	CLR	DDLIUP#(R4)		;Yes-don't have an upstream line now!
	CLRB	DDLISN#(R4)
	CALL	CLRSUP			;Clean up any connection waiting for the
					;  supervisor and tell other neighbors
	MOV	DDSUSD#(R4),SD		;Get the SDB for the supervisor link
	CALL	CLRCIR			;Clean up our side
	CALL	FRESOC#			;No need to send kill or anything
	BR	56$			;Finish up
5$:	MOV	(SP),R0			;Get the error code
	CMP	#5,R0
	BLOS	56$			;Skip if someone forgot to set up R0
	SWAB	R0			;Put code in second byte of message
	BIS	#.SMCLC+<^H8000>,R0	;SET IN SUP MESSAGE AND ERROR CODE
	MOV	R0,SUPMSG
	MOVB	LDILNO#(R3),R0		;Get line number
	BIS	#^H8080,R0		;Put in escape bits
	MOV	R0,SUPMSG+2
	MOV	LDINBR#(R3),R0		;Get neighbor node
	BIS	#^H8000,R0		;Put in escape bit
	SWAB	R0			;Put bytes into SUP order
	MOV	R0,SUPMSG+4		;Put in neighbor number	
	MOV	#6,R0			;Set up count
	CALL	SNDSPR			;Send off to the sup
56$:	CLR	LDIZLH#(R3)		;Clear the zap list head and tail
	CLR	LDIZLT#(R3)		;  pointers
	CLR	LDISPC#(R3)		;Clean up defered processing flag
	POP	R0			;Clean up stack
.PAGE
;Now disconnect all circuits using this line

	MOV	LDISDB#(R3),R0		;Point to SDB list
	PUSHB	LDICHN#(R3)		;Get number of lines
10$:	MOV	(R0),SD			;Get SDB
	BEQ	20$			;Go on if none
	BIT	#1,SD			;Really a SDB?
	BNE	20$			;No
	PUSH	R0			;Yes-save pointer
.IF EQ ..SAT
	MOV	#.S7OCU*10000!.ERSPR,R0	;Get reason for zap
.IFF
	CLR	R0
.ENDC
	CALL	KILSUB			;Kill the connection
	POP	R0
20$:	CLR	(R0)+			;Make sure SDB table entry is clear
	DECB	(SP)			;More to do?
	BNE	10$			;Yes-continue
	TST	(SP)+			;No-fix up the stack
	MOV	LDIDDB#(R3),R4		;Get address of DDB
	TBBN	$L1DWN,LDIST1#(R3),30$	;Already down - skip this if so
	BIS	#$L1DWN,LDIST1#(R3)	;Indicate this line is down
	DECB	DDLINU#(R4)		;Reduce count of up lines
	BGT	30$			;Go on if still have line(s) up
	BIS	#$D1DWN,DDSTS1#(R4)	;Declare the device to be down
	CLRB	DDLINU#(R4)		;Just to be safe!!
30$:	CJMP	@LDIDWX#(R3)		;Return thru the frame level routine


;Subroutine called from LKIDWN to kill a connection
;	C(R0) = Supervisor message type + Nexilis error code
;	CALL	KILSUB

KILSUB:	PUSH	R1			;Respect R1
	PUSH	R0			;Save Nexilis error code
	BIC	#377,R0			;Remove junk
	CALL	BRKCIR			;Break the circuit to Tymnet
	POPB	R0			;Restore Nexilis error code
	CALL	MAKKIL#			;Make a Kill packet
	CALL	LKISPK			;Send the kill packet
	POP	R1			;Restore R1
	RETURN				;And return
	.PAGE
	.SBTTL	Data

;Impure data

	IMPURE
	.EVEN

REQCNT:	.WORD	0		;REQUEST COUNTER
LKIPPK:: .WORD	0		;Address of reserve packet
SUPTOD:	.BLKW	2		; SUP GMT
SUPNOD:: .WORD	0		;AREA TO PLACE NODE NUMBER + 8000
SUPBUF:	.BLKB	32.		; SUP MESSAGE BUILD AREA
SUPMSG:: .BLKB	64.		; SUP MESSAGE BUILD AREA (LONG ENOUGH FOR
				;  LONGEST POSSIBLE NEEDLE)
SUPEND:

;Pure data

	PURE
	.EVEN			;Make sure its even!!!

	.END

  - MX