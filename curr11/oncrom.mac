	.TITLE	ONCROM   - ONCE-ONLY ROUTINES

	XLPAR				;DON'T LIST PARAMETER FILE


	.SBTTL	ONCROM   - ONCE-ONLY ENTRY POINTS

	.PSECT	ONCE,RW,I,LCL,REL,CON



; ENTRY POINT FOR ONCE-ONLY


ONCXDT::!

;NORMAL ENTRY POINT FOR ONCE-ONLY - GET HERE FROM THE JMP INSTR IN LOCATION 400

ONCNRM::!
ONCE0:	RESET				;RESET THE WORLD
	MOV	#STKBGN#,SP		;SET STACK POINTER
	CMP	#174000,#CTYRBF#	;Is this a FALCON board
	BEQ	45$			;EQ, NO
	JMP	DIAME2			;ELSE, YES, DON'T DO SCC DIAGNOSTIC
45$:	CALL	SETCTY			;GO SET CONSOLE BAUD RATE
	JMP	DIASCC			;BEGIN DIAGNOSTIC

; HERE ARE SOME SUBROUTINES TO OUTPUT DIAGNOSTIC MESSAGES
GOODM:	.ASCIZ	<CR><LF><LF>" RAM DIAGNOSTIC OK    "
BM1:	.ASCIZ	<CR><LF><LF>" BAD   RAM   AT   "
BM2:	.ASCIZ	<CR><LF>" EXPECTED  VALUE= "
BM3:	.ASCIZ	<CR><LF>" ACTUAL    VALUE= "
BSCC:	.ASCIZ	<CR><LF>" BAD SCC AT "
NESCC:	.ASCIZ	<CR><LF>" NONEXISTENT SCC AT "
NESCC1:	.ASCIZ	" , CHANNEL IS DISABLED    "
INVNN:	.ASCIZ	<CR><LF>" INVALID NODE NUMBER     "
	.EVEN
DIABA1:					;BAD MEMORY ENTRY
	MOV	R1,R2			;SAVE EXPECTED VALUE
	BR 	DIABA2			
DIABAD:					;BAD MEMORY  ENTRY
	MOV	@R0,R2			;SAVE EXPECTED VALUE
DIABA2:
	MOV	@R1,R3			;SAVE ACTUAL    VALUE
	PUSH	R1			;SAVE BAD ADDRESS
	MOV	#BM1,R1			;TYPE BAD RAM AT
	CALL	CTYSTR#			;OUTPUT A STRING
	POP	R1			;RESTORE R1
	CALL	CTYOCT#			;OUTPUT THE ADDRESS BAD
	MOV	#BM2,R1			;TYPE EXPECTED VALUE=
	CALL	CTYSTR#			;OUTPUT  A STRING
	MOV	R2,R1			;GET EXPECTED VALUE
	CALL	CTYOCT#			;OUTPUT IT
	MOV	#BM3,R1			;TYPE ACTUAL    VALUE
	CALL	CTYSTR#			;OUTPUT  A STRING
	MOV	R3,R1			;GET ACTUAL    VALUE
	CALL	CTYOCT#			;OUTPUT IT
	BR	.			;HALT THE SYSTEM
SCCSHW:	MOV	#SCCINI,R2		;POINT TO INITAILIZATION SEQUENCE
	PUSH	#INILEN
10$:	MOVB	(R2)+,6(R0)
	MOVB	(R1)+,6(R0)		;SET BITS IN THE HARDWARE
	DEC	(SP)
	BGT	10$			;CONTINUE IF MORE TO GO
	TST	(SP)+			;Clear the stack
	RETURN
SCCIN:				;INPUT ONE BYTE(R1) FROM SCC CHANNEL(R0)
	PUSH	R2
	CLR	R2
1$:	TBBN	1,4(R0),2$		;MAKE SURE RX AVAILABLE
	SOB	R2,1$
2$:	MOVB	@R0,R1			;INPUT ONE BYTE
	POP	R2
	RETURN
SCCOUT:				;OUTPUT ONE BYTE(R2) TO SCC CHANNEL(R0)
	PUSH	R1
	CLR	R1
1$:	TBBN	4,4(R0),2$		;MAKE SURE TX BUFFER EMPTY
	SOB	R1,1$
2$:	MOVB	R2,2(R0)		;OUTPUT R2
	POP	R1
	RETURN
SETCTY:					;SET CONSOLE TO 300 BAUD
	MOV	#CTYRBF#,R0		;RCV BUFFER REGISTER
	CALL	SCCRST#			;Reset the channel
	MOV	#ASGRAT,R1		;POINT TO FIRST ENTRY IN TABLE
	CALL	SCCSHW			;SET SCC HARDWARE
	RETURN
; HERE FOR SCC DIAGNOSTIC
DIASCC:					;Test SCC
	MOV	#SCCTBL,R3		;R3 POINTS TO SCCTBL
1$:	MOV	(R3)+,R0		;GET THE RCV DATA REG. ADDRESS
	BEQ	DIAMEM			;EQ, means all done
	CLRB	6(R0)			;--KSB2, MAKE SURE SCC IN GOOD MOOD
	MOV	#9.,6(R0)	;--US01
	CLR	6(R0)		;--US01, make sure vector not includes status
	MOVB	#2,6(R0)		;POINT TO WR2 FOR WRITING VECTOR
	MOVB	#246,6(R0)		;PICK 246 AS VECTOR
	MOVB	#2,6(R0)		;RR2 FOR READING VECTOR
;	CMPB	#246,4(R0)		;SAME VECTOR?
	MOVB	4(R0),R2		;--KSA4, GET VECTOR BACK
;	CMPB	#246,R2			;--KSA4SAME VECTOR?
;	BEQ	2$			;EQ, SCC EXISTS, GO ON
	TBBN	240,R2,2$	;--US11, ANY BIT SET IN VECTOR -> SCC EXISTS
	MOV	#NESCC,R1		;R1 POINT TO OUTPUT MESSAGE
;+--KSA4
;	BR	4$			;GO SCC ERROR ROUTINE
	PUSH	R0			;RESPECT R0
	CALL	CTYSTR#			;TO CONSOLE
	POP	R1			;GET ADDRESS OF BAD CHANNEL
	CALL	CTYOCT#			;OUTPUT THE ADDRESS
	CLR	R1
	BISB	R2,R1
	CALL	CTYOCT
	MOV	#NESCC1,R1	;--US11, DISPALY "CHANNEL DISABLED"
	CALL	CTYSTR#		;--US11
	BR	1$			;NEXT CHANNEL
;---KSA4
2$:	CALL	SCCRST#			;RESET CHANNEL
	MOV	#ASGDIA,R1		;POINT TO FIRST ENTRY IN TABLE
	CALL	SCCSHW			;SET SCC HARDWARE
	CLR	R2			;PREPARE TO OUTPUT 255 TO 0
3$:	DECB	R2			;
	BEQ	1$			;EQ, THIS CHANNEL IS GOOD
	CALL	SCCOUT			;OUT ONE BYTE IN R2
	CALL	SCCIN			;INPUT ONE BYTE TO R1
	CMPB	R1,R2			;SHOULD BE EQUAL?
	BEQ	3$			;EQ, CONTINUE, NEXT BYTE
;
;HERE SCC HAS ERROR
	MOV	#BSCC,R1		;OUTPUT SCC ERROR MESSAGE
4$:	PUSH	R0			;RESPECT R0
	CALL	CTYSTR#			;TO CONSOLE
	POP	R1			;GET ADDRESS OF BAD CHANNEL
	CALL	CTYOCT#			;OUTPUT THE ADDRESS
	BR	1$			;NEXT CHANNEL
DIAB91:	JMP	DIABA1
DIABA9:	JMP	DIABAD


; HERE FOR RAM DIAGNOSTIC

DIAMEM:					;DIAgnostic memory
	CALL	SETCTY			;GO SET CONSOLE BAUD RATE
DIAME2:	MOV	CRSCNT#,R3		;SAVE CRASH COUNT

; HERE CHECK ADDRESS
	MOV	#PKTBGN#,R1		;PKTBGN ALSO RAM STARTING ADDRESS
9$:
	MOV	R1,(R1)			;MOVE ADDRESS TO SELF
	TST	(R1)+			;INCREMENT BY 2
	CMP	#170000,R1		;RAM END ADDRESS
	BHI	9$			;HI, CONTINUE
	MOV	#PKTBGN#,R1		;RAM STARTING ADDRESS->R1
11$:
	CMP	R1,@R1			;MATCH?
	BNE	DIAB91			;NE, BAD MEMORY
	TST	(R1)+			;ADD 2
	CMP	#170000,R1		;RAM END ADDRESS
	BHI	11$			;HI, CONTINUE

; HERE CHECK PATTERNS
	MOV	#DIAPAT,R0		;PATTERN START->R0
	MOV	#DIASIZ,R2		;SIZE IN BYTE
	ASR	R2			;NOW IN WORDS
7$:
	MOV	#PKTBGN#,R1		;RAM STARTING ADDRESS->R1
5$:
	MOV	@R0,(R1)+		;MOVE THE PATTERN
	CMP	#170000,R1		;RAM END ADDRESS
	BHI	5$			;HI, CONTINUE
	MOV	#PKTBGN#,R1		;RAM STARTING ADDRESS->R1
3$:
	CMP	@R0,@R1			;COMPARE IT
	BNE	DIABA9			;NE, BAD MEMORY
	TST	(R1)+			;INCREMENT BY 2
	CMP	#170000,R1		;DON'T EXCEED RAM HIGH
	BHI	3$			;HI, NOT YET
	TST	(R0)+			;ELSE, NEXT PATTERN
	SOB	R2,7$			;LOOP UNTIL R2=0
	MOV	R3,CRSCNT#		;RESTORE CRASH COUNT

; HERE WE HAVE GOOD RAM
	MOV	#GOODM,R1		;LET EVERYBODY KNOW
	CALL	CTYSTR#			;DO CONSOLE OUTPUT

	SETPSW	#340			;MAKE SURE NO INTERRUPTS NOW
	MOV	#170000,R0		;GET HIGH END OF MEMORY
	MOV	#PDATND#,R1		;GET START OF MEMORY TO INITIALIZE
	SUB	R1,R0			;GET LENGTH OF INITAILIZED MEMORY
	ASR	R0			;CONVERT TO WORDS
2$:	CLR	(R1)+			;CLEAR PURE DATA AREA
	SOB	R0,2$
	CMP	#50,CRSCNT#		;CHECK CRASH COUNT
	BHI	4$			;BR IF REASONABLE
	CLR	CRSCNT#			;RESET IT OTHERWISE
4$:	MOV	#167400,R0		;ROM version starts at 167400
16$:	MOV	#4.,R3			;SETUP 4 GROUPS
	MOV	#TRPER0#,SD		;POINT TO ROUTINE FOR FIRST GROUP
20$:	MOV	#16.,R1			;SET COUNT


30$:	MOV	#137,(R0)+		;Store jump instruction
	MOV	SD,(R0)+		;Store address
	SOB	R1,30$			;Continue if more to set
40$:	ADD	#TRPERX#,SD		;POINT TO ROUTINE FOR NEXT GROUP
	SOB	R3,20$			;CONTINUE IF MORE TO DO

;FOLLOWING ROUTINE SETS UP ALL INTERRUPT VECTORS.  NO VECTORS ARE SET AT LOAD
;  TIME SO AS NOT TO MIX UP THE MONITOR!  INSTEAD A TABLE, "VECTBL" IS BUILT
;  WHICH SPECIFIES EACH INTERRUPT VECTOR.  THIS TABLE CONTAINS WORD TRIPLETS
;  WITH THE FIRST WORD CONTAINING THE LOCATION OF THE VECTOR AND THE SECOND
;  THE ADDRESS OF THE INTERRUPT ROUTINE FOR THE VECTOR.  THE THIRD WORD
;  CONTAINS THE PRIORITY LEVEL FOR THE INTERRUPT.

44$:	MOV	#VECTBL#,R1		;SET POINTER
	MOV	#167402,R2		;Yes-get offset for "soft" vectors
SETVEC:	MOV	(R1)+,R0		;GET LOCATION OF VECTOR
	ADD	R2,R0			;Add in the offset
	MOV	(R1)+,(R0)+		;STORE ADDRESS OF INTERRUPT ROUTINE
	MOV	(R1)+,R3		;Get interrupt level
2$:	CMP	#VECEND#,R1		;FINISHED?
	BNE	SETVEC			;NO-CONTINUE
					;YES
	.PAGE
	.SBTTL	ONCROM   - DETERMINE MEMORY SIZE

;THE FOLLOWING CODE DETERMINES THE AMOUNT OF MEMORY WE HAVE BY ATTEMPTING TO
;  READ THE WORD JUST BEYOND EACH 4K WORD BOUNDRY

MEMLOP:
	MOV	#PKTBGN#-10000,R3	;INITIALIZE POINTER
MEMLP1:	ADD	#10000,R3		;BUMP POINTER TO NEXT 2K BLOCK
	TST	(R3)			;TRY TO READ MEMORY
	NXMJMP	MEMTOP			;WHERE TO GO IF NO MORE MEMORY
	CMP	#160000,R3		;CHECK FOR END
	BHI	MEMLP1			;NOT YET

;GET HERE WHEN WE HAVE FOUND THE TOP OF MEMORY

MEMTOP:	SUB	#PKTBGN#,R3		;GET ACTUAL AMOUNT OF RAM SPACE
	ADD	#PDATA#-160100,R3	;ADD IN FALCON LOCAL MEMORY PACKET SPACE
	CLR	R2			;GET NUMBER OF PACKETS
	DIV	#PKTWDS*2,R2
	MOV	R2,NUMPKT#		;STORE IT FOR LATER
	.PAGE
; SCATTERLOAD INITIALIZATION INFO IN MEMORY
	
	MOV	#INIDAT#,R0		;Point to initilization data
10$:	CMP	R0,#INIDND#		;At end yet?
	BHIS	20$			;Yes
	MOV	(R0)+,@(R0)+		;Store data in address
	BR	10$

; DO BYTE DATA NEXT
20$:	MOV	#INIBYT#,R0
30$:	CMP	R0,#INIBND#		;Are we at the end yet
	BHIS	40$			;Yes
	MOV	(R0)+,R1		;Get the data
	MOVB	R1,@(R0)+		;Move data byte to destination
	BR	30$
40$:

;	here for possible timer setup

	CMP	#174000,#CTYRBF#	;Is this a FALCON board
;	BNE	STRT4			;Yes, don't initialize the CIO
	BEQ	45$
	JMP	STRT4			;Yes, don't initialize the CIO
45$:	TST	177014			;Read the csr to make sure we are
					;in reset state or state zero
	CLR	177016			;Now we are in state 0 or 1
	TST	177014			;now we are for sure in state 0
	MOV	#CIOINI,R0		;Point to initilization block
	MOV	#CIOLEN,R1
50$:	MOVB	(R0)+,177016		;Send bytes of control info to CIO
	SOB	R1,50$
	CLR	R1
	BISB	177000,R1		;Get port C
	ASR	R1			;Shift off C0
	SWAB	R1			;Put msb bits in highest part
	BISB	177004,R1		;Get port B
	COM	R1			;Uninvert bits
	ASL	R1
	ASL	R1			;Get two msb to high byte
	MOV	R1,R3			;Copy
	SWAB	R1			;Get 4 highest bits to low part
	BIC	#^C17,R1		;Four highest bits
	MUL	#1000.,R1		;Calculate msb
	ASL	R3			;Copy B5 bit to bit 8 in R3
	ROLB	R3			;Move unconnected B4 to carry
	ASHI	-5,R3			;Position to extract 4 bits
	BIC	#^C17,R3		;Get low 4 bits
	MUL	#100.,R3		;Calculate value
	ADD	R3,R1			;Accumulate result
	MOVB	177010,R0		;Get port A data
	COM	R0
	MOV	R0,R3		
	ASHI	-4,R3			;Position high 4 bits
	BIC	#^C17,R3
	MUL	#10.,R3			;Calculate value
	ADD	R3,R1			;Accumulate result
	BIC	#^C17,R0
	ADD	R0,R1
	CMP	#16665.,R1		;Were all the bits on?
	BEQ	53$			;Yes, skip saving away
	BIS	#^H8000,R1		;Turn on high bit
	SWAB	R1			;Put bits in correct order for KERHST
	MOV	R1,KERHST#
	MOV	R1,THOST#		;Update terminal host number
53$:	MOV	#341,177002		;Write to port C
	MOV	#LKIDDB#,R0		;Point to link I DDB
	CLR	R1
	BISB	177004,R1		;Get port B
	ASRB	R1			;Shift off PB0
	SWAB	R1			;Put bytes in correct halves
	BISB	177010,R1		;Get port A data
;	BEQ	STRT3			;Skip all this if zeros
;	BIT	#10000,R1		;Was the high bit on
;	BEQ	54$			;No
;	BIS	#4000,R1		;Yes, put in proper place
54$:	COM	R1			;Compliment bits
;	BIC	#170000,R1		;Clear out any junk
;+--V1.20 MAKE NODE NUMBER TO 14 BITS, I.E. FROM 2010 TO 37777
	MOV	R1,R3		;R1,R3=XBBBXBBBAAAAAAAA
	BIC	#107777,R3	;   R3=0BBB000000000000
	ASR	R3		;   R3=X0BBB00000000000
	BIC	#174000,R1	;R1,  =00000BBBAAAAAAAA
	BIS	R3,R1		;R1,  =X0BBBBBBAAAAAAAA
	BIC	#100000,R1	;R1,  =00BBBBBBAAAAAAAA
;	BEQ	STRT3			;Skip if nothing in switches
	CMP	R1,#2010		;See if legal node number
;	BLO	STRT3			;Not legal if less than 2010
	BLO	ILLNN		;NOT LEGAL IF LESS THAN 2010
	MOV	R1,DDLINN#(R0)		;Yes, save node number
;STRT3:
	MOV	DDLINN#(R0),R1		;Get the node number
;	MOV	#4,R0			;Form count of digits
	MOV	#5,R0			;Form count of digits
	MOV	#THSNOD#,R2		;Point to result array
;	ASHI	4,R1			;Shift off junk
	ASL	R1			;Shift off junk
60$:	CLR	R3			;Clear result reg
	ASL	R1			;Shift msb into carry
	ROL	R3			;Pickup msb
	ASL	R1			;Shift msb into carry
	ROL	R3			;Pickup msb
	ASL	R1			;Shift msb into carry
	ROL	R3			;Pickup msb
	BNE	62$		;NON ZERO, GO AHEAD TO CONVERT
	CMP	#5,R0		;ZERO, IS IT MSB?
	BEQ	64$		;EQ, MSB, BRANCH TO SUPPRESS ZERO
62$:	ADD	#'0,R3			;Convert  to ASCII
	MOVB	R3,(R2)+		;Deposit into name
64$:	SOB	R0,60$			;Continue

;HERE TO START NODE


STRT4:	CLR	CKSFLG#			;CLEAR CHECKSUM FLAG
	JMP	START#			;GO START THE NODE
ILLNN:	MOV	#INVNN,R1	;SET DIASNOSTIC MESSAGE ADDRESS
	CALL	CTYSTR#		;OUTPUT TO CONSOL PORT
	JMP	ONCE0		;DISPLAY FOREVER UNTIL NODE SWITCH RESET

	CODE
	VECTOR	110,CLKINT,7		;Set up vector for possible clock interrupt

CLKINT:	TST	177014			;MAKE SURE WE ARE OK
	MOVB	#14,177016		;point to register 14 in CIO
	MOVB	#46,177016		;Reset interrupt under service
	JMP	@100			;Continue processing interrupt

CODTOP::!				;HIGHEST LOCATION WHICH EVER CONTAINS
					;  CODE (USED IN ERROR FOR NXM CHECK)
	PURE
;	THIS IS THE CIO PROGRAM.  IT USERS COUNTER 3 AND PROGRAMS IT WITH A
;	COUNT OF 20480. (1.2288MHZ/60HZ).  THE EXTERNAL COUNT ENABLE IS 0 AND
;	THEREFORE THE INPUT IS ONE HALF OF THE CIO PCLK INPUT.
;	COUNTER 1 IS PROGRAMMED TO PROVIDE A "75 BAUD" (ACTUALLY 64*75) CLOCK
;	FOR 1200/75 SPLIT BAUD.

CIOINI:	.BYTE	0,1,0			;RESET CHIP AND RETURN TO STATE ZERO
	.BYTE	32,40.,33,0		;SET UP THE DOWN COUNTERS FOR CT3
	.BYTE	26,0,27,128.		;CT1
	.BYTE	36,202			;SET CONTINOUS TIMER MODE AND SQUARE
	.BYTE	34,302			;OUTPUT FOR CT3 AND CT1
	.BYTE	4,110			;SET INTERRUPT VECTOR TO 110
	.BYTE	43,377			;SET PORT A AS INPUT PORT
	.BYTE	53,356			;SET UP PORT B'S INPUT BITS
	.BYTE	6,16			;SET UP PORT C'S INPUT BITS
	.BYTE	1,327			;ENABLE COUNTER 1,2,3 AND PORTS
	.BYTE	14,306			;SET INTERRUPT ENABLE AND TURN ON CT3
	.BYTE	12,6			;TURN ON CT1
	.BYTE	0,200			;MASTER INTERRUPT ENABLE
CIOLEN=	.-CIOINI

	PURE
;SCCINI:	.BYTE	24,3,25,11.,12.,13.,3,5,14.
SCCINI:	.BYTE	23,25,24,11.,12.,13.,3,5,14.
INILEN=	.-SCCINI
	.EVEN
ASGRAT:	.BYTE	300,342,304,120		;--US01
	.WORD	<19200./300.>-2		; 7 =   300   BAUD, 8 BITS, 1   STOP BIT
	.BYTE	300,352,203			;enable tx, set clock, baud source
	.EVEN
ASGDIA:	.BYTE	300,342,104,120		;--US01
	.WORD	<19200./<19200./4>>-2	;19200 BAUD, 8 BITS, 1 STOP BIT
	.BYTE	301,352,223		;LOCAL LOOPBACK MODE
	.EVEN
DIAPAT:					;RAM DIAGNOSTIC PATTERNS
	.BYTE	360,017
	.BYTE	155,222
	.BYTE	044,333
	.BYTE	125,377
	.BYTE	000,232
	.BYTE	000,000
DIASIZ=.-DIAPAT
	.EVEN
SCCTBL:	.WORD	174010
	.WORD	175000,175010
	.WORD	176000,176010
	.WORD	170000,170010
	.WORD	171010,171000
	.WORD	174000
	.WORD	0
	.EVEN
	.ASECT
.=	0
	RSTOP	BRZ

ADDR=	167404
COND=	1
	.REPT	4
	.WORD	ADDR
	.WORD	340+COND
ADDR=	!ADDR+4
COND=	!<COND+1>&17
	.ENDR

	.WORD	ONCXDT			;Power down/up vector
	.WORD	340

ADDR=	!ADDR+4
COND=	!<COND+1>&17
	.REPT	73

	.WORD	ADDR
	.WORD	340+COND
ADDR=	!ADDR+4
COND=	!<COND+1>&17
	.ENDR
COPNOT:	.ASCII	/COPYRIGHT 1983, TYMSHARE INC., CUPERTINO CA./
.=	500	;PUT A NOTICE IN EACH ROM
	.ASCII	/CCOOPPYYRRIIGGHHTT  11998833,,  /
	.ASCII	/TTYYMMSSHHAARREE  IINNCC..,,  CCUUPPEERRTTIINNOO  CCAA../

	.END
