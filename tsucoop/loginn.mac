tymspc==70	;major release no.
tymrel==1	;bugfix no.

define titl(ts,tr)<
title LOGINN version ts'.'tr
vcompil=<ts,,tr>>

titl(\tymspc,\tymrel)

subttl for p030 & later. wfw/ag/aaa/wrs/JMS

if2 <printx	License needed: OP SY ST HF JL RF>
if2 <printx	See/update (OSU:930)LOGINN.INF history of this program>
		;Need to eliminate all USETI,USETO,INPUT,OUTPUT calls

	loc	<JOBVER=137>
	exp	vcompile
	reloc

	twoseg
	reloc	400000

define lvar<
	reloc
	var
	reloc
>



;parameters	from commod.mac

ribppn==1
ribnam==2
ribext==3
ribprv==4
ribsiz==5
ribalc==11
ribqtf==22
ribqto==23
ribqtr==24
ribusd==25
ribaut==26
ribunm==27
ribsts==17
  ripbda==1
  ripcrh==4
  ripbfa==10
  riphre==100
  riphwe==200
  ripbdr=2000
  riplog==400000
  ripdir==400000

devnam==0
prv.rd==4	; rd protection code

;end of parameters from commod.mac

intern vcompil,jobver,p,calc,T1,T2,T3

deb==0		;debug switch: 0 production, 1 debug

sysgan==3	;gan for system development users
sysres==3	;number of jobs to reserve for sys dev.
;ac assignments

f=0	;flags
T1=1	;4 acs for lookups and general work
T2=2
T3=3
T4=4
T5=5	;temp
calc=6	;for accounting
r=7	;for radix print
m=10	;message addresses
bp=11	;byte pointer
pp=12	;project programmer pair
n=13	;numbers in or out
n1=14	;n+1 for radix print
ch=15	;characters
WD=16	;words
P=17	;pushdown pointer

;io channels

ufd==2	;for disk io
usr==3	;for checking user files
us1==4	;these two used by ufdset
msg==5  ;for access.msg (wrs)
pasio==7;for password checking
;flags - lh of f

fl.sts==1		;user has status (! before name) shut override
  s.shov==1	;shut override set flag in stmdat+5
fl.npt==2		;do not prompt for proj code (; in input)
l.pend==4		;on for not a new structure
f.dett==10		;there are detached jobs
f.bcast==20		;broadcast letter(s) waiting
f.mor==40		;more job slots available
fl.rst==100	;system is restricted
fl.fuf==200	;this is the first ufd processed
f.deT2==400	;in attach code used to distinguish 1 from
		;more than 1 available job to attach to.
f.gem==1000	;in lokmal, tells where to look for mail
		;in case user is gemode (japan)
f.ejob==2000	;a job exists already under this aun
f.onej==4000	;LUD says he can have only one job logged
		;in at a time.
f.nopjc==10000	;LUD said not to ask this user for a proj code
fl.pass==20000	;do not prompt for password(ks)
f.half==40000	;half duplex flag

comment ! fl.fuf used in ufdset to cause "tru limit exceeded"
to come out on return in fs1 from ufdset. most routines in ufdset
tlz fl,fl.fuf if they are Sreturning; or if they Freturn,
they have already printed some message.
!

subttl	OPDEFs and such

OPDEF	PJRST	[JRST]		;Equivalent to PUSHJ + POPJ
DEFINE	PFALL(ADDR),<IF2,<IFN .-ADDR,<PRINTX PFALL mismatch at ADDR>>>

OPDEF	CHGPPN	[CALLI  74]	;Change default directory PPN
OPDEF	STRUUO	[CALLI  50]	;Structure interlock
OPDEF	LOGIN	[CALLI  15]	;Log job in
OPDEF	LOGOUT	[CALLI  17]	;Log job out

  ;TYMCOM-X specific UUOs
OPDEF	OUTCHI	[TTCALL 16,]	;Output character, immediate
OPDEF	OUTPTR	[TTCALL 17,]	;Output string, updating byte pointer
OPDEF	CHANIO	[043B8]		;New I/O functions
OPDEF	ATTACH	[CALLI  -6]	;Attach line to frame (not same as TOPS10)
OPDEF	CHPJC	[CALLI -61]	;Change project code
OPDEF	INTADR	[CALLI -33]	;Declare interrupt vector address
OPDEF	INTASS	[CALLI -36]	;Assign cause to interrupt vector
OPDEF	INTENB	[CALLI -34]	;Enable interrupt system
OPDEF	PUTSAR	[CALLI -62]	;Put stream accounging record
OPDEF	SETJAL	[CALLI -21]	;Set JACCT license
OPDEF	SETLIC	[CALLI -10]	;Set program license
OPDEF	SETMOD	[CALLI -26]	;Set TTY I/O mode
OPDEF	SETPRV	[CALLI -11]	;Change JBTPRV
OPDEF	SETRCF	[CALLI -57]	;Set restricted command file
OPDEF	SETTIM	[CALLI -37]	;Set timer interrupt
OPDEF	SETUUO	[CALLI  75]	;Set functions (not same as TOPS10)
OPDEF	TINASS	[CALLI -42]	;INTASS for terminals

.chufd==33	;CHANIO function to read UFD
hiblin==20	;argument to hibernate for break chr
timcas==4	;reason for timer interupt
logsiz==5	;size of login block to monitor

suumsg==0	;setuuo code to type cty/opr tty msg
suutim==3	;setuuo code for time
suudat==4	;setuuo code for date
suuopr==5	;setuuo code for opr

;gettab args

jbtlin==-27	;tty name
jbtlog==-24	;ldblog (supervisor info)
jbtaun==-23	;aun (logged in PPN)
jbtunm==-22	;1st half of user name
jbtun1==-21	;2nd half of user name

jbtlic==-20	;for getting our licenses
  licopr==100000	;for setuuo msgs
  licsys== 40000	;systat (for checking detached jobs)
  licst==   4000	;structure (to interlock ufd)
  lichf==   2000	;home files (LUD,mailboxes,..)
  licjal==  1000	;loginn runs with these

.gtsts==0	;job status bits (jbtsts)
  jna==40000		;this job number is assigned
  jlog==   4		;logged in bit
  jacct==  1		;jacct bit. to be turned off after login

.gtppn==2	;project/programmer number of default directory

.gtprv==6	;privilege bits for job (JBTPRV)
  prvmod==600		;mask for mode bits in jbtprv word
  prvtru==2000		;bit set by loginn if tru budget present (in jbtprv)
  pvnoat==1B1		;bit set if job doesn't want to be attached to
  pvexo==1B18		;execute only
  pvdop==3B20		;mask for disconnect options field
  .jpcon==2B20		;continue-on-disconnect (so LOGINN traps zappers)

%cntim==10,,11	;time of day
%cndat==11,,11	;date
%cnopr==13,,11	;name of OPR device
%cnsjn==15,,11	;number of first hiseg ( = jobmax + 1)
%cnsts==17,,11	;states word in config table
%cnser==20,,11	;CPU serial number
%cnjsc==26,,11	;jiffies per second
%cnjmn==27,,11	;jiffies per minute

%nsalm==36,,12	;alarm bits
  almcty==400	;alarm bit for cty msg
  almrmt==200	;alarm bit for rps

%ldmfd==0,,16	;PPN of MFD:[1,1]
%ldsys==1,,16	;PPN of SYS:[1,4]
;ascii characters

nulchr==0	;null
cntrlc==3	;control c
cntrlg==7	;control g (bell)
lf==12		;line feed
vt==13		;vertical tab
ff==14		;form feed
cr==15		;carriage return
escchr==33	;escape
nonull==4	;number of null characters for spacing

;definitions of words in the LUD

lppn==0		;ppn for user
laun==0		;aun for user
lbits==2	;bits (run bit, watch bits, etc)
 lcspb==400	;bit indicates a cusp to run is present
 ltrub==(1b4)	;tru budget present bit
 lnoatt==(1b5)	;no attach in loginn even if job exists
 lfrcat==(1b6)	;forced attach..cannot create new job
 lonejb==(1b7)	;allow only 1 job on system at a time, this aun
 lnopjc==(1b8)	;dont ask for project code
 lovrid==1b19	;shut override bit in LUD ,right half
llink==2	;has size of entry in right 7 bits
lprv==3		;prv bits
  rescmd==1000	;-restr. command mode if on.
lhun==4		;hased user name
ltru==5		;tru budget word
lcsn==5		;cusp to run (if present)
lcsu==6	;user name of cusp to run (0=this user)
lcsu1==7		;second half of user name

lfsnam==5	;file structure in reference to file structure information
lfsbts==5	;satus bits
lfsqin==6	;logged in quota (in blocks)
lfsqot==7	;logged out quota (in blocks)

llet1==1000		;send broadcast letter 1
llet2==2000
llet3==4000
llet4==10000
llet5==20000
llet6==40000

llete==llet6		;highest letter (maybe some day more than 6)
lleta==llet1!llet2!llet3!llet4!llet5!llet6	;any letters
lnolog==400000		;do not let him log in here
lnomes==200000		;do not give user the tymshare message
lrstr== 100000		;user is restricted

;structure of password file (pas.sys), 2 word entries, last
;  entry in the block , right half of first element, points to
;  overflow block if any

phun==0		;hashed user name entry
ppw==1		;hashed password entry
pentsz==2	;size of each password file entry
exlppn==ribppn	;entry for directory name (project, programmer number)
exlnam==ribnam	;file name
exlext==ribext	;ext
exlerr==ribext	;error code
exlalc==ribalc	;blocks allocated
exlqtr==ribqtr	;reserved quota
exlqtf==ribqtf	;first come, first served quota
exlqto==ribqto	;logged-out quota
exlusd==ribusd	;free blocks left with respect to logged-in quota
exlsts==ribsts	;status bits

LUDhsh==^d887	;hash value for LUD
malhsh==177	;hash value for mailbox

;places in mailbox for broadcast letters

malnam==0	;name
maldat==2	;date
malexp==4	;expiration date
malcnt==5	;count of not recieved
maltxt==12	;text starts here (in asciz)
array buf[200],cmd,pdl[40],rh.usr[3],runblk[6]
integer mfdppn,sysppn,hshblk,hshnam,strptr,strnum
integer cspnam,inbits,ufdfsn,datime
array lkbmsg[4],bufmsg[3],twtmsg[1]	; stuff for typmsg routine
array logtab[logsiz],cspusr[2],inttab[2]
integer kspass,ksmach,hpw,pblknum,lftpas,rtpas,bdpwct
maxpwf==4	;maximum number of trys at getting the password right

lvar

inppn=logtab
 gemode==2
inprv=logtab+1
inaun=logtab+2
innam=logtab+3
innam1=logtab+4

comment !
persons loging in from the nodes listed in the following
table are forced into the corresponding xexec mode regardless
of the mode recorded for them in the LUD
!

pdpmod==0
xexmod==1
japmod==2
sudmod==3

nodtab:
REPEAT 0,<;These node numbers change when they went to TYMNET-II
	XWD	1270,japmod
	XWD	1271,japmod
	XWD	1272,japmod
	XWD	1273,japmod
	XWD	1274,japmod
	XWD	1275,japmod
	XWD	1276,japmod
>
nodtbl==.-nodtab
subttl	Startup

LOGINN::jfcl			;in case of ccl entry
	reset			;reset the world
	move	P,[ioWD 40,pdl]	;get the pushdown stack
	movsi	F,fl.fuf	;just first ufd bit
	hrroi	T1,.gtsts	;get jobs status
	gettab	T1,
	 jsp	N,uuoerr	;fatal if cannot get this
	tlne	T1,jlog		;must not be logged in
ifn deb,< jfcl>
ife deb,<
	  jrst	alrdin
	hrroi	T2,jbtlic
	gettab	T2,		;see that loginn has needed licenses
	 movei	T2,0		;say none
	tlc	T2,licopr!licsys!licst!lichf!licjal
	tlce	T2,licopr!licsys!licst!lichf!licjal
	 jsp	N,licerr	;not all were set
	tlo	T1,jacct	;T1/jbtsts still
	setjal	T1,		;set up jacct
	 jsp	N,jalerr>
	movei	T1,1200		;break 2 and no echo
	setmod	T1,		;set tty mode
	movei	T1,17
	hrli	T1,400000	;physical only
	movsi	T2,'SYS'
	movei	T3,0
	open	ufd,T1		;phys only,iodmp=17 mode,no buff ring hdr
	 jsp	N,syserr	
	move	T1,[ioWD 200,buf]
	movem	T1,cmd
	setzm	cmd+1		;fix up for dump input
	move	T1,[%ldsys]
	gettab	T1,		;get (SYS) ppn
	 move	T1,[XWD 1,4]
	movem	T1,sysppn
	move	T1,[%ldmfd]
	gettab	T1,		;get (UFD) ppn
	 move	T1,[XWD 1,1]
	movem	T1,mfdppn
;;;SDD: new wonderful FOO only carries across halves on stack stuff
;;; You wouldn't want to do this in non-0 section (global stack and all)
	movei	T1,-1	; 0,,top-of-memory
	push	T1,0	; 1,,0 if no carry, 2,,0 elsewise (and 0 <- 0)
	tlz	T1,1	;make the result 0 for good (DEC) CPUs
;;	seto	T1,
;;	aobjn	T1,.+1
;;^^ end-of-change ^^
	jumpn	T1,itsaf3	;f3 like KA, alves overflow
	move	T1,[%cnser]
	gettab	T1,		;get serial number
	  jsp	N,uuoerr	;if we can't get this, we're in deep trouble
	andi	T1,30000	;KS serial numbers are .gt. 7777
itsaf3:	movem	T1,kspass	;F3 and KS need to read SYS:PAS.SYS
	movem	T1,ksmach
;KSPASS	and KSMACH control LOGINN behavior under these
;conditions:
;1) This system is a KS or F3 and it is connected to NEXILIS network
;2) This system is a KS or F3 connected to TYMNET
;3) This system is a KS or F3 coming up under CTYSIM (no network)
;4) This system is not a KS or F3 (and therefore is not coming
;	up under NEXILIS.  It must be a KI or KL coming up
;	under TYMNET or CTYSIM.  The case of a KI/KL
;	coming up under NEXILIS is not supposed to happen.)
;KS or F3 systems have a LUD bit which says whether or not the
;user has shut override.  So if case (2), check from LUD even
;if TYMNET says "!".
;NEXILIS net has no supervisor, does no password checking. That
;must be done by the host.  In case (2), turn off KS or F3 password-checking
;since TYMNET already did it.
;NEXILIS net puts a vertical bar "|" before the username to
;identify itself (TYMNET never puts "|" in the char stream)
;and to force KS or F3 password verification.
	hrroi	T1,.gtprv
	gettab	T1,		;must set initial disconnect options
	 jsp	N,uuoerr
	trz	T1,pvdop	;from whatever default monitor leaves
	iori	T1,.jpcon	;to continue-on-disconnect, so that
	setprv	T1,		;SETINT arming for zapper-int will work
	HRROI	T1,.GTPPN
	GETTAB	T1,		;Get PPN in case set by CREFRM
	  MOVEI	T1,0
	MOVEM	T1,ORGPPN#
	HRROI	T1,JBTAUN	;Get Accounting User Number
	GETTAB	T1,		;(this is zero for network logins)
	  MOVEI	T1,0
	MOVEM	T1,ORGAUN#
	CAMN	T1,[400000,,0]	;Did CREFRM set special number?
	 JRST	[SETOM	KSPASS		;Need to verify password
		 OUTSTR	[ASCIZ /Please log in: /] ;Wait for PTY to be attached
		 JRST	RDUNM	]	;Go get user name and password
	JUMPG	T1,[MOVEI CH,";"	;Suppress "project code" prompt
		HRROI	T2,jbtunm	;Get name that CREFRM set
		GETTAB	T2,
		  SETO	T2,
		HRROI	T3,jbtun1	;2nd half
		GETTAB	T3,
		  SETO	T3,
		DMOVEM	T2,NAME
		JRST	RDUNM2	]	;Verify name and get PPN
	movei	M,^d600		;wait a long time for the first stuff
	pushj	P,setint	;set up all software interrupts, start timer
	pushj	P,tyi
	cain	CH,"|"-40	;vertical bar from NEX net?
	 jrst	rdunm		;yes. leave KSPASS set non-zero ; this
				;is a KS or F3 system.
	setzm	kspass		;TYMNET, turn off KS or F3 password verify
	caie	CH,"!"		;did TYMNET put in "!" for shut override?
	 jrst	rdunm1		;no, CH/ 1st char of username
	skipn	ksmach		;on KS or F3 check override from LUD
	 tlo	F,fl.sts	;not KS or F3, accept TYMNET override
;KSMACH=0 if KL or KI system
;KSMACH#0 if KS or F3
;KSPASS=0 if TYMNET already checked password
;KSPASS#0 if KS or F3 password checking must be done
SUBTTL	Read username from network

rdunm:	pushj	P,tyi		;get ch/ 1st char of username
;fall thru from above with timer set and ch/ 1st char username
rdunm1:	skipe	kspass
	 pushj	P,seehaf	;for pw check see if line is halfdup
	pushj	P,rdnam		;deposit name in core area,
	  jrst	notval		;pretend not valid if too many chars
;ch/ term char from RDNAM all thru below
RDUNM2:	pushj	P,clrtim		;no timer while doing LUD operations
	movsi	T1,(sixbit /LUD/)	;see if he's in the LUD
	movsi	T2,(sixbit /SYS/)
	movei	T3,0
	move	T4,sysppn
	lookup	ufd,T1		;lookup LUD.SYS in sysppn
	  jrst	noLUD		;*****
	move	N,name
	movem	N,innam
	move	N1,name+1
	movem	N1,innam1
	pushj	P,hashit	;go hash user name
	jumpe	T1,notval	;*****
	movem	T1,hshnam
	movem	N1,hshblk
	pushj	P,fndusr	;find the user
	 jrst	notval		;*****
;fall thru, still have ch/ term char
	movei	M,^d120		;give 2 more mins for password or for
	pushj	P,rsttim	;input of final term chr if not KS
	skipn	kspass		;skip if password must be checked
	 jrst	lkusr
	movem	WD,savWD	;WD gets clobbered in passWD lookup
	movei	M,maxpwf	;init passWD fail count
	movem	M,bdpwct
	pushj	P,chsemi	;if prev input term char =";"
	 tlo	F,fl.pas	;suppress prompt for passWD
	tlnn	F,fl.pas
	outstr	[asciz /
password: /]
	pushj	P,getpas	;get & hash it, term char in CH
	pushj	P,fndpas	;verify password correct
	 pushj	P,badpas	;***** password didn't match, go ask again
	move	WD,savWD
;arrive here with ch/ term char from RDNAM (or GETPAS if KS)
;timer is running; WD/ index for LUD lookup
lkusr:	pushj	P,chsemi	;if term chr =";"
	 tlo	F,fl.npt	;then suppress "proj code" prompt
				;and suck up possible CR LF
	pushj	P,clrtim	;reset timeout
	move	T1,buf+lppn(WD)
	movem	T1,inppn
	move	T1,buf+laun(WD)
	movem	T1,inaun
	move	T2,buf+llink(WD)
	andi	T2,177
	setzm	cspnam
	move	T1,buf+lbits(WD)
	trne	T1,lovrid	;see if override allowed
	 tlo	F,fl.sts	;set flag, override allowed
	move	M,[%cnsts]
	gettab	M,
	 jsp	N,uuoerr	;cannot get STATES ? fatal
	skipe	ksmach		;dont test shutness unless on ks
	trnn	M,400000	;skip if  shut
	 jrst	lkus1		;not shut, go on
	tlnn	F,fl.sts	;skip if override  allowed
	 jrst	syshut		;complain- sys shut
	skipn	kspass		;skip if need to say shut
	 jrst	lkus1
	outchi	cntrlg		;put out bell
	outstr	[asciz /shut/]	;output the shut message
repeat nonull,<outchi nulchr>	;output nulls to space the bells'
	outchi	cntrlg		;put out bell
lkus1:	tlne	T1,lnolog	;is this a prohibited user??
	 jrst	notvl1
	tlne	T1,lnopjc	;no proj code from this guy?
	 tlo	F,f.nopjc	;  nope
	tlne	T1,lonejb	;LUD sez one job only at a time?
	tloa	F,f.onej	;yes, remember in f & skip
	 tdza	T3,T3		;not lonejb; T3_0 setup opt att
	  movsi	T3,(1b0)	;lonejb; set for forced attach
	tlne	T1,lfrcat
	 tlo	T3,(1b0)
	tlne	T1,lnoatt
	 hrri	T3,1
	movem	T3,attflg#	;attflg <0 if forced att,
				;attflg =0 if optional att (normal)
				;attflg >0 if no att
	move	T3,buf+lprv(WD)
	trz	T3,prvtru	;assume not TRU limit until later
	movem	T3,inprv	;save priv bits
	setom	intru#		;assume no TRU budget until later

	hlrz	T5,inaun	;get aun
	cain	T5,sysgan	;gan 3?
	 jrst	nonres

	tlne	T1,ltrub	;is tru budget present for this user?
	 tro	T3,prvtru	;yes, set it
	movem	T3,inprv	;and save them again
	trne	M,100000	;is it sched 100000
	 tloa	F,fl.rst	;set restrict bit
	  jrst	nonres		;no, not restricted
	tlne	T1,lrstr	;is user restricted? (only ref this symbol)
	 tlne	F,fl.sts	;and not override
	  skipa
	jrst	rstrct		;yes, restricted, kick him off
;fall thru
nonres: tlnn	T1,ltrub
	 jrst	notru
	move	M,buf+ltru(WD)	;get word
	caie	T5,sysgan		;gan 3
	 movem	M,intru
	addi	WD,1
	subi	T2,1
;fall thru
notru:	movem	T1,inbits
	trnn	T1,lcspb		;is	there a cusp name?
	jrst	nocsp
	move	T1,buf+lcsn(WD)
	movem	T1,cspnam
	move	T1,buf+lcsu(WD)
	movem	T1,cspusr
	move	T1,buf+lcsu1(WD)
	movem	T1,cspusr+1
	addi	WD,3
	subi	T2,3
;fall thru
nocsp:	movem	WD,strptr
	subi	T2,lcsn
	idivi	T2,3
	movem	T2,strnum
	close	ufd,0		;LUD.SYS
;see if necessary to force user into special xexec mode
;due to loging in from special node
	hrroi	T1,jbtlog
	gettab	T1,		;get supervisor info
	 jsp	N,uuoerr
	ldb	T2,[point 8,T1,19]	;node number top 8 bits
	ldb	T1,[point 6,T1,27]	;low 6
	dpb	T2,[point 8,T1,29]	;T1/14 bit node number
IFG NODTBL,<
	movsi	T2,-nodtbl
nodl0:	hlrz	T3,nodtab(T2)
	came	T3,T1			;does T1 match any node in table
	 aobjn	T2,nodl0
	jumpge	T2,nodl1		;fell thru whole table no match
	hrrz	T3,nodtab(T2)
	dpb	T3,[point 2,inprv,28]	;force mode specific for this node
nodl1: >  ;End IFG NODTBL
	move	T1,inprv
	pvexo==1b18
	iori	T1,pvexo	;loginn is run-only
	movem	T1,inprv
	setprv	T1,		;set time zone,etc.
	movei	M,0		;turn on tty echo,
	setmod	M,		;etc.
	PFALL	getprj		;fall thru
;input the project code

getprj:	setzm	name	l project code!
	setzm	name+1
	setzm	name+2
	SKIPLE	ORGAUN		;If we got user name from GETTAB tables,
	 JRST	CHKSLT		; then don't ask for project code or DET jobs
	tlnn	F,f.nopjc	;LUD says to input one?
	 jrst	rdpjc		;yes
	tlnn	F,fl.npt	;prev input term char =";"?
	 tdza	CH,CH		;not going to read pjc, fake
	  movei	CH,";"		;initial setting of ATTFL2
	jrst	det0		;init for det loop

rdpjc:	tlnn	F,fl.npt
	 outstr	[asciz /proj code: /]
	movei	M,^d120		;2 min
	pushj	P,rsttim
	pushj	P,rdnam1
	cain	CH,CR		;if <cr> after <proj code>
	 pushj	P,tyi		;need to absorb 1 more
	PFALL	det0

comment ! ATTACH-to-job stuff.  Fall into this code from above.
Code at DET1 begins a loop which repeats if failure
	below	during ATTACH.
;exits from this code are:
;1)chkslt--may not attach to existing job or none exists,
;  	   or doesnt want to attach (<cr> to "job no." question)
;2)timer interrupt-- comout
;3)attach uuo succeeds
;4)comout-- if detcnt runs down
;attflg set from LUD:
; <0	forced attach to any job present belonging to this user
; =0	optional attach..usual case
; >0	no attach to job(s) which may exist for this user
!

det0:	movei	M,detlc
	movem	M,detcnt#	;loop limiter for deT1 attach code
	cain	CH,";"	;did he type <proj code>;<job number [possibly null]> <cr> ?
	 tdza	CH,CH	;well, he typed the ";" at least
			;skip	& fall into deT1 attach code

deT1:	seto	CH,		;after <proj code>, what did he type?
	movem	CH,attfl2#	;attfl2/0 if user typed ";"
				;attfl2/-1	if he gave <cr>
				;attfl2 needed so that we can
				;type msgs on <possible> 2nd, 3rd
				;passes thru here even if fl.npt is set
	sosg	detcnt
	 jrst	comout
	pushj	P,clrtim
	pushj	P,inimbf	;init msg buffer
	movei	T1,[asciz /type job number to attach, job /]
	pushj	P,appmsg	;append (T1) string to msg
	setzm	frejob#
	setzm	spcjob#	;initialize for ckdet
	tlz	F,f.mor!f.dett!f.deT2
	move	T1,[%cnsjn]
	gettab	T1,		;get no. of 1st hiseg,
	 jsp	N,uuoerr
	movei	T1,-1(T1)	;highest job=1 less than gettab returns

;scan all jobs for ones belonging to us and detached
;for a:=highest job step -1 until 1 do:

deT2:	pushj	P,ckdet	;skip	if (T1) is ours & detached
			;count	frejob and spcjob
	jrst	deT3	;doesnt qualify
	skipl	attflg	;forced attach?
	jrst	[hrl	T2,T1		;no, check "no attach" bit
		hrri	T2,.gtprv	;in jbtprv
		gettab	T2,
		 jfcl
	tlne	T2,(pvnoat)
		jrst	deT3	;no attach set - skip this one
		jrst	.+1]
	movem	T1,atT1jb#	;save incase it's the only one
	tloe	F,f.dett	;got one
	tlo	F,f.deT2	;got more than one
	pushj	P,appnum	;append (T1) as decimal number to msg
	movei	CH,","
	sosle	msgct
	idpb	CH,msg	;number,number,...
deT3:	sojg	T1,deT2	;next	job

;done scanning. spcjob,frejob,f.dett set

	skipge	attflg	;skip if optional or no attach
	jrst	[	tlnn	F,f.dett	;forced attach,do we have any ?
		jrst	.+1	;no
		tlnn	F,f.deT2	;did we find just one job?
		jrst	det4	;yes,auto attach to it
		jrst	.+1]	;let him select which one
	pushj	P,frechk	;set f.mor if ok to create new job
	skipg	attflg	;if may not attach to existing job,
	tlnn	F,f.dett	;or no detached jobs for this guy,
	 jrst	chkslt	;go attempt to create new job
	movei	T1,[asciz / or c.r. to login: /]
	skipn	attflg
	tlnn	F,f.mor	;mention c.r. option only if new job ok,
	movei	T1,[asciz / to login: /]	;and not forced attach
	pushj	P,appmsg	;append (T1) msg
	move	T1,[point 7,msgbuf]
	skipe	attfl2	;print entire msg unless user finished
	outptr	T1	;proj code string with ";"
	movei	M,^d120	;now set timer and
	pushj	P,rsttim	;read job number
;read job number, complain if garbage offered
	pushj	P,decrd
	cain	CH,CR	;did he type <job no><cr> ?
	 jrst	det5	;yes
	pushj	P,tyi	;no, eat chars until lf
	caie	CH,LF
	 jrst	.-2
	outstr	[asciz /
not a number
/]
	jrst	deT1

comment !
here if forced attach mode and only one job exists
!

det4:	pushj	P,inimbf	;re-init	msg buff
	movei	T1,[asciz /attaching you to job /]
	pushj	P,appmsg
	move	T1,atT1jb
	pushj	P,appnum
	movei	T1,[asciz /
/]
	pushj	P,appmsg	;trailing crlf so monitor prompt on new line
	move	BP,[point 7,msgbuf]
	outptr	bp
	move	T1,atT1jb	;restore a/job no. for det6
	jrst	det6

comment !
here we have a/job no.  to try attaching to
(if he typed just <cr>, a/0.  )
!

det5:	pushj	P,tyi	;get	the lf after <job no><cr>
	skipn	attflg	;skip if forced attach
	jumpe	T1,chkslt	;<job no> not typed, doesnt want attach
	jumpe	T1,deT1	;dont let him do it if forced attach
	pushj	P,ckdet	;make sure this one if for him
	jrst	deT1	;the klutz typed somebody else's job no.
det6:	skipe	name	;in case he typed a proj code, tell him:
	outstr	[asciz /
project code ignored on attach
/]
	attach	T1,	;doesnt return if success since login
			;uuo not yet done, this process will be
			;killed by monitor. if it returns:
	outstr	[asciz /
can not attach to job
/]
	jrst	deT1	;start over again

comment ! routine decrd
function: return (T1)=decimal number from tty, ch/term char
!

decrd:	movei	T1,0
dcrd:	pushj	P,tyi
	caig	CH,"9"
	caige	CH,"0"
	popj	P,
	imuli	T1,^d10
	addi	T1,-"0"(CH)
	jrst	dcrd
comment	! routine inimbf
function: initialize msg buffer & params
returns: msgbuf zeroed
	msg/	b.p. to start of buffer
	msgct/	chars left to end of buffer
destroy: T1
!

inimbf:	move	T1,[point 7,msgbuf]
	movem	T1,msg
	movei	T1,msgsiz*5
	movem	T1,msgct	;set up msg params for appmsg,appnum
	setzm	msgbuf
	move	T1,[XWD msgbuf,msgbuf+1]
	blt	T1,msgbuf+msgsiz-1
	popj	P,



comment ! routine appmsg
function: append string to msg
expects: a/addr of asciz string to append
	msg/	b.p. to current spot in msgbuf for idpb
	msgct/	chars left to go in msgbuf

destroy: T1
!

appmsg: hrli	T1,(point 7,0)
	push	P,T1
app2:	ildb	T1,(P)
	jumpe	T1,appx
	sosg	msgct
	jrst	appx
	idpb	T1,msg
	jrst	app2
appx:	pop	P,T1
	popj	P,

comment	! routine appnum
function: append decimal number in (T1) onto string in msgbuf
expects: a/number	msg/ b.p. into msgbuf for idpb
	msgct/	space left in msgbuf
destroy:	N,n+1	(=n1), ch
!

appnum:	move	N,T1
appn2:	idivi	N,^d10
	hrlm	n+1,(P)
	skipe	n
	pushj	P,appn2
	hlrz	CH,(P)
	addi	CH,"0"
	sosle	msgct
	idpb	CH,msg
	popj	P,

integer	msg,msgct
msgsiz==^d20
array msgbuf[msgsiz]
detlc==^d10	;max of 10 times thru attach code, then die

;here when attach code previous page has finished scanning
;all jobs to see if this guy should be allowed on.
;f.mor set if ok to use up a job slot by letting
;this guy on.
;f.ejob set by det code during system scan if there exists a
;job for this guy already.

chkslt:	tlnn	F,f.mor
	 jrst	jcapyx		;"job cap'y exceeded"
	tlc	F,f.ejob!f.onej
	tlce	F,f.ejob!f.onej	;were both set?
	  skipa			;none on yet or can have >1 job
	 jrst	alredy		;yes, say sorry,bye

;fall thru
chktim:	pushj	P,clrtim
	move	T1,inppn
 ife deb, <
	chgppn	T1,	;change ppn so can access files
	 jsp	N,uuoerr	;fatal trouble
 >; end	ife deb.  No CHGPPN if debugging
	move	T1,[%cndat]
	gettab	T1,
	 jsp	N,uuoerr
	SKIPLE	ORGAUN		;If this is a created frame
	 TLZ	T1,(1B0)	; then don't ask for date/time
	jumpge	T1,fs0		;time ok
;***********************************

;time not received from tymnet. user must deal with it.

;fall thru from above if date not set.  Only exit
;is COMOUT (timeout) or FS0 when date entered properly

;************************************


	movei	M,^d120
	pushj	P,rsttim
rrddat:	outstr	[asciz /
date not set, type date as mm-dd-yyyy /]
	pushj	P,decrd
	jumpe	T1,baddat
	caig	T1,^d12
	cain	CH,CR
	 jrst	baddat		;date is bad
	move	T2,T1
	pushj	P,decrd
	caig	T1,^d31
	cain	CH,CR
	 jrst	baddat
	sosge	T3,T1
	 jrst	baddat
	pushj	P,decrd
	cail	T1,^d1964
	caile	T1,^d2008
	 jrst	baddat
	caie	CH,CR
	 jrst	baddat
	pushj	P,tyi		;get the line feed
	subi	T1,^d1964
	imuli	T1,^d12
	addi	T1,-1(T2)
	imuli	T1,^d31
	add	T3,T1		;now have date in c

rrdtim:	outstr	[asciz /
type time as hh:mm /]
	pushj	P,decrd
	CAIN	CH,":"
	 jrst	[PUSH	P,T1		;Save hours
		PUSHJ	P,DECRD		;Get minutes
		POP	P,T2		;Convert hours
		IMULI	T2,^D60		;To minutes
		jrst	RRDTM1]
	idivi	T1,^d100
	imuli	T1,^d60
RRDTM1:	add	T1,T2
	caie	CH,CR
	 jrst	badtim
	pushj	P,tyi
	cail	T1,^d<24*60>	;see if time too big
	 jrst	badtim		;yes, tell him and make him retype
	hrli	T3,suudat
	setuuo	T3,
	 jfcl
	hrli	T1,suutim
	setuuo	T1,
	 jfcl
;******************************
	jrst	fs0
;******************************


baddat:	clrbfi
	outstr	[asciz /
incorrect date/]
	jrst	rrddat

badtim:	clrbfi
	outstr	[asciz /
incorrect time/]
	jrst	rrdtim
;here from chktim if time already set or after time
;set up prev. pg.

;scan all file structures and do ufdset for each one
;(temporary kludge: look only at /DSKB/)
;exit to strdon.

;strnum and strptr initialized from LUD entry at nocsp

fs0:	pushj	P,clrtim
fs1:
ife	deb,<sosge strnum>	;structures left?
ifn	deb,<jfcl>
	 jrst	strdon	;go finish logging him in
	move	WD,strptr
	move	M,buf+lfsnam(WD)	;get name
	trz	M,7777	;only 4 characters
	move	T1,buf+lfsbts(WD)	;status bits
	andi	T1,3	;only these two
	move	T2,buf+lfsqin(WD)	;quota in
	move	T3,buf+lfsqot(WD)	;and out
	ash	T2,-2			;kludge conv blocks to pages.aaa
	ash	T3,-2			;kludge ". LUD values are in blocks.aaa
	addi	WD,3			;point to next
	movem	WD,strptr
	came	M,[sixbit /DSKB/]
	 jrst	fs1
	pushj	P,ufdset		;set up ufd
	  jfcl
	tlnn	F,fl.fuf		;is first ufd flag still set?
	 jrst	strdon
	outstr	[asciz /
tru limit exceeded/]			;must be out of time
	jrst	comout

;fall tru from fs1
strdon:	pushj	P,acct		;write accounting entry
	pushj	P,typmsg	;print access.msg (if there)
	pushj	P,inmss		;print login message
	tlne	F,fl.sts	;is this an override password?
	 pushj	P,inopr		;yes, give alarms
	reset
	move	T2,[XWD 5,runblk];read&clear tmpcor dir
	setzm	runblk		;runblk is a handy buffer
ife deb,<tmpcor	T2,	;clear tempcore files
	  jfcl	;ignore error return>
	jrst	pjctst		;-go test proj code class,etc.
comment ! Project-Code database def'ns   !

;-class info is in 3 words of ufd rib. it is as follows:
;-class 'a'	xlpjpp/ 0
;		xlpjfn/ 0
;		xlpjcl/ 0
;-class 'b'
;		xlpjpp/ ppn
;		xlpjfn/ filename to run
;	xlpjcl=	xlpjxt/ 0,,1
;
;-class 'c'	xlpjpp/ ppn
;		xlpjfn/ filename for another prog to look in
;	xlpjcl=	xlpjxt/ ext,,2

;-whatever pjc user gave is sitting in name,name+1,
; name+2
;-ac definitions for passing args to project-code programs
;-none of these may be ac 1 or ac 17 (for run 1, & popj P,)
logac1==7	;proj code, 3 regs
logac2==10
logac3==11
logac4==12	;date,time
logac5==2	;"inprv" fr loginn, user status for jbtprv
logac6==3	;init fn,username 3 regs
  logrcm==1000	;restr. command mode, in rh logac5
logac7==4
logac8==5
logac9==13	;values from ufd: ufdpjc/ ppn
lgac10==14	;ufdpj1/ filename or progname
lgac11==15	;ufdpj2/ext,,class designator

;-new positions in ufd rib contain class info
xlpjpp==35
xlpjfn==36
xlpjcl==37
xlpjxt==37	;ext & class in same word
;-bp's for class & "verify bit"
pjclas:	point	3,srcbuf+xlpjcl,35
pjcvfy:	point	1,name+2,35	;bit says verify this pjc if 1
pjcca==0 ; class a
pjccb==1
pjccc==2
;-dispatch for 3 classes
pjcdsp:	pushj	P,upjca
	pushj	P,upjcb
	pushj	P,upjcc
.pjdl==.-pjcdsp	;leng	for double-ck

;-************standard (sys)projec for class 'c' users*****
sfnpjc:	sixbit	/projec/
;**********************************************************
;Here is where we do the last few things then exit LOGINN
;to monitor, init file, or project-code-verification program.
;Determine whether user subject to pjc-verify
; or not (class A is not, B,C are).  If class A, set session
; pjc & exit (run any init file).  If verify required,
; run the appropriate program, passing the proposed
; project code, initfilename, login jbtsts word from LUD,
; class info, etc., force restricted command mode.


pjctst:	ldb	T1,pjclas
	caile	T1,.pjdl	;catch garbage
	jrst	[outstr [asciz /
project-code info in ufd bad. logging you out./]
		jrst	comout]
	movei	T2,0
	skipe	T1
	movei	T2,1
	dpb	T2,pjcvfy	;if not class 'a', turn on verify
	move	T2,[XWD runblk,runblk+1]
	setzm	runblk
	blt	T2,runblk+5	;clear entire runblk
	xct	pjcdsp(T1)	;call setup routine per class
	;ac	1 set by setup routine for proper entry pt.
	;ac	1 = 0 if no init file or pjc verifier
	;rh(runblk+5)	has license to pass to next program if any
	;(usually	zero,but jl passed to (sys)projec. reduce
	; license	now to nothing or whatever license to be passed)
	HRROI	T2,JBTLIC
	SKIPLE	ORGAUN		;If CREFRM gave us a username
	 GETTAB	T2,		; then preserve passed license
	  MOVEI	T2,0
	hll	T2,runblk+5
	setlic	T2,
	jumpe	T1,lgixit
	run	1,	;-exit login to init file or proj code verifier.
	jfcl
	outstr [asciz /
can't run required program/]
	ldb	T1,pjclas
	jumpe	T1,lgixit	;if class	T1,run failed on initfile,
			;so	no need to be nasty. otherwise,
			;must	kick the guy off.
	outstr	[asciz /
logging you out/]
	jrst	comout

lgixit:	exit	1,	;***exit loginn, no initfile or pjc prog***
	exit	;in case he says .con

;-upjca .. setup for class 'a' user.
;1. set priviledges from LUD
;2. set sesssion pjc if not null
;3. return a=0, runblk[0 - 5]=0 if no init file
;4. set runblk for initfile
;5. set registers to pass. (just 7,10,11,12 relevant)
;6. return

upjca:	move	T1,inprv	;from LUD
	setprv	T1,
	dmove	T2,name		;load up project code into
	move	T4,name+2	;T2,T3,T4
	jumpe	T2,upjca2	;none, no need for uuo
	move	T1,[3,,T2]	;set pjc from T2,T3,T4=name..name+2,
	chpjc	T1,		;set vfybit from bit 35 of T4
	 jrst	[outstr [asciz /
cannot set project code.  system trouble/]
		jrst	comout]
upjca2:	skipn	T1,cspnam	;skip if initfile present
	 popj	P,		;return a=0 no license no run uuo
	movem	T1,runblk+1	;init fn
	movei	T1,cspusr	;pt at username
	skipn	cspusr
	setz	T1,
	movem	T1,runblk+4	;username
	movsi	T1,(sixbit/dsk/)
	movem	T1,runblk	;dev
	movei	T1,runblk	;run init file at entry+0
	jrst	upjxit		;common xit, load regs & return

;-upjcb..setup for class 'B' user.
;1. set priv from LUD with restr cmd mode forced.
;2. set rcm file=prog in ufd xlpjfn,xlpjpp (acct. super prog)
;3. set runblk for run acct. super prog
;4. set ac 1 for run at entry+1
;5. load regs & return

upjcb:	move	T1,inprv
	iori	T1,rescmd
	setprv	T1,
	move	T1,srcbuf+xlpjfn
	move	T2,srcbuf+xlpjpp
	movei	T3,T1		;set rcm fil T3/loc
	setrcf	T3,		;loc/fn loc+1/ppn
	movem	T1,runblk+1	;fn
	movem	T2,runblk+4	;ppn
	movsi	T2,(sixbit/dsk/)
	movem	T2,runblk	;dev
	move	1,[1,,runblk]	;run at entry+1
;common load regs & exit for upjca,upjcb,upjcc

upjxit:	dmove	logac1,name	;pjc0,1
	move	logac3,name+2	;pjc2 with vfybit set
	move	logac4,datime
	move	logac5,inprv	;actual LUD priviledges
	move	logac6,cspnam	;init fn
	dmove	logac7,cspusr	;& username
	dmove	logac9,srcbuf+xlpjpp	;ppn,fn ufd info
	move	lgac11,srcbuf+xlpjxt	;&ext,,class
	popj	P,

;-upjcc..setup for class c user
;1. set priv with forced rcm
;2. set rcf file = standard project program
;3. set runblk for run standard program. pass jl license ***
;4. set ac 1 for run entry+1
;5. load regs & return. logac9-11 tell std prog where
;	to look for users list of pjc's

upjcc:	move	T1,inprv
	iori	T1,rescmd
	setprv	T1,
	move	T1,sfnpjc	;std	file name
	move	T2,sysppn
	movei	T3,T1		;rcm file:=(sys)dsk:stdnam
	setrcf	T3,	;so "resrun" in uuocon will work
	movem	T1,runblk+1;std nam
	movsi	T2,(sixbit/sys/)
	movem	T2,runblk	;dev=sys.
	movsi	T1,licjal
	movem	T1,runblk+5	;pass jl lic ***
	move	T1,[1,,runblk]	;run at entry+1
	jrst	upjxit

subttl various utility routines

;subroutine to output accumulator m as sixbit chars

sixmsg:	push	P,m
	move	M,[point	6,(P)]	;m=byte pointer
sixmsl:	ildb	CH,m
	jumpe	CH,mpopj	;quit	at first null byte
	addi	CH,40
	outchr	ch
	tlne	M,770000	;or end of word
	jrst	sixmsl
mpopj:	pop	P,m
	popj	P,


comment	! ckdet - check out jobs on system for detached
	ones	and others belonging to this aun
expects: a/ job number
function: if job(T1) detached and has our aun, skip rtn.
	if	job(T1) has our aun (attached or not) set f.ejob
; increment frejob if job(T1) not assigned
; increment spcjob if job(T1) in sysgan
; if job is not a candidate for attaching, (attached or
;  wrong aun or bad job no) return no skip
;
;destroy: b
!

ckdet:	move	T2,[%cnsjn]
	gettab	T2,		;get b/highest job+1=no. 1st "hiseg"
	 jsp	N,uuoerr
	caile	T1,-1(T2)	;if job no>highest existing job,
	 popj	P,		;say it can't be attached to.
	hrl	T2,T1
	hrri	T2,jbtaun
	gettab	T2,
	  jsp	N,uuoerr
	jumpe	T2,[aos frejob	;unoccupied job,count it
		   jrst cpopj]	;noskip rtn
	hlrz	M,T2
	cain	M,sysgan
	 aos	spcjob		;this is a special one
	came	T2,inaun
	 popj	P,
	tlo	F,f.ejob	;note that there exists job this aun already
	hrl	T2,T1
	hrri	T2,jbtlin
	gettab	T2,	;get b/sixbit "tty###" or 0,,###
	  jsp	N,uuoerr
	jumpe	T2,cpopj	;no name or something
	tlnn	T2,-1		;lh is tty if not det
cpopj1:	aos	(P)
cpopj:	popj	P,


comment	! routine frechk
function: to set f.mor if user is to be allowed to create
	a	new job & occupy another job number.
	set	f.mor if frejob.ne.0 and
	user	is in sysgan, or if frejob.ne.0 ,user
	in	another gan, and frejob.gt.(sysres-spcjob)
expects: frejob/ count of job nos. whose jna is reset
	 spcjob/	count of jobs logged in from gan (sysgan)
	f.mor/	0
clobbers:	T1,T2
!
frechk:	skipn	T2,frejob	;any	free?
	popj	P,	;no
	hlrz	T1,inaun
	cain	T1,sysgan	;system?
	jrst	freck1	;yes, ok if any slots
	add	T2,spcjob
	caile	T2,sysres	;if not must be enough slots left
freck1:	tlo	F,f.mor
	popj	P,


comment	! routine fndusr
function: skip if user is in LUD
expects: LUD open on chann ufd
	hshblk/	set up
	hshnam/	set up
	cmd/	200 WD io command list
destroy:	T1,T2,WD and former contents of buf (200 wrds)
returns: WD/ index in buf of the LUD entry

!
fndusr:	move	T1,hshnam
	move	T2,hshblk
	addi	T2,1
srus1:	hrrzm	T2,usrblk#	;save	for changing broadcast bits
	useti	ufd,(T2)
	input	ufd,cmd
srus0:	movei	WD,0
srusr:	camn	T1,buf+lhun(WD)
	 jrst	cpopj1		;found
nuser:	skipg	T2,buf+lppn(WD)
	 jrst	blklnk
	move	T2,buf+llink(WD)
	andi	T2,177
	add	WD,T2
	caile	WD,177
	 popj	P,		;LUD is bad
	jrst	srusr

blklnk:	jumpe	T2,cpopj	;invalid user
	hrrz	T2,T2		;isolate the pointer to next block
	camg	T2,usrblk	;must always go forward
	popj	P,
	jrst	srus1	;set block numbeer and read


;routine to hash values in n & n1 and return then hashed value in
;  register a and the block number in register n1

hashit:	move	T1,[555555555555]
	move	T2,[361275431652]
	move	T3,[612754316523]
	movei	WD,0
	pushj	P,rnd
	pushj	P,rnd
	pushj	P,rnd
	pushj	P,rnd
	xor	T3,T2
	move	N,T3
	tlz	N,400000
	idivi	N,LUDhsh
	xor	T1,T3
	popj	P,

;randomizer for LUD hashing

rnd:	add	T2,n
	rotc	N,-22
	movei	BP,5
rnd1:	move	T4,T2(WD)
	mul	T4,[5*5*5*5*5*5*5*5*5*5*5*5*5*5*5]	;5^15
	addm	T5,T3(WD)
	aoje	WD,rnd2
	movni	WD,1
	trne	T2,1
	skipl	T3
		movei	WD,0
	exch	T1,T3
rnd2:	sojg	BP,rnd1
	popj	P,

;get	chr from input

tyi:	inchwl	ch	;here in case no hibernate uuo
	andi	CH,177	;mask to character
	jumpe	CH,tyi	;ignore nulls
	cain	CH,177	;and rubouts
	jrst	tyi
	cain	CH,cntrlc
	jrst	comout	;get out on ^c
	cain	CH,escchr
	jrst	comout	;get out on "esc"
	cail	CH,140
	subi	CH,40
	popj	P,


comment ! routine CHSEMI
function:  see if previous input terminator was ";",
	set proper flag if so, and exit. Check for CR LF and
	suck them in & echo them .
call:  pushj	P,chsemi
	tlx	F,flag	;this gets xct'd if ch/semi
	always	return here
expects:  ch/ term chr last input
!

chsemi:	cain	CH,";"
	 xct	@(P)
	outchr	ch	;echo it (port is in no-echo mode)
	caie	CH,CR
	 jrst	cpopj1
	pushj	P,tyi	;get LF
	outchr	ch
	jrst	cpopj1



comment ! routine RDNAM..reads username in login string
expects:  ch/ 1st char of name
returns:  ch/ terminating char, name/ username, (skip return)
	or	(error return) if too many characters for field (12 max)
destroys:	WD,bp
!
;put 12-char string into "name", a pseudonym for
;the project-code spot in login stream records. ascii
rdnam:	movei	WD,^d12		;read 12 character name
	setzm	name
	setzm	name+1
	move	BP,[point 6,name]
rdlp:	caie	CH,";"		;Username terminated by semicolon
	cain	CH,CR		; or carriage return
	 jrst	cpopj1
	SKIPGE	ORGAUN		;If getting username from PTY,
	 OUTCHR	CH		; then echo characters
	subi	CH,40
	JUMPL	CH,RDLPB	;Ignore ^A,^B,^C,^D,^I,^V gouging characters
	sojl	WD,cpopj	;deposit up to ^d12 chars
	idpb	CH,bp
RDLPB:	pushj	P,tyi
	jrst	rdlp

crlf:	outstr	[asciz /
/]
	popj	P,

octprt:	movei	R,^d8
	jrst	rdxprt

decpr2:	caig	N,^D9
	outchr	["0"]
decprt:	movei	R,^D10
rdxprt:	idivi	N,(r)
	hrlm	n+1,0(P)
	skipe	n
	pushj	P,rdxprt
	hlrz	CH,0(P)
	addi	CH,"0"
	outchr	ch
	popj	P,


rdnam1:	movei	WD,^d12
	setzm	name
	setzm	name+1
	setzm	name+2
	move	BP,[point	7,name]
rdlp1:	pushj	P,tyi
	caie	CH,";"
	cain	CH,CR
	popj	P,
	sojl	WD,rdlp1
	idpb	CH,bp
	jrst	rdlp1


comment	! SETINT;  set up timer,zapper interrupts & set
	initial	timeout for (M) sec by falling into RSTTIM.  Both
	timer	and zapper are armed on channel 1 to cause
	control	to go to COMOUT where LOGINN cleans up
	and	goes away.
expects: m/ sec
!

setint:	movei	CH,comout
	movem	CH,inttab+1	;set	up interupts
	move	CH,[4B17+2B17+inttab]	;IA.REE+IA.CLR+trap vector addr
	intadr	CH,
	 jsp	N,uuoerr
	movei	CH,0
	settim	CH,	;reset timer
	 jsp	N,uuoerr
	move	CH,[timcas,,1]	;timer on chl 1
	intass	CH,
	 jsp	N,uuoerr
	.IAZAP==7	;zapper-seen cause
	move	CH,[<.IAZAP>B8+1B17+777777] ;assign also to channel 1
	tinass	CH,	;on command port
	 jrst	comout	;Race condition - there is no command port
	movsi	CH,(1B0+1B1)
	intenb	CH,	;enable channel
	 jsp	N,uuoerr
	PFALL	rsttim	;fall thru

comment ! routine RSTTIM
function: set up timer for new timeout
expects:  m/ seconds
!
rsttim:	hrli	M,1	;m/	1,,seconds
	settim	M,
	 jsp	N,uuoerr
	popj	P,

clrtim:	movei	M,0	;routine	to turn off timer completely
	settim	M,
	 jsp	N,uuoerr
	popj	P,


comment	! Routines to do KS2020 special processing !

	array	pwcmd[2]
	array	pwbuf[200]
	integer	savWD

;getpas - routine to get the password

getpas:	tlne	F,f.half		;see	if half duplex
	 pushj	P,prtmsk	;yes,go print mask
;fall through from above

getpa2:	pushj	P,tyi		;get next char
	pushj	P,get12		;get 12 char in T1 & T2
	movem	T1,lftpas
	movem	T2,rtpas
	pushj	P,testch	;see if password done
	 jrst	getpa4		;yes, exit
	pushj	P,get12		;get next 12
	rot	T1,2		;shift to preserve position
	rot	T2,2
	xorm	T1,lftpas	;xor to rest
	xorm	T2,rtpas
	pushj	P,testch	;see if done
	 jrst	getpa4		;yes, exit
	pushj	P,get12		;get next 12
	rot	T1,4
	rot	T2,4
	xorm	T1,lftpas
	xorm	T2,rtpas
	pushj	P,testch	;see if done
	 jrst	getpa4
getpa3:	pushj	P,tyi		;ignore password after 36 char
	pushj	P,testch
	 jrst	getpa4		;exit
	jrst	getpa3		;loop until past password

getpa4: move	N,lftpas	;set up for hash routine
	move	N1,rtpas
	pushj	P,hashit	;go hash it
	movem	T1,hpw		;save hashed password
	movem	N1,pblknum	;save block number in pass file
	popj	P,		;now exit

;subroutine to see if ch = ";" or less than 40
;  return if it is, skip return if not

testch:	cain	CH,";"
	 popj	P,
	caige	CH,40
	 popj	P,
	jrst	cpopj1		;no, skip return

; subroutine to print 15 character mask for password

prtmsk:	outstr	[asciz /
/]
	outstr	[asciz /###############/]
	outchi	CR
	outstr	[asciz /***************/]
	outchi	CR
	outstr	[asciz /OOOOOOOOOOOOOOO/]
	outchi	CR
	popj	P,

; subroutine to check for half duplex line

seehaf:	setz	T1,
	getlch	T1		;get	line characteristics
	tlne	T1,10000	;see if half duplex
	 tlo	F,f.half	;yes, set half duplex flag
	popj	P,

;subroutine to get up to 12 char and store them in a and b

get12:	movei	WD,^d12		;initialize char. count
	setz	T1,
	setz	T2,
	move	BP,[point 6,T1]
get12a:	caie	CH,";"
	caige	CH,40
	 popj	P,		;found not valid letter

	sosge	WD		;skip if not done
	 popj	P,		;done 12, exit
	subi	CH,40
	idpb	CH,bp		;store character
	pushj	P,tyi		;get next char
	jrst	get12a		;loop back for next character

;subroutine to find if password is in PAS.SYS file, and that it
;  correct for the user name. Skip return if found, non-skip
;  if not found or not correct for user name.
;Destroys registers	T1-T4

fndpas:	movei	T1,17
	
	hrli	T1,400000		;physical only
	move	T2,[ioWD 200,pwbuf]
	movem	T2,pwcmd		;set up ioword for password file read
	movsi	T2,'SYS'
	movei	T3,0
	
	open	pasio,T1		;physical only, dump mode
	 jsp	N,syserr
	movsi	T1,(sixbit/PAS/)
	movsi	T2,(sixbit/SYS/)
	movei	T3,0
	move	T4,sysppn
	lookup	pasio,T1		;lookup PAS.SYS in sysppn directory
	 jrst	nopas			;***** lookupfailed
	move	T1,hpw			;hashed password
	move	T3,hshnam		;hashed username
	move	T2,hshblk		;hashed user name block number
	addi	T2,1
fndp1:	hrrzm	T2,pasblk#		;save for varifing forward search
	useti	pasio,(T2)		;get block
	input	pasio,pwcmd
fndp2:	movei	WD,0
fndp3:	came	T3,pwbuf+phun(WD)	;see if match on hashed name
	 jrst	fndp4			;no, go get next entry
	camn	T1,pwbuf+ppw(WD)	;check match on hashed user password
	 jrst	skip			;found, skip return
;on not found fall through

fndp4:	addi	WD,pentsz		;position to next entry
	caige	WD,^d128/pentsz*pentsz -pentsz ;are we at end?
	 jrst	fndp3			;no
	hrrz	T2,pwbuf+phun(WD)	;get pointer to next block
	skipg	T2			;got pointer if non zero
	 jrst	noskp			;exit, not found
	camg	T2,usrblk		;must move forward in file
	 jrst	noskp			;exit, not found
	jrst	fndp1			;go read next block

noskp:	releas	pasio,			;release channel
	popj	P,			;non skip return, not found

skip:	releas	pasio			;release pas file channel
	jrst	cpopj1			;skip return, found mtch

comment ! end of special KS2020 routines !
noLUD:	outstr	[asciz /
can not access LUD/]

comment ! COMOUT..common LOGINN panic/error exit.  Something
	has gone wrong so we attempt to clean up and leave.
	Timer/zapper interrupts come here.
!

comout:	clrbfi				;clear input so no garbage printed
	hrroi	T1,.gtsts		;get jbtsts
	gettab	T1,
	 movsi	T1,jlog			;say logged in
	tlnn	T1,jlog			;login uuo done yet?
	 logout				;no,this is sufficient
	move	T2,[XWD runblk,runblk+1]
	setzm	runblk
	blt	T2,runblk+5		;zero runblk
	move	T2,[sixbit /logout/]
	movem	T2,runblk+1
	movsi	T2,(sixbit /sys/)
	movem	T2,runblk
	move	T1,[1,,runblk]		;fake an xexec "exit" command
	run	T1,
	  halt				;monitor takes this if fails



notval:	outstr	[asciz /
not valid user on this computer/]
	jrst	comout

badpas: sosg bdpwct			;if allowed number of failures exceeded
	 jrst	comout			;if yes then get out
	clrbfi				;clear the input buffer
	tlz	F,fl.npt		;clear the no prompt for project code
	outstr	[asciz /
error, type password: /]
	pushj	P,getpas		;get password again
	pushj	P,fndpas		;test again
	 jrst	badpas			;still didnt match
	popj	P,

alrdin:	outstr	[asciz /
already logged in/]
	exit	;this code is for people who .R LOGINN

alredy: move	M,innam
	pushj	P,sixmsg
	skipe	M,innam1
	pushj	P,sixmsg
	outstr	[asciz / already logged in/]
	jrst	comout		;this code for those with lonejb who
				;try to log in a second job

jcapyx:	outstr	[asciz /
job capacity exceeded/]
	jrst	comout		;here for no more slots to log him in

notvl1:	outstr	[asciz /
can not login under this user name/]
	jrst	comout

rstrct:	outstr	[asciz /
restricted/]
	jrst	comout		;do not let him in

syshut: outstr [asciz /
host shut/]
	jrst	comout		;do not let him in

repmsg:	asciz /
system problem, please see your representative/

nopas:	outstr	[asciz /
can not access PAS file/]
	jrst	comout


	;get	here with T2/licenses we've currently got
	;some	are missing. send special msg to users
	;in	case licopr is missing & cty doesnt get msg
licerr:	movei	T1,[asciz/
system problem "L", please see your representative/]
	movei	T2,[asciz /
loginn program missing license(s)
/]
	pushj	P,errmsg
	jrst	comout

uuoerr:
jalerr:
syserr:
	movei	T2,[asciz /
loginn program uuo failure at /]
	movei	T1,repmsg
	pushj	P,errmsg
; Now append UUO address to CTY message
	subi	N,2		;Adjust JSP return to address of UUO
	movei	T1,6		;Counter for octal address type-out
	push	P,T1		;Save count, since T1 is needed
	hrlz	N,n		;Set up octal address for loop
	move	T1,[point 7,T2-1,35] ;ASCII byte pointer into T2-T3
	setzb	T2,T3		;String storage
uuoer1:	hrri	N,"0"_-3	;High-order four bits of ASCII digit
	rot	N,3		;Shift in low-order three bits
	idpb	N,T1		;Build string in T2-T3
	sosle	(P)		;Loop on count
	jrst	uuoer1		;Back for more
	ior	T3,[byte (7) 0,CR,LF,CR,LF] ;Add CR-LF's after 6th digit
	move	T1,[suumsg,,T2]	;Arg word for SETUUO
	setuuo	T1,		;Write address to CTY
	  jfcl
	pop	P,T1		;Adjust stack
	jrst	comout		;Die ignobly


comment ! routine errmsg
function: type the asciz at T1 to the user, setuuo the
	asciz at T2 to cty & opr tty (will fail if licopr missing)
destroy: lh of T2
!
errmsg: outstr	(T1)
	hrli	T2,suumsg
	setuuo	T2,
	  jfcl
	popj	P,
COMMENT ! ROUTINE ACCT
FUNCTION:  LOG THE USER INTO SYSTEM (SET JBTAUN,PRV,PPN,UNM/UN1
	VIA	LOGIN UUO) AND PUT HIS STREAM ACCOUNTING LOGIN RECORD
	INTO	STREAM IF POSSIBLE.
EXPECTS:  STREAM RECORD ALREADY PARTIALLY COMPOSED IN STMDAT
	ARRAY	(RDNAM1 PUTS PJC THERE).
	  ARRAY	LOGTAB SET UP FOR LOGIN UUO.
!

ACCT:
	move	T1,[XWD -logsiz,logtab]
  ife deb,<
	login	T1,		;***do the login uuo***
	jfcl	;(so it returns)
	 >;end	ife deb. No UUO if debugging
	hrroi	T1,.gtsts
	gettab	T1,
	  jsp	N,uuoerr	;failed,bomb him out
	tlz	T1,jacct
	setjal	T1,		;clear jacct in jbtsts
	  jfcl

	move	T1,stmhed
	movem	T1,stmdat	;login type record header word
	hrroi	T1,jbtlog
	gettab	T1,
	 jsp	N,uuoerr	;sorry
	movem	T1,stmdat+6	;supervisor info
	ldb	T1,[point 4,T1,11];terminal type
	dpb	T1,[point 12,stmdat,29]
	pjob	T1,		;job no.
	dpb	T1,[point 9,stmdat,17]
	move	T1,inaun	;users aun to word 2
	movem	T1,stmdat+2
	movei	T1,s.shov	;get location of shut override bit
	andcam	T1,stmdat+5	;make sure bit clear
	tlne	F,fl.sts	;skip if shut override not set
	iorm	T1,stmdat+5	;indicate shut over was on in stream
	movei	T1,stmdat	;monitor will date-stamp
	putsar	T1,		;this stream record
	 jrst	acctf		;failed, analyze
	popj	P,
;-this rec contains pjc in words 3,4,5 written by rdnam1.

acctf:	jumpe	T1,cpopj	;T1=err code from putsar. 0 means no acctg for sys
	movei	T1,repmsg
	movei	T2,[asciz /
loginn bad putsar arguments. potential
acct'g problem. leave system up. notify o.s. group
/]
	pushj	P,errmsg	;tell user one thing & oper the other
	popj	P,		;go on without login record
subttl type date, time, and message of the day
inmss:	mstime	T1,
	idivi	T1,^d1000	;to minutes
	hrrm	T1,datime
	date	T1,
	hrlm	T1,datime
	movsi	T1,lnomes
	tdne	T1,inbits	;should this user get the tymshare msg?
	 jrst	inmss2		;no
	outstr	[asciz /
tymshare  /]
	hrrz	T1,datime
	idivi	T1,^d60
	idivi	T1,^d60		;now break in mins and hrs
	move	N,T1		;hours
	pushj	P,decpr2
	move	N,T2		;minutes
	pushj	P,decpr2
	outchr	[11]
	hlrz	T1,datime
	pushj	P,datpr
inmss2:	tlz	F,f.bcast	;no broadcast letters yet
	movei	T1,lleta	;are there any?
	tdnn	T1,inbits
	 jrst	lokmal		;no, see if mail waiting
	tlo	F,f.bcast	;yes, remember to send
	movei	T1,16
	hrli	T1,400000	;physical only
	movsi	T2,'DSK'
	movei	T3,0
	open	ufd,T1
	 jrst	gotmal		;can't get LUD, just say mail
	movsi	T1,(sixbit /LUD/)
	movsi	T2,(sixbit /SYS/)
	movei	T3,0
	move	T4,sysppn
	lookup	ufd,T1
	 jrst	gotmal		;again, can't get it
	movei	N,^d12		;number of times to try
entLUD:	movei	T3,0
	move	T4,sysppn
	enter	ufd,T1		;get LUD in update mode
	 jrst	LUDbsy		;busy
	pushj	P,fndusr	;find this user
	 jrst	gotmal		;can't, say mail waiting
	movei	T1,lleta
	andcam	T1,buf+lbits(WD);reset bits
	useto	ufd,@usrblk
	output	ufd,cmd
	close	ufd,0
	jrst	lokmal		;now send and see about mail

LUDbsy:	sojl	N,gotmal	;give up waiting
	movei	T4,^d10
	sleep	T4,		;wait
	jrst	entLUD		;and retry
comment ! lokmal
function: 1)type any broadcast letters from (sys)xoblam
	if user's LUD entry had letter bits on. update the
	xoblam file letter "already sent" counts if possible.
	2) see if "mail" is waiting in (sys)xoblam
	for non-japan-exec-mode (gemode) users, or (sys)xobnpo
	for japan-exec users; type "opnotice waiting" (japan user)
	or "mail waiting" (other users).
(For further understanding, refer to RPG.MAC SEND & MAIL code
where a description of the mail structure lives.)
!

; check for new style mail and print message
;	if (MAIL)aun.MAI exists
;
LOKMAL:	movei	T1,16
	hrli	T1,400000
	movsi	T2,'DSK'
	movei	T3,0
	open	ufd,T1
		jrst	nomail
	move	T1,inaun		; file (MAIL)aun.MAI
	movsi	T2,(sixbit "MAI")
	setz	T3,
	movei	T4,[sixbit "MAIL"
		exp	0]
	lookup	ufd,T1
	 jrst	lokma2
	ldb	T1,[point 2,inprv,28]	;his jbtprv mode
	cain	T1,gemode
	 skipa	T1,[[asciz /[opnotice waiting]
/]]
	 movei	T1,[asciz /[mail waiting]
/]
	outstr	(T1)

lokma2:	ldb	T1,[point 2,inprv,28]	;his jbtprv mode
	cain	T1,gemode
	 tlo	F,f.gem
	tlnn	F,f.bcast	;do any broadcast letters exist
	 jrst	lkml2		;no
	move	T1,[sixbit /xoblam/]
	setzb	T2,T3
	move	T4,sysppn
	lookup	ufd,T1
	 jrst	nomail
	pushj	P,sendbc	;send them
	release	ufd,0		;possibly updating (sys)xoblam
lkml2:	movei	T1,16
	hrli	T1,400000
	movsi	T2,'DSK'
	movei	T3,0
	open	ufd,T1
	jrst	nomail
	setzb	T2,T3
	move	T4,sysppn
	tlne	F,f.gem
	skipa	T1,[sixbit/xobnpo/]	;"opnbox"--opnotice box
	move	T1,[sixbit/xoblam/]		;"malbox" - for non-japan
	lookup	ufd,T1		;lookup (sys)xob###
	jrst	nomail
	move	T1,innam	;find hash
	add	T1,innam+1
	tlz	T1,400000
	idivi	T1,malhsh
	useti	ufd,2(T2)	;this is the block he should be in
	move	T1,innam	;get ready to search
	move	T2,innam+1
nxmbk:	input	ufd,cmd
	move	T3,[XWD -40,0]	;40, 4-word blocks
msrc:	skipn	buf(T3)	;zero is end of mail
	jrst	nomail
	camn	T1,buf(T3)
	came	T2,buf+1(T3)
	skipa
	jrst	gotmal		;found some
	addi	T3,3
	aobjn	T3,msrc
	jrst	nxmbk		;read next block and try it
gotmal:
	ldb	T1,[point 2,inprv,28]	;if ge-(japan) mode, dont
	cain	T1,gemode	;use the word "mail"--japanese dont like
	skipa	T1,[exp [asciz /
opnotice waiting
/]  ]
	movei	T1,[asciz /
mail waiting
/]
	outstr	(T1)
nomail:	close	ufd,0
	popj	P,
datpr:	idivi	T1,^d31		;the usual date printer
	movei	N,1(T2)		;day of month
	pushj	P,decpr2
	idivi	T1,^d12		;month and year
	move	T2,montab(T2)
	movem	T2,datemp
	setzm	datemp+1	;for asciz, ddtout
	outstr	datemp
	movei	N,^d1964(T1)	;year
	pushj	P,decpr2
	pjrst	crlf

array datemp[2]

montab:	ascii	/-jan-/
	ascii	/-feb-/
	ascii	/-mar-/
	ascii	/-apr-/
	ascii	/-may-/
	ascii	/-jun-/
	ascii	/-jul-/
	ascii	/-aug-/
	ascii	/-sep-/
	ascii	/-oct-/
	ascii	/-nov-/
	ascii	/-dec-/
comment ! SENDBC; send Broadcast Letters.  !

sendbc:	movei	N,^d12		;set to wait a whille
entmal:	movei	T3,0
	move	T4,sysppn
	enter	ufd,T1
	  jrst	malbsy		;try again later
malset:	movei	T1,lleT1
	movei	T2,1
nxbrd:	tdne	T1,inbits	;send this one?
	 pushj	P,brdcst	;yes
	trne	T1,llete	;last one to look at?
	 popj	P,		;yes, done
	lsh	T1,1
	aoja	T2,nxbrd

malbsy:	movei	T4,^d10
	sleep	T4,
	sojge	N,entmal	;try again
	tlz	F,f.bcast	;send anyway but don't change count
	jrst	malset

brdcst:	move	T3,T2
	trnn	T3,1		;which half
	 tdza	WD,WD
	movei	WD,100
	lsh	T3,-1		;which block
	useti	ufd,202(T3)
	input	ufd,cmd
	date	T4,		;get current date
	sosl	buf+malcnt(WD)	;if count is 0
	caml	T4,buf+malexp(WD);or mail expired
	 popj	P,		;don't print
	skipn	buf+malnam(WD)	;also if name has gone to 0
	 popj	P,
	push	P,T1
	push	P,T2
	move	T1,buf+maldat(WD)	;print date
	pushj	P,datpr
	outstr	buf+maltxt(WD)	;and text of letter
	outstr	[asciz /
/]
	pop	P,T2
	pop	P,T1
	tlnn	F,f.bcast	;do we have mailbox in update?
	 popj	P,
	useto	ufd,202(T3)
	output	ufd,cmd		;change count
	popj	P,
comment ! INOPR;  stuff to do when OPERs are logging in !

inopr:	hrroi	T1,jbtlog
	gettab	T1,
	  jsp	N,uuoerr
	tlnn	T1,037700	;is the TID zero?
	 popj	P,		;no, assume aux circuit of some kind
	move	T1,inaun	;do these things for OPERs only
	came	T1,[1,,21]	;This is the known PPN for OPER
	 popj	P,
	move	T1,[%nsalm]
	gettab	T1,		;get alarms
	  jsp	N,uuoerr
	trne	T1,almcty
	 outstr	[asciz /
message on console teletype
/]
	move	T1,[%cnopr]
	gettab	T1,
	  jsp	N,uuoerr
	jumpn	T1,cpopj
	movsi	T1,suuopr		;no opr set
	setuuo	T1,
	  popj	P,
	outstr	[asciz /
no opr terminal - set opr done for this terminal
/]
	popj	P,
subttl login stream rec def'n & buffers

logtyp==40	;stream record type for login records
loglng==7	;length
stmhed:	byte	(9)logtyp,0 (18)loglng
array stmdat[loglng]	;"acct" composes rec in this buffer.
lvar
name==stmdat+3	;this is how pjc gets into login record
subttl UFDSET--check out user's files, make ufd if needed
;subroutine to set up a ufd for use  v002
;	T1=status bits
;	T2=first come first served quota
;	T3=logged out quota
;	M=name of str
;	CH=accumulator to contain char to be typed
;	F=flag register
;	P=push down list pointer
;
;if T3=-1 assume no ufd desired - perform other operations
;
;	usr=free i/o channel
;	us1=free i/o channel
;
;call	pushj	P,ufdset
;	  error		dont proceed (message typed)
;	ok		str is in search list (warning may be typed)


;assumes symbols for ac's above defined, locations cpopj, cpopj1 defined
;
;uses u and uu macros to reserve storage for either high or low
;segment operation.
;
;routines defined here:
;
;msg:		types string of ascii chars to first null
;sixmsg:	types contents of m as sixbit chars
;crlf:		types carriage return line feed
;octprt:	types contents of n as octal number
;mpopj:		<pop P,m> follwed by <popj P,>
;r.usr:		reads next word from channel usr into a (buffer header rh.usr, buffer b.usr)
;addstr:	add file structure to search list
;disstr:	delete file structure from search list

mntsub==1		;declare in case dismount subroutine also appears
ufdgil==^d<7*60>	;times to try to get ufd interlock (LOGOUT uses 6*60)
;arguments for extended lookup, enter, rename

;-exllen==34	;length arg list, before pjc facility
exllen==41	;new length, 3 new rib locns for pjc,etc.
exlppn==1	;directory name
exlnam==2	;file name
exlext==3	;ext
exlalc==11	;blocks allocated for file
exldev==16	;device on which file looked up is
exlsts==17	;status bits
  riplog==400000	;lh bit is logged in bit
  ripdir==400000	;rh bit is directory bit
exlmxa==24	;reserved quota
exlqtf==22	;first come, first served quota
exlqto==23	;logged-out quota
exlusd==25	;blocks used
exlun1==27	;first part of user name in dir
exlun2==30	;second part of user name in dir
exltru==31
exlalp==33

chrufb==1	;ufbtal word
chrlen==14	;length of dskchr block
  d.mc==10000	;bit in lh of dskchr ac return=1 if mount count=0

;STRUUO definitions
srcdsl==1	;function to set new search list
  strjmx==9	;maximum number of strs per job
  srwps==3	;words per str entry in search list
  s.swl==400000	;software write lock
s.ncr==200000	;no create bit
rdffst==3	;struuo function to redefine file structure ***
  s.sin==200000	;single access
ulkstr==6	;struuo function to test/set ufd interlock
uclstr==7	;struuo function to clear ufd interlock
ufperr==100000	;bit on sez some ripxxx bit on,lookup file


gobjob==0	;index for job number in arg list
gobppn==1	;index for ppn
gobnam==2	;index for str name


	define	ufdsem(text)<
	xlist
	movei	N1,[asciz \text\]
	jrst	ufdsmp
	list
>

array	srcbuf[exllen],chrbuf[chrlen],secbuf[exlsts+1]
array ufnarg[10],ufnbuf[4*^d102]
lvar


subttl	UFDSET routine

ufdset:	movem	M,ufdfsn	;and name of str
	movei	N,0		;n=reserved quota
	move	M,T2		;m=fcfs quota fr LUD conv to pgs aaa
	move	CH,T3		;ch=logged out quota,also in pgs
	move	WD,T1		;satus bits
	movei	N1,ufdgil	;number of times to try for ufd interlock
ufdsta:	movei	T2,ulkstr	;user-mode ufd interlock function
	pushj	P,stufc1	;test/set ufd interlock
	  jrst	stufbs		;busy, sleep and retry
	move	T2,ufdfsn
	movei	T1,17
	hrli	T1,400000
	movei	T3,rh.usr ;inbuf needs a buffer ring hder. aaa
	open	usr,T1		;init this file structure
	  jrst	ufdse2		;how can this be?
	inbuf	usr,1;this looks unnecessary to me.aaa	;declare our 1 buffer
	pushj	P,setexl	;set up srcbuf for extended lookup of ufd
	setzb	T3,srcbuf+4	;clear rest of lookup block
	move	T1,[XWD srcbuf+4,srcbuf+5]
	blt	T1,srcbuf+exllen-1
	lookup	usr,srcbuf	;lookup ufd
	  skipa	T1,srcbuf+exlext	;get error code in T1
	 jrst	ufdex		;ufd exists, look at it
	trne	T1,-1		;skip if no ufd
	jrst	ufdse3		;there's something wrong with this ufd

;here if must create a ufd

	movem	N,srcbuf+exlmxa	;store maximum
	movem	M,srcbuf+exlqtf	;and fcfs
	movem	CH,srcbuf+exlqto ;and logged out quota
	setzm	srcbuf+exltru	;zero this when creating a ufd
	tlz	F,fl.fuf		;so it does not look like out of time
	pushj	P,setexl	;set up for extended enter of ufd
	move	T1,[XWD riplog,ripdir]	;set directory bit and logged in bit
	movem	T1,srcbuf+exlsts
	move	T1,innam
	movem	T1,srcbuf+exlun1
	move	T1,innam1
	movem	T1,srcbuf+exlun2
	enter	usr,srcbuf	;try to create a ufd
	  jrst	ufdse1		;identify enter failure
	close	usr,		;an empty ufd
	jrst	ufdok		;all set

;here if ufd already exists

ufdex:	movem	M,srcbuf+exlqtf	;and	fcfs
	movem	CH,srcbuf+exlqto ;and logged out quota
	tlze	F,fl.fuf
	jrst	chktru	;tru need checking
oktru:	movsi	T1,riplog!ripbfa!ripcrh!riphre!riphwe!ripbdr!ripbda	;logged	in bit and error bits
	tdnn	T1,srcbuf+exlsts	;skip if bit on in ufd
	jrst	ufdex2		;no, can proceed
	move	T2,[%cnsjn]
	gettab	T2,		;get number of jobs
	 jsp	N,uuoerr
	movni	T2,-1(T2)
	hrlzs	T2
	pjob	T5,			;e:=this job. aaa
ufdex1:	move	T3,ufdfsn
	movem	T3,chrbuf+gobnam
	move	T3,inppn
	movem	T3,chrbuf+gobppn
	movei	T3,1(T2)	;job
	camn	T3,T5		;dont	look at this job
	jrst	.fdex2		;keep looking at others
	movem	T3,chrbuf+gobjob
	movei	T3,chrbuf
	gobstr	T3,
	 skipa	;not in this jobs search list or not same ppn
	jrst	ufdex5	;go
.fdex2:	aobjn	T2,ufdex1
	andcam	T1,srcbuf+exlsts	;reset
	movsi	T1,riplog
	iorm	T1,srcbuf+exlsts	;and	set logged in

;here to lookup all files and recompute ribusd

	setzb	T1,T3
	hrli	T1,400000
	move	T2,ufdfsn
	open	us1,T1		;open file structure
	  jrst	ufdse2
	setzm	srcbuf+exlusd	;clear used word
	move	T1,[-4*^d102,,ufnbuf]
	movem	T1,ufnarg
	movsi	T1,(sixbit/*/)
	movem	T1,ufnarg+1
	movem	T1,ufnarg+2	;file *.*
	setzm	ufnarg+4
	movsi	T1,220000
	movem	T1,ufnarg+3
allk0:	move	T1,[.CHUFD,,usr]
	chanio	T1,ufnarg
	  jrst	ufdrer
	move	T3,ufnarg
allk1:	sosge	ufnarg+7
	jrst	allk0
	move	T1,(T3)
	movem	T1,secbuf+exlnam
	move	T1,1(T3)
	movem	T1,secbuf+exlext
	move	T1,inppn	;user's ppn
	movem	T1,secbuf+exlppn
	movei	T1,exlalp
	movem	T1,secbuf	;set number of args to get alp word
	move	T1,2(T3)
	jumpl	T1,allku	;lookup required
	movei	T2,ufperr
	tdne	T2,3(T3)	;check special status flag
	jrst	allku
	ash	T1,-2		;kludge convert blocks->pgs.aaa.dec 76
	addm	T1,srcbuf+exlusd
allk2:	addi	T3,4
	jrst	allk1

allku:	lookup	us1,secbuf	;lookup file
	jrst	[hrrz	T1,secbuf+exlext ;did this fail because
		caie	T1,6		;of a rib error?
		 jrst	allk2		;no.
		movsi	T1,ripbdr	;yes, warn the
		jrst	allk4]		;user.
	move	T1,secbuf+exlalp ;get blocks allocated for this file
	addm	T1,srcbuf+exlusd ;count for all files
	hrlz	T1,secbuf+exlsts
	tlne	T1,ripcrh
	 pushj	P,crhfil
	tlne	T1,ripbfa
	 pushj	P,bfafil
	tlne	T1,ripbda
	 pushj	P,bdafil
allk4:	tlne	T1,ripbdr
	 pushj	P,bdrfil
	tlne	T1,riphwe
	 pushj	P,hwefil
	tlne	T1,riphre
	 pushj	P,hrefil
	and	T1,[XWD	ripbfa!ripcrh!riphre!riphwe!ripbdr!ripbda,0]
	iorm	T1,srcbuf+exlsts	;put bits back in dir
	jrst	allk2
strfil:	move	M,ufdfsn
	pushj	P,sixmsg
	outchr	[":"]
	move	M,secbuf+exlnam
	pushj	P,sixmsg
	hllz	M,secbuf+exlext
	jumpe	M,cpopj
	outchr	["."]
	pjrst	sixmsg

crhfil:	pushj	P,strfil
	outstr	[asciz / partially written file closed after monitor stopped
/]
	popj	P,

bfafil:	pushj	P,strfil
	outstr	[asciz / found bad by restore
/]
	popj	P,

bdafil:	pushj	P,strfil
	outstr	[asciz / found bad by damage assessment program
/]
	popj	P,

bdrfil:	pushj	P,strfil
	outstr	[asciz / rib error
/]
	popj	P,

hrefil:	pushj	P,strfil
	outstr	[asciz / hardware data read error detected
/]
	popj	P,

hwefil:	pushj	P,strfil
	outstr	[asciz / hardware data write error detected
/]
	popj	P,

chktru:	tlne	F,fl.rst	;is	system restrict bit on
	skipge	T1,intru	;and really a limit there?
	jrst	oktru	;no to either, ok
	caml	T1,srcbuf+exltru	;is it exceeded
	jrst	oktru
	tlo	F,fl.fuf
	pushj	P,stufcl	;clear interlock
	 jrst	cpopj1
	jrst	cpopj1

;here if read error (may be eof)

ufdrer:	close	us1,
	getsts	usr,T1		;a=error	code
	movei	M,[asciz / ufd read error, status = /]
	trnn	T1,20000		;skip if error, not eof
	jrst	ufdse4		;tell user about error, no ufd
	jrst	ufdex3		;all set


ufdex2:	movsi	T1,riplog	;here	fr oktru+2 when no err bits on in ufd ribsts
	iorm	T1,srcbuf+exlsts	;make sure logged in bit on
ufdex5:	setom	srcbuf+exlusd	;use	monitor's copy of ufbtal to compute ribusd
ufdex3:	move	T1,innam
	movem	T1,srcbuf+exlun1
	move	T1,innam1
	movem	T1,srcbuf+exlun2
	setom	srcbuf+exlmxa
	pushj	P,setexl	;set	up srcbuf for extended rename
  ife deb,<
	rename	usr,srcbuf
	  skipa	T1,srcbuf+exlext
	 >;end	ife deb. Leave UFD alone if debugging
	jrst	ufdok

	movei	M,[asciz / ufd rename failure /]
	jrst	ufdse4

ufdse3:	movei	M,[asciz / ufd lookup failure /]
	tlz	F,fl.fuf	;reset flag
ufdse4:	exch	M,ufdfsn
	pushj	P,sixmsg
	exch	M,ufdfsn
	outstr	(M)
	hrrz	N,T1		;n=error	code
	pushj	P,octprt
	pushj	P,crlf
	jrst	ufdok

ufdse1:	move	M,ufdfsn
	pushj	P,sixmsg
	outstr	[asciz / ufd enter failure /]
	hrrz	N,srcbuf+exlext
	pushj	P,octprt
	outstr	[asciz /
no ufd created
/]
ufdok:
ufdok1:

;here to clear ufd interlock

	pushj	P,stufcl	;clear ufd interlock
	  jrst	cpopj1		;what?
	jrst	cpopj1		;all done

ufdsmp:	outchi	"?"
	move	M,ufdfsn
	pushj	P,sixmsg
	outchi	" "
	outstr	(n1)
	pjrst	crlf
;here when ufd interlock is busy - sleep and retry

stufbs:	trnn	N1,77		;Output	message every 64 seconds
	 outstr	[asciz /waiting for UFD interlock
/]
	movei	T1,1
	sleep	T1,		;sleep for 1 second
	sojg	N1,ufdsta
	pushj	P,stufcl	;Break down the UFD interlock (7 minutes)
	jumpe	N1,ufdsta	;One more try
	tlz	F,fl.fuf
	ufdsem	<UFD interlock busy>


ufdse2:	tlz	F,fl.fuf
	pushj	P,stufcl
		 jfcl
	ufdsem <cant open>


;subroutine to test/set or clear ufd interlock
;enter at stufcl to clear
;enter at stufc1 with b=function
;return popj if failed
;return cpopj1 if ok

stufcl:	movei	T2,uclstr
stufc1:	move	T1,[XWD	3,T2]
	move	T3,ufdfsn
	move	T4,inppn
  ife deb,<
	struuo	T1,
	  popj	P,
	 >;end	ife deb
	pjrst	cpopj1

;subroutine to set up header for extended lookup/enter/rename of ufd

setexl:	movei	T1,exllen-1	;length	of arg list
	movem	T1,srcbuf
	move	T1,inppn	;name is user's ppn
	movem	T1,srcbuf+exlnam
	movsi	T1,(sixbit .ufd.)	;ext is ufd
	movem	T1,srcbuf+exlext
	move	T1,mfdppn	;directory is mfd
	movem	T1,srcbuf+exlppn
	popj	P,

subttl	typmsg - look for dsk:access.msg and type if present

ifndef msg,<msg==0>

typmsg:	init	msg,1
	sixbit	"SYS"
	XWD	0,bufmsg
	  skipa
	pushj	P,msgtry	; try device sys
	init	msg,1
	sixbit	"DSK"
	XWD	0,bufmsg
	  jrst	msgdon
		; try	device dsk and return to main
msgtry:	move	T1,[sixbit	"ACCESS"]
	movem	T1,lkbmsg
	movsi	T1,'MSG'
	movem	T1,lkbmsg+1
	setzm	lkbmsg+3
	lookup	msg,lkbmsg
	  jrst	msgdon
	ldb	T2,[point 3,lkbmsg+2,2]	; get owner protection field
	caile	T2,prv.rd	; no lk or run?
	  jrst	msgdon	;   yes - can't read it
	setzm	twtmsg	; clear flag to ignore line numbers
msgin:	sosge	bufmsg+2
	  jrst	msginp
	ildb	T2,bufmsg+1
	jumpe	T2,msgin	; ignore nulls
	move	T1,@bufmsg+1
	trne	T1,1
	  setom	twtmsg	; set flag that this a line number
	skipe	twtmsg
	  jrst	msgtab	; skip to tab check
	cain	T2,177	; a rubout?
	  hrroi	T2,"#"-100
	cain	T2,"~"	; a tilde?
	  hrroi	T2,"%"-100
	cail	T2," "	; control character?
	  jrst	msgchi	; no!
	cail	T2,"G"-100	; allow bell thru carriage return
	caile	T2,"M"-100
	 caia
	jrst	msgchi	; print it
	outchi	"^"	; else print as ^ char
	movei	T2,"@"(T2)
msgchi:	outchi	(T2)
msgtab:	cain	T2,11
		 setzm	twtmsg
	jrst	msgin
msginp:	in	msg,
	  jrst	msgin
msgdon:	releas	msg,
	popj	P,
	xlist	;literals
	lit
	list	;literals

lgiend:	BLOCK	2
	end	LOGINN
   {?Dbp