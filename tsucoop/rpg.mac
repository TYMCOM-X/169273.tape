	Search	RPGUNV		; Get macro definitions from UNV file.

TYMSPC==156	;TYMSHARE SPEC NO. (bumped once per transmittal)
TYMREL==0	;TYM RELEASE NO. (bump this for bugfixes)
JOBVER==137	; address of where to put version number

TITL(\TYMSPC,\TYMREL)

	TWOSEG		;SIGNAL LOADER FOR HIGH SEGMENT

IF2<PRINTX License required: HF>

IFNDEF PIP33,<PIP33==0>	;PIP33=1 MEANS INCLUDE STUFF FOR NEW PIP

	Subttl	Segmentation stuff -- Internals and Externals

Entry	SCAN,SCANS,SCANHW,SWSCAN
Entry	SETRNF,TRANUN,GETNAM,TMNER,SYNERR
Entry	CPOPJ,CPOPJ1,BYENOW,EX,XPAND,XIT
Entry	GETCH,GETNMS,GSTRN,GTUNO
Entry	TPSIX,YN,PROMPT,OPUD,PRTIM1,TDATE
Entry	RDBLK,WTBLK,LKLUD,LDPRV

Intern	TMPFIL,JOBNAM,LOGPPN,SVJBFF,CORTOP
Intern	SVDEV,SVNAM,SVEXT,SVPPN,ALTRUN,ALTLOD,ACCUM
Intern	BUF,SHED,SBUF,NAMCT,NAMPT

Extern	JOBFF,JOBREL,JOBSA,JOBSYM,JOBERR,JOBDDT		; Job Data area
Extern	GETPAR,SETPAR,WRTPAR,MAKINI,MODPAR,RPGPAR	; See RPGINI.MAC
Extern	SETPRO,ADDPRO,SETPTH,ADDPTH,SETNSD,ADDNSD	;	"
Extern	SETRPG,SETDFL,SETDDT,PRCTRN,SETML,DOCMD		;	"
Extern	SEND,MAIL,OPNOTICE,POST,RFLBLK			; See RPGMAI.MAC

	Subttl	Beginning of Code

LOWST::			; Address of Start of low core for ZEROING BLT

	RELOC	400000	; All the code is high-segment

;COME HERE WHEN FINALLY READY TO RUN A PROCESSOR

PERFOO:	MOVE	T2,[SIXBIT /PERFOR/]	;YES? THEN PERFORM
	PUSHJ	P,OUTSIX		;WRITE IT OUT
	MOVEI	T1,"!"		;BANG, YOU'RE DEAD
	PUSHJ	P,(T3)			;OUTPUT ROUTINE
	PUSHJ	P,OUCRLF		; FOLLOW WITH A CRLF
	POPJ	P,0		; CLIMB INTO THE WAY-BACK MACHINE, MR. PEABODY

CREFIT:	PUSHJ	P,WRTPAR	;MAKE SURE PARAMETER FILE IS WRITTEN
	SKIPA	T1,[SIXBIT/CROSS/]
GOSFO:	MOVE	T1,[SIXBIT/SFORTR/]
	JRST	NUNDO

RUNCMD:	PUSHJ P,SETRNF	;HANDLE RUN COMMAND - EASY AS PYE
	JRST	NUNDO

GOCFO:	SKIPA	T1,[SIXBIT/CFORTR/]	;SYS:CFORTR INSTEAD OF SYS:LOADER
PERFIT:	MOVE	T1,[SIXBIT /PERFOR/]	; CALLING PERFORM!!
NUNDO:	MOVEM	T1,NAME		;SET NAME
	SETZM	NAME+3
	SETZM	NAME+1	;LET MONITOR SUPPLY SAV OR SHR
	SKIPN T1,PCDEV	;SPECIAL DEVICE??
	JRST NOPCDV
	MOVEM T1,RUNBLK
	SETZM NAME+3	;ZERO PPN
NOPCDV:	SKIPE T1,PCEXT
	MOVEM T1,NAME+1
	SKIPE T1,PCPPN
	MOVEM T1,NAME+3 ;SETUP OTHER THINGS (FROM NON-STANDARD)
	SKIPE ALTRUN
	JRST	[MOVE T1,[ALTRUN,,RUNBLK]
		BLT T1,RUNBLK+5
		JRST GORUN]
	MOVE T3,NAME
	PUSHJ P,PRCTRN	;TRANSLATE IF NEEDED
	 JRST GORUN	;NO TRANSLATION
SPFND:	MOVSI T1,1(T3)
	HRRI T1,RUNBLK	;FOUND SPECIAL, GET ITS RUN BLOCK
	BLT T1,RUNBLK+5
GORUN:	PUSH P,[RUNBLK]
IFDEF	RPGDEBUG,<
	PUSHJ P,RPGDB	;IN BLISS: RPGDB(RUNBLK);
> ; End IFDEF RPGDEBUG
	MOVEI T1,RUNBLK
	SKIPN EDCMND#
	HRLI T1,1	;ALL COMMANDS EXCEPT EDITOR GET 1 OFFSET
	RUN	T1,
	HALT

;/RUN <FILENAME> IS A VALID SWITCH IN ALMOST ALL COMMANDS.
;IT TELLS RPG TO RUN THE PROGRAM SPECIFIED BY <FILENAME>
;INSTEAD OF THE PROGRAM IT WOULD NORMALLY RUN.

SETRNN:	TROA FL,NOSCAN
SETRUN:	TRZ FL,NOSCAN
	AOBJP SVPT,TMNER	;AVOID CLOBBERING STUFF
	PUSHJ P,SETRNF
	SUB SVPT,[1,,1]	;BACK UP POINTER
	SETZB T3,T4	;FOR LISTER-TYPE COMMANDS
	TRNN FL,NOSCAN	;SHOULD WE SCAN?
	JRST SCAN	;YUP
	POPJ P,		;NOPE

SETRNF:	PUSHJ P,GETNMS	;GET FILE NAME TO RUN
	SKIPN T1,SVDEV(SVPT)
	MOVSI T1,'DSK'	;DEFAULT DEVICE IS DSK NOT SYS
	MOVEM T1,ALTRUN
	MOVE T1,SVNAM(SVPT)
	MOVEM T1,ALTRUN+1
	HLLZ T1,SVEXT(SVPT)
	MOVEM T1,ALTRUN+2
	SKIPN T1,SVPPN(SVPT)
	MOVE T1,USRPPN
	MOVEM T1,ALTRUN+4
	POPJ P,

;THESE ROUTINES SCAN A FILE NAME AND STUFF IT IN SVNAM AND
;FRIENDS INDEXED BY SVPT.
;GETNMS BEGINS A SCAN AND DOES THE STUFF.
;GETNAM SCANS A FILE NAME IN WHICH THE FIRST TOKEN HAS ALREADY
;BEEN SCANNED.

GETNMS:	PUSHJ P,SCAN
GETNAM:	SETZM SVNAM(SVPT)	;ZERO OUT CELLS IN CASE NOTHING

	SETZM SVEXT(SVPT)	;GETS PUT THERE
	SETZM SVPPN(SVPT)
	SETZM SWBKS(SVPT)
	SETZM SVDEV(SVPT)
GETN1:	TRNN FL,IDF		;WAS THE THING SCANNED AN IDENT
	JRST TRYPP1	;TRY FOR PPN
	PUSH P,ACCUM
	PUSHJ P,SCANS	;CHECK FOR EXT OR PPN
	CAIE C,":"	;IS IT A DEVICE NAME
	JRST NODEV	;NO
	POP P,SVDEV(SVPT)	;WE WERE HIDING IT IN THE STACK
	MOVSI T1,'SYS'
	CAME T1,SVDEV(SVPT)
	JRST GETN1A
	SETZM SVDEV(SVPT)
	MOVE T1,[1,,4]		;CHANGE SYS: TO (SYS) TO AVOID CONFUSION
	MOVEM T1,SVPPN(SVPT)	;ABOUT WHETHER TO COMPILE
GETN1A:	PUSHJ P,SCAN	;BYPASS
	PUSHJ P,SCANS	;PEEK AHEAD
	JUMPN CS,TRYPPN	;CHECK FOR DELIMITER AFTER :
	PUSHJ P,SCAN	;NO, MUST HAVE AN IDENTIFIER
	PUSH P,ACCUM
	PUSHJ P,SCANS
NODEV:	POP P,SVNAM(SVPT)
	CAIN C,"["	;IS IT PPN
	JRST GPPN
	CAIE C,"."	;NO, EXT?
	JRST GTNMX	;NEITHER, RETURN
	PUSHJ P,SCAN	;NO. GO OVER DOT
	PUSHJ P,SCANS	;PEEK AT NEXT CHAR
	JUMPN CS,[HLLOS SVEXT(SVPT)	;BLANK EXTENSION
	JRST TRYPPN]	;LOOK FOR PPN NEXT
	PUSHJ P,SCAN	;GET EXT
	TRNN FL,IDF
	JRST	[OUTSTR [ASCIZ "EXTENSION EXPECTED"]
	JRST	ERRCOM]
	MOVE T1,ACCUM
	HLLZM T1,SVEXT(SVPT)
	PUSHJ P,SCANS
TRYPPN:	CAIE C,"["	;CHECK FOR PPN AGAIN
	JRST GTNMX
;GPPN AND TRYPP1 HANDLE [N,N] AND USER NAMES
GPPN:	PUSHJ P,SCAN
GETPP2:	pushj p,scanhw		;read octal half-word to t1
	HRLM T1,SVPPN(SVPT)	;STORE LEFT HALF
	PUSHJ P,SCAN
	CAIE C,","
	JRST SYNERR
	PUSHJ P,scanhw
	HRRM T1,SVPPN(SVPT)
	PUSHJ P,SCAN
	CAIE C,"]"
	JRST SYNERR
GTNMX:	MOVE T1,DEFPPN
	SKIPN SVPPN(SVPT)
	MOVEM T1,SVPPN(SVPT)	;USE DEFAULT PPN IF NONE GIVEN HERE
	SKIPN SVDEV(SVPT)
	SKIPE SVEXT(SVPT)
	POPJ P,		;NO FUNNY STUFF IF DEV OR EXT GIVEN
	MOVSI T1,'*.*'
	PUSH P,T4	;SAVE ACC IF NESTING
IFN PIP33,<
	MOVE T4,SVNAM(SVPT)
	CAMN T4,[SIXBIT/ALL/]
	MOVEM T1,SVNAM(SVPT)	;CHANGE "ALL" TO "*.*"
	HRRZI T1,(SVPT)		;IS THIS THE FIRST FILE GIVEN?
	JUMPE T1,NOCHNG		;YES, DON'T MESS WITH IT.
	CAME T4,[SIXBIT/SAME/]	;"SAME" BECOMES PREVIOUS
	JRST NOCHNG		; FILE DECLARATION
	MOVE T1,SVNAM-1(SVPT)	;RETRIEVE FILE NAME
	MOVEM T1,SVNAM(SVPT)	; FROM PREVIOUS DECLARATION
	MOVE T1,SVEXT-1(SVPT)	;LIKEWISE EXT.
	MOVEM T1,SVEXT (SVPT)
NOCHNG:
>
IFE PIP33,<
	MOVE T4,SVNAM(SVPT)
	CAME T4,[SIXBIT/ALL/]
	CAMN T4,[SIXBIT/SAME/]
	MOVEM T1,SVNAM(SVPT)	;CHANGE ALL OR SAME TO *.*
>
	POP P,T4		;RESTORE ACC
	POPJ P,


scanhw:	pushj	p,scan		;scan a half word (octal), place in t1
	TRNN FL,IDF		;better be id
	JRST SYNERR
	PUSH	P,T3
	MOVE T3,accum	;CONVERT SIXBIT TO OCTAL
	MOVEI T1,0
CONVOC:	MOVEI T2,0
	LSHC T2,6
	CAIL T2,20
	CAILE T2,27
	JRST SYNERR
	LSH T1,3
	IORI T1,-20(T2)
	JUMPN T3,CONVOC
	POP	P,T3
	POPJ P,

TRYPP1:	CAIN	C,"["
	JRST	GETPP2
	CAIE	C,"("
	JRST	GTNMX
	PUSH	P,T3	;WHY ARE THERE NO TRUE "SCRATCH" ACC'S?
	PUSH	P,T4	;SO THAT WE DON'T HAVE TO DO THIS!
	PUSHJ	P,GTUNO
	MOVEM	T3,SVPPN(SVPT)
	POP	P,T4	;TO GET RID OF USELESS SAVES
	POP	P,T3	;RPG NEEDS A SCRATCH ACC CONVENTION!
	CAIE	C,")"
	JRST	SYNERR
	PUSHJ	P,SCANS
	JUMPN	CS,GTNMX	;ALL DONE ON TERMINATOR
	PUSHJ	P,SCAN
	JRST	GETN1	;CONT. WITH FILE NAME
;SCANS PEEKS AHEAD AT THE NEXT COMMAND CHARACTER, SKIPPING OVER
;MULTIPLE BLANKS. RETURNS C=CS=0 IF CHAR=LEGAL IN NAME,
;ELSE C=CHAR, CS=CHAR+FLAGS

SCANS:	MOVNI T1,1	;FLAG AS NOTHING SEEN YET
	SKIPN CS,SAVCHR ;CHARACTER WAITING?
SCNS2:	PUSHJ P,GETCH
	JUMPN CS,SCNS1	;FOUND SOMETHING
	MOVEI T1,0
	JRST SCNS2
SCNS1:	JUMPL CS,SCNS4	;SPECIAL CHARACTER
	MOVEM CS,SAVCHR ;SAVE THAT CHARACTER
	JUMPL T1,SCNS3	;DO NOTHING ELSE IF NO BLANKS SEEN
	MOVEM T1,SAVCHR ;IF BLANKS SEEN, SAVE ONE
	MOVSI T1,70000
	HRRZ CS,IOPNT
	IMULI CS,3
	ADDM T1,IBUFCM+1(CS)	;BACK UP POINTER
SCNS3:	TDZA CS,CS	;IN EITHER CASE, RETURN 0
SCNS4:	MOVEM CS,SAVCHR ;SAVE SPECIAL CHARACTER
	HRRZ C,CS		;GET A CHARACTER TO RETURN
	POPJ P,
;SCAN RETURNS THE NEXT TOKEN IN THE COMMAND STRING. IF TOKEN=
;NAME OR NUMBER, C=CS=0, ACCUM=SIXBIT NAME, NUMAC=DECIMAL VALUE
;IF NUMBER. IF TOKEN=SPECIAL CHARACTER, C=CHAR, CS=CHAR+FLAGS.
;LEADING BLANKS ARE IGNORED.

SCAN:	TRZ FL,IDF!NUMFS	;RESET IN CASE NOT
	SKIPN CS,SAVCHR ;WAS THERE SOMETHING LEFT OVER
	PUSHJ P,GETCH	;NO, GET ANOTHER
	JUMPE CS,.-1	;IGNORE BLANKS
	JUMPL CS,SPCHR	;IS IT A SPECIAL CHARACTER
	SETZM ACCUM	;PREPARE TO STORE IT
	setzm accum+1	;clear both words of ident store
	MOVE T1,[POINT 6,ACCUM]
	TRO FL,IDF!NUMFS	;SAY ID AND FOR NOW A NUMBER
	TLNE CS,NUMF	;IS IT A NUMBER??
	JRST SCNUM	;YES, GO SCAN IT
SCAN1:	came t1,[point 6,accum+1,35]	;both words full?
	IDPB CS,T1	;NO, STORE ANOTHER
	PUSHJ P,GETCH	;GET NEXT
	JUMPG CS,SCAN1	;ANOTHER ALPHA
	TRZ FL,NUMFS	;THIS WAS NOT A NUMBER
SCAN2:	MOVEM CS,SAVCHR
	MOVEI C,0	;TO AVOID CONFUSION
	MOVEI CS,0
	POPJ P,
SPCHR:	HRRZ C,CS	;RETURN HIM THE HALF OF IT
	SETZM SAVCHR	;NOTHING SAVED BY NOW
	TLNN CS,SPACT	;DO WE WANT SPECIAL ACTION?
	POPJ P,	 ;NO
	JRST (CS)	;YES, RH IS DISPATCH
SCNUM:	SETZM NUMAC#	;THE NUMBER ACCUMULATOR
SCNUM1:	TLNE T1,770000	;SAVE DIGITS IN SIXBIT IN CASE FILE NAME
	IDPB CS,T1
	MOVEI C,^D10
	IMUL C,NUMAC
	ADDI C,-20(CS)	;ADD IN THE NUMBER
	MOVEM C,NUMAC
	PUSHJ P,GETCH
	JUMPLE CS,SCAN2 ;END OF NUMBER (SPECIAL CHR) GET OUT
	TLNE CS,NUMF	;IS IT PART OF A NUMBER?
	JRST SCNUM1	;YES, GO ON
	JRST SCAN1	;SCAN REST OF IDENT (NUMFS TURNED OFF AT SCAN2-1)
;GETCH RETURNS 7-BIT ASCII CHAR IN C, TABLE ENTRY IN CS

GETCH:	HRRZ CS,IOPNT
	IMULI CS,3		;TO USE FOR BUFFER POINTER
	SOSLE IBUFCM+2(CS)	;USE CORRECT BUFFER HEADER
	JRST OKPICK
	MOVE C,TMPFLG(IOPNT)	;IS TMPCOR BEING USED?
	CAMN C,[-1]		;SET TO -1 IF YES
	JRST [SETZM TMPFLG(IOPNT)	;CLEAR TMPFLAG
		JRST POPFI1]		;YES FINISHED WITH THIS READ
	HRR C,IOPNT		;CHANNEL NUMBE
	HRLI C,CIO.IN
	CHANIO C,
	SKIPA
	JRST ERREOF	;WAS AN ERROR OR EOF, GO CHECK
OKPICK:	IBP IBUFCM+1(CS)
	MOVE C,IBUFCM+1(CS)	;PICK UP THE NEW BYTE POINTER
	MOVE C,(C)	;GET THE WORD IT CAME FROM
	TRNE C,1	;AND CHECK FOR SEQ NUM
	JRST	[AOS IBUFCM+1(CS)	;ADVANCE POINTER
		MOVNI C,5	;AND ADJUST COUNT
		ADDB C,IBUFCM+2(CS)
		SKIPG C	;CHECK FOR BUFFER OVERRUN
		PUSHJ P,GETCH	;GET RID OF TAB
		JRST GETCH]
	LDB C,IBUFCM+1(CS)
	JUMPE C,GETCH	;IGNORE NULLS
	IDPB	C,ERBFPT	;SAVE CHAR FOR ERROR PRINTER
	MOVE	CS,ERBFPT
	CAME	CS,[POINT 7,ERRBUF+3,34]
	JRST	.+3
	MOVE	CS,[POINT 7,ERRBUF]
	MOVEM	CS,ERBFPT	;RESET IF AT END
	MOVE CS,CTBL(C) ;GET STATUS BITS
EOFRT1:	TRNN FL,INPRNT	;IF PRINTING ERROR, DO NOT NEST
	TLNN CS,SPACT2	;SPECIAL?
	POPJ P,
	JRST (CS)	;DO IT

ERREOF: HRRZ C,IOPNT	;GET CHANNEL
	HRLI C,CIO.SZ
	CHANIO C,740000
	JRST READER	;AN INPUT ERROR
	JRST POPFIL	;GO GET PREVIOUS FILE
SEMIC:	TRO FL,INPRNT	;GO GET RID OF GETCH SPECIAL ACTION
SEMIC1:	PUSHJ P,GETCH	;READ CHRS
	CAIE C,12	;UNTIL A LINE FEED
	JRST SEMIC1
	TRNN	IOPNT,-1	;IF A SEMI-COLON
	PUSHJ	P,GSTRN		;GET NEXT LINE
	TRZ FL,INPRNT	;GET RID OF FLAG
	JRST GETCH	;AND READ A CHR
CTBL:	0
REPEAT 10,<XWD SPCF,.-CTBL>
	0		;TAB
	XWD SPCF!SPACT!TERMF+12,CHKTRM
	XWD SPCF,13
	0	;IGNORE FORM FEEDS
	0		;CARRET
REPEAT 15,<XWD SPCF,.-CTBL>
	XWD SPCF!TERMF!SPACT+44,CHKTRM
REPEAT 4,<XWD SPCF,.-CTBL>
	0		;SPACE
	REPEAT 2,<XWD SPCF,.-CTBL>
	3	;# FOR SPECIAL IN DIR COMMAND
REPEAT 6,<XWD SPCF,.-CTBL>
12
REPEAT 2,<XWD SPCF,.-CTBL>
XWD SPCF!NUMF,.-CTBL	;ALLOW %-B IN LOADER SWITCHES
REPEAT 2,<XWD SPCF,.-CTBL>
REPEAT 12,<XWD NUMF,.-CTBL-40		;DIGIT>
	XWD SPCF,.-CTBL ;:
	XWD SPCF!SPACT2+";",SEMIC	;;
REPEAT 3,<XWD SPCF,.-CTBL>
37			;ALLOW QUESTION MARK AS WILD CHARACTER
	XWD SPCF!SPACT2+"@",NEST
REPEAT 32,<EXP .-CTBL-40		;UPPER CASE LETTERS>
REPEAT 6,<XWD SPCF,.-CTBL>
REPEAT 32,<EXP .-CTBL-100		;LOWER CASE LETTERS>
	XWD SPCF,.-CTBL
	XWD SPCF,.-CTBL
	XWD SPCF!TERMF!SPACT+44,CHKTRM
	XWD SPCF!TERMF!SPACT+44,CHKTRM
	XWD SPCF!SPACT,POPFIL

CHKTRM:	PUSH P,CS	;SAVE MAGIC BITS
TERMC1:	PUSHJ P,GETCH
	JUMPE CS,TERMC1 ;ALSO IGNORE TABS AND SPACES
	TLNE CS,TERMF
	JRST TERMC1	;BYPASS TERMINATORS
	MOVEM CS,SAVCHR ;SAVE FOR LATER
	POP P,CS
	MOVEI C,0	;AS GOOD AS ANYTHING ELSE
	POPJ P,

DEFINE QQ<
N=1
REPEAT NESTDP+1,<MAC(\N)
	N=N+1>>


;NEXT HANDLES THE @ CONSTRUCTION AND IMPLIED COMMANDS (-LOA<CR>).
;IT SAVES THE CURRENT SCANNER STATUS AND GOES TO THE COMMAND
;FILE SO THAT COMMAND FILES MAY BE NESTED

NEST:	PUSH P,ACCUM	;SAVE STATE OF SCANNER
	push p,accum+1	;(both halves of ident)
	PUSH P,FL	;SAVE THE FLAGS (AS IDF?)
	PUSH P,T1
	SETZM SAVCHR
	PUSH P,NAME	;AND THIS OTHER STUFF
	PUSH P,NAME+1
	PUSH P,NAME+2
	PUSH P,NAME+3
	AOBJP SVPT,TMNER	;GET A CLEAR SPACE FOR NAME
	PUSHJ P,GETNMS
	AOBJP IOPNT,NESTTD	;TOO DEEP?
	PUSH IOP,SAVCHR
	SETZM	SAVCHR
	PUSHJ P,CHKRM		;GET BUFFER SPACE
RENEST:
	MOVS C,SVEXT(SVPT)
	CAIE C,'TMP'
	JRST NOTMP	;FORGET ABOUT TMPCOR IF NOT .TMP
	MOVE C,JOBFF	;GET START OF BUFFER
	MOVEM C,BUFTAB(IOPNT)	;SAVE IT FOR RELEASING INFO
	MOVEM C,TMPFIL+1	;SAVE IOWD FOR TMPCOR UUO
	HRRZ CS,IOPNT
	IMULI CS,3
	MOVEM C,IBUFCM+1(CS)	;DUMMY UP BYTE POINTER
	SOS TMPFIL+1		;MAKE TMPFIL INTO CORRECT IOWD FORMAT
	MOVNI C,200		;GET BUFFER LENGTH
	HRLM C,TMPFIL+1	 ;STORE NEGATIVE WORD COUNT
	MOVE C,SVNAM(SVPT)	;PICK UP FILNAM
	HRLZM C,TMPFIL	;STORE RIGHT THREE LETTERS
	MOVE C,[XWD 1,TMPFIL]	;SET UP FOR TMPCOR READ
	TMPCOR	C,		;READ FILE AND DON'T DELETE
	JRST NOTMP		;NO SUCH FILE, TRY THE DISK
	SETOM TMPFLG(IOPNT)	;FLAG THAT TMPCOR READ WAS DONE
	IMULI C,5		;CALCULATE CHARACTER COUNT
	ADDI	C,1		;ADJUST FOR BOUNDARY CONDITION
	MOVEM C,IBUFCM+2(CS)	;STORE IN BUFFER HEADER
	MOVEI C,440700		;SET UP BYTE POINTER
	HRLM C,IBUFCM+1(CS)	;BUFFER HEADER FINALLY SET UP
	JRST NEXT2		;CONTINUE INTO MAIN STREAM
NOTMP:	SETZM	OPENB
	MOVSI	C,(SIXBIT /DSK/)
	MOVEM	C,OPENB+1
	HRRZ C,IOPNT
	IMULI C,3
	ADDI C,IBUFCM
	MOVEM C,OPENB+2
	MOVE	C,[OPEN .-.,OPENB]
	DPB IOPNT,[POINT 4,C,12]
	XCT	C
	JRST DSKNA	;LOSE BIG
	MOVE C,JOBFF
	MOVEM C,BUFTAB(IOPNT)	;SAVE THE PLACE PUT
	HRRZ C,IOPNT
	HRLI C,CIO.IB
	CHANIO C,2
	MOVE C,SVNAM(SVPT)
	MOVEM C,LNAM	;SET UP FOR LOOKUP
	SKIPN C,SVEXT(SVPT)
	MOVSI C,'CMD'	;TRY .CMD IF NO EXT GIVEN
	MOVEM C,LEXT
NEST1:	MOVE C,SVPPN(SVPT)
	MOVEM C,LPPN
	HRRZ C,IOPNT
	HRLI C,CIO.LK
	CHANIO C,NAME
	JRST	[TRNE FL,INCRF	;SPECIAL IF TRYING TO READ QQCREF
	JRST DNCRF
		SKIPN SVEXT(SVPT)	;WAS EXTENSION GIVEN?
		SKIPN LEXT	;NO, DID WE TRY NULL YET?
		JRST NOFIL	;YES, EITHER HE GAVE ONE OR WE TRIED BOTH DEFAULTS
		SETZM LEXT	;WE TRIED .CMD, NOW TRY NULL
	JRST NEST1]
NEXT2:	SUB SVPT,[XWD 1,1]	;GET HIM POINTED BACK RIGHT
	POP P,NAME+3	;RESTORE THINGS
	POP P,NAME+2
	POP P,NAME+1
	POP P,NAME
	POP P,T1
	POP P,FL
	POP P,ACCUM
	pop p,accum+1	;(both halves of ident restored)
	TRZ FL,RPGSRC!RECALF	;WE HAVE DONE THE FIND
	JRST GETCH	;AND CONTINUE TO GET THAT CHR

POPFIL:
	HRRZ C,IOPNT
	JUMPE C,@EOFLAB		;FIRST CASE
	HRLI C,CIO.RL
	CHANIO C,
POPFI1:	SETZM TMPFLG(IOPNT)	;CLEAR TMPCOR FLAG
	MOVE C,BUFTAB(IOPNT)
	MOVEM C,FREBUF(IOPNT)	;MARK BUFFER FREE
	POP IOP,CS
	HRRZ C,CS
	SUB IOPNT,[XWD 1,1]	;POINT IT BACK
	JRST EOFRT1	;AND GIVE BACK THE CHARACTER

ARRAY IBUFCM[3*<NESTDP+1>]
ARRAY TMPFLG[NESTDP+2]

DINCT=IBUFCM+2
DINPT=IBUFCM+1

;ERROR ROUTINES

ILLCHR:	OUTSTR	[ASCIZ/ILLEGAL CHARACTER:/]
	JRST	ERRCOM
ETMS:	OUTSTR	[ASCIZ /TOO MANY SWITCHES: /]
ERRCOM:	OUTSTR	[BYTE(7)15,12]
	MOVE	T1,ERBFPT
ERRCM1:	ILDB	C,T1		;GET CHARACTER FROM COMMAND
	CAMN	T1,[POINT 7,ERRBUF+3,34]
	MOVE	T1,[POINT 7,ERRBUF]
	PUSHJ	P,TYPERR	;TYPE ERROR CHARACTER
	AOS	ERRCNT		;REMEMBER THAT IT PRINTED
	CAME	T1,ERBFPT
	JRST	ERRCM1
	TRO	FL,INPRNT
	MOVEI	T1,^D10
ERRCM3:	PUSHJ	P,GETCH
	CAIN	C,177
	JRST	ERRCM4
	PUSHJ	P,TYPERR	;TYPE SOME MORE
	JFCL			;DON'T CARE WHETHER IT PRINTED OR NOT
	SOJG	T1,ERRCM3
ERRCM4:	OUTSTR	[BYTE(7)15,12]
ERRCM5:	SOSG	ERRCNT
	JRST	ERRCM6
	OUTCHR	[" "]
	JRST	ERRCM5
ERRCM6:	OUTCHR	["^"]
	JRST	BYENOW
TYPERR:	CAIGE	C," "
	JRST	CPOPJ1		;IGNORE NONPRINTING CHARS
	OUTCHR	C
	POPJ	P,
TMNER:	OUTSTR	[ASCIZ /TOO MANY NAMES: /]
	JRST ERRCOM
DSKNA:	OUTSTR	[ASCIZ /DISK NOT AVAILABLE: /]
	JRST ERRCOM
OUTER:	OUTSTR	[ASCIZ /OUTPUT ERROR: /]
	JRST ERRCOM
PROCON:	OUTSTR	[ASCIZ /PROCESSOR CONFLICT: /]
	JRST ERRCOM
NOCOR:	OUTSTR	[ASCIZ /NOT ENOUGH CORE: /]
	JRST ERRCOM
READER:	OUTSTR	[ASCIZ /INPUT ERROR: /]
	JRST ERRCOM
SYNERR:	OUTSTR	[ASCIZ /COMMAND ERROR: /]
	JRST ERRCOM
UNRECS:	OUTSTR	[ASCIZ /UNRECOGNIZABLE SWITCH: /]
	MOVE T3,ACCUM
	PUSHJ P,SIXOUT	;TYPE THE OFFENDING SWITCH
	skipe t3,accum+1	;tell him about full ident
	 pushj p,sixout		;even if it takes two words
	JRST BYENOW

NESTTD:	OUTSTR	[ASCIZ/TOO MANY COMMAND FILES NESTED - CAN'T OPEN /]
	MOVE T1,SVNAM(SVPT)
	MOVEM T1,NAME
	SKIPN T1,SVEXT(SVPT)
	MOVSI T1,'CMD'
	MOVEM T1,NAME+1
	JRST NAMCOM

NOFIL:	TRZE FL,RPGSRC
	JRST TRYSVD	;TRY SVED
	TRNE FL,RECALF	;WE WERE LOOKING UP A SVC FILE
	JRST NOPREV	;SO GIVE SPECIAL MESSAGE
	OUTSTR	[ASCIZ /NO SUCH FILE - /]
NAMCOM:	MOVE T3,NAME
	PUSHJ P,SIXOUT
	HLLZ T3,NAME+1
	JUMPE T3,BYENOW
	OUTCHR ["."]
	PUSHJ P,SIXOUT
BYENOW:	RESET
	JRST XIT
FIU:	OUTSTR	[ASCIZ /FILE IN USE OR PROTECTED - /]
	JRST NAMCOM

SIXOUT:	MOVEI T2,0
	LSHC T2,6
	ADDI T2,40
	OUTCHR T2
	JUMPN T3,SIXOUT
	POPJ P,

TMSTD:	OUTSTR	[ASCIZ /TOO MANY NON-STANDARD PROCESSORS: /]
	JRST ERRCOM

NOPREV:	MOVEI	T1,[ASCIZ/NO PREVIOUS COMPILE-TYPE COMMAND/]
	TRNE	FL,EDITF	;PICK OUT APPROPRIATE MESSAGE
	MOVEI	T1,[ASCIZ/NO PREVIOUS EDIT-TYPE COMMAND/]
	OUTSTR	(T1)
	JRST	BYENOW
;FINSIH UP COMMAND HANDLING - TELL LAST PROCESSOR TO RUN LOADER IF NECESSARY
;AND FINISH UP LOADER COMMAND FILE

ALLDON:	SKIPE LODNSV	;WAS THIS A LOAD COMMAND WITH NO SAVE SWITCH?
	SKIPN NEDSAV	;YES, DOES IT NEED ONE? (OVERLAY OR SFO DEBUG)
	JRST ALDOON	;NO, OK
	OUTSTR NSVWRN	;YES, GIVE A WARNING
ALDOON:	TRNE FL,INCRF	;JUST FOUND END OF QQCREF FILE
	JRST DNCRF
	TRNE FL,INPRNT
	JRST BYENOW	;IF PRINTENG AND EOF THEN FIINSH UP
	HRRZ T1,(P)	;GET THE ADDRESS WE WANT TO RETURN TO
	CAIE T1,NXFIL+1 ;THIS SHOULD BE HERE
	CAIN T1,ILP2A+1
	JRST .+3
	OUTSTR [ASCIZ/LINE TERMINATED IMPROPERLY/]
	JRST BYENOW
	SETZM PCNAM	;NO LINK NAME TO START WITH
	SKIPN LODUSE
	JRST NOTLDR	;NOT USING LOADER
	MOVSI	T2,'/2Y'		;YES, CHECK ANYTHING TO BE FINISHED
	SKIPE	FTFFLG
	PUSHJ	P,LODSIX
	SKIPE	FTXFLG		;If Field Test FORTRAN-10,
	  PUSHJ	  P,LODSIX	;  then append '/2Y' switch
	SKIPN	CDEBFL		;SKIP IF COBDDT WANTED
	JRST	NOCBD		;NOPE.
	MOVEI	T2,[ASCIZ'COBDDT[1,4],']
	PUSHJ	P,OUTASC
NOCBD:	MOVSI	T2,'/G '	;SET UP FOR TERMINATE LOADING
	PUSHJ P,LODSIX		;YES, PUT IT OUT
NOTLDR:	SETZM PCDEV	;ON DEVICE
	SETZM PCPPN	;NO PROGJ PROG
	SETZM PCEXT	;NO EXTENSION
	MOVEI T4,20	;GET SET TO SEE WHAT OUTPUT NEEDS DOING
	SKIPE T5,LODUSE	;IS THE LOADER FLAG SET?
	JRST ALDNM	;YES, DO IT FIRST
	SUBI T4,1	;ELSE START THROUGH CHAIN
ALDN1:	SKIPN T3,PRN4)	;ANYTHING THERE?
	JRST ALDN2		;NO
	HRRZS T3
	CAIE T3,IDXLOA+1
	CAIN T3,IDXCRE+1
	JRST ALDN2	;IGNORE CREF AND LOADER NOW
	MOVEI T5,17
	SUB T5,T4
	SKIPA
ALDNM:	MOVEI T3,0	;SET FOR LOADER
	PUSH P,T3	;SAVE IT
	MOVEI T3,COMNIT
	PUSHJ P,DOBANG	;OUTPUT
	PUSHJ P,COMCHK	;RELEASE
	POP P,T3
	CAILE T3,NPROCS	;IS IF A NON-STANDARD?
	JRST ALDNNS
	MOVE T3,PRCNAM-1(T3)
	MOVEM T3,PCNAM
	SETZM PCEXT
	SETZM PCDEV
	SETZM PCPPN
ALDN2:	SOJGE T4,ALDN1
	JRST DONE

ALDNNS:	MOVE T1,NONSNM-NPROCS-1(T3)
	MOVEM T1,PCNAM
	MOVE T1,NONSDV-NPROCS-1(T3)
	MOVEM T1,PCDEV
	MOVE T1,NONSXT-NPROCS-1(T3)
	MOVEM T1,PCEXT
	MOVE T1,NONSPN-NPROCS-1(T3)
	MOVEM T1,PCPPN
	JRST ALDN2


;DOBANG SETS A ! RUN COMMAND FOR THE PROCESSOR WHOSE OUTPUT
;ROUTINE IS IN T3 TELLING IT TO RUN THE PROCESSOR WHOSE NAME
;IS IN PCNAM ETC.	ALSO TAKES CARE OF RUNNING SFORTR AND FRIENDS AND
;SUBSTITUTIONS FROM THE SETPROCS COMMAND.	MY APOLOGIES FOR THE TRICKY CODE.

DOBANG:	SKIPE T2,PCNAM	;ANYTHING TO RUN?
	JRST GOTNAM	;YES, GO DO IT
	CAIN T4,20	;TRUE ONLY IF LOADER
	POPJ P,		;BUT NEVER IF GOING TO LOADER NOW
	SKIPE SFOMOD	;GOT NOTHING BETTER TO DO, MIGHT AS WELL SEE IF
	MOVE T2,['SFORTR'] ;WE NEED TO RUN ONE OF THESE DUDES
	SKIPE CFOMOD
	MOVE T2,['CFORTR']
	SKIPE PERFLG
	MOVE T2,['PERFOR']
	JUMPE T2,CPOPJ	;GOODBYE IF DIDN'T DO ONE OF THESE
	MOVEM T2,PCNAM	;OK, WANT TO DO SOMETHING AT LEAST
GOTNAM:	PUSH P,T4	;SAVE PROCESSOR FLAGS
	PUSH P,T3	;SAVE PROCESSOR OUTPUT ROUTINE
	MOVE T3,PCNAM
	PUSHJ P,PRCTRN	;POSSIBLE SUBSTITUTION
	 SKIPA T4,[PCDEV]	;NONE, USE OLD
	MOVEI T4,1(T3)
	POP P,T3
	SKIPN T2,(T4)	;HERE WE GO OUTPUTTING A NAME
	JRST PCOUT1
	PUSHJ P,OUTSIX	;DEVICE NAME
	MOVEI T1,":"
	PUSHJ P,(T3)
PCOUT1:	MOVE T2,1(T4)
	PUSHJ P,OUTSIX	;FILE NAME
	SKIPN T2,2(T4)
	JRST PCOUT2
	MOVEI T1,"."
	PUSHJ P,(T3)
	PUSHJ P,OUTSIX	;EXTENSION
PCOUT2:	SKIPE T2,4(T4)
	PUSHJ P,OUTPPN	;PPN
	POP P,T4	;GET BACK PROCESSOR FLAG
	MOVEI T1,"!"
	PUSHJ P,(T3)	;BANG, GANG
	JRST OUCRLF	;AND IT'S ALLL DONE!

NSVWRN:	ASCIZ"Warning: You must include a /SAVE switch in your LOAD command if
you want to create a save file for this program.	An XEXEC or
monitor SAVE command will not work properly for overlay programs
or SFORTRAN debug-mode programs.	Please contact your local
Tymshare representative for further information.
"
;WRITE OUT COMMAND IN SVC FILE AND CLOSE ALL FILES, THEN RUN 
;PROCESSOR OR EXIT

DONE:	TRNE FL,NOSVC	;DID WE SEE COMMAND FROM TTY?
JDONE1:	JRST DONE1	;NO, DO NOT WRITE FILE
	MOVE T1,JOBNAM
	HRRI T1,(SIXBIT /SVC/)
	TRNE FL,EDITF
	HRRI T1,(SIXBIT /EDS/)
	MOVEM T1,LNAM	;SET UP OUTPUT FILE
	HRLZM T1,TMPFIL		;SAVE NAME IN TMPFIL
	MOVE T1,[POINT 7,TTYBUF]	;SET UP BYTE POINTER
	MOVNI T2,4			;SET UP FOR CHARACTER COUNT
	ILDB T3,T1			;GET NEXT CHARACTER
	CAIE T3,177			;IS IT A EOF CHARACTER
	SOJA T2,.-2			;NO, TRY AGAIN
	IDIVI T2,5			;CALCULATE CHARACTER COUNT
	HRLM T2,TMPFIL+1		;STORE IN TMPCOR OUTPUT BLOCK
	LDB T3,[POINT 6,T1,5]		;PICK UP BIT POS OF LAST CHAR
	SETO T2,			;PREPARE TO BUILD MASK
	LSH T2,7(T3)			;MASK OFF REST OF LAST WORD
	ANDM T2,(T1)			;	IN DDT BUFFER
	MOVEI T2,TTYBUF-1		;GET START OF BUFFER
	HRRM T2,TMPFIL+1		;STORE IN WRITE BLOCK FOR TMPCOR UUO
	MOVE T2,[XWD 3,TMPFIL]		;SET UP FOR WRITE
	TMPCOR	T2,			;WRITE OUT FILE INTO CORE
	SKIPA				;IT DID NOT FIT, TRY DISK
	JRST DONE1			;GO CLEAN UP AND LEAVE
	MOVEI T2,177			;RESTORE EOF CHARACTER IN TTYBUF
	IDPB T2,T1			;ALL BACK TO NORMAL
	MOVSI T1,'TMP'
	MOVEM T1,LEXT
	SETZM LDAT
	SETZM LPPN
	INIT LOOK,1
	SIXBIT'DSK'
	LOOKBF,,0
	 JRST DSKNA
	PUSHJ P,CHKRM	;GET ROOM FOR BUFFERS
	ENTER LOOK,LNAM ;GET SET TO WRITE
	JRST FIU	;TREAT THIS AS A FATAL ERROR
	OUTBUF LOOK,2
	MOVE T1,[POINT 7,TTYBUF]	;WRITE ALL OF COMMAND
DONE3:	ILDB T2,T1
	CAIN T2,177	;DONE?
	JRST DONE2
	SOSG LOOKBF+2
	OUTPUT LOOK,0
	IDPB T2,LOOKBF+1
	JRST DONE3
DONE2:	RELEASE LOOK,0	;LET IT GO
DONE1:	SKIPE CRFUSE	;DID WE DO ANY CREF?
	PUSHJ P,FINCRF	;YES, FINISH OFF CREF
	RESET	;RESET SO EXTRA FILES NOT PUT OUT
	PUSHJ P,WRTPAR	;CLOSE UP PARAMETER FILE
	SKIPN ALTRUN	;ALWAYS RUN IF ALTERNATE PROCESSOR
	SKIPE T1,PCNAM	;IS THERE ONE TO LOAD?
	JRST NUNDO	;GO LOAD IT
EX:	MOVEI	T1,17		;PREPARE TO RELEASE ALL FILES
	MOVE	T2,[RELEAS 0,0]
	DPB	T1,[POINT 4,T2,12]
	XCT	T2
	SOJGE	T1,.-2
XIT:	PUSHJ	P,WRTPAR	;CLOSE PARAMETER FILE
	SKIPE	PERFLG		;WERE WE CALLED BY PERFORM
	JRST	PERFIT		; YES? WELL, THEN RUN PERFORM
	SKIPE	CFOMOD
	JRST	GOCFO		;CFO MODE DON'T EXIT
	SKIPE	SFOMOD
	JRST	GOSFO		;DITTO FOR SFO MODE
	PUSH P,[[EXP 0,0,0,0,0,0]]
IFDEF	RPGDEBUG,<
	PUSHJ P,RPGDB##	;IN BLISS: RPGDB(0);
> ; END IFDEF RPGDEBUG
	EXIT	1,
	JRST	.-1


	DEFINE X (A,B,C,D,E,F)
<<SIXBIT /C/>>

	SIXBIT /LOADER/
PRCNAM:	PROCESS
;BUFFER ALLOCATION STUFF - EXPAND CORE IF NECESSARY

CHKRM:	PUSH P,T1	;SAVE THE REGISTERS WE ARE USING
	PUSH P,T2
	MOVSI T1,-<NESTDP+2>	;LOOK TO SEE IF ANY FREED BUFFERS
	SKIPN T2,FREBUF(T1)
	AOBJN T1,.-1	;TRY AGAIN
	JUMPGE T1,USTOP ;NO, GET IT FROMTOP OF STORAGE
	MOVEM T2,JOBFF	;YES, SET JOBFF THERE
	SETZM FREBUF(T1)	;AND MARK IT USED
	JRST TPOPJ	;THATS ALL FOR NOW
USTOP:	MOVE T1,SVJFF	;GET THE CURRENT TOP OF BUFFER AREA
	MOVEM T1,JOBFF
	ADDI T1,<203*2>+1	;LEAVE THIS MUCH ROOM
	MOVEM T1,SVJFF	;THATS THE NEW TOP
	CAMGE T1,CORTOP ;WILL THAT RUN US OUT OF CORE?
	JRST TPOPJ	;NO, LEAVE
	PUSH P,CTPOPJ
XPAND:	MOVEI T1,2000	;GET SET TO EXPAND
	ADDM T1,CORTOP
	ADDM T1,CORT1
	ADD T1,JOBREL	;NEW TOP DESIRED
	CORE T1,	;ASK FOR IT
	JRST NOCOR	;LOSE BIG
	MOVE T1,JOBREL
MVCR:	MOVE T2,-2000(T1)	;MVOVE CORE UP
	MOVEM T2,(T1)
	CAMLE T1,CORTOP ;ARE WE DONE?
	SOJA T1,MVCR
CTPOPJ:	POPJ	P,TPOPJ
TPOPJ:	POP P,T2	;ALL FINISHED
	POP P,T1
	POPJ P,
DEFINE TABLE
<SWITCH COMPILE,<TRZ FL,DOLOD>
SWITCH COM,<TRZ FL,DOLOD>
SWITCH COMP,<TRZ FL,DOLOD>
SWITCH LOAD,<SETOM LODNSV#>
SWITCH CDEBUG,<PUSHJ P,CDEBUG>
SWITCH DEBUG,<PUSHJ P,DEBUG>
SWITCH EXECUTE,<PUSHJ P,XCTR>
SWITCH TRY,<PUSHJ P,TRYIT>
SWITCH SETDDT,<JRST SETDDT>
SWITCH SETMAIL,<JRST SETML>
SWITCH MAKINI,<JRST MAKINI>
SWITCH FDEBUG,<PUSHJ P,FDEBUG>
SWITCH SDEBUG,<PUSHJ P,SDEBUG>
SWITCH PRINT,<JRST PRINT>
SWITCH CRE,<PUSHJ P,CREATE>
SWITCH CREATE,<PUSHJ P,CREATE>
SWITCH MODIFY,<PUSHJ P,MODIFY>
SWITCH EDITOR,<PUSHJ P,EDITOR>
SWITCH VUE,<PUSHJ P,VUE>
SWITCH LIST,<JRST LISTR>
SWITCH DIRECTORY,<JRST DODIR>
SWITCH DIFFERENCES,<JRST DIFFER>
SWITCH CREF,<JRST PLCROS>
SWITCH CROSS,<JRST CREFIT>
SWITCH DELETE,<JRST DODEL>
SWITCH TECO,<PUSHJ P,TECO>
SWITCH MAKE,<PUSHJ P,MAKE>
SWITCH RENAME,<JRST DOREN>
SWITCH TYPE,<JRST TYPR>
SWITCH COPY,<JRST COPY>
SWITCH DECLARE,<JRST DECLARE>
SWITCH PPN,<JRST PPN>
SWITCH FILES,<JRST DOFL>
SWITCH HELP,<JRST HELP>
SWITCH DATE,<JRST DODATE>
SWITCH TYMEX,<JRST TYMEX>
SWITCH XEXEC,<JRST TYMEX>
SWITCH PDP10,<JRST PDP10>
SWITCH 10EDIT,<PUSHJ P,EDIT10>
SWITCH FDC,<JRST FDC>
SWITCH PFDC,<JRST PFDC>
SWITCH SETRPG,<JRST SETRPG>
SWITCH SETPROC,<JRST SETPROC>
SWITCH ADDPROC,<JRST ADDPRO>
SWITCH SETDOLIST,<JRST SETPTH>
SWITCH ADDDOLIST,<JRST ADDPTH>
SWITCH DO,<JRST DOCMD>
SWITCH RUN,<JRST RUNCMD>
SWITCH SETNONSTANDARD,<JRST SETNSD>
SWITCH ADDNONSTANDARD,<JRST ADDNSD>
SWITCH SETDEFAULT,<JRST SETDFL>
SWITCH CTEST,<RPGRET>	;ZERO LEFT HALF MEANS LEAVE LICENSE ON
SWITCH MAIL,<MAIL>
SWITCH OPNOTICE,<OPNOTI>
SWITCH SEND,<SEND>
SWITCH POSTMAN,<POST>>

TBGEN (COMTAB,COMTLG,COMT2)
;ROUTINES TO INITIALIZE FOR VARIOUS LOAD-TYPE COMMANDS (AND SOME OTHERS)

PLCROS:	OUTSTR	[ASCIZ /PLEASE USE CROSS COMMAND/]
	RESET		;AND EXIT
	JRST	EX	;...

TRYIT:	SKIPA	T2,[SIXBIT '/D/E']
DEBUG:	MOVSI T2,'/T '
	PUSH P,T2
	MOVEI T1,P.DDT
	PUSHJ P,GETPAR
	 JRST	[POP P,T2
		JRST LODSIX]
	MOVEI T3,OUTLOD
	PUSH P,T1
	SKIPE T2,@(P)
	PUSHJ P,OUTDV
	AOS (P)
	MOVE T2,@(P)
	PUSHJ P,OUTSIX
	AOS (P)
	SKIPN T2,@(P)
	JRST TRYIT1
	MOVEI T1,"."
	PUSHJ P,(T3)
	PUSHJ P,OUTSIX
TRYIT1:	AOS (P)
	SKIPE T2,@(P)
	PUSHJ P,OUTPPN
	MOVSI T2,'/-3'
	PUSHJ P,OUTSIX
	POP P,T2
	POP P,T2
	LSH T2,6
	JRST OUTSIX

FDEBUG:	MOVSI	T2,'/S '	;GIVE LOAD WITH SYMBOLS SWITCH
	PUSHJ	P,LODSIX	;TO THE LOADER
	TROA	FLP,FDEBSW	;INDICATE FDEBUG IN PROGRESS
CDBG2:	SKIPA	T2,[SIXBIT'/E/4Y']
XCTR:	MOVSI T2,'/E '
LODSIX:	MOVEI	T3,OUTLOD
	JRST	OUTSIX

CDEBUG:	SETOM	CDEBFL#
	JRST	CDBG2

SDEBUG:	MOVE	T2,[SIXBIT'/E/13Y']
	PUSHJ	P,LODSIX
	JRST	SDEBCM

RPGSET:	MOVE T1,[POINT 7,FCOMD]
	MOVEM T1,DINPT
	MOVEI FL,RPGSRC!RECALF!NOSVC
	JRST RPGRET

;ROUTINE TO SET UP SVC FILE FOR -LOAD<CR> TYPE COMMAND
TRYSVD:	TRZE FL,ALTSRC	;FROM COMMAND?
	JRST TRYSV2
	MOVE T1,[POINT 7,FCOMD3]
	MOVEM T1,DINPT
	MOVEI FL,RECALF!NOSVC!ALTSRC
	JRST RPGRET	;TRY AGAIN
TRYSV2:	HLLZ C,JOBNAM
	HRRI C,(SIXBIT /EDS/)
	MOVEM C,SVNAM(SVPT)
	MOVSI C,(SIXBIT /TMP/)
	MOVEM C,SVEXT(SVPT)
	HRRZ C,BUFTAB(IOPNT)
	MOVEM C,JOBFF	;RESET SINCE ONE INBUF ALREADY DONE
	JRST RENEST

;ROUTINE TO GET A CHARACTER STRING FROM THE TTY AND STUFF IT IN
;TTYBUF. BUFFERED INPUT WOULD BE A NICER WAY TO DO THIS BUT WOULD
;REQUIRE AN EXTRA CHANNEL (CHANNELS ARE SCARCE IN THIS PROGRAM).
GSTRN:	PUSH	P,T1	;SAVE THE ACCUMULATORS
	PUSH	P,T2
	PUSH	P,T3
	 MOVE	T1,[POINT 7,TTYBUF]	;SET POINTER
	MOVEM	T1,DINPT
GSTRN1:	INCHWL	T2
	CAME	T1,[POINT 7,TTYBUF+^D99,6]
	IDPB	T2,T1	;PUT CHAR IN BUF IF NOT FULL
	MOVE	T3,CTBL(T2)	;GET CHAR DESCRIPTOR
	TLNN	T3,TERMF	;IS IT A BREAK CHAR?
	JRST	GSTRN1	;NO, GET MORE
	MOVEI	T2,177	;MARK EN WITH AN EOF FLAG
	IDPB	T2,T1
	IDPB	T2,T1
	SETZB	CS,SAVCHR
	POP	P,T3	;GET THOSE ACCUMULATORS BACK!
	POP	P,T2
	POP	P,T1
	POPJ	P,

STTYMX:	HRROI	T1,GETPRV	;SET TYMEX FLAG IF REQ.
	GETTAB	T1,
	JRST	EX
	TRNE	T1,PVTYMX!PVGEX
	TLO	FL,TYMX	;SET FLAG
	POPJ	P,

PERFOR:	PUSH	P,T1	;SAVE THEM ACCUMULATORS
	PUSH	P,T2
	PUSH	P,T3
	PUSH	P,T4
	MOVE	T1,[POINT 7,[ASCIZ /CTE @/]]
	MOVE	T4,[POINT 7,TTYBUF]
	PUSHJ	P,WRTCHR	;WRITE OUT THE CONTENTS OF T1
	MOVEI	T1,3	;A COUNTER FOR LOOPING
	PJOB	T2,
PLOOP:	IDIVI	T2,12		;CONVERT TO BASE 10
	ADDI	T3,60	;MAKE IT AN ASCII NUMBER
	PUSH	P,T3		;STACK IT
	SOJG	T1,PLOOP	;ARE WE DONE LOOPING?
	MOVEI	T1,3		;
	POP	P,T3
	IDPB	T3,T4
	SOJG	T1,.-2		;UNSTACKING CONTINUES
	MOVE	T1,[POINT 7,[ASCIZ /PEC.TMP
/]]
	PUSHJ	P,WRTCHR	;FINISH THE "CTE" COMMAND
	MOVEI	T2,177		;AN EOF FLAG!!
	IDPB	T2,T4		;PLACE IT AT THE END OF BUFFER
	IDPB	T2,T4		;AND ANOTHER...
	SETZB	CS,SAVCHR	;EMULATE GSTRN
	MOVE	T1,[POINT 7,TTYBUF]	;SO THAT GETCHR IS HAPPY
	MOVEM	T1,DINPT		;SAVE THAT POINTER
	POP	P,T4		;RESTORE THEM ACCUMULATORS
	POP	P,T3		
	POP	P,T2
	POP	P,T1
	JRST	CPOPJ1

WRTCHR:	ILDB	T2,T1		;ASSUMES PTRS IN T1,T4
	SKIPN	T2
	POPJ	P,
	IDPB	T2,T4
	JRST	WRTCHR
;HERE WE GO TO START THE WORLD TURNING

STPT:	TDZA	T4,T4		;NORMAL ENTRY
	MOVEI T4,1	;REENTRY FROM AN EDITOR
	RESET
	SETZM ALTLOD		;PART OF INITIALIZATION
	SETZM	LOWST		;MUST CLEAR LOW CORE
	MOVE	T1,[XWD LOWST,LOWST+1]
	BLT	T1,LOWTOP
	MOVEM T4,STRTFL#
	MOVEM 17,SAVE17#
	MOVEM 16,SAVE16#
	MOVE P,PDP
	GETPPN T1,	;GET USER'S PPN
	MOVEM T1,USRPPN
	HRROI T1,-23	;AND HIS PPN
	GETTAB T1,	;(HIS LOGIN PPN NOT GFD PPN)
	 HALT .
	MOVEM T1,LOGPPN#	;AND SAVE LOGIN PPN
	MOVEI T1,3
	PJOB T2,
	IDIVI T2,12
	ADDI T3,20	;MAKE SIXBIT JOB NUMBER FOR NAMES
	LSHC T3,-6
	SOJG T1,.-3
	HLLZM T4,JOBNAM
	MOVE T1,JOBFF
	MOVEM T1,RPGPAR
	CAMG T1,JOBREL
	JRST RPITMP
	CORE T3,	;TAKE CARE OF THE ONE-IN-A-K CASE WHERE
	HALT .		;JOBFF>JOBREL
RPITMP:	MOVSI T1,'RPG'
	MOVEM T1,TMPFIL
	MOVE T3,JOBFF
	SUBI T3,1
	MOVE T4,JOBFF
	SUB T4,JOBREL
	HRLI T3,(T4)	;SET UP TMPCOR IOWD
	MOVEM T3,TMPFIL+1
	MOVE T1,[1,,TMPFIL]
	TMPCOR T1,	;TRY READING IT
	JRST RPIDSK	;NO LUCK, TRY DISK
	MOVN T4,T4
	CAIG T1,(T4)	;WAS BUFFER LARGE ENOUGH?
	JRST RPITOK	;YES
	ADD T1,JOBFF
	CORE T1,	;NO, EXPAND
	HALT .
	JRST RPITMP
RPITOK:	ADDM T1,JOBFF	;BUMP PAST FILE
	JRST RPICKP
RPIDSK:	INIT LOOK,17
	SIXBIT/DSK/
	0
	HALT .
	MOVE T1,JOBNAM
	HRRI T1,'RPG'
	MOVSI T2,'TMP'
RPIAGN:	SETZ T3,
	move T4,logppn		;always use logged in directory
	LOOKUP LOOK,T1
	JRST	[HLRZS T2
		CAIE T2,'TMP'
		JRST RPINOF	;ALLOW ANOTHER TRY
		MOVSI T1,'RPG'	;THIS TIME FOR RPG.INI
		MOVSI T2,'INI'	;SORT OF PERM INFO
		SETOM MODPAR	;FORE REWRITE
		JRST RPIAGN]
	HRR T4,JOBFF
	SUBI T4,1
	HLRE T1,T4
	MOVN T1,T1
	ADDB T1,JOBFF	;ALLOW FOR SIZE OF FILE
	CAMG T1,JOBREL
	JRST .+3
	CORE T1,	;EXPAND IF NECESSARY
	HALT .
	MOVEI T5,0
	IN LOOK,T4	;INPUT PARAMETER FILE
	JRST RPIDRL
	HALT .
RPINOF:	SETOM MODPAR	;SET FLAG SO FILE GETS WRITTEN
RPIDRL:	RELEAS LOOK,
RPICKP:	SETZM @JOBFF	;SET UP NULL IN CASE NONE FOUND		[150.0]
	AOS JOBFF	;MARK ONE ZERO WORD IN USE		[150.0]
IFDEF	RPGDEBUG,<
	JRST RPST2	;FORGET SPECIAL RPG IF IN DEBUG MODE
> ; End IFDEF RPGDEBUG
	MOVEI T1,P.RPGRN
	PUSHJ P,GETPAR	;CHECK FOR SPECIAL RPG TO RUN
	JRST RPST2	;NOPE
	HRROI T2,-25	;YES, WHERE DID WE COME FROM?
	GETTAB T2,
	HALT .
	HRROI T3,3	;AND GET OUR NAME
	GETTAB T3,
	HALT .
	CAMN T2,4(T1)	;PPN MUST MATCH
	CAME T3,1(T1)	;AND NAME MUST MATCH
	JRST [	MOVE 17,SAVE17
		MOVE 16,SAVE16
		HRL T1,STRTFL	;A MISMATCH, WE ARE THE WRONG RPG
		RUN T1,		;RUN THE RIGHT RPG WITH THE SAME INCREMENT
		HALT .]

;PROGRAMS WHICH WANT TO HAVE RPG DO SOMETHING FOR THEM OTHER THAN THE
;NORMAL EDITOR THING SHOULD CALL RPG WITH 'KLUDGE' IN 17 AND A FUNCTION
;CODE IN 16 TO TELL IT WHAT TO DO.	WHAT A HACK!

RPST2:	MOVE T1,SAVE17
	SKIPE STRTFL	;WERE WE STARTED AT +1?
	CAME T1,['KLUDGE']	;AND SPECIAL CODE IN R17?
	JRST RPST3	;NO, FORGET IT
	MOVE T1,SAVE16	;YES, GET FUNCTION CODE
	CAIL T1,0
	CAIL T1,MAXFCN	;CHECK FOR BEING WITHIN RANGE
	 HALT .
	XCT SPCFCN(T1)	;DO WHATEVER IT WANTS
	JRST RPST3

SPCFCN:	PUSHJ P,SETPER		; 0 SET PERFORM MODE
	PUSHJ P,SETSFO		; 1 SET SFORTRAN-EDITOR MODE
	PUSHJ P,SETCFO		; 2 SET CFORTRAN-EDITOR MODE
	SETOM SFCFLG#		; 3 GET COMMAND FROM SFC NOT SVC
MAXFCN==.-SPCFCN

SETPER:	SETOM PERFLG#
	SETZM STRTFL#
	POPJ P,

SETSFO:	SOSA SFOMOD#
SETCFO:	SETOM CFOMOD#
	SETOM SFCFLG
	POPJ P,
RPST3:	SKIPE STRTFL
	JRST RPGSET	;OK, DO FUNNY STUFF FOR EDITOR CALL
IFDEF	RPGDEBUG,<
	OUTSTR	[ASCIZ/:-/]	;DEBUG MODE, GIVE A FUNNY GLITCH
>
IFNDEF	RPGDEBUG,<
	RESCAN			;NORMAL MODE, RESCAN COMMAND LINE
>
	MOVEI FL,0
	SKIPE	PERFLG		;HAVE WE BEEN CALLED BY "PERFORM"
	PUSHJ	P,PERFOR	;YES INDEED
	PUSHJ P,GSTRN	;GET THE COMMAND STRING
RPGRET:	MOVE T1,[XWD INIDAT,INILOW]
	BLT T1,INILOW+INILEN-1
	MOVE T4,JOBNAM	;GET SIXBIT JOB NUMBER
	TLO T4,404040	;NOW TO ASCII FOR ASCIZ'S
	MOVEI T1,3	;THREE CHARS
	LSH T3,1
	LSHC T3,6	;BRING IN A CHAR
	SOJG T1,.-2
	DPB T3,[POINT 21,CRFRDR,27]	;SAVE IN ASCIZ
	DPB T3,[POINT 21,FCOMD,27]
	DPB T3,[POINT 21,FCOMD2,27]
	MOVEI T1,"F"
	SKIPE SFCFLG	;MAYBE SHOULD GET COMMAND FROM SFC RATHER TTHAN SVC
	DPB T1,[POINT 7,FCOMD+1,6]
	MOVSI T1,377777 ;SET COUNT TO A LARGE NUMBER
	MOVEM T1,DINCT
	SETOM NOSTNM#	;NO NON-STARDARD PROCESSORS SEEN YET
	MOVE P,PDP		;SET UP PDL
	MOVE IOP,[IOWD <NESTDP+2>*3,IOPD]	;AND IO PDL
	MOVSI IOPNT,-<NESTDP+1> ;SET NEXT LIMIT
	SETZ	FL2,
	PUSHJ	P,STTYMX	;SET TYMEX
	TRO FL,DOLOD		;WE WANT TO LOAD
	MOVSI FLP,IDXFOR	;ASSUME F4 DEFAULT PROCESSOR
	SKIPE SFOMOD
	MOVSI FLP,IDXSFO	;BUT MAKE IT SFORTRAN IN SFO MODE
	SETZM FLT,LOKNAM	;NO TEMP FLAGS, NO ALTERNATE DEVICE
	MOVE T1,JOBFF
	MOVEM T1,SVJFF
	MOVE T1,JOBREL
	MOVEM T1,CORTOP
	MOVEM T1,CORT1
	SETZM SAVCHR	;TO START THINGS
	HLLZS JOBERR	;RESET ERROR COUNT
	MOVSI SVPT,-NFILE
	MOVEI T1,P.NSD
	PUSHJ P,GETPAR	;GET NONSTANDARD PROCS
	 JRST NORPNS	;NONE
	HRRZ T4,(T2)	;NUMBER
	LSH T4,-3
RPNSLP:	AOS T2,NOSTNM
	CAIL T2,NSDNM
	JRST	[SOS NOSTNM
		JRST NORPNS]	;QUIT
	AOS NPROC1	;ONE MORE PROCESSOR
	MOVE T3,(T1)
	MOVEM T3,NONSNM(T2)
	HLRZM T3,BNAM+NPROCS(T2)
	SKIPN T3,3(T1)
	MOVSI T3,'DSK'
	MOVEM T3,NONSDV(T2)
	MOVE T3,1(T1)
	HLLZM T3,NONSXT(T2)
	MOVE T3,2(T1)
	MOVEM T3,NONSPN(T2)
	MOVE T3,4(T1)
	MOVEM T3,NSDSWS(T2)	;SWITCH
	MOVE T3,5(T1)
	MOVEM T3,EXTAB+NPROCS(T2)	;EXTENSION
	MOVE T3,6(T1)
	MOVEM T3,NXPC+NPROCS(T2)
	MOVE T3,7(T1)
	MOVEM T3,INTEXT+NPROCS(T2)	;OUTPUT EXTENSION
	ADDI T1,10
	SOJG T4,RPNSLP
NORPNS:	MOVEI T1,P.DEF
	PUSHJ P,GETPAR
	 JRST NORPDF
	MOVE T1,(T1)
	MOVSI T2,-NPROCS
	CAME T1,SWTAB2-NPROCS(T2)
	AOBJN T2,.-1
	JUMPL T2,FNDRDF	;FOUND IT, SET INDEX
	MOVN T3,NOSTNM
	SUBI T3,1
	JUMPE T3,NORPDF
	HRL T2,T3
	CAME T1,NONSNM-NPROCS(T2)
	AOBJN T2,.-1
	SKIPGE T2
FNDRDF:	HRL FLP,T2	;SET IT
NORPDF:	MOVEI T1,P.NSDO
	PUSHJ P,GETPAR
	 JRST NOOSD	;NONE OF OLD STYLE
	OUTSTR [ASCIZ /PLEASE RESET NON-STANDARD PROCESSOR DEFINITIONS
/]
	MOVEI T2,0
	MOVEI T1,P.NSDO
	PUSHJ P,SETPAR
	JRST XIT
NOOSD:
	MOVSI T1,'SYS'
	MOVEM T1,NAMES1	;INITIALIZE USERNAME TABLE
	MOVE T1,[1,,4]
	MOVEM T1,PPNS
COMMENT ! FORCE LUD READ TO PICK UP ALL INFO ABOUT THIS USER
	;(WHENEVER GTUNO CALLED LATER)
	AOS NMLSTP
	HRROI T1,-22
	GETTAB T1,	;FIRST HALF OF THIS USER'S NAME
	HALT .
	MOVEM T1,NAMES1+1
	HRROI T1,-21	;SECOND HALF
	GETTAB T1,
	HALT .
	MOVEM T1,NAMES2+1
	HRROI T1,GETPRV
	GETTAB T1,
	HALT .
	MOVEM T1,LDPRV+1	;HIS CURRENT JBTPRV
	;SETZM LDBITS+1		;LUD STATUS BITS
END COMMENT !
	HRROI T1,-23	;AND HIS PPN
	GETTAB T1,	;(HIS LOGIN PPN NOT GFD PPN)
	 HALT .
COMMENT !
	MOVEM T1,PPNS+1
END !
	MOVEM T1,LOGPPN#	;AND SAVE LOGIN PPN
	PUSHJ P,SCAN

	MOVE T1,[XWD -COMTLG,COMTAB]	;CALL SCANNER FOR WORDS
	PUSHJ P,SWSCAN
	JRST	[OUTSTR [ASCIZ "ILLEGAL COMMAND NAME: "]
	JRST	ERRCOM]
	JFCL	;EXACT MATCH RETURN. ANY MATCH WILL DO
	HLLZ T2,COMT2-COMTAB(T1)
	JUMPE T2,@COMT2-COMTAB(T1)	;ZERO LH MEANS DO MAILBOX THING
	HRROI T2,-20
	GETTAB T2,
	 MOVEI T2,0
	HRL T2,T2	;TURN OFF LICENSE FOR OTHER COMMANDS
	SETLIC T2,
	XCT COMT2-COMTAB(T1)	;DO IT
	SUBI T3,1
	MOVE T2,[SIXBIT'/11Y']
	SKIPE SFOMOD	;IF WE WERE CALLED FROM SFO EDITOR
	PUSHJ P,LODSIX	;THEN LET THE LOADER AND USER PROGRAM KNOW IT
	MOVSI T2,'/3Y'
	SKIPE CFOMOD
	PUSHJ P,LODSIX	;DO CFORTRAN THE SAME FAVOR
	TRZE FL,ALTSRC
	PUSHJ P,SCAN	;GET BY EDIT
	PUSHJ P,SCAN	;GET NEXT THING
	TRNN IOPNT,-1	;IF DOWN A LEVEL ITS OK
	TLNN CS,TERMF	;OR IF NOTHING SEEN
	SKIPA
	JRST COMAT1
	TRNE FL,EDITF
	JRST DOEDT1
	JRST NXFIL1
COMAT1:	MOVE T1,[POINT 7,FCOMD] ;GENERATE FAKE COMMAND TO READ
	TRNN FL,EDITF
	TROA FL,RPGSRC!ALTSRC	;TRY FOR SVCM FILE
	MOVE T1,[POINT 7,FCOMD2]
	MOVEM T1,DINPT	;SAVE FILE
	TRO FL,RECALF+NOSVC	;MARK RECALLING FILE, DONT WRITE
	SETZM SAVCHR	;CLEAR OUT SCANNER
	MOVSI IOPNT,-<NESTDP+2> ;ALLOW EXTRA NESTING
	PUSHJ P,SCAN
	TRNE FL,EDITF
	JRST DOEDIT
;INITIALIZE FOR A NEW FILE NAME IN THE COMMAND

NXFIL:	PUSHJ P,SCAN
NXFIL1:	MOVSI SVPT,-NFILE	;SET UP FOR NUMBER OF FILES
	MOVEI T1,SWBK*5
	MOVEM T1,SWCNT#		;# OF ALLOWABLE COMPILER SWITCH CHARS
	MOVE T1,[POINT 7,SWBLK]
	MOVEM T1,SWPT#		;AND BYTE PTR FOR DEM
	SETZM SWBKL
	SETZM SWBKB
	SETZM ONAM
	SETZM OEXT
	SETZM OPPN	;NO OUTPUT EXTENSION OR PPN
	MOVE FLT,FLP	;SET TEMP FLAGS FROM PERM FLAGS
	MOVE T1,[POINT 7,LODSBK]	;SET POINTER TO LOADER
	MOVEM T1,LODSP		;SWITCH BLOCK
	MOVEI T1,LODSCT
	MOVEM T1,LODCTR
	MOVEM T1,LODCT2 ;AND SET COUNT FOR AFTER FILE NAME SWITCHES
	MOVE T1,[POINT 7,LODSB2]
	MOVEM T1,LODSP2
	SETZM BROCNT	;CLEAR OUT THE <> COUNT
	TRZ FLP,FORWDS!REFSW	;THESE ARE PERM FOR ONE "LINE" ONLY
	SETZM SDAT	;ACCUMULATE DATES AS WE GO
	JRST	ILP0A
;MAIN LOOP FOR READING INPUT
;CHECK FOR PERMANENT SWITCHES, THEN FILE NAME, THEN TEMP SWITCHES
;(ALSO CHECK FOR OTHER SPECIAL THINGS)

ILP0:	PUSHJ P,SCAN	;GET FIRST "THING"
ILP0A:	CAIN C,"/"	;CHECK FOR PERM COMPILE SWITCHES
	JRST COMPS1
	CAIN C,"%"	;CHECK FOR PERM LOADER FLAGS
	JRST LOADS1
	TLNN	CS,TERMF
	CAIN	C,","		
	JRST	[MOVE T2,[POINT 7,LODSBK]
		MOVEI	T3,OUTLOD
		TRNE FL,DOLOD
		PUSHJ	P,OUTSW
		MOVEI	T1,","
		TRNE FL,DOLOD
		PUSHJ	P,OUTLOD
		SETZM	LODSBK
		SETZM	LODSBK+1
		JRST	NXFIL]
	TRZ FL,PROCS	;NO PROCESSOR SWITCHES SEEN YET
	MOVE T1,FLP
	ANDI T1,FORWDS!REFSW	;FORCE TEMP SAME AS PERM (TEMP IS ONE FILE)
	TRZ FLT,FORWDS!REFSW
	IOR FLT,T1
	CAIN	C,"]"
	JRST	ILP1B
	CAIE	C,"!"
	CAIN	C,"["
ILP1B:	JRST	[MOVE T1,C
		PUSHJ P,OUTLOD
		SETOM NEDSAV#
		JRST ILP0]
	PUSHJ P,GETNAM	;GO GET A FILE NAME
	PUSHJ P,XSWS	;EXCHANGE LOADER SWITCH LISTS
ILP2A:	PUSHJ P,SCAN	;GET THE SPECIAL CHR OR WHATEVER
ILP2:	CAIN C,"("	;MAYBE SWITCHES TO BE PASSED TO PROCESSORS
	JRST PROCSW
	CAIN C,"/"	;OR FOR US
	JRST COMPSW
	CAIN C,"%"
	JRST LOADS2
	CAIN C,"="	;MAYBE HE IS SETTING THE OUTPUT NAME
	JRST SETONM
	PUSHJ P,GETDAT
	CAIE C,","	;DONE WITH THIS SET OF NAMES?
	TLNE CS,TERMF	;WILL ACCEPT A TERMINATOR
	JRST SETUP	;GO SET UP THE FILES FOR PROCESSORS
	CAIE	C,"]"
	CAIN	C,"!"
	JRST	[	SETOM NEDSAV
		JRST SETUP	]
	CAIN C,">"
	JRST ENDBRO	;THIS IS THE END OF A BROKET STRING
	JUMPE C,SYNERR	;NULL CHARACTER GETS NONCOMITTAL MESSAGE
	CAIE C,"+"	;IS THIS A SECOND FILE
	JRST ILLCHR	;IT SHOULD HAVE BEEN ONE OF THOSE
	TRNN FLT,REFSW		;DO NOT ADVANCE POINTE IF REF
	AOBJP SVPT,TMNER	;MAYBE TOO MANY FILES
	PUSHJ P,XSWS
	PUSHJ P,SCAN	;GET NEXT
	CAIE C,"<"	;IS THIS THE <> CONSTRUCTION
	JRST ILP0A	;NO
	AOS BROCNT	;WE ARE ONE DEEPER IN BROKETS
	PUSH P,FLT
	PUSH P,SVPT	;SAVE AWAY ALL THE IMPORTANT INFORMATION
	PUSH P,SWPT
	PUSH P,SWCNT
	PUSH P,LODSP
	PUSH P,LODSP2
	PUSH P,LODCTR
	PUSH P,LODCT2
	PUSH P,SWBKL
	PUSH P,SWBKB
	PUSH P,ONAM
	PUSH P,SDAT
	JRST ILP0	;GO FINISH THINGS UP

ENDBRO:
	SOSGE BROCNT	;ERROR IF NO < WAS SEEN
	JRST SYNERR
	SUB P,[14,,14]	;RESET PDL
	JRST ILP2A	;GO PRETEND > NOT SEEN (COMMA SHOULD BE NEXT)

NXFILP:	SKIPG BROCNT	;ARE WE DONING BROKETS?
	JRST NXFIL	;NO, JUST CONTINUE
	MOVE T1,P
	POP T1,SDAT
	POP T1,ONAM
	POP T1,SWBKB
	POP T1,SWBKL
	POP T1,LODCT2
	POP T1,LODCTR
	POP T1,LODSP2
	POP T1,LODSP
	POP T1,SWCNT
	POP T1,SWPT
	POP T1,SVPT
	POP T1,FLT
	JRST ILP0
COMPS:	PUSHJ P,SCAN	;GET THE NAME OF THE SWITCH
;HANDLE COMPILER SWITCH, EITHER TEMP OR PERM

	TRNN FL,IDF	;WAS THERE REALLY AN IDENTIFIER THERE?
	JRST SYNERR	;LOSE
	MOVE T1,[XWD -TBLG,SWTAB]
	PUSHJ P,SWSCAN
	JRST	[MOVE T1,[XWD -NSDNM,NSDSWS]	;LOOK FOR NON-STANDARD PROCESSORS
	PUSHJ P,SWSCAN	;IS IT THERE??
	JRST UNRECS	;NO MATCH, LOSE
	JRST GSW2	;EXACT MATCH OK
	JRST GSW2]	;SO IS PARTIAL MATCH
	JRST GETSW	;EXACT MATCH, GO
	JRST	[MOVE T1,[XWD -NSDNM,NSDSWS]	;PARTIAL MATCH
	PUSHJ P,SWSCAN	;CHECK FURTHER
	JRST GSW1	;NONE THERE USE OLD MATCH
	JRST GSW2	;THIS ONE EXACT, USE IT
	JRST UNRECS]	;BOTH PARTIAL SO LOSE
GSW2:	SUBI T1,NSDSWS
	MOVE T1,SWTAB3(T1)
	JRST INTSW
GSW1:	MOVE T1,SVIND	;GET BACK ONLY MATCH NUMBER
GETSW:	MOVE T1,SWTAB2-SWTAB(T1)	;GET ACTION
INTSW:	TLNE T1,IMED	;IMMEDIATE SWITCH?
	JRST (T1)	;YES, DO IT NOW
	PUSH P,JSCAN	;TO RETURN TO SCAN
INTSW1:	TLZN T1,PROC	;PROCESSOR SWITCH?
	JRST INTSWS	;NO
	CAIN T1,IDXFTF	;SETTING FTF40?
	SETOM FTFFLG	;YES, REMEMBER FOR LOADER
	CAIN	T1,IDXFTX	;If setting FTFORT,
	  SETOM	  FTXFLG	;  then remember for loader
	HRL FLT,T1	;SET TEMP PROCESSOR SWITCH (AND CLEAR OTHERS)
	TRNE FL,PERF
	HRL FLP,T1	;DITTO FOR PERM SWITCH IF NEEDED
	POPJ P,
INTSWS:	TLNE T1,OFF	;NONPROCESSOR, DOES IT GO ON OR OFF?
	JRST INTSWF
	TRO FLT,(T1)	;ON, DO IT FOR TEMP
	TRNE FL,PERF
	TRO FLP,(T1)	;AND MAYBE PERM
	POPJ P,
INTSWF:	TRZ FLT,(T1)	;OFF DO IT FOR TEMP
	TRNE FL,PERF
	TRZ FLP,(T1)	;AND MAYBE PERM
	POPJ P,

;BITS IN LH OF SWTAB2 ENTRIES
IMED==1		;GO EXECUTE THIS ONE - DON'T JUST SET BITS
OFF==2		;TURN SELECTED BIT OFF (OTHERWISE ON)
PROC==4		;RH IS PROCESSOR BIT, NOT NORMAL SWITCH.	SET LH INSTEAD OF RH

DEFINE X (A,B,C,D,E,F)
<SWITCH A,<PROC,,IDX'A>>

	DEFINE TABLE
<SWITCH LIST,<IMED,,SETLST>
SWITCH CREF,<IMED,,SETCRF>
SWITCH M,<PROC,,IDXMAC>
SWITCH C,<IMED,,SETCRF>
SWITCH CROSS,<IMED,,SETCRO>
SWITCH LIBRARY,<LIBSW>
SWITCH LIB,<LIBSW>
SWITCH LIBF40,<IMED,,F40LIB>
SWITCH LIBSFORTRAN,<IMED,,SFOLIB>
SWITCH LIBALGOL,<IMED,,ALGLIB>
SWITCH LIBCOBOL,<IMED,,COBLIB>
SWITCH LIBSYM,<IMED,,LIBSYM>
SWITCH REL,<PROC,,IDXLOA>
SWITCH NOLIST,<OFF,,LISTSW>
SWITCH NOSEARCH,<OFF,,LIBSW>
SWITCH HOTSTART,<IMED,,HOTSTR>
SWITCH MIXFOR,<IMED,,FORMIX>
SWITCH NOMIXFOR,<IMED,,NOFMIX>
SWITCH L,<IMED,,SETLST>
SWITCH F,<PROC,,IDXFOR>
SWITCH N,<OFF,,LISTSW>
SWITCH COMPILE,<COMPLS>
SWITCH NOCOMPILE,<OFF,,COMPLS>
SWITCH NOLOAD,<NOLODS>
SWITCH LOAD,<OFF,,NOLODS>
SWITCH DEBUG,<DEBSW>
SWITCH NODEBUG,<OFF,,DEBSW>
SWITCH FORWARD,<FORWDS>
SWITCH NOTFORWARD,<OFF,,FORWDS>
SWITCH REFERENCE,<REFSW>
SWITCH NOREFERENCE,<OFF,,REFSW>
SWITCH MAP,<IMED,,SETMAP>
SWITCH NONSTANDARD,<IMED,,NONSTD>
SWITCH NSLOAD,<IMED,,NSLOD>
SWITCH NOBINARY,<NOBIN>
SWITCH BINARY,<OFF,,NOBIN>
SWITCH SDEBUG,<IMED,,SDEBSW>
SWITCH FDEBUG,<IMED,,FDEBSR>
SWITCH SAVE,<IMED,,STSAV>
SWITCH SSAVE,<IMED,,STSSAV>
SWITCH NAME,<IMED,,STNAM>
SWITCH PROFILE,<IMED,,STPRF>
SWITCH SYMFILE,<IMED,,STSYM>
SWITCH INITIAL,<IMED,,STINI>
SWITCH CLOSE,<IMED,,STCLS>
SWITCH USER,<IMED,,SETUSR>
SWITCH RUN,<IMED,,SETRUN>
SWITCH SEARCH,<IMED,,SRCLIB>
PROCESS
>

TBGEN (SWTAB,TBLG,SWTAB2)
SWTAB3:	FOR (1,NSDNM,<PROC,,IDXLOA-NSDNM-1+XXX>)
;LOOK UP A SWITCH IN A GIVEN TABLE. NO SKIP IF NOT FOUND,
;SKIP IF EXACT MATCH, DOUBLE SKIP IF PARTIAL MATCH WITH NO AMBIGUITY

SWSCAN:	MOVE T3,ACCUM	;FIND OUT HOW MANY LETTERS
	MOVNI T2,1
SWSC1:	CAMN	T3,[SIXBIT '?']
	JRST	SWSC0C
	LSH T3,6
	LSH T2,-6	;GET ZEROS IN T2 WHERE THERE ARE LETTERS
	JUMPN T3,SWSC1
	SETOM NUMAT	;NONE FOUND YET
SWSC3:	MOVE T3,(T1)
	CAMN T3,ACCUM	;EXACT MATCH?
	JRST CPOPJ1	;YES, SKIP RETURN
	ANDCM T3,T2	;LOOK AT ONLY THOSE LETTERS TYPED
	CAME T3,ACCUM	;MATCH NOW??
	JRST SWSC2	;NO
	AOS NUMAT	;RECORD ANOTHER PARTIAL MATCH
	MOVEM T1,SVIND	;SAVE IT
SWSC2:	AOBJN T1,SWSC3	;TRY FOR MORE
	SKIPE NUMAT	;MUST BE ONE AND ONLY 1 PARTIAL MATCH
	POPJ P,	 ;ELSE ERROR RETURN
	MOVE T1,SVIND	;GET IT
	AOS(P)	;PARTIAL IS DOUBLE SKIP RETURN
CPOPJ1:	AOS(P)
	POPJ P,	 ;SKIP RETURN
SWSC0C:	MOVEM	T1,SVIND
	OUTSTR	[ASCIZ "OPTIONS ARE"]
	MOVEI	T2,":"
SWSC0A:	HRRZ	T3,SVIND
	CAIE	T3,COMTAB
	JRST	SWS0A1
	MOVE	T3,(T1)
	CAME	T3,[SIXBIT 'CTEST']
	CAMN	T3,[SIXBIT 'CRE']
	JRST	SWSC0D
	CAMN	T3,[SIXBIT 'CREF']
	JRST	SWSC0D
SWS0A1:	MOVE	T3,(T1)
	OUTCHR	T2
SWSC0B:	SETZ	T2,
	LSHC	T2,6
	ADDI	T2," "
	OUTCHR	T2
	JUMPN	T3,SWSC0B
	MOVEI	T2,","
SWSC0D:	AOBJN	T1,SWSC0A
	MOVE	T1,SVIND
	OUTSTR	[ASCIZ ".
"]
	JRST	EX

XSWS:	MOVE C,LODSP
	EXCH C,LODSP2
	MOVEM C,LODSP
	MOVE C,LODCTR
	EXCH C,LODCT2
	MOVEM C,LODCTR
	POPJ P,

STSYM:	MOVE	T2,[SIXBIT'/15Y']
	JRST	LDSSCN
STINI:	SKIPA	T2,[SIXBIT'/1Y']
STCLS:	MOVSI	T2,'/0Y'
LDSSCN:	TRNE FL,DOLOD
	PUSHJ	P,LODSIX	;SEND FLAG TO LOADER
	JRST	SCAN

STPRF:	MOVEI	T3,OUTLOD
	MOVEI	T2,[ASCIZ'PRFGEN[1,4],/S/15Y']
	TRNE FL,DOLOD
	PUSHJ	P,OUTASC
STSAV:	SKIPA	T2,[SIXBIT'/-2Y']
STSSAV:	MOVE	T2,[SIXBIT'/-1Y']
	SETZM	LODNSV
STFIL:	AOBJP	SVPT,TMNER	;AVOID CLOBBERING ANY CURRENT FILE NAME
	PUSH	P,T2		;SAVE THAT SWITCH!!
	PUSHJ	P,SCAN
	CAIE	C,":"		;GOT TO HAVE A COLON AFTER THE SWITCH
	JRST	SYNERR
	PUSH	P,DEFPPN
	SETZM	DEFPPN		;DON'T USE DEFAULT USER NAME
	PUSHJ	P,GETNMS	;GET THE FILE NAME
	POP	P,DEFPPN
	MOVEI	T3,OUTLOD	;PREPARE FOR OUTPUT TO LOADER
	MOVE	T4,SVPT		;POINTER TO FILE NAME STUFF
	TRNE FL,DOLOD
	PUSHJ	P,CMNO		;SEND FILE NAME TO LOADER
	POP	P,T2		;GET THE SWITCH BACK
	TRNE FL,DOLOD
	PUSHJ	P,LODSIX	;WRITE IT OUT TOO
	SUB	SVPT,[1,,1]
	JRST	SCAN

SETUSR:	PUSHJ	P,SCAN
	CAIE	C,"("
	JRST	SYNERR		;USER NAME MUST BEGIN WITH (
	PUSHJ	P,GTUNO
	MOVEM	T3,DEFPPN	;SAVE USER NAME (PPN) AS DEFAULT
	CAIE	C,")"
	JRST	SYNERR		;MUST END WITH )
JSCAN:	JRST	SCAN

SDEBSW:	PUSH	P,JSCAN		;TO RETURN TO SCAN
SDEBCM:	SETOM NEDSAV
	TRO	FLT,FDEBSW	;SET /DEBUG AS TEMPORARY
	TRO	FLP,FDEBSW	;AND PERMANENT
	MOVE	T2,[SIXBIT'/12Y']
	TRNN FL,DOLOD
	POPJ P,
	JRST	LODSIX		;TELL LOADER TO GET SFO DEBUGGER

FDEBSR:	TRO	FLP,FDEBSW	;TELL F40 ABOUT FDEBUG
	TRO FLT,FDEBSW
	MOVSI	T2,'/S '
	JRST	LDSSCN		;TELL LOADER TOO

STNAM:	OUTSTR	NMSWRN
	JRST	BYENOW

NMSWRN:	ASCIZ"The /NAME switch is no longer valid, and its function has been
taken over by the /SAVE switch.	You must now include a /SAVE
switch in your command string if you want the overlay file to
be saved.	Please contact your local Tymshare representative
for further information.
"

HOTSTR:	MOVE T2,[SIXBIT '/-4Y/']
	JRST STFIL
FORMIX:	SKIPA T2,[SIXBIT '/-6Y']
NOFMIX: MOVE T2,[SIXBIT '/-7Y']
	TRNE FL,DOLOD
	PUSHJ P,LODSIX
	JRST SCAN
;HERE ON "/" AFTER A FILE NAME

COMPSW:	TRZ FL,PERF	;DOING TEMP
	PUSHJ P,COMPS
	JRST ILP2

;HERE ON "/" AS FIRST CHAR OF IDENT, I.E. PERM SW

COMPS1:	TRO FL,PERF
	PUSHJ P,COMPS
	JRST ILP0A

SETMAP:	TRON FL,MAPST	;IS IT SET?
	TRNN FL,DOLOD
	JRST SCAN	;ONLY THE FIRST TIME IF LOADING
	MOVEI T3,OUTLOD
	PUSHJ	P,OUCRLF
	MOVE T2,[SIXBIT'MAP_/M']
	PUSHJ P,OUTSIX
	JRST SCAN
COBLIB:	SKIPA	T2,[SIXBIT'/10Y']
F40LIB:	MOVSI	T2,'/5Y'
	JRST	LDSSCN
LIBSYM:	SKIPA	T2,[SIXBIT'/14Y']
SFOLIB:	MOVSI	T2,'/6Y'
	JRST	LDSSCN
ALGLIB:	MOVSI	T2,'/7Y'
	JRST	LDSSCN
SRCLIB:	MOVSI T2,(SIXBIT !/F!)
	JRST LDSSCN
PROCSW:	TROE FL,PROCS	;HAVE WE ALREADY SEEN SOME?
	JRST SYNERR	;YES, I DEFINE THIS AS ILLEGAL
	SETZB	T3,SWBKS(SVPT)
	MOVE	C,[0 @PROCS0]
	MOVEM	C,PCM#
	MOVE	T1,SWPT
	MOVEM	T1,SWPT0#
PROCS1:	PUSHJ	P,GETCH
	SOSG	SWCNT
	JRST	ETMS
	CAIE	C,")"
	CAIN	C,","
	JRST	PROCS2
	CAIE	C,"/"	;ALLOW "/" SWITCHES WITHIN PARENDS FOR F10
	CAIN	C,":"	;ALLOW : WITHIN PARENDS FOR F10 SWITCHES
	CAIA		;SKIP FOR F10 CHARS / AND :
	JUMPLE	CS,SYNERR
	IDPB	C,SWPT0
	JRST	PROCS1

PROCS0:	0	SWBKS(SVPT)
	EXP	SWBKB,SWBKL	;DON'T YOU DARE TO MOVE IT
PROCS2:	MOVE	T1,SWPT
	CAMN	T1,SWPT0
	JRST	PROCS3
	SKIPE	@PCM
	JRST	SYNERR
	MOVEM	T1,@PCM
	IDPB	T3,SWPT0
	MOVE	T1,SWPT0
	MOVEM	T1,SWPT
PROCS3:	CAIN	C,")"
	JRST	ILP2A
	AOS	C,PCM
	SKIPE	@PCM
	JRST	SYNERR
	JRST	PROCS1

;SETONM HANDLES THE = CONSTRUCTION TO SET A REL FILE NAME

SETONM:	SKIPN ONAM	;DON'T ALLOW A=B=C
	TRNE FL,PROCS	;OR SWITCHES IN THE MIDDLE OF IT
	JRST SYNERR
	MOVE T1,SVNAM(SVPT)	;GET THE NAME
	MOVEM T1,ONAM	;AND SAVE IT AWAY
	MOVE T1,SVEXT(SVPT)
	MOVEM T1,OEXT
	MOVE T1,SVPPN(SVPT)
	MOVEM T1,OPPN	;SET UP EXT AND PPN FOR OUTPUT NAME
	PUSHJ P,XSWS
	JRST ILP0	;AND GO

LOADS1:	PUSHJ P,LODS1
	JRST ILP0
LOADS2:	PUSH P,[ILP2A]	;SET RETURN POINT
LODS1:	PUSHJ P,GETCH	;NEXT CHR
	CAIE	C,"-"		;ALLOW MINUS IN LOADER SWITCHES
	JUMPLE CS,SYNERR	;SPECIAL CHARACTERS NOT PERMITTED
	IDPB C,LODSP	;SAVE IT
	SOSG LODCTR	;CHECK SIZE
	JRST ETMS
	TLNN CS,NUMF	;A NUMBER
	POPJ P,	 ;NO, DONE
	JRST LODS1	;YES, THEY GET PASSED ON

SWBITS:	HRRZ T2,(T4)	;LIST POINTER IN T4 LIST GEN WITH SBTS
	XCT @(P)	;THE MAJIC TEST INSTR
	JRST NOSW	;NOT THIS ONE
	HLLZ T2,(T4)	;GET SIXBIT
	PUSHJ P,OUTSIX
NOSW:	AOBJN T4,SWBITS
	AOS (P)	 ;SKIP THE INSTRUCTION WE WERE EXECUTING
	POPJ P,

SETLST:	MOVE T1,[OFF,,CRSW]
	PUSHJ P,INTSW1	;TURN /CREF OFF
	MOVEI T1,LISTSW	;AND /LIST ON
	JRST INTSW

SETCRF:	TLZ FL,ALLCRF	;GET RID OF FLAGS
SETCRC:	MOVEI T1,CRSW!LISTSW
	JRST INTSW	;FAKE A SWITCH AND RETURN

SETCRO:	TLZ FL,ALLCRF
	PUSHJ P,STARGS
SETCR1:	TRNN FL,IDF
	JRST SYNERR
	MOVE T1,[XWD -CLG,CSWS]
	PUSHJ P,SWSCAN
	JRST UNRECS
	JFCL
	TLO FL,@CSWS2-CSWS(T1) ;SET SWITCH
	TLNN FL,PARFLG ;IN THE () MODE?
	JRST SETCRC	;SCAN AND FAKE SWITCH
	PUSHJ P,SCAN
	CAIE C,")"
	JRST SETCR1
	JRST SETCRC

DEFINE TABLE
<SWITCH NOSYMBOLS,CNSBT
SWITCH NOMACROS,CNMBT
SWITCH OPCODES,COPBT
SWITCH NOLISTING,CNLBT
SWITCH MONITOR,CMONBT
SWITCH COMBINE,CCMBT>
TBGEN (CSWS,CLG,CSWS2)
;FINISHED SCANNING A NAME, PICK OUT THE RIGHT FILE FOR IT 
;(CHECK STANDARD PROCESSORS, REL FILE, ETC)

SETUP:	MOVEM	C,SAVC#
	TRNE FLT,REFSW	;SPECIAL IF THIS IS REFERENCE
	JRST	[TRNN SVPT,-1
		JRST SYNERR	;MUST NOT BE ONLY FILE
		SUB SVPT,[1,,1]
		JRST .+1]
	SETZM RELDEF#	;SHOW USING = CONSTRUCT
	SKIPE ONAM	;SET ONAM IF NOT ALREADY
	JRST ONSET
	SETOM RELDEF	;OOPS, REALLY WEREN'T USING = CONSTRUCT
	MOVE T1,SVNAM(SVPT)	;AS LAST FILE NAME
	MOVEM T1,ONAM
	MOVE T1,SVPPN(SVPT)
	MOVEM T1,OPPN	;SET UP PPN SAME AS INPUT
	SETZM OEXT	;AUTO REL EXT
ONSET:	MOVSI T1,-NFILE ;NUMBER OF FILES
	TLO FL2,-1	;NO PROCESSOR YET
	PUSHJ P,GETPRO	;GO FIND DATE AND PROCESSOR
	HLRZ T1,FL2
	CAIN T1,IDXLOA	;IF A REL FILE
	JRST NOCOM1	;GO LOAD IT NOW
	SKIPA T1,OPPN
REREL:	SETZB T1,OPPN
	MOVEM T1,LPPN	;BUT ONLY FIRST TIME
	MOVE T1,ONAM	;SEE IF REL IS THERE
	MOVEM T1,LNAM
	HLRZ T1,FL2	;GET PROCESSOR NUMBER
	SKIPN T2,OEXT		;SPECIFIED OUTPUT EXTENSION
	 MOVE T2,INTEXT(T1)	;IF NONE SPECIFIED, PROCESSORS STANDARD
	CAIN T2,0		;IF NEITHER GAVE AN EXTENSION
	 MOVSI T2,'REL'		;THEN USE .REL
	MOVEM T2,OEXTP		;MAKE SURE IT GETS SET
	MOVEM T2,LEXT		;STORE IN EXTENSION TO LOOK UP
	TRNE FLT,COMPLS ;DO WE ALWAYS WANT TO COMPILE?
	JRST DOCOMP	;YES, IGNORE DATES
	PUSHJ P,UFDLK	;DOES FILE EXIST?
	JRST DOCOM1	;NO, WE MUST RECOMPILE
	HLRZ T2,FLT
	CAIN T2,IDXLOA
	JRST NOCOM1	;IF /REL, DON'T COMPILE EVER
	HLRZ T2,FL2
	CAIE T2,IDXFOR
	CAIN T2,IDXFTF
	JRST NODEB
	CAIE	T2,IDXF10
	 CAIE	 T2,IDXFTX
	  JRST	  NODEB
	CAIE T2,IDXSFO	;IF SFO
	SKIPN DEBTBL(T2)	;OR NO DEBUG SWITCH FOR THIS PROC
	JRST NODEB	;DO NOTHING SPECIAL
	TRNN FLT,DEBSW
	TDZA T2,T2
	MOVEI T2,1B24
	XOR T2,CURBTS
	TRNE T2,1B24	;THESE MUST AGREE
	JRST DOCOM1	;ELSE FORCE RECOMP
NODEB:	MOVE T2,LDAT
	CAMG T2,SDAT	;IS REL NEWER THAN SOURCE?
	JRST DOCOM1	;NO, COMPILE IT
	MOVE T1,OEXT
	MOVEM T1,OEXTP
	JRST NOCOM1	;YES, FINE
;SET UP APPROPRIATE COMMAND FOR THE PROCESSOR WHICH HAS BEEN ELECTED
;FOR THIS FILE

DOCOM1:	SKIPE OPPN
	JRST REREL	;IF TRIED ANOTHER, TRY SELF
DOCOMP:	SETZM OPPN
	HLRZ T3,FL2
	MOVEM T3,PCNUM	;SAVE IT FOR LATER
	ADDI T3,1
	PUSHJ P,FNDOPR	;FIND THE OUTPUT ROUTINE
	TRNE FLT,NOBIN	;DOING ANY REL FILE?
	JRST TRYLST	;NO, LISTING
	MOVE T2,ONAM	;START PUTTING OUT
	PUSHJ P,OUTSIX
	SKIPN T2,OEXTP
	JRST NREXT
	HLLZS T2	;PUT OUT EXTENSION
	MOVEI T1,"."
	PUSHJ P,(T3)
	PUSHJ P,OUTSIX
NREXT:	SKIPE T2,SWBKB	;ARE THERE SWITCHES
	PUSHJ P,OUTSW	;YES, OUTPUT THEM
TRYLST:	TRNN FLT,LISTSW ;LISTING REQUESTED?
	JRST NOLST
	MOVEI T1,","	;YES, NEED A COMMA
	PUSHJ P,(T3)
	MOVE T2,ONAM	;SET IT UP
	PUSHJ P,OUTSIX
	TRNN FLT,CRSW	;CREF MAYBE
	JRST NOLST1
	MOVSI T2,'/C '
	PUSHJ P,OUTSIX
NOLST1:	PUSH P,T3	;PUT OUT TO CREF FOR /L ALSO
	PUSH P,T5	;SAVE T5 ALSO
	PUSHJ P,ENTCRF	;PUT IT IN THE ###CREF FILE
	POP P,T5
	POP P,T3
	SKIPE T2,SWBKL	;SWITCHES?
	PUSHJ P,OUTSW
NOLST:	TRNN FLT,FDEBSW!DEBSW	;DO WE WANT TO DEBUG?
	JRST NOLDB	;NO
	HLRZ T2,FL2	;GET PROCESSOR NUMBER
	SKIPE T2,DEBTBL(T2)
	PUSHJ P,OUTSIX
NOLDB:	MOVEI T1,"_"
	PUSHJ P,(T3)
	MOVSI T4,-NFILE
PRCLP:	PUSHJ P,CMNO
	SKIPE T2,SWBKS(T4)	;AND SWITCHES
	PUSHJ P,OUTSW
	CAMN T4,SVPT	;ALL DONE?
	JRST ENDPRC	;YES, GO FINISH UP AND CONSIDER LOADING
	MOVEI T1,","
	PUSHJ P,(T3)	;NEXT FILE
	AOBJN T4,PRCLP
ENDPRC:	PUSHJ	P,OUCRLF
	HLRZ T3,FL2
	SKIPN T2,NXPC(T3)	;IS THERE ANOTHER PROCESSOR?
	JRST NOCOM1		;NO
	MOVSI SVPT,-NFILE	;RESET POINTER
	MOVE T1,ONAM	;AND FAKE WORLD
	MOVEM T1,SVNAM
	MOVE T1,OEXTP
	MOVEM T1,SVEXT
	SETZM OEXT
	SETZM SVPPN
	SETZM SWBKS
	SETZM SWBKB
	SETZM SWBKL
	MOVN T1,NPROC1	;FIND THE EXTENSION
	HRLZS T1
	CAME T2,EXTAB(T1)
	AOBJN T1,.-1
	JUMPGE T1,NOCOM1	;IGNORE IT IF NOT THERE
	HRL FL2,T1		;SET UP FOR PROCESSOR
	JRST REREL	;AND GO EMIT CALLS
CMNO:	SKIPN T2,SVDEV(T4)	;IS THERE A DEVICE THERE
	JRST PRCLP2	;NO
	PUSHJ P,OUTSIX	;YES, PRINT IT
	MOVEI T1,":"
	PUSHJ P,(T3)
PRCLP2:	SKIPE T2,SVNAM(T4)	;PUT OUT NAME
	PUSHJ P,OUTSIX
	HLLZ T2,SVEXT(T4)	;GET EXTENSION
	JUMPE T2,NOEXT	;NONE THERE
	MOVEI T1,"."
	PUSHJ P,(T3)
	PUSHJ P,OUTSIX
NOEXT:	SKIPE T2,SVPPN(T4)	;NEED PPN?
	PUSHJ P,OUTPPN	;PUT THEM OUT
	POPJ P,

	DEFINE X (A,B,C,D,E,F)
<<SIXBIT !F!>>
DEBTBL:	PROCESS
	BLOCK NSDNM
;SET UP LOADER COMMAND FOR THIS FILE

NOCOM1:	TRNN FLT,NOLODS!NOBIN	;IF NOT TO LOAD THIS ONE
	TRNN FL,DOLOD	;OR NOT LOADING
	JRST NXFILP	;NO, GO TO NEXT
	MOVEI C,0
	IDPB C,LODSP	;END SECOND SET OF SWITCHES
	IDPB C,LODSP2
	MOVEI T3,OUTLOD	;SET FOR LOADER
	MOVE T2,[POINT 7,LODSBK]	;OUTPUT FIRST SWITCHES
	PUSHJ P,OUTSW
	MOVE T2,ONAM	;NOW FILE NAME
	PUSHJ P,OUTSIX
	SKIPN T2,OEXTP
	JRST LODR2
	HLLZS T2
	MOVEI T1,"."
	PUSHJ P,OUTLOD
	PUSHJ P,OUTSIX
LODR2:	SKIPE T2,OPPN	;THEN THINK ABOUT PPN
	PUSHJ P,OUTPPN
	TRNN FLT,LIBSW	;LIBRARY?
	JRST	[TLZN FL,INLIB ;IN LIB MODE CURRENTLY?
	JRST ELOD	;NO, IGNORE
	MOVSI T2,(SIXBIT :/N:)
	JRST ELODP]
	MOVSI T2,'/L '	;TELL LOADER
	TLO FL,INLIB
ELODP:	PUSHJ P,OUTSIX
ELOD:	MOVE T2,[POINT 7,LODSB2]	;OUTPUT SECOND SET OF SWITCHES
	PUSHJ P,OUTSW
	SKIPN	T1,SAVC
	MOVEI	T1,","		;USE LAST DELIMITER OR ,
	PUSHJ	P,OUTLOD	;OUTPUT SOME DELIMITER
	JRST	NXFILP
;ROUTINE TO CHOOSE THE PROCESSOR FOR A FILE AND DECIDE WHETHER TO COMPILE AT ALL
;ALSO ROUTINE TO GET THE DATE FOR THE CURRENT FILE

GETDAT:	MOVE T3,NPROC1
	MOVE T2,SVNAM(SVPT)	;SET UP NAME AND PPN
	MOVEM T2,LNAM
	HLLZ T2,SVEXT(SVPT)
NXEXT:	PUSHJ P,ALTDEV	;LOOK UP FILE, SKIP IF FOUND
	JRST NOTYET	;HAVE NOT FOUND IT YET
FNDEXT:	HLLZ T2,LEXT	;GET THE EXTENSION
	MOVEM T2,SVEXT(SVPT)	;SAVE EXTENSION
FNDFWD:	MOVE T2,LDAT	;IS THE CURRENT FILE MORE RECENT THAT WHAT
	CAMLE T2,SDAT	;WE'VE HAD SO FAR?
	MOVEM T2,SDAT	;YES, SAVE ITS DATE AS THE NEWEST SOURCE FILE
	POPJ P,
GETPRO:	HLLZ T2,SVEXT(T1)	;GET THE EXTENSION WE FOUND
	CAME T2,[SIXBIT /REL/]
	CAMN T2,[SIXBIT /RDL/]
	JRST ISREL
	JUMPE T2,SETCP	;SET TO CURRENT PROCESSOR
	MOVN T3,NPROC1
	HRLZS T3	;MINUS AND IN LEFT HALF
	CAME T2,EXTAB(T3)
	AOBJN T3,.-1
	JUMPGE T3,SETCP ;NOT THERE
	JUMPL FL2,NEWPCC	;WE HAVE NOT SEEN ONE YET
	HLRZ T2,FL2
	CAIE T2,(T3)		;IS THIS THE SAME ONE?
	JRST PROCON		;NO, CONFLICT
NEWPCC:	HRL FL2,T3
NFIL2:	CAME T1,SVPT	;ARE WE DONE?
NFIL1:	AOBJN T1,GETPRO ;NO, GO ON
GTPRX:	HLRZ T1,FL2
	CAIE T1,IDXFOR		;NOTHING SPECIAL IF NOT F4
	JRST	GTPRX1
	HLRZ T1,FLT		;IS STANDARD FTF AND F4
	CAIN T1,IDXFTF		;NEED TO SWITCH TO FTF
	HRLI	FL2,IDXFOR	;/FTF OVERRIDES .F4 EXT, SO CHANGE PROCESSOR
	HLRZ T1,FL2	;RESTORE FOR BELOW
GTPRX1:	CAIN T1,IDXFTF
	SETOM	FTFFLG#		;IF FTF CHOSEN FOR ANY REASON, SET TO TELL LOADER
	CAIE	T1,IDXF10	;If not F10,
	  JRST	  GTPRX2	;  then nothing special
	HLRZ	T1,FLT		;Examine processor set via switch
	CAIN	T1,IDXFTF	;If user said "/FT",
	  HRLI	  FL2,IDXFTX	;  then pretend .FTX instead of .FOR
	HLRZ	T1,FL2		;Restore processor type for below
GTPRX2:	CAIN	T1,IDXFTX	;If .FTX set for any reason,
	  SETOM	  FTXFLG#	;  then remember to tell loader
CKSFDB:	MOVSI	T2,'RDL'
	TRNE	FLT,FDEBSW!DEBSW	;IF DEBUG MODE
	CAIE T1,IDXSFO		;AND DOING SFORTRAN
	POPJ P,
	SKIPN	OEXT		;AND NO EXTENSION GIVEN
	MOVEM	T2,OEXT		;THEN USE .RDL INSTEAD OF .REL
	POPJ	P,
SETCP:	CAME T1,SVPT	;AT END?
	JRST NFIL1	;NO, DO NOT SET
	JUMPGE FL2,GTPRX		;GO IF SOMETHING ALREADY SET
	HLL FL2,FLT	;NO, SET TO CURRENT PROCESSOR
	JRST	GTPRX

NOTYET:	SKIPE T2,SVEXT(SVPT)	;GET THE CURRENT EXT
	JRST NOFIL1	;IF HE SPECIFIED AN EXT WE LOSE
	MOVE T2,EXTAB-1(T3)	;ELSE PICK UP ONE
	SOJGE T3,NXEXT
NOFIL1:	TRNN FLT,FORWDS ;IF NOT FORWARD
	JRST TRYREL	;THEN NONE THERE
	HRLOI T2,377777	;SET LARGEST POSITIVE NUMBER AS DATE
	MOVEM T2,LDAT	;TO FORCE COMPILATION
	JRST FNDFWD


TRYREL:	MOVSI T2,'REL'
	PUSHJ P,ALTDEV
	 SKIPA		;NOT FOUND
	JRST FNDEXT	;GOT IT
	MOVSI T2,'RDL'	;CROCK FOR SFO
	PUSHJ P,ALTDEV
	 JRST NOFILX	;NO FILE
	JRST FNDEXT

ISREL:	TRNN SVPT,-1	;NO + CONSTRUCT ALLOWED
	SKIPN RELDEF	;AND NO = CONSTRUCT
	JRST SYNERR
	HRLI FL2,IDXLOA
	POPJ P,
;ALTDEV AND ALTDVP DO SOME DIDDLING WITH THE DEVICE NAME AND THEN
;IF THE CURRENT DEVICE IS DSK TRANSFER TO UFDLK TO LOOK UP THE FILE
;NAME (UFDLK SKIP RETURNS IF FOUND).	IF THE DEVICE IS NOT DSK,
;THE DATE WILL BE SET TO A VERY LARGE NUMBER FORCING RECOMPILE
;THIS CODE WILL NOT WORK WITH DECTAPE.

ALTDEV:	MOVEM T2,LEXT
	MOVE T2,SVPPN(SVPT)
	MOVEM T2,LPPN
	SKIPN T2,SVDEV(SVPT)	;SPECIAL DEVICE
ALTDVP:	SKIPE T2,LOKNAM	 ;OR REMEMBERING??
	SKIPA		;YES
	JRST UFDLK	;NO, JUST DO THE LOOKUP
	MOVEM T2,LOKNAM ;SAVE FOR LATER
	MOVEM T2,SVDEV(T1)	;AND IN DEVICE FOR OUTPUT
	DEVCHR T2,	;GET CHARACTERISTICS
	TLNE T2,DSKBT	;A DSK?
	JRST	[SETZM LOKNAM	;NO MORE NEED
		JRST UFDLK]	;GO DO THE LOOKUP
	HRLOI T2,377777
	MOVEM T2,LDAT	;SET VERY LARGE
	JRST CPOPJ1	;PRETEND FILE IS FOUND

OUTPPN:	HRRZM T2,SAVPPN ;CONVERT TO SIXBIT FOR OUTPUT
	MOVEI T1,"["	;START OUT
	PUSHJ P,(T3)
	HLRZ T1,T2	;GET NUMBER
	PUSHJ P,OUTOCT
	MOVEI T1,","
	PUSHJ P,(T3)
	HRRZ T1,SAVPPN
	PUSHJ P,OUTOCT
	MOVEI T1,"]"
	JRST (T3)

OUTOCT:	IDIVI T1,10	;OCTAL OUTPUT
	HRLM T2,(P)
	SKIPE T1
	PUSHJ P,OUTOCT
	HLRZ T1,(P)
	ADDI T1,"0"
	JRST (T3)

NOFILX:	MOVE T1,SVPT
NOFILP:	MOVE T2,SVNAM(T1)	;RESET THINGS FOR ERROR MSG
	MOVEM T2,NAME
	MOVE T2,SVEXT(T1)
	HLLZM T2,NAME+1
	JRST NOFIL
;MAKE LOOKUPS FAST BY FAKING THEM BY READING THE UFD
;EXPECTS T2/PPN

RDIUFD:	PUSH P,T1
	PUSH P,T3
	PUSH P,T4
	PUSH P,T5
	SETZM CURUFD	;SHOW NO CURRENT UFD
	MOVE T1,NMLSTP
	CAMN T2,PPNS(T1);LOOK FOR UFD ALREADY IN CORE
	JRST RDUFD1	;FOUND IT
	SOJGE T1,.-2
	MOVE T1,NMLSTP
	CAIL T1,NMLSTL
	JRST UFDRET
	ADDI T1,1
	SETZM LDBITS(T1)
	SETZM LDPRV(T1)
	SETZM NAMES1(T1)
	SETZM NAMES2(T1)
	SETZM UFDS(T1)
	MOVEM T2,PPNS(T1)
RDUFD1:	SKIPE T3,UFDS(T1)	;ALREADY SET UP?
	JRST [	MOVEM T3,CURUFD	;YES, ALL DONE
		JRST UFDRET]
	MOVEM T1,SVIND#	;REMEMBER WHICH NMLST ENTRY
	MOVEM T2,LKUFD	;SET UP FOR UFD LOOKUP
	MOVSI T1,'UFD'
	MOVEM T1,LKUFD+1
	SETZM LKUFD+2
	MOVE T1,[XWD 1,1]
	MOVEM T1,LKUFD+3
	INIT LOOK,0
	SIXBIT'DSK'
	0
	 JRST DSKNA
	LOOKUP LOOK,LKUFD
	JRST ENDUFD	;RESET CKPPN AND GET OUT
	PUSHJ P,CHKRM
	MOVE T1,[-200,,UFDBFR]
	MOVEM T1,CTLBUF	;SET FOR UFDUUO
	MOVSI T1,'*  '
	MOVEM T1,CTLBUF+1
	MOVEM T1,CTLBUF+2
	MOVSI T1,060000	;WANT DATE AND STATUS BITS
	MOVEM T1,CTLBUF+3
	SETZM CTLBUF+4
	SETZM CTLBUF+7	;COUNT=0 TO GET STARTED
	PUSHJ P,CHKRM
	MOVE T1,JOBFF
	MOVE T2,SVIND
	CAMLE T2,NMLSTP
	AOS NMLSTP
	MOVEM T1,UFDS(T2)
	MOVEM T1,CURUFD
	MOVEI T2,1(T1)
	HRLI T2,(T1)
	SETZM (T1)
	MOVEI T1,HASH(T1)
	BLT T2,-1(T1)
	HRLI T1,-<406-HASH>/4
NXTUFD:	PUSHJ P,UFDENT	;GET AN ENTRY T2=NAME,T3=DATE
	JRST ZAPUFD	;T4=EXT, SKIP RETURN IF NOT EOF
	JUMPE T2,NXTUFD ;ZERO NAME IS NULL ENTRY
	MOVEM T2,(T1)	;SAVE NAME
	MOVEM T3,2(T1)	;AND DATE
	HRRZM T4,3(T1)	;BITS
	IDIVI T2,HASH	;HASH IT
	MOVM T2,T3	;(TO MAKE IT POSITIVE)
	ADD T2,CURUFD
	HRR T4,(T2)	;LINK IT IN
	MOVEM T4,1(T1)	;AND SAVE EXT AND LINK
	HRRZM T1,(T2)	;SAVE NEW POINTER
	ADDI T1,3	;USED 3 WORDS
	AOBJN T1,NXTUFD ;AND ONE ENTRY, CHECK FOR OVERFLOW
	PUSHJ P,CHKRM
	MOVE T1,JOBFF
	HRLI T1,-<406/4>
	JRST NXTUFD
ZAPUFD:
ENDUFD:	RELEASE LOOK,0
UFDRET:	POP P,T5
	POP P,T4
	POP P,T3
	POP P,T1
	POPJ P,

UFDENT:	SKIPGE T2,CTLBUF+7
	JRST UFDNT2	;THERE SHOULD BE AN ENTRY THERE
UFDNT1:	MOVE T2,[33,,LOOK]
	CHANIO T2,CTLBUF
	 POPJ P,		;EOF
	MOVN T2,CTLBUF+7
	MOVSS T2
	HRRI T2,UFDBFR
	MOVEM T2,CTLBUF+7	;TURN INTO AOBJN
	JUMPG T2,UFDNT1
UFDNT2:	ADD T2,[1,,4]
	MOVEM T2,CTLBUF+7
	MOVE T3,-2(T2)
	HLLZ T4,-3(T2)	;EXTENSION
	HRR T4,-1(T2)	;UFD BITS
	MOVE T2,-4(T2)	;NAME
	AOS (P)
	POPJ P,

ARRAY CTLBUF[10],UFDBFR[200],ALTLOD[5]
;UFDLK DOES A FAST LOOKUP ON THE FILE NAME CONTAINED IN
;LNAM/LEXT/LDAT/LPPN.	IT TRIES TO GET THE LOOKUP DATA FROM THE
;UFD, AND IF THAT FAILS DOES A NORMAL EXTENDED LOOKUP.	IT RETURNS
;THE LOOKUP DATA IN LNAM ETC. AS IF A FOUR-WORD LOOKUP HAD BEEN
;DONE.	THE DATE AND TIME IN LDAT ARE RE-FORMATTED, HOWEVER.	LDAT IS
;SET UP WITH:
;	BITS 0-4:	0
;	BITS 5-17:	CREATION DATE IN DAYS SINCE 1-1-1964 GMT
;	BITS 19-35:	CREATION TIME IN SECONDS SINCE MIDNIGHT GMT
;THIS FORMAT ALLOWS A DIRECT COMPARISON BETWEEN TWO DATE-TIME WORDS
;TO DETERMINE WHICH ONE IS MORE RECENT.

UFDLK:	SKIPN T2,LPPN	;GET SPECIFIED PPN
	MOVE T2,USRPPN	;OR THIS USERS
	PUSHJ P,RDIUFD
	SKIPN CURUFD	;WAS THE UFD READ IN OK?
	JRST UFDLKL	;NO, TRY A NORMAL LOOKUP
	PUSH P,T3	;NEED EXTRA AC
	HLLZS LEXT	;JUST IN CASE IT NEEDS IT
	MOVE T2,LNAM	;GET NAME
	IDIVI T2,HASH	;AND HASH
	MOVM T2,T3
	ADD T2,CURUFD
	HRRZ T2,(T2)
	JUMPE T2,T3POPJ ;NOT IN DIRECTORY
	MOVE T3,LNAM
NMCM:	CAME T3,(T2)	;THIS ONE?
	JRST NXTNM
	HLLZ T3,1(T2)	;GET EXT
	CAME T3,LEXT	;AND CHECK
	JRST NXTRNM	;GET NEXT AND RESTORE NAME
	MOVE T3,3(T2)
	MOVEM T3,CURBTS#	;CURRENT BITS
	MOVE T3,2(T2)
	MOVEM T3,LDAT
	AOS -1(P)	;SKIP RETURN
T3POPJ:	POP P,T3
	POPJ P,

NXTRNM:	MOVE T3,LNAM	;THIS GOT WIPED OUT
NXTNM:	HRRZ T2,1(T2)	;LINK
	JUMPE T2,T3POPJ ;GIVE UP AND GO HOME
	JRST NMCM	;GO LOOK SOME MORE

UFDLKL:	INIT LOOK,0		;SET UP CHANNEL FOR LOOKUP
	SIXBIT'DSK'
	0
	 JRST DSKNA
	MOVEI T2,14	;SET UP EXTENDED LOOKUP BLOCK
	MOVEM T2,EXTLK
	MOVE T2,LPPN		;MOVE STUFF FROM 4-WORD BLOCK TO EXTENDED BLOCK
	MOVEM T2,EXTLK+1
	MOVE T2,LNAM		;AN EXTENDED LOOKUP IS USED HERE BECAUSE
	MOVEM T2,EXTLK+2	;PART OF THE CREATION TIME IS NOT
	MOVE T2,LEXT		;AVAILABLE IN THE NORMAL 4-WORD LOOKUP.
	MOVEM T2,EXTLK+3
	LOOKUP LOOK,EXTLK	;OK, DO THE LOOKUP
	JRST [	RELEAS LOOK,	;NOT FOUND, FORGET IT
		POPJ P,	]
	RELEAS LOOK,		;FOUND IT, GET RID OF THE CHANNEL
	LDB T2,[POINT 6,EXTLK+14,17]	;SECONDS PART OF CREATION TIME
	MOVEM T2,LDAT
	LDB T2,[POINT 11,EXTLK+4,23]	;REST OF CREATION TIME
	IMULI T2,^D60
	ADDM T2,LDAT
	LDB T2,[POINT 12,EXTLK+4,35]	;MOST OF CREATION DATE
	DPB T2,[POINT 12,LDAT,17]
	LDB T2,[POINT 2,EXTLK+3,21]	;TWO MORE BITS OF CREATION DATE
	DPB T2,[POINT 2,LDAT,5]
	JRST CPOPJ1		;SKIP RETURN

ARRAY LKUFD[4],EXTLK[15]
INTEGER CURUFD

OUTASC:	HRLI T2,(POINT 7,)
OUASC1:	ILDB T1,T2
	JUMPE T1,CPOPJ
	PUSHJ P,(T3)
	JRST OUASC1

OUTSIX:	MOVEI T1,0
	LSHC T1,6
	ADDI T1,40
	PUSHJ P,(T3)
	JUMPN T2,OUTSIX
CPOPJ:	POPJ P,

OUTSW:	MOVEM T2,SVSWP	;SAVE THE POINTER
	ILDB T1,T2	;PICK UP THE FIRST CHR
	JUMPE T1,CPOPJ	;AND CHECK FOR NULL AS A PRECAUTION
	MOVEI T1,"("
	PUSHJ P,(T3)	;SWITCHES ARE IN () TO PROCESSOR
OUTSW1:	ILDB T1,SVSWP
	JUMPE T1,[MOVEI T1,")"
	JRST	(T3)]
	PUSHJ P,(T3)
	JRST OUTSW1	;A NULL WILL MARK THE END

OUTDV:	PUSHJ P,OUTSIX	;DEVICE IS IN T2
	MOVEI T1,":"
	JRST (T3)
ENTCNM:	MOVE T1,CORTOP	;CHECK TO SEE IF NAME ALREADY THERE
ENTC1:	CAMN T1,CORT1
	JRST ENTC2
	CAMN T2,1(T1)
	POPJ P, ;NAME THERE, EXIT
	AOJA T1,ENTC1	;CHECK ANOTHERE
ENTC2:	MOVEM T2,@CORTOP	;SAVE IT
	AOS (P)	 ;SKIP RETURN IF ENTERED
	SOS T1,CORTOP
	CAMG T1,SVJFF	;CHECK TO SEE IF CORE EXCEEDED
	JRST XPAND
	POPJ P,

ENTCRF:	MOVE T2,ONAM
	PUSHJ P,ENTCNM	;SEE IF NAME ALREADY THERE
	POPJ P, ;YES, DONE
	MOVEI T1,"_"
	PUSHJ P,OUTCRF
	MOVEI T3,OUTCRF
	MOVE T2,ONAM
	PUSHJ P,OUTSIX
	MOVSI T2,(SIXBIT !/L!)	;NO PUT OUT /L FOR A LIST FILE
	TRNN FLT,CRSW	;IS THIS REALLY CREF??
	PUSHJ P,OUTSIX
	MOVE T4,[XWD -CSBL,CSBT]	;PUT OUT EXTRA SWS
	PUSHJ P,SWBITS
	TLNN FL,(T2)
	JRST OUCRLF

FINCRF:	MOVSI IOPNT,-2	;PERMIT ONLY THIS ONE LEVEL
	TRO FL,INCRF	;SAY WE ARE FINISHING
	MOVEM P,SVPDL	;SAVE THE PDL FOR LATER
	MOVE T1,[POINT 7,CRFRDR]
	MOVEM T1,DINPT
	MOVEI T3,OUTCRF
FINC1:	PUSHJ P,SCAN	;GET SOMETHING
	TRNN FL,IDF	;IGNORE ALL BUT IDENTIFIERS
	JRST FINC1
	MOVEI SVPT,0	;SET UP IN CASE IT IS SOMETHING ELSE
	PUSHJ P,GETNAM	;GET A NAME
	MOVE T2,SVNAM	;GET IT
	PUSHJ P,ENTCNM	;AND SEE IF IT DUPLICATES
	JRST FINC2A	;WAIT FOR TERM
	MOVEI T1,"_"
	PUSHJ P,OUTCRF
	SKIPN T2,SVDEV	;IF A DEVICE IS THERE (WHEN LSTDEV IS IN)
	JRST NOCRDV
	PUSHJ P,OUTSIX
	MOVEI T1,":"
	PUSHJ P,OUTCRF
NOCRDV:	MOVE T2,SVNAM
	PUSHJ P,OUTSIX
	SKIPA	;C IS ALREADY LOADED FROM SCAN
FINC4:	PUSHJ P,GETCH
	TLNE CS,TERMF	;IS IT ERMINATORE?
	JRST FINC5	;TRY NEXT
	MOVE T1,C
	PUSHJ P,OUTCRF
	JRST FINC4

FINC2:	PUSHJ P,SCAN
FINC2A:	TLNN CS,TERMF
	JRST FINC2
	JRST FINC1
DNCRF:
	PUSHJ P,CHKCRF	;CLOSE FILE
	MOVE P,SVPDL	;GET THE ENTERING PDL BACK
	TRZ FL,INCRF	;NO LONGER THERE
	POPJ P,

FINC5:	PUSHJ P,OUCRLF
	JRST FINC1	;FINISH UP LINE

CSBT:	SBTS K,CNSBT
	SBTS M,CNMBT
	SBTS O,COPBT
	SBTS S,CNLBT
	SBTS C,CCMBT
	SBTS Q,CMONBT
CSBL==.-CSBT
;HANDLE THE DIFFERENCES COMMAND - DO GOOD STUFF AND CALL FILCOM

DIFFER:	MOVEI T1,FCMEOF		; LABEL FOR SPECIAL EXIT ROUTINE
	MOVEM T1,EOFLAB		; (EXIT LABEL REFERENCED IN RELTAB)
DIFFIT:	MOVEI T4,[ASCIZ/OUTPUT TO: /]
	PUSHJ P,PROMPT
	TRNE FL,PRMPTF	;IF PROMPTING
	JRST	[PUSHJ P,DIFINM	;READ NAME
		TLNE CS,TERMF
		JRST DIFOKO
		JRST SYNERR]	;OTHERWISE NEED _ OR = FOR OUTPUT
	PUSHJ P,DIFINM	;GET FIRST NAME - MIGHT BE INPUT OR OUTPUT
	CAIN C,","
	JRST DIFOKA	;COMMA SAYS IT WAS INPUT NAME
	CAIE C,"_"
	CAIN C,"="
	JRST DIFOKO	;CHECK FOR VALID OUTPUT NAME TERMINATORS
	JRST SYNERR
DIFOKO:	PUSHJ P,CKTTY	;ALLOW TEL FOR TTY: IN OUTPUT NAME
	PUSHJ P,DIFONM	;SEND OUTPUT NAME TO FILCOM
	MOVEI T4,[ASCIZ/INPUT FILE 1: /]
	PUSHJ P,PROMPT
	TRZN FL,PRMPTF
	PUSHJ P,SCAN
	PUSHJ P,DIFINM	;GET INPUT FILE 1
DIFOKA:	MOVEI T1,"_"
	PUSHJ P,OUTFCM	;DELIMIT OUTPUT NAME
	PUSHJ P,DIFONM	;SEND FILE NAME TO FILCOM
	MOVEI T1,","
	PUSHJ P,OUTFCM
	CAIE C,","
	TLNE CS,TERMF	;CHECK FOR VALID DELIMITERS
	SKIPA T4,[[ASCIZ/INPUT FILE 2: /]]
	JRST SYNERR
	PUSHJ P,PROMPT
	TRZN FL,PRMPTF
	PUSHJ P,SCAN
	PUSHJ P,DIFINM	;GET SECOND INPUT NAME
	PUSHJ P,DIFONM
	PUSHJ P,SCAN
	TLNN CS,TERMF
	JRST SYNERR
	MOVEI T3,OUTFCM
	PUSHJ P,OUCRLF
	JRST DIFFIT		; READ NEXT LINE (IN COMMAND FILE)


FCMEOF:	PUSHJ P,CHKFCM
	MOVE T1,[SIXBIT/FILCOM/]
	MOVEM T1,PCNAM
	JRST DONE1

DIFINM:	PUSHJ P,SCAN
	CAIN C,"/"	;CHECK FOR SWITCH BEFORE NAME
	PUSHJ P,DIFSW1	;YES, PROCESS IT
	PUSHJ P,GETNAM	;GET FILE NAME
	PUSHJ P,SCANS	;PEEK AT NEXT CHARACTER
	CAIN C,"/"	;CHECK FOR SWITCH AFTER NAME
	PUSHJ P,DIFSW	;YES, PROCESS IT
	POPJ P,

DIFSW:	PUSHJ P,SCAN	;THIS ENTRY SKIPS OVER THE /
DIFSW1:	HRREI T1,-3	;THIS ENTRY ASSUMES / HAS BEEN SCANNED
	ADDM T1,(P)	;RETURN TO CALLING LOC-2
	PUSHJ P,SCAN	;SCAN SWITCH NAME
	TRNN FL,IDF
	JRST SYNERR
	MOVSI T1,'RUN'
	CAMN T1,ACCUM
	JRST SETRNN	;HANDLE RUN SWITCH SPECIALLY TO AVOID GARBAGE
	MOVEI T1,"/"
	PUSHJ P,OUTFCM	;BEGINNING OF SWITCH FOR FILCOM
	MOVE T1,[-DIFLEN,,DIFTAB]
	PUSHJ P,SWSCAN
	JRST UNRECS
	JFCL
	XCT DIFT2-DIFTAB(T1)	;DO THE SWITCH
	PUSHJ	P,OUTFCM	; SEND SWITCH CHARACTER TO BUF
	MOVE	T3,[SIXBIT /HELP/]
	CAME	T3,ACCUM	; DID WE SCAN THE /HELP SWITCH?
	POPJ	P,		; RETURN
	SKIPE	SVNAM	;ANY NAMES SEEN YET?
	POPJ	P,		;YUP, BETTER GO BACK & WRITE THEM
	PUSHJ	P,SCANS		; ANYTHING ELSE IN THE STRING?
	TLNN	CS,TERMF	; A TERMINATOR?
	POPJ	P,		; NO THERE'S MORE (RETURN)
	PUSHJ	P,SCAN	; NO? WELL, GET TERMINATOR ANYWAY
	POP	P,T3		; RE-ADJUST THE STACK
	JRST	DIFFIT		;AND GO BACK TO THE BEGINNING

DIFONM:	MOVEI T3,OUTFCM
	MOVE T4,SVPT
	JRST CMNO

DIFLOW:	SKIPA T1,["L"]
DIFUP:	MOVEI T1,"U"
	PUSH P,T1
	PUSHJ P,STARGS
	TRNN FL,NUMFS	;ARGUMENT MUST BE NUMERIC
	JRST SYNERR
	MOVE T1,NUMAC
	MOVEI T3,OUTFCM
	PUSHJ P,OUTNUM	;SEND NUMBER TO FILCOM
	TLNN FL,PARFLG
	JRST DIFLU1	;IF NOT (ARG) THEN ALMOST DONE
	PUSHJ P,SCAN	;IF (ARG) THEN SCAN )
	CAIE C,")"
	JRST SYNERR	;MUST BE )
DIFLU1:	POP P,T1	;GET BACK SWITCH CHARACTER
	POPJ P,	;RETURN

DEFINE TABLE<
SWITCH ASCII,<MOVEI T1,"A">
SWITCH BINARY,<MOVEI T1,"W">
SWITCH BLANK,<MOVEI T1,"B">
SWITCH COMMENT,<MOVEI T1,"C">
SWITCH COREIMAGE,<MOVEI T1,"X">
SWITCH CASE,<MOVEI T1,"K">
SWITCH HELP,<MOVEI T1,"H">
SWITCH QUICK,<MOVEI T1,"Q">
SWITCH SPACING,<MOVEI T1,"S">
SWITCH SYMBOLIC,<MOVEI T1,"A">
SWITCH WORD,<MOVEI T1,"W">
SWITCH UPDATE,<MOVEI T1,"U">
SWITCH EXPAND,<MOVEI T1,"X">
SWITCH SMALL,<MOVEI T1,"N">
SWITCH LOWER,<PUSHJ P,DIFLOW>
SWITCH UPPER,<PUSHJ P,DIFUP>
>

TBGEN(DIFTAB,DIFLEN,DIFT2)
;HANDLE DIRECTORY-TYPE COMMANDS. ALL ARE ABOUT THE SAME EXCEPT FOR FLAGS


DODIR:	 TLO	FL2,SFLGD!CFLGD ;SET NORMAL DIR. BITS
	TLNE	FL,TYMX
	TLO	FL2,DFLGD!PFLGD!AFLGD
	JRST	DOFL+1
DODEL:	TLO FL,DELTSW	;JUST SET DELETE SWITCH
DOFL:	TLZ FL2,-1	;NO FLAGS
	TRO FL,PIPF
	MOVEI	T1,DIREOF	;LOC OF EXIT ROUTINE CALL
	MOVEM	T1,EOFLAB	;EXIT LABEL REFERENCED BY RELTAB
DODIR1:	PUSHJ P,SCAN	;FIND OUT IF HE WANTS /L OR /F SWITCH
DODIR2:	TRNN FL,IDF	;WAS IT AN IDENT?
	CAIN C,"["
	JRST DIRNAM
	CAIN	C,"("
	JRST	DIRNAM
	CAIN C,"-"
	JRST MINAM
	CAIE C,"_"
	CAIN C,"="
	JRST DODIR1
	CAIE C,","
	CAIN C," "
	JRST DODIR1
	CAIE C,"#"
	CAIN C,")"
	JRST SYNERR	;JRST DODIR1 ALLOWS #,) AS SEPARATORS
	CAIE C,"]"
	SKIPN C		; WHERE SCAN PRODUCED AN IDF IN DISGUISE
	JRST DODIR1
	CAIE C,"/"
	JRST SYNERR
	PUSHJ P,SCAN	;WHICH ONE
	TRNN FL,IDF	;MUST SEEN AN IDENTIFIER
	JRST SYNERR
	MOVEI T1,"_"
	TLON FL,NEDCMA
	PUSHJ P,OUTDIR
	MOVE T1,[XWD -DIRLG,DIRTAB]
	PUSHJ P,SWSCAN
	JRST	SWHELP
	JFCL
	XCT DIRT2-DIRTAB(T1)
	JRST DODIR1
DIRNAM:	PUSHJ P,GETNAM
	SKIPN SVDEV(SVPT)
	SKIPE SVEXT(SVPT)
	JRST CMNM	;NO FUNNY STUFF IF DEV OR EXT GIVEN
	MOVSI T1,'NOT'
	CAMN T1,SVNAM(SVPT)
	JRST MINAM	;NOT IS THE SAME AS -
CMNM:	CAIE C,"="
	CAIN C,"_"	;NAME= OR NAME_ IS OUTPUT SPEC
	JRST [	TLNE FL,NEDCMA
		JRST SYNERR	;MUST NOT HAVE HAD ANY PREVIOUS NAMES
		MOVSI T1,'DSK'
		SKIPN SVDEV(SVPT)	;DIRIT DOESN'T HAVE DSK DEFAULT
		MOVEM T1,SVDEV(SVPT)
		JRST CMNM1]
	MOVEI T1,"_"	;JUST A REGULAR NAME, PRECEDE IT WITH
	TLOE FL,NEDCMA	;THE PROPER DELIMITER (_ IF FIRST,
	MOVEI T1,","	;ELSE COMMA)
	PUSHJ P,OUTDIR	;COMMA IF NOT FIRST
CMNM1:	MOVE T4,SVPT
	MOVEI T3,OUTDIR
	PUSHJ P,CMNO	;OUTPUT NAME TO DIRIT
	JRST DODIR1
MINAM:	PUSHJ P,GETNMS	;SKIP - AND SCAN NAME
	MOVSI T2,'_- '	;ARROW IF FIRST
	TLOE FL,NEDCMA
	MOVSI T2,',- '	;COMMA IF NOT FIRST
	MOVEI T3,OUTDIR
	PUSHJ P,OUTSIX	;OUTPUT COMMA (OR ARROW) AND -
	JRST CMNM1
DIREOF:	MOVEI T1,"_"
	TLNN FL,NEDCMA
	PUSHJ P,OUTDIR	;_ IF NO FILE SPECIFICATIONS YET
	PUSHJ	P,OUTSWD	; WRITE SWITCHES AND CRLF
DIROUT:	SKIPE PERFLG	; WERE WE CALLED BY PERFORM?
	PUSHJ	P,PERFOO	;YES, INDEED
	PUSHJ P,CHKDIR
	MOVE T1,[SIXBIT /DIRIT/]
	MOVEM T1,PCNAM
	JRST DONE1

OUTSWD:	MOVEI T3,OUTDIR
	MOVE T4,[XWD -DSBTL,DSBT]
	PUSHJ P,SWBITS
	TLNN FL2,(T2)
	MOVE T4,[XWD -D2SBTL,D2SBT]	;RAN OUT OF BITS IN 1 WORD
	PUSHJ P,SWBITS
	TLNN FL,(T2)	;SO USE ANOTHER
	PUSHJ	P,OUCRLF	; OUTPUT A CRLF
	POPJ	P,	; RETURN TO CALLING ROUTINE

SWHELP:	OUTSTR	SWHLPM
	JRST	EX
SWHLPM:	ASCIZ $
SORT SWITCHES ARE:
    /ALPHABETICAL, /REVERSE, /STORAGE, /EXTENSION
ITEM SWITCHES ARE:
    /ACCESS, /AUTHOR, /CREATION, /LICENSE, /PID, /PROJECT
    /PROTECTION, /SECONDS, /SIZE, /STATUS, /TIME, /UFDBITS, /WORDS
DELETE SWITCHES ARE:
    /ANY, /BAD, /SOFT
OTHER SWITCHES:
    /AFTER, /BEFORE, /EVERYTHING, /FAST, /NOPRINT, /UNSORTED
    /TEMPS (OR /K), /TODAY, /TOTAL, /YESTERDAY
$
;SWITCH VALUES

EFLGD==1
RFLGD==2
TFLGD==4
SFLGD==10
CFLGD==20
DFLGD==40
JFLGD==100
NFLGD==200
BFLGD==400
PFLGD==1000
AFLGD==2000
MFLGD==4000
KFLGD==10000
VFLGD==20000
UFLGD==40000
HFLGD==100000
GFLGD==200000

;NOW BITS IN LH OF FL


PRMSW==1	;WANTS PROMPT ON DELETE, ENABLE /Q TO DIRIT
DELTSW==2	;THIS IS A DELETE
RENTSW==4	;THIS IS A RENAME
NEDCMA==10	;NEED TO OUTPUT COMMA BEFORE NAME
YFLGD==20
ZFLGD==40
SOONR==100	;1=/BEFORE	0=/AFTER
IFLGD==200
WFLGD==400	;PROJ CODE ENABLE /W TO DIRIT. AAA.
OFLGD==1000	; AUTHOR /AUTHOR TO RPG; /O TO DIRIT (OH - NOT ZERO)
FLGD1==2000	;PID REPORTING: /PID TO RPG, /1 TO DIRIT
FLGD2==4000	;BAD RIB FILE DEL: /BAD TO RPG, /2 TO DIRIT
FLGD3==10000	;DEL BY REN TO TMP FILE: /SOFT TO REP, /3 TO DIRIT

DEFINE TABLE <
SWITCH PROJECT,<TLO FL,WFLGD>
SWITCH LPT,<TLO FL,IFLGD>
SWITCH EXTENSION,<TLO FL2,EFLGD>
SWITCH REVERSE,<TLO FL2,RFLGD>
SWITCH ALPHABETIC,<TLO FL2,TFLGD>
SWITCH SIZE,<TLO FL2,SFLGD>
SWITCH CREATION,<TLO FL2,CFLGD>
SWITCH TIME,<TLO FL2,DFLGD>
SWITCH SECONDS,<TLO FL2,JFLGD>
SWITCH TOTAL,<TLO FL2,NFLGD>
SWITCH LICENSE,<TLO FL2,BFLGD>
SWITCH PROTECTION,<TLO FL2,PFLGD>
SWITCH ACCESS,<TLO FL2,AFLGD>
SWITCH MODE,<TLO FL2,MFLGD>
SWITCH TEMPS,<TLO FL2,KFLGD>
SWITCH K,<TLO FL2,KFLGD>
SWITCH FAST,<TLZ FL2,SFLGD!CFLGD!PFLGD!AFLGD>
SWITCH EVERYTHING,<PUSHJ P,EVRYTH>
SWITCH UNSORTED,<TLO FL2,UFLGD>
SWITCH STORAGE,<TLO FL2,HFLGD>
SWITCH UFDBITS,<TLO FL2,GFLGD>
SWITCH NOPRINT,<TLO FL2,VFLGD>
SWITCH WORDS,<TLO FL,YFLGD>
SWITCH STATUS,<TLO FL,ZFLGD>
SWITCH BEFORE,<JRST SOONER>
SWITCH AFTER,<JRST LATER>
SWITCH TODAY,<JRST TODAY>
SWITCH YESTERDAY,<JRST YESTER>
SWITCH AUTHOR,<TLO FL,OFLGD>
SWITCH PID,<TLO FL,FLGD1>
SWITCH BAD,<PUSHJ P,SETBAD>
SWITCH ANY,<PUSHJ P,SETANY>
SWITCH SOFT,<PUSHJ P,SETSOF>
SWITCH WAIT,<TLO FL,PRMSW>
SWITCH RUN,<PUSHJ P,SETRNN>
>
TBGEN (DIRTAB,DIRLG,DIRT2)
DSBT:	SBTS E,EFLGD
	SBTS R,RFLGD
	SBTS T,TFLGD
	SBTS S,SFLGD
	SBTS C,CFLGD
	SBTS D,DFLGD
	SBTS J,JFLGD
	SBTS N,NFLGD
	SBTS B,BFLGD
	SBTS P,PFLGD
	SBTS A,AFLGD
	SBTS M,MFLGD
	SBTS K,KFLGD
	SBTS V,VFLGD
	SBTS U,UFLGD
	SBTS H,HFLGD
	SBTS G,GFLGD
DSBTL==.-DSBT

D2SBT:	SBTS X,DELTSW
	SBTS Q,PRMSW
	SBTS L,RENTSW
	SBTS Y,YFLGD
	SBTS Z,ZFLGD
	SBTS I,IFLGD
	SBTS W,WFLGD
	SBTS O,OFLGD
	SBTS 1,FLGD1
	SBTS 2,FLGD2
	SBTS 3,FLGD3
D2SBTL==.-D2SBT

EVRYTH:	TLO FL2,SFLGD!JFLGD!PFLGD!AFLGD!MFLGD!BFLGD!GFLGD
	TLO FL,YFLGD!ZFLGD!WFLGD!OFLGD
	POPJ P,

SETANY:	TLNN	FL,DELTSW
	JRST	SWHELP		;MUST BE A DEL FOR /ANY TO BE LEGAL
SETAN1:	TLO	FL,FLGD2
	POPJ	P,

SETBAD: TLZN	FL,DELTSW
	JRST	SWHELP		;MUST BE A DEL FOR /BAD TO BE LEGAL
	JRST	SETAN1

SETSOF:	TLNN	FL,DELTSW
	JRST	SWHELP		;MUST BE A DEL FOR /SOFT TO BE LEGAL
	TLO	FL,FLGD3
	POPJ	P,

SOONER:	TLOA FL,SOONR
LATER:	TLZ FL,SOONR
	MOVEI T1,"/"
	PUSHJ P,OUTDIR
	SETZM DIRDAT#
	DATE	T1,
	IDIVI T1,^D31
	MOVEM T2,DRDAY#
	IDIVI T1,^D12
	MOVEM T2,DRMON#
	MOVEM T1,DRYR#
	PUSHJ P,SCAN
	CAIN C,"."
	JRST CRDAGT
	TRNN FL,NUMFS
	JRST SYNERR
	SOS T1,NUMAC
	MOVEM T1,DRDAY
	PUSHJ P,SCAN
	CAIE C,"-"
	JRST CRDAGT
	PUSHJ P,SCAN
	TRNN FL,IDF	;MUST BE IDENT OR NUMBER
	JRST SYNERR
	TRNN FL,NUMFS
	JRST RMON	;FIND OUT WHICH MONTH (TYPE IN NAME)
	SOS T1,NUMAC
	MOVEM T1,DRMON
RDYRD:	PUSHJ P,SCAN
	CAIE C,"-"
	JRST CRDAGT
	PUSHJ P,SCAN
	TRNN FL,NUMFS
	JRST SYNERR
	MOVE T1,NUMAC
	SUBI T1,^D64
	MOVEM T1,DRYR
	PUSHJ P,SCAN
CRDAGT:	MOVE T1,DRYR
	IMULI T1,^D12
	ADD T1,DRMON
	IMULI T1,^D31
	ADD T1,DRDAY
	MOVEM T1,DIRDAT
	MOVEI T4,DODIR2
	CAIE C,"."
	JRST DODT2
	PUSHJ P,SCAN
	TRNN FL,NUMFS
	JRST SYNERR
	MOVE T1,NUMAC
	IDIVI T1,^D100
	IMULI T1,^D60
	ADD T1,T2
	IMULI T1,^D60
	DPB T1,[POINT 17,DIRDAT,21]
DODT1:	MOVEI T4,DODIR1
DODT2:	MOVE T1,DIRDAT
	MOVEI T3,OUTDIR
	PUSHJ P,OUTNUM	;OUTPUT DATE
	MOVEI T1,"<"
	TLNN FL,SOONR
	MOVEI T1,">"
	PUSHJ P,OUTDIR	;OUTPUT APPROPRIATE SWITCH
	JRST (T4)

YSMNDY:	EXP ^D31,^D28,^D31,^D30,^D31,^D30,^D31,^D31,^D30,^D31,^D30,^D31
YESTER:	TLZ FL,SOONR
	MOVEI T1,"/"
	PUSHJ P,OUTDIR
	DATE T1,
	PUSH P,T2		; Save some registers
	PUSH P,T3
	IDIVI T1,^D31		; day into t2
	MOVE T3,T2		;   ... into t3
	IDIVI T1,^D12		; month into t2, year in t1
	SOJ T3,			; decrement day
	JUMPGE T3,YESTED	; not the first, continue.
	SOJ T2,			; must be first (-1) so last month.
	JUMPGE T2,YESTEM	; not january, continue.
	SOJ T1,			; must be january do year
	MOVEI T2,^D12-1		; yesterday was in december
YESTEM:	ADD T3,YSMNDY(T2)	; add in MoNth DaYs for this month.
	TRNE T1,3		; skip if this is a leap year (till 2099)
	 JRST YESTED		; non-leap so ignore february
	CAIN T2,1		; february?
	 AOJ T3,		;  yes!
YESTED:	IMULI T1,^D12		; make years into months
	ADD T1,T2		; add months
	IMULI T1,^D31		; make months into days
	ADD T1,T3		; add days
	POP P,T3		; restore registers
	POP P,T2
	MOVEM T1,DIRDAT		; store date
	JRST DODT1		; finish up

TODAY:	TLZ FL,SOONR
	MOVEI T1,"/"
	PUSHJ P,OUTDIR
	DATE	T1,
	MOVEM T1,DIRDAT
	JRST DODT1


RMON:	MOVE T1,[XWD -MONLG,MONTAB]
	PUSHJ P,SWSCAN
	JRST SYNERR
	JFCL
	SUBI T1,MONTAB	;CONVERT TO NUMBER
	HRRZM T1,DRMON	;PUT IT IN
	JRST RDYRD	;DONE

DEFINE IR (A)
<IRP A <<SIXBIT /A/>>>
MONTAB:	IR <JANUARY,FEBRUARY,MARCH,APRIL,MAY,JUNE,JULY,AUGUST>
	IR <SEPTEMBER,OCTOBER,NOVEMBER,DECEMBER>
MONLG==.-MONTAB
;RENAME COMMAND - BOTH PDP10 AND TYMEX

DOREN:	MOVEI	T4,DIROUT	; SPECIAL RENAME EXIT ROUTINE
	MOVEM	T4,EOFLAB	; MOVE LABEL TO EXIT LOCATION
DORENM:	TRO FL,PIPF	;PERMIT * IN FILES
	MOVEI T4,[ASCIZ/OLD NAME: /]
	PUSHJ P,PROMPT	;PROMPT USER (MAYBE)
	PUSH P,FL	;SAVE FL BECAUSE GETNAM ZAPS NEEDED FLAG
	PUSHJ P,GETNMS	;SCAN FIRST FILE NAME
	CAIE C,"="	;HOW DID IT TERMINATE?
	CAIN C,"_"
	JRST PDPREN	; = OR _ MEANS PDP10-STYLE
	CAIE C,"<"	;AS DOES <
	JRST TYMREN	;ANYTHING ELSE IS TYMEX-STYLE
PDPREN:	POP P,T1	;GET BACK FLAG
	TRNE T1,PRMPTF
	JRST SYNERR	;BUT PDP10-STYLE CAN'T BE PROMPTED
	MOVE T1,USRPPN
	SKIPN SVPPN
	MOVEM T1,SVPPN	;USER'S PPN IF NONE GIVEN (BECAUSE OF DIRIT BUG)
	SKIPE SVNAM	;NO NAME, NO SCAN
	PUSHJ P,SCAN
	MOVEI T3,OUTDIR
	MOVE T4,SVPT
	PUSHJ P,CMNO	;OUTPUT NAME
	CAIE C,"<"	;IS THERE PROTECTION?
	JRST NORPRT
	PUSHJ P,SCAN
	TRNN FL,NUMFS
	PUSHJ P,TRYIDP	;TRY FOR NAMES ON PROTECTION
	MOVEI T1,"<"
	PUSHJ P,OUTDIR
	MOVE T2,NUMAC	;GET NUMBER
	PUSHJ P,DECOCT	;CONVET IT
	MOVEI T3,OUTDIR ;DESTROYED BY DECOCT
	PUSHJ P,OUTNUM
	MOVEI T1,">"
	PUSHJ P,OUTDIR
	PUSHJ P,SCAN
	CAIE C,">"
	JRST SYNERR
	PUSHJ P,SCAN
NORPRT:	TLO FL,RENTSW	;SET THE BIT
	CAIE C,"="
	CAIN C,"_"
	JRST DOFL
	JRST SYNERR

TYMREN:	AOBJP	SVPT,TMNER	;SAVE OLD NAME
	TLNN	CS,TERMF	;CARRIAGE RETURN
	CAIN	C,","		;OR COMMA
	JRST	TYMRNP		;IS OK
	JUMPN	C,SYNERR	;OR ELSE IT BETTER BE A SPACE
	PUSHJ	P,SCAN
	MOVSI	T1,'AS '	;FIRST NAME WAS FOLLOWED BY SPACE, NEXT
	CAME	T1,ACCUM	;WORD HAD BETTER BE "AS"
	JRST	SYNERR
	PUSHJ	P,SCANS
	CAIE	C,"("		;AND THAT HAD BETTER BE FOLLOWED BY AN
	JUMPN	C,SYNERR	;OPEN PAREN OR ANOTHER SPACE
	JRST TYMRNG		;FAR OUT! WE CAN SKIP THE PROMPTING
TYMRNP:	MOVEI	T4,[ASCIZ /NEW NAME: /]
	PUSHJ	P,PROMPT	;CK IF END OF STRING AND PROMPT REQ.
	TRZN	FL,PRMPTF	;TEST FLAG AND SKIP OVER SEP. IF SET
	PUSHJ	P,SCAN		;SKIP OVER SEPARATOR
TYMRNG:	PUSHJ	P,GETNMS	;GET NEW NAME
	MOVE T1,USRPPN
	SKIPN	SVPPN(SVPT)	;USE USER'S PPN IF NONE GIVEN
	MOVEM	T1,SVPPN(SVPT)	;TO GET AROUND DIRIT PROBLEM
	MOVEI	T3,OUTDIR
	MOVE	T4,SVPT
	PUSHJ	P,CMNO		;OUTPUT NEW NAME
	MOVEI	T1,"_"
	PUSHJ	P,OUTDIR
	MOVEI	T4,0
	PUSHJ	P,CMNO		;OUTPUT OLD NAME
	TLO	FL,RENTSW	;SET RENAME SW
RENM:	PUSHJ	P,SCAN		;LOOK FOR POSSIBLE SWITCHES
	TRNN	FL,IDF
	CAIE	C,"/"
	JRST	[TLNN	CS,TERMF	;A CRLF?
		JRST 	SYNERR	;NOPE, HE LOSES
		PUSHJ P,OUTSWD	;YES, WRITE OUT COMMAND
		MOVSI	SVPT,-NFILE ;RESET SVPT
		JRST 	DORENM]	; GO BACK AND CONTINUE READING
	PUSHJ	P,SCAN
	TRNN	FL,IDF
	JRST	SYNERR
	MOVE	T1,[XWD -DIRLG,DIRTAB]
	PUSHJ	P,SWSCAN
	JRST	SWHELP
	JFCL
	XCT	DIRT2-DIRTAB(T1)
	JRST	RENM

DECOCT:	MOVEI T1,0
	JUMPGE T2,DECO1
	HRRZ T1,T2
	POPJ P,	 ;NEG FLAG IS SET BY TRYIDP
DECO1:	IDIVI T2,^D10
	HRLM T3,(P)
	SKIPE T2
	PUSHJ P,DECO1
	HLRZ T3,(P)
	LSH T1,3
	ADDI T1,(T3)
	POPJ P,

TRYIDP:	MOVEI T5,3	;NUMBER OF PROTECTION FIELDS
	TDZA T4,T4	;ACCUMULATE PROTECTION
IDP1:	PUSHJ P,SCAN
	TRNN FL,IDF
	JRST SYNERR	;MUST BE A NAME
	MOVE T1,[XWD -10,PROTAB]	;ONLY A FEW POSSIBLE
	PUSHJ P,SWSCAN
	JRST SYNERR	;NOT A GOOD ONE
	JFCL
	SUBI T1,PROTAB	;CONVER TO	PROTECTION
	LSH T4,3
	IORI T4,(T1)	;PUT IT IN
	SOJG T5,IDP1	;IF MORE, TRY AGAIN
	HRROM T4,NUMAC	;SAVE FOR COMPRT
	MOVEI T3,OUTDIR ;THIS GOT LOST
	POPJ P,

PROTAB:	SIXBIT /ALL/
	SIXBIT /CP/
	SIXBIT /UPD/
	SIXBIT /AP/
	SIXBIT /RD/
	SIXBIT /RUN/
	SIXBIT /LK/
	SIXBIT /NO/
COPY:	MOVEI	T4,CPYEOF	; SPECIAL "COPY" EXIT ROUTINE
	MOVEM	T4,EOFLAB		;MOVE LABEL TO EXIT LOCATION
COPY2:	TRO	FL,PIPF	 ;SET PIP FLAG
	MOVEI	T4,[ASCIZ /FROM FILE: /]
	PUSHJ	P,PROMPT	;TYPE PROMPTING MSG IF REQ.
	PUSHJ	P,GNM	;GET OLD FILE NAME
	AOBJP	SVPT,TMNER
DOC2:	MOVEI	T4,[ASCIZ /TO: /]
	PUSHJ	P,PROMPT	;TYPE PROMPTING MSG IF REQ.
	TRZN	FL,PRMPTF	;AVOID SSCAN IF MSG. TYPED
	PUSHJ	P,SCAN		;IGNORE SEPARATOR
	CAIN	C,"+"
	JRST	[PUSHJ	P,GNM
		MOVE	T1,SVPPN-1(SVPT)
		SKIPN	SVPPN(SVPT)	;DEFAULT PPN FOR + IS
		MOVEM	T1,SVPPN(SVPT)	;WHATEVER PREVIOUS FILE HAD
		AOBJP	SVPT,TMNER
IFN PIP33,<
		SETOM	CONCAT#	;A FLAG TO SHOW CONCATENATION
>
	JRST	DOC2]
	PUSHJ	P,GNM	;GET NEW NAME
	TLNN CS,TERMF
	JRST SYNERR	;MUST HAVE TERMINATOR HERE
	MOVEI T3,OUTPIP
	MOVE T4,SVPT
IFN PIP33,<
	PUSHJ	P,WILDCH	;CONVERT "WILD" CHARACTERS
	PUSHJ P,CMNO	;OUTPUT NAME OF OUTPUT FILE
	MOVSI T2,'/X_'	;/X TO OUTPUT BUFFER
	MOVSI	T1,'TTY'	;UNLESS THE INPUT DEVICE
	CAME	T1,SVDEV-1(SVPT)	;IS A TTY: , OR HE'S
	SKIPE	CONCAT		;CONCATENATING, IN WHICH CASE
	MOVSI	T2,'_  '	;NO /X TO OUTPUT BUFFER
	PUSHJ P,OUTSIX	;OUTPUT /X_
	MOVEI T4,0
DOC3:	PUSHJ	P,WILDCH	;CONVERT "#" TO "?" FOR PIP
	PUSHJ P,CMNO	;OUTPUT AN INPUT FILE NAME
>
IFE PIP33,<
	PUSHJ P,CMNO	;OUTPUT NAME OF OUTPUT FILE
	MOVSI T1,'*.*'
	MOVSI T2,'_  '
	CAMN T1,SVNAM(SVPT)
	MOVSI T2,'/X_'	;/X IF COPYING TO *.*
	PUSHJ P,OUTSIX	;OUTPUT _ OR /X_
	MOVEI T4,0
DOC3:	PUSHJ P,CMNO	;OUTPUT AN INPUT FILE NAME
>
	CAIL T4,-1(SVPT)
	JRST CPYDON	;DONE, CHECK FOR ANOTHER (IN COMMAND FILE)
	MOVEI T1,","
	PUSHJ P,OUTPIP	;ELSE A COMMA BETWEEN THEM
	AOJA T4,DOC3

CPYDON:	PUSHJ P,OUCRLF	;TERMINATE THIS PIP COMMAND
	MOVSI SVPT,-NFILE	;RESET SVPT
	PUSHJ	P,SCAN		; EAT THAT CRLF !! (AND ITS TERMF)
	JRST COPY2	;KEEP ON TRUCKIN'

CPYEOF:	SKIPE	PERFLG		; WERE WE CALLED BY PERFORM?
	PUSHJ	P,PERFOO	; YES, QUITE
	PUSHJ P,CHKPIP
	MOVSI T1,(SIXBIT /PIP/)
	MOVEM T1,PCNAM	;LOAD THIS ONE
	JRST DONE1

;THIS ROUTINE SCANS A FILE NAME AND CHECKS FOR THE RESERVED
;WORDS TELETYPE AND TERMINAL AND THEIR SUBSTRINGS.

GNM:	PUSHJ P,GETNMS
CKTTY:	SKIPN SVEXT(SVPT)
	SKIPE SVDEV(SVPT)
	POPJ P,		;NO FUNNY STUFF IF DEV OR EXT GIVEN
	MOVE	T1,['TELETY']
	MOVE	T2,['TERMIN']
	MOVE	T4,SVNAM(SVPT)
	SETZ	T5,
CKT1:	ADDI	T5,6
	LSH	T4,6
	JUMPN	T4,CKT1
	SUBI	T5,6*6
	MOVE	T4,SVNAM(SVPT)
	LSH	T1,(T5)
	LSH	T2,(T5)
	LSH	T4,(T5)
	CAME	T2,T4
	CAMN	T1,T4		;LOOK FOR TELETYPE OR ANY PART
	JRST .+2
	POPJ P,
	MOVSI T2,'TTY'	;TELETYPE, CHANGE DEVICE TO TTY:
	MOVEM T2,SVDEV(SVPT)
	SETZM SVNAM(SVPT)
	POPJ P,

IFN PIP33,<

;THIS ROUTINE CONVERTS ALL OCCURENCES OF THE CHARACTER "#"
;IN INPUT OR OUTPUT FILE NAMES (AND EXTENSIONS) TO THE 
;CHARACTER "?".	THIS IS DONE TO MAINTAIN COMPATIBILITY WITH
;DEC'S VERSION OF "PIP", WITH WILD-CHARACTER LOGIC.

WILDCH:	MOVE	T1,[POINT 6,SVNAM(T4)]	;PTR TO THE FILENAME
	PUSH	P,T3
	PUSH	P,T4		;SAVE THE ACCUMULATORS
	MOVEI	T2,6		;CHAR COUNT FOR FILENAMES
	PUSHJ	P,CONVRT	;CONVERTS "#" TO "?"
	POP	P,T4
	MOVE	T1,[POINT	6,SVEXT(T4)]	; PTR TO FILEXT
	PUSH	P,T4
	MOVE	T2,3		;CHAR COUNT FOR EXTENSIONS
	PUSHJ	P,CONVRT	;SAME CONVERSION AS ABOVE
	POP	P,T4
	POP	P,T3		;RESTORE ACCUMULATORS
	POPJ	P,		;AND RETURN

CONVRT:	ILDB	T3,T1		;T1 HAS POINTER, T5 HAS COUNT
	CAIN	T3,'#'		;IS THE CHAR A "#"?
	JRST	[MOVEI	T3,'?'	;YES!	CONVERT IT!
		DPB	T3,T1	;CHANGES BYTE IN SVNAM OR SVEXT
		JRST .+1]
	SOJG	T2,CONVRT	;CHECK THE CHARACTER COUNT
	POPJ	P,		;AND RETURN WHEN IT'S ZERO

>
HELP:	OUTSTR	HELPM
	JRST	EX

HELPM:	ASCIZ $
LIST OF SOME VALID COMMANDS:
	COMPILE
	CREATE
	DEBUG
	COPY
	TRY
	CROSS
	DELETE
	DIRECTORY
	EDITOR
	EXECUTE
	LOAD
	MAKE
	RENAME
	TECO
	TYPE
	PRINT
	FILES
	DECLARE
	HELP
	SYSNO
	DATE
	TIME
	WHO
$

TYMEX:	SKIPA	T2,[TRO T1,PVTYMX]
PDP10:	MOVE	T2,[TRZ T1,PVTYMX]
	HRROI	T1,GETPRV
	GETTAB	T1,		;GET CURRENT PRIVILEGE
	JRST	EX
	XCT	T2		;TURN TYMEX BIT ON OR OFF
	TRZ	T1,PVGEX	;MAKE SURE GE BIT IS OFF
	SETPRV	T1,		;SET NEW PRIVILEGE
	JRST	EX
;CHECKS IF END OF STORED STRING - IF SO TYPES STRING POINTED TO IN T4
;AND SETS PROMPT FLAG
PROMPT:	PUSHJ	P,SCANS	 ;GET TERM. CHAR.
	TRZ	FL,PRMPTF	;CLEAR FOR POS. PROMPT
	MOVE	T2,SAVCHR	;GET SAVED CHAR. TO CHECK FLAGS
	TLNN	T2,TERMF	;TERMINATION FLAG
	POPJ	P,		;NOT SET
	TRNE	IOPNT,-1
	JRST	SYNERR		;CAN'T PROMPT WITHIN COMMAND FILE
	OUTSTR	(T4)		;TYPE PROMPT MESSAGE
	PUSHJ	P,GSTRN	 ;GET NEW STRING
	TRO	FL,PRMPTF	;SET FLAG
	POPJ	P,
OCTTYP:	MOVEI	T3,10	;SET BASE TO EIGHT
	JRST	RDXTYP
RADX10:	MOVEI	T3,12	;BASE 10
RDXTYP:	PUSH	P,T2	;SAVE FOR TIME
	PUSHJ	P,PRTDIG
	POP	P,T2
	POPJ	P,0
PRTDIG:	IDIV	T1,T3
	HRLM	T2,0(P)	 ;SAVE DIGIT IN STACK
	SKIPE	T1		;CK IF DONE
	PUSHJ	P,PRTDIG	;NO, GET NEXT DIGIT
	HLRZ	T1,0(P)	 ;TAKE DIGITS OFF STACK
	ADDI	T1,"0"		;CHANGE TO ASCCI
	OUTCHR	T1
	POPJ	P,0
TPSIX:	PUSH	P,T3		;SAVE A COUPLE REG.
	PUSH	P,T2
	SKIPE	T3,1(T1)	;IF 0,TREAT 1ST AS LAST
	JRST	TPS1
	MOVE	T3,(T1)
TPS:	JUMPN	T3,TPS2
	POP	P,T2
	POP	P,T3
	POPJ	P,
TPS2:	MOVEI	T2,0
	LSHC	T2,6
	ADDI	T2,40
	OUTCHR	T2
	JRST	TPS
TPS1:	MOVEI	CS,6
	MOVE	T2,(T1)
TPS3:	MOVEI	T1,0
	LSHC	T1,6
	ADDI	T1,40
	OUTCHR	T1
	SOJG	CS,TPS3
	JRST	TPS2

CLUD:	CLOSE	RFL,		;CLOSE USER DIR. FILE
	STATZ	RFL,740000
	JRST	READER
	RELEAS	RFL,
	POPJ	P,0
DECLARE:	TRO	FL,PIPF	 ;SET PIP OUTPUT FLAG
	MOVEI	FLP,0		;USED FOR PROTECT BITS
	PUSHJ	P,SCANS	 ;CK IF PROMPTING DESIRED
	MOVE	CS,SAVCHR
	TLNN	CS,TERMF	;IF TERMF, THEN END AND NEED PROMPT
	JRST	DECL2		;NO PROMPT
	MOVE	T7,[12,,16]	;MONITOR TABLE 16, ENTRY 12
	GETTAB 	T7,		;GETS STANDARD FILE PROTECTION
	MOVE	T7,[047000,,0]	;JUST IN CASE OF FAILURE
	PUSHJ	P,GETPRT	; GET STD. PROTECTION FROM MONITOR
	MOVEI	T1,[ASCIZ /ALLOW PRIVATE:
/]
	PUSHJ	P,SDECL	 ;GET PRIVATE PROTECT BITS
	MOVE	T6,%PRPRT	;PRIVATE PROTECTION
	LSH	T6,6		;POS. FOR MERGE
	IOR	FLP,T6
	MOVEI	T1,[ASCIZ /ACCOUNT:
/]
	PUSHJ	P,SDECL
	MOVE	T6,%ACPRT	;STANDARD ACCT PROTECTION
	LSH	T6,3
	IOR	FLP,T6
	MOVEI	T1,[ASCIZ /PUBLIC:
/]
	PUSHJ	P,SDECL
	MOVE	T6,%PUPRT		;STND BITS FOR PUBLIC
	IOR	FLP,T6
	MOVSI	T1,TERMF
	MOVEM	T1,SAVCHR	;FAKE OUT PROMPT
DECL1:	MOVEI	T4,[ASCIZ /FILE(S): /]
	PUSHJ	P,PROMPT
	PUSHJ	P,SPREN
	TLO	FL,RENTSW	;SET RENAME SW
	PUSHJ	P,STTYMX	;SET TYMEX
	JRST	DOFL

SPREN:	MOVEI	T3,OUTDIR	;PREPARE TO OUTPUT IN RENAME FORMAT
	MOVEI	T1,"<"
	PUSHJ	P,OUTDIR
	MOVE	T1,FLP		;ACCUMULATED PROTECT BITS
	PUSHJ	P,OUTNUM	;OUTPUT IN DECIMAL FOR DIRIT
	MOVEI	T1,">"
	JRST	OUTDIR
DECL2:	MOVEI	T4,0		;ACCUM. BITS HERE
	MOVEI	T5,3		;3 FIELDS
	PUSHJ	P,IDP1		;GET PROT. BITS
	MOVE	FLP,T4
	JRST	DECL1

SDECL:	MOVEI	T6,7		;START WITH NOTHING
	OUTSTR	(T1)
	MOVEI	T1,[ASCIZ /	MODIFY? /]
	PUSHJ	P,YN
	JRST	SDM
	MOVEI	T1,[ASCIZ /	READ(RD)? /]
	PUSHJ	P,YN
	JRST	SD4
	MOVEI	T1,[ASCIZ /	RUN(RUN)? /]
	PUSHJ	P,YN
	JRST	SD5
	MOVEI	T1,[ASCIZ /	LOOKUP(LK)? /]
	PUSHJ	P,YN
	JRST	SD6
	OUTSTR	[ASCIZ /	NOTHING(NO)
/]
	JRST	CPOPJ1
SDM:	MOVEI	T1,[ASCIZ /	RENAME & DELETE(ALL)? /]
	PUSHJ	P,YN
	JRST	SD0
	MOVEI	T1,[ASCIZ /	CHANGE PROT.(CP)? /]
	PUSHJ	P,YN
	JRST	SD1
	MOVEI	T1,[ASCIZ /	UPDATE(UPD)? /]
	PUSHJ	P,YN
	JRST	SD2
	OUTSTR	[ASCIZ /	APPEND(AP)
/]
	JRST	SD3
SD0:	SUBI	T6,1
SD1:	SUBI	T6,1
SD2:	SUBI	T6,1
SD3:	SUBI	T6,1
SD4:	SUBI	T6,1
SD5:	SUBI	T6,1
SD6:	SUBI	T6,1
	JRST	CPOPJ1

YN:	OUTSTR	(T1)
YN4:	PUSHJ	P,GSTRN
YN1:	PUSHJ	P,GETCH
	JUMPE	CS,YN1
	CAIN	C,15
	JRST	YN1
	TLNE	CS,TERMF
	JRST	YN4		;END OF LINE, GET ANOTHER
	HRRZ	C,CS
	SETZB	CS,SAVCHR
	CAIN	C,56		;TEST FOR N
	JRST	CPOPJ1
	CAIN	C,71		;TEST FOR Y
	POPJ	P,0
	CAIE	C,"-"
	JRST	YN5
	POP	P,(P)		;MAKE RETURN GO ONE LOWER
	POPJ	P,0
YN5:	OUTSTR	[ASCIZ/WHAT? /]
	JRST	YN4


;PRINTS PROJECT-PROGRAMMER (ACCOUNT-PROG.) NO
PPN:	MOVEI	T4,[ASCIZ /USER NAME: /]
	PUSHJ	P,PROMPT	;CK IF PROMPT, THEN TYPE
	PUSHJ	P,GTUNO	 ;GET USER NO.
	PUSHJ	P,TPPPN	 ;GO TYPE
	SKIPE	PERFLG		;WERE WE CALLED BY PERFORM?
	OUTSTR	[ASCIZ /
/]
	JRST	EX
;GTUNO: TAKES NAME (read in with SCANW) AND VERIFIES IF VALID
;RETURNS: T3/ PPN
;	T4/ USERNAME PART 1
;	T5/ USERNAME PART 2
;	T1/NMLST INDEX
;	C/ TERMINATOR CHAR FROM SCAN CALL TO READ NAME
;	CS/ TABLE(C)

GTUNO:	MOVEI	T5,0		;IN CASE 6 OR LESS CHARS.
	PUSHJ	P,SCANW	 ;GET FIRST 6
	JRST	GTU1		;FOUND A TERMINATOR
	MOVE	T4,ACCUM	;SAVE FIRST WORD OF NAME
	PUSHJ	P,SCANW
	JRST	GTU2		;A TERM.CHAR.
	PUSHJ	P,GETCH	 ;CK. NEXT CHAR
	JUMPG	CS,SYNERR	;ERROR, MUST BE TERM.
GTU2:	SKIPA	T5,ACCUM	;2ND WORD OF NAME
GTU1:	MOVE	T4,ACCUM
	pushj	p,findun	;go try and find in current list
	 popj	p,		;found it (we just saved a lot of I/O)
	PUSHJ	P,OPUD		;NO MATCH ANYWHERE, HAVE TO TRY THE LUD
	PUSHJ	P,LKLUD	;T1/LOC OF LUD ENTRY NOW IN BUF
	JRST	BADNAM
	PUSHJ	P,CLUD	;CLOSE LUD
	PUSH P,T2
	MOVE T2,NMLSTP	; T2/NMLST INDEX LAST ENTRY PRESENT
	CAIG T2,NMLSTL-1	;SHOW NEW NMLST ENTRY UNLESS FULL
	AOS T2,NMLSTP
	MOVE T3,BUF+LPRV(T1)
	MOVEM T3,LDPRV(T2)
	MOVE T3,BUF+LBITS(T1)
	MOVEM T3,LDBITS(T2)
	MOVE T3,BUF+LDPPN(T1)
	MOVEM T3,PPNS(T2)
	SETZM UFDS(T2)
	MOVEM T4,NAMES1(T2)
	MOVEM T5,NAMES2(T2)
	POP P,T2
	MOVE T1,NMLSTP
	POPJ P,

;;findun: find a user name in in-core table
;;	takes name in t4,t5
;;	 success: direct return, t1=nmlst index, t3=PPN, other acs ok
;;	 failure: skip return, t1 trashed
findun:	move	t1,nmlstp	;get base of name list
	camn	t4,names1(t1)
	came	t5,names2(t1)
	 sojge	t1,.-2		;run along list looking for name
	jumpl	t1,cpopj1	;we didn't find one, skip return
	move	t3,ppns(t1)	;we found it, get return value set
	popj	p,		;return (no skip)

;;tranun: translate a user name into a PPN.
;;	takes name in t4,t5, returns PPN in t3, t1 trashed
;;	causes error on failure
tranun:	pushj	p,findun	;try and find it in table
	 popj	p,		;how about that, we did
	push	p,[3]		;make a lookup block
	push	p,[t4]		;this word points to the name
	push	p,[0]		;don't really want to look anything up
	push	p,[0]		;just want to use LOOKUP to find PPN
	INIT	LOOK,17
	SIXBIT	/DSK/
	XWD 0,0
	HALT	.		;DSK not available(?)
	lookup	look,-3(p)
	skipa	t3,-2(p)	;get converted PPN  (LOOKUP must fail)
	 halt	.		;found file with null name(?)
	sub	p,[xwd 4,4]	;remove the lookup block from the stack
	release	look,
	tlne	t3,-1		;check if ppn was changed
	 popj	p,		;it was, return with it

BADNAM:	OUTSTR	[ASCIZ /NO USER NAMED: /]
	MOVEI	T1,T4
	PUSHJ	P,TPSIX
	JRST	EX

;LOOK UP NAME IN LUD
;EXPECTS NAME IN T4,T5
;FILE MUST BE OPEN
;NO SKIP RETURN IF NOT IN LUD
;T1 RETURNS WITH INDEX INTO BUF
LKLUD:	MOVEM	FL2,SVAC	;SAVE SOME ACCUM.
	MOVE	FL2,[XWD FL2+1,SVAC+1]
	BLT	FL2,SVAC+6
	MOVEI	C,0
	MOVE	T1,[555555555555]
	MOVE	T2,[361275431652]
	MOVE	T3,[612754316523]
	PUSHJ	P,RND
	PUSHJ	P,RND
	PUSHJ	P,RND
	PUSHJ	P,RND
	XOR	T2,T3
	XOR	T1,T2
	TLZ	T2,400000
	IDIVI	T2,^D887
	MOVE	T2,T1
SRUS:	PUSHJ	P,RDBLK
	MOVEI	T1,0
SRUSR:	CAME	T2,BUF+LHUN(T1)
	JRST	NUSER
	AOS	0(P)
LKLUDE:	MOVE	C,[XWD SVAC,FL2]	;RESTORE ACCUM.
	BLT	C,C
	POPJ	P,0
NUSER:	SKIPG	T6,BUF+LDPPN(T1)
	JRST	BLKLNK
	MOVE	T6,BUF+LLINK(T1)
	ANDI	T6,177
	ADD	T1,T6
	JRST	SRUSR
BLKLNK:	JUMPE	T6,LKLUDE	
	MOVE	T3,T6
	JRST	SRUS

RND:	ADD	T2,T4
	ROTC	T4,-22
	MOVEI	CS,5
RND1:	MOVE	T6,T2(C)
	MUL	T6,[5*5*5*5*5*5*5*5*5*5*5*5*5*5*5]
	ADDM	T7,T3(C)
	AOJE	C,RND2
	MOVNI	C,1
	TRNE	T2,1
	SKIPL	T3
	MOVEI	C,0
	EXCH	T1,T3
RND2:	SOJG	CS,RND1
	POPJ	P,0
TPPPN:	HLRZ	T1,T3		;TYPE NO. IN T3
	MOVE	T4,T3
	PUSHJ	P,OCTTYP
	OUTCHR	[","]
	HRRZ	T1,T4
	JRST	OCTTYP
;ROUTINE OPUD OPENS LUD. DESTROYS T1-T3

OPUD:	PUSH	P,T4
	INIT	RFL,17
	SIXBIT	/SYS/
	XWD	0,0
	 EXIT
	MOVE	T1,[SIXBIT /LUD/]
	MOVSI	T2,(SIXBIT /SYS/)
	SETZB	T3,T4
	LOOKUP	RFL,T1
	MESS	<CAN'T OPEN LUD>
	Setom	RFLBLK			; Force read of LUD block [v153]
	POP	P,T4
	POPJ	P,0

COMMENT ! SCANW -- GET A SIXBIT WORD. USED ONLY BY GTUNO PRESENTLY
!

SCANW:	SETZM	ACCUM	;GATHERS 6 CHARS.
	MOVE	T1,[POINT 6,ACCUM]
	SKIPN	CS,SAVCHR	;USE SAVED CHAR IF ONE
	JRST	SCW1	;NO SAVED, GO GET ONE
	SETZM	SAVCHR	;DONT USE AGAIN
	JRST	.+2	;DONT GET ANOTHER
SCW1:	PUSHJ	P,GETCH
	JUMPLE	CS,SCW3	 ;TERM CHAR
SCW2:	IDPB	CS,T1
	TLNE	T1,770000	;CK IF 6 CHARS. STORED
	JRST	SCW1		;NOT YET
	JRST	CPOPJ1		;SKIP RETURN FOR NO TERM CHAR
SCW3:	CAIE	C,15		;CAR. RET. FOR TERM.
	CAMN	CS,CTBL+12		;CHECK CHAR IN CTBL FOR SPACE
	POPJ	P,0
	CAIE	C,":"
	CAIN	C,";"		;VALID TERMINATOR
	POPJ	P,0
	CAIE	C,","
	CAIN	C,")"
	POPJ	P,0
	SUBI	C,40		;CHANGE TO 6 BIT
	TRNE	C,100		;CK NO. OF BITS
	POPJ	P,0		;MUST BE FUNNY TERM.
	MOVE	CS,C
	JRST	SCW2

COMMENT ! WTBLK  -- FOR MAILBOX CODE. WRITE BLOCK
EXPECTS: T3/BLOCK TO USETO TO
	HED/ IOWD FOR BUF FULL OF OUTPUT STUFF
DESTROYS: NO AC
RETURNS: POPJ
! 

WTBLK:	HRRM	T3,RFLBLK	;NOTE NEW POSITION
	USETO	RFL,1(T3)
	OUTPUT	RFL,HED
	STATO	RFL,740000
	POPJ	P,0
	OUTSTR	[ASCIZ/OUTPUT ERROR/]
	JRST	BYENOW
COMMENT ! RDBLK -- FOR MAILBOX CODE. INPUT A BLOCK INTO BUF
EXPECTS: T3/BLOCK TO USETI TO
!

RDBLK:	CAMN	T3,RFLBLK	;DO WE ALREADY HAVE IT
	POPJ	P,		;YUP,NO WORK
	HRRM	T3,RFLBLK	;NO,NOTE NEW POSITION
	USETI	RFL,1(T3)
	INPUT	RFL,HED
	STATO	RFL,760000
	POPJ	P,0
	MOVSI	T1,-200
	SETZM	BUF(T1)
	AOBJN	T1,.-1
	MOVEI	T1,0		;SW
	POPJ	P,0
DODATE:	DATE	T1,		;GET DATE FROM MONITOR
	PUSHJ	P,TDATE
	TIMER	T1,		;RECOVER TIME IN MILLISEC
	PUSHJ	P,PRTIM1
	JRST	EX

TDATE:	IDIVI	T1,^D31	 ;GET MONTH
	MOVEI	T3,1(T2)
	MOVE	T2,T1
	MOVEI	T1,0
	DIVI	T1,^D12	 ;SEPARATE MONTH FROM YEAR
	OUTSTR	MONTH(T2)
	MOVE	T2,T1
	MOVE	T1,T3
	PUSHJ	P,RADX10	;TYPE DAY
	OUTSTR	[ASCIZ /, 19/]
	MOVEI	T1,^D64(T2)	;YEAR 64 IS 0
	PUSHJ	P,RADX10	;TYPE YEAR
	OUTSTR	[ASCIZ/	/]
	POPJ	P,
MONTH:	ASCIZ "JAN "
	ASCIZ "FEB "
	ASCIZ "MAR "
	ASCIZ "APR "
	ASCIZ "MAY "
	ASCIZ "JUN "
	ASCIZ "JUL "
	ASCIZ "AUG "
	ASCIZ "SEP "
	ASCIZ "OCT "
	ASCIZ "NOV "
	ASCIZ "DEC "

PRTIM1:	IDIVI	T1,^D3600		;CHANGE JIFFIES TO MINS.
	IDIVI	T1,^D60	 ;HRS IN T1, MIN IN T2
	PUSHJ	P,RADX10	;TYPE HOURS
	OUTCHR	[":"]
	CAIG	T2,11
	OUTCHR	["0"]
	MOVE	T1,T2
	JRST	RADX10		;TYPE MINUTES AND RETURN
;GET USER FILE DIRECTORY PROTECTION BITS
GETPRT:	LDB	T6,[POINT 3, T7, 2]	
	LSH	T6, 3		; SHIFT'EM INTO PLACE
	MOVEM	T6,%PRPRT#	; PRIVATE PROTECTION BITS
	LDB	T6,[POINT 3, T7, 5]	; NEXT 3 BITS
	MOVEM	T6,%ACPRT#	; ACCOUNT PROTECTION BITS
	LDB	T6,[POINT 3, T7, 8]	; LAST 3 BITS
	MOVEM	T6,%PUPRT#	; PUBLIC PROTECTION BITS
	POPJ	P,0
; SET FILE DIRECTORY CONTROLS
FDC:	MOVE	T7,[13,,16]	; MONITOR TABLE 16, ENTRY 13 
	GETTAB	T7,	;	GETS STANDARD UFD PROTECTION CODE
	MOVE	T7,[754000,,0]	; JUST IN CASE IT FAILS
	PUSHJ	P,GETPRT	;CF. MONITOR FOR UFD PROTECTIONS
	MOVE	T6,%PRPRT	; STANDARD PROTECTION, PRIVATE
	MOVEI	T1,[ASCIZ /ALLOW ACCOUNT:
/]
	PUSHJ	P,SFDC
	MOVE	T7,%ACPRT		;STANDARD OPTIONS
	OR	T6,T7
	LSH	T6,3
	MOVEI	T1,[ASCIZ /PUBLIC:
/]
	PUSHJ	P,SFDC
	MOVE	T7,%PUPRT		;STANDARD PUBLIC PROTECTION
	OR	T6,T7
	PUSHJ	P,OPMFD
	DPB	T6,[POINT 9,T3,8]
	MOVE	T4,[XWD 1,1]
	RENAME	RFL,T1
FDERR:	OUTSTR	[ASCIZ/FD ERROR/]
	JRST	EX

SFDC:	OUTSTR	(T1)
	MOVEI	T7,0
	MOVEI	T1,[ASCIZ /	SHARABLE? /]
	PUSHJ	P,YN
	TRO	T7,4
	MOVEI	T1,[ASCIZ /	NEW FILES? /]
	PUSHJ	P,YN
	TRO	T7,2
	MOVEI	T1,[ASCIZ /	LISTABLE? /]
	PUSHJ	P,YN
	TRO	T7,1
	JRST	CPOPJ1

;PRINT FILE DIRECTORY CONTROLS
PFDC:	PUSHJ	P,OPMFD
	MOVEI	T1,[ASCIZ /
ACCOUNT:	/]
	LSHC	T2,6
	PUSHJ	P,TFDC
	MOVEI	T1,[ASCIZ /
PUBLIC:	/]
	LSHC	T2,3
	PUSHJ	P,TFDC
	JRST	EX

TFDC:	TRNN	T2,7
	POPJ	P,
	OUTSTR	(T1)
	TRNE	T2,4
	OUTSTR	[ASCIZ/SHARABLE /]
	TRNE	T2,2
	OUTSTR	[ASCIZ/NEW FILES /]
	TRNE	T2,1
	OUTSTR	[ASCIZ/LISTABLE/]
	POPJ	P,0

OPMFD:	INIT	RFL,17
	SIXBIT	/DSK/
	0
	HALT
	MOVE	T1,USRPPN
	MOVSI	T2,(SIXBIT /UFD/)
	MOVEI	T3,0
	MOVE	T4,[XWD 1,1]
	LOOKUP	RFL,T1
	JRST	FDERR
	POPJ	P,
;HANDLE VARIOUS EDITOR-TYPE COMMANDS

EDITOR:	TLNN	FL,TYMX
	JRST	EDIT10		;IN PDP MODE, THIS CALLS EDIT10
	SETOM	EDCMND		;TYMEX MODE, START EDITOR AT NORMAL START ADDRESS
	PUSH	P,JDONE1	;DIDDLE RETURN ADDRESS TO AVOID PLAYING WITH ARGUMENTS
	JRST	MODIFY

VUE:	MOVSI	T1,'VUE'	;GET FILENAME TO RUN
	JRST	EDFIN		; AND ACT LIKE EVERYONE ELSE

MAKE:	TRO	FL,CREATF	;A CREATE-STYLE COMMAND
TECO:	MOVE	T1,[SIXBIT/TECO/] ;YES, SOME PEOPLE USE THIS EDITOR
	JRST	EDFIN

CREATE:	TRO	FL,CREATF
	TLNN	FL,TYMX	;CHOOSE APPROPRIATE EDITOR FOR MODE
EDIT10:	SKIPA	T1,[SIXBIT/EDIT10/] ;A PDP HACK OR 10EDIT COMMAND
MODIFY:	MOVE	T1,[SIXBIT/EDITOR/] ;A TYMHACK
EDFIN:	MOVEM	T1,PCNAM	;SAVE HIS EDITOR
	TRO	FL,EDITF
	POPJ	P,
;FLAGS IN LH OF FL FOR EDITING
SQFLG==1	;/S FOR EDIT10
RFLG==2	 ;READ ONLY (/R)

DOEDIT:	PUSHJ P,SCAN	;START ON THE FILE NAME
DOEDT1:	PUSHJ P,GETNAM
EDRS:	PUSHJ	P,SCAN
	CAIE	C,"/"
	JRST NOEDSW
	PUSHJ P,SCAN
	TRNN FL,IDF
	JRST SYNERR
	MOVE T1,[XWD -EDSWL,EDSWT]
	PUSHJ P,SWSCAN
	JRST UNRECS
	JFCL
	TLO FL,@EDSWT2-EDSWT(T1)
	JRST EDRS
NOEDSW:	SKIPE SVDEV	;DEVICE IS ILLEGAL
	JRST	SYNERR
	MOVEI	T3,OUTEDT
	MOVEI	T1," "		;COMMAND FOR DREDIT
	PUSHJ	P,OUTEDT	;OUTPUT THE S
	MOVEI T4,0
	PUSHJ P,CMNO	;OUTPUT THE NAME
	MOVE T4,[XWD -EDSBL,EDSBT]
	PUSHJ P,SWBITS
	TLNN FL,(T2)
	TRNE	FL,CREATF	;EDIT OR CREATE?
	JRST	DOEDT3		;CREATE (OR MAKE)
DOEDP:	PUSHJ	P,OUCRLF	;EDIT (OR TECO) - OUTPUT CRLF
DOEDT2:
	CAIE C,"%"
	JRST NOCOMS
RCOM:	PUSHJ P,GETCH
	TLNN CS,TERMF	;THE END, GET CRLF AND GO
	CAIN C,"%"	;START OF ANOTHER COMMAND
	JRST DOEDP	;THIS WILL PUT OUT CRLF AND READ MORE
	MOVE T1,C	;PUT IT OUT
	PUSHJ P,OUTEDT
	JRST RCOM
NOCOMS:	TLNN CS,TERMF
	JRST SYNERR
	MOVEI T1,0
	PUSHJ P,OUTEDT
	PUSHJ P,CHKEDT
		JRST DONE	;GO GET IT LOADED

DOEDT3:	MOVEI	T1,175		;OLD ALTMODE
	PUSHJ	P,OUTEDT	;ENDS CREATE OR MAKE COMMAND
	JRST	DOEDT2

DEFINE TABLE<
SWITCH SEQUENCE,SQFLG
SWITCH READ,RFLG
>
TBGEN (EDSWT,EDSWL,EDSWT2)
EDSBT:	SBTS R,RFLG
	SBTS S,SQFLG
EDSBL==.-EDSBT
;FLAGS IN LH OF FLP(PERM) AND LH OF FLT(TEMP)
;FOR SPECIAL LISTER SWITCHES
PFLG==1	 ;FOOTRAN TYPE OUTPUT /FOOTRAN
LFLG==2	 ;CASE CONTROL /CASE
QFLG==4	 ;QUESTION MARK CONTROL /QUESTION
HFLG==10	;HEADER CONTROL /HEADER
NFLG==20	;SEQUENCE NUMBER PRINTING /NOSEQUENCE
SFLG==40	;SKIP CONTROL CHRS. /NOSKIPCONTROL
DFLG==100	;MULTI LINE /DOUBLE /MULTILINE
MFLG==200	;SET M SWITCH(/LOL) 
JFLG==400	;SET J SWITCH(/NOFULL)
LIMSW==1000	;IMEDIATE MODE SWITCH
OFLG==2000	;SMALL PRINTER PAPER /SMALL
GFLG==4000	;PAGED TTY OUTPUT /PAGED
IFLG==10000	;CHEAP HEADING /CHEAD
EFLG==20000	;COUNT PAGES /COUNT
AFLG==40000	;ONE NUMBER PAGE SCHEME /ONENUM
%BFLG==100000	;SET PAGE SIZE /SIZE NN
KFLG==200000	;SET K SWITCH(/NOFULL)
REFLAG==400000	;SET R SWITHC (/RESTART)

;ENTRIES IN NUMBER TABLE
SIZEP==1
LOLS==2		;/LOL SWITCH
REST==3		;/RESTART SWITCH
LINES==4	;MUST BE LAST ENTRY
;NOTE THAT LINES MUST BE THE LAST ENTRY IN THE TABLE BECAUSE
;THE IDIOT WHO CODED THIS SECTION OF RPG USES LINES AS A 
;CONSTANT FOR A SCAN LOOP.....
;ALSO KEEP IN ORDER TABLE AT LOCATION	SPSTB

ARRAY PTAB,TTAB[LINES+1]

PRINT:	SKIPA T2,[SIXBIT /LPT/]
TYPR:	MOVSI T2,'TTY'
	MOVSI FLP,QFLG+HFLG
	JRST LSTST
LISTR:	MOVSI T2,'LPT'
	MOVSI FLP,QFLG
LSTST:	MOVEM T2,LISDEV#
	MOVE	T3,[SIXBIT/LISTER/]
	MOVEM	T3,PCNAM	;...
LSTLP1:	MOVSI T2,'DSK'
	MOVEM T2,LOKNAM
	TRO	FL,PIPF ;IF IT'S PIP, ALLOW *.MAC, ETC.
	MOVEI	T3,LSTEOF	;LOC OF LISTER EXIT ROUTINE
	MOVEM	T3,EOFLAB	;GOES TO INDIRECT PTR IN RELTAB
LSTLP:	PUSHJ P,SCAN	;GET NAME
	TLNE	FL,NEDCMA	; A COMMA TO SEPARATE FILES?
	PUSHJ	P,PUTCMA	;YES, WRITE IT OUT.
LSTLPP:	CAIN C,"/"
	JRST PLSTSW
	PUSHJ P,GETNAM
	MOVEI T3,OUTLST
	SKIPN T2,SVDEV
	MOVE T2,LOKNAM	;USE PREV NAME IF NO NEW NAME
	MOVEM	T2,LOKNAM	;KEEP DTA NAME AROUND FOR MORE FILES
	MOVEM T2,SVDEV
	MOVEI T4,0
	TLON FL,NEDCMA	;FIRST NAME?
	SKIPE OUTDEV	;NO, IS THERE A SPECIAL OUTPUT DEV?
	JRST LSTNF	;YES
	CAIE C,"_"	;NOT YET, CHECK FOR _ OR =
	CAIN C,"="
	JRST [	PUSHJ P,CMNO	;NAME FOLLOWED BY _ OR =, OUTPUT THE NAME
		MOVEI T1,"_"
		PUSHJ P,OUTLST	;AND A _
		PUSHJ P,SCAN	;SCAN PAST _ OR =
		SETOM	OUTDEV#	;SPECIAL OUTPUT DEVICE
		TLZ	FL,NEDCMA ;TURN OFF THE SPURIOUS BIT
		JRST LSTLP1]	;AND GO FOR NEXT NAME
	MOVE T2,LISDEV
	HRRI T2,':_ '	;FIRST NAME NOT FOLLOWED BY _ OR = SO MUST
	PUSHJ P,OUTSIX	;BE USING DEFAULT DEVICE - GIVE IT TO LISTER
LSTNF:	PUSHJ P,CMNO	;OUTPUT NAME
	MOVE FLT,FLP	;SET TEMPS FROM PERMS
	MOVE T1,[XWD PTAB,TTAB]
	BLT T1,TTAB+LINES
	PUSHJ P,SCAN
TSWRT:	CAIN C,"/"
	JRST TLSTSW
	MOVEI T3,OUTLST
	MOVE T4,[XWD -LSWBTL,LSWBTB]
	PUSHJ P,SWBITS
	TLNN FLT,(T2)
	MOVEI T4,LINES
NXSLC:	TLNN FLT,@SPSTB-1(T4)	;IS BIT ON
	JRST NOSPC	;NO
	MOVEI T1,"/"
	PUSHJ P,OUTLST
	MOVE T1,TTAB(T4)
	PUSHJ P,OUTNUM
	HLLZ T2,SPSTB-1(T4)
	PUSHJ P,OUTSIX	;THE SWITCH
NOSPC:	SOJG T4,NXSLC
	CAIE C,"("
	JRST ENDLST
	SKIPA	;PASS PAGE INFO
LST1:	PUSHJ P,GETCH
	MOVE T1,C
	PUSHJ P,OUTLST
	CAIE C,")"
	JRST LST1
	PUSHJ P,SCAN
ENDLST:	TLNE	CS,TERMF	;A LINE-FEED?
	JRST	LSTLP	;YES, START AGAIN FROM THE TOP
	CAIE	C,54	;NO, WELL THEN.. A COMMA?
	JRST	SYNERR	;NOPE.	HE LOSES.
	JRST	LSTLP	;START AGAIN
LSTEOF:	PUSHJ	P,OUCRLF	;ADD CRLF TO COMMAND
	SKIPE	PERFLG		;WERE WE CALLED BY PERFORM?
	PUSHJ	P,PERFOO	;YES, WRITE OUT PERFOR!

	PUSHJ	P,CHKLST
	JRST DONE1

PUTCMA:	MOVEI	T1,","
	JRST	OUTLST		;WRITE OUT A COMMA

DEFINE SPMK (A,B)
<<SIXBIT !A!>+B>
;THIS TABLE MUST BE IN THE SAME ORDER AS THE NUMBER TABLE
SPSTB:	SPMK B,%BFLG
	SPMK M,MFLG	;/LOL SWITCH(/M)
	SPMK R,REFLAG	;/RESTART SWITCH (/R)
	SPMK D,DFLG	;MUST BE LAST
	SPMK B,%BFLG	;/SIZE SWITCH

OUTNUM:	IDIVI T1,^D10	;RECOGNIZE THIS??
	HRLM T2,(P)
	SKIPE T1
	PUSHJ P,OUTNUM
	HLRZ T1,(P)
	ADDI T1,"0"
	JRST (T3)
PLSTSW:	PUSHJ P,LSTSW
	TLZ FLP,(T4)
	MOVSS T4
	TLO FLP,(T4)
	MOVEM T2,PTAB(T3)
	JRST LSTLPP

TLSTSW:	PUSHJ P,LSTSW
	TLZ FLT,(T4)
	MOVSS T4
	TLO FLT,(T4)
	MOVEM T2,TTAB(T3)
	JRST TSWRT

LSTSW:	PUSHJ P,SCAN
	TRNN FL,IDF
	JRST SYNERR
	MOVE T1,[XWD -LLG,LSTBL]
	PUSHJ P,SWSCAN
	JRST UNRECS
	JFCL
	SETZB T2,T3
	MOVE T4,LSTB2-LSTBL(T1)
	TLNE T4,LIMSW
	JRST (T4)
	JRST SCAN

DEFINE TABLE
<SWITCH FORTRAN,<XWD PFLG,0>
SWITCH NOFORTRAN,PFLG
SWITCH NOCASE,<XWD LFLG,0>
SWITCH FULLCHARACTERSET,<XWD JFLG,KFLG>
SWITCH NOFULLCHARACTERSET,<XWD KFLG,JFLG>
SWITCH NORMALCHARACTERSET,<XWD 0,JFLG+KFLG>
SWITCH CASE,LFLG
SWITCH NOQUESTION,<XWD QFLG,0>
SWITCH QUESTION,QFLG
SWITCH SINGLE,DFLG
SWITCH DOUBLE,<XWD LIMSW,DOUBLE>
SWITCH MULTISPACE,<XWD LIMSW,MULTI>
SWITCH HEADING,HFLG
SWITCH NOHEADING,<XWD HFLG,0>
SWITCH SEQUENCE,NFLG
SWITCH NOSEQUENCE,<XWD NFLG,0>
SWITCH SKIPCONTROL,<XWD SFLG,0>
SWITCH NOSKIPCONTROL,SFLG
SWITCH SMALL,<XWD OFLG,0>
SWITCH LARGE,OFLG
SWITCH PAGED,<XWD GFLG,0>
SWITCH NOPAGE,GFLG
SWITCH CHEAD,<XWD IFLG,0>
SWITCH NOCHEAD,IFLG
SWITCH COUNT,<XWD EFLG,0>
SWITCH NOCOUNT,EFLG
SWITCH ONENUM,<XWD AFLG,0>
SWITCH TWONUM,AFLG
SWITCH NOONENUM,AFLG
SWITCH SIZE,<XWD LIMSW,DSIZ>
SWITCH LOL,<XWD LIMSW,LOLER>
SWITCH RESTART,<XWD LIMSW,RESTER>
SWITCH RUN,<XWD LIMSW,SETRUN>
>
TBGEN (LSTBL,LLG,LSTB2)
LSWBTB:	SBTS P,PFLG
	SBTS L,LFLG
	SBTS Q,QFLG
	SBTS H,HFLG
	SBTS N,NFLG
	SBTS S,SFLG
	SBTS O,OFLG
	SBTS G,GFLG
	SBTS A,AFLG
	SBTS E,EFLG
	SBTS I,IFLG
	SBTS J,JFLG
	SBTS K,KFLG
LSWBTL==.-LSWBTB
DSIZ:	PUSHJ	P,STARGS
;ROUTINE FOR /SIZE SWITCH
	TRNN	FL,NUMFS
	JRST	SYNERR
	MOVE	T2,NUMAC
	MOVSI	T4,%BFLG
	MOVEI	T3,SIZEP
	JRST	FINPRS

MULTI:	PUSHJ P,STARGS
	TRNN FL,NUMFS
	JRST SYNERR
	MOVE T2,NUMAC
MULTIC:	MOVSI T4,DFLG
	MOVEI T3,LINES
	JRST FINPRS

DOUBLE:	MOVEI T2,1
	TLZ FL,PARFLG
	JRST MULTIC

;CODE TO HANDLE THE /LOL SWITCH
LOLER:	PUSHJ	P,STARGS	;SET UP ARGUMENTS
	TRNN	FL,NUMFS	;SAY WE ARE SCANNING FOR A NUMBER
	JRST	SYNERR		;NO -- BAD
	MOVE	T2,NUMAC
	MOVSI	T4,MFLG		;SAY WHICH FLAG TO SCAN FOR IN TBL
	MOVEI	T3,LOLS		;TABLE ENTRY #
	JRST	FINPRS		;FINISH NUMBER SCAN

;CODE TO HANDLE THE /RESTART SWITCH
RESTER:	PUSHJ	P,STARGS
	TRNN	FL,NUMFS
	JRST	SYNERR
	MOVE	T2,NUMAC
	MOVSI	T4,REFLAG
	MOVEI	T3,REST
	JRST	FINPRS
OUCRLF:	MOVEI	T1,15	;CARRIAGE RETURN
	PUSHJ	P,0(T3)	 ;TO CURRENT OUTPUT FILE
	MOVEI	T1,12		;LINE FEED
	JRST	0(T3)		;TO OUTPUT FILE
ARRAY BJFF,BFLG[20],BOB[20*3]

COMNIT:	PUSH P,T2
	HRRZ T2,T5
	IMULI T2,3	;POINTE TO BUFFERS
	SOSLE BOB+2(T2) ;ANY MORE SPACE
	JRST BOU1
	SKIPN BFLG(T5)	;DOING TMPCOR?
	PUSHJ P,INOLD	;YES, INIT FOR DSK
	SETOM BFLG(T5)	;AND MARK
	HRLI T5,CIO.OT
	CHANIO T5,
	SKIPA
	JRST OUTER
BOU1:	IDPB T1,BOB+1(T2)
	POP P,T2
	POPJ P,

COMCHK:	PUSH P,T1
	MOVE T1,BJFF(T5)	;RECOVER START OF BUFFERS
	ADDI T1,2	;START OF DATA
	HRRM T1,TMPFIL+1	;SET UP IOWD
	HRRZ T1,T5
	IMULI T1,3
	HRRZ T1,BOB+1(T1)	;THE BYTE POINTER
	SUB T1,BJFF(T5)
	SUBI T1,2
	MOVNS T1	;SET UP COUNT
	HRLM T1,TMPFIL+1
	MOVEI T1,17
	SUB T1,T5
	MOVE T1,PRNMTB(T1)
	HRLZ T1,BNAM-1(T1)
	MOVEM T1,TMPFIL
	SKIPE	BFLG(T5)
	JRST	[SETZM	TMPFIL+1
		MOVE	T1,[2,,TMPFIL]
		TMPCOR T1,
		JFCL
		POP	P,T1
		JRST	CK1B]
	MOVE T1,[XWD 3,TMPFIL]	;WRITE OP
	TMPCOR	T1,
	SKIPA	;ERROR
	JRST	[POP P,T1
	POPJ P,]
	POP P,T1
	PUSHJ P,INOLD	;SET UP FOR REGULAR OUTPUT
CK1B:	HRLI T5,CIO.RL
	CHANIO T5,	;DO A RELEASE
	POPJ P,

INITCH:	PUSHJ P,CHKRM	;GET SOME SPACE FOR BUFFERS
	PUSH P,T1
	PUSH P,T2
	MOVE T1,JOBFF
	MOVEM T1,BJFF(T5)
	HRRZ T2,T5
	IMULI T2,3
	ADDI T2,BOB
	HRLZM T2,INIT1
	HRLI T5,CIO.OP
	CHANIO T5,NSDOPN
	 JRST EX ;CAN NOT GET DSK
	HRLI T5,CIO.OB
	CHANIO T5,2
	ADDI T1,3
	HRLI T1,440700	;SET UP BUFFER HEADERS
	MOVEM T1,1(T2)
	HRLS T1
	ADDI T1,1
	SETZM -1(T1)
	MOVEI T2,176(T1)
	BLT T1,(T2)
	MOVEI T1,200*5
	HRRZ T2,T5
	IMULI T2,3
	MOVEM T1,BOB+2(T2)
	MOVSI T1,400000
	ANDCAM T1,BOB(T2)
	SETZM BFLG(T5)	;MARK AS TEMPCORE
	POP P,T2
	POP P,T1
	POPJ P,
INOLD:	PUSH P,T1
	MOVEI T1,17
	SUB T1,T5
	MOVE T1,PRNMTB(T1)	;GET PROCESSOR NUMBER
	MOVE T1,BNAM-1(T1)	;GET ITS NAME
	HLL T1,JOBNAM
	MOVEM T1,NAME
	MOVSI T1,(SIXBIT /TMP/)
	MOVEM T1,NAME+1
	SETZM NAME+2
	SETZM NAME+3
	HRLI T5,CIO.ST
	CHANIO T5,17	;SET MODE TO 17 TO PRESERVE BUFFERS
	HRLI T5,CIO.EN
	CHANIO T5,NAME	;ENTER IT
	JRST FIU
	HRLI T5,CIO.ST
	CHANIO T5,1	;BACK TO MODE 1
	POP P,T1
	POPJ P,

FNDOPR:	MOVSI T5,-17
FNDPC1:	CAMN T3,PRNMTB(T5)	;IS THIS THE PROCESSOR NUMBER?
	JRST	[MOVEI T3,COMNIT
		SUBI T5,17
		MOVNS T5
		POPJ P,]	;TO MAKE OLD STUFF WORK
	SKIPN PRNMTB(T5)	;IS THIS THE END?
	JRST NEWPRC		;YES, NEW ONE
	AOBJN T5,FNDPC1	;KEEP GOING
	OUTSTR [ASCIZ /TOO MANY PROCESSORS: /]
	JRST ERRCOM

NEWPRC:	MOVEM T3,PRNMTB(T5)
	SUBI T5,17
	MOVNS T5
	ADD IOPNT,[1,,0]	;ONE LESS NEST WE CAN HAVE
	JUMPGE IOPNT,NESTTD	;TOO MANY
	MOVEI T3,COMNIT
	JRST INITCH		;GO INITIALIZE
NONSTD:	AOBJP SVPT,TMNER	;NOT ENOUGH ROOM TO READ NAME
IFE 1,<
	PUSHJ P,SCAN
	CAIE C,":"
	JRST SYNERR	;GOT TO HAVE A COLON AFTER THE SWITCH
	PUSHJ P,GETNAM
>
IFN 1,<
	PUSHJ P,STARGS	;WORRY ABOUT ( AROUND ARGS
	TLNN FL,PARFLG	;WAS THERE A (?
	JRST [	CAIN C,":"	;NO, CHECK FOR :
		PUSHJ P,SCAN	;A :, SKIP OVER IT
		JRST .+1	]
	PUSHJ P,GETNAM	;GET A FILE NAME ETC
	PUSHJ P,FINPAR	;END OF ARGS
>
	AOS T1,NOSTNM	;ONE MORE NOW
	CAIL T1,NSDNM
	JRST TMSTD	;WE DON'T ALLOW THAT MANY
	MOVE C,SVNAM(SVPT)
	MOVEM C,NONSNM(T1)	;SAVE NAME
	MOVEM C,NSDSWS(T1)	;ALSO AS A SWITCH
	HLRZS C
	HRLM C,EXTAB+NPROCS(T1)	;EXTENSION
	MOVEM C,BNAM+NPROCS(T1)	;AND FILE NAME
	SKIPN C,SVDEV(SVPT)
	MOVSI C,(SIXBIT /DSK/)
	MOVEM C,NONSDV(T1)
	MOVE C,SVEXT(SVPT)
	MOVEM C,NONSXT(T1)
	MOVE C,SVPPN(SVPT)
	MOVEM C,NONSPN(T1)
	SUB SVPT,[1,,1]	;RESTORE
	AOS NPROC1	;ONE MORE
	MOVE T1,SWTAB3(T1)	;GET SWITCH
	JRST INTSW	;AND GO

NSLOD:	AOBJP SVPT,TMNER	;NEED ROOM
	PUSHJ P,STARGS		;LIKE NONSTD
	TLNN FL,PARFLG
	JRST	[CAIN C,":"
		PUSHJ P,SCAN
		JRST .+1]
	PUSHJ P,GETNAM
	PUSHJ P,FINPAR
	MOVE T1,SVNAM(SVPT)
	MOVEM T1,ALTLOD+1
	SKIPN T1,SVDEV(SVPT)
	MOVSI T1,'DSK'
	MOVEM T1,ALTLOD
	MOVE T1,SVEXT(SVPT)
	MOVEM T1,ALTLOD+2
	SETZM ALTLOD+3
	MOVE T1,SVPPN(SVPT)
	MOVEM T1,ALTLOD+4
	SUB SVPT,[1,,1]
	JRST SCAN	;FINISH UP AND SCAN AHEAD

FINPRS:	PUSHJ P,SCAN
FINPAR:	TLNN FL,PARFLG ;IS THE PAREN FLAG ON??
	POPJ P, ;NO, ARG NOT SURROUNDED BY ()
	CAIE C,")"	;SHOULD HAVE ENDED PROPERLY
	JRST SYNERR	;NO
	JRST SCAN	;YES, SCAN PAST IT

STARGS:	PUSHJ P,SCAN
	CAIN C,"("	;ARGS SURROUNDED BY PAREN??
	TLOA FL,PARFLG ;YES
	TLZA FL,PARFLG ;NO
	JRST SCAN	;SCAN PAST (
	POPJ P,

	DEFINE STDUSE<
X LOADER,LOD
X DIRIT,DIR
X LIST,LST
X CREF,CRF
X EDT,EDT
X PIP,PIP
X FCM,FCM
>

	DEFINE X(A,B)
<OUT'B:	SKIPE T5,B'USE
	JRST	[MOVEI T3,COMNIT	;STANDARD AND KNOWN
		JRST COMNIT]
	MOVEI T3,IDX'A+1
	PUSHJ P,FNDOPR
	MOVEM T5,B'USE
	JRST COMNIT

CHK'B:	SKIPN T5,B'USE
	POPJ P,
	JRST COMCHK
>

	STDUSE
;DATA STORAGE ASSIGNMENTS

PDP:	IOWD	PDL,PDLB		;INITIAL PDL POINTER

	DEFINE X(A,B)<INTEGER B'USE>
	STDUSE

INTEGER USRPPN,SWBKB,SWBKL,ONAM,OEXT,OPPN,OEXTP
INTEGER SAVPPN,SVSWP,PCNUM,SDAT,SAVCHR
INTEGER CORTOP,CORT1,NUMAT
INTEGER SVIND,SVPDL,JOBNAM,BROCNT,LODSP2,LODCT2,LODSP,LODCTR
INTEGER NAMCT,NAMPT,SVJBFF,ERRCNT,NMLSTP,DEFPPN

array accum[2]			;we may colloect two-word idents
ARRAY LODSBK,LODSB2[LODSCT/5+1]
ARRAY SWBKS,SVDEV,SVNAM,SVEXT,SVPPN[NFILE],NSDSWS[NSDNM]
ARRAY TTYBUF[^D100],LOOKBF,OPENB[3],PDLB[PDL+1],SWBLK[SWBK+1]
ARRAY ERRBUF[4],BUFTAB,FREBUF[NESTDP+2],IOPD[<NESTDP+2>*3+1]
ARRAY BUF[200],SVAC[20],SBUF[200],ALTRUN[6]
ARRAY TMPFIL[2],PCDEV[5],PRNMTB[17],NONSNM,NONSDV,NONSPN,NONSXT[NSDNM]
ARRAY LDBITS,LDPRV,NAMES1,NAMES2,PPNS,UFDS[NMLSTL+1]


DEFINE X(A,B,C,D,E,F)
<SIXBIT /B/>

INIDAT:	CODIT (RUNBLK,<EXP SIXBIT'SYS',0,0,0,0,0>)

	NAME=RUNBLK+1
	LNAM=RUNBLK+1
	LEXT=RUNBLK+2
	LDAT=RUNBLK+3
	LPPN=RUNBLK+4
	INILOW=RUNBLK

	CODIT (EXTAB,<PROCESS
	BLOCK NSDNM>)
 
; Field Test FORTRAN-10 has the same first parameter as standard
; FORTRAN-10 because this parameter is also the name of the TMPCOR
; file, and the field test compiler must be able to be the same as
; the standard compiler.  However IDXFTX must be defined as the correct
; index, so the below conditional code is necessary.
	DEFINE X(A,B,C,D,E,F)
<	<SIXBIT /   A/>
IFDIF /'B//FTX/ <IDX'A==%%X>
IFIDN /'B//FTX/ <IDXFTX==%%X>
%%X==%%X+1>
%%X==0
	CODIT (BNAM,<PROCESS
	REPEAT NSDNM,<X(NSD)>
	STDUSE>)

	CODIT(LOKNAM,<0
	0>)

	CODIT (NPROC1,NPROCS)

	CODIT (FCOMD,<ASCII /@***SVC.TMP
/
	BYTE (7) 177,177>)

	CODIT (FCOMD3,<ASCII /EXEC />)
	CODIT (FCOMD2,<ASCII /@***EDS.TMP
/
	BYTE (7) 177,177>)

	CODIT (CRFRDR,<ASCII /@***CRE.TMP
/
	BYTE (7) 177,177>)

	CODIT (NSDOPN,<EXP 1,SIXBIT /DSK/>)

	CODIT (INIT1,0)

	CODIT (HED,<IOWD 200,BUF
	0>)
	CODIT (SHED,<IOWD 200,SBUF
	0>)

CODIT (ERBFPT,<POINT 7,ERRBUF>)
	CODIT (EOFLAB,ALLDON)
	DEFINE X(A,B,C,D,E,F)
<<SIXBIT /E/>>
	CODIT (INTEXT,<PROCESS
	REPEAT NSDNM,<0>>)
	DEFINE X(A,B,C,D,E,F)
<<SIXBIT /D/>&777777000000>
	CODIT (NXPC,<PROCESS
	REPEAT NSDNM,<0>>)
INILEN==.-INIDAT
LOWTOP=RUNBLK-1

	Reloc	; 0
	Var				; All variables defined by #
	Reloc	; 400000

; Move these here so that the ARRAYs are defined before we try to use them

PCNAM=PCDEV+1
PCEXT=PCDEV+2
PCPPN=PCDEV+4

SVJFF==SVJBFF


	END	STPT
    	'Y