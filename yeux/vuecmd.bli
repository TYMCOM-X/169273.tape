module vuecmd = begin

!
!  Our own internal storage::
! (to be moved later?)
!

bind abbrevsize=1000, abbrevs=100;

own abbrevspace[AbbrevSize/5+2];
own abold[abbrevs],abosize[abbrevs];
own abnew[abbrevs],abnsize[abbrevs];
own abfreep,abssize,absp;
own
 	lpos,			! last known line position
	pcolumn;		! physical column on screen

!
!  The following symbols are define elsewhere:
!
external

	hptr, lowptr,		! pointer to "next" , "previous" char
	p, lowend,		! beginning, end  of the low buffer
	hbot, hend,		! beginning, end  of buffer after gap
	mark,			! location of the current mark

	radix,			! value of numeric argument radix
	repeat,			! repeat count for the command
	argmpy,			! value of argument multiplier
	argflg,			! if an argument is pending
	argbig, argstk,		! if a big argument given, sticky
	argdiv,			! if arg is to be divided first

	curline,		! current line on the screen
	curbuf,			! current buffer we are in
	scrsze,			! size of the screen in lines
	sst, rst,		! search string, replace string array
	allmod,			! buffer modified array
	muline,			! flag for multi-line change
	scrmod,			! flag for screen modified
	flush,			! flag for "input" flushed

	comchar,		! character value of the last command
	lasmov,			! flag for last was a move
	killer, laskil,		! "kill" flag for this,last command

	escvalue,		! the value of the <esc> key
	abortvalue,		! the value of the <abort> key
	indent, iudent,		! the left margin, right margin
	commentpos,		! place to put the comment
	abbrex,			! flag for expanded abbreviations
	spaces,			! flag for using spaces instead of tabs
	jstins, filins,		! flag for insert justifying, filling
	bsback,			! flag for handling count for backspaces
	sosmod,			! flag for ?L == page mark (page mode)
	tabsize,		! the size of a tab character (:= 8)
	tabwidth,		! the width of a tab (until tabstops)

	distbl,			! dispatch table pointer
	cnames,cfuncts,		! list of command names, functions
	pnames,plocs;		! list of environment variables, storage

!
!  External procedures::
!
external

	readch,			! read a character (tty, macro, file)
	readcc,			! read a command character (meta-etc)
	ttyidle,		! true if nothingx in input buffer
	writeloss,		! write a character handling ^ and $
	writestring,		! write a string using writeloss(s)
	putstr,			! put a string to the screen (as is)
	wrtsix,			! write a sixbit word as a string
	wrtnum,			! write a number as a string
	wrtoct,			! write a number as an octal string
	toPrompt,		! write a message on prompt line
	fromPrompt,		! reset prompt line pointer
	flubfr,			! flush the tty buffer
	clrKbf,			! clear kill buffer (BUFFER)

	munchline,		! print a prompt and read a response
	getnum,			! read a number (octal or decimal)
	symbol,			! read and find a function name

	ctrll,			! (WINDOW) clear and redraw window
	redisp,			! redisplay screen
	makbox,			! paint a box and it's contents
	clearscreen,		! clear the screen

	errstr,			! print message and abort (abort)
	zapmac,			! pop out of everything
	ttyzap,			! clear tty and finish up
	quit,			! quit the program - saving nothing

	moveforward,		! move n bytes forward in the buffer
	moveback,		! move n bytes backward in the buffer
	getchxr,		! get value of character at position n
	updatecursor,		! calculate new position given old+char
	getpos,			! get the current position on the line
	therep,			! true if at matchstring location

	insertchar,		! insert a character into the buffer
	killforward,		! kill a byte forward in the buffer
	delforward,		! delete a byte forward in the buffer
	delbackward,		! delete a byte backward in the buffer

	abbtype,		! true if char is abbreviation terminator
	jsttype,		! returns type of text character 0-6
	eolBreak,		! true if char is end-of-line char
	whtBreak,		! true if char is horiz whitespace
	fmtBreak,		! true if char is pub/scribe ".@" fmt
	whitespace,		! true if char is whitespace
	apbreak,		! true if point is after paragraph break
	wbreak,			! true if char is alpha-numeric

	getIndent,		! get the indentation for this line
	setIndent,		! set the indentation for this line
	just,			! text justification with margins

	ctrln2,			! move down to next line start
	ctrlp2;			! move back to previous line start

!
!  General ABORT functions::
!

global routine abortC =			! USER ABORT
    errstr(plit asciz'Quoi??????');


global routine ctrlc = begin		! EXIT QUIT
    ttyzap();				! zap the tty stuff
    quit()				!  and exit to the exec
end;


!
!  Argument handling routines::
!  Repeat count and numeric input.
!

Global routine BigArg = begin		! set huge argument for next

    argbig_ 1;				! set big argument flag
    argstk_ 1;				! set sticky arg for <repeat>
    repeat_ #377777777777;		! very big positive arg
    toPrompt(plit asciz 'Arg: [inf]');	! let the user know!!!
    argflg_ 1				! set flag for argument

end;


Global routine NumArg = begin		! read numeric argument digit

    if .argbig				! if <esc><esc> sticky big set
     then repeat_ 0;			!  then reset repeat count
    argbig_ 0;				! clear big sticky flag

    if .argdiv				! if first time since C-U
     then repeat_ 0;			!  then reset for number
    argdiv_ 0;				! clear divide flag

    repeat_ (.repeat * .radix) +	! multiply by the radix
	((.comchar and #177) - "0");	!  and add in the digit

    If ttyIdle()			! if he's typing fast
     then begin				!  don't do this
	toPrompt(plit asciz 'Arg: ');	! put info in prompt line
	wrtnum(.repeat)			!  .. with current value
     end;

    argflg_ 1				! set flag for argument
end;



Global routine SetArg = begin

    repeat_ .repeat * .argmpy;		! multiply repeat count
    argdiv_ 1;				! set flag for divide

    If ttyIdle()			! if he's typing fast
     then begin				!  don't do this
	toPrompt(plit asciz 'Arg: ');	! put info in prompt line
	wrtnum(.repeat)			!  .. with current value
     end;

    argflg_ 1				! set flag for argument

end;

!
!  Movement inside the buffer::
!

global routine ctrlf =			! MOVE FORWARD CHARACTER
    if .hend neq .hbot			! if not at end of buffer
     then moveforward(1)		!  then move
     else return zapmac();		!  else bomb-out


global routine metaf = begin		! MOVE FORWARD WORD
    while .hend neq .hbot		! while not at end of buffer
     do if whitespace(scann(hptr))	!   and inside whitespace
	 then moveforward(1)		!   then move past whitespace
	 else exitloop;			!   else continue
    while .hend neq .hbot		! while not at end of buffer
     do if wbreak(moveforward(1))	!   move forward until
	 then return;			!   a whitebreak, then return
    return zapmac()			! if reach end then bomb-out
end;


global routine ctrlb =			! MOVE BACK CHARACTER
    if .lowend gtr 1			! if not at beginning of buffer
     then moveback(1)			!  then backup
     else return zapmac();		!  else bomb-out

global routine metab = begin		! MOVE BACK WORD
    while .lowend gtr 1			! if not at beginning of buffer
     do if whitespace(scann(lowptr))	!   and inside whitespace
	 then moveback(1)		!   then backup past whitespace
	 else exitloop;			!   else continue
    while .lowend gtr 1			! if not at beginning of buffer
     do begin				!  then backup
	moveback(1);			!    until whitespace
	if wbreak(scann(lowptr))	!    and return
	 then return
     end;
    return zapmac()			! if hit beginning then bomb-out
end;

!
!  Larger movement -- Line, Page, Text
!

Global routine BegLin =			! MOVE TO BEGINNING OF LINE
    while .lowend gtr 1			! while not at beginning of buffer
     do if eolBreak(scann(lowptr))	!  do  moveback
	 then return			!  until previous characer is
	 else moveback(1);		!  an end of line character

Global routine EndLin =			! MOVE TO END OF LINE
    while .hend neq .hbot		! while not at end of buffer
     do if eolBreak(scann(hptr))	!  do moveforward
	 then return			!  until next character is
	 else moveforward(1);		!  an end of line character


Global routine BegPag = begin		! MOVE TO BEGINNING OF PAGE
    while .lowend gtr 1			! while not at beginning of buffer
     do if scann(lowptr) eql "?L"	! do if previous is a page mark
	 then exitloop			!  then done
	 else moveback(1);		!  else backup one
    muline_1;				! mark multi-line change
    scrmod_1;				! mark screen modified
    curline_1				! current line is top of page
end;

Global routine EndPag = begin		! MOVE TO END OF PAGE
    while .hend neq .hbot		! while not at end of buffer
      do if scann(hptr) eql "?L"	! do if next is page mark
	  then exitloop			!   then done
	  else moveforward(1);		!   else move to next
    muline_1;				! mark multi-line change
    scrmod_1;				! mark screen modified
    if .curline gtr .scrsze		! if current line not on the screen
     then curline_.scrsze-1		!  then set it near the bottom
end;


global routine BegTxt = begin		! MOVE TO BEGINNING OF TEXT
    moveback (.lowend-1);		! backup to before first char
    muline_1;				! mark multi-line change
    scrmod_1;				! mark screen modified
    curline_1				! set current line to top
end;

global routine EndTxt = begin		! MOVE TO END OF TEXT
    moveforward (.hend-.hbot);		! move each character until end
    muline_1;				! mark multi-line change
    scrmod_1;				! mark screen modified
    if .curline gtr .scrsze		! if current line not on the screen
     then curline_.scrsze-1		!  then set it near the bottom
end;

!
!  Movement up and down by text lines
!

global routine ctrln = begin local pos;
    if not .lasmov then GetPos(pcolumn);
    incr i from 1 to .repeat do ctrln2();
    pos_1;
    incr i from 1 to .pcolumn-1
     do if .pos geq .pcolumn or eolBreak(scann(hptr))
	 then exitloop
	 else begin
	    pos _ updatecursor(scann(hptr),.pos);
	    ctrlf()
	 end;
    repeat_ 1
end;


global routine ctrlp = begin local pos;
    if not .lasmov then GetPos(pcolumn);
    incr i from 1 to .repeat do ctrlp2();
    pos_1;
    incr i from 1 to .pcolumn-1 do
	if .pos geq .pcolumn or eolBreak(scann(hptr))
	 then exitloop
	 else begin
	    pos _ updatecursor(scann(hptr),.pos);
	    ctrlf()
	 end;
    repeat_ 1
end;

Global routine PrevVC =			! MOVE TO PREVIOUS VISIBLE CHARACTERA
    while .lowend gtr 1			! while not at beginning of buffer
     do if whitespace(scann(lowptr))	! if previous character is whitespace
	 then moveback(1);		!  then move past it.

Global routine NextVC =			! MOVE TO NEXT VISIBLE CHARACTER
    while .hend neq .hbot		! while not at end of buffer
     do if whitespace(scann(hptr))	! if next character is whitespace
	 then moveforward(1);		!  then move past it.

Global routine BegPar = begin		! MOVE TO BEGINNING OF PARAGRAPH
    until apbreak(.lowend)		! while not after paragraph break
     do ctrlp2();			!  backup a line
    if fmtBreak(scann(hptr))		! if this is a format line
     then ctrln2();			!  then move down one line
    NextVC()				! find next visible character
end;

Global routine EndPar = begin		! MOVE TO END OF PARAGRAPH
    do ctrln2() until
	apbreak(.lowend) or
	eolBreak(scann(hptr)) or
	.hend eql .hbot;
    if .hbot lss .hend
     then ctrlp2();
    EndLin()
end;

routine uponepar = begin
    local blanksw,omark;

    blanksw _ 0;
    while .lowend gtr 1
     do begin
	if fmtBreak(scann(hptr))
	 then ctrlp2()
	 else begin
	    if eolBreak(scann(hptr)) eql 0
	     then return EndLin();
	    if .blanksw eql 1
	     then return moveforward(.omark-.lowend);
	    blanksw _ 1;
	    do ctrlp2() while
	     eolBreak(scann(hptr)) and .lowend gtr 1;
	    if fmtBreak(scann(hptr)) eql 0
	     then return EndLin();
	    EndLin();
	    omark _ .lowend;
	    ctrlp2()
	 end
     end
end;

global routine metalb = begin		! MOVE UP PARAGRAPH BREAK
    local temp,atleft,breakleft,comleft;

    if .lowend eql 1
     then return
     else if .lowend eql 2
	   then return moveback(1);

    atleft _ 0;		!cursor at first printing char of line ?
    while 1
     do begin
	temp_ moveback(1);
	if eolbreak( .temp )
	 then begin
	    atleft _ 1;
	    moveforward(1);
	    exitloop
	 end
	 else if .lowend eql 1 or
		  not whtbreak(.temp)
	       then exitloop
     end;

    BegLin();				! start on a paragraph break?
    breakleft _ apbreak(.lowend);

    comleft _ fmtBreak(scann(hptr));	! start on a Scribe command ?

    if .atleft eql 0			! inside a line?
     then
	if .comleft eql 0
         then return(BegPar())
	 else begin
	    do ctrlp2() while
	        fmtBreak(scann(hptr))
		 and .lowend gtr 1;
	    if eolBreak(scann(hptr))
	     then begin
		ctrln2();
		return(NextVC())
	     end
	     else return(EndLin())
	 end;
    if .breakleft eql 0			! inside a paragraph?
     then begin
	ctrlp2();
	if fmtBreak(scann(hptr)) eql 0
	 then return(BegPar())
	 else return(uponepar())
     end;
    if .comleft eql 0
     then begin
	ctrlp2();
	return(uponepar())
     end;
    ctrlp2();
    if fmtBreak(scann(hptr)) or
       eolBreak(scann(hptr))
     then return(uponepar())
     else return(EndLin())
end;

routine downonepar = begin
    local blanksw,omark;

    blanksw _ eolBreak(scann(hptr));
    while 1
     do begin
	ctrln2();
	if .hend eql .hbot
	 then return
	 else
	    if eolBreak(scann(hptr))
	     then
		if .blanksw eql 2
		 then return(moveback(.lowend-.omark))
		 else
		    if .blanksw eql 0
		     then blanksw_ 1
		     else 0
	     else
		if fmtBreak(scann(hptr)) eql 0
		 then return(NextVC())
		 else
		    if .blanksw eql 1
		     then begin
			omark_ .lowend;
			blanksw_ 2
		     end
     end
end;

global routine metarb = begin		! MOVE DOWN PARAGRAPH BREAK
    local opos,editp;

    opos _ .lowend;
    BegLin();
    while eolBreak(scann(hptr)) and
	  .hbot lss .hend
     do ctrln2();

    editp _ fmtBreak(scann(hptr));
    EndLin();

    if .lowend gtr .opos		! not at line end ?
     then
	if .editp eql 0
	 then return(EndPar())
	 else begin
	    BegLin();
	    while fmtBreak(scann(hptr)) and
		  .hend neq .hbot
	     do ctrln2();
	    if .hend eql .hbot
	     then return EndLin()
	     else
		if eolBreak(scann(hptr))
		 then begin
		    ctrlp2();
		    return EndLin()
		 end
		 else return NextVC()
     end;
    ctrln2();
    if apbreak(.lowend) or
       eolBreak(scann(hptr))
     then downonepar()
     else EndPar()
end;

Global routine Lastpage = begin		! MOVE TO TOP OF PREVIOUS PAGE
    local c;

    c_.lowend;				! save point (don't move)
    While .c gtr 1
     do begin
	c_.c-1;
	If getchxr(.c) eql "?L"
	 then exitloop			! Backup past ^L
     end;
    If getchxr(.c) neq "?L"
     then return abortC();		! If none "Error"
    While .c gtr 1
    do begin
	if getchxr(.c-1) eql "?L"
	 then exitloop;			! Backup to next ^L
	c_.c-1				!  or beginning.
     end;
    If .c neq .lowend
     then begin				! See if we moved.
	moveback(.lowend-.c);		!  and do the work!
	curline_1;
	scrmod_1;
	muline_1
     end
end;


Global routine Nextpage = begin		! MOVE TO TOP OF NEXT PAGE
    local cnt,pnt;

    cnt_ 0;				! initialize count
    pnt_ .hptr;				! copy pointer
    incr i from 1 to .hend-.hbot	! for each character past point
     do begin
	cnt_ .cnt+1;			!  increment counter
	if scann(pnt) eql "?L"		!  if next character is a page mark
	 then exitloop			!   then done
	 else incp(pnt)			!   else bump pointer
     end;
    if .cnt gtr 0			! if we found a page mark
     then begin
	moveforward(.cnt);		! then move forward past it
	muline_ 1;			!  mark multi-line change
	scrmod_ 1;			!  mark screen modified
	curline_ 1			!  set current line to top
    end
    else return abortC()		! else complain.
end;

global routine ctrlv = begin		! MOVE FORWARD WINDOW/SCREEN
    incr i from 1 to .scrsze-.curline	! Move down from point to end
     do if ctrln2() or .hend eql .hbot	!  of screen searching for
	 then exitloop;			!  end of page, if found exitloop
    if .hend neq .hbot			! If not at EOF
     then curline_1;			!  then set current line = 1
    muline_1;				! Mark multi-line change
    scrmod_1				! Mark screen modified
end;

global routine metav = begin		! MOVE BACKWARD WINDOW/SCREEN
    incr i from 1 to .scrsze+.curline-2	! Move up size of screen + line
     do if ctrlp2() or .lowend eql 1	! if at end of page or beg of buf
	 then if .curline leq 0		!  then
	       then begin		!    if past top of screen?
		   ctrln2();		!     then show predecessor.
		   exitloop		!      and stop
	       end;
    curline_1;				! Mark cursor in line 1
    muline_1;				! Mark multi-line change
    scrmod_1				! Mark screen modified
end;

global routine metacn =			! MOVE TO END OF WINDOW
    incr i from 1 to .scrsze-.curline	! for the remaining line count
     do if ctrln2()			! do move-down-one-line
	 then begin			!  checking for end of page
	    moveback(1);		!  backup over the page mark
	    curline_ .lpos;		!  reset line to last known
	    exitloop			! finished
	 end
	 else lpos_ .curline;		! remembering the last line


global routine metacp =			! MOVE TO START OF WINDOW
    incr i from 1 to .curline		! for each line position
     do ctrlp2();			! move up one line

!
!  MARK related commands::
!

global routine NoMark =			! COMPLAIN ABOUT MARK
    errstr(plit asciz'Mark not set.');


global routine ClrMrk = begin		! CLEAR MARK
    repeat_1;				! reset any repeat count
    mark_0;				! clear the mark
    ToPrompt(plit asciz 'Mark cleared')	! and print a message
end;


global routine SetMrk =			! SET MARK
    if .repeat eql 1			! if no repeat count
     then begin				! then continue
	mark_.lowend;			!  set the mark to point
	ToPrompt(plit asciz 'Mark set')	!  and print a message
    end
    else ClrMrk();			! else clear mark


global routine ExcMrk =			! EXCHANGE MARK AND POINT
    begin local tmark;

    if .mark eql 0			! if no mark set, then abort
     then return NoMark();
    if .mark eql .lowend		! if mark eql point
     then return .mark;			!   then return point
    tmark_.lowend;			! save the point
    if .mark gtr .lowend+.hend-.hbot	! if mark tooe
     then return EndTxt();		!   then move to end
    if .mark lss .lowend		! if mark before point
     then moveback (.lowend-.mark)	!   then backup
     else moveforward (.mark-.lowend);	!   else go forward
    return (mark_.tmark)		! return old point
end;


!
!  More movement -- uses fake mark
!

global routine ctrlz = begin		! MOVE WINDOW DOWN
    local omark,ocurline;

    omark_.mark;			! save mark
    ocurline_.curline;			! save line
    mark_.lowend;			! mark = point
    metacp();				! move to top of screen
    incr i from 1 to .repeat		! for each count
     do ctrln2();			!  move down a buffer line
    curline_1;				! mark current line = 1
    if .ocurline-.repeat gtr 0		! if old-line is on screen
     then ExcMrk();			!  then exchange positions
    mark_.omark;			! restore mark
    muline_1;				! mark multi-line change
    scrmod_1				! mark screen modified
end;



global routine metaz = begin		! MOVE WINDOW UP
    local omark,ocurline;

    omark_.mark;			! save mark
    ocurline_.curline;			! save current line
    mark_.lowend;			! set mark = point
    metacp();				! move to bottom of screen
    incr i from 1 to .repeat		! backup repeat-count lines
     do ctrlp2();			! from the bottom
    curline_1;				! set current line at top
    if .ocurline+.repeat leq .scrsze	! if old-line on screen
     then ExcMrk();			!  then exchange positions
    mark_.omark;			! restore mark
    muline_1;				! mark multi-line change
    scrmod_1				! mark screen modified
end;

!
!  Text Inserting::
!

global routine abinit = begin		! INITIALIZE ABBREV SPACE
    abssize_0;
    absp_0;
    abfreep_(abbrevspace)<36,7>
end;


global routine abspace = begin		! check for abbreviation expansion
    local tp,bp;

    incr i from 0 to .absp-1
     do begin				! once per abbrev.
	if .abosize[.i] eql 0		! if no size,  try next one
	 then exitcompound;

	if (bp_.lowend-.abosize[.i]-1) lss 0
	 then exitcompount;		! if no room in buffer, try next

	if wbreak(getchxr(.bp))		! must be preceeded by break
	 then exitcompound;		! else try next one

	tp_.abold[.i];			! point to abbreviation
	incr j from 1 to .abosize[.i]	! for each character - compare
	 do if scani(tp) neq getchxr(.bp+.j)
	     then exitcompound;		! if no match, try next one

	incr j from 1 to .abosize[.i]	! For size of old string
	 do delbackward();		! delete it
	tp_.abnew[.i];			! reset pointer
	incr j from 1 to .abnsize[.i]	! For size of new string
	 do insertchar(scani(tp));	! insert it

	return				! done.
    end;
    return -1				! not found
end;

Global Routine myspace = begin
    local cpos;

    if (.hend neq .hbot) and		! if inside buffer and
	not eolBreak(scann(hptr))	!    not at eol
     then return;			!  then do nothing

    BegLin();				! else go to line start
    cpos_1;				! set position to 1
    while (.hend neq .hbot) and		! count to end-of line
	  not eolBreak(scann(hptr))
     do begin
	cpos_ if .bsback and		!  possibly treating
		 "?H" eql scann(hptr)	!  backspace as special
		then if .cpos gtr 1	!    (if not first char)
			then .cpos - 1 else .cpos
		else updatecursor(scann(hptr),.cpos);
	moveforward(1)			! one character at a time.
     end;

    if .cpos leq .iudent then return;	! if cpos leq right-margin

    while (.lowend gtr 1) and		! delete trailing white
	  whitespace(scann(lowptr))	! at the end of line
     do delbackward();

    while (.lowend gtr 1) and 		! backup over non-white
	  not whitespace(scann(lowptr))	! until next break
     do moveback(1);

    while (.lowend gtr 1) and		! delete this whitespace
	  whitespace(scann(lowptr))	! back to next non-white
     do delbackward();

    insertchar("?M");			! insert a CR
    setIndent(.indent);			! indent by proper amount 
    EndLin()				! and skip to eol

end;


Global routine SelfI = Begin		! SELF INSERT
    Own TChar,Char;			! Need these across calls
    Bind Spc = 4, Csp = 5;		! Define types from justify code

    Char_ .comchar and #177;		! can only insert ascii?
    If .AbbrEx				! if expanding abbreviations
     then If AbbType(.char)		!  then if abbrev-terminator
	   then abspace();		!        then attempt expansion
    If .JstIns				! if justifying inserts
     then begin				!  then
	TChar_ JstType(.char);		!   get text type
	If .Tchar eql Spc or		!   if a space
	   .Tchar eql CSp		!   or convert to a space
	 then myspace();		!    then do justification
	If .Tchar eql CSp		!   if convert to space
	 then char_ " "			!    then change it to space
      end;
    InsertChar(.char)			! insert the given character
end;

global routine ctrlq = begin		! QUOTE CHARACTER INSERT
    comchar_ readch();			! read a character
    incr i from 1 to .repeat		! for each rep-count
     do insertchar(.comchar);		! insert the character directly
    repeat_ 1				! fixup repeat and return
end;

global routine ctrlo  = begin		! OPEN WHITE LINE
    insertchar("?M");			! insert eol
    moveback(1)				! and backup over it
end;

!
!  Make room for abbreviation code, find and define::
!

routine findab( abbr ) = begin	! FIND AN ABBREV
    local tp;

    incr i from 0 to .absp-1		! for each abbreviation
     do begin

	if ..abbr neq .abosize[.i]	! if the size doesn't match
	 then exitcompound;		!  then try next one

	tp_.abold[.i];			! setup pointer

	incr j from 1 to .abosize[.i]	! see if it matches
	 do if scani(tp) neq .((.abbr)[.j])
	     then exitcompound;		! if not, then try next

	return .i			! got one, so return it
     end;
    return -1				! not found
end;


global routine abdefine = begin
    local tp,tc,line[132];

    if .repeat neq 1
     then begin
	repeat_1;
	return abinit()
     end;

    if .absp geq abbrevs
     then return errstr(plit asciz'Too many abbreviations.');

    munchline(line,plit asciz'Abbreviation <esc>: ',.EscValue);
    tp_findab(line);
    if .tp neq -1
     then abosize[.tp]_0;		! delete any existing abbrev
    tp_.abfreep;			! first free byte.
    abold[.absp]_.tp;			! remember it.
    incr k from 1 to .line		! read in the data.
     do begin
	replacei(tp,.line[.k]);		! copy user response
	if .abssize geq abbrevsize
	 then return errstr(plit asciz'Too many chars in abbreviations');
	abssize_.abssize+1
     end;
    abosize[.absp]_.line;		! set the count.
    munchline(line,plit asciz' will be expanded to <esc>: ',.EscValue);
    abnew[.absp]_.tp;			! and again do so.
    incr k from 1 to .line
     do begin
	replacei(tp,.line[.k]);
	if .abssize geq abbrevsize
	 then return errstr(plit asciz'Too many chars in abbreviations');
	abssize_.abssize+1
     end;
    abnsize[.absp]_.line;
    abfreep_.tp;
    absp_.absp+1
end;

!
!  Search movement::
!

global routine ctrlr = begin		! REVERSE STRING SEARCH

    if not munchline (sst,plit asciz'Reverse Search: ',.EscValue)
     then return errstr(plit asciz'Reverse Search aborted.');

    decr i from .lowend-.sst[0] to 1
     do if therep(sst,.i)
	 then begin
	    moveback(.lowend-.i);
	    if .repeat eql 1
	     then return
	     else repeat_ .repeat-1
	 end;

    return errstr(plit asciz'Reverse Search Failed')

end;

global routine ctrls = begin

    if not munchline (sst,plit asciz'Search: ',.EscValue)
     then return errstr(plit asciz'Search aborted.');

    incr i from .lowend to .lowend+.hend-.hbot-.sst+1
     do if therep (sst,.i)
	 then begin
	    moveforward(.i+.sst[0]-.lowend);
	    if .repeat eql 1
	     then return
	     else repeat_ .repeat-1
	end;

    return errstr(plit asciz'Search failed')

end;

routine genreplace (query) = begin
    local answer,i,char,tp;

    sst_0;				! reset search string
    if not munchline (sst,plit asciz'Old String: ',.EscValue)
     then return abortC();
    if .sst leq 0
     then return abortC();

    rst_0;				! reset replace string
    if not munchline (rst,plit asciz'New String: ',.EscValue)
     then return abortC();

    i_.lowend;
    while .i leq .lowend+.hend-.hbot-.sst+1
     do begin				! for each past pointer
       if therep(sst,.i)		! if at a match
        then begin
	    moveforward (.i+.sst[0]-.lowend);	! move past it

	    if .query			! if query mode
	     then begin
		scrmod_1;		! mark screen modified
		muline_1;		! mark multi-line
		redisp(1);		! do the redisplay
		answer_readch()		! read an answer
	     end
	     else answer_"!";		! else set query to finish

	    if .answer eql "??"		! if user wants help
	     then begin
		clearscreen();		! clear screen first
		putstr( plit asciz '
?J.:        Change this one and stop.
?J<space>:  Change this one.
?J<escape>: No change - exit replace mode.
?J<abort>:  No change - exit replace mode.
?J!:        Change this one and all the rest.
?J<anything else>: No change - continue.
?J
?J Type anything to re-enter query replace mode--' );
		tp_readch();		! wait for response
		ctrll();		! clear screen and repaint
		redisp(1);		! redisplay
		answer_readch()		! prompt again
	     end;

	    if .answer eql .AbortValue	! abort?
	     then exitloop;		!  then done.
	    if .answer eql .EscValue	! escape?
	     then exitloop;		!  then done.

	    if .answer eql "!"		! finish all?
	     then query_0;		!  then clear query flag

	    if .answer eql "." or	! if this
	       .answer eql  "!" or	!  or finish
	       .answer eql " "		!  or continue
	     then begin
	      incr j from 1 to .sst	!  then delete string
	       do delbackward();	!    that we matched
	      incr j from 1 to .rst	!    and replace it
	       do insertchar(.rst[.j]);	!    with new string.
	      i_.i+.rst-1;		!    bump index pointer
	      if .query			!    if still query
	       then redisp(1)		!     then show change
	     end;

	    if .answer eql "."		! if "."
	     then return		!  then done.
	 end;

	i_.i+1				! increment buffer pointer
       end;
    ToPrompt( If .Query
	   then plit asciz'Finished with Query Replace'
	   else plit asciz'Finished with Replace'  );
    return
end;


global routine metaq = genreplace( 1 );
global routine metar = genreplace( 0 );

!
!  Text deletion and killing::
!

global routine ctrld =			! DELETE FORWARD CHARACTER
    if .hbot neq .hend			! if not at end of buffer
     then killforward(0)		!   then delete a character
     else return zapmac();		!   else bomb-out


global routine metad =  begin		! DELETE FORWARD WORD
    while .hend neq .hbot		! while not at end of buffer
     do if whitespace(scann(hptr))	!   and inside whitespace
	 then killforward(0)		!   then move past whitespace
	 else exitloop;			!   else continue
    while .hend neq .hbot		! while not at end of buffer
     do begin				!  then delete forward
	killforward(0);			!   until whitespace is
	if wbreak(scann(hptr))		!   found, then return
	 then return
     end;
    return zapmac()			! if reach end then bomb-out
end;


global routine rubout =			! DELETE BACKWARD CHARACTER
    if .lowend gtr 1			! if not at beginning of buffer
     then delbackward()			!  then rubout a character
     else zapmac();			!  else bomb-out

global routine metadel = begin		! DELETE BACKWARD WORD
    while .lowend gtr 1			! while not at beginning of buffer
     do if whitespace(scann(lowptr))	! and inside whitespace
	 then delbackward()		!   then rubout characters
	 else exitloop;			!   else continue
    while .lowend gtr 1			! while not at beginning of buffer
     do begin				!  then rubout characters
	delbackward();			!  until we reach whitespace
	if wbreak(scann(lowptr))	!    then return
	 then return
     end;
    return zapmac()			! if we hit the beginning bomb-out
end;

routine killtext(killflag) = begin
    local n,tp;

    if .mark eql 0			! if no mark
     then return NoMark();		!  then complain bitterly
    if .lowend gtr .mark		! if <point> is past mark
     then ExcMrk();			!  then swap
    if (not .laskil)			! if a "new" kill
     then clrkbf();			!  then clear buffer
    killer_ 1;				! tell command loop about kill
    n_.mark-.lowend;			! calculate length
    toPrompt( ( if .killflag		! tell what we're doing
		 then plit asciz ' ..Deleting...'
		 else plit asciz ' ..Copying...') );
    flubfr();				! flush it to the terminal

    incr i from 1 to .n			! for each character
     do begin
	register ch;			! hold the character
	if .hbot eql .hend		! pre-mature end of buffer?
	 then exitloop;			!  yes - exitloop
	ch_ scann(hptr);		! get the character
	killforward(1);			! kill it
	if (not .killflag)		! if we didn't want to
	 then insertchar(.ch);		!  then put it back
    end;

    Writestring(plit asciz 'done!');	! tell the user we're done
    mark _ 0
end;

global routine ctrlw = killtext(1);

global routine metcw = killtext(0);

global routine metaw = begin		! KILL TO SEARCH STRING
    local loc;

    loc_ .lowend;			! remember our point
    if .repeat neq 1			! if no argument
     then ctrls()			!  then search forward
     else ctrlr();			!  else backward
    if .lowend neq .loc			! if we moved
     then begin				!  then we have something
	mark_ .loc;			!  so, set the mark
	ctrlw()				!  and delete the text
     end
end;					! if not, leave mark intact


global routine metak = begin		! DELETE HORIZONTAL WHITESPACE
    if .hend eql .hbot			! if at end of the buffer
     then return zapmac();		!  then bomb-out
    while .hend neq .hbot and		! while not at end of buffer
	  whtBreak(scann(hptr))		! and inside whitespace
     do delforward();			!  delete forward
    scrmod_ 1				! mark screen modified
end;


global routine ctrlk  = begin		! KILL LINE or EOL
    killer _ 1;				! mark this as a kill
    if (not .laskil)			! if this is a "new" kill
     then clrkbf();			!  then clear the buffer
    incr i from 1 to .repeat		! for each "kill line"
     do begin
	register cc;			! use this to hold characters
	if .hend eql .hbot		! premature end of buffer?
	 then return zapmac();		!  yes, pop out of this
	cc_ scann(hptr);		! prime the loop
	if .cc eql #15			! if blank line
	 then killforward(1)		!  then kill it
	 else until .cc eql #15		! until end of line
	  do begin
	    if .cc eql #14 and .sosmod	! if end of page
	     then return zapmac();	!  then done
	    killforward(1);		! else kill character
	    if .hend eql .hbot		! if premature end of buffer
	     then return zapmac();	!  then done
	    cc _ scann(hptr)		! - get character -
	  end
     end;
    repeat_ 1				! reset count, we're done
end;

global routine killmultiline = begin	! KILL MULTIPLE LINES or EOLs
    if .repeat eql 1			! if single kill
     then return ctrlk();		!  then handle it elsewhere
    killer _ 1;				! mark this as a kill
    if (not .laskil)			! if this is a "new" kill
     then clrkbf();			!  then clear the kill buffer
    incr i from 1 to .repeat		! for each "kill line" command
     do begin
	register cc;			! use this to hold characters
	if .hend eql .hbot		! if pre-mature end of buffer
	 then return zapmac();		!  then we are done
	cc_ scann(hptr);		! character to prime the loop
	until .cc eql #15		! until end of line
	 do begin			
	    if .cc eql #14 and .sosmod	! if end of page
	     then return zapmac();	!  then done
	    killforward(1);		! else kill it
	    if .hend eql .hbot		! if pre-mature end of buffer
	     then return zapmac();	!  then done
	    cc _ scann(hptr)		! - get character -
	 end;
	 killforward(1)			! finish the line
     end;
    repeat_ 1				! reset count, we're done
end;

!
!  Text modification -- swapping
!

global routine ctrlt = begin		! TRANSPOSE CHARACTERS
    local ch;

    if .lowend lss 3			! if nothing to do
     then return abortC();		!  complain to the user
    lpos_ .curline;			! save current line;
    ch_ moveback(1);			! backup between characters
    if eolBreak( copynn(hptr,lowptr) )	! overwrite it with next
     then muline_1;			!  and check for eol char
    if eolBreak( replacen(hptr,.ch) )	! replace next with previous
     then muline_1;			!  and check for eol char
    moveforward(1);			! put cursor back
    curline_ .lpos;			! put line position back
    allmod[.curbuf]_1;			! mark buffer modified
    scrmod_ 1				! mark screen modified
end;


!
!  Set right and left margins
!

routine lftrgtpos = begin
    local lowsave, linpos, char;
    linpos_ .repeat;
    repeat_ 1;
    if .linpos leq 1
     then begin
	lowsave_ .lowend;
	BegLin();
	if .lowend eql .lowsave
	 then return 1;
	linpos_ 1;
	char_ scann(hptr);
	incr i from .lowend to .lowsave-1
	 do begin
	    if .bsback and .char eql "?H"
	     then linpos_ if .linpos gtr 1
			 then .linpos - 1
			 else .linpos
	     else linpos_ updatecursor(.char,.linpos);
	    char_ moveforward(1)
	 end
     end;
    return .linpos
end;


Global routine SetLft = indent_ lftrgtpos() - 1;
Global routine SetRgt = iudent_ lftrgtpos();

routine NoJust =
    errstr(plit asciz 'Nothing to Justify');


global routine metaj = begin
	local leftmar,rightmar,topara;

	if .lowend eql 1 and (.hend-.hbot eql 0)
	 then return NoJust();

	leftmar_ (if .indent geq 0 then .indent else 0);
	rightmar_ (if .repeat gtr 1 then .repeat else .iudent);
	repeat_ 1;

	topara _ .lowend;
	BegPar();
	if apbreak(.lowend) and .lowend gtr .topara
	 then begin
	    moveback(.lowend-.topara);
	    return NoJust()
	 end;
	if eolBreak(scann(hptr))
	 then begin
	    moveforward(.topara-.lowend);
	    return NoJust()
	 end;

	just(.leftmar,.rightmar);

	if .hend - .hbot eql 1
	 then
	    if eolBreak(scann(hptr))
	     then moveforward(1);
	muline _ 1;
	scrmod _ 1
	end;

global routine ctrlar = begin		! INVERT CASE CHARACTER
    local char;

    if .hend eql .hbot			! if at end of buffer
     then return zapmac();		!  then bomb-out

    char_ scann(hptr);			! copy current character

    if .char geq "a" and .char leq "z"	! if it's lower case
     then replacen(hptr,.char-32)	!   then make it upper
    else
     if .char geq "A" and .char leq "Z"	! if it's upper case
      then replacen(hptr,.char+32);	!   then make it lower

    if .char neq scann(hptr)		! if the character changed
     then begin				!  then
	allmod[.curbuf]_1;		!   mark the buffer modified
	scrmod_ 1			!   and the screen modified
     end;

    moveforward(1)			! pass the character
end;

global routine metaar = begin		! INVERT CASE WORD
    while .hend neq .hbot		! while not at end of buffer
     do if whitespace(scann(hptr))	! and inside whitespace
	 then moveforward(1)		!   then move past whitespace
	 else exitloop;			!   else continue

    while .hend neq .hbot		! while not at end of buffer
     do begin
	ctrlar();			! invert case character
	if wbreak(scann(hptr))		! until whitespace or break
	 then return			!  then return
     end;
    return zapmac()			! if at end then bomb-out
end;


global routine metcar = begin		! INVERT CASE REGION
    if .mark eql 0			! if no region setup, complain
     then return NoMark();
    if .mark leq .lowend		! if point after mark
     then ExcMrk();			!  then exchange
    incr i from .lowend to .mark-1	! invert case of each
     do ctrlar();			!  character until mark
    mark_0				! clear the mark
end;

!
!  Indenting routines
!

Global Routine ctrlj = begin		! INDENT NEXT TO MARGIN
    local lindent;

    lindent_ GetIndent( 0 );		! get line indentation
    EndLin();				! move to end of line
    insertchar("?M");			! insert a CR
    SetIndent( .lindent )		! insert the correct spacing

end;


Global Routine untabline = begin	! UNINDENT LINE
    SetIndent(GetIndent(1)-.tabwidth);	! indent - 1 tabwidth
    EndLin()				! wait at end of line
end;


Global Routine toleft = begin		! UNINDENT REGION
    if .mark eql 0 then			! if no region is declared
     return NoMark();			!  then complain

    BegLin();				! else move to beginning of line
    ExcMrk();				! swap places with mark
    BegLin();				! move to beginning of line

    if .mark gtr .lowend		! if at beginning of region
     then ExcMrk();			!  then move to end of region

    while .lowend geq .mark		! while we are past mark
     do begin
	incr i from 1 to .repeat	!  for each repeat count
	 do untabline();		!   untabify the line
	ctrlp2();			!  backup one line.
	if .lowend eql 1		!  if we've reached the beginning
	 then return			! then return
     end;
    ctrln2()
end;

Global Routine tabline = begin		! INDENT LINE
    SetIndent(GetIndent(1)+.tabwidth);	! indent + 1 tabwidth
    EndLin()				! wait at end of line
end;


Global Routine toright = begin		! INDENT REGION
    if .mark eql 0 then			! if no region is declared
     return NoMark();			!  then complain

    BegLin();				! else move to beginning of line
    ExcMrk();				! swap places with mark
    BegLin();				! move to beginning of line

    if .mark gtr .lowend		! if at beginning of region
     then ExcMrk();			!  then move to end of region

    while .lowend geq .mark		! while we are past mark
     do begin
	incr i from 1 to .repeat	!  for each repeat count
	 do tabline();			!   tabify the line
	ctrlp2();			!  backup one line.
	if .lowend eql 1		!  if we've reached the beginning
	 then return			! then return
     end;
    ctrln2()				! move back over line
end;

global routine metarp = begin		! MOVE TO MATCHING RIGHT PAREN
    local count, moves, leftparen, rightparen;

    rightparen_ SELECT leftparen_ scann(hptr)
	of NSET
	    "(": ")";
	    "[": "]";
	    "{": "}";
	    "<": ">";
	    "`": "'";
	    """": """";
	    OTHERWISE: return abortC()
	TESN;
    count_1;
    moves_0;
    do begin
	moves_.moves+1;
	ctrlf();
	if scann(hptr) eql .rightparen
	 then count_.count-1
	 else if scann(hptr) eql .leftparen
	       then count_.count+1;
	if .count neq 0 and .hend eql .hbot
	 then begin
	    while .moves gtr 0
	     do begin ctrlb(); moves_.moves-1 end;
	    return abortC()
	 end
     end until .count eql 0
end;

global routine metalp = begin		! MOVE TO MATCHING LEFT PAREN
    local count, moves, leftparen, rightparen;

    leftparen_ SELECT rightparen_ scann(hptr)
	of NSET
	    ")": "(";
	    "]": "[";
	    "}": "{";
	    ">": "<";
	    "'": "`";
	    """": """";
	    OTHERWISE: return abortC()
	TESN;
    count_1;
    moves_0;
    do begin
	moves_.moves+1;
	ctrlb();
	if scann(hptr) eql .leftparen
	 then count_.count-1
	 else if scann(hptr) eql .rightparen
	       then count_.count+1;
	if .count neq 0 and .lowend eql 1
	 then begin
	    while .moves gtr 0
	     do begin ctrlf(); moves_.moves-1 end;
	    return abortC()
	 end
     end until .count eql 0
end;

Global Routine docomment = begin	! MOVE AND INSERT COMMENT STRING
    local temp,goal;

    BegLin();				! First find length of line
    temp_1;
    while .hbot neq .hend
     do begin
	if eolBreak(scann(hptr))
	 then exitloop;
	temp_updatecursor(scann(hptr),.temp);
	moveforward()
     end;
    goal_.commentpos;			!the goal place to go.
    while .temp gtr .goal
     do goal_.goal + .tabwidth;
    while .temp lss .goal
     do if .spaces or
	   .goal-.temp lss .tabsize
	 then begin
	    insertchar(" ");
	    temp_.temp+1
	 end
	 else begin
	    insertchar("?I");
	    temp_updatecursor("?I",.temp)
	 end;

    insertchar("!")
end;

global routine DayTime = begin
    local val;
    external flubfr,Pdate,Ptime;

    Writeloss(" ");
    Flubfr();
    PDate(-1,.Val_-1);
    Writeloss(" ");
    Flubfr();
    PTime(-1,.Val_-1)
end;

global routine debcor = begin
    local val;

    val _ GetNum(Writestring(plit asciz' loc: '));
    Writeloss(" "); WrtOct(.val); Writestring(plit asciz '/  ');
    WrtOct(.(.val)<18,18>); Writestring(plit asciz',,');
    WrtOct(.(.val)< 0,18>);
    Writeloss(" "); Wrtnum(.(.val)<0,36>); Writestring(plit asciz'. ');
    Writestring(plit asciz' |'); WrtSix((.val)<0,36>); Writeloss("|")
end;

global routine uctrll = begin		! COPY KEY
    local old,new;

    ToPrompt(plit asciz'Copy key:');	! get the old key
    old_ readcc();			!  from the user

    if .old eql .AbortValue		! if user types abort
     then return abortC();		!  then pop out of this

    WriteString(plit asciz' to new key:');
    new_ readcc();			! get the new key

    if .new eql .AbortValue		! again, if the user aborts
     then return abortC();		!  then pop out of this

    (@distbl)[.new]_.(@distbl)[.old]	! all ok, make the copy
end;


global routine bindkey = begin
    local key,name;

    ToPrompt(plit asciz'Function Name: ');
    name _ Symbol(CNames);
    if .flush
     then return abortC();
    if .name leq 0 then return abortC();
    Writestring(plit asciz'Key: ');
    key _ readcc();
    if .key eql .AbortValue
      then return abortC();
    (@distbl)[.key]_.CFuncts[.name];
    repeat_1
end;

Global routine metas = begin local I,Temp;

    Global routine ParHelp = begin
	Own Idx;

	Idx _ 1;				! Skip the first one [0]
	While .Pnames[.Idx] neq 0 do begin	! While not at end of list
	    scrmod_ 1;
	    If MakBox( 1, .PNames[.Idx], ..PLocs[.Idx] )
	     then Idx _ .Idx + 1		! Print Item & Increment
	     else return
	end;
	MakBox( -1, 0, 0 )			! Close box
    end;

    scrmod _ 0;
    Do begin
	ToPrompt(plit asciz 'Parameter: ');
	I _ Symbol(PNames);
	If .I eql 0
	 then ParHelp()
    end until .I neq 0 or .flush;
    If .flush
     then ToPrompt(plit asciz'Aborted')
     else begin
	If .I gtr 0
	 then begin
	    Writestring(plit asciz' Old value was ');
	    WrtNum(..PLocs[.I]);
	    Temp _ GetNum(Writestring(plit asciz', New value: '));
	    If .flush
	     then ToPrompt(plit asciz'Aborted')
	     else .PLocs[.I] _ .Temp
	 end
     end;
    If .scrmod
     then Ctrll()
end;

Global routine extend = begin
    local i;

    Global routine ExtHead = abortC();		! Should never get here
    Global routine ExtHelp = begin
	own Idx;

	Idx _ 1;				! Skip the first one [0]
	While .Cnames[.Idx] neq 0
	 do begin
	    scrmod_ 1;				! Mark screen modified
	    If .Cfuncts[.Idx] neq 0		! If something, print header
	     then MakBox( 0, .CNames[.Idx], 0 );
	    Idx _ .Idx + 1;			! Increment Index
	    While .Cfuncts[.Idx] neq ExtHead	! While not header
		   and .Cfuncts[.Idx] neq 0	!   and not at end (either)
	     do begin				!  Put item into the box
		If MakBox( 0, .CNames[.Idx], 0 )
		 then Idx_ .Idx + 1		!  If ok, Increment Index
		 else return			!   else finish up
	     end;
	    If not MakBox( -2, 0, 0 )		! Close box and check
	     then return			!  for completion
	end
    end;

    scrmod _ 0;
    Do begin
	ToPrompt(plit asciz 'Meta-X ');		! Print M-X
	I _ Symbol(CNames);
	If .I eql 0
	 then ExtHelp()				! Do we really want help?
    end until .I neq 0 or .flush;

    If .scrmod
     then Ctrll();
    if .flush
     then return abortC();

    if .i gtr 0
     then while .repeat gtr 0
	   do begin
		if ..CFuncts[.i] neq 0
		 then (.Cfuncts[.i])();
		repeat _ .repeat -1
	   end;
    repeat_1
end;

external flush,getstr,filescan,CmdFil;

Global Routine metam = begin
    local tp,glbuffer[25],thack;
    external modblk;

    flush_0;
    ToPrompt(plit asciz 'Mode Package: ');
    tp_(glbuffer)<36,7>;
    getstr(.tp);
    thack_.(modblk+1);
    if not (filescan (tp,modblk)) then return abortC();
    if .flush then return abortC();
    return  Select .(modblk+1) of NSET
	sixbit'text':		jstins_ 1;
	sixbit'abbrev':		abinit();
	sixbit'init':		(abinit();jstins_ 0);
	Otherwise:
	    Begin
	(modblk+1)_.thack;
	ErrStr(plit asciz'Bad mode, one of (text abbrev init)');
	    end;
    TESN
end;

Global Routine Ctrlxt = begin
    local glbuffer[20],tp;

    flush_0;
    ToPrompt(plit asciz'Execute command file: ');
    tp_(glbuffer)<36,7>;
    getstr(.tp);
    if .flush
     then return errstr(plit asciz'User Abort');
    CmdFil(.tp,0,plit asciz'No command file')
end;

Global Routine Vueini =
    if not CmdFil((plit asciz'DSK:VUE.INI')<36,7>, 0, Null)
     then CmdFil((plit asciz'DSK:VUE.INI')<36,7>, Getaun(), Null);

end eludom
H3>92