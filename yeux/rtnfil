FILECO.BLI	
G Global routine errstr (foo) = begin
    ToPrompt(.foo);
R Routine fileread(tp,fileppn) = begin
    if not (filescan(tp,filblk)) then
    return errstr(plit asciz'Bad file name');
    if not open(4,0,.filblk,dskbfh<0,0>) then
    return errstr(plit asciz'No such device');
    buffers(4,1,1,dskbuf);
    if not lookup(4,filblk+1) then
    return errstr(plit asciz'No such file.');
G Global routine ctrlxt = begin
    errstr(plit asciz'Infinite Macro Recursion');
    return ctrlg();
    ToPrompt(plit asciz'Take commands from file: ');
    getstr(.tp    tp_(glbuffer-1)<1,7>;    );
    if .flush then return errstr(plit asciz'Flushed');
    fileread(.tp,0);
G Global routine exini =
    fileread((plit asciz'DSK:VUE.INI'-1)<1,7>, Getaun());
QREPL.BLI	
G Global routine genreplace = begin
    if not munchline (sst,plit asciz'Old String: ',.EscValue)
    then return ctrlg();
    if .sst leq 0 then return ctrlg();
    if not munchline (rst,plit asciz'New String: ',.EscValue) then return ctrlg();
    if therep(sst,.i) then begin !if we have an occurence of the string
    moveforward (.i+.sst[0]-.lowend); !move to the right place.
    redisp(1);
    answer_readch();
    clearscreen();
    outstr(tp);
    tp_readch();
    ctrll();
    redisp(1);
    answer_readch();
    incr j from 1 to .sst do delbackward(); !zap the string.
    incr j from 1 to .rst do insertchar(.rst[.j]); !replace
    if .query then redisp(1)
    If .Query then ToPrompt(plit asciz'Finished with Query Replace')
    else ToPrompt(plit asciz'Finished with Replace');
G Global routine metaq = begin
    genreplace()
G Global routine metar = begin
    genreplace()
G Global routine metaa = begin
    redisp(1);
    tc_readch();
    if .tc eql "?G" then return ctrlg();
    else return metap();	       !macro return.
ABBREV.BLI	
G Global routine abspace = begin
    if not whitespace(getchxr(.bp)) then
    tc_scani(tp);
    if .tc neq getchxr(.bp+.j) then exitcompound[2];
    incr j from 1 to .abosize[.i] do rubout();  !zap it.
    tc_scani(tp);
    insertchar(.tc);	       !insert it.
G Global routine abinit = begin
    setproc(CtrlXValue+"?A",abdefine);
    approc(" ",abspace);
    approc("?J",abspace);
    approc("?M",abspace);
    approc(",",abspace);
    approc(";",abspace);
    approc(".",abspace);
    approc("(",abspace);
    approc(")",abspace);
    approc("!",abspace);
    approc("[",abspace);
    approc("]",abspace);
    approc("*",abspace);
    approc("/",abspace);
    approc("$",abspace);
    approc("'",abspace);
    approc("+",abspace);
    approc("-",abspace);
    approc("=",abspace);
    approc("#",abspace);
    approc("&",abspace);
    approc("^",abspace);
    approc(":",abspace);
    approc("@",abspace);
    approc("%",abspace);
    approc("",abspace);
    approc("_",abspace);
    approc("\",abspace);
    approc("""",abspace);
G Global routine abdefine = begin
    return abreset();
    ToPrompt(plit asciz'Too many abbreviations.');
    ToPrompt(plit asciz'');
    munchnnl(line,plit asciz'Abbreviation <esc>: ',.EscValue);
    tp_findab(line);
    replacei(tp,.line[.k]);!dump it in.
    ToPrompt(plit asciz'Too many chars in abbreviations');
    munchnnl(line,plit asciz' will be expanded to <esc>: ',.EscValue);
    WriteLoss("$");
    replacei(tp,.line[.k]);	       !dump it in.
    ToPrompt(plit asciz'Too many chars in abbreviations');
G Global routine abreset = begin
    abfreep_(abbrevspace)<36,7>;
G Global routine findab(aab) = begin	       !find an abbrev.
    tc_scani(tp);
    if .tc neq .((.aab)[.j]) then exitcompound[2];
IDCHAR.BLI	
G Global routine idc (firstchar,line) = begin
    bchr _ getchxr(.mypos);			% buffer character %
    endphyspos_updatecursor(.schr,.endphyspos);
    if .screen[.line,.myscreenpos] eql getchxr(.mypos) then
    goxy(.myphyspos,.line-.wndorg[.curwin]+1+.scroff);!get to right spot.
    fudge_updatecursor(getchxr(.firstchar+.i-1),.fudge);
    inschar();					% excess space %
    fudge_updatecursor(.screen[.line,.i],.fudge);
    delchar();
VUE.BLI	
G Global routine clrkbf = begin
G Global routine appkbf = begin
G Global routine killforward(flag)  = begin local cc;
    cc_getchxr(.lowend);
    replacei(kilptr,.cc);
G Global routine delforward = killforward(0);
G Global routine delbackward  = begin
    moveback(1);
    killforward(0);
G Global routine setchar (i,q) = begin
G Global routine getc (p,i) = begin
G Global routine setc(p,i,c) = begin
G Global routine insertchar(i) =  begin
    coresize(512);				! get more core
    setchar(.lowend-1,.i);
G Global routine echord = begin local tp;
    tp_readch(); ! read a character
    writestring(plit asciz 'Aborted')
    writeloss(.tp); ! print it out.
G Global routine metalt = begin
    moveback (.lowend-1);
G Global routine metagt = begin
    moveforward (.hend-.hbot);
G Global routine ctrlg = begin
    ToPrompt(plit asciz'Error');
G Global routine metac = begin
    errstr(plit asciz'Macro Depth Overflow');
    return ctrlg();
    if .newcount then callchar_readch();
    cstk[.csnum]_qreg(.callchar); !start at the right q-register.
G Global routine metap = begin
G Global routine zapmac = begin
G Global routine ctrlu = begin
    tp_readch(); !read a character.
    if .base neq 0 then comchar_readch();
R Routine commonwrite = begin
    fixfil();	!renames bak files around. uses channel three.
    open (2,0,.filblk,.tp);
    buffers (2,1,0,dskbuf);
    if not enter (2,(filblk+1)<0,0>) then begin
    ToPrompt(plit asciz'Enter failed, probably quota exhausted.');
    close(2);
    if not muncho (.lowend-1,(.p-1)<1,7>) then begin
    ToPrompt(plit asciz'Write failed, cannot begin save.');
    close(2);
    if not muncho (.hend-.hbot, (.p+(.hbot-2)/5)
    ToPrompt(plit asciz'Write failed, cannot complete save.');
    close(2);
    writestring(plit asciz'Write completed.');
    close (2);
R Routine finishbuffer = if .allmod[.curbuf] eql 0 then
    ToPrompt(plit asciz 'No changes made.')
    combuf(1);  close (2);
    ToPrompt(plit asciz 'Writing buffer...');
    return commonwrite();
R Routine exitbuffer = begin
    If not finishbuffer() then return Writestring(plit asciz 'Error!');
    ToPrompt(plit asciz'');
    ttyzap();
    if .cclflag neq 0 then cclmultix()
    else if .xeflag then cucl() else quit();
G Global routine ctrlxs = finishbuffer();
G Global routine ctrlxe = begin
    exitbuffer();
G Global routine ctrlxf = begin
    exitbuffer();
G Global routine ctrlxw = begin local glbuffer [100];
    ToPrompt(plit asciz 'Write File: ');
    getstr(.tp    tp_(glbuffer-1)<1,7>;    );
    if not (filescan (tp,filblk)) then return ctrlg();
    if .flush then return ctrlg();
    commonwrite();
G Global routine munchnnl (line,prompt,terminator) = begin
    writestring(.prompt);
    tc_readch(); ! read a character.
    goxy(.physpos-1,.physlin);
    goxy(.physpos-1,.physlin);
    clearline();
    flubfr();
    (.line+.i)_readch();	!set the char.
    writeloss(.(.line+.i));
    writeloss(.tc);
    (.line+.i)_.tc; ! set the char.
G Global routine munchline(line,prompt,terminator) = begin
    ToPrompt(plit asciz'');
    retval_munchnnl(.line,.prompt,.terminator);
    WriteLoss("$");
    flubfr();
G Global routine ctrlxx = begin
    if .mark gtr .lowend+.hend-.hbot then return metagt(); !bad mark
    if .mark lss .lowend then moveback (.lowend-.mark);
    if .mark gtr .lowend then moveforward (.mark-.lowend);
    return (mark_.tmark)
R Routine killtext(killflag) = begin local n,tp;
    if .mark eql 0 then return errstr(plit asciz'Mark not set.');
    if .lowend gtr .mark then ctrlxx();		! mark must be after lowend
    if not(.laskil) then clrkbf();
    ToPrompt(plit
    tp_readch();
    ToStatus(); hitsts_1;
    Writestring(plit asciz 'Please type "Y" or "N"');
    ToPrompt(plit asciz 'Text too large to copy!');
    replacei(kilptr,getchxr(.lowend));	% copy the character %
    if .killflag then killforward(0)	% kill it? %
    else moveforward(1);	% no -- just skip it %
    if .killflag then ToPrompt(plit asciz 'Text Killed')
    else ToPrompt(plit asciz 'Text Copied');
G Global routine ctrlw = killtext(1);
G Global routine metcw = killtext(0);
G Global routine ctrls = begin
    if not munchline (sst,plit asciz'Search: ',.EscValue) then return
    (errstr(plit asciz'Search aborted.');-1);
    if therep (sst,.i) then begin
    moveforward(.i+.sst[0]-.lowend);
    return (errstr(plit asciz'Search failed');-1);
G Global routine  ctrlat = begin
    ToPrompt(plit asciz 'Mark set')
    ToPrompt(plit asciz 'Mark cleared')
G Global routine horizspace (tc) =
G Global routine whitespace(tc) =
G Global routine wbreak (foo) =
G Global routine ctrlr = begin
    if not munchline (sst,plit asciz'Reverse Search: ',.EscValue) then
    return (errstr(plit asciz'Reverse Search aborted.');-1);
    if therep(sst,.i) then begin
    moveback(.lowend-.i);
    return (errstr(plit asciz'Reverse Search Failed');-1);
G Global routine dispatch = begin
    if .tp eql 1 then insertchar(.comchar)  % 1=self inserting %
    errstr(plit asciz'Macro Depth Overflow');
    cstk[.csnum]_qreg(.callchar);		! set macro address
    else (.tp)();				! else do command
G Global routine reader = begin local igct,wonp;
    setlab();
    if .cstk[.csnum] eql 0 and ttyidle() then begin
    autoloss();	!call autosave code.
    wonp_if .igct geq 10 then redisp(0)
    else redisp(1);
    comchar_readch();
    if .base neq 0 then comchar_readch();   !if $ or ^x, get real command
    dispatch();   !execute the command
G Global routine ctrlxm = begin
    ToPrompt(plit asciz'Macro Slot: ');
    tp_readch(); !get the macro character slot.
    writeloss(.tp);
    errstr(plit asciz'Illegal Slot Name.');
    writestring(plit asciz' def: ');
    qbp_qreg(.tp);
    tp_readch(); ! get a char.
    replacei (qbp,.tp);
    writeloss(.tp);
G Global routine metaw = begin
    ctrlat();
    if .oct eql 4 then tp_ctrlr()			% in front of string %
    tp_ctrls();
    if .tp neq -1 then moveback(.sst[0])	% in front of string %
    if .tp eql -1 then return errstr(plit asciz'String not found.');
    ctrlw();
G Global routine ctrla  = while 1 do begin local cc;
    cc_getchxr(.lowend-1);
    moveback(1)
G Global routine ctrlb  =  if .lowend neq 1 then moveback(1)
    else return zapmac();
G Global routine metab = begin
    ctrlb();
    while .lowend gtr 1 and whitespace(getchxr(.lowend)) do ctrlb();
    if .lowend eql 1 then return zapmac();
    if wbreak(getchxr(.lowend-1)) then return;
    ctrlb();
G Global routine ctrlc = begin
    ToPrompt(plit asciz'');
    ttyzap();
    quit();
G Global routine ctrld = if .hbot neq .hend then killforward(0)
    else return zapmac();
G Global routine metad =  begin
    while .hend neq .hbot and whitespace(getchxr(.lowend)) do ctrld();
    ctrld();
    if .hbot eql .hend then return zapmac();
    if wbreak (getchxr(.lowend)) then exitloop;
G Global routine ctrle = while 1 do begin local cc;
    cc_getchxr(.lowend);
    moveforward(1);
G Global routine ctrlf  = if .hend neq .hbot then moveforward(1)
    else return zapmac();
G Global routine metaf = begin
    while .hend neq .hbot and whitespace(getchxr(.lowend)) do ctrlf();
    ctrlf();
    if .hbot eql .hend then return zapmac();
    if wbreak(getchxr(.lowend)) then exitloop;
G Global routine ctrlk  = begin local rep,cc;
    if not(.laskil) then clrkbf();
    if .hend eql .hbot then return zapmac();	% prevent overflows %
    cc_getchxr(.lowend);				%  prime the loop   %
    if .cc eql #15 then killforward(1)		% a blank line case %
    killforward(1);
    if .hend eql .hbot then return zapmac();	% ? end of text ?   %
    cc _ getchxr(.lowend);			% - get character - %
    ToPrompt(plit asciz 'Too much text deleted -- not all was saved!');
G Global routine killmultiline  = begin local rep,cc;
    if not(.laskil) then clrkbf();
    if .hend eql .hbot then return zapmac();
    cc_getchxr(.lowend);	% seed to prime the loop %
    Return (killforward(1));
    killforward(1);
    if .hend eql .hbot then return zapmac();	% ? end of text ?   %
    cc _ getchxr(.lowend);			% - get character - %
    if .cc eql #15 then killforward(1);		% finish the line   %
    ToPrompt(plit asciz 'Too much text deleted -- not all was saved!');
R Routine GetPos (npcol) = begin
    temp_getchxr(.place-1);
    temp_getchxr(.i);	       !get the data.
    .npcol_updatecursor(.temp,..npcol);
G Global routine ctrln2  = while 1 do begin;
    if .hend eql .hbot then return zapmac();
    moveforward(1);
    if getchxr(.lowend-1) eql #015 then return 0;
    if .sosmod then if getchxr(.lowend-1) eql #014 then return 1;
G Global routine ctrln = begin
    if not .lasmov then GetPos(pcolumn);
    incr i from 1 to .repcount do ctrln2();
    if  .pos geq .pcolumn or getchxr(.lowend) eql "?M"
    or (getchxr(.lowend) eql "?L" and .sosmod)
    pos _ updatecursor(getchxr(.lowend),.pos);
    ctrlf()
G Global routine ctrlo  = begin;
    insertchar(#015);
    moveback(1);
G Global routine ctrlp2  = while 1 do begin;
    if .lowend eql 1 then return zapmac();
    moveback(1);
    if getchxr(.lowend) eql #015 then return(ctrla();0);
    if .sosmod then if getchxr(.lowend) eql #014 then return(ctrla();1);
G Global routine ctrlp = begin
    GetPos(pcolumn);
    ctrlp2();
    getchxr(.lowend)
    getchxr(.lowend)
    updatecursor(getchxr(.lowend),.pos);
    ctrlf()
G Global routine ctrlq  = insertchar(readch());
G Global routine ctrlt = begin
    ctrlg()
    tc_getchxr(.lowend-1);
    setchar(.lowend-1,getchxr(.lowend-2));
    setchar(.lowend-2,.tc);
    getchxr(.lowend-1) eql"?M" or getchxr(.lowend-2) eql "?M" then
G Global routine ctrlv = begin
    do if ctrln2() then exitloop;
G Global routine metav = begin
    do if ctrlp2() then
    ctrln2();	       !show predecessor.
G Global routine metacn = begin
    incr i from 1 to .scrsze-.curline do if ctrln2() then begin
    ctrlp2();		       !back over the page mark.
    ctrle();
G Global routine metacp = begin
    incr i from 1 to .curline-1 do ctrlp2();
    ctrla();
G Global routine rubout = begin
    if .lowend eql 1 then return zapmac();
    delbackward();
G Global routine metadel = begin local tc,td;
    metab();
    moveforward(.tc-.td);
    incr i from .td to .tc-1 do delbackward();
G Global routine ctrly = begin
    insertchar(scani(tp));
    Reset();				! Check Visibility.
    clrkbf();				! Clear the kill buffer.
    p_coresize(512);			! Get some core.
    bufini();
    (bfblk2+4)_getppn();
    If .cclflag then cclstuff()		! Either read TMP file
    else dorescan();		!   or   possible command line.
    If Asktty() then begin			! If we get a legal terminal
    initdispatch();			! Initialize dispatch table.
    qbp_qreg(.i);			!   Executed only once!
    replacei(qbp,.XPrefix);		!      C-X
    replacei(qbp,")");		!      ")"
    fef();				! Initialize Terminal mode
    exini();				! Set/Check INIT file
    clearscreen();			! Clear screen
    winit();				! Initialize window
    reader();				! On your way!
REDISP.BLI	
G Global routine redisp (checkflag) = begin
G Global inwind=(0);
G Global linmax[30]=(30:1);
G Global routine writestring(foo) = begin
    cc_scani(tp);
    writeloss(.cc)
G Global routine writeloss(foo)=
    putch(.foo);
    else if .foo eql #15 then leftmargin()
    ! else if .foo eql #12 then (putch(.foo);physlin_.physlin+1)
    else if .foo eql #11 then goxy (updatecursor(#11,.physpos),.physlin)
    else if .foo eql .EscValue then (putch("$");physpos_.physpos+1)
    putch("^");putch(.foo+#100);	![CB @ GC] Changed to Upper case
G Global routine updatecursor (xc,foo) =
    if (getchxr(.i) eql "?L") and .sosmod then begin
    if getchxr(.i) eql #015 then begin
    defwindow(1,.wndorg[.curwin],.linesz,.wndsiz[.curwin])
    caliad(.firstchar);	!ins and del line.
    else idc(.firstchar,.i))
    if not ttyidle() and .checkflag then return 0; !early
    idc(.firstchar,.i);
    cchar_getchxr(.firstchar); !save calls to getchxr
    curlm_updatecursor(.cchar,.physcreenpos);
    physcreenpos_updatecursor(.cchar,.physcreenpos);
    or (updatecursor(.cchar,1)  neq 2)
    or (updatecursor(.temp,1)  neq 2))
    goxy (.physcreenpos,.tline)
    else goxy (.linesz,.tline);
    clearline();
    goxy (.physcreenpos,.tline)
    else goxy (.linesz,.tline);
    clearline();
    flubfr();
    goxy (.physcreenpos,.tline) !and place
    else goxy (.linesz,.tline);
    writeloss (.cchar);
    dostatus();
    defwindow(1,.wndorg[.curwin],.linesz,.wndsiz[.curwin])
    if .npos lss .linesz then goxy (.npos,.scroff+.curline)
    else goxy (.linesz,.scroff+.curline);
G Global routine metao = begin
CALIAD.BLI	
G Global routine autoloss = begin
    ToPrompt(plit asciz 'Starting...');
    flubfr();
    combuf(1);
    close (2);
    writestring(plit asciz 'Saved');
G Global routine metarp = begin local count, moves, leftparen, rightparen;
    SELECT leftparen_getchxr(.lowend) OF
    OTHERWISE: (return ctrlg())
    moves_.moves+1; ctrlf();
    if getchxr(.lowend) eql .rightparen then count_.count-1
    else if getchxr(.lowend) eql .leftparen then count_.count+1;
    while .moves gtr 0 do begin ctrlb(); moves_.moves-1 end;
    return ctrlg()
G Global routine metalp = begin local count, moves, leftparen, rightparen;
    SELECT rightparen_getchxr(.lowend) OF
    OTHERWISE: (return ctrlg())
    moves_.moves+1; ctrlb();
    if getchxr(.lowend) eql .leftparen then count_.count-1
    else if getchxr(.lowend) eql .rightparen then count_.count+1;
    while .moves gtr 0 do begin ctrlf(); moves_.moves-1 end;
    return ctrlg()
TMP.BLI	
G Global routine tmpcor(name,code,buffer,buflen)=
G Global routine dotmpcor(name,func,buffer,buflen)=
G Global routine tmpdsk(name,func,buffer,buflen)=
G Global routine corecheck = begin
    coresize(512); ! get more core
    setchar(.i+2560,getchxr(.i));
BUFFER.BLI	
G Global routine bufnam(request) = begin
R Routine Hexdigit(number) = 
    Job_getjob();
    request<6,6>_Hexdigit(.Job<4,4>);
    request<0,6>_Hexd.Job<0,4>);
G Global routine bufinit = begin
    allbufs[0]_bufnam(sixbit 'main');
G Global routine uctrlb = begin local glbuffer [MaxBufs],tp;
    ToPrompt(plit asciz'Select Buffer: ');
    (bfblk1+1)_bufnam(sixbit 'main');
    (bfblk1+4)_getppn();
    getstr(.tp);
    if not (filescan (tp,bfblk1)) then return ctrlg();
    if .flush then return ctrlg();
    ToPrompt(plit asciz'');
    combuf(0)
G Global Routine Filbuf = Begin
    ppn_.(filblk+4);			! Current ppn
    open (2,0,.filblk,dskbfh<0,0>);	! Current file block
    buffers (2,1,1,dskbuf);		! ..get a formatted disk buffer.
    if lookop() then munchi ((.p+extra/5)<1,7>)
    else ToPrompt(plit asciz'File not found.');
    close (2);				! Finished with input file.
    relcore();				! Release extra core
G Global routine ctrlxr = begin local glbuffer [100];
    ToPrompt(plit asciz'Read File: ');
    getstr(.tp);
    if not (filescan (tp,filblk)) then return
    errstr(plit asciz'Illegal File Name');
    if .flush then return ctrlg();
    Filbuf()
G Global routine ctrlxv = begin local glbuffer [MaxBufs],tp,device,ext;
    ToPrompt(plit asciz'Visit File: ');
    getstr(.tp);
    if not (filescan (tp,tmpblk)) then return ctrlg();
    if .flush then return ctrlg();
    existed_existsbuf(.(tmpblk+1));
    ToPrompt(plit asciz'');
    (bfblk1+4)_getppn();
    combuf(0);
    Filbuf();
G Global routine UCtrlo = begin local glbuffer [MaxBufs],tp;
    ToPrompt(plit asciz'Buffer Name: ');
    (bfblk1+1)_bufnam(sixbit 'main');
    (bfblk1+4)_getppn();
    getstr(.tp);
    if not (filescan (tp,bfblk1)) then return ctrlg();
    if .flush then return ctrlg();
    ToPrompt(plit asciz'');
    combuf(2)
G Global routine combuf (autop) = begin
    if .autop eql 0 then newbuf_AddBuf(.(bfblk1+1));
    if .autop eql 2 then (Addbuf(.(bfblk1+1));newbuf_0);
    open (2,#16,.bfblk2,0<0,0>);
    if not enter (2,(bfblk2+1)<0,0>) then begin
    ToPrompt(plit asciz'Buffer enter failed!');
    close(2);
    dmpout(dskbuf,#200);	!dump out the status record.
    dmpout(.p,.hend/5+1);	!dump out the main buffer.
    close (2);
    (bfblk2+4)_getppn();
    open (2,#16,.bfblk1,0<0,0>);
    curbuf_gbnum(.(bfblk1+1));     !set the buffer number.
    if .newbuf or (not realup(bfblk1+1<0,0>)) then begin;
    close(2);
    dmpin(2,dskbuf,#200);	!read the header page in.
    coresize(512);
    dmpin(2,.p,.dskbuf/5+1);	!read in .hend characters.
    close (2);
G Global routine existsbuf (bname) =begin
G Global routine AddBuf (bname) = begin local seen;
    ToPrompt(plit asciz'Too many buffers');
G Global routine ctrlxb = begin local tp,tc;
    ToPrompt(plit asciz'');
    if .allmod[.i] neq 0 then writeloss("*");
    tc_scani(tp);
    writeloss(.tc)
    writeloss(" ");
G Global routine gbnum (bname) =
G Global routine gbmod(bname) = .allmod[gbnum(.bname)];
EXTEND.BLI	
G Global routine approc(place,proc) = begin local oldvalue;
    errstr(plit asciz'Rebind space overflow, reseting with INIT mode.');
    initdispatch();
G Global routine setproc(place,proc) = distbl[.place]_.proc;
G Global routine getpair = begin    ! standard command rebinder.
    tc_readch();	       !get the thing.
    if .tc eql "?G" then return (errstr(plit asciz'Cannot Do Rebind');-1);
    writeloss(.tc);
    tc_readch();
    if .tc eql "?G" then return (errstr(plit asciz'Cannot Do Rebind');-1);
    writeloss(.tc);
G Global routine uctrll = begin
    ToPrompt(plit asciz'Copy key:');
    old_getpair();
    WriteString(plit asciz' to new key:');
    new_getpair();
G Global routine bindkey = begin
    ToPrompt(plit asciz'Function Name: ');
    name _ GetRoutine(table);
    if .name eql -1 then return ctrlg();
    Writestring(plit asciz'Key: ');
    key _ getpair();
    if .key lss 0 then return ctrlg();
G Global routine ctrlxl = begin
    ToPrompt(plit asciz'Macro Slot: ');
    mname_readch();
    errstr(plit asciz'Illegal Slot Name.');
    writeloss(.mname);
    WriteString(plit asciz' bind to key: ');
    new_getpair();
G Global routine setparm = begin	       !^Xright square bracket
    pn_readch();	       !read which parameter we are.
    ToPrompt(plit asciz'');
    tc_readch();
    writeloss(.tc);
    tc_readch();
    writeloss(.tc);		       !and echo it.
    replacei(freezone,.tc);	       !plug it in.
    replacei(freezone,"?]");	       !part of the return sequence.
    replacei(freezone,"r");	       !the rest thereof.
G Global routine popio = begin
G Global routine extend = begin
    ToPrompt(plit asciz 'Meta-X ');	! Print M-X
    i _ GetRoutine(table);		! Use table from Module
    if ..i neq 0 then (..i)();	! Attempt to use this.
G Global routine metas = begin
    ToPrompt(plit asciz 'Mode parameter: ');
    GetSymbol(.parameters);
STATUS.BLI	
R Routine writesix(word) = Begin
    chr_scani(tp);
    If .chr neq 0 then writeloss(.chr+#40);
G Global routine dostat = begin
    Putch("?G"); ! Beep !
    InverseVideo();
    ToStatus();		!move the cursor to the right place and clear line.
    WhiteLine();
    writestring(plit asciz ' VUE ');
    writeloss("%");
    wrtoct(.ver);
    if .min neq 0 then writeloss(.min+"@");
    if .edit neq 0 then begin writeloss("(");wrtoct(.edit);writeloss(")"); end;
    if .who neq 0 then begin writeloss("-");writeloss(.who+"0"); end;
    writeloss(" ");
    if .vuetyp neq 0 then begin writesix(vuetyp); writeloss(" "); end;
    if .JBddt<0,36> neq 0 then writestring(plit asciz '+DDT ');
    Writeloss("(");
    Writesix(ttype);		!first terminal type
    Writeloss(" ");
    Writesix(modblk+1);		!mode
    if .submod neq 0 then begin writeloss(" "); writesix(submod); end;
    if .autoinc neq 0 then writestring(plit asciz ' Save');
    writestring(plit asciz ') ');
    writesix(bfblk2+1);		!buffer name
    writestring(plit asciz '  File:');
    writesix(filblk+1);		!Filename part
    writeloss(".");
    writesix(Ext);		!Extension part
    writestring (plit asciz '  --');	!a separation.
    if .lowend eql 1 then writestring(plit asciz'TOP--')
    else if .hend eql .hbot then writestring(plit asciz'BOT--')
    writeloss(.percnt/10+"0");
    writeloss(.percnt-10*(.percnt/10)+"0");
    writestring(plit asciz'%--');
    if gbmod(.(bfblk2+1)) then writestring(plit asciz' *');
    if mail() then writestring(plit asciz' ');
    normalvideo();
REBIND.BLI	
G Global routine approc(place,proc) = begin local oldvalue;
    errstr(plit asciz'Cons space overflow, reseting to INIT mode.');
    initdispatch();
G Global routine setproc(place,proc) = begin
G Global routine getpair = begin
    tc_readch();	       !get the thing.
    if .tc eql "?G" then return (errstr(plit asciz'Punt!');-1);
    writeloss(.tc);
    tc_readch();
    if .tc eql "?G" then return (errstr(plit asciz'Punt!');-1);
    writeloss(.tc);
    tc_readch();
    if .tc eql "?G" then return (errstr(plit asciz'Punt!');-1);
    writeloss(.tc);
G Global routine uctrll = begin
    ToPrompt(plit asciz'Move from command:');
    old_getpair();
    WriteString(plit asciz' to new command:');
    new_getpair();
G Global routine ctrlxl = begin
    ToPrompt(plit asciz'Macro name: ');
    mname_readch();
    errstr(plit asciz'Bad macro name.');
    writeloss(.mname);
    WriteString(plit asciz' will be typed as :');
    new_getpair();
G Global routine setparm = begin	       !^Xright square bracket
    pn_readch();	       !read which parameter we are.
    ToPrompt(plit asciz'');
    tc_readch();
    writeloss(.tc);
    tc_readch();
    writeloss(.tc);		       !and echo it.
    replacei(freezone,.tc);	       !plug it in.
    replacei(freezone,"?]");	       !part of the return sequence.
    replacei(freezone,"r");	       !the rest thereof.
G Global routine popio = begin
CURSOR.BLI	
R Routine escape(char) = begin
    putch(#33);
    putch(.char)
R Routine padd(count) = begin
    if .ttytyp eql Adm31 then imout(#0) else imout(#177);
G Global routine ttyzap = begin
    clearscreen();
    escape("4");putch(" ");putch("l");
    defwindow(1,1,.Ccols,.Clines);
    goxy(1,.modpos+.echosize);
    escape("z");
    defwindow(1,1,.Ccols,.Clines);
    (putch(#030);putch(#035));
G Global routine delchar =
    con100:	return  escape("?A");
    hkit19:	return  (escape("[");putch("P"));
    h19:	return	escape("N");
    tr1061:	return  escape("Q");
    hp2621:	return  escape("P");
    adm31:	return	escape("W");
G Global routine inschar =
    con100:	return  (escape("?P");putch(" ");
    putch(#33);imout(0);
    hkit19:	return  (escape("[");putch("4");putch("h");
    putch(" ");
    escape("[");putch("4");putch("l");
    h19:	return	(escape("@");putch(" ");escape("O");
    tr1061:	return  escape("P");
    hp2621:	return  (escape("Q");putch(" ");
    escape("R");
    Adm31:	return	escape("Q");
G Global routine ttyin2 = begin
G Global routine ttyini = begin
    Clines _ GetLen()+1;
    Ccols _ GetWid();		    ! [CB] Use system's idea of width
    con100:	return  (Ccols _ GetWid();
    escape("U");
    escape("4");putch(" ");putch("f");
    defwindow(1,1,.Ccols,.Clines));
    vt100:	return	defwindow(1,1,.Ccols,.Clines);
    hkit19:	return  escape("<");
    h19:	return  (escape("[");putch("??");
    putch("2");putch("h"));
G Global routine ToPrompt(foo) =
    defwindow(1,1,.linesz,.modpos+.echosize);
    goxy(1,.modpos+2);
    clearline();
    Writestring(.foo);
    Flubfr();
G Global routine ToStatus =
    defwindow(1,1,.linesz,.modpos+.echosize);
    goxy(1,.modpos+1);
    clearline();
G Global routine defwindow (x,y,c,l) =
    escape("v");	!define window mode.
    wrnum(.y);		!write the y position
    wrnum(.x);
    wrnum(.l+1);
    wrnum(.c+1)
    vt100setregion(0,.Clines)
R Routine vt100setregion (top,bottom) = begin
    escape("[");
    if .top    gtr 1 then wrnum(.top+1);
    putch(";");
    wrnum(.bottom+1);
    putch("r");				! Set scrolling region
G Global routine inslin (times) =
    putch(#176);putch(#232);padd(2)	end;
    putch(#176);putch(#232);padd(2)	end;
    vt100:	return  (escape("7");	! save the cursor position
    vt100setregion(.physlin,.modpos+1);
    escape("8");	! restore cursor position
    incr i from 1 to .times do escape("M");
    vt100setregion(0,.modpos+.echosize);
    escape("8"));	! restore cursor position
    tr1061:	return  incr i from 1 to .times do escape("L");
    adm31:	return	incr i from 1 to .times do (escape("E");padd(16));
    local j;escape("L");
    incr j from 1 to 4 do putch(13);
    putch(#20);putch(#12);putch(#30)
    escape("?R");padd(3)
    hkit19:	return  (escape("[");wrnum(.times+1);putch("L"));
    h19:	return	incr i from 1 to .times do escape("L");
    mime4:	return  incr i from 1 to .times do putch("?A");
    hp2621:	return  incr i from 1 to .times do escape("L");
G Global routine dellin (times) =
    putch(#176);putch(#223);padd(2) end;
    putch(#176);putch(#223);padd(2) end;
    vt100:	return  (escape("7");
    vt100setregion(.physlin,.modpos+1);
    escape("[");wrnum(.modpos+.echosize);putch("H");
    incr i from 1 to .times do putch("?J");
    vt100setregion(0,.modpos+.echosize);
    escape("8"));
    escape("?B");padd(3) end;
    tr1061:	return  incr i from 1 to .times do escape("M");
    adm31:	return	incr i from 1 to .times do (escape("R");padd(16));
    local j;escape("M");
    incr j from 1 to 12 do putch(13);
    putch(#20);putch(#32);putch(#30);
    hkit19:	return  (escape("[");wrnum(.times+1);putch("M"));
    h19:	return	incr i from 1 to .times do escape("M");
    mime4:	return  incr i from 1 to .times do putch("?W");
    hp2621:	return  incr i from 1 to .times do escape("M");
G Global routine clearscreen = begin
    ttyini();
    putch(12);				!1: superbee
    (putch(26);putch(32));			!2: adm
    putch(12);				!4: beehive
    (defwindow(1,1,.Ccols,.Clines);		!6: concept
    physpos_1;physlin_1;putch("?L"));
    (putch("?X");putch(#36));		!9: dm2500
    (home();escape("[");			!10:vt100
    putch("2");putch("J"));
    (putch(#176);putch(#234);padd(4));	!13:Hazeltine 1500
    (escape("[");putch("2");putch("J"));	!14:heath 19
    putch(#14);				!15:dm1500
    putch("?L");				!16:act4
    (home();escape("J"));			!17:vt52
    putch("?L");				!20:teleray 1061
    putch("?L");				!21:mime4
    (home();escape("J"));			!23:HP2621v
    escape("E");				!27:Heath-kit 19
    (escape(":");padd(8));			!28:Adm-31
    (putch(#176);putch(#234);padd(4));	!30:Hazeltine 2000
    flubfr();
G Global routine leftmargin = begin
    if .ttytyp eql superbee then (putch(13);putch(10);escape("A"))
    else putch(13);
G Global routine home = begin
    escape("H");				!1: superbee
    putch("?^");				!2: adm3a
    escape("H");				!4: beehive
    escape("??");				!6: concept
    putch(2);				!9: dm2500
    (escape("[");putch("H"));		!10:vt100
    (putch(#176);putch(#22);padd(2));	!13:Hazeltine 1500
    (escape("[");putch("H"));		!14:heath 19
    putch(#31);				!15:dm1500
    putch("?]");				!16:act4
    escape("H");				!17:vt52
    escape("H");				!20:teleray 1061
    putch("?]");				!21:mime4
    escape("H");				!23:HP2621
    escape("H");				!27:Heath-kit 19
    putch(#36);				!28:Adm-31
    (putch(#176);putch(#22);padd(2));	!30:Hazeltine 2000
G Global routine goxy (xloc,yloc) = begin
R Routine yxechar(ch) = begin
    escape(.ch);    putch(.y+#37);    putch(.x+#37);
R Routine xychar(ch) = begin
    putch(.ch);    putch(.x+#37);    putch(.y+#37);
R Routine yxchar(ch) = begin
    putch(.ch);    putch(.y+#37);    putch(.x+#37);
R Routine xynum(ch) = begin
    putch(.ch);    wrnum(.x);    wrnum(.y);
R Routine yxnum(ch) = begin
    putch(.ch);    wrnum(.y);    wrnum(.x);
R Routine xyenum(ch) = begin
    putch(#33);    xynum(.ch);
R Routine yxenum(ch) = begin
    putch(#33);    yxnum(.ch);
R Routine xyhp26xx = begin
    escape("&");    putch("a");
    wrnum(.y);      putch("y");
    wrnum(.x);      putch("C");
R Routine xydm2500 = begin
    putch(#14);    putch(.x-1 xor #140);    putch(.y-1 xor #140);
R Routine xydm1500 = begin
    putch(#36);    imout(.x+31);    imout(.y-1);
R Routine xyvt100 = begin
    escape("[");
    if .y gtr 1 then wrnum(.y+1);
    if .x gtr 1 then begin putch(";"); wrnum(.x+1); end;
    putch("H");
R Routine xyhazeltine = begin
    putch(#176);    putch(#21);
    imout(.x-1);	!	    putch(.x);
    imout(.y-1);	!	    putch(.y);
    (putch("?M");putch("?J"));	! 0: non-video
    xyenum("F");		! 1: superbee
    yxechar("=");		! 2: adm3a
    yxenum("F");		! 4: beehive
    yxenum("a");		! 6: concept 100
    xydm2500();			! 9: dm2500
    xyvt100();			!10: vt100
    xyhazeltine();		!13: hazeltine 1500
    xyvt100();			!14: heath-19
    xydm1500();			!15: dm1500
    yxnum("?T");		!16: act4
    yxechar("Y");		!17: vt52
    yxechar("Y");		!20: teleray 1061
    yxnum("?T");		!21: mime4
    xyhp26xx();			!23: hp 2621v
    yxechar("Y");		!27: Heath-kit 19 (Heath mode)
    yxechar("=");		!28: Adm-31
    xyhazeltine();		!30: hazeltine 2000
G Global routine clearline = begin
    escape("K");		       !1: superbee
    writeloss(" ");		!adm3
    goxy(.tc,.physlin)		!go back to where we were.
    escape("K");		       !4: beehive
    escape(19);		       !6: concept
    putch(#27);		       !9: dm2500
    (escape("[");putch("K"));      !10:vt100
    (putch(#176);putch(#17);padd(2)); !13:hazel
    (escape("[");putch("K"));      !14:heath 19
    putch(#35);		       !15: dm1500
    putch("?^");		       !16: act4
    escape("K");		       !17: vt52
    escape("K");		       !20: t1061
    putch("?^");		       !21: mime4
    escape("K");		       !23: HP2621
    escape("K");		       !27: Heath-kit 19 (Heath mode)
    escape("T");		       !28: Adm-31
    Flubfr();
G Global routine Asktty = begin
R Routine SelectTTY(Sometype) =
R Routine CaseTTY(TTYnumber) = 
R Routine Getusr = while 1 do begin
    ToPrompt(plit asciz 'Enter terminal type (?? for help, E for exit): ');
    tp_readch();
    clearscreen();
    ToStatus();
    Montty _ Gettty();			!   Ask the monitor for a type
    Savtyp _ SelectTTY(.Montty);	! See if it's in our table
    Ttype  _ CaseTTY(.Savtyp);	!   Set NAME to Terminal NAME
    Montty _ Getusr();			! Ask the user for a type
    Savtyp _ SelectTTY(.Montty);	! See if it's in our table
    Ttype  _ CaseTTY(.Savtyp);	!   Set NAME to Terminal NAME
G Global Routine WhiteLine = begin
    ClearLine();
    InverseVideo();
    InverseVideo();
    ClearLine();
G Global routine inversevideo =
    hz1500:	return  (putch(#176);putch(#237));
    hz2000:	return  (putch(#176);putch(#237));
    vt100:	return  (escape("[");putch("7");putch("m"));
    con100:	return  (escape("D");escape("E"));
    hkit19:	return  (escape("[");putch("7");putch("m"));
    h19:	return	escape("p");
G Global routine normalvideo =
    hz1500:	return  (putch(#176);putch(#231));
    hz2000:	return  (putch(#176);putch(#231));
    con100:	return  (escape("d");escape("e"));
    !    adm31:	return	(escape("G");putch("0"));
    vt100:	return  (escape("[");putch("m"));
    hkit19:	return  (escape("[");putch("m"));
    h19:	return	escape("q");
    !   tr1061:	return	(escape("R");putch("@"));   ! looks horrible
PASCAL.BLI	
R Routine advance (fromCol,toCol) =
    while (tempcol_updatecursor("?I",.col)) leq .toCol do
    insertchar("?I");
    insertchar(" ");
R Routine column =
    if getchxr(.pos) eql "?M" then (pos_.pos+1; exitloop)
    col_updatecursor(getchxr(.pos),.col);
R Routine MetaBB  =
    advance(.col,.curcomment);
    insertchar("");
    mylf()
R Routine myspace  =
    if (.hend neq .hbot) and getchxr(.lowend) neq "?M" then
    return insertchar(" ");
    ctrla();	!get back
    if getchxr(.lowend) eql "?M" then exitloop;
    cpos_updatecursor(getchxr(.lowend),.cpos);
    moveforward(1)
    if .cpos leq .linesize then return insertchar(" ");
    cpos_getchxr(.lowend-1);
    if whitespace(.cpos) then exitloop;
    moveback(1)
    if getchxr(.lowend-1) eql " " then delback()
    insertchar("?M");
    advance(1,.curcomment+2);
    ctrle();	!skip over what we have
    insertchar(" ");
R Routine myret  = begin
    myspace();		!hack a space first
    rubout();		!knock it off too.
    insertchar("?M");	!put in a carriage return at the end.
G Global routine pascal  =
R Routine untabline  =
    getind();
    ctrla();
    moveforward(.labelsize);
    while horizspace(getchxr(.lowend)) and .hbot neq .hend do
    delforward();
    doend();
    ctrle()
R Routine tabline  =
    getind();
    ctrla();
    moveforward(.labelsize);
    while horizspace(getchxr(.lowend)) and .hbot neq .hend do
    delforward();
    doend();
    ctrle()
R Routine stringp (astring,start,wordp) =
    if .wordp and not wbreak(getchxr(.start-1)) and .start neq 1 then
    tc_scani(tp);
    if getchxr(.cpos) neq .tc then return 0;
    if (.wordp and not wbreak(getchxr(.cpos)))
R Routine linep (keyword,start)=
    if stringp(.tp,.start,1) then return 1;
    if stringp(commentstring,.start,0) then return 0;
    if getchxr(.start) eql "?M" then return 0;
R Routine elinep (keyword,start) =
    if stringp(commentstring,.start,0) then exitloop;
    if getchxr(.start) eql "?M" then exitloop;
    if wbreak(getchxr(.start)) then LastWasBreak_1
    else (if .LastWasBreak then keycol_.start; LastWasBreak_0);
    if stringp(.tp,.keycol,1) then return 1;
R Routine inlist (list,rout,start) =
    if (.rout)(..ptr,.start) then return .Vreg
R Routine getind  = begin
    ctrle();
    if getchxr(.start) eql "{" then exitloop;
    while (c_getchxr(.start)) eql ":" or "0" leq .c and .c leq "9" do
    while getchxr(.start) eql "?I" do begin
    !	spacect_updatecursor("?I",.spacect+1)-1;
    spacect_updatecursor("?I",.c+1)-1;
    while getchxr(.start) eql " " do begin
R Routine calcind  = begin
R Routine doend  =
    advance(.labelsize+1,.spacect+1);
R Routine mycolon  =
    insertchar(":");
    if (c_getchxr(.i)) eql "?M" then
    getind();
    ctrla();
    while (c_getchxr(.lowend)) eql "?I" or .c eql " " and .hbot neq .hend do
    delforward();
    moveforward(.labelsize);
    doend();
R Routine mylf  = begin
    start_getind();
    if inlist(EndSymbols,linep,.start) then begin
    else if inlist(OneLineIndentSymbols,elinep,.start) then xiudent_1;
    ctrla();
    ctrlp2();	!if there is a line, go back to it
    start_getind();
    if inlist(OneLineIndentSymbols,elinep,.start) then
    ctrln2();
    start_getind();
    if inlist(BeginSymbols,linep,.start) then xiudent_1
    if inlist(StickOutSymbols,linep,.start) then
    untabline();
    if .endflag and not .indend then untabline();
    calcind();	!calculate the new indentation.
    ctrle();
    insertchar("?M");
    doend();		!do the indentation.
MODES.BLI	
G Global Routine myspace = begin local cpos;
    if (.hend neq .hbot) and getchxr(.lowend) neq "?M" then return;
    ctrla();	!get back
    if getchxr(.lowend) eql "?M" then exitloop;
    cpos_updatecursor(getchxr(.lowend),.cpos);
    moveforward(1)
    while (.lowend gtr 1) and (getchxr(.lowend-1) eql " ") do delback();
    cpos_getchxr(.lowend-1);
    if whitespace(.cpos) then exitloop;
    moveback(1)
    while (.lowend gtr 1) and (getchxr(.lowend-1) eql " ") do delback();
    insertchar("?M");
    ctrle();	!skip over what we have
G Global Routine text = begin local tp;
    approc("?M",myspace);		! Myret == Myspace
    approc(" ",myspace);
    setproc("?J",mycj);
G Global Routine Bliss = begin
    setproc("?J",mylf);
G Global Routine docomment = begin local temp,goal;
    temp_getpos();
    ctrle();		!move to the end
    insertchar(" ");
    insertchar("?I");
    temp_updatecursor("?I",.temp);
    insertchar("!");
G Global Routine getpos = begin
    ctrla();
    if getchxr(.lowend) eql "?M" then return .temp;
    if getchxr(.lowend) eql "?L" then return .temp;
    temp_updatecursor(getchxr(.lowend),.temp);
    ctrlf()
G Global Routine MetaBS = begin
    ctrle();
    temp_getpos();		       !the position of the cr.
    insertchar(" ");
G Global Routine untabline = begin
    getind();
    ctrla();
    while horizspace(getchxr(.lowend)) and .hbot neq .hend do
    delforward();
    doend();
    ctrle()
G Global Routine tabline = begin
    getind();
    ctrla();
    while horizspace(getchxr(.lowend)) and .hbot neq .hend do
    delforward();
    doend();
    ctrle()
G Global Routine allwhite = begin local tc;
    ctrla();
    tc_getchxr(.lowend);
    if not whitespace(.tc) then return 0;
    ctrlf();
G Global Routine stringp (astring,wordp) = begin local tc,tp,cpos;
    if .wordp and not wbreak(getchxr(.lowend-1)) and .lowend neq 1 then
    tc_scani(tp);
    if getchxr(.cpos) neq .tc then return 0;
    if (.wordp and not wbreak(getchxr(.cpos)))
G Global Routine linep (keyword)= begin local tp,cc;
    ctrla();	!get to the left margin
    cc_getchxr(.lowend);
    if stringp(.tp,1) then return 1;
    if stringp(commentstring,0) then return 0;
    if getchxr(.lowend) eql "?M" then return 0;
    if getchxr(.lowend) eql "?L" then return 0;
    ctrlf();
G Global Routine elinep (keyword) = begin local nblank,tp,cc;
    ctrla();
    cc_getchxr(.lowend);
    if stringp(commentstring,0) then exitloop;
    if getchxr(.lowend) eql "?M" then exitloop;
    if getchxr(.lowend) eql "?L" then exitloop;
    if not wbreak(getchxr(.lowend)) then nblank_1;
    ctrlf()
    if .nblank then metab();
    if stringp(.tp,1) then return 1;
G Global Routine getind  = begin
    ctrla();		!get back to the beginning
    while getchxr(.lowend) eql "?I" do begin
    moveforward(1)
    while getchxr(.lowend) eql " " do begin
    moveforward(1)
G Global Routine calcind = begin
G Global Routine doend  = begin
    insertchar("?I");
    incr i from 1 to .spacect do insertchar(" ");
G Global Routine mylf  = begin local endflag,tc;
    if allwhite() then begin
    ctrla();
    insertchar("?M");
    ctrle();
    if linep(keyend) then begin
    else if elinep(keythen) then xiudent_1
    else if elinep(keyequal) then xiudent_1
    else if elinep(keydo) then xiudent_1
    else if elinep(keyof) then xiudent_1
    else if elinep(keyset) then xiudent_1
    else if elinep(keyelse) then xiudent_1;
    ctrla();
    ctrlp2();	!if there is a line, go back to it
    if elinep(keythen) then xiudent_.xiudent-1
    else if elinep(keyelse) then xiudent_.xiudent-1
    else if elinep(keyequal) then xiudent_.xiudent-1
    else if elinep(keydo) then xiudent_.xiudent-1;
    ctrln2();
    if linep(keybegin) then xiudent_1;
    if .endflag and not .indend then untabline();
    getind();	!get the indentation
    calcind();	!calculate the new indentation.
    ctrle();
    insertchar("?M");
    doend();		!do the indentation.
G Global Routine toleft = begin
    if .mark eql 0 then return ctrlg();
    ctrla();
    ctrlxx();
    ctrla();
    if .mark gtr .lowend then ctrlxx();	   !get mark less than lowend
    incr i from 1 to .trep do untabline();
    ctrlp2();		       !move back one line.
    if .lowend eql 1 then return untabline();
G Global Routine toright = begin
    if .mark eql 0 then return ctrlg();
    ctrla();
    ctrlxx();
    ctrla();
    if .mark gtr .lowend then ctrlxx();	   !get mark less than lowend
    incr i from 1 to .trep do tabline();
    ctrlp2();		       !move back one line.
    if .lowend eql 1 then return tabline();
G Global Routine mycj = begin local tabct,timect;
    ctrla();		!get back to the beginning
    while getchxr(.lowend) eql "?I" do begin
    moveforward(1)
    while getchxr(.lowend) eql " " do begin
    moveforward(1)
    ctrle();	!go to the end of the line again.
    insertchar("?M");	!insert a cr.
    incr i from 1 to .tabct do insertchar("?I");
    incr i from 1 to .timect do insertchar(" ")
G Global routine metam = begin local tp,glbuffer[100],thack;
    ToPrompt(plit asciz 'Mode Package: ');
    getstr(.tp);
    if not (filescan (tp,modblk)) then return ctrlg();
    if .flush then return ctrlg();
    sixbit'bliss':		bliss();
    sixbit'text':		text();
    sixbit'abbrev':		abinit();
    sixbit'init':		initdispatch();
    sixbit'pascal':		pascal();
    ErrStr(plit asciz'Bad mode, one of (bliss text init abbrev pascal)');
IDLINE.BLI	
    CSTlin = -1,	! Cost of redrawing a line		(?)
    CSTchr =  1,	! Cost of outputting a character	(1)
    CSTpos =  4,	! Cost of repositioning the cursor	(4)
    CSTdel =  5,	! Cost of deleting a line		(5)
    CSTins =  5,	! Cost of inserting a line		(5)
    CSTclr =  2;	! Cost of clearing to end of line	(2)
R Routine cost(i,j) =
R Routine draw(i) = if .nhash[.i] eql 0 then 0 else .CSTchr*(.nhash[.i]^(-18));
R Routine merge (cstyle,comptr) = begin
G Global routine caliad (argplace) = begin local a,b,temp,tdir,netpos,dist;
    tc_getchxr(.place);	!get the char
    dyn[.i,0]_if .i geq 1 then .CSTins+.CSTpos+.dyn[.i-1,0]+Draw(.i)
    dyn[.i,.j]_.dyn[.i-1,.j-1]+Cost(.i,.j);
    temp_.dyn[.i-1,.j]+.CSTins+.CSTpos+Draw(.i);
    temp_.dyn[.i-1,.j]+Draw(.i);
    goxy(.physpos,.wndsiz[.curwin]+.scroff-.netpos+1);
    dellin(.netpos);
    goxy(.physpos,.temp);
    merge(1,.comptr);
    merge(2,.comptr);
    goxy(.physpos,1-.a+.scroff+.xpos[.i]);
    inslin(.dif);
    goxy(.physpos,1-.a+.xpos[.i]+.scroff);
    dellin(.dif);
    goxy(.physpos,.wndsiz[.curwin]+.scroff+.netpos+1);
    inslin(-.netpos);
    goxy(.physpos,.temp);
WINDOW.BLI	
G Global routine winit = begin
    ttyin2();			       !setup line lengths.
G Global routine wset (awindow) = begin
    (bfblk1+4)_getppn();
    combuf(0);		       !go there.
    moveback(.lowend-.wndlow[.curwin]);
    moveforward(.wndlow[.curwin]-.lowend);
G Global routine uctrlc = begin local ctr;
    redisp(0);			       !ensure things are nice first.
    ToPrompt(plit asciz 'Too many windows');
    if .curline leq 0 then return ctrlg();
    if .wndsiz[.curwin]-.curline-1 leq 0 then return ctrlg();
    ctrlp2();			       !back up a line.
    goxy(1,.physlin);
    WhiteLine();
    writestring(separator);
    normalvideo();
    wset(.ctr);			       !switch to the new window.
G Global routine ctrll  = begin local lastdone,oldwin;
    defwindow(1,1,.linesz,.modpos+.echosize);
    clearscreen();
    defwindow(1,1,.linesz,.modpos+.echosize);
    goxy(1,.i);
    WhiteLine();
    writestring(separator);
    normalvideo();
    wset(.lastdone);
    redisp(0);	       !0 means do not watch for ttyio.
    wset(.oldwin);		       !reset the window now.
G Global routine uctrlp = begin local nextwindow;
    if .nextwindow eql -1 then return ctrlg();    !no previous window.
    wset(.nextwindow);		       !otherwise go there.
G Global routine uctrln = begin local nextwindow;
    if .nextwindow eql -1 then return ctrlg();    !no previous window.
    wset(.nextwindow);		       !otherwise go there.
G Global routine uctrld = begin local nextwindow,reali,backp;
    if .nextwindow eql -1 then return ctrlg();
    wset(.nextwindow);
G Global routine metalc = begin
    if getchxr(.lowend-1) eql "?L" then exitloop;
    moveback(1);
G Global routine Lastpage = begin local c;
    If getchxr(.c) eql "?L" then exitloop;		! Backup past ^L
    If getchxr(.c) neq "?L" then return ctrlg();	! If none "Error"
    if getchxr(.c-1) eql "?L" then exitloop;	! Backup to next ^L
    moveback(.lowend-.c);				!  and do the work!
G Global routine metarc = begin
    if getchxr(.lowend) eql "?L" then exitloop;
    moveforward(1);
G Global routine Nextpage = begin
    moveforward(1);
    if getchxr(.lowend-1) eql "?L" then exitloop;	! Move past ^L
    If getchxr(.lowend-1) eql "?L" then begin
    moveback(.lowend-.c);
    return ctrlg();
G Global routine ctrlx2 = begin local ctr;
    if .inwind then redisp(0);	       !fix up screen first.
    ToPrompt(plit asciz 'Too many windows');
    else curline_ if .repcount+1 gtr .wndsiz[.curwin] then return ctrlg()
    if .curline-1 leq 0 then return ctrlg();
    if .wndsiz[.curwin]-.curline leq 0 then return ctrlg();
    goxy(1,.curline+.scroff);
    WhiteLine();
    writestring(separator);
    normalvideo();
    wset(.ctr);
G Global routine uctrlz = begin
    if .nextwindow eql -1 then return ctrlg();    !no following window.
    if .savarg geq .wndsiz[.nextwindow] then return ctrlg();
    if .savarg eql 1 then ctrll();
    wset(.oldwin);
G Global routine ctrlxz = begin
    if .savarg geq .wndsiz[.curwin] then return ctrlg();
    if .nextwindow eql -1 then return ctrlg();
    if .savarg eql 1 then ctrll();
    wset(.oldwin);		       !go back to original window
G Global routine metabang = begin
    incr i from 1 to .curline-1 do ctrlz();
FILESC.BLI	
R Routine SCAN(BLOCK)=
R Routine ASCIITOSIX=
R Routine TYPE=
R Routine GETSIX=
    DO GETCHAR WHILE TYPE() EQL 1;
    THEN REPLACEI(BP,ASCIITOSIX())
    DO GETCHAR UNTIL TYPE() NEQ 4;
    IF GETSIX() EQL 3 THEN		! If it's a colon
    GETSIX()
    IF TYPE() EQL 0 THEN RETURN 1+.C^18;
    GETSIX();
    IF TYPE() EQL 0 THEN RETURN 1+.C^18;
    IF REPLACEI(BP,GETCHAR) EQL "]" THEN EXITLOOP .BP_0) NEQ 0
    DO GETCHAR UNTIL TYPE() EQL 0;
    IF (BLOCK[WPPN]_CMUDEC(PPNBUF<0,0>)) EQL 0 THEN RETURN 6+.C^18;
    IF TYPE() EQL 0 THEN EXITLOOP BLOCK[RPPN]_.R;
    UNTIL TYPE() EQL 0 DO GETCHAR;
R Routine GETCH=ILDB(VREG,PTR);
G Global ROUTINE FILESCAN(P,BLOCK)=
    TEMP_SCAN(.BLOCK);
SYMS.BLI	
R Routine WrtRadix(OutNum,OutRadix) =
    replacei(StrPtr,"-");
    then replacei(StrPtr,"0")
    replacei(StrPtr,(.Digits[.Index]+"0"));
    replacei(StrPtr,0);			! don't forget to end with a zero
    writestring(OString<36,7>);		! write it on the screen
G Global Routine WrtNum(OutNum) = WrtRadix(.Outnum,10);
G Global Routine WrtOct(Outnum) = WrtRadix(.Outnum,8);
G Global routine GetSymbol(TableAddr)=
    char _ readch();	! get a character
    if (.char eql #177) or (.char eql #010) then begin
    goxy(.physpos-1,.physlin);
    goxy(.physpos-1,.physlin);
    clearline();			! clear after prompt
    ctrlg();	! give error
    clearscreen();
    goxy(1,.index);
    writestring(..i);
    writestring(plit asciz ' [');
    wrtnum(...i);
    writestring(plit asciz ']');
    goxy(1,.index);
    writestring(plit asciz '--More????--');
    char _ readch();
    clearscreen();
    goxy(1,.index);
    writestring(plit asciz '--Type any character to return??--');
    char _ readch();
    ctrll();
    SymNam[.I] _ readch();
    ctrlg();	! give error
    return -1;	! exit routine
    writeloss(.char);
    ctrlg();				! error zero length symbol
    while (scani(CPtr) neq 0) do begin
    Tmp1 _ scann(CPtr);			! ** Use lowercase to compare **
    if scann(Cptr) eql 0 then begin		! found exact match
    ctrlg();				! Give error
    ctrlg();				! ambigious error
    goxy(.physpos-.SymLen,.physlin);	! move cursor back over symbol
    writestring(..i);			! write real name out
    writestring(OldPrmpt);			! message for old value
    wrtnum(...i);
    WriteString(ValPrmpt);			! prompt for a value
    char _ readch();	! get a character
    goxy(.physpos-1,.physlin);
    clearline();
    writeloss(.char);
    writeloss(.char);
    ctrlg();	! error
    ctrlg();
    writeloss("$");
G Global routine GetRoutine(TableAddr)=
    char _ readch();		! get a character
    goxy(.physpos-1,.physlin);
    goxy(.physpos-1,.physlin);
    clearline();		! clear after prompt
    ctrlg();	! give error
    clearscreen();
    goxy(1,.index);
    if ..(.i+1) neq 0 then writestring(plit asciz'    ');
    writestring(..i);
    goxy(1,.index);
    if ..i neq 0 then writestring(Plit asciz '--More--')
    else writestring(plit asciz '--Type any character to finish--');
    char _ readch();
    then return (ctrll();-1);
    clearscreen();
    else if (.char eql "?Q") then begin		! ** found quote character
    SymNam[.I] _ readch();
    ctrlg();	! give error
    writeloss(.char);
    ctrlg();	! error zero length symbol
    while (scani(CPtr) neq 0) do begin
    Tmp1 _ scann(CPtr);			! ** Use lowercase to compare **
    if scann(Cptr) eql 0 then begin		! found exact match
    ctrlg();				! Give error
    ctrlg();				! ambigious error
    writeloss("$");
HELP.BLI	
G Global routine metaquest = begin
    clearscreen();
    outstr(tp);
    outstr(tp);
    tp_readch();
    if .tp neq " " then return ctrll();
    clearscreen();
    outstr(tp);
    tp_readch();
    if .tp neq " " then return ctrll();
    clearscreen();
    outstr(tp);
    tp_readch();
    if .tp neq " " then return ctrll();
    clearscreen();
    outstr(tp);
    tp_readch();
    if .tp neq " " then return ctrll();
    clearscreen();
    outstr(tp);
    outstr(tp);
    tp_readch();
    if .tp neq " " then return ctrll();
    clearscreen();
    outstr(tp);
    outstr(tp);
    tp_readch();
    if .tp neq " " then return ctrll();
    clearscreen();
    outstr(tp);
    outstr(tp);
    tp_readch();
    return ctrll();
GETSTR.BLI	
G Global routine getstring(pointer) =
    char _ readch();
    IF Isctrlchar(scann(tmpointer)) THEN
    goxy(.physpos - 1,.physlin);
    INCR index from 1 to .charcount DO Incp(tmpointer);
    goxy(.PhysPos - 1,.physlin);
    clearline();
    CtrlQ:	(char _ readch();
    replacei(tmpointer,.char);
    writeloss(.char);
    goxy(.origphyspos,.physlin);
    writeloss(scani(tmpointer));
    goxy(.origphyspos,.physlin);
    clearline());
    ReplaceI(tmpointer,.char);
    writeloss("$");
    flubfr();
JUST.BLI	
G Global routine pbreak (i) = begin
    char _ getchxr(.i);
    char _ getchxr(.i+1);
R Routine aebreak (i) = begin
    char _ getchxr(.i);
G Global routine apbreak (i) = begin
    char _ getchxr(.i);
    if getchxr(.i-1) neq "?M" and getchxr(.i-1) neq "?L"
    if getchxr(.i-2) eql "?M" or getchxr(.i-2) eql "?L"
    else if getchxr(1) eql "?M" then return 1;
R Routine findbreak (i) = 
    if apbreak(.j) then return .j;
R Routine chopline (lastbreak,linpos) = begin
    moveback(.lowend - .lastbreak);
    insertchar("?M");
    moveback(1);
    while getchxr(.lowend - 1) eql " " do delbackward();
    moveforward(1);
G Global routine just (linwid) = begin
    if .hend-.hbot neq 0 then moveforward(1);
    temp_getchxr(.lowend);	! skip over any initial blank lines
    moveforward(1);
    else updatecursor(.temp,.linpos);
    temp_getchxr(.lowend)
    until pbreak(.lowend) do begin		! main justify loop
    char _ getchxr(.lowend);
    if .blankctr eql 0 then delforward()
    moveforward(1);
    insertchar(" ");
    "?M" : setchar(.lowend," ");
    "?I" : setchar(.lowend," ");
    moveforward(1);
    linpos _ updatecursor(.char,.linpos);
    linpos _ chopline(.lastbreak,.linpos);
    else if .char neq ")" then if .char neq ">" then
R Routine emptyline (i) = begin
    temp _ getchxr(.i);
G Global routine metaj = begin
    return ToPrompt(plit asciz 'Empty File');
    ctrla();
    if emptyline(.lowend) then begin
    do ctrln2() while emptyline(.lowend) and .hbot lss .hend;
    while aebreak(.lowend) do ctrln2();
    if emptyline(.lowend) or aebreak(.lowend) then begin
    moveback(.lowend-.topara);
    return ToPrompt(plit asciz 'Nothing to Justify')
    if aebreak(.lowend) then begin
    do ctrln2() while aebreak(.lowend) and .hbot lss .hend;
    if apbreak(.lowend) or emptyline(.lowend) then begin
    moveback(.lowend-.topara);
    do ctrlp2() while aebreak(.lowend) and .lowend gtr 1;
    if emptyline(.lowend) or aebreak(.lowend) then begin
    moveforward(.topara-.lowend);
    return ToPrompt(plit asciz 'Nothing to Justify')
    fbr _ findbreak(.lowend);
    if .fbr lss .lowend then moveback(.lowend - .fbr);
    while aebreak(.lowend) and .hbot lss .hend do ctrln2();
    if emptyline(.lowend) then begin
    moveforward(.topara-.lowend);
    return ToPrompt(plit asciz 'Nothing to Justify')
    just(.justwidth);
    if getchxr(.lowend) neq "?M" then ctrlf();
R Routine fwdtovis =
    (getchxr(.lowend) eql "?M" or getchxr(.lowend) eql " " or
    getchxr(.lowend) eql "?I" or getchxr(.lowend) eql "?L") do
    moveforward(1);
R Routine tostartpar = begin
    until apbreak(.lowend) do ctrlp2();
    if aebreak(.lowend) then ctrln2();
    fwdtovis()
R Routine uponepar = begin
    else if aebreak(.lowend) then ctrlp2()
    else if emptyline(.lowend) eql 0 then return (ctrle())
    else if .blanksw eql 1 then return(moveforward(.omark-.lowend))
    do ctrlp2() while emptyline(.lowend) and .lowend gtr 1;
    if aebreak(.lowend) eql 0 then return(ctrle());
    ctrle();
    ctrlp2()
G Global routine metalb = begin
    else if .lowend eql 2 then return(moveback(1));
    moveback(1);
    temp _ getchxr(.lowend);
    moveforward(1);
    ctrla();			!start on a paragraph break?
    breakleft _ apbreak(.lowend);
    comleft _ aebreak(.lowend);	!start on a Scribe command ?
    if .comleft eql 0 then return(tostartpar())
    do ctrlp2() while aebreak(.lowend) and .lowend gtr 1;
    if emptyline(.lowend) then begin
    ctrln2();
    return(fwdtovis())
    else return(ctrle())
    ctrlp2();
    if aebreak(.lowend) eql 0 then return(tostartpar())
    else return(uponepar());
    if .comleft eql 0 then begin ctrlp2(); return(uponepar()) end;
    ctrlp2();
    if aebreak(.lowend) or emptyline(.lowend) then return(uponepar())
    else return(ctrle())
R Routine toendpar = begin
    do ctrln2() until apbreak(.lowend) or emptyline(.lowend) or
    if .hbot lss .hend then ctrlp2();
    ctrle()
R Routine downonepar = begin
    blanksw _ emptyline(.lowend);
    ctrln2();
    else if emptyline(.lowend) then
    if .blanksw eql 2 then return(moveback(.lowend-.omark))
    else if aebreak(.lowend) eql 0 then return(fwdtovis())
G Global routine metarb = begin
    ctrla();
    while emptyline(.lowend) and .hbot lss .hend do ctrln2();
    editp _ aebreak(.lowend);
    ctrle();
    if .editp eql 0 then return(toendpar())
    ctrla();
    while aebreak(.lowend) and .hend neq .hbot do
    ctrln2();
    if .hend eql .hbot then return (ctrle())
    else if emptyline(.lowend) then begin
    ctrlp2();
    return(ctrle())
    else return (fwdtovis());
    ctrln2();
    if apbreak(.lowend) or emptyline(.lowend) then downonepar()
    else toendpar()
G Global routine ctrlz = begin
    metacp();		!go down to the end of the screen.
    incr i from 1 to .orepcount do ctrln2();
    if .ocurline-.orepcount gtr 0 then ctrlxx();
G Global routine metaz = begin
    metacp();		!go down to the end of the screen.
    incr i from 1 to .orepcount do ctrlp2();
    if .ocurline+.orepcount leq .scrsze then ctrlxx();
G Global routine ctrlar = begin
    if .hend eql .hbot then return ctrlg();
    char _ getchxr(.lowend);
    then setchar(.lowend,.char-32)
    then setchar(.lowend,.char+32);
    ctrlf();
G Global routine metaar = begin
    while .hend neq .hbot and whitespace(getchxr(.lowend)) do ctrlf();
    ctrlar();
    if .hbot eql .hend then return zapmac();
    if wbreak(getchxr(.lowend)) then exitloop;
G Global routine metcar = begin
    if .mark eql 0 then return ctrlg();
    if .mark leq .lowend then ctrlxx();
    incr i from .lowend to .mark-1 do ctrlar();
G Global routine metak = begin
    if .hend eql .hbot then return ctrlg();
    (getchxr(.lowend) eql " " or getchxr(.lowend) eql "?I")
    do delforward();
MLOAD.BLI	
G Global routine metal = begin local tc,qbp,tp;
    ToPrompt(plit asciz 'Macro buffer to load:');
    tp_readch();
    if .tp lss "a" or .tp gtr "z" then return ctrlg();
    qbp_qreg(.tp);		       !get the byte pointer.
    metalt();			       !get to the start of the buffer.
    replacei(qbp,getchxr(.lowend));
    moveforward(1);
    replacei(qbp,.Xprefix);	       !the escape.
    replacei(qbp,")");		       !the pea.
ISERCH.BLI	
    Module Isrch(optimize) = begin
R Routine wgoxy (x,y) = begin
    defwindow(1,1,.linesz,.modpos+.echosize);
    goxy(.x,.y);
G Global Routine SrchString(Prmpt)= Begin
    ToPrompt(.Prmpt);
    writeloss(#136);	!up arrow
    writeloss(.sst[.I]+#100)
    end else writeloss(.sst[.I]);
    FluBfr();
R Routine ISDel = Begin
    If .ISFlag gtr 0 then Moveback(1);
    If .CSnum eql CST then wgoxy(.savpos-1,.savlin);
    wgoxy(.savpos-2,.savlin);
    If .Csnum eql CST then clearline();
    Moveback(.Ind-1);
    If not therep(sst,.lowend) then (moveforward(.ind-1);return);
    Moveforward(.Ind-1);
    SrchString (plit asciz 'I-Search:');
R Routine IRDel = Begin
    If .CSnum eql CST then wgoxy(.savpos-1,.savlin);
    wgoxy(.savpos-2,.savlin);
    If .Csnum eql CST then clearline();
    If Not Therep(sst,.lowend) then return;
    Srchstring (plit asciz 'Reverse I-Search:');
R Routine Iesc = Begin local i;
    If .csnum eql CST then wgoxy(.savpos,.savlin);
    Writeloss("$");
    flubfr();
R Routine iserch= begin
    If .csnum eql CST then wgoxy(.savpos,.savlin);
    writeloss(#136);	!up arrow
    writeloss(.comchar+#100)
    else writeloss(.comchar);
    FluBfr();
    moveback(.Ind-1);
    if therep (sst,.i) then begin
    moveforward(.i+.Ind-.lowend-1);
    moveforward(.ind-1);
    If .csnum eql CST then putch("?G");
    Srchstring (plit asciz 'Failing I-Search:');
R Routine ISquote = Begin
    Comchar_Readch();
    Iserch();
R Routine IRserch= begin 
    If .Isflag eql 2 then (Ind_1;  ! iF first time reset ind
    Isflag_1);
    If .csnum eql CST then wgoxy(.savpos,.savlin);
    writeloss(#136);	!up arrow
    writeloss(.comchar+#100)
    else writeloss(.comchar);
    FluBfr();
    moveforward(.ind-1);
    if therep (sst,.i) then begin
    moveBack(.lowend-.i);
    moveback(.ind-1);
    If .csnum eql CST then putch("?G");
    Srchstring (plit asciz 'Failing Reverse I-Search:');
R Routine IRquote = Begin
    Comchar_Readch();
    IRserch();
R Routine ISNext= Begin local i;
    Srchstring(plit asciz 'I-Search:'));
    if therep (sst,.i) then begin
    moveforward(.i+.Ind-1-.lowend);
    If .csnum eql CST then putch("?G");
    Srchstring (plit asciz 'Failing I-Search:');
R Routine IRNext= Begin local i;
    Srchstring(plit asciz 'Reverse I-Search:'));
    if therep (sst,.i) then begin
    moveBack(.lowend-.i);
    If .csnum eql CST then putch("?G");
    Srchstring (plit asciz 'Failing Reverse I-Search:');
R Routine rtos = Begin local I;
    Srchstring (plit asciz 'I-Search:');
    ISNext();
R Routine stor = Begin
    Srchstring (plit asciz 'Reverse I-Search:');
    IRNext();
G Global routine Ictrls = begin
    ToPrompt(plit asciz 'I-Search:');
G Global routine IctrlR = begin
    ToPrompt(plit asciz 'Reverse I-Search:');
CCL.BLI	
G Global routine cclstuff = begin
    if dotmpcor(sixbit 'EDT',2,xbuffer,30) lss 0 then
    dotmpcor(sixbit 'EDS',2,xbuffer,30);
    if not (filescan (tp,filblk)) then return ctrlg();
    filbuf();			! do common stuff [located in BUFFER]
G Global routine cclmultix = begin
    incp(tp);
    if scani(ep) eql "!" then begin
    replacen(ep,"?M");	!bash ! to ?m
    if scann(ep) eql 0 then if .xeflag then cucl() else quit();
    if not (filescan (tp,filblk)) then return ctrlg();
    jrst(4,0);
G Global routine ctrlxi = begin local glbuffer [100];
    ToPrompt(plit asciz'Insert File: ');
    getstr(.tp);
    if not (filescan (tp,lfilblk)) then return ctrlg();
    if .flush then return ctrlg();
    open (2,0,.lfilblk,dskbfh<0,0>);
    buffers (2,1,1,dskbuf); !get a disk buffer formatted.
    if realup(lfilblk+1) then begin
    incr i from 1 to .lowend-1 do incp(tp);
    munchi (.tp);
    else ToPrompt(plit asciz'File not found.');
    close (2);
DISPAT.BLI	
G Global routine initdispatch = begin
   (|