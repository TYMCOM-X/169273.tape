BASE 0

GLOBAL %BCHARG

%BCHARG

!REQUIRES WF LICENSE TO WRITE INTO *1BATCH

FIND %BYPT, %INIT.TTY, %CHOOSE, %CHR.OUT, %DATOUT, %GETNUM, %GETTOKEN
LOCAL %GSYSNO, %GET.PASS, %FIX.REQ.INF, %MAKE.REQ
FIND %NUMOUT, %QUERY, %LISTABLE, %OUT, %MAKE.SIXBIT, %GETULC
FIND %HASH

FIND TOKEN(0), PNAME(0), FILNO, RETADR
FIND PJ.ACTG.SYS, PJ.THIS.SYS

GLOBAL CH.OUT, P, NUMBER

LOCAL %READ.REQ, %TYPE.DOLLAR, %CHANGE.FLAG, %FIND.PRO
LOCAL %INIT.BCHARG, %CALL.UUO, %REQ.OUT, %OPEN.CHG.OR.CAN, %ONE.OUT
LOCAL %SEARCH, %GET.BILL.INF, %BILL.IT, %NUM.TO.ASCII, %INPUT.INF
LOCAL %ASCII.TO.NUM, %HEAD.OUT, %LIST.UNPROC, %DATE.IN, %TYPE.IT
LOCAL %DOLAR.IN, %IN.NUM, %MAKE.TIME, %GET.NEW.REQ, %FIND.LUD
LOCAL %QUERY1

LOCAL CH.IN, CH.NEW, OLDCP, RECORD(85), OP.NAME.IN, OPER.NAME(3)
LOCAL TEMP, T, IOTAB(40), ACTPPN, BATCHG, BATCAN, CMD, TYP.LST, THIS.REQ
LOCAL PTR, SYS.NO, REQ, THIS.MON, THIS.DATE, FLAG, N.TYPES, U.DIST
LOCAL SAVE.MONTH, FIRST.CP, USER(2), SPECIAL.FLG, L.INDEX, L.BLK(128)
LOCAL YEAR, MONTH, DAY, FND.FLG, J.TYPE, SYS.NAME
LOCAL LAST.CP, LAST.REQ, F.FLG
LOCAL EOFRET	!IF NON-ZERO, ON END OF FILE RETURN HERE
LOCAL NO.REQS	!=-1 IF NOT SEARCHING
		!=0 IF SEARCHING AND NONE FOUND YET
		!>0 IF SEARCHING AND SOME REQ. FOUND
LOCAL HOLFLG	!POSITIVE IF THIS IS A HOLD REQUEST

!Removed: ITSR #900700 1.13.82 kmd

LOCAL FRN.FLG  ! 1 IF DISTRICT 7 (FRANCE)
LOCAL SEEN.TMP.MSG ! ZERO IF WE HAVEN'T PRINTED THE TEMP. MESSAGE
DEF MAX.JOB.TYPES AS 10
DEF B.MAX AS 9
DEF SZ.B.ENTRY AS B.MAX

DEF SIZE.B.INF AS SZ.B.ENTRY * MAX.JOB.TYPES
LOCAL B.INDEX, B.INF(SIZE.B.INF)

LOCAL GETCMD:, CHK.ERR:, PUR.ERR:, REN.ERR:, RECRET:, POSRET:
LOCAL CHARGE.IT:, FIND.ERR:, L.REQ.ERR:, L1.REQ.ERR:

!COMMANDS
DEF N.CMDS AS 9
DEF HELP AS 1
DEF LIST AS 2
DEF PURGE AS 3
DEF VOID AS 4
DEF CHARGE AS 5
DEF POSTAGE AS 6
DEF RECHARGE AS 7
DEF CREATE AS 8
DEF QUIT AS 9

!LISTING COMMANDS
DEF N.LST.CMDS AS 3
DEF PROC AS 1
DEF UN.PROC AS 2
DEF L.CAN AS 3
DEF L.REQ AS 4

!SOME FLAGS
DEF L.ZERO AS 0	!NEED LEADING ZEROES
DEF NO.L.ZERO AS 1	!DO NOT WANT LEADING ZEROES
DEF NEED.YR AS 0	!WANT YEAR TO BE INCLUDED IN DATE
DEF NO.YR AS 1		!DO NOT WANT YEAR TO BE NCLUDED IN DATE
LOCAL NO.CENTS		!AMOUNT IN DOLLARS ONLY IF # 0
LOCAL HEAD.FLG
   DEF NEED.HEAD AS -1

!NUMBER OF WORDS IN A RECORD
DEF N.WORDS AS 17

!JOB TYPES
DEF LISTING AS 1
DEF CARD.READ AS 2
DEF CARD.PUNCH AS 3
DEF TAPE.READ AS 4
DEF TAPE.WRITE AS 5
DEF TAPE.CONV AS 7
DEF ALIEN AS 8
DEF TAPE.370 AS 12
DEF PSTGO.370 AS 13
DEF MAX.TYPE AS 8

!VALUES TO BE INPUT FOR CHARGES
DEF B.COM.DATE AS 1
DEF B.J.TYPE AS 2
DEF B.VOLUME AS 3
DEF B.P.PAPER AS 4
DEF B.DECOLL AS 5
DEF B.T.PURCH AS 6
DEF B.PSTG AS 7
DEF B.TP.CNV AS 9

!PTRS FOR RECORD
DEF POINTER(A,B) AS CHPT(RECORD+A,B)
DEF R.SYS AS POINTER(0,-1)	!SYSTEM NUMBER (OR FLAG)
DEF R.REQ AS POINTER(0,1)	!REQUEST NUMBER
DEF R.MON.R AS POINTER(1,-1)	!MONTH REQUESTED
DEF R.DAY.R AS POINTER(1,1)	!DAY REQUESTED
DEF R.HOUR.R AS POINTER(1,3)	!HOUR REQUESTED
DEF R.MIN.R AS POINTER(2,0)	!MINUTE REQUESTED
DEF R.USER AS POINTER(2,2)	!USER NAME
DEF R.PPN AS POINTER(5,-1)	!PPN
DEF R.DIST AS POINTER(7,1)	!DISTRICT
DEF R.PROJ AS POINTER(8,-1)	!PROJECT CODE
DEF R.C.FLAG AS POINTER(10,1)	!INHOUSE/CUSTOMER FLAG
DEF R.JOB.TYPE AS POINTER(10,2)	!JOB TYPE
DEF R.VOLUME AS POINTER(11,-1)	!VOLUME
DEF R.TP.CNV AS POINTER(12,0)	!# OF TAPES CONVERTED
DEF R.PARTS AS POINTER(12,0)	!NUMBER OF PARTS OF PAPER
DEF R.DECOLL AS POINTER(12,2)	!=1 IF THERE IS A DECOLL CHARGE
DEF R.PSTG AS POINTER(13,-1)	!DELIVERY CHARGES
DEF R.T.PURCH AS POINTER(14,-1)	!# OF TAPES PURCHASED

DEF R.DATE AS POINTER(15,1)	!PROCESSED DATE
DEF R.CRLF AS POINTER(16,2)

!SIZE OF FIELDS
DEF SZ.SYS AS 2
DEF SZ.REQ AS 3
DEF SZ.USER AS 12
DEF SZ.MON AS 2
DEF SZ.YEAR AS 2
DEF SZ.DAY AS 2
DEF SZ.HOUR AS 2
DEF SZ.MIN AS 2
DEF SZ.PPN AS 12
DEF SZ.GAN AS 6
DEF SZ.DIST AS 3
DEF SZ.PROJ AS 12
DEF SZ.J.TYPE AS 2
DEF SZ.VOLUME AS 6
DEF SZ.TP.CNV AS 4
DEF SZ.T.PURCH AS 7
DEF SZ.PARTS AS 2
DEF SZ.DECOLL AS 1
DEF SZ.PSTG AS 5
DEF SZ.COMP.DATE AS 6
DEF SZ.DUMMY AS 30
DEF BAK.DIR AS '(*1BATCH)PARCHG.BAK'
DEF NUM.DIR AS '(*1BATCH)REQNUM.DAT'

DEF NEW.DIR AS '(*1BATCH)PARCHG.NEW'
DEF DAT.DIR AS '(*1BATCH)PARCHG.DAT'
DEF CHG.DIR AS '(*1BATCH)BATCHG'
DEF CAN.DIR AS '(*1BATCH)BATCAN'

GLOBAL TABLE CMDS(1:N.CMDS)&
   ['HELP','LIST','PURGE','VOID','CHARGE','POSTAGE','RECHARGE',&
	'CREATE','QUIT']

GLOBAL TABLE LST.CMDS(1:N.LST.CMDS)['PROCESSED','UNPROCESSED','VOIDED']

DEF MIN.YEAR AS 75
DEF MAX.YEAR AS 99
DEF MAX.DAY AS 31
DEF MAX.MONTH AS 12

GLOBAL TABLE MONTHS(1:MAX.MONTH)['JANUARY','FEBRUARY','MARCH','APRIL','MAY',&
   'JUNE','JULY','AUGUST','SEPTEMBER','OCTOBER','NOVEMBER','DECEMBER']

!MACROS
DEF ALPHA AS 0
DEF ASCII.ZERO AS $0
DEF ASCII.ONE AS $1
DEF ASK.CORRECT AS QUERY('ALL ENTRIES CORRECT')
DEF ASK.OK AS QUERY('$OKAY')

!Removed: ITSR #900700 1.13.82 kmd

DEF CANCELLED AS ^'01'
DEF CHECK.NO.MORE.IN(A) AS [IF END.OF.LINE THEN A; PCHV P]
DEF CHARGE.ONE AS [ONE.OUT; IF CMD = RECHARGE OR ASK.OK = YES THEN BILL.IT]
DEF CHG.CHOICES AS [NUM.OR; MSG('OR ALL: ')]
DEF CK.NUMBER(A) AS ASCII.ZERO <= A <= $9
DEF COLON AS CHR.OUT($:)
DEF COLON.SP AS MSG(': ')
DEF CR AS CHR.OUT(CARRET)
DEF DATED AS 1
DEF DATUUO AS -OCT 55
DEF DOT AS $.
DEF DOLLAR.SIGN AS $$
DEF DASH AS $-
DEF END.OF.LINE AS TEMP _ NCHV P = EOLIT OR TEMP = CARRET
DEF FLG.CANC AS $1
DEF FLG.PROC AS $2
DEF FROM.THIS.MONTH AS ASCII.TO.NUM(R.MON.R,SZ.MON) = SAVE.MONTH
DEF GET.AMT.AND.CHK(A,B,C) AS [IF INF(A) _ B > C OR INF(A) <= 0 THEN &
   [MSG('$VALUE MUST BE POSITIVE AND LESS THAN '); NUMOUT(C); CR; GO AGN]]
DEF GET.REQ AS [CHECK.NO.MORE.IN(MSG('$ENTER REQUEST NUMBER: ')); &
   GETTOKEN(NUM.ONLY); REQ _ TOKEN(0) BAND REQ.MASK]
DEF GETTAB AS OCT 41
DEF HOLD AS ^'04'
DEF INF(A) AS B.INF(B.INDEX+A)
DEF LICTAB AS -OCT 20
DEF LST.CHOICES AS [NUM.OR; LISTABLE(N.LST.CMDS,LST.CMDS); COLON.SP]
DEF LUD(A) AS L.BLK(L.INDEX+A)
DEF MIN.DEL AS 13	!MINIMUM POSTAGE IF NOT ZERO
DEF MULTI.SPACE(A) AS REPEAT A OUT.SPACE
DEF NEW.LINE AS [WHILE END.OF.LINE THEN P _ GETLINE(TEL); PCHV P]
DEF NO AS 0
DEF NOLIC AS [MSG('$THIS PROGRAM REQUIRES OPER LICENSE.$'); EXIT]
DEF NOPSTG AS &
   [MSG('$THIS REQUEST MUST BE CHARGED BEFORE IT CAN HAVE POSTAGE ADDED.$');&
   GO GETCMD]
DEF NOPST1 AS &
   [MSG('$THIS IS A HOLD COMMAND, USE THE CHARGE COMMAND TO ADD POSTAGE.$');&
   GO GETCMD]
DEF NORECH AS &
   [MSG('$THIS REQUEST MUST BE CHARGED BEFORE IT CAN BE RECHARGED.$');&
    GO GETCMD]
DEF NUM.OR AS MSG('$INPUT A NUMBER, ')
DEF NUM.ONLY AS 1
DEF OPEN.PAR(A,B) AS CH.IN _ OPEN(DAT.DIR,DIRECT+A+WORD,B)
DEF OPEN.TEL AS CH.OUT _ OPEN('TEL',SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)
DEF OPER.BIT AS BYT(CALL.UUO(LICTAB,GETTAB,1),1,15)
DEF OUT.OF.LOOP AS REPEAT 0
DEF OUT.SLASH AS CHR.OUT(SLASH)
DEF OUT.SPACE AS CHR.OUT(SPACE)
DEF OUT.WHERE AS [MSG('$OUTPUT TO: '); GETTOKEN(ALPHA); CLOSE.ALL;&
   CH.OUT _ OPEN(TOKEN,SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)]
DEF PROCESSED AS ^'02'
DEF PSTG.ONLY AS ^'03'
DEF PTR.TO.FLAG AS CHPT(@FLAG,-1)
DEF PTR.TO.OPER AS CHPT(OPER.NAME,-1)
DEF PTR.TO.REQ AS CHPT(@THIS.REQ,-1)
DEF PTR.TO.SYS AS CHPT(@SYS.NO,-1)
DEF QUESTION.MARK AS $?
DEF R.DATE.OUT AS [TYPE.IT(R.MON.R,SZ.MON,L.ZERO); OUT.SLASH;&
   TYPE.IT(R.DAY.R,SZ.DAY,L.ZERO); OUT.SPACE]
DEF REQ.MASK AS OCT 17777777
DEF REQ.TO.BE.DONE AS FLAG # CANCELLED AND FLAG # PROCESSED
DEF SAVE.STR(SIZE, P1) AS [PTR _ P1; P _ CHPT(TOKEN,-1);&
   REPEAT SIZE [IF TEMP _ NCHV(P) = 0 THEN TEMP _ SPACE;&
   NCHV(PTR) _ TEMP]]
DEF SET.DIST AS U.DIST _ ASCII.TO.NUM(R.DIST,SZ.DIST)
DEF SLASH AS $/
DEF SPACE AS $ 
DEF T.ALL AS ^'ALL'
DEF TAP.CHG AS NUM.TO.ASCII(R.T.PURCH,INF(B.T.PURCH),SZ.T.PURCH)
DEF TEXT.OUT(A,B) AS [T _ A; REPEAT B CHR.OUT(NCHV(T))]
DEF UNDATED AS 2
DEF VERSION AS 32.3
DEF WHAT AS [MSG('$?'); GO GETCMD]
DEF WRITE.REQ(A) AS [T _ 0; TEMP _ R.CRLF; NCHV(TEMP) _ CARRET;&
   NCHV(TEMP) _ LNFEED; REPEAT N.WORDS [W(A,RECORD(T)); INC T]]
DEF YES AS 1
DEF ZERO.B.INF AS MOVE SIZE.B.INF FROM ALL 0 TO B.INF
DEF ZERO.HALF.RECORD AS [PTR _ R.JOB.TYPE;&
   REPEAT SZ.DUMMY NCHV(PTR) _ ASCII.ZERO]
!		***  Mainline Code  ***

START: INIT.BCHARG
\\->START
GETCMD: CLOSE.ALL; OPEN.TEL; CR; MSG('$*'); P _ GETLINE(TEL)
   GETTOKEN(ALPHA); IF CMD _ CHOOSE(N.CMDS,CMDS) = NO THEN WHAT
   EOFRET _ HOLFLG _ HEAD.FLG _ NO; NO.REQS _ -1
   SPECIAL.FLG _ IF CMD = RECHARGE OR CMD = CREATE THEN 1 ELSE 0

   DO CMD OF HELP:QUIT

HELP: MSG('$VALID COMMANDS ARE:')
   MSG('$$LIST PROCESSED		OUTPUTS THE FOLLOWING INFO FOR ALL PROCESSED')
   MSG('$			REQUESTS:')
   MSG('$			   REQUEST, GAN, DISTRICT, USER, PROJ-CODE,')
   MSG('$			   TYPE, VOLUME, PARTS, DATE, PSTG, ')
   MSG('$			   DECOLL.')
   MSG('$$LIST UNPROCESSED	OUTPUTS THE FOLLOWING INFO FOR ALL UNPROCESSED')
   MSG('$			REQUESTS:')
   MSG('$			   REQUEST, GAN, DISTRICT, USER, PROJ-CODE,')
   MSG('$			   DATE OF REQUEST.')
   MSG('$			THIS COMMAND CAN INCLUDE A DATE TO ')
   MSG('$			LIST ALL REQUESTS CREATED ON OR ')
   MSG('$			BEFORE THAT DATE.')
   MSG('$$LIST VOID		OUTPUTS THE FOLLOWING INFO FOR ALL VOIDED ')
   MSG('$			REQUESTS:')
   MSG('$			   REQUEST, GAN, DISTRICT, USER NAME, ')
   MSG('$			   PROJ-CODE, DATE REQUESTED, ')
   MSG('$			   AND THE OPER NAME THAT VOIDED THE REQUEST.')
   MSG('$$LIST #			IF REQUEST IS FOUND IN THE UNPROCESSED FILE, ')
   MSG('$			THE INFO IS TYPED FOR AN UNPROCESSED COMMAND.')
   MSG('$			IF NOT FOUND IN THE UNPROCESSED FILE, WILL LOOK')
   MSG('$			IN THE PROCESSED FILE AND LIST THE APPROPRIATE')
   MSG('$			INFO IF FOUND.  IF NOT FOUND WILL SEARCH THE')
   MSG('$			VOIDED FILE AND LIST THE VOIDED INFO.')
   MSG('$$PURGE			REMOVES ALL PROCESSED AND CANCELLED REQUESTS')
   MSG('$			FROM PREVIOUS MONTHS.')
   MSG('$$VOID #			CANCELS THE SPECIFIED REQUEST.')
   MSG('$$CHARGE ALL		INPUTS CHARGES FOR ALL PENDING REQUESTS.')
   MSG('$$CHARGE #		INPUTS CHARGES FOR SPECIFIED REQUEST.')
   MSG('$$POSTAGE			ALLOWS USER TO ENTER POSTAGE FOR A')
   MSG('$			REQUEST THAT IS ALREADY PROCESSED.')
   MSG('$$RECHARGE		ALLOWS OPERATORS TO RECHARGE A REQUEST')
   MSG('$			   THAT HAS ALREADY BEEN CHARGED.')
   MSG('$			   THE OLD CHARGE IS REMOVED.')
   MSG('$$CREATE			ALLOWS OPERATORS TO CREATE A NEW BATCH')
   MSG('$			   REQUEST AND CHARGE IT.')
   MSG('$$QUIT			EXITS FROM PROGRAM.')
   MSG('$$JOB TYPES ARE AS FOLLOWS:')
   MSG('$$1 = LISTING$2 = CARD READ$3 = CARD PUNCH$4 = TAPE READ')
   MSG('$5 = TAPE WRITE$7 = TAPE CONVERSION$$')

!Removed: ITSR #900700 1.13.82 kmd

LIST: CHECK.NO.MORE.IN(LST.CHOICES)
   LOOP DO
	NEWLINE
	IF CK.NUMBER(TEMP) THEN DO
	   GET.REQ; TYP.LST _ L.REQ; OUT.OF.LOOP
	END ELSE DO
	   GETTOKEN(ALPHA)
	   IF TYP.LST _ CHOOSE(N.LST.CMDS,LST.CMDS) = NO THEN &
		[CR; LST.CHOICES] ELSE OUT.OF.LOOP
	END
   END

	DO TYP.LST OF PROC:L.REQ

   UN.PROC: INC NO.REQS; HEAD.FLG _ NEED.HEAD	!LIST UNPROCESSED RECORDS
   IF END.OF.LINE THEN DO
	IF QUERY('ALL') = YES THEN DO
	   OUT.WHERE
	   LIST.UNPROC(UNDATED)	!UNDATED UNPROCESSED RECORDS HERE
	   GO GETCMD
	END
	MSG('$ENTER LIMITING MONTH-DAY: '); NEW.LINE
   END ELSE PCHV(P)
   DATE.IN(NO.YR)
   OUT.WHERE
   LIST.UNPROC(DATED); GO GETCMD	!DATED UNPROCESSED RECORDS HERE

   PROC: INC NO.REQS; HEAD.FLG _ NEED.HEAD
	OUT.WHERE
	OPEN.CHG.OR.CAN(INPUT,BATCHG,CHK.ERR)
	LOOP DO
	   READ.REQ
	   IF FLAG # CANCELLED THEN DO
		REQ.OUT
		INC NO.REQS
	   END
	END

   L.CAN: INC NO.REQS; HEAD.FLG _ NEED.HEAD; OUT.WHERE
   OPEN.CHG.OR.CAN(INPUT,BATCAN,CHK.ERR)
   LOOP [READ.REQ; REQ.OUT; INC NO.REQS]

   L.REQ: HEAD.FLG _ NEED.HEAD; TYP.LST _ UN.PROC
	OPEN.PAR(INPUT,L.REQ.ERR); INC NO.REQS	!LIST A SINGLE RECORD
	SEARCH; REQ.OUT; GO GETCMD
   L.REQ.ERR: IF ERRNUM # EOFERR THEN GO CHK.ERR
	MSG('$NO UNPROCESSED REQUEST BY THAT NUMBER - WILL TRY ')
	MSG('PROCESSED FILE$'); CLOSE(CH.IN)
	TYP.LST _ PROC
	OPEN.CHG.OR.CAN(INPUT,BATCHG,L1.REQ.ERR)
	TYP.LST _ PROC; FND.FLG _ 0
	LOOP [SEARCH; INC FND.FLG;  REQ.OUT; INC NO.REQS]
	L1.REQ.ERR: IF ERRNUM # EOFERR THEN GO CHK.ERR
	   IF FND.FLG # 0 THEN GO GETCMD
	   MSG('$NO PROCESSED REQUEST BY THAT NUMBER - ')
	   MSG('WILL LOOK FOR VOIDED RECORD$'); CLOSE(CH.IN)
	   TYP.LST _ L.CAN
	   OPEN.CHG.OR.CAN(INPUT,BATCAN,CHK.ERR)
	   SEARCH; TYP.LST _ L.CAN; REQ.OUT; GO GETCMD

END

PURGE: OPEN.PAR(UPDATE,PUR.ERR)
   CH.NEW _ OPEN(NEW.DIR,OUTPUT+DIRECT+WORD,CHK.ERR)
   LOOP DO
	READ.REQ
	IF FROM.THIS.MONTH OR REQ.TO.BE.DONE THEN WRITE.REQ(CH.NEW)
   END
   PUR.ERR: IF ERRNUM # EOFERR THEN GO CHK.ERR
	CLOSE.ALL
   REN.OVER: ERRNUM _ 0
	RENAME(DAT.DIR,BAK.DIR,REN.ERR)
   REN.ERR: IF ERRNUM = AEFERR THEN &
	[DELETE(BAK.DIR,CHK.ERR); GO REN.OVER]
   IF ERRNUM # 0 THEN GO CHK.ERR
	RENAME(NEW.DIR,DAT.DIR,CHK.ERR)
	MSG('$PURGE PROCESSED.$')

VOID: CLOSE.ALL
   GET.PASS
   OPEN.TEL
   INC NO.REQS
   GET.REQ; OPEN.PAR(INPUT,CHK.ERR); SEARCH
   IF FLAG = PROCESSED OR FLAG = PSTG.ONLY OR FLAG = HOLD THEN &
	[MSG('$ENTRY ALREADY PROCESSED.$'); GO GETCMD]
   ONE.OUT
   INC NO.REQS
   IF ASK.OK = NO THEN GO GETCMD
   CLOSE(CH.IN)
   CHANGE.FLAG(FLG.CANC,OLDCP)
   OPEN.CHG.OR.CAN(UPDATE,BATCAN,CHK.ERR)
   SETCP(CH.IN,SIZE(CH.IN))
   TEMP _ PTR.TO.OPER; PTR _ R.PPN
   REPEAT SZ.USER NCHV(PTR) _ NCHV(TEMP)	!SAVE OPER'S NAME
   WRITE.REQ(CH.IN); CLOSE(CH.IN)
   MSG('$REQUEST CANCELLED.$')

CHARGE:	GET.PASS
   OPEN.PAR(INPUT,CHK.ERR); CHECK.NO.MORE.IN(CHG.CHOICES)
   LOOP DO
	INC NO.REQS
	NEW.LINE
	IF CK.NUMBER(TEMP) THEN DO
	   GET.REQ; NCHV P
	   SEARCH; INC NO.REQS; CHARGE.ONE
	   IF QUERY('ANOTHER REQUEST') = NO THEN GO GETCMD ELSE SETCP(CH.IN,0)
	   MSG('$ENTER REQUEST NUMBER: ')
	END ELSE DO
	   GETTOKEN(ALPHA)
	   IF TOKEN(0) # T.ALL THEN [CR; CHG.CHOICES] ELSE GO CHARGE.IT
	   NEW.LINE
	END
   END
CHARGE.IT: INC NO.REQS; LOOP DO	!CHARGE ALL UNPROCESSED REQUESTS
	READ.REQ
	IF REQ.TO.BE.DONE THEN [CHARGE.ONE; INC NO.REQS]
   END

POSTAGE: GET.PASS; GET.REQ; INC NO.REQS; EOFRET _ POSRET
   OPEN.PAR(INPUT,CHK.ERR)
   LOOP DO
	SEARCH
	IF FLAG = PSTG.ONLY THEN NOPSTG
	IF FLAG = HOLD THEN NOPST1
   END

POSRET: NO.REQS _ -1;  FIND.PRO; LAST.CP - _ N.WORDS
IF ASCII.TO.NUM(R.PSTG,SZ.PSTG) # 0 THEN &
   [MSG('$POSTAGE ALREADY ENTERED.$'); GO GETCMD]
INPUT.INF(B.PSTG)
IF ASK.OK = NO THEN GO GETCMD
NUM.TO.ASCII(R.PSTG,INF(B.PSTG),SZ.PSTG)
OPEN.CHG.OR.CAN(UPDATE,BATCHG,CHK.ERR)
SETCP(CH.IN,LAST.CP)
WRITE.REQ(CH.IN); CLOSE(CH.IN)
MSG('$POSTAGE ADDED.$')

RECHARGE: GET.PASS; GET.REQ; INC NO.REQS; EOFRET _ RECRET
   OPEN.PAR(INPUT,CHK.ERR)
   LOOP [SEARCH; IF FLAG = PSTG.ONLY OR FLAG = HOLD THEN NORECH]
RECRET:   NO.REQS _ -1; FIND.PRO; CHARGE.ONE
   OPEN.CHG.OR.CAN(UPDATE,BATCHG,CHK.ERR)
   LOOP DO
	SETCP(CH.IN,FIRST.CP); READ.REQ; SETCP(CH.IN,FIRST.CP)
	IF LAST.REQ = RECORD(0) THEN DO
	   P _ CHPT(RECORD,-1)
		NCHV(P) _ ASCII.ZERO; NCHV(P) _ FLG.CANC
	   TEMP _ 0
	   NUM.TO.ASCII(R.PPN,TEMP,SZ.PPN)
	   WRITE.REQ(CH.IN)
	   FIRST.CP + _ N.WORDS
	END ELSE REPEAT 0
	IF FIRST.CP >= LAST.CP THEN REPEAT 0
   END
   CLOSE(CH.IN)
   MSG('$REQUEST RECHARGED$')

CREATE: MAKE.REQ

QUIT: EXIT

END

GO GET.CMD

CHK.ERR: IF TEMP _ EOFRET # 0 THEN [CLOSE(CH.IN); EOFRET _ 0; GO ^TEMP]
   TEMP _ ERRNUM; CLOSE.ALL; OPEN.TEL
   IF TEMP = EOFERR THEN DO
	IF NO.REQS = 0 THEN MSG('$NO REQUESTS FOUND.$') ELSE &
		MSG('$END OF FILE.$')
	GO GETCMD
   END
CR;    DO ERRNUM OF TMFERR:CORERR
TMFERR: MSG('TOO MANY FILES OPEN')
FMDERR: MSG('BAD FILE MODE OR TYPE')
IFDERR: MSG('ILLEGAL FILE ID')
CNFERR: MSG('TYPE MODIFIER CONFLICT')
FNFERR: MSG('FILE NOT FOUND')
IUSERR: MSG('INVALID USER NAME')
PRTERR: MSG('PROTECTION FAILURE')
FBSERR: MSG('FILE BUSY')
AEFERR: MSG('ALREADY EXISTING FILE')
EOFERR: MSG('END OF FILE')
LNGERR: MSG('LINE TOO LONG')
TELERR: MSG('ILLEGAL OPERATION ON TEL')
ARGERR: MSG('BAD ARGUMENT ERROR')
CORERR: MSG('OUT OF CORE')
   END
GO GETCMD
!		***  INIT.BCHARG ***

%INIT.BCHARG
FIND PJ.THIS.SYS
LOCAL T,T1
LOCAL THIS.GAN, DATBLK(3)


IOCS(2)
OP.NAME.IN _ NO
MOVE 72 FROM ALL 0 TO TOKEN
TEMP _ CALL.UUO(-OCT 23,OCT 41,1)
THIS.GAN _ HW(@TEMP,0)
!GAN changed for ITSR #900700 - 2.5.82 kmd
!IF USER IS NOT IN GAN 3, CHECK FOR DIST 2 OR 0
IF THIS.GAN # OCT 3 THEN DO
   USER(0) _ CALL.UUO(-OCT 22,OCT 41,1)
   USER(1) _ CALL.UUO(-OCT 21,OCT 41,1)
   IF FIND.LUD = 0 THEN EXIT
   IF TEMP _ BYT(LUD(1),8,0) # 0 AND TEMP # 2 THEN &
	[MSG('$YOU MUST BE IN DISTRICT 0 OR 2 TO RUN THIS PROGRAM.$'); EXIT]
END ELSE IF OPER.BIT # YES THEN NOLIC
MSG('$CREATE BATCH ACCOUNTING CHARGES - VERSION '); NUMOUT(VERSION)
CR; DATOUT
INIT.TTY(GETCMD)
!SET UP FILE NAMES AND USER NAMES FOR LOOKUPS
TEMP _ CHPT(CHG.DIR,-1)
   SETFID(IOTAB,@TEMP,0,CHK.ERR)
   BATCHG _ NAMARG(IOTAB)
   ACTPPN _ PPNARG(IOTAB)
TEMP _ CHPT(CAN.DIR,-1)
   SETFID(IOTAB,@TEMP,0,CHK.ERR)
   BATCAN _ NAMARG(IOTAB)
GSYSNO
   [T1;T] _ PJ.THIS.SYS DIVMOD 10
   SYS.NO _ ((((ASCII.ZERO SHL 7) + T1 + ASCII.ZERO) SHL 7) + T + ASCII.ZERO) SHL 15
   MAKE.SIXBIT(@SYS.NO,@SYS.NAME,3)
   SYS.NO _ SYS.NO SHL 7
   HW(@BATCHG,1) _ HW(@SYS.NAME,0)
THIS.DATE _ DATBLK(0) _ EXU(OCT 47,OCT 1,OCT 14)	!GET DATE IN USERS TIME ZONE
   DATBLK(1) _ EXU(OCT 47, OCT 1, OCT 22)	!CURRENT TIME IN JIFFIES
   DATBLK(2) _ (OCT 400000 SHL 18) BOR (OCT 400020)
   CALL.UUO(DATBLK,DATUUO,1)	!GET DATE IN GMT
   [TEMP;] _ DATBLK(0) DIVMOD 31	!USE GMT DATE
   [;TEMP] _ TEMP DIVMOD 12
   SAVE.MONTH _ TEMP + 1
   MAKE.SIXBIT(MONTHS(SAVE.MONTH),@THIS.MON,3)
RETURN
END INIT.BCHARG
!		*** MAKE.REQ ***

%MAKE.REQ
PTR _ R.SYS; REPEAT N.WORDS*CPW NCHV(PTR) _ ASCII.ZERO
LOOP DO
   MSG('$ENTER USER NAME TO BE CHARGED: '); GETTOKEN(2)
   MAKE.SIXBIT(TOKEN,USER,12)
   WHILE FIND.LUD = 0
END
SAVE.STR(SZ.USER, R.USER)
GET.NEW.REQ
MSG('$ENTER PROJECT CODE: '); P _ GETLINE(TEL); GETTOKEN(2)
SAVE.STR(SZ.PROJ, R.PROJ)
PTR _ R.C.FLAG
NCHV(PTR) _ QUERY('CUSTOMER REQUEST') + ASCII.ZERO
NUM.TO.ASCII(R.DIST,BYT(LUD(1),8,0),SZ.DIST)
PTR _ R.PPN; P _ BYPT(@LUD(0),1,3)
REPEAT SZ.PPN NCHV(PTR) _ NCHV(P) + ASCII.ZERO
MAKE.TIME
FIX.REQ.INF		! SHOT IN THE DARK
CHARGE.ONE
RETURN
END MAKE.REQ
!		*** OPEN.CHG.OR.CAN ***

%OPEN.CHG.OR.CAN(TYPE,FILE,ERR)L OPEN.ERR:, OPN.AGN:
OPN.AGN: PPNARG(IOTAB) _ ACTPPN
NAMARG(IOTAB) _ FILE
EXTARG(IOTAB) _ THIS.MON
ERRNUM _ 0
CH.IN _ OPEN(-IOTAB,WORD+DIRECT+TYPE,OPEN.ERR)
OPEN.ERR: IF ERRNUM=0 THEN RETURN
!IF FILE NOT THERE, CREATE ONE!
IF ERRNUM = FNFERR THEN DO
   CH.IN _ OPEN(-IOTAB,WORD+DIRECT+OUTPUT,OPEN.ERR)
   CLOSE(CH.IN); GO OPN.AGN
END ELSE GO ^ERR
RETURN
END OPEN.CHG.OR.CAN
!		*** SEARCH ***

%SEARCH
LOOP DO
   LAST.CP _ CP(CH.IN)
   READ.REQ
   IF REQ.TO.BE.DONE AND REQ = (THIS.REQ BAND REQ.MASK) THEN RETURN
END
END SEARCH
!		*** CALL.UUO ***

%CALL.UUO(AC,ADDR,SKPFLG)
LOCAL DIDIT:
^OCT 12 _ AC
EXU(OCT 47,OCT 12,ADDR,DIDIT)
IF SKPFLG = 1 THEN [MSG('$UUO FAILED.$'); EXIT]
DIDIT: RETURN ^OCT 12
END CALL.UUO
!		*** REQ.OUT ***

%REQ.OUT
HEAD.OUT
IF FLAG = HOLD OR FLAG = PSTG.ONLY THEN DO
   TYPE.IT(PTR.TO.SYS,SZ.SYS,L.ZERO)
END ELSE TYPE.IT(PTR.TO.FLAG,SZ.SYS,L.ZERO)	!SYSTEM NUMBER
TYPE.IT(R.REQ,SZ.REQ,L.ZERO); OUT.SPACE	!REQUEST NO.
IF TYP.LST # L.CAN THEN [TYPE.IT(R.PPN,SZ.GAN,NO.L.ZERO); OUT.SPACE]  !GAN
TYPE.IT(R.DIST,SZ.DIST,NO.L.ZERO); OUT.SPACE		!DISTRICT
TEXT.OUT(R.USER,SZ.USER); OUT.SPACE !USER NAME
TEXT.OUT(R.PROJ,SZ.PROJ); OUT.SPACE !PROJECT CODE
   DO TYP.LST OF PROC:L.CAN
PROC: TYPE.IT(R.JOB.TYPE,SZ.J.TYPE,NO.L.ZERO); OUT.SPACE  !JOB TYPE
   TYPE.IT(R.VOLUME,SZ.VOLUME,NO.L.ZERO)	!VOLUME
   EIF J.TYPE = LISTING THEN DO
	CHR.OUT(DASH); TYPE.IT(R.PARTS,SZ.PARTS,L.ZERO)
	MULTI.SPACE(SZ.PARTS+2)
   END

!Begin  To be removed later, perhaps: ITSR #900700 1.13.82 kmd

!Historical note: The following was done because the accounting
!   unit for type 8 jobs was hundreds of CHARACTERS, and
!   therefore needed to be scaled on output.

   ORIF J.TYPE = ALIEN THEN OUT('00     ')

!End  To be removed later, perhaps: ITSR #900700 1.13.82 kmd

   ELSE MULTI.SPACE(7)
   TYPE.IT(R.DATE,SZ.COMP.DATE,L.ZERO); OUT.SPACE	!COMPLETION DATE
   CR
   IF J.TYPE = LISTING THEN DO
	IF ASCII.TO.NUM(R.DECOLL,SZ.DECOLL) = 1 &
	   THEN OUT('  YES  ') ELSE OUT('   NO  ')
   END ELSE MULTI.SPACE(7)
   IF ASCII.TO.NUM(R.PSTG,SZ.PSTG) # 0 THEN DO
	TYPE.DOLLAR(R.PSTG,SZ.PSTG)
	OUT.SPACE
   END ELSE MULTI.SPACE(SZ.PSTG+1)

!Begin  To be removed later, perhaps: ITSR #900700 1.13.82 kmd

   IF (J.TYPE=TAPE.WRITE OR J.TYPE=TAPE.CONV OR J.TYPE=ALIEN OR J.TYPE=&
	TAPE.370) AND ASCII.TO.NUM(R.T.PURCH,SZ.T.PURCH) # 0 THEN DO
	TYPE.IT(R.T.PURCH,SZ.T.PURCH,NO.L.ZERO); OUT.SPACE
   END ELSE MULTI.SPACE(SZ.T.PURCH+1)

!End  To be removed later, perhaps: ITSR #900700 1.13.82 kmd

   IF J.TYPE = TAPE.CONV AND ASCII.TO.NUM(R.TP.CNV,SZ.TP.CNV) &
	# 0 THEN DO
	TYPE.IT(R.TP.CNV,SZ.TP.CNV,NO.L.ZERO); OUT.SPACE
   END ELSE MULTI.SPACE(SZ.TP.CNV+1)
UN.PROC: R.DATE.OUT
   IF FLAG=PSTG.ONLY OR FLAG=HOLD THEN OUT('DEL. CHG. ONLY REQUIRED')
L.CAN: R.DATE.OUT; MULTI.SPACE(9); TEXT.OUT(R.PPN,SZ.PPN)
   END
CR
RETURN
END REQ.OUT
!		*** ONE.OUT ***

%ONE.OUT
MSG('$REQUEST NUMBER: '); TYPE.IT(PTR.TO.SYS,SZ.SYS,L.ZERO)
   TYPE.IT(R.REQ,SZ.REQ,L.ZERO)
MSG('$DATE REQUESTED: '); R.DATE.OUT
   TYPE.IT(R.HOUR.R,SZ.HOUR,L.ZERO); COLON; TYPE.IT(R.MIN.R,SZ.MIN,L.ZERO)
MSG('$BILLED TO: '); TEXT.OUT(R.USER,SZ.USER)
MSG('$ DISTRICT: '); TYPE.IT(R.DIST,SZ.DIST,NO.L.ZERO)
MSG('$PROJECT CODE: '); TEXT.OUT(R.PROJ,SZ.PROJ)
TEMP _ R.C.FLAG
IF NCHV(TEMP) = ASCII.ZERO THEN MSG('$INHOUSE REQUEST') ELSE&
   MSG('$CUSTOMER REQUEST')
RETURN
END ONE.OUT
!		*** LIST.UNPROC ***

%LIST.UNPROC(FLG)
LOCAL REC.MON, O.FLG
OPEN.PAR(INPUT,CHK.ERR)
LOOP DO
   READ.REQ
   O.FLG _ 0
   IF REQ.TO.BE.DONE THEN DO
	IF FLG = DATED THEN DO
	   IF MONTH = REC.MON _ ASCII.TO.NUM(R.MON.R,SZ.MON) THEN DO
		IF DAY >= ASCII.TO.NUM(R.DAY.R,SZ.DAY) THEN INC O.FLG
	   END ELSE IF MONTH > REC.MON THEN INC O.FLG
	END ELSE INC O.FLG
   END
   IF O.FLG > 0 THEN [REQ.OUT; INC NO.REQS]
END
END LIST.UNPROC
!		*** HEAD.OUT ***

%HEAD.OUT
IF HEAD.FLG # NEED.HEAD THEN RETURN
   DO TYP.LST OF PROC:L.CAN
PROC: OUT('$REQ.    GAN  DIST USER NAME   PROJ-CODE   TYPE VOLUME-PARTS DATE$')
   OUT('DECOLL.  PSTG    TPS   TPS')
   OUT('$               PURCHD CNVTD$$')
UN.PROC: OUT('$REQ.   GAN   DIST  USER NAME    PROJ-CODE DATE REQUESTED$$')
L.CAN: OUT('$REQ.   DIST  USER NAME    PROJ-CODE DATE REQUESTED ')
   OUT('VOIDED BY$$')
   END
INC HEAD.FLG
RETURN
END HEAD.OUT
!		*** NUM.TO.ASCII ***

%NUM.TO.ASCII(ASCII.PTR,NUM,N.DIGITS)
DEF MAX.DIGITS AS 15
LOCAL T(MAX.DIGITS),T.INDEX
IF N.DIGITS > MAX.DIGITS THEN [MSG('$NUMBER TOO BIG!.$'); EXIT]
MOVE MAX.DIGITS FROM ALL 0 TO T
TEMP _ NUM; T.INDEX _ 0
REPEAT N.DIGITS [[TEMP;T(T.INDEX)] _ TEMP DIVMOD 10; INC T.INDEX]
T.INDEX _ N.DIGITS - 1
REPEAT N.DIGITS [NCHV(ASCII.PTR) _  T(T.INDEX) + ASCII.ZERO; DEC T.INDEX]
RETURN
END NUM.TO.ASCII
!		*** ASCII.TO.NUM ***

%ASCII.TO.NUM(ASCII.PTR,N.DIGITS)
LOCAL MULT, N, T
MULT _ 1; N _ 0
REPEAT N.DIGITS-1 MULT _ MULT * 10
REPEAT N.DIGITS DO
   IF T _ NCHV(ASCII.PTR) # SPACE AND T # 0  THEN&
	 N + _ (T - ASCII.ZERO) * MULT
   MULT _ MULT/10
END
RETURN N
END ASCII.TO.NUM
!		*** GET.BILL.INF ***

!PUT ALL BILLING INFORMATION FOR ALL JOB TYPES FOR THIS JOB INTO ARRAY B.INF

%GET.BILL.INF
ZERO.B.INF
N.TYPES _ B.INDEX _ 0
IF FLAG = PSTG.ONLY OR FLAG = HOLD THEN DO
   LOOP [INPUT.INF(B.PSTG); WHILE ASK.CORRECT = NO]
   RETURN
END

!Changed: ITRS #900700 1.13.82 kmd

IF (NOT SEEN.TMP.MSG) AND FRN.FLG THEN DO
    MSG('$USE JOB TYPE 4 TO RESTORE TAPES,')
    MSG('$    JOB TYPE 5 TO STORE   TAPES,')
    MSG('$AND JOB TYPE 7 TO CONVERT TAPES.$')
    INC SEEN.TMP.MSG
  END

LOOP DO
  INPUT.INF(B.COM.DATE)
  LOOP DO
   INPUT.INF(B.J.TYPE)
   EIF NUMBER = TAPE.CONV THEN DO
	INPUT.INF(B.VOLUME)
	INPUT.INF(B.TP.CNV)
	INPUT.INF(B.T.PURCH)
   END

!Changed: ITSR #900700 1.13.82 kmd

   ORIF NUMBER = TAPE.WRITE THEN DO
	INPUT.INF(B.T.PURCH)
	INPUT.INF(B.VOLUME)
   END
   ORIF NUMBER = LISTING THEN DO
	INPUT.INF(B.VOLUME)
	INPUT.INF(B.P.PAPER)
	IF INF(B.P.PAPER) > 1 THEN INPUT.INF(B.DECOLL)
   END
   ELSE INPUT.INF(B.VOLUME)
   WHILE INC N.TYPES < MAX.JOB.TYPES AND &
	QUERY('ANOTHER BATCH TYPE FOR THIS REQUEST') = YES
   B.INDEX + _ SZ.B.ENTRY
  END
   INPUT.INF(B.PSTG)
   IF ASK.CORRECT = YES THEN RETURN
   ZERO.B.INF
   N.TYPES _ B.INDEX _ 0
END
END GET.BILL.INF
!		*** INPUT.INF ***

!INPUT BILLING INFORMATION
%INPUT.INF(WHICH)
LOCAL T1
LOCAL AGN:
AGN:   DO WHICH OF B.COM.DATE:B.MAX
B.COM.DATE: MSG('$COMPLETION DATE: '); P _ GETLINE(TEL)
   NEW.LINE; DATE.IN(NEED.YR)
   INF(B.COM.DATE) _ ((YEAR * 100) + MONTH) * 100 + DAY

B.J.TYPE: MSG('$BATCH TYPE: ')

!Changed: ITSR #900700 1.13.82 kmd

   IF TEMP _ INF(B.J.TYPE) _ IN.NUM > MAX.TYPE &
	 OR TEMP = 0 OR TEMP = 6 OR TEMP = 8 THEN GO AGN


B.VOLUME: CR
	DO INF(B.J.TYPE) OF LISTING:TAPE.CONV
   LISTING: MSG('PAGES')
   CARD.READ: CARD.PUNCH: MSG('NUMBER OF CARDS')
   TAPE.CONV: TAPE.READ: TAPE.WRITE: MSG('NUMBER OF FILES')

!Removed: ITSR #900700 1.13.82 kmd

	END
   MSG(': '); GET.AMT.AND.CHK(B.VOLUME,IN.NUM,999999)

B.TP.CNV: MSG('$NUMBER OF TAPES CONVERTED: ')
   GET.AMT.AND.CHK(B.TP.CNV,IN.NUM,999999)

B.P.PAPER: MSG('$PARTS: ')
   IF INF(B.P.PAPER) _ IN.NUM > 4 OR INF(B.P.PAPER) = 0 THEN GO AGN

B.DECOLL: INF(B.DECOLL) _ QUERY('WERE LISTINGS DECOLLATED')

B.T.PURCH: IF (QUERY('WERE ANY TAPES PURCHASED')) = YES THEN DO
	MSG('$NUMBER OF TAPES PURCHASED: ')
	GET.AMT.AND.CHK(B.T.PURCH,INNUM,9999999)
END

B.PSTG: IF QUERY1('ANY POSTAGE OR TRANSPORTATION CHARGE')=NO THEN RETURN
   MSG('$DELIVERY CHARGE: ')
   GET.AMT.AND.CHK(B.PSTG,DOLAR.IN,99999)
   IF T1 _ INF(B.PSTG) > 0 AND T1 < MIN.DEL THEN INF(B.PSTG) _ MIN.DEL


   END
RETURN
END INPUT.INF
!		*** QUERY1 ***

%QUERY1(Q)
IF CMD # CHARGE THEN RETURN QUERY(Q)
HOLFLG _ NO
CR; MSG(Q); MSG('? ')
LOOP DO
   P _ GETLINE(FILNO); TEMP _ NCHV P; WHILE NCHV P # EOLIT THEN NULL
   IF TEMP > OCT 140 THEN TEMP - _ OCT 40
   EIF TEMP = $Y OR TEMP = CARRET THEN RETURN 1
   ORIF TEMP = $? THEN GO ^RETADR
   ORIF TEMP = $H THEN [HOLFLG _ YES; RETURN 0]
   ORIF TEMP = $N THEN RETURN 0
   ELSE MSG('TYPE "Y" FOR YES, "N" FOR NO, OR "H" FOR HOLD: ')
END
END QUERY1
!		*** BILL.IT ***

%BILL.IT
LOCAL VOLUME, LAST, SAVCP, JOB.TYPE
SET.DIST
IF SPECIAL.FLG THEN CR
GET.BILL.INF
LAST _ (N.TYPES-1) * SZ.B.ENTRY
B.INDEX _ 0
SAV.CP _ OLD.CP
IF SPECIAL.FLG = NO THEN CLOSE(CH.IN)	!CLOSE PARCHG.DAT
OPEN.CHG.OR.CAN(UPDATE,BATCHG,CHK.ERR)

SETCP(CH.IN,SIZE(CH.IN)) 	!APPEND TO FILE

IF FLAG = PSTG.ONLY OR FLAG = HOLD THEN DO
   NUM.TO.ASCII(R.SYS,ASCII.TO.NUM(CHPT(@SYS.NO,-1),SZ.SYS),SZ.SYS)
   NUM.TO.ASCII(R.PSTG,INF(B.PSTG),SZ.PSTG)
   WRITE.REQ(CH.IN)
END ELSE DO
REPEAT N.TYPES DO
   ZERO.HALF.RECORD
   INF(B.COM.DATE) _ B.INF(B.COM.DATE)
   VOLUME _ INF(B.VOLUME)

   DO JOB.TYPE _ INF(B.J.TYPE) OF LISTING:MAX.TYPE

LISTING: NUM.TO.ASCII(R.PARTS,INF(B.P.PAPER),SZ.PARTS)
   TEMP _ R.DECOLL; IF INF(B.DECOLL) # NO THEN NCHV(TEMP) _ ASCII.ONE

TAPE.CONV:  NUM.TO.ASCII(R.TP.CNV,INF(B.TP.CNV),SZ.TP.CNV); TAP.CHG

!Removed: ITSR #900700 1.13.82 kmd

TAPE.WRITE: TAP.CHG


   END

   NUM.TO.ASCII(R.JOB.TYPE,JOB.TYPE,SZ.J.TYPE)
   NUM.TO.ASCII(R.VOLUME,INF(B.VOLUME),SZ.VOLUME)
   NUM.TO.ASCII(R.PSTG,INF(B.PSTG),SZ.PSTG)
   NUM.TO.ASCII(R.DATE,INF(B.COM.DATE),SZ.COMP.DATE)
   IF HOLFLG = YES AND LAST = B.INDEX THEN DO
	RECORD(0) _ (RECORD(0) BAND OCT 17777777) + HOLD
	CLOSE(CH.IN)	!CLOSE BATCH FILE
	OPEN.PAR(UPDATE,CHK.ERR)	!OPEN PARCHG
	SETCP(CH.IN,SIZE(CH.IN))	!APPEND TO FILE
   END
   WRITE.REQ(CH.IN)
   B.INDEX + _ SZ.B.ENTRY
END
END
CLOSE(CH.IN)
IF SPECIAL.FLG THEN RETURN
CHANGE.FLAG(FLG.PROC,SAV.CP)
OPEN.PAR(INPUT,CHK.ERR)
SETCP(CH.IN,SAV.CP); READ.REQ
MSG('$CHARGE PROCESSED$')
RETURN
END BILL.IT
!		*** DATE.IN ***

%DATE.IN(FLG)
LOCAL LAST.CHR, LAST.PTR, STATES, SEP

!STATES
DEF MO.IN AS 1
DEF MO.OR.SEP AS 2
DEF DA.IN AS 3
DEF DA.OR.SEP.OR.CR AS 4
DEF CR.ONLY AS 5
DEF SEP.ONLY AS 6
DEF YR.IN AS 7
DEF YR.ONLY AS 8

DEF CONVRT.AND.CHK(A,B,C,HIGH,LOW) AS IF A _ ASCII.TO.NUM(B,C) > HIGH OR &
   A < LOW THEN GO ILL.DATE


STATES _ MO.IN; MONTH _ DAY _ YEAR _ LAST.CHR _ SEP _ 0
LAST.PTR _ P
LOOP DO
  LOOP DO
   IF LAST.CHR _ NCHV(P) = QUESTION.MARK THEN GO GETCMD

	DO STATES OF MO.IN:YR.ONLY

YR.IN: MO.IN: DA.IN: IF CK.NUMBER(LAST.CHR) THEN INC STATES ELSE GO BAD.DATE

MO.OR.SEP: IF CK.NUMBER(LAST.CHR) THEN DO
	CONVRT.AND.CHK(MONTH,LAST.PTR,SZ.MON,MAX.MONTH,1)
	STATES _ SEP.ONLY
   END ELSE IF SEP _ LAST.CHR = DASH OR SEP = SLASH THEN DO
	CONVRT.AND.CHK(MONTH,LAST.PTR,1,MAX.MONTH,1)
	INC STATES
	LAST.PTR _ P
   END ELSE GO BAD.DATE

DA.OR.SEP.OR.CR: EIF CK.NUMBER(LAST.CHR) THEN DO
	CONVRT.AND.CHK(DAY,LAST.PTR,SZ.DAY,MAX.DAY,1)
	STATES _ IF FLG = NEED.YR THEN SEP.ONLY ELSE CR.ONLY
   END
   ORIF LAST.CHR = SEP THEN DO
	IF FLG # NEED.YR THEN GO BAD.DATE
	CONVRT.AND.CHK(DAY,LAST.PTR,1,MAX.DAY,1)
	STATES _ YR.IN
	LAST.PTR _ P
   END
   ELSE IF LAST.CHR = CARRET THEN DO
	IF FLG = NEED.YR THEN GO BAD.DATE
	CONVRT.AND.CHK(DAY,LAST.PTR,1,MAX.DAY,1)
	RETURN
   END ELSE GO BAD.DATE

CR.ONLY: IF LAST.CHR # CARRET THEN GO BAD.DATE ELSE RETURN

SEP.ONLY: IF SEP = 0 THEN DO
	IF SEP _ LAST.CHR # DASH AND SEP # SLASH THEN GO BAD.DATE
	STATES _ DA.IN
   END ELSE IF SEP # LAST.CHR THEN GO BAD.DATE ELSE STATES _ YR.IN
   LAST.PTR _ P

YR.ONLY: IF CK.NUMBER(LAST.CHR) THEN DO
	CONVRT.AND.CHK(YEAR,LAST.PTR,SZ.YEAR,MAX.YEAR,MIN.YEAR)
	STATES _ CR.ONLY
   END ELSE GO BAD.DATE

	END

  END

ILL.DATE: MSG('$ILLEGAL DATE - REENTER: '); GO SET.NEW
BAD.DATE: MSG('$ENTER THE DATE IN MONTH-DAY')
   IF FLG = NEED.YR THEN MSG('-YEAR')
   MSG(' FORMAT: ')
SET.NEW: DAY _ MONTH _ YEAR _ SEP _ LAST.CHR _ 0
   P _ LAST.PTR _ GETLINE; STATES _ MO.IN
END
END DATE.IN
!		*** TYPE.IT ***

%TYPE.IT(P,N.DIGITS,F)
LOCAL LEAD.ZERO, CHR
LEAD.ZERO _ IF F # L.ZERO THEN -1 ELSE 1
LOOP DO
   WHILE DEC N.DIGITS > 0
   IF CHR _ NCHV(P) = SPACE OR CHR = 0 THEN CHR _ ASCII.ZERO
   IF CHR = ASCII.ZERO AND LEAD.ZERO = -1 THEN OUT.SPACE ELSE &
	 [CHR.OUT(CHR); INC LEAD.ZERO]
END
CHR.OUT(NCHV(P))
RETURN
END TYPE.IT
!		*** DOLAR.IN ***

%DOLAR.IN
LOCAL LAST.CHR, STATES, PTR, NUM.STRING(3), COUNT
LOCAL BAD.CHR:, DOLAR.AGN:

!STATES
DEF SIGN.OR.NUMBER.OR.DOT AS 1
DEF NUM.OR.DOT AS 2
DEF CENTS.2 AS 3
DEF CENTS.1 AS 4
DEF CR.ONLY AS 5

DEF RET.AMT AS ASCII.TO.NUM(CHPT(NUM.STRING,-1),COUNT)
DEF SAVE.IT AS [NCHV(PTR) _ LAST.CHR; INC COUNT]

NEW.LINE

LOOP DO
DOLAR.AGN: STATES _ SIGN.OR.NUMBER.OR.DOT
   COUNT _ 0
   PTR _ CHPT(NUM.STRING,-1)
 LOOP DO
	IF LAST.CHR _ NCHV(P) = QUESTION.MARK THEN GO GETCMD

	DO STATES OF SIGN.OR.NUMBER.OR.DOT:CR.ONLY

   SIGN.OR.NUMBER.OR.DOT: EIF LAST.CHR = DOT THEN STATES _ CENTS.2
	ORIF LAST.CHR = DOLLAR.SIGN THEN INC STATES
	ORIF CK.NUMBER(LAST.CHR) THEN [SAVE.IT; INC STATES]
	ELSE GO BAD.CHR

   NUM.OR.DOT: EIF CK.NUMBER(LAST.CHR) THEN SAVE.IT
	ORIF LAST.CHR = DOT THEN &
	   IF NO.CENTS # 0 THEN STATES _ CR.ONLY ELSE INC STATES
	ORIF LAST.CHR = CARRET AND NO.CENTS # 0 THEN RETURN RET.AMT
	ELSE GO BAD.CHR

   CENTS.1: CENTS.2: IF NO.CENTS # 0 THEN GO BAD.CHR
	IF CK.NUMBER(LAST.CHR) THEN [SAVE.IT; INC STATES] ELSE GO BAD.CHR

   CR.ONLY: IF LAST.CHR # CARRET THEN GO BAD.CHR
	RETURN RET.AMT

	END
 END
BAD.CHR: MSG('$INPUT IN DOLLAR ')
   MSG(IF NO.CENTS # 0 THEN 'ONLY' ELSE 'AND CENTS')
   MSG(' FORMAT: ')
   P _ GETLINE(TEL)
END
END DOLAR.IN
!		*** IN.NUM ***

%IN.NUM
LOCAL SAVP, COUNT, GOT.NUM:
LOOP DO
   NEW.LINE; SAVP _ P
   LOOP DO
	IF END.OF.LINE THEN DO
	   IF COUNT > 0 THEN GO GOT.NUM ELSE OUT.OF.LOOP
	END
	IF TEMP = QUESTION.MARK THEN GO GETCMD
	IF CK.NUMBER(TEMP) THEN INC COUNT ELSE OUT.OF.LOOP
   END
   MSG('$INPUT NUMERICAL DIGITS ONLY: '); P _ GETLINE(TEL)
END
GOT.NUM: P _ SAVP; RETURN GETNUM
END IN.NUM
!		*** READ.REQ ***

%READ.REQ
LOCAL TEMP
LOOP DO
   OLD.CP _ CP(CH.IN)
   TEMP _ 0
   REPEAT N.WORDS [RECORD(TEMP) _ R(CH.IN); INC TEMP]
      IF RECORD(0) = 0 THEN [MSG('$CHARGE FILE IS UNRECOGNIZABLE.');&
	MSG('$PLEASE CALL Q.A.$'); EXIT]
   FIX.REQ.INF
   J.TYPE _ ASCII.TO.NUM(R.JOB.TYPE,SZ.J.TYPE)

!Changed: ITSR #900700 1.13.82 kmd

   IF NOT (J.TYPE >= 9 AND J.TYPE <= 11) THEN RETURN

END
END READ.REQ
!		*** TYPE.DOLLAR ***

%TYPE.DOLLAR(AMT.PTR,DIGITS)
TEMP _ AMT.PTR
TYPE.IT(AMT.PTR,DIGITS-2,NO.L.ZERO)
CHR.OUT($.)
REPEAT DIGITS-2 NCHV(TEMP)
REPEAT 2 [IF T _ NCHV(TEMP) = SPACE THEN T _ ASCII.ZERO; CHR.OUT(T)]
RETURN
END TYPE.DOLLAR
!		*** CHANGE.FLAG ***

%CHANGE.FLAG(F,CURSOR.P)
LOCAL I.WORD, P
OPEN.PAR(UPDATE,CHK.ERR)
SETCP(CH.IN,CURSOR.P)
I.WORD _ R(CH.IN)
SETCP(CH.IN,CURSOR.P)
P _ CHPT(@I.WORD,-1)
NCHV(P) _ ASCII.ZERO
NCHV(P) _ F
W(CH.IN,I.WORD)
CLOSE(CH.IN)
RETURN
END CHANGE.FLAG
!		*** FIND.PRO ***

%FIND.PRO
INC NO.REQS
ERRNUM _ 0; TYP.LST _ PROC
OPEN.CHG.OR.CAN(INPUT,BATCHG,FIND.ERR)
LAST.REQ _ LAST.CP _ 0
LOOP DO
   HEAD.FLG _ NEED.HEAD
   F.FLG _ 0
   SEARCH
   LAST.REQ _ RECORD(0)
   INC F.FLG
   REQ.OUT
   LAST.CP _ CP(CH.IN)
   FIRST.CP _ LAST.CP - N.WORDS
   LOOP DO
	LAST.CP _ CP(CH.IN)
	READ.REQ
	IF LAST.REQ = RECORD(0) THEN REQ.OUT ELSE REPEAT 0
   END
FIND.ERR: IF ERRNUM > 0 THEN &
   [IF ERRNUM # EOFERR OR F.FLG = 0 THEN GO CHK.ERR]
   INC NO.REQS
   IF ASK.OK = YES THEN DO
	SETCP(CH.IN,LAST.CP - N.WORDS)
	READ.REQ
	CLOSE(CH.IN)
	RETURN
      END
END
END FIND.PRO
!		*** GSYSNO ***

%GSYSNO

LOCAL CH.SYS
LOCAL SYS.ERR:

GLOBAL PJ.THIS.SYS, PJ.ACTG.SYS

DEF ACTG.BIT AS BYT(PJ.ACTG.SYS,1,30)

CH.SYS _ OPEN('(PJ)JOBS.DAT',DIRECT+INPUT+WORD,SYS.ERR)
SETCP(CH.SYS,1); PJ.THIS.SYS _ R(CH.SYS)
SETCP(CH.SYS,13)	!START SEARCHING THRU SYSTEMS
LOOP DO
   PJ.ACTG.SYS _ R(CH.SYS)
   WHILE ACTG.BIT # 1
END
PJ.ACTG.SYS _ HW(@PJ.ACTG.SYS,1)
CLOSE(CH.SYS); RETURN 1

SYS.ERR: CLOSE(CH.SYS); RETURN 0
END GSYSNO
!		*** FIND.LUD ***

%FIND.LUD
GLOBAL LOC.HASH, NAME.HASH
LOCAL CH.LUD

DEF FIXCP(A) AS (A-1) * 128
CH.LUD _ OPEN('(SYS)LUD.SYS',INPUT+DIRECT+WORD,CHK.ERR)
HASH(^USER,^(USER+1))
SETCP(CH.LUD,FIXCP(LOC.HASH))
RB(CH.LUD,128,L.BLK); L.INDEX _ 0
WHILE NAME.HASH # LUD(4) THEN DO
	L.INDEX + _ BYT(LUD(2),7,0)
	IF LUD(0) = 0 THEN RETURN 0
	IF LUD(0) < 0 THEN DO
	   SETCP(CH.LUD,FIXCP(HW(@LUD(1),1)))
	   RB(CH.LUD,128,L.BLK)
	END
END
RETURN 1
END FIND.LUD
!		*** MAKE.TIME ***

%MAKE.TIME
LOCAL MON, HOURS, DAY, MINUTE, TEMP
TEMP _ EXU(OCT 47, OCT 1, OCT 14)
   [TEMP;DAY] _ TEMP DIVMOD 31
   [;MON] _ TEMP DIVMOD 12
TEMP _ EXU(OCT 47, OCT 1, OCT 22)
   [TEMP;] _ TEMP DIVMOD 3600
   [HOURS; MINUTE] _ TEMP DIVMOD 60
NUM.TO.ASCII(R.MON.R, MON + 1, SZ.MON)
NUM.TO.ASCII(R.DAY.R, DAY + 1, SZ.DAY)
NUM.TO.ASCII(R.HOUR.R, HOURS, SZ.HOUR)
NUM.TO.ASCII(R.MIN.R, MINUTE, SZ.MIN)
RETURN
END MAKE.TIME
!		*** GET.NEW.REQ ***

%GET.NEW.REQ
LOCAL CH.REQ, BZY.CNT, REQUEST
LOCAL REQ.ERR:
BZY.CNT _ 100
LOOP DO
   ERRNUM _ 0
   CH.REQ _ OPEN(NUM.DIR,DIRECT+WORD+UPDATE,REQ.ERR)
   REQ.ERR: WHILE ERRNUM # 0
	IF ERRNUM # FBSERR THEN GO CHK.ERR
 	IF DEC BZY.CNT < 0 THEN &
	   [MSG('$REQUEST NUMBER FILE BUSY - TRY AGAIN LATER.$');&
	   GO GETCMD]
END
REQUEST _ R(CH.REQ)
SETCP(CH.REQ,0); W(CH.REQ,REQUEST+1)
CLOSE(CH.REQ)
NUM.TO.ASCII(R.SYS, REQUEST, SZ.SYS+SZ.REQ)
FIX.REQ.INF
RETURN
END GET.NEW.REQ
!		*** GET.PASS ***

%GET.PASS
IF OP.NAME.IN # 0 THEN RETURN
P.NAME(0) _ P.NAME(1) _ 0
CR; IF GETULC < 0 THEN GO GETCMD
CR; TEMP _ PTR.TO.OPER; PTR _ BYPT(PNAME,1,6)
REPEAT SZ.USER NCHV(TEMP) _ NCHV(PTR) + OCT 40
INC OP.NAME.IN
RETURN
END GET.PASS
!		*** FIX.REQ.INF ***

%FIX.REQ.INF
P _ R.SYS
PTR _ PTR.TO.REQ
TEMP _ PTR.TO.FLAG
REPEAT SZ.SYS NCHV(TEMP) _ NCHV(PTR) _ NCHV(P)
REPEAT SZ.REQ NCHV(PTR) _ NCHV(P)

!Changed: ITSR #900700 1.13.82 kmd

FRN.FLG _ 0
SEEN.TMP.MSG _ 0
TEMP _ ASCII.TO.NUM(R.DIST,SZ.DIST)
IF (TEMP > 69 AND TEMP < 80) THEN INC FRN.FLG

RETURN
END FIX.REQ.INF



END BCHARG
  @m