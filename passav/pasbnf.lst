    1	$TERMINALS
    2	
    3	  <identifier> = ident
    4	  <intconst> = intconst
    5	  <realconst> = realconst
    6	  <stringconst> = stringconst
    7	  NIL = nilsy
    8	  NOT = notsy
    9	  '**' = powerop
   10	  <mulop> = mulop
   11	  <addop> = addop
   12	  <relop> = relop
   13	  '(' = lparent
   14	  ')' = rparent
   15	  '[' = lbracket
   16	  ']' = rbracket
   17	  ',' = comma
   18	  '.' = period
   19	  '^' = arrow
   20	  ':' = colon
   21	  ':=' = becomes
   22	  ';' = semicolon
   23	  '..' = elipsis
   24	  LABEL = labelsy
   25	  CONST = constsy
   26	  TYPE = typesy
   27	  VAR = varsy
   28	  FUNCTION = functionsy
   29	  PROCEDURE = proceduresy
   30	  EXCEPTION = exceptionsy
   31	  EXTERNAL = externalsy
   32	  PUBLIC = publicsy
   33	  STATIC = staticsy
   34	  FORWARD = forwardsy
   35	  OPTIONS = optionssy
   36	  PACKED = packedsy
   37	  SET = setsy
   38	  ARRAY = arraysy
   39	  RECORD = recordsy
   40	  STRING = stringsy
   41	  FILE = filesy
   42	  PREC = precsy
   43	  PROGRAM = programsy
   44	  MODULE = modulesy
   45	  DATAMODULE = datamodsy
   46	  ENVMODULE = envmodsy
   47	  BEGIN = beginsy
   48	  IF = ifsy
   49	  CASE = casesy
   50	  REPEAT = repeatsy
   51	  WHILE = whilesy
   52	  FOR = forsy
   53	  WITH = withsy
   54	  LOOP = loopsy
   55	  GOTO = gotosy
   56	  RETURN = returnsy
   57	  STOP = stopsy
   58	  <io function> = iosy
   59	  EXIT = exitsy
   60	  END = endsy
   61	  THEN = thensy
   62	  ELSE = elsesy
   63	  UNTIL = untilsy
   64	  OF = ofsy
   65	  DO = dosy
   66	  TO = tosy
   67	  DOWNTO = downtosy
   68	  OTHERS = otherssy
   69	  ALLCONDITIONS = allcondsy
   70	  <eof> = eofsy
   71	
   72	
   73	$NONTERMINALS
   74	
   75	<program id> = program_id
   76	<module id> = module_id
   77	<datamodule id> = datamod_id
   78	<envmodule id> = envmod_id
   79	<subr options> = subr_options
   80	<statement> = null_stmt                         (* PLACE HOLDING TYPE FOR TREE *)
   81	<simple statement> = simple_stmt
   82	<goto statement> = goto_stmt
   83	<io statement> = io_stmt
   84	<return statement> = return_stmt
   85	<stop statement> = stop_stmt
   86	<if head> = if_stmt
   87	<for head> = for_stmt
   88	<while head> = while_stmt
   89	<case head> = case_stmt
   90	<with head> = with_stmt
   91	<exit head> = exit_clause
   92	<until clause> = until_clause
   93	<expression> = exprtree                         (* PLACE HOLDING NODE TYPE FOR TREE *)
   94	<not op> = not_op
   95	<sign op> = sign_op
   96	<paren expr> = paren_expr
   97	<set expression> = set_expr
   98	<array qualifier> = array_qualifier
   99	<field qualifier> = field_qualifier
  100	<ptr qualifier> = ptr_qualifier
  101	<function qualifier> = func_qualifier
  102	<type decl> = type_decl                         (* PLACE HOLDING NODE TYPE FOR TREE *)
  103	<packed type> = packed_type
  104	<set type> = set_type
  105	<string type> = string_type
  106	<pointer type> = pointer_type
  107	<subr type> = subr_type
  108	<array type> = array_type
  109	<packed array type> = pk_array_type
  110	<record type> = record_type
  111	<file type> = file_type
  112	<parameter list> = parm_list
  113	<var parm decl> = var_parm_decl
  114	<value parm decl> = value_parm_decl
  115	<const id decl> = const_id_decl
  116	<var id decl> = var_id_decl
  117	<type id decl> = type_id_decl
  118	<identifier list> = id_list
  119	<field id decl> = field_id_decl
  120	<variant part> = variant_part
  121	<tag field> = tag_field
  122	<variant case> = variant_case
  123	<range list> = range_list
  124	<declaration> = declaration                     (* PLACE HOLDING NODE TYPE FOR TREE *)
  125	<label declaration> = label_declaration
  126	<const declaration> = const_declaration
  127	<var declaration> = var_declaration
  128	<type declaration> = type_declaration
  129	<condition declaration> = cond_declaration
  130	<subr decl> = subr_decl
  131	<star> = starsy
  132	<io arg> = io_arg
  133	
  134	
  135	$CODES
  136	
  137	  (* Tree building actions *)
  138	
  139	  attach attachnt attachqual infixop returnnt returnterm returnsubr
  140	  returnqual attachopt
  141	
  142	  (* Syntactic error recovery actions *)
  143	
  144	  extratext progidexp semiexp progexp dotexp declexp labelidexp nodecl
  145	  noending typeexp initvalexp colonexp  subrnameexp subrbodyexp parmdeclexp idexp
  146	  chkeq chkstar eqexp lbracketexp idxtypeexp ofexp
  147	  nofieldsemi novariant nocaselab lparenexp nostatement nosemi norhs noifpred
  148	  thenexp chksemielse foridxexp becomesexp forinitexp forwayexp forfinexp doexp
  149	  untilexp untilpredexp whilepredexp nocase stmtincaseexp nocasedelim nowithref
  150	  labelexp endstmtexp ifexp operandexp expressionexp rparenexp rbracketexp rangeexp
  151	  upbexp fieldexp eqinstead chksign declrequired nohandler
  152	
  153	$GRAMMAR
  154	
  155	<program> ::=           <dat or env module>                             |
  156	                        <program or module>                             ;
  157	
  158	<program or module> ::= [ <program id>          $s returnnt             |
  159	                          <module id>           $s returnnt
  160	                                                $f returnnt             ]
  161	                        [ <declarations>                                ]
  162	                        [ <compound statement>                          ]
  163	                        '.'                     $f dotexp
  164	                        <eof>                   $f extratext            ;
  165	
  166	<dat or env module> ::= ( <datamodule id>       $s returnnt             |
  167	                          <envmodule id>        $s returnnt             )
  168	                        [ <declarations>                                ]
  169	                        END                     $f endstmtexp
  170	                        '.'                     $f dotexp
  171	                        <eof>                   $f extratext            ;
  172	
  173	<program id> ::=        PROGRAM
  174	                        <identifier>            $s attach
  175	                                                $f progidexp
  176	                        [ <subr options>        $s attachnt             ]
  177	                        ';'                     $f semiexp              ;
  178	
  179	<module id> ::=         MODULE
  180	                        <identifier>            $s attach
  181	                                                $f progidexp
  182	                        [ <subr options>        $s attachnt             ]
  183	                        ';'                     $f semiexp              ;
  184	
  185	<datamodule id> ::=     DATAMODULE
  186	                        <identifier>            $s attach
  187	                                                $f progidexp
  188	                        [ <subr options>        $s attachnt             ]
  189	                        ';'                     $f semiexp              ;
  190	
  191	<envmodule id> ::=      ENVMODULE
  192	                        <identifier>            $s attach
  193	                                                $f progidexp
  194	                        [ <subr options>        $s attachnt             ]
  195	                        ';'                     $f semiexp              ;
  196	
  197	<declarations> ::=      <declaration>           $f nodecl
  198	                        [ <declaration>         $f nodecl               ]* ;
  199	
  200	<declaration> ::=       ( <public declaration>                          |
  201	                          <external declaration>                        |
  202	                          <static declaration>                          |
  203	                          <simple declaration>                          ) ;
  204	
  205	<public declaration> ::=
  206	                        PUBLIC                  $s attach
  207	                        ( <const declaration>   $s returnqual           |
  208	                          <subr declaration>                            |
  209	                          <var declaration>     $s returnqual           |
  210	                          <condition declaration>       $s returnqual   |
  211	                          <label declaration>   $s returnqual           |
  212	                          <type declaration>    $s returnqual
  213	                                                $f declrequired         );
  214	
  215	<external declaration> ::=
  216	                        EXTERNAL                $s attach
  217	                        ( <const declaration>   $s returnqual           |
  218	                          <var declaration>     $s returnqual           |
  219	                          <condition declaration>       $s returnqual   |
  220	                          <subr decl>           $s returnqual           |
  221	                          <label declaration>   $s returnqual           |
  222	                          <type declaration>    $s returnqual
  223	                                                $f declrequired         );
  224	
  225	<static declaration> ::=
  226	                        STATIC                  $s attach
  227	                        ( <var declaration>     $s returnqual           |
  228	                          <const declaration>   $s returnqual           |
  229	                          <subr declaration>                            |
  230	                          <label declaration>   $s returnqual           |
  231	                          <condition declaration>       $s returnqual   |
  232	                          <type declaration>    $s returnqual
  233	                                                $f declrequired         );
  234	
  235	<simple declaration> ::=
  236	                        ( <label declaration>   $s returnnt             |
  237	                          <const declaration>   $s returnnt             |
  238	                          <type declaration>    $s returnnt             |
  239	                          <var declaration>     $s returnnt             |
  240	                          <condition declaration>       $s returnqual   |
  241	                          <subr declaration>                            ) ;
  242	
  243	<label declaration> ::= LABEL
  244	                        <intconst>              $s attach
  245	                                                $f labelidexp
  246	                        [ ','
  247	                          <intconst>            $s attach
  248	                                                $f labelidexp           ]*
  249	                        [ ';'                   $f noending             ]  ;
  250	
  251	<const declaration> ::= CONST
  252	                        <const id decl>         $s attachnt
  253	                                                $f declexp
  254	                        [ <const id decl>       $s attachnt             ]* ;
  255	
  256	<const id decl> ::=     <identifier>            $s attach
  257	                        ( <typed const>                                 |
  258	                          ( ':='                                    |
  259	                            <equals>            $f becomesexp       )
  260	                          <expression>          $f initvalexp           )
  261	                        [ ';'                   $f noending             ] ;
  262	
  263	<typed const> ::=       ':'                     $s attach
  264	                        <type decl>             $f typeexp
  265	                        [ ( ':='                                    |
  266	                            <equals>                                )
  267	                          <expression>          $f initvalexp           ] ;
  268	
  269	<var declaration> ::=   VAR
  270	                        <var id decl>           $s attachnt
  271	                                                $f declexp
  272	                        [ <var id decl>         $s attachnt             ]* ;
  273	
  274	<var id decl> ::=       <identifier list>       $s attachnt
  275	                        ':'                     $f colonexp
  276	                        <type decl>             $f typeexp
  277	                        [ <becomes>
  278	                          <expression>          $f initvalexp           ]
  279	                        [ ';'                   $f noending             ] ;
  280	
  281	<type declaration> ::=  TYPE
  282	                        <type id decl>          $s attachnt
  283	                                                $f declexp
  284	                        [ <type id decl>        $s attachnt             ]* ;
  285	
  286	<type id decl> ::=      <identifier>            $s attach
  287	                        <equals>                $f eqexp
  288	                        <type decl>             $f typeexp
  289	                        [ ';'                   $f noending             ] ;
  290	
  291	<identifier list> ::=   <identifier>            $s attach
  292	                        [ ','
  293	                          <identifier>          $s attach
  294	                                                $f idexp                ]* ;
  295	
  296	<condition declaration> ::=
  297	                        EXCEPTION
  298	                        <identifier list>       $f idexp
  299	                        [ ';'                   $f noending             ] ;
  300	
  301	<subr declaration> ::=  <subr decl>
  302	                        [ FORWARD               $s returnsubr
  303	                                                $f returnsubr           |
  304	                          <subr body>                                   ]
  305	                        [ ';'                   $f noending             ] ;
  306	
  307	<subr decl> ::=         ( PROCEDURE             $s attach               |
  308	                          FUNCTION              $s attach               )
  309	                        <identifier>            $s attach
  310	                                                $f subrnameexp
  311	                        [ <parameter list>      $s attachnt             ]
  312	                        [ <parm type>                                   ]
  313	                        [ <subr options>        $s attachnt             ]
  314	                        [ ';'                   $f noending             ] ;
  315	
  316	<parameter list> ::=    '('
  317	                        [ <parm decl>
  318	                          [ ';'
  319	                            <parm decl>         $f parmdeclexp          ]* ]
  320	                        ')'                     $f rparenexp            ;
  321	
  322	<parm decl> ::=         <var parm decl>         $s attachnt             |
  323	                        <value parm decl>       $s attachnt             ;
  324	
  325	<var parm decl> ::=     VAR
  326	                        <value parm decl>       $f parmdeclexp          ;
  327	
  328	        (* The contorted BNF below exists in order to have generalized
  329	           <type decl>s in parameter lists.  The problem exists because it is
  330	           impossible to tell between a parameter declaration containing only
  331	           a <type decl> and one listing the parameter names, without examining
  332	           the following token to see if it is a comma, colon, elipsis or
  333	           expression symbol.  *)
  334	
  335	<value parm decl> ::=   <vpd id left>                                   |
  336	                        <type decl>                                     ;
  337	
  338	<vpd id left> ::=       <identifier>            $s attach
  339	                        [ <parm id list>                                |
  340	                          <parm type>                                   |
  341	                          [ <array qualifier>   $s attachqual           |
  342	                            <field qualifier>   $s attachqual           |
  343	                            <ptr qualifier>     $s attachqual           |
  344	                            <function qualifier>   $s attachqual        ]*
  345	                          [ <mulop>             $s attach
  346	                            <unary expr>        $s infixop
  347	                                                $f operandexp           ]*
  348	                          [ <addop>             $s attach
  349	                            <factor>            $s infixop
  350	                                                $f operandexp           ]*
  351	                          [ '..'                $s attach
  352	                            <term>              $s infixop
  353	                                                $f upbexp               ]  ] ;
  354	
  355	<parm id list> ::=      ','
  356	                        <identifier>            $s attach
  357	                                                $f idexp
  358	                        [ ','
  359	                          <identifier>          $s attach
  360	                                                $f idexp                ]*
  361	                        <parm type>             $f typeexp              ;
  362	
  363	<parm type> ::=         ':'
  364	                        <type decl>             $f typeexp              ;
  365	
  366	<subr body> ::=         [ <declaration>         $f nodecl               ]*
  367	                        <compound statement>    $f subrbodyexp          ;
  368	
  369	<type decl> ::=         <packed type>           $s attachnt             |
  370	                        <unpacked type>                                 ;
  371	
  372	<packed type> ::=       PACKED
  373	                        ( <packed array type>   $s attachnt             |
  374	                          [ '['
  375	                            <expression>   $f expressionexp
  376	                            ']'                 $f rbracketexp          ]
  377	                          <unpacked type>       $f typeexp              ) ;
  378	
  379	<unpacked type> ::=     <range type>                                    |
  380	                        <string type>           $s attachnt             |
  381	                        <pointer type>          $s attachnt             |
  382	                        <set type>              $s attachnt             |
  383	                        <aggregate type>                                |
  384	                        <subr type>             $s attachnt             ;
  385	
  386	    (* Note below we use <term> instead of <expression> because: relational
  387	       expressions are ambiguous in a constant declaration because of the
  388	       use of '=' following a type, and because subranges of boolean are kind
  389	       of silly anyway. *)
  390	
  391	<range type> ::=        <term>  
  392	                        [ '..'                  $s attach
  393	                          <term>                $f upbexp
  394	                          [ <prec clause>       $s infixop
  395	                                                $f infixop              ] ] ;
  396	
  397	<prec clause> ::=       PREC                    $s attach
  398	                        <term>                  $f expressionexp        ;
  399	
  400	<pointer type> ::=      '^'
  401	                        <type decl>             $f typeexp              ;
  402	
  403	<string type> ::=       STRING
  404	                        [ '['
  405	                          <upb expr>            $f expressionexp
  406	                          ']'                   $f rbracketexp          ] ;
  407	
  408	<upb expr> ::=          <term>                                          |
  409	                        <star>                  $s attachnt             ;
  410	
  411	<set type> ::=          SET
  412	                        OF                      $f ofexp
  413	                        <range type>            $f typeexp              ;
  414	
  415	<aggregate type> ::=    <array type>            $s attachnt             |
  416	                        <record type>           $s attachnt             |
  417	                        <file type>             $s attachnt             ;
  418	
  419	<array type> ::=        ARRAY
  420	                        '['                     $f lbracketexp
  421	                        <index type>            $f idxtypeexp
  422	                        [ ','
  423	                          <index type>          $f idxtypeexp           ]*
  424	                        ']'                     $f rbracketexp
  425	                        OF                      $f ofexp
  426	                        <type decl>             $f typeexp              ;
  427	
  428	<packed array type> ::= <array type>                                    ;
  429	
  430	<index type> ::=        <star>                  $s attachnt             |
  431	                        <term>
  432	                        [ '..'                  $s attach
  433	                          <upb expr>            $s infixop
  434	                                                $f upbexp               ] ;
  435	
  436	<record type> ::=       RECORD
  437	                        <field list>
  438	                        END                     $f endstmtexp           ;
  439	
  440	<field list> ::=        [ <field id decl>       $s attachnt             ]*
  441	                        [ <variant part>        $s attachnt             ]  ;
  442	
  443	<field id decl> ::=     <identifier list>       $s attachnt
  444	                        ':'                     $f colonexp
  445	                        <type decl>             $f typeexp
  446	                        [ ';'                   $f nofieldsemi          ] ;
  447	
  448	<variant part> ::=      CASE
  449	                        <tag field>             $s attachnt
  450	                                                $f idexp
  451	                        OF                      $f ofexp
  452	                        <variant case>          $s attachnt
  453	                                                $f novariant
  454	                        [ <variant case>        $s attachnt             ]* ;
  455	
  456	<tag field> ::=         <tag decl> |
  457	                        <type decl>                                     ;
  458	
  459	<tag decl> ::=          <identifier>            $s attach
  460	                        [ ':'
  461	                          <type decl>           $f typeexp              ] ;
  462	
  463	<variant case> ::=      ( <range list>          $s attachnt             |
  464	                          OTHERS                $s attach               )
  465	                        ':'                     $f colonexp
  466	                        '('                     $f lparenexp
  467	                        <field list>
  468	                        ')'                     $f rparenexp
  469	                        [ ';'                   $f nofieldsemi          ] ;
  470	
  471	<file type> ::=         FILE
  472	                        OF                      $f ofexp
  473	                        [ <star>                $s attachnt             |
  474	                          <type decl>           $f typeexp              ] ;
  475	
  476	<subr type> ::=         ( PROCEDURE             $s attach               |
  477	                          FUNCTION              $s attach               )
  478	                        [ <parameter list>      $s attachnt             ]
  479	                        [ <parm type>                                   ] ;
  480	
  481	<subr options> ::=      OPTIONS
  482	                        <option>                $s attachopt
  483	                                                $f idexp
  484	                        [ ','
  485	                          <option>              $s attachopt
  486	                                                $f idexp                ]* ;
  487	
  488	<option> ::=            [ <star>                $s attachnt             ]
  489	                        <identifier>            $s attach
  490	                        [ '('
  491	                          <sub option>          $f idexp
  492	                          [ ','
  493	                            <sub option>        $f idexp                ]*
  494	                          ')'                   $f rparenexp            ]  ;
  495	
  496	<sub option> ::=        <identifier>            $s attach               |
  497	                        <intconst>              $s attach               ;
  498	
  499	<statement list> ::=    [ <stmt in list>                                |
  500	                          ';'                                           ]* ;
  501	
  502	<stmt in list> ::=      ( <labeled statement>                           |
  503	                          <statement>           $f nostatement          )
  504	                        [ ';'                   $f nosemi               ] ;
  505	
  506	<labeled statement> ::= <intconst>              $s returnterm
  507	                        ':'                     $f colonexp
  508	                        [ <statement>           $f nostatement          ] ;
  509	
  510	<statement> ::=         ( <simple statement>    $s returnnt             |
  511	                          <goto statement>      $s returnnt             |
  512	                          <io statement>        $s returnnt             |
  513	                          <return statement>    $s returnnt             |
  514	                          <stop statement>      $s returnnt             |
  515	                          <compound statement>                          |
  516	                          <if statement>                                |
  517	                          <for statement>                               |
  518	                          <repeat statement>                            |
  519	                          <while statement>                             |
  520	                          <loop statement>                              |
  521	                          <case statement>                              |
  522	                          <with statement>                              |
  523	                          <exit clause>                                 ) ;
  524	
  525	<simple statement> ::=  <reference>
  526	                        [ <becomes>
  527	                          <expression>          $f norhs                ] ;
  528	
  529	<goto statement> ::=    GOTO
  530	                        <intconst>              $s attach
  531	                                                $f labelexp             ;
  532	
  533	<io statement> ::=      <io function>                   $s attach
  534	                        [ '('
  535	                          [ <io arg>            $s attachnt
  536	                            [ ','
  537	                              <io arg>          $s attachnt
  538	                                                $f expressionexp        ]* ]
  539	                          ')'                   $f rparenexp            ] ;
  540	
  541	<io arg> ::=            <expression>
  542	                        [ ':'
  543	                          <expression>          $f expressionexp        ]* ;
  544	
  545	<return statement> ::=  RETURN                                          ;
  546	
  547	<stop statement> ::=    STOP                                            ;
  548	
  549	<compound statement> ::=
  550	                        BEGIN                   $s returnterm
  551	                        <statement list>
  552	                        [ <handler clause>                              ]
  553	                        END                     $s returnterm
  554	                                                $f endstmtexp           ;
  555	
  556	<handler clause> ::=    EXCEPTION               $s returnterm
  557	                        <handler>               $f nohandler
  558	                        [ <handler>                                     ]* ;
  559	
  560	<handler> ::=           ( <identifier list>     $s returnnt             |
  561	                          OTHERS                $s returnterm           |
  562	                          ALLCONDITIONS         $s returnterm           )
  563	                        ':'                     $f colonexp
  564	                        [ <statement>           $f stmtincaseexp        ]
  565	                        [ ';'                   $f nocasedelim          ] ;
  566	
  567	<if statement> ::=      <if head>               $s returnnt
  568	                        [ <statement>           $f returnnt             ]
  569	                        [ ELSE                  $s returnterm
  570	                                                $f chksemielse
  571	                          [ <statement>         $f returnnt             ] ] ;
  572	
  573	<if head> ::=           IF
  574	                        <expression>            $f noifpred
  575	                        THEN                    $f thenexp              ;
  576	
  577	<for statement> ::=     <for head>              $s returnnt
  578	                        [ <statement>           $f returnnt             ] ;
  579	
  580	<for head> ::=          FOR
  581	                        <reference>             $f foridxexp
  582	                        <becomes>               $f becomesexp
  583	                        <expression>            $f forinitexp
  584	                        <for way>               $f forwayexp
  585	                        <expression>            $f forfinexp
  586	                        DO                      $f doexp                ;
  587	
  588	<for way> ::=           TO                      $s attach               |
  589	                        DOWNTO                  $s attach               ;
  590	
  591	<repeat statement> ::=  REPEAT                  $s returnterm
  592	                        <statement list>
  593	                        <until clause>          $s returnnt             ;
  594	
  595	<until clause> ::=      UNTIL                   $f untilexp
  596	                        <expression>            $f untilpredexp         ;
  597	
  598	<while statement> ::=   <while head>            $s returnnt
  599	                        [ <statement>           $f returnnt             ] ;
  600	
  601	<while head> ::=        WHILE
  602	                        <expression>            $f whilepredexp
  603	                        DO                      $f doexp                ;
  604	
  605	<loop statement> ::=    LOOP                    $s returnterm
  606	                        <statement list>
  607	                        END                     $s returnterm
  608	                                                $f endstmtexp           ;
  609	
  610	<case statement> ::=    <case head>             $s returnnt
  611	                        <case member>           $f nocase
  612	                        [ <case member>                                 ]*
  613	                        END                     $s returnterm
  614	                                                $f endstmtexp           ;
  615	
  616	<case head> ::=         CASE
  617	                        <expression>            $f expressionexp
  618	                        OF                      $f ofexp                ;
  619	
  620	<case member> ::=       ( <range list>          $s returnnt             |
  621	                          OTHERS                $s returnterm           )
  622	                        ':'                     $f colonexp
  623	                        [ <statement>           $f stmtincaseexp        ]
  624	                        [ ';'                   $f nocasedelim          ] ;
  625	
  626	<with statement> ::=    <with head>             $s returnnt
  627	                        [ <statement>           $f returnnt             ] ;
  628	
  629	<with head> ::=         WITH
  630	                        <reference>             $f nowithref
  631	                        [ ','
  632	                          <reference>           $f nowithref            ]*
  633	                        DO                      $f doexp                ;
  634	
  635	<exit clause> ::=       <exit head>             $s returnnt
  636	                        [ DO                    $s returnterm
  637	                          [ <statement>         $f returnnt             ] ] ;
  638	
  639	<exit head> ::=         EXIT
  640	                        IF                      $f ifexp
  641	                        <expression>            $f noifpred             ;
  642	
  643	<expression> ::=        <term>
  644	                        [ <relop>               $s attach
  645	                          <term>                $s infixop
  646	                                                $f operandexp           ]* ;
  647	
  648	<term> ::=              <factor>
  649	                        [ <addop>               $s attach
  650	                          <factor>              $s infixop
  651	                                                $f operandexp           ]* ;
  652	
  653	<factor> ::=            <power expr>
  654	                        [ <mulop>               $s attach
  655	                          <power expr>          $s infixop
  656	                                                $f operandexp           ]* ;
  657	
  658	<power expr> ::=        <unary expr>
  659	                        [ '**'                  $s attach
  660	                          <unary expr>          $s infixop
  661	                                                $f operandexp           ] ;
  662	
  663	<unary expr> ::=        ( <not op>              $s attachnt             |
  664	                          <sign op>             $s attachnt             |
  665	                          <simple expression>                           ) ;
  666	
  667	<not op> ::=            NOT
  668	                        <unary expr>            $f operandexp           ;
  669	
  670	<sign op> ::=           <sign>
  671	                        <unary expr>            $f operandexp           ;
  672	
  673	<simple expression> ::= <intconst>              $s attach               |
  674	                        <realconst>             $s attach               |
  675	                        <stringconst>           $s attach               |
  676	                        NIL                     $s attach               |
  677	                        <reference>                                     |
  678	                        <paren expr>            $s attachnt             |
  679	                        <set expression>        $s attachnt             ;
  680	
  681	<paren expr> ::=        '('
  682	                        [ <paren term>
  683	                          [ ','
  684	                            <paren term>        $f expressionexp        ]* ]
  685	                        ')'                     $f rparenexp            ;
  686	
  687	<paren term> ::=        <expression>
  688	                        [ OF                    $s attach
  689	                          <expression>          $s infixop
  690	                                                $f expressionexp        ] ;
  691	
  692	<set expression> ::=    '['
  693	                        [ <range list>                                  ]
  694	                        ']'                     $f rbracketexp          ;
  695	
  696	<range list> ::=        <range>
  697	                        [ ','
  698	                          <range>               $f rangeexp             ]* ;
  699	
  700	<range> ::=             <expression>
  701	                        [ '..'                  $s attach
  702	                          <expression>          $s infixop
  703	                                                $f expressionexp        ];
  704	
  705	<reference> ::=         <identifier>            $s attach
  706	                        [ <array qualifier>     $s attachqual           |
  707	                          <field qualifier>     $s attachqual           |
  708	                          <ptr qualifier>       $s attachqual           |
  709	                          <function qualifier>  $s attachqual           ]* ;
  710	
  711	<array qualifier> ::=   '['
  712	                        <subscript>             $f expressionexp
  713	                        [ ','
  714	                          <subscript>           $f expressionexp        ]*
  715	                        ']'                     $f rbracketexp          ;
  716	
  717	<subscript> ::=         <expression>
  718	                        [ ':'                   $s attach
  719	                          <expression>          $s infixop
  720	                                                $f expressionexp        ] ;
  721	
  722	<field qualifier> ::=   '.'
  723	                        <identifier>            $s attach
  724	                                                $f fieldexp             ;
  725	
  726	<ptr qualifier> ::=     '^'                                             ;
  727	
  728	<function qualifier> ::=
  729	                        '('
  730	                        [ <expression>
  731	                          [ ','
  732	                            <expression>        $f expressionexp        ]* ]
  733	                        ')'                     $f rparenexp            ;
  734	
  735	<becomes> ::=           ':='                                            |
  736	                        <equals>                $s eqinstead            ;
  737	
  738	<equals> ::=            <relop>                 $s chkeq                ;
  739	
  740	<star> ::=              <mulop>                 $s chkstar              ;
  741	
  742	<sign> ::=              <addop>                 $s chksign              ;
  743	
  744	$END

ADDR            OP             AT   AF           SG                    FG

   3     <dat or env module>    T    4                       
   4     <program or module>    T    F                       
   5            <program id>    7    6              RETURNNT 
   6             <module id>    7    7              RETURNNT              RETURNNT
   7          <declarations>    8    8                       
   8    <compound statement>    9    9                       
   9                       .   10    E                                      DOTEXP
  10                   <eof>    T    E                                   EXTRATEXT
  11         <datamodule id>   13   12              RETURNNT 
  12          <envmodule id>   13    F              RETURNNT 
  13          <declarations>   14   14                       
  14                     END   15    E                                  ENDSTMTEXP
  15                       .   16    E                                      DOTEXP
  16                   <eof>    T    E                                   EXTRATEXT
  17                 PROGRAM   18    F                       
  18            <identifier>   19    E                ATTACH             PROGIDEXP
  19          <subr options>   20   20              ATTACHNT 
  20                       ;    T    E                                     SEMIEXP
  21                  MODULE   22    F                       
  22            <identifier>   23    E                ATTACH             PROGIDEXP
  23          <subr options>   24   24              ATTACHNT 
  24                       ;    T    E                                     SEMIEXP
  25              DATAMODULE   26    F                       
  26            <identifier>   27    E                ATTACH             PROGIDEXP
  27          <subr options>   28   28              ATTACHNT 
  28                       ;    T    E                                     SEMIEXP
  29               ENVMODULE   30    F                       
  30            <identifier>   31    E                ATTACH             PROGIDEXP
  31          <subr options>   32   32              ATTACHNT 
  32                       ;    T    E                                     SEMIEXP
  33           <declaration>   34    F                                      NODECL
  34           <declaration>   34    T                                      NODECL
  35    <public declaration>    T   36                       
  36  <external declaration>    T   37                       
  37    <static declaration>    T   38                       
  38    <simple declaration>    T    F                       
  39                  PUBLIC   40    F                ATTACH 
  40     <const declaration>    T   41            RETURNQUAL 
  41      <subr declaration>    T   42                       
  42       <var declaration>    T   43            RETURNQUAL 
  43  <condition declaratio>    T   44            RETURNQUAL 
  44     <label declaration>    T   45            RETURNQUAL 
  45      <type declaration>    T    E            RETURNQUAL          DECLREQUIRED
  46                EXTERNAL   47    F                ATTACH 
  47     <const declaration>    T   48            RETURNQUAL 
  48       <var declaration>    T   49            RETURNQUAL 
  49  <condition declaratio>    T   50            RETURNQUAL 
  50             <subr decl>    T   51            RETURNQUAL 
  51     <label declaration>    T   52            RETURNQUAL 
  52      <type declaration>    T    E            RETURNQUAL          DECLREQUIRED
  53                  STATIC   54    F                ATTACH 
  54       <var declaration>    T   55            RETURNQUAL 
  55     <const declaration>    T   56            RETURNQUAL 
  56      <subr declaration>    T   57                       
  57     <label declaration>    T   58            RETURNQUAL 
  58  <condition declaratio>    T   59            RETURNQUAL 
  59      <type declaration>    T    E            RETURNQUAL          DECLREQUIRED
  60     <label declaration>    T   61              RETURNNT 
  61     <const declaration>    T   62              RETURNNT 
  62      <type declaration>    T   63              RETURNNT 
  63       <var declaration>    T   64              RETURNNT 
  64  <condition declaratio>    T   65            RETURNQUAL 
  65      <subr declaration>    T    F                       
  66                   LABEL   67    F                       
  67              <intconst>   68    E                ATTACH            LABELIDEXP
  68                       ,   69   70                       
  69              <intconst>   68    E                ATTACH            LABELIDEXP
  70                       ;    T    T                                    NOENDING
  71                   CONST   72    F                       
  72         <const id decl>   73    E              ATTACHNT               DECLEXP
  73         <const id decl>   73    T              ATTACHNT 
  74            <identifier>   75    F                ATTACH 
  75           <typed const>   79   76                       
  76                      :=   78   77                       
  77                <equals>   78    E                                  BECOMESEXP
  78            <expression>   79    E                                  INITVALEXP
  79                       ;    T    T                                    NOENDING
  80                       :   81    F                ATTACH 
  81             <type decl>   82    E                                     TYPEEXP
  82                      :=   84   83                       
  83                <equals>   84    T                       
  84            <expression>    T    E                                  INITVALEXP
  85                     VAR   86    F                       
  86           <var id decl>   87    E              ATTACHNT               DECLEXP
  87           <var id decl>   87    T              ATTACHNT 
  88       <identifier list>   89    F              ATTACHNT 
  89                       :   90    E                                    COLONEXP
  90             <type decl>   91    E                                     TYPEEXP
  91               <becomes>   92   93                       
  92            <expression>   93    E                                  INITVALEXP
  93                       ;    T    T                                    NOENDING
  94                    TYPE   95    F                       
  95          <type id decl>   96    E              ATTACHNT               DECLEXP
  96          <type id decl>   96    T              ATTACHNT 
  97            <identifier>   98    F                ATTACH 
  98                <equals>   99    E                                       EQEXP
  99             <type decl>  100    E                                     TYPEEXP
 100                       ;    T    T                                    NOENDING
 101            <identifier>  102    F                ATTACH 
 102                       ,  103    T                       
 103            <identifier>  102    E                ATTACH                 IDEXP
 104               EXCEPTION  105    F                       
 105       <identifier list>  106    E                                       IDEXP
 106                       ;    T    T                                    NOENDING
 107             <subr decl>  108    F                       
 108                 FORWARD  110  109            RETURNSUBR            RETURNSUBR
 109             <subr body>  110  110                       
 110                       ;    T    T                                    NOENDING
 111               PROCEDURE  113  112                ATTACH 
 112                FUNCTION  113    F                ATTACH 
 113            <identifier>  114    E                ATTACH           SUBRNAMEEXP
 114        <parameter list>  115  115              ATTACHNT 
 115             <parm type>  116  116                       
 116          <subr options>  117  117              ATTACHNT 
 117                       ;    T    T                                    NOENDING
 118                       (  119    F                       
 119             <parm decl>  120  122                       
 120                       ;  121  122                       
 121             <parm decl>  120    E                                 PARMDECLEXP
 122                       )    T    E                                   RPARENEXP
 123         <var parm decl>    T  124              ATTACHNT 
 124       <value parm decl>    T    F              ATTACHNT 
 125                     VAR  126    F                       
 126       <value parm decl>    T    E                                 PARMDECLEXP
 127           <vpd id left>    T  128                       
 128             <type decl>    T    F                       
 129            <identifier>  130    F                ATTACH 
 130          <parm id list>    T  131                       
 131             <parm type>    T  132                       
 132       <array qualifier>  132  133            ATTACHQUAL 
 133       <field qualifier>  132  134            ATTACHQUAL 
 134         <ptr qualifier>  132  135            ATTACHQUAL 
 135    <function qualifier>  132  136            ATTACHQUAL 
 136                 <mulop>  137  138                ATTACH 
 137            <unary expr>  136    E               INFIXOP            OPERANDEXP
 138                 <addop>  139  140                ATTACH 
 139                <factor>  138    E               INFIXOP            OPERANDEXP
 140                      ..  141    T                ATTACH 
 141                  <term>    T    E               INFIXOP                UPBEXP
 142                       ,  143    F                       
 143            <identifier>  144    E                ATTACH                 IDEXP
 144                       ,  145  146                       
 145            <identifier>  144    E                ATTACH                 IDEXP
 146             <parm type>    T    E                                     TYPEEXP
 147                       :  148    F                       
 148             <type decl>    T    E                                     TYPEEXP
 149           <declaration>  149  150                                      NODECL
 150    <compound statement>    T    E                                 SUBRBODYEXP
 151           <packed type>    T  152              ATTACHNT 
 152         <unpacked type>    T    F                       
 153                  PACKED  154    F                       
 154     <packed array type>    T  155              ATTACHNT 
 155                       [  156  158                       
 156            <expression>  157    E                               EXPRESSIONEXP
 157                       ]  158    E                                 RBRACKETEXP
 158         <unpacked type>    T    E                                     TYPEEXP
 159            <range type>    T  160                       
 160           <string type>    T  161              ATTACHNT 
 161          <pointer type>    T  162              ATTACHNT 
 162              <set type>    T  163              ATTACHNT 
 163        <aggregate type>    T  164                       
 164             <subr type>    T    F              ATTACHNT 
 165                  <term>  166    F                       
 166                      ..  167    T                ATTACH 
 167                  <term>  168    E                                      UPBEXP
 168           <prec clause>    T    T               INFIXOP               INFIXOP
 169                    PREC  170    F                ATTACH 
 170                  <term>    T    E                               EXPRESSIONEXP
 171                       ^  172    F                       
 172             <type decl>    T    E                                     TYPEEXP
 173                  STRING  174    F                       
 174                       [  175    T                       
 175              <upb expr>  176    E                               EXPRESSIONEXP
 176                       ]    T    E                                 RBRACKETEXP
 177                  <term>    T  178                       
 178                  <star>    T    F              ATTACHNT 
 179                     SET  180    F                       
 180                      OF  181    E                                       OFEXP
 181            <range type>    T    E                                     TYPEEXP
 182            <array type>    T  183              ATTACHNT 
 183           <record type>    T  184              ATTACHNT 
 184             <file type>    T    F              ATTACHNT 
 185                   ARRAY  186    F                       
 186                       [  187    E                                 LBRACKETEXP
 187            <index type>  188    E                                  IDXTYPEEXP
 188                       ,  189  190                       
 189            <index type>  188    E                                  IDXTYPEEXP
 190                       ]  191    E                                 RBRACKETEXP
 191                      OF  192    E                                       OFEXP
 192             <type decl>    T    E                                     TYPEEXP
 193            <array type>    T    F                       
 194                  <star>    T  195              ATTACHNT 
 195                  <term>  196    F                       
 196                      ..  197    T                ATTACH 
 197              <upb expr>    T    E               INFIXOP                UPBEXP
 198                  RECORD  199    F                       
 199            <field list>  200    E                       
 200                     END    T    E                                  ENDSTMTEXP
 201         <field id decl>  201  202              ATTACHNT 
 202          <variant part>    T    T              ATTACHNT 
 203       <identifier list>  204    F              ATTACHNT 
 204                       :  205    E                                    COLONEXP
 205             <type decl>  206    E                                     TYPEEXP
 206                       ;    T    T                                 NOFIELDSEMI
 207                    CASE  208    F                       
 208             <tag field>  209    E              ATTACHNT                 IDEXP
 209                      OF  210    E                                       OFEXP
 210          <variant case>  211    E              ATTACHNT             NOVARIANT
 211          <variant case>  211    T              ATTACHNT 
 212              <tag decl>    T  213                       
 213             <type decl>    T    F                       
 214            <identifier>  215    F                ATTACH 
 215                       :  216    T                       
 216             <type decl>    T    E                                     TYPEEXP
 217            <range list>  219  218              ATTACHNT 
 218                  OTHERS  219    F                ATTACH 
 219                       :  220    E                                    COLONEXP
 220                       (  221    E                                   LPARENEXP
 221            <field list>  222    E                       
 222                       )  223    E                                   RPARENEXP
 223                       ;    T    T                                 NOFIELDSEMI
 224                    FILE  225    F                       
 225                      OF  226    E                                       OFEXP
 226                  <star>    T  227              ATTACHNT 
 227             <type decl>    T    T                                     TYPEEXP
 228               PROCEDURE  230  229                ATTACH 
 229                FUNCTION  230    F                ATTACH 
 230        <parameter list>  231  231              ATTACHNT 
 231             <parm type>    T    T                       
 232                 OPTIONS  233    F                       
 233                <option>  234    E             ATTACHOPT                 IDEXP
 234                       ,  235    T                       
 235                <option>  234    E             ATTACHOPT                 IDEXP
 236                  <star>  237  237              ATTACHNT 
 237            <identifier>  238    E                ATTACH 
 238                       (  239    T                       
 239            <sub option>  240    E                                       IDEXP
 240                       ,  241  242                       
 241            <sub option>  240    E                                       IDEXP
 242                       )    T    E                                   RPARENEXP
 243            <identifier>    T  244                ATTACH 
 244              <intconst>    T    F                ATTACH 
 245          <stmt in list>  245  246                       
 246                       ;  245    T                       
 247     <labeled statement>  249  248                       
 248             <statement>  249    F                                 NOSTATEMENT
 249                       ;    T    T                                      NOSEMI
 250              <intconst>  251    F            RETURNTERM 
 251                       :  252    E                                    COLONEXP
 252             <statement>    T    T                                 NOSTATEMENT
 253      <simple statement>    T  254              RETURNNT 
 254        <goto statement>    T  255              RETURNNT 
 255          <io statement>    T  256              RETURNNT 
 256      <return statement>    T  257              RETURNNT 
 257        <stop statement>    T  258              RETURNNT 
 258    <compound statement>    T  259                       
 259          <if statement>    T  260                       
 260         <for statement>    T  261                       
 261      <repeat statement>    T  262                       
 262       <while statement>    T  263                       
 263        <loop statement>    T  264                       
 264        <case statement>    T  265                       
 265        <with statement>    T  266                       
 266           <exit clause>    T    F                       
 267             <reference>  268    F                       
 268               <becomes>  269    T                       
 269            <expression>    T    E                                       NORHS
 270                    GOTO  271    F                       
 271              <intconst>    T    E                ATTACH              LABELEXP
 272           <io function>  273    F                ATTACH 
 273                       (  274    T                       
 274                <io arg>  275  277              ATTACHNT 
 275                       ,  276  277                       
 276                <io arg>  275    E              ATTACHNT         EXPRESSIONEXP
 277                       )    T    E                                   RPARENEXP
 278            <expression>  279    F                       
 279                       :  280    T                       
 280            <expression>  279    E                               EXPRESSIONEXP
 281                  RETURN    T    F                       
 282                    STOP    T    F                       
 283                   BEGIN  284    F            RETURNTERM 
 284        <statement list>  285    E                       
 285        <handler clause>  286  286                       
 286                     END    T    E            RETURNTERM            ENDSTMTEXP
 287               EXCEPTION  288    F            RETURNTERM 
 288               <handler>  289    E                                   NOHANDLER
 289               <handler>  289    T                       
 290       <identifier list>  293  291              RETURNNT 
 291                  OTHERS  293  292            RETURNTERM 
 292           ALLCONDITIONS  293    F            RETURNTERM 
 293                       :  294    E                                    COLONEXP
 294             <statement>  295  295                               STMTINCASEEXP
 295                       ;    T    T                                 NOCASEDELIM
 296               <if head>  297    F              RETURNNT 
 297             <statement>  298  298                                    RETURNNT
 298                    ELSE  299    T            RETURNTERM           CHKSEMIELSE
 299             <statement>    T    T                                    RETURNNT
 300                      IF  301    F                       
 301            <expression>  302    E                                    NOIFPRED
 302                    THEN    T    E                                     THENEXP
 303              <for head>  304    F              RETURNNT 
 304             <statement>    T    T                                    RETURNNT
 305                     FOR  306    F                       
 306             <reference>  307    E                                   FORIDXEXP
 307               <becomes>  308    E                                  BECOMESEXP
 308            <expression>  309    E                                  FORINITEXP
 309               <for way>  310    E                                   FORWAYEXP
 310            <expression>  311    E                                   FORFINEXP
 311                      DO    T    E                                       DOEXP
 312                      TO    T  313                ATTACH 
 313                  DOWNTO    T    F                ATTACH 
 314                  REPEAT  315    F            RETURNTERM 
 315        <statement list>  316    E                       
 316          <until clause>    T    E              RETURNNT 
 317                   UNTIL  318    F                                    UNTILEXP
 318            <expression>    T    E                                UNTILPREDEXP
 319            <while head>  320    F              RETURNNT 
 320             <statement>    T    T                                    RETURNNT
 321                   WHILE  322    F                       
 322            <expression>  323    E                                WHILEPREDEXP
 323                      DO    T    E                                       DOEXP
 324                    LOOP  325    F            RETURNTERM 
 325        <statement list>  326    E                       
 326                     END    T    E            RETURNTERM            ENDSTMTEXP
 327             <case head>  328    F              RETURNNT 
 328           <case member>  329    E                                      NOCASE
 329           <case member>  329  330                       
 330                     END    T    E            RETURNTERM            ENDSTMTEXP
 331                    CASE  332    F                       
 332            <expression>  333    E                               EXPRESSIONEXP
 333                      OF    T    E                                       OFEXP
 334            <range list>  336  335              RETURNNT 
 335                  OTHERS  336    F            RETURNTERM 
 336                       :  337    E                                    COLONEXP
 337             <statement>  338  338                               STMTINCASEEXP
 338                       ;    T    T                                 NOCASEDELIM
 339             <with head>  340    F              RETURNNT 
 340             <statement>    T    T                                    RETURNNT
 341                    WITH  342    F                       
 342             <reference>  343    E                                   NOWITHREF
 343                       ,  344  345                       
 344             <reference>  343    E                                   NOWITHREF
 345                      DO    T    E                                       DOEXP
 346             <exit head>  347    F              RETURNNT 
 347                      DO  348    T            RETURNTERM 
 348             <statement>    T    T                                    RETURNNT
 349                    EXIT  350    F                       
 350                      IF  351    E                                       IFEXP
 351            <expression>    T    E                                    NOIFPRED
 352                  <term>  353    F                       
 353                 <relop>  354    T                ATTACH 
 354                  <term>  353    E               INFIXOP            OPERANDEXP
 355                <factor>  356    F                       
 356                 <addop>  357    T                ATTACH 
 357                <factor>  356    E               INFIXOP            OPERANDEXP
 358            <power expr>  359    F                       
 359                 <mulop>  360    T                ATTACH 
 360            <power expr>  359    E               INFIXOP            OPERANDEXP
 361            <unary expr>  362    F                       
 362                      **  363    T                ATTACH 
 363            <unary expr>    T    E               INFIXOP            OPERANDEXP
 364                <not op>    T  365              ATTACHNT 
 365               <sign op>    T  366              ATTACHNT 
 366     <simple expression>    T    F                       
 367                     NOT  368    F                       
 368            <unary expr>    T    E                                  OPERANDEXP
 369                  <sign>  370    F                       
 370            <unary expr>    T    E                                  OPERANDEXP
 371              <intconst>    T  372                ATTACH 
 372             <realconst>    T  373                ATTACH 
 373           <stringconst>    T  374                ATTACH 
 374                     NIL    T  375                ATTACH 
 375             <reference>    T  376                       
 376            <paren expr>    T  377              ATTACHNT 
 377        <set expression>    T    F              ATTACHNT 
 378                       (  379    F                       
 379            <paren term>  380  382                       
 380                       ,  381  382                       
 381            <paren term>  380    E                               EXPRESSIONEXP
 382                       )    T    E                                   RPARENEXP
 383            <expression>  384    F                       
 384                      OF  385    T                ATTACH 
 385            <expression>    T    E               INFIXOP         EXPRESSIONEXP
 386                       [  387    F                       
 387            <range list>  388  388                       
 388                       ]    T    E                                 RBRACKETEXP
 389                 <range>  390    F                       
 390                       ,  391    T                       
 391                 <range>  390    E                                    RANGEEXP
 392            <expression>  393    F                       
 393                      ..  394    T                ATTACH 
 394            <expression>    T    E               INFIXOP         EXPRESSIONEXP
 395            <identifier>  396    F                ATTACH 
 396       <array qualifier>  396  397            ATTACHQUAL 
 397       <field qualifier>  396  398            ATTACHQUAL 
 398         <ptr qualifier>  396  399            ATTACHQUAL 
 399    <function qualifier>  396    T            ATTACHQUAL 
 400                       [  401    F                       
 401             <subscript>  402    E                               EXPRESSIONEXP
 402                       ,  403  404                       
 403             <subscript>  402    E                               EXPRESSIONEXP
 404                       ]    T    E                                 RBRACKETEXP
 405            <expression>  406    F                       
 406                       :  407    T                ATTACH 
 407            <expression>    T    E               INFIXOP         EXPRESSIONEXP
 408                       .  409    F                       
 409            <identifier>    T    E                ATTACH              FIELDEXP
 410                       ^    T    F                       
 411                       (  412    F                       
 412            <expression>  413  415                       
 413                       ,  414  415                       
 414            <expression>  413    E                               EXPRESSIONEXP
 415                       )    T    E                                   RPARENEXP
 416                      :=    T  417                       
 417                <equals>    T    F             EQINSTEAD 
 418                 <relop>    T    F                 CHKEQ 
 419                 <mulop>    T    F               CHKSTAR 
 420                 <addop>    T    F               CHKSIGN 

TERMINAL SYMBOLS

   1 <identifier>           IDENT
   2 <intconst>             INTCONST
   3 <realconst>            REALCONST
   4 <stringconst>          STRINGCONST
   5 NIL                    NILSY
   6 NOT                    NOTSY
   7 **                     POWEROP
   8 <mulop>                MULOP
   9 <addop>                ADDOP
  10 <relop>                RELOP
  11 (                      LPARENT
  12 )                      RPARENT
  13 [                      LBRACKET
  14 ]                      RBRACKET
  15 ,                      COMMA
  16 .                      PERIOD
  17 ^                      ARROW
  18 :                      COLON
  19 :=                     BECOMES
  20 ;                      SEMICOLON
  21 ..                     ELIPSIS
  22 LABEL                  LABELSY
  23 CONST                  CONSTSY
  24 TYPE                   TYPESY
  25 VAR                    VARSY
  26 FUNCTION               FUNCTIONSY
  27 PROCEDURE              PROCEDURESY
  28 EXCEPTION              EXCEPTIONSY
  29 EXTERNAL               EXTERNALSY
  30 PUBLIC                 PUBLICSY
  31 STATIC                 STATICSY
  32 FORWARD                FORWARDSY
  33 OPTIONS                OPTIONSSY
  34 PACKED                 PACKEDSY
  35 SET                    SETSY
  36 ARRAY                  ARRAYSY
  37 RECORD                 RECORDSY
  38 STRING                 STRINGSY
  39 FILE                   FILESY
  40 PREC                   PRECSY
  41 PROGRAM                PROGRAMSY
  42 MODULE                 MODULESY
  43 DATAMODULE             DATAMODSY
  44 ENVMODULE              ENVMODSY
  45 BEGIN                  BEGINSY
  46 IF                     IFSY
  47 CASE                   CASESY
  48 REPEAT                 REPEATSY
  49 WHILE                  WHILESY
  50 FOR                    FORSY
  51 WITH                   WITHSY
  52 LOOP                   LOOPSY
  53 GOTO                   GOTOSY
  54 RETURN                 RETURNSY
  55 STOP                   STOPSY
  56 <io function>          IOSY
  57 EXIT                   EXITSY
  58 END                    ENDSY
  59 THEN                   THENSY
  60 ELSE                   ELSESY
  61 UNTIL                  UNTILSY
  62 OF                     OFSY
  63 DO                     DOSY
  64 TO                     TOSY
  65 DOWNTO                 DOWNTOSY
  66 OTHERS                 OTHERSSY
  67 ALLCONDITIONS          ALLCONDSY
  68 <eof>                  EOFSY


SEMANTIC OPERATIONS

   1 ATTACH
   2 ATTACHNT
   3 ATTACHQUAL
   4 INFIXOP
   5 RETURNNT
   6 RETURNTERM
   7 RETURNSUBR
   8 RETURNQUAL
   9 ATTACHOPT
  10 EXTRATEXT
  11 PROGIDEXP
  12 SEMIEXP
  13 PROGEXP
  14 DOTEXP
  15 DECLEXP
  16 LABELIDEXP
  17 NODECL
  18 NOENDING
  19 TYPEEXP
  20 INITVALEXP
  21 COLONEXP
  22 SUBRNAMEEXP
  23 SUBRBODYEXP
  24 PARMDECLEXP
  25 IDEXP
  26 CHKEQ
  27 CHKSTAR
  28 EQEXP
  29 LBRACKETEXP
  30 IDXTYPEEXP
  31 OFEXP
  32 NOFIELDSEMI
  33 NOVARIANT
  34 NOCASELAB
  35 LPARENEXP
  36 NOSTATEMENT
  37 NOSEMI
  38 NORHS
  39 NOIFPRED
  40 THENEXP
  41 CHKSEMIELSE
  42 FORIDXEXP
  43 BECOMESEXP
  44 FORINITEXP
  45 FORWAYEXP
  46 FORFINEXP
  47 DOEXP
  48 UNTILEXP
  49 UNTILPREDEXP
  50 WHILEPREDEXP
  51 NOCASE
  52 STMTINCASEEXP
  53 NOCASEDELIM
  54 NOWITHREF
  55 LABELEXP
  56 ENDSTMTEXP
  57 IFEXP
  58 OPERANDEXP
  59 EXPRESSIONEXP
  60 RPARENEXP
  61 RBRACKETEXP
  62 RANGEEXP
  63 UPBEXP
  64 FIELDEXP
  65 EQINSTEAD
  66 CHKSIGN
  67 DECLREQUIRED
  68 NOHANDLER


NON-TERMINAL SYMBOLS

     3 <program>
     5 <program or module>
    11 <dat or env module>
    17 <program id>             PROGRAM_ID
    21 <module id>              MODULE_ID
    25 <datamodule id>          DATAMOD_ID
    29 <envmodule id>           ENVMOD_ID
    33 <declarations>
    35 <declaration>            DECLARATION
    39 <public declaration>
    46 <external declaration>
    53 <static declaration>
    60 <simple declaration>
    66 <label declaration>      LABEL_DECLARATION
    71 <const declaration>      CONST_DECLARATION
    74 <const id decl>          CONST_ID_DECL
    80 <typed const>
    85 <var declaration>        VAR_DECLARATION
    88 <var id decl>            VAR_ID_DECL
    94 <type declaration>       TYPE_DECLARATION
    97 <type id decl>           TYPE_ID_DECL
   101 <identifier list>        ID_LIST
   104 <condition declaratio>   COND_DECLARATION
   107 <subr declaration>
   111 <subr decl>              SUBR_DECL
   118 <parameter list>         PARM_LIST
   123 <parm decl>
   125 <var parm decl>          VAR_PARM_DECL
   127 <value parm decl>        VALUE_PARM_DECL
   129 <vpd id left>
   142 <parm id list>
   147 <parm type>
   149 <subr body>
   151 <type decl>              TYPE_DECL
   153 <packed type>            PACKED_TYPE
   159 <unpacked type>
   165 <range type>
   169 <prec clause>
   171 <pointer type>           POINTER_TYPE
   173 <string type>            STRING_TYPE
   177 <upb expr>
   179 <set type>               SET_TYPE
   182 <aggregate type>
   185 <array type>             ARRAY_TYPE
   193 <packed array type>      PK_ARRAY_TYPE
   194 <index type>
   198 <record type>            RECORD_TYPE
   201 <field list>
   203 <field id decl>          FIELD_ID_DECL
   207 <variant part>           VARIANT_PART
   212 <tag field>              TAG_FIELD
   214 <tag decl>
   217 <variant case>           VARIANT_CASE
   224 <file type>              FILE_TYPE
   228 <subr type>              SUBR_TYPE
   232 <subr options>           SUBR_OPTIONS
   236 <option>
   243 <sub option>
   245 <statement list>
   247 <stmt in list>
   250 <labeled statement>
   253 <statement>              NULL_STMT
   267 <simple statement>       SIMPLE_STMT
   270 <goto statement>         GOTO_STMT
   272 <io statement>           IO_STMT
   278 <io arg>                 IO_ARG
   281 <return statement>       RETURN_STMT
   282 <stop statement>         STOP_STMT
   283 <compound statement>
   287 <handler clause>
   290 <handler>
   296 <if statement>
   300 <if head>                IF_STMT
   303 <for statement>
   305 <for head>               FOR_STMT
   312 <for way>
   314 <repeat statement>
   317 <until clause>           UNTIL_CLAUSE
   319 <while statement>
   321 <while head>             WHILE_STMT
   324 <loop statement>
   327 <case statement>
   331 <case head>              CASE_STMT
   334 <case member>
   339 <with statement>
   341 <with head>              WITH_STMT
   346 <exit clause>
   349 <exit head>              EXIT_CLAUSE
   352 <expression>             EXPRTREE
   355 <term>
   358 <factor>
   361 <power expr>
   364 <unary expr>
   367 <not op>                 NOT_OP
   369 <sign op>                SIGN_OP
   371 <simple expression>
   378 <paren expr>             PAREN_EXPR
   383 <paren term>
   386 <set expression>         SET_EXPR
   389 <range list>             RANGE_LIST
   392 <range>
   395 <reference>
   400 <array qualifier>        ARRAY_QUALIFIER
   405 <subscript>
   408 <field qualifier>        FIELD_QUALIFIER
   410 <ptr qualifier>          PTR_QUALIFIER
   411 <function qualifier>     FUNC_QUALIFIER
   416 <becomes>
   418 <equals>
   419 <star>                   STARSY
   420 <sign>

    ,M{