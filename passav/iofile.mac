	search	RTSYM
	search	IOSYM
	sall
	$MODULE	IORES

	entry	RESET.
	extern	OPEN.,GETCH.

; RESET. -- reset for a text file.  To make RESET an indivisible operation
;   with respect to errors, we call OPEN. to open the file, then if and
;   only if everything went well, we do the GET.  Increase the library size
;   by a bit, incidentally reduce inline code by 3 words per RESET.

RESET.:	$MASK
	PUSH	TOP,PSA		; combination FRAME and SAVE
	MOVEI	PSA,4		; get an address for passing parameters
	ADDB	PSA,-1(TOP)	;   in the usual style.
	LDB	R1,[point 4,-4(PSA),12]	; pick up specified AC bits
	TRNE	R1,1		; we're interested in internal file name bit
	JRST	RESINT		;   it's internal

	PUSHJ	TOP,OPEN.	; do it
	  ARG	0,@-4(PSA)	; we have addr of word past original
	  ARG	0,@-3(PSA)	;   parameter list, so use it to get
	  ARG	0,@-2(PSA)	;   OPEN. set up on the original list
	  ARG	0,@-1(PSA)	;   (assuming it doesn't use PSA!!).
	JRST	RESETT		; we're in business

RESINT:	PUSHJ	TOP,OPEN.	; do it
	  ARG	1,@-4(PSA)	;   only difference is the int. filename bit
	  ARG	0,@-3(PSA)
	  ARG	0,@-2(PSA)
	  ARG	0,@-1(PSA)

RESETT:	SKIPLE	0,ERRORS(R1)	; did the OPEN succeed?
	JRST	RSTOUT		;   no, just return now
	MOVEI	PSA,0(R1)	; it did -- pass and save file block addr
	PUSHJ	TOP,GETCH.	;   while we fill the component
	  ARG	0,0(PSA)
	MOVEI	R1,0(PSA)	; but remember, we return FB in R1

RSTOUT:	POP	TOP,PSA		; restore our sequestered R14
	$UNMASK			; all clear
	POPJ	TOP,0
	prgend
	search	RTSYM
	search	IOSYM
	search	OPDEFS
	sall
	$MODULE	IOCLR

	entry	CLEAR.

; CLEAR. -- discard terminal input/output.  If it's either of TTY or
;   TTYOUTPUT, zero out the count and reset the byte pointer.

CLEAR.:	MOVEI	R1,1		; get the arg
	ADDB	R1,0(TOP)
	MOVEI	R1,@-1(R1)
	MOVEI	R0,ISTTYI+ISTTYO
	TDNN	R0,STATUS(R1)	; are any set?
	POPJ	TOP,0		;   no, split
	SETZM	0,CURSOR(R1)	; clear cursor
	SETZM	0,BUFCNT(R1)	;   and buffer counter
	HRRI	R0,BUFFER(R1)	; compute new byte pointer
	HRLI	R0,440700
	MOVEM	R0,BUFPTR(R1)	; and install
	MOVEI	R0," "		; reset component to blank
	MOVEM	R0,@COMPTR(R1)
	POPJ	TOP,0		; toodles
	prgend
	search	RTSYM
	search	IOSYM
	search	OPDEFS
	sall
	$MODULE	IOEMY
	$TEMP	BREEZE,1	; for pushj
	$TEMP	LARGS,4		; where to explode args
	$TEMP	JCELL,1		; RA for nested routines
	$TEMP	ARGBLK,^o11	; argument block for monitor
	$TEMP	FBLOCK,5+MAXSFD	;   and for TENIO file parser

	$LOCAL	REGSAV,3	; must frame for call to FNAME.
	$LOCAL	FNSTR,^o21	; string[80]

	entry	EMPTY.
	extern	FNAME.,IOERR.,TENIO.,PASUO.,BUF.0

; EMPTY. -- empty non-text file.  Close the file via TENIO, and then
;   reopen, using the duplicate set of bits saved in IOINST in the
;   file block.  Must check to see if output is permitted.

EMPTY.:	MOVEI	R1,1		; one arg
	ADDB	R1,0(TOP)
	MOVEI	R1,@-1(R1)	;   a file block addr
	$FRAME
	$SAVE	REGSAV,EXP1,EXP3
	$MASK
	SKIPLE	0,ERRORS(R1)	; any errors?
	JRST	EMPTNO		;   yes, go throw up.
	SETZM	0,ERRORS(R1)	;   else reset error codes
	SETZM	0,$IOERR(PDA)
	SETZM	0,$EXTST(PDA)
	MOVEI	EXP1,0(R1)	; pars for FNAME.
	MOVEI	EXP2,FNSTR	;   file block and string
	PUSHJ	TOP,FNAME.
	SKIPN	0,0(EXP2)	; did we get anything?
	JRST	NOEMPT		;   no, forget it
	MOVEI	R0,OPNOUT	; check for being open for output
	TDNN	R0,STATUS(EXP1)
	JRST	NOEMP1 		;   no, fail now
	SETZ	R1,0		; close without deleting
	CLOSEF	R1,CHNUM(EXP1)	;   do it
	JRST	NOEMP1
	MOVEI	EXP3,0(EXP1)	; load file block addr
	HLL	R0,IOINST(EXP3)	; get old bits
	TLZ	R0,^o100000	; clear bit to force deletion of contents
	TLO	R0,^o2000	; set bit for string file name
	HRR	R0,FNSTR	; the string length
	MOVEI	R1,TENBUF(EXP3)	; buffer whether we need it or not
	HRRI	EXP1,1+FNSTR	; compose a byte pointer to file name
	HRLI	EXP1,440700
	OPENF	R0,CHNUM(EXP3)	; do it, dick
	JRST	NOEMPT		; hell with it
	HRLI	R0,EOFBIT	; set EOF true
	HRRI	R0,EOFCNT
	MOVEM	R0,EOFWRD(EXP3)
	SETZM	0,CURSOR(EXP3)	; reinit cursor
EMPOUT:	$RESTOR	REGSAV,EXP1,EXP3
	$UNMASK
	$UNFRAME
	POPJ	TOP,0

NOEMP1:	MOVEI	EXP3,0(EXP1)	; load EXP3 with file block addr
	MOVE	R1,R0		; load error code in R1
NOEMPT:	MOVEM	R1,$EXTST(PDA)	; record extended status
	LDERR	R1,EMPERR	;   and load the error code.
	MOVEM	R1,ERRORS(EXP3)
	MOVEM	R1,$IOERR(PDA)	; also install in global cell.
	HRLZI	R0,ETRAP	; must see if file is trapping
	TDNE	R0,STATUS(EXP3)	; well?
	JRST	EMPOUT		;   ok
	MOVE	R0,0(TOP)	; pop return addr
	JRST	IOERR.		;   and go die

EMPTNO:	MOVE	R1,ERRORS(R1)	; load whatever error code it was
	MOVE	R0,0(TOP)	;   and return addr
	JRST	IOERR.		;   and die.
	$END	IOEMY
	prgend
	search	RTSYM
	search	IOSYM
	sall
	$MODULE	IOEMX
	$TEMP	BREEZE,1	; for pushj
	$TEMP	LARGS,4		; where to explode args
	$TEMP	JCELL,1		; RA for nested routines
	$TEMP	ARGBLK,^o11	; argument block for monitor
	$TEMP	FBLOCK,5+MAXSFD	;   and for TENIO file parser

	$LOCAL	REGSAV,^o13	; must frame for call to fname.
	$LOCAL	FNSTR,^o21	; string[80] for file name

	entry	EMPTX.		; empty for text files
	extern	FNAME.,GTIFN.,IOERR.,DODEC.

; EMPTX. -- empty text file.  Get the full file name, manually close the
;   file, and try for an ENTER on the file name.   It's a fatal error if
;   this one fails, so don't worry about clean-up.

EMPTX.:	MOVEI	R1,1		; one arg
	ADDB	R1,0(TOP)
	MOVEI	R1,@-1(R1)	; get the file block addr
	$FRAME
	$SAVE	REGSAV,EXP1,PSA
	$MASK
	SKIPLE	0,ERRORS(R1)	; any deferred errors?
	JRST	EMPTNO		;   yes
	SETZM	0,ERRORS(R1)	; no, clear error cells
	SETZM	0,$IOERR(PDA)
	SETZM	0,$EXTST(PDA)
	MOVEI	EXP1,0(R1)	; params for FNAME -- file block addr
	MOVEI	EXP2,FNSTR	;   and string variable addr
	PUSHJ	TOP,FNAME.
	SKIPN	0,0(EXP2)	; did we get anything?
	JRST	NOEMPT		;   zero length string -- error.
	MOVEI	EXP3,0(EXP1)	; put block addr in EXP3 for safe keeping
	MOVEI	R0,OPNOUT	; see if file was open for output
	TDNN	R0,STATUS(EXP3)
	JRST	NOEMPT		; no, forget it
	HRLZI	R1,(close)	; set up CLOSE skeleton
	MOVE	EXP2,CHNUM(EXP3)	; standard channel trick
	LSH	EXP2,^o27	; into AC field
	OR	R1,EXP2		;   and into instr.
	$DOUUO	XCT,0,R1,EMPOK	; no skip return
EMPOK:	MOVEI	R1,1+FNSTR	; compose byte pointer to file name
	HRLI	R1,440700	;   for tenio file name parser
	MOVEM	R1,1+LARGS
	MOVE	R1,FNSTR	; string length
	MOVEM	R1,2+LARGS
	JSP	CO1,GTIFN.	; go ahead
	JRST	NOEMPT		; huh?
	JRST	NOEMPT		;   TTY can't be emptied!
	JSP	CO1,DODEC.	; OK, set up dec-style lookup bloc
	MOVE	R1,[enter 0,ARGBLK]	; and the instr
	OR	R1,EXP2
	$DOUUO	XCT,0,R1,NOEMPT,EMPOK2
EMPOK2:	HRLI	R1,EOFBIT	; initialize to end of file
	HRRI	R1,EOFCNT
	MOVEM	R1,EOFWRD(EXP3)
	SETZM	0,CURSOR(EXP3)	; reinit cursor
	SETZM	0,BUFCNT(EXP3)	;   and buffer count
	HRRI	R0,BUFFER(EXP3)	; reinit byte pointer to start
	HRLI	R0,440700	;   of buffer
	MOVEM	R0,BUFPTR(EXP3)
EMPOUT:	$RESTOR	REGSAV,EXP1,PSA
	$UNMASK
	$UNFRAM
	POPJ	TOP,0

NOEMPT:	HRRZ	R1,1+ARGBLK	; get error code from monitor
	MOVEM	R1,$EXTST(PDA)	;   and call it extended status.
	LDERR	R1,EMPERR	; record error code in block
	MOVEM	R1,ERRORS(EXP3)
	MOVEM	R1,$IOERR(PDA)	; also install in global cell.
	HRLZI	R0,ETRAP	; find out if this guy traps
	TDNE	R0,STATUS(EXP3)
	JRST	EMPOUT		;   yes, go ahead
	MOVE	R0,0(TOP)	; must die -- put return addr in R0
	JRST	IOERR.		; pontiatello!
	$END	IOEMX

EMPTNO:	MOVE	R1,ERRORS(R1)	; load whatever error it was
	MOVE	R0,0(TOP)	; and the return addr
	JRST	IOERR.		;   and die
	prgend
	search	RTSYM
	search	IOSYM
	sall
	$MODULE	IOPEN
	$TEMP	BREEZE,1	; for pushj
	$TEMP	LARGS,4		; where to explode args
	$TEMP	JCELL,1		; RA for nested routines
	$TEMP	ARGBLK,^o11	; argument block for monitor
	$TEMP	FBLOCK,5+MAXSFD	;   and for TENIO file parser
	$TEMP	REGSAV,^o13	; good old register save area
	$TEMP	TENSAV,^o16	;   one for TENIO parser too

	entry	OPEN.
	extern	FRECN.,FMTCH.,FLCHN.,IOFAK.,FFRBF.,CLOSA.
	extern	FARGX.,GTIFN.,DOTXT.,.JBFF,DODEC.

; OPEN. -- initialize text file for input.  We explode the args, parse
;   the file name.  If it looks like 'TTY:', we see if TTY has already
;   been created via FMTCH., otherwise we create one.

OPEN.:	JSP	R1,FARGX.	; explode args on top of stack
	TRO	OPBITS,OPNINP	; remember we're open for input!
	JSP	CO1,GTIFN.	; parse the file name
	JRST	OPNER0		;   nonsense
	JRST	OPNTTY		;   looks like TTY

DOTEXT:	JSP	CO1,DOTXT.	; common code for text files
	JRST	OPNER0		; something wrong?
	MOVEI	R1,RINGHD(FBL)	; address of ring header
	MOVEM	R1,2+ARGBLK	;   in right half for input
	$DOUUO	XCT,0,R0,OPNER2,DOINIT
	; do the open, get rid of channel and block if no good

DOINIT:	HRLZI	R0,(inbuf)	; make an input buffer
	OR	R0,CO2		; install channel number
	ADDI	R0,1		; make only one buffer
	MOVEI	R1,BUFFHD(FBL)	; where the header is
	EXCH	R1,.JBFF	; make it work right
	$DOUUO	XCT,0,R0,JBREST	; no error
JBREST:	MOVEM	R1,.JBFF	; restore .JBFF
	TRNE	OPBITS,ISTTYI	; if it's tty for input
	JRST	OPNXIT		;   then skip lookup jazz
	JSP	CO1,DODEC.	; set up DEC style block for LOOKUP
	MOVE	R0,[lookup 0,ARGBLK]
	OR	R0,CO2		; the instruction with channel number
	$DOUUO	XCT,0,R0,OPNER3,OPNXIT

OPNXIT:	MOVE	R0,1+ARGBLK	; pick up actual ppn
	MOVEM	R0,FILPPN(FBL)	; and save it
	JSP	CO1,FLCHN.	; chain file block on
	HRLZI	R0,EOLBIT	; EOL for all input files
	MOVEM	R0,EOFWRD(FBL)
	HRLZI	R0,(in)		; I/O transfer instruction for input files
	OR	R0,CO2		; install channel number
	MOVEM	R0,IOINST(FBL)
	MOVEM	OPBITS,STATUS(FBL)
	MOVE	R0,[ascii/-----/]	; funny init val for linenr
	MOVEM	R0,LINENR(FBL)
OPNDON:	MOVEI	R1,0(FBL)	; always return file block addr in R1
	$RESTOR	REGSAV,EXP1,PSA
	$UNMASK
	POPJ	TOP,0

OPNER3:	HRRZ	CO1,1+ARGBLK	; get monitor's error code from LOOKUP
	MOVEM	CO1,$EXTST(PDA)	;   and call it extended status.

OPNER2:	MOVE	CO1,[release 0,0]	; must release the channel
	OR	CO1,CO2
	$DOUUO	XCT,0,CO1,OPNER1
OPNER1:	MOVE	R0,CHNUM(FBL)	; return channel to free pool
	PUSHJ	TOP,FRECN.
	JSP	CO1,FFRBF.	; return file block to pool

OPNER0:	JSP	CO1,IOFAK.	; return fake block
	JRST	OPNDON		;   and split

OPNTTY:	MOVEI	PR2,ISTTYI	; set search bit
	OR	OPBITS,PR2	; remember if we have to make one
	JSP	CO1,FMTCH.	; match it
	JRST	DOTEXT		; not found, make one
;
; check options here!
;
	JRST	OPNDON
	$END	IOPEN
	prgend
	search	RTSYM
	search	IOSYM
	sall
	$MODULE	IORWR
	$TEMP	BREEZE,1	; for pushj
	$TEMP	LARGS,4		; where to explode args
	$TEMP	JCELL,1		; RA for nested routines
	$TEMP	ARGBLK,^o11	; argument block for monitor
	$TEMP	FBLOCK,5+MAXSFD	;   and for TENIO file parser
	$TEMP	REGSAV,^o13	; good old register save area
	$TEMP	TENSAV,^o16	;   one for TENIO parser too

	entry	REWRT.
	extern	FRECN.,FMTCH.,FLCHN.,IOFAK.,FFRBF.,CLOSA.
	extern	FARGX.,GTIFN.,DOTXT.,.JBFF,DODEC.

; REWRT. -- initialize text file for output.  Explode args, parse the
;   file name.  Same TTY hack as with OPEN.

REWRT.:	JSP	R1,FARGX.	; explode args on top of stack
	TRO	OPBITS,OPNOUT	; remember we're open for output!
	JSP	CO1,GTIFN.	; parse the file name
	JRST	OPNER0		;   nonsense
	JRST	REWTTY		;   looks like TTY

DOTEXT:	JSP	CO1,DOTXT.	; common code for text files
	JRST	OPNER0		; something wrong?
	MOVEI	R1,RINGHD(FBL)	; address of ring header
	HRLZM	R1,2+ARGBLK	;   in right half for output
	$DOUUO	XCT,0,R0,REWER2,DOINIT
	; do the open, get rid of channel and block if no good

DOINIT:	HRLZI	R0,(outbuf)	; make an output buffer
	OR	R0,CO2		; install channel number
	ADDI	R0,1		; make only one buffer
	MOVEI	R1,BUFFHD(FBL)	; where the header is
	EXCH	R1,.JBFF	; make it work right
	$DOUUO	XCT,0,R0,JBREST	; no error
JBREST:	MOVEM	R1,.JBFF	; restore .JBFF
	TRNE	OPBITS,ISTTYO	; if it's tty for output
	JRST	REWXIT		;   then skip lookup jazz
	JSP	CO1,DODEC.	; set up DEC style block for LOOKUP
	TLNN	OPBITS,PRESBI	; is preserve option specified?
	JRST	DONTR		;   no, just do the enter
	MOVE	R0,[lookup 0,ARGBLK]
	OR	R0,CO2		; set up the ENTER
	$DOUUO	XCT,0,R0,DOENTR,DOPRES
	; do it, if failure, just do enter else enter and USETO

DOPRES:	MOVE	R0,1+ARGBLK	; pick up actual ppn
	MOVEM	R0,FILPPN(FBL)	; and remember it
	JSP	CO1,DODEC.	; reset arg block
	MOVE	R0,[enter 0,ARGBLK]
	OR	R0,CO2		; set up the enter
	$DOUUO	XCT,0,R0,REWER3,DOECCH
	; do it, if fails, whole thing fails, else do USETO

DOECCH:	HRLZI	R0,(out)	; must do phony output before useto
	OR	R0,CO2
	$DOUUO	XCT,0,R0,DOCURS,REWER3
	; noskip is ok, else error

DOCURS:	MOVE	R0,[useti 0,-1]	; you guessed it
	OR	R0,CO2		; position to end of file
	$DOUUO	XCT,0,R0,REWXIT
	; no error, split after this

DOENTR:	JSP	CO1,DODEC.	; must reset block
DONTR:	MOVE	R0,[enter 0,ARGBLK]
	OR	R0,CO2		; set up enter
	$DOUUO	XCT,0,R0,REWER3,DOPHON
	; either it errors, or we're all set.

DOPHON:	HRLZI	R0,(out)	; must do phohy output for monitor
	OR	R0,CO2
	$DOUUO	XCT,0,R0,REWXIT,REWER3

REWXIT:	JSP	CO1,FLCHN.	; chain file block on
	HRLZI	R0,EOFBIT	; EOF for all output files
	TRNE	OPBITS,CONTRB	; open with control option?
	TLO	R0,EOLBIT	;   yes, set EOLN too
	MOVEM	R0,EOFWRD(FBL)
	HRLZI	R0,(out)	; I/O transfer instruction for output files
	OR	R0,CO2		; install channel number
	MOVEM	R0,IOINST(FBL)
	MOVEM	OPBITS,STATUS(FBL)
	MOVE	R0,[ascii/-----/]	; funny init val for linenr
	MOVEM	R0,LINENR(FBL)
REWDON:	MOVEI	R1,0(FBL)	; always return file block addr in R1
	$RESTOR	REGSAV,EXP1,PSA
	$UNMASK
	POPJ	TOP,0

REWER3:	HRRZ	CO1,1+ARGBLK	; get lookup/enter error code
	MOVEM	CO1,$EXTST(PDA)	;   and call it extended status.

REWER2:	MOVE	CO1,[release 0,0]	; must release the channel
	OR	CO1,CO2
	$DOUUO	XCT,0,CO1,REWER1
REWER1:	MOVE	R0,CHNUM(FBL)	; return channel to free pool
	PUSHJ	TOP,FRECN.
	JSP	CO1,FFRBF.	; return file block to pool

OPNER0:	JSP	CO1,IOFAK.	; return fake block
	JRST	REWDON		;   and split

REWTTY:	MOVEI	PR2,ISTTYO	; set search bit
	OR	OPBITS,PR2	; in case we have to make one
	JSP	CO1,FMTCH.	; match it
	JRST	DOTEXT		; not found, make one
;
; check options here!
;
	JRST	REWDON
	$END	IORWR
	prgend
	search	RTSYM
	search	IOSYM
	search	OPDEFS
	sall
	$MODULE	IOBIN

	$TEMP	BREEZE,1	; to permit PUSHJ for free
	$TEMP	LARGS,4		; where to explode args
	$TEMP	JCELL,1		; RA for nested routines
	$TEMP	ARGBLK,^o11	; argument block for monitor
	$TEMP	FBLOCK,5+MAXSFD	;   and for TENIO file parser
	$TEMP	REGSAV,^o13	; good old register save area
	$TEMP	TENSAV,^o16	;   one for TENIO parser too

	entry	OPNTP.,OPNBN.,DB$OPE,CLSTB.
	extern	FARGX.,FGTBF.,FLCHN.,CLOSA.,GTIFN.
	extern	FFRBF.,GETCN.,FRECN.,IOFAK.,GET.
	extern	TENIO.,FILSZ.,BUF.0,PASUO.,PPGRG.
	extern	DB.FBL

; OPNTP. -- open typed file.  The setup for the TENIO open mostly involves
;   the initializtion of the file block.  Notice that the component of
;   a file whose base type is an integral multiple of 128 words is used
;   as the "buffer" for that file, and in fact the transfers are done
;   with buffering forbidden.

OPNTP.:	JSP	R1,FARGX.	; explode the args
	TRO	OPBITS,TYPFIL	; describe the file
	MOVE	CLEN,LARGS	; load component length from arg list
	MOVEI	R1,TENBUF(CLEN)	; size of block plus component (no buff)
	TRNE	CLEN,^o177	; is comp. size even mult. of 128?
	JRST	OPNTNB		;   no, must add on one buffer
	JSP	CO1,FGTBF.	; otherwise just get block + component
	MOVEI	NAME,TENBUF(FBL)	; component addr is buffer addr
	HRLZI	R0,^o4000	; set bit to supress buffering
	JRST	OPNTYP		;   and hit common code

OPNTNB:	ADDI	R1,^o200	; not even -- add 128 words for buffer
	JSP	CO1,FGTBF.	; get the block
	MOVEI	NAME,TENBUF+^o200(FBL)	; load component addr
	SETZ	R0,0		; ok for buffering

OPNTYP:	MOVE	CLEN,LARGS	; common code -- reload comp size
	JSP	CO1,OPNCOM	; common code for binary/typed

	SETZM	0,CURSOR(FBL)	; was for input -- make it an open.
	SETZM	0,EOFWRD(FBL)	; set everything up now
	MOVEM	OPBITS,STATUS(FBL)
	ADJSP	TOP,$MAXTEMP	; save our stack
	PUSHJ	TOP,GET.	; load it up
	  ARG	0,0(FBL)
	ADJSP	TOP,-$MAXTEMP	; ok
	JRST	OPNZOM+1	; don't stomp bits if GET changed them??

; EXTERNAL PROCEDURE DB$OPEN ( VAR F: FILE OF <128-WORD ARRAY>;
;			       NAME: PACKED ARRAY [1..*] OF CHAR;
;			       OPTS: SET OF IO_OPTIONS );
;
;   is a special debugger entry point to open a typed file.  It works
;   the same as OPNTP., except that the file block is stored at a
;   special debugger static location (obtained from the debugger support
;   routine DB.FBL).

DB$OPE:	PUSHJ	TOP,OPNDB1	; fake a runtime open call
	Z	10,200		; input, 128-word buffer
	Z	4		; the string byte pointer
	Z	0(3)		; the string length word
	Z	5		; the option set word
	MOVEM	R1,0(2)		; save the file block address
	POPJ	TOP,

OPNDB1:	JSP	R1,FARGX.	; explode the (fake) args
	TRO	OPBITS,TYPFIL+DEBFBL	; typed file, debugger file block
	PUSHJ	TOP,DB.FBL	; get the file block address
	MOVE	FBL,R1
	MOVEI	NAME,TENBUF(FBL)	; component addr is buffer addr
	HRLZI	R0,^o4000	; suppress buffering
	JRST	OPNTYP		; now treat like ordinary typed file

; OPNBN. -- open binary file.  We share a bit of code with the typed
;   open case, but we always must call FILSZ. to determine EOF.  Note
;   that from the user's point of view, there is no OPEN for binary files,
;   only RESET, which 'gets the first component'.  Actually, this is
;   done to make READ work correctly.

OPNBN.:	JSP	R1,FARGX.	; get them args
	TRO	OPBITS,BINFIL	; we is a binary file!
	MOVEI	R1,TENBUF+^o200	; always need a buffer, never a component
	JSP	CO1,FGTBF.
	MOVEI	NAME,$NIL	; component pointer is nil
	MOVEI	CLEN,1		; for cursor computation, size is 1 word
	SETZ	R0,0		; ok
	JSP	CO1,OPNCOM	; hit common code

	MOVEI	R1,1		; it worked, get cursor initial value
	MOVEM	R1,CURSOR(FBL)
	ADJSP	TOP,$MAXTEMP	; call filsz. while saving temps
	PUSHJ	TOP,FILSZ.
	  ARG	0,0(FBL)
	ADJSP	TOP,-$MAXTEMP
	JRST	OPNZOM		; EOF is set, we're all done!

OPNDON:	SETZM	0,EOFWRD(FBL)	; some people don't set EOF
OPNZOM:	MOVEM	OPBITS,STATUS(FBL)	; must set status now
	MOVEI	R1,0(FBL)	; return file block addr in R1
	$RESTOR	REGSAV,EXP1,PSA
	$UNMASK
	POPJ	TOP,0

; OPNCOM -- common code for opening typed and binary files.  Just set up
;   the call to tenio's OPENF and do it.  We handle errors simply by
itting the IOFAK. helper in IOICM.

OPNCOM:	MOVEM	NAME,COMPTR(FBL)	; set component pointer
	MOVEM	CLEN,XRFWRD(FBL)	;   and component size
	MOVEM	CO1,JCELL	; ok, save our return addr
	HRR	R0,2+LARGS	; length of file name
	SETCM	CO1,OPBITS	; pick up complement of AC
	TRNN	CO1,OPNINP+OPNOUT	; to see if an update file
	TLO	OPBITS,PRESBI+RANDOM	;   if so, set default options
	TRNE	OPBITS,OPNINP	; is input allowed?
	TLO	R0,^o400000	;   yes, tell tenio so
	TRNE	OPBITS,OPNOUT	; how about output?
	TLO	R0,^o200000	;   ok
	TLNE	OPBITS,PRESBI	; preserve option?
	TLO	R0,^o100000	;   yes
	MOVEM	R0,IOINST(FBL)	; save it across GETCN.
	JSP	CO1,GTIFN.	; parse the file name
	JRST	IOBNFG		;   no good
	JRST	IOBNFG		;   TTY no good either
	DMOVE	R0,1+FBLOCK	; internal file name and extension
	DMOVEM	R0,FILENM(FBL)	; initialize it
	PUSHJ	TOP,GETCN.	; we know GETCN. uses no regs or temps
	MOVEM	R0,CHNUM(FBL)	; store it
	MOVE	R0,IOINST(FBL)	; fetch up TENIO word
	MOVEI	R1,TENBUF(FBL)	; buffer addr whether we use it or not
	MOVE	EXP1,1+LARGS	; the byte pointer
	TLO	R0,^o2000	; set bit for length
	ADJSP	TOP,$MAXTEMP	; protect our temps from TENIO
	OPENF	R0,CHNUM(FBL)	; channel number in memory
	JRST	IONFG1		; NFG
	ADJSP	TOP,-$MAXTEMP	;   it worked -- fix local stack
	MOVE	R1,3+FBLOCK	; get actual ppn
	MOVEM	R1,FILPPN(FBL)	; and save it
	TRNN	OPBITS,DEBFBL	; if not the debugger file block,
	JSP	CO1,FLCHN.	;   then chain it
	TRNE	OPBITS,OPNINP	; if input allowed
	JRST	@JCELL		; then let caller handle it
	MOVEI	R1,1		; else init cursor to one
	MOVEM	R1,CURSOR(FBL)	;   and set EOF via EXTENT(F)
	ADJSP	TOP,$MAXTEMP
	PUSHJ	TOP,FILSZ.	; get size
	  ARG	0,0(FBL)	;   of this file
	ADJSP	TOP,-$MAXTEMP
	TLNN	OPBITS,PRESBI	; is preserve option specified?
	JRST	OPNZOM		;   no, we're done
	ADDM	R1,CURSOR(FBL)	; else set cursor to extent+1
	MOVE	R1,[EOFBIT,,EOFCNT]	;   and set EOF by hand
	MOVEM	R1,EOFWRD(FBL)
	JRST	OPNZOM

IONFG1:	ADJSP	TOP,-$MAXTEMP	; fix the stack again

IOBNFG:	MOVEM	R0,$EXTST(PDA)	; store TENIO error return
	MOVE	R0,CHNUM(FBL)
	PUSHJ	TOP,FRECN.	; FRECN doesn't use regs or temps either
	TRNN	OPBITS,DEBFBL	; if not the debugger file block,
	JSP	CO1,FFRBF.	;   then get rid of it
	JSP	CO1,IOFAK.	; set up the fake return
	JRST	OPNZOM+1	;   and take it (leaving status)


; CLSTB. -- close typed and binary.  If this module is pulled, then the
;   call to CLSTB in the IOCLS module will come here, and we will do the
;   TENIO close (because we know tenio is around).  But if this module is
;   not pulled, then CLSTB. will be faked up at the end of IOFILE by
;   a call to the error routine (instead of an illegal LUUO).

CLSTB.:	CLOSEF	CO1,CHNUM(FBL)	; just do it
	JRST	0(R1)		;   error return
	JRST	1(R1)		; natural return


	$END	IOBIN
	prgend
	search	RTSYM
	search	IOSYM
	sall
	$MODULE	IOCLS
	$LOCAL	BREEZE,1	; for pushj
	$LOCAL	LARGS,4		; where to explode args
	$LOCAL	JCELL,1		; RA for nested routines
	$LOCAL	ARGBLK,^o11	; argument block for monitor
	$LOCAL	FBLOCK,5+MAXSFD	;   and for TENIO file parser
	$LOCAL	REGSAV,^o13	; good old register save area
	$LOCAL	TENSAV,^o16	;   one for TENIO parser too

	entry	CLOSE.,CLOSD.,CLOSA.
	extern	FFRBF.,FLUCH.,CLSTB.,BREAK.,FRECN.,IOERR.

; CLOSE., CLOSD., and CLOSA. -- the file closing routines.  Set up R1
;   zero if no delete, non-zero to delete.   Hit common code CLFILE with
;   a JSP PR1.  For CLOSA., walk the file block chain.

CLOSE.:	SETZ	R1,0		; don't delete
	JRST	CLSFIL

CLOSD.:	MOVEI	R1,1		; yes, delete (the scratch function)

CLSFIL:	HRL	R1,0(TOP)	; get addr of arg word
	AOS	0,0(TOP)	;   and tick return addr
	$MASK			; now take standard entry seq
	$FRAME
	$SAVE	REGSAV,EXP1,PSA
	SETZM	0,$EXTST(PDA)
	SETZM	0,$IOERR(PDA)
	MOVE	PSA,$IOICM(PDA)	; load up our data pointer
	HLRZ	FBL,R1		; get addr of arg word
	MOVEI	FBL,@0(FBL)	; get addr of file block
	HRRZI	CO1,0(R1)	; keep only right half of R1
	JSP	PR1,CLFILE	; get rid of it
	HRRZI	R0,DEBFBL+PHOFBL; if not a phony or debugger
	TDNN	R0,STATUS(FBL)	; static file block, then
	JSP	CO1,FLUCH.	; unchain single file
	JRST	CLSDON		; take "standard" return

CLOSA.:	$MASK			; our own entry seq
	$FRAME
	$SAVE	REGSAV,EXP1,PSA
	SETZM	0,$EXTST(PDA)
	SETZM	0,$IOERR(PDA)
	MOVE	PSA,$IOICM(PDA)	; load up data pointer
	MOVE	NLEN,0(PSA)	; get first block on list
	JUMPE	NLEN,CLSDON	; nothing to do
	SETZM	0,0(PSA)	; kill list then

CLALOO:	MOVEI	FBL,0(NLEN)	; load up block addr
	HRRZ	NLEN,FLINKS(FBL)	; remember where we are
	SETZ	CO1,0		; don't delete
	JSP	PR1,CLFILE	; hit common code
	JUMPN	NLEN,CLALOO	; go back if more to do

CLSDON:	$RESTOR	REGSAV,EXP1,PSA
	$UNMASK
	$UNFRAME
	POPJ	TOP,0

; CLFILE -- common code for closing files.  When we think we have a file
;   block pointer, either use TENIO to close a binary or typed file, or
;   do the jazz ourselves.  Then get rid of the block.  We have to unchain
;   it from the list.

CLFILE:;	CAML	FBL,$BFPNT(PDA)	; semi-test for legality
;	CAML	FBL,$STACK(PDA)	; within buffer space?
;	JRST	1(PR1)		;   no, skip return and forget it

	HRRZI	R0,PHOFBL	; no close for dummy file
	TDNE	R0,STATUS(FBL)
	JRST	0(PR1)
	SETZM	0,ERRORS(FBL)
	HRRZI	R0,TEXTFI	; see if it's a text file
	TDNE	R0,STATUS(FBL)	; if it's not
	JRST	CLTEN		;   then do a TENIO close
	HRRZI	R1,OPNOUT	; if output text file, must do break
	TDNN	R1,STATUS(FBL)	; how about it?
	JRST	CLFNOT		;   no, not output
	PUSHJ	TOP,BREAK.	; do the break (we did a frame already)
	ARG	0,0(FBL)	; this file, please
CLFNOT:	MOVE	R0,CHNUM(FBL)	; get channel number
	LSH	R0,^o27		; shift into AC field
	JUMPE	CO1,CLOSEF	; jump if we're not deleting file
	MOVE	R1,[rename 0,ARGBLK]	; else load up rename skeleton
	SETZM	0,ARGBLK	; with zero as first word of block
	OR	R1,R0		; install channel number
	$DOUUO	XCT,0,R1,CLNOGO,CLFREE
	; do it, no error, then release the channel and free block

CLNOGO:	LDERR	R1,EMPERR
	MOVEM	R1,$IOERR(PDA)
	JRST	CLFREE

CLOSEF:	HRLZI	R1,(CLOSE)	; load up close 0,0 instead of rename
	$DOUUO	XCT,0,R1,CLFREE	;   and execute it

CLFREE:	HRLZI	R1,(RELEAS)	; load up releas 0,0
	OR	R1,R0		; slap in channel number
	$DOUUO	XCT,0,R1,CLFBUF
	; do it, no error possible, then free the block

CLFBUF:	MOVE	R0,CHNUM(FBL)	; load up channel
	PUSHJ	TOP,FRECN.	; free channel, we already did a $frame

CLDONE:	HRRZI	R0,DEBFBL	; if not the debugger static
	TDNN	R0,STATUS(FBL)	; file block, then
	JSP	CO1,FFRBF.	; free it.
	JRST	0(PR1)		; go home

CLTEN:	JSP	R1,CLSTB.	; hit the alleged close routine
	JRST	CLTERR		; oops
	JRST	CLFBUF

CLTERR:	LDERR	R1,EMPERR
	MOVEM	R1,$IOERR(PDA)
	JRST	CLFBUF
	$LIT
	$END	IOCLS,0,CLOSA.
	prgend
	search	RTSYM
	search	IOSYM
	sall
	$MODULE	IOTXH

	$TEMP	BREEZE,1	; for pushj
	$TEMP	LARGS,4		; where to explode args
	$TEMP	JCELL,1		; RA for nested routines
	$TEMP	ARGBLK,^o11	; argument block for monitor
	$TEMP	FBLOCK,5+MAXSFD	;   and for TENIO file parser
	$TEMP	REGSAV,^o13	; good old register save area
	$TEMP	TENSAV,^o16	;   one for TENIO parser too

	entry	DODEC.,DOTXT.
	extern	GETCN.,FGTBF.,FMTCH.

; DODEC. -- set up DEC file name argument.  This routine prepares an
;   argument block for LOOKUP and ENTER.  SFD's are handled here.

DODEC.:	MOVE	PR2,1+FBLOCK	; file name
	MOVEM	PR2,2+ARGBLK
	MOVE	PR2,2+FBLOCK	; extension
	HLLZM	PR2,3+ARGBLK
	ANDI	PR2,777000	; isolate parsed prot. code
	HRLZI	PR2,0(PR2)	; put in high order nine bits
	MOVEM	PR2,4+ARGBLK	;   of third word.
	MOVE	PR2,3+FBLOCK	; pick up PPN parsed
	MOVEM	PR2,1+ARGBLK	; whatever
	MOVEI	PR2,4
	MOVEM	PR2,ARGBLK	; length of lookup block
	JRST	0(CO1)		; split

; DOTXT. -- common code for text files.  Get size of buffer needed for
;   device, allocate a block, get a channel, set up OPEN call and split.

DOTXT.:	MOVEI	R1,ARGBLK	; where the device block is
	SETZM	0,0(R1)		; ASCII mode
	MOVE	R0,FBLOCK	; pick up device name
	MOVEM	R0,1+ARGBLK	;   and install in block
	DEVSIZ	R1,0		; get it
	JRST	0(CO1)		;   no good
	MOVEM	CO1,ARGBLK	; must save our return addr
	MOVEI	CO2,0(R1)	; save device size
	MOVEI	R1,BUFFER+1(R1)	; load size of file block needed
	JSP	CO1,FGTBF.	; get the block
	ADDI	CO2,BUFFER(FBL)	; buffer addr + buffer size = comp. addr
	HRRZM	CO2,COMPTR(FBL)	;   install

	PUSHJ	TOP,GETCN.	; get a channel
	MOVEM	R0,CHNUM(FBL)	;   and install
	MOVE	CO2,R0		; copy channel num
	LSH	CO2,^o27	; shift into AC field
	MOVE	CO1,ARGBLK	; restore our return addr
	MOVE	R0,1+FBLOCK	; get the sixbit filename
	MOVEM	R0,FILENM(FBL)	;   and save it in the file block
	HLLZ	R0,2+FBLOCK	;   along with the extension.
	MOVEM	R0,FILEXT(FBL)
	SETZM	0,ARGBLK	; set up OPEN block -- no status bits
	MOVE	R0,FBLOCK	; device name
	MOVEM	R0,1+ARGBLK
	MOVE	R0,[open 0,ARGBLK]	; load skeleton instr
	OR	R0,CO2		; install channel number
	JRST	1(CO1)		; return to let caller set direction
	prgend
	search	RTSYM
	search	IOSYM
	sall
	$MODULE	IOICM
	$TEMP	BREEZE,1	; for pushj
	$TEMP	LARGS,4		; where to explode args
	$TEMP	JCELL,1		; RA for nested routines
	$TEMP	ARGBLK,^o11	; argument block for monitor
	$TEMP	FBLOCK,5+MAXSFD	;   and for TENIO file parser
	$TEMP	REGSAV,^o13	; good old register save area
	$TEMP	TENSAV,^o16	;   one for TENIO parser too

	entry	FARGX.,FGTBF.,FFRBF.,FLCHN.,FLUCH.,GTIFN.
	entry	IOFAK.,FMTCH.,P.FID.
	extern	IOERR.		; for tenio
	extern	PPGRG.,DECOD.
	$STATIC	FBLIST,1
	$STATIC	INPHON,STATUS+1
	$STATIC	OUTPHO,STATUS+1

; P.FID. -- decently callable hook into TENIO's file name parser.  After
;   fooling around with the arguments (EXP1 has addr of fn string, EXP2
;   has addr of pseudo-LOOKUP block to fill), just hit it.  Do NOT call
;   this guy from within the I/O system -- for various utility hacks
;   only.  PS -- we cream several words on top of TOP.

P.FID.:	$SAVE	REGSAV,EXP1,PDA
	MOVE	R1,0(EXP1)	; store str length in arg block
	MOVEM	R1,2+LARGS	;   for GTIFN.
	MOVEI	R1,1(EXP1)	; compose byte pointer for 1st char
	HRLI	R1,^o440700
	MOVEM	R1,1+LARGS	;   and store it
	JSP	CO1,GTIFN.	; do it now
	JRST	PRFNFG		; no good parse
	CAI	0,0		; no-op if TTY
	HRLI	R1,FBLOCK	; BLT the parsed block into caller's
	HRRI	R1,0(EXP2)	;   area
	BLT	R1,5+MAXSFD(EXP2)
	AOS	0,0(TOP)	;   and take a skip return

PRFNFG:	$RESTOR	REGSAV,EXP1,PDA
	POPJ	TOP,0

; GTIFN. -- parse file name (get internal form).  Make a call to TENIO's
;   parser DECOD., after setting up all its arguments.

GTIFN.:	$SAVE	TENSAV,EXP1,BASIS	; save every register
	MOVE	3,TOP		; remember TOP in 3 (not smashed)
	SETZ	2,0		; remember skip return in 2
	MOVE	R0,2+LARGS	; load length of string
	MOVEI	R1,FBLOCK	; where to put internal form
	MOVE	7,1+LARGS	; load byte pointer to name
	JSP	14,DECOD.	; do it
	AOJ	2,0		; make non-zero, incorrect return
	MOVE	TOP,3		; restore top
	MOVEI	R1,0(2)		; put code where we can see it after
	$RESTOR	TENSAV,EXP1,BASIS
	JUMPN	R1,0(CO1)	; take error return
	HRLZI	R0,'TTY'	; check for TTY
	CAMN	R0,FBLOCK	; well?
	JRST	1(CO1)		; yes
	JRST	2(CO1)		; no

; FGTBF. -- file buffer allocation routine.  Assume size block desired
;;   in R1, we return proper block in FBL or die trying.  If we need
;;   to extend the area, fix up the stack pointer via FIXSP, which is
;;   also called by FFRBF.  The allocation algorithm is a best-fit with
;;   a size word before each block, positive if free, negative if alloc'd,
;;   with the absolute value being the size of the block including the
;;   control word.
;
;FGTBF.:	ADDI	R1,1		; allocate size plus control word
;	HRRZM	CO1,JCELL	; save return address in memory
;	MOVE	CO1,$STACK(PDA)	; compute our high bound
;	SUBI	CO1,BUFDGE+1	;   which is fudge words off heap
;	HRLOI	R0,377777	; init current size to largest int
;	SETZ	FBL,0		; we haven't found one yet
;	MOVE	NAME,$BFPNT(PDA)	; pick up current top of buffers
;
;	CAIL	NAME,0(CO1)	; are we over the edge already?
;	JRST	GBXTND		; guess so, must extend area
;
;GBLOOP:	SKIPG	NLEN,0(NAME)	; pick up size word of block
;	JRST	GBNEXT		; allocated -- forget it
;	CAIL	NLEN,0(R1)	; is block big enuf for us?
;	CAIG	R0,0(NLEN)	; is it smaller than our current best?
;	JRST	GBNEXT		; no, try next block
;
;	MOVEI	FBL,0(NAME)	; remember this guy
;	MOVEI	R0,0(NLEN)	; size (above) and address too
;
;GBNEXT:	MOVMS	0,NLEN		; add absolute value
;	ADDI	NAME,0(NLEN)	;   to addr to get next block's addr
;	CAIGE	NAME,0(CO1)	; are we over the edge?
;	JRST	GBLOOP		; not yet
;
;;
;;  at this point, if we found a candidate, FBL has its address and R0
;;     its size.  We may have to split it, or extend if none found.
;;
;
;GBDONE:	JUMPE	FBL,GBXTND	; nothing, go extend area
;	SUBI	R0,0(R1)	; compute residue size
;	CAILE	R0,SMALL	; too small to split
;	JRST	GBSPLT		;   no, gotta split it
;
;GBGOT:	MOVNS	0,0(FBL)	; set size word negative (for alloc'd)
;GBGOT1:	ADDI	FBL,1		; return addr of control word + 1
;GBZERO:	HRLZI	R0,0(FBL)	; set up BLT reg
;	HRRI	R0,1(FBL)	;   to zero out block
;	SETZM	0,0(FBL)	; clear first word
;	MOVN	R1,-1(FBL)	; get positive size of block
;	ADDI	R1,0(FBL)	; add to addr to get last addr
;	BLT	R0,-2(R1)	;   minus two to zero out
;	JRST	@JCELL		;   and go home with FBL
;
;GBSPLT:	MOVE	NLEN,0(FBL)	; pick up size of big block
;	MOVNM	R1,0(FBL)	; install alloc'd block size there
;	MOVEI	NAME,0(FBL)	; copy addr
;	ADDI	NAME,0(R1)	;   to get addr of remnant
;	MOVEM	R0,0(NAME)	; drop remnant size
;	JRST	GBGOT1		; return, but don't negate size word!
;
;GBXTND:	MOVE	NAME,$BFPNT(PDA)	; get top of buffer area
;	SUBI	NAME,0(R1)	; subtract size desired for new top
;	MOVEM	NAME,$BFPNT(PDA)	;   and install new top
;	CAIG	NAME,BUFDGE(TOP)	; can we do it (enough room)?
;	JRST	GBNOGO		; no, go barf
;	MOVNM	R1,0(NAME)	; install neg of desired size
;	MOVEI	FBL,1(NAME)	; set up return register
;	JSP	CO1,FIXSP	; fix up the stack
;	JRST	GBZERO		;   zero block and split
;
;NOFIL.:	$RTERR	FILMSG
;FILMSG:	asciz;
;?	No buffer space. Increase S parameter and try again;
;GBNOGO:	$ERROR	NOFIL.

; FFRBF. -- free buffer allocated by FGTBF.  Give buffer address in
;;   FBL, return address via JSP CO1.   I use NLEN, NAME, R1,
;;   CO1, and JCELL.  First coalesce all free blocks in area.  Then,
;;   if the first block is free, return the stolen stack space to the
;;   stack by calling FIXSP with a negative correction factor.
;
;FFRBF.:	MOVMS	0,-1(FBL)	; make size word positive
;	HRRZM	CO1,JCELL	; save return addr to get a register
;	MOVE	NAME,$BFPNT(PDA)	; get current lowest in area
;	MOVE	CO1,$STACK(PDA)	; compute end of area
;	SUBI	CO1,BUFDGE+1	; fudge factor off bottom of heap
;
;FRLOOP:	SKIPG	R1,0(NAME)	; is size word positive?
;	JRST	FRNEXT		; no
;	MOVEI	NLEN,0(NAME)	; copy addr of block
;	ADDI	NLEN,0(R1)	;   to compute addr of next
;	CAIL	NLEN,0(CO1)	; does that take us over the edge?
;	JRST	FRDONE		; yes, we're done
;	SKIPG	R1,0(NLEN)	; is next block free too?
;	JRST	FRNEXT		;   no, sorry
;	ADDM	R1,0(NAME)	; yes, fix size of current to incl. next
;	JRST	FRLOOP		;   and continue this game
;
;FRNEXT:	MOVM	R1,0(NAME)	; pick up size to next block
;	ADDI	NAME,0(R1)	; compute next block's addr
;	CAIGE	NAME,0(CO1)	; does that put us over edge?
;	JRST	FRLOOP		;   no, keep checking
;
;FRDONE:	MOVE	NAME,$BFPNT(PDA)	; get first block's addr again
;	SKIPG	R1,0(NAME)	; is it free?
;	JRST	@JCELL		;   no, get out
;	ADDI	NAME,0(R1)	; yes, compute new first block addr
;	MOVEM	NAME,$BFPNT(PDA)	;   and store it
;	MOVNS	0,R1		; get negative correction factor
;	JSP	CO1,FIXSP	;   for dynamic chain
;	JRST	@JCELL		; and we're done.

; FIXSP -- helper for buffer allocation and deallocation routines.  Call
;;   me with a JSP CO1, with R1 containing the adjustment size.   I use
;;   NAME and NLEN, and stomp on TOP a little bit, and chase up the
;;   dynamic chain fixing stored pointers.
;
;FIXSP:	HLRE	NLEN,TOP	; get PDL count (negative)
;	ADD	NLEN,R1		; adjust (adjustment may be negative)
;	HRLI	TOP,0(NLEN)	;   and restore
;	MOVE	NAME,BASIS	; chase down to mainline
;
;FIXSP1:	TLNN	NAME,777777	; are we down to main frame?
;	JRST	0(CO1)		;   yes, go home
;	HLRE	NLEN,2(NAME)	; pick up PDL count of stored ptr
;	ADD	NLEN,R1	; fix up
;	HRLM	NLEN,2(NAME)	;   and reinstall
;	HLRZ	NAME,1(NAME)	; get next on chain (used to be MOVE)
;	JRST	FIXSP1		;   and fix next one

; FGTBF. -- the real new file block allocator. Get it off the heap.

FGTBF.:	HRRZM	CO1,JCELL	; save return address
	ADJSP	TOP,$MAXTEMP	; pad our temps
	PUSH	TOP,CO2		; save damn register
	MOVE	CO2,R1		; size needed in EXP1
	PUSH	TOP,PSA
	PUSHJ	TOP,NEW.##	; get it
	ARG	FBL,0(CO2)	; get it and put it
	POP	TOP,PSA
	POP	TOP,CO2		; restore it
	ADJSP	TOP,-$MAXTEMP	; fix stack
	JRST	@JCELL		; return to caller
;
FFRBF.:	HRRZM	CO1,JCELL
	ADJSP	TOP,$MAXTEMP
	PUSH	TOP,PSA		; best save it
	PUSHJ	TOP,DSPOS.##
	ARG	0,0(FBL)
	POP	TOP,PSA
	ADJSP	TOP,-$MAXTEMP
	JRST	@JCELL

; IOFINI -- initialization routine.   Nothing to it.

IOFINI:	SETZM	0,FBLIST	; start out with empty file list
	HRLI	R1,FBLIST	; zero out phony file blocks
	HRRI	R1,INPHON
	BLT	R1,EOFWRD+OUTPHO
	HRLZI	R1,EOFBIT+EOLBIT	; input phony gets both
	HRRI	R1,EOFCNT
	MOVEM	R1,EOFWRD+INPHON
	LDERR	R1,OPNERR	; the error code in phony FBs
	MOVEM	R1,ERRORS+OUTPHO
	MOVEM	R1,ERRORS+INPHON
	HRRZI	R1,PHOFBL	; mark file blocks as phony
	MOVEM	R1,STATUS+OUTPHO
	MOVEM	R1,STATUS+INPHON
	MOVE	R1,$STACK(PDA)	; must initialize start of buffer area
	SUBI	R1,BUFDGE+1	; fudge words before good stuff
	MOVEM	R1,$BFPNT(PDA)
	POPJ	TOP,0

; FLCHN. -- chain on file block.  This is here because the static storage
;   cell is here also.

FLCHN.:	SKIPE	R1,FBLIST	; pick up current first
	HRLM	FBL,FLINKS(R1)	; make old first point back to us
	HRRZM	R1,FLINKS(FBL)	; make new first point only to old one
	MOVEM	FBL,FBLIST	; new first
	JRST	0(CO1)		; ta-ta


; FLUCH. -- unchain file block.  This is here for the same reason.

FLUCH.:	HRRZ	CO2,FLINKS(FBL)	; get forward block addr
	HLRZ	R1,FLINKS(FBL)	;   and backwards
	SKIPE	0,CO2		; do we have a forward guy?
	HRLM	R1,FLINKS(CO2)	;   yes, point him to our trailer
	JUMPE	R1,FL1ST	; no trailer, we were first
	HRRM	CO2,FLINKS(R1)	;   else point trailer to forwards
	JRST	0(CO1)		; leave

FL1ST:	HRRZM	CO2,FBLIST	; new first one
	JRST	0(CO1)

; FMTCH. -- find a block matching bits in PR2.  To find TTY block if any.

FMTCH.:	MOVE	FBL,FBLIST	; get first to check
	JUMPE	FBL,0(CO1)	;   oops, nothing there!

FMTCHL:	TDNE	PR2,STATUS(FBL)	; do you match bits?
	JRST	1(CO1)		;   yes, return it
	HRRZ	FBL,FLINKS(FBL)	;   no, get next in chain.
	JUMPN	FBL,FMTCHL	;   if any
	JRST	0(CO1)		;     else go home in disgrace

; FARGX. -- explode file arguments.  The calling sequence to all file
;   opening routines is the same (essentially).  This helper explodes
;   the arguments, saves registers, and masks.

FARGX.:	LDB	R0,[point 4,@0(TOP),12]
	LSH	R0,2		; load AC bits, make room for 2 more
	MOVEM	R0,3+LARGS	;   and store them
	MOVEM	R1,JCELL	; store our return addr
	MOVEI	R1,4		; explode 4 args
	ADDB	R1,0(TOP)
	MOVEI	R0,@-4(R1)	; get component length
	MOVEM	R0,LARGS
	MOVEI	R0,@-2(R1)	; get length of file name
	MOVEM	R0,2+LARGS
	MOVE	R0,@-3(R1)	; get byte pointer
	MOVEM	R0,1+LARGS	; store for now
	LDB	R0,[point 4,0,17]	; fetch index bits from addr spec
	JUMPE	R0,FD		; no register specified
	MOVEI	R0,@1+LARGS	; evaluate EA of byte pointer
	HRRM	R0,1+LARGS	; is new EA of byte pointer
	HRLZI	R0,^o17		; finally, blot index field of pointer
	ANDCAM	R0,1+LARGS	; like so

FD:	MOVEI	R1,@-1(R1)	; get addr of option set
	HLLZ	R0,0(R1)	;   and the set
	HLLM	R0,3+LARGS	;   and store with the AC bits
	$SAVE	REGSAV,EXP1,PSA
	$MASK
	SETZM	0,$EXTST(PDA)	; clear global error cells
	SETZM	0,$IOERR(PDA)
	MOVE	OPBITS,3+LARGS	; keep option bits in register
	MOVE	PSA,$IOICM(PDA)	; load data area pointer
	TRNN	OPBITS,4	; was internal filename specified?
	JRST	@JCELL		;   no, split
	MOVE	R1,[ascii '.PIO ']	; set down the enforced extension
	MOVEM	R1,6+ARGBLK	; use ARGBLK, it's safe until after parsing
	HRRZ	R1,1+LARGS	; get byte pointer EA
	DMOVE	R0,1(R1)	; thru it to get first two words
	DMOVEM	R0,7+ARGBLK	;   and store them after ext.
	MOVEI	R1,6-1+ARGBLK	; the address of the ponied file name
	HRRM	R1,1+LARGS	; word before, stuff into the byte pointer
	MOVE	R1,2+LARGS	; get length sent down
	ADDI	R1,5		;   plus five for ext
	CAIL	R1,^o14		; did we blow it?
	MOVEI	R1,^o13		;   yes, trunc file name to 6 chars
	MOVEM	R1,2+LARGS	; replace length
	JRST	@JCELL		; go home now

; IOFAK. -- error return.  Load up the right block and split.

IOFAK.:	LDERR	FBL,OPNERR
	MOVEM	FBL,$IOERR(PDA)	; set global cell same as local
	MOVEI	FBL,OUTPHO
	TRNE	OPBITS,OPNINP	; is it input?
	MOVEI	FBL,INPHON	; yes
	JRST	0(CO1)		; split
	$END	IOICM,IOFINI
	prgend
	search	RTSYM
	search	IOSYM
	search	OPDEFS
	sall
	$MODULE	IOBFAK

	entry	CLSTB.
	extern	IOERR.

; CLSTB. -- close typed and binary.  If the IOBIN module was not pulled via
;   OPNTP. or OPNBN., then it is an error to try to close a TENIO file
;   with CLSTB (as none could have been opened through pascal).  So we
;   take an error dive instead of bombing out on an illegal LUUO.

CLSTB.:	LDERR	R1,INTERR
	POP	TOP,R0
	JRST	IOERR.

	$END	IOBFAK
	prgend
	search	RTSYM
	$MODULE	DBFBFK

	entry	DB.FBL

; DB.FBL -- debugger file block address.  If the debugger hasn't been
;   loaded, then there is no debugger static file block, and no one
;   ought to be calling DB$OPEN.  Therefore, if DB$OPEN is called,
;   it will hit this routine when it tries to get the debugger static
;   file block address, and we can put it out of its misery.

DB.FBL:	$FTERROR ERRMSG

ERRMSG:	ASCIZ	/
?	Call to DB$OPEN in non-debug program/

	PRGEND
	search	RTSYM
	search	IOSYM
	$MODULE	IOFNAM

	entry	FNAME.

	$LOCAL	REGSAV,INDEX1-EXP3+1
	$LOCAL	DEVICE,1	; looks like a tenio block
	$LOCAL	FLNAME,1
	$LOCAL	FEXT,1
	$LOCAL	PPN,1
	$LOCAL	SFDS,MAXSFD
	$LOCAL	STOP,1

; FNAME. -- return canonical file name in string form.  TENIO doesn't
;   mind if we do a PATH. on one of its files, so treat all files the
;   same.  Set up a TENIO-ish internal file block and convert to canon-
;   ical string form.

FNAME.:	$FRAME
	$SAVE	REGSAV,EXP3,INDEX1

	HRRZI	EXP3,1(EXP2)	; compose byte pointer to target string
	HRLI	EXP3,440700
	MOVEI	EXP4,0
	MOVE	R1,CHNUM(EXP1)	; try DEVNAM in case it's a device
	DEVNAM	R1,0		; ok?
	JRST	FNERR		;   no good, hell with it.
	JSP	EXP5,DONAME	; ok, write out the name
	MOVEI	R0,":"		;   with a colon
	JSP	EXP5,DOCHR

	SKIPN	R1,FILENM(EXP1)	; check if just device
	JRST	DVDONE		; must be
	JSP	EXP5,DONAME

	MOVEI	R0,"."		; now the extension
	JSP	EXP5,DOCHR
	HLLZ	R1,FILEXT(EXP1)
	JSP	EXP5,DONAME

	MOVEI	R0,"["		; now the PPN
	JSP	EXP5,DOCHR
	HLRZ	R1,FILPPN(EXP1)
	JSP	EXP5,DOOCT
	MOVEI	R0,","
	JSP	EXP5,DOCHR
	HRRZ	R1,FILPPN(EXP1)
	JSP	EXP5,DOOCT

SFDONE:	MOVEI	R0,"]"		; close the path list
	JSP	EXP5,DOCHR

DVDONE:	MOVEM	EXP4,0(EXP2)	; install length of path string
FNDONE:	$RESTOR	REGSAV,EXP3,INDEX1
	$UNFRAME
	POPJ	TOP,0

FNERR:	SETZM	0(EXP2)		; return null string on errors
	JRST	FNDONE

; DONAME, DOOCT and DOCHR -- support routines for FNAME.  Really simple
;   thingies to write out a sixbit word in chars, stopping at the
;   first null char, to write out an octal number starting at the first
;   non-zero digit, and to write out a single ascii char.

DONAME:	MOVE	INDEX1,[point 6,R1]
DONLOO:	ILDB	R0,INDEX1	; get the char
	JUMPE	R0,0(EXP5)	;   zero, we're done
	ife	R1&1,<TRNE INDEX1,1>	; see if byte pointer has
	ifn	R1&1,<TRNN INDEX1,1>	;   gone on to next word
	JRST	0(EXP5)		; yes, again we're done
	ADDI	R0,^o40		; ok, convert sixbit to sevenbit
	IDPB	R0,EXP3		; dump it
	AOJA	EXP4,DONLOO	;   and get another


DOCHR:	IDPB	R0,EXP3		; dump it
	AOJA	EXP4,0(EXP5)	;   and split


DOOCT:	MOVE	INDEX1,[point 3,R1]	; pointer to get octal digits
	JUMPE	R1,0(EXP5)	; if zero, split now
DOOLOO:	ILDB	R0,INDEX1	; get a char
	JUMPE	R0,DOOLOO	; zero, get another
	JRST	DOGOT1		; jump into loop below

DOCLOO:	ILDB	R0,INDEX1	; get the char
	ife	R1&1,<TRNE INDEX1,1>	; skip if byte pointer not
	ifn	R1&1,<TRNN INDEX1,1>	;   incremented to next reg
	JRST	0(EXP5)		; if it is, we're done
DOGOT1:	ADDI	R0,"0"		; convert into digit
	IDPB	R0,EXP3		; deposit it
	AOJA	EXP4,DOCLOO	;   increment count and get another
	end
    K \b