SUBTTL R CLEMENTS /CHW/TNH/PFC/RCC/CMF/SML/JMF/TCK/JNG/JMT/PMW/MTH/KPY/ISM/BBE/WCL/BCM/GAT 21-Feb-86
VSYSTAT==477
VEDIT==337
VMINOR==0
VWHO==0


;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1968,1979,1980,1982,1984,1986.
;ALL RIGHTS RESERVED.
;
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.

	.TEXT	"REL:HELPER.REL/SEGMENT:LOW"

DEFINE	.TITL(VMAG,VMIN)<
TITLE	SYSTAT -- PRINT SYSTEM STASTICS -- V VMAG(VMIN)
>
	.TITL	(\VSYSTAT,\VEDIT)
;EDIT HISTORY

;EDIT LEVEL 27  TO LEVEL 30

;EDIT #1
;SY P PRINTED WRONG NUMBER OF FREE BLOCKS 

;EDIT LEVEL 30 TO LEVEL 31

;EDIT #2

;THE NUMBER OF EXTENDED READ AND WRITES IS WRONG FOR A MONITOR
;WITH FTVM OFF

;EDIT #3

;ONLY PRINT FANCY RESPONSE DATA WHEN FTRSP IS ON

;EDIT #4

;NO NEW ACCESSSES ALLOWED IS PRINTED ON VM MONITORS
;FOR RANDOM FILE STRUCTURES WHENEVER SYS IS TYPED,SYS F IS OAKY

;EDIT #5

;SPOOLED DEVICES SHOULD BE LISTED ON THE OPERATOR SYSTAT LIST
;FLAGGED WITH A ' SIGN .THIS DID NOT HAPPEN AS SPOOLED DEVICES
;DO NOT HAVE DVDSK ON IN DEVMOD DDB ENTRY.SO USE THE PROPER FLAG
;IN DEVSPL DDB ENTRY

;EDIT #6

;REPORT OF SWAPPING SPACE LOST IS TOO HIGH 3 MORE BITS HAVE TO BE
;ZEROED IN DATA PRINTED

;EDIT #7

;ONE MORE OCCURRENCE OF A WRONG UDB INDEX FOR VM SYSTEMS

;EDIT #8

;WARN USERS THAT NO OPERATOR IS ON DUTY (SPR 10,12,962)

;EDIT #9

;ADD P OR K TO AVERAGE SIZE PRINT OUT

;EDIT 10

;IF CONTROL C INTERRUPT THEN DO NOT TYPE HACK TABLE ENTRY BUT EXIT

;EDIT 11

;LOGICAL NAMES OF JOB ONER ARE NOT DISPLAYED

;EDIT 12

;SYS LEF PRODUCES AN EMPTY FILE

;EDIT 13

;SYS ...... MAKES SYSTAT GROW

;EDIT 14

;THE RIGHT TO WRITE SYSTAT.TXT IS NOT CHECKED

;EDIT 15

;/X BROKE DUE TO EDIT 13 RESET UUO!

;EDIT 16

;SPOOLING A CONTINUOUS SYSTAT TEXT RESULTS IN I/O TO AN UNASSIGNED CHANNEL
;DUE TO EDIT 12

;EDIT 17

;REENTER OPTION WAS BROKEN

;EDIT 18

;SYS XL FILE SPEC CAUSED THE MESSAGE CAN'T GET AT THAT FILE
;MAKE SYSTAT MORE CLEVER.

;EDIT 19

;SYSTAT CAN EAT TYPE AHAED 

;EDIT 20

;LOW SEGMENT SIZE OF PROGRAMS WITH SHARABLE
;HISEG IS WRONG

;EDIT 143

;MAKE EDIT NUMBER EQUAL REVISION HISTORY.
;USE C AS A UNIVERSAL.

;EDIT 144

;RESTRICT SYSTAT L WHEN NOT-LOGGED-IN TO LOCAL TTYS OR SUBJOBS OF
;PROJECT 1. [10-13028]

;EDIT 145

;MAKE SYSTAT EASIER TO ^C, AND ALLOW CONTINUES IF LOGGED IN.

;EDIT 146

;CLEAR .UXTRM OFFSET FROM A GETLCH TO AVOID "SY ." PROBS. [14434]

;EDIT 147

;SHOW BUSY DEVICES WHEN WILD PPN REQUESTED [10-14317]

;EDIT 150

;ALLOW COMMENTS ON THE SYSTAT COMMAND LINE [10-14543]

;EDIT 151

;FIX "SYSTAT OCL", BROKEN BY EDIT 145

;EDIT 152

;STARTING WITH LOAD 722 KNOW OF NEW NUMTAB FORMAT

;EDIT 153

;BELIEVE IN NEW DDB ENTRY DEVJOB FOR 722

;EDIT 154

;UPDATE DEVFIL PART OF DDB'S TO USE LENGTH OF SHORT DDB'S

;EDIT 155

;USE TRMNO. UUO FOR NON TOPS10 MONITORS,WHICH KNOW THE TRMNO.

;EDIT 156

;THE SEQUENCE : .ASS DSK LPT   SYS /L/X
;GIVES AN ILLEGAL UUO

;EDIT 157

;REPLACE ALL DDB OFFSETS BY A SYMBOL DV.XXX TO PREVENT DUPLICATING
;OF UUO NAMES

;EDIT 160

;NEVER USE A ZERO UPTIME TO COMPUTE PERCENTAGES

;EDIT 161

;DISK ERRORS ARE REPOTED WRONG FOR A CRASH FILE

;EDIT 162

;PRINT SYSTEM HEADER ASAP ON A /X AS THIS SAVES CONSIDERABLE
;TIME IF ONE LOOKS AT THE WRONG CRASH

;EDIT 163

;SUBTRACT THE MONITOR HIGH SEGSIZE FROM THE CORE SIZE

;EDIT 164

;ADD SUPPORT FOR READING EXE CRASHES

;;EDIT 166	(16236)

;;ADD SWAPPING SPACE LOST MESSAGE
;;AREAS AFFECTED: MUS3

;EDIT 167  (16461)

;INCREASE REMOTE STATION LOOP RESTRICTION

;edit 170  (15261)

;typing continue after running systat gives a logged in user the
;message "kjob"

;edit 171

;thisis uses the variable date to print the date this varible is 
;not initialized on a sys x command

;edit 172

;the vlalue of unixra was changed in 602 causing extended writes
;and reads column to be wrong

;edit 173

;ignore all structures and packs with zero mount count pack not mounted
;pack off line and zero reads and writes

;EDIT 174

;MAKE SYSTAT X GIVE ERROR MESSAGE FOR NON-DISK DEVICES

;EDIT 175

;USE UNIVERSAL JOBDAT FILE

;EDIT 176

;REMOVE SYSTEM 124 FROM IN-HOUSE LIST; IT'S BEEN SOLD.

;EDIT 177

;MAKE /X GIVE PROPER TIME FOR 50HZ COUNTRIES

;EDIT 200

;MAKE CONTINUOUS SYSTATING REMEMBER THE ARGUMENTS GIVEN IN
;THE COMMAND. THE COMMAND LINE IS NOW READ INTO A BUFFER SO
;THE COMMAND CAN BE REREAD ON EACH PASS THROUGH.

;EDIT 201

;TIME CALCULATION @ERRLY1 USES DECIMAL 60 EXPLICITLY RATHER
;THAN TCKSEC, THUS 50 HZ. COUNTRIES GET BAD TIMES !

;EDIT 202

;SYSTAT E TRIES TO DETERMINE STOPCD TYPE BY FOLLOWING ADDRESS
;IN %SYSPC. UNFORTUNATELY THIS PRODUCES AN ?ILL MEM REF IF
;SPYING SINCE %SYSPC POINTS INTO HIGH SEGMENT OF MONITOR.
;MAKE IT DO A PEEK INSTEAD FOR THE RUNNING MONITOR AND ONLY
;PRINT STOPCD NAME FOR A CRASHED MONITOR.

;EDIT 203

;THIS EDIT CHANGES THE ROUTINE GETFIL TO USE FILOP. TO OPEN
;THE CRASH FILE ON A .SYS X SO THAT PRIVILEGE CHECKING FOR
;FILE ACCESS IS DONE CORRECTLY. PREVIOUSLY A CHKACC WAS PERFORMED
;WHICH CORRECTLY CHECKED THE FILES PROTECTION, HOWEVER IT DOESN'T
;CHECK THE UFD PROTECTION. IN FACT, THERE IS NO CHKACC FUNCTION TO
;SEE IF ACCESS TO FILES IN A UFD IS ALLOWED. IF THE FILOP. IS NOT
;IMPLEMENTED, THE FORMER METHOD WILL BE USED, AND ONLY THE FILE
;PROTECTION WILL BE CHECKED BEFORE ALLOWING ACCESS.

;EDIT 204

;MAKE SYSTAT REPORT "TIMESHARING IS OVER" WHEN IT CHECKS
;KSYS AS IT DOES WHEN IT REPORTS "TIMESHARING WILL END IN ...".

;EDIT 205

;WHEN DOING .SYS F  DON'T PRINT BLANK STRUCTURES.

;EDIT 206

;BUSY DEVICE INFORMATION ON SYSTATS OF CRASHED MONITORS IS
;INCORRECT IF THE DDB FORMAT OF THE CRASHED MONITOR IS DIFFERENT
;THAN THAT OF THE RUNNING MONITOR.
;ON SYSTATS OF CRASHED MONITORS, THE MONITOR VERSION SHOULD BE GOTTEN
;FROM THE CRASH FILE. ITS NOW GOTTEN FROM THE RUNNING MONITOR BECAUSE
;IT IS DETERMINED AT INITIALIZATION TIME BEFORE WE KNOW WHETHER
;THIS IS A .SYS X OR A SYSTAT OF THE RUNNING MONITOR.  ALSO,
;FOR THE SAME REASON WHEN DETERMINING THE DISK DDB SIZE AND
;BUILDING THE DDB POINTERS, THE VALUE IS GOTTEN FROM THE RUNNING
;MONITOR RATHER THAN FROM THE CRASH FILE.
;AREA AFFECTED: DSKJN1

;EDIT 207

;EDIT #200 BROKE THE REENTER FEATURE OF SYSTAT SUCH THAT IF
;YOU TYPED REENTER, SYSTAT WOULD CONTINUALLY LOOP. THIS IS
;BECAUSE THE INPUT BUFFER IS NEVER CLEARED AFTER READING
;COMMAND INTO BUFFER.
;AREA AFFECTED: RDCMND

;EDIT 210
;IF PAGED OUTPUT IS REQUESTED, YOU TYPE ^C AS RESPONSE TO THE
;PROMPT, AND YOU'RE NOT LOGGED IN, THE "KJOB" MESSAGE IS NOT TYPED.
;AREA AFFECTED: HICCUP

;EDIT 211
;ADD STATISTICS REPORT FOR DUAL PORTED RPO4'S

;EDIT 212
;FIX SHORT DDB PROBLEM  [.DVDAT, DEVLP]



;EDIT 213
;FIX TYPE-AHEAD PROBLEM CAUSED BY EDIT 207'S FIX TO EDIT 200


;EDIT 214  /PMW  10 MAR 77
;IN RDCMND
;TEST FOR FULL INPUT BUFFER

;EDIT 215  /PMW  10 MAR 77
;AT GETFIL+1
;MODIFY EDIT 203 <USE FILOP. FOR CRASH.EXE> TO USE PRIVILEGED FILOP.
;SO [1,2] AND JACCT JOBS  GET FULL ACCESS.

;EDIT 216
;SYS C G <JOB NUMBER> ZEROED OUT CPU TIME FOR THE JOB GIVING
;THE WRONG CPU TIME FOR THE JOB AND INCREASING THE IDLE TIME
;REPORTED BY THE SYSTEM.
;AREA AFFECTED: TSTATE
;EDIT 217	/PMW  5 APR 77
;MODIFY EDIT 215 SUCH THAT ONLY 1,2 JOBS GET ACCESS TO CRASH.EXE

;EDIT 220	/PMW  5 APR 77
;MODIFY EDIT 144 SUCH THAT NOT-LOGGED-IN JOBS CAN'T GET LPT
;	(UNLESS 1,2 SUBJOBS)

;EDIT 221	MTH  21-JUN-77
;SYS C <ARGS> WAS DOING INCREMENTAL SYSTATS ON THE REPETITIONS
;OF THE COMMAND LINE. FIX IT TO ACT LIKE ORIGINAL START UP, EXCEPT
;THAT COMMAND LINE HAS ALREADY BEEN SAVED AWAY.
;AREAS AFFECTED: SNOOZ1, CMDBUF

;EDIT 222	MTH 21-JUN-77
;REPLACE EDIT 217 FIX BECAUSE "SYSTAT O" SETS FL.GOD AND ANY
;RANDOM USER WHO USED THIS WOULD GET THE FILOP. PRIV BIT.
;AREA AFFECTED: GETFIL

;EDIT 223	MTH 27-JUN-77
;CONTINUOUS STUFF IS DONE INCORRECTLY FOR PARTICULAR ARGUMENTS
;COMPUTE UPTIME IMMEDIATELY AFTER COMMAND DECODING
;FLAG ONCE THROUGH IN HACKQ. DON'T ALWAYS DO CLRBFI'S.
;UNDO EDIT 216, IT CAUSED OUTRAGEOUS %CPU TIMES WITH "REENTER"
;AREAS AFFECTED:.DVDAT,GENSTS,DUNJOB,FINIS,HACKQ,RDCMND,OLDTIM,
;	SYSINI,GENST1,GENST5,GENST7,TSTATE

;EDIT 224	KPY 20-FEB-78
;FIX 5.03 OR LATER UNIT ERROR INFO ROUTINE
;UNI2ND SHOULD BE INDEXED BY D.
;AREAS AFFECTED: DP AT FLUNN0+4
;C FILE SYMBOLS WHICH ARE OVERRIDDEN


;EDIT 225	PG 30-MAR-78
;PPN'S MUST HAVE NON-ZERO PROJECT NUMBERS
;AREAS AFFECTED: GETPPN


;EDIT 226	ISM 19-APR-78
;FIX "SY P" TO REPORT ON ALL THE STRUCTURES MOUNTED ON THE SYSTEM, 
;ESPECIALLY THOSE BEYOND A STRUCTURE DATA BLOCK WITH A NULL NAME.
;
;EDIT 227	ISM	6-9-78	IF "SYSTAT C" IS GOING TO DISK,
;MAKE IT UPDATE THE FILE IN APPEND MODE.
;
;EDIT 230	ISM	6-26-78		CREATE A SUBROUTINE TO SIMULATE
;THE CTLJOB UUO WHEN SYSTATING A CRASH FILE.
;
;EDIT 231	ISM	7-12-78		NOT ENOUGH BITS USED TO DETERMINE
;ACTIVE SWAPPING STATISTICS IN "SYSTAT P". USED TO BE 2**12, CURRENTLY 2**13.
;
;EDIT 232	KPY 31-JUL-78
;	1)  AT GETFIL + 2 USE [1,,2] NOT FSFPPN SINCE THE LATTER IS NOT SETUP
;	AT THIS POINT.
;	2)  AT GETFIL + 3 REPLACE 400000 WITH FO.PRV.
;BEGIN VERSION 474 HERE WITH 7.00 UPDATE
;EDIT 233
;	REMOVE THE /R SWITCH SINCE IT HAS NEVER WORKED WITH
;	NETWORKS.
;EDIT 234
;	UNI2ND HAS A NEW FORMAT TO INDICATE A DRIVE IS DUAL
;	PORTED ACROSS CPU'S.  MAKE THE SYS P CODE KNOW ABOUT IT.
;EDIT 235
;	PRINT DISK DDB'S IN THE BUSY DEVICE CODE IFF WE ARE READING
;	A CRASH FILE OR FOR A USER'S OWN JOB.  SINCE THE DDB'S ARE
;	NOW IN FUNNY SPACE THEY CANNOT BE RELIABLY READ FOR ANY JOB
;	BUT OUR OWN.
;EDIT 236
;	HIGH AND DORMANT HIGH SEGS CAN NOW HAVE POINTERS TO PATH
;	BLOCKS.  FOLLOW THE POINTER AND PRINT THE OWNER PPN.
;EDIT 237
;	PRINT THE MONITOR NAME ON THE USER'S TERMINAL ON SYS X
;	COMMANDS TO GIVE HIM A CHANCE TO ABORT WITHOUT WAITING
;	FOR 3 MINUTES WHILE SYSTAT CRAWLS THROUGH THE DISK FILE.
;EDIT 240
;	PRINT "PRIVATE STRUCTURE" IN SYS F FOR PRIVATE STRUCTURES.
;EDIT 241
;	PRINT %OVERHEAD TIME IN THE HEADER
;EDIT 242
;	ACCEPT CONSTRUCTS OF THE FORM [,] AND ALLOW SFD'S IN
;	THE FILE SPEC FOR SYS X.
;
;EDIT 243  SPR 10-27276
;	INVALIDATE SY X IF JOB NOT LOGGED IN EXCEPT
;	IF CONTROLLED BY [1,*].
;
;
;EDIT 244 SPR 10-27189
;	ELIMINATE CPU1 DATA FROM SY E WHEN NCPUS=1
;
;
;EDIT 245 	SPR 10-27179
;	REMOVE REFERENCES TO OBSOLETE FLAG
;	TTYFLG
;
; 246	WCL	15-MAY-79	SPR 10-27980
;	6-DIGIT PROJECT NUMBER RUNS INTO JOB NUMBER; INSERT SPACING
;	AREAS AFFECTED: TTYOK, NOTSLF
;
;EDIT 247	SPR 10-28133
;	REMOVE THE ^D SENT WHEN SYSTAT IS RUN NOT-LOGGED-IN
;EDIT 250	SPR 10-27724
;	EDIT PUBLISHED AS 246 LOST
;	CHANGE PUSHJ P,FGETTB TO GETTAB IN EDIT 243 SO WE GET
;	CURRENT INFO ON PPN OF CONTROLLING JOB WHEN PROCESSING SY X.
;EDIT 251
;	ENHANCE THE MESSAGE PRINTED BY EDIT 237 TO INCLUDE THE DATE
;	AND TIME OF THE CRASH AND THE STOPCD NAME.
;
;BEGIN VERSION 475 HERE WITH 7.01 UPDATE
;EDIT 252
;	ADD THE /U SWITCH TO PRINT A LIST OF USERS.  THIS SWITCH MAY
;	BE COMBINED WITH ANY OTHER SWITCH OR COMMAND.
;EDIT 253
;	ADD CPU STOPCD TYPE TO SYS E CODE.
;EDIT 254
;	MAINTAIN AN INCORE CACHE OF PAGES FROM THE EXE FILE FOR "SYS X"
;	THIS WILL MAKE IT QUITE A BIT FASTER
;EDIT 255
;	NEW MONBTS DUMPS HAVE HOLES FOR NXMTAB, CHANGE "SYS X" TO REALLY
;	UNDERSTAND .EXE DIRECTORY FORMAT
;	HAD TO INCREASE DEFAULT PDL SIZE FOR THIS EDIT
;EDIT 256
;	DEFAULT NCPUS TO 4, REFORMAT CPU SPECIFIC OUTPUT
;EDIT 257
;	USE THE EPT OF THE BOOT PROCESSOR (BOOTCP) FOR "SYS X"
;	USE GETTAB TO FIND THE CTY CAUSE IT CAN MOVE IN 7.00/7.01
;EDIT 260
;	REMOVE EDIT 202, PEEKA IS SMART ENOUGH NOW FOR BOTH RUNNING
;	AND CRASHED MONITORS
;EDIT 261
;	EDIT 256 BROKE OUTPUT FOR PRE-7.00 MONITORS
;
;	701 Release SYSTAT 475(261)
;
;EDIT 262	SPR #10-29511	RKB	16-JUN-80
;	ADD A NEW PER-JOB TABLE (C0UPTM) TO SHOW CPU0 UPTIME AT EACH RUN-
;	TIME CALCULATION (PREVENTS >100% USAGE ON "REENTER" COMMAND)
;EDIT 263	SPR #29511	RKB	22-JUL-80
;	FIX TWO PROBLEMS WITH EDIT 262: "7.01-IZE" THE UPTIME TABLE, AND
;	DELETE A LINE OF CODE (C0UPTM IS NOW SYSUPT)
;EDIT 264	SPR #30143	BCM	8-Dec-80
;	Correct the offset for UNILOG data
;EDIT 265	SPR #10-30144	BCM	9-Dec-80
;	Print out filename information in header along with everything else
;EDIT 266	SPR #10-30060	RKB	7-JAN-81
;	Teach "SYS T" about networks, and make it print out more useful
;	information.
;EDIT 267			RKB	8-JAN-81
;	Fix the "FGETTB" routine to do GETTABs on addresses higher than
;	the EXEC address 400000.
;EDIT 270	SPR #10-30361	RKB	14-JAN-81
;	Avoid getting over 100% overhead, null, or lost time
;	reported on REENTER.
;EDIT 271	SPR #10-30215	RKB	15-JAN-81
;	"SYS B" could type out the "busy device" header without listing
;	any devices, if all devices in use are PTY's.
;EDIT 272	SPR #10-30512	BCM	28-JAN-81
;	Fix edit 265 to work correctly.
;EDIT 273	SPR #10-30857	BCM	14-APR-81
;	Minor fix to edit 272
;EDIT 274	SPR #10-30858	BCM	15-May-81
;	Check if we are 50 Hz early, and store result
;EDIT 275	SPR #10-30998	BCM	18-May-81
;	Skip the first counter increment so we get DSCTAB + 0
;EDIT 276
;	SPR #10-31700,31733	GAT	7-JAN-82
;	FIXES EDIT 274. CORRECTLY FETCHES THE RIGHT "STATES"
;	WORD FROM THE MONITOR OR THE CRASH DUMP, TO DETERMINE
;	THE CORRECT LINE FREQUENCY(50/60 HERTZ).
;EDIT 277			JMF	14-Jan-82
;	Make "SYS X" work with KL paging
;EDIT 300			JMF	16-Jan-82
;	Tell swapping statistics for the second port of a dual ported drive
;	in the "SYS P" report
;EDIT 301			JMF	16-Jan-82
;	Report characters received, transmitted, and echoed in "SYS E"
;EDIT 302			JMF	16-Jan-82
;	GETTAB the offset into the UDB of DEVUNI so that UNILOG comes out
;	correctly in "SYS X" report no matter what monitor was running (if
;	the GETTAB is implemented)
;EDIT 303
;	GAT	21-JAN-82	SPR #10-31462
;	SYS L NEVER CHECKS OUTPUT UUO FOR ERRORS
;EDIT 304	GAT	26-JAN-82
;	CORRECTS TIME PRINTED IN "TIMESHARING ENDS" MESSAGE
;EDIT 305
;	SUPERSEDES EDITS 264,302	GAT	25-JAN-82
;	CLEAN UP CODE SO SYSTAT GETS PROPER DDB OFFSETS
;	FOR EITHER THE RUNNING MONITOR OR THE CRASH FILE
;EDIT 307	GAT	SPR 10-31803	3-FEB-82
;	TEACH SYS P THAT ON A KS THERE ARE NO DUAL PORTS, AND STOP IT 
;	FROM READING UNI2ND AND PRINTING GARBAGE.
;EDIT 310	GAT	SPR 10-31706	10-MAR-82
;	CORRECT ACTIVE SWAPPING RATIO CALCULATION TO INCLUDE 
;	PER PROCESS PAGES AND PRINT IT OUT MORE ACCURATELY.
;	(SYSTAT/SYSDPY CALCULATIONS ARE THE SAME NOW)
;EDIT 311	GAT		16-MAR-82
;	PRINT "Not Running" MSG FOR STOPPED CPUS
;EDIT 312	GAT		17-MAR-82
;	MAKE "SYS GG..."   WORK CORRECTLY
;EDIT 313	JMF	22-MAR-82
;	REPORT CHARACTERS TRANSMITTED/RECEIVED/ECHOED ON 
;	ALL CPUS.
;EDIT 314	GAT		16-JUL-82
;	FIX EDIT 305 THAT WAS STILL RETURNING THE WRONG
;	VALUE OF DEVUNI FOR PRE-700 MONITORS.
;EDIT 315	GAT		16-AUG-82
;	MAKE "SYS P" REPORT INFORMATION ON MAIN OR ALTERNATE 
;	PORT EVEN IF NO I/O HAS OCCURRED. REMOVE SECOND OCCURRENCE 
;	OF "FREE" FOR ALT PORT.
;EDIT 316	GAT		23-AUG-82	SPR 10-32936
;	FIX EDIT 300. PRINTS ONE LINE OF GARBAGE AFTER EACH UNIT 
;	IN "ACTIVE SWAPPING STATISTICS"	ON A KS-10.
;EDIT 317	GAT		20-OCT-82	SPR 10-33165
;	EDIT 310 DOES NOT ALWAYS CLEAN UP STACK CORRECTLY AND 
;	IS PRONE TO "?ILL ADDRESS/MEM REFs".
;EDIT 320	GAT		19-NOV-82	SPR 10-32964
;	DEFAULT HACKSW TO ZERO. 
;EDIT 321	GAT		29-DEC-82	SPR 10-33374
;	EDIT 310 FETCHES NUMBER OF FUNNY PAGES INCORRECTLY.
;EDIT 322	GAT		18-FEB-83	SPR 10-33570/QAR 125027
;	FIX ILL MEM REF CAUSED BY EDIT 266 WHEN ENTRY FOUND IN 
;	DSCTAB IS PRINTED BY "SYS T".
;EDIT 323	GAT		8-APR-83	QAR 125024
;	SYSTAT SHOWED INCORRECT IDLE TIME FOR CPU3.
;EDIT 324	GAT		24-OCT-83	SPR 10-33843
;	"SYS P" REPORTS INCORRECT NUMBER OF RETRIES (UNIECT).
;EDIT 325	JMF		12-JUN-84	NO SPR
;	FIX ILL MEM REFS FROM "ONE WORD GLOBAL BYTE POINTERS" IN 
;	NEW MICROCODE (V352).
;EDIT	326	JMF		07-JAN-85	SPR 10-34951
;	REPORT SYSTEM UPTIME AS WELL AS CPU UP TIMES ON SMP SYSTEMMS
;EDIT	327	JMF		15-JAN-85	NO SPR
;	TEACH SYSTAT ABOUT 7.03
;EDIT	330	JMF		9-DEC-83	NO SPR
;	ADD PAGING I/O STATISTICS TO SYS P DISPLAY.
;EDIT	331	JMF		9-DEC-83	NO SPR
;	MAKE SYS E DISPLAY EASIER TO READ, PUT THE MOST IMPORTANT THINGS FIRST,
;	AND ADD BLOCKS XFERRED FOR FILE AND SWAPPING I/O.
;EDIT	332	JMF		19-APR-85	NO SPR
;	FIX SOME BUGS IN 327.
;EDIT	333	JMF		7-JUL-85	SPR 10-35259
;	SYSTAT hiseg display occasionally doesn't show the device name.
;EDIT	334	JMF		6-AUG-85	NO SPR
;	Fixup SYS E display when CPU0 isn't running. 
;EDIT	335	LEO		9-AUG-85	NO SPR
;	Fix copyright statements.
;EDIT	336	JMF		10-OCT-85	QAR 868325
;	CHECK LTLUSE BEFORE PRINTING TTY INFO IN "SYS T" DISPLAY
;EDIT	337	JMF		17-FEB-86	NO SPR
;	SYSTAT "D" display doesn't show swapped out dormant segments under 7.03.
;	It also doesn't indicate fragmented swapping correctly.
;
;END OF EDIT HISTORY
;
F%RSP=1B28		;RESPONSE TIME FEATURE

;PRINTS ON SYSTAT:SYSTAT.TXT  OR  TTY:SYSTAT.TXT

SALL

	SEARCH	JOBDAT,MACTEN,UUOSYM ;GET STANDARD SYMBOLS
	LOC	.JBVER
	BYTE	(3)VWHO(9)VSYSTAT(6)VMINOR(18)VEDIT

RELOC

COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1968,1986. ALL RIGHTS RESERVED.
\;END COPYRIGHT MACRO


;AC ASSIGNMENTS

F=0
A=1
B=2
C=3
D=4
J=5
JS=6
R=7
N=10
N1=11
M=12
CH=13
BP=14
WD=15
F1=16
P=17

;I/O CHANNEL

HLP==0	;CHANNEL 0 IS RESERVED FOR HELPER
TTY==1	;FOR OUTPUT
DSK==2	;FOR READING DSK:CRASH.XPN

;ASSEMBLY OPTIONS

IFNDEF PURESW,<PURESW==0>	;SHARABLE
IFNDEF LN.PDL,<LN.PDL==30>	;LENGTH OF PUSH-DOWN LIST
IFNDEF LN.BUF,<LN.BUF==200>	;LENGTH OF DISK BUFFER
IFNDENSW,<STANSW==0>	;PPN IS ALWAYS SIXBIT
IFNDEF HACKSW,<HACKSW==0>	;DO NOT INCLUDE HACKS (IF -1, JUST FOR LISTED SYSTEMS)
IFNDEF NSPMEM,<NSPMEM==^D1000>	;N-SEC/MEMORY CYCLE(IN CASE MONITOR REFUSED TO TELL US)
IFNDEF HIDPPN,<HIDPPN==0>	;HIDE DETACHED JOBS PPN
IFNDEF NCPUS,<NCPUS==^D4>	;NUMBER OF CPUS IN THE SYSTEM
IFG NCPUS-6,<NCPUS==^D6		;EVEN THE MONITOR CAN'T HANDLE MORE THAN THIS
PRINTX	%Number of CPU's reduced to six
>
IFNDEF	JOBMAX,<JOBMAX==^D512>	;MAXIMUM NUMBER OF JOBS FOR TABLES
IFNDEF NBCSHE,<NBCSHE==^D25>	;NUMBER OF PAGES TO KEEP IN CORE
	IFLE NBCSHE,<NBCSHE==1>	;IN CASE WE DON'T LIKE THE VALUE
IFNDEF FTAMPM,<FTAMPM==-1>	;-1=FORCE 24 HR. CLOCK, +1=FORCE AM/PM,
				;0=MAKE FOLLOWING DUBIOUS ASSUMPTION:
;50 HZ POWER LINE MEANS USE 24 HR TYPEOUT, 60 HZ MEANS USE AM/PM

IFNDEF	FTEXE,<FTEXE==1>	;SUPPORT FOR EXE FILES
IFNDEF FTDEBUG,<FTDEBUG==0>	;-1 TO ENABLE SYSTAT TO BE DEBUGGED
;FTDEBUG ALLOWS COMMANDS OF THE FORM "START ;ARG" TO PASS
; "ARG" TO SYSTAT.  ALSO INCLUDES PATCH AREA.
;
;NOTE:  TO DEBUG WITH BREAKPOINTS VIA DDT, TYPE 
;  "HALT$X".  THIS WILL SET THE BREAKPOINTS AND TRAP
; TO THE MONITOR.  THEN TYPE "START ;ARGS"
;COMMANDS

L.BDO=="B"	;B WAS TYPED  BUSY DEVICES
L.DSO=="D"	;D  "    "    DORMANT SEGMENTS
L.FSO=="F"	;F  "    "    FILE STRUCTURES
L.GSS=="G"	;G  "    "    GENERAL SYSTEM STATISTICS
L.DPO=="P"	;P  "    "    PERFORMANCE OF DISKS
L.SSO=="S"	;S  "    "    SHORT JOB STATUS
L.JSO=="J"	;J  "    "    JOB STATUS
L.EJS=="N"	;N  "    "    ALL BUT JOB STATUS
L.LPT=="L"	;L  "    "    LIST ON LPT
L.HSO=="H"	;H  "    "    HELP
L.DSC=="T"	;T  "    "    DATA SET STATUS (TTY)
L.ERR=="E"	;E  "    "    ERROR REPORTS (NON-DISK)
L.USR=="U"	;U  "    "    LIST USER NAMES
L.DSK=="X"	;X  "    "    READ FROM DSK:CRASH.XPN
L.MYJ=="."	;.  "    "    MY JOB ONLY
L.DPY=="V"	;V  "    "    VT05 OR VT06 USER...TYPE 20 LINES AT A TIME & WAIT 
L.CNT=="C"	;C  "    "    CONTINUOUS TO SAME FILE
L.GOD=="O"	;O  "    "    GODLY POSSESSOR OF SECRET CHARACTER
L.WLD=="*"	;*  "    "    PPN WILD CARD

;FLAGS (LH OF F)

FL.DSK==1	;DISK MODE
FL.HGH==2	;HIGH SEG PARAGRAPH NEEDED
FL.GOD==4	;I AM [1,N]
FL.LGI==10	;I AM LOGGED IN
FL.DTJ==20	;THIS JOB DETACHED
FL.DOR==40	;DORMANT SEG TABLE BEING PRINTED
FL.SCN==100	;NEW SCANNER SERVICE (FOR TTYTAB LAYOUT)
FL.DEV==200	;HEADER OUTPUT SYNC
FL.NUM==400	;IF # PRINTED
FL.NST==1000	;IF @ PRINTED
FL.SZR==2000	;SUPPRESS ZEROES
FL.BZR==4000	;BLANK OUT ZEROES
FL.HSG==10000	;WORKING ON HIGH SEGMENT
FL.LPT==20000	;LIST ON LPT
FL.RPT==40000	;REPEATING, WAITING FOR LPT
FL.EXM==40000	;IF ! PRINTED (DURING RUN)
FL.AMP==100000	;IF & PRINTED
FL.NBK==200000	;NON-BLANK LINE
FL.BRK==SIGN	;NO MORE CHS. TO I/P OR BREAK CH. SEEN

;FLAGS (RH OF F)

FR.OVR==1B35	;COLUMN OVERFLOW
IFGE  FTAMPM,<
FR.DAY==1B34	;DO TIME AS TIME OF DAY (AM/PM)
>
FR.XOM==1B33	;IF $ PRINTED
FR.HPQ==1B32	;IF HPQ # PRINTED
FR.NFS==1B31	;IF UNIT NOT IN A F/S
FR.NFP==1B30	;IF "UNIT-NOT-IN-AN-F/S" MESS NOT PRINTED
FR.CNT==1B29	;WE ARE DOING A CONTINUOUS SYSTAT
FR.DPY==1B28	;PAGE HIS OUTPUT....HE HAS A DISPLAY
FR.END==1B27	;WE HAVE BEEN THOUGH THE CONT. THING BEFORE
FR.CHG==1B26	;THIS IS NEW OR RE-LOGIN FOR JOB
FR.LGN==1B25	;SOME NEW LOGIN THIS PASS
FR.VMF==1B24	;THE VM FEATURE IS SUPPORTED
FR.INI==1B23	;THE TTY CHANNEL IS OPEN
FR.DSK==1B22	;OUTPUT IS TO A DISK FILE
FR.CMT==1B21	;A COMMENT HAS BEEN SEEN
FR.EXE==1B20	;EXE MODE
FR.INC==1B19	;DOING INCREMENTAL SYSTATS
FR.USR==1B18	;PRINT USER NAME

;FLAGS (LH OF F1)

F1.XAD==1	;ADDRESSES ARE 30 BIT QUANITIES (DON'T CLEAR LH WHEN PEEKING)
;STUFF WHICH HAS TO AGREE WITH MONITOR, ASIDE FROM GETTAB DEFNS

ABSTB1==151	;OLD VALUE OF ABSTAB, POINTER TO NUMTAB
ABSTB2==410	;NEW VALUE OF ABSTAB AFTER 503+ MONITOR
JBTLOC==26	;TABLE FOR JOB LOCATIONS
CMWB==200000	;COMMAND WAIT IN JOB STATUS TABLE
JNA==40000
JLOG==4
JDCON==20000	;JOB WAITING FOR DEVICE TO BE READIED
JDC==100000	;JOB WAITING FOR DCORE OR DUMP COMMAND
ASSCON==400000
ASSPRG==200000
SNA==400000
NSWP==10000		;NON-SWAPPABLE IN LH JBTSTS
JSWP==2000
NSHF==1000		;NON-SHUFFLABLE IN LH JBTSTS
CLKR==1B18		;JOB HAS A CLOCK REQUEST IN
JS.XO==1B25		;EXECUTE ONLY BIT IN RH OF JOB STATUS
SHRSEG==200000
CLKCYC==1B6		;CLOCK CYCLES (1=50 HERTZ)
CANXRC==1B13		;EXTENDED RIBS (1=MONITOR CAN READ/WRITE THEM)
GT.PRC==1B9		;BIT IN NUMTAB ENTRY MEANING DATA IN PDB
GT.PDB==4		;PDB ENTRY IN NUMTAB

IOIMPM==400000
IODERR==200000
IODTER==100000

DV.NAM==0
DV.CHR==1
DV.IOS==2	;DEVICE STATUS
DV.SER==3
DV.MOD==4
DV.LOG==5	;LOGICAL DEVICE NAME
DV.SPL==12	;SPOOL DATA
DV.JOB==20	;THESE ARE 603A DDB OFFSETS
DV.FIL==21	;FILE NAME IF DISK
DV.EXT==22	;FILE EXTENSION IF DISK
DV.PPN==23	;P,PN IF DISK
DV.UNI==30	;UDB POINTER IF DISK
;STARTING WITH VERSION 507 DDBLDB CAN BE OBTAINED WITH GETTAB 
DDBLDB==11	;LINK TO LDB IF NEW SCNSER
;SEE ALSO PJOBN AND TPCJOB
;PARAMETERS

SIGN=400000
DVDSK==200000
DVTTY==10
DVTTYC==20000	;TTY IN USE AS CONSOLE
LDBTTW==56
LTLUSE==40000	;LDB IS IN USE
OUTMSK==377000
UU.PHS==1B19		;PHYSICAL ONLY  BIT
FSP==370		;PAGE INTO WHICH TO MAP FUNNY SPACE PAGE
FSPADR==FSP_^D9		;ABOVE AS AN ADDRESS

MLON

OPDEF	PJRST [JRST]
OPDEF	DEVNAM	[CALLI	64]
OPDEF	CHKACC [CALLI 100]

DEFINE	BOMB(A),<JRST	[JSP	M,BOMB.
			ASCIZ	\A\]>
DEFINE	ALLCPUS,<
	ZZ==0
	REPEAT	NCPUS,<
		EACHCPU(\ZZ)
		ZZ==ZZ+1
	>
>
DEFINE	CALL(R)
<	PUSHJ	P,R
>
DEFINE	RETURN
<	POPJ	P,
>
;STR DATA BLOCK

STRNAM==0
STRSYS==1
STRUNI==2
STRTAL==11
STRMNT==13
STRUN1==15
  STPPVS==1B35		;STRUCTURE IS PRIVATE
STRJOB==20

;UNIT DATA BLOCK

UNINAM==0
UNILOG==1
UNIHID==2
UNISYS==3
UNISTR==4
UNISWP==7
UNIK4S==7	;RIGHT 13 BITS = K FOR SWAPPING
  MSKK4S==17777	;CHNAGED FROM 12 BITS TO 13
UNIHCT==10
UNISCT==11
UNIMCT==12
UNIERR==13
UNISOF==14
UNIHBN==15
UNIBRC==16
UNIBWC==17
UNIDRC==20
UNIDWC==21
UNIMRC==22
UNIMWC==23
UNIICT==24
UNIOCT==25
UNIMSC==26
UNIUSC==27
UNIPCT==30
IFNDEF UNIFKS,<UNIFKS==31>
UNISDI==32
UNIHDI==33
UNIECT==34
UNIHNG==35
;UNITA UNIDES AND UNIXRA ARE SINCE 50634 5 LARGER
UNIPCI==45
UNIPCO==46
UNITAL==47	;IN 503, 504
UNITL1==41	;UNITAL PRE 503
UNIDES==50	;IN 503,504 - BUT NOT IN 501
UNIDE1==42	;UNIDES PRE-503
  UNPZMT==10000
  UNPSAF==20000
UNIXRA==54
UNI2ND==72
;FIELDS IN DATA SET CONTROL TABLE

DSCSTS==7B2	;STATE OF DATA SET
DSCTIM==77B17	;TIMER FOR DATA SET

IFN	PURESW,<TWOSEG
		RELOC	400000>
	SUBTTL	INITIALIZATION
;START HERE

SYSTAT:	RESET			;CLEAR ALL I/O AND RESTORE CORE
	SETZM	GOTCMD		;WE DONT YET HAVE A COMMAND
	MOVE	A,[GOTCMD,,CMDBUF]	;CLEAR ANY JUNK
	BLT	A,CDENDP	;THAT MIGHT BE LYING AROUND
CNTLP:				;HERE'S WHERE WE GO TO DO
				;THE SAME OLD COMMAND AGAIN
	IFN	PURESW,<
	MOVE	A,[XWD HIGH,LOW]
	BLT	A,LOWEND-1
>
	MOVE	A,[XWD LOWEND,LOWEND+1]
	SETZM	LOWEND
	BLT	A,TEMEND
	SETZB	F,WD		;CLEAR WD FOR NORMAL SYSTAT O/P
	JRST	.+3		;DOUBLE SKIP
REENTR:	RESET			;REENTRY POINT
	TRO	F,FR.INC	;SET INCREMENTAL MODE BIT
	TDZ	F,[FL.BRK,,FR.INI!FR.DSK!FR.CMT] ;MARK RESET DONE
	SETZM	JOBINT+2	;NO ^C TYPED YET
	MOVEI	A,SYSTAT	;SET REENTER POINT (RESET LATER)
	MOVEM	A,.JBREN	;SAVE IT
	SETOM	ONCE		;CLEAR ONCE THRU FLAG
	MOVEI	M,^D19		;PAGE SIZE LESS ONE FOR DISPLAYS
	MOVEM	M,LINECT	;RESET THE COUNTER
	MOVE	P,PDP		;SETUP STACK PNTR.

REPEAT 0,<
	OUTSTR	[ASCIZ /Systat V/]
	MOVE	N,.JBVER	;GET VERSION NUMBER
	PUSHJ	P,VERPRT	;TYPE IT TO USER
	PUSHJ	P,CRLF		;AND END LINE
>

	PUSHJ	P,STATE		;GET STATES WORD
	MOVE	A,XMNVER	;GET MONITOR VERSION
	CALL	GETZ		;GET VALUE IN A
	HRRZS	A		;ZAP NOISE BITS
	MOVEM	A,MONVER	;AND REMEMBER IT
	CAIGE	A,60122		;OLD STYLE IF LESS
	CAIGE	A,60000		;AN OLD MONITOR
	CAIGE	A,50722		;IF NOT VERSION 6 OR LATER
	JRST	SYSTA1		;OLD STYLE
SYSTA0:	SETOM	NEWSPY		;NEW SPY LOGIC
	MOVE	A,[POINT 9,C,35]	;NEW POINTER TO JOB NUMBER
	MOVEM	A,NPJOBN	;NEW JOB NUMBER POINTER
SYSTA1:	IFE	PURESW,<
	MOVE	A,XSYSSZ	;GET SIZE OF SYSTEM
	PUSHJ	P,GETA		;FROM THE MONITOR
	MOVEI	A,-1(A)		;(BACK UP ONE)
	SPY	A,		;AND TRY TO SPY
	  JRST	NOSPY		;CAN'T--USE GETTABS, ETC.
;NOTE THAT ALL SPY DATA WILL BE CHANGED BY SETDSK WHEN A SYSTAT
;OF A CRASHED MONITOR ISMADE
	SETOM	SPYFLG		;CAN--SET FLAG FOR PEEKS
	MOVE	A,XGTTBI	;SEE IF WE HAVE GETTAB IMMEDIATE
	PUSHJ	P,GETZ		;IN THIS MONITOR
	JUMPE	A,NOSPY		;IF NOT--STILL DO GETTABS
	HRRZM	A,OFSGTB	;YES--STORE OFFSET FOR PEEK VIA SPY
	LSH	A,-^D9		;POSITION LENGTH OF TABLE
	HLRZM	A,MAXGTB	;AND STORE FOR SIMULATOR
	MOVE	A,XPDBPT	;POINTER TO JBTPDB
	PUSHJ	P,GETZ		;GET IT IF IT EXISTS
	SKIPE	A		;IF IT DOES,
	TDO	A,[XWD A,400000]	;MAKE POINTER FOR INDIRECTING AND INDEXING
	MOVEM	A,PDBPTR	;STORE FOR LATER
>
NOSPY:	MOVE	A,[XWD 4,FINIS]	;SETUP TO INTERCEPT CONTROL C
	MOVEM	A,JOBINT
	MOVE	A,[EXP ER.MSG+ER.ICC]
	MOVEM	A,JOBINT+1
	MOVEI	A,JOBINT
	HRRM	A,.JBINT
	PJOB	A,		;GET MY JOB NUMBER
	MOVEM	A,MYJOB
	HRROI	A,0		;MY STATUS
	PUSHJ	P,GETA
	HRROI	B,2		;MY PPN
	PUSHJ	P,GETTB
	  JRST	GODLY		;NON DISK SYSTEM-FLAG AS GODLY
	TLNE	A,JLOG		;LOGGED IN?
	TLO	F,FL.LGI	;YES-REMEMBER IT
	TLNN	B,-2		;PROJECT 1?
	TLNN	A,JLOG		;YES-LOGGED IN?
	SKIPA			;NO
GODLY:	TLO	F,FL.GOD	;WE'RE GOD
	TLNN	F,FL.LGI	;ARE WE LOGGED IN?
	SETZ	B,		;NO--CLEAR OUR NUMBER
	MOVEM	B,ME		;SAVE FOR FUTURE TESTS
	PUSHJ	P,RDCMND	;YES--READ COMMAND INTO BUFFER
	SUBTTL COMMAND DECODING
COMND:	PUSHJ	P,GETCHR	;INPUT A CH.
	  JRST	NOGO		;NO CHS. LEFT OR A BREAK CH.
	CAIG	WD,"Z"
	CAIGE	WD,"A"		;IGNORE ALL NON-ALPHABETIC CHS.
	JRST 	COMND
IFE FTDEBUG,<
	CAIE	WD,"S"		;IGNORE FIRST WORD UNLESS IT BEGINS WITH S
	JRST	NOGO
>
COMND1:	PUSHJ	P,GETCHR	;GET CHARACTERS OF WORD
	  JRST	NOGO		;JUMP IF END OF LINE
	CAIG	WD,"Z"		;SKIP UNTIL NO ALPHAS
	CAIGE	WD,"A"		;..
	JRST	AGAIN1		;DONE--CHECK SEPARATOR
	JRST	COMND1		;NO--LOOP
AGAIN:	PUSHJ	P,GETCHR	;2ND. TIME AROUND LOOK FOR 1ST. CH. NOT A SPACE
	  JRST	NOGO		;NO CHS. LEFT OR A BREAK CH.
AGAIN1:	TLNE	F,FL.DSK
	CAIE	WD," "
	SKIPA
	JRST	NOGO
	CAIE	WD," "		;SKIP SPACES
	CAIN	WD,","		;AND COMMAS
	JRST	AGAIN		;..
IFN FTDEBUG,<
	CAIE	WD,";"		;SKIP SEMICOLON
>
	CAIN	WD,"/"		;SKIP SLASH
	JRST	AGAIN		;..
	JRST	.+2
NOGO:	MOVEI	WD,0		;CLEAR WORD IF NOT "SYSTAT" COMMAND
	CAIN	WD,L.DSK	;SEE IF CRASH FILE REQUESTED
	JRST	[TLO F,FL.DSK
		 JRST AGAIN]

;HERE TO INIT THE DEVICE AND ENTER THE FILE

	CAIN	WD,L.DPY	;IS THIS A DISPLAY?
	JRST	[TRO	F,FR.DPY	;REMEMBER IT
		JRST	AGAIN]
	CAIN	WD,L.CNT	;DO IT OVER AND OVER AND OVER?
	JRST	[TRO	F,FR.CNT	;REMEMBER IT
		JRST	AGAIN]
	CAIN	WD,L.USR	;WANT USER NAMES?
	JRST	[TRO	F,FR.USR
		 JRST	AGAIN]
	CAIE	WD,L.GOD	;IS HE GODLY ANYWAY?
	JRST	SYSINI		;NO GET DEVICE
	TLO	F,FL.GOD	;HE KNEW THE SECRET THING
	JRST	AGAIN
	SUBTTL	COMMAND DISPATCH AND SET UP
SYSINI:	PUSH	P,F		;SAVE CURRENT F
	TLZ	F,FL.DSK	;TURN DISK USAGE OFF
	CALL	GETTTY		;MAKE OUTPUT AVALABLE
	POP	P,A		;GET OLD F BACK
	TLNE	A,FL.DSK	;WAS DISK FEATURE ON
	TLO	F,FL.DSK	;THEN MAKE IT VISIBLE AGAIN
	TLZ	F,FL.RPT	;CLEAR OUT FLAG FOR MESSAGE (LPT)
	CAIN	WD,L.LPT	;GETTING LPT??
	JRST	AGAIN		;NEXT CHARACTER
	TRNE	F,FR.DSK	;IF OUTPUT GOES TO A DISK
	TRZ	F,FR.DPY	;THEN DO NOT PAGE
	HRRZ	A,.JBFF		;PRIME THE FREE CORE SPACE
	MOVEM	A,FREE		;FOR SUBSEQUENT CALLS
	MOVEI	A,340000	;CATCH 22, .UPFSO AND .UPFSE MUST BE INITIALIZED
	MOVEM	A,.UPFSO	; TO SOMETHING FOR DSKA TO WORK, BUT CAN'T GET
	MOVEI	A,400000	; REAL VALUES UNTIL DSKA DOES WORK. SO SET THEM
	MOVEM	A,.UPFSE	; TO RANDOM VALUES, INITIALIZED FOR REAL LATER
	PUSH	P,WD		;SAVE COMMAND
	TLNE	F,FL.DSK	;WAS DISK FEATURE ALREADY THERE
	PUSHJ	P,SETDSK
	POP	P,WD		;RESTORE COMMAND
.DVDAT:	MOVE	A,[%CNCPU]	;NUMBER OF CPUS FROM MONGEN
	PUSHJ	P,FGETTB	;GET IT FOR LOOP
	  JRST	[MOVE A,[%CNSTS] ;OLD MONITOR, GET CONFIG STATUS
		 PUSHJ P,FGETTB	;GET IT
		   SETZ A,	;REAL OLD MONITOR
		 TLNN A,(ST%DUL) ;DUAL PROCESSOR MONITOR
		 TDZA A,A	;NO, GET A ZERO
		 MOVEI A,1	;YES
		 AOJA A,.+1]	;RESUME INLINE, A=NUMBER OF CPUS
	CAILE	A,NCPUS		;MORE THAT THIS VERSION WAS ASSEMBLED FOR
	MOVEI	A,NCPUS		;YES, RESET TO ASSEMBLY PARAMETER
	MOVEM	A,NCPCNF	;SAVE NUMBER OF CPUS AWAY
	MOVE	A,[%CNLSD]	;GET LENGH OF SHORT DDB
	CALL	GETZ		;GET A ZERO OR VALUE
	JUMPE	A,GETUPT	;UNKNOWN - GET UPTIME, ETC.
	HRRM	A,.DVFIL	;UPDATE POINTER
	SUBI	A,1		;BACK UP 1
	HRRM	A,.DVJOB	;AND GET THIS FOR LATER
	ADDI	A,2		;ADD 2 NOT 1 EXTENSION POINTER
	HRRM	A,.DVEXT	;UPDATE 
	ADDI	A,1		;PPN POINTER
	HRRM	A,.DVPPN	;UPDATE THAT TOO
	MOVE	A,[%LDDVU]	;DEVUNI OFFSET
	PUSHJ	P,GETZ		;GET OFFSET OR ZERO
	JUMPN	A,.DVDT2	;GOT IT
	MOVEI	A,DV.UNI	;SETUP DEVUNI 
	MOVE	B,MONVER	;GET MONITOR VERSION
	CAIGE	B,70000		;DO WE HAVE MONITOR VERSION 7.00 OR ABOVE?
	JRST	.DVDT2		;NO, DV.UNI GOOD ENOUGH
	MOVE	A,[%FTERR]	;FEATURE TEST WORD
	PUSHJ	P,GETZ		;GET IT OR ZERO
	TRNE	A,F%KL10&<0,,-1>;ON A KL?
	TRNN	A,F%MS&<0,,-1>	;SEE IF FTMP TRUE
	SKIPA	A,[DV.UNI]	;NO, DEVUNI=30
	MOVEI	A,DV.UNI+3	;YES, DEVUNI=33
.DVDT2:	HRRM	A,.DVUNI	;UPDATE UNIT POINTER
	MOVE	A,[%VMPPB]	;GET START OF FUNNY SPACE
	PUSHJ	P,FGETTB	;GET IT
	  MOVEI	A,340000	;TRADITIONAL VALUE
	MOVEM	A,.UPFSO	;SAVE FOR RANGE CHECKING
	MOVE	A,[%VMPPE]	;GET END OF FUNNY SPACE
	PUSHJ	P,FGETTB	;GET IT
	  MOVEI	A,400000	;TRADITIONAL VALUE
	MOVEM	A,.UPFSE	;SAVE FOR RANGE CHECKING
	MOVE	A,[%VMUPM]	;GET POINTER TO VIRTUAL ADDR OF UPMP
	PUSHJ	P,GETZ		;GET VALUE
	JUMPE	A,GETUPT	;IF NOT DEFINED
	MOVE	B,A		;SAVE IT
	MOVE	A,[%VMLST]	;GET UPMP OFFSET OF DISK DDB PTRS
	PUSHJ	P,GETZ		;GET IT
	JUMPE	A,GETUPT	;IF NOT DEFINED
	ADD	A,B		;ADD TOGETHER
	MOVEM	A,.UPLST	;SAVE FOR SPYPAG
	MOVE	A,[%CNBCP]	;GET CPU NUMBER OF BOOT PROCESSOR
	PUSHJ	P,FGETTB	;SO WE CAN RESOLVE HIGH SEG ADDRESS IN "SYS X"
	  SETZ	A,		;PRE-701, USE CPU0
	LSH	A,1		;*2 FOR GETTAB
	ADD	A,[%CCTOS]	;ADDRESS OF EPT FOR CPUN
	PUSHJ	P,FGETTB	;GET IT
	  SKIPA			;CAN'T, FORGET IT
	MOVEM	A,.CPTOS	;SAVE FOR LATER
	ADDI	A,540		;LOCATION OF SECTION MAP IN THE EPT
	MOVEI	B,0		;INDEX INTO SECTAB
.DVDT3:	MOVE	C,A		;WHERE TO GET ANSWER
	PUSHJ	P,PEEKC		;GET ENTRY IN SECTION MAP
	MOVEM	C,SECTAB(B)	;STORE IT
	AOS	A		;NEXT SECTION
	CAIGE	B,37		;DONE?
	AOJA	B,.DVDT3	;NO, READ NEXT ENTRY
	MOVE	A,[%FTERR]	;FEATURE TEST TABLE
	PUSHJ	P,GETZ		;GET FEATURE TEST SETTING BITS
	TRNN	A,<F%KLP&777777> ;KI OR KL PAGING?
	TDZA	A,A		;KI PAGING, EPT AND MAP ARE THE SAME PAGE
	MOVEI	A,1000		;KL PAGING, MAP IS THE NEXT PAGE AFTER THE EPT
	ADD	A,.CPTOS	;ADDRESS OF THE MAP
	MOVEM	A,.CPMAP	;SAVE THAT FOR DSKA

GETUPT:	MOVSI	A,-NCPUS	;ONCE FOR EVERY CPU
	SETZ	D,		;PREPARE COUNTER
	TRNN	F,FR.END	;FIRST TIME?
	SKIPE	ONCE		;(NO) ONCE THRU?
	JRST	UPTIME		;HERE-FIRST TIME
	MOVE	B,[XWD CPNNUL,CPNNUL+1]	;SET UP TO ZERO CPU STAT AREA
	SETZM	CPNNUL		;ZERO FIRST LOCATION
	BLT	B,TEMP-1	;DO IT
UPTIME:	MOVEI	B,(D)		;GET CPU*2
	ADD	B,[%CVUPT]	;GET UPTIME FOR THAT CPU
	CALL	GETTB		;GET IT
	  JRST	SYSIN3		;NO CPU
	MOVE	C,B		;SAVE UPTIME
	EXCH	C,CPNUPT(A)	;SAVE THE TIME AWAY
				;RECOVER OLD TIME
	SUB	B,C		;COMPUTE HOW MUCH TIME
				;HAS PASSED
	MOVEM	B,DIFTIM(A)	;SAVE ELAPSED TIME
	MOVE	B,CPNNUL(A)	;GET OLD NULL TIME
	MOVEM	B,OLDNUL(A)	;REMEMBER IT FOR LATER
	MOVEI	B,(D)		;GET CPU*2
	ADD	B,[%CVNUL]	;NULL TIME
	CALL	GETTB		;GET IT
	  SETZ	B,		;NONE
	MOVEM	B,CPNNUL(A)	;SAVE AWAY
	MOVE	B,CPNLST(A)	;GET OLD LOST TIME
	MOVEM	B,OLDLOS(A)	;SAVE IT NOW
	MOVEI	B,(D)		;GET CPU*2
	ADD	B,[%CVLST]	;LOST TIME
	CALL	GETTB		;GET IT
	  SETZ	B,		;NONE
	MOVEM	B,CPNLST(A)	;SAVE
	MOVE	B,CPNOHT(A)	;GET OLD OVERHEAD TIME
	MOVEM	B,OLDOHT(A)	;SAVE IT NOW
	MOVEI	B,(D)		;GET CPU*2
	ADD	B,[%CVOHT]	;OVERHEAD TIME
	CALL	GETTB		;GET IT
	  SETZ	B,
	MOVEM	B,CPNOHT(A)	;SAVE IT
	ADDI	D,2		;INCREMENT D BY 2 FOR
				;GETTAB TABLE
	AOBJN	A,UPTIME	;LOOP
SYSIN3:	TXZ	F,FR.VMF	;TEST HERE FOR VM  SUPPORT
	MOVE	A,[%CNST2]	;AS DSKSET COULD BE CALLED
	CALL	GETZ		;GET A ZERO OR THE FEATURE
	TXNE	A,ST%VMS	;VM SUPPORT
	TXO	F,FR.VMF	;YES FLAG IT
	SETZM	ONEJOB		;CLEAR SINGLE JOB FLAG
	SETZM	ONEPPN		;CLEAR SINGLE PPN FLAG
	SETOM	ONETTY		;CLEAR SINGLE TTY MODE
	SKIPE	DSKFLG		;SEE IF DISK MODE
	TLO	F,FL.GOD!FL.DSK	;YES--THEREFORE NO SECRETS

	MOVE	A,XFSFPP	;GET SOME SYSTEM STUFF
	PUSHJ	P,GETZ		;LIKE FAILSAFE PPN
	SKIPN	A
	MOVE	A,[1,,2]
	MOVEM	A,FSFPPN
	MOVE	A,XPTYCN	;ALSO PTY POINTER
	PUSHJ	P,GETZ
	HLRZM	A,PTYOFS
	ADD	A,PTYOFS
	HRRZM	A,PTYMAX
	HRRZ	A,PTYOFS	;COMPUTE LINE NUMBER OF THE CTY
	SOS	A		;IT IS USUALLY LAST REAL TTY BEFORE PTYS
	MOVEM	A,CTYLIN	;SO SAVE THAT
	MOVE	A,[%CNBCL]	;ASK FOR CURRENT CTY
	PUSHJ	P,GETZ		;GET IT
	SKIPE	A		;IGNORE IF OLD MONITOR (CAN'T BE LINE 0)
	MOVEM	A,CTYLIN	;SAVE THAT INSTEAD

	MOVE	A,XOPR		;GET NAME OF "OPR"
	PUSHJ	P,GETA
	MOVEM	A,OPR
	MOVE	A,XDATE		;GET DATE NOW
	PUSHJ	P,GETA
	MOVEM	A,DATE		;SAVE TODAY'S DATE
	MOVE	A,XSPPN		;GET SYS: PPN PAIR
	PUSHJ	P,GETZ
	SKIPE	A
	MOVEM	A,SYSPPN
	SETZM	CPKI10		;ZERO KI10 FLAG
	HRLOI	B,-2		;AND TEST WHETHER WE RUN ON A KI10
	AOBJN	B,KI10		;IT IS AKI10
	JRST	NOKI		;IT IS A KA10
KI10:	CAILE	A,50510		;BUT FORGET IF AN EARLY VERSION
	SETOM	CPKI10		;ELSE SET THE KI10 FLAG
NOKI:	HRLZI	B,LQTAB		;GET Q TABLE NAMES IF WE CAN
	SETZB	C,TIQ		;CLEAR INCASE OF REENTER
	SETZM	SLQ		;
	SETZM	EWQ		;
QTLP:	HRRZI	A,25
	HRL	A,B
	PUSHJ	P,GETZ
	JUMPE	A,QTLP1
	MOVEM	A,QTAB(B)
	MOVE	D,[POINT 12,QTAB(B)] ;BYTE PTR TO CODES
	HRLI	C,-3		;3 CODES PER WORD
QTLP2:	ILDB	A,D		;NEXT CODE
	CAIN	A,'SL'		;SKIP IF NOT SLEEP
	HRRZM	C,SLQ		;REMEMBER WAIT STATE CODE FOR SLEEP
	CAIN	A,'TI'		;SKIP IF NOT TI
	HRRZM	C,TIQ		;REMEMBER CODE FOR TI
	CAIN	A,'EW'		;"EW" STATE?
	HRRZM	C,EWQ		;YES, REMEMBER Q CODE
	AOBJN	C,QTLP2		;LOOP FOR ALL CODES IN THIS WORD
	AOBJN	B,QTLP
QTLP1:	MOVE	A,STATES	;GET STATES WORD
	TLNE	A,100		;NEW SCANNER SERVICE?
	TLO	F,FL.SCN	;YES. REMEMBER IT.
	SETZM	TNFRTY		;CLEAR 10/40N FLAG
	TLNN	A,(1B2)		;CHECK FOR LOGIN FEATURE
	SETOM	TNFRTY		;NONE--SET 10/40N FLAG
	MOVE	A,XSYSTP	;FIND OUT THE NAME OF "SYS:"
	PUSHJ	P,GETZ		;FROM THE MONITOR
	CAMN	A,[SIXBIT /DSK/]  ;IF "DSK:",
	MOVEI	A,0		; CLEAR FOR EASY TESTS LATER
	MOVEM	A,SYSTAP	;STORE AWAY
DNTSTO:	MOVE	A,XMEMNS	;GET CORE SPEED
	PUSHJ	P,GETZ
	SKIPE	A
	MOVEM	A,MEMNSP	;DON'T OVERRIDE IF UNDEFINED
	MOVX	A,%FTDS2	;GET 2ND DISK FEATURE WORD
	PUSHJ	P,GETZ		;GET IT OR ZERO
	SETOM	FTDUAL		;ASSUME DUAL PORTED SUPPORT
	TRNN	A,F%DUAL&777777	;TEST FOR IT
	SETZM	FTDUAL		;NO SUPPORT
	CAIN	WD,L.BDO	;LIST BUSY DEVICES ONLY?
	JRST	DEVQ		;YES
	CAIN	WD,L.HSO	;HELP?
	JRST	HELP		;YES
	CAIE	WD,L.DSO	;LIST DORMANT SEGS ONLY?
	CAIN	WD,L.SSO	;NO - LIST SHORT JOB STATUS ONLY?
	JRST	GA		;YES
	CAIE	WD,L.JSO	;LIST JOB STATUS INFO. ONLY?
	CAIN	WD,L.EJS	;NO-LIST ALL BUT JOB STATUS?
	JRST	GA		;YES
	CAIN	WD,L.FSO	;LIST FILESTRUCTURES ONLY?
	JRST	FS		;YES
	CAIN	WD,L.DPO	;LIST DISK PERFORMANCE ONLY?
	JRST	DP		;YES
	CAIN	WD,L.DSC	;DATA SET CONTROL ONLY?
	JRST	DSCDO		;YES
	CAIN	WD,L.ERR	;NON-DISK ERRORS ONLY?
	JRST	ERRPT		;YES
	CAIN	WD,L.GSS	;GENERAL SYSTEM STATISTICS ONLY?
	JRST	GA		;YES
	CAIN	WD,L.MYJ	;LIST JUST MY JOB?
	JRST	[MOVE	N,MYJOB
		 JRST	GOTJOB]
	CAIL	WD,"0"		;SEE IF SPECIFIC JOB
	CAILE	WD,"9"		;..
	JRST	CHKPPN		;NO--GO SEE IF PPN
	MOVEI	R,^D10		;SET FOR DECIMAL INPUT
	PUSHJ	P,GETRDX	;GET DECIMAL
GOTJOB:	JUMPE	N,HELPM		;ERROR IF JOB 0
	MOVEM	N,ONEJOB	;STORE REQUEST
	JRST	GOTJNK		;GO DO IT
CHKPPN:	SKIPN	TNFRTY		;NO PPNS IF 10/40
	CAIE	WD,"["		;SEE IF PPN
	JRST	CHKTTY		;NO--GO PROCESS
	MOVEI	R,10		;SET FOR OCTAL INPUT
	PUSHJ	P,GETRDC	;GET PROJECT
	PUSHJ	P,GETCHR	;GET BREAK CHAR IN WD
	  JRST	HELPM
	PUSHJ	P,CHKWLD	;SEE IF WILD CARD PPN
	SKIPGE	N		;USER TYPE [,...?
	HLRZ	N,ME		;YES, SUBSTITUTE OUR PROJECT
	HRLZ	A,N		;SAVE FOR LATER
	CAIE	WD,","		;MUST HAVE COMMA HERE
	JRST	HELPM
	PUSHJ	P,GETRDC	;GET PROGRAMMER
	PUSHJ	P,GETCHR	;GET BREAK CHARACTER
	  JFCL
	PUSHJ	P,CHKWLD	;SEE IF WILD CARD PPN
	SKIPGE	N		;USER TYPE [...,]?
	HRRZ	N,ME		;YES, USE OUR PROGRAMMER NUMBER
	HRR	A,N		;ADD TO RESULT
	SKIPN	A		;*,*?
	SETO	A,		;YES, REMEMBER THAT
	MOVEM	A,ONEPPN	;STORE FOR TESTS
	JRST	GOTCT2		;AND SKIP BREAK CHARACTER

CHKWLD:	CAIN	WD,L.WLD	;* TYPED?
	  JRST	[JUMPN N,HELPM	;IF *, CANNOT HAVE A NUMBER
		 PUSHJ P,GETCHR	;FLUSH THE *
		  JFCL
		 POPJ P,]	;ELSE RETURN
	SKIPE	N		;NUMBER SEEN?
	POPJ	P,		;YES, RETURN IT
	TLNN	F,FL.LGI	;USER LOGGED IN?
	JRST	HELPM		;NO, [,] IS ILLEGAL
	SETOM	N		;SET FLAG FOR CALLER
	POPJ	P,		;EVERYTHING OK, RETURN
CHKTTY:	TLNE	F,FL.SCN	;SEE IF NEW SCANNER SERVICE
	CAIE	WD,"#"		;YES--SEE IF TTY NUMBER
	JRST	CHKONC		;NO--GO PROCESS
	PUSHJ	P,GETCHR	;YES--GET WHICH TYPE
	  JRST	.+2		;END--DO SELF
	CAIN	WD,"."		;SEE IF SELF
	JRST	[SETOM	A
		 GETLCH	A
		 TRZ	A,.UXTRM	;CLEAR .UXTRM OFFSET
		 JRST	GOTCT1]
	CAIN	WD,"C"		;SEE IF CTY
	JRST	GOTCTY		;YES--GO SET IT UP
	MOVEI	R,^D8
	CAIN	WD,"P"		;SEE IF PSEUDO LINE
	JRST	[PUSHJ	P,GETRDC
		 ADD	N,PTYOFS
		 JRST	GOTTTY]
	CAIN	WD,"T"		;SEE IF TTY
	JRST	[PUSHJ	P,GETRDC
		 JRST	GOTTTY]
	PUSHJ	P,GETRDX	;MUST BE JUST TTY NUMBER
GOTTTY:	HRRZM	N,ONETTY	;STORE RESULT
	JRST	GOTJNK		;GO DO THE WORK
GOTCTY:	MOVE	A,CTYLIN	;GET LINE NUMBER OF THE CTY
GOTCT1:	HRRZM	A,ONETTY	;STORE AWAY
GOTCT2:	PUSHJ	P,GETCHR	;GET BREAK CHARACTER
	  JFCL			;IGNORE EOL
GOTJNK:	MOVEI	WD,"["		;SETUP JUNK
	JRST	GA		;GO DO IT

CHKSW:	TDNE	F,[XWD FL.GOD,FR.DPY!FR.CNT]	;DID HE TYPE ONLY ONE OF THE NEW COMMANDS?
	JRST	CLRGA		;YES, GIVE HIM THE DEFAULT
CHKONC:	SKIPN	ONCE		;NO VALID ARGS. SUPPLIED-HAVE WE BEEN THRU BEFORE?
	JRST	HACKQ		;YES-EXIT.
	CAIL	WD,40		;IS IT JUNK GRAPHIC?
	JRST	HELPM		;NO--TELL USER HOW TO GET HELP
CLRGA:	MOVEI	WD,0		;CLEAR WD FOR NORMAL O/P
	SUBTTL	READ TTY STATUS DATA
GA:	MOVE	A,XSEGPT
	PUSHJ	P,GETA
	MOVEM	A,SEGPTR
	HLRE	B,A
	MOVNM	B,SEGN
	HRRZM	A,JOBN
	ADD	A,SEGN
	HRRZM	A,BOTH
	HRRZ	B,FREE
	MOVEM	B,ZERLOW
	MOVE	A,JOBN		;GET NUMBER OF JOBS
	IMULI	A,3		;NEED THAT MANY WORDS ON NEXT PAGE
	ADDI	B,(A)		;COMPUTE HIGHEST ADDRESS NEEDED
	HRRZ	A,.JBREL
	CAIL	A,(B)		;SEE IF .DVIOS, .TTY, AND .TTYN TABLES WILL EXCEED CORE
	JRST	SYS0A
	CORE	B,
	  JRST	NOCOR		;TROUBLE-PRINT MESSAGE & QUIT
	HRRZ	A,.JBREL
SYS0A:	MOVEM	A,ZERHGH
	SETZM	@ZERLOW
	MOVE	A,ZERLOW
	HRLS	A
	ADDI	A,1
	BLT	A,@ZERHGH
	MOVE	A,FREE
	HRRM	A,.DVIOS
	MOVE	A,JOBN
	ADDB	A,FREE
	HRRM	A,.TTY
	MOVE	A,JOBN		;GET NUMBER OF JOBS
	ADDB	A,FREE		;ADVANCE POINTER
	HRRM	A,.TTYN		;SETUP TABLE OF LINE NUMBERS
	MOVE	A,JOBN		;GET NUMBER OF JOBS
	ADDB	A,FREE		;AND UPDATE THE FREE BARRIER
	SETOM	(A)		;JOB 0 IS ON NO LINE
	MOVSI	D,10		;TABLE INDEX FOR TTYTAB, ENTRY #0
SYS0L:	MOVS	B,D
	TLNN	F,FL.DSK	;READING FROM DISK?
	SKIPE	SPYFLG		;OR PRIVILEGED?
	JRST	SYST03		;YES, USE TTYTAB LOGIC
	HRRZ	J,D		;GET JOB NUMBER
	CAML	J,JOBN		;CHECK FOR THE END
	JRST	SYS0X		;END OF TY DATA
	JUMPE	A,SYST02	;0 IS DETACHED!!
	MOVE	A,J		;GET JOB NUMBER
	TRMNO.	A,		;GET I/O INDEX
	  JRST	[SETZ A,	;MAKE IT DETACHED
		JRST SYST02]	;AND FILL IN NAME
	TRZ	A,.UXTRM	;CLEAR TTY UDX BIT
	CAMN	A,CTYLIN	;IS IT CTY?
	JRST	SYST01		;YES THEN NAME IS KNOWN
	TRO	A,.UXTRM	;PUT THE BIT BACK
	DEVNAM	A,		;GET NAME
	  SETZM	A		;DETACHED IF AN ERROR
	SKIPA			;SKIP CTY NAME
SYST01:	MOVSI	A,(SIXBIT /CTY/);GET REAL NAME
SYST02:	MOVEM	A,@.TTY		;REMEBER NAME
	JRST	TTYCN1		;SKIP TTYTAB LOGIC
SYST03:	PUSHJ	P,GETTB		;GET NEXT ENTRY
	  JRST	SYS0X		;END OF TTYTAB
	LDB	J,TPCJOB	;IF OLD SCNSRF, GET JOB NO
	TLNE	F,FL.SCN	;NEW SCNSER?
	MOVEI	J,0(D)		;YES. DIFFERENT LAYOUT. GET JOB NO.
	SETZM	@.TTY		;CLEAR NAME
	TLZ	B,-1
	JUMPE	B,SYS0Z
	MOVEI	C,DV.NAM(B)	;GET TTY NAME
	PUSHJ	P,PEEKC		;..
	MOVEM	C,@.TTY		;STORE IN TABLE
	MOVEI	C,DV.IOS(B)	;GET IOS
	PUSHJ	P,PEEKC
	MOVEM	C,@.DVIOS
	TLNN	F,FL.SCN	;WHICH SCANNER LAYOUT?
	JRST	SYS0Z		;OLD FORGET IT
	MOVE	A,XDDBLD	;GET CODE FOR LDB LINK
	PUSHJ	P,GETZ		;RETURN ZERO IF NOT IMPLEMENTED
	JUMPE	A,SYS0L0	;IN THAT CASE TAKE OLD NUMERIC LOGIC
	MOVE	C,B		;GET DDB ADDRESS
	ADDI	C,(A)		;AND ADD IN  LDB LINK OFFSET
	JRST	SYS0L1		;AND SKIP NUMERIC LOGIC
SYS0L0:	MOVEI	C,DDBLDB(B)	;NEW. SEE IF DETACHED.
	SKIPE	A,MONVER	;SEE IF OLD MONITOR
	ADDI	C,3		;NO, 5.03 OR LATER
	TLZ	A,-1		;CLEAR JUNK
	CAILE	A,50430		;5.05 OR LATER?
	ADDI	C,1		;ONE MORE WORD IN LDB
	CAILE	A,70207		;703?
	ADDI	C,1		;YES, EVEN 1 MORE
SYS0L1:	PUSHJ	P,PEEKC		;..
	TRNN	C,-1		;ANY LDB LINK?
	HRLM	C,@.TTY		;CLEAR LEFT HALF
TTYCN1:	MOVE	A,[POINT 6,@.TTY,17]
	MOVEI	B,0		;GET TTY NUMBER
TTYCN2:	ILDB	C,A		;GET NEXT DIGIT
	SUBI	C,'0'		;CONVERT TO BINARY
	JUMPL	C,TTYCN3	;EXIT. WHEN DONE
	LSH	B,3		;ADVANCE RESULT
	IOR	B,C		;INCLUDE THIS DIGIT
	TLNE	A,(77B5)	;SEE IF AT END OF WORD
	JRST	TTYCN2		;NO--LOOP FOR MORE
TTYCN3:	MOVEI	A,-1		;SET RIGHT HALF MASK
	TDNN	A,@.TTY		;SEE IF RH=0 (IE, CTY)
	MOVE	B,CTYLIN	;YES--CHANGE TO CTY LINE NUMBER
	MOVEM	B,@.TTYN	;STORE LINE NUMBER AWAY
	TSNN	A,@.TTY		;SEE IF DETACHED
	JRST	SYS0Z		;YES--SKIP PTY TEST
	CAML	B,PTYOFS	;SEE IF WITHIN THE PTY RANGE
	CAML	B,PTYMAX	;..
	JRST	SYS0Z		;NO--LEAVE ALONE
	SUB	B,PTYOFS	;YES--REMOVE THE OFFSET
	HRLI	B,'PTY'		;SET FLAG FOR LATER
	MOVEM	B,@.TTY		;AND STORE

SYS0Z:	AOJA	D,SYS0L
SYS0X:	MOVE	J,MYJOB		;SEE IF WE ARE AT AN OPERATOR TTY
	MOVE	A,@.TTY
	CAME	A,[SIXBIT /CTY/]	;CHECK CTY
	CAMN	A,OPR		;CHECK OPR
	TLO	F,FL.GOD	;YES--SET GOD FLAG


	SUBTTL	READ JOB AND SEGMENT STATUS
	MOVE	B,[XWD -NTAB,TABPTR]
	HRLI	A,.GTSWP
	MOVE	C,MONVER
	CAILE	C,70207
	HRLI	A,.GTIMI
	TLO	A,SIGN
	HLLM	A,TABPTR+2
INIT1:	MOVE	C,(B)
	HRRZ	J,BOTH
	TLZN	C,SIGN
	HRRZ	J,JOBN
	MOVE	A,FREE
	HRRM	A,(C)		;GENERATE ADDRESS IN TABLE POINTER
	ADDI	A,(J)		;PROTECT TABLE 
	HRRZM	A,FREE		;UPDATE FREE FENCE FOR NEXT ROUND
	CAMG	A,.JBREL	;DO WE NEED MORE CORE?
	JRST	INIT0		;NO THERE IS STILL ENOUGH
	CORE	A,		;GET CORE
	JRST	NOCOR		;IF IT IS NOT THERE THEN TOO BAD
INIT0:	MOVNS	J
	HRLZS	J
INIT2:	MOVS	A,C
	HRLI	A,(J)
	PUSHJ	P,GETZ
	MOVEM	A,@0(C)
	AOBJN	J,INIT2
	AOBJN	B,INIT1
	MOVE	A,FREE
	HRRM	A,.SEGCT	;
	ADD	A,SEGN
	HRRZM	A,FREE
	CAMG	A,.JBREL	;IS THERE SILL ENOUGH CORE
	JRST	INIT3		;YES
	CORE	A,		;GET IT OR
	JRST	NOCOR		;JUST DIE
INIT3:	MOVE	A,.SEGCT
	HRLS	A
	SETZM	(A)
	ADDI	A,1
	BLT	A,@FREE
	MOVE	A,[%NSMXM]	;MAX VALUE MAXMAX
	PUSHJ	P,GETZ		;GO GET IT OR ZERO
	SKIPN	A		;NON-ZERO?
	BOMB	(GETTAB ERROR <%NSMXM>)	;NO, DIE
	SKIPE	CPKI10		;RUNNING ON A KI10.GT.50510
	JRST	INIT6		;YES GO AWAY
	ADDI	A,1777		;ROUND UP
	TRZ	A,1777
INIT6:	MOVEM	A,MAXMAX	;TOTAL MAX USER CORE AVAILABLE
	CAIN	WD,L.DSO	;LIST DORMANT SEGS. ONLY?
	JRST	DODORM		;YES - GO DO IT
	CAIN	WD,L.SSO	;SHORT STATUS ONLY?
	JRST	SYS4A		;YES
	SKIPN	ONEJOB		;SEE IF CROSS SECTION
	SKIPE	ONEPPN		;..
	JRST	SYS4A		;YES--SKIP HEADERS, ETC.
	SKIPL	ONETTY		;..
	JRST	SYS4A		;..
	SUBTTL	PRINT GENERAL SYSTEM STATUS
	PUSHJ	P,THISIS	;OUTPUT NAME OF SYSTEM, DATE AND TIME
	MOVE	A,STATES	;REPORT LOGIN AVAILABILITY
	MOVEI	M,[ASCIZ /No LOGINs allowed
/]
	TRNN	A,1
	MOVEI	M,[ASCIZ /No remote LOGINs allowed
/]
	TRNE	A,3
	PUSHJ	P,MSG
	MOVEI	M,[ASCIZ /Batch only
/]
	TRNE	A,4		;CHECK BATCH BIT
	PUSHJ	P,MSG
	MOVEI	M,[ASCIZ /Unspooling allowed
/]
	TRNE	A,200		;CHECK SPOOL CONTROL
	PUSHJ	P,MSG
	MOVEI	M,[ASCIZ /No operator on duty
/]
	TRNE	A,400		;**[8] IS OPERATOR THERE
	CALL	MSG		;**[8] (NO) TELL IT
	MOVE	A,XSYKTM	;GET MINUTES TO SYSTEM KILL
	PUSHJ	P,GETZ		;FROM THE MONITOR
	MOVEI	M,[ASCIZ/Timesharing is over
/]				;
	SKIPGE	A		;IS TIMESHARING OVER ?
	PUSHJ	P,MSG		;YES--TELL USER ABOUT IT
	SKIPLE	N,A		;SEE IF SET
	CAILE	A,^D24*^D60	;YES--SEE IF WITHIN 24 HRS.
	JRST	GENSTS		;NO--SKIP MESSAGE
	MOVEI	M,[ASCIZ /Timesharing ends in /]
	IDIVI	N,^D60		;YES--GET HOURS
	PUSH	P,N1		;SAVE MINUTES
	JUMPE	N,KSYNHR	;JUMP IF NO HOURS LEFT
	PUSHJ	P,MSGDEC	;TELL USER HOW LONG
	MOVEI	M,[ASCIZ / hrs. /]
KSYNHR:	POP	P,N		;RECOVER MINUTES
	PUSHJ	P,MSGDEC	;OUTPUT IT
	MOVEI	M,[ASCIZ / mins.  (at /]
	PUSHJ	P,MSG		;AND WHEN THAT IS
	IMULI	A,^D60		;CONVERT TO SECS.
	IMUL	A,TCKSEC	;AND THEN JIFFIES
	ADD	A,NOW		;ADD CURRENT TIME
	IDIV	A,TCKSEC	;CONVERT TO SECS
	IDIVI	A,^D60		;CONVERT TO MINUTES
	IMUL	A,TCKSEC	;BACK TO SECONDS
	IMULI	A,^D60		;BACK TO MINUTES,TO DROP SECONDS
	MOVEI	B,^D24*^D3600	;GET NUMBER OF SECS. IN A DAY
	IMUL	B,TCKSEC	;CONVERT TO JIFFIES
	CAML	A,B		;SEE IF TOMORROW
	SUB	A,B		;YES--BACK OFF CLOCK
	IFGE  FTAMPM,<
	TRO	F,FR.DAY	;REQUEST AM/PM HACK
>
	PUSHJ	P,TCKTIS	;OUTPUT TIME OF DAY
	MOVEI	M,[ASCIZ /)
/]
	PUSHJ	P,MSG		;FINISH MESSAGE
GENSTS:	PUSHJ	P,CRLF		;ISOLATE CPU TIMES FROM HEADER,KSYS, ETC.
	MOVE	A,[%CNCPU]	;[326]NUMBER OF CPUS
	PUSHJ	P,FGETTB	;[326]GET THAT
	  SETZ	A,
	SOJLE	A,GENST0	;[326]DON'T OUTPUT IF ONLY 1 CPU
	MOVEI	M,[ASCIZ /System Uptime /] ;[326]
	PUSHJ	P,MSG		;[326]OUTPUT
	MOVE	A,[%CNSUP]	;[326]GET SYSTEM UPTIME
	PUSHJ	P,FGETTB	;[326] ..
	  JFCL			;[326]
	PUSHJ	P,TCKTIS	;[326]OUTPUT THAT
	PUSHJ	P,CRLF		;[326]AND END THE LINE
GENST0:	MOVN	D,NCPCNF	;[326]FORM AOBJN
	HRLZS	D
	TLC	D,-1		;FIND OUT IF ONLY 1 IN CONFIGURATION
	TLCN	D,-1
	JRST	GENST2		;SKIP OUTPUT OF "CPUn"
GENST1:	MOVEI	M,[ASCIZ/CPU/]	;HEADER
	PUSHJ	P,MSG
	HRRZ	N,D		;GET CPU NUMBER
	PUSHJ	P,DECPRT	;OUTPUT IT
	PUSHJ	P,SPACE		;ALIGN OUTPUT
GENST2:	HRRZ	A,D		;GET CPU #
	LSH	A,1		;CPU*2 FOR GETTAB
	ADD	A,[%CCOKP]	;CPU OK WORD
	PUSHJ	P,GETZ		;GO GET IT
	MOVE	C,A		;SAVE ANSWER
	HRRZ	A,D		;GET CPU #
	LSH	A,1		;CPU*2 FOR GETTAB
	ADD	A,[%CVRUN]	;RUNNABILITY FLAGS
	PUSHJ	P,GETZ		;GET THEM
	TXNN	A,CV%RUN	;SIGN BIT ON SAYS NOT RUNNING BY OPR CHOICE
	JUMPLE	C,RUNSTS	;RUNNING?
	MOVEI	M,[ASCIZ/Not Running/]	;NO
	PUSHJ	P,MSG		;OUTPUT MSG
	JUMPE	A,GENST3	;GO IF IT JUST STOPPED
	TXNE	A,CV%SPD	;SUSPENDED (ONLY MAKES SENSE IF THIS IS A CRASH)
	JRST	[MOVEI M,[ASCIZ/ (Suspended)/]
		 PUSHJ P,MSG	;PRINT THAT
		 JRST GENST3]	;NEXT CPU
	TXNN	A,CV%RMV+CV%DET	;JUST "SET NO RUN"?
	JRST	[MOVEI M,[ASCIZ/ (Set no run)/]
		 PUSHJ P,MSG	;OUTPUT THAT
		 JRST GENST3]	;AND GO ON TO THE NEXT CPU
	TXNE	A,CV%RMV	;REMOVED?
	JRST	[MOVEI M,[ASCIZ/ (Removed)/]
		 PUSHJ P,MSG	;OUTPUT THAT
		 JRST GENST3]	;AND GO ON TO THE NEXT CPU
	MOVEI	M,[ASCIZ/ (Detached)/]
	PUSHJ	P,MSG		;OUTPUT THAT
	JRST	GENST3		;NEXT CPU
RUNSTS:	MOVEI	M,[ASCIZ/Incremental /] ;IN CASE THIS IS "C"
	TRNE	F,FR.END	;NOT FIRST TIME?
	PUSHJ	P,MSG		;NOT FIRST, TYPE IT
	MOVEI	M,[ASCIZ /Uptime /]
	PUSHJ	P,MSG
	TRNE	F,FR.END	;FIRST TIME?
	  SKIPA	A,DIFTIM(D)	;NO, GET DIFF UPTIME
	MOVE	A,CPNUPT(D)	;PICK UP UPTIME
	PUSH	P,A		;SAVE WHAT WE TYPE
	CALL	TCKTIS		;TYPE IT
	POP	P,A		;GET VALUE OF UPTIME
	JUMPE	A,GENST3	;SKIP REST IF UPTIME OR INCREMENTAL IS ZERO
	MOVEI	M,[ASCIZ /, /]
	PUSHJ	P,MSG
	MOVE	N,CPNNUL(D)
	SUB	N,OLDNUL(D)	;USE DIFFERENTIAL NULL TIME
	IMULI	N,^D100
	MOVEM	N,TEMP(D)	;SAVE FOR COMPUTING IDLE & LOST TIME
	TRNE	F,FR.END	;FIRST TIME?
	  SKIPA	B,DIFTIM(D)	;NO, GET DIF UPTIME.
	MOVE	B,CPNUPT(D)	;YES, GET CPU UPTIME
	IDIV	N,B		;COMPUTE % NULL TIME
	MOVEM	N,TEMP1		;SAVE %NULL TIME
	PUSHJ	P,DECPRT		;TYPE NULL TIME FOR EACH CPU
	MOVEI	M,[ASCIZ /% Null time = /]
	PUSHJ	P,MSG
	MOVE	N,CPNLST(D)
	SUB	N,OLDLOS(D)	;GET DIFFERENTIAL LOST TIME
	IMUL	N,[EXP -^D100]
	ADD	N,TEMP(D)
	TRNE	F,FR.END	;FIRST TIME?
	  SKIPA	B,DIFTIM(D)	;NO, GET DIF UPTIME.
	MOVE	B,CPNUPT(D)	;YES, GET CPU UPTIME
	IDIV	N,B		;COMPUTE % LOST TIME
	MOVEM	N,TEMP(D)	;SAVE %IDLE TO GET %LOST LATER
	PUSHJ	P,DECPRT	;TYPE IDLE TIME FOR EACH CPU
	MOVEI	M,[ASCIZ /% Idle + /]
	PUSHJ	P,MSG
	MOVE	N,TEMP1		;GET %NULL TIME
	SUB	N,TEMP(D)	;SUBTRACT %IDLE TIME
	PUSHJ	P,DECPRT	;TYPE LOST TIME FOR EACH CPU
	MOVEI	M,[ASCIZ /% Lost, /]
	PUSHJ	P,MSG
	MOVE	N,CPNOHT(D)	;GET CURRENT OHT
	SUB	N,OLDOHT(D)	;COMPUTE INCREMENTAL OVERHEAD
	IMULI	N,^D100
	TRNE	F,FR.END	;FIRST TIME?
	  SKIPA	B,DIFTIM(D)	;NO, GET INCREMENTAL UPTIME
	MOVE	B,CPNUPT(D)	;YES, GET CPU UPTIME
	IDIV	N,B		;COMPUTE %OVERHEAD
	PUSHJ	P,DECPRT	;PRINT IT
	MOVEI	M,[ASCIZ/% Overhead/]
	PUSHJ	P,MSG
GENST3:	PUSHJ	P,CRLF
	AOBJN	D,GENST1	;TYPEOUT FOR ALL CPUS
	MOVE	D,NCPCNF	;GET NUMBER OF CPUS (LINES) JUST OUTPUT
	CAILE	D,1		;ONLY 1 LINE
	PUSHJ	P,CRLF		;NO, SEPARATE OUTPUT A LITTLE BETTER

PRSHUF:	TLNN	F,FL.DSK!FL.LPT	;SEE IF OPERATOR WORK
	JRST	PRSHF1		;NO--CUT OUT JUNK TO SAVE TIME
	MOVEI	M,[ASCIZ/Incremental /]	;IN CASE THIS IS "C"
	TRNE	F,FR.END	;NOT FIRST TIME?
	PUSHJ	P,MSG		;NOT FIRST, TYPE IT
	MOVEI	M,[ASCIZ /Shuffle time = /]
	MOVE	A,XSHF		;GET WORDS SHUFFLED
	PUSHJ	P,GETA
	MOVN	B,OLDSFL	;GET THE LAST SHUFFLE
	MOVEM	A,OLDSFL	;SAVE THIS SHUFFLE THERE
	ADD	A,B		;USE DIFFERENTIAL SHUFFLE
	PUSHJ	P,MEMPR		;PRINT AS TIME
	MOVEI	M,[ASCIZ /,  Core Zeroing time = /]
	MOVE	A,XZCOR		;GET WORDS ZEROED
	PUSHJ	P,GETA
	MOVN	B,OLDZRO	;GET THE LAST ZEROED
	MOVEM	A,OLDZRO	;SAVE THIS ZEROED THERE
	ADD	A,B		;USE DIFFERENTIAL ZEROED
	PUSHJ	P,MEMPR		;PRINT AS TIME
	PUSHJ 	P,CRLF
	MOVEI	M,[ASCIZ/Incr avg response time:/]
	TRNN	F,FR.END	;PRINT ON 2ND,3RD,... PASS
	MOVEI	M,[ASCIZ /Average response time: /]
	PUSHJ	P,MSG		;ANNOUNCE RESPONSE TIME
	MOVE	A,[%FTDEB]	;[EDIT 2] GET OPTIONS
	CALL	GETZ		;[EDIT 2] ZERO IF NOT THERE
	TXNN	A,F%RSP		;[EDIT 2] THE FANCY STUFF?
	JRST	PRSHU0		;[EDIT 2] DEFINITELY NOT
	MOVE	A,MONVER	;IS MONITOR .GT 50500?
	CAIL	A,50500
	JRST	GENRSP		;YES, HANDLE FANCY RESPONSE TABLES
PRSHU0:	TRNE	F,FR.END	;FIRST PASS?
	PUSHJ	P,SPACE		;NO, PRINT EXTRA SPACE
	MOVE	A,XRNUM
	PUSHJ	P,GETA
	EXCH	A,OLDNUM	;SWAP OLD AND NEW TOTAL RESPONSES
	SUB	A,OLDNUM	;-(NUMBER OF RESPONSES)
	MOVMM	A,TEMP		;+NUMBER OF RESPONSES THIS INTERVAL
	MOVE	A,XSRSP
	PUSHJ	P,GETA
	EXCH	A,OLDRSP	;SWAP NEW AND OLD JIFFIES RESPONDING
	SUB	A,OLDRSP	;-(JIFFIES SPENT RESPNDING)
	MOVMS	A
	MOVEM	A,TEMP1
	IDIV	A,TEMP		;JIFFIES PER RESPONSE THIS INTERVAL
	PUSHJ	P,TIMPR		;PRINT TIME IN SECONDS
	MOVEI	M,[ASCIZ / sec (/]
	PUSHJ	P,MSG
	MOVE	A,TEMP1
	PUSHJ	P,TIMPR
	MOVEI	M,[ASCIZ^ sec/^]
	MOVE	N,TEMP
	PUSHJ	P,MSGDEC
	MOVEI	M,[ASCIZ/ resp.)/]
	PUSHJ	P,MSG
	PUSHJ	P,CRLF
	JRST	PRSHF1		;GO DO JOB STUFF
;HERE TO PRINT RESPONSE MEASURES

GENRSP:	SETZM	CPU		;TO ALIGN HEADERS
	MOVEI	M,[ASCIZ@	Mean//St.Dev.@]
	PUSHJ	P,MSG
	PUSHJ	P,STAB		;ALIGN NEXT HEADER
	MOVEI	M,[ASCIZ@Resp/Min	@]
	PUSHJ	P,MSG
	MOVE	A,NCPCNF	;NUMBER OF CPUS TO REPORT
	CAILE	A,2		;IF 1 OR 2, HEADERS WILL LINE UP
	PUSHJ	P,TAB		;FOR 3 OR 4, ADD ANOTHER TAB
	MOVEI	M,[ASCIZ/# of RESP
/]
	PUSHJ	P,MSG
	HRREI	A,-4		;4 TYPES OF RESPONSE
	SETZM	D		;RELATIVE SUBTABLE POINTER
RSP:	MOVEM	A,RSPCNT	;SAVE RESPONSE TYPE COUNTER
	MOVE	M,RSPMSG+4(A)	;GET MSG FOR THIS RESPONSE TYPE
	SETZM	CPU		;SET FOR CPU0

;LOOP TO PRINT RESPONSE FOR EACH CPU

RSPLP1:	MOVE	A,D		;GET TYPE INDEX
	ADDI	A,%CVRNO	;NO. OF RESPONSES SINCE STARTUP
	PUSHJ	P,GETRS0	;GET FROM MONITOR REL TABLE
	  JRST RSP1C		;NOT PRESENT FOR THIS CPU
	PUSHJ	P,GETDIF	;GET INCREMENTAL VALUE
	PUSH	P,A		;SAVE TOTAL NO. OF RESPONSES

	MOVE	A,D		;GET TYPE INDEX
	ADDI	A,%CVRSO	;SUM OF RESPONSE TIMES IN JIFFIES
	PUSHJ	P,GETRSP	;GET FROM MONITOR REL TABLE
	  JRST	RSP1B		;NOT PRESENT FOR THIS CPU
	PUSHJ	P,GETDIF	;GET INCREMENTAL VALUE
	MOVE	N,A		;MOVE TO N FOR PNTSEC ROUTINE
	MUL	A,A		;GET SQUARE OF SUM OF RESPONSES
	PUSH	P,A		;SAVE FOR STANDARD DEV
	PUSH	P,B		;..
	IDIV	N,-2(P)		;AVERAGE RSP=SUM/NUMBER(IN JIFFIES)
	PUSHJ	P,PNTSEC	;PRINT IN SECONDS + TENTHS
	POP	P,N1		;RESTORE SQUARE OF SUM
	POP	P,N		;..
	MOVEI	M,[ASCIZ @//@]	;SEPARATE MEAN FROM STANDARD DEVIATION
	PUSHJ	P,MSG

	MOVE	A,D		;GET TYPE INDEX
	ADDI	A,%CVRLO	;GET LOW SUM OF SQUARES OF RESPONSES
	PUSHJ	P,GETRSP	;GET FROM MONITOR REL TABLE
	  JRST	RSP1B		;NOT THERE
	PUSHJ	P,GETDIF	;GET INCREMENTAL VALUE
	MOVE	B,A		;POSITION FOR MULT.
	MOVE	A,RSPIDX	;GET INDEX TO DIFRSP TABLE
	MOVEM	A,RSPIX1	;SAVE IT (NEED TO DO DOUBLE
				;PRECISION SUBTRACT)

	MOVE	A,D		;GET TYPE INDEX
	ADDI	A,%CVRHO	;ASK FOR HIGH SUM OF SQUARES
	PUSHJ	P,GETRSP	;FROM MONITOR
	  JRST	RSP1B		;(STRANGE!)
	PUSHJ	P,GETDIF	;GET INCREMENTAL VALUE
	SKIPL	B		;IS DIFFERENTIAL LOW ORDER PART NEGATIVE?
	JRST	RSPL1A		;NO, OK
				;YES, FUDGE DOUBLE PRECISION
	PUSH	P,N		;SAVE N
	MOVE	N,RSPIX1	;GET INDEX TO DIFRSP TABLE
	SETCAB	B,DIFRSP(N)	;COMPLEMENT LOW ORDER HALF
	MOVE	N,RSPIDX	;GET INDEX TO HIGH ORDER HALF
	SOS	A,DIFRSP(N)	;BORROW 1
	POP	P,N		;RESTORE N
RSPL1A:	MUL	B,(P)		;MULT BY NUMBER
	IMUL	A,(P)		;BOTH HALVES
	ADD	A,B		;INCLUDE CROSS CARRY
	MOVE	B,C		;POSITION LOW HALF
	SETCMM	N		;COMPLEMENT SQUARE OF SUM
	MOVNS	N1		;..
	SKIPN	N1		;HANDLE CARRY
	ADDI	N,1		;YES
	TLZ	N1,(1B0)	;GOT (N,N1)=-SQ.SUM
	ADD	B,N1		;ADD TO N*SUM SQ.
	ADD	A,N		;..
	TLZE	B,(1B0)		;SEE IF CARRY
	ADDI	A,1		;YES. GOT (A,B)=N*SUM SQ.-SQ.SUM
	PUSHJ	P,ISQRT		;COMPUTE N=SQRT((A,B))
	IDIV	N,(P)		;DIVIDE BY NUMBER; N=STD.DEV
	PUSHJ	P,PNTSEC	;PRINT AS SECONDS PLUS TENTHS
	POP	P,A		;REMOVE NO.
	AOS	CPU		;STEP TO NEXT CPU
	JRST	RSPLP1		;GO SEE IF EXISTS	
;HERE WHEN PRINTED MEAN AND STANDARD DEV FOR ALL CPUS
RSP1B:	POP	P,A		;REMOVE NUMBER
RSP1C:	PUSHJ	P,TAB		;AND A SECOND ONE
	MOVE	A,DIFTIM	;UP TIME IN JIFFIES
	IDIV	A,TCKSEC	;NO. OF SECONDS UP
	IDIVI	A,^D60		;NO. OF MINUTES UP
	MOVEM	A,TEMP		;STORE FOR CMPCNA
	SETZM	CPU		;START WITH CPU0
RSPLP2:	MOVE	A,D		;GET TYPE INDEX
	ADDI	A,%CVRNO	;NO. OF RESPONSES FOR THIS CPU
	PUSHJ	P,GETRS0	;CALL GETRSP TO SET UP INDEX
	  JRST	RSP2		;NOT THERE
	MOVE	A,RSPIDX	;DIDN'T REALLY WANT NEW VALUE
	MOVE	A,DIFRSP(A)	;GET INCREMENTAL VALUE
	PUSHJ	P,CMPDFA	;PRINT NO. RESPONSES PER MIN
	AOS	CPU		;STEP TO NEXT CPU
	JRST	RSPLP2		;TRY NEXT CPU

;HERE TO PRINT NUMBER OF RESPONSES FOR THIS TYPE

RSP2:	PUSHJ	P,TAB		;ALIGN OUTPUT
	PUSHJ	P,TAB		;...
	SETZM	CPU		;START WITH CPU0
RSPLP3:	MOVE	A,D		;GET TYPE INDEX
	ADDI	A,%CVRNO	;NO. OF RESPONSES FOR THIS CPU
	PUSHJ	P,GETRS0	;CALL GETRSP TO SET UP INDEX
	  JRST RSP3		;NOT THERE
	MOVE	A,RSPIDX	;DIDN'T REALLY WANT NEW VALUE
	MOVE	N,DIFRSP(A)	;GET INCREMENTAL VALUE
	PUSHJ	P,DECPRT	;PRINT # OF RESPONSES
	AOS	CPU		;FIND OUT IF ANY MORE CPU'S
	JRST	RSPLP3		;TRY NEXT CPU

;HERE WHEN PRINTED FOR ALL CPUS

RSP3:	PUSHJ	P,CRLF
	ADDI	D,4		;STEP TO NEXT RESPONSE TYPE
	MOVE	A,RSPCNT
	AOJL	A,RSP		;PROCESS NEXT TYPE (IF ANY)
PRSHF1:	SETZB	N,B		;COUNT JOBS AND LOGGED IN JOBS
	SETZB	C,D		;AND DETACHED JOBS
	MOVE	J,JOBN
CTJOB:	SOJLE	J,CTJOB1	;COUNT, PRINT IF DONE
	MOVE	A,@.STS
	TLNN	A,JNA		;SEE IF JOB NUMBER ASSIGNED
	JRST	CTJOB		;NO--DON'T COUNT
	AOS	N		;YES
	TLNE	A,JLOG		;SEE IF LOGGED IN
	AOS	B		;YES
	MOVE	A,@.TTY
	TLNN	A,-1		;SEE IF DETACHED
	AOS	C		;YES
	JRST	CTJOB		;LOOP

CTJOB1:	MOVEM	N,NUMJOB	;SAVE NUMBER OF ACTIVE JOBS
	PUSHJ	P,DECPRT	;PRINT NUMBER OF JOBS IN USE
	MOVEI	M,[ASCIZ / Jobs in use out of /]
	MOVE	N,JOBN		;PRINT NO. IN SYSTEM
	SUBI	N,1		;ALLOW FOR NULL JOB
	PUSHJ	P,MSGDEC
	MOVEI	M,[ASCIZ /.  /]
	SKIPE	TNFRTY		;SEE IF 10/40N
	JRST	PRDET		;YES--DON'T COUNT LOGINS
	MOVE	N,B		;PRINT NO. LOGGED IN
	MOVEM	B,LOGDIN	;SAVE FOR  KSEC COMPUTATION
	PUSHJ	P,MSGDEC
	MOVEI	M,[ASCIZ / logged in/]
	PUSHJ	P,MSG
	MOVE	A,XLGMAX	;GET LOGMAX
	PUSHJ	P,GETZ
	JUMPE	A,CTJOB2	;NO LOGMAX
	MOVE	N,A		;COPY LOGMAX
	AOS	A		;SEE IF LOGMAX = ALL JOBS
	CAMN	A,JOBN		;IF SO, DON'T BOTHER PRINTING
	JRST	CTJOB2
	MOVEI	M,[ASCIZ/ (LOGMAX of /]
	PUSHJ	P,MSGDEC	;OUTPUT LOGMAX
	MOVEI	CH,")"		;CLOSE MESSAGE
	PUSHJ	P,TYO		;OUTPUT THAT
CTJOB2:	MOVEI	M,[ASCIZ/, /]	;PRETTY UP THE OUTPUT
PRDET:	MOVE	N,C		;PRINT NO. DETACHED
	PUSHJ	P,MSGDEC
	MOVEI	M,[ASCIZ / detached./]
	PUSHJ	P,MSG
	SUBTTL	PRINT JOB STATUS
PRJBST:	PUSHJ	P,CRLF
	CAIE	WD,L.EJS	;LIST ALL BUT JOB STATUS?
	CAIN	WD,L.GSS	;ONLY GENERAL SYSTEM STATISTICS?
	TLOA	WD,SIGN		;YES
	JRST	SSTATS		;NO
	JRST	SYS4A
SSTATS:	MOVEI	M,[ASCIZ /
Job    Who     Line#	What   Size(K)	State	/]
	SKIPE	CPKI10		;IS IT A KA10?
	MOVEI	M,[ASCIZ /
Job    Who     Line#	What   Size(P)	State	/]
	SKIPE	TNFRTY		;SEE IF 10/40N
	MOVEI	M,[ASCIZ /
Job	Line#	What   Size(K)	State	/]
	TRNE	F,FR.USR	;LIST USER NAMES?
	MOVEI	M,[ASCIZ /
Job    Who       User          Line#	What   Size(P)	State	/]
	PUSHJ	P,MSG
	MOVEI	M,[ASCIZ/% of CPU KCsecs

/]
	TRNN	F,FR.END	;FIRST PASS?
	MOVEI	M,[ASCIZ/Run Time

/]
	PUSHJ	P,MSG		;FINISH THE HEADING EITHER WAY
SYS4A:	MOVN	J,JOBN
	HRLZS	J
	SETZM	TOTKCT		;CLEAR TOTAL KILO=CORE SECS
	SETZM	CORUSE		;CLEAR TOTAL VIRT. CORE USED
	SETZM	DSKUSE		;CLEAR TOTAL SWAPPING SPACE USED
	SETZM	ACTUSE		;CLEAR COUNT OF ACTIVE SWAPPING SPACE USED
	SETZM	LOWUSE		;CLEAR COUNT OF LOW SEGMENT SIZES
	SETZM	PTYS		;CLEAR COUNT OF PTY JOBS
	SETZM	SEGFLG		;CLEAR SEGMENT FLAG
	TLZ	F,FL.NUM!FL.NST!FL.EXM!FL.AMP
SYSL1:	SKIPE	N,ONEJOB	;SEE IF ONE JOB REQUESTED
	CAIN	N,(J)		;YES--SEE IF THIS IS IT
	SKIPA	JS,@.STS	;A WINNER
	JRST	DUNJOB		;A LOSER
	TLNN	JS,JNA
	JRST	[SETZM	JOBTIM(J)	;FOR NEXT TIME
		SETZM	OLDPPN(J)	;FOR NEXT TIME AROUND
		SETZM	JOBKCT(J)	;START FRESH
		JRST	DUNJOB]
	TLO	F,FL.DTJ
	MOVE	A,@.TTY		;GET TTY NAME
	TLNN	A,-1		;TEST FOR DETACHED
	TLOA	A,(SIXBIT /DET/) ;YES
	TLZA	F,FL.DTJ	;YES. NOT DETACHED.
	TLNE	F,FL.GOD	;SEE IF GOD
	SKIPA			;YES (OR NOT DETACHED)
	TRZ	A,-1		;NOT GOD AND DETACHED--CLEAR TTY NUMBER
	MOVEM	A,JOBTTY
	SKIPE	TNFRTY		;SEE IF 10/40N
	JRST	SYSL1D		;YES--SKIP PRJ-PRG
	MOVE	A,@.PPN		;FETCH PPN OF JOB
	TLNN	F,FL.DTJ
	TLNN	JS,JLOG
	PUSHJ	P,NOWHO		;PRINT *'S OR PRJPRG DEPENDING UPON GODLINESS
	SKIPLE	N,ONEPPN	;SEE IF PPN CROSS SECTION
	CAMN	A,N		;YES--SEE IF MATCHES
	JRST	SYSL1D		;A WINNER
	TLNE	N,-1		;WILD CARD PROJECT NUMBER?
	JRST	SYSL0D		;NO
	CAIN	N,(A)		;PROGRAMMER NUMBERS MATCH?
	JRST	SYSL1D		;A WINNER
SYSL0D:	TRNE	N,-1		;WILD CARD PROGRAMMER NUMBER?
	JRST	DUNJOB		;A LOSER
	TRZ	A,-1		;ANY PROGRAMMER NUMBER WINS
	CAME	A,N		;SEE IF IT MATCHES
	JRST	DUNJOB		;A LOSER
	MOVE	A,@.PPN		;RESTORE PPN
SYSL1D:	SKIPGE	N,ONETTY	;SEE IF TTY CROSS SECTION
	JRST	TTYOK		;NO--MUST BE OK
	CAMN	N,@.TTYN	;YES--SEE IF CORRECT LINE NUMBER
	CAMN	A,[-1]		;SEE IF HIDDEN
	JRST	DUNJOB		;A LOSER
TTYOK:	HRRZ	N,J
	TRO	F,FR.OVR	;TENTATIVELY SET COLUMN OVERFLOW
	CAME	A,[-1]		;CLEAR IF HIDDEN
;DELETE 2 LINES
	TLNE	A,7B20		;SEE IF WIDE PROJECT
	JRST	TTYOK1		;YES--DON'T CLEAR
	TRNN	A,7B20		;AND WIDE PROGRAMMER
	TRZ	F,FR.OVR	;NO--CLEAR
TTYOK1:	PUSHJ	P,DECP2X	;PRINT AS TWO DIGITS OR SPACE AND ONE
	SKIPE	TNFRTY		;SEE IF 10/40
	JRST	NOPPN		;10/40 NO PPN'S
	SKIPN	N,ONEPPN	;SINGLE USER?
	JRST	PPNOK		;NO, DISPLAY PPN
	JUMPL	N,PPNOK
	TRNE	N,-1		;WILD CARD PROGRAMMER NUMBER?
	TLNN	N,-1		;OR WILD CARD PROJECT NUMBER?
	JRST	PPNOK		;YES, PRINT PPN SINCE MAYBE MORE THAN ONE
NOPPN:	TRZA	F,FR.OVR	;YES--SKIP PPN
PPNOK:	PUSHJ	P,PNTPPN	;PRINT PRJ-PRG #
	TRNE	F,FR.OVR	;SEE IF OVERFLOW
	PUSHJ	P,SPACE		;YES--JUST SPACE TO CATCH UP
	TRZN	F,FR.OVR	;NO--CLEAR AND
	PUSHJ	P,TAB		;TAB OVER
	TRNE	F,FR.USR	;WANT USER NAMES?
	PUSHJ	P,USRNAM	;YES, PRINT THEM
	SKIPN	A,JOBTTY
	MOVE	A,@.TTY
	HLRZ	CH,A		;GET PREFIX OF DEVICE
	CAIN	CH,'TTY'	;SEE IF TTY
	SKIPE	ONEJOB		;YES--SEE IF ALL JOBS
	JRST	.+2		;NO--GIVE FULL NAME
	HRLZ	A,A		;YES--JUST OUTPUT NUMBER
	CAIE	CH,'PTY'	;SEE IF PTY
	JRST	SYSLTT		;NO--OUTPUT IN SIXBIT
	AOS	PTYS		;COUNT THE PTY JOB
	MOVEI	CH,"P"		;YES--OUTPUT A P
	PUSHJ	P,TYO		;..
	HRRZ	N,A		;FOLLOWED BY
	PUSHJ	P,OPRNT		;THE PTY DRIVING THIS PTY
	HRRZ	N,J		;GET JOB #
	SKIPE	DSKFLG		;DISK MODE?
	PUSHJ	P,CTLJB		;YES,SIMULATE CTLJOB UUO
	CTLJOB	N,		;FIND CONTROLLING JOB
	  JRST	SYSLTY		;N.G.
	JUMPLE	N,SYSLTY	;N.G.
	MOVEI	CH,"J"		;PRINT A J
	PUSHJ	P,TYO
	PUSHJ	P,DECPRT	;PRINT CONTROLLING JOB #
SYSLTY:	PUSHJ	P,TAB
	JRST	SYSLTU		;DON'T DO THE SIXBIT THING
SYSLTT:	TDNN	A,[-77B5-1]	;SEE IF JUST ONE CHARACTER
	PUSHJ	P,SPACE		;YES--SPACE IN ONE
	PUSHJ	P,SIXTAB	;PRINT SIXBIT MSG FOLLOWED BY TAB

SYSLTU:	MOVE	A,@.PRG
	PUSHJ	P,SIXTAB	;PRINT SIXBIT MSG FOLLOWED BY TAB
	TLZ	F,FL.HSG	;FLAG LOW SEGMENT
	PUSHJ	P,SEGSZ		;COMPUTE SEGMENT SIZE
	PUSH	P,J		;SAVE JOB NO
	PUSH	P,N		;SAVE LOW SEG VALUE
	SKIPG	J,@.SGN		;GET SEGMENT # OF HISEG
	JRST	SYSLT0		;SPY OR NO HIGH SEGMENT
	TLO	F,FL.HSG	;FLAG THAT HISEG IS DESIRED
	PUSHJ	P,SEGSZ		;GET HISEG SIZE
	TRNE	F,FR.VMF	;IS THIS A VM SYSTEM?
	TLNE	J,SHRSEG	;AND IS SEGMENT SHARABLE?
	JRST	SYSLT1		;NO CLASSIC
	SUBM	N,(P)		;UPDATE LOW SEGSIZE
	MOVNS	(P)		;MAKE IT POSITIVE
SYSLT1:	HRLM	N,(P)		;STORE HISEG VALUE ON STACK
SYSLT0:	HRRZ	N,(P)		;GET LOW SEGMENT SIZE
	EXCH	J,-1(P)		;GET OLD J VALUE
	HLRZ	A,@.PDB		;FETCH # OF PER PROCESS PAGES
	ANDI	A,77		;JUST # OF PAGES
	ADD	N,A		;ADD THEM TO LOW SEG SIZE
	MOVE	A,N		;SAVE FOR LATER TEST
	ADDM	N,CORUSE
	PUSHJ	P,SEGLOK	;SEE IF SEG LOCKED
	PUSHJ	P,INACTC	;SKIP IF JOB IS INACTIVE
	ADDM	N,ACTUSE	;NO, ACTIVE, COUNT ACTIVE VIRTUAL CORE
	ADDM	N,LOWUSE	;COUNT TOTAL LOW SEG SIZE
	PUSHJ	P,DECPRT
	EXCH	J,-1(P)		;GET JBTSGN ENTRY
	JUMPLE	J,SYS9		;IN CASE SPYING
	MOVEI	CH,"+"		;OUTPUT A PLUS
	PUSHJ	P,TYO
	HLRZ	N,(P)		;GET HISEG VALUE
	PUSHJ	P,DECPRT	;PRINT HI-SEG SIZE
SYS9:	JUMPGE	J,SYS8	;GET VALUABLES BACK
	MOVE	A,[SIXBIT /+spy/] ;SPYING--PRINT INDICATION
	PUSHJ	P,SIXBP
SYS8:	POP	P,J		;GET TEMPORARY OF STACK
	POP	P,J		;RESTORE JOB NUMBER

	CAIN	WD,L.SSO	;SHORT STATUS ONLY?
	JRST	RET2		;YES-DON'T PRINT STATE OR RUN TIME
	PUSHJ	P,TAB
	MOVSI	A,'^W '		;PREPARE FOR COMMAND WAIT
	TLNE	JS,400000	;SEE IF COMMAND TYPED
	MOVSI	A,'CW '		;.
	TLNE	JS,CMWB		;..
	JRST	TSTATE		;YES
	MOVSI	A,'OW '		;SET IN CASE OPER WAIT
	TRNE	JS,JDCON	;SEE IF DEVICE HOLDING IT UP
	JRST	TSTATE		;YES--SEND IT
	MOVSI	A,'^D '		;SET IN CASE DAEMON WAIT
	TRNE	JS,JDC		;SEE IF DAEMON CALL FROM COMMAND
	JRST	TSTATE		;YES--SEND IT
	MOVSI	A,(SIXBIT /^C/)
	JUMPGE	JS,TSTATE
	LDB	B,[POINT 5,JS,14]
	IDIVI	B,3
	IMULI	C,^D12
	MOVE	A,QTAB(B)
	LSH	A,(C)
	AND	A,[7777B11]
	MOVSI	B,(SIXBIT /SL/)	;SEE IF SLEEP WAIT STATE CODE
	CAME	B,A		;IS IT?
	JRST	SYS10		;NO
	TRNN	JS,CLKR		;DOES THE JOB HAVE A CLOCK REQUEST IN?
	MOVSI	A,(SIXBIT /HB/)	;NO, THE JOB IS HIBERNATING
SYS10:	MOVSI	B,(SIXBIT /TI/)	;SEE IF TTY I/O WAIT STATE CODE
	CAMN	B,A		;IS IT?
	SKIPN	B,@.DVIOS	;AND IS IOS NON-ZERO
	JRST	TSTATE		;NO, TI WAIT
	TLNN	F,FL.SCN	;NEW SCANNER SERVICE?
	MOVNS	B		;NO, REVERSE THE SENSE OF THE BIT
	JUMPGE	B,TSTATE	;JUMP IF NOT OUTPUT
	MOVSI	A,(SIXBIT /TO/)	;TTY OUTPUT WAIT
TSTATE:	PUSHJ	P,LOPSWP	;PRINT STATE AND "SW"/"SWF" IF SWAPPED/& FRAGMENTED
	MOVE	C,@.KCT
	TRNN	F,FR.END
	MOVEM	C,JOBKCT(J)	;STORE ON FIRST PASS ONLY
	MOVE	A,@.TIM
;Deleted	MOVE	B,JOBTIM(J)	;PICK UP OLD RUN TIME TICKS
	MOVE	N,JOBTIM(J)	;PICK UP OLD RUN TIME TICKS
	MOVEM	A,JOBTIM(J)	;SAVE THIS PASS
	MOVE	B,[%CNSUP]	;GET SYSTEM UPTIME
	CALL	GETTB		;DO THE GETTAB
	 JFCL			;?FAILURE?
	MOVE	CH,B		;SAVE UPTIME AWAY HERE
	SUB	CH,SYSUPT(J)	;THIS IS THE UPTIME SINCE LAST "REENTER"
	MOVEM	B,SYSUPT(J)	;SAVE NEW UPTIME FOR THE NEXT TIME
	MOVE	B,N		;GET JOBTIM BACK HERE
	TRNN	F,FR.END	;FIRST PASS?
	JRST	PRUNT		;YES
	MOVE	M,@.PPN		;PICK UP PPN
	CAMN	M,OLDPPN(J)	;NEW PPN?
	CAMGE	A,B		;NEW RUN TIME .LT. LAST?
	TROA	F,FR.CHG!FR.LGN	;YES. MUST HAVE LOGGED IN
	SUB	A,B		;USE DIFFERENTIAL
	JUMPE	A,[MOVEI	M,[ASCIZ/	/]
		PUSHJ	P,MSG	;FAKE IT
		JRST	CHKKCT]
;Deleted	MOVE	CH,DIFTIM	;PICK UP INCREMENTAL UPTIME
	MOVE	N,A		;SET UP CALLING SEQUENCE FOR
	PUSHJ	P,PCNT2		;PRINT PERCENTAGE OF CPU
CHKKCT:	MOVE	A,@.KCT		;PICK UP NEW KC TICKS
	MOVE	B,JOBKCT(J)	;OLD KC TICKS
	MOVEM	A,JOBKCT(J)	;SAVE NEW VALUE
	TRNN	F,FR.CHG	;USE NEW AMOUNT IF CHANGE
	SUB	A,B
	ADDM	A,TOTKCT	;FORM TOTAL THIS PASS
	JUMPE	A,[MOVEI	M,[ASCIZ /  /]
		   PUSHJ P,MSG
		   JRST DOFLGS]
	MOVEI	M,[ASCIZ/	/]
	PUSHJ	P,MSG
	MOVE	N,A
	IDIV	N,TCKSEC
	PUSHJ	P,DECP3X	;PRINT KILO-CORE-SECS
	JRST	DOFLGS
PRUNT:	PUSHJ	P,TCKTIB	;PRINT RUN TIME IS SECS
DOFLGS:	MOVE	C,[POINT 6,A]	;SET-UP POINTER FOR FLAGS
	MOVE	A,@.RTD		;SEE IF IN A HIGH PRIORITY QUEUE
	LDB	N,HPQPNT	;GET HPQ NUMBER
	JUMPE	N,SYSLK0	;ZERO MEANS  TS Q'S
	PUSHJ	P,SPACE
	PUSHJ	P,DECPR2	;PRINT Q NUMBER
	TRO	F,FR.HPQ	;REMEMBER IT FOR THE FOOTNOTE
SYSLK0:	MOVEI	A,0		;CLEAR FLAGS
	MOVE	B,@.STS		;GET JOB STATUS
	TLNN	B,NSWP!NSHF	;SEE IF LOCKED IN CORE
	JRST	SYSLKX		;NO
	TLNE	B,NSHF		;YES--SEE IF CAN BE SHUFFLED
	JRST	SYSLK1		;NO
	MOVEI	B,(SIXBIT /  !/)  ;YES
	TLO	F,FL.EXM	;FLAG FOR FOOTNOTE
	JRST	SYSLK2
SYSLK1:	MOVEI	B,(SIXBIT /  &/)  ;NOTE LOCKED
	TLO	F,FL.AMP	;FLAG FOR FOOTNOTE
SYSLK2:	IDPB	B,C		;PUT FLAG AWAY
SYSLKX:	MOVS	B,@.STS		;GET STATUS WORD, SWAPPED
	HRRI	B,'$'		;AND FLAG FOR EXECUTE ONLY
	TLNE	B,JS.XO		;IS THIS JOB EXECUTE ONLY?
	IDPB	B,C		;YES. ADD $ TO FLAGS
	TLNE	B,JS.XO	
	TRO	F,FR.XOM	;AND FLAG WANT EXECUTE ONLY MESSAGE
	SKIPG	B,@.SGN		;DOES JOB HAVE A HISEG?
	JRST	SYSL1E		;NO
	TLO	F,FL.HGH	;SET HISEGS IN USE FLAG
	PUSH	P,J		;SAVE J
	MOVE	J,B
	PUSH	P,A		;SAVE A
	HRRZ	A,B
	SUB	A,JOBN
	SKIPL	A		;RANGE CHECK
	CAML	A,SEGN		;..
	MOVEI	A,0		;BAD. PROTECT ONESSELF
	AOS	@.SEGCT		;INCREMENT HI SEG USE COUNT
	POP	P,A		;RESTORE A
	SKIPE	B,@.PRG		;AN OBSOLETED SEGMENT?
	JRST	SYSL1A		;NO-CHECK IF IT'S A NON CUSP HISEG
	MOVE	B,@.STS
	TLNN	B,SHRSEG	;IS IT SHARABLE?
	JRST	SYSL1B		;NO-MUST BE PRIVATE
	MOVEI	B,(SIXBIT /  @/)
	IDPB	B,C		;PUT FLAG AWAY
	TLO	F,FL.NST	;YES-SET @ FLAG
	JRST	SYSL1B		;PRINT @
SYSL1A:	SKIPN	B,SYSTAP	;SEE IF SYSTEM TAPE IS NOT DISK
	JRST	SYSL1M		;IS DISK--CHECK PPN
	CAME	B,@.PPN		;CHECK LEV.C DEVICE NAME
	CAMN	B,@.DEV		;OR LEVEL D DEVICE NAME
	JRST	SYSL1B		;IS SYS
	JRST	SYSL1N		;IS NOT SYS
SYSL1M:	MOVE	B,@.PPN		;GET HISEG OWNER
	CAMN	B,SYSPPN	;IS IT A CUSP HISEG?
	JRST	SYSL1B		;YES-DON'T PRINT ANYTHING
SYSL1N:	MOVEI	B,(SIXBIT /  #/)  ;PREPARE TO FLAG JOB WITH #
	IDPB	B,C		;PUT FLAG AWAY
	TLO	F,FL.NUM	;SET # FLAG
SYSL1B:	POP	P,J		;RESTORE J & A
SYSL1E:	MOVEI	B,(SIXBIT /  +/)
	TRZE	F,FR.CHG	;NEW LOGIN?
	IDPB	B,C		;FLAG ON OUTPUT
	JUMPL	C,RET2		;IF NO FLAGS, JUMP
	PUSHJ	P,SPACE		;PRINT A SPACE
	PUSHJ	P,SIXBP		;PRINT @ OR #
RET2:	PUSHJ	P,CRLF

DUNJOB:	MOVE	A,@.PPN		;IN ANY CASE, SAVE THIS PPN
	MOVEM	A,OLDPPN(J)
	PUSHJ	P,NOWHO
	MOVEM	A,@.PPN		;IN CASE OF **,** WIPEOUT
	AOBJN	J,SYSL1
	MOVEI	M,[ASCIZ/Total KCS used = /]
	MOVE	N,TOTKCT
	IDIV	N,TCKSEC
	MOVEM	N,TEMP
	TRNE	F,FR.END	;2ND OR 3RD PASS?
	PUSHJ	P,MSGDEC
	MOVEI	M,[ASCIZ/ Average KCS = /]
	MOVE	N,TEMP
	IDIV	N,LOGDIN
	TRNE	F,FR.END
	PUSHJ	P,MSGDEC	;ANNOUNCE AVERAGE KCS OVER INTERVAL
	TRNE	F,FR.END
	PUSHJ	P,CRLF
	MOVEI	M,[ASCIZ /@ means superseded Hi-Seg	/]
	TLNE	F,FL.NST
	PUSHJ	P,MSG
	MOVEI	M,[ASCIZ /# means non-system Hi-Seg/]
	TLNE	F,FL.NUM
	PUSHJ	P,MSG
	TLZE	F,FL.NST!FL.NUM
	PUSHJ	P,CRLF
	MOVEI	M,[ASCIZ /& means locked in core	/]
	TLNE	F,FL.AMP
	PUSHJ	P,MSG
	MOVEI	M,[ASCIZ /! means locked in core--can be shuffled/]
	TLNE	F,FL.EXM
	PUSHJ	P,MSG
	TLZE	F,FL.AMP!FL.EXM
	PUSHJ	P,CRLF
	MOVEI	M,[ASCIZ /$ means Execute Only	/]
	TRNE	F,FR.XOM	;WAS THERE AN EXECUTE ONLY JOB?
	PUSHJ	P,MSG		;YES. EXPLAIN FLAG

	MOVEI	M,[ASCIZ /n means job runs in HPQ n/]
	TRNE	F,FR.HPQ	;SEEN ANY JOBS IN HPQ'S?
	PUSHJ	P,MSG		;YES, EXPLAIN NUMBER
	TRZE	F,FR.XOM!FR.HPQ
	PUSHJ	P,CRLF
	MOVEI	M,[ASCIZ &+ means LOGIN during interval&]
	TRNE	F,FR.LGN	;ANY NEW LOGINS?
	PUSHJ	P,MSG		;YES, EXPLAIN +
	TRZE	F,FR.LGN
	PUSHJ	P,CRLF
	SKIPN	PTYS		;SEE IF ANY PTY JOBS
	JRST	DONJOB		;NO--END OF FOOTNOTES
	MOVEI	M,[ASCIZ /Jnn is the controlling job, Pnn corresponds to TTY/]
	PUSHJ	P,MSG		;YES--OUTPUT NOTE
	MOVE	N,PTYOFS	;GET OFFSET
	PUSHJ	P,OPRNT		;OUTPUT IT
	MOVEI	M,[ASCIZ /+nn
/]
	PUSHJ	P,MSG		;(PTY0 DRIVES OFFSET TTY)
DONJOB:	CAIN	WD,L.SSO	;SHORT STATUS ONLY?
	JRST	FINIS		;YES-GO SEE IF WE SHOULD EXIT. OR INTERPRET MORE CHS.
	TLZ	WD,SIGN		;CLEAR SIGN BIT IF IT WAS ON SO PRINTING MAY RESUME
	SKIPL	ONETTY		;SEE IF SINGLE TTY
	JRST	DEVQ		;YES--PROCEED TO DEVICE STATUS
	SKIPN	ONEJOB		;SEE IF SINGLE JOB
	SKIPE	ONEPPN		;OR SINGLE USER
	JRST	DEVQ		;YES--SKIP SEGMENT JUNK
	TLNN	F,FL.HGH
	JRST	DORMNT
	SUBTTL	PRINT HIGH-SEGMENT STATUS
	CAIN	WD,L.GSS	;ONLY GENERAL SYSTEM STATISTICS?
	TLO	WD,SIGN		;YES, SUPPRESS PRINTING
	LDB	D,DSKLEV
	SETOM	SEGFLG		;SEG SEGMENT FLAG
	MOVEI	M,[ASCIZ /
High Segments:
Program	/]
	PUSHJ	P,MSG
	JUMPE	D,.+3
	MOVEI	M,[ASCIZ /Device	/]
	PUSHJ	P,MSG
	MOVEI	M,[ASCIZ  /Owner	High(K)	Users

/]
	SKIPE	CPKI10
	MOVEI	M,[ASCIZ  /Owner	High(P)	Users

/]
	PUSHJ	P,MSG
	MOVE	J,SEGPTR
	SETZM	CORSAV		;CLEAR COUNTER FOR VIRT. CORE SAVED
	SETZM	LOKCHK		;CLEAR LOKSEG CHECKED FLAG
HIGH00:	SKIPL	JS,@.STS
	JRST	DUNHGH
	SKIPN	A,@.PRG
	JRST	[MOVE	A,[SIXBIT /(priv)/]
		TLNE	JS,SHRSEG
		MOVE	A,[SIXBIT /(obs)/]
		JRST	.+1]
	PUSHJ	P,SIXBP		;PRINT SIXBIT MSG
	JUMPE	D,.+3
	MOVE	A,@.DEV
	PUSHJ	P,TABSIX
	SKIPN	A,SYSTAP	;SEE IF SYSTEM TAPE IS NOT A DISK
	JRST	HIGH04		;DISK--CHECK PPN
	CAME	A,@.PPN		;COMPARE WITH LEV.C DEVICE
	CAMN	A,@.DEV		;COMPARE WITH LEV.D DEVICE
	JRST	[MOVSI	A,(SIXBIT /SYS/)
		 JRST	HIGH2A]
	SKIPN	A,@.PPN		;NOT SYS, GET DEVICE NAME
	MOVE	A,@.DEV		;FROM TABLES
	JRST	HIGH2A		;AND GO PRINT IT
HIGH04:	MOVE	A,@.PPN
	JUMPE	A,.+3		;IF ZERO, LEAVE IT THAT WAY
	TLNN	A,-1		;PPN OR POINTER?
	PUSHJ	P,PEEKA		;POINTER, GET PPN
	CAMN	A,SYSPPN	;CUSP HISEG?
	JRST	HIGH2A		;YES-DON'T LOOK FOR DETACHED OWNER
	JUMPN	A,HIGH05
	PUSHJ	P,SEGSCN	;LOOK FOR JOB WITH THIS SEGMENT NO.
	  JRST	HIGH2C
	SKIPGE	B		;PRIVATE HISEG?
	JUMPE	A,[MOVEI M,[ASCIZ /	Job /]	;YES-COMPUTE JOB NO.
		SUB	B,.SGN
		HRRZ	N,B
		PUSHJ	P,MSGDEC	;AND PRINT IT
		JRST	HIGH2C]
IFE STANSW,<
HIGH05:	JUMPLE	A,HIGH2A	;OWNER MUST BE A DEVICE
	PUSH	P,J		;SAVE CURRENT SEGMENT NO.
	PUSHJ	P,SEGSCN	;FIND 1ST. JOB USING THIS HISEG
	  JRST	NOSEG		;NONE LEFT
	HRRZ	J,B
	SUB	J,.SGN		;GET JOB NO.
	HLRZ	C,@.TTY		;JOB DETACHED?
	CAIN	C,0
	CAME	A,@.PPN		;YES-IS THIS JOB HISEG OWNER?
	SKIPA	J,(P)		;NO-GET HISEG NO. AGAIN
	JRST	GO.ON		;YES-PRINT *'S UNLESS GOD
	AOBJN	P,.+1		;PRETEND WE DID A "PUSHJ"
	SOS	(P)		;DECREMENT PC
	AOBJN	B,HIGH06	;RE-ENTER SUBROUTINE (QUEL HACQUE!)
	POP	P,J		;POP OFF PC IF NO MORE JOBS TO CHECK
NOSEG:	POP	P,J		;RESTORE SEGMENT NO.
	JRST	HIGH2A		;PRINT OWNER
GO.ON:	POP	P,J		;RESTORE SEGMENT NO.
	PUSHJ	P,NOWHO		;PRINT *'S OR PRJPRG DEPENDING UPON GODLINESS
>
	JRST	HIGH2A

HIGH2C:	SETZ	A,		;PRINT BLANKS
HIGH2A:	PUSHJ	P,HIGH01
DUNHGH:	AOBJN	J,HIGH00	;ARE THERE ANY MORE HI SEGS.?
	JRST	DORMNT

HIGH01:	PUSHJ	P,PNTPPN	;PRINT AS P,PN PAIR
	PUSHJ	P,TAB
	TLO	F,FL.HSG	;FLAG HI-SEG
	PUSHJ	P,SEGSZ		;COMPUTE SEGMENT SIZE
	MOVE	B,N		;SAVE FOR LATER TEST
	TLNE	F,FL.DOR
	JRST	HIGH4A
	ADDM	N,CORUSE
	PUSHJ	P,SEGSCN	;FIND FIRST USER OF THIS HIGH SEG
	  JRST	NOALOW		;NO USERS
	JRST	FSALOW		;SEE IF ACTIVE
NXALOW:	ADD	J,.SGN		;RESTORE PTR TO SEGMENT TABLE
	EXCH	J,B		;RESTORE ORIGINAL J AND B
	PUSHJ	P,HIGH6A	;FIND NEXT USER OF THIS HIGH SEG
	  JRST	NOALOW		;NO MORE USERS
FSALOW:	SKIPN	LOKCHK		;THIS SEG CHECKED FOR LOCKED?
	PUSHJ	P,SEGLOK	;NO,SEE IF SEG LOCKED
	EXCH	J,B		;J=PTR TO USER IN SEGMENT TABLE
	SUB	J,.SGN		;J=JOB NUMBER OF USER
	PUSHJ	P,INACTC	;SKIP IF INACTIVE
	  SKIPA	J,B		;ACTIVE, COUNT THIS HIGH SEGMENT
	JRST	NXALOW		;INACTIVE, CHECK OTHER USERS
	ADDM	N,ACTUSE	;COUNT VIRTUAL CORE FOR ACTIVE SEGMENTS
NOALOW:	SETZM	LOKCHK		;RESET FLAG FOR NEXT SEGMENT
	PUSH	P,N
HIGH4A:	PUSHJ	P,DECP2X
	MOVSI	A,(SIXBIT //)
	PUSHJ	P,HIPSWP
	TLNE	F,FL.DOR
	JRST	CRLF
	MOVEI	A,(J)
	SUB	A,JOBN
	SOS	N,@.SEGCT
	IMULM	N,(P)
	AOS	N,@.SEGCT
	POP	P,A
	SKIPLE	A		;DON'T ADD TO CORSAV IF 0 OR -VE
	ADDM	A,CORSAV
	PUSHJ	P,DECPRT
	JRST	CRLF
	SUBTTL	PRINT DORMANT-SEGMENT STATUS
DORMNT:	TLZN	WD,SIGN		;SIGN ON?  YES IF GENERAL SYSTEM STATISTICS
	TLNN	F,FL.LPT!FL.DSK	;SEE IF FOR OPERATOR
	JRST	ENDDOR		;NO--SKIP
DODORM:	LDB	D,DSKLEV
	SETOM	SEGFLG		;SET SEGMENT FLAG
	MOVEI	M,[ASCIZ /
Dormant Segments:
Program	Owner	High(K)

/]
	JUMPE	D,.+2
	MOVEI	M,[ASCIZ /
Dormant Segments:
Program	Device	Owner	High(K)

/]
	SKIPE	CPKI10		;KI10 TEST
	MOVEI	M,[ASCIZ /
Dormant Segments:
Program	Device	Owner	High(P)

/]
	SETO	CH,
	MOVE	J,SEGPTR
DOR1:	SKIPGE	JS,@.STS	;SEGMENT DORMANT?
	JRST	DUNDOR		;NO
	MOVEI	N,OUTMSK
	MOVE	A,MONVER	;MONITOR VERSION NUMBER
	CAILE	A,70207		;7.03?
	MOVEI	N,777		;YES, DATA IS IN A DIFFERENT PLACE
	SKIPN	@.ADR		;SEGMENT IN CORE?
	TDNE	N,@.SWP		;NO - ON DISK?
	JRST	DOR2		;YES - GO PRINT IT
	JRST	DUNDOR		;NOT IN USE

DOR2:	JUMPE	CH,DORMN
	PUSHJ	P,MSG
	TLO	F,FL.DOR
DORMN:	MOVE	A,@.PRG
	PUSHJ	P,SIXBP
	SKIPN	A,SYSTAP	;SEE IF "SYS:" NOT "DSK:"
	JRST	DORMN2		;DISK
	CAME	A,@.PPN		;CHECK LEV.C DEVICE
	CAMN	A,@.DEV		;CHECK LEV.D DEVICE
	JRST	[MOVSI	A,(SIXBIT /SYS/)
		 JRST	DORM2A]
	SKIPN	A,@.PPN
	MOVE	A,@.DEV
	JRST	DORM2A
DORMN2:	JUMPE	D,.+3
	MOVE	A,@.DEV
	PUSHJ	P,TABSIX
	MOVE	A,@.PPN
DORM2A:	TLNN	A,-1		;PPN OR POINTER
	PUSHJ	P,PEEKA		;POINTER, GET PPN
	PUSHJ	P,HIGH01
DUNDOR:	AOBJN	J,DOR1		;ARE THERE ANY MORE SEGS. TO LOOK AT?

ENDDOR:	TLZ	F,FL.DOR
	CAIN	WD,L.DSO	;LIST DORMANT SEGS. ONLY?
	JRST	FINIS		;YES - GO SEE IF WE SHOULD EXIT OR INTERPRET MORE CHS.
	SUBTTL	PRINT MEMORY UTILIZATION STATISTICS
MUSTAT:	PUSHJ	P,CRLF
	MOVEI	M,[ASCIZ /Swapping space used = /]
	MOVE	A,XK4SWP
	PUSHJ	P,GETZ
	JUMPE	A,[MOVE   A,MAXMAX	;
		   ASH	  A,-12
		   MOVEM  A,TEMP
		   JRST   MUS3]
	MOVEM	A,TEMP
	MOVE	N,DSKUSE
	PUSHJ	P,PRPCNT
	MOVEI	M,[ASCIZ /Swapping Space Lost = /]	;
	MOVE	A,XSWPER	;
	PUSHJ	P,GETZ		;
	JUMPE	A,MUS3		;
	HRRZ	N,A		;
	TRZ	N,770000	;
	PUSHJ	P,MSGDEC	;
	PUSHJ	P,CRLF		;
MUS3:	MOVEI	M,[ASCIZ /Virt. Core used = /]
	MOVE	N,CORUSE
	PUSHJ	P,PRPCNT
	MOVE	N,MAXMAX	;FETCH MAX USER CORE AVAILABLE
	ASH	N,-11
	SKIPN	CPKI10		;FOR A KI10 ALL IS OKAY
	ASH	N,-1		;BUT SHIFT 1 MORE FOR A KA10
	MOVEM	N,TEMP
	SUB	N,CORUSE
	JUMPL	N,SWAP01
	MOVEI	M,[ASCIZ /K Core left/]
	SKIPE	CPKI10
	MOVEI	M,[ASCIZ /P Core left/]
	PUSHJ	P,DECMSG
	JRST	SWAP02

PRPCNT:	MOVEM	N,TEMP1
	PUSHJ	P,MSGDEC
	MOVSI	A,(SIXBIT ./.)
	MOVE	N,TEMP
	PUSHJ	P,SIXDEC
	MOVEI	M,[ASCIZ / = /]
	MOVE	N,TEMP1
	PUSHJ	P,CMPCNT
	MOVEI	M,[ASCIZ /%
/]
	JRST	MSG
SWAP01:	MOVEI	M,[ASCIZ /Swapping Ratio = /]
	MOVE	N,CORUSE
	PUSHJ	P,SWPPRT	;TYPE SWAPPING RATIO LINE
SWAP02:	MOVEI	M,[ASCIZ .
Active swapping ratio = .]
	MOVE	N,ACTUSE	;TOTAL ACTIVE VIRTUAL CORE
	PUSHJ	P,SWPPRT	;TYPE LINE
	SKIPN	N,CORSAV	;ANY CORE SAVED BY SHARING?
	JRST	SWAP03		;NO-DON'T PRINT ANYTHING
	MOVEI	M,[ASCIZ /
Virt. Core saved by sharing = /]
	PUSHJ	P,MSGDEC
	MOVSI	A,(SIXBIT ./(.)
	MOVE	N,CORSAV
	PUSHJ	P,SIXDEC
	MOVSI	A,(SIXBIT .+.)
	MOVE	N,CORUSE
	PUSHJ	P,SIXDEC
	MOVEI	M,[ASCIZ /) = /]
	MOVE	N,CORSAV
	ADD	N,CORUSE
	MOVEM	N,TEMP
	MOVE	N,CORSAV
	PUSHJ	P,CMPCNT	;COMPUTE PERCENTAGE & PRINT
	MOVSI	A,(SIXBIT .%.)
	PUSHJ	P,SIXBP
SWAP03:	PUSHJ	P,CRLF
	MOVE	N,NUMJOB	;NUMBER OF ACTIVE JOBS
	MOVEM	N,TEMP		;USE AS DIVISOR
	MOVEI	M,[ASCIZ .Average job size =.]
	MOVE	N,LOWUSE	;TOTAL OF LOW SEG SIZES
	PUSHJ	P,SWPPRT	;TYPE AVERAGE LOW SEG SIZE
	CALL	KAYPEE		;**[9] PRINT K OR P
	MOVEI	M,[ASCIZ .+.]
	MOVE	N,CORUSE	;TOTAL CORE USED
	ADD	N,CORSAV	;PLUS SAVED BY SHARING
	SUB	N,LOWUSE	;MINUS LOW SEGS= HIGH SEGS
	PUSHJ	P,SWPPRT	;TYPE AVERAGE HIGH SEGMENT SIZE
	CALL	KAYPEE		;**[9] PRINT K OR P
	MOVEI	M,[ASCIZ .  Total=.]
	MOVE	N,CORUSE	;TOTAL CORE USED
	ADD	N,CORSAV	;PLUS SAVED BY SHARING
	PUSHJ	P,SWPPRT	;TYPE AVERAGE TOTAL SIZE
	CALL	KAYPEE		;**[9] PRINT K OR P
	PUSHJ	P,CRLF
	CAIE	WD,L.GSS	;GENERAL SYSTEM STATISTICS ONLY?
	CAIN	WD,L.JSO	;PRINT JOB STATUS ONLY?
	JRST	FINIS		;YES-GO SEE IF WE SHOULD EXIT. OR INTERPRET MORE CHS.
	SUBTTL	"B" - DEVICE STATUS
DEVQ:	TLZ	F,FL.DEV	;CLEAR HEADER FLAG
	SETOM	FSDCNT		;SET 1ST PASS FLAG
	SETZM	DSKDDB		;CLEAR COUNTER OF DISK DDBS
	MOVE	A,XDVLST
	PUSHJ	P,GETZ
DEVLP1:	HLRZ	D,A		;GET POINTER
	MOVEI	JS,^D10000	;PROTECT AGAINST INF. LOOP
DEVLP:	JUMPE	D,DEVEND	;EXIT. LOOP IF ALL DONE
	MOVEI	C,DV.MOD(D)
	PUSHJ	P,PEEKC
	MOVE	B,C
	TRNN	B,ASSCON+ASSPRG
	JRST	NXTDEV
	MOVEI	C,DV.LOG(D)	;GET LOGICAL NAME
	PUSHJ	P,PEEKC		;FROM DDB
	MOVEM	C,LOGNAM	;SAVE FOR LATER
	MOVEI	A,DV.NAM(D)
	PUSHJ	P,PEEKA
	MOVEI	C,@.DVJOB	;NEW ENTRY IN DDB SINCE LOAD 722
	SKIPN	NPJOBN		;IF NEW STYLE THEN SKIP
	MOVEI	C,DV.CHR(D)
	PUSHJ	P,PEEKC
	LDB	J,PJOBN		;YES--GET JOB NUMBER
	SKIPE	NPJOBN		;IF NOT NEW STYLE
	LDB	J,NPJOBN	;GET JOB NUMBER SOMEWHERE ELSE
	MOVEI	C,DV.SPL(D)	;**[5] GET DEVSPL DDB ENTRY
	CALL	PEEKC		;**[C] IN C ASS J HAS BEEN SET
	SKIPL	C		;**[5] SPOOLED DEVICES USE A DISK DDB
	TLNE	B,DVDSK		;SEE IF DISK
	AOS	DSKDDB		;YES--COUNT IT
	TLNE	B,DVTTY		;SEE IF TTY
	TLNE	B,DVTTYC	;IF I/O TTY ALWAYS DO IT
	TLNN	B,DVTTY+DVDSK	;SEE IF TTY OR DISK
	JRST	DEVDO		;NO--JUST GO DO IT
	TLNE	F,FL.DSK	;IS IT DISK MODE?
	JRST	DEVDO		;YES--ALWAYS DO ALL DEVICES
	TLNN	F,FL.LPT!FL.GOD	;IF THIS IS OPER WORK
	CAMN	J,MYJOB		;OR SAME JOB
	SKIPN	LOGNAM		;AND THERE IS A LOGNAM
	JRST	NXTDEV		;**[5] FORGET THE THING
DEVDO:	SKIPE	N1,ONEJOB	;SEE IF SINGLE JOB
	CAMN	J,N1		;YES--SEE IF MATCHES
	JRST	.+2		;A WINNER
	JRST	NXTDEV		;NO--SKIP IT
	SKIPN	N1,ONEPPN	;MAKE WILD CARDS WORK; WAS ANY PPN
	JRST	DEVTTY		;SPECIFIED?  NO; GO ON.
	MOVE	N,@.PPN		;LOAD UP PPN OF DEVICE.
	TRNN	N1,-1		;RIGHT HALF OF SPEC'D PPN WILD?
	TRZ	N,-1		;YES; ZERO IT IN DEV PPN FOR MATCH.
	TLNN	N1,-1		;HOW ABOUT THE LEFT HALF?
	TLZ	N,-1		;DITTO.
	CAME	N,N1		;IF THEY AREN'T SAME NOW,
	JRST	NXTDEV		;GET ANOTHER DEVICE.
DEVTTY:	SKIPGE	N1,ONETTY	;(LABEL ADDITION) ;SEE IF SINGLE TTY MODE
	JRST	TTYOKD		;NO--PROCEED
	SETOM	N		;PRESET FOR TEST
	CAMN	N1,@.TTYN	;YES--SEE IF IT MATCHES
	CAMN	N,@.PPN		;SEE IF HIDDEN
	JRST	NXTDEV		;NO--SKIP IT
TTYOKD:	TLNE	B,DVTTY		;IF TTY
	TLNE	A,-1		;AND LH=0
	JRST	.+2		;NO
	HRLI	A,'DET'		;YES--DETACHED
;THE FOLLOWING TEST WAS MOVED UP A FEW LINES TO THIS POINT
	HLRZ	CH,A		;GRAB FIRST 3 CHARS
	CAIN	CH,'PTY'	;IS IT A PTY?
	JRST	[MOVEI	CH,0	;YES, MAYBE LIST ANYWAY
		OR	CH,ONEJOB
		OR	CH,ONEPPN
		ORCM	CH,ONETTY
		SKIPE	CH	;NONE OF THESE
		JRST	.+1	;GIVE HIM THE PTY ANYWAY
		CAME	J,MYJOB	;ESPECIALLY IF IT IS HIS
		TLNE	F,FL.LPT!FL.GOD	;OR HE DESERVES IT
		JRST	.+1
		JRST	NXTDEV]	;SPARE HIM THE TYPEOUT

	MOVEI	M,[ASCIZ /
Busy devices:
Device	Job	Why	Logical

/]
	TLNE	F,FL.DSK	;SEE IF DISK MODE
	MOVEI	M,[ASCIZ /
Busy devices:
Device	Job	Address	Why	Logical	UNILOG	DEVFIL	DEVEXT	DEVPPN

/]
	TLON	F,FL.DEV
	PUSHJ	P,MSG
	MOVEI	CH,"'"		;GET FLAG IN CASE DISK
	SKIPL	C		;**[6] IF SPOOLELED OR
	TLNE	B,DVDSK		;IS IT DISK?
	PUSHJ	P,TYO		;YES--OUTPUT FLAG FIRST
;THE TEST FOR PTY DEVICES WAS HERE BEFORE
	PUSHJ	P,SIXTAB	;PRINT SIXBIT MSG FOLLOWED BY TAB
	MOVE	N,J		;**[5] GET JOB NUMBER
	PUSHJ	P,DECP2X
	PUSHJ	P,TAB
	TLNN	F,FL.DSK	;SEE IF DISK MODE
	JRST	DVWHY		;NO--PROCEED
	MOVEI	N,(D)		;YES--GET ADDRESS OF DDB
	MOVEI	CH,-1		;SET FOR 6 DIGITS
	PUSHJ	P,FIXOCT	;OUTPUT IT
	PUSHJ	P,TAB		;AND SPACE
DVWHY:	MOVEI	M,[ASCIZ /as/]
	TRNE	B,ASSCON
	PUSHJ	P,MSG
	TRNN	B,ASSPRG
	JRST	DVLOG
	MOVEI	CH,"+"
	TRNE	B,ASSCON
	PUSHJ	P,TYO
	MOVEI	M,[ASCIZ /init/]
	PUSHJ	P,MSG
DVLOG:	TLNN	F,FL.LPT!FL.GOD	;IF FOR OPERATOR
	CAMN	J,MYJOB		;OR THIS JOB
	SKIPN	A,LOGNAM	;AND THERE IS A LOGICAL NAME
	JRST	DVFILE		;NO--SKIP IT
	PUSHJ	P,TABSIX	;OUTPUT IT
DVFILE:	TLNE	F,FL.DSK	;IN DSK MODE?
	TLNN	B,DVDSK		;AND IS THIS A DSK DDB
	JRST	DVCRLF		;NO--SKIP IT
	SKIPN	LOGNAM		;NEED A TAB?
	PUSHJ	P,TAB		;YES
	MOVEI	A,@.DVUNI	;GET UDB ADDRESS
	PUSHJ	P,PEEKA
	TRNN	A,-1		;DOES "CURRENT" EXIST?
	MOVS	A,A		;IF NOT, USE "ORIGINAL" UDB
	TLZ	A,-1		;SEE IF WE HAVE AN ADDRESS
	JUMPE	A,DVLOG1	;?
	MOVEI	A,UNILOG(A)	;GET UNIT'S LOGICAL NAME
	PUSHJ	P,PEEKA		;...
DVLOG1:	PUSHJ	P,TABSIX	;AND PRINT IT
DVLOGN:	MOVEI	A,@.DVFIL	;USE D AS INDEX
	PUSHJ	P,PEEKA
	JUMPE	A,DVCRL0	;FORGET IT IF ITS ZERO
	PUSH	P,A		;SAVE FILE NAME
	MOVEI	A,@.DVEXT	;GET EXTENSION USE D AS INDEX
	PUSHJ	P,PEEKA
	TRZ	A,-1
	PUSHJ	P,TAB		;LINE IT UP
	CAME	A,[SIXBIT /UFD/]
	JRST	DVFIL1		;PRINT SIXBIT NAME
	EXCH	A,(P)		;GET UFD PPN
	PUSHJ	P,OCTPRA	;PRINT IT
	JRST	DVFIL2		;GO DO THE EXTENSION
DVFIL1:	EXCH	A,(P)		;GET SIXBIT FILE NAME
	PUSHJ	P,SIXBP		;DISPLAY IT
DVFIL2:	POP	P,A		;EXTENSION
	PUSHJ	P,TABSIX	;PRINT IT
	MOVEI	A,@.DVPPN	;GET OWNER USE D AS INDEX
	PUSHJ	P,PEEKA
	PUSHJ	P,PNTPPN	;AND PRINT IT
DVCRL0:
DVCRLF:	PUSHJ	P,CRLF
NXTDEV:	MOVEI	C,DV.SER(D)
	PUSHJ	P,PEEKC
	HLRZ	D,C
	SOJG	JS,DEVLP

DEVEND:	MOVE	A,MONVER	;GET MONITOR VERSION
	CAIGE	A,67700		;7.00 FIELD TEST OR LATER?
	JRST	DEVEN4		;NO, QUIT NOW
	TLNN	F,FL.DSK	;READING A CRASH?
	JRST	DEVEN2		;NO
DEVEN1:	AOS	J,FSDCNT	;BUMP JOB # COUNT
	CAML	J,JOBN		;DONE THEM ALL YET?
	JRST	DEVEN4		;YES
	MOVE	A,@.STS		;PICK UP JOB STATUS
	TLNN	A,JNA		;JOB NUMBER ASSIGNED?
	JRST	DEVEN1		;NO, TRY NEXT
	JRST	DEVEN3		;JOIN COMMON CODE
DEVEN2:	AOSE	FSDCNT		;BEEN HERE BEFORE?
	JRST	DEVEN4		;YES, THAT'S ALL
	SKIPE	A,ONEJOB	;USER SPECIFY JUST ONE JOB?
	CAME	A,MYJOB		;AND IS IT THIS ONE?
	JRST	DEVEN4		;NO, DON'T PRINT ANY DDB'S
DEVEN3:	SKIPE	A,.UPLST	;GET ADDRESS OF PTR TO DISK DDB'S
	PUSHJ	P,PEEKA		;READ FROM OUR PAGE MAP
	JUMPN	A,DEVLP1	;PRINT ANY DISK DDB'S
	TLNE	F,FL.DSK	;READING A CRASH?
	JRST	DEVEN1		;YES, TRY NEXT JOB

DEVEN4:	SETOM	FSDCNT		;SET FLAG AGAIN
	SKIPN	ONEJOB		;SEE IF SINGLE JOB
	SKIPE	ONEPPN		;SEE IF SINGLE PPN
	JRST	FINIS		;YES--ALL DONE
	SKIPL	ONETTY		;SEE IF SINGLE TTY
	JRST	FINIS		;YES--FINISH UP
	MOVEI	M,[ASCIZ /
No busy devices
/]
	TLZN	F,FL.DEV
	PUSHJ	P,MSG
	MOVEI	M,[ASCIZ / disk DDBs
/]
	MOVE	CH,MONVER	;GET VERSION OF MONITOR
	SKIPE	N,DSKDDB	;GET DISK DDB COUNT
	CAIL	CH,67700	;7.00 FIELD TEST OR LATER?
	CAIA			;YES, DON'T PRINT
	PUSHJ	P,DECMSG	;OUTPUT IT IF THERE ARE ANY

DEVFIN:	CAIN	WD,L.BDO	;PRINT BUSY DEVICES ONLY?
	JRST	FINIS		;YES-GO SEE IF WE SHOULD EXIT. OR INTERPRET MORE CHS.
	SUBTTL	"F" - FILE STRUCTURE STATUS

FS:	TLZ	F,FL.DEV	;CLEAR HEADER FLAG
	SETZB	A,C
	MOVE	A,XSYSST
	PUSHJ	P,GETA
FS1:	HLRZ	D,A
	JUMPE	D,FSFIN
	MOVEI	A,STRNAM(D)
	PUSHJ	P,PEEKA
	JUMPE	A,FSL1		;IF BLANK STRUCTURE NAME, PROCEED
	MOVEI	M,[ASCIZ /
System File Structures:
Name	Free	Mount
/]
	TLON	F,FL.DEV	;TYPED THIS HEADING YET?
	PUSHJ	P,MSG		;NO. DO IT NOW.
	PUSHJ	P,SIXTAB	;TYPE STRUCTURE NAME
	MOVEI	A,STRTAL(D)
	PUSHJ	P,PEEKA
	MOVE	N,A
	ADD	C,N		;ACCUMULATE IT IN THE TOTAL
	PUSHJ	P,DECTAB	;PRINT IT
	MOVEI	A,STRMNT(D)
	PUSHJ	P,PEEKA
	MOVE	N,A
	PUSHJ	P,DECPRT	;PRINT IT
	MOVEI	M,[ASCIZ /	Private structure/]
	MOVEI	A,STRUN1(D)	;POINT TO WORD CONTAINING STPPVS
	PUSHJ	P,PEEKA		;GET IT
	TRNE	A,STPPVS	;THIS STR PRIVATE?
	PUSHJ	P,MSG		;YES, TELL THE USER
	MOVEI	M,[ASCIZ /	Single Access by job /]
	MOVEI	A,STRJOB(D)
	PUSHJ	P,PEEKA
	JUMPLE	A,FSNNA
	HRRZ	N,A
	PUSHJ	P,MSGDEC	;AND PRINT HIS NUMBER
FSNNA:	MOVEI	M,[ASCIZ /	No New Accesses/]
	MOVEI	A,STRUNI(D)
	PUSHJ	P,PEEKA
	HLRZM	A,UNIBLK	;SET THE UDB ADDRESS
	PUSH	P,D		;SAVE STR ADDRESS
	CALL	GETDES		;GET UNIDES
	POP	P,D		;RESTORE D
	TLNE	A,(.UPNNA)	;SEE IF NNA
	PUSHJ	P,MSG		;YES--PRINT FLAG
FSL:	PUSHJ	P,CRLF		;GO TO NEW LINE
FSL1:	MOVEI	A,STRSYS(D)	;
	PUSHJ	P,PEEKA
	JRST	FS1		;LOOP

FSFIN:	MOVE	N,C		;TOTAL FREE
	MOVEI	M,[ASCIZ /Total Free /]
	PUSHJ	P,MSGDEC	;PRINT IT
	PUSHJ	P,CRLF		;NEW LINE
	CAIN	WD,L.FSO	;PRINT FILE STRUCTURES ONLY?
	JRST	FINIS		;YES-GE SEE IF WE SHOULD EXIT. OR INTERPRETMORE CHS.
	SUBTTL	"T" - DATA SET TABLE

; Begin body of Edit 266 - This edit causes SYSTAT to search through LINTAB
;  (LDB's) first for remote lines, and then through DSCTAB for lines on the
;  central node.

;	This code depends on a few post-6.03A GETTAB-able monitor symbols; it
;	 will assume 6.03A defaults if the GETTABs fail:

	%CNDCH=154,,11		;LDBDCH
	%CNDJB=135,,11		;DEVJOB
	%NDSNM=3,,161		;NDBSNM
				;LDBREM is not GETTABable

DSCDO:	TLZ	F,FL.DEV	;Clear the header flag
	MOVEI	M,[ASCIZ	/
  Dataset		Control
  Line #		Status

/	]			;Get header text
	MOVE	A,[0,,.GTLOC]	;Get location of central site
	PUSHJ	P,GETZ
	MOVEM	A,CNTLOC	;Save it
	MOVE	B,[%CNDCH]	;Get device-charac. word in LDB
	PUSHJ	P,GETTB
	 MOVEI	B,16		;Call not implemented?  Assume 6.03A-style
	HRRZM	B,LDBDCH
	MOVE	B,[%NDSNM]	;Get node-name pointer in NDB
	PUSHJ	P,GETTB
	 MOVEI	B,2		;Not implemented?  Assume 2
	HRRZM	B,NDBSNM	;Save this value
	MOVE	B,[%CNDJB]	;Get job-number pointer in DDB
	PUSHJ	P,GETTB
	 MOVEI	B,20		;Assume old monitor
	HRRZM	B,DEVJOB	;Save this value
	MOVE	B,MONVER	;Now determine LDBREM
	CAILE	B,70100		;Is it after 7.01?
	 MOVEI	A,33		;Yes, use 7.02 value of LDBREM
	CAILE	B,70207		;Is it after 7.02?
	 MOVEI	A,57		;Yes, use 7.03 value
	CAIG	B,70100		;Is it 7.01 or before?
	 MOVEI	A,32		;Yes, assume 7.00-7.01 value of LDBREM
	CAIGE	B,70000		;Is it before 7.00?
	 MOVEI	A,23		;Yes, assume 6.03A value of LDBREM
	MOVEM	A,LDBREM	;Remember this value
	MOVE	A,[%CNLNP]	;Get count and address of TTY line table
	PUSHJ	P,GETZ
	JUMPGE	A,FINIT		;Failed? Skip this whole routine
	HRRZM	A,LINTAB	;Remember beginning of table
	SETZM	TTNUM		;Zero out the counter
DSCLP0:	HRRZ	C,A		;Find the address of the LDB
	PUSHJ	P,PEEKC		;Get this address
	MOVE	B,MONVER	;Monitor version number
	CAILE	B,70207		;7.03?
	TLOA	F1,F1.XAD	;Yes, LDBs are in section 4. Don't clear left half
	HRRZS	C		;Get rid of left-half junk
	JUMPE	C,DSNEXT
	MOVEM	C,LDB		;Save the LDB pointer
	ADD	C,LDBDCH	;Get offset into LDB
	PUSHJ	P,PEEKC		;Get the word of data
	TRNE	C,(GL.DSL)	;See if a dataset TTY
	 PUSHJ	P,TYPEIT	;Type it out if so
DSNEXT:	AOS	TTNUM		;Go to next terminal
	AOBJN	A,DSCLP0	;Bump pointer and loop back
FINIT:	MOVE	A,XDSCTB	;Get pointer to dataset table
	PUSHJ	P,GETZ		;(Optional)
	JUMPGE	A,DSCFIN	;Skip table if empty
	SETOM	TTNUM		;Start with lowest TTY - 1
	TRNA			;skip incr. first time through

DSCLP:	AOBJP	A,DSCFIN	;Exit when done
	AOS	TTNUM		;Bump tty counter
	HRRZ	C,A		;Get location of this entry
	PUSHJ	P,PEEKC		;Look at it
	TLNN	C,(DSCSTS)	;See if other than idle
	JRST	DSCLP		;Idle--skip this entry
	TLON	F,FL.DEV	;See if header output yet
	PUSHJ	P,MSG		;No--do it
	LDB	N,[POINT 3,C,2+^L<DSCSTS>]
	CAIE	N,6		;Check special case first
	 JRST	DSCREG		;Not "in use"?  Do regular stuff
	TLNE	C,(DSCTIM)	;Timed state 6
	 SETZ	N,		;Flag as "new call"
DSCREG:	HRRZS	C		;Get rid of left half
	PUSHJ	P,TYPTTY	;Type out the message
	JRST	DSCLP		;And loop back

TYPEIT:	PUSH	P,A		;Save this ac
	MOVE	C,LDB		;Get LDB pointer
	ADD	C,LDBREM	;Add on this
	ADDI	C,3		;Go to LDBREM+3
	PUSHJ	P,PEEKC		;Get the word that contains the node number
	LDB	A,LDPRNN	;Get the right byte
	CAMN	A,CNTLOC	;On central node?
	 JRST	TYPDON		;Don't bother with locals
	JUMPE	C,TYPDON	;If zero, not connected or local
	MOVE	C,TTNUM		;Tell next routine the TTY number
	MOVEI	N,6		;Tell this routine N=6 (line "in use")
	PUSHJ	P,TYPTTY	;Type out this TTY line
TYPDON:	POP	P,A		;Get "A" back
	POPJ	P,
;  Here to type out a TTY status report, with C = TTY # set up and N containing
;    the status of the line

TYPTTY:	PUSH	P,A		;[322] Save loop counter
	PUSH	P,N		;Remember this word
	PUSH	P,C		;Remember the TTY number
	ADD	C,LINTAB	;Find the address of the LDB
	PUSHJ	P,PEEKC		;Get this address
	MOVE	B,MONVER	;Monitor version number
	CAILE	B,70207		;7.03?
	TLOA	F1,F1.XAD	;Yes, LDBs are in section 4. Don't clear left half
	HRRZS	C		;Get rid of left-half flags
	MOVEM	C,LDB		;Save the LDB pointer
	TLNN	F1,F1.XAD	;7.03 or later?
	JRST	TYPA.0		;No, don't check use bit
	ADDI	C,LDBTTW	;Address of TTW word
	PUSHJ	P,PEEKC		;Get it
	TLNE	C,LTLUSE	;Use bit on?
	JRST	TYPA.0		;Yes, go type it out
	POP	P,C		;No, return typing nothing
	POP	P,N		; ..
	JRST	NOJOB1		; ..
TYPA.0:	TLON	F,FL.DEV	;Header printed yet?
	 PUSHJ	P,MSG		;Do it now
	PUSHJ	P,NODENM	;Simulate the NODE. call
	 JRST	[MOVEI	M,[ASCIZ /     /] ;Failed?
		 PUSHJ	P,MSG	;Type a few spaces instead of a name
		 JRST	TYPE.1]	;And skip down a bit
	JUMPE	A,TYPE.1	;If zero, assume old monitor (no networks)
	PUSHJ	P,SIXBP		;Print out the node name
TYPE.0:	MOVEI	CH,"_"		;Type separator out
	PUSHJ	P,TYO
	MOVE	C,LDB		;Now get line number
	ADD	C,LDBREM	;Go to LDBREM+2
	ADDI	C,2
	PUSHJ	P,PEEKC		;Get this word
	JUMPE	C,[MOVE	N,TTNUM	;If zero, we have a central-node TTY
		   JRST	.+2]	;And should use correct line-number
	LDB	N,LDPRLN	;Get line number out of it
	PUSHJ	P,OPRNT		;Type it out
TYPE.1:	PUSHJ	P,SPACE		;Type a space
	MOVE	N,COLCNT	;Get HPOS
	CAIE	N,^D12		;At Column 12?
	JRST	TYPE.1		;No, type another space
	MOVE	N,COLCNT	;Get current column
	CAIGE	N,10		;Past first tab stop?
	PUSHJ	P,TAB		;No, line it up
	MOVEI	M,[ASCIZ /TTY/] ;Type this out
	PUSHJ	P,MSG
	POP	P,N		;Get the TTY number back (into N, not C)
	PUSHJ	P,OPRNT		;Type that out too
	MOVEI	M,[ASCIZ /:	/] ;Print this spacer out
	PUSHJ	P,MSG
	POP	P,N		;Get the TTY number back
	SKIPE	M,DSCMTB(N)	;Get standard message, if any
	JRST	DSCMSG		;Go output it
	PUSHJ	P,OPRNT		;No--Type octal status
	CAIA			;And skip
DSCMSG:	PUSHJ	P,MSG		;Output message
	MOVE	C,LDB
	PUSHJ	P,PEEKC		;Get LDBDDB word
	HRRZS	C		;See if a DDB exists for this TTY
	JUMPE	C,NOJOB		;No?  Not a job
	ADD	C,DEVJOB	;Get the job number
	PUSHJ	P,PEEKC		;(from the DDB)
	LDB	N,DDBJOB
	JUMPE	N,NOJOB		;If zero, don't type this
	MOVEI	M,[ASCIZ / by job /]
	PUSHJ	P,MSG
	PUSHJ	P,DECPRT	;Type it out
NOJOB:	PUSHJ	P,CRLF		;Plus a crlf
NOJOB1:	POP	P,A		;[322] Restore loop counter
	POPJ	P,		;That's all
;  Here to simulate function 2 of NODE. call (takes address in LDB)

NODENM:	PUSH	P,C		;Can't smash C
	MOVE	C,LDB		;Get LDB pointer
	ADD	C,LDBREM	;Add on this
	ADDI	C,3		;Go to LDBREM+3
	PUSHJ	P,PEEKC		;Get the word that contains the node number
	JUMPE	C,NODBAD	;If zero, we have a central-node TTY
	LDB	A,LDPRNN	;Get the right byte
	MOVE	B,[%CNNDB]	;Get address of first NDB
	PUSHJ	P,GETTB
	 JRST	NODBAD		;Failure
	MOVE	C,B		;Initialize search through NDB chain

NODLOP:	MOVE	D,C		;Remember the NDB address
	PUSHJ	P,PEEKC		;Get contents of this address
	HLRZ	N,C		;Get node number of this NDB
	HRRZS	C		;Get rid of left half
	CAMN	N,A		;Does it match?
	 JRST	NODRET		;Yes, return the name
	SKIPN	C		;At the bottom of the chain yet?
	 JRST	NODBAD		;Yes, fail miserably
	JRST	NODLOP		;Loop back

NODRET:	MOVE	C,D		;Get NDB address
	ADD	C,NDBSNM	;Get this word out of the NDB
	PUSHJ	P,PEEKC		;Got it
	MOVSS	C		;Swap halves of N
	PUSHJ	P,PEEKC		;Get the SIXBIT node name here
	MOVE	A,C		;Return the value here
	POP	P,C		;Get C back
	AOS	(P)		;Give skip return
	POPJ	P,

NODBAD:	POP	P,C		;Get C back
	POPJ	P,		;Give non-skip return

LDPRNN:	POINT	16,C,35		;Pointer to node number in LDBREM+3
LDPRLN:	POINT	10,C,35		;Pointer to line number in LDBREM+2
DDBJOB:	POINT	9,C,35		;Pointer to job number in DDB+DEVJOB

;  End of body of Edit 266

DSCMTB:	[ASCIZ	/new call/]
	0	;STATE=1
	[ASCIZ /rang/]
	[ASCIZ /carrier interrupt/]
	0	;4
	0	;5
	[ASCIZ /in use/]
	0	;7

DSCFIN:	TLZ	F1,F1.XAD	;Let PEEKA clear the left half of A
	CAIN	WD,L.DSC	;See if just this display
	JRST	FINIS		;Yes--exit
	SUBTTL	"E" - NON-DISK ERROR REPORT

	DEFINE	EACHCPU(CPUN),<		;
		IFE CPUN,<MOVEI	N,0>
		IFG CPUN,<TLNE	M,(1B<4+CPUN-1>)
			  MOVEI	N,CPUN>
	>

	TLNN	F,FL.DSK!FL.LPT	;SEE IF FOR OPERATOR
	JRST	SWFIN		;NO--SKIP REST OF DISPLAYS
ERRPT:	TLZ	F,FL.DEV	;CLEAR TITLE FLAG
	MOVSI	D,-ERRTL1	;SETUP TABLE POINTER

ERRLP1:	MOVE	A,ERRTB1(D)	;GET NEXT GETTAB
	MOVE	M,ERRTM1(D)	;ALLOW FOR POSSIBILITY OF A SUBTABLE
	TLNE	M,(1B11)	;ITEM FROM A SUBTABLE?
	JRST	[ALLCPUS	;YES, GET CPU NUMBER
		 MOVEM N,CPU	;SET TO CALL GETRSP
		 PUSHJ P,GETRSP	;GET THE VALUE
		   JRST ERRLX1	;NO SUCH GETTAB
		 JRST .+2]	;SKIP CALL TO GETZ AND CONTINUE
	PUSHJ	P,GETZ		;GET IT IF POSSIBLE
	JUMPE	A,ERRLX1	;ZERO--EITHER NOT THERE OR NOT USED
	MOVEI	M,[ASCIZ /
Non-disk Performance

/]
	TLON	F,FL.DEV	;SEE IF TITLE DONE YET
	PUSHJ	P,MSG		;OUTPUT TITLE
	MOVE	N,A		;SAVE COUNT
	HRRZ	M,ERRTM1(D)
	MOVE	B,ERRTM1(D)
	JUMPL	B,ERRLA1
	TLZE	B,200000	;DECIMAL HALF WORDS?
	JRST	ERRLA2		;YES
	PUSH	P,A
ERRLA3:	PUSH	P,B
	PUSH	P,M
	MOVEI	M,[ASCIZ /   /]	;LINE THINGS UP
	PUSHJ	P,MSG
	POP	P,M
	PUSHJ	P,DECPRJ	;OUTPUT RIGHT JUSTIFIED DECIMAL NUMBER
	POP	P,B
	POP	P,A
	PUSHJ	P,MSG		; AND THEN THE MESSAGE
	MOVEI	M,[EXP 0]
	JRST	ERRLY1		;JUMP TO FINISH LINE

ERRLA2:	PUSH	P,A		;DECIMAL HALFWORDS WERE A WIERD IDEA
	PUSH	P,WD
	SETO	WD,		;COUNT, DON'T PRINT
	HLRZ	N,A
	PUSHJ	P,DECPRJ	;COUNT LEFT HALF CHARACTERS
	HRRZ	N,-1(P)
	PUSHJ	P,DECPRJ	;DON'T PRINT THAT EITHER, JUST COUNT CHARACTERS
	MOVE	N,COLCNT	;NOW COMPUTE HOW TO FORMAT IT
	SUBI	N,^D10		;WANT TO END UP IN COLUMN 15., ACCOUNT FOR ., AND .
	POP	P,WD
	SKIPLE	N
	PUSHJ	P,SPACE
	SOJG	N,.-1
	POP	P,A
	HLRZ	N,A
	PUSHJ	P,DECPRT
	MOVEI	M,[ASCIZ /.,/]
	PUSHJ	P,MSG	
	HRRZ	N,A
	PUSHJ	P,DECPRT
	HRRZ	M,ERRTM1(D)
	PUSHJ	P,MSG
	JRST	ERRLY2
ERRLA1:	PUSH	P,M
	MOVEI	M,[ASCIZ /  /]
	PUSHJ	P,MSG		;LINE THINGS UP
	POP	P,M
	PUSHJ	P,OCTPRJ	;OUTPUT OCTAL NUMBER
	PUSHJ	P,MSG		;OUTPUT MESSAGE
ERRLY1:	TLNN	B,140000
	JRST	ERRLY2
	MOVEM	A,TEMP
	MOVE	A,[%CVUPT]
IFG NCPUS-1,<
	TLNE	B,20000
	ADDI	A,2
>
IFG NCPUS-2,<
	TLNE	B,10000
	ADDI	A,4
>
IFG NCPUS-3,<
	TLNE	B,4000
	ADDI	A,6
>
IFN NCPUS-4,<
	TLNE	B,2000
	ADDI	B,10
>
IFN NCPUS-5,<
	TLNE	B,1000
	ADDI	A,12
>
	TLNE	B,400
	MOVE	A,[%CNSUP]
	PUSHJ	P,FGETTB	;TRY TO GET UPTIME
	 JRST	[MOVE A,XUPTIM 	;DEFAULT TO TOTAL
		 PUSHJ P,GETA	;SYSTEMS UPTIME
		 JRST .+1 ]
	EXCH	A,TEMP
	IMULI	A,^D60
	TLNE	B,40000
	IMUL	A,TCKSEC	;REMEMBER ENGLAND !
	PUSHJ	P,CMPDFA
	MOVEI	M,[ASCIZ \/Second)\]
	TLNE	B,40000
	MOVEI	M,[ASCIZ \/Minute)\]
	PUSHJ	P,MSG
ERRLY2:	PUSHJ	P,CRLF		;END LINE
ERRLX1:	AOBJN	D,ERRLP1	;LOOP BACK UNTIL DONE

;PRINT LAST STOPCD INFORMATION
	MOVE	A,[%SYSPC]	;GET LAST STOPCODE DATA
	PUSHJ	P,GETZ		;GET IT OR A ZERO
	JUMPE	A,NSTOPC	;THERE WAS NO STOPCD
	PUSH	P,A		;SAVE STOPCD INFO
	MOVE	A,[%SYSCD]	;STOPCD NAME IN 7.03 OR LATER
	PUSHJ	P,GETZ		;GET IT OR ZERO
	SKIPN	BP,A		;IS THERE A NEW NAME?
	HLLZ	BP,(P)		;NO, COPY OLD STOP CODE NAME
	PUSHJ	P,SIXBP1	;PRINT SIXBIT CODE
	MOVEI	M,[ASCIZ / was last STOPCD, type=/]
	PUSHJ	P,MSG		;PRINT NAME
	JUMPN	A,[POP P,A	;IF 7.03 OR LATER
		   MOVE A,[%SYSTY] ;STOPCD TYPE IS STORED HERE
		   PUSHJ P,GETZ	;GET IT
		   JRST STOPTY]	;AND PRINT THE RESULTS
	POP	P,A		;RESTORE STOPCD INFO
	HRRZ	A,A		;ISOLATE ADDRESS
	PUSHJ	P,PEEKA		;GET STOPCD TYPE
	LDB	A,[POINT 3,A,12] ;GET TYPE ( IGNORE LONG FORM BIT )
STOPTY:	MOVE	M,STOPT(A)	;GET TYPE OF STOPCD
	PUSHJ	P,MSG		;PRINT IT AND
	PUSHJ	P,CRLF		;A NEW LINE
NSTOPC:
REPEAT 0,<			;HISTORICAL STUFF

	TLNN	F,FL.DSK	;SEE IF DISK MODE
	JRST	ERRXIT		;NO--SKIP CRASH STUFF
	MOVE	A,XPCMA		;GET PC AND MA (FROM SWITCHES)
	PUSHJ	P,GETZ		;FROM MONITOR
	JUMPE	A,ERRLX0	;NOT USEABLE
	MOVEM	A,D		;SAVE FOR LATER
	PUSHJ	P,CRLF		;START NEW LINE
	MOVEI	M,[ASCIZ /PC=/]
	HLRZ	N,A		;GET PC
	PUSHJ	P,MSGOCT	;OUTPUT PC
	MOVEI	M,[ASCIZ /  MA=/]
	HRRZ	N,A		;GET MA
	PUSHJ	P,MSGOCT	;OUTPUT MA
	MOVE	A,XPIIP		;GET PI SYSTEM
	PUSHJ	P,GETZ		;FROM MONITOR
	ANDI	A,77400		;MASK TO IN-PROGRESS
	JUMPE	A,ERRLXX	;SKIP IF NONE
	MOVSI	B,-^D8		;SET UP COUNT
	MOVEI	M,[ASCIZ /  PIs in prog=/]
ERRLPX:	AOBJP	B,ERRLXX	;COUNT EACH CHANNEL
	LSH	A,1		;POSITION BITS
	TRNN	A,100000	;SEE IF ON
	JRST	ERRLPX		;LOOP IF NOT
	HRRZ	N,B		;GET CHANNEL NUMBER
	PUSHJ	P,MSGDEC	;OUTPUT NUMBER
	MOVEI	M,[ASCIZ /,/]
	JRST	ERRLPX		;LOOP FOR MORE
ERRLXX:	PUSHJ	P,CRLF		;END LINE

ERRLX0:	MOVE	A,MONVER	;IS MONITOR .GT. 5.04?
	CAIGE	A,50400
	JRST	ERRLX2		;NO, "JOB" IS 150
	MOVEI	A,20		;YES, "JOB" IS 20.  GET IT.
	PUSHJ	P,PEEKA
	TLNN	A,-1		;DUAL PROCESSOR?
	JRST	ERRLX3		;NO, PRINT C(JOB)
	MOVEI	M,[ASCIZ /Job (CPU1,,CPU0)  /]
	HLRZ	N,A		;GET CPU1 JOB
	PUSHJ	P,MSGDEC
	MOVEI	M,[ASCIZ /,,/]
	HRRZ	N,A		;GET CPU0 JOB
	PUSHJ	P,MSGDEC	;PRINT IT
	JRST	ERRLX4		;DONE WITH C(JOB)

ERRLX2:	MOVEI	A,150		;GET JOB (FOR MONITOR OLDER THAN 5.04)
	PUSHJ	P,PEEKA		;FROM MONITOR
ERRLX3:	MOVE	N,A		;MOVE TO OUTPUT
	MOVEI	M,[ASCIZ /job  /]
	PUSHJ	P,MSGDEC	;OUTPUT IT
ERRLX4:	MOVEI	A,30		;READ LOCATION 30
	PUSHJ	P,PEEKA		;FROM MONITOR
	MOVE	N,A		;SETUP FOR OUTPUT
	MOVEI	M,[ASCIZ /	C(30)  /]
	PUSHJ	P,MSGOCT	;OUTPUT IT
	PUSHJ	P,CRLF		;NEW LINE
	MOVE	A,XAPRCN	;GET APR CONI
	PUSHJ	P,GETZ		;FROM CRASH
	ANDI	A,7		;GET CHANNEL OF APR
	ADDI	A,40(A)		;GET 40+2*A
	PUSHJ	P,PEEKA		;LOOK IN CORE AS JSR FOR CLOCK
	ANDI	A,-1		;CLEAR JUNK
	CAML	A,DSKFLG	;MAKE SURE IT IS OK
	JRST	ERRNCL		;NO--SKIP THIS LINE
	PUSHJ	P,PEEKA		;GET PC AT LAST CLOCK
	MOVE	N,A		;MOVE TO OUTPUT
	MOVEI	M,[ASCIZ /PC at trap  /]
	PUSHJ	P,MSGOCT	;OUTPUT LINE
	PUSHJ	P,CRLF		;AND END LINE
	PUSHJ	P,GETBTH	;GET IT AND IT-1
	  JRST	ERRNCL		;SKIP IF JUNK
	MOVE	N,C		;GET -1
	MOVEI	M,[ASCIZ /C(PCT-1)  /]
	PUSHJ	P,MSGOCT	;OUTPUT IT
	MOVE	N,A		;GET IT
	MOVEI	M,[ASCIZ /	C(PCT)	/]
	PUSHJ	P,MSGOCT	;PRINT IT
	PUSHJ	P,CRLF		;END OF LINE

ERRNCL:	HLRZ	A,D		;GET PC
	PUSHJ	P,GETBTH	;GET IT AND IT-1
	  JRST	ERRNPC		;SKIP IF BAD
	MOVE	N,C		;GET -1
	MOVEI	M,[ASCIZ /C(PC-1)   /]
	PUSHJ	P,MSGOCT	;OUTPUT IT
	MOVE	N,A		;GET IT
	MOVEI	M,[ASCIZ /	C(PC)   /]
	PUSHJ	P,MSGOCT	;OUTPUT IT
	PUSHJ	P,CRLF		;END LINE

ERRNPC:	HRRZ	A,D		;GET MA
	PUSHJ	P,GETBTH	;GET IT AND IT-1
	  JRST	ERRNMA		;SKIP IF BAD
	MOVE	N,C		;GET MA-1
	MOVEI	M,[ASCIZ /C(MA-1)   /]
	PUSHJ	P,MSGOCT	;OUTPUT IT
	MOVE	N,A		;GET MA
	MOVEI	M,[ASCIZ /	C(MA)   /]
	PUSHJ	P,MSGOCT	;OUTPUT IT
	PUSHJ	P,CRLF		;END LINE

ERRNMA:

> ;END REPEAT 0 OF HISTORICAL STUFF

ERRXIT:	CAIN	WD,L.ERR	;SEE IF JUST THIS DISPLAY
	JRST	FINIS		;YES--END
	JRST	DP		;NO--PROCEED

ERRTB1:
XMNVER:	EXP	%CNVER
	EXP	%SYERR
	EXP	%SYDEL		;DISABLED ERROR COUNT
	EXP	%CNPOK
	EXP	%CNPUC
	EXP	%NSTPE
	EXP	%NSSPE
	EXP	%NSMPC
	EXP	%NSMPA
	EXP	%NSMPW
	EXP	%NSMPP
	EXP	%NSEPO
	EXP	%NSEPR
	EXP	%NSABC
	EXP	%NSABA
	EXP	%SYNCP
	EXP	%SCNRI
	EXP	%SCNXI
	EXP	%SCNEI
DEFINE	EACHCPU(CPUN),<
	EXP	%CVTUC+CPUN+CPUN
>
	ALLCPUS
DEFINE	EACHCPU(CPUN),<
	EXP	%CVTJC+CPUN+CPUN
>
	ALLCPUS
DEFINE	EACHCPU(CPUN),<		;
	EXP	%CVNRI
>
	ALLCPUS
DEFINE	EACHCPU(CPUN),<		;
	EXP	%CVNXI
>
	ALLCPUS
DEFINE	EACHCPU(CPUN),<		;
	EXP	%CVNEI
>
	ALLCPUS
DEFINE	EACHCPU(CPUN),<
	EXP	%CVFBI+CPUN+CPUN
>
	ALLCPUS
DEFINE	EACHCPU(CPUN),<
	EXP	%CVFBO+CPUN+CPUN
>
	ALLCPUS
DEFINE	EACHCPU(CPUN),<
	EXP	%CVSBI+CPUN+CPUN
>
	ALLCPUS
DEFINE	EACHCPU(CPUN),<
	EXP	%CVSBO+CPUN+CPUN
>
	ALLCPUS
	EXP	%SYNDS		;NUMBER OF DEBUG STOPCDS
	EXP	%SYNJS		;NUMBER OF JOB STOPCDS
	EXP	%SYNCS		;NUMBER OF CPU STOPCDS
ERRTL1==.-ERRTB1

;ERROR PRINT MESSAGES:
;	BIT 0 - PRINT COUNT IN OCTAL
;	BIT 1 - PRINT COUNT AS DECIMAL HALF WORDS
;	BIT 2 - PRINT AVERAGE NUMBER OF OCCURRENCES/SECOND
;	BIT 3 - PRINT AVERAGE NUMBER OF OCCURRENCES/MINUTE
;	BIT 4 - PRINT FOR CPU1
;	BIT 5 - PRINT FOR CPU2
;	BIT 6 - PRINT FOR CPU3
;	BIT 7 - PRINT FOR CPU4
;	BIT 8 - PRINT FOR CPU5
;	BIT 9 - USE SYSUPT, NOT .C0UPT
;	BIT 11 - DATA IS FROM A CDB GETTAB SUBTABLE	;

ERRTM1:
    1B0+[ASCIZ / = Monitor version/]
	[ASCIZ /. = System wide hardware error count/]
	[ASCIZ /. = Number of errors for which logging was disabled/]
    1B0+[ASCIZ / = Address of last POKE uuo/]
    1B1+[ASCIZ /. = lh=job that POKEd, rh=# of POKEs/]
	[ASCIZ /. = user memory parity errors/]
	[ASCIZ /. = spurious memory parity errors/]
	[ASCIZ /. = continues after memory parity errors/]
    1B0+[ASCIZ / = address of last memory parity error/]
    1B0+[ASCIZ / = contents of last memory parity error/]
    1B0+[ASCIZ / = PC of last memory parity error/]
    1B2+[ASCIZ /. = EXEC PDL overflows (/]
    1B2+[ASCIZ /. = recovered EXEC PDL overflows (/]
	[ASCIZ /. = address breaks/]
    1B0+[ASCIZ /. = switches on last address break/]
    1B3+1B9+[ASCIZ /. = Number of commands processed (/]
    1B2+1B9+[ASCIZ /. = Total number of characters received (/]	;
    1B2+1B9+[ASCIZ /. = Total number of characters transmitted (/]	;
    1B2+1B9+[ASCIZ /. = Total number of characters echoed (/]	;
DEFINE	EACHCPU(CPUN),<
	ZZZ==1B2
	IFG CPUN,<ZZZ==ZZZ!1B<4+CPUN-1>>
    ZZZ+[ASCIZ /. = Number of UUOs executed on CPU'CPUN (/]
>
	ALLCPUS
DEFINE	EACHCPU(CPUN),<
	ZZZ==1B2
	IFG CPUN,<ZZZ==ZZZ!1B<4+CPUN-1>>
    ZZZ+[ASCIZ /. = Number of context switches on CPU'CPUN (/]
>
	ALLCPUS
DEFINE	EACHCPU(CPUN),<		;
	ZZZ==1B2+1B11
	IFG CPUN,<ZZZ==ZZZ!1B<4+CPUN-1>>
    ZZZ+[ASCIZ /. = Number of characters received on CPU'CPUN (/]
>
	ALLCPUS
DEFINE	EACHCPU(CPUN),<		;
	ZZZ==1B2+1B11
	IFG CPUN,<ZZZ==ZZZ!1B<4+CPUN-1>>
    ZZZ+[ASCIZ /. = Number of characters transmitted on CPU'CPUN (/]
>
	ALLCPUS
DEFINE	EACHCPU(CPUN),<		;
	ZZZ==1B2+1B11
	IFG CPUN,<ZZZ==ZZZ!1B<4+CPUN-1>>
    ZZZ+[ASCIZ /. = Number of characters echoed on CPU'CPUN (/]
>
	ALLCPUS
DEFINE	EACHCPU(CPUN),<
	ZZZ==1B2
	IFG CPUN,<ZZZ==ZZZ!1B<4+CPUN-1>>
    ZZZ+[ASCIZ /. = Number of disk reads executed on CPU'CPUN (/]
>
	ALLCPUS
DEFINE	EACHCPU(CPUN),<
	ZZZ==1B2
	IFG CPUN,<ZZZ==ZZZ!1B<4+CPUN-1>>
    ZZZ+[ASCIZ /. = Number of disk writes executed on CPU'CPUN (/]
>
	ALLCPUS
DEFINE	EACHCPU(CPUN),<
	ZZZ==1B2
	IFG CPUN,<ZZZ==ZZZ!1B<4+CPUN-1>>
    ZZZ+[ASCIZ /. = Number of swap reads executed on CPU'CPUN (/]
>
	ALLCPUS
DEFINE	EACHCPU(CPUN),<
	ZZZ==1B2
	IFG CPUN,<ZZZ==ZZZ!1B<4+CPUN-1>>
    ZZZ+[ASCIZ /. = Number of swap writes executed on CPU'CPUN (/]
>
	ALLCPUS
	[ASCIZ /. = Number of DEBUG STOPCDs/]
	[ASCIZ /. = Number of JOB STOPCDs/]
	[ASCIZ /. = Number of CPU STOPCDs/]
SUBTTL "P" - PERFORMANCE OF DISKS INCLUDING ERRORS

DP:	PUSHJ P,CRLF
	LDB	D,DSKLEV	;DISK LEVEL NO. FROM STATES WORD
	SKIPE	D		;BEFORE 5.01?
	SKIPE	TNFRTY		;NO, SEE IF 10/40N
	JRST	SWFIN		;YES--SKIP DISK PERFORMANCE
	CAIN WD,L.DPO		;"P" TYPED?
	PUSHJ	P,THISIS	;YES--GIVE SYSTEM HEADER
	MOVEI M,[ASCIZ .
Disk performance statistics:
.]
	PUSHJ P,MSG
	SETZM CURFS
	TRZ	F,FR.NFS	;CLEAR "NOT IN A F/S" CODE FLAG
	MOVEI M,[ASCIZ .Unit or F/S
	BR	BW	DR	DW	XR	XW	MR	MW
.]
	PUSHJ P,MSG

	MOVE	A,XSYSST	;SYS STR LIST POINTER
	PUSHJ	P,GETA
FLFSL:	HLRZ	C,A
	JUMPE	C,FLNFS		;IF 0, GO TO UNITS NOT IN ANY F/S
	MOVEM	C,CURFS		;C GETS CLOBBERED LATER
	MOVEI	A,STRNAM(C)
	PUSHJ	P,PEEKA
	JUMPE	A,FLFSN		;GET NEXT STRUCTURE IF STRUCTURE NAME IS NULL;
	PUSHJ	P,CRLF		;MAKE IT EASIER TO PICK OUT A STR
	PUSHJ	P,SIXBP		;TYPE F/S NAME
	MOVEI	M,[ASCIZ/:/]	;PRETTY IT UP
	PUSHJ	P,MSG		;PRINT IT OUT
	PUSHJ	P,TAB
	MOVEI	A,STRTAL(C)	;GET BLOCKS LEFT
	PUSHJ	P,PEEKA
	MOVE	N,A
	PUSHJ	P,DECPRT	;PRINT IT
	MOVEI	M,[ASCIZ . Free
.]
	PUSHJ	P,MSG
;UNIT STUFF HERE

	MOVEI	A,STRUNI(C)
	PUSHJ	P,PEEKA
FLUNL:	HLRZ	D,A		;D NOW POINTS TO THE UDB
	JUMPE	D,FLFSN		;DONE ALL UNITS?
FLUNL1:	MOVEM	D,UNIBLK	;SET POINTER FOR USE BY ERROR STATISTICS CODE
	movsi	n,-6		;6 read write varibles
	hrri	n,unibrc(d)	;start at unibrc
flu000:	hrrz	a,n		;get the address
	pushj	p,peeka		;get the count
	jumpn	a,flu010	;non zero then report
	aobjn	n,flu000	;try next entry
	CALL	GETDES		;GET UNIDES
	tlne	a,210000	;ofline zero mount
	pjrst	flunn		;next unit
	ldb	a,[point 2,a,8]	;uniust field
	jumpn	a,flunn		;unit is not mounted
flu010:	PUSHJ	P,SPACE		;MAKE IT EASIER TO PICK OUT A UDB
	MOVEI	A,UNINAM(D)	;GET PHYSICAL UNIT NAME
	PUSHJ	P,PEEKA
	MOVEM	A,DSKBLK	;SAVE NAME IN CASE WE MUST DO DSKCHR UUO
	PUSHJ P,SIXBP
	MOVEI M,[ASCIZ /(/]
	PUSHJ P,MSG
	MOVEI A,UNIHID(D)
	PUSHJ	P,PEEKA
	PUSHJ P,SIXBP
	MOVEI M,[ASCIZ /) /]	;TAKE OUT :	
	SKIPE	DOALT		;DOING ALTERNATE?
	JRST	FLSEEK		;YES,DON'T PRINT "FREE" AGAIN
	CALL	GETTAL		;GET UNITAL
	MOVE	N,A
	PUSHJ P,MSGDEC
	MOVEI M,[ASCIZ . Free, .]
FLSEEK:	PUSHJ P,MSG		;
	MOVEI A,UNIUSC
	PUSHJ P,GETUDB
	MOVEI A,UNIMSC
	ADD A,UNIBLK
	PUSHJ P,PEEKA
	ADD N,A
	MOVEI M,[ASCIZ / Seeks
/]
	PUSHJ P,DECMSG
	MOVSI C,-UDTBL
FLUNL3:	HRRZ	A,UDTAB(C)
	CAIE	A,UNIXRA	;THIS OFFSET CHANGED IN 50634
	JRST	FLUNL0		;NO SKIP UPDATE
	CALL	GETXRA		;GET UNIXRA
	SKIPA	N,A		;SKIP GET UDB
FLUNL0:	PUSHJ P,GETUDB
	HLRE A,UDTAB(C)
	JUMPE A,FLUNLA
	JUMPL A,FLDIFF
	MOVE A,STATES
	TLNN A,(CANXRC)
	MOVEI N,0
	PUSH P,N
	TLZ N,-1
	PUSHJ P,TAB
	PUSHJ P,DECPRT
	POP P,N
	HLRZ N,N
	JRST FLUNLA

FLDIFF:	MOVNS A
	ADD A,UNIBLK
	PUSHJ	P,PEEKA
	SUB N,A
FLUNLA:	PUSHJ P,TAB
	PUSHJ P,DECPRT
	AOBJN C,FLUNL3
FLUN2:	PUSHJ P,CRLF
	TLZ F,FL.NBK+FL.DEV
	PUSHJ	P,SETDES	;GET DSKCHR BITS
	TLZ A,BITMSK
	JUMPE A,FLUN4
	PUSHJ P,SPACE
	TLO F,FL.NBK
	MOVSI C,-BITTL
FLBTL:	SKIPGE A
	PUSHJ P,PRTBIT
	LSH A,1
	AOBJN C,FLBTL
FLUN4:	LDB C,DSKLEV		;DISK LEVEL NO.
	CAILE	C,1		;5.01, 5.02 OR EARLIER?
	JRST	FLUN5		;NO, MUST BE 5.03 OR LATER

;HERE TO DO 5.01, OR 5.02 UNIT ERROR INFO
	MOVSI C,-UERRTL
FLUNL4:	HLRZ A,UERRT1(C)
	PUSHJ P,GETUDB
	HRRZ M,UERRT1(C)
	XCT UERRT2(C)
	PUSHJ P,@UERRT3(C)
	AOBJN C,FLUNL4
	JRST	FLUNN0		;FINISHED

;HERE TO DO 5.03 OR LATER UNIT ERROR INFO
FLUN5:	MOVSI	C,-UER2TL
FLUNL5:	HLRZ	A,UER2T1(C)
	PUSHJ	P,GETUDB
	HRRZ	M,UER2T1(C)
	XCT	UER2T2(C)
	PUSHJ	P,@UER2T3(C)
	AOBJN	C,FLUNL5
FLUNN0:	TLNE F,FL.NBK+FL.DEV
	PUSHJ P,CRLF
	SKIPE	A,DOALT		;ARE WE DOING ALTERNATE PATH?
	 JRST FLMAIN		;YES, GO BACK TO MAIN FOR NEXT
	SKIPN	FTDUAL		;DUAL PORTED SUPPORT?
	JRST	FLUNN		;NO, SKIP ALTERNATE PATH LOGIC
	MOVEI	A,UNI2ND(D)	;GO GET ALTERNATE PART WORD
	PUSHJ	P,PEEKA		;0 IF NOT DUAL PORTED,
				;0,,ALTERNATE UDB ADDRESS IF MAIN
				;-1,,MAIN UDB ADDRESS IF ALTERNATE
				;400000,,ALTERNATE IF MAIN ON OTHER CPU
				;400001,,MAIN IF ALTERNATE ON OTHER CPU
	JUMPE	A,FLUNN		;GO IF NOT DUAL PORTED
	TLNN	A,1		;SKIP IF DOING ALTERNATE NOW
	 JRST FLALT		;SET UP TO DO ALTERNATE

FLUNN:	TRNE	F,FR.NFS
	JRST	FLNFS2
flunn2:	MOVEI	A,UNISTR(D)
	PUSHJ	P,PEEKA
	JRST FLUNL

FLFSN:	MOVE	C,CURFS
	MOVEI	A,STRSYS(C)
	PUSHJ	P,PEEKA
	JRST FLFSL		;LOOP FOR NEXT STRUCTURE

FLALT:	AOS	DOALT		;REMEMBER DOING ALTERNATE
	MOVEM	D,MAIND		;REMEMBER MAIN UDB (D)
	HRLZ	A,A		;PUT UDB (OF ALT) ADDR IN LEFT
	JRST	FLUNL		;GO THROUGH THIS LOOP AGAIN

FLMAIN:	MOVE	D,MAIND		;RESTORE D
	SETZM	DOALT		;RESET ALTERNATE FLAG
		JRST FLUNN
SETDES:	TLNE	F,FL.DSK	;DISK MODE?
	JRST	SETDE2		;YES
	MOVE	A,[XWD 1,DSKBLK]
	DSKCHR	A,		;NOTE! THIS IS THE ONLY WAY TO GET THE "SWP" BIT
	SETZ	A,
SETDE1:	HLLZ	A,A		;CLEAR OUT RH
	POPJ	P,0

SETDE2:	CALL	GETDES		;GET UNIDES
	HLLZ	B,A		;SAVE UNIDES
	SKIPN	C,CURFS		;GET F/S
	JRST	SETDE1		;RETURN IF NOT IN A F/S
	MOVEI	A,STRMNT(C)
	PUSHJ	P,PEEKA
	CAIN	A,0		;ZMT?
	TLO	B,UNPZMT
	MOVEI	A,STRJOB(C)
	PUSHJ	P,PEEKA
	CAILE	A,0		;SAF?
	TLO	B,UNPSAF
	HLLZ	A,B
	POPJ	P,0
;NOTE THAT SWP IS NEVER ON IF /X

;CODE FOR UNITS NOT IN ANY F/S
FLNFS:	TRO	F,FR.NFS!FR.NFP
	SETZM	CURFS
	MOVE	A,XSYSUN	;SYSTEM UNIT LIST POINTER
	PUSHJ	P,GETA
FLNFS1:	HLRZ	D,A
	JUMPE	D,FILEXI
	MOVEI	A,UNISTR(D)
	PUSHJ	P,PEEKA
	JUMPE	A,FLNFS3	;JUMP IF NOT IN A F/S
FLNFS2:	MOVEI	A,UNISYS(D)
	PUSHJ	P,PEEKA
	JRST	FLNFS1
FLNFS3:	MOVEI	M,[ASCIZ .Units not in any File Structure:
.]
	TRZE	F,FR.NFP
	PUSHJ	P,MSG
	JRST	FLUNL1
FILEXI:
SW:	MOVEI	M,[ASCIZ!
Active swapping/paging statistics:
Class	Unit	Swap	Swap	Page	Page	Used(!]	;EXPANDED HEADER
	PUSHJ	P,MSG
	MOVEI	M,[ASCIZ/K)
/]
	SKIPE	CPKI10
	MOVEI	M,[ASCIZ/P)
/]
	PUSHJ	P,MSG
	MOVEI	M,[ASCIZ/		Reads	Writes	Reads	Writes
/]
	PUSHJ	P,MSG
	MOVE	A,XSWPUN
	PUSHJ	P,GETA
	MOVEM	A,SWPUNI
	HLRZ	D,A
SWLP1:	MOVEI	M,[ASCIZ/  /]
	PUSHJ	P,MSG
	MOVEI	A,UNIK4S(D)
	MOVE	B,MONVER
	PUSHJ	P,PEEKA
	LDB	N,[POINT 3,A,22]
	PUSHJ	P,DECTAB
	PUSHJ	P,PRTSRW	;PRINT SWAP STATISTICS
	MOVEI A,UNIFKS(D)
	PUSHJ	P,PEEKA
	MOVEM A,N
	MOVEI A,UNIK4S(D)
	MOVE	B,MONVER
	CAILE	B,70207
	MOVEI	A,111(D)
	PUSHJ	P,PEEKA
	MOVE	B,MONVER
	CAILE	B,70207
	TLZA	B,-1
	ANDI A,MSKK4S
	SKIPE	CPKI10		;A KA10
	LSH	A,1		;NO SHIFT ONE MORE
	MOVEM A,TEMP
	SUBB A,N
	MOVEI M,[ASCIZ /	/]
	PUSHJ P,PRPCNT
	SKIPN	FTDUAL		;DUAL PORT SUPPORT?
	JRST	SWLP2		;NO, SKIP ALTERNATE PORT LOGIC
	MOVEI	A,UNI2ND(D)	;ALTERNATE PORT
	PUSHJ	P,PEEKA		;PEEK IT
	JUMPE	A,SWLP2		;NONE,DON'T OUTPUT
	PUSH	P,D		;SAVE PRIME PORT ADDR
	MOVE	D,A		;SET UP FOR ALTERNATE UDB
	PUSHJ	P,TAB		;BE NEAT
	PUSHJ	P,PRTSRW	;PRINT SWAP STATISTICS
	PUSHJ	P,CRLF		;NEXT LINE
	POP	P,D		;RESTORE MAIN UDB ADDR
SWLP2:	MOVEI A,UNISWP(D)	;GET NEXT UDB
	PUSHJ	P,PEEKA
	HLRZ D,A
	JUMPN D,SWLP1
	PUSHJ P,CRLF
;HERE TO CHECK FOR SWAP READ ERRORS
	MOVE A,XSWPER
	PUSHJ P,GETZ
	JUMPE A,SWFIN
	MOVE D,A
	MOVEI M,[ASCIZ /
Swap errors: /]
	PUSHJ P,MSG
	HLRZ N,D
	PUSHJ P,DECTAB
	MOVEI M,[ASCIZ / CHK/]
	TRZE D,IOIMPM
	PUSHJ P,MSG
	MOVEI M,[ASCIZ / DEV/]
	TRZE D,IODERR
	PUSHJ P,MSG
	MOVEI M,[ASCIZ / DAT/]
	TRZE D,IODTER
	PUSHJ P,MSG
	MOVEI M,[ASCIZ /   K Lost: /]
	SKIPE	CPKI10
	MOVEI M,[ASCIZ /   P Lost: /]
	HRRZ N,D
	TRZ	N,770000	;**[6] FIRST 3 ARE NOT NEEDED,BUT
	PUSHJ P,MSGDEC
	PUSHJ P,CRLF
SWFIN:	JRST FINIS

;SUBROUTINE TO PRINT SWAP READS/WRITES FOR A UNIT

PRTSRW:	MOVEI	A,UNINAM(D)	;UNIT NAME
	PUSHJ	P,PEEKA		;PEEK FOR IT
	PUSHJ	P,SIXBP		;SIXBIT OUTPUT
	PUSHJ	P,TAB		;BE NEAT
	MOVEI	A,UNIICT(D)	;# BLOCKS SWAPPED IN
	PUSHJ	P,PEEKA		;GET IT
	MOVE	N,A		;SET UP FOR DECTAB
	PUSHJ	P,DECTAB	;DECIMAL OUTPUT
	MOVEI	A,UNIOCT(D)	;# BLOCKS SWAPPED OUT
	PUSHJ	P,PEEKA		;GO PEEK
	MOVE	N,A		;SET UP FOR DECTAB
	PUSHJ	P,DECTAB	;DO OUTPUT
	MOVEI	A,UNIPCI(D)	;# BLOCKS SPAGED IN
	PUSHJ	P,PEEKA		;GET IT
	MOVE	N,A		;SET UP FOR DECTAB
	PUSHJ	P,DECTAB	;DECIMAL OUTPUT
	MOVEI	A,UNIPCO(D)	;# BLOCKS PAGED OUT
	PUSHJ	P,PEEKA		;GO PEEK
	MOVE	N,A		;SET UP FOR DECPRT
	PJRST	DECPRT		;DO OUTPUT
	SUBTTL ROTINES TO SETDES UNITAL AND UNIXRA FROM THE UDB

;ALL USE D TO STORE THE UDB ADDRESS FROM UNIBLK
;CLOBBER B AND RETURN THE VALUE IN A

GETTAL:	MOVE	D,UNIBLK	;GET UDB ADDRESS
	MOVEI	A,UNITAL(D)	;AND ENTRY
	CALL	UPDADR		;UPDATE THE ADDRESS
	LDB	B,DSKLEV	;GET VERSION
	CAIG	B,1		;SEE HOW OLD
	MOVEI	A,UNITL1(D)	;REUPDATE
	PJRST	PEEKA		;AND GET THE VALUE

GETDES:	MOVE	D,UNIBLK	;GET THE UDB ADDRESS
	MOVEI	A,UNIDES(D)	;GET THE ENTRY
	CALL	UPDADR		;UPDATE THE ADDRES
	LDB	B,DSKLEV	;GET THE DISK VERSION
	CAIG	B,1		;SEE HOW OLD
	MOVEI	A,UNIDE1(D)	;SO CHANGE
	PJRST	PEEKA		;AND GET IT

GETXRA:	MOVE	D,UNIBLK	;GET UDB ADDRES
	MOVEI	A,UNIXRA(D)	;AND ENTRY
	hrrz	b,monver	;get monitor version
	cail	b,50750		;if 602 then
	subi	a,1		;one less
	CALL	UPDADR		;UPDATE THE ADDRESS
	PJRST	PEEKA		;AND PEEK


UPDADR:	HRRZ	B,MONVER	;GET VERSION
	CAIL	B,50634		;HERE UNITAL XRA AND DES BECAME 3 LARGER
	ADDI	A,3		;SO UPDATE
	TXNE	F,FR.VMF	;IF VM THEN
	ADDI	A,2		;ADD ANOTHER 2
	RETURN

	;OFFSET IN A GETS CONTENTS INTO N

GETUDB:	ADD A,UNIBLK
	PUSHJ	P,PEEKA
	MOVE N,A
	POPJ P,
PRTBIT:	MOVE	M,BITTAB(C)	;NOW A LITERAL
	PUSHJ P,MSG
	PUSHJ P,SPACE
	POPJ P,0

PRTUED:	JUMPE N,CPOPJ
	PUSH P,M
	MOVEI M,[ASCIZ / Errors: /]
	TLON F,FL.DEV
	PUSHJ P,MSG
	POP P,M
	PUSHJ P,MSGDEC
	PUSHJ	P,PERIOD	;NOW EVERYBODY KNOWS IT IS DECIMAL
	JRST SPACE

PRTUEO:	JUMPE N,CPOPJ
	PUSH P,M
	MOVEI M,[ASCIZ / Errors: /]
	TLON F,FL.DEV
	PUSHJ P,MSG
	POP P,M
	PUSHJ P,MSG
	PUSHJ P,OCTPRT
	JRST SPACE

BITTAB:	[ASCIZ /Reread home blocks/]	;RHB
	[ASCIZ /Offline/]		;OFL
	[ASCIZ /Hardware write protect/] ;HWP
	[ASCIZ /Software write protect/] ;SWP
	[ASCIZ /Single access/]		;SAF
	[ASCIZ /Zero mount count/]	;ZMT
	[ASCIZ /Private/]		;PRF
	[ASCIZ /Pack not mounted/]	;PNM
	[ASCIZ /Down/]			;DWN
	[ASCIZ /Multiple SAT blocks/]	;MSB
	[ASCIZ /No new accesses/]	;NNA
BITTL=.-BITTAB

BITMSK=77	;CLEAR, LEAVING BITS IN 777700,,0

UDTAB:	XWD 0,UNIBRC
	XWD 0,UNIBWC
	XWD 0,UNIDRC
	XWD 0,UNIDWC
	XWD 1,UNIXRA
	XWD -UNIICT,UNIMRC
	XWD -UNIOCT,UNIMWC
UDTBL==.-UDTAB
;5.01 AND 5.02 MONITOR ERROR INFO TABLES:

UERRT1:	XWD UNIHCT,[ASCIZ /HDEV:/]
	XWD UNIHCT,[ASCIZ /HDAT:/]
	XWD UNISCT,[ASCIZ /SDEV:/]
	XWD UNISCT,[ASCIZ /SDAT:/]
	XWD UNIPCT,[ASCIZ /HPOS:/]
	XWD UNIPCT,[ASCIZ /SPOS:/]
	XWD UNIMCT,[ASCIZ /SER:/]
	XWD UNIMCT,[ASCIZ /RER:/]
	XWD UNIMCT,[ASCIZ /CER:/]
	XWD UNIERR,[ASCIZ /HERR status:/]
	XWD UNISOF,[ASCIZ /SERR status:/]
	XWD UNIHBN,[ASCIZ /LBN:/]
UERRTL==.-UERRT1

UERRT2:	HLRZS N
	HRRZS N
	HLRZS N
	HRRZS N
	HLRZS N
	HRRZS N
	LDB N,[POINT 12,N,11]
	LDB N,[POINT 12,N,23]
	ANDI N,7777
	JFCL
	JFCL
	JFCL

UERRT3:	PRTUED
	PRTUED
	PRTUED
	PRTUED
	PRTUED
	PRTUED
	PRTUED
	PRTUED
	PRTUED
	PRTUEO
	PRTUEO
	PRTUEO
;5.03 AND LATER MONTIORS ERROR INFO TABLES:


UER2T1:	XWD UNIHCT,[ASCIZ /Hard Device:/]	;HDEV
	XWD UNIHCT,[ASCIZ /Hard Data:/]		;HDAT
	XWD UNISCT,[ASCIZ /Soft Device:/]	;1DEV
	XWD UNISCT,[ASCIZ /Soft Data:/]		;1DAT
	XWD UNIECT,[ASCIZ /Retries:/]		;RETRIES
	XWD UNIMCT,[ASCIZ /SAT:/]		;SER
	XWD UNIMCT,[ASCIZ /RIB:/]		;RER
	XWD UNIMCT,[ASCIZ /Checksum:/]		;CER
	XWD UNIERR,[ASCIZ /2nd CONI:/]		;2CONI
	XWD UNISOF,[ASCIZ /1st CONI:/]		;1CONI
	XWD UNIHBN,[ASCIZ /LBN:/]
	XWD UNIHNG,[ASCIZ /Position Hang:/]	;PHUNG
	XWD UNIHNG,[ASCIZ /Soft Transfer Hang:/] ;THUNG
	XWD UNIHNG,[ASCIZ /Hard Transfer Hang:/] ;NTHUNG
	XWD UNIHNG,[ASCIZ /Software Hang:/]	;SHUNG
	XWD UNIHDI,[ASCIZ /2nd DATAI:/]		;2DATAI
	XWD UNISDI,[ASCIZ /1st DATAI:/]		;1DATAI
UER2TL==.-UER2T1

UER2T2:	HLRZS N
	HRRZS N
	HLRZS N
	HRRZS N
	ANDI N,77777			;[324] RETRIES FIELD BITS 15-35
	LDB N,[POINT 12,N,11]
	LDB N,[POINT 12,N,23]
	ANDI N,7777
	JFCL
	JFCL
	JFCL
	LDB N,[POINT 9,N,26]
	LDB N,[POINT 9,N,17]
	LDB N,[POINT 9,N,8]
	LDB N,[POINT 9,N,35]
	JFCL
	JFCL
UER2T3:	PRTUED
	PRTUED
	PRTUED
	PRTUED
	PRTUED
	PRTUED
	PRTUED
	PRTUED
	PRTUEO
	PRTUEO
	PRTUED
	PRTUED
	PRTUED
	PRTUED
	PRTUED
	PRTUEO
	PRTUEO
FINIS:	SKIPE	JOBINT+2	;CONTROL C TYPED?
	JRST	CTRAP		;YES, GO SERVICE
	PUSHJ	P,CRLF
	JUMPE	WD,HACKQ	;NO CHS. TYPED--EXIT.
	JUMPL	F,HACKQ		;BREAK CH. FOUND--EXIT.
	TRNN	F,FR.DSK	;DO NOT CLODE DISK FILE
	CLOSE	TTY,		;EMPTY BUFFERS (IN CASE OF TTY ^O)
	AND	F,[FL.GOD!FL.LGI!FL.LPT,,FR.CNT!FR.DPY!FR.DSK!FR.INI!FR.END!FR.INC!FR.USR]
	SETZM	ONCE		;SET ONCE THRU FLAG
	JRST	AGAIN		;GO INTERPRET MORE CHS.


;HERE ON FATAL ERROR

BOMB.:	OUTSTR	[ASCIZ /
? /]
	OUTSTR	(M)		;OUTPUT MESSAGE
	OUTSTR	[ASCIZ /
/]
	CLRBFI			;CLEAR TYPE AHEAD
	JRST	EXIT.		;GO BIND OFF JOB

;HERE WHEN ^C TYPED

CTRAP:	TLNN	F,FL.LGI	;ARE WE LOGGED IN?
	  JRST	KILL		;NO, GO KJOB
	PUSH	P,JOBINT+2	;SAVE RETURN
	CLRBFO			;KILL TYPE-AHEAD
	EXIT	1,		;STOP NOW
	SETZM	JOBINT+2	;ALLOW MORE ^CS
	POPJ	P,		;CONTINUE WHERE STOPPED
	SUBTTL	FINISH UP
HACKQ:	MOVEI	M,REENTR	;SET REENTER POINT
	MOVEM	M,.JBREN	;SAVE IT
	TRO	F,FR.END	;MARK AS HAVING BEEN DONE NOW
	TRNE	F,FR.CNT	;ARE WE CONTINUING ?
	JRST	SNOOZE		;YES--GO SLEEP FOR AWHILE
	TRNE	F,FR.DSK	;KEEP DISK FILES OPEN
	JRST	EXIT.		;NO BIRTH DAYS
	CLOSE	TTY,
	IFN HACKSW,<
	IFL	HACKSW,<
	MOVE	A,XAPRSN	;GET SERIAL NUMBER
	PUSHJ	P,GETZ		;OF THIS MACHINE
	MOVSI	B,-LENHAQ	;SEARCH SPECIAL TABLE
HAQ1:	MOVE	C,HAQAPR(B)	;OF MACHINES TO BE
	CAME	A,C		;HACKED
	AOBJN	B,HAQ1		;LOOP
	JUMPGE	B,EXIT.		;EXIT. IF NOT THIS MACHINE
>
	SETZB	WD,TYOB		;CLEAR WD IN CASE -VE SO PRINTING WILL HAPPEN
	MOVE	A,DATE
	IDIVI	A,^D31*^D12	;GET MODULO YEAR
	MOVEM	B,DATE
	MOVSI	J,-HAKLEN
	JUMPE	J,EXIT.		;GO AWAY IF EMPTY TABLE
HAKLUP:	MOVE	A,HAKTAB(J)
	HLRZ	B,A		;THE DATE FROM TABLE
	ANDI	B,7777		;JUST DATE CODE
	CAME	B,DATE		;TODAY?
	JRST	HAKNXT		;NO
	PUSHJ	P,CRLF2
	MOVEI	M,BMSG
	SKIPL	A
	PUSHJ	P,MSG
	HRRZ	M,A
	PUSHJ	P,MSG
	PUSHJ	P,CRLF
HAKNXT:	AOBJN	J,HAKLUP
>
	JRST	EXIT.

	IFL	HACKSW,<
HAQAPR:	DEC	1,2,40,169,513,514,546,1026,1042,2263,2476
LENHAQ==.-HAQAPR
>
NOCOR:	MOVEI	M,[ASCIZ /?Need more core for data

/]
	PUSHJ	P,MSG
EXIT.:	CLOSE	TTY,		;CLOSE TTY IN CASE OF ^O
	PUSHJ	P,GETCHR	;GOBBLE LEFTOVER CHS. UNTIL A BREAK CH. IS SEEN
	TLZA	F,FL.BRK	;CLEAR BREAK CHAR FLAG
	JRST	.-2
KILL:	TDZ	F,[FL.LPT,,FR.INI!FR.DSK]	;EDIT 17 FORGET ALL ABOUT IO
	RELEASE	TTY,		;CLEAR BITS, THEN RELEASE TTY
	SKIPN	TNFRTY		;EXIT ON 10/40 SYSTEM
	TLNE	F,FL.LGI
	pjrst	[ EXIT	1,
		  pjrst	systat] ;restart it
	OUTSTR	KJMSG
	LOGOUT

KJMSG:	ASCII	/.KJOB/
	BYTE	(7) 15,12,".",0,0

MINUTE==^D1			;THIS IS THE SLEEP TIME

SNOOZE:	CLOSE	TTY,		;CLOSE TTY IN CASE OF ^O
	TLNN	F,FL.LGI
	JRST	KILL		;NOT LOGGED IN, CAN'T REPEAT
	RELEASE	TTY,
	TRZ	F,FR.INI	;**[16] NO MORE INITED
 	SETZM	TYOB		;TO FORCE USE OF TTCALL I/O
	TTCALL	2,M		;JUST TO RESET THE ^O BIT
	  JRST	SNOOZ1
	CAIN	M,3		;IS IT ^C ?
	EXIT	1,
	CLRBFI

SNOOZ1:	MOVEI	M,^D60/4	;SECONDS PER MINUTE/4
	MOVSI	A,-MINUTE*4	;HOW MANY MINUTES TO SLEEP*4
CNTRLC:	TTCALL	2,CH		;JUST IN CASE HE TYPED ^C
	  JRST	ZZZZZ		;NO
	CAIN	CH,3		;IS IT?
	EXIT	1,		;YES
	CLRBFI
ZZZZZ:	CALLI	M,31		;GO TO SLEEP FOR A MINUTE
	AOBJN	A,CNTRLC	;DO IT AGAIN AND AGAIN
	TRNE	F,FR.INC	;INCREMENTAL MODE?
	  JRST	REENTR		;YES, GO DO IT.
	JRST	CNTLP		;WAKE UP, WORLD! HERE WE GO AGAIN
	SUBTTL	HELP

HELPM:	MOVEI	M,[ASCIZ /? Type "SYS H" for Help
/]
HELPER:	PUSHJ	P,MSG		;TELL ABOUT HELP
	JRST	EXIT.		;GO EXIT

HELP:	MOVE	1,['SYSTAT']		;IT MUST BE REGISTER 1
	PUSHJ	P,.HELPR##		;GO TO THE HELPER
	JRST	HACKQ			;AND GO HACK IT

;O IS DELIBERATELY NOT TYPED BY HELP
;ALL JOB STATE CODES ARE LISTED (EVEN THOSE NOT TYPED BY SYSTAT)

	SUBTTL	"X" - INVOKE DSK:CRASH.XPN RATHER THAN RUNNING MONITOR
;COMMAND FORMAT:
; 'ANY NONGO SITCHES' X 'ATLEAST ONE SPACE' [FILE NAME]
;  FILE CRASH.XPN IS TAKEN WHEN FILE NAME IS EMPTY

SETDSK:
	TLNE	F,FL.LGI	;LOGGED IN JOB?
	JRST	STDSK1		;YES
;
;IF JOB IS NOT LOGGED IN BUT CONTROLLED BY A [1,*] JOB
;ALLOW SYSTAT X OTHERWISE BOMB IT OUT
;
	PJOB	A,		;GET CURRENT JOB NUMBER
	CTLJOB	A,		;GET CONTROLLING JOB NUMBER
	SETO	A,		;NOT IMPLEMENTED
	MOVSI	A,(A)		;SET UP TO GETTAB
	HRRI	A,.GTPPN	;GET PPN OF CONTROLLING JOB
	GETTAB	A,		;DO THE GETTAB
	SETO	A,		;ERROR
	TLNN	A,-2		;PROJECT 0 OR 1?
	JRST	STDSK1		;YES..
	BOMB	(Job not logged in.)	;BYE BYE
STDSK1:	SETZM	INDEV
	SETZM	INFILE
	SETZM	INEXT
	SETZM	INPPN
	PUSHJ	P,GETNXT	;GET A SIXBIT FIELD OR ZERO
	JUMPE	A,SETDS2	;CHECK FOR PPN	;NOTHING FOUND THE JUMP
	CAIE	WD,":"
	JRST	SETDS1
	MOVEM	A,INDEV
	PUSHJ	P,GETNXT
	JUMPE	A,SETDS2	;IS THERE A FILE
SETDS1:	MOVEM	A,INFILE
	CAIE	WD,"."
	JRST	SETDS2
	PUSHJ	P,GETNXT
	  JFCL
	MOVEM	A,INEXT
SETDS2:	CAIN	WD,"["
	PUSHJ	P,INPPPN
SETDS3:	PUSHJ	P,GETFIL
	BOMB	(Can't get at that file)
	MOVSI	A,-NBCSHE	;PRIME THE INCORE CACHE POINTERS
	MOVE	B,FREE		;FIRST AVAILABLE LOC
	HRROM	B,DCACHE(A)	;STORE -1,,BUFFER ADDRESS
	ADDI	B,LN.BUF	;STEP TO NEXT DISK BUFFER
	AOBJN	A,.-2		;STORE ALL ENTRIES
	MOVEM	B,FREE		;STORE NEXT AVAILABLE FREE CORE ADDR
	CAMG	B,.JBREL	;NEED TO EXPAND
	JRST	.+3		;NO
	CORE	B,		;GET THE EXTRA CORE
	  JRST	NOCOR		;WHOOPS
IFN FTEXE,<
	TRNN	F,FR.EXE	;EXE CRASH FILE?
	JRST	NOXCRS		;NO
	MOVEI	A,0		;FIRST, LET'S CHECK HEADER WORD
	PUSHJ	P,DSKA		;GET FIRST WORD FORM FILE
	HLRZS	A		;ISOLATE HEADER CODE
	CAIE	A,1776		;CORRECT?
	BOMB	(Bad header code--not an EXE file)
	PUSHJ	P,CPYEXE	;COPY EXE FILE DIRECTORY AND RE-COMPUTE DSKFLG
NOXCRS:
>;END OF IFN FTEXE
	MOVEI	A,ABSTB1	;GET POINTER TO GETTABS
DSKJN1:	MOVEM	A,MAXGTB	;BORROW THIS CELL TO REMEMBER WHICH ABSTAB TRYING
	PUSHJ	P,DSKA		;READ IT
	TLNE	A,-1		;MAKE SURE ZERO LH
	JRST	DSKJNK		;NO. NOT ABSTAB
	CAMLE	A,MAXGTB	;MAKE SURE IT MAKES SOME SENSE
	CAML	A,DSKFLG	;..
	JRST	DSKJNK		;NO--GIVE UP
	HRRZ	B,A		;SAVE FOR TEST LATER
	ADD	A,XGTTBI	;ADD OFFSET FOR GETTAB IMMEDIATE
	PUSHJ	P,DSKA		;READ THAT PLACE
	CAIE	B,(A)		;SEE IF IT MATCHES
	JRST	DSKJNK		;NO--MUST BE JUNK
	HRRZM	A,OFSGTB	;YES--REMEMBER OFFSET
	LSH	A,-^D9		;GET NUMBER OF TABLES
	HLRZM	A,MAXGTB	;SAVE IT
	PUSHJ	P,STATE		;GET STATES WORD FROM DUMP
	MOVEI	A,TYOCH		;GET ADDRESS OF OUTSTR ROUTINE
	MOVEM	A,COMTOA	;STORE TYPE OUT ADDRESS
	MOVEI	M,[ASCIZ/
[/]
	PUSHJ	P,MSG
	PUSHJ	P,CRSMSG	;TYPE MONITOR NAME, DATE, TIME
	MOVE	A,[%SYSPC]	;GET LAST STOPCODE DATA
	PUSHJ	P,GETZ		;GET IT OR A ZERO
	JUMPE	A,SETDS4	;THERE WAS NO STOPCD
	PUSH	P,A		;SAVE STOPCD INFO
	MOVE	A,[%SYSCD]	;STOPCD NAME IN 7.03 OR LATER
	PUSHJ	P,GETZ		;GET IT OR ZERO
	SKIPN	BP,A		;IS THERE A NEW NAME?
	HLLZ	BP,(P)		;NO, COPY OLD STOP CODE NAME
	POP	P,(P)		;POP OFF JUNK
	MOVEI	M,[ASCIZ/, stopcode /]
	PUSHJ	P,MSG		;TELL WHAT IT IS
	PUSHJ	P,SIXBP1	;TYPE STOPCD NAME
SETDS4:	MOVEI	M,[ASCIZ/]

/]
	PUSHJ	P,MSG
	SETZM	COMTOA		;USE DEFAULT TYPEOUT
	MOVE	A,XPDBPT	;SET UP PDB POINTER FOR CRASH FILE
	PUSHJ	P,GETZ		;SEE IIF IT IS THERE
	MOVEM	A,PDBPTR	;STORE ZERO OR VALUE
	MOVE	A,XMNVER	;GET CRASHED MONITORS
	CALL	GETZ		;VERSION INTO A
	HRRZS	A		;STRIP OFF NOISE BITS
	MOVEM	A,MONVER	;AND STORE IT AWAY
	CAIGE	A,60122		;OLD STYLE IF LESS
	CAIGE	A,60000		;AN OLD MONITOR
	CAIGE	A,50722		;IF NOT VERSION 6 OR LATER
	SETZM	NPJOBN		;OLD STYLE SO CLEAR NEW JOB PTR.
	POPJ	P,		;RETURN

DSKJNK:	MOVEI	A,ABSTB2	;TRY SECOND ONE
	CAME	A,MAXGTB	;OR DID WE ALREADY?
	JRST	DSKJN1		;NO, TRY IT.
	JSP	M,BOMB.		;GIVE JUNK ERROR
	ASCIZ	/Can't find GETTABs in CRASH/
GETFIL:	MOVSI	A,DSK		;GET CHANNEL #
	MOVE	B,ME		;GET MY PPN
	CAMN	B,[1,,2]	;AM I THE SAME AS OPR PPN?
	TXO	A,FO.PRV	;SET PRIV BIT FOR FILOP.
				;[1,2] JOBS GET FULL ACCESS
	MOVEM	A,FLP+.FOFNC	;AND STORE IT IN FILOP. BLOCK
	MOVEI	A,.FORED	;SET FUNCTION CODE
	HRRM	A,FLP+.FOFNC	;TO READ FILE
	MOVEI	A,17		;SET I/O MODE
	MOVEM	A,FLP+.FOIOS	;. .
	SKIPN	A,INDEV		;DID USER SPECIFY A DEVICE ?
	MOVSI	A,'DSK'		;NO--ASSUME DSK
	MOVEM	A,FLP+.FODEV	;AND STORE IT
	DEVCHR	A,		;GET DEVICE CHARACTERISTICS
	TLNN	A,(DV.DIR)	;IS IT A DISK ?
	JRST	DNDERR		;PROCESS ERROR
	SETZM	FLP+.FOBRH	;NO BUFFERS
	SETZM	FLP+.FONBF	;. .
	MOVEI	A,LKB		;ADDR. OF LOOKUP BLOCK
	MOVEM	A,FLP+.FOLEB	;. .
	SKIPN	A,INFILE	;FILE SPECIFIED ?
	MOVE	A,CRASH		;NO--ASSUME CRASH
	MOVEM	A,LKB+.RBNAM	;STORE IT IN LOOKUP BLOCK
	SKIPN	A,INEXT		;EXTENSION SPECIFIED ?
IFE FTEXE,<
	MOVE	A,CRSEXT	;NO--GET CRASH EXTENSION
>;END OF IFE FTEXE
IFN FTEXE,<
	MOVSI	A,'EXE'		;NO--ASSUME EXE
>;END IFN FTEXE
	MOVEM	A,LKB+.RBEXT	;STORE IT
	SKIPN	A,INPPN		;PPN SPECIFIED ?
	MOVE	A,CRSPPN	;NO--USE CRASH PPN DEFAULT
	MOVEM	A,LKB+.RBPPN	;STORE IT
	MOVEI	A,10		;GET EXTENDED LOOKUP BLOCK SIZE
	MOVEM	A,LKB		;STORE IT IN LOOKUP BLOCK
FLPAGN:	MOVE	A,[XWD 6,FLP]	;POINT TO FILOP. BLOCK
	FILOP.	A,		;OPEN CRASH FILE
	  JRST	FLPERR		;GO PROCESS FILOP. ERROR
FILOPN:	HLRZ	A,LKB+.RBEXT	;GET EXTENSION
	CAIN	A,'EXE'		;IS THIS AN EXE FILE ?
	TRO	F,FR.EXE	;YES--SET BIT TO REMEMBER IT
	MOVE	A,LKB+.RBSIZ	;YES--GET FILE SIZE
	MOVEM	A,DSKFLG	;AND SAVE IT AWAY FOR LATER
	JRST	CPOPJ1		;GIVE GOOD RETURN

FLPERR:	CAME	A,[XWD 6,FLP]	;IS FILOP. IMPLEMENTED ?
	JRST	CHKERR		;YES--GO CHECK THE ERROR CODE THEN
	OPEN	DSK,FLP+.FOIOS	;NO--DO MANUAL OPEN
	  POPJ	P,		;CAN'T ACCESS FILE
	LOOKUP	DSK,LKB		;LOOKUP FILE
	  JRST	CHKER1		;GO PROCESS LOOKUP FAILURE
CHKPRV:	HLRZ	B,LKB+.RBPRV	;GET PRIVILEGE WORD FROM LOOKUP BLOCK
	LSH	B,-^D9		;RIGHT JUSTIFY PROT. CODE
	HRLI	B,5		;SET CHKACC FUNC. CODE TO READ FILE
	MOVEI	C,DSK		;GET CHANNEL #
	DEVPPN	C,		;GET DEVICE'S ASSOCIATED PPN
	  MOVEI	C,ME		;ASSUME MY PPN
	CAME	C,ME		;IS IT ME ?
	MOVEM	C,INPPN		;NO--OVERIDE ALL WITH ERSATZ PPN
	SKIPN	C,INPPN		;IS THERE A PPN ARGUMENT ?
	MOVE	C,ME		;NO--ASSUME OUR PPN
	MOVE	D,ME		;PERFORM CHKACC AGAINST ME
	MOVEI	A,B		;POINT TO CHKACC ARGUMENT BLOCK
	CHKACC	A,		;ARE WE ALLOWED TO ACCESS THIS FILE ?
	  JRST	FILOPN		;ASSUME YES AND PROCEED
	JUMPGE	A,FILOPN	;YES--PROCEED
FILPRT:	JSP	M,BOMB.		;NO--FILE'S PROTECTED AGAINST US
	ASCIZ/File is read protected/

DNDERR:	JSP	M,BOMB.		;DEVICE MUST BE A DISK !!
	ASCIZ/Device must be a disk/

CHKER1:	HRRZ	A,LKB+.RBEXT	;GET LOOKUP ERROR CODE
CHKERR:	CAIN	A,2		;PROTECTION FAILURE ?
	JRST	FILPRT		;YES--GIVE ERROR
	JUMPN	A,CPOPJ		;FILE NOT FOUND ?
	HLRZ	A,LKB+.RBEXT	;YES--GET EXTENSION
	CAIE	A,'EXE'		;WAS IT 'EXE' ?
	POPJ	P,		;NO--CAN'T ACCESS FILE
	MOVE	A,CRSEXT	;YES--GET OLD EXTENSION
	MOVEM	A,LKB+.RBEXT	;AND STORE IT
	JRST	FLPAGN		;TRY AGAIN WITH NEW EXTENSION

INPPPN:	PUSHJ	P,GETPPN
	MOVEM	A,INPTH+.PTPPN
	MOVEI	A,INPTH		;POINT TO PATH BLOCK
	MOVEM	A,INPPN		;SAVE AS POINTER IN PPN WORD
	PUSH	P,[-5,,0]	;SAVE AOBJN POINTER TO SFD LIST ON STK
INPPP1:	CAIE	WD,","		;SFD LIST FOLLOW?
	JRST	INPPP2		;NO
	PUSHJ	P,GETNXT	;GET NEXT SFD
	  BOMB	<Command error -- Type SYS /H for help>
	SKIPN	A		;MUST BE NON-NULL
	  BOMB	<Command error -- Type SYS /H for help>
	MOVE	C,(P)		;GET AOBJN POINTER BACK
	MOVEM	A,INPTH+.PTPPN+1(C) ;STORE SFD IN NEXT WORD OF BLOCK
	AOBJP	C,INPPP2	;GO IF TOO MANY
	MOVEM	C,(P)		;STORE UPDATED POINTER BACK ON STACK
	JRST	INPPP1		;AND LOOP FOR NEXT
INPPP2:	POP	P,A		;RESTORE LAST VALUE OF AOBJN POINTER
	SETZM	INPTH+.PTPPN+1(A) ;INSURE ZERO TERMINATOR
	CAIE	WD,12
	PUSHJ	P,GETNXT
	  JFCL
	POPJ	P,
DSKBP1:	CAMN	BP,LASBPA	;SEE IF SAME AS LAST ONE
	JRST	[MOVE BP,LASBP1	;YES--GET SAME ANSWER
		 JRST CPOPJ1]	;GIVE SKIP RETURN
	MOVEM	BP,LASBPA	;NO--SAVE ADDRESS
	PUSH	P,A		;SAVE A
	MOVE	A,BP		;GET ARGUMENT
	PUSHJ	P,DSKA		;GET WORD
	MOVE	BP,A		;GIVE ANSWER
	POP	P,A		;RESORE A
	MOVEM	BP,LASBP1	;SAVE ANSWER
	JRST	CPOPJ1		;SKIP RETURN

DSKC:	PUSH	P,A		;SAVE A
	MOVE	A,C		;GET ARGUMENT
	PUSHJ	P,DSKA		;GET WORD
	MOVE	C,A		;GIVE ANSWER
	POP	P,A		;RESTORE A
	POPJ	P,		;RETURN
DSKA1:	AOS	(P)		;SKIP RETURN
DSKA:	TLNN	F1,F1.XAD	;30 BIT ADDRESS?
	TLZ	A,-1		;CLEAR JUNK
	CAMGE	A,.UPFSO	;ADDRESS IN MONITOR LOW SEG
	JRST	DSKA8		;YES, JUST GET MONITOR LOW SEG VALUE
	PUSH	P,D		;GET A WORKING AC
	MOVE	D,A		;SAVE ADDRESS IN D
	CAML	D,.UPFSE	;REALLY IN FUNNY SPACE?
	TLO	D,400000	;NO, IN THE MONITOR'S HIGH SEGMENT
	ANDI	A,777		;ISOLATE OFFSET IN PAGE
	PUSH	P,A		;SAVE THIS
	LSH	D,-^D9		;CONVERT TO PAGE NUMBER
	MOVE	A,.CPTOS	;THIS IS KIND OF A KLUDGE BUT THERE ARE NO
	CAME	A,.CPMAP	;CONVIENENT BITS TO REMEMBER TYPE OF PAGING
	TLO	D,600000	;KL PAGING
	TLZN	D,400		;ADDRESS IN MONITOR HIGH SEG?
	JRST	DSKA2		;NO, PER-PROCESS MAPPING
	TLNN	D,200000	;KL PAGING?
	ROT	D,-1		;NO, KI PAGING - MAP SLOTS ARE HALF WORDS
	HRRZ	A,D		;WORD WITHIN THE MAP
	TRNE	A,37000		;NON-ZERO SECTION?
	JRST	[PUSH P,B	;YES, SAVE A TEMP
		 LDB B,[POINT 9,A,26] ;GET SECTION NUMBER
		 MOVE B,SECTAB(B) ;GET MAP POINTER
		 ANDI B,17777	;ISOLATE PHYSICAL PAGE NUMBER
		 LSH B,^D9	;POSITION IT
		 ANDI A,777	;JUST PAGE OFFSET WITHIN SECTION
		 ADD A,B	;PHYSICAL ADDRESS OF MAP POINTER
		 POP P,B	;RESTORE TEMP
		 JRST DSKA7]	;GO GET MAP SLOT ENTRY
	ADD	A,.CPMAP	;ADDRESS OF MAP SLOT ENTRY
	JRST	DSKA7		;GO GET MAP SLOT ENTRY
DSKA2:	MOVSI	A,(J)		;JOB NUMBER TO LH
	HRRI	A,.GTUPM	;NEED JBTUPM FOR THIS JOB
	PUSHJ	P,FGETTB	;GET VALUE
	  JRST	DSKA3		;FAILED, RETURN ZERO
	HRRZS	A		;KEEP JUST PAGE NUMBER
	JUMPN	A,DSKA5		;IF THERE, CONTINUE
DSKA3:	POP	P,(P)		;FLUSH JUNK
	POP	P,D		;RESTORE D
DSKA4:	MOVEI	A,0		;RETURN ZERO TO CALLER
	POPJ	P,		;AND RETURN
DSKA5:	LSH	A,^D9		;MAKE PAGE NUMBER AN ADDRESS
	TLNE	D,200000	;KL PAGING?
	JRST	DSKA6		;YES, PAGE NUMBER IS OFFSET INTO THE MAP
	ROT	D,-1		;DIVIDE BY 2 PUTTING REMAINDER IN THE SIGN BIT
	ADDI	D,220		;PP STUFF STARTS AT 400 IN THE MAP
DSKA6:	ADDI	A,(D)		;POINT TO PER-PROCESS STUFF IN THE UPMP
DSKA7:	PUSHJ	P,DSKA8		;GET THE MAP SLOT FOR THIS ADDRESS
	SKIPL	D		;SKIP IF MAPPING THROUGH RH
	MOVSS	A		;MAPPING THROUGH LH, REVERSE
	TLNE	D,200000	;KL PAGING?
	TLNN	A,700000	;YES, ACCESS ALLOWED?
	CAIA			;KI PAGING OR ACCESS NOT ALLOWED
	TRO	A,400000	;INDICATE ACCESS ALLOWED
	TRNN	A,400000	;PAGE HAVE ACCESS ALLOWED ON?
	JRST	DSKA3		;NO, RETURN ZERO
	ANDI	A,17777		;KEEP JUST 13 BIT PAGE NUMBER
	LSH	A,^D9		;MAKE IT AN ADDRESS
	ADD	A,0(P)		;ADD IN OFFSET IN PAGE
	POP	P,(P)		;FLUSH JUNK
	POP	P,D		;RESTORE D
DSKA8:	PUSH	P,B		;SAVE B
	CAML	A,DSKFLG	;COMPARE TO AMOUNT IN FILE
	JRST	[POP	P,B	;RESTORE B
		 JRST	DSKA4]	;RETURN ZERO
	PUSH	P,C		;SAVE A WORK REGISTER
IFN FTEXE,<
	JUMPE	A,DSKA9		;DON'T RELOCATE 0 (NEED TO READ EXE DIRECTORY)
	TRNN	F,FR.EXE	;IS THIS AN EXE FILE?
	JRST	DSKA9		;NO, GO STRAIGHT TO FILE
	PUSHJ	P,RELEXE	;RELOCATE ADDRESS TO DISK PAGE ADDRESS
	  JRST	[POP P,C	;ADDRESS NOT IN FILE, RESTORE ACS
		POP P,B
		JRST DSKA4]	;AND RETURN 0
>;END OF IFN FTEXE
DSKA9:	IDIVI	A,LN.BUF	;SPLIT INTO BLOCK AND WORD
	PUSH	P,B		;OFFSET FOR WORD IN BUFFER
	MOVSI	B,-NBCSHE	;SEARCH THE CACHE FOR THIS DISK BLOCK
	HLRZ	C,DCACHE(B)	;FETCH BLOCK DESCRIBED
	CAIE	C,(A)		;IS THIS IT
	AOBJN	B,.-2		;NO, KEEP LOOKING
	JUMPL	B,DSKARD	;FOUND ONE, UPDATE LEAST RECENTLY USED
	HRLM	A,DCACHE+NBCSHE-1 ;STORE BLOCK NUMBER IN LAST (OLDEST)
	HRRZ	B,DCACHE+NBCSHE-1 ;WHERE DATA IS TO BE READ
	SOS	B		;-1 FOR THE IOWD
	HRRM	B,DSKIOW	;STORE ADDR
	MOVEI	B,NBCSHE-1	;INDEX WHERE READ (FOUND)
IFN LN.BUF-200,<IMULI A,LN.BUF/200>
IFN LN.BUF-<LN.BUF/200>*200,<PRINTX LN.BUF MUST BE MULT OF 200>
	USETI	DSK,1(A)	;NO--POSITION FILE
	IN	DSK,DSKIOW
	JRST	DSKARD		;READ OK
	PUSH	P,M		;BAD--SAVE LOTS STUFF
	PUSH	P,N
	PUSH	P,N1
	PUSH	P,R
	PUSH	P,CH
	PUSH	P,WD
	MOVEI	WD,0
	GETSTS	DSK,N
	MOVEI	M,[ASCIZ /
% Disk read error /]
	PUSHJ	P,MSG
	PUSHJ	P,OCTPRT
	PUSHJ	P,CRLF
	POP	P,WD
	POP	P,CH
	POP	P,R
	POP	P,N1
	POP	P,N
	POP	P,M

DSKARD:	HRRZS	B		;ISOLATE POSITION IN TABLE
	CAIG	B,NBCSHE/3	;DON'T RIPPLE TABLE IF CLOSE TO FRONT ALREADY
	JRST	DSKAR1		;THIS MIGHT NOT BE TOO GOOD WITH SMALL "NBCSHE"
	PUSH	P,DCACHE(B)	;SAVE DESIRED ENTRY
	MOVE	C,DCACHE-1(B)	;COMPRESS TABLE SO LEAST USED IS LAST
	MOVEM	C,DCACHE(B)	;MOVE UP ENTRIES BELOW ONE FOUND
	SOJG	B,.-2		;SO NEW ONE CAN BE FOUND QUICKLY LATER
	POP	P,DCACHE(B)	;PUT SAVED ENTRY AT THE FRONT
DSKAR1:	POP	P,C		;GET WORD OFFSET FOR DATA ITEM
	ADD	C,DCACHE(B)	;FIND WORD IN BUFFER
	MOVE	A,(C)		;FETCH IT
	POP	P,C		;RESTORE WORK AC
	POP	P,B		;RESTORE CALLERS AC
	POPJ	P,		;RETURN WITH DATA ITEM IN A
;SUBROUTINES TO DEAL WITH EXE DIRECTORY

IFN FTEXE,<

CPYEXE:	HRLZ	A,DCACHE	;*** "KNOW" WHERE DSKA READ IT
	HRRI	A,EXEDIR	;PLACE TO SAVE IT
	BLT	A,EXEDIR+LN.BUF-1 ;MOVE AS MUCH AS WAS READ
	HRRZ	A,EXEDIR	;FETCH DIRECTORY SIZE
	CAIL	A,LN.BUF	;DID WE GET ALL OF IT
	BOMB	(EXE Directory too complex, try making LN.BUF larger)
	MOVE	A,EXEDIR-1(A)	;FETCH LAST DESCRIPTOR WORD
	LDB	B,[POINT 9,A,8]	;GET REPEATER COUNT
	ADDI	B,1(A)		;FIRST PAGE NOT IN FILE
	LSH	B,^D9		;FIRST ADDRESS NOT IN FILE
	MOVEM	B,DSKFLG	;RESET MAXIMUM ADDRESS
	POPJ	P,		;AND RETURN

RELEXE:	PUSH	P,D		;SAVE A WORKING AC
	IDIVI	A,1000		;SPLIT INTO PAGE AND OFFSET
	PUSH	P,B		;SAVE OFFSET
	HRRZ	B,EXEDIR	;FETCH NUMBER OF WORDS IN DIRECTORY
	MOVNI	B,-1(B)		;DON'T COUNT HEADER WORD
	HRLZS	B		;= AOBJN
RELEX1:	HRRZ	C,EXEDIR+2(B)	;GET CORE ADDRESS FROM DESCRIPTOR
	CAILE	C,(A)		;PASS THE ONE WE WANT
	JRST	RELEX3		;YES, WORD NOT IN FILE
	LDB	D,[POINT 9,EXEDIR+2(B),8] ;GET REPEATER
	ADDI	D,1(C)		;FIRST PAGE NOT IN POINTER
	CAIL	A,(D)		;PAGE IN THIS POINTER AT ALL
	JRST	RELEX2		;NO, GET ANOTHER POINTER
	SUBI	A,(C)		;HOW FAR INTO THE POINTER
	ADD	A,EXEDIR+1(B)	;HOW FAR INTO THE FILE PROPER
	TLZ	A,-1		;KEEP IT REASONABLE ( FLAGS BITS )
	LSH	A,^D9		;TO A PAGE ADDRESS IN THE FILE
	ADDM	A,(P)		;INCLUDE THE OFFSET WANTED
	AOS	-2(P)		;GIVE GOOD RETURN
	JRST	RELEX3		;AND RETURN
RELEX2:	AOBJN	B,.+1		;ADJUST FOR DOUBLE WORD ENTRIES
	AOBJN	B,RELEX1	;LOOK AT NEXT POINTER
RELEX3:	POP	P,A		;RETURN VALUE
	POP	P,D		;RESTORE WORKING AC
	POPJ	P,		;RETURN

> ;END FTEXE
;GETNXT IS CALLED TO COLLECT A SIXBIT FIELD IN ACCU A
;AND A DELIMITING CHARACTER IN REGISTER WD
;DELIMITERS ARE:
;LINE FEED COMMA PERIOD COLON LEFT BRACKET RIGHT BRACKET LEFTARROW
;IF A BREAK CHARACTER WAS FOUND A ZERO DELIMITER IS RETURNED CAUSING
;SYSTAT TO  FAIL AT ALL DELIMITER TESTS
GETNXT:	SETZ	A,
GETNX0:	SETZ	WD,		;LET TEST ON DELIMITER FAIL
	TLNE	F,FL.BRK
	POPJ	P,
	PUSHJ	P,GETCHR
	  JFCL
	CAIE	WD," "
	CAIN	WD,15
	JRST	GETNX0
GETNX1:	MOVE	B,DELMPT
GETNX2:	ILDB	C,B
	JUMPE	C,GETNX4
	CAIE	WD,(C)
	JRST	GETNX2
	SKIPE	A
GETNX3:	TLNE	A,770000
	JRST	CPOPJ1
	LSH	A,6
	JRST	GETNX3
GETNX4:	TLNE	A,770000
	JRST	GETNX0
	LSH	A,6
	ADDI	A,-40(WD)
	JRST	GETNX0

DELMPT:	POINT	7,DELMTB
DELMTB:	BYTE	(7) 12,54,56,72,133,135,137,0

GETPPN:	PUSHJ	P,GETNXT
	  BOMB	<Command error -- Type SYS /H for help>
	SKIPN	C,A
	  MOVSI	C,'0  '		;IF [,], FAKE GETNUM
	CAIE	WD,","
	  BOMB	<Command error -- Type SYS /H for help>
	PUSHJ	P,GETNUM
	SKIPN	A		;SKIP IF PROJECT# NON-ZERO
	HLRZ	A,ME		;IF [,], USE OUR PROJECT NUMBER
	PUSH	P,A
	TLNN	A,-1
	PUSHJ	P,GETNXT
	  BOMB	<Command error -- Type SYS /H for help>
	SKIPN	C,A
	  MOVSI	C,'0  '		;IF [,] FAKE GETNUM
	PUSHJ	P,GETNUM
	SKIPN	A		;SKIP IF PROGRAMMER NUMBER NON-ZERO
	HRRZ	A,ME		;USER OURS IF [,]
	TLNE	A,-1
	  BOMB	<Command error -- Type SYS /H for help>
	HRL	A,(P)
	POP	P,B
	POPJ	P,

GETNUM:	SETZ	A,
GETNM0:	SETZ	B,
	LSHC	B,6
	CAIL	B,"0"-40
	CAILE	B,"7"-40
	  BOMB	<Command error -- Type SYS /H for help>
	LSH	A,3
	ADDI	A,-20(B)
	JUMPN	C,GETNM0	;GET MORE DIGITS
	POPJ	P,
	SUBTTL	SUBROUTINES
;GETTAB OPTIONAL TABLE--RETURN 0 IF ABSENT (RESULT IN A)
GETZ:	PUSHJ	P,FGETTB	;GO DO GETTAB
	  SETZ	A,
	POPJ	P,

;GETTAB OPTIONAL TABLE--ERROR RETURN IF ABSENT (RESULT IN B)
GETTB:	PUSH	P,A		;SAVE A
	MOVE	A,B		;SETUP FOR GETTAB
	PUSHJ	P,FGETTB	;DO GETTAB
	  JRST	[POP	P,A
		 POPJ	P,]
	MOVE	B,A		;GET ANSWER
	POP	P,A		;RESTORE A
CPOPJ1:	AOS	(P)
	POPJ	P,
CPOPJ2:	AOS	(P)	;
	AOS	(P)	;
	POPJ	P,	;

;GETTAB MANDATORY TABLES (RESULT IN A)
GETA:	PUSHJ	P,FGETTB	;GETTAB
	  TDZA	A,A
	POPJ	P,0
PRQM:	MOVEI	CH,"?"
	JRST	TYO
;ROUTINE TO FUDGE GETTABS VIA SPY IF POSSIBLE
;NOTE--DOES NOT HANDLE -2 IN LH, IF FAIL, CHANGES A

FGETTB:	SKIPE	N1,MAXGTB	;SEE IF GETTAB SPYING POSSIBLE
	JRST	GETTB1		;YES--GO DO IT
FGETT1:	SKIPN	DSKFLG		;DONT GETTAB IF IN /X
	GETTAB	A,		;NO--USE MONITOR
	  POPJ	P,		;ERROR RETURN
	JRST	CPOPJ1		;WIN RETURN
GETTB1:	HRRZ	BP,A		;GET TABLE INDEX
	CAMLE	BP,N1		;SEE IF IN RANGE
	POPJ	P,		;NO--ERROR RETURN
	ADD	BP,OFSGTB	;YES--GET CORE ADDRESS
	TLNE	F,FL.DSK	;SEE IF DISK MODE
	PUSHJ	P,DSKBP1	;YES--READ FROM IT AND SKIP
	MOVE	BP,400000(BP)	;GET NUMTAB POINTER
	CALL	SETSPY		;SET UP SPY DATA
	SKIPE	PDBPTR		;YES. HAVE WE THE POINTER TO JBTPDB?
	SKIPA			;OK
	JRST	FGETT1		;NO. GO USE A GETTAB
	HLRZ	A,A		;GET REQUESTED INDEX IN TABLE
	TRNE	A,1B18		;SEE IF JOB FLAG
	MOVE	A,MYJOB		;YES--GET JOB NUMBER
	CAMLE	A,N1		;SEE IF IN RANGE
	POPJ	P,		;NO--ERROR RETURN
	TLNN	BP,(17B17)	;SEE IF INDEXING
	MOVEI	A,0		;NO--CLEAR REQUEST
	TLNN	BP,(GT.PRC)	;PDB DATUM?
	JRST	FGETT2		;NO
	TLNE	F,FL.DSK	;DISK MODE?
	JRST	FGETP2		;YES, HANDLE IT
	ADD	BP,@PDBPTR	;GET ADDRESS IN JOBS PDB
	MOVEI	A,0		;HAVE ADDED IN A ALREADY
FGETT2:	ADDI	A,(BP)		;ADD TABLE LOCATION TO OFFSET
	TLNE	F,FL.DSK	;SEE IF DISK MODE
	PJRST	DSKA1		;YES--GET WORD FROM DISK
	CAML	A,.UPFSO	;IS "A" IN THE EXEC LOW-SEGMENT?
	JRST	FGETT3		;NO, MUST USE PEEKC
	MOVE	A,400000(A)	;GET WORD
	JRST	CPOPJ1		;GIVE WIN RETURN
FGETT3:	PUSH	P,C		;DON'T SMASH "C"
	MOVEI	C,(A)		;GET THE ADDRESS
	PUSHJ	P,PEEKC		;GET CONTENTS THIS WAY
	MOVE	A,C		;RETURN THE VALUE
	POP	P,C		;RESTORE "C" PROPERLY
	JRST	CPOPJ1		;WIN RETURN

FGETP2:	ADD	A,PDBPTR	;GET JOBS PDB POINTER FROM DISK
	PUSHJ	P,DSKA
	ADDB	BP,A		;POINT TO RELATIVE WORD
	PJRST	DSKA1		;GET THE PDB WORD

SETSPY:	LDB	N1,[POINT 9,BP,8];GET TABLE LENGTH
	PUSH	P,N1		;AND SAVE IT
	SKIPN	NEWSPY		;THE NEW STYLE OF SPYING
	JRST	SETSP0		;NO LEAVEIT AS IT IS
	LDB	N1,[POINT 3,BP,11];GET ENTRY TYPE
	TLZ	BP,777760	;ZAP ALL BUT INDEX FIELD
	CAIN	N1,GT.PDB	;SKIP IF NOT PDB DATA
	TLO	BP,(GT.PRC)	;COMPATIBLE
	PUSH	P,A		;SAVE A
	SKIPN	A,BOTH		;GET NUMBER OF JOBS+SEGMENTS
	JRST	SETSP1		;NOT SET  UP YET, LEAVE ALONE
	SUBI	A,1		;COMPUTE HIGHEST SEGMENT OFFSET
	CAIN	N1,.SLIXS	;INDEX BY SEGMENT NUMBER?
	MOVEM	A,-1(P)		;YES, CHANGE MAX
SETSP1:	POP	P,A		;RESTORE A
SETSP0:	POP	P,N1		;GET LENGTH OF TABLE BACK
	TLNN	BP,(GT.PRC)	;PDB DATA??
	AOS	(P)		;SET SKIP RETURN
	RETURN
;PEEK INTO C
PEEKC:	TLNE	F,FL.DSK	;SEE IF DISK MODE
	PJRST	DSKC		;YES--PEEK AT THE DISK
	PUSH	P,A		;SAVE A
	MOVE	A,C		;GET ARGUMENT
	PUSHJ	P,PEEKA		;GET VALUE IN A
	MOVE	C,A		;MOVE TO C FOR RETURN
	POP	P,A		;RESTORE A
	POPJ	P,

;PEEK INTO A
PEEKA:	TLNE	F,FL.DSK	;SEE IF DISK MODE
	PJRST	DSKA		;YES--PEEK AT THE DISK
	TLNN	F1,F1.XAD	;30 BIT ADDRESS?
	TLZ	A,-1		;NO, CLEAR JUNK
	CAML	A,.UPFSE	;MONITOR HIGH SEG ADDRESS?
	JRST	PEEKA1		;YES, GO GET IT WITH PEEK
	CAML	A,.UPFSO	;FUNNY SPACE ADDRESS?
	PJRST	SPYPAG		;YES
	SKIPE	SPYFLG		;SEE IF SPYING
	SKIPA	A,400000(A)	;YES--GET FROM CORE
PEEKA1:	PEEK	A,		;NO--GET FROM MONITOR
	POPJ	P,

GETBTH:	ANDI	A,-1		;MASK TO SIZE
	SKIPE	A		;ERROR IF 0
	CAML	A,DSKFLG	;SEE IF IT FITS
	POPJ	P,		;NO--GIVE ERROR
	MOVEI	C,-1(A)		;GET ADDR-1
	PUSHJ	P,PEEKA		;GET CONT(ADDR)
	PUSHJ	P,PEEKC		;GET CONT(ADDR-1)
	JRST	CPOPJ1		;SKIP RETURN

;ROUTINE TO GET A WORD FROM FUNNY SPACE FOR THIS JOB.  WORKS
;ONLY FOR THIS JOB.  CALL WITH A=ADDRESS, RETURNS A=VALUE.
SPYPAG:	PUSH	P,A		;SAVE ADDRESS
	MOVE	A,MONVER	;GET MONITOR VERSION NUMBER
	CAIGE	A,67700		;7.00 FIELD TEST OR GREATER?
	JRST	SPYPA2		;NO, RETURN ZERO
	MOVE	A,0(P)		;GET ADDRESS BACK
	LSH	A,-^D9		;KEEP JUST PAGE NUMBER
	CAMN	A,LASSPY	;SAME PAGE AS LAST TIME?
	JRST	SPYPA1		;YES, JUST GET IT FROM CORE
	MOVEM	A,LASSPY	;SAVE FOR NEXT CALL
	HRLM	A,GETBLK+1	;ALSO SAVE FOR PAGE CALL
	MOVE	A,[.PAGSP,,DELBLK] ;POINT AT BLOCK TO DELETE PAGE
	PAGE.	A,		;DELETE PAGE FROM OUR ADDRESS SPACE
	  JFCL			;MUST NOT HAVE BEEN THERE
	MOVE	A,[.PAGSP,,GETBLK] ;POINT TO BLOCK TO GET PAGE
	PAGE.	A,		;PAGE IN THAT PAGE
	  JRST	SPYPA2		;FAILED, RETURN ZERO
SPYPA1:	POP	P,A		;GET ADDRESS BACK
	ANDI	A,777		;KEEP JUST OFFSET IN PAGE
	MOVE	A,FSPADR(A)	;GET ADDRESS FROM FUNNY SPACE PAGE
	POPJ	P,		;AND RETURN
SPYPA2:	POP	P,(P)		;PRUNE STACK
	MOVEI	A,0		;RETURN 0
	SETZM	LASSPY		;FORCE REREAD NEXT TIME
	POPJ	P,		;RETURN
GETTTY:	TRNE	F,FR.CNT	;**[16] A CONTINUOUS SYSTAT?
	TLNN	F,FL.LPT	;**[16] (YES) AND GOING TO LPT
	SKIPA			;**[16] (NO) NORMAL
	JRST	GETTT0		;**[16] (YES)  FORCE OF INIT
	TLNE	F,FL.LPT	;IS LPT FILE OPEN?
	RETURN			;(YES) THEN KEEP IT THTA WAY
	CAIE	WD,L.LPT	;DID USER WANT LINE PRINTER
	JRST	SYSIN2		;(NO) SEE IF HE HAS TTY ALLREADY
	TLO	F,FL.LPT	;DID HE HAVE LPT ALLREADY
				;REMOTELY REMOTE?
	TLNE	F,FL.LGI	;OR NOT LOGGED IN?
	  JRST	GETTT0		;NO..OK TO USE LPT
	CTLJOB	A,		;BEING CONTROLLED?
	  SETO A,		;NOT IMPLEMENTED
	MOVSI	A,(A)		;SETUP TO GETTAB ...
	HRRI	A,.GTPPN	;OUR CONTROLLING JOB'S PPN
	PUSHJ	P,FGETTB	;SIMULATE THE GETTAB
	  SETO	A,		;DISALLOW IF NOT IMPLEMENTED
	TLNN	A,-2		;PROJECTS 0 OR 1?
	  JRST	GETTT0		;YES..YOU WIN
	BOMB	(LOGIN to use LPT)  ;NO, TOO BAD
GETTT0:	MOVEI	C,5		;TRY INIT FIVE TIMES
	RESET			;GIVE BUFFERS BACK
SYSIN1:	INIT	TTY,0		;YES--INIT LPT
SYSDEV:	  SIXBIT /LPT/
	  XWD	TYOB,0
	  SKIPA
	JRST	SYSOPN		;IF SUCCESS
	MOVE	B,C
	SLEEP	B,		;WIAT AWHILE
	SOJG	C,SYSIN1	;TRY SOME,THEN GIVE MESSAGE
SYSNOT:	TLON	F,FL.RPT	;FAILED--SEE IF FIRST TIME
	OUTSTR	[ASCIZ /LPT busy--Please assign LPT and continue
/]
	EXIT	1,		;RETURN TO MONITOR MODE
	JRST	SYSIN1		;LOOP BACK FOR ANOTHER TRY
SYSIN2:	TROE	F,FR.INI	;IS THIS THE FIRST TRY
	RETURN			;(NO) YOU HAVE IT ALLREADY
	TLNN	F,FL.DSK	;**[16] DO NOT RESET DISK FILE
	RESET			;GET OLD BUFFERS AWAY
	INIT TTY,0		;FIRST TRY DEVICE SYSTAT
	  SIXBIT /SYSTAT/
	  XWD TYOB,0
	  SKIPA			;NOTHING ASSIGNED AS SYSTAT
	JRST SYSOPN		;OK. USE IT.
	INIT	TTY,0
	  SIXBIT /TTY/
	  XWD	TYOB,0
	  BOMB	(Output init failed)	;DIE IF CAN'T DO OUTPUT
SYSOPN:	TRO	F,FR.INI	;TURN ON FOR L OPTION
	OUTBUF	TTY,1		;ONLY ONE BUFFER
	TRZ	F,FR.DSK	;ASSUME NO DISK
	MOVEI	A,TTY		;GET CHANNEL NUMBER
	DEVTYP	A,		;AND GET IT'S TYPE
	JRST	SYSOP1		;GIVE UP TRY THE ENTER
	ANDI	A,TY.DEV	;GET THE TYPE FIELD
	CAIE	A,.TYDSK	;IS IT A DISK
	JRST	SYSOP1		;(NO) OPEN THE FILE
	TRO	F,FR.DSK	;FLAG THAT THIS IS A DISK FILE
	MOVE	A,[%LDSTP]	;GET STANDARD PROTECTION
	CALL	GETZ		;SEE WHAT IT IS
	ROT	A,^D9		;GET IT IN THE RIGHT HAND SIDE
	HRLI	A,.ACWRI	;WE WANT TO WRITE
	TRZ	A,777000	;MASK OUT JUNK
	MOVEI	B,TTY		;GET OWNERS PPN
	DEVPPN	B,		;FIND THE PPN
	JRST	SYSOP1		;NO PROTECTION
	MOVE	C,ME		;GET MY PPN
	MOVEI	N,A		;GET ADDRESS OF CHECK BLOCK
	CHKACC	N,		;SEE IF I MAY ENTER AND WRITE FILE
	JRST	SYSOP1		;NO CHKACC SO DO IT
	JUMPE	N,SYSOP1	;ALL IS FINE
	BOMB	(No write privilige for file SYSTAT.TXT)
SYSOP1:	MOVE	A,[SIXBIT /SYSTAT/]
	MOVSI	B,(SIXBIT /TXT/)
	SETZB	C,D		;CLEAR DATE & PPN
	TRNE	F,FR.DSK		;IS OUTPUT GOING TO DISK?
	LOOKUP	TTY,A			;YES.DOES SYSTAT.TXT EXIST?
	SKIPA				;NO. CREATE FILE
	JRST	APPEND			;APPEND TO EXISTING FILE
	ENTER	TTY,A
	  BOMB	(Output enter failed)	;DIE IF CAN'T ENTER
	RETURN
APPEND:	HLRE	N,D			;-WORDS(<128K) OR +BLOCKS(>128K)
	SKIPL	N			;BLOCKS?
	JRST	APPEN1			;YES.
	MOVNS	N			;MAKE WORDS +
	LSH	N,-7			;CONVERT TO BLOCKS
	AOS	N			;NEXT BLOCK
APPEN1:	AOS	N			;NEXT BLOCK
	MOVEM	N,FLP+1			;SET NEXT BLOCK IN USETO REQUEST
	HLLZS	B			;CLEAR ENTER ARG BLOCK
	SETZB	C,D			;
	ENTER	TTY,A			;REQUEST SUPERCEDE EXISTING SYSTAT.TXT
	BOMB	(Output ENTER failed)	;DIE ON ERROR
	MOVE	N,[XWD TTY,.FOUSO]	;SET UP FILOP BLOCK TO DO...
	MOVEM	N,FLP			;...AN APPEND.
	MOVE	N,[XWD 2,FLP]		;SET UP FOR FILOP CALL
	FILOP.	N,			;POINT TO NEXT BLOCK IN SYSTAT.TXT
	BOMB	(Output append failed)	;DIE IF CAN'T APPEND
	RETURN				;
;SUBROUTINE TO TYPE <MESSAGE> N/TEMP = NUM.NUM
;ARGS	M=ADDR OF FIRST ASCIZ MESSAGE
;	N=DIVIDEND
;	TEMP=DIVISOR

SWPPRT:	PUSH	P,N		;SAVE DIVIDEND
	PUSHJ	P,MSGDEC
	MOVSI	A,(SIXBIT ./.)
	MOVE	N,TEMP
	PUSHJ	P,SIXDEC
	MOVEI	M,[ASCIZ / = /]
	POP	P,N		;RESTORE DIVIDEND
	IMULI	N,^D100		;
	IDIV	N,TEMP		;
	PJRST	MSGCPC		;PRINT AS N.MM%
;SUBROUTINE TO PRINT THE USER NAME FOR A JOB.
;ARGS	J=JOB NUMBER

USRNAM:	MOVE	A,@.USNM1	;GET FIRST HALF OF USER NAME
	PUSHJ	P,SIXPRT	;PRINT IT
	MOVE	A,@.USNM2	;GET SECOND HALF
	PUSHJ	P,SIXPRT	;PRINT IT
	PJRST	TAB		;END WITH TAB AND RETURN

;SUBROUTINE TO PRINT ALL 6 CHARACTERS OF A SIXBIT NAME
;ARGS:	A=SIXBIT NAME

SIXPRT:	MOVE	BP,A		;MOVE NAME TO BP
	MOVEI	A,6		;AND SETUP LOOP COUNTER
SIXPR1:	MOVEI	CH,0
	LSHC	CH,6		;MOVE NEXT CHAR OF NAME INTO CH
	ADDI	CH,40		;CONVERT TO ASCII
	PUSHJ	P,TYO		;TYPE IT
	SOJG	A,SIXPR1	;LOOP FOR ALL
	POPJ	P,		;RETURN
NOWHO:
IFN HIDPPN,<
	CAME	A,ME
	TLNE	F,FL.GOD
	POPJ	P,		;RETURN IF OK
	SETO	A,		;HIDE IT--CHANGE NAME
>
	POPJ	P,

ASTSIX:	MOVE	A,[SIXBIT /**,**/]
SP4SIX:	TDNE	A,[-1-77B5]	;SEE IF SHORT NAME
	SKIPE	SEGFLG		;NO--SEE IF SEGMENT MODE
	JRST	TABSIX		;YES--DO TAB THEN PRINT
	MOVEI	N,4		;SPACE 4, THEN SIXBIT
	PUSHJ	P,SPACE
	SOJG	N,.-1
SIXBP:	MOVE	BP,A
SIXBP1:	MOVEI	CH,0
	LSHC	CH,6
	IFN CH-BP+1,<PRINTX BP MUST BE CH+1>
	ADDI	CH,40
	PUSHJ	P,TYO
	JUMPN	BP,SIXBP1
CPOPJ:	POPJ	P,0

TABSIX:	PUSHJ	P,TAB		;SEND TAB
	JRST	SIXBP		;THEN SIXBIT MESSAGE

REPEAT 0,<
;SUBR VERPRT - CALL WITH (137) OR THE LIKE IN N, TYPES STD FORM VERSION
VERPRT:	PUSH	P,N
	LDB	N,[POINT 9,0(P),11]
	PUSHJ	P,OCTPRT
	LDB	CH,[POINT 6,0(P),17]
	JUMPE	CH,VERP1
	ADDI	CH,"A"-1
	PUSHJ	P,TYO
VERP1:	HRRZ	N,0(P)
	JUMPE	N,VERP2
	MOVEI	CH,"("
	PUSHJ	P,TYO
	PUSHJ	P,OCTPRT
	MOVEI	CH,")"
	PUSHJ	P,TYO
VERP2:	LDB	N,[POINT 3,0(P),2]
	JUMPE	N,VERP3
	MOVNS	N
	PUSHJ	P,DECPRT
VERP3:
NPOPJ:	POP	P,N
	POPJ	P,0
>
;SUBROUTINE CALLED TO INSURE THAT DATA FOR MULTIPLE CPU'S IS
;LINED UP PROPERLY.THE CALL IS IDENTICAL TO THE CALL OF GETRSP

GETRS0:	PUSHJ	P,GETRSP	;GET THE DATA
	JRST	STAB		;NO MORE SET TABS
	SKIPE	CPU		;DO NOT SEPERATE PRINT OUT THE FIRST TIME
	PUSHJ	P,PLUS		;PRINT THE SEPERATOR
	PJRST	CPOPJ1		;GIVE A SKIP RETURN

STAB:	MOVE	A,NCPCNF	;GET THE NUMBER OF CPUS
STAB0:	CAMG	A,CPU		;LIGNED UP ALLREADY
	POPJ	P,		;YES GIVE NORMAL RETURNS
	PUSHJ	P,TAB		;PRINT A TAB
	SOJA	A,STAB0		;FILL TILL ALL CPUS DONE

;SUBROUTINE TO GET REL ENTRY FROM MONITOR GETTAB SUB-TABLE
;CALL:	MOVEI	A,DESIRED REL ENTRY IN RESPONSE TABLE
;	MOVEM	CPU #,CPU	;STORE CPU NUMBER = 0,1
;	PUSHJ	P,GETRSP
;	  ERROR RETURN NOT PRESENT FOR THIS CPU
;	OK RETURN CONTENTS IN AC A

GETRSP:	PUSH	P,N1		;SAVE N1
	PUSH	P,B		;SAVE B (GETTB USES B INSTEAD OF A)
	PUSH	P,A		;SAVE RELATIVE ADR IN SUB-TABLE
	MOVE	B,CPU		;CPU WANTED
	CAML	B,NCPCNF	;REALLY THERE
	JRST	GTRSPX		;NO, ERROR RETURN
	IMULI	A,NCPUS		;MAKE INDEX TO RESPONSE TABLE IN CORE
	ADD	A,CPU
	MOVEM	A,RSPIDX
	MOVE	B,[%CCRSP]	;GETTAB IN CPU CONSTANTS TABLE
				;FOR REL ENTRY IN CPU VARIABLE TABLE
				;FOR RESPONSE DATA
	ADD	B,CPU		;FORM FOR THIS CPU
	ADD	B,CPU		;CONSTANTS GETTABS ARE EVERY OTHER
	PUSHJ	P,GETTB		;GET ENTRY FROM MONITOR
	  JRST	GTRSPX		;NOT PRESENT, ERROR RETURN
	ADD	B,(P)		;FORM ADR IN CPU VARIABLE TABLE
	HRL	B,B		;TO LH
	HRRI	B,.GTC0V	;VARIABLE GETTAB FOR CPU0
	ADD	B,CPU		;FOR FOR CPU N
	ADD	B,CPU		;VARIABLE TABLE IS EVERY OTHER
	PUSHJ	P,GETTB		;GET FROM MONITOR
	  SOS	-3(P)		;NOT PRESENT, SET FOR ERROR RETURN
	AOS	-3(P)		;SKIP RETURN(UNLESS ERROR)
GTRSPX:	MOVE	A,B		;PUT RESULT IN A
	POP	P,N1		;RESTORE PD LIST
	POP	P,B		;RESTORE B
	POP	P,N1		;RESTORE N1
	POPJ	P,		;ERROR OR OK RETURN


;SUBROUTINE TO PROVIDE INCREMENTAL RESPONSE VALUE
; RETURNS WITH INCREMENTAL VALUE IN A,  OLD VALUE IN OLDRSP(RSPIDX)
; AND INCREMENTAL VALUE IN DIFRSP(RSPIDX).
;
;CALL:	MOVEI	A,VALUE		;VALUE FROM GETTAB
;	PUSHJ	P,GETDIF	;RSPIDX HAS POINTER (SET BY GETRSP)
;	RETURN HERE

GETDIF:	PUSH	P,B		;SAVE B,N
	PUSH	P,N
	MOVE	N,RSPIDX	;GET TABLE POINTER
	MOVE	B,OLDRSP(N)	;GET PREVIOUS VALUE
	MOVEM	A,OLDRSP(N)	;SAVE NEW AS OLD FOR NEXT TIME
	SUB	A,B		;GET DIFFERENCE
	MOVEM	A,DIFRSP(N)	;SAVE DIFFERENCE IN CASE NEED IT LATER
	POP	P,N		;RESTORE N,B
	POP	P,B
	POPJ	P,		;RETURN,  INCREMENTAL VALUE IN A


;ROUTINE TO COMPUTE INTEGER SQRT:  N=ISQRT(A,B)
;CALLED WITH POS ARG IN "A,B", RESULT RETURNED IN "N", USES N1

ISQRT:	MOVEI	N,0		;PRESET NULL ANSWER
	JUMPL	A,CPOPJ		;RETURN 0 IF NEG
	MOVE	N,A		;COPY ARG
	JFFO	N,.+2		;SET N1 TO NUM 0S
	MOVEI	N1,^D36		;IN CASE ALL ZERO
	SOS	N1		;BACK DOWN FOR SIGN BIT
	TRZ	N1,1		;MAKE SMALLER EVEN
	LSH	B,1		;COMPRESS OUT SIGN BIT OF B
	LSHC	A,-^D35(N1)	;POSITION MOST SIG. BITS IN B
	ASH	N1,-1		;DIVIDE SHIFT BY 2
	MOVNS	N1		;SET TO OTHER WAY FOR ANSWER

	TRO	B,1		;FORCE SOME BITS ON TO TERMINATE
	MOVEI	N,0		;CLEAR ANSWER
ISQ1:	ASH	N,1		;MOVE TO NEXT BIT
	CAMG	A,N		;SEE IF REMAINDER IS BIG
	JRST	ISQ2		;NO--LOOP ON
	SUB	A,N		;DECREASE REMAINDER
	SUBI	A,1		;..
	TRO	N,2		;INCREASE RESULT
ISQ2:	LSHC	A,2		;SHIFT REMAINDER TWO BITS
	JUMPN	B,ISQ1		;LOOP UNTIL DONE
	ASH	A,-1		;BACK OFF REMAINDER
	CAMLE	A,N		;SEE IF ROUNDING NEEDED
	ADDI	N,1		;YES--INCREASE RESULT

	ASH	N,^D17(N1)	;POSITION RESULT
	POPJ	P,		;RETURN
CRLF2:	PUSHJ	P,CRLF
CRLF:	MOVEI	M,[ASCIZ /
/]
MSG:	TLZ	M,-1		;[325]
	TLOA	M,440700
MSG1:	PUSHJ	P,TYO
	ILDB	CH,M
	JUMPN	CH,MSG1
	POPJ	P,

;KAYPEE PRINTS A P OR K DDEPENDING ON THE SYSTEM
;WHOSE SYSTAT IS BEING PRINTED

KAYPEE:	MOVEI	CH,"K"		;ASSUME KA10 FIRST
	SKIPE	CPKI10		;IS IT A KI10?
	MOVEI	CH,"P"		;(YES) THEN A P
	PJRST	TYO		;RETURN AFTER PRINTING

PLUS:	MOVEI	CH,"+"
	JRST	TYO

PERIOD:	MOVEI	CH,"."
	JRST	TYO

COLON:	TLNE	F,FL.SZR	;DON'T PRINT IF SUPPRESSINGZEROES
	POPJ	P,
	MOVEI	CH,":"
	TLNE	F,FL.BZR	;PRINT BLANK IF BLANKING ZEROES
	MOVEI	CH," "
	JRST	TYO

COMMA:	MOVEI	CH,","
	JRST	TYO

SIXTAB:	PUSHJ	P,SIXBP
TAB:	SKIPA	CH,["	"]	;PRINT TAB
SPACE:	MOVEI	CH,40
TYO:	AOS	COLCNT		;COUNT COLUMN
	CAIN	CH,12		;A LINE FEED?
	SETZM	COLCNT		;YES, SET COLUMN COUNT TO LEFT MARGIN
	JUMPL	WD,CPOPJ
	SKIPE	COMTOA		;SPECIAL TYPEOUT ROUTINE?
	PJRST	@COMTOA		;YES, DISPATCH TO IT
	TRNN	F,FR.DPY	;DOES HE WANT PAGED OUTPUT?
	JRST	TYO1		;NO
	CAIN	CH,12		;IS IT A LINE FEED?
	SOSE	LINECT		;COUNT LINES
	SKIPA
	PUSH	P,[HICCUP]	;HANDLE IT LATER
TYO1:	SOSG	TYOB+2
	OUTPUT	TTY,0
	IDPB	CH,TYOB+1
	POPJ	P,0

TYOCH:	OUTCHR	CH
	POPJ	P,
;WE TRICKED TYO INTO RETURNING HERE AFTER THAT LINE FEED
HICCUP:	PUSH	P,M		;SAVE THE REST FOR LATER
	CLRBFI			;CLEAR THE INPUT BUFFER
	OUTPUT	TTY,0		;EMPTY THE BUFFER JUST IN CASE
	TTCALL	2,M		;RESET THE ^O SWITCH
	  JRST	.+3		;NOTHING TYPED
	CAIN	M,3		;HE SAID SOMETHING, WAS IT ^C?
	JRST	EXIT.		;YES, QUIT
	OUTSTR	[ASCIZ/Type any single character to continue:/]
	INCHRW	M		;WAIT UNTIL HE TYPES SOMETHING, THEN EAT IT
	CAIE	M,15	
	OUTSTR	[ASCIZ /
/]				;SEND CAR.RETURN IF USER DIDN'T.
	CAIN	M,3		;IS IT ^C ?
	JRST	EXIT.		;YES, QUIT!
	CAIN	M,15
	INCHRW	M		;ACCEPT SCANNER SERVICE L.F.
	MOVEI	M,^D19		;PAGE SIZE LESS ONE
	MOVEM	M,LINECT	;RESET THE COUNTER
	POP	P,M		;RESTORE THE REGISTER
	POPJ	P,		;REMEMBER WE HAD STOLEN TYO'S RETURN

OPRN2X:	MOVEI	CH,77		;PRINT OCTAL AT LEAST 2 DIGITS

;PRINT OCTAL FIXED NUMBER OF PLACES
;CALL: CH=BIGGEST VALUE, N=VALUE
FIXOCT:	LSH	CH,-3		;POSITION MASK
	SKIPE	CH		;SEE IF OUT OF PREFIX
	CAMLE	N,CH		;SEE IF DONE
	JRST	OPRNT		;YES--OUTPUT NUMBER
	PUSH	P,CH		;PRESERVE MASK
	PUSHJ	P,SPACE		;OUTPUT FILLER
	POP	P,CH		;RESTORE MASK
	JRST	FIXOCT		;LOOP FOR MORE

;OCTAL OUTPUTS
OPRNT:	MOVEI	R,10		;REGULAR RADIX
	JRST	RDXPRT		;GO DO IT
TCKTIB:	TLOA	F,FL.BZR	;BLANK LEADING ZEROES
TCKTIS:	TLO	F,FL.SZR	;SUPPRESS ZEROES
TCKTIM:	IDIV	A,TCKSEC	;JUNK JIFFIES
	ASH	B,1		;ROUND?
	CAML	B,TCKSEC
	ADDI	A,1		;ROUND-UP
TIME:	PUSH	P,A		;ASVE TIME FOR LATER TEST
	IFGE  FTAMPM,<
	IFE   FTAMPM,<
	MOVSI	B,(CLKCYC)	;GET FLAG FOR 50 HERTZ
	TDNE	B,STATES	;IN STATES WORD
	TRZ	F,FR.DAY	;YES--CLEAR AM/PM REQUEST
>
	TRNE	F,FR.DAY	;SEE IF AM/PM HACK
	CAIGE	A,^D12*^D60*^D60  ;YES--SEE IF PM
	JRST	.+2		;NO--SKIP
	SUBI	A,^D12*^D60*^D60  ;YES--SUBTRACT 12 HOURS
>
	IDIVI	A,^D60*^D60
	IFL   FTAMPM,<
	MOVE	N,A
>
	IFGE  FTAMPM,<
	SKIPN	N,A
	TRNN	F,FR.DAY
	JRST	.+2
	MOVEI	N,^D12
>
	PUSHJ	P,DECP2X
	PUSHJ	P,COLON
	IDIVI	B,^D60
	MOVE	N,B
	PUSHJ	P,DECPR2
	PUSHJ	P,COLON
	MOVE	N,C
	MOVEI	C,DECPR2	;PRESET ROUTINE
	TLZE	F,FL.SZR
	MOVEI	C,DECPRT	;IF SUPPRESSING, MAKE SURE WE PRINT SOMETHING
	TLZE	F,FL.BZR
	MOVEI	C,DECP2X	;LIKEWISE FOR BLANKING
	PUSHJ	P,(C)		;PRINT FINAL FIELD
	POP	P,C		;RECOVER ARGUMENT
	IFGE  FTAMPM,<
	MOVEI	M,[ASCIZ / a.m./]
	CAIL	C,^D12*^D60*^D60
	MOVEI	M,[ASCIZ / p.m./]
	TRZE	F,FR.DAY	;SEE IF AM/PM HACK
	JRST	MSG		;YES--OUTPUT SUFFIX
>
	POPJ	P,		;NO--RETURN
OCTPRJ:	PUSH	P,A
	PUSH	P,N
	PUSH	P,COLCNT
	PUSH	P,WD
	SETO	WD,		;COUNT, DON'T PRINT
	PUSHJ	P,OCTPRT
	MOVE	N,COLCNT	;NOW COMPUTE HOW TO FORMAT IT
	SUB	N,-1(P)
	SUBI	N,^D13		;IT TAKES 13 DIGITS TO PRINT THE LARGEST 
				; OCTAL NUMBER. E.G., NNNNNN,NNNNNN
	POP	P,WD
	POP	P,COLCNT
	SKIPGE	N
	PUSHJ	P,SPACE
	AOJL	N,.-1
	POP	P,N
	POP	P,A
	JRST	OCTPRT
DECPRJ:	JUMPL	N,DECPJ2	;JUST FOR SAFETY'S SAKE
	MOVE	A,[^D10000000000]
DECPJ1:	CAML	N,A
	JRST	DECPJ2
	PUSHJ	P,SPACE
	IDIVI	A,^D10
	JRST	DECPJ1
DECPJ2:	JUMPGE	WD,DECPRT
	POPJ	P,
DECP3X:	MOVEI	CH," "
	CAIG	N,^D99
	PUSHJ	P,TYO
	JRST	DECP2X		;PRINT 3 DECIMAL DIGITS
DECPR2:	MOVEI	CH,"0"
	TLNE	F,FL.BZR	;SUBSTITUTE BLANK IF BLANKING ZEROES
DECP2X:	MOVEI	CH," "
	CAIG	N,^D9
	TLNE	F,FL.SZR	;DON'T PRINT IF SUPPRESSING ZEROES
	JRST	DECPRT
	PUSHJ	P,TYO
DECPRT:	MOVEI	R,^D10
RDXPRT:	MOVEI	CH,"-"
	JUMPGE	N,RADIX1
	PUSHJ	P,TYO
	MOVMS	N
RADIX1:	JUMPN	N,RADIX2	;DEFINITELY PRINT IF NON-ZERO
	TLNN	F,FL.SZR!FL.BZR	;SEE IF BLANKING OR SUPPRESSING
	JRST	RADIX2		;NO--PRINT ONE ZERO
	MOVEI	CH," "
	TLNN	F,FL.SZR	;SEE IF SUPPRESSING ZEROES
	PUSHJ	P,TYO		;NO--BLANKING SO OUTPUT SPACE
	POPJ	P,		;YES--RETURN
RADIX2:	TLZ	F,FL.SZR!FL.BZR	;STOP ANY ZERO SUPPRESSION
	IDIVI	N,(R)
	HRLM	N1,0(P)
	SKIPE	N
	PUSHJ	P,RADIX2
	HLRZ	CH,0(P)
	ADDI	CH,"0"
	JRST	TYO

DECTAB:	PUSHJ	P,DECPRT
	JRST	TAB
CPCPT:	CAIG	N,^D999		;NN.N% FORM?
	JRST	CPCPT2		;NO
	IDIVI	N,^D100		;YES, REDUCE TO JUST PERCENT
	CAILE	N,^D99		;100%?
	PJRST	DECPRT		;YES, THAT'S OUR THREE DIGITS
	PUSH	P,N1		;HOLD REMAINDER
	PUSHJ	P,DECPRT	;NO, PRINT TWO DIGITS
	MOVEI	CH,"."		;FOLLOW BY PERCENT INDICATOR
	PUSHJ	P,TYO		;AND CAP IT OFF
	POP	P,N		;GET IT BACK
	IDIVI	N,^D10		;ONLY TENTHS
	PJRST	DECPRT		;TYPE IT OUT
CPCPT2:	CAIG	N,^D99		;N.N FORM?
	JRST	CPCPT4		;NO
	IDIVI	N,^D100		;GET PERCENTAGE DIGIT
	MOVEI	CH,"0"(N)	;IN ASCII
	PUSHJ	P,TYO		;AND PRINT IT OUT
	MOVEI	CH,"."		;SEPARATING DOT
	PUSHJ	P,TYO		;PRINT IT ALSO
	MOVE	N,N1		;GET BACK THE HUNDREDTHS
	IDIVI	N,^D10		;TENTHS OF PERCENT
	MOVEI	CH,"0"(N)	;IN ASCII
	PJRST	TYO		;AND PRINT IT OUT
CPCPT4:	MOVEI	CH,"."		;LEADING DECIMAL
	PUSHJ	P,TYO		;INDICATE HUNDREDTHS
	MOVEI	CH,"0"		;IN CASE NEED LEADING "0"
	CAIG	N,^D9		;LESS THAN .10 PERCENT?
	PUSHJ	P,TYO		;YES, NEED LEADING "0"
	PJRST	DECPRT		;TYPE HUNDREDTHS OF PERCENT
THISIS:	MOVEI	M,[BYTE (7) 14,0,0,0]	;GIVE HIM A FORM FEED
	TLNE	F,FL.LPT	;IF HE IS OUTPUTTING TO THE LPT
	PUSHJ	P,MSG		;OTHERWISE NOT
	TLNN	F,FL.DSK	;SEE IF WE SHOULD TYPE THIS STUFF
	JRST	NULDEV		;NO, GO DO NORMAL THINGS
	SKIPN	INFILE		;IF NO FILE NAME THEN NO DESCRIPTION
	JRST	NULDEV		;SO GET OUT OF HERE
	MOVEI	M,[ASCIZ/[Status report from crash file /] ;GIVE MESSAGE
	PUSHJ	P,MSG		;SHOULD HELP PRETTY IT UP
	MOVE	A,INDEV		;GET THE DEVICE TYPE
	JUMPE	A,INFIL		;IN CASE OF NULL DEV
	PUSHJ	P,SIXBP		;OUTPUT IT
	MOVEI	M,[ASCIZ/:/]	;PUT THE COLON OUT THERE
	PUSHJ	P,MSG		;OUT IT
INFIL:	MOVE	A,INFILE	;GET THE FILE NAME
	PUSHJ	P,SIXBP		;PUT IT OUT THERE
	MOVEI	M,[ASCIZ/./]	;SEPERATE WITH A PERIOD
	PUSHJ	P,MSG		;OUT IT
	SKIPN	A,INEXT		;GET EXTENSION IF GIVEN
	MOVSI	A,'EXE'		;ELSE DEFAULT TO .EXE IF BLANK
	PUSHJ	P,SIXBP		;PUT IT OUT ALSO
	MOVEI	M,[ASCIZ/]
/]				;PUT THE CLOSING TEXT OUT THERE
	PUSHJ	P,MSG		;PUT IT OUT
NULDEV:				;ADD LABEL NULDEV
	SKIPA	M,[[ASCIZ /
Status of /]]
CRSMSG:	MOVEI	M,[ASCIZ/Monitor is /]
	PUSHJ	P,MSG
	MOVEI	B,0
	MOVEI	C,11		;TAB
SYS2:	MOVEI	M,A
	MOVE	A,C
	PUSHJ	P,GETA
	PUSHJ	P,MSG
	AOBJN	C,.+1
	TRNE	A,376
	SOJA	C,SYS2
	MOVEI	M,[ASCIZ / at /]
	PUSHJ	P,MSG
	MOVE	A,XTIME
	PUSHJ	P,GETA
	MOVEM	A,NOW		;SAVE FOR LATER
	IFGE  FTAMPM,<
	TRO	F,FR.DAY	;SET FOR DATE AM/PM HACK
>
	PUSHJ	P,TCKTIM
	MOVEI	M,[ASCIZ / on /]
	PUSHJ	P,MSG
	MOVE	A,XDATE		;GET TODAY'S DATE
	PUSHJ	P,GETA		;FRESHLY
	IDIVI	A,^D31
	MOVEI	N,1(B)
	PUSHJ	P,DECPR2
	IDIVI	A,^D12
	MOVE	B,MONTAB(B)
	MOVEI	C,0
	MOVEI	M,B
	MOVEI	N,^D64(A)
	PUSHJ	P,MSGDEC	;PRINT MESSAGE FOLLOWED BY DECIMAL NO.
	SKIPE	COMTOA		;SPECIAL TYPEOUT ROUTINE?
	POPJ	P,		;YES, NO CRLF AT END
	CALL	CRLF		;PRINT IT
	OUT	TTY,		;DO OUTPUT
	RETURN
	BOMB	<Output failed>	;ERROR ON OUTPUT
;SUBROUTINE TO PRINT PROJECT PROGRAMMER NUMBER AS A PAIR
;IF ZERO, RETURN
;IF SAME AS SYSPPN, PRINT "SYS"
;IF SAME AS MY PPN, PRINT "[SELF]"
;IF SIGN BIT ON, PRINT IN SIXBIT
;ELSE, PRINT AS PAIR OR OCTAL NUMBERS
;ENTERED WITH PPN TO BE PRINTED IN A
;USES N,R,N1,BP,CH

PNTPPN:	SKIPN	A		;SEE IF NULL
	POPJ	P,		;YES--RETURN
	CAMN	A,[-1]		;SEE IF HIDDEN
	JRST	ASTSIX		;YES--PRINT ASTERISKS
	CAMN	A,FSFPPN	;SEE IF OPERATOR
	MOVE	A,[SIXBIT /[OPR]/]
	CAMN	A,SYSPPN
	MOVE	A,[SIXBIT /[SYS]/]  ;TYPE NAME FOR SYS
	SKIPN	ONEJOB		;SEE IF SELF
	TLNE	F,FL.GOD!FL.LPT	;SEE IF OPERATOR
	JRST	NOTSLF		;YES--SKIP SELF CHECK
	CAMN	A,ME		;SEE IF ME
	MOVE	A,[SIXBIT /[SELF]/]
NOTSLF:	IFN STANSW,<JRST TABSIX>
	IFE STANSW,<
	JUMPLE	A,SP4SIX	;PRINT AS NAME IF SIXBIT
	TLNE	A,7B20		;WIDE PROJECT NUMBER?
	PUSHJ	P,SPACE		;YES--SPACE OVER
	PUSH	P,A		;SAVE ARGUMENT
	HLRZ	N,A		;GET LEFT HALF
	MOVEI	CH,-1		;SETUP MASK FOR 6 DIGITS
	PUSHJ	P,FIXOCT	;OUTPUT IN FIXED FORMAT
	JRST	OCTCRH		;GO FINISH IN  VARIABLE FORM
>

;PRINT OCTAL AS UNSIGNED HALVES
OCTPRA:	MOVE	N,A		;MOVE DATUM
OCTPRT:	PUSH	P,N
	HLRZ	N,N
	JUMPE	N,OCTRH
	PUSHJ	P,OPRNT		;OUTPUT IN OCTAL
OCTCRH:	PUSHJ	P,COMMA
OCTRH:	HRRZ	N,(P)
	PUSHJ	P,OPRNT		;OUTPUT IN OCTAL
	POP	P,N
	POPJ	P,
	JRST	RDXPRT
;SUBROUTINE TO GET A CH. FROM COMMAND BUFFER
;CALL	PUSHJ	P,GETCHR
;	NONE LEFT OR BREAK CH. FOUND
;	GOT A CH. RETURN
;AC WD IS RETURNED WITH THE CH.
;AC F WILL HAVE FL.BRK SET IF BREAK CH. FOUND

GETCHR:	SKIPE	WD,SAVCHR	;SEE IF ALREADY HOLDING CHAR
	JRST	[SETZM	SAVCHR	;YES--CLEAR IT
		 JRST	CPOPJ1]	;AND RETURN IT
	TLNE	F,FL.BRK	;SEE IF ALREADY AT END
	JRST	FLAGIT		;YES
	ILDB	WD,CMDPTR	;GET CHARACTER
	CAIN	WD,0		;NULL CHARACTER ?
	JRST	FLAGIT		;YES--NONE LEFT
	CAIN	WD,3		;IS IT ^C ?
	EXIT	1,		;YES, ABORT, ABORT, ABORT
	CAIL	WD,"A"+40	;CHECK LOWER CASE
	CAILE	WD,"Z"+40
	JRST	.+2		;NO
	SUBI	WD,40		;YES
	CAIN	WD,11		;SEE IF TAB
	MOVEI	WD," "		;YES--CHANGE TO SPACE
	CAIG	WD,14		;IS IT LF,VT
	CAIGE	WD,12		;FF OR
	CAIN	WD,33		;ALTMODE?
	JRST	FLAGIT		;YES - NON SKIP RETURN
	CAIE	WD,176		;OTHER KINDS
	CAIN	WD,175		;OF ALTMODE?
	JRST	FLAGIT		;YES - NON SKIP
IFE FTDEBUG,<
	TRNE	F,FR.CMT	;ARE WE IN A COMMENT?
	JRST	GETCHR		;YES - THROW IT AWAY
	CAIE	WD,";"		;IS THIS A COMMENT?
	CAIN	WD,"!"		;EITHER KIND?
	JRST	.+2		;YES, GO HANDLE IT
>
	JRST	CPOPJ1		;NONE OF THE ABOVE, RETURN IT.
IFE FTDEBUG,<
	TRO	F,FR.CMT	;INTO A COMMENT
	JRST	GETCHR		;SO THROW THE CHAR AWAY.
>

FLAGIT:	TLO	F,FL.BRK	;FLAG THAT BREAK FOUND
	POPJ	P,		;NON SKIP RETURN

;GET RADIX INPUT
GETRDC:	TDZA	N,N		;CLEAR ANSWER AND SUCK CHAR
GETRDX:	TDZA	N,N		;CLEAR ANSWER
GETRD1:	PUSHJ	P,GETCHR	;GET NEXT DIGIT
	  JFCL			;IGNORE END
	CAIL	WD,"0"		;SEE IF DIGIT
	CAIL	WD,"0"(R)	;..
	JRST	[EXCH	WD,SAVCHR	;NO--SAVE FOR NEXT SCAN
		 POPJ	P,]		;RETURN
	IMULI	N,(R)		;YES--ADVANCE RESULT
	ADDI	N,-"0"(WD)	;ADD DIGIT
	JRST	GETRD1		;LOOP FOR MORE

; @GETRD1+7 1/2, ADD ROUTINE RDCMND, JMT, 3-MAY-76
;SUBROUTINE TO READ COMMAND INTO COMMAND BUFFER
;IF THIS IS THE FIRST TIME, AND TO RESET THE POINTER
;TO THE BEGINNING.
;CALL:
;	PUSHJ	P,RDCMND
;	 . .		;RETURNS HERE
;ACS A & WD ARE DESTROYED

RDCMND:	MOVE	A,ORGPTR	;GET ORIGIONAL POINTER
	MOVEM	A,CMDPTR	;AND RESET COMMAND POINTER
	SETZM	SAVCHR		;RESET LOOK AHEAD
	TLZ	F,FL.BRK	;AND CLEAR BREAK FLAG
	SKIPE	GOTCMD		;GOT COMMAND ALREADY?
	  RETURN		;YES, RETURN
	RESCAN	1		;TRY TO READY COMMAND LINE
	SKPINC			;ANYTHING?
	  JRST	FLAGIT		;NO, RETURN EOF.
RDCMD1:	TTCALL	2,WD		;GET CHARACTER
	  JRST	RDCMD2		;NO MORE LEFT
	IDPB	WD,CMDPTR	;STORE CHARACTER IN BUFFER
	HRRZ	A,CMDPTR	;WHERE DID WE PUT THAT CHAR?
	CAIL	A,CDENDP	;IN THE LAST WORD??
	 JRST CBOFLO		;YES, OVERFLOW ERROR
	CAIG	WD,14		;IS IT LF, VT
	CAIGE	WD,12		;FF OR
	CAIN	WD,33		;ALTMODE ?
	JRST	RDCMD2		;YES--NO MORE LEFT
	CAIE	WD,176		;OTHER KINDS
	CAIN	WD,175		;OF ALTMODES ?
	JRST	RDCMD2		;YES--THAT'S IT
	JRST	RDCMD1		;NO--LOOP BACK FOR REST OF LINE

RDCMD2:	SETZ	WD,		;CLEAR WD TO MAKE NULL
	IDPB	WD,CMDPTR	;MARK BUFFER END WITH NULL
	MOVE	A,ORGPTR	;GET ORIGIONAL BUFFER POINTER
	MOVEM	A,CMDPTR	;AND RESET COMMAND POINTER
	SETOM	GOTCMD		;SET COMMAND GOTTEN FLAG
	MOVE	A,ORGPTR	;GET ORIGIONAL POINTER
	MOVEM	A,CMDPTR	;AND RESET COMMAND POINTER
	SETZM	SAVCHR		;RESET LOOK AHEAD
	TLZ	F,FL.BRK	;AND CLEAR BREAK FLAG
	POPJ	P,0		;RETURN



CBOFLO:	JSP	M,BOMB.		;
	ASCIZ /Input line too long/
;SUBROUTINE TO DIVIDE A NUMBER IN AC N BY TEMP
;ROUND UP RESULT IF NECESSARY AND PRINT MESSAGE FOLLOWED BY N (%)
;CALL	MOVEM	AC,TEMP
;	MOVE	N,NUMBER TO BE DIVIDED
;	MOVEI	M,[ASCIZ /TEXT/]
;	PUSHJ	P,DIVRPT
;	ALWAYS	RETURN
;ACS N1,N,M,CH & R ARE DESTROYED

CMPCNA:	MOVE	N,A
CMPCNT:	IMULI	N,^D100
	IDIV	N,TEMP
	LSH	N1,1
	CAML	N1,TEMP
	ADDI	N,1

MSGDEC:	PUSHJ	P,MSG
	JRST	DECPRT

SIXDEC:	PUSHJ	P,SIXBP
	JRST	DECPRT

DECMSG:	PUSHJ	P,DECPRT	;OUTPUT DECIMAL
	JRST	MSG		;THEN MESSAGE

MSGOCT:	PUSHJ	P,MSG		;SEND MESSAGE
	JRST	OCTPRT		;THEN OCTAL

MSGCPC:	PUSHJ	P,MSG		;OUTPUT MESSAGE
	JRST	CPCPT		;THEN PERCENTAGE
;SUBROUTINE TO CHECK IF A SEGMENT IS INACTIVE
;INACTIVE IS DEFINED AS RUN BIT OFF OR TI/SL/EW STATE
;ARGS	J=SEGMENT NUMBER IN RH
;NON-SKIP RETURN IF ACTIVE, SKIP RETURN IF INACTIVE

INACTC:	SKIPL	R,@.STS		;SKIP IF RUN BIT ON
	JRST	CPOPJ1		;OFF, INACTIVE
	LDB	R,[POINT 5,R,14];GET WAIT STATE CODE
	CAMN	R,SLQ		;SKIP IF DOESNT MATCH
	JRST	CPOPJ1		;YES, ONE MATCHES, INACTIVE
	CAME	R,TIQ		;IN "TI" STATE?
	CAMN	R,EWQ		;IN "EW" STATE?
	JRST	CPOPJ1		;YES, MATCHES, INACTIVE
	POPJ	P,		;NO, MUST BE ACTIVE

;SUBROUTINE TO PRINT (N) AS A PERCENTAGE OF (CH), RIGHT JUSTIFIED
;CALL	MOVE	CH,REFERENCE NUMBER
;	MOVE	N,NUMBER TO BE DIVIDED
;	PUSHJ	P,PNCT2
;	ALWAYS	RETURN
;ACS N1,N,CH & R ARE DESTROYED

PCNT2:	IMULI	N,^D100
	IDIV	N,CH
	LSH	N1,1
	CAML	N1,CH
	ADDI	N,1

	MOVEI	CH," "		;FOR A LEADING BLANK
	CAIG	N,^D9		;DO WE NEED IT TO RIGHT JUSTIFY?
	PUSHJ	P,TYO		;YES
	JRST	DECPRT

;SUBROUTINE TO PRINT INTEGER+1 DIGIT FRACTION
;CALL:	MOVEM	TEMP		NUMBER TO DIVIDE BY
;	MOVE	A,NUMBER TO BE DIVIDED
;	PUSHJ	P,CMPDFA
;	ALWAYS RETURN

CMPDFA:	MOVE	N,A
CMPDFN:	IMULI	N,^D10		;* 10
	IDIV	N,TEMP		;DIVIDE BY #K AVAILABLE
	LSH	N1,1		;REMAINDER * 2
	CAML	N1,TEMP		;TEST FOR ROUNDING NEEDED
	AOJ	N,		;YES, INCR QUOTIENT BY 1
	IDIVI	N,^D10		;DIVIDE TO GET INTEGER/FRACTION
	PUSH	P,N1		;SAVE FRACTION FOR LATER
	PUSHJ	P,MSGDEC	;PRINT MSG & INTEGRAL PART
	POP	P,N		;RESTORE FRACTIONAL DIGIT
	MOVEI	M,[ASCIZ /./]
	PJRST	MSGDEC		;PRINT DEC. POINT & FRACTION

;SUBROUTINE TO PRINT JIFFY TIME TO NEAREST TENTHS OF SECONDS
;CALL:	MOVE	N,TIME IN JIFFIES
;	PUSHJ	P,PNTSEC

PNTSEC:	MOVE	A,TCKSEC	;NO. OF JIFFIES IN 1 SECOND
	MOVEM	A,TEMP		;STORE FOR CMPDFN
	PJRST	CMPDFN		;GO PRINT RATIO
;SUBROUTINE TO PRINT SMALL TIME VALUE
;CALL	MOVE A,VALUE IN JIFFIES
;	PUSHJ	P,TIMPR
;	 .. RETURN

TIMPR:	IMULI	A,^D100
	IDIV	A,TCKSEC	;FORM .01 SECONDS
	TLO	F,FL.SZR	;SUPPRESS ZEROES
	JRST	MEMPR1

;SUBROUTINE TO CONVERT BLT TIME TO SECONDS (ROUNDED)
;PRINTS MESSAGE FOLLOWED BY TIME
;CALL	MOVE	A,BLT COUNT
;	MOVEI	M,[ASCIZ /TEXT/]
;	PUSHJ	P,MEMPR
;	ALWAYS	RETURN
;ACS A,B,C,N,N1,M,CH & R ARE DESTROYED

MEMPR:	TLO	F,FL.SZR	;SUPPRESS ZEROES
	PUSHJ	P,MSG		;SEND MESSAGE
	MUL	A,MEMNSP	;=TOTAL N-SEC/2
	DIV	A,[^D5000000]	;=TOTAL .01 SEC
MEMPR1:	TLNE	B,200000	;CHECK ROUND
	ADDI	A,1		;ROUND-UP
	IDIVI	A,^D100		;GET SEC
	PUSH	P,B		;SAVE .01S
	PUSHJ	P,TIME		;PRINT HR:MIN:SEC
	PUSHJ	P,PERIOD	;PRINT .
	POP	P,N		;RESTORE .01S
	PUSHJ	P,DECPR2	;PRINT .01S
	POPJ	P,		;RETURN


;SUBROUTINE SEGLOK CHECKS IF A SEGMENT IS LOCKED IN CORE
; J=JOB # OR HIGH SEG #
; N=SIZE OF SEGMENT
; UPDATES MAXMAX TO INCLUDE LOCKED SEG SIZE
; ALWAYS NON-SKIP RETURN
;
SEGLOK:	SETOM	LOKCHK		;FLAG THAT WE WERE HERE
	PUSH	P,B		;SAVE B
	MOVE	B,@.STS		;GET STATUS WORD
	TLNE	B,NSWP!NSHF	;SEE IF LOCKED
	ADDM	N,MAXMAX	;YES,UPDATE MAXMAX W/ SIZE OF LOCKED SEG
	POP	P,B		;(NO)RESTORE B
	POPJ	P,		;RETURN
;SUBROUTINE TO COMPUTE THE SIZE OF A HI OR LOW SEGMENT
;ENTERRED WITH J=JOB OR SEGMENT NUMBER;   IF JOB, JS=STATUS
;RETURN WITH N=SIZE IN K
;RESPECTS ALL AC'S

SEGSZ:	MOVEI	N,(J)		;CHECK RANGE.
	CAML	N,BOTH		;..
	JRST	SEGSZ4		;NO GOOD
	TRNN	F,FR.VMF	;IS THIS A VM SYSTEM?
	JRST	SEGSZ7		;(NO) USE THE CLASSIC LOGIC
	MOVE	N,@.SWP		;(YES) ASSUME WE NEED IMGIN FIELD
	TLNN	F,FL.HSG	;IF THIS IS NO HIGH SEGMENT 
	JRST	SEGSZ6		;THEN RETURN LAST 9 BITS
SEGSZ8:	MOVE	N,@.STS		;ELSE SEE IF IT IS
	TLNE	N,SHRSEG	;NONSHARABLE
	JRST	SEGSZ7		;SHARABLE IS OLD LOGIC
	PUSHJ	P,NSHSZ		;IT IS NONSHARABLE
	JRST	SEGSZ6		;RETURN 9 BITS
SEGSZ7:	MOVS	N,@.ADR		;FETCH SEGMENT ADDRESS AND SIZE IN CORE
	JUMPE	N,SEGSZ1	;JUMP IF NOT IN CORE
	TLNN	F,FL.HSG	;TEST IF HI-SEG REQUEST
	TLNN	JS,JSWP		;N0--SEE IF SWAPPED OUT
	JRST	SEGSZ2		;HI-SEG OR IN-CORE LO-SEG
SEGSZ1:	MOVE	N,@.SWP		;FETCH SWAPPING DATA
	TRNE	N,377		;SEE IF OUT YET
	JRST	SEGSZ3		;(IN-CORE SIZE)
	MOVS	N,@.ADR		;NO. USE IN-CORE VALUE ANYWAY
SEGSZ2:	SKIPE	CPKI10
	JRST	SEGSZ5		;DO KI10 WORK
	ADDI	N,1777		;ROUND IN-CORE SIZE UP
	ASH	N,-^D10		;DIVIDE BY 1K
SEGSZ3:	ANDI	N,377		;MASK RESULT TO 256K
	POPJ	P,		;RETURN
SEGSZ4:	MOVEI	N,777		;RETURN HUGE NUMBER
	POPJ	P,0
SEGSZ5:	ADDI	N,777		;ROUND TO PAGES
	LSH	N,-^D9
SEGSZ6:	PUSH	P,A
	TLNE	F,FL.HSG
	JRST	SEGSZ9
	MOVE	A,MONVER
	CAILE	A,70207
	TLZA	N,777770
SEGSZ9:	ANDI	N,777
	POP	P,A
	POPJ	P,

;SUBROUTINE TO RETURN SIZE OF A NON-SHARABLE HIGH SEGMENT. ENTER J=SEGMENT NUMBER.

NSHSZ:	PUSH	P,A		;SAVE A TEMP TO USE FOR GETTAB
	HRLZ	A,J		;SEGMENT NUMBER
	HRRI	A,7		;GETTAB TABLE NUMBER
	PUSHJ	P,GETZ		;GET SIZE
	HLRZ	N,A		;IN THE LEFT HALF
	POP	P,A		;RESTORE TEMP
	POPJ	P,		;AND RETURN
;SUBROUTINE TO FIND 1ST. JOB USING A SEGMENT
;CALL	MOVE	J,SEGMENT NO.
;	PUSHJ	P,SEGSCN
;	NONE FOUND RETURN
;	FOUND
;AC'S B & C DESTROYED
;AC J IS RESPECTED

SEGSCN:	MOVN	B,JOBN
	HRLZS	B
	HRR	B,.SGN		;PREPARE AOBJN PTR. FOR SCANNING JBTSGN
HIGH06:	HRRZ	C,(B)		;GET SEGMENT NO.
	CAIE	C,(J)		;DOES IT MATCH WITH CURRENT ONE?
HIGH6A:	AOBJN	B,HIGH06	;NO-DO AGAIN
	JUMPL	B,CPOPJ1	;WE HAVE A MATCH?
	POPJ	P,		;NO-NONE FOUND RETURN


;SUBROUTINE TO PRINT A MSG. FOLLOWED "SW" IF SEGMENT SWAPPED & NOT FRAGMENTED
; OR "SF" IF SWAPPED & FRAGMENTED, OR "FR" IF JUST FRAGMENTED & A HISEG
; OR NOTHING IF IN CORE & NOT FRAGMENTED
;CALL	MOVE	JS,JOB/HISEG STATUS
;	MOVE	B,CORE SIZE (HI ONLY)
;	MOVSI	A,(SIXBIT .XX.)
;	PUSHJ	P,LOPSWP/HIPSWP
;	ALWAYS GOOD RETURN
;AC'S A,B,BP,CH ARE DESTROYED
;AC JS IS RESPECTED  *******MSG TO BE PRINTED MUSTN'T EXCEED 4 CHS.********

HIPSWP:	TLNE	JS,JSWP		;IS HI SEG SWAPPED?
	JRST	LOPSW1		;YES - GO PRINT "SW" OR "SF"
	SKIPL	@.SWP		;CORE IMAGE FRAGMENTED ON DISK?
	JRST	LOPSW3		;NO
	PUSHJ	P,SIXBP
	MOVSI	A,(SIXBIT .FR.)	;YES - PRESUME HISEG IN CORE
	JRST	LOPSW2		;YES - PRINT "FR"

LOPSWP:	SETZ	B,
	TLNN	JS,JSWP		;IS SEG SWAPPED?
	JRST	LOPSW3		;NO - PRINT MSG & EXIT
LOPSW1:	PUSHJ	P,SIXBP
	MOVEI	A,.GTSWP	;JBTSWP
	HRL	A,J		;SEGMENT NUMBER
	PUSHJ	P,GETZ		;GET CONTENTS OF JBTSWP
	SKIPL	A		;FRAGMENTED?
	SKIPA	A,[SIXBIT /SW/]	;NO
	MOVSI	A,(SIXBIT /SWF/);YES, INDICATE SWAPPED & FRAGMENTED
	CAIGE	B,^D100		;SKIP SPACE IF NO ROOM
LOPSW2:	PUSHJ	P,SPACE
LOPSW3:	PUSHJ	P,SIXBP		;PRINT "FR","SF" OR "SW"
	LDB	N,IMGOUT	;GET CORE SIZE ON DISK
	MOVE	B,MONVER	;GET MONITOR VERSION NUMBER
	CAILE	B,70207		;BEFORE 7.03?
	LDB	N,[POINT 21,@.SWP,35] ;7.03 IS DIFFERENT
	ADDM	N,DSKUSE	;ADD TO TOTAL SPACE USED ON SWAPPING SPACE
	TLNN	F,FL.DOR
	JRST	TAB		;PRINT TAB & EXIT
	POPJ	P,
;	SUBROUTINE TO SIMULATE CTLJOB UUO WHEN SYSTATING
;A CRASH FILE.
;CALL WITH PTY NAME AND NUMBER IN A.
;RETURNS CONTROLLING JOB NUMBER IN N.
;GIVES DOUBLE SKIP RETURN TO JUMP OVER CTLJOB UUO AND ITS ERROR RETURN.
;
CTLJB:	PUSH	P,A		;SAVE DEVICE NAME
	MOVE	A,XDVLST	;TABLE FOR GETTAB UUO
	PUSHJ	P,GETZ		;GET ADDR OF FIRST DDB
	HLRZ	D,A		;MOVE IT TO D
	POP	P,A		;GET BACK PTY NAME
	PUSHJ	P,CNVERT	;CONVERT RIGHT HALF OF PTY NAME TO SIXBIT
	PUSH	P,JS		;SAVE JS
	MOVEI	JS,^D10000	;PREVENT INFINITE LOOP
CTLLOP:	JUMPE	D,ENDDEV	;LAST DDB ENCOUNTERED?
	MOVEI	C,DV.MOD(D)	;NO,GET ITS CHARCTERISTICS
	PUSHJ	P,PEEKC		;FETCH IT
	MOVE	B,C		;
	TRNN	B,ASSCON+ASSPRG	;IN USE?
	JRST	NEXTDV		;NO,GET THE NEXT DDB
	MOVEI	C,DV.NAM(D)	;GET DEVICE NAME FROM DDB
	PUSHJ	P,PEEKC		;FETCH IT
	CAME	A,C		;SAME?
	JRST	NEXTDV		;NO,GET ANOTHER DDB
	MOVE	C,.DVJOB	;GET POSITION OF CONTROLLING JOB IN DDB
	ADD	C,D		;ADDRESS OF DDB+JOB OFFSET
	SKIPN	NPJOBN		;OLD STYLE?
	MOVEI	C,DV.CHR(D)	;YES
	HRRZS	C		;MAKE SURE LEFT HALF IS EMPTY
	PUSHJ	P,PEEKC		;FETCH IT
	LDB	N,PJOBN		;LOAD THE CONTROLLING JOB'S NUMBER
	SKIPE	NPJOBN		;
	LDB	N,NPJOBN	;TRY AGAIN
	JRST	ENDDEV+1	;DOUBLE SKIP RETURN
NEXTDV:	MOVEI	C,DV.SER(D)	;GET LINK TO NEXT DDB
	PUSHJ	P,PEEKC		;FETCH IT
	HLRZ	D,C		;
	SOJG	JS,CTLLOP	;LOOP FOR MORE
ENDDEV:	SETZM	N		;COULDN'T FIND CONTROLLING JOB
	POP	P,JS		;GET IT BACK
	JRST	CPOPJ2		;DOUBLE SKIP RETURN
;
;SUBROUTINE TO CONVERT RIGHT HALF OF PTY NAME TO SIXBIT WHEN SIMULATING
;CTLJOB UUO.
CNVERT:	PUSH	P,N		;SET UP
	PUSH	P,J		;
	PUSH	P,D		;
	PUSH	P,C		;
	PUSH	P,B		;
	PUSH	P,A		;
	SETZM	B		;
	SETZM	C		;
	MOVEI	D,3		;NUMBER OF CHARACTERS TO EXAMINE
	HRRZS	A		;NOW CONTAINS DEVICE NUMBER TO CONVERT TO SIXBIT
	JUMPE	A,ZEROUT	;DEVICE 0
	MOVE	J,[POINT 3,A,26]	;SET UP BYTE POINTER
	MOVE	N,[POINT 6,C,17]	;
SXBT:	ILDB	B,J		;FETCH FIRST NUMBER
	CAIE	D,6		;	
	CAMN	B,C		;
	JUMPE	B,SXBT1		;LEADING ZERO?
	ADDI	B,20		;NO, CONVERT TO SIXBIT
	IDPB	B,N		;DEPOSIT SIXBIT CHARACTER
SXBT1:	SOJN	D,SXBT		;MORE CHARACTERS?
	SKIPA			;NO
ZEROUT:	MOVEI	C,200000	;DEVICE 0
	POP	P,A		;GET BACK PTY NAME
	HRR	A,C		;PUT SIXBIT DEVICE CODE IN RIGHT HALF
	POP	P,B		;CLEAN UP
	POP	P,C		;
	POP	P,D		;
	POP	P,J		;
	POP	P,N		;
	POPJ	P,		;
;END OF EDIT 230 SUBROUTINES TO SIMULATE CTLJOB UUO	

STATE:	MOVE	A,XSTATS	;ROUTINE TO FETCH STATES WORD
	PUSHJ	P,GETZ		;GO GET IT
	JUMPE	A,NOSTAT	;UNDEFINED, RETURN ZERO
	MOVEM	A,STATES	;SAVE IT
	MOVEI	B,^D60		;SET UP FOR 60HZ
	TLNE	A,(CLKCYC)	;SEE IF 50HZ
	MOVEI	B,^D50		;YES IT IS
	MOVEM	B,TCKSEC	;SAVE TICKS/SECOND
NOSTAT:	POPJ	P,		;RETURN
	SUBTTL	TABLES
IFLE HACKSW,<XLIST>
IFN HACKSW,<	RADIX 10
DEFINE BDAY (MO,DA,WHO)
<XWD <<MO-1>*^D31+DA-1>,EXP [ASCIZ /WHO/]>
DEFINE SDAY (MO,DA,SALUD)
<XWD SIGN!<<MO-1>*^D31+DA-1>,EXP [ASCIZ /SALUD/]>
BMSG:	ASCIZ	/Happy Birthday /
HAKTAB:
	SDAY (01,01,<Happy New Year>)
	SDAY (03,17,<Happy Evacuation Day>)
	SDAY (03,17,<P.S. It's also St. Patty's Day>)
	BDAY (03,21,<Johann Sebastian Bach>)
	SDAY (05,10,<Confederate Memorial Day>)
	SDAY (07,01,<Dominion Day>)
	SDAY (07,04,<Happy Independence Day>)
	SDAY (07,14,<Bastille Day>)
	SDAY (07,15,<Happy St Swithin's Day>)
	SDAY (10,12,<Real Columbus Day>)
	SDAY (10,24,<United Nations Day>)
	SDAY (11,05,<Guy Fawkes Day>)
	SDAY (12,25,<Merry Christmas>)
	SDAY (12,26,<Boxing Day>)
	SDAY (12,31,<Drive carefully tonight>)

HAKLEN==.-HAKTAB
	RADIX 8
>
	LIST

;CONSTANTS FOR GETTAB UUO

XTIME:	XWD	10,11
XPDBPT:	XWD	45,11		;POINTER TO JBTPDB
XDATE:	XWD	11,11
XSEGPT:	XWD	15,11
XUPTIM:	XWD	15,12
XDVLST:	XWD	14,11
XCORMX:	XWD	10,12
XSYSSZ:	XWD	12,11
XMEMSZ:	XWD	23,12
XSTATS:	XWD	17,11
XLSTIM:	XWD	22,12
XK4SWP:	XWD	1,15
XSPPN:	XWD	1,16
XTTY:	XWD	-1,10
XSHF:	XWD	16,12
XZCOR:	XWD	21,12
XSRSP:	XWD	42,12		;INDEX OF SYSRSP
XRNUM:	XWD	43,12		;INDEX OF NUMRSP
XMEMNS:	XWD	21,11
XOPR:	XWD	13,11
XSYSST:	XWD	6,16	;SYSTEM STR LIST
XSYSUN:	XWD	7,16
XSWPER:	XWD	5,13
XSWPUN:	XWD	10,16
XSYSTP:	XWD	7,11	;NAME OF SYSTEM TAPE ("SYS:")
XFSFPP:	XWD	2,16	;OPERATOR (FAILSAFE) NUMBER
XPTYCN:	XWD	22,11	;CONFIGURATION FOR PTYS
XAPRSN:	XWD	20,11	;APR SERIAL NUMBER
XSYKTM:	XWD	35,12	;SYSTEM KILL TIME
XGTTBI:	XWD	23,23	;GETTAB IMMEDIATE
XDSCTB:	XWD	35,11	;DSC TAB POINTER
XPCMA:	XWD	2,44	;PC AND MA ON CRASH (SWITCHES)
XPIIP:	XWD	1,44	;PI SYSTEM ON CRASH
XAPRCN:	XWD	0,44	;APR CONI ON A CRASH
XLGMAX:	XWD	50,11	;LOGMAX
XDDBLD:	XWD	75,11	;VALUE OF DDBLDB

MONTAB:	ASCII /-Jan-/
	ASCII /-Feb-/
	ASCII /-Mar-/
	ASCII /-Apr-/
	ASCII /-May-/
	ASCII /-Jun-/
	ASCII /-Jul-/
	ASCII /-Aug-/
	ASCII /-Sep-/
	ASCII /-Oct-/
	ASCII /-Nov-/
	ASCII /-Dec-/

;TABLE OF STOPCD CODES INDEXED BY VALUE

STOPT:	[ASCIZ /HALT/]
	[ASCIZ /STOP/]
	[ASCIZ /JOB/]
	[ASCIZ /DEBUG/]
	[ASCIZ/CPU/]
	[ASCIZ /INFO/]
	[ASCIZ /EVENT/]
TABPTR:	XWD	SIGN+0,.STS
	XWD	SIGN+1,.ADR
	XWD	SIGN+7,.SWP
	XWD	SIGN+2,.PPN
	XWD	162,.PDB	;
	XWD	     4,.TIM
	XWD	    14,.SGN
	XWD	SIGN+3,.PRG
	XWD	SIGN+24,.DEV
	XWD	5,.KCT		;TABLE 5,kilo core ticks
	XWD	37,.RTD
	XWD	.GTNM1,.USNM1
	XWD	.GTNM2,.USNM2
NTAB==.-TABPTR
	XWD	     0,.SEGCT


;MORE MONITOR INTERFACE

PJOBN:	POINT 7,C,6
NPJOBN:	Z		;NEW STYLE JOB POINTER
NEWSPY:	Z			;FOR LOAD 722 AND SUBSEQUENT 
.DVJOB:	D,,DV.JOB
.DVFIL:	D,,DV.FIL		;TO GET FILE NAMES
.DVEXT:	D,,DV.EXT		;TO GET FILE EXTENSIONS
.DVPPN:	D,,DV.PPN		;TO GET PPN
.DVUNI:	D,,DV.UNI		;TO GET UDB ADDRESS
TPCJOB:	POINT 8,B,10
IMGOUT:	POINT 8,@.SWP,26
DSKLEV:	POINT	3,STATES,9
HPQPNT:	POINT	4,A,9

;CRASH-FILE NAME DATA
; WANT TO BE ABLE TO ASK FOR "FILE" IF CAN'T FIND
; "CRASH.XPN", BUT FOR NOW CAN DEPOSIT OTHER FILE NAME HERE.
; (NOTE: ERRORS STILL SAY "CRASH.XPN")

CRASH:	SIXBIT /CRASH/
CRSEXT:	SIXBIT /XPN/
CRSPPN:	1,,4

RSPMSG:	[ASCIZ /    'til TTY output:	/]
RSPMS2:	[ASCIZ /    'til TTY input:	/]
RSPMS3:	[ASCIZ /    'til requeued:	/]
RSPMS4:	[ASCIZ /    'til 1st of above:	/]

IFN FTDEBUG,<
PAT:
PATCH:
FOO:	BLOCK	50		;PATCH AREA
>
IFE FTDEBUG,<
	XLIST		;ONLY LIST LITERALS IF IN DEBUG MODE
>
	LIT
	LIST

PDP:	IOWD	LN.PDL,PDL	;POINTER TO PUSH DOWN LIST
;TEMPORARIES

	IFN	PURESW,<
HIGH:	RELOC
LOW:	RELOC
	PHASE	LOW>

DSKIOW:	IOWD	LN.BUF,0	;IOWD FOR READING CRASH FILE, ADDR FILLED IN
	0			;END OF LIST

QTAB:	SIXBIT /RNWSTS/
	SIXBIT /STAUMQ/
	SIXBIT /DADTDC/
	SIXBIT /MTIOTT/
	SIXBIT /SLNL^C/
	SIXBIT /AABBCC/
	SIXBIT /DDEEFF/
	SIXBIT /GGHHII/
	SIXBIT /JJKKLL/
	SIXBIT /MMNNOO/
	SIXBIT /PPQQRR/
LQTAB==QTAB-.

.DVIOS:	XWD	J,0	;L
.TTY:	XWD	J,0	;L
.TTYN:	XWD	J,0	;L	TTY LINE NUMBERS
.STS:	XWD	J,0	;L+H
.ADR:	XWD	J,0	;L+H
.SWP:	XWD	J,0	;L+H
.PPN:	XWD	J,0	;L+H
.PDB:	XWD	J,0	;L	;
.TIM:	XWD	J,0	;L
.SGN:	XWD	J,0	;L
.PRG:	XWD	J,0	;L+H
.DEV:	XWD	J,0	;L+H
.KCT:	XWD	J,0	;L
.RTD:	XWD	J,0	;L
.SEGCT:	XWD	A,0	;H
.USNM1:	XWD	J,0	;L
.USNM2:	XWD	J,0	;L
TCKSEC:	0			;JIFFIES PER SECOND, A GETTAB VALUE
SYSPPN:	XWD	1,1		;PPN OF SYS:
MEMNSP:	NSPMEM			;CORE SPEED
LASSPY:	EXP	0		;LAST PAGE GOTTEN IN SPYPAG
GETBLK:	EXP	1		;PAGE. BLOCK TO PAGE IN PAGE
	XWD	0,FSP
DELBLK:	EXP	1		;PAGE. BLOCK TO PAGE OUT PAGE
	PA.GAF!FSP

ORGPTR:	POINT 7,CMDBUF		;ORIGIONAL COMMAND BUFFER POINTER

	IFN	PURESW,<
ZZZ==.-LOW
	RELOC
LOW:	BLOCK	ZZZ>

CBSIZE==^D14		;SIZE <WORDS> OF COMMAND BUFFER
GOTCMD:	BLOCK	1	;COMMAND GOTTEN FLAG (MOVED)
CMDBUF:	BLOCK	CBSIZE+1	;COMMAND BUFFER
CMDPTR:	BLOCK	1	;CURRENT COMMAND POINTER (MOVED)
CDENDP==CMDBUF+CBSIZE+1	;END OF COMMAND BUFFER AREA
			;REDEFINED BECUZ OF MOVED STUFF

LOWEND:				;START OF ZEROED AREA

PDL:	BLOCK	LN.PDL+1	;PUSH-DOWN LIST

COMTOA:	BLOCK	1		;ADDRESS OF SPECIAL TYPEOUT ROUTINE
NCPCNF:	BLOCK	1		;NUMBER OF CPUS IN THE CONFIGURATION
CPNUPT:	BLOCK	NCPUS
CPNNUL:	BLOCK	NCPUS
CPNLST:	BLOCK	NCPUS
CPNOHT:	BLOCK	NCPUS
TEMP:	BLOCK	NCPUS		;[323] ONE TEMP AREA FOR EACH CPU
TEMP1:	BLOCK	1

TYOB:	BLOCK	3	;LISTING DEVICE OUTPUT BUFFER POINTERS

FLP:	BLOCK 6		;FILOP. ARGUMENT BLOCK
LKB:	BLOCK 10	;EXTENDED LOOKUP BLOCK

SEGPTR:	BLOCK	1	;LH=-# SEGS, RH=# JOBS
JOBN:	BLOCK	1	;NUMBER OF JOBS IN SYSTEM
SEGN:	BLOCK	1	;NUMBER OF SEGMENTS IN SYSTEM
BOTH:	BLOCK	1	;JOBN + SEGN

MAXMAX:	BLOCK	1	;MAX SIZE OF USER CORE
CORUSE:	BLOCK	1	;VIRTUAL CORE USED
DSKUSE:	BLOCK	1	;SWAPPING SPACE USED
ACTUSE:	BLOCK	1	;ACTIVE VIRTUAL CORE USED
LOWUSE:	BLOCK	1	;TOTAL VIRTUAL CORE IN LOW SEGMENTS

FREE:	BLOCK	1	;TEMPORARY .JBFF
ZERLOW:	BLOCK	1	;FIRST ADDRESS OF DYNAMIC TABLES
ZERHGH:	BLOCK	1	;LAST ADDRESS OF DYNAMIC TABLES

JOBTTY:	BLOCK	1	;NAME OF CURRENT JOB'S TTY
DATE:	BLOCK	1	;TODAY'S DATE
FTDUAL: BLOCK	1	;NON-ZERO IF DUAL PORTED DISK SUPPORT
STATES:	BLOCK	1	;SYSTEM STATES WORD
FSDCNT:	BLOCK	1	;JOB OR LOOP NUMBER/COUNT IN SYS B CODE
.UPLST:	BLOCK	1	;ADDRESS OF PTR TO OUR DSK DDB'S
;CATCH 22, .UPFSO AND .UPFSE MUST BE INITIALIZED TO SOMETHING FOR DSKA
; TO WORK, BE CAN'T GET REAL VALUES UNTIL DSKA DOES WORK
.UPFSO:	340000		;ORGIN OF FUNNY SPACE
.UPFSE:	400000		;END OF FUNNY SPACE
SECTAB:	BLOCK	40	;STORAGE FOR SECTION MAP
.CPTOS:	BLOCK	1	;PAGE NUMBER OF CPU0 EPT TO MAKE CALCULATIONS
			;IN DSKA WORK FOR EPT MAPPING AS WELL AS UPMP
.CPMAP:	BLOCK	1	;ADDRESS OF THE EXEC MAP (=.CPTOS IF KI PAGING)
ME:	BLOCK	1	;MY PPN
OPR:	BLOCK	1	;NAME OF "OPR" DEVICE
MYJOB:	BLOCK	1	;MY JOB NUMBER
CORSAV:	BLOCK	1	;VIRTUAL CORE SAVED BY SHARING
ONCE:	BLOCK	1	;-1 FIRST TIME THROUGH
TNFRTY:	BLOCK	1	;1 IF 10/40N (NO LOGIN)
SYSTAP:	BLOCK	1	;NAME OF SYSTEM TAPE ("SYS:"), 0=DSK:
FSFPPN:	BLOCK	1	;OPERATOR NUMBER
CTYLIN:	BLOCK	1	;LINE NUMBER OF CTY
PTYOFS:	BLOCK	1	;NUMBER OF FIRST TTY DRIVEN BY PTY
PTYMAX:	BLOCK	1	;NUMBER OF LAST+1 TTY DRIVEN BY PTY
		.UPSAF==1B4	;BIT FLAGGING S/A
		.UPNNA==1B10	;BIT FLAGGING NNA
CURFS:	BLOCK	1	;CURRENT FILESTRUCTURE
UNIBLK:	BLOCK	1
SYSUNI:	BLOCK	1
SWPUNI:	BLOCK	1
DSKBLK:	BLOCK	1		;DSKCHR UUO BLOCK
DSKDDB:	BLOCK	1	;COUNT OF DISK DDB'S
LOGNAM:	BLOCK	1	;LOGICAL NAME OF THIS DEVICE
NOW:	BLOCK	1	;CURRENT TIME
SPYFLG:	BLOCK	1	;-1 IF SPYING
MAXGTB:	BLOCK	1	;LARGEST GETTAB TABLE #
OFSGTB:	BLOCK	1	;START OF GETTAB TABLE POINTERS
PTYS:	BLOCK	1	;COUNT OF PTY DRIVEN JOBS
ONEJOB:	BLOCK	1	;NUMBER OF JOB IF SINGLE
ONEPPN:	BLOCK	1	;NUMBER OF PPN IF SINGLE
ONETTY:	BLOCK	1	;NUMBER OF TTY IF SINGLE
SAVCHR:	BLOCK	1	;CHARACTER TO RESCAN IF ANY
SEGFLG:	BLOCK	1	;-1 IF SEGMENT PRINTING
DSKFLG:	BLOCK	1	;FLAG (AND MAX SIZE) OF DISK INPUT FILE
DCACHE:	BLOCK	NBCSHE	;INCORE CACHE FOR CRASH FILE
EXEDIR:	BLOCK	LN.BUF	;SPACE FOR EXE DIRECTORY
LASBP1:	BLOCK	1	;VALUE OF LAST DSKBP1 CALL
LASBPA:	BLOCK	1	;ARGUMENT OF LAST DSKBP1 CALL
MONVER:	BLOCK	1	;MONITOR VERSION GETTAB (0 BEFORE 503)
OLDNUL:	BLOCK	NCPUS	;PREVIOUS NULL TIME IN JIFFIES
OLDLOS:	BLOCK	NCPUS	;PREVIOUS LOST TIME IN JIFFIES
OLDOHT:	BLOCK	NCPUS	;PREVIOUS OVERHEAD TIME IN JIFFIES
OLDZRO:	BLOCK	1
OLDSFL:	BLOCK	1
OLDNUM:	BLOCK	1	;PREVIOUS NUMBER OF SYSTEM RESPONSES(OLD RSP CODE)
TOTKCT:	BLOCK	1	;TOTAL KC TICKS THIS PASS
LOGDIN:	BLOCK	1	;JOBS LOGGED IN
DIFTIM:	BLOCK	NCPUS	;DIFFERENTIAL UPTIME FOR THIS PASS
LINECT:COLCNT:	BLOCK	1	;COLUMN COUNT FOR FORMATTING OUTPUT
	BLOCK	1	;LINES PER PAGE FOR DISPLAY USERS
SYSUPT:	BLOCK	JOBMAX	;CPU0 UPTIME AT EACH RUN-TIME CALCULATION
JOBTIM:	BLOCK	JOBMAX	;RUN TIM FOR EACH JOB NUMBER
OLDPPN:	BLOCK	JOBMAX	;OLD PPN FOR EACH JOB NUMBER
JOBKCT:	BLOCK	JOBMAX	;KILO CORE TICKS FOR EACH JOB
SLQ:	BLOCK	1	;WAIT STATE CODE FOR SL
TIQ:	BLOCK	1	;WAIT STATE CODE FOR TI
EWQ:	BLOCK	1	;WAIT STATE CODE FOR EW
LOKCHK:	BLOCK	1	;CHECKED FOR LOCKED SEGMENT FLAG
NUMJOB:	BLOCK	1	;NUMBER OF ACTIVE JOBS
REMSNO:	BLOCK	1	;CURRENT REMOTE STATION NUMBER
PDBPTR:	BLOCK	1	;ADDRESS OF JBTPDB FOR PEEKING
JOBINT:	BLOCK	4	;INTERRUPT BLOCK FOR INTERRUPTING ^C
CPU:	BLOCK	1	;TEMP FOR GETRSP
DOALT:	BLOCK	1	;FLAG FOR ALTERNATE PATH TYPE
MAIND:	BLOCK	1	;SAVE LOCATION FOR UDB OF MAIN
CPKI10:	BLOCK	1	;IF KI10 AND MONITOR.GT.50510 THEN -1 ELSE 0
INDEV:	BLOCK	1
INFILE:	BLOCK	1
INEXT:	BLOCK	1
INPPN:	BLOCK	1
INPTH:	BLOCK	.PTMAX
RSPCNT:	BLOCK	1	;COUNTER FOR GENRSP CODE
RSPIDX:	BLOCK	1	;INDEX INTO OLDRSP & DIFRSP
RSPIX1:	BLOCK	1	;TEMP FOR GETRSP
OLDRSP:	BLOCK	NCPUS*4*4	;4 DIFFERENT TYPES OF RESPONSE*4
DIFRSP:	BLOCK	NCPUS*4*4	;ENTRIES PER TYPE* # OF CPU'S

LINTAB:	BLOCK	1		;Address of LDB table in the monitor
LDB:	BLOCK	1		;Pointer to a given LDB
LDBDCH:	BLOCK	1		;Device-characteristics pointer in LDB
LDBREM:	BLOCK	1		;Beginning of remote TTY block in LDB
NDBSNM:	BLOCK	1		;An NDB word defined in the monitor
DEVJOB:	BLOCK	1		;Word in DDB containing job number
CNTLOC:	BLOCK	1		;Node number of central site
TTNUM:	BLOCK	1		;Number of a TTY

TEMEND==.-1		;END OF ZEROED AREA

	END	SYSTAT
                        @