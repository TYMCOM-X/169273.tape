TITLE   UUO     SEP 17, 1974
;*LAST LINE EDITING WOULD BE NICE
;*REDO RDLINE ROUTINE TO USE TABLE
;
;
; THIS PACKAGE CONTAINS A UUO DISPATCHER AND SOME TELETYPE
; UUOS.
;
; IT IS ASSUMED THAT REGISTER P IS SET UP FOR A PUSH STACK.
; IT IS USED EXTENSIVELY BY THIS CODE BUT IS NOT SET UP.
;
; IT IS ASSUMED THAT LOCATION 41 OCTAL CONTAINS THE INSTRUCTION
; 'PUSHJ P,UUO'.
;
; TO ADD NEW UUOS, PUT THE UUO NAME AND ROUTINE ADDRESS INTO
; THE TABLE 'UUOTAB'. THE FORMAT OF AN ENTRY IS:
; NAME,ROUTINE. THE LOCATIION OF THE UUO IN THE TABLE
; DEFINES IT'S OPCODE FIELD. IN OTHER WORDS, THE FIRST ENTRY
; IN THE TABLE HAS OPCODE 1, THE SECOND ENTRY HAS OPCODE 2.
; IN GENERAL, THE NTH ENTRY IN THE TABLE HAS OPCODE N.
; UNUSED ENTRIES SHOULD BE ZERO.
;
; WHEN THE UUO DISPATCHER BRANCHES TO THE UUO ROUTINE,
; THE RETURN ADDRESS AND THE ORIGINAL CONTENTS OF REGISTER ZERO
; WILL HAVE BEEN PUSHED ONTO THE STACK. CELL ZERO IS ON THE
; TOP OF THE STACK. THE RETURN ADDRESS IS NEXT. CELL ZERO
; WILL HAVE BEEN CLOBBERED.
        EXTERNAL CDISP,ESCR

SAVBEG=1
SAVEND=16
FORTY=40

LBRACK==133
RBRACK==135
YCHR=   131
LFCHR=12
BELCHR=7
BSLASH=134
UARROW=136
RUBOUT=377
RUB177=177
LOWERA=141
LOWERZ=172
CTRLQ=21
COLON==72
DASH==55
COMMA=54
DOLLAR=44

FORTY1= 41
        LOC     FORTY1
        PUSHJ   P,UUO                   ;SET UP BRANCH TO UUOS IN LOC 41
        LOC     137
        XWD     VERSION,VERPAT
        RELOC

SAVR1:  BLOCK   SAVEND-SAVBEG
SAVR1E: BLOCK   1
SAVR2:  BLOCK   SAVEND-SAVBEG
SAVR2E: BLOCK   1
SPTR:   BLOCK   3
LBUFF:  BLOCK   64
SAVE1:  0
SAVE2:  0
SAVE3:  0
CTEST2: 0
CTEST:  0
TTYSTA: 0
TTYFLG: 0
CHRCNT::        0               ;CHAR COUNT FOR TCO UUO
CNT:    0
ESCFLG: 0
SAVESC: 0
CLIN:   POPJ    P,              ;*CHANGE THIS*
CLOUT:  POPJ    P,              ;*CHANGE THIS*
FERR::  0
CIN::   0
COUT::  0
SCHAR:  0
UUO:    EXCH    R0,STKCNT#      ;EXCHANGE R0 AND STACK CONTENTS OF UUO
        HRRZS   (P)             ;SET ALL FLAGS TO ZERO
        EXCH    P,STKPTR        ;EXCHANGE OLD AND NEW STACK POINTERS
        CAMGE   P,STKPTR#       ;SKIP IF LOWER OR SAME LEVEL UUO CALL
        CAME    R0,(P)          ;SKIP IF NOT A NEW UUO CALL
        MOVE    P,STKPTR        ;SAVE NEW STACK POINTER
        CAMN    P,STKPTR        ;SKIP IF NOT A NEW UUO CALL
        MOVE    R0,(P)          ;SAVE CURRENT CONTENTS OF RETURN CELL
        EXCH    P,STKPTR        ;RE-EXCHANGE P AND STACK POINTER
        EXCH    R0,STKCNT       ;RE-EXCHANGE R0 AND STACK CONTENTS
        PUSH    P,R0
        LDB     R0,[POINT 9,FORTY,8]
        CAILE   R0,X            ;SKIP IF UUO NOT TOO BIG
        JRST    UUOERR          ;GO TO ERROR ROUTINE
        ADDI    R0,UUOTAB-1
        JRST    @R0
UUOERR: SETZM   .               ;EXECUTE THIS ROUTINE ONLY ONCE
        ERROR   [ASCIZ "ATTEMPT TO EXECUTE AN ILLEGAL UUO"]
;THE SSKE UUO SKIPS IF TWO STRINGS ARE EQUAL

SSKUUO: BLOCK   0
        LDB     R0,[POINT 4,FORTY,12] ;GET AC FIELD OF UUO
        SKIPN   R0              ;SKIP IF IT'S NOT ZERO
        HRR     R0,P            ;POINT TO STACK FOR R0
        HRRZ    R0,@R0          ;GET ADDRESS OF STRING PTR
        ADD     R0,[7B11-1]     ;DEC AND MAKE BYTE POINTER FOR 7 BIT
        MOVEM   R0,SKPT2        ;SAVE POINTER TO STRING
        HRR     R0,FORTY        ;GET ADDRESS OF FIRST STRING PTR
        SUBI    R0,1            ;DECREMENT TO POINT TO PRECEDING WORD
        MOVEM   R0,SKPT1        ;SAVE POINTER TO STRING
SSKELP: ILDB    R0,SKPT2        ;GET NEXT CHAR FROM SECOND STRING
        CAIN    R0,EOLIT        ;SKIP IF IT'S NOT THE END OF STRING
        JRST    UUOSKR          ;EVERYTHING MATCHES SO SKIP RETURN
        MOVEM   R0,SSKET        ;SAVE THE CHARACTER
        ILDB    R0,SKPT1        ;GET NEXT CHAR FROM FIRST STRING
        CAME    R0,SSKET        ;SKIP IF THE CHARACTERS ARE THE SAME
        JRST    UUORET          ;NOT EQUAL SO RETURN WITHOUT SKIPPING
        JRST    SSKELP          ;LOOP

SSKET:  0                       ;TEMP CELL

SKPT1:  0                       ;ADDRESS OF FIRST STRING

SKPT2:  0                       ;ADDRESS OF SECOND STRING
; THE TCI UUO READS ONE CHARACTER FROM THE TERMINAL. THE CHARACTER
; IS RETURNED IN THE CORE ADDRESS SPECIFIED AND IN THE AC
; SPECIFIED (UNLESS THE AC IS ZERO). CARRIAGE RETURN/LINEFEED
; PAIRS ARE REDUCED TO A SINGLE CARRIAGE RETURN.
; LINEFEEDS ARE ECHOED AS LINEFEED, CARRIAGE RETURN, RUBOUT.
; EDITTING AND BREAK CHARACTERS ARE DEFINED BY THE SETTTY UUO.
TCIUUO: PUSH    P,FORTY
        SKIPL   CTEST
        JRST    TCI3
        AOS     CTEST
TCI1:   MOVE    R0,SCHAR
TCI4:   POP     P,FORTY
        MOVEM   R0,SCHAR
        PUSHJ   P,CHATYP        ;GET THE CHARACTER TYPE
        CAIN    R0,TE           ;SKIP IF NOT A LINE TERMINATOR
        SETZM   CHRCNT          ;ZERO CHAR COUNT FOR NEW LINE
        PUSH    P,R0            ;SAVE THE TYPE ON THE STACK
        LDB     R0,[POINT 4,FORTY,12]
        POP     P,@R0           ;STORE TYPE IN APPROPRIATE REGISTER
        MOVE    R0,SCHAR
        EXCH    R0,0(P)
        POP     P,@FORTY
        POPJ    P,
TCI2:   MOVE    R0,[POINT 7,LBUFF-1,34]
        MOVEM   R0,SPTR
        MOVEM   R0,SPTR+1
        MOVEI   R0,^D260
        MOVEM   R0,SPTR+2
        RDLINE  SPTR
        JRST    .+1
TCI3:   GCI     R0,SPTR
        JRST    TCI2
        JRST    TCI4
; THE TCL UUO IS IDENTICAL TO THE TCI UUO EXCEPT THAT THE
; CHARACTER IS NOT REMOVED FROM THE INPUT STRING.
TCLUUO: PUSH    P,FORTY
        SKIPGE  CTEST
        JRST    TCI1
        SOS     CTEST
        JRST    TCI3

CHATYP: PUSH    P,R1            ;SAVE R1 ON THE STACK
        PUSH    P,R2            ;SAVE R2 ON THE STACK
        MOVE    R1,R0           ;GET THE CHAR FROM R0
        IDIVI   R1,11           ;DIVIDE CHAR BY 9 TO LOOK UP TYPE
        LDB     R0,FS3(R2)      ;GET THE CHAR TYPE
        POP     P,R2            ;RESTORE R2 FROM STACK
        POP     P,R1            ;RESTORE R1 FROM STACK
        POPJ    P,              ;RETURN FROM SUBROUTINE

;INPUT CHARACTER DISPATCH MATRIX

FS3:    POINT   4,FS4(R1),3      ;BYTE POINTERS TO CLASSIFICATION TABLE
        POINT   4,FS4(R1),7
        POINT   4,FS4(R1),11
        POINT   4,FS4(R1),15
        POINT   4,FS4(R1),19
        POINT   4,FS4(R1),23
        POINT   4,FS4(R1),27
        POINT   4,FS4(R1),31
        POINT   4,FS4(R1),35

;       CLASSIFICATION TABLE FOR INPUT CHARACTERS
;       SECOND ALPHABET REPRESENTS LOWER CASE CHARACTER CODES

FS4:    BLOCK   0
BYTE (4)IG,IC,IC,IC,IC,IC,IC,IC,IC ;NUL SOH STX ETX EOT ENQ ACK BEL BS 
BYTE (4)IG,TE,IG,IG,TE,IC,IC,IC,IC ;HT  LF  VT  FF  CR  SO  SI  DLE DC1
BYTE (4)IC,IC,IC,IC,IC,IC,IC,IC,IC ;DC2 DC3 DC4 NAK SYN ETB CAN EM  SUB
BYTE (4)IC,IC,IC,IC,IC,SP,IC,IC,PO ;ESC FS  GS  RS  US  SP  !   "   #
BYTE (4)PU,IC,IC,PU,LP,RP,AS,IC,CO ;$   %   &   '   (   )   *   +   ,
BYTE (4)DA,EX,PU,NU,NU,NU,NU,NU,NU ;-   .   /   0   1   2   3   4   5
BYTE (4)NU,NU,NU,NU,IC,IC,IC,IC,IC ;6   7   8   9   :   ;   <   =   >
BYTE (4)QU,AT,AL,AL,AL,AL,AL,AL,AL ;?   @   A   B   C   D   E   F   G
BYTE (4)AL,AL,AL,AL,AL,AL,AL,AL,AL ;H   I   J   K   L   M   N   O   P
BYTE (4)AL,AL,AL,AL,AL,AL,AL,AL,AL ;Q   R   S   T   U   V   W   X   Y
BYTE (4)AL,LP,IC,RP,IC,IC,IC,IC,IC ;Z   [   \   ]   ^   _   '   A   B 
BYTE (4)IC,IC,IC,IC,IC,IC,IC,IC,IC ;C   D   E   F   G   H   I   J   K
BYTE (4)IC,IC,IC,IC,IC,IC,IC,IC,IC ;L   M   N   O   P   Q   R   S   T
BYTE (4)IC,IC,IC,IC,IC,IC,IC,IC,IC ;U   V   W   X   Y   Z   173 174 175
BYTE (4)IC,IG                      ;176 DEL

TABUUO: HRRZ    R0,FORTY
        SUB     R0,CHRCNT
TABLP:  SOJL    R0,UUORET
        TCO     [SPACE]
        JRST    TABLP

; THE GCI UUO READS ONE CHARACTER FROM THE FRONT OF A STRING
; AND INCREMENTS THE FIRST CHARACTER POINTER.
; IT SKIPS IF THE STRING IS NOT EMPTY.
; THE CHARACTER IS RETURNED IN THE SPECIFIED AC.
; THE ADDRESS PORTION OF THE INSTRUCTION POINTS TO A 3 WORD
; STRING POINTER. THE FORMAT OF THE STRING POINTER IS:
;
; PTR:   BYTE POINTER. POINTS TO THE CHARACTER POSITION PRECEEDING
;        THE FIRST CHARACTER IN THE STRING.
; PTR+1: BYTE POINTER. POINTS TO THE LAST CHARACTER IN THE STRING.
; PTR+2: LPTR,,RPTR
;
; LPTR IS THE NUMBER OF CHARACTER POSITIONS TO THE LEFT
; OF THE 1ST CHARACTER IN THE STRING. RPTR IS THE NUMBER
; OF CHARACTER POSITIONS TO THE RIGHT OF THE LAST
; CHARACTER IN THE STRING.
GCIUUO: PUSH    P,R1
        MOVE    R1,FORTY
        MOVE    R0,0(R1)
        CAMN    R0,1(R1)
        JRST    UUORE1
        HRLZI   R0,1
        ADDM    R0,2(R1)
        ILDB    R0,0(R1)
GCI2:   LDB     R1,[POINT 4,R1,12]
        MOVEM   R1,FORTY
        POP     P,R1
        EXCH    R0,0(P)
        POP     P,@FORTY
        JRST    UUOSK1
; THE GCD UUO READS ONE CHARACTER FROM THE END OF A STRING AND
; DECREMENTS THE LAST CHARACTER POINTER. THE CHARACTER IS
; RETURNED IN THE SPECIFIED AC. SEE 'GCI' UUO FOR A
; DESCRIPTION OF STRING POINTER WHICH IS ADDRESSED BY GCL UUO.
; GCL SKIPS IF THE STRING WAS NOT EMPTY.
GCDUUO: PUSH    P,R1
        MOVE    R1,FORTY
        MOVE    R0,0(R1)
        CAMN    R0,1(R1)
        JRST    UUORE1
        AOS     2(R1)
        LDB     R0,1(R1)
        DCR     1(R1)
        JRST    GCI2
; THE WCI UUO WRITES ONE CHARACTER TO THE END OF A STRING.
; IT SKIPS IF THE STRING DOES NOT OVERFLOW.
; THE LAST CHARACTER POINTER IS INCREMENTED.
; THE CHARACTER IS TAKEN FROM THE SPECIFIED AC. THE ADDRESS FIELD
; IS USED TO ADDRESS A SET OF STRING POINTERS.
WCIUUO: PUSH    P,R1
        MOVE    R1,FORTY
        MOVE    R0,2(R1)
        TRNN    R0,-1
        JRST    UUORE1
        SOS     2(R1)
        AOS     FORTY
        POP     P,R1
        LDB     R0,[POINT 4,FORTY,12]
        MOVEM   R0,1(P)
        MOVE    R0,0(P)
        MOVE    R0,@R1(P)
        IDPB    R0,@FORTY
UUOSKR: POP     P,R0
UUOSK1: AOS     0(P)
        POPJ    P,
; THE WCD UUO WRITES ONE CHARACTER TO THE FRONT OF A STRING.
; THE FIRST CHARACTER POINTER IS DECREMENTED. THE CHARACTER
; IS TAKEN FROM THE SPECIFIED AC. THE ADDRESS FIELD
; IS USED TO ADDRESS A SET OF STRING POINTERS.
; THE WCD UUO SKIPS IF THE STRING DOES NOT UNDERFLOW.
WCDUUO: PUSH    P,R1
        MOVE    R1,FORTY
        TLNN    R0,-1
        JRST    UUOSKR
        HRLZI   R0,1
        SUBM    2(R1)
        POP     P,R1
        LDB     R0,[POINT 4,FORTY,12]
        MOVEM   R0,1(P)
        MOVE    R0,0(P)
        MOVE    R0,@1(P)
        DPB     R0,@FORTY
        DCR     @FORTY
        JRST    UUOSKR
; THE RDLINE UUO READS ONE LINE FROM THE TELETYPE INTO A STRING
; DEFINED BY STRING POINTERS ADDRESSED BY THE UUO.
; EDITTING AND BREAK CHARACTERS ARE DEFINED BY THE SETTTY UUO.
; IF THE STRING OVERFLOWS, IT IS TREATED AS A BREAK CHARACTER.
RDUUO:  PUSH    P,R1
        PUSH    P,R2
        HRRZ    R2,FORTY
        MOVE    R0,0(R2)
        MOVEM   R0,SAVE1
        MOVE    R0,1(R2)
        MOVEM   R0,SAVE2
        MOVE    R0,2(R2)
        MOVEM   R0,SAVE3
        SETZM   CNT
        SKIPL   TTYFLG  ;HAS TTY STATUS BEEN SET?
        SETTTY  [0]     ;INITIALIZE TTY STATUS TO DEFAULT
RDL1:   PUSHJ   P,GETCHR
        CAIN    R0,CRCHR
        JRST    CR
        CAIN    R0,LFCHR
        JRST    LF
        MOVE    R1,TTYSTA
        TRNN    R1,2000
        JRST    RDX1
        CAIN    R0,3
        JRST    RDX2
        JRST    RDX
RDX1:   HRLZI   R1,-3
        CAMN    R0,ESCTAB(R1)
        JRST    .+3
        AOBJN   R1,.-2
        JRST    RDX
RDX2:   SKIPL   ESCFLG
        JRST    ESCR
        SETOM   SAVESC
RDX:    SKIPGE  CIN
        JRST    RDC
        MOVE    R1,TTYSTA
        TLNN    R1,40000
        TLNN    R1,600000
        JRST    RDC
        MOVE    R1,TTYSTA
        TRNN    R1,2000
        JRST    RDX3
        CAIN    R0,25
        JRST    CQ
        CAIN    R0,RUB177
        JRST    CA
        JRST    RDC
RDX3:   HRLZI   R1,-4
        CAMN    R0,CTAB1(R1)
        JRST    @CTAB2(R1)
        AOBJN   R1,.-2
RDC:    CAIG    R0,LOWERZ
        CAIGE   R0,LOWERA
        JRST    NCV
        MOVE    R1,TTYSTA
        TRNE    R1,400
        SUBI    R0,40
NCV:    WCI     R0,@R2
        PUSHJ   P,FERR
        HRRZ    R1,2(R2)
        JUMPE   R1,RDONE+1
        AOS     CNT
        MOVE    R1,TTYSTA
        TLNN    R1,440000
        JRST    RDC2
        CAIE    R0,CRCHR
        CAIN    R0,LFCHR
        JRST    RDONE
        JRST    RDL1
RDC2:   HRLZI   R1,-8
        CAML    R0,BITTAB(R1)
        JRST    .+2
        AOBJN   R1,.-2
        HLRE    R1,R1
        ADDI    R1,10
        CAIE    R1,7
        JRST    RDC3
        MOVE    R1,TTYSTA
        TLNN    R1,200000
        JRST    RDC3-1
        HRLZI   R1,-4
        CAMN    R0,CTAB1(R1)
        JRST    RDL1
        AOBJN   R1,.-2
        MOVEI   R1,7
RDC3:   MOVEI   R0,1
        LSH     0(R1)
        TDNN    R0,TTYSTA
        JRST    RDL1
RDONE:  AOS     -3(P)
        JRST    UUORE2
CQ:     OUTCHR  [UARROW]
        OUTCHR  [CRCHR]
        OUTCHR  [LFCHR]
        SKIPL   TTYSTA
        JRST    RDC
        MOVE    R0,SAVE1
        MOVEM   R0,0(R2)
        MOVE    R0,SAVE2
        MOVEM   R0,1(R2)
        MOVE    R0,SAVE3
        MOVEM   R0,2(R2)
        JRST    RDL1
CA:     SKIPL   TTYSTA
        JRST    CA2
        GCD     R0,@R2
        JRST    BELL
        OUTCHR  [BARROW]
        JRST    RDL1
CA2:    OUTCHR  [BARROW]
        JRST    RDC
CW:     SKIPL   TTYSTA
        JRST    CW2
        GCD     R0,@R2
        JRST    BELL
        OUTCHR  [BSLASH]
        JRST    .+3
        GCD     R0,@R2
        JRST    RDL1
        CAIN    R0,SPACE
        JRST    .-3
        GCD     R0,@R2
        JRST    RDL1
        CAIE    R0,SPACE
        CAIN    R0,COMMA
        JRST    RDC
        JRST    .-5
CW2:    OUTCHR  [BSLASH]
        JRST    RDC
CI:     MOVE    R0,CNT
        HRLZI   R1,-12
        CAMGE   R0,TAB(R1)
        JRST    CI2
        AOBJN   R1,.-2
        ADDI    R1,10
        CAML    R0,R1
        JRST    .-2
        JRST    .+2
CI2:    MOVE    R1,TAB(R1)
        SUB     R1,CNT
        MOVEI   R0,40
        HLL     R0,TTYSTA
        TLZ     R0,10000
        TLNE    R0,400000
        JRST    .+2
        TLNE    R0,100000
        TLO     R0,10000
        TLNN    R0,10000
        JRST    .+3
        WCI     R0,@R2
        JRST    RDONE
        AOS     CNT
        SUBI    R1,1
        JUMPG   R1,.-6
        TLNE    R0,10000
        JRST    RDL1
        MOVEI   R0,CTRLQ
        JRST    RDC
TAB:    EXP     10,20,30,40,50,60,70,100,110,120
BELL:   OUTCHR  [BELCHR]
        JRST    RDL1
LF:     MOVEI   R0,CRCHR
        PUSHJ   P,GIVCHR
        MOVEI   R0,LFCHR
        MOVE    R1,TTYSTA
        TRNE    R1,1000
        MOVEI   R0,CRCHR
        SKIPL   COUT
        OUTCHR  [RUBOUT]
        JRST    RDC
CR:     PUSHJ   P,GETCHR
        MOVEI   R0,CRCHR
        JRST    RDC
ESCTAB: EXP     175,33,37              ;*DO SOMETHING ABOUT THIS*
BITTAB: EXP     173,141,133,101,72,60,40,0
CTAB1:  EXP     R1,27,21,11
CTAB2:  EXP     CA,CW,CQ,CI
GETCHR: SKIPL   CIN
        JRST    RDTTY
        ERROR   [ASCIZ "COMMAND INPUT FILE NOT YET IMPLEMENTED"]
EOF:    DISABL
        PUSHJ   P,CLIN
        ENABLE
        MOVE    R0,[XWD SAVR1,SAVBEG]
        BLT     R0,SAVEND
RDTTY:  MOVE    R0,TTYSTA
        TLNN    R0,40000
        JRST    RDTTY2
        INCHWL  R0

        JRST    TTYDON
RDTTY2: INCHRW  R0

TTYDON: SKIPL   CIN
        SKIPGE  COUT
        JRST    GIVCHR          ;SAME AS PUSHJ P,GIVCHR ; POPJ P,
        POPJ    P,
; THE TCO UUO OUTPUTS ONE CHARACTER TO THE TERMINAL. CARRIAGE
; RETURN AND LINEFEED ARE TREATED SPECIALLY.
; FOR CARRIAGE RETURN, A CARRIAGE RETURN AND LINEFEED ARE SENT.
; FOR LINEFEED, A LINEFEED, CARRIAGE RETURN, AND RUBOUT ARE SENT.
; IF COUT IS NEGATIVE, THE RUBOUT IS NOT SENT. *CHANGE THIS*
GIVCHR: SKIPL   COUT
        JRST    WRTTY
        PUSH    P,R0
        MOVE    R0,[XWD SAVBEG,SAVR2]
        BLT     R0,SAVR2E
        PUSHJ   P,BYO
        ERROR   [ASCIZ "WRITE ERROR"]
        MOVE    R0,[XWD SAVR2,SAVBEG]
        BLT     R0,SAVEND       ;*THIS MAY NOT BE NECESSARY
        JRST    UUORET          ;RETURN FROM GIVCHR
WRTTY:  OUTCHR  R0
        POPJ    P,

;NEW TCO UUO 5/28/72
TCOUU:  MOVE    R0,(P)          ;RESTORE R0 IN CASE IT CONTAINED CHAR
        PUSH    P,R1            ;STACK R1
        MOVE    R0,@FORTY       ;LOAD CHAR INTO R0
        ANDI    R0,177          ;USE ONLY SEVEN BITS
        MOVEI   R1,0            ;ASSUME WE START IN STATE 0
        AOS     CHRCNT          ;INCREMENT CHARACTER COUNT
        CAIN    R0,CRCHR        ;SKIP IF CHAR IS NOT CARRIAGE RETURN
        MOVEI   R1,1            ;START IN STATE 1 FOR CARRIAGE RETURN
        CAIE    R0,LFCHR        ;SKIP IF CHAR IS NOT A LINE FEED
        JRST    TCOUU1          ;NOT A LINE FEED
        SOSN    TCOSTA          ;SKIP IF LAST CHAR WAS NOT A CR
        JRST    UUORE1          ;IGNORE A LINE FEED AFTER A CR
        MOVEI   R1,2            ;START IN STATE 2 FOR LINE FEED
TCOUU1: CAIE    R1,0            ;SKIP IF NOT END OF LINE
        SETZM   CHRCNT          ;ZERO THE CHARACTER COUNT
        MOVEM   R1,TCOSTA#      ;SAVE STATE OF LAST CHAR OUTPUT
        SKIPA                   ;SKIP TO START OF THE ROUTINE
TCOLP:  LDB     R1,[POINT 2,TCOTAB(R1),21] ;LOAD NEW STATE
        SKIPL   COUT            ;SKIP IF OUTPUT NOT TO TERMINAL
        OUTCHR  R0              ;OUTPUT CHAR TO TERMINAL
        SKIPGE  COUT            ;DON'T SKIP IF OUTPUT TO FILE
        PUSHJ   P,BYO           ;OUTPUT CHAR TO FILE
        LDB     R0,[POINT 7,TCOTAB(R1),17] ;LOAD NEXT CHAR
        SKIPL   TCOTAB(R1)      ;SKIP IF WE ARE ALL DONE
        JRST    TCOLP           ;LOOP FOR NEXT CHAR
        JRST    UUORE1

TCOTAB: XWD     -1,0            ;STATE 0 - RETURN FROM UUO
        XWD     LFCHR,0         ;STATE 1 - GO TO STATE 0 AND OUTPUT LF
        XWD     3000+CRCHR,0    ;STATE 2 - GO TO STATE 3 AND OUTPUT CR
        XWD     RUBOUT,0        ;STATE 3 - GO TO STATE 0 AND OUTPUT RUBOUT

COF==   2                       ;*THIS SHOULD E HERE
BYO:    SOSG    COFHD2#         ;DECREMENT CHAR COUNT - SKIP IF BUFF NOT FULL
        PUSHJ   P,COFOUT        ;OUTPUT THE BUFFER
        IDPB    R0,COFHD1#      ;DEPOSIT THE BYTE
        POPJ    P,              ;RETURN
COFOUT: OUT     COF,            ;OUTPUT THE BUFFER
        POPJ    P,              ;SUCCESSFUL SO RETURN
        ERROR   [ASCIZ "ERROR IN WRITING TO OUTPUT FILE"]

; THE DCR UUO DECREMENTS A BYTE POINTER. THE ADDRESS FIELD
; SHOULD ADDRESS A PDP10 BYTE POINTER.
DCRUUO: PUSH    P,R1
        LDB     R1,[POINT 6,@FORTY,5]
        LDB     R0,[POINT 6,@FORTY,11]
        ADD     R1,R0
        CAIGE   R1,^D36
        JRST    DEC2
        MOVE    R1,R0
        MOVEI   R0,^D36
        IDIV    R0,R1
        SOS     @FORTY
DEC2:   DPB     R1,[POINT 6,@FORTY,5]
        JRST    UUORE1
; THE TYPE UUO OUTPUTS A STRING TO THE TERMINAL.
; THE ADDRESS SHOULD POINT TO THE DESIRED MESSAGE.
; DOLLAR SIGNS ARE INTERPRETED AS CARRIAGE RETURNS
TYPUUO: PUSH    P,R1
        HRRZ    R1,FORTY
        HRLI    R1,10700
        SUBI    R1,1
TYP1:   ILDB    R0,R1
        CAIN    R0,DOLLAR
        MOVEI   R0,CRCHR
        CAIN    R0,EOLIT        ;SKIP IF NOT END OF STRING
        JRST    UUORE1
        TCO     R0
        JRST    TYP1
UUORE2::POP     P,R2
UUORE1: POP     P,R1
UUORET::POP     P,R0
        POPJ    P,

CLRUUO: CLRBFI  0              ;*THIS UUO SHOULD ALSO KILL CMD FILES*
        MOVE    R0,[POINT 7,LBUFF-1,34]
        MOVEM   R0,SPTR
        MOVEM   R0,SPTR+1
        MOVEI   R0,^D260
        MOVEM   R0,SPTR+2
        SETZM   CTEST
        SETZM   CTEST2
        PUSHJ   P,CLIN
        PUSHJ   P,CLOUT
        JRST    UUORET
; THE TTY UUO IS USED TO DEFINE EDITTING AND BREAK CHARACTERS
; FOR TCI, TCL, AND RDLINE. THE ADRESS PORTION SHOULD POINT
; TO THE NEW TTY STATUS WORD. THE OLD ONE IS RETURNED IN THE
; SPECIFIED AC (UNLESS THE AC IS ZERO). IF THE NEW STATUS WORD
; IS ILLEGAL, IT DOES NOT REPLACE THE OLD ONE, BUT THE OLD ONE
; IS STILL RETURNED IN THE SPECIFIED AC. THIS ALLOWS
; READING OF THE STATUS WORD WITHOUT CHANGING IT BY SPECIFYING
; AN ILLEGAL STATUS WORD.
; A STATUS WORD MUST EITHER HAVE BIT 0, BIT 3 OR ANY ONE OF BITS
; 28-35 TURNED ON TO BE LEGAL.
; THE BIT DEFINITIONS ARE:
;  0 - COMMAND EDIT MODE. CONTROL A, W, Q, AND I EDITTING ARE
;      DONE. BREAKS ONLY ON CARRIAGE RETURN OR LINEFEED.
;      CONTROL A ECHOES "_". CONTROL W ECHOES "\". CONTROL Q
;      ECHOES "^", CARRIAGE RETURN, LINEFEED.
;      CONTROL I (TAB) ECHOES THE PROPER NUMBER OF BLANKS WHICH
;      ARE ALSO SENT TO THE PROGRAM.
;  1 - SPECIAL ECHO MODE. THE CONTROL CHARACTERS A, W, AND Q
;      ARE ECHOED AS IN COMMAND EDIT MODE. HOWEVER, NO EDITTING
;      IS DONE. THE EDITTING CHRACTERS ARE PASSED TO THE
;      PROGRAM. BREAKS ACCORDING TO BREAK BITS BUT WILL NOT
;      BREAK ON CONTROL A, W, Q, OR I.
;      CONTROL I STILL SENDS THE PROPER NUMBER OF BLANKS TO THE
;      PROGRAM AND THE CONTROL I IS NOT SENT.
;  2 - SUPPRESS TABS. THIS BIT CAUSED "SPECIAL ECHO" MODE
;      TO SUPPRESS TABS. CONTROL I WILL STILL ECHO BLANKS
;      BUT THE BLANKS WILL NOT BE SENT TO THE PROGRAM. THE
;      CONTROL I WILL BE SENT INSTEAD.
;  3 - SYSTEM EDITTING. EDITTING IS DONE BY THE MONITOR. BREAK
;      CHARACTERS ARE CARRIAGE RETURN AND LINEFEED.
; 25 - PDP10/TYMEX FLAG. NOT SETTABLE BY USER. 1 = PDP10.
;      0 = TYMEX.
; 26 - CONVERT LINEFEEDS TO CARRIAGE RETURNS.
; 27 - CONVERT LOWER CASE ALPHA TO UPPER CASE ALPHA.
; 28 - BREAK ON CONTROL CHARACTERS (001-037).
; 29 - BREAK ON PUNCTUATION GROUP 1 (40-57).
; 30 - BREAK ON NUMBERS (60-71).
; 31 - BREAK ON PUNCTUATION GROUP 2 (72-100).
; 32 - BREAK ON UPPER CASE ALPHA (101-132).
; 33 - BREAK ON PUNCTUATION GROUP 3 (133-140).
; 34 - BREAK ON LOWER CASE ALPHA (141-172).
; 35 - BREAK ON PUNCTUATION GROUP 4 (173-176).
;
; TTY STATUS IS EFFECTIVEY INITIALIZED AS "40000,,400".
TTYUUO: SKIPGE  TTYFLG
        JRST    TTY2
        PUSH    P,FORTY
        DISABL
        SOS     TTYFLG
        SETTTY  [XWD 40000,400]
        ENABLE
        POP     P,FORTY
TTY2:   PUSH    P,R1
        MOVE    R1,[XWD -1,6]
        GETTAB  R1,
        PUSHJ   P,FERR          ;FATAL ERROR
        MOVE    R0,@FORTY
        ANDCMI  R0,2000
        TRNN    R1,200
        IORI    R0,2000
        POP     P,R1
        TLNN    R0,440000
        TRNE    R0,377
        JRST    .+2
        MOVE    R0,TTYSTA
        EXCH    R0,TTYSTA
        PUSH    P,R0
        LDB     R0,[POINT 4,FORTY,12]
        POP     P,@R0
        JRST    UUORET

ERRUUO: MOVE    R0,FORTY
        SETZM   COUT            ;*PROBABLY SHOULD CLOSE FILE
        TYPE    @R0
        CLRIN                   ;CLEAR INPUT BUFFER
        JRST    CDISP           ;RETURN TO COMMAND DISPATCHER
ENUUO:  POP     P,R0
        AOSL    ESCFLG
        SKIPL   SAVESC
        POPJ    P,
        JRST    ESCR
DISUUO: SOS     ESCFLG
        JRST    UUORET


;PRINT OCTAL NUMBER ON TERMINAL
; CALL WITH NUMBER IN R0

PRONUM::HRLM    R0,(P)          ;PUT THAT DIGIT ON THE STACK
        LSH     R0,-3           ;RIGHT SHIFT THREE
        SKIPE   R0              ;SKIP IF THERE ARE NO MORE DIGITS
        PUSHJ   P,PRONUM        ;DO IT AGAIN
        HLRZ    R0,(P)          ;GET NEXT DIGIT OFF THE STACK
        TRZ     R0,777770       ;SAVE ONLY RIGHT THREE BITS
        ADDI    R0,"0"          ;CONVERT IT TO A CHARACTER
        TCO     R0              ;TYPE IT
        POPJ    P,              ;TYPE NEXT DIGIT OR RETURN

;PRINT DECIMAL NUMBER ON TERMINAL
; CALL WITH NUMBER IN R0

PRDNUM::IDIVI   R0,12           ;DIVIDE BY TEN FOR NEXT DIGIT
        HRLM    R1,(P)          ;STICK THE DIGIT IN THE STACK
        SKIPE   R0              ;SKIP IF WE'VE GOT ALL THE DIGITS
        PUSHJ   P,PRDNUM        ;GET THE NEXT DIGIT
        HLRZ    R0,(P)          ;GET THE NEXT DIGIT FROM THE STACK
        ADDI    R0,"0"          ;CONVERT NUMBER TO CHARACTER
        TCO     R0              ;OUTPUT THE CHARACTER
        POPJ    P,              ;GET NEXT DIGIT OR RETURN

;PRINT A TWO DIGIT DECIMAL NUMBER TO THE TERMINAL
; CALL WITH NUMBER IN R0

PRD2N:: IDIVI   R0,12           ;DIVIDE BY TEN TO SEPARATE DIGITS
        ADDI    R0,60           ;CONVERT FIRST NUMBER TO CHARACTER
        TCO     R0              ;OUTPUT THE CHARACTER
        ADDI    R1,60           ;CONVERT SECOND NUMBER TO CHARACTER
        TCO     R1              ;OUTPUT THAT CHARACTER
        POPJ    P,              ;RETURN

;READ DECIMAL/OCTAL NUMBER
; RETURN NUMBER IN R0, TERMINATING CHAR IN CH, TYPE IN CT
; RETURN NUMBER OF CHARACTERS IN NUMBER IN R1

RDONUM::SKIPA   R1,[10]         ;SET BASE TO EIGHT
RDDNUM::MOVEI   R1,12           ;SET BASE TO TEN
        PUSH    P,R1            ;SAVE BASE ON THE STACK
        SETZB   R1,R0           ;ZERO THE ACCUMULATOR AND CHAR COUNT
RDNU1:  TCI     CT,CH           ;READ NEXT CHAR
        CAIE    CT,NU           ;SKIP IF IT'S A DIGIT
        JRST    RDNRET          ;ANYTHING ELSE IS A TERMINATOR SO RET
        IMUL    R0,(P)          ;MULTIPLY ACCUMULATOR BY BASE
        ADD     R0,CH           ;ADD IN THE NEW DIGIT
        SUBI    R0,60           ;CONVERT NEW DIGIT FROM CHAR TO NUMBER
        AOJA    R1,RDNU1        ;INCREMENT CHAR COUNT AND GET NEXT CHAR
RDNRET: POP     P,(P)           ;POP STACK TO THROW AWAY THE BASE
        POPJ    P,              ;RETURN FROM RDDNUM OR RDONUM
        VAR
        END
  +H=º