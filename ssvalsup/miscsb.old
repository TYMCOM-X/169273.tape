SUBTTL MISCSB - miscellaneous subroutines
ERREX:  ; here when we are doing an error exit
        MOVEM   AC,NUM
        TCR     (1)
        TYPSTR ([ASCIZ /Error exit: code =/],777,0,0,N,Y)
        TYPNUM (NUM,D,1,0,Y,Y)
        JRST    CMDQUI

WASLIN: ; waste a line
        TLNE    FLG,U.EOL               ; skip if last char not eol
         JRST   WASLI2
        INSTR   (NONE,STRSP,1,S)
WASLI2: POPJ    P,

CHKLIC: ; check wf and ac proc lic
        HRROI   AC,.GTLIC               ; get lic
        GETTAB  AC,
         SETZ   AC,
        TLNN    AC,(LC.WF)
         BOMB   (ERR.WF)
        TLNN    AC,(LC.AC)
         BOMB   (ERR.AC)
        MOVEM   AC,NUM
        POPJ    P,

GETPJ:  ; find actg and cud host numbers in (pj)jobs.dat
  ;     MOVEI   AC,^D74
  ;     MOVEM   AC,ACTHOS
  ;     AOS     (P)
  ;     POPJ    P,
        MOVE    AC,[.CHOPN,,JOBCHN]
        CHANIO  AC,JOBOPN       ; open a channel
         BOMB   (ERR.PJ)
        HRLI    AC,.CHLK        ; set to do lookup
        CHANIO  AC,JOBLKB       ; do it
         BOMB   (ERR.PJ)
        HRLI    AC,.CHIN        ; set to input a block
        CHANIO  AC,JOBCOM
        SKIPA
         BOMB   (ERR.PJ)
        MOVEI   AC1,PJ.FSW      ; first system word in file
GETJO2: MOVE    AC,JOBBUF(AC1)  ; get a word
        CAMN    AC,MONE         ; skip if not end
         JRST   GETJOE
        SKIPE   ACTHOS          ; skip if we do not yet have act host
         JRST   GETJO3
        TLNN    AC,PJ.ACT       ; skip if act sys record found
         JRST   GETJO3
        HRRZM   AC,ACTHOS       ; save acthos
        SKIPE   CUDHOS          ; skip if we do not yet have cud host
         JRST   GETJOD
GETJO3: TLNN    AC,PJ.CUD       ; skip if cud sys record found
         JRST   GETJO4
        HRRZM   AC,CUDHOS       ; save cudhos
        SKIPE   ACTHOS          ; skip if we do not yet have act host
         JRST   GETJOD
GETJO4: AOJ     AC1,            ; increment index
        JRST    GETJO2

GETJOD: AOS     (P)             ; set to skip return
        JRST    GETJOE          ; return

GETJOE: MOVE    AC,[.CHREL,,JOBCHN]     ; set to release channel
        CHANIO  AC,
        POPJ    P,

BINDEC: ; change binary to decimal, ac/ byte pointer,  ac1/ number
        IDIVI   AC1,^D10
        HRLM    AC2,0(P)                ; save digit
        JUMPE   AC1,BINDE2              ; none left
        PUSHJ   P,BINDEC                ; next digit
BINDE2: HLRZ    AC1,0(P)                ; get digit
        ADDI    AC1,"0"                 ; make ascii
        IDPB    AC1,AC                  ; deposit it
        POPJ    P,                      ; next

CNVD0:  MOVEM   AC,AC4          ;subrt. converts ascii str. (=dec.#) to binary
        HRLI    AC4,(POINT 7)   ;set byte pointer
        SETZ    AC1,            ;zero a location to hold binary we create
CNVD1:  ILDB    AC,AC4          ;put first or next char. in ac
        CAIN    AC," "          ;blank means end of token we're converting
          JRST  [AOS    0(P)    ;skip return since conversion succeeded
                 POPJ   P,]
        CAIL    AC,"0"          ;if non-integer character,,goto ndecn 
        CAILE   AC,"9"          ;if non-integer character,,goto ndecn
          JRST  NDECN
        SUBI    AC,"0"          ;convert to binary
        IMULI   AC1,^D10        ;multiply previous sum by 10 before
        ADD     AC1,AC          ;adding next digit
        JRST    CNVD1           ;get next character
NDECN:  POPJ    P,



CNVO0:  MOVEM   AC,AC4          ;subrt. converts ascii str. (=oct.#) to binary
        HRLI    AC4,(POINT 7)   ;set byte pointer
        SETZ    AC1,            ;zero a location to hold binary we create
CNVO1:  ILDB    AC,AC4          ;put first or next char. in ac
        CAIN    AC," "          ;blank means end of token we're converting
          JRST  [AOS    0(P)    ;skip return since conversion succeeded
                 POPJ   P,]     
        CAIL    AC,"0"          ;if non-integer char.,,goto noctn
        CAILE   AC,"7"          ;if non-integer char.,,goto noctn
          JRST  NOCTN
        SUBI    AC,"0"          ;convert to binary
        IMULI   AC1,^O10        ;multiply previous sum by 8 before
        ADD     AC1,AC          ;adding next digit
        JRST    CNVO1           ;go get next character
NOCTN:  POPJ    P,

GETUNM: ; input a username into UNMSPC
; returns with the length of the username in ac1.
        INSTR   ([ASCIZ/Username :/],UNMSPC,L.UNM,T)
        MOVEI   AC1,L.UNM
        MOVEI   AC,UNMSPC
        PUSHJ   P,CNTCHR
        SKIPE   AC1
        AOS     0(P)
        POPJ    P,

GTUCLS:	; get mud class info from terminal
	MOVE	AC,[CLSWRK,,CLSWRK+1]
	SETZM	CLSWRK
	BLT	AC,CLSWEN
	MOVEI	AC,CLSWRK+1
	MOVEM	AC,CLSWIN	; initialize index
	MOVEI	AC,NMSZCS-1
	MOVEM	AC,CLSWCT	; max number of words
	GETYR	([ASCIZ/Is the class self defining ?/])
	 JRST	GTRCLS	; get regular class
	JRST	GTSCLS	; get self defining class

GTRCLS:	; get regular class
	INNUM	([ASCIZ/Class :/],D)
	 JRST	[PUSHJ P,INORNO
		 JRST	GTRCLS]
	MOVEM	AC1,CLSWRK+1
	JUMPG	AC1,GTRCL2	; jump to ac2 if not zero
	GETYR	([ASCIZ/Please confirm class = 0 :/])
	 JRST	GTRCLS
GTRCL2:
	PUSHJ	P,GHGRP		; get home groups
	PUSHJ	P,GNHGRP	; get non-home groups
	PUSHJ	P,GHHST		; get home hosts
	PUSHJ	P,GNHHST	; get non-home hosts
	PUSHJ	P,CLSWDS	; display it, ask for approval.
	 JRST	GTUCLS
	POPJ	P,

GTSCLS:	; get self defining class
	GETYR	([ASCIZ/Is this a exception class ?/])
	 JRST	GTSCL2
	MOVEI	AC,UDN.CD	; mark exception class
	JRST	GTSCL3
GTSCL2:	SETZ	AC,
GTSCL3:
	TRO	AC,UDF.CD	; mark self defining class
	MOVEM	AC,CLSWRK+1
	PUSHJ	P,GOHST		; get originating hosts
	PUSHJ	P,GONOD		; get originating nodes
	PUSHJ	P,GHGRP		; get home groups
	PUSHJ	P,GNHGRP	; get non home groups
	PUSHJ	P,GHHST		; get home hosts
	PUSHJ	P,GNHHST	; get non home hosts
	PUSHJ	P,CLSWDS	; display info
	 JRST	GTUCLS
	POPJ	P,

GONOD:	; get originating nodes
	INNUM	([ASCIZ/Originating Nodes :/],O)
	 JRST	[PUSHJ P,INORNO
		 JRST  GONOD]
	JUMPG	AC1,GONOD2
	 JRST	GONODD
GONOD2:	SOSG	CLSWCT
	 JRST	CLSOVF
	AOS	CLSWRK		; increment size in words
	AOS	CLSWRK+1	; increment size of self defined rec 2 bytes
	AOS	CLSWRK+1
	AOS	CLSWIN		; increment index
	MOVEM	AC1,@CLSWIN	; store it
	TLNN	FLG,U.EOL	; skip if last input not eol
	 JRST	GONOD
GONODD:	POPJ	P,

GOHST:	; get originating hosts
	INNUM	([ASCIZ/Originating Hosts :/],D)
	 JRST	[PUSHJ	P,INORNO
		 JRST	GOHST]
	JUMPG	AC1,GOHST2
	 JRST	GOHSTD
GOHST2:	SOSG	CLSWCT
	 JRST	CLSOVF
	AOS	CLSWRK
	AOS	CLSWRK+1
	AOS	CLSWRK+1
	AOS	CLSWIN
	TRO	AC1,HOS.CD
	MOVEM	AC1,@CLSWIN
	TLNN	FLG,U.EOL
	 JRST	GOHST
GOHSTD:	POPJ	P,

GHGRP:	; get home groups
	INNUM	([ASCIZ/Home Groups :/],D)
	 JRST	[PUSHJ	P,INORNO
		 JRST	GHGRP]
	JUMPG	AC1,GHGRP2
	MOVE	AC,CNVHLD	; check for null input
	CAMN	AC,[ASCII/     /]
	 JRST	GHGRPD
	TYPSTR	([ASCIZ/Home group zero not allowed/],777,0,0,Y,Y)
	PUSHJ	P,INORNO
	JRST	GHGRP
GHGRP2:	; here to put new group in work area
	SOSG	CLSWCT		; jump if room left
	 JRST	CLSOVF		; overflow.
	AOS	CLSWIN
	AOS	CLSWRK		; increment size of class
	TRO	AC1,HOM.CD!GRP.CD ; mark them
	MOVEM	AC1,@CLSWIN	; store it
	TLNN	FLG,U.EOL
	 JRST	GHGRP
GHGRPD:	POPJ	P,

GNHGRP:	; get non home groups
	INNUM	([ASCIZ/Non-Home Groups :/],D)
	 JRST	[PUSHJ	P,INORNO
		 JRST	GNHGRP]
	JUMPG	AC1,GNHGR2
	MOVE	AC,CNVHLD
	CAMN	AC,[ASCII/     /]
	 JRST	GNHGRD
	SETZ	AC1,		; to be safe
GNHGR2:
	SOSG	CLSWCT
	 JRST	CLSOVF
	AOS	CLSWIN
	AOS	CLSWRK
	TRO	AC1,GRP.CD
	MOVEM	AC1,@CLSWIN
	TLNN	FLG,U.EOL
	 JRST	GNHGRP		; go get more
GNHGRD:	POPJ	P,

GHHST:	; get home hosts
	INNUM	([ASCIZ/Home hosts :/],D)
	 JRST	[PUSHJ P,INORNO
		 JRST  GHHST]
	JUMPG	AC1,GHHST2
	 JRST	GHHSTD		; all done.
GHHST2:	SOSG	CLSWCT
	 JRST	CLSOVF
	AOS	CLSWIN
	AOS	CLSWRK
	TRO	AC1,HOM.CD
	MOVEM	AC1,@CLSWIN
	TLNN	FLG,U.EOL
	 JRST	GHHST
GHHSTD:	POPJ	P,

GNHHST:	; get non home hosts
	INNUM	([ASCIZ/Non-Home Hosts :/],D)
	 JRST	[PUSHJ	P,INORNO
		 JRST	GNHHST]
	JUMPG	AC1,GNHHS2
	 JRST	GNHHSD
GNHHS2:	SOSG	CLSWCT
	 JRST	CLSOVF
	AOS	CLSWIN
	AOS	CLSWRK
	MOVEM	AC1,@CLSWIN
	TLNN	FLG,U.EOL
	 JRST	GNHHST
GNHHSD:	POPJ	P,

CLSOVF:
	TYPSTR	([ASCIZ/Overflow./],777,0,0,Y,Y)
	PUSHJ	P,INORNO
	JRST	GTUCLS		; start again

CLSWDS:	; display info
	TCR	(1)
	SETZM	CLSCTR		; set up some data for clsout routine
	AOS	CLSCTR
	MOVEI	AC,NMCLSS
	MOVEM	AC,CLSIND
	MOVE	AC,CLSWRK
	MOVEM	AC,GRPCTR
	MOVE	AC,[NMCLSS,,CLSSAV]	; save nmclss data
	BLT	AC,CLSSAV+NMSZCS
	MOVE	AC,[CLSWRK,,NMCLSS]	; move in clswrk data
	BLT	AC,NMCLSS+NMSZCS-1
	SETZM	NMCLSS+NMSZCS		; zero our 1st wrd of 2nd position
	PUSHJ	P,CLSWOT		; output info
	MOVE	AC,[CLSSAV,,NMCLSS]
	BLT	AC,NMCLSS+NMSZCS	; restore original nmclss data
	TCR	(1)
	GETYR	([ASCIZ/Ok ?/])
	 SKIPA
	AOS	0(P)
	POPJ	P,


GETHOH: ; input home system number
        INNUM   ([ASCIZ/Home Host :/],D)
         JRST   GETHM2  ; not correct input
        MOVEM   AC1,HOMSYS              ; save it
; now check with acctg to see if this is a tymshare host
        SNDBYT  (ACTPRT,\B.ACOM,KHOACT,I)
        SNDBYT  (AC,\B.HST,HOMSYS)
        PUSHJ   P,AGANS         ; skip return if tymshare host
         JRST   GETHM3          ; not a tymshare host
        POPJ    P,
GETHM2: PUSHJ   P,INORNO
        JRST    GETHOH
GETHM3: TYPSTR  ([ASCIZ/Not a Tymshare Host./])
        PUSHJ   P,INORNO
        JRST    GETHOH

GETCC:  ;input costcode
        TLNE    FLG,U.NET
         JRST   GETCC1
        TLNN    FLG,U.PRV               ;skip if we're privileged
        TLNN    FLG,U.CUS               ;skip if we're customer type
         SKIPA                          ;skip always
         JRST   CCIN2                   ;default to own costcode
GETCC1: INNUM   ([ASCIZ/Cost Code: /],D) ;input cost code
         JRST   [PUSHJ  P,INORNO        ;try again if input was incorrect
                 JRST   GETCC]
        MOVEM   AC1,CCRCT
        SKIPE   AC1                     ;return if input was <cr>
         AOS    0(P)                    ;set up for skip return
        POPJ    P,                      ;return

CCIN2:  MOVE    AC1,MY.CC               ;default to own costcode
        MOVEM   AC1,CCRCT               ;costcode contained in CCRCT
        AOS     0(P)                    ;set up for skip return
        POPJ    P,                      ;return

GETCUS: ; input a customer number into CUSNUM
        MOVE    AC,MY.DIS
        CAIN    AC,^D205        ; skip if not finance dept.
         JRST   GE2CUS          
        TLNE    FLG,U.NET
         JRST   GE2CUS
        TLNN    FLG,U.PRV       ; skip if we're privileged
        TLNN    FLG,U.CUS       ; skip if we are customer type
         SKIPA
        JRST    CUSIN2
GE2CUS: INNUM   ([ASCIZ/Cid : /],D)
         JRST   [PUSHJ P,INORNO
                 JRST   GETCUS]
        MOVEM   AC1,CUSNUM
        SKIPE   AC1
         AOS    0(P)
        POPJ    P,
CUSIN2: MOVE    AC1,MY.CID      ; my cus number
        MOVEM   AC1,CUSNUM
        AOS     0(P)
        POPJ    P,

GETDIS: ; input district
        TLNE    FLG,U.NET
         JRST   GETDI3
        TLNN    FLG,U.PRV       ; skip if we're privileged
        TLNN    FLG,U.DIS       ; skip if we're district type
         JRST   GETDI3
        MOVE    AC,MY.DIS
        CAIE    AC,0      ; give dist 0 & dist. type users (such as psdmgr1)
         JRST   DISIN2    ; access to other district
GETDI3: INNUM   ([ASCIZ/District : /],D)
         JRST   [PUSHJ P,INORNO
                 JRST   GETDIS]
        MOVEM   AC1,DISRCT
        MOVEI   AC,CNVHLD
        MOVEI   AC1,5
        PUSHJ   P,CNTCHR
        SKIPE   AC1
         AOS    0(P)
        POPJ    P,
DISIN2: MOVE    AC1,MY.DIS
        MOVEM   AC1,DISRCT
        AOS     0(P)
        POPJ    P,

GETGAN: ; input a gan
        TLNE    FLG,U.PRV!U.DIS!U.CUS!U.NET    ; all these need to be asked
         JRST   GETGA1
        TLNN    FLG,U.ASV               ; this guy defaults to us
         POPJ   P,                      ; he doesn't get one at all
        JRST    GETGA2
GETGA1: INSTR   ([ASCIZ/Username in desired Gan :/],UNMSPC,L.UNM,T)
        MOVEI   AC,UNMSPC
        MOVEI   AC1,L.UNM
        PUSHJ   P,CNTCHR
        SKIPG   AC1
         POPJ   P,
        PUSHJ   P,GCREC
         JRST   [PUSHJ P,INORNO
                 JRST   GETGAN]
        MOVE    AC,NMDIST
        MOVEM   AC,DISRCT
        MOVE    AC,NMGAN
        MOVEM   AC,GLOBAC
        TLNN    FLG,U.CUS       ; skip if we are cus type
         JRST   GETGAD
        SNDBYT  (ACTPRT,\B.ACOM,LCN2CT,I)
        SNDBYT  (ACTPRT,\B.UUN,NMUUN)
        PUSHJ   P,AGANS
         JRST   [PUSHJ P,INORNO
                 JRST   GETGAN]
        GETBYT  (ACTPRT,\B.CID)
         JRST   GETCMD
        MOVEM   AC1,CUSNUM
        JRST    GETGAD
GETGA2: MOVE    AC1,MY.GAN
        MOVEM   AC1,GLOBAC
GETGAD: AOS     0(P)
        POPJ    P,

CHKUUN: ; check if we have access to this uun
        ; uun from nmuun
        MOVE    AC,MY.DIS
        CAIN    AC,^D206                 
         JRST   CHKUND                 ; give dist 206 access priv.
        CAIN    AC,^D205
         JRST   CHKUND
        CAIN    AC,^D144
         JRST   CHKUN4                 ; check access of ACS districts
        CAIN    AC,^D70
         JRST   CHKUND                 ; give dist 70  access priv.
        CAIN    AC,0
         JRST   CHKUND                 ; give dist 0 access priv.
        TLNE    FLG,U.PRV!U.AP!U.NET    ; skip if not priv, acctg, or tymnet
         JRST   CHKUND
        TLNN    FLG,U.DIS               ; skip if we are dist type
         JRST   CHKUN2                  ; check if we're customer
        MOVE    AC,NMDIST               ; get district
        CAMN    AC,MY.DIS               ; compare to us
         JRST   CHKUND                  ; match
        JRST    CHKUNE                  ; no match
CHKUN2: TLNN    FLG,U.CUS               ; skip if we're customer
         JRST   CHKUN3                  ; check for acct sup
        PUSHJ   P,GETACC
         JRST   GETCMD
        SNDBYT  (ACTPRT,\B.ACOM,KMUACT,I)   ; check mailname for this uun
        SNDBYT  (AC,\B.UUN,MY.UUN)         ; send loggon uun
        SNDBYT  (AC,\B.UUN,NMUUN)
        GETBYT  (AC)
         JRST   GETCMD
        CAIE    AC1,ACT.OK
         JRST   CHKUNE                  ; no such uun in acctg
        JRST    CHKUND
CHKUN3: TLNN    FLG,U.ASV               ; see if acctsup
         JRST   CHKUNE                  ; no
        MOVE    AC,NMGAN                ; check the gan
        CAME    AC,MY.GAN               ; skip if we match
         JRST   CHKUNE                  ; nothing else left
        JRST    CHKUND
CHKUN4: MOVE   AC,NMDIST
        PUSHJ  P,CHKACS
        JRST   CHKUND
        JRST   CHKUNE
CHKUND: AOS     0(P)
        POPJ    P,
CHKUNE: PUSHJ   P,NOACM
        POPJ    P,


CHKCC:  ;check if we have access to this costcode
        TLNE    FLG,U.PRV!U.AP!U.ASV!U.NET    ; skip if not privileged or acctg.
         JRST   CHKCCD                  ;ok, all done
        TLNN    FLG,U.DIS               ;skip if we're district type
         JRST   [PUSHJ  P,NOACM         
                 POPJ   P,]             ;return

CHKCCD: AOS     0(P)                    ;set up for skip return
        POPJ    P,                      ;skip return

CHKCUS: ; see if we have access to this customer
; customer number in cusnum
        MOVE    AC,MY.DIS
        CAIN    AC,^D205
         JRST   CHKCDN                  ; give finance dist. access (SBILL1)
        CAIN    AC,^D206
         JRST   CHKCDN                  ; give dist 206 access priv.
        CAIN    AC,^D70 
         JRST   CHKCDN                  ; give dist 70  access priv.
        CAIN    AC,0
         JRST   CHKCDN                  ; give dist 0 access priv.
        TLNE    FLG,U.PRV!U.AP!U.NET          ; skip if not privileged or acctg
         JRST   CHKCDN                  ; ok, all done.
        TLNE    FLG,U.CUS               ; skip if we're not customer type
         JRST   CHKCDN                  ; if custyp always our cusnum
        TLNN    FLG,U.DIS               ; skip if district type
         JRST   CHKCER
        SNDBYT  (ACTPRT,\B.ACOM,LCDACT,I)
        SNDBYT  (ACTPRT,\B.CID,CUSNUM)
 ;      SNDBYT  (ACTPRT,\B.ASY,ACTSY2)
        PUSHJ   P,AGANS
         JRST   CHKCER
        GETBYT  (ACTPRT,\B.DIS)
         JRST   GETCMD
        MOVEM   AC1,ACCDIS
        MOVE    AC,MY.DIS
        CAIN    AC,^D144
         JRST   CHKCD4
        CAME    AC1,MY.DIS
         JRST   CHKCER
        JRST    CHKCDN
CHKCD4: MOVE    AC,ACCDIS
        PUSHJ   P,CHKACS              ; check acs districts
        JRST    CHKCDN
        JRST    CHKCER
CHKCDN: AOS     0(P)
        POPJ    P,
CHKCER: PUSHJ   P,NOACM
        POPJ    P,

CHKDIS: ; see if we have access to info for district in DISRCT
; this is real easy, we only have if
; (we are privileged) or (we are dist type and disrct matches my.dis).
; if we're dist type disrct always equals my.dis
        TLNE    FLG,U.PRV!U.AP!U.ASV!U.NET   ; skip if not priv, asv or acct.
         JRST   CHKDI2          ; ok return
        TLNN    FLG,U.DIS       ; skip if we're dist type.
         JRST   [PUSHJ  P,NOACM
                 POPJ   P,]
CHKDI2: AOS     0(P)
        POPJ    P,

CHKGAN: ; see if we have access to this gan
        MOVE    AC,MY.DIS
        CAIN    AC,^D205
         JRST   CHKGAD
        CAIN    AC,^D206
         JRST   CHKGAD
        CAIN    AC,^D144
         JRST   CHKGA4     ; check access of ACS districts
        CAIN    AC,^D70
         JRST   CHKGAD
        CAIN    AC,0
         JRST   CHKGAD
        TLNE    FLG,U.PRV!U.AP!U.NET
         JRST   CHKGAD
        TLNN    FLG,U.DIS
         JRST   CHKGA2
        MOVE    AC,DISRCT
        CAMN    AC,MY.DIS
         JRST   CHKGAD
CHKGA2:
        TLNN    FLG,U.CUS
         JRST   CHKGA3
        MOVE    AC,CUSNUM
        CAMN    AC,MY.CID
         JRST   CHKGAD
CHKGA3:
        TLNN    FLG,U.ASV
         JRST   C
        MOVE    AC,GLOBAC
        CAME    AC,MY.GAN
         JRST   CHKGAE
        JRST    CHKGAD
CHKGA4: MOVE    AC,NMDIST
        PUSHJ   CHKACS
        JRST    CHKGAD
        JRST    CHKGAE
CHKGAD: AOS     0(P)
        POPJ    P,
CHKGAE: PUSHJ   P,NOACM
        POPJ    P,

NOACM:  TYPSTR  ([ASCIZ/No access./])
        TCR     (1)
        POPJ    P,

INASYS: ; input asystype 9,10,370 or any (cr)
; output:
;  ac1/ 0, ^d940, ^d10, or ^d370
;  actsys/ same as ac1
        INNUM   ([ASCIZ/System type (940, 10, or 370 or (cr)) :/],D)
         JRST   INASY3
        CAIE    AC1,^D940
         JRST   INAS1A
        MOVEI   AC1,2           ; system code
        JRST    INASY1
INAS1A: CAIE    AC1,^D10
         JRST   INAS1B
        MOVEI   AC1,1
        JRST    INASY1
INAS1B: CAIE    AC1,^D370
         JRST   INAS1C
        MOVEI   AC1,3
        JRST    INASY1
INAS1C: MOVE    AC,CNVHLD       ; check if he input a null
        CAME    AC,[ASCII/     /]
         JRST   INASY3
        SETZ    AC1,
INASY1: MOVEM   AC1,ACTSYS      ; put in return area
        POPJ    P,
INASY3: PUSHJ   P,INORNO
        JRST    INASYS

INACSY: ; input asystype 9,940,10,370 or any (cr)
; output:
;  ac1/ 0, ^d940, ^d10, or ^d370, ^d9
;  actsys/ same as ac1
        INNUM   ([ASCIZ/System type (9, 940, 10, or 370 or (cr)) :/],D)
         JRST   INACS3
        CAIE    AC1,^D9               ; tymnet?
         JRST   INAC1X
        JRST    INACY1
INAC1X: CAIE    AC1,^D940
         JRST   INAC1A
        MOVEI   AC1,2           ; system code
        JRST    INACY1
INAC1A: CAIE    AC1,^D10
         JRST   INAC1B
        MOVEI   AC1,1
        JRST    INACY1
INAC1B: CAIE    AC1,^D370
         JRST   INAC1C
        MOVEI   AC1,3
        JRST    INACY1
INAC1C: MOVE    AC,CNVHLD       ; check if he input a null
        CAME    AC,[ASCII/     /]
         JRST   INACS3
        SETZ    AC1,
INACY1: MOVEM   AC1,ACTSYS      ; put in return area
        POPJ    P,
INACS3: PUSHJ   P,INORNO
        JRST    INACSY


INASY2: ; input asystype, including special system type
; output:
;  ac1/ any number
;  actsys/ same as ac1
        TLNN    FLG,U.AP        ; skip if accounting users
         JRST   INAS2Z
        INNUM   ([ASCIZ/System type (940, 10, 370 or others) :/],D)
         JRST   INASY4
        JRST    INAS2Y
INAS2Z: INNUM   ([ASCIZ/System type (940, 10, or 370) :/],D)
         JRST   INASY4
INAS2Y: CAIE    AC1,^D940
         JRST   INAS2A
        MOVEI   AC1,2           ; system code
        JRST    INASYD
INAS2A: CAIE    AC1,^D10
         JRST   INAS2B
        MOVEI   AC1,1
        JRST    INASYD
INAS2B: CAIE    AC1,^D370
         SKIPA
        MOVEI   AC1,3
INASYD: MOVEM   AC1,ACTSYS      ; put in return area
        POPJ    P,
INASY4: PUSHJ   P,INORNO
        JRST    INASY2

INASY9: ; input asystype, including special system type
; output:
;  ac1/ any number
;  actsys/ same as ac1
        TLNN    FLG,U.AP!U.CS   ; skip if accounting or cs users
         JRST   INAS3Z
        INNUM   ([ASCIZ/System type (940, 10, 370 or others) :/],D)
         JRST   INASY5
        JRST    INAS3Y
INAS3Z: INNUM   ([ASCIZ/System type (940, 10, or 370 or (cr)) :/],D)
         JRST   INASY5
INAS3Y: CAIE    AC1,^D940
         JRST   INAS3A
        MOVEI   AC1,2           ; system code
        JRST    INASYE
INAS3A: CAIE    AC1,^D10
         JRST   INAS3B
        MOVEI   AC1,1
        JRST    INASYE
INAS3B: CAIE    AC1,^D370
         JRST   INASYG
        MOVEI   AC1,3
        JRST    INASYE
INASYG: MOVE    AC,CNVHLD
        CAME    AC,[ASCII/     /]
         JRST   INASYE
        SETZ    AC1,
INASYE: MOVEM   AC1,ACTSYS      ; put in return area
        POPJ    P,
INASY5: PUSHJ   P,INORNO
        JRST    INASY9

FINAST: ; if actsys is zero, find us a real ast
        MOVE    AC1,ACTSYS      ; check if ast was supplied
        MOVEM   AC1,ACTSY2
        JUMPG   AC1,FINAS3      ; jump if not zero, to finas3
; if no ast code was supplied, get ast byte from acctg, and extract
; an ast code from it.
        SNDBYT  (ACTPRT,\B.ACOM,FINARG)   ; send the command
        SNDBYT  (AC,\B.UUN,FINAR2)    ; assuming B.UUN and B.CID are equal
        PUSHJ   P,AGANS
         JRST   FINASE          ; error return
        GETBYT  (AC)            ; get ast byte
         JRST   GETCMD
        MOVE    AC1,ASMTAB(AC1) ; get an ast number from table
        MOVEM   AC1,ACTSY2      ; put it in actsy2
        MOVEM   AC1,ACTSYS      ; also save for the use of SYSOUT
FINAS3: AOS     0(P)    ; set to skip return
FINASE: POPJ    P,      ; and return
ASMTAB: EXP     0,2,1,1,3,3,3,3   ; tbl of ast codes for each possible mask

GETHOS: ; get a host number form terminal and build an old lud circuit
        INNUM   ([ASCIZ/Host :/],D)
         JRST   GETHO2
        JUMPE   AC1,GETHO3      ; he input a zero or cr
GETHO1: MOVEM   AC1,LUDNUM      ; prepare for circuit building
        PUSHJ   P,GETOLD        ; get a circuit to old lud host
         POPJ   P,
        AOS     0(P)            ; successful return
        POPJ    P,
GETHO2: PUSHJ   P,INORNO        ; see if we should try again
        JRST    GETHOS
GETHO3: SKIPG   AC1,OLDHOS
         JRST   GETHO2
        JRST    GETHO1

GETHOO:	; get old lud host for MOVE command.
	INNUM	([ASCIZ/Old host :/],D)
	 JRST	GEHOO2
	JUMPE	AC1,GEHOO2
	MOVEM	AC1,LUDNUM
	PUSHJ	P,GETOLD
	 POPJ	P,
	AOS	0(P)
	POPJ	P,
GEHOO2:	PUSHJ	P,INORNO
	JRST	GETHOO

GETHON:	; get new lud host for MOVE command.
	INNUM	([ASCIZ/New host :/],D)
	 JRST	GEHON2
	JUMPE	AC1,GEHON2
	MOVEM	AC1,LUDNUM
	PUSHJ	P,GETNEW
	 POPJ	P,
	AOS	0(P)
	POPJ	P,
GEHON2:	PUSHJ	P,INORNO
	JRST	GETHON

; INORNO checks if input is from a file, if so jrsts to GETCMD, else
; returns to caller with a popj
INORNO: TLNE    FLG,U.IND       ; skip if not coming from indirect file
        JRST    INOR2
	TRNE	FLG,U.RFI	; skip if not coming from request file
	 BOMB	(ERR.R4)
        PUSHJ   P,WASLIN
        TYPSTR  ([ASCIZ/Try again./])
        TCR     (1)
        POPJ    P,
INOR2:  TYPSTR  ([ASCIZ/Error- incorrect indirect input./],777,0,0,Y,Y)
        JRST    GETCMD

AGANS:  ; get answer from acctg
        GETBYT  (ACTPRT)
         JRST   GETCMD
        MOVEM   AC1,ACANS
        CAIN    AC1,ACT.OK
         AOS    0(P)
        POPJ    P,

OLDA:	; get answer from old lud host
	GETBYT	(OLDPRT)
	 JRST	GETCMD
	MOVEM	AC1,OLDANS
	CAIN	AC1,LUD.OK
	 AOS	0(P)
	POPJ	P,

NEWA:	; get anser from new lud host
	GETBYT	(NEWPRT)
	 JRST	GETCMD
	MOVEM	AC1,NEWANS
	CAIN	AC1,LUD.OK
	 AOS	0(P)
	POPJ	P,

LUDAOT:	; output lud and acctg errors, answer must be in ac1
	CAIL	AC1,LUDALN
	 JRST	LUDAO2
	HLRZ	AC,LUDAMS(AC1)
	TRNE	AC,X.M
	 PUSHJ	P,LUDAOS
LUDAO1:	TYPSTR	(@LUDAMS(AC1))
	POPJ	P,
LUDAO2:	PUSHJ	P,LUDAOS
	TYPSTR	([ASCIZ/Error code out of range./],777,1)
	POPJ	P,

LUDAOS:	; output error number
	MOVEM	AC1,NUM
	MOVEI	AC,"("
	PUSHJ	P,CHROUT
	TYPNUM	(NUM,D,0,0,N)
	MOVEI	AC,")"
	PUSHJ	P,CHROUT
	MOVEI	AC," "
	PUSHJ	P,CHROUT
	MOVE	AC1,NUM
	POPJ	P,

	X.M==	(1B0)		; write code to term/tout
	X.S==	(1B1)		; contact software support

LUDAMS:	[ASCIZ	/Undefined error./]
	[ASCIZ	/Entry Completed./]
	[ASCIZ	/Entry already entered./]
	[ASCIZ	/Entry Not Found./]
	[ASCIZ	/Illegal Date Entered./] ; 4
	[ASCIZ	/X22 Access Error./] ;5
	[ASCIZ	/Disk Error./] ;6
	[ASCIZ	/Illegal Host Entered./] ; 7
	[ASCIZ	/Error in Dul./] ; 8 (10)
	[ASCIZ	/Customer Number Not Found./] ; 9 (11)
	[ASCIZ	/Error in Billing File./] ; 10 (12)
	[ASCIZ	/Table Overflow./] ; 11 (13)
	X.M,,[ASCIZ	/File Busy./] ; 12
	X.M,,[ASCIZ	/Illegal Value Entered./] ;13
	X.M,,[ASCIZ	/Error Deleting Files or UFD./] ; 14
	X.M,,[ASCIZ	/Undefined error./] ; 15
	X.M,,[ASCIZ	/Illegal Code Entered./] ; 16
	X.M,,[ASCIZ	/Undefined error./] ; 17
	X.M,,[ASCIZ	/Lookup or Enter error./] ; 18
	X.M,,[ASCIZ	/Input or Output error./] ; 19
	X.M,,[ASCIZ	/Init error./] ;20
	X.M,,[ASCIZ	/Illegal User for this Command./] ; 21
	X.M,,[ASCIZ	/Illegal Gan or Uun./] ; 22
	X.M,,[ASCIZ	/Duplicate Entries Found./] ; 23
	X.M,,[ASCIZ	/User Should be Cancelled./] ; 24
	X.M,,[ASCIZ	/No Address for this Customer./] ; 25
	X.M,,[ASCIZ	/Undefined Error./] ;26
	X.M,,[ASCIZ	/This Command may only be executed on Acctg Sys./] ;27
	X.M,,[ASCIZ	/User is on Tymcom-9 and may not chg cid./] ; 28
	X.M,,[ASCIZ	/Uun-Host is Allready There./] ; 29
	X.M,,[ASCIZ	/Uun-Host Not Found./] ; 30
	X.M,,[ASCIZ	/Undefined error./] ; 31
	X.M,,[ASCIZ	/Host in Tymconv Not Found./] ; 32
	X.M,,[ASCIZ	/Host Allready in Tymcnv Not Found./] ; 33
	X.M,,[ASCIZ	/Request Cannot be Cancelled Now./] ; 34
	X.M,,[ASCIZ	/Illegal Request Type./] ; 35
	X.M,,[ASCIZ	/Mail Name may not be Cancelled Now./] ; 36
	X.M,,[ASCIZ	/Undefined Error./]
	X.M,,[ASCIZ	/Undefined Error./] ; 38
	X.M,,[ASCIZ	/Undefined Error./] ; 39
	X.M,,[ASCIZ	/Undefined Error./] ; 40
	X.M,,[ASCIZ	/Undefined Error./] ; 41
	X.M,,[ASCIZ	/Undefined Error./] ; 42
	X.M,,[ASCIZ	/Undefined Error./] ; 43
	X.M,,[ASCIZ	/Undefined Error./] ; 44
	X.M,,[ASCIZ	/Undefined Error./] ; 45
	X.M,,[ASCIZ	/Undefined Error./] ; 46
	X.M,,[ASCIZ	/Undefined Error./] ; 47
	X.M,,[ASCIZ	/Undefined Error./] ; 48
	X.M,,[ASCIZ	/Undefined Error./] ; 49
	X.M,,[ASCIZ	/Undefined Error./] ; 50
	X.M,,[ASCIZ	/Undefined Error./] ; 51
	X.M,,[ASCIZ	/Undefined Error./] ; 52
	X.M,,[ASCIZ	/Undefined Error./] ; 53
	X.M,,[ASCIZ	/Undefined Error./] ; 54
	X.M,,[ASCIZ	/Undefined Error./] ; 55
	X.M,,[ASCIZ	/Undefined Error./] ; 56
	X.M,,[ASCIZ	/Undefined Error./] ; 57
	X.M,,[ASCIZ	/Undefined Error./] ; 58
	X.M,,[ASCIZ	/Undefined Error./] ; 59
	X.M,,[ASCIZ	/Undefined Error./] ; 60
	X.M,,[ASCIZ	/Undefined Error./] ; 61
	X.M,,[ASCIZ	/Undefined Error./] ; 62
	X.M,,[ASCIZ	/Require 1 or more Mdsk allocation count./] ; 63
	X.M,,[ASCIZ	/Error Appending to userdef tracking file./] ; 64
	X.M,,[ASCIZ	/Device is not an Mdisk/] ; 65
	X.M,,[ASCIZ	/Device cannot be moved or deleted./] ; 66
	X.M,,[ASCIZ	/Undefined Error./] ; 67
	X.M,,[ASCIZ	/Code is not a 1point mail command./] ; 68
	X.M,,[ASCIZ	/Error writing file USERDEF COMMANDS./] ; 69
	X.M,,[ASCIZ	/Error getting number of CMS blocks./] ; 70
	X.M,,[ASCIZ	/Undefined Error./] ; 71
	X.M,,[ASCIZ	/Undefined Error./] ; 72
	X.M,,[ASCIZ	/Undefined Error./] ; 73
	X.M,,[ASCIZ	/Undefined Error./] ; 74
	X.M,,[ASCIZ	/Undefined Error./] ; 75
	X.M,,[ASCIZ	/Undefined Error./] ; 76
	X.M,,[ASCIZ	/Undefined Error./] ; 77
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 78
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 79
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 80
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 81
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 82
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 83
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 84
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 85
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 86
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 87
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 88
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 89
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 90
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 91
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 92
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 93
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 94
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 95
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 96
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 97
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 98
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 99
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 100
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 101
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 102
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 103
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 104
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 105
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 106
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 107
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 108
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 109
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 110
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 111
	X.M,,[ASCIZ	/Mdisk has Fixed option./] ; 112
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 113
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 114
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 115
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 116
	X.M,,[ASCIZ	/Invalid Character in Password./] ; 117
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 118
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 119
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 120
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 121
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 122
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 123
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 124
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 125
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 126
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 127
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 128
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 129
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 130
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 131
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 132
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 133
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 134
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 135
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 136
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 137
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 138
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 139
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 140
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 141
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 142
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 143
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 144
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 145
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 146
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 147
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 148
	X.M,,[ASCIZ	/Out of Mdisk Allocation Space./] ; 149
	X.M,,[ASCIZ	/Priority to Set User is Invalid./] ; 150
	X.M,,[ASCIZ	/Invalid Mdisk Password./] ; 151
	X.M,,[ASCIZ	/Code is not a 1point change command./] ; 152
	X.M,,[ASCIZ	/Data Passed is Invalid./] ; 153
	X.M,,[ASCIZ	/Error writing to Fileback Devchg./] ; 154
	X.M,,[ASCIZ	/Code is not a 1point RDUSR command./] ; 155
	X.M,,[ASCIZ	/Data Passed is Invalid./] ; 156
	X.M,,[ASCIZ	/Device is not a Spool Device Type./] ; 157
	X.M,,[ASCIZ	/Cannot change Format of Mdisk./] ; 158
	X.M,,[ASCIZ	/Error getting Mdisk Format./] ; 159
	X.M,,[ASCIZ	/Error creating file CODE24 DATA./] ; 160
	X.M,,[ASCIZ	/Invalid RDUSR output./] ; 161
	X.M,,[ASCIZ	/User has class C and cannot be moved./] ; 162
	X.M,,[ASCIZ	/User has invalid options cannot be moved./] ;163
	X.M,,[ASCIZ	/Console device type invalid./] ; 164
	X.M,,[ASCIZ	/Special Card Invalid./] ; 165
	X.M,,[ASCIZ	/Link mode MW and MWV./] ; 166
	X.M,,[ASCIZ	/Mdisk password MWP - user not moved./] ; 167
	X.M,,[ASCIZ	/Code not 1POINT other command./] ; 168
	X.M,,[ASCIZ	/Spool dev type invalid./] ; 169
	X.M,,[ASCIZ	/Error writing Mail Address./] ; 170
	X.M,,[ASCIZ	/Error accessing user's Mdisk./] ; 171
	X.M,,[ASCIZ	/Mail Address file cannot be created./] ; 172
	X.M,,[ASCIZ	/Mdisk label not CMS - user cannot be moved./] ; 173
	X.M,,[ASCIZ	/Can't move a user having multiple read psw./] ; 174
	X.M,,[ASCIZ	/Licenses invalid - user cannot be moved./] ; 175
	X.M,,[ASCIZ	/Code is not a 1POINT add command./] ; 176
	X.M,,[ASCIZ	/Data passed is Invalid./] ; 177
	X.M,,[ASCIZ	/Mdisk mode MW and MWV./] ; 178
	X.M,,[ASCIZ	/Error writing the Mail Address File./] ; 179
	X.M,,[ASCIZ	/The Change cmd for Password failed./] ; 180
	X.M,,[ASCIZ	/The Change cmd for license failed./] ; 181
	X.M,,[ASCIZ	/The Change cmd for maxcore failed./] ; 182
	X.M,,[ASCIZ	/Default core less than 320k./] ; 183
	X.M,,[ASCIZ	/Read or syntax error./] ; 184
	X.M,,[ASCIZ	/Read or snytax error./] ; 185
	X.M,,[ASCIZ	/Code 2 failed after the basic add cmd./] ; 186
	X.M,,[ASCIZ	/Not enough space left on the pack./]  ; 187
	X.M,,[ASCIZ	/Error in reading file: setm map./] ; 188
	X.M,,[ASCIZ	/Cannot specify 0 cylinder./] ; 189
	X.M,,[ASCIZ	/x./] ; 190
	X.M,,[ASCIZ	/Cynlinder excess upper limit./] ; 191
	X.M,,[ASCIZ	/Cynlinder overlap in dir./] ; 192
	X.M,,[ASCIZ	/Invalid userdef parameter./] ; 193
	X.M,,[ASCIZ	/File alloc data not found./] ; 194
	X.M,,[ASCIZ	/Pack label cannot contain blank./] ; 195
	X.M,,[ASCIZ	/Bad file or permanent disk error./] ; 196
	X.M,,[ASCIZ	/Too many mdisks deleted by userdef./] ; 197
	X.M,,[ASCIZ	/Delete device free format failed./] ; 198
	X.M,,[ASCIZ	/System is out of mdisk alloc. space./] ; 199
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 200
	X.M,,[ASCIZ	/Error in reading cylm map./] ; 201
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 202
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 203
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 204
	X.M,,[ASCIZ	/Userdef Internal Error./] ; 205
	X.M,,[ASCIZ	/Label not found in cylm map./] ; 206
	X.M,,[ASCIZ	/Access error./] ; 207
	X.M,,[ASCIZ	/Format command failed./] ; 208
	X.M,,[ASCIZ	/Release error./] ; 209
	X.M,,[ASCIZ	/Detach error./] ; 210
	X.M,,[ASCIZ	/Failed in copying file to new mdisk./] ; 211
	X.M,,[ASCIZ	/Halt type command failed./] ; 212
	X.M,,[ASCIZ	/Mdisk is in use./] ; 213
	X.M,,[ASCIZ	/User's files not fit on new mdisk./] ; 214
	X.M,,[ASCIZ	/x./] ; 215
	X.M,,[ASCIZ	/1POINT Internal Error./] ; 216
	X.M,,[ASCIZ	/1POINT Internal Error./] ; 217
	X.M,,[ASCIZ	/1POINT Internal Error./] ; 218
	X.M,,[ASCIZ	/1POINT Internal Error./] ; 219
	X.M,,[ASCIZ	/1POINT Internal Error./] ; 220
	X.M,,[ASCIZ	/1POINT Internal Error./] ; 221
	X.M,,[ASCIZ	/1POINT Internal Error./] ; 222
	X.M,,[ASCIZ	/1POINT Internal Error./] ; 223
	X.M,,[ASCIZ	/1POINT Internal Error./] ; 224
	X.M,,[ASCIZ	/Invalid 1POINT lud code./] ; 225
	X.M,,[ASCIZ	/1POINT Internal Error./] ; 226
	X.M,,[ASCIZ	/Code 23 rename failed./] ; 227
	X.M,,[ASCIZ	/Write error in building file./] ; 228
	X.M,,[ASCIZ	/Invalid license change for this user./] ; 229
	X.M,,[ASCIZ	/Read error file./] ; 230
	X.M,,[ASCIZ	/x./] ; 231
	X.M,,[ASCIZ	/File not found./] ; 232
	X.M,,[ASCIZ	/Invalid record found in file./] ; 233
	X.M,,[ASCIZ	/Read error file./] ; 234
	X.M,,[ASCIZ	/Pack not mounted./] ; 235
	X.M,,[ASCIZ	/Standard pack is not mounted./] ; 236
	X.M,,[ASCIZ	/No mail address./] ; 237
	X.M,,[ASCIZ	/x./] ; 238
	X.M,,[ASCIZ	/x./] ; 239
	X.M,,[ASCIZ	/Code is not 1POINT delete cmd./] ; 240
	X.M,,[ASCIZ	/Erro in writing to device change file./] ; 241
	X.M,,[ASCIZ	/Invalid gan./] ; 242
	X.M,,[ASCIZ	/This username cannot be changed or deleted./] ; 243
	X.M,,[ASCIZ	/x./] ; 244
	X.M,,[ASCIZ	/x./] ; 245
	X.M,,[ASCIZ	/x./] ; 246
	X.M,,[ASCIZ	/x./] ; 247
	X.M,,[ASCIZ	/Invalid return code./] ; 248
	X.M,,[ASCIZ	/Device address already entered./] ; 249
	X.M,,[ASCIZ	/Device address not found./] ; 250
	X.M,,[ASCIZ	/read error in verifying device address./] ; 251
	X.M,,[ASCIZ	/The set pack group label entered is invalid./] ; 252
LUDALN==.-LUDAMS

GETODF: ; get list output destination and channel if it's a file
        TRZ     FLG,U.LFO       ; turn off bit
        INSTR   ([ASCIZ /Output to : /],FILIN,25,T)
        MOVE    AC,FILIN        ; look at the first word
        CAME    AC,[ASCII/T    /]       ; skip if it's a T
         CAMN   AC,[ASCII/     /]       ; skip if it's not a blank
         SKIPA
         SKIPA
         POPJ   P,      ; a space or T means do list output to TOUT/terminal
        MOVEI   AP,ODFARG       ; if not then it's a filename, parse it
        PUSHJ   P,FNPAR
        JUMPGE  AC,ODFERR       ; error during parse
        SETZM   ODFBLK          ; prepare open block
        HRLZI   AC,ODFBUF
        MOVEM   AC,ODFBLK+2
        MOVE    AC,ODFDEV       ; get the device
        MOVEM   AC,ODFBLK+1     ; move it into open block
        MOVE    AC,[.CHOPN,,ODFCHN]
        CHANIO  AC,ODFBLK       ; do open
         JRST   ODFER1
        MOVE    AC,[.CHLK,,ODFCHN]
        CHANIO  ODFLK
         PUSHJ  P,NEWFIL
        PUSHJ   P,OLDFIL
        GETYR   ([ASCIZ /- ok ?/])
         JRST   GETODF
        MOVE    AC,SAVLIC       ; get our license word
        HRLS    AC              ; make proc lic = frame lic
        SETLIC  AC,
        MOVE    AC,[.CHENT,,ODFCHN]
        CHANIO  AC,ODFLK        ; enter it
         JRST   ODFER2
        MOVE    AC,SAVLIC       ; restore our proc lic
        SETLIC  AC,
        PUSHJ   P,CHKLIC        ; make sure it's there
        TRO     FLG,U.LFO       ; set flag indicating file list output
        POPJ    P,

ODFERR: TYPSTR  ([ASCIZ/Error parsing filename/])
        PUSHJ   P,INORNO
        JRST    GETODF

ODFER1:
        TYPSTR  ([ASCIZ/Channel open failed/])
        PUSHJ   P,INORNO
        JRST    GETODF
ODFER2:
        TYPSTR  ([ASCIZ/Enter failed/])
        PUSHJ   P,INORNO
        JRST    GETODF

NEWFIL: ; confirm new file
        TYPSTR  ([ASCIZ/New file/],777,0,0,N)
        AOS     0(P)            ; skip over oldfil routine
        POPJ    P,

OLDFIL:
        HRLI    AC,.CHCLS       ; close the file
        CHANIO  AC,
        TYPSTR  ([ASCIZ/Old File/],777,0,0,N)
        POPJ    P,

YORN:   ; get yes or no, null line means yes
        INSTR   (NONE,YORNSP,1,T)
        MOVE    AC,YORNSP
        CAME    AC,[ASCII/Y    /]
         CAMN   AC,[ASCII/     /]
         SKIPA
         JRST   YORN2
        AOS     0(P)
        POPJ    P,
YORN2:  CAME    AC,[ASCII/N    /]
         JRST   YORN3
        POPJ    P,
YORN3:  PUSHJ   P,INORNO
        TYPSTR  (@LASPRM,777,0,0,N)
        JRST    YORN

ODFOUT: ; output a string to the list output file
; AC / address of string to output to list file
; ac1 / max chars to output
        MOVEM   AC,SAC          ; save the address
        PUSHJ   P,CNTCHR        ; find actual size
        MOVE    AC,SAC          ; get address back
        HRLI    AC,(POINT 7)    ; make a byte pointer
        MOVE    AC4,AC1         ; size to ac4
ODFOU2: ILDB    AC1,AC          ; load a char
        SOSG    ODFCNT          ; skip if room left in current buffer
         PUSHJ  P,NODFBF        ; else get a new buffer
        IDPB    AC1,ODFBP       ; deposit it
        SOJG    AC4,ODFOU2      ; get next char
        MOVEI   AC1,.CR         ; add a carriage return line feed sequence
        SOSG    ODFCNT
         PUSHJ  P,NODFBF
        IDPB    AC1,ODFBP
        MOVEI   AC1,.LF
        SOSG    ODFCNT
         PUSHJ  P,NODFBF
        IDPB    AC1,ODFBP
        POPJ    P,              ; and return

NODFBF: ; here to flush output to list file
        MOVE    AC3,[.CHOUT,,ODFCHN]    ; ready for OUT uuo
        CHANIO  AC3,                    ; do it
        JRST    NODFB2          ; ok return
         PUSHJ  P,ERRODF        ; error return
NODFB2: POPJ    P,

ERRODF: ; error writing to list output file
        TRZ     FLG,U.LFO       ; reset output flag
        TYPSTR  ([ASCIZ/Error during LIST output- status word:/],777,0,0,N)
        MOVE    AC4,[POINT 7,SAC]        ; deposit last char here
        MOVEM   AC4,ODFBP
        SETZ    AC4,
        MOVE    AC3,[.CHGS,,ODFCHN]     ; get status word
        CHANIO  AC3,SAC
        TYPNUM  (SAC,O,1)               ; output it
        PUSHJ   P,CLSODF                ; release the channel
        POPJ    P,

CLSODF: ; release list output file channel
        MOVE    AC3,[.CHREL,,ODFCHN]
        CHANIO  AC3,
        POPJ    P,

UNSA:   ; convert sixbit username to ascii
        SETZM   MY.UNM
        SETZM   MY.UNM+1
        SETZM   MY.UNM+2
        MOVE    AC,[POINT 6,SIXUNM]
        MOVE    AC1,[POINT 7,MY.UNM]
        MOVEI   AC4,L.UNM
UNSA1:  ILDB    AC3,AC
        JUMPE   AC3,UNSA2
        ADDI    AC3,BLNK
        IDPB    AC3,AC1
        SOJG    AC4,UNSA1
UNSA2:  POPJ    P,

STDUHD:	; standard entries for tattle tale file for user type transactions.
	PUSHJ	P,STDHDR
	TTFSTR	([ASCIZ/Username :/],777,N)
	TTFSTR	(UNMSPC,L.UNM)
	POPJ	P,
ST1UHD:	; standard entries for tattle tale file for user type transactions.
        ; for the user whose username's address is NNMSPC
	PUSHJ	P,STDHDR
	TTFSTR	([ASCIZ/Username :/],777,N)
	TTFSTR	(NNMSPC,L.UNM)
	POPJ	P,
STDCHD:	; standard entries for tattle tale file for customer type trans.
	PUSHJ	P,STDHDR
	TTFSTR	([ASCIZ/Customer :/],777,N)
	TTFNUM	(CUSNUM,D)
	POPJ	P,
STDGHD:	; standard entries for tattle tale file for gan type trans.
	PUSHJ	P,STDHDR
	TTFSTR	([ASCIZ/Gan :/],777,N)
	TTFNUM	(NMGAN,O)
	POPJ	P,
STDHDR:	; standard header
	TTFSTR	([ASCIZ/Logged :/],777,N)
	TTFSTR	(MY.UNM,L.UNM)
	MOVE	AC,TATALE	; see if status name present
	JUMPE	AC,STDHD1
	CAMN	AC,[ASCII/     /]
	 JRST	STDHD1
	TTFSTR	([ASCIZ/Status :/],777,N)
	TTFSTR	(TATALE,L.UNM)
STDHD1:
	TLNN	FLG2,V.PRQ	; skip if processing a request
	 JRST	STDHDD
	MOVE	AC,SRAAPP
	CAMN	AC,[ASCII/     /] ; skip if not blank
	 JRST	STDHD2
	TTFSTR	([ASCIZ/Approved :/],777,N)
	TTFSTR	(SRAAPP,L.UNM)
STDHD2:
	TTFSTR	([ASCIZ/Originator :/],777,N)
	TTFSTR	(RQSORG,L.UNM)
STDHDD:	POPJ	P,

SESCFL:	; here on escape interrupt
	TLNE	FLG2,V.INI	; skip if not doing input from init file.
	 DISMIS
	TLNE	FLG2,V.INP	; skip if not doing strin input
	 JRST	[MOVEI	AC,ESCABT
		 MOVEM	AC,TRPVEC+2
		 DISMIS]
	TLO	FLG2,V.ESC
	DISMIS
	HALT

ESCABT:	; here to abort after escape seen
	TLNN	FLG,U.IND		; skip if coming from com file
	 CLRBFI
	TLZ	FLG2,V.INP
	TYPSTR	([ASCIZ/^/])
	JRST	GETCMD


INPDT:	; input a date from terminal
	MOVEI	AC,DATSPC		; count the chars
	MOVEI	AC1,^D14		; max chars
	PUSHJ	P,CNTCHR
	CAIL	AC1,6		; min size
	CAILE	AC1,^D10	; max size
	 JRST	INPDTE
	SETZM	MONSPC		; set individual fields to zeros
	SETZM	YRSPC
	SETZM	DAYSPC
	MOVE	AC1,[POINT 7,DATSPC]	; pointer to string
	MOVEI	AC2,MONSPC		; address of month space
	MOVEI	AC3,2			; max length of month field
INPDT1:	PUSHJ	P,INPDN			; isolate the month
	MOVEI	AC2,DAYSPC		; pointer to day field
	MOVEI	AC3,2			; max length of day field
	PUSHJ	P,INPDN			; isolate day field
	MOVEI	AC2,YRSPC		; pointer to year field
	MOVEI	AC3,4			; max length of year field
	PUSHJ	P,INPDN			; isolate year.
	MOVE	AC,YRSPC
	IDIVI	AC,^D100		; isolate 2 digit year in ac+1
	MOVE	AC,AC1
	IMULI	AC,^D10000
	MOVE	AC1,MONSPC
	JUMPE	AC1,INPDTE
	CAILE	AC1,^D12
	 JRST	INPDTE			; illegal month
	IMULI	AC1,^D100
	ADD	AC,AC1
	MOVEM	AC,DATSPC
	MOVE	AC,DAYSPC
	CAILE	AC,^D31
	 JRST	AC,INPDTE		; illegal day
	JUMPE	AC,INPDTE
	ADDM	AC,DATSPC
	AOS	0(P)
	POPJ	P,

INPDN:	; isolate a field in date string
	MOVE	AC4,AC3			; save length for later compare
INPDN1:	ILDB	AC,AC1			; get a char.
	CAIN	AC," "			; skip if not a space
	 JRST	INPDND			; done
	JUMPE	AC,INPDND		; jump to done if null
	CAIN	AC,"/"			; skip if not a slash
	 JRST	INPDND
	CAIN	AC,"-"			; skip if not a dash
	 JRST	INPDND
	CAIL	AC,"0"			; skip if less then char zero
	CAILE	AC,"9"			; skip if less then or eq to char 9
	 JRST	INPDTE
; now add the digit into the proper field (binary integer format).
	MOVE	ACX,0(AC2)
	IMULI	ACX,^D10		; left shift one digit.
	SUBI	AC,"0"
	ADD	ACX,AC
	MOVEM	ACX,0(AC2)
; do next char, if not overflowing field size.
	SOJGE	AC3,INPDN1
	JRST	INPDTE			; error.
INPDND:	CAMN	AC3,AC4			; skip if field is not null.
	 JRST	INPDTE
	POPJ	P,

INPDTE:	; error getting a date
	TYPSTR	([ASCIZ/Date must be in ZM-ZY-YY format./],777,0,0,Y,Y)
	POPJ	P,
PASGRD:	; input pasgan.exm
	HRLOI	AC,.CHOPN	; prepare to open next channel
	CHANIO	AC,PASGOP	; open
	 JRST	PASGRD
	SETOM	PASGBU		; set 1st wd of pasgan.exm buffer to -1
	HRLI	AC,.CHLK	; prepare to lookup pasgan.exm
	CHANIO	AC,PASGLK	; lookup
	 JRST	PASGR1		; not found
	HRRZ	AC1,PASGLK+.RBLIC ; get file license halfword
	TRNN	AC1,(LC.WC)	; skip if write core license is set
	 BOMB	(ERR.PG)	; exit
	HRLI	AC,.CHIN	; prepare to input buffer
	CHANIO	AC,PASGCM
	 BOMB	(ERR.PG)
PASGR1:
	HRLI	AC,.CHREL	; prepare to release channel
	CHANIO	AC,
	POPJ	P,		; return

PASGEX:	; skip return if gan in ac is exempt from password stds
	; destroys ac1
	JUMPE	AC,PASGX2	; if supplied gan is 0, non-skip return.
	HRLZI	AC1,-PASGSI	; for aobjn
PASGX1:
	SKIPGE	PASGBU(AC1)	; skip if entry in pasgbu is >= 0
	 JRST	PASGX2
	CAMN	AC,PASGBU(AC1)	 ;skip if ac and entry are not equal
	 JRST	PASGX3
	AOBJN	AC1,PASGX1
PASGX2:	; here when no match found
	POPJ	P,
PASGX3:	; here when a match is found
	AOS	0(P)
	POPJ	P,
 
 
 
 
 
KLSOUT: ; get class info and set flag if home host is 88
        SETZM   CLSCTR          ; zero counter
KLSOU2: ; major loop for outputting class info
        MOVE    AC1,CLSCTR      ; compute new pointer
        IMULI   AC1,NMSZCS
        ADDI    AC1,NMCLSS
        SKIPN   0(AC1)          ; check if we're done
         JRST   KLSOUD          ; done
        MOVEM   AC1,CLSIND      ; save it
        AOS     CLSCTR          ; increment position counter
        MOVE    AC,@CLSIND
        MOVEM   AC,GRPCTR       ; save # of groups in position
KLSWOT:	; we xfer here to display one class only, not numbered.
        AOS     CLSIND
        MOVE    AC,@CLSIND      ; get class number in ac
        TRZ     FLG,U.UDF
        TRZE    AC,UDF.CD       ; skip if not self-defining
         JRST   KLSO2C
        JRST    KLSO2B
KLSO2C: TRZ     AC,UDN.CD       ; zero negative class bit
        IDIVI   AC,2            ; change byte to word cnt
        MOVEM   AC,CLSCT2       ; save it
        MOVE    AC,@CLSIND
        TRNN    AC,UDN.CD       ; skip if negative class
         JRST   KLSO2D
KLSO2D:
        TRO     FLG,U.UDF
KLSO2B: SOSGE   GRPCTR          ; skip if hosts or groups left
         JRST   KLSOU2
        AOS     CLSIND
        MOVE    AC,@CLSIND      ; get a host or group word
        TRZN    AC,GRP.CD       ; skip if it is a group
         JRST   KLSOU3
        TRZE    AC,HOM.CD       ; skip if it's not a home
         TRO    FLG,U.HOM       ;  set home bit
        MOVEM   AC,NUM
        JRST    KLSOU4
KLSOU3: TRNN    FLG,U.UDF       ; skip if this is a self defining class
         JRST   KLSO3B
        SOSGE   CLSCT2
         JRST   KLSO3B
        TRZE    AC,HOS.CD
         JRST   KLSO3C
        MOVEM   AC,NUM
        JRST    KLSOU5
KLSO3B:
        MOVE    AC,@CLSIND
        TRZE    AC,HOM.CD       ; check if this is home system
         JRST   [CAIE    AC,^D88      ; if home host, ask if it is 88
                  JRST   KLSO3C
                 MOVEM   AC,FLG88
                 JRST    KLSO3C]
KLSO3C: MOVEM   AC,NUM
KLSOU4: TRZN    FLG,U.HOM
         JRST   KLSOU5
KLSOU5: 
        TRNN    FLG,U.UDF       ; skip if self defining class
         JRST   KLSO2B
        SKIPE   CLSCT2          ; skip if just exhausted orig nodes
         JRST   KLSO2B
        SETOM   CLSCT2
        JRST    KLSO2B  ; go do next host or group
KLSOUD: 
        POPJ    P,      ; all done

CKHST1: ; check gan or user being valid on the input host
        SETZM   UAHSTC
HSTLOP: MOVE    AC1,UAHSTC
        MOVE    AC1,UAHST(AC1)
        CAMLE   AC1,LUDNUM
         JRST   [TYPSTR  ([ASCIZ/User is not valid on the host./])
                 POPJ    P,]
        CAME    AC1,LUDNUM
         JRST   [AOS     UAHSTC
                 JRST    HSTLOP]
        AOS     0(P)
        POPJ    P,
 

; get customer accounting record, skip return if found, popj p if error
GCAREK: SNDBYT  (ACTPRT,\B.ACOM,LCAACT,I)   ;send code 50 = list cus. acct.
        SNDBYT  (AC,\B.CID,CUSNUM)          ;send 3 byte c.i.d. to acct.
        SNDBYT  (AC,\B.ASY,ACTSY2)          ;send 1 byte sys.type to acct.
        PUSHJ   P,AGANS
         POPJ   P,                    ; return to calling program if error
        GETSTR  (AC,L.CUSN,ACCNAM)       ;cus. name from acctg.
        GETBYT  (AC,\B.DIS)              ;cus. dist. to ACCDIS
         JRST   GETCMD
        MOVEM   AC1,ACCDIS
	GETBYT  (AC,\B.CC)
	 JRST	GETCMD
	MOVEM	AC1,ACCCC
        GETBYT  (AC,\B.DET)              ;detail code to ACDETC
         JRST   GETCMD
        MOVEM   AC1,ACDETC
        GETBYT  (AC,\B.INV)              ;invoice code to ACINVC
         JRST   GETCMD
        MOVEM   AC1,ACINVC
        GETBYT  (AC,\B.MIN)              ;min. code to ACMINC
         JRST   GETCMD
        MOVEM   AC1,ACMINC
        GETBYT  (AC,\B.SLS)              ;salesman code to ACSLS
         JRST   GETCMD
        MOVEM   AC1,ACSLS
        GETSTR  (AC,L.PO,ACPONM)         ;po number to ACPONM
        GETBYT  (AC,\B.POMX)             ;pomax to ACPOMX
         JRST   GETCMD
        MOVEM   AC1,ACPOMX
        GETBYT  (AC,\B.PODT)             ;po start date to ACPSDM->(ACPSDM+2)
         JRST   GETCMD
        MOVEM   AC1,ACPSDT
        MOVE    AC,AC1
        MOVEI   AP,ACPSDM
        PUSHJ   P,CNVDT
        GETBYT  (ACTPRT,\B.PODT)         ;po end date to ACPEDM->(ACPEDM+2)
         JRST   GETCMD
        MOVEM   AC1,ACPEDT
        MOVE    AC,AC1
        MOVEI   AP,ACPEDM
        PUSHJ   P,CNVDT
        GETBYT  (ACTPRT,\B.VPRI)         ;variable pricing flag to ACVPF
         JRST   GETCMD
        MOVEM   AC1,ACVPF
        GETBYT  (AC,\B.PRI)              ;default pricing to ACDEFP
         JRST   GETCMD
        MOVEM   AC1,ACDEFP
	GETBYT	(AC,\B.FOCF)
	 JRST	GETCMD
	MOVEM	AC1,ACFOCF
        GETBYT  (AC,\B.PODT)            ;get anniversary date
         JRST   GETCMD
        GETSTR  (AC,L.STRE,ACSTR1)      ;get street1
        GETSTR  (AC,L.STRE,ACSTR2)      ;get street2
        GETSTR  (AC,L.STRE,ACEXLN)      ;get extra line
        GETSTR  (AC,L.CITY,ACCITY)      ;get city
        GETSTR  (AC,L.STAT,ACSTAT)      ;get state
        GETSTR  (AC,L.ZIP,ACZIP)        ;get zip code
        GETSTR  (AC,L.CTRY,ACCTRY)      ;get country
        GETSTR  (AC,L.ATTN,ACATTN)      ;get attention line
        AOS     0(P)
        POPJ    P,
 
 
GUAREK: ; get user acctg record, return if error, skip return if found
        SNDBYT  (ACTPRT,\B.ACOM,LUEACT,I) ; send the command
        SNDBYT  (AC,\B.UUN,NMUUN)       ; and the uun
        SNDBYT  (ACTPRT,\B.ACOM,ACTSY2) ; actg sys type
        PUSHJ   P,AGANS
         POPJ   P,
        GETBYT  (AC,\B.GAN)     ; input the gan
         JRST   GETCMD
        MOVEM   AC1,UAGAN
        PUSHJ   P,GNAMAC        ; get username
        GETBYT  (AC,\B.DIS)     ; input district
         JRST   GETCMD
        MOVEM   AC1,UADIS
        GETBYT  (AC,\B.CID)     ; get cid
         JRST   GETCMD
        MOVEM   AC1,UACID
        PUSHJ   P,GCNAAC        ; input customer name
	GETBYT  (AC,\B.CC)
	 JRST	GETCMD
	MOVEM	AC1,UACC
        GETBYT  (AC,\B.SLS)     ; input salesman
         JRST   GETCMD
        MOVEM   AC1,UASLS
        GETBYT  (AC,\B.PRI)     ; input pricing code
         JRST   GETCMD
        MOVEM   AC1,UAPRIC
        GETBYT  (AC,\B.RES)     ; input resource code
         JRST   GETCMD
        MOVEM   AC1,UARESC
        GETBYT  (AC,\B.CUR)     ; input currency code
         JRST   GETCMD
        MOVEM   AC1,UACURC
        GETBYT  (AC,\B.LAN)     ; input language code
         JRST   GETCMD
        MOVEM   AC1,UALANC
        GETBYT  (AC,\B.TZ)      ; input time zone
         JRST   GETCMD
        MOVEM   AC1,UATZ
        PUSHJ   P,GHSTAC        ; input hosts
        AOS     0(P)
        POPJ    P,
 
CHGUDI:
; this is a temporary command for change user's district in lud, cud and acctg.
 
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GETACC
         JRST   GETCMD
        PUSHJ   P,GETMON
        PUSHJ   P,GEDIST
LOOPG8: TCR     (1)
        PUSHJ   P,GETUNM
         JRST   [TYPSTR  ([ASCIZ/Done./])
                 JRST    GETCMD]
        PUSHJ   P,GCREC
         JRST   GETCMD
        PUSHJ   P,CDISMD
         JRST   GETCMD
        PUSHJ   P,CDISLD
         JRST   GETCMD
        SNDBYT  (ACTPRT,\B.ACOM,CUDACT,I)
        SNDBYT  (AC,\B.UUN,NMUUN)
        SNDBYT  (AC,\B.DIS,DISRCT)
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Error in changing district in acctg./])
                 TYPSTR  ([ASCIZ/Username/],777,0,0,N)
                 TYPSTR  (UNMSPC,L.UNM,1,0)
                 MOVE    AC1,ACANS
                 PUSHJ   P,LUDAOT
                 JRST    GETCMD]
        JRST    LOOPG8
 
CHGLDI:
; this command is used to change user's district in the lud
 
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GETMO2
        PUSHJ   P,GEDIST
LOOPG9: TCR     (1)
        PUSHJ   P,GETUNM
         JRST   [TYPSTR  ([ASCIZ/Done./])
                 JRST    GETCMD]
        PUSHJ   P,CDISLD
         JRST   GETCMD
        JRST    LOOPG9
 
DIFDIS: ; this is a temporary setup for list usernames in the cud, when 
        ; if district not equal input district then print name and district
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GEDIST
LOPDIF: PUSHJ   P,GETUNM
         JRST   [TYPSTR  ([ASCIZ/Done/])
                JRST    GETCMD]
        PUSHJ   P,GCREC1
         JRST   LOPDIF
        MOVE    AC1,NMDIST
        CAMN    AC1,DISRCT
         JRST   LOPDIF
        MOVEI   AC,UNMSPC
        PUSHJ   P,NAMOUT
        MOVE    AC,NMDIST
        PUSHJ   P,DISOUT
        JRST    LOPDIF
 
; cancel names in the PDP-10 lud
 
DELLUD:
        PUSHJ   P,GETH10
LOOP10:
        TCR     (1)
        PUSHJ   P,GETUNM
         JRST   [TYPSTR   ([ASCIZ/Done./])
                 JRST    GETCMD]
        SNDBYT  (OLDPRT,\B.LCOM,REMLUD,I)
        SNDSTR  (AC,L.UNM,UNMSPC)
        PUSHJ   P,OLDA
         JRST   LOOP10
        GETBYT  (OLDPRT,\B.GAN)
         JRST   GETCMD
        GETBYT  (OLDPRT,\B.UUN)
         JRST   GETCMD
        JRST    LOOP10
 
; the following dummy statement is for loading USRVAL only, it should be
; changed to the comment statement when loading CHGPSW program!
X1234C:                             
        JFCL                          
 
 
CMDGET: ; get next customer number
        PUSHJ   P,GETACC
  ;     PUSHJ   P,GETCUD
         JRST   GETCMD
        SNDBYT  (ACTPRT,\B.ACOM,NIDACT,I)
  ;     PUSHJ   P,SND40
  ;     PUSHJ   P,NGANS
  ;      JRST   ERRCUD
        PUSHJ   P,AGANS
         JRST   CIDERR
        GETBYT  (ACTPRT,\B.CID)
         JRST   GETCMD
        MOVEM   AC1,CUSNUM
  ;     PUSHJ   P,GET40
        TCR     (1)
        TYPSTR  ([ASCIZ/****************** The Customer Number /],777,0,1,N)
        TYPSTR  ([ASCIZ/is /],777,1,0,N)
        TYPNUM  (CUSNUM,D,5)
        TCR     (1)
        JRST    GETCMD
 

CIDERR:
        TYPSTR  ([ASCIZ/Error in get cid./])
        JRST    GETCMD
 
 
CMDRSE: ; remove username without telling pj
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GETUNM
         JRST   GETCMD
        PUSHJ   P,GCREC1
         JRST   CMDRSE
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)
        PUSHJ   P,SNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   ERRCUD
        PUSHJ   P,NANOUT
        PUSHJ   P,GET40
        JRST    CMDRSE
PJ1:    
        PUSHJ   P,GETHOM
        PUSHJ   P,GETUNM
         JRST   GETCMD
        PUSHJ   P,GETNNM
        JRST    CHGLUD
 
 
; the following code is temporary for changing tru budget for a group of
; users on the same pdp-10 host.
LUDTRU:
        PUSHJ   P,GETH10
        PUSHJ   P,GETBUD
TRULOP:
        PUSHJ   P,GETUNM
         JRST   GETCMD
        SNDBYT  (OLDPRT,\B.LCOM,CTBLUD,I)
        SNDSTR  (AC,L.UNM,UNMSPC)
        SNDBYT  (AC,\B.BUD,LUXBUD)
        PUSHJ   P,OLDA
         JRST   TRUERR
        JRST    TRULOP
 
TRUERR:
        TYPSTR  ([ASCIZ/error!!!/])
        MOVE    AC1,OLDANS
        PUSHJ   P,LUDAOT
        JRST    TRULOP
 
 
; The follwoing code accept a decimal number from terminal then display
; the octal representation
 
 
OCTREP:
        INNUM   ([ASCIZ/Decimal Number :/],D)
         JRST   [PUSHJ   P,INORNO
                 JRST    GETCMD]
        MOVEM   AC1,NUM5
        CAIN    AC1,0
         JRST   GETCMD
        TYPNUM  (NUM5,O,0,T.P2)
        JRST    OCTREP
 
; check French validation usernames
 
CHKFRA:
        MOVE    AC,SIXUNM
        MOVE    AC1,[-FRANLN,,0]
FRALOP:
        CAMN    AC,FRANAM(AC1)
         JRST   FRANFD
        AOBJN   AC1,FRALOP
        POPJ    P,
 
FRANFD:
        TYPSTR  (FRAMSG)
   ;    TYPSTR  ([ASCIZ/Pls use appropriate internal validation program or/])
   ;    TYPSTR  ([ASCIZ/contact French Accounting Dept: (Ontym ID: CT.ACT)/])
        JRST    GETCMD
 
FRAMSG:  ASCIZ   -
Pls use appropriate internal validation program or contact French Accounting
Dept: (Ontyme ID: CT.ACT) -
 
FRANAM: SIXBIT/DIST30/
        SIXBIT/DIST33/
        SIXBIT/DIST39/
        SIXBIT/DIST71/
        SIXBIT/DIST72/
        SIXBIT/DIST73/
        SIXBIT/DIST74/
        SIXBIT/DIST75/
        SIXBIT/DIST76/
        SIXBIT/DIST77/
        SIXBIT/DIST78/
        SIXBIT/DIST79/
FRANLN==.-FRANAM
 
; check access of ACS districts, AC contains input district number, normal
; return if match, jump return if no match
 
CHKACS:
        MOVE    AC1,[-ACSLTH,,0]
ACSLOP:
        CAMN    AC,ACSDIS(AC1)
         POPJ   P,          ; match
        AOBJN   AC1,ACSLOP
        AOS     0(P)
        POPJ    P,
 
ACSDIS: ^D10
        ^D11
        ^D12
        ^D13
        ^D14
        ^D15
        ^D16
        ^D19
        ^D40
        ^D41
        ^D42
        ^D44
        ^D46
        ^D49
        ^D51
        ^D52
        ^D53
        ^D54
        ^D55
        ^D59
        ^D60
        ^D61
        ^D62
        ^D65
        ^D67
        ^D68
        ^D69
        ^D85
        ^D86
        ^D89
        ^D90
        ^D91
        ^D92
        ^D93
        ^D94
        ^D95
        ^D96
        ^D97
        ^D98
        ^D99
        ^D101
        ^D104
        ^D109
        ^D111
        ^D112
        ^D113
        ^D114
        ^D115
        ^D116
        ^D117
        ^D118
        ^D119
        ^D144
        ^D146
        ^D249
        ^D250
        ^D251
        ^D252
        ^D253
        ^D254
ACSLTH==.-ACSDIS
    XWK