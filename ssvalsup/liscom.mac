SUBTTL LISCOM - list type commands
 DEFINE LIS1 <
        X USER,1,CMDLUS,U.NET!U.PRV!U.DIS!U.CUS!U.ASV!U.AP,-1 ; list user
        X CUSTO,2,CMDLCS,U.NET!U.PRV!U.DIS!U.CUS!U.AP!U.ASV,-1  ; list customer
        X DISTR,1,CMDLDS,U.NET!U.PRV!U.DIS!U.AP!U.ASV,-1    ; list district
        X GAN,1,CMDLGS,U.NET!U.PRV!U.DIS!U.CUS!U.ASV!U.AP,-1    ; list gan
 ;      X INDUS,1,CMDLIN,U.PRV!U.DIS!U.AP,-1         ; list industry codes
        X COSTC,2,CMDLKS,U.NET!U.PRV!U.CUS!U.DIS!U.AP!U.ASV,-1  ; list costcode
 >

        SUBCOM ([ASCIZ /List :/],LIS,LIS1)
 DEFINE LUS1 <
        X INFOR,1,CMDLUI,U.PRV,-1   ; list user info
        X CUD,1,CMDLUC,-1,-1    ; list user cud
        X ACCOU,1,CMDLUA,-1,-1  ; list user accounting
        X LUD,1,CMDLUL,-1,-1    ; list user lud
	X PASSD,1,CMDLUP,U.PRV!U.NET,-1 ; list user passdate
	X MAIL,1,CMDLUM,U.PRV,-1  ; list (370) user mailing address
 >
        SUBCOM  ([ASCIZ/List User :/],LUS,LUS1)
        POPJ    P,
DEFINE  LCS1 <
        X ACCOU,1,CMDLCA,-1,-1          ; list customer accounting
        X NAMES,1,CMDLCN,-1,-1          ; list customer names
        X GANS,1,CMDLCG,-1,-1           ; list customer gans
        X HOSTS,1,CMDLCH,-1,-1          ; list customer hosts
        X TYMUS,1,CMDLCT,U.PRV,-1       ; list customer tymuse
>
        SUBCOM  ([ASCIZ/List Customer :/],LCS,LCS1)
        POPJ    P,
DEFINE LDS1 <
        X CUSTO,2,CMDLDC,-1,-1          ; list district customers
        X NAMES,1,CMDLDN,-1,-1          ; list district names
        X TYMUS,1,CMDLDT,-1,-1          ; list district tymuse
        X COSTC,2,CMDLDK,-1,-1          ;list district costcodes(kostcodes)
>
        SUBCOM  ([ASCIZ/List District :/],LDS,LDS1)
        POPJ    P,
DEFINE LGS1 <
        X NAMES,1,CMDLGN,-1,-1  ; list gan names
        X HOSTS,1,CMDLGH,-1,-1  ; list gan hosts
>

        SUBCOM  ([ASCIZ/List Gan :/],LGS,LGS1)

DEFINE LKS1 <
       X CUSTO,1,CMDLKC,-1,-1           ;list costcode customers
       X GANS,1,CMDLKG,-1,-1            ;list costcode gans
       X USERS,1,CMDLKU,-1,-1           ;list costcode users
>
       SUBCOM ([ASCIZ/List Costcode :/],LKS,LKS1)


;     LIST COSTCODE CUSTOMERS
;     _______________________
;
; This command will list all the customer numbers, corresponding     *
; customer names, and system types for a given costcode. If you      *
; type a <cr> when prompted for a costcode, you will return to       *
; the command level.                                                 *
;
; '%' indicates programmer-defined macro.                            *
;
;*********************************************************************


CMDLKC: ;list costcode(kostcode) customers
        PUSHJ   P,LTT                   ;  write an entry in tattle tale file
        TCR     (1)                     ;% type crlf
        PUSHJ   P,GETACC                ;  get acctg circuit
         JRST   GETCMD                  ;  command aborted, no circuit built
        PUSHJ   P,GETODF                ;  get output direction
        TRO     FLG,U.OST               ;  set output stype flag
        GETYR   ([ASCIZ/Output system type ?/]) ;% get y/n, skip return if yes
         TRZ    FLG,U.OST               ;  set it off
        TRO     FLG,U.OCN               ;  set output cusnam flag
        GETYR   ([ASCIZ/Output customer name ?/]) ;% get y/n, skip return if yes
         TRZ    FLG,U.OCN               ;  unset it
        SETOM   LASCUS                  ;  set control break field
; *note: control break on cusnum if system type field is not output only
        SETFM   (L.CID)                 ;% field size for cid
    
CMLKC2: TCR     (1)                     ;% type crlf
        PUSHJ   P,GETCC                 ;  input costcode
         JRST   CMLKCD                  ;  all done
        PUSHJ   P,CHKCC                 ;  check costcode
         JRST   CMLKC2                  ;  try again
        PUSHJ   P,GKCREC                ;  input and display data
     
      
CMLKCD: ;all done
        TRNE    FLG,U.LFO               ;  skip if not output to list file
        PUSHJ   P,CLSODF                ;  close list file
        TRO     FLG,U.OKAY              ;  set OK flag
        POPJ    P,                      ;  return
       
GKCREC: ;get costcode customers records
        SNDBYT  (ACTPRT,\B.ACOM,LKCACT,I)       ;% send command
        
GKCRCB: SNDBYT  (ACTPRT,\B.CC,CCRCT)    ;% send costcode
        TCR     (1)                     ;% type crlf
        PUSHJ   P,AGANS                 ;  get answering byte
         JRST   GKCERR                  ;  not found
        
        ;type heading if not going to list file
        TYPSNL  ([ASCIZ/Cid/],777,0,T.P0+L.CID-3,N)     ;%
        TYPSNL  ([ASCIZ/Type/],777,0,T.P2-1,N)          ;%
        TYPSNL  ([ASCIZ/Cus Name/],777,0,T.P3+5)        ;%
        
        ;else type a message if we are going to list file
        TYPSLO  ([ASCIZ/Starting list output/])         ;%
        
GKCRC2: TCRNL   (1)                     ;% separate each entry
        
GKCRC3: GETBYT  (ACTPRT,\B.CID,Y)       ;% get cid
         JRST   GETCMD                  ;  command aborted, invalid cid
        CAIN    AC1,377                 ;  skip if not terminator
         JRST   CMLKC2                  ;  done, get another costcode
        MOVEM   AC1,UACID               ;  save
        GETBYT  (ACTPRT,\B.ASY)         ;% input system type
         JRST   GETCMD                  ;  command aborted, invalid system type
        MOVEM   AC1,ACTSYS              ;  save
        PUSHJ   P,GCNAAC                ;  get customer name
        MOVE    AC,ACTSYS               ;  get system type
        CAILE   AC,A370                 ;  make sure it's <=3
         JRST   GKCRC3                  ;  don't output Tymcom III records
        TRNE    FLG,U.OST               ;  skip if not outputting sys type
         JRST   GKCRC5                  ;  else type it out
        
        ;check for possible control break when outputting system type
        MOVE    AC1,UACID
        CAMN    AC1,LASCUS              ;skip if different
         JRST   GKCRC3                  ;if same, go get another
        MOVEM   AC1,LASCUS              ;  different--alter control field
                                        ;  and continue
        
GKCRC5: LISNUM  (UACID,D,0,T.P0,N)      ;% output cusnum
        TRNN    FLG,U.OST               ;  skip if outputting sys type
         JRST   GKCRC6                  ;  next field
        MOVE    AC1,ACTSYS              ;  get systype
        MOVEI   AC1,@ASTTAB-1(AC1)      ;  get address of string(systype name)
        MOVEM   AC1,NUM                 ;  save it
        TYPLIS  (@NUM,777,0,T.P2,N)     ;% output it
        
GKCRC6: TRNN    FLG,U.OCN               ;  check for customer name output
         JRST   GKCRC7                  ;  no
        TYPLIS  (UACNM,L.CUSN,0,T.P3+3,N)       ;% yes,type it
        
GKCRC7: JRST    GKCRC2                  ;  type crlf and get another entry
 
 
GKCERR: ;error
        TYPSTR  ([ASCIZ/Costcode Not Found./])          ;%
        POPJ    P,                      ;  return





;     LIST COSTCODE GANS
;     __________________

; This command will list all the gans for a given costcode.     *
; If a <cr> is typed when prompted for a costcode, you will     *
; return to the command level.                                  *
;                                                               *
; % indicates programmer-defined macro.                         *
;                                                               *
;****************************************************************

CMDLKG: ;list costcode gans
        PUSHJ   P,LTT                   ;  write an entry in tattle tale file
        TCR     (1)                     ;% type crlf
        PUSHJ   P,GETACC                ;  get acctg circuit
         JRST   GETCMD                  ;  command aborted, no circuit built
        PUSHJ   P,GETODF                ;  get output file
        SETFM   (L.GAN)                 ;% field size for gan

CMLKG2: TCR     (1)                     ;% type crlf
        PUSHJ   P,GETCC                 ;  input costcode
         JRST   CMLKGD                  ;  all done
        PUSHJ   P,CHKCC                 ;  check costcode
         JRST   CMLKG2
        PUSHJ   P,GKGREC                ;  input and list info


CMLKGD: ;all done
        TRNE    FLG,U.LFO               ;  skip of no list output file
        PUSHJ   P,CLSODF                ;  close file
        TRO     FLG,U.OKAY              ;  command completed
        POPJ    P,                      ;  return

GKGREC: ;get and output costcode gans
        SNDBYT  (ACTPRT,\B.ACOM,LKGACT,I)       ;% send command
        SNDBYT  (ACTPRT,\B.CC,CCRCT)    ;% send costcode
        TCR     (1)                     ;% type crlf
        PUSHJ   P,AGANS                 ;  get answering byte
         JRST   GKGERR                  ;  not found

        ;output heading if not going to list file
        TYPSNL  ([ASCIZ/Gans/],777,0,T.P0+L.GAN-4)      ;%

        ;else type message if output is to list file
        TYPSLO  ([ASCIZ/Starting list output. /])       ;%

GKGRC2: TCRNL   (1)                     ;% separate each entry

GKGRC3: GETBYT  (ACTPRT,\B.GAN,Y)       ;% get gan
         JRST   GETCMD                  ;  command aborted, illegal gan
        CAIN    AC1,377                 ;  skip if terminator
         JRST   CMLKG2                  ;  done, get another costcode
        MOVEM   AC1,UAGAN               ;  set to print it
        LISNUM  (UAGAN,O,0,T.P0)        ;% output gan

GKGRC4: JRST    GKGRC2                  ;  get another gan for this costcode

GKGERR: ;error
        TYPSTR  ([ASCIZ/Costcode Not Found./])          ;%
        POPJ    P,                      ;  return to command level


;     LIST COSTCODE USERS
;     ___________________

; This command will list all the users, customer numbers, and   *
; gans for a given costcode. If a <cr> is typed when prompted   *
; for a costcode, you will return to the command level.         *
;                                                               *
; % indicates programmer-defined macro.                         *
;                                                               *
;****************************************************************

CMDLKU: ;list costcode users
        PUSHJ   P,LTT                   ;  write an entry in tattle tale file
        TCR     (1)                     ;% type carriage return
        PUSHJ   P,GETACC                ;  get acctg circuit
         JRST   GETCMD                  ;  command aborted, no circuit built
        PUSHJ   P,GETODF                ;  get output destination file
        TRO     FLG,U.OCN               ;  set output cusnam flag
        GETYR   ([ASCIZ/Output Customer Number ?/])     ;% get y/n, skip if yes
         TRZ    FLG,U.OCN               ;  set it off
        TRO     FLG,U.OGN               ;  set output gan flag
        GETYR   ([ASCIZ/Output Gan ?/]) ;% get y/n, skip if yes
        TRZ     FLG,U.OGN               ;  set it off

CMLKU2: TCR     (1)                     ;% type a carriage return
        PUSHJ   P,GETCC                 ;  input costcode
         JRST   CMLKUD                  ;  all done
        PUSHJ   P,CHKCC                 ;  check costcode
         JRST   CMLKU2                  ;  try again
        PUSHJ   P,GKUREC                ;  get costcode user record


CMLKUD: ;all done
        TRNE    FLG,U.LFO               ;  skip if no list ourput file
        PUSHJ   P,CLSODF                ;  close list file
        TRO     FLG,U.OKAY              ;  set OK flag
        POPJ    P,                      ;  return

GKUREC: ;get and output list costcode users
        SNDBYT  (ACTPRT,\B.ACOM,LKUACT,I)       ;% send command
        SNDBYT  (ACTPRT,\B.CC,CCRCT)    ;% send costcode
        TCR     (1)                     ;% type crlf
        PUSHJ   P,AGANS                 ;  get answering byte
         JRST   GKUERR                  ;  not found

        ;output heading if not going to list file
        TYPSNL  ([ASCIZ/Cid/],777,0,T.P0+L.CID-3,N)     ;%
        TYPSNL  ([ASCIZ/Gan/],777,0,T.P0+10+L.GAN-3,N)  ;%
        TYPSNL  ([ASCIZ/Username/],777,0,T.P0+25)       ;%

        ;else type message if output is to list file
        TYPSLO  ([ASCIZ/Starting list output./])        ;%

GKURC2: TCRNL   (1)                     ;  separate each entry

GKURC3: GETBYT  (ACTPRT,\B.CID,Y)       ;% get cusnum
         JRST   GETCMD                  ;  command aborted, invalid cusnum
        CAIN    AC1,377                 ;  skip if not terminator
         JRST   CMLKU2                  ;  done, get another costcode
        MOVEM   AC1,UACID               ;  save cusnum
        GETBYT  (ACTPRT,\B.GAN)         ;% get gan
         JRST   GETCMD                  ;  command aborted, invalid gan
        MOVEM   AC1,UAGAN               ;  save gan
        PUSHJ   P,GNAMAC                ;  get username
        TRNN    FLG,U.OCN               ;  skip if we output cid
         JRST   GKURC4                  ;  go to output gan
        SETFM   (L.CID)                 ;% set output field size for cid
        LISNUM  (UACID,D,0,T.P0,N)      ;% type out cid's

GKURC4: ;type out the gans
        TRNN    FLG,U.OGN               ;  skip if we output gan
         JRST   GKURC5                  ;  if not, go to output usernames
        SETFM   (L.GAN)                 ;% set field size for gan
        LISNUM  (UAGAN,O,0,T.P0+10,N)   ;% type out the gans

GKURC5: ;output the usernames
        TYPLIS  (UAUNM,L.UNM,0,T.P0+25,N)       ;% type the names
         JRST   GKURC2                  ;  next

GKUERR: ;error
        TYPSTR  ([ASCIZ/Costcode Not Found./])          ;%
        POPJ    P,                      ;  return to command level

CMDLCA:  ; list customer accounting
	PUSHJ	P,LTT
        TCR     (1)             ; type crlf
 ;      PUSHJ   P,GETCUD        ; for getting industry code from mud later
 ;       JRST   GETCMD
        PUSHJ   P,GETACC        ;build circuit to accounting
         JRST   GETCMD
        PUSHJ   P,INASY9
        MOVEI   AC,LCTACT
        MOVEM   AC,FINARG

GETCSR: ;get customer acctng. record
        TCR     (1)
        PUSHJ   P,GETCUS        ;get cus.num.
         JRST   GETCS3          ;got crlf instead of number. cmd done
        MOVE    AC,CUSNUM
        MOVEM   AC,FINAR2
        PUSHJ   P,FINAST        ;get ASTSY2 for CHKCUS
         JRST   [TYPSTR  ([ASCIZ/Not a valid Tymshare customer number./])
                 JRST    GETCSR]
        PUSHJ   P,CHKCUS        ;test access
         JRST   GETCS2          ;access denied
        PUSHJ   P,GCAREC        ;read acctg. record
         JRST   GETCS2          ;no record found
        PUSHJ   P,LCAREC        ;write cus. acctng. record

GETCS2: TLNN    FLG,U.CUS
         JRST   GETCSR          ;user not a cus. so return for next #
GETCS3: TRO     FLG,U.OKAY      ;reset u.okay flag before try next command
        POPJ    P,


GCAREC: MOVE    AC,CUSNUM
        MOVEM   AC,FINAR2
        PUSHJ   P,FINAST
         JRST   GCAREE
        SNDBYT  (ACTPRT,\B.ACOM,LCAACT,I)   ;send code 50 = list cus. acct.
        SNDBYT  (AC,\B.CID,CUSNUM)      ;send 3 byte c.i.d. to acct.
        SNDBYT  (AC,\B.ASY,ACTSY2)     ;send 1 byte sys.type to acct.
        PUSHJ   P,AGANS
         JRST   GCAREE

        GETSTR  (AC,L.CUSN,ACCNAM)      ;cus. name from acctg.
        GETBYT  (AC,\B.DIS)              ;cus. dist. to ACCDIS
         JRST   GETCMD
        MOVEM   AC1,ACCDIS
	GETBYT  (AC,\B.CC)
	 JRST	GETCMD
	MOVEM	AC1,ACCCC
        GETBYT  (AC,\B.DET)              ;detail code to ACDETC
         JRST   GETCMD
        MOVEM   AC1,ACDETC
        GETBYT  (AC,\B.INV)              ;invoice code to ACINVC
         JRST   GETCMD
        MOVEM   AC1,ACINVC
        GETBYT  (AC,\B.MIN)              ;min. code to ACMINC
         JRST   GETCMD
        MOVEM   AC1,ACMINC
        GETBYT  (AC,\B.SLS)              ;salesman code to ACSLS
         JRST   GETCMD
        MOVEM   AC1,ACSLS
        GETSTR  (AC,L.PO,ACPONM)        ;po number to ACPONM
        GETBYT  (AC,\B.POMX)             ;pomax to ACPOMX
         JRST   GETCMD
        MOVEM   AC1,ACPOMX
        GETBYT  (AC,\B.PODT)             ;po start date to ACPSDM->(ACPSDM+2)
         JRST   GETCMD
        MOVEM   AC1,ACPSDT
        MOVE    AC,AC1
        MOVEI   AP,ACPSDM
        PUSHJ   P,CNVDT
        GETBYT  (ACTPRT,\B.PODT)         ;po end date to ACPEDM->(ACPEDM+2)
         JRST   GETCMD
        MOVEM   AC1,ACPEDT
        MOVE    AC,AC1
        MOVEI   AP,ACPEDM
        PUSHJ   P,CNVDT
        GETBYT  (ACTPRT,\B.VPRI)         ;variable pricing flag to ACVPF
         JRST   GETCMD
        MOVEM   AC1,ACVPF
        GETBYT  (AC,\B.PRI)              ;default pricing to ACDEFP
         JRST   GETCMD
        MOVEM   AC1,ACDEFP
	GETBYT	(AC,\B.FOCF)
	 JRST	GETCMD
	MOVEM	AC1,ACFOCF
        GETBYT  (AC,\B.PODT)             ;get anniversary date
         JRST   GETCMD
        MOVE    AC,AC1
        MOVEI   AP,ANNVDM
        PUSHJ   P,CNVDT
        GETSTR  (ACTPRT,L.STRE,ACSTR1)          ;get street1
        GETSTR  (AC,L.STRE,ACSTR2)      ;get street2
        GETSTR  (AC,L.STRE,ACEXLN)      ;get extra line
        GETSTR  (AC,L.CITY,ACCITY)      ;get city
        GETSTR  (AC,L.STAT,ACSTAT)      ;get state
        GETSTR  (AC,L.ZIP,ACZIP)        ;get zip code
        GETSTR  (AC,L.CTRY,ACCTRY)      ;get country
        GETSTR  (AC,L.ATTN,ACATTN)      ;get attention line
        AOS     0(P)
        POPJ    P,

        ; skip the following codes because of eliminating industry code
        SNDBYT  (CUDPRT,\B.CCOM,LCIMUD,I)
        SNDBYT  (AC,\B.CID,CUSNUM)
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   GCARE1          ;nothing back from cud port
        JRST    GCARE2          ;got something-->goto GCARE2
GCARE1: SETZM   NMSIC           ;zero out industry code value in mem.
        JRST    GCA        ;goto 'skip' (=successful) return.NMSIC=0
GCARE2: GETBYT  (AC,\B.IND)
         JRST   GETCMD          ;didn't get promised bytes. do next comm'd
        CAIN    AC1,177777      ;if ind.code val. returned is -1 then no value
         JRST   GCARE1          ;GCARE1 supplies 0 value for NMSIC & goes to ret.
        MOVEM   AC1,NMSIC       ;move actual non-zero value to NMSIC
        PUSHJ   P,GET40         ;finishes up last trans. thru cud port
        SNDBYT  (AC,\B.CCOM,LICMUD,I)
        SNDBYT  (AC,\B.IND,NMSIC)
        PUSHJ   P,SND40         ;send for ind. code desc.
        PUSHJ   P,NGANS
         JRST   [MOVE   AC,[MSG1,,NMSICD]       ;NGANS found nothing
                 BLT    AC,NMSICD + MSG1S
                 JRST   GCARE3]         ;i.c.desc.=='no desc. for this i.c.'
        GETSTR  (AC,L.INDN,NMSICD)      ;read i.c.desc. string & put in NMSICD

GCARE3: PUSHJ   P,GET40                 ;finishes up last trans. thru cud port
        AOS     0(P)                    ;set up skip return
        POPJ    P,                      ;do it

GCAREE: TYPSTR ([ASCIZ/Not valid Tymshare customer number./])
        POPJ    P,


INDUS:
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GETODF
INDUS0:
        PUSHJ   P,GETCUS
         POPJ   P,
        SNDBYT  (CUDPRT,\B.CCOM,LCIMUD,I)
        SNDBYT  (AC,\B.CID,CUSNUM)
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   INDUS1          ;nothing back from cud port
        JRST    INDUS2          ;got something-->goto GCARE2
INDUS1: SETZM   NMSIC           ;zero out industry code value in mem.
        JRST    INDUS3          ;goto 'skip' (=successful) return.NMSIC=0
INDUS2: GETBYT  (AC,\B.IND)
         JRST   GETCMD          ;didn't get promised bytes. do next comm'd
        CAIN    AC1,177777      ;if ind.code val. returned is -1 then no value
         JRST   INDUS1          
        MOVEM   AC1,NMSIC       ;move actual non-zero value to NMSIC
INDUS3: PUSHJ   P,GET40                 ;finishes up last trans. thru cud port
        LISNUM  (CUSNUM,D,0,T.P0)
        LISNUM  (NMSIC,D,5,T.P2)
        JRST    INDUS0


LCAREC: TCR     (1)
        MOVE    AC,CUSNUM
        PUSHJ   P,CIDOUT                ;output cust. number
        PUSHJ   P,ASTSOU                ;output acct. sys. type
        MOVEI   AC,ACCNAM
        PUSHJ   P,CSNOUT                ;output cust. name
        PUSHJ   P,ATNOUT                ;output attention line
        PUSHJ   P,ADROUT                ;output entire mailing address
        PUSHJ   P,DETOUT                ;output detail code
        PUSHJ   P,INVOUT                ;output invoice code
        MOVE    AC,ACSLS
        PUSHJ   P,SLSOUT                ;output salesman number
	MOVE	AC,ACCCC
	PUSHJ	P,CCOUT			; cost code
        MOVE    AC,ACCDIS
        PUSHJ   P,DISOUT                ;output customer district
 ;      PUSHJ   P,ICDOUT                ;output industry code
        MOVEI   AC,ANNVDM               ;setup for anniversary date
        PUSHJ   P,ANNOUT
        PUSHJ   P,POOUT                 ;output p.o. number
        MOVEI   AC,ACPSDM               ;setup for p.o. start date
        PUSHJ   P,PODOUT                ;output p.o. start date
        MOVEI   AC,ACPEDM               ;setup for p.o. stop date
        PUSHJ   P,PODOUT                ;output p.o. stop date
        PUSHJ   P,POMOUT                ;output p.o. limit (max)
        PUSHJ   P,DFPOUT                ;output default price code
     ;  PUSHJ   P,MNCOUT                ;output mincode (always='none')
        TCR     (1)
        POPJ    P,





CMDLCN: ; list all user names for a customer
	PUSHJ	P,LTT
        TCR     (1)
        PUSHJ   P,GETACC        ; get accounting circuit
         JRST   GETCMD
        PUSHJ   P,GETODF        ; get output file (for list output)
        TRO     FLG,U.OGN       ; set output gan flag
        GETYR   ([ASCIZ/Output Gan ?/])
         TRZ    FLG,U.OGN       ; unset output gan flag
        SETZM   ACTSYS
        SETFM   (L.GAN)
CMLCN2: TCR     (1)
        PUSHJ   P,GETCUS        ; input customer number
         JRST   CMLCND          ; all done
        MOVEI   AC,LCTACT       ; setup for finast routine
        MOVEM   FINARG
        MOVE    AC,CUSNUM       ; ditto
        MOVEM   AC,FINAR2
        SETZM   ACTSYS
        PUSHJ   P,FINAST        ; get an ast for this customer
         JRST   CMLCN3          ; no such Tymshare customer
        PUSHJ   P,CHKCUS        ; see if we have access to this cust
         JRST   CMLCN2
        PUSHJ   P,GCNREC        ; get and output information
CLCN2B: TLNN    FLG,U.CUS       ; skip if cus type
         JRST   CMLCN2          ; get next
        JRST    CMLCND          ; all done
CMLCN3:
        TYPSTR  ([ASCIZ/Not a Tymshare Customer Number./])
        JRST    CLCN2B

CMLCND: ; done processing List Customer Names
        TRNE    FLG,U.LFO       ; skip if not going to list output file
         PUSHJ  P,CLSODF        ; close the list output file
        TRO     FLG,U.OKAY      ; set OK flag
        POPJ    P,              ; and return

GCNREC: ; start getting list customer names record
        SNDBYT  (ACTPRT,\B.ACOM,LUCACT,I)       ; output the command
        SNDBYT  (ACTPRT,\B.CID,CUSNUM)          ; and cid
        SNDBYT  (ACTPRT,\B.ASY,ACTSY2)          ; and system type
        PUSHJ   P,AGANS         ; get answer
         JRST   GCNREE
        GETBYT  (ACTPRT,\B.DIS)         ; get district
         JRST   GETCMD
        MOVEM   AC1,UADIS               ; save it
        TCR     (1)
; output heading if going to terminal/tout
        TYPSNL  ([ASCIZ/Username          Gan/],777,0,T.P0)
; output message if going to LIST output file
        TYPSLO  ([ASCIZ/Starting list output./])
GCNRC2:
        TCRNL   (1)             ; new line on terminal/tout
        PUSHJ   P,GNAMAC        ; input username
        CAIN    AC1,377         ; skip if not end
         JRST   GCNRED
        GETBYT  (ACTPRT,\B.GAN)         ; input the gan
         JRST   GETCMD
        MOVEM   AC1,UAGAN               ; save it
        TYPLIS  (UAUNM,L.UNM,0,T.P0,N)  ; output the username
        TRNN    FLG,U.OGN               ; skip if he wants the gan
         JRST   GCNRC2
        LISNUM  (UAGAN,O,0,T.P2,N)      ; output the gan
        JRST    GCNRC2
GCNRED:
        POPJ    P,

GCNREE: POPJ    P,
CMDLCG: ; list customer gans
	PUSHJ	P,LTT
        TCR     (1)
        PUSHJ   P,GETACC                ; get acctg circuit
         JRST   GETCMD
        PUSHJ   P,GETODF                ; get output file
        SETFM   (L.GAN)         ; field size for gan
CMLCG2: TCR     (1)
        PUSHJ   P,GETCUS                ; input customer number
         JRST   CMLCGD
        MOVEI   AC,LCTACT               ; prepare for finast routine
        MOVEM   FINARG
        MOVE    AC,CUSNUM
        MOVEM   AC,FINAR2
        SETZM   ACTSYS
        PUSHJ   P,FINAST                ; mostly to check for valid customer
         JRST   CMLCG3
        PUSHJ   P,CHKCUS                ; check access to this customer
         JRST   CMLCG2
        PUSHJ   P,GCGREC                ; input and list info
CLCG2B: TLNN    FLG,U.CUS               ; skip if cus
         JRST   CMLCG2                  ; do another
        JRST    CMLCGD                  ; all done

CMLCG3:
        TYPSTR  ([ASCIZ/Not a Tymshare Customer Number./])
        JRST    CLCG2B
CMLCGD: ; done processing List Customer Gans
        TRNE    FLG,U.LFO
         PUSHJ  P,CLSODF
        TRO     FLG,U.OKAY
        POPJ    P,

GCGREC: ; get and output customer gans.
        SNDBYT  (ACTPRT,\B.ACOM,LCGACT,I)       ; send the command
        SNDBYT  (ACTPRT,\B.CID,CUSNUM)          ; and cusid
        TCR     (1)
        TYPSNL  ([ASCIZ/Gans/],777,0,T.P0+L.GAN-4)      ; heading
        TYPSLO  ([ASCIZ/Starting list output./]) ; for list output
        TCRNL   (1)
GCGRC2: GETBYT  (ACTPRT,\B.GAN,Y)       ; get gan or termin
         JRST   GETCMD
        CAIN    AC1,377         ; is it termin
         JRST   GCGRCD          ; yes, all done
        MOVEM   AC1,UAGAN       ; set to print it
        LISNUM  (UAGAN,O,0,T.P0)        ; output it
        JRST    GCGRC2
GCGRCD: 
        POPJ    P,                      ; return
CMDLCH: ; list customer hosts
	PUSHJ	P,LTT
        TCR     (1)
        PUSHJ   P,GETACC        ; get acctg circuit
         JRST   GETCMD
CMLCH2: TCR     (1)
        PUSHJ   P,GETCUS        ; get a customer number
         JRST   CMLCHD
        PUSHJ   P,CHKCUS        ; check if we have access
         JRST   CMLCH2
        PUSHJ   P,GCHREC        ; get the host numbers from acctg
         JRST   CLCH2B          ; none found
        PUSHJ   P,LCHREC        ; output hosts
CLCH2B: TLNN    FLG,U.CUS
         JRST   CMLCH2
        JRST    CMLCHD          ; all done

CMLCHD: ; all done
        TRO     FLG,U.OKAY
        POPJ    P,

GCHREC: ; get customer hosts
        SNDBYT  (ACTPRT,\B.ACOM,LHCACT,I)       ; send the command
        SNDBYT  (ACTPRT,\B.CID,CUSNUM)  ; and the cusomer number
        PUSHJ   P,AGANS         ; get answer
         JRST   GCHREE          ; not found
        PUSHJ   P,GHSTAC        ; input hosts
        SKIPLE  UAHSTP          ; skip if none found
         AOS    0(P)            ; set to skip return
        POPJ    P,              ; return

GCHREE: ; not found
        TYPSTR  ([ASCIZ/Not a Tymshare Customer Number./])
        JRST    CLCH2B

LCHREC: ; output customer hosts record
        TCR     (1)
        MOVE    AC,CUSNUM               ; output cid
        PUSHJ   P,CIDOUT
        PUSHJ   P,HSTOUT                ; output hosts
        POPJ    P,
CMDLCT: ; list customer tymuse
	PUSHJ	P,LTT
        TCR     (1)
        PUSHJ   P,GETACC
         JRST   GETCMD
CMLCT2: TCR     (1)
        PUSHJ   P,GETCUS                ; input cusnum
         JRST   CMLCTD
        PUSHJ   P,CHKCUS                ; check access
         JRST   CLCT2B
        PUSHJ   P,GCTREC                ; input a cus tymuse rec
         JRST   CLCT2B
        PUSHJ   P,LCTREC                ; list it out
CLCT2B: TLNN    FLG,U.CUS               ; skip if we customer type
         JRST   CMLCT2                  ; get another
        JRST    CMLCTD                  ; all done

CMLCTD:
        TRO     FLG,U.OKAY              ; set ok flag
        POPJ    P,

GCTREC: ; get customer tymuse rec
        SETZM   TCSTRT                  ; zero out buffer
        MOVE    AC,[TCSTRT,,TCSTRT+1]
        BLT     AC,TCEND-1
        SNDBYT  (ACTPRT,\B.ACOM,LTYACT,I) ; send code
        SNDBYT  (ACTPRT,\B.CID,CUSNUM) ; and cid
        PUSHJ   P,AGANS                 ; input answer
         JRST   GCTREE
        GETBYT  (ACTPRT,3)              ; input date in decimal yymmdd fmt
         JRST   GETCMD
        MOVE    AC,AC1                  ; prepare to convert date
        MOVEI   AP,TCMM                 ; ditto
        PUSHJ   P,CNVDT                 ; convert to 3 separate wrds mm,dd,yy
        GETBYT  (ACTPRT,\B.CID)         ; input cid (receiving)
         JRST   GETCMD
        MOVEM   AC1,TCRCID
        GETBYT  (ACTPRT)
         JRST   GETCMD
        MOVEM   AC1,TCFLG               ; save flag (whether username present)
        CAIE    AC1,1
         JRST   GCTRC2
        GETSTR  (ACTPRT,L.UNM,TCUNM)    ; input username (destination)
        GETBYT  (ACTPRT,\B.TDS)         ; input days to hold data
         JRST   GETCMD
        MOVEM   AC1,TCDS
        SETZM   ACTSYS                  ; prepare to get cusnam for cid
GCTRC2: MOVEI   AC,LCTACT
        MOVEM   AC,FINARG
        MOVE    AC,CUSNUM
        MOVEM   AC,FINAR2
        PUSHJ   P,FINAST                ; find an actg sys type
         JRST   GCTRC3
        SNDBYT  (ACTPRT,\B.ACOM,LCNACT,I)        ; send command
        SNDBYT  (ACTPRT,\B.CID,CUSNUM)          ; and cusnum
        SNDBYT  (ACTPRT,\B.ASY,ACTSY2)          ; and actg systype
        PUSHJ   P,AGANS
         JRST   GCTRC3
        GETSTR  (ACTPRT,L.CUSN,TCCN)            ; input customer name
GCTRC3: MOVE    AC,TCRCID
        CAIN    AC,0
         JRST   GCTRCD                ; tcrcid = 0 means no receiving cid
        SETZM   ACTSYS                          ; now same for receiving cid
        MOVEI   AC,LCTACT
        MOVEM   AC,FINARG
        MOVE    AC,TCRCID
        MOVEM   AC,FINAR2
        PUSHJ   P,FINAST
         JRST   GCTREE
        SNDBYT  (ACTPRT,\B.ACOM,LCNACT,I)
        SNDBYT  (ACTPRT,\B.CID,TCRCID)
        SNDBYT  (ACTPRT,\B.ASY,ACTSY2)
        PUSHJ   P,AGANS
         JRST   GCTREE
        GETSTR  (ACTPRT,L.CUSN,TCRCN)   ; input receiving cusnam
GCTRCD: AOS     0(P)
        POPJ    P,

GCTREE:
        TYPSTR  ([ASCIZ/Not a Valid Tymuse Customer/])
        POPJ    P,

CNVDT:  ; convert yymmdd in ac to three separate numbers
        IDIVI   AC,^D10000      ; after: ac/ yy    ac1/ mmdd
        MOVEM   AC,2(AP)
        MOVE    AC,AC1
        IDIVI   AC,^D100        ; after: ac/ mm    ac1/ dd
        MOVEM   AC,0(AP)
        MOVEM   AC1,1(AP)
        POPJ    P,

LCTREC: ; output cus tymuse rec
        TCR     (1)
        MOVE    AC,CUSNUM       ; cid
        PUSHJ   P,CIDOUT
        MOVEI   AC,TCCN
        PUSHJ   P,CSNOUT        ; cusnam
        MOVEI   AC,TCMM
        PUSHJ   P,SDTOUT        ; start date
        MOVE    AC,TCRCID
        CAIN    AC,0
         JRST   LCTRE2                ; tcrcid = 0 means no receiving cid
        MOVEI   AC1,TCRCN
        PUSHJ   P,RCIOUT        ; receiving cid
LCTRE2: MOVE    AC,TCFLG
        CAIE    AC,1
         POPJ   P,
        MOVEI   AC,TCUNM
        PUSHJ   P,DUNOUT        ; destination uname
        MOVE    AC,TCDS
        PUSHJ   P,TDAOUT        ; days to hold
        POPJ    P,





;     LIST DISTRICT COSTCODES
;     _______________________



; This command lists all the costcodes for a given district.    *
; If a <cr> is typed when prompted for a district number, you   *
; will return to the command level.                             *
;                                                               *
; % indicates a programmer-defined macro.                       *
;;

;****************************************************************


CMDLDK: ;list district costcodes
        PUSHJ   P,LTT                   ;  write entry in tattle tale file
        TCR     (1)                     ;% type carriage return
        PUSHJ   P,GETACC                ;  get acctg circuit
         JRST   GETCMD                  ;  command aborted, no circuit built
        PUSHJ   P,GETODF                ;  get output file
        
CMLDK2: TCR     (1)                     ;% type carriage return
        PUSHJ   P,GETDIS                ;  get a district number
         JRST   CMLDKD                  ;  all done
        PUSHJ   P,CHKDIS                ;  see if we have access
         JRST   CMLDK2                  ;  let's try again
        PUSHJ   P,GDKREC                ;  get district costcode record
  
CLDK2B: TLNN    FLG,U.DIS               ;  skip if we're district
         JRST   CMLDK2                  ;  if not done, get a district
        JRST    CMLDKD                  ;  else done
   
CMLDKD: TRNE    FLG,U.LFO               ;  check if we have a list file
        PUSHJ   P,CLSODF                ;  close it
        TRO     FLG,U.OKAY              ;  command completed okay
        POPJ    P,                      ;  return
 
GDKREC: ;input and display list district costcodes data
        SNDBYT  (ACTPRT,\B.ACOM,LDKACT,I)       ;% send command
        SNDBYT  (ACTPRT,\B.DIS,DISRCT)  ;% and district
        TCR     (1)                     ;% type crlf
        PUSHJ   P,AGANS                 ;  get answering byte
         JRST   GDKERR                  ;  not found
   

        ;output the heading if not going to list file
        TYPSNL  ([ASCIZ/Costcode/],777,0,T.P0+L.CC-6)   ;%
        
        ;else type a message if going to list file
        TYPSLO  ([ASCIZ/Starting list output./])        ;%
   
GDKRC2: TCRNL   (1)                     ;% separate each entry
        GETBYT  (ACTPRT,\B.CC,Y)        ;% get costcode
         JRST   GETCMD                  ;  command aborted, invalid costcode
        CAIN    AC1,377                 ;  skip if not terminator
         JRST   GDKRCD                  ;  done, get another district number
        MOVEM   AC1,UACC                ;  save costcode
   
       
GDKRC3: SETFM   (L.CC)                  ;% set output field size for costcode
        LISNUM  (UACC,D,0,T.P0,N)       ;% type the costcode
         JRST   GDKRC2                  ;  next
    
GDKERR: ;error
        TYPSTR  ([ASCIZ/District Not Found./])          ;%
        POPJ    P,                      ;  return to command level
 
GDKRCD: ;done, return
        POPJ     P,
 


CMDLDC: ; list district customers
	PUSHJ	P,LTT
        TCR     (1)
        PUSHJ   P,GETACC        ; get acctg circuit
         JRST   GETCMD
        PUSHJ   P,GETODF        ; get output direction
        TRO     FLG,U.OST       ; set output stype flag
        GETYR   ([ASCIZ/Output system type ?/])
        TRZ     FLG,U.OST       ; set it off
        TRO     FLG,U.OCN       ; set output cusnam flag
        GETYR   ([ASCIZ/Output customer name ?/])
         TRZ    FLG,U.OCN       ; unset it
        SETOM   LASCUS          ; set control break field
; *note: control break on cusnum if system type field is not output only.
        SETFM   (L.CID)         ; field size for cid
CMLDC2: TCR     (1)
        PUSHJ   P,GETDIS        ; input a district number
         JRST   CMLDCD          ; all done
        PUSHJ   P,CHKDIS        ; check district number.
         JRST   CMLDC2
        PUSHJ   P,GDCREC        ; input and display data
CLDC2B: TLNN    FLG,U.DIS
         JRST   CMLDC2
        JRST    CMLDCD

CMLDCD: ; all done
        TRNE    FLG,U.LFO       ; skip if not output to list file
         PUSHJ  P,CLSODF        ; close list file
        TRO     FLG,U.OKAY      ; set OK flag
        POPJ    P,              ; and return

GDCREC: ; get district customers records
        SNDBYT  (ACTPRT,\B.ACOM,LDCACT,I)       ; send command
GDCRCB: SNDBYT  (ACTPRT,\B.DIS,DISRCT)          ; send district
        TCR     (1)
; type the heading if not going to list file
        TYPSNL  ([ASCIZ/Cid/],777,0,T.P0+L.CID-3,N)
        TYPSNL  ([ASCIZ/Type/],777,0,T.P2-1,N)
        TYPSNL  ([ASCIZ/Cus Name/],777,0,T.P3+3)
; else type a message if we are going to list file
        TYPSLO  ([ASCIZ/Starting list output./])
GDCRC2: TCRNL   (1)     ; separate each entry
GDCRC3: GETBYT  (ACTPRT,\B.CID,Y)       ; get cid
         JRST   GETCMD
        CAIN    AC1,377                 ; skip if this is not terminator
         JRST   GDCRCD
        MOVEM   AC1,UACID               ; save
        GETBYT  (ACTPRT,\B.ASY)         ; input system type
         JRST   GETCMD
        MOVEM   AC1,ACTSYS              ; save
        PUSHJ   P,GCNAAC                ; get customer name
        MOVE    AC,ACTSYS               ; get system type
        CAILE   AC,A370                 ; make sure it's <= 3
         JRST   GDCRC3                  ; don't output Tymcom-III records.
        TRNE    FLG,U.OST               ; skip if not outputting sys type
         JRST   GDCRC5
; check for possible control break when not outputting system type.
        MOVE    AC1,UACID
        CAMN    AC1,LASCUS              ; skip if different
         JRST   GDCRC3                  ; if same, go get another.
        MOVEM   AC1,LASCUS              ; different.. alter control field.
                                        ; and continue.
GDCRC5: LISNUM  (UACID,D,0,T.P0,N)      ; output cusnum
        TRNN    FLG,U.OST               ; skip if outputting sys type
         JRST   GDCRC6                  ; next field
        MOVE    AC1,ACTSYS              ; get systype
        MOVEI   AC1,@ASTTAB-1(AC1)      ; get address of string (systype name)
        MOVEM   AC1,NUM                 ; save it
        TYPLIS  (@NUM,777,0,T.P2,N)     ; output it
GDCRC6: TRNN    FLG,U.OCN               ; check for customer name ouput
         JRST   GDCRC7                  ; no
        TYPLIS  (UACNM,L.CUSN,0,T.P3+3,N)       ; yes. type it

GDCRC7: JRST    GDCRC2                  ; type crlf and get another entry.

GDCRCD: ; here when received a terminator
        POPJ    P,                      ; return
ASTTAB: [ASCIZ/ 10/]
        [ASCIZ/940/]
        [ASCIZ/370/]
ASTLEN==.-ASTTAB
CMDLDN: ; list district names
	PUSHJ	P,LTT
        TCR     (1)
        PUSHJ   P,GETACC        ; get acctg host
         JRST   GETCMD
        PUSHJ   P,GETODF                ; and possible  list output file
        TRO     FLG,U.OGN               ; determine if output gan
        GETYR   ([ASCIZ/Output Gan ?/])
         TRZ    FLG,U.OGN
        TRO     FLG,U.OCN               ; determine if output cusnum
        GETYR   ([ASCIZ/Output Customer Number ?/])
         TRZ    FLG,U.OCN
CMLDN2: TCR     (1)
        PUSHJ   P,GETDIS                ; get a district number
         JRST   CMLDND                  ; all done
        PUSHJ   P,CHKDIS                ; see if we have access
         JRST   CMLDN2                  ; no, try again
        PUSHJ   P,GDNREC                ; do it.
CLDN2B: TLNN    FLG,U.DIS    
         JRST   CMLDN2
        JRST    CMLDND

CMLDND:
        TRNE    FLG,U.LFO               ; check if we have a list file 
         PUSHJ  P,CLSODF                ; close it
        TRO     FLG,U.OKAY
        POPJ    P,                      ; and return

GDNREC: ; input and display list dist names data
        SNDBYT  (ACTPRT,\B.ACOM,LDUACT,I)       ; send command
        SNDBYT  (ACTPRT,\B.DIS,DISRCT)  ; and district
	TCR	(1)
; output the heading
        TYPSNL  ([ASCIZ/Cid/],777,0,T.P0+L.CID-3,N)
        TYPSNL  ([ASCIZ/Gan/],777,0,T.P0+10+L.GAN-3,N)
        TYPSNL  ([ASCIZ/Username/],777,0,T.P0+25)
        TYPSLO  ([ASCIZ/Starting list output./])
GDNRC2: TCRNL   (1)
        GETBYT  (ACTPRT,\B.CID,Y)       ; get cusnum
         JRST   GETCMD
        CAIN    AC1,377                 ; skip if not terminator
         JRST   GDNRCD                  ; done
        MOVEM   AC1,UACID               ; save cusnum
        GETBYT  (ACTPRT,\B.GAN)         ; get gan
         JRST   GETCMD
        MOVEM   AC1,UAGAN               ; save it
        PUSHJ   P,GNAMAC                ; get username
        TRNN    FLG,U.OCN               ; skip if we output cid
         JRST   GDNRC3
        SETFM   (L.CID)                 ; set output field size
        LISNUM  (UACID,D,0,T.P0,N)      ; type it out
GDNRC3: TRNN    FLG,U.OGN               ; skip if we output gan
         JRST   GDNRC4                  ; no
        SETFM   (L.GAN)                 ; set field size
        LISNUM  (UAGAN,O,0,T.P0+10,N)   ; do it
GDNRC4: TYPLIS  (UAUNM,L.UNM,0,T.P0+25,N); type the name
        JRST    GDNRC2                  ; next

GDNRCD: ; done, return.
        POPJ    P,
CMDLDT:  ; list district tymuse
	PUSHJ	P,LTT
        TCR     (1)
        PUSHJ   P,GETACC
         JRST   GETCMD
        PUSHJ   P,GETODF
        TRO     FLG,U.OST
        GETYR   ([ASCIZ/Output system type ?/])
         TRZ    FLG,U.OST
        TRO     FLG,U.OCN
        GETYR   ([ASCIZ/Output customer name ?/])
         TRZ    FLG,U.OCN
        SETFM   (L.CID)
CMLDT2: TCR     (1)
        PUSHJ   P,GETDIS
         JRST   CMLDTD
        PUSHJ   P,CHKDIS
         JRST   CMLDT2
        PUSHJ   P,GDTREC
CLDT2B: TLNN    FLG,U.DIS
         JRST   CMLDT2
        JRST    CMLDTD

CMLDTD:
        TRNE    FLG,U.LFO
         PUSHJ  P,CLSODF
        TRO     FLG,U.OKAY
        POPJ    P,

GDTREC:
        SNDBYT  (ACTPRT,\B.ACOM,LTYCCT,I)
        PUSHJ   P,GDCRCB
         JFCL

CMDLGN: ; list gan names
	PUSHJ	P,LTT
        TCR     (1)
        PUSHJ   P,GETACC        ; get acctg
         JRST   GETCMD
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GETODF        ; get output direction
CMLGN2: TCR     (1)
        PUSHJ   P,GETGAN        ; input a gan
         JRST   CMLGND
        PUSHJ   P,CHKGAN
         JRST   CMLGN2
        PUSHJ   P,GGNREC        ; do it
        TLNE    FLG,U.PRV!U.DIS!U.CUS
         JRST   CMLGN2
        JRST    CMLGND

CMLGND:                         ; all done
        TRNE    FLG,U.LFO
         PUSHJ  P,CLSODF
        TRO     FLG,U.OKAY      ; set OK flag
        POPJ    P,

GGNREC: ; get and output list gan names
        SNDBYT  (ACTPRT,\B.ACOM,LUGACT,I) ; send command
        SNDBYT  (ACTPRT,\B.GAN,GLOBAC)  ; and gan
        PUSHJ   P,AGANS ; get answer
         JRST   GGNREE
        GETBYT  (ACTPRT,\B.DIS) ; input district
         JRST   GETCMD
        TCR     (1)
; output heading
        TYPSTR  ([ASCIZ/For Gan /],777,0,0,N)
        TYPNUM  (GLOBAC,O,1)
        TYPSNL  ([ASCIZ/Username/],777,0,T.P0)
        TYPSLO  ([ASCIZ/Starting list output./])
GGNRC2: TCRNL   (1)
        GETSTR  (ACTPRT,\L.UNM,UNMSPC)  ; input username
        CAIN    AC1,377 ; skip if not terminator
         JRST   GGNRCD
        GETBYT  (ACTPRT,\B.GAN) ; input gan
         JRST   GETCMD
        TYPLIS  (UNMSPC,L.UNM,0,T.P0,N) ; output username
        JRST    GGNRC2          ; do another user for this gan

GGNRCD: ; all names done
        POPJ    P,

GGNREE: ; error
        TYPSTR  ([ASCIZ/Not a Tymshare Gan./])
        POPJ    P,
CMDLGH: ; list gan hosts
	PUSHJ	P,LTT
        TCR     (1)
        PUSHJ   P,GETACC        ; get acctg circuit
         JRST   GETCMD
        PUSHJ   P,GETCUD        ; get cud circuit
         JRST   GETCMD
CMLGH2: TCR     (1)
        PUSHJ   P,GETGAN        ; get a gan
         JRST   CMLGHD
        PUSHJ   P,CHKGAN        ; check for access
         JRST   CLGH2B
        PUSHJ   P,GGHREC        ; get hosts
         JRST   CLGH2B
        PUSHJ   P,LGHREC        ; output hosts
CLGH2B: TLNE    FLG,U.DIS!U.PRV!U.CUS
         JRST   CMLGH2
        JRST    CMLGHD          ; done

CMLGHD:
        TRO     FLG,U.OKAY
        POPJ    P,

GGHREC: ; get gan hosts
        SNDBYT  (ACTPRT,\B.ACOM,LHGACT,I)       ; send command
        SNDBYT  (ACTPRT,\B.GAN,GLOBAC)  ; send gan
        PUSHJ   P,AGANS                 ; get answer
         JRST   GGHREE
        PUSHJ   P,GHSTAC                ; get hosts numbers
        SKIPLE  UAHSTP                  ; skip if none found
         AOS    0(P)                    ; set to skip return
        POPJ    P,

GGHREE: 
        TYPSTR  ([ASCIZ/Not a Tymshare Gan./])
        POPJ    P,

LGHREC:
        MOVE    AC,GLOBAC
        PUSHJ   P,GANOUT
        PUSHJ   P,HSTOUT
        POPJ    P,
CMDLUI: ; list user information including cud and accounting
        PUSHJ   P,LTT
        TCR     (1)
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GETACC
         JRST   GETCMD
CMLUI1:
        PUSHJ   P,GETUNM              ; get user name
         JRST   LUIDON
        PUSHJ   P,GCREC               ; get cud record
         JRST   CMLUI1
        SETZM   ACTSYS                ; for getting default ast
        MOVEI   AC,LUTACT
        MOVEM   AC,FINARG             ; for FINAST call
        PUSHJ   P,GUAREC              ; get acctg. record
         JRST   CMLUI1
        PUSHJ   P,LUSINF              ; output info
        JRST    CMLUI1
LUIDON:
        TRO     FLG,U.OKAY
        POPJ    P,
 
LUSINF: ; output cud and acctg. info to terminal
        TCR     (1)
        MOVEI   AC,UNMSPC
        PUSHJ   P,NAMOUT
        MOVE    AC,NMGAN
        PUSHJ   P,GANOUT
        MOVE    AC,NMUUN
        PUSHJ   P,UUNOUT
        MOVE    AC,NMDIST
        PUSHJ   P,DISOUT
        PUSHJ   P,CPROUT
        PUSHJ   P,CLNOUT
        PUSHJ   P,ASTSOU
        MOVE    AC,UACID
        PUSHJ   P,CIDOUT
        MOVEI   AC,UACNM
        PUSHJ   P,CSNOUT
        MOVE    AC,UACC
        PUSHJ   P,CCOUT
        MOVE    AC,UATZ
        PUSHJ   P,ZONOUT
        PUSHJ   P,HSTOUT
        PUSHJ   P,CLSOUT
        POPJ    P,
CMDLUC: ; list user cud record
	PUSHJ	P,LTT
        TCR     (1)
        PUSHJ   P,GETCUD
         JRST   GETCMD
CMLUC1: PUSHJ   P,GETUNM        ; get username
         JRST   LUCDON
        TCR     (1)
        PUSHJ   P,GCREC         ; get a cud record
         JRST   CMLUC1
	TLNE	FLG,U.NET	; skip if we are not network types
	 JRST	CMLUC2
        PUSHJ   P,CHKUUN        ; see if we have access
         JRST   CMLUC1
CMLUC2:	PUSHJ   P,LCREC         ; output it
        JRST    CMLUC1
LUCDON:
        TRO     FLG,U.OKAY
        POPJ    P,
GCREC:  ; get a cud record for user in UNMSPC
        SETZM   NMSTRT          ; clear entire cud rec area
        MOVE    AC,[NMSTRT,,NMSTRT+1]
        BLT     AC,NMEND-1      ; do it
        PUSHJ   P,GETCUD        ; build a circuit
         JRST   GETCMD
        SNDBYT  (CUDPRT,\B.CCOM,LUSMUD,I) ; send the command
        PUSHJ   P,SNMCUD        ; send the username
        PUSHJ   P,SND40
        PUSHJ   P,NGANS         ; get answer
         PUSHJ  P,ERRCUD        ; check for fatal error
        MOVE    AC,NMANS
        CAIE    AC,1
         POPJ   P,              ; we are not going to get a record
        GETBYT  (CUDPRT)        ; waste the first byte
         JRST   GETCMD
        GETBYT  (AC,\B.GAN)     ; get the gan
         JRST   GETCMD
        MOVEM   AC1,NMGAN
        GETBYT  (AC)            ; waste another
         JRST   GETCMD
        GETBYT  (AC,\B.UUN)     ; get the uun
         JRST   GETCMD
        MOVEM   AC1,NMUUN
        GETBYT  (AC,\B.CPR)     ; get cparw
         JRST   GETCMD
        LSH     AC1,^D8         ; adjust
        MOVEM   AC1,NMCPAR
        GETBYT  (AC,\B.CLN)     ; get colon word
         JRST   GETCMD
        LSH     AC1,^D16        ; adjust
        TLZ     AC1,(1B14)      ; don't know what this bit is
        MOVEM   AC1,NMCOLN
        GETBYT  (AC,\B.CDST)    ; get district
         JRST   GETCMD
        MOVEM   AC1,NMDIST
        GETBYT  (AC,\B.IRC)     ; get irc code
         JRST   GETCMD
        MOVEM   AC1,NMIRC
        PUSHJ   P,GCCLS         ; get class info
        GETBYT  (AC,\B.PDT)     ; cubs format passdate
         JRST   GETCMD
        MOVEM   AC1,NMPDAT
        PUSHJ   P,GET40         ; get terminator
GTPDAT:	SNDBYT  (CUDPRT,\B.CCOM,LD2MUD,I) ; get passdate in pdp-10 format
        PUSHJ   P,SNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         PUSHJ  ERRCUD
        MOVE    AC,NMANS
        CAIE    AC,1
         POPJ   P,
        GETBYT  (CUDPRT)                ; get month
         JRST   GETCMD
        MOVEM   AC1,NMPMON      ; month of password
        GETBYT  (AC)            ; get day
         JRST   GETCMD
        MOVEM   AC1,NMPDAY      ; day of month of password
        GETBYT  (AC)            ; get year
         JRST   GETCMD
	SKIPG	NMPDAY		; skip if nmpday not zero
	 JRST	[AOS	NMPDAY
		 AOS	NMPMON
		 MOVEI	AC1,^D72
		 MOVEM	AC1,NMPYR
		 JRST	GCREC3]
	CAMLE   AC1,LYDIG       ; skip if last dig of pdate less current
         JRST   GCREC2
        ADD     AC1,DECADE      ; add in the decade
        MOVEM   AC1,NMPYR       ; year (adjusted)
        JRST    GCREC3
GCREC2: ADD     AC1,DECADE
        SUBI    AC1,^D10        ; last decade
        MOVEM   AC1,NMPYR
GCREC3:
        PUSHJ   P,GET40         ; get terminator
        AOS     0(P)
        POPJ    P,

GCCLS:  ; get class info from cud
        MOVEI   AC1,NMCLSS      ; get address
        MOVEM   AC1,CLSIND
GCCLS2: GETBYT  (CUDPRT)                ; input a byte
         JRST   GETCMD
        CAIN    AC1,377         ; skip if not end of class info
         JRST   GCCLS4
        MOVEM   AC1,GRPCTR      ; save number of groups
        MOVEM   AC1,@CLSIND     ; save address
        AOS     CLSIND          ; and increment by 1
        GETBYT  (AC,\B.CLS)     ; get class
         JRST   GETCMD
        MOVEM   AC1,@CLSIND     ; save the class number
        AOS     CLSIND          ; increment pointer
GCLS2B: SOSGE   GRPCTR          ; see if any hosts and groups left
         JRST   GCCLS3          ; next
        GETBYT  (AC,\B.GRPH)    ; get a host or group
         JRST   GETCMD
        MOVEM   AC1,@CLSIND     ; save it
        AOS     CLSIND          ; increment pointer
        JRST    GCLS2B
GCCLS3: AOS     CLSCTR          ; increment position counter
        MOVE    AC1,CLSCTR      ; compute new clsind
        IMULI   AC1,NMSZCS
        ADDI    AC1,NMCLSS
        MOVEM   AC1,CLSIND      ; and save it
        JRST    GCCLS2          ; do next class if any
GCCLS4:
        POPJ    P,              ; all done, return

LCREC:  ; output cud record to terminal
        TCR     (1)
        MOVEI   AC,UNMSPC       ; address of username
        PUSHJ   P,NAMOUT        ; output name
        MOVE    AC,NMGAN        ; get gan
        PUSHJ   P,GANOUT        ; output it
        MOVE    AC,NMUUN        ; uun
        PUSHJ   P,UUNOUT
        MOVE    AC,NMDIST       ; district
        PUSHJ   P,DISOUT
        MOVE    AC,NMIRC        ; irc
        PUSHJ   P,IRCOUT
        PUSHJ   P,PDTOUT        ; passdate from nmpmon, nmpday, nmpyr
        PUSHJ   P,CPROUT        ; cparw from nmcpar
        PUSHJ   P,CLNOUT        ; colon from nmcoln
        PUSHJ   P,CLSOUT        ; classes
        POPJ    P,
CMDLUP:	; list user passdate
comment `
 note that this command currently requires U.PRV status; if it is ever
 released to the public, then access checking must be included.
`
	TCR	(1)
	PUSHJ	P,GETCUD
	 JRST	GETCMD
; input cutoff date
	INDAT	([ASCIZ/Cutoff Date :/])
	 JRST	[PUSHJ	P,INORNO
		 JRST	CMDLUP]
	PUSHJ	P,GETODF		; output destination
	SETFM	(^D8)
CMLUP1:	TCRNL	(1)
	PUSHJ	P,GETUNM	; get a username
	 JRST	CMLUPD
	PUSHJ	P,GCREC		; get cud record
;	PUSHJ	P,GTPDAT	; go get password date stamp
	 JRST	CMLUPE
	MOVE	AC,NMCOLN	; get colon word
	TLNE	AC,NPS.CD	; skip if no-psw bit is not set
	 JRST	[MOVEI	AC,^D100101
		 MOVEM	AC,NMPDAT
		 JRST	CMLUP2]
	MOVE	AC,NMPYR	; now convert passdate to YYMMDD for compare.
	IMULI	AC,^D10000
	MOVE	AC1,NMPMON
	CAIN	AC1,377
	 JRST	CMLUP1		; gfd-only name.
	IMULI	AC1,^D100
	ADD	AC,AC1
	MOVEM	AC,NMPDAT
	MOVE	AC,NMPDAY
	ADDM	AC,NMPDAT
	MOVE	AC1,DATSPC	; compare to date input from term
	CAMG	AC1,NMPDAT	; skip if it's larger
	 JRST	CMLUP1		; next.
CMLUP2:
; we are now going to abuse list output.  Since list output will only output
; one item per line, we'll convert the username and passdate to one item.
	MOVE	AC,[UNMSPC,,LUPOSP]
	BLT	AC,LUPOSP+2	; copy the username.
	MOVEI	AC4,^D10
	MOVE	AC,NMPDAT
	PUSHJ	P,NUMOUT	; convert passdate to ascii (yymmdd fmt).
	DMOVE	AC,NUMSP	; move it
	DMOVEM	AC,LUPOSP+3
	MOVE	AC,NMDIST
	MOVEI	AC4,^D10
	PUSHJ	P,NUMOUT
	MOVE	AC,NUMSP
	MOVEM	AC,LUPOSP+5
	MOVE	AC,NMGAN
	MOVEI	AC4,^D8
	PUSHJ	P,NUMOUT
	DMOVE	AC,NUMSP
	DMOVEM	AC,LUPOSP+6
	TCRNL	(1)
	MOVEI	AC,LUPOSP+4
	MOVEI	AC1,<LUPOLN-4>*5
	PUSHJ	P,NONL
	TYPLIS	(LUPOSP,LUPOLN*5)	; and output it.
	JRST	CMLUP1

CMLUPE:	; error from gtpdat routine
	JRST	CMLUP1

CMLUPD:
	TRNE	FLG,U.LFO
	 PUSHJ	P,CLSODF	; release output destination.
	SETFM	(0)		; reset format to floating.
	TRO	FLG,U.OKAY	; return.
	POPJ	P,

NONL:	; substitute blanks for nulls
; ac/ address of string
; ac1/ length
	HRLI	AC,(POINT 7)	; make a byte pointer
NONL1:	ILDB	AC2,AC
	JUMPG	AC2,NONL2
	MOVEI	AC2,BLNK
	DPB	AC2,AC
NONL2:	SOJG	AC1,NONL1
	POPJ	P,
CMDLUA: ; list user accounting
	PUSHJ	P,LTT
        TCR     (1)
        PUSHJ   P,GETACC
         JRST   GETCMD
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,INASYS                ; get system type
        MOVEI   AC,LUTACT       ; for finast call
        MOVEM   AC,FINARG       ; save it
CMDLU2: TCR     (1)
        PUSHJ   P,GETUNM
         JRST   LUADON
        PUSHJ   P,GCREC
         JRST   CMDLU2
        PUSHJ   P,CHKUUN
         JRST   CMDLU2
        PUSHJ   P,GUAREC
         JRST   CMDLU2
        PUSHJ   P,LUAREC
        JRST    CMDLU2
LUADON:
        TRO     FLG,U.OKAY
        POPJ    P,

GUAREC: ; get user acctg record
        SETZM   UASTRT          ; set all to zeroes
        MOVE    AC,[UASTRT,,UASTRT+1]
        BLT     AC,UAEND-1              ; clear usr acctg area
        MOVE    AC,NMUUN
        MOVEM   AC,FINAR2
        PUSHJ   P,FINAST
         JRST   GUARCE
        SNDBYT  (ACTPRT,\B.ACOM,LUEACT,I) ; send the command
        SNDBYT  (AC,\B.UUN,NMUUN)       ; and the uun
        SNDBYT  (ACTPRT,\B.ACOM,ACTSY2) ; actg sys type
        GETBYT  (ACTPRT)
         JRST   GETCMD
        CAIE    AC1,ACT.OK      ; skip if ok
         JRST   GUARCE
        GETBYT  (AC,\B.GAN)     ; input the gan
         JRST   GETCMD
        MOVEM   AC1,UAGAN
        PUSHJ   P,GNAMAC        ; get username
        GETBYT  (AC,\B.DIS)     ; input district
         JRST   GETCMD
        MOVEM   AC1,UADIS
        GETBYT  (AC,\B.CID)     ; get cid
         JRST   GETCMD
        MOVEM   AC1,UACID
        PUSHJ   P,GCNAAC        ; input customer name
	GETBYT  (AC,\B.CC)
	 JRST	GETCMD
	MOVEM	AC1,UACC
        GETBYT  (AC,\B.SLS)     ; input salesman
         JRST   GETCMD
        MOVEM   AC1,UASLS
        GETBYT  (AC,\B.PRI)     ; input pricing code
         JRST   GETCMD
        MOVEM   AC1,UAPRIC
        GETBYT  (AC,\B.RES)     ; input resource code
         JRST   GETCMD
        MOVEM   AC1,UARESC
        GETBYT  (AC,\B.CUR)     ; input currency code
         JRST   GETCMD
        MOVEM   AC1,UACURC
        GETBYT  (AC,\B.LAN)     ; input language code
         JRST   GETCMD
        MOVEM   AC1,UALANC
        GETBYT  (AC,\B.TZ)      ; input time zone
         JRST   GETCMD
        MOVEM   AC1,UATZ
        PUSHJ   P,GHSTAC        ; input hosts
GUARCD: AOS     0(P)
        POPJ    P,
GUARCE: TYPSTR  ([ASCIZ\No acctg record for this uun/system type\])
        POPJ    P,

LUAREC: ; list user accounting record
        TCR     (1)
        MOVEI   AC,UNMSPC
        PUSHJ   P,NAMOUT        ; output username
        PUSHJ   P,ASTSOU        ; output acct. sys. type
        MOVE    AC,UAGAN
        PUSHJ   P,GANOUT        ; output gan
	MOVE	AC,UACC
	PUSHJ	P,CCOUT
        MOVE    AC,UADIS
        PUSHJ   P,DISOUT        ; output district
        MOVE    AC,UACID
        PUSHJ   P,CIDOUT        ; output cid
        MOVEI   AC,UACNM
        PUSHJ   P,CSNOUT        ; output customer name
        MOVE    AC,UASLS
        PUSHJ   P,SLSOUT        ; output salesman
        PUSHJ   P,CUROUT        ; output currency
        PUSHJ   P,LANOUT        ; output language
        MOVE    AC,UATZ         ; get time zone
        PUSHJ   P,ZONOUT        ; output time zone
        PUSHJ   P,HSTOUT        ; output hosts
        TCR     (1)
        POPJ    P,

GNAMAC: ; get a username from acctg
        GETSTR  (ACTPRT,L.UNM,UAUNM)
        POPJ    P,

GHSTAC: ; get valid hosts from acctg (for user or customer)
        SETZM   UAHST
        MOVE    AC,[UAHST,,UAHST+1]
        BLT     AC,UAHSTP
        
        MOVEI   AC,UAHST
        MOVEM   AC,UAHSTP
        MOVE    AC,ACTPRT
GHSTA2: GETBYT  (AC,\B.HST)
         JRST   GETCMD
        CAIN    AC1,177777
         JRST   GHSTA3
        MOVEM   AC1,@UAHSTP
        AOS     UAHSTP
        JRST    GHSTA2          ; next one
GHSTA3: MOVE    AC1,UAHSTP
        SUBI    AC1,UAHST
        MOVEM   AC1,UAHSTP
        POPJ    P,
GCCAC:  ;get a costcode from accounting
        GETSTR  (ACTPRT,B.CC,UACC)
        POPJ    P,                      ;return
GCNAAC: ; get customer name from ac
        GETSTR  (ACTPRT,L.CUSN,UACNM)
        POPJ    P,

CMDLUL: ; list user lud
	PUSHJ	P,LTT
        TCR     (1)
        PUSHJ   P,GETHOS                ; input a host number and get circuit
         JRST   GETCMD
        PUSHJ   P,GETCUD
         JRST   GETCMD
        MOVE    AC,OLDASY
CMLUD2: TCR     (1)
        PUSHJ   P,GETUNM        ; get a username into unmspc
         JRST   LULDON
        PUSHJ   P,GCREC
         SETZM  NMUUN           ; reset cud uun word
        PUSHJ   P,CHKUUN
         JRST   CMLUD2
        PUSHJ   P,GLREC         ; get a lud record
         JRST   CMLUD2
        PUSHJ   P,LULREC        ; output it
        JRST    CMLUD2
LULDON:
        TRO     FLG,U.OKAY
        POPJ    P,

GLREC:  ; get user lud record
        MOVE    AC,OLDASY       ; get act sys type
        CAIN    AC,A10          ; skip if not a pdp10
         JRST   INPPDP
        CAIN    AC,A370         ; skip if not a 370
         TLNE   FLG,U.PRV       ; skip if not c/s lic
         SKIPA
         JRST   GLREC0          ; if a 370 type with no c/s lic
        SNDBYT  (OLDPRT,\B.LCOM,LE2LUD,I) ; list user lud (370 with pw)
        JRST    GLREC1
GLREC0: SNDBYT  (OLDPRT,\B.LCOM,LE1LUD,I) ; 370 list user lud no pw
GLREC1:
        MOVE    AC,OLDASY       ; get act sys again
        CAIN    AC,A370         ; skip if not 370
         JRST   GLREC2
        SNDSTR  (OLDPRT,L.UNM,UNMSPC)   ; send 12 byte uname
        JRST    GLREC3
GLREC2: SNDSTR  (OLDPRT,L.UNM3,UNMSPC)  ; send 8 byte uname
GLREC3:
        GETBYT  (OLDPRT)        ; get answer
         JRST   GETCMD
        CAIE    AC1,1           ; skip if ok
         JRST   GLRECE
        MOVE    AC,OLDASY       ; act sys one more time
        CAIN    AC,A370
         JRST   GLRECD          ; for 370, don't input info yet
; get tymcom-10 lud info, first get tru budget and init file from salve LMVLUD
INPPDP: SNDBYT  (OLDPRT,\B.LCOM,LMVLUD,I)
        SNDSTR  (OLDPRT,L.UNM,UNMSPC)
        GETBYT  (OLDPRT)
         JRST   GETCMD
        CAIE    AC1,1
         JRST   GLRECE
        GETBYT  (OLDPRT,\B.GAN) ; get the gan
         JRST   GETCMD
        GETBYT  (OLDPRT,\B.UUN) ; get uun
         JRST   GETCMD
        GETBYT  (OLDPRT,\B.DIS) ; get district
         JRST   GETCMD
        GETBYT  (OLDPRT,\B.MIS) ; get misc. bits
         JRST   GETCMD
        MOVEM   AC1,LUXMIS 
        SETZM   LUXBUD
        TRNN    AC1,BUD.MI      ; skip if tru bit is on
         JRST   INPINI
        GETBYT  (OLDPRT,\B.BUD) ; get tru bit
         JRST   GETCMD
        MOVEM   AC1,LUXBUD
INPINI: MOVE    AC1,LUXMIS
        TRNN    AC1,INF.MI      ; skip if init file bit on
         JRST   INPPRV
        GETSTR  (OLDPRT,L.UNM,LUXUSN)
        GETSTR  (OLDPRT,L.INF,LUXPRN)
INPPRV: GETBYT  (OLDPRT,3)      ; get privilege bits
         JRST   GETCMD
        GETBYT  (OLDPRT,3)
         JRST   GETCMD
        GETBYT  (OLDPRT,\B.QUOT) ; get login quota
         JRST   GETCMD
        GETBYT  (OLDPRT,\B.QUOT) ; get logout quota
         JRST   GETCMD
        ; now we are really listing user lud info
        SNDBYT  (OLDPRT,\B.LCOM,LE2LUD,I)
        SNDSTR  (OLDPRT,L.UNM,UNMSPC)
        GETBYT  (OLDPRT)
         JRST   GETCMD
        CAIE    AC1,1
         JRST   GLRECE
        GETBYT  (OLDPRT,\B.GAN) ; get the gan
         JRST   GETCMD
        MOVEM   AC1,LUXGAN
        GETBYT  (AC,\B.UUN)     ; get uun
         JRST   GETCMD
        MOVEM   AC1,LUXUUN
        GETBYT  (AC,\B.DIS)     ; get district
         JRST   GETCMD
        MOVEM   AC1,LUXDIS
        GETBYT  (AC,\B.PRV)     ; get privilege bits
         JRST   GETCMD
        LSH     AC1,^D12        ; left adjust
        MOVEM   AC1,LUXPRV
        GETBYT  (AC,\B.TZ)      ; get time zone
         JRST   GETCMD
        MOVEM   AC1,LUXTZ
        GETBYT  (AC,\B.QUOT)    ; get login quota
         JRST   GETCMD
        MOVEM   AC1,LUXQIN
        GETBYT  (AC,\B.QUOT)    ; get logout quota
         JRST   GETCMD
        MOVEM   AC1,LUXQOT
        JRST    GLRECD

GLRECD: ; done with get lud record
        AOS     0(P)
        POPJ    P,

GLRECE: ; error getting lud record
        TYPSTR  ([ASCIZ /Username/],777,0,0,N)
        TYPSTR  (UNMSPC,L.UNM,1,0,N)
        TYPSTR  ([ASCIZ/not found in Lud on host/],777,1,0,N)
        TYPNUM  (OLDHOS,D,1)
        POPJ    P,

LULREC: ; list user lud record
        TCR     (1)
        MOVE    AC,OLDASY       ; get system type
        CAIN    AC,A370
         JRST   LUL370          ; do 370 list user lud
; here to output tymcom-10 lud info
        MOVEI   AC,UNMSPC
        PUSHJ   P,NAMOUT        ; output username
        MOVE    AC,LUXGAN
        PUSHJ   P,GANOUT        ; output gan
        MOVE    AC,LUXUUN
        PUSHJ   P,UUNOUT        ; output uun
        MOVE    AC,LUXDIS
        PUSHJ   P,DISOUT        ; output district
        MOVE    AC,LUXTZ
        PUSHJ   P,ZONOUT        ; output timezone
        MOVE    AC,LUXQIN
        PUSHJ   P,QINOUT        ; output login quota
        MOVE    AC,LUXQOT
        PUSHJ   P,QOTOUT        ; output logout quota
        PUSHJ   P,BUDOUT        ; output tru budget, BUDOUT can be found
                                ; in Change User (tru) Budget command
        PUSHJ   P,INITOU        ; output init file
        MOVE    AC,LUXPRV
        PUSHJ   P,PRVOUT        ; output license
        POPJ    P,              ; and return
LUL370: ; output list user lud record from 370
;  370 circuit input has not been read yet, just output each char as it comes.
; (1point and 1rdusr send us symbolic output similar to rdusr).
        MOVEI   AC,T.P0
        PUSHJ   P,TABS
LUL372: GETBYT  (OLDPRT)
         JRST   GETCMD
        CAIN    AC1,377         ; skip if not a terminator
         JRST   LUL373
        MOVEI   AC,40(AC1)      ; move and make ascii
        PUSHJ   P,CHROUT        ; output it
        JRST    LUL372          ; and get next one
LUL373: TCR     (1)             ; echo crlf for terminator
        GETBYT  (OLDPRT)        ; get another byte
         JRST   GETCMD
        CAIN    AC1,377         ; see if another terminator
         JRST   LUL374          ; yes it is, end of data
        MOVEI   AC,40(AC1)
        MOVEM   AC,NUM
        MOVEI   AC,T.P0
        PUSHJ   P,TABS
        MOVE    AC,NUM
        PUSHJ   P,CHROUT        ; else type it out.
        JRST    LUL372          ; and get next char
LUL374: ; here on end of data from 370 list user lud
        POPJ    P,


CMDLUM: ; list user mailing address
	PUSHJ	P,LTT
        TCR     (1)
        PUSHJ   P,GETHOS                ; input a host number and get circuit
         JRST   GETCMD
        MOVE    AC,OLDASY
        CAIE    AC,A370
         JRST   [TYPSTR  ([ASCIZ/Cmd only available for 370/])
                 JRST    GETHOS]
CMLUM2: TCR     (1)
        PUSHJ   P,GETUNM        ; get a username into unmspc
         JRST   LUMDON
        PUSHJ   P,GMAIL         ; get mailing address
         JRST   CMLUM2
        PUSHJ   P,LUMAIL        ; output it
        JRST    CMLUM2
LUMDON:
        TRO     FLG,U.OKAY
        POPJ    P,

GMAIL:  ; get user mailing address
        SNDBYT  (OLDPRT,\B.LCOM,LMALUD,I)
        SNDSTR  (AC,L.UNM3,UNMSPC)
        GETBYT  (OLDPRT)              ; get answer
         JRST   GETCMD
        CAIE    AC1,1                 ; skip if ok
         JRST   [PUSHJ   P,LUDAOT     ; error
                 POPJ    P,]
        GETSTR  (OLDPRT,L.ST,ST1)
        GETSTR  (OLDPRT,L.ST,ST2)
        GETSTR  (OLDPRT,L.ST,ST3)
        GETSTR  (OLDPRT,L.ST,ST4)
        GETSTR  (OLDPRT,L.ST,ST5)
        GETSTR  (OLDPRT,L.ST,ST6)
        GETSTR  (OLDPRT,L.ST,ST7)
        GETSTR  (OLDPRT,L.ST,ST8)
        AOS     0(P)
        POPJ    P,
 
GMAILE: ; error in getting mail address
LUMAIL: ; output mailing address
        TYPSTR  (ST1,L.ST,0,T.P2)
        TYPSTR  (ST2,L.ST,0,T.P2)
        TYPSTR  (ST3,L.ST,0,T.P2)
        TYPSTR  (ST4,L.ST,0,T.P2)
        TYPSTR  (ST5,L.ST,0,T.P2)
        TYPSTR  (ST6,L.ST,0,T.P2)
        TYPSTR  (ST7,L.ST,0,T.P2)
        TYPSTR  (ST8,L.ST,0,T.P2)
        POPJ    P,
  
 
 
 
 
 
NAMOUT: ; output username from address in ac
        MOVEM   AC,NUM
        TYPSTR  ([ASCIZ/Username :/],777,0,T.P0,N)
        TYPSTR  (@NUM,L.UNM,0,T.P2)
        POPJ    P,

GANOUT: ; ouput the gan in ac
        MOVEM   AC,NUM
        TYPSTR  ([ASCIZ/Gan :/],777,0,T.P0,N)
        TYPNUM  (NUM,O,0,T.P2)
        POPJ    P,

RCIOUT: ; output the cid in ac, cusnam fro adr in ac1 (tym rec cust)
        MOVEM   AC,NUM
        MOVEM   AC1,NUM1
        TYPSTR  ([ASCIZ/Rec. Cid :/],777,0,T.P0,N)
        TYPNUM  (NUM,D,0,T.P2,N)
        MOVE    AC,NUM1
        MOVEI   AC1,5
        PUSHJ   P,CNTCHR        ; check length of name
        JUMPE   AC1,RCIOUD      ; if it's zero, we're done.
        TYPSTR  ([ASCIZ/-/],777,1,0,N)
        TYPSTR  (@NUM1,L.CUSN,1,0,N)
RCIOUD: TCR     (1)
        POPJ    P,

SDTOUT: ; output start date from adrs in ac
        MOVEM   AC,NUM
        TYPSTR  ([ASCIZ/Start Date :/],777,0,T.P0,N)
        MOVE    AC1,NUM
        MOVE    AC,0(AC1)
        MOVEM   AC,NUM1
        TYPNUM  (NUM1,D,0,T.P2,N)       ; output mm
        TYPSTR  ([ASCIZ/-/],777,0,0,N)
        MOVE    AC1,NUM
        MOVE    AC,1(AC1)
        MOVEM   AC,NUM1
        TYPNUM  (NUM1,D,0,0,N)          ; output dd
        TYPSTR  ([ASCIZ/-/],777,0,0,N)
        MOVE    AC1,NUM
        MOVE    AC,2(AC1)
        MOVEM   AC,NUM1
        TYPNUM  (NUM1,D,0,0)            ; output yy
        POPJ    P,

DUNOUT: ; output destination username from adrs in ac
        MOVEM   AC,NUM
        TYPSTR  ([ASCIZ/Dest. User :/],777,0,T.P0,N)
        TYPSTR  (@NUM,L.UNM,0,T.P2)
        POPJ    P,

TDAOUT: ; output tymuse days from ac
        MOVEM   AC,NUM
        TYPSTR  ([ASCIZ/Hold days :/],777,0,T.P0,N)
        TYPNUM  (NUM,D,0,T.P2)
        POPJ    P,

CIDOUT: ; output the cid in ac
        MOVEM   AC,NUM
        TYPSTR  ([ASCIZ/Cid :/],777,0,T.P0,N)
        TYPNUM  (NUM,D,0,T.P2)
        POPJ    P,

CSNOUT: ; output the customer name from address in ac
        MOVEM   AC,NUM
        TYPSTR  ([ASCIZ/Cust Name :/],777,0,T.P0,N)
        TYPSTR  (@NUM,777,0,T.P2)
        POPJ    P,

UUNOUT: ; output the uun in ac
        MOVEM   AC,NUM
        TYPSTR  ([ASCIZ/Uun :/],777,0,T.P0,N)
        TYPNUM  (NUM,O,0,T.P2)
        POPJ    P,

IRCOUT: ; output the irc in ac
        JUMPE   AC,IRCOU2               ; no output if irc is zero
        MOVEM   AC,NUM
        TYPSTR  ([ASCIZ/Irc :/],777,0,T.P0,N)
        TYPNUM  (NUM,D,0,T.P2)
IRCOU2: POPJ    P,

CCOUT:	; output the cost center number in ac
	MOVEM	AC,NUM
	TYPSTR	([ASCIZ/Cost Code :/],777,0,T.P0,N)
	TYPNUM	(NUM,D,0,T.P2)
	POPJ	P,

DISOUT: ; output the district in ac
        MOVEM   AC,NUM
        TYPSTR  ([ASCIZ/Dist :/],777,0,T.P0,N)
        TYPNUM  (NUM,D,0,T.P2)
        POPJ    P,
FDOUT:  ; output the fd number in ac
        MOVEM   AC,NUM
        TYPSTR  ([ASCIZ/Fd : /],777,0,T.P0,N)
        TYPNUM  (NUM,O,0,T.P2)
        POPJ    P,


CLSOUT: ; output class info
        SETZM   CLSCTR          ; zero counter
CLSOU2: ; major loop for outputting class info
        TCR     (1)
        MOVE    AC1,CLSCTR      ; compute new pointer
        IMULI   AC1,NMSZCS
        ADDI    AC1,NMCLSS
        SKIPN   0(AC1)          ; check if we're done
         JRST   CLSOUD          ; done
        MOVEM   AC1,CLSIND      ; save it
        AOS     CLSCTR          ; increment position counter
        MOVE    AC,@CLSIND
        MOVEM   AC,GRPCTR       ; save # of groups in position
        MOVEI   AC,T.P0
        PUSHJ   P,TABS
        MOVEI   AC,"("          ; now ouptut position number
        PUSHJ   P,CHROUT
        TYPNUM  (CLSCTR,D,0,0,N)
        MOVEI   AC,")"
        PUSHJ   P,CHROUT
CLSWOT:	; we xfer here to display one class only, not numbered.
        TYPSTR  ([ASCIZ/Class :/],777,0,T.P1,N)
        AOS     CLSIND
        MOVE    AC,@CLSIND      ; get class number in ac
        TRZ     FLG,U.UDF
        TRZE    AC,UDF.CD       ; skip if not self-defining
         JRST   CLSO2C
        TYPNUM  (@CLSIND,D,0,T.P2) ; output class number
        JRST    CLSO2B
CLSO2C: TRZ     AC,UDN.CD       ; zero negative class bit
        IDIVI   AC,2            ; change byte to word cnt
        MOVEM   AC,CLSCT2       ; save it
        TYPSTR  ([ASCIZ/Self Defining/],777,0,T.P2,N)
        MOVE    AC,@CLSIND
        TRNN    AC,UDN.CD       ; skip if negative class
         JRST   CLSO2D
        TYPSTR  ([ASCIZ/- Exception Class/],777,1,0,N)
CLSO2D:
        TCR     (1)
        TRO     FLG,U.UDF
CLSO2B: SOSGE   GRPCTR          ; skip if hosts or groups left
         JRST   CLSOU2
        AOS     CLSIND
        MOVE    AC,@CLSIND      ; get a host or group word
        TRZN    AC,GRP.CD       ; skip if it is a group
         JRST   CLSOU3
        TRZE    AC,HOM.CD       ; skip if it's not a home
         TRO    FLG,U.HOM       ;  set home bit
        MOVEM   AC,NUM
        TYPSTR  ([ASCIZ/Group :/],777,0,T.P1,N)
        TYPNUM  (NUM,D,0,T.P2,N)       ; output the group number
        JRST    CLSOU4
CLSOU3: TRNN    FLG,U.UDF       ; skip if this is a self defining class
         JRST   CLSO3B
        SOSGE   CLSCT2
         JRST   CLSO3B
        TRZE    AC,HOS.CD
         JRST   CLSO3C
        MOVEM   AC,NUM
        TYPSTR  ([ASCIZ/Node :/],777,0,T.P1,N)
        TYPNUM  (NUM,O,0,T.P2,N)
        JRST    CLSOU5
CLSO3B:
        MOVE    AC,@CLSIND
        TRZE    AC,HOM.CD       ; check if this is home system
         TRO    FLG,U.HOM       ; set home bit
CLSO3C: MOVEM   AC,NUM
        TYPSTR  ([ASCIZ/Host :/],777,0,T.P1,N)
        TYPNUM  (NUM,D,0,T.P2,N)       ; output the host
CLSOU4: TRZN    FLG,U.HOM
         JRST   CLSOU5
        TYPSTR  ([ASCIZ/- Home/],777,0,T.P3,N) ; output home indicator
CLSOU5: TCR     (1)
        TRNN    FLG,U.UDF       ; skip if self defining class
         JRST   CLSO2B
        SKIPE   CLSCT2          ; skip if just exhausted orig nodes
         JRST   CLSO2B
        TYPSTR  ([ASCIZ\* End of originating hosts/nodes\],777,0,T.P1)
        SETOM   CLSCT2
        JRST    CLSO2B  ; go do next host or group
CLSOUD: 
        POPJ    P,      ; all done

PDTOUT: ; output date in nmpday,nmpmon,nmpyr
        MOVE    AC,[77,,777777]
        CAMN    AC,NMPDAT               ; skip if not gfd only
         POPJ   P,
        TYPSTR  ([ASCIZ/Passdate :/],777,0,T.P0,N)
        TYPNUM  (NMPMON,D,0,T.P2,N)    ; output the month
        TYPSTR  ([ASCIZ/-/],777,0,0,N)
        TYPNUM  (NMPDAY,D,0,0,N)        ; output the day
        TYPSTR  ([ASCIZ/-/],777,0,0,N)
        TYPNUM  (NMPYR,D)               ; output the year
        POPJ    P,

CPROUT: ; translate and output cud lic word
        TYPSTR  ([ASCIZ/Lic :/],777,0,T.P0,N)
        MOVEI   AC,T.P2-1
        PUSHJ   P,TABS          ; tab over to correct space
        SKIPN   NMCPAR          ; skip if some bits are set
         POPJ   P,
        MOVE    AC,NMCPAR
        TLNN    AC,LOS.CD
         JRST   CPROU2
        TYPSTR  ([ASCIZ/Los/],777,1,0,N)
        MOVE    AC,NMCPAR
CPROU2: TRNN    AC,GTW.CD
         POPJ   P,
        TYPSTR  ([ASCIZ/Gty/],777,1,0,N)
        POPJ    P,              ; all done with crarw

CLNOUT: ; translate and output colon option word
; this routine should always be called after cprout
        MOVE    AC,LPOST        ; check our position
        TLNE    FLG,U.TOUT
         MOVE   AC,LPOSF
        CAIG    AC,^D45         ; skip if gt 45
         JRST   CLNOU0          ; don't start a new line
        TCR     (1)
        MOVEI   AC,T.P2-1       ; tab
        PUSHJ   P,TABS
CLNOU0: MOVE    AC,NMCOLN
        TLNE    AC,BIL.CD
         JRST   CLNOU1
        TYPSTR  ([ASCIZ/Bill/],777,1,0,N)
        MOVE    AC,NMCOLN
CLNOU1: TLNN    AC,BIL.CD
         JRST   CLNOU2
        TYPSTR  ([ASCIZ/Non-bill/],777,1,0,N)
        MOVE    AC,NMCOLN
CLNOU2: TLNN    AC,CLN.CD
         JRST   CLNOU3
        TYPSTR  ([ASCIZ/No-colon/],777,1,0,N)
        MOVE    AC,NMCOLN
CLNOU3: TLNN    AC,NPS.CD
         JRST   CLNOU4
        TYPSTR  ([ASCIZ/No-psw/],777,1,0,N)
CLNOU4:
        MOVE    AC,[77,,777777]
        CAME    AC,NMPDAT               ; skip if gfd only
         JRST   CLNOU5
        TYPSTR  ([ASCIZ/Gfd-only/],777,1,0,N)
CLNOU5:
        TCR     (1)
        POPJ    P,

SLSOUT: ; output the salesman number in ac
        MOVEM   AC,NUM
        TYPSTR  ([ASCIZ/Salesman :/],777,0,T.P0,N)
        TYPNUM  (NUM,D,0,T.P2)
        POPJ    P,

CUROUT: ; output the currency from code in uapric
        TYPSTR  ([ASCIZ/Currency :/],777,0,T.P0,N)
        MOVE    AC1,UACURC
        CAILE   AC1,CURLEN
         JRST   CUROU2
        ADDI    AC1,CURTAB
        MOVEI   AC1,@-1(AC1)
        MOVEM   AC1,NUM
        TYPSTR  (@NUM,777,0,T.P2)
        POPJ    P,
CUROU2:
        MOVEM   AC,NUM
        TYPNUM  (NUM,D,0,T.P2)
        POPJ    P,
CURTAB: [ASCIZ/US Dollars/]
        [ASCIZ/French Francs/]
        [ASCIZ/English Pounds/]
        [ASCIZ/Belgian Francs/]
        [ASCIZ/German Marks/]
        [ASCIZ/Japanese Yen/]
        [ASCIZ/Dutch Dfl/]
        [ASCIZ/Swiss Francs/]
        [ASCIZ/Canadian Dollars/]
CURLEN==.-CURTAB

ZONOUT: ; output time zone in ac
        MOVEM   AC,TZSAV
        TYPSTR  ([ASCIZ/Time Zone :/],777,0,T.P0,N)
        MOVE    AC1,TZSAV
        CAIN    AC1,^D48
         ADDI   AC1,2
        TRZ     AC1,TZMASK
        CAILE   AC1,TZLEN
         SETZ   AC1,
        ADDI    AC1,TZTAB
        MOVEI   AC1,@0(AC1)
        MOVEM   AC1,NUM
        TYPSTR  (@NUM,777,0,T.P2,N)
        MOVE    AC1,TZSAV
        TRNN    AC1,TZMASK
         JRST   ZONOU2
        TYPSTR  ([ASCIZ/- Subject to daylight savings/],777,2)
        JRST    ZONOU3
ZONOU2: TCR     (1)
ZONOU3: POPJ    P,

TZTAB:  NOTZ
        NOTZ
        NOTZ
        NOTZ
        NOTZ
        NOTZ
        [ASCIZ/Hawaii and Alaska/]
        NOTZ
        [ASCIZ/Pacific/]
        [ASCIZ/Mountain/]
        [ASCIZ/Central/]
        [ASCIZ/Eastern/]
        [ASCIZ/Atlantic/]
        NOTZ
        NOTZ
        NOTZ
        [ASCIZ/Greenwich/]
        [ASCIZ/Central Europe/]
        [ASCIZ/Western Europe/]
        NOTZ
        NOTZ
        NOTZ
        NOTZ
        NOTZ
        NOTZ
        [ASCIZ/Japan/]
        [ASCIZ/Brisbane/]
        NOTZ
        NOTZ
        NOTZ
        NOTZ
        NOTZ
        NOTZ
        NOTZ
TZLEN==.-TZTAB
NOTZ:   ASCIZ   /Undefined time zone/

ASTOUT: TYPSTR  ([ASCIZ/Sys. Type :/],777,0,T.P0,N)
        MOVE    AC1,ACTSY2              ;put asys # in ACTSY2
        CAILE   AC1,ASTLEN              ;if # l.e. asys # then use ASTTAB
         JRST   ASTOU2                  ;# > length(table) ;so; just type #
        ADDI    AC1,ASTTAB              ;setup for indexing into ASTTAB
        MOVEI   AC1,@-1(AC1)            ;setup for indexing into ASTTAB
        MOVEM   AC1,NUM                 ;NUM now holds locale of asys.type string
        TYPSTR  (@NUM,777,0,T.P2)       ;type it out
        POPJ    P,
ASTOU2: MOVEM   AC1,NUM
        TYPNUM  (NUM,D,0,T.P2)          ;type the # instead of the description
        POPJ    P,

ASTSOU:	TYPSTR	([ASCIZ/Sys. Type :/],777,0,T.P0,N)
	MOVE	AC1,ACTSY2
	CAILE	AC1,ASTLEN
	 JRST	ASTOU2
	ADDI	AC1,ASTSTB-1
	MOVEI	AC1,@0(AC1)
	MOVEM	AC1,NUM
	TYPSTR	(@NUM,777,0,T.P2)
	POPJ	P,

ASTSTB:	
	[ASCIZ	/Tymcom-10/]
	[ASCIZ	/Tymcom-9/]
	[ASCIZ	/Tymcom-370/]

ICDOUT: TYPSTR  ([ASCIZ/Ind. Code :/],777,0,T.P0,N)
        TYPNUM  (NMSIC,D,0,T.P2,N)
        TYPSTR  ([ASCIZ/-/],1,1,0,N)
        TYPSTR  (NMSICD,L.INDN,1)
        POPJ    P,

MNCOUT: TYPSTR  ([ASCIZ/Minimum :/],777,0,T.P0,N)
        TYPSTR  ([ASCIZ/None/],777,0,T.P2)
        POPJ    P,

VRPOUT: TYPSTR  ([ASCIZ/Var. Pric. :/],777,0,T.P0,N)
        TYPSTR  ([ASCIZ/No/],777,0,T.P2)
        POPJ    P,

POOUT:  TYPSTR  ([ASCIZ/P.O. No. :/],777,0,T.P0,N)
        TYPSTR  (ACPONM,L.PO,0,T.P2)
        POPJ    P,

POMOUT: TYPSTR  ([ASCIZ/P.O. Limit :/],777,0,T.P0,N)
        MOVE    AC1,ACPOMX              ;get ready for value test
        JUMPE   AC1,POMOU2              ;if AC1/ACPOMX==0 goto POMOU2
        TYPNUM  (ACPOMX,D,0,T.P2)       ;type the value
        POPJ    P,
POMOU2: TYPSTR  ([ASCIZ/None /],777,0,T.P2)     
        POPJ    P,

DFPOUT: TYPSTR  ([ASCIZ/Def. Price :/],777,0,T.P0,N)
        MOVE    AC,ACDEFP               ;move def.pri.code to ACDEFP
        CAIN    AC,1
         JRST   DFPO1           ;since ACDEFP=1 goto DFPO1 to type msg.
        CAIN    AC,5
         JRST   DFPO5           ;since ACDEFP=5 goto DFPO5 to type msg.
        CAIN    AC,^d8
         JRST   DFPO8           ;since ACDEFP = 8 goto DFPO8 to type msg.
        CAIN    AC,^d99         ;since ACDEFP = 99 goto DFPO99 to type msg.
         JRST   DFPO99
        TYPNUM  (ACDEFP,D,0,T.P2)       ;output def.pri.code as #
        POPJ    P,
DFPO1:  TYPSTR  ([ASCIZ/Standard Tymcom-10/],777,0,T.P2)
        POPJ    P,
DFPO5:  TYPSTR  ([ASCIZ/Standard Tymcom-9/],777,0,T.P2)
        POPJ    P,
DFPO8:  TYPSTR  ([ASCIZ/Standard Tymcom-370/],777,0,T.P2)
        POPJ    P,
DFPO99: TYPSTR  ([ASCIZ/Non-standard Pricing/],777,0,T.P2)
        POPJ    P,

ATNOUT: TYPSTR  ([ASCIZ/Attn :/],777,0,T.P0,N)
        TYPSTR  (ACATTN,L.ATTN,0,T.P2)
        POPJ    P,

ADROUT: TYPSTR  ([ASCIZ/Mailing Info :/],777,0,T.P0)
        TYPSTR  (ACSTR1,L.STRE,0,T.P2)
        TYPSTR  (ACSTR2,L.STRE,0,T.P2)
        TYPSTR  (ACCITY,L.CITY,0,T.P2,N)
        TYPSTR  (ACSTAT,L.STAT,3,0,N)
        TYPSTR  (ACZIP,L.ZIP,3)
        TYPSTR  (ACCTRY,L.CTRY,0,T.P2)
        POPJ    P,

ANNOUT: ; output anniversary date
        MOVEM   AC,NUM
        TYPSTR  ([ASCIZ/Anniversary :/],777,0,T.P0,N)
        JRST    PODOU2
 
PODOUT: MOVEM   AC,NUM          ;ac/num must contain ACPSDM or ACPEDM
        CAIE    AC,ACPSDM       ;if AC=ACPSDM then we're doing start date
         JRST   PODOU1          ;skip 'start date' section
        TYPSTR  ([ASCIZ/P.O. Start :/],777,0,T.P0,N)
PODOU1: MOVE    AC,NUM          ;restore original AC value to AC
        CAIE    AC,ACPEDM       ;if AC=ACPEDM we're doing stop date
         JRST   PODOU2          ;skip 'stop date' section
        TYPSTR  ([ASCIZ/P.O. Stop :/],777,0,T.P0,N)
PODOU2: MOVE    AC,@NUM         ;put value of loc. in NUM in AC
        MOVEM   AC,NUM1         ;move value (= ? date) to NUM1
        TYPNUM  (NUM1,D,0,T.P2,N)       ;type the month
        TYPSTR  ([ASCIZ/-/],777,0,0,N)  ;type a hyphen
        AOS     NUM             ;add one to NUM so as to reference day of date
        MOVE    AC,@NUM         ;put value of day in AC
        MOVEM   AC,NUM1         ;put it in NUM1
        TYPNUM  (NUM1,D,0,0,N)  ;type the day subsect. of date
        TYPSTR  ([ASCIZ/-/],777,0,0,N)  ;type the second hyphen
        AOS     NUM             ;add one to NUM so as to reference year of date
        MOVE    AC,@NUM         ;put value of  year in AC
        MOVEM   AC,NUM1         ;put value of year in NUM1
        TYPNUM  (NUM1,D)        ;type the year value
        POPJ    P,



INVOUT: TYPSTR  ([ASCIZ/Invoice :/],777,0,T.P0,N)
        MOVE    AC1,ACINVC      ;put inv.code # into AC1
        CAILE   AC1,INVLEN      ;if inv.code < length(INV.TABLE) skip
         JRST   INVOU2          ;go & output the inv.code #
        ADDI    AC1,INVTAB      ;set up index into table
        MOVEI   AC1,@-1(AC1)    ;complete the index setup
        MOVEM   AC1,NUM         ;move location of string to type to NUM
        TYPSTR  (@NUM,777,0,T.P2)       ;type the string indexed in table INVTAB
        POPJ    P,              ;non-skip return...all done
INVOU2: MOVEM   AC1,NUM         ;output # instead of description
        TYPNUM  (NUM,D,0,T.P2)  ;type it out
        POPJ    P,              ;non-skip return...all done

INVTAB: [ASCIZ/Standard/]
        [ASCIZ/Non-standard Special Handling/]
        [ASCIZ/Internal/]
        [ASCIZ/Non-standard Manual/]
INVLEN==.-INVTAB


DETOUT: TYPSTR  ([ASCIZ/Detail :/],777,0,T.P0,N)
        MOVE    AC1,ACDETC      ;put detail code # in AC1
        CAILE   AC1,DETLEN      ;if det.# <= LEN(DETTAB) use string from table
         JRST   DETOU2          ;no such index into table so just type # value
        ADDI    AC1,DETTAB      ;setup indexing into det.code table
        MOVEI   AC1,@-1(AC1)    ;finish indexing setup
        MOVEM   AC1,NUM         ;NUM has address of string to use
        TYPSTR  (@NUM,777,0,T.P2)       ;type the string @NUM
        POPJ    P,              ;non-skip return...all done
DETOU2: MOVEM   AC1,NUM
        TYPNUM  (NUM,D,0,T.P2)
        POPJ    P,


DETTAB: [ASCIZ/Full Detail; User's Zone/]
        [ASCIZ/Full Detail; GMT/]
        [ASCIZ/Full Detail; PST/]
        [ASCIZ/Summary/]
        [ASCIZ/Internal Summary/]
        [ASCIZ/No Detail/]
        [ASCIZ/No Detail/]
        [ASCIZ/Minimum Session Charge/]
DETLEN==.-DETTAB

LANOUT: ; output language from ualanc
        TYPSTR  ([ASCIZ/Language :/],777,0,T.P0,N)
        MOVE    AC1,UALANC
        CAILE   AC1,LANLEN
         JRST   LANOU2
        ADDI    AC1,LANTAB
        MOVEI   AC1,@-1(AC1)
        MOVEM   AC1,NUM
        TYPSTR  (@NUM,777,0,T.P2)
        POPJ    P,
LANOU2: MOVEM   AC1,NUM
        TYPNUM  (NUM,D,0,T.P2)
        POPJ    P,

LANTAB: [ASCIZ  /English/]
        [ASCIZ  /French/]
        [ASCIZ  /Crown's English/]
        [ASCIZ  /Belgian/]
        [ASCIZ  /German/]
        [ASCIZ  /Japanese/]
LANLEN==.-LANTAB

HSTOUT: ; output hosts user is valid on
        TYPSTR  ([ASCIZ/Hosts :/],777,0,T.P0,N)
        SETZM   UAHSTC
        MOVEI   AC,T.P2-1
        PUSHJ   P,TABS
HSTOU2:
        MOVE    AC1,UAHSTC      ; get count
        CAML    AC1,UAHSTP      ; skip if less then total
         JRST   HSTOUD
        MOVE    AC1,UAHST(AC1)  ; get the number
        MOVEM   AC1,NUM
        MOVE    AC,LPOST        ; get our current position
        TLNE    FLG,U.TOUT
         MOVE   AC,LPOSF
        CAIG    AC,^D65         ; skip if we are out of room on line
         JRST   HSTOU3
        TCR     (1)             ; type a carriage return
        MOVEI   AC,T.P2-1               ; tab
        PUSHJ   P,TABS
HSTOU3: TYPNUM  (NUM,D,1,0,N)   ; type the host number
        AOS     UAHSTC          ; increment count
        JRST    HSTOU2          ; do the rest
HSTOUD: TCR     (1)
        POPJ    P,

RESOUT: ; output resource code from uaresc
        POPJ    P,

QINOUT: ; output login quota from ac
        IDIVI   AC,4            ; convert blocks to pages
        MOVEM   AC,NUM          ; save it
        TYPSTR  ([ASCIZ/Login Quota :/],777,0,T.P0,N)
        TYPNUM  (NUM,D,0,T.P2)  ; output it
        POPJ    P,

QOTOUT: ; output the logout quota from ac
        IDIVI   AC,4            ; convert blocks to pages
        MOVEM   AC,NUM
        TYPSTR  ([ASCIZ/Logout Quota :/],777,0,T.P0,N)
        TYPNUM  (NUM,D,0,T.P2)  ; output logout quota
        POPJ    P,

INITOU: ; output init file
        TYPSTR  ([ASCIZ/Init File :/],777,0,T.P0,N)
        MOVE    AC,LUXMIS
        TRNN    AC,INF.MI             ; skip if init file bit on
         JRST   NONOUT
        MOVEI   AC,T.P2
        PUSHJ   P,TABS                ; move to position T.P2
        MOVEI   AC,"("
        PUSHJ   P,CHROUT
        TYPSTR  (LUXUSN,777,0,0,N)
        MOVEI   AC,")"
        PUSHJ   P,CHROUT              ; output it
        TYPSTR  (LUXPRN,777,0)
        POPJ    P,
NONOUT:
        TYPSTR  ([ASCIZ/None/],4,0,T.P2)
        POPJ    P,
 
PRVOUT: ; output the privilege bits in pdp10 lud
        MOVEM   AC,NUM
        TYPSTR  ([ASCIZ/Lic :/],777,0,T.P0,N)
        MOVEI   AC,T.P2-1
        PUSHJ   P,TABS          ; tab to correct position
        SKIPN   NUM
         JRST   PRVO11          ; no priv, just output mode
        MOVE    AC,NUM
        TLNN    AC,NOL.LX
         JRST   PRVO2
        TYPSTR  ([ASCIZ/Nolog/],777,1,0,N) ; no login
        MOVE    AC,NUM
PRVO2:  TLNN    AC,HSH.LX
         JRST   PRVO3
        TYPSTR  ([ASCIZ/Hush/],777,1,0,N) ; suppress tym msg
        MOVE    AC,NUM
PRVO3:  TLNN    AC,GFD.LX
         JRST   PRVO4
        TYPSTR  ([ASCIZ/Gfd/],77,1,0,N) ; gfd
        MOVE    AC,NUM
PRVO4:  TLNN    AC,BUD.LX
         JRST   PRVO5
        TYPSTR  ([ASCIZ/Cont/],777,1,0,N) ; budget present
        MOVE    AC,NUM
PRVO5:  TLNN    AC,DET.LX
         JRST   PRVO6
        TYPSTR  ([ASCIZ/Det/],777,1,0,N) ;det on disconnect
        MOVE    AC,NUM
        TLNN    AC,TMO.LX
         JRST   PRVO6
        TYPSTR  ([ASCIZ/-tmo/],777,0,0,N) ; 15 min timeout set
        MOVE    AC,NUM
PRVO6:  TLNN    AC,TYM.LX
         JRST   PRVO7
        TYPSTR  ([ASCIZ/Tym/],777,1,0,N)        ; Tymshare
        MOVE    AC,NUM
PRVO7:  TRNN    AC,BIL.LX
         JRST   PRVO8
        TYPSTR  ([ASCIZ/Bill/],777,1,0,N)       ; billable
        MOVE    AC,NUM
PRVO8:  TLNN    AC,RUB.LX
         JRST   PRVO9
        TYPSTR  ([ASCIZ/Rub/],777,1,0,N) ; rub
        MOVE    AC,NUM
PRVO9:  TLNN    AC,AS.LX
         JRST   PRVO10
        TYPSTR  ([ASCIZ/A.S./],777,1,0,N)
        MOVE    AC,NUM
PRVO10: TRNN    AC,RCM.LX
         JRST   PRVO11
        TYPSTR  ([ASCIZ/Rcm/],777,1,0,N)
        MOVE    AC,NUM
PRVO11: TCR     (1)     ; now to output mode
        MOVE    AC,[MOD.LX]     ; byte pointer for mode position
        TRO     AC,NUM          ; put in the address part
        LDB     AC1,AC          ; get the mode from the privilege word
        MOVEI   AC1,@XEXTAB(AC1) ; get the address of the name
        MOVEM   AC1,NUM ; save it
        TYPSTR  ([ASCIZ /Mode :/],777,0,T.P0,N)
        TYPSTR  (@NUM,777,0,T.P2)       ; output it
        POPJ    P,

XEXTAB: [ASCIZ /Pdp-10/]
        [ASCIZ /Xexec/]
        [ASCIZ /Xexec-J/]
        [ASCIZ /Suds/]

CMDLIN: ; list industry codes
	PUSHJ	P,LTT
        TCR     (1)
        PUSHJ   P,GETCUD                ; get cud circuit
         JRST   GETCMD
        SNDBYT  (CUDPRT,\B.CCOM,LAIMUD,I)       ; send command
        PUSHJ   P,SND40                 ; terminator char
        PUSHJ   P,NGANS                 ; get answer
         JRST   GETCMD
        SETFM   (L.IND)                 ; size for numeric output field
; output heading
        TYPSTR  ([ASCIZ/Code/],777,0,T.P0+L.IND-4,N)
        TYPSTR  ([ASCIZ/Description/],777,0,T.P0+L.IND+4)
        TCR     (1)
CMLIN2: GETBYT  (CUDPRT,\B.IND) ; get code number
         JRST   GETCMD
        CAIN    AC1,177777      ; skip if not end
         JRST   CMLIND
        MOVEM   AC1,INDCOD      ; save it
        GETSTR  (CUDPRT,L.INDN,INDNAM)  ; input description
        TYPNUM  (INDCOD,D,0,T.P0,N)     ; output the code
        TYPSTR  (INDNAM,L.INDN,4)       ; output the description
        JRST    CMLIN2                  ; do next

CMLIND:
        PUSHJ   P,GET40                 ; get terminator
        TLO     FLG,U.OKAY              ; return
        POPJ    P,
CMDCHK: ; check if username is already in mud
        TCR     (1)
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GETUNM        ; input username into UNMSPC
         JRST   CHKDON
        TCR     (1)
        SNDBYT  (CUDPRT,\B.CCOM,KUNMUD,I)       ; send check name cmd
        PUSHJ   P,SNMCUD        ; send the username
        PUSHJ   P,SND40
        PUSHJ   P,NGANS         ; get answer
         JFCL
        PUSHJ   P,GET40
        TYPSTR  (UNMSPC,L.UNM,0,0,N)
        TYPSTR  ([ASCIZ/-/],777,1,0,N)
        MOVEI   AC,2
        PUSHJ   P,SPACES
        PUSHJ   P,NANOUT        ; type out the message
        JRST    CMDCHK
CHKDON:
        TRO     FLG,U.OKAY
        POPJ    P,

LTT:    ; here to outout to list command ttl file, all list cms
        TLNE    FLG,U.NET
         POPJ   P,              ; don't write tt file for TYMRES
	GETT	(/LIS/)
	POPJ	P,
	PUSHJ	P,STDHDR
	PUSHJ	P,RELTTF
	POPJ	P,
GCREC1: ; get a cud record for user in UNMSPC but don't get passdate in pdp10
        ; format
        SETZM   NMSTRT          ; clear entire cud rec area
        MOVE    AC,[NMSTRT,,NMSTRT+1]
        BLT     AC,NMEND-1      ; do it
        PUSHJ   P,GETCUD        ; build a circuit
         JRST   GETCMD
        SNDBYT  (CUDPRT,\B.CCOM,LUSMUD,I) ; send the command
        PUSHJ   P,SNMCUD        ; send the username
        PUSHJ   P,SND40
        PUSHJ   P,NGANS         ; get answer
         PUSHJ  P,ERRCUD        ; check for fatal error
        MOVE    AC,NMANS
        CAIE    AC,1
         POPJ   P,              ; we are not going to get a record
        GETBYT  (CUDPRT)        ; waste the first byte
         JRST   GETCMD
        GETBYT  (AC,\B.GAN)     ; get the gan
         JRST   GETCMD
        MOVEM   AC1,NMGAN
        GETBYT  (AC)            ; waste another
         JRST   GETCMD
        GETBYT  (AC,\B.UUN)     ; get the uun
         JRST   GETCMD
        MOVEM   AC1,NMUUN
        GETBYT  (AC,\B.CPR)     ; get cparw
         JRST   GETCMD
        LSH     AC1,^D8         ; adjust
        MOVEM   AC1,NMCPAR
        GETBYT  (AC,\B.CLN)     ; get colon word
         JRST   GETCMD
        LSH     AC1,^D16        ; adjust
        TLZ     AC1,(1B14)      ; don't know what this bit is
        MOVEM   AC1,NMCOLN
        GETBYT  (AC,\B.CDST)    ; get district
         JRST   GETCMD
        MOVEM   AC1,NMDIST
        GETBYT  (AC,\B.IRC)     ; get irc code
         JRST   GETCMD
        MOVEM   AC1,NMIRC
        PUSHJ   P,GCCLS         ; get class info
        GETBYT  (AC,\B.PDT)     ; cubs format passdate
         JRST   GETCMD
        MOVEM   AC1,NMPDAT
        PUSHJ   P,GET40         ; get terminator
        AOS     0(P)
        POPJ    P,
 
 
; routine check username against cud, used for accounting data base/cud
; consistency check. Only msg when username not found.
 
CONCHK:
        PUSHJ   P,GETCUD
         JRST   GETCMD
CONCH1: PUSHJ   P,GETUNM
         JRST   GETCMD
        SNDBYT  (CUDPRT,\B.CCOM,KUNMUD,I)
        PUSHJ   P,SNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JFCL
        PUSHJ   P,GET40
        MOVE    AC1,NMANS
        CAIE    AC1,2
         JRST   CONCH1
  ;     TYPSTR  ([ASCIZ/NOT FOUND/])
        GETT    (/BAD/)
         JRST   CONCH1
        PUSHJ   P,STDUHD
        PUSHJ   P,RELTTF
        JRST    CONCH1
   ;zNJn