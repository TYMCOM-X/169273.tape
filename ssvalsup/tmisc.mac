SUBTTL	MISCSB - MISCELLANEOUS SUBROUTINES

ERREX:	; HERE WHEN WE ARE DOING AN ERROR EXIT
        MOVEM   AC1,NUM
        TCR     (1)
        MOVE    AC1,NUM
        SKIPN   AC1
        JRST    ERREX2
        CAIL    AC1,SEMMAX
        JRST    ERREX2
        TYPSTR  (@SYSERR(AC1),777,0,0,Y,Y)
        TCR     (1)
        MOVE    AC1,NUM
        HLRZ    AC,SYSERR(AC1)
        TRNE    AC,X.S
        JRST    ERREX1
ERREX0: TYPSTR	([ASCIZ/Please report this problem to Software Support/],777,0,0,Y,Y)
        TYPSTR  ([ASCIZ/or TYMNET's Validations Department immediately./],777,0,0,Y,Y)
        JRST    CMDQUI
ERREX1: TYPSTR	([ASCIZ/Please contact TYMNET's Validations Department/],777,0,0,Y,Y)
        TYPSTR  ([ASCIZ/if you have any question about this problem./],777,0,0,Y,Y)
        JRST    CMDQUI
ERREX2: TYPSTR  ([ASCIZ/Error exit - code:/],777,0,0,N,Y)
        TYPNUM  (NUM,D,1,0,Y,Y)
        JRST    ERREX0

WASLIN: ; WASTE A LINE
	TLNE	FLG,U.EOL		; SKIP IF LAST CHAR NOT EOL
	JRST	WASLI2
	INSTR	(NONE,STRSP,1,S)
WASLI2: POPJ	P,

CHKLIC: ; CHECK WF AND AC PROC LIC.
	HRROI	AC,.GTLIC		; GET LIC
	GETTAB	AC,
	SETZ	AC,
	TLNN	AC,(LC.WF)
	BOMB	(ERR.WF)
	TLNN	AC,(LC.AC)
	BOMB	(ERR.AC)
	MOVEM	AC,NUM
	POPJ	P,

GETPJ:	; FIND ACTG. AND CUD SYSTEM NUMBERS IN (PJ)JOBS.DAT
	MOVE	AC,[.CHOPN,,JOBCHN]
	CHANIO	AC,JOBOPN		; OPEN A CHANNEL
	BOMB	(ERR.PJ)
	HRLI	AC,.CHLK		; SET TO DO LOOKUP
	CHANIO	AC,JOBLKB		; DO IT
	BOMB	(ERR.PJ)
	HRLI	AC,.CHIN		; SET TO INPUT A BLOCK
	CHANIO	AC,JOBCOM
	SKIPA
	BOMB	(ERR.PJ)
	MOVEI	AC1,PJ.FSW		; FIRST SYSTEM WORD IN FILE
GETJO2: MOVE	AC,JOBBUF(AC1)		; GET A WORD
	CAMN	AC,MONE			; SKIP IF NOT END
	JRST	GETJOE
	SKIPE	ACTHOS			; SKIP IF WE DO NOT YET HAVE ACT. HOST
	JRST	GETJO3
	TLNN	AC,PJ.ACT		; SKIP IF ACT. SYS RECORD FOUND
	JRST	GETJO3
	HRRZM	AC,ACTHOS		; SAVE ACTG. HOST
	SKIPE	CUDHOS			; SKIP IF WE DO NOT YET HAVE CUD HOST
	JRST	GETJOD
GETJO3: TLNN	AC,PJ.CUD		; SKIP IF CUD SYS RECORD FOUND
	JRST	GETJO4
	HRRZM	AC,CUDHOS		; SAVE CUD HOST
	SKIPE	ACTHOS			; SKIP IF WE DO NOT YET HAVE ACT. HOST
	JRST	GETJOD
GETJO4: AOJ	AC1,			; INCREMENT INDEX
	JRST	GETJO2
GETJOD: AOS	(P)			; SET TO SKIP RETURN
	JRST	GETJOE			; RETURN
GETJOE: MOVE	AC,[.CHREL,,JOBCHN]	; SET TO RELEASE CHANNEL
	CHANIO	AC,
	POPJ	P,

TVACES:	; FIND MY.UUN IN TYMVAL.UUN FILE
	MOVE	AC,[.CHOPN,,JOBCHN]	; PREPRE TO OPEN A CHANNEL
	CHANIO	AC,TVAOPN		; OPEN CHANNEL
	JRST	TVACES			; OPEN ERROR, TRY AGAIN
	HRLI	AC,.CHLK		; SET TO DO LOOKUP
	CHANIO	AC,TVALKB		; LOOK UP THE FILE TYMVAL.UUN
	BOMB	(ERR.TV)
	HRLI	AC,.CHIN		; PREPARE TO INPUT A BLOCK
	CHANIO	AC,TVACOM
	SKIPA
	BOMB	(ERR.TV)
	SETZ	AC1,
TVACCL:	MOVE	AC,TVABUF(AC1)		; GET A WORD FROM BUFFER
	CAMN	AC,MONE			; SKIP IF NOT END
	JRST	TVACCE			; NOT FOUND
	HRRZ	AC2,AC
	CAMN	AC2,MY.UUN		; SKIP IF NOT FOUND YET
	JRST	TVACCD
	AOJA	AC1,TVACCL
TVACCD: HLLZS	AC
	TDO	FLG,AC
	TLNN	FLG,U.PROG
	JRST	TVACCE
	TLZE	FLG,U.WC
	JRST	TVACCE
	TLZ	FLG,U.PROG
	TLO	FLG,U.NET
TVACCE:	MOVE	AC,[.CHREL,,JOBCHN]	; SET TO RELEASE CHANNEL
	CHANIO	AC,
	POPJ	P,

BINDEC: ; CHANGE BINARY TO DECIMAL - AC/ BYTE POINTER - AC1/ NUMBER
	IDIVI	AC1,^D10
	HRLM	AC2,(P)			; SAVE DIGIT
	JUMPE	AC1,BINDE2		; NONE LEFT
	PUSHJ	P,BINDEC		; NEXT DIGIT
BINDE2: HLRZ	AC1,(P)			; GET DIGIT
	ADDI	AC1,"0"			; MAKE ASCII
	IDPB	AC1,AC			; DEPOSIT IT
	POPJ	P,			; NEXT

CNVD0:	; SUBROUTINE CONVERTS ASCII STRING (DECIMAL NO.) TO BINARY.
	MOVEM	AC,AC4
	HRLI	AC4,(POINT 7)		; SET BYTE POINTER
	SETZ	AC1,			; ZERO ACCUMULATOR
CNVD1:	ILDB	AC,AC4			; PUT FIRST OR NEXT CHAR. IN AC
	CAIN	AC,BLNK			; BLANK MEANS END OF TOKEN
	JRST	[AOS	(P)		; SKIP RETURN
		 POPJ	P,]
	CAIL	AC,60			; DIGIT?
	CAILE	AC,71
	JRST	ILLVAL			; NOT A DIGIT
	SUBI	AC,60			; CONVERT TO NUMERIC VALUE
	IMULI	AC1,^D10		; MULTIPLY PREVIOUS SUM BY 10 BEFORE
	ADD	AC1,AC			; ADDING NEXT DIGIT
	JRST	CNVD1			; GET NEXT CHARACTER.

CNVO0:	; SUBROUTINE CONVERTS ASCII STRING (DECIMAL NO.) TO BINARY.
	MOVEM	AC,AC4
	HRLI	AC4,(POINT 7)		; SET BYTE POINTER
	SETZ	AC1,			; ZERO ACCUMULATOR
CNVO1:	ILDB	AC,AC4			; PUT FIRST OR NEXT CHAR. IN AC
	CAIN	AC,BLNK			; BLANK MEANS END OF TOKEN
	JRST	[AOS	(P)		; SKIP RETURN
		 POPJ	P,]
	CAIL	AC,60			; OCTAL DIGIT?
	CAILE	AC,67
	JRST	ILLVAL			; NOT A DIGIT
	SUBI	AC,60			; CONVERT TO NUMERIC VALUE
	IMULI	AC1,^D8			; MULTIPLY PREVIOUS SUM BY 8 BEFORE
	ADD	AC1,AC			; ADDING NEXT DIGIT
	JRST	CNVO1			; GET NEXT CHARACTER.
ILLVAL: TLNE	FLG,U.IND
	JRST	[TYPSTR	([ASCIZ"Error - Incorrect indirect input."],777,0,0,Y,Y)
		 JRST GETCMD]
	TRNE	FLG,U.RFI
	BOMB	(ERR.R4)
	PUSHJ	P,WASLIN
	TYPSTR	([ASCIZ"Illegal value - Please re-enter."])
	TCR	(1)
	POPJ	P,

OUTOFB: ; Value of bounds.
	TLNE	FLG,U.IND
	JRST	[TYPSTR	([ASCIZ"Error - Incorrect indirect input."],777,0,0,Y,Y)
		 JRST GETCMD]
	TRNE	FLG,U.RFI
	BOMB	(ERR.R4)
	PUSHJ	P,WASLIN
	TYPSTR	(@ERRMSG,777,0,0,N)
	TYPSTR	([ASCIZ" - Please re-enter."])
	TCR	(1)
	POPJ	P,

GETUNM: ; INPUT A USERNAME INTO UNMSPC - RETURN AC1/ LENGTH OF THE USERNAME.
	INSTR	([ASCIZ/Enter Username:/],UNMSPC,L.UNM,T)
	MOVEI	AC1,L.UNM
	MOVEI	AC,UNMSPC
	PUSHJ	P,CNTCHR
	SKIPG	AC1
	POPJ	P,
	PUSHJ	P,VALNAM
	JRST	[TCR	(1)
		 JRST	GETUNM]
	AOS	(P)
	POPJ	P,

GTUCLS: ; GET MUD CLASS INFO FROM TERMINAL
	MOVE	AC,[CLSWRK,,CLSWRK+1]
	SETZM	CLSWRK
	BLT	AC,CLSWEN
	MOVEI	AC,CLSWRK+1
	MOVEM	AC,CLSWIN		; INITIALIZE INDEX
	MOVEI	AC,NMSZCS-1
	MOVEM	AC,CLSWCT		; MAX NUMBER OF WORDS
	GETYR	([ASCIZ"Is the class user defined? (Y/N):"])
	JRST	GTRCLS			; GET REGULAR CLASS
	JRST	GTSCLS			; GET USER DEFINED CLASS
GTRCLS: INNUM	([ASCIZ/Class:/],D)
	JRST	GTRCLS
	CAIG	AC1,^D96
	SKIPG	AC1
	JRST	[MOVEI	AC,[ASCIZ"Illegal class"]
		MOVEM	AC,ERRMSG
		PUSHJ	P,OUTOFB
		JRST	GTRCLS]
	MOVEM	AC1,CLSWRK+1
        PUSHJ	P,GHGRP			; GET HOME GROUPS
	PUSHJ	P,GNHGRP		; GET NON-HOME GROUPS
	PUSHJ	P,GHHST			; GET HOME HOSTS
	PUSHJ	P,GNHHST		; GET NON-HOME HOSTS
	PUSHJ	P,CLSWDS		; DISPLAY IT, ASK FOR APPROVAL
	JRST	GTCLSA		; GET THE CLASS AGAIN
	POPJ	P,
GTCLSA:	TCR	(1)
	JRST	GTUCLS
GTSCLS: GETYR	([ASCIZ"Is this an exception class? (Y/N):"])
	JRST	GTSCL2
	MOVEI	AC,UDN.CD		; MARK EXCEPTION CLASS
	JRST	GTSCL3
GTSCL2: SETZ	AC,
GTSCL3: TRO	AC,UDF.CD		; MARK SELF DEFINING CLASS
	MOVEM	AC,CLSWRK+1
	PUSHJ	P,GOHST			; GET ORIGINATING HOSTS
	PUSHJ	P,GONOD			; GET ORIGINATION NODES
	PUSHJ	P,GHGRP			; GET HOME GROUPS
	PUSHJ	P,GNHGRP		; GET NON-HOME GROUPS
	PUSHJ	P,GHHST			; GET HOME HOSTS
	PUSHJ	P,GNHHST		; GET NON-HOME HOSTS
	PUSHJ	P,CLSWDS		; DISPLAY INFO
	JRST	GTCLSA
	POPJ	P,

GONOD:	; GET ORIGINATING NODES
	INNUM	([ASCIZ/Originating Nodes:/],O)
	JRST	GONOD
	JUMPG	AC1,GONOD2
	JRST	GONODD
GONOD2: SOSG	CLSWCT
	JRST	CLSOVF
	AOS	CLSWRK			; INCREMENT SIZE IN WORDS
	AOS	CLSWRK+1		; INC. SIZE OF SELF DEFINED REC 2 BYTES
	AOS	CLSWRK+1
	AOS	CLSWIN			; INCREMENT INDEX
	MOVEM	AC1,@CLSWIN		; STORE IT
	TLNN	FLG,U.EOL		; SKIP IF LAST INPUT NOT EOL
	JRST	GONOD
GONODD: POPJ	P,

GOHST:	; GET ORIGINATING HOSTS
	INNUM	([ASCIZ/Originating Hosts:/],D)
	JRST	GOHST
	JUMPG	AC1,GOHST2
	JRST	GOHSTD
GOHST2: SOSG	CLSWCT
	JRST	CLSOVF
	AOS	CLSWRK
	AOS	CLSWRK+1
	AOS	CLSWRK+1
	AOS	CLSWIN
	TRO	AC1,HOS.CD
	MOVEM	AC1,@CLSWIN
	TLNN	FLG,U.EOL
	JRST	GOHST
GOHSTD: POPJ	P,

GHGRP:	; get home groups
	INNUM	([ASCIZ/Home Groups:/],D)
	JRST	GHGRP
	JUMPG	AC1,GHGRP2
	MOVE	AC,CNVHLD		; check for null input
	CAMN	AC,[ASCII/     /]
	JRST	GHGRPD
	MOVEI	AC,[ASCIZ/Home group zero not allowed/]
	MOVEM	AC,ERRMSG
	PUSHJ	P,OUTOFB
	JRST	GHGRP
GHGRP2:	; here to put new group in work area
	SOSG	CLSWCT			; JUMP IF ROOM LEFT
	JRST	CLSOVF			; OVERFLOW
	AOS	CLSWIN
	AOS	CLSWRK			; increment size of class
	TRO	AC1,HOM.CD!GRP.CD ; mark them
	MOVEM	AC1,@CLSWIN		; store it
	TLNN	FLG,U.EOL
	JRST	GHGRP
GHGRPD: POPJ	P,

GNHGRP:	; get non home groups
	INNUM	([ASCIZ/Non-Home Groups:/],D)
	JRST	GNHGRP
	JUMPG	AC1,GNHGR2
	MOVE	AC,CNVHLD
	CAMN	AC,[ASCII/     /]
	JRST	GNHGRD
	SETZ	AC1,
GNHGR2:	SOSG	CLSWCT
	JRST	CLSOVF
	AOS	CLSWIN
	AOS	CLSWRK
	TRO	AC1,GRP.CD
	MOVEM	AC1,@CLSWIN
	TLNN	FLG,U.EOL
	JRST	GNHGRP			; GO GET MORE
GNHGRD: POPJ	P,

GHHST:	; get home hosts
	INNUM	([ASCIZ/Home hosts:/],D)
	JRST	GHHST
	JUMPG	AC1,GHHST2
	JRST	GHHSTD			; all done.
GHHST2:	SOSG	CLSWCT
	JRST	CLSOVF
	AOS	CLSWIN
	AOS	CLSWRK
	TRO	AC1,HOM.CD
	MOVEM	AC1,@CLSWIN
	TLNN	FLG,U.EOL
	JRST	GHHST
GHHSTD: POPJ	P,

GNHHST:	; get non home hosts
	INNUM	([ASCIZ/Non-Home Hosts:/],D)
	JRST	GNHHST
	JUMPG	AC1,GNHHS2
	JRST	GNHHSD
GNHHS2:	SOSG	CLSWCT
	JRST	CLSOVF
	AOS	CLSWIN
	AOS	CLSWRK
	MOVEM	AC1,@CLSWIN
	TLNN	FLG,U.EOL
	JRST	GNHHST
GNHHSD: POPJ	P,

CLSOVF:	TYPSTR	([ASCIZ/Overflow./],777,0,0,Y,Y)
	PUSHJ	P,INORNO
	JRST	GTUCLS			; start again

CLSWDS:	; display info
	TCR	(1)
	SETZM	CLSCTR			; set up some data for clsout routine
	AOS	CLSCTR
	MOVEI	AC,NMCLSS
	MOVEM	AC,CLSIND
	MOVE	AC,CLSWRK
	MOVEM	AC,GRPCTR
	MOVE	AC,[NMCLSS,,CLSSAV]	; save nmclss data
	BLT	AC,CLSSAV+NMSZCS-1
	MOVE	AC,[CLSWRK,,NMCLSS]	; move in clswrk data
	BLT	AC,NMCLSS+NMSZCS-1
	SETZM	NMCLSS+NMSZCS		; zero our 1st wrd of 2nd position
	PUSHJ	P,CLSWOT		; output info
	MOVE	AC,[CLSSAV,,NMCLSS]
	BLT	AC,NMCLSS+NMSZCS	; restore original nmclss data
        TCR     (1)
	GETYR	([ASCIZ"OK? (Y/N):"])
	POPJ	P,
	AOS	(P)
	POPJ	P,

GETHOH: ; INPUT HOME SYSTEM
	INNUM	([ASCIZ/Enter New Home System:/],D)
	JRST	GETHM3
	MOVEM	AC1,HOMSYS
	TLNE	FLG2,V.EXC
	JRST	GHOH01
	TLNE	FLG2,V.LSQ!V.PRQ!V.EXQ
	POPJ	P,
GHOH01: CAIL	AC1,1			; CHECK FOR MINIMUM
	CAILE	AC1,MAXHST		; CHECK FOR MAXIMUM ALLOWED HOST
	JRST	GETHM2
	PUSHJ	P,CKMLHT		; CHECK MAIL NAME FOR A HOST
	JRST	[TCR	(1)
		 JRST	GETHM3]
	POPJ	P,
GETHM2: TRNE	FLG2,U.RFI
	JRST	GETHM3
	MOVEI	AC,[ASCIZ"System number out of bounds <1-16383>"]
	MOVEM	AC,ERRMSG
	PUSHJ	P,OUTOFB
	JRST	GETHOH
GETHM3: TRNE    FLG,U.RFI
        JRST    [SETOM  HOMSYS
                 TLO    FLG2,V.RER
                 POPJ   P,]
	JRST	GETHOH

CKMLHT: ; CHECK MAILNAME AND HOMSYS FOR VALID ENTRY IN TYMHST DATA BASE.
	MOVE	AC,HOMSYS
	TRNE	AC,GRP.CD
	JRST	CKMLH2
	JUMPE	AC,CKMLH2
	SNDBYT	(ACTPRT,\B.ACOM,KMHACT,I)
	SNDBYT	(AC,\B.UUN,MAIUUN)
	SNDBYT	(AC,\B.HST,HOMSYS)
	PUSHJ	P,AGANS
	JRST	CKMLH3
CKMLH2: AOS	(P)
	POPJ	P,
CKMLH3: MOVE	AC1,ACANS
	CAIE	AC1,3
	JRST	CKMLH4
CKMLH5:	TYPSTR	(MAINAM,L.UNM,0,0,N)
	TYPSTR	([ASCIZ/(Mail Name) is not valid on system/],777,1,0,N)
	TYPNUM	(HOMSYS,D,1)
	POPJ	P,
CKMLH4: TYPSTR	([ASCIZ/Error during Check a Mail Name for a host/])
	PUSHJ	P,LUDAOT
	POPJ	P,

CKMLHS:	; CHECK HOMSYS VALID IN UAHST
	MOVE	AC,HOMSYS
	TRNE	AC,GRP.CD
	JRST	CKMLH2
	JUMPE	AC,CKMLH2
	SETZ	AC1,
KMLHS1:	CAML	AC1,UAHSTP
	JRST	CKMLH5
	MOVE	AC,UAHST(AC1)
	CAIN	AC,ALHSTS
	JRST	CKMLH2
	CAMN	AC,HOMSYS
	JRST	CKMLH2
	AOS	AC1
	JRST	KMLHS1

GETCC:	; INPUT COST CODE
	INNUM	([ASCIZ/Cost Code:/],D)
	JRST	GTCCE2			; TRY AGAIN IF INPUT WAS INCORRECT
	CAIL	AC1,1
	CAILE	AC1,^D262143
	JRST	GTCCE1
	MOVEM	AC,CCRCT
	POPJ	P,			; RETURN
GTCCE1: TRNE	FLG2,U.RFI
        JRST    GTCCE2
	MOVEI	AC,[ASCIZ"Cost Code out of bounds <1-262143>"]
	MOVEM	AC,ERRMSG
	PUSHJ	P,OUTOFB
        JRST    GETCC
GTCCE2: TRNE    FLG2,U.RFI
        JRST    [TLO    FLG2,V.RER
                 SETZ   AC1,
                 SETZM  CCRCT
                 POPJ   P,]
	JRST	GETCC

GETCUS: ; input a customer number into CUSNUM
	TLNE	FLG2,V.EXC
	JRST	NALCHG
GTCUS1:	INNUM	([ASCIZ/Customer Number:/],D)
	JRST	GTCUSE
	MOVEM	AC1,CUSNUM
	MOVEM	AC1,TUCNO
	MOVE	AC,CNVHLD
	CAMN	AC,[ASCII/     /]
	POPJ	P,
	CAIL	AC1,1
	CAILE	AC1,^D262143
	JRST	[TRNE	FLG,U.RFI
		 JRST	GTCUSE
		 MOVEI	AC,[ASCIZ"Customer number out of bounds <1-262143>"]
		 MOVEM	AC,ERRMSG
		 PUSHJ	P,OUTOFB
		 JRST	GETCUS]
	AOS	(P)
	POPJ	P,
GTCUSE: ; INPUT CUSTOMER ERROR
        TRNE    FLG,U.RFI               ; SKIP IF NOT INPUT FROM REQ FILE
        JRST    [TLO    FLG2,V.RER
                 SETZM  CUSNUM
                 SETZM  TUCNO
                 POPJ   P,]
        JRST    GTCUS1

GETDIS: ; INPUT DISTRICT NUMBER
	TLNE	FLG2,V.EXC
	JRST	NALCHG
GTDIS1:	INNUM	([ASCIZ/District Number:/],D)
	JRST	GTDISE
	SKIPL	AC1
	CAILE	AC1,^D255
	JRST	[MOVEI	AC,[ASCIZ"District out of bounds <0-255>"]
		 MOVEM	AC,ERRMSG
		 PUSHJ	P,OUTOFB
		 JRST	GTDIS1]
	MOVEM	AC1,DISRCT
	MOVEM	AC1,NMDIST
	PUSHJ	P,CHKDIS
	JRST	GTDIS2
	POPJ	P,
GTDIS2: TYPNUM	(DISRCT,D,0,0,N)
	TYPSTR	([ASCIZ/ is not a Tymnet district./])
        TRNE    FLG,U.RFI
        JRST    GTDISE
        PUSHJ   P,INORNO
        JRST    GTDIS1
GTDISE: TRNE    FLG,U.RFI
        JRST    [TLO    FLG2,V.RER
                 SETOM  DISRCT
                 SETZM  NMDIST
                 POPJ   P,]
        JRST    GTDIS1

INASYS: ; INPUT A SYSTEM TYPE 9 OR 66 - RETURN AC1 AND ACTSYS/ 9 OR 66
	INNUM	([ASCIZ/System type (9 or 66):/],D)
	JRST	INASYS
	CAIN	AC1,^D9			; TYMNET?
	JRST	INASYR			; YES, JUST RETURN
	CAIE	AC1,^D66		; PRIVATE NET?
	JRST	[MOVEI	AC,[ASCIZ"Illegal system type"]
		 MOVEM	AC,ERRMSG
		 PUSHJ	P,OUTOFB
		 JRST	INASYS]
INASYR: MOVEM	AC1,ACTSYS		; PUT IN RETURN AREA
	POPJ	P,

; INORNO checks if input is from a file, if so jrsts to GETCMD, else
; returns to caller with a popj
INORNO: TLNE	FLG,U.IND		; SKIP IF NOT INPUT FORM INDIRECT FILE
	JRST	INOR2
	TRNE	FLG,U.RFI		; skip if not coming from request file
	BOMB	(ERR.R4)
	PUSHJ	P,WASLIN
	TYPSTR	([ASCIZ/Please try again./])
	TCR	(1)
	POPJ	P,
INOR2:	TYPSTR	([ASCIZ/Error- incorrect indirect input./],777,0,0,Y,Y)
	JRST	GETCMD

AGANS:	; get answer from acctg
	GETBYT	(ACTPRT)
	JRST	GETCMD
	MOVEM	AC1,ACANS
	CAIN	AC1,ACT.OK
	AOS	(P)
	POPJ	P,

LUDAOT:	; output lud and acctg errors, answer must be in ac1
	MOVE	AC1,ACANS
	CAIL	AC1,LUDALN
	JRST	LUDAO2
	HLRZ	AC,LUDAMS(AC1)
	TRNE	AC,X.M
	PUSHJ	P,LUDAOS
LUDAO1: TYPSTR	(@LUDAMS(AC1))
	POPJ	P,
LUDAO2: PUSHJ	P,LUDAOS
	TYPSTR	([ASCIZ/Error code out of range./],777,1)
	POPJ	P,

LUDAOS:	; output error number
	MOVEM	AC1,NUM
	MOVEI	AC,"("
	PUSHJ	P,CHROUT
	TYPNUM	(NUM,O,0,0,N)
	MOVEI	AC,")"
	PUSHJ	P,CHROUT
	MOVEI	AC," "
	PUSHJ	P,CHROUT
	MOVE	AC1,NUM
	POPJ	P,

GETODF: ; get list output destination and channel if it's a file
	TRZ	FLG,U.LFO		; turn off bit
	TCR	(1)
	INSTR	([ASCIZ /Output to:/],FILIN,25,T)
	MOVE	AC,FILIN		; look at the first word
	CAME	AC,[ASCII/T    /]	; SKIP IF IT IS A CHAR "T".
	CAMN	AC,[ASCII/     /]	; SKIP IF IT IS NOT A BLANK
	SKIPA				; A SPACE OR T MEANS DO LIST
	SKIPA				; OUTPUT TO TOUT/TERMINAL
	POPJ	P,
	MOVEI	AP,ODFARG		; IF NOT THEN IT'S A FILENAME, PARSE IT
	PUSHJ	P,FNPAR
	JUMPGE	AC,ODFERR		; error during parse
	SETZM	ODFBLK			; PREPARE OPEN BLOCK
	HRLZI	AC,ODFBUF
	MOVEM	AC,ODFBLK+2
	MOVE	AC,ODFDEV		; get the device
	MOVEM	AC,ODFBLK+1		; move it into open block
	MOVE	AC,[.CHOPN,,ODFCHN]
	CHANIO	AC,ODFBLK		; do open
	JRST	ODFER1
	MOVE	AC,[.CHLK,,ODFCHN]
	CHANIO	ODFLK
	PUSHJ	P,NEWFIL
	PUSHJ	P,OLDFIL
	GETYR	(LINEBF)
	JRST	GETODF
	MOVE	AC,SAVLIC		; get our license word
	HRLS	AC			; make proc lic = frame lic
	SETLIC	AC,
	MOVE	AC,[.CHENT,,ODFCHN]
	CHANIO	AC,ODFLK		; enter it
	JRST	ODFER2
	MOVE	AC,SAVLIC		; restore our proc lic
	SETLIC	AC,
	PUSHJ	P,CHKLIC		; make sure it's there
	MOVEI	AC,ODFBUF
	HRRZM	AC,CA.BRH
	MOVEI	AC,ODFRBF
	HRRZM	AC,CA.BRG
	PUSHJ	P,INITBR
	TRO	FLG,U.LFO		; set flag indicating file list output
	SETZ	LPOSL,
	POPJ	P,

ODFERR: TYPSTR	([ASCIZ/Error parsing filename/])
	PUSHJ	P,INORNO
	JRST	GETODF

ODFER1:	TYPSTR	([ASCIZ/Channel open failed/])
	PUSHJ	P,INORNO
	JRST	GETODF
ODFER2:	TYPSTR	([ASCIZ/Enter failed/])
	PUSHJ	P,INORNO
	JRST	GETODF

NEWFIL: ; confirm new file
	CONCAT	(LINEBF,[ASCIZ"New file - OK? (Y/N):"],0)
	AOS	(P)			; skip over oldfil routine
	POPJ	P,

OLDFIL:	HRLI	AC,.CHCLS		; close the file
	CHANIO	AC,
	CONCAT	(LINEBF,[ASCIZ"Old File - OK? (Y/N):"],0)
	POPJ	P,

YORN:	; Input yes or no.
	INSTR	(NONE,YORNSP,1,T)
	MOVE	AC,YORNSP
	CAME	AC,[ASCII/Y    /]
	JRST	YORN2
	AOS	(P)
	POPJ	P,
YORN2:	CAME	AC,[ASCII/N    /]
	JRST	YORN3
	POPJ	P,
YORN3:	TLNE	FLG,U.IND
	JRST	INOR2
	TRNE	FLG,U.RFI
	BOMB	(ERR.R4)
	PUSHJ	P,WASLIN
	TYPSTR	([ASCIZ"Illegal answer - Please re-enter."])
	TCR	(1)
	TYPSTR	(@LASPRM,777,0,0,N)
	MOVEI	AC,40
	PUSHJ	P,CHROUT
	JRST	YORN

ODFCHR: ; OUTPUT A CHARACTER TO THE LIST OUTPUT FILE
; AC/ CHARACTER TO OUTPUT
	SOSG	ODFCNT			; SKIP IF ROOM LEFT IN CURRENT BUFFER
	PUSHJ	P,NODFBF		; ELSE GET A NEW BUFFER
	IDPB	AC,ODFBP		; DEPOSIT IT
	POPJ	P,

NODFBF: ; here to flush output to list file
	PUSH	P,AC3
	MOVE	AC3,[.CHOUT,,ODFCHN]	; Prepare for CHANIO
	CHANIO	AC3,			; do it
	JRST	NODFB2			; ok return
	PUSHJ	P,ERRODF		; error return
NODFB2: POP	P,AC3
	POPJ	P,

ERRODF: ; error writing to list output file
	TRZ	FLG,U.LFO		; RESET OUTPUT FLAG
	TYPSTR	([ASCIZ/Error during LIST output- status word:/],777,0,0,N)
	MOVE	AC4,[POINT 7,SAC]	; deposit last char here
	MOVEM	AC4,ODFBP
	SETZ	AC4,
	MOVE	AC3,[.CHGS,,ODFCHN]	; get status word
	CHANIO	AC3,SAC
	TYPNUM	(SAC,O,1)		; output it
	PUSHJ	P,CLSODF		; release the channel
	POPJ	P,

CLSODF: ; release list output file channel
	MOVE	AC3,[.CHREL,,ODFCHN]
	CHANIO	AC3,
	JFCL
	TRZ	FLG,U.LFO
	POPJ	P,

UNSA:	; convert sixbit username to ascii
	SETZM	MY.UNM
	SETZM	MY.UNM+1
	SETZM	MY.UNM+2
	MOVE	AC,[POINT 6,SIXUNM]
	MOVE	AC1,[POINT 7,MY.UNM]
	MOVEI	AC4,L.UNM
UNSA1:	ILDB	AC3,AC
	JUMPE	AC3,UNSA2
	ADDI	AC3,BLNK
	IDPB	AC3,AC1
	SOJG	AC4,UNSA1
UNSA2:	POPJ	P,

SESCFL:	; here on escape interrupt
	TLNE	FLG2,V.INP		; SKIP IF NOT DOING STRING INPUT
	JRST	[MOVEI	AC,ESCABT
		 MOVEM	AC,TRPVEC+2
		 DISMIS]
	TRNE	FLG2,V.LCM
	JRST	[MOVEI	AC,LCDABT
		 MOVEM	AC,TRPVEC+2
		 DISMIS]
	TRNE	FLG2,V.HIC
	JRST	[MOVEI	AC,HICABT
		 MOVEM	AC,TRPVEC+2
		 DISMIS]
        TRNE    FLG2,V.PSW
        JRST    [MOVEI  AC,ESCPSW
                 MOVEM  AC,TRPVEC+2
                 DISMISS]
	TRNE	FLG2,V.LAG
	JRST	[MOVEI	AC,LAGABT
		 MOVEM	AC,TRPVEC+2
		 DISMIS]
	TLO	FLG2,V.ESC
	DISMIS
	HALT

ESCABT:	; here to abort after escape seen
	TLNN	FLG,U.IND		; skip if coming from com file
	CLRBFI
	TLZ	FLG2,V.INP
ESCAB1:	TYPSTR	([ASCIZ/^/])
	SETZM	TRPVEC+2
	JRST	GETCMD

ESCPSW: ; HERE TO ABORT WHEN AN ESC TYPED DURING PSWD INPUT.
        TRZ     V.PSW!V.CUP
        SETZ    AC,
        SETMOD  AC,                     ; RE-ENABLE ECHO
        SNDBYT  (CUDPRT,1,.CRCUD,I)     ; SEND 940 CR
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
        JRST    ESCAB1
        GETBYT  (CUDPRT,\B.CYP)
        JRST    ESCAB1
        PUSHJ   P,GET40
        JFCL
        JRST    ESCAB1

LCDABT:	; TO ABORT LIST COMMAND AFTER ESCAPE SEEN
	MOVE	AC,ACTPRT
	ZAPCIR	AC,
	MOVE	AC,CUDPRT
	ZAPCIR	AC,
	SETZM	CUDPRT
	SETZM	ACTPRT
	TRZ	FLG,U.CUD!U.ACT
	TRNE	FLG,U.LFO		; SKIP IF NOT OUTPUT TO A FILE
	PUSHJ	P,CLSODF		; CLOSE LIST OUTPUT FILE
	TRZ	FLG2,V.LCM		; RESET FLAG
        CLRBFI
	JRST	ESCAB1

LAGABT: ; To abort List All GanPass after escape seen.
	TRZ	FLG2,V.LAG!V.HDR
	HRRZ	AC,TTFPAG
	HRLI	AC,1
	VCLEAR	AC,
	JFCL
	PUSHJ	P,CLSPWF
	TRNE	FLG,U.LFO
	PUSHJ	P,CLSODF
	JRST	ESCAB1

HICABT:	; TO ABORT HELP OR INSTRUCTIONS COMMAND AFTER ESCAPE SEEN
	TLZ	FLG2,V.HIC		; RESET FLAG
	TRNE	FLG,U.LFO
	PUSHJ	P,CLSODF
	CLOSE	JOBCHN,
	JRST	ESCAB1

; READ ALL TYMNET DISTRICT NUMBERS FROM FILE "DSTRCT.NET"
; AND PUT THEM INTO DISTAB (DISTRICT TABLE).

MKDIST: OPEN	JOBCHN,RO.OPN
	POPJ	P,
	PUSHJ	P,STRORB
	LOOKUP	JOBCHN,DISTFN
	POPJ	P,
	IN	JOBCHN,
	MOVEI	AC,DISTAB
	MOVEM	AC,DISTXX
MKDST1: PUSHJ	P,RDANUM		; READ A NUMBER FROM THE FILE
	JRST	MKDST2
	MOVEM	AC1,@DISTXX
	AOS	DISTXX
	JRST	MKDST1
MKDST2: MOVE	AC,DISTXX
	SUBI	AC,DISTAB
	MOVEM	AC,DISTLL
	AOS	(P)
	POPJ	P,

RDANUM: ; READ A NUMBER FROM THE FILE.
	SETZ	AC1,			; SET ZERO AC1
RDNUM1: PUSHJ	P,RDACHR		; READ A CHARACTER
	POPJ	P,			; END OF FILE
	CAIN	AC,15			; CARRIAGE RETURN?
	JRST	RDNUM1			; YES, SKIP THIS CHAR AND GET NEXT ONE
	CAIN	AC,12			; LINE FEED?
	JRST	RDNUM2			; YES, END OF LINE
	CAIGE	AC,60			; CHECK FOR NUMERIC
	JRST	RDNUM3			; NOT A DIGIT
	CAILE	AC,71
	JRST	RDNUM3
	SUBI	AC,60			; CONVERT ASCII TO NUMERIC VALUE
	IMULI	AC1,^D10
	ADD	AC1,AC
	JRST	RDNUM1
RDNUM2: AOS	(P)
	POPJ	P,
RDNUM3: CLOSE	JOBCHN,
	BOMB	(ERR.D2)

RDACHR: ; INPUT A CHRACTER FROM THE FILE
	SOSGE	RO.CNT			; ROOM IN BUFFER?
	JRST	[IN	JOBCHN,		; NO, GET NEW ONE
		JRST	RDACHR
		 CLOSE	JOBCHN,		; EOF
		 POPJ	P,]
	ILDB	AC,RO.PTR		; GET A CHAR. FROM INPUT BUFFER
	JUMPE	AC,RDACHR		; IF NULL, GET ANOTHER
	AOS	(P)			; SKIP RETURN
	POPJ	P,

CHKDIS: ; CHECK ACCESS OF TYMNET DISTRICT - AC1/ DISTRICT NUMBER
	TLNE	FLG,U.PROG		; SKIP IF NOT PROGRAMMER
	JRST	CKDIS1
	MOVN	AC2,DISTLL
	HRLZS	AC2
	CAMN	AC1,DISTAB(AC2)		; SKIP IF NOT MATCH
	JRST	.+3
	AOBJN	AC2,.-2			; INCREMENT INDEX AND LOOP BACK
	SKIPA
CKDIS1: AOS	(P)
	POPJ	P,

VALNAM: ; CHECK A USERNAME
	TLNE	FLG2,V.LSQ!V.EXQ!V.PRQ
	JRST	VALNMD
	TLNN	FLG,U.TR6
	JRST	VALNMD
	CMPSTR	([ASCIZ/TYMRES6/],UNMSPC,7)
	JRST	VALNM1
	JRST	VALNMD
VALNM1: SPLITN	(UNMSPC,CPUNM,PRUNM)
	JRST	VALNME
VALNMD: AOS	(P)
	POPJ	P,
VALNME: TYPSTR	([ASCIZ/Illegal format of Username./])
	POPJ	P,

VALMAI: ; CHECK A MAILNAME
	TLNN	FLG,U.TR6
	JRST	VALNMD
	CMPSTR	([ASCIZ/TYMRES6/],MAINAM,7)
	JRST	VLMAI1
	JRST	VALNMD
VLMAI1: SPLITN	(MAINAM,CPMNM,PRMNM)
	POPJ	P,
;	MOVE	AC,PRMNM
;	CAME	AC,[ASCIZ/MAIL/]
;	POPJ	P,
	AOS	(P)
	POPJ	P,

GTCPNM: CAIGE	AC1,3
	POPJ	P,
	SETZM	0(AC3)
	SETZM	1(AC3)
	SETZM	0(AC4)
	SETZM	1(AC4)
	SETZM	CPMNML
	HRLI	AC2,(POINT 7)
	HRLI	AC3,(POINT 7)
	HRLI	AC4,(POINT 7)
GCPNM1: ILDB	AC,AC2
	CAIN	AC,"."
	JRST	GCPNM2
	IDPB	AC,AC3
	AOS	CPMNML
	SOJG	AC1,GCPNM1
	POPJ	P,
GCPNM2: SKIPN	CPMNML
	POPJ	P,
	SOJLE	AC1,.-1
GCPNM3: ILDB	AC,AC2
	IDPB	AC,AC4
	SOJG	AC1,GCPNM3
	AOS	(P)
	POPJ	P,

X1234C: JFCL

INVOUT:	; OUTPUTS INVOICE CODE
	TYPSTR	([ASCIZ/Invoice:/],777,0,0,N)
	MOVE	AC1,ACINVC		; PUT INV.CODE # INTO AC1
	CAILE	AC1,INVLEN		; IF INV.CODE < LENGTH(INV.TABLE) SKIP
	JRST	INVOU2			; GO & OUTPUT THE INV.CODE #
	ADDI	AC1,INVTAB		; SET UP INDEX INTO TABLE
	MOVEI	AC1,@-1(AC1)		; COMPLETE THE INDEX SETUP
	MOVEM	AC1,NUM			; MOVE ADDRESS OF STRING TO NUM
	TYPSTR	(@NUM,777,1)		; TYPE INVOIVE DESCRIPTION
	POPJ	P,			; NON-SKIP RETURN...ALL DONE
INVOU2: MOVEM	AC1,NUM			; OUTPUT # INSTEAD OF DESCRIPTION
	TYPNUM	(NUM,D,1)		; TYPE IT OUT
	POPJ	P,			; NON-SKIP RETURN...ALL DONE

GETINV:	; GET INVOICE CODE
	INNUM	([ASCIZ/Invoice Code:/],D)
	JRST	GETINV
	CAIL	AC1,1
        CAILE   AC1,4
        JRST    [MOVEI	AC,[ASCIZ"Invoice code out of bounds <1-4>"]
		 MOVEM	AC,ERRMSG
		 PUSHJ	P,OUTOFB
		 JRST	GETINV]
	MOVEM	AC1,ACINVC
	ADDI	AC1,INVTAB
	MOVEI	AC1,@-1(AC1)
	MOVEM	AC1,NUM
	CONCAT	(LINEBF,@NUM,0)
	CONCAT	(LINEBF,[ASCIZ" - OK? (Y/N):"])
	GETYR	(LINEBF)
	JRST	[TCR	(1)
		 JRST	GETINV]
	POPJ	P,

ASEDON: ; TYPE STRING "Accounting entry completed."
	TYPSTR	(@AENTRY)
	POPJ	P,

MSEDON: ; TYPE STRING "MUD entry completed."
	TYPSTR	(@MENTRY)
	POPJ	P,

ENTDON: ; TYPE STRING "Entry completed."
        TYPSTR  (ENTRYC)
        POPJ    P,


CONCTN: ; CONCATENATES 2 STRINGS IN A SINGLE STRING (RESULT IN STRING 1)
        DMOVEM  AC,NUM1
        DMOVEM  AC2,NUM3
        CAIE    AC1,777
        JRST    CNCAT1
        PUSHJ   P,CNTCHR
        MOVEM   AC1,NUM2
CNCAT1: DMOVE   AC,NUM3
        CAIE    AC1,777
        JRST    CNCAT2
        PUSHJ   P,CNTCHR
        MOVEM   AC1,NUM4
CNCAT2: DMOVE   AC1,NUM1
        DMOVE   AC3,NUM3
        HRLI    AC1,(POINT 7)
        HRLI    AC3,(POINT 7)
        JUMPE   AC2,.+3
        IBP     AC1
        SOJG    AC2,.-1
        JUMPE   AC4,.+4
        ILDB    AC,AC3
        IDPB    AC,AC1
        SOJG    AC4,.-2
        SETZ    AC,
        IDPB    AC,AC1
        POPJ    P,
}@7‚