SUBTTL CHGCOM - change commands
DEFINE CHG1 <
        X USER,1,CMDCUS,U.NET!U.PRV!U.DIS!U.CUS,-1      ; change user
	X MDISK,2,CMDCMI,U.PRV!U.DIS,-1           ; change mdisk
	X CUSTO,1,CMDCCT,U.PRV!U.DIS!U.NET,-1    ; change customer
	X TYMUS,1,CMDCTM,U.PRV,-1               ; change tymuse
	X FOCUS,1,CMDCFO,U.PRV,-1          ; change focus 
	X ACCOU,1,CMDCAC,U.WC,-1                ; change accounting
	X LUD,1,CMDCLD,U.WC,-1                  ; change lud
	X MUD,1,CMDCMU,U.WC,-1                  ; change mud
>
        SUBCOM  ([ASCIZ/Change :/],CHG,CHG1)
DEFINE CUS1 <
        X PASSW,2,CMDCUP,-1,-1          ; change user password
        X HOME,1,CMDCUH,U.PRV!U.DIS,-1           ; change user home
	X NETCL,2,CMDCUC,U.NET!U.PRV,-1 ; change user network class
	X CORE,2,CMDCCO,U.PRV!U.DIS,-1           ; change user core
	X SYSTE,2,CMDCUI,U.PRV!U.DIS,-1          ; change user IPL system
	X VMOPT,1,CMDCOP,U.PRV!U.DIS,-1          ; change user vm option
	X NAME,2,CMDCUN,U.PRV!U.DIS,-1           ; change user name
	X LANGU,2,CMDCUL,U.PRV!U.DIS,-1          ; change user language
	X CLASS,2,CMDCCP,U.PRV,-1       ; change user class privileges
	X CURRE,3,CMDCCR,U.PRV!U.DIS,-1          ; change user currency code
	X SALES,2,CMDCSA,U.PRV!U.DIS,-1 ; change user salesman code
	X PRIOR,2,CMDCPR,U.PRV!U.DIS,-1 ; change user priority
	X DISKQ,1,CMDCUQ,U.PRV!U.DIS,-1          ; change user disk quota
	X TIMEZ,1,CMDCUT,U.PRV!U.DIS,-1          ; change user time zone
	X FOCUS,1,CMDCUF,U.PRV,-1       ; change user focus flat fee flag
	X LICEN,2,CMDCLI,U.PRV!U.DIS,-1          ; change user license bits
	X BUDGE,1,CMDCUB,U.PRV,-1       ; change user tru budget
	X CUSTO,3,CMDCUM,U.PRV,-1       ; change user customer number
	X SPOOL,2,CMDCSC,U.PRV,-1       ; change user  spool class
	X ADDRE,1,CMDCUA,U.PRV,-1       ; change 370 user address
>

        SUBCOM  ([ASCIZ/Change User :/],CUS,CUS1)
DEFINE CMI1 <
	X CYLIN,1,CMDCMC,-1,-1	        ; change mdisk cylinders
	X ADDRE,1,CMDCMA,-1,-1	        ; change mdisk address
	X MODE,1,CMDCMM,-1,-1           ; change mdisk mode
  ;     X FORMA,1,CMDCMF,-1,-1          ; change mdisk format
	X PASSW,1,CMDCMP,-1,-1          ; change mdisk password
>

	SUBCOM	([ASCIZ /Change Mdisk :/],CMI,CMI1)
DEFINE CCT1 <
        ;  X SALES,1,CMDCCS,U.PRV!U.DIS!U.AP,-1 ; change customer salesman
        X DISTR,2,CMDCCD,U.PRV!U.DIS!U.NET,-1  ; change customer district
        ;  X NAME,1,CMDCCN,U.PRV!U.DIS!U.AP,-1  ; change customer name
        ;  X INDUS,3,CMDCCI,U.PRV!U.DIS,-1 ; change customer industry code
        ;  X ADDRE,2,CMDCCA,U.PRV!U.DIS!U.AP,-1 ; change customer address
        ;  X DETAI,2,CMDCDE,U.PRV!U.DIS!U.AP,-1 ; change customer detail
        ;  X PO,1,CMDCPO,U.PRV!U.DIS!U.AP,-1    ; change customer po
        ;  X INVOI,1,CMDCIV,U.PRV!U.AP!U.SB1,-1     ; change cust. invoice
        ;  X ATTEN,2,CMDCAT,U.PRV!U.DIS!U.AP,-1 ; change customer attention
        ;  X FOCUS,1,CMDCCF,U.PRV,-1       ; change customer focus fee flag
>

	SUBCOM	([ASCIZ /Change Customer :/],CCT,CCT1)
DEFINE CTM1 <
        X DAYS,1,CMDCTD,U.PRV!U.DIS,-1    ; change tymuse days
        X CUSTO,1,CMDCTC,U.PRV!U.DIS,-1   ; change tymuse customer
>

	SUBCOM	([ASCIZ /Change Tymuse :/],CTM,CTM1)
DEFINE CAC1 <
        X TIMEZ,1,CMDTAC,U.PRV,-1         ; change acctg. timezone
>

	SUBCOM	([ASCIZ /Change Accounting :/],CAC,CAC1)
DEFINE CLD1 <
        X TIMEZ,1,CMDCLT,U.PRV,-1         ; change lud timezone
        X DISTR,1,CHGLDI,U.WC,-1          ; change lud district
>

	SUBCOM	([ASCIZ /Change Lud :/],CLD,CLD1)
DEFINE CMU1 <
        X GAN,1,CMUGAN,U.WC,-1           ; change gan in the mud
        X UUN,1,CMUUUN,U.WC,-1           ; change uun in the mud
        X PPN,1,CMUPPN,U.WC,-1           ; change ppn in the mud
        X IRC,1,CMUIRC,U.WC,-1           ; change irc in the mud
        X DISTR,1,CMUDIS,U.WC,-1         ; change district in the mud
        X BILLA,1,CMUBIL,U.WC,-1         ; set billable bit
        X NONBI,1,CMUNON,U.WC,-1         ; unset billable bit
>

	SUBCOM	([ASCIZ /Change Mud :/],CMU,CMU1)
CAMUDX: ; cancel user in the mud and write to the ludupd file
        PUSHJ   P,GETCUD
         JRST   GETCMD
NXTNAM: PUSHJ   P,GETUNM
         JRST   GETCMD
        PUSHJ   P,GCREC1
         JRST   GETCMD
        SNDBYT  (CUDPRT,\B.CCOM,RUSMUD,I)
        PUSHJ   P,SNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   CAUSE5
        PUSHJ   P,GET40
 
; write ludupd file
 
        TRO     FLG2,V.LUD            ; for using tat.mac
        GETT    (/DEL/)
         JRST   LUDBAD
        TTFSTR  (UNMSPC,L.UNM,N,Y)
        TTFNUM  (NMUUN,O,Y,Y)
        PUSHJ   P,RELTTF
        TRZ     FLG2,V.LUD
 
        JRST    NXTNAM
CMUGAN: ; change user's gan in the mud
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GETUNM
         JRST   GETCMD
        PUSHJ   P,GCREC1              ; get cud record but don't get
         JRST   CMUGAN                ; passdate in pdp-10 format
        PUSHJ   P,GEGANN              ; get gan
        SNDBYT  (CUDPRT,\B.CCOM,CGAMUD,I)
        PUSHJ   P,SNMCUD
        SNDBYT  (CUDPRT,1,0,I)
        SNDBYT  (CUDPRT,\B.GAN,NMGAN)
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [PUSHJ   P,ERRCUD
                 JRST    CMUGAN]
        PUSHJ   P,NANOUT              ; output answer
        PUSHJ   P,GET40
        JRST    CMUGAN
CMUUUN: ; change user's uun in the mud
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GETUNM
         JRST   GETCMD
        PUSHJ   P,GCREC1              ; get cud record but don't get
         JRST   CMUUUN                ; passdate in pdp-10 format
        PUSHJ   P,GEGUUN              ; get uun
        SNDBYT  (CUDPRT,\B.CCOM,CUUMUD,I)
        PUSHJ   P,SNMCUD
        SNDBYT  (CUDPRT,1,0,I)
        SNDBYT  (CUDPRT,\B.UUN,NMUUN)
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [PUSHJ   P,ERRCUD
                 JRST    CMUUUN]
        PUSHJ   P,NANOUT              ; output answer
        PUSHJ   P,GET40
        JRST    CMUUUN
 
GEGUUN: ; get uun 
        INNUM   ([ASCIZ/Uun :/],O)
         JRST   GEGUUN
        MOVEM   AC1,NMUUN
        POPJ    P,
CMUPPN: ; change user's ppn in the mud
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GETUNM
         JRST   GETCMD
        PUSHJ   P,GCREC1              ; get cud record but don't get
         JRST   CMUPPN                ; passdate in pdp-10 format
        PUSHJ   P,GEGANN              ; get gan
        PUSHJ   P,GEGUUN              ; get uun
        SNDBYT  (CUDPRT,\B.CCOM,CPPMUD,I)
        PUSHJ   P,SNMCUD
        SNDBYT  (CUDPRT,1,0)
        SNDBYT  (CUDPRT,\B.GAN,NMGAN)
        SNDBYT  (CUDPRT,1,0)
        SNDBYT  (CUDPRT,\B.UUN,NMUUN)
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [PUSHJ   P,ERRCUD
                 JRST    CMUPPN]
        PUSHJ   P,NANOUT              ; output answer
        PUSHJ   P,GET40
        JRST    CMUPPN
CMUIRC: ; change user irc code in the mud
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GETUNM
         JRST   GETCMD
        PUSHJ   P,GCREC1              ; get cud record but don't get
         JRST   CMUIRC                ; passdate in pdp-10 format
        PUSHJ   P,GETIRC              ; get irc
        SNDBYT  (CUDPRT,\B.CCOM,CICMUD,I)
        PUSHJ   P,SNMCUD
        SNDBYT  (CUDPRT,\B.IRC,NMIRC)
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [PUSHJ   P,ERRCUD
                 JRST    CMUIRC]
        PUSHJ   P,NANOUT              ; output answer
        PUSHJ   P,GET40
        JRST    CMUIRC
 
GETIRC: ; get irc
        INNUM   ([ASCIZ/Irc :/],D)
         JRST   GETIRC
        MOVEM   AC1,NMIRC
        POPJ    P,
CMUDIS: ; change user district in the mud
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GETDIS              ; get district
         JRST   GETCMD
CMDIS1: PUSHJ   P,GETUNM
         JRST   GETCMD
        PUSHJ   P,GCREC1              ; get cud record but don't get
         JRST   CMUDIS                ; passdate in pdp-10 format
        PUSHJ   P,CDISMD              ; change district in mud
         JRST   GETCMD
        JRST    CMDIS1
 
 
 
 
 
 
CMUBIL: ; change user to billable
        PUSHJ   P,GETCUD
         JRST   GETCMD
CMBIL1: PUSHJ   P,GETUNM
         JRST   GETCMD
        PUSHJ   P,GCREC1
         JRST   CMUBIL
        MOVE    AC1,NMCOLN
        TLZ     AC1,BIL.CD
        LSH     AC1,-^D16               ; right shift 16 bits
        MOVEM   AC1,NMCOLN
        SNDBYT  (CUDPRT,\B.CCOM,CBIMUD,I)  ; change billbit in colon word
        PUSHJ   P,SNMCUD                ; send username
        SNDBYT  (CUDPRT,\B.CLN,NMCOLN)  ; send colon word
        PUSHJ   P,SND40                 ; send terminate char.
        PUSHJ   P,NGANS                 ; get a byte from cud
         JRST   ERRCUD                  ; error
        PUSHJ   P,GET40
        JRST    CMBIL1
 
 
 
CMUNON: ; change user to nonbillable
        PUSHJ   P,GETCUD
         JRST   GETCMD
CMNON1: PUSHJ   P,GETUNM
         JRST   GETCMD
        PUSHJ   P,GCREC1
         JRST   CMUNON
        MOVE    AC1,NMCOLN
        TLO     AC1,BIL.CD
        LSH     AC1,-^D16               ; right shift 16 bits
        MOVEM   AC1,NMCOLN
        SNDBYT  (CUDPRT,\B.CCOM,CBIMUD,I)  ; change billbit in colon word
        PUSHJ   P,SNMCUD                ; send username
        SNDBYT  (CUDPRT,\B.CLN,NMCOLN)  ; send colon word
        PUSHJ   P,SND40                 ; send terminate char.
        PUSHJ   P,NGANS                 ; get a byte from cud
         JRST   ERRCUD                  ; error
        PUSHJ   P,GET40
        JRST    CMNON1
CMDCUP: ; change user logon password in MUD
        TCR     (1)
        PUSHJ   P,WASLIN        ; no args allowed
        PUSHJ   P,GETCUD        ; get a cud circuit
         JRST   GETCMD
        PUSHJ   P,GETPSW        ; input password from term
         JRST   GETCMD
CMCUP1: TCR     (1)
        PUSHJ   P,GETUNM        ; get a username
         JRST   CMCUPD
; if we are not privileged, then we need to get cud record for access control.
; if no non-alpha was seen in the last password, need cud rec for exception
; checking.
	TLNN	FLG,U.PRV	; skip if privileged
	 JRST	CMCUP2		; go input cud record
	TLNE	FLG2,V.NPS	; skip if non-alpha not seen
	 JRST	CCUP2B		; skip over getting cud rec
CMCUP2:
        PUSHJ   P,GCREC         ; get cud record for uun check
         JRST   CMCUP1
CCUP2B:
        PUSHJ   P,CHKUUN        ; see if he's got access rights
         JRST   CMCUP1          ; no, do another
        MOVEI   AC,UNMSPC             ; for using CYPNAM
        MOVEM   AC,NUM2               ; for using CYPNAM
	PUSHJ   P,CYPNAM        ; cipher the username
        CAMN    AC1,NMPSW       ; cipher same as password cipher?
         JRST   CCUPE1          ; yes, not allowed.
	MOVE	AC,NMGAN	; get gan
	TLNE	FLG2,V.NPS	; skip if last password had no non-alphas
	 JRST	CMCUP3
	PUSHJ	P,PASGEX	; see if exempt from non-alpha stds
	 JRST	CCUPE2		; no, tell him he needs non-alphas
CMCUP3:
; now do the change user password
        SNDBYT  (CUDPRT,\B.CCOM,CPSMUD,I)
        PUSHJ   P,SNMCUD        ; send the username
        SNDBYT  (CUDPRT,\B.CYP,NMPSW) ; send password cipher
        PUSHJ   P,SND40         ; send terminator
        PUSHJ   P,NGANS         ; get answer
         JFCL
        PUSHJ   P,NANOUT        ; output answer
        PUSHJ   P,GET40         ; get terminator
	GETT	(/CHG/)		; get the tattle tale file
	 JRST	CMCUP1		; proceed without tattle feature
; output tattle tale info
	TTFSTR	([ASCIZ/Change User Password/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF	; release tt file
        JRST    CMCUP1          ; do another name

CMCUPD: ; done changing passwords
        TRO     FLG,U.OKAY      ; set ok flag
        POPJ    P,              ; return

CCUPE1: ; error password and username ciphers are equal
        TYPSTR  (UNMSPC,L.UNM,0,0,N)
        TYPSTR  ([ASCIZ/- Bad Password- not changed./])
        JRST    CMCUP1  ; get another name

CCUPE2:	; needs non-alphas
	TYPSTR	(UNMSPC,L.UNM,0,0,N)
	TYPSTR	(PE4,777,1)
	JRST	CMCUP1	; get another name
CMDCUH: ; change user home (for class 2 group 1 users only)
        TCR     (1)
        PUSHJ   P,GETCUD        ; get cud circuit
         JRST   GETCMD
        PUSHJ   P,GETACC        ; get acct circuit
         JRST   GETCMD
        PUSHJ   P,GETHOH        ; get home host number, must be tymshare
CMCUH1: TCR     (1)
        PUSHJ   P,GETUNM        ; get a username
         JRST   CMCUHD          ; done
        PUSHJ   P,GCREC         ; get cud record
         JRST   CMCUH1
        PUSHJ   P,CHKUUN        ; check access
         JRST   CMCUH1
        MOVE    AC,NMCLSS+1     ; get class number
        CAIE    AC,D.CLS        ; skip if standard
         JRST   CMCUHE          ; no go
        MOVE    AC,NMCLSS+2     ; get first word (group)
        CAIE    AC,GRP.CD!D.GRP ; skip if group 1
         JRST   CMCUHE          ; also no go
; if we get to here, then 1st position is class 2 group 1
        MOVEI   AC1,NMCLSS+3    ; address of 1st host record
        MOVEI   AC3,NMSZCS-3    ; number of possible entries
CMCUH2: MOVE    AC,0(AC1)       ; get entry
        TRNN    AC,HOM.CD       ; see if home host
         JRST   [AOJ    AC1,    ; no, try next one
                 SOJG   AC3,CMCUH2
                 JRST   CMCUHE]
        MOVE    AC,HOMSYS       ; got it, get our new home sys
        TRO     AC,HOM.CD       ; flag it
        MOVEM   AC,0(AC1)       ; change it
; change the class
        SNDBYT  (CUDPRT,\B.CCOM,CCLMUD,I)
        PUSHJ   P,SNMCUD        ; send username
        SNDBYT  (CUDPRT,1,1,I)  ; position number always 1
        MOVEI   AC,NMCLSS+1     ; send the rest
        MOVEM   AC,CLSIND
        MOVE    AC,NMCLSS
        MOVEM   AC,CLSCTR
        SNDBYT  (CUDPRT,1,NMCLSS)
CMCUH3: SNDBYT  (CUDPRT,2,@CLSIND)
        SOSGE   CLSCTR
         JRST   CMCUH4
        AOS     CLSIND
        JRST    CMCUH3
CMCUH4: PUSHJ   P,SND40         ; send terminator
        PUSHJ   P,NGANS         ; get answer
         JFCL
        PUSHJ   P,NANOUT        ; type answer
        PUSHJ   P,GET40         ; get terminator
	GETT	(/CHG/)
	 JRST	CMCUH1
	TTFSTR	([ASCIZ/Change User Home/])
	PUSHJ	P,STDUHD
	TTFSTR	([ASCIZ/New Home Host :/],777,N)
	TTFNUM	(HOMSYS,D)
	PUSHJ	P,RELTTF
	JRST    CMCUH1          ; do another user

CMCUHE: ; does not qualify
        TYPSTR  ([ASCIZ/Can only change class 2 group 1 users./])
        JRST    CMCUH1

CMCUHD: ; done
        TRO     FLG,U.OKAY
        POPJ    P,
CMDCUC:	; change user network class
	TCR	(1)
	PUSHJ	P,GETCUD
	 JRST	GETCMD
	INNUM	([ASCIZ/Class position : /],D)
	 JRST	[PUSHJ	P,INORNO
		 JRST	CMDCUC]
	MOVEM	AC1,CLSWPO	; store it
	JUMPLE	AC1,CMCUC0	; must be ge 0, if not tell him so.
	CAIG	AC1,NMNCLS	; must be le largest position number.
	 JRST	CMCUCA
CMCUC0:	TYPSTR	([ASCIZ/Bad position number./])
	PUSHJ	P,INORNO
	JRST	CMDCUC
CMCUCA:	PUSHJ	P,GTUCLS
CMCUC1:	TCR	(1)
	PUSHJ	P,GETUNM
	 JRST	CMCUCD
	PUSHJ	P,GCREC
	 JRST	CMCUC1
	MOVE	AC1,CLSWPO
	SOJ	AC1,
	IMULI	AC1,NMSZCS
	SKIPG	NMCLSS(AC1)
	 JRST	CMCUCE
	SNDBYT	(CUDPRT,\B.CCOM,CCLMUD,I)
	PUSHJ	P,SNMCUD
	SNDBYT	(CUDPRT,1,CLSWPO)
	PUSHJ	P,CMAUCB
	GETT	(/CHG/)
	 JRST	CMCUC1
	TTFSTR	([ASCIZ/Change User Class/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
	JRST	CMCUC1

CMCUCD:
	TRO	FLG,U.OKAY
	POPJ	P,

CMCUCE:
	TYPSTR	([ASCIZ/No such class position./])
	JRST	CMCUC1
CMDCCO: ; change user core
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CUCO <
	X	(HST1OT,GETH37,RWH37)
	X	(NAMOUP,GETUSR,RWUSR)
	X	(DCOOUT,GETDCO,RWDCO)
	X	(MCOOUT,GETMCO,RWMCO)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CUC,CUCO,4,USRRQQ)

; code for change user core starts here

	SNDBYT	(OLDPRT,\B.LCOM,CCOLUD,I)	; change core
	SNDSTR	(AC,L.UNM3,UNMSPC)         ; send username
	SNDBYT	(AC,\B.VPRI,DFLAG)         ; send change defcore flag
	SNDBYT	(AC,\B.CORE,DNCOR)         ; send defcore
	SNDBYT	(AC,\B.VPRI,MFLAG)         ; send change maxcore flag
	SNDBYT	(AC,\B.CORE,MNCOR)         ; send maxcore
	PUSHJ	P,OLDA
	 JRST	CUCCE2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CUCMC4
	TTFSTR	([ASCIZ/Change User Core/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
CUCMC4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CUCMCD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CUCMCD
	JRST	CUCST2			; ABRV'ST2 is the menu output section

CUCMCD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

CUCCE2:	; error during change user core
	TYPSTR	([ASCIZ/Error during Change User Core./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	CUCCE3

CUCCE3:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	CUCST2

; end of code for change user core
 
DCOOUT:
	TYPSTR	([ASCIZ/Def. Core :/],777,0,T.P0,N)
	TYPSTR	(DCORE,L.CORE,0,T.P2)
	POPJ	P,
MCOOUT:
	TYPSTR	([ASCIZ/Max. Core :/],777,0,T.P0,N)
	TYPSTR	(MCORE,L.CORE,0,T.P2)
	POPJ	P,

GETDCO:
        MOVEI   AC,^D255              ;set flag to 255 as  requested in 1POINT
        MOVEM   AC,DFLAG
	INSTR	([ASCIZ/Def. Core :/],DCORE,L.CORE,T)
        MOVE    AC4,[POINT 7,DCORE]   ;set byte pointer to AC4 which points
                                      ;to DCORE
        PUSHJ   P,CNVCOR              ;call conversion routine
        CAIN    AC1,0                 ;carriage return?
         JRST   GETDCO
        CAIL    AC1,MIN.COR           ;less than 320?
        CAILE   AC1,MAX.COR           ;less than 16M=16384k?
         JRST   ERRCOR
        SETZM   DFLAG                 ;set zero to dflag \= 255
        MOVEM   AC1,DNCOR
        POPJ    P,
 
 
CNVCOR:  ; convert core from characters to number
         SETZ   AC1,                  ;set ac1 zero
CNVCO1:  ILDB   AC,AC4           ;put first or next char. in ac
         CAIN   AC," "                ;blank means end of token
          POPJ  P,
         CAIN   AC,"K"                ;'k' means last char. too
          POPJ  P,
         CAIN   AC,"M"                ;'m' means last char., but in mega byte
          JRST  [IMULI    AC1,^D1024  ;1m =  1024k
                 POPJ     P,]
         CAIL   AC,"0"                ;if not k,m or number, goto nokc
         CAILE  AC,"9"
          JRST  NOKC
         SUBI   AC,"0"                ;convert to binary
         IMULI  AC1,^D10              ;multiply previous number by 10
         ADD    AC1,AC
         JRST   CNVCO1                ;get next char.
 
ERRCOR:
         TYPSTR  ([ASCIZ/Must be a value between 320K and 16384K (or 16M)/])
         JRST    GETDCO
        
NOKC:
         TYPSTR  ([ASCIZ/Invalid Character/])
         JRST    GETDCO
 
GETMCO:
        MOVEI   AC,^D255
        MOVEM   AC,MFLAG
	INSTR	([ASCIZ/Max. Core :/],MCORE,L.CORE,T)
        MOVE    AC4,[POINT 7,MCORE]   ;set byte pointer to AC4 which points
                                      ;to MCORE
        PUSHJ   P,CNVMCR              ;call conversion routine
        CAIN    AC1,0                 ;carriage return?
         JRST   GETMCO
        CAIL    AC1,MIN.COR           ;less than 320?
        CAILE   AC1,MAX.COR           ;less than 16M=16384k?
         JRST   ERRMCR
        SETZM   MFLAG                 ;set zero to mflag \= 255
        MOVEM   AC1,MNCOR
        POPJ    P,

CNVMCR:  ; convert core from characters to number
         SETZ   AC1,                  ;set ac1 zero
CNVCO2:  ILDB   AC,AC4                ;put first or next char. in ac
         CAIN   AC," "                ;blank means end of token
          POPJ  P,
         CAIN   AC,"K"                ;'k' means last char. too
          POPJ  P,
         CAIN   AC,"M"                ;'m' means last char., but in mega byte
          JRST  [IMULI    AC1,^D1024  ;1m =  1024k
                 POPJ     P,]
         CAIL   AC,"0"                ;if not k,m or number, goto nokc
         CAILE  AC,"9"
          JRST  NOKC2
         SUBI   AC,"0"                ;convert to binary
         IMULI  AC1,^D10              ;multiply previous number by 10
         ADD    AC1,AC
         JRST   CNVCO2                ;get next char.
 
ERRMCR:
         TYPSTR  ([ASCIZ/Must be a value between 320K and 16384K (or 16M)/])
         JRST    GETMCO
        
NOKC2:
         TYPSTR  ([ASCIZ/Invalid Character/])
         JRST    GETMCO
 
RWDCO:	; write default core to request file
	REQOUT	(REQ,DCORE,L.CORE)
	POPJ	P,
RWMCO:	; write maximum core to request file
	REQOUT	(REQ,MCORE,L.CORE)
	POPJ	P,

 
 

CMDCUI: ; change user IPL system
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CUIS <
	X	(HST1OT,GETH37,RWH37)
	X	(NAMOUP,GETUSR,RWUSR)
	X	(IPLOUT,GETIPL,RWIPL)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CUI,CUIS,5,USRRQQ)

; code for change user IPL system starts here, only immediate mode and
; PROCESS command can enter into following codes

	SNDBYT	(OLDPRT,\B.LCOM,CIPLUD,I)	; change ipl
	SNDSTR	(AC,L.UNM3,UNMSPC)
        SNDBYT  (AC,\B.VPRI,DFLAG)         ; send change IPL flag
	SNDSTR	(AC,L.SIPL,SIPL)
	PUSHJ	P,OLDA
	 JRST	CUIAE2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CUIMC4
	TTFSTR	([ASCIZ/Change User IPL System/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
 
CUIMC4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CUIMCD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CUIMCD
	JRST	CUIST2			; ABRV'ST2 is the menu output section

CUIMCD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

CUIAE2:	; error during change IPL
	TYPSTR	([ASCIZ/Error during Change User IPL System./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	CUIAE3
 
CUIAE3:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	CUIST2

; end of code for change user IPL system
 
IPLOUT:
	TYPSTR	([ASCIZ/IPL System :/],777,0,T.P0,N)
	TYPSTR	(SIPL,L.SIPL,0,T.P2)
	POPJ	P,
 

GETIPL:
        MOVEI   AC,1
        MOVEM   AC,DFLAG
	INSTR	([ASCIZ/IPL System :/],SIPL,L.SIPL)
        MOVE    AC,SIPL
        CAMN    AC,[ASCII/     /]     ;if not a carriage return then skip
         JRST   GETIPL
	POPJ	P,


RWIPL:	; write IPL to request file
	REQOUT	(REQ,SIPL,L.SIPL)
	POPJ	P,
 
 
CMDCOP: ; change user VM options
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CUOP <
	X	(HST1OT,GETH37,RWH37)
	X	(NAMOUP,GETUSR,RWUSR)
	X	(VOPOUT,GETVOP,RWVOP)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CUO,CUOP,7,USRRQQ)

; code for change user VM options starts here, only immediate mode and
; PROCESS command can enter into following codes

	SNDBYT	(OLDPRT,\B.LCOM,COPLUD,I)	; change VM options
	SNDSTR	(AC,L.UNM3,UNMSPC)
        SNDBYT  (AC,\B.VOPT,VOPT)          
        MOVEI   AC1,^D255             ; temporarily shut off 2nd word of
        MOVEM   AC1,DFLAG             ; vm option (assume no change)
        SNDBYT  (OLDPRT,\B.FS,DFLAG)
        SNDBYT  (OLDPRT,\B.VOPT,VOPT)    
	PUSHJ	P,OLDA
	 JRST	CUOAE2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CUOMC4
	TTFSTR	([ASCIZ/Change User VM Options/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
 
CUOMC4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CUOMCD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CUOMCD
	JRST	CUOST2			; ABRV'ST2 is the menu output section

CUOMCD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

CUOAE2:	; error during change VM options
	TYPSTR	([ASCIZ/Error during Change User VM Options./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	CUOAE3
 
CUOAE3:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	CUOST2

; end of code for change user VM options
 
VOPOUT:
	TYPSTR	([ASCIZ/VM Options :/],777,0,T.P0,N)
        MOVE    AC1,VOPT
        TRNN    AC1,1B34
         JRST   VOOUT2
        TYPSTR  ([ASCIZ/Nocp/],777,1,T.P2)
VOOUT2: MOVE    AC1,VOPT
        TRNN    AC1,1B33
         JRST   VOOUT3
        TYPSTR  ([ASCIZ/Paramauto/],777,1,T.P2)
VOOUT3: MOVE    AC1,VOPT
        TRNN    AC1,1B29
         JRST   VOOUT4
        TYPSTR  ([ASCIZ/Ecmode/],777,1,T.P2)
VOOUT4: MOVE    AC1,VOPT
        TRNN    AC1,1B28
         JRST   VOOUT5
        TYPSTR  ([ASCIZ/Autodial/],777,1,T.P2)
VOOUT5: MOVE    AC1,VOPT
        TRNN    AC1,1B30
         JRST   VOOUT6
        TYPSTR  ([ASCIZ/Realtimer/],777,1,T.P2)
VOOUT6: MOVE    AC1,VOPT
        TRNN    AC1,1B31
         JRST   VOOUT7
        TYPSTR  ([ASCIZ/Virtual=Real/],777,1,T.P2)
VOOUT7: MOVE    AC1,VOPT
        TRNN    AC1,1B32
         JRST   VOOUT8
        TYPSTR  ([ASCIZ/Accounting/],777,1,T.P2)
VOOUT8: MOVE    AC1,VOPT
        TRNN    AC1,1B35
        JRST    VOOUT9
        TYPSTR  ([ASCIZ/Bmx/],777,1,T.P2)
VOOUT9: POPJ    P,
 

GETVOP:
        SETZ    AC1,
        MOVEM   AC1,VOPT
        GETYR   ([ASCIZ/Nocp? /])     ;if yes, skip next statement
         JRST   .+4                   ;no
        MOVE    AC1,VOPT
        TRO     AC1,1B34
        MOVEM   AC1,VOPT
        GETYR   ([ASCIZ/Paramauto? /])
         JRST   .+4
        MOVE    AC1,VOPT
        TRO     AC1,1B33
        MOVEM   AC1,VOPT
        GETYR   ([ASCIZ/Ecmode? /])
         JRST   .+4
        MOVE    AC1,VOPT
        TRO     AC1,1B29
        MOVEM   AC1,VOPT
        TLNN    FLG,U.PRV             ;skip if privileged
         POPJ   P,
        GETYR   ([ASCIZ/Autodial? /])
         JRST   .+4
        MOVE    AC1,VOPT
        TRO     AC1,1B28
        MOVEM   AC1,VOPT
        GETYR   ([ASCIZ/Realtimer? /])
         JRST   .+4
        MOVE    AC1,VOPT
        TRO     AC1,1B30
        MOVEM   AC1,VOPT
        GETYR   ([ASCIZ/Virtual=Real? /])
         JRST   .+4
        MOVE    AC1,VOPT
        TRO     AC1,1B31
        MOVEM   AC1,VOPT
        GETYR   ([ASCIZ/Accounting? /])
         JRST   .+4
        MOVE    AC1,VOPT
        TRO     AC1,1B32
        MOVEM   AC1,VOPT
        GETYR   ([ASCIZ/Bmx? /])
         JRST   .+4
        MOVE    AC1,VOPT
        TRO     AC1,1B35
        MOVEM   AC1,VOPT
        POPJ    P,

RWVOP:	; write to request file
        MOVE    AC1,VOPT
        TRNN    AC1,1B34
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,VOPT
        TRNN    AC1,1B33
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,VOPT
        TRNN    AC1,1B29
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,VOPT
        TRNN    AC1,1B28
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,VOPT
        TRNN    AC1,1B30
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,VOPT
        TRNN    AC1,1B31
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,VOPT
        TRNN    AC1,1B32
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,VOPT
        TRNN    AC1,1B35
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        POPJ    P,
 
WRYES:  REQOUT  (REQ,[ASCII/Y/],1)
        POPJ    P,
 
WRNO:   REQOUT  (REQ,[ASCII/N/],1)
        AOS     0(P)
        POPJ    P,
 
CMDCUN: ; change user name, only ask old and new username, changes are
        ; been made immediatly in the mud then write a file to VALDEV
        ; this file will be read by lud updater to change the name on
        ; the acctg. data base and all the hosts which is valid.
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CUNM <
	; X	(HOMOUT,GETHOM,RWH37)
	X	(NAMOUP,USRGET,RWUSR)
	X	(NNMOUT,GETNNM,RWNNM)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CUN,CUNM,^D8,USRRQQ)

; code for change user name starts here, only immediate mode and
; PROCESS command can enter the following codes

; change user name in cud or mud
 
        SNDBYT  (CUDPRT,\B.CCOM,CUNMUD,I)
        PUSHJ   P,NNMCUD              ; send new name
        PUSHJ   P,SNMCUD              ; send old name
        PUSHJ   P,SND40               ; send cud terminate char.
        PUSHJ   P,NGANS               ; get a byte from cud
         JRST   ERRCUD                ; error
        PUSHJ   P,GET40
 
; write ludupd file
 
        TRO     FLG2,V.LUD            ; for using tat.mac
        GETT    (/CHG/)
         JRST   LUBAD1
        TTFSTR  (UNMSPC,L.UNM,N,Y)
        TTFSTR  (NNMSPC,L.UNM,N,Y)
        TTFNUM  (NMUUN,O,Y,Y)
        PUSHJ   P,RELTTF
        TRZ     FLG2,V.LUD
 
; change user name in accounting
 
;       PUSHJ   P,GETACC
;        JRST   GETCMD
;       SNDBYT  (ACTPRT,\B.ACOM,CUNACT,I)
;       SNDBYT  (AC,\B.UUN,NMUUN)     ; send uun
;       SNDSTR  (AC,L.UNM,NNMSPC)     ; send new name
;       PUSHJ   P,AGANS
;        JRST   RSEMUD
 
; change user name in tusrdb, proceed if user not found
 
        PUSHJ   P,GETACC
         JRST   GETCMD
        SNDBYT  (ACTPRT,\B.ACOM,CTYMCT,I)
        SNDBYT  (AC,\B.UUN,NMUUN)     ; send uun
        SNDSTR  (AC,L.UNM,NNMSPC)     ; send new name
        PUSHJ   P,AGANS
         JRST   CNMTAT
        JRST    CNMTAT
 
LUBAD1: TYPSTR  ([ASCIZ/error in writing LUDUPD.CHG file./])
        TRZ     FLG2,V.LUD
        JRST    GETCMD
 
RSEMUD:
	TYPSTR	([ASCIZ/Error during Change User Name in Accounting./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,CUNMUD,I)  ; change new name back to old name
        PUSHJ   P,SNMCUD              ; send old name
        PUSHJ   P,NNMCUD              ; send new name
        PUSHJ   P,SND40               ; send cud terminate char.
        PUSHJ   P,NGANS               ; get a byte from cud
         JRST   [TYPSTR  ([ASCIZ/Reverse Mud Entry not Working!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        POPJ    P,
 
; change user name in lud - will be treated  differently according to
; system type
  
CHGLUD: MOVE    AC,OLDASY             ; get accounting system type
        CAIN    AC,A370               ; skip if not 370
         JRST   SND370
        CAIN    AC,A940               ; skip if not 940
         JRST   SND940
 
        ; sending usernames to pdp10 host
 
	SNDBYT	(OLDPRT,\B.LCOM,CNMLUD,I)	
        SNDSTR  (AC,L.UNM,UNMSPC)
        SNDSTR  (AC,L.UNM,NNMSPC)
        JRST    SNDDNE
 
SND370: ; sending usernames to 370 host
	SNDBYT	(OLDPRT,\B.LCOM,CNMLUD,I)	
       	SNDSTR  (AC,L.UNM3,UNMSPC)
	SNDSTR	(AC,L.UNM3,NNMSPC)
         JRST   SNDDNE
 
SND940: ; sending usernames to 940 host
	SNDBYT	(OLDPRT,\B.LCOM,CNMLUD,I)	
        SNDBYT  (OLDPRT,\B.940W,0,I)    ; send dummy request no.
        SNDSTR  (AC,L.UNM,UNMSPC)
        SNDSTR  (AC,L.UNM,NNMSPC)
        SNDBYT  (AC,\B.940W,[44444444]) ; send 44444444 in octal
 
SNDDNE: PUSHJ   P,OLDA
         JRST   CUNAE2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
CNMTAT: 
	TYPSTR	([ASCIZ/Entry Complete./])
	GETT	(/CHG/)
	 JRST	CUNMC4
	TTFSTR	([ASCIZ/Change User Name/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
 
CUNMC4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CUNMCD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
         JRST   CUNMCD
	JRST	CUNST2			; ABRV'ST2 is the menu output section

CUNMCD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

CUNAE2:	; error during change name in the lud
	TYPSTR	([ASCIZ/Error during Change User Name in the Lud./])
        MOVE    AC1,OLDANS
        PUSHJ   P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,CUNMUD,I)  ; change new name back to old name
        PUSHJ   P,SNMCUD              ; send old name
        PUSHJ   P,NNMCUD              ; send new name
        PUSHJ   P,SND40               ; send cud terminate char.
        PUSHJ   P,NGANS               ; get a byte from cud
         JRST   [TYPSTR  ([ASCIZ/Reverse Mud Entry not Working!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        SNDBYT  (ACTPRT,\B.CCOM,REVACT,I)   ; reverse last change on acct
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Reverse Acctg. Entry not Working!/])
                 MOVE    AC1,ACANS
                 PUSHJ   P,LUDAOT
                 POPJ    P,]
        POPJ    P,
 

; end of code for change user name
 
HOMOUT:
	TYPSTR	([ASCIZ/Home Host :/],777,0,T.P0,N)
	TYPNUM	(HOST,D,0,T.P2)
	POPJ	P,
 
NNMOUT:
        MOVEI   AC,NNMSPC
        MOVEM   AC,NUM
        TYPSTR  ([ASCIZ/New Username :/],777,0,T.P0,N)
        TYPSTR  (@NUM,L.UNM,0,T.P2)
        POPJ    P,
 
GETHOM:
        INNUM   ([ASCIZ/Home Host :/],D)
         JRST   [PUSHJ  P,INORNO
                  JRST  GETHOM]
        JUMPE   AC1,.-1
        MOVEM   AC1,LUDNUM
        MOVEM   AC1,HOST
        TLNE    FLG2,V.LSQ            ; skip if not a list command
         POPJ   P,
        PUSHJ   P,GETOLD
         JRST   GETCMD
        TLNN    FLG2,V.EXC            ; skip if changing items
         POPJ   P,
        PUSHJ   P,CKUVA1              ; check old name valid on this host
         JRST   [TYPSTR  ([ASCIZ/Name not in Host/])
                 PUSHJ  P,INORNO
                  JRST  GETHOM]
        PUSHJ   P,CKUNOV              ; check new name not exist on cud
         JRST   [TYPSTR  ([ASCIZ/Name already exist./])
                 PUSHJ  P,INORNO
                  JRST  GETHOM]
        POPJ    P,
 
USRGET:
        PUSHJ   P,GETUNM
         JRST   [PUSHJ  P,INORNO
                 JRST   USRGET]
        TLNE    FLG2,V.LSQ
         POPJ   P,
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GCREC1
         JRST   USRGER
        PUSHJ   P,CHKUUN
         JRST   USRGER
        POPJ    P,
 
USRGER: ; get user error
        TRNN    FLG,U.RFI
         JRST   [PUSHJ   P,INORNO
                 JRST    USRGET]
        PUSHJ   P,REQERR
        POPJ    P,
 
GETNNM: ; get new user name
        INSTR   ([ASCIZ/New Username :/],NNMSPC,L.UNM,T)
        MOVEI   AC1,L.UNM
        MOVEI   AC,NNMSPC
        PUSHJ   P,CNTCHR
        SKIPN   AC1                   ; skip if not a blank
         JRST   [PUSHJ  P,INORNO
                 JRST   GETNNM]
        TLNE    FLG2,V.LSQ            ; skip this part if doing a list
         POPJ   P,
        PUSHJ   P,CKUNOV              ; make sure this name not exist
         JRST   GETNN2
        POPJ    P,
 
GETNN2: ; type error msg
        TRNN    FLG,U.RFI             ; skip if this is from a request
         JRST   [TYPSTR  ([ASCIZ/Name already exist./])
                 PUSHJ  P,INORNO
                 JRST   GETNNM]
        PUSHJ   P,REQERR

CKUVA1:	; check if user is valid on this host of various system types
	MOVE	AC,OLDHOS
	CAME	AC,HOST
         JRST   [AOS     0(P)         ; if no circuit, skip return
                 POPJ    P,]
        MOVE    AC,OLDASY
        CAIN    AC,A370
         JRST   CKU370
        CAIN    AC,A940
         JRST   CKU940
; we should use 'check username valid on pdp10 host' slave program here,
; but this program is not working on 74, therefore using list user lud command
	SNDBYT	(OLDPRT,\B.LCOM,LE2LUD,I)
	SNDSTR	(AC,L.UNM,UNMSPC)
        JRST    CKUDN1
CKU370: ; check username on 370 host
	SNDBYT	(OLDPRT,\B.LCOM,KNALUD,I)
	SNDSTR	(AC,L.UNM3,UNMSPC)
        JRST    CKUDNE
CKU940: ; check username on 940 host
	SNDBYT	(OLDPRT,\B.LCOM,LE2LUD,I)   ; note send list lud slave code
        SNDBYT  (AC,\B.940W,0,I)
	SNDSTR	(AC,L.UNM,UNMSPC)
        JRST    CKUDN9
CKUDNE: GETBYT  (OLDPRT)
         JRST   GETCMD
        CAIN    AC1,LUD.OK
         AOS    0(P)
        POPJ    P,
CKUDN1: GETBYT  (OLDPRT)
         JRST   GETCMD
        CAIE    AC1,LUD.OK            ; skip if ok
         POPJ   P,
        GETBYT  (OLDPRT,\B.GAN)
         JRST   GETCMD
        GETBYT  (AC,\B.UUN)
         JRST   GETCMD
        GETBYT  (AC,\B.DIS)
         JRST   GETCMD
        GETBYT  (AC,\B.PRV)
         JRST   GETCMD
        GETBYT  (AC,\B.TZ)
         JRST   GETCMD
        GETBYT  (AC,\B.QUOT)
         JRST   GETCMD
        GETBYT  (AC,\B.QUOT)
         JRST   GETCMD
        AOS     0(P)
        POPJ    P,
CKUDN9: GETBYT  (OLDPRT)
         JRST   GETCMD
        CAIE    AC1,LUD.OK           ; skip if ok
         POPJ   P,                   ; error return
        GETBYT  (OLDPRT,\B.940W)     ; 940 always send 5 three byte word
         JRST   GETCMD
        GETBYT  (OLDPRT,\B.940W)
         JRST   GETCMD
        GETBYT  (OLDPRT,\B.940W)
         JRST   GETCMD
        GETBYT  (OLDPRT,\B.940W)
         JRST   GETCMD
        GETBYT  (OLDPRT,\B.940W)
         JRST   GETCMD
        AOS     0(P)
        POPJ    P,
 
CKUNOV: ; check new user name not valid on cud. Since new name may be exist
        ; on other host but not on the host he or she entered, so we should 
        ; not check new name is not valid on lud!
        ; following codes are copied from routine GCREC in list user cud
 
        PUSHJ   P,GETCUD
         JRST   GETCMD
        SNDBYT  (CUDPRT,\B.CCOM,KUNMUD,I)
        PUSHJ   P,NNMCUD              ; send new name 
        PUSHJ   P,SND40
        GETBYT  (CUDPRT)
         JRST   GETCMD
        MOVEM   AC1,NMANS
        PUSHJ   P,GET40
        MOVE    AC1,NMANS
        CAIN    AC1,2                 ; skip if not (not found)
         AOS    0(P)                  ; skip return if not found
        POPJ    P,

RWNNM:	; write new username to request file
        REQOUT  (REQ,NNMSPC,L.UNM)
        POPJ    P,
 
 
 
CMDCUL: ; change user language
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CULG <
	X	(NAMOUP,GETUSE,RWUSR)
	X	(LANOUT,GETLAG,RWLAN)     ; use lanout in liscom.mac
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CUL,CULG,^D9,USRRQQ)

; code for change user language starts here, only immediate mode and
; PROCESS command can enter into following codes

	SNDBYT	(ACTPRT,\B.ACOM,CLCACT,I)	; change language code
	SNDBYT	(AC,\B.UUN,NMUUN)  
        SNDBYT  (AC,\B.LAN,UALANC)
        PUSHJ   P,AGANS
	 JRST	CULAE2
	MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
 
; tattle
	GETT	(/CHG/)
	 JRST	CULMC4
	TTFSTR	([ASCIZ/Change User Language/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
 
CULMC4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CULMCD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CULMCD
	JRST	CULST2			; ABRV'ST2 is the menu output section

CULMCD: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
CULAE2: ; error during change language code
        TYPSTR  ([ASCIZ/Error during Change User Language Code./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    CULAE3
 
CULAE3: ; after error, see if we can give him  another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    CULST2
 
; end of code for change user language code
 
 
GETUSE:	; input the username and check name against cud and acct. data base
        PUSHJ   P,GETACC
         JRST   GETCMD
	PUSHJ	P,GETUNM
	 JRST	[PUSHJ	P,INORNO
		 JRST	GETUSE]
	TLNE	FLG2,V.LSQ	; skip this part if doing a list
	 POPJ	P,
	PUSHJ	P,GETCUD
	 JRST	GETCMD
	PUSHJ	P,GCREC
	 JRST	GETUS2
	PUSHJ	P,CHKUUN	; check access
	 JRST	GETUS2
        SNDBYT  (ACTPRT,\B.ACOM,LCN2CT,I)   ; list user's customer number to
        SNDBYT  (AC,\B.UUN,NMUUN)           ; make sure user exists in acct. db
        GETBYT  (AC)
         JRST   GETCMD
        CAIE    AC1,ACT.OK                  ; skip if acctg. record exists
         JRST   [TYPSTR  ([ASCIZ/No acctg record for this username./])
                 JRST    GETUS2]
        GETBYT  (AC,\B.CID)
         JRST   GETCMD
        POPJ    P,
GETUS2:	; here when username does not match
	TRNN	FLG,U.RFI	; skip if this is from  a request
         JRST   [PUSHJ  P,INORNO
		 JRST	GETUSE]
	PUSHJ	P,REQERR
	POPJ	P,

GETLAG: ; get language and convert to code
        SETZ     AC1,
        MOVEM    AC1,UALANC
        GETYR    ([ASCIZ/English? /])
         JRST    .+4
        MOVEI    AC1,1
        MOVEM    AC1,UALANC
        POPJ     P,
        GETYR    ([ASCIZ/French? /])
         JRST    .+4
        MOVEI    AC1,2
        MOVEM    AC1,UALANC
        POPJ     P,
        GETYR    ([ASCIZ/Crown's English? /])
         JRST    .+4
        MOVEI    AC1,3
        MOVEM    AC1,UALANC
        POPJ     P,
        GETYR    ([ASCIZ/Belgian? /])
         JRST    .+4
        MOVEI    AC1,4
        MOVEM    AC1,UALANC
        POPJ     P,
        GETYR    ([ASCIZ/German? /])
         JRST    .+4
        MOVEI    AC1,5
        MOVEM    AC1,UALANC
        POPJ     P,
        GETYR    ([ASCIZ/Japanese? /])
         JRST    .+4
        MOVEI    AC1,6
        MOVEM    AC1,UALANC
        POPJ     P,
        JRST     GETLAG
        
RWLAN:  ; write to request file
        MOVE     AC1,UALANC
        CAIE     AC1,1
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
        MOVE     AC1,UALANC
        CAIE     AC1,2
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
        MOVE     AC1,UALANC
        CAIE     AC1,3
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
        MOVE     AC1,UALANC
        CAIE     AC1,4
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
        MOVE     AC1,UALANC
        CAIE     AC1,5
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
        MOVE     AC1,UALANC
        CAIE     AC1,6
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
 
 
CMDCCP: ; change user class privileges
	TCR	(1)
	TRO	FLG2,V.NIR
        TYPSTR  ([ASCIZ/Please notify System Support for this change/])
        TCR     (1)

DEFINE CUCP <
        X       (HST1OT,GETH37,RWH37)
	X	(NAMOUP,GETUSR,RWUSR)
	X	(CLPOUT,GETCLP,RWCLP)     
>
	EXMMAC (CCP,CUCP,^D10,USRRQQ)

; code for change use class privilegesd starts here

	SNDBYT	(OLDPRT,\B.LCOM,CCLLUD,I)	; change class privileges
	SNDSTR	(AC,L.UNM3,UNMSPC)
        SNDBYT  (AC,\B.FS,CLPRI)        ; borrow b.fs to indicate 1 byte
	PUSHJ	P,OLDA
	 JRST	CCPAE2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CCPMC4
	TTFSTR	([ASCIZ/Change User Class Privileges/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
 
CCPMC4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CUCPCD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CUCPCD
	JRST	CCPST2			; ABRV'ST2 is the menu output section

CUCPCD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

CCPAE2:	; error during change address
	TYPSTR	([ASCIZ/Error during Change User Class Privileges./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	CCPAE3
 
CCPAE3:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	CCPST2

; end of code for change user class privileges
 
CLPOUT:
	TYPSTR	([ASCIZ/Classes :/],777,0,T.P0,N)
        MOVE    AC1,CLPRI
        TRNN    AC1,1B28
         JRST   CPOUT2
        TYPSTR  ([ASCIZ/A/],777,1,0,N)
CPOUT2: MOVE    AC1,CLPRI
        TRNN    AC1,1B29
         JRST   CPOUT3
        TYPSTR  ([ASCIZ/B/],777,1,0,N)
CPOUT3: MOVE    AC1,CLPRI
        TRNN    AC1,1B31
         JRST   CPOUT4
        TYPSTR  ([ASCIZ/D/],777,1,0,N)
CPOUT4: MOVE    AC1,CLPRI
        TRNN    AC1,1B32
         JRST   CPOUT5
        TYPSTR  ([ASCIZ/E/],777,1,0,N)
CPOUT5: MOVE    AC1,CLPRI
        TRNN    AC1,1B33
         JRST   CPOUT6
        TYPSTR  ([ASCIZ/F/],777,1,0,N)
CPOUT6: MOVE    AC1,CLPRI
        TRNN    AC1,1B34
         JRST   CPOUT7
        TYPSTR  ([ASCIZ/G/],777,1,0,N)
CPOUT7: MOVE    AC1,CLPRI
        TRNN    AC1,1B35
         JRST   CPOUT8
        TYPSTR  ([ASCIZ/H/],777,1,0,N)
CPOUT8: TYPSTR  ([ASCIZ/ /],777,1,0,Y)
        POPJ    P,
 
 
GETCLP:
        SETZM   CLPRI
        GETYR   ([ASCIZ/Class A? /])     ;if yes, skip next statement
         JRST   .+4                      ;no
        MOVE    AC1,CLPRI
        TRO     AC1,1B28
        MOVEM   AC1,CLPRI
        GETYR   ([ASCIZ/Class B? /])
         JRST   .+4
        MOVE    AC1,CLPRI
        TRO     AC1,1B29
        MOVEM   AC1,CLPRI
        GETYR   ([ASCIZ/Class D? /])
         JRST   .+4
        MOVE    AC1,CLPRI
        TRO     AC1,1B31
        MOVEM   AC1,CLPRI
        GETYR   ([ASCIZ/Class E? /])
         JRST   .+4
        MOVE    AC1,CLPRI
        TRO     AC1,1B32
        MOVEM   AC1,CLPRI
        GETYR   ([ASCIZ/Class F? /])
         JRST   .+4
        MOVE    AC1,CLPRI
        TRO     AC1,1B33
        MOVEM   AC1,CLPRI
        GETYR   ([ASCIZ/Class G? /])
         JRST   .+4
        MOVE    AC1,CLPRI
        TRO     AC1,1B34
        MOVEM   AC1,CLPRI
        GETYR   ([ASCIZ/Class H? /])
         JRST   .+4
        MOVE    AC1,CLPRI
        TRO     AC1,1B35
        MOVEM   AC1,CLPRI
        POPJ    P,

RWCLP:  
        MOVE    AC,CLPRI
        TRNN    AC,1B28
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC,CLPRI
        TRNN    AC,1B29
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC,CLPRI
        TRNN    AC,1B31
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC,CLPRI
        TRNN    AC,1B32
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC,CLPRI
        TRNN    AC,1B33
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC,CLPRI
        TRNN    AC,1B34
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC,CLPRI
        TRNN    AC,1B35
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        POPJ    P,
 
CMDCCR: ; change user currency code
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CUCR <
	X	(NAMOUP,GETUSE,RWUSR)
	X	(CUROUT,GETCUR,RWCUR)     ; use curout in liscom.mac
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CCR,CUCR,^D11,USRRQQ)

; code for change user currency code starts here, only immediate mode and
; PROCESS command can enter into following codes

	SNDBYT	(ACTPRT,\B.ACOM,CCCACT,I)	; change currency code
	SNDBYT	(AC,\B.UUN,NMUUN)  
        SNDBYT  (AC,\B.LAN,UACURC)
        PUSHJ   P,AGANS
	 JRST	CUCRE2
	MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
 
; tattle
	GETT	(/CHG/)
	 JRST	CUCRC4
	TTFSTR	([ASCIZ/Change User Currency/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
 
CUCRC4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CUCRCD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CUCRCD
	JRST	CCRST2			; ABRV'ST2 is the menu output section

CUCRCD: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
CUCRE2: ; error during change currency code
        TYPSTR  ([ASCIZ/Error during Change User Currency Code./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    CUCRE3
 
CUCRE3: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    CCRST2
 
; end of code for change user currency code
 
GETCUR: ; get currency and convert to code
        SETZ     AC1,
        MOVEM    AC1,UACURC
        GETYR    ([ASCIZ/US Dollars? /])
         JRST    .+4
        MOVEI    AC1,1
        MOVEM    AC1,UACURC
        POPJ     P,
        GETYR    ([ASCIZ/French Francs? /])
         JRST    .+4
        MOVEI    AC1,2
        MOVEM    AC1,UACURC
        POPJ     P,
        GETYR    ([ASCIZ/English Pounds? /])
         JRST    .+4
        MOVEI    AC1,3
        MOVEM    AC1,UACURC
        POPJ     P,
        GETYR    ([ASCIZ/Belgian Francs? /])
         JRST    .+4
        MOVEI    AC1,4
        MOVEM    AC1,UACURC
        POPJ     P,
        GETYR    ([ASCIZ/German Marks? /])
         JRST    .+4
        MOVEI    AC1,5
        MOVEM    AC1,UACURC
        POPJ     P,
        GETYR    ([ASCIZ/Japanese Yen? /])
         JRST    .+4
        MOVEI    AC1,6
        MOVEM    AC1,UACURC
        POPJ     P,
        GETYR    ([ASCIZ/Dutch Dfl? /])
         JRST    .+4
        MOVEI    AC1,7
        MOVEM    AC1,UACURC
        POPJ     P,
        GETYR    ([ASCIZ/Swiss Francs? /])
         JRST    .+4
        MOVEI    AC1,^D8
        MOVEM    AC1,UACURC
        POPJ     P,
        GETYR    ([ASCIZ/Canadian Dollars? /])
         JRST    .+4
        MOVEI    AC1,^D9
        MOVEM    AC1,UACURC
        POPJ     P,
        JRST     GETCUR
        
RWCUR:  ; write to request file
        MOVE     AC1,UACURC
        CAIE     AC1,1
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
        MOVE     AC1,UACURC
        CAIE     AC1,2
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
        MOVE     AC1,UACURC
        CAIE     AC1,3
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
        MOVE     AC1,UACURC
        CAIE     AC1,4
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
        MOVE     AC1,UACURC
        CAIE     AC1,5
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
        MOVE     AC1,UACURC
        CAIE     AC1,6
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
        MOVE     AC1,UACURC
        CAIE     AC1,7
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
        MOVE     AC1,UACURC
        CAIE     AC1,^D8
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
        MOVE     AC1,UACURC
        CAIE     AC1,^D9
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
 
CMDCSA: ; change user salesman code
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CUSA <
        X       (SYSOUT,GETSYS,RWSYS)
	X	(NAMOUP,GETUS3,RWUSR)
	X	(SALOUT,GETSAL,RWSAL)     
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CSA,CUSA,^D12,USRRQQ)

; code for change user salesman number starts here, only immediate mode and
; PROCESS command can enter into following codes

	SNDBYT	(ACTPRT,\B.ACOM,CUSACT,I)	; change salesman code
	SNDBYT	(AC,\B.UUN,NMUUN)  
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        SNDBYT  (AC,\B.SLS,UASLS)
        PUSHJ   P,AGANS
	 JRST	CUSAE2
	MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
 
; tattle
	GETT	(/CHG/)
	 JRST	CUSAC4
	TTFSTR	([ASCIZ/Change User Salesman/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
 
CUSAC4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CUSACD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CUSACD
	JRST	CSAST2			; ABRV'ST2 is the menu output section

CUSACD: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
CUSAE2: ; error during change salesman code
        TYPSTR  ([ASCIZ/Error during Change User Salesman Code./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    CUSAE3
 
CUSAE3: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    CSAST2
 
; end of change user salesman code
 
SYSOUT:
        MOVE    AC,ACTSYS
        CAIE    AC,1
         JRST   .+3
        MOVEI   AC1,^D10
        JRST    SYSOU3
        CAIE    AC,2
         JRST   .+3
        MOVEI   AC1,^D940
        JRST    SYSOU3
        CAIE    AC,3
         JRST   SYSOU5
        MOVEI   AC1,^D370
        JRST    SYSOU3
SYSOU5: MOVE    AC1,AC
SYSOU3: MOVEM   AC1,SYSTYP
        TYPSTR  ([ASCIZ/System Type :/],777,0,T.P0,N)
        TYPNUM  (SYSTYP,D,0,T.P2)
        POPJ    P,
 
SALOUT:
        MOVE    AC,UASLS
        PUSHJ   P,SLSOUT
        POPJ    P,
 
GETSYS:
        PUSHJ   P,INASYS
        TLNN    FLG2,V.EXC            ; skip if changing items
         POPJ   P,
        MOVEI   AC,LUTACT
        MOVEM   AC,FINARG             ; for using routine FINAST in GUAREC
        PUSHJ   P,GUAREC        ; get user acct. system type (from FINAST) and
         JRST   GETSYS          ; make sure acct. record is existing in given
        POPJ    P,              ; system type (inputted from terminal)
 
GETUS3:	; input the username and check name against cud and acct. data base
        ; by given system type
        PUSHJ   P,GETACC
         JRST   GETCMD
	PUSHJ	P,GETUNM
	 JRST	[PUSHJ	P,INORNO
		 JRST	GETUS3]
	TLNE	FLG2,V.LSQ	; skip this part if doing a list
	 POPJ	P,
	PUSHJ	P,GETCUD
	 JRST	GETCMD
	PUSHJ	P,GCREC
	 JRST	GETUS4
	PUSHJ	P,CHKUUN	; check access, note not using ACTSY2
	 JRST	GETUS4
        MOVEI   AC,LUTACT
        MOVEM   AC,FINARG       ; for using routine FINAST in GUAREC
        PUSHJ   P,GUAREC        ; get user acct. system type and record
         JRST   GETUS4
        POPJ    P,
GETUS4:	
	TRNN	FLG,U.RFI	; skip if this is from  a request
         JRST   [PUSHJ  P,INORNO
		 JRST	GETUS3]
	PUSHJ	P,REQERR
	POPJ	P,
 
GETSAL:
        INNUM   ([ASCIZ/Salesman Number :/],D)
         JRST   GETSA2
        CAILE   AC1,^D99
         JRST   GETSA2
        MOVEM   AC1,UASLS
        POPJ    P,
GETSA2: PUSHJ   P,INORNO
        JRST    GETSAL
 
RWSAL:
        REQNOT  (REQ,UASLS,D)
        POPJ    P,
 
RWSYS:
        REQNOT  (REQ,SYSTYP,D)
        POPJ    P,

CMDCPR: ; change user priority
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CUPR <
        X       (HST1OT,GETH37,RWH37)
	X	(NAMOUP,GETUSR,RWUSR)
	X	(PRIOUT,GETPRI,RWPRI)     
>
	EXMMAC (CUP,CUPR,^D14,USRRQQ)

; code for change use priority starts here

        MOVE    AC1,NUM5
        CAIE    AC1,^D64
         JRST   [MOVEI  AC1,2
                 JRST   CGPRIO]
        MOVEI   AC1,1
CGPRIO: MOVEM   AC1,PRIOR
        SNDBYT  (OLDPRT,\B.LCOM,CPRLUD,I)   ; change user priority
	SNDSTR	(AC,L.UNM3,UNMSPC)
        SNDBYT  (AC,\B.FS,PRIOR)        ; borrow b.fs to indicate 1 byte
	PUSHJ	P,OLDA
	 JRST	CUPRI2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CUPRI4
	TTFSTR	([ASCIZ/Change User Priority/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
 
CUPRI4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CUPRID			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CUPRID
	JRST	CUPST2			; ABRV'ST2 is the menu output section

CUPRID:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

CUPRI2:	; error during change address
	TYPSTR	([ASCIZ/Error during Change User Priority./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	CUPRI3
 
CUPRI3:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	CUPST2

; end of code for change user priority
 
PRIOUT:
        TYPSTR  ([ASCIZ/Priority :/],777,0,T.P0,N)
        TYPNUM  (NUM5,D,0,T.P2)
        POPJ    P,
 
GETPRI:
        INNUM   ([ASCIZ/Priority (64 or 75):/],D)
         JRST   [PUSHJ  P,INORNO
                 JRST   GETPRI]
        MOVEM   AC1,NUM5
        CAIE    AC1,^D64
         CAIN   AC1,^D75
        POPJ    P,
        JRST    GETPRI
 
RWPRI:
        REQNOT  (REQ,NUM5,D)
        POPJ    P,
 
CMDCUQ: ; change user disk quota
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CUDQ <
        X       (HOMOUT,GETH10,RWH37)
	X	(NAMOUP,GETUSR,RWUSR)
	X	(INQOUT,GETINQ,RWINQ)     
	X	(OTQOUT,GETOTQ,RWOTQ)     
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CUQ,CUDQ,^D15,USRRQQ)

; code for change user disk quota starts here, only immediate mode and
; PROCESS command can enter into following codes

        ; first convert pages to blocks
        MOVE    AC,LUXQIN
        IMULI   AC,4
        MOVEM   AC,LUXQIN
        MOVE    AC,LUXQOT
        IMULI   AC,4
        MOVEM   AC,LUXQOT
	SNDBYT	(OLDPRT,\B.LCOM,CQTLUD,I)	; change disk quota
	SNDSTR	(AC,L.UNM,UNMSPC)
        SNDBYT  (AC,\B.QUOT,LUXQIN)
        SNDBYT  (AC,\B.QUOT,LUXQOT)
	PUSHJ	P,OLDA
	 JRST	CUDKQ2
        MOVE    AC1,LUXQIN
        IDIVI   AC1,4
        MOVEM   AC1,LUXQIN
        MOVE    AC1,LUXQOT
        IDIVI   AC1,4
        MOVEM   AC1,LUXQOT
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CUDKQ4
	TTFSTR	([ASCIZ/Change User Disk Quota/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
CUDKQ4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CUDKQD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CUDKQD
	JRST	CUQST2			; ABRV'ST2 is the menu output section

CUDKQD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

CUDKQ2:	; error during change user disk quota
	TYPSTR	([ASCIZ/Error during Change User Disk Quota./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	CUDKQ3

CUDKQ3:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	CUQST2

; end of code for change user disk quota
 
GETH10: ; input pdp10 host number
	INNUM	([ASCIZ/Host :/],D)
	 JRST	[PUSHJ	P,INORNO
		 JRST	GETH10]
	JUMPE	AC1,.-1
	MOVEM	AC1,LUDNUM
	MOVEM	AC1,HOST
	TLNE	FLG2,V.LSQ		; skip if not a list command
	 POPJ	P,			; return, no check on list
	PUSHJ	P,GETOLD		; build circuit
	 JRST	GETCMD
	MOVE	AC,OLDASY
	CAIN	AC,A10
	 JRST	GTH102
	TYPSTR	([ASCIZ/Cmd only available on Tymcom-10/])
	PUSHJ	P,INORNO
	JRST	GETH10
GTH102:
	TLNN	FLG2,V.EXC	; skip if changing items
	 POPJ	P,		; if original input then GETUSR will check username.
        PUSHJ   P,CKUVA1        ; check that username valid on this host
	 JRST	[PUSHJ	P,INORNO
		 JRST	GETH10]
	POPJ	P,

INQOUT:
        TYPSTR  ([ASCIZ/Login Quota :/],777,0,T.P0,N)
        TYPNUM  (LUXQIN,D,0,T.P2)
        POPJ    P,
OTQOUT:
        TYPSTR  ([ASCIZ/Logout Quota :/],777,0,T.P0,N)
        TYPNUM  (LUXQOT,D,0,T.P2)
        POPJ    P,
 
GETINQ:
        INNUM   ([ASCIZ/Login Quota :/],D)
         JRST   GETIQ2
        JUMPE   AC1,GETIQ2
        MOVEM   AC1,LUXQIN
        POPJ    P,
GETIQ2:
        PUSHJ   P,INORNO
        JRST    GETINQ
GETOTQ:
        INNUM   ([ASCIZ/Logout Quota :/],D)
         JRST   GETOQ2
        JUMPE   AC1,GETOQ2
        MOVEM   AC1,LUXQOT
        POPJ    P,
GETOQ2:
        PUSHJ   P,INORNO
        JRST    GETOTQ
 
RWINQ:
        REQNOT  (REQ,LUXQIN,D)
        POPJ    P,
 
RWOTQ:
        REQNOT  (REQ,LUXQOT,D)
        POPJ    P,
CMDTAC: ; change user time zone in accounting only
        TCR     (1)
        PUSHJ   P,GETACC
         JRST   GETCMD
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GETTMZ              ; get timezone
GEASYS: PUSHJ   P,INASYS              ; get system type
        CAIN    AC1,0
         JRST   GEASYS
CHACTI: TCR     (1)
        PUSHJ   P,GETUNM
         JRST   GETCMD
        PUSHJ   P,GCREC
         JRST   CHACTI
        SNDBYT  (ACTPRT,\B.ACOM,CTZACT,I)
        SNDBYT  (AC,\B.UUN,NMUUN)
        SNDBYT  (AC,\B.ACOM,ACTSYS)
        SNDBYT  (AC,\B.TZ,UATZ)
        PUSHJ   P,AGANS
         JRST   CHACTE                ; error
; tattle
        GETT    /CHG/
         JRST   CHACTI
        TTFSTR  ([ASCIZ/Change User Time Zone in Acctg./])
        PUSHJ   P,STDUHD
        PUSHJ   P,RELTTF
        JRST    CHACTI
CHACTE:
        TYPSTR  ([ASCIZ/Error during change user timezone in acctg./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    CHACTI
CMDCLT: ; change user time zone in lud only
        TCR     (1)
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GETTMZ              ; get timezone
        PUSHJ   P,GETHOS              ; get host
         JRST   GETCMD
CHLDTI: TCR     (1)
        PUSHJ   P,GETUNM
         JRST   GETCMD
        PUSHJ   P,GCREC
         JRST   CHLDTI
        PUSHJ   P,CHLDT2
         JRST   CHLDTE                ; error
; tattle
        GETT    /CHG/
         JRST   CHLDTI
        TTFSTR  ([ASCIZ/Change User Time Zone in Lud./])
        PUSHJ   P,STDUHD
        PUSHJ   P,RELTTF
        JRST    CHLDTI
CHLDT2: MOVE    AC,OLDASY             ; get accounting system type
        CAIN    AC,A370               ; skip if not 370
         JRST   CLD37T
        CAIN    AC,A940               ; skip if not 940
         JRST   CLD94T
 
        ; sending time zone to pdp10 host
 
	SNDBYT	(OLDPRT,\B.LCOM,CTZLUD,I)	
        SNDSTR  (AC,L.UNM,UNMSPC)
        SNDBYT  (AC,\B.TZ,UATZ)
        JRST    CLDTDN
 
CLD37T: ; sending time zone to 370 host
	SNDBYT	(OLDPRT,\B.LCOM,CTZLUD,I)	
       	SNDSTR  (AC,L.UNM3,UNMSPC)
	SNDBYT	(AC,\B.TZ,UATZ)
        JRST    CLDTDN
 
CLD94T: ; sending time zone to 940 host
	SNDBYT	(OLDPRT,\B.LCOM,CTZ94L,I)   ; slave code for change time zone
                                            ; in 940 lud is CTZ94L = 33
        SNDBYT  (OLDPRT,\B.940W,0,I)    ; send dummy request no.
        SNDSTR  (AC,L.UNM,UNMSPC)
        SNDBYT  (AC,\B.TZ,UATZ)
        SNDBYT  (AC,\B.TZ,0,I)          ; send a zero byte, required by 940
        SNDBYT  (AC,\B.940W,[44444444]) ; send 44444444 in octal
 
CLDTDN: PUSHJ   P,OLDA
         POPJ   P,
	AOS     0(P)
        POPJ    P,
CHLDTE:
        TYPSTR  ([ASCIZ/Error during change user timezone in lud./])
        MOVE    AC1,OLDANS
        PUSHJ   P,LUDAOT
        JRST    CHLDTI
CMDCUT: ; change user time zone in all luds and all ast's
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CUTZ <
   ;    X       (HST1OT,GETHME,RWH37)
	X	(NAMOUP,GETUSE,RWUSR)
	X	(TMZOUT,GETTMZ,RWTMZ)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CUT,CUTZ,^D16,USRRQQ)

; code for change user time zone starts here, only immediate mode and
; PROCESS command can enter the following codes

        PUSHJ   P,GETACC
         JRST   GETCMD
        SNDBYT  (ACTPRT,\B.ACOM,LHOACT,I)  ; get all hosts for this user
        SNDBYT  (AC,\B.UUN,NMUUN)
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Error in listing hosts for this user/])
                 JRST    CUTZE3]
        PUSHJ   P,GHSTAC              ; input hosts
        SETZM   ACTSY2
        SETZM   UAHSTC
        SETZM   NUM5
CTZLOP:
        MOVE    AC1,UAHSTC            ; get count
        CAML    AC1,UAHSTP            ; skip if less than total
         JRST   CTZTAT
        MOVE    AC1,UAHST(AC1)        ; get a host number
        MOVEM   AC1,HOST
        MOVEM   AC1,LUDNUM
        PUSHJ   P,GETOLD
         JRST   CTZLOP    ; if can't get circuit, skip and get next host
        MOVE    AC1,OLDASY
        CAMN    AC1,ACTSY2
         JRST   CGTZLU
        MOVEM   AC1,ACTSY2
 
; change user time zone in accounting
 
        SNDBYT  (ACTPRT,\B.ACOM,CTZACT,I)
        SNDBYT  (AC,\B.UUN,NMUUN)     ; send uun
        SNDBYT  (AC,\B.ACOM,ACTSY2)   ; send actg sys type
        SNDBYT  (AC,\B.TZ,UATZ)       ; send time zone byte
        PUSHJ   P,AGANS
         JRST   CUTZE2
        JRST    CGTZLU
 
; change user time zone in lud - will be treated differently according to
; system type
  
CGTZLU: MOVE    AC,OLDASY             ; get accounting system type
        CAIN    AC,A370               ; skip if not 370
         JRST   SND37T
        CAIN    AC,A940               ; skip if not 940
         JRST   SND94T
 
        ; sending time zone to pdp10 host
 
	SNDBYT	(OLDPRT,\B.LCOM,CTZLUD,I)	
        SNDSTR  (AC,L.UNM,UNMSPC)
        SNDBYT  (AC,\B.TZ,UATZ)
        JRST    SNDTDN
 
SND37T: ; sending time zone to 370 host
	SNDBYT	(OLDPRT,\B.LCOM,CTZLUD,I)	
       	SNDSTR  (AC,L.UNM3,UNMSPC)
	SNDBYT	(AC,\B.TZ,UATZ)
        JRST    SNDTDN
 
SND94T: ; sending time zone to 940 host
	SNDBYT	(OLDPRT,\B.LCOM,CTZ94L,I)   ; slave code for change time zone
                                            ; in 940 lud is CTZ94L = 33
        SNDBYT  (OLDPRT,\B.940W,0,I)    ; send dummy request no.
        SNDSTR  (AC,L.UNM,UNMSPC)
        SNDBYT  (AC,\B.TZ,UATZ)
        SNDBYT  (AC,\B.TZ,0,I)          ; send a zero byte, required by 940
        SNDBYT  (AC,\B.940W,[44444444]) ; send 44444444 in octal
 
SNDTDN: PUSHJ   P,OLDA
         JRST   CUTMZ2
	AOS     UAHSTC                ; increment count
	JRST    CTZLOP
; tattle
CTZTAT:
        MOVE    AC1,NUM5
        CAIE    AC1,0
         JRST   [TYPSTR  ([ASCIZ/Entry Partially Complete./])
                 JRST    CTZTA2]
        TYPSTR  ([ASCIZ/Entry Complete./])
CTZTA2: GETT    (/CHG/)
	 JRST	CUTMZ4
	TTFSTR	([ASCIZ/Change User Time Zone/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
        SETZM   NUM5
 
CUTMZ4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CUTMZD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
         JRST   CUTMZD
	JRST	CUTST2			; ABRV'ST2 is the menu output section

CUTMZD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

CUTZE2: ; error during change time zone in acct.
        TYPSTR  ([ASCIZ/Error during Change User Time Zone in Acctg./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        MOVEI   AC1,1
        MOVEM   AC1,NUM5
        AOS     UAHSTC
        JRST    CTZLOP
 
CUTMZ2:	; error during change time zone in lud
	TYPSTR	([ASCIZ/Error during Change User Time Zone in the Lud./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        MOVEI   AC1,1
        MOVEM   AC1,NUM5
        AOS     UAHSTC
        JRST    CTZLOP
 
CUTZE3: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    CUTST2
 
; end of code for change user time zone
 
TMZOUT:
        TYPSTR  ([ASCIZ/Time Zone :/],777,0,T.P0,N)
        TYPSTR  (TZSAV,B.MDI,0,T.P2,N)
        MOVE    AC,ANS1
        CAME    AC,[ASCII/Y    /]
         CAMN   AC,[ASCII/     /]
         JRST   SAVOUT
        TYPSTR  ([ASCIZ/ /])
        POPJ    P,
SAVOUT:
        TYPSTR  ([ASCIZ/- Subject to Daylight Savings/],777,2)
        POPJ    P,
 
GETHME: ; get system number and check user name is valid on that host
        INNUM   ([ASCIZ/Host :/],D)
         JRST   [PUSHJ  P,INORNO
                  JRST  GETHME]
        JUMPE   AC1,.-1
        MOVEM   AC1,LUDNUM
        MOVEM   AC1,HOST
        TLNE    FLG2,V.LSQ            ; skip if not a list command
         POPJ   P,
        PUSHJ   P,GETOLD
         JRST   GETCMD
        TLNN    FLG2,V.EXC            ; skip if changing items
         POPJ   P,
        PUSHJ   P,CKUVA1              ; check username valid on this host
         JRST   [TYPSTR  ([ASCIZ/Name not in Host/])
                 PUSHJ  P,INORNO
                  JRST  GETHME]
        POPJ    P,
 
GETTMZ: ; get UATZ for both accounting and lud
        INSTR   ([ASCIZ/Time Zone :/],TZSAV,B.MDI)  
        ; borrow B.MDI = 3 for only taking first 3 bytes from input
        MOVE    AC,TZSAV
        MOVE    AC1,[-TMZTLN,,0]
TMZLP:
        CAMN    AC,TMZTB(AC1)
         JRST   TMZFD                       ; match
        AOBJN   AC1,TMZLP                   ; add 1 on ac1 both halves
                                            ; and back to TMZLP if left half
                                            ; is not zero
        TYPSTR  ([ASCIZ/Options are : /])
        TYPSTR  (TMZTB)
        JRST    GETTMZ
 
TMZFD:
        MOVE    AC,TMZNU(AC1)
        MOVEM   AC,UATZ
        GETYR   ([ASCIZ/Subject to Daylight Savings ? /])
         JRST   [MOVEM   AC,ANS1            ; save no
                 POPJ    P,]
        MOVEM   AC,ANS1                     ; save yes
        MOVE    AC1,UATZ
        TRO     AC1,TZMASK                  ; set daylight savings bit
        MOVEM   AC1,UATZ
        POPJ    P,
 
RWTMZ:
        REQOUT  (REQ,TZSAV,B.MDI)
        REQOUT  (REQ,ANS1,1)                 ; write yes/no for daylight sav.
        POPJ    P,
 
TMZTB:  ASCII/HST  /
        ASCII/PST  /
        ASCII/MST  /
        ASCII/CST  /
        ASCII/EST  /
        ASCII/AST  /
        ASCII/GMT  /
        ASCII/WET  /
        ASCII/CET  /
        ASCII/JST  /
        ASCII/BST  /
TMZTLN==.-TMZTB
TMZNU:   6
         ^D8
         ^D9
         ^D10
         ^D11
         ^D12
         ^D16
         ^D16
         ^D17
         ^D25
         ^D26
CMDCUF: ; change user focus flat fee flag
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CUFO <
	X	(HST1OT,GETH37,RWH37)
	X	(NAMOUP,GETUSR,RWUSR)
	X	(FOCOUT,GETFOC,RWFOC)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CUF,CUFO,^D17,USRRQQ)

; code for change user focus flat fee starts here
        SNDBYT  (OLDPRT,\B.LCOM,CFOLUD,I)       ; change user focus fee flag
        SNDSTR  (AC,L.UNM3,UNMSPC)
        SNDBYT  (AC,\B.FOCF,ACFOCF)
	PUSHJ	P,OLDA
	 JRST	CUFOR2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CUFOR4
	TTFSTR	([ASCIZ/Change User Focus Flat Fee Flag/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
CUFOR4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CUFORD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CUFORD
	JRST	CUFST2			; ABRV'ST2 is the menu output section

CUFORD: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

CUFOR2:	; error during change user focus flat fee flag
	TYPSTR	([ASCIZ/Error during Change User Focus Flat Fee Flag./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	CUFOR3

CUFOR3:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	CUFST2

; end of code for change user focus flat fee flag
 
FOCOUT:
        MOVE    AC,ACFOCF
        CAIE    AC,0
         JRST   FOCON
        TYPSTR  ([ASCIZ/Turn off Focus Flat Fee Arrangement /],777,0,T.P0)
        POPJ    P,
FOCON:
        TYPSTR  ([ASCIZ/Turn on Focus Flat Fee Arrangement /],777,0,T.P0)
        POPJ    P,
 
GETFOC: GETYR   ([ASCIZ/Turn on Focus Flat Fee Arrangement ?/])
         JRST   FOCOFF
        MOVEI   AC1,^D32
        MOVEM   AC1,ACFOCF
        POPJ    P,
FOCOFF:
        MOVEI   AC1,0
        MOVEM   AC1,ACFOCF
        POPJ    P,
 
RWFOC:
        MOVE    AC,ACFOCF
        CAIN    AC,0
         PUSHJ   P,WRNO
        PUSHJ   P,WRYES
        POPJ    P,
 
CMDCLI: ; change user license bits in lud and cud (mud)
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CLIC <
	X	(MONOUT,GETMON,RWMON)
	X	(NAMOUP,GETUR3,RWUSR)
	X	(LICOUT,GETLIS,RWLIC)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CLI,CLIC,^D18,USRRQQ)

; code for change user license bits starts here, only immediate mode and
; PROCESS command can enter the following codes

; change user license bits in lud or cud will be treated differently
; according to system type 
  
        MOVE    AC,MUDON              
        CAIN    AC,1                  ; change cud lic?
         JRST   SNDMUL                ; yes
        MOVE    AC,OLDASY             ; get accounting system type
        CAIN    AC,A370               ; skip if not 370
         JRST   SND37L
        CAIN    AC,A940               ; skip if not 940
         JRST   SND94L
        CAIN    AC,A10                ; skip if not pdp10
         JRST   SND10L
 
SNDMUL: ; sending license bits to cud
        SNDBYT  (CUDPRT,\B.CCOM,CLIMUD,I)
        PUSHJ   P,SNMCUD                ; send username
        MOVE    AC1,NMCPAR
        LSH     AC1,-^D8                ; right shift 8 bits
        MOVEM   AC1,NMCPAR              
        SNDBYT  (CUDPRT,\B.CPR,NMCPAR)  ; send license (2 bytes)
        PUSHJ   P,SND40                 ; send terminate char.
        PUSHJ   P,NGANS                 ; get a byte from cud
         JRST   ERRCUD                  ; error
        PUSHJ   P,GET40
        MOVE    AC1,NMCPAR
        LSH     AC1,^D8                 ; return to old status for next
        MOVEM   AC1,NMCPAR              ; request
        MOVE    AC,NMCOLN
        CAMN    AC,SAVCLN               ; see if NMCOLN has been modified
         JRST   WRTATT                  ; no
                                        ; change colon word
        MOVE    AC1,NMCOLN
        LSH     AC1,-^D16               ; right shift 16 bits
        MOVEM   AC1,NMCOLN
        SNDBYT  (CUDPRT,\B.CCOM,CBIMUD,I)  ; change billbit in colon word
        PUSHJ   P,SNMCUD                ; send username
        SNDBYT  (CUDPRT,\B.CLN,NMCOLN)  ; send colon word
        PUSHJ   P,SND40                 ; send terminate char.
        PUSHJ   P,NGANS                 ; get a byte from cud
         JRST   ERRCUD                  ; error
        PUSHJ   P,GET40
        SNDBYT  (CUDPRT,\B.CCOM,CCOMUD,I)  ; change colon option in colon word
        PUSHJ   P,SNMCUD                ; send username
        SNDBYT  (CUDPRT,\B.CLN,NMCOLN)  ; send colon word
        PUSHJ   P,SND40                 ; send terminate char.
        PUSHJ   P,NGANS                 ; get a byte from cud
         JRST   ERRCUD                  ; error
        PUSHJ   P,GET40
        SNDBYT  (CUDPRT,\B.CCOM,CNPMUD,I)  ; change no-psw in colon word
        PUSHJ   P,SNMCUD                ; send username
        MOVE    AC1,NMCOLN
        LSH     AC1,-^D4                ; right shift 4 more bits
        MOVEM   AC1,NMCOLN
        SNDBYT  (CUDPRT,\B.CLN,NMCOLN)  ; send colon word
        PUSHJ   P,SND40                 ; send terminate char.
        PUSHJ   P,NGANS                 ; get a byte from cud
         JRST   ERRCUD                  ; error
        PUSHJ   P,GET40
        MOVE    AC1,NMCOLN
        LSH     AC1,^D20                ; return to old status for next
        MOVEM   AC1,NMCOLN              ; request
        JRST    WRTATT
 
SND10L: ; sending license bits to pdp10 host
 
	SNDBYT	(OLDPRT,\B.LCOM,CPVLUD,I)	
        SNDSTR  (AC,L.UNM,UNMSPC)
        MOVE    AC1,LUXPRV
        LSH     AC1,-^D12               ; right shift 12 bits
        MOVEM   AC1,LUXPRV
        SNDBYT  (OLDPRT,\B.PRV,LUXPRV)
        JRST    SNDLDN
 
SND37L: ; sending license bits to 370 host
	SNDBYT	(OLDPRT,\B.LCOM,CPVLUD,I)	
       	SNDSTR  (AC,L.UNM3,UNMSPC)
	SNDBYT	(AC,\B.FS,LIC1)
	SNDBYT	(AC,\B.FS,DFLAG)      
	SNDBYT	(AC,\B.FS,LIC2)       ; lic2, see 1point documentation
        MOVEI   AC1,^D255             ; temporarily shut off 3rd word
        MOVEM   AC1,DFLAG             ; license (assume no change)
        SNDBYT  (OLDPRT,\B.FS,DFLAG)
        SNDBYT  (OLDPRT,\B.FS,LIC2)
        JRST    SNDLDN
 
SND94L: ; sending license bits to 940 host
	SNDBYT	(OLDPRT,\B.LCOM,CPVLUD,I)
        SNDBYT  (OLDPRT,\B.940W,0,I)    ; send dummy request no.
        SNDSTR  (AC,L.UNM,UNMSPC)
        SNDBYT  (AC,\B.940W,LU9CPR)
        SNDBYT  (AC,\B.940W,[44444444]) ; send 44444444 in octal
 
SNDLDN: PUSHJ   P,OLDA
         JRST   CULIC2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        MOVE    AC,OLDASY
        CAIE    AC,A10                ; if pdp-10 then shift 12 bits to left
         JRST   UPDMUL
        MOVE    AC1,LUXPRV
        LSH     AC1,^D12              ; for next request
        MOVEM   AC1,LUXPRV
UPDMUL: MOVE    AC,NMCPAR
        CAMN    AC,SAVCPR             ; see if NMCPAR has been modified
         JRST   WRTATT                ; no
        JRST    SNDMUL                ; yes, update license in cud
 
WRTATT: ; tattle
        MOVE    AC,MUDON
        CAIE    AC,1                  ; MUDON = 1 means change cud lic
         JRST   WRTAT1
        TYPSTR  ([ASCIZ/Entry Complete./])
WRTAT1: GETT    (/CHG/)
	 JRST	CULIC4
	TTFSTR	([ASCIZ/Change User License Bits/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
 
CULIC4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CULICD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
         JRST   CULICD
	JRST	CLIST2			; ABRV'ST2 is the menu output section

CULICD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

CULIC2:	; error during change license bits in lud
	TYPSTR	([ASCIZ/Error during Change User License in the Lud./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        POPJ    P,
 
; end of code for change user license bits
 
MONOUT:
        TLNN    FLG,U.PRV             ; skip if privileged
         JRST   MONOU2
        TYPSTR  ([ASCIZ/Host or Cud:/],777,0,T.P0,N)
        JRST    MONOU3
MONOU2: TYPSTR  ([ASCIZ/Host: /],777,0,T.P0,N)
MONOU3: TYPSTR  (HOST1,L.HOST,0,T.P2)
        POPJ    P,
 
GETMON: ; get cud or host number
        SETZM   MUDON
        TLNN    FLG,U.PRV
         JRST   GETMO2
        INSTR   ([ASCIZ/Host or Cud :/],HOST1,L.HOST,T)
        JRST    GETMO3
GETMO2: INSTR   ([ASCIZ/Host : /],HOST1,L.HOST,T)
GETMO3: MOVE    AC4,[POINT 7,HOST1]    ; set byte pointer to AC4 which
                                       ; points to HOST1
        PUSHJ   P,CNVHOS               ; call conversion routine
        MOVE    AC,MUDON
        CAIN    AC,1                   ; change cud lic?
         POPJ   P,                     ; yes
        CAIN    AC1,0                  ; HOST1 is blank?
         JRST   GETMON
        MOVEM   AC1,LUDNUM
        MOVEM   AC1,HOST
 ;      PUSHJ   P,GETACC              ; build circuit to accounting
 ;       JRST   GETOLE
 ;      SNDBYT  (ACTPRT,\B.ACOM,LHAACT,I)   ; get ast from acctg
 ;      SNDBYT  (ACTPRT,\B.HST,LUDNUM)
 ;      PUSHJ   P,AGANS
 ;       JRST   GETOE1                ; error of locating host in acctg. db
 ;      GETBYT  (ACTPRT)
 ;       JRST   GETCMD
 ;      MOVEM   AC1,OLDASY
 ;      TLNE    FLG2,V.LSQ             ; skip if not a list command
 ;       POPJ   P,
        PUSHJ   P,GETOLD               ; OLDASY is defined in GETOLD
         JRST   GETCMD
        TLNN    FLG2,V.EXC             ; skip if changing items
         POPJ   P,
        PUSHJ   P,CKUVA1               ; check username valid on this host
         JRST   [TYPSTR  ([ASCIZ/Name not in Host/])
                 PUSHJ  P,INORNO
                  JRST  GETMON]
        POPJ    P,
CNVHOS: ; convert HOST1 from characters to number, if HOST1 is not Cud
        SETZ    AC1,
CNVHO1:
        ILDB    AC,AC4                 ; put first or next char. in AC
        CAIN    AC," "                 ; blank means end of token
         POPJ   P,
        CAIN    AC,"C"                 ; C means cud
         JRST   [MOVEI   AC,1
                 MOVEM   AC,MUDON
                 POPJ    P,]           ; move 1 into MUDON and return
        CAIL    AC,"0"
        CAILE   AC,"9"
         JRST   NOTMON
        SUBI    AC,"0"
        IMULI   AC1,^D10
        ADD     AC1,AC
        JRST    CNVHO1                 ; get next char.
 
NOTMON:
        TYPSTR  ([ASCIZ/Must be cud or a host number/])
        JRST    GETMON

GETUR3: ; get username, cud license and colon option from GCREC
        PUSHJ   P,GETUNM
	 JRST	[PUSHJ	P,INORNO
		 JRST	GETUR3]
	TLNE	FLG2,V.LSQ	       ; skip this part if doing a list
	 POPJ	P,
	PUSHJ	P,GETCUD
	 JRST	GETCMD
	PUSHJ	P,GCREC
	 JRST	GETUR4
	PUSHJ	P,CHKUUN	       ; check access
	 JRST	GETUR4
        MOVE    AC,NMCOLN
        MOVEM   AC,SAVCLN              ; save nmcoln
        MOVE    AC,NMCPAR
        MOVEM   AC,SAVCPR              ; save nmcpar
        MOVE    AC,MUDON
        CAIN    AC,1
         POPJ   P,
	PUSHJ	P,CKUVA1             ; if change lud lic. then check name valid
         JRST   [TYPSTR  ([ASCIZ/Name not in Host./],777,0,0,Y)
                 JRST    GETUR4]
	POPJ	P,
GETUR4:	; here when username does not match
	TRNN	FLG,U.RFI	; skip if this is from  a request
         JRST   [PUSHJ  P,INORNO
		 JRST	GETUR3]
	PUSHJ	P,REQERR
	POPJ	P,
 
LICOUT:
        MOVE    AC,MUDON
        CAIN    AC,1                  ; change cud lic?
         JRST   OUT4LS
        MOVE    AC,OLDASY
        CAIN    AC,A10
         JRST   OUT1LS
        CAIN    AC,A370
         JRST   OUT3LS
        CAIN    AC,A940
         JRST   OUT9LS
 
OUT4LS: ; output cud license
        PUSHJ   P,CPROUT
        PUSHJ   P,CLNOUT
        TCR     (1)
        POPJ    P,
OUT1LS: ; output pdp-10 license
        MOVE    AC,LUXPRV
        PUSHJ   P,PRVOUT
        POPJ    P,
OUT9LS: ; output 940 license
        MOVE    AC,NMCPAR
        MOVEM   AC,TEMCPR             ; save nmcpar temporary
        MOVE    AC,LU9CPR
        TRZ     AC,DISMSK             ; remove district bits
        TLZ     AC,LOS.CD             ; and shut override
        MOVEM   AC,NMCPAR
        PUSHJ   P,CPROUT
        MOVE    AC,TEMCPR
        MOVEM   AC,NMCPAR             ; put back real nmcpar
        TCR     (1)
        POPJ    P,
OUT3LS: ; output 370 license
        TYPSTR  ([ASCIZ/Lic :/],777,0,T.P0,N)
        MOVEI   AC,T.P2-1
        PUSHJ   P,TABS
        MOVE    AC1,LIC1
        TRNN    AC1,1B35
         JRST   OUTB34
        TYPSTR  ([ASCIZ/Tym/],777,1,0,N)
OUTB34: MOVE    AC1,LIC1
        TRNN    AC1,1B34
         JRST   OUTB33
        TYPSTR  ([ASCIZ/Vlog/],777,1,0,N)
OUTB33: MOVE    AC1,LIC1
        TRNN    AC1,1B33
         JRST   OUTB32
        TYPSTR  ([ASCIZ/Vgan/],777,1,0,N)
OUTB32: MOVE    AC1,LIC1
        TRNN    AC1,1B32
         JRST   OUTB31
        TYPSTR  ([ASCIZ/A.S./],777,1,0,N)
OUTB31: MOVE    AC1,LIC1
        TRNN    AC1,1B31
         JRST   OUTB30
        TYPSTR  ([ASCIZ/Hush/],777,1,0,N)
OUTB30: MOVE    AC1,LIC1
        TRNN    AC1,1B30
         JRST   OUTB29
        TYPSTR  ([ASCIZ/Focus/],777,1,0,N)
OUTB29: MOVE    AC1,LIC1
        TRNN    AC1,1B29
         JRST   OUTB28
        TYPSTR  ([ASCIZ/Chggan/],777,1,0,N)
OUTB28: MOVE    AC1,LIC1
        TRNN    AC1,1B28
         JRST   OT2B34
        TYPSTR  ([ASCIZ/Chgall/],777,1,0,N)
OT2B34: MOVE    AC1,LIC2
        TRNN    AC1,1B34
         JRST   OT2B33
        TYPSTR  ([ASCIZ/Accounting/],777,1,0,N)
OT2B33: MOVE    AC1,LIC2
        TRNN    AC1,1B33
         JRST   OT2B32
        TYPSTR  ([ASCIZ/Markup/],777,1,0,N)
OT2B32: MOVE    AC1,LIC2
        TRNN    AC1,1B32
         JRST   OT2B31
        TYPSTR  ([ASCIZ/Savencp/],777,1,0,N)
OT2B31: MOVE    AC1,LIC2
        TRNN    AC1,1B31
         JRST   OT2B30
        TYPSTR  ([ASCIZ/Savesys/],777,1,0,N)
OT2B30: MOVE    AC1,LIC2
        TRNN    AC1,1B30
         JRST   OT2B29
        TYPSTR  ([ASCIZ/Auxlic/],777,1,0,N)
OT2B29: MOVE    AC1,LIC2
        TRNN    AC1,1B29
         JRST   OT2B28
        TYPSTR  ([ASCIZ/Wlnk/],777,1,0,N)
OT2B28: MOVE    AC1,LIC2
        TRNN    AC1,1B28
         JRST   OT2BDN
        TYPSTR  ([ASCIZ/Rlnk/],777,1,0,N)
OT2BDN: TYPSTR  ([ASCIZ/ /],777,1,0,Y)
        POPJ    P,
 
GETLIS:
        MOVE    AC,MUDON
        CAIN    AC,1
         JRST   GET4LS
        MOVE    AC,OLDASY
        CAIN    AC,A10
         JRST   GET1LS
        CAIN    AC,A370
         JRST   GET3LS
        CAIN    AC,A940
         JRST   GET9LS
 
GET4LS: ; get cud license
        SETZ    AC,
        MOVEM   AC,NMCPAR             ; move zero to nmcpar
        MOVEM   AC,NMCOLN             ; move zero to nmcoln
        GETYR   ([ASCIZ/Tym? /])
         JRST   .+4
        MOVE    AC,NMCPAR
        TLO     AC,TYM.CD
        MOVEM   AC,NMCPAR
        GETYR   ([ASCIZ/Prm? /])
         JRST   .+4
        MOVE    AC,NMCPAR
        TLO     AC,PRM.CD
        MOVEM   AC,NMCPAR
        GETYR   ([ASCIZ/Los? /])
         JRST   .+4
        MOVE    AC,NMCPAR
        TLO     AC,LOS.CD
        MOVEM   AC,NMCPAR
        GETYR   ([ASCIZ/A.S.? /])
         JRST   .+4
        MOVE    AC,NMCPAR
        TLO     AC,AS.CD 
        MOVEM   AC,NMCPAR
        GETYR   ([ASCIZ/Hush? /])
         JRST   .+4
        MOVE    AC,NMCPAR
        TLO     AC,HSH.CD
        MOVEM   AC,NMCPAR
        GETYR   ([ASCIZ/Nomult? /])
         JRST   .+4
        MOVE    AC,NMCPAR
        TRO     AC,NML.CD
        MOVEM   AC,NMCPAR
        GETYR   ([ASCIZ/No-chg-psw? /])
         JRST   .+4
        MOVE    AC,NMCPAR
        TRO     AC,NPC.CD
        MOVEM   AC,NMCPAR
        GETYR   ([ASCIZ/Gty? /])
         JRST   .+4
        MOVE    AC,NMCPAR
        TRO     AC,GTW.CD
        MOVEM   AC,NMCPAR
        GETYR   ([ASCIZ/Rub? /])
         JRST   .+4
        MOVE    AC,NMCPAR
        TRO     AC,RUB.CD
        MOVEM   AC,NMCPAR
        GETYR   ([ASCIZ/Slow? /])
         JRST   .+4
        MOVE    AC,NMCPAR
        TRO     AC,SLW.CD
        MOVEM   AC,NMCPAR
        GETYR   ([ASCIZ/Non-bill ?/])
         JRST   .+4
        MOVE    AC,NMCOLN
        TLO     AC,BIL.CD
        MOVEM   AC,NMCOLN
        GETYR   ([ASCIZ/No-colon ?/])
         JRST   .+4
        MOVE    AC,NMCOLN
        TLO     AC,CLN.CD
        MOVEM   AC,NMCOLN
        GETYR   ([ASCIZ/No-psw ?/])
         JRST   .+4
        MOVE    AC,NMCOLN
        TLO     AC,NPS.CD
        MOVEM   AC,NMCOLN
        POPJ    P,
 
GET1LS: ; get license for pdp10 host
        MOVE    AC,NMCPAR
        TLZ     AC,TYM.CD             ; turn off tym bit in nmcpar
        TLZ     AC,AS.CD              ; turn off a.s. bit
        TLZ     AC,HSH.CD             ; turn off hush bit
        MOVEM   AC,NMCPAR
        SETZ    AC,
        MOVEM   AC,LUXPRV             ; set zero to luxprv
        GETYR   ([ASCIZ/Tym? /])
         JRST   .+7
        MOVE    AC,LUXPRV
        TLO     AC,TYM.LX
        MOVEM   AC,LUXPRV
        MOVE    AC,NMCPAR             ; also update cud lic.
        TLO     AC,TYM.CD
        MOVEM   AC,NMCPAR
        GETYR   ([ASCIZ/A.S.? /])
         JRST   .+7
        MOVE    AC,LUXPRV
        TLO     AC,AS.LX
        MOVEM   AC,LUXPRV
        MOVE    AC,NMCPAR
        TLO     AC,AS.CD
        MOVEM   AC,NMCPAR
        GETYR   ([ASCIZ/Hush? /])
         JRST   .+7
        MOVE    AC,LUXPRV
        TLO     AC,HSH.LX
        MOVEM   AC,LUXPRV
        MOVE    AC,NMCPAR
        TLO     AC,HSH.CD
        MOVEM   AC,NMCPAR
        TLNN    FLG,U.PRV             ; if non_privilege then prompt mode
         JRST   GTMODE
        GETYR   ([ASCIZ/Gfd? /])
         JRST   .+4
        MOVE    AC,LUXPRV
        TLO     AC,GFD.LX
        MOVEM   AC,LUXPRV
        GETYR   ([ASCIZ/Rcm? /])
         JRST   .+4
        MOVE    AC,LUXPRV
        TRO     AC,RCM.LX
        MOVEM   AC,LUXPRV
        GETYR   ([ASCIZ/Rub? /])
         JRST   .+4
        MOVE    AC,LUXPRV
        TLO     AC,RUB.LX
        MOVEM   AC,LUXPRV
GTMODE: GETYR   ([ASCIZ/Xexec? /])
         JRST   .+5
        MOVE    AC,LUXPRV
        TRO     AC,1B23
        MOVEM   AC,LUXPRV
        POPJ    P,
        GETYR   ([ASCIZ/Xexec-J? /])
         JRST   .+5
        MOVE    AC,LUXPRV
        TRO     AC,1B22
        MOVEM   AC,LUXPRV
        POPJ    P,
        GETYR   ([ASCIZ/Pdp-10? /])
         JRST   .+2
        POPJ    P,                    ; if yes then leave bits 22-23 off
        MOVE    AC,LUXPRV             ; if no then default to mode = suds
        TRO     AC,1B22
        TRO     AC,1B23
        MOVEM   AC,LUXPRV
        POPJ    P,
 
GET9LS: ; get license for 940, first get LU9CPR from lud which contains
        ; district bits that we have to keep in setting new lic. bits
        MOVE    AC,NMCPAR             ; zero following bits in nmcpar
        TLZ     AC,TYM.CD
        TLZ     AC,PRM.CD
        TLZ     AC,AS.CD
        TLZ     AC,HSH.CD
        TRZ     AC,NML.CD
        TRZ     AC,NPC.CD
        MOVEM   AC,NMCPAR
        PUSHJ   P,GLREC               ; get lud record 
         JRST   GET9LS
        MOVE    AC,LU9CPR
        TLZ     AC,TYM.CD
        TLZ     AC,PRM.CD
        TLZ     AC,AS.CD
        TLZ     AC,HSH.CD
        TRZ     AC,NML.CD
        TRZ     AC,NPC.CD
        MOVEM   AC,LU9CPR
        GETYR   ([ASCIZ/Tym? /])
         JRST   .+7
        MOVE    AC,LU9CPR
        TLO     AC,TYM.CD
        MOVEM   AC,LU9CPR
        MOVE    AC,NMCPAR
        TLO     AC,TYM.CD
        MOVEM   AC,NMCPAR
        GETYR   ([ASCIZ/Prm? /])
         JRST   .+7
        MOVE    AC,LU9CPR
        TLO     AC,PRM.CD
        MOVEM   AC,LU9CPR
        MOVE    AC,NMCPAR
        TLO     AC,PRM.CD
        MOVEM   AC,NMCPAR
        GETYR   ([ASCIZ/A.S.? /])
         JRST   .+7
        MOVE    AC,LU9CPR
        TLO     AC,AS.CD 
        MOVEM   AC,LU9CPR
        MOVE    AC,NMCPAR
        TLO     AC,AS.CD
        MOVEM   AC,NMCPAR
        GETYR   ([ASCIZ/Hush? /])
         JRST   .+7
        MOVE    AC,LU9CPR
        TLO     AC,HSH.CD
        MOVEM   AC,LU9CPR
        MOVE    AC,NMCPAR
        TLO     AC,HSH.CD
        MOVEM   AC,NMCPAR
        GETYR   ([ASCIZ/Nomult? /])
         JRST   .+7
        MOVE    AC,LU9CPR
        TRO     AC,NML.CD
        MOVEM   AC,LU9CPR
        MOVE    AC,NMCPAR
        TRO     AC,NML.CD
        MOVEM   AC,NMCPAR
        TLNN    FLG,U.PRV             ; privileged?
         POPJ   P,
        GETYR   ([ASCIZ/No-chg-psw? /])
         JRST   .+7
        MOVE    AC,LU9CPR
        TRO     AC,NPC.CD
        MOVEM   AC,LU9CPR
        MOVE    AC,NMCPAR
        TRO     AC,NPC.CD
        MOVEM   AC,NMCPAR
        POPJ    P,
 
GET3LS: ; get license for 370 host
        SETZ    AC,
        MOVEM   AC,LIC1
        MOVEM   AC,DFLAG
        MOVEM   AC,LIC2
        MOVE    AC,NMCPAR
        TLZ     AC,TYM.CD
        TLZ     AC,AS.CD
        TLZ     AC,HSH.CD
        MOVEM   AC,NMCPAR
        GETYR   ([ASCIZ/Tym? /])
         JRST   .+7
        MOVE    AC,LIC1
        TRO     AC,1B35
        MOVEM   AC,LIC1
        MOVE    AC,NMCPAR
        TLO     AC,TYM.CD
        MOVEM   AC,NMCPAR
        GETYR   ([ASCIZ/A.S.? /])
         JRST   .+7
        MOVE    AC,LIC1
        TRO     AC,1B32
        MOVEM   AC,LIC1
        MOVE    AC,NMCPAR
        TLO     AC,AS.CD
        MOVEM   AC,NMCPAR
        GETYR   ([ASCIZ/Hush? /])
         JRST   .+7
        MOVE    AC,LIC1
        TRO     AC,1B31
        MOVEM   AC,LIC1
        MOVE    AC,NMCPAR
        TLO     AC,HSH.CD
        MOVEM   AC,NMCPAR
        GETYR   ([ASCIZ/Vlog? /])
         JRST   .+5
        MOVE    AC,LIC1
        TRO     AC,1B34
        MOVEM   AC,LIC1
        JRST    GTREST
        GETYR   ([ASCIZ/Vgan? /])
         JRST   .+4
        MOVE    AC,LIC1
        TRO     AC,1B33
        MOVEM   AC,LIC1
GTREST: TLNN    FLG,U.PRV             ; privileged?
         POPJ   P,
        GETYR   ([ASCIZ/Focus? /])
         JRST   .+4
        MOVE    AC,LIC1
        TRO     AC,1B30
        MOVEM   AC,LIC1
        GETYR   ([ASCIZ/Chggan? /])
         JRST   .+4
        MOVE    AC,LIC1
        TRO     AC,1B29
        MOVEM   AC,LIC1
        GETYR   ([ASCIZ/Chgall? /])
         JRST   .+4
        MOVE    AC,LIC1
        TRO     AC,1B28
        MOVEM   AC,LIC1
        GETYR   ([ASCIZ/Rlnk? /])
         JRST   .+4
        MOVE    AC,LIC2
        TRO     AC,1B28
        MOVEM   AC,LIC2
        GETYR   ([ASCIZ/Wlnk? /])
         JRST   .+4
        MOVE    AC,LIC2
        TRO     AC,1B29
        MOVEM   AC,LIC2
        GETYR   ([ASCIZ/Auxlic? /])
         JRST   .+4
        MOVE    AC,LIC2
        TRO     AC,1B30
        MOVEM   AC,LIC2
        GETYR   ([ASCIZ/Savesys? /])
        JRST    .+4
        MOVE    AC,LIC2
        TRO     AC,1B31
        MOVEM   AC,LIC2
        GETYR   ([ASCIZ/Savencp? /])
         JRST   .+4
        MOVE    AC,LIC2
        TRO     AC,1B32
        MOVEM   AC,LIC2
        GETYR   ([ASCIZ/Markup? /])
         JRST   .+4
        MOVE    AC,LIC2
        TRO     AC,1B33
        MOVEM   AC,LIC2
        GETYR   ([ASCIZ/Accounting? /])
         JRST   .+4
        MOVE    AC,LIC2
        TRO     AC,1B34
        MOVEM   AC,LIC2
        POPJ    P,
 
RWMON:
        REQOUT  (REQ,HOST1,L.HOST)
        POPJ    P,
 
RWLIC:
        MOVE    AC,MUDON
        CAIN    AC,1
         JRST   RW4LS
        MOVE    AC,OLDASY
        CAIN    AC,A10
         JRST   RW1LS
        CAIN    AC,A370
         JRST   RW3LS
        CAIN    AC,A940
         JRST   RW9LS
 
RW4LS:  ; write mud license, not used now, since only privileged users can
        ; change mud license and they will be dropped into immediate mode
        MOVE    AC1,NMCPAR
        TLNN    AC1,TYM.CD
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,NMCPAR
        TLNN    AC1,PRM.CD
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,NMCPAR
        TLNN    AC1,LOS.CD
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,NMCPAR
        TLNN    AC1,AS.CD
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,NMCPAR
        TLNN    AC1,HSH.CD
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,NMCPAR
        TRNN    AC1,NML.CD
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,NMCPAR
        TRNN    AC1,NPC.CD
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,NMCPAR
        TRNN    AC1,GTW.CD
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,NMCPAR
        TRNN    AC1,RUB.CD
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,NMCPAR
        TRNN    AC1,SLW.CD
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,NMCOLN
        TLNN    AC1,BIL.CD
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,NMCOLN
        TLNN    AC1,CLN.CD
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,NMCOLN
        TLNN    AC1,NPS.CD
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        POPJ    P,
RW1LS:
        MOVE    AC1,LUXPRV
        TLNN    AC1,TYM.LX
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LUXPRV
        TLNN    AC1,AS.LX
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LUXPRV
        TLNN    AC1,HSH.LX
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LUXPRV
        TLNN    AC1,GFD.LX
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LUXPRV
        TRNN    AC1,RCM.LX
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LUXPRV
        TLNN    AC1,RUB.LX
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
RWMODE: MOVE    AC1,LUXPRV
        TRNE    AC1,1B22
         JRST   MODE1                 ; bit 22 = 1
        TRNN    AC1,1B23              ; bit 22 = 0
         JRST   MODE1                 ; bit 23 = 0
        PUSHJ   P,WRYES               ; bit 22 = 0, 23 = 1 means xexec
        POPJ    P,
MODE1:  REQOUT  (REQ,[ASCII/N/],1)    ; write no for the prompt of xexec
        MOVE    AC1,LUXPRV
        TRNE    AC1,1B23
         JRST   MODE2                 ; bit 23 = 1
        TRNN    AC1,1B22              ; bit 23 = 0
         JRST   MODE2                 ; bit 22 = 0
        PUSHJ   P,WRYES               ; bit 22 = 1 & 23 = 0 means jexec
        POPJ    P,
MODE2:  REQOUT  (REQ,[ASCII/N/],1)    ; write no for the prompt of jexec
        MOVE    AC1,LUXPRV
        TRNE    AC1,1B22
         JRST   MODE3                 ; bit 22 = 1
        TRNE    AC1,1B23              ; bit 22 = 0
         JRST   MODE3                 ; bit 23 = 1
        PUSHJ   P,WRYES               ; bit 23 = 22 = 0 means pdp-10
        POPJ    P,
MODE3:  REQOUT  (REQ,[ASCII/N/],1)    ; write no for the prompt of pdp-10
        POPJ    P,
 
RW9LS:
        MOVE    AC1,LU9CPR
        TLNN    AC1,TYM.CD
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LU9CPR
        TLNN    AC1,PRM.CD
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LU9CPR
        TLNN    AC1,AS.CD
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LU9CPR
        TLNN    AC1,HSH.CD
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LU9CPR
        TRNN    AC1,NML.CD
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LU9CPR
        TRNN    AC1,NPC.CD
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        POPJ    P,
RW3LS:
        MOVE    AC1,LIC1
        TRNN    AC1,1B35
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LIC1
        TRNN    AC1,1B32
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LIC1
        TRNN    AC1,1B31
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LIC1
        TRNN    AC1,1B34
         PUSHJ  P,WRNO
        JRST    .+4                   ; if answer for vlog is yes
        MOVE    AC1,LIC1
        TRNN    AC1,1B33
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LIC1
        TRNN    AC1,1B30
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LIC1
        TRNN    AC1,1B29
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LIC1
        TRNN    AC1,1B28
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LIC2
        TRNN    AC1,1B28
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LIC2
        TRNN    AC1,1B29
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LIC2
        TRNN    AC1,1B30
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LIC2
        TRNN    AC1,1B31
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LIC2
        TRNN    AC1,1B32
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LIC2
        TRNN    AC1,1B33
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LIC2
        TRNN    AC1,1B34
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        POPJ    P,
 
CMDCUB: ; change user tru budget
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CUBE <
        X       (HOMOUT,GETH10,RWH37)
	X	(NAMOUP,GETUSR,RWUSR)
	X	(BUDOUT,GETBUD,RWBUD)     
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CUB,CUBE,^D19,USRRQQ)

; code for change user tru budget starts here, only immediate mode and
; PROCESS command can enter into following codes

	SNDBYT	(OLDPRT,\B.LCOM,CTBLUD,I)	; change tru budget
	SNDSTR	(AC,L.UNM,UNMSPC)
        SNDBYT  (AC,\B.BUD,LUXBUD)
	PUSHJ	P,OLDA
	 JRST	CUBGT2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CUBGT4
	TTFSTR	([ASCIZ/Change User Tru Budget/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
CUBGT4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CUBGTD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CUBGTD
	JRST	CUBST2			; ABRV'ST2 is the menu output section

CUBGTD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

CUBGT2:	; error during change user tru budget
	TYPSTR	([ASCIZ/Error during Change User Tru Budget./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	CUBGT3

CUBGT3:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	CUBST2

; end of code for change user tru budget
BUDOUT:
        TYPSTR  ([ASCIZ/Tru Budget :/],777,0,T.P0,N)
        TYPNUM  (LUXBUD,D,0,T.P2)
        POPJ    P,
 
GETBUD:
        INNUM   ([ASCIZ/Tru Budget :/],D)
         JRST   GETBU2
        MOVEM   AC1,LUXBUD
        POPJ    P,
    
GETBU2:
        PUSHJ   P,INORNO
        JRST    GETBUD
 
RWBUD:
        REQNOT  (REQ,LUXBUD,D)
        POPJ    P,
 
CMDCUM: ; change tymshare or tymnet user's customer number
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CUCN <
	X	(NAMOUP,GE1USE,RWUSR)
	X	(CSMOUT,GETCSM,RWCSN)     
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CUM,CUCN,^D32,USRRQQ)

; code for change user customer number starts here, only immediate mode and
; PROCESS command can enter into following codes

        MOVE    AC1,MFLAG            
        CAIN    AC1,1                 ; change tymnet user's cid?
         JRST   [SNDBYT  (ACTPRT,\B.ACOM,CTCACT,I)
                 JRST    INPUUN]
	SNDBYT	(ACTPRT,\B.ACOM,CUCACT,I)	; change tymshare user's cid
INPUUN: SNDBYT  (ACTPRT,\B.UUN,NMUUN)
        SNDBYT  (AC,\B.CID,CUSNUM)
        PUSHJ   P,AGANS
	 JRST	CUCNE2
	MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
 
; tattle
	GETT	(/CHG/)
	 JRST	CUCUN4
	TTFSTR	([ASCIZ/Change User Customer Number/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
 
CUCUN4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CUCUND			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CUCUND
	JRST	CUMST2			; ABRV'ST2 is the menu output section

CUCUND: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
CUCNE2: ; error during change customer number
        TYPSTR  ([ASCIZ/Error during Change User Customer Number./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    CUCNE3
 
CUCNE3: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    CUMST2
 
; end of code for change user customer number
 
 
GE1USE:	; input the username and check name against cud and acct. data base
        ; also check it is a tymnet user or tymshare user. Note we assume
        ; that a user is either belonging to tymshare or tymnet but can't
        ; be in both
	PUSHJ	P,GETUNM
	 JRST	[PUSHJ	P,INORNO
		 JRST	GE1USE]
	TLNE	FLG2,V.LSQ	      ; skip if not list request
	 POPJ	P,                    ; no check for type command
        PUSHJ   P,GETACC
         JRST   GETCMD
	PUSHJ	P,GETCUD
	 JRST	GETCMD
	PUSHJ	P,GCREC
	 JRST	GE2US2
	PUSHJ	P,CHKUUN	      ; check access
	 JRST	GE2US2
        SNDBYT  (ACTPRT,\B.ACOM,LTYMCT,I)   ; list user in tusrdb
        SNDBYT  (AC,\B.UUN,NMUUN)
        PUSHJ   P,AGANS
         JRST   LUSCUM                ; if user not in tusrdb, then check usrdb
        GETBYT  (ACTPRT,\B.CID)       ; get cid
         JRST   GETCMD
        GETSTR  (ACTPRT,L.CUSN,ACCNAM)
        GETSTR  (AC,L.UNM,ACCITY)     ; get mail name - 12 bytes
        GETBYT  (ACTPRT,\B.CC)        ; get costcode
         JRST   GETCMD
        MOVEI   AC,1
        MOVEM   AC,MFLAG
        POPJ    P,
LUSCUM: SETZM   MFLAG
        SNDBYT  (ACTPRT,\B.ACOM,LCN2CT,I)   ; list user's customer number to
        SNDBYT  (AC,\B.UUN,NMUUN)           ; make sure user exists in acct. db
        GETBYT  (AC)
         JRST   GETCMD
        CAIE    AC1,ACT.OK                  ; skip if acctg. record exists
         JRST   [TYPSTR  ([ASCIZ/No acctg record for this username./])
                 JRST    GE1USE]
        GETBYT  (AC,\B.CID)
         JRST   GETCMD
        POPJ    P,
GE2US2:	; here when username does not match
	TRNN	FLG,U.RFI	; skip if this is from  a request
         JRST   [PUSHJ  P,INORNO
		 JRST	GE1USE]
	PUSHJ	P,REQERR
	POPJ	P,

CSMOUT:
        TYPSTR  ([ASCIZ/New Cid :/],777,0,T.P0,N)
        TYPNUM  (CUSNUM,D,0,T.P2)
        POPJ    P,
 
GETCSM: ; get customer number and check it is valid
        INNUM   ([ASCIZ/New Cid :/],D)
         JRST   [PUSHJ   P,INORNO
                 JRST    GETCSM]
        MOVEM   AC1,CUSNUM
        TLNE    FLG2,V.LSQ            ; skip if not list request
         POPJ   P,                    ; no check for type command
        SNDBYT  (ACTPRT,\B.ACOM,LCDACT,I)   ; list customer district
        SNDBYT  (AC,\B.CID,CUSNUM)
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/No acctg record for this customer./])
                 JRST    GETCSM]
        GETBYT  (ACTPRT,\B.DIS)       ; get district
         JRST    GETCMD
        CAMN    AC1,NMDIST            ; same district?
         POPJ   P,                    ; yes
        TYPSTR  ([ASCIZ/Customer's district and user's district must match/])
        JRST    GETCSM

CMDCSC: ; change user spool class
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CSPC <
	X	(HST1OT,GETH37,RWH37)
	X	(NAMOUP,GETUSR,RWUSR)
	X	(SPAOUT,GETSPA,RWSPA)
	X	(SPLOUT,GETSPL,RWSPL)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CSP,CSPC,6,USRRQQ)

; code for change user spool class starts here, only immediate mode and
; PROCESS command can enter into following codes

	SNDBYT	(OLDPRT,\B.LCOM,CSPLUD,I)	; change spool class
	SNDSTR	(AC,L.UNM3,UNMSPC)
        SNDSTR  (AC,L.SPA,SPA)              ; send spool address
	SNDSTR	(AC,L.SPL,SPL)              ; send spool class
	PUSHJ	P,OLDA
	 JRST	CSPAE2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CSPMC4
	TTFSTR	([ASCIZ/Change User Spool Class/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
 
CSPMC4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CSPMCD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CSPMCD
	JRST	CSPST2			; ABRV'ST2 is the menu output section

CSPMCD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

CSPAE2:	; error during change spool class
	TYPSTR	([ASCIZ/Error during Change User Spool Class./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	CSPAE3
 
CSPAE3:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	     ; skip if not processing a request
	 POPJ	P,		     ; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	CSPST2

; end of code for change user spool class
 
SPAOUT:
	TYPSTR	([ASCIZ/Spool Address :/],777,0,T.P0,N)
	TYPSTR	(SPA,L.SPA,0,T.P2)
	POPJ	P,
 
SPLOUT:
	TYPSTR	([ASCIZ/Spool Class :/],777,0,T.P0,N)
	TYPSTR	(SPL,L.SPL,0,T.P2)
	POPJ	P,

GETSPA:
	INSTR	([ASCIZ/Spool Address :/],SPA,L.SPA)
        MOVE    AC,SPA
        CAMN    AC,[ASCII/     /]     ;if not a carriage return then skip
         JRST   GETSPA
	POPJ	P,

GETSPL:
	INSTR	([ASCIZ/Spool Class :/],SPL,L.SPL)
        MOVE    AC,SPL
        CAMN    AC,[ASCII/     /]     ;if not a carriage return then skip
         JRST   GETSPL
	POPJ	P,

RWSPA:	; write SPA to request file
	REQOUT	(REQ,SPA,L.SPA)
	POPJ	P,
 
RWSPL:	; write SPL to request file
	REQOUT	(REQ,SPL,L.SPL)
	POPJ	P,
CMDCUA: ; change 370 user address
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CUAD <
	X	(HST1OT,GETH37,RWH37)
	X	(NAMOUP,GETUSR,RWUSR)
	X	(ST1OUT,GETST1,RWST1)
	X	(ST2OUT,GETST2,RWST2)
	X	(ST3OUT,GETST3,RWST3)
	X	(ST4OUT,GETST4,RWST4)
	X	(ST5OUT,GETST5,RWST5)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CUA,CUAD,^D63,USRRQQ)

; code for change user address starts here, only immediate mode and PROCESS
; can enter
        SNDBYT  (OLDPRT,\B.LCOM,AMALUD,I)       ; change user address
        SNDSTR  (AC,L.UNM3,UNMSPC)
	SNDSTR	(AC,L.ST,ST1)
	SNDSTR	(AC,L.ST,ST2)
	SNDSTR	(AC,L.ST,ST3)
	SNDSTR	(AC,L.ST,ST4)
	SNDSTR	(AC,L.ST,ST5)
        SNDSTR  (AC,1,CTRLD)          ; send control-d
        SNDSTR  (AC,^D119,ST3)        ; padding 119 chars.
	PUSHJ	P,OLDA
	 JRST	CUADE2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CUADR4
	TTFSTR	([ASCIZ/Change User Address/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
CUADR4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CUADRD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CUADRD
	JRST	CUAST2			; ABRV'ST2 is the menu output section

CUADRD: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

CUADE2:	; error during change user address
	TYPSTR	([ASCIZ/Error during Change User Address./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	CUADE3

CUADE3:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	CUAST2

; end of code for change 370 user address
CMDCCS: ; change customer salesman code
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CCUS <
        X       (SYSOUT,GE1SYS,RWSYS)
	X	(CSNOU1,GETCSN,RWCSN)              
	X	(SALOUT,GETSAL,RWSAL)     
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CCS,CCUS,^D20,CUSRQQ)

; code for change customer salesman number starts here, only immediate mode and
; PROCESS command can enter into following codes

	SNDBYT	(ACTPRT,\B.ACOM,CCSACT,I)	; change salesman for all users
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        SNDBYT  (AC,\B.SLS,UASLS)
        PUSHJ   P,AGANS
	 JRST	CCSAE2
	MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CCUSA4
	TTFSTR	([ASCIZ/Change Customer Salesman/])
	PUSHJ	P,STDCHD              ; write standard header
	PUSHJ	P,RELTTF
 
CCUSA4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CCUSAD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CCUSAD
	JRST	CCSST2			; ABRV'ST2 is the menu output section

CCUSAD: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
CCSAE2: ; error during change salesman code
        TYPSTR  ([ASCIZ/Error during Change Customer Salesman Code./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    CCSAE3
 
CCSAE3: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    CCSST2
 
; end of code for change customer salesman code
 
GE1SYS:
   ;    PUSHJ   P,INASYS
        PUSHJ   P,INASY9              ; allow entering special ast for acct.
        TLNN    FLG2,V.EXC            ; skip if changing items
         POPJ   P,
        MOVEI   AC,LCTACT
        MOVEM   AC,FINARG             ; for using FINAST in GCAREC
        MOVE    AC,CUSNUM
        MOVEM   AC,FINAR2             ; for using the routine FINAST
        PUSHJ   P,FINAST              ; get ACTSY2
         JRST   [TYPSTR  ([ASCIZ/No acctg record for this customer./])
                 JRST    GE1SYS]
        SNDBYT  (ACTPRT,\B.ACOM,LCNACT,I)   ; get customer name from acct.
        SNDBYT  (ACTPRT,\B.CID,CUSNUM)      ; also check customer is valid 
        SNDBYT  (ACTPRT,\B.ASY,ACTSY2)      ; on this acctg. system type
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Customer number not in this system type./])
                 JRST    GE1SYS]
        GETSTR  (AC,L.CUSN,ACCNAM)    ; get customer name
        POPJ    P,
 
GETCSN: ; get customer number
        PUSHJ   P,GETCUS              ; get customer number 
         JRST   .-1                   ; if input c.r., prompt again
        PUSHJ   P,GETACC              ; build accounting circuit
         JRST   GETCMD
        TLNE    FLG2,V.LSQ            ; skip if not list command
         POPJ   P,
        MOVEI   AC,LCTACT
        MOVEM   AC,FINARG             ; for using FINAST in GCAREC
        MOVE    AC,CUSNUM
        MOVEM   AC,FINAR2             ; for using the routine FINAST
        PUSHJ   P,FINAST              ; get ACTSY2
         JRST   [TYPSTR  ([ASCIZ/No acctg record for this customer./])
                 JRST    GETCSN]
        TLNE    FLG,U.AP              ; if not acct. lic. then skip
         JRST   GECSN2                ; if acct. lic then don't check access
        PUSHJ   P,CHKCUS              ; check access, note : need ACTSY2
         JRST   GETCSN                ; access denied, prompt cusnum again
GECSN2: PUSHJ   P,GCAREK              ; get accounting record
         SKIPA
        POPJ    P,
        TYPSTR  ([ASCIZ/Customer not valid in this system type./])
        JRST    GETCSN
 
CSNOU1: ; output customer number along with name
        TYPSTR  ([ASCIZ/Cid :/],777,0,T.P0,N)
        TYPNUM  (CUSNUM,D,0,T.P2,N)
        TYPSTR  ([ASCIZ/ - /],777,0,0,N)
        TLNN    FLG2,V.LSQ                  ; skip if it is type command
         JRST   CSNOU2
        MOVEI   AC,LCTACT
        MOVEM   AC,FINARG
        MOVE    AC,CUSNUM
        MOVEM   AC,FINAR2
        PUSHJ   P,FINAST
         JRST   CSNOU1
        SNDBYT  (ACTPRT,\B.ACOM,LCNACT,I)   ; get customer name from acct.
        SNDBYT  (ACTPRT,\B.CID,CUSNUM)      
        SNDBYT  (ACTPRT,\B.ASY,ACTSY2)
        PUSHJ   P,AGANS
         JRST   CSNOU1
        GETSTR  (AC,L.CUSN,ACCNAM)          ; get customer name
CSNOU2: TYPSTR  (ACCNAM,777,1)
        POPJ    P,
 
RWCSN:  ; write customer number
        REQNOT  (REQ,CUSNUM,D)
        POPJ    P,
 
CMDCCD: ; change customer district
	TCR	(1)
        TRO     FLG2,V.NIR

DEFINE CCUD <
        X       (SYSOUT,GE2SYS,RWSYS)
	X	(CSNOU1,GETCSN,RWCSN)              
	X	(DISTOU,GEDIST,RWDIST)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR)  ; if not immediate or req
>
	EXMMAC (CCD,CCUD,^D21,CUSRQQ)

        TRNE    FLG,U.RFI             ; if input not from terminal then skip
         JRST   PCSDI0
        TYPSTR  ([ASCIZ/Error - Input must be from request file./])
        POPJ    P,
; code for change customer district starts here, only PROCESS CHANGE
; DISTRICT command can enter into following codes

PCSDI0: SETZM   NUM2
        TRZ     FLG,U.RFI             ; for accept input from terminal
        GETYR   ([ASCIZ/Restart ? /])
         JRST   PCSDIS
GELSNM: INNUM   ([ASCIZ/Number of records last updated: /],D)
         JRST   [PUSHJ  P,INORNO
                 JRST   GELSNM]
        MOVEM   AC1,NUM2
        MOVE    AC,ACTSY2             ; load acctg. system type
        CAIN    AC,^D9                ; skip if not tymnet
         JRST   CNETDI
        JRST    PCSDI1
; first change customer's district in accounting only
PCSDIS: SNDBYT  (ACTPRT,\B.ACOM,CCDACT,I)       
	SNDBYT	(AC,\B.CID,CUSNUM)              
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        SNDBYT  (AC,\B.DIS,DISRCT)
        PUSHJ   P,AGANS
	 JRST	CCDIE2
        MOVE    AC,ACTSY2             ; load acctg. system type
        CAIN    AC,^D9                ; skip if not tymnet
         JRST   CNETDI
PCSDI1: PUSHJ   P,GCHREC              ; get and save customer hosts
         JRST   CCDIE2
; second for each host, change district for all users under same cid
CUDIST:
        INNUM   ([ASCIZ/Host :/],D)   ; from terminal
         JRST   [PUSHJ   P,INORNO
                 JRST    CUDIST]
        JUMPE   AC1,CUDISD            ; if carriage return then done
        MOVEM   AC1,LUDNUM
        CAIN    AC1,^D9999            
         JRST   CUDISH                ; 9999 means done partially
        SETZM   UAHSTC
CUDIS1: MOVE    AC1,UAHSTC
        CAML    AC1,UAHSTP
         JRST   [TYPSTR  ([ASCIZ/Invalid host for this customer./])
                 JRST    CUDIST]
        MOVE    AC1,UAHST(AC1)        ; get a host number from table
        CAMN    AC1,LUDNUM
         JRST   .+2                   ; found, start execution
        JRST    CULOPD
        SETZM   NUM1                  ; set counter to zero
        PUSHJ   P,GETOLD              ; get lud circuit and OLDASY
         JRST   GETCMD
        SNDBYT  (ACTPRT,\B.ACOM,CD2ACT,I)    ; change users' district in acct.
        SNDBYT  (ACTPRT,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ASY,OLDASY)
        SNDBYT  (AC,\B.DIS,DISRCT)
        SNDBYT  (AC,\B.HST,LUDNUM)
        PUSHJ   P,AGANS
         JRST   CCDIE2
CURLOP: GETSTR  (ACTPRT,L.UNM,UNMSPC) ; get username
        CAIN    AC1,377               ; skip if not end
         JRST   CUDIST                ; get next host number from terminal
        PUSHJ   P,AGANS
         JRST   CCDIE2
        AOS     NUM1                  ; increment NUM1
        MOVE    AC,NUM1
        CAMGE   AC,NUM2
         JRST   CURLOP
        TYPNUM  (NUM1,D,0,0,N)
        TYPSTR  ([ASCIZ/ - /],777,0,0,N)
        TYPSTR  (UNMSPC,L.UNM,1,0)
; third, change this user's district in mud and lud
        PUSHJ   P,CDISMD              ; change user's district in mud
         JRST   CURLOP
        PUSHJ   P,CDISLD              ; change user's district in lud
         JRST   CURLOP
        JRST    CURLOP                ; back to loop
CULOPD: AOS     UAHSTC                ; increment count
        JRST    CUDIS1                ; back to main loop
CNETDI: ; change tymnet customer district
        SETZM   NUM1                  ; set counter to zero
        SNDBYT  (ACTPRT,\B.ACOM,CTDACT,I)    ; change users' district in acct.
        SNDBYT  (ACTPRT,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ASY,ACTSY2)
        SNDBYT  (AC,\B.DIS,DISRCT)
        PUSHJ   P,AGANS
         JRST   CCDIE2
CNELOP: GETSTR  (ACTPRT,L.UNM,UNMSPC) ; get username
        CAIN    AC1,377               ; skip if not end
         JRST   CUDISD                ; done
        PUSHJ   P,AGANS
         JRST   CCDIE2
        AOS     NUM1                  ; increment NUM1
        MOVE    AC,NUM1
        CAMGE   AC,NUM2
         JRST   CNELOP
        TYPNUM  (NUM1,D,0,0,N)
        TYPSTR  ([ASCIZ/ - /],777,0,0,N)
        TYPSTR  (UNMSPC,L.UNM,1,0)
; change user's district in mud
        PUSHJ   P,CDISMD              ; change user's district in mud
         JRST   CNELOP
        JRST    CNELOP                ; back to loop
 
CUDISD: TYPSTR  ([ASCIZ/Entry Completed./])
        TRO     FLG,U.RFI             ; turn off U.RFI
; tattle
	GETT	(/CHG/)
	 JRST	CCUDI4
	TTFSTR	([ASCIZ/Change Customer District/])
	PUSHJ	P,STDCHD                ; write standard header
	PUSHJ	P,RELTTF
 
CCUDI4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CCUDID			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CCUDID
	JRST	CCDST2			; ABRV'ST2 is the menu output section

CCUDID: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
CUDISH: ; partially done, don't turn on okay switch
        TRO     FLG,U.RFI
        POPJ    P,
 
CCDIE2: ; error during change district
        TYPSTR  ([ASCIZ/Error during Change Customer District./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    CCDIE3
 
CCDIE3: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    CCDST2
 
; end of code for change customer district
 
CDISMD: ; change user district in mud
        PUSHJ   P,GETCUD              ; get circuit to cud
         JRST   GETCMD
        SNDBYT  (CUDPRT,\B.CCOM,CDIMUD,I)
        PUSHJ   P,SNMCUD                     ; send username
        SNDBYT  (CUDPRT,\B.CDST,DISRCT)       ; note send 2 bytes!
        PUSHJ   P,SND40
        PUSHJ   P,NGANS               ; get a byte from cud
         JRST   [TYPSTR  ([ASCIZ/Error in changing district in cud/])
                 TYPSTR  ([ASCIZ/Username/],777,0,0,N)
                 TYPSTR  (UNMSPC,L.UNM,1,0)
                 PUSHJ   P,ERRCUD
                 POPJ    P,]
        PUSHJ   P,GET40
        AOS     0(P)
        POPJ    P,
 
CDISLD: ; change user district in lud
        MOVE    AC,OLDASY
        CAIN    AC,A370               ; skip if not 370
         JRST   CDI370
        CAIN    AC,A940               ; skip if not 940
         JRST   CDI940
 
        ; change user's district in pdp10 lud
 
        SNDBYT  (OLDPRT,\B.LCOM,CDILUD,I)
        SNDSTR  (AC,L.UNM,UNMSPC)
        SNDBYT  (AC,\B.DIS,DISRCT)
        JRST    CDIDNE
 
CDI370: ; change user's district in 370 lud
        SNDBYT  (OLDPRT,\B.LCOM,CDILUD,I)
        SNDSTR  (AC,L.UNM3,UNMSPC)
        SNDBYT  (AC,\B.DIS,DISRCT)
        JRST    CDIDNE
 
CDI940: ; change user's district in 940 lud
        SNDBYT  (OLDPRT,\B.LCOM,CDILUD,I)
        SNDBYT  (AC,\B.940W,0,I)
        SNDSTR  (AC,L.UNM,UNMSPC)
        SNDBYT  (AC,\B.DIS,DISRCT)
        SNDBYT  (AC,\B.940W,[44444444])
CDIDNE: PUSHJ   P,OLDA
         JRST   [TYPSTR  ([ASCIZ/Error in changing district in lud/])
                 TYPSTR  ([ASCIZ/Username/],777,0,0,N)
                 TYPSTR  (UNMSPC,L.UNM,1,0)
                 MOVE    AC1,OLDANS
                 PUSHJ   P,LUDAOT
                 POPJ    P,]
        AOS     0(P)
        POPJ    P,
 
GE2SYS:
        PUSHJ   P,INACSY              ; prompt for acctg. system type including
                                      ; type 9 for Tymnet
        TLNN    FLG2,V.EXC            ; skip if changing items
         POPJ   P,
        MOVEI   AC,LCTACT
        MOVEM   AC,FINARG             ; for using FINAST in GCAREC
        MOVE    AC,CUSNUM
        MOVEM   AC,FINAR2             ; for using the routine FINAST
        PUSHJ   P,FINAST              ; get ACTSY2
         JRST   [TYPSTR  ([ASCIZ/No acctg record for this customer./])
                 JRST    GE2SYS]
        SNDBYT  (ACTPRT,\B.ACOM,LCNACT,I)   ; get customer name from acct.
        SNDBYT  (ACTPRT,\B.CID,CUSNUM)      ; also check customer is valid 
        SNDBYT  (ACTPRT,\B.ASY,ACTSY2)      ; on this acctg. system type
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Customer not valid in this system type./])
                 JRST    GE2SYS]
        GETSTR  (AC,L.CUSN,ACCNAM)    ; get customer name
        POPJ    P,
 
DISTOU:
        MOVE    AC,DISRCT
        PUSHJ   P,DISOUT
        POPJ    P,
 
GEDIST:
        INNUM   ([ASCIZ/Dist :/],D)
         JRST   [PUSHJ  P,INORNO
                 JRST   GEDIST]
        MOVEM   AC1,DISRCT
        POPJ    P,
 
RWDIST:
        REQNOT  (REQ,DISRCT,D)
        POPJ    P,
CMDCCN: ; change customer name
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CCUN <
        X       (SYSOUT,GE1SYS,RWSYS)
	X	(CSNOU1,GETCSN,RWCSN)              
	X	(CNAOUT,GETCNA,RWCNA)     
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CCN,CCUN,^D22,CUSRQQ)

; code for change customer name starts here, only immediate mode and
; PROCESS command can enter into following codes

	SNDBYT	(ACTPRT,\B.ACOM,CCNACT,I)	; change customer name
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        SNDSTR  (AC,L.CUSN,NCNMSP)
        PUSHJ   P,AGANS
	 JRST	CCNAE2
	MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CCUNA4
	TTFSTR	([ASCIZ/Change Customer Name/])
	PUSHJ	P,STDCHD              ; write standard header
	PUSHJ	P,RELTTF
 
CCUNA4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CCUNAD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CCUNAD
	JRST	CCNST2			; ABRV'ST2 is the menu output section

CCUNAD: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
CCNAE2: ; error during change customer name
        TYPSTR  ([ASCIZ/Error during Change Customer Name./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    CCNAE3
 
CCNAE3: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    CCNST2
 
; end of code for change customer name
 
CNAOUT:
        TYPSTR  ([ASCIZ/New Name :/],777,0,T.P0,N)
        TYPSTR  (NCNMSP,L.CUSN,0,T.P2)
        POPJ    P,
 
GETCNA:
        INSTR   ([ASCIZ/New Name :/],NCNMSP,L.CUSN)
        MOVEI   AC1,L.CUSN
        MOVEI   AC,NCNMSP
        PUSHJ   P,CNTCHR
        SKIPN   AC1                   ; skip if not blank
         JRST   [PUSHJ  P,INORNO
                 JRST   GETCNA]
        POPJ    P,
 
RWCNA:
        REQOUT  (REQ,NCNMSP,L.CUSN)
        POPJ    P,
 
CMDCCI: ; change customer industry code
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CCUI <
        X       (CSNOU3,GE1CSN,RWCSN)
	X	(CINOUT,GETCIN,RWCIN)     
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CCI,CCUI,^D23,CUSRQQ)

; code for change customer industry code starts here, only immediate mode and
; PROCESS command can enter into following codes

        PUSHJ   P,GETCUD
         JRST   GETCMD
	SNDBYT	(CUDPRT,\B.CCOM,CCIMUD,I)	; change customer industry code
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.IND,NMSIC)
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
	 JRST	CCINE2
        GETBYT  (CUDPRT,2)            ; get 2 bytes 
         JRST   GETCMD
        PUSHJ   P,GET40
        TYPSTR  ([ASCIZ/Entry Complete./])
 
; tattle
	GETT	(/CHG/)
	 JRST	CCUIN4
	TTFSTR	([ASCIZ/Change Customer Industry Code/])
	PUSHJ	P,STDCHD              ; write standard header
	PUSHJ	P,RELTTF
 
CCUIN4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CCUIND			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CCUIND
	JRST	CCIST2			; ABRV'ST2 is the menu output section

CCUIND: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
CCINE2: ; error during change customer industry code
        TYPSTR  ([ASCIZ/Error during Change Customer Industry Code./])
        PUSHJ   P,ERRCUD
 
CCINE3: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    CCIST2
 
; end of code for change customer industry code
 
GE1CSN: ; get customer number, set ACTSYS = 0 then use FINAST to get default
        ; ACTSY2 for the checking in GETCSN
        SETZM   ACTSYS
        PUSHJ   P,GETCSN
        POPJ    P,
 
CSNOU3:
        SETZM   ACTSYS
        PUSHJ   P,CSNOU1
        POPJ    P,
  
CINOUT:
        TYPSTR  ([ASCIZ/Ind. Code :/],777,0,T.P0,N)
        TYPNUM  (NMSIC,D,0,T.P2)
        POPJ    P,
 
GETCIN:
        INNUM   ([ASCIZ/Ind. Code :/],D)
         JRST   GETCI2
        MOVEM   AC1,NMSIC
        POPJ    P,
GETCI2: PUSHJ   P,INORNO
        JRST    GETCIN
 
RWCIN:
        REQNOT  (REQ,NMSIC,D)
        POPJ    P,
CMDCCA: ; change customer address
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CCUA <
        X       (SYSOUT,GE1SYS,RWSYS)
	X	(CSNOU1,GETCSN,RWCSN)              
	X	(AD1OUT,GETAD1,RWAD1)     
	X	(AD2OUT,GETAD2,RWAD2)     
	X	(CTYOUT,GETCTY,RWCTY)     
	X	(STAOUT,GETSTA,RWSTA)     
	X	(ZIPOUT,GETZIP,RWZIP)     
	X	(CTROUT,GETCTR,RWCTR)     
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CCA,CCUA,^D24,CUSRQQ)

; code for change customer address starts here, only immediate mode and
; PROCESS command can enter into following codes
; note: in this command, we don't ask for extra line of street, even if we 
; have to send it (with garbage)

        SNDBYT  (ACTPRT,\B.ACOM,LATACT,I)       ; list customer attention
        SNDBYT  (AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        PUSHJ   P,AGANS
         JRST   GCAREE
        GETSTR  (ACTPRT,L.ATTN,ACATTN)          ; get attention line
	SNDBYT	(ACTPRT,\B.ACOM,CCAACT,I)	; change customer address
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        SNDSTR  (AC,L.STRE,ACSTR1)
        SNDSTR  (AC,L.STRE,ACSTR2)
        SNDSTR  (AC,L.STRE,ACEXLN)
        SNDSTR  (AC,L.CITY,ACCITY)
        SNDSTR  (AC,L.STAT,ACSTAT)
        SNDSTR  (AC,L.ZIP,ACZIP)
        SNDSTR  (AC,L.CTRY,ACCTRY)
        SNDSTR  (AC,L.ATTN,ACATTN)
        PUSHJ   P,AGANS
	 JRST	CCADE2
	MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CCUAD4
	TTFSTR	([ASCIZ/Change Customer Address/])
	PUSHJ	P,STDCHD              ; write standard header
	PUSHJ	P,RELTTF
 
CCUAD4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CCUADD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CCUADD
	JRST	CCAST2			; ABRV'ST2 is the menu output section

CCUADD: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
CCADE2: ; error during change customer name
        TYPSTR  ([ASCIZ/Error during Change Customer Address./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    CCADE3
 
CCADE3: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    CCAST2
 
; end of code for change customer address
    
AD1OUT: 
        TYPSTR  ([ASCIZ/Street (1st) :/],777,0,T.P0,N)
        TYPSTR  (ACSTR1,L.STRE,0,T.P2)
        POPJ    P,
 
GETAD1:  
        TRNE    FLG,U.RFI             ; skip if input not from request file
         JRST   GE2AD1
        TYPSTR  ([ASCIZ/Mailing Info :/])
GE2AD1: INSTR   ([ASCIZ/Street (1st) :/],ACSTR1,L.STRE)
        POPJ    P,
 
RWAD1:
        REQOUT  (REQ,ACSTR1,L.STRE)
        POPJ    P,
    
AD2OUT: 
        TYPSTR  ([ASCIZ/Street (2nd) :/],777,0,T.P0,N)
        TYPSTR  (ACSTR2,L.STRE,0,T.P2)
        POPJ    P,
 
GETAD2:  
        INSTR   ([ASCIZ/Street (2nd) :/],ACSTR2,L.STRE)
        POPJ    P,
 
RWAD2:
        REQOUT  (REQ,ACSTR2,L.STRE)
        POPJ    P,
    
CTYOUT: 
        TYPSTR  ([ASCIZ/City :/],777,0,T.P0,N)
        TYPSTR  (ACCITY,L.CITY,0,T.P2)
        POPJ    P,
 
GETCTY:  
        INSTR   ([ASCIZ/City :/],ACCITY,L.CITY)
        POPJ    P,
 
RWCTY:
        REQOUT  (REQ,ACCITY,L.CITY)
        POPJ    P,
    
STAOUT: 
        TYPSTR  ([ASCIZ/State :/],777,0,T.P0,N)
        TYPSTR  (ACSTAT,L.STAT,0,T.P2)
        POPJ    P,
 
GETSTA:  
        INSTR   ([ASCIZ/State :/],ACSTAT,L.STAT)
        POPJ    P,
 
RWSTA:
        REQOUT  (REQ,ACSTAT,L.STAT)
        POPJ    P,
    
ZIPOUT: 
        TYPSTR  ([ASCIZ/Zip :/],777,0,T.P0,N)
        TYPSTR  (ACZIP,L.ZIP,0,T.P2)
        POPJ    P,
 
GETZIP:  
        INSTR   ([ASCIZ/Zip :/],ACZIP,L.ZIP)
        POPJ    P,
 
RWZIP:
        REQOUT  (REQ,ACZIP,L.ZIP)
        POPJ    P,
    
CTROUT: 
        TYPSTR  ([ASCIZ/Country :/],777,0,T.P0,N)
        TYPSTR  (ACCTRY,L.CTRY,0,T.P2)
        POPJ    P,
 
GETCTR:  
        INSTR   ([ASCIZ/Country :/],ACCTRY,L.CTRY)
        MOVE    AC,ACCTRY
        CAMN    AC,[ASCII/     /]
         JRST   GETCTR
        POPJ    P,
 
RWCTR:
        REQOUT  (REQ,ACCTRY,L.CTRY)
        POPJ    P,
CMDCDE: ; change customer detail
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CCDE <
        X       (SYSOUT,GE1SYS,RWSYS)
	X	(CSNOU1,GETCSN,RWCSN)              
	X	(DETOUT,GETDET,RWDET)     
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CDE,CCDE,^D25,CUSRQQ)

; code for change customer detail starts here, only immediate mode and
; PROCESS command can enter into following codes

	SNDBYT	(ACTPRT,\B.ACOM,CDTACT,I)	; change customer detail
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        SNDBYT  (AC,\B.DET,ACDETC)
        PUSHJ   P,AGANS
	 JRST	CCDEE2
	MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CCUDE4
	TTFSTR	([ASCIZ/Change Customer Detail/])
	PUSHJ	P,STDCHD              ; write standard header
	PUSHJ	P,RELTTF
 
CCUDE4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CCUDED			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CCUDED
	JRST	CCDST2			; ABRV'ST2 is the menu output section

CCUDED: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
CCDEE2: ; error during change customer detail
        TYPSTR  ([ASCIZ/Error during Change Customer Detail./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    CCDEE3
 
CCDEE3: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    CCDST2
 
; end of code for change customer detail

GETDET: ; get detail and convert to code
        SETZ     AC1,
        MOVEM    AC1,ACDETC
        GETYR    ([ASCIZ/Minimum Session Charge? /])
         JRST    .+4
        MOVEI    AC1,^D8
        MOVEM    AC1,ACDETC
        POPJ     P,
        GETYR    ([ASCIZ/Full Detail; GMT? /])
         JRST    .+4
        MOVEI    AC1,2
        MOVEM    AC1,ACDETC
        POPJ     P,
  ;     GETYR    ([ASCIZ/Full Detail; PST? /])
  ;      JRST    .+4
  ;     MOVEI    AC1,3
  ;     MOVEM    AC1,ACDETC
  ;     POPJ     P,
        GETYR    ([ASCIZ/Summary? /])
         JRST    .+4
        MOVEI    AC1,4
        MOVEM    AC1,ACDETC
        POPJ     P,
        GETYR    ([ASCIZ/Internal Summary? /])
         JRST    .+4
        MOVEI    AC1,5
        MOVEM    AC1,ACDETC
        POPJ     P,
        GETYR    ([ASCIZ/No Detail? /])
         JRST    .+4
        MOVEI    AC1,6
        MOVEM    AC1,ACDETC
        POPJ     P,
        JRST     GETDET
        
RWDET:  ; write to request file
        MOVE     AC1,ACDETC
        CAIE     AC1,^D8
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
        MOVE     AC1,ACDETC
        CAIE     AC1,2
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
  ;     MOVE     AC1,ACDETC
  ;     CAIE     AC1,3
  ;      PUSHJ   P,WRNO
  ;     JRST     [PUSHJ   P,WRYES
  ;               POPJ    P,]
        MOVE     AC1,ACDETC
        CAIE     AC1,4
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
        MOVE     AC1,ACDETC
        CAIE     AC1,5
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
        MOVE     AC1,ACDETC
        CAIE     AC1,6
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
 
 
CMDCPO: ; change customer purchase order
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CCUP <
        X       (SYSOUT,GE1SYS,RWSYS)
	X	(CSNOU1,GETCSN,RWCSN)              
	X	(POOUT,GETPO,RWPO)     
	X	(POSOUT,GETPOS,RWPOS)     
	X	(POEOUT,GETPOE,RWPOE)     
	X	(POMOUT,GETPOM,RWPOM)     
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CPO,CCUP,^D26,CUSRQQ)

; code for change customer purchase order starts here, only immediate mode and
; PROCESS command can enter into following codes

	SNDBYT	(ACTPRT,\B.ACOM,CPOACT,I)	; change customer po
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        SNDSTR  (AC,L.PO,ACPONM)
        PUSHJ   P,AGANS
	 JRST	CCPOE2
	SNDBYT	(ACTPRT,\B.ACOM,CPMACT,I)	; change customer po maximum
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        SNDBYT  (AC,\B.POMX,ACPOMX)
        PUSHJ   P,AGANS
	 JRST	CCPOE2
	SNDBYT	(ACTPRT,\B.ACOM,CPSACT,I)	; change customer po start date
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        SNDBYT  (AC,\B.PODT,ACPSDT)
        PUSHJ   P,AGANS
	 JRST	CCPOE2
	SNDBYT	(ACTPRT,\B.ACOM,CSTACT,I)	; change customer po stop date
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        SNDBYT  (AC,\B.PODT,ACPEDT)
        PUSHJ   P,AGANS
	 JRST	CCPOE2
	MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CCUPO4
	TTFSTR	([ASCIZ/Change Customer PO/])
	PUSHJ	P,STDCHD              ; write standard header
	PUSHJ	P,RELTTF
 
CCUPO4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CCUPOD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CCUPOD
	JRST	CPOST2			; ABRV'ST2 is the menu output section

CCUPOD: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
CCPOE2: ; error during change customer po
        TYPSTR  ([ASCIZ/Error during Change Customer PO./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    CCPOE3
 
CCPOE3: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    CPOST2
 
; end of code for change customer po
 
POSOUT:
        TYPSTR  ([ASCIZ/P.O. Start Date (yymmdd) :/],777,0,T.P0,N)
        TYPNUM  (ACPSDT,D,0,T.P2)
        POPJ    P,
 
POEOUT:
        TYPSTR  ([ASCIZ/P.O. Stop  Date (yymmdd) :/],777,0,T.P0,N)
        MOVE    AC,ACPEDT
        CAIN    AC,0
         JRST   POEOU2
        TYPNUM  (ACPEDT,D,0,T.P2)
        POPJ    P,
POEOU2: TYPSTR  ([ASCIZ/991231/],777,0,T.P2)
        POPJ    P,
 
GETPO:
        INSTR   ([ASCIZ/P.O. No. :/],ACPONM,L.PO)
        POPJ    P,
 
GETPOS:
        INNUM   ([ASCIZ/P.O. Start Date (yymmdd) :/],D)
         JRST   GETPS3
        CAIN    AC1,0
         JRST   [PUSHJ   P,GTODAY     ; get today's date, GTODAY in tat.mac
                 MOVEM   AC,ACPSDT
                 POPJ    P,]
        MOVEM   AC1,ACPSDT
        POPJ    P,
GETPS3:
        PUSHJ   P,INORNO
        JRST    GETPOS
 
GETPOE:
        INNUM   ([ASCIZ/P.O. Stop  Date (yymmdd) :/],D)
         JRST   GETP3E
        MOVEM   AC1,ACPEDT
        POPJ    P,
GETP3E:
        PUSHJ   P,INORNO
        JRST    GETPOE
      
GETPOM:
        INNUM   ([ASCIZ/P.O. Limit :/],D)
         JRST   GETPM2
        MOVEM   AC1,ACPOMX
        POPJ    P,
GETPM2:
        PUSHJ   P,INORNO
        JRST    GETPOM
 
RWPO:
        REQOUT  (REQ,ACPONM,L.PO)
        POPJ    P,
 
RWPOS:
        REQNOT  (REQ,ACPSDT,D)
        POPJ    P,
 
RWPOE:
        REQNOT  (REQ,ACPEDT,D)
        POPJ    P,
 
RWPOM:
        REQNOT  (REQ,ACPOMX,D)
        POPJ    P,
CMDCIV: ; change customer invoice
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CCIV <
        X       (SYSOUT,GE1SYS,RWSYS)
	X	(CSNOU1,GETCSN,RWCSN)              
	X	(INVOU1,GETINV,RWINV)     
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CIV,CCIV,^D27,CUSRQQ)

; code for change customer invoice starts here, only immediate mode and
; PROCESS command can enter into following codes

	SNDBYT	(ACTPRT,\B.ACOM,CIVACT,I)	; change customer invoice
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        SNDBYT  (AC,\B.INV,NUM7)
        PUSHJ   P,AGANS
	 JRST	CCIVE2
	MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CCUIV4
	TTFSTR	([ASCIZ/Change Customer Invoice/])
	PUSHJ	P,STDCHD              ; write standard header
	PUSHJ	P,RELTTF
 
CCUIV4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CCUIVD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CCUIVD
	JRST	CIVST2			; ABRV'ST2 is the menu output section

CCUIVD: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
CCIVE2: ; error during change customer invoice
        TYPSTR  ([ASCIZ/Error during Change Customer Invoice./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    CCIVE3
 
CCIVE3: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    CIVST2
 
; end of code for change customer invoice
 
INVOU1:
        MOVE    AC1,NUM7
        MOVEM   AC1,ACINVC
        PUSHJ   P,INVOUT
        POPJ    P,
 
GETINV: ; get invoice and convert to code
        SETZ     AC1,
        MOVEM    AC1,NUM7
        GETYR    ([ASCIZ/Standard? /])
         JRST    .+4
        MOVEI    AC1,1
        MOVEM    AC1,NUM7
        POPJ     P,
        GETYR    ([ASCIZ/Non-standard Special Handling? /])
         JRST    .+4
        MOVEI    AC1,2
        MOVEM    AC1,NUM7
        POPJ     P,
        GETYR    ([ASCIZ/Internal? /])
         JRST    .+4
        MOVEI    AC1,3
        MOVEM    AC1,NUM7
        POPJ     P,
        GETYR    ([ASCIZ/Non-standard Manual? /])
         JRST    .+4
        MOVEI    AC1,4
        MOVEM    AC1,NUM7
        POPJ     P,
        JRST     GETINV
        
RWINV:  ; write to request file
        MOVE     AC1,NUM7
        CAIE     AC1,1
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
        MOVE     AC1,NUM7
        CAIE     AC1,2
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
        MOVE     AC1,NUM7
        CAIE     AC1,3
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
        MOVE     AC1,NUM7
        CAIE     AC1,4
         PUSHJ   P,WRNO
        JRST     [PUSHJ   P,WRYES
                  POPJ    P,]
        POPJ     P,
CMDCAT: ; change customer attention
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CCAT <
        X       (SYSOUT,GE1SYS,RWSYS)
	X	(CSNOU1,GETCSN,RWCSN)              
	X	(ATTOUT,GETATN,RWATN)     
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CAT,CCAT,^D28,CUSRQQ)

; code for change customer attention starts here, only immediate mode and
; PROCESS command can enter into following codes

	SNDBYT	(ACTPRT,\B.ACOM,LADACT,I)	; get street
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        PUSHJ   P,AGANS
         JRST   GCAREE
        GETSTR  (ACTPRT,L.STRE,ACSTR1)
        GETSTR  (ACTPRT,L.STRE,ACSTR2)
        GETSTR  (ACTPRT,L.STRE,ACEXLN)
	SNDBYT	(ACTPRT,\B.ACOM,LCIACT,I)	; get city
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        PUSHJ   P,AGANS
         JRST   GCAREE
        GETSTR  (ACTPRT,L.CITY,ACCITY)
	SNDBYT	(ACTPRT,\B.ACOM,LCSACT,I)	; get state
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        PUSHJ   P,AGANS
         JRST   GCAREE
        GETSTR  (ACTPRT,L.STAT,ACSTAT)
	SNDBYT	(ACTPRT,\B.ACOM,LZIACT,I)	; get zip
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        PUSHJ   P,AGANS
         JRST   GCAREE
        GETSTR  (ACTPRT,L.ZIP,ACZIP)
	SNDBYT	(ACTPRT,\B.ACOM,LCCACT,I)	; get country
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        PUSHJ   P,AGANS
         JRST   GCAREE
        GETSTR  (ACTPRT,L.CTRY,ACCTRY)
	SNDBYT	(ACTPRT,\B.ACOM,CCAACT,I)	; change customer attention
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        SNDSTR  (AC,L.STRE,ACSTR1)
        SNDSTR  (AC,L.STRE,ACSTR2)
        SNDSTR  (AC,L.STRE,ACEXLN)
        SNDSTR  (AC,L.CITY,ACCITY)
        SNDSTR  (AC,L.STAT,ACSTAT)
        SNDSTR  (AC,L.ZIP,ACZIP)
        SNDSTR  (AC,L.CTRY,ACCTRY)
        SNDSTR  (AC,L.ATTN,ACCATT)
        PUSHJ   P,AGANS
	 JRST	CCATE2
	MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CCUAT4
	TTFSTR	([ASCIZ/Change Customer Attention/])
	PUSHJ	P,STDCHD              ; write standard header
	PUSHJ	P,RELTTF
 
CCUAT4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CCUATD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CCUATD
	JRST	CATST2			; ABRV'ST2 is the menu output section

CCUATD: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
CCATE2: ; error during change customer attention
        TYPSTR  ([ASCIZ/Error during Change Customer Attention./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    CCATE3
 
CCATE3: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    CATST2
 
; end of code for change customer attention
 
ATTOUT:
        TYPSTR  ([ASCIZ/Attn :/],777,0,T.P0,N)
        TYPSTR  (ACCATT,L.ATTN,0,T.P2)
        POPJ    P,
 
GETATN:  
        INSTR   ([ASCIZ/Attn :/],ACCATT,L.ATTN)
        POPJ    P,
 
RWATN:
        REQOUT  (REQ,ACCATT,L.ATTN)
        POPJ    P,
CMDCCF: ; change customer focus flat fee flag
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CCFO <
	X	(CSNOU4,GE2CSN,RWCSN)              
	X	(FOCOUT,GETFFF,RWFOC)     
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CCF,CCFO,^D29,CUSRQQ)

; code for change customer focus flat fee starts here, only immediate mode and
; PROCESS command can enter into following codes

	SNDBYT	(ACTPRT,\B.ACOM,CCFACT,I)	; chg. customer focus fee flag
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        SNDBYT  (AC,\B.FOCF,ACFOCF)
        PUSHJ   P,AGANS
	 JRST	CCFOE2
	MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CCUFO4
	TTFSTR	([ASCIZ/Change Customer Focus Fee Flag/])
	PUSHJ	P,STDCHD              ; write standard header
	PUSHJ	P,RELTTF
 
CCUFO4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CCUFOD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CCUFOD
	JRST	CCFST2			; ABRV'ST2 is the menu output section

CCUFOD: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
CCFOE2: ; error during change customer focus flat fee flag
        TYPSTR  ([ASCIZ/Error during Change Customer Focus Fee Flag./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    CCFOE3
 
CCFOE3: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    CCFST2
 
; end of code for change customer focus flat fee flag
 
GE2CSN:
        MOVEI   AC,A370
        MOVEM   AC,ACTSYS             ; system type always 370
        PUSHJ   P,GETCSN
        POPJ    P,
 
CSNOU4:
        MOVEI   AC,3
        MOVEM   AC,ACTSYS
        PUSHJ   P,CSNOU1
        POPJ    P,
 
GETFFF: GETYR   ([ASCIZ/Turn on Focus Flat Fee Arrangement ?/])
         JRST   FOCOFF
        MOVEI   AC1,1
        MOVEM   AC1,ACFOCF
        POPJ    P,
 
CMDCMC: ; change mdisk cylinders
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CMCM <
	X	(HST1OT,GETH37,RWH37)
	X	(NAMOUP,GETUSR,RWUSR)
	X	(MDIOUT,GETMDI,RWMDI)
	X	(CYLOUT,GETCYL,RWCYL)
	X	(GRPOUT,GETGRP,RWGRP,AC,-1,U.PRV) ; only priv may chg packgrp
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CMC,CMCM,1,USRRQQ)

; code for change mdisk cylinders starts here

	SKIPN	PCKG
	 JRST	CMCMC3
	SNDBYT	(OLDPRT,\B.LCOM,SPKLUD,I)
	SNDSTR	(AC,L.PKGP,PCKG)
	PUSHJ	P,OLDA
	 JRST	CMCMCE		; error
	JRST	CMCMC3
CMCMC1:	SNDBYT	(OLDPRT,\B.LCOM,SAPLUD,I)
	PUSHJ	P,OLDA
	 JRST	CMCMCE
CMCMC3:	; set pack done, try for actual change now
	SNDBYT	(OLDPRT,\B.LCOM,CCYLUD,I)	; change cyl
	SNDSTR	(AC,L.UNM3,UNMSPC)
; The 1point doc says send filesys of zero, for padding only, 1 byte
	SNDBYT	(AC,\B.FS,0,I)	; send a zero byte, required by 1point
	SNDSTR	(AC,B.MDI,MDISK)
	SNDBYT	(AC,\B.CYL,CYL)
	PUSHJ	P,OLDA
	 JRST	CCMCE2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CMCMC4
	TTFSTR	([ASCIZ/Change Mdisk Cylinders/])
	PUSHJ	P,STDUHD              ; write header for user type trans.
	PUSHJ	P,RELTTF
CMCMC4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CMCMCD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CMCMCD
	JRST	CMCST2			; ABRV'ST2 is the menu output section

CMCMCD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

CMCMCE:	; error during set pack
	TYPSTR	([ASCIZ/Error during Set Pack./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	CCMCE3

CCMCE2:	; error during change cyl
	TYPSTR	([ASCIZ/Error during Change Cylinders./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	CCMCE3

CCMCE3:	; after error, see if we can give him another chance
        MOVE    AC,SIXUNM
        CAMN    AC,[SIXBIT/VALADM/]   ; skip if not VALADM1 (army corp.)
         JRST   GETNON                ; for army corp., waste rest of input
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	CMCST2

; end of code for change mdisk cylinders
HST1OT:
	TYPSTR	([ASCIZ/Host :/],777,0,T.P0,N)
	TYPNUM	(HOST,D,0,T.P2)
	POPJ	P,
NAMOUP:
	MOVEI	AC,UNMSPC
	PUSHJ	P,NAMOUT
	POPJ	P,

MDIOUT:
	TYPSTR	([ASCIZ/Mdisk :/],777,0,T.P0,N)
	TYPSTR	(MDISK,B.MDI,0,T.P2)
	POPJ	P,

CYLOUT:
	TYPSTR	([ASCIZ/Cylinders :/],777,0,T.P0,N)
	TYPNUM	(CYL,D,0,T.P2)
	POPJ	P,

GRPOUT:
	TYPSTR	([ASCIZ/Pack Grp :/],777,0,T.P0,N)
	TYPSTR	(PCKG,L.PKGP,0,T.P2)
	POPJ	P,

SCMOUT:
	TYPSTR	([ASCIZ/Comment :/],777,0,T.P0,N)
	TYPSTR	(SCM,L.SCM,0,T.P2)
	POPJ	P,

GETH37:	; input 370 host number
	INNUM	([ASCIZ/Host :/],D)
	 JRST	[PUSHJ	P,INORNO
		 JRST	GETH37]
	JUMPE	AC1,.-1
	MOVEM	AC1,LUDNUM
	MOVEM	AC1,HOST
	TLNE	FLG2,V.LSQ		; skip if not a list command
	 POPJ	P,			; return, no check on list
	PUSHJ	P,GETOLD		; build circuit
	 JRST	GETCMD
	MOVE	AC,OLDASY
	CAIN	AC,A370
	 JRST	GTH372
	TYPSTR	([ASCIZ/Cmd only available on Tymcom-370/])
	PUSHJ	P,INORNO
	JRST	GETH37
GTH372:
	TLNN	FLG2,V.EXC	; skip if changing items
	 POPJ	P,		; if original input then GETUSR will check username.
	PUSHJ	P,CKUVAL	; check that username valid on this host
	 JRST	[PUSHJ	P,INORNO
		 JRST	GETH37]
	POPJ	P,

GETUSR:	; input the username
	PUSHJ	P,GETUNM
	 JRST	[PUSHJ	P,INORNO
		 JRST	GETUSR]
	TLNE	FLG2,V.LSQ	; skip this part if doing a list
	 POPJ	P,
	PUSHJ	P,GETCUD
	 JRST	GETCMD
	PUSHJ	P,GCREC
	 JRST	GETUR2
	PUSHJ	P,CHKUUN	; check access
	 JRST	GETUR2
GETUR1:
	PUSHJ	P,CKUVA1
         JRST   [TYPSTR  ([ASCIZ/Name not in Host./],777,0,0,Y)
                 JRST    GETUR2]
	POPJ	P,
GETUR2:	; here when username does not match
	TRNN	FLG,U.RFI	; skip if this is from  a request
         JRST   [PUSHJ  P,INORNO
		 JRST	GETUSR]
	PUSHJ	P,REQERR
	POPJ	P,

GETMDI:
	INSTR	([ASCIZ/Mdisk Addrs :/],MDISK,B.MDI)
	POPJ	P,

GETCYL:
	INNUM	([ASCIZ/Cylinders (3330) :/],D)
	 JRST	GETCY2
	JUMPE	AC1,GETCY2
	CAILE	AC1,MAX.CY
	 JRST	GETCY2
	MOVEM	AC1,CYL
	POPJ	P,
GETCY2:	PUSHJ	P,INORNO
	JRST	GETCYL

GETGRP:	; input pack group
	SETZM	PCKG
	TLNN	FLG,U.PRV	; skip if privileged
	 POPJ	P,
	INSTR	([ASCIZ/Pack or Group or (cr) :/],PCKG,L.PKGP,T)
	MOVE	AC,PCKG
	CAMN	AC,[ASCII/     /]
	 SETZM	PCKG
	POPJ	P,

GETSCM:	; get short 1 line comment
	TLNE	FLG2,V.EXQ!V.LSQ!V.PRQ	; skip if not request
	 JRST	GTSCM2
	TLNN	FLG,U.IMM		; skip if immediate
	 JRST	GTSCM2
	TRZ	FLG2,V.NIR
	POPJ	P,
GTSCM2:
	INSTR	([ASCIZ/Comment :/],SCM,L.SCM)
	POPJ	P,

CKUVAL:	; check if user is valid on this 370 host, currently not been used
	MOVE	AC,OLDHOS
	CAME	AC,HOST
	 JRST	CKUVL2		; if no circuit, skip return
	SNDBYT	(OLDPRT,\B.LCOM,KNALUD,I)
	SNDSTR	(AC,L.UNM3,UNMSPC)
	PUSHJ	P,OLDA
	 JRST	[TYPSTR	([ASCIZ/Username -/],777,0,0,N)
		 MOVE	AC1,OLDANS
		 PUSHJ	P,LUDAOT
		 POPJ	P,]
CKUVL2:	AOS	0(P)	; skip return
	POPJ	P,

RWH37:	; write host to request file
	REQNOT	(REQ,HOST,D)
	POPJ	P,

RWUSR:	; write username to request file
	REQOUT	(REQ,UNMSPC,L.UNM)
	POPJ	P,

RWMDI:	; write mdisk to request file
	REQOUT	(REQ,MDISK,B.MDI)
	POPJ	P,

RWCYL:	; write cylinders to request file
	REQNOT	(REQ,CYL,D)
	POPJ	P,

RWGRP:	; write pack group
	REQOUT	(REQ,PCKG,L.PKGP)
	POPJ	P,

RWSCM:	; write 1 line comment
	REQOUT	(REQ,SCM,L.SCM)
	POPJ	P,
 
 

CMDCMA: ; change mdisk address
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CMAM <
	X	(HST1OT,GETH37,RWH37)
	X	(NAMOUP,GETUSR,RWUSR)
	X	(OMDOUT,GETOMD,RWOMD)
	X	(NMDOUT,GETNMD,RWNMD)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CMA,CMAM,2,USRRQQ)

; code for change mdisk address starts here, only immediate mode and
; PROCESS command can enter into following codes

	SNDBYT	(OLDPRT,\B.LCOM,CDALUD,I)	; change address
	SNDSTR	(AC,L.UNM3,UNMSPC)
	SNDSTR	(AC,B.MDI,MDISK)
	SNDSTR	(AC,B.MDI,NMDSK)
	PUSHJ	P,OLDA
	 JRST	CCMAE2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CMAMC4
	TTFSTR	([ASCIZ/Change Mdisk Address/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
 
CMAMC4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CMAMCD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CMAMCD
	JRST	CMAST2			; ABRV'ST2 is the menu output section

CMAMCD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

CCMAE2:	; error during change address
	TYPSTR	([ASCIZ/Error during Change Mdisk Address./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	CCMAE3
 
CCMAE3:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	CMAST2

; end of code for change mdisk address
 
OMDOUT:
	TYPSTR	([ASCIZ/Current Mdisk Addrs :/],777,0,T.P0,N)
	TYPSTR	(MDISK,B.MDI,0,T.P2)
	POPJ	P,
 

NMDOUT:
	TYPSTR	([ASCIZ/New Mdisk Addrs :/],777,0,T.P0,N)
	TYPSTR	(NMDSK,B.MDI,0,T.P2)
	POPJ	P,

GETOMD:
	INSTR	([ASCIZ/Current Mdisk Addrs :/],MDISK,B.MDI)
	POPJ	P,


GETNMD:
	INSTR	([ASCIZ/New Mdisk Addrs :/],NMDSK,B.MDI)
	POPJ	P,
RWOMD:	; write old mdisk addrs to request file
	REQOUT	(REQ,MDISK,B.MDI)
	POPJ	P,

RWNMD:	; write new mdisk addrs to request file
	REQOUT	(REQ,NMDSK,B.MDI)
	POPJ	P,
 
 
 
CMDCMM: ; change mdisk mode
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CMMM <
	X	(HST1OT,GETH37,RWH37)
	X	(NAMOUP,GETUSR,RWUSR)
	X	(MDIOUT,GETMDI,RWMDI)
	X	(MODOUT,GETMOD,RWMOD)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CMM,CMMM,3,USRRQQ)

; code for change mdisk mode starts here, only immediate mode and PROCESS
; can enter
        SNDBYT  (OLDPRT,\B.LCOM,CDMLUD,I)       ; change mdisk mode
        SNDSTR  (AC,L.UNM3,UNMSPC)
	SNDSTR	(AC,B.MDI,MDISK)
	SNDBYT	(AC,\B.MOD,NMODE)
	PUSHJ	P,OLDA
	 JRST	CCMME2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CMMMC4
	TTFSTR	([ASCIZ/Change Mdisk Mode/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
CMMMC4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CMMMCD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CMMMCD
	JRST	CMMST2			; ABRV'ST2 is the menu output section

CMMMCD: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

CCMME2:	; error during change mode
	TYPSTR	([ASCIZ/Error during Change Mode./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	CCMME3

CCMME3:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	CMMST2

; end of code for change mdisk mode
 
MODOUT:
	TYPSTR	([ASCIZ/Mode :/],777,0,T.P0,N)
	TYPSTR	(MMODE,L.MOD,0,T.P2)
	POPJ	P,
 
; according to 1POINT, we have to convert mdisk mode to corresponding
; number before sending it out.

GETMOD:
	INSTR	([ASCIZ/Mode :/],MMODE,L.MOD)
        SETO    AC1,                         ; set one's in AC1
        MOVE    AC,MMODE
        CAMN    AC,[ASCII/R    /]            ; = R?
         MOVEI  AC1,0                        ; yes, move in  0
        CAMN    AC,[ASCII/RV   /]            ; = RV?
         MOVEI  AC1,2                        ; yes, move in  2
        CAMN    AC,[ASCII/RR   /]            ; = RR?
         MOVEI  AC1,4                        ; yes, move in  4
        CAMN    AC,[ASCII/RRV  /]            ; = RRV?
         MOVEI  AC1,6                        ; yes, move in  6
        CAMN    AC,[ASCII/W    /]            ; = W?
         MOVEI  AC1,10                       ; yes, move in  8
        CAMN    AC,[ASCII/WV   /]            ; = WV?
         MOVEI  AC1,12                       ; yes, move in 10
        CAMN    AC,[ASCII/WR   /]            ; = WR?
         MOVEI  AC1,14                       ; yes, move in 12
        CAMN    AC,[ASCII/WRV  /]            ; = WRV?
         MOVEI  AC1,16                       ; yes, move in 14
        CAMN    AC,[ASCII/M    /]            ; = M?
         MOVEI  AC1,20                       ; yes, move in 16
        CAMN    AC,[ASCII/MV   /]            ; = MV?
         MOVEI  AC1,22                       ; yes, move in 18
        CAMN    AC,[ASCII/MR   /]            ; = MR?
         MOVEI  AC1,24                       ; yes, move in 20
        CAMN    AC,[ASCII/MRV  /]            ; = MRV?
         MOVEI  AC1,26                       ; yes, move in 22
        JUMPL   AC1,BADMOD                   ; if AC1 unchanged then error
        MOVEM   AC1,NMODE                     
	POPJ	P,
 
BADMOD:
        TYPSTR  ([ASCIZ/Invalid Mdisk Mode/])
        JRST    GETMOD
 

RWMOD:	; write mode  to request file
	REQOUT	(REQ,MMODE,L.MOD)
	POPJ	P,

CMDCMF: ; change mdisk format
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CMFO <
	X	(HST1OT,GETH37,RWH37)
	X	(NAMOUP,GETUSR,RWUSR)
	X	(FOMOUT,GETFOM,RWFOM)
	X	(MDIOUT,GETMDI,RWMDI)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CMF,CMFO,^D13,USRRQQ)

; code for change mdisk format starts here, only immediate mode and PROCESS
; can enter
        SNDBYT  (OLDPRT,\B.LCOM,CFMLUD,I)       ; change mdisk format
        SNDSTR  (AC,L.UNM3,UNMSPC)
        SNDBYT  (AC,\B.FS,FS)
	SNDSTR	(AC,B.MDI,MDISK)
	PUSHJ	P,OLDA
	 JRST	CMFOR2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CMFOR4
	TTFSTR	([ASCIZ/Change Mdisk Format/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
CMFOR4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CMFORD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CMFORD
	JRST	CMFST2			; ABRV'ST2 is the menu output section

CMFORD: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

CMFOR2:	; error during change mdisk format
	TYPSTR	([ASCIZ/Error during Change Mdisk Format./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	CMFOR3

CMFOR3:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	CMFST2

; end of code for change mdisk format
 
FOMOUT:
        TYPSTR  ([ASCIZ/Format :/],777,0,T.P0,N)
        TYPSTR  (OFS,L.OFS,0,T.P2)
        POPJ    P,
 
GETFOM:
        INSTR   ([ASCIZ/Format (IBM or TFS):/],OFS,L.OFS)
        MOVE    AC,OFS
        CAME    AC,[ASCIZ/IBM  /]
         JRST   GETFO2
        MOVEI   AC1,1
        MOVEM   AC1,FS
        POPJ    P,
GETFO2:
        CAME    AC,[ASCIZ/TFS  /]
         JRST   GETFOM
        MOVEI   AC1,2
        MOVEM   AC1,FS
        POPJ    P,
 
RWFOM:
        REQOUT  (REQ,OFS,L.OFS)
        POPJ    P,
CMDCMP: ; change mdisk passwords
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CMPW <
	X	(HST1OT,GETH37,RWH37)
	X	(NAMOUP,GETUSR,RWUSR)
	X	(MDIOUT,GETMDI,RWMDI)
	X	(RPWOUT,GETRPW,RWRPW)
	X	(WPWOUT,GETWPW,RWWPW)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CMP,CMPW,^D61,USRRQQ)

; code for change mdisk password starts here, only immediate mode and
; PROCESS command can enter into following codes

	SNDBYT	(OLDPRT,\B.LCOM,CMPLUD,I)	; change mdisk passwords
	SNDSTR	(AC,L.UNM3,UNMSPC)
        SNDSTR  (AC,B.MDI,MDISK)            ; send mdisk address
        SNDSTR  (AC,L.UNM3,RPW)             ; send read password
	SNDSTR	(AC,L.UNM3,WPW)             ; send write password
	PUSHJ	P,OLDA
	 JRST	CMPWE2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CMPWC4
	TTFSTR	([ASCIZ/Change Mdisk Passwords/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
 
CMPWC4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CMPWCD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CMPWCD
	JRST	CMPST2			; ABRV'ST2 is the menu output section

CMPWCD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

CMPWE2:	; error during change mdisk password
	TYPSTR	([ASCIZ/Error during Change Mdisk Passwords./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	CMPWE3
 
CMPWE3:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	     ; skip if not processing a request
	 POPJ	P,		     ; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	CMPST2

; end of code for change mdisk passwords
CMDCFO: ; change all users' focus flat fee flag under same cid and same host
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CFOC <
	X	(CSNOU4,GE4CSN,RWCSN)              
        X       (HST1OT,GE1H37,RWH37)
	X	(FOCOUT,GETFOC,RWFOC)     
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CFO,CFOC,^D31,CUSRQQ)

; code for change all users focus flat fee starts here, only immediate mode
; and PROCESS command can enter into following codes

; first, list all users and their hosts for the customer
	SNDBYT	(ACTPRT,\B.ACOM,LCUACT,I)	; list user and hosts for a cid
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        PUSHJ   P,AGANS
	 JRST   CFOCE3                ; error
        GETBYT  (ACTPRT,\B.DIS)       ; get district
         JRST   GETCMD
GNNAME: GETSTR  (ACTPRT,L.UNM,UAUNM)  ; get username
        CAIN    AC1,377               ; skip if not end
         JRST   CFODNE
        GETBYT  (ACTPRT,\B.GAN)       ; get gan
         JRST   GETCMD
GNHOST: GETBYT  (ACTPRT,\B.HST)       ; get host
         JRST   GETCMD
        CAIL    AC1,^D9999            ; skip if not end
         JRST   GNNAME                ; get next name
        CAME    AC1,LUDNUM            ; match with input host number?
         JRST   GNHOST                ; no, get next host
; yes, then change focus flat fee flag for this user in lud
        SNDBYT  (OLDPRT,\B.LCOM,CFOLUD,I)
        SNDSTR  (AC,L.UNM3,UAUNM)
        SNDBYT  (AC,\B.FOCF,ACFOCF)
        PUSHJ   P,OLDA
         JRST   CFOCE2
	JRST    GNHOST                ; get next host until it exhaust then
                                      ; back to get next username
; tattle
CFODNE: TYPSTR  ([ASCIZ/Entry Completed./])
        GETT    (/CHG/)
	 JRST	CFOCU4
	TTFSTR	([ASCIZ/Change All Users Focus Fee Flag/])
	PUSHJ	P,STDCHD              ; write standard header
	PUSHJ	P,RELTTF
 
CFOCU4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CFOCUD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CFOCUD
	JRST	CFOST2			; ABRV'ST2 is the menu output section

CFOCUD: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
CFOCE2: ; error during change focus flat fee flag in lud
        TYPSTR  ([ASCIZ/Username -/],777,0,T.P0,N)
        TYPSTR  (UAUNM,L.UNM,1)
        TYPSTR  ([ASCIZ/Error during Change User Focus Fee Flag./])
        MOVE    AC1,OLDANS
        PUSHJ   P,LUDAOT
        POPJ    P,
 
CFOCE3: ; error in list usernames and hosts for a customer
        TYPSTR  ([ASCIZ/Error during List All Users and Hosts for Customer./])
        MOVE    AC1,AGANS
        PUSHJ   P,LUDAOT
        POPJ    P,
; end of code for change customer focus flat fee flag
 
GE4CSN: ; get cid and all hosts valid on this cid
        PUSHJ   P,GETACC
         JRST   GETCMD
        PUSHJ   P,GETCUS
         JRST   .-1
        TLNE    FLG2,V.LSQ            ; skip if not a list
         POPJ    P,
        PUSHJ   P,GCHREC              ; get host numbers and save
         JRST   [TYPSTR  ([ASCIZ/No host for this customer./])
                 JRST    GE4CSN]
        TLNN    FLG2,V.EXC            ; skip if changing items
         JRST   GE4CS2
        PUSHJ   P,CHKHST
         JRST   [PUSHJ   P,INORNO
                 JRST    GE4CSN]
GE4CS2: MOVEI   AC1,A370
        MOVEM   AC1,ACTSY2            ; attg. system type is always 3
        PUSHJ   P,CHKCUS
         JRST   GE4CSN
        SNDBYT  (ACTPRT,\B.ACOM,LCNACT,I) ; get customer name
        SNDBYT  (AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ASY,ACTSY2)
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Not a valid Tymahre customer number./])
                 JRST    GE4CSN]
        GETSTR  (AC,L.CUSN,ACCNAM)
        POPJ    P,
 
GE1H37: ; get 370 host number and make sure it is valid in above cid
        INNUM   ([ASCIZ/Host :/],D)
         JRST   [PUSHJ   P,INORNO
                 JRST    GE1H37]
        JUMPE   AC1,.-1
        MOVEM   AC1,LUDNUM
        MOVEM   AC1,HOST
        TLNE    FLG2,V.LSQ            ; skip if not a list command
         POPJ   P,
        PUSHJ   P,CHKHST              ; check host valid on cid
         JRST   [PUSHJ   P,INORNO
                 JRST    GE1H37]
        PUSHJ   P,GETOLD
         JRST   GETCMD
        MOVE    AC,OLDASY
        CAIN    AC,A370
         POPJ   P,
        TYPSTR  ([ASCIZ/Cmd only available on Tymcom-370/])
        PUSHJ   P,INORNO
        JRST    GE1H37
 
 
CHKHST:
        SETZM   UAHSTC
CHKHS1: MOVE    AC1,UAHSTC
        CAML    AC1,UAHSTP
         JRST   [TYPSTR  ([ASCIZ/Host not valid in this customer./])
                 POPJ    P,]
        MOVE    AC1,UAHST(AC1)
        CAMN    AC1,LUDNUM
         JRST   .+3                   ; found, skip return
        AOS     UAHSTC                ; increment count
        JRST    CHKHS1
        AOS     (P)
        POPJ    P,
CMDCTD: ; change tymuser days
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CTDA <
	X	(CSNOU5,GE3CSN,RWCSN)              
	X	(DAYOUT,GETDAY,RWDAY)     
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CTD,CTDA,^D30,CUSRQQ)

; code for change tymuser days starts here, only immediate mode and
; PROCESS command can enter into following codes

        SNDBYT	(ACTPRT,\B.ACOM,CTYACT,I)	; chg. tymuser days
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.TDS,TCDS)
        PUSHJ   P,AGANS
	 JRST	CTDAE2
	MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CTYDA4
	TTFSTR	([ASCIZ/Change Tymuser Days/])
	PUSHJ	P,STDCHD              ; write standard header
	PUSHJ	P,RELTTF
 
CTYDA4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CTYDAD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CTYDAD
	JRST	CTDST2			; ABRV'ST2 is the menu output section

CTYDAD: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
CTDAE2: ; error during change tymuser days
        TYPSTR  ([ASCIZ/Error during Change Tymuser Days./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    CTDAE3
 
CTDAE3: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    CTDST2
 
; end of code for change tymuser days
 
CSNOU5:
        SETZM   ACTSYS
        PUSHJ   P,CSNOU1
        POPJ    P,
 
GE3CSN:
        PUSHJ   P,GETCUS
         JRST   GE3CSN
        PUSHJ   P,GETACC
         JRST   GETCMD
        TLNE    FLG2,V.LSQ            ; skip if not  a listing
         POPJ   P,
        MOVEI   AC,LCTACT
        MOVEM   AC,FINARG
        MOVE    AC,CUSNUM
        MOVEM   AC,FINAR2             
        SETZM   ACTSYS                ; set ACTSYS = 0 for calling FINAST
        PUSHJ   P,FINAST              ; get actg. system type then call CHKCUS
         JRST   [TYPSTR  ([ASCIZ/No acctg record for this customer./])
                 JRST    GE3CSN]
        PUSHJ   P,CHKCUS
         JRST   GE3CSN
        SNDBYT  (ACTPRT,\B.ACOM,KTYACT,I)  ; check valid tymuser cid
        SNDBYT  (AC,\B.CID,CUSNUM)
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Not a Valid Tymuse Customer/])
                 JRST    GE3CSN]
        SNDBYT  (ACTPRT,\B.ACOM,LCNACT,I)  ; get cus. name from acctg.
        SNDBYT  (AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ASY,ACTSY2)
        PUSHJ   P,AGANS
         JRST   GE3CSN
        GETSTR  (AC,L.CUSN,ACCNAM)    ; get customer name
        POPJ    P,
 
DAYOUT:
        MOVE    AC,TCDS
        PUSHJ   P,TDAOUT
        POPJ    P,
 
GETDAY:
        INNUM   ([ASCIZ/Hold days :/],D)
         JRST   [PUSHJ   P,INORNO
                 JRST    GETDAY]
        MOVEM   AC1,TCDS
        POPJ    P,
 
RWDAY:
        REQNOT  (REQ,TCDS,D)
        POPJ    P,
 
CMDCTC: ; change tymuser receiving customer info
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE CTCN <
	X	(CSNOU5,GE3CSN,RWCSN)              
        X       (OUASK1,GEASK1,WASK1)
	X	(CSMOU5,GE3CSM,RWCSM,MFLAG,2)
        X       (OUASK2,GEASK2,WASK2,MFLAG,2)
        X       (NAMOU1,GE2USE,RWUSR,TCFLG,1)
	X	(DAYOUT,GETDAY,RWDAY,TCFLG,1)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CTC,CTCN,^D33,CUSRQQ)

; code for change tymuser customer starts here, only immediate mode and
; PROCESS command can enter into following codes

        SNDBYT	(ACTPRT,\B.ACOM,CTRACT,I)	; chg. tymuser receiving cid
	SNDBYT	(AC,\B.CID,CUSNUM)
	SNDBYT	(AC,\B.CID,TCRCID)
        SNDBYT  (AC,\B.FS,TCFLG)      ; send flag
        MOVE    AC1,TCFLG
        CAIE    AC1,1
         JRST   INPDNE                ; no user, input finished
        SNDBYT  (ACTPRT,\B.UUN,NMUUN)
        SNDBYT  (AC,\B.TDS,TCDS)
INPDNE: PUSHJ   P,AGANS
	 JRST	CTCNE2
	MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
; tattle
	GETT	(/CHG/)
	 JRST	CTYCN4
	TTFSTR	([ASCIZ/Change Tymuser Receiving Customer Info/])
	PUSHJ	P,STDCHD              ; write standard header
	PUSHJ	P,RELTTF
 
CTYCN4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CTYCND			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	CTYCND
	JRST	CTCST2			; ABRV'ST2 is the menu output section

CTYCND: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
CTCNE2: ; error during change tymuser receiving customer info
        TYPSTR  ([ASCIZ/Error during Change Tymuser Receiving Customer Info./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    CTCNE3
 
CTCNE3: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    CTCST2
 
; end of code for change tymuser receiving customer info.
 
OUASK1:
        MOVE    AC1,MFLAG
        CAIE    AC1,2
         JRST   O2ASK1
        TYPSTR  ([ASCIZ/Send Data to Another Customer/],777,0,T.P0)
        POPJ    P,
O2ASK1: TYPSTR  ([ASCIZ/No Receiving Customer/],777,0,T.P0)
        POPJ    P,
 
GEASK1:
        GETYR   ([ASCIZ/Send Data to Another Customer?/])
         JRST   G2ASK1                ; no
        MOVEI   AC1,2                 ; yes
        MOVEM   AC1,MFLAG             
        POPJ    P,
G2ASK1: MOVEI   AC1,1
        MOVEM   AC1,MFLAG
        MOVEM   AC1,TCFLG
        SETZM   TCRCID                ; define receiving cid to zero
        POPJ    P,
WASK1:
        MOVE    AC1,MFLAG
        CAIE    AC1,2
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        POPJ    P, 
 
CSMOU5:
        TYPSTR  ([ASCIZ/Receiving Cid :/],777,0,T.P0,N)
        TYPNUM  (TCRCID,D,0,T.P2,N)
        TYPSTR  ([ASCIZ/ - /],777,0,0,N)
        SETZM   ACTSYS
        TLNN    FLG2,V.LSQ                  ; skip if it is type command
         JRST   CSMOU2
        MOVEI   AC,LCTACT
        MOVEM   AC,FINARG
        MOVE    AC,TCRCID
        MOVEM   AC,FINAR2
        PUSHJ   P,FINAST
         JRST   CSMOU5
        SNDBYT  (ACTPRT,\B.ACOM,LCNACT,I)   ; get rec. customer name from acct.
        SNDBYT  (ACTPRT,\B.CID,TCRCID)
        SNDBYT  (ACTPRT,\B.ASY,ACTSY2)
        PUSHJ   P,AGANS
         JRST   CSMOU5
        GETSTR  (AC,L.CUSN,TCRCN)           ; get receviing customer name
CSMOU2: TYPSTR  (TCRCN,777,1)
        POPJ    P,
 
GE3CSM: ; get receiving customer number
        INNUM   ([ASCIZ/Receiving Cid :/],D)
         JRST   [PUSHJ   P,INORNO
                 JRST    GE3CSM]
        JUMPE   AC1,.-1
        MOVEM   AC1,TCRCID
        TLNE    FLG2,V.LSQ            ; skip if not  a listing
         POPJ   P,
        MOVEI   AC,LCTACT
        MOVEM   AC,FINARG
        MOVE    AC,TCRCID
        MOVEM   AC,FINAR2             
        SETZM   ACTSYS                ; set ACTSYS = 0 for calling FINAST
        PUSHJ   P,FINAST              ; get actg. system type then call CHKCUS
         JRST   [TYPSTR  ([ASCIZ/No acctg record for this customer./])
                 JRST    GE3CSM]
        PUSHJ   P,CHKCUS
         JRST   GE3CSM
        SNDBYT  (ACTPRT,\B.ACOM,KTYACT,I)  ; check valid tymuser cid
        SNDBYT  (AC,\B.CID,TCRCID)
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Not a Valid Tymuse Customer/])
                 JRST    GE3CSM]
        SNDBYT  (ACTPRT,\B.ACOM,LCNACT,I)  ; get receiving cid
        SNDBYT  (AC,\B.CID,TCRCID)
        SNDBYT  (AC,\B.ASY,ACTSY2)
        PUSHJ   P,AGANS
         JRST   GE3CSM
        GETSTR  (AC,L.CUSN,TCRCN)
        POPJ    P,
 
RWCSM:
        REQNOT  (REQ,TCRCID,D)
        POPJ    P,
 
OUASK2:
        MOVE    AC1,TCFLG
        CAIE    AC1,1
         JRST   O2ASK2
        TYPSTR  ([ASCIZ/Receiving Own Data/],777,0,T.P0)
        POPJ    P,
O2ASK2: TYPSTR  ([ASCIZ/Do not Receive Own Data/],777,0,T.P0)
        POPJ    P,
 
GEASK2:
        GETYR   ([ASCIZ/Receiving Own Data ?/])
         JRST   G2ASK2                ; no
        MOVEI   AC1,1                 ; yes
        MOVEM   AC1,TCFLG
        POPJ    P,
G2ASK2: MOVEI   AC1,2
        MOVEM   AC1,TCFLG
        POPJ    P,
 
WASK2:
        MOVE    AC1,TCFLG
        CAIE    AC1,1
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        POPJ    P, 
 
NAMOU1:
        TYPSTR  ([ASCIZ/Dest. User :/],777,0,T.P0,N)
        TYPSTR  (UNMSPC,L.UNM,0,T.P2)
        POPJ    P,
 
GE2USE:
        INSTR   ([ASCIZ/Dest. user :/],UNMSPC,L.UNM,T)
        MOVEI   AC1,L.UNM
        MOVEI   AC,UNMSPC
        PUSHJ   P,CNTCHR
        SKIPN   AC1                   ; skip if not blank
         JRST   [PUSHJ   P,INORNO
                  JRST   GE2USE]
        TLNE    FLG2,V.LSQ            ; skip if not type command
         POPJ   P,
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GCREC
         JRST   GE2USE
        SNDBYT  (ACTPRT,\B.ACOM,LCN2CT,I)   ; get user cid
        SNDBYT  (AC,\B.UUN,NMUUN)
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/No acctg record for this username./])
                 JRST    GE2US3]
        GETBYT  (AC,\B.CID)
         JRST   GETCMD
        CAMN    AC1,CUSNUM            ; match against the input cid
         POPJ   P,                    ; matches
        TYPSTR  ([ASCIZ/User does not belong to this customer /])
        JRST    GE2USE
GE2US3:
        TRNN    FLG,U.RFI             ; skip if this is from a request
         JRST   [PUSHJ   P,INORNO
                 JRST    GE2USE]
        PUSHJ   P,REQERR
        POPJ    P,
 
DEFINE SET1 <
        X TYMUS,2,CMDSTY,U.PRV!U.DIS,-1   ; set tymuse for customer
        X RESTR,1,CMDSRE,U.PRV,-1         ; set user restriction
        X GFD,1,CMDSGF,U.PRV,-1           ; set user gfd only
        X TGY,2,CMDSGY,U.PRV!U.NET,-1     ; set user transparent getway lic
        X NOMUL,2,CMDSNM,U.PRV,-1         ; set user no multi-logon lic.
        X COLON,1,CMDSCO,U.PRV!U.NET,-1   ; set user colon option
>

	SUBCOM	([ASCIZ /Set :/],SET,SET1)
CMDSTY: ; set tymuse for a customer
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE STYM <
	X	(CSNOU6,GE5CSN,RWCSN)              
        X       (DATOU1,GE1DAT,RWPOE)
        X       (OUASK1,GEASK1,WASK1)
	X	(CSMOU5,GE3CSM,RWCSM,MFLAG,2)
        X       (OUASK2,GEASK2,WASK2,MFLAG,2)
        X       (NAMOU1,GE2USE,RWUSR,TCFLG,1)
	X	(DAYOUT,GETDAY,RWDAY,TCFLG,1)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (STY,STYM,^D35,CUSRQQ)

; code for set tymuser customer starts here, only immediate mode and
; PROCESS command can enter into following codes

        SNDBYT	(ACTPRT,\B.ACOM,STYACT,I)	; set tymuse
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.PODT,ACPSDM)   ; use po start date symbol
	SNDBYT	(AC,\B.CID,TCRCID)
        SNDBYT  (AC,\B.FS,TCFLG)      ; send flag
        MOVE    AC1,TCFLG
        CAIE    AC1,1
         JRST   INPUDN                ; no user, input finished
        SNDBYT  (ACTPRT,\B.UUN,NMUUN)
        SNDBYT  (AC,\B.TDS,TCDS)
INPUDN: PUSHJ   P,AGANS
	 JRST	STYME2
	MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
; tattle
	GETT	(/SET/)
	 JRST	SETYM4
	TTFSTR	([ASCIZ/Set Tymuse Customer/])
	PUSHJ	P,STDCHD              ; write standard header
	PUSHJ	P,RELTTF
 
SETYM4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	SETYMD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	SETYMD
	JRST	STYST2			; ABRV'ST2 is the menu output section

SETYMD: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
STYME2: ; error during set tymuse customer
        TYPSTR  ([ASCIZ/Error during Set Tymuse Customer./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    STYME3
 
STYME3: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    STYST2
 
; end of code for set tymuse customer
 
CSNOU6:
        SETZM   ACTSYS
        PUSHJ   P,CSNOU1
        POPJ    P,
 
DATOU1:
        TYPSTR  ([ASCIZ/Start Date (yymmdd) :/],777,0,T.P0,N)
        TYPNUM  (ACPSDM,D,0,T.P2)
        POPJ    P,
 
GE5CSN:
        SETZM   ACTSYS
        PUSHJ   P,GETCSN
        POPJ    P,
 
GE1DAT:
        INNUM   ([ASCIZ/Start Date (yymmdd) :/],D)
         JRST   [PUSHJ   P,INORNO
                 JRST    GE1DAT]
        MOVEM   AC1,ACPSDM
        POPJ    P,
CMDSRE: ; set user restriction
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE SRES <
        X       (HST1OT,GETH37,RWH37)
	X	(NAMOUP,GETUSR,RWUSR)
	X	(RESTOU,GETRES,RWPRI)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (SRE,SRES,^D36,USRRQQ)

; code for set user restriction starts from here

	SNDBYT	(OLDPRT,\B.LCOM,CRSLUD,I)	; set user restriction
	SNDSTR	(AC,L.UNM3,UNMSPC)
        SNDBYT  (AC,\B.FS,PRIOR)
	PUSHJ	P,OLDA
	 JRST	SRESE2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/SET/)
         JRST   SERES4
	TTFSTR	([ASCIZ/Set User Restriction/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
 
SERES4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	SERESD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	SERESD
	JRST	SREST2			; ABRV'ST2 is the menu output section

SERESD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

SRESE2:	; error during set restriction
	TYPSTR	([ASCIZ/Error during Set User Restriction./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	SRESE3
 
SRESE3:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	SREST2

; end of code for set user restriction
 
 
RESTOU:
        TYPSTR  ([ASCIZ/Priority :/],777,0,T.P0,N)
        TYPNUM  (PRIOR,D,0,T.P2)
        POPJ    P,
 
GETRES:
        INNUM   ([ASCIZ/Priority :/],D)
         JRST    [PUSHJ   P,INORNO
                  JRST    GETRES]
        CAILE   AC1,^D200
         JRST   GE1RES
        MOVEM   AC1,PRIOR
        POPJ    P,
GE1RES: TYPSTR  ([ASCIZ/Priority must be less than or equal to 200/])
        JRST    GETRES
CMDSGF: ; set user gfd only
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE SGFD <
	X	(NAMOUP,GECUSR,RWUSR)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (SGF,SGFD,^D37,USRRQQ)

; code for set user gfd starts from here

	SNDBYT	(CUDPRT,\B.CCOM,CGFMUD,I)	; set user gfd only
	PUSHJ   P,SNMCUD
        PUSHJ   P,SND40
	PUSHJ	P,NGANS
	 JRST	ERRCUD
        PUSHJ   P,GET40
	TYPSTR  ([ASCIZ/Entry Complete./])
; tattle
        GETT    (/SET/)
         JRST   SEGFD4
	TTFSTR	([ASCIZ/Set User Gfd/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
 
SEGFD4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	SEGFDD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	SEGFDD
	JRST	SGFST2			; ABRV'ST2 is the menu output section

SEGFDD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
GECUSR: ; get username and make sure it is valid
        PUSHJ   P,GETUNM
         JRST   [PUSHJ   P,INORNO
                 JRST    GECUSR]
        TLNE    FLG2,V.LSQ            ; skip if not type command
         POPJ   P, 
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GCREC
         JRST   GECUS1
        PUSHJ   P,CHKUUN
         JRST   GECUS1
        POPJ    P,
GECUS1:
        TRNN    FLG,U.RFI
         JRST   [PUSHJ   P,INORNO
                 JRST    GECUSR]
        PUSHJ   P,REQERR
        POPJ    P,

; end of code for set user gfd only

CMDSGY:  ; set transparent getway license for user(s)
        TCR     (1)
        PUSHJ   P,GETCUD
         JRST   GETCMD
CMDSG1:
        PUSHJ   P,GETUNM              ; get username
         JRST   CMSGYD                ; done
        PUSHJ   P,GCREC1              ; get cud record
         JRST   CMDSG1
        MOVE    AC,NMCPAR
        TRO     AC,GTW.CD             ; set gtw lic.
        LSH     AC,-^D8               ; right shift 8 bits
        MOVEM   AC,NMCPAR
        SNDBYT  (CUDPRT,\B.CCOM,CLIMUD,I)
        PUSHJ   P,SNMCUD
        SNDBYT  (CUDPRT,\B.CPR,NMCPAR)
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   ERRCUD
        PUSHJ   P,GET40
        GETT    (/SET/)
         JRST   CMDSG1
        TTFSTR  ([ASCIZ/Set User Gty./])
        PUSHJ   P,STDUHD
        PUSHJ   P,RELTTF
        JRST    CMDSG1
 
CMSGYD:
        TRO     FLG,U.OKAY
        POPJ    P,

CMDSNM:  ; set no multiple logon  license for user(s)
        TCR     (1)
        PUSHJ   P,GETCUD
         JRST   GETCMD
CMDSN1:
        PUSHJ   P,GETUNM              ; get username
         JRST   CMSGYD                ; done
        PUSHJ   P,GCREC1              ; get cud record
         JRST   CMDSN1
        MOVE    AC,NMCPAR
        TRO     AC,NML.CD             ; set nml lic.
        LSH     AC,-^D8               ; right shift 8 bits
        MOVEM   AC,NMCPAR
        SNDBYT  (CUDPRT,\B.CCOM,CLIMUD,I)
        PUSHJ   P,SNMCUD
        SNDBYT  (CUDPRT,\B.CPR,NMCPAR)
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   ERRCUD
        PUSHJ   P,GET40
        GETT    (/SET/)
         JRST   CMDSN1
        TTFSTR  ([ASCIZ/Set User Nml./])
        PUSHJ   P,STDUHD
        PUSHJ   P,RELTTF
        JRST    CMDSN1
 
 
 
 
 
CMDSCO:  ; set colon option
        TCR     (1)
        PUSHJ   P,GETCUD
         JRST   GETCMD
CMDSC1:
        PUSHJ   P,GETUNM              ; get username
         JRST   GETCMD                ; done
        PUSHJ   P,GCREC1              ; get cud record
         JRST   CMDSC1
        MOVE    AC,NMCOLN
        TLZ     AC,CLN.CD             ; set colon option
        LSH     AC,-^D16              ; right shift 16 bits
        MOVEM   AC,NMCOLN
        SNDBYT  (CUDPRT,\B.CCOM,CCOMUD,I)
        PUSHJ   P,SNMCUD
        SNDBYT  (CUDPRT,\B.CLN,NMCOLN)
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   ERRCUD
        PUSHJ   P,GET40
        JRST    CMDSC1
 
DEFINE UNS1 <
        X TGY,2,CMDUTG,U.PRV!U.NET,-1     ; unset transparent gateway lic.
        X TYMUS,2,CMDUTY,U.PRV!U.DIS,-1   ; unset tymuse for customer
>

	SUBCOM	([ASCIZ /Unset :/],UNS,UNS1)
 
 
 
CMDUTG:  ; unset transparent getway license for user(s)
        TCR     (1)
        PUSHJ   P,GETCUD
         JRST   GETCMD
CMDUG1:
        PUSHJ   P,GETUNM              ; get username
         JRST   CMUGYD                ; done
        PUSHJ   P,GCREC1              ; get cud record
         JRST   CMDUG1
        MOVE    AC,NMCPAR
        TRZ     AC,GTW.CD             ; unset gtw lic.
        LSH     AC,-^D8               ; right shift 8 bits
        MOVEM   AC,NMCPAR
        SNDBYT  (CUDPRT,\B.CCOM,CLIMUD,I)
        PUSHJ   P,SNMCUD
        SNDBYT  (CUDPRT,\B.CPR,NMCPAR)
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   ERRCUD
        PUSHJ   P,GET40
        GETT    (/UNS/)
         JRST   CMDUG1
        TTFSTR  ([ASCIZ/Unset User Gty./])
        PUSHJ   P,STDUHD
        PUSHJ   P,RELTTF
        JRST    CMDUG1
 
CMUGYD:
        TRO     FLG,U.OKAY
        POPJ    P,
CMDUTY: ; unset tymuse
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE UNSE <
	X	(CSNOU5,GE3CSN,RWCSN)              
	X	(DATEOU,GEDATE,RWPOE)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (UNS,UNSE,^D34,CUSRQQ)

; code for unset tymuse customer starts here, only immediate mode and
; PROCESS command can enter into following codes

        SNDBYT	(ACTPRT,\B.ACOM,UTYACT,I)	; unset tymuse
	SNDBYT	(AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.PODT,ACPEDM)   ; use po stop date symbols
        PUSHJ   P,AGANS
	 JRST	UNSEE2
	MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
; tattle
	GETT	(/SET/)
	 JRST	UNSET4
	TTFSTR	([ASCIZ/Unset Tymuse/])
	PUSHJ	P,STDCHD              ; write standard header
	PUSHJ	P,RELTTF
 
UNSET4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	UNSETD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	UNSETD
	JRST	UNSST2			; ABRV'ST2 is the menu output section

UNSETD: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
UNSEE2: ; error during unset tymuse
        TYPSTR  ([ASCIZ/Error during Unset Tymuse./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    UNSEE3
 
UNSEE3: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    UNSST2
 
; end of code for unset tymuse
 
DATEOU:
        TYPSTR  ([ASCIZ/Stop Date (yymmdd) :/],777,0,T.P0,N)
        TYPNUM  (ACPEDM,D,0,T.P2)
        POPJ    P,
 
GEDATE: 
        INNUM   ([ASCIZ/Stop Date (yymmdd) :/],D)
         JRST   [PUSHJ   P,INORNO
                 JRST    GEDATE]
        MOVEM   AC1,ACPEDM
        POPJ    P,
 
DEFINE CNC1 <
        X REQUE,1,CMDCAN,U.IMM!U.UPD!U.AP!U.NET,-1   ; cancel request
        X USER,1,CMDCAU,U.PRV!U.DIS,-1    ; cancel user from tymshare
        X GAN,1,CMDCAG,U.PRV,-1           ; cancel gan from tymshare
        X MUD,1,CAMUDX,U.WC,-1            ; cancel user in the mud
>

	SUBCOM	([ASCIZ /Cancel :/],CNC,CNC1)
CMDCAU: ; cancel user from tymshare and tymnet, only ask username
	TCR	(1)
        PUSHJ   P,CHKFRA              ; check French validators' username
        TLNE    FLG2,V.EXQ!V.LSQ!V.PRQ
         JRST   CMDCA1
        TLNE    FLG,U.IMM
         JRST   CMDCA1
        TYPSTR  (WN1)
        TCR     (1)
CMDCA1: TRO     FLG2,V.NIR

DEFINE CAUS <
	X	(NAMOUP,USRGET,RWUSR)
           ; X       (HST1OT,GE1HST,RWH37)    ; ge1hst coded in move.mac
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CAU,CAUS,^D40,USRRQQ)

; code for cancel user from tymshare starts here, only immediate mode and
; PROCESS command can enter the following codes

   ;    PUSHJ   P,GETOLD
   ;     JRST   GETCMD
        PUSHJ   P,GETACC
         JRST   GETCMD
 
 
; cancel user from accounting in both userdb and tuserdb (if any)
; when cancel user in userdb, always define ludnum = 1 (or any valid
; host number)
     
        MOVEI   AC,1
        MOVEM   AC,LUDNUM
 
;       SNDBYT  (ACTPRT,\B.ACOM,CAUACT,I)  ; remove user in userdb
;       SNDBYT  (AC,\B.UUN,NMUUN)     ; send uun
;       SNDBYT  (AC,\B.HST,LUDNUM)
;       PUSHJ   P,AGANS
;        JFCL   
        ; proceed error or not
        SNDBYT  (ACTPRT,\B.ACOM,RTYACT,I)    ; remove user from tuserdb
        SNDBYT  (AC,\B.UUN,NMUUN)
        PUSHJ   P,AGANS
         JRST   CAUMUD
        JRST    CAUMUD
 
; skip the following code of cancelling user from lud, since PJ will
; update the lud through lud change file
  
CMDCA3: MOVE    AC,OLDASY             ; get accounting system type
        CAIN    AC,A370               ; skip if not 370
         JRST   CAU370
        CAIN    AC,A940               ; skip if not 940
         JRST   CAU940
 
        ; remove user from pdp10 lud
 
	SNDBYT	(OLDPRT,\B.LCOM,REMLUD,I)	
        SNDSTR  (AC,L.UNM,UNMSPC)
        JRST    CAUDNE
 
CAU370: ; remove user from 370 lud
	SNDBYT	(OLDPRT,\B.LCOM,REMLUD,I)	
       	SNDSTR  (AC,L.UNM3,UNMSPC)
         JRST   CAUDNE
 
CAU940: ; delete user from 940 lud
	SNDBYT	(OLDPRT,\B.LCOM,REMLUD,I)	
        SNDBYT  (OLDPRT,\B.940W,0,I)    ; send dummy request no.
        SNDSTR  (AC,L.UNM,UNMSPC)
        SNDBYT  (AC,\B.940W,[44444444]) ; send 44444444 in octal
 
CAUDNE: PUSHJ   P,OLDA
         JRST   CAUSE4
        MOVE    AC,OLDASY
        CAIE    AC,A10
         JRST   CAUMUD
        GETBYT  (OLDPRT,\B.GAN)
         JRST   GETCMD
        GETBYT  (OLDPRT,\B.UUN)
         JRST   GETCMD
 
; remove user from mud
 
CAUMUD: SNDBYT  (CUDPRT,\B.CCOM,RUSMUD,I)
        PUSHJ   P,SNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   CAUSE5
        PUSHJ   P,GET40
 
; write ludupd file
 
        TRO     FLG2,V.LUD            ; for using tat.mac
        GETT    (/DEL/)
         JRST   LUDBAD
        TTFSTR  (UNMSPC,L.UNM,N,Y)
        TTFNUM  (NMUUN,O,Y,Y)
        PUSHJ   P,RELTTF
        TRZ     FLG2,V.LUD
 
        TYPSTR  ([ASCIZ/Entry Complete./])
 
; tattle
	GETT	/CAN/
	 JRST	CAUST4
	TTFSTR	([ASCIZ/Cancel User /])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
 
CAUST4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CAUSTD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
         JRST   CAUSTD
	JRST	CAUST2			; ABRV'ST2 is the menu output section

CAUSTD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 
LUDBAD: TYPSTR  ([ASCIZ/error in writing LUDUPD.DEL file./])
        TRZ     FLG2,V.LUD
        JRST    GETCMD
 
CAUSE2:	; error during delete user host in accounting
	TYPSTR	([ASCIZ/Error during Cancel User in Accunting./])
	MOVE	AC1,ACANS
	PUSHJ	P,LUDAOT
        JRST    CAUSE3
 
CAUSE3: ; after error, see if we can give him  another chance
        MOVE    AC,SIXUNM
        CAMN    AC,[SIXBIT/VALADM/]   ; skip if not VALADM1 (army corp.)
         JRST   GETNON                ; for army corp., waste rest of input
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    CAUST2

CAUSE4:	; error during cancel user from the lud
	TYPSTR	([ASCIZ/Error during Cancel User from the Lud./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        SNDBYT  (ACTPRT,\B.CCOM,REVACT,I)   ; reverse last acctg. entry
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Reverse Acctg. Entry not Working!/])
                 POPJ    P,]
        POPJ    P,

CAUSE5:	; error during cancel user in the mud
	TYPSTR	([ASCIZ/Error during Cancel User Host in the Cud./])
        PUSHJ   P,ERRCUD
        SNDBYT  (ACTPRT,\B.CCOM,REVACT,I)   ; reverse last acctg. entry
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Reverse Acctg. Entry not Working!/])
                 POPJ    P,]
        POPJ   P,
        
        ; reverse last lud entry
 
;       MOVE    AC,OLDASY
;       CAIN    AC,A940
;        JRST   RVS940
 
        ; reverse last lud entry on pdp10 or 370
     
;       SNDBYT  (OLDPRT,\B.LCOM,REVLUD,I)
;       PUSHJ   P,OLDA
;        JRST   [TYPSTR  ([ASCIZ/Reverse Lud Entry not Working!/])
;                POPJ    P,]
;       POPJ    P,
; RVS940:
        ; there is no salve program for reversing last 940 lud entry!
;       TYPSTR  ([ASCIZ/Can not Reverse Last Entry for 940 Lud!/])
;       POPJ    P,

; end of code for cancel user 
 
 
GEBUSR: ; input username and perform various checkings
        PUSHJ   P,GETUNM
         JRST   [PUSHJ   P,INORNO
                 JRST    GEBUSR]
        TLNE    FLG2,V.LSQ            ; skip if it is a type command
         POPJ   P,
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GCREC
         JRST   GEBUS2
        PUSHJ   P,CHKUUN              ; check access
         JRST   GEBUS2
        PUSHJ   P,GETACC
         JRST   GETCMD
        TLNN    FLG,U.PRV             ; skip if privileged
         JRST   GEBUS3
        TRZ     FLG2,V.TFLG
        SNDBYT  (ACTPRT,\B.ACOM,LTYMCT,I)  ; list user in tuserdb
        SNDBYT  (AC,\B.UUN,NMUUN)
        PUSHJ   P,AGANS
         JRST   GEBUS3                ; jump if not found
        GETBYT  (ACTPRT,\B.CID)
         JRST   GETCMD
        GETSTR  (AC,L.CUSN,ACCNAM)    ; get customer name
        GETSTR  (AC,L.UNM,MAILNA)     ; get mailname
        GETBYT  (AC,\B.CC)
         JRST   GETCMD
        TRO     FLG2,V.TFLG           ; turn flag on for cancel in tuserdb
GEBUS3: SNDBYT  (ACTPRT,\B.ACOM,LHOACT,I)  ; get all hosts for this user
        SNDBYT  (AC,\B.UUN,NMUUN)
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Error in listing hosts for this user/])
                 JRST    GEBUS2]
        PUSHJ   P,GHSTAC              ; input hosts
        TLNN    FLG2,V.EXC            ; skip if changing items
         POPJ   P,
        PUSHJ   P,CKHST1              ; check user valid on this host
         JRST   GEBUS2
        POPJ    P,
 
GEBUS2:
        TRNN    FLG,U.RFI             ; skip if this is from a request
         JRST    [PUSHJ   P,INORNO
                  JRST    GEBUSR]
        PUSHJ   P,REQERR
        POPJ    P,
 
CMDCAG: ; cancel  gan from tymshare
	TCR	(1)
        TLNE    FLG2,V.EXQ!V.LSQ!V.PRQ
         JRST   CMDCA2
        TLNE    FLG,U.IMM
         JRST   CMDCA2
        TYPSTR  (WN1)
        TCR     (1)
CMDCA2: TRO     FLG2,V.NIR

DEFINE CAGA <
	X	(GANOU1,GEAGAN,RWUSR)
        X       (HST1OT,GE1HST,RWH37)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (CAG,CAGA,^D41,USRRQQ)

; code for cancel gan  from tymshare starts here, only immediate mode and
; PROCESS command can enter the following codes

        PUSHJ   P,GETOLD              ; build circuit to lud
         JRST   GETCMD
 
; cancel gan from the lud - will be treated  differently according to
; system type
  
        MOVE    AC,OLDASY             ; get accounting system type
        CAIN    AC,A370               ; skip if not 370
         JRST   CAG370
        CAIN    AC,A940               ; skip if not 940
         JRST   CAG940
 
        ; cancel gan  from pdp10 lud
 
	SNDBYT	(OLDPRT,\B.LCOM,DACLUD,I)	
        SNDBYT  (AC,\B.GAN,NMGAN)
        JRST    CAGLU1
 
CAG370: ; cancel gan  from 370 lud
	SNDBYT	(OLDPRT,\B.LCOM,DACLUD,I)	
       	SNDBYT  (AC,\B.GAN,NMGAN)
         JRST   CAGLU1
 
CAG940: ; cancel gan  from 940 lud
	SNDBYT	(OLDPRT,\B.LCOM,DACLUD,I)	
        SNDBYT  (OLDPRT,\B.940W,0,I)    ; send dummy request no.
        SNDBYT  (AC,\B.GAN,NMGAN)
        SNDBYT  (AC,\B.940W,[44444444]) ; send 44444444 in octal
 
CAGLU1: PUSHJ   P,OLDA
         JRST   CAGAE2
GUSRLP: MOVE    AC,OLDASY
        CAIN    AC,A370               ; skip if not 370
         JRST   [GETSTR  (OLDPRT,L.UNM3,UNMSPC)
                 JRST    GUSRL2]
        GETSTR  (OLDPRT,L.UNM,UNMSPC) ; input pdp10 or 940 username
GUSRL2: CAIN    AC1,377               ; skip if not end
         JRST   CAGDNE                ; all done
        TYPSTR  (UNMSPC,L.UNM,0,T.P0)
        GETBYT  (OLDPRT,\B.GAN)       ; get gan
         JRST   GETCMD
        GETBYT  (OLDPRT,\B.UUN)       ; get uun
         JRST   GETCMD
        MOVEM   AC1,NMUUN
        GETBYT  (OLDPRT)              ; get one byte
         JRST   GETCMD
        CAIE    AC1,1
         JRST   CAGAE2
 
; remove user from mud
 
        MOVEI   AC1,UNMSPC
        PUSHJ   P,NAMOUT
        SNDBYT  (CUDPRT,\B.CCOM,RUSMUD,I)
        PUSHJ   P,SNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   CAGAE4
        PUSHJ   P,GET40
 
; cancel user from accounting
 
        SNDBYT  (ACTPRT,\B.ACOM,CAUACT,I)
        SNDBYT  (AC,\B.UUN,NMUUN)     ; send uun
        SNDBYT  (AC,\B.HST,LUDNUM)
        PUSHJ   P,AGANS
         JRST   CAGAE5
        JRST    GUSRLP
 
; tattle
 
CAGDNE: GETT    /CAN/
	 JRST	CAGAT4
	TTFSTR	([ASCIZ/Cancel Gan  /])
	PUSHJ	P,STDGHD
	PUSHJ	P,RELTTF
        TYPSTR  ([ASCIZ/Entry Complete./])
 
CAGAT4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	CAGATD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
         JRST   CAGATD
	JRST	CAGST2			; ABRV'ST2 is the menu output section

CAGATD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,
 

CAGAE2:	; error during cancel gan from lud
	TYPSTR	([ASCIZ/Error during Cancel Gan from the Lud./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        JRST    CAGAE3

CAGAE3: ; after error, see if we can give him  another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    CAGST2
CAGAE4:	; error during cancel user host in mud
	TYPSTR	([ASCIZ/Error during Cancel User from the Cud./])
        TYPSTR  (UNMSPC,L.UNM,1,0)
        PUSHJ   P,ERRCUD
        POPJ    P,
 
CAGAE5:	; error during cancel user from accounting
	TYPSTR	([ASCIZ/Error during Cancel User in Accunting./])
        TYPSTR  (UNMSPC,L.UNM,1,0)
	MOVE	AC1,ACANS
	PUSHJ	P,LUDAOT
        POPJ    P,
 
; end of code for cancel gan
  
r