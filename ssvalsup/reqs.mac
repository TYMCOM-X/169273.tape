SUBTTL REQS - REQUEST ROUTINES

  IFDEF DEBUG, <
CMDNRF:	; create a new reques.dir file, this is available only in the
	; debug version of USRVAL.  Requires U.WC to be set.
	GETYR	([ASCIZ/Are you sure you want to create a new reqdir ? /])
	 POPJ	P,
	TYPSTR	([ASCIZ/If you say so./])
CMNRF2:	MOVE	AC,[.CHOPN,,RDFCHN]	; open a channel.
	CHANIO	AC,NRFOPN
	 JRST	CMNRF2
	MOVE	AC,[DB.DIR]		; prepare extended lookup block.
	MOVEM	AC,NRFLK+.RBPPN
	MOVE	AC,[SIXBIT/REQUES/]
	MOVEM	AC,NRFLK+.RBNAM
	HRLZI	AC,(SIXBIT/DIR/)
	MOVEM	AC,NRFLK+.RBEXT
	SETZM	NRFLK+.RBPRV
	MOVEI	AC,NRFLKS
	MOVEM	AC,NRFLK
	MOVE	AC,[.CHLK,,RDFCHN]	; ready for lookup.
	CHANIO	AC,NRFLK		; lookup.
	 JRST	CMNRF3			; new file.
	TYPSTR	([ASCIZ/Existing file./]) ; tell about old file.
	GETYR	([ASCIZ/Are you quite positive about this?/])
	 JRST	CMNRF5
	TYPSTR	([ASCIZ/Ok - you're the boss./])
CMNRF3:	MOVE	AC,[.CHCLS,,RDFCHN]	; close any old file for superceed.
	CHANIO	AC,
	MOVE	AC,[DB.DIR]		; prepare lookup block for enter.
	MOVEM	AC,NRFLK+.RBPPN
	MOVE	AC,[SIXBIT/REQUES/]
	MOVEM	AC,NRFLK+.RBNAM
	HRLZI	AC,(SIXBIT/DIR/)
	MOVEM	AC,NRFLK+.RBEXT
	HRLZI	AC,(777B8)
	MOVEM	AC,NRFLK+.RBPRV		; prot = 'NO NO NO'
	MOVEI	AC,NRFLKS
	MOVEM	AC,NRFLK
	MOVE	AC,[.CHENT,,RDFCHN]	; enter
	CHANIO	AC,NRFLK
	 JRST	CMNRFE
	MOVEI	AC1,RDFSIZ		; number of pages to create.
	MOVE	AC,[.CHCFP,,RDFCHN]
	SETO	AC2,			; will be page 1 all the time.
CMNRF4:	CHANIO	AC,AC2			; create a file page.
	 JRST	CMNRFE
	AOJ	AC2,			; bump the page number by 1.
	SOJG	AC1,CMNRF4		; do the rest.
	PUSHJ	P,FPG2MP		; find core page address.
	MOVEM	AC,NUM			; save.
	HRLI	AC,(3B7!1B17)		; protection, count.
	MOVEM	AC,TTFPAG
	MOVEI	AC1,1			; page 1.
	MOVEM	AC1,TTFPAG+1		; set up for map.
	MOVE	AC,[.CHMFP,,RDFCHN]	;  ditto.
	CHANIO	AC,TTFPAG		; map.
	 JRST	CMNRFE
	MOVEI	AC1,1			; move a '1' to word 0.
	MOVE	AC2,NUM			; compute address.
	IMULI	AC2,1000
	MOVEM	AC1,0(AC2)		; move it in.
	MOVE	AC1,NUM
	HRLI	AC1,1			; prepare for unmap
	VCLEAR	AC1,
	 JFCL
	TYPSTR	([ASCIZ/Done./])
CMNRF5:	MOVE	AC,[.CHREL,,RDFCHN]	; release the channel.
	CHANIO	AC,
	POPJ	P,

CMNRFE:
	TYPSTR	([ASCIZ/Error opening file/])
	MOVE	AC,[.CHREL,,RDFCHN]
	CHANIO	AC,
	POPJ	P,

 >	; end of cmdnrf code.
NTMRQF:	; create temp filename for request files and store in lookup block
	; also prepare rest of lookup/enter block
	PJOB	AC,		; get our absolute frame number
	ADDI	AC,^D1000	; add a thousand so names will be same size
	MOVEI	AC4,^D10	; decimal conversion
	TRO	FLG,U.SIX	; set sixbit flag
	PUSHJ	P,NUMOUT	; convert to sixbit chars
	TRZ	FLG,U.SIX	; reset sixbit flag
	MOVE	AC,NUMSP	; get sixbit filename
	IOR	AC,TQSUFF	; or in the suffix into the filename
	MOVEM	AC,TMRLK+.RBNAM	; store in lookup block
	MOVE	AC,[DB.DIR]
	MOVEM	TMRLK+.RBPPN
	SETZM	TMRLK+.RBEXT
	HRLZI	AC,(777B8)
	MOVEM	AC,TMRLK+.RBPRV
	POPJ	P,

NPMRQF:	; create request file name and store in lookup block
	MOVE	AC,[DB.DIR]
	MOVEM	AC,PMRLK+.RBPPN
	MOVE	AC,REQNUM	; convert reqnum to sixbit
	MOVEI	AC4,^D10
	TRO	FLG,U.SIX
	PUSHJ	P,NUMOUT
	TRZ	FLG,U.SIX
	MOVE	AC,NUMSP
	MOVEM	AC,PMRLK+.RBNAM	; move it into enter/lookup blok
	SETZM	PMRLK+.RBEXT
	HRLZI	AC,(777B8)
	MOVEM	AC,PMRLK+.RBPRV	; set prot = 'no no no'
	MOVEI	AC,PMRLKS	; set size of lookup block
	MOVEM	AC,PMRLK
	POPJ	P,

NPBRQF:	; create request file name in form Bxxxx. and store in lk blk
	PUSHJ	P,NPMRQF	; create std perm name
	MOVE	AC,PMRLK+.RBNAM	; get name
	LSH	AC,-6		; right shift one char
	TLO	AC,(SIXBIT/B/)	; put a b into 1st char position
	MOVEM	AC,PMRLK+.RBNAM
	POPJ	P,

GNXTRQ:	; allocate a request number
; This routine places the current available request number in REQNUM.
; It then finds the next available request number and updates word 0
; of reques.dir.  Then it deletes any files associated with the current
; request number.  As a byproduct, the next request number is placed
; in NEXREQ, but this can't be reliable because other copies of USRVAL
; may allocate requests at any time.
	PUSHJ	P,ENTRQF	; go enter request file
	PUSHJ	P,FPG2MP	; find core page
	HRRZ	AC1,.JBFF	; get last .jbff value
	MOVEM	AC1,SAVJBF	; save it
	MOVE	AC1,AC		; now compute last occupied address
	ADDI	AC1,2
	IMULI	AC1,1000	; convert page to word address
	SUBI	AC1,1		; last word of previous page
	HRRM	AC1,.JBFF	; store new .jbff value
	MOVEM	AC,NUM		; save page number
	HRLI	AC,(3B7!1B17)	; protection, count
	MOVEM	AC,TTFPAG
	MOVEI	AC1,1
	MOVEM	AC1,TTFPAG+1	; page 1
	MOVE	AC,[.CHMFP,,RDFCHN]
	CHANIO	AC,TTFPAG	; map
	 BOMB	(ERR.R2)
	MOVE	AC1,NUM		; get core page number
	IMULI	AC1,1000	; make into an address
	MOVE	AC,0(AC1)	; get next available reqnum
	SETZM	0(AC1)		; set it to zero until update
	MOVEM	AC1,SAVRP1	; save address of page 1
	SKIPLE	AC		; skip if reqnum le 0 
	 CAILE	AC,REQMAX	; skip if reqnum le max reqnum
	  BOMB	(ERR.R2)	; fatal damage to file
	MOVEM	AC,REQNUM	; save reqnum
; at this point we have page one of reques.dir mapped and we know the 
; current request number available.  We must now update word 0 of reques.dir
; by finding which request will be next available for use.
	AOJ	AC,		; bump up by one
	MOVEM	AC,NEXREQ	; save in nexreq
GNXTR0:
	IDIVI	AC,1000		; divide by number of requests per page
	AOJ	AC,		; correct
	MOVEM	AC,TTFPGM	; save page number
	PUSHJ	P,FPG2MP	; get core page
	HRLI	AC,(1B7!1B17)	; prot, count
	MOVEM	AC,TTFPAG
	MOVE	AC,[.CHMFP,,RDFCHN]
	CHANIO	AC,TTFPAG
	 BOMB	(ERR.R2)
	MOVE	AC1,NEXREQ	; get next number to check
	ANDI	AC1,777		; within this page
	MOVEI	AC,1000
	SUB	AC,AC1		; records left on this page
	MOVNS	AC
	HRRZ	AC2,TTFPAG
	IMULI	AC2,1000	; words per page
	ADD	AC1,AC2		; make into an address
	HRLM	AC,AC1		; make ac1 an aobjn index
GNXTR1:	MOVE	AC,0(AC1)	; get a word
	JUMPE	AC,GNXTRD	; got it
	TLNE	AC,R.NAC	; skip if not still an active request
	 JRST	GNXTRD		; got it
	AOS	NEXREQ
	AOBJN	AC1,GNXTR1
; here if no open request slots this page
	HRRZ	AC,TTFPAG	; unmap the page
	HRLI	AC,1		; count
	VCLEAR	AC,
	 JFCL
	MOVE	AC,NEXREQ
	CAIG	AC,REQMAX	; skip if nexreq gt reqmax
	 JRST	GNXTR0
	MOVEI	AC,1		; wrap around to beginning of file
	MOVEM	AC,NEXREQ
	JRST	GNXTR0
GNXTRD:	; here when we find an empty spot
	MOVE	AC,NEXREQ	; update word zero
	MOVEM	AC,@SAVRP1
	MOVE	AC,SAVRP1	; unmap page 1 of file
	IDIVI	AC,1000
	HRLI	AC,1
	VCLEAR	AC,
	 JFCL
	HRRZ	AC,TTFPAG	; unmap last data page
	HRLI	AC,1
	VCLEAR	AC,
	 JFCL
	MOVE	AC,[.CHREL,,RDFCHN] ; release the channel
	CHANIO	AC,	
	MOVE	AC,SAVJBF	; restore .jbff
	MOVEM	AC,.JBFF
; Now we can delete any existing files associated with this request.
GNXTD2:
	MOVE	AC,[.CHOPN,,RDFCHN]	; open a channel
	CHANIO	AC,NRFOPN
	 JRST GNXTD2
	MOVEI	AC,MAXINQ-1	; number of files-1
	MOVEM	AC,RQFCT	; save in memory
GNXTD3:
	PUSHJ	P,NPMRQF	; create lookup block.
	MOVE	AC1,RQFCT	; get index
	MOVE	AC,QEXT(AC1)	; get extention
	MOVEM	AC,PMRLK+.RBEXT	; move into lookup block
	MOVE	AC,[.CHLK,,RDFCHN]
	CHANIO	AC,PMRLK
	 JRST	GNXTD4		; no such file
	MOVE	AC,[.CHREN,,RDFCHN]	; delete
	SETZB	AC1,AC2
	CHANIO	AC,AC1
	 JFCL
GNXTD4:	SOSL	RQFCT		; sub one from counter, skip if negative
	 JRST	GNXTD3		; do next file

	MOVE	AC,[.CHREL,,RDFCHN] ; release channel 
	CHANIO	AC,
; this is the end of the GNXTRQ routine, always just return
	POPJ	P,

GNMREQ:	; starting with REQNUM+1, retieve each word in reques.dir.
;	  do a pushj p, to the address provided in ac.  If the routine
;	  skip returns continue, otherwise release reques.dir

	MOVEM	AC,REQPAD		; save
	AOS	REQNUM			; start with next request number
	MOVE	AC,REQNUM
	SKIPL	AC			; skip if < 0
	 CAILE	AC,REQMAX		; skip if <= max
	  POPJ	P,			; return if out of range
GMNRQ0:
	PUSHJ	P,ENTRQF		; enter reques.dir
	MOVE	AC,REQNUM
	IDIVI	AC,1000			; divide by request per page
	AOJ	AC,			; correct page
	MOVEM	AC,TTFPGM		; save page
	PUSHJ	P,FPG2MP		; get virtual core page
	HRLI	AC,(3B7!1B17)		; prot, count
	MOVEM	AC,TTFPAG
	MOVE	AC,[.CHMFP,,RDFCHN]	; map file page to it
	CHANIO	AC,TTFPAG
	 BOMB	(ERR.R2)
	MOVE	AC1,REQNUM		; get request number
	ANDI	AC1,777			; isolate request within this page
	MOVEI	AC,1000			; calculate number of requests left
	SUB	AC,AC1			;  on this page.
	MOVNS	AC			; make negative.
	HRRZ	AC2,TTFPAG		; get core page address
	IMULI	AC2,1000		; convert to word address
	ADD	AC1,AC2			; add start point
	HRLM	AC,AC1			; ac1 now aobjn index
GMNRQ1:	MOVE	AC,0(AC1)		; move word from reques.dir to ac
	PUSHJ	P,@REQPAD		; perform the test
	 JRST	GMNRQ2			; match found
	AOS	REQNUM			; increment request number
	AOBJN	AC1,GMNRQ1		; do next request this page
	HRRZ	AC,TTFPAG		; unmap this page
	HRLI	AC,1
	VCLEAR	AC,
	 JFCL
	MOVE	AC,REQNUM		; see if any more requests left
	CAILE	AC,REQMAX
	 JRST	GMNRQ3			; no more requests
	JRST	GMNRQ0			; map next page
GMNRQ2:	; here when a match is found
	HRRZ	AC,TTFPAG		; unmap page
	HRLI	AC,1
	VCLEAR	AC,
	 JFCL
	MOVE	AC,[.CHREL,,RDFCHN]	; release channel
	CHANIO	AC,
	AOS	0(P)			; skip return
	POPJ	P,
GMNRQ3:	; match not found
	HRRZ	AC,TTFPAG		; unmap page
	HRLI	AC,1
	VCLEAR	AC,
	 JFCL
	MOVE	AC,[.CHREL,,RDFCHN]	; release channel
	CHANIO	AC,
	POPJ	P,			; non-skip return


REQTS1:	; non skip return if the value in ac skips on a tdnn with reqmsk.
	TDNN	AC,REQMSK		; test against mask
	 AOS	0(P)
	POPJ	P,

REQTS2:	; non skip return if the value in ac skips on a tdnn with reqmsk
;	  and with reqms2.
	TDNN	AC,REQMSK
	 JRST	SPOPJ
	TDNN	AC,REQMS2
	 JRST	SPOPJ
	POPJ	P,
SPOPJ:	AOS	0(P)
	POPJ	P,

REQTS3:	; non skip return if the value in ac skips on a tdnn with reqmsk
;	  and on a tdne with reqms2
	TDNN	AC,REQMSK
	 JRST	SPOPJ
	TDNE	AC,REQMS2
	 JRST	SPOPJ
	POPJ	P,

REQTS4:	; non skip return if the right half of ac matches my.uun
;	destroys left half of ac
	HRRZS	AC
	CAME	AC,MY.UUN	; skip if match
	 JRST	SPOPJ
	POPJ	P,
 
CHKCOM: ; check if request is complete
        MOVE    AC,REQVAL
        TLNN    AC,R.COM              ; skip if complete
         JRST   CHKCO1
        TYPSTR  ([ASCIZ/This request has been processed./])
        POPJ    P,
CHKCO1: AOS     0(P)
        POPJ    P,

CHKREV: ; check if request need reviewed
        MOVE    AC,REQVAL
        TLNE    AC,R.NACC             ; skip if need not review
         JRST   CHKRE1
        TYPSTR  ([ASCIZ/This request should not be reviewed./])
        POPJ    P,
CHKRE1: AOS     0(P)
        POPJ    P,

CHKEXA: ; check if request need examined
        MOVE    AC,REQVAL
        TLNE    AC,R.NEX              ; skip if not need examined
         JRST   CHKEX1
        TYPSTR  ([ASCIZ/This request should not be examined./])
        POPJ    P,
CHKEX1: AOS     0(P)
        POPJ    P,

CHLOCK:	; get the reqval value for reqnum, if locked just return
;	if not locked, lock it ans skip return
	MOVEI	AC,CHLOC2
	MOVEM	AC,REQPAD
	JRST	GMNRQ0		; go get the value
CHLOC2:
	JUMPE	AC,CHLOC3	; if zero, just return
	TLOE	AC,R.LCK	; skip if not locked
	 JRST	CHLOC3
	MOVEM	AC,0(AC1)	; lock request
	MOVEM	AC,REQVAL	; move to reqval if updated
	POP	P,AC
	JRST	GMNRQ2		; release the file and skip return 
CHLOC3:	POP	P,AC
	TYPSTR	([ASCIZ/Request/],777,0,0,N)
	TYPNUM	(REQNUM,D,1,0,N)
	TYPSTR	([ASCIZ/is locked./],777,1)
	JRST	GMNRQ3		; release the file and just return

LKRQF:	; init rdfchn and lookup reques.dir
	MOVE	AC,[.CHOPN,,RDFCHN]
	CHANIO	AC,NRFOPN	; open a channel
	 JRST	LKRQF
	MOVE	AC,[DB.DIR]	; prepare lookup block for reques.dir
	MOVEM	AC,NRFLK+.RBPPN
	MOVE	AC,[SIXBIT/REQUES/]
	MOVEM	AC,NRFLK+.RBNAM
	HRLZI	AC,(SIXBIT/DIR/)
	MOVEM	AC,NRFLK+.RBEXT
	SETZM	NRFLK+.RBPRV
	MOVEI	AC,NRFLKS
	MOVEM	AC,NRFLK
	MOVE	AC,[.CHLK,,RDFCHN]
	CHANIO	AC,NRFLK	; lookup
	 BOMB	(ERR.RN)	; fatal error, there must be a reques.dir
	POPJ	P,

ENTRQF:	; enter request file
	PUSHJ	P,LKRQF		; init channel and lookup file reques.dir
	MOVE	AC,[DB.DIR]	; now prepare for enter
	MOVEM	AC,NRFLK+.RBPPN
	MOVE	AC,[SIXBIT /REQUES/]
	MOVEM	AC,NRFLK+.RBNAM
	HRLZI	AC,(SIXBIT/DIR/)
	MOVEM	AC,NRFLK+.RBEXT
	HRLZI	AC,(777B8)	; prot = 'no no no'
	MOVEM	AC,NRFLK+.RBPRV
	MOVEI	AC,NRFLKS
	MOVEM	AC,NRFLK
	MOVE	AC,[.CHENT,,RDFCHN]
	CHANIO	AC,NRFLK	; enter
	 JRST	ENTRQE		; error in enter
	SETZM	TTBCT
	POPJ	P,

ENTRQE:	; enter error trying to enter reques.dir
	HRRZ	AC,NRFLK+.RBEXT	; get error code
	CAIN	AC,.ERFBM	; skip if not file busy
	 JRST	ENTQE1
	MOVEM	AC,NUM
	TYPSTR	([ASCIZ/Error opening REQDIR - error = /],777,0,0,N,Y)
	TYPNUM	(NUM,O,1,0,Y,Y)
	JRST	CMDQUI
ENTQE1:	; here when file busy error
	MOVE	AC,[.CHREL,,RDFCHN]	; release channel
	CHANIO	AC,
	MOVE	AC,TTBCT
	CAIE	AC,3
	 JRST	ENTQE2
; type file busy error every 'mod (try-count, 1000) = 3'
	TYPSTR	([ASCIZ/REQDIR file busy./])
ENTQE2:	CAIN	AC,^D1000
	 JRST	ENTQE3
	AOS	TTBCT
	JRST	ENTRQF	; try again
ENTQE3:	SETZM	TTBCT
	JRST	ENTRQF	; try again

RDRQF:	; input value of request word for request in REQNUM into REQVAL
	; the request file is kept busy during the read.
	SETOM	REQVAL		; set reqval to -1
	MOVE	AC,REQNUM
	SKIPLE	AC
	 CAILE	AC,REQMAX
	  POPJ	P,		; illegal value in reqnum
	PUSHJ	P,ENTRQF	; enter the file ( to lock )
	MOVE	AC,REQNUM
	IDIVI	AC,1000
	AOJ	AC,		; page number reqnum is on
	MOVEM	AC,TTFPGM
	PUSHJ	P,FPG2MP
	HRLI	AC,(1B7!1B17)	; prot, count
	MOVEM	AC,TTFPAG
	MOVE	AC,[.CHMFP,,RDFCHN]	; map the page
	CHANIO	AC,TTFPAG
	 BOMB	(ERR.R2)
	MOVE	AC,REQNUM
	ANDI	AC,777		; isolate number within this page
	HRRZ	AC1,TTFPAG
	IMULI	AC1,1000
	ADD	AC1,AC
	MOVE	AC,0(AC1)	; find the value
	MOVEM	AC,REQVAL
	HRRZ	AC,TTFPAG	; unmap the page
	HRLI	AC,1
	VCLEAR	AC,
	 JFCL
	MOVE	AC,[.CHREL,,RDFCHN]	; release the channel
	CHANIO	AC,
	POPJ	P,

WRRQF:	; write the value in reqval into request file at REQNUM
;	  skip return if ok .  cannot be used to write word zero
	MOVE	AC,REQNUM
	SKIPLE	AC
	 CAILE	AC,REQMAX
	  POPJ	P,		; just return if reqnum out of range
	PUSHJ	P,ENTRQF	; enter reques.dir
	MOVE	AC,REQNUM
	IDIVI	AC,1000
	AOJ	AC,		; page number this request is on
	MOVEM	AC,TTFPGM
	PUSHJ	P,FPG2MP	; find core page
	HRLI	AC,(3B7!1B17)	; prot, count
	MOVEM	AC,TTFPAG
	MOVE	AC,[.CHMFP,,RDFCHN]	; map
	CHANIO	AC,TTFPAG
	 BOMB	(ERR.R2)
	MOVE	AC,REQNUM	; get request number
	ANDI	AC,777		; isolate to within this page
	HRRZ	AC1,TTFPAG	; compute address
	IMULI	AC1,1000
	ADD	AC1,AC
	MOVE	AC,REQVAL	; get value to write
	MOVEM	AC,0(AC1)	; write it
	HRRZ	AC,TTFPAG	; unmap page
	HRLI	AC,1
	VCLEAR	AC,
	 JFCL
	MOVE	AC,[.CHREL,,RDFCHN]	; release channel
	CHANIO	AC,
	AOS	0(P)		; skip return
	POPJ	P,

REQSTO:	; output a string to a request file
; input:    ac/ address of string
;	    ac1/ max length of string (string terminates on null)
;	    ac2/ index into request file tables
; this routine copies string into REQSBU, so <ac1> must be <= size(REQSBU)
	HRLZS	AC	; move address to left half
	HRRI	AC,REQSBU
	BLT	AC,REQSBU+REQSSI-1	; copy string
	MOVEM	AC2,RQFCT		; save index
	MOVEM	AC1,RQFLN		; save max ct
	SKIPL	QACTO(AC2)		; skip if active
	 PUSHJ	P,REQOPN		; activate file
	MOVE	AC2,RQFCT		; get index
	MOVE	AC3,OTQTAB(AC2)		; address of ring header
	ADDI	AC3,2			; adjust to byte count
	MOVE	AC1,RQFLN
	MOVE	AC,[POINT 7,REQSBU]
	MOVEM	AC,REQSBP
REQST1:
	SOSGE	0(AC3)			; skip if buffer still has room
	 PUSHJ	P,REQONB		; output last buffer
	ILDB	AC,REQSBP		; get a byte
	JUMPE	AC,REQST2		; jump out of loop if null
	IDPB	AC,-1(AC3)		; deposit in buffer
	SOJG	AC1,REQST1		; next
	SOSGE	0(AC3)			; put in <crlf>
	 PUSHJ	P,REQONB
REQST2:
	MOVEI	AC,.CR
	IDPB	AC,-1(AC3)
	SOSGE	0(AC3)
	 PUSHJ	P,REQONB
	MOVEI	AC,.LF
	IDPB	AC,-1(AC3)
	POPJ	P,			; return

REQOPN:	; init request file channel and enter a file
	MOVE	AC,OTQTAB(AC2)
	HRLZM	AC,REQFBO+2
	HRLI	AC,.CHOPN		; open channel code
	HRR	AC,QCHNO(AC2)		; channel
	CHANIO	AC,REQFBO
	 JRST	REQOPN
	PUSHJ	P,NTMRQF		; create filename
	MOVE	AC2,RQFCT		; get index
	MOVE	AC,QEXT(AC2)		; get extention
	MOVEM	AC,TMRLK+.RBEXT		; put into enter block
	HRLI	AC,.CHENT
	HRR	AC,QCHNO(AC2)		; channel
	CHANIO	AC,TMRLK		; enter
	 BOMB	(ERR.R3)		; suicide if enter does not work
	HRLI	AC,.CHOUT
	CHANIO	AC,			; out
	 SKIPA
	 BOMB	(ERR.R3)
	MOVE	AC2,RQFCT		; set active flag
	SETOM	QACTO(AC2)
	POPJ	P,

REQONB:	; output a bufferful
	MOVE	AC2,RQFCT
	HRLI	AC,.CHOUT
	HRR	AC,QCHNO(AC2)
	CHANIO	AC,
	 SKIPA
	 BOMB	(ERR.R3)
	POPJ	P,

RELRQO:	; close output request files and rename them as permanent reqs
; If the contents of REQNUM is not zero, use this as the request number,
; deleting any existing files by the same name.  If REQNUM is zero, then
; this routine allocates a request number via GNXRQO and then renames
; the temp request output files to their permanent form.
; The contents of reqval are then copied to the correct word in reques.dir.
	SKIPG	REQNUM		; skip if contents of reqnum > 0
	 PUSHJ	P,GNXTRQ	; get a request number
	MOVEI	AC,MAXINQ-1	; number of files -1
	MOVEM	AC,RQFCT
RELRO1:
	MOVE	AC1,RQFCT
	SKIPN	QACTO(AC1)	; skip if active request file
	 JRST	RELRO5
	PUSHJ	P,NPMRQF	; create lookup block
	MOVE	AC1,RQFCT
	MOVE	AC,QEXT(AC1)	; get extention
	MOVEM	AC,PMRLK+.RBEXT
	MOVE	AC,[.CHOPN,,TMPCHN]	; open temp channel
	CHANIO	AC,TMPOPN
	 JRST	.-1
	TLO	FLG2,V.NBU	; set no-backup flag
	MOVE	AC,[.CHLK,,TMPCHN]
	CHANIO	AC,PMRLK	; lookup any old file by same name
	 JRST	RELRO3
	TLZ	FLG2,V.NBU	; reset nobackup flag
	PUSHJ	P,NPBRQF	; get backup filename lookup block
	MOVE	AC,[.CHREN,,TMPCHN]	; rename old file
	CHANIO	AC,PMRLK
	 BOMB	(ERR.R3)
RELRO3:	PUSHJ	P,NPMRQF	; get permanent name
	MOVE	AC1,RQFCT
	MOVE	AC,QEXT(AC1)
	MOVEM	AC,PMRLK+.RBEXT
	HRLI	AC,.CHREN	; rename
	HRR	AC,QCHNO(AC1)
	CHANIO	AC,PMRLK
	 BOMB	(ERR.R3)
	HRLI	AC,.CHREL	; release channel
	CHANIO	AC,
	SETZM	QACTO(AC1)	; reset active switch
	TLNE	FLG2,V.NBU	; skip if backup file to delete
	 JRST	RELRO4
	SETZB	AC1,AC2		; delete backup file
	MOVE	AC,[.CHREN,,TMPCHN]
	CHANIO	AC,AC1
	 JFCL
RELRO4:	MOVE	AC,[.CHREL,,TMPCHN]
	CHANIO	AC,
RELRO5:
	SOSL	RQFCT
	 JRST	RELRO1		; do next file
	PUSHJ	P,WRRQF		; copy reqval to reques.dir
	 BOMB	(ERR.R2)
	POPJ	P,		; return

QSTRIN:	; input a line from a request file
; input: ac/ address of buffer to input to
;	 ac1/ max length to input
;	 ac2/ index into request file tables
;	 reqnum/ request number
 	MOVEM	AC2,RQFCT	; save index
	MOVEM	AC1,RQFLN	; save length
	MOVEM	AC,RQFBA	; save address of buffer

	IDIVI	AC1,5		; divide by number of chars per word
	SKIPE	AC1+1		; skip if division was even
	 AOJ	AC1,		; increment number of words by one
	MOVE	AC2,[ASCII /     /]
	MOVEM	AC2,@RQFBA	; move spaces to 1st word in buffer
	MOVE	AC2,RQFBA
	AOJ	AC2,
	HRL	AC2,RQFBA
	MOVE	AC3,RQFBA
	ADDI	AC3,-1(AC1)	; end address for blt
	BLT	AC2,0(AC3)	; copy spaces to rest of buffer
	MOVE	AC2,RQFCT
	SKIPL	QACTI(AC2)	; skip if file open
	 PUSHJ	P,REQOPI	; go open a file
	MOVE	AC2,RQFCT
	MOVE	AC3,INQTAB(AC2)	; address of ring header
	ADDI	AC3,2		; adjust
	MOVE	AC1,RQFLN	; count
	MOVE	AC,RQFBA	; buffer address
	HRLI	AC,(POINT 7)	; make it into byte pointer
	MOVEM	AC,REQSBP	; save
QSTR1:
	SOSGE	0(AC3)		; skip if buffer still has chars
	 PUSHJ	P,REQINB	; go input another buffer
	ILDB	AC,-1(AC3)	; get a char
	CAIN	AC,.LF		; skip if not a line feed
	 JRST	QSTRD		; finished
	CAIGE	AC," "		; skip if not a control char
	 JRST	QSTR1		; get another
	IDPB	AC,REQSBP	; deposit into buffer
	SOJG	AC1,QSTR1	; get next char
; waste chars until we hit a line feed
QSTR2:
	SOSGE	0(AC3)
	 PUSHJ	P,REQINB
	ILDB	AC,-1(AC3)
	JUMPE	AC,QSTRD
	CAIN	AC,.LF
	 JRST	QSTRD
	JRST	QSTR2
QSTRD:
	POPJ	P,

REQOPI:	; init request file channel and lookup a file
;	just to keep things interesting, this routine will return
;	to the caller if it is successful, but will return to
;	the caller's caller if it is not.
	MOVE	AC,INQTAB(AC2)		;  buffer ring header address
	HRRZM	AC,REQFBO+2
	HRLI	AC,.CHOPN
	HRR	AC,QCHNI(AC2)
	CHANIO	AC,REQFBO		; open a channel 
	 JRST	REQOPI
	PUSHJ	P,NPMRQF		; create lookup block
	MOVE	AC2,RQFCT
	MOVE	AC,QEXT(AC2)		; move in the extention
	MOVEM	AC,PMRLK+.RBEXT
	HRLI	AC,.CHLK		; lookup
	HRR	AC,QCHNI(AC2)
	CHANIO	AC,PMRLK
	 JRST	REQOPE			; not found
	HRLI	AC,.CHIN		; input 1st bufferful
	CHANIO	AC,
	 SKIPA
	 JRST	REQOPE
	SETOM	QACTI(AC2)
	POPJ	P,
REQOPE:	; error, do not return to caller, return to caller's caller, no skip
	POP	P,AC		; waste one stack value
	SETZ	AC,
	POPJ	P,

REQINB:	; input a buffer from a request type file
	MOVE	AC2,RQFCT
	HRR	AC,QCHNI(AC2)
	HRLI	AC,.CHIN
	CHANIO	AC,
	 SKIPA
	 JRST	REQOPE		; return to caller's caller
	POPJ	P,

RELRQI:	; release request input channels
	MOVEI	AC,MAXINQ-1
	MOVEM	AC,RQFCT
RELRI1:
	MOVE	AC1,RQFCT
	SKIPN	QACTI(AC1)		; skip if active
	 JRST	RELRI2
	HRR	AC,QCHNI(AC1)		; release channel
	HRLI	AC,.CHREL
	CHANIO	AC,
	SETZM	QACTI(AC1)		; reset switch
RELRI2:
	SOSL	RQFCT
	 JRST	RELRI1	; next file
	POPJ	P,

CLRREQ:	; clear up request channels
	PUSHJ	P,RELRQI	; release input channels
	PUSHJ	P,DELRQO	; release output channels
	POPJ	P,

DELRQO:	; close output channels without renaming to permanent names.
;	this routine is usually called to abort a request
	MOVEI	AC,MAXINQ-1
	MOVEM	AC,RQFCT
DELRO1:
	MOVE	AC1,RQFCT
	SKIPN	QACTO(AC1)
	 JRST	DELRO2
	HRR	AC,QCHNO(AC1)
	HRLI	AC,.CHREL
	CHANIO	AC,
	SETZM	QACTO(AC1)
DELRO2:
	SOSL	RQFCT
	 JRST	DELRO1
	POPJ	P,
CONHDR:	; write a xxxx.con file with std header
	SKIPE	QACTO+2		; skip if con file not yet opened
	 POPJ	P,		; just return if allready done.
        REQNOT  (CON,REQDAT,D)   ; creation date
	;  REQNOT  (CON,[REL],D)   ; release
	REQNOT	(CON,[VER],D)	; version
	TLNE	FLG,U.IMM	; skip if in not immediate mode
	 JRST	CONHR2
	REQOUT	(CON,MY.UNM,L.UNM) ; username of originator (me)
	REQOUT	(CON,TATALE,L.UNM) ; status name of originator (me)
	JRST	CONHR3
CONHR2:
	REQOUT	(CON,RQUORG,L.UNM) ; username of originator
	REQOUT	(CON,RQSORG,L.UNM) ; status name of originator
CONHR3:
	REQOUT	(CON,CONSTR,L.CON) ; contact
	REQOUT	(CON,SRAAPP,L.UNM) ; sra approver
	REQOUT	(CON,VALPRO,L.UNM) ; validations processor
	REQNOT	(CON,REQCOM,D) ; request header
	REQNOT	(CON,REQERC,D)		; error code
	REQOUT	(CON,[ASCIZ/END/])
	POPJ	P,

CONRD:	; read con file
	SETZM	REQCOM
	SETZM	REQERC
	PUSHJ	P,RDRQF		; get reqval
	SKIPN	REQVAL
	 POPJ	P,
	REQINN	(CON,D)
	 JFCL
	MOVEM	AC1,REQDAT
	REQINN	(CON,D)
	 JFCL
	MOVEM	AC1,RVER
	REQINS	(CON,RQUORG,L.UNM)
	REQINS	(CON,RQSORG,L.UNM)
	REQINS	(CON,CONSTR,L.CON)
	REQINS	(CON,SRAAPP,L.UNM)
	REQINS	(CON,VALPRO,L.UNM)
	REQINN	(CON,D)
	 JFCL
	MOVEM	AC1,REQCOM	; command number
	REQINN	(CON,D)
	 JFCL
	MOVEM	AC1,REQERC	; error code
	POPJ	P,
EXMNMO:	; output the number for display of exam items
	MOVE	AC,EXMIN
	AOJ	AC,
	MOVEM	AC,EXMNUM
        TLNN    FLG,U.DIS             ; skip if district type user
         JRST   EXMNO1
        MOVE    AC1,REQCOM
        CAIE    AC1,^D52              ; skip if new customer command
         JRST   EXMNO1
        CAIN    AC,^D22
         POPJ   P,                    ; not printing 22nd item
        CAIN    AC,^D23
         POPJ   P,                    ; not printing 23rd item
EXMNO1: TYPNUM  (EXMNUM,D,0,0,N)
	TYPSTR	([ASCIZ/./],1,0,0,N)
	POPJ	P,
REQDIS:
; request command dispatcher
; expects c(REQCOM) is a valid command number

	MOVE	AC1,REQCOM		; get command number
	SKIPLE	AC1
	 CAILE	AC1,MAXRCM
	  POPJ	P,			; out of range, return
;	MOVE	AC,RCOMDS-1(AC1)	; address of descriptor
;	MOVEM	AC,REQTMP
;	TYPSTR	(@REQTMP)		; type descriptor
;	MOVE	AC1,REQCOM		; get command number
	PUSHJ	P,@RCOMTB-1(AC1)	; branch to it
	 POPJ	P,
	AOS	0(P)			; reflect skip return
	POPJ	P,

REQERR:	; warn user and set error seen during request
	TLO	FLG2,V.RER		; set flag
	TYPSTR	([ASCIZ/Request cannot be processed until this item is changed/])
	POPJ	P,

; VALRT's (routines to set up reqval for new requests)
; These routines must set up the bits in left half of reqval and move
; MY.UUN to the right half.  They must examine RCOMNA, RCOMAC and RCOMEX.

USRREQ:	; set up reqval for an existing username request
;	if nmcoln is already correct, this routine may be called at USRRQQ
	PUSHJ	P,GETCUD
	 JRST	GETCMD
	PUSHJ	P,GCREC1       ; get cud rec. but no format passdate
	 JRST	GETCMD
USRRQQ: SETZB   AC1,REQVAL            ; set both zeros
        MOVE    AC2,REQCOM            ; load dispatcher index
        MOVE    AC,NMCOLN             ; get colon word
        TLNE    AC,BIL.CD             ; skip if billable
         JRST   NBIREQ                ; non-billable case
        JRST    BILREQ                ; billable case

CUSREQ:	; set up reqval for an existing or new customer request
     ; if invoice code is already correct, this routine may be called at CUSRQQ
	PUSHJ	P,GETACC
	 JRST	GETCMD
	PUSHJ	P,GCAREK
	 JRST	GETCMD
CUSRQQ: SETZB   AC1,REQVAL            ; set both zeros
        MOVE    AC2,REQCOM            ; load dispatcher index
        MOVE    AC,ACINVC             ; get invoice code
        CAIN    AC,3             ; skip if billable, i.e inv. code = 1, 2  or 4
         JRST   NBIREQ                ; non-billable case
        JRST    BILREQ                ; billable case
 
NBIREQ: ; set reqval for non-billable (internal) user or customer requests
        ; note non-billable user or customer requests never need accounting
        ; approval
        TLO     AC1,R.INT             ; set internal
        SKIPL   RCOMNA-1(AC2)         ; skip if need sra app
         JRST   .+3
        TLO     AC1,R.NSRA
        JRST    NBIRE2                ; internal & sra app then need not exam.
        SKIPL   RCOMEX-1(AC2)         ; skip if need exam
         JRST   NBIRE2
        TLO     AC1,R.NEX
NBIRE2: TLNN    AC1,R.NEX!R.NSRA
         TLO    AC1,R.RDY             ; here means need not exam by any body
        JRST    RQVALD
 
BILREQ: ; set reqval for billable user or customer requests
        ; note billable user customer requests never need approval from sra
        SKIPL   RCOMAC-1(AC2)         ; skip if need acctg. app
         JRST   .+3
        TLNN    FLG,U.AP              ; skip if accounting submit the req.
         TLO    AC1,R.NACC
        SKIPL   RCOMEX-1(AC2)
         JRST   .+2
        TLO     AC1,R.NEX
        TLNN    AC1,R.NEX!R.NACC
         TLO    AC1,R.RDY             ; need not examine or review
RQVALD: HRR     AC1,MY.UUN            ; move in uun of originator
        MOVEM   AC1,REQVAL
        MOVE    AC,REQCOM
        ; the following code is set reqval for changing customer district
        ; request. Request is always set to be examined by resource. When
        ; approved, it will be set for ready for change - R.DCH
        CAIE    AC,^D21         ; skip if change cust. dist. req
         POPJ   P,
  ;     TLNN    FLG,U.AP        ; acct. submit this req.?
  ;      JRST   .+5
  ;     TLZ     AC1,R.RDY
  ;     TLO     AC1,R.DCH       ; ready for change cust. dist.
  ;     MOVEM   AC1,REQVAL
  ;     POPJ    P,
        TLZ     AC1,R.RDY  
        TLO     AC1,R.DCH       ; put into ready for cha. dist.
        MOVEM   AC1,REQVAL
        POPJ    P, 
 
 
; the following codes are old codes may deleted if USRRQQ and CUSRQQ both are
; tested through
; **************************************************************************
USBRQQ:
	SETZB	AC1,REQVAL	; initialize at zeros
	MOVE	AC2,REQCOM	; dispatcher index
	MOVE	AC,NMCOLN	; get colon word
	TLO	AC1,R.NEX	; set up needs examine
	TLNE	AC,BIL.CD	; skip if billable
	 JRST	[TLO	AC1,R.INT	; set internal
	 	 SKIPL	RCOMNA-1(AC2)	; skip if internal need sra app
		  JRST	USRRQ0		; sra approval not needed this cmd
		 TLO	AC1,R.NSRA	; set needs sra approval bit
		 TLZ	AC1,R.RDY!R.NEX	; reset ready to process, need examine
		 JRST	USRRQN]		; go get my.uun
USRRQ0:	SKIPL	RCOMEX-1(AC2)	; skip if needs exam
	 JRST	USRRQ1		; does not need exam
	TLO	AC1,R.NEX	; set needs examine
	TLZ	AC1,R.RDY!R.NSRA	; reset needs sra app, ready
	JRST	USRRQN
USRRQ1:	TLO	AC1,R.RDY	; here when no need sra app, no examine
	TLZ	AC1,R.NEX!R.NSRA
USRRQN:	HRR	AC1,MY.UUN	; move in uun of originator
	MOVEM	AC1,REQVAL
	POPJ	P,

CUCREQ:	; set up reqval for an existing customer request
;	if inv. code is already obtained, this routine may be called at CUCRQQ
	PUSHJ	P,GETACC               ; build accounting circuit
	 JRST	GETCMD
	PUSHJ	P,GCAREC               ; get accounting record
	 JRST	GETCMD
CUCRQQ:
	SETZB	AC1,REQVAL	; initialize at zeros
	MOVE	AC2,REQCOM	; dispatcher index
	MOVE	AC,ACINVC	; get invoice code
	TLO	AC1,R.NEX	; set up needs examine
	CAIN	AC,3      ; skip if billable, i.e. inv. code = 1, 2 or 4
	 JRST	[TLO	AC1,R.INT	; set internal
	 	 SKIPL	RCOMNA-1(AC2)	; skip if internal need sra app
		  JRST	CUSRQ0		; sra approval not needed this cmd
		 TLO	AC1,R.NSRA	; set needs sra approval bit
		 TLZ	AC1,R.RDY!R.NEX	; reset ready to process, need examine
		 JRST	CUSRQN]		; go get my.uun
CUSRQ0:	SKIPL	RCOMEX-1(AC2)	; skip if needs exam
	 JRST	CUSRQ1		; does not need exam
	TLO	AC1,R.NEX	; set needs examine
	TLZ	AC1,R.RDY!R.NSRA	; reset needs sra app, ready
	JRST	CUSRQN
CUSRQ1:	TLO	AC1,R.RDY	; here when no need sra app, no examine
	TLZ	AC1,R.NEX!R.NSRA
CUSRQN:	HRR	AC1,MY.UUN	; move in uun of originator
	MOVEM	AC1,REQVAL
	POPJ	P,

; needed are routines to determine the REQVAL values for new users
; and new customers.
; ***************************************************************************
LRHDR:	; list current request information
; output reqval bits and information input by conrd.
	TCR	(1)
	TYPSTR	([ASCIZ/Request :/],777,0,T.P0,N)
	TYPNUM	(REQNUM,D,0,T.P2)
	TYPSTR	([ASCIZ/Orig Usr:/],777,0,T.P0,N)
	TYPSTR	(RQUORG,L.UNM,0,T.P2)
        MOVE    AC,REQDAT
        CAIG    AC,^D84
         JRST   LRHDR0
	TYPSTR	([ASCIZ/Req Date:/],777,0,T.P0,N)
	TYPNUM	(REQDAT,D,0,T.P2)
LRHDR0: MOVE    AC,RQUORG
	CAMN	AC,[ASCII/     /]
	 JRST	LRHDR2
	TYPSTR	([ASCIZ/Orig Stat:/],777,0,T.P0,N)
	TYPSTR	(RQSORG,L.UNM,0,T.P2)
LRHDR2:	MOVE	AC,CONSTR
	CAMN	AC,[ASCII/     /]
	 JRST	LRHDR3
	TYPSTR	([ASCIZ/Cont at:/],777,0,T.P0,N)
	TYPSTR	(CONSTR,L.CON,0,T.P2)
LRHDR3:	MOVE	AC,SRAAPP
	CAMN	AC,[ASCII/     /]
	 JRST	LRHDR4
	TYPSTR	([ASCIZ/Approver:/],777,0,T.P0,N)
	TYPSTR	(SRAAPP,L.UNM,0,T.P2)
LRHDR4:	MOVE	AC,VALPRO
	CAMN	AC,[ASCII/     /]
	 JRST	LRHDR5
	TYPSTR	([ASCIZ/Val Pro:/],777,0,T.P0,N)
	TYPSTR	(VALPRO,L.UNM,0,T.P2)
LRHDR5:
	TYPSTR	([ASCIZ/Status:/],777,0,T.P0,N)
	MOVE	AC,REQVAL
	TLNN	AC,R.NEX
	 JRST	LRHDR6
	TYPSTR	([ASCIZ/Needs Examine by Validations/],777,0,T.P2)
LRHDR6:	MOVE	AC,REQVAL
	TLNN	AC,R.NSRA
	 JRST	LRHD61
	TYPSTR	([ASCIZ/Needs Approval by SRA/],777,0,T.P2)
LRHD61:	MOVE	AC,REQVAL
	TLNN	AC,R.NACC
	 JRST	LRHDR7
	TYPSTR	([ASCIZ/Needs Approval by Accounting/],777,0,T.P2)
LRHDR7:	MOVE	AC,REQVAL
	TLNN	AC,R.INT
	 JRST	LRHDR8
	TYPSTR	([ASCIZ/Non-Billable Request/],777,0,T.P2)
LRHDR8:	MOVE	AC,REQVAL
	TLNN	AC,R.HLD
	 JRST	LRHDR9
	TYPSTR	([ASCIZ/In Hold/],777,0,T.P2)
LRHDR9:	MOVE	AC,REQVAL
	TLNN	AC,R.CAN
	 JRST	LRHD10
	TYPSTR	([ASCIZ/Cancelled by SRA or Validations/],777,0,T.P2)
LRHD10:	MOVE	AC,REQVAL
	TLNN	AC,R.UCN
	 JRST	LRHD11
	TYPSTR	([ASCIZ/Cancelled/],777,0,T.P2)
LRHD11:	MOVE	AC,REQVAL
	TLNN	AC,R.ERR
	 JRST	LRHD12
	TYPSTR	([ASCIZ/Error -/],777,0,T.P2,N)
	SKIPG	REQERC		; skip if we have a code
	 JRST	[TCR	(1)
		 JRST	LRHD12]
	MOVE	AC1,REQERC
	MOVE	AC,RQERS(AC1)
	MOVEM	AC,NUM
	TYPSTR	(@NUM,777,1)
LRHD12:
	MOVE	AC,REQVAL
	TLNN	AC,R.RDY
	 JRST	LRH13A
	TYPSTR	([ASCIZ/Ready to process/],777,0,T.P2)
LRH13A:
	MOVE	AC,REQVAL
	TLNN	AC,R.DCH
	 JRST	LRHD13
	TYPSTR	([ASCIZ/Ready to process by Accounting/],777,0,T.P2)
LRHD13:
	MOVE	AC,REQVAL
	TLNN	AC,R.COM
	 JRST	LRHD14
	TYPSTR	([ASCIZ/Request Completed/],777,0,T.P2)
LRHD14:
	MOVE	AC,REQVAL
	TLNN	AC,R.LCK
	 JRST	LRHD15
	TYPSTR	([ASCIZ/Request Locked/],777,0,T.P2)
LRHD15:
	MOVE	AC,LPOST
	TLNE	AC,U.TOUT	; skip if not going to tout
	 MOVE	AC,LPOSF
	CAIL	AC,T.P0
	 PUSHJ	P,[TCR (1)
		   POPJ P,]
	TYPSTR	([ASCIZ/Command :/],777,0,T.P0,N)
	MOVE	AC1,REQCOM
	SKIPLE	AC1
	 CAILE	AC1,MAXRCM
	  JRST	LRHD16		; unknown command code
	MOVE	AC,RCOMDS-1(AC1)
	MOVEM	AC,REQTMP
	TYPSTR	(@REQTMP,777,0,T.P2)
	JRST	LRHD17
LRHD16:	TYPSTR	([ASCIZ/Unknown - Call Programmer/],777,0,T.P0,N)
LRHD17:
	POPJ	P,

INCON:	; input requestor's phone number or ontyme-ii name
	INSTR	([ASCIZ/Phone number or Ontyme-II name :/],CONSTR,L.CON)
	MOVE	AC,CONSTR
	CAMN	AC,[ASCII/     /]
	 JRST	INCON2
	JUMPE	AC,INCON2
	POPJ	P,
INCON2:	PUSHJ	P,INORNO
	JRST	INCON

CMDTYP:	; type a request
	TCR	(1)
	PUSHJ	P,GRNO
	 JRST	CMDTY3
	PUSHJ	P,CONRD		; read control and reqval
	SKIPN	REQVAL
	 JRST	CMDTY2
        PUSHJ   P,LRHDR         ; output control and reqval info
	TLO	FLG2,V.LSQ	; set listing flag
	REQINP	ON
	PUSHJ	P,REQDIS
	 JFCL
	REQINP	OFF
CMDTY2:
	PUSHJ	P,RELRQI
	JRST	CMDTYP
CMDTY3:
	TRO	FLG,U.OKAY
	POPJ	P,

GRNO:	; input request number from terminal
	INNUM	([ASCIZ/Request # :/],D)
	 JRST	GRNO1
	JUMPE	AC1,GRNO2
	CAILE	AC1,REQMAX
	 JRST	GRNO1
	MOVEM	AC1,REQNUM	; save request number
	AOS	0(P)
	POPJ	P,
GRNO1:	PUSHJ	P,INORNO
	JRST	GRNO
GRNO2:	MOVE	AC,CNVHLD
	CAME	AC,[ASCII/     /]
	 JRST	GRNO1
	POPJ	P,

GNRNO:	; get starting request number
	INNUM	([ASCIZ/Start with Request # :/],D)
	 JRST	GNRNO1
	JUMPE	AC1,GNRNO0
	CAILE	AC1,REQMAX
	 JRST	GNRNO1
	SOJ	AC1,
GNRNO0:	MOVEM	AC1,REQNUM
	POPJ	P,
GNRNO1:	PUSHJ	P,INORNO
	JRST	GNRNO
CMDAPP:	; approve internal requests
	TCR	(1)
	HRLZI	AC,V.EXQ	; setup for change mode (examine)
	MOVEM	AC,REQFLG
CMAPP0:
	TRZ	FLG2,V.1R
	GETYR	([ASCIZ/One request only ?/])
	 JRST	CMAPPB
CMAPP1:
	TRO	FLG2,V.1R
	PUSHJ	P,GRNO		; request number
	 JRST	CMAPPD
	PUSHJ	P,CONRD		; get header and reqval
	SKIPN	REQVAL
	 JRST	CMAPPD
	JRST	CMAPP3

CMAPPB:	PUSHJ	P,GNRNO		; starting request number
CMAPP2:
	HRLZI	AC,R.NSRA	; 1st condition
	MOVEM	AC,REQMSK	; save mask
	HRLZI	AC,R.NAC2!R.LCK	; not active flags, locked, in hold
	MOVEM	AC,REQMS2	; save 2nd mask
	MOVEI	AC,REQTS3	; pick test 3
	PUSHJ	P,GNMREQ	; locate the request
	 JRST	CMAPPD
	PUSHJ	P,CONRD
CMAPP3:
	PUSHJ	P,CHLOCK	; check if locked
	 JRST	CMAPP4		; locked, cannot do this request
	PUSHJ	P,LRHDR
	TLO	FLG2,V.EXQ 	; set v.exq
	REQINP	ON
	PUSHJ	P,REQDIS
	 JFCL
	REQINP	OFF
	GETYR	([ASCIZ/Approved ?/])
	 JRST	[MOVE	AC,REQVAL
		 JRST	CAPP3B]
	DMOVE	AC,TATALE	; set up sra approver
	DMOVEM	AC,SRAAPP
	MOVE	AC,TATALE+2
	MOVEM	AC,SRAAPP+2
	PUSHJ	P,CONHDR
	SETZM	SRAAPP		; clear sra approver
	MOVE	AC,REQVAL
	TLZ	AC,R.NSRA      	; turn off needs sra
	TLO     AC,R.RDY        ; turn on ready to process
CAPP3B:	TLZ	AC,R.LCK	; unlock
	MOVEM	AC,REQVAL
	PUSHJ	P,RELRQO
CMAPP4:
	PUSHJ	P,RELRQI
	TRNN	FLG2,V.1R	; skip if one request only
	 JRST	CMAPP2		; do next request if any
CMAPPD:	; done
	TRO	FLG,U.OKAY
	POPJ	P,
CMDREV:	; approve billable request by accounting
	TCR	(1)
CMREV0:
	TRZ	FLG2,V.1R
	GETYR	([ASCIZ/One request only ?/])
	 JRST	CMREVB
CMREV1:
	TRO	FLG2,V.1R
	PUSHJ	P,GRNO		; request number
	 JRST	CMREVD
	PUSHJ	P,CONRD		; get header and reqval
	SKIPN	REQVAL
	 JRST	CMREVD
	JRST	CMREV3

CMREVB:	PUSHJ	P,GNRNO		; starting request number
CMREV2:
	HRLZI	AC,R.NACC       ; 1st condition
	MOVEM	AC,REQMSK	; save mask
	HRLZI	AC,R.NAC2!R.LCK	; not active flags, locked, in hold
	MOVEM	AC,REQMS2	; save 2nd mask
	MOVEI	AC,REQTS3	; pick test 3
	PUSHJ	P,GNMREQ	; locate the request
	 JRST	CMREVD
	PUSHJ	P,CONRD
CMREV3:
        PUSHJ   P,CHKCOM        ; check if complete
         JRST   CMREV4          ; complete, can't review again
        PUSHJ   P,CHKREV        ; check if need reviewed
         JRST   CMREV4          ; no
	PUSHJ	P,CHLOCK	; check if locked
	 JRST	CMREV4		; locked, cannot do this request
	PUSHJ	P,LRHDR
	TLO	FLG2,V.EXQ      ; set v.exq for examine
        TLO     FLG,U.IMM       ; turn on imm. mode for using exmmac
	REQINP	ON
	PUSHJ	P,REQDIS
	 JFCL
	REQINP	OFF
        TLZ     FLG,U.IMM       ; turn off imm. mode
	  ;  DMOVE	AC,TATALE	; set up acctg. approver
	DMOVE	AC,[ASCIZ/JUNE THUM/]  ; set June Thum
	DMOVEM	AC,SRAAPP
	MOVE	AC,TATALE+2
	MOVEM	AC,SRAAPP+2
        TLO     FLG,U.IMM       ; turn on imm. mode for using CONHDR
	PUSHJ	P,CONHDR
        TLZ     FLG,U.IMM       ; turn off imm. mode
	SETZM	SRAAPP		; clear acctg approver
	GETYR	([ASCIZ/Approved ?/])
	 JRST	[MOVE	AC,REQVAL
		 JRST	CREV3B]
	MOVE	AC,REQVAL
	TLZ	AC,R.NACC      	; approved, turn off need acct. review bit
        TLNE    AC,R.NEX        ; skip if need not examine
         JRST   CREV3B
        TLO     AC,R.RDY        ; ready to process except change cus. dist.
	MOVE	AC1,REQCOM	; get command index
        CAIE    AC1,^D21        ; skip if change cust. district request
         JRST   CREV3B          
        TLO     AC,R.DCH        ; turn on ready chg. cus. dist. by acct. bit
        TLZ     AC,R.RDY        ; change cust. dist. only process by acct.
CREV3B:	TLZ	AC,R.LCK	; unlock
	MOVEM	AC,REQVAL
	PUSHJ	P,RELRQO
CMREV4:
	PUSHJ	P,RELRQI
	TRNN	FLG2,V.1R	; skip if one request only
	 JRST	CMREV2		; do next request if any
CMREVD:	; done
	TRO	FLG,U.OKAY
	POPJ	P,
CMDEXM:	; Examine requests
	TCR	(1)
CMEXM0:
	TRZ	FLG2,V.1R
	GETYR	([ASCIZ/One request only ?/])
	 JRST	CMEXMB
CMEXM1:
	TRO	FLG2,V.1R
	PUSHJ	P,GRNO		; request number
	 JRST	CMEXMD
	PUSHJ	P,CONRD		; get header and reqval
	SKIPN	REQVAL
	 JRST	CMEXMD
	MOVE	AC,REQVAL
        TLNE    AC,R.NACC             ; skip if need not acctg. approve
         JRST   CMEXMN
	TLNN	AC,R.NSRA
	 JRST	CMEXM3
	TYPSTR	([ASCIZ/** Request SHOULD be approved by SRA **/],777,0,T.P0)
	JRST	CMEXM3

CMEXMB:	PUSHJ	P,GNRNO		; starting request number
CMEXM2:
	HRLZI	AC,R.NEX	; 1st condition
	MOVEM	AC,REQMSK	; save mask
	HRLZI	AC,R.NAC2!R.LCK	; not active flags
	MOVEM	AC,REQMS2	; save 2nd mask
	MOVEI	AC,REQTS3	; pick test 3
	PUSHJ	P,GNMREQ	; locate the request
	 JRST	CMEXMD
	PUSHJ	P,CONRD
        MOVE    AC,REQVAL
        TLNN    AC,R.NACC       ; skip if need acct. review
         JRST   CMEXM3
        TCR     (1)
        TYPSTR  ([ASCIZ/Request/],777,0,T.P0,N)
        TYPNUM  (REQNUM,D,1,0,N)
        TYPSTR  ([ASCIZ/MUST be reviewed by Acctg. first./],777,1)
        TCR     (1)
        MOVE    AC,REQVAL
        JRST    CEXM3B
CMEXM3:
        PUSHJ   P,CHKCOM        ; check if complete
         JRST   CMEXM4
        PUSHJ   P,CHKEXA        ; check if need examined
         JRST   CMEXM4
	PUSHJ	P,CHLOCK	; check if locked
	 JRST	CMEXM4
	PUSHJ	P,LRHDR
	TLO	FLG2,V.EXQ	; set v.exq (examine)
	REQINP	ON
	PUSHJ	P,REQDIS
	 JFCL
	REQINP	OFF
	GETYR	([ASCIZ/Ready to process ?/])
	 JRST	[MOVE	AC,REQVAL
		 JRST	CEXM3B]
	DMOVE	AC,TATALE	; set up val processor 
	DMOVEM	AC,VALPRO
	MOVE	AC,TATALE+2
	MOVEM	AC,VALPRO+2
	SETZM	REQERC		; reset error code
	PUSHJ	P,CONHDR
	SETZM	VALPRO		; clear processor
	MOVE	AC,REQVAL
	TLZ	AC,R.NSRA!R.NEX!R.ERR!R.COM!R.CAN!R.UCN!R.HLD	; reset flags
	TLO	AC,R.RDY	; turn on ready to process
CEXM3B:	TLZ	AC,R.LCK	; unlock
	MOVEM	AC,REQVAL
	PUSHJ	P,RELRQO
CMEXM4:
	PUSHJ	P,RELRQI
	TRNN	FLG2,V.1R	; skip if one request only
	 JRST	CMEXM2		; do next request if any
CMEXMD:	; done
	TRO	FLG,U.OKAY
	POPJ	P,
 
CMEXMN:
        TYPSTR  ([ASCIZ/** Request MUST be reviewed by Acctg. **/],777,0,T.P0)
        PUSHJ   P,RELRQI              ; close input file
        JRST    GETCMD
CMDPRO:	; process requests
	TCR	(1)
CMPRO0:
	TRZ	FLG2,V.1R
	GETYR	([ASCIZ/One request only ?/])
	 JRST	CMPROB
CMPRO1:
	TRO	FLG2,V.1R	; set single request flag
	PUSHJ	P,GRNO		; get request number
	 JRST	CMPROD
	PUSHJ	P,CONRD		; get hdr and reqval
	SKIPN	REQVAL
	 JRST	CMPROD		; zero request
	MOVE	AC,REQVAL
	TLNE	AC,R.RDY	; skip if not ready to process
	 JRST	CMPRO3
	TYPSTR	([ASCIZ/** Request not ready to process **/])
	POPJ	P,

CMPROB:	PUSHJ	P,GNRNO		; get starting request number
CMPRO2:
	HRLZI	AC,R.RDY	; 1st condition
	MOVEM	AC,REQMSK
	HRLZI	AC,R.NAC2!R.LCK	; 2nd condition
	MOVEM	AC,REQMS2
	MOVEI	AC,REQTS3	; pick test 3
	PUSHJ	P,GNMREQ	; locate request
	 JRST	CMPROD
	PUSHJ	P,CONRD		; got a request, read header
CMPRO3:
	PUSHJ	P,CHLOCK	; lock and skip if not locked
	 JRST	CMPRO6
	PUSHJ	P,LRHDR		; output header
	TLO	FLG2,V.PRQ	; set processing flag
	TRZ	FLG,U.OKAY	; reset okay flag
	REQINP	ON
	PUSHJ	P,REQDIS
	 JFCL
	REQINP	OFF
	DMOVE	AC,TATALE
	DMOVEM	AC,VALPRO
	MOVE	AC,TATALE+2
	MOVEM	AC,VALPRO+2
	TRNN	FLG,U.OKAY	; skip if okay flag set
	 JRST	CMPRO4
	MOVE	AC,REQVAL
	TLO	AC,R.COM	; set completed flag
	TLZ	AC,R.RDY!R.HLD!R.CAN!R.UCN!R.ERR!R.LCK ;reset flags
	MOVEM	AC,REQVAL
	TYPSTR	([ASCIZ/Request completed and answered./])
	JRST	CMPRO5
CMPRO4:	; error during processing
	MOVE	AC,REQVAL
	TLO	AC,R.ERR!R.NEX	; turn on error and need examine
	TLZ	AC,R.RDY!R.LCK	; turn off ready and unlock
	MOVEM	AC,REQVAL
	SETZM	REQERC		; set error code to zero
	TYPSTR	([ASCIZ/Request not complete - not answered./])
CMPRO5:
	PUSHJ	P,CONHDR
	PUSHJ	P,RELRQO
CMPRO6:	PUSHJ	P,RELRQI
	TRNN	FLG2,V.1R	; skip if one request only
	 JRST	CMPRO2		; do next request

CMPROD:	; done
	TRO	FLG,U.OKAY
	POPJ	P,
CMDPSD:	; process change customer district
        TLO     FLG,U.IMM       ; turn on imm. mode
        TLO     FLG,U.PRV       ; turn on priv. bit for chg dist on 370 lud
	TCR	(1)
CMPSD0:
	TRZ	FLG2,V.1R
	GETYR	([ASCIZ/One request only ?/])
	 JRST	CMPSDB
CMPSD1:
	TRO	FLG2,V.1R	; set single request flag
	PUSHJ	P,GRNO		; get request number
	 JRST	CMPSDD
	PUSHJ	P,CONRD		; get hdr and reqval
	SKIPN	REQVAL
	 JRST	CMPSDD		; zero request
        MOVE    AC,REQVAL
	TLNE	AC,R.DCH	; skip if not ready to process
	 JRST	CMPSD3
	TYPSTR	([ASCIZ/** Request not ready to process **/])
        TLZ     FLG,U.IMM            ; turn off imm. mode
        TLZ     FLG,U.PRV            ; turn off priv. bit
	POPJ	P,

CMPSDB:	PUSHJ	P,GNRNO		; get starting request number
CMPSD2:
	HRLZI	AC,R.DCH	; 1st condition
	MOVEM	AC,REQMSK
	HRLZI	AC,R.NAC2!R.LCK	; 2nd condition
	MOVEM	AC,REQMS2
	MOVEI	AC,REQTS3	; pick test 3
	PUSHJ	P,GNMREQ	; locate request
	 JRST	CMPSDD
	PUSHJ	P,CONRD		; got a request, read header
CMPSD3:
	PUSHJ	P,CHLOCK	; lock and skip if not locked
	 JRST	CMPSD6
	PUSHJ	P,LRHDR		; output header
	TLO	FLG2,V.PRQ	; set processing flag
	TRZ	FLG,U.OKAY	; reset okay flag
	REQINP	ON
	PUSHJ	P,REQDIS
	 JFCL
	REQINP	OFF
	DMOVE	AC,TATALE
	DMOVEM	AC,VALPRO
	MOVE	AC,TATALE+2
	MOVEM	AC,VALPRO+2
	TRNN	FLG,U.OKAY	; skip if okay flag set
	 JRST	CMPSD4
	MOVE	AC,REQVAL
	TLO	AC,R.COM	; set completed flag
	TLZ	AC,R.DCH!R.HLD!R.CAN!R.UCN!R.ERR!R.LCK ;reset flags
	MOVEM	AC,REQVAL
	TYPSTR	([ASCIZ/Request completed and answered./])
	JRST	CMPSD5
CMPSD4:	; partial complete or error during processing
        MOVE    AC,LUDNUM
        CAIN    AC,^D9999       ; partial complete?
         JRST   CMPSD5          ; yes
	MOVE	AC,REQVAL
	TLO	AC,R.ERR!R.NACC  ; turn on error and need reviewed
	TLZ	AC,R.LCK         ; unlock
	MOVEM	AC,REQVAL
	SETZM	REQERC		; set error code to zero
	TYPSTR	([ASCIZ/Request not complete - not answered./])
CMPSD5:
	PUSHJ	P,CONHDR
	PUSHJ	P,RELRQO
CMPSD6:	PUSHJ	P,RELRQI
	TRNN	FLG2,V.1R	; skip if one request only
	 JRST	CMPSD2		; do next request

CMPSDD:	; done
	TRO	FLG,U.OKAY
        TLZ     FLG,U.IMM            ; turn off imm. mode
	POPJ	P,
CMDHOL:	; hold a request
	TCR	(1)
	PUSHJ	P,GRNO		; get request
	 JRST	CMHOLD
	PUSHJ	P,CONRD
	SKIPN	REQVAL
	 JRST	CMHOLD
	PUSHJ	P,CHLOCK	; lock and skip if not locked
	 JRST	CMHOLD
	PUSHJ	P,LRHDR
	GETYR	([ASCIZ/Hold - OK ?/])
	 JRST	[MOVE	AC,REQVAL
		 JRST	CMHOL1]
	MOVE	AC,REQVAL
	TLO	AC,R.HLD
        TLZ     AC,R.NEX              ; turn off need examine while in hold
CMHOL1:	TLZ	AC,R.LCK
	MOVEM	AC,REQVAL
	PUSHJ	P,RELRQO
CMHOLD:	PUSHJ	P,RELRQI	
	TRO	FLG,U.OKAY
	POPJ	P,
CMDUNH:	; unhold a request
	TCR	(1)
	PUSHJ	P,GRNO		; get request
	 JRST	CMUNHD
	PUSHJ	P,CONRD
	SKIPN	REQVAL
	 JRST	CMUNHD
	PUSHJ	P,CHLOCK	; lock and skip if not already locked
	 JRST	CMUNHD
	PUSHJ	P,LRHDR
	GETYR	([ASCIZ/Unhold - OK ?/])
	 JRST	[MOVE	AC,REQVAL
		 JRST	CMUNH1]
	MOVE	AC,REQVAL
	TLZ	AC,R.HLD	; unhold
        TLO     AC,R.NEX        ; turn on need examine flag
CMUNH1:	TLZ	AC,R.LCK	; unlock
	MOVEM	AC,REQVAL
	PUSHJ	P,RELRQO
CMUNHD:	PUSHJ	P,RELRQI	
	TRO	FLG,U.OKAY
	POPJ	P,
CMDUNL:	; unlock a request
	TCR	(1)
	PUSHJ	P,GRNO		; get number
	 JRST	CMUNLD
	PUSHJ	P,CONRD
	SKIPN	REQVAL
	 JRST	CMUNLD
	PUSHJ	P,LRHDR
	MOVE	AC,REQVAL
	TLNN	AC,R.LCK	; skip if locked
	 JRST	CMUNLD
	GETYR	([ASCIZ/UnLock - are you sure ?/])
	 JRST	CMUNLD
	MOVE	AC,REQVAL
	TLZ	AC,R.LCK
	MOVEM	AC,REQVAL
	PUSHJ	P,RELRQO
CMUNLD: PUSHJ	P,RELRQI
	TRO	FLG,U.OKAY
	POPJ	P,
CMDANS:	; answer a request
	TCR	(1)
	PUSHJ	P,GRNO
	 JRST	CMANSD
	PUSHJ	P,CONRD
	SKIPN	REQVAL
	 JRST	CMANSD
	PUSHJ	P,CHLOCK	; lock and skip if not already locked
	 JRST	CMANSD
	PUSHJ	P,LRHDR
	GETYR	([ASCIZ/Error ?/])
	 JRST	CMANS2
	PUSHJ	P,GREQEC	; get error code
	MOVE	AC,REQVAL
	TLO	AC,R.ERR!R.CAN	; set error and cancelled
	TLZ	AC,R.RDY!R.COM!R.NEX!R.NSRA!R.LCK!R.NACC!R.DCH ; reset flags
	MOVEM	AC,REQVAL
	JRST	CMANS3
CMANS2:	MOVE	AC,REQVAL
	TLZ	AC,R.ERR!R.CAN!R.NEX!R.NSRA!R.HLD!R.RDY!R.LCK!R.NACC!R.DCH
	TLO	AC,R.COM
	MOVEM	AC,REQVAL
CMANS3:
	DMOVE	AC,TATALE
	DMOVEM	AC,VALPRO
	MOVE	AC,TATALE+2
	MOVEM	AC,VALPRO+2
	PUSHJ	P,CONHDR	; rewrite hdr
	SETZM	VALPRO
	PUSHJ	P,RELRQO
CMANSD:	PUSHJ	P,RELRQI
	TRO	FLG,U.OKAY
	POPJ	P,

GREQEC:
	INNUM	([ASCIZ/Error Code :/],D)
	 JRST	GRQEC2
	CAILE	AC1,NRQERS	; skip if le max
	 JRST	GRQEC2
	JUMPE	AC1,GRQEC2
	MOVEM	AC1,REQERC	; save it
	MOVE	AC,RQERS(AC1)
	MOVEM	AC,NUM
	TYPSTR	(@NUM)
	GETYR	([ASCIZ/Ok ?/])
	 JRST	GREQEC
	POPJ	P,
GRQEC2:
	PUSHJ	P,INORNO
	JRST	GREQEC
CMDASK:	; ask about a request (for non-privileged users)
	TCR	(1)
	PUSHJ	P,GRNO
	 JRST	CMASK1
	PUSHJ	P,CONRD
	SKIPN	REQVAL
	 JRST	CMASK2
	TLNE	FLG,U.PRV!U.AP          ; skip if not privileged nor acct.
	 JRST	CMASK0			; do it if he's privileged
	HRRZ	AC,REQVAL		; get RH(reqval)
	CAME	AC,MY.UUN		; skip if originated by me
	 JRST	CMASK2
CMASK0:
	PUSHJ	P,LRHDR
CMASK1:	PUSHJ	P,RELRQI
	TRO	FLG,U.OKAY
        MOVE    AC,REQCOM
        CAIE    AC,^D52               ; skip if new customer command
         POPJ   P,
        MOVE    AC,REQVAL
        TLNN    AC,R.COM              ; skip if request completed
         POPJ   P,
        REQINN  (DAT,D)               ; load cid from data file
         JFCL
        MOVEM   AC1,CUSNUM
        TYPSTR  ([ASCIZ/Cid:/],777,0,T.P0,N)
        TYPNUM  (CUSNUM,D,0,T.P2)
        PUSHJ   P,RELRQI              ; close input file
	POPJ	P,
CMASK2:	; no access
	TYPSTR	([ASCIZ/No access./])
	PUSHJ   P,RELRQI
        TRO     FLG,U.OKAY
        POPJ    P,
CMDSCN:	; scan reques.dir for requests entered by MY.UUN
	TCR	(1)
	MOVEI	AC,REQTS4	; test four
	MOVEM	AC,REQPAD

CMSCN2:
	SETZM	REQNUM
	PUSHJ	P,GETODF	; output destination
	TCR	(1)
	TYPSNL	([ASCIZ/Request numbers :/])
	TCRNL	(1)
	TYPSLO	([ASCIZ/Starting List Output./])
CMSCN3:
	MOVE	AC,REQPAD
	PUSHJ	P,GNMREQ
	 JRST	CMSCND
        MOVE    AC,REQNUM
        CAIN    AC,^D39
         JRST   CMSCN3
        CAIN    AC,^D5090
         JRST   CMSCN3
	LISNUM	(REQNUM,D,0,T.P0)	; output request number
	JRST	CMSCN3

CMSCND:
	TRNE	FLG,U.LFO	; skip if not list output
	 PUSHJ	P,CLSODF
	TRO	FLG,U.OKAY
	POPJ	P,
	DEFINE NE1 <
	X UNHOL,3,CMDNUN,U.PRV,-1
	X ANSWE,2,CMDNAN,U.PRV,-1
	X APPRO,2,CMDNAP,U.PRV,-1
	X EXAMI,1,CMDNEX,U.PRV,-1
	X PROCE,1,CMDNPR,U.PRV,-1
	X UNLOC,3,CMDNUL,U.PRV,-1
        X CHGDI,1,CMDNCD,U.WC,-1
        X REVIE,1,CMDNRE,U.AP!U.WC,-1
>
	SUBCOM	([ASCIZ/Needs :/],NEE,NE1)
CMDNUN:	; needs unhold
	TCR	(1)
	HRLZI	AC,R.HLD	; hold bit set
	MOVEM	AC,REQMSK
	MOVEI	AC,REQTS1	; test one
	MOVEM	AC,REQPAD
	JRST	CMSCN2

CMDNAN:	; needs answer
	TCR	(1)
	HRLZI	AC,R.ERR	; error bit set
	MOVEM	REQMSK
CMNAN2:	HRLZI	AC,R.CAN!R.UCN	; cancelled
	MOVEM	AC,REQMS2	; and set of conditions
        MOVE    AC1,NUM8        ; load in the flag
        CAIE    AC1,1           ; skip if need examine
         JRST   CMNAN3
        HRLZI   AC,R.NACC!R.CAN!R.UCN
        MOVEM   AC,REQMS2
        SETZM   NUM8
CMNAN3: MOVEI   AC,REQTS3       ; test three (1st true, 2nd false)
	MOVEM	AC,REQPAD
	JRST	CMSCN2

CMDNAP:	; needs approval
	TCR	(1)
	HRLZI	AC,R.NSRA
	MOVEM	AC,REQMSK
	JRST	CMNAN2

CMDNRE:	; needs approval by acctg.
	TCR	(1)
	HRLZI	AC,R.NACC
	MOVEM	AC,REQMSK
	JRST	CMNAN2

CMDNEX:	; needs examine, only show those either been approved by acctg.
        ; or do not need acctg. to approve. In other words, those pending
        ; for acctg. to approve will not be shown.
	TCR	(1)
        MOVEI   AC1,1
        MOVEM   AC1,NUM8              ; set the flag
	HRLZI	AC,R.NEX
	MOVEM	AC,REQMSK
	JRST	CMNAN2

CMDNPR:	; needs process
	TCR	(1)
	HRLZI	AC,R.RDY
	MOVEM	AC,REQMSK
	JRST	CMNAN2

CMDNCD:	; needs process change customer district
	TCR	(1)
	HRLZI	AC,R.DCH
	MOVEM	AC,REQMSK
	JRST	CMNAN2

CMDNUL:	 ; needs unlock
	TCR	(1)
	HRLZI	AC,R.LCK
	MOVEM	AC,REQMSK
	MOVEI	AC,REQTS1
	MOVEM	AC,REQPAD
	JRST	CMSCN2
CMDCAN:	; cancel request for originating user only, priv users use answer
	TCR	(1)
	PUSHJ	P,GRNO
	 JRST	CMCAN1
	PUSHJ	P,CONRD
	SKIPN	REQVAL
	 JRST	CMCAN2
	HRRZ	AC,REQVAL
	CAME	AC,MY.UUN	; skip if my request
	 JRST	CMCAN2
	MOVE	AC,REQVAL
	TLNE	AC,R.COM	; skip if not completed
	 JRST	CMCAN3
	PUSHJ	P,LRHDR
	GETYR	([ASCIZ/Cancel - Ok ?/])
	 JRST	CMCAN1
	MOVE	AC,REQVAL
	TLZ	AC,R.RDY!R.NEX!R.HLD!R.NSRA!R.NACC
	TLO	AC,R.UCN	; set cancelled by owner
	MOVEM	AC,REQVAL
	PUSHJ	P,CONHDR
	PUSHJ	P,RELRQO
CMCAN1:
	PUSHJ	P,RELRQI
	TRO	FLG,U.OKAY
	POPJ	P,
CMCAN2:	TYPSTR	([ASCIZ/No access./])
	JRST	CMCAN1
CMCAN3:	TYPSTR	([ASCIZ/Too late - request completed./])
	JRST	CMCAN1
V]