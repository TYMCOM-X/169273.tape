SUBTTL ADDCOM - add commands
DEFINE ADD1 <
	X USER,1,CMDAUS,-1,-1	      ; add user 
	X MDISK,1,CMDAMD,-1,-1	      ; add mdisk
	; X TFSMD,2,CMDATF,U.PRV,-1     ; add tfsmdisk
	X LINK,1,CMDALI,-1,-1         ; add link
	X TIMER,2,CMDATI,U.PRV,-1     ; add timer
	X FREE,1,CMDAFR,U.PRV,-1      ; add free format mdisk
        X CUSTO,1,CMDACS,-1,-1        ; add customer
 >

	SUBCOM	([ASCIZ/Add :/],ADD,ADD1)
DEFINE AUS1 <
	X NETCL,1,CMDAUC,U.WC!U.NET,-1     ; add user netclass
	X HOST,1,CMDAUH,-1,-1               ; add user host
 >

	SUBCOM	([ASCIZ/Add User :/],AUS,AUS1)
CMDAMD: ; add midsk 
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE AMDI <
	X	(HST1OT,GETH37,RWH37)
	X	(NAMOUP,GETUSR,RWUSR)
	X	(MDIOUT,GE1MDI,RWMDI)
	X	(CYLOUT,GETCYL,RWCYL)
        X       (GRPOUT,GETGRP,RWGRP,AC,-1,U.PRV)  ; only priv may set pack
	X	(ST1OUT,GETST1,RWST1,MFLAG,1)
	X	(ST2OUT,GETST2,RWST2,MFLAG,1)
	X	(ST3OUT,GETST3,RWST3,MFLAG,1)
	X	(ST4OUT,GETST4,RWST4,MFLAG,1)
	X	(ST5OUT,GETST5,RWST5,MFLAG,1)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (AMD,AMDI,^D44,USRRQQ)

; code for add mdisk starts here, only immediate mode and PROCESS
; can enter
 
        SKIPN   PCKG
         JRST   ADMSK2
        SNDBYT  (OLDPRT,\B.LCOM,SPKLUD,I)
        SNDSTR  (AC,L.PKGP,PCKG)
        PUSHJ   P,OLDA
         JRST   AMDIE1
        JRST    ADMSK2
ADMSK1:
        SNDBYT  (OLDPRT,\B.LCOM,SAPLUD,I)
        PUSHJ   P,OLDA
         JRST   AMDIE1
        ; set pack done, now start to add mdisk
ADMSK2: SNDBYT  (OLDPRT,\B.LCOM,AMDLUD,I)       ; add mdisk
        SNDSTR  (AC,L.UNM3,UNMSPC)
        SNDBYT  (AC,\B.FS,FS)         ; for padding only
	SNDSTR	(AC,B.MDI,MDISK)
        SNDBYT  (AC,\B.CYL,CYL)
        MOVE    AC1,MFLAG
        CAIE    AC1,1                 ; skip if mdisk addrs is 191
         JRST   AMDDNE
        SNDSTR  (OLDPRT,L.ST,ST1)
        SNDSTR  (AC,L.ST,ST2)
        SNDSTR  (AC,L.ST,ST3)
        SNDSTR  (AC,L.ST,ST4)
        SNDSTR  (AC,L.ST,ST5)
        SNDBYT  (AC,1,CTRLD)          ; send control-d
        SNDSTR  (AC,^D119,ST3)        ; padding 119 chars.
AMDDNE: PUSHJ   P,OLDA
	 JRST	AMDIE2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/ADD/)
	 JRST	ADMDI4
	TTFSTR	([ASCIZ/Add Mdisk/])
	PUSHJ	P,STDCHD
	PUSHJ	P,RELTTF
ADMDI4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	ADMDID			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	ADMDID
	JRST	AMDST2			; ABRV'ST2 is the menu output section

ADMDID: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

AMDIE1:	; error during set pack
	TYPSTR	([ASCIZ/Error during Set Pack./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	AMDIE3

AMDIE2:	; error during add mdisk
	TYPSTR	([ASCIZ/Error during Add Mdisk./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	AMDIE3

AMDIE3:	; after error, see if we can give him another chance
        MOVE    AC,SIXUNM
        CAMN    AC,[SIXBIT/VALADM/]   ; skip if not run by VALADM1 (army corp)
         JRST   GETNON                ; for army corp. then waste rest of input
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	AMDST2

; end of code for add mdisk
 
GE1MDI: ; get mdisk address and set mflag
        SETZM   MFLAG
        INSTR   ([ASCIZ/Mdisk Addrs :/],MDISK,B.MDI)
        MOVE    AC,MDISK
        CAME    AC,[ASCIZ/191  /]
         POPJ   P,
        MOVEI   AC,1                  ; if mdisk = 191 then move 1 to mflag
        MOVEM   AC,MFLAG
        POPJ    P,
 
 
ST1OUT:
        TYPSTR  ([ASCIZ/Street (1st) :/],777,0,T.P0,N)
        TYPSTR  (ST1,L.ST,0,T.P2)
        POPJ    P,
 
GETST1:
        INSTR   ([ASCIZ/Street (1st) :/],ST1,L.ST)
        POPJ    P,
 
RWST1:
        REQOUT  (REQ,ST1,L.ST)
        POPJ    P,
 
ST2OUT:
        TYPSTR  ([ASCIZ/Street (2nd) :/],777,0,T.P0,N)
        TYPSTR  (ST2,L.ST,0,T.P2)
        POPJ    P,
 
GETST2:
        INSTR   ([ASCIZ/Street (2nd) :/],ST2,L.ST)
        POPJ    P,
 
RWST2:
        REQOUT  (REQ,ST2,L.ST)
        POPJ    P,
 
ST5OUT:
        TYPSTR  ([ASCIZ/Country :/],777,0,T.P0,N)
        TYPSTR  (ST5,L.ST,0,T.P2)
        POPJ    P,
 
GETST5:
        INSTR   ([ASCIZ/Country :/],ST5,L.ST)
        POPJ    P,
 
RWST5:
        REQOUT  (REQ,ST5,L.ST)
        POPJ    P,
 
ST3OUT:
        TYPSTR  ([ASCIZ/City :/],777,0,T.P0,N)
        TYPSTR  (ST3,L.ST,0,T.P2)
        POPJ    P,
 
GETST3:
        INSTR   ([ASCIZ/City :/],ST3,L.ST)
        POPJ    P,
 
RWST3:
        REQOUT  (REQ,ST3,L.ST)
        POPJ    P,
 
ST4OUT:
        TYPSTR  ([ASCIZ/State and Zip :/],777,0,T.P0,N)
        TYPSTR  (ST4,L.ST,0,T.P2)
        POPJ    P,
 
GETST4:
        INSTR   ([ASCIZ/State and Zip :/],ST4,L.ST)
        POPJ    P,
 
RWST4:
        REQOUT  (REQ,ST4,L.ST)
        POPJ    P,
CMDATF: ; add tfsmdisk
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE ATFS <
        X       (HST1OT,GETH37,RWH37)
	X	(NAMOUP,GETUSR,RWUSR)
	X	(MDIOUT,GE1MDI,RWMDI)
	X	(CYLOUT,GETCYL,RWCYL)
	X	(ST1OUT,GETST1,RWST1,MFLAG,1)
	X	(ST2OUT,GETST2,RWST2,MFLAG,1)
	X	(ST3OUT,GETST3,RWST3,MFLAG,1)
	X	(ST4OUT,GETST4,RWST4,MFLAG,1)
	X	(ST5OUT,GETST5,RWST5,MFLAG,1)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (ATF,ATFS,^D45,USRRQQ)

; code for add tfsmdisk starts here, only immediate mode and PROCESS
; can enter
        SNDBYT  (OLDPRT,\B.LCOM,ATFLUD,I)       ; add tfsmdisk
        SNDSTR  (AC,L.UNM3,UNMSPC)
        SNDBYT  (AC,\B.FS,FS)         ; for padding only
	SNDSTR	(AC,B.MDI,MDISK)
        SNDBYT  (AC,\B.CYL,CYL)
        MOVE    AC1,MFLAG
        CAIE    AC1,1                 ; skip if mdisk addrs is 191
         JRST   ATFDNE
        SNDSTR  (OLDPRT,L.ST,ST1)
        SNDSTR  (AC,L.ST,ST2)
        SNDSTR  (AC,L.ST,ST3)
        SNDSTR  (AC,L.ST,ST4)
        SNDSTR  (AC,L.ST,ST5)
        SNDBYT  (AC,1,CTRLD)          ; send control-d
        SNDSTR  (AC,^D119,ST3)        ; padding 119 chars.
ATFDNE: PUSHJ   P,OLDA
	 JRST	ATFSE2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/ADD/)
	 JRST	ADTFS4
	TTFSTR	([ASCIZ/Add TFSmdisk/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
ADTFS4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	ADTFSD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	ADTFSD
	JRST	ATFST2			; ABRV'ST2 is the menu output section

ADTFSD: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

ATFSE2:	; error during add tfsmdisk
	TYPSTR	([ASCIZ/Error during Add TFSmdisk./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	ATFSE3

ATFSE3:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	ATFST2

; end of code for add tfsmdisk
CMDALI: ; add link
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE ALIN <
	X	(HST1OT,GETL37,RWH37)
	X	(NAMOUP,GEOUSR,RWUSR)
	X	(MDIOUT,GETMDI,RWMDI)
	X	(LNUOUT,GETLNU,RWNNM)
	X	(LNDOUT,GETLND,RWNMD)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (ALI,ALIN,^D46,USRREQ)

; code for add link starts here, only immediate mode and PROCESS
; can enter
        SNDBYT  (OLDPRT,\B.LCOM,ALNLUD,I)       ; add link
        SNDSTR  (AC,L.UNM3,UNMSPC)
	SNDSTR	(AC,B.MDI,MDISK)
        SNDSTR  (AC,L.UNM3,NNMSPC)
        SNDSTR  (AC,B.MDI,NMDSK)
        PUSHJ   P,OLDA
         JRST   ALINE2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/ADD/)
	 JRST	ADLIN4
	TTFSTR	([ASCIZ/Add Link/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
ADLIN4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	ADLIND			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	ADLIND
	JRST	ALIST2			; ABRV'ST2 is the menu output section

ADLIND: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

ALINE2:	; error during add link
	TYPSTR	([ASCIZ/Error during Add Link./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	ALINE3

ALINE3:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	ALIST2

; end of code for add link
 
LNDOUT:
        TYPSTR  ([ASCIZ/Mdisk Addrs to Link to :/],777,0,T.P0,N)
        TYPSTR  (NMDSK,B.MDI,0,T.P2)
        POPJ    P,
 
LNUOUT:
        MOVEI   AC,NNMSPC
        MOVEM   AC,NUM
        TYPSTR  ([ASCIZ/User to Link to :/],777,0,T.P0,N)
        TYPSTR  (@NUM,L.UNM3,0,T.P2)
        POPJ    P,

GETLND:
        INSTR   ([ASCIZ/Mdisk Addrs to Link to :/],NMDSK,B.MDI)
        POPJ    P,
 
GETL37:	; input 370 host number and check usernames
	INNUM	([ASCIZ/Host :/],D)
	 JRST	[PUSHJ	P,INORNO
		 JRST	GETL37]
	JUMPE	AC1,.-1
	MOVEM	AC1,LUDNUM
	MOVEM	AC1,HOST
	TLNE	FLG2,V.LSQ		; skip if not a list command
	 POPJ	P,			; return, no check on list
	PUSHJ	P,GETOLD		; build circuit
	 JRST	GETCMD
	MOVE	AC,OLDASY
	CAIN	AC,A370
	 JRST	GTL372
	TYPSTR	([ASCIZ/Cmd only available on Tymcom-370/])
	PUSHJ	P,INORNO
	JRST	GETL37
GTL372:
	TLNN	FLG2,V.EXC	; skip if changing items
	 POPJ	P,		
        MOVEI   AC,UNMSPC
        MOVEM   AC,NUM
	PUSHJ	P,CK3USR               ; check original user valid on this host
         JRST   [TYPSTR  ([ASCIZ/Originating user not valid on this host./])
                 JRST    GETL37]
        MOVEI   AC,NNMSPC
        MOVEM   AC,NUM
        PUSHJ   P,CK3USR
         JRST   [TYPSTR  ([ASCIZ/Linked username not valid on this host./])
                 JRST    GETL37]
        POPJ    P,
 
GEOUSR: ; get original user and check valid on host etc.
        PUSHJ   P,GETUNM
         JRST   [PUSHJ   P,INORNO
                 JRST    GEOUSR]
        TLNE    FLG2,V.LSQ
         POPJ   P,
        MOVEI   AC,UNMSPC
        MOVEM   AC,NUM
        PUSHJ   P,CK3USR              ; check user valid on the host
         JRST   [TYPSTR  ([ASCIZ/User not valid in the host/])
                 JRST    GEOUSR]
        MOVEI   AC,UNMSPC
        MOVEM   AC,NUM
        PUSHJ   P,GT3UUN              ; get gan and uun
        PUSHJ   P,GETACC
         JRST   GETCMD
        PUSHJ   P,GEDISA              ; get district
        MOVE    AC,UADIS
        MOVEM   AC,NMDIST
        TLNE    FLG,U.PRV             ; return if privilege
         POPJ   P,
        TLNN    FLG2,V.EXC            ; skip if changing items
         POPJ   P,
        CAMN    AC,DISRCT
         POPJ   P,
        TYPSTR  ([ASCIZ/Users not in the same district./])
        JRST    GEOUSR
 
GETLNU: ; get username to be linked to and make sure they are in the same dist
        INSTR   ([ASCIZ/User to Link to :/],NNMSPC,L.UNM3,T)
        MOVEI   AC1,L.UNM3
        MOVEI   AC,NNMSPC
        PUSHJ   P,CNTCHR
        SKIPN   AC1
         JRST   [PUSHJ   P,INORNO
                 JRST    GETLNU]
        TLNE    FLG2,V.LSQ
         POPJ   P,
        MOVEI   AC,NNMSPC
        MOVEM   AC,NUM
        PUSHJ   P,CK3USR              ; check user valid on the host
         JRST   [TYPSTR  ([ASCIZ/User not valid in the host/])
                 JRST    GETLNU]
        MOVEI   AC,NNMSPC
        MOVEM   AC,NUM
        PUSHJ   P,GT3UUN              ; get gan and uun
        PUSHJ   P,GEDISA              ; get district
        MOVE    AC,UADIS
        MOVEM   AC,DISRCT
        MOVE    AC,NMDIST
        TLNE    FLG,U.PRV             ; return if privilege
         POPJ   P,
        CAMN    AC,DISRCT
         POPJ   P,
        TYPSTR  ([ASCIZ/Users not in the same district./])
        JRST    GETLNU
 
CK3USR: ; check 370 user valid on the input host
        SNDBYT  (OLDPRT,\B.LCOM,KNALUD,I)  
        SNDSTR  (AC,L.UNM3,@NUM)
        GETBYT  (OLDPRT)
         JRST   GETCMD
        CAIE    AC1,LUD.OK            ; skip if valid
         POPJ   P,
        AOS     0(P)
        POPJ    P,
 
GT3UUN: ; get 370 user's gan and uun
        SNDBYT  (OLDPRT,\B.LCOM,LGULUD,I)
        SNDSTR  (AC,L.UNM3,@NUM)
        PUSHJ   P,OLDA
         JRST   [TYPSTR  ([ASCIZ/Error in getting user's uun/])
                 JRST    GETCMD]
        GETBYT  (OLDPRT,\B.GAN)
         JRST   GETCMD
        GETBYT  (OLDPRT,\B.UUN)
         JRST   GETCMD
        MOVEM   AC1,NMUUN
        POPJ    P,
 
GEDISA: ; get district code from accounting data base
        MOVEI   AC,A370
        MOVEM   AC,ACTSY2             ; acctg. system type is always 3
        SNDBYT  (ACTPRT,\B.ACOM,LUDACT,I)
        SNDBYT  (AC,\B.UUN,NMUUN)
        SNDBYT  (AC,\B.ASY,ACTSY2)
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Error in listing district for the user/])
                 JRST    GETCMD]
        GETBYT  (ACTPRT,\B.DIS)
         JRST   GETCMD
        MOVEM   AC1,UADIS
        POPJ    P,
CMDATI: ; add timer
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE ATIM <
	X	(HST1OT,GETH37,RWH37)
	X	(NAMOUP,GETUSR,RWUSR)
	X	(TIMOUT,GETTIM,RWMDI)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (ATI,ATIM,^D47,USRRQQ)

; code for add timer starts here, only immediate mode and PROCESS
; can enter
        SNDBYT  (OLDPRT,\B.LCOM,ATILUD,I)       ; add timer
        SNDSTR  (AC,L.UNM3,UNMSPC)
	SNDSTR	(AC,B.MDI,MDISK)
        PUSHJ   P,OLDA
         JRST   ATIME2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/ADD/)
	 JRST	ADTIM4
	TTFSTR	([ASCIZ/Add Timer/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
ADTIM4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	ADTIMD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	ADTIMD
	JRST	ATIST2			; ABRV'ST2 is the menu output section

ADTIMD: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

ATIME2:	; error during add timer
	TYPSTR	([ASCIZ/Error during Add Timer./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	ATIME3

ATIME3:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	ATIST2

; end of code for add timer
 
TIMOUT:
        TYPSTR  ([ASCIZ/Timer Addrs :/],777,0,T.P0,N)
        TYPSTR  (MDISK,B.MDI,0,T.P2)
        POPJ    P,
 
GETTIM:
        INSTR   ([ASCIZ/Timer Addrs :/],MDISK,B.MDI)
        POPJ    P,
CMDAFR: ; add free format mdisk
	TCR	(1)
	TRO	FLG2,V.NIR

DEFINE AFRE <
        X       (HST1OT,GETH37,RWH37)
	X	(NAMOUP,GETUSR,RWUSR)
	X	(MDIOUT,GE1MDI,RWMDI)
        X       (SLCOUT,GETSLC,RWSLC)
	X	(CYLOUT,GETCYL,RWCYL)
	X	(LABOUT,GETLAB,RWLAB)
	X	(DVTOUT,GETDVT,RWDVT)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (AFR,AFRE,^D48,USRRQQ)

; code for add free format mdisk starts here, only immediate mode and PROCESS
; can enter
        SNDBYT  (OLDPRT,\B.LCOM,AFFLUD,I)       ; add free format mdisk
        SNDSTR  (AC,L.UNM3,UNMSPC)
	SNDSTR	(AC,B.MDI,MDISK)
        SNDBYT  (AC,\B.CYL,SLC)
        SNDBYT  (AC,\B.CYL,CYL)
        SNDSTR  (AC,L.LAB,LAB)
        SNDBYT  (AC,\B.DTY,DTY)
        PUSHJ   P,OLDA
	 JRST	AFREE2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; tattle
	GETT	(/ADD/)
	 JRST	ADFRE4
	TTFSTR	([ASCIZ/Add Free Format Mdisk/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
ADFRE4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	ADFRED			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	ADFRED
	JRST	AFRST2			; ABRV'ST2 is the menu output section

ADFRED: ; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

AFREE2:	; error during add free format mdisk
	TYPSTR	([ASCIZ/Error during Add Free Format Mdisk./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
	JRST	AFREE3

AFREE3:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
	JRST	AFRST2

; end of code for add free format mdisk
 
SLCOUT:
        TYPSTR  ([ASCIZ/Starting Position :/],777,0,T.P0,N)
        TYPNUM  (SLC,D,0,T.P2)
        POPJ    P,
 
GETSLC: ; get starting cyclinder location
        INNUM   ([ASCIZ/Starting Position :/],D)
         JRST   GETSL2
        AOS     AC1
        CAILE   AC1,MAX.CY
         JRST   GETSL2
        SOS     AC1
        MOVEM   AC1,SLC
        POPJ    P,
GETSL2: PUSHJ   P,INORNO
        JRST    GETSLC
 
RWSLC:
        REQNOT  (REQ,SLC,D)
        POPJ    P,
 
LABOUT:  
        TYPSTR  ([ASCIZ/Label :/],777,0,T.P0,N)
        TYPSTR  (LAB,L.LAB,0,T.P2)
        POPJ    P,
 
GETLAB: ; get mdisk label
        INSTR   ([ASCIZ/Label :/],LAB,L.LAB)
        POPJ    P,
 
RWLAB:
        REQOUT  (REQ,LAB,L.LAB)
        POPJ    P,
 
DVTOUT:
	TYPSTR	([ASCIZ/Device Type :/],777,0,T.P0,N)
	TYPSTR	(DTYPE,L.DTY,0,T.P2)
	POPJ	P,
 
GETDVT:
	INSTR	([ASCIZ/Device Type :/],DTYPE,L.DTY)
        SETO    AC1,
        MOVE    AC,DTYPE
        CAMN    AC,[ASCII/3340 /]            
         MOVEI  AC1,1
        CAMN    AC,[ASCII/2305 /]            
         MOVEI  AC1,2                        
        CAMN    AC,[ASCII/3375 /]            
         MOVEI  AC1,4                        
        CAMN    AC,[ASCII/3350 /]            
         MOVEI  AC1,^D8
        CAMN    AC,[ASCII/3330 /]            
         MOVEI  AC1,^D16
        CAMN    AC,[ASCII/3380 /]            
         MOVEI  AC1,^D32
        CAMN    AC,[ASCII/2314 /]            
         MOVEI  AC1,^D64
        CAMN    AC,[ASCII/2311 /]            
         MOVEI  AC1,^D128
        JUMPL   AC1,BADTYP                   ; if AC1 unchanged then error
        MOVEM   AC1,DTY
	POPJ	P,
 
BADTYP:
        TYPSTR  ([ASCIZ/Invalid Device Type./])
        JRST    GETDVT
 

RWDVT:
	REQOUT	(REQ,DTYPE,L.DTY)
	POPJ	P,
CMDACS: ; add customer
	TCR	(1)
        SETZM   REQNM2                ; set request number of new gan after
                                      ; this add customer request to 0. Note
                                      ; REQNM2 \= 0 means new gan has been
                                      ; established. REQNM2 also will be used
                                      ; to retrieve (new) gan in the routine
                                 ; NUNGAC - new user of new gan after add
                                      ; customer request
        TRO     FLG2,V.ACS            ; this is add customer request
	TRO	FLG2,V.NIR

DEFINE ACUS <
	X	(SYSOUT,GEYSYS,RWSYS)
	X	(CSNOUX,GEZCSN,RWCSN)
	X	(DETOUT,GEXDET,RWDET)
        X       (FOCOUT,GETFFF,RWFOC,TCFLG,1)    ; for 370 only
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (ACS,ACUS,^D51,CUSRQQ)

; code for add customer starts here, only immediate mode and PROCESS
; can enter
        MOVE    AC,ACINVC
        CAIN    AC,3                  ; skip if billable
         JRST   STDPRI
        MOVEI   AC1,^D99              ; set pricing code to 99
        JRST    START1
STDPRI: MOVE    AC,ACTSY2
        CAIE    AC,A10
         JRST   NOTP10
        MOVEI   AC1,1
        JRST    START1
NOTP10: CAIE    AC,A940
         JRST   NOTP94
        MOVEI   AC1,5
        JRST    START1
NOTP94: MOVEI   AC1,^D8
START1: MOVEM   AC1,ACDEFP
        SNDBYT  (ACTPRT,\B.ACOM,NCUACT,I)       ; add customer
        SNDBYT  (AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ASY,ACTSY2)
        SNDSTR  (AC,L.CUSN,ACCNAM)
        SNDBYT  (AC,\B.DIS,ACCDIS)
        SNDBYT  (AC,\B.DET,ACDETC)
        SNDBYT  (AC,\B.INV,ACINVC)
        SNDBYT  (AC,\B.MIN,ACMINC)
        SNDBYT  (AC,\B.SLS,ACSLS)
        SNDSTR  (AC,L.PO,ACPONM)
        SNDBYT  (AC,\B.POMX,ACPOMX)
        SNDBYT  (AC,\B.PODT,ACPSDT)
        SNDBYT  (AC,\B.PODT,ACPEDT)
        SNDBYT  (AC,\B.VPRI,ACVPF)
        SNDBYT  (AC,\B.PRI,ACDEFP)
        SNDSTR  (AC,L.STRE,ACSTR1)
        SNDSTR  (AC,L.STRE,ACSTR2)
        SNDSTR  (AC,L.STRE,ACEXLN)
        SNDSTR  (AC,L.CITY,ACCITY)
        SNDSTR  (AC,L.STAT,ACSTAT)
        SNDSTR  (AC,L.ZIP,ACZIP)
        SNDSTR  (AC,L.CTRY,ACCTRY)
        SNDSTR  (AC,L.ATTN,ACATTN)
        SNDBYT  (AC,\B.CC,ACCCC)
        PUSHJ   P,AGANS
         JRST   ACUSE2
; If add customer to 370, then update focus flat fee flag
        MOVE    AC,ACTSY2
        CAIE    AC,3                  ; see if it is 370
         JRST   ACUDNE
        SNDBYT  (ACTPRT,\B.ACOM,CCFACT,I)
        SNDBYT  (AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ASY,ACTSY2)
        SNDBYT  (AC,\B.FOCF,ACFOCF)
        PUSHJ   P,AGANS
         JRST   ACUSE3
ACUDNE: MOVE    AC1,ACANS
	PUSHJ	P,LUDAOT
 
; write 99 file
        MOVE    AC,ACDEFP
        CAIE    AC,^D99
         JRST   TATADD
        TRO     FLG2,V.F99
        GETT    (/F99/)
         JRST   TATADD
        TTFNUM  (CUSNUM,D)
        TTFNUM  (ACTSY2,D)
        TTFSTR  (ACCNAM,L.CUSN)
        PUSHJ   P,TTFCR1              ; write crlf
        PUSHJ   P,TTFCR1              ; write crlf
        PUSHJ   P,RELTTF
 
; tattle
TATADD: TRZ     FLG2,V.F99            ; for write tattle file
	GETT	(/ADD/)
	 JRST	ACUST4
	TTFSTR	([ASCIZ/Add Customer/])
	PUSHJ	P,STDCHD
	PUSHJ	P,RELTTF
ACUST4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	ACUSTD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	ACUSTD
	JRST    ACSST2

ACUSTD: ; done, successful completion
        TRZ     FLG2,V.ACS
	TRO	FLG,U.OKAY
	POPJ	P,

ACUSE2:	; error during add customer
	TYPSTR	([ASCIZ/Error during Add Customer./])
	MOVE	AC1,ACANS
	PUSHJ	P,LUDAOT
	JRST	ACUSE4

ACUSE3:
        TYPSTR  ([ASCIZ/Error during Update Customer Focus Flat Fee Flag./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        SNDBYT  (ACTPRT,\B.ACOM,REVACT,I)  ; reverse last acctg. entry
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Reverse Acctg. Entry not Working./])
                 MOVE    AC1,ACANS
                 PUSHJ   P,LUDAOT
                 JRST    GETCMD]
        JRST    ACUSE4
 
ACUSE4:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
        JRST    ACSST2
 
; end of code for add customer
 
GEZCSN: ; get cid
        PUSHJ   P,GETCUS
         JRST   .-1
        TLNE    FLG2,V.LSQ
         POPJ   P,
        ; get default ast, for checking valid cid and checking access
        PUSHJ   P,GETACC
         JRST   GETCMD
        SNDBYT  (ACTPRT,\B.ACOM,LCTACT,I)  ; list ast for cid
        SNDBYT  (AC,\B.CID,CUSNUM)
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Customer not Found./])
                 JRST    GEZCSN]
        GETBYT  (AC)
         JRST   GETCMD
        MOVE    AC1,ASMTAB(AC1)       ; get ast number from table
        MOVEM   AC1,ACTSY2            ; load ast to ACTSY2 for checking access
        PUSHJ   P,CHKCUS
         JRST   GEZCSN
        ; check cid not valid on input ast (ACTSYS)
        SNDBYT  (ACTPRT,\B.ACOM,LCNACT,I)   ; list customer name
        SNDBYT  (AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ASY,ACTSYS)
        PUSHJ   P,AGANS
         JRST   GEZCS2
        GETSTR  (AC,L.CUSN,ACCNAM)    ; get customer name
        TYPSTR  ([ASCIZ/Customer already valid on this system type./])
        JRST    GEZCSN
GEZCS2: ; get customer acctg. info respect to default ast. This is for 
        ; establishing customer record in new (input) ast
        PUSHJ   P,GCAREK
         JRST   [TYPSTR   ([ASCIZ/Customer not found in its default ast./])
                 JRST    GEZCSN]
        MOVE    AC1,ACTSYS
        MOVEM   AC1,ACTSY2            ; put input ast into ACTSY2 for later use
        POPJ    P,
NUOGAC: ; new user of existing gan for add customer command
      ; TYPSTR  ([ASCIZ/Add new user of old gan after add customer request/])
        ; this routine is called after add customer command, itself is not a 
        ; command. After user generated an ADD CUSTOMER request and wants to
        ; add a new user of existing gan to this customer, this routine will
        ; be called automatically. Therefore both system type and cid are get
        ; from ADD CUSTOMER request without asking user again. But we still
        ; have to get them when this request being examined by accounting, sra
        ; or validation.
	TCR	(1)
	TRO	FLG2,V.NIR
        TRZ     FLG2,V.ACS            ; add customer request is done
        TRZ     FLG2,V.GAN            ; for using GEYLIC
        SETZM   MUDON                 ; for output  license
      ; TCFLG has been defined in ADD CUSTOMER command
        SETZM   MFLAG                 ; for non-zero cyclinders input
        SETZM   DFLAG                 ; for getting write password

DEFINE N1US <
	X	(SYSOUT,N1USYS,RWSYS)
        X       (CSNOUX,N1UCSN,RWCSN)
        X       (GANOU1,GEYGAN,RWUSR)
	X	(NNMOUT,GETNNM,RWNNM)
        X       (PSWOUT,GEYPSW,RWPSW)
        X       (COCOUT,GETCOC,RWCOC)
	X	(GHMEOT,GEGHME,RWH37)
        X       (LICOUX,GEYLIC,WYLIC)
	X	(TMZOUT,GETTMZ,RWTMZ)
        X       (INQOUT,GETINQ,RWINQ,TCFLG,2)
        X       (OTQOUT,GETOTQ,RWOTQ,TCFLG,2)
        X       (DCOOUT,GETDCO,RWDCO,TCFLG,1)
        X       (MCOOUT,GETMCO,RWMCO,TCFLG,1)
        X       (CYLOUT,GEXCYL,RWCYL,TCFLG,1)
        X       (GRPOUT,GETGRP,RWGRP,TCFLG,1,U.PRV)  ; only priv may set pack
	X	(ST1OUT,GETST1,RWST1,MFLAG,1)
	X	(ST2OUT,GETST2,RWST2,MFLAG,1)
	X	(ST3OUT,GETST3,RWST3,MFLAG,1)
	X	(ST4OUT,GETST4,RWST4,MFLAG,1)
	X	(ST5OUT,GETST5,RWST5,MFLAG,1)
        X       (RPWOUT,GETRPW,RWRPW,MFLAG,1)
        X       (WPWOUT,GETWPW,RWWPW,DFLAG,1)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC  (N1U,N1US,^D54,CUSRQQ)

; code for add new user of old gan after add customer command starts here, only
; PROCESS command can enter the following codes

; setup NMCPAR, NMCOLN, NMIRC and NMCLSS
        MOVE    AC1,NMCPAR            ; NMCPAR is newly defined in GEYLIC
        LSH     AC1,-^D8
        MOVEM   AC1,NMCPAR
        MOVE    AC,NMPSW
        CAIE    AC,7400               ; no psw?
         JRST   .+4
        MOVE    AC1,NMCOLN
        TLO     AC1,NPS.CD            ; set no-psw bit
        MOVEM   AC1,NMCOLN
        MOVE    AC1,NMCOLN            ; colon came from old user
        LSH     AC1,-^D16
        MOVEM   AC1,NMCOLN
        SETZM   NMIRC
        MOVEI   AC1,2
        MOVEM   AC1,NMCLSS
        MOVEI   AC1,D.CLS             ; set class 2
        MOVEM   AC1,NMCLSS+1
        MOVEI   AC1,D.GRP             ; set group 1
        TRO     AC1,GRP.CD            ; set group indicator bit
        MOVEM   AC1,NMCLSS+2
        MOVE    AC1,HOST
        TRO     AC1,HOM.CD            ; set home host indicator bit
        MOVEM   AC1,NMCLSS+3
 
; add new user to cud
        PUSHJ   P,NUSMUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   N1USE1
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.GAN)       ; get gan
         JRST   GETCMD
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.UUN)       ; get uun for new user
         JRST   GETCMD
        MOVEM   AC1,NMUUN
        PUSHJ   P,GET40
        TCR     (1)
        TYPSTR  ([ASCIZ/********** The Uun for /],777,0,T.P0,N)
        TYPSTR  (NNMSPC,L.UNM,1,0,N)
        TYPSTR  ([ASCIZ/is /],777,1,0,N)
        TYPNUM  (NMUUN,O,5)
        MOVE    AC1,NMCPAR            ; return for next entry
        LSH     AC1,^D8
        MOVEM   AC1,NMCPAR
        MOVE    AC1,NMCOLN            ; return for next entry
        LSH     AC1,^D16
        MOVEM   AC1,NMCOLN
 
; new user for the accounting system type
        MOVE    AC,NMCOLN
        TLNE    AC,BIL.CD             ; skip if billable
         JRST   .+3                   ; if non-billable then use old UAPRIC
        MOVEI   AC1,^D99
        MOVEM   AC1,UAPRIC            ; assign 99 pricing code
        PUSHJ   P,NUSACC
        PUSHJ   P,AGANS
         JRST   N1USE2
        JRST    N1ULUD
 
; add user in lud - will be treated differently according to system type
  
N1ULUD:
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; skip if 370
         JRST   NOT137
        PUSHJ   P,ADD370
        JRST    N1UDNE
NOT137: PUSHJ   P,ADD10
        JRST    N1UDNE
 
N1UDNE: PUSHJ   P,OLDA
         JRST   N1USE3
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; if 370 then update default core
         JRST   .+6
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM6
        PUSHJ   P,ADDCOR
        PUSHJ   P,OLDA
         JFCL                         ; continue even if error
; tattle
	GETT	(/ADD/)
	 JRST	N1USR4
	TTFSTR	([ASCIZ/New user of existing gan after add customer/])
	PUSHJ	P,ST1UHD
	PUSHJ	P,RELTTF
 
N1USR4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	N1USRD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
         JRST   N1USRD
	JRST	N1UST2			; ABRV'ST2 is the menu output section

N1USRD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

N1USE1: ; error during add new user into the mud
        TYPSTR  ([ASCIZ/Error during Add New User in the Cud./])
        PUSHJ   P,ERRCUD
        JRST    N1USE4

N1USE2: ; error during add new user in acctg.
        TYPSTR  ([ASCIZ/Error during Add User in Acctg./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        JRST    N1USE4
 
N1USE3:	; error during add user in lud
	TYPSTR	([ASCIZ/Error during Add User in the Lud./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        SNDBYT  (ACTPRT,\B.ACOM,REVACT,I)  ; reverse last acctg. entry
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Reverse Acctg. Entry not Working!/])
                 MOVE    AC1,ACANS
                 PUSHJ   P,LUDAOT
                 JRST    GETCMD]
 
N1USE4: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    N1UST2
 
; end of code for new user of existing gan after add customer
 
N1USYS:
        TLNE    FLG2,V.LSQ!V.EXQ!V.PRQ    ; skip if not a request
         JRST   GEYSYS
        TLNE    FLG,U.IMM                 ; skip if non-immediate mode
         JRST   GEYSYS
        POPJ    P,                    ; return, since ast already defined in
                                      ; ADD CUSTOMER command
 
N1UCSN:
        TLNE    FLG2,V.EXQ!V.LSQ!V.PRQ
         JRST   N1UCS2
        TLNE    FLG,U.IMM
         JRST   N1UCS2
        MOVE    AC,ACTSYS
        MOVEM   AC,ACTSY2
        POPJ    P,
N1UCS2:
        PUSHJ   P,GETCUS
         JRST   .-1
        TLNE    FLG2,V.LSQ
         POPJ   P,
        ; when examine or process, we have to get customer accounting info
        ; for setting up license from invoice code, also get cost code
        PUSHJ   P,GETACC
         JRST   GETCMD
        SNDBYT  (ACTPRT,\B.ACOM,LCTACT,I)  ; list ast for cid
        SNDBYT  (AC,\B.CID,CUSNUM)
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Customer not Found./])
                 JRST    N1UCS2]
        GETBYT  (ACTPRT)
         JRST   GETCMD
        MOVE    AC1,ASMTAB(AC1)
        MOVEM   AC1,ACTSY2
        PUSHJ   P,GCAREK
         JRST   [TYPSTR  ([ASCIZ/Customer not found in default ast./])
                 JRST    N1UCS2]
        MOVE    AC,ACTSYS
        MOVEM   AC,ACTSY2
        POPJ    P,
 
AUHOAC: ; add user host after add customer command
      ; TYPSTR  ([ASCIZ/Add user host after add customer request/])
        ; this routine is called after add customer command, itself is not a 
        ; command. After user generated an ADD CUSTOMER request and wants to
        ; validate an existing user (belongs to this customer) to a host of
        ; new (input) ast, this routine will be called automatically. Both
        ; system type and customer are get from ADD CUSTOMER request. This
        ; routine basically are same as ADD USER HOST command.
	TCR	(1)
        TRZ     FLG2,V.ACS            ; add customer request is done
	TRO	FLG2,V.NIR
        SETZM   MUDON                 ; for output  license
      ; TCFLG has been defined in ADD CUSTOMER command
        SETZM   MFLAG                 ; for non-zero cyclinders input
        SETZM   DFLAG                 ; for getting write password

DEFINE N2US <
	X	(SYSOUT,N1USYS,RWSYS)
        X       (CSNOUX,N1UCSN,RWCSN)
	X	(NAMOUP,N2UUSR,RWUSR)
	X	(HST1OT,GEXHME,RWH37)
        X       (LICOUX,GEXLIC,WXLIC)
	X	(TMZOUT,GETTMZ,RWTMZ)
        X       (INQOUT,GETINQ,RWINQ,TCFLG,2)
        X       (OTQOUT,GETOTQ,RWOTQ,TCFLG,2)
        X       (DCOOUT,GETDCO,RWDCO,TCFLG,1)
        X       (MCOOUT,GETMCO,RWMCO,TCFLG,1)
        X       (CYLOUT,GEXCYL,RWCYL,TCFLG,1)
        X       (GRPOUT,GETGRP,RWGRP,TCFLG,1,U.PRV)  ; only priv may set pack
	X	(ST1OUT,GETST1,RWST1,MFLAG,1)
	X	(ST2OUT,GETST2,RWST2,MFLAG,1)
	X	(ST3OUT,GETST3,RWST3,MFLAG,1)
	X	(ST4OUT,GETST4,RWST4,MFLAG,1)
	X	(ST5OUT,GETST5,RWST5,MFLAG,1)
        X       (RPWOUT,GETRPW,RWRPW,MFLAG,1)
        X       (WPWOUT,GETWPW,RWWPW,DFLAG,1)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC  (N2U,N2US,^D55,CUSRQQ)

        PUSHJ   P,NTYACC              ; new user for an ast
        PUSHJ   P,AGANS
         JRST   N2USE1
        MOVEI   AC1,UNMSPC
        MOVEM   AC1,NUM
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; skip if 370
         JRST   NOT237
        PUSHJ   P,ADD370
        JRST    N2UDNE
NOT237: PUSHJ   P,ADD10
        JRST    N2UDNE
 
N2UDNE: PUSHJ   P,OLDA
         JRST   N2USE2
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; if 370 then update default core
         JRST   .+6
        MOVEI   AC1,UNMSPC
        MOVEM   AC1,NUM6
        PUSHJ   P,ADDCOR
        PUSHJ   P,OLDA
         JFCL                         ; continue even if error
; tattle
	GETT	(/ADD/)
	 JRST	N2USR4
	TTFSTR	([ASCIZ/Add User Host after add customer/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
 
N2USR4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	N2USRD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
         JRST   N2USRD
	JRST	N2UST2			; ABRV'ST2 is the menu output section

N2USRD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

N2USE1: ; error during add new user for an ast
        TYPSTR  ([ASCIZ/Error during Add Acctg. System Type for the User./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    N2USE3

N2USE2:	; error during add user in lud
	TYPSTR	([ASCIZ/Error during Add User in the Lud./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        SNDBYT  (ACTPRT,\B.ACOM,REVACT,I)  ; reverse last acctg. entry
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Reverse Acctg. Entry not Working!/])
                 MOVE    AC1,ACANS
                 PUSHJ   P,LUDAOT
                 JRST    GETCMD]
        JRST    N2USE3
 
N2USE3: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    N2UST2
 
; end of code for add user host after add customer command
 
N2UUSR: ; assume user is not valid on input ast since this is request after
        ; add customer to input ast request
        PUSHJ   P,GETUNM
         JRST   [PUSHJ   P,INORNO
                 JRST    N2UUSR]
        TLNE    FLG2,V.LSQ
         POPJ   P,
        PUSHJ   P,GETACC
         JRST   GETCMD
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GCREC
         JRST   N2UUS2
        PUSHJ   P,GEXSYS              ;  get default ast and acctg. info
        MOVE    AC,UACID
        CAMN    AC,CUSNUM
         POPJ   P,
        TYPSTR  ([ASCIZ/User not belong to this customer./])
        POPJ    P,
 
N2UUS2:
        TRNN    FLG,U.RFI
         JRST   [PUSHJ   P,INORNO
                 JRST    N2UUSR]
        PUSHJ   P,REQERR
        POPJ    P,
 
GEXHME:
        INNUM   ([ASCIZ/Host :/],D)   ; no
         JRST   [PUSHJ   P,INORNO
                 JRST    GEXHME]
        JUMPE   AC1,.-1
        MOVEM   AC1,LUDNUM
        MOVEM   AC1,HOST
        TLNE    FLG2,V.LSQ
         POPJ   P,
        PUSHJ   P,GETOLD
         JRST   GETCMD
        MOVE    AC1,OLDASY
        CAME    AC1,ACTSYS
         JRST   GEXHM2
        SNDBYT  (ACTPRT,\B.ACOM,KUHACT,I)  ; check user valid on the host
        SNDBYT  (AC,\B.UUN,NMUUN)
        SNDBYT  (AC,\B.HST,HOST)
        PUSHJ   P,AGANS
         POPJ   P,                    ; return if user not on this host
        TYPSTR  ([ASCIZ/User already valid on the host in acctg./])
        JRST    GEXHME
GEXHM2:
        TYPSTR  ([ASCIZ/Mismatch between host and system type./])
        TRNN    FLG,U.RFI
         JRST   [PUSHJ   P,INORNO
                 JRST    GEXHME]
        PUSHJ   P,REQERR
        POPJ    P,
 
NGANAC: ; new gan after add customer command
      ; TYPSTR  ([ASCIZ/Add new gan after add customer request/])
        ; This is a routine not a command. It is called when user want to
        ; establish a new account after finished an add customer request.
        ; Both system type and cid are get from storage not from this routine,
        ; unless it is an examine, type or process a request.
 
        AOS     USRCNT                ; USRCNT is used in EXMMAC of add 
                                      ; customer command to indicate a gan has
                                      ; been established
	TCR	(1)
	TRO	FLG2,V.NIR
        TRZ     FLG2,V.ACS            ; add customer request is done
        TRO     FLG2,V.AGA            ; for using in GEYLIC and define REQNM2
        SETZM   MUDON                 ; for output  license
        ; TCFLG has been defined in the ADD CUSTOMER command
        SETZM   MFLAG                 ; for non-zero cyclinders input
        SETZM   DFLAG                 ; for getting write password

DEFINE N3US <
	X	(SYSOUT,N1USYS,RWSYS)
        X       (CSNOUX,N1UCSN,RWCSN)
	X	(NNMOUT,GETNNM,RWNNM)
        X       (PSWOUT,GEYPSW,RWPSW)
        X       (COCOUT,GETCOC,RWCOC)
        X       (LICOUX,GEYLIC,WYLIC)
	X	(TMZOUT,GETTMZ,RWTMZ)
	X	(GHMEOT,GEGHME,RWH37)
        X       (INQOUT,GETINQ,RWINQ,TCFLG,2)
        X       (OTQOUT,GETOTQ,RWOTQ,TCFLG,2)
        X       (DCOOUT,GETDCO,RWDCO,TCFLG,1)
        X       (MCOOUT,GETMCO,RWMCO,TCFLG,1)
        X       (CYLOUT,GEXCYL,RWCYL,TCFLG,1)
        X       (GRPOUT,GETGRP,RWGRP,TCFLG,1,U.PRV)  ; only priv may set pack
	X	(ST1OUT,GETST1,RWST1,MFLAG,1)
	X	(ST2OUT,GETST2,RWST2,MFLAG,1)
	X	(ST3OUT,GETST3,RWST3,MFLAG,1)
	X	(ST4OUT,GETST4,RWST4,MFLAG,1)
	X	(ST5OUT,GETST5,RWST5,MFLAG,1)
        X       (RPWOUT,GETRPW,RWRPW,MFLAG,1)
        X       (WPWOUT,GETWPW,RWWPW,DFLAG,1)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC  (N3U,N3US,^D56,CUSRQQ)

; code for add new gan (add first user in the gan) after add customer starts
; here, only PROCESS command can enter the following codes

; setup NMCPAR, NMCOLN, NMIRC and NMCLSS
        MOVE    AC1,NMCPAR            ; NMCPAR is newly defined in GEYLIC
        LSH     AC1,-^D8
        MOVEM   AC1,NMCPAR
        SETZM   AC1
        MOVE    AC,NMPSW
        CAIE    AC,7400               ; no psw?
         SKIPA
        TLO     AC1,NPS.CD            ; set no-psw bit
        MOVE    AC,ACINVC
        CAIN    AC,3                  ; invoice code = 3 is non-billable
         TLO    AC1,BIL.CD            ; turn on bil.cd if non-billable
        LSH     AC1,-^D16
        MOVEM   AC1,NMCOLN
        SETZM   NMIRC
        MOVEI   AC1,2
        MOVEM   AC1,NMCLSS
        MOVEI   AC1,D.CLS             ; set class 2
        MOVEM   AC1,NMCLSS+1
        MOVEI   AC1,D.GRP             ; set group 1
        TRO     AC1,GRP.CD            ; set group indicator bit
        MOVEM   AC1,NMCLSS+2
        MOVE    AC1,HOST
        TRO     AC1,HOM.CD            ; set home host indicator bit
        MOVEM   AC1,NMCLSS+3
        MOVE    AC1,ACCDIS            ; ACCDIS came from customer
        MOVEM   AC1,NMDIST
 
; add new user to cud
        SETZM   NMGAN
        PUSHJ   P,NUSMUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   N3USE1
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.GAN)       ; get gan
         JRST   GETCMD
        MOVEM   AC1,NMGAN      
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.UUN)       ; get uun for new user
         JRST   GETCMD
        MOVEM   AC1,NMUUN
        PUSHJ   P,GET40
        TCR     (1)
        TYPSTR  ([ASCIZ/********** Global Account Number is /],777,0,T.P0,N)
        TYPNUM  (NMGAN,O,5)
        TCR     (1)
        TYPSTR  ([ASCIZ/********** The Uun for /],777,0,T.P0,N)
        TYPSTR  (NNMSPC,L.UNM,1,0,N)
        TYPSTR  ([ASCIZ/is /],777,1,0,N)
        TYPNUM  (NMUUN,O,5)
        MOVE    AC1,NMCPAR            ; return for next entry
        LSH     AC1,^D8
        MOVEM   AC1,NMCPAR
        MOVE    AC1,NMCOLN            ; return for next entry
        LSH     AC1,^D16
        MOVEM   AC1,NMCOLN
 
; new user for the accounting system type, first get ACCDIS and UASLS from
; customer then get UALANC and UACURC from table. UARESC is defined
; to be 1 in UPDLUD, therefore, we are not trying to get it here
        MOVE    AC1,ACDEFP            ; acdefp from customer record
        MOVEM   AC1,UAPRIC
        MOVE    AC1,ACCDIS
        MOVEM   AC1,UADIS
        IMULI   AC1,^D10
        MOVE    AC,DISTBL+5(AC1)             ; 6th column is language code
        MOVEM   AC,UALANC
        MOVE    AC,DISTBL+6(AC1)             ; 7th column is currency code
        MOVEM   AC,UACURC
        MOVE    AC1,ACSLS
        MOVEM   AC1,UASLS
        MOVE    AC,NMCOLN
        TLNE    AC,BIL.CD             ; skip if billable
         JRST   .+3                   ; if non-billable then use table
        MOVEI   AC1,^D99
        MOVEM   AC1,UAPRIC            ; assign 99 pricing code
        PUSHJ   P,NUSACC
        PUSHJ   P,AGANS
         JRST   N3USE2
        JRST    N3ULUD
 
; add user in lud - will be treated differently according to system type
  
N3ULUD:
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; skip if 370
         JRST   NOT337
        PUSHJ   P,ADD370
        JRST    N3UDNE
NOT337: PUSHJ   P,ADD10
        JRST    N3UDNE
 
N3UDNE: PUSHJ   P,OLDA
         JRST   N3USE3
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; if 370 then update default core
         JRST   .+6
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM6
        PUSHJ   P,ADDCOR
        PUSHJ   P,OLDA
         JFCL                         ; continue even if error
; tattle
	GETT	(/ADD/)
	 JRST	N3USR4
	TTFSTR	([ASCIZ/New Gan after add customer/])
	PUSHJ	P,ST1UHD
	PUSHJ	P,RELTTF
 
; write reqnum.DAT file, all the data that need for subsequent new user request
; will be written here
        TLNN    FLG2,V.PRQ
         JRST   N3USR4
        REQNOT  (DAT,NMGAN,O)         ; open DAT file and write gan
        REQNOT  (DAT,NMCOLN,D)
        REQNOT  (DAT,NMDIST,D)
        REQNOT  (DAT,UADIS,D)
        REQNOT  (DAT,UALANC,D)
        REQNOT  (DAT,UACURC,D)
        REQNOT  (DAT,UASLS,D)
        REQNOT  (DAT,UAPRIC,D)
        REQNOT  (DAT,UARESC,D)
 ;      REQNOT  (DAT,ACCCC,D)
        PUSHJ   P,RELRQO              ; close output file
 
N3USR4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	N3USRD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
         JRST   N3USRD
	JRST	N3UST2			; ABRV'ST2 is the menu output section

N3USRD:	; done, successful completion
        TRZ     FLG2,V.GAN
	TRO	FLG,U.OKAY
	POPJ	P,
 
N3USE1: ; error during add new user into the mud
        TYPSTR  ([ASCIZ/Error during Add New Gan in the Cud./])
        PUSHJ   P,ERRCUD
        JRST    N3USE4

N3USE2: ; error during add new user in acctg.
        TYPSTR  ([ASCIZ/Error during Add Gan in Acctg./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        JRST    N3USE4
 
N3USE3:	; error during add user in lud
	TYPSTR	([ASCIZ/Error during Add Gan in the Lud./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        SNDBYT  (ACTPRT,\B.ACOM,REVACT,I)  ; reverse last acctg. entry
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Reverse Acctg. Entry not Working!/])
                 MOVE    AC1,ACANS
                 PUSHJ   P,LUDAOT
                 JRST    GETCMD]
 
N3USE4: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    N3UST2
 
; end of code for new gan after add customer command
NUNGAC: ; new user of new gan for add customer request
      ; TYPSTR  ([ASCIZ/Add new user of new gan after add customer request/])
        ; this routine is called after made an add customer request and a new
        ; gan (first new user after add customer) request. Both system type
        ; and cid are get from preceding request. This routine will not get
        ; gan until processing the request. The gan is obtained from DAT file
        ; of processed (new gan after add customer) request. Therefore this
        ; routine has to record the new gan after add customer request
        ; number for retrieval gan!
	TCR	(1)
	TRO	FLG2,V.NIR
        TRZ     FLG2,V.GAN            ; for using GEYLIC
        TRZ     FLG2,V.ACS            ; add customer request is done
        SETZM   MUDON                 ; for output  license
      ; TCFLG has been defined in ADD CUSTOMER command
        SETZM   MFLAG                 ; for non-zero cyclinders input
        SETZM   DFLAG                 ; for getting write password

DEFINE N4US <
	X	(SYSOUT,N1USYS,RWSYS)
        X       (CSNOUX,N1UCSN,RWCSN)
	X	(NNMOUT,GETNNM,RWNNM)
        X       (PSWOUT,GEYPSW,RWPSW)
        X       (COCOUT,GETCOC,RWCOC)
	X	(GHMEOT,GEGHME,RWH37)
        X       (LICOUX,GEYLIC,WYLIC)
	X	(TMZOUT,GETTMZ,RWTMZ)
        X       (INQOUT,GETINQ,RWINQ,TCFLG,2)
        X       (OTQOUT,GETOTQ,RWOTQ,TCFLG,2)
        X       (DCOOUT,GETDCO,RWDCO,TCFLG,1)
        X       (MCOOUT,GETMCO,RWMCO,TCFLG,1)
        X       (CYLOUT,GEXCYL,RWCYL,TCFLG,1)
        X       (GRPOUT,GETGRP,RWGRP,TCFLG,1,U.PRV)  ; only priv may set pack
	X	(ST1OUT,GETST1,RWST1,MFLAG,1)
	X	(ST2OUT,GETST2,RWST2,MFLAG,1)
	X	(ST3OUT,GETST3,RWST3,MFLAG,1)
	X	(ST4OUT,GETST4,RWST4,MFLAG,1)
	X	(ST5OUT,GETST5,RWST5,MFLAG,1)
        X       (RPWOUT,GETRPW,RWRPW,MFLAG,1)
        X       (WPWOUT,GETWPW,RWWPW,DFLAG,1)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
        X       (DUMMY2,GERQNM,RWRQNM)     ; get and write request number
>
	EXMMAC  (N4U,N4US,^D57,CUSRQQ)

; code for add new user of new gan after add customer command starts here,
; only PROCESS command can enter the following codes

; get gan from REQNM2.DAT file
        MOVE    AC,REQNUM
        MOVEM   AC,NUM3               ; save current reqnum
        MOVE    AC,REQNM2
        MOVEM   AC,REQNUM             ; for calling RDRQF
        MOVE    AC,REQVAL
        MOVEM   AC,NUM4               ; save current reqval for calling RDRQF
        PUSHJ   P,RDRQF               ; set reqval from REQNM2
        SKIPN   REQVAL
         JRST   [TYPSTR  ([ASCIZ/Gan has not been created./])
                 JRST    GETCMD]
        REQINN  (DAT,O)
         JFCL
        MOVEM   AC1,NMGAN
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,NMCOLN
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,NMDIST
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,UADIS
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,UALANC
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,UACURC
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,UASLS
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,UAPRIC
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,UARESC
 ;      REQINN  (DAT,D)
 ;       JFCL
 ;      MOVEM   AC1,ACCCC
        PUSHJ   P,RELRQI              ; close input file
        MOVE    AC,NUM3
        MOVEM   AC,REQNUM             ; put back reqnum
        MOVE    AC,NUM4
        MOVEM   AC,REQVAL             ; put back reqval
 
 
; setup NMCPAR, NMCOLN, NMIRC and NMCLSS
        MOVE    AC1,NMCPAR            ; NMCPAR is newly defined in GEYLIC
        LSH     AC1,-^D8
        MOVEM   AC1,NMCPAR
        MOVE    AC,NMPSW
        CAIE    AC,7400               ; no psw?
         JRST   .+4
        MOVE    AC1,NMCOLN
        TLO     AC1,NPS.CD            ; set no-psw bit
        MOVEM   AC1,NMCOLN
        MOVE    AC1,NMCOLN            ; colon came from old user
        LSH     AC1,-^D16
        MOVEM   AC1,NMCOLN
        SETZM   NMIRC
        MOVEI   AC1,2
        MOVEM   AC1,NMCLSS
        MOVEI   AC1,D.CLS             ; set class 2
        MOVEM   AC1,NMCLSS+1
        MOVEI   AC1,D.GRP             ; set group 1
        TRO     AC1,GRP.CD            ; set group indicator bit
        MOVEM   AC1,NMCLSS+2
        MOVE    AC1,HOST
        TRO     AC1,HOM.CD            ; set home host indicator bit
        MOVEM   AC1,NMCLSS+3
 
; add new user to cud
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,NUSMUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   N4USE1
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.GAN)       ; get gan
         JRST   GETCMD
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.UUN)       ; get uun for new user
         JRST   GETCMD
        MOVEM   AC1,NMUUN
        PUSHJ   P,GET40
        TCR     (1)
        TYPSTR  ([ASCIZ/********** The Uun for /],777,0,T.P0,N)
        TYPSTR  (NNMSPC,L.UNM,1,0,N)
        TYPSTR  ([ASCIZ/is /],777,1,0,N)
        TYPNUM  (NMUUN,O,5)
        MOVE    AC1,NMCPAR            ; return for next entry
        LSH     AC1,^D8
        MOVEM   AC1,NMCPAR
        MOVE    AC1,NMCOLN            ; return for next entry
        LSH     AC1,^D16
        MOVEM   AC1,NMCOLN
 
; new user for the accounting system type
        PUSHJ   P,NUSACC
        PUSHJ   P,AGANS
         JRST   N4USE2
        JRST    N4ULUD
 
; add user in lud - will be treated differently according to system type
  
N4ULUD:
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; skip if 370
         JRST   NOT437
        PUSHJ   P,ADD370
        JRST    N4UDNE
NOT437: PUSHJ   P,ADD10
        JRST    N4UDNE
 
N4UDNE: PUSHJ   P,OLDA
         JRST   N4USE3
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; if 370 then update default core
         JRST   .+6
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM6
        PUSHJ   P,ADDCOR
        PUSHJ   P,OLDA
         JFCL                         ; continue even if error
; tattle
	GETT	(/ADD/)
	 JRST	N4USR4
	TTFSTR	([ASCIZ/New user of new gan after add customer/])
	PUSHJ	P,ST1UHD
	PUSHJ	P,RELTTF
 
N4USR4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	N4USRD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
         JRST   N4USRD
	JRST	N4UST2			; ABRV'ST2 is the menu output section

N4USRD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

N4USE1: ; error during add new user into the mud
        TYPSTR  ([ASCIZ/Error during Add New User in the Cud./])
        PUSHJ   P,ERRCUD
        JRST    N4USE4

N4USE2: ; error during add new user in acctg.
        TYPSTR  ([ASCIZ/Error during Add User in Acctg./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        JRST    N4USE4
 
N4USE3:	; error during add user in lud
	TYPSTR	([ASCIZ/Error during Add User in the Lud./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        SNDBYT  (ACTPRT,\B.ACOM,REVACT,I)  ; reverse last acctg. entry
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Reverse Acctg. Entry not Working!/])
                 MOVE    AC1,ACANS
                 PUSHJ   P,LUDAOT
                 JRST    GETCMD]
 
N4USE4: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    N4UST2
 
; end of code for new user  of new gan after add customer
 
DUMMY2:
        TYPSTR  ([ASCIZ/Gan :/],777,0,T.P0,N)
        TYPSTR  ([ASCIZ/to be assigned/],777,0,T.P2)
        POPJ    P,
 
GERQNM: ; get request number from new gan request
        TLNN    FLG2,V.LSQ!V.EXQ!V.PRQ
         POPJ   P,                    ; if request then REQNM2 already defined
; if examine or type or process a request, then read in last request number
; into REQNM2
        INNUM   ([ASCIZ/Request Number :/],D)
         JRST   GERQNM
        MOVEM   AC1,REQNM2
        POPJ    P,
 
RWRQNM:
        REQNOT  (REQ,REQNM2,D)
        POPJ    P,
 
CMDAUC:	 ; add user network class
	TCR	(1)
	PUSHJ	P,GETCUD
	 JRST	GETCMD
	PUSHJ	P,GTUCLS	; get class info
CMAUC1:	TCR	(1)
	PUSHJ	P,GETUNM
	 JRST	CMAUCD
	PUSHJ	P,GCREC
	 JRST	CMAUC1
	SKIPE	NMCLSS+<NMNCLS-1>*NMSZCS	; skip if last pos empty
	 JRST	CMAUCE
	PUSHJ	P,CMAUC2
	GETT	(/ADD/)
	 JRST	CMAUC1
	TTFSTR	([ASCIZ/Add User Class./])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
	JRST	CMAUC1

CMAUCD:
	TRO	FLG,U.OKAY
	POPJ	P,
CMAUCE:
	TYPSTR	([ASCIZ/Too many class positions./])
	 JRST	CMAUC1

CMAUC2:
	SNDBYT	(CUDPRT,\B.CCOM,ACLMUD,I)
	PUSHJ	P,SNMCUD
CMAUCB:	SNDBYT	(CUDPRT,1,CLSWRK)
	SNDBYT	(AC,\B.CLS,CLSWRK+1)
	MOVE	AC1,CLSWRK
	MOVEM	AC1,NUM
	MOVEI	AC1,CLSWRK+2
	MOVEM	AC1,NUM1
CMAUC3:	
	SNDBYT	(AC,\B.GRPH,@NUM1)
	AOS	NUM1
	SOSG	NUM
	 JRST	CMAUC4
	JRST	CMAUC3

CMAUC4:	PUSHJ	P,SND40
	PUSHJ	P,NGANS
	 JFCL
	PUSHJ	P,NANOUT
	PUSHJ	P,GET40
	POPJ	P,
CMDAUH: ; add user host
	TCR	(1)
        PUSHJ   P,CHKFRA              ; check French validators' name
	TRO	FLG2,V.NIR
        SETZM   NUM5                  ; default system type for input user
        SETZM   MUDON                 ; for output  license
        SETZM   TCFLG                 ; for getting 370/pdp10 input
        SETZM   MFLAG                 ; for non-zero cyclinders input
        SETZM   DFLAG                 ; for getting write password

DEFINE AUSR <
	X	(NAMOUP,GEXUSR,RWUSR)
	X	(HST1OT,GEAHME,RWH37)
        X       (LICOUX,GEXLIC,WXLIC)
	X	(TMZOUT,GETTMZ,RWTMZ)
        X       (INQOUT,GETINQ,RWINQ,TCFLG,2)
        X       (OTQOUT,GETOTQ,RWOTQ,TCFLG,2)
        X       (DCOOUT,GETDCO,RWDCO,TCFLG,1)
        X       (MCOOUT,GETMCO,RWMCO,TCFLG,1)
        X       (CYLOUT,GEXCYL,RWCYL,TCFLG,1)
        X       (GRPOUT,GETGRP,RWGRP,TCFLG,1,U.PRV)  ; only priv may set pack
	X	(ST1OUT,GETST1,RWST1,MFLAG,1)
	X	(ST2OUT,GETST2,RWST2,MFLAG,1)
	X	(ST3OUT,GETST3,RWST3,MFLAG,1)
	X	(ST4OUT,GETST4,RWST4,MFLAG,1)
	X	(ST5OUT,GETST5,RWST5,MFLAG,1)
        X       (RPWOUT,GETRPW,RWRPW,MFLAG,1)
        X       (WPWOUT,GETWPW,RWWPW,DFLAG,1)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (AUH,AUSR,^D49,USRRQQ)

; code for add user host starts here, only immediate mode and
; PROCESS command can enter the following codes

        MOVE    AC,NUM5
        CAIN    AC,0                  ; skip if got the default sys. type
         JRST   ADUHST                ; add host for uun
        SETZ    AC1,
        MOVE    AC,ACTSY2             ; define pricing code for this user
        CAIE    AC,A370               ; according to new system type
         SKIPA
        MOVEI   AC1,^D8
        CAIE    AC,A10
         SKIPA
        MOVEI   AC1,1
        CAIE    AC,A940
         SKIPA
        MOVEI   AC1,5
        MOVEM   AC1,UAPRIC
        PUSHJ   P,NTYACC              ; new user for an ast
        PUSHJ   P,AGANS
         JRST   AUSRE1
        JRST    ADULUD
 
NTYACC: SNDBYT  (ACTPRT,\B.ACOM,NTYACT,I)  ; new user for an ast
        SNDBYT  (AC,\B.GAN,NMGAN)
        SNDBYT  (AC,\B.UUN,NMUUN)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        SNDBYT  (AC,\B.SLS,UASLS)
        SNDBYT  (AC,\B.PRI,UAPRIC)
        SNDBYT  (AC,\B.TZ,UATZ)
        SNDBYT  (AC,\B.RES,UARESC)
        SNDBYT  (AC,\B.HST,HOST)
        SETZM   NUM5                  ; for adding next host of same ast
        POPJ    P,
 
ADUHST: ; add host for a uun (user) in accounting
        SNDBYT  (ACTPRT,\B.ACOM,AUSACT,I)
        SNDBYT  (AC,\B.UUN,NMUUN)     ; send uun
        SNDBYT  (AC,\B.HST,HOST)      ; send host number
        PUSHJ   P,AGANS
         JRST   AUSRE2
 
; add user in lud - will be treated differently according to
; system type
  
ADULUD:
        MOVEI   AC1,UNMSPC
        MOVEM   AC1,NUM
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; skip if 370
         JRST   NOT370
        PUSHJ   P,ADD370
        JRST    ADDUDN
NOT370: PUSHJ   P,ADD10
        JRST    ADDUDN
 
ADD10:  ; add user in pdp10 lud
 
        MOVE    AC,LUXQIN
        IMULI   AC,4
        MOVEM   AC,LUXQIN
        MOVE    AC,LUXQOT
        IMULI   AC,4
        MOVEM   AC,LUXQOT
	SNDBYT	(OLDPRT,\B.LCOM,ADDLUD,I)	
        SNDSTR  (AC,L.UNM,@NUM)
        SNDBYT  (AC,\B.GAN,NMGAN)
        SNDBYT  (AC,\B.UUN,NMUUN)
        SNDBYT  (AC,\B.DIS,NMDIST)
        MOVE    AC1,LUXPRV
        LSH     AC1,-^D12
        MOVEM   AC1,LUXPRV
        SNDBYT  (OLDPRT,\B.PRV,LUXPRV)
        SNDBYT  (AC,\B.TZ,UATZ)
        SNDBYT  (AC,\B.QUOT,LUXQIN)
        SNDBYT  (AC,\B.QUOT,LUXQOT)
        MOVE    AC,LUXQIN             ; return to pages for adding next user
        IDIVI   AC,4
        MOVEM   AC,LUXQIN
        MOVE    AC,LUXQOT
        IDIVI   AC,4
        MOVEM   AC,LUXQOT
        MOVE    AC,LUXPRV             ; retrun to original input for
        LSH     AC,^D12               ; adding next user
        MOVEM   AC,LUXPRV
        POPJ    P,
 
ADD370: ; add user in 370 lud
        SKIPN   PCKG
         JRST   AD3703
        SNDBYT  (OLDPRT,\B.LCOM,SPKLUD,I)
        SNDSTR  (AC,L.PKGP,PCKG)
        PUSHJ   P,OLDA
         JRST   AD3703                ; fail, but still proceed
        JRST    AD3703
AD3702:
        SNDBYT  (OLDPRT,\B.LCOM,SAPLUD,I)
        PUSHJ   P,OLDA
         JRST   AD3703                ; fail, but still proceed
        ; set pack done, now start to add user
AD3703: SNDBYT  (OLDPRT,\B.LCOM,ADDLUD,I)
       	SNDSTR  (AC,L.UNM3,@NUM)
        SNDBYT  (AC,\B.UUN,NMUUN)
        SNDBYT  (AC,\B.GAN,NMGAN)
        SNDBYT  (AC,\B.DIS,NMDIST)
	SNDBYT	(AC,\B.TZ,UATZ)
        SNDBYT  (AC,\B.FS,LIC1)
        SNDBYT  (AC,\B.CORE,MNCOR)
        SNDBYT  (AC,\B.FS,0,I)        ; for padding only
        SNDBYT  (AC,\B.CYL,CYL)
        MOVE    AC1,MFLAG
        CAIE    AC1,1
         POPJ   P,
        SNDSTR  (OLDPRT,L.UNM3,RPW)   ; send read/write pw even if pw = .cr
        SNDSTR  (AC,L.UNM3,WPW)
        SNDSTR  (AC,L.ST,ST1)
        SNDSTR  (AC,L.ST,ST2)
        SNDSTR  (AC,L.ST,ST3)
        SNDSTR  (AC,L.ST,ST4)
        SNDSTR  (AC,L.ST,ST5)
        SNDBYT  (AC,1,CTRLD)          ; send control-d
        SNDSTR  (AC,^D119,ST3)        ; padding 119 chars.
        POPJ    P,
 
ADDUDN: PUSHJ   P,OLDA
         JRST   AUSRE3
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; if 370 then update default core
         JRST   .+6
        MOVEI   AC1,UNMSPC
        MOVEM   AC1,NUM6
        PUSHJ   P,ADDCOR
        PUSHJ   P,OLDA
         JFCL                         ; continue even if error
; tattle
	GETT	(/ADD/)
	 JRST	ADUSR4
	TTFSTR	([ASCIZ/Add User Host/])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
 
ADUSR4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	ADUSRD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
         JRST   ADUSRD
	JRST	AUHST2			; ABRV'ST2 is the menu output section

ADUSRD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

AUSRE1: ; error during add new user for an ast
        TYPSTR  ([ASCIZ/Error during Add Acctg. System Type for the User./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    AUSRE4

AUSRE2: ; error during add host for a user in acctg.
        TYPSTR  ([ASCIZ/Error during Add User in Acctg./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    AUSRE4
 
AUSRE3:	; error during add user in lud
	TYPSTR	([ASCIZ/Error during Add User in the Lud./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        SNDBYT  (ACTPRT,\B.ACOM,REVACT,I)  ; reverse last acctg. entry
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Reverse Acctg. Entry not Working!/])
                 MOVE    AC1,ACANS
                 PUSHJ   P,LUDAOT
                 JRST    GETCMD]
        JRST    AUSRE4
 
AUSRE4: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    AUHST2
 
; end of code for add user host
 
GEXUSR:
        PUSHJ   P,GETUNM
         JRST   [PUSHJ   P,INORNO
                 JRST    GEXUSR]
        TLNE    FLG2,V.LSQ            ; skip if not list request
         POPJ   P,
        PUSHJ   P,GETACC
         JRST   GETCMD
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GCREC
         JRST   GEXUS2
        PUSHJ   P,CHKUUN
         JRST   GEXUS2
        SNDBYT  (ACTPRT,\B.ACOM,LCN2CT,I)  ; list user's cid
        SNDBYT  (AC,\B.UUN,NMUUN)
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/No acctg record for this username./])
                 JRST    GEXUSR]
        GETBYT  (ACTPRT,\B.CID)
         JRST   GETCMD
        MOVEM   AC1,CUSNUM            ; save cid
 
        TLNN    FLG2,V.EXC            ; check if changing mode
         POPJ   P,
        TLNE    FLG2,V.LSQ
         POPJ   P,
        SNDBYT  (ACTPRT,\B.ACOM,KUHACT,I)  ; check user valid on the host
        SNDBYT  (AC,\B.UUN,NMUUN)
        SNDBYT  (AC,\B.HST,HOST)
        PUSHJ   P,AGANS
         JRST   GEAHM3
        TYPSTR  ([ASCIZ/User already valid on the host in acctg./])
        JRST    GEXUSR
 
GEXUS2:
        TRNN    FLG,U.RFI
         JRST   [PUSHJ   P,INORNO
                 JRST    GEXUSR]
        PUSHJ   P,REQERR
        POPJ    P,
 
GEAHME:
        INNUM   ([ASCIZ/Host :/],D)   
         JRST   [PUSHJ   P,INORNO
                 JRST    GEAHME]
        JUMPE   AC1,.-1
        MOVEM   AC1,LUDNUM
        MOVEM   AC1,HOST
        PUSHJ   P,GETOLD
         JRST   GETCMD
        MOVE    AC1,OLDASY
        MOVEM   AC1,ACTSYS
        MOVEM   AC1,ACTSY2
        MOVE    AC,NMUUN
        CAIG    AC,377777             ; skip if 18-bit uun
         JRST   GEAHM1
        CAIE    AC1,A940              ; also want to add 940 host
         JRST   GEAHM1
        TYPSTR  ([ASCIZ/can't add an 18-bit Uun to 940 host/])
        JRST    GETCMD
GEAHM1: SETZM   TCFLG
        SETZM   MFLAG
        SETZM   DFLAG
        CAIE    AC1,A10               ; set flags
         JRST   .+3
        MOVEI   AC,2
        MOVEM   AC,TCFLG
        CAIE    AC1,A370
         JRST   .+3
        MOVEI   AC,1
        MOVEM   AC,TCFLG
        TLNE    FLG2,V.LSQ
         POPJ   P,
        SNDBYT  (ACTPRT,\B.ACOM,KUHACT,I)  ; check user valid on the host
        SNDBYT  (AC,\B.UUN,NMUUN)
        SNDBYT  (AC,\B.HST,HOST)
        PUSHJ   P,AGANS
         JRST   GEAHM2
        TYPSTR  ([ASCIZ/User already valid on the host in acctg./])
        JRST    GEAHM4
GEAHM2:
        PUSHJ   P,GCAREK              ; get customer acctg. info for using
         SKIPA                        ; to get tym.cd lic
        JRST    GEAHM3
        TYPSTR  ([ASCIZ/Customer is not valid on this system type./])
        JRST    GEAHM4
GEAHM3: ; check user is valid on this ast, if not then get default ast NUM5
        ; then get acctg. record of this user for adding new system type
        ; for this user
        SNDBYT  (ACTPRT,\B.ACOM,LUDACT,I)   ; get district for uun
        SNDBYT  (AC,\B.UUN,NMUUN)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        PUSHJ   P,AGANS
         JRST   GEXSYS                ; get default ast then get acctg. rec
        GETBYT  (AC,\B.DIS)           ; get district
         JRST   GETCMD
        POPJ    P,
GEAHM4: TRNN    FLG,U.RFI
         JRST   [PUSHJ   P,INORNO
                 JRST    GEAHME]
        PUSHJ   P,REQERR
        POPJ    P,
 
GEXSYS:
        SNDBYT  (ACTPRT,\B.ACOM,LUTACT,I)  ; get user's acctg. system type
        SNDBYT  (AC,\B.UUN,NMUUN)
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/No acctg. record for this user./])
                 JRST    GEXUSR]
        GETBYT  (AC)
         JRST   GETCMD
        MOVE    AC1,ASMTAB(AC1)
        MOVEM   AC1,NUM5              ; load in acctg. system type
        SNDBYT  (ACTPRT,\B.ACOM,LUEACT,I)  ; get user acctg. info
        SNDBYT  (AC,\B.UUN,NMUUN)
        SNDBYT  (AC,\B.ACOM,NUM5)
        PUSHJ   P,AGANS
         JRST   [PUSHJ   P,GUARCE
                 JRST    GETCMD]
        GETBYT  (AC,\B.GAN)
         JRST   GETCMD
        PUSHJ   P,GNAMAC              ; get username
        GETBYT  (AC,\B.DIS)
         JRST   GETCMD
        MOVEM   AC1,UADIS
        GETBYT  (AC,\B.CID)
         JRST   GETCMD
        MOVEM   AC1,UACID
        PUSHJ   P,GCNAAC
        GETBYT  (AC,\B.CC)
         JRST   GETCMD
        GETBYT  (AC,\B.SLS)
         JRST   GETCMD
        MOVEM   AC1,UASLS
        GETBYT  (AC,\B.PRI)
         JRST   GETCMD
        MOVEM   AC1,UAPRIC
        GETBYT  (AC,\B.RES)
         JRST   GETCMD
        MOVEM   AC1,UARESC
        GETBYT  (AC,\B.CUR)
         JRST   GETCMD
        MOVEM   AC1,UACURC
        GETBYT  (AC,\B.LAN)
         JRST   GETCMD
        MOVEM   AC1,UALANC
        GETBYT  (AC,\B.TZ)
         JRST   GETCMD
        MOVEM   AC1,UATZ
        PUSHJ   P,GHSTAC
        POPJ    P,
 
GEXCYL:
        SETZM   MFLAG                 ; for getting 370-mdisk info
        INNUM   ([ASCIZ/Cylinders (3330) :/],D)
         JRST   [PUSHJ   P,INORNO
                 JRST    GEXCYL]
        CAILE   AC1,MAX.CY
         JRST   [PUSHJ   P,INORNO
                 JRST    GEXCYL]
        MOVEM   AC1,CYL
        CAIN    AC1,0
         POPJ   P,
        MOVEI   AC,1
        MOVEM   AC,MFLAG
        POPJ    P,
 
LICOUX:
        MOVE    AC,ACTSYS
        CAIN    AC,A10
         JRST   OUT1LS
        JRST    OUT3LS
 
GEXLIC:
        TLNN    FLG2,V.LSQ
         JRST   GEXLI1
        PUSHJ   P,GETCUD              ; if this is type req. command, then we
         JRST   GETCMD                ; have to get NMCPAR from cud
        PUSHJ   P,GCREC
         JRST   GETCMD
GEXLI1: TRNE    FLG,U.RFI             ; skip if input not from request file
         JRST   GEXLI2
        TYPSTR  ([ASCIZ/Lic : /])
GEXLI2: MOVE    AC,ACTSYS
        CAIN    AC,A10
         JRST   GEX1LS
        ; get lic1 for 370 host
        SETZM   AC
        SETZM   LIC1                  ; for routine licout
        SETZM   LIC2                  ; for routine licout
        GETYR   ([ASCIZ/Tym? /])
         JRST   .+4
        MOVE    AC,LIC1
        TRO     AC,1B35
        MOVEM   AC,LIC1
        GETYR   ([ASCIZ/A. S.? /])
         JRST    .+4
        MOVE    AC,LIC1
        TRO     AC,1B32
        MOVEM   AC,LIC1
        GETYR   ([ASCIZ/Hush? /])
         JRST    .+4
        MOVE    AC,LIC1
        TRO     AC,1B31
        MOVEM   AC,LIC1
        GETYR   ([ASCIZ/Vgan? /])
         JRST   .+4
        MOVE    AC,LIC1
        TRO     AC,1B33
        MOVEM   AC,LIC1
        POPJ    P,
GEX9LS:
        POPJ    P,
GEX1LS:
        SETZM   AC
        SETZM   LUXPRV
        GETYR   ([ASCIZ/Tym? /])
         JRST   .+4
        MOVE    AC,LUXPRV
        TLO     AC,TYM.LX
        MOVEM   AC,LUXPRV
        GETYR   ([ASCIZ/A. S.? /])
         JRST    .+4
        MOVE    AC,LUXPRV
        TLO     AC,AS.LX
        MOVEM   AC,LUXPRV
        GETYR   ([ASCIZ/Hush? /])
         JRST    .+4
        MOVE    AC,LUXPRV
        TLO     AC,HSH.LX
        MOVEM   AC,LUXPRV
        GETYR   ([ASCIZ/Gfd? /])
         JRST   .+4
        MOVE    AC,LUXPRV
        TLO     AC,GFD.LX
        MOVEM   AC,LUXPRV
        PUSHJ   P,GTMODE
        POPJ    P,
 
WXLIC:
        MOVE    AC,ACTSYS
        CAIN    AC,A10
         JRST   RW10LI                ; write lic for pdp-10 host
        CAIN    AC,A940
         POPJ   P,
        ; write lic1 for 370 host
        MOVE    AC1,LIC1
        TRNN    AC1,1B35
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LIC1
        TRNN    AC1,1B32
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LIC1
        TRNN    AC1,1B31
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LIC1
        TRNN    AC1,1B33
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        POPJ    P,
RW10LI:
        MOVE    AC1,LUXPRV
        TLNN    AC1,TYM.LX
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LUXPRV
        TLNN    AC1,AS.LX 
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LUXPRV
        TLNN    AC1,HSH.LX
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC1,LUXPRV
        TLNN    AC1,GFD.LX
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        JRST    RWMODE
 
RPWOUT:
        MOVE    AC1,DFLAG
        CAIN    AC1,0
         JRST   RPWOU2
        TYPSTR  ([ASCIZ/Read Password :/],777,0,T.P0,N)
        TYPSTR  (RPW,L.UNM3,0,T.P2)
        POPJ    P,
RPWOU2:
        TYPSTR  ([ASCIZ/No Read and Write Password/],777,0,T.P0)
        POPJ    P,
 
GETRPW:
        INSTR   ([ASCIZ/Read Password :/],RPW,L.UNM3)
        MOVEI   AC1,L.UNM3
        MOVEI   AC,RPW
        PUSHJ   P,CNTCHR
        SKIPE   AC1
         JRST   GETRP1
        MOVE    AC,RPW
        MOVEM   AC,WPW
        POPJ    P,
GETRP1:
        MOVEI   AC,1
        MOVEM   AC,DFLAG
        POPJ    P,
 
RWRPW:
        REQOUT  (REQ,RPW,L.UNM3)
        POPJ    P,
 
WPWOUT:
        TYPSTR  ([ASCIZ/Write Password :/],777,0,T.P0,N)
        TYPSTR  (WPW,L.UNM3,0,T.P2)
        POPJ    P,
 
GETWPW:
        INSTR   ([ASCIZ/Write Password :/],WPW,L.UNM3)
        POPJ    P,
 
RWWPW:
        REQOUT  (REQ,WPW,L.UNM3)
        POPJ    P,
 
ADDCOR: SETZM   EFLAG
        MOVEI   AC,^D255
        MOVEM   AC,OFLAG              ; do not change max. core
        SNDBYT  (OLDPRT,\B.LCOM,CCOLUD,I)   ; change core
        SNDSTR  (AC,L.UNM3,@NUM6)
        SNDBYT  (AC,\B.VPRI,EFLAG)
        SNDBYT  (AC,\B.CORE,DNCOR)
        SNDBYT  (AC,\B.VPRI,OFLAG)
        SNDBYT  (AC,\B.CORE,MNCOR)
        POPJ    P,
DEFINE NEW1 <
	X USER,1,CMDNUS,U.PRV!U.DIS!U.NET,-1  ; new user 
	X CUSTO,2,CMDNCS,U.PRV!U.DIS!U.NET!U.AP,-1  ; new customer
	X GAN,1,CMDNGA,U.PRV!U.DIS,-1         ; new gan
	X ARMY,1,CMDNAM,U.PRV,-1              ; new army
	X SPC1,1,CMDSP1,U.PRV,-1              ; special new user 
	X IAFP,1,CMDIFP,U.PRV,-1              ; iafp new user
	X COEES,2,CMDCOE,U.PRV!U.NET,-1       ; new coees user
 >

	SUBCOM	([ASCIZ/New :/],NEW,NEW1)
CMDNUS: ; new user 
	TCR	(1)
        PUSHJ   P,CHKFRA              ; check French validators' name
	TRO	FLG2,V.NIR
        TRZ     FLG2,V.GAN            ; for using GEYLIC
        SETZM   MUDON                 ; for output  license
        SETZM   TCFLG                 ; for pdp10/370 input
        SETZM   MFLAG                 ; for non-zero cyclinders input
        SETZM   DFLAG                 ; for getting write password

DEFINE NUSR <
	X	(SYSOUT,GEYSYS,RWSYS)
        X       (CSNOUX,GEXCSN,RWCSN)
        X       (GANOU1,GEYGAN,RWUSR)
	X	(NNMOUT,GETNNM,RWNNM)
        X       (PSWOUT,GEYPSW,RWPSW)
        X       (COCOUT,GETCOC,RWCOC)
	X	(HST1OT,GEYHME,RWH37)
        X       (LICOUX,GEYLIC,WYLIC)
	X	(TMZOUT,GETTMZ,RWTMZ)
        X       (INQOUT,GETINQ,RWINQ,TCFLG,2)
        X       (OTQOUT,GETOTQ,RWOTQ,TCFLG,2)
        X       (DCOOUT,GETDCO,RWDCO,TCFLG,1)
        X       (MCOOUT,GETMCO,RWMCO,TCFLG,1)
        X       (CYLOUT,GEXCYL,RWCYL,TCFLG,1)
        X       (GRPOUT,GETGRP,RWGRP,TCFLG,1,U.PRV)  ; only priv may set pack
	X	(ST1OUT,GETST1,RWST1,MFLAG,1)
	X	(ST2OUT,GETST2,RWST2,MFLAG,1)
	X	(ST3OUT,GETST3,RWST3,MFLAG,1)
	X	(ST4OUT,GETST4,RWST4,MFLAG,1)
	X	(ST5OUT,GETST5,RWST5,MFLAG,1)
        X       (RPWOUT,GETRPW,RWRPW,MFLAG,1)
        X       (WPWOUT,GETWPW,RWWPW,DFLAG,1)
        X       (NDISOU,GENDIS,RWNDIS)           ; get district for ast = 9
        X       (MUUNOU,GEMUUN,RWMUUN)           ; get muun
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC  (NUS,NUSR,^D50,CUSRQQ)

; code for add new user starts here, only immediate mode and
; PROCESS command can enter the following codes

; setup NMCPAR, NMCOLN, NMIRC and NMCLSS
        MOVE    AC1,NMCPAR            ; NMCPAR is newly defined in GEYLIC
        LSH     AC1,-^D8
        MOVEM   AC1,NMCPAR
        MOVE    AC,NMPSW
        CAIE    AC,7400               ; no psw?
         JRST   .+4
        MOVE    AC1,NMCOLN            ; colon came from old user
        TLO     AC1,NPS.CD            ; set no-psw bit
        MOVEM   AC1,NMCOLN
        MOVE    AC1,NMCOLN
        LSH     AC1,-^D16
        MOVEM   AC1,NMCOLN
        SETZM   NMIRC
        MOVEI   AC1,2
        MOVEM   AC1,NMCLSS
        MOVEI   AC1,D.CLS             ; set class 2
        MOVEM   AC1,NMCLSS+1
        MOVEI   AC1,D.GRP             ; set group 1
        TRO     AC1,GRP.CD            ; set group indicator bit
        MOVEM   AC1,NMCLSS+2
        MOVE    AC1,HOST
        TRO     AC1,HOM.CD            ; set home host indicator bit
        MOVEM   AC1,NMCLSS+3
 
; add new user to cud
        PUSHJ   P,NUSMUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   NUSRE1
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.GAN)       ; get gan
         JRST   GETCMD
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.UUN)       ; get uun for new user
         JRST   GETCMD
        MOVEM   AC1,NMUUN
        PUSHJ   P,GET40
        TCR     (1)
        TYPSTR  ([ASCIZ/********** The Uun for /],777,0,T.P0,N)
        TYPSTR  (NNMSPC,L.UNM,1,0,N)
        TYPSTR  ([ASCIZ/is /],777,1,0,N)
        TYPNUM  (NMUUN,O,5)
        MOVE    AC1,NMCPAR            ; return for next entry
        LSH     AC1,^D8
        MOVEM   AC1,NMCPAR
        MOVE    AC1,NMCOLN            ; return for next entry
        LSH     AC1,^D16
        MOVEM   AC1,NMCOLN
 
; new user for the accounting system type
        MOVE    AC1,ACDEFP            ; load in customer's price code
        MOVEM   AC1,UAPRIC            ; assign it to user
        PUSHJ   P,NUSACC
        PUSHJ   P,AGANS
         JRST   NUSRE2
        MOVE    AC1,TDIST
        CAIN    AC1,0
         JRST   NUSLUD
        MOVE    AC1,NMDIST
        MOVEM   AC1,TDIST
        PUSHJ   P,NUSNET
        PUSHJ   P,AGANS
         JRST   NUSRE2
        JRST    NUSLUD
 
NUSMUD: MOVE    AC,ACTSY2
        CAIN    AC,A940
         JRST   N17BIT                     
        SNDBYT  (CUDPRT,\B.CCOM,NEWMU2,I)   ; ask for 18-bit uun
        JRST    NUSCON
N17BIT: SNDBYT  (CUDPRT,\B.CCOM,NEWMUD,I)   ; ask for 17-bit uun
NUSCON: PUSHJ   P,NNMCUD
        SNDBYT  (CUDPRT,\B.CYP,NMPSW) ; send password cipher
        SNDBYT  (AC,1,0,I)
        SNDBYT  (AC,\B.GAN,NMGAN)
        SNDBYT  (AC,1,0,I)
        SETZM   NMUUN
        SNDBYT  (AC,\B.UUN,NMUUN)     
        SNDBYT  (AC,\B.CPR,NMCPAR)
        SNDBYT  (AC,\B.CLN,NMCOLN)
        SNDBYT  (AC,\B.CDST,NMDIST)   ; NMDIST came from old user
        SNDBYT  (AC,\B.IRC,NMIRC)
        SNDBYT  (AC,1,NMCLSS)
        SNDBYT  (AC,2,NMCLSS+1)
        SNDBYT  (AC,2,NMCLSS+2)
        SNDBYT  (AC,2,NMCLSS+3)
        POPJ    P,
 
NUSACC: SNDBYT  (ACTPRT,\B.ACOM,NUSACT,I)  ; new user in acctg.
        SNDBYT  (AC,\B.GAN,NMGAN)
        SNDBYT  (AC,\B.UUN,NMUUN)
        SNDBYT  (AC,\B.ACOM,ACTSY2)
        SNDSTR  (AC,L.UNM,NNMSPC)
        SNDBYT  (AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.DIS,UADIS)
        SNDBYT  (AC,\B.LAN,UALANC)
        SNDBYT  (AC,\B.CUR,UACURC)
        SNDBYT  (AC,\B.SLS,UASLS)
        SNDBYT  (AC,\B.PRI,UAPRIC)
        SNDBYT  (AC,\B.TZ,UATZ)
        SNDBYT  (AC,\B.RES,UARESC)
        SNDBYT  (AC,\B.HST,HOST)
        SNDBYT  (AC,\B.CC,ACCCC)
        POPJ    P,
 
NUSNET: SNDBYT  (ACTPRT,\B.ACOM,ATYACT,I)    ; new user in tuserdb
        SNDBYT  (AC,\B.GAN,NMGAN)
        SNDBYT  (AC,\B.UUN,NMUUN)
        SNDSTR  (AC,L.UNM,NNMSPC)
        SNDBYT  (AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.DIS,TDIST)
        SNDBYT  (AC,\B.UUN,MMUUN)
        SNDBYT  (AC,\B.CC,TCCCC) 
        POPJ    P,
 
; add user in lud - will be treated differently according to system type
  
NUSLUD:
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; skip if 370
         JRST   NOTN37
        PUSHJ   P,ADD370
        JRST    NUSDNE
NOTN37: CAIE    AC,A940               ; skip if 940
         JRST   NOTN94
        PUSHJ   P,ADD940
        JRST    NUSDNE
NOTN94: PUSHJ   P,ADD10
        JRST    NUSDNE
 
NUSDNE: PUSHJ   P,OLDA
         JRST   NUSRE3
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; if 370 then update default core
         JRST   .+6
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM6
        PUSHJ   P,ADDCOR
        PUSHJ   P,OLDA
         JFCL                         ; continue even if error
; tattle
	GETT	(/ADD/)
	 JRST	NEUSR4
	TTFSTR	([ASCIZ/New User/])
	PUSHJ	P,ST1UHD
	PUSHJ	P,RELTTF
 
NEUSR4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	NEUSRD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
         JRST   NEUSRD
	JRST	NUSST2			; ABRV'ST2 is the menu output section

NEUSRD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

NUSRE1: ; error during add new user into the mud
        TYPSTR  ([ASCIZ/Error during Add New User in the Cud./])
        PUSHJ   P,ERRCUD
        JRST    NUSRE4

NUSRE2: ; error during add new user in acctg.
        TYPSTR  ([ASCIZ/Error during Add User in Acctg./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        JRST    NUSRE4
 
NUSRE3:	; error during add user in lud
	TYPSTR	([ASCIZ/Error during Add User in the Lud./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        SNDBYT  (ACTPRT,\B.ACOM,REVACT,I)  ; reverse last acctg. entry
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Reverse Acctg. Entry not Working!/])
                 MOVE    AC1,ACANS
                 PUSHJ   P,LUDAOT
                 JRST    GETCMD]
 
NUSRE4: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    NUSST2
 
; end of code for new user 
 
GEYSYS: ; get accounting system type and set flags
        PUSHJ   P,INASYS
        MOVE    AC1,ACTSYS
        CAIN    AC1,0
         JRST   GEYSYS                ; ask again if enter cr
        SETZM   TCFLG
        SETZM   MFLAG
        SETZM   DFLAG
        CAIE    AC1,A10
         JRST   .+3
        MOVEI   AC,2
        MOVEM   AC,TCFLG
        CAIE    AC1,A370
         JRST   .+3
        MOVEI   AC,1
        MOVEM   AC,TCFLG
        POPJ    P,
 
CSNOUX:
        TYPSTR  ([ASCIZ/Cid :/],777,0,T.P0,N)
        TYPNUM  (CUSNUM,D,0,T.P2)
        POPJ    P,
 
GEXCSN: ; get cid
        PUSHJ   P,GETCUS
         JRST   .-1
        TLNE    FLG2,V.LSQ
         POPJ   P,
        PUSHJ   P,GETACC
         JRST   GETCMD
        MOVE    AC1,ACTSYS
        MOVEM   AC1,ACTSY2
        PUSHJ   P,CHKCUS              ; check access
         JRST   GEXCSN
        PUSHJ   P,GCAREK              ; get customer acctg. info for using
         SKIPA                        ; to get tym.cd license
        POPJ    P,
        TYPSTR  ([ASCIZ/Invalid Customer in this acctg. system type./])
        JRST    GEXCSN
GEXCS2: ; the following code will not be used
        SETZM   TDIST
        MOVE    AC,ACCNAM             ; load in customer name's address
        CAME    AC,[ASCII/FORD /]
         POPJ   P,                    ; return if not FORD
        MOVE    AC,ACCNAM+1
        CAME    AC,[ASCII/MOTOR/]   
         POPJ   P,                       
        MOVEI   AC1,^D9
        MOVEM   AC1,A9
        SNDBYT  (ACTPRT,\B.ACOM,LCD2CT,I)  ; get TDIST from ast = 9
        SNDBYT  (AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ASY,A9)
        PUSHJ   P,AGANS
         POPJ   P,                    ; return if no record for ast 9
        GETBYT  (ACTPRT,\B.DIS)
         JRST   GETCMD
        MOVEM   AC1,TDIST
        MOVEI   AC,233167
        MOVEM   AC,MMUUN              ; 233167 is muun for ford special users
        POPJ    P,
 
GEYGAN:
        INSTR   ([ASCIZ/Username in desired Gan :/],UNMSPC,L.UNM,T)
        MOVEI   AC,UNMSPC
        MOVEI   AC1,L.UNM
        PUSHJ   P,CNTCHR
        SKIPG   AC1
         JRST   [PUSHJ   P,INORNO
                 JRST    GEYGAN]
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GCREC               ; get cud record before testing it is 
         JRST   [PUSHJ   P,INORNO     ; a type request command or not. Since
                 JRST    GEYGAN]      ; gan will be displayed in output menu
        TLNE    FLG2,V.LSQ
         POPJ   P,
        MOVE    AC,NMDIST
        MOVEM   AC,DISRCT             ; for calling CHKGAN
        MOVE    AC,NMGAN
        MOVEM   AC,GLOBAC             ; for calling CHKGAN
        PUSHJ   P,GETACC
         JRST   GETCMD
  ;     SNDBYT  (ACTPRT,\B.ACOM,LCN2CT,I)   ; list cid for uun
  ;     SNDBYT  (AC,\B.UUN,NMUUN)
  ;     PUSHJ   P,AGANS
  ;      JRST   [PUSHJ   P,INORNO
  ;              JRST    GEYGAN]
  ;     GETBYT  (ACTPRT,\B.CID)       ; get cid for calling CHKGAN
  ;      JRST   GETCMD
  ;     CAME    AC1,CUSNUM
  ;      JRST   [TYPSTR  ([ASCIZ/User's cid does not agree with input cid./])
  ;              JRST    GEYGAN]
   ;    TLNN    FLG,U.ASV
   ;     JRST   .+3
   ;    MOVE    AC1,MY.GAN
   ;    MOVEM   AC1,GLOBAC
        PUSHJ   P,CHKGAN              ; check access
         JRST   GEYGAN
        ; check user is valid on the input acctg. system type, if not then
        ; get default system type NUM1. Then we always have ast for getting
        ; acctg. record of this user. These acctg. info will be used to
        ; establish acctg. record for the new user.
        PUSHJ   P,GUAREK              ; get user acctg. record in ACTSY2
         JRST   GEXSYS                ; get default ast then acctg. rec
        POPJ    P,
 
GEYHME:
        INNUM   ([ASCIZ/Host :/],D)   
         JRST   [PUSHJ   P,INORNO
                 JRST    GEYHME]
        JUMPE   AC1,.-1
        MOVEM   AC1,LUDNUM
        MOVEM   AC1,HOST
        TLNE    FLG2,V.LSQ
         POPJ   P,
        PUSHJ   P,GETOLD
         JRST   GETCMD
        MOVE    AC1,OLDASY
        CAMN    AC1,ACTSYS
         POPJ   P,
        TYPSTR  ([ASCIZ/Mismatch between host and system type./])
        TRNN    FLG,U.RFI
         JRST   [PUSHJ   P,INORNO
                 JRST    GEYHME]
        PUSHJ   P,REQERR
        POPJ    P,
 
 
PSWOUT:
        TYPSTR  ([ASCIZ/Password - Not Shown/],777,0,T.P0)
        POPJ    P,
 
GEYPSW: ; get password and check cipher not equal to new username's cipher
        PUSHJ   P,GETPSW
         JRST   GETCMD
        TLNE    FLG2,V.LSQ
         POPJ   P,
        MOVE    AC,NMPSW
        CAIN    AC,7400               ; 7400 is null psw cipher  (no psw)
         POPJ   P,                    ; return if it is null psw cipher
        MOVEI   AC,NNMSPC
        MOVEM   AC,NUM2               ; for calling CYPNAM
        PUSHJ   P,CYPNAM              ; cipher new username
        CAMN    AC1,NMPSW             ; cipher same as password cipher?
         JRST   [TYPSTR  ([ASCIZ/Error - Password same as Username./])
                 JRST    GEYPSW]
        TLNE    FLG2,V.NPS            ; skip if psw has no non-alphas
         POPJ   P,
        MOVE    AC,NMGAN              ; for calling PASGEX
        PUSHJ   P,PASGEX              ; see if exempt from non-alpha stds
         JRST   [TYPSTR  (PE4,777,1)  ; PE4 tells password no non-alphas
                 JRST    GEYPSW]
        POPJ    P,
 
RWPSW:  ; write password cipher (not password!)
        REQNOT  (REQ,NMPSW,D)
        POPJ    P,
 
COCOUT:
        TYPSTR  ([ASCIZ/Cost Code :/],777,0,T.P0,N)
        TYPNUM  (ACCCC,D,0,T.P2)
        POPJ    P,
 
GETCOC:
        INNUM   ([ASCIZ/Cost Code :/],D)
         JRST   GETCO2
        CAIL    AC1,^D9999
         JRST   GETCO2
        CAIG    AC1,^D1000
         JRST   GETCO2
        MOVEM   AC1,ACCCC
        POPJ    P,
   
GETCO2:
        TYPSTR  ([ASCIZ/Cost Code out of range./])
        PUSHJ   P,INORNO
        JRST    GETCOC
 
RWCOC:
        REQNOT  (REQ,ACCCC,D)
        POPJ    P,
 
TCCOUT:
        TYPSTR  ([ASCIZ/Cost Code :/],777,0,T.P0,N)
        TYPNUM  (TCCCC,D,0,T.P2)
        POPJ    P,
 
GETTCC:
        INNUM   ([ASCIZ/Cost Code :/],D)
         JRST   GETTC2
        CAIL    AC1,^D7000
         JRST   GETTC2
        CAIG    AC1,^D1000
         JRST   GETTC2
        MOVEM   AC1,TCCCC
        POPJ    P,
   
GETTC2:
        TYPSTR  ([ASCIZ/Cost Code out of range./])
        PUSHJ   P,INORNO
        JRST    GETTCC
 
RWTCC:
        REQNOT  (REQ,TCCCC,D)
        POPJ    P,
 
GEYLIC:
        TRNE    FLG,U.RFI             ; skip if input not from request file
         JRST   GEYLI2
        TYPSTR  ([ASCIZ/Lic : /])
GEYLI2: SETZM   NMCPAR
        MOVE    AC,ACTSYS
        CAIN    AC,A10
         JRST   GEY1LS
        JRST    GEY3LS
 
GEY1LS: ; get new user license for pdp10 ast
        SETZM   LUXPRV
        MOVE    AC1,ACINVC                 ; if req. then define TYM.CD from
        CAIE    AC1,3                      ; invoice code  3
         JRST   GE1ACS
        MOVE    AC,LUXPRV
        TLO     AC,TYM.LX
        MOVEM   AC,LUXPRV
GE1ACS:
        TRNN    FLG2,V.GAN
         JRST   PR1ACS
        JRST    SET1AS
PR1ACS:
        GETYR   ([ASCIZ/A.S.? /])
         JRST   GTMOD1
SET1AS: MOVE    AC,LUXPRV
        TLO     AC,AS.LX
        MOVEM   AC,LUXPRV
GTMOD1: PUSHJ   P,GTMODE
        POPJ    P,
 
GEY3LS: ; get new user license for 370 ast
        SETZM   LIC1
        SETZM   LIC2
        MOVE    AC1,ACINVC                 ; if req. then define TYM.CD from
        CAIE    AC1,3                      ; invoice code  3
         JRST   GE3ACS
        MOVE    AC,LIC1
        TRO     AC,1B35
        MOVEM   AC,LIC1
GE3ACS:
        TRNN    FLG2,V.GAN
         JRST   PR3ACS
        JRST    SET3AS
PR3ACS:
        GETYR   ([ASCIZ/A.S.? /])
         JRST   GE3RES
SET3AS: MOVE    AC,LIC1
        TRO     AC,1B32
        MOVEM   AC,LIC1
GE3RES:
        GETYR   ([ASCIZ/Hush? /])
         JRST   .+4
        MOVE    AC,LIC1
        TRO     AC,1B31
        MOVEM   AC,LIC1
        GETYR   ([ASCIZ/Vlog? /])
         JRST   .+4
        MOVE    AC,LIC1
        TRO     AC,1B34
        MOVEM   AC,LIC1
        GETYR   ([ASCIZ/Vgan? /])
         JRST   .+4
        MOVE    AC,LIC1
        TRO     AC,1B33
        MOVEM   AC,LIC1
        ; set focus bit
        MOVE    AC1,ACFOCF            ; acfocf came from customer acctg. rec
        CAIE    AC1,1
         POPJ   P,
        MOVE    AC,LIC1
        TRO     AC,1B30
        MOVEM   AC,LIC1
        POPJ    P,
 
WYLIC:
        MOVE    AC,ACTSYS
        CAIN    AC,A10
         JRST   WY1LS
        JRST    WY3LS
WY1LS:
        TRNE    FLG2,V.GAN
         JRST   WY1RES
        MOVE    AC,LUXPRV
        TLNN    AC,AS.LX
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
WY1RES: PUSHJ   P,RWMODE
        POPJ    P,
WY3LS:
        TRNE    FLG2,V.GAN
         JRST   WY3RES
        MOVE    AC,LIC1
        TRNN    AC,1B32
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
WY3RES: MOVE    AC,LIC1
        TRNN    AC,1B31
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC,LIC1
        TRNN    AC,1B34
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        MOVE    AC,LIC1
        TRNN    AC,1B33
         PUSHJ  P,WRNO
        PUSHJ   P,WRYES
        POPJ    P,
 
 
CMDNCS: ; new customer
	TCR	(1)
        PUSHJ   P,CHKFRA              ; check French validators' name
        SETZM   REQNM1                ; set request number of this (new cust-
                                      ; omer) request to 0. REQNM1 will be used
                                      ; to retrieve (new cid) in the subsequent
                                      ; requests.
        SETZM   REQNM2                ; set request number of new gan after
                                      ; this new customer request to 0. Note
                                      ; REQNM2 \= 0 means new gan has been
                                      ; established. REQNM2 also will be used
                                      ; to retrieve (new) gan in subsequent
                                      ; requests.
        TRZ     FLG2,V.XNC            ; assume not special ast
        TRO     FLG2,V.NCS            ; for define REQNM1 in EXMMAC
	TRO	FLG2,V.NIR

DEFINE NCUS <
	X	(SYSOUT,GEZSYS,RWSYS)
	X	(DISTOU,GEXDIS,RWDIST)
	X	(CNAOUT,GETCNA,RWCNA)
        X       (COCOUT,GETCOC,RWCOC)
	X	(AD1OUT,GETAD1,RWAD1)
	X	(AD2OUT,GETAD2,RWAD2)
	X	(CTYOUT,GETCTY,RWCTY)
	X	(STAOUT,GETSTA,RWSTA)
	X	(ZIPOUT,GETZIP,RWZIP)
	X	(CTROUT,GETCTR,RWCTR)
	X	(ATTOUT,GETATN,RWATN)
        X       (INVOUX,GEXINV,RWINV)
        X       (PRXOUT,GETPRX,RWPRX,FLG2,V.NIR) ; if non-immediate or req
	X	(SALOUT,GETSAL,RWSAL)
	; X	(CINOUT,GETCIN,RWCIN)
	X	(POOUT,GETPO,RWPO)
	X	(POSOUT,GETPOS,RWPOS)
	X	(POEOUT,GETPOE,RWPOE)
	X	(POMOUT,GETPOM,RWPOM)
	X	(DETOUT,GEXDET,RWDET)
        X       (FOCOUT,GETFFF,RWFOC,TCFLG,1)    ; for 370 only
          ;  X       (AMTOUT,GETAMT,RWAMT)
          ;  X       (SRNOUT,GETSRN,RWSRN)
          ;  X       (PRDOUT,GETPRD,RWPRD)
          ;  X       (DPTOUT,GETDPT,RWDPT)
        X       (NDISOU,GENDIS,RWNDIS)           ; get district for ast = 9
        X       (NCCCOU,GENCCC,RWNCCC)           ; get costcode for ast = 9
        X       (NSLSOU,GENSLS,RWNSLS)           ; get salesman no. for ast = 9
        X       (MUUNOU,GEMUUN,RWMUUN)           ; get muun
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC (NCS,NCUS,^D52,CUSRQQ)

; code for new customer starts here, only immediate mode and PROCESS
; can enter
; first get new customer number from mud
 
        PUSHJ   P,GETACC
         JRST   GETCMD
        SNDBYT  (ACTPRT,\B.ACOM,NIDACT,I)
        PUSHJ   P,AGANS
         JRST   NCUSE0
        GETBYT  (ACTPRT,\B.CID)
         JRST   GETCMD
        MOVEM   AC1,CUSNUM
        TCR     (1)
        TYPSTR  ([ASCIZ/********** The Cid for /],777,0,1,N)
        TYPSTR  (NCNMSP,L.CUSN,1,0,N)
        TYPSTR  ([ASCIZ/is /],777,1,0,N)
        TYPNUM  (CUSNUM,D,5)
        TCR     (1)
 
; next, update customer industry code in the mud
 
 ;      SNDBYT  (CUDPRT,\B.CCOM,CCIMUD,I)
 ;      SNDBYT  (AC,\B.CID,CUSNUM)
 ;      SNDBYT  (AC,\B.IND,NMSIC)
 ;      PUSHJ   P,SND40
 ;      PUSHJ   P,NGANS
 ;       JRST   NCUSE1
 ;      GETBYT  (CUDPRT,2)           ; get 2 bytes
 ;       JRST   GETCMD
 ;      PUSHJ   P,GET40
  
; third, add new customer record into acctg.
 
        PUSHJ   P,GETACC
         JRST   GETCMD
        SETZM   ACVPF                 ; set variable pricing flag to zero
        MOVEI   AC1,1
        MOVEM   AC1,ACMINC            ; set minimum code to 1
        TRNN    FLG2,V.NCS            ; skip if new cust of ast 1,2 or 3
         JRST   NEWCS1
        MOVE    AC,ACINVC
        CAIN    AC,3                  ; skip if billable
         JRST   NEWCS1
        MOVEI   AC1,^D99              ; only billable and ast = 1,2 or 3
        MOVEM   AC1,ACDEFP            ; set default price code 99
NEWCS1: SNDBYT  (ACTPRT,\B.ACOM,NCUACT,I)       ; new customer in acctg.
        SNDBYT  (AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ASY,ACTSYS)
        SNDSTR  (AC,L.CUSN,NCNMSP)
        SNDBYT  (AC,\B.DIS,DISRCT)
        SNDBYT  (AC,\B.DET,ACDETC)
        SNDBYT  (AC,\B.INV,ACINVC)
        SNDBYT  (AC,\B.MIN,ACMINC)
        SNDBYT  (AC,\B.SLS,UASLS)
        SNDSTR  (AC,L.PO,ACPONM)
        SNDBYT  (AC,\B.POMX,ACPOMX)
        SNDBYT  (AC,\B.PODT,ACPSDT)
        SNDBYT  (AC,\B.PODT,ACPEDT)
        SNDBYT  (AC,\B.VPRI,ACVPF)
        SNDBYT  (AC,\B.PRI,ACDEFP)
        SNDSTR  (AC,L.STRE,ACSTR1)
        SNDSTR  (AC,L.STRE,ACSTR2)
        SNDSTR  (AC,L.STRE,ACEXLN)
        SNDSTR  (AC,L.CITY,ACCITY)
        SNDSTR  (AC,L.STAT,ACSTAT)
        SNDSTR  (AC,L.ZIP,ACZIP)
        SNDSTR  (AC,L.CTRY,ACCTRY)
        SNDSTR  (AC,L.ATTN,ACCATT)
        SNDBYT  (AC,\B.CC,ACCCC)
        PUSHJ   P,AGANS
         JRST   NCUSE2
; If add customer to 370, then update focus flat fee flag
 ;      MOVE    AC,ACTSYS
 ;      CAIE    AC,3                  ; see if it is 370
 ;       JRST   NCUDNE
 ;      SNDBYT  (ACTPRT,\B.ACOM,CCFACT,I)
 ;      SNDBYT  (AC,\B.CID,CUSNUM)
 ;      SNDBYT  (AC,\B.ASY,ACTSYS)
 ;      SNDBYT  (AC,\B.FOCF,ACFOCF)
 ;      PUSHJ   P,AGANS
 ;       JRST   NCUSE3
; if TDIST is not 0, add this customer to ast = 9
        MOVE    AC,TDIST
        CAIN    AC,0
         JRST   NCUDNE
        MOVEI   AC,1
        MOVEM   AC,ACVPF              ; set varaible pricing flag to 1
        MOVEI   AC,^D9
        MOVEM   AC,A9
        SNDBYT  (ACTPRT,\B.ACOM,NCUACT,I)
        SNDBYT  (AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.ASY,A9)
        SNDSTR  (AC,L.CUSN,NCNMSP)
        SNDBYT  (AC,\B.DIS,TDIST)     ; district for tymnet
        SNDBYT  (AC,\B.DET,ACDETC)
        SNDBYT  (AC,\B.INV,ACINVC)
        SNDBYT  (AC,\B.MIN,ACMINC)
        SNDBYT  (AC,\B.SLS,TASLS)     ; salesman number for tymnet
        SNDSTR  (AC,L.PO,ACPONM)
        SNDBYT  (AC,\B.POMX,ACPOMX)
        SNDBYT  (AC,\B.PODT,ACPSDT)
        SNDBYT  (AC,\B.PODT,ACPEDT)
        SNDBYT  (AC,\B.VPRI,ACVPF)
        SNDBYT  (AC,\B.PRI,N30)       ; def. pricing for FORD is 30 in Tymnet
        SNDSTR  (AC,L.STRE,ACSTR1)
        SNDSTR  (AC,L.STRE,ACSTR2)
        SNDSTR  (AC,L.STRE,ACEXLN)
        SNDSTR  (AC,L.CITY,ACCITY)
        SNDSTR  (AC,L.STAT,ACSTAT)
        SNDSTR  (AC,L.ZIP,ACZIP)
        SNDSTR  (AC,L.CTRY,ACCTRY)
        SNDSTR  (AC,L.ATTN,ACCATT)
        SNDBYT  (AC,\B.CC,TCCCC)
        PUSHJ   P,AGANS
         JRST   NCUSE1
NCUDNE: MOVE    AC1,ACANS
	PUSHJ	P,LUDAOT
 
;  write 99 file 
        MOVE    AC,ACDEFP
        CAIE    AC,^D99
         JRST   TATNEW                
        TRO     FLG2,V.F99            ; starting write 99 file
	GETT	(/F99/)
	 JRST	NCUST4
        TTFNUM  (CUSNUM,D)
        TTFNUM  (ACTSYS,D)
        TTFSTR  (NCNMSP,L.CUSN)
        MOVE    AC,CONAM
        CAIN    AC,0
         JRST   [PUSHJ   P,TTFCR1     ; if no conam then write crlf
                 JRST    F99ST2]
        TTFSTR  (CONAM,L.CUSN)
F99ST2: MOVE    AC,PHNUM
        CAIN    AC,0
         JRST   [PUSHJ   P,TTFCR1     ; if no phnum then write crlf
                 JRST    F99DNE]
        TTFSTR  (PHNUM,L.CON)
F99DNE: PUSHJ   P,RELTTF
 
; tattle
TATNEW: TRZ     FLG2,V.F99            ; for write tattle file
        GETT    (/ADD/)
         JRST   NCUST4
        TTFSTR  ([ASCIZ/New Customer/])
        PUSHJ   P,STDCHD
        PUSHJ   P,RELTTF
 
; write reqnum.DAT file, all data that need for subsequent new gan and new user
; requests will be written here
        TLNN    FLG2,V.PRQ            ; skip if process request
         JRST   NCUST4
        REQNOT  (DAT,CUSNUM,D)        ; open DAT file and write cid
        REQNOT  (DAT,ACINVC,D)
        REQNOT  (DAT,UASLS,D)
        REQNOT  (DAT,DISRCT,D)
        REQNOT  (DAT,ACCCC,D)
        REQNOT  (DAT,TDIST,D)
        REQNOT  (DAT,MMUUN,O)
        PUSHJ   P,RELRQO              ; close output file
 
NCUST4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	NCUSTD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
	 JRST	NCUSTD
        JRST    NCSST2

NCUSTD: ; done, successful completion
        TRZ     FLG2,V.NCS
        TRZ     FLG2,V.XNC
	TRO	FLG,U.OKAY
	POPJ	P,

NCUSE0: ; error during get customer from acctg.
        TYPSTR  ([ASCIZ/Error during get Customer Number from Acctg./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    NCUSE4
 
NCUSE1: ; error during adding customer in tymnet
        TYPSTR  ([ASCIZ/Error during adding Customer in Tymnet./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        JRST    NCUSE4
 
NCUSE2:	; error during add new customer in Tymshare
	TYPSTR	([ASCIZ/Error during Add New Customer./])
	MOVE	AC1,ACANS
	PUSHJ	P,LUDAOT
	JRST	NCUSE4

NCUSE3:
        TYPSTR  ([ASCIZ/Error during Update Customer Focus Flat Fee Flag./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        SNDBYT  (ACTPRT,\B.ACOM,REVACT,I)  ; reverse last acctg. entry
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Reverse Acctg. Entry not Working./])
                 MOVE    AC1,ACANS
                 PUSHJ   P,LUDAOT
                 JRST    GETCMD]
        JRST    NCUSE4
 
NCUSE4:	; after error, see if we can give him another chance
	TLNE	FLG2,V.PRQ	; skip if not processing a request
	 POPJ	P,		; just return
	GETYR	([ASCIZ/Do you want to continue ?/])
	 POPJ	P,
        JRST    NCSST2
 
; end of code for add new  customer
 
GEZSYS: ; get accounting system type, set pricing code and set flags
        PUSHJ   P,INASY2
        MOVE    AC1,ACTSYS
        CAIN    AC1,0
         JRST   GEZSYS                ; ask again if enter cr
        SETZM   TCFLG
        SETZM   MFLAG
        SETZM   DFLAG
        CAIE    AC1,A10
         JRST   .+6
        MOVEI   AC,2
        MOVEM   AC,TCFLG
        MOVEI   AC,1
        MOVEM   AC,ACDEFP
        POPJ    P,
        CAIE    AC1,A370
         JRST   .+6
        MOVEI   AC,1
        MOVEM   AC,TCFLG
        MOVEI   AC,^D8
        MOVEM   AC,ACDEFP
        POPJ    P,
        CAIE    AC1,A940
         JRST   .+4
        MOVEI   AC,5
        MOVEM   AC,ACDEFP
        POPJ    P,
        ; start from here, assume ast is special and assign a pricing code
        ; if found
        CAIE    AC1,^D28
         JRST   .+4
        MOVEI   AC,^D28
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D68
         JRST   .+4
        MOVEI   AC,^D977
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D69
         JRST   .+4
        MOVEI   AC,^D978
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D62
         JRST   .+4
        MOVEI   AC,^D974
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D67
         JRST   .+4
        MOVEI   AC,^D976
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D52
         JRST   .+4
        MOVEI   AC,^D950
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D55
         JRST   .+4
        MOVEI   AC,^D951
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D56
         JRST   .+4
        MOVEI   AC,^D952
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D58
         JRST   .+4
        MOVEI   AC,^D953
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D63
         JRST   .+4
        MOVEI   AC,^D954
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D64
         JRST   .+4
        MOVEI   AC,^D955
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D59
         JRST   .+4
        MOVEI   AC,^D956
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D60
         JRST   .+4
        MOVEI   AC,^D957
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D21
         JRST   .+4
        MOVEI   AC,^D958
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D22
         JRST   .+4
        MOVEI   AC,^D959
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D31
         JRST   .+4
        MOVEI   AC,^D960
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D32
         JRST   .+4
        MOVEI   AC,^D961
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D34
         JRST   .+4
        MOVEI   AC,^D962
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D35
         JRST   .+4
        MOVEI   AC,^D963
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D36
         JRST   .+4
        MOVEI   AC,^D964
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D37
         JRST   .+4
        MOVEI   AC,^D965
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D39
         JRST   .+4
        MOVEI   AC,^D966
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D48
         JRST   .+4
        MOVEI   AC,^D967
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D49
         JRST   .+4
        MOVEI   AC,^D968
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D50
         JRST   .+4
        MOVEI   AC,^D969
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D51
         JRST   .+4
        MOVEI   AC,^D970
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D54
         JRST   .+4
        MOVEI   AC,^D971
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D61
         JRST   .+4
        MOVEI   AC,^D972
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        CAIE    AC1,^D53
         JRST   .+4
        MOVEI   AC,^D973
        MOVEM   AC,ACDEFP
        JRST    GEZSPS
        JRST    [TYPSTR  ([ASCIZ/Invalid system type./])
                 JRST    GEZSYS]
GEZSPS: TRO     FLG2,V.XNC            ; turn on new cust for special ast bit
        TRZ     FLG2,V.NCS            ; for prompt "Do Another" in exmmac
        POPJ    P,
 
GEXDIS: ; get district number
        MOVE    AC1,MY.DIS            ; default to own district
        MOVEM   AC1,DISRCT
        CAIN    AC1,^D70              ; prompt 'dist:' for dist70a
         JRST   GEXDI2
        CAIN    AC1,^D144             ; prompt 'dist:' for dist144a (ACS)
         JRST   GEXDI2
        CAIN    AC1,^D148             ; prompt 'dist:' for DISTRCS (RCS)
         JRST   GEXDI2
        TLNE    FLG,U.DIS             ; skip if not district type
         POPJ   P,
GEXDI2: PUSHJ   P,GEDIST
        POPJ    P,
 
INVOUX:
        TLNE    FLG,U.DIS
         JRST   OUTBIL
        PUSHJ   P,INVOU1
        POPJ    P,
OUTBIL:
        MOVE    AC1,ACINVC
        CAIE    AC1,3
         JRST   TYPBIL
        TYPSTR  ([ASCIZ/Non-billable/],777,0,T.P0)
        POPJ    P,
TYPBIL:
        TYPSTR  ([ASCIZ/Billable/],777,0,T.P0)
        POPJ    P,
 
GEXINV:
        TLNE    FLG,U.DIS             ; skip  if not district type
         JRST   GETBIL
        TRNE    FLG,U.RFI             ; skip if input not from request file
         JRST   GE2INV
        TYPSTR  ([ASCIZ/Invoice : /])
GE2INV: PUSHJ   P,GETINV
        POPJ    P,
GETBIL:
        GETYR   ([ASCIZ/Billable ? /])
         JRST   .+3                   ; no
        MOVEI   AC1,1                 ; yes
        JRST    .+2
        MOVEI   AC1,3
        MOVEM   AC1,NUM7
        MOVEM   AC1,ACINVC
        POPJ    P,
 
PRXOUT:
        MOVE    AC,STDFLG
        CAIE    AC,0
         JRST   PRXOU2
        TYPSTR  ([ASCIZ/Users will receive non-standard pricing/],777,0,T.P0)
        TYPSTR  ([ASCIZ/Tymshare Contact Name: /],777,0,10,N)
        TYPSTR  (CONAM,L.CUSN,1)
        TYPSTR  ([ASCIZ/Phone number: /],777,0,10,N)
        TYPSTR  (PHNUM,L.CON,1)
        POPJ    P,
PRXOU2: TYPSTR  ([ASCIZ/Users will receive standard pricing/],777,0,T.P0)
        POPJ    P,
 
GETPRX:
        SETZM   CONAM
        SETZM   PHNUM
        TLNE    FLG,U.DIS             ; skip if not district type
         JRST   GETPR2
        TLNE    FLG2,V.EXQ!V.LSQ!V.PRQ   ; skip if not request
         JRST   GETPR2
        TLNN    FLG,U.IMM                ; skip if immediate
         JRST   GETPR2
        TRZ     FLG2,V.NIR
        POPJ    P,
GETPR2:
        GETYR   (ASK1)
         SKIPA
        JRST    [MOVEI   AC1,1
                 MOVEM   AC1,STDFLG
                 POPJ    P,]
        SETZM   STDFLG
        INSTR   ([ASCIZ/Tymshare Contact Name :/],CONAM,L.CUSN)
        INSTR   ([ASCIZ/Phone number :/],PHNUM,L.CON)
        POPJ    P,
 
ASK1:   ASCIZ   -Should users for this customer receive standard pricing?-
 
RWPRX:
        MOVE    AC,STDFLG
        CAIE    AC,1
         PUSHJ  P,WRNO
        JRST    [PUSHJ   P,WRYES
                 POPJ    P,]
        REQOUT  (REQ,CONAM,L.CUSN)
        REQOUT  (REQ,PHNUM,L.CON)
        POPJ    P,
 
GEXDET:
        TRO     FLG2,V.NIR            ; set v.nir since it might be changed in
                                      ; routine GETPRX
        TRNE    FLG,U.RFI             ; skip if input not from request file
         JRST   GEXDE2
        TYPSTR  ([ASCIZ/Detail : /])
GEXDE2: PUSHJ   P,GETDET
        POPJ    P,
 
AMTOUT:
        TYPSTR  ([ASCIZ/Est. Monthly Billing Amount: $/],777,0,T.P0,N)
        TYPSTR  (ESTAMT,L.ESAMT)
        POPJ    P,
 
GETAMT:
        INSTR   ([ASCIZ/Est. Monthly Billing Amount: $/],ESTAMT,L.ESAMT)
        MOVE    AC,ESTAMT
        CAMN    AC,[ASCII/     /]
         JRST   GETAMT
        POPJ    P,
 
RWAMT:
        REQOUT  (REQ,ESTAMT,L.ESAMT)
        POPJ    P,
 
SRNOUT:
        TYPSTR  ([ASCIZ/Sales Rep. Name: /],777,0,T.P0,N)
        TYPSTR  (SRN,L.SRN)
        POPJ    P,
 
GETSRN:
        INSTR   ([ASCIZ/Sales Rep. Name: /],SRN,L.SRN)
        POPJ    P,
 
RWSRN:
        REQOUT  (REQ,SRN,L.SRN)
        POPJ    P,
 
PRDOUT:
        TYPSTR  ([ASCIZ/Product: /],777,0,T.P0,N)
        TYPSTR  (PRD,L.PRD)
        POPJ    P,
 
GETPRD:
        INSTR   ([ASCIZ/Product: /],PRD,L.PRD)
        POPJ    P,
 
RWPRD:
        REQOUT  (REQ,PRD,L.PRD)
        POPJ    P,
 
DPTOUT:
        TYPSTR  ([ASCIZ/Department Number: /],777,0,T.P0,N)
        TYPSTR  (DPT,L.DPT)
        POPJ    P,
 
GETDPT:
        INSTR   ([ASCIZ/Department Number: /],DPT,L.DPT)
        POPJ    P,
 
RWDPT:
        REQOUT  (REQ,DPT,L.DPT)
        POPJ    P,
 
NDISOU:
        TLNN    FLG2,V.PRQ!V.EXQ      ; skip if processing/examing the req
         POPJ   P,
        TYPSTR  ([ASCIZ/District in Tymnet: /],777,0,T.P0,N)
        TYPNUM  (TDIST,D,0,T.P2)
        POPJ    P,
 
GENDIS:
        SETZM   TDIST
        TLNN    FLG2,V.PRQ!V.EXQ      ; skip if processing/examing the req
         POPJ   P,                    ; note TDIST  is 0 when U.DIS submit
                                      ; the request
GENDI2: INNUM   ([ASCIZ/District in Tymnet: /],D)
         JRST   [PUSHJ   P,INORNO
                 JRST    GENDIS]
        MOVE    AC,CUSNUM
        CAIE    AC,^D38339            ; FORD MOTOR?
         CAIN   AC,^D56778
        MOVEI   AC1,^D217
        MOVEM   AC1,TDIST
        POPJ    P,
 
RWNDIS:
        REQNOT  (REQ,TDIST,D)
        POPJ    P,
 
NCCCOU:
        TLNN    FLG2,V.PRQ!V.EXQ      ; skip if processing/examing the req
         POPJ   P,
        TYPSTR  ([ASCIZ/Costcode in Tymnet: /],777,0,T.P0,N)
        TYPNUM  (TCCCC,D,0,T.P2)
        POPJ    P,
 
GENCCC:
        SETZM   TCCCC
        TLNN    FLG2,V.PRQ!V.EXQ      ; skip if processing/examing the req
         POPJ   P,                    ; note TCCCC  is 0 when U.DIS submit
                                      ; the request
        INNUM   ([ASCIZ/Costcode in Tymnet: /],D)
         JRST   [PUSHJ   P,INORNO
                 JRST    GENCCC]
        MOVEM   AC1,TCCCC
        POPJ    P,
 
RWNCCC:
        REQNOT  (REQ,TCCCC,D)
        POPJ    P,
 
NSLSOU:
        TLNN    FLG2,V.PRQ!V.EXQ      ; skip if processing/examing the req.
         POPJ   P,
        TYPSTR  ([ASCIZ/Salesman no. in Tymnet: /],777,0,T.P0,N)
        TYPNUM  (TASLS,D,0,T.P2)
        POPJ    P,
 
GENSLS:
        SETZM   TASLS
        TLNN    FLG2,V.PRQ!V.EXQ      ; skip if processing/examing the req
         POPJ   P,                    ; note TASLS  is 0 when U.DIS submit
                                      ; the request
        INNUM   ([ASCIZ/Salesman no. in Tymnet: /],D)
         JRST   [PUSHJ   P,INORNO
                 JRST    GENSLS]
        MOVEM   AC1,TASLS
        POPJ    P,
 
RWNSLS:
        REQNOT  (REQ,TASLS,D)
        POPJ    P,
 
MUUNOU:
        TLNN    FLG2,V.PRQ!V.EXQ      ; skip if processing/examing the req
         POPJ   P,
        TYPSTR  ([ASCIZ/Muun: /],777,0,T.P0,N)
        TYPNUM  (MMUUN,O,0,T.P2)
        POPJ    P,
 
GEMUUN:
        SETZM   MMUUN
        TLNN    FLG2,V.PRQ!V.EXQ      ; skip if processing/examing the req
         POPJ   P,                    ; note MMUUN  is 0 when U.DIS submit
                                      ; the request
GEMUU2: INNUM   ([ASCIZ/Muun: /],O)
         JRST   [PUSHJ   P,INORNO
                 JRST    GEMUUN]
        MOVE    AC,CUSNUM
        CAIE    AC,^D38339            ; FORD MOTOR?
         CAIN   AC,^D56778
        MOVEI   AC1,233167
        MOVEM   AC1,MMUUN
        POPJ    P,
 
RWMUUN:
        REQNOT  (REQ,MMUUN,O)
        POPJ    P,
 
NGANNC: ; new gan after new customer command
      ; TYPSTR  ([ASCIZ/Add new gan after new customer request/])
        ; This is a routine not a command. It is called when user want to
        ; establish a new account after finished an new customer request.
        ; The system type is obtained from memory. REQNM1 - the request number
        ; of new customer request - is written to reqnum.REQ file. Before
        ; processing, this number will be read in, then read real cid from
        ; REQNM1.DAT file
        AOS     USRCNT                ; USRCNT is used in EXMMAC of add 
                                      ; customer command to indicate a gan has
                                      ; been established
	TCR	(1)
	TRO	FLG2,V.NIR
        TRZ     FLG2,V.NCS            ; turn off this bit since new customer
                                      ; request is done
        TRO     FLG2,V.NGA            ; for using in GEYLIC and define REQNM2
        SETZM   MUDON                 ; for output  license
        ; TCFLG has been defined in the NEW CUSTOMER command
        SETZM   MFLAG                 ; for non-zero cyclinders input
        SETZM   DFLAG                 ; for getting write password

DEFINE N5US <
	X	(SYSOUT,N1USYS,RWSYS)
	X	(NNMOUT,GETNNM,RWNNM)
        X       (PSWOUT,GEYPSW,RWPSW)
        X       (COCOUT,GETCOC,RWCOC)
        X       (LICOUX,GEYLIC,WYLIC)
	X	(TMZOUT,GETTMZ,RWTMZ)
	X	(GHMEOT,GEGHME,RWH37)
        X       (INQOUT,GETINQ,RWINQ,TCFLG,2)
        X       (OTQOUT,GETOTQ,RWOTQ,TCFLG,2)
        X       (DCOOUT,GETDCO,RWDCO,TCFLG,1)
        X       (MCOOUT,GETMCO,RWMCO,TCFLG,1)
        X       (CYLOUT,GEXCYL,RWCYL,TCFLG,1)
        X       (GRPOUT,GETGRP,RWGRP,TCFLG,1,U.PRV)  ; only priv may set pack
	X	(ST1OUT,GETST1,RWST1,MFLAG,1)
	X	(ST2OUT,GETST2,RWST2,MFLAG,1)
	X	(ST3OUT,GETST3,RWST3,MFLAG,1)
	X	(ST4OUT,GETST4,RWST4,MFLAG,1)
	X	(ST5OUT,GETST5,RWST5,MFLAG,1)
        X       (RPWOUT,GETRPW,RWRPW,MFLAG,1)
        X       (WPWOUT,GETWPW,RWWPW,DFLAG,1)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
        X       (DUMMY1,GERQN1,RWRQN1)
>
	EXMMAC  (N5U,N5US,^D58,CUSRQQ)

; code for add new gan (add first user in the gan) after add customer starts
; here, only PROCESS command can enter the following codes

 
; first read in cid etc. from REQNM1.DAT file
 
        MOVE    AC,REQNUM
        MOVEM   AC,NUM3               ; save current reqnum
        MOVE    AC,REQNM1
        MOVEM   AC,REQNUM             ; for calling RDRQF
        MOVE    AC,REQVAL
        MOVEM   AC,NUM4               ; save current reqval
        PUSHJ   P,RDRQF               ; set reqval from REQNM1
        SKIPN   REQVAL
         JRST   [TYPSTR  ([ASCIZ/Customer has not been created./])
                 JRST    GETCMD]
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,CUSNUM
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,ACINVC
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,UASLS
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,ACCDIS
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,ACCCC
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,TDIST
        REQINN  (DAT,O)
         JFCL
        MOVEM   AC1,MMUUN
        PUSHJ   P,RELRQI              ; close input file
        MOVE    AC,NUM3
        MOVEM   AC,REQNUM             ; bring back current reqnum
        MOVE    AC,NUM4
        MOVEM   AC,REQVAL             ; bring back current reqval
 
; setup NMCPAR, NMCOLN, NMIRC and NMCLSS
        MOVE    AC1,NMCPAR            ; NMCPAR is newly defined in GEYLIC
        LSH     AC1,-^D8
        MOVEM   AC1,NMCPAR
        SETZM   AC1
        MOVE    AC,NMPSW
        CAIE    AC,7400               ; no psw?
         SKIPA
        TLO     AC1,NPS.CD            ; set no-psw bit
        MOVE    AC,ACINVC
        CAIN    AC,3                  ; invoice code = 3 is non-billable
         TLO    AC1,BIL.CD            ; turn on bil.cd if non-billable
        LSH     AC1,-^D16
        MOVEM   AC1,NMCOLN
        SETZM   NMIRC
        MOVEI   AC1,2
        MOVEM   AC1,NMCLSS
        MOVEI   AC1,D.CLS             ; set class 2
        MOVEM   AC1,NMCLSS+1
        MOVEI   AC1,D.GRP             ; set group 1
        TRO     AC1,GRP.CD            ; set group indicator bit
        MOVEM   AC1,NMCLSS+2
        MOVE    AC1,HOST
        TRO     AC1,HOM.CD            ; set home host indicator bit
        MOVEM   AC1,NMCLSS+3
        MOVE    AC1,ACCDIS            ; ACCDIS came from customer
        MOVEM   AC1,NMDIST
 
; add new user to cud
        MOVE    AC,ACTSYS
        MOVEM   AC,ACTSY2             ; load in actsys into actsy2
        SETZM   NMGAN
        PUSHJ   P,NUSMUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   N5USE1
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.GAN)       ; get gan
         JRST   GETCMD
        MOVEM   AC1,NMGAN      
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.UUN)       ; get uun for new user
         JRST   GETCMD
        MOVEM   AC1,NMUUN
        PUSHJ   P,GET40
        TCR     (1)
        TYPSTR  ([ASCIZ/********** Global Account Number is /],777,0,T.P0,N)
        TYPNUM  (NMGAN,O,5)
        TCR     (1)
        TYPSTR  ([ASCIZ/********** The Uun for /],777,0,T.P0,N)
        TYPSTR  (NNMSPC,L.UNM,1,0,N)
        TYPSTR  ([ASCIZ/is /],777,1,0,N)
        TYPNUM  (NMUUN,O,5)
        MOVE    AC1,NMCPAR            ; return for next entry
        LSH     AC1,^D8
        MOVEM   AC1,NMCPAR
        MOVE    AC1,NMCOLN            ; return for next entry
        LSH     AC1,^D16
        MOVEM   AC1,NMCOLN
 
; new user for the accounting system type, first get ACCDIS and UASLS from
; customer then get UAPRIC, UALANC and UACURC from table. UARESC is defined
; to be 1 in UPDLUD, therefore, we are not trying to get it here
        MOVE    AC1,ACCDIS
        MOVEM   AC1,UADIS
        IMULI   AC1,^D10
        MOVE    AC,ACTSY2
        CAIN    AC,A370
         JRST   [MOVE    AC,DISTBL+2(AC1)    ; 3rd column is 370 pricing code
                 JRST    MVPRI2]
        CAIN    AC,A940
         JRST   [MOVE    AC,DISTBL+1(AC1)    ; 2nd column is 940 pricing code
                 JRST    MVPRI2]
        MOVE    AC,DISTBL(AC1)               ; 1st column is pdp10 pricing code
MVPRI2: MOVEM   AC,UAPRIC
        MOVE    AC,DISTBL+5(AC1)             ; 6th column is language code
        MOVEM   AC,UALANC
        MOVE    AC,DISTBL+6(AC1)             ; 7th column is currency code
        MOVEM   AC,UACURC
        MOVE    AC,NMCOLN
        TLNE    AC,BIL.CD             ; skip if billable
         JRST   .+3                   ; if non-billable then use table
        MOVEI   AC1,^D99
        MOVEM   AC1,UAPRIC            ; assign 99 pricing code
        PUSHJ   P,NUSACC
        PUSHJ   P,AGANS
         JRST   N5USE2
        MOVE    AC1,TDIST
        CAIN    AC1,0
         JRST   N5ULUD
        PUSHJ   P,NUSNET              ; new user in tuserdb
        PUSHJ   P,AGANS
         JRST   N5USE2
 
; add user in lud - will be treated differently according to system type
  
N5ULUD:
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; skip if 370
         JRST   NOT537
        PUSHJ   P,ADD370
        JRST    N5UDNE
NOT537: CAIE    AC,A940               ; skip if 940
         JRST   NOT594
        PUSHJ   P,ADD940
        JRST    N5UDNE
NOT594: PUSHJ   P,ADD10
        JRST    N5UDNE
 
N5UDNE: PUSHJ   P,OLDA
         JRST   N5USE3
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; if 370 then update default core
         JRST   .+6
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM6
        PUSHJ   P,ADDCOR
        PUSHJ   P,OLDA
         JFCL                         ; continue even if error
; tattle
	GETT	(/ADD/)
	 JRST	N5USR4
	TTFSTR	([ASCIZ/New Gan after new customer/])
	PUSHJ	P,ST1UHD
	PUSHJ	P,RELTTF
 
; write reqnum.DAT file, all the data that need for subsequent new user request
; will be written here
        TLNN    FLG2,V.PRQ
         JRST   N5USR4
        REQNOT  (DAT,CUSNUM,D)        ; open DAT file and write cid
        REQNOT  (DAT,NMGAN,O)         
        REQNOT  (DAT,NMCOLN,D)
        REQNOT  (DAT,NMDIST,D)
        REQNOT  (DAT,UADIS,D)
        REQNOT  (DAT,UALANC,D)
        REQNOT  (DAT,UACURC,D)
        REQNOT  (DAT,UASLS,D)
        REQNOT  (DAT,UAPRIC,D)
        REQNOT  (DAT,UARESC,D)
        REQNOT  (DAT,ACCCC,D)
        REQNOT  (DAT,TDIST,D)
        REQNOT  (DAT,MMUUN,O)
        PUSHJ   P,RELRQO              ; close output file
 
N5USR4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	N5USRD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
         JRST   N5USRD
	JRST	N5UST2			; ABRV'ST2 is the menu output section

N5USRD:	; done, successful completion
        TRZ     FLG2,V.GAN
	TRO	FLG,U.OKAY
	POPJ	P,
 
N5USE1: ; error during add new user into the mud
        TYPSTR  ([ASCIZ/Error during Add New Gan in the Cud./])
        PUSHJ   P,ERRCUD
        JRST    N5USE4

N5USE2: ; error during add new user in acctg.
        TYPSTR  ([ASCIZ/Error during Add Gan in Acctg./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        JRST    N5USE4
 
N5USE3:	; error during add user in lud
	TYPSTR	([ASCIZ/Error during Add Gan in the Lud./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        SNDBYT  (ACTPRT,\B.ACOM,REVACT,I)  ; reverse last acctg. entry
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Reverse Acctg. Entry not Working!/])
                 MOVE    AC1,ACANS
                 PUSHJ   P,LUDAOT
                 JRST    GETCMD]
 
N5USE4: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    N5UST2
 
; end of code for new gan after new customer command
 
DUMMY1:
        TYPSTR  ([ASCIZ/Cid :/],777,0,T.P0,N)
        TYPSTR  ([ASCIZ/to be assigned/],777,0,T.P2)
        POPJ    P,
 
GERQN1: ; get request number from new customer request
        TLNN    FLG2,V.LSQ!V.EXQ!V.PRQ
        POPJ   P,
; if examine or type or process a request, then read in request number from
; request file
        INNUM   ([ASCIZ/Request Number :/],D)
         JRST   GERQN1
        MOVEM   AC1,REQNM1
        POPJ    P,
 
RWRQN1:
        REQNOT  (REQ,REQNM1,D)
        POPJ    P,
NUNGNC: ; new user of new gan for new customer request
      ; TYPSTR  ([ASCIZ/Add new user of new gan after new customer request/])
        ; this routine is called after made an new customer request and a new
        ; gan (first new user after new customer) request. System type is
        ; obtained from preceding request. Both cid and gan are read in from
        ; REQNM1.DAT and REQNM2.DAT file respectively. During the request,
        ; REQNM1 and REQNM2 are recorded in reqnum.REQ file
	TCR	(1)
	TRO	FLG2,V.NIR
        TRZ     FLG2,V.GAN            ; for using GEYLIC
        TRZ     FLG2,V.NCS            ; new customer request is done
        SETZM   MUDON                 ; for output  license
      ; TCFLG has been defined in NEW CUSTOMER command
        SETZM   MFLAG                 ; for non-zero cyclinders input
        SETZM   DFLAG                 ; for getting write password

DEFINE N6US <
	X	(SYSOUT,N1USYS,RWSYS)
	X	(NNMOUT,GETNNM,RWNNM)
        X       (PSWOUT,GEYPSW,RWPSW)
        X       (COCOUT,GETCOC,RWCOC)
	X	(GHMEOT,GEGHME,RWH37)
        X       (LICOUX,GEYLIC,WYLIC)
	X	(TMZOUT,GETTMZ,RWTMZ)
        X       (INQOUT,GETINQ,RWINQ,TCFLG,2)
        X       (OTQOUT,GETOTQ,RWOTQ,TCFLG,2)
        X       (DCOOUT,GETDCO,RWDCO,TCFLG,1)
        X       (MCOOUT,GETMCO,RWMCO,TCFLG,1)
        X       (CYLOUT,GEXCYL,RWCYL,TCFLG,1)
        X       (GRPOUT,GETGRP,RWGRP,TCFLG,1,U.PRV)  ; only priv may set pack
	X	(ST1OUT,GETST1,RWST1,MFLAG,1)
	X	(ST2OUT,GETST2,RWST2,MFLAG,1)
	X	(ST3OUT,GETST3,RWST3,MFLAG,1)
	X	(ST4OUT,GETST4,RWST4,MFLAG,1)
	X	(ST5OUT,GETST5,RWST5,MFLAG,1)
        X       (RPWOUT,GETRPW,RWRPW,MFLAG,1)
        X       (WPWOUT,GETWPW,RWWPW,DFLAG,1)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
        X       (DUMMY1,GERQN1,RWRQN1)
        X       (DUMMY2,GERQNM,RWRQNM)     
>
	EXMMAC  (N6U,N6US,^D59,CUSRQQ)

; code for add new user of new gan after add customer command starts here,
; only PROCESS command can enter the following codes

; first read in cid etc. from REQNM2.DAT file
 
        MOVE    AC,REQNUM
        MOVEM   AC,NUM3               ; save current reqnum
        MOVE    AC,REQNM2
        MOVEM   AC,REQNUM             ; for calling RDRQF
        MOVE    AC,REQVAL
        MOVEM   AC,NUM4               ; save current reqval for calling RDRQF
        PUSHJ   P,RDRQF               ; set reqval from REQNM2
        SKIPN   REQVAL
         JRST   [TYPSTR  ([ASCIZ/Gan has not been created./])
                 JRST    GETCMD]
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,CUSNUM
        REQINN  (DAT,O)
         JFCL
        MOVEM   AC1,NMGAN
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,NMCOLN
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,NMDIST
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,UADIS
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,UALANC
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,UACURC
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,UASLS
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,UAPRIC
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,UARESC
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,ACCCC
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,TDIST
        REQINN  (DAT,O)
         JFCL
        MOVEM   AC1,MMUUN
        PUSHJ   P,RELRQI              ; close input file
        MOVE    AC,NUM3
        MOVEM   AC,REQNUM             ; put back reqnum
        MOVE    AC,NUM4
        MOVEM   AC,REQVAL             ; put back reqval
 
 
; setup NMCPAR, NMCOLN, NMIRC and NMCLSS
        MOVE    AC1,NMCPAR            ; NMCPAR is newly defined in GEYLIC
        LSH     AC1,-^D8
        MOVEM   AC1,NMCPAR
        MOVE    AC,NMPSW
        CAIE    AC,7400               ; no psw?
         JRST   .+4
        MOVE    AC1,NMCOLN
        TLO     AC1,NPS.CD            ; set no-psw bit
        MOVEM   AC1,NMCOLN
        MOVE    AC1,NMCOLN            ; colon came from old user
        LSH     AC1,-^D16
        MOVEM   AC1,NMCOLN
        SETZM   NMIRC
        MOVEI   AC1,2
        MOVEM   AC1,NMCLSS
        MOVEI   AC1,D.CLS             ; set class 2
        MOVEM   AC1,NMCLSS+1
        MOVEI   AC1,D.GRP             ; set group 1
        TRO     AC1,GRP.CD            ; set group indicator bit
        MOVEM   AC1,NMCLSS+2
        MOVE    AC1,HOST
        TRO     AC1,HOM.CD            ; set home host indicator bit
        MOVEM   AC1,NMCLSS+3
 
; add new user to cud
        MOVE    AC,ACTSYS
        MOVEM   AC,ACTSY2             ; load actsys into actsy2
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,NUSMUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   N6USE1
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.GAN)       ; get gan
         JRST   GETCMD
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.UUN)       ; get uun for new user
         JRST   GETCMD
        MOVEM   AC1,NMUUN
        PUSHJ   P,GET40
        TCR     (1)
        TYPSTR  ([ASCIZ/********** The Uun for /],777,0,T.P0,N)
        TYPSTR  (NNMSPC,L.UNM,1,0,N)
        TYPSTR  ([ASCIZ/is /],777,1,0,N)
        TYPNUM  (NMUUN,O,5)
        MOVE    AC1,NMCPAR            ; return for next entry
        LSH     AC1,^D8
        MOVEM   AC1,NMCPAR
        MOVE    AC1,NMCOLN            ; return for next entry
        LSH     AC1,^D16
        MOVEM   AC1,NMCOLN
 
; new user for the accounting system type
        PUSHJ   P,NUSACC
        PUSHJ   P,AGANS
         JRST   N6USE2
        MOVE    AC1,TDIST
        CAIN    AC1,0
         JRST   N6ULUD
        PUSHJ   P,NUSNET
        PUSHJ   P,AGANS
         JRST   N6USE2
        JRST    N6ULUD
 
; add user in lud - will be treated differently according to system type
  
N6ULUD:
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; skip if 370
         JRST   NOT637
        PUSHJ   P,ADD370
        JRST    N6UDNE
NOT637: CAIE    AC,A940               ; skip if 940
         JRST   NOT694
        PUSHJ   P,ADD940
        JRST    N6UDNE
NOT694: PUSHJ   P,ADD10
        JRST    N6UDNE
 
N6UDNE: PUSHJ   P,OLDA
         JRST   N6USE3
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; if 370 then update default core
         JRST   .+6
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM6
        PUSHJ   P,ADDCOR
        PUSHJ   P,OLDA
         JFCL                         ; continue even if error
; tattle
	GETT	(/ADD/)
	 JRST	N6USR4
	TTFSTR	([ASCIZ/New user of new gan after new customer/])
	PUSHJ	P,ST1UHD
	PUSHJ	P,RELTTF
 
N6USR4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	N6USRD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
         JRST   N6USRD
	JRST	N6UST2			; ABRV'ST2 is the menu output section

N6USRD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

N6USE1: ; error during add new user into the mud
        TYPSTR  ([ASCIZ/Error during Add New User in the Cud./])
        PUSHJ   P,ERRCUD
        JRST    N6USE4

N6USE2: ; error during add new user in acctg.
        TYPSTR  ([ASCIZ/Error during Add User in Acctg./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        JRST    N6USE4
 
N6USE3:	; error during add user in lud
	TYPSTR	([ASCIZ/Error during Add User in the Lud./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        SNDBYT  (ACTPRT,\B.ACOM,REVACT,I)  ; reverse last acctg. entry
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Reverse Acctg. Entry not Working!/])
                 MOVE    AC1,ACANS
                 PUSHJ   P,LUDAOT
                 JRST    GETCMD]
 
N6USE4: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    N6UST2
 
; end of code for new user  of new gan after new customer
 
NUOGNC: ; new user of existing gan for new customer command
      ; TYPSTR  ([ASCIZ/Add new user of old gan after new customer request/])
        ; this routine is called after new customer command, itself is not a 
        ; command. After user generated an NEW CUSTOMER request and wants to
        ; add a new user of existing gan to this customer, this routine will
        ; be called automatically. The system type is obtained from memory
        ; and cid get from REQNM1.DAT file
	TCR	(1)
	TRO	FLG2,V.NIR
        TRZ     FLG2,V.NCS            ; new customer request is done
        TRZ     FLG2,V.GAN            ; for using GEYLIC
        SETZM   MUDON                 ; for output  license
      ; TCFLG has been defined in ADD CUSTOMER command
        SETZM   MFLAG                 ; for non-zero cyclinders input
        SETZM   DFLAG                 ; for getting write password

DEFINE N7US <
	X	(SYSOUT,N1USYS,RWSYS)
        X       (GANOU1,N7UGAN,RWUSR)
	X	(NNMOUT,GETNNM,RWNNM)
        X       (PSWOUT,GEYPSW,RWPSW)
        X       (COCOUT,GETCOC,RWCOC)
	X	(GHMEOT,GEGHME,RWH37)
        X       (LICOUX,GEYLIC,WYLIC)
	X	(TMZOUT,GETTMZ,RWTMZ)
        X       (INQOUT,GETINQ,RWINQ,TCFLG,2)
        X       (OTQOUT,GETOTQ,RWOTQ,TCFLG,2)
        X       (DCOOUT,GETDCO,RWDCO,TCFLG,1)
        X       (MCOOUT,GETMCO,RWMCO,TCFLG,1)
        X       (CYLOUT,GEXCYL,RWCYL,TCFLG,1)
        X       (GRPOUT,GETGRP,RWGRP,TCFLG,1,U.PRV)  ; only priv may set pack
	X	(ST1OUT,GETST1,RWST1,MFLAG,1)
	X	(ST2OUT,GETST2,RWST2,MFLAG,1)
	X	(ST3OUT,GETST3,RWST3,MFLAG,1)
	X	(ST4OUT,GETST4,RWST4,MFLAG,1)
	X	(ST5OUT,GETST5,RWST5,MFLAG,1)
        X       (RPWOUT,GETRPW,RWRPW,MFLAG,1)
        X       (WPWOUT,GETWPW,RWWPW,DFLAG,1)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
        X       (DUMMY1,GERQN1,RWRQN1)
>
	EXMMAC  (N7U,N7US,^D60,CUSRQQ)

; code for add new user of old gan after new customer command starts here, only
; PROCESS command can enter the following codes

; first read in cid etc. from REQNM1.DAT file
 
        MOVE    AC,REQNUM
        MOVEM   AC,NUM3               ; save current reqnum
        MOVE    AC,REQNM1
        MOVEM   AC,REQNUM             ; for calling RDRQF
        MOVE    AC,REQVAL
        MOVEM   AC,NUM4               ; save current reqval
        PUSHJ   P,RDRQF               ; set reqval from REQNM1
        SKIPN   REQVAL
         JRST   [TYPSTR  ([ASCIZ/Customer has not been created./])
                 JRST    GETCMD]
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,CUSNUM
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,ACINVC
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,UASLS
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,ACCDIS
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,ACCCC
        REQINN  (DAT,D)
         JFCL
        MOVEM   AC1,TDIST
        REQINN  (DAT,O)
         JFCL
        MOVEM   AC1,MMUUN
        PUSHJ   P,RELRQI              ; close input file
        MOVE    AC,NUM3
        MOVEM   AC,REQNUM             ; bring back current reqnum
        MOVE    AC,NUM4
        MOVEM   AC,REQVAL             ; bring back current reqval
 
; setup NMCPAR, NMCOLN, NMIRC and NMCLSS. NMCOLN will be decided by customer
; invoice code instead of NMCOLN of the user in existing gan
; setup NMCPAR, NMCOLN, NMIRC and NMCLSS
        MOVE    AC1,NMCPAR            ; NMCPAR is newly defined in GEYLIC
        LSH     AC1,-^D8
        MOVEM   AC1,NMCPAR
        SETZM   AC1,
        MOVE    AC,NMPSW
        CAIE    AC,7400               ; no psw?
         SKIPA
        TLO     AC1,NPS.CD            ; set no-psw bit
        MOVE    AC,ACINVC
        CAIN    AC,3                  ; invoice code = 3 is non-billable
         TLO    AC1,BIL.CD            ; turn on bil.cd if non-billable
        LSH     AC1,-^D16
        MOVEM   AC1,NMCOLN            
        SETZM   NMIRC
        MOVEI   AC1,2
        MOVEM   AC1,NMCLSS
        MOVEI   AC1,D.CLS             ; set class 2
        MOVEM   AC1,NMCLSS+1
        MOVEI   AC1,D.GRP             ; set group 1
        TRO     AC1,GRP.CD            ; set group indicator bit
        MOVEM   AC1,NMCLSS+2
        MOVE    AC1,HOST
        TRO     AC1,HOM.CD            ; set home host indicator bit
        MOVEM   AC1,NMCLSS+3
 
; add new user to cud
        MOVE    AC,ACTSYS
        MOVEM   AC,ACTSY2
        PUSHJ   P,NUSMUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   N7USE1
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.GAN)       ; get gan
         JRST   GETCMD
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.UUN)       ; get uun for new user
         JRST   GETCMD
        MOVEM   AC1,NMUUN
        PUSHJ   P,GET40
        TCR     (1)
        TYPSTR  ([ASCIZ/********** The Uun for /],777,0,T.P0,N)
        TYPSTR  (NNMSPC,L.UNM,1,0,N)
        TYPSTR  ([ASCIZ/is /],777,1,0,N)
        TYPNUM  (NMUUN,O,5)
        MOVE    AC1,NMCPAR            ; return for next entry
        LSH     AC1,^D8
        MOVEM   AC1,NMCPAR
        MOVE    AC1,NMCOLN            ; return for next entry
        LSH     AC1,^D16
        MOVEM   AC1,NMCOLN
 
; new user for the accounting system type
        MOVE    AC,NMCOLN
        TLNE    AC,BIL.CD             ; skip if billable
         JRST   .+3                   ; if non-billable then use old UAPRIC
        MOVEI   AC1,^D99
        MOVEM   AC1,UAPRIC            ; assign 99 pricing code
        PUSHJ   P,NUSACC
        PUSHJ   P,AGANS
         JRST   N7USE2
        MOVE    AC1,TDIST
        CAIN    AC1,0
         JRST   N7ULUD
        PUSHJ   P,NUSNET
        PUSHJ   P,AGANS
         JRST   N7USE2
        JRST    N7ULUD
 
; add user in lud - will be treated differently according to system type
  
N7ULUD:
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; skip if 370
         JRST   NOT737
        PUSHJ   P,ADD370
        JRST    N7UDNE
NOT737: CAIE    AC,A940               ; skip if 940
         JRST   NOT794
        PUSHJ   P,ADD940
        JRST    N7UDNE
NOT794: PUSHJ   P,ADD10
        JRST    N7UDNE
 
N7UDNE: PUSHJ   P,OLDA
         JRST   N7USE3
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; if 370 then update default core
         JRST   .+6
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM6
        PUSHJ   P,ADDCOR
        PUSHJ   P,OLDA
         JFCL                         ; continue even if error
; tattle
        GETT    (/ADD/)
	 JRST	N7USR4
	TTFSTR	([ASCIZ/New user of existing gan after new customer/])
	PUSHJ	P,ST1UHD
	PUSHJ	P,RELTTF
 
N7USR4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	N7USRD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
         JRST   N7USRD
	JRST	N7UST2			; ABRV'ST2 is the menu output section

N7USRD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

N7USE1: ; error during add new user into the mud
        TYPSTR  ([ASCIZ/Error during Add New User in the Cud./])
        PUSHJ   P,ERRCUD
        JRST    N7USE4

N7USE2: ; error during add new user in acctg.
        TYPSTR  ([ASCIZ/Error during Add User in Acctg./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        JRST    N7USE4
 
N7USE3:	; error during add user in lud
	TYPSTR	([ASCIZ/Error during Add User in the Lud./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        SNDBYT  (ACTPRT,\B.ACOM,REVACT,I)  ; reverse last acctg. entry
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Reverse Acctg. Entry not Working!/])
                 MOVE    AC1,ACANS
                 PUSHJ   P,LUDAOT
                 JRST    GETCMD]
 
N7USE4: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    N7UST2
 
; end of code for new user of existing gan after new customer
 
N7UGAN: ; get gan, if request mode then make sure entered user belonging to
        ; customer's district. No check access because it is done in new
        ; customer request. Finally, get user acctg. record for new user.
        INSTR   ([ASCIZ/Username in desired Gan :/],UNMSPC,L.UNM,T)
        MOVEI   AC,UNMSPC
        MOVEI   AC1,L.UNM
        PUSHJ   P,CNTCHR
        SKIPG   AC1
         JRST   [PUSHJ   P,INORNO
                 JRST    GEYGAN]
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GCREC               ; get cud record before testing it is 
         JRST   [PUSHJ   P,INORNO     ; a type request command or not. Since
                 JRST    N7UGAN]      ; gan will be displayed in output menu
        TLNE    FLG2,V.LSQ
         POPJ   P,
        TLNE    FLG2,V.EXQ!V.PRQ      ; make sure user is belonging to 
         JRST   N7UGA1                ; customer's district during request
        MOVE    AC,NMDIST             ; make sure district agree with cid's
        CAME    AC,DISRCT             ; disrct defined in the new customer req.
         JRST   N7UGA2
N7UGA1: PUSHJ   P,GETACC
         JRST   GETCMD
        ; check user is valid on the input acctg. system type, if not then
        ; get default system type NUM1. Then we always have ast for getting
        ; acctg. record of this user. These acctg. info will be used to
        ; establish acctg. record for the new user.
        PUSHJ   P,GUAREK              ; get user acctg. record in ACTSY2
         JRST   GEXSYS                ; get default ast then acctg. rec
        POPJ    P,
N7UGA2:
        TYPSTR  ([ASCIZ/User is not belonging to customer's district./])
        JRST    N7UGAN
 
CMDNGA: ; new gan
	TCR	(1)
        PUSHJ   P,CHKFRA              ; check French validators' name
	TRO	FLG2,V.NIR
        TRO     FLG2,V.GAN            ; for using in GEYLIC and define REQNM2
        SETZM   MUDON                 ; for output  license
        SETZM   TCFLG                 ; for pdp10/370 input
        SETZM   MFLAG                 ; for non-zero cyclinders input
        SETZM   DFLAG                 ; for getting write password

DEFINE NGAN <
	X	(SYSOUT,GEYSYS,RWSYS)
        X       (CSNOUX,GEXCSN,RWCSN)
	X	(NNMOUT,GETNNM,RWNNM)
        X       (PSWOUT,GEYPSW,RWPSW)
        X       (COCOUT,GETCOC,RWCOC)
        X       (LICOUX,GEYLIC,WYLIC)
	X	(TMZOUT,GETTMZ,RWTMZ)
	X	(GHMEOT,GEGHME,RWH37)
        X       (INQOUT,GETINQ,RWINQ,TCFLG,2)
        X       (OTQOUT,GETOTQ,RWOTQ,TCFLG,2)
        X       (DCOOUT,GETDCO,RWDCO,TCFLG,1)
        X       (MCOOUT,GETMCO,RWMCO,TCFLG,1)
        X       (CYLOUT,GEXCYL,RWCYL,TCFLG,1)
        X       (GRPOUT,GETGRP,RWGRP,TCFLG,1,U.PRV)  ; only priv may set pack
	X	(ST1OUT,GETST1,RWST1,MFLAG,1)
	X	(ST2OUT,GETST2,RWST2,MFLAG,1)
	X	(ST3OUT,GETST3,RWST3,MFLAG,1)
	X	(ST4OUT,GETST4,RWST4,MFLAG,1)
	X	(ST5OUT,GETST5,RWST5,MFLAG,1)
        X       (RPWOUT,GETRPW,RWRPW,MFLAG,1)
        X       (WPWOUT,GETWPW,RWWPW,DFLAG,1)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC  (NGA,NGAN,^D53,CUSRQQ)

; code for add new gan (add first user in the gan) starts here, only immediate 
; mode and PROCESS command can enter the following codes

; setup NMCPAR, NMCOLN, NMIRC and NMCLSS
        MOVE    AC1,NMCPAR            ; NMCPAR is newly defined in GEYLIC
        LSH     AC1,-^D8
        MOVEM   AC1,NMCPAR
        SETZM   AC1
        MOVE    AC,NMPSW
        CAIE    AC,7400               ; no psw?
         SKIPA
        TLO     AC1,NPS.CD            ; set no-psw bit
        MOVE    AC,ACINVC
        CAIN    AC,3                  ; invoice code = 3 is non-billable
         TLO    AC1,BIL.CD            ; turn on bil.cd if non-billable
        LSH     AC1,-^D16
        MOVEM   AC1,NMCOLN
        SETZM   NMIRC
        MOVEI   AC1,2
        MOVEM   AC1,NMCLSS
        MOVEI   AC1,D.CLS             ; set class 2
        MOVEM   AC1,NMCLSS+1
        MOVEI   AC1,D.GRP             ; set group 1
        TRO     AC1,GRP.CD            ; set group indicator bit
        MOVEM   AC1,NMCLSS+2
        MOVE    AC1,HOST
        TRO     AC1,HOM.CD            ; set home host indicator bit
        MOVEM   AC1,NMCLSS+3
        MOVE    AC1,ACCDIS            ; ACCDIS came from customer
        MOVEM   AC1,NMDIST
 
; add new user to cud
        SETZM   NMGAN
        PUSHJ   P,NUSMUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   NGANE1
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.GAN)       ; get gan
         JRST   GETCMD
        MOVEM   AC1,NMGAN      
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.UUN)       ; get uun for new user
         JRST   GETCMD
        MOVEM   AC1,NMUUN
        PUSHJ   P,GET40
        TCR     (1)
        TYPSTR  ([ASCIZ/********** Global Account Number is /],777,0,T.P0,N)
        TYPNUM  (NMGAN,O,5)
        TCR     (1)
        TYPSTR  ([ASCIZ/********** The Uun for /],777,0,T.P0,N)
        TYPSTR  (NNMSPC,L.UNM,1,0,N)
        TYPSTR  ([ASCIZ/is /],777,1,0,N)
        TYPNUM  (NMUUN,O,5)
        MOVE    AC1,NMCPAR            ; return for next entry
        LSH     AC1,^D8
        MOVEM   AC1,NMCPAR
        MOVE    AC1,NMCOLN            ; return for next entry
        LSH     AC1,^D16
        MOVEM   AC1,NMCOLN
 
; new user for the accounting system type, first get ACCDIS and UASLS from
; customer then get  UALANC and UACURC from table. UARESC is defined
; to be 1 in UPDLUD, therefore, we will not define it here. UAPRIC set equal
; to ACDEFP - customer's price cdoe.
        MOVE    AC1,ACDEFP            ; load in customer's price code
        MOVEM   AC1,UAPRIC            ; pass it to user
        MOVE    AC1,ACCDIS
        MOVEM   AC1,UADIS
        IMULI   AC1,^D10
        MOVE    AC,DISTBL+5(AC1)             ; 6th column is language code
        MOVEM   AC,UALANC
        MOVE    AC,DISTBL+6(AC1)             ; 7th column is currency code
        MOVEM   AC,UACURC
        MOVE    AC1,ACSLS
        MOVEM   AC1,UASLS
        PUSHJ   P,NUSACC
        PUSHJ   P,AGANS
         JRST   NGANE2
        MOVE    AC1,TDIST
        CAIN    AC1,0
         JRST   NGALUD
        PUSHJ   P,NUSNET
        PUSHJ   P,AGANS
         JRST   NGANE2
        JRST    NGALUD
 
; add user in lud - will be treated differently according to system type
  
NGALUD:
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; skip if 370
         JRST   NOTG37
        PUSHJ   P,ADD370
        JRST    NGADNE
NOTG37: CAIE    AC,A940               ; skip if 940
         JRST   NOTG94
        PUSHJ   P,ADD940
        JRST    NGADNE
NOTG94: PUSHJ   P,ADD10
        JRST    NGADNE
 
NGADNE: PUSHJ   P,OLDA
         JRST   NGANE3
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; if 370 then update default core
         JRST   .+6
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM6
        PUSHJ   P,ADDCOR
        PUSHJ   P,OLDA
         JFCL                         ; continue even if error
; tattle
	GETT	(/ADD/)
	 JRST	NEGAN4
	TTFSTR	([ASCIZ/New Gan/])
	PUSHJ	P,ST1UHD
	PUSHJ	P,RELTTF
 
NEGAN4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	NEGAND			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
         JRST   NEGAND
	JRST	NGAST2			; ABRV'ST2 is the menu output section

NEGAND:	; done, successful completion
        TRZ     FLG2,V.GAN
	TRO	FLG,U.OKAY
	POPJ	P,

 
NGANE1: ; error during add new user into the mud
        TYPSTR  ([ASCIZ/Error during Add New Gan in the Cud./])
        PUSHJ   P,ERRCUD
        JRST    NGANE4

NGANE2: ; error during add new user in acctg.
        TYPSTR  ([ASCIZ/Error during Add Gan in Acctg./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        JRST    NGANE4
 
NGANE3:	; error during add user in lud
	TYPSTR	([ASCIZ/Error during Add Gan in the Lud./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        SNDBYT  (ACTPRT,\B.ACOM,REVACT,I)  ; reverse last acctg. entry
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Reverse Acctg. Entry not Working!/])
                 MOVE    AC1,ACANS
                 PUSHJ   P,LUDAOT
                 JRST    GETCMD]
 
NGANE4: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    NGAST2
 
; end of code for new gan
 
GHMEOT: ; display host only if not a request mode
        TLNE    FLG2,V.EXQ!V.LSQ!V.PRQ   ; skip if not exam, list or process
         JRST   .+3
        TLNN    FLG,U.IMM                ; skip if immediate
         JRST   GHMEO2
        PUSHJ   P,HST1OT
        POPJ    P,
GHMEO2:
        TYPSTR  ([ASCIZ/Host :/],777,0,T.P0,N)
        TYPSTR  ([ASCIZ/to be assigned/],777,0,T.P2)
        POPJ    P,
 
GEGHME: ; get host if not a request
        SETZM   HOST
        TLNE    FLG2,V.EXQ!V.LSQ!V.PRQ
         JRST   .+3
        TLNN    FLG,U.IMM             
         POPJ   P,
        INNUM   ([ASCIZ/Host :/],D)
         JRST   [PUSHJ   P,INORNO
                 JRST    GEGHME]
        MOVEM   AC1,LUDNUM
        MOVEM   AC1,HOST
        CAIN    AC1,0
         POPJ   P,                    ; let it go if 0, because we expect 0
                                      ; from request file and we expect it 
                                      ; will be changed during examining
        PUSHJ   P,GETOLD
         JRST   GETCMD
        MOVE    AC1,OLDASY
        CAMN    AC1,ACTSYS
         POPJ   P,
        TYPSTR  ([ASCIZ/Mismatch between host and system type./])
        JRST    GEGHME
 
CMDNAM: ; new army user
;   It is always assumed in immediate mode, ast = 3, host = 47, cylinder =0,
;   cid = 33270, uapric = 176, costc = 3102 and dist = 46.
        TCR     (1)
        TRZ     FLG2,V.NIR
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GETACC
         JRST   GETCMD
        MOVEI   AC1,^D47
        MOVEM   AC1,LUDNUM
        MOVEM   AC1,HOST
        PUSHJ   P,GETOLD
         JRST   GETCMD
        MOVE    AC1,OLDASY
        MOVEI   AC1,3
        MOVEM   AC1,ACTSYS
        MOVEM   AC1,ACTSY2
        MOVEI   AC1,^D33270
        MOVEM   AC1,CUSNUM
        MOVEI   AC1,^D46
        MOVEM   AC1,DISRCT
        MOVEI   AC1,^D3102
        MOVEM   AC1,ACCCC
 
; get new user information
        PUSHJ   P,N7UGAN
        PUSHJ   P,GETNNM
        PUSHJ   P,GEYPSW
        PUSHJ   P,GEYLIC
        PUSHJ   P,GETTMZ
        PUSHJ   P,GETMCO
        SETZM   MFLAG
        SETZM   CYL
 
 
ARMUSR: MOVEI   AC,^D46
        MOVEM   AC,ACCDIS
; setup NMCPAR, NMCOLN, NMIRC and NMCLSS. NMCOLN will be decided by customer
; invoice code instead of NMCOLN of the user in existing gan
; setup NMCPAR, NMCOLN, NMIRC and NMCLSS
        MOVE    AC1,NMCPAR            ; NMCPAR is newly defined in GEYLIC
        LSH     AC1,-^D8
        MOVEM   AC1,NMCPAR
        SETZM   AC1,
        TLO     AC1,BIL.CD            ; set billable bit
        LSH     AC1,-^D16
        MOVEM   AC1,NMCOLN            
        SETZM   NMIRC
        MOVEI   AC1,2
        MOVEM   AC1,NMCLSS
        MOVEI   AC1,D.CLS             ; set class 2
        MOVEM   AC1,NMCLSS+1
        MOVEI   AC1,D.GRP             ; set group 1
        TRO     AC1,GRP.CD            ; set group indicator bit
        MOVEM   AC1,NMCLSS+2
        MOVE    AC1,HOST
        TRO     AC1,HOM.CD            ; set home host indicator bit
        MOVEM   AC1,NMCLSS+3
 
; add new user to cud
        PUSHJ   P,NUSMUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   N8USE1
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.GAN)       ; get gan
         JRST   GETCMD
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.UUN)       ; get uun for new user
         JRST   GETCMD
        MOVEM   AC1,NMUUN
        PUSHJ   P,GET40
        TCR     (1)
        TYPSTR  ([ASCIZ/********** The Uun for /],777,0,T.P0,N)
        TYPSTR  (NNMSPC,L.UNM,1,0,N)
        TYPSTR  ([ASCIZ/is /],777,1,0,N)
        TYPNUM  (NMUUN,O,5)
        PUSHJ   P,ADCL37              ; add class 37
 
; new user for the accounting system type
        MOVE    AC,ACTSYS
        MOVEM   AC,ACTSY2
        MOVEI   AC1,^D176              ; always give 176 pricing code
        MOVEM   AC1,UAPRIC             ; assign 176 pricing code
        PUSHJ   P,NUSACC
        PUSHJ   P,AGANS
         JRST   N8USE2
        JRST    N8ULUD
 
; add user in lud - will be treated differently according to system type
  
N8ULUD:
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM
        PUSHJ   P,ADD370
 
        PUSHJ   P,OLDA
         JRST   N8USE3
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
; write yymmdd.usa file
  ;     GETT    (/USA/)
  ;      JRST   N8USR4
  ;     TTFNUM  (CUSNUM,D)
  ;     TTFNUM  (NMUUN,O)
  ;     TTFSTR  (NNMSPC,L.UNM)
  ;     PUSHJ   P,RELTTF
; tattle
        GETT    (/ADD/)
	 JRST	N8USR4
	TTFSTR	([ASCIZ/New user of existing gan after new customer/])
	PUSHJ	P,ST1UHD
	PUSHJ	P,RELTTF
 
N8USR4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	N8USRD			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
         JRST   N8USRD
	JRST	CMDNAM

N8USRD:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

N8USE1: ; error during add new user into the mud
        TYPSTR  ([ASCIZ/Error during Add New User in the Cud./])
        PUSHJ   P,ERRCUD
        JRST    N8USE4

N8USE2: ; error during add new user in acctg.
        TYPSTR  ([ASCIZ/Error during Add User in Acctg./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        JRST    N8USE4
 
N8USE3:	; error during add user in lud
	TYPSTR	([ASCIZ/Error during Add User in the Lud./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        SNDBYT  (ACTPRT,\B.ACOM,REVACT,I)  ; reverse last acctg. entry
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Reverse Acctg. Entry not Working!/])
                 MOVE    AC1,ACANS
                 PUSHJ   P,LUDAOT
                 JRST    GETCMD]
 
N8USE4: ; after error, see if we can give him another chance
        JRST    GETNON
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        JRST    GETCMD
 
 
GETNON: ; this routine try to get 99999, which will be used to eat all input
        INNUM   ([ASCIZ/? /],D)
         JRST   GETNON
        CAIE    AC1,^D99999
         JRST   GETNON
        JRST    GETCMD
; end of code for new user of existing gan for army customer 33270
CMDSP1: ; special new user command number 1
          ; This command is used to create new users through a file, these
          ; users have common cid, gan, district, cost code and 370 host
          ; number. The processing flow is:
          ;             1. get cid, gan, cost code and host no.
          ;             2. start the loop 
          ;                2.1 get username stop if get c.r.
          ;                2.2 get rest of user's information
          ;                2.3 add user into cud and accounting
          ;                2.4 add user into lud with 0 cyclinder
          ;                2.5 add user mdisk
          ;                2.6 change mdisk passwords
          ;                2.7 change user (default) core
          ;                2.8 add link for user who has 191 mdisk
          ;                2.9 back to loop
         
        TCR     (1)
        TRZ     FLG2,V.NIR
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GETACC
         JRST   GETCMD
        PUSHJ   P,GEYSYS              ; get ast
        PUSHJ   P,GEXCSN              ; get cid
        PUSHJ   P,GEGANN              ; get gan
        PUSHJ   P,GETCOC              ; get cost code
        PUSHJ   P,GEGHME              ; get host number
        PUSHJ   P,GETGRP              ; get set pack
        SETZM   ST1
        SETZM   ST2
        SETZM   ST3
        SETZM   ST4
        SETZM   ST5
; set NMIRC and NMCLSS for adding user into the cud
        SETZM   NMIRC
        MOVEI   AC1,2
        MOVEM   AC1,NMCLSS
        MOVEI   AC1,D.CLS             ; set class 2
        MOVEM   AC1,NMCLSS+1
        MOVEI   AC1,D.GRP             ; set group 1
        TRO     AC1,GRP.CD            ; set group indicator bit
        MOVEM   AC1,NMCLSS+2
        MOVE    AC1,HOST
        TRO     AC1,HOM.CD            ; set home host indicator bit
        MOVEM   AC1,NMCLSS+3
        MOVE    AC1,ACCDIS            ; ACCDIS came from customer
        MOVEM   AC1,NMDIST
 
; set new user's accounting information, first get ACCDIS, UAPRIC and UASLS
; from customer then get UALANC and UACURC from table. UARESC is defined
; to be 1 in UPDLUD, therefore, we will not define it here
        MOVE    AC1,ACDEFP            ; load in customer's price code
        MOVEM   AC1,UAPRIC            ; pass it to user
        MOVE    AC1,ACCDIS
        MOVEM   AC1,UADIS
        IMULI   AC1,^D10
        MOVE    AC,DISTBL+5(AC1)             ; 6th column is language code
        MOVEM   AC,UALANC
        MOVE    AC,DISTBL+6(AC1)             ; 7th column is currency code
        MOVEM   AC,UACURC
        MOVE    AC1,ACSLS
        MOVEM   AC1,UASLS
 
SP1LOP: ; start get username and misc. info
        PUSHJ   P,GESNNM              ; get username
        PUSHJ   P,GESPSW              ; get psw
        PUSHJ   P,GESLIC              ; get (370) licenses
        PUSHJ   P,GETTMZ              ; get time zone
        PUSHJ   P,GETDCO              ; get default core
        PUSHJ   P,GETMCO              ; get maximum core
        PUSHJ   P,GETMDI              ; get mdisk address
        PUSHJ   P,GETCYL              ; get number of cylinders
        PUSHJ   P,GETRPW              ; get mdisk read  psw
        PUSHJ   P,GETWPW              ; get mdisk write psw
        PUSHJ   P,GESLNK              ; get username to be linked to
        PUSHJ   P,GETLND              ; get mdisk addr. to link to
        PUSHJ   P,GESLKA              ; get link addr.
; setup NMCPAR and NMCOLN. (NMIRC and NMCLSS already defined!)
        MOVE    AC1,NMCPAR            ; NMCPAR is newly defined in GESLIC
        LSH     AC1,-^D8
        MOVEM   AC1,NMCPAR
        SETZM   AC1
        MOVE    AC,NMPSW
        CAIE    AC,7400               ; no psw?
         SKIPA
        TLO     AC1,NPS.CD            ; set no-psw bit
        MOVE    AC,ACINVC
        CAIN    AC,3                  ; invoice code = 3 is non-billable
         TLO    AC1,BIL.CD            ; turn on bil.cd if non-billable
        LSH     AC1,-^D16
        MOVEM   AC1,NMCOLN
; add new user to cud
        PUSHJ   P,NUSMUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   SP1ER1
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.GAN)       ; get gan
         JRST   GETCMD
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.UUN)       ; get uun for new user
         JRST   GETCMD
        MOVEM   AC1,NMUUN
        PUSHJ   P,GET40
        TCR     (1)
        TYPSTR  ([ASCIZ/********** The Uun for /],777,0,T.P0,N)
        TYPSTR  (NNMSPC,L.UNM,1,0,N)
        TYPSTR  ([ASCIZ/is /],777,1,0,N)
        TYPNUM  (NMUUN,O,5)
        MOVE    AC1,NMCPAR            ; return for next entry
        LSH     AC1,^D8
        MOVEM   AC1,NMCPAR
        MOVE    AC1,NMCOLN            ; return for next entry
        LSH     AC1,^D16
        MOVEM   AC1,NMCOLN
 
; add user into accounting
        PUSHJ   P,NUSACC
        PUSHJ   P,AGANS
         JRST   SP1ER2
        JRST    SP1LUD
 
; add user in lud - will be treated differently according to system type
 
SP1LUD:
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; skip if 370
         JRST   NOTS37
        MOVE    AC1,CYL
        MOVEM   AC1,TEMCYL            ; save # of cylinders
        SETZM   CYL
        SETZM   MFLAG                 ; for add user of 0 cylinder
        PUSHJ   P,ADD370
        JRST    SP1DNE
NOTS37: CAIE    AC,A940               ; skip if 940
         JRST   NOTS94
        PUSHJ   P,ADD940
        JRST    SP1DNE
NOTS94: PUSHJ   P,ADD10
        JRST    SP1DNE
 
SP1DNE: PUSHJ   P,OLDA
         JRST   SP1ER3
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
 
; if 370, then change default core, add mdisk, change mdisk read/
; write psw, add link
 
; update default core
        MOVE    AC,OLDASY
        CAIE    AC,A370               ; skip if 370
         JRST   SP1TAT
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM6
        PUSHJ   P,ADDCOR
        PUSHJ   P,OLDA
         JRST   SP1ER4
        TYPSTR  ([ASCIZ/Default Core Updated./])
 
; set pack
        SKIPN   PCKG                  
         JRST   SPMSK2
        SNDBYT  (OLDPRT,\B.LCOM,SPKLUD,I)
        SNDSTR  (AC,L.PKGP,PCKG)
        PUSHJ   P,OLDA
         JRST   SP1ER5
        JRST    SPMSK2
SPMSK1:           
        SNDBYT  (OLDPRT,\B.LCOM,SAPLUD,I)
        PUSHJ   P,OLDA
         JRST   SP1ER5
SPMSK2: MOVE    AC1,TEMCYL
        MOVEM   AC1,CYL               ; restore # of cylinders
        SETZM   MFLAG
        MOVE    AC1,MDISK
        CAME    AC1,[ASCIZ/191  /]
         JRST   SPMSK2
        MOVEI   AC,1                  ; if mdisk = 191 then move 1 to mflag
        MOVEM   AC,MFLAG
 
        ; set pack done, now start to add mdisk
        SNDBYT  (OLDPRT,\B.LCOM,AMDLUD,I)       ; add mdisk
        SNDSTR  (AC,L.UNM3,NNMSPC)
        SNDBYT  (AC,\B.FS,FS)         ; for padding only
	SNDSTR	(AC,B.MDI,MDISK)
        SNDBYT  (AC,\B.CYL,CYL)
        MOVE    AC1,MFLAG
        CAIE    AC1,1                 ; skip if mdisk addrs is 191
         JRST   SP1MKD
        SNDSTR  (OLDPRT,L.ST,ST1)
        SNDSTR  (AC,L.ST,ST2)
        SNDSTR  (AC,L.ST,ST3)
        SNDSTR  (AC,L.ST,ST4)
        SNDSTR  (AC,L.ST,ST5)
        SNDBYT  (AC,1,CTRLD)          ; send control-d
        SNDSTR  (AC,^D119,ST3)        ; padding 119 chars.
SP1MKD: PUSHJ   P,OLDA
	 JRST	SP1ER6
        TYPSTR  ([ASCIZ/Add Mdisk Done./])
 
; change mdisk passwords
        SNDBYT  (OLDPRT,\B.LCOM,CMPLUD,I)    
        SNDSTR  (AC,L.UNM3,NNMSPC)
        SNDSTR  (AC,B.MDI,MDISK)
        SNDSTR  (AC,L.UNM3,RPW)
        SNDSTR  (AC,L.UNM3,WPW)
        PUSHJ   P,OLDA
         JRST   SP1ER7
        TYPSTR  ([ASCIZ/Mdisk Passwords Updated./])
 
; add link
        MOVE    AC,NFLAG
        CAIE    AC,1
         JRST   SP1TAT
        SNDBYT  (OLDPRT,\B.LCOM,ALNLUD,I)
        SNDSTR  (AC,L.UNM3,NNMSPC)
        SNDSTR  (AC,B.MDI,MDISC)
        SNDSTR  (AC,L.UNM3,UNMSPC)
        SNDSTR  (AC,B.MDI,NMDSK)
        PUSHJ   P,OLDA
         JRST   SP1ER8
        TYPSTR  ([ASCIZ/Add Link Done./])
; tattle
SP1TAT: GETT    (/ADD/)
	 JRST	SP1LOP
	TTFSTR	([ASCIZ/New User (special)/])
	PUSHJ	P,ST1UHD
	PUSHJ	P,RELTTF
	JRST    SP1LOP               ; get next username

 
SP1ER1: ; error during add new user into the mud
        TYPSTR  ([ASCIZ/Error during Add New User in the Cud./])
        PUSHJ   P,ERRCUD
        JRST    GETCMD                ; return to prompt

SP1ER2: ; error during add new user in acctg.
        TYPSTR  ([ASCIZ/Error during Add User in Acctg./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        JRST    GETCMD                ; return to prompt
 
SP1ER3:	; error during add user in lud
	TYPSTR	([ASCIZ/Error during Add User in the Lud./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        SNDBYT  (ACTPRT,\B.ACOM,REVACT,I)  ; reverse last acctg. entry
        PUSHJ   P,AGANS
         JRST   [TYPSTR  ([ASCIZ/Reverse Acctg. Entry not Working!/])
                 MOVE    AC1,ACANS
                 PUSHJ   P,LUDAOT
                 JRST    GETCMD]
 
        JRST    GETCMD                ; back to prompt
 
SP1ER4: ; error during updating default core
	TYPSTR	([ASCIZ/Error during Updating Default Core./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        JRST    SP1TAT
 
SP1ER5: ; error during setting pack
	TYPSTR	([ASCIZ/Error during Setting Pack./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        JRST    SP1TAT
 
SP1ER6: ; error during adding mdisk
	TYPSTR	([ASCIZ/Error during Adding Mdisk./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        JRST    SP1TAT
 
SP1ER7: ; error during updating mdisk password
	TYPSTR	([ASCIZ/Error during Updating Mdisk Passwords./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        JRST    SP1TAT
 
SP1ER8: ; error during adding link
	TYPSTR	([ASCIZ/Error during Add Link./])
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
        JRST    SP1TAT
 
GESNNM: ; get username
        INSTR   ([ASCIZ/New Username :/],NNMSPC,L.UNM,T)
        MOVEI   AC1,L.UNM
        MOVEI   AC,NNMSPC
        PUSHJ   P,CNTCHR
        SKIPN   AC1
         JRST   GETCMD                ; if c.r. then back to prompt
        PUSHJ   P,CKUNOV              ; make sure name not exist
         JRST   [TYPSTR  ([ASCIZ/Name already exist./])
                 JRST    GETCMD]
        POPJ    P,
 
GESPSW: ; get password (only once) through a file and but no length
        ; and embedded non-alpha character checking. get password cipher
        ; first get password from a device (termianl or file), through
        ; a line (not a token!) because it is allowed to embed a space
        ; into the password
        INSTR   ([ASCIZ/Password :/],PSWSPC,PW.MAX,S) 
        MOVEI   AC,PSWSPC
        MOVEI   AC1,PW.MAX
        PUSHJ   P,CNTCHR
        MOVEM   AC1,SAC               ; ac1 contains real password length
        SNDBYT  (CUDPRT,\B.CCOM,LPCMUD,I)
        MOVE    AC1,SAC
        MOVEI   AC2,PSWSPC
        PUSHJ   P,AUXSOT              ; send password to cud
        SNDBYT  (CUDPRT,1,.CRCUD,I)   ; send c.r.
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JFCL
        GETBYT  (CUDPRT,\B.CYP)       ; get cipher
         JRST   GETCMD
        MOVEM   AC1,NMPSW             ; load cipher
        PUSHJ   P,GET40
        POPJ    P,
 
GESLIC: ; get license
        SETZM   LIC1
        GETYR   ([ASCIZ/A.S.? /])
         JRST   .+4
        MOVE    AC,LIC1
        TRO     AC,1B32
        MOVEM   AC,LIC1
        GETYR   ([ASCIZ/Hush? /])
         JRST   .+4
        MOVE    AC,LIC1
        TRO     AC,1B31
        MOVEM   AC,LIC1
        GETYR   ([ASCIZ/Vlog? /])
         JRST   .+4
        MOVE    AC,LIC1
        TRO     AC,1B34
        MOVEM   AC,LIC1
        GETYR   ([ASCIZ/Focus? /])
         JRST   .+4
        MOVE    AC,LIC1
        TRO     AC,1B30
        MOVEM   AC,LIC1
        POPJ    P,
 
GESLNK: ; get username to be linked to
        SETZM   NFLAG
        INSTR   ([ASCIZ/User to link to :/],UNMSPC,L.UNM3,T)
        MOVEI   AC1,L.UNM3
        MOVEI   AC,UNMSPC
        SKIPN   AC1
         POPJ   P,
        MOVE    AC1,1
        MOVEM   AC1,NFLAG
        POPJ    P,
 
GESLKA: ; get link address
        INSTR   ([ASCIZ/Link addrs :/],MDISC,B.MDI)
        POPJ    P,
 
GEGANN: ; get gan 
        INNUM   ([ASCIZ/Gan :/],O)
         JRST   GEGANN
        MOVEM   AC1,NMGAN
        POPJ    P,
CMDIFP: ; adding new user to customer IAFP
        MOVEI   AC,3
        MOVEM   AC,ACTSYS
        MOVEM   AC,ACTSY2
        PUSHJ   P,GEGHME              ; get 370 host number
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GETACC
         JRST   GETCMD
        PUSHJ   P,IFPGAN              ; get username in IAFP gan
        MOVEI   AC,^D94
        MOVEM   AC,NMDIST             ; dist should be 94 in the mud and lud
 
        ; set up commom accounting information
        
        MOVEM   AC,UADIS              ; dist should be 94 in userdb
        MOVEI   AC,^D54926
        MOVEM   AC,CUSNUM
        MOVEI   AC,1
        MOVEM   AC,UALANC
        MOVEM   AC,UACURC
        MOVEI   AC,2
        MOVEM   AC,UASLS
        MOVEI   AC,^D8
        MOVEM   AC,UAPRIC
        MOVEI   AC,1
        MOVEM   AC,UARESC
        MOVEI   AC,^D3084
        MOVEM   AC,ACCCC
 ;      MOVEI   AC,^D229
 ;      MOVEM   AC,TDIST
 ;      MOVEI   AC,142556
 ;      MOVEM   AC,MMUUN
 
        ; set up common lud information
 
        MOVEI   AC,1
        MOVEM   AC,MFLAG
        SETZ    AC,
        TRO     AC,1B35
        MOVEM   AC,LIC1               ; give tymshare license
        SETZM   ST1
        SETZM   ST2
        SETZM   ST3
        SETZM   ST4
        SETZM   ST5
        PUSHJ   P,GETMCO
        PUSHJ   P,GETGRP
        PUSHJ   P,GETMDI
        PUSHJ   P,GETCYL
        PUSHJ   P,GETRPW
        PUSHJ   P,GETWPW
IAFPLP:
        PUSHJ   P,GESNNM              ; get name and psw (once) from file
        PUSHJ   P,GESPSW
        PUSHJ   P,GETTMZ
     
 
 
; add user into mud, note how to add (two) classes and groups (no host!)
; setup NMCPAR and NMCOLN. (NMIRC and NMCLSS = 1 already defined!)
        MOVE    AC1,NMCPAR            
        LSH     AC1,-^D8
        MOVEM   AC1,NMCPAR
        SETZM   AC1
        MOVE    AC,NMPSW
        CAIE    AC,7400               ; no psw?
         SKIPA
        TLO     AC1,NPS.CD            ; set no-psw bit
        TLZ     AC1,BIL.CD            ; turn off bil.cd for billable user
        LSH     AC1,-^D16
        MOVEM   AC1,NMCOLN
        SNDBYT  (CUDPRT,\B.CCOM,NEWMU2,I)   ; ask for 18-bit uun
        PUSHJ   P,NNMCUD
        SNDBYT  (CUDPRT,\B.CYP,NMPSW) ; send password cipher
        SNDBYT  (AC,1,0,I)
        SNDBYT  (AC,\B.GAN,NMGAN)
        SNDBYT  (AC,1,0,I)
        SETZM   NMUUN
        SNDBYT  (AC,\B.UUN,NMUUN)     
        SNDBYT  (AC,\B.CPR,NMCPAR)
        SNDBYT  (AC,\B.CLN,NMCOLN)
        SNDBYT  (AC,\B.CDST,NMDIST)   ; NMDIST came from old user
        SNDBYT  (AC,\B.IRC,NMIRC)
        SNDBYT  (AC,1,NMCLSS)
        SNDBYT  (AC,2,NMCLSS+1)
        SNDBYT  (AC,2,NMCLSS+2)
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   SP1ER1
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.GAN)       ; get gan
         JRST   GETCMD
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.UUN)       ; get uun for new user
         JRST   GETCMD
        MOVEM   AC1,NMUUN
        PUSHJ   P,GET40
        TCR     (1)
        TYPSTR  ([ASCIZ/********** The Uun for /],777,0,T.P0,N)
        TYPSTR  (NNMSPC,L.UNM,1,0,N)
        TYPSTR  ([ASCIZ/is /],777,1,0,N)
        TYPNUM  (NMUUN,O,5)
        MOVE    AC1,NMCPAR            ; return for next entry
        LSH     AC1,^D8
        MOVEM   AC1,NMCPAR
        MOVE    AC1,NMCOLN            ; return for next entry
        LSH     AC1,^D16
        MOVEM   AC1,NMCOLN
        ; add one more class to the user
        SNDBYT  (CUDPRT,\B.CCOM,ACLMUD,I)
        PUSHJ   P,NNMCUD
        SNDBYT  (CUDPRT,1,NMCLSS+10)  ; note nmclss+10 = 1
        SNDBYT  (AC,2,NMCLSS+11)      ; send class
        SNDBYT  (AC,2,NMCLSS+12)      ; send group
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   GETCMD 
        PUSHJ   P,GET40
 
        MOVEI   AC1,^D99              ; always give 99 pricing code
        MOVEM   AC1,UAPRIC
        PUSHJ   P,NUSACC              ; new user in userdb
        PUSHJ   P,AGANS
         JRST   SP1ER2
 ;      PUSHJ   P,NUSNET              ; new user in tuserdb
 ;      PUSHJ   P,AGANS
 ;       JRST   SP1ER2
        MOVEI   AC,NNMSPC
        MOVEM   AC,NUM
        PUSHJ   P,ADD370              ; new user in the lud
        PUSHJ   P,OLDA
         JRST   SP1ER3
        ; tattle
        GETT    (/ADD/)
         JRST   IAFPLP
        TTFSTR  ([ASCIZ/New IAFP User/])
        PUSHJ   P,ST1UHD
        PUSHJ   P,RELTTF
        JRST    IAFPLP
 
 
 
IFPGAN:   ;  get username in the IAFP gan
        INSTR   ([ASCIZ/Username in desired Gan :/],UNMSPC,L.UNM,T)
        MOVEI   AC,UNMSPC
        MOVEI   AC1,L.UNM
        PUSHJ   P,CNTCHR
        SKIPG   AC1
         JRST   [PUSHJ   P,INORNO
                 JRST    GETCMD]
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GCREC               
         JRST   [PUSHJ   P,INORNO     
                 JRST    GETCMD]
        POPJ    P,
; ***
 
ADDNET: ; this is a temporary code for adding user into tusrdb
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GETACC
         JRST   GETCMD
        PUSHJ   P,GETCUS
         JRST   GETCMD
        PUSHJ   P,GENDI2
        PUSHJ   P,GEMUU2
        PUSHJ   P,GETTCC
NETLOP: PUSHJ   P,GETUNM
         JRST   LUCDON
        PUSHJ   P,GCREC
         JRST   [TYPSTR  ([ASCIZ/gcrec error/])
                 JRST    GETCMD]
        SNDBYT  (ACTPRT,\B.ACOM,ATYACT,I)
        SNDBYT  (AC,\B.GAN,NMGAN)
        SNDBYT  (AC,\B.UUN,NMUUN)
        SNDSTR  (AC,L.UNM,UNMSPC)
        SNDBYT  (AC,\B.CID,CUSNUM)
        SNDBYT  (AC,\B.DIS,TDIST)
        SNDBYT  (AC,\B.UUN,MMUUN)
        SNDBYT  (AC,\B.CC,TCCCC) 
        PUSHJ   P,AGANS
         JRST   ERRO10
        JRST    NETLOP
 
ERRO10:
        TYPSTR  ([ASCIZ/Not successful/])
        JRST    GETCMD
 
 
 
 
 
 
 
 
 
  
CMDCOE: ; this command is used to validate COEES new user on VAX hosts 
        ; only. Only Tymnet validation can use this command to submit the
        ; request. After request is completed, Tymnet validation has to
        ; use CHANGE USER NETCL to change new user's access to the VAX.
 
        TCR     (1)
        TRO     FLG2,V.NIR
 
DEFINE NCOE <
        X       (CSNOUX,CUSGET,RWCSN)
	X	(NNMOUT,GETNNM,RWNNM)
        X       (PSWOUT,GEYPSW,RWPSW)
	X	(SCMOUT,GETSCM,RWSCM,FLG2,V.NIR) ; if (not immediate) or req
>
	EXMMAC  (COE,NCOE,^D65,CUSRQQ)

; code for add new user starts here, only immediate mode and
; PROCESS command can enter the following codes

; setup NMCPAR, NMCOLN, NMIRC, NMDIST and NMCLSS
        PUSHJ   P,GETACC
         JRST   GETCMD
        SETZM   NMCPAR
        SETZM   AC1
        MOVE    AC,NMPSW
        CAIE    AC,7400               ; no psw?
         SKIPA
        TLO     AC1,NPS.CD            ; set no-psw bit
        TLZ     AC1,BIL.CD            ; always billable
        LSH     AC1,-^D16
        MOVEM   AC1,NMCOLN
        SETZM   NMIRC
        MOVEI   AC1,2
        MOVEM   AC1,NMCLSS
        MOVEI   AC1,D.CLS             ; set class 2
        MOVEM   AC1,NMCLSS+1
        MOVEI   AC1,D.GRP             ; set group 1
        TRO     AC1,GRP.CD            ; set group indicator bit
        MOVEM   AC1,NMCLSS+2
        MOVEI   AC1,^D29              ; give temporary host number 29
        TRO     AC1,HOM.CD            ; set home host indicator bit
        MOVEM   AC1,NMCLSS+3
        MOVEI   AC1,^D229
        MOVEM   AC1,NMDIST            ; district is 229
        MOVEI   AC1,7676
        MOVEM   AC1,NMGAN             ; gan is 7676
 
; add new user to cud
        PUSHJ   P,NUSMUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   COEER1
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.GAN)       ; get gan
         JRST   GETCMD
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.UUN)       ; get uun for new user
         JRST   GETCMD
        MOVEM   AC1,NMUUN
        PUSHJ   P,GET40
        TCR     (1)
        TYPSTR  ([ASCIZ/********** The Uun for /],777,0,T.P0,N)
        TYPSTR  (NNMSPC,L.UNM,1,0,N)
        TYPSTR  ([ASCIZ/is /],777,1,0,N)
        TYPNUM  (NMUUN,O,5)
 
; new user in tusrdb (tymnet in accounting data base)
        MOVEI   AC1,^D229
        MOVEM   AC1,TDIST
        MOVEI   AC1,^D3124
        MOVEM   AC1,TCCCC
        MOVEI   AC1,271412
        MOVEM   AC1,MMUUN
        PUSHJ   P,NUSNET
        PUSHJ   P,AGANS
         JRST   COEER2
        PUSHJ   P,LUDAOT
; tattle
	GETT	(/ADD/)
	 JRST	NCOEE4
	TTFSTR	([ASCIZ/New COEES User/])
	PUSHJ	P,ST1UHD
	PUSHJ	P,RELTTF
 
NCOEE4:	TLNE	FLG2,V.PRQ		; skip if we are not processing req
	 JRST	NCOEED			; if this is a request, finish up
	GETYR	([ASCIZ/Do Another?/])
         JRST   NCOEED
	JRST	COEST2			; ABRV'ST2 is the menu output section

NCOEED:	; done, successful completion
	TRO	FLG,U.OKAY
	POPJ	P,

COEER1: ; error during add new user into the mud
        TYPSTR  ([ASCIZ/Error during Add New User in the Cud./])
        PUSHJ   P,ERRCUD
        JRST    COEER4

COEER2: ; error during add new user in acctg.
        TYPSTR  ([ASCIZ/Error during Add User in Tymnet Acctg./])
        MOVE    AC1,ACANS
        PUSHJ   P,LUDAOT
        SNDBYT  (CUDPRT,\B.CCOM,REVMUD,I)   ; remove user without telling pj
        PUSHJ   P,NNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [TYPSTR  ([ASCIZ/Remove User not Working in the CUD!/])
                 JRST    ERRCUD]
        PUSHJ   P,GET40
        JRST    COEER4
 
COEER4: ; after error, see if we can give him another chance
        TLNE    FLG2,V.PRQ            ; skip if not processing a request
         POPJ   P,
        GETYR   ([ASCIZ/Do you want to continue ?/])
         POPJ   P,
        JRST    COEST2
 
; end of code for new user 
 
CUSGET: ; get cid, no checking
        PUSHJ   P,GETCUS
         JRST   .-1
        POPJ    P,
CMDSP2: ; special new user command number 2
          ; This command is used to create new users through a file, these
          ; users have common info except username and they are added to
          ; 370 host only.
         
        TCR     (1)
        TRZ     FLG2,V.NIR
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GETACC
         JRST   GETCMD
        PUSHJ   P,GEYSYS              ; get ast
        PUSHJ   P,GEXCSN              ; get cid
        PUSHJ   P,GEGANN              ; get gan
        PUSHJ   P,GETCOC              ; get cost code
        PUSHJ   P,GEGHME              ; get host number
        PUSHJ   P,GETGRP              ; get set pack
        PUSHJ   P,GESPSW              ; get psw
        PUSHJ   P,GESLIC              ; get (370) licenses
        PUSHJ   P,GETTMZ              ; get time zone
        PUSHJ   P,GETDCO              ; get default core
        PUSHJ   P,GETMCO              ; get maximum core
        PUSHJ   P,GETCYL              ; get number of cylinders
        PUSHJ   P,GETRPW              ; get mdisk read  psw
        PUSHJ   P,GETWPW              ; get mdisk write psw
        PUSHJ   P,GETST1
        PUSHJ   P,GETST2
        PUSHJ   P,GETST3
        PUSHJ   P,GETST4
        PUSHJ   P,GETST5
; set NMIRC and NMCLSS for adding user into the cud
        SETZM   NMIRC
        MOVEI   AC1,2
        MOVEM   AC1,NMCLSS
        MOVEI   AC1,D.CLS             ; set class 2
        MOVEM   AC1,NMCLSS+1
        MOVEI   AC1,D.GRP             ; set group 1
        TRO     AC1,GRP.CD            ; set group indicator bit
        MOVEM   AC1,NMCLSS+2
        MOVE    AC1,HOST
        TRO     AC1,HOM.CD            ; set home host indicator bit
        MOVEM   AC1,NMCLSS+3
        MOVE    AC1,ACCDIS            ; ACCDIS came from customer
        MOVEM   AC1,NMDIST
 
; set new user's accounting information,   first get ACCDIS and UASLS from
; customer then get UAPRIC, UALANC and UACURC from table. UARESC is defined
; to be 1 in UPDLUD, therefore, we will not define it here
        MOVE    AC1,ACCDIS
        MOVEM   AC1,UADIS
        IMULI   AC1,^D10
        MOVE    AC,ACTSY2
        CAIN    AC,A370
         JRST   [MOVE    AC,DISTBL+2(AC1)    ; 3rd column is 370 pricing code
                 JRST    MOVPR2]
        CAIN    AC,A940
         JRST   [MOVE    AC,DISTBL+1(AC1)    ; 2nd column is 940 pricing code
                 JRST    MOVPR2]
        MOVE    AC,DISTBL(AC1)               ; 1st column is pdp10 pricing code
MOVPR2: MOVEM   AC,UAPRIC
        MOVE    AC,DISTBL+5(AC1)             ; 6th column is language code
        MOVEM   AC,UALANC
        MOVE    AC,DISTBL+6(AC1)             ; 7th column is currency code
        MOVEM   AC,UACURC
        MOVE    AC1,ACSLS
        MOVEM   AC1,UASLS
 
SP2LOP: ; start get username and processing
        PUSHJ   P,GESNNM              ; get username
 
; setup NMCPAR and NMCOLN. (NMIRC and NMCLSS already defined!)
        MOVE    AC1,NMCPAR            ; NMCPAR is newly defined in GESLIC
        LSH     AC1,-^D8
        MOVEM   AC1,NMCPAR
        SETZM   AC1
        MOVE    AC,NMPSW
        CAIE    AC,7400               ; no psw?
         SKIPA
        TLO     AC1,NPS.CD            ; set no-psw bit
        MOVE    AC,ACINVC
        CAIN    AC,3                  ; invoice code = 3 is non-billable
         TLO    AC1,BIL.CD            ; turn on bil.cd if non-billable
        LSH     AC1,-^D16
        MOVEM   AC1,NMCOLN
; add new user to cud
        PUSHJ   P,NUSMUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   SP1ER1
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.GAN)       ; get gan
         JRST   GETCMD
        GETBYT  (CUDPRT)
         JRST   GETCMD
        GETBYT  (CUDPRT,\B.UUN)       ; get uun for new user
         JRST   GETCMD
        MOVEM   AC1,NMUUN
        PUSHJ   P,GET40
        TCR     (1)
        TYPSTR  ([ASCIZ/********** The Uun for /],777,0,T.P0,N)
        TYPSTR  (NNMSPC,L.UNM,1,0,N)
        TYPSTR  ([ASCIZ/is /],777,1,0,N)
        TYPNUM  (NMUUN,O,5)
        MOVE    AC1,NMCPAR            ; return for next entry
        LSH     AC1,^D8
        MOVEM   AC1,NMCPAR
        MOVE    AC1,NMCOLN            ; return for next entry
        LSH     AC1,^D16
        MOVEM   AC1,NMCOLN
 
; add user into accounting
        MOVE    AC,NMCOLN
        TLNE    AC,BIL.CD             ; skip if billable
         JRST   .+3                   ; if non-billable then use old UAPRIC
        MOVEI   AC1,^D99
        MOVEM   AC1,UAPRIC            ; assign 99 pricing code
        PUSHJ   P,NUSACC
        PUSHJ   P,AGANS
         JRST   SP1ER2
 
; add user in 370 lud
 
        MOVEI   AC1,1
        MOVEM   AC1,MFLAG
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM
        PUSHJ   P,ADD370
        PUSHJ   P,OLDA
         JRST   SP1ER3
	MOVE	AC1,OLDANS
	PUSHJ	P,LUDAOT
 
 
; update default core
        MOVEI   AC1,NNMSPC
        MOVEM   AC1,NUM6
        PUSHJ   P,ADDCOR
        PUSHJ   P,OLDA
         JRST   SP1ER4
        GETT    (/ADD/)
         JRST   SP2LOP
        TTFSTR  ([ASCIZ/New User (special)/])
        PUSHJ   P,ST1UHD
        PUSHJ   P,RELTTF
        JRST    SP2LOP
DEFINE DEL1 <
	X USER,1,CMDDUS,-1,-1   ; delete user
 >
	SUBCOM	([ASCIZ/Delete :/],DEL,DEL1)
DEFINE DUS1 <
        X MUD,1,DELMUD,U.WC,-1          ; del user from the mud
        X LUD,1,DELLUD,U.WC,-1          ; del user from the lud
	X NETCL,1,CMDDUC,U.WC!U.NET,-1	; del user network class
 >

	SUBCOM ([ASCIZ/Delete User :/],DUS,DUS1)
DELMUD:  ; remove user from the mud
        PUSHJ   P,GETUNM
         JRST   GETCMD
        PUSHJ   P,GETCUD
         JRST   GETCMD
        PUSHJ   P,GCREC1              ; get cud rec. but no passdate format
         JRST   DELMUD
        SNDBYT  (CUDPRT,\B.CCOM,RUSMUD,I)
        PUSHJ   P,SNMCUD
        PUSHJ   P,SND40
        PUSHJ   P,NGANS
         JRST   [PUSHJ   P,ERRCUD
                 JRST    DELMUD]
        PUSHJ   P,GET40
        JRST    DELMUD
CMDDUC:	; delete user class
	TCR	(1)
	PUSHJ	P,GETCUD
	 JRST	GETCMD
	INNUM	([ASCIZ/Class position :/],D)
	 JRST	[PUSHJ P,INORNO
		 JRST	CMDDUC]
	MOVEM	AC1,CLSWPO
	JUMPLE	AC1,CMDUC0
	CAIG	AC1,NMNCLS
	 JRST	CMDUC1
CMDUC0:	TYPSTR	([ASCIZ/Bad position number./])
	PUSHJ	P,INORNO
	JRST	CMDDUC
CMDUC1:	TCR	(1)
	PUSHJ	P,GETUNM
	 JRST	CMDUCD
	PUSHJ	P,GCREC
	 JRST	CMDDUC1
	MOVE	AC1,CLSWPO
	SOJ	AC1,
	IMULI	AC1,NMSZCS
	SKIPG	NMCLSS(AC1)
	 JRST	CMDUCE
	SNDBYT	(CUDPRT,\B.CCOM,RCLMUD,I)
	PUSHJ	P,SNMCUD
	SNDBYT	(CUDPRT,1,CLSWPO)
	PUSHJ	P,SND40
	PUSHJ	P,NGANS
	 JFCL
	PUSHJ	P,NANOUT
	PUSHJ	P,GET40
	GETT	(/ADD/)
	 JRST	CMDUC1
	TTFSTR	([ASCIZ/Delete User Class./])
	PUSHJ	P,STDUHD
	PUSHJ	P,RELTTF
	JRST	CMDUC1

CMDUCD:
	TRO	FLG,U.OKAY
	POPJ	P,

CMDUCE:
	TYPSTR	([ASCIZ/No such class position./])
	JRST	CMDUC1
 
ADD940:
        JFCL
 
 
ADCL37: ; add class 37 for Army Corp. users
        MOVEI   AC1,3
        MOVEM   AC1,CLSWRK
        MOVEI   AC1,45
        MOVEM   AC1,CLSWRK+1          ; class 37
        MOVEI   AC1,1
        TRO     AC1,GRP.CD
        MOVEM   AC1,CLSWRK+2          ; non-home group 1
        MOVEI   AC1,57
        TRO     AC1,HOM.CD
        MOVEM   AC1,CLSWRK+3          ; home host 47
        MOVEI   AC1,235
        MOVEM   AC1,CLSWRK+4          ; 2nd host 157
	SNDBYT	(CUDPRT,\B.CCOM,ACLMUD,I)
	PUSHJ	P,NNMCUD
        SNDBYT  (CUDPRT,1,CLSWRK)
	SNDBYT	(AC,\B.CLS,CLSWRK+1)
	SNDBYT	(AC,\B.GRPH,CLSWRK+2)
	SNDBYT	(AC,\B.GRPH,CLSWRK+3)
	SNDBYT	(AC,\B.GRPH,CLSWRK+4)
        PUSHJ   P,SND40
	PUSHJ	P,NGANS
	 JFCL
	PUSHJ	P,NANOUT
	PUSHJ	P,GET40
	POPJ	P,
    <\XZh