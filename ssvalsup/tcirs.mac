SUBTTL CIRS - CIRCUIT ROUTINES

COMMENT '
BLDCIR creates an auxiliary circuit.
AC/  byte pointer
AC1/ system number
AC2/ address of login string
'
BLDCIR:	MOVEM	AC2,NUM			; SAVE THE STRING ADDRESS
	PUSHJ	P,MAKLOG		; CREATE LOGIN STRING
	MOVE	AC,NUM			; RESTORE ADDRESS
	CREAUX	AC,			; GET THE CIRCUIT
	JRST	BLDCER			; ERROR
	AOS	(P)			; SET TO SKIP RETURN
	POPJ	P,
BLDCER:	MOVEM	AC,BCERCD		; SAVE ERROR CODE
	TCR	(1)
	TYPSTR	([ASCIZ/Circuit error -/],777,0,0,N)
	HLRZ	AC1,BCERCD		; GET HOST ERROR CODE
	JUMPE	AC1,SUPER1		; IT IS A SUPERVISOR ERROR
	JUMPL	AC1,SUPERR
	CAIL	AC1,MAXHER		; MAX REASONABLE HOST ERROR CODE
	JRST	SUPERR
        PUSH    P,AC1
	HRRZ	AC,MHSTER(AC1)		; GET ADDRESS OF ERROR MESSAGE
	MOVEM	AC,NUM
	TYPSTR	(@NUM,777,1)		; OUTPUTS IT
        POP     P,AC1
        HLRZ    AC,MHSTER(AC1)
        TRNE    AC,X.S
        JRST    ERREX0
        TRNE    AC,X.A
        JRST    TRY10M
	POPJ	P,
SUPERR: MOVEM	AC1,NUM
	TYPSTR	([ASCIZ/Host Code:/],777,1,0,N)
	TYPNUM	(NUM,O,1)
	TYPSTR	([ASCIZ/-/],777,0,^D15,N)
        HRRZ    AC1,BCERCD
        JRST    SUPER2
SUPER1: HRRZ	AC1,BCERCD		; GET SUPERVISOR ERROR CODE
	JUMPLE	AC1,SUPER2
	CAIL	AC1,MAXSER		; MAX REASONABLE SUP ERROR CODE
	JRST	SUPER2
        PUSH    P,AC1
	HRRZ	AC,MSUPER(AC1)		; GET ADDRESS OF SUP ERROR MESSAGE
	MOVEM	AC,NUM
	TYPSTR	(@NUM,777,1)
        POP     P,AC1
        HLRZ    AC,MSUPER(AC1)
        TRNE    AC,X.S
        JRST    ERREX0
        TRNN    AC,X.A
	POPJ	P,
TRY10M: TYPSTR  ([ASCIZ"Please try again in 10 minutes."])
	TCR	(1)
        POPJ    P,
SUPER2:	MOVEM	AC1,NUM
	TYPSTR	([ASCIZ/Supervisor Code:/],777,1,0,N)
	TYPNUM	(NUM,O,1)
	JRST	ERREX0

MAKLOG:	; MAKE A LOGIN STRING
	PUSHJ	P,BINDEC
	MOVEI	AC1,SEMIC		; SET TO PUT IN THE SEMI COLON
	IDPB	AC1,AC			; DO IT
	POPJ	P,

G1234:	; GET HANDSHAKE
	MOVE	AC4,[G1234C,,TL.HSK]
	PUSHJ	P,STIMER
G1234B:	PUSHJ	P,AINCHR		; GET A CHAR IN AC1
	JRST	G1234D
	CAIE	AC1,1			; SKIP IF 1
	JRST	G1234B
	PUSHJ	P,AINCHR		; GET A CHAR
	JRST	G1234D
	CAIE	AC1,2
	JRST	G1234B
	PUSHJ	P,AINCHR
	JRST	G1234D
	CAIE	AC1,3
	JRST	G1234B
	PUSHJ	P,AINCHR
	JRST	G1234D
	CAIE	AC1,4
	JRST	G1234B
	AOS	(P)
G1234D: PUSHJ	P,RTIMER
	POPJ	P,

G1234C:	; TRAP TO HERE ON TIMEOUT.
	HLRZS	AC			; SET TO ZAP THE PORT
	ZAPCIR	AC,
        TCR     (1)
	TYPSTR	([ASCIZ/Circuit error - Handshake Timeout./],777,0,0,Y,Y)
        TYPSTR  ([ASCIZ/Please try again in 10 minutes./])
	MOVEI	AC4,G1234D		; ADDRESS TO DISMISS TO
	MOVEM	AC4,TRPVEC
	DISMIS

S1234:	; RESPOND HANDSHAKE
	MOVEI	AC1,1			; STARTING CHAR
S1234B:	CAIL	AC1,5			; SKIP IF LESS THEN 5
	JRST	S1234D	 		; DONE
	PUSHJ	P,AONCHR		; SEND THE CHAR
	AOJA	AC1,S1234B		; DO THE REST
S1234D:	MOVEM	AC,NUM
	TCR	(1)
	MOVE	AC,NUM	 		; RESTORE PORT NUMBER FROM NUM
	POPJ	P,

AINCHR:	; INPUT A CHARACTER FROM THE AUX. PORT AC, RETURN CHARACTER IN AC1
	HRL	AC2,AC			; THE PORT NUMBER
	HRRI	AC2,.AXI8C		; PREPARE FOR AUXCAL
	AUXCAL	AC2,AC1
	JRST	AINCH2
	AOS	(P)
	POPJ	P,
AINCH2:	PUSHJ	P,CHKPRT
	POPJ	P,
	JRST	AINCHR

AONCHR:	; OUTPUT A CHAR TO AUX PORT IN AC, CHAR FROM AC1
	HRL	AC4,AC			; THE PORT NUMBER
	HRRI	AC4,.AXO8		; GET READY FOR AUXCAL
	AUXCAL	AC4,AC1			; DO IT
	POPJ	P,

G4BYT:	; INPUT 4 BYTES FROM AN AUX CIRCUIT, PUT INTO AC1. AC/ PORT NO.
	MOVEI	AC3,4			; NUMBER OF BYTES
	JRST	GAUXC			; DO IT
G3BYT:	; INPUT 3 BYTES
	MOVEI	AC3,3
	JRST	GAUXC
G2BYT:	; INPUT 2 BYTES
	MOVEI	AC3,2
	JRST	GAUXC
G1BYT:	; INPUT A BYTE
	MOVEI	AC3,1
COMMENT '
GAUXC gets 1,2,3, or 4 bytes from an auxiliary circuit.
AC/  The port number
AC1/ Result
AC3/ Number of bytes to get
'
GAUXC:	SETZ	ACX,			; ZERO RESULT FIELD
GAUXC1:	PUSHJ	P,GAUX			; GET A BYTE
	POPJ	P,			; ERROR
	TRZN	FLG,U.C377		; SKIP IF U.C377 IS SET
	JRST	GAUXC2			; DON'T BOTHER
	CAIN	AC1,377
	JRST	GAUXD2			; TERMINATE
GAUXC2:	LSH	ACX,^D8			; SHIFT PREVIOUS VALUE
	OR	ACX,AC1			; INCLUDE CURRENT BYTE
	SOJG	AC3,GAUXC1		; DO THE REST
GAUXD:	MOVE	AC1,ACX			; MOVE RESULT TO AC1
GAUXD2:	AOS	(P)			; RETURN
	POPJ	P,

GAUX:	; INPUT CHARS FROM AUX CIRCUIT, RETURN RESULT IN AC1
	SETZ	AC1,			; RESET AC1
	PUSH	P,AC4
	MOVE	AC4,[ATOABT,,TL.AUX]
	PUSHJ	P,STIMER
	POP	P,AC4
GAUX2:	PUSHJ	P,AINCHR		; GET A CHAR
	JRST	GAUXE			; ERROR
	AOS	(P)
GAUXE:	PUSHJ	P,RTIMER
	POPJ	P,

S4BYT:	; SEND 4 BYTES THROUGH AUX CIRCUIT
	MOVEI	AC3,4			; NUMBER OF BYTES
	LSH	AC2,^D4			; LEFT JUSTIFY
	JRST	SAUXC
S3BYT:	; SEND 3 BYTES THROUGH AUX CIRCUIT
	MOVEI	AC3,3			; NUMBER OF BYTES
	LSH	AC2,L.UNM		; LEFT JUSTIFY
	JRST	SAUXC
S2BYT:	; SEND 2 BYTES THROUGH AUX CIRCUIT
	MOVEI	AC3,2			; NUMBER OF BYTES
	LSH	AC2,^D20		; LEFT JUSTIFY
	JRST	SAUXC
S1BYT:	; SEND 1 BYTE THROUGH AUX CIRCUIT
	MOVEI	AC3,1			; NUMBER OF BYTES
	LSH	AC2,^D28		; LEFT JUSTIFY
COMMENT '
SAUXC sends 1,2,3, or 4 bytes through auxiliary circuit.
AC/  The port number
AC2/ Bytes to send
AC3/ Number of bytes
'
SAUXC:	SETZ	AC1,			; RESET AC1
	LSHC	AC1,^D8			; GET A CHAR IN AC1
	PUSHJ	P,AONCHR		; SEND IT
	SOJG	AC3,SAUXC		; DO THE REST
	POPJ	P,
COMMENT '
AUXSIN inputs a string from auxiliary circuit.
AC/  Port number
AC1/ Length
AC2/ Address of string
'
AUXSIN:	MOVE	AC3,AC1			; MOVE LENGTH IN CHARS TO AC3
	IDIVI	AC3,5			; CONVERT TO WORDS
	SKIPE	AC3+1			; SKIP IF NO REMAINDER
	AOJ	AC3,			; ROUND UP
	MOVE	AC4,AC3			; MOVE ROUNDED LENGTH TO AC4
	ADD	AC4,AC2			; ADD START ADDRS TO GET LAST WORD+1
	MOVEI	AC3,1(AC2)		; PREPARE TO CLEAR AREA
	HRL	AC3,AC2			; AC3/ START,,START+1
	SETZM	0(AC2)			; ZERO FIRST WORD
	BLT	AC3,-1(AC4)		; CLEAR AREA
	MOVEM	AC1,AUXIC		; SAVE COUNT
	HRLI	AC2,(POINT 7)		; MAKE A BYTE POINTER
	MOVEM	AC2,AUXIP		; SAVE IT
AUXSI2:	SOSGE	AUXIC			; SKIP IF WE WANT MORE
	JRST	AUXSI3
	GETBYT	(AC)			; GET A BYTE
	JRST	GETCMD
	CAIN	AC1,377			; SKIP IF NOT END
	JRST	AUXSI3
	ADDI	AC1,BLNK		; MAKE ASCII
	IDPB	AC1,AUXIP		; DEPOSIT IT
	JRST	AUXSI2
AUXSI3:	POPJ	P,			; RETURN

COMMENT '
AUXSOT outputs a string through an auxiliary circuit in sixbit per character.
AC/  Port number
AC1/ Length
AC2/ Address of string
'
AUXSOT:	MOVEM	AC1,SNDSCT		; SAVE THE COUNT
	HRLI	AC2,(POINT 7)		; MAKE A BYTE POINTER
	MOVEM	AC2,SNDSBP		; SAVE IT
AUXSO2:	ILDB	AC2,SNDSBP		; GET A CHAR
	TRNN	FLG,U.ASC		; SKIP IF SEND ASCII
	SUBI	AC2,40			; ADJUST
	SNDBYT	(AC,1,AC2)		; SEND A BYTE
	SOSLE	SNDSCT			; REDUCE COUNT SKIP IF NONE LEFT
	JRST	AUXSO2			; DO NEXT CHAR
	POPJ	P,			; OR RETURN IF DONE

CHKPRT:	; CHECK AUX CIRCUITS
	HRLI	AC1,-PTBLEN		; LENGTH OF PORT TABLE
	HRRI	AC1,PTABL		; ADDRESS
	AUXRED	AC1,			; READ PORTS
	JFCL
	TRNN	FLG,U.ACT		; SKIP IF WE SHOULD HAVE ACTG CIRCUIT
	JRST	CHKPR2
	MOVEM	AC,SAC			; SAVE CURRENT PORT NUMBER
	MOVE	AC,ACTPRT		; GET ACT PORT NUMBER
	PUSHJ	P,CHKPRR		; TRY TO FIND IT
	JRST	CHKPR2			; GO CHECK CUD PORT
	TRZ	FLG,U.ACT		; ERROR RETURN, RESET FLAG
	SETZM	ACTPRT			; RESET PORT NUMBER
        TCR     (1)
	TYPSTR	([ASCIZ/Accounting Circuit zapped due to inactivity./],777,0,0,Y,Y)
        TCR     (1)
	POPJ	P,
CHKPR2:	TRNN	FLG,U.CUD
	JRST	CHKPR3
	MOVE	AC,CUDPRT		; GET CUD PORT NUMBER
	PUSHJ	P,CHKPRR
	JRST	CHKPR3
	TRZ	FLG,U.CUD		; RESET CUD PORT FLAG
	SETZM	CUDPRT			; RESET PORT NUMBER
        TCR     (1)
	TYPSTR	([ASCIZ/Controling User Directory Circuit zapped due to inactivity./],777,0,0,Y,Y)
        TCR     (1)
	POPJ	P,
CHKPR3:	AOS	(P)
	POPJ	P,

CHKPRR:	; TRY TO LOCATE PORT IN AC IN TABLE, SKIP RETURN IF NOT FOUND
	SETZ	AC1,			; INDEX
CHKPLP:	SKIPGE	PTABL(AC1)
	JRST	CHKRR2			; NOT FOUND
	CAMN	AC,PTABL(AC1)		; SKIP IF NO MATCH FOUND YET
	JRST	CHKRR3			; FOUND
	AOJA	AC1,CHKPLP		; DO THE REST
CHKRR2:	AOS	(P)
CHKRR3:	POPJ	P,

GETACC:	; GET A CIRCUIT TO THE ACCOUNTING SYSTEM
	TRNE	FLG,U.ACT		; SKIP IF WE DO NOT YET HAVE AN ACT CIR
	JRST	GETACD			; SUCESSFUL RETURN
	TYPSTR	(MBDACT,777,0,0,N)
	MOVE	AC,ACTBP		; BYTE POINTER TO CUD10 LOGIN STRING
	MOVE	AC1,ACTHOS		; ACCTG HOST NUMBER
	MOVEI	AC2,ACTSTR		; LOGIN STRING
	PUSHJ	P,BLDCIR		; BUILD THE CIRCUIT
	JRST	GETACE			; ERROR RETURN
	MOVEM	AC,ACTPRT		; SAVE THE PORT NUMBER
	TRO	FLG,U.ACT		; SET ACT CIRCUIT FLAG
	HRLZS	AC
	HRRI	AC,.AXO8I		; SET TO TYPE CR
	AUXCAL	AC,.CR
	AUXCAL	AC,.CR
	HRRI	AC,.AXOST		; SET TO RUN UPDLUD
	AUXCAL	AC,PRGAC
	MOVE	AC,ACTPRT
	PUSHJ	P,G1234			; GET ANSWER
	JRST	GETACE
	PUSHJ	P,S1234			; SEND RESPONSE
GETACD:	AOS	(P)
	POPJ	P,
GETACE:	TRZ	FLG,U.ACT		; SET FLAG OFF
	SETZM	ACTPRT			; ZERO PORT CELL
	POPJ	P,

GETCUD:	; GET A CIRCUIT TO THE CUD
	TRNE	FLG,U.CUD		; SKIP IF WE DO NOT YET HAVE A CIRCUIT
	JRST	GOTCUD			; SUCCESSFUL RETURN
	TYPSTR	(MBDCUD,777,0,0,N)
	MOVE	AC,CUDBP		; BYTE POINTER TO LOGIN STRING
	MOVEI	AC1,10			; LOAD IN DUMMY NUMBER AS CUD HOST NO.
	MOVEI	AC2,CUDSTR		; LOGIN STRING ADDRESS NCUD1;
	PUSHJ	P,BLDCIR		; GET A CIRCUIT
	JRST	GETCUE
	MOVEM	AC,CUDPRT		; SAVE THE PORT NUMBER
	TRO	FLG,U.CUD		; SET CUD CIRCUIT FLAG
	HRLZS	AC
	HRRI	AC,.AXO8I		; SET TO TYPE CR'S
	AUXCAL	AC,.CR
	AUXCAL	AC,.CR
	AUXCAL	AC,.CR
	HLRZS	AC
	PUSHJ	P,G1234
	JRST	GETCUE
	PUSHJ	P,S1234
	PUSHJ	P,SENDID
	JRST	[HRRZ	AC,CUDPRT
		 ZAPCIR	AC,
		 TRZ	FLG,U.CUD
		 SETZM	CUDPRT
		 PUSHJ	P,NANOUT
		 POPJ	P,]
GOTCUD:	AOS	(P)			; SKIP RETURN
	POPJ	P,
GETCUE:	TRZ	FLG,U.CUD		; SET FLAG OFF
	SETZM	CUDPRT			; ZERO PORT CELL
	POPJ	P,

ACTCUD:	; GET CIRCUITS TO ACTG. AND CUD
	TCR	(1)
	TRNN	FLG,U.ACT		; SKIP IF WE HAVE AN ACTG. CIR
	JRST	ACTCU1
	TRNE	FLG,U.CUD
	JRST	ACTCU2
ACTCU1:	PUSHJ	P,GETACC
	POPJ	P,
	PUSHJ	P,GETCUD
	POPJ	P,
	TCR	(1)
ACTCU2:	AOS	(P)
	POPJ	P,

BLDCUD:	TCR	(1)
	TRNE	FLG,U.CUD
	JRST	BDCUD1
	PUSHJ	P,GETCUD
	POPJ	P,
	TCR	(1)
BDCUD1:	AOS	(P)
	POPJ	P,

BLDACT:	TCR	(1)
	TRNE	FLG,U.ACT
	JRST	BDACT1
	PUSHJ	P,GETACC
	POPJ	P,
	TCR	(1)
BDACT1:	AOS	(P)
	POPJ	P,

SENDID: ; Send login username and PDP-10 frame ID to NetVal Operator Log
	SNDBYT	(CUDPRT,\B.CCOM,^D13,I)
	SNDBYT	(CUDPRT,1,LOGIDL,C)
	TRO	FLG,U.ASC
	SNDSTR	(CUDPRT,@LOGIDL,LOGID)
	TRZ	FLG,U.ASC
	PUSHJ	P,SND40
	PUSHJ	P,NGANS
	JFCL
	PUSHJ	P,GET40
	MOVE	AC1,NMANS
	CAIN	AC1,CUD.OK
	AOS	0(P)
	POPJ	P,

MKLGID: ; Make the identification remark for NetVal Operator Log file
	CONCAT	(LOGID,[ASCIZ"TYMVAL - "],0,^D9)
	CONCAT	(LOGID,MY.UNM,^D9,L.UNM)
	CONCAT	(LOGID,[ASCIZ" - #"])
	PJOB	AC,
	MOVEI	AC4,^D10
	PUSHJ	P,NUMOUT
	CONCAT	(LOGID,NUMSP,777,3)
	MOVEI	AC,LOGID
	MOVEI	AC1,^D30
	PUSHJ	P,CNTCHR
	MOVEM	AC1,LOGIDL
	POPJ	P,

STIMER: ; Set timer. AC4 contains [Trap routine address,,no. of seconds]
	HLRZM	AC4,TRPVEC+1
	PUSH	P,AC4
	SETZ	AC4,
	SETTIM	AC4,			; Reset timer
	JFCL
	MOVE	AC4,[IA.REE,,TRPVEC]	; Initialize interrupt address system.
	INTADR	AC4,			; Get ready to set timer interrupt
	BOMB	(ERR.IS)		; Unable to set timer
	POP	P,AC4
	HRLI	AC4,T.SEC
	SETTIM	AC4,			; Set timer interrupt
	JFCL
	MOVE	AC4,[.IATIM,,TIM.CH]	; To assign interrupt causes
	INTASS	AC4,
	BOMB	(ERR.IC)		; Unable to assign interrupt causes
	HRLZI	AC4,(1B0!1B1!1B2)	; Enable interrupt on channel 1 and 2
	INTENB	AC4,
	BOMB	(ERR.IA)		; Interrupt address not in effect
	POPJ	P,

RTIMER: ; Clear timer
	PUSH	P,AC4
	HRLZI	AC4,IA.CLR		; To disable interrupt address system
	INTADR	AC4,
	BOMB	(ERR.CL)		; Unable to clear INTADR system
	SETZ	AC4,
	SETTIM	AC4,			; Reset timer
	JFCL
	MOVE	AC4,[IA.REE,,TRPVEC]
	INTADR	AC4,
	BOMB	(ERR.IA)
        HRLZI   AC4,(1B0!1B2)
        INTENB  AC4,
	BOMB	(ERR.IA)		; Interrupt address not in effect
        POP     P,AC4
	POPJ	P,			; Return

ATOABT: ; Aux. timeout
	PUSH	P,AC
	TCR	(1)
	POP	P,AC
	CAMN	AC,CUDPRT
	JRST	[ZAPCIR	AC,
		 SETZM	CUDPRT
		 TRZ	FLG,U.CUD
		 TYPSTR	([ASCIZ"Controlling User Directory circuit timeout."])
		 JRST	AUX.TO]
	CAMN	AC,ACTPRT
	JRST	[ZAPCIR	AC,
		 SETZM	ACTPRT
		 TRZ	FLG,U.ACT
		 TYPSTR	([ASCIZ"Accounting circuit timeout."])
		 JRST	AUX.TO]
	HRRZS	AC
	ZAPCIR	AC,
	TYPSTR	([ASCIZ"Circuit error - Timeout."])
AUX.TO: MOVEI	AC,TO.RTN
	MOVEM	AC,TRPVEC
	DISMIS

TO.RTN: PUSHJ	P,RTIMER
	TCR	(1)
	JRST	GETCMD
    