!;---------------------------------------------------------------------
!dif (peakx)DED.DEF,(peak)

1)1	ifcr Host.Sys = 10 thenc
****
2)1	define
2)	  WarpLoad = false;
2)	    ! Bill Soley designed a mechanism called WARP to decrease the time
2)	    ! it takes SAIL programs to come up when they are run.  This
2)	    ! switch controls the use of this mechanism in Peak initialization
2)	    ! and loading.
2)	    !
2)	    ! If WarpLoad = true, then, when the .SAV file produced from the
2)	    ! normal compile and link is run, it will proceed as usual, doing
2)	    ! instantiation independent initialization, until the Warp()
2)	    ! routine is called.  This routine will take the core image at
2)	    ! that point and map it to the file PEAK.WRP.
2)	    !
2)	    ! The Program named WARPLD, when renamed to PEAK.SAV, will map
2)	    ! the file PEAK.WRP from the homefile directory, and proceed to
2)	    ! execute it from the point it left off, presumably proceeding to
2)	    ! instantiation dependent initialization.
2)	    ;
2)	ifcr Host.Sys = 10 thenc
**************
1)1	    Debug   = true;
1)	endc
****
2)1	    Debug   = false;
2)	endc
**************
1)1	!version(!ver('2, '0), !edit('301), !date(23-April-1984));
1)	define
****
2)1	!version(!ver('2, '0), !edit('313), !date(18-July-1984));
2)	define
**************
1)2	! ------------------------------------------------------------------------;
1)3	!! title Operating System dependent definitions. ;
1)	! ------------------------------------------------------------------------;
****
2)2	! V2.0(303)     6.25.84         Add WarpLoad capability for fast and easy
2)	!                               loading of Peak.  See above description)
2)	!
2)	! V2.0(305)     7.10.84         Change the Checkpoint mechanism to utilize
2)	!                               a deferred timer interrupt to occasion its
2)	!                               magic.  This causes Peak to be in TI state
2)	!                               when awaiting terminal input, rather than
2)	!                               SL.  This results in potentially dramatic
2)	!                               response improvements since the Tymcom-X
2)	!                               scheduler places a process returning from
2)	!                               TI wait at the front of QUEUE 1, and a
2)	!                               process returning from SL at the end of
2)	!                               QUEUE 3.
2)	!
2)	! ------------------------------------------------------------------------;
2)3	!! title Operating System dependent definitions ;
2)	! ------------------------------------------------------------------------;
**************
1)4	!                         From the Command Module
****
2)4	!
2)	!                         From the Command Module
**************
1)4	  C!RFSearch = {C!A000};
1)	!                         From the Buffer Module
****
2)4	  C!RFSearch = {C!A000},
2)	  C!DoChkPnt = {C!A001};
2)	!                         From the Buffer Module
**************
1)4	  B!DeAllocateMark      = {B!A00U};
1)	! ------------------------------------------------------------------------;
****
2)4	  B!DeAllocateMark      = {B!A00U},
2)	  B!ChkPntModP          = {B!A00V};
2)	! ------------------------------------------------------------------------;
2)5	!! title Interrupt and I/O related stuff ;
2)	! ------------------------------------------------------------------------;
2)	!
2)	!                    Definitions of various identities
2)	!                relating to Interrupt and I/O Processing
2)	;
2)	ifcr TymcomX thenc
2)	  ! This stuff only works for the present on Tymcom-X (7.5.84).  It may
2)	  ! only be necessary on Tymcom-X, for that matter.
2)	  ;
2)	  define
2)	    ChkPntChn = 10,
2)	    AuxWinChn = 11;
2)	      ! Channels on which our home grown interrupts will be enabled.  These
2)	      ! are scientifically designed to stay out of SAIL's way, since they
2)	      ! are in the "middle" of the allowable range [1, 35].
2)	      ;
2)	! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
2)	  define
2)	    !axi8c        = '0                  ! Input Image Character (wait for
2)	                                        ! character).
2)	                                        ;,
2)	    !axi8s        = '1                  ! Input Image Character (skip if
2)	                                        ! character was returned).
2)	                                        ;,
2)	    !axsi         = '33                 ! Simulate input on port.
2)	                                        ;,
2)	    !axsic        = '10                 ! Skip if character in input
2)	                                        ! buffer.
2)	                                        ;,
2)	    !axo8         = '3                  ! Output Image Character.
2)	                                        ;,
2)	    !axo8i        = '4                  ! Output image character immediate.
2)	                                        ;,
2)	    !axlde        = '11                 ! Leave Deferred Echo Mode.
2)	                                        ;,
2)	    !iachr        = '1                  ! Receipt of a Character (cause
2)	                                        ! for an interrupt).
2)	                                        ;,
2)	    !iatim        = '4                  ! Timer interrupt cuase.
2)	                                        ;,
2)	    !gtunm        = -'22                ! Username(1)
2)	                                        ;,
2)	    !gtun1        = -'21                ! Username(2)
2)	                                        ;,
2)	    !cnsys        = '33                 ! System Number Gettab Item
2)	                                        ! designator.
2)	                                        ;,
2)	    !gtcnf        = '11                 ! System Configuration Data Gettab
2)	                                        ! table number.
2)	                                        ;,
2)	    calli!AuxRed  = -'46                ! Read AuxCircuit count function
2)	                                        ! code.
2)	                                        ;,
2)	    calli!CreAux  = -'44                ! CreAux function code.
2)	                                        ;,
2)	    calli!GetTab  = '41                 ! Gettab function code.
2)	                                        ;,
2)	    calli!Hiber   = '72                 ! Hiber function code.
2)	                                        ;,
2)	    calli!Timer   = -'37                ! Timer interrupt function code.
2)	                                        ;,
2)	    calli!Wake    = '73                 ! Wake function code.
2)	                                        ;,
2)	    calli!ZapCir  = -'45                ! Zap the aux circuit function
2)	                                        ! code.
2)	                                        ;;
2)	      ! Miscellaneous monitor symbols from uuosym.def.
2)	      ;
2)	  define
2)	    cxsup# = '0,
2)	    cx2ax# = '1,
2)	    cxlog# = '2,
2)	    cxdcb# = '3,
2)	    cxnrr# = '4,
2)	    cxnrl# = '5,
2)	    cxnch# = '6,
2)	    cxerr# = '7,
2)	    cxsfe# = '1,
2)	    cxsbu# = '2,
2)	    cxsbm# = '3,
2)	    cxshu# = '4,
2)	    cxsdf# = '5,
2)	    cxsto# = '6,
2)	    cxsab# = '7,
2)	    cxsis# = '10,
2)	    cxslq# = '11;
2)	      ! CreAux error condition symbols.
2)	      ;
2)	! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
2)	!
2)	!
2)	!                       Interrupt Administration functions
2)	!
2)	!
2)	!       Note:  newenb below means "use the new (=NEWENB) as opposed to old
2)	!       (=APRENB) interrupt system for TymcomX".
2)	;
2)	  require "<><>" delimiters;
2)	  define
2)	    intass (cause, channel) =
2)	        <xwd((cause), (bit(20) + (channel)))>,
2)	    tinass (port, cause, channel) =
2)	        <xwd((port), (bit(5, 20) + (cause lsh 9) + (channel)))>,
2)	    intdev (device, cause, channel) =
2)	        <xwd((device), (bit(7, 20) + (cause lsh 9) + (channel)))>,
2)	    newenb (channel) =
2)	        <(bit(26) + (channel))>;
2)	  require unstack!delimiters;
2)	endc
2)	! ------------------------------------------------------------------------;
**************

Files are different


!dif (peakx)HOST.DEF,(peak)


No differences encountered


!dif (peakx)COMM1.REQ,(peak)


No differences encountered


!dif (peakx)COMM2.REQ,(peak)


No differences encountered


!dif (peakx)COMM3.REQ,(peak)


No differences encountered


!dif (peakx)COMM4.REQ,(peak)


No differences encountered


!dif (peakx)COMM5.REQ,(peak)


No differences encountered


!dif (peakx)COMM6.REQ,(peak)


No differences encountered


!dif (peakx)COMM7.REQ,(peak)


No differences encountered


!dif (peakx)COMM8.REQ,(peak)


No differences encountered


!dif (peakx)COMSUB.REQ,(peak)


No differences encountered


!dif (peakx)XXBUF1.REQ,(peak)


No differences encountered


!dif (peakx)XXBUF2.REQ,(peak)


No differences encountered


!dif (peakx)AUXWIN.SAI,(peak)

1)1	!                         From the Command Module
****
2)1	!
2)	!                        Interrupt Administration
2)	!
2)	!       o  The interrupt is used to move keyboard data out to the
2)	!          circuit.  
2)	!       o  For efficiency, an immediate interrupt is used:
2)	!
2)	!                               - BEWARE -
2)	!                          no SAIL data structures
2)	!                      may be touched by this routine!
2)	!
2)	! -------------------------------------------------------------------------
2)	!                         From the Command Module
**************
1)1	!                        Miscellaneous Definitions
1)	;
1)	  define
1)	    !axi8c        = '0                  ! Input Image Character (wait for
1)	                                        ! character).
1)	                                        ;,
1)	    !axi8s        = '1                  ! Input Image Character (skip if
1)	                                        ! character was returned).
1)	                                        ;,
1)	    !axsi         = '33                 ! Simulate input on port.
1)	                                        ;,
1)	    !axsic        = '10                 ! Skip if character in input
1)	                                        ! buffer.
1)	                                        ;,
1)	    !axo8         = '3                  ! Output Image Character.
1)	                                        ;,
1)	    !axo8i        = '4                  ! Output image character immediate.
1)	                                        ;,
1)	    !axlde        = '11                 ! Leave Deferred Echo Mode.
1)	                                        ;,
1)	    !iachr        = '1                  ! Receipt of a Character (cause
1)	                                        ! for an interrupt).
1)	                                        ;,
1)	    !gtunm        = -'22                ! Username(1)
1)	                                        ;,
1)	    !gtun1        = -'21                ! Username(2)
1)	                                        ;,
1)	    !cnsys        = '33                 ! System Number Gettab Item
1)	                                        ! designator.
1)	                                        ;,
1)	    !gtcnf        = '11                 ! System Configuration Data Gettab
1)	                                        ! table number.
1)	                                        ;,
1)	    calli!AuxRed  = -'46                ! Read AuxCircuit count function
1)	                                        ! code.
1)	                                        ;,
1)	    calli!CreAux  = -'44                ! CreAux function code.
1)	                                        ;,
1)	    calli!GetTab  = '41                 ! Gettab function code.
1)	                                        ;,
1)	    calli!Hiber   = '72                 ! Hiber function code.
1)	                                        ;,
1)	    calli!Wake    = '73                 ! Wake function code.
1)	                                        ;,
1)	    calli!ZapCir  = -'45                ! Zap the aux circuit function
1)	                                        ! code.
1)	                                        ;;
1)	      ! Miscellaneous monitor symbols from uuosym.def.
1)	      ;
1)	  define
1)	    cxsup# = '0,
1)	    cx2ax# = '1,
1)	    cxlog# = '2,
1)	    cxdcb# = '3,
1)	    cxnrr# = '4,
1)	    cxnrl# = '5,
1)	    cxnch# = '6,
1)	    cxerr# = '7,
1)	    cxsfe# = '1,
1)	    cxsbu# = '2,
1)	    cxsbm# = '3,
1)	    cxshu# = '4,
1)	    cxsdf# = '5,
1)	    cxsto# = '6,
1)	    cxsab# = '7,
1)	    cxsis# = '10,
1)	    cxslq# = '11;
1)	      ! CreAux error condition symbols.
1)	      ;
1)	! ------------------------------------------------------------------------;
1)2	!! title Interrupt Administration ;
1)	! -------------------------------------------------------------------------
1)	!
1)	!                        Interrupt Administration
1)	!
1)	!       o  The interrupt is used to move keyboard data out to the
1)	!          circuit.  
1)	!       o  For efficiency, an immediate interrupt is used:
1)	!
1)	!                               - BEWARE -
1)	!                          no SAIL data structures
1)	!                      may be touched by this routine!
1)	!
1)	!       o  Channel 10 is used because SAIL uses some of the lower ones.
1)	!
1)	! -------------------------------------------------------------------------
1)	!
1)	!                   Interrupt Administration functions
1)	;
1)	! Note: newenb below means "use the new (=NEWENB) as opposed to old
1)	! (=APRENB) interrupt system for TymcomX".
1)	;
1)	  require "<><>" delimiters;
1)	  define
1)	    intass (cause, channel) =
1)	        <xwd((cause), (bit(20) + (channel)))>,
1)	    tinass (port, cause, channel) =
1)	        <xwd((port), (bit(5, 20) + (cause lsh 9) + (channel)))>,
1)	    intdev (device, cause, channel) =
1)	        <xwd((device), (bit(7, 20) + (cause lsh 9) + (channel)))>,
1)	    newenb (channel) =
1)	        <(bit(26) + (channel))>;
1)	  require unstack!delimiters;
1)	! ------------------------------------------------------------------------;
1)3	!! title Rtn AuxIni ;
****
2)2	!! title Rtn AuxIni ;
**************
1)5	  intmap(tinass(-1, !iachr, 10), TTYSvc, 0);
1)	  enable(newenb(10));
1)	  auxclv(-1, 0, !axlde);                ! echo yellow balls;
****
2)4	  intmap(tinass(-1, !iachr, AuxWinChn), TTYSvc, 0);
2)	  enable(newenb(AuxWinChn));
2)	  auxclv(-1, 0, !axlde);                ! echo yellow balls;
**************
1)6	  disable(newenb(10));
1)	end "Disable!TTY";
1)7	!! title Rtn CreAux ;
1)	!
1)	!                     Auxilary Circuit Administration
1)	!
1)	!       o  Build a circuit to the specified user name/host.
1)	!       o  The following defaults are handled by this procedure:
1)	!              <null>           defaults to LIUN:CSYS
****
2)5	  disable(newenb(AuxWinChn));
2)	end "Disable!TTY";
2)6	!! title Rtn MakeLoginString ;
2)	! Create a fully specified user login string from a fragment thereof
2)	!
2)	!       o  The following defaults are handled by this procedure:
2)	!
2)	!              <null>           defaults to LIUN:CSYS
**************
1)7	!              LIUN = logged in user name
****
2)6	!
2)	!              LIUN = logged in user name
**************
1)7	!       o  returns port number if succesful, else -1, !skip! is also set
1)	;
1)	internal integer procedure A!CreAux (reference string LoginString);
1)	begin "CreAux"
1)	  integer
1)	    I,
1)	    Port;
1)	  integer array
1)	    X[0:5];
1)	  string
1)	    S,
1)	    ErrMsg;
1)	! Convert to Upper Case
1)	;
1)	    S           _ LoginString;
1)	    LoginString _ null;
1)	    while (length(S)) do 
****
2)6	;
2)	simple string procedure MakeLoginString (string LoginString);
2)	begin "MakeLoginString"
2)	  integer
2)	    I;
2)	  string
2)	    S;
2)	    S           _ LoginString;
2)	    LoginString _ null;
2)	      ! Keep a copy of the original around.
2)	      ;
2)	    while (length(S)) do 
**************
1)7	 
****
2)6	      ! Convert to upper case.
2)	      ;
2)	 
**************
1)7	! Keep the User Informed
1)	;
1)	    W!Msg("Login: " & LoginString & " [Working]");
1)	    W!Disp(true);
1)	! Pack the String into an Array and Call the Monitor to Build the Circuit
****
2)6	    return(LoginString);
2)	end "MakeLoginString";
2)7	!! title Rtn CreAux ;
2)	! Build a circuit to the specified user name/host.
2)	! Returns the port number if succesful, returns -1 otherwise.
2)	! !skip! is also set.
2)	;
2)	internal integer procedure A!CreAux (reference string LoginString);
2)	begin "CreAux"
2)	  integer
2)	    I,
2)	    Port;
2)	  integer array
2)	    X[0:5];
2)	  string
2)	    ErrMsg;
2)	    LoginString _ MakeLoginString(LoginString);
2)	      ! Fill in all defaults in the login string.
2)	      ;
2)	    W!Msg("Login: " & LoginString & " [Working]");
2)	    W!Disp(true);
2)	      ! Keep the User Informed.
2)	      ;
2)	! Pack the String into an Array and Call the Monitor to Build the Circuit
**************

Files are different


!dif (peakx)COMAND.SAI,(peak)

1)1	  endc
****
2)1	    external simple boolean procedure
2)	      B!ChkPntModP;                     ! True if buffer has been modified
2)	                                        ! since the last Checkpoint was
2)	                                        ! performed.
2)	                                        ;
2)	  endc
**************
1)2	!                           Miscellaneous Stuff
****
2)2	!
2)	!                    Checkpoint Timer Interrupt Stuff
2)	;
2)	  internal boolean
2)	    C!TimIntFlg;                        ! True once the Timer Interrupt has
2)	                                        ! taken place.  (This is set by
2)	                                        ! the routine ChkPntSvc.)
2)	                                        ;
2)	! - - - - - - - - - - - - - - - - - - - - - -  - - - - - - - - - - - ;
2)	!                           Miscellaneous Stuff
**************
1)5	!  see the comments in C!Init.  Dispatch is defined here because numerous
1)	!  routines below call it. ;
****
2)5	!  see the comments in C!In1.  Dispatch is defined here because numerous
2)	!  routines below call it. ;
**************
1)6	!! title Rtn C!WaitAndPossiblyCheckpoint ;
1)	! Routine called from T!GetC when a redisplay has been done and there
1)	! still isn't a character from the keyboard.  If a checkpoint interval
1)	! has been given wait that long, then checkpoint the buffer is nothing
1)	! has been done at the keyboard. ;
1)	simple procedure C!WaitAndPossiblyCheckpoint;
1)	begin "timer"
1)	  ifcr TymcomX thenc
1)	    own integer Flag;
1)	    if (not C!CheckPointInterval) then
1)	      return;
1)	    start!code
1)	      setzm     Flag;           ! assume character hit ;
1)	      hrli      1, '11;         ! wait for char, wait in seconds ;
1)	      hrr       1, C!CheckPointInterval;
1)	      calli     1, '72;         ! hiber 1, ;
1)	       jfcl;
1)	      hrroi     1, '10;         ! .axsic - skip if character ;
1)	      auxcal    1,;
1)	        setom   Flag;           ! no character hit ;
1)	    end;
1)	    if (Flag) then
1)	    begin
1)	      W!Msg2("[CheckPoint]");
1)	      B!CheckPoint;
1)	      W!Disp(false);
1)	    end;
1)	  endc
1)	  ifcr Tops20 thenc
1)	    return;
1)	  endc
1)	end "timer" ;
1)7	!! title Rtn C!ChrP ;
****
2)6	!! title Rtn ChkPntSvc ;
2)	! This routine is activated by the Timer interrupt.  It is a SAIL IMMEDIATE
2)	! INTERRUPT routine, and therefore must be simple, and must reference no
2)	! dynamic SAIL data structures.
2)	!
2)	! Marvel at how UGLY this mechanism is!  It is constructed thus to be able
2)	! to checkpoint even when we are sitting in an input wait (see T!GetC).
2)	;
2)	ifcr TymComX thenc
2)	  simple procedure ChkPntSvc;
2)	  begin "ChkPntSvc"
2)	    begin!code
2)	      define
2)	        JOBTPC = '127;                  ! The location of the value of the
2)	                                        ! PC before the interrupt was
2)	                                        ! taken.  
2)	                                        ;
2)	      label
2)	        STRT,
2)	        TST;
2)	        jrst    STRT;
2)	      TST:
2)	        skipe   C!TimIntFlg;
2)	      STRT:
2)	        move    1, JOBTPC;              ! Were we at a hand-made ;
2)	        move    2, -3(1);               ! polling point? ;
2)	        camn    2, TST;                 ! (See T!GetC) ;
2)	        subi    1, 3;                   ! Yes - Adjust the PC to handle the
2)	                                        ! interrupt and proceed. ;
2)	        movem   1, JOBTPC;              ! Reset the Old PC. ;
2)	        setom   C!TimIntFlg;            ! Flag the interrupt. ;
2)	    end;
2)	  end "ChkPntSvc";
2)	endc
2)7	!! title Rtn DoChkPnt;
2)	! Perform the Checkpoint operation.
2)	;
2)	ifcr TymcomX thenc
2)	  internal procedure C!DoChkPnt;
2)	  begin "C!DoChkPnt"
2)	    if (B!ChkPntModP) then
2)	    begin
2)	      ! If there has been a change in the buffer since the last Checkpoint
2)	      ! was done.
2)	      ;
2)	      W!Msg2("[Checkpoint]");
2)	      B!Checkpoint;
2)	      W!Disp(false);
2)	        ! Do the Checkpoint, and update the screen.  The Checkpoint routine
2)	        ! will restart the timer.
2)	        ;
2)	    end
2)	    else
2)	      calli(C!CheckpointInterval * 1000, calli!timer);
2)	        ! Restart the timer for the next checkpoint.
2)	        ;
2)	    clear(C!TimIntFlg);
2)	      ! Indicate that we are waiting for a timer interrupt.
2)	      ;
2)	  end "C!DoChkPnt";
2)	endc
2)8	!! title Rtn C!ChrP ;
**************
1)8	        ! These tests should be seperate, since they are sensitive to
1)	          time elapsing ;
1)	        if ( not C!ChrP ) then W!Disp( true );
1)	        if ( not C!ChrP ) then C!WaitAndPossiblyCheckpoint;
1)	        C := T!GetC;
****
2)9	        ! These tests should be seperate, since they are sensitive to time
2)	        ! elapsing 
2)	        ;
2)	        ifcr Tops20 thenc
2)	          ! <<  This may be desirable in the Tops-20 implementation. (???)
2)	          ;
2)	          if (not C!Chrp) then
2)	            WaitandPossiblyCheckpoint;
2)	        endc
2)	        if (not C!ChrP) then
2)	          W!Disp( true );
2)	        C := T!GetC;
**************
1)19	! title Rtn C!Init ;
1)	! C!Init - Set up the key bindings, and symbolic stuff.
1)	;
1)	internal procedure C!Init;
1)	  begin "initialization"
1)	ifcr TymcomX thenc
1)	    C!UserName := cv6str( call( xwd(-1, -'22), "gettab" )) &
1)	                  cv6str( call( xwd(-1, -'21), "gettab" ));
1)	endc
1)	ifcr Tops20 thenc
1)	    integer J, L, C, T;
1)	    J := gjinf( L,C,T );
1)	    C!UserName := dirst( L );
1)	    clear(G!ShowGens);
1)	endc
1)	    C!MetaPrefix := ESC;        ! standard meta prefix ;
****
2)20	! title Rtn C!In1 ;
2)	! C!In1 - Set up the key bindings, and symbolic stuff.
2)	;
2)	internal procedure C!In1;
2)	  begin "initialization"
2)	    C!MetaPrefix := ESC;        ! standard meta prefix ;
**************
1)19	    C!CreEscChr _ '30;                  ! The default CreAux escape
1)	                                        ! character is ^X.
1)	                                        ;
1)	    C!AuxStr    _ null;                 ! The default login string is
1)	                                        ! empty.
1)	                                        ;
1)	    C!AuxPort   _ -1;                   ! The default auxiliary port is
1)	                                        ! undefined.
1)	                                        ;
1)20	!! title Bind ASCII Commands ;
****
2)20	    ifcr TymcomX thenc
2)	      C!CreEscChr  _ '30;               ! The default CreAux escape
2)	                                        ! character is ^X.
2)	                                        ;
2)	      C!AuxStr     _ null;              ! The default login string is
2)	                                        ! empty.
2)	                                        ;
2)	      C!AuxPort    _ -1;                ! The default auxiliary port is
2)	                                        ! undefined.
2)	                                        ;
2)	    endc
2)21	!! title Bind ASCII Commands ;
**************
1)23	!! title Expand Command Tables ;
****
2)24	!! title Rtn C!In2 ;
2)	! Perform instantiation dependent initialization of the Command Module.
2)	;
2)	internal simple procedure C!In2;
2)	begin "C!In2"
2)	ifcr TymcomX thenc
2)	  C!UserName _
2)	      cv6str(call(xwd(-1, -'22), "gettab")) &
2)	      cv6str(call(xwd(-1, -'21), "gettab"));
2)	    ! Get the current user's name.
2)	    ;
2)	  intmap(intass(!iatim, ChkPntChn), ChkPntSvc, 0);
2)	  enable(newenb(ChkPntChn));
2)	  clear(C!TimIntFlg);
2)	    ! Establish the Timer immediate interrupt.
2)	    ;
2)	endc
2)	ifcr Tops20 thenc
2)	  integer
2)	    J,
2)	    L,
2)	    C,
2)	    T;
2)	    J _ gjinf(L, C, T);
2)	    C!UserName _ dirst(L);
2)	    clear(G!ShowGens);
2)	endc
2)	end "C!In2";
2)25	!! title Expand Command Tables ;
**************
1)31	    Cmd _ C!GetCMD;
****
2)33	    if (C!TimIntFlg) then
2)	      C!DoChkPnt;
2)	      ! If the timer has gone off, do a Checkpoint.
2)	      ;
2)	    Cmd _ C!GetCMD;
**************
1)31	    if (C!Quit) then
****
2)33	      ! Perform the command.
2)	      ;
2)	    if (C!Quit) then
**************

Files are different


!dif (peakx)DED.SAI,(peak)

1)1	*                 Dave W. Smith,  September-October, '81                  *
1)	*                 Ken Dawson:  Version 1.0  (6..82 - ??)                  *
1)	*                                                                         *
****
2)1	*                                                                         *
2)	*                                 or PEAK                                 *
2)	*            (As it came to be known when it hit the streets)             *
2)	*                                                                         *
2)	*                 Dave W. Smith:                [9..81 - 10..81]          *
2)	*                 Ken Dawson:  Version 1.0(???) [1.12.83]                 *
2)	*                 Ken Dawson:  Version 2.0(301) [4.25.84]                 *
2)	*                                                                         *
**************
1)1	  external procedure
****
2)1	  ifcr WarpLoad thenc
2)	    external simple procedure
2)	      Warp (string Filename);           ! Wrap up the current core image
2)	                                        ! into a nice bundle to be executed
2)	                                        ! using the warp drive mechanism
2)	                                        ! later.
2)	                                        ;
2)	  endc
2)	  external procedure
**************
1)1	    C!Init;                             ! Initialize the Command module.
1)	                                        ;
****
2)1	    C!In1;                              ! Do instantiation independent
2)	                                        ! initialization of the Command
2)	                                        ! module.  
2)	                                        ;
2)	  external procedure
2)	    C!In2;                              ! Do instantiation dependent
2)	                                        ! initialization of the Command
2)	                                        ! module.  
2)	                                        ;
2)	  external procedure
2)	    B!In2;                              ! Do instantiation dependent
2)	                                        ! initialization of the Buffer
2)	                                        ! module.  
2)	                                        ;
**************
1)1	! ************************************************************************;
1)2	!! title Rtn InitializeEverything ;
1)	! Perform all module initializations for the manifold components of Peak.
1)	! Also initialize global variables which don't necessarily belong to any
1)	! particular module.
1)	;
****
2)1	  external integer
2)	    C!CheckpointInterval;               ! The number of seconds between
2)	                                        ! checkpoints.
2)	                                        ;
2)	! ************************************************************************;
2)2	!! title Rtn InitializeEverything ;
2)	! Perform all instantiation dependent module initializations for the
2)	! manifold components of Peak.  Also initialize global variables which
2)	! don't necessarily belong to any particular module.
2)	;
**************
1)2	  C!Init;
1)	  T!Init;
****
2)2	  C!In2;
2)	  B!In2;
2)	  T!Init;
**************
1)2	end "InitializeEverything";
1)3	!! title Rtn Mainline Code ;
1)	! Note that by the time we get here, the following routines have been
1)	! initialized via the Sail "require ... initialization" mechanism:
1)	!
1)	!     InitSymCmdAddr                    in the Command Module
1)	!     InitVarLocs                       in the Command Module
1)	!     B!Init                            in the Buffer  Module
1)	;
****
2)2	  calli(C!CheckpointInterval * 1000, calli!timer);
2)	    ! Setup the first checkpoint timer interrupt.
2)	    ;
2)	end "InitializeEverything";
2)3	!! title Rtn Mainline Code ;
2)	! Note that by the time we get here, the following routines (which do
2)	! instantiation independent initialization) have been called via the Sail
2)	! "require ...  initialization" mechanism:
2)	;
2)	!
2)	!     AuxInit                           in the AuxWin  Module
2)	!     B!In1                             in the Buffer  Module
2)	!     InitSymCmdAddr                    in the Command Module
2)	!     InitVarLocs                       in the Command Module
2)	;
**************
1)3	  F!Rpg;
****
2)3	  C!In1;
2)	      ! Instantiation independent init of the Command Module.
2)	      ;
2)	                                          
2)	  W!Init;
2)	      ! Instantiation independent init of the Window Module.
2)	      ;
2)	  ifcr (WarpLoad) thenc
2)	    ! If we are compiling with the fast-load option.
2)	    ;
2)	    Warp("Peak.Wrp");
2)	      ! Create the Warp File of this core image.
2)	      ;
2)	  endc
2)	  F!Rpg;
**************

Files are different


!dif (peakx)REDISP.SAI,(peak)

1)1	external boolean
1)	  C!Debug;
1)	external procedure
1)	  W!BAdd (string S);
1)2	!! title Internal Storage ;
****
2)1	!                         From the Command Module
2)	;
2)	external boolean
2)	  C!TimIntFlg,                          ! The timer interrupt has taken
2)	                                        ! place.
2)	                                        ;
2)	  C!Debug;
2)	external procedure
2)	  C!DoChkPnt;                           ! Perform a Checkpoint.
2)	                                        ;
2)	!                         From the Window Module
2)	;
2)	external procedure
2)	  W!BAdd (string S);
2)	! ************************************************************************;
2)2	!! title Internal Storage ;
**************
1)2	  T!IntP;                              ! Flag indicating that the Terminal
1)	                                        ! has been initialized.
****
2)2	  T!IntP;                               ! Flag indicating that the Terminal
2)	                                        ! has been initialized.
**************
1)13		hrroi	1, 0;		! -1,,0 (.axi8c) ;
****
2)13	        skipe   C!TimIntFlg;    ! If an interrupt has take place ;
2)	        pushj   '17, C!DoChkPnt;        ! Go take care of it ;
2)		hrroi	1, 0;		! -1,,0 (.axi8c) ;
**************

Files are different


!dif (peakx)UTIL.SAI,(peak)

1)1	  external simple procedure
****
2)1	!                      From the SAIL Runtime System
2)	;
2)	  external integer
2)	    !skip!;                             ! Indicate a skip on UUO execution.
2)	!                         From the Window Module
2)	;
2)	  external simple procedure
**************
1)8	ifcr Tops20 thenc
****
2)8	! <<  This doesn't appear to work!
2)	;
2)	ifcr Tops20 thenc
**************
1)10	end "Peak Utility Module";
1)	! **************************  End of Util.Sai  ************************** ;
****
2)11	!! title Rtn Warp ;
2)	! Call Warp to create a file that may be loaded and executed by
2)	! WARPLD.  Should be called immediately following initialization.
2)	! Restrictions:  no files or interrupts may be open, no instantiation
2)	! dependent code should precede the call to Warp.  Also, no shared or
2)	! non-private pages may exist in the low segment.  Only one file may
2)	! be mapped in the high segment.
2)	;
2)	ifcr WarpLoad thenc
2)	  internal simple procedure Warp (string Filename);
2)	  begin "Warp"
2)	    own integer
2)	      VP,
2)	      E,
2)	      AC12,
2)	      AC16,
2)	      AC17;
2)	    own safe integer array
2)	      X[0:1],
2)	      Seg[0:7];
2)	    own string
2)	      SegName,
2)	      SegERR;
2)	    label
2)	      RESTART;
2)	    quick!code
2)	      movem       '12, AC12;
2)	      movem       '16, AC16;
2)	      movem       '17, AC17;
2)	      hrri        1, RESTART;
2)	      hrli        1, '44;
2)	      add         1, ['1000000];
2)	      movem       1, '120;
2)	    end;
2)	    calli(xwd(-8, location(Seg[0] _ '400)), -'103);
2)	    if (Seg[0] _ !skip!) then
2)	    begin
2)	      SegName _ cv6str(Seg[3]) &  xwdstr(Seg[6]);
2)	      SegERR  _ "?Warp: GETSEG failure for " &  SegName &  0;
2)	      print("Warp: high segment from ", SegName, crlf);
2)	    end;
2)	    open(0, "DSK", '14, 0, 4, 0, 0, E);
2)	    enter(0, Filename, E);
2)	    X[1] _ -1;
2)	    if (E) then
2)	      usererr(E, 2, "?Warp: unable to enter file " & Filename & ": ", "X");
2)	    for VP_ 0 upto '777 do
2)	    begin
2)	      E _ chnior(0, X[0] _ xwd(1, VP), '47);
2)	      if (!skip!) then
2)	        calli(2*bit(7)+bit(17)+X[0], -'70)
2)	      else
2)	        done;
2)	    end;
2)	    release(0);
2)	    print("Warp: ", VP, " pages written to ", Filename, crlf);
2)	    return;
2)	    RESTART:
2)	    quick!code
2)	      external integer
2)	        RPGSW,
2)	        INIACS;
2)	      label
2)	        NOSEG;
2)	        jump      RPGSW;
2)	        jump      INIACS;
2)	        move      '12, AC12;
2)	        move      '16, AC16;
2)	        move      '17, AC17;
2)	        skipn     Seg[0];
2)	         jrst     NOSEG;
2)	        movei     1, Seg[2];
2)	        calli     1, '40;               ! GETSEG;
2)	          ttcall  '17, SegERR;          ! OUTPTR;
2)	      NOSEG:
2)	    end;
2)	  end "Warp";
2)	endc
2)	end "Peak Utility Module";
2)	! **************************  End of Util.Sai  ************************** ;
**************

Files are different


!dif (peakx)WINDOW.SAI,(peak)


No differences encountered


!dif (peakx)XBUFF.SAI,(peak)

1)1	  external simple integer procedure
****
2)1	  external integer
2)	    C!CheckpointInterval;               ! The number of seconds between
2)	                                        ! Checkpoints.
2)	                                        ;
2)	  external simple integer procedure
**************
1)2	  own integer B!Addr;		! address of buffer space ;
1)	  own integer B!Pages;		! number of pages mapped ;
1)	  own boolean B!NullFlag;	! true if Nulls in buffer ;
1)	! Storage for buffer descriptors ;
****
2)2	  own integer
2)	    B!Addr,                             ! address of buffer space
2)	                                        ;
2)	    B!Pages;            		! number of pages mapped
2)	                                        ;
2)	  own boolean
2)	    B!NullFlag,                 	! true if Nulls in buffer
2)	                                        ;
2)	    ChkPntModified;                     ! True if Buffer has been modified
2)	                                        ! since the last Checkpoint was
2)	                                        ! done.
2)	                                        ;
2)	! Storage for buffer descriptors ;
**************
1)2	  own safe integer array B!BPLeft [0:4];
1)	! ************************************************************************;
****
2)2	  own safe integer array
2)	    B!BPLeft [0:4];
2)	! ************************************************************************;
**************
1)7	!! title Rtn B!Init ;
1)	! Initialize the buffer system by grounding the active list pointer and
1)	!  linking all buffers into the free list. ;
1)	internal simple procedure B!Init;
1)	begin "init"
1)	  own integer
1)	    I;
1)	  B!DedVer   _ DED!Version!Word;	! The current version of PEAK ;
****
2)7	!! title Rtn B!In1 ;
2)	! Initialize the buffer system by grounding the active list pointer and
2)	! linking all buffers into the free list.
2)	;
2)	internal simple procedure B!In1;
2)	begin "B!Init"
2)	  own integer
2)	    I;
2)	  set(ChkPntModified);
2)	    ! We make sure that our first Checkpoint file gets written when the
2)	    ! time comes by indicating that the buffer has changed since the last
2)	    ! time the Checkpoint file was written out.
2)	    ;
2)	  B!DedVer   _ DED!Version!Word;	! The current version of PEAK ;
**************
1)7	  B!Chan _ B!GtChan;		! Establish the buffer I/O channel ;
1)	end "init";
1)	require B!Init initialization;
1)8	!! title Rtn DeleteBuffer ;
****
2)7	end "B!Init";
2)	require B!In1 initialization;
2)8	!! title Rtn B!In2 ;
2)	! Perform instantiation dependent Buffer Module initialization.
2)	;
2)	internal simple procedure B!In2;
2)	begin "B!In2"
2)	  B!Chan _ B!GtChan;                    ! Establish the buffer I/O channel.
2)	                                        ; 
2)	end "B!In2";
2)9	!! title Rtn DeleteBuffer ;
**************
1)15	! Flush information that we keep in static locations back
1)	!  into the buffer descriptor block.  Also flush the in-core image
1)	!  to a "checkpoint file" on disk. ;
1)	internal simple procedure B!Checkpoint;
****
2)16	! Flush information that we keep in static locations back into the buffer
2)	! descriptor block.  Also flush the in-core image to a "checkpoint file" on
2)	! disk.
2)	;
2)	internal simple procedure B!Checkpoint;
**************
1)15	end;
****
2)16	  clear(ChkPntModified);
2)	  calli(C!CheckpointInterval * 1000, calli!timer);
2)	    ! Indicate that the buffer has not changed since the last Checkpoint
2)	    ! file was written out, and setup the next timer interrupt.
2)	    ;
2)	end;
**************
1)16	end "restore";
****
2)17	  clear(ChkPntModified);
2)	  calli(C!CheckpointInterval * 1000, calli!timer);
2)	    ! Indicate that the buffer has not changed since the last Checkpoint
2)	    ! file was written out, and setup the next timer interrupt.
2)	    ;
2)	end "restore";
**************
1)44	    if ( not B!ModP ) then
****
2)45	    set(ChkPntModified);
2)	      ! The buffer has now changed since the last Checkpoint file got
2)	      ! written out.
2)	      ;
2)	    if ( not B!ModP ) then
**************
1)45	    if ( Not B!ModP ) then
****
2)46	    set(ChkPntModified);
2)	      ! The buffer has now changed since the last Checkpoint file got
2)	      ! written out.
2)	      ;
2)	    if ( Not B!ModP ) then
**************
1)56	end "DED - buffer manager"
1)	! ***************************  End Xbuff.Sai  ****************************;
****
2)58	!! title Rtn B!ChkPntModP ;
2)	! Indicate to the curious whether the buffer has been modified since the
2)	! last time the Checkpoint file was written out.
2)	;
2)	internal simple boolean procedure B!ChkPntModP;
2)	begin "B!ChkPntModP"
2)	  return(ChkPntModified);
2)	end "B!ChkPntModP";
2)	end "DED - buffer manager"
2)	! ***************************  End Xbuff.Sai  ****************************;
**************

Files are different


!dif (peakx)XFILE.SAI,(peak)


No differences encountered


!dif (peakx)XXBUFF.SAI,(peak)


No differences encountered


!dif (peakx)XXFILE.SAI,(peak)


No differences encountered


!;---------------------------------------------------------------------
!dir (peakx)*.def,*.req,*.sai

DED     DEF      12  25-APR-84 1404.32 ALL RD  NO      5295           (KEN)
HOST    DEF       2   5-DEC-83 1627.07 ALL RD  NO       156           (KEN)
COMM1   REQ      12  30-APR-84  929.44 ALL RD  NO      5168           (KEN)
COMM2   REQ      20  13-APR-84 1504.50 ALL RD  NO      9438           (KEN)
COMM3   REQ      10  24-JAN-84 1459.55 ALL RD  NO      4344           (KEN)
COMM4   REQ       6   5-DEC-83 1426.10 ALL RD  NO      2348           (KEN)
COMM5   REQ       2  29-MAR-84 1435.27 ALL RD  NO       299           (KEN)
COMM6   REQ       2   9-APR-83 1531.00 ALL RD  NO       365           (KEN)
COMM7   REQ       3  14-MAR-84 1442.21 ALL RD  NO       851           (KEN)
COMM8   REQ       2  19-APR-84 1620.37 ALL RD  NO       445           (KEN)
COMSUB  REQ      12  26-MAR-84 1307.20 ALL RD  NO      5512           (KEN)
XXBUF1  REQ      28  13-APR-84 1446.52 ALL RD  NO     13653           (KEN)
XXBUF2  REQ      11   3-APR-84 1615.46 ALL RD  NO      4635           (KEN)
AUXWIN  SAI      10  25-APR-84 1444.49 ALL RD  NO      4100           (KEN)
COMAND  SAI      28  25-APR-84 1200.41 ALL RD  NO     13449           (KEN)
DED     SAI       3   2-MAY-84 1140.38 ALL RD  NO       964           (KEN)
REDISP  SAI      16   6-APR-84 1159.25 ALL RD  NO      7579           (KEN)
UTIL    SAI       4  16-FEB-84 1405.33 ALL RD  NO      1417           (KEN)
WINDOW  SAI      11   3-APR-84 1526.56 ALL RD  NO      5100           (KEN)
XBUFF   SAI      19  13-APR-84 1446.56 ALL RD  NO      9167           (KEN)
XFILE   SAI      13   5-APR-84 1008.31 ALL RD  NO      6137           (KEN)
XXBUFF  SAI      13   2-MAY-84  732.28 ALL RD  NO      5830           (KEN)
XXFILE  SAI      11   2-APR-84 1531.53 ALL RD  NO      4773           (KEN)

!dir (peak)*.def,*.req,*.sai

DED     DEF      14  18-JUL-84  931.18 ALL RD  NO      6596           (KEN)
HOST    DEF       2   5-DEC-83 1627.07 ALL RD  NO       156           (KEN)
COMM1   REQ      12  30-APR-84  929.44 ALL RD  NO      5168           (KEN)
COMM2   REQ      20  13-APR-84 1504.50 ALL RD  NO      9438           (KEN)
COMM3   REQ      10  24-JAN-84 1459.55 ALL RD  NO      4344           (KEN)
COMM4   REQ       6   5-DEC-83 1426.10 ALL RD  NO      2348           (KEN)
COMM5   REQ       2  29-MAR-84 1435.27 ALL RD  NO       299           (KEN)
COMM6   REQ       2   9-APR-83 1531.00 ALL RD  NO       365           (KEN)
COMM7   REQ       3  14-MAR-84 1442.21 ALL RD  NO       851           (KEN)
COMM8   REQ       2  19-APR-84 1620.37 ALL RD  NO       445           (KEN)
COMSUB  REQ      12  26-MAR-84 1307.20 ALL RD  NO      5512           (KEN)
XXBUF1  REQ      28  13-APR-84 1446.52 ALL RD  NO     13653           (KEN)
XXBUF2  REQ      11   3-APR-84 1615.46 ALL RD  NO      4635           (KEN)
AUXWIN  SAI       8   5-JUL-84 1346.40 ALL RD  NO      3401           (KEN)
COMAND  SAI      29  18-JUL-84  931.21 ALL RD  NO     13945           (KEN)
DED     SAI       4  18-JUL-84   35.54 ALL RD  NO      1419           (KEN)
REDISP  SAI      17  17-JUL-84 1457.41 ALL RD  NO      7703           (KEN)
UTIL    SAI       5  28-JUN-84  936.35 ALL RD  NO      1906           (KEN)
WINDOW  SAI      11   3-APR-84 1526.56 ALL RD  NO      5100           (KEN)
XBUFF   SAI      20  18-JUL-84  109.08 ALL RD  NO      9580           (KEN)
XFILE   SAI      13   5-APR-84 1008.31 ALL RD  NO      6137           (KEN)
XXBUFF  SAI      13   2-MAY-84  732.28 ALL RD  NO      5830           (KEN)
XXFILE  SAI      11   2-APR-84 1531.53 ALL RD  NO      4773           (KEN)

!;---------------------------------------------------------------------
!SEND KEN
TYPE LETTER:
; PCOM v1.63 - processed: (PEAK)DIFOLD.LOG = (PEAK)DIFOLD.CTL
; Options: DETACH  LOG NOAPPEND SUPERSEDE LICENSE 
; Limits: TIME:60 TRULIMIT:0 
; Status: completed.
; Output recorded in file (PEAK)DIFOLD.LOG.

mail waiting
!LOGOUT
82.57 tru
terminal time: 0:10:37
    &@n%