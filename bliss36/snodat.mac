	SUBTTL	GIMPEL--MA355/JDS/DRH/MP/RCM/VB		16-JULY-76

;COPYRIGHT (c) 1972,1973,1976,1977 STEVENS INSTITUTE OF TECHNOLOGY
;HOBOKEN, NEW JERSEY, 07030.
;ALL RIGHTS RESERVED.

  ;UNIVERSALS

	SEARCH	JOBDAT		;JOB DATA AREA DEFINITIONS
	SEARCH	MACTEN		;DEC-10 MACROS
	SEARCH	UUOSYM		;TOPS-10 UUO SYMBOL DEFINITIONS
	SEARCH	SNOPRM		;SITBOL PARAMETER FILE

  ;DIRECTIVES

	.DIREC	.OKOVL		;Don't care about overflows
	.DIREC	FLBLST		;LOSE SOME UNNEEDED LISTING
	.DIREC	.XTABM		;EXCLUDE TABS FROM MACRO CALLS
	SALL			;SUPPRESS MACRO EXPANSIONS
	TWOSEG	400K		;TWO SEGMENT CODE

 ;VERSION NUMBER

	DATVER==5		;MAJOR VERSION
	DATMIN==0		;MINOR VERSION
	DATEDT==266		;EDIT LEVEL
	DATWHO==0		;CUSTOMER ARG

  ;TITLE

	TITLE.	DAT,SNODAT,<Pure and Impure Data>

	DATTTL				; Title
	DATPTX				; PASS2 message
	SUBTTL	Table of Contents

;		Table of Contents for Pure and Impure Data
;
;
;			   Section			      Page
;   1. Table of Contents. . . . . . . . . . . . . . . . . . .    2
;   2. REVISION HISTORY . . . . . . . . . . . . . . . . . . .    3
;   3. PURE DATA
;        3.1.   COMMON CODE . . . . . . . . . . . . . . . . .    4
;        3.2.   &ALPHABET AND 1 CHAR. STRINGS . . . . . . . .    5
;        3.3.   COMMON STRINGS. . . . . . . . . . . . . . . .    6
;        3.4.   SYSTEM CHARACTER TABLE. . . . . . . . . . . .    7
;        3.5.   MISC. PURE DATA . . . . . . . . . . . . . . .    8
;   4. IMPURE DATA
;        4.1.   MACROS. . . . . . . . . . . . . . . . . . . .    9
;        4.2.   misc. from all modules. . . . . . . . . . . .   10
;        4.3.   IMPURE KEYWORDS . . . . . . . . . . . . . . .   13
;        4.4.   NONFLOATING NONRECURSIVE IMPURE DATA. . . . .   14
;        4.5.   SAVE AREAS. . . . . . . . . . . . . . . . . .   16
;        4.6.   DESCRIPTOR STORAGE. . . . . . . . . . . . . .   18
	SUBTTL	REVISION HISTORY

COMMENT	\
START OF VERSION 5.
122	CLEAN-UP THE LISTINGS AND REARRANGE A LITTLE.
124	ADD HOOKS FOR EXTERNAL FUNCTIONS
131	ADD SUPPORT FOR SNODDT & PAV.
145	Change the version number.
156	Fix a problem with edit 124.
167	Finish new error processing.
170	Add new keywords (&ERRLEVEL, &ERRMSG, &ERRNAME)
173	Change strings in SNODAT to upper & lower case
204	Add &VERSION keyword.
215	Add FTSINGLE, for one segment SITBOL
236	Revise the format of the output listing.
243	Add location to save the cpu type for EL file loading.
253	ERROR SNOSSO SHOULD BE ABLE TO WORK (I.E. DON'T USE STACK WHEN YOU
	DON'T HAVE ANY.)
255	Add a Low Segment version number.
266	Add a lowseg loc and a error text for the error 15.
\
	SUBTTL	PURE DATA --  COMMON CODE

; The following are used almost every where in SITBOL, so why duplicate
; the constants everywhere.

XWD22::	2,,2		;USED TO REMOVE STUFF FROM STACK
XWD44::	4,,4		;USED TO REMOVE TWO ARGS FROM STACK

;	NORMAL RETURNING FROM A PRIMARY ROUTINE

IFN FTDDT,<
RETNL3::SUB	STACK,XWD22	;BUMP STACK 1 DESCRIPTOR
>
RETNL2::SUB	STACK,XWD22		; BUMP STACK 1 DESCRIPTOR
RETNL1::SUB	STACK,XWD22		; BUMP STACK 1 DESCRIPTOR
RETNUL::PUSH	STACK,NULLST		; RETURN NULL STRING ...
	PUSH	STACK,NULLST+1		; FROM ...
	JRST	1(PLINK)		; PRIMARY ROUTINE

;	FAIL RETURNING FROM A PRIMARY ROUTINE

FRET3::	SUB	STACK,XWD22		; BUMP STACK 3 DESCRIPTORS
FRET2:: SUB	STACK,XWD22		; BUMP STACK 2 DESCRIPTORS
FRET1:: SUB	STACK,XWD22		; BUMP STACK 1 DESCRIPTOR AND 
	JRST	0(PLINK)		; AND FAIL.


	 ; PSHSA - ROUTINE TO PUSH SAVE AREAS
	 ; CALLING SEQUENCE:
	 ;	JSP	Z,PSHSA
	 ;	XWD	N,LOC

PSHSA::	MOVEM	Q1,PPRET	; SAVE Q1
	AOS	Q1,Z		; RETURN ADDR TO Q1

	HLR	Z,-1(Q1)	; LOAD WORD COUNT
	JRST	PSHR1		; JOIN PUSHR PROCESSING

	 ; PSHR - ROUTINE TO PUSH REGISTERS
	 ; CALLING SEQUENCE:
	 ;	JSP	Z,PSHR
	 ;	XWD	N+1,LOC

PSHR::	MOVEM	Q1,PPRET	; SAVE Q1
	AOS	Q1,Z		; RETURN POINT TO Q1

	HLR	Z,-1(Q1)	; LOAD COUNT TO Z-RIGHT
	HRLI	Z,JUNK		; TYPE TO Z-LEFT
	PUSH	STACK,Z		; PUSH WARNING WORD

	SOS	Z		; # OF REGS TO Z-RIGHT

PSHR1:	 ; HERE FROM PSHSA

	HRL	Z,Z		; # OF WORDS TO BE MOVED
	ADD	Z,STACK		; NEW STACK WORD TO ...
	EXCH	Z,STACK		; STACK, OLD STACK TO Z

	ADDI	Z,1		; 'TO' ADDRESS
	HRL	Z,-1(Q1)	; 'FROM' ADDRESS

	SKIPL	STACK		; TEST STACK ...
	ERROR	6,2		; FOR OVERFLOW

	EXCH	Q1,PPRET	; RESTORE Q1
	BLT	Z,0(STACK)	; DO THE DATA TRANSFER

	JRST	@PPRET		; AND RETURN

	 ; PPSA & PPR - ROUTINES TO POP SAVE AREAS &
	 ; REGISTERS RESPECTIVELY
	 ; CALLING SEQUENCE:
	 ;	JSP	Z,PPSA (OR JSP Z,PPR)
	 ;	XWD	N,LOC

PPSA::	TLOA	Z,400000	; FLAG ENTRY
PPR::	TLZ	Z,400000	; FLAG ENTRY

	MOVEM	Q1,PPRET	; SAVE Q1
	AOS	Q1,Z		; RETURN ADDRESS TO Q1

	HLL	Z,-1(Q1)	; COUNT TO Z-LEFT
	HLR	Z,Z		; AND RIGHT
	SUB	STACK,Z		; NEW STACK ...
	MOVEM	STACK,IGNOZ	; SAVE HERE

	HRLI	Z,1(STACK)	; 'FROM' ADDRESS TO Z-LEFT
	HRRZ	STACK,Z		; COUNT TO STACK-RIGHT
	ADD	STACK,-1(Q1)	; LAST 'TO' ADDRESS TO STACK
	HRR	Z,-1(Q1)	; 'TO' ADDRESS TO Z-RIGHT
	EXCH	Q1,PPRET	; RESTORE Q1 IN CASE
	BLT	Z,-1(STACK)	; BLT IT UP

	MOVE	STACK,IGNOZ	; LOAD NEW STACK
	SKIPL	PPRET		; POPR ENTRY?
	POP	STACK,Z		; YES - REMOVE EXTRA WORD

	JRST	@PPRET		; AND RETURN

	SUBTTL	PURE DATA --  &ALPHABET AND 1 CHAR. STRINGS
;
$ALPHA::	XWD	SDT,ALPHAC	; DESCRIPTOR TOP AND ...
		XWD	0,^D128		; BOTTOM FOR &ALPHABET
ALPHAC::	XWD	SBLOK,<^D128/5>+3	; DUMMY BLOK ...
		0			; HEADER
; 	
;	THE FOLLOWING MACRO WILL GENERATE THE TABLE OF 128 BYTES
;
	DEFINE  ALPHAM(N)< BYTE(7)N+0,N+1,N+2,N+3,N+4>
	ALPHAN=0
	REPEAT	<^D128/5+1>,<ALPHAM(\ALPHAN)
			ALPHAN=ALPHAN+5>
;
; SINGLE CHARACTER DESCRIPTOR BOTTOMS FOLLOW:
;
S.BL::	XWD	" ",1		; BLANK
S.CM::	XWD	",",1		; COMMA
S.LP::	XWD	"(",1		; LEFT PAREN
S.RP::	XWD	")",1		; RIGHT PAREN
S.TAB::	XWD	.CHTAB,1	; TAB

	SUBTTL	PURE DATA --  COMMON STRINGS


;	THE MACRO STRING WILL NOT ONLY ASSEMBLE A STRING (CALLING
; 	THE PSUEDO-OP ASCII) BUT WILL ALSO ASSEMBLE A WORD
;	OF THE FORM
;		XWD	OFFSET,LENGTH
;	TO BE USED AS THE SECOND WORD OF A 2-WORD DESCRIPTOR FOR
;	THE STRING.
;	THE VARIABLE OFF KEEPS TRACK OF THE OFFSET WHICH
;	IS RELATIVE TO SYSBL+2.
;	THE FIRST WORD OF THE DESCRIPTOR IS LOCATED AT SYSTR.
;	NUMBER IS A UTILITY MACRO USED TO CONVERT A SYMBOL TO
;	NUMERIC FORM


	DEFINE	NUMBER(N) <N>
	DEFINE STRING(S) <
	LSTR==0
	IRPC S,<
	LSTR==LSTR+1>
	XWD NUMBER(\OFF),NUMBER(\LSTR)
	ASCII	|S|
	OFF==<<<LSTR-1>/5>+2>*5+OFF   >
;
;	INITIALIZE OFF
;
	OFF==5		; THE FIRST STRING IS OFFSET BY 5
;
SYSTR:: XWD	SDT,.+1		; FIRST WORD OF DESCRIPTOR 
				; (COMMON FOR ALL)
SYSBL:: XWD	SBLOK,SYSBLE-SYSBL	; PHONEY ...
	0				; HEADER
;
;	NOTE: DUE TO A BUG IN THE ASSEMBLER, COMMENTS MAY
;	NOT APPEAR ON THE SAME LINE AS A REFERENCE TO THE
;	STRING MACRO.
;
S.EQL:: STRING	< = >
S.TEQ:: STRING	<	= >
S.BLLB::STRING	 ([<])
			; USED IN PREPARING DUMPS

;	COMPILER ERROR MESSAGES FOLLOW

CE.PRE::STRING	(*****)	; PREFIX FOR COMP. ERRORS
;CE.GT::	STRING	(ERROR IN GOTO FIELD)
; SEE EERR8
CE.NI::	STRING	(Error in numeric item)
CE.IC:: STRING	(Illegal character)
CE.MB:: STRING	<Missing blank>

;
;CE.CP:: STRING	(Invalid - copy card)
CE.PL:: STRING	(Multiply defined label)
CE.ME:: STRING	<Missing end supplied>
CE.BL::	STRING	(Too many left parens or brackets)
CE.BR:: STRING (Too few left parens or brackets)
CE.LS:: STRING (Stmt too long)
CE.UT:: STRING	(Undefined label)
CE.QT:: STRING	(Unmatched quote)
CE.SYS::STRING	(System error)
;CE.CE::	STRING 	(COMPILER ERROR)
; SEE EERR15
;
; MAJOR ERROR MESSAGES FOR EXECUTION ERRORS
;
;EERR01::STRING	< IN STATEMENT >
EERR02::STRING	< at level >
;EERR2::	STRING	<UNEXPECTED FAILURE>
CE.GT::
CE.GT::	STRING	<Error in goto>
EEUSER::	STRING	<User issued error>
EESYSE::	STRING	<?STBDIE	SITBOL has detected an internal error.
Please contact your Systems Programmer.  This error should not
normally be encountered, however it has at user PC >

;
;  THE FOLLOWING ARE STRINGS WHICH WILL BE PUT INTO $RTNTP
;
S.RET::	STRING	<RETURN>
S.FRET::STRING	<FRETURN>
S.NRET::STRING	<NRETURN>
;
; THESE STRING ARE USED BY DFF TO CREATE TRACING FOR USER DEFINED 
; FUNCTIONS.
;
FTRC.E::STRING	< entered>
FTRC.R::STRING	< from >
;
;	THE FOLLOWING STRINGS ARE USED BY THE INTERPRETER
;
S.BLNK::   STRING	<        >
S.EOC::	STRING	<
[SNOEOC	End of compilation]

>
S.NORM::   STRING	<[SNONRM	Normal termination at level >
S.LAST::	STRING	<[SNOLSE	Last stmt executed was stmt >
S.DMP::	STRING		<[SNODMP	Dump will follow]>
S.STAT::   STRING	<[SNOSTS	SITBOL statistics summary]

>
S.CMTM::   STRING	< ms. compilation time>
S.EXTM::   STRING	< ms. execution time>
S.STEX:: STRING	< stmts executed,>
S.FLD::	   STRING	< failed>
S.GC::	   STRING	< garbage collections>
S.NINS::   STRING	< reads>
S.NOUT::   STRING	< writes>
S.AVE::	STRING	< microsecond ave. per stmt executed>
S.USED:: STRING	< stack, maximum was >
S.SST::  STRING	< system>
S.HST::  STRING	< pattern matching>
S.NST::  STRING < name-list>
S.MLOW:: STRING <K max low-seg>
S.LOW::  STRING <K current low segment comprising:>
S.HGH::  STRING <K high segment>
S.FLID:: STRING < words floating>
S.GRID:: STRING < words growing>
S.STKS:: STRING < words for stacks:>
S.ID::	STRING	<SITBOL >
S.VER::	SNONME (STRING)
S.VTBL:: STRING < word variable table>
EERR01::
S.SMNT::   STRING< in stmt >
S.HIST::STRING	< INPUT('H.IN',&ARB,'T')
	N. = CONVERT(&NAME,.STRING,'S') '.HST'
	OUTPUT('H.OUT',N.,'T')
	A = &HISTOGRAM
	&HISTOGRAM = 
	H.P = TAB(1) SPAN('0123456789') . P.
	S. = '	' H.IN	:F(END)
	S. = ?(S. ? H.P) '(' A[P.] ')' S.
	H.OUT = S.	:[-2]>
;
;	THE FOLLOWING STRINGS ARE REEQUIRED BY TRC
S.NO::	STRING	< #>
S.BAR::STRING	<! >
S.LPRP::STRING	<() >
S.ED::	STRING	<ED >
S.CLST::STRING	< called in stmt >
S.TIME::STRING	<, time = >
S.STMT::STRING	< stmt >
S.KEQ::	STRING	<:	&>
S.CLT::	STRING	<:  >
S.TRAN::STRING	<transfer to >
S.CAL::	STRING	< call of >
S.LEV::  STRING	<:  level = >
S.TRET::STRING	< return of >
S.REE::	STRING	<reenter at &STCOUNT>
;
;  THE FOLLOWING STRINGS ARE NEEDED BY THE COMPLIER ERROR WRITER TO
;  CREATE THE ERROR MESSAGES
;
;CE.BK::	STRING	<     >
;CE.PT::	STRING	< .$. >

S.INP:: STRING <INPUT>
S.TTY:: STRING <TTY>
S.OUT:: STRING <OUTPUT>

;
;	THE FOLLWOING STRING DEFINES THE DEFAULT EXTERNAL FUNCTION
;	FILE NAME.
;
S.XLIB::
IFN FTOPS10,	STRING	<DSK:SNOLIB.REL>
IFN FTOPS20,	STRING	<PS:SITBOL-LIBRARY.REL>

	; THESE STRINGS ARE USED ON THE HEADER ON EACH PAGE OF
	; THE LISTING FILE

S.FIL::	STRING	<File: >
S.PAG::	STRING	<Page >
SYSBLE:			; SYSTEM SBLOK END

	SUBTTL	PURE DATA --  SYSTEM CHARACTER TABLE
;
;	SYSTEM WIDE CHARACTER SETS ARE DEFINED HERE
;
SYSCT::	XWD	CSDT,.+1	; FIRST WORD OF CHAR. SET DESCRIPTOR
	XWD	CTBLOK,LHDR+^D128	; PREPARE PHONEY HEADER
	0				; GC FIELD
;	'X.' LABEL PROVIDES A CONVENIENT HANDLE ON THE RELATED
; MASK BUT IT CAN ONLY BE USED IF ONE BIT APPEARS IN THE WORD.
SYSCTB:: REPEAT	11,<0>		; SKIP FIRST OCTAL 11 LOCATIONS
X.TAB::	Y.TAB			; TAB CHARACTER
	Y.VM			; LINE FEED
	Y.VM			; VERTICAL TAB
	Y.VM			; FORM FEED
	Y.CR			; CARRIAGE RETURN
	REPEAT	32-16,<0>	; SKIP TO OCTAL 32
	Y.CZ			; ^Z
	Y.ALT			; ALT-MODE
	REPEAT	40-34,<0>	; SKIP TO OCTAL 40
X.BL::	Y.BL			; BLANK
	Y.OP!Y.VB		; !
X.QQ::	Y.QQ			; "
X.OP::	Y.OP			; #
	Y.OP!Y.DOLR		; $
	Y.OP!Y.PCNT		; %
	Y.OP			; '

X.Q::	Y.Q			; '
X.LP::	Y.LP			; (
X.RP::	Y.RP			; )
	Y.OP!Y.STAR		; *
	Y.OP!Y.PLUS		; +
X.CM::	Y.CM			; ,
	Y.OP!Y.MNS		; -
	Y.OP!Y.PER		; .
	Y.OP!Y.SLSH		; /
X.NUM::	REPEAT ^D10,<Y.NUM>	; 0-9
X.COL::	Y.COL			; :
X.SEMI::Y.SEMI			; ;
X.LB::	Y.LB			; <
	Y.OP!Y.EQ		; =
X.RB::	Y.RB			; >
	Y.OP			; ?
	Y.OP			; @
X.UPS::	REPEAT	3,<Y.UPS>	; LETTERS A-C (UPPER CASE)
	Y.E!Y.UPS		;[247] Allow D exponent
	Y.E!Y.UPS		; THE LETTER E
	REPEAT  ^D21,<Y.UPS>	; THE REST OF THE UPPER CASE ALPHABET
	Y.LB			; [
	Y.OP			; \
	Y.RB			; ]
	Y.OP!Y.VB		; ^
	Y.OP!Y.UN		; _
	0			; `
X.LOWS::REPEAT	^D26,<Y.LOWS>	; LOWER CASE
	Y.LB			; lt. curly bracket
	Y.OP!Y.VB		; VERTICAL BAR
	Y.RB			; RT. CURLY BRACKET
	Y.OP			; TILDE
	0			; DELETE
;
;	MISC. MASKS FOR SYSTEM CHARACTER SETS
;	(A WORD OF THE FORM X.--- FORMS THE 2ND WORD
; 	OF A TWO WORD DESCRIPTOR THE FIRST WORD OF WHICH
;	IS FOUND AT SYSCT)
;
X.ALPH::	Y.UPS!Y.LOWS		; ALPHABETICS
X.ALNU::	Y.UPS!Y.LOWS!Y.NUM	; ALPHANUMERICS
X.ID::	Y.UN!Y.UPS!Y.LOWS!Y.NUM!Y.PER	; IDENTIFIER CHARACTERS
X.NUM.::	Y.NUM!Y.PER		; NUMBERS AND PERIOD
X.CMRP::	Y.CM!Y.RP		; COMMA OR RIGHT PAREN
X.NSC::		Y.NUM!Y.MNS!Y.PLUS!Y.PER!Y.E
					; NUMERICAL STRING CONSTANT

X.R50::	Y.UPS!Y.LOWS!Y.PER!Y.DOLR!Y.PCNT ;RADIX-50 SYMBOLS

	SUBTTL	PURE DATA --  MISC. PURE DATA
;
NULLST::	XWD	SDT,0	; DESCRIPTOR FOR NULL STRING
		0
;
;
;

	SUBTTL	IMPURE DATA -- MACROS



;	THE FOLLOWING MACROS ARE NEEDED TO ENCODE THE
;	IMPURE DATA AREA. THEY ALL ASSEMBLE INTO ZERO'S
;	SO AS TO MAKE THE IMPURE SEGMENT RESTARTABLE.
;	BUT THEY ALSO PROVIDE CODE (BEGINNING AT INIMP) WHICH
;	INITIALIZES THESE LOCATIONS.
;	CONTROL RETURNS VIA QLINK.
INIMP::
;
	DEFINE	XWD.(X,Y,%LOC)<
%LOC:	BLOCK 1
	RELOC
	MOVE	Z,[XWD X,Y]
	MOVEM	Z,%LOC
	RELOC	>
;	EXP.	MACRO TO STORE SOMETHING INTO THE LOW SEG.
;

	DEFINE	EXP.(X,%LOC)<
%LOC:	BLOCK 1		;; ASSEMBLE THE WORD
	RELOC		;; GET BACK TO PURE CODE
	STORE	Z,%LOC,,X	;;STORE IT INTO THE LOW SEG
	RELOC>		;; LEAVE IT IN IMPURE.


;	WORD. macro to store one full word into the low segment.
;	EXP. can not be used since it uses the STORE macro from UUOSYM
;	and can not handle external symbols

	DEFINE	WORD.(VAL,%LOC),<
%LOC:	BLOCK	1		;;Generate the storage
	RELOC			;;INTO THE HIGH SEGMENT FOR CODE
	MOVE	Z,[VAL]		;;Get the value
	MOVEM	Z,%LOC		;;STORE IT
	RELOC			;;Back tothe low segment
>

;
	RELOC	0

HGHVER::	BLOCK	1	; high segment version no.
LWVRSN::	LOWVER		;[255] Low segment Version number
				; Starts at one with edit [255]
SEGDEV::	BLOCK	1	; for storage of original seg spec's
SEGNAM::	BLOCK	1
		BLOCK	2
SEGPPN::	BLOCK	1
		BLOCK	1
STFLAG::	BLOCK	1	; so that seg spec's remain untouched.
HSTLOC::BLOCK	1		; 
HSTSAV::BLOCK	3		; PRIVATE SAVE AREA
CPUTYP::BLOCK	1		;[243] CPU type; ka = 1, ki = 2, kl = 3

FID::

	SUBTTL 	IMPURE DATA -- misc. from all modules


;	--	SNOFIO		--

JOBNO6::	BLOCK	1
TMPOPN::	BLOCK	1
TRFLGS::	BLOCK	1	; location to save current traps.
RSFLAG::	BLOCK	1	; restart flag.
S.PAR::		BLOCK	1	; stacks
V.PAR::		BLOCK	1	; variable table
C.PAR::		BLOCK	1	; core
TTYBLK::	BLOCK	1
GETOSV::	BLOCK	1	; saves linking register.
STBLKS::	BLOCK	1
CDWSV::		BLOCK	1
RDLINK::	BLOCK	1	; link save for read
RDSTBL::	BLOCK	1	; read stream block
RDFLGS::	BLOCK	1	; holds flags.
DEPTR::		BLOCK	1
RDQLNK::	BLOCK	1
DEVICE::	BLOCK	1	; .. for strio ..
FILNAM::	BLOCK	1
EXT::		BLOCK	1
PRIV::		BLOCK	1
PPN::		BLOCK	1
PTH::		BLOCK	12
		PTHEND==:.-1
TERMCH::	BLOCK	1	; terminal (or break) char.
IOBLKS::	BLOCK	1
PTHPTR::	BLOCK	1
FRSTNM::	BLOCK	1
DFTEXT::	BLOCK	1	; current default ext.
EXPTR::		BLOCK	1	; define extraction ptr
ALBFSV::	BLOCK	1
BTSIZE::	BLOCK	1	; size of byte
BTLENG::	BLOCK	1
BTPTR::		BLOCK 	1
BTBASE::	BLOCK	1
BTMAX::		BLOCK	1
BTLJFL::	BLOCK	1	; left-justify flag

;	--	SNOSYN		--

VB.S::	BLOCK	1
VB.F::		BLOCK	1
VB.ST::		BLOCK	1
VB.BL::		BLOCK	1
VB.EQ::		BLOCK	1
LEVEL::		BLOCK	1
PMFLAG::	BLOCK	1
FGT::		BLOCK	1	; holds offset to fail goto
SGT::		BLOCK	1	; holds offset to success goto
RGT::		BLOCK	1	; holds offset to recovery goto
GTZONE::	BLOCK	1
CURSOE::	BLOCK	1
ENDLBL::	BLOCK	1
EXFLAG::	BLOCK	1	; flag to indicate expression comp
LAST::		BLOCK	1	; offset to last statement in CBLOK
ENDFLG::	BLOCK	1

;	--	SNOERR 		--

ERRLOC::	BLOCK	1	;[266] WHERE ERROR OCCURED
IN.ERR::	BLOCK	1
PREFIX::	BLOCK	1
CERARG::	BLOCK	1
CERLNK::	BLOCK	1
SET.LB::	BLOCK	1

;	--	SNODEB		--

T1SAV::		BLOCK	1

;	--	SNOPAV		--

TLNKSV::	BLOCK	1
SVTLNK::	BLOCK	1
T2SAV::		BLOCK	1
T3SAV::		BLOCK	1

;	--	SNOSTR		--

STCHD::		BLOCK	1
STCPTR::	BLOCK	1
STCTOT::	BLOCK	1
STCREM::	BLOCK	1

;	--	SNOSMR		--

CCSCSV::	BLOCK	1
CVTSAV::	BLOCK	1

;	--	SNOEXT		--

ECBPTR::	BLOCK	1	; pointer to junk block (has code for ext fun)
LOCNTR::	BLOCK	1	; location counter for loading code
TSAVE::		BLOCK	2	; save area for T routines
LCOUNT::	BLOCK 2	; SAVE ARE FOR GETDAT

;	--	SNOLEX		--

LASLOT::	BLOCK	1
NXTUBE::	BLOCK	1
STATE::		BLOCK	1
LINES::		BLOCK	1
GTFLAG::	BLOCK	1
STKSAV::	BLOCK	2		; Some save areas

;	--	SNOTBL		--

FTESV::		BLOCK	2
TBLSV::	BLOCK	2

;	--	SNOSYM		--

TLSAV::		BLOCK	1

;	--	SNOGC		--

BLOKSV::	BLOCK	2
SEDIM::		BLOCK	1

;	--	SNOTRC		--

BARINC::	BLOCK	1
LNCLSV::	BLOCK	1	; save word for calling line used elsewhere
TR.TIM::	BLOCK	1
SLKSAV::	BLOCK	1

;	--	SNOCVT		--

CVSTOR::	BLOCK	1
CVSTO1::	BLOCK	1
CVSTO2::	BLOCK	1
CVSTO3::	BLOCK	1

;	--	SNOPL		--

CVPTSV::	BLOCK	1

;	--	SNONUM		--

NUMSTR::	BLOCK	1
	SUBTTL	IMPURE DATA -- IMPURE KEYWORDS

; PROTECTED

$FNCLV:: BLOCK  1	; &FNCLEVEL
	 BLOCK  1	; TRACE FLAG
$LASTN:: BLOCK  1	; &LASTNO
$RTNTP:: BLOCK  1	; &RTNTYPE
$STCNT:: BLOCK  1	; &STCOUNT
	 BLOCK  1	; TRACE FLAG
$STFCT:: BLOCK  1	; &STFCOUNT
	 BLOCK  1	; TRACE FLAG
$STNO::  BLOCK  1	; &STNO
$JOBNO:: BLOCK  1	; &JOBNO

; UNPROTECTED

$ABEND:: BLOCK  1    	; &ABEND
$ANCH::  BLOCK  1	; &ANCHOR
$CODE::  BLOCK  1	; &CODE
$DUMP::  BLOCK  1	; &DUMP
$ERRTP:: BLOCK  1	; &ERRTYPE
	 BLOCK	1	; TRACE FLAG FOR &ERRTYPE
$ERRLM:: BLOCK  1	; &ERRLIMIT
$ERRLV:: BLOCK	1	; &ERRLEVEL
$VERSN:: BLOCK	1	; &VERSION
$FTRC::  BLOCK  1	; &FTRACE
$FULL::  BLOCK  1	; &FULLSCAN
$INPUT:: EXP. 1  	; &INPUT
$MAXL::  EXP.  ^D5000	; &MAXLNGTH
$OUTPT:: EXP. 1  	; &OUTPUT
$STLIM::	XWD.	377777,777777	; &STLIMIT
$TRACE:: BLOCK  1	; &TRACE
$TRIM::  BLOCK  1	; &TRIM
$RAND::	BLOCK	1	; &RANDOM


IFN FTPAV,<
$ASSOC::EXP.	1		; &ASSOCIATE
>;END OF IFN FTPAV
	SUBTTL	IMPURE DATA -- NONFLOATING NONRECURSIVE IMPURE DATA
PREX::	  EXP. 1	;  PRE-EXECUTION STAGE.  WHEN EXECUTION BEGINS
			; THIS IS SET TO 0.
CEIL::	  BLOCK 1	; UPPER LIMIT ON FLOATING STORAGE
HIWATR::  BLOCK 1       ; HIGH WATER MARK FOR CORE REQUESTS
FLOOR::	  BLOCK 1	; BOTTOM OF FLOATING STORAGE
STBASE::  BLOCK 1	; SYSTEM STACK BASE
HSBASE::  BLOCK 1	; HISTORY STACK BASE
NSBASE::  BLOCK 1	; NAME-LIST STACK BASE
BROOM::   EXP. ^D1000	; BREATHING RTOOMCH::  EXP. ^D3000	; MAXIMUM SLACK
VTABLE::  BLOCK	1	; ADDRESS OF HASH TABLE FOR VARIABLE BLOCKS
LVTBL::	  BLOCK 1	; LENGTH OF VTABLE
TIME.S::  BLOCK 1	; STARTING TIME
TIME.C::  BLOCK 1	; TIME AT FINISH OF COMPILATION
TIME.E::  BLOCK 1       ; ENDING TIME
GRID::	  BLOCK 1	; BASE OF GROWING REGION
GSURF::	  BLOCK 1	; SURFACE OF GRID REGION
NLINES:: EXP.	<^D55>		; Lines per page on the output listing
DIM4::	  BLOCK 1	; 4TH DIMENSION
CMPNO::	  EXP. 1	; COMPILER STATEMENT NO.
PAGENO::  EXP. 1	; COMPILER PAGE NO.
NLPGNO::	EXP.	1	;[254] NEXT LINE PAGE NUMBER
NLMPGN::	BLOCK	1	;[254] Next line minor page number.
ARYID::   BLOCK 1	; ID # FOR ARRAYS
TBLID::   BLOCK 1	; ID # FOR TABLES
DFDID::	  BLOCK 1	; IDENTIFICATION # FOR DEFINED DATATYPES
NINS::	  BLOCK 1	; NUMBER OF READS
NOUTS::	  BLOCK 1	; NUMBER 0F WRITES
NGCS::    BLOCK 1	; NUMBER OF GARBAGE COLLECTS
CBLENG::  EXP. ^D400	; LENGTH OF CBLOK
AUTOHS::  BLOCK 1	; AUTO HISTOGRAM
GRFLAG::  BLOCK 1	; ALL. IN GR. REG. FLAG
LINENO::	BLOCK	1	; FAKED LINE NUMBER
IGNOZ:	BLOCK	1	; TEMPS USED BY ...
PPRET:	BLOCK	1	; PUSH-POP MACROS

IFN FTDDT,<
I.JRST::WORD.	<JRST	I.BUMP##>	;EVENT TRAP FOR INTERPRETER LOOP
					; XCT'ED INSTRUCT. BY INTERPRETER

>	;END OF IFN FTDDT

EF.FLG::EXP.	0		;[156] Flag turned on when executing an
				;[156]  external function

	; GETSG -- ROUTINE  USED BY STBERR AND SNOERR
	;		TO CALL A HIGH SEGMENT
	;		IS CALLED WITH P1 CONTAINING THE RETURN ADDR
	;		AND WITH Z CONTAINING THE NAME OF THE HIGH SEG.

IFE FTSINGLE,<			;[215] Single segment SITBOL
	RELOC

	HRLI	Z,GETSGS
	HRRI	Z,GETSG
	BLT	Z,GETSG+GSGLEN-1
	JRST	.+GSGLEN+1

GETSGS:	PHASE	0
	MOVEI	S1,GETSG		; TO MAKE IT EASY
	MOVEI	Q2,GSGBLK(S1)		; GIVE GSGBLK SPECS TO
	HRLI	Q2,SEGDEV		; GSGBLK.  FOUND IN
	BLT	Q2,GSGBLK+4(S1)		; SEGDEV.
	MOVEM	Z,GSGBLK+1(S1)		; ALSO PLACE SEGNAME.

	HRLI	Z,1		; SAVE SOME ...
	HRRI	Z,IGNOP		; IMPORTANT ...
	BLT	Z,IGNOP+3	; REGISTERS

	MOVE	Z,.JBSA		; SAVE THE STARTING ADDR
	MOVEM	Z,ADDRSA(S1)	; ..

	MOVSI	Z,1		; DELETE THE ...
	CORE	Z,		; HIGH SEG
	 ERROR	15		; HOPEFULLY NEVER.

	MOVEI	Z,GSGBLK(S1)	; USE GSGBLK FOR SPECS
	GETSEG	Z,		; EXE THE UUO
	 ERROR	15		; COULDN'T DO IT?

	MOVEI	S1,GETSG	; ** [GC] ** GETSEG DESTROYED ADDRESS !!! FIX!

	MOVE	Z,ADDRSA(S1)	; GET BACK .JBSA
	MOVEM	Z,.JBSA		; ..

	HRLI	Z,IGNOP		; GET BACK THOSE ..
	HRRI	Z,1		; IMPORTANT ...
	BLT	Z,4		; REGISTERS.

	JRST	0(PLINK)	; RETURN TO WHOEVER.

GSGBLK:	BLOCK	6
ADDRSA:	BLOCK	1

	DEPHASE
	GSGLEN==.-GETSGS
	RELOC

GETSG::	BLOCK	GSGLEN



>;[215] End of IFE FTSINGLE
	SUBTTL	IMPURE DATA --  SAVE AREAS
;
;	THIS IS THE START OF THE REGION TENDED BY THE GARBAGE
;	COLLECTOR.
TENDED::
;
;	2.3.1  PATTERN MATCHING SAVE AREA
;
SAVEM::		XWD.  JUNK,LIGNOM+1	
			; INDICATOR FOR GARBAGE COLLECTOR
IGNOM::			; START OF IGNORED AREA
CURSOR::	BLOCK 1		; CURSOR
STPTR::		BLOCK 1		; STREAM POINTER
MAXLEN::	BLOCK 1		; MAXIMUM LENGTH PREFIX OF ...
				; SUBJECT STRING WHICH CAN BE MATCHED
HSTACK::	BLOCK 1		; HISTORY STACK
NSTACK::	BLOCK 1		; NAME STACK
FUTILE::	BLOCK 1		; FUTILITY FLAG
SCRAD::		BLOCK 1		; SCAN RETURN ADDRESS
;
;FLAM::			; FLOATING ADDRESSES FOR PATTERN MATCHING
SUBJ::	BLOCK	2	; SUBJECT STRING OF THE MATCH
PATT::	BLOCK 	2	; PATTERN FOR THE MATCH
	IFN LSAVEM-<.-SAVEM>,< PRINTX LSAVEM IS IN ERROR>
;
;	2.3.2  INTERPRETER SAVE AREA
;
SAVEI::		XWD.	JUNK,LIGNOI+1
IGNOI::				; IGNORED AREA
GROUND::	BLOCK 1		; BASIC STACK POSITION.
			; SERVES AS FRAME OF REFERENCE ON A PER
			; STATEMENT BASIS
STSAVE::	BLOCK 1		; STACK SAVE, REQUIRED ON A PER FUNCTION
				; BASIS
PUSHTP::        BLOCK 1         ; DENOTES TYPE OF PUSH
                      ; 0=BOTTOM, 1=FUNCTION, -1=ERROR RECOVERY
;FLAI::			; FLOATING ADDRESS SAVE REGION OF INTERPRETER
ILABEL::	BLOCK 2		; STATEMENT LABEL POINTER
ILOC::		BLOCK 2		; LOCATION COUNTER
	IFN LSAVEI-<.-SAVEI>,<PRINTX LSAVEI IS IN ERROR>
;	SAVE AREA FOR PRIMARY ROUTINES
SAVEP::	XWD.	JUNK,LIGNO+1
IGNOP::	BLOCK	LIGNO	; IGNORED REGION
FLAP::	BLOCK	LFLA	; FLOATING REGION
;
;	SAVE AREA FOR SECONDARY ROUTINES
SAVES::	XWD.	JUNK,LIGNO+1
IGNOS::	BLOCK	LIGNO	; IGNORED REGION
FLAS::	BLOCK	LFLA	; FLOATING REGION
;
;	TERTIARY SAVE AREA
SAVET::	XWD.	JUNK,LIGNO+1
IGNOT::	BLOCK	LIGNO	; IGNORED REGION
FLAT::	BLOCK	LFLA	; FLOATING REGION
;
;	QUATERNARY SAVE AREA
SAVEQ::	XWD.	JUNK,LIGNO+1
IGNOQ::	BLOCK	LIGNO
FLAQ::	BLOCK	LFLA

	SUBTTL	IMPURE DATA -- DESCRIPTOR STORAGE
;
;	INFORMATION IN THIS SECTION APPEARS IN WORD PAIRS
;	AND ARE ASSUMED BY THE GARBAGE COLLECTOR TO BE VALID
;	DESCRIPTORS.
;
;	I/O DESCRIPTORS
;
OUTF::   	BLOCK  2	; OUTPUT FILE
LISTF::		BLOCK  2	; LISTING FILE
CERRF:: 	        	; COMPILER ERROR FILE
XERRF::  	BLOCK  2	; EXECUTION ERROR FILE
COMPIN::	BLOCK 2       	; COMPILER INPUT FILE
INFILE::	BLOCK  2	; DATA INPUT FILE
;
;	OTHER MISC. DESCRIPTORS
LASTCI::	BLOCK  2  	; LAST COMPIN DESCRIPTOR
CCTBL:: 	BLOCK  2	; CURRENT CHARACTER TABLE
$HIST::		BLOCK  2	; HISTOGRAM TABLE
LSUBJ::		BLOCK  2	; LISTING SUBJECT
RP.A2::		BLOCK 4		; 2ND AND 3RD ARGS TO REPLACE
RP.TBL::	BLOCK 2		; TABLE USED BY REPLACE
TB.FNC::	BLOCK 2		; &FNCLEVEL TRBLOK
TB.STC::	BLOCK 2		; &STCOUNT TRBLOK
TB.STF::	BLOCK 2		; &STFCOUNT TRBLOK
TB.ERR::	BLOCK 2		; &ERRTYPE TRBLOK
ERRPRM::	XWD.	SDT,0	; &ERRPARM
		BLOCK 1
ERRNAM::	XWD.	SDT,0	; &ERRNAME
		BLOCK	1
ERRMSG::	XWD.	SDT,0	; &ERRMSG
		BLOCK	1
IFN FTDDT,<
BPTBL::	BLOCK	2	;Break point table
DDTVAB::BLOCK	2	;VABLOK for DDT event association

>;END OF IFN FTDDT


;	END OF FIXED IMPURE DATA SECTION (FID)
;	ALSO BEGINNING OF ADJUSTABLE IMPURE DATA SECTION (AID)
AID::

	RELOC
	JRST	0(QLINK)		; END INIT AND RETURN
	END
   H Ñ