	SUBTTL	L. SAMBERG/LSS/DRH/MP/RCM/VB		15-JUN-76

; COPYRIGHTS 1972,1973,1976,1977  STEVENS INSTITUTE OF TECHNOLOGY
; HOBOKEN, NEW JERSEY, 07030
; ALL RIGHTS RESERVED.

  ;UNIVERSALS

	SEARCH	MACTEN		;DEC-10 COMMON MACROS
	SEARCH	SNOPRM		;SITBOL PARAMETER FILE

  ;DIRECTIVES

	.DIRECT	.XTABM		;EXCLUDE TABS FROM MACRO CALLS
	SALL			;SUPPRESS MACRO EXPANSIONS
	TWOSEG	400K		;TWOSEGMENT CODE

  ;VERSION NUMBER

	CVTVER==5		;MAJOR VERSION NUMBER
	CVTMIN==0		;MINOR VERSION NUMBER
	CVTEDT==247		;EDIT LEVEL
	CVTWHO==0		;CUSTOMER ARGUMENT

  ;TITLE

	TITLE.	CVT,SNOCVT,<Datatype Conversion Routines>

  ;SHOW UNIVERSAL VERSION NUMBERS

	SHOW.	%%MACT		;VERSION NUMBER OF MACTEN
	SHOW.	%%SNOP		;VERSION NUMBER OF SNOPRM

	CVTTTL			; Title
	CVTPTX			; PASS2 message
	SUBTTL	Table of Contents

;		Table of Contents for Datatype Conversion Routines
;
;
;			   Section			      Page
;   1. Table of Contents. . . . . . . . . . . . . . . . . . .    2
;   2. REVISION HISTORY . . . . . . . . . . . . . . . . . . .    3
;   3. INTRODUCTION . . . . . . . . . . . . . . . . . . . . .    4
;   4. DATATYPE CONVERSIONS . . . . . . . . . . . . . . . . .    5
;   5. BUILT-INS AND UNARY OPERATORS. . . . . . . . . . . . .   17
	SUBTTL	REVISION HISTORY

COMMENT	\

START OF VERSION 5.
122	RENAME MODULES & CLEAN UP.
133	FIX BUG IN STRING TO NUMERIC CONVERSION.
174	Fix problem in real to string conversion of zero.
247	Allow D to signify an exponent.
\
	SUBTTL	INTRODUCTION

;THIS MODULE CONTAINS FIVE DTATTYPE CONVERSION ROUTINES:

;	1)CVTINT -- CONVERT TO INTEGER
;	2)CVTRL  -- CONVERT TO REAL
;	3)CVTNUM -- CONVERT TO NUMERIC
;	4)CVTSTR -- CONVERT TO STRING
;	5)CVTNAM -- CONVERT TO NAME

;ALL ROUTINES ARE 'T' LEVEL.
;CVTSTR AND CVTNAM ARE UNSTABLE.

;ALSO CONTAINS 3 BUILT-IN FUNCTIONS:
;	1)CONVERT
;	2)IND -- UNARY '$'
;	3)NAME-- UNARY "."

;SOME FLAGS
	F..NEG==1B18		;RESULT IS NEGATIVE
	F..DEC==1B19		;DECIMAL POINT SEEN
	F..ING==1B20		;CONVERT TO STRICTLY INTEGER
	F..NEX==1B21		;NEGATIVE EXPONENT


;USABLE AC'S ARE:
;	T1,T2,T3,T4
;	Q1,Q2,Q3
;	Z

IFNDEF	MAXDIG <MAXDIG==^D8>	;MAXIMUM # OF DIGITS
IFNDEF	MAXDEC <MAXDEC==^D8>	;MAX NUMBER OF DECIMAL PLACES
IFNDEF	MINDEC <MINDEC==2>	;MIN NUMBER OF DEC PLACES


SUBTTL	DATATYPE CONVERSIONS

;CONVERT TO INTEGER ROUTINES

CVTING::MOVSI	T2,IDT		;RESULT IS INTEGER DATATYPE
	TROA	T2,F..ING	;ACCEPT NOTHING BUT INTEGER

;HERE IS REAL CONVERT TO INTEGER

CVTINT::MOVSI	T2,IDT		;RESULT IS INTEGER
	JSP	QLINK,CVCHTP	;GET TYPE OF ARGUMENT
	  JRST	CVS.M		;STRING --> INTEGER(NUMERIC)
	  JRST	1(TLINK)	;INTEGER --> INTEGER (NO-OP)

;HERE FALL THRU TO CONVERT REAL TO INTEGER

CVR.I:	JSP	QLINK,CVCHMG	;GET THE MAGNITUDE
	  JRST	PUTZR		;ITS A ZERO

CVR.I1:	CAML	T4,[244400,,0]	;GT 2^35?
	JRST	0(TLINK)	;YES LOSE
	CAML	T4,[201400,,0]	;LT 1?
	JRST	CVR.I2		;NO ITS IN RANGE
	JRST	PUTZR		;LT 1 = 0

CVR.I2:	LDB	Q1,[POINT 8,T4,8]
	ASH	T4,10		;NORMALIZE FRACTION TO BIT 1
	CLEAR	T3,		;SHIFT REGISTER
	ASHC	T3,-200(Q1)	;SHIFT OVER ACCORDING TO EXPONENT
	MOVE	T4,T3		;PUT IT IN THE RIGHT REGISTER
	JRST	PUTON		;AND RETURN


;CONVERT TO REAL ROUTINES

CVTRL::	MOVSI	T2,RDT		;RESULT WILL BE REAL
	JSP	QLINK,CVCHTP	;GET TYPE OR ARGUMENT
	  JRST	CVS.M		;CONVER STRING --> REAL(NUMERIC)
	  JRST	CVI.R		;CONVERT INTEGER --> REAL
	  JRST	1(TLINK)	;REAL --> REAL IS A NO-OP

;HERE CONVERT INTEGER TO REAL

CVI.R:	JSP	QLINK,CVCHMG	;GET MAGNITUDE
	  JRST	PUTZR		;ITS O

CVI.R1:	MOVE	Q1,T4		;GET NUMBER IN Q1
	JSP	Z,FLOAT		;FLOAT IT
	JRST	PUTONQ		;AND RETURN


;HERE CONVERT TO STRING

CVTSTR::MOVSI	T2,SDT		;RESULT IS SDT
	JSP	QLINK,CVCHTP	;GET TYPE OF ARG
	  JRST	1(TLINK)	;STRING TO STRING IS EASY.
	  JRST	CVI.S		;CONVERT INTEGER --> STRING

;FALL THRU TO CONVERT REAL TO STRING

CVR.S:	JSP	QLINK,CVGTBK	;GET AN SBLOK AND SETUP NUMBER

CVR.S1:	LDB	T3,[POINT 8,T4,8]
	CLEARM	CVSTO1##		;PLACE TO COUNT E SCALE
	MOVE	Q1,T4		;TRANSFER THE NUMBER
	CAIGE	T3,167		;IF GE -9
	JRST	CVR.S2		;THEN DONT USE "E"
	CAIG	T3,233		;AND LT 27,
	JRST	CVR.S6		;THEN DON'T USE 'E' CONSTRUCT

CVR.S2:	MOVEM	Q2,CVSTO1	;SAVE COUNT
	HRREI	Q2,-200(T3)	;PUT EXPONENT IN Q2
	ASH	Q2,-2		;DIVIDE BY FOUR
	MOVEM	Q2,CVSTO2##	;SAVE SCALE FACTOR
	MOVNS	Q2		;NEGATE SO WE DO THE RIGHT MULT
	MOVEM	TLINK,IGNOT##	;SAVE THE LINK
	JSP	TLINK,CVS.NH	;AND SCALE THE NUMBER
	  ERROR	15		;IMPOSSIBLE??

	MOVE	Q2,CVSTO2	;GET SCALE BACK WITH PROPER SIGN
CVR.S3:	CAML	Q1,[201400,,0]	;MAKE SURE POINT IS IN RIGHT PLACE
	JRST	CVR.S4		;KEEP CHECKING
	FMPRI	Q1,204500	;MULTIPLY BY 10
	SOS	Q2		;AND DECR. EXPONENT
	JRST	CVR.S3		;LOOP AROUND TO CHECK

CVR.S4:	CAMGE	Q1,[204500,,0]	;GT 10
	JRST	CVR.S5		;NO CONTINUE
	FDVRI	Q1,204500	;DIVIDE BY 10
	AOS	Q2		;AND INCREMENT
	JRST	CVR.S4		;LOOP AROUND AND CHECK AGAIN

CVR.S5:	EXCH	Q2,CVSTO1	;SAVE SCALE AND GET COUNT
	LDB	T3,[POINT 8,Q1,8]
	MOVE	TLINK,IGNOT##	;RETRIEVE THE LINK


CVR.S6:	ASH	Q1,10		;NORMALIZE FRACTION TO BIT 1
	CLEAR	T4,		;CLEAR THIS FOR SHIFT
	ASHC	T4,-200(T3)	;SHIFT ACCORDINGLY
	MOVEM	Q1,IGNOT##+2	;SAVE THIS FOR LATER
	PUSHJ	STACK,CVI.SL	;INSERT INTEGER PART


CVR.S7:	MOVNI	Q1,MAXDIG	;GET MAX DIGITS
	ADDI	Q1,(Q2)		;SUBTRACT WHAT WE'VE ALREADY GOT
	TRNE	T2,F..NEG	;IF NUMBER IS NEGATIVE
	SOJ	Q1,		;ADD ONE FOR THE MINUS SIGN
	CAMGE	Q1,[-MAXDEC]	;OK IF LE MAXDEC
	MOVNI	Q1,MAXDEC	;OTHERWISE USE MAXDEC
	CAMLE	Q1,[-MINDEC]	;HOWEVER, WE WANT AT LEAST 2
	MOVNI	Q1,MINDEC	;DECIMAL PLACES
	HRLI	Q2,(Q1)		;MAKE AOBJN POINTER
	MOVMS	Q1
	MOVEI	T2,12(Q1)	;SETUP TO COUNT ZERO BITS
	MOVE	Q1,RNDTBL(Q1)	;GET ROUNDING FACTOR
	JFCL	17,.+1		; CLEAR FLAGS
	ADD	Q1,IGNOT##+2	;AND ADD FRACTIONAL PART
CVR.SX:	JFCL	2,[ HRLOI Q1,377777	; IF OVERFLOW USE ...
		    JRST  CVR.SX+1 ]	; MAXIMUM POSITIVE NO.
	MOVEI	T4,"."		;PUT A DECIMAL POINT IN
	AOJ	Q2,		;INCREMENT COUNT
	IDPB	T4,IGNOQ##	;HERE

CVR.S8:	MOVE	T4,Q1		;PUT NUMBER IN T4
	JFFO	T4,.+2		;IT MIGHT BE WISE TO DO SOME
	JRST	CVR.S9		; TRUNCATION.
	CAIL	Q1,(T2)		;IF I'VE GOT MORE THAN (T2) 0'S
	JRST	CVR.S9		;IN FRONT OF ME.
	SUBI	T2,2		;DECREMENT COUNT OF ALLOWABLE 0'S
CVR.SL:	MULI	T4,12		;MULTIPLY BY 10
	ADDI	T4,60		;MAKE IT ASCII
	IDPB	T4,IGNOQ##	;DEPOSIT IT
	AOBJN	Q2,CVR.S8	;IF NOT DONE, THEN LOOP AROUND

CVR.S9:	MOVE	Q1,CVSTO1	;GET SCALE FACTOR
	JUMPE	Q1,CVI.S3	;DONT SCALE
	MOVEI	T4,"E"		;PUT IN "E"
	IDPB	T4,IGNOQ##	;DEPOSIT IT
	MOVEI	T4,"+"		;PLUS?
	SKIPGE	Q1
	MOVEI	T4,"-"		;NO MINUS
	IDPB	T4,IGNOQ##	;DEPOSIT IT
	ADDI	Q2,2		;INCREMENT CHAR COUNT
	MOVM	T4,Q1		;GET MAGNITUDE OF SCALE
	PUSHJ	STACK,CVI.SL	;CONVERT TO ASCII
	JRST	CVI.S3		;DONE -- RETURN


;CONVERT INTEGER TO STRING

CVI.S:	JSP	QLINK,CVGTBK	;GET AN SBLOK AND SETUP POINTERS

CVI.S2:	PUSHJ	STACK,CVI.SL	;RECURSIVE CALL TO THE PROCESSING
				; LOOP
CVI.S3:	HRRZM	Q2,(STACK)	;OFFSET,,LENGTH
	MOVE	Q2,IGNOT##+1	;GET THE DESCRIPTOR
	MOVEM	Q2,-1(STACK)	;SDT,,ADDRESS
	JRST	1(TLINK)	;AND RETURN NORMALLY

;HERE IS LOOP TO CONVERT CHARACTER BY CHARACTER.
;IT IS CALLED WITH A PUSHJ AND RETURNS WITH POPJ, LEAVING THE
;STACK IN ITS ORIGINAL CONDITION.

CVI.SL:	IDIVI	T4,12		;GET A DIGIT
	HRLM	T4+1,(STACK)	;STACK IT
	ADDI	Q2,1		;COUNT THE DIGIT
	SKIPE	T4		;ALL DONE?
	PUSHJ	STACK,CVI.SL	;NO -- RECURSE
	HLRZ	T4,(STACK)	;YES GET BACK IN REVERSE ORDER
	ADDI	T4,"0"		;MAKE IT ASCII
	IDPB	T4,IGNOQ##	;DEPOSIT IT
	POPJ	STACK,		;AND UNWIND

;HERE ON ZERO STRING

CVI.SZ:	MOVEI	T4,"0"		;LOAD A '0'
	IDPB	T4,IGNOQ##	;DEPOSIT IT
	MOVEI	Q2,1		;ONE CHARACTER
	HLRZ	T3,-1(STACK)	; Get datatype
	CAIE	T3,RDT		; REAL?
	 JRST	CVI.S3		; No, return
	MOVEI	T4,"."		; Yes, make string "0.0"
	IDPB	T4,IGNOQ	
	MOVEI	T4,"0"
	IDPB	T4,IGNOQ
	MOVEI	Q2,3		; String is now 3 characs long.
	JRST	CVI.S3		; Return

;CONVERT TO NUMERIC

CVTNUM::CLEAR	T2,		;DATATYPE OF RESULT IS NOT YET KNOWN
	JSP	QLINK,CVCHTP	;CHECK THE TYPE OF ARG
	  JRST	CVS.M		;CONVERT STRING --> NUMERIC
	  JRST	1(TLINK)	;INTEGERS ARE NUMERIC
	  JRST	1(TLINK)	;SO ARE REALS

CVS.M:	MOVEM	TLINK,IGNOT##	;SAVE THE LINK
	JSP	TLINK,CVS.N	;CONVERT STRING TO NUMBER
	  JRST	@IGNOT##		;ERROR!!
	MOVE	TLINK,IGNOT##	;GET THE LINK BACK
	MOVE	T4,Q1		;PUT THE RESULT IN THE RIGHT AC

CVS.M1:	TLNE	T2,IDT-NUMDC	;SEE IF WE 'WANT' AN INTEGER
	JRST	CVR.I1		;YES FIX IT AND RETURN

	TLNE	T2,RDT-NUMDC	;SEE IF WE 'WANT' A REAL
	JRST	PUTON		;YES!! JUST RETURN

	HRLI	T2,RDT		;SETUP RDT
CVS.M2:	TRNN	T2,F..DEC	;DID WE GET A DECIMAL POINT?
	JRST	CVS.M3		;NO, TRY FOR AN INTEGER.
	JRST	PUTON		;A POINT AND REAL WINS.

CVS.M3:	CAML	T4,[244400,,0]	;TOO LARGE FOR AN INTEGER?
	JRST	PUTON		;YES -- ITS REAL
	HRLI	T2,IDT		;NO, GO FIX IT
	JRST	CVR.I1		;AND RETURN


;HERE TO CONVERT STRINGS TO NUMERIC
;CONVERTS STRINGS TO INTEGER,REAL (WITH 'E')


CVS.N:	MOVE	T3,-1(STACK)	;GET ADDRESS OF STRING
	TRNE	T3,-1		;NULL STRING?
	JRST	CVS.N1		;NO -- CONTINUE
	CLEARB	Q1,T4		;YES -- RETURN ZERO
	JRST	1(TLINK)	;AND RETURN

CVS.N1:	PUSH	STACK,-1(STACK)	;SAVE THESE FOR LATER
	PUSH	STACK,-1(STACK)
	JSP	QLINK,CVTPTR##	;CONVERT TO POINTER
	  0			;NO BASE
	ERROR	15		;ERROR?

	MOVEM	Z,IGNOQ		;SAVE THIS
	HRRZ	T3,(STACK)	;GET LENGTH OF STRING
	CLEAR	Q1,		;ACCUMULATE NUMBER IN Q1
CVSN99: SOJL	T3,1(TLINK)	; DECREMENT COUNT
	ILDB	T4,IGNOQ	;GET A CHARACTER
	CAIN	T4," "		; IGNORE ...
	JRST	CVSN99		; BLANKS
	CAIN	T4,"+"		;PLUS SIGN?
	JRST	CVS.N0		;YES -- IGNORE IT
	CAIE	T4,"-"		;MINUS?
	JRST	CVS.N3		;NO -- SEE IF REAL LIVE NUMBER
	TRO	T2,F..NEG	;SET NEGATIVE FLAG

;MAIN LOOP
;T3 CONTAINS NUMBER OF CHARS LEFT IN STRING
;T4 CONTAINS CURRENT CHARACTER
;Q1 CONTAINS ACCUMULATED NUMBER

CVS.N0:	JUMPLE	T3,(TLINK)	;[133] Check if only '+' or '-'
CVS.N2:	SOJL	T3,1(TLINK)	;SOS COUNT AND RETURN IF DONE
	ILDB	T4,IGNOQ	;GET THE NEXT CHARACTER
CVS.N3:	CAIL	T4,"0"		;CHECK FOR VALIDITY
	CAILE	T4,"9"		;UPPER AND LOWER BOUND
	JRST	NOTNUM		;NOT A NUMBER


CVS.N5:	TDC	T4,[233000,,60]	;DIDDLE SOME BITS AND SCALE
	FMPRI	Q1,204500	;MULTIPLY BY 10.0
	FADR	Q1,T4		;ADD IN
	JRST	CVS.N2		;AND GO BACK FOR MORE

NOTNUM:	TRNE	T2,F..ING	;STRICTLY INTEGER?
	JRST	0(TLINK)	;YES LOSE
	CLEAR	Q2,		;COUNTER FOR EXPONENT
	CAIE	T4,"D"		;[274] ALLOW A D FOR EXPONENT
	CAIN	T4,"E"		;EXPONENT?
	JRST	CVS.N8		;YES GO HANDLE IT
	CAIE	T4,"."		;POINT?
	JRST	0(TLINK)	;NO, MUST BE ILLEGAL

;NOW PICK UP FRACTIONAL PART
;Q2 COUNTS POWERS OF TEN

CVS.N6:	TRO	T2,F..DEC	;FLAG DECIMAL POINT
CVS.N7:	SOJL	T3,CVS.NH	;ANY MORE CHARACTERS?
	ILDB	T4,IGNOQ	;YUP -- GET ONE
	CAIL	T4,"0"		;MAKE SURE ITS IN RANGE
	CAILE	T4,"9"
	JRST	CVS.N8		;ITS NOT -- ONLY THING LEFT IS 'E'
	TDC	T4,[233000,,60]	;DO SOME DIDDLING
	FMPRI	Q1,204500	;SHIFT CORRECTLY
	FADR	Q1,T4		;ADD IN
	SOJ	Q2,		;ONE LESS POWER OF TEN
	JRST	CVS.N7		;GO BACK FOR ANOTHER


;HERE WE HANDLE "E"

CVS.N8:	CAIE	T4,"E"		;IS IT E?
	 CAIN	T4,"D"		;[247] D exponent ?
	  SKIPA			;[247] We have an exponent
	JRST	0(TLINK)	;NO -- ERROR
	MOVEM	Q2,CVSTO1	;SAVE PREVIOUS SCALE FACTOR
	CLEAR	Q2,		;AND CLEAR FOR NEW ONE
	SOJL	T3,0(TLINK)	;DECR COUNT
	ILDB	T4,IGNOQ	;AND GET ANOTHER CHAR.
	CAIE	T4,"-"		;MINUS SIGN?
	JRST	CVS.ND		;NO, TRY PLUS
	TRO	T2,F..NEX	;YES
	JRST	CVS.NE		;AND GO PROCESS NUMBER
CVS.ND:	CAIE	T4,"+"		;NO, PLUS SIGN?
	JRST	CVS.N9		;NO -- HOPE ITS A NUMBER
CVS.NE:	SOJL	T3,0(TLINK)	;DECR. COUNT
	SKIPA

CVS.NF:	SOJL	T3,CVS.NG	;IF WE'RE DONE, GO SCALE
	ILDB	T4,IGNOQ	;GET ANOTHER CHAR
CVS.N9:	CAIL	T4,"0"		;MAKE SURE ITS A NUMBER
	CAILE	T4,"9"
	JRST	0(TLINK)	;ITS NOT!!
	IMULI	Q2,12		;SHIFT TOTAL
	ADDI	Q2,-"0"(T4)	;ADD IN NEW NUMBER
	JRST	CVS.NF		;AND LOOP FOR ANOTHER

CVS.NG:	TRNE	T2,F..NEX	;NEGATIVE EXPONENT?
	MOVNS	Q2		;YES NEGATE IT
	ADD	Q2,CVSTO1	;ADD PREVIOUS SCALE FACTOR

CVS.NH:	JFCL	17,.+1		;CLEAR ALL FLAGS
	MOVEI	Q3,1		;SETUP INDEX TO PWRTBL
	JUMPGE	Q2,CVS.NP	;GO HANDLE POSITIVE SCALE
	MOVMS	Q2		;GET MAGNITUDE OF EXP

;HERE HANDLE NEGATIVE SCALE FACTORS

CVS.NN:	JUMPE	Q2,1(TLINK)	;EXP = 0 MEANS DONE
	TRNE	Q2,1		;IS LOW-ORDER BIT 1?
	FDVR	Q1,PWRTBL(Q3)	;YES DO DIVIDE
	JOV	0(TLINK)	;OVERFLOW MEANS ERROR
	LSH	Q2,-1		;SHIFT EXPONENT
	AOJA	Q3,CVS.NN	;ADD TO INDEX AND LOOP

;HERE HANDLE POSITIVE SCALE FACTORS
CVS.NP:	JUMPE	Q2,1(TLINK)	;0 MEANS DONE
	TRNE	Q2,1		;IF LOW-ORDER BIT IS 1
	FMPR	Q1,PWRTBL(Q3)	;THEN MULT.
	JOV	0(TLINK)	;FAIL ON OVERFLOW
	LSH	Q2,-1		;SHIFT EXPONENT
	AOJA	Q3,CVS.NP	;AND CONTINUE LOOPING


;CONVERT TO NAME

CVTNAM::HLRZ	T2,-1(STACK)	;GET DATATYPE OF ARG
	CAIN	T2,NDT		;ALREADY NAME?
	JRST	1(TLINK)	;YES JUST RETURN
	MOVEM	TLINK,CVSTOR##	;SAVE THE LINK

CVTNM1:	JSP	TLINK,CVTSTR	;CONVERT IT TO STRING
	JRST	@CVSTOR		;CAN'T BE DONE

CVTNM2:	MOVE	Z,-1(STACK)	;GET STRING DESCRIPTOR
	CAMN	Z,NULLST##	;NULL STRING?
	JRST	@CVSTOR		;NULL NAME LOSES!

CVTNM3:	JSP	TLINK,INSTAL##	;INSTALL IN SYM
	  ERROR	15		;SYSTEM ERROR
	HRLI	Z,NDT		;SET-UP NAME DESCRIPTOR
	PUSH	STACK,Z		;FIRST WORD ON STACK
	PUSH	STACK,[0]	;SECOND WORD ON STACK
	MOVE	TLINK,CVSTOR	;GET THE LINK BACK
	JRST	1(TLINK)	;AND RETURN


;COMMON SUBROUTINES

;CVCHTP -- CHECKS DTATYPE OF ARGUMENT ON STACK
;RETURN:	NO SKIP -- STRING
;		1 SKIP  -- INTEGER
;		2 SKIP  -- REAL

;IF ARGUMENT IS NDT, CONVERTS TO STRING AND TAKES STRING RETURN.
;CALLED WITH QLINK,  IF DATATYPE IS ILLEGAL, TAKE FAIL RETURN
;TO TOP LEVEL  'TLINK'

CVCHTP:	HLRZ	T3,-1(STACK)	;GET DATATYPE OF ARG
	CAIN	T3,SDT		;STRING?
	JRST	0(QLINK)	;YES NO SKIP
	CAIN	T3,IDT		;INTEGER?
	JRST	1(QLINK)	;SINGLE SKIP
	CAIN	T3,RDT		;REAL?
	JRST	2(QLINK)	;DOUBLE SKIP
	CAIE	T3,NDT		;NAME?
	JRST	0(TLINK)	;NO --FAIL BACK TO THE TOP

;HERE FALL THRU TO CONVERT NAME TO STRING

CVN.S:	SKIPE	0(STACK)	;NATURAL VARIABLE?
	JRST	0(TLINK)	;NO -- CANT CONVERT
	HRRZ	T3,-1(STACK)	;GET ADDRESS OF VBLOK
	MOVE	T4,VNAME(T3)	;GET NAME FIELD
	MOVEM	T4,-1(STACK)	;SAVE IT
	MOVE	T4,VNAME+1(T3)	;AND THE REST
	MOVEM	T4,0(STACK)	;AND SAVE THAT
	JRST	0(QLINK)	;AND RETURN


;ROUTINE TO FLOAT THE INTEGER IN Q1

FLOAT:	IDIVI	Q1,1000		;DIVIDE BY 1000
	SKIPE	Q1		;DON'T SCALE A ZERO
	TLO	Q1,244000	;MULT BY 1000 AND AND SCALE FACTOR
	TLO	Q2,233000	;SCALE REMAINDER
	FADR	Q1,Q2		;RECOMBINE
	JRST	@Z		;AND RETURN


;CVCHMG -- CHECKS MAGNITUDE OF ARGUMENT ON STACK.
;RETURNS VALUE IN T4 (ABS VAL) AND SETS NEGATIVE FLAG IF
;APPROPRITE.  SKIP RETURNS UNLESS VALUE IS ZERO.

CVCHMG:	SKIPN	T4,0(STACK)	;LOAD VALUE AND SKIP IF NON-ZERO
	  JRST	0(QLINK)	;ITS ZERO
	SKIPG	T4		;GT 0?
	TRO	T2,F..NEG	;NO -- SET NEGATIVE FLAG
	MOVMS	T4		;GET MAGNITUDE
	JRST	1(QLINK)	;AND RETURN

;PUTON AND PUTZR PUT THE RESULT ON THE STACK OVER THE
;ARGUMENT, AND RETURN FROM WHENCE WE CAME.

PUTONQ:	SKIPA	T4,Q1		;FOR A NUMBER IN Q1
PUTZR:	CLEAR	T4,		;ZERO VALUE
PUTON:	TRNE	T2,F..NEG	;IS RESULT NEGATIVE?
	MOVNS	T4		;YES NEGATE IT
	HLLZM	T2,-1(STACK)	;FIRST WORD OF DECRIPTOR
	MOVEM	T4,0(STACK)	;SECOND WORD OF DESCRIPTOR
	JRST	1(TLINK)


;CVGTBK -- ROUTINE TO SET-UP FOR CONVERT TO STRING ROUTINES.
;ALLOCATES AN SBLOK SETS UP BYTE POINTER AND CHECKS MAGNITUDE.

CVGTBK:	MOVEM	QLINK,IGNOT+2	;SAVE THE LINK
	MOVEI	Z,5		;SEE IF WE NEED GARBAGE COLLECT
	JSP	QLINK,GCOLF##
	MOVE	Z,[SBLOK,,5]	;WE WANT A 5 WORD SBLOK
	MOVEM	Z,BTCODE&BLENG(SURF) ;SETUP HEADER
	CLEARM	GCFLD(SURF)	; MAKE GC HAPPY
	MOVEI	T3,(SURF)
	HRLI	T3,SDT		;SETUP DESCRIPTOR
	MOVEM	T3,IGNOT+1	;SAVE IT FOR LATER
	ADDI	SURF,5		;MOVE DOWN SURF
	ADDI	T3,LHDR		;GET RID OF LHDR OFFSET
	HRLI	T3,440700	;SETUP A BYTE POINTER
	MOVEM	T3,IGNOQ	;AND STORE IT

CVGTB1:	JSP	QLINK,CVCHMG	;CHECK MAGNITUDE
	  JRST	CVI.SZ		;PUT A ZERO ON THE STACK
	CLEAR	Q2,		;TO COUNT CHARACTERS
	MOVEI	Q3,"-"		;SET UP A NEGATIVE SIGN
	TRNN	T2,F..NEG	;IS IT NEGATIVE?
	JRST	@IGNOT+2	;NO -- JUST RETURN
	IDPB	Q3,IGNOQ	;DEPOSIT THE SIGN
	MOVEI	Q2,1		;ADD ONE TO COUNT
	JRST	@IGNOT+2	;AND RETURN


SUBTTL	BUILT-INS AND UNARY OPERATORS

IND::	JSP	TLINK,CVTNAM	;CONVERT ARG TO NAME
	ERROR.	1,17		;NOT CONVERTIBLE
	MOVEI	P2,VAR		;VARIABLE DESCRIPTOR
	HRLM	P2,-1(STACK)	;PUT IT ON STACK
	JRST	1(PLINK)


NAME::	HLRZ	P2,-1(STACK)	;GET TYPE
	CAIE	P2,VAR		;VAR?
	JRST	NAME1		; TRY SOMETHING ELS
	MOVEI	P2,NDT
	HRLM	P2,-1(STACK)	;ITS NOW A VARIABLE
	JRST	1(PLINK)

	 ; DO THE TRAPPED VARIABLE THING

NAME1:	CAIE	P2,TVAR		; TRAPPED VAR?
	ERROR	14,8		; BAD VALUE

	MOVE	P2,0(STACK)	; LOAD ADDRESS
	JSP	SLINK,1(P2)	; CALL 1+
	JRST	FRET1##		; PASS FAIL BACK
	JRST	NAME		; TRY AGAIN



CNVRT::	CAIE	Z,3		; 3 ARGUMENTS ?
	JRST	CNVRT1		; NOPE, BETTER BE TWO

	MOVE	S1,-1(STACK)	; BETTER CHECK FOR THE...
	CAME	S1,NULLST	; NULL STRING JUST IN CASE
	JRST	CVT3		; NON-NULL 3RD ARGUMENT, GO HANDLE IT
	SUB	STACK,XWD22##	; PRUNE NULL STRING OFF THE STACK
	SUBI	Z,1		; DECREMENT NUMBER OF ARGUMENTS

CNVRT1:	CAIN	Z,2		; BETTER HAVE 2 ARGUMENTS NOW

	JSP	TLINK,CVTNAM	;CONVERT IT TO NAME
	ERROR.	1,58		;GUESS ITS AN ERROR
	HRRZ	S1,-1(STACK)	;GET ADDRESS OF VBLOK
	HLRZ	S1,VBDT(S1)	;GET ASSOCIATED DATATYPE
	JUMPE	S1,E13.68	;0 IS NOT LEGAL
	SUB	STACK,XWD22##	;GET RID OF SEC ARG
	TRZE	S1,NUMDC	;NUMERIC?
	JRST	CNVNUM		;YES GOTO ROUTINE
	ANDI	S1,DTNUM	;AND DOWN TO DATATYPE
	CAIGE	S1,MAXDTN	;IS IT LEGAL?
	SKIPN	S1		;0 ISN'T
	JRST	E13.68		;NO ITS NOT
	JRST	CNVNM1		;GO DISPATCH

CNVNUM:	ANDI	S1,DTNUM	;AND DOWN TO DATATYPE
	CAILE	S1,2		;LEGAL TYPE?
	JRST	FRET1##		;NO!!
CNVNM1:	MOVEM	PLINK,CVSTO3##	;SAVE THIS
	XCT	NUMCVT(S1)	;DISPATCH TO ROUTINE
	JRST	CNVNM2		;ERROR
	MOVE	PLINK,CVSTO3	;GET THE LINK BACK
	JRST	1(PLINK)	;AND RETURN

CNVNM2:	MOVE	PLINK,CVSTO3	;GET THE LINK BACK
	JRST	FRET1##		;AND TAKE FAIL RETURN

	 ; EXTENDED CONVERT (3 ARGUMENT VARIETY)

CVT3:	JSP	SLINK,CVTFMT##	; GET THE FORMAT
	MOVEM	Z,IGNOP##		; AND SAVE IT

	JSP	TLINK,CVTNAM	; GET VB
	ERROR.	1,58		;
	SUB	STACK,XWD22##	; POP STACK
	HRRZ	S1,1(STACK)	; ADDRESS OF VB

	HLRZ	S2,VBDT(S1)	; LOAD TYPE
	CAIE	S2,SDT		; STRING?
	JRST	CVT3.1		; NO - BRANCH

	JSP	TLINK,CVTNUM	; MAKE FIRST ARG NUMERIC
	ERROR.	1,80		; NO? GIVE ERROR
	POP	STACK,T2	; RETAIN NUMBER
	POP	STACK,Z		; GET RID OF DT

	MOVE	Z,IGNOP##		; RELOAD FORMAT
	JSP	TLINK,CVTWD##	; GET THE STRING
	JRST	0(PLINK)	; FAIL IF CAN'T
	JRST	1(PLINK)	; SUCCEED IF CAN

	 ; HERE TO CONVERT TO WORD

CVT3.1:	TRNE	S2,NUMDC	; IF NON NUMERIC
	CAIN	S2,NUMDC	; OR IF 'NUMERIC'
E13.68:	ERROR	13,68		; INDICATE ERRORJSP	TLINK,CVTSTR	; INSIST ON A STRING
	ERROR.	1,81		; OR FAIL

	MOVE	Z,IGNOP##		; RELOAD FORMAT
	JSP	TLINK,CVTDW##	; GET THE WORD
	JRST	0(PLINK)	; OR FAIL

	MOVS	S2,S2		; GET TYPE OF RESULT
	PUSH	STACK,S2	; PUSH ONTO STACK
	PUSH	STACK,Z		; PUSH RETURNED VALUE
	JRST	1(PLINK)	; AND RETURN


;DISPATCH TABLE FOR CONVERT BUILT IN

NUMCVT:	JSP	TLINK,CVTNUM
	JSP	TLINK,CVTINT
	JSP	TLINK,CVTRL
STRCVT:	JSP	TLINK,CVTSTR
	JSP	TLINK,CVTPAT##
	JSP	SLINK,CVTARY##
	JSP	PLINK,CVTEXP##
	JSP	PLINK,CODE##
	JSP	SLINK,CVTTBL##
	JSP	TLINK,CVTNAM


;POWERS OF TEN

PWRTBL:	OCT	201400000000	;1.E0
	OCT	204500000000	;1.E1
	OCT	207620000000	;1.E2
	OCT	216470400000	;1.E4
	OCT	233575360400	;1.E8
	OCT	266434157116	;1.E16
	OCT	353473426555	;1.E32


;ROUNDING TABLE

RNDTBL==.-1
	OCT	14631463140	;1 DECIMAL PLACE
	OCT	1217270240	;2
	OCT	101422340	;3
	OCT	6433340		;4
	OCT	517420		;5
	OCT	41440		;6
	OCT	3260		;7
	OCT	260		;8


	END

 1 
=e