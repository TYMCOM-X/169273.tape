	SUBTTL	Gimpel--Ma355/JDS/DRH/RCM/VB		13-April-1977

; COPYRIGHTS 1972,1973,1976,1977  STEVENS INSTITUTE OF TECHNOLOGY
; HOBOKEN, NEW JERSEY, 07030
; ALL RIGHTS RESERVED.

  ;UNIVERSALS

	SEARCH	JOBDAT		;JOB DATA AREA DEFINITIONS
	SEARCH	MACTEN		;DEC-10 COMMON MACROS
	SEARCH	UUOSYM		;TOPS10 UUO SYMBOL DEFINITIONS
	SEARCH	SNOPRM		;SITBOL PARAMETER FILE

  ;DIRECTIVES

	.DIRECT	.XTABM		;EXCLUDE TABS FROM MACRO CALLS
	SALL			;SUPPRESS MACRO EXPANSIONS
	TWOSEG	400K		;TWOSEGMENT CODE

  ;VERSION NUMBER

	SMRVER==5		;MAJOR VERSION NUMBER
	SMRMIN==0		;MINOR VERSION NUMBER
	SMREDT==207		;EDIT LEVEL
	SMRWHO==0		;CUSTOMER ARGUMENT

  ;TITLE

	TITLE.	SMR,SNOSMR,<The Streamer>

  ;SHOW UNIVERSAL VERSION NUMBERS

	SHOW.	%%JOBD		;VERSION NUMBER OF JOBDAT
	SHOW.	%%MACT		;VERSION NUMBER OF MACTEN
	SHOW.	%%UUOS		;VERSION NUMBER OF UUOSYM
	SHOW.	%%SNOP		;VERSION NUMBER OF SNOPRM

	SMRTTL			; Title
	SMRPTX			; PASS2 assembly message
	SUBTTL	Table of Contents

;		Table of Contents for The Streamer
;
;
;			   Section			      Page
;   1. Table of Contents. . . . . . . . . . . . . . . . . . .    2
;   2. REVISION HISTORY . . . . . . . . . . . . . . . . . . .    3
;   3. 1.1 STINIT - INITIALIZE STREAMING. . . . . . . . . . .    4
;   4. 1.2 STRM - STREAM FOR A SET MEMBER . . . . . . . . . .    5
;   5. 1.3 STRMC  1.4 STR.  1.5 STR.C . . . . . . . . . . . .    6
;   6. 1.6 CHECK. . . . . . . . . . . . . . . . . . . . . . .    7
;   7. 1.99 AUXILIARY CODE FOR STREAMING. . . . . . . . . . .    8
;   8. 2.1 CVTCS - CONVERT TO CHAR. SET . . . . . . . . . . .    9
;   9. 2.2 CVTCSC - CONVERT TO CHAR SET COMPLEMENTED. . . . .   10
;  10. 2.3 ORCSET - OR TWO CHAR. SETS . . . . . . . . . . . .   11
;  11. 2.99 AUXILIARY ROUTINES FOR CHARACTER SETS . . . . . .   12
;  12. 3.1 CVTPTR . . . . . . . . . . . . . . . . . . . . . .   13
	SUBTTL	REVISION HISTORY

COMMENT	\

START OF VERSION 5.
122	RENAME MODULES & CLEAN UP.
161	Removed by edit 163.
163	Remove edit 163, Fix the problem in the pattern matcher.
201	Change CVTPTR so that it skips unnessecary divide. (For speed)
207	Cleanup some of the code in SNOPL, SNOPG & SNOSMR.
\
	SUBTTL	1.1 STINIT - INITIALIZE STREAMING

;	CALLING SEQUENCE:
;		PUSH STRING DESCRIPTOR
;		JSP	TLINK,STINIT
;		ERROR	; ARG LEFT ON STACK
;		NORMAL	; STACK POPPED 

STINIT::MOVE	T2,-1(STACK)	; GET FIRST DESCRIPTOR WORD
	MOVEM	T2,SUBJ##		; STORE INTO SUBJECT
	MOVE	T3,0(STACK)	; GET 2ND DESCRIPTOR
	MOVEM	T3,SUBJ##+1	; IS 2ND WORD OF SUBJECT
	HRRZM	T3,CURSOR##	; ALSO SET CURSOR
	JSP	QLINK,CVTPTR	; CONVERT TO POINTER
	Q3			; BASE ON Q3
	JRST	0(TLINK)	; TAKE ERROR EXIT
	IBP	Z		; INCREMENT THE POINTER
	MOVEM	Z,STPTR##	; ESTABLISH THE POINTER
	JRST	1(TLINK)	; NORMAL RETURN
	SUBTTL	1.2 STRM - STREAM FOR A SET MEMBER

;	CALLING SEQUENCE
;	MOVE	S2, 1ST WORD &
;	MOVE	S3, 2ND WORD OF CHARACTER SET
;	JSP	TLINK, STRM
;	RUNNOUT -
;	NORMAL -
;		DESCRIPTOR RETURNED ON STACK
;		IN BOTH CASES

STRM::	SETOM	IGNOT##+1	; PUT FLAG IN T2 INDICATING THAT
				; THAT A VALUE IS TO BE RETURNED.
	SKIPG	CURSOR##	; TEST CURSOR FOR 0
	JRST	NULOUT		; RETURN A NULL STRING & RUNNOUT
	JSP	QLINK,CHECKQ	; IS A SET CHARACTER THERE?
	JRST	STRM1		; GO LOOK FOR A CHARACTER IN THE SET
	JRST	NULNRM		; RETURN A NULL STRING AND
				; INDICATE NORMAL RETURN
;	MERGE HERE FROM STR.
STRM1:	MOVE	T2,[TDNN S3,.-.(Q2)]	; LOAD TESTING INSTRUCTION
;	MERGE HERE FROM STRMC AND STR.C
STRM1A:	MOVEM	TLINK,IGNOT##	; SAVE LINKING REGISTER
	SKIPL	IGNOT##+1	; SKIP IF VALUE IS TO BE RETURNED
	JRST	STRM2		; IF NO VALUE IS BEING RETURNED ...
				; TAKE JUMP
	PUSH	STACK,SUBJ##	; PUSH FIRST WORD OF RETURNED VALUE
	MOVE	Z,SUBJ##+1	; LOAD OFFSET-LENGTH
	SUB	Z,CURSOR	; DETERMINE LOC. WITHIN STRING
	HRLZ	Q2,Z		; PUT RESULT IN LEFT HALF OF Q2
	ADD	Z,Q2		; ADD THIS TO ORIGINAL OFFSET
	PUSH	STACK,Z		; AND PUSH ONTO STACK
STRM2:	MOVE	Z,STPTR##	;[161] Get the byte pointer
	MOVE	Q1,CURSOR##	;[161] Load the cursor
	SOJLE	Q1,STRM4	;[163] Decrement & check for run out
	MOVE 	T1,REGLP	; LOAD THE REST OF THE ...
	DMOVE	T3,REGLP+2	;[161] Instructions into ...
				;[161] the T registers. 
	HRRI	T2,CTBITS(S2)	; PLUG ADDRESS PART OF T2
	JRST	T1		; JUMP INTO THE REGISTERS

;	THE FOLLOWING 4 LINES ARE NOT EXECUTED IN SITU 
;	BUT ARE LOADED INTO REGISTERS T1-T4

REGLP:	ILDB	Q2,Z		; GET THE NEXT BYTE
	TDNN	S3,.-.(Q2)	; SKIP IF ANY MASKED BITS ARE ON
				; THIS BECOMES A TDNE FOR COMPLEMENT SEARCHING.
	SOJG	Q1,T1		;[163] IF CURSOR IS STILL POSITIVE, GO BACK TO T1
	JRST	STRM3		; EXECUTE A RETURN TO SANITY

;	NOTE: THIS LOOP TAKES ABOUT 6.36 MICROSECONDS
;	NOT OPERATING OUT OF REGISTERS FORCES ANOTHER 
;	INSTRUCTION INTO THE LOOP (AN ADDI).  THE RESULT
;	IS 9.84 MICROSEC. OR 55% SLOWER.



STRM3:	MOVEM	Z,STPTR		; ESTABLISH NEW POINTER

;	MERGE HERE FROM 1 CHARACTER SITUATION.
STRM4:	EXCH	Q1,CURSOR	; EXCHANGE OLD CURSOR AND THE NEW
	SUB	Q1,CURSOR	; DETERMINE AMOUNT CURSOR HAS ...
				; BEEN MOVED.
	SKIPGE	IGNOT##+1	; SKIP IF VALUE IS NOT REQUIRED.
	HRRM	Q1,0(STACK)	; STORE THIS AS THE NEW LENGTH

	CAIN	Q1,1		; IS THE LENGTH = 1
	JRST	STRM6		; YES - TREAT SPECIAL

STRM5:	MOVE	TLINK,IGNOT##	; RESTORE LINKING REGISTER
	SKIPLE	CURSOR		; SKIP ON RUNNOUT
	JRST	1(TLINK)	; NORMAL RETURN
	JRST	0(TLINK)	; RUNNOUT

	 ; HERE TO TREAT THE SPECIAL CASE OF THE SINGLE CHAR.

STRM6:	SKIPL	IGNOT##+1	; SKIP IF VALUE IS REQUIRED
	JRST	STRM5		; NO - JUST GO BACK

	JSP	QLINK,CVTPTR	; POINT TO CHAR
	0			; NO BASING
	ERROR	15		; CAN'T FAIL

	ILDB	Q1,Z		; GET THE CHAR
	MOVSI	Q1,0(Q1)	; USE AS OFFSET
	HRRI	Q1,1		; LENGTH
	PUSH	STACK,$ALPHA##	; &ALPHABET HEADER
	PUSH	STACK,Q1	; 2ND DESCR WORD

	MOVE	Q3,SUBJ##	; RESTORE THINGS ...
	LDB	Q2,STPTR	; FOR CALLER
	JRST	STRM5		; REJOIN PROCESSING
;	THE CALLING SEQUENCE FOR THESE 3 ROUTINES IS THE
;	SAME AS FOR STRM EXCEPT THAT NO VALUE IS RETURNED
;	IN THE CASE OF STR. AND STR.C
;	THAT'S THEIR PURPOSE IN FACT.

	SUBTTL	1.3 STRMC  1.4 STR.  1.5 STR.C
STRMC::	SETOM	IGNOT##+1	; INDICATE VALUE IS WANTED
	SKIPG	CURSOR		; TEST CURSOR FOR 0
	JRST	NULOUT		; RETURN A NULL STRING IF SO
	JSP	QLINK,CHECKQ	; IS CHAR. IN CHAR. SET?
	JRST	NULNRM		; NO - RETURN SUCCESS
STRMC1:	MOVE	T2,[TDNE S3,.-.(Q2)]	; YES - LOAD TEST WORD
	JRST	STRM1A		; AND OFF TO JOIN STRM

STR.::	SETZM	IGNOT##+1	; ZERO OUT FLAG (NOT RETURNING A VALUE)
	SKIPG	CURSOR		; TEST CURSOR FOR 0
	JRST	0(TLINK)	; TAKE RUNNOUT IF SO
	JSP	QLINK,CHECKQ	; IS CHAR IN CHAR. SET
	JRST	STRM1		; NO - KEEP LOOKING
	JRST	1(TLINK)	; YES - RETURN SUCCESS

STR.C::	SETZM	IGNOT##+1	; ZERO OUT RETURNING-VALUE FLAG
	SKIPG	CURSOR		; TEST CURSOR FOR 0
	JRST	0(TLINK)	; TAKE RUNNOUT IF SO
	JSP	QLINK,CHECKQ	; IS CHAR IN CHAR SET
	JRST	1(TLINK)	; NO - RETURN SUCCESSFULLY
	JRST	STRMC1		; GO JOIN STRMC
	SUBTTL	1.6 CHECK

;  CALLING SEQUENCE:
;	LOAD S2 AND S3 WITH CHAR. SET DESCRIPTOR.
;	JSP	TLINK,CHECK
;	FAIL - NOT IN SET
;	SUCCESS - IS IN SET
;	
;	CHECKS NEXT CHARACTER FOR BEING A MEMBER OF THE SET IN 
;	S2 & S3

CHECK::	SKIPG	CURSOR		; IF CURSOR IS 0 ...
	JRST	0(TLINK)	; RETURN IMMEDIATELY (FAILING)
	JSP	QLINK,CHECKQ	; USE INTERNAL FORM OF CHECK
	JRST	0(TLINK)	; FAIL
	JRST	1(TLINK)	; SUCCESS
	SUBTTL	1.99 AUXILIARY CODE FOR STREAMING

;	TYPE Q VERSION OF CHECK

CHECKQ:	MOVE	Q3,SUBJ##	; BASE THE POINTER
	LDB	Q2,STPTR	; LOAD FIRST CHARACTER
	MOVE	T4,S2		; GET BASE OF CHARACTER TABLE
	ADDI	T4,0(Q2)	; ADD IN THE CHRACTER
	TDNN	S3,CTBITS(T4)	; SKIP IF CHAR IS IN SET
	JRST	0(QLINK)	; ALL ZEROS - FAIL EXIT
	JRST	1(QLINK)	; TAKE SUCCESS EXIT

;	SPECIAL RETURNS

NULOUT:	SUBI	TLINK,1		; RETURN A NULL STRING AND RUNNOUT
NULNRM:	PUSH	STACK,NULLST##	; RETURN A NULL STRING AND NORMAL RETURN
	PUSH	STACK,NULLST+1
	JRST	1(TLINK)
	SUBTTL	2.1 CVTCS - CONVERT TO CHAR. SET

;   CALLING SEQUENCE:
;	PUSH DESCRIPTOR ONTO STACK
;	JSP	TLINK,CVTCS
;	FAIL	COULDN'T CONVERT, DESCRIPTOR LEFT ON STACK
;	NORMAL RETURN - VALUE IS ON STACK TOP

CVTCS::	HLRZ	Z,-1(STACK)	; PICK UP DATATYPE
	CAIN	Z,CSDT		; SKIP IF NOT A CHAR. SET ALREADY
	JRST	1(TLINK)	; SUCCESSFUL RETURN
	CAIE	Z,SDT		; SKIP IF A STRING (NORMAL CASE)
	JRST	CCS1		; OTHERWISE TRY TO HANDLE STRANGE DT
CCS4:	SKIPN	T2,CCTBL##+1	; LOAD AND TEST CURRENT MASK
	JRST	CCS3		; MASK IS 0 - TAKE BRANCH
	HRRZ	T3,0(STACK)	; LOAD LENGTH OF STRING
	JSP	QLINK,CVTPTR	; CONVERT STRING TO POINTER
	0			; NO BASING
	JRST	CCS2		; NULL STRING EXIT
CVTLP:	ILDB	Q2,Z		; LOAD A BYTE
	ADD	Q2,CCTBL##	; ADD IN THE ADDRESS OF THE TABLE
	IORM	T2,CTBITS(Q2)	; PLUG WITH A ONE
	SOJG	T3,CVTLP	; IF MORE CHARACTERS, GO BACK

;	ENTER HERE FROM NULL STRING PROCESSING
CCS5:	PUSH	STACK,CCTBL##	; PUSH FIRST WORD
	PUSH	STACK,T2	; PUSH 2ND WORD OF DESCRIPTOR
	LSH	T2,-1		; SHIFT THE MASK
	MOVEM	T2,CCTBL##+1	; AND SET UP NEW MASK
	JRST	1(TLINK)	; AND RETURN

CCS1:	MOVEM	TLINK,CVTSAV##	; SAVE TLINK
	JSP	TLINK,CVTSTR##	; CONVERT OUR ARGUMENT IF POSSIBLE
	JRST	@CVTSAV		; ERROR - NO CONVERT
	MOVE	TLINK,CVTSAV	; RESTORE TLINK
	JRST	CCS4		; AND JOIN REGULAR PROCESSING

CCS2:	SUB	STACK,[XWD 2,2]	; REMOVE THE DESCRIPTOR
				; FROM THE STACK
	JRST	CCS5		; JOIN MAIN PROCESSING

CCS3:	JSP	T4,INITCT	; GO INITIALIZE CHAR. TABLE
	JRST	CCS4		; JOIN EARLY PROCESSING.
	SUBTTL	2.2 CVTCSC - CONVERT TO CHAR SET COMPLEMENTED

; CALLING SEQUENCE:
;	PUSH DESCRIPTOR ONTO THE STACK
;	JSP	TLINK,CVTCSC
;	FAIL	NO CONVERSION - ARG LEFT ON STACK
;	SUCCESS - CONVERTED VALUE IS LEFT ON STACK

CVTCSC::HLRZ	Z,-1(STACK)	; LOAD DT
	CAIN	Z,CSDT		; IS IT CHAR. SET?
	JRST	0(TLINK)	; NO-GO

	MOVEM	TLINK,CCSCSV##	; SAVE LINKING REGISTER
	JSP	TLINK,CVTCS	; CONVERT ARG TO CHARACTER SET
	JRST	@CCSCSV		; NO GO

	MOVE	T2,0(STACK)	; LOAD MASK
	MOVSI	T3,-^D128	; LOAD NUMBER OF BITS TO PLUG
	HRR	T3,-1(STACK)	; ALSO LOAD ADDRESS OF TABLE

	XORM	T2,CTBITS(T3)	; OR IN A 1 FOR ...
	AOBJN	T3,.-1		; EACH WORD IN THE TABLE

	MOVE	TLINK,CCSCSV	; RELOAD LINKING REGISTER
	JRST	1(TLINK)	; SUCCESSFUL RETURN
	SUBTTL	2.3 ORCSET - OR TWO CHAR. SETS

;  CALLING SEQUENCE:
;	PUSH 2 CHAR. SETS ONTO THE STACK
;	JSP	TLINK,ORCSET
;	RETURN - VALUE IS AT TOP OF STACK
ORCSET::
	MOVE	T2,-1(STACK)	; PICK UP HEAD OF 2ND
	CAME	T2,-3(STACK)	; COMPARE WITH HEAD OF 1ST
	JRST	ORCS1		; TAKE JUMP IF UNEQUAL
	MOVE	T3,0(STACK)	; LOAD MASK OF 2ND
	ORM	T3,2(STACK)	; OR IT INTO MASK OF FIRST
	SUB	STACK,[XWD 2,2]	; POP STACK
	JRST	0(TLINK)	; AND EXIT

;	IF THE 2 TABLES ARE DIFFERENT WE MUST MAKE A 
;	NEW ENTRY IN TE
;	NEW ENTRY IN THE CURRENT CHARACTER TABLE (CCTBL).
;	DURING THIS CONSTRUCTION THE FOLLOWING REGISTERS WILL 
;	HAVE SIGNIFICANCE.
;	T1, Q1 = TABLE AND MASK OF 1ST ARGUMENT
;	T2, Q2 = TABLE AND MASK OF 2ND ARGUMENT
;	T3, Q3 = TABLE AND MASK OF 3RD ARGUMENT
;	T3(LEFT) = A COUNT

ORCS1:	MOVEM	TLINK,T4	; SAVE LINKING REG
	SKIPN	Q3,CCTBL+1	; LOAD AND TEST NEW MASK
	JRST	ORCS3		; GO MAKE NEW TABLE
	MOVE	T3,CCTBL##	; LOAD NEW TABLE
	HRLI	T3,-^D128	; PUT NEG. COUNT INTO T3 LEFT
	POP	STACK,Q2	; PUT ...
	POP	STACK,T2	; CHARACTER ...
	POP	STACK,Q1	; SETS ...
	POP	STACK,T1	; INTO REGISTERS
ORCS2:
	TDNN	Q1,CTBITS(T1)	; SKIP IF FIRST CHAR. SET IS YES
	TDNE	Q2,CTBITS(T2)	; TAKE NEXT IF 2ND CHAR. SET IS YES
	IORM	Q3,CTBITS(T3)	; PLUG NEW SET IF EITHER ARE YES
	AOJ	T1,		; INCREMENT FIRST TABLE
	AOJ	T2, 		; INCREMENT 2ND TABLE
	AOBJN	T3,ORCS2	; INCREMENT 3RD TABLE, TEST AND LOOP

	  ; 	UPDATE MASK AND RETURN
	PUSH	STACK,CCTBL##	; PUSH FIRST WORD
	PUSH	STACK,Q3	; AND MASK
	LSH	Q3,-1		; SHIFT RIGHT
	MOVEM	Q3,CCTBL##+1	; STORE EVEN IF 0
	JRST	0(T4)		; TAKE SUCCESSFUL EXIT

	  ;	HERE IF THE MASK WAS 0
ORCS3::	JSP	T4,INITCT	; INITIALIZE A NEW TABLE
	JRST	ORCS1		; JOIN MAIN PROCESSING
	SUBTTL	2.99 AUXILIARY ROUTINES FOR CHARACTER SETS

;	INITCT - INITIALIZE THE CURRENT CHARACTER TABLE
;	(CALLED ONCE FOR EVERY 36 CHARACTER SETS)
;  CALLING SEQUENCE:
;	JSP	T4,INITCT

INITCT:
	MOVE	Z,[XWD  CTBLOK,^D128+LHDR]  ; LOAD 1ST WORD
	JSP	QLINK,BLOK##	; MAKE CALL TO ALLOCATE STORAGE
	ERROR	15		; IMPOSSIBLE ERROR
	POP	STACK,Z		; REMOVE WORD
	POP	STACK,CCTBL##	; GET FIRST DESCRIPTOR WORD
	MOVSI	Z,400000	; SET BIT 0 IN REG. 0
	MOVEM	Z,CCTBL##+1	; SET BIT 0 OF MASK WORD
	JRST	0(T4)		; RETURN
	SUBTTL	3.1 CVTPTR

;  CALLING SEQUENCE:
;	PUSH STRING DESCRIPTOR ONTO STACK
;	JSP	QLINK,CVTPTR
;	REG	; BASING REGISTER FOR POINTER (MAYBE 0)
;	FAIL - NULL STRING OR NONSTRING - STACK UNPOPPED
;	SUCCESS - STACK POPPED, Z CONTAINS POINTER, REG SET

CVTPTR::
	MOVE	Z,-1(STACK)	; GET TYPE AND ADDRESS
	HLRZ	Q2,Z		; GET DATATYPE IN RIGHT OF Q2
	CAIN	Q2,SDT		; SKIP IF NOT A STRING
	TRNN	Z,-1		; SKIP IF ADDRESS IS NONZERO
	JRST	1(QLINK)	; ERROR - NONSTRING OR NULL STRING
	HLRZ	Q2,(STACK)	; PICK UP BYTE OFFSET
	JUMPN	Q2,CVTPT0	; DO WE WANT TO AVOID,
	HRL	Z,0(QLINK)	; THE TERRIBLE DIVIDE INSTRUCTION?
	IOR	Z,PTR		;  YES.
	ADDI	Z,2
	JRST	CVTPT1
CVTPT0:	IDIVI	Q2,5		; CONVERT TO WORD OFFSET
	ADDI	Z,2(Q2)		; ADD IN THE WORD OFFSET TO Z
	HRL	Z,0(QLINK)	; INSERT THE AC
	IOR	Z,PTR(Q3)	; OR IN THE POINTER PART
CVTPT1:	SUB	STACK,[XWD 2,2]	; POP STACK
	SKIPN	0(QLINK)	; SKIP IF AC IS GIVEN
	JRST	2(QLINK)	; TAKE NORMAL RETURN
	MOVE	Q2,1(STACK)	; PICK UP FIRST DESCR. WORD
	SUBI	Z,0(Q2)		; DEDUCT ADDRESS FROM Z
	MOVEM	Q2,@(QLINK)	; INSERT ADDRESS INTO REG.
	JRST	2(QLINK)	; TAKE NORMAL RETURN

PTR:	POINT	7,0
	POINT	7,0,6
	POINT	7,0,13
	POINT	7,0,20
	POINT	7,0,27


	END
