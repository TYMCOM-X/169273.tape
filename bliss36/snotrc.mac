	SUBTTL	Gimpel--Ma355/JDS/DRH/MP/RCM/VB		15-Jun-76

; COPYRIGHTS 1972,1973,1976,1977  STEVENS INSTITUTE OF TECHNOLOGY
; HOBOKEN, NEW JERSEY, 07030
; ALL RIGHTS RESERVED.

  ;UNIVERSALS

	SEARCH	MACTEN		;DEC-10 COMMON MACROS
	SEARCH	SNOPRM		;SITBOL PARAMETER FILE

  ;DIRECTIVES

	.DIRECT	.XTABM		;EXCLUDE TABS FROM MACRO CALLS
	SALL			;SUPPRESS MACRO EXPANSIONS
	TWOSEG	400K		;TWOSEGMENT CODE

  ;VERSION NUMBER

	TRCVER==5		;MAJOR VERSION NUMBER
	TRCMIN==0		;MINOR VERSION NUMBER
	TRCEDT==251		;EDIT LEVEL
	TRCWHO==0		;CUSTOMER ARGUMENT

  ;TITLE

	TITLE.	TRC,SNOTRC,<Tracing Routines>

  ;SHOW UNIVERSAL VERSION NUMBERS

	SHOW.	%%MACT		;VERSION NUMBER OF MACTEN
	SHOW.	%%SNOP		;VERSION NUMBER OF SNOPRM

	TRCTTL				;Title
	TRCPTX				; PASS2 assembly message
	SUBTTL	Table of Contents

;		Table of Contents for Tracing Routines
;
;
;			   Section			      Page
;   1. Table of Contents. . . . . . . . . . . . . . . . . . .    2
;   2. REVISION HISTORY . . . . . . . . . . . . . . . . . . .    3
;   3. MISC DEFINITIONS . . . . . . . . . . . . . . . . . . .    4
;   4. PRIMARY FUNCTION
;        4.1.   STOPTR. . . . . . . . . . . . . . . . . . . .    5
;        4.2.   TRACE . . . . . . . . . . . . . . . . . . . .    5
;   5. COMMON SUBROUTINES . . . . . . . . . . . . . . . . . .    6
;   6. VALUE TRACING. . . . . . . . . . . . . . . . . . . . .   10
;   7. FUNCTION TRACING . . . . . . . . . . . . . . . . . . .   12
;   8. LABEL TRACING. . . . . . . . . . . . . . . . . . . . .   15
;   9. KEYWORD TRACING. . . . . . . . . . . . . . . . . . . .   17
;  10. PRIMARY FUNCTION
;       10.1.   ASSIGN. . . . . . . . . . . . . . . . . . . .   19
;       10.2.   DUMP. . . . . . . . . . . . . . . . . . . . .   20
	SUBTTL	REVISION HISTORY

COMMENT	\

START OF VERSION 5.
122	RENAME MODULES & CLEAN UP.
131	Add code to process associated variables.
132	Fix bug in collection of Wsedim.
150	Prevent labels from becoming undefined.  The wrong AC
	was being used for indexing.
152	Save more info about traces.
224	Third argument to TRACE is converted to string,
	it shoould not be.  Fix it.
225	Fix typo
251	Add missing PORTAL
\
	SUBTTL	MISC DEFINITIONS

TRFL==XERRF##		;TRACE FILE SAME AS ERROR FILE
	SUBTTL	PRIMARY FUNCTION -- STOPTR

STOPTR::CLEARM	IGNOP##+3		; FLAG ENTRY
	JRST	TRACE2		; JOIN COMMON PROCESSING


	SUBTTL	PRIMARY FUNCTION -- TRACE

TRACE::	SETOM	IGNOP##+3		; FLAG ENTRY
	MOVEI	T1,^D1000	; BOOST ...
	ADDM	T1,$TRACE##	; # OF TRACE REQUESTS

	MOVE	P2,Z		; # OF ARGS

TRAC.A:	CAIG	P2,1		; LOOP TO REMOVE UNNECESSARY NULLS
	JRST	TRAC.B		; BUT ONLY FOR LAST 3 ARGUMENTS

	MOVE	Z,-1(STACK)	; CHECK FOR THE NULL STRING...
	CAME	Z,NULLST##	; AS AN ARGUMENT
	JRST	TRAC.B		; QUIT IF WE HAVE OTHER THAN NULL STRING

	SUB	STACK,XWD22##	; OTHERWISE PRUNE STACK AND...
	SOJA	P2,TRAC.A	; ADJUST NUMBER OF ARGUMENTS

TRAC.B:	MOVE	Z,[TRBLOK,,6]	; ALLOCATE
	CAIN	P2,4		; A
	HRRI	Z,12		; TRACE
	CAIN	P2,3		; BLOK
	HRRI	Z,10		; OF
	JSP	QLINK,BLOK##	; SIZE
	ERROR	15		; DEPINDING
	POP	STACK,FLAP##+1	; ON 
	POP	STACK,FLAP##	; # OF ARGUMENTS

	JRST	@<TRTBL-1>(P2)	; FAN OUT

TRTBL:	EXP	TRACE1,TRACE2,TRACE3,TRACE4

	 ; 4TH ARGUMENT

TRACE4:	JSP	TLINK,CVTNAM##	; INSIST
	ERROR.	1,104		; ON
	SKIPE	0(STACK)	; NATURAL
	ERROR.	1,104		; VARIABLE

	MOVE	S1,FLAP##		; STORE
	POP	STACK,TRFUNC+1(S1) ; INTO TRFUNC
	POP	STACK,TRFUNC(S1) ; FIELD OF TRBLOK

	 ; 3RD ARGUMENT

TRACE3:	MOVE	S1,FLAP##	;[224] STORE
	POP	STACK,TRTAG+1(S1) ; INTO TRTAG
	POP	STACK,TRTAG(S1)	; FIELD OF TRBLOK

	 ; HERE FROM STOPTR ENTRY

TRACE2:	JSP	TLINK,CVTSTR	; 2ND ARG
	ERROR.	1,102		; MUST BE STRING

	HRRZ	P2,0(STACK)	; NULL STRING?
	JUMPN	P2,TRC2.2	; JUMP IF NOT
	SUB	STACK,XWD22##	; POP STACK IF SO

	 ; HERE FROM ONE ARGUMENT CASE

TRACE1:	MOVEI	S2,"V"		; ASSUME VALUE
	JRST	TRC2.3		; JOIN PROCESSING

	 ; HERE IF 2ND ARG WAS NONNULL

TRC2.2:	JSP	QLINK,CVTPTR##	; GET
	0
	ERROR	15		; FIRST
	ILDB	S2,Z		; CHARACTER

TRC2.3:	JSP	TLINK,CVTNAM	; INSIST THAT FIRST
	ERROR.	1,101		; ARG. BE NAME

	MOVE	S1,FLAP##		; ADDR OF TRBLOK
	SKIPN	IGNOP##+3		; TRACE?
	MOVEI	S1,FLAP##+2-TRNAME ; NO, PUT IT IN FLAP##+2

	POP	STACK,TRNAME+1(S1) ; NAME
	POP	STACK,TRNAME(S1) ; INTO TRBLOK

	MOVE	P2,1(STACK)	; GET ADDRESS
	ADD	P2,2(STACK)	; OF VARIABLE

	CAIN	S2,"V"		; VALUE TRACING?
	JRST	TRC2.4		; YES, GO ON
	SKIPE	2(STACK)	; NATURAL VARIABLE?
	ERROR	13,53		; NO - COMPLAIN
	 ; 
	 ; HERE TO TABLE OFF TO CORRECT ROUTINE

TRC2.4:	CAIN	S2,"V"
	JRST	TRCVAL
	CAIN	S2,"F"
	JRST	TRCFUN
	CAIN	S2,"L"
	JRST	TRCLAB
	CAIN	S2,"K"
	JRST	TRCKEY
	CAIN	S2,"R"
	JRST	TRCRET
	CAIN	S2,"C"
	JRST	TRCCAL
	ERROR	13,60


	SUBTTL	COMMON SUBROUTINES

	 ;------------------------------------------------------
	 ; BARS - (BAR TENDER)
	 ; CALLING SEQUENCE:
	 ;	JSP	SLINK,BARS
	 ;	RETURN

BARS:	PUSH	STACK,SYSTR##	; PUSH
	PUSH	STACK,S.BAR##	; ONE BAR
	MOVE	Z,$FNCLV##	; REQUEST FOR &FNCLEVEL OF THESE
	ADD	Z,BARINC##	; ADD ANY INCREMENT
	CLEARM	BARINC		; ERASE THE INCREMENT
	SKIPGE	Z		; BEWARE OF NEGATIVES.
	ERROR	15		; SIGNAL ERROR
	JSP	TLINK,DUPLI##	; DUPLICATION
	JFCL			; CAN'T ERR
	JRST	0(SLINK)	; RETURN

	 ;------------------------------------------------------
	 ; IMAGE - A ROUTINE TO COMPUTE THE
	 ; PRINTABLE IMAGE OF A DESCRIPTOR.
	 ; CALLING SEQUENCE:
	 ; 	LOAD Q2 WITH ADDRESS OF DESCRIPTOR
	 ;	JSP	SLINK,IMAGE
	 ;	RETURN

IMAGE::	JSP	QLINK,LOCVAL##	; POINT TO VALUE

	HLRZ	Q1,0(Q2)	; GET DT
	PUSH	STACK,0(Q2)	; PUSH VALUE
	PUSH	STACK,1(Q2)	; ONTO STACK
	MOVEM	SLINK,LNCLSV##	; SAVE RETURN

	CAIN	Q1,ADT		; IS IT AN ARRAY
	JRST	IMAG.A		; PROCESS ARRAY
	CAIN	Q1,SDT		; IS IT A STRING
	JRST	IMAG.S		; PROCESS STRING
	CAIN	Q1,DDT		; IS IT DEFINED?
	JRST	IMAG.D		; PROCESS DEFINE TYPE
	CAIN	Q1,TDT		; TABLE?
	JRST	IMAG.T		; YES

	JSP	TLINK,CVTSTR	; TRY CONVERTING TO STRING
	JSP	QLINK,DTNAME##	; FAIL, THEN USE DT
	JRST	0(SLINK)	; AND RETURN.
IMAG.S:	JSP	SLINK,LINE.##	; SANDWICH
	XWD	0,3		; THE
	XWD	SDT,["'",,1]	; STRING
	XWD	STACK,1		; BETWEEN
	XWD	SDT,["'",,1]	; QUOTES

	JRST	@LNCLSV		; AND RETURN

IMAG.A:	MOVE	S3,-1(STACK)	; GET ADDR OF ABLOK
	JSP	QLINK,DTNAME	; CONVERT TO NAME (ARRAY)

	PUSH	STACK,APROTO(S3) ; PUSH PROTOTYPE
	PUSH	STACK,APROTO+1(S3) ; ONTO STACK

	HLRZ	T1,AHASH(S3)	; RETRIEVE ID #
IMA.A1:	PUSH	STACK,[IDT,,0]	; AND PUSH IT
	PUSH	STACK,T1	; ONTO STACK

	JSP	SLINK,LINE.	; LET LINE. COMPOSE THE IMAGE
	XWD	0,6		; 6 ARGUMENTS
	XWD	STACK,3		; ARRAY
	XWD	SDT,["(",,1]	;  (
	XWD	STACK,2		;  PROTOTYPE
	XWD	SDT,[")",,1]	;         )
	XWD	SDT,S.NO##	;   #
	XWD	STACK,1		;  ID #

	JRST	@LNCLSV		; AND RETURN

	 ; HERE FOR DEFINED DATATYPES

IMAG.D:	MOVE	S3,-1(STACK)	; ADDR OF DBLOK
	JSP	QLINK,DTNAME	; FIND ITS NAME
	HLRZ	T1,DHASH(S3)	; GET ITS ID #

IMA.D1:	PUSH	STACK,[IDT,,0]	; AND PUSH IT
	PUSH	STACK,T1	; ONTO THE STACK

	JSP	SLINK,LINE.	; COMPOSE A STRING
	XWD	0,3		; 3 ARGUMENTS
	XWD	STACK,2		;  DT NAME
	XWD	SDT,S.NO	;     #
	XWD	STACK,1		;   <ID #>

	JRST	@LNCLSV		; AND RETURN

	 ; HERE FOR TABLES

IMAG.T:	MOVE	S3,-1(STACK)	; SAVE ADDR OF TBLOK
	JSP	QLINK,DTNAME	; GET NAME
	HLRZ	T1,THASH(S3)	; AND ITS HASH NO
	PUSH	STACK,[IDT,,0]	; GET
	HRRZ	T2,TNBUCK(S3)	; PROTO-
	PUSH	STACK,T2	; TYPE
	JRST	IMA.A1		; JOIN ARRAY PROCESSING


	 ;------------------------------------------------------
	 ; TIMECL (TIME CLAUSE) PRODUCES THE MESSAGE:
	 ;     TIME =  <TIME>

	 ; CALLING SEQUENCE:
	 ; 	JSP	SLINK,TIMECL
	 ;	RETURN		; STRING LEFT ON STACK

TIMECL:	MOVEM	SLINK,LNCLSV	; SAVE LINK

	JSP	QLINK,MSTIME##	; GET THE TIME
	SUB	Z,TIME.C##	; SINCE END OF 
	MOVEM	Z,TR.TIM##	; COMPILATION

	JSP	SLINK,LINE.	; PREPARE
	XWD	0,2		; THE
	XWD	SDT,S.TIME##	; TIME
	XWD	IDT,TR.TIM	; CLAUSE

	JRST	@LNCLSV		; RETURN

	 ;------------------------------------------------------
	 ; TRCALL (TRACE CALL) IS USED AS AN INITIAL
	 ; PART OF EVERY TRACE EFFORT.  SIDE EFFECTS INCLUDE
	 ; UPDATING &TRACE.
	 ; CALLING SEQUENCE:
	 ;	LOAD T2 WITH ADDRESS OF TRBLOK
	 ; 	JSP	TLINK,TRCALL
	 ;	NO TRACE  (&TRACE LE 0)
	 ; 	NO FUNC   (SIZE TRBLOK LT ^D10)
	 ;	FUNC CALLED

TRCALL::SKIPG	$TRACE##	; &TRACE ON?
	JRST	0(TLINK)	; NO

	SOS	T4,$TRACE##	; DECREMENT $TRACE

	JUMPE	T2,1(TLINK)	; ZERO MEANS NO FUNCTION
	HRRZ	T3,BLENG(T2)	; GET LENGTH OF BLOK
	CAIG	T3,TRFUNC	; FUNCTION THERE?
	JRST	1(TLINK)	; NO

	CLEARM	BARINC		; WIPE OUT BAR INCREMENT
	CLEARM	$TRACE##	; CLEAR &TRACE
	PUSHR	PST		; SAVE OUR STATE
	PUSHSA	MIPS		;[152] on the stack

	PUSH	STACK,TRNAME(T2)	; PUSH
	PUSH	STACK,TRNAME+1(T2)	; NAME
	PUSH	STACK,TRTAG(T2)		; AND
	PUSH	STACK,TRTAG+1(T2)	; TAG

	MOVEI	Z,2		; SET THE NUMBER OF ARGS
	MOVE	T3,TRFUNC(T2)	; GET ADDR OF VB
	MOVEI	Q1,VFUNC(T3)	; POINT TO VFUNC FIELD
	MOVEM	Q1,IGNOP##+2	; SAVE FOR &ERRPARM
	MOVE	T4,VFUNC(T3)	; GET ADDR OF FBLOK
	JSP	PLINK,FCODE(T4)	; CALL THE FUNCTION
	SKIPA			; FAILED, SO WHAT
	SUB	STACK,XWD22##	; REMOVE RETURNED VALUE

	POPSA	MIPS		;[152] Restore ...
	POPR	PST		; OUR STATE
	MOVEM	T4,$TRACE##	; RESTORE &TRACE
	JRST	2(TLINK)	; AND RETURN


	SUBTTL	VALUE TRACING

	 ; VALUE TRACING SETUP

	 ; S1 - THE TRBLOK
	 ; P2 - THE VARIABLE BLOCK

TRCVAL:	 ; FIRST REMOVE ANY OLD VALUE TRACING

	MOVE	S2,P2		; GET ADDRESS OF VARIABLE

TRCVL3:	HLRZ	S3,0(S2)	; LOAD DATATYPE
	CAIE	S3,TVAR		; TRAPPED?
	JRST	TRCVL1		; NO

	MOVE	S3,0(S2)	; ADDR OF BLOK
	HLRZ	T1,BTCODE(S3)	; TYPE
	CAIN	T1,TRBLOK	; TRACED?
	JRST	TRCVL2		; YES - GO REMOVE

	MOVEI	S2,TRVAL(S3)	; ELSE
	JRST	TRCVL3		; TRY NEXT DESCRIPTOR

TRCVL2:	HRRI	Z,0(S2)		; TRANSFER
	HRLI	Z,TRVAL(S3)	; OLD VALUE
	BLT	Z,1(S2)		; BACK

	SKIPN	IGNOP##+3		; TRACE() ?
	JRST	RETNUL##	; NO, STOPTR()
	JRST	TRCVL4		; GO ON IF YES

TRCVL1:	SKIPN	IGNOP##+3		; STOPTR?
	JRST	0(PLINK)	; YES

	 ; OLD VALUE TRACING IS NOW REMOVED
	 ; READY TO INSERT NEW TRACING

TRCVL4:
IFN FTPAV,<
	MOVE	T2,P2		; Point to variable
	MOVEI	T3,TRLVL	; GvET DEFAULT LEVEL POSITION IN TRAP CHAIN
	JSP	TLINK,FNDPOS##	; FvIND THE CORRECT POSITION IN TRAP CHAIN
	MOVE	P2,T2		; PvUT BACK IN P2
>;END OF IFN FTPAV
	MOVE	Q1,0(P2)	; LIFT
	MOVE	Q2,1(P2)	; OLD VALUE
	MOVEM	Q1,TRVAL(S1)	; MOVEM
	MOVEM	Q2,TRVAL+1(S1)	; INTO VALUE FIELD OF TRBLOK

	HRLI	S1,TVAR		; COMPOSE
	MOVEI	S2,VTRC		; TVAR
	MOVEM	S1,0(P2)	; AND MOVE
	MOVEM	S2,1(P2)	; INTO OLD DESCR.

	JRST	RETNUL		; AND RETURN



	 ; TRAPPED VARIABLE VALUE TRACING

VTRC:	JRST	TVVT1		; VALUE
	JRST	TVVT2		; NAME
	JRST	TVVT3		; ASSIGNMENT

TVVT1:	MOVE	S3,-1(STACK)	; ADDR OF TRBLOK
	SUB	STACK,XWD22##	; POP STACK
	PUSH	STACK,TRVAL(S3)	; PUSH REAL ...
	PUSH	STACK,TRVAL+1(S3) ; VALUE

	JRST	1(SLINK)	; AND RETURN

TVVT2:	MOVEI	S2,VAR		; CONSTRUCT
	HRLM	S2,-1(STACK)	; VAR
	MOVEI	S2,TRVAL	; OUT OF
	MOVEM	S2,0(STACK)	; TVAR

	JRST	1(SLINK)	; AND RETURN

	 ; ASSIGNING A VALUE TO A TRACED VARIABLE

TVVT3:	MOVE	T1,-3(STACK)	; ADDRESS OF TRBLOK
	HRLI	T1,VAR		; INDICATE VARIABLE
	PUSH	STACK,T1	; PUSH ...
	MOVEI	T2,TRVAL	; VARIABLE
	PUSH	STACK,T2	; ONTO STACK

	PUSH	STACK,-3(STACK)	; REPRODUCE 
	PUSH	STACK,-3(STACK)	; VALUE
	JSP	TLINK,ASGNVL##	; MAKE ASSIGNMENT
IFE FTPAV,<
	ERROR	15		; CAN'T FAIL
>
IFN FTPAV,<
	JRST	[SUB	STACK,XWD44##	;FAILED -- CLEAN UP STACK
		JRST	(SLINK)]	;[225] AND RETURN FAILURE
>
	SUB	STACK,XWD22##	; POP OFF VARIABLE

	 ; HERE TO DO ACTUAL TRACING

	HRRZ	T2,-3(STACK)	; CALL THE ...
	JSP	TLINK,TRCALL	; PD TRACE FUNCTION
	SKIPA			; &TRACE = 0
	JRST	VTRC1		; NO SUPPLIED

	SUB	STACK,XWD22##	; REMOVE VALUE
	JRST	1(SLINK)	; GIVE NORMAL RETURN

	 ; HERE TO SUPPLY CANNED MESSAGE

VTRC1:	ADDI	SLINK,1		; PREPARE FOR INDIRECT
	MOVEM	SLINK,SLKSAV##	; SAVE  LINK

	HRRZ	S2,-3(STACK)	; ADDR OF TRBLOK
	MOVEI	T1,TRNAME(S2)	; POINT TO NAME
	SKIPN	TRNAME+1(S2)	; NATURAL VARIABLE?
	JRST	VTRC2		; YES

	MOVE	T1,NULLST	;[224] Asume null string (tag)
	HRRZ	S3,BLENG(S2)	;[224] Is there ...
	CAIG	S3,TRTAG	;[224]  a tag ?
	 JRST	VTRC2		;[224] No

	PUSH	STACK,TRTAG(S2)	;[224] Yes - Store it
	PUSH	STACK,TRTAG+1(S2) ;[224] onto the stack
	JSP	TLINK,CVTSTR##	;[224] Convert to a string
	 JSP	QLINK,DTNAME##	;[224] Don't convert, use the datatype
	JRST	VTRC4		;[244] Continue

VTRC2:	PUSH	STACK,0(T1)	; PUSH ID WHATEVER
	PUSH	STACK,1(T1)	; IT IS.

	 ; MERGE HERE FROM KEYWORD CASE

VTRC4:	MOVEI	Q2,-3(STACK)	; GET IMAGE OF
	JSP	SLINK,IMAGE	; VALUE STILL ON STACK

	JSP	SLINK,TIMECL	; TIME CLAUSE
	JSP	SLINK,BARS	; PREFIX

	JSP	SLINK,LINE##	; PUT OUT MESSAGE
	XWD	TRFL,8		; 8 ARGUMENTS
	XWD	STACK,1		;   ! ! !
	XWD	SDT,S.STMT##	; IN STATEMENT
	XWD	IDT+6,$STNO##	;  <&STNO>
	XWD	SDT,S.CLT##	;     :
	XWD	STACK,4		;  <VARIABLE>
	XWD	SDT,S.EQL##	;      =
	XWD	STACK,3		;   <VALUE>
	XWD	STACK,2		;  , TIME = <TIME>

	SUB	STACK,XWD22##	; WIPE AWAY ORIGNAL VALUE
	JRST	@SLKSAV		; AND RETURN

	SUBTTL	FUNCTION TRACING

	 ; FUNCTON TRACING SETUP

TRCFUN:	MOVSI	S2,VRTFL!VCTFL
	JRST	TRFUN1		; JOIN COMMON PROCESSNG

TRCRET:	SKIPA	S2,[VRTFL,,0]	; LOAD RETURN FLAG
	
TRCCAL:	MOVSI	S2,VCTFL	; LOAD CALL TRACE FLAG

	 ; ALL MEET HERE

TRFUN1:	SKIPE	IGNOP##+3		; TRACE() ?
	JRST	TRCFN1		; YES

	TDNN	S2,VFLAGS(P2)	; WAS?
	JRST	0(PLINK)	; NO
	ANDCAM	S2,VFLAGS(P2)	; REST
	JRST	RETNUL##	; AND RETURN

	 ; HERE TO IMPLEMENT THE TRACE PART 

TRCFN1:	HRRZ	T2,VFUNC(P2)	; DO WE
	HLRZ	T3,BTCODE(T2)	; ALREADY HAVE
	CAIN	T3,TFBLOK	; A TFBLOK
	JRST	TRCFN2		; YES

	MOVE	Z,[TFBLOK,,8]	; ALLOCATE
	JSP	QLINK,BLOK	; A TFBLOK
	ERROR	6,1		; OR OVERFLOW
	POP	STACK,Z		; JUNK
	POP	STACK,T2	; ADDRESS OF

	HRRZ	T1,VFUNC(P2)	; RETRIEVE FBLOK
	HRRM	T2,VFUNC(P2)	; INSERT TFBLOK
	HRRM	T1,TFOLD(T2)	; INSERT FBLOK ADDRESS
	MOVE	Z,FFLAGS&FNARGS(T1) ; TRANSFER 
	MOVEM	Z,FFLAGS&FNARGS(T2) ; GOODIES

	move	z,[jsp p2,trcfn4##] ;[251] get the instruction
	MOVEM	Z,FCODE(T2)	; INSERT TO SIMULATE OTHER

	HRRM	P2,TFVB(T2)	; ALSO INSERT VB ADDR

TRCFN2:	IORM	S2,VFLAGS(P2)	; SET FLAGS

	MOVE	S1,FLAP##		; DO WE
	HRRZ	Q1,BLENG(S1)	; HAVE A FUNCTION
	CAIG	Q1,TRFUNC	; TO SPECIFY?
	JRST	RETNUL		; NO, JUST RETURN

	TLNE	S2,VCTFL	; CALL?
	HRRM	S1,TFCT(T2)	; YES, SET TRBLOK
	TLNE	S2,VRTFL	; RETURN?
	HRRM	S1,TFRT(T2)	; YES, SET TRBLOK

	JRST	RETNUL		; NOW RETURN



trcfn3::move	p2,tfold-fcode-1(p2) ;[251] get address of the block
	JRST	FCODE(P2)	;[251] Spring off to the code

	 ; CLMESS - WILL PRINT A CALL MESSAGE
	 ; CALLING SEQUENCE
	 ; 	LOAD Z WTH # OF ARGUMENTS
	 ;	PUSH Z ARGUMENTS ONTO STACK
	 ;	PUSH NAME OF FUNCTON ONTO STACK
	 ;	JSP  SLINK,CLMESS
	 ;	RETURN

	 ; ON RETURN Z HAS NOT BEEN CHANGED AND THE STACK
	 ; IS POPPED ONE DESCRIPTOR

CLMESS::POP	STACK,FLAS##+1	; SAVE
	POP	STACK,FLAS##	; FUNCTION NAME
	MOVE	S3,STACK	; SAVE STACK POSITION
	MOVEM	Z,S2		; SAVE # OF ARGS
	PUSHR	PS		; SAVE REGS.
	PUSH	STACK,FLAS##	; PUSH FUNCTION 
	PUSH	STACK,FLAS##+1	; NAME

	 ; PREPARE ARGUMENT LIST

	PUSH	STACK,$ALPHA##	; PUSH
	PUSH	STACK,["(",,1]	; "(" ONTO STACK

	MOVE	P1,S2		; # OF ARGUMENTS
	MOVEI	P2,1(S3)	; POINT TO JUST BEYOND LAST ARG
	SUB	P2,S2		; POINT TO ...
	SUB	P2,S2		; FIRST ARG
	JUMPE	P1,CLMES1	; JUMP IF NO ARGS

	 ; LOOP FOR PROCESSING ARGUMENTS

CLMES2:	MOVE	Q2,P2		; POINT TO DESCRIPTOR
	JSP	SLINK,IMAGE	; GET ITS IMAGE

	SOJLE	P1,CLMES3	; JUMP IF THIS IS THE LAST

	JSP	SLINK,LINE.	; COMBINE ...
	XWD	0,3		; WITH ...
	XWD	STACK,2		; REST ...
	XWD	STACK,1		; OF ARGS AND
	XWD	SDT,[",",,1]	; END WITH COMMA

	ADDI	P2,2		; POINT TO NEXT ARG
	JRST	CLMES2		; AND LOOP BACK

	 ; HERE IF NO ARGS

CLMES1:	PUSH	STACK,NULLST	; PUSH NULL ...
	PUSH	STACK,NULLST+1	; STRING

	 ; HERE UPON COMPLETION OF ARG LIST

CLMES3:	JSP	SLINK,LINE.	; JOIN
	XWD	0,3		; TGETHER
	XWD	STACK,2		; EARLY ARGS
	XWD	STACK,1		; LAST ARG
	XWD	SDT,[")",,1]	; TERMINAL ")"

	JSP	SLINK,BARS	; MAKE BARS

	SKIPGE	$FTRC##		; &FTRACE NEGATIVE?
	JRST	CLMES4		; YES, GO GIVE SHORT MESSAGE

	JSP	SLINK,TIMECL	; TIME CLAUSE

	 ; MAIN MESSAGE

	JSP	SLINK,LINE
	XWD	TRFL,8		; 8 ARGS
	XWD	STACK,2		; PREFIX
	XWD	STACK,4		; FUNCTION NAME
	XWD	STACK,3		; ARGUMENT LIST
	XWD	SDT,S.CLST##	; CALLED IN STMT
	XWD	IDT,$STNO##	;   <STNO>
	XWD	SDT,S.LEV##	; AT LEVEL
	XWD	IDT,$FNCLV	; <LEVEL #>
	XWD	STACK,1		; TME

	JRST	CLMES5		; WRAP UP

	 ; HERE TO GIVE ABBREVIATED MESSAGE

CLMES4:	JSP	SLINK,LINE
	XWD	TRFL,3
	XWD	STACK,1		; BARS
	XWD	STACK,3		; FUNCTION NAME
	XWD	STACK,2		; ARGUMENT LIST

CLMES5:	POPR	PS		; RESTORE
	MOVE	Z,S2		; CONDITONS
	JRST	0(SLINK)	; AND RETURN



	 ; RTMESS - RETURN MESSAGE
	 ; CALLING SEQUENCE:
	 ;	LOAD S2 WITH ADDRESS OF DESCR. OR 0
	 ; 	PUSH	NAME OF FUNCTION
	 ;	JSP	SLINK,RTMESS
	 ;	RETURN

RTMESS::MOVEM	SLINK,SLKSAV	; SAVE RETURN
	JUMPE	S2,RTMS1	; RETURN VALUE?

	MOVE	Q2,S2		; LOAD ARGUMENT FOR IMAGE
	JSP	SLINK,IMAGE	; CREATE THE IMAGE
	JRST	RTMS2		; JOIN COMMON PROCESSING

	 ; NO RETURN VALUE

RTMS1:	PUSH	STACK,NULLST	; THROW A 
	PUSH	STACK,NULLST+1	; NULL STRING ONTO THE STACK

RTMS2:	JSP	SLINK,BARS	; MAKE BARS
	PUSH	STACK,SYSTR	; PUSH  
	MOVE	T1,$RTNTP##	; THE
	PUSH	STACK,0(T1)	; &RTNTYPE

	JSP	SLINK,LINE.	; PUT OUT MESSAGE
	XWD	TRFL,6		; (6 ARGUMENTS)
	XWD	STACK,2		;  ! ! !
	XWD	STACK,4		;  <FNAME>
	XWD	SDT,[" ",,1]	;
	XWD	STACK,1		;  RETURN
	XWD	SDT,S.ED##	;    'ED
	XWD	STACK,3		;  <VALUE>

	SKIPL	$FTRC##		; SHORT OR LONG?
	JRST	RTMS3		; GO GIVE LONG IF POSITIVE

	JSP	SLINK,LINE	; PUT
	XWD	TRFL,1		; OUT SHORT
	XWD	STACK,1		; MESSAGE

	JRST	@SLKSAV		; AND RETURN

RTMS3:	JSP	SLINK,TIMECL	; MAKE TIME CLAUSE

	JSP	SLINK,LINE	; MAKE LONG
	XWD	TRFL,4		; MESSAGE
	XWD	STACK,2		; ORIGNAL SHORT MESSAGE
	XWD	SDT,S.STMT	; IN STMT
	XWD	IDT,$STNO	;  <STNO>
	XWD	STACK,1		;  TIME = ..

	JRST	@SLKSAV		; AND RETURN


	SUBTTL	LABEL TRACING

	 ; HERE FOR LABEL TRACING SETUP
	 ; (S1 = TRBLOK, P2 = VB)

TRCLAB:	MOVSI	T4,LTFLAG	; POISE FLAG IN PLACE
	TDNN	T4,VFLAGS(P2)	; ALREADY TRACED?
	JRST	TRCLB1		; NO

	ANDCAM	T4,VFLAGS(P2)	; ZAP OUT BIT
	MOVE	T2,VLABEL(P2)	; RESTORE
	HRR	T3,TRVAL(T2)	;[150] to 
	HRL	T3,TRVAL+1(T2)	;[150] non-
	MOVEM	T3,VLABEL(P2)	; TRACE STATUS

	SKIPN	IGNOP##+3		; STOPTR?
	JRST	RETNUL		; YES

TRCLB1:	SKIPN	IGNOP##+3		; STOPTR?
	JRST	0(PLINK)	; YES, FAIL

	IORM	T4,VFLA)	; ESTABLISH LTFLAG
	MOVE	Q1,VLABEL(P2)	; LOAD THE LABEL
	HLRZM	Q1,TRVAL+1(S1)	; INSERT OFFSET
	HRLI	Q1,CDT		; INSERT ...
	MOVEM	Q1,TRVAL(S1)	; FIRST DESCR WORD

	HRRZM	S1,VLABEL(P2)	; INSERT TRBLOK INTO VB

	JRST	RETNUL		; AND RETURN


	 ; HERE TO TRACE LABEL

	 ; CALLING SEQUENCE:
	 ;	LOAD S2 WITH ADDRESS OF VB
	 ;	JSP  SLINK,LTRC
	 ;	RETURN

LTRC::	HRRZ	T2,VLABEL(S2)	; GET ADDR OF TRBLOK
	JSP	TLINK,TRCALL	; CALL EXTERNAL FUNCTION
	SKIPA			; &TRACE WAS 0
	SKIPA			; NO EXTERNAL FUNCTION
	JRST	0(SLINK)	; JUST RETURN

	 ; HERE TO GIVE CANNED MESSAGE

	MOVEM	SLINK,SLKSAV	; SAVE LINK

	PUSH	STACK,VNAME(S2)	; PUSH NAME
	PUSH	STACK,VNAME+1(S2) ; OF LABEL

	JSP	SLINK,TIMECL	; TIME CLAUSE
	JSP	SLINK,BARS	; MAKE BARS

	JSP	SLINK,LINE	; MAKE MESSAGE
	XWD	TRFL,7		; FROM 7 ARGS
	XWD	STACK,1		;  ! ! !
	XWD	SDT,S.STMT	; IN STMT
	XWD	IDT+6,$STNO	; <&STNO>
	XWD	SDT,S.CLT	;    :
	XWD	SDT,S.TRAN##	; TRANSFER TO
	XWD	STACK,3		;  <LABEL>
	XWD	STACK,2		;  TIME = <TIME>

	JRST	@SLKSAV		; AND RETURN


	SUBTTL	KEYWORD TRACING

	 ; KEYWORD SETUP

TRCKEY:	HLRZ	T2,VKEY(P2)	; GET KEYW #
	ANDI	T2,77		; IN T2 RIGHT

	MOVEI	T3,PROTKW##(T2)	; POINT TO CORRECT ENTRY
	MOVEI	S3,TB.FNC##	; PERHAPS &FNCLEVEL
	CAIN	T2,7		; IS IT?
	JRST	TRCKY1		; YES, JUMP

	MOVEI	S3,TB.STC##	; PERHAPS &STCOUNT
	CAIN	T2,13		; IS IT?
	JRST	TRCKY1		; YES, JUMP

	MOVEI	S3,TB.STF##	; PERHAPS &STFCOUNT
	CAIN	T2,14		; IS IT?
	JRST	TRCKY1		; YES, JUMP

	MOVEI	T3,UPROKW##-40(T2) ; UNPROTECTED KEYWORD?
	MOVEI	S3,TB.ERR##	; MUST BE &ERRTYPE
	CAIN	T2,44		; BUT IS IT?
	JRST	TRCKY1		; YES, JUMP

	ERROR	13,70		; NON-TRACEABLE

	 ; HERE WITH S3 POINTING TO DESCRIPTOR FOR TRBLOK
	 ; AND WITH T3 POINTING TO KEYWORD WORD.

TRCKY1:	HLRZ	S2,0(T3)	; GET ADDRESS OF KEYWORD CELL
	SKIPN	IGNOP##+3		; STOPTR?
	JRST	TRCKY3		; YES, GO RETURN

	MOVEM	S3,1(S2)	; PUT IN ADDR OF DESCRIPTOR
	HRLI	S1,UTDT		; MAKE DATATYPE UTILITY
	MOVEM	S1,0(S3)	; PLUG AS DESCRIPTOR

	JRST	RETNUL		; RETURN NULL STRING

	 ; HERE IF JUST STOPTR

TRCKY3:	SKIPN	1(S2)		; WERE WE ALREADY TRACING
	JRST	0(PLINK)	; NO, FAIL

	CLEARM	1(S2)		; CLEAR FLAG
	CLEARM	0(S3)		; CLEAR TRBLOK
	JRST	RETNUL		; RETURN NULL STRIG


	 ; KEYWORD TRACE PROCESSING
	 ; CALLING SEQUENCE
	 ; 	JSP	SLINK,-------
	 ; 	RETURN

ETPTRC::MOVEI	S3,$ERRTP##	; &ERRTYPE
	JRST	KTRC

FNCTRC::MOVEI	S3,$FNCLV	; &FNCLEVEL
	JRST	KTRC

STCTRC::MOVEI	S3,$STCNT##	; &STCOUNT
	JRST	KTRC

STFTRC::MOVEI	S3,$STFCT##	; &STFCOUNT
	JRST	KTRC

KTRC:	MOVE	T2,1(S3)	; LOAD ADDRESS OF ...
	MOVE	T2,0(T2)	; TRBLOK
	JSP	TLINK,TRCALL	; AND TRY PD TRACE
	JRST	0(SLINK)	; &TRACE = 0
	SKIPA			; NO PD FUNCTION
	JRST	0(SLINK)	; FUNCTION WAS CALLED

	 ; HERE TO SUPPLY CANNED TRACE MESSAGE

	PUSH	STACK,[IDT,,0]	; PUSH ...
	PUSH	STACK,0(S3)	; VALUE OF KEYWORD
	MOVEM	SLINK,SLKSAV	; SAVE RETURN

	MOVE	T2,1(S3)	; ADDRESS OF ...
	MOVE	T2,0(T2)	; TRBLOK TO T2
	JUMPE	T2,[		; JUMP IF REENTER

	 PUSH	STACK,SYSTR	; PUSH
	 PUSH	STACK,S.REE##	; REENTER MESSAGE
	 CLEARM	$STCNT+1	; CLEAR &STCOUNT TRACE
	 JRST	VTRC4]		; JOIN VALUE PROCESSING

	MOVE	T3,TRNAME(T2)	; ADDRESS OF VB TO T3
	PUSH	STACK,VNAME(T3)	; INSERT NAME
	PUSH	STACK,VNAME+1(T3) ; OF KEYWORD ON STACK

	JSP	SLINK,LINE.	; PRODUCE
	XWD	0,2		; KEYWORD LOOKING THING
	XWD	SDT,["&",,1]	; &
	XWD	STACK,1		; NAME

	JRST	VTRC4		; JOIN VALUE PROCESSING

	SUBTTL	PRIMARY FUNCTION -- ASSIGN


ASGN::	JSP	TLINK,CVTVAL##	; ENSURE A VALUE
	JRST	FRET2##		; OR FAIL

	HLRZ	Z,-3(STACK)	; IS VARIABLE ...
	CAIN	Z,TVAR		; TRAPPED?
	JRST	ASGNTR		; YES

	JSP	TLINK,ASGNVL##	; JUST CALL ASSIGN FUNC
IFE FTPAV,<
	ERROR	15		;CAN'T HAPPEN
>
IFN FTPAV,<
	JRST	(PLINK)		;ASSIGNMENT FAILED
>

	JRST	1(PLINK)	; AND RETURN

ASGNTR:	MOVE	P2,-2(STACK)	; LOAD ADDRESS
	JSP	SLINK,2(P2)	; AND GO CALL FUNCTION
IFE FTPAV,<
	ERROR	15		;CAN'T HAPPEN
>
IFN FTPAV,<
	JRST	(PLINK)		;ASSIGNMENT FAILED
>
	JRST	1(PLINK)	; RETURN NORMAL

	SUBTTL	PRIMARY FUNCTION -- DUMP


DUMP::	CLEARM	SEDIM##		; KLEAN UNDA DA RUG TWO
	JSP	QLINK,GCOL##	; CLEAR OUT ALL DEAD THINGY'S
	JSP	TLINK,CVTINT##	; ENSURE AN INTEGER
	JRST	DUMPAG		; NO, MUST BE SOME AGGREGATE
	POP	STACK,IGNOP##	; SAVE ARGUMENT
	POP	STACK,Z		; IGNORE DT

	SKIPG	IGNOP##		; IGNORE DUMP?
	JRST	RETNUL		; YES

	MOVE	T1,VTABLE##	; MAKE THE SYMBOL TABLE
	SUB	T1,[-TDT,,TBUCK]	; LOOK LIKE A TABLE
	PUSH	STACK,T1	; PUSH IT ...
	PUSH	STACK,[0]	; ONTO THE STACK
	MOVE	Z,[-1,,VNAME]	; AND SORT (IN REVERSE) ON ...
	JSP	P2,VTSORT##	; THE NAMES
	SUB	STACK,XWD22##	; POP TABLE

	MOVE	P2,FLAS		; TRANSFER
	MOVEM	P2,FLAP##		; TABLE
	JSP	QLINK,NSRT1##	; AND JUNKIFY IT
	HRRZ	P2,TNBUCK(P2)	; LOAD COUNT OF ITEMS

DUMP1:	SOJL	P2,DUMP1A	; LOOP ON P2
	HRRZ	S1,FLAP##		; LOAD TBL ADDR
	ADDI	S1,TBUCK(P2)	; POINT TO BUCKET
	MOVE	S1,0(S1)	; LOAD ADDRESS FROM BUCKET
	PUSH	STACK,VNAME(S1)	; PUSH NAME ONTO ...
	PUSH	STACK,VNAME+1(S1)	; STACK

	MOVEI	Q2,VALUE(S1)	; PUT ...
	JSP	SLINK,IMAGE	; VALUE ONTO STACK

	JSP	SLINK,LINE	; PRINT THE LINE
	XWD	TRFL,3
	XWD	STACK,2
	XWD	SDT,S.TEQ##
	XWD	STACK,1

	JRST	DUMP1		; LOOP BACK

DUMP1A:	 ; HERE WHEN DONE OF LOOP

	SOSG	IGNOP##		; ORIGNAL ARG GT 1?
	JRST	RETNUL		; NO, JUST RETURN

	 ; HERE TO DUMP BLOK IN FLOATING STORE

	MOVEM	PLINK,IGNOP##+1	; SAVE LINK
	MOVE	P1,FLOOR##	; POINT TO FIRST BLOK

DUMPF:	HLRZ	P2,BTCODE(P1)	; LOAD CODE
	CAIN	P2,ABLOK	; ARRAY?
	JRST	DUMPFA		; YES, GO DUMP IT
	CAIN	P2,DBLOK	; DEFINED BLOK?
	JRST	DUMPFD		; YES, GO PROCESS IT
	CAIN	P2,TBLOK	; TABLE?
	JRST	DUMPFT		; YES

	 ; RETURN BACK HERE AFTER DUMPING

DUMPF1:	HRRZ	P2,BLENG(P1)	; GET LENGTH
	ADD	P1,P2		; ADD TO GET TO NEXT BLOK
	CAMGE	P1,SURF		; STILL BELOW SURFACE?
	JRST	DUMPF		; YES, GO BACK

	MOVE	PLINK,IGNOP##+1	; LOAD RETURN
	JRST	RETNUL		; AND RETURN

	 ; HERE IF DUMPABLE BLOK IS FOUND

DUMPFT:	HRLI	P1,TDT	; INSERT TABLE DT
	SKIPA
DUMPFA:	HRLI	P1,ADT		; AN ARRAY!
	SKIPA			; JOIN PROCESSING
DUMPFD:	HRLI	P1,DDT		; A DEFINED DATA OBJECT!
	MOVEM	P1,FLAP##		; SAVE THIS AGGREGATE
	CLEARM	FLAP##+1		; AND CLEAR OUT 2ND WORD TOO.
	PUSHSA	P		; SAVE P AREA

	PUSH	STACK,P1	; NOW PUSH ON
	PUSH	STACK,[0]	; THE AGGREGATE
	JSP	PLINK,DUMP	; AND MAKE THE RECURSIVE CALL
	ERROR	15		; THIS CAN'T HAPPEN
	SUB	STACK,XWD22##	; IGNORE RETURNED VALUE

	POPSA	P		; RESTORE OURSELVES
	HRRZ	P1,FLAP##		; THIS TELLS US WHERE WE WERE.
	JRST	DUMPF1		; JOIN REG. PROCESSING.

	 ; HERE TO DUMP A SINGLE AGGREGATE

DUMPAG:	MOVEM	P1,IGNOP##+1	; SAVE RETURN
	POP	STACK,FLAP##+3	; SAVE
	POP	STACK,FLAP##+2	; ARGUMENT
	MOVEM	STACK,IGNOP##+3	; SAVE STACK

	MOVEI	Q2,FLAP##+2	; POINT TO VALUE
	JSP	SLINK,IMAGE	; GET ITS IMAGE

	JSP	SLINK,LINE	; PUT OUT
	XWD	TRFL,1		; A BLANK
	XWD	SDT,[" ",,1]	; LINE

	JSP	SLINK,LINE	; NOW
	XWD	TRFL,1		; PUT OUT ITS
	XWD	STACK,1		; IMAGE

	HLRZ	T1,FLAP##+2	; GET THE DATATYPE
	CAIN	T1,ADT		; ARRAY?
	JRST	DUMPA		; YES
	CAIN	T1,DDT		; DEFINED?
	JRST	DUMPD		; YES
	CAIN	T1,TDT		; TABLE?
	JRST	DUMPT		; YES
  MOVEI  Q3,FLAP##+2  ; POINT TO BADNESS
	ERROR%	1,110		; BAD TYPE

	 ; THE COMPLETE ARRAY DUMPER

DUMPA:	MOVE	P2,FLAP##+2	; LOAD ABLOK ADDR
	HRRZ	S1,NSUBS(P2)	; GET # OF SUBSCRIPTS
	MOVEM	S1,IGNOP##+2	; SAVE THIS NUMBER

	ADDI	S1,SUBFAC(S1)	; COMPUTE OFFSET OF FIRST ARRAY ELEMENT
	MOVEM	S1,FLAP##+3	; SAVE IN CONVENIENT SPOT

	 ; LOOP TO PUSH SUBSCRIPTS ONTO STACK

	MOVE	S1,IGNOP##+2	; RELOAD NUMBER OF SUBSCRS.
	HRRZ	S3,FLAP##+2	; POINT TO ABLOK

DUMPA1:	HLRE	S2,SUBLBD(S3)	; GET LOWER BOUND
	HRRZ	T1,SUBDIM(S3)	; GET ITS SIZE
	HRLI	T1,IDT		; TYPE IS INTEGER
	PUSH	STACK,T1	; PUSH TYPE
	PUSH	STACK,S2	; PUSH BOUND
	ADDI	S3,2		; NEXT DIMENSION
	SOJG	S1,DUMPA1	; LOOP ON NUMBER OF SUBS.

DUMPA2:	PUSH	STACK,SYSTR	; PUSH
	PUSH	STACK,S.BLLB##	;	 " <"
	MOVE	P2,IGNOP##+2	; LOAD NUMBER OF SUBS
	HRRZ	P1,IGNOP##+3	; POINT TO STACK START

DUMPA3:	ADDI	P1,2		; CRAWL UP STACK
	PUSH	STACK,[IDT,,0]	; PUSH
	PUSH	STACK,0(P1)	; CURRENT INTEGER
	SOJLE	P2,DUMPA4	; JUMP IF THIS IS THE LAST

	JSP	SLINK,LINE.	; COMBINE
	XWD	0,3		;
	XWD	STACK,2		; ALL PREVIOUS SUBSCRIPTS
	XWD	STACK,1		; WITH THIS ONE
	XWD	SDT,[",",,1]	; AND APPEND A COMMA

	JRST	DUMPA3		; BACK FOR THE NEXT ONE

	 ; HERE TO COMBINE ALL AND PRINT

DUMPA4:	HRRZ	Q2,FLAP##+2	; POINT TO 
	ADD	Q2,FLAP##+3	; NEXT VALUE
	AOS	FLAP##+3		; AND INCREMENT
	AOS	FLAP##+3		; WHILE WE'RE HER
	JSP	SLINK,IMAGE	; GET THE IMAGE OF IT

	JSP	SLINK,LINE	; PUT OUT DUMP
	XWD	TRFL,5		; 5 ARGS
	XWD	STACK,3		; EARLY SUBSCRIPTS	
	XWD	STACK,2		; LAST SUBSCRIPT
	XWD	SDT,[">",,1]	; CLOSE OFF
	XWD	SDT,S.TEQ	;		=
	XWD	STACK,1		;	<VALUE>

	 ; HERE TO INCREMENT SUBSCRIPTS

	MOVE	S1,IGNOP##+2	; LOAD # OF SUBS
	HRRZ	S2,STACK	; TOP OF STACK

DUMPA6:	AOS	0(S2)		; INCREMENT LAST SUBSCRIPT
	SOS	T1,-1(S2)	; DECREMENT FROM SUBDIM
	TRNE	T1,-1		; WAS THIS THE LAST?
	JRST	DUMPA2		; NO, DUMP OUT NEXT.
	SOJLE	S1,DUMPA9	; BRANCH IF WE'RE OUT OF SUBS.

	 ; HERE TO INCREMENT TO NEXT HIGHER SUBSCRIPT

	HRRZ	S3,FLAP##+2	; GET
	ADDI	S3,0(S1)	; THE LOWER BOUND
	ADDI	S3,0(S1)	; OF THE CURRENT
	HRRZ	T1,SUBDIM(S3)	; SUBSCRIPT
	HLRE	T2,SUBLBD(S3)	; AS WELL AS THE DIM.
	HRRM	T1,-1(S2)	; AND RESTORE THE STACK
	MOVEM	T2,0(S2)	; TO ITS ORIGNAL STATE

	SUBI	S2,2		; BUMP TO NEXT SUBSCRIPT
	JRST	DUMPA6		; AND LOOP FOR MORE

	 ; HERE ON COMPLETION OF DUMPING

DUMPA9:	MOVE	PLINK,IGNOP##+1	; RESTORE RET. ADDR
	MOVE	STACK,IGNOP##+3	; RESTORE STACK
	JRST	RETNUL		; RETURN NULL STRING

	 ; HERE TO DUMP OUT DEFINED DATA ITEM

DUMPD:	CLEARM	IGNOP##+2		; INDICATES WHICH ITEM

DUMPD1:	AOS	S1,IGNOP##+2	; BUMP AND LOAD
	MOVE	P2,FLAP##+2	; GET ADDR OF DBLOK
	HRRZ	S2,ADFBLK(P2)	; GET ADDR OF DFBLOK
	HRRZ	S3,FNARGS(S2)	; GET NUMBER OF ARGS
	CAMLE	S1,S3		; STILL WITHIN BLOK?
	JRST	DUMPA9		; NO, RETURN

	ADD	S2,S1		; GET THE ADDRESS ...
	MOVE	T1,DFFLDS-1(S2) ; OF THE VB TO T1
	PUSH	STACK,VNAME(T1) ; AND PUSH FIELD
	PUSH	STACK,VNAME+1(T1) ; NAME

	LSH	S1,1		; DOUBLE INDEX OF ITEM
	ADDI	P2,DFLDS-2(S1)	; COMPUTE ADDRESS
	MOVEI	Q2,0(P2)	; OF VALUE INTO Q2
	JSP	SLINK,IMAGE	; AND LET IMAGE DO ITS THING

	JSP	SLINK,LINE	; PUT OUT THE LINE
	XWD	TRFL,4		; 4 ARGUMENTS
	XWD	SDT,[" ",,1]	; INDENTATION
	XWD	STACK,2		; FIELD NAME
	XWD	SDT,S.TEQ	;	 =
	XWD	STACK,1		; <VALUE>

	JRST	DUMPD1		; AND LOOP

	 ; TABLE DUMPING

DUMPT:	PUSH	STACK,FLAP##+2	; PUSH TABLE
	PUSH	STACK,FLAP##+3	; BACK ONTO STACK
	JSP	TLINK,TSEQ##	; SEQUENCE THRU EVERY ELEMENT
	JSP	QLINK,DUMPT1	; FOR EACH ONE CALL DUMPT1

	JRST	DUMPA9		; AND THEN DO FINAL WRAP UP

	 ; Q-TYPE SUBROUTINE TO PRINT OUT A TABLE ELEMENT
	 ; T4 HOLDS ADDRESS OF TEBLOK

DUMPT1:	PUSHSA	ST		; ELEVATE PRIVILEGE
	PUSHR	STQ		; TO THAT OF TYPE S

	PUSH	STACK,TEVAL(T4)	; PUSH THE
	PUSH	STACK,TEVAL+1(T4) ; VALUE

	MOVEI	Q2,TEREF(T4)	; FIND THE IMAGE OF THE 
	JSP	SLINK,IMAGE	; REFERENCE DESCR

	MOVEI	Q2,-3(STACK)	; FIND THE IMAGE OF THE
	JSP	SLINK,IMAGE	; VALUE

	JSP	SLINK,LINE	; OUTPUT THE MESSAGE
	XWD	TRFL,5		;
	XWD	SDT,S.BLLB	;	 <
	XWD	STACK,2		;	REF
	XWD	SDT,[">",,1]	;	 >
	XWD	SDT,S.TEQ	;	 =
	XWD	STACK,1		; VAL

	SUB	STACK,XWD22##	; REMOVE OLD VAL
	POPR	STQ		; RESTORE ...
	POPSA	ST		; STATE

	JRST	0(QLINK)	; AND RETURN


	END
 P@~