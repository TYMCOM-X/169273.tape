	SUBTTL	Gimpel--Ma355/JDS/DRH/MP/RCM/VB		15-Jun-76

; COPYRIGHTS 1972,1973,1976,1977  STEVENS INSTITUTE OF TECHNOLOGY
; HOBOKEN, NEW JERSEY, 07030
; ALL RIGHTS RESERVED.

  ;UNIVERSALS

	SEARCH	JOBDAT		;JOB DATA AREA DEFINITIONS
	SEARCH	MACTEN		;DEC-10 COMMON MACROS
	SEARCH	UUOSYM		;TOPS10 UUO SYMBOL DEFINITIONS
	SEARCH	SNOPRM		;SITBOL PARAMETER FILE

  ;DIRECTIVES

	.DIRECT	.XTABM		;EXCLUDE TABS FROM MACRO CALLS
	SALL			;SUPPRESS MACRO EXPANSIONS
	TWOSEG	400K		;TWOSEGMENT CODE

  ;VERSION NUMBER

	PGVER==5		;MAJOR VERSION NUMBER
	PGMIN==0		;MINOR VERSION NUMBER
	PGEDT==207		;EDIT LEVEL
	PGWHO==0		;CUSTOMER ARGUMENT

  ;TITLE

	TITLE.	PG,SNOPG,<Pattern Global Routines>

  ;SHOW UNIVERSAL VERSION NUMBERS

	SHOW.	%%JOBD		;VERSION NUMBER OF JOBDAT
	SHOW.	%%MACT		;VERSION NUMBER OF MACTEN
	SHOW.	%%UUOS		;VERSION NUMBER OF UUOSYM
	SHOW.	%%SNOP		;VERSION NUMBER OF SNOPRM

	PGTTL				; Title
	PGPTX				; PASS2 message
	SUBTTL	Table of Contents

;		Table of Contents for Pattern Global Routines
;
;
;			   Section			      Page
;   1. Table of Contents. . . . . . . . . . . . . . . . . . .    2
;   2. REVISION HISTORY . . . . . . . . . . . . . . . . . . .    3
;   3. PJOIN: BUILD COMPOSITE PATTERN BLOCK FROM 2 PATTS. . .    4
;   4. CONCATENATE PATTERNS AT TOP OF STACK . . . . . . . . .    5
;   5. BUILD ALTERNATION OF PATTERNS AT TOP OF STACK. . . . .    6
;   6. ARBNO: . . . . . . . . . . . . . . . . . . . . . . . .    7
;   7. VA SYNTHESIZE VARIABLE ASSOC PBLOKS. . . . . . . . . .    8
;   8. PPRTBL . . . . . . . . . . . . . . . . . . . . . . . .    9
;   9. MTCH . . . . . . . . . . . . . . . . . . . . . . . . .   10
;  10. SCAN:. . . . . . . . . . . . . . . . . . . . . . . . .   11
;  11. PR.EX. . . . . . . . . . . . . . . . . . . . . . . . .   12
;  12. CONST: . . . . . . . . . . . . . . . . . . . . . . . .   13
;  13. SSTPP: . . . . . . . . . . . . . . . . . . . . . . . .   14
	SUBTTL	REVISION HISTORY

COMMENT	\

START OF VERSION 5.
122	RENAME MODULES & CLEAN UP.
152	Fix possible problem with using a floating address.
	Reset the address first before using.
164	Change for unevaluated expressions being compiled out of line.
207	Clean up some of the code in here.
\

	SUBTTL	PJOIN: BUILD COMPOSITE PATTERN BLOCK FROM 2 PATTS
;	  SECONDARY-LEVEL SUBROUTINE FOR CATP AND ALT
;
PJOIN:	JSP	TLINK,CVTPAT##		;MAKE SURE RIGHT ARG OK
	ERROR.	1,25			;   IT'S NOT
	POP	STACK,FLAS##+1		;SAVE RT ARG OFF STACK
	POP 	STACK,FLAS##		;   HOLD AS FLOATING ADDRESS
		   ;NOW STACK=LFT ARG, FLAS=RT ARG
	JSP	TLINK,CVTPAT##		;MAKE SURE LEFT ARG OK
	ERROR.	1,24			;   IT'S NOT

	HRRZ	S2,-1(STACK)		;GET NEW BLOCK SIZE
	HRRZ	Z,BLENG(S2)		;   =SIZE OF LEFT ARG
	MOVE	T2,Z			;	(SAVE IT)
	HRRZ	S2,FLAS##
	HRRZ	T4,BLENG(S2)		;   +SIZE OF RT ARG (SV IN T4)
	ADDI	Z,-LPHDR(T4)		;   -LPHDR
	MOVE	S3,Z			;SAVE NEW BLOCK SIZE
	JSP	QLINK,GCOLF##		;ASSURE ENOUGH STORAGE

	  ; MOVE LEFT ARG PBLOCK INTO NEW BLOCK AS IS

	HRLZ	Z,-1(STACK)		;"FROM" ADDRESS- LEFT ARG
	HLRZ	T1,Z			;   HOLD ADDRESS
	HRR	Z,SURF			;"TO" ADDRESS- NEW BLOCK
	MOVE	S2,T2			;CALC LAST WORD+1 (ADDR)
	ADD	S2,SURF			;   OF NEW BLOCK- "LWA" +1
	BLT	Z,-1(S2)		;MOVE IT

	HRRM	S3,BLENG(SURF)		;PUT IN THE PROPER SIZE

	  ; MOVE BODY OF RT ARG PBLOK INTO NEW BLOCK

	HRRZ	T3,FLAS##		;"FROM" ADDRESS- OLD BLOCK
	MOVSI	Z,LPHDR(T3)		;   FIRST WORD TO MOVE
	HRR	Z,S2			;"TO" ADDRESS- JUST AFTER ABOVE 
					;   MOVED BLOCK
	ADDI	S2,-LPHDR(T4)		;GIVES LWA MOVE +1
	BLT	Z,-1(S2)		;   MOVE IT
;
;  NOW REGS CONTAIN:
;	T1=ADDR LFT ARG		T2=SIZE LFT ARG
;	T3=ADDR RT ARG		T4=SIZE RT ARG
;	SURF=FWA NEW BLOCK	S3=SIZE NEW BLOCK
;	S2=LWA NEW BLOCK+1

	  ; RELOCATE RIGHT ARG INTERNAL REFS

	MOVEI	Q1,-LPHDR(T4)		;CALC NO WDS IN RT ARG
	LSH	Q1,-2			;CALC NO OF NODES
	SUBI	S2,-LPHDR(T4)		;CALC ADDR FIRST NODE OF
					;   RT ARG IN NEW BLOK
	MOVEI	Z,-LPHDR(T2)		;NO OF WORDS IN LEFT BLOK
	HRL	Z,Z			;  MAKE DOUBLE RELOCATER
PJOIN1:	ADDM	Z,PALT&PSUBS(S2)	;RELOCATE NODE'S POINTERS
	ADDI	S2,PNDSZ		;   NEXT NODE ADDRESS
	SOJG	Q1,PJOIN1		;   COUNT HOW MANY

	  ;FIX UP STACK AND SURF

	HRRM	SURF,-1(STACK)		;MAKE TOP STACK ELT POINT
					;  TO NEW BLOCK
	EXCH	SURF,S2			;UPDATE SURF TO FREE LOC
					;  AFTER NEW BLOK
;
;  EXIT-
;	T1 THRU T4 ARE AS ABOVE
;	S2 = ADDRE OF NEW BLOK
;	SURF = ADDR LWA NEW BLOK+1
;
	JRST	(SLINK)


	SUBTTL	CONCATENATE PATTERNS AT TOP OF STACK
CATP::	JSP	SLINK,PJOIN		; DO PRELIM JOINING
	MOVE	Q3,PMIN(T3)		;FETCH PMIN OF RT ARG
	ADDM	Q3,PMIN(S2)		;   ADD IT TO RESULT PMIN

	  ; SET LEFT ARG SUBS'S TO RT ARG POSIT IN NEW BLOCK

	MOVEI	Q1,-LPHDR(T2)		;NO OF WORDS IN LEFT ARG
	LSH	Q1,-2			;  NO OF NODES TO DO
	MOVEI	Q2,LPHDR(S2)		;ADDR OF FIRST NODE
	MOVS	Q3,Q3			;SET UP RESID INCR IN LHS OF REG
	MOVEI	Z,EMPTY			;SET UP TEST FOR EMPTY
CATP1:	TDNE	Z,PSUBS(Q2)		;IF EMPTY,
	HRRM	T2,PSUBS(Q2)		;   SET TO RT ARG POSIT
	ADDM	Q3,PRESID(Q2)		;INC RESID BY PMIN OF RT ARG
	ADDI	Q2,PNDSZ		;NEXT NODE ADDRESS
	SOJG	Q1,CATP1		;   COUNT HOW MANY

	JRST	1(PLINK)		;ALL DONE, NORMAL EXIT

EMPTY==400000; FLAG CODE FOR EMPTY ALT/SUBS FIELD

	SUBTTL	BUILD ALTERNATION OF PATTERNS AT TOP OF STACK

ALT::	JSP	SLINK,PJOIN		;DO PRELIM JOINING
	MOVE	Z,PMIN(T3)		;PMIN OF NEW =
	CAMGE	Z,PMIN(S2)		;  MIN(PMIN/LFT, PMIN/RT)
	MOVEM	Z,PMIN(S2)

	  ; SET EMPTY ALT OF ROOT OF LEFT ARG TO RT ARG

	MOVSI	Q2,LPHDR		;INITIAL PBLOK OFFSET...ROOT
ALTPB0:	HLRZ	Q1,Q2			;THIS NODE IS AT OFFSET
	ADD	Q1,S2			;   PLUS BLOCK
	MOVE	Q2,PALT(Q1)		;LOAD THIS NODE ALT
	JUMPGE	Q2,ALTPB0		;   LOOP WHILE ALT NOT EMPTY
	HRLM	T2,PALT(Q1)	;FOUND IT- RESET TO ROOT OF RT ARG

	  ; FORM COMPOSITE PSTART

	MOVE	Z,PSTART(T1)		;ARE DATA TYPES EQUAL?
	HLRZ	Q1,Z
	XOR	Z,PSTART(T3)
	TLNE	Z,-1
	JRST	ALTPB1			;NO- DIFFERENT DATATYPES
	JUMPE	Q1,ALTPB3		;EQUAL. ARE THEY ZEROS?
	CAIE	Q1,IDT			;EQUAL. WHICH KIND?
	JRST	ALTPB2			;   JMP IF CHAR SET(NOT INT)
	MOVE	Q1,PSTART+1(T1)		;   INTEGERS.. ARE THEY EQL?
	CAMN	Q1,PSTART+1(T3)		;
	JRST	ALTPB3			;   YES, OK TO LEAVE IT

ALTPB1:	SETZM	PSTART(S2)		;NO GOOD-- HAVE TO
	SETZM	PSTART+1(S2)		;   CLEAR IT OUT
	JRST	ALTPB3

ALTPB2:	CAIE	Q1,CSDT		;NOT INT,  BETTER  BE CHAR SET
	ERROR	15,0		;SYSTEM ERROR- PSTART NE IDT, NE CSDT
	JUMPN	Z,ALTP2A		;THAT'S OK. SPECIAL EASY CASE?
	MOVE	Q1,PSTART+1(T3)		;  YES. IOR THE MASK WORDS.
	IORM	Q1,PSTART+1(S2)
	JRST	ALTPB3

ALTP2A:	PUSH	STACK,PSTART(T1)	;HAVE TO REALLY OR THE CHAR-
	PUSH	STACK,PSTART+1(T1)	;   ARACTER SETS THE HARD WAY
	PUSH	STACK,PSTART(T3)
	PUSH	STACK,PSTART+1(T3)
	JSP	TLINK,ORCSET##
	HRRZ	S1,-3(STACK)		;GET BACK OUR BLOK ADDRESS
	POP	STACK,PSTART+1(S1)	;   PUT NEW DESCR INTO
	POP	STACK,PSTART(S1)	;     RESULTANT BLOK'S PSTART

ALTPB3:	JRST	1(PLINK)		;ALL DONE-- NORMAL  EXIT

	SUBTTL	ARBNO:	SYNTHESIZE COMPOSITE PBLOK PATT
;
;  CALLING SEQUENCE:
;	  PUSH STACK, DESCR FOR PATT ARG
;	  JSP  PLINK,ARBNO##
;  RETURN:
;	  PATT ARG GONE FROM STACK, REPL BY RESULT PBLOK DESCR
;
ARBNO::	JSP	TLINK,CVTPAT##		;ARG ON TOP OF STACK CV TO PATT
	ERROR.	1,50			;   ARBNO PARAM NOT PATT
	MOVE	P2,-1(STACK)		;ASSURE SUFFICIENT STG-
	HRRZ	P2,BLENG(P2)		;   P2=PBLOK SIZE
	MOVEI	Z,2*PNDSZ(P2)		;   Z=NEW BLK SIZE(ADD 2 NILS)
	JSP	QLINK,GCOLF##		;   NOW GUARANTEE THAT MUCH
	
	  ;  MOVE PARAM PATT P INTO NEW PBLOK

	HRRZ	T2,-1(STACK)		;SAVE PARAM PATT ADD IN T2
	MOVS	Z,T2			;PARAM PATT ADDR IN Z LEFT
	HRR	Z,SURF			;NEW BLK ADDR IN Z RIGHT
	ADD	Z,OFFSET		;  OFFSET THOSE ADDRS OVER HEADS
	MOVE	T1,P2			;T1=OLD PATT BLK SIZE
	ADD	T1,Z			;ADDR OF WD AFTER END OF NEW BL
	BLT	Z,-1-LPHDR(T1)		;   NOW MOVE IT

	  ;  SET UP FIRST WORD OF NEW BLOK
	MOVE	Z,BTCODE&BLENG(T2)	;LOAD OLD BLOKHEAD
	ADDI	Z,2*PNDSZ		;   INC BY SIZE INCRMNT
	MOVEM	Z,(SURF)		;STORE IN NEW BLOK

	  ;  MOVE A FEW ZEROS AND TWO NIL BLOCKS INTO NEW PATT
	MOVEI	Z,GCFLD(SURF)		;ADDR AFTER NEW BLK HEAD
	HRLI	Z,NILBLK		;ADDR OF PROTO NIL BLOKS
	BLT	Z,PPAT-1(SURF)		;  PUT THE NILS WHERE THEY BELONG

	  ; SET UP TO RELOCATE A,S PTRS; ALSO CHG SUBS FLDS
	MOVEI	Z,-LPHDR(P2)		;PUT PBLOK SIZE IN Z
	LSH	Z,-2			;  LOOP COUNT IS SZ/4
	MOVE	T1,[XWD 2*PNDSZ,2*PNDSZ]	;INIT FOR INC INSIDE LOOP
	MOVEI	T2,NIL2			;  INIT FOR ADDR SUBST INSIDE LOOP
	MOVEI	S1,PPAT(SURF)		;  S1=FIRST LOC TO CHG
	MOVEI	S3,EMPTY		;   MORE SETUP FOR THE LOOP

ARBNO4:	ADDM	T1,PALT&PSUBS(S1)	;RELOCATE THE INTERNAL REFS
	TDNE	S3,PSUBS(S1)		;  IF SGN OF SUBS SET,
	HRRM	T2,PSUBS(S1)		;	MAKE IT POINT TO NIL2
	ADDI	S1,PNDSZ		;BUMP PATT WORD POINTER
	SOJG	Z,ARBNO4		;   AND LOOP TIL DONE

	;  UPDATE SURF AND DESCR ON STACK
	HRRM	SURF,-1(STACK)		;MAKE DESC PNT TO NE BLK
	ADDI	SURF,2*PNDSZ(P2)	;BUMP SURF BY SZ OF NEW BLK

	JRST	1(PLINK)		;RETURN OK.  WE CAN'T FAIL


NILBLK:	REPEAT	LPHDR-1,<0>		;HDR = 0 EXC SZ WD FRST
	XWD	0,SC.S		;NIL BLOCK 1  RESID/PGM
	XWD	EMPTY,NIL2		;ALT(NONE)/SUBS
	OCT	0,0			;  ARG DESCR (NONE)
	XWD	0,SC.S		;NIL BLOCK 2  RESID/PGM
	XWD	PPAT,EMPTY		;ALT(PPAT)/SUBS(NONE)
	OCT	0,0

OFFSET:	XWD	LPHDR,PPAT		;DOUBLE-ADDRESS OFFSET

NIL1==LPHDR		;REL POS OF NILBLK 1
NIL2==NIL1+PNDSZ	;REL POS OF NILBLK 2
PPAT==NIL2+PNDSZ	;REL POS OF PARAM PATT(NEWB)


	SUBTTL	VA SYNTHESIZE VARIABLE ASSOC PBLOKS
;
;	CALLING SEQUENCE:
;	   FOR OPERATION N = P . V (OR P $ V)
;	  PUSH  STK,P
;	  PUSH	STK,V
;	  JSP	PLINK,CNVA  (OR IMVA)
;	RETURN:
;	  N IS LEFT ON THE STK
;	  WE CAN'T FAIL IN THIS ENDEAVOUR
;	  THUS ALWAYS RETURN TO CALL+2
;


;	  -------------------------------
;	  IMMEDIATE VARIABLE ASSOCIATION
;	  ------------------------------

IMVA::	HRLI	PLINK,PR.IN2##		;USE IMMED NAMING NODE PRIM
	JRST	VA

;	  --------------------------------
;	  CONDTIONAL VARIABLE ASSOCIATION
;	  --------------------------------

CNVA::	HRLI	PLINK,PR.CN2##		;USE CONDIT NAMING NODE PRIM

	  ; VALIDATE AND PROCESS RIGHT ARG

VA:	HLRZ	Z,-1(STACK)	;CHECK RT ARG
	CAIE	Z,VAR		;OK IF VAR...
	CAIN	Z,TVAR		;OK IF TRAPPED VAR
	JRST	VA1		;  JP IF SO

	JSP	TLINK,CVTVAL	; INSURE A VALUE
	ERROR	15		; THIS SHOULDN'T HAPPEN
	HLRZ	Z,-1(STACK)	; GET DATATYPE
	CAIE	Z,EDT		; OK IF EXPRESSION
	ERROR	14,6		;OTHERWISE TOO BAD

VA1:	POP	STACK,FLAS##+1		;SAVE OBJECT OF ASSIGNMENT
	POP	STACK,FLAS##		;  FOR A MOMENT

	  ; VALIDATE AND PROCESS LEFT ARG

	JSP	TLINK,CVTVAL		;MAKE SURE WE HAVE VALUE
	JRST	FRET1##		; FAIL IF NOT
	JSP	TLINK,CVTPAT		;IT'S NOW ON TOP. CHK IT'S PATTERN
	ERROR.	1,38		;  WASN'T. TOO BAD.

	  ;MAKE SURE THERE'S ENOUGH ROOM

	MOVE	S1,-1(STACK)		;OBTAIN ADDR OF P
	HRRZ	S2,BLENG(S1)		;OBTAIN LENGTH OF P
	SUBI	S2,LPHDR		;  LESS HDR GIVES NWDS IN NODES
	MOVEI	Z,LPHDR+NINC(S2)	;GET TOTAL SIZE OF NEW BLK
	JSP	QLINK,GCOLF		;  ASSURE ENOUGH STG FOR NEW BLK

	  ;NEW HEADER = P'S HEADER, MOSTLY

	MOVE	S1,-1(STACK)		;HOLD ADDR OF P
	MOVS	Z,S1		;ZLEFT = P'S TOP
	HRR	Z,SURF		;ZRIGHT = N'S TOP
	BLT	Z,LPHDR-1(SURF)	;SET N'S HDR = P'S HDR
	MOVEI	Z,NINC		;BUMP SIZE OF P BY NINC
	ADDM	Z,BLENG(SURF)	;   GIVING SIZE OF N

	  ;PLACE THE TWO SPECIAL NILS AT THE TOP OF THE BLK

	MOVSI	Z,NAMN		;ZLEFT = NAMING'S NIL BLOCKS
	HRRI	Z,NN1(SURF)	;ZRIGHT=POSITION IN N BLOK
	BLT	Z,NN2+1(SURF)	;MOVE IN THE 2 NIL NODES
	HLRM	PLINK,NN2(SURF)	;SET THE PROPER KIND OF NODE2
	MOVE	Z,PMIN(SURF)	;SET RESID OF NIL1 = PMIN OF P
	HRLM	Z,PRESID+NN1(SURF)	;  THERE IT GOES
	MOVSI	Z,FLAS		;MOVE THE VAR
	HRRI	Z,NN2+PARG(SURF)	;  INTO THE ARG SPOT
	BLT	Z,NN2+PARG+1(SURF)     ;   OF NIL NODE 2

	  ;MOVE P INTO ITS POSITION IN N

	MOVSI	Z,LPHDR(S1)		;ADDR OF 1ST NODE IN P
	HRRI	Z,NPPAT(SURF)		;ADDR FOR THAT NODE IN N
	MOVEI	T1,LPHDR+NINC(S2)	;CALC ADDR OF END OF N
	ADD	T1,SURF			;  PLUS ONE
	BLT	Z,-1(T1)		;MOVE P INTO N.

	  ;RELOCATE P'S INTERNAL REFS AND
	  ;CHANGE EMPTY SUBSEQ'S TO NN2

	MOVEI	S1,NPPAT(SURF)	;ADDR OF 1ST NODE TO FIX
	LSH	S2,-2		;NUMBER OF NODES TO FIX
	MOVE	Z,[XWD 2*PNDSZ,2*PNDSZ]	;FIX NODE REFS W/THIS
	MOVEI	Q1,EMPTY		;THIS TESTS IF SUBS IS EMPTY
	MOVEI	Q2,NN2		;THIS IS WHAT EMPTY SUBS BECOMES

VA2:	ADDM	Z,PALT&PSUBS(S1)	;RELOCATE NODE REFS
	TDNE	Q1,PSUBS(S1)		;IS SUBSEQ EMPTY?
	HRRM	Q2,PSUBS(S1)		;   IF SO, CHG TO REF NIL2
	ADDI	S1,PNDSZ		;BUMP ADDR TO NEXT NODE
	SOJG	S2,VA2		;  AND COUNT NODES


	  ;FINISH UP AND LEAVE

	HRRM	SURF,-1(STACK)	;CHG DESCR ON STK TO BE N
	MOVE	SURF,T1		;  CHG SURF TO ALLOCATE N'S BLOK
	JRST	1(PLINK)		;WE ALWAYS SUCCEED.


	;  PROTOTYPE BLOK FOR THE NIL REGIONS

NN1==LPHDR		;NAME OF NAMING NILBLK 1. JUST BELOW HDR
NAMN:	XWD	0,PR.XN1##	;RESID/PROG
	XWD	EMPTY,NPPAT
	REPEAT	PNDSZ-2,<0>	;ARG SPACE
NN2==NN1+PNDSZ		;NAME OF NAMING NILBLK 2.
	XWD	0,PR.CN2## ;OR PR.IN2##	;RESID/PROG	PGM ADDR TO BE SET
	XWD	EMPTY,EMPTY	;ALT/SUBS

		; HERE GOES THE VARIABLE ARG

NPPAT==NN2+PNDSZ		;NAME OF NAMING P PATTERN
NINC==NPPAT-LPHDR		;SIZE INCREASE OVER ORIG PATT P


	SUBTTL	PPRTBL	PRIMITIVES' ADDRESSES FOR VARIOUS SCAN FAILS

	DEFINE	PPENT(X)		<;;GEN PPRTBL ENTRY
D.'X==:.-PPRTBL				;;DEFINE NEG INDEX
	IF2 , <IFNDEF PR.'X, <EXTERN PR.'X>>  ;;EXT IF NOT IN THIS PROG
	EXP	PR.'X			;;ASSEBMLE IN PRIM'S ADDR>


	PPENT	(LF)		;LENGTH FAILER
	PPENT	(EX2)		;UNEVALEX UNRECURSER
	PPENT	(EX3)		;UNEVALEX RE-RECURSER
	PPENT	(IB2)		;IMMED NAMING BACKUP
	PPENT	(CB2)		;CONDIT NAMING BACKUP
	PPENT	(XB1)		;BOTH NAMING BACKUP #1
	PPENT	(FUF)	; FULLSCAN UNANCHORED FAILURE
	PPENT	(CSF)	; CHARACTER SET SCAN FAILURE
	PPENT	(GAF)	; GLOBAL ANCHORED FAILURE
	PPENT	(GUF)	; GLOBAL UNANCHORED FAILURE
	PPENT	(AFL)	; ARB FAIL (GLOBAL)
PPRTBL:		;THIS LABEL MUST FOLLOW THE TABLE

	INTERN	D.EX3


	SUBTTL	MTCH	OVERALL CONTROLLER FOR "?" BINOP
;
;  CALLING SEQUENCE:
;	SET UP HSTACK AND NSTACK'S INITIAL VALUES
;	PUSH	STACK,DESCR FOR SUBJ STR
;	PUSH	STACK,DESCR FOR PATTERN
;	JSP	PLINK,MTCH##
;  RECURSION IS OK ONLY IF "SAVEM" IS PUSHED, RE-INITIALIZED,
;    USED, AND FINALLY POPPED BACK
;  HSR MUST ALWAYS CONTAIN THE RIGHT VALUES WHILE A MATCH IS RUNNING
;    IT IS INITIALIZED AT THE TOP OF MTCH AND MUST BE PROPERLY
;    MAINTAINED THROUGH RECURSION PROCEEDINGS
;  MTCH SAVES EXIT ADDRESS IN MADSAV(LEFT), WHICH IS A RECUR-
;    SION-PROTECTED VARIABLE.
;  MTCH SAVES INITIAL VALUE OF &FULLSCAN IN FULSAV (RIGHT),
;    WHICH IS A MATCH-RECURSION PROTECTED VARIABLE.  THUS YOU
;    CAN'T CHANGE THE VALUE OF &FULLSCAN IN THE MIDDLE OF
;    A MATCH.
;
;	RETURNS TO CALL+1 IF MATCH FAILS OR ABORTS.  ARGS POPPED.
;	RETURN TO CALL+2 WITH TVAR FOR MATCHED SUBSTR ON
;	  THE STACK IN CASE OF SUCCESS
;
;
;
;  DEDICATED USE OF IGNOP AND FLAP DURING MATCHING
;  -----------------------------------------------
;
MADSAV== IGNOP##	; (LEFT); MTCH RETURN ADDRESS
FULSAV== IGNOP##	;(RIGHT); MTCH SAMPLED-AND-HELD VALUE OF FULLSCAN
NSSAVE== IGNOP##+1	;  SAVED INIT POS OF NAME STACK
SSSAVE=IGNOP+2	;  SAVED INIT POS OF SYSTEM STACK

SUBVAR==FLAP##		;  SAVED SUBJECT OF MATCH UNDER GUISE OF VARIABLE
;
;  -----------------------------------------------
;

;
;	  FIRST, MAKE SURE RT ARG IS PATTERN
;
MTCH::	HRLZM	PLINK,MADSAV		;SAVE MATCH RET ADDR
	JSP	TLINK,CVTVAL		;GET THE VALUE OF RT ARG
	JRST	FRET2##		; FAIL IF IT FAILS
	JSP	TLINK,CVTPAT##		;  ENSURE PATTERN
	ERROR.	1,20			;    DIDN'T WORK- NOT PATT
MTCH1:	POP	STACK,Z			;HAVE A GOOD PATT ARG
	POP 	STACK,PATT##		;  PUT IT AWAY FOR LATER

	POP	STACK,SUBVAR+1	; SAVE SUBJECT
	POP	STACK,SUBVAR	; FOR LATER
	ADD	STACK,[2,,2]	; PUT IT BACK ON

MTCH1A:	JSP	TLINK,CVTVAL##		;ASSURE IT'S NOW A VALUE
	JRST	FRET1##		; FAIL IF SUBJ FAIL
	JSP	TLINK,CVTSTR##		;MAKE SURE WE HAVE A STRING TO SCAN
	ERROR.	1,19			;LEFT ARG OF MTCH NOT STRING

	CLEARM	CURSOR##		; IN CASE NULL
	JSP	TLINK,STINIT##		; INIT FOR STREAMING THRU LFT ARG
	SUB	STACK,[2,,2]	; POP VALUE
;
;	  OTHER MISCELLANEOUS SETUPS
;
	HRLI	Q1,D.GAF	; ANCHOR FAILURE TENTATIVE
	SKIPE	P2,$FULL##	; &FULLSCAN?
	MOVEI	P2,1		; YES
	HRRM	P2,FULSAV		;  AND SAVE FOR WHOLE MATCH
	MOVE	Z,CURSOR		;INIT MAX STR LENGTH
	MOVEM	Z,MAXLEN##		;  TO TOTAL STR LENGTH
	MOVE	Z,NSTACK##		;SAVE NAME STACK START POS
	MOVEM	Z,NSSAVE		;  FOR THE POST-PROCESSOR
	MOVE	HSR,HSTACK##		;INIT HIST STK REGISTER
	MOVEM	STACK,SSSAVE		;  DITTO. THUS CAN RESTORE ENVIRONS
	SKIPN	$ANCH##		; ON &ANCHOR
	SKIPN	CURSOR		; OR NULL
	JRST	MTCH4		; BYPASS THIS HACKING
;
;	  UNANCHORED SETUP -- SPECIAL CURSOR MOTION
;
MTCH2:	HRRZ	Z,FULSAV		;BYPASS SPECIAL IF FULLSCAN
	JUMPN	Z,MTCH3			;   FLAG WAS SET
	MOVE	P2,PATT			;CHECK WHERE CURSOR IS TO START LIFE
	MOVE	S3,PSTART+1(P2)		;   PICK UP ARG FOR LATER
	HLRZ	S2,PSTART(P2)		;CHECK STARTER'S DATA TYPE
	MOVSI	Q1,D.GUF	; SET FAIL AS UNANCHORED
	JUMPE	S2,MTCH4		;   NO SPECIAL STARTING POINT
	CAIN	S2,CSDT			;   TRY CHAR SET
	JRST	MTCH2A			;     YES, GO SCAN FOR IT
	MOVSI	Q1,D.GAF	; FAIL IS LIKE &ANCHOR
	JUMPGE	S3,MTCH2J		;   NO, INTEGER. OK IF POSITIVE
	ADD	S3,MAXLEN		;    NEG-RPOS/RTAB-COUNT BACKW
	ADDI	S3,1			;    THAT NEG WAS 1'S COMPL
	JUMPL	S3,PR.GAF	; JUMP IF STRING TOO SMALL
MTCH2J:SUB	S3,CURSOR		;MOVE CURSOR TO RIGHT PLACE
	JUMPG	S3,PR.GAF	; JUMP IF STRING TOO SMALL
	MOVNM	S3,CURSOR		;   SUB WAS BACKW- COMPL&STR

	ADD	S3,MAXLEN		;NOW S3=MAXLEN-CURSOR
	IDIVI	S3,5			;S3=WORDS, S3+1=BYTES
	ADDM	S3,STPTR##		;  BUMP PTR BY WORD COUNT

	SOJL	S3+1,MTCH4		;EXIT LOOP WHEN BYTE CNT LE 0
	IBP	STPTR##			;  INC BYTEWISE ONCE PER
	JRST	.-2			;  BYTE LEFTOVER AFTER WORDS DONE


MTCH2A:	MOVE	P2,PATT		; LOAD PATTERN ADDR
	MOVE	S3,PSTART+1(P2) ; LOAD MASK
	MOVE	S2,PSTART(P2)	;STREAM FOR THE CHAR SET
	JSP	TLINK,STR.##		;  THAT STARTS THIS MATCH
	JRST	PR.GAF			;NO FIND- GO FAIL

	SKIPA	Q1,[D.CSF,,0]	; BACK HERE ON FAIL

	 ; HERE IF &FULLSCAN

MTCH3:	HRLI	Q1,D.FUF	; FULLSCAN RETRY
;
;	  INIT STACK BOTTOM AND RUN THE SCAN
;
MTCH4:	HRR	Q1,CURSOR		;PLACE STACK BOTTOM
	PUSH	HSR,Q1			;  SHOWING FAILURE TYPE
	PUSH	HSR,STPTR##		;  AND RESTART POSITION

	MOVEI	Z,LPHDR			;START PATT
	MOVEM	Z,PATT+1		;  POINTING TO ROOT NODE
	SETOM	FUTILE##			;AND SET LENGTH FUTILITY ON

	JSP	P2,SCAN			;TRY THE SCAN

;	  SUCCESS RETURN

;	  MAKE UP UBLOCK SHOWING RESULT OF SUCCESS

UBLKZ==LHDR+6			;SIZE OF OUR UBLOK

	MOVEI	Z,UBLKZ			;ASSURE ENOUGH ROOM
	JSP	QLINK,GCOLF##		;  FOR A 3-DESCR UBLOK
	HRLI	Z,UTBLOK		;MAKE UP BLOK HDR
	MOVEM	Z,BTCODE&BLENG(SURF)	;  = UBLOK/SIZE
	SETZM	GCFLD(SURF)		;GARB FLD = 0
	MOVEI	Z,SSVAL(S	;POSITION OF SUBJ IN NEW BLK
	HRLI	Z,SUBJ##		;REGULAR POS OF SUBJ
	BLT	Z,SSVAL+1(SURF)		;MOVE SUBJ TO UBLK
	MOVEI	Z,SSVAR(SURF)		;POS OF SUBJ/VAR IN NEW BLK
	HRLI	Z,SUBVAR		;POS OF SUBJ/VAR NOW
	BLT	Z,SSVAR+1(SURF)		;MOVE SUBJ/VAR INTO NEW BLOK
	SETZM	<SSHEAD&SSCURS>-1(SURF)	;STR POS INDIC- WD1=0
	MOVE	Z,CURSOR		;   POS AT END OF MTCH
	MOVE	Q1,HSTACK		;   POS AT STRT OF MTCH
	HRL	Z,1(Q1)			;     KEPT ON BOTT OF HIST STK
	MOVEM	Z,SSHEAD&SSCURS(SURF)	;   PUT IT AWAY
	ADDI	SURF,UBLKZ		;AND BUMP SURF PAST THE NEW BLK

;	  MAKE UP TVAR POINTING TO UBLOK AND SSTPP

	MOVEI	Z,-UBLKZ(SURF)		;POSIT OF UBLOK
	HRLI	Z,TVAR			;  FLAG THAT VAR IS TRAPPED
	PUSH 	STACK,Z			;RETURN IT ON THE STACK
	PUSH	STACK,[XWD 0,SSTPP]	;  BOTTOM OF TVAR IS PROG ADDR

;	  PERFORM CONDITIONAL VARIABLE ASSIGNMENTS
;

	MOVE	S2,NSSAVE		;SET UP PORTION OF NAMESTACK
	HRRZ	S3,NSTACK		;  THAT WE'VE USED
	MOVEM	S2,NSTACK		;  AND RELEASE IT NOW
	HRLI	S2,0		;PNAMEL WANTS ADDRS ONLY
	JSP	SLINK,PNAMEL##		;AND GO PROCESS IT

;
;	  ALL DONE -- RETURN SUCCESS
;
	MOVE	HSR,HSTACK		;RESTORE H.S. TO ORIG CONDIT
	HLRZ	PLINK,MADSAV		;FETCH BACK OUR RETURN ADDRESS
	JRST	1(PLINK)		;  AND MAKE SUCCESS RETURN
;
;	SCAN FAILURE POINTS
;

	 ; UNANCHORED FAILURE (NON CHARACTER SET)

PR.GUF:	SKIPE	FUTILE			;  IF THE MATCH IS FUTILE,
	JRST	PR.GAF		; DIE
	
PR.FUF:	MOVE	Q1,1(HSR)	; PICK UP RETRY ADDR
	IBP	STPTR##			;BUMP STR POSIT
	SOSL	CURSOR			;  TO NEXT CHAR
	JRST	MTCH4			;  AND TRY AGAIN
	JRST	PR.GAF		; GLOBAL FAIL IF CURSOR GOES NEG

	 ; CHARACTER SET RETRY

PR.CSF:	IBP	STPTR##		; BUMP POINTER
	SOSL	CURSOR		; BUMP CURSOR
	JRST	MTCH2A		; AND TRY CHAR SET
;	JRST	PR.GAF		; DONE IF CURS GOES NEG
;	  GLOBAL SCAN FAILURE POINT -- ANCHORED FAIL/UNANCH RUNOUT
;
PR.GAF:	MOVE	Z,NSSAVE		;CLEAR OUT NAME STACK
	MOVEM	Z,NSTACK		;   TO ABORT NAMING
	MOVE	HSR,HSTACK		; RESTORE HSTACK
	HLRZ	PLINK,MADSAV		;FIND OUT WHERE TO RETURN TO
	JRST	0(PLINK)		;  GO THERE, FAIL EXIT


	SUBTTL	SCAN:	MATCH PROCESSOR FOR ONE PBLOK			
;
;   CALLING SEQUENCE:
;	SET UP PATT,HSR,FUTILE##, CURSOR,MAXLEN,STPTR##
;	JSP	P2,SCAN
;   RECURSION IS OK ONLY IF THE SCAN VARIABLES (BOTT OF "SAVEM")
;	  ARE PUSHED AND POPPED.  SEE ALSO MTCH.
;	SCAN SAVES EXIT-SUCCESS ADDRESS IN SCRAD(RIGHT),
;		WHICH IS A SCAN RECURSION-PROTECTED VARIABLE
;	RETURNS TO CALL+1 IF SUCCESSFUL MATCH
;	RETURNS TO ADDR ON HISTORY STACK IF FAIL
;
SCAN:	HRRM	P2,SCRAD##	;SAVE SUCCESS RETURN ADDRESS
SCAN0:	MOVE	P2,PATT		;SET UP PATT BLOK ADDR
	ADD	P2,PATT+1	;  PLUS NODE POS=NODE ADDR
	MOVE	Z,PALT(P2)	;  IS THERE AN ALTERNATE?
	JUMPL	Z,SCAN1		;    NO
	HRR	Z,CURSOR	;    YES-COMPOSE ALT & CURSOR
	PUSH	HSR,Z		; PUSH ALT & CURSOR TO H.S.
	PUSH	HSR,STPTR##	;    WITH THE CORRES STRING POINTER
SCAN1:	MOVE	P1,PPROG(P2)	;FETCH PRIMITIVE'S ADDR
	JRST	(P1)		;  GO RUN IT
;
;	  THE PRIMITIVE REPORTS SUCCESS
;
SC.S::	MOVE	P2,PATT		;[152] Relead pattern block address
	ADD	P2,PATT+1	;[152] Point to the current node
	HRLZ	Z,PSUBS(P2)	;IS THERE A SUBSEQ?
	HLRZM	Z,PATT+1	;  (RESET PATT NODE IN CASE)
	JUMPGE	Z,SCAN0		;  JUMP IF HAVE SUBS TO PROCESS
	HRRZ	PLINK,SCRAD	;NO SUBSEQUENT-- OVERALL SUCCESS!
	JRST	(PLINK)		;  GO BACK, TO SUCCESS EXIT
;
;	  THE PRIMITIVE REPORTS MATCH FAILURE
;
SC.MF::	SETZM	FUTILE	;NOTE THE MATCH MAY NOT BE FUTILE
;
;	  THE PRIMITIVE REPORTS LENGTH FAILURE
;
PR.LF:			;H.S. PRIMITIVE TO LENGTH-FAIL
SC.LF::	POP	HSR,STPTR##	;BACK UP TO PREV ALT POSIT
	POP	HSR,P2		;  AND RESET
	HRRZM	P2,CURSOR	;	CURSOR AND
	HLRZM	P2,PATT+1	;	PATT NODE. IS THERE A REAL ALT?
	JUMPGE	P2,SCAN0	;   YES.  GO TRY IT
	HLRE	P2,P2		;   NO.  GET FAIL ADDRESS
	JRST	@PPRTBL(P2)		;	AND GO FAIL





	SUBTTL	PR.EX	UNEVALUATED EXPRESSION PROCESSING

	  ;ENCOUNTER AN UNEVALEX NODE DURING A MATCH

PR.EX1::CLEAR	S1,
	HRRZ	S2,FULSAV		; WIPE OUT RETURN ADDR
	SKIPN	S2			; THEN ARE WE IN FULLSCAN MODE?
	HLRZ	S1,PRESID(P2)	;CHK IF RESIDUAL
	MOVE	S2,CURSOR		;  IS MORE THAN CURSOR
	SUB	S2,S1			;  HAS LEFT IN THE STRING
	JUMPL	S2,SC.LF		;JUMP IF NOT ENOUGH LEFT

	MOVEI	T2,PARG(P2)		;THAT'S OUR ARG
	JSP	TLINK,PEVAL##		;  EVALUATE IT
	JRST	SC.MF			;  WOULDN'T GO- GO FAIL

	JSP	TLINK,CVTVAL	; ENSURE A VALUE
	JRST	[SUB STACK,[2,,2]
		 JRST SC.MF]	; FAIL? THEN GIVE A MATCH FAIL



	JSP	TLINK,CVTPAT		;MAKE USRE WE GOT PATTERN
	ERROR.	1,11			;  DIDN'T.  KILL IT

	MOVE	Q3,-1(STACK)		;OK. SAVE PATT ARG IN Q3
	MOVEM	S2,CURSOR		;DECREASE TO REFLECT
	SUB	S1,MAXLEN		;  THE LIMITING RESIDUAL
	MOVNM	S1,MAXLEN		;  SUB WAS BACKW; COMPL&STR

EX1A:
	MOVE	Z,PATT			;PUT THE SCAN VARS ONTO 
	MOVEM	Z,-1(STACK)		;  SYSTEM STACK
	MOVE	Z,PATT+1		;  TO SAVE THEM
	HRL	Z,SCRAD			;  THROUGH THE
	MOVEM	Z,0(STACK)		;  SCAN RECURSION COMING

	MOVEM	Q3,PATT			;RESET SCAN VARS
	MOVEI	Q3,LPHDR		;  TO REFLECT THE
	MOVEM	Q3,PATT+1		;  NEW SITUATION

	PUSH	HSR,[XWD D.EX2,0]	;SET FAILURE POINT TO UNRECURSE
	PUSH	HSR,Z			;  DOESN'T NEED ANYTH BUT ADDR

	JSP	P2,SCAN			;TRY THIS SUB-PATTERN
EXPRET:			;SCAN'S RETURN POINT FOR THE EXPRESSION CALL

	  ;SCAN REPORTS SUCCESS

	POP	STACK,Z			;RETRIEVE SCAN VARS
	HRRZM	Z,PATT+1		;  PATTERN NODE
	HLRZM	Z,SCRAD			;  RETURN ADDRESS
	POP	STACK,P2		;  PATTERN BLOCK ADDR
	MOVE	S2,PATT		; SAVE PATTERN SUBSTITUTE
	MOVEM	P2,PATT			;    RESTORE USUAL PATT PTR
	ADD	P2,PATT+1		;  P2 IS ALWAYS THE NODE POINTER

	HRRZ	Z,FULSAV		;IF QUICKSCAN
	JUMPN	EXRA			;    MODE,
	HLRZ	S1,PRESID(P2)		;RESTORE FROM THE
	ADDM	S1,CURSOR		;  LIMITATION IMPOSED
	ADDM	S1,MAXLEN		;  BY THE RESIDUAL

EXRA:
	HRLZI	Z,D.EX3			;SET FUTURE-FAILURE TRAP
	HRR	Z,PATT+1		;SPECIAL ONE FOR SUCCESS THRU HERE
	PUSH	HSR,Z			;UNUSUAL H.S. ENTRY
	PUSH	HSR,S2		; SAVE SUBSTITUTE PATT	

	JRST	SC.S			;REPORT SUCCESSFUL STAR


;
;   --------------------
;   SCAN REPORTS FAILURE
;   --------------------
;

PR.EX2::	POP	STACK,Z			;RETRIEVE SCAN VARS
	HRRZM	Z,P2			;  HOLD PATT NODE OFFSET
	HLRZM	Z,SCRAD			;  RETURN ADDRESS
	POP	STACK,PATT		;  PATT BLOK ADDR
	ADD	P2,PATT			;RESTORE PATT NODE PTR

	HRRZ	Z,FULSAV		;IF QUICKSCAN
	JUMPN	Z,SC.LF			;    MODE,
	HLRZ	S1,PRESID(P2)		;RESTORE MAXLEN FROM
	ADDM	S1,MAXLEN		;  THE RESIDUAL'S LIMITATION

	JRST	SC.LF			;EVERYTH ELSE IS RESET FROM H.S.

;
;  THESE ROUTINES UTILIZE SCAN VARIABLES SAVED ON SYS STK:
;	+-----------------------+
;	+        P A T T        +
;	+-----------+-----------+
;	+  SCRAD(R) +  PATT+1   +
;	+-----------+-----------+
;
;  IT LOOKS LIKE A PATTERN DATATYPE DESCR.
;


	  ;SCAN OF THE STAR NODE'S SUCCESSOR
	;REPORTS FAILURE ALL THE WAY BACK INTO
	;THE STAR NODE, WHICH HAD SUCCEEDED.
	;RE-RECURSE, SO WE CAN KEEP HOPPING BACK
	;THRU THE HISTORY STACK IN THE ARG PATTERN


PR.EX3:				;PUT SCAN VARS BACK ONTO STK
				;  JUST LIKE PREV CALL TO SCAN
	MOVE	S1,STPTR##		;WE PUT PATT HERE
	PUSH	STACK,PATT	; SAVE ORIGINAL PATT.
	MOVE	P2,CURSOR		;WE PUT PATT+1 HERE
	HRLZ	Z,SCRAD			;THIS IS SCAN'S RETURN ADDR
	HRR	Z,P2			;PUT PATT+1 WITH RET ADDR
	PUSH 	STACK,Z			;AND PUT IT BACK, TOO

	ADD	P2,PATT		;MAKE UP NODE PTR
	HRRZ	Z,FULSAV		;IF QUICKSCAN
	JUMPN	EX3A			;    MODE,
	HLRZ	Z,PRESID(P2)		;  FETCH NODE'S RESID
	SUB	Z,MAXLEN		;  RESET TO HI LEVEL'S LIM'D VALUE
	MOVNM	Z,MAXLEN		;  STORE MAXLEN - RESID

EX3A:
	MOVEM	S1,PATT			;RESET PATTERN HEADER
					;  TO THE EVALUATED EXPRE PATT
	MOVEI	S1,EXPRET	; RESTORE ...
	MOVEM	S1,SCRAD	; RETURN ADDRESS
	JRST	SC.LF			;CURSOR AND STPTR## WILL BE
					;  RESET FROM THE H.S.

;
;  THIS ROUTINE UTILIZES A PHONEY H.S. ENTRY:
;	+---------+---------+
;	+  D.EX3  +  PATT+1 +
;	+---------+---------+
;	+      P A T T      +
;	+-------------------+
;  WHERE "PATT" REFERS TO THE UNEVALEX
;


	SUBTTL	CONST:	CONSTANT PATTERNS & PRIMITIVE
;
;  PRIMITIVE TO KILL THE WORKS
;
PR.ABT::	MOVE	STACK,SSSAVE	;RESTORE SYSTEM STATUS 
		JRST 	PR.GAF		;GO FINISH FAILING.

;
;  THE CONSTANT PATTERN FOR ABORT
;
$ABORT::	XWD	PBLOK,LPHDR+PNDSZ
		REPEAT	LPHDR-1,<0>		;GCFLD,PSTRT,PMIN
		XWD	0,PR.ABT	;PRESID/PPROG
		XWD	EMPTY,EMPTY		;PALT/PSUBS (NONE)
		OCT	0,0			;PARG (NONE)

;
;  THE CONSTANT PATTERN FOR ARB
;
$ARB::	XWD	PBLOK,LPHDR+3*PNDSZ
	REPEAT	LPHDR-1,<0>		;GCFLD,PSTRT,PMIN
	XWD	0,ARB1		;RESID/PGM		NIL1
	XWD	EMPTY,A.NIL2	;ALT/SUBS	
	REPEAT	PNDSZ-2,<0>	;ARG
A.NIL2==.-$ARB			;NAME FOR		NIL2
	XWD	0,SC.S		;RESID/PGM
	XWD	A.LEN1,EMPTY	;ALT/SUBS
	REPEAT	PNDSZ-2,<0>	;ARG
A.LEN1==.-$ARB		;NAME FOR			LEN(1)
	XWD	0,PR.LN1##		;RESID/PROG
	XWD	EMPTY,A.NIL2	;ALT/SUBS
	REPEAT	PNDSZ-2,<0>	;ARG

ARB1:	PUSH	HSR,FUTILE	; SAVE FUTILE FLAG
	MOVE	Z,CURSOR	; FORM A STACK
	HRLI	Z,D.AFL		; ENTRY
	PUSH	HSR,Z		; TO GET CONTROL BACK
	PUSH	HSR,STPTR##	; UPON GLOBAL FAIL
	JRST	SC.S		; PROCEED WITH SCANNING

PR.AFL:	POP	HSR,FUTILE	; RESTORE FUTILE FLAG
	JRST	SC.LF		; AND FAIL

;
;  THE CONSTANT PATTERN FOR BAL
;
$BAL::	XWD	PBLOK,LPHDR+3*PNDSZ
	REPEAT	LPHDR-1,<0>
	XWD	0,SC.S
	XWD	EMPTY,B.GBAL
	OCT	0,0
B.GBAL==.-$BAL		;LABEL FOR GBAL NODE
	XWD	0,PR.GBL##
	XWD	EMPTY,B.NIL2
	OCT	0,0
B.NIL2==.-$BAL			;LABEL FOR SECOND NIL NODE
	XWD	0,SC.S
	XWD	B.GBAL,EMPTY
	OCT	00,0

;
;  THE CONSTANT PATTERN FOR SUCCEED
;
$SUCC::	XWD	PBLOK,LPHDR+PNDSZ
	REPEAT	LPHDR-1,<0>
	XWD	0,SC.S
	XWD	EMPTY,EMPTY
	OCT	0,0


	SUBTTL	SSTPP:	SUBSTRING TVAR LOAD & STORE PROCESSOR PGM

;  POSITIONS IN UBLOK, WHICH IS POINTED TO BY TVAR:

SSVAL==LHDR		;ORIGINALLY SUBJ, THE VAL OF MTCH SUBJ
SSVAR==SSVAL+2		;ORIGINALLY SUBVAR, SUBJ AS A VARIABLE
			; =0 IF SUBJ WAS NOT A VARIABLE
SSHEAD==SSVAR+3		; (LEFT);	CURSOR AT STRT OF MTCH
SSCURS==SSHEAD		; (RIGHT);	CURSOR AT END  OF MTCH

SSTPP:	JRST	SSTPPV			;ENTRY TO GET VALUE
	ERROR	14,5			;ENTRY TO GET NAME. HAVE NONE.
SSTPPA:					;ENTRY TO ASSIGN VALUE
;
;	   ---------------------------------
;	   ASSIGN VALUE TO MATCHED SUBSTRING
;	   ---------------------------------
;
;
;	CALLING SEQUENCE:
;	  JSP SLINK,SSTPP+2
;	    WITH STK TOP = VALUE TO ASSIGN
;	    AND STK NEXT= OUR TVAR DESCRIPTOR
;	RETURN:
;	  JUST AS ASGNVL LEAVES IT
;	  FAIL OR SUCCEED AS DOES ASGNVL
;

	JSP	TLINK,CVTSTR##		;MAKE SURE THE VALUE'S A STR
	ERROR.	1,18			;  IT WASN'T. TOO BAD.
	POP	STACK,IGNOS##+1		;SAVE THE STRING VALUE FOR A 
	POP	STACK,IGNOS##		;  MOMENT(IT'S OK- NO GCOL)
;
;  WE NOW CALL CONCAT TO PUT TOGETHER:
;	THE STR LEFT OF THE MATCH
;	THE NEW VALUE
;	THE STR RIGHT OF THE MATCH
;	  (STACK THEM IN OPPOSITE ORDER)
;
	POP	STACK,Z			;DISCARD TVAR PTR TO SSTPP
	POP	STACK,FLAS		;SAVE TVAR PTR TO UBLOK
	MOVEI	Z,1			;INIT CONCAT PARAM COUNTER
	MOVE	S2,FLAS			;GET ADDR OF UBLOK

	PUSH	STACK,SSVAR(S2)		;IN PREPARATION FOR ASGNVL
	PUSH	STACK,SSVAR+1(S2)	;  CALL, PUT VARIABLE ON STK

	  ;  OPTIONALLY PUSH DESCR FOR RT STR ONTO STK
	HRRE	S3,SSCURS(S2)		;GET THE CURSOR
	JUMPLE	S3,SSTPPB		;  SKIP RT STR IF NONE
	PUSH	STACK,SSVAL(S2)		;WD#1 = SDT/PTR SBLOK
	HLRZ	T1,SSVAL+1(S2)	;GET OFFSET OF SUBJ
	ADD	T1,SSVAL+1(S2)		;  ADD LENGTH OF SUBJ
	SUB	T1,S3			;  SUBTR CURSOR
	HRLM	T1,S3			;=NEW OFFSET; JOIN TO CURSOR
	PUSH	STACK,S3		;RIGHT STRING DESCR DONE
	ADDI	Z,1			;CONCAT GETS ONE MORE ARG

	  ; PUSH DESCR FOR NEW SUBSTITUTION
SSTPPB:	PUSH	STACK,IGNOS##		;2D CONCAT ARG IS OUR
	PUSH	STACK,IGNOS+1		;  ASSIGNING VALUE
	
	  ;OPTIONALLY PUSH DESCR FOR LFT STR ONTO STK
	HLRZ	S3,SSHEAD(S2)		;GET HEAD OF MATCH
	MOVE	T1,SSVAL+1(S2)		;  GET OFFSET/LNTH OF SUBJ
	HRRZ	T2,T1			;ISOLATE LENGTH
	CAML	S3,T2			;  CHECK HEAD LT LNTH
	JRST	SSTPPC			;HEAD=LNTH: NO LEFT STRING
	PUSH	STACK,SSVAL(S2)		;WD#1 = SDT/ PTR SBLOK
	SUB	T1,S3			;WD#2 = OFFSET/LNTH-HEAD
	PUSH	STACK,T1		;  NOW THE DESCR IS DONE
	ADDI	Z,1			;AND NOTE ANOTHER ARG

SSTPPC:	CAIG	Z,1			;AT LEAST TWO ARGS FOR CONCAT?
	JRST	SSTPPD			;  NO, DON'T BOTHER
	JSP	TLINK,CONCAT##		;OK.  PUT THEM TOGETHER
	ERROR	11,17			;  STRING RSLT TOO LONG

SSTPPD:
;
;	NOW STACK TOP = RESULT STRING
;	    STACK NXT = SUBVAR, WHAT TO ASSIGN TO
;	MAKE THE ASSIGNMENT
;	
	HLRZ	Q2,-3(STACK)	; LOAD DATATYPE OF SUBJECT
	TRNE	Q2,NONDC	; IF DATA
	TRNE	Q2,PDC		; OR IF PROTECTED
	JRST	SSTPPE		; GO RETURN JUST VALUE

	JSP	TLINK,ASGNVL##		;ASSIGN IT
	JRST	0(SLINK)		;PASS FAILURE BACK
	JRST	1(SLINK)		;A-OK; ALL DONE.

	 ; HERE TO JUST RETURN THE VALUE

SSTPPE:	POP	STACK,-2(STACK)	; JUST MOVE THE
	POP	STACK,-2(STACK)	; DESCRIPTOR DOWN A LEVEL
	JRST	1(SLINK)	; AND RETURN
;
;	-----------------------------------------
;	FETCH VALUE OF SUBSTRING TRAPPED VARIABLE
;	-----------------------------------------
;	  MAKE UP A STRING DESCRIPTOR FOR IT AND RETURN THAT
;	CALLING SEQUENCE:
;	  STACK TOP = OUR TVAR DESCR
;	  JSP	SLINK,SSTPP
;	RETURN:
;	  STACK TOP REPLACED BY STR DESCR FOR VALUE
;	  NEVER FAIL.  RETURN TO CALL+2.
;
SSTPPV:	MOVE	S2,-1(STACK)		;GET ADDR OF UBLOK
	MOVE	Z,SSVAL(S2)		;GET DESCR OF SUBJ
	MOVEM	Z,-1(STACK)		;RETURN WD#1 = SDT/PTR SBLOK

	HLRZ	Z,SSHEAD(S2)		;GET HEAD, LEFT MTCH BOUNDARY
	MOVE	S3,Z			;  SAVE IF FOR LATER
	SUB	Z,SSCURS(S2)	;  HEAD LESS CURSOR
	MOVEM	Z,0(STACK)		;  =SUBSTR LNTH (RIGHT HALF)

	HLRZ	Z,SSVAL+1(S2)		;GET ORIGINAL OFFSET
	ADD	Z,SSVAL+1(S2)		;  PLUS LENGTH
	SUB	Z,S3			;  LESS HEAD
	HRLM	Z,0(STACK)		;  GIVES NEW OFFSET
	JRST	1(SLINK)		;AND WE NEVER FAIL


	END
   xxä