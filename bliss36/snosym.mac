	SUBTTL	MA355/JDS/DRH/MP/RCM/VB		10-JUN-76

; COPYRIGHT 1972,1973,1976,1977 STEVENS INSTITUTE OF TECHNOLOGY,
; HOBOKEN, NEW JERSEY, 07030
; ALL RIGHTS RESERVED.

	SEARCH	SNOPRM		;SITBOL PARAMETER FILE
	SEARCH	MACTEN		;STANDARD MACROS

  ;DIRECTIVES
	SALL			;SUPPRESS MACRO EXPANSIONS
	.DIREC	.XTABM		;EXCLUDE TABS FROM MACRO CALLS
	TWOSEG	400K		;TWO SEGMENT CODE

  ;VERSION NUMBER

	SYMVER==5		;MAJOR VERSION NUMBER
	SYMMIN==0		;MINOR VERSION NUMBER
	SYMEDT==222		;EDIT LEVEL
	SYMWHO==0		;CUSTOMER ARG

  ;TITLE

	TITLE.	SYM,SNOSYM,<Symbol Table Management>

  ;SHOW UNIVERSAL VERSION NUMBERS

	SHOW.	%%SNOPRM	;SNOPRM'S VERSION NUMBER
	SHOW.	%%MACT		;MACTEN'S VERSION NUMBER


  ;SOME EXTERNAL SYMBOLS


	SYMTTL			; Title
	SYMPTX			; PASS2 message
	SUBTTL	Table of Contents

;		Table of Contents for Symbol Table Management
;
;
;			   Section			      Page
;   1. Table of Contents. . . . . . . . . . . . . . . . . . .    2
;   2. Revision History . . . . . . . . . . . . . . . . . . .    3
;   3. INTERNAL(STATIC) SYMBOL TABLE. . . . . . . . . . . . .    4
;   4. PRIMARY ROUTINES
;        4.1.   CLEAR . . . . . . . . . . . . . . . . . . . .    9
;        4.2.   DATATYPE. . . . . . . . . . . . . . . . . . .   11
;        4.3.   FUNCTION(NAME). . . . . . . . . . . . . . . .   12
;   5. Primary Routines
;        5.1.   LABEL(NAME) . . . . . . . . . . . . . . . . .   13
;   6. PRIMARY ROUTINES
;        6.1.   OPSYN . . . . . . . . . . . . . . . . . . . .   14
;   7. DTNAME - TO DEFINE DATATYPE OF DESCRIPTOR. . . . . . .   15
;   8. INSTAL - LOCATE OR INSTAL A SYMBOL . . . . . . . . . .   16
;   9. LOCATE - TO LOCATE A STRING IN THE SYMBOL TABLE. . . .   17
	SUBTTL	Revision History



Comment	{
122	Clean up the listings.
124	Add the LOAD function to load an external function.
	Add the UNLOAD function to unload an external function.
131	ADD SNODDT FUNCTIONS AND PAV FUNCTIONS
147	Use the TX?? macros instead of the TD?? instruction when you
	use Y.???? instead of the X.????
170	Add new keywords for error processing.
171	Fix problem with &ASSOCIATE
204	Add &VERSION keyword.
221	Make OPSYN check for natural variables in the first two arguments.
222	LABEL("") and FUNCTION("") SHOULD FAIL, MAKE THEM DO THAT.
{
        SUBTTL INTERNAL(STATIC) SYMBOL TABLE
        FNFLAG== 200000
        KWFLAG== 100000
        LBFLAG== 40000
        PKFLAG== 20000
        DTFLAG== 10000
        ISDAT== 7777
        ISKEY== 7700
        DTPINX== 77
        OPNO== 77
        EXT== 10000
 DEFINE DATWD(I)<D'I>
 DEFINE IST(I)<ISTC'I>
 DEFINE ISD(I)<ISTD'I>
 DEFINE BIS(A)< DEFINE CA(ARG)<C(,<ARG>)>
                 DEFINE C(X,Y)< DEFINE CA(ARG)<C <X'Y>,<ARG>>>
               N= 0
               OFSET= 0
               LEN= A
               ISTD'A::
               ADDR= ISTD'A      >
 DEFINE EIS(A)< DEFINE C(X,Y)< ASCII "X">
                MXISC= A
                ISTC'A:: XWD SBLOK,N
                         XWD 0,0
                CA()                >
 DEFINE ISOP(NM,ISUN,ISBIN,OPN)< XWD ISUN,ISBIN
             BYTE (1)1(29)0(6)OPN
             N= N+1
             CA <NM>
             IRPC NM,<OFSET= OFSET+1>    >
 DEFINE IS(NM,ISFUN,ISK,PKEY,LABL,ISDT)< F=0
           K= 0
           L= 0
           PK= 0
           D= 0
           IFDIF <ISFUN><><                F= 1 >
	XWD  ISFUN,LABL
           IFDIF <LABL><><       L= 1 >
           IFDIF <ISK><>< K= 1
                          IFN PKEY,<PK=1>  >
           IFDIF <ISDT><>< D= 1
                           INX= ISDT&DTNUM
                           DATWD(\INX)= <OFSET>B17!LEN >
           IFIDN <ISDT><EXT>< ISDT=0 >
           N= N+1
           CA <NM>
           IRPC NM,< OFSET= OFSET+1 >
           BYTE (1),F,K,L,PK,D(12)ISDT(6),ISK      >
	BIS(1)
	ISOP	< >,,CAT$##,5
	ISOP	<!>,,ALT$##,2
	ISOP	<#>,,,3
	ISOP	<$>,IND$##,IMVA$##,12
	ISOP	<%>,,,4
	ISOP	<&>,KEYW$##,,3
	ISOP	<*>,,MUL$##,10
	ISOP	<+>,PLUS$##,SUM$##,6
	ISOP	<->,MINUS$##,DIFF$##,6
	ISOP	<.>,NAME$##,CNVA$##,12
	ISOP	</>,,DIV$##,7
	ISOP	<=>,,ASGN$##,0
	ISOP	<?>,QUEST$##,MTCH$##,1
	ISOP	<@>,CURS$##,,3
	ISOP	<\>,NEG$##,,3
	ISOP	<^>,,ALT$,2
	ISOP	<_>,,ASGN$,0
	ISOP	<|>,,ALT$,2
	ISOP	<~>,NEG$,,3
	EIS(1)

	BIS(2)
	ISOP	**,,EXP$##,11
	IS	EQ,EQ$##
	IS	GE,GE$##
	IS	GT,GT$##
	IS	LE,LE$##
	IS	LT,LT$##
	IS	NE,NE$##
	EIS(2)

	BIS(3)
	IS	ANY,ANY$##
	IS	ARB,,3,1
	IS	ARG,ARG$##
	IS	BAL,,4,1
	IS	END,,,,END##
	IS	LEN,LEN$##
	IS	LEQ,LEQ$##
	IS	LGE,LGE$##
	IS	LGT,LGT$##
	IS	LLE,LLE$##
	IS	LLT,LLT$##
	IS	LNE,LNE$##
	IS	POS,POS$##
	IS	PPN,,22
	IS	REM,,11,1
	IS	RUN,RUN$##
	IS	TAB,TAB$##
	IS	TTY,TTY$##
	EIS(3)
	BIS(4)
	IS	CODE,CODE$##,42,,,CDT
	IS	COPY,COPY$##
	IS	DATA,DATA$##
	IS	DATE,DATE$##
	IS	DUMP,DUMP$##,43
	IS	DUPL,DUPL$##
	IS	EVAL,EVAL$##
	IS	EXIT,EXIT$##
	IS	FAIL,,5,1
	IS	FILE,FILE$##
	IS	ITEM,ITEM$##
	IS	LOAD,LOAD$##
	IS	LPAD,LPAD$##
	IS	NAME,,21,,,NDT
	IS	REAL,,,,,RDT
	IS	RPAD,RPAD$##
	IS	RPOS,RPOS$##
	IS	RTAB,RTAB$##
	IS	SIZE,SIZE$##,23
	IS	SORT,SORT$##
	IS	SPAN,SPAN$##
	IS	STNO,,15
	IS	TIME,TIME$##
	IS	TRIM,TRIM$##,55
	EIS(4)

	BIS(5)
	IS	ABEND,,40
	IS	ABORT,,1,1,ABORT##
	IS	APPLY,APPLY$##
	IS	ARBNO,ARBNO$##
	IS	ARRAY,ARRAY$##,,,,ADT
	IS	ASCII,ASCII$##
	IS	BREAK,BREAK$##
	IS	CLEAR,CLEAR$##
	IS	FENCE,,6,1
	IS	FIELD,FIELD$##
	IS	IDENT,IDENT$##
	IS	INPUT,INPUT$##,50
	IS	JOBNO,,17
	IS	LABEL,LABEL$##
	IS	LOCAL,LOCAL$##
	IS	MTAPE,MTAPE$##
	IS	OPSYN,OPSYN$##
	IS	REMDR,REMDR$##
	IS	RSORT,RSORT$##
	IS	TABLE,TABLE$##,,,,TDT
	IS	TRACE,TRACE$##,54
IFN FTDDT,<
	IS	WHERE,WHERE$##
>
	EIS(5)
	BIS(6)
	IS	ANCHOR,,41
	IS	BREAKX,BRKX$##
	IS	COMPNO,,60
	IS	DEFINE,DFN$##
	IS	DELETE,DELET$##
	IS	DETACH,DTCH$##
	IS	DIFFER,DFFR$##
	IS	ERRMSG,,26
	IS	FTRACE,,46
	IS	LASTNO,,10
	IS	NOTANY,NTNY$##
	IS	OUTPUT,OUTPT$##,52
	IS	RANDOM,RAND$##,57
	IS	RENAME,RENAM$##
	IS	REPEAT,,,,REPEAT##
	IS	RESCAN,RSCN$##
	IS	RETURN,,,,RET##
	IS	REWIND,RWND$##
	IS	STOPTR,STPTR$##
	IS	STRING,,,,,SDT
	IS	SUBSTR,SBSTR$##
	IS	UNLOAD,UNLD$##
	EIS(6)

	BIS(7)
	IS	COLLECT,CLLCT$##
	IS	COMMAND,,20
IFN FTDDT,<
	IS	CONNECT,CNCT$##		;CONNECT TO AN EVENT
>
	IS	CONVERT,CNVRT$##
	IS	ENDFILE,ENDFL$##
	IS	ERRNAME,,25
	IS	ERRPARM,,24
	IS	ERRTYPE,,44
	IS	FRETURN,,,,FRET##
	IS	INTEGER,INTGR$##,,,,IDT
	IS	NRETURN,,,,NRET##
	IS	NUMERIC,,,,,NUMDC
	IS	PATTERN,,,,,PDT
	IS	REPLACE,RPLC$##
	IS	REVERSE,RVRS$##
	IS	RTNTYPE,,12
	IS	SETEXIT,STXT$##
	IS	STCOUNT,,13
	IS	STLIMIT,,53
	IS	SUCCEED,,16,1
	IS	VERSION,,63
	EIS(7)

	BIS(10)
	IS	ALPHABET,,2
	IS	CONTINUE,,,,CONTIN##
	IS	DATATYPE,DTTP$##
	IS	ERRLEVEL,,62
	IS	ERRLIMIT,,45
	IS	EXTERNAL,,,,,EXT
	IS	FNCLEVEL,,7
	IS	FULLSCAN,,47
	IS	FUNCTION,FUNCT$##
IFN FTDDT,<
	IS	INSERTBP,IBP$##		;INSERT A BREAK POINT
>
	IS	MAXLNGTH,,51
IFN FTDDT,<
	IS	REMOVEBP,RBP$##		;REMOVE A BREAK POINT
>
	IS	STFCOUNT,,14
	EIS(10)

	BIS(11)
IFN FTPAV,<
	IS	ASSOCIATE,ASSC$##,61	;FOR PROGRAMMER-DEFINED ASSOCIATIONS
>
	IS	HISTOGRAM,,56
	IS	PROTOTYPE,PROTO$##
	EIS(11)

	BIS(12)
IFN FTDDT,<
	IS	DISCONNECT,DCNCT$##	;DISCONNECT AN EVENT
>
	IS	EXPRESSION,,,,,EDT
	EIS(12)
IFN FTPAV,<
	BIS	(13)
	EIS	(13)
	BIS	(14)
	IS	DISASSOCIATE,DASSC$##	;UNDO ASSOCIATIONS
	EIS	(14)
>;END OF IFN FTPAV
	I= 0
ISTDTP::
	REPEAT	MAXDTN,< OFFLEN==DATWD(\I)
		XWD SDT,IST(\<OFFLEN&77>)
		EXP OFFLEN
			I= I+1       >
	I= 1
STABLE:: 0
	REPEAT	MXISC,< IST(\I)
			I= I+1    >
	I= 1
DTABLE:: 0
	REPEAT	MXISC,< ISD(\I)
			I= I+1   >

ISPREC::
	XWD	5,4
	XWD	7,6
	XWD	12,13
	XWD	20,21
	XWD	24,25
	XWD	30,31
	XWD	40,41
	XWD	50,51
	XWD	54,55
	XWD	65,64
	XWD	70,71

VARPRO::
	XWD	SDT,0
	OCT	0,0
	XWD	0,UNDEF$
	OCT	0,0,0
	SUBTTL	PRIMARY ROUTINES -- CLEAR
;   CLEAR(STRING,ARG) WILL CAUSE THE VALUES OF VARIABLES IN THE
;   SYMBOL TABLE TO BE SET TO NULL.  THE FIRST ARGUMENT IS A
;   STRING WHICH LISTS THE VARIABLE NAMES, SEPERATED BY
;   COMMAS, OF THOSE VARIABLES WHOSE VALUE IS TO BE LEFT 
;   UNCHANGED.  IF A SECOND NON-NULL ARGUMENT IS SUPPLIED, THEN
;   ALL VARIABLES CONTAINING PATTERN VALUES ARE LEFT UNCHANGED.
;
CLEAR::
        SETZ    P2,             ;PATTERN VAL. VARIABLE INDICATOR
        POP     STACK,Z         ;2ND WD OF DESCR. - 2ND ARG
        POP     STACK,S2        ;1ST  " "    "         "
        CAME    S2,NULLST##       ;SKIP IF 2ND ARG IS NULL
        HRRI    P2,1            ;DON'T CLEAR PATTERN VAL. VAR.
        MOVE    Z,NULLST        ;NULL DESCR.
        SETZ    S1,             ;COUNT OF SPECIAL VARIABLES
        CAME    Z,-1(STACK)     ;SKIP IF 1ST ARG IS NULL
        JRST    BRKST           ;JUMP TO BREAK UP STR OF PROT. VAR.
	SUB	STACK,[2,,2]	; POP DESCR
	JRST	VARCL		; JOIN OTHER PROCESSING

BRKST:  JSP     TLINK,STINIT##  ;INITIALIZE STRM
	ERROR.	1,55		;BAD 1ST ARG - NOT STRING
        MOVE    S2,SYSCT##        ;SYSTEM CHAR. TBL ADDR
       MOVX    S3,Y.CM		;COMMA MASK
     
CLOOP:  AOJ     S1,             ;INCREMENT VAR. COUNT
        JSP     TLINK,STRM##    ;STREAM FOR COMMA
        MOVEI   S3,0            ;ZERO MASK - LAST VARIABLE
        JSP     TLINK,LOCATE  ;GET ADDR OF VAR BLK
        SOJA    S1,CLOOP1       ;STRING NOT LOCATED
        MOVE    Q2,Z            ;ADDR OF VAR BLK
        JSP     QLINK,LOCVAL##  ;LOCATE VALUE OF DESCR.
        PUSH    STACK,VALUE(Q2) ;STORE VALUE DESCR.
        PUSH    STACK,VALUE+1(Q2) 
        PUSH    STACK,NULLST+1  ;STORE DUMMY VALUE - PAIR
        PUSH    STACK,Q2        ;STORE ADDR OF VALUE DESCR.
CLOOP1: JUMPE   S3,VARCL        ;JUMP IF LAST VAR.
        SOS     CURSOR##          ;DECREMENT CURSOR POSITION
        IBP     STPTR##           ;SKIP OVER COMMA
        JRST    CLOOP           ;CONTINUE LOADING VALUES
VARCL:  MOVEM   S1,IGNOS        ;SAVE VARIABLE COUNT
        MOVE    T1,NULLST       ;NULL DESCR.
        MOVE    T2,VTABLE##       ;ADDR OF 1ST WD IN HASH TBL
        MOVE    T3,T2           
	ADD	T3,LVTBL##	;addr of last word +1 in table
        SUBI    T2,1            ;SET UP HASH TBL ADDR WD
NXHSH:  AOJ     T2,             ;INCREMENT HASH TBL ADDR 
        CAML    T2,T3           ;SKIP IF NOT AT END OF TBL
        JRST    CLSTK           ;JUMP IF FINISHED CLEARING
        MOVE    S1,0(T2)        ;NXT HASH TBL ENTRY
        JUMPE   S1,NXHSH        ;JMP IF HASH ENTRY IS 0 - NO CHAIN
NXVBL:  TRNN    P2,1            ;SKIP IF MUST CHK FOR PDT
        JRST    CLVAR           ;JUMP TO CLEAR VAR.
        HLRZ    S3,VALUE(S1)    ;GET DATATYPE
        CAIN    S3,PDT          ;SKIP IF NOT PDT - CLEAR
        JRST    NXLNK           ;DON'T CLEAR - GET NXT VAR.
CLVAR:  MOVE    Q2,S1           ;ADDR OF DESCR.
        JSP     QLINK,LOCVAL##  ;LOCATE VALUE DESCR.
        MOVEM   T1,VALUE(Q2)    ;CLEAR VAR. - SET NULL
        SETZM   VALUE+1(Q2)     
NXLNK:  HRRZ    S1,VLINK(S1)    ;NXT VAR. ON CHAIN
        JUMPE   S1,NXHSH        ;JUMP IF LAST LINK ON CHAIN
        JRST    NXVBL           ;PROCESS NXT VAR. ON CHAIN

CLSTK:  MOVE    T2,IGNOS##        ;COUNT OF VAR. ON STACK
RSTVL:  SOJL    T2,RETNUL##       ;JUMP IF DONE - RET NULL STR
        POP     STACK,S1        ;ADDR OF VAR. DESCR.
        POP     STACK,Z         ;DUMMY PAIRED VALUE
        POP     STACK,VALUE+1(S1) ;RESTORE VALUE OF VARIABLE
        POP     STACK,VALUE(S1)
        JRST    RSTVL           ;CONTINUE
	SUBTTL	PRIMARY ROUTINES -- DATATYPE
;   DATATYPE(ARG) RETURNS A STRING DESCRIPTOR OF THE FORMAL
;   IDENTIFICATION OF THE DATATYPE OF ITS ARGUMENT.  IF THE 
;   DATATYPE CANNOT BE IDENTIFIED, A FORMAL IDENTIFICATION 
;   OF 'EXTERNAL' IS RETURNED
;
DTTP::
        JSP     QLINK,DTNAME    ;GET STR DESCR. OF DATATYPE
        JSP     1(PLINK)        ;NORMAL RETURN

	SUBTTL	PRIMARY ROUTINES -- FUNCTION(NAME)

; PREDICATE TO DETERMINE WHETHER THE GIVEN
; NAME IS THE NAME OF A FUNCTION


FUNCT::	JSP	TLINK,CVTNAM##	; ENSURE A NAME
	 JRST	FUNCT2		;[222] Failed - Check for null string

	SKIPE	0(STACK)	; NATURAL?
	JRST	FRET1##		; FAIL IF NOT

	HRRZ	T1,-1(STACK)	; ADDRESS OF VBLOCK
	HRRZ	T2,VFUNC(T1)	; ADDRESS OF FBLOK

FUNCT1:	CAIN	T2,UNDEF$##	; UNDEFINED?
	JRST	FRET1##		; YES, FAIL

	HLRZ	T3,BTCODE(T2)	; GET CODE
	CAIE	T3,TFBLOK	; IS IT BEING TRACED?
	JRST	RETNL1##	; NO - SUCCEED

	HRRZ	T2,TFOLD(T2)	; PICK UP OLD FUNCTION
	JRST	FUNCT1		; AND LOOP BACK


;[222] Here to check for a null string in the call to FUNCTION.
;[222] FAIL IF THE STRING IS NULL, ELSE GIVE THE 1.73 ERROR.

FUNCT2:	MOVE	Z,-1(STACK)	;[222] Get the first word of the arg
	CAME	Z,NULLST	;[222] Is this the null string ?
	 ERROR.	1,73		;[222] No - Bad data type
	JRST	FRET1		;[222] Yes - Give a fail return
	SUBTTL	Primary Routines -- LABEL(NAME)

; LABEL(NAME) IS A PREDICATE TO TEST
; WHETER NAME IS THE NAME OF A LABEL.

LABEL::
IFN FTDDT,<
	JSP	TLINK,CVTINT##	;CONVERT SECOND ARGUMENT TO INTEGER
	 ERROR.	1,310		;FAILED -- BAD ARGUMENT
	SKIPN	(STACK)		;IS OFFSET ?
	 JRST	LABL1		;NO -- TRY FOR LABEL OR SYSTEM LABEL

	; SEARCH FOR DESIRED STATEMENT

	JSP	SLINK,CVTLAB##	;CONVERT TO CODE
	 JRST	FRET2##		;YES LOSE
	JRST	RETNL1		;WINNER !

	;HERE IF WE JUST WANT LABEL WITH NO OFFSET

LABL1:	SUB	STACK,[2,,2]	;TOSS OFF OFFSET
>;END OF IFN FTDDT

	JSP	TLINK,CVTNAM	; ENSURE A NAME
	 JRST	LABL2		;[222] Check for null string
	SKIPE	0(STACK)	; NATURAL?
	JRST	FRET1		; NO, FAIL

	HRRZ	T1,-1(STACK)	; ADDR OF NAT. VAR.
	MOVE	T2,VLABEL(T1)	; GET LABEL
	SKIPGE	VFLAGS(T1)	; OPERATORS ALWAYS
	JRST	FRET1		; LOSE

	JUMPE	T2,FRET1	; NO LABEL? FAIL
	JRST	RETNL1		; OTHERWISE ASSUME A LABEL


;[222] Here to check for the null string.  If it is null then
;[222] give a fail return, else give a 1.74 error (bad datatype)

LABL2:	MOVE	Z,-1(STACK)	;[222] Get the first word of the arg
	CAME	Z,NULLST	;[222] Is this the null string ?
	 ERROR.	1,74		;[222] No - Bad argument
	JRST	FRET1		;[222] Yes - Give the fail return
	SUBTTL	PRIMARY ROUTINES -- OPSYN


;   OPSYN(NAME1,NAME2,ARG) CAUSES THE FUNCTION NAME IN THE FIRST
;   ARGUMENT TO BE DEFINED TO HAVE THE SAME DEFINITION AS THE
;   FUNCTION NAMED IN THE SECOND ARGUMENT.  IF EITHER OR BOTH OF
;   THE FIRST TWO ARGUMENTS ARE OPERATORS THEN THE THIRD ARGUMENT
;   WILL DETERMINE IF THE UNARY(ARG=1) OR BINARY(ARG=2) OPERATION
;   IS BEING REFERENCED.  DEFAULT IS THE BINARY OPERATION.
;
OPSYN::
        JSP     TLINK,CVTINT##    ;CONVERT 3RD ARG TO INTEGER
	ERROR.	1,72		;BAD 3RD ARGUMENT
        POP     STACK,P2        ;VALUE OF INTEGER
        POP     STACK,Z         ;DON'T CARE
        CAIGE   P2,0            ;SKIP IF 3RD ARG GE 0
	ERROR	13,46		;BAD 3RD ARG - NEGATIVE
        CAILE   P2,2            ;SKIP IF 3RD ARG LE 2
	ERROR	13,46		;BAD 3RD ARG - TOO LARGE
        JSP     TLINK,CVTNAM##  ;CONV. 2ND ARG TO NAME
	 ERROR.	1,79		;BAD 2ND ARG
	SKIPE	(STACK)		;[221] Natural variable ?
	 ERROR.	1,79		;[221] No - BAD ARGUMENT
        POP     STACK,Z         ;2ND WD OF DESCR.
        POP     STACK,S2        ;1ST WD OF DESCR.
        HLLI    S2,0            ;ADDR OF VAR BLK - 2ND ARG
        JSP     TLINK,CVTNAM##  ;CONV. 1ST ARG TO NAME
	 ERROR.	1,78		;BAD 1ST ARG
	SKIPE	(STACK)		;[221] Natural variable ?
	 ERROR.	1,78		;[221] No - Bad argument
        POP     STACK,Z         ;2ND WD OF DESCR.
        POP     STACK,S1        ;1ST WD OF DESCR.
        HLLI    S1,0            ;ADDR OF VAR BLK - 1ST ARG
        CAIN    P2,1            ;SKIP IF NOT UNARY
        JRST    OPUN            ;JUMP FOR UNARY OPERATOR
        MOVE    Q3,VFUNC(S2)    ;FBLOK OR VBINRY FOR 2ND ARG
        MOVEI   Q2,VFUNC(S1)    ;ADDR OF FBLOK OR VBINRY FLD IN 1ST ARG
        JSP     QLINK,IFBLOK##  ;SET FIELD FOR 1ST VARIABLE
        JRST    RETNUL##        ;RETURN NULL STR ON STACK
OPUN:   MOVE    Q3,VUNARY(S2)   ;GET UNARY FLD FOR OPERATOR
        SKIPL   VFLAGS(S2)      ;SKIP IF 2ND ARG IS OPER.
        MOVE    Q3,VFUNC(S2)    ;GET FUNC FLD FOR FUNCTION
        MOVEI   Q2,VUNARY(S1)   ;ADDR OF UNARY FLD FOR ARG 1
        SKIPL   VFLAGS(S1)      ;SKIP IF 1ST ARG IS OPER.
        MOVEI   Q2,VFUNC(S1)    ;ADDR OF FUNC FLD FOR ARG 1
        JSP     QLINK,IFBLOK##  ;SET FIELD FOR 1ST ARG
        JRST    RETNUL          ;RETURN NULL STR ON STACK
        SUBTTL  DTNAME - TO DEFINE DATATYPE OF DESCRIPTOR
;
;   CALLING SEQUENCE:
;                  PUSH DESCRIPTOR(ANY TYPE) ONTO STACK
;                  JSP  QLINK,DTNAME
;                  RETURN - STRING DESCRIPTOR OF DATATYPE ON STACK.
;                           IF DATATYPE UNKNOWN, STRING DESCRIPTOR
;                           FOR 'EXTERNAL' ON STACK.
;
DTNAME::
        POP     STACK,Z         ;2ND WD OF DESCR.
        POP     STACK,Q3        ;1ST WD OF DESCR.
        HLRZ    Q2,Q3           ;ISOLATE DATATYPE
        CAIN    Q2,DDT          ;SKIP IF NOT DEFINED DATATYPE
        JRST    DEFDAT          ;JUMP FOR DEFINED DATATYPE
        ANDI    Q2,DTNUM        ;ISOLATE RIGHT 6 BITS
        CAIL    Q2,MAXDTN       ;SKIP IF KNOWN DATATYPE
        SETZ    Q2,             ;UNKNOWN DTP - EXTERNAL INDEX
        ASH     Q2,1            ;GET INDEX TO DATATYPE TBL
        PUSH    STACK,ISTDTP(Q2) ;1ST WD OF STR DESCR.
        PUSH    STACK,ISTDTP+1(Q2) ;2ND WD OF STR DESCR.
        JSP     0(QLINK)        ;NORMAL RETURN
DEFDAT: HRRZ    Q2,ADFBLK(Q3)   ;ADDR OF DFBLOK
        HRRZ    Q2,DFNAME(Q2)   ;ADDR OF VAR BLK
        PUSH    STACK,VNAME(Q2) ;1ST WD OF STR DESCR.
        PUSH    STACK,VNAME+1(Q2) ;2ND WD OF STR DESCR.
        JSP     0(QLINK)        ;NORMAL RETURN
        SUBTTL  INSTAL - LOCATE OR INSTAL A SYMBOL
;
;   CALLING SEQUENCE:
;                  PUSH STRING DESCRIPTOR ONTO STACK(MUST BE STRING)
;                  JSP  TLINK,INSTAL
;                  FAIL RETURN - STACK POPPED
;                  SUCCESS RETURN - STACK POPPED, ADDRESS OF 
;                                   VARIABLE BLOCK IN REG 0.
;

INSTAL::
        MOVEM   TLINK,TLNKSV##    ;SAVE TLINK
        JSP     TLINK,LOCATE    ;LOCATE BLOCK
        JRST    INST1           ;CONTINUE IF NOT LOCATED
        MOVE    TLINK,TLNKSV    ;RESTORE TLINK
        JRST    1(TLINK)        ;SUCCESS RETURN
INST1:  JUMPN   Z,INST2         ;JUMP IF STRING GOOD
        JRST    @TLNKSV         ;FAIL RETURAD STR DESCR.
INST2:  MOVE    T2,Z            ;ADDR OF VLINK FIELD
        MOVE    T3,GSURF##        ;ADDR OF NXT VAR BLK
        HRRM    T3,0(T2)        ;LINK VAR BLK ON CHAIN
        MOVEI   Z,VARSIZ        ;LENGTH OF VAR BLK
        JSP     QLINK,GCOLG##   ;GARBAGE COLLECT - GET SPACE
	PUSHR	PS		;Increase privelege
        MOVE    Z,GSURF         ;GSURF POINTER - NEW DATA ADDR
        HRLI    Z,VARPRO        ;ADDR OF VAR BLK PROTOTYPE
        MOVE    P1,GSURF        ;ADDR OF VAR BLK
        BLT     Z,VARSIZ-1(P1)  ;MOVE PROTOTYPE INTO VAR BLK
        MOVE    Q2,IGNOT##+1      ;LENGTH OF STRING
        CAILE   Q2,MXISC        ;JUMP IF STR LGTH IN BOUNDS
        JRST    INST10          ;JUMP IF NOT INTERNAL VARIABLE
        MOVE    Q2,STABLE(Q2)   ;ADDR OF INT STRING HEADCELLS
        HRRZ    S1,0(Q2)        ;NUMBER OF STRINGS IN TBL
        JUMPE   S1,INST10       ;JUMP IF TBL EMPTY
        MOVSI   P2,SDT          ;STR DESCR. DATATYPE
        HRR     P2,Q2           ;1ST WD OF DESCR. FOR INTERN. TBL
        HRRZ    S2,IGNOT+1      ;2ND WD OF DESCR.
        HRLZ    S3,IGNOT+1      ;LENGTH,0

INST3:  PUSH    STACK,P2        ;1WD OF DESCR. FOR INT. SYM. TBL
        PUSH    STACK,S2        ;2ND WD OF DESCR.
        JSP     TLINK,LEQUAL##  ;COMPARE STRINGS LEXICALLY
        JRST    INST4           ;LT - KEEP LOOKING
        JRST    INST5           ;EQ - FOUND IN INT SYM TBL
        JRST    INST10          ;GT - NOT IN INT SYM TBL
INST4:  ADD     S2,S3           ;INCREMENT OFFSET
        SOJG    S1,INST3        ;DECREMENT COUNT OF STRINGS

INST10:
INSTOK:	MOVEI	T1,VARSIZ(P1)	; UPDATE ...
	MOVEM	T1,GSURF	; GSURF

	PUSH	STACK,FLAT##	; RETRIEVE ORIGINAL ...
	PUSH	STACK,FLAT+1	; STRING
	JSP	TLINK,STCON##	; PUT IT WITH THE CONSTANTS
	POP	STACK,VNAME+1(P1) ; AND PLACE ...
	POP	STACK,VNAME(P1) ; IT IN THE VAR BL.

	MOVEM	P1,T2		; SAVE THE VAR. BLCK ADDR
	POPR	PS		;Restore registers
        MOVE    Z,T2         ;ADDR OF VAR BLK
        MOVE    TLINK,TLNKSV    ;RESTORE TLINK
        JRST    1(TLINK)        ;SUCCESS RETURN
INST5:  MOVEM   P2,FLAT         ;NEW STR DESCR. - IN SYM TBL
        MOVEM   S2,FLAT+1       ;
        HRRZ    P2,P2           ;ADDR OF SBLOK
        HRRZ    P2,0(P2)        ;NUMBER OF STRINGS IN BLOK
        SUB     P2,S1           ;POSITION OF LOCATED STRING
        ASH     P2,1            ;INDEX INTO DOPE VECTOR TABLE
        HRRZ    S2,S2           ;LENGTH OF STRING
        MOVE    Q2,DTABLE(S2)   ;ADDR OF PARTICULAR DOPE VEC TBL
        ADD     Q2,P2           ;ADDR OF DOPE VECTOR
        MOVE    Q1,0(Q2)        ;1ST WD OF DOPE VECTOR
        MOVE    Q2,1(Q2)        ;2ND WD OF DOPE VECTOR
        TLNN    Q2,PKFLAG       ;SKIP IF PATTERN VAL. KEYWD
        JRST    INST6           ;JUMP TO CHECK IF OPERATOR
        MOVE    Q3,Q2           ;2ND DOPE VECTOR WD
        ANDI     Q3,ISKEY        ;KEYWD NUMBER
        LSH     Q3,-6            ;INDEX FOR PROTECTED KYWD TBL
        MOVEI   Z,PROTKW##      ;ADDR OF PROT. KYWD
        ADD     Q3,Z            ;ADDR OF DATA
        MOVSI   Z,PDT
        HLR     Z,0(Q3)         ;PATT. VAL. KYWD ADDR
        MOVEM   Z,VALUE(P1)     ;SET VALUE
INST6:  TLNE    Q2,OPFLAG       ;SKIP IF NOT OPERATOR
        JRST    INSTOP          ;JUMP TO SET OPER VAR BLK
        TLNN    Q2,LBFLAG       ;SKIP IF IT IS A LABEL
        JRST    INST7           ;JUMP - NOT LABEL
        HRLZ    Z,Q1            ;LABEL VAL FROM DOPE VECTOR
        MOVEM   Z,VLABEL(P1)    ;SET LABEL IN VAR BLK

INST7:  MOVEI   Z,UNDEF$
        TLNE    Q2,FNFLAG       ;JUMP IF NOT FUNCTION
        HLRZ    Z,Q1            ;FUNC DATA FROM DOPE VECTOR
        TLNN    Q2,DTFLAG       ;JUMP IF DATATYPE SET
        JRST    INST8           ;JUMP TO INSTAL VBDT,VFUNC
        HLRZ    Q3,Q2           ;2ND WD OF DOPE VECTOR
        ANDI     Q3,ISDAT        ;DATATYPE
        HRL     Z,Q3            ;INSERT VBDT
 
INST8:  MOVEM   Z,VFUNC(P1)     ;LOAD VBDT AND VFUNC
        TLNN    Q2,KWFLAG       ;SKIP IF KYWD SET
        JRST    INST10          ;JUMP TO CHECK STR SIZE
        ANDI     Q2,ISKEY        ;GET KYWD FROM TBL
        LSH     Q2,-6            ;KEYWORD
        HRLM    Q2,VKEY(P1)     ;SET KEYWORD
        JRST    INST10          ;JUMP TO CHECK SIZE
;   THE FOLLOWING CODE IS ENTERED IF THE VARIABLE BEING 
;   INSTALLED IS AN OPERATOT.
;
INSTOP: HRLZI   Z,OPFLAG        ;OPERATOT FLAG
        MOVEM   Z,VFLAGS(P1)    ;SET VFLAGS IN VAR BLK
        ANDI     Q2,OPNO         ;OPERATOR NUMBER
        MOVEI   Q3,ISPREC       ;ADDR OF OPER. PREC. TBL
        ADD     Q3,Q2           ;ADDR OF OPER. PRECEDENCES
        MOVE    Q3,0(Q3)        ;OPERATOR PRECEDENCES
        HLLM    Q3,LPREC(P1)    ;SET LEFT PRECEDENCE IN VAR BLK
        HRLM    Q3,RPREC(P1)    ;SET RIGHT   "         "
        HLRZ    Z,Q1            ;VUNARY FROM DOPE VECTOR
        CAIN    Z,0             ;SKIP IF NOT 0
        MOVEI   Z,UNDEF$        ;UNDEFINED VUNARY
        HRRM    Z,VUNARY(P1)    ;LOAD VUNARY IN VAR BLK
        HRRZ    Z,Q1            ;VBINRY FROM DOPE VECTOR
        CAIE    Z,0             ;SKIP IF UNDEF VBINRY
        HRRM    Z,VBINRY(P1)    ;LOAD VBINRY IN VAR BLK

	JRST	INSTOK		; GO RETURN
        SUBTTL  LOCATE - TO LOCATE A STRING IN THE SYMBOL TABLE
; CALLING SEQUENCE :
;
;		 PUSH STRING DESCRIPTOR ONTO STACK(MUST BE STRING)
;		 JSP	 TLINK,LOCATE
;                FAIL RETURN    - STACK POPPED
;                SUCCESS RETURN - STACK POPPED,ADDRESS OF VARIABLE 
;                                 IN REGISTER 0.
;
LOCATE::
        MOVEM   TLINK,TLSAV##     ;SAVE TLINK
        JSP     TLINK,EQINIT##  ;INITIALIZE FOR EQUAL
        JRST    FAILOC          ;ERROR - BAD STRING DESCR.
        PUSH    STACK,FLAT      ;1ST WD OF STR DESCR.
        PUSH    STACK,FLAT+1    ;2ND WD OF STR DESCR.
        JSP     QLINK,HASHNO##  ;GET HASH NUMBER
	MOVE	T2,Z            ;HASH NO. FOR DIVIDE
	IDIV	T2,LVTBL	;GET HASH ENTRY
	MOVE	T2,VTABLE 	;ADDR OF FIRST WD IN HASH TBL
	ADD	T2,T3		;ADDR OF HASH TBL ENTRY
	MOVE	T3,0(T2)	;ADDR OF 1ST VAR BLK IN CHAIN
	JUMPE	T3,NOHASH	;JUMP IF CHAIN EMPTY
	$PUSH	<P1,P2>		;SAVE PREGS
	MOVE	P2,T3		;SAVE ADDR OF VAR BLK
LOCLUP:	PUSH	STACK,VNAME(P2)	;1ST WORD OF VAR BLK DESCR.
	PUSH	STACK,VNAME+1(P2)	;2ND WORD OF VAR BLK DESCR.
	JSP	TLINK,EQUAL##	;ARE NAMES EQUAL
	SKIPA	0		;SKIP IF NOT EQUAL
	JRST	YESLOC		;JUMP IF STRING LOCATED
	MOVEI	T3,VLINK(P2)	;ADDR OF VLINK TO NXT VAR BLK
	HRRZ	P2,VLINK(P2)	;ADDR OF NXT VAR BLK
	JUMPN	P2,LOCLUP	;JUMP IF ANOTHER VAR ON CHAIN
	$POP	<P2,P1>		; RESTORE P REGS
	MOVE	Z,T3		;ADDR OF VLINK
	JRST	@TLSAV		;FAIL RETURN - NOT LOCATE
YESLOC: MOVE    TLINK,TLSAV     ;RESTORE TLINK
	MOVE	T2,P2		 ;ADDR OF VAR BLK
	$POP	<P2,P1>		;RESTORE P REGS
	MOVE	Z,T2		 ;Z=ADDR OF VAR BLK
	JRST	1(TLINK)	;SUCCESS RETURN
FAILOC: SETZ    T2,             ;INDICATOR FOR INSTAL
	SUB	STACK,[XWD 2,2]	;POP TOP TWO VALUES
NOHASH:	MOVE	Z,T2		 ;ADDR TO LINK NEW VAR BLK
        JRST    @TLSAV          ;FAIL RETURN - NOT LOCATED


UNDEF::	HRRZ	Q1,IGNOP##+2	; GET ADDRESS OF VFUNC FIELD

	MOVEI	Q3,VNAME-VFUNC(Q1) ; POINT TO VNAME FIELD
	HLRZ	Q2,0(Q3)	; CHECK DT
	CAIE	Q2,SDT		; AT VNAME - IS STRING?
	MOVEI	Q3,VNAME-VUNARY(Q1) ; NO, MUST HAVE BEEN UNY OP

	ERROR%	9,1
	END
    @'Ø