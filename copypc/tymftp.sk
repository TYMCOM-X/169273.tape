



                               File Transfer Protocol Specification                               File Transfer Protocol Specification                               File Transfer Protocol Specification                               File Transfer Protocol Specification


                                                  Document Number 1

                                                   March 26th, 1986

                                             Paul A. Crable, editor


                                         Workstation Products Unit,
                                                  INFOTYM Division,
                              Tymshare, a McDonnell Douglas Company
                                                  Mail Stop VG2-B01
                                           20705 Valley Green Drive
                                           Cupertino, CA 94014-1794
                              ONTYME STD.P/CRABLE, VMMAIL CRABLE:40
                                                     (408) 446-6573









                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  PREFACE  _______  PREFACE  PREFACE  PREFACE

  The technical material in this document was provided by the fol-
  lowing individuals:

      Rob Larson

      Curt Truman

      Scott Daniels

      Robert Klute

  I (Paul Crable) have reformatted the document.

  This document supercedes A Protocol for transferring data between                           ________________________________________
  computers, written by the above individuals, dated 13th of Decem-  _________
  ber 1982.  It was noted as the "Preliminary" version.  The tech-
  nical substance in this document should be the same as that in
  the superceded version.  I am reissuing this document as the
  first step to bringing the technical information up to date.












  Preface                                                        ii

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  CONTENTS  ________  CONTENTS  CONTENTS  CONTENTS

  Introduction   . . . . . . . . . . . . . . . . . . . . . . . .  1  Introduction   . . . . . . . . . . . . . . . . . . . . . . . .  1  Introduction   . . . . . . . . . . . . . . . . . . . . . . . .  1  Introduction   . . . . . . . . . . . . . . . . . . . . . . . .  1
  Document overview.   . . . . . . . . . . . . . . . . . . . . .  1
  Enhancements, revisions, and complaints.   . . . . . . . . . .  2

  Definitions  . . . . . . . . . . . . . . . . . . . . . . . . .  3  Definitions  . . . . . . . . . . . . . . . . . . . . . . . . .  3  Definitions  . . . . . . . . . . . . . . . . . . . . . . . . .  3  Definitions  . . . . . . . . . . . . . . . . . . . . . . . . .  3
  The target data transfer environment   . . . . . . . . . . . .  4
    Definition of the target machine   . . . . . . . . . . . . .  4
      Tymshare Environment   . . . . . . . . . . . . . . . . . .  4
      Non-Tymshare Environment   . . . . . . . . . . . . . . . .  4
    Definition of the target transmittable characters  . . . . .  5

  The File Transfer Protocol   . . . . . . . . . . . . . . . . .  6  The File Transfer Protocol   . . . . . . . . . . . . . . . . .  6  The File Transfer Protocol   . . . . . . . . . . . . . . . . .  6  The File Transfer Protocol   . . . . . . . . . . . . . . . . .  6
    The data transfer as a lower-level process   . . . . . . . .  6
  Separating "Protocol" from "Non-Protocol" Data Traffic   . . .  6
    Identifying Protocol Traffic   . . . . . . . . . . . . . . .  6
    Identifying Non-Protocol Traffic   . . . . . . . . . . . . .  6
      Byte Streams Outside Valid Packet Boundaries   . . . . . .  6
      Handling Non-Protocol Traffic  . . . . . . . . . . . . . .  7
  Functions of Protocol Levels Defined   . . . . . . . . . . . .  7
    Diagramatic View of All Levels   . . . . . . . . . . . . . .  7
      Conformance with the ISO Model   . . . . . . . . . . . . .  8
      Flow Control Process   . . . . . . . . . . . . . . . . . .  8
    Transport Packet Level Specifics   . . . . . . . . . . . . .  9
      Inbound Traffic  . . . . . . . . . . . . . . . . . . . . .  9
      Outbound Traffic   . . . . . . . . . . . . . . . . . . . .  9
    Binary Packet Level Specifics  . . . . . . . . . . . . . . . 10
      Inbound Traffic  . . . . . . . . . . . . . . . . . . . . . 10
      Outbound Traffic   . . . . . . . . . . . . . . . . . . . . 11
    Valid packet level specifics:  . . . . . . . . . . . . . . . 12
      Inbound Traffic  . . . . . . . . . . . . . . . . . . . . . 12
      Outbound Traffic   . . . . . . . . . . . . . . . . . . . . 13
    Application packet level specifics:  . . . . . . . . . . . . 14
      Inbound traffic and outbound traffic:  . . . . . . . . . . 14
  Error detection  . . . . . . . . . . . . . . . . . . . . . . . 14
    Error detection responsibilities in general  . . . . . . . . 14
      Transport packet level   . . . . . . . . . . . . . . . . . 14
      Binary packet level  . . . . . . . . . . . . . . . . . . . 14
      Valid packet level   . . . . . . . . . . . . . . . . . . . 15
      Application packet level   . . . . . . . . . . . . . . . . 15
    Binary packet level error detection techniques:  . . . . . . 15
      Detecting the alteration of protocol traffic using
       checksums:  . . . . . . . . . . . . . . . . . . . . . . . 15
      Detecting the loss of protocol traffic using packet
       identifiers:  . . . . . . . . . . . . . . . . . . . . . . 16
      Detecting the loss of protocol traffic using timeouts:   . 16
  Error recovery   . . . . . . . . . . . . . . . . . . . . . . . 16
    Definition of ACK, NAK, and RFR packets:   . . . . . . . . . 17
      Positive acknowledgement (ACK):  . . . . . . . . . . . . . 17
      Negative acknowledgement (NAK):  . . . . . . . . . . . . . 17
      Request For Response (RFR):  . . . . . . . . . . . . . . . 17

  Contents                                                      iii

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

    Rules for implementing error recovery procedures:  . . . . . 18
      Rules concerning Packet IDentifiers (PID):   . . . . . . . 18
      Rule concerning positive acknowledgements, or ACKs:  . . . 18
      Rule concerning negative acknowledgements, or NAKs:  . . . 18
      Rules concerning timeouts and timeout counters:  . . . . . 19
      Rules concerning requests for a response, or RFRs  . . . . 19
  Packaging rules for valid packet level processing.   . . . . . 19
    Position and meaning of the data class byte:   . . . . . . . 19
    Position and meaning of the data header byte:  . . . . . . . 20
    A packaging example  . . . . . . . . . . . . . . . . . . . . 21
  Definition of session startup and synchronization tasks.   . . 22
    Configuration table in use at startup:   . . . . . . . . . . 22
    Which process is by the default the "requestor"?   . . . . . 23
    Which process is by default the "server"?  . . . . . . . . . 23
    Responsibilities of the requestor at startup:  . . . . . . . 23
    Responsibilities of the server at startup:   . . . . . . . . 23
  Transmission configuration selection and negotiation.  . . . . 24
    The transmission configuration baseline  . . . . . . . . . . 24
    Negotiating a new configuration  . . . . . . . . . . . . . . 24
  Encoding/decoding specification  . . . . . . . . . . . . . . . 24
    Which bytes must be encoded:   . . . . . . . . . . . . . . . 24
    Definition of encoding/decoding algorithm:   . . . . . . . . 25
      While outputting bytes:  . . . . . . . . . . . . . . . . . 25
      While inputting bytes:   . . . . . . . . . . . . . . . . . 26
  Checksum algorithm specification.  . . . . . . . . . . . . . . 26
    The baseline checksum algorithm:   . . . . . . . . . . . . . 26
    Position of checksum in binary packet:   . . . . . . . . . . 27
    Switching to a different algorithm:  . . . . . . . . . . . . 27

  Appendix A. Data Class byte value table.   . . . . . . . . . . 28  Appendix A. Data Class byte value table.   . . . . . . . . . . 28  Appendix A. Data Class byte value table.   . . . . . . . . . . 28  Appendix A. Data Class byte value table.   . . . . . . . . . . 28
      Data Class byte format:  . . . . . . . . . . . . . . . . . 28
      Data Class byte values:  . . . . . . . . . . . . . . . . . 28

  Appendix B. Data Header byte value table.  . . . . . . . . . . 30  Appendix B. Data Header byte value table.  . . . . . . . . . . 30  Appendix B. Data Header byte value table.  . . . . . . . . . . 30  Appendix B. Data Header byte value table.  . . . . . . . . . . 30
      Data Header byte format:   . . . . . . . . . . . . . . . . 30
      Case value of ABC:   . . . . . . . . . . . . . . . . . . . 30

  Appendix C. Link Control command table.  . . . . . . . . . . . 32  Appendix C. Link Control command table.  . . . . . . . . . . . 32  Appendix C. Link Control command table.  . . . . . . . . . . . 32  Appendix C. Link Control command table.  . . . . . . . . . . . 32
      Link Control byte format:  . . . . . . . . . . . . . . . . 32
      Link Control byte values:  . . . . . . . . . . . . . . . . 32

  Appendix D. Application control command table  . . . . . . . . 34  Appendix D. Application control command table  . . . . . . . . 34  Appendix D. Application control command table  . . . . . . . . 34  Appendix D. Application control command table  . . . . . . . . 34
      Case value of command byte:  . . . . . . . . . . . . . . . 34
      Date format rules:   . . . . . . . . . . . . . . . . . . . 35

  Appendix E. Reply reason code table  . . . . . . . . . . . . . 37  Appendix E. Reply reason code table  . . . . . . . . . . . . . 37  Appendix E. Reply reason code table  . . . . . . . . . . . . . 37  Appendix E. Reply reason code table  . . . . . . . . . . . . . 37
      Case value of Reason Code:   . . . . . . . . . . . . . . . 37

  Appendix F. Description of AST files   . . . . . . . . . . . . 38  Appendix F. Description of AST files   . . . . . . . . . . . . 38  Appendix F. Description of AST files   . . . . . . . . . . . . 38  Appendix F. Description of AST files   . . . . . . . . . . . . 38

  Appendix G. Standard Configuration Tables  . . . . . . . . . . 40  Appendix G. Standard Configuration Tables  . . . . . . . . . . 40  Appendix G. Standard Configuration Tables  . . . . . . . . . . 40  Appendix G. Standard Configuration Tables  . . . . . . . . . . 40
  Table "A"- Baseline  . . . . . . . . . . . . . . . . . . . . . 40
  Table "B"  . . . . . . . . . . . . . . . . . . . . . . . . . . 40


  Contents                                                       iv

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

+ Appendix H. Diagram of Packet Packaging  . . . . . . . . . . . 42  Appendix H. Diagram of Packet Packaging  . . . . . . . . . . . 42  Appendix H. Diagram of Packet Packaging  . . . . . . . . . . . 42  Appendix H. Diagram of Packet Packaging  . . . . . . . . . . . 42



















  Contents                                                        v

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  INTRODUCTION  ____________  INTRODUCTION  INTRODUCTION  INTRODUCTION

  DOCUMENT OVERVIEW.  __________________  DOCUMENT OVERVIEW.  DOCUMENT OVERVIEW.  DOCUMENT OVERVIEW.

  This document is intended to aid in the design and implementation
  of a set of programs capable of transferring information from one
  computer to another.  It has not been a goal to teach people what
  a protocol is and what it is used for, but rather to define one
  that is useful.  In the hopes of getting many systems conversing
  in this protocol, the designers have used the following concepts
  as guiding principles:

     The protocol must be implementable.  The designers attempted
      to specify a protocol implementable in a high level language
      on a microcomputer, and equally implementable in any language
      on a powerful mainframe computer.  A major goal has been to
      provide a means for processes with widely diverse constraints
      and capabilities to communicate in the most effective manner.

     The protocol must be flexible and open ended.  Provisions
      have been included for future enhancements to the protocol
      itself.  Implementations may vary in complexity, but each
      must support a minimal subset of the available features.
      Implementations may ignore or reject features not included in
      the minimal subset, and they may choose to implement any fea-
      tures not provided for in the minimal subset.

     The protocol must ensure the integrity of data.  Procedures
      have been specified to allow a process to determine whether
      transmitted data was received as transmitted, and to allow a
      process to request the retransmission of erroneous data.

     The protocol must satisfy efficiency contraints.  Different
      implementations may have diverse transmission capabilities,
      but each implementation may choose the method of controlling
      the flow of data.  In addition, efforts have been made to
      reduce the number of interactions required and the quantity
      of data that must be transmitted.

     The protocol must maintain the accuracy of data from machine
      to machine.  Files copied between similar or dissimilar types
      of machines must retain a meaningful structure and content.
      The ability to transform diverse record and file structures
      to that of the destination structure was provided for.




  Introduction                                                    1

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  ENHANCEMENTS, REVISIONS, AND COMPLAINTS.  ________________________________________  ENHANCEMENTS, REVISIONS, AND COMPLAINTS.  ENHANCEMENTS, REVISIONS, AND COMPLAINTS.  ENHANCEMENTS, REVISIONS, AND COMPLAINTS.

  One of the major goals of the designers of the protocol is to get
  the protocol implemented on as many systems as possible.  This is
  only possible if people working on these systems take part in the
  design effort.  For this reason, and for many other valid rea-
  sons, readers or users of this document are encouraged to make
  comments to the designers of the protocol concerning inprovements
  in terms of the generality and functionality of the protocol or
  document.  The designers are open to any comment or critism on
  any subject.

  Phone numbers are all (408)446-xxxx      ONTYME userids:
     Paul Crable       -6573                  STD.P/CRABLE
     Robert Klute      -7363                  INSD.R/KLUTE
     Rob Larson        -6579                  STD.R/LARSON
     Curt Truman       -6832                  INSD.C/TRUMAN

  Although each of the members of the design team should be able to
  answer  telephone  questions,  written  comments  are  preferred.
  Copies of  the document  are available in  hard copy  or computer
+ text format.   To obtain a computer  text copy, attach  to SYNDEV
+ (System 40) with read password TGRAPH11 then enter
+           SCRIPTVS COMFTP (OPTIONS(COMFTP)
+ Or simply copy  the file COMFTP LISTING  (including carriage con-
+ trol).  Written comments and requests for copies may be sent to:

      Paul Crable
      InfoTym Division (VG2-B01)
      Tymshare, Inc.
      20705 Valley Green Drive
      Cupertino, CA    95014








  Introduction                                                    2

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  DEFINITIONS  ___________  DEFINITIONS  DEFINITIONS  DEFINITIONS

  Definitions of important terms.

  protocol        a basic procedure or set of rules that governs  protocol  protocol  protocol
                  and controls the flow of messages between comput-
                  ers.  Also, a set of conventions between communi-
                  cating processes on the format and content of
                  messages to be exchanged.

  process         a computer system capable of initiating or  process  process  process
                  receiving data, and manipulating or responding to
                  received data.  There must be a process that can
                  communicate in protocol mode at both ends of a
                  file transfer.

  protocol mode   when two processes start to communicate using  protocol mode  protocol mode  protocol mode
                  functions and commands provided by the protocol,
                  they are said to be in protocol mode.  Note that
                  while the processes are in protocol mode,
                  non-protocol data may still be traded.

  requestor       the process in charge is the requestor.  The  requestor  requestor  requestor
                  requestor is, in general, the process with an
                  intent to transfer data.

  server          the process being commanded is the server.  The  server  server  server
                  server is charged with responding to the
                  requestor's commands, which will implement the
                  requestor's intent to move data.

  byte            a sequence of adjacent bits operated on as a  bytyte  byte
                  unit.  Bytes referred to in this document have 8
                  bits.  Bytes that are received or transmitted
                  will be treated as if their left- most bit is the
                  high-order bit.  If a 16-bit word is sent as a
                  byte pair, the first byte will be treated as the
                  high-order byte.

  traffic         the byte streams being exchanged between two pro-  traffic  traffic  traffic
                  cesses.  Traffic may be protocol or non-protocol,
                  incoming or outgoing, valid or garbage, etc.

  protocol level  the functions performed by a process in order to  protocol level  protocol level  protocol level
                  implement the protocol have been divided into
                  four levels.  Each has a distinct functional
                  responsibility defined.

  packet          each of the protocol levels works with a packet  packet  packet  packet
                  of data, packaging or unpackaging the packet
                  according to a defined set of rules, then passing


  Definitions                                                     3

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

                  the resulting packet on to the next level below
                  or above it in the hierarchy.

  package         use package as a verb, that is, each level pack-  package  package  package
                  ages data into or unpackages data from a speci-
                  fied packet format.


  THE TARGET DATA TRANSFER ENVIRONMENT  ____________________________________  THE TARGET DATA TRANSFER ENVIRONMENT  THE TARGET DATA TRANSFER ENVIRONMENT  THE TARGET DATA TRANSFER ENVIRONMENT


  Definition of the target machine  ________________________________  Definition of the target machine  Definition of the target machine  Definition of the target machine


  Tymshare Environment  Tymshare Environment  Tymshare Environment  Tymshare Environment

  The first level is defined as those hardware and software combi-
  nations that are being used at Tymshare, including: mainframes
  running Tymshare operating systems (IBM 370, DEC 10 and 20,
  ONTYME engine); microcomputers and associated operating systems
  supported by Tymshare (DEC PWS I/II and TI Model 1100 running
  under P-system, Model 1100 under TPL, IBM PC under MSDOS); and
  other mainframe/mini/micro computers in Tymshare's product lines.
  Communication media include: TYMNET; direct machine-to-machine or
  dial-up connections.  The protocol is designed to be implementa-
  ble on any reasonable combinations of machines/communication
  media at this level.

  Non-Tymshare Environment  Non-Tymshare Environment  Non-Tymshare Environment  Non-Tymshare Environment

  The second level is defined as those configurations of hardware
  and software that are not in use at Tymshare, but are important
  or widespread enough in use to warrant consideration. These
  include: mainframes running standard operating systems (IBM, DEC,
  etc.); microcomputers or operating systems not currently in use
  at Tymshare; and mainframe/mini/micro computers that implement
  applications outside Tymshare's product line.  The communication
  media may include: foreign networks such as ARPANET; local area
  network packages.  The protocol is designed with non-Tymshare
  needs in mind, but is not necessarily implementable in all situ-
  ations.



  Definitions                                                     4

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  Definition of the target transmittable characters  _________________________________________________  Definition of the target transmittable characters  Definition of the target transmittable characters  Definition of the target transmittable characters

  A baseline character set is defined that excludes characters that
  may pose problems for machines included in the first-level imple-
  mentation, e.g., the XOFF character transmitted openly within a
  transport packet would be acted upon by TYMNET.  The baseline
  definition is defined in Table "A" of "Appendix G. Standard Con-
  figuration Tables" on page 40.  Additional configuration tables
  and values are provided, and processes may negotiate a change in
  the baseline set or a change to a different table entirely.  A
  baseline method for the encoding/decoding of values not in the
  transmittable set is defined.















  Definitions                                                     5

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  THE FILE TRANSFER PROTOCOL  __________________________  THE FILE TRANSFER PROTOCOL  THE FILE TRANSFER PROTOCOL  THE FILE TRANSFER PROTOCOL

  The data transfer as a lower-level process  __________________________________________  The data transfer as a lower-level process  The data transfer as a lower-level process  The data transfer as a lower-level process

  The assumption made in this document is that there will be two
  processes using the protocol in order to accomplish a data trans-
  fer.  Examples of this situation are: systems that automatically
  upload data generated by data entry systems; a human user moving
  a text file between machines; or a distribution system updating
  program file libraries on multiple hosts.  Because some tasks
  must be accomplished outside protocol control, there must be a
  program, a terminal emulator, responsible for the following:
  accessing the communication medium and the computers need to
  transfer the data, starting the process on each computer that
  implements the protocol, and, when the transfer is complete, dis-
  connecting both the computers and the communications medium in an
  orderly fashion.  Because these tasks are generally implementa-
  tion dependent they are considered outside the scope of the pro-
  tocol definition.

  SEPARATING "PROTOCOL" FROM "NON-PROTOCOL" DATA TRAFFIC  ______________________________________________________  SEPARATING "PROTOCOL" FROM "NON-PROTOCOL" DATA TRAFFIC  SEPARATING "PROTOCOL" FROM "NON-PROTOCOL" DATA TRAFFIC  SEPARATING "PROTOCOL" FROM "NON-PROTOCOL" DATA TRAFFIC


  Identifying Protocol Traffic  ____________________________  Identifying Protocol Traffic  Identifying Protocol Traffic  Identifying Protocol Traffic

  The byte values used to packetize, or delimit, protocol traffic
  are specified in "Appendix G. Standard Configuration Tables" on
  page 40, and may be redefined at runtime.  There are two byte
  values used: the header, which identifies the beginning of a
  transport packet; and the trailer, which identifies the end of a
  transport packet.  "Transport Packets" are defined as byte
  streams of protocol traffic, consisting of a header, the bytes of
  data being transferred, and a trailer.

  Identifying Non-Protocol Traffic  ________________________________  Identifying Non-Protocol Traffic  Identifying Non-Protocol Traffic  Identifying Non-Protocol Traffic


  Byte Streams Outside Valid Packet Boundaries  Byte Streams Outside Valid Packet Boundaries  Byte Streams Outside Valid Packet Boundaries  Byte Streams Outside Valid Packet Boundaries

  The definition of a transport packet allows a process to deter-
  mine whether a stream of bytes can be collected as a packet of
  data.  There may be, however, byte streams found outside the val-
  id packet boundaries:

  The File Transfer Protocol                                      6

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  Valid Non-Protocol Traffic. Terminal control sequences, user  Valid Non-Protocol Traffic.  Valid Non-Protocol Traffic.  Valid Non-Protocol Traffic.
  input, uncontrollable machine messages ("host going down"), etc.

  Invalid Non-Protocol Traffic. Garbled forms of valid packets.  Invalid Non-Protocol Traffic.  Invalid Non-Protocol Traffic.  Invalid Non-Protocol Traffic.

  Invalid Protocol Traffic. Possible when:  Invalid Protocol Traffic.  Invalid Protocol Traffic.  Invalid Protocol Traffic.

  A Trailer Has Been Lost. If a process has received a header and  ________________________
  has begun collecting the bytes received up to the trailer, a lost
  trailer may cause the process to have to deal with a transport
  packet that is longer than the currently defined maximum (see "
  The transmission configuration baseline" on page 24).  Even if
  all of the bytes received up to the next trailer can be col-
  lected, at least one transport packet has been lost.

  A Header Has Been Lost. In this situation, the traffic is valid  _______________________
  protocol traffic, but is not recognizable as such.  The receipt
  of the lost header's trailer may not be noticed, as the trailer
  may be used in non-protocol traffic.  The receipt of the next
  packet's header will not in itself signify an error, in that a
  header is expected.  However, since the identifier of the next
  packet will be out of sequence, the process will deduce that at
  least one transport packet has been lost.

  Handling Non-Protocol Traffic  Handling Non-Protocol Traffic  Handling Non-Protocol Traffic  Handling Non-Protocol Traffic

  All non-protocol traffic must be handled in some way by the ter-
  minal emulator, whether this means sending it to the screen, a
  file, the printer, the bit bucket, etc.

  FUNCTIONS OF PROTOCOL LEVELS DEFINED  ____________________________________  FUNCTIONS OF PROTOCOL LEVELS DEFINED  FUNCTIONS OF PROTOCOL LEVELS DEFINED  FUNCTIONS OF PROTOCOL LEVELS DEFINED


  Diagramatic View of All Levels  ______________________________  Diagramatic View of All Levels  Diagramatic View of All Levels  Diagramatic View of All Levels

  The diagram below shows the levels as described in the following
  pages.  Each level, in abstract terms, converses only with its'
  parallel level.  In practice, all communication in protocol mode
  must travel down through the lower levels, through the medium,
  and then up to the same level on the other end.




  The File Transfer Protocol                                      7

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

+      REQUESTOR                                        SERVER
+
+ +------------------+                           +------------------+
+ ^   Application    ^ < send me file FOO.DAT  > ^    Application   ^
+ ^     Packets      ^ <reset to link baseline > ^      Packets     ^
+ +------------------+                           +------------------+
+          ^                                              ^
+          ^                                              ^
+ +------------------+                           +------------------+
+ ^      Valid       ^ <send mode, file=FOO.DAT> ^       Valid      ^
+ ^     Packets      ^ <  RESET, Table = "A"   > ^      Packets     ^
+ +------------------+                           +------------------+
+          ^                                              ^
+          ^                                              ^
+ +------------------+                           +------------------+
+ ^     Binary       ^ <  packet #N received   > ^      Binary      ^
+ ^     Packets      ^                           ^      Packets     ^
+ +------------------+                           +------------------+
+          ^                                              ^
+          ^                                              ^
+ +------------------+                           +------------------+
+ ^    Transport     ^ <header, bytes, trailer > ^     Transport    ^
+ ^     Packets      ^                           ^      Packets     ^
+ +------------------+                           +------------------+
+          ^                                              ^
+          ^                                              ^
+     +--------------------------------------------------------+
+     ^                 Communications Medium                  ^
+     +--------------------------------------------------------+

+ Also refer to "Appendix H. Diagram of Packet Packaging" for a
+ diagram of packet packaging

  Conformance with the ISO Model  Conformance with the ISO Model  Conformance with the ISO Model  Conformance with the ISO Model

  These "levels" very loosley correspond to the "layers" defined in
  the Open Systems Interconnection Reference Model.  The lowest
  three layers specified under the ISO model (physical, data link,
  network) are not considered in this model.  This discussion only
  pertains to the higher four levels, which range in function from
  access to the communication medium to protocol commands used in
  transferring files.

  Flow Control Process  Flow Control Process  Flow Control Process  Flow Control Process

  Some of the following sections refer to "Flow Control Process".
  This is a generic name for that portion of a process that handles


  The File Transfer Protocol                                      8

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  error detection and recovery by keeping track of packets that
  have been sent, received, lost, garbled during transmission, or
  improperly formatted.  The rules and regulations governing the
  flow control process are found in the "Error detection" and "Er-
  ror Recovery" sections.

  Transport Packet Level Specifics  ________________________________  Transport Packet Level Specifics  Transport Packet Level Specifics  Transport Packet Level Specifics


  Inbound Traffic  Inbound Traffic  Inbound Traffic  Inbound Traffic

  This level is responsible for collecting protocol traffic as it
  comes in on the communications medium.  This level may or may not
  be a part of a terminal emulator process.  When a header is
  received, this level must collect bytes as they are received,
  until the packet's trailer is received.  Those bytes received
  that are in an encoded format must be decoded before being dealt
  with.  This level should be able to handle the situation where a
  packet becomes larger than the maximum transport packet size (be-
  fore decoding) due to the loss of a trailer.

  Format of input:

  packet header    +   transferred data   +    packet trailer

  /lead-in byte/     /encoded byte stream/     /end-packet byte/

  Processing:
    IF receive header THEN
       receive and, if necessary, decode byte stream
       IF receive trailer before MAX passed THEN
          save byte stream
       ELSE
          flow Control Process

  Format of output:
    transferred data

  /decoded byte stream/

  Outbound Traffic  Outbound Traffic  Outbound Traffic  Outbound Traffic

  This level is responsible for transmitting protocol traffic over
  the communications medium.  When a binary packet is being trans-
  mitted, each byte in it must be examined to determine whether
  its' value is one that must be encoded first.  The packet header

  The File Transfer Protocol                                      9

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  is transmitted, followed by bytes being transferred (any may be
  encoded), followed by the trailer.  This level must only send as
  many bytes in each packet (after encoding) as can be received as
  a whole by the transport level at the other end.  This maximum
  transport packet size may be respecified by either side if the
  baseline number is not adequate or efficient.

  Format of input:
    data to be transferred

  /un-encoded byte stream/

  Processing
    send header
    WHILE byte to send DO
       perform encoding process if necessary
       send byte(s)
    send trailer

  Format of output:
  packet header    +   transferred data   +   packet trailer

  /lead-in byte/     /encoded byte stream/   /end-packet byte/

  Binary Packet Level Specifics  _____________________________  Binary Packet Level Specifics  Binary Packet Level Specifics  Binary Packet Level Specifics


  Inbound Traffic  Inbound Traffic  Inbound Traffic  Inbound Traffic

  Packets may be of two flavors at this level:

     flow control (note that flow control packets do not have a
      PID), and,

     data being transferred (which may consist of commands or
      data, and each data packet must have a unique PID).

  When a process receives a packet from the Transport level, it
  must first find whether the packet was altered in route.  This is
  done by comparing the stored checksum (in last 2 bytes of the
  packet) to a computed value, using an algorithm that is applied
  to the remaining bytes in the packet.  If the checksum is OK, the
  packet type byte (PTC) in the first byte will indicate whether
  the packet is flow control or data.  Data (but not flow control)
  packets have a packet identifier value (PID) in the second byte.
  When this level receives a flow control packet, it will perform
  the set of functions required by the values in it.  When this
  level receives a packet of transferred data, it will pass the
  packet to the valid packet level.  The detection of transmission

  The File Transfer Protocol                                     10

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  errors and their resolution is the responsibility of this level,
  so the Valid Packet level only receives packets that are in
  sequence and that have been validated as correct.
  Format of input:
  transferred data          OR         flow control values

  /PTC byte [+ PID byte] + transferred bytes + checksum bytes/

  Processing
    calculate checksum using all but checksum bytes
    IF checksum = BAD THEN
       flow control process: ERROR
    ELSE
       IF packet-type = flow control (ACK, NAK, RFR) THEN
          flow control process: UPDATE
       ELSE
          IF PID = out of sequence THEN
             flow control process: may be ERROR
          ELSE
             flow control process: OK
             strip off PID
             strip off checksum
             pass on remaining bytes

  Format of output:

          packaged data bytes

          /data or commands/

  Outbound Traffic  Outbound Traffic  Outbound Traffic  Outbound Traffic

  The two flavors of outbound traffic correspond to the inbound
  traffic:

     flow control (note that flow control packets do not have a
      PID), and,

     data being transferred (which may consist of commands or
      data, and each data packet must have a unique PID).

  Flow control packets may have to be generated in response to
  packets of transferred data being received (or lost), and/or in
  response to the receipt of flow control packets.  Packets of data
  to be transferred are input from the valid packet level.  Both
  types are assigned a PTC, but only data packets are assigned a
  PID.  A checksum is generated and stored in the packet regardless
  of packet type.  The completed packet is turned over to the
  transport level for transmission.


  The File Transfer Protocol                                     11

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  Format of input:
    packaged data bytes

    /data or commands/

  Processing:
    IF responding to flow control THEN
       generate flow control packet
       assign PTC
    ELSE
       assign PTC
       assign PID
    generate checksum
    assemble byte stream

  Format of output:

   transferred data          OR        flow control values

   /PTC byte [+ PID byte] + transferred bytes + checksum bytes/

  Valid packet level specifics:  _____________________________  Valid packet level specifics:  Valid packet level specifics:  Valid packet level specifics:


  Inbound Traffic  Inbound Traffic  Inbound Traffic  Inbound Traffic

  The name of this level implies that packets that have gotten this
  far have been validated, that is, received in order without
  errors. This level's function is to unpackage packets of data
  bytes that have been received, using specific rules.  After the
  transferred data bytes have been unpackaged, this level's respon-
  sibilities become implementation- dependent.  Some may desire
  that this level be able to recognize data destined for different
  processes at the application level and send the packet to the
  appropriate process.  Others may wish only to hand the packet
  intact to the application level and have it determine the type of
  process that should act upon the data.






  The File Transfer Protocol                                     12

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  Format of input:

    packaged data bytes

  /data class byte + data header + data or command
       [ + data header]/

  Processing:

    unpackage data bytes

  Format of output:

    data or command

    /some number of bytes, which may be text or coded values, and which
     may include the data class byte if the application level does all
     of the handling of different types of data or commands/


  Outbound Traffic  Outbound Traffic  Outbound Traffic  Outbound Traffic

  This level is responsible for packaging data and command bytes
  into a specified format.  Additional processing is implementa-
  tion-dependent, in that some implementations may have this level
  accept packets from more than one process at the application lev-
  el, while others may want the application level to handle all
  combinations of data or commands from multiple processes and act
  as the sole interface between multiple processes and the valid
  packet level.

  Format of Input:
    data or command

    /some number of bytes, which may be text or coded values/

  Processing
    package data bytes

  Format of output:
    packaged data bytes

    /data class byte + data header byte + data or command
  [+ data header]/



  The File Transfer Protocol                                     13

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  Application packet level specifics:  ___________________________________  Application packet level specifics:  Application packet level specifics:  Application packet level specifics:


  Inbound traffic and outbound traffic:  Inbound traffic and outbound traffic:  Inbound traffic and outbound traffic:  Inbound traffic and outbound traffic:

  The processing at this level is implementation dependent, in that
  it depends upon the placement of link and application processes.
  Some may choose to implement this level as separate processes
  that receive their input directly from a handler or switcher at
  the valid packet level.  Other implementors may choose to have
  this level consist of a handler that receives all packets from
  the valid packet level and does the switching of packets to the
  appropriate process.  Whichever method is chosen, the responsi-
  bility of this level is to implement a file transfer using link
  control and application control commands.  Additional responsi-
  bilities include: handling the file data that has been trans-
  ferred, converting values, accessing the operating system for
  information about files, interfacing to a program that uses the
  protocol processes to move its' files, and handling problems
  caused by improper or unimplemented requests received from the
  other end.

  ERROR DETECTION  _______________  ERROR DETECTION  ERROR DETECTION  ERROR DETECTION


  Error detection responsibilities in general  ___________________________________________  Error detection responsibilities in general  Error detection responsibilities in general  Error detection responsibilities in general


  Transport packet level  Transport packet level  Transport packet level  Transport packet level

  When a process is collecting a transport packet into a buffer and
  finds that it has received more bytes than the maximum transport
  packet size because the trailer has been lost, it can assume that
  the entire packet is invalid and throw it away.  If it throws the
  packet away, the binary packet level must assume responsibility
  for detecting that the packet was lost in transit.

  Binary packet level  Binary packet level  Binary packet level  Binary packet level

  Each packet of commands or data to be transmitted passes through
  this level, and is assigned a packet identifier (PID).  Each
  packet is assigned a packet type character (PTC), and each packet
  is assigned a checksum value (using a specified checksum algo-
  rithm).  The checksum is used to verify that each packet was not

  The File Transfer Protocol                                     14

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  altered during transmission.  The PID is used to verify that all
  packets sent have been received.  In addition, timeouts may be
  used to detect the loss of one or more packets.  Each of these
  methods is discussed below.

  Valid packet level  Valid packet level  Valid packet level  Valid packet level

  As the name implies, all packets to reach this level have passed
  the checksum test and were received in the proper order.  This
  level should be prepared to handle errors caused by improper
  packaging and formatting of data or commands.  In addition, this
  level may or may not have the responsibility of dispensing all
  packets received to the process responsible for handling the
  packet.

  Application packet level  Application packet level  Application packet level  Application packet level

  This level must implement the conversation between the two proc-
  esses.  It should be able to respond with "I don't understand
  that" or "I don't know how to do that" when it is asked to do
  something it has not implemented.  This level is the interface to
  application program and to the application level of the other
  process, so it must be able to handle errors from both
  directions.

  Binary packet level error detection techniques:  _______________________________________________  Binary packet level error detection techniques:  Binary packet level error detection techniques:  Binary packet level error detection techniques:


  Detecting the alteration of protocol traffic using checksums:  Detecting the alteration of protocol traffic using checksums:  Detecting the alteration of protocol traffic using checksums:  Detecting the alteration of protocol traffic using checksums:

  When a packet reaches the binary packet level of the recipient, a
  checksum is calculated and compared to the stored value.  If the
  two values are equal, it should be true that the packet was not
  altered in transmission.  Each unaltered packet must at some time
  be acknowledged (ACKed) to notify the sender that the packet was
  received correctly.  If the checksum values don't match, none of
  the bytes may be presumed to be correct.  However, techniques
  useful for recovery are available, using the PID that was
  expected in the next packet received.



  The File Transfer Protocol                                     15

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  Detecting the loss of protocol traffic using packet identifiers:  Detecting the loss of protocol traffic using packet identifiers:  Detecting the loss of protocol traffic using packet identifiers:  Detecting the loss of protocol traffic using packet identifiers:


  When a packet is received without a checksum error: When a proc-  When a packet is received without a checksum error:  When a packet is received without a checksum error:  When a packet is received without a checksum error:
  ess is working in single outstanding packet mode, packets are
  received sequentially because the transfer will not proceed until
  each packet is received intact.  While in single outstanding
  mode: if packets #1, #2, and then #4 are received, a process may
  deduce that packet #3 was lost because the packets are not in
  sequential order.  The process should NAK the packet to inform
  the sender it was lost.  If a process is working in multiple out-
  standing packet mode, packets will not necessarily be received in
  order because a packet received out of order may be a packet pre-
+ viously NAKed.  While in multiple outstandingpacket mode: if
  packets #1, #2, and #4 are received without errors, and packet #3
  is received but must be NAKed, the next packet received may be #5
  or #3.

  When a packet is received with a checksum error: In this case,  When a packet is received with a checksum error:  When a packet is received with a checksum error:  When a packet is received with a checksum error:
  the PID may not be valid.  A process should have some idea, how-
  ever, of which PID was to be expected.  This expected value may
  be used to keep the flow of packets going.  The most logically
  simple thing to do may be to proceed as if the packet wasn't
  received and allow normal timeout processing to detect the error.

  Detecting the loss of protocol traffic using timeouts:  Detecting the loss of protocol traffic using timeouts:  Detecting the loss of protocol traffic using timeouts:  Detecting the loss of protocol traffic using timeouts:

+ A primary and important rule concerning the use of timeouts is
+ that at least one of the communicating processes must have imple-
  mented a form of timeout processing, either in the form of time
  counting, or in the form of event counting.  In situations where
  this condition cannot be met, processes may be unable to detect
  the loss of protocol traffic, or, whether the other process is
+ still alive.  A process that can do timeouts is able to monitor
+ how long it has waited for a response to a packet.  Such a proc-
  ess should also keep a timeout counter to enable it to decide
  that the whole thing is not working and quit.  The Error Recovery
  section discusses the use of timeouts and their place in the
  error recovery system.

  ERROR RECOVERY  ______________  ERROR RECOVERY  ERROR RECOVERY  ERROR RECOVERY




  The File Transfer Protocol                                     16

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  Definition of ACK, NAK, and RFR packets:  ________________________________________  Definition of ACK, NAK, and RFR packets:  Definition of ACK, NAK, and RFR packets:  Definition of ACK, NAK, and RFR packets:

  Three special purpose packets may be transmitted to aid in recov-
  ery from an error condition.   These packets are generated by the
  binary packet level.  They each have a packet type character
  (PTC), but they do not have a packet identifier because they are
  not acknowledged.  All packets are assigned a checksum value
  after they are completed.

  Positive acknowledgement (ACK):  Positive acknowledgement (ACK):  Positive acknowledgement (ACK):  Positive acknowledgement (ACK):

  /PTC  +  Packet_ID1  +  Packet_ID2  +  checksum/

  ACKs are sent to inform the sender of a packet that it was
  received without a checksum error.  During the discussion of
  error recovery, it is important to remember that when the proto-
  col says that an ACK be sent for any reason, the ACK must be an
  indication of the CURRENT state of affairs.  The value of Pack-
  et_ID1 always indicates the last packet correctly received, and
  further implies that all previously sent packets have also been
  received correctly.  Packet_ID2's value tells the sender the
  highest packet that it can send without waiting for another ACK.
  The difference between Packet_ID2 and Packet_ID1 is referred to
  as the receiver's "window".  A process running in the single out-
  standing packet mode (packets are acknowledged one-by-one) will
  send ACKs with Packet_ID2 equal to Packet_ID1 plus one, which
  results in a window size of 1.  A process running in the multiple
  outstanding packet mode will send ACKs with Packet_ID2 set equal
  to Packet_ID1 plus N, where N defines the number of packets that
  may be received as a group before acknowledgement processing
  takes place.

  Negative acknowledgement (NAK):  Negative acknowledgement (NAK):  Negative acknowledgement (NAK):  Negative acknowledgement (NAK):

  /PTC  +  Packet_ID1  +  checksum/

  Packet_ID1's value tells the sender that a packet must be
  retransmitted because it was not received correctly.

  Request For Response (RFR):  Request For Response (RFR):  Request For Response (RFR):  Request For Response (RFR):

  /PTC  +  checksum/



  The File Transfer Protocol                                     17

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  The RFR packet is only transmitted by the sender of a packet that
  has timed out waiting for an acknowledgement on the packet.  It's
  purpose is to inform the other process that the sender is waiting
  for the acknowledgement.  When a receiving process receives an
  RFR, it should treat it as a timeout indicator and follow the
  rules set forward in the next section for sending an acknowlege-
  ment.

  Rules for implementing error recovery procedures:  _________________________________________________  Rules for implementing error recovery procedures:  Rules for implementing error recovery procedures:  Rules for implementing error recovery procedures:


  Rules concerning Packet IDentifiers (PID):  Rules concerning Packet IDentifiers (PID):  Rules concerning Packet IDentifiers (PID):  Rules concerning Packet IDentifiers (PID):

  1.  PIDs range from ASCII SPACE (Hex 20) up to ASCII "z" (Hex
      7A).

  2.  The range of values is circular (SPACE > "z") and must be
      contiguous.

+ 3.  The range of PID's limits the number of packets that may be
+     outstanding (unacknowledged) to one half the size of the
+     range (baseline = X'2D' = 45).

  4.  Processes may redefine the PID range using link control com-
      mands.


  Rule concerning positive acknowledgements, or ACKs:  Rule concerning positive acknowledgements, or ACKs:  Rule concerning positive acknowledgements, or ACKs:  Rule concerning positive acknowledgements, or ACKs:

  A process receiving packets must ACK (where an ACK is defined as
  an indication of the CURRENT state of affairs) when:

     its' window is filled with valid packets.

     a packet already ACKed is received.

     a packet outside the current window is received.


  Rule concerning negative acknowledgements, or NAKs:  Rule concerning negative acknowledgements, or NAKs:  Rule concerning negative acknowledgements, or NAKs:  Rule concerning negative acknowledgements, or NAKs:

  Timeout rules and the number of outstanding packets control NAKs:
  In single outstanding packet mode, a packet in error would be
  NAKed right away because to be silent would cause the other proc-
  ess to time out.  In multiple outstanding packet mode, a packet


  The File Transfer Protocol                                     18

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  in error need not be NAKed until one of the processes has reached
  a timeout condition.

  Rules concerning timeouts and timeout counters:  Rules concerning timeouts and timeout counters:  Rules concerning timeouts and timeout counters:  Rules concerning timeouts and timeout counters:

  1.  In order to prevent "needless blocking" at least one of the
      two processes must implement either a time or event timeout
      mechanism.

  2.  Timeouts should be counted in order to give up when neces-
      sary.

  3.  A receiver starts its timer when a packet passing the check-
      sum test is received, and times out when it waits too long
      for such a packet.  When a receiver of packets times out, it
      must either send an ACK where Packet_ID1 is greater than in
      the last ACK, or NAK the packet with the lowest ID expected.
      It should then increment the timeout counter and restart the
      timer.

  4.  A sender turns off its' timer when it can send packets.  A
      sender restarts its' timer when it cannot send packets (a
      sender will get to this state when it is waiting for ack-
      nowledgedements of packets already sent).   A sender times
      out when it has waited too long for an acknowledgment on any
      previously sent packets.  When a sender has timed out, it
      must either transmit a RFR packet (request for response) or
      resend the lowest packet not yet acknowledged.


  Rules concerning requests for a response, or RFRs  Rules concerning requests for a response, or RFRs  Rules concerning requests for a response, or RFRs  Rules concerning requests for a response, or RFRs

  1.  A sender may send an RFR when it has timed out waiting for an
      acknowledgement on a packet sent.

  2.  A receiver that times out may not send an RFR, but may send
      an ACK or NAK, indicating the state it is currently in.


  PACKAGING RULES FOR VALID PACKET LEVEL PROCESSING.  __________________________________________________  PACKAGING RULES FOR VALID PACKET LEVEL PROCESSING.  PACKAGING RULES FOR VALID PACKET LEVEL PROCESSING.  PACKAGING RULES FOR VALID PACKET LEVEL PROCESSING.


  Position and meaning of the data class byte:  ____________________________________________  Position and meaning of the data class byte:  Position and meaning of the data class byte:  Position and meaning of the data class byte:

  Each packet of data passed between processes has data in it of a
  class, e.g., link control commands, application data, application

  The File Transfer Protocol                                     19

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  commands, etc.  Each packet must have a data class byte, because
  the end of a packet is the end of a data class.  When data of
  more than one class is sent in a packet, a End of Data Class data
  header marks the end of a class, and the new class is indicated
  by another data class byte.  The first byte of a valid packet
  contains the primary data class of the packet.  The data class
  byte table "Appendix A. Data Class byte value table." on page
  28shows the layout of fields within the the byte and the meaning
  of each field.

  Position and meaning of the data header byte:  _____________________________________________  Position and meaning of the data header byte:  Position and meaning of the data header byte:  Position and meaning of the data header byte:

  The primary use of a data header is to say "what follows is N
  bytes" of data.  This allows two different processes to ascertain
  the format of the data from the content of the data header.  A
  command, and data that may be associated with the command, can
  conceptually be thought of as a logical record in the same way as
  a file may have logical records in it.  The EOR data header is
  used to notify the recipient that a record has or has not yet
  ended, allowing it to reconstruct the bytes correctly.  Other
  data headers delimit data classes, indicate the end of a file,
  and allow data compression of various common values.  The data
+ header byte table, "Appendix B. Data Header byte value table." on
+ page 30, shows the layout of fields within the byte and the mean-
  ing of each field.










  The File Transfer Protocol                                     20

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  A packaging example  ___________________  A packaging example  A packaging example  A packaging example

  In the following example, a process is packaging application com-
  mands that are needed to send a file, and in addition, is packag-
  ing the data from the file, which consists of two 47-byte lines
  of text.

      Data Class for commands:

          What follows is command information
          Information belongs to Primary Application
          Generated by Requestor
          Advisory Information (could be changed to important)
          Command, reply is optional (could be changed to required)

      Commands to be sent:                    #of bytes for command

          Put yourself in Receive Mode        1
          What follows is file name           1 + "FOO.DOC"
          What follows is file type           1 + filetype byte

      Data Class for data:

          What follows is data
          Information belongs to Primary Application
          Generated by Requestor (the remaining data class byte
          fields are not defined for data)

      Data to be sent:

          "This is line one of the file to be transferred."
          "This is line two of the file to be transferred."









  The File Transfer Protocol                                     21

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  This section shows the format of the packets implementing the
  example.  It should be noted that this transfer is implemented
  using packets that may have a maximum length (in the case when
  all packet bytes must be encoded) that is greater than the base-
  line definition. In addition, for the sake of simplicity trans-
  port packets have not been packed full of data, but have been
  broken up in logical places.  Assume that packets sent are
  received correctly and the acknowledgements are received.

  Packet #1:
    /Data Class byte, enter application command mode/
    /Data header, what follows is 1 byte of "as is" data/
    /Put yourself in Receive Mode byte/
    /Data header, end of command (EOR)/
    /Data header, what follows is 8 byte of "as is" data/
    /File name byte + 7 bytes of filename/
    /Data header, end of command (EOR)/
    /Data header, what follows is 1 byte of "as is" data/
    /Begin the transfer process command, 1 byte/
    /Data header, end of command (EOR)/
    /Data header, end of group of commands (EOF)/

  Packet #2:
    /Data class byte, now sending application data/
    /Data header, what follows is 31 bytes of "as is" data/
    /"This is line one of the file to"/
    /Data header, what follows is 16 bytes of "as is" data/
    /" be transferred."/
    /Data header, end of record (EOR)/
    /Data header, what follows is 31 bytes of "as is" data/
    /"This is line two of the file to"
    /Data header, what follows is 16 bytes of "as is" data/
    /" be transferred."/
    /Data header, end of record (EOR)/
    /Data header, end of file or group of records (EOF)/

  DEFINITION OF SESSION STARTUP AND SYNCHRONIZATION TASKS.  ________________________________________________________  DEFINITION OF SESSION STARTUP AND SYNCHRONIZATION TASKS.  DEFINITION OF SESSION STARTUP AND SYNCHRONIZATION TASKS.  DEFINITION OF SESSION STARTUP AND SYNCHRONIZATION TASKS.


  Configuration table in use at startup:  ______________________________________  Configuration table in use at startup:  Configuration table in use at startup:  Configuration table in use at startup:

  Both processes must use the  baseline configuration (as specified
  in Table  "A" of "Appendix  G. Standard Configuration  Tables" on
  page 40)  when the  protocol mode  level session  begins.  Either
  process may negotiate to a different configuration after the ses-
  sion has stabilized.  The rule of using the baseline in all cases
  allows two "blind"  processes, or processes that  don't know any-
  thing about each other, to  introduce themselves and negotiate to


  The File Transfer Protocol                                     22

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  a more  effecient or useful configuration  (if they can  agree to
  one).

  Which process is by the default the "requestor"?  ________________________________________________  Which process is by the default the "requestor"?  Which process is by the default the "requestor"?  Which process is by the default the "requestor"?

+ The requestor, as defined in the  "Definitions" on page 3, is the
  process  with an  intent to  transfer  data.  When  a session  is
  started,  the process  that is  run  first is  designated as  the
  requestor.  Here  it is  assumed that  the first  process started
  logs in (in some form) to the machine it wishes to converse with,
  accesses the appropriate userid, and then begins execution of the
  program that acts  as a server.  This function  is dependent upon
  the implementation,  since a master switcher  may be used  to run
  the requestor  or server dependent upon  a parameter, or  the two
  functions may be provided by a single program.  Whatever the form
  of implementation, the requestor is the process started first.

  Which process is by default the "server"?  _________________________________________  Which process is by default the "server"?  Which process is by default the "server"?  Which process is by default the "server"?

  The server, as defined in "Definitions" on page 3, is the process
  that is started by the requestor.  When a session is started, the
  process that is  to be the server  must be started by  the reque-
  stor.  The server  may be a specific program or  may be contained
  within a master  program.  In either case, the  server is started
  by the requestor.

  Responsibilities of the requestor at startup:  _____________________________________________  Responsibilities of the requestor at startup:  Responsibilities of the requestor at startup:  Responsibilities of the requestor at startup:

  After the requestor starts the server process, it must wait for a
  signal from the server that indicates it is ready to receive pro-
  tocol packets.  The requestor is in the same situation at startup
  as it is when it has sent  all the packets it can without waiting
  for an ACK or NAK in order to continue sending packets.  The ser-
  ver will, as its' first action, send  an ACK.  This will free the
  requestor to send the number of packets indicated by the server's
  window in the ACK.  If the server never ACKs, normal timeout pro-
  cessing should  handle the  error.  All  configuration parameters
+ must be from "Appendix G. Standard Configuration Tables."




  The File Transfer Protocol                                     23

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  Responsibilities of the server at startup:  __________________________________________  Responsibilities of the server at startup:  Responsibilities of the server at startup:  Responsibilities of the server at startup:

  After the server  is started by the requestor,  its' first trans-
  mission must  be an ACK.   This ACK  will tell the  requestor the
  number of packets that may be sent  without it having to wait for
  another ACK, therefore freeing up the requestor to begin the ses-
  sion.  The ACK  must use the lowest  end of the PID  range, ASCII
  SPACE (Hex 20), for the Packet_ID1  value.  Packet_ID2 must be at
  least one greater than  Packet_ID1.  All configuration parameters
  must be  from table  "A" of  "Appendix G.  Standard Configuration
  Tables" on page 40.

  TRANSMISSION CONFIGURATION SELECTION AND NEGOTIATION.  _____________________________________________________  TRANSMISSION CONFIGURATION SELECTION AND NEGOTIATION.  TRANSMISSION CONFIGURATION SELECTION AND NEGOTIATION.  TRANSMISSION CONFIGURATION SELECTION AND NEGOTIATION.


  The transmission configuration baseline  _______________________________________  The transmission configuration baseline  The transmission configuration baseline  The transmission configuration baseline

  Each of the link control commands has a baseline value associated
  with it.   If neither  process respecifies  or if  both processes
  can't agree on a configuration, the baseline is used.  All imple-
  mentations must at all times be  able to converse using the base-
  line.

  Negotiating a new configuration  _______________________________  Negotiating a new configuration  Negotiating a new configuration  Negotiating a new configuration

  Two process may establish a new  configuration when both agree to
  use the new one.  All changes must be made from the baseline lev-
  el, that is, processes must go from  a special set to baseline to
  a special set.   Configuration changes may be  made individually,
  or major changes may be made  by switching to a different config-
  uration table (only tables defined  in "Appendix G. Standard Con-
  figuration Tables" on page 40 may be switched to).

  Note: Due to the  complexity of the negotiating  sequence and the  Note:  Note:  Note:
  variety of possible  configurations, this discussion will  be put
  off  in the  preliminary version  of the  document until  further
  analysis is made.

  ENCODING/DECODING SPECIFICATION  _______________________________  ENCODING/DECODING SPECIFICATION  ENCODING/DECODING SPECIFICATION  ENCODING/DECODING SPECIFICATION



  The File Transfer Protocol                                     24

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  Which bytes must be encoded:  ____________________________  Which bytes must be encoded:  Which bytes must be encoded:  Which bytes must be encoded:

  The point at which a process must encode bytes is when it is pre-
  paring to send a binary packet out  the door as a transport pack-
  et.  At  any time during  protocol mode,  the set of  byte values
  that can be  safely transmitted through the  communication medium
  is defined, and is often referred  to as the "transmittable char-
  acter set".  The bytes that must be encoded are all those outside
  the transmittable  set, and  in addition, any  byte with  a value
  equal to  the current definition of  the header, the  trailer, or
  the Shift to  Hex byte value.  While  in shift mode, there  is no
  need to shift out until a byte  that need not be shifted is seen.
  Also, it is not efficient to shift out unless the next 2 bytes to
  be sent need not be shifted (due  to the overhead of the shifting
  bytes).  Note  that a process  must be  in unshifted mode  when a
  header is recognized, which implies that  the trailer of a packet
  ends Shift to Hex mode.

  Definition of encoding/decoding algorithm:  __________________________________________  Definition of encoding/decoding algorithm:  Definition of encoding/decoding algorithm:  Definition of encoding/decoding algorithm:

  In the following  discussion, [OK SET] is defined  as the charac-
  ters that need not be  shifted before transmission.  Byte_to_send
  refers to  a byte from a  binary level packet, and  becomes FALSE
  when all bytes are sent.

  While outputting bytes:  While outputting bytes:  While outputting bytes:  While outputting bytes:

  in_shift_mode := FALSE
  WHILE byte_to_send DO
     IF byte_value NOT IN [OK SET] THEN
        IF NOT in_shift_mode THEN
           in_shift_mode := TRUE
           send Shift to Hex byte
         convert 1-byte integer value into 2-byte Hex value
         send 1 Hex digit
         send 1 Hex digit
     ELSE
        IF in_shift_mode THEN
           in_shift_mode := FALSE
           send Shift out byte
        send byte



  The File Transfer Protocol                                     25

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  While inputting bytes:  While inputting bytes:  While inputting bytes:  While inputting bytes:

  expecting_1st := TRUE
  in_shift_mode := FALSE
  WHILE byte_to_input DO
   byte_to_input = FALSE when trailer seen }
     BEGIN
     INPUT byte_value
     IF in_shift_mode THEN
        IF byte_value = Shift Out THEN
           IF expecting_1st THEN
              in_shift_mode := FALSE
           ELSE
              ERROR condition because need 2nd digit of
              character
        ELSE
           IF expecting_1st THEN
              1st_Part := byte_value
              expecting_1st := FALSE
           ELSE
              2nd_Part := byte_value
              data_byte := convert(1st_part, 2nd_part)
                  convert takes two hex digits ["0".."9",
                   "A".."F"], and
                   returns the one-byte integer represented
                   by the hex.
                   An assumption is that both digits are
                   valid Hex digits.}
              expecting_1st := TRUE
     ELSE     not in_shift_mode }
        If byte_value = Shift to Hex then
           in_shift_mode := TRUE
           expecting_1st := TRUE
        ELSE
           data_byte := byte_value
     END

  CHECKSUM ALGORITHM SPECIFICATION.  _________________________________  CHECKSUM ALGORITHM SPECIFICATION.  CHECKSUM ALGORITHM SPECIFICATION.  CHECKSUM ALGORITHM SPECIFICATION.


  The baseline checksum algorithm:  ________________________________  The baseline checksum algorithm:  The baseline checksum algorithm:  The baseline checksum algorithm:

  In the  following discussion,  2to14  represents the value  "2 to
  the 14th power".  SUM is an integer  whose value may range  up to



  The File Transfer Protocol                                     26

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  2to14.  Checksum_area is all of the bytes from the PTC to the 3rd
  byte from the trailer.  The minimum is  one byte, as in RFR pack-
  et.

  SUM := 0;
  FOR EACH BYTE IN checksum_area
     BEGIN
     SUM := SUM + SUM + BYTE_VALUE;
      SUM + SUM is Left Shift 1 bit }
     WHILE SUM >= 2to14 DO
       SUM := SUM - 2to14 + 1;
     END;
  CHECKSUM := SUM

  Position of checksum in binary packet:  ______________________________________  Position of checksum in binary packet:  Position of checksum in binary packet:  Position of checksum in binary packet:

  The binary packet  level is responsible for  calculating and com-
  paring checksums.   The last two bytes  of a binary  level packet
  contain the checksum as calculated before transmission, using all
  of the binary packet bytes except the checksum bytes.  The binary
  packet level on  the receiving end must, of course,  use the same
  bytes to calculate a checksum after transmission.

  Switching to a different algorithm:  ___________________________________  Switching to a different algorithm:  Switching to a different algorithm:  Switching to a different algorithm:

  Some implementations may want to  use a different checksum.  This
  may be done  using the negotiating rules  outlined for configura-
  tion tables. Only those checksums defined in this document may be
  switched to.







  The File Transfer Protocol                                     27

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  APPENDIX A. DATA CLASS BYTE VALUE TABLE.  ________________________________________  APPENDIX A. DATA CLASS BYTE VALUE TABLE.  APPENDIX A. DATA CLASS BYTE VALUE TABLE.  APPENDIX A. DATA CLASS BYTE VALUE TABLE.

  Each packet received from the Binary packet level contains at
  least one data class byte.  The data class byte indicates the
  type or class of the following bytes of data, up to an End of
  Data Class data header byte, or up to the end of the packet,
  which implies End of Data Class.

  Data Class byte format:  Data Class byte format:  Data Class byte format:  Data Class byte format:

      Bits of byte =  A B C D E F G H

      Fields in byte =  A, BC, D, E, FGH


  Data Class byte values:  Data Class byte values:  Data Class byte values:  Data Class byte values:

      Case value of A:

      0         what follows is control or command information.      0      0      0

      1         what follows is data (as in file data).  Note that      1      1      1
                if this field is set to 1, only the BC and D fields
                are defined.

      Case value of BC:

      00    Link Control.      00      00      00

      01    Primary application.      01      01      01

      10    Secondary application.      10      10      10

      11    Tertiary application.      11      11      11

      Note: This field allows for up to 3 different sets of appli-      Note:      Note:      Note:
      cation commands or data to be dealt with by a single process.

      Case value of D:

      0     This is a packet generated by the REQUESTOR.      0      0      0

      1     This is a packet generated by the SERVER.      1      1      1

      Case value of E:

      0    Advisory - can ignore if not understood or acceptable.      0      0      0

  Appendix A. Data Class byte value table.                       28

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

      1    Important - must be understood and acceptable.      1      1      1

      Case value of FGH:

      000    Command, reply is optional.      000      000      000

      001    Command, reply is required.      001      001      001

      010    Positive reply (command echoed).      010      010      010

      011    Negative reply (command echoed).      011      011      011

      100    Explanatory reply (command byte echoed,      100      100      100

             Note: Reason code (and text if needed), may follow,             Note:             Note:             Note:
             see "Appendix E. Reply reason code table" on page 37.

      101    Request for information.  This field is followed by a      101      101      101
             command byte, and asks the recipient for the data
             associated with the command byte be returned to the
             sender.  The presence of data in conjunction with a
             command is currently undefined.












  Appendix A. Data Class byte value table.                       29

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  APPENDIX B. DATA HEADER BYTE VALUE TABLE.  _________________________________________  APPENDIX B. DATA HEADER BYTE VALUE TABLE.  APPENDIX B. DATA HEADER BYTE VALUE TABLE.  APPENDIX B. DATA HEADER BYTE VALUE TABLE.

  Data Header byte format:  Data Header byte format:  Data Header byte format:  Data Header byte format:

      Bits of byte = A B C D E F G H

      Fields in byte = ABC, DEFGH

  Note: The DEFGH field has a maximum value of Decimal 31.  Note:  Note:  Note:

  Case value of ABC:  Case value of ABC:  Case value of ABC:  Case value of ABC:

  000       Invalid value.                      (Hex 00)  000  000  000

  001       Case value of DEFGH:                (Hex 20)  001  001  001

            00000     End of record marker (EOR). When used within            00000            00000            00000
                      the application data class, convert to/from
                      the logical end of record marker of local
                      machine.  When used within link or applica-
                      tion command data class, means that a command
                      and its' associated data ends.

            xxxxx     What follows is xxxxx bytes of "as is" data.            xxxxx            xxxxx            xxxxx

  010       Case value of DEFGH:                (Hex 40)  010  010  010

            00000   End of file marker (EOF), group of records            00000            00000            00000
                    ends. When used as end of command records,
                    implies that sender is waiting for a response
                    to "required response" type commands before
                    proceeding.

            xxxxx   Expand binary zero (NULL) into xxxxx bytes.            xxxxx            xxxxx            xxxxx

  011       Case value of DEFGH:                (Hex 60)  011  011  011

            00000   End of Data Class marker (EOD), group of simi-            00000            00000            00000
                    lar commands or data ends.  Used only when
                    changing data class within a valid packet.  EOD
                    is implied when the end of a valid packet is
                    reached.

            xxxxx   Expand ASCII blank (Hex 20) into xxxxx bytes.            xxxxx            xxxxx            xxxxx

  100       Case value of DEFGH:                (Hex 80)  100  100  100

            00000   Invalid value.            00000            00000            00000

  Appendix B. Data Header byte value table.                      30

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

            xxxxx   Expand next byte's value into xxxxx bytes.            xxxxx            xxxxx            xxxxx

  101       Case value of DEFGH:                (Hex A0)  101  101  101

            00000   Invalid value.            00000            00000            00000

            xxxxx   Expand EBCDIC blank (Hex 40) into xxxxx bytes.            xxxxx            xxxxx            xxxxx

  110       Reserved value.                     (Hex C0)  110  110  110

  111       Reserved value.                     (Hex E0)  111  111  111
















  Appendix B. Data Header byte value table.                      31

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  APPENDIX C. LINK CONTROL COMMAND TABLE.  _______________________________________  APPENDIX C. LINK CONTROL COMMAND TABLE.  APPENDIX C. LINK CONTROL COMMAND TABLE.  APPENDIX C. LINK CONTROL COMMAND TABLE.

  Use of Link Control command table to redefine configuration:
  Each process may redefine any of the configuration parameters
  singularly, or may redefine the entire configuration paramater
  table by choosing command 12.  Either method of changing must be
  done within the rules specified in "Transmission configuration
  selection and negotiation".

  Link Control byte format:  Link Control byte format:  Link Control byte format:  Link Control byte format:

      Bits of byte = A B C D E F G H
      Fields in byte = A, BCDEFGH


  Link Control byte values:  Link Control byte values:  Link Control byte values:  Link Control byte values:

  Case value of A:  Case value of A:  Case value of A:  Case value of A:

  0    this is what I want to use.  0  0  0

  1    this is what I want you to use.  1  1  1

  Case value of BCDEFGH:  Case value of BCDEFGH:  Case value of BCDEFGH:  Case value of BCDEFGH:

  0    invalid value.  0  0  0

  1    What follows is header character (the header must be in the  1  1  1
       set of characters that may be transmitted safely without
       encoding, but it must be encoded when found within a binary
       level packet).

  2    What follows is trailer character (the trailer must be in  2  2  2
       the set of characters that may be transmitted safely without
       encoding, but it must be encoded when found within a binary
       level packet).

  3    What follows is non-special packet packet-type character.  3  3  3

  4    What follows is ACK packet-type character.  4  4  4

  5    What follows is NAK packet-type character.  5  5  5

  6    What follows is RFR packet-type character.  6  6  6

   7   What follows is the Shift to Hex character (the Shift to Hex   7   7   7
       character must be in the set of characters that may be tran-

  Appendix C. Link Control command table.                        32

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

       smitted safely without encoding, but it must be encoded when
       found within a binary level packet).

  8    What follows is the Shift out of Hex character.  8  8  8

  9    What follows is a bit map of the set of characters that can  9  9  9
       be transmitted safely through the medium of communication.
       Bit map is transmitted as 32-byte array, bit 1 of element 1
       = ASCII NULL.

  10   What follows is timeout time in seconds.  Processes that  10  10  10
       cannot implement a timeout must send this command, with val-
       ue of zero.

  11   What follows is maximum transport packet size after encod-  11  11  11
       ing.

  12   What follows is configuration table to RESET to.  12  12  12

  13   What follows is 1 byte indicating which application level of  13  13  13
       Primary, Secondary, or Tertiary, the following string (or
       process name) should be associated with.

  14   What follows is PID range, within baseline range.  Format is  14  14  14
       two bytes, first is low end, second is high end.  Second
       must be at least one greater than first.











  Appendix C. Link Control command table.                        33

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  APPENDIX D. APPLICATION CONTROL COMMAND TABLE  _____________________________________________  APPENDIX D. APPLICATION CONTROL COMMAND TABLE  APPENDIX D. APPLICATION CONTROL COMMAND TABLE  APPENDIX D. APPLICATION CONTROL COMMAND TABLE

  Each command has a different data parameter associated, the con-
  tent of the parameter is determined in the valid packet level
  unpackaging processing.  This processing must look for the end of
  the command's data and inform the application packet when the end
  is found.

  Case value of command byte:  Case value of command byte:  Case value of command byte:  Case value of command byte:

  0    Invalid value.  0  0  0

  1    Put yourself into "send data" mode.  1  1  1

  2    Put yourself into "receive data" mode.  2  2  2

  3    Start the transfer process.  3  3  3

  4    Terminate the transfer process, remain in "protocol" mode.  4  4  4

  5    End "protocol" mode, terminate session.  5  5  5

  6    What follows is file name.  6  6  6

  7    What follows is treatment for an existing file:  Case next  7  7  7
       byte's value:

       0    Invalid value.       0       0       0

       1    Replace the existing file with new one.       1       1       1

       2    Append the new file onto the existing one.       2       2       2

       3    Return error if the file exists.       3       3       3

  8    What follows is the approximate size of the file in bytes.  8  8  8

  9    What follows is an indicator of file type:  Case next byte's  9  9  9
       value:

       0    Invalid value.       0       0       0

       1    File of Bytes (BYTE), a stream of 8-bit bytes.       1       1       1

       2    File of Bits (BIT), a stream of bits, the first of       2       2       2
            which is the high-order bit of the first byte of the
            file.


  Appendix D. Application control command table                  34

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

       3    Abstract Symbolic Text (AST).  This filetype will be       3       3       3
            used to transfer most text files.  See Appendix C for
            further discussion of what an AST file is, and the
            rules that apply.

  10   What follows is the approximate size of a "record", where  10  10  10
       the consideration of the value depends upon the type of the
       file.  Case File Type of

       BYTE   size is number of bytes.       BYTE       BYTE       BYTE

       BIT    size is number of bits.       BIT       BIT       BIT

       AST    size is line width [and possibly page length].       AST       AST       AST

  11   What follows is the approximate length of the file in "re-  11  11  11
       cords".

  12   What follows is file author as string.  12  12  12

  13   What follows in the next 22 (may be less) bytes is the time  13  13  13
       and date the file was created.  Use date format below.

  14   What follows in the next 22 (may be less) bytes is the time  14  14  14
       and date the file was last updated.  Use date format below.

  15   What follows in the next 22 (may be less) bytes is the time  15  15  15
       and date at the present.  Use date format below.  This com-
       mand may be useful for determining differences in time
       zones.


  Date format rules:  Date format rules:  Date format rules:  Date format rules:

  Maximum is 22 bytes.  Format is /yyyy-mm-dd hh:mm:ss.mmm/.  Each
  non-delimiter field is a digit but the delimiter fields may be of
  any character value.  All 22 bytes need not be transmitted, so a
  process must apply the received bytes to an array, conceptually
  at least, that has the value: /0000-01-01 00:00:00.000/.  As
  bytes are received, they must be assigned to the array, byte by
  byte, from the left to the right.  When a date is sent that is
  not in correct format, the result is undefined.  The default for
  each of fields described below is the minimum value in the range.

  yyyy   Four digit year, range : 0000..9999.  yyyy  yyyy  yyyy

  mm     Two digit month, range : 01..12.  mm  mm  mm

  dd     Two digit day, range : 01..31.  dd  dd  dd


  Appendix D. Application control command table                  35

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  hh     Two digit hour, range : 00..23.  Hours are expressed as on  hh  hh  hh
         a 24-hour clock, where midnight is hour zero at the begin-
         ning of a new day.

  mm     Two digit minutes, range : 00..59.  mm  mm  mm

  ss     Two digit seconds, range : 00..59.  ss  ss  ss

  mmm    Three digit milliseconds, range : 000..999.  mmm  mmm  mmm

  Examples:

      File created December 10, 1982.  Time 6:50:00.123 in evening.

      /1982-12-10 18:50:00.123/

      File changed January 10, 1983.  Time 09:30:59.001 in morning.

      /1983-01-10 09:30:59.001/

      If file creation bytes received are: /1982-12-22/

      Created December 22, 1982 at 00:00:00.000 hours.

      If file updated bytes received are: /1982-1/

      Created November (NOT January) 01, 1982 at 00:00:00.000
      hours.










  Appendix D. Application control command table                  36

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  APPENDIX E. REPLY REASON CODE TABLE  ___________________________________  APPENDIX E. REPLY REASON CODE TABLE  APPENDIX E. REPLY REASON CODE TABLE  APPENDIX E. REPLY REASON CODE TABLE

  These codes would be returned in response to a command, such as
  "SEND ME FILE: ABC JJJ A1".  If the SEND command was not imple-
  mented as of yet by the receiver of the command, the answer might
  be "Explanatory reply, reason code follows".

  Case value of Reason Code:  Case value of Reason Code:  Case value of Reason Code:  Case value of Reason Code:

  0    Human user-oriented comment in Printable ASCII form follows.  0  0  0

  1    Request type not implemented.  1  1  1

  2    Invalid Syntax.  2  2  2

  3    Requested File or Facility Not Found.  3  3  3

  4    Not enough space (on volume or disk).  4  4  4

  5    File or Operating System error - DO NOT RETRY.  5  5  5

  6    File or Operating System error - MAY RETRY.  6  6  6

  7    Access Error- protection failure or type violation.  7  7  7










  Appendix E. Reply reason code table                            37

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  APPENDIX F. DESCRIPTION OF AST FILES  ____________________________________  APPENDIX F. DESCRIPTION OF AST FILES  APPENDIX F. DESCRIPTION OF AST FILES  APPENDIX F. DESCRIPTION OF AST FILES

   off Processes  do not actually transfer  a file as it  exists on
  one  computer  to another  computer.   What  they transfer  is  a
  description of  the file, followed by  the contents of  the file.
  What is  hoped is  that the file  appears the  same on  both ends
  after the transfer, even if it is stored in a different manner by
  both ends.

  The term  abstract means  that we define  the file  abstractly as
  follows:

     Each page consists of lines,

     each line consists of characters.

     The number of  pages, width of a  line, and length of  a page
      are considered to be arbritrarily large.

  Each system  is responsible  for describing  the form  of an  AST
  file, by using the above  abstract terms, according to system-lo-
  cal conventions.  Each system is  also responsible for building a
  file of  the same  form, using  system-local conventions  with an
  abstract form description.

  The contents of files may be described  in terms of the range and
  type characters found  within them.  For the basic  AST file, the
  printing ASCII  characters (Hex 21-Hex7E),  in addition  to ASCII
  SPACE (Hex 20), may be used to  describe the contents of most any
  printing file.  Note that SPACE is  treated as a horizontal posi-
  tioning character, and in a sense is non-printing.  A record con-
  taining only  the ASCII  FORMFEED (Hex  0E) is  used to  separate
  pages.

  In order  to provide a  more narrow  definition of what  a file's
  contents may  be, any  of the remaining  character values  may be
  specified  as  of the  "printing"  type  through the  process  of
  exchanging a  32-byte bit map  which has  a 1 for  each character
  that is  prints "as is".  Thereafter,  when one of  the newly-de-
  fined "printing"  characters is  seen, it  need not  be converted
  from/to system-local conventions before transmission.

  Some characters that produce special effects are

  TAB     (Hex 09) prevents TAB insertion or realignment at the end  TAB  TAB  TAB
          receiving the file, as well  as replicating the TAB char-
          acter in the file itself.

  CR      (Hex 0D) only affects carriage-return characters that are  CR  CR  CR
          not part of an "end of line".


  Appendix F. Description of AST files                           38

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  LF      (Hex 0A)  only affects linefeed  characters that  are not  LF  LF  LF
          part of an "end of line".

  SPACE   (Hex 20)  affects the treatment  of trailing spaces  on a  SPACE  SPACE  SPACE
          line.


















  Appendix F. Description of AST files                           39

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

  APPENDIX G. STANDARD CONFIGURATION TABLES  _________________________________________  APPENDIX G. STANDARD CONFIGURATION TABLES  APPENDIX G. STANDARD CONFIGURATION TABLES  APPENDIX G. STANDARD CONFIGURATION TABLES

  TABLE "A"- BASELINE  ___________________  TABLE "A"- BASELINE  TABLE "A"- BASELINE  TABLE "A"- BASELINE

  1.  Header character is "*" (Hex 2A).

  2.  Trailer character is <CR> carriage return (Hex 0D).

  3.  Non-special packet packet-type character is "=" (Hex 3D).

  4.  ACK packet packet-type character is "+" (Hex 2B).

  5.  NAK packet packet-type character is "-" (Hex 2D).

  6.  RFR packet packet-type character is "?" (Hex 3F).

+ 7.  Shift to Hex character is "%" (Hex 25).
+
+ 8.  Shift out of Hex character is "%" (Hex 25).

  9.  Transmittable character set is  as follows:  carriage return,
      space, "0"-"9", "A"-"Z", "+-*/=.,()%?"   (Should be expressed
      as 32-byte bit  map, where bit 1  of element 1 is  equal to 1
      when NULL may be transmitted without encoding.)

  10. Timeout time (in seconds) is 120.

  11. Maximum transport packet size after encoding is 72 bytes.

  12. String associated with Primary Application level is "TYMFTP".

  13. PID range is ASCII SPACE (Hex 20) to ASCII "z" (Hex 7A).


  TABLE "B"  _________  TABLE "B"  TABLE "B"  TABLE "B"

  This table is  an example of the types  of standard configuration
  tables that need to be developed.  This  one is being used by Rob
  Larson to implement  the protocol using an  IBM PC to talk  to an
  IBM 370.  What we need is a group of special tables that could be
  switched to quickly once a  procotol session is initialized using
  baseline mode.

  1.  Header character is ESC (Hex 1B).

  2.  Trailer character is <CR> carriage return (Hex 0D).

+ 3.  Non-special packet packet-type character is "w" (Hex 77).


  Appendix G. Standard Configuration Tables                      40

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

+ 4.  ACK packet packet-type character is "x" (Hex 78).
+
+ 5.  NAK packet packet-type character is "y" (Hex 79).
+
+ 6.  RFR packet packet-type character is "z" (Hex 7A).

  7.  Shift to Hex character is ASCII Shift In (Hex 0F).

  8.  Shift out of Hex character is ASCII Shift Out (Hex 0E).

  9.  Transmittable  character set  is as  follows:   All of  ASCII
      range, except XON, XOFF.  (Should be expressed as 32-byte bit
      map, where bit 1 of element 1 is  equal to 1 when NULL may be
      transmitted without encoding.)

  10. Timeout time (in seconds) is 120.

  11. Maximum transport packet size after encoding is 512 bytes.

  12. String associated with Primary Application level is "TYMFTP".

  13. PID range is ASCII SPACE (Hex 20) to ASCII "z" (Hex 7A).












  Appendix G. Standard Configuration Tables                      41

                            Working Draft                            Working Draft                            Working Draft                            Working Draft

+ APPENDIX H. DIAGRAM OF PACKET PACKAGING  _______________________________________  APPENDIX H. DIAGRAM OF PACKET PACKAGING  APPENDIX H. DIAGRAM OF PACKET PACKAGING  APPENDIX H. DIAGRAM OF PACKET PACKAGING
+
+
+
+                       +-------------------+
+                       ^  TRANSPORT LEVEL  ^
+ +---------------------------------------------------------------+
+ ^                                                               ^
+ ^                                                               ^
+ ^                     +-------------------+                     ^
+ ^                     ^   BINARY LEVEL    ^                     ^
+ ^   +-------------------------------------------------------+   ^
+ ^   ^                                                       ^   ^
+ ^   ^                                                       ^   ^
+ ^   ^                 +-------------------+                 ^   ^
+ ^   ^                 ^   VALID LEVEL     ^                 ^   ^
+ ^   ^                 ^ data packets only ^                 ^   ^
+ ^   ^       +-------------------------------------------+   ^   ^
+ ^   ^       ^                                           ^   ^   ^
+ ^   ^       ^                                           ^   ^   ^
+ ^   ^       ^         +-------------------+             ^   ^   ^
+ ^   ^       ^         ^ APPLICATION LEVEL ^             ^   ^   ^
+ ^   ^       ^       +-----------------------------------+   ^   ^
+ ^   ^       ^       ^                                   ^   ^   ^
+ ^   ^       ^       ^                                   ^   ^   ^
+ ^   ^       +---+---+                                   ^   ^   ^
+ ^   ^       ^ * ^ * ^                                   ^   ^   ^
+ ^   ^       ^   ^   ^                                   ^   ^   ^
+ +---+---+---+---+---+------+---+------+-----------------+---+---+
+ ^   ^   ^   ^   ^   ^      ^   ^      ^                 ^   ^   ^
+ ^HDR^PTC^PID^DAT^DAT^ data ^DAT^ data ^ ...             ^CHK^TRL^
+ ^   ^   ^   ^CLS^HDR^      ^HDR^      ^                 ^SUM^   ^
+ ^   ^   ^   ^   ^   ^      ^   ^      ^                 ^   ^   ^
+ +---+---+---+---+---+------+---+------+-----------------+---+---+
+   1   2   3   4   5 ^  6                                ^ 7    8
+                     ^                                   ^
+                     ^   optional in each packet         ^
+                     +-----------------------------------+
+
+ * indicates these fields are optionally present at the applica-
+   tion level.  The implementation may interpret them at the valid
+   level and send the data to the appropriate destination within
+   the application or it may pass them to the application and let
+   it decide how to process them.
+
+
     + 1 packet header             + 4 data class code
     + 2 packet type character     + 5 data header
     + 3 packet sequence identi-   + 6 data or command
     +   fier - present only in    + 7 check sum
     +   data packets (not ACK,    + 8 packet trailer
     +   NAK, RFR)


  Appendix H. Diagram of Packet Packaging                        42
cTx