;23-Jul-84 18:50:31 Edit by WILKES - Version 41 ready for release

IFNDEF DEBUG,<DEBUG==0>

TITLE DSKCLN - DAMAGE CLEANUP AND DAMAGE ASSESMENT

VRAT==41	;version number

;[41] VERSION 41  23-Jul-84 /WILKES
;[41] call it version 41, since it appears to function properly
;[41] fix minor oops in pagwrt when VALPAGing - want virtual page, not disk
;[41] also print version number at startup.
;[41] Remove dead code from dump mode i/o and maksw stuff.
;[40] VERSION 40 - 16-Jul-84 - john wilkes (again!)
;[40] make all pages mapped read/write in fix mode, read-only in 
;[40] check mode, since monitor won't let us vcreate in ill mem ref
;[40] interrupt handler.  (god only knows why not...)
;[37] VERSION 37 21-May-84 John Wilkes
;[37] teach the program about paging.  Re-do PAGRED, FNDSEK, and  PAGWRT
;[37] routines, taking out old-style I/O, putting in paging.  Add interrupt 
;[37] handler for software interrupt system to do the .IAERR software
;[37] interrupt for catching paging I/O errors caused by flaky hardware.
;[37] The philosophy is to handle the errors if they come from the file
;[37] system and they are not associated with a critical file.  Primary 
;[37] objective is to get the system up, and if a few user files get
;[37] blown away, report them to the cty so that the operator can restore
;[37] them.  If the page error is nefarious enough that it cannot be handled,
;[37] abort with an appropriate message suggesting that the disk subsystem
;[37] hardware be checked out.  FNDSEK no longer does seek handling, now
;[37] it uses the same decision-making logic to map/prereference instead.
;[37] PAGRED had to be taught to recognize an already pre-reffed file
;[37] and not try to map it again, but replicate it instead.  In order to
;[37] minimize impact throughout the program, keep the one page area
;[37] called BUF as the place where the most recently requested disk
;[37] page is kept.  When doing pre-referencing, map the pages to another
;[37] area (FNDSEK) then replicate them into BUF (PAGRED).
;[37] It turns out that an undocumented "feature" of super-mapping is that 
;[37] copy-on-write protection is illegal for super-mapped pages.  A cow
;[37] page will lose if you try to scribble there.  program dies with an 
;[37] illegal memory reference.  I thought to use the software interrupt
;[37] system to trap and handle this, in fact, tried it.  Another undocumented
;[37] "feature" of tymcom-10 is that it is illegal to vcreat private pages
;[37] when the system is in its funny "auto-restart-doing-dskcln" mode.
;[37] this may be connected to having just done a dskclr uuo with the
;[37] dc.clr (clear in-core file system info) function, i don't know.
;[37] Fortunately, DSKCLN only scribbles in BUF when it knows what it's
;[37] doing, so map all pages with read/write protection.  put a checker
;[37] into pagwrt to be sure that the page we want to write is the most
;[37] recently one mapped into BUF.
;[37] Since I could not make much sense out of the DEBUG or MAKSW
;[37] assembly switches, and they interfered greatly in the I/O
;[37] routines, remove them.  DEBUG version now never writes (thruogh PAGWRT)
;[37] on disk, nor does it do the DSKCLR UUO.  So-called "file-maker"
;[37] version (MAKSW=1) no longer exists.
;[37] Also, as part of initially understanding the program's logic, add 
;[37] comments as necessary for clarification (mine, if nobody else's!).
;[37] Comments added merely to clarify existing code are not flagged with
;[37] an edit level.  All new lines of code have comments marked with an
;[37] edit level.  Any lines of existing code that were removed, were commented
;[37] out with the edit level that blew them away indicated.
;version 36 11/15/81 DWS
; 1. make sure system is super shut before running in fix mode.
; 2. try to improve error messages for critical files (in/around crterr:).
; 3. comment out dead code (swpprc:) from edit 35.
;version 35 7/17/81 WRS
; 1. continue analysis if critical file damaged while in check mode
; 2. eliminate SWAP.SYS as a critical file
;VERSION 34
;CHECK FOR UNIT OUT OF RANGE IN FNDSK1
;VERSION 33.
;DSKCLN CAN NOW CONDITIONALLY PROCESS SELECTED SUBSETS OF FILE
; STRUCTURES.  THE SUBSET DESIRED IS PASSED TO DSKCLN BY A TYPE
; NUMBER (AN INTERER FROM 0-7) ENTERED BY THE OPER IN CHECKING
; MODE OR GETTABED IF FIX MODE.  THREE TYPES ARE CURRENTLY AVAILABLE:
; 0  NONE:  THIS STRUCTURE NEEDS NO ANALYSIS
; 1  FAST:  EXAMINE ONLY THOSE FILES WHICH HAVE RECENTLY UNDERGONE
;	    ALLOCATION.  THIS IS ACCOMPLISHED BY CHECKING THE BIT
;	    UFPALC IN THE UFD ENTRY FOR EVERY FILE.  AFTER ANALYSIS,
;	    IF FIXING IS BEING PERFORMED, THE DSKCLN GENERATED SATS
;	    ARE ANDED WITH THE DSK SATS.
; 7  FULL:  CHECK AND/OR CORRECT FILE PROBLEMS OVER ENTIRE STR.  THIS
;	    WAS THE ONLY MODE PREVIOUSLY AVAILABLE.
; DSKCLR CALLS WERE MODIFIED TO CONFORM TO THE NEW DSKCLR UUO FORMAT
; WHICH WAS NECESSARY TO SUPPORT MODE. 0.  IDENT NOW REPORTS MODE.
; OUTPUT TO TTY NO LONGER USES BUFFERED I/O.  DSKCLN IDENTIFIES
; ITSELF, REPORTS KEY FACTS ON STRUCTURE UNDER ANALYSIS, AND PRINTS
; TERMINATION MESSAGE ON CTY. 4/25/80 /TLC.
;VERSION 32.
;MERGED 2020 MODIFICATIONS WITH DSKCLN VERSION 31 USING DSKCLN V30
; AS THE MASTER FILE / FEB 8,1980 ELB/ SEE BELOW DESCRIPTION FOR
; 2020 CHANGES
;MODIFIED 1/17/79 BY DSB TO USE DSKCHR TO GET SOME OF THE HOME FILE
; STRUCTURE: ADDRESSES OF HOME, BAT PAGES AND SIZE & LENGTH OF THE
; BOOTSTRAP AREA.

JOBVER==137
LOC	JOBVER
	VRAT
	RELOC
INTERNAL JOBVER,JOBREN

;PARAMETERS FROM COMMOD.MAC

HOMNAM==0	;"HOM" IN SIXBIT
HOMSNM==2	;FILE STR NAME UNIT IS IN
HOMNXT==3	;ID OF NEXT UNIT IN FILE STRUCTURE
HOMLOG==5	;LOGICAL NAME OF THIS UNIT IN FILE STR (DSKB5)
HOMLUN==6	;LOGICAL UNIT IN STR
HOMP4S==7	;PAGES FOR SWAPPING
HOMSLP==13	;FIRST LOGICAL BLOCK FOR SWAPPING
HOMSPU==15	;SATS ON THIS UNIT
HOMOVR==16	;OVERDRAW ALLOWED
HOMSAT==17	;LOGICAL BLOCK WITHIN STR OF 1ST RIB FOR SAT.SYS
HOMHMS==20	;LOGICAL BLOCK WITHIN STR OF 1ST RIB FOR HOME.SYS
HOMSWP==21	;LOGICAL BLOCK WITHIN STR OF 1ST RIB FOR SWAP.SYS
HOMSUF==23	;LOGICAL BLOCK WITHIN STR OF 1ST RIB FOR SYS UFD
HOMMFD==25	;LOGICAL BLOCK WITHIN STR OF 1ST MFD RIB
HOMHSH==27	;HASH CODE FOR DIRECTORIES STORED HERE
HOMCOD==776	;CONAINS UNLIKELY CODE
HOMSLF==777	;THIS BLOCK WITHIN UNIT

;CHANIO IDECIS
CIO.RL==0	;RELEASE
CIO.OP==13	;OPEN
CIO.IN==14	;IN
CIO.OT==15	;OUT
CIO.ST==16	;SETSTS
CIO.SK==24	;SEEK
CIO.PI==31	;PAGE USETI
CIO.PO==32	;PAGE USETO

RIBPFS==51	;FIRST POINTER IN PRIME RIB
RIBLST==775	;LAST POINTER IN ANY RIB
RIBSFS==4	;FIRST POINTER IN SPARE RIB
RIBRIB==0	;BACK POINTER IN RIB
RIBRPS==1	;UP LEVEL WORD POINTER
RIBSZS==2	;SIZE OF A SPARE RIB POINTER IN THIS RIB
RIBSNM==3	;NUMBER OF SPARE RIBS IN TOP LEVEL POINTER
RIBPPN==4
RIBNAM==5
RIBEXT==6
RIBPVW==7
RIBSIZ==10
RIBLCW==17
RIBSTS==22
RIBUSD==30
RIBMXA==27
RIBALP==36	;NUMBER OF PAGES ALLOCATED
RIBCOD==776
RIBSLF==777

RIPNUB==400000
RIPDIR==400000
RIPBDA==1		;FILE FOUND BAD BY DAMAGE ASSESMENT
RIPALC==(1B7)	;FILE MODIFIED RECENTLY (IN LH RIBLCW)

PTSUNI==^D8	;UNIT FIELD IN POINTER
PTNUNI==^D16
PTSPNO==^D19
PTNPNO==^D35
RBREAL==200000	;REAL POINTER
RBSPAR==400000	;SPARE RIB POINTER
RBLVPR==RIBLST-RIBPFS+1	;NUMBER OF POINTERS IN PRIME RIB
RBLVSR==RIBLST-RIBSFS+1	;NUMBER OF POINTERS IN SPARE RIB

CODHOM==070717	;UNLIKELY CODE FOR HOME BLOCK
CODRIB==666666	;DITTO FOR BAT BLOCK.

BLKSIZ==1000

;END PARAMETERS FROM COMMOD.MAC

EXTERN	JOBREL,JOBFF,JOBSA

JOBREN==124
	LOC JOBREN
	RENADR
	RELOC

RENADR:	SETZM DETSW	;clear AUTO-RESTART flag when re-entering
	JSP P,CHKOPR	;make sure we have OP license
	JRST RENAD1	;DO NOT DO THE FIX FUNCTION, JUST DSKRAT

;ACS

M=0
T=1		;\
T1=T+1		; \
T2=T+2		;  > temporaries, usually
T3=T+3		; /
T4=T+4		;/
N=6		;used for numeric output usually
N1=N+1		;used by numeric output routines, usually
CH=10		;used by character output routines, usually
CHAN=11		;software channel kept here
U=12		;the unit in use, usually
P1=13		;\
P2=P1+1		; \
P3=P2+1		; /
P4=P3+1		;/
P=17		;stack pointer always

;IO CHANNELS

DSK==0		;FOR READING DISK
LPT==16		;FOR OUTPUT
MXCHN==16	;MAX NUMBER OF CHANNELS TO HAVE
FIL==17

;DSKCHR INDICES

.CHSNM==4	;NAME OF STR
.CHCHR==5	;CHARACTERISTICS
.CHBPU==6	;BLOCKS ON THIS UNIT
.CHHA==20	;HOME PAGE 1,,HOME PAGE 2
.CHBA==21	;BAT PAGE 1,,BAT PAGE 2
.CHBSA==22	;# PAGES IN BOOTSTRAP AREA,,FIRST PAGE IN BOOTSTRAP AREA

.CHLEN==1+.CHBSA	;WORDS IN DSKCHR ARGUMENT LIST

OPDEF PJRST [JRST]


	DEFINE ERRLEV (A)
<	XCT A,[PUSHJ P,ERLSET]>

;FILE LOOKUP ENTER INDICES

FLMNAM==2
FLMEXT==3
FLMPPN==1
FLMSTS==17

UFDNAM==0	;NAME
UFDEXT==1	;EXTENSION (LEFT HALF)
UFDPRV==1
UFDUF2==1
UFDTMD==2
UFDLIC==3
UFDALC==3
UFDRBP==4	;POINTER TO RIB
UFDSIZ==5	;number of words in a single UFD entry
UFDLST=<<1000/UFDSIZ>-1>*UFDSIZ	;LAST UFD ENTRY
UFPALC==1B22	;FILE MODIFIED RECENTLY (IN RH UFDUF2)

LEVMIN==1		;MINOR DAMAGE NO TROUBLE
LEVUSR==2		;SINGLE USER(S) DAMAGED
LEVCRS==3		;ERROR BAD ENOUGH TO CAUSE CRASH
LEVBAD==4		;ERROR IS BAD ENOUGH TO GARBAGE WORSE
IF1,<
IFN DEBUG,<PRINTX DEBUG VERSION>
;[37] IFN MAKSW,<PRINTX FILE MAKER>>

;[37] IFN MAKSW!DEBUG,<FILSIZ==17777	;NUMBER OF BLOCKS PERMITTED
;[37] 	FILOFS==<FILSIZ+200>/200>

BATNAM==0	;INFO FOR BAT BLOCKS
CODBAT==505050
BATCOD==776
BATSLF==777
BATFIR==1
BATELB==1	;PAGE NUMBER OF ERROR WITHIN REGION
BATNBB==0	;LOCATION OF NUMBER OF BAD PAGES
BASNBB==^D9	;SIZE OF FIELD
BANNBB==^D8	;LOW ORDER BIT (FOR BYTE POINTER)

;DSKCLR MODES

DC.CLR==0	;CLEAR IN-CORE DISK INFO
DC.FPC==1	;SET STTFPC FOR ALL SATS ON ALL UNITS
DC.NDS==2	;CLEAR SRPNDS ONLY

JACCT==1
JBTSTS==0
LICOPR==100000
LICSY==(1B3)
LICST==(1B6)
LICJL==(1B8)
LICRA==(3B15)
LICWA==(3B17)
LICTAB==-20
CNFTAB==11	;CONFIGURATION TABLE WITH SYSTEM NAME
LINJOB==-26	;GETTAB FOR JOB TO LINE CONVERSION

PDLSIZ==100	; stack size
ARRAY PDL[PDLSIZ]

buf=777000		;[37] put BUF at top of core - page 777
bufpag==buf/1000	;[37] remember the page number, too
array mapwd[2]		;[37] for mapping UUOs
.chsmp=43		;[37] CHANIO super map absolute disk pages
.prro==1b7		;[37] Read Only page protection
.prrw==3b7		;[37] Read/Write page protection
cnt1==1b17		;[37] count of one for paging uuos
.addws==1b7		;[37] add flag for .WSRNG
.wsrng=1		;[37] WSCTL add/remove from working set
ps.ner==1b7		;[37] PERSET ignore errors
ia.ree==2		;[37] (re)enable interrupt system function
.iaerr==12		;[37] paging i/o error interrupt cause number
vl.wat==1b7		;[37] VALPAG wait for dirty pages to be written
vlioe%==5		;[37] VALPAG i/o error has occurred error code

ARRAY IOCW[2],CHRBUF[.CHLEN],LOBUF[3]
ARRAY TRMBLK[^D30],CNFNAM[6],FIXREN,FIXPTR,FIXBAD[2]
ARRAY CHANU,CHANUU[MXCHN],FILNAM[FLMSTS+1],UFDPCT[1000]

ERRPPN==ERRNAM+3
ERREXT==ERRNAM+1

STAITM==17	;GETTAB ITEM AND TABLE FOR STATES WORD
STATAB==11
LOGITM==25	;GETTAB ITEM AND TABLE FOR LOGOUT NAME
LOGTAB==11
DATITM==11	;GETTAB ITEM AND TABLE FOR DATE
DATTAB==11
TIMITM==10	;GETTAB ITEM AND TABLE FOR TIME (JIFFIES)
TIMTAB==11

DCNITM==5	;GETTAB ITEM AND TABLE FOR DSKCLN TYPE
DCNTAB==15

SUUMSG==0	;DISPATCH CODE FOR SETUUO MESSAGE
SUUINI==2	;DISPATCH CODE FOR SETUUO INITIA PASS 2

DV.TTA==(1B4)	;IS A JOBS COMMAND PORT

;DEFINE LOCATIONS TO GO IN THE BLOCKS TO CONTROL SCAN OF
;UFD, MFD, AND FILES

	DEFINE UUU(A,B)
<	A==%%Z
	%%Z==%%Z+B>

%%Z==0
	UUU RIBLBN,1	;RETRIEVAL PNTR TO RIB
	UUU NXTPTR,1	;BLOCK NUMBER CURRENTLY BEING READ
	UUU UFDPTR,1	;POINTER TO THE UFD SLOT
	UUU UFDOGP,1	;UFD ORIGIN POINTER
	UUU ROUTIN,1	;ROUTINE TO CALL TO GET DOWN A LEVEL
	UUU SAVRIB,1000	;MOVE THE RIB HERE
	UUU DEVRSU,1	;POINTR INTO RIB INFO
	UUU DEVREL,1	;LOGICAL BLOCK NUMBER
	UUU SAVBLK,1	;POINTER TO PLACE TO SAVE CURRENT BLOCK
	UUU UFDBKF,2	;FOR CHANGES TO UFD BLK
	UUU UFDUSD,1
	UUU FIXRBP,2	;FOR CHANGS TO RIB
	UUU UFDLSD,1	;THIS UFD HAS LOST DATA
	UUU ERRNAM,1
	UUU ERREXT,1
	UUU ERRPPN,1
	UUU UFDHSP,1	;POINTER TO HASH TABLE FOR UFD
	UUU SIZRIB,1	;NUMBER OF LOGICAL BLOCKS TO EOF
	UUU ALCRIB,1	;NUMBER OF REAL PPAGES

ARRAY MFDRIB,UFDRIB,FILRIB[%%Z]
ARRAY MFDBUF,UFDBUF[1000]

STPT:	MOVE	P,[IOWD PDLSIZ,PDL]	; Set up the stack

IFE DEBUG,<
	HRROI	T,JBTSTS
	GETTAB	T,
	 JRST	NOJAL
	TLO	T,JACCT			;MAKE SURE WE DO NOT GET STOPPED
	SETJAL	T,
	 JRST	NOJAL
>; IFE DEBUG

	SETZM	DETSW#			; Clear AUTO RESTART flag
	MOVE	T,[STAITM,,STATAB]
	GETTAB	T,			; Check state of system
	 MOVEI	T,0
	TLNE	T,1			; Still in AUTO RESTART?
	 SETOM	DETSW#			; Yes, set flag.

	MOVEI	M,[ASCIZ /
     D-S-K-C-L-N     /]
	PUSHJ	P,TRMMES		;IDENTIFY OURSELF
	movei m,[asciz \version: %\]	;[41] 
	pushj p,trmmes			;[41] 
	movei n,vrat			;[41] 
	pushj p,octcty			;[41] tell version number
	movei m,[asciz \
\]
	pushj p,trmmes

	SETOM 	FIXFLG#			; Assume we're doing fixup
	SKIPE	DETSW#			; Are we in AUTO RESTART?
	  JRST	STPT1			; Yes, continue checking
	SETZM	FIXFLG			; No, only checking function - no fixup
	MOVEI	M,[ASCIZ/
SYSTEM IS NOT IN AUTO-RESTART.
ONLY CHECKING FUNCTION WILL BE PERFORMED.
/]
	PUSHJ	P,TRMMES
	JRST	STPT2

STPT1:	ONEJOB				; Skip if we're the only job
	 SKIPA				; no, we're not
	JRST	GOFIX			; yes, continue checking
	MOVEI	M,[ASCIZ/
NOT THE ONLY JOB.
ONLY CHECKING FUNCTION WILL BE PERFORMED.
/]
	PUSHJ	P,TRMMES
	SETZM	FIXFLG			; Checking function only

STPT2:	JSP	P,CHKOPR		; Make sure that we have license
	HRROI	T,JBTSTS		; No, Reset JACCT
	GETTAB	T,
	 JRST	NOJAL
	TLZ	T,JACCT
	SETJAL	T,
	 JRST	NOJAL
RENAD1:	SETZM FIXFLG		;HERE FROM REENTER

GOFIX:	MOVE	P,[IOWD PDLSIZ,PDL]
	PUSHJ	P,CHKLIC	;Determine if prog has correct lic
	MOVE	T,JOBREL	;RECORD UPPER
	MOVEM	T,UPRBND	;BOUND OF CORE.
	movei	t,buf		;[37] addr of input buffer
	movem	t,hiaddr#	;[37] 1st addr in himem not available to GETCOR

;[37] set up software interrupt system for handling paging errors
	move	t,[ia.ree,,intvec]	;[37] 
	intadr	t,		;[37] crank up the software interrupt system
	 jrst	interr		;[37] 
	move	t,[.iaerr,,1]	;[37] page i/o errors,,SI channel 1
	intass	t,		;[37] 
	 jrst	interr		;[37] 
	move	t,[1B0!1B1]	;[37] enable interrupts on channel 1
	intenb	t,		;[37] 
	 jrst	interr		;[37] 

	MOVE T,[IOWD 1000,BUF]
	MOVEM T,IOCW
	SETZM IOCW+1	;SET UP FOR DISK OPERATIONS
	MOVSI T,'STR'
	MOVEM T,CHRBUF	;NOW SEE IF STR IS THERE
	MOVE T,[.CHLEN,,CHRBUF]
	DSKCHR T,
	 JRST ALLSTR	;NOT THERE
	SKIPN T,CHRBUF+.CHSNM
	JRST ALLSTR	;OR NOT PART OF A STRUCTURE
	MOVEM T,STRNAM#	;DO THIS STRUCTURE
	PUSHJ P,CHKSTR
FINSTR:	JRST	QUIT		;DONE

ALLSTR:	SETZM STRNAM
ALLSTL:	MOVE T,STRNAM
	SYSSTR T,	;NEXT STR IN SYSTEM
	 JRST FINSTR
	JUMPE T,FINSTR	;ALL DONE
	MOVEM T,STRNAM
	PUSHJ P,CHKSTR
	JRST ALLSTL

;START OF ROUTINE TO CHECK A SINGLE STR

CHKSTR:	MOVEI	T,TRMSAV
	MOVEM	T,TYODSP
	SETZB	T2,FSTFLG#	;INIT FAST DSKCLN FLAG
	SKIPE	FIXFLG
	JRST	DCTFIX
IFE DEBUG,<MOVSI T3,'LPT'>
IFN DEBUG,<MOVSI T3,'LST'>
	MOVSI T4,LOBUF
	OPEN LPT,T2
	 JRST FALLPT	;CAN NOT GET IT
	MOVE T1,STRNAM
	MOVSI T2,'RAT'
	SETZB T3,T4
	ENTER LPT,T1
	 JRST FALLPT	;CAN NOT GET LPT
DCTENT:	MOVE	P1,[POINT 7,TRMBLK]
	MOVE	T,STRNAM
	PUSHJ	P,PR6BIT
	PUSHJ	P,NULL		;TERMINATE STRING
	OUTSTR	TRMBLK
	OUTSTR	[ASCIZ / MODE CODE: /]	;QUERY USER FOR TYPE CODE
	INCHRW	T		;GET HIS RESPONSE
	SUBI	T,"0"		;CONVERT TO BINARY
	JRST	DCT1
DCTFIX:	MOVE	T,[DCNITM,,DCNTAB]	;GET TYPE CODE FROM
	GETTAB	T,			; SYSTEM
	 MOVEI	T,7		;DEFAULT TO FULL
DCT1:	TDNE	T,[-10]		;DOES CODE OVERFLOW ITS FIELD?
	JRST	DCNDEF		;YES
	XCT	DCNDIS(T)	;DISPATCH ON TYPE
	JRST	CHKST1		;CODE DEFINED

DCNDIS:	JRST	DONST1		;0  NONE
	SETOM	FSTFLG		;1  FAST
	JRST	DCNDEF		;2
	JRST	DCNDEF		;3
	JRST	DCNDEF		;4
	JRST	DCNDEF		;5
	JRST	DCNDEF		;6
	JFCL			;7  FULL

DCNNAM:	0		;0
	SIXBIT /FAST/	;1
	0		;2
	0		;3
	0		;4
	0		;5
	0		;6
	SIXBIT /FULL/	;7

DCNDEF:	SKIPE	FIXFLG
	JRST	DCT2
	OUTSTR	[ASCIZ /
LEGAL CODES ARE: 0=NONE, 1=FAST, 7=FULL.
/]
	JRST	DCTENT		;GIVE USER ANOTHER TRY
DCT2:	MOVE	P1,[POINT 7,TRMBLK]	;MODE READ FROM MONITOR
	MOVE	T,STRNAM		; IS NOT DEFINED, SO
	PUSHJ	P,PR6BIT		; INDICATE ON CTY
	MOVEI	M,[ASCIZ /.  MODE: /]
	PUSHJ	P,MSG
	MOVE	N,DCN
	PUSHJ	P,DECPRT
	MOVEI	M,[ASCIZ / NOT DEFINED, DEFAULTING TO 7.
/]
	PUSHJ	P,MSG
	PUSHJ	P,NULL		;TERMINATE STRING
	MOVEI	M,TRMBLK
	PUSHJ	P,TRMMES
	MOVEI	T,7		;DEFAULT TO FULL DSKCLN
CHKST1:	MOVEM	T,DCN#		;SAVE TYPE FOR FUTURE REFERENCE

; add some comments here to help you figure out how we teach a PDP-10
; to do post-indexed indirect addressing...
	HLRZ	T,JOBSA		;make magic pointers.. start of free core in RH
	HRLI T,U		;and U in LH for indexing - **REMEMBER THIS**
	MOVEM T,PTRPPU#		;stash at start of table of indirect pointers
	SETZB U,STRPPU#		;clean out U and largest blocks/unit

				;now start loop to make blocks/unit table
SETTLE:	PUSHJ P,LNAME		;stuff CHRBUF with 6bit logical name of unit
	MOVE T,[.CHLEN,,CHRBUF]	;set to get some info about a unit...
	DSKCHR T,		;do it
	 JRST INITL		;  must be FINALLY OUT OF UNITS
	MOVEI T,@PTRPPU		;get addr of blks/unit entry via magic pointer,
	PUSHJ	P,GETCOR	;  ..and GET MORE CORE, IF NECESSARY.
	MOVE T,.CHBPU+CHRBUF	;get number of pages (sic) for this unit
	MOVEM T,@PTRPPU		;  ..and stash it in the table via magic pntr.
	CAMLE T,STRPPU		;is it the largest for this structure?
	 MOVEM T,STRPPU		;  yes, stash it
	AOJA U,SETTLE		;increment indirect register and try next unit

;now make magic pointers (as above) to all per unit tables
INITL:	MOVEM U,HIGHU#	;STASH NUMBER OF UNITS
	HLRZ T,JOBSA	;GET STARTING ADDR
	HRLI T,U	;SET TO INDEX
	ADD T,HIGHU	;adjust by # of units to allow for PPU table above

	MOVSI T1,-UNTLEN	;NOW GENERATE POINTERS TO ALL PER UNIT TABLES
CREUNT:	MOVEM T,@UNITAB(T1)
	ADD T,HIGHU
	AOBJN T1,CREUNT

;[37] set up table of per-unit "cache" pages for pre-referencing
	sos	u,highu		;[37] make them number of the highest unit
	movei	t1,bufpag	;[40] page that BUF is on
	 sos	t1		;[37] map/pre-ref page of highest numbered unit
	 movem	t1,@ptrupg	;[37] stash it in the table
	 sojge	u,.-2		;[37] do 'em all
	lsh	t1,^d9		;[37] make it an address
	movem	t1,hiaddr	;[37] stash so GETCOR knows how high to go
ZS T
	MOVEM T,JOBFF		;SAVE POINTER TO FREE CORE.
	PUSHJ	P,GETCOR	;GET MORE CORE, IF NECESSARY.


;[37] now map BUFPAG because PAGRED expects it.
	movsi	t,(.prrw!1b17)	;[37] cow protection, count=1
	hrri	t,bufpag	;[37] starting page
	vcreat	t,		;[37] ask for them privately
	 PUSHJ	P,PAGERR		;[37] lost, complain and die

	MOVEI T,16	;NOW OPEN ALL I/O CHANNELS
	MOVE T1,STRNAM	;TO POINT TO THIS STR
	SETZB	T2,TRBFLG#	;THIS FLAG NON-ZERO IF MULTIPLY USED PAGES PRESENT
	HRLI T3,CIO.OP	;CHANIO OPEN
	MOVSI P1,-MXCHN	;OPEN ALL CHANNELS
	HRR T3,P1
	CHANIO T3,T
	 JRST OPNERR
	AOBJN P1,.-3
	SKIPN	FIXFLG
	OUTBUF LPT,2	;MAKE SURE ROOM FOR OUTPUT BUFFER DECLARED
	MOVE	P1,[POINT 7,TRMBLK+1]	;INIT OUTPUT BYTE PNTR
	PUSHJ	P,IDENT		;IDENTIFY ANALYSIS OF THIS STR
	PUSHJ	P,NULL		;TERMINATE STRING
	SKIPE	FIXFLG
	JRST	CHKST3
	MOVEI	T,LPT		;IS LPT ASSIGNED
	DEVCHR	T,		; TO THE COMMAND
	TLNE	T,DV.TTA	; PORT?
	JRST	CHKST3
	OUTSTR	TRMBLK+1		;NO
	MOVEI	T,TYO		;OUTPUT TO LPT IN CHECK MODE
	SKIPA
CHKST3:	MOVEI	T,TRMOPR	;OUTPUT TO CTY IN FIX MODE
	MOVEM	T,TYODSP
	MOVEI	M,TRMBLK+1
	PUSHJ	P,MSG		;DUMP BUFFER

;NOW READ AND CHECK THE HOME BLOCKS

	MOVEI U,0
	MOVEI CHAN,0
	PUSHJ P,HOMCHK	;READ AND DO PRELIMINARY CHECKS
	 JRST BADHOM	;NOT A GOOD HOME BLOCK
	MOVSI P1,-HOMTLN
HOMMOV:	MOVE T1,HOMTAB(P1)	;GET DATA FROM FIRST HOME BLOCK
	MOVE T,BUF(T1)
	MOVSS T1
	MOVEM T,(T1)
	AOBJN P1,HOMMOV
	PUSHJ P,HOMCOP	;NOW COPY SOME PER/UNIT DATA
NXTHOM:	SKIPN BUF+HOMNXT	;IS THERE A NEXT UNIT?
	JRST ENDHOM	;NO, SHOULD BE ALL DONE
	ADDI U,1	;YES, DO IT
	PUSHJ P,HOMCHK
	 JRST BADHOM
	MOVSI P1,-HOMTLN
HOMSAM:	MOVE T1,HOMTAB(P1)	;THIS INFORMATION SHOULD BE THE SAME IN ALL HOME BLOCKS
	MOVE T,BUF(T1)
	MOVSS T1
	CAME T,(T1)
	JRST BADHOM	;IT IS NOT
	AOBJN P1,HOMSAM
	PUSHJ P,HOMCOP	;GET THE PER UNIT DATA
	JRST NXTHOM	;AND TRY FOR NEXT ONE

ENDHOM:	CAME U,HIGHU	;WE SHOULD HAVE JUUT DONE THE LAST UNT
	JRST HOMNUM	;NO. WRONG NUMBER OF UITS

;NOW GET CORE TO HOLD SAT TABLES

	MOVEI U,0
	MOVE T,JOBFF
	HRRZM T,UFDHSP+MFDRIB
	HLRZS STRHSH	;MAKE IT BE THE CORRECT NUMBER
	ADD T,STRHSH	;ROOM FOR HASH TABLE
	HRRZM T,UFDHSP+UFDRIB
	ADD T,STRHSH
	MOVN T1,STRHSH
	HRLZM T1,STRHAD#
SATULP:	HRRM T,@PTRSAD	;POINTERS TO SAT ADDRESSES
	HLRZ T1,@PTRDST	;NUMBER OF SATS ON UNIT
	ADD T,T1
	ADDI U,1
	CAMG U,HIGHU
	JRST SATULP
	MOVSI P4,-STBLEN	;NOW SET UP VARIOUS SAT TABLES
SATFUN:	MOVE U,HIGHU	;GENERATE A SAT TABLE
SATFN1:	HRRM T,@SATTAB(P4)
	HLRZ T1,@PTRDST
	IMULI T1,400
	ADD T,T1
	SOJGE U,SATFN1
	AOBJN P4,SATFUN
	MOVEM T,ENDSAT#
	HRRZ	T1,T		;SAVE FROM GETCOR.
	PUSHJ	P,GETCOR	;
	HRRZ T,JOBFF
	SETOM (T)
	HRLS T		;SET ALL TO 1'S (UNUSED)
	ADDI T,1
	BLT T,-1(T1)
	MOVEM T1,JOBFF

	MOVE T,SATRIB	;READ THE RIB FOR THE SAT BLOCK
	PUSHJ P,RIBCHK
	 JRST SRBERR	;RIB ERROR
	MOVE T,[BUF,,MFDBUF]	;SAVE RIB HERE
	BLT T,MFDBUF+777
	MOVE U,HIGHU	;NOW READ ALL SATS
NXTSTU:	HLLZ P3,@PTRDST	;NUMBER OF SATS
	MOVNS P3	;TURN INTO AOBJN PTR
	MOVSI P2,-RBLVPR	;AOBJN POINTER TO SAT RIB
NXTSPT:	SKIPN T,MFDBUF+RIBPFS(P2)
	JRST NXTSDN		;EOF
	JUMPL	T,SRBERR	;SPARE PNTRS ARE ILLEGAL.
	TLNN	T,RBREAL	;HOLES ARE ILLEGAL.
	JRST	SRBERR		;
	LDB T1,[POINT PTSUNI,T,PTNUNI]
	CAME T1,U	;IS IT THIS UNIT?
	JRST NXTSP2	;NO, CONTINUE SEARCHING
	JUMPGE P3,SRBERR	;FOUND TOO MANY
	LDB T1,[POINT PTSPNO,T,PTNPNO]
	HRRZ T,P3	;THE NUMBER OF THIS SAT ON THIS UNIT
	ADD T,@PTRSAD
	MOVEM T1,(T)	;AND STORE THE ADDRESS
	PUSHJ P,PAGRED	;READ IT
	 JRST SBKERR	;ERROR
	HRRZ T,P3
	IMULI T,400
	ADD T,@PTRDST	;WHERE TO PUT THE BITS
	MOVE T1,T
	HRLI T,BUF
	BLT T,377(T1)
	AOBJN P3,.+1	;COUNT ONE MORE SAT
NXTSP2:	AOBJN P2,NXTSPT	;SEE IF ANY MORE POINTERS TO LOOK AT
NXTSDN:	JUMPL P3,SRBERR	;NOT ENOUGH SATS
	SOJGE U,NXTSTU	;CONTINUE FOR ALL UNITS

	SETZM ERRSAV#	;NO ERRORS SO FAR
	MOVEI T,FIXPTR
	PUSHJ P,SETFIX		;SET UP POINTER CHAIN
	MOVEI T,FIXBAD
	PUSHJ P,SETFIX		;NO FILES TO REENTER
	SETZM TRBFIL#
	SETZM TRBFLG#		;NO MULTIPLY USED CLUSERS
	MOVE T,JOBFF
	MOVEM T,FREPTR#
	SKIPN	FIXFLG
	JRST	MGONFX

IFE DEBUG, <DSKCLR DC.CLR,
	 JRST .-1	;PCB I/O IN PROGRESS
	JRST	NOCLR>
	MOVEI T,TRMOPR
	MOVEM T,TYODSP
MGONFX:	PUSHJ P,CHKSAT
	MOVEI T,MFDPRC
	MOVEM T,MFDRIB+ROUTIN	;SET UP ROUTINES TO CALL
	MOVEI T,UFDPRC
	MOVEM T,UFDRIB+ROUTIN
	MOVEI T,MFDBUF
	MOVEM T,MFDRIB+SAVBLK
	MOVEI T,UFDBUF
	MOVEM T,UFDRIB+SAVBLK
	MOVEI P4,MFDRIB
	MOVE T1,RIBLBN(P4)
	MOVEM T1,MFDRBC#	;SAVE HERE FOR SPECIAL FILE CHECK
	MOVE T,[1,,1]
	MOVEM T,ERRNAM(P4)
	MOVEM T,ERRPPN(P4)
	MOVSI T,'UFD'
	MOVEM T,ERREXT(P4)

	PUSHJ P,MFDUFD	;PROCESS ALL FILES
	 JRST CRTERM	;SOMETHING WRONG WITH 1,1
	SKIPN TRBFLG	;ANY MULTIPLY USED PAGES?
	JRST NOTRB	;NO
	MOVEI T,FIXPTR	;YES, RESET FIX POINTERS
	PUSHJ P,SETFIX
	MOVEI T,FIXBAD
	PUSHJ P,SETFIX
	SETZM TRBFIL
	MOVE T,JOBFF
	MOVEM T,FREPTR

	SKIPE FIXFLG
	JRST PASS2

	OUTPUT LPT,0
	OUTSTR [ASCIZ /
STARTING PASS 2
/]		
	PUSHJ P,IDENT

PASS2:	MOVE U,HIGHU
	HRRZ T,@PTROST	;CLEAR RIB SAT AND OUR SAT
	SETOM (T)
	HRLS T
	ADDI T,1
	MOVE T1,ENDSAT
	BLT T,-1(T1)
	PUSHJ P,CHKSAT	;RECHECK SAT (IF FIXING SET BITS IN OUR SAT)
	MOVEI P4,MFDRIB
	MOVE T1,RIBLBN(P4)
	MOVEM T1,MFDRBC		;FORCE RECHECK
	PUSHJ P,MFDUFD
	 JRST CRTERM
NOTRB:	PUSHJ P,CHKBAT	;CHECK BAT BLOCKS
	MOVSI T,-SPCLEN	;CHECK THAT ALL CRITICAL FILES FOUND
	SKIPE	FSTFLG	;IF IN FAST MODE ONLY CHECK TO SEE
	MOVSI	T,-SPUFDN	; IF CRITICAL UFDS FOUND
	SKIPL @SPCACT(T)
	JRST MISCRT
	AOBJN T,.-2
	SKIPE FIXFLG
	JRST FINFIX	;FINISH FIXUPS
	PUSHJ P,IDENT
	SKIPE	FSTFLG
	JRST	FRERPT
	MOVEI P4,LOSTAB
	PUSHJ P,CLSSRC	;PRINT LOST PAGES
FRERPT:	MOVEI	P4,FRETAB
	PUSHJ P,CLSSRC	;FREE PAGES
	MOVEI P4,MLTTAB
	PUSHJ P,CLSSRC	;AND MULTIPLY USED PAGES
	MOVE T,ERRSAV
	CLOSE LPT,
	OUTSTR @ERRTAB(T)	;OUTPUT MESSAGE
DONSTR:	RELEASE LPT,0
	MOVSI T,-MXCHN
	HRLI	T3,CIO.RL	;CHANIO RELEASE.
	HRR T3,T
	CHANIO T3,0
	AOBJN T,.-2
	POPJ P,		;FINISHED THIS STR, EXIT

DONST1:	MOVE	P1,[POINT 7,TRMBLK]	;INIT OUTPUT BYTE POINTER
	MOVEI	M,[ASCIZ /

NO ANALYSIS REQUIRED FOR /]
	PUSHJ	P,MSG		;BUFFER MSG
	MOVE	T,STRNAM	;GET TRANSLATE AND 
	PUSHJ	P,PR6BIT	; BUFFER STR NAME
	PUSHJ	P,PDOT
	PUSHJ	P,CRLF2
	PUSHJ	P,NULL
	MOVEI	M,TRMBLK	;OUTPUT TO TTY
	PUSHJ	P,TRMMES	; OR CTY
	SKIPN	FIXFLG
	POPJ	P,	;DONE WITH THIS STR
	DSKCLR	DC.NDS,	;TURN OFF NEED DSKCLN FLAG
	 POPJ	P,	;DONE WITH THIS STR
	JRST	NOJAL	;MISSING WA LIC

;[37] FINFIX:	IFE DEBUG!MAKSW,<DSKCLR DC.CLR,
FINFIX:	IFE DEBUG,<DSKCLR DC.CLR,
	JRST	.-1
	JRST	NOCLR>
	MOVE U,HIGHU	;NOW WRITE OUT SAT TABLES
WRTSAT:	HLRZ P3,@PTRDST	;NUMBER TO WRITE
	SUBI P3,1	;NOW HAVE NUMBER OF THE SAT TO WRITE
	MOVE P2,@PTRSAD	;POINTER TO SAT ADDRESSES TABLE
	HRLI P2,P3	;SET INDEX BY SAT NUMBER
WRTSTU:	MOVE T1,@P2	;READ SAT IN TO KEEP CORE PAGE BITS
	PUSHJ P,PAGRED
	 JRST SBKERR
	MOVE T,P3
	IMULI T,400	;NUMBER OF WORDS/SAT
	MOVE	T1,T
	ADD T,@PTROST
	HRLS T
	HRRI T,BUF
	BLT T,BUF+377
	SKIPN	FSTFLG
	JRST	WRTST1
	MOVEI	T3,0		;INIT PNTR INTO OUR SAT BUFFER
	ADD	T1,@PTRDST	;SET UP AOBJN POINTER TO CURRENT
	HRLI	T1,-400		; DISK SAT ON CURRENT UNIT
SATIOR:	MOVE	T2,(T1)		;GET DISK VALUE FOR THIS SAT WORD
	ANDM	T2,BUF(T3)	;OR WITH OUR SAT WORD
	AOS	T3		;POINT TO NEXT OUR SAT WORD
	AOBJN	T1,SATIOR	;CONTINUE, IF NOT DONE
WRTST1:	MOVE	T1,@P2	;GET SAT ADDRESS
	PUSHJ P,PAGWRT	;WRITE IT OUT
	MOVEI T,0	;NOW COUNT BITS
	MOVSI T1,-400

STCNT3:	MOVE T2,BUF(T1)	;GET F BITS
	AND T2,BUF+400(T1) ;F AND M BITS MUST BE 1
	JUMPE T2,STCNT1	;IF NO BITS THAT ARE BOTH ONE, NO FREE PAGES
	MOVE T3,T2	;COPY BITS INTO T3
	LSH T3,-1	;RIGHT ONE
	AND T3,[333333,,333333] ;MASK OUT FORMER LEAST SIG. BITS IN OCTAL DIGITS
	SUB T2,T3	;D-[D/2]
	LSH T3,-1	;RIGHT ANOTHER POSITION
	AND T3,[333333,,333333] ;JUST HI ORDER
	SUBB T2,T3	;D-[D/2]-[D/4], TWO COPIES
	LSH T3,-3	;SHIFT RIGHT 1 OCTAL DIGIT
	ADD T2,T3	;ADD NUMBERS IN DIGIT PAIRS
	AND T2,[070707,,070707] ;NOW ITS BASE 64
	IDIVI T2,77	;DIVIDE BY 63, NUMBER OF BITS IS IN T3.
	ADD T,T3	;COUNT MORE BITS IN THIS SAT.
STCNT1:	AOBJN T1,STCNT3
	MOVEM T,@P2	;STORE OVER SAT ADDRESS
	SOJGE P3,WRTSTU	;MORE SATS ON THIS UNIT
	SOJGE U,WRTSAT	;AND MORE UNITS IN THIS STR

	MOVE U,HIGHU
	MOVEI T,0
	HLRZ T1,@PTRDST
	ADD T,T1	;COUNT TOTAL NUMBER OF SATS
	SOJGE U,.-2
	MOVNS T
	HRLS T
	MOVEI U,0
	HRR T,@PTRSAD
IFE DEBUG,<
	DSKCLR DC.FPC,
	T
	 JFCL
>
	MOVEI T,FIXREN
	PUSHJ P,SETFIX
	SETOM BLKIN#	;BLOCK IN CORE
	MOVEI P3,FIXPTR
FIXLP:	HLRZ T1,(P3)
	SETZM (P3)	;CLEAR OLD LINK
	SKIPN P3,T1	;NOW SET FOR THIS LINK
	JRST FIXDON
	MOVE T,1(P3)	;BLOCK DESIRED
	CAMN T,BLKIN
	JRST BLKOK	;SAME ONE AS THERE NOW
	EXCH T,BLKIN	;GET OLD ONE
	JUMPL T,NOBWRT	;NOTHING REALLY
	PUSHJ P,PAGWTP	;WRITE IT
NOBWRT:	SKIPGE T,BLKIN
	JRST	[TLZ T,(1B0)	;JAST WANT TO ZERO (FROM ERROR)
		MOVEM T,BLKIN	;DO NOT NEED TO READ FIRST
		JRST BLKOK]	;SINCE HAS ERROR ANYWAY
	PUSHJ P,PAGRDP	;GET BLOCK
	 JRST FRDER	;FATAL READ ERROR
BLKOK:	MOVE T2,2(P3)	;HAVE BLOCK, SET ACS
	MOVE T3,3(P3)
	MOVE T,(P3)
	PUSHJ P,1(T)	;CALL FIXUP ROUTINE
	JRST FIXLP	;CONTINUE

FIXDON:	SKIPL T,BLKIN	;IS A BLOCK IN CORE?
	PUSHJ P,PAGWTP	;YES, WRITE IT OUT
	SKIPE T,FIXREN	;ANY FILES TO REEENTER
	JRST DOREN	;YES, DO IT
	SKIPE FIXBAD	;AND LOCKED OR LOST DATA FILES TO PRINT
	JRST PRNFIL	;YES
	JRST DONSTR	;NO, FINISHED

DOREN:	HLLM T,@FIXBAD+1	;PUT ON END OF LOST DATA LIST
	MOVSS T
	RELEASE DSK,0	;BECAUSE IT IS IN ABSOLUTE MODE
	MOVEI T1,16
	MOVE T2,STRNAM
	MOVEI T3,0
	OPEN DSK,T1
	 JRST PRNFIL		;CAN NOT REENTER THEM
RENFIL:	SETZM FILNAM
	MOVE T1,[FILNAM,,FILNAM+1]
	BLT T1,FILNAM+FLMSTS	;CLEAR EXTRA ENTRIES
	MOVEI T1,RIPBDA
	MOVEM T1,FILNAM+FLMSTS	;SET FOND BAD BY DAMAGE ASSESMENT
	MOVEI T1,FLMSTS
	MOVEM T1,FILNAM		;SET SIZE OF ENTER BLOCK
	MOVE T1,1(T)
	MOVEM T1,FILNAM+FLMNAM
	MOVE T1,2(T)
	HLLZM T1,FILNAM+FLMEXT
	MOVE T1,3(T)
	MOVEM T1,FILNAM+FLMPPN
IFE DEBUG,<ENTER DSK,FILNAM>
	JFCL
	CLOSE DSK,0
	HLRZ T,(T)	;CHECK LINK
	JUMPN T,RENFIL
PRNFIL:	MOVEI	T,RCVBUF
	MOVEM T,JOBFF	;SO WE CAN SET UP BUFFERS
	SETZB T,P4	;P4 IS FLAG TO SAY FILE OPEN
IFE DEBUG,<MOVSI T1,'SYS'>
IFN DEBUG,<MOVSI T1,'DSK'>
	MOVSI T2,LOBUF	;OPEN ERROR RECORD FILE
	OPEN LPT,T
	 JRST FILOPN	;CAN NOT OPEN, P4=0 SAYS THAT
	MOVEI T,3
	MOVEI T1,0
	MOVE T2,[SIXBIT /RECOV/]
	MOVSI T3,'SYS'
	LOOKUP LPT,T
	 JFCL		;TRY TO GET IN UPDATE MODE
	ENTER LPT,T
	 JRST FILOPN	;CAN NOT GET IT
	USETI LPT,-1	;GET TO END
	MOVEI P4,1	;FLAG TO SAY IT IS OPEN

FILOPN:	MOVEI T1,TYOBTH	;OUTPUT TO BOTH
	MOVEM T1,TYODSP
	MOVE P1,[POINT 7,TRMBLK]
	PUSHJ P,IDENT	;IDENTIFY
	MOVEI T1,0
	IDPB T1,P1
	MOVEI M,TRMBLK
	PUSHJ P,TRMMES	;SEND MESSAGE TO TERMINAL
	SKIPN P3,FIXBAD
	JRST DONSTR	;NO BAD FILES TO PRINT
	MOVEI M,[ASCIZ /
THE FOLLOWING FILES HAVE LOST DATA:
/]
	PUSHJ P,FILPRN
	JRST DONSTR

;HERE TO PRINT A MESSAGE AND A LIST OF FILE NAMES

FILPRN:	MOVE P1,[POINT 7,TRMBLK]
	PUSHJ P,MSG
	MOVEI T1,0
	IDPB T1,P1
	MOVEI M,TRMBLK
	PUSHJ P,TRMMES	;SEND MESSAGE (ALSO POSSIBLEY TO FILE)
	MOVSS P3	;GET LIST POINTER
FLPLP:	MOVE P1,[POINT 7,TRMBLK]
	HLRZ T,2(P3)	;GET EXTENSION
	CAIN T,'UFD'	;CHECK FOR UFD
	JRST FLPUFD	;POSSIBLE, MORE CHECKS
FLPNUF:	MOVE T,1(P3)
	PUSHJ P,PR6BIT
FLPEXT:	HLLZ T,2(P3)	;EXTENSION
	SKIPE T
	PUSHJ P,PDOT
	SKIPE T
	PUSHJ P,PR6BIT
	MOVEI CH,"["
	PUSHJ P,@TYODSP
	HLRZ N,3(P3)
	PUSHJ P,OCTPRT
	PUSHJ P,COMMA
	HRRZ N,3(P3)
	PUSHJ P,OCTPRT
	MOVEI CH,"]"
	PUSHJ P,@TYODSP
	PUSHJ P,CRLF
	MOVEI T1,0
	IDPB T1,P1
	MOVEI M,TRMBLK
	PUSHJ P,TRMMES
	HLRZ P3,(P3)	;NEXT LINK
	JUMPN P3,FLPLP
	POPJ P,		;DONE

FLPUFD:	MOVE T,3(P3)	;GET PPN
	CAME T,[1,,1]	;IN MFD?
	JRST FLPNUF	;NO, NOT UFD
	HLRZ N,1(P3)
	PUSHJ P,OCTPRT
	PUSHJ P,COMMA
	HRRZ N,1(P3)
	PUSHJ P,OCTPRT
	JRST FLPEXT

;THIS IS A MAIN ROUTINE.  IT EXPECTS AT LEAST P2 AND P4.
MFDUFD:	MOVEI CHAN,0	;JUST TO MAKE SURE
	MOVEM P2,UFDPTR(P4)
	SETZM UFDLSD(P4)	;NO DATA LOST YET
	SETZM UFDUSD(P4)
	MOVE T,RIBLBN(P4)
	PUSHJ P,FULRBC		;GET ALL THE INFORMATION ON THIS RIB
	 POPJ P,		;SOMETHING WRONG
	MOVE T,SAVRIB+RIBSZS(P4)
	CAIE T,1
	POPJ P,		;MUST BE 1 FOR A UFD
	MOVE T,PTROST
	MOVE T1,RIBLBN(P4)
	PUSHJ P,TSTZRO
	 SKIPA
	POPJ P,		;ALREADY WAS 0, SEEN BEFORE
	MOVE T1,UFDHSP(P4)
	HLL T1,STRHAD
	MOVEI T,0	;SET ORIGINAL VALUES
UMFSLP:	MOVEM T,(T1)
	ADDI T,1
	AOBJN T1,UMFSLP
	MOVEI T,FIXRBP(P4)
	PUSHJ P,SETFIX
	MOVE T,RIBLBN(P4)
	PUSHJ P,FILMKC
	 POPJ P,
NXUFDB:	PUSHJ P,GETBLK
	 JRST UFDIGN	;BAD PAGE
	JUMPE T,UFDDON	;EOF
	AOS SIZRIB(P4)
	TLNN T,RBREAL
	JRST UFDNRL	;NOT A REAL POINTER
	TLNE T,RBSPAR
	JRST UFDIGN	;SPARE POINTERS NOT ALLOWED IN RIBS FOR UFD
	PUSHJ P,FILMKC
	 JRST UFDIGN	;CHECK FOR POINTER MUL USED ETC
	PUSHJ P,PAGRDP	;READ THE BLOCK
	 JRST UFDIGN	;READ ERROR, MAKE BLOCK GO AWAY
	SKIPN T,BUF
	JRST ANYHSH	;BLOCK SHOULD BE EMPTY
	TLZ T,(1B0)
	IDIV T,STRHSH
	HRLM T1,UFDHSP(P4)
	ADD T1,UFDHSP(P4)	;GET A POINTER TO THE HASH TABLE
	MOVE T,DEVREL(P4)
	CAME T,(T1)
	JRST UFDIGN	;BAD HASH CODE
UFDBSZ:	MOVEI T,UFDBKF(P4)
	PUSHJ P,SETFIX
	PUSH P,T1
	SKIPN T,BUF+777
	JRST UFDESH	;END OF LINKS
	CAMLE T,DEVREL(P4)
	CAIL T,RBLVPR
	JRST UFDBDH	;BAD HASH
	MOVE T2,UFDHSP(P4)
	HLL T2,STRHAD
	CAMN T,(T2)
	JRST UFDBDH	;BAD HASH IF ANYONE ELSE POINTS HERE
	AOBJN T2,.-2
	SKIPA
UFDESH:	SETO	T,	;END OF THE WORLD
	POP P,T1
	MOVEM T,(T1)	;RESET HASH LINK
	AOS ALCRIB(P4)
	MOVE T,SAVBLK(P4)
	HRLI T,BUF
	MOVE T1,T
	BLT T,777(T1)
	SETO	T,
	PUSHJ P,@ROUTIN(P4)
	MOVEI T,UFDBKF(P4)
	PUSHJ P,ADDTOT
	JRST NXUFDB	;CONTINUE

UFDIGN:	PUSHJ P,PTRBSB	;BAD POINTER
UFDNRL:	MOVE T1,UFDHSP(P4)
	HLL T1,STRHAD	;THIS IS THE HASH ADDRESS AOBJN
	MOVE T,DEVREL(P4)
	CAMN T,(T1)
	SETOM (T1)		;END OF THIS LINK
	AOBJN T1,.-2
	JRST NXUFDB	;AND GO

ANYHSH:	MOVE T1,UFDHSP(P4)
	HLL T1,STRHAD
	MOVE T,DEVREL(P4)
	CAMN T,(T1)	;LOOK FOR ANY MATCH (EMPTY BLOCK)
	JRST UFDBSZ	;FOUND IT, CONTINUE
	AOBJN T1,.-2	;KEEP LOOKING
	JRST UFDIGN	;COULD NOT FIND IT, CALL IT BAD

UFDBDH:	SKIPN FIXFLG
	JRST UFDBHM
	MOVEI T,UFDBKF(P4)
	MOVE T1,NXTPTR(P4)
	PUSHJ P,ADDFIX
	 JRST UFDESH
	SETZM BUF+777
	POPJ P,

UFDBHM:	ERRLEV (LEVBAD)
	MOVSI T,[ASCIZ /BAD UFD HASH/]
	PUSHJ P,FLRERR
	JRST UFDESH

UFDDON:	SETZM SAVSNM
	MOVEI T1,PRMRB1
	TLNN P4,-1
	MOVEI T1,PRMRB2	;FOR THE MFD
	PUSHJ P,(T1)
	MOVE T2,UFDUSD(P4)
	SKIPE	FSTFLG		;CANNOT DETERMINE USE ERRORS
	JRST	UFDDN1		; IN FAST MODE
	CAME T2,SAVRIB+RIBUSD(P4)
	PUSHJ P,BADUSD
	MOVE T2,UFDUSD(P4)
	CAMLE T2,SAVRIB+RIBMXA(P4)
	PUSHJ P,BADMXA
UFDDN1:	MOVEI T,FIXRBP(P4)
	AOS (P)	;ALL IS OK NOW, SKIP RETURN
	JRST ADDTOT

BADUSD:	SKIPN FIXFLG
	JRST BADUSM
	PUSHJ P,FILFIX
	 POPJ P,
	MOVEM T2,BUF+RIBUSD
	POPJ P,

BADUSM:	HRLZI T,[ASCIZ /USED COUNT INCORRECT/]
	JRST FLMERR

BADMXA:	SKIPN FIXFLG
	JRST BADMXM
	PUSHJ P,FILFIX
	 POPJ P,
	MOVEM T2,BUF+RIBMXA
	POPJ P,

BADMXM:	HRLZI T,[ASCIZ /MAXIMUM USED COUNT INCORRECT/]
	JRST FLMERR

;PROCESS THE MFD (ONE BLOCK OF IT)

MFDPRC:	MOVE P2,SAVBLK(P4)
	HRLI P2,-1000/UFDSIZ
	MOVEM P2,UFDOGP(P4)
MFDPR1:	SKIPN T,UFDNAM(P2)
	POPJ	P,		;0 MEANS THE END.
	TLZ T,(1B0)
	IDIV T,STRHSH
	HLRZ T,UFDHSP(P4)
	CAME T,T1
	JRST	[PUSH P,P2
		JRST MFDDEL]
	MOVE T,UFDNAM(P2)
	HLRZ T1,UFDEXT(P2)
	CAIE T1,'UFD'
	JRST NOTUFD
	MOVE T2,UFDRBP(P2)
	CAMN T2,MFDRBC
	JRST	[SETOM MFDRBC
		JRST SKPENT]
	MOVE P4,[MFDRIB,,UFDRIB]
	HRLZM T1,ERREXT(P4)
	MOVEM T,ERRNAM(P4)
	MOVE T,[1,,1]
	MOVEM T,ERRPPN(P4)
	MOVE T,UFDRBP(P2)
	PUSH P,P2
	MOVEM T,RIBLBN(P4)
	PUSHJ P,MFDUFD	;NOW PROCESS THIS UFD
	 JRST MFDDEL	;NEEDS DELETING
	SKIPE UFDLSD(P4)	;DID FILE IN UFD LOSE DATA?
	SKIPN FIXFLG	;DID A FILE LOSE DATA AND FIXING
	JRST MFDPR2	;NO
	MOVE T1,RIBLBN(P4)
	MOVEI T,FIXPTR
	PUSHJ P,ADDFIX	;ADD A FIXUP ENTRY
	 JRST MFDPR2
	MOVSI T2,RIPBDA
	IORM T2,BUF+RIBSTS	;MARK UFD
	POPJ P,
MFDPR2:	POP P,P2
SKPENT:	ADDI P2,UFDSIZ-1
	MOVEI P4,MFDRIB
	AOBJN P2,MFDPR1
	POPJ P,		;FINISHED A MFD BLOCK

NOTUFD:	MOVE P4,[MFDRIB,,FILRIB]
	MOVEM T,ERRNAM(P4)
	HRLZM T1,ERREXT(P4)
	MOVE T,[1,,1]
	MOVEM T,ERRPPN(P4)
	PUSH P,P2
	MOVE T,UFDRBP(P2)
	MOVEM T,RIBLBN(P4)
	PUSHJ P,FILPRC
	 JRST MFDDEL
	JRST MFDPR2

MFDDEL:	MOVE P2,P4	;SAVE FOR ERROR MESSAGE
	MOVEI P4,MFDRIB
	MOVE T2,(P)
	SUB T2,UFDOGP(P4)
	SKIPN FIXFLG
	JRST MFDRBE
	MOVEI T,UFDBKF(P4)
	MOVE T1,NXTPTR(P4)
	PUSHJ P,ADDFIX
	 JRST MFDRBD
	MOVEI T1,BUF(T2)
	HRLI T1,UFDSIZ(T1)
	BLT T1,BUF+UFDLST-1
	MOVEI T1,BUF+UFDLST+1
	SETZM -1(T1)
	HRLI T1,-1(T1)
	BLT T1,BUF+776
	POPJ P,

MFDRBE:	HRLZI T,[ASCIZ /RIB ERROR/]
	HRRI T,ERRNAM(P2)
	PUSHJ P,PRTRBL
	JRST MFDPR2

MFDRBD:	MOVE T2,(P)		;GET POINTER TO BAD UFD ENTRY
	MOVEI T1,(T2)		;OVERWRITE IT WITH NEXT ENTRY
	HRLI T1,UFDSIZ(T2)	;WHICH IS HERE
	MOVE T2,UFDOGP(P4)	;GET BEGINNING OF MFD IN CORE
	BLT T1,UFDLST-1(T2)	;MOVE EVERYTHING UP
	MOVEI T1,UFDLST+1(T2)	;NOW CLEAR VACANT LAST ENTRY
	SETZM -1(T1)
	HRLI T1,-1(T1)
	BLT T1,776(T2)		;BUT DON'T CLEAR POINTER AT THE END.
	POP P,P2		;RESTORE POINTER TO MFD
	JRST MFDPR1		;AND CONTINUE WHERE WE LEFT OFF.

UFDPRC:	MOVE T1,RIBLBN(P4)
	CAMN T1,SYSRIB
	SETOM SYSRIB
	MOVE U,HIGHU
	SETZM @PTRUNU	;CLEAR UNIT IN USE FLAGS
	SOJGE U,.-1
	SETZM CHANU
	MOVE T1,[CHANU,,CHANU+1]
	BLT T1,CHANU+MXCHN-1	;AND CHANNEL IN USE FLAGS
	SETZM CHNCNT#		;NONE IN USE
	SETZM UFDPCT		;ALSO CLEAR FILE PROCESSED FLAGS
	MOVE T1,[UFDPCT,,UFDPCT+1]
	BLT T1,UFDPCT+777
	MOVE P2,SAVBLK(P4)
	HRLI P2,-1000/UFDSIZ		;SCAN ALL ENTRIES
	MOVEM P2,UFDOGP(P4)	;SAVE POINTER TO ORIGIN
	MOVE P4,[UFDRIB,,FILRIB]
	MOVSI CHAN,-MXCHN
	PUSHJ P,FNDSEK		;START UP ALL POSSIBLE SEEKS
	 JRST FINSEK
	AOBJN CHAN,.-2

FINSEK:	SKIPN	CHNCNT		;ANY FILES TO PROCESS?
	JRST	NEDZT		;NO
	MOVNS CHAN		;GET THE MAX CHANNEL USED
	HRLZM CHAN,BIGCHN#
FINSK0:	MOVE CHAN,BIGCHN	;NOW CYCLE THROUGH CHANNELS
FINSK1:	SKIPN P2,CHANU(CHAN)	;THIS ONE IN USE?
	JRST CHNFRE		;NO
	MOVE T,UFDNAM(P2)
	MOVEM T,ERRNAM(P4)
	MOVE T,UFDEXT(P2)
	HLLZM T,ERREXT(P4)
	MOVE T,ERRNAM+UFDRIB
	MOVEM T,ERRPPN(P4)
	MOVE T,UFDRBP(P2)
	MOVEM T,RIBLBN(P4)
	MOVE T,UFDNAM(P2)
	TLZ T,(1B0)
	IDIV T,STRHSH
	HLRZ T,UFDHSP+UFDRIB
	CAMN T,T1
	PUSHJ P,FILPRC		;PROCESS FILE
	 PUSHJ P,FILDEL		;RIB ERROR, MUST MARK TO DELETE
	MOVE T1,FILLOS
	IORM T1,UFDRIB+UFDLSD
	MOVE T1,ALCRIB(P4)
	ADDM T1,UFDUSD+UFDRIB
	PUSHJ P,FNDSK1		;START A NEW SEEK
	 JRST CHNFRE		;NOTHING NEW TO DO
NXTCHN:	AOBJN CHAN,FINSK1
	JRST FINSK0

CHNFRE:	SKIPE CHNCNT	;ANY STILL ACTIVE
	JRST NXTCHN	;YES, GO FIND THEM AND PROCESS
NEDZT:	MOVEI P4,UFDRIB
	MOVE T1,SAVBLK(P4)
	ADDI T1,777
	SUB T1,P2
	MOVNS T1
	HRL P2,T1	;SET AOBJN POINTER
	SKIPE (P2)
	JRST NEDZRO
	AOBJN P2,.-2
	POPJ P,

;[37] FNDSEK - former seek handling routine now does map/pre-reference
;ENTER AT FNDSEK TO FIND A UFD ENTRY IN THE PAGE POINTED TO BY
;P2, SUCH THAT THE RETRIEVAL PNTR FOR THE RIB OF THAT ENTRY
;IS ON A UNIT THAT IS NOT BUSY AND THE ENTRY HAS NOT
;BEEN PROCESSED BEFORE.  IF FOUND, START THE map/rereference AND SKIP
;RETURN.  IF NONE FOUND, NON-SKIP RETURN.
;[37] enter at fndsk1 when finished processing a file.  mark 
;[37] channel and unit free, then fall into fndsek to get the next file.


FNDSK1:	MOVE P2,CHANU(CHAN)	;HERE WHEN WE HAVE FINISHED A FILE
	MOVE U,CHANUU(CHAN)	;THE UNIT WE WERE PROCESSING
	SETZM CHANU(CHAN)	;CHANNEL IS NOW FREE
	CAMG	U,HIGHU		;IF OUT OF RANGE, LET DISK READING ROUTINE
				; GIVE ERROR
	SETZM @PTRUNU		;ALSO UNIT
	setzm	@ptrpge		;[37] also seen-error flag
	move	t2,@ptrupg	;[37] this guy no longer needed, so 
	hrli	t2,1		;[37] blow him away
	vclear	t2,		;[37] goodbye
	 PUSHJ	P,PAGERR	;[37] loser, go see why
	SOS CHNCNT		;ONE FEWER CHANNEL
FNDSK2:	ADDI P2,UFDSIZ-1		;NEXT FILE
	AOBJP P2,CPOPJ		;SET THE PLACE OF ENDING
FNDSEK:	SKIPN (P2)
	POPJ P,
	LDB U,[POINT PTSUNI,UFDRBP(P2),PTNUNI]
	CAMG U,HIGHU		;IF OUT OF RANGE, LET DISK READING
				;ROUTINE GIVE ERROR
	SKIPN @PTRUNU
	JRST	.+2		;OUT OF RANGE OR UNIT NOT BUSY.
	JRST FNDSK2		;THAT UNIT IS BUSY
	MOVE T2,P2
	SUB T2,UFDOGP+UFDRIB
	SKIPE UFDPCT(T2)	;HAVE WE PROCESSED THAT ONE?
	JRST FNDSK2		;YES
	SETOM UFDPCT(T2)	;NO, WE WILL NOW
	SKIPN	FSTFLG		;running in fast mode?
	 JRST	FNDSK3		;no, do all files
	MOVE	T,UFDUF2(P2)	;yes, fast mode
	TRNN	T,UFPALC	;HAS THIS FILE BEEN MODIFIED RECENTLY?
	 JRST	FNDSK2		;NO, DON'T BOTHER TO PROCESS IT
FNDSK3:	MOVEM P2,CHANU(CHAN)
	MOVEM	U,CHANUU(CHAN)	;CHANNEL IN USE
	AOS CHNCNT
	CAMLE	U,HIGHU		;IF UNIT NUMBER IS BAD,
	JRST	CPOPJ1		;RETURN NOW.
	hrrz	t,chan		;[37] channel number for mapping
	LDB T1,[POINT PTSPNO,UFDRBP(P2),PTNPNO]
	move	t2,strppu	;[37] pages per unit in str
	imul	t2,u		;[37] page num of 1st page on unit
	add	t1,t2		;[37] t1=logical page within str
	movem	t1,@ptrunu	;[37] mark unit in use & stash disk page
	movem	t1,mapwd+1	;[37] stash the disk address (source)
	move	t1,@ptrupg	;[37] get cache page (destination)
	hrli	t1,(.prro!1b17)	;[37] cow protect and only 1, please
	movem	t1,mapwd	;[37] stash it
	hrli	t,.chsmp	;[37] set to super-map it
	chanio	t,mapwd		;[37] ask
	 jrst	prefer		;[37] a loser, handle it
	hrlzi	t,(.addws!1b17)	;[37] add one page to working set
	hllm	t,mapwd		;[37] page we just mapped to
	movei	t,mapwd		;[37] remember where stashed
	hrli	t,.wsrng	;[37] ask to ad to WS
	wsctl	t,		;[37] thusly
	 jrst	prefer		;[37] loser
	move	t1,@ptrupg	;[37] cache page again
	preref	t1,		;[37] pre-reference it to start it in
	 jrst	prefer		;[37] loser, handle it

	JRST CPOPJ1		;GOT IT

prefer:	movei	m,[asciz \
FATAL ERROR IN FNDSEK ROUTINE.  ABORTING...\]
	jrst	faterr		;[37] complain and die


NEDZRO:	SKIPN FIXFLG
	JRST NEDZER	;ERROR MESSAGE
	MOVE T3,P2
	SUB T3,UFDOGP+UFDRIB
	HRRZS T3
	MOVE T1,NXTPTR(P4)
	MOVEI T,UFDBKF(P4)
	PUSHJ P,ADDFIX
	 POPJ P,
	SETZM BUF(T3)
	CAIL T3,776
	POPJ P,		;DONE IF JUST 1 WORD
	ADDI T3,BUF+1
	HRLI T3,-1(T3)
	BLT T3,BUF+776
	POPJ P,

NEDZER:	ERRLEV (LEVUSR)
	MOVE N,NXTPTR(P4)
	HRLZI T,[ASCIZ /NEED EXTRA WORDS ZEROED/]
	HRRI T,ERRNAM(P4)
	JRST PRTRBL

;HERE ON RIB ERROR OR MULTIPLE ENTRY

FILDEL:	SETOM FILLOS
	MOVEI T1,1
	MOVEM T1,ALCRIB(P4)
	SKIPN FIXFLG
	JRST RIBERR	;ERROR ONLY
	MOVE T1,UFDRIB+NXTPTR
	MOVE T2,CHANU(CHAN)
	SUB T2,UFDOGP+UFDRIB
	MOVEI T,UFDBKF+UFDRIB
	MOVE T3,UFDRIB+ERRNAM	;ALSO GET PPN FOR REENTRY
	SETOM	UFDLSD+UFDRIB	;FILE IN UFD HAS LOST DATA
	PUSHJ P,ADDFIX
	 JRST RELDEL	;DIFFENCE IS IF WE WANT TO REENTER NAME
	MOVE T,BUF(T2)	;GET FILE NAME
	MOVEM T,1(P3)	;P3 POINTS TO THE ERROR BLOCK
	MOVE T,BUF+1(T2)
	MOVEM T,2(P3)	;3(P3) IS ALREADY PPN
	HRLM P3,@FIXREN+1	;LINK IN
	HRRZM P3,FIXREN+1	;THIS BLOCK LIKE WILL BE ZERORED LATER
	ADDI	T2,BUF
	HRLI T2,UFDSIZ(T2)
	BLT T2,BUF+UFDLST-1
	MOVEI T2,BUF+UFDLST+1
	SETZM -1(T2)
	HRLI T2,-1(T2)
	BLT T2,BUF+776
	POPJ P,

RIBERR:	MOVE N,RIBLBN+FILRIB
	ERRLEV (LEVUSR)
	HRLZI T,[ASCIZ /RIB ERROR/]
	HRRI T,ERRNAM+FILRIB
	JRST PRTRBL

;REMOVE ENTRY FROM CURRENT UFD BLOCK

RELDEL:	MOVE T1,CHANU(CHAN)	;POINTER
RELDL1:	MOVE T2,BIGCHN
	CAME T1,CHANU(T2)
	AOBJN T2,.-1
	JUMPGE T2,RELDL2	;NOTHING WITH THAT POINTER
	MOVN T,[1,,UFDSIZ]	;BACK UP POINTER
	ADDM T,CHANU(T2)
RELDL2:	ADDI T1,UFDSIZ-1
	AOBJN T1,RELDL1		;GET ALL POINTER SAFTER THIS
	MOVE T1,CHANU(CHAN)
	ADDI T1,UFDSIZ+UFDPCT	;MOVE THE UFDPCT ARRAY
	SUB T1,UFDOGP+UFDRIB
	HRLI T1,UFDSIZ(T1)
	BLT T1,UFDPCT+UFDLST-1
	MOVEI T1,UFDPCT+UFDLST+1
	SETZM -1(T1)
	HRLI T1,-1(T1)
	BLT T1,UFDPCT+776
	MOVE T1,CHANU(CHAN)
	ADDI T1,UFDSIZ
	HRLI T1,UFDSIZ(T1)
	MOVE T2,SAVBLK+UFDRIB
	BLT T1,UFDLST-1(T2)
	HRLI T1,UFDLST(T2)
	HRRI T1,UFDLST+1(T2)
	SETZM UFDLST(T2)
	BLT T1,776(T2)
	POPJ P,

;PROCESS A FILE

FILPRC:	MOVEM P2,UFDPTR(P4)
	MOVEI T1,CPOPJ
	MOVEM	T1,ROUTIN(P4)	;SPECIAL ROUTINE FOR EACH PAGE
	SKIPE TRBFIL
	PUSHJ	P,CRLF		;PROBLEM ON LAST FILE, SEPARATE
	SETZM TRBFIL
	MOVE T,RIBLBN(P4)
	PUSHJ P,FULRBC		;FULL CHECK OF RIB
	 JRST ISCRIT		;CHECK FOR CRITICAL FILE
	MOVE T,RIBLBN(P4)
	PUSHJ P,FILMKC
	 JRST ISCRIT
	MOVSI T,-SPCLEN
	MOVE T1,RIBLBN(P4)
	CAME T1,@SPCACT(T)
	AOBJN T,.-1
	JUMPGE	T,NOSPEC	;SOME FILES NEED SPECIAL CHECKS.

	MOVE T1,SYSNAM(T)	;CHECK NAME, EXT, PPN
	CAME T1,ERRNAM(P4)
	 JRST UFDERR
	HLLZ T1,ERREXT(P4)
	CAME T1,SYSEXT(T)
	 JRST UFDERR
	MOVE T1,SYSPPN(T)
	CAME T1,ERRPPN(P4)
	 JRST UFDERR
	MOVE T1,SPACT2(T)
	PUSHJ P,(T1)		;SO DO THEM
NOSPEC:	MOVEI	T,FIXRBP(P4)
	PUSHJ P,SETFIX	;SET TO RECORD FIXES TO RIB
	MOVE P2,CHANU(CHAN)	;POINT TO CHANNEL
	SETZM SAVSNM#	;FOR RECORDING SNM IN FIRST RIB
	SETOM SPAROK#		;OK TO HAVE A SPARE POINTER
	SETZM EOFSEN#
	SETZM FILLOS#
	SETZM FILTRB#
FILRBN:	PUSHJ P,SETPTR
FILCNT:	PUSHJ P,GETBLK
	 JRST PTRBAD		;NOT A GOOD POINTER
	TLZE T,RBSPAR
	JRST SPRPTR
	JUMPE T,RIBEOF
	SKIPE EOFSEN
	JRST FRCEOF	;SHOULD HAVE BEEN A ZERO POINTER HERE
	AOS SIZRIB(P4)	;COUNT 1
	SETZM SPAROK	;NO SPARE AFTER A REAL ONE
	TLNN T,RBREAL
	JRST FILCNT
	PUSHJ P,FILMKC	;MARK AND CHECK
	 JRST PTRBD1	;ITS BAD
	PUSHJ P,@ROUTIN(P4)	;CALL SPECIAL PROCESSOR
	AOS ALCRIB(P4)
	JRST FILCNT

SPRPTR:	SKIPN SPAROK
	 JRST PTRBAD	;CAN NOT USE SPARE HERE
	PUSHJ P,FILMKC
	 JRST PTRBAD	;CAN NOT USE IF MULTIPLE ETC
	PUSHJ P,RIBCHK
	 JRST PTRBAD	;NOT A GOOD SPARE RIB
	MOVE T1,DEVRSU(P4)
	MOVE T2,SAVRIB+RIBSLF(P4)
	CAME T2,BUF+RIBRIB
	 JRST PTRBAD
	SUBI T1,SAVRIB+1(P4)
	HRRZS T1
	CAME T1,BUF+RIBRPS
	JRST PTRBAD
	PUSHJ P,COPTR
	AOS ALCRIB(P4)
	JRST FILRBN	;GO

    ;SUBR TO SET THE F BIT FOR THE RETRIEVAL PNTR IN T, IN
    ;THE PTROST SATS.  FIRST CHECKS PTRTST AND PTRDST.

FILMKC:	PUSH P,T
	MOVE T1,T
	MOVE	T,PTRTST	;IS THIS BIT
	PUSHJ	P,TSTZRO	;ALREADY KNOWN TO BE MUL USED?
	JRST	MKNMLT		;NO.
	SETOM	FILTRB		;YES.
	SETOM	TRBFLG		;TROUBLE (MULTIPLE USED)
	PUSHJ P,ISCRIT
	SKIPE FIXFLG
	JRST	TPOPJ		;JUST RETURN IF FIXING
	ERRLEV (LEVBAD)
	MOVSI T,[ASCIZ /MULTIPLY-USED CLUSTER/]
	PUSHJ P,FREETR
MKNMLT:	MOVE T1,(P)
	MOVE	T,PTRDST	;IS THIS BIT MARKED IN USE
	PUSHJ	P,TSTZRO	;IN THE DISK SATS?
	PUSHJ	P,FREE		;NO, MAYBE REPORT USED BUT NOT MARKED.
	MOVE	T1,(P)		;YES.
	MOVE	T,PTROST	;MARK THIS BIT IN USE
	PUSHJ	P,MRKZRO	;IN OUR SATS.
	SKIPA			;BAD NEWS, ALREADY IN USE.
	JRST	TPOPJ1		;SUCCESS.
	SETOM TRBFLG
	SETOM FILTRB
	MOVE T1,(P)
	MOVE	T,PTRTST	;MARK THIS BIT IN THE MULTIPLY
	PUSHJ	P,MRKZRO	;USED SATS.
	 JFCL
	SKIPA
TPOPJ1:	AOS -1(P)
TPOPJ:	POP P,T
	POPJ P,


FREE:	SKIPE FIXFLG
	POPJ P,		;NOTHING IF FIXING
	MOVSI T,[ASCIZ /USED BUT NOT MARKED IN SAT/]
	ERRLEV (LEVBAD)
FREETR:	HRRI T,ERRNAM(P4)
	MOVE	N,-1(P)
	JRST PRTRBL

RIBEOF:	SKIPL T2,DEVRSU(P4)
	JRST RIBZEF		;OUT OF POINTERS, NONE TO ZERO
	SKIPE  (T2)		;REMAINING MUST BE ZERO
	JRST RIBNZF
	AOBJN T2,.-2
RIBZEF:	MOVE T1,SAVRIB+RIBSFS(P4)
	SKIPN SAVRIB+RIBRIB(P4)
	MOVE T1,SAVRIB+RIBPFS(P4)
	TLNE T1,RBSPAR
	JRST RBEOF1	;FIRST IS A SPARE POINTER
	MOVEI T2,1
	CAME T2,SAVRIB+RIBSZS(P4)	;MUST BE 1
	PUSHJ P,BADSZS
RBEOF1:	SKIPN T,SAVRIB+RIBRIB(P4)
	JRST PRMRIB	;BACK TO PRIME RIB, CONTINUE
	MOVEM T,RIBLBN(P4)
	PUSHJ P,RIBCHK
	JRST ISCRIT	;CALL IT A RIB ERROR
	SETZM SPAROK	;UNLESS RESET BELOW
	SKIPN T1,SAVRIB+RIBLST(P4)
	SETOM EOFSEN	;EOF HAS BEEN SEEN
	MOVE T,SAVRIB+RIBSZS(P4)
	TLNN T1,RBSPAR
	CAIN T,1
	SETOM SPAROK	;SPARE POINTERS OK IN THIS CASE
	MOVE T1,SAVRIB+RIBRPS(P4)
	HRLI T1,-RIBLST(T1)
	ADDI T1,SAVRIB+1(P4)
	MOVEM T1,DEVRSU(P4)
	SUBI T1,SAVRIB+RIBPFS(P4)
	HRRZM T1,SAVSNM		;SAVE LAST SPARE RIB SEEN
	PUSH P,SAVRIB+RIBSZS(P4)
	PUSHJ P,COPTR
	POP P,T2
	IMULI T2,RBLVSR
	CAME T2,SAVRIB+RIBSZS(P4)
	PUSHJ P,BADSZS
	JRST FILCNT		;AND GO

PTRBSB:	AOS SIZRIB(P4)
	SETZM SPAROK
	PUSHJ P,ISCRIT
	SKIPN FIXFLG
	JRST BDPMER
	SETOM FILLOS
	MOVE T2,DEVRSU(P4)
	SUBI T2,1+SAVRIB(P4)
	PUSHJ P,FILFIX
	 POPJ P,
	MOVEI T3,1
	MOVEM T3,BUF(T2)
	POPJ P,

BDPMER:	ERRLEV (LEVCRS)
	MOVSI T,[ASCIZ /BAD RETRIEVAL POINTER/]
	JRST FLRERR

PTRBD1:	SOS SIZRIB(P4)
PTRBAD:	PUSHJ P,PTRBSB
	JRST FILCNT

FRCEOF:	MOVE T2,DEVRSU(P4)
	SUBI T2,1	;POINT AT ONE WHICH SHOULD BE ZERO
	JRST RIBNZF	;AND GO ZERO THEM

EOFERM:	ERRLEV (LEVCRS)
	MOVSI T,[ASCIZ /SHOULD HAVE FOUND EOF/]
	PUSHJ P,FLRERR
	JRST RIBEOF

BADSZS:	MOVEM T2,SAVRIB+RIBSZS(P4)
	SKIPN FIXFLG
	JRST SZSERM
	PUSHJ P,FILFIX
	 POPJ P,
	MOVEM T2,BUF+RIBSZS
	POPJ P,

SZSERM:	ERRLEV (LEVCRS)
	MOVSI T,[ASCIZ /BAD RIBSZS/]
	JRST FLRERR

RIBNZF:	SETZM (T2)	;ZERO EXTRA POINTERS T2 IS POINTER
	HRL T,T2
	HRRI T,1(T2)
	SUBI T2,SAVRIB(P4)
	CAIE T2,RIBLST
	BLT T,SAVRIB+RIBLST(P4)	;NO BLT IF AT END
	SKIPN FIXFLG
	JRST EOFERM
	PUSHJ P,FILFIX
	 JRST RIBEOF	;WILL FIND IT ZERO NOW
	SETZM BUF(T2)
	CAIN T2,RIBLST
	POPJ P,		;DO NOT OVERFLOW ON BLT
	HRLI T2,BUF(T2)
	ADDI T2,BUF+1
	BLT T2,BUF+RIBLST
	POPJ P,


PRMRIB:	AOS (P)
	MOVEI T,0
	PUSHJ P,@ROUTIN(P4)	;DONE
	PUSHJ	P,PRMRB1
	MOVEI T,FIXRBP(P4)
	JRST ADDTOT

COMMENT #
@@SUBROUTINE PRMRB1/PRMRB2
@@PURPOSE
SUBRS TO CHECK MANY NON-RETRIEVAL PNTR THINGS ABOUT THE PRIME
RIB, SUCH AS DATE, TIME, ALP, ETC.
@@ENTRY
THERE ARE TWO ENTRY POINTS, PRMRB1 AND PRMRB2.
EXPECTS THE RIB TO BE IN SAVRIB(P4).
@@ACCUM
@@EXIT
@@ #

PRMRB1:	MOVE P2,UFDPTR(P4)	;WHERE WE SAVED IT
	HRRZ T,UFDLIC(P2)
	HRRZ T2,SAVRIB+RIBLCW(P4)
	CAME T,T2	;LICENSE FIELDS SHOULD MATCH
	PUSHJ P,BADLIC	;BUT DO NOT
	LDB T,[POINT 9,UFDPRV(P2),35]
	LDB T2,[POINT 9,SAVRIB+RIBPVW(P4),8]
	CAME T,T2	;CHECK PROTECTION FIELD
	PUSHJ P,BADPRV
	LDB T2,[POINT 11,SAVRIB+RIBPVW(P4),23]	;MIN
	IMULI T2,^D60
	LDB T1,[POINT 6,SAVRIB+RIBLCW(P4),17]	;SEC
	ADD T2,T1
	LDB T,[POINT 17,UFDTMD(P2),23]	;NOW FROM UFD
	CAME T,T2
	PUSHJ P,BADTIM
	LDB T,[POINT 12,UFDTMD(P2),35]
	LDB T1,[POINT 2,UFDTMD(P2),6]	;EXTRA 2 BITS
	DPB T1,[POINT 2,T,23]
	LDB T2,[POINT 12,SAVRIB+RIBPVW(P4),35]
	LDB T1,[POINT 2,SAVRIB+RIBEXT(P4),21]
	DPB T1,[POINT 2,T2,23]
	CAME T,T2	;CHECK DATE
	PUSHJ P,BADDAT
	MOVE	T,UFDUF2(P2)
	MOVE	T4,SAVRIB+RIBLCW(P4)
	SKIPN	FIXFLG		;IN CHECK MODE ONLY REPORT
	JRST	MODCL1		; DIFFERENCES IN MOD BIT IN UFD AND RIB
	TRNN	T,UFPALC	;IS UFD MOD BIT SET?
	JRST	MODCL2		;NO
	PUSHJ	P,SETUFX	;INSERT UFD FIX UP ENTRY
	 JRST	MODCL2
	MOVEI	T2,UFPALC	;CLEAR UFD FILE
	ANDCAM	T2,BUF+UFDUF2(T3)	; RECENTLY MOD BIT
	POPJ	P,
MODCL2:	TLNN	T4,RIPALC	;IS RIB FILE MODE BIT SET?
	JRST	PRMRB0		;NO
	PUSHJ	P,FILFIX	;INSERT FILE FIX UP ENTRY
	 JRST	PRMRB0
	MOVSI	T2,RIPALC	;CLEAR FILE RIB RECENTLY
	ANDCAM	T2,BUF+RIBLCW	; MOD BIT
	POPJ	P,
MODCL1:	LSH	T,^L<UFPALC>-<^L<RIPALC>-^D18>	;ARE BOTH
	XOR	T,T4		; FILE RIB AND UFD FILE RECENTLY MOD
	TLNN	T,RIPALC	; BITS SET OR CLEAR?
	JRST	PRMRB0		;YES
	HRLZI	T,[ASCIZ /ONLY UFPALC SET/]
	TLNE	T4,RIPALC
	HRLZI	T,[ASCIZ /ONLY RIPALC SET/]
	PUSHJ	P,FLMERR	;OUTPUT ERROR MSG
PRMRB0:	LDB	T,[POINT 9,UFDPRV(P2),26]
	TRZ	T,UFPALC_-<^D35-^D26>	;IGNORE UFPALC
	LDB	T2,[POINT 8,SAVRIB+RIBLCW(P4),11]
	TRZ	T2,RIPALC_-<^D17-^D11>	;IGNORE RIPALC
	CAME T,T2
	PUSHJ P,BADBT1	;WRONG BITS
	LDB T,[POINT 5,UFDTMD(P2),4]
	LDB T2,[POINT 4,SAVRIB+RIBLCW(P4),3]
	CAME T,T2
	PUSHJ P,BADBT2
	MOVE T2,ALCRIB(P4)
	CAIL T2,400000
	MOVEI T2,400000		;THE FUNNY 18-BIT TRUNCATION
	HLRZ T1,UFDALC(P2)
	CAME T1,T2
	PUSHJ P,BADALU
PRMRB2:	PUSHJ P,ISUFD	;SKIP IF UFD
	TDZA T,T
	MOVEI T,RIPDIR
	XOR T,SAVRIB+RIBSTS(P4)	;MAKE SURE DIR BIT CORRECT
	TRNE T,RIPDIR
	PUSHJ P,BADDIR
	MOVE T2,ALCRIB(P4)
	CAME T2,SAVRIB+RIBALP(P4)
	PUSHJ P,BADALP		;WRONG NUMBER OF PAGES ALLOCATED
	MOVE T1,SAVRIB+RIBSIZ(P4)
	TRZE T1,777
	ADDI T1,1000	;ONLY KNOW TO PAGES
	MOVE T2,SIZRIB(P4)
	LSH T2,9	;CONVERT PAGES TO WORDS
	CAMGE T2,T1
	PUSHJ P,BADSIZ
	MOVE T2,SAVSNM
	CAME T2,SAVRIB+RIBSNM(P4)
	PUSHJ P,BADSNM
	POPJ P,		;ALL DONE

;HERE FOR THE VARIOUS ERRORS

BADLIC:	SKIPN FIXFLG
	JRST LICERM
	PUSHJ P,SETUFX
	 POPJ P,
	HRRM T2,BUF+UFDLIC(T3)	;SET LICENSE WHEN FIXING
	POPJ P,

LICERM:	HRLZI T,[ASCIZ /WRONG UFD LICENSE/]
FLMERR:	ERRLEV (LEVMIN)
FLRERR:	MOVE N,RIBLBN(P4)
	HRRI T,ERRNAM(P4)
	JRST PRTRBL

BADPRV:	SKIPN FIXFLG
	JRST PRVERM
	PUSHJ P,SETUFX
	 POPJ P,
	DPB T2,[POINT 9,BUF+UFDPRV(T3),35]
	POPJ P,

PRVERM:	HRLZI T,[ASCIZ /WRONG UFD PROTECTION/]
	JRST FLMERR

SETUFX:	HLRZ T1,P4	;GET PLACE CALLED FROM
	MOVEI T,UFDBKF(T1)
	MOVE T3,P2
	SUB T3,UFDOGP(T1)
	MOVE T1,NXTPTR(T1)	;THE PLACE TO FIX
	JRST ADDFIX

BADTIM:	SKIPN FIXFLG
	JRST TIMERM
	PUSHJ P,SETUFX
	 POPJ P,
	DPB T2,[POINT 17,BUF+UFDTMD(T3),23]
	POPJ P,

TIMERM:	HRLZI T,[ASCIZ /WRONG UFD TIME/]
	JRST FLMERR

BADDAT:	SKIPN FIXFLG
	JRST DATERM
	PUSHJ P,SETUFX
	 POPJ P,
	DPB T2,[POINT 12,BUF+UFDTMD(T3),35]
	LSH T2,-^D12		;NOW HIGH ORDER 2 BITS
	DPB T2,[POINT 2,BUF+UFDTMD(T3),6]
	POPJ P,

DATERM:	HRLZI T,[ASCIZ /WRONG UFD DATE/]
	JRST FLMERR

BADBT1:	SKIPN FIXFLG
	JRST BT1ERM
	PUSHJ P,SETUFX
	 POPJ P,
	DPB T2,[POINT 9,BUF+UFDPRV(T3),26]
	POPJ P,

BT1ERM:	HRLZI T,[ASCIZ /WRONG UFD BITS1/]
	JRST FLMERR

BADBT2:	SKIPN FIXFLG
	JRST BT2ERM
	PUSHJ P,SETUFX
	 POPJ P,
	DPB T2,[POINT 5,BUF+UFDTMD(T3),4]
	POPJ P,

BT2ERM:	HRLZI T,[ASCIZ /WRONG UFD BITS2/]
	JRST FLMERR

BADDIR:	SKIPN FIXFLG
	JRST DIRERM
	PUSHJ P,FILFIX
	 POPJ P,
	MOVEI T2,RIPDIR
	XORM T2,BUF+RIBSTS
	POPJ P,

FILFIX:	MOVEI T,FIXRBP(P4)
	MOVE T1,RIBLBN(P4)
	JRST ADDFIX

DIRERM:	HRLZI T,[ASCIZ /RIPDIR SET WRONG/]
	JRST FLMERR

BADSNM:	SKIPN FIXFLG
	JRST SNMERM
	PUSHJ P,FILFIX
	 POPJ P,
	MOVEM T2,BUF+RIBSNM
	POPJ P,

SNMERM:	MOVSI T,[ASCIZ /NUMBER OF SUBRIBS WRONG/]
	JRST FLMERR

BADALP:	SKIPN FIXFLG
	JRST ALCERM
	PUSHJ P,FILFIX
	 POPJ P,
	MOVEM T2,BUF+RIBALP
	POPJ P,

ALCERM:	MOVSI T,[ASCIZ /ALLOCATION WRONG/]
	ERRLEV (LEVCRS)
	JRST FLRERR

BADSIZ:	SKIPN FIXFLG
	JRST SIZERM
	PUSHJ P,FILFIX
	 POPJ P,
	MOVEM T2,BUF+RIBSIZ
	POPJ P,

SIZERM:	MOVSI T,[ASCIZ /SIZE WRITTEN WRONG/]
	ERRLEV (LEVCRS)
	JRST FLRERR

BADALU:	SKIPN FIXFLG
	JRST ALUERM
	PUSHJ P,SETUFX
	 POPJ P,
	HRLM T2,BUF+UFDALC(T3)
	POPJ P,

ALUERM:	MOVSI T,[ASCIZ /UFD ALLOCATION MISMATCH/]
	JRST FLMERR

;SPECIAL PROCESSING ROUTINES FOR CERTAIN FILES

;SYSPRC==CRTERR
SYSPRC:	MOVEI	M,[ASCIZ /RIB POINTER TO (SYS) FOUND IN MFD/]
	JRST	CRTERR

;MFDPC1==CRTERR
MFDPC1:	MOVEI	M,[ASCIZ /RIB POINTER TO MFD FOUND IN MFD/]
	JRST	CRTERR

SATPRC:	SETOM SATRIB
	POPJ P,

;HOME.SYS FILE.  CHECK THE RIB AGAINST OUR IMPRESSION OF WHAT IT SHOULD
; BE.  ITS RIB IS CREATED BY THE CODE IN REFSTR @ INISA5+2, FF.
;THE TWO HOME PAGES ARE ALLOCATED FIRST, NEXT THE BAT PAGES,
; AND THEN THE BOOTSTRAP AREA.  IN KA,I,L SYSTEMS THE BOOTSTRAP
; AREA IS 3 PAGES LONG.  IN KS SYSTEMS IT IS 100 PAGES LONG.
HOMPRC:	MOVEI T1,HOMRTN
	MOVEM T1,ROUTIN(P4)
	MOVEM T,RTNIDX#		;SAVE IN CASE OF ERROR
	SETZM RTNUNI#
	SETOM RTNPAG#		;GET STARTED
	HLRZ T1,CHRBUF+.CHBSA	;COMPUTE SIZE OF HOME FILE.
	ADDI T1,HTL		;PAGE 0, HP1, HP2, BP1, BP2
	MOVEM T1,HFSIZ#
	POPJ P,

HOMRTU:	SETOM RTNPAG
	AOS U,RTNUNI		;NEXT UNIT
	CAMG U,HIGHU		;END?
	 JRST HOMRTN		;NO
	JUMPN T,CRTIDX		;J-NOT EOF SO ERROR.
	SETOM HOMRIB
	POPJ P,

HOMRTN:	AOS T1,RTNPAG
	CAML T1,HFSIZ
	 JRST HOMRTU		;FINISHED WITH THIS UNIT
	CAIL T1,HTL
	 JRST [	ADD T1,CHRBUF+.CHBSA	;HOMLTB+N -> RH(.CHBSA)+N, N>=0
		SUBI T1,HTL
		HRRZS T1
		JRST HOMRT1]
	CAIGE T1,HTL
	 XCT HOMTBL(T1)
HOMRT1:	MOVE U,RTNUNI
	DPB U,[POINT PTSUNI,T1,PTNUNI]
	TLO T1,RBREAL
	CAMN T1,T
	 POPJ P,		;THIS ONE IS OK
CRTIDX:	MOVE T,RTNIDX
	JRST CRTERR		;ERROR

HOMTBL:	SETZ T1,
	HLRZ T1,CHRBUF+.CHHA
	HRRZ T1,CHRBUF+.CHHA
	HLRZ T1,CHRBUF+.CHBA
	HRRZ T1,CHRBUF+.CHBA
HTL==.-HOMTBL

repeat 0,<			; removed by edit 35
SWPPRC:	MOVEI T1,SWPRTN
	MOVEM T1,ROUTIN(P4)
	MOVEM T,RTNIDX
	SETZM RTNCNT#
	SETOM RTNUNI
	POPJ P,

SWPRTU:	AOS U,RTNUNI
	CAMLE U,HIGHU
	JRST SWPEOF
	SKIPN T1,@PTRSWP
	JRST SWPRTU	;NO SPACE ON THIS UNIT
	MOVEM T1,RTNCNT
	MOVE T1,@PTRSWB
	MOVEM T1,RTNPAG
SWPRTN:	SOSGE RTNCNT
	JRST SWPRTU
	MOVE T1,RTNPAG
	MOVE U,RTNUNI
	DPB U,[POINT PTSUNI,T1,PTNUNI]
	TLO T1,RBREAL
	CAME T1,T
	JRST CRTIDX
	AOS RTNPAG
	POPJ P,

SWPEOF:	JUMPN T,CRTIDX
	SETOM SWPRIB
	POPJ P,
>; end repeat 0
;TABLES USED BY VARIOUS ROUTINES

;POINTERS TO VARIOUS PER UNIT TABLES
;[37] note that the loop at CREUNT makes all these be indexed
;[37] pointers with U as the indexing register.

UNITAB:	PTRDST#		;DISK SATS
	PTRTST#		;TROUBLE SATS (FOR MULTIPLY USED PAGES)
	PTROST#		;OUR SAT (CREATED BY DSKCLN)
	PTRSAD#		;SAT ADDRESSES
	PTRUNU#		;UNIT IN USE 
		;[37] PTRUNU now contains the disk page number if a
		;[37] map/pre-ref has been done on this unit and the
		;[37] page in question has not made it to BUF yet.
		;[37] otherwise, it contains zero.
	ptrupg#		;[37] "disk cache" page associated with unit
			;[37] for map/pre-ref
	ptrpge#		;[37] zero if no hardware error detected
			;[37] -1 if hardware error detected during pre-ref
	PTRSWP#		;NUMBER OF K FOR SWAPPING ON UNIT
	PTRSWB#		;FIRST BLOCK FOR SWAPPING
UNTLEN==.-UNITAB

;USED TO READ AND CHECK INFORMATION IN HOME BLOCKS

HOMTAB:	STROVR#,,HOMOVR	;OVERDRAW
	SATRIB#,,HOMSAT	;SAT.SYS RIB
	HOMRIB#,,HOMHMS	;HOME.SYS RIB
	SWPRIB#,,HOMSWP	;SWAP.SYS RIB
	SYSRIB#,,HOMSUF	;SYS UFD RIB
	MFDRIB+RIBLBN,,HOMMFD	;1,1.UFD RIB
	STRHSH#,,HOMHSH		;HASH FOR UFD
HOMTLN==.-HOMTAB

;TABLE TO USE IN SETTING UP SATS

SATTAB:	@PTRDST		;DISK SAT
	@PTRTST		;TROUBLE SAT (MULIPLY USED PAGES)
	@PTROST		;OUR SAT (THE ONE WE ARE CREATING)
STBLEN==.-SATTAB

;ERROR MESSAGES AFTER DSKRAT

ERRTAB:	[ASCIZ /
NO DISK PROBLEMS/]
	[ASCIZ /
ONLY MINOR ERRORS DETECTED. OK TO BRING SYSTEM UP FOR USERS/]
	[ASCIZ /
ERRORS DETECTED WHICH MAY BE SERIOUS TO INDIVIDUAL USERS.
SHOULD NOT KILL SYSTEM/]
	[ASCIZ /
ERRORS DETECTED WHICH MAY CAUSE SYSTEM CRASHES. SUGGEST FIXING
ERRORS BEFORE BRING SYSTEM UP FOR USERS/]
	[ASCIZ /
ERRORS DETECTED WHICH MAY CAUSE SEVERE DISK GARBAGING. DO NOT
BRING SYSTEM UP FOR USERS UNTIL ERRORS ARE FIXED/]
	REPEAT 20+ERRTAB-.,<[0]>

LOSTAB:	@PTRDST	;FIRST SAT TO USE
	@PTROST	;SECOND SAT TO USE
	NOLOS	;NO LOST PAGES MESSAGE
	HEDLOS	;HEADER FOR LOST PAGES
	TOTLOS	;TOTAL LOST MESSAGE
	ERRLEV (LEVMIN)	;PUSHJ HERE TO SET ERROR LEVEL
	POPJ P,
	TDNE T1,(T4)	;PUSHJ HERE TO TEST FOR LOST. IN OUR SAT?
	TDNE T1,(T3)	;NO, IN DISK SAT?
	POPJ P,	;IN OURS OR IN NEITHER
	JRST CPOPJ1	;NOT IN OURS BUT IN DISK

NOLOS:	ASCIZ /
THERE ARE NO LOST PAGES (MARKED IN USE, BUT IN NO FILE).
/
HEDLOS:	ASCIZ /
THE FOLLOWING PAGES ARE LOST (MARKED IN USE, BUT IN NO FILE):
/
TOTLOS:	ASCIZ /
TOTAL NUMBER OF LOST PAGES = /

FRETAB:	@PTRDST	;CHECK FOR FREE PAGES
	@PTROST
	NOFREE
	HEDFRE
	TOTFRE
	ERRLEV (LEVBAD)
	POPJ P,
	TDNN T1,(T4)	;IN OUR SAT?
	TDNN T1,(T3)	;YES, IN DISK SAT?
	POPJ P,		;NOT IN OURS OR IN BOTH
	JRST CPOPJ1	;IN OURS BUT NOT DISK

NOFREE:	ASCIZ /
THERE ARE NO FREE PAGES (NOT MARKED IN USE, BUT IN SOME FILE).
/
HEDFRE:	ASCIZ /
THE FOLLOWING PAGES ARE FREE (NOT MARKED IN USE, BUT IN SOME FILE):
/
TOTFRE:	ASCIZ /
TOTAL NUMBER OF FREE PAGES = /

MLTTAB:	@PTRTST	;TROUBLE SAT
	@PTRTST	;REALLY ONLY ONE THAT MATTERS
	NOMULT
	HEDMLT
	TOTMLT
	POPJ P,		;ERROR LEVEL ALREADY SET
	POPJ P,
	TDNN T1,(T3)
	AOS (P)	;BAD IF MARKED
	POPJ P,

NOMULT:	ASCIZ /
THERE ARE NO MULTIPLY USED PAGES (BELONG TO MORE THAN ONE FILE).
/
HEDMLT:	ASCIZ /
THE FOLLOWING PAGES ARE MULTIPLY USED (BELONG TO MORE THAN ONE FILE):
/
TOTMLT:	ASCIZ /
TOTAL NUMBER OF MULTIPLY USED PAGES = /

	DEFINE SPCMAC
< IFNDEF XX,<XX:>
	X <1,,1>,UFD,MFDRBC,MFDPC1
	X <1,,4>,UFD,SYSRIB,SYSPRC
  IFNDEF SPUFDN,<SPUFDN==.-XX>		;;# OF UFD ENTRIES
	X HOME,SYS,HOMRIB,HOMPRC
	X SAT,SYS,SATRIB,SATPRC
;;	X SWAP,SYS,SWPRIB,SWPPRC	;; nobody cares anymore!
	X CRASH,SAV,[-1],CPOPJ
>

	DEFINE X (A,B,C,D)
	<C>
;CHECK FOR SPECIAL FILE
SPCACT:	SPCMAC

	DEFINE X (A,B,C,D)
	<D>
;ACTION TO TAKE FOR SPECIAL FILES
SPACT2:	SPCMAC

	DEFINE X (A,B,C,D)
	<IFIDN <B><UFD>,<1,,1>
	IFDIF <B><UFD>,<1,,4>>
;PPN FOR SPECIAL FILE
SYSPPN:	SPCMAC

	DEFINE X (A,B,C,D)
	<IFIDN <B><UFD>,<A>
	IFDIF <B><UFD>,<SIXBIT /A/>>
;NAME OF SPECIAL FILES
SYSNAM:	SPCMAC

	DEFINE X (A,B,C,D)
	<SIXBIT /B/>
;EXTENSION OF SPECIAL FILES
SYSEXT:	SPCMAC
	SPCLEN==.-SYSEXT

;ERROR ROUTINES

TRMMES:	SKIPE DETSW	;MESSAGE POINTED TO BY M
	JRST DETMSG	;EVENTUALLY TO CTY
	OUTSTR @M
	POPJ P,

;Check for SY, ST, JL, RA, and WA lic

CHKLIC:	HRROI	T,LICTAB	;Get lic word
	GETTAB	T,
	  MOVEI	T,0		;As if had no lic
	SETCA	T,T
ife debug,<
 	TLNN	T,LICSY+LICST+LICJL+LICRA+LICWA	;Does process have required
>						; lic?
ifn debug,<
	TLNN	T,LICSY+LICST+LICJL+LICRA	;[37] no WA if debug mode 
>
	POPJ	P,		;Yes
NOJAL:	MOVEI	M,[ASCIZ /
SY, ST, JL, RA, AND WA LICENSE REQUIRED.  NOTIFY SQC.
/]
	
FATERR:	CLOSE LPT,
	PUSHJ P,TRMMES
	JRST QUIT0

interr:	movei	m,[asciz \
CAN'T ACTIVAT SOFTWARE INTERRUPT SYSTEM.  ABORTING...\]
	jrst	faterr		;[37] 

pioerr:	movei	m,[asciz \
FATAL HARDWARE DISK ERROR DETECTED!\]
	jrst	faterr		;[37] un-recoverable hard device or data errors

nocor1:	movei 	m,[asciz \
INSUFFICIENT CORE AVAILABLE - T .GE. HIADDR IN GETCOR.\]
	jrst	faterr		;[37] temporarily add slightly different 
				;[37] error message if because hiaddr too low

NOCOR:	MOVEI M,[ASCIZ /
INSUFFICIENT CORE AVAILABLE/]
	JRST FATERR

PVYERR:	MOVEI	M,[ASCIZ/
DSKCLN USER CORE LIMIT SET TOO LOW/]
	JRST	FATERR

OPNERR:	MOVEI M,[ASCIZ /
CAN NOT OPEN AN OUTPUT FILE/]
	JRST FATERR

NODSER:	MOVEI	M,[ASCIZ/
DSKCLN UUO FAILED.
NOTIFY OPERATING SYSTEMS/]
	JRST	FATERR

FALLPT:	MOVEI M,[ASCIZ /
CAN NOT OPEN LIST OUTPUT. LPT NOT AVAILABLE?/]
	JRST FATERR

HOMNUM:	MOVEI M,[ASCIZ /
WRONG NUMBER OF HOME BLOCKS READ
NOTIFY OPERATING SYSTEMS/]
	JRST FATERR

BADHOM:	MOVEI M,[ASCIZ /
BAD HOME BLOCK ON UNIT /]
	PUSHJ P,TRMMES
	MOVE P1,[POINT 7,TRMBLK]
	MOVE N,U
	MOVEI P4,TRMSAV
	MOVEM P4,TYODSP#
	PUSHJ P,DECPRT
	MOVEI T,0
	IDPB T,P1
	MOVEI M,TRMBLK
	PUSHJ P,TRMMES
	MOVEI M,[ASCIZ /
NOTIFY OPERATING SYSTEMS/]
	JRST FATERR

DETMSG:	HRLI M,SUUMSG
	SETUUO M,	;SEND MSG TO OPR
	 OUTSTR @M	;OUTSTR IF IT FAILS
	POPJ P,

;THIS ROUTINE IS USED TO OUTPUT CHRS TO A BYTE POINTER IN P1

TYOBTH:	SKIPE P4	;POSSIBLE TO BOTH FILE AND TERMINAL
	PUSHJ P,TYO	;SEND TO FILE
TRMSAV:	IDPB CH,P1
	POPJ P,

FRDER:	MOVEI M,[ASCIZ /
FATAL READ ERROR WHILE FIXING DISK/]
	JRST FATERR

NOCLR:	MOVEI M,[ASCIZ /
CAN NOT CLEAR DISK INFORMATION
CRASH SYSTEM, BRING IT BACK UP, RUN DSKCLN AGAIN.
IF PROBLEM PERSISTS, CALL SYSTEMS
REMEMBER TO SAVE THE CRASH.
/]
	JRST FATERR

COMMENT #
@@SUBROUTINE GETCOR
@@PURPOSE
SUBR TO SEE IF WE NEED CORE, AND THEN TO GET CORE, IF
NECESSARY.
@@ENTRY
EXPECTS T/ HIGHEST DESIRED ADDRESSABLE LOCATION.
@@ACCUM
DESTROYS T.
@@EXIT
NON-SKIP RETURNS IF OKAY, NEVER RETURNS IF NOT OKAY.
ON SUCCESS, HAS SET UPRBND TO NEW VALUE.
@@ #

GETCOR:	CAMG	T,UPRBND	;NEED MORE CORE?
	POPJ	P,		;NO.
	IORI	T,1777		;GO BY K.
	caml	t,hiaddr	;[37] too high?
	 jrst	nocor1		;[37] yes, complain and die
	MOVEM	T,UPRBND	;no, stash it
	CORE	T,		;OLD STYLE GET CORE.
	JRST	NOCOR		;
	POPJ	P,

;CHECK FOR OPER LICENSE

CHKOPR:	HRROI	T,LICTAB	;GET LICENSE WORD
	GETTAB	T,
	  MOVEI	T,0		;AS IF HAD NO LICENSE
IFE DEBUG,<
	TRNE	T,LICOPR	;DOES JOB, NOT PROCESS, HAVE OP?
	JRST	(P)		;YES, OK.
	MOVEI	M,[ASCIZ/
OP LICENSE REQUIRED/]
	PUSHJ	P,TRMMES
	EXIT
>

IFN DEBUG,<
	TRNN	T,3		;MAKE SURE HE ISN'T DANGEROUS
	JRST	(P)		;OK.
	OUTSTR	[ASCIZ/
MUST NOT HAVE WP,WF, OR WA IN DEBUG OR MAKE MODE/]
	EXIT
>

QUIT0:	MOVEI M,NOUP
	PUSHJ P,TRMMES
	PUSHJ	P,IDEND	;PRINT TERMINATION MESSAGE
	EXIT		;ALWAYS EXIT IF FATEL ERROR
QUIT:	PUSHJ	P,IDEND	;PRINT TERMINATION MESSAGE
	SKIPN DETSW	;SPECIAL IF AUTO-RESTART
	EXIT
	HLRZ T,JOBSA	;KEEP LOWSEG BELOW 256K
	CORE T,		;SO LOGOUT WILL RUN UNDER P032.
	JFCL			; SHOUDLD NEVER FAIL
	MOVSI T,SUUINI
	SETUUO T,	;START REST OF AUTO-RELOAD GOING
	 JFCL
	MOVE T,[LOGITM,,LOGTAB]
	GETTAB T,
	 MOVE T,[SIXBIT /LOGOUT/]
	MOVEM T,FILNAM+1
	SETZM FILNAM+2
	MOVE T,[FILNAM+2,,FILNAM+3]
	BLT T,FILNAM+5
	MOVSI T,'SYS'
	MOVEM T,FILNAM
	MOVEI T,FILNAM
	HRLI T,1	;NOW LOGOUT
	RUN T,
	HALT .		;IN CASE OF ERROR

NOUP:	ASCIZ /
DO NOT ATTEMPT TO BRING SYSTEM UP FOR USERS/

SRBERR:	MOVEI M,[ASCIZ /
ERROR IN SAT.SYS RIB/]
	JRST FATERR

SBKERR:	MOVEI M,[ASCIZ /
ERROR READING A SAT BLOCK/]
	JRST FATERR

ERLSET:	PUSH P,T
	MOVE T,-1(P)
	LDB T,[POINT 4,-1(T),12]
	MOVEM T,THSERR#
	CAMLE T,ERRSAV
	MOVEM T,ERRSAV
	POP P,T
	POPJ P,

;SUBROUTINE TO PRINT ERROR MESSAGES CONCERNING PARTICULAR PAGES IN THE FORMAT:
;     FILE  FILE.EXT  [PRJ,PRG] CLSTR # (= BLK #)  RANDOM ERROR MESSAGE
; THE ARGUMENTS TO THE SUBROUTINE ARE:
;     ACC N CONTAINS THE CLUSTER NUMBER (IF NEGATIVE CLSTR # WILL NOT BE PRINTED)
;     LH OF ACC T HAS ADR OF RANDOM ASCIZ ERROR MESSAGE (CAN BE 0 IF NONE DESIRED)
;     RH OF ACC T HAS ADR OF 4-WORD LOOKUP BLOCK CONTAINING THE SIXBIT
;      FILENAME AND EXTENSION AND PRJ,PRG IN THE STANDARD PLACES

PRTRBL:	PUSH P,N
	PUSH P,T
	MOVE T1,THSERR
	CAMGE T1,MINERR
	JRST NOPRTR
	SETOM TRBFIL
	MOVEI M,[ASCIZ /FILE  /]
	PUSHJ P,MSG
	HLRZ T1,1(T)
	CAIN T1,'UFD'
	JRST PRTRBU
PRTBU1:	MOVE T,0(T)		;GET FILE NAME
	PUSHJ P,PR6BIT
PRTRB2:	MOVE T,0(P)
	HLLZ T,1(T)		;GET EXTENSION
	SKIPE T
	PUSHJ P,PDOT		;PRINT DOT ONLY IF NON-NULL EXT
	PUSHJ P,PR6BIT
	PUSHJ P,SPC
	MOVE T,0(P)
	SKIPN 2(T)
	JRST PRTRB3
	MOVEI CH,"["
	PUSHJ P,@TYODSP
	HLRZ N,2(T)		;PRJ
	PUSHJ P,OCTPRT
	PUSHJ P,COMMA
	HRRZ N,2(T)		;PRG
	PUSHJ P,OCTPRT
	MOVEI CH,"]"
	PUSHJ P,@TYODSP
	PUSHJ P,SPC
PRTRB3:	SKIPGE N,-1(P)
	JRST PRTRB4
	MOVEI M,[ASCIZ /PAGE /]
	PUSHJ P,MSG
	LDB N,[POINT PTSPNO,N,PTNPNO]
	PUSHJ P,OCTPRT
	MOVEI M,[ASCIZ / UNIT /]
	PUSHJ P,MSG
	LDB N,[POINT PTSUNI,-1(P),PTNUNI]
	PUSHJ P,OCTPRT
PRTRB4:	PUSHJ P,SPC
	PUSHJ P,SPC
	HLRZ M,0(P)
	SKIPE M
	PUSHJ P,MSG
	PUSHJ P,CRLF
NOPRTR:	POP P,T
	POP P,N
	POPJ P,

PRTRBU:	SKIPE N,2(T)
	CAMN N,[1,,1]
	SKIPA		;REALLY A UFD
	JRST PRTBU1
	HLRZ N,0(T)
	PUSHJ P,OCTPRT
	PUSHJ P,COMMA
	HRRZ N,0(T)
	PUSHJ P,OCTPRT
	JRST PRTRB2

MINERR:	0

;ROUTINES TO PRINT RIGHT-JUSTIFIED INTEGERS
; FIELD WIDTH IN ACC T
; NUMBER IN ACC N

DECSPC:	SKIPA CH,[40]		;DECIMAL WITH LEADING SPACES
DECZRO:	MOVEI CH,"0"		;DECIMAL WITH LEADING ZEROES
	MOVEI N1,^D10
	JRST RJRDXP
OCTSPC:	SKIPA CH,[40]		;OCTAL WITH LEADING SPACES
OCTZRO:	MOVEI CH,"0"		;OCTAL WITH LEADING ZEROES
	MOVEI N1,^D8
RJRDXP:	MOVEM N1,RADIX#
JUSTFY:	SOJLE T,RDXPRT		;RIGHT JUSTIFY
	CAMGE N,N1
	PUSHJ P,@TYODSP
	IMUL N1,RADIX
	JRST JUSTFY

DECPRT:	SKIPA N1,[^D10]
OCTPRT:	MOVEI N1,^D8
	MOVEM N1,RADIX
RDXPRT:	IDIV N,RADIX		;ANY RADIX PRINT ROUTINE
	HRLM N1,0(P)
	SKIPE N
	PUSHJ P,RDXPRT
	HLRZ CH,0(P)
	ADDI CH,"0"
	JRST @TYODSP

;subr to print octal number in ac N on the cty.
;make a string in chrbuf and return thru trmmsg
octcty:	movei t,^d12		;[40] set to loop
	move ch,[point 7,chrbuf] ;[40] point to string area
	move n1,n		;[40] put it in the right guy
octcy1:	setz n,			;[40] clean one out
	lshc n,3		;[40] one octal digit into N
	addi n,"0"		;[40] make it ascii
	idpb n,ch		;[40] stash it
	sojg t,octcy1		;[40] do 'em all
	movei m,chrbuf		;[40] point to string
	setz n,			;[40] tack on a null
	idpb n,ch		;[40] to make asciz
	jrst trmmes		;[40] and print it out

;SUBROUTINE TO IDENTIFY THIS RUN

IDENT:	PUSHJ	P,CRLF2
	MOVSI T,-6		;GET SYSTEM NAME
NAMLP:	HRL M,T
	HRRI M,CNFTAB
	GETTAB M,
	 MOVEI M,0
	MOVEM M,CNFNAM(T)
	AOBJN T,NAMLP
	MOVEI M,CNFNAM	;NOW PRINT IT
	PUSHJ P,MSG
	PUSHJ P,CRLF
	MOVE	T,STRNAM
	PUSHJ	P,PR6BIT
	MOVEI	M,[ASCIZ /.  MODE: /]
	PUSHJ	P,MSG
	MOVE	T,DCN
	MOVE	T,DCNNAM(T)
	PUSHJ	P,PR6BIT
	MOVEI	M,[ASCIZ /.     ANALYSIS BEGUN AT /]
	PUSHJ	P,MSG
	PUSHJ	P,NOW
	PJRST	CRLF2

;SUBROUTINE TO PRINT TERMINATION MESSAGE

IDEND:	MOVEI	M,[ASCIZ /

DSKCLN DONE AT /]
	PUSHJ	P,TRMMES
	MOVE	P1,[POINT 7,TRMBLK]
	MOVEI	T,TRMSAV
	MOVEM	T,TYODSP
	PUSHJ	P,NOW
	PUSHJ	P,CRLF2
	PUSHJ	P,NULL
	MOVEI	M,TRMBLK
	PJRST	TRMMES

;THESE ARE PRINT-OUT ROUTINES LIFTED FROM DSKLST AND OCCASIONALLY
; SLIGHTLY MODIFIED  (AC USAGE, ETC.)

MSG:	HRLI M,440700		;PRINT RANDOM LENGTH (ASCIZ) MESSAGE
MSGL:	ILDB CH,M		;  ADDRESS OF MESSAGE IS IN ACC M
	JUMPE CH,CPOPJ
	PUSHJ P,@TYODSP
	JRST MSGL

SPC:	MOVEI CH,40		;PRINT OUT PARTICULAR CHARACTERS...
	JRST @TYODSP
FORM:	MOVEI	CH,14
	JRST	@TYODSP
COMMA:	MOVEI CH,","
	JRST @TYODSP
PDOT:	MOVEI CH,"."
	JRST @TYODSP
NULL:	MOVEI	CH,0
	JRST	@TYODSP
TAB:	MOVEI CH,11

CRLF3:	PUSHJ P,CRLF
CRLF2:	PUSHJ P,CRLF
CRLF:	JSP M,MSG
	ASCIZ /
/


TYO:	SOSG LOBUF+2
	OUTPUT LPT,0
	IDPB CH,LOBUF+1
	POPJ P,

PR6BIT:	MOVEI M,0
	LSHC M,6	;FROM T
	MOVE CH,M
	ADDI CH," "
	PUSHJ P,@TYODSP
	JUMPN T,PR6BIT
	POPJ P,

TRMOPR:	PUSH P,CH
	MOVE CH,[POINT 7,TRMBLK]
	MOVEM CH,TRMPTR#
	MOVEI CH,TRMOP2
	MOVEM CH,TYODSP
	POP P,CH
TRMOP2:	IDPB CH,TRMPTR
	CAIE CH,12
	POPJ P,
	PUSH P,M
	MOVSI M,TRMOPR
	MOVSM M,TYODSP
	IDPB M,TRMPTR	;SWAPPED GIVES US A ZERO TO IDPB
	MOVEI M,TRMBLK
	PUSHJ P,TRMMES
	POP P,M
	POPJ P,

NOW:	MOVE T1,[DATITM,,DATTAB]
	GETTAB T1,
	SETO	T1,
	JUMPL T1,NODAT		;DATE NOT YET SET
	MOVE T2,[TIMITM,,TIMTAB]
	GETTAB T2,
	 MOVEI T2,0
	MOVE T3,[400020,,20]	;CONVERT TO DEC FMT GMT
	MOVEI T4,T1
	DATUUO T4,
	 MOVEI T4,0	;FLAG IF NO DATUUO (TIME NOT GMT)
	PUSH P,T4	;SAVE FLAG
	PUSH P,T1	;AND DATE
	MOVE T1,T2	;GET TIME
	IDIVI T1,^D3600
	MOVE T3,T2
	IDIVI T3,^D60		;SECONDS IN T3
	IDIVI T1,^D60		;HOURS IN T1, MINUTES IN T2
	HRREI T4,-2
	SKIPA CH,[40]
NOWLUP:	MOVEI CH,":"
	PUSHJ P,@TYODSP
	MOVEI T,2
	MOVE N,T3(T4)
	PUSHJ P,DECZRO
	AOJLE T4,NOWLUP
	PUSHJ P,SPC
	PUSHJ P,SPC
	POP P,T1		;RESTORE DATE

PRDATE:	IDIVI T1,^D31
	MOVEI N,1(T2)
	MOVEI T,2
	PUSHJ P,DECZRO
	IDIVI T1,^D12
	MOVE M,MONTAB(T2)
	MOVEI T3,0
	PUSHJ P,MSG
	MOVEI N,^D1964(T1)
	PUSHJ P,DECPRT
	POP P,T1		;GMT FLAG
	SKIPN T1
	POPJ P,		;NOT GMT
	JSP M,MSG
	ASCIZ / GMT/

NODAT:	JSP M,MSG
	ASCIZ / DATE NOT RECEIVED/


DEFINE MONMAC(A)<IRP A,<[ASCIZ /-A-/]>>
MONTAB: 
MONMAC<JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC>

; Here on a critical error.  Build a call to PRTRBL (print file and
;  error message), then die.
;
; Entered with M pointing to ASCIZ string indicating cause of death.


CRTERM:	MOVEI	T,0			;ERROR IN MFD
CRTERR:	MOVEI	P3,[ASCIZ /CRITICAL FILE DAMAGED/]
	JRST	CRTER1

UFDERR:	MOVEI	M,[ASCIZ /BAD FILE SPEC IN UFD POINTING TO CRITICAL FILE/]
	JRST	CRTER1

MISCRT: MOVEI	M,[ASCIZ /CRITICAL FILE MISSING/]
	MOVEI	P3,[0]

CRTER1:	MOVEI	P4,FILRIB
	MOVE	T1,SYSNAM(T)
	MOVEM	T1,ERRNAM(P4)
	MOVE	T1,SYSEXT(T)
	MOVEM	T1,ERREXT(P4)
	MOVE	T1,SYSPPN(T)
	MOVEM	T1,ERRPPN(P4)
	HRLZ	T,M			;POINTER TO CAUSE OF DEATH STRING
	MOVE	P1,[POINT 7,TRMBLK]
	MOVEI	T1,TRMSAV		;DAMAGE TO CRITICAL FILE
	MOVEM	T1,TYODSP
	SETO	N,
	HRRI	T,ERRNAM(P4)
	PUSHJ	P,PRTRBL
	PUSHJ	P,CRLF
	MOVE	M,P3			;MISSING OR DAMAGED MESSAGE
	PUSHJ	P,MSG
	MOVEI	T,0
	IDPB	T,P1
	MOVEI	M,TRMBLK
	JRST	FATERR

;SUBROUTINES START HERE

;SUBROUTINE TO COMPUTE SIXBIT FOR LOGICAL UNIT WITHIN FILE STRUCTURE
;ARGS	STRNAM=SIXBIT NAME OF FILE STRUCTURE
;	U=LOGICAL UNIT IN STR
;VALUE	CHRBUF=SIXBIT LOGICAL UNIT IN STR

LNAME:	MOVE	T2,STRNAM
	MOVE	T3,[POINT 6,T2]
	ILDB	T4,T3
	JUMPN	T4,.-1		;FIND END OF STR NAME
	MOVEI	T4,T2
	CAIE	T4,(T3)
	JRST	STRLUX
	MOVE T,U
	IDIVI	T,10
	JUMPE	T,STRLU1
	TLNN T3,770000
	JRST STRLUX
	ADDI	T,20
	DPB	T,T3
	IBP	T3
STRLU1:	ADDI	T1,20
	DPB	T1,T3
STRLUX:	MOVEM	T2,CHRBUF
	POPJ	P,

;READ AND CHECK THE HOME BLOCKS. TRY FIRST BLOCK THEN SECOND
;IF FIRST IS BAD

HOMCHK:	MOVE P1,CHRBUF+.CHHA	;ADDRESS OF HOME PAGES.
	PUSHJ P,HOMCK1	;READ THEM AND CHECK
	 JRST CPOPJ1	;NON-SKIP RETURN SAYS GOOD
	MOVSS P1	;TRY THE NEXT ONE
	PUSHJ P,HOMCK1
CPOPJ1:	 AOS (P)	;GOOD, TAKE SKIP RETURN TO SAY GOOD
CPOPJ:	POPJ P,

HOMCK1:	HLRZ T1,P1	;GET BLOCK NUMBER TO READ
	PUSHJ P,PAGRED
	 JRST CPOPJ1	;BLOCK WAS BAD
	MOVSI T,'HOM'
	MOVEI T1,CODHOM
	CAMN T,BUF+HOMNAM
	CAME T1,BUF+HOMCOD
	JRST CPOPJ1	;ONE OF THOSE WAS BAD
	HLRZ T1,P1
	DPB U,[POINT PTSUNI,T1,PTNUNI]
	TLO T1,RBREAL	;AMKE IT A REAL POINTER
	CAME T1,BUF+HOMSLF
	JRST CPOPJ1	;SHOULD HAVE OWN BLOCK NUMBER
	PUSHJ P,LNAME	;GET NAME FOR THIS UNIT IN STR
	MOVE T,STRNAM
	MOVE T1,CHRBUF	;NAME OF THIS UNIT
	CAMN T,BUF+HOMSNM
	CAME T1,BUF+HOMLOG	;THESE SHOULD AGREE
	AOS (P)		;THEY DO NOT, SKIP RETURN
	POPJ P,		;ALL GOOD, OK RETURN

;GET SOME OF THE PER UNIT DATA FROM THE HOME BLOCK

HOMCOP:	MOVE T,BUF+HOMSPU	;SATS/UNIT
	HRLZM T,@PTRDST	;INTO DISK SAT POINTER TABLE
	MOVE T,BUF+HOMP4S
	MOVEM T,@PTRSWP	;SAVE SWAPING SPACE
	MOVE T,BUF+HOMSLP
	MOVEM T,@PTRSWB	;AND BLOCK TO CHECK SWAP.SYS
	POPJ P,

;SUBROUTINE TO READ A PAGE
;ARGS	T1=LOGICAL PAGE WITHIN UNIT TO READ
;	U=LOGICAL UNIT NUMBER
;	IOCW=IOWD
;ENTER AT BLKRD1 IF T1=LOGICAL PAGE WITHIN STR

PAGRDP:	LDB U,[POINT PTSUNI,T,PTNUNI]
	LDB T1,[POINT PTSPNO,T,PTNPNO]
	CAMG U,HIGHU
	CAML T1,@PTRPPU
	POPJ P,
PAGRED:	MOVE	T2,STRPPU	;PAGES PER UNIT IN STR
	IMUL	T2,U		;PAGE NUM OF 1ST PAGE ON UNIT
	ADD	T1,T2		;T1=LOGICAL PAGE WITHIN STR

	movem t1,lstbuf#	;[40] remember disk page now mapped to buf
	movei	t2,bufpag	;[37] blow this page away
	hrli	t2,1		;[37] but just this one
	vclear	t2,		;[37] goodbye
	 PUSHJ	P,PAGERR	;[37] oops...
	hrli	t2,(.prrw!1B17)	;[37] read/write when fixing
	skipn fixflg		;[40] doing fixup operation?
	 hrli	t2,(.prro!1B17)	;[40] no, mapping should be read-only
	movem	t2,mapwd	;[37] stash VP info
	camn	t1,@ptrunu	;[37] map/pre-ref in prog for this page?
	 jrst	xchptr		;[37] yes, go make BUF point there
	hrli	chan,.chsmp	;[37] set to super-map to BUFPAG
	movem	t1,mapwd+1	;[37] stash disk source page
	chanio	chan,mapwd	;[37] ask God for it
	 PUSHJ	P,PAGERR	;[37] we lost, puke
	jrst	tchbuf		;[37] we won, go touch it

;[37] here to replicate a page previously mapped and pre-referenced
xchptr:	push	p,t1		;[37] somebody somewhere may depend on this
	move	t1,@ptrupg	;[37] get the source addr
	skipn	@ptrpge		;[37] have we seen a harware i/o error?
	 jrst	pagok		;[37] no
	pop	p,t1
	jrst	prvbuf		;[37] go make private BUF

pagok:				;[37] here to copy page
	movem	t1,mapwd+1	;[37] stash
	movei	t2,mapwd	;[37] remember where
	vreplc	t2,		;[37] ask to replicate
	 PUSHJ	P,PAGERR		;[37] lost, go see why
	pop	p,t1		;[37] somebody may want this
tchbuf:	setzm	bfeflg		;[37] be sure error flag not set
	move	t2,buf		;[37] touch the page
	skipn	bfeflg		;[37] did it cause an error?
	 jrst	cpopj1		;[37] no, skip-return, all OK
	setzm	bfeflg		;[37] yes, reset flag
	movei	t,bufpag	;[37] blow it away
	hrli	t,1		;[37] only one
	vclear	t,		;[37] just to be sure
	 jfcl			;[37] ignore
prvbuf:	movei	t,bufpag	;[37] get it again in case of vclear error
	hrli	t,(.prrw!1b17)	;[37] make private page, cow only one
	vcreat	t,		;[37] thusly
	 PUSHJ	P,PAGERR		;[37] dumb programmer
	hrli	t,(ps.ner!1b17)	;[37] set to ignore page errors
	perset	t,		;[37] thusly
	 PUSHJ	P,PAGERR		;[37] dumb programmer
	popj	p,		;[37] and error return
	

pagerr:	movei m,[asciz \
PC = \]
	pushj p,trmmes
	pop p,n		;[40] get caller's PC
	pushj p,octcty
	movei	m,[asciz \
??Fatal Error Return from UUO detected!!
\]
	jrst	oldone		;[41] complain and try to run prev ver

;[37] interrupt handler for hardware page errors
;[37] if BUF caused the page error interrupt
;[37] 	then set flag saying BUF is bad and map a private page to BUF
;[37] 	else if a disk cache page caused the interrupt
;[37] 		then mark the page bad and map a private page there
;[37] 		else fatal paging error - probably sick hardware

errint:	push	p,u		;[37] save some ACs
	push	p,t2		;[37] 
	push	p,t1		;[37] 
	push	p,t		;[37] 
	movei	t,t1		;[37] where to stash 'em
	hrli	t,-2		;[37] want both page-error status wds
	pgests	t,		;[37] ask for 'em
	 jfcl			;[37] ignore errors
	hrrz	t,t1		;[37] offending virtual page number
	cain	t,bufpag	;[37] is it BUF?
	 jrst	errit1		;[37] 
	move	u,highu		;[37] set to index and loop
	camn	t,@ptrupg	;[37] is it from a pre-reference?
	 jrst	errit2		;[37] yes, handle
	sojge	u,.-2		;[37] check all units

	jrst	pioerr		;[37] offending page not from BUF or the
				;[37] disk cache - fatal error, probably
				;[37] sick hardware.

errit2:				;[37] here to handle error from pre-ref
	setom	@ptrpge		;[37] mark it bad
	skipa
errit1:	setom	bfeflg#		;[37] flag error inputting to BUF
	hrli	t,1		;[37] set to blow away a page
	vclear	t,		;[37] just to be sure it's gone
	 jfcl			;[37] ignore errors
	hrli	t,(.prrw!1b17)	;[37] make a private page there
	vcreat	t,		;[37] thusly
	 PUSHJ	P,PAGERR		;[37] dumb programmer
	pop	p,t		;[37] restore saved ACs
	pop	p,t1		;[37] 
	pop	p,t2		;[37] 
	pop	p,u		;[37] 
	dismis			;[37] and go back to whatever


;here to die with instructions to try old version of dskcln.
oldone:	movei m,[asciz \
%% Attempting to run previous version of DSKCLN...
%% Notify Operating Systems.
\]
	pushj p,trmmes
	movei t,[sixbit \SYS\
		 sixbit \DSKCLN\
		 sixbit \S36\
		 z
		 z
		 z]
	run t,
	 movei m,[asciz \

??Can't Run Old DSKCLN. Call Tymcom-X Software Support.

\]
	jrst faterr

;[37] PAGWRT - routine to force bufpag out to disk, assuming it is 
;[37] 	       already super-mapped read-write.  check to be sure
;[40] 	       that the page wanted to be written is the same one that
;[40] 	       was last mapped by pagred, otherwise things are really
;[40] 	       screwed. (the great leap of faith that every program must have)
;[37] 
;[37] entry pagwrt: enter with U/unit number  
;[37] 			       T1/ logical page on unit in U
;[37] entry pagwtp: enter with T/RIB pointer to disk page
;[37] 
;[37] returns +1 success
;[37] never returns if error - complains and dies thruogh FATERR
;[37] destroys T2 always - destroys T1 and U from pagwtp entry
;[37] 
;[40] VALPAG contents of BUF, after checking consistency with last 
;[40] pagred.  desired disk page should have been mapped by PAGRED
;[40] with read/write protection.  if we are trying to write a disk
;[40] page that is other than what was last mapped by PAGRED, then 
;[40] things are really screwed up because we just scribbled on the
;[40] wrong disk page!  when VALPAGing, wait to be sure there are no I/O
;[40] errors.  If the page is the correct one, and there are no I/O
;[40] errors, non-skip return.  If God is not on our side, and anything
;[40] smells bad, complain and die.

ife debug,<
PAGWTP:	LDB	U,[POINT PTSUNI,T,PTNUNI]
	LDB	T1,[POINT PTSPNO,T,PTNPNO]
	CAMG	U,HIGHU
	CAML	T1,@PTRPPU
	POPJ	P,
PAGWRT:
	MOVE	T2,STRPPU	; make it be logical page in structure
	IMUL	T2,U
	ADD 	T1,T2

	came t1,lstbuf		;[40] want to write to same page as now mapped?
	 jrst wrtfat		;[40] sad if no
	move t2,[vl.wat!cnt1!bufpag]	;[40] set to validate this page only
	valpag	t2,		;[37] ask for it, waiting for dirty pgs
	 jrst	wrterr		;[37] check for i/o error
	popj	p,		;[37] all OK, normal return

wrtfat:	movei m,[asciz \
??Fatal Error...  Aborting.
Entered PAGWRT With Output Page Not Equal To Disk Page Last Mapped!!
Contact Operating Systems.
\]
	pushj p,trmmes		;[40] complain about it
	jrst oldone		;[40] and tell 'em to run the old one.

wrterr:	hrrz	t,t2		;[37] error code
	caie	t,vlioe%	;[37] i/o error occurred?
	 jrst  [movei m,[asciz \VALPAG ERROR CODE = \]
		pushj p,trmmes
		move n,t
		pushj p,octcty
		PUSHJ	P,PAGERR]	;[37] no, something strange

;[37] here on an output error - complain and die through FATERR
;[37] alternate entry PG%.ER to complain and die with t1/offending page number
 	MOVEI	M,[ASCIZ /PAGE WRITE ERROR, UNIT # /]
 	PUSHJ	P,MSG
 	MOVE	N,U
	PUSHJ	P,OCTPRT
pg%.er:	MOVEI	M,[ASCIZ/, PAGE # /]
	PUSHJ	P,MSG
;[40] 	MOVE	N,T1
	hrrz n,t1		;[40] want page num only, not paging flags
	PUSHJ	P,OCTPRT
	MOVE	M,[ASCIZ/ (WITHIN STR)/]
	JRST	FATERR
>; end ife debug

ifn debug,<
pagwtp:
pagwrt:	popj	p,
>;[37] end ifn debug - if debugging, don't ever try to write
;READ AND CHECK A RIB
;ARGS	T=STR BLOCK NUMBER OF FIRST RIB
;	SKIP RETURN IF OK

RIBCHK:	TLNE T,RBREAL
	PUSHJ P,PAGRDP
	 JRST [MOVEI M,[ASCIZ/READ ERROR FOR RIB/]
		POPJ P,]
	MOVEI T1,CODRIB
	CAMN T,BUF+RIBSLF
	 CAME T1,BUF+RIBCOD	;SIMPLE ERROR CHECKS
	  JRST [MOVEI M,[ASCIZ/BAD RIBCOD/]
		POPJ P,]
	JRST CPOPJ1	;ALL OK

;DO A COMPLETE CHECK OF A RIB. BLOCK NUMBER IN T (

FULRBC:	MOVEI M,[ASCIZ/BAD DATA IN RIB/]	; SETUP DEFAULT ERROR TEXT
	PUSHJ P,RIBCHK	;READ AND MAKE PRELIMINARY CHECKS
	 POPJ P,		;BAD
	MOVE T,ERRNAM(P4)
	MOVE T1,ERRPPN(P4)
	CAMN T,BUF+RIBNAM
	CAME T1,BUF+RIBPPN	;CHECK ANME, EXT AND PPN
	POPJ P,
	HLLZ T,ERREXT(P4)
	HLLZ T1,BUF+RIBEXT
	SKIPN BUF+RIBRIB
	CAME T,T1
	POPJ P,
	SETZM SIZRIB(P4)
	SETZM ALCRIB(P4)
	AOS ALCRIB(P4)
	PUSHJ P,COPTR	;SAVE RIB BLOCK AND SET FULBLK
	PUSHJ P,SETPTR	;SET UP POINTERS TO RET INFO
	AOS (P)	;DOES, OK
	POPJ P,

;SUBROUTINE TO COPY POINTERS INTO SAVE RIB SLOT
;ARG	P4=ARD OF CORE BLOCK

COPTR:	MOVEI T,SAVRIB(P4)
	HRLI T,BUF
	BLT T,SAVRIB+777(P4)
	POPJ P,

;SUBROUTINE TO SET UP DEVRSU ETC. TO POINT TO STARTING POINT
;OF RIB POINTERS SAVED
;ARG	P4=CORE BLOCK

SETPTR:	MOVE T,[-RBLVPR,,RIBPFS]
	SKIPE SAVRIB+RIBRIB(P4)
	MOVE T,[-RBLVSR,,RIBSFS]
	ADDI T,SAVRIB(P4)
	MOVEM T,DEVRSU(P4)
	SETOM DEVREL(P4)
	POPJ P,

;SUBROUTINE TO RETURN NEXT POINTER FROM THE RIB
;ARG P4=ADDRESS OF CORE BLOCK
;FAIL RETURN IS TAKEN ONLY IF THE UNIT AND PAGE VALUES IN AN
;OBTAINED PNTR ARE TOO LARGE.
;ALL OTHERS(HOLES, SPARES, REAL IN BOUNDS) TAKE THE SUCCESS
;RETURN, INCLUDING T/0 ON OUT OF PNTRS.

GETBLK:	AOS DEVREL(P4)
	SKIPL	T1,DEVRSU(P4)	;GET T1/ AOBJN PNTR TO RET PNTR.
	JRST	NOPTR
	MOVE	T,(T1)		;GET T/ POSSIBLE RET PNTR.
	AOBJN	T1,.+1		;INCREMENT THE AOBJN
	MOVEM	T1,DEVRSU(P4)	;PNTR IN DEVRSU.
	JUMPE T1,NOPTR
	MOVEM T,NXTPTR(P4)
	TLNN T,RBREAL
	JRST CPOPJ1
	LDB U,[POINT PTSUNI,T,PTNUNI]
	CAMLE U,HIGHU
	POPJ P,
	LDB T1,[POINT PTSPNO,T,PTNPNO]
	CAMGE T1,@PTRPPU
	AOS (P)
	POPJ P,

NOPTR:	MOVEI T,0
	JRST CPOPJ1

;CODE TO MARK BITS IN SAT BLOCKS
;RIB PTR IN T1, POINTER TO SAT TABLE IN T

;TEST BIT, SKIP RETURN IF BIT IS OFF

TSTZRO:	LDB U,[POINT PTSUNI,T1,PTNUNI]
	LDB T1,[POINT PTSPNO,T1,PTNPNO]
	IDIVI T1,^D36
	ADD T1,@T	;NOW HAVE WORD ADDRESS
	MOVE T,T1	;AND BIT NUMBER IN T2
	MOVNS T2
	MOVSI T1,(1B0)
	LSH T1,(T2)	;NOW HAVE BIT POSITIONED
	TDNN T1,(T)	;TEST BIT
	AOS (P)
	POPJ P,

;SET BIT 0, SKIP IF BIT WAS A 1

MRKZRO:	PUSHJ P,TSTZRO
	 AOS (P)		;BIT WAS A 1, SKIP RETURN
	ANDCAM T1,(T)	;MAKE SURE BIT IS OFF
	POPJ P,

;SET BIT 1, SKIP IF BIT WAS A 0

MRKONE:	PUSHJ P,TSTZRO
	 SKIPA
	AOS (P)	;BIT WAS A 0
	IORM T1,(T)	;MARK IT A 1
	POPJ P,

;CHECK BAT BLOCKS

CHKBAT:	MOVE U,HIGHU
BATUNI:	MOVE P1,CHRBUF+.CHBA
	PUSHJ P,CKBAT1
	 JRST DOBAT	;THIS BAT BLOCK IS OK
	MOVSS P1	;TRY OTHER ONE
	PUSHJ P,CKBAT1
	 JRST DOBAT	;OK, USE IT
	JRST BATUDN	;BOTH BAD, JUST IGNORE
DOBAT:	MOVEI P1,BUF
	ADD P1,BATFIR(P1)
BATUN1:	SKIPN (P1)	;ZERO AT END OF LIST
	JRST BATUDN	;DONE WITH THIS UNIT
	LDB P2,BAYNBB	;NUMBER BAD (-1) IN THIS REGION
NXTBBK:	MOVE T1,BATELB(P1)
	ADDI T1,(P2)
	CAML T1,@PTRPPU
	JRST BATBK2		;IGNORE BLOCKS TOO HIGH
	DPB U,[POINT PTSUNI,T1,PTNUNI]
	PUSH P,T1
	MOVE T,PTROST
	PUSHJ P,MRKZRO	;MARK IN OUT SAT
	 JRST BATBKD	;WAS MARKED, DO NOT MARK IN DSK SAT IN CASE FREE
	MOVE T1,(P)	;BECAUSE THAT WOULD CAUSE LOST PAGES MSG.
	MOVE T,PTRDST	;IN DISK SAT
	PUSHJ P,MRKZRO
	 JFCL
BATBKD:	POP P,T1
BATBK2:	SOJGE P2,NXTBBK	;DO IT FOR ALL IN THIS REGION
	AOBJP P1,BATUDN	;DONE WHEN RUN OUT OF ROOM
	AOBJN P1,BATUN1	;DO MORE IF MORE THERE (2 WORDS/ENTRY)
BATUDN:	SOJGE U,BATUNI	;TRY NEXT UNIT
	POPJ P,

BAYNBB:	POINT BASNBB,BATNBB(P1),BANNBB	;HERE IS WHERE NUMBER OF BAD BLOCKS IN REGION LIVES

CKBAT1:	HLRZ T1,P1
	PUSHJ P,PAGRED
	 JRST CPOPJ1
	MOVSI T,'BAT'
	MOVEI T1,CODBAT
	CAMN T,BUF+BATNAM	;CHECK CONSISTANCY
	CAME T1,BUF+BATCOD
	JRST CPOPJ1	;NO GOOD
	HLRZ T1,P1
	DPB U,[POINT PTSUNI,T1,PTNUNI]
	TLO T1,RBREAL	;TURN IT INTO A POINTER
	CAME T1,BUF+BATSLF
	AOS (P)
	POPJ P,

;HERE TO GO THROUGH ALL THE CLUSTER IN ORDER IN THE SAT TABLES
;P4 CONTAINS A POINTER TO A DRIVER TABLE
;	(P4) POINTER TO FIRST SAT TABLE (@ BIT ON)
;	1(P4) POINTER TO SECOND SAT TABLE
;	2(P4) NO CLUSTER BAD MESSAGE
;	3(P4) HEADER IF SOME BAD
;	4(P4) TOTAL BAD MESSAGE
;	5(P4) PUSHJ HERE IF ANY BAD
;	7(P4) PUSHJ HERE TO SEE IF BAD RETURNS CPOPJ1 IF IS

CLSSRC:	SETOM COUNT#
	MOVEI U,0
SRNWUN:	MOVE P3,@PTRPPU	;GET NUMBER OF BLOCKS
	MOVE T,U
	IMUL T,STRPPU
	SOS P2,T	;P2 WILL BE CLUSTER NUMBER (AOS'ED BEFORE CHECK)
	HRRZ T3,@(P4)	;FIRST SAT POINTER
	HRRZ T4,@1(P4)	;SECOND SAT POINTER
	SUBI T3,1
	SUBI T4,1	;DECRIMENT SINCE AOS BEFORE USE
SRNWST:	MOVEI T1,1	;START OF SAT, T1 HAS BIT TO TEST
	MOVEI T2,400*^D36
SRNXCL:	ADDI P2,1	;NEXT CLUSTER
	SOJL P3,SRNXUN	;SEE IF OUT OF PAGES ON THIS UNIT
	SOJL T2,SRNXST	;OR POSSIBLY IN THIS SAT
	ROT T1,-1	;MOVE BIT
	JUMPGE T1,SRTST	;IF HIGH ORDER BIT, MUST WANT NEXT WORD
	ADDI T3,1
	ADDI T4,1
SRTST:	PUSHJ P,7(P4)	;TEST
	 JRST SRNXCL	;ALL OK
	MOVE M,3(P4)	;GET READY TO PUT OUT HEADER
	AOSG COUNT
	PUSHJ P,MSG	;FIRST BAD ONE
	MOVE N,P2
	MOVEI T,6
	PUSHJ P,OCTZRO	;PRINT 6 DIGITS WITH LEADING ZEROS
	PUSHJ P,SPC
	PUSHJ P,SPC
	MOVE N,COUNT
	ADDI N,1
	IDIVI N,^D15
	JUMPN N1,SRNXCL	;SEE IF ENOUGH ON THIS LINE
	PUSHJ P,CRLF	;YES
	JRST SRNXCL

SRNXST:	ADDI P3,1
	SOJA P2,SRNWST	;COMPENSATE FOR EXTRA INCS
SRNXUN:	CAMGE U,HIGHU
	AOJA U,SRNWUN	;GO WITH NEXT UNIT
	MOVE M,2(P4)	;GET READY WITH NO ERRORS MESSAGE
	AOSG N,COUNT
	JRST MSG	;THERE WERE NONE
	PUSHJ P,5(P4)	;MARK ERRORS
	MOVE M,4(P4)	;TOTAL ERRORS MESSAGE
	PUSHJ P,MSG
	PUSHJ P,DECPRT
	PUSHJ P,PDOT
	JRST CRLF3	;DONE

;TEST TO SEE IF FILE IS A UFD

ISUFD:	HLRZ T,ERREXT(P4)
	MOVE T1,ERRPPN(P4)
	CAIN T,'UFD'
	CAME T1,[1,,1]
	POPJ P,		;NOT UFD, NON-SKIP RETURN
	JRST CPOPJ1	;IS A UFD
;TEST TO SEE IF CRITICAL FILE DAMAGED

ISCRIT:	MOVSI	T,-SPCLEN
	MOVE	T1,ERRNAM(P4)
	CAME	T1,SYSNAM(T)	;CHECK NAME TABLE
CRIT1:	 AOBJN	T,.-1
	JUMPGE	T,CPOPJ		;NOT ON CRITICAL LIST.
	MOVE	T2,ERRPPN(P4)
	CAME	T2,SYSPPN(T)
	 JRST	CRIT1		;NO MATCH
	HLLZ	T2,ERREXT(P4)
	CAME	T2,SYSEXT(T)
	 JRST	CRIT1
	SKIPE	FIXFLG		;DON'T DIE IF CHECKING MODE
	 JRST	CRTERR
	OUTSTR	[asciz "
CRITICAL FILE FOUND DAMAGED IN CHECKING MODE: (CONTINUING...)
"]
	POPJ P,
;CHECK SAT FOR EXTRA (UNUSED) BITS NOT MARKED. IF FIXING,
;MARK EXTRA BITS IN OUR SAT

CHKSAT:	MOVE U,HIGHU	;NOW CHECK FOR EXTRA SAT BITS
	MOVE P1,PTRDST
	SKIPE FIXFLG
	MOVE P1,PTROST	;FOR FIXING
CKBUNI:	MOVE T,@PTRPPU	;GET NUMBER OF PAGES
	IDIVI T,400*^D36	;NUMBER OF BITS/PAGE
	HLRZ T4,@PTRDST		;GET EXPECTED NUMBER
	JUMPE T1,[CAME T,T4	;EVEN NUMBE OF SATS
		JRST BADNST	;DOES NOT COMPARE
		JRST NXTST2]
	CAIE T4,1(T)	;DO NUMBERS MATCH
	JRST BADNST	;NO
	IMULI T,400	;WORDS IN FULL SATS
	ADD T,@P1	;LOCATION
	MOVE T4,T	;SAVE IT. FIRST WORD OF LAST SAT
	MOVE T,T1
	IDIVI T,^D36	;FULL WORD SIN LAST SAT
	ADD T4,T
	MOVEI T3,400
	SUB T3,T	;THE NUMBER OF WORDS NOT FULL
	SETO	T,
	MOVNS T1
	LSH T,(T1)	;T NOW HAS 1 BITS WHERE SAT SHOULD HAVE 0'S
	MOVEI N,0	;ERROR FLAG
	TDNE T,(T4)
	MOVEI N,1	;SET ERROR FLAG
	ANDCAM T,(T4)	;SET CORE BITS
CHKST2:	SOJLE T3,NXTSAT	;ARE WE DONE?
	SKIPE 1(T4)	;NO REST SHOULD BE ALL ZERO
	MOVEI N,1
	SETZM 1(T4)
	AOJA T4,CHKST2
NXTSAT:	SKIPN FIXFLG	;NO ERROR MESSAGE IF FIXING
	JUMPN N,BADSAT
NXTST2:	SOJGE U,CKBUNI
	POPJ P,		;FINISHED ALL SATS

BADSAT:	ERRLEV (LEVBAD)
	MOVEI M,[ASCIZ /EXTRA BITS IN SAT NOT MARKED UNIT /]
	PUSHJ P,MSG
	MOVE N,U
	PUSHJ P,DECPRT
	PUSHJ P,CRLF
	JRST NXTST2

BADNST:	MOVEI M,[ASCIZ /
WRONG NUMBER OF SATS/]
	JRST FATERR

;SET UP AN ERROR LIST POINTER. FIRST WORD POINTS TO CHAIN
;SECOND TO END OF CHAIN FOR ADDING AT END
;POINTER TO BLOCK IN T

SETFIX:	MOVEM T,1(T)
	SETZM (T)
	POPJ P,

;ADD SOMETHING TO END OF CHAIN
;ADD A 4 WORD BLOCK
;	WORD 0 LH. IS LINK. RH IS ADDRESS CALLED FROM
;		WILL GO TO ADDRESS CALLED FROM+1 TO FIX
;	WORD 1 IS BLOCK NUMBER
;	WORDS 2 AND 3 ARE ROUTINE DEPENDENT ARGS

ADDFIX:	PUSH P,T3
	MOVEI T3,4
	ADDB T3,FREPTR	;GET SPACE
	PUSH	P,T		;SAVE T
	MOVE	T,T3		;
	PUSHJ	P,GETCOR	;
	POP	P,T		;
	MOVE T3,FREPTR
	SUBI T3,4
	POP P,3(T3)
	MOVEM T2,2(T3)
	MOVEM T1,1(T3)	;BLOCK NUMBER
	HRRZ T1,(P)	;LINK IS ALWAYS 0
	MOVE T2,1(T)	;T POINTS TO CHAIN BLOCK
	MOVEM T1,(T3)	;SAVE ADDRESS
	HRLM T3,(T2)	;LINK ON END
	MOVEM T3,1(T)	;AND SET NEW END
	POPJ P,

ADDTOT:	SKIPN T1,(T)	;ANYTHING TO ADD?
	POPJ P,		;NO
	HLLM T1,@FIXPTR+1	;ADD TO END OF MASTER CHAIN
	MOVE T1,1(T)
	MOVEM T1,FIXPTR+1	;RESET END
	POPJ P,

RCVBUF:	BLOCK 406	;RESERVED SPACE FOR RECOV.SYS BUFFERS.

imradr:	block 3		;[37] stg for page fail words from PGFSTS UUO
intvec:	z		;[37] monitor will stash pc here on chan 1 interr
	errint		;[37] chan 1 interrupt handler
	block ^d68	;[37] no other SI channels used

UPRBND:	Z		;HAS ADDR OF HIGHEST ADDRESSABLE WORD
			;OF CORE.

	END STPT
(4