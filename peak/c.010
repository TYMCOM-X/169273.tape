EXT-guy-sun-uucp-8P4G2 20-Feb-86 Re: Wanted:Compaction Algorithm
   From: {Guy Harris <guy%sun.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-guy-sun-uucp-8P4G2 / <3261@sun.uucp>
   Posted: 20-Feb-86 11:59-PST  Received: 25-Mar-86 17:42-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 26 Feb 86 04:00:16 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a020666; 26 Feb 86 6:56 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a015398; 26 Feb 86 6:40 EST
   Newsgroups: net.lang.c,net.unix
   Xref: seismo net.lang.c:8107 net.unix:7533
   > I am in need of a packing algorithm which works better than the > PACK 
   Utility of UNIX.  I have also looked at COMPRESS ( developed > at 
   University of Utah ).  COMPRESS works great if distinct number > of input
   bytes is small.  But if the distinct input bytes reach > 256 ( binary 
   data ), PACK works better than COMPRESS.  With PACK > I am getting a 
   saving of 20-25%.  If anybody has an algorithm > that would do better in 
   packing "load modules", I would like to > know about it.
   Are you sure you have the latest version of "compress"?  I tried 
   "pack"ing and "compress"ing "/usr/bin/suntools" (which is a BMF 
   executable image) and "compress" did significantly better than "pack" did
   (it took significantly more time doing it, but that's life).  Remember, 
   Lempel-Ziv compression will discover frequently-occurring sequences of 
   bytes, and unless your machine has all one-byte instructions you're 
   likely to get some multi-byte sequences occurring frequently.
   --
      Guy Harris
      {ihnp4, decvax, seismo, decwrl, ...}!sun!guy
     guy@sun.arpa    (yes, really)
EXT-guy-sun-uucp-8P4GF 20-Feb-86 Re: Enums as Indices
   From: {Guy Harris <guy%sun.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-guy-sun-uucp-8P4GF / <3262@sun.uucp>
   Posted: 20-Feb-86 12:14-PST  Received: 25-Mar-86 17:42-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 26 Feb 86 04:05:47 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a020711; 26 Feb 86 6:57 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a015407; 26 Feb 86 6:41 EST
   Newsgroups: net.lang.c
   > Second, I feel that ENUM's are merely a way of writing #defines with a 
   > bit of type checking thrown in (thus the error). One of the things you 
   > can do with integers is use them for subscripts. I can imagine a > 
   statement like `wavelenth[RED] = however_many_angstroms_red_really_is'. 
   ... > An expression such as `wavelength['RED'] = ...' is currently legal 
   altho > not recommended (portability).
   Unfortunately, as pointed out such an expression is not legal according 
   to PCC, at least, although ANSI C indicates that "enum"s are really just 
   funny names for "int"s and presumably allows their use as subscripts.  
   (This means that the type checking may go away, although it'd be nice to 
   have it at least issue a warning on a type clash; consider the definition
      typedef enum { READ, WRITE } op_type;
      typedef enum { BYTES, CHARACTERS } io_mode;
      int funny_io(int, char *, int, op_type, io_mode);
   which could catch errors like
      ntransferred = funny_io(fd, buf, count, BYTES, READ);
   )  Conceptually, an array of type "x" using type "y" as a subscript is a 
   function from the set of members of type "x" to the members of type "y". 
   However, C doesn't permit you to specify "y" directly as a type, so you 
   can't do
      enum color { red, orange, yellow, green, blue, indigo, violet }; float
      wavelength[enum color];
   to indicate that the valid subscripts for "wavelength" are members of the
   enumeration type "enum color" and to tell it to allocate 7 elements for 
   the array.  Things would get even messier if you defined a sparse 
   enumeration; should it allocate array elements for all the missing 
   elements, or implement the array differently from a dense one?  
   Furthermore, to make arrays indexed by a subset of the integers work, 
   you'd have to add subrange types to C; this might be a nice thing to do, 
   but it drags in a lot of additional baggage.
   --
      Guy Harris
      {ihnp4, decvax, seismo, decwrl, ...}!sun!guy
     guy@sun.arpa    (yes, really)
EXT-bruce-graffiti-uucp-8P4YI 20-Feb-86 Who is the keeper of termcap these 
days?
   From: {Bruce Jilek <bruce%graffiti.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-bruce-graffiti-uucp-8P4YI / <113@graffiti.UUCP>
   Posted: 20-Feb-86 09:26-PST  Received: 25-Mar-86 17:42-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 26 Feb 86 09:31:21 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a001222; 26 Feb 86 11:59
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a024096; 26 Feb 86 11:34 EST
   Newsgroups: net.unix,net.lang.c
   Xref: seismo net.unix:7539 net.lang.c:8112
   Does anyone know who is maintaining the termcap database now?
   Mine is quite old and outdated.
   Thanks
   ...ihnp4!shell!graffiti!bruce
   (713) 488-6870
EXT-cottrell-8P5RC 26-Feb-86 ANSI C Draft
   From: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   Reply-to: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   To: {info-c <info-c@BRL.ARPA>}DDN
   Identifier: EXT-cottrell-8P5RC
   Posted: 26-Feb-86 11:25-PST  Received: 25-Mar-86 17:42-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 26 Feb 86 18:10:16 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a010188; 26 Feb 86 20:56
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id a005652; 26 Feb 86 20:43
   EST
   Received: from icst-gw.arpa by AOS.BRL.ARPA id a010144; 26 Feb 86 20:36 
   EST
   /*
   I tried to mail this to mod.std.c, but I forgot their address, and both 
   permutations I tried didn't work, so here it is worldwide!
   To The Authorities:
   Here is a message I received about my posting on the ANSI C Draft. Please
   give it due consideration:
   Return-Path: <KLH@SRI-NIC.ARPA>
   Received: from SRI-NIC.ARPA by NBS-VMS.ARPA ; 23 Feb 86 19:27:27 EST 
   Date: Fri 21 Feb 86 15:03:34-PST
   From: Ken Harrenstien <KLH@SRI-NIC.ARPA>
   Subject: ANSI C Draft
   To: cottrell@NBS-VMS.ARPA
   cc: KLH@SRI-NIC.ARPA
   In-Reply-To: Message from ""COTTRELL, JAMES" <cottrell@nbs-vms.arpa>" of 
   Thu 6 Feb 86 14:34:00-PST
   Message-ID: <12185229280.26.KLH@SRI-NIC.ARPA>
   I noticed your message about the ANSI C standard draft.  I don't know who
   you were replying to, as I don't follow INFO-C all of the time (most of 
   it is irrelevant).  However, I can say that the NIC would be happy to 
   make any such on-line documents available to the Internet community at 
   large, just as we do for RFCs.  We also have OCR hardware for scanning 
   paper documents to convert them into on-line form, and could readily do 
   this for the ANSI C standard drafts if they are not too complex 
   graphically.  All that is needed is agreement.
   I share your feelings about the absurdity of asking for comments in an 
   electronic medium about a document that presumably is also created 
   electronically, and then refusing to provide it in any form other than 
   hard-copy.  A handling charge for paper is understandable (even the NIC 
   now does this) but the cost and the way they have set things up makes 
   them look pretty bad.
   If you can give me the appropriate address or phone number of someone to 
   contact, we will try to arrange something.
   --Ken
   -------
      Yours Truly,
             jim             cottrell@nbs
   */
   ------
EXT-greg-utcsri-uucp-8P6F7 19-Feb-86 Re: The REAL problem(?) with C.
   From: {Gregory Smith <greg%utcsri.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-greg-utcsri-uucp-8P6F7 / <2158@utcsri.UUCP>
   Keywords: Standards Macros
   Posted: 19-Feb-86 13:29-PST  Received: 25-Mar-86 17:43-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 27 Feb 86 01:19:36 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a011676; 27 Feb 86 4:06 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a009907; 27 Feb 86 3:51 EST
   Newsgroups: net.lang.c
   In article <1251@watmath.UUCP>
   rbutterworth@watmath.UUCP (Ray Butterworth) writes: >I wonder how many 
   tens of thousands of dollars of time and resources >have been wasted 
   recently by all of these complaints and discussions >about what the % 
   operator should do.
   >
   >The real problem of course isn't that the % operator was definded 
   >correctly or incorrectly, the problem is that it is intentionally 
   >poorly defined in C.  The expression -5%2 will be positive on some 
   >implementations, and negative on others, but in both cases the answer 
   >will be "correct".
   The nail has been finally hit on the head.
   I see C as about the closest thing we have to a 'portable' assembler, for
   the following reasons ( among others ):
      - The language has 'machine' operators like >>,<<, &,|,~ and pointer 
      operations, available to the user.
      - C does not 'hide' the fact that a computer memory consists of a 
      linear homogenous  address space (except maybe 8086 >:-) ) The C 
      programmer normally has to be aware of this. In most other high-level 
      languages, this is not the case.
      - C does not hide the fact that machines are different from each 
      other. It tries to, but it does not. The programmer needs to be very 
      much aware of the nature of these differences to be able to write 
      portable code. This is not the case in most other HLLs.
   Now the point.
   If C is to be an 'assembler' or 'high-level-assembler', it should be able
   to produce very efficient code, to eliminate one of the prime reasons for
   using 'real' assembler.  For the produced code to be very efficient, it 
   should be as near as possible to the bare instructions required to do 
   what needs doing. Now it is a hard fact that machines have hardware 'mod'
   and 'div' operators, and different machines produce different results for
   these. I do not think it would be a good idea to standardize the results 
   of / and %, because then machines which did not produce the 'correct' 
   results would have problems. The compiler would have to emit clumsy sign-
   checking code, or call a routine to do the operation. This is not 
   consistent with the 'efficiency' objective.
   I believe the designers of C were thinking exactly along these lines. 
   More evidence: char to int conversion may or may not be sign-extended. 
   The PDP-11 makes it dashed clumsy to move a char to an int *without* 
   sign-extend, thus PDP-11 C sign-extends. If the machine cannot do this 
   extension easily, the no-extend operation should take place. More: some 
   types ( unsigned long, unsigned char ) may not be allowed.
   If you need a certain type of division/mod/whatever not guaranteed, do 
   one of the following:
      (1) write a non-portable version, if you know it will never need to be
      ported.
     (2) use #defines:  #define div(a,b) ((a)/(b))   on one machine,
                        #define div(a,b) ((a)<0?-(-(a)/(b)):(a)/(b))
                                              on another, etc
     (3) Don't use C   :-).
   Note that option 2 corresponds to making the compiler emit code for 
   machines with the 'wrong' divide operation. Except this way you only get 
   it when you need it.
   Macros like this could even be provided in system-dependant header files,
   to provide commonly used 'guaranteed' operations. Like toupper(c) and 
   things like that.
   Greg Smith
   University of Toronto
   --------------------------------------------------------------------- 
   These opinions are mine and are not necessarily those of anybody else
   nor are they necessarily very original!      ( =-> )
EXT-barmar-mit-eddie-uuc-8P6GZ 21-Feb-86 Re: Command line arguments, 
redirection, etc.
   From: {Barry Margolin <barmar%mit-eddie.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-barmar-mit-eddie-uuc-8P6GZ / <251@mit-eddie.UUCP>
   Posted: 21-Feb-86 00:42-PST  Received: 25-Mar-86 17:43-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 27 Feb 86 01:42:51 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a011749; 27 Feb 86 4:26 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a009997; 27 Feb 86 3:55 EST
   Newsgroups: net.lang.c
   In article <36@se-sd.UUCP> cbk@se-sd.UUCP (Carl Kuck) writes: >[ Personal
   opinion, FLAME ON ]
   >
   >Any implementation of C that doesn't provide redirection and 
   command-line >argument passing is half-assed at best.
   >
   >[ FLAME OFF]
   This whole discussion is pretty silly, but...
   The above comment implies that a computer that doesn't have command lines
   and files "is half-assed at best".  Most of the computers one uses do not
   have these features.  For example, the computer in my VCR, my terminal, 
   my microwave, my thermostat, etc.  I would be willing to bet that none of
   these is currently programmed in C, but it would be possible for C to be 
   used.
   --
      Barry Margolin
      ARPA: barmar@MIT-Multics
      UUCP: ..!genrad!mit-eddie!barmar
EXT-ray-vger-uucp-8P6QI 20-Feb-86 Question on ANSI C
   From: {Ray Swartz <ray%vger.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-ray-vger-uucp-8P6QI / <348@vger.UUCP>
   Posted: 20-Feb-86 18:26-PST  Received: 25-Mar-86 17:43-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 27 Feb 86 04:42:50 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a013040; 27 Feb 86 7:34 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a016492; 27 Feb 86 7:17 EST
   Newsgroups: net.lang.c
   I have read the proposed ANSI standard and the rational for it and no 
   where does is CLEARLY say whether or not automatic arrays can be 
   initialized!
   Does anyone know what the status of this feature is?
   Ray Swartz
EXT-oz-yetti-uucp-8P6UC 20-Feb-86 case stmt != jumptable of goto labels  
!!!!!!!!!
   From: {Ozan Yigit <oz%yetti.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-oz-yetti-uucp-8P6UC / <324@yetti.UUCP>
   Keywords: case, jumptable
   Posted: 20-Feb-86 07:57-PST  Received: 25-Mar-86 17:43-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 27 Feb 86 05:51:48 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a015290; 27 Feb 86 8:41 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a018140; 27 Feb 86 8:10 EST
   Newsgroups: net.lang.c
   Why is it, when someone asks whether or not jumptables with goto labels 
   are allowed in C, there is the overwhelming response "use a case 
   statement" ????
   It is not the same, except in one isolated circumstance, where the 
   user-created jumptable is completely static.
   Furthermore:
   [1] You are never guaranteed to get a jumptable out of a case statement. 
   If you get it with compiler X, you may not get with compiler Y. [the 
   reason may be a buggy implementation or whatever, but would be 
   unnoticable,  since it does not effect the correctness of the generated 
   code]
   [2] The structure of the case jumptable may be different from compiler to
   compiler. [Vaxen Cc may generate a jump table of relative offsets to feed
   to case[wl] instruction, whereas others may generate a table of direct 
   addresses]
   [3] The jumptable is hidden, thus cannot be manipulated. (unless, of 
   course, you are practicing black magic :-)
   I can see some weird application where a jumptable of goto labels is 
   used, and program dynamically alters the control flow by swapping labels 
   on the jump table, or by adding new ones in. Surely this would be most 
   unreadable, and difficult to debug, and something I would classify as 
   "pornographic programming", but than, It is proven nicely in "obfuscated 
   C" contests that one can do a lot worst.
   Please hold your flame, in case you are ready to lit. I am not suggesting
   that C should have the capability, [Although it is certainly debatable] 
   nor am I suggesting that a jumptable with goto labels is necessary, where
   jumptables with function entries could easily be created. All I am 
   arguing against is the unthinking suggestion that case == jumptable of 
   labels.
   Oz
   --
   Usenet: [decvax|allegra|linus|ihnp4]!utzoo!yetti!oz Bitnet: 
   oz@[yusol|yuyetti]
      FREE SOFTWARE FOUNDATION vs. EMPIRE. Watch for
      things to come..
EXT-perl-rdin-uucp-8P6VD 20-Feb-86 Re: Fast code and no morals (exit() on 
VMS)
   From: {Robert Perlberg <perl%rdin.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-perl-rdin-uucp-8P6VD / <533@rdin.UUCP>
   Posted: 20-Feb-86 12:12-PST  Received: 25-Mar-86 17:43-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 27 Feb 86 06:10:09 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a015878; 27 Feb 86 8:58 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id aa19187; 27 Feb 86 8:36 EST
   Newsgroups: net.lang.c
   >I know this is naive, but then this flock is full of naive users... 
   >Doug, where exactly do Kernighan & Ritchie specify the semantics of >the
   exit() procedure ?
   >
   >                                           you can't say VMS is WRONG
   >just because it's DIFFERENT unless you can quote chapter and verse. >
   >Does the ANSI draft specify semantics for system calls ?
   K&R, Chapter 7, page 154, verse 5 (and I quote -- uh-hum):
   "The program also uses the standard library function exit, which 
   terminates program execution when it is called.  The argument of exit is 
   available atever process called this one, so the success or failure 
   of the program can be tested by another program that uses this one as a 
   subprocess.  By convention, a return value of 0 signals that all is well,
   and various non-zero values signal abnormal situations."
   Amen.
   Let's get real, though.  I don't really care about how something is 
   defined by K&R or ANSI or any so-called authority.  All I care about is 
   being able to copy a bunch of code onto a system, compile it, and have it
   work.  If the designers of VAX C endowed it with an exit() function, it's
   not because they saw it in K&R, it's because they wanted VAX C to be able
   to compile and run the vast body of C code "out there".  The VAX C manual
   is loaded with references to UNIX and has many functions which are 
   clearly intended to mimic UNIX (take a look at stat()).  You could quote 
   K&R till doomsday and it wouldn't make existing code run on existing 
   systems until you wake up and take a look at how things are done in the 
   real world and adapt to it.  You're a fine one to be calling others 
   "naive".
   Robert Perlberg
   Resource Dynamics Inc.
   New York
   {philabs|delftcc}!rdin!perl
EXT-kwh-bentley-uucp-8P6YI 22-Feb-86 Re: Arcane C hacks?
   From: {KW Heuer <kwh%bentley.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-kwh-bentley-uucp-8P6YI / <592@bentley.UUCP>
   Posted: 22-Feb-86 16:37-PST  Received: 25-Mar-86 17:43-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 27 Feb 86 07:04:59 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a017543; 27 Feb 86 9:52 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a021317; 27 Feb 86 9:38 EST
   Newsgroups: net.lang.c
   In articles <184@bu-cs.UUCP> bu-cs!bzs (Barry Shein) writes: >declare a 
   table something like:   int (*funtable[MAXFNS])() ; >and just malloc the 
   storage for the generated code.  ...  It should be >quite portable (code 
   generator aside) and is legal C.
   Well, some compilers will dislike the attempt to cast a (char *) into a 
   (int (*)()) ; in fact I think some will call it an outright error (not 
   just a warning).  But in any case it is _not_ portable to the 3b2, 
   because all programs are pure -- you can't goto/call data space, nor can 
   you read from the instruction stream.  Some sort of chastity belt in the 
   hardware, I think.
EXT-cottrell-8P8EK 27-Feb-86 Compression of Load Modules
   From: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   Reply-to: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   To: {info-c <info-c@BRL.ARPA>}DDN
   Identifier: EXT-cottrell-8P8EK
   Posted: 27-Feb-86 13:38-PST  Received: 25-Mar-86 17:44-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 27 Feb 86 22:45:16 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a003933; 28 Feb 86 1:40 
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id aa06193; 28 Feb 86 1:02 
   EST
   Received: from icst-gw.arpa by AOS.BRL.ARPA id a001926; 27 Feb 86 16:50 
   EST
   /*
   >         TO WHOM IT MAY CONCERN
   >         ----------------------
   Hey, that's me!
   >
   > I am in need of a packing algorithm which works better than the > PACK 
   Utility of UNIX.  I have also looked at COMPRESS ( developed > at 
   University of Utah ).  COMPRESS works great if distinct number > of input
   bytes is small.  But if the distinct input bytes reach > 256 ( binary 
   data ), PACK works better than COMPRESS.  With PACK > I am getting a 
   saving of 20-25%.  If anybody has an algorithm > that would do better in 
   packing "load modules", I would like to > know about it.
   >
   > THNX...........Padam
   >
   > Name:                   Padam Maheshwari
   > Phone:                  (201) 580-4552
   > Organization:           AT&T Bell Labs
   > Address:                3ND15
   >                         184 Liberty Corner Rd
   >                         Warren, NJ 07060-0908
   > NET Mail Address:       ihnp4!pierce!pkm
   I just ran `compressdir -v' on (a *copy* of!) /bin. Here are the results,
   sorted by compression ratio. We run 4.2 BSD. Of course, Doug Gwyn would 
   rather compress /bin/csh by 100% :-). The average compresion (ignoring 
   true/false) seems to be 33.6%. I got my copy of compress via FTP off 
   seismo, Version 4.0 7/30/85. Thanks guys!
      1      ./false: Compression: -57.14% -- file unchanged 2       ./true:
      Compression: -57.14% -- file unchanged 3       ./vi: Compression: 
      25.01% -- replaced with ./vi.Z 4       ./passwd: Compression: 25.66% 
      -- replaced with ./passwd.Z 5  ./ps: Compression: 26.21% -- replaced 
      with ./ps.Z 6  ./grep: Compression: 26.75% -- replaced with ./grep.Z 7 
      ./make: Compression: 26.86% -- replaced with ./make.Z 8        
      ./rmail: Compression: 26.93% -- replaced with ./rmail.Z 9      ./diff:
      Compression: 27.38% -- replaced with ./diff.Z
   10        ./sed: Compression: 27.79% -- replaced with ./sed.Z 11  ./cc: 
   Compression: 27.84% -- replaced with ./cc.Z 12    ./ls: Compression: 
   27.89% -- replaced with ./ls.Z 13 ./login: Compression: 27.93% -- 
   replaced with ./login.Z 14        ./csh: Compression: 28.05% -- replaced 
   with ./csh.Z 15   ./pr: Compression: 28.30% -- replaced with ./pr.Z 16    
   ./tp: Compression: 28.66% -- replaced with ./tp.Z 17      ./chgrp: 
   Compression: 28.77% -- replaced with ./chgrp.Z 18 ./mail: Compression: 
   28.94% -- replaced with ./mail.Z 19       ./cmp: Compression: 29.18% -- 
   replaced with ./cmp.Z 20  ./tar: Compression: 29.21% -- replaced with 
   ./tar.Z 21        ./adb: Compression: 29.43% -- replaced with ./adb.Z 22  
   ./mt: Compression: 29.63% -- replaced with ./mt.Z 23      ./as: 
   Compression: 30.08% -- replaced with ./as.Z 24    ./dd: Compression: 
   30.18% -- replaced with ./dd.Z 25 ./mv: Compression: 30.20% -- replaced 
   with ./mv.Z 26    ./write: Compression: 30.64% -- replaced with ./write.Z
   27        ./sh: Compression: 30.68% -- replaced with ./sh.Z 28    ./time:
   Compression: 30.88% -- replaced with ./time.Z 29  ./ld: Compression: 
   31.10% -- replaced with ./ld.Z 30 ./cp: Compression: 31.55% -- replaced 
   with ./cp.Z 31    ./ar: Compression: 31.62% -- replaced with ./ar.Z 32    
   ./hostid: Compression: 31.80% -- replaced with ./hostid.Z 33      ./od: 
   Compression: 32.69% -- replaced with ./od.Z 34    ./expr: Compression: 
   32.86% -- replaced with ./expr.Z 35       ./du: Compression: 32.93% -- 
   replaced with ./du.Z 36   ./su: Compression: 33.06% -- replaced with 
   ./su.Z 37 ./rm: Compression: 33.34% -- replaced with ./rm.Z 38    ./cat: 
   Compression: 33.50% -- replaced with ./cat.Z 39   ./date: Compression: 
   33.67% -- replaced with ./date.Z 40       ./stty: Compression: 33.96% -- 
   replaced with ./stty.Z 41 ./nm: Compression: 34.52% -- replaced with 
   ./nm.Z 42 ./size: Compression: 34.77% -- replaced with ./size.Z 43        
   ./wall: Compression: 35.02% -- replaced with ./wall.Z 44  ./ed: 
   Compression: 35.07% -- replaced with ./ed.Z 45    ./mkdir: Compression: 
   35.20% -- replaced with ./mkdir.Z
   46        ./rmdir: Compression: 35.27% -- replaced with ./rmdir.Z 47      
   ./pwd: Compression: 35.32% -- replaced with ./pwd.Z 48    ./hostname: 
   Compression: 35.33% -- replaced with ./hostname.Z 49      ./awk: 
   Compression: 35.36% -- replaced with ./awk.Z 50   ./kill: Compression: 
   36.04% -- replaced with ./kill.Z 51       ./ln: Compression: 36.13% -- 
   replaced with ./ln.Z 52   ./who: Compression: 36.18% -- replaced with 
   ./who.Z 53        ./df: Compression: 36.49% -- replaced with ./df.Z 54    
   ./chmod: Compression: 37.36% -- replaced with ./chmod.Z 55        
   ./strip: Compression: 37.94% -- replaced with ./strip.Z 56        
   ./pagesize: Compression: 39.24% -- replaced with ./pagesize.Z 57  ./nice:
   Compression: 44.86% -- replaced with ./nice.Z 58  ./test: Compression: 
   50.61% -- replaced with ./test.Z 59       ./tee: Compression: 58.47% -- 
   replaced with ./tee.Z 60  ./echo: Compression: 59.47% -- replaced with 
   ./echo.Z 61       ./sync: Compression: 63.30% -- replaced with ./sync.Z
     jim             cottrell@nbs
   */
   ------
EXT-woody-Juliet-Caltech-8P8ZH 27-Feb-86 Portable C code
   From: woody%Juliet.Caltech.Edu@CIT-HAMLET.ARPA
   To: info-c%Juliet.Caltech.Edu@CIT-HAMLET.ARPA
   Identifier: EXT-woody-Juliet-Caltech-8P8ZH / 
   <860227144823.024@Juliet.Caltech.Edu>
   Comment: Batteries not included.
   Posted: 27-Feb-86 14:51-PST  Received: 25-Mar-86 17:44-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 28 Feb 86 04:30:44 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a005063; 28 Feb 86 7:24 
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id a019829; 28 Feb 86 7:10 
   EST
   Received: from cit-hamlet.arpa by AOS.BRL.ARPA id a004887; 28 Feb 86 7:03
   EST
   Received: from Juliet.Caltech.Edu by Hamlet.Caltech.Edu with DECNET ;
     Thu, 27 Feb 86 14:52:15 PST
      I have been working on a very large program (~5000 lines-large for a 
      college student doing this by himself with 4 other classes) for a 
      professor here.
      When I wrote it, I decided that it should be done in something that 
      was reasonably portable; I decided to do it in C.  This piece of code 
      is now running on a Macintosh, a VAX-750 under 4.2bsd, and I'm in the 
      process of moving it onto a VAX-750 under VMS and an IBM-PC/XT.  
      Believe me, had I wrote this in assembler, pascal, or (heaven help me)
      fortrash, the work involved in getting this program working on those 
      four machines would have caused my GPA to drop more than it has... :-)
      C may not be too portable, but it sure as heck is a lot more portable 
      than anything else I know (with the possible exception of LISP, but 
      LISP would have been too slow for what I wanted).
         - William Woody
      NET  Woody%Romeo@Hamlet.Caltech.Edu
   USNAIL  1-54 Lloyd, Caltech / Pasadena, CA 91126
EXT-ark-alice-uucp-8P9EO 22-Feb-86 Re: Fast Morals & No Code
   From: {Andrew Koenig <ark%alice.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-ark-alice-uucp-8P9EO / <5020@alice.uUCp>
   Posted: 22-Feb-86 09:00-PST  Received: 25-Mar-86 17:44-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 28 Feb 86 09:32:19 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a013390; 28 Feb 86 12:24
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a004460; 28 Feb 86 11:57 EST
   Newsgroups: net.lang.c
   > The point is that the VMS C implementation must map its exit codes into
   > what the operating system expects. When the programmer says `exit 0', 
   he > means `I succeeded'. The exit() function must support this. >
   > jim             cottrell@nbs
   No way!  exit(n) means "terminate and send the number n back to the 
   system."
EXT-latham-bsdpkh-uucp-8P9EL 21-Feb-86 Re: Fork and Execl
   From: {Ken Latham <latham%bsdpkh.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-latham-bsdpkh-uucp-8P9EL / <172@bsdpkh.UUCP>
   Posted: 21-Feb-86 14:12-PST  Received: 25-Mar-86 17:44-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 28 Feb 86 09:32:50 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a013379; 28 Feb 86 12:23
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a004308; 28 Feb 86 11:55 EST
   Newsgroups: net.lang.c
   > I've got a question ...
   >....but where does the execution of the child process continue from ? > 
   In other words, if I wanted to put an execl() in the child to overwrite >
   the child, where would it go ?
   A common phrase used is:
   ......PARENT
   if ( (childid = fork()) == 0)
   {
      DO execl();
   }
   if ( childid != -1 )
      werror=wait(&status);  /* status being a status structure */
   REST OF PARENT ....;
   ( Yes, I know it's not standard indentation ..... :-) )
   You get two complete copies of the process executing from the same point 
   in process with the same data, stack ... well everything EXCEPT the 
   return code from fork().  The parent gets the PID of the kid, the kid 
   gets 0. ( other restrictions may apply see fork(2), void where 
   prohibited) the execl() will never be executed if the fork() call fails.
   If you are using OS9 however you get a NEW process as a child ... never 
   mind I'm getting carried away.
   Be careful the above will NOT work if the CHILD doesn't do an exec() of 
   some kind ( or exit inside the if ).  The child would execute what was 
   inside the if ... drop out .... execute the parent code... etc.  Although
   you may WANT to do this some times!
                     Ken Latham, AT&T-IS (via AGS Inc.), Orlando , FL
                     uucp: ihnp4!bsdpkh!latham
EXT-cottrell-8P9LS 28-Feb-86 Fast Morals & No Exit
   From: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   Reply-to: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   To: {info-c <info-c@BRL.ARPA>}DDN
   Identifier: EXT-cottrell-8P9LS
   Posted: 28-Feb-86 10:53-PST  Received: 25-Mar-86 17:44-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 28 Feb 86 11:42:01 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a016519; 28 Feb 86 14:29
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id a010496; 28 Feb 86 14:12
   EST
   Received: from icst-gw.arpa by AOS.BRL.ARPA id a015767; 28 Feb 86 14:04 
   EST
   /* >> is Me, > is Andrew Koenig <ark@alice.uucp>
   > > The point is that the VMS C implementation must map its exit codes 
   into > > what the operating system expects. When the programmer says 
   `exit 0', he > > means `I succeeded'. The exit() function must support 
   this. >
   > No way!  exit(n) means "terminate and send the number n back to the 
   system."
   Referring to the infamous `April 30 1985' ANSI C Draft (I geuss the NIC 
   doesn't have their copy online yet :-), Section D.10.4.2, last three 
   lines, it says, "Finally, control is returned to the environment. If the 
   value of status is zero, the status returned is successful termination; 
   otherwise an implementation-defined form of the status unsuccessful 
   termination is returned". Whew! Quoting that was worse than reading it.
   I would be surprised if the standard has changed on this point.
   The Point Is, if `successful termination' means rewinding all the 
   tapedrives, printing the American flag on the laser printer, or aborting 
   the space shuttle, when I say `exit(0)', THAT IS WHAT MUST HAPPEN!!! As 
   you well know, a function _exit(int status) exists to do just what you 
   mention. On VMS, after cleanup, exit(int status) should call 
   _exit(!status) in order to conform. I want my scripts to work right!
   You see, Doug, not everyone who disagrees with Andy is a turkey.
     jim             cottrell@nbs
   */
   ------
EXT-cottrell-8P9PF 28-Feb-86 C Portability
   From: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   Reply-to: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   To: {info-c <info-c@BRL.ARPA>}DDN
   Identifier: EXT-cottrell-8P9PF
   Posted: 28-Feb-86 11:44-PST  Received: 25-Mar-86 17:44-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 28 Feb 86 12:47:07 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a018045; 28 Feb 86 15:37
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id a013508; 28 Feb 86 15:14
   EST
   Received: from icst-gw.arpa by AOS.BRL.ARPA id a017498; 28 Feb 86 15:06 
   EST
   /*
   > The point about the "C" being as portable as Stonehenge was made NOT to
   > imply that programs should be routinely written in Assembler Language >
   (pun not intended), but rather that porting of programs written in "C" > 
   has its own different set of problems, the solution to some of which are 
   > noted above.  This is very obvious to organizations, such as mine, that
   > distribute "C"-based software for use on many different host systems, 
   all of > which allegedly have "standard UNIX" and "standard C" (whatever 
   "standard" > means these days).
   If it didn't have `it's own set of problems' your company wouldn't exist.
   Do you think all you have to do is show up at your customer's site with 
   tar tapes, run a `make install, & go home? Any fool can do that.
   > Of course, we would never be able to distribute our software for so 
   many > different host systems if we were required to write the code in 
   Assembler, > but, on the other hand, we must go through significant 
   coding gymnastics to > assure the portability including sticking to the 
   "least common multiple" of > language features and "detuning" programs 
   due to the compiler restrictions > (authors call them features, of 
   course) on some systems.  We don't have the > luxury of telling our 
   customers "too bad, your system doesn't have a good > or standard enough 
   C compiler!"
   Ever heard of `#ifdefs'? That way you can write your code for a `normal' 
   machine & your favorite environment, then put in #ifdefs for other 
   environments. You may not have the luxury of telling your customers too 
   bad (you must not be from SUN :-), but you *can* charge them a different 
   price for your services. After all, it's the weird ones that make it 
   harder, let *them* pay for it.
     jim             cottrell@nbs
   */
   ------
EXT-cottrell-8P9R1 28-Feb-86 Stack Frames
   From: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   Reply-to: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   To: {info-c <info-c@BRL.ARPA>}DDN
   Identifier: EXT-cottrell-8P9R1
   Posted: 28-Feb-86 12:09-PST  Received: 25-Mar-86 17:44-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 28 Feb 86 13:16:26 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a019121; 28 Feb 86 16:07
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id a014720; 28 Feb 86 15:40
   EST
   Received: from icst-gw.arpa by AOS.BRL.ARPA id a017832; 28 Feb 86 15:28 
   EST
   /*
   > >> If your C compiler generates additional overhead for local > >> 
   blocks, it is not very good.  Most reasonable implementations > >> 
   reserve enough stack at function entry for the deepest local > >> block 
   nesting within the function, so that there is no > >> run-time action 
   required upon entering a local block. [DAGWYNN] > >
   > > Not only `not very good' but seemingly impossible. If a separate > > 
   stack frame [were] created, access to arguments would be different > > 
   within the new block. Still doable, but now try jumping in or
   > > out of the block. Getting Hairy!              [COTTRELL]
   >
   > There is at least one compiler out there for which does this.  I know >
   because I got a bug report on vnews concerning a piece of code where > I 
   jumped into the middle of a block.  The rule is that the effect of > 
   jumping into a block containing declarations is machine dependent.  All >
   other jumps, such as jumping into a block that contains no variable > 
   declarations or jumping out of a block that does, are all legal, just > 
   as in PL/1.
   While I rarely do this (I did for the Rand editor for the arrow keys, 
   they had `ESC [ A', & my terminal produced both that & `ESC O A' as well.
   I jumped from one switch into the other) I would not expect any penalty 
   by doing this. I consider the idea of blocks stupid, merely syntactic 
   sugar. `{' is `then'. `}' is `end'. Functions should be small enuf so 
   that nested blocks are not needed. But I'm rambling...
   > Cottrell overestimates the difficulty of allocating variables declared 
   > in a block when that block is entered.  On a stack based machine, when 
   > you enter a block with declarations, the compiler merely adjusts the > 
   stack pointer to make room for the variables.
   And I think you underestimate the difficulty. You are not creating a new 
   stack frame, which is what the original discussion mentioned. Also, are 
   you referencing your variables relative to the stack pointer, or the 
   frame pointer? The stack pointer moves around, especially in expressions 
   like: `{ int q = 3; printf("%d%d%d%d\n",q,q*q,q*q*q,q*q*q*q); }'.
   >When you exit the block,
   > either by reaching the bottom or by doing a goto out of it, the stack >
   pointer must be adjusted back.  This is also fairly simple if the com- > 
   piler is prepared to read the entire routine before it starts generating 
   > code (otherwise it wouldn't know which goto's required adjustment to 
   the > stack pointer).  Ideally, the compiler should also adjust the stack
   > pointer when compiling a goto into a block that contains declarations, 
   > but C does not require this.
   While all this is possible, the way Doug described is so much simpler, 
   faster, easier, & offers less surprises. Your compiler must have been 
   written by a nested block freak.
   > The advantage of this approach is that stack space may be saved if > 
   subroutines are called outside the block.  In most code the space > 
   savings won't make much difference.  The disadvantage is the extra time >
   spent adjusting the stack pointer.  Again this cost is likely to be 
   small, > but my guess is that is the cost of adjusting the stack pointer 
   will > usually outweigh the space savings that it brings, and most 
   compiler > writers appear to agree.  Still, you cannot count on this if 
   you want > to write portable code.
   I agree totally. If it's small, who cares. If it's big, use malloc. The 
   time overhead is the same to adjust the stack pointer by one as it is to 
   adjust it by one thousand. Unless you have an `add quick'.
   >                                 Kenneth Almquist
   >                                 ihnp4!houxm!hropus!ka   (official name)
   >                                 ihnp4!opus!ka           (shorter path)
     jim             cottrell@nbs
   */
   ------
EXT-cottrell-8P9U8 28-Feb-86 Fast code and no case
   From: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   Reply-to: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   To: {info-c <info-c@BRL.ARPA>}DDN
   Identifier: EXT-cottrell-8P9U8
   Posted: 28-Feb-86 12:56-PST  Received: 25-Mar-86 17:44-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 28 Feb 86 14:14:34 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a019605; 28 Feb 86 16:44
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id a016379; 28 Feb 86 16:26
   EST
   Received: from icst-gw.arpa by AOS.BRL.ARPA id a019351; 28 Feb 86 16:18 
   EST
   /*
   > Yes, but C requires both upper- and lower-case support for > program 
   text itself, which rules out implementation on real > dinosaurs 
   (hurray!).
   Not really. Who says sizeof(char) must be a `byte' on a particular 
   machine? You could use `int's or `short's to hold chars. And what is 
   `case'? There are only `numbers' or `bits' inside a computer. They don't 
   turn into `characters' until you send them to a printing device.
   Of course all this is so stupid I don't even know why I posted it.
     jim             cottrell@nbs
   */
   ------
EXT-cottrell-8P9UK 28-Feb-86 Parallel Stack Frames
   From: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   Reply-to: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   To: {info-c <info-c@BRL.ARPA>}DDN
   Identifier: EXT-cottrell-8P9UK
   Posted: 28-Feb-86 13:29-PST  Received: 25-Mar-86 17:44-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 28 Feb 86 14:21:01 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a019660; 28 Feb 86 16:56
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id a016619; 28 Feb 86 16:37
   EST
   Received: from icst-gw.arpa by AOS.BRL.ARPA id a019562; 28 Feb 86 16:39 
   EST
   /* Eugene Brooks writes:
   > The idea of creating a new context with each entry to a {} block, > or 
   at least for some very special ones, has some merit worth > thinking 
   about.  Suppose you have extended C for parallel programming.
   Is this what your `vectorizing C compiler' does :-) Isn't this 
   announcement a little over a month early :-) :-)
   > main()
   > {
   >         int i;
   >         int shared;
   >
   >         forall(i from 0 to 9) {
   >                 int private;
   >                 /* lines of code */
   >         }
   > }
   >
   > if the forall loop is looked at as a fork of 10 lines of control > 
   which join up at the closing brace then the opening brace must do > 
   something special to the stack frame so that 10 seperate copies of > 
   'private' are generated.  The int 'shared' is on the stack of the parent 
   > and can be read or written by all of the lines of control but the > 
   stack splits into 10 segments at the opening brace of the forall loop.
   This is one school of thought on P.P., small grain. I myself prefer 
   explicit declaration of parallelism, i.e. a larger grain. Thus I would 
   write something like:
   int shared[10];
   int *private = &shared[0];
   main()
   { int n = 0;
      somehow_declare_shared(shared,sizeof(shared));
      while (n++ < 10)
         if (fork()) ++private;
             else    child();
     while (n--)     wait();
   }
   child()
   { child plays with *private;
   }
   As you know, the usefulness of your construct depends on the size of 
   what's inside the loop compared to what's outside it. That is, how much 
   of your code can be parallelized vs how much is sequential.
     jim             cottrell@nbs
   */
   ------
EXT-dietz-slb-doll-csnet-8P9XU 28-Feb-86 What happened to label variables?
   From: {Paul Dietz <dietz%slb-doll.csnet@CSNET-RELAY.ARPA>}DDN
   To: info-c@BRL.ARPA
   Identifier: EXT-dietz-slb-doll-csnet-8P9XU
   Posted: 28-Feb-86 11:11-PST  Received: 25-Mar-86 17:44-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 28 Feb 86 15:19:59 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a019869; 28 Feb 86 18:15
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id aa17352; 28 Feb 86 18:06
   EST
   Received: from csnet-pdn-gw.arpa by AOS.BRL.ARPA id a019851; 28 Feb 86 
   18:01 EST
   Received: from slb-doll by csnet-relay.csnet id a003623; 28 Feb 86 15:10 
   EST
   Posted-Date: Fri 28 Feb 1986 14:11:20 EST
   I recall that C on early UNIX's treated labels as constants of type (int 
   *).  As a result, you could assign labels to variables and even jump to 
   the label in a variable.  This got taken out of K&R, and as I far as I 
   can tell it's not in other C's today.
   This is unfortunate; I ran into a situation recently in which I wanted to
   (automatically) generate C code that should, for efficiency reasons, 
   contain label variables.  I had to simulate them with a switch statement 
   of the form:
      switch(labelindex) {
         case 1: goto label1;
         case 2: goto label2;
         ...
         case n: goto labeln;
             default: fprintf(stderr,"unknown label index: %d\n",
                                     labelindex);
                      abort();
   }
   This is a lot slower, though, and some of the compiler's I tried it on 
   (the VAX VMS C compiler, for example) did not peephole optimize the jump 
   table implementing the switch and the branch instructions implementing 
   the goto's (this should have been treated as a jump to a jump).
   I'm curious if any commerically available C compilers implement jumps to 
   arbitrary pointers without recourse to assembly language inserts.
EXT-cottrell-8Q01S 28-Feb-86 What happened to labels
   From: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   Reply-to: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   To: {info-c <info-c@BRL.ARPA>}DDN
   Identifier: EXT-cottrell-8Q01S
   Posted: 28-Feb-86 15:50-PST  Received: 25-Mar-86 17:44-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 28 Feb 86 16:30:37 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a019972; 28 Feb 86 19:19
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id a017597; 28 Feb 86 19:12
   EST
   Received: from icst-gw.arpa by AOS.BRL.ARPA id a019964; 28 Feb 86 19:09 
   EST
   /*
   > I recall that C on early UNIX's treated labels as constants of type > 
   (int *).  As a result, you could assign labels to variables and even > 
   jump to the label in a variable.  This got taken out of K&R, and > as I 
   far as I can tell it's not in other C's today. >
   > This is unfortunate;
   I don't think you will get much sympathy on this point.
   > I ran into a situation recently in which I wanted > to (automatically) 
   generate C code that should, for efficiency reasons, > contain label 
   variables.  I had to simulate them with a switch statement > of the form:
   >
   >         switch(labelindex) {
   >                 case 1: goto label1;
   >                 case 2: goto label2;
   >                 ...
   >                 case n: goto labeln;
   >                 default: fprintf(stderr,"unknown label index: %d\n",
   >                                         labelindex);
   >                          abort();
   >         }
      switch(labelindex) {
         case 1: label1: <code> break;
         case 2: label2: <code> break;
         ...
             case n: labeln: <code> break;
             default: fprintf(stderr,"unknown label index: %d\n",
                                     labelindex);
                      abort();
   }
   > This is a lot slower, though, and some of the compiler's I tried it > 
   on (the VAX VMS C compiler, for example) did not peephole optimize the > 
   jump table implementing the switch and the branch instructions > 
   implementing the goto's (this should have been treated as a jump > to a 
   jump).
   >
   > I'm curious if any commerically available C compilers implement jumps >
   to arbitrary pointers without recourse to assembly language inserts.
   Probably not. I think they all wised up. Why don't you?
     jim             cottrell@nbs
   */
   ------
EXT-brett-wjvax-uucp-8Q09Z 21-Feb-86 Re: Stack Frames
   From: {Brett Galloway <brett%wjvax.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-brett-wjvax-uucp-8Q09Z / <655@wjvax.wjvax.UUCP>
   Posted: 21-Feb-86 09:57-PST  Received: 25-Mar-86 17:45-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 28 Feb 86 18:58:19 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a000365; 28 Feb 86 21:54
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a018044; 28 Feb 86 20:59 EST
   Newsgroups: net.lang.c,net.unix-wizards
   Followup-To: net.unix-wizards
   Xref: seismo net.lang.c:8124 net.unix-wizards:16996
   This posting may be slightly inappropriate in net.lang.c, but I am 
   interested in the matter of how variables get declared in routine 
   subblocks (i.e. within {} within a routine; for example:
   routine()
   { int     a;
      { int b; }
   }
   I would assume that they are declared in routine()'s stack frame, and 
   that the only effect of declaring them in a subblock is to restrict their
   scope to that subblock.
   HOWEVER, in the Mt Xinu port of BSD 4.2 (for a VAX 750), dbx does not 
   seem to treat them this way; once dbx has moved into a subblock in which 
   variables are declared, any variables higher up in the stack are marked 
   as "not active".  This behaviour of dbx appears to be wrong.  My question
   is whether this behaviour is simply a shortcoming of dbx's implementation
   of subblock scoping, or whether it reflects some peculiarity in the way 
   variables declared in subblocks are treated by the c compiler.
   My apologies if this question is obvious or inappropriate.  Please send 
   me mail if the answer is not of general interest.
   -------------
   Brett Galloway
   {pesnta,twg,ios,qubix,turtlevax,tymix,vecpyr,certes,isi}!wjvax!brett
EXT-dietz-slb-doll-csnet-8Q4KJ 1-Mar-86 What happened to label variables?
   From: {Paul Dietz <dietz%slb-doll.csnet@CSNET-RELAY.ARPA>}DDN
   To: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   Cc: info-c@BRL.ARPA
   Identifier: EXT-dietz-slb-doll-csnet-8Q4KJ
   In-reply-to: "COTTRELL, JAMES"'s message of 28 Feb 86 18:50:00 EST
   Posted:  1-Mar-86 10:32-PST  Received: 25-Mar-86 17:45-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 17:17:57 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002181; 2 Mar 86 20:05 
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id ag00696; 1 Mar 86 22:45 
   EST
   Received: from csnet-pdn-gw.arpa by AOS.BRL.ARPA id a000255; 1 Mar 86 
   18:08 EST
   Received: from slb-doll by csnet-relay.csnet id aa13847; 1 Mar 86 14:09 
   EST
   Posted-Date: Sat 1 Mar 1986 13:32:19 EST
   >> [the lack of label varibles in C] is unfortunate...
   >I don't think you will get much sympathy on this point.
   I certainly wasn't suggesting the use of label variables by human 
   programmers.  However, like gotos, they make writing source-to-source 
   translators easier in some cases (such as mine).
   You suggested:
   >         switch(labelindex) {
   >                 case 1: label1: <code> break;
   >                 case 2: label2: <code> break;
   >                 ...
   >                 case n: labeln: <code> break;
   >                 default: fprintf(stderr,"unknown label index: %d\n",
   >                                         labelindex);
   >                          abort();
   >         }
   Unfortunately, this doesn't always work.  Some of the label1 ... labeln 
   may be inside additional switch statements.  In any case, using a switch 
   statement is still slower than a jump to a label variable, since the 
   object code must check if the index is out of range (the VAX does this in
   microcode but it's still slower than a jump).
   >> [Do any current compilers have indirect jumps...?] > Probably not. I 
   think they all wised up. Why don't you?
   Because I want to generate C, and I want efficient code.  The switch hack
   is contorted and inefficient.
EXT-jpm-8Q4KG 1-Mar-86 ANSI C yacc grammer
   From: {John McNamee <jpm@BNL.ARPA>}DDN
   To: Info-C@BRL.ARPA
   Identifier: EXT-jpm-8Q4KG / <8603012001.AA01359@BNL.ARPA>
   Posted:  1-Mar-86 12:01-PST  Received: 25-Mar-86 17:45-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 17:18:37 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002170; 2 Mar 86 20:03 
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id ab00502; 1 Mar 86 22:40 
   EST
   Received: from bnl-gw.arpa by AOS.BRL.ARPA id a000174; 1 Mar 86 17:59 EST
   Received: by BNL.ARPA; Sat, 1 Mar 86 15:01:30 est
   A few months ago somebody posted a yacc grammer for ANSI C.  Does anybody
   on the Internet have that online for anonymous FTP?
      John McNamee
      jpm@BNL.ARPA
EXT-guy-sun-uucp-8Q4KV 23-Feb-86 Re: Arcane C hacks?
   From: {Guy Harris <guy%sun.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-guy-sun-uucp-8Q4KV / <3284@sun.uucp>
   Posted: 23-Feb-86 03:41-PST  Received: 25-Mar-86 17:45-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 17:25:35 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002198; 2 Mar 86 20:09 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a001286; 1 Mar 86 23:01 EST
   Newsgroups: net.lang.c
   > >declare a table something like:   int (*funtable[MAXFNS])() ; > >and 
   just malloc the storage for the generated code.  ...  It should be > 
   >quite portable (code generator aside) and is legal C. >
   > Well, some compilers will dislike the attempt to cast a (char *) into >
   a (int (*)()) ; in fact I think some will call it an outright error > 
   (not just a warning).  But in any case it is _not_ portable to the 3b2, >
   because all programs are pure -- you can't goto/call data space, nor > 
   can you read from the instruction stream.
   3B2, hell, that goes all the way back to separate I&D space on the 
   PDP-11. It is quite unportable, and "lint" will justifiably complain 
   about it, warning of a "questionable conversion of function pointer" 
   (even if you're converting another kind of pointer *into* a function 
   pointer, but that's life during UNIX).
   Then again, if they're generating code on the fly, it's not going to be 
   very portable anyway, so if you're doing this sort of thing worrying 
   about whether the pointer conversion is portable is kind of silly.  (If 
   you really MUST do this sort of thing, you can probably get the OS to 
   help by providing a call to convert a data segment into a code segment.) 
   --
      Guy Harris
      {ihnp4, decvax, seismo, decwrl, ...}!sun!guy
     guy@sun.arpa    (yes, really)
EXT-josh-crunch-uucp-8Q4LH 23-Feb-86 a basic like gosub in C
   From: {Josh Siegel <josh%crunch.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-josh-crunch-uucp-8Q4LH / <202@crunch.uucp>
   Posted: 23-Feb-86 12:06-PST  Received: 25-Mar-86 17:45-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 17:36:07 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002234; 2 Mar 86 20:24 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a001760; 1 Mar 86 23:31 EST
   Newsgroups: net.lang.c
   In basic there is a GOSUB routine that will push the current position 
   onto the stack and jump to another line.  Then, upon hitting a return 
   will return to that place.  I wish to write something like that in C that
   will be movable between compilers.
   A sample of something like it is below:
   5  rem Basic
   10 print "hi"
   20 gosub 50
   30 print "bye"
   35 gosub 50
   40 end
   50 print "hello"
   55 print "who are you?"
   60 return
   /* C code that does work */
   main () {
      (void)gosub (0);
   }
   gosub (line)
   int     line;
   {
      switch (line) {
         default:
            puts ("hi");
            (void)gosub (50);
            puts ("bye");
            (void)gosub (55);
            exit (0);
         case 50:
            puts ("hello");
         case 55:
            puts ("who are you");
            return (0);
      }
   }
   Can anybody think of a better way to do this? I want it for a Basic->C 
   translator (Please, I am writting it for fun... No abuse...Please?).
      thanks much,
   Send me mail . . . I   L O V E  mail
      Josh Siegel
           {convex,ucbvax,gatech,csu-cs,anl-mcs,lanl-a}!unmvax
                                                              \
                                                              !crunch!josh
                                                              /
   {cmcl2,csu-cs,dirac,dspo,gel,ias,ihnp4,mtu,nmsu}!lanl!quark
EXT-phillips-cisden-uucp-8Q4LQ 24-Feb-86 Re: UNIX Futures
   From: {Tom Phillips <phillips%cisden.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-phillips-cisden-uucp-8Q4LQ / <521@cisden.UUCP>
   Posted: 24-Feb-86 15:44-PST  Received: 25-Mar-86 17:45-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 17:41:56 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002245; 2 Mar 86 20:26 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a003671; 2 Mar 86 3:52 EST
   Newsgroups: net.lang.c
   In article <1131@brl-smoke.ARPA> cottrell@NBS-VMS.ARPA (COTTRELL, JAMES) 
   writes: >Divergence? Who renumbered the manual sexions? Who made
                                          AAAAAAAAAAAAAAAAARRRRRGHHH!
   > jim             cottrell@nbs
   jim, i want you to know that no matter how good the stuff you say is i 
   won't read it until someone removes the 'x' from your keyboard.--
                                             Tommy Phillips
   From the banks of the great grey-green greasy Limpopo River, all set 
   about with fever-trees.
                             cisden!phillips
EXT-guy-sun-uucp-8Q4LZ 23-Feb-86 Re: code and comments disagreeing 
(4.[23]BSD TCP code)
   From: {Guy Harris <guy%sun.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-guy-sun-uucp-8Q4LZ / <3278@sun.uucp>
   Posted: 23-Feb-86 03:10-PST  Received: 25-Mar-86 17:45-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 17:46:07 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002314; 2 Mar 86 20:40 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a001263; 1 Mar 86 23:00 EST
   Newsgroups: net.lang.c,net.bugs.4bsd
   Followup-To: net.bugs.4bsd
   Xref: seismo net.lang.c:8126 net.bugs.4bsd:1948
   > Found in our kernel code:
   >
   > /* this should be SEQ_LT; is SEQ_LEQ for BBN vax TCP only */ >          
      (SEQ_LT(ti->ti_ack, tp->iss) ||
   You'll be happy to know this is fixed in 4.3beta; the comment is gone 
   (and the code uses SEQ_LEQ).  However, while looking up "iss", I found a 
   worse bug; "netinet/tcp_var.h" refers you to RFC783, which is the TFTP 
   RFC, NOT the TCP RFC, which is RFC793.  The copy of RFC793 we have is 
   dated September 1981, not December 1981, and the sequence variables are 
   defined on page 19, not page 21.  This demonstrates how useful comments 
   are.  (From my quick reading of the code and the RFC, SEQ_LEQ seems to be
   correct; "tp->iss" is the sequence number on the "SYN" sent out, and the 
   other side should ACK that SYN with the next sequence number it expects 
   to see, which must be greater than the one it just saw.)
   > (gee, I wonder now, should I worry about posting "secret" code? :-)
   This code is not AT&T code, it's Berkeley code (and may be descended from
   BBN code).  I don't know whether there are any trade secret restrictions 
   on Berkeley's or BBN's TCP implementation, although since the US Federal 
   Gummint paid for the Berkeley work (and maybe the BBN work) I tend to 
   doubt it.
   --
      Guy Harris
      {ihnp4, decvax, seismo, decwrl, ...}!sun!guy
     guy@sun.arpa    (yes, really)
EXT-guy-sun-uucp-8Q4MB 23-Feb-86 Re: what does exit(0) mean?
   From: {Guy Harris <guy%sun.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-guy-sun-uucp-8Q4MB / <3281@sun.uucp>
   Posted: 23-Feb-86 03:27-PST  Received: 25-Mar-86 17:45-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 17:51:47 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002326; 2 Mar 86 20:41 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a001270; 1 Mar 86 23:01 EST
   Newsgroups: net.lang.c
   > > The point is that the VMS C implementation must map its exit codes 
   into > > what the operating system expects. When the programmer says 
   `exit 0', he > > means `I succeeded'. The exit() function must support 
   this. >
   > No way!  exit(n) means "terminate and send the number n back to the 
   system."
   In UNIX C, definitely.  In ANSI C (as given in the current draft), no 
   way. Chapter and verse citations have been given in previous articles.  A
   VMS ANSI C implementaion will return SS$NORMAL or whatever they call it 
   when you do "exit(0)".  Presumably, "exit(n)", for "n" != 0, can return 
   with "n". --
      Guy Harris
      {ihnp4, decvax, seismo, decwrl, ...}!sun!guy
     guy@sun.arpa    (yes, really)
EXT-jimc-ucla-cs-uucp-8Q4MN 24-Feb-86 Architecture of Integer Remainder
   From: jimc%ucla-cs.uucp@BRL.ARPA
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-jimc-ucla-cs-uucp-8Q4MN / <9341@ucla-cs.ARPA>
   Posted: 24-Feb-86 09:08-PST  Received: 25-Mar-86 17:45-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 17:57:14 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002336; 2 Mar 86 20:42 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a003742; 2 Mar 86 3:58 EST
   Newsgroups: net.lang.c,net.arch
   Xref: seismo net.lang.c:8132 net.arch:2685
      When a negative integer is divided, what should be the sign of the 
      remainder?  Should -14/5 = -3 remainder +1, or -2 remainder -4?  The 
      draft standard for "C" language (X3J11/85-138 sect. C.3.5 line 434) 
      states that the sign is "implementation defined", as different 
      hardware produces different results, and to make all conform would be 
      inefficient.  Many "C" users desire a specific standard, and debate 
      has churned in the last few weeks over what should be done.
      One person points out that if you sell 9 things for $10.00 the unit 
      price is $1.11, so if you buy 9 for $-10.00 the price should be 
      $-1.11.  In this case the remainder should have the sign of the 
      dividend.  (Integers are assumed, Cobol style.)
      Many have pointed out systems applications that demand a positive 
      remainder. Examples are converting a signed time offset to hours and 
      minutes; a signed byte offset in a file to bytes, sectors and tracks; 
      a hash table when the key is signed; a ring cache when jumps are long 
      and bidirectional; and so on. Range reduction of periodic functions is
      a related example in floating point. And the positive remainder is 
      clearly what the theory of rings demands.
      We have also been pointedly reminded that Fortran, Cobol, Basic and 
      Ada all make the remainder sign match the dividend, and against such 
      forces we cannot expect any kind of rational choice to prevail.
      The issue is more, should users, compilers or hardware produce the 
      required remainder sign?  Users are capable of doing (where % means 
      remainder):
         r = a % b; if (r < 0) r = r + b;
   or   if (a < 0) a = a - (b-1); q = a/b; r = a - b*q;
   But users feel the irregular remainder sign is a blemish in a 
   well-constructed language and a significant error exposure if forgotten. 
   Compilers are capable of providing the same code automatically, but 
   compiler writers know that 90% of all divisions are of positive 
   quantities and they have to produce the code for all divisions, a waste. 
   Hardware divide algorithms, at least those I know of, cannot handle a 
   negative dividend so that an explicit sign-correction step is necessary, 
   again slowing down the machine.
      "C" users: Do we have a consensus that there should be a specific 
      standard, and that we want the remainder sign positive -- if the 
      efficiency issue can be resolved?  Do users want a positive remainder 
      even if it usually means wasted code?  How do users of other languages
      feel?
      Compiler writers: Is it feasible to recognize when a dividend is in 
      fact always positive, so the extra code can be omitted?  If you 
      declare the dividend explicitly unsigned, on some machines you must 
      produce bizarrely contorted code to handle the N'th bit; is it 
      feasible to recognize when these contortions are unnecessary?
      Hardware engineers:  It's you who got us into this, so please help us 
      get out by, in the next generation of machines, handling division the 
      way the users want -- don't tell us to take our discussion elsewhere. 
      Is there any major hardware that does not make the remainder sign 
      match the dividend?  Is there any efficient divide algorithm that 
      works equally well on both sign dividends?  Is it a significant burden
      on hardware to adjust the remainder when it is negative?
      To avoid clogging the newsgroups for another few weeks, please mail me
      your comments and I will summarize them.  Closing date 3 March.  Thank
      you.
   --
   James F. Carter            (213) 206-1306
   UCLA-SEASnet; 2567 Boelter Hall; 405 Hilgard Ave.; Los Angeles, CA 90024 
   UUCP:...!{ihnp4,ucbvax,{hao!cepu}}!ucla-cs!jimc  ARPA:jimc@locus.UCLA.EDU
EXT-bs-faron-uucp-8Q4MW 27-Feb-86 Long Longs
   From: {"Robert D. Silverman" <bs%faron.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-bs-faron-uucp-8Q4MW / <491@faron.UUCP>
   Posted: 27-Feb-86 03:56-PST  Received: 25-Mar-86 17:45-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 18:02:56 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002356; 2 Mar 86 20:45 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a005131; 2 Mar 86 5:49 EST
   Newsgroups: net.lang.c
   Much of the work I (and others) do involves frequent computations of the 
   form:
   int a,b,c,d;
   a = (b*c)/d;
   a = (b*c) % d;
   Even when I know (because of normalization or other conditions) that a 
   will fit in a single machine word, C does not allow one to do such 
   computations. The difficulty of course is that b*c frequently will 
   overflow. However, many machines CAN multiply two full words together 
   giving a double length product placed in two adjacent registers. Since 
   there is no 'double register int a' or 'long long a' in C, one is forced 
   however to write an assembler routine to do such arithmetic. However, if 
   one does such computations frequently (e.g. millions of times) the cost 
   of calling a routine to do it is prohibitive. e.g. A three argument call 
   on the VAX takes 16+ usec.
   Does anyone have a good solution?
   Does C++ have long longs? Does anyone know of ANY language that does? 
   (Bignums in Lisp don't qualify)
   Bob Silverman
EXT-gnu-hoptoad-uucp-8Q4MZ 24-Feb-86 Re: case stmt != jumptable of goto 
labels  !!!!!!!!!
   From: {John Gilmore <gnu%hoptoad.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-gnu-hoptoad-uucp-8Q4MZ / <553@hoptoad.uucp>
   Keywords: case, jumptable
   Posted: 24-Feb-86 19:37-PST  Received: 25-Mar-86 17:45-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 18:01:49 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002347; 2 Mar 86 20:43 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a004112; 2 Mar 86 4:05 EST
   Newsgroups: net.lang.c
   It is true that a case (in C, "switch") statement is not the same as a 
   jump vector, because the vector cannot be modified.  However, a trivial 
   hack gives the behaviour you want:
      int vector[MAX_JUMPS];
      switch (vector[i]) {
   This costs one subscripting operation per jump -- a price, but a small 
   price. Not nearly the overhead of a function call, for example.  I've 
   seen exactly this kind of contruct used for the inner loop of an 
   interpreter.  It probably works OK for a regular expression scanner, or 
   lexer, too.
   You can even do it one better by declaring
      int *vector;
   and pointing it at whatever jump table you are currently interested in, 
   out of a set of precompiled or dynamically built jump tables.
   Are we having done yet?
   --
   John Gilmore  {sun,ptsfa,lll-crg,ihnp4}!hoptoad!gnu   
   jgilmore@lll-crg.arpa
EXT-grt-twitch-uucp-8Q4N6 27-Feb-86 casting pointers, executing from .data
   From: {" G.R.Tomasevich" <grt%twitch.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-grt-twitch-uucp-8Q4N6 / <285@twitch.UUCP>
   Posted: 27-Feb-86 09:53-PST  Received: 25-Mar-86 17:45-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 18:07:39 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002366; 2 Mar 86 20:46 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a005171; 2 Mar 86 5:52 EST
   Newsgroups: net.lang.c
   > > In articles <184@bu-cs.UUCP> bu-cs!bzs (Barry Shein) writes: > > ...
   > > Well, some compilers will dislike the attempt to cast a (char *) into
   > > a (int (*)()) ; in fact I think some will call it an outright error >
   > Jack Harkins (houxf!jph)
   > Huh???
   >
   > This line of code DOES NOT cast a char * into an int. It is declaring
   He did not say 'int'; look at that declaration again.
   > > because all programs are pure -- you can't goto/call data space, nor 
   > > can you read from the instruction stream.  Some sort of chastity belt
   > > in the hardware, I think.
   >
   > Whazat??
   True.  What he means is that you cannot generate code in some array, as 
   from an assembler built into your program, and then jump into it. I wrote
   a FORTH-like language, but I had to stick to using C functions for all 
   primitives because of that restriction.  It is not possible to assemble 
   new words into which one can transfer control.  One could set a pointer 
   to a function equal to the address of an array, but if you enter that 
   function, you go to that address in the instruction space, not in the 
   data space.
   --
      George Tomasevich, ihnp4!twitch!grt
      AT&T Bell Laboratories, Holmdel, NJ
EXT-aaz-8Q4N9 27-Feb-86 Re: Arcane C hacks?
   From: {Marc Mengel <aaz@PUCC-J.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-aaz-8Q4N9 / <857@pucc-j>
   Keywords: type casts,function pointers
   Posted: 27-Feb-86 09:48-PST  Received: 25-Mar-86 17:46-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 18:08:32 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002385; 2 Mar 86 20:47 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a005302; 2 Mar 86 6:01 EST
   Newsgroups: net.lang.c
             As far as I know, the following code is legal, and it works on 
      all the machines I have ever used.  It is not neccesarily portable 
      everywhere, since some machines may not like executing in the data 
      segment, but then again, if you are putting machine code in an array 
      and executing it, it isn't portable code in *any* case.
   char foo[BIGNUM];
   main()
   {
      int result;
      /* code to put machine code into foo[] */
      result = (* (int (*)()) foo)();
   }
   --
                                     Marc Mengel
   Uucp: { decvax, icalqa, ihnp4, inuxc, sequent, uiucdcs  
   }!pur-ee!pucc-j!aaz { decwrl, hplabs, icase, psuvax1, siemens, ucbvax 
   }!purdue!pucc-j!aaz
   USnail: 910 N. 9th street
      Lafayette IN 47904
EXT-colin-vu-vlsi-uucp-8Q4NO 26-Feb-86 No. of elements in initialized array
   From: {Colin Kelley <colin%vu-vlsi.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-colin-vu-vlsi-uucp-8Q4NO / <250@vu-vlsi.UUCP>
   Keywords: sizeof, struct
   Posted: 26-Feb-86 10:17-PST  Received: 25-Mar-86 17:46-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 18:14:17 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002394; 2 Mar 86 20:48 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a005409; 2 Mar 86 6:08 EST
   Newsgroups: net.lang.c
   We've got some code that looks like: (somewhat simplified here)
   struct termentry {
           char name[MAX_ID_LEN];          /* name of graphics driver */
           unsigned int xmax,ymax;         /* screen dimensions */
   } term_tbl[] = {
           {"hp",    HP_XMAX,    HP_YMAX},
      {"regis", REGIS_XMAX, REGIS_YMAX},
           {"tek",   TEK_XMAX,   TEK_YMAX}
   };
   This code takes advantage of the C compiler's ability to count the number
   of initializers for term_tbl[], and automatically dimension term_tbl[] to
   that size.  However, code that must look at term_tbl[] needs to know how 
   many elements it has.  The solution we're using now is:
   #define TERMCOUNT (sizeof(term_tbl)/sizeof(struct termentry))
   This works fine on both our Pyramid and our Vaxen.  BUT...is this the 
   preferred technique?  Isn't it possible on some machines that the structs
   may have to be padded out to some arbitrary word boundary or something in
   order to fit efficiently into the array (and thus sizeof(term_tbl) may 
   not be an integer multiple of sizeof(struct termentry))?  Or will C 
   compilers guarantee that that any necessary padding will be included in 
   sizeof(struct)?
   I assume this must be a pretty common problem.  I hope someone out there 
   can tell me whether our code is ok as is, or if I've overlooked some 
   obvious solution...Thanks!
                           -Colin Kelley  ..!{psuvax1,pyrnj}!vu-vlsi!colin
EXT-kwh-bentley-uucp-8Q4NL 28-Feb-86 Re: Arcane C hacks?
   From: {KW Heuer <kwh%bentley.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-kwh-bentley-uucp-8Q4NL / <601@bentley.UUCP>
   Posted: 28-Feb-86 05:15-PST  Received: 25-Mar-86 17:46-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 18:14:46 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002414; 2 Mar 86 20:49 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a005631; 2 Mar 86 6:24 EST
   Newsgroups: net.lang.c
   This is a re-post; my apologies if you get it twice.
   [ bu-cs!bzs (Barry Shein) ]
   >> >declare a table something like:   int (*funtable[MAXFNS])() ; >> >and
   just malloc the storage for the generated code.  ...  It should be >> 
   >quite portable (code generator aside) and is legal C.
   [ bentley!kwh (Karl Heuer) ]
   >> Well, some compilers will dislike the attempt to cast a (char *) into 
   >> a (int (*)()) ; in fact I think some will call it an outright error
   [ houxf!jph (Jack Harkins) ]
   >Huh???  This line of code DOES NOT cast a char * into an int.... >I have
   programs that use pointers to functions, some that run on 3B2/5's.
   Sorry, you seem to have lost the context.  The original poster wanted to 
   malloc space for the CODE ITSELF, not the pointer table; i.e. do 
   something like
      funtable[0] = (int (*)())malloc(codesize);
   and this line _does_ cast a (char *) (which is what malloc() returns) 
   into a function pointer.  (Actually a more likely sequence is
      char *s = malloc(codesize);
      s[0] = CLRW;  s[1] = R0;
      funtable[0] = (int (*)())s;
      n = (*funtable[0])();
   or something like that.)
   [ bentley!kwh (Karl Heuer) ]
   >> because all programs are pure -- you can't goto/call data space, nor 
   >> can you read from the instruction stream.  Some sort of chastity belt 
   >> in the hardware, I think.
   [ houxf!jph (Jack Harkins) ]
   >Whazat??
   >
   >MOST(not all) programs are pure in this environment, yes.  But that has 
   >nothing to do with being able to use a pointer to a function.  The code 
   >that is executed is actually in the shared text region; it is only the 
   >pointer to the function that is in the data area.
   When I said "all programs are pure", I meant that on the 3b2 it is _not_ 
   _possible_ to write an impure program (as far as I can determine).  The 
   code fragment above can be made to work on a VAX (even without "ld -N"), 
   but on the 3b2 it dies with a bus error.  I hope I've cleared this up.
   To any would-be flamers: the alignment is appropriate; the bus error 
   occurs on the CALL instruction; don't flame me about what I'm "clearly" 
   doing wrong unless you can demonstrate a way to do it right.  On a 3b2. 
   I've already checked things pretty carefully, including the source code 
   in the kernel.
EXT-rwl-uvacs-uucp-8Q4NU 25-Feb-86 Re: Re: Compaction Algorithm (pack vs 
compress)
   From: {Ray Lubinsky <rwl%uvacs.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-rwl-uvacs-uucp-8Q4NU / <226@uvacs.UUCP>
   Posted: 25-Feb-86 12:09-PST  Received: 25-Mar-86 17:46-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 18:20:04 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002429; 2 Mar 86 20:50 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a005962; 2 Mar 86 6:47 EST
   Newsgroups: net.lang.c,net.unix
   Xref: seismo net.lang.c:8157 net.unix:7606
   > > I am in need of a packing algorithm which works better than the > > 
   PACK Utility of UNIX.  I have also looked at COMPRESS ( developed > > at 
   University of Utah ).  COMPRESS works great if distinct number > > of 
   input bytes is small.  But if the distinct input bytes reach > > 256 ( 
   binary data ), PACK works better than COMPRESS.  With PACK > > I am 
   getting a saving of 20-25%.  If anybody has an algorithm > > that would 
   do better in packing "load modules", I would like to > > know about it.
   >
   > Are you sure you have the latest version of "compress"?  I tried 
   "pack"ing > and "compress"ing "/usr/bin/suntools" (which is a BMF 
   executable image) and > "compress" did significantly better than "pack" 
   did (it took significantly > more time doing it, but that's life).  
   Remember, Lempel-Ziv compression will > discover frequently-occurring 
   sequences of bytes, and unless your machine > has all one-byte 
   instructions you're likely to get some multi-byte sequences > occurring 
   frequently.
   > --
   >         Guy Harris
   >         {ihnp4, decvax, seismo, decwrl, ...}!sun!guy
   >         guy@sun.arpa    (yes, really)
   Hold on thar, Babaloo!  If you mean better in terms of *byte* savings, I 
   imagine ``compress'' could easily do better than ``pack''.  But if you're
   talking about *block* savings, I'm dubious that ``pack'' will be much 
   improved upon.  I don't know about your system, but my Vax running 4.2 
   BSD permits internal fragmentation, so it's disk block savings that 
   count.
   Now, I'm not entirely familiar with ``compress'', but I can compare with 
   ``compact''.  When I created a file of 2000 bytes (one identical 
   character per line plus a newline), ``compress'' boasted of > 85% 
   compression, while pack only claimed 50% compression, but each of the 
   results consumed the same amount of blocks.  Hence the same effective 
   compression.
   Sqeezing a few extra bytes out of a file can only be worth it if it 
   results in reducing by the 1K minimum data block size (2 basic file 
   system blocks).  Is this often the case?  (On my system, ``pack'' runs 
   considerably faster than ``compact'', so the choice is easy.)
   --
   Ray Lubinsky      University of Virginia, Dept. of Computer Science
      UUCP: ...!cbosgd!uvacs!rwl or ...!decvax!mcnc!ncsu!uvacs!rwl
EXT-davidsen-steinmetz-u-8Q4O3 27-Feb-86 Re: Stack Frames
   From: {Davidsen <davidsen%steinmetz.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-davidsen-steinmetz-u-8Q4O3 / <666@steinmetz.UUCP>
   Posted: 27-Feb-86 11:22-PST  Received: 25-Mar-86 17:46-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 18:23:20 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002438; 2 Mar 86 20:51 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a005974; 2 Mar 86 6:47 EST
   Newsgroups: net.lang.c
   In article <289@hropus.UUCP> ka@hropus.UUCP (Kenneth Almquist) writes: 
   >>> If your C compiler generates additional overhead for local >>> 
   blocks, it is not very good.  Most reasonable implementations >>> reserve
   enough stack at function entry for the deepest local >>> block nesting 
   within the function, so that there is no >>> run-time action required 
   upon entering a local block. [DAGWYNN] >>
   >> Not only `not very good' but seemingly impossible. If a separate >> 
   stack frame [were] created, access to arguments would be different >> 
   within the new block. Still doable, but now try jumping in or
   >> out of the block. Getting Hairy!               [COTTRELL]
   >
   >There is at least one compiler out there for which does this.  I know 
   >because I got a bug report on vnews concerning a piece of code where >I 
   jumped into the middle of a block. ...
   On machines which do not have stack hardware, C may be implemented by 
   using offsets to a register, since all offsets can be calculated at 
   compile time. I first saw this in the "B" compiler for GE600 (Honeywell 
   6000/DPS) systems in about 1970.
   On entry to a procedure a register pointed to the return, arguments were 
   offsets in one direction, and local variables were offsets in the other. 
   The allocation consisted of assuming a larger number for "bytes in use" 
   when entering the inner block. There is nothing faster at runtime than an
   assumption made at compile time... no code, no overhead.
   Point of allocation becomes important when variables are initialized, 
   since in C it happens when the space is allocated (by this I mean that 
   static variables are allocated at link time and initialized then, once, 
   while auto variables are allocated and initialized on entry to a block.
   If the variables are allocated on entry to the procedure (which means 
   that all inner block variables are taking stack space at once), the code 
   to initialize them still has to be at the head of the inner block. 
   Allocating inner block variables at procedure entry will save space/time 
   on many machines, while allocating them at block entry will save stack 
   space. --
      -bill davidsen
      seismo!rochester!steinmetz!--\
          /                               \
   ihnp4!              unirot ------------->---> crdos1!davidsen
          \                               /
           chinet! ---------------------/        (davidsen@ge-crd.ARPA)
   "It seemed like a good idea at the time..."
EXT-greenberg-calgary-uu-8Q4OC 27-Feb-86 C cross compiler to Data general 
Nova assembly lang. wanted
   From: {Saul Greenberg <greenberg%calgary.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-greenberg-calgary-uu-8Q4OC / <184@calgary.UUCP>
   Posted: 27-Feb-86 07:57-PST  Received: 25-Mar-86 17:46-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 18:28:13 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002450; 2 Mar 86 20:52 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a006207; 2 Mar 86 6:59 EST
   Newsgroups: net.wanted.sources,net.lang.c
   Xref: seismo net.wanted.sources:2092 net.lang.c:8160
   Looking for a C cross-compiler, running on Vax under Unix, with target 
   language Data General Nova assembly or machine code. Reply by net mail or
   by surface mail to:
   Saul Greenberg
   Dept of Computer Science
   University of Calgary
   Calgary, Alberta
   Canada T2N 1N4
   tel 403-220-6786
EXT-chris-umcp-cs-uucp-8Q4OP 28-Feb-86 Re: Long Longs
   From: {Chris Torek <chris%umcp-cs.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-chris-umcp-cs-uucp-8Q4OP / <3408@umcp-cs.UUCP>
   Posted: 28-Feb-86 18:36-PST  Received: 25-Mar-86 17:46-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 18:32:45 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002460; 2 Mar 86 20:53 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a006458; 2 Mar 86 7:10 EST
   Newsgroups: net.lang.c
   In article <491@faron.UUCP> bs@faron.UUCP (Bob Silverman) writes:
   >Does anyone have a good solution [to getting (b*c)/d and (b*c)%d >done 
   with double-length instructions]?
   and also mentions that one can
   >write an assembler routine to do such arithmetic.  However, if one >does
   such computations frequently (e.g. millions of times) the cost >of 
   calling a routine to do it is prohibitive.
   One method, used in the 4BSD kernel and in Franz Lisp, is to write a 
   `sed' script, and run the output of the compiler through this. Thus what 
   looks like a function call is actually expanded in-line:
      # foo.e - sed script to expand various routines in line #
     # Usage: /lib/cpp file.c | /lib/ccom | sed -f foo.e | /lib/c2 | \
     #       as -o file.o
   # (or use .s files if your `as' cannot read pipes). #
   # Change calls to `foo' to a `bar' instruction.
   # Foo takes two arguments and presents a return
   # value in r0.
     /calls  $2,_foo/s//movl (sp)+,r0\
             movl    (sp)+,r1\
             bar     r1,r0/
   This costs a few redundant stack operations; these can be avoided by 
   using the 4.3BSD `inline' program---if you have it---in place of sed.
   --
   In-Real-Life: Chris Torek, Univ of MD Comp Sci Dept (+1 301 454 1415)
   UUCP:     seismo!umcp-cs!chris
   CSNet:    chris@umcp-cs           ARPA:   chris@mimsy.umd.edu
EXT-guy-sun-uucp-8Q4OS 28-Feb-86 Re: Re: Compaction Algorithm (pack vs 
compress)
   From: {Guy Harris <guy%sun.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-guy-sun-uucp-8Q4OS / <3302@sun.uucp>
   Posted: 28-Feb-86 19:50-PST  Received: 25-Mar-86 17:46-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 18:35:56 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002469; 2 Mar 86 20:54 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a008521; 2 Mar 86 10:26 EST
   Newsgroups: net.lang.c,net.unix
   Xref: seismo net.lang.c:8167 net.unix:7612
   > Hold on thar, Babaloo!  If you mean better in terms of *byte* savings, 
   I > imagine ``compress'' could easily do better than ``pack''.  But if 
   you're > talking about *block* savings, I'm dubious that ``pack'' will be
   much > improved upon.  I don't know about your system, but my Vax running
   4.2 BSD > permits internal fragmentation, so it's disk block savings that
   count.
   1) I assume you "don't know about (my) system" because your news reading 
   program doesn't display the "Organization:" line.  FYI, as it's sent out 
   from this site, it's "Sun Microsystems, Inc."  I'm sure you can figure 
   out what system my machine is running from that.
   2) Most operating systems do internal fragmentation.  It's hardly 
   specific to VAXes running 4.2BSD.  Even <SPOILER WARNING> Suns running 
   4.2BSD do it. (It's also hardly a question of "permitting" internal 
   fragmentation.  It's not as if UNIX gives you a choice.  If you don't 
   want internal fragmentation, you phave to put several files together into
   something like an "ar" or "tar" archive".)
   > Now, I'm not entirely familiar with ``compress'', but I can compare 
   with > ``compact''.  When I created a file of 2000 bytes (one identical 
   character > per line plus a newline), ``compress'' boasted of > 85% 
   compression, while > pack only claimed 50% compression, but each of the 
   results consumed the same > amount of blocks.  Hence the same effective 
   compression.
   Big deal.  A 2000-byte file is two 1K frags.  The person was asking about
   "load modules", by which I presume he means executable images.  
   "/bin/cat" is 24 1K frags on my system ("'cat -v' considered harmful" 
   flames to /dev/null, please, I'm just reporting the facts).  They were 
   probably interested in compressing large executable images, so the 
   internal fragmentation is probably a very small percentage of the file 
   size, and thus the savings in blocks is infinitesimally different from 
   the savings in bytes.
   OK, let's terminate the debate with some hard data:
   Original file:
    664 -rwxr-xr-x  1 root       671744 Feb 19 12:25 /usr/bin/suntools
   "pack":
    520 -rwxr-xr-x  1 guy        519660 Feb 28 18:33 suntools.z
   pack: suntools: 22.6% Compression
   real      1m2.98s
   user      0m46.00s
   sys       0m12.91s
   "compact":
    520 -rwxr-xr-x  1 guy        519916 Feb 28 18:55 suntools.C
   suntools:  Compression :   22.60%
   real      16m17.15s
   user      12m44.50s
   sys       0m15.15s
   "compress":
   suntools: Compression: 43.18% -- replaced with suntools.Z
   real      1m39.90s
   user      1m25.65s
   sys       0m4.63s
    384 -rwxr-xr-x  1 guy        382395 Feb 28 18:36 suntools.Z
   It seems "compress" really does provide a significant improvement on the 
   *block* usage of the file in question, however "dubious" you may be of 
   those results.  "compact" and "pack" get results which are infinitesmally
   different.
   BTW, I tried "compress", "compact", and "pack" on a 2048-byte file in the
   exact same format you describe.  "compress" reported a 95% compression, 
   "compact" reported an 81% compression, and "pack" reported an 81% 
   compression.  All three reduced the file from two frags to one.  I then 
   tried it on a 2000-byte file in the format you describe, and got the 
   exact same results as on the 2048-byte file.  Your numbers look flaky.
   > Sqeezing a few extra bytes out of a file can only be worth it if it 
   results > in reducing by the 1K minimum data block size (2 basic file 
   system blocks). > Is this often the case?
   Yes, even on 2000-byte files consisting of 1000 identical lines.
   > (On my system, ``pack'' runs considerably faster than ``compact'', so 
   the > choice is easy.)
   Since "pack" also gives results which are as good as those "compact" 
   gives, the choice is *very* easy unless you need something which makes 
   only one pass over its input (e.g. because it's reading from a pipe), in 
   which case "pack" won't cut it.  "compress" is only a small amount slower
   than "pack" in CPU usage (at least when compared to the speed difference 
   between "pack" and "compact"), gives much better results than "pack" or 
   "compact", and makes only one pass over its input.  The only disadvantage
   is that it tends to eat virtual (and physical) memory; as Peter Honeyman 
   once put it, "more than two compresses makes disks dance!"  I don't care,
   since my machine is a one-user machine, but on a multi-user machine this 
   may make a difference. I'm also not sure whether the latest "compress" 
   uses memory that freely. --
      Guy Harris
      {ihnp4, decvax, seismo, decwrl, ...}!sun!guy
     guy@sun.arpa    (yes, really)
EXT-larry-cca-uucp-8Q4OY 28-Feb-86 Re: Arcane C hacks?
   From: {Laurence Schmitt <larry%cca.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-larry-cca-uucp-8Q4OY / <6441@cca.UUCP>
   Posted: 28-Feb-86 04:53-PST  Received: 25-Mar-86 17:46-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 18:39:16 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002527; 2 Mar 86 21:11 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a008666; 2 Mar 86 10:37 EST
   Newsgroups: net.lang.c
   >
   > 2)  Is there a machine independent way to coerce non-pointer-
   >     to-function values to pointer-to-function values?
   >
   Considering that the program in question would be generating machine code
   on the fly, an extremely machine *dependent* operation, it seems curious 
   to complain that the jump operation itself cannot be made machine 
   independent! :-)
   --
   Larry Schmitt                     Computer Corporation of America
   larry@cca                         4 Cambridge Center
   decvax!cca!larry          Cambridge, MA 02142
                             (617)-492-8860
EXT-g-rh-cca-uucp-8Q4P4 28-Feb-86 Re: Re: Compaction Algorithm (pack vs 
compress)
   From: {Richard Harter <g-rh%cca.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-g-rh-cca-uucp-8Q4P4 / <6448@cca.UUCP>
   Posted: 28-Feb-86 20:06-PST  Received: 25-Mar-86 17:46-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 18:42:03 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002542; 2 Mar 86 21:12 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a008674; 2 Mar 86 10:38 EST
   Newsgroups: net.lang.c,net.unix
   Xref: seismo net.lang.c:8170 net.unix:7613
   Just a note on packing.  Recently people in one of the newsgroups were 
   speculating about one character predictor packing.  We implemented it and
   found that it works as well as pack (for text files).  The idea is that 
   you make a first pass through the file and determine, for each character,
   its most probable successor.  You make a second pass through the file and
   record one bit for each character, F if the character is not followed by 
   its most probable successor, and T if it is.  You also record the 
   incorrect guesses.  You store the file as a bit array followed by the 
   wrongly predicted characters.  The point of these shenanigans is that the
   unpacking is fast.  In our context the determination of the predicted 
   characters only has to be done once so packing is also fast.  Our results
   are that this style of packing is as efficient as PACK for source code 
   and English text.  The bit array is an automatic 12.5% penalty.  
   Prediction rate is around 50% for source code (depending on language and 
   style -- higher for operating systems that store files with trailing 
   blanks in fixed records).  Not bad for quick and dirty.  However it is of
   no use for object code.
      Richard Harter, SMDS Inc.
EXT-greg-utcsri-uucp-8Q4Q4 24-Feb-86 Re: Fork and Execl
   From: {Gregory Smith <greg%utcsri.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-greg-utcsri-uucp-8Q4Q4 / <2190@utcsri.UUCP>
   Posted: 24-Feb-86 14:01-PST  Received: 25-Mar-86 17:46-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 19:00:12 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002571; 2 Mar 86 21:17 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a009332; 2 Mar 86 11:17 EST
   Newsgroups: net.lang.c
   In article <868@umd5.UUCP> don@umd5.UUCP writes:
   >The question is:
   >After issuing the fork(), I know the parent process gets the pid of the 
   >child, and the child is a copy of the parent process, but where does the
   >execution of the child process continue from ?
   From the stork process, of course.
EXT-cim1-pyuxv-uucp-8Q4QD 24-Feb-86 K&R is not the bible
   From: {"G. Bogatko" <cim1%pyuxv.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-cim1-pyuxv-uucp-8Q4QD / <180@pyuxv.UUCP>
   Posted: 24-Feb-86 16:32-PST  Received: 25-Mar-86 17:46-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 19:05:19 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002602; 2 Mar 86 21:20 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a011462; 2 Mar 86 15:01 EST
   Newsgroups: net.lang.c
      There is an awful lot of refering to K&R as if it were a bible of C 
      syntax.  Now I will admit that It contains an awful lot about what C 
      is, and that it was authored by the guy that invented the language, 
      but listen folks, it was written in 1978, and we just can't keep 
      thinking that C begins and ends with K&R.
     For example, if I call a compiler company and ask them if their 
   compiler supports enums and structure passing, I will most likely get the
   answer,
      "Well, that sort of stuff is not K&R, so we don't do it."
   Well, it might not be K&R, but it IS legal C. Not only that but it's been
   around since 1978.  Listen to the Seventh Edition UNIX Manual (if UNIX C 
   isn't a benchmark, then what is?)
      Page 277:
                     Recent Changes to C
                      November 15, 1978
   A few extensions have been made to the C language beyond what is 
   described in the reference document("The C Programming Language," 
   Kernighan and Ritchie, Prentice-Hall, 1978)
   1. Structure assignment
      Structures may be assigned, passed to functions, and returned by 
      functions.
   2. Enumeration type
      There is a new data type analogous to the scalar types of Pascal. 
      [continues with a description of enums]
   ***********************
   I've been told, but I haven't personally seen it, that Ritchie brought 
   out a new version of the reference manual in 1980 that included struct 
   passing and enums.
   You can't tell me that 8 years is not enough time for this kind of change
   to get out. (I know, Microsoft 3.0 C does it, and I think also CI, but 
   this is only recently).
   Enough then.  K&R is OLD.  It is NOT the alpha and omega of C. When I 
   want to see what C is doing NOW, I refer to books that are more 
   contemporary.
   ***********************
   K&R:      "In evalulating a[i], C converts it to *(a+i) immediately"
   Therefore, is a[x] the same as x[a]?  It is on UNIX C and AZTEC C. It 
   isn't on MICROSOFT C.  Try this on your compiler:
   #include <stdio.h>
   main()
   {
   static char a[] = "abcdefg";
      putchar(a[3]);
      putchar(3[a]);
     putchar("xyzq1234"[4]);         /* does this work on your compiler? */
     putchar(4["xyzq1234"]);         /* does this? */
                                     /* they work on UNIX */
   }
   What is the standard here?
   If K&R doesn't mention this kind of thing specifically, does it mean that
   the implementations that allow it are wrong?  How about the ones don't 
   allow it. Are they wrong too?
   G. Bogatko
EXT-greg-utcsri-uucp-8Q4QJ 24-Feb-86 Re:  type cast in initializer
   From: {Gregory Smith <greg%utcsri.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-greg-utcsri-uucp-8Q4QJ / <2189@utcsri.UUCP>
   Posted: 24-Feb-86 13:54-PST  Received: 25-Mar-86 17:46-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 19:07:51 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002558; 2 Mar 86 21:15 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a009328; 2 Mar 86 11:17 EST
   Newsgroups: net.lang.c
   >> >The values of '\377' and -1 are one and the same without a type cast.
   I have lost of track of who originally said that, but it is presented as 
   evidence that '\377' ( or any char constant, e.g. 'x' ) is of type (int),
   not of type (char). This is not evidence though, since
     int x;   x = 'a';
   will convert 'a' to (int) if it was not already, before assigning. This 
   includes sign extending if that is the convention on your system. The 
   same
   applies to   func('x') and  case '\300':. Thus the equality between
   -1 and '\377' does not mean that they are both int's. The only way to 
   tell is to do a sizeof('x'), which is 1 if 'x' is (char) and 2 or 4 or ..
   if 'x' is int.
   Having said this, I will add that char constants are in fact of type 
   (int), which can be verified by the above test. ( I speak for 4.2BSD).
   Greg Smith
   University of Toronto
EXT-throopw-dg-rtp-uucp-8Q4QP 23-Feb-86 Re:  type cast in initializer :-)
   From: throopw%dg_rtp.uucp@BRL.ARPA
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-throopw-dg-rtp-uucp-8Q4QP / <180@dg_rtp.UUCP>
   Posted: 23-Feb-86 17:55-PST  Received: 25-Mar-86 17:46-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 19:11:09 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002621; 2 Mar 86 21:22 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a011537; 2 Mar 86 15:06 EST
   Newsgroups: net.lang.c
   >>> The values of '\377' and -1 are one and the same without a type cast.
   >> Yes---*if* your machine has signed `char's.
   > AND if your machine has eight-bit bytes...
   AND two's complement arithmetic,
   AND the phase of the moon is right,
   AND the gods are properly propiciated,
   AND the keyboard is anointed with the blood of three chickens, AND you 
   dance around your terminal widdershins,
      (Maybe it would be simpler to just say that '\377' is some 
      implementation-defined value of type integer??? Nyeah!  Couldn't be!)
   AND the south pole of Uranus points towards the sun. AND ...
   And now we can start a long and fulfilling discussion about what '\377' 
   and -1 are *with* typecasts!  Wouldn't that be lovely?  Hmmmmm? --
   Wayne Throop at Data General, RTP, NC
   <the-known-world>!mcnc!rti-sel!dg_rtp!throopw
EXT-wrs-pupthy-uucp-8Q4QS 1-Mar-86 Re: Re: Compaction Algorithm (pack vs 
compress)
   From: wrs%pupthy.uucp@BRL.ARPA
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-wrs-pupthy-uucp-8Q4QS / <51@pupthy.UUCP>
   Posted:  1-Mar-86 09:43-PST  Received: 25-Mar-86 17:46-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 19:12:27 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002581; 2 Mar 86 21:18 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a009388; 2 Mar 86 11:22 EST
   Newsgroups: net.lang.c,net.unix
   Xref: seismo net.lang.c:8181 net.unix:7620
   In article <226@uvacs.UUCP> rwl@uvacs.UUCP (Ray Lubinsky) writes:
   (On the relative merits of pack/compact/compress...)
   > Hold on thar, Babaloo!  If you mean better in terms of *byte* savings, 
   I > imagine ``compress'' could easily do better than ``pack''.  But if 
   you're > talking about *block* savings, I'm dubious that ``pack'' will be
   much improved > upon.  I don't know about your system, but my Vax running
   4.2 BSD permits > internal fragmentation, so it's disk block savings that
   count. >
   > Now, I'm not entirely familiar with ``compress'', but I can compare 
   with > ``compact''.  When I created a file of 2000 bytes (one identical 
   character > per line plus a newline), ``compress'' boasted of > 85% 
   compression, while > pack only claimed 50% compression, but each of the 
   results consumed the same > amount of blocks.  Hence the same effective 
   compression. >
   > Sqeezing a few extra bytes out of a file can only be worth it if it 
   results in > reducing by the 1K minimum data block size (2 basic file 
   system blocks). ...
   The above comments are pretty much true.  Since disk space is allocated 
   in integral block chunks, reducing the size of a file below the minimal 
   disk storage size does nothing much for you.  I.E. a 2056 byte file and 
   its packed 1378 byte (say) compressed version both take 2k of physical 
   disk space. (Although why you would want to compress a 2k file for other 
   than test purposes, I don't know.)
   However, if the file size is sufficiently large, the "file blocking" 
   becomes pretty much irrelevant.  We have been using compress to reduce 
   the size of some of our data file, which have had sizes up to 100Mb (Yes,
   Mega-bytes!)
   Tests run on our Ridge (disk blocks = 4k) gave the following results:
   3Mb data file (text):
      Original:      3956579b ==> 966 blocks
      Compress:       759914b ==> 186 blocks = 81% compression        157.0 
      cpu sec Compact:       2002303b ==> 489 blocks = 49% compression       
      1452.0 cpu sec
       Pack: 1998736b ==> 488 blocks = 49% compression         98.7 cpu sec
   100kb executable (stripped):
      Original:       186960b ==>  46 blocks
       Compress:       87005b ==>  22 blocks = 52% compression          9.5 
   cpu sec
       Compact:       126561b ==>  31 blocks = 33% compression         88.5 
   cpu sec
       Pack:  126437b ==>  31 blocks = 33% compression          4.9 cpu sec
   (I would have tried one of our 100Mb files, but didn't have one around)
   ------------------------------------------------------------------------
   William R. Somsky                          Physics Dept ; Princeton Univ
   {ihnp4,princeton}!pupthy!wrs             PO Box 708 ; Princeton NJ 08544
EXT-jph-houxf-uucp-8Q4QY 25-Feb-86 Re: Arcane C hacks?
   From: {"J.HARKINS" <jph%houxf.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-jph-houxf-uucp-8Q4QY / <1067@houxf.UUCP>
   Posted: 25-Feb-86 16:47-PST  Received: 25-Mar-86 17:46-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 19:15:59 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002678; 2 Mar 86 21:37 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a012255; 2 Mar 86 15:53 EST
   Newsgroups: net.lang.c
   > In articles <184@bu-cs.UUCP> bu-cs!bzs (Barry Shein) writes: > >declare
   a table something like:   int (*funtable[MAXFNS])() ; > >and just malloc 
   the storage for the generated code.  ...  It should be > >quite portable 
   (code generator aside) and is legal C. >
   > Well, some compilers will dislike the attempt to cast a (char *) into >
   a (int (*)()) ; in fact I think some will call it an outright error
   Huh???
   This line of code DOES NOT cast a char * into an int. It is declaring 
   that funtable is an array of MAXFNS elements, each of which is a pointer 
   to a function that returns a int value.
   > (not just a warning).  But in any case it is _not_ portable to the 3b2,
   BOLDERDASH!!!
   I have programs that use pointers to functions, some that run on 3B2/5's.
   The construct is totally(no flames, please) portable.  As a matter of 
   fact I have used this type of construct to allow emulation of UN*X signal
   processing on a non UN*X operating system that only allowed one routine 
   to be specified for all signals.
   > because all programs are pure -- you can't goto/call data space, nor > 
   can you read from the instruction stream.  Some sort of chastity belt > 
   in the hardware, I think.
   Whazat??
   MOST(not all) programs are pure in this environment, yes.  But that has 
   nothing to do with being able to use a pointer to a function.  The code 
   that is executed is actually in the shared text region; it is only the 
   pointer to the function that is in the data area.
   -------
   Disclaimer: I hereby disclaim all my debts.
   ------
   Jack Harkins @ AT&T Bell Labs
   Princeton Information
   (201) 949-3618
   (201) 561-3370
   houxf!jph
EXT-throopw-dg-rtp-uucp-8Q4R5 23-Feb-86 Re: Command line arguments, 
redirection, etc.
   From: throopw%dg_rtp.uucp@BRL.ARPA
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-throopw-dg-rtp-uucp-8Q4R5 / <179@dg_rtp.UUCP>
   Posted: 23-Feb-86 17:38-PST  Received: 25-Mar-86 17:47-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 19:18:38 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002636; 2 Mar 86 21:23 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a011542; 2 Mar 86 15:07 EST
   Newsgroups: net.lang.c
   [   Warning.  Some of my comentary below contains (gasp) Humorous
      Content.  In no way should the Mild Humor in this posting be confused 
      with Hurtful and Counterproductive Sarcasm. You have been Warned!  ]
   >   Hopefully, this "discussion" about argument passing, redirection, and
   > such can be put to rest once and for all.
   Close, but no cigar.
   > 1. Redirection of standard I/O is a part of C, piping is not.
   >    Ref: K&R, chapter 7
   >
   >    "Finally, the routines are meant to be 'portable', in the sense that
   >     they will exist *in compatible form* on any system where C 
   exists"...
   >
   >    The routines mentioned are those which use "standard I/O".  See page
   >    144... "output can be redirected to a file by using >...", and "On
   >    the UNIX system, a pipe can also be used..."  This implies that
   >    redirection is required functionality, whereas piping is a part of
   >    a particular operating system.
   Well, your heart's in the right place, you *do* got religion, but I don't
   think you've really imersed yourself in the Holy Texts.  In particular, 
   you missed the fact that on page 143, to introduce the whole chapter on 
   IO, The Book says
      And DMR created Facilities, Input and Output created He Them, And 
      these Facilities were separate from The Language of C,
   Oops, sorry, that was the King James version.
   Let me get my Modern Reformed copy...
      Input and output facilities are not part of the C language,
   Now, you can dismiss this by saying that in common usage the phrase "the 
   C language" refers to both the formal language definition *and* the 
   supporting libraries (at least stdio).  But worse yet (you heretic you), 
   you missed the quote just above the one you took from page 144:
      In most environments that support C, a file may be substituted for the
      terminal by using the < convention
   In particular, The Book says "most" (not "all") environments that support
   C, so it is *not* a requirement, merely a coincidence.  So, even if one 
   takes the standard IO libraries to be "part of the language", C doesn't 
   require "<>" style redirection any more than it requires the "|" piping 
   convention.
   > 2. Command-line arguments are a part of C.
   >    Ref: K&R, chapter 5.11
   >
   >    "In environments that support C, there is a way to pass command-line
   >     arguments or parameters to a program when it begins executing."
   Again, you don't catch on to the subtleties.  The phrase is "command-line
   arguments *or* parameters".  In fact, careful reading of K&R convinces me
   that C can be correctly implemented on systems that (shudder) *have* *no*
   *commands* *or* *command* *lines*, let alone "command-line arguments".  
   All that is nailed down is some way to pass text string parameters to 
   programs at execution time.  The method isn't spelled out, and in 
   particular it needen't be "commands" which have "arguments".
   > It sounds to me like this whole issue boils down to whether or not 
   someone > has taken the time to *correctly* implement C to provide the 
   functionality > as specified in K&R (or whatever else happens to be your 
   favorite standard).
   I guess I agree with that.
   > [ Personal opinion, FLAME ON ]
   >
   > Any implementation of C that doesn't provide redirection and 
   command-line > argument passing is half-assed at best.
   >
   > [ FLAME OFF]
   It may be half-assed, but it could still be a legal C implementation.
   > You know, I feel better already!  Hey kiddies, get out YOUR copy of K&R
   and > read, read, read!
   Good idea.  Try Harbison and Steele also.
   > -- Carl Kuck (apply all standard disclaimers to the preceeding babble)
   --
   (Gee, isn't being a language lawyer fun?  Just think what can be done 
   with interpreting ANSI C when it comes out!  Can you say "job security"? 
   I knew you could...)
   --
   Wayne Throop at Data General, RTP, NC
   <the-known-world>!mcnc!rti-sel!dg_rtp!throopw
EXT-danny-sftig-uucp-8Q4SK 25-Feb-86 integer division in ANSI C
   From: {"L.Rosler" <danny%sftig.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-danny-sftig-uucp-8Q4SK / <695@sftig.UUCP>
   Posted: 25-Feb-86 18:58-PST  Received: 25-Mar-86 17:47-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 19:43:38 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002687; 2 Mar 86 21:38 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a012352; 2 Mar 86 15:58 EST
   Newsgroups: net.lang.c
   There have been several thoughtful submissions on the subject of integer 
   division in C recently.  I think the ANSI X3J11 position should be 
   introduced into the discussion.
   This issue reveals the fundamental dichotomy in C -- between the 
   systems-programmers' language (replacing assembly language) and the 
   application-programmers' language (replacing FORTRAN or Pascal, say).
   System programmers really are not concerned about the behavior when a 
   negative number is involved.  Except perhaps for -1, negative numbers are
   considered harmful in this arena.  The goal of division is to get the 
   positive quotient or positive remainder as fast as the hardware can give 
   it, and this will always be hardware-independent.
   Application programmers, on the other hand, ARE concerned about portable 
   division involving negative numbers, a need which C does not address.  
   When this was discussed (at many Standards meetings), the following 
   positions emerged:
   1.  Ignore the problem -- reliable application programs are not 
   important.
   2.  Force the compiler to generate code to produce portable semantics -- 
   fast systems programs are not important.
   3.  Enrich the language by adding semantics to the new ``signed'' 
   keyword, which is at present redundant for int's.  This proposal would 
   also have solved the problem of reliable semantics for right-shifting of 
   negative int's.  It leads to 12 types of integers (``plain'', unsigned 
   and signed; char, short, ``plain'' and long) and runs slightly afoul of 
   the widening rules (signed char would widen to signed int, not ``plain'' 
   int).  It was defeated at two successive meetings by a very narrow vote, 
   and I have given up on it.
   4.  Enrich the language by adding new operators (// and %%) to signify 
   reliable signed division where desired.  (I tolerated this proposal until
   the // comment convention of C++ appeared.)
   5.  Enrich the library by adding functions that do reliable signed 
   division.  (Functions can be implemented as macros in ANSI C if 
   appropriate, because their names are reserved.) The functions invented 
   for this purpose are:
      typedef struct { int quot, rem; } idiv_t;
      idiv_t idiv(int numer, int denom);
   and
      typedef struct { long int quot, rem; } ldiv_t; ldiv_t ldiv(long int 
      numer, long int denom);
   The semantics are those of FORTRAN:  The sign of the quotient and 
   remainder are the same as the sign of the mathematical quotient.  The 
   behavior on exceptions such as overflow or divide-by-zero is undefined, 
   just like regular division. (Note that these are the only functions in 
   the library that return structs.)
   The functions were added last December, and could still be challenged. 
   Constructive comments on this "solution by committee" would be 
   appreciated, either on the Net or to me by e-mail.
   Larry Rosler, AT&T
   Editor, X3J11
   ihnp4!attunix!lr, 201-522-5086
EXT-kwh-bentley-uucp-8Q4SQ 26-Feb-86 Re: Arcane C hacks?
   From: {KW Heuer <kwh%bentley.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-kwh-bentley-uucp-8Q4SQ / <600@bentley.UUCP>
   Posted: 26-Feb-86 08:14-PST  Received: 25-Mar-86 17:47-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 19:47:09 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002696; 2 Mar 86 21:39 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a012537; 2 Mar 86 16:08 EST
   Newsgroups: net.lang.c
   [ bu-cs!bzs (Barry Shein) ]
   >> >declare a table something like:   int (*funtable[MAXFNS])() ; >> >and
   just malloc the storage for the generated code.  ...  It should be >> 
   >quite portable (code generator aside) and is legal C.
   [ bentley!kwh (Karl Heuer) ]
   >> Well, some compilers will dislike the attempt to cast a (char *) into 
   >> a (int (*)()) ; in fact I think some will call it an outright error
   [ houxf!jph (Jack Harkins) ]
   >Huh???  This line of code DOES NOT cast a char * into an int.... >I have
   programs that use pointers to functions, some that run on 3B2/5's.
   Sorry, you seem to have lost the context.  The original poster wanted to 
   malloc space for the CODE ITSELF, not the pointer table; i.e. do 
   something like
      funtable[0] = (int (*)())malloc(codesize);
   and this line _does_ cast a (char *) (which is what malloc() returns) 
   into a function pointer.  (Actually a more likely sequence is
      char *s = malloc(codesize);
      s[0] = CLRW;  s[1] = R0;
      funtable[0] = (int (*)())s;
      n = (*funtable[0])();
   or something like that.)
   [ bentley!kwh (Karl Heuer) ]
   >> because all programs are pure -- you can't goto/call data space, nor 
   >> can you read from the instruction stream.  Some sort of chastity belt 
   >> in the hardware, I think.
   [ houxf!jph (Jack Harkins) ]
   >Whazat??
   >
   >MOST(not all) programs are pure in this environment, yes.  But that has 
   >nothing to do with being able to use a pointer to a function.  The code 
   >that is executed is actually in the shared text region; it is only the 
   >pointer to the function that is in the data area.
   When I said "all programs are pure", I meant that on the 3b2 it is _not_ 
   _possible_ to write an impure program (as far as I can determine).  The 
   code fragment above can be made to work on a VAX (even without "ld -N"), 
   but on the 3b2 it dies with a bus error.  I hope I've cleared this up.
   To any would-be flamers: the alignment is appropriate; the bus error 
   occurs on the CALL instruction; don't flame me about what I'm "clearly" 
   doing wrong unless you can demonstrate a way to do it right.  On a 3b2. 
   I've already checked things pretty carefully, including the source code 
   in the kernel.
EXT-rwl-uvacs-uucp-8Q4T2 23-Feb-86 Targeting C for dedicated processors
   From: {Ray Lubinsky <rwl%uvacs.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-rwl-uvacs-uucp-8Q4T2 / <213@uvacs.UUCP>
   Posted: 23-Feb-86 09:59-PST  Received: 25-Mar-86 17:47-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 19:53:15 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002720; 2 Mar 86 21:41 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a013101; 2 Mar 86 16:41 EST
   Newsgroups: net.lang.c
   > >Any implementation of C that doesn't provide redirection and 
   command-line > >argument passing is half-assed at best.
   :
   > The above comment implies that a computer that doesn't have command > 
   lines and files "is half-assed at best".  Most of the computers one uses 
   > do not have these features.  For example, the computer in my VCR, my > 
   terminal, my microwave, my thermostat, etc.  I would be willing to bet > 
   that none of these is currently programmed in C, but it would be > 
   possible for C to be used.
   > --
   >     Barry Margolin
   No, I don't think that the above statement has any implication about 
   machines; just implementations of C.  Should we pare the language so it 
   will fit the lowest-common-denominator system?  I hope not; I program for
   time-sharing systems.  I've never written a microwave oven controller.
   And if you are developing oven controllers on time-sharing system 
   (certainly you're not going to develop them directly on the chip), do you
   really want a C compiler that breaks on almost every other program 
   written?
   It's one thing to avoid using features of C and its usual libraries for 
   the sake of a specific application, but it's another to kludge them back 
   in if they're not there.
   --
   Ray Lubinsky                 University of Virginia, Dept. of Computer 
   Science
                        UUCP: decvax!mcnc!ncsu!uvacs!rwl OR cbosgd!uvacs!rwl
EXT-rb-ccivax-uucp-8Q4TK 24-Feb-86 Re: casting structures
   From: {rex ballard <rb%ccivax.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-rb-ccivax-uucp-8Q4TK / <430@ccivax.UUCP>
   Posted: 24-Feb-86 10:46-PST  Received: 25-Mar-86 17:47-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 20:01:57 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002708; 2 Mar 86 21:40 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a012690; 2 Mar 86 16:17 EST
   Newsgroups: net.lang.c
   Well, another goofup!
   First of all, the example given was poor to say the least.  It certainly 
   did not illustrate the problem.  Your right, I've never used it, but I 
   have seen it.
   An example where casting was needed was this.
   #define EOR 0370
   char *x;
   if (*x<EOR)
   or
   #define EOR '\370'
   int *x;
   if (*x<EOR)
   (believe it or not, because of some #includes, both showed up in the same
   project, in fact, the definitions changed mid-project)
   guess what, the original compiler actually worked (gave the result 
   desired) with the second example and didn't work with:
   #define EOR '\370'        /* compiler treated like unsigned */
   char *x;
   if(*x<EOR)
   because of the nature of what was actually desired, the proper definition
   would have been.
   #define EOR (unsigned char)0370
   or
   #define EOR (unsigned char)'370'
   unsigned char x;
   if (*x<EOR)
   moral: when in doubt, cast  (the next guy might figure out what you want)
   Qualifier: the compiler that gave this problem accepted code which 
   contained so many syntax errors (missing semicolons...) that lint died 
   just looking at it.  (I think it was someone's kludge of bcpl or what 
   they thought C was before reading K&R :-)  It is a VERY OLD compiler.
   Please excuse problems in the code, these are just "off the cuff" 
   examples, written near the end of the lunch hour.
EXT-herndon-umn-cs-uucp-8Q4TR 22-Feb-86 Re: Arcane C hacks?
   From: herndon%umn-cs.uucp@BRL.ARPA
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-herndon-umn-cs-uucp-8Q4TR / <1700004@umn-cs.UUCP>
   Posted: 22-Feb-86 21:39-PST  Received: 25-Mar-86 17:47-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 20:05:52 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002758; 2 Mar 86 21:44 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a014061; 2 Mar 86 17:39 EST
   Newsgroups: net.lang.c
   Nf-ID: #R:umn-cs:-170000300:umn-cs:1700004:000:3238
   Nf-From: umn-cs!herndon    Feb 22 23:39:00 1986
   [Here, bugs, bugs, bugs!  Here, bu
      Hmmm.  Apparently my original posting wasn't too clear. Many responses
      were sent telling me that I should just use a switch statement, or an 
      array of pointers to functions. Somebody else mailed me a note telling
      me I should not put code into an array, but should use an assembler. 
      My original note explicitly mentioned the possibilities of using both 
      switch statements and pointers to functions, and I've had to make do 
      with these options.  Sigh.
      Let me restate my problem.  Suppose I have an interpreter, which 
      accepts input from a user.  Something like a BASIC (Ugh!) or Lisp 
      interpreter/compiler.  I wish to convert a statement that the user 
      enters into machine code, and be able to execute that machine code, 
      RIGHT THEN(!).  (I certainly don't wish to have to call an assembler 
      and a loader.)  This is perhaps a iffy operation, since some machines 
      will not allow the execution of data.
      Now, it is certainly not too difficult to generate my machine code and
      stick it into an array somewhere.  If I could simply jump to it, I'd 
      be very happy.  This I can do by creating an assembly language 
      procedure of one argument which jumps to the address given as the 
      argument.
   1)  Can I do this without the assembly language help?
      As a second alternative, I can put my machine code into an array, 
      place the address of that array into a union as an integer, and CALL 
      (not jump to!) the array by pulling the address out of the union as a 
      pointer to a function. This is somewhat ugly, since I don't know what 
      size a code address is, and C will NOT let me type cast an address 
      into a pointer to a function.  Therefore this CODE construct is not 
      portable.  (As I noted in my original article, I can generate code 
      from machine-dependent DATA tables by using ifdefs and includes, but 
      I'd like machine independent CODE.)  Further, many machines (for 
      instance, the VAX) insist on particular prologues and epilogues for 
      procedures which I have no interest in and do not wish to generate 
      code for.
   2)  Is there a machine independent way to coerce non-pointer- to-function
   values to pointer-to-function values?
      As a third alternative, definitely the least desirable from my 
      particular perspective, is to do the whole thing a "proper way".  I 
      should generate nice intermediate code, stuff it into an array, and 
      then write a routine to interpret the intermediate code.  Presumably 
      then I can use the switch statement everyone recommends to generate 
      the jump-tables to get to the code to interpret my intermediate code. 
      Slow. And I can't add new intermediate-opcodes without recompiling.
      The fourth alternative (another "proper way") is to generate arrays of
      pointers to functions for code, where the pointers point to real, live
      C functions.  Then, by stepping through the arrays and calling each 
      function pointed to, I can indirectly interpret my code. (Something 
      like a forth interpreter.)  Again, I can't add new 
      intermediate-opcodes without recompiling.  Sigh.
      Oh, well, it was a hack anyhow.  It was something that used to be 
      possible and had occasional application, and then was rudely snatched 
      away by "improvements" to C.  I think it predates the existence of 
      K&R's book.
                             Robert Herndon
EXT-holloway-drivax-uucp-8Q4TN 26-Feb-86 Re: a basic like gosub in C
   From: {Bruce Holloway <holloway%drivax.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-holloway-drivax-uucp-8Q4TN / <300@drivax.UUCP>
   Posted: 26-Feb-86 10:05-PST  Received: 25-Mar-86 17:47-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 20:03:26 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002749; 2 Mar 86 21:44 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a013664; 2 Mar 86 17:11 EST
   Newsgroups: net.lang.c
   In article <202@crunch.uucp> josh@crunch.uucp (Josh Siegel) writes: >In 
   basic there is a GOSUB routine that will push the current > position onto
   the stack and jump to another line.  Then, upon > hitting a return will 
   return to that place.  I wish to write > something like that in C that 
   will be movable between compilers.
   (Sorry I'm not sending MAIL... but it doesn't seem to work from "rn" 
   under the C shell....)
   You should use the setjmp() and longjmp() routines.
   Call setjmp with a implementation specific environment buffer. When a 
   longjmp is called with the same buffer, it returns from the setjmp with a
   return code. setjmp returns zero in a normal routine, or the longjmp 
   parameter if that's wwhere it came from. Hmmm.
      jmp_buf env;
      func(){
         :
         :
         if(setjmp(env)){
   /* Code executed when returning from LONGJMP */
      }
   :
   :
   longjmp(env,ret_code);
   }
   --
   +------------------------------------------------------------------------
   ----+ |Whatever I write are not the opinions or policies of Digital 
   Research, Inc.,|
   |and probably won't be in the foreseeable future.                        
      |
   +------------------------------------------------------------------------
   ----+
   Bruce Holloway
   ....!ucbvax!hplabs!amdahl!drivax!holloway
   (I'm not THAT Bruce Holloway, I'm the other one.)
EXT-daemon-8Q4U4 27-Feb-86 Redirection
   From: {John Williams 223-3402 <williams%kirk.dec@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-daemon-8Q4U4 / <1403@decwrl.DEC.COM>
   Sender: daemon@decwrl.ARPA
   Posted: 27-Feb-86 06:17-PST  Received: 25-Mar-86 17:47-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 20:11:28 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002787; 2 Mar 86 21:47 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a014477; 2 Mar 86 18:04 EST
   Newsgroups: net.lang.c
   For example, VMS has neither redirection nor pipelining. All this means 
   is that you have to open a file.
   #include <stdio.h>
   FILE *infile,*outfile;
   infile = fopen("file.in","r");
   outfile = fopen("file.out","w");
   .
   .
   .
   You can now use any stdio function by putting a f in front and adding the
   file pointer as the first argument.
   .
   .
   .
   fclose(infile);
   fclose(outfile);
      Sure, those *features* are missed a little bit, but I certainly 
      wouldn't call VMS half-assed. I simply takes a little more to get 
      around that *particular* problem. As a matter of fact, most VMS tools 
      don't bother with stdio at all, they use default filename extentions.
                                             John Williams
EXT-don-umd5-uucp-8Q4UG 27-Feb-86 Re: Fork and execl
   From: don%umd5.uucp@BRL.ARPA
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-don-umd5-uucp-8Q4UG / <874@umd5.UUCP>
   Posted: 27-Feb-86 15:09-PST  Received: 25-Mar-86 17:47-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  2 Mar 86 20:18:21 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a002767; 2 Mar 86 21:45 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a014174; 2 Mar 86 17:46 EST
   Newsgroups: net.lang.c
   Thanks to all who responded to my question. I've posted questions to the 
   net before (not net.lang.c), but never have I received responses of 
   quality in great quantity. Thanks again.
   A friend of mine was kind enough to lend me his copy of _Advanced UNIX 
   Programming_ by Marc J. Rochkind. Between the responses and the book, I'm
   sure I've got fork() figured.
   (I'm still waiting for the campus library to obtain copies of the books I
   requested from one of the other campuses.)
   --
   --==---==---==--
   ".. all mimsy were the borogoves .."
      ARPA: don@umd5.UMD.EDU
   BITNET: don%umd5@umd2
      UUCP: ..!{ seismo!umcp-cs, ihnp4!rlgvax }!cvl!umd5!don
   (NOTE: Please mail to  umcp-cs!cvl!umd5!don  NOT  umd5!cvl!umcp-cs!don)
   umcp-cs ::= mimsy.UMD.EDU | maryland.ARPA | umcp-cs.UUCP
EXT-ka-hropus-uucp-8Q5SF 1-Mar-86 Re: integer division in ANSI C
   From: {Kenneth Almquist <ka%hropus.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-ka-hropus-uucp-8Q5SF / <316@hropus.UUCP>
   Posted:  1-Mar-86 22:07-PST  Received: 25-Mar-86 17:47-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  3 Mar 86 06:30:46 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a004054; 3 Mar 86 9:25 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a018294; 2 Mar 86 21:57 EST
   Newsgroups: net.lang.c
   > This issue reveals the fundamental dichotomy in C -- between > the 
   systems-programmers' language and the application-programmers' > 
   language...
   Yes.  I've never understood why anybody would *want* to do applications 
   programming in C, but then I've never understood why people want to use 
   Fortran and Cobol either...
   The proposed functions will not fully solve the problem if C is used by 
   fallible programmers, but then only those of us who are perfect have any 
   business using a dangerous language like C anyway :-).  I would suggest 
   making the routines simpler to use by providing separate routines for 
   division and remainder, as this will encourage more people to use them 
   when necessary.  This would also mean that these routines could be 
   replaced with simple macros on machines that do division the Fortran way 
   (most of them).
   It would also be nice to have a modulo function.  In my view, this would 
   be more useful than a remainder function.
                             Kenneth Almquist
                             ihnp4!houxm!hropus!ka   (official name)
                             ihnp4!opus!ka           (shorter path)
EXT-henry-utzoo-uucp-8Q5T0 1-Mar-86 Re: Arcane C hacks?
   From: {Henry Spencer <henry%utzoo.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-henry-utzoo-uucp-8Q5T0 / <6449@utzoo.UUCP>
   Posted:  1-Mar-86 20:50-PST  Received: 25-Mar-86 17:47-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  3 Mar 86 06:39:18 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a004074; 3 Mar 86 9:27 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a018305; 2 Mar 86 21:58 EST
   Newsgroups: net.lang.c
   > 2)  Is there a machine independent way to coerce non-pointer-
   >     to-function values to pointer-to-function values?
   No, because on some machines they are very different animals:  a pointer 
   to a function is not necessarily a pointer to the bytes comprising its 
   code.  Some machines want a rather more elaborate structure, in which a 
   pointer to a function is a module identifier and a function-within-module
   identifier, and there is extra information somewhere that allows the 
   machine to interpret this.  Which leads to...
   > ...Further, many machines (for instance, the VAX) > insist on 
   particular prologues and epilogues for procedures > which I have no 
   interest in and do not wish to generate > code for.
   If you want to treat something as a function, you *must* observe the 
   conventions that your machine (and your compiler) want to see.  There is 
   no portable way around this.  In fact, there's no entirely portable way 
   to do what you want at all, because the basic nature of the conventions 
   (never mind the details of them!) is machine-dependent.  For example, 
   machines that use a module+function form of function pointer will need 
   some sort of module dictionary somewhere, which you're going to have to 
   build.  Some machines won't let you do what you want at all, in fact, 
   because on them, code is code and data is data and never the twain shall 
   meet.  (Examples:  a pdp11 running split-space; a segmented machine that 
   makes a distinction between code and data segments.) --
                             Henry Spencer @ U of Toronto Zoology
                             {allegra,ihnp4,linus,decvax}!utzoo!henry
EXT-gwyn-8Q5TY 2-Mar-86 Re:  Arcane C hacks?
   From: {Doug Gwyn (VLD/VMB) <gwyn@BRL.ARPA>}DDN
   To: herndon%umn-cs.uucp@BRL.ARPA
   Cc: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-gwyn-8Q5TY
   Posted:  2-Mar-86 18:56-PST  Received: 25-Mar-86 17:47-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  3 Mar 86 06:57:10 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a004091; 3 Mar 86 9:28 
   EST
   Received: from brl-vmb.arpa by SMOKE.BRL.ARPA id a018362; 2 Mar 86 22:04 
   EST
   I can think of two legal ways to implement the
      goto jumptab[i];
   idea in C, assuming you need the flexibility of reassigning the 
   destinations for each i:
   (1)  Use an array of jmpbufs, do something to get them initialized using 
   setjmp (that's the hard part), and longjmp to the correct jmpbuf array 
   member.
   (2)  Use an array of function pointers, initialize them as desired, and 
   call via the appropriate function array member (watch out that you don't 
   keep recursing deeper and deeper; it's probably best to have a common 
   return from the functions).
   I suspect that if we knew your intended application, better solutions 
   would be possible.  Just what do you think you need a jump table for?
EXT-gwyn-8Q5U1 2-Mar-86 Re:  No. of elements in initialized array
   From: {Doug Gwyn (VLD/VMB) <gwyn@BRL.ARPA>}DDN
   To: {Colin Kelley <colin%vu-vlsi.uucp@BRL.ARPA>}DDN
   Cc: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-gwyn-8Q5U1
   Posted:  2-Mar-86 22:21-PST  Received: 25-Mar-86 17:47-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  3 Mar 86 06:59:22 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a004154; 3 Mar 86 9:30 
   EST
   Received: from brl-vmb.arpa by SMOKE.BRL.ARPA id a020085; 3 Mar 86 1:30 
   EST
   > ...  However, code that must look at term_tbl[] needs to know how many 
   > elements it has.  The solution we're using now is: >
   > #define TERMCOUNT (sizeof(term_tbl)/sizeof(struct termentry)) >
   > This works fine on both our Pyramid and our Vaxen.  BUT...is this the 
   preferred > technique?  Isn't it possible on some machines that the 
   structs may have to > be padded out to some arbitrary word boundary or 
   something in order to fit > efficiently into the array (and thus 
   sizeof(term_tbl) may not be an integer > multiple of sizeof(struct 
   termentry))?  Or will C compilers guarantee that that > any necessary 
   padding will be included in sizeof(struct)?
   The padding is part of the "sizeof" the structure.
   #define   number_of_elements(array)       
   (sizeof(array)/sizeof(array)[0])
   This works unless your C compiler is badly broken.  (That CAN happen; not
   very long ago I had to use one that insisted that sizeof a string literal
   was equal to sizeof(char*).)
EXT-woody-Juliet-Caltech-8Q6PZ 3-Mar-86 Re: Command line arguments
   From: woody%Juliet.Caltech.Edu@cit-hamlet.ARPA
   To: info-c%Juliet.Caltech.Edu@cit-hamlet.ARPA
   Identifier: EXT-woody-Juliet-Caltech-8Q6PZ / 
   <860303102928.003@Juliet.Caltech.Edu>
   Comment: Antidisestablishmentarianism!!!!
   Posted:  3-Mar-86 10:31-PST  Received: 25-Mar-86 17:48-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  3 Mar 86 16:34:09 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a000360; 3 Mar 86 19:26 
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id a003462; 3 Mar 86 13:33 
   EST
   Received: from cit-hamlet.arpa by AOS.BRL.ARPA id a013350; 3 Mar 86 13:34
   EST
   Received: from Juliet.Caltech.Edu by Hamlet.Caltech.Edu with DECNET ;
     Mon, 3 Mar 86 10:31:44 PST
   >   [ Wayne Throop ]
   >>  [ Carl Kuck ]
   >>  2.  Command-line arguments are a part of C.
   >>      Ref: K&R, chapter 5.11
   >
   >   Again, you don't catch on to subtleties.  The phrase is
   >   "command-line arguments *or* parameters.  In fact, careful reading of
   >   K&R convinces me that C may be correctly implemented on systems that
   >   (shudder) *have* *no* *commands* *or* *command* *lines*, let alone
   >   "command-line arguments."
      Like the Macintosh, where (despite Apple Computers) C seems to be the 
      de-facto programming language.  Under the Finder (read: Shell), 
      running a program is done by double-clicking the icon representing the
      program with the mouse, and arguments may be passed by shift-clicking 
      the appropriate file icons before double-clicking the program icon.  
      Command lines?  What command lines?  Do you see any command lines?
         - William Woody
      NET  Woody%Romeo@Hamlet.Caltech.Edu
   USNAIL  1-54 Lloyd, Caltech / Pasadena, CA 91126
EXT-woody-Juliet-Caltech-8Q6R3 3-Mar-86 Integer Division
   From: woody%Juliet.Caltech.Edu@cit-hamlet.ARPA
   To: info-c%Juliet.Caltech.Edu@cit-hamlet.ARPA
   Identifier: EXT-woody-Juliet-Caltech-8Q6R3 / 
   <860303104736.004@Juliet.Caltech.Edu>
   Comment: NOTE:  The following message has no content at all.
   Posted:  3-Mar-86 10:50-PST  Received: 25-Mar-86 17:48-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  3 Mar 86 16:53:19 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a000435; 3 Mar 86 19:42 
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id a004337; 3 Mar 86 13:56 
   EST
   Received: from cit-hamlet.arpa by AOS.BRL.ARPA id a014785; 3 Mar 86 13:52
   EST
   Received: from Juliet.Caltech.Edu by Hamlet.Caltech.Edu with DECNET ;
     Mon, 3 Mar 86 10:51:02 PST
      After all is said and done about integer division, and even though it 
      is mathematically correct to have a%b >= 0 for all integers a and b, 
      than have -(a/b) = (-a)/b for all integers a and b; and even though I 
      have argued (rather long windedly, I confess) about the mathematical 
      correctness of a%b >= 0, I'm still going to write:
         c = a%b;
         if (c < 0) c += b;
      For there's no point in turning C into a language so big that I can't 
      remember how to program in it.
      Besides, I like the idea of C as being a small step above assembly 
      language; it makes all my code go very fast.  And as C is (more or 
      less) portable (or more so than [say] Pascal), I don't have to write 
      things three (or six or nine or a dozen) times (as you do in Pascal). 
      Let's try not to break this with the new ANSI standard; I like C the 
      way it is--fast, dirty, and (reasonably) portable.
         - William Woody
      NET  Woody%Romeo@Hamlet.Caltech.Edu
   USNAIL  1-54 Lloyd, Caltech / Pasadena, CA 91126
EXT-dat-chinet-uucp-8Q6RC 28-Feb-86 Wanted LINT for VMS
   From: {Dick Tusia <dat%chinet.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-dat-chinet-uucp-8Q6RC / <379@chinet.UUCP>
   Keywords: LINT, VMS
   Posted: 28-Feb-86 09:58-PST  Received: 25-Mar-86 17:48-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  3 Mar 86 16:57:54 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a000444; 3 Mar 86 19:43 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a004627; 3 Mar 86 14:04 EST
   Newsgroups: net.wanted,net.wanted.sources,net.decus,net.lang,net.lang.c
   Xref: seismo net.wanted:8910 net.wanted.sources:2100 net.decus:305 
   net.lang:2240 net.lang.c:8189
   I am looking for a program like lint that will run under VMS on a VAX 
   11/730. Any information or pointers would be appreciated.
                             Thanks,
                             Dick Tusia
                             ihnp4!chinet!dat
                             203-767-2601
                             203-669-3144
EXT-simon-simon-pc-uucp-8Q6RV 2-Mar-86 Lattice 2.15 problems - APOLOGY!!!
   From: {Simon Shapiro <simon%simon_pc.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-simon-simon-pc-uucp-8Q6RV / <154@simon_pc.UUCP>
   Keywords: MY mistake!!!  Thank you all!
   Posted:  2-Mar-86 16:28-PST  Received: 25-Mar-86 17:48-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  3 Mar 86 17:07:59 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a000454; 3 Mar 86 19:43 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a004766; 3 Mar 86 14:08 EST
   Newsgroups: net.lang.c,net.followup
   Xref: seismo net.lang.c:8190 net.followup:5897
   Thank you ALL for your help.  I received 4-5 mailings about my problem + 
   several followups that you have all seen.
   I screwed-up!  I did include the lcm library but it was listed AFTER lc 
   and not before.
   'when two people tell you you are drunk - go to bad!'  when I got off my 
   bug-bitching-mood and looked at the shell script I wrote and compared it 
   to Lattice's I saw my error.
   This is exactly what I like about this network:  So full of nice people 
   doing their best to help their fellow man (no pun intended!)
   Thank you, Simon.
EXT-nolan-8Q6TA 3-Mar-86 Re: Language Translators
   From: {Earl Nolan <nolan@ucb-vax.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-nolan-8Q6TA / <12143@ucbvax.BERKELEY.EDU>
   Posted:  3-Mar-86 08:36-PST  Received: 25-Mar-86 17:48-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  3 Mar 86 17:32:59 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a000595; 3 Mar 86 20:12 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a002526; 3 Mar 86 19:51 EST
   Newsgroups: net.lang.c
   In article <1286@brl-smoke.ARPA>, cottrell@NBS-VMS.ARPA (COTTRELL, JAMES)
   writes: > /*
   > People keep requesting things like `I need a <languageX> to > 
   <languageY> translator.' While this is all fine and good, what we > 
   *really* need is a C to ADA translator to keep Uncle Sam happy > and also
   allow us to program on our beloved UNIX in Sacred C. > How about it, Dr. 
   Research?
   >
   >         jim             cottrell@nbs
   > */
   > ------
   That's the best idea to come out of net.lang.c since I've been reading 
   it!!! --
   Eureka!!!   I have found it!  Not only the job, but the company.
   [..!ucbvax!nolan]                                 /* no comment */
   [nolan@ucbarpa.ARPA]                                      earl nolan
EXT-ado-elsie-uucp-8Q6TJ 3-Mar-86 __LINE__
   From: {Arthur David Olson <ado%elsie.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-ado-elsie-uucp-8Q6TJ / <6037@elsie.UUCP>
   Keywords: __LINE__
   Posted:  3-Mar-86 09:15-PST  Received: 25-Mar-86 17:48-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  3 Mar 86 17:38:01 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a000607; 3 Mar 86 20:13 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a002534; 3 Mar 86 19:52 EST
   Newsgroups: net.lang.c
   My April 30, 1985 Draft standard has a "conceptual model" on page 5 that 
   breaks language processing into these successive phases (among others):
      . . .
      2.  Each instance of a new-line character and an immediately preceding
      baclslash character is deleted, splicing physical source lines to form
      logical source lines.
      . . .
      5.  The source is preprocessed. . .
   Later, in discussing the preprocessor, the standard reads:
      . . .The line number of the current source line is one greater than 
      the number of new-line characters read while processing the source 
      file to the current token. . .The predefined macro name __LINE__ has 
      the value of the line number of the current source line (a decimal 
      constant). . .
   It's unclear (to me, at least) whether the new-line characters that are 
   counted in determining __LINE__ are those in the physical source lines 
   (seen in conceptual phase 2) or those in the logical source lines (seen 
   in conceptual phase 5, the preprocessing phase).  I'd imagine that having
   __LINE__ be a physical source line number would be preferable, but how 
   can that be accomplished without breaking down barriers between 
   conceptual phases?
   --
     UUCP: ..decvax!seismo!elsie!ado    ARPA: elsie!ado@seismo.ARPA
      DEC, VAX and Elsie are Digital Equipment and Borden trademarks
EXT-kwh-bentley-uucp-8Q6U8 3-Mar-86 Re: Long Longs
   From: {KW Heuer <kwh%bentley.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-kwh-bentley-uucp-8Q6U8 / <608@bentley.UUCP>
   Posted:  3-Mar-86 13:13-PST  Received: 25-Mar-86 17:48-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  3 Mar 86 17:50:24 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a000639; 3 Mar 86 20:29 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a002630; 3 Mar 86 19:57 EST
   Newsgroups: net.lang.c
   In article <491@faron.UUCP> faron!bs (Bob Silverman) writes: >[How do I 
   calculate without intermediate overflow] >a = (b*c)/d;
   >a = (b*c) % d;
   >... Many machines CAN multiply two full words together giving a double 
   >length product placed in two adjacent registers.
   Many others can't.  If the feature were built into the language, what 
   code should it generate for "long long" arithmetic on a more limited 
   machine?
   >Does C++ have long longs?
   C++ cannot do anything that C cannot, since it produces C output.
   >Does anyone have a good solution?
   My prefered method (to maximize portability) is to have library functions
      int muldiv(int, int, int)
      int mulrem(int, int, int)
   which are written in assembly language; for specific applications in 
   tight loops I hand-optimize the .s file as described in article 
   <3408@umcp-cs.UUCP> by umcp-cs!chris (Chris Torek) (not quoted here).
   It seems to me that best solution for the future is for "int" to be 32 
   bits wide, while "long" is 64.  I expect the compilers will start doing 
   this once there is a little more support for 64-bit arithmetic in the 
   hardware.  (Like when 32-bit addresses aren't big enough.) No smiley on 
   this paragraph, I'm serious.
   Incidentally, does anyone have a muldiv routine (in C or as) for a 32-bit
   machine without emul/ediv instructions?  Currently I'm using 
   (int)((double)x*(double)y/(double)z) which is quite slow on a 3b2 without
   floating-point hardware.
   Karl W. Z. Heuer (ihnp4!bentley!kwh), The Walking Lint
EXT-ded-aplvax-uucp-8Q6XV 3-Mar-86 To dereference or not dereference, that 
is the question
   From: {"Don E. Davis" <ded%aplvax.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-ded-aplvax-uucp-8Q6XV / <196@aplvax.UUCP>
   Keywords: type casts,function pointers
   Posted:  3-Mar-86 07:37-PST  Received: 25-Mar-86 17:48-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  3 Mar 86 18:56:24 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a000843; 3 Mar 86 21:57 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a003492; 3 Mar 86 21:45 EST
   Newsgroups: net.lang.c
   In article <857@pucc-j> aaz@pucc-j.UUCP (Marc Mengel) writes: >
   >char foo[BIGNUM];
   >main()
   >{
   >        int result;
   >
   > /* code to put machine code into foo[] */
   >
   > result = (* (int (*)()) foo)();
   >}
   >--
   An interesting corollary to this issue is the following.  It doesn't seem
   to matter if I deference function pointers or not. This seems wrong to 
   me.  I feel the y(2) and ((int (*)())x)(3) function invocations should be
   illegal.
   #include <stdio.h>
   main(argc, argv)
   int argc;
   char **argv;
   {
      int x;
     int (*y)();     /* y is pointer to function returning int */
   int func();
     y = func;       /* y points to func */
     (*y)(1);        /* dereference y and invoke func */
     y(2);           /* DON'T dereference y and invoke func! */
   /* the same as above with casting */
   x = (int)func;
   ((int (*)())x)(3);
   (*(int (*)())x)(4);
   exit(0);
   }
   func(param)
   int param;
   {
      printf("hello %d\n", param);
   }
   All of the above appear to be equivalent.  What the heck is going on 
   here? --
                                     Don Davis
                                     JHU/APL
                             
   ...decvax!harpo!seismo!umcp-cs!aplcen!aplvax!ded
                             ...rlgvax!cvl!umcp-cs!aplcen!aplvax!ded
EXT-lcc-rich-wiz-8Q75O 3-Mar-86 Re: Stack Frames
   From: {Richard Mathews <lcc.rich-wiz@ucla-locus.ARPA>}DDN
   To: ihnp4!opus!ka@ucla-locus.ARPA
   Cc: info-c@BRL.ARPA
   Identifier: EXT-lcc-rich-wiz-8Q75O
   In-reply-to: Message of 19 Feb 86 22:26:07 GMT from "Kenneth Almquist 
   <ka@hropus.uucp>" <289@hropus.UUCP>
   Posted:  3-Mar-86 19:49-PST  Received: 25-Mar-86 17:48-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  3 Mar 86 21:15:39 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a000320; 4 Mar 86 0:09 
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id a003885; 3 Mar 86 23:28 
   EST
   Received: from ucla-locus.arpa by AOS.BRL.ARPA id a001218; 3 Mar 86 23:26
   EST
   > There is at least one compiler out there for which does this.  I know >
   because I got a bug report on vnews concerning a piece of code where
   > I jumped into the middle of a block.    The rule is that the effect of
   > jumping into a block containing declarations is machine dependent.  All
   > other jumps, such as jumping into a block that contains no variable > 
   declarations or jumping out of a block that does, are all legal, just > 
   as in PL/1.
   The only thing that is machine dependent is the contents of the 
   uninitialized variable(s).  If this is what was meant, ignore this 
   message.
   Any compiler which does not allow jumping into blocks with declarations 
   is broken.  To quote from K&R, page 201:
      It is currently possible (but a bad practice) to transfer into a 
      block; in that case the initializations are not performed.
   The word "currently" in the above quote bothered me.  It implies that 
   this may not be true someday; however, the April 30, 1985 draft of ANSI C
   says (section C.6.2):
      An instance of an object declared with automatic storage duration is 
      created on each entry into a block or (via a jump) into an enclosed 
      block.  If an initialization is supplied, it is performed on each 
      entry, except if the block is entered via a jump.
   Richard M. Mathews
   Locus Computing Corporation                      
   lcc.richard@LOCUS.UCLA.EDU
                                            lcc.richard@UCLA-CS
                              {ihnp4,trwrb}!lcc!richard
      {randvax,sdcrdcf,ucbvax,trwspp}!ucla-cs!lcc!richard
EXT-chris-umcp-cs-uucp-8Q75U 3-Mar-86 Re: To dereference or not dereference,
that is the question
   From: {Chris Torek <chris%umcp-cs.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-chris-umcp-cs-uucp-8Q75U / <44@umcp-cs.UUCP>
   Keywords: type casts,function pointers
   Posted:  3-Mar-86 18:10-PST  Received: 25-Mar-86 17:48-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  3 Mar 86 21:19:44 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a000325; 4 Mar 86 0:09 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a004114; 3 Mar 86 23:44 EST
   Newsgroups: net.lang.c
   In article <196@aplvax.UUCP> ded@aplvax.UUCP (Don E. Davis) writes:
   >... It doesn't seem to matter if I deference function pointers or not. 
   >This seems wrong to me.
   ... followed by a code sample including the declaration and call:
      int (*y)();
      ...
      y(2);
   The call is wrong.  It `just happens' to work in PCC-based compilers. Try
   compiling the following:
      main()
      {
         int f(), (*p)();
         p = f;
         p(1);
         (*p)(2);
         (**p)(3);
         (****************p)(4);
      }
      f(x)
         int x;
      {
         printf("%d\n", x);
      }
   Just because it works in your compiler (and in mine) does not mean it is 
   correct....
   Of course, the only thing you can do with a pointer to a function is take
   its address, take its value, or call through it.  PCC seems to figure 
   that if you are not doing either of the former, you must be doing the 
   latter, and does not care how many indirections were actually used.  
   While this is a bug in PCC, it does not seem a very important one.
   --
   In-Real-Life: Chris Torek, Univ of MD Comp Sci Dept (+1 301 454 1415)
   UUCP:     seismo!umcp-cs!chris
   CSNet:    chris@umcp-cs           ARPA:   chris@mimsy.umd.edu
EXT-pete-valid-uucp-8Q7OY 27-Feb-86 Re: Integer division
   From: {Pete Zakel <pete%valid.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-pete-valid-uucp-8Q7OY / <151@valid.UUCP>
   Posted: 27-Feb-86 15:32-PST  Received: 25-Mar-86 17:49-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  4 Mar 86 03:03:24 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a000627; 4 Mar 86 6:01 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a006420; 4 Mar 86 5:46 EST
   Newsgroups: net.math,net.lang.c,net.arch
   Xref: seismo net.math:2829 net.lang.c:8201 net.arch:2757
   > Is there someone out there who *wants* a/b to round towards 0 (for 
   reasons > that say that is the desired result)?  I asked that before and 
   have not seen > any affirmatives.
   >
   > ucbvax!brahms!weemba    Matthew P Wiener/UCB Math Dept/Berkeley CA 
   94720
   I do!  Mainly because I want the absolute value of (-a)/b to equal the 
   absolute value of a/b.
   --
   -Pete Zakel (..!{hplabs,amd,pyramid,ihnp4}!pesnta!valid!pete)
EXT-simon-simon-pc-uucp-8Q84B 3-Mar-86 Re: Command line arguments
   From: {Simon Shapiro <simon%simon_pc.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-simon-simon-pc-uucp-8Q84B / <161@simon_pc.UUCP>
   Posted:  3-Mar-86 18:47-PST  Received: 25-Mar-86 17:49-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  4 Mar 86 07:40:34 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a011053; 4 Mar 86 10:27 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a012587; 4 Mar 86 9:51 EST
   Newsgroups: net.lang.c
   All this arguing about what did K&R mean here or there reminds me of a 
   Talmud study, with one exception.  The Rabi is still alive! Maybe Mr. 
   Ritchie can tell us what he ment when he said what he said about what he 
   said (Command line argument passing) instead of all this (very amusing) 
   argument about arguments?
   I refer this to Mr. Dennis Ritchie and not to Mr. Brian Kernigham only 
   because I saw a recent postig by the first (so he must be listening to 
   all of this) but did not catch the later's name on this network.
   Simon.
EXT-cottrell-8Q8PN 4-Mar-86 Integer Division
   From: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   Reply-to: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   To: {info-c <info-c@BRL.ARPA>}DDN
   Identifier: EXT-cottrell-8Q8PN
   Posted:  4-Mar-86 12:43-PST  Received: 25-Mar-86 17:49-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  4 Mar 86 14:03:15 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a023498; 4 Mar 86 16:55 
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id a025775; 4 Mar 86 16:32 
   EST
   Received: from icst-gw.arpa by AOS.BRL.ARPA id a023200; 4 Mar 86 16:28 
   EST
   /*
   > > Is there someone out there who *wants* a/b to round towards 0 (for 
   reasons > > that say that is the desired result)?  I asked that before 
   and have not seen > > any affirmatives.
   > >
   > > ucbvax!brahms!weemba  Matthew P Wiener/UCB Math Dept/Berkeley CA 
   94720
   >
   > I do!  Mainly because I want the absolute value of (-a)/b to equal the 
   absolute > value of a/b.
   > --
   > -Pete Zakel (..!{hplabs,amd,pyramid,ihnp4}!pesnta!valid!pete)
   Me too. Conceptually, `a/b' is `how many times does b go into a'? What is
   left over has the same sign as the dividend. It seems that most 
   previously built computers truncate towards zero. Ironically, I also 
   prefer that `a%b' be positive, so that the `%' operator is actually the 
   `modulus' rather than the remainder. Thus we have the contradiction that 
   `a != (a/b)*b + (a%b)' for all possible a & b. But, as previously noted, 
   mostly we do `%' on positive integers. Of course, if b is a power of two,
   you can just `&' with `b - 1' to get the real modulus.
     jim             cottrell@nbs
   */
   ------
EXT-cottrell-8Q8T5 4-Mar-86 Gosub
   From: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   Reply-to: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   To: {info-c <info-c@BRL.ARPA>}DDN
   Identifier: EXT-cottrell-8Q8T5
   Posted:  4-Mar-86 12:57-PST  Received: 25-Mar-86 17:49-PST
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA;  4 Mar 86 15:06:50 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a023948; 4 Mar 86 17:51 
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id aa25775; 4 Mar 86 16:32 
   EST
   Received: from icst-gw.arpa by AOS.BRL.ARPA id aa23200; 4 Mar 86 16:28 
   EST
   /*
   > In basic there is a GOSUB routine that will push the current >  
   position onto the stack and jump to another line.  Then, upon >  hitting 
   a return will return to that place.  I wish to write >  something like 
   that in C that will be movable between compilers. >
   > A sample of something like it is below:
   >
   > [Example Deleted]
   >
   > Can anybody think of a better way to do this? I want it for a
   >   Basic->C translator (Please, I am writting it for fun... No 
   abuse...Please?).
   To answer a somewhat different question, while I am opposed to this 
   construct in C (because it messes with the stack, making things 
   difficult), I would very much like to see this in shell command files. 
   Here, there is no stack, and variables would be global to the command 
   file. I feel that the overhead of opening another file and the difficulty
   of passing back results (`cmd args` is limited) justifies it. What say 
   ye?
     jim             cottrell@nbs
   */
   ------
EXT-cottrell-8N9TB 19-Feb-86 UNIX Futures
   From: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   Reply-to: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   To: {info-c <info-c@BRL.ARPA>}DDN
   Identifier: EXT-cottrell-8N9TB
   Length: 3 page(s)[estimate]
   Posted: 19-Feb-86 10:54-PST  Received: 27-Apr-86 15:25-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 19 Feb 86 13:57:31 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id aa27653; 19 Feb 86 15:49
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id aa14012; 19 Feb 86 15:37
   EST
   Received: from icst-gw.arpa by AOS.BRL.ARPA id a027264; 19 Feb 86 15:30 
   EST
   /* Dagwynn sez:
   > Wayne Hathaway's question can be generalized:
   >
   > What lies in the future for vendors who have been > providing 
   Berkeley-based kernels?  Do they track > 4.nBSD as it continues to 
   diverge from AT&T's
   > UNIX product, do they convert to follow AT&T, or > do they offer a 
   choice of systems?  After all,
   > there is a limit to how much System V compatibility > you can squeeze 
   out of a Berkeley kernel, and this > limit unfortunately excludes several
   really useful > System V features.
   Divergence? Who renumbered the manual sexions? Who made INIT, LPR 
   spooling, the TTY driver look alien? OK, so maybe SV's tty driver is 
   `better' than BSD's, but why didn't they keep the old names? Like CBREAK.
   And just how much BSD compatibility can you squeeze out of the SV kernel.
   Sometimes I think TPC is *trying* to be different
   just to kill off BSD.
   > It appears that the major market demand will be for > AT&T-compatible 
   systems.  This does apply a lot of > pressure to the Berkeley system 
   vendors.  Of course, > if Berkeley would conform to the SVID, this would 
   > not be such a significant issue, but recently
   > reported quotes make this appear unlikely.  Too bad. > (Actually, if 
   BSD usage dwindled to just research- > oriented sites, that would 
   probably be a Good Thing > for everyone concerned, in the long run.)
   It seems to me that SVID is like the intersexion of most *ix's out there.
   If they want the other vendors to conform, it can't be *too* much work, 
   or no one would do it.
   > Barry has made some very good points, most of which I agree with.
   Yer darn tootin!
   > ATTIS *has* made an unfavorable initial impression on the UNIX > 
   technical community, for example (although the recent 3B2/400 > appears 
   to be significantly improved over earlier models, and the > next major 
   release of UNIX System V is slated to incorporate > substantial 
   improvements, beyond what 4.3BSD can match.  In
   Well it's about time! I guess if Berkeley had releases all the time they 
   would have some neat new stuff too. It's been four years now, while TPC 
   put out abominations like SYS III. On my SV tapes (gotta have 'em to run 
   BSD, plus we have a Motorola SV.0 port) they *finally* included vi (what 
   did they use before, ed? The Rand editor?), no pager, no new shells (same
   old sh), and a lot of weird stuff (LP, INIT, TTY, etc) i had to relearn.
   > In many ways, UNIX System V is already more useful than 4BSD,
   Name three.
   > although it does currently lag in networking support).  By the > way, 
   Barry, I was told that RFS can link disparate machines, but > given UNIX 
   code quality to date, I am skeptical.  I really hope > AT&T will make an 
   effort to teach their programmers how to code > more portably.
   > The main reason I think UNIX's commercial future lies primarily > along
   the System V path is not so much that AT&T is pushing it; > rather, it's 
   because the *customers* are starting to demand it.
   So those wimpy manager types are scared because BSD is `unsupported'. Big
   deal. Software support is a joke anyway. Fill out a form and wait for 
   unusual weather conditions in Hades. Better to publish the source & let 
   'em fix it themselves. Or subscribe to the net.
   > Several federal agencies now mandate UNIX System V, for example.
   NBS doesn't.
   > Even more significantly, in my estimation, is the fact that the > 
   standardization efforts for both UNIX and C follow System V semantics > 
   very closely.  (I even technically agree with this; every time I > find 
   myself working in a native Berkeley environment, it is not > long before 
   I start cursing their primitive software development tools.
   Primitive? I suppose you prefer SCCS over RCS? Jeez! OK, so `make' has 
   been enhanced. What else?
   > The main motivation of the BRL UNIX System V emulation > project was to
   provide the nicer, uniform, System V environment > everywhere I have to 
   work.  Many of my users appreciate it, too.)
   Don't get me wrong, we appreciate your efforts. I just didn't realize 
   your motives until now.
   > Besides better user-mode libraries and utilities, which 4BSD could > 
   pick up,
   Could they? What would TPC if Berkeley wanted to include, say SCCS? Or 
   the nifty new shells TPC has developed? At what price?
   > there are also many aspects of the UNIX System V kernel > that are 
   better designed and implemented than in 4.2BSD;
   Examples please.
   > memory management is one notable example.
   Took them long enuf.
   > This is not to say that there
   > are not problems with UNIX System V; Guy Harris and I have posted > 
   perhaps a hundred bug reports and there are many others we have > fixed 
   without telling the net.  It is important to realize that > the same 
   thing would have been observed for 4.2BSD, except I avoid > improving it 
   because I don't use much of their user-mode software. > (What I do use 
   often suffers from the famous "Berkeley Brain > Damage", which I 
   attribute to the designers deciding on a single > usage model and doing a
   lot to help that particular usage, to the > detriment of other more 
   general possible uses.
   Just what we need, lots of different ways of doing things.
   > Gee, I could have had a V8!)
   Could you? Who *has* V8? Outside Bell Labs, that is.
   > The reason that this issue is drawing increasing attention is that, > 
   unless AT&T really botches it, the next major release (3.0) of UNIX > 
   System V will be significantly better than any previous publicly- > 
   available version of UNIX (although it may be some time before this > 
   becomes generally apparent), and some of the new features will be > 
   difficult to fit into 4BSD-based kernels without major overhaul. > What 
   one would hope is that the folks at Berkeley would be willing > to change
   their system to closely track UNIX System V, except in > those cases (if 
   any) where it is clear that a major loss of > functionality would result.
   Like I said, I think TPC has been making that difficult.
   > It was mentioned that DEC's Ultrix product was based on 4.2BSD and > 
   had attained some degree of System V compatibility through the use > of 
   the BRL UNIX System V emulation package.  Actually, the current > 
   situation is somewhat different, in that DEC (like most of the other > 
   major 4BSD-based kernel vendors) has felt the pressure from the > 
   marketplace for System V compatibility, and they have been > responding. 
   Many (maybe even most) of these vendors obtained the > BRL UNIX System V 
   emulation package and used it as a base for > their initial System V 
   compatibility offering.  (No, I will not > disclose names.  Just name 
   one; they're probably included.)  The > trouble with the BRL UNIX System 
   V emulation is that I could not > emulate all aspects of UNIX System V 
   semantics perfectly without > making changes to the 4.2BSD kernel, which 
   was off-limits for the > purposes of my project.  The 4BSD-based kernel 
   vendors, however, > do not have such a constraint, and what many of them 
   have done is > to incorporate into their kernels those System V features 
   that > are hardest to do in user mode, leaving the rest to a 
   compatibility > library very much the way I did the whole emulation.  
   This approach > has allowed 4BSD-based kernel vendors to provide System V
   > functionality (yuck, I hate that word -- is there a better one?) > to 
   those customers who want it.  DEC, for example, now advertises > Ultrix 
   as meeting all the specs of the System V Interface > Definition (AT&T's 
   official published System V semantic > specification); I have no idea how
   much (if any) of my original > work is still in the Ultrix product (I 
   hope the bug fixes are). >
   > The problem with such a hybrid system, or even with a parallel- > 
   universe one such as Pyramid and Apollo offer, is that it gets > 
   progressively harder to maintain a split personality as the two > base 
   systems diverge.  There are already possible security > problems due 
   simply to the different ideas the two UNIX variants > have about such 
   things as chown, process groups, terminal ioctls, > signals, etc. if both
   semantics are provided on the same system. > (Remember, security is an 
   aspect of how everything fits together.) > Merged systems have a similar 
   problem; we use one here, and both > the 4BSD and System V camps have 
   found its behavior irritating. >
   > On a strictly functional basis, which version is better? > For a long 
   time, 4BSD adherents claimed:
   >         4BSD supports demand-paged virtual memory
   >                 - So does System V, more cleanly, and shared
   >                 memory is provided (and is rumored to even work)
   One thing you Gurus have been strangely silent on is *my* model for 
   memory sharing. That is, after a fork, *just duplicate the stack and let 
   parent & child live in the same data space*!!!
   >         4BSD provides networking support
   >                 - I agree that UUCP and 3Bnet don't qualify
   Yeah, but guess who rakes in the bucks on phone calls!
   >                 - SVR3 streams will be a boon to networking
   Probably.
   >                 - TCP/IP is available for System V; soon with
   >                 AT&T's blessing (I don't know if a stream-
   >                 based TCP/IP will be released; Wollongong may
   >                 provide essentially the Berkeley implementation)
   I hear that too.
   >         4BSD has vi, termcap, and curses
   >                 - System V picked these up, and improved termcap
   >                 into terminfo (which really is better)
   Did they pay Berkeley? What did they give in return?
   >         4BSD has csh
   >                 - In many ways, the SVR2 Bourne shell is better
   How so?
   >                 - One can run ksh, which is Bourne shell compatible
   >                 and offers more than csh (except for job control);
   That's a *big* exception.
             there have been (unsubstantiated) rumors of ksh
   >                 being supported in a future release of UNIX System V
   >                 - I don't put shl in the same class as job control
   I just read about it yesterday. I agree.
   >                 - I use a 5620 DMD, what do I care.  DMDs are great!
   Great. How much do they cost? What extra software do they need?
   >                 - As usual, Berkeley implemented the wrong thing;
   Explain.
   >                 I thought those guys were supposed to talk with the
   >                 folks at Murray Hill (maybe they don't listen)
   Which *they*?
   >         4BSD has dbx
   >                 - System V's sdb is comparable
   BSD has sdb too.
   >                 - I hope pi will arrive with SVR3.n (for small n)
   Pascal? YUK!
   >         4BSD is faster
   >                 - UNIX System V is at least as fast for typical
   >                 loads
   >                 - The 4.2BSD fast file system is indeed faster
   >                 under some circumstances, at the cost of other
   >                 resources (CPU cycles and main memory)
   >         4BSD has universities developing software for it
   >                 - AT&T has Bell Labs, so there, nyaah, nyaah
   Touche!
   >                 - AT&T has substantial development resources
   I agree. Bill Joy & Mark Horton probably get paid better in the real 
   world.
   >                 - I agree that AT&T moves more deliberately
   >                 - That can be a Good Thing too
   You forgot:
      4BSD comes with better games & Rogue.
         - yeah but you can port Hack to System V
         - most of System V's games suck.
   > In other words, these arguments used to be mostly valid (that's > why 
   we chose to run 4BSD on the BRL VAXes), but UNIX System V > has rapidly 
   improved -- faster than 4BSD is improving.
   Mostly because they had a longer way to go to catch up.
   > If any die-hard 4BSD hackers have read this far, I would be glad > for 
   you fellows to keep playing around and coming up with useful > ideas.  I 
   like good ideas.  But I sure don't want you using me, > as a commercial 
   *user* of the system, as your guinea pig.  The > production folks really 
   do want improvements, but they want them > introduced in a controlled 
   manner, to minimize operational > headaches.  So far, AT&T has done a 
   much better job of that than > Berkeley has..
   I don't believe it. In a project as big as an operating system, there are
   bound to be bugs. Both in SV & BSD. The only difference I see is that TPC
   publishes their bug list ("MR's fixed") *after* they are fixed, while 
   "the BSD bug list" floats around the net *while* they are still bugs.
   > ..but nobody's perfect
   >
   > Finally, a plea:  Let's not start one of those pointless > "My system 
   is better than yours" debates.  The topic is, > where is UNIX headed in 
   the near future?  I say: clearly > System V, so far as the commercial 
   marketplace is concerned. > Feel free to dispute this, based on facts or 
   perceptions.
   You may be right, but there are *lots* of us diehards out there. IBM 
   because of their corporate size, influences the market greatly, but 
   seldom produces anything you or I would wish to deal with. Unfortunately,
   marketplace considerations often override technical ones.
     jim             cottrell@nbs
   */
   ------
EXT-jst-abic-uucp-8N9T8 15-Feb-86 Re: Integer division
   From: {Shack Toms <jst%abic.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-jst-abic-uucp-8N9T8 / <738@abic.UUCP>
   Posted: 15-Feb-86 06:24-PST  Received: 27-Apr-86 15:25-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 19 Feb 86 13:56:49 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a025707; 19 Feb 86 14:36
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a011029; 19 Feb 86 14:00 EST
   Newsgroups: net.lang,net.lang.c
   Xref: seismo net.lang:2181 net.lang.c:8038
   [Kenneth Almquist @ Bell Labs, Holmdel, NJ writes (single >)] > > Perhaps
   K&R thought that the performance penalty of implementing a > > consistent
   modulus (or divide) was not justified, since negative > > integers are 
   rarely encountered in "C" [this comment cannot be traced > > to K&R.]  
   However, this performance penalty can be avoided simply by > > declaring 
   unsigned integers as "unsigned int". >
   > On the VAX, the unsigned remainder function is implemented as a > 
   subroutine call.  The standard divide instruction cannot be used > 
   because the divide instruction does not work on unsigned integers.
   Thanks for getting me to check this out!  On my VAX using VAXC V2.1, the 
   unsigned division is done with very ugly inline code...  Thats ok, but it
   is incorrect ugly inline code.  Seems that it does not correctly perform 
   x%y where x = 0x7fffffff, y = 0xfffffff2.  It gets the answer 1, rather 
   than 0x7fffffff.
   However, the following inline fragment should work ok.
     clrl    r1
     movl    x,r0            ; load x into r0,r1 as quadword
     movl    y,r2            ; y in r2, set condition codes
     bgeq    1$              ; y < 2**31, ediv is ok
     cmpl    r2,r0           ; y >= 2**31, we know x < 2*y
     bgtru   2$              ; y > x ==> x%y == x
     subl2   r2,r0           ; y <= x < 2*y ==> x%y == x-y
     brb     2$              ;
   1$:       ediv    r2,r0,r1,r0     ; y in range for ediv, x%y put in r0
   2$:                               ; r0 now contains x%y
   For signed integers x%y,  the following seems about optimal, [this is 
   from the VAXC code (almost)]
     emul    #0,#0,x,r0      ; place x in r0,r1 as signed quadword
     ediv    y,r0,r1,r0      ; r0 now contains x%y
   Comparing the two fragments, the code for the unsigned divide will 
   probably run about as fast as the code for the signed divide, so long as 
   the value of y is less than 2**31.  This is because the VAX lacks not 
   only an unsigned divide, but also a signed longword to quadword 
   conversion (except for the trick with emul).  And the signed modulus 
   instruction (ediv) requires a quadword dividend.
   The clear winner in all of this is probably x%y, where x is unsigned and 
   y is a short (either signed or unsigned).  The code is then:
     clrl    r1
     movl    x,r0            ; Unsigned x in r0,r1
     movzwl  y,r2            ; Unsigned short y in r2 (cvtwl for short y)
     ediv    r2,r0,r1,r0     ; r0 contains x%y
   But enough of implemention details...
   > In Ada, division truncates towards zero, and there are separate > 
   remainder and modulo operators.  The % operator in C is a remainder > 
   operator; we could have a new operator %% for modulo.  (On the other > 
   hand, maybe not.  We don't want C to get as large as Ada!)
   I certainly agree with that last remark.  You say, however, that the % 
   operator is a remainder operator.  Sure, the definition is that a/b can 
   round up or down [except when both a and b are positive], but a/b*b+a%b 
   must equal a.  The problem is that this selection of properties is shared
   by at least 8 possible funcions from Z X Z --> Z. Indeed, there may be 
   many more than 8 functions.  As I read my K&R there is nothing wrong with
   a compiler evaluating division of constants (constant folding) in a 
   different manner from the run-time evaluation of the same values.  
   Furthermore, the preprocessor may evaluate division in compile time 
   expressions (say in #if statements) using a different algorithm. (These 
   possibilities are probably greater with cross-compilers).  Furthermore, 
   if the denominator is a constant power of two, then the compiler might 
   generate shifts and masks, and produce a result different from that of a 
   division of the same values had they both been stored in variables.  
   Similarly, for certain values of the numerator, the division can be 
   optimized into a comparison with a result generated according to its own 
   rule.  The requirement seems to be only that, in each case, the a/b*b+a%b
   == a rule must hold.  That is, whenever an optimization can be made for 
   an expression involving "/", that the corresponding optimization also 
   must be made for "%".  Giving this operator a simple name ("remainder 
   operator") belies its fundamental ambiguity.
   A very simple solution, which is upward compatible with the current 
   language definition, is to define division to always round in a precise 
   way, and then to keep % as the remainder function.  That way, the 
   language need not be cluttered with a %% operator.  The problem is to 
   choose that definition which has the most widespread application.
   Now to get back to the original subject [which way to round], in my 
   opinion the most useful of these eight choices for division is made by 
   adding the constraint that the sign of any non-zero remainder should be 
   equal to the sign of the divisor.  My experiences have led me to believe 
   that this is the most convenient choice.  These experiences were gained 
   largely using languages which do integer division equivalently to: a/b = 
   trunc(float(a)/float(b)) (i.e. the "wrong" way).
   *Whenever* I have sought the result of a%b with b>0, I have wanted the 
   smallest non-negative remainder, regardless of the sign of a.  The 
   symmetric choice is to then have the sign of a%b determined by the sign 
   of b.  This choice may lead [as would any choice] to [marginally] 
   increased overhead on machines which have asymmetric support for signed 
   vs. unsigned integers, but it is no secret that C runs best on machines 
   with symmetric architectures.
EXT-angel-macbeth-uucp-8O0ZQ 15-Feb-86 Prolog to C
   From: {El lobo solitario <angel%macbeth.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-angel-macbeth-uucp-8O0ZQ / <165@macbeth.UUCP>
   Posted: 15-Feb-86 11:51-PST  Received: 27-Apr-86 15:25-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 20 Feb 86 02:37:56 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a000500; 19 Feb 86 22:30
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a021735; 19 Feb 86 22:03 EST
   Newsgroups: net.lang.c,net.lang.prolog
   Xref: seismo net.lang.c:8040 net.lang.prolog:680
   Some one knows of some Prolog to C converter/translator available either 
   public domain or comercially ??
   I will apreciate some information or hints about the subject.
   Angel
   ..!princeton!macbeth!angel
   --
                                      Angel Casado
                     {Las mulas son lentas pero la tierra es paciente.}
                        ... !princeton!macbeth!angel
EXT-boyd-inset-uucp-8O0ZT 13-Feb-86 Re: Disgusting Code
   From: {Boyd Roberts <boyd%inset.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-boyd-inset-uucp-8O0ZT / <847@inset.UUCP>
   Posted: 13-Feb-86 04:06-PST  Received: 27-Apr-86 15:26-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 20 Feb 86 02:37:50 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a000239; 19 Feb 86 20:56
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a018533; 19 Feb 86 20:32 EST
   Newsgroups: net.lang.c,net.sources,net.micro.pc,net.unix-wizards
   Xref: seismo net.lang.c:8039 net.sources:4425 net.micro.pc:7499 
   net.unix-wizards:16882
   But we have net.sources?
   Seriously, there's enough bad code already.
   Boyd Roberts
   +++
   +   ..!mcvax!ukc!inset!boyd
   +   boyd@inset.co.uk
   +   boyd@basser.oz
   +
   +++ "Isn't that kind of severe?"
EXT-chongo-nsc-uucp-8O0ZK 15-Feb-86 The next International Obfuscated C Code
Contest
   From: {Landon Noll <chongo%nsc.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-chongo-nsc-uucp-8O0ZK / <3427@nsc.UUCP>
   Posted: 15-Feb-86 18:59-PST  Received: 27-Apr-86 15:26-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 20 Feb 86 02:38:07 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a000585; 19 Feb 86 23:10
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a022848; 19 Feb 86 22:30 EST
   Newsgroups: net.lang.c,net.unix-wizards
   Xref: seismo net.lang.c:8042 net.unix-wizards:16886
   In article <147@nbs-amrf.UUCP> libes@nbs-amrf.UUCP (Don Libes) writes: >I
   believe chongo will also be presenting these at a BOF at the Summer 
   Usenix.
   I will be posting the 1986 rules (some changes over the 1985 rules) to 
   net.announce around the end of march.  Both these news groups will 
   receive a similar notice for folks who do not get net.announce.
   The winners will first be announced at the Summer 86 Usenix (copies will 
   be available at the Usenet BOF).  I will post the winners to the net when
   I get back form Usenix.
   For folks worried about abuse of 'net.sources' please note that the 
   contest will not use any entries posted directly to a newsgroup.  Entries
   will have to mail to decwrl!nsc!obfuscate, or directly to me via Postal 
   Letter.
   chongo < netnews() { /* begin comment > /\oo/\
EXT-chris-umcp-cs-uucp-8O0ZN 15-Feb-86 Re: pointers to void functions
   From: {Chris Torek <chris%umcp-cs.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-chris-umcp-cs-uucp-8O0ZN / <3223@umcp-cs.UUCP>
   Posted: 15-Feb-86 23:02-PST  Received: 27-Apr-86 15:26-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 20 Feb 86 02:38:01 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a000540; 19 Feb 86 22:48
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a022379; 19 Feb 86 22:17 EST
   Newsgroups: net.lang.c
   In article <943@h-sc1.UUCP> clarke@h-sc1.UUCP writes:
   >I wrote this ... under 4.2 BSD. Unfortunately, cc and lint don't like 
   >the assignment "tch = catch;"
   where `tch' is `pointer to function returning void', and `catch' is 
   `function returning void'.
   `void' types are somewhat broken in the 4.2BSD PCC.  Use `-Dvoid=int' for
   now, or avoid void.
   --
   In-Real-Life: Chris Torek, Univ of MD Comp Sci Dept (+1 301 454 1415)
   UUCP:     seismo!umcp-cs!chris
   CSNet:    chris@umcp-cs           ARPA:   chris@mimsy.umd.edu
EXT-cottrell-8O0ZZ 19-Feb-86 CPIO Incremental Dumps
   From: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   Reply-to: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   To: {info-c <info-c@BRL.ARPA>}DDN
   Identifier: EXT-cottrell-8O0ZZ
   Posted: 19-Feb-86 13:30-PST  Received: 27-Apr-86 15:26-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 20 Feb 86 02:37:32 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id aa28685; 19 Feb 86 16:49
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id ab15785; 19 Feb 86 16:45
   EST
   Received: from icst-gw.arpa by AOS.BRL.ARPA id aa28548; 19 Feb 86 16:35 
   EST
   /*
   > >From: weber@nadc.ARPA
   > >We recently installed Sys-V, release 2 and would like to use the cpio 
   > >command to do daily incremental dumps.  AT&T has hinted that cpio > 
   >should be used but doesn't want to give out any more info without a > 
   >service contract in place.
   Boy are you cynical! Or, boy am I naive.
   > Sure, we do that as a regular shell procedure on our 3B5, although > 
   the shell script is a little peculiar to our installation, here's > the 
   gist of it:
   >
   >         for j in 5 6 7 8        # whatever, for /usr5, /usr6...
   >         do
   >                 /bin/find /usr$j -type f $duration -print >> $logfile
   >                 /bin/cpio -oB < $logfile > /dev/rmt/0m
   >         done
   There is also a `-cpio <device>' option to TPC's find command. And a 
   `-newer <file>' command as well.
   >         -Barry Shein, Boston University
     jim             cottrell@nbs
   */
   ------
EXT-cottrell-8O102 19-Feb-86 The heat is on FORTH
   From: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   Reply-to: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   To: {info-c <info-c@BRL.ARPA>}DDN
   Identifier: EXT-cottrell-8O102
   Posted: 19-Feb-86 13:09-PST  Received: 27-Apr-86 15:26-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 20 Feb 86 02:37:25 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a028675; 19 Feb 86 16:48
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id aa15471; 19 Feb 86 16:23
   EST
   Received: from icst-gw.arpa by AOS.BRL.ARPA id aa28301; 19 Feb 86 16:14 
   EST
   /*
   > I agree with the supporters of FORTH that it is a usable language, and 
   that > with some discipline, a programmer can turn out good FORTH code.  
   However, > there IS indeed one area in which FORTH is much weaker than 
   any other > language, and this is the area of net-effect.  A FORTH word 
   can do any > amount of damage to the runtime stack (value stack).  There 
   is really no > limit, and this is simply due to the fact that the average
   FORTH > implementation has no control of the amount of the value stack 
   that a > routine can push or pop.  In "real" languages, we have a 
   net-effect > property, which guarantees that the arguments to a function 
   are popped off, > and the return value from a function in put in their 
   place, after function > call.  This makes much of programming much 
   easier, and, most importantly, IS > IN THE LANGUAGE SPECIFICATION.  FORTH
   programmers may enforce this rule > themseleves, but by golly it sure is 
   nice of the compiler to do it for us C > programmers.  It lets us spend 
   time where we should, worrying about > algorithms and such.
   >
   > --chet-- (chet@rice.arpa)
   All you're saying is that the Stack is a primitive data type in FORTH & 
   not in C (or Pascal, Fortran, Ada, etc). Your criticism sounds much like 
   saying that since pointers can point anywhere in C that they are 
   dangerous. In fact, FORTH has TWO stacks, one for data & one for 
   procedure (word) calls & DO loops. The call stack is maintained much the 
   same as in conventional languages. I wish I knew who said the following: 
   `Saying that the C language is dangerous presumes the existence of a safe
   one'. The same goes for FORTH, LISP, FORTRAN, PASCAL, ADA et al.
     jim             cottrell@nbs
   */
   ------
EXT-cottrell-8O105 19-Feb-86 C not LALR grammar
   From: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   Reply-to: "COTTRELL@, {JAMES" <cottrell@NBS-VMS.ARPA>}DDN
   To: {info-c <info-c@BRL.ARPA>}DDN
   Identifier: EXT-cottrell-8O105
   Posted: 19-Feb-86 13:00-PST  Received: 27-Apr-86 15:26-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 20 Feb 86 02:37:11 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a028666; 19 Feb 86 16:47
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id a015471; 19 Feb 86 16:22
   EST
   Received: from icst-gw.arpa by AOS.BRL.ARPA id a028301; 19 Feb 86 16:13 
   EST
   > >                        A ( *B );
   > >
   > >     If A has been defined as a typedef name, then the line is a
   > >     declaration of a variable B to be of type "pointer to A."
   > >     (The parentheses surrounding "*B" are ignored.)  If A is not
   > >     a type name, then this line is a call of the function A with
   > >     the single parameter *B.  This ambiguity cannot be resolved
   > >     grammatically.
   > >         C compilers based on UNIX' YACC parser-generator -- such
   > >     as the Portable C Compiler -- handle this problem by feeding
   > >     information acquired during semantic analysis back to the
   > >     lexer.  In fact, most C compilers do some typedef analysis
   > >     during lexical analysis.
   >
   > Which is just fine.  There are many other cases where the symbol > 
   table must be consulted to determine how to handle a construct > (scope 
   rules, etc.).  Nobody promised that C grammar would be > strictly 
   LALR(1)-parsable.  What is your problem?
   Amen! At least it's not as bad as FORTRASH where when you see the string 
   `DO 10 I =' you don't have to look ahead for the comma to tell you it's 
   really a DO statement rather than an assign to the variable `DO10I'. This
   freaked me out when I heard about it. YUK!
     jim             cottrell@nbs
   */
   ------
EXT-cg-myrias-uucp-8O10B 13-Feb-86 Re: ANSI C and function prototypes
   From: {Chris Gray <cg%myrias.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-cg-myrias-uucp-8O10B / <219@myrias.UUCP>
   Posted: 13-Feb-86 10:05-PST  Received: 27-Apr-86 15:26-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 20 Feb 86 02:50:28 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a001632; 20 Feb 86 5:48 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a000041; 20 Feb 86 5:27 EST
   Newsgroups: net.lang.c
   -------
   Input C program:
   -------
   dispatcher(int code, void (*disp_func)());
   -------
   Output from compiler with symbol table dump debugging flag turned on: 
   -------
   dispatcher: function - function (signed int, pointer to function () 
   returning void) returning signed int -------
   (Sorry for the long output line - you should see them for some of the 
   things I tested it with!)
   As for what this means under the draft ANSI spec, well.......
EXT--DCPHOST-LADC-8O0ZW 19-Feb-86 Re: Disgusting / obfuscated C
   From: {".DCPHOST" <.DCPHOST%LADC@CISL-SERVICE-MULTICS.ARPA>}DDN
   Reply-to: {".DCPHOS" <.DCPHOS%LADC@CISL-SERVICE-MULTICS.ARPA>}DDN
   To: {Info-C <Info-C@BRL.ARPA>}DDN
   Identifier: EXT--DCPHOST-LADC-8O0ZW
   Posted: 19-Feb-86 13:38-PST  Received: 27-Apr-86 15:26-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 20 Feb 86 02:37:38 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a029091; 19 Feb 86 17:27
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id aa16119; 19 Feb 86 17:11
   EST
   Received: from cisl-service-multics.arpa by AOS.BRL.ARPA id a028877;
             19 Feb 86 17:05 EST
   Received: FROM LADC BY CISL-SERVICE-MULTICS.ARPA WITH dial; 19 FEB 1986 
   16:50:23 EST
   Randomness: Try not to let implementation details sneak into design 
   documents.
   The results of the 2nd Annual Obfuscated C Contest were posted to 
   net.lang.c on 24 June 1985 by Landon Noll <chongo@nsc.uucp>.  I have a 
   copy in my mail archive, if anyone wants it.  Drop me a note and I'll 
   send you a copy, or (if there's sufficient interest and no negative 
   votes) I'll post it to Info-C for redistribution.
EXT-kludge-gitpyr-uucp-8O10Q 16-Feb-86 Re: Disgusting Code
   From: {Scott Dorsey <kludge%gitpyr.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-kludge-gitpyr-uucp-8O10Q / <1428@gitpyr.UUCP>
   Keywords: code, yukky, yech, contest
   Posted: 16-Feb-86 14:55-PST  Received: 27-Apr-86 15:26-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 20 Feb 86 03:00:07 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a001642; 20 Feb 86 5:48 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a000190; 20 Feb 86 5:31 EST
   Newsgroups: net.lang.c,net.micro.pc,net.unix-wizards
   Xref: seismo net.lang.c:8044 net.micro.pc:7516 net.unix-wizards:16890
   In article <168@pyuxv.UUCP> cim1@pyuxv.UUCP (G. Bogatko) writes: > ...
   > Why don't we do the same thing, and have a "Most Disgusting Code"
   >award.  The rules are simple.  Just produce your favorite bit of 
   >un-maintainable, or un-readable code. (something that would be too much 
   for >the puzzle book).  Obviously, it must compile.
      This would not be a fair contest.  I could send in a couple of the 
      assignments for our introductory programming classes and win easily. 
      I'm talking
   IF A>B THEN ELSE WRITE('HI')
   In Pascal here.  I wouldn't dare put anything worse up without ROT13.
   -------
   Disclaimer: Everything I say is probably a trademark of someone.  But 
   don't worry, I probably don't know what I'm talking about.
   Scott Dorsey
   ICS Programming Lab, Georgia Insitute of Technology, Atlanta Georgia, 
   30332 
   ...!{akgua,allegra,amd,hplabs,ihnp4,seismo,ut-ngp}!gatech!gitpyr!kludge
EXT-meissner-dg-rtp-uucp-8O117 16-Feb-86 Re: Re: fast code and no morals
   From: meissner%dg_rtp.uucp@BRL.ARPA
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-meissner-dg-rtp-uucp-8O117 / <162@dg_rtp.UUCP>
   Posted: 16-Feb-86 14:24-PST  Received: 27-Apr-86 15:26-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 20 Feb 86 03:03:55 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a001655; 20 Feb 86 5:53 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a000615; 20 Feb 86 5:44 EST
   Newsgroups: net.lang.c
   In article <814@brl-smoke.ARPA> gwyn@brl.ARPA writes: >In a hosted (as 
   opposed to stand-alone) environment, yes, C requires >that programs be 
   able to obtain arguments specified at the time they >are run.  The 
   Software Tools people have accomplished this on >virtually every major 
   mainframe and minicomputer OS, so it is doable. >
   >Yes, C requires support of both upper- and lower-case characters. 
   >Modern Cybers claim to have support for 8- or 12-bit characters. >
   I believe Doug already knows this, but ANSI C does not require command 
   line arguments to be dual-case.  If the environment can only support one 
   case, command line args MUST be mapped to lower case.
      Michael Meissner
EXT-larry-8O12V 20-Feb-86 Unix Futures
   From: larry@JPL-VLSI.ARPA
   To: info-c@BRL.ARPA
   Identifier: EXT-larry-8O12V
   Posted: 20-Feb-86 03:03-PST  Received: 27-Apr-86 15:26-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 20 Feb 86 03:38:02 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a001853; 20 Feb 86 6:33 
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id aa01521; 20 Feb 86 6:14 
   EST
   Received: from jpl-vlsi.arpa by AOS.BRL.ARPA id a001727; 20 Feb 86 6:09 
   EST
   X-ST-Vmsmail-To: ST%"info-c@brl.arpa"
   Why is this on info-c and not unix-info?
   Isn't the situation that BSD is experimental and SysV commercial?  That's
   why SysV doesn't have all the goodies we want--and doesn't have a lot of 
   the junk.
   This is not to slander Berkeley.  Just the reverse.  If you don't risk 
   you can't improve.
                               Larry @ jpl-vlsi.ARPA
EXT-gwyn-8O137 20-Feb-86 Re:  Re: fast code and no morals
   From: {Doug Gwyn (VLD/VMB) <gwyn@BRL.ARPA>}DDN
   To: meissner%dg_rtp.uucp@BRL.ARPA
   Cc: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-gwyn-8O137
   Posted: 20-Feb-86 03:20-PST  Received: 27-Apr-86 15:26-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 20 Feb 86 03:44:39 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a001864; 20 Feb 86 6:36 
   EST
   Received: from brl-vmb.arpa by SMOKE.BRL.ARPA id aa01727; 20 Feb 86 6:21 
   EST
   Yes, but C requires both upper- and lower-case support for program text 
   itself, which rules out implementation on real dinosaurs (hurray!).
EXT-jsdy-hadron-uucp-8O1GE 17-Feb-86 Re: Passing arguments to C programs
   From: {"Joseph S. D. Yao" <jsdy%hadron.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-jsdy-hadron-uucp-8O1GE / <265@hadron.UUCP>
   Posted: 17-Feb-86 22:34-PST  Received: 27-Apr-86 15:42-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 20 Feb 86 07:41:26 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a008287; 20 Feb 86 10:26
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a007525; 20 Feb 86 10:13 EST
   Newsgroups: net.lang.c
   In article <983@brl-smoke.ARPA> gwyn@brl.ARPA writes: >The requirements 
   for a hosted C environment are given in section >B.1.2.2 of the X3J11 
   draft standard.  ...
   >     ... there is a strong implication that the environment must
   >be able to supply [args] to a C program at start-up.  This would >not be
   required of a freestanding environment C implementation, >of course.
   I don't see why "of course."  Using the System V stand-alone shell, I've 
   gotten unix to happily accept command-line arguments specifying root, 
   initial swap, dump, and pipe devices and other parameters. Perhaps "of 
   course" applies just to the idea that it's not required of less fortunate
   systems?
   Note that accepting arguments is possible to most stand-alone programs on
   System V even without the stand-alone shell.  They just prompt for their 
   args and read them in from the keyboard.
   --
     Joe Yao         hadron!jsdy@seismo.{CSS.GOV,ARPA,UUCP}
EXT-don-umd5-uucp-8O1JS 18-Feb-86 Fork and Execl
   From: don%umd5.uucp@BRL.ARPA
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-don-umd5-uucp-8O1JS / <868@umd5.UUCP>
   Posted: 18-Feb-86 11:08-PST  Received: 27-Apr-86 15:42-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 20 Feb 86 08:42:09 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a010795; 20 Feb 86 11:37
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a010102; 20 Feb 86 11:20 EST
   Newsgroups: net.lang.c
   I've got a question ... Our library here is a bit shy on good Unix books,
   (people take them out and then never return them) and the online and 
   Programmer's manuals haven't been able to answer my question clearly ... 
   The question is:
   After issuing the fork(), I know the parent process gets the pid of the 
   child, and the child is a copy of the parent process, but where does the 
   execution of the child process continue from ? (assuming the child 
   process was created with no errors) In other words, if I wanted to put an
   execl() in the child to overwrite the child, where would it go ? 
   Additionally, how can I be certain that I won't ever overwrite the parent
   process ? Without code fragments, I've not been able to get a clear 
   picture of how this works.
   AtDhVaAnNkCsE
   --
   --==---==---==--
   ".. all mimsy were the Borogroves .."
      ARPA: don@umd5.UMD.EDU
   BITNET: don%umd5@umd2
      UUCP: ..!{ seismo!umcp-cs, ihnp4!rlgvax }!cvl!umd5!don
   (NOTE: Please mail to  umcp-cs!cvl!umd5!don  NOT  umd5!cvl!umcp-cs!don)
   umcp-cs ::= mimsy.UMD.EDU | maryland.ARPA | umcp-cs.UUCP
EXT-jimc-ucla-cs-uucp-8O1L4 14-Feb-86 Re: ANSI C and function prototypes
   From: jimc%ucla-cs.uucp@BRL.ARPA
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-jimc-ucla-cs-uucp-8O1L4 / <8976@ucla-cs.ARPA>
   Posted: 14-Feb-86 09:18-PST  Received: 27-Apr-86 15:42-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 20 Feb 86 09:06:12 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a011103; 20 Feb 86 11:55
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a010620; 20 Feb 86 11:32 EST
   Newsgroups: net.lang.c
   In article <250@hadron.UUCP> jsdy@hadron.UUCP (Joseph S. D. Yao) writes: 
   >return that.  Of course, since no one but EcoSoft (tentative as >that 
   is) has prototyping, there's no compiler to check this >against.  (I 
   don't have EcoSoft C.)
   >--
   IBM "C" ((c) Microsoft) for the PC claims to attempt to conform to what 
   the ANSI spec will eventually evolve to.  In particular, it includes 
   function prototypes.
   James F. Carter            (213) 206-1306
   UCLA-SEASnet; 2567 Boelter Hall; 405 Hilgard Ave.; Los Angeles, CA 90024 
   UUCP:...!{ihnp4,ucbvax,{hao!cepu}}!ucla-cs!jimc  ARPA:jimc@locus.UCLA.EDU
EXT-cscott-8O38X 20-Feb-86 add me
   From: {"Curtis A. Scott" <cscott@BBN-VAX.ARPA>}DDN
   To: info-c@BRL.ARPA
   Identifier: EXT-cscott-8O38X
   Posted: 20-Feb-86 12:31-PST  Received: 27-Apr-86 15:42-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 21 Feb 86 03:02:31 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a021226; 21 Feb 86 6:01 
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id a000955; 21 Feb 86 5:44 
   EST
   Received: from bbn-vax.arpa by AOS.BRL.ARPA id a016922; 20 Feb 86 15:36 
   EST
   If this is Mark Plotnick reading this, hello.  You used to grade my 6.001
   problem sets.
   --Curtis
EXT-eric-burdvax-uucp-8O3E9 16-Feb-86 lex and yacc spec for C wanted
   From: {Eric Marshall <eric%burdvax.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-eric-burdvax-uucp-8O3E9 / <2353@burdvax.UUCP>
   Posted: 16-Feb-86 10:28-PST  Received: 27-Apr-86 15:42-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 21 Feb 86 04:37:03 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a022046; 21 Feb 86 7:33 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a003288; 21 Feb 86 7:17 EST
   Newsgroups: net.wanted.sources,net.lang.c
   Xref: seismo net.wanted.sources:2049 net.lang.c:8065
      I am looking for a lex and yacc specification for C which will be used
      within a simple syntax checker for C.
   Thanks in advance.
   Eric Marshall
   System Development Corporation, a Burroughs Company P.O. Box 517
   Paoli, PA. 19301
   (215) 648-7223
   USENET: sdcrdcf!burdvax!eric
      {sjuvax,ihnp4,akgua,cadre}psuvax1!burdvax!eric ARPANET: PAYTON@BBNG
EXT-robison-8O3YT 17-Feb-86 Re: Stack frames
   From: robison@uiucdcsb.cs.uiuc.edu
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-robison-8O3YT / <139200021@uiucdcsb>
   Posted: 17-Feb-86 08:44-PST  Received: 27-Apr-86 15:42-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 21 Feb 86 10:03:54 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a003800; 21 Feb 86 13:00
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a011576; 21 Feb 86 12:20 EST
   Newsgroups: net.lang.c
   Nf-ID: #R:ur-helheim.UUCP:463:uiucdcsb:139200021:000:481
   Nf-From: uiucdcsb.CS.UIUC.EDU!robison    Feb 17 10:44:00 1986
   The output from C compilers I have seen indicates there is no penalty for
   {} blocks with declarations.  All allocation can be done at the function 
   entry. I.e., the source code:
      int f(x,y)
         int x,y;
         {
            int a,b;
            ...
            {
               int m,n;
               ...
            }
            ...
         }
   generates assembly code which allocates a,b,m, and n on the stack upon 
   entry. The only difference between a,b and m,n is that m,n is visible 
   only within the inner block.
   - Arch Robison
EXT-SofPasuk-imagen-uucp-8O453 17-Feb-86 Re: Re: fast code and no morals
   From: {Munach Rvi'i <SofPasuk%imagen.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-SofPasuk-imagen-uucp-8O453 / <273@imagen.UUCP>
   Posted: 17-Feb-86 09:16-PST  Received: 27-Apr-86 15:42-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 21 Feb 86 12:42:34 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a005043; 21 Feb 86 13:43
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a013611; 21 Feb 86 13:06 EST
   Newsgroups: net.lang.c
   > In article <6365@utzoo.UUCP> henry@utzoo.UUCP (Henry Spencer) writes: >
   >> > Assembler isn't portable, C is. ...
   > >>
   > >> "C" is as portable as Stonehedge!!  At least assembler languages 
   don't > >> pretend to be portable.
   > >
   > >How curious.  At U of T we routinely move C code among half a dozen or
   so > >different processors (more than that if you count different C 
   compilers > >for things like the 68000).  Compile it and it runs. > >
   > >C's portability is more than just pretense.  Of course, you have to 
   know > >what you're doing when you write the code.
   >
   > When the same application or small routine has to on an 8085, 8086, 
   68000, > 68010, PDP-11, and a VAX, and is subject to FREQUENT 
   enhancement, and > only two machines run UNIX, the less written in 
   assembler, the better. >
   > Standard practice in this case is to run everything, including 
   libraries > through lint, all 8 compilers (Large and small model 68K on 
   native and > non-native), and be real specific about types.
   >
   > This is much better than having to maintain 8 different assembler 
   versions. >
   > ...
   >
   The point about the "C" being as portable as Stonehenge was made NOT to 
   imply that programs should be routinely written in Assembler Language 
   (pun not intended), but rather that porting of programs written in "C" 
   has its own different set of problems, the solution to some of which are 
   noted above.  This is very obvious to organizations, such as mine, that 
   distribute "C"-based software for use on many different host systems, all
   of which allegedly have "standard UNIX" and "standard C" (whatever 
   "standard" means these days).
   Of course, we would never be able to distribute our software for so many 
   different host systems if we were required to write the code in 
   Assembler, but, on the other hand, we must go through significant coding 
   gymnastics to assure the portability including sticking to the "least 
   common multiple" of language features and "detuning" programs due to the 
   compiler restrictions (authors call them features, of course) on some 
   systems.  We don't have the luxury of telling our customers "too bad, 
   your system doesn't have a good or standard enough C compiler!"
EXT-SofPasuk-imagen-uucp-8O48E 17-Feb-86 Re: Re: fast code and no morals
   From: {Munach Rvi'i <SofPasuk%imagen.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-SofPasuk-imagen-uucp-8O48E / <273@imagen.UUCP>
   Posted: 17-Feb-86 09:16-PST  Received: 27-Apr-86 15:42-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 21 Feb 86 13:41:05 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a005043; 21 Feb 86 13:43
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a013611; 21 Feb 86 13:06 EST
   Newsgroups: net.lang.c
   > In article <6365@utzoo.UUCP> henry@utzoo.UUCP (Henry Spencer) writes: >
   >> > Assembler isn't portable, C is. ...
   > >>
   > >> "C" is as portable as Stonehedge!!  At least assembler languages 
   don't > >> pretend to be portable.
   > >
   > >How curious.  At U of T we routinely move C code among half a dozen or
   so > >different processors (more than that if you count different C 
   compilers > >for things like the 68000).  Compile it and it runs. > >
   > >C's portability is more than just pretense.  Of course, you have to 
   know > >what you're doing when you write the code.
   >
   > When the same application or small routine has to on an 8085, 8086, 
   68000, > 68010, PDP-11, and a VAX, and is subject to FREQUENT 
   enhancement, and > only two machines run UNIX, the less written in 
   assembler, the better. >
   > Standard practice in this case is to run everything, including 
   libraries > through lint, all 8 compilers (Large and small model 68K on 
   native and > non-native), and be real specific about types.
   >
   > This is much better than having to maintain 8 different assembler 
   versions. >
   > ...
   >
   The point about the "C" being as portable as Stonehenge was made NOT to 
   imply that programs should be routinely written in Assembler Language 
   (pun not intended), but rather that porting of programs written in "C" 
   has its own different set of problems, the solution to some of which are 
   noted above.  This is very obvious to organizations, such as mine, that 
   distribute "C"-based software for use on many different host systems, all
   of which allegedly have "standard UNIX" and "standard C" (whatever 
   "standard" means these days).
   Of course, we would never be able to distribute our software for so many 
   different host systems if we were required to write the code in 
   Assembler, but, on the other hand, we must go through significant coding 
   gymnastics to assure the portability including sticking to the "least 
   common multiple" of language features and "detuning" programs due to the 
   compiler restrictions (authors call them features, of course) on some 
   systems.  We don't have the luxury of telling our customers "too bad, 
   your system doesn't have a good or standard enough C compiler!"
EXT-ron-8O49P 21-Feb-86 Re: Fork and Execl
   From: {"Ron Natalie <ron>" <ron@BRL-SMOKE.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-ron-8O49P / <1212@brl-smoke.ARPA>
   Posted: 21-Feb-86 10:49-PST  Received: 27-Apr-86 15:43-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 21 Feb 86 14:02:45 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a000207; 21 Feb 86 15:47
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a015374; 21 Feb 86 13:50 EST
   Newsgroups: net.lang.c
   > After issuing the fork(), I know the parent process gets the pid of the
   > child, and the child is a copy of the parent process, but where does 
   the > execution of the child process continue from ? (assuming the child 
   process > was created with no errors) In other words, if I wanted to put 
   an execl() > in the child to overwrite the child, where would it go ? 
   Additionally, how > can I be certain that I won't ever overwrite the 
   parent process ? > Without code fragments, I've not been able to get a 
   clear picture of how > this works.
   >
   Neglecting certain funny versions of 4.2 as done by National 
   Semiconductor, the fork creates a totally seperate copy of all the 
   nonshared program sections.  This is entirely analogous to having 
   allocated room for a new running copy of the program.  Every program your
   shell starts up is handled by fork and execl.  No working UNIX would 
   overwrite the parent when the child does something.
   Since the NSC memory management unit is a little better than that of a 
   VAX they accomplish the same thing by setting all the writable areas to 
   generate a fault when accessed by either the parent or child.  It then 
   makes a seperate copy of just that page.
   VFORK, in 4 BSD is a realization that many programs do fork/exec in quick
   succession.  VFORK does not copy the data areas, but suspends the parent 
   until the child executes a separate exec.
   -Ron
EXT-DPHARP01-ULKYVX-BITN-8O64Q 22-Feb-86 Help!
   From: DPHARP01%ULKYVX.BITNET@wiscvm.ARPA
   To: INFO-C@BRL.ARPA
   Identifier: EXT-DPHARP01-ULKYVX-BITN-8O64Q
   Posted: 22-Feb-86 09:20-PST  Received: 27-Apr-86 15:43-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 22 Feb 86 10:11:39 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a004001; 22 Feb 86 13:07
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id aa26672; 22 Feb 86 12:55
   EST
   Received: from wiscvm.arpa by AOS.BRL.ARPA id a003892; 22 Feb 86 12:52 
   EST
   Received: from (DPHARP01)ULKYVX.BITNET by WISCVM.WISC.EDU on 02/22/86
     at 11:51:17 CST
   I am looking for an implementation of either the DES or RSA encryption 
   algorithims written in C.  Any flavor of C will do, although VAX C would 
   be nice if I had a choice.  Any help on where I might look, etc. would be
   greatly appreciated.
   David Harpe
   University of Louisville
   BITNET: DPHARP01@ULKYVX
   Phone:  (502) 588-6303
EXT-info-c-request-8O6R0 22-Feb-86 INFO-C: The Lost Messages
   From: {Mark Plotnick (MIT) <info-c-request@BRL.ARPA>}DDN
   To: info-c-arpa@BRL.ARPA
   Identifier: EXT-info-c-request-8O6R0
   Posted: 22-Feb-86 16:21-PST  Received: 27-Apr-86 15:43-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 22 Feb 86 16:52:43 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a005938; 22 Feb 86 19:43
   EST
   I've now recovered and sorted through the 10 days' worth of missing 
   netnews net.lang.c articles from earlier this month (the problem, which 
   hit a few of the mailing lists coming out of BRL, was due to the netnews 
   software moving onto a different machine with a relatively new mail 
   system).  I'll be mailing the messages out to this list over the next 
   couple days (since the total size is about 140KB).  Since I didn't think 
   anyone would want to read a string of 87 messages, I took the liberty of 
   grouping the messages a bit, as follows:
   c++               c++ discussion
   definition        language definition and implementation issues
   intdiv            the integer division discussion
   lambda            lambda definitions in c
   wanted            software and documentation requests
   misc              stuff that didn't fit into any of the above 5 
   categories
   moremisc          stuff that didn't fit into any of the above 6 
   categories
EXT-info-c-request-8O6TC 22-Feb-86 info-c lost messages: c++
   From: {Mark Plotnick (MIT) <info-c-request@BRL.ARPA>}DDN
   To: info-c-arpa@BRL.ARPA
   Identifier: EXT-info-c-request-8O6TC
   Length: 2 page(s)[estimate]
   Posted: 22-Feb-86 17:08-PST  Received: 27-Apr-86 15:43-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 22 Feb 86 17:32:51 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a006118; 22 Feb 86 20:20
   EST
   From: david@ukma.UUCP (David Herron, NPR Lover)
   Newsgroups: net.lang.c
   Subject: C++ and YACC (?)
   Date: 3 Feb 86 02:30:06 GMT
   Organization: U of Kentucky, Mathematical Sciences, Lexington KY
   I'm wanting to learn C++.  As the language is geared towards large 
   projects what I have in mind is finally fixing up my BASIC interpretor. 
   (You may remember me posting it to mod.sources last summer).
   As I know very little about parsing I will want to use a YACC grammar 
   spec for the parser.  But will YACC and C++ inter-operate properly? Or 
   would a new sort of "language hosting" need to be done for C++? Has 
   anybody done a parser using YACC and C++?
   My "working design" at the moment has the grammar also recognizing the 
   normal user-level commands (i.e. RUN, LIST, etc).  It generates code 
   lists into an intermediate language, and calls a function to interpret 
   this intermediate language at appropriate times.  So I won't have to call
   yyparse() lots of times (I couldn't figure that one out when I tried a 
   couple of years ago).  But I will need to be using some code that's C to 
   call code that's C++.  Or maybe I can just compile the yacc output with 
   C++ instead of C?
   Any suggestions?
   --
   David Herron,  cbosgd!ukma!david, david@UKMA.BITNET, soon, 
   david@uky.csnet.
   Experience is something you don't get until just after you need it.
      -------
   From: ggs@ulysses.UUCP (Griff Smith)
   Newsgroups: net.lang.c
   Subject: Re: C++ and YACC (?)
   Date: 3 Feb 86 14:38:57 GMT
   Organization: AT&T Bell Laboratories, Murray Hill
   > Will YACC and C++ inter-operate properly?
   > Or would a new sort of "language hosting" need to be done for C++? > 
   Has anybody done a parser using YACC and C++?
   >
   > I won't
   > have to call yyparse() lots of times (I couldn't figure that one > out 
   when I tried a couple of years ago).  But I will need to be > using some 
   code that's C to call code that's C++.  Or maybe I can > just compile the
   yacc output with C++ instead of C? >
   > Any suggestions?
   > --
   > David Herron,  cbosgd!ukma!david, david@UKMA.BITNET, soon, 
   david@uky.csnet. >
   The output of YACC is compatible with C++.  The compiler grumbles a bit 
   about the sloppy function declarations, but there are no fatal errors. 
   Lex is a bit worse; the complaints from the compiler are a bit louder, 
   though still non-fatal.  I run the output of lex through a sed script to 
   clean up warnings plus a few self-inflicted problems. --
   Griff Smith       AT&T (Bell Laboratories), Murray Hill
   Phone:            (201) 582-7736
   Internet: ggs@ulysses.uucp
   UUCP:             ulysses!ggs  ( {allegra|ihnp4}!ulysses!ggs )
      -------
   From: bs@alice.UucP (Bjarne Stroustrup)
   Newsgroups: net.lang.c
   Subject: C++ and YACC
   Date: 3 Feb 86 19:33:55 GMT
   Organization: Bell Labs, Murray Hill
   > From allegra!ulysses!burl!clyde!cbosgd!ukma!david Wed Dec 31 19:00:00 
   1969
   Nice date!
   > From: david@ukma.UUCP (David Herron, NPR Lover)
   > Newsgroups: net.lang.c
   > Subject: C++ and YACC (?)
   > Posted: Sun Feb  2 21:30:06 1986
   > Organization: U of Kentucky, Mathematical Sciences, Lexington KY
   > I'm wanting to learn C++.  As the language is geared towards large > 
   projects what I have in mind is finally fixing up my BASIC interpretor. >
   (You may remember me posting it to mod.sources last summer).
   Actually, it is not bad for small projects either.
   > As I know very little about parsing I will want to use a YACC grammar >
   spec for the parser.  But will YACC and C++ inter-operate properly? > Or 
   would a new sort of "language hosting" need to be done for C++? > Has 
   anybody done a parser using YACC and C++?
   Yes, that has been done several times. In particular, the C++ parser is 
   done using yacc. You can simply write the actions in C++, yacc doesn't 
   really know about C.
   > My "working design" at the moment has the grammar also recognizing > 
   the normal user-level commands (i.e. RUN, LIST, etc).  It generates > 
   code lists into an intermediate language, and calls a function to > 
   interpret this intermediate language at appropriate times.  So I won't > 
   have to call yyparse() lots of times (I couldn't figure that one > out 
   when I tried a couple of years ago).  But I will need to be > using some 
   code that's C to call code that's C++.  Or maybe I can > just compile the
   yacc output with C++ instead of C?
   Exactly. Just feed y.tab.c to CC (the C++ compiler) instead of cc.
   > Any suggestions?
   > David Herron,  cbosgd!ukma!david, david@UKMA.BITNET, soon, 
   david@uky.csnet. > Experience is something you don't get until just after
   you need it.
      - Bjarne Stroustrup
   -------
   From: gdw@asgb.UUCP (Gary Walker)
   Newsgroups: net.lang.c
   Subject: C++ Translator
   Date: 4 Feb 86 20:32:09 GMT
   Organization: Burroughs Corp. ASG, Boulder Colo.
      Does anyone know of a C++ Translator that runs on a Sun or an Apollo 
      workstation?
   Gary Walker
   seismo!hao!asgb!gollem!gdw
   (303)-530-6754
      -------
   From: jes@ulysses.UUCP (Jonathan Shopiro)
   Newsgroups: net.lang.c
   Subject: Re: C++ Translator
   Date: 5 Feb 86 17:27:38 GMT
   Organization: AT&T Bell Laboratories, Murray Hill
   >
   >     Does anyone know of a C++ Translator that runs on a Sun or an 
   Apollo
   > workstation?
   >
   > Gary Walker
   > seismo!hao!asgb!gollem!gdw
   > (303)-530-6754
   You don't have to find _a_ C++ translator, you can use _the_ C++ 
   translator. It helps to have a VAX or 3B handy to do the initial loading,
   although you can do without if you're willing to spend some time editing 
   the intermediate files.
   --
      -- Jonathan Shopiro
         AT&T Bell Laboratories
         600 Mountain Avenue
         Murray Hill, NJ 07974
         (201) 582-4179
         allegra!ulysses!jes
   -------
   From: news@pegasus.UUCP (Netnews Administrator / Tony Hansen) Newsgroups:
   net.lang.c++,net.lang.c,net.lang,net.news.group Subject: net.lang.c++ 
   created
   Date: 4 Feb 86 22:29:43 GMT
   Organization: AT&T Information Systems, Lincroft
   Keywords: C++
   Well, the votes are in after several weeks of waiting and the decision 
   was unanimous to create the net.lang.c++ newsgroup. Please move all C++ 
   discussion from net.lang and net.lang.c to net.lang.c++.
   Someone on the ARPANET may wish to set up a relay separate from the 
   info-c mailing list. Not being on the ARPANET, I have no idea how to go 
   about getting that to happen.
                                     Tony Hansen
                                     ihnp4!pegasus!hansen
      -------
EXT-info-c-request-8O6UV 22-Feb-86 missing info-c messages: 
definition/implementation issues
   From: {Mark Plotnick (MIT) <info-c-request@BRL.ARPA>}DDN
   To: info-c-arpa@BRL.ARPA
   Identifier: EXT-info-c-request-8O6UV
   Length: 10 page(s)[estimate]
   Posted: 22-Feb-86 17:30-PST  Received: 27-Apr-86 15:43-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 22 Feb 86 18:01:26 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a006196; 22 Feb 86 20:36
   EST
   From: steven@boring.uucp (Steven Pemberton)
   Newsgroups: net.lang.c,net.lang
   Subject: Re: LALR grammars for C and C++
   Date: 3 Feb 86 18:04:40 GMT
   Organization: CWI, Amsterdam
   In article <294@isis.UUCP> dmiruke@isis.UUCP asks: > Sometime back 
   someone posted a question about an error in the LALR grammar > given in 
   the book 'C - A Reference Manual' by Harbison and Steele, in which > 
   there are two productions present that don't seem to be used anywhere at 
   all > in the rest of the grammar. I do not know if any solution or 
   improvement was > suggested by someone about this. If someone has any 
   idea would like to hear > about it.
   In May 1985, Don Taylor posted the following corrections:
   | There are a handful of typo's in the lalr(1) grammar in appendix c [of 
   H&S]. | A letter to them resulted in a prompt reply from Mr. Harbison, 
   and I quote | ------------
   |
   |      -Change all occurences of "..._ctype>" to "..._type>".
   |
   |      -Remove definitions of "<008>" and "<key_dcltr>"; they are not 
   needed.
   |
   |      -"<decl or stmt>" should be "<dcl_or_stmt>".
   |
   | In addition, if you have the first printing of the book, the production
   |
   |      <cast_exp> ::= ( <typename_declaration> ) <prefix_exp>
   | should be
   |      <cast_exp> ::= ( <typename_declaration> ) <cast_exp>
   |
   | You should also know that this grammar does not accomodate C's "old" 
   form of | initializers and compound assignments.
   | ------------
   Steven Pemberton, CWI, Amsterdam; steven@mcvax.uucp
      -------
   From: throopw@dg_rtp.UUCP
   Newsgroups: net.lang.c
   Subject: Re: lint bug or bad syntax?
   Date: 3 Feb 86 00:10:52 GMT
   > At a guess, lint doesn't parse much but instead does lots of lexxing.
   Say what?  The lint utility must parse just as much as a compiler... in 
   just what sense does a typechecker parse "less" than it lexes?
   In any event, this is indeed a bug in lint (or so I assert).  The 
   expression ((void)f(),(void)g()) provokes no message, but 
   (void)((void)f(),g()) causes a warning about the value of g being 
   ignored.  Clearly, g's value is explicitly being ignored in both cases.
   In general, lint's opinions about side effects, lack thereof, and what 
   constitutes "use" of a value are less useful then they ought to be. 
   Unfortunately, the upshot for your case seems to be that there isn't a 
   clean way to get lint to accept your construct.
   --
   Wayne Throop at Data General, RTP, NC
   <the-known-world>!mcnc!rti-sel!dg_rtp!throopw
      -------
   From: throopw@dg_rtp.UUCP
   Newsgroups: net.unix-wizards,net.lang.c
   Subject: Re: Need help with C (struct comparison)
   Date: 3 Feb 86 00:15:35 GMT
   >    struct datestruct date;
   >    struct dbstruct dbase[63];
   >
   >    I try to do a comparison between these, i.e.
   >
   >        ( date == dbase[loop].date )
   >
   >    but the compiler blows up on this, saying the two are incompatible.
   K&R C doesn't allow composite variables (arrays, structures, like that) 
   to be used in primitive operations (assignment, comparison, like that). 
   Now, structure assignment works in many compilers nowadays, but I'm not 
   sure about comparison.  Our typechecker barfs on this sort of thing, and 
   so does our compiler.  The compiler says:
      if( x==y )
         ^
   The binary operator "==" works only on integer, floating-point and 
   pointer data types.
   which is pretty much to the point.  In any event, just what did you want 
   the comparison to do?  Compare for bit-wise equality?  Including padding?
    What if characters have multiple representations for the "same" 
   character on your machine?  Maybe component-by-component equality?  With 
   just what semantics?  And so on and on.
   >    I'm almost positive I've done this sort of thing before, and can't
   >    seem to find why it won't work.  Anyone have any ideas/suggestions
   >    as to why this is?
   I assume that when you did it before, the item you were grabbing out of 
   the array of structures was *not* a composite type, but rather belonged 
   to integer, floating-point or pointer type.
   >    Also, is there a better newsgroup for these type of inquiries?
   Yes indeedy, called "net.lang.c".   Followup has been redirected there. 
   --
   Wayne Throop at Data General, RTP, NC
   <the-known-world>!mcnc!rti-sel!dg_rtp!throopw
      -------
   From: jsdy@hadron.UUCP (Joseph S. D. Yao)
   Newsgroups: net.lang.c
   Subject: Re: type cast in initializer
   Date: 1 Feb 86 16:35:30 GMT
   Organization: Hadron, Inc., Fairfax, VA
   Summary: why cast?  two reasons.
   In article <1450@bbncc5.UUCP> keesan@bbncc5.UUCP (Morris M. Keesan) 
   writes: >In article <302@hsi.UUCP> stevens@hsi.UUCP (Richard Stevens) 
   writes:
   >>        int     x = 0;
   >>        char    *ptr = (char *) &x;
   >    In any case, I'm not sure why you'd want to do what your example 
   does,
   >since the cast here is a no-op.
   Two reasons are immediately obvious.  The less compelling is that lint 
   tells you to.  The more compelling is that on some computer 
   architectures, e.g. one with type-tagged pointers, the cast may [ NOTE:  
   n o t  "will", just "may" ] not be a no-op.  Some compilers will even 
   reject the un-cast initialisation out of hand.
   Come to think of it, the 'lint' reason is not less compelling. Since you 
   are doing something "unnatural" -- pointing to an object of one type with
   a pointer of another type -- this falls under the heading of explicitly 
   having to say, "yes, this is not an error, I do mean to do exactly what 
   this says."
   --
     Joe Yao         hadron!jsdy@seismo.{CSS.GOV,ARPA,UUCP}
      -------
   From: steve@harvard.UUCP ( Pratap)
   Newsgroups: net.lang.c
   Subject: ANSI C and function prototypes
   Date: 4 Feb 86 20:01:19 GMT
   Organization: Aiken Comp Lab, Harvard
      Here is a short question regarding the new ANSI standard and function 
      prototypes.
      Let's say I want to write a 'dispatcher' routine that is passed a code
      number and a pointer to a function to call. I wish to use a prototype 
      to make sure that I am always passing two arguments, the first of 
      which is an int and the second of which is a function pointer.
      I might define the prototype as:
      dispatcher(int code, void (*disp_func)());
      My problem is that under the standard it will always be an error to 
      call this routine with a pointer to a function that does NOT return 
      void.
      Is there any way to prototype the second argument as a pointer to a 
      function returning 'anything'?  I realize if I prototype the second 
      argument as a 'void *pointer', any pointer will be properly converted,
      but this defeats my purpose of checking to make sure that the second 
      argument is really a function pointer.
      I can think of many times when I have passed pointers to functions 
      that return various different types, yet I see no way of doing this 
      when using prototypes.
         Steve Kaufer
         steve@harvard.HARVARD.EDU
         {seismo,ihnp4,allegra,ut-sally}!harvard!steve
   -------
   From: richw@ada-uts.UUCP
   Newsgroups: net.lang.c
   Subject: Re: C not LALR(1) & compiler bugs
   Date: 3 Feb 86 16:53:00 GMT
   Some clarifications:
   Whether the ambiguity pointed out in H&S causes C's grammar to be context
   sensitive deserves to be questioned.  My faint recollection of what it 
   technically means to be context sensitive doesn't seem to apply (i.e. 
   more the one terminal and/or non-terminal on the left-hand-side of a 
   production?).
   However, whether or not H&S is correct in using the term "context- 
   sensitive", there IS a point to be made!  By simply looking at
      A (*B) ;
   the parser CAN generate A (sub-) tree for that statement/declaration. 
   That is, the parser WILL still only recognize strings in the language for
   C (where language is defined in the more formal sense of being a 
   possibly-infinite set of strings).  HOWEVER, the tree that is built for 
   this statement/declaration contains almost no semantic information. 
   Contrast it against the sub-tree built for
      if (<conditional-expression>)
         <statement>
      else
         <statement>
   After parsing that, the language processor KNOWS that that is an IF 
   statement.  However, after parsing, the language processor needs to look 
   at PREVIOUS information (context, if you like) to figure out if
      A (*B) ;
   is a statement (i.e. procedure call) or a variable declaration. There's a
   big difference between the two interpretations...
   My apologies for probably using the wrong terminology, but remember that 
   it was quoted from H&S (i.e. how to pawn off blame for a mistake).
   -- Rich
      -------
   From: aegl@root44.UUCP (Tony Luck)
   Newsgroups: net.lang.c
   Subject: want copy of X3J11 standard
   Date: 4 Feb 86 17:08:39 GMT
   Organization: Root Computers Ltd., London
   Some time ago someone posted some information on X3J11 Ansi standard C [a
   full copy of the standard]. If anyone saved this (or knows someone who 
   can supply me with a copy (preferably machine readable - but paper will 
   do) could they please mail me. [Just mail to say you have it first I 
   don't want to get swamped with 1000 copies !]
   -Tony Luck    {eunet}!ukc!root44!aegl
      -------
   From: bcase@amdcad.UUCP (Brian case)
   Newsgroups: net.lang.c
   Subject: PCC bug; probably an old one
   Date: 5 Feb 86 23:40:03 GMT
   Organization: AMDCAD, Sunnyvale, CA
   Keywords: switch, floating point
   I am in the process of porting the portable C compiler.  I just found 
   what I think to be a bug (well, I am sure it is a bug) in the front end. 
   It seems that the PCC front end generates incorrect code for a switch 
   statement whose expression is of type double or float (and possibly other
   types; haven't checked 'em out).  In K&R, it is stated that the type of a
   switch expression must be int.  So, the PCC front end should flag an 
   error (but doesn't).  Is this really a bug or have I missed something?  
   Sorry if I am bringing up an old topic.  Reply by mail unless general net
   interest is suspected.
      Brian Case
      ..ihnp4!amdcad!bcase
   -------
   From: hrp@cray.UUCP (Hal Peterson)
   Newsgroups: net.lang.c
   Subject: Re: Re: type cast in initializer
   Date: 3 Feb 86 18:53:51 GMT
   Organization: Cray Research Inc., Mendota Heights, MN
   > >       int     x = 0;
   > >       char    *ptr = (char *) &x;
   >
   >     In any case, I'm not sure why you'd want to do what your example 
   does,
   > since the cast here is a no-op.
   An int pointer does not necessarily have the same format as a char 
   pointer. Consider a word addressible machine on which the char's are 
   packed into the words.
   --
   Hal Peterson / Cray Research / 1440 Northland Dr. / Mendota Hts, MN  
   55120 UUCP:  ihnp4!cray!hrp               phone:  (612) 681-3085
      -------
   From: rich@rexago1.UUCP (K. Richard )
   Newsgroups: net.lang.c,net.unix
   Subject: return, exit, _exit summary
   Date: 5 Feb 86 17:30:44 GMT
   Organization: Roadway Express Inc., Akron, OH
   My original query:
   >I'm on a binary only 3b2/300 running SV.2.2 so... >What's the difference
   between leaving main by return() vs exit() vs _exit()? >I mean in 
   reality, by proposed standards (X3J11 can you hear me?), and 
   >functionally (like on my machine).  Who closes file descriptors?  Who 
   reclaims >memory?  What about shared memory?  What is a gate 4, 8?
   It seems that return & exit both place exit status on the stack and allow
   the process to die.  _exit does the same thing but does not flush io 
   buffers. Cleanup, ie, open files, semaphores, and shared memory segments 
   are cleaned up by the kernal when a process dies.
   Thanks to all who shared.
   K. Richard Magill
   ps, the gate is a kernal call on a 3b2.
      -------
   From: henry@utzoo.UUCP (Henry Spencer)
   Newsgroups: net.lang.c
   Subject: Re: C not LALR(1) & compiler bugs
   Date: 5 Feb 86 00:20:05 GMT
   Organization: U of Toronto Zoology
   > ... I simply don't like being told in K&R and H&S that > if I want my 
   programs to be portable, I should ensure that the first > six characters 
   of all of my external id's are different, ignoring case, > so that I can 
   port it to a Honeywell 6000.  Is it really crucial for > the compiler 
   generated code to conform to the limitations of ALL > linkers and 
   loaders?
   Do you want your programs to be portable or not?  The fewer assumptions 
   you make about the environment they will run in, the more portable they 
   will be.  Six-characters-monocase is a rather extreme restriction 
   (although there are worse linkers on some real systems!), but code that 
   conforms to it will run on almost anything.  Once you go beyond 8 
   characters or so of significance, the number of machines it will run on 
   drops *sharply*.  Do you care about portability or not?
   > ... I should either get a modern linker or worry about > mapping 
   identifiers in the object code MYSELF -- it really isn't > hard.
   Tell that to an IBM user, who doesn't *want* to write his own linker. 
   Many people have to live with support software they do not control... and
   those who do control such software often are reluctant to invest the 
   enormous efforts that would be needed to support two incompatible 
   versions. Whether this is *right* or not, it is a *fact*.  Nor are such 
   problems trivial to solve, especially when maintenance and updates are 
   considered; many people who are faced with software containing unportable
   constructs like long identifiers eventually give up on it.  Again, 
   whether this is *right* or not, it is a *fact*:  if your code relies on 
   long identifiers, there are many potential users who will never be able 
   to run it.
   > If anybody can think of ANY reason for limiting the number of 
   significant > characters of non-external identifiers to 8, I'd be 
   honestly interested > in hearing it -- these identifiers don't even exist
   after compilation!
   Here the arguments are weaker; object-file formats and linkers don't 
   enter the picture.  But for the present, the problem remains:  many 
   people have compilers which observe such limits, and are not free to 
   change.  *This* problem should eventually go away, since the ANSI drafts 
   all mandate rather longer minima for internal identifiers.  Meanwhile, 
   again, many potential users will be unable to run your software if you 
   make it gratuitously unportable by using identifiers not unique in the 
   first 8.
   > ... come on, should
   > you, in your language definition, make such silly concessions simply > 
   to ease the construction of compilers for your language?  ...
   A sound point for new languages.  C is not a new language.  Life would be
   a lot simpler if C had mandated arbitrary-length identifiers from the 
   start, but it didn't happen that way.  IT DID NOT HAPPEN THAT WAY.  That 
   is the situation; whether you like it or not doesn't change it.  You can 
   either live with it, and make your software portable, or refuse to accept
   it, and make your software unportable.  A disagreeable choice, but that's
   the way it is.
   --
                             Henry Spencer @ U of Toronto Zoology
                             {allegra,ihnp4,linus,decvax}!utzoo!henry
      -------
   From: gwyn@brl-smoke.ARPA (Doug Gwyn )
   Newsgroups: net.lang.c
   Subject: Re: Re: type cast in initializer
   Date: 6 Feb 86 23:30:45 GMT
   Organization: Ballistic Research Lab
   >> >      int     x = 0;
   >> >      char    *ptr = (char *) &x;
   >>
   >>     In any case, I'm not sure why you'd want to do what your example 
   does,
   >> since the cast here is a no-op.
   >
   >An int pointer does not necessarily have the same format as a char 
   pointer. >Consider a word addressible machine on which the char's are 
   packed into the >words.
   But, the = forces the same type coercion as the type cast. Writing the 
   cast explicitly is good style, however. I don't see why the fellow wants 
   to do what he's doing quite apart from the question of how to express 
   it..
      -------
   From: kanner@tymix.UUCP (Herb Kanner)
   Newsgroups: net.lang.c
   Subject: A diagnostic "gotcha"
   Date: 5 Feb 86 21:48:35 GMT
   Organization: Tymnet Inc., Cupertino CA
   A line of C code that looked like:
      node_mem[*dotp] = val & 0xff;
   produced the diagonistic "operands of + have incompatible types."  The 
   error was that *dotp was not of type int, and a[b] being a euphemism for 
   *(a + b), it complained about the operands of addition. --
   Herb Kanner
   McDonnell Douglas (TYMNET)
   ...!hplabs!oliveb!tymix!kanner
      -------
   From: hand@ncsu.UUCP (Steven Hand)
   Newsgroups: net.lang.c
   Subject: Re: ANSI C
   Date: 6 Feb 86 02:07:34 GMT
   Organization: N.C. State University, Raleigh
   By the way, can anyone send me the details on how to order the ANSI C 
   reference manual?
   Thanks, Steve
      -------
   From: rb@ccivax.UUCP (rex ballard)
   Newsgroups: net.lang.c
   Subject: Re: C not LALR(1) & compiler bugs
   Date: 6 Feb 86 22:30:26 GMT
   Organization: CCI Telephony Systems Group,  Rochester NY
   In article <10200037@ada-uts.UUCP> richw@ada-uts.UUCP writes: >
   >Well, I've calmed down a bit.  That was quite a flame... >
   >Whether you consider these ambiguities "all that bad" seems to >be a 
   matter of personal taste.
   >
   >In any case, the 8 significant character stuff...  (yes, more flames) >
   >If anybody can think of ANY reason for limiting the number of 
   significant >characters of non-external identifiers to 8, I'd be honestly
   interested >in hearing it.
   As has been mentioned before, the big problem with >6|8 significant 
   characters is with the assemblers.  The old RT-11 assemblers only 
   provided 6 characters.  Some of the Whitesmith flavors are the same, 
   along with most old micro assemblers like for the 8080, where the memory 
   available for the symbol table was less than 64K.
   The same problem exists with the linkers, librarians, and debuggers. 
   Debuggers which reference source line lables such as DBX and SDB are free
   of this limitation, but source is not always available.
   Static and automatic lables are often treated as local lables with 
   L[1-256] or a similar approach.  This makes debugging more difficult, but
   eases the symbol table crunch.  These can be made variable length so long
   as the programmer understands the difference.  Structure member names are
   another candidate for variable length names.
   One popular approach is to use #defines do define full names and use a 
   good pre-processor to resolve them into their cryptic names.  Doing this 
   automatically seems attractive until you get into the problem of global 
   resolution.  Perhaps incorporating the file name into the lable would 
   help.
   As long as there are assemblers that run in 'PDP-11 emulation mode' and 
   machines with memory restrictions, the restriction will hold for 
   'portable code'.
   One alternative (though less practical).  Compile directly from 'C' 
   source to link module.  This bypasses the assembler but not the linker. 
   Another is to go from source to executable, this can lead to a very large
   compiler, like SmallTalk, but would make debugging easier.
   I have noticed that lint (4.2) will complain when a very long name is 
   declared, and a trunkated version is referenced (Particularly with 
   #defines).  Ideally, lint should check for both 'Unique prefix' and 
   'Unique full-name' on all lables, issuing '<lable> not used', '<lable> 
   undefined', and '<lable multiply defined>' if there is a clash either 
   way.
   Unfortunately, it seems that there is little incentive to rewrite 
   assemblers, linkers, librarians...,  Fourth generation languages, 
   incremental compilers, and interactive developement systems are following
   the FORTH tradition of keeping symbol table information directly even 
   after the source is compiled.  Could something like this could be done 
   for C?
   I am glad there is interest in making these types of improvements in the 
   language.  Perhaps by investigating some of the good features of 
   languages like FORTH or SmallTalk, rather than trying to poke at their 
   weaknesses (they have many), a better, more powerful 'C' developement 
   system will evolve.  I'd love to see a fully interactive environment that
   allows unit testing and gradual integration of actual compiled code. DBX 
   comes close, but I'm almost positive it could be even better.
      -------
   From: msb@lsuc.UUCP (Mark Brader)
   Newsgroups: net.lang.c
   Subject: Re: type cast in initializer
   Date: 8 Feb 86 05:22:46 GMT
   Organization: Law Society of Upper Canada, Toronto Summary: Reminder of 
   what casting means
   In regard to...
   > > >     int     x = 0;
   > > >     char    *ptr = (char *) &x;
   > >    In any case, I'm not sure why you'd want to do what your example 
   does,
   > >since the cast here is a no-op.
   Joseph S. D. Yao responds...
   > Two reasons are immediately obvious...
   and goes on to give three reasons.  Two are excellent, but the other is 
   wrong:
   > ... on some computer
   > architectures, e.g. one with type-tagged pointers, the cast may > [ 
   NOTE:  n o t  "will", just "may" ] not be a no-op.
   If this is not a slip, it stems from a misconception of casting which is 
   a Frequently Repeated Error in this newsgroup.  (If I remember what 
   somebody posted a while ago, the error found its way into a DECUS C 
   manual, which accounts for its widespreadness.)
   The cast specifies a conversion.  If TTT and UUU are types, and we have:
      TTT t; UUU u; /* ..... */ t = u;
   then at that point the expressions t and (TTT)u are interchangeable. In 
   the case of type-tagged pointers, the cast specifies that the pointer 
   tagged "int" is to be converted to one tagged "char" and stored in the 
   variable, but so would the initialization or assignment without the cast,
   if the compiler accepts it at all.
   Mark Brader
   [ The current ANSI draft C standard states:
     Preceding an expression by a parenthesized type name
     c o n v e r t s    t h e    v a l u e           [ emphasis mine]
      of the expression to the named type.  This construction is called a 
      cast.]
   -------
   From: rb@ccivax.UUCP (rex ballard)
   Newsgroups: net.lang.c
   Subject: Re: Need help with C (struct comparison)
   Date: 7 Feb 86 23:17:44 GMT
   Organization: CCI Telephony Systems Group,  Rochester NY
   In article <124@dg_rtp.UUCP> throopw@dg_rtp.UUCP writes:
   >    struct datestruct date;
   >    struct dbstruct dbase[63];
   >
   >    I try to do a comparison between these, i.e.
   >
   >        ( date == dbase[loop].date )
   >
   >    but the compiler blows up on this, saying the two are incompatible.
   The basic problem is that the 'C' doesn't do composite comparisons.
   Suppose you declared datestruct as
   struct datestruct {
     int yy; /* year */
      int mm; /* month */
      int dd; /* day */
   }
   On a 68000 machine you could use bcmp();
   But on a VAX, 808X, or PDP-11, byte ordering of words is not Most 
   Significant to Least Significant, therefore the code would be 
   non-portable.
   What you need here is a function to compare two dates; Of course you need
   functions to compare other complex types as well.
   You could use an object oriented language such as C++ which would be able
   to interpret this as a function call to a complex structure type.
   Some C compilers are able to do assignment automatically by using bcopy, 
   because the order will be preserved automatically.  However, this is a 
   relatively new feature, and is not really portable unless you use an 
   actual call to bcopy().  The same is true with passing structures and 
   arrays (rather than just pointers) to functions.
   What an object oriented language (C++ or Objective C) does for you is to 
   intercept the '==' and the two types and call the appropriate structure 
   comparison routine (which may be automatically generated in some 
   languages).
   This is one of the reasons the 'sort()' routine has such an unusual 
   calling sequence.
   Of course, one advantage of C is that you don't automatically get compare
   routines for every composite structure you want to use.
   If you can, go back a few articles in this group and read some of the 
   comments on these 'Object Oriented' versions of the language.
   Perhaps a variation of C++ will become a standard superset of the 
   standard language.  It would be nice to have addition, subtraction, 
   assignment, concatenation, 'to ascii', print, input, and file I/O of 
   complex types. How about a capability for specifying which of these 
   operations you actually plan to use (something many OOL's lack) either at
   declaration time or by the linker?  Or am I the only one who has ever had
   to write stubs for the 'printf/scanf floating point' to make an 
   application fit the constraints of the machine?
      -------
   From: ansok@spp3.UUCP (Gary Ansok)
   Newsgroups: net.lang.c
   Subject: Re: type cast in initializer
   Date: 7 Feb 86 23:15:55 GMT
   Organization: TRW, Redondo Beach  CA
   > int     x = 0;
   > char    *ptr = (char *) &x;
   Even if the pointers (int *) and (char *) have different formats, the 
   assignment should take care of the conversion, so the cast should be 
   unnecessary.  A cast in an assignment var_1 = (type) var_2 is never 
   strictly necessary, except for readability (a good reason!), to keep lint
   happy, or to work around bad compilers.  (The cast *should* be acceptable
   to the compiler, though).  As I understand it, a cast has the effect of 
   an assignment to a temporary unnamed variable; sqrt((double) i) is 
   equivalent to (tmp_double = i, sqrt(tmp_double)).
   Are there any other cases where casts are NEEDED besides:
      function calls:  doub_var = sqrt((double) int_var); pointer punning: 
      long_var = *(long *) char_ptr;
   Note: that last example is NONportable and downright dangerous on 
   machines with alignment requirements.  Still, it gets used by a lot of 
   programmers (including me, on occasion...sigh).
                     Gary Ansok
                     {ihnp4,ucbvax,decvax}!trwrb!trwspp!spp3!ansok
      -------
   From: henry@utzoo.UUCP (Henry Spencer)
   Newsgroups: net.lang.c
   Subject: Re: ANSI C and function prototypes
   Date: 6 Feb 86 21:25:30 GMT
   Organization: U of Toronto Zoology
   >   ...Is there any way to prototype the second argument as a pointer to
   > a function returning 'anything'?  I realize if I prototype the second >
   argument as a 'void *pointer', any pointer will be properly converted, > 
   but this defeats my purpose of checking to make sure that the second > 
   argument is really a function pointer...
   Prototyping it as "void *" is wrong too, and a strict ANSI-compliant 
   compiler will reject use of it as illegal.  "void *" is a generic *data* 
   pointer, and function pointers are not data pointers.  The ANSI drafts 
   say that mixing function pointers and data pointers is illegal, period, 
   although it is listed in the relevant appendix as a "common extension". 
   It certainly is a potential portability problem even if the compiler 
   permits it.
   --
                             Henry Spencer @ U of Toronto Zoology
                             {allegra,ihnp4,linus,decvax}!utzoo!henry
      -------
   From: gwyn@brl-smoke.ARPA (Doug Gwyn )
   Newsgroups: net.lang.c
   Subject: Re: type cast in initializer
   Date: 10 Feb 86 03:19:13 GMT
   Organization: /usr/local/lib/news/organization
   In article <269@spp3.UUCP> ansok@spp3.UUCP (Gary Ansok) asks:
   > Are there any other cases where casts are NEEDED besides: >
   > function calls:  doub_var = sqrt((double) int_var);
   > pointer punning: long_var = *(long *) char_ptr;
   Type casts are also useful in expressions, to avoid introducing a 
   temporary variable just to accomplish a type conversion.  One example is 
   casting a (char) to an (unsigned char) before putting it into an (int) 
   variable, to prevent sign-extension.  Another is casting a (long) to an 
   (unsigned long) before a right-shift, to avoid sign-propagation.  A third
   case is converting an (int) to a (long) early in an integer expression, 
   to ensure that the operations will not overflow.
   But it is true that type casts should be used sparingly, and never to 
   compensate for sloppiness in declaring data types.
   C note of the day: 'x' is of type (int), not (char).
      -------
   From: throopw@dg_rtp.UUCP
   Newsgroups: net.lang.c
   Subject: Re: type cast in initializer
   Date: 9 Feb 86 20:43:31 GMT
   [ The case under discussion:
           int     x = 0;
           char    *ptr = (char *) &x;
   ]
   [keesan@bbncc5.UUCP]
   > >    In any case, I'm not sure why you'd want to do what your example 
   does,
   > >since the cast here is a no-op.
   [hadron!jsdy@seismo.{CSS.GOV,ARPA,UUCP}]
   > Two reasons are immediately obvious.  The less compelling is that > 
   lint tells you to.  The more compelling is that on some computer > 
   architectures, e.g. one with type-tagged pointers, the cast may > [ NOTE:
    n o t  "will", just "may" ] not be a no-op.  Some compilers > will even 
   reject the un-cast initialisation out of hand.
   Acutally, for K&R C, Keesan is correct.  I was about to post just about 
   what Yao posted, but I looked it up in K&R, and found two interesting 
   points, the first about casts, and the second about initializations.
      [from The Book, page 42, paragraph 3, line 5, read in the style of a 
      Gregorian chant for best effect]
      The precise meaning of a cast is in fact as if *expression* were 
      assigned to a variable of the specified type, which is then used in 
      place of the whole construction.
      [from The Book, page 198, paragraph 5]
      When an initializer applies to a *scalar* (a pointer or an object of 
      arithmetic type), it consists of a single expression, perhaps in 
      braces.  The initial value of the object is taken from the expression;
      the same conversions as for assignment are performed.
   I'm not sure what ANSI says about it, but it's probably something 
   similar.
   So, casts are equivalent to assignment, and initialization (for scalars) 
   is equivalent to assignment, therefore initialization is equivalent to a 
   cast, and the explicit cast is redundant.  But I'd still put it in, 
   myself, since
   > Come to think of it, the 'lint' reason is not less compelling.
   is right on the money... if you are doing something perverse like this 
   with types, you had better justify yourself to lint (or some other 
   typechecker).  If you don't lint your code and pay attention to what lint
   says, you are just coding in a peculiar assembly language. --
   Wayne Throop at Data General, RTP, NC
   <the-known-world>!mcnc!rti-sel!dg_rtp!throopw
      -------
   From: sue@sfmag.UUCP (S.M.Stanziano)
   Newsgroups: net.lang.c
   Subject: C Aggregate Initialization
   Date: 10 Feb 86 15:54:05 GMT
   Organization: AT&T Information Systems, Summit, NJ
   I am taking a survey at Larry Rosler's behest
   for the benefit of the ANSI C committee.  Although this article is LONG, 
   I hope you will plow through it and let me know if you would be affected 
   by the proposal that I outline below for initialization of aggregates 
   (structs, arrays).
   The gist of the problem is that most PCC-based
   compilers handle some of these initializations
   (cases described below) differently from the way
   K&R describes them, which is one of the
   ways the ANSI committee is considering defining
   aggregate initialization.  Furthermore, it is
   hard to formalize exactly what PCC-based compilers are doing.
   Consider this declaration:
   struct outer {
      struct inner {
         int i[3];
      } a;
      char * b;
   };
   If you initialize an array of these and include
   all of the { }'s, most compilers are happy:
      struct outer a1[] = {
         { {1, 2, 3}, "hello" },
         { {4, 5, 6}, "world" }
      };
   Problems arise when you omit { }'s:
      struct outer a2[] = {
         { 1, 2, 3, "hello" },
         { 4, 5, 6, "world" }
      };
   PCC-based compilers complain about this
   because they treat the { next to the 1 as the
   beginning of a2[0].i, rather than the beginning
   of a2[0].
   PCC-based compilers currently accept this code, which is wrong according 
   to K&R:
      struct outer a3[] = {
         {1, 2, 3}, "hello",
         {4, 5, 6}, "world"
      };
   The correct interpretation, according to K&R, is that {1,2,3} initializes
   a3[0].  Thus "hello"
   is an attempt to initialize a3[1].i[0],
   and that's a type mismatch.
   Here's a case where both PCC-based compilers
   and K&R would accept the C code, but the
   interpretation would be different:
      struct st {
         int a[3];
         int b;
      };
      struct sta[] = {
         { 1 },
         2
      };
   In the PCC interpretation
   sta[0].a[0] is 1 and sta[0].b is 2.
   In the K&R interpretation,
   sta[0].a[0] is 1 and sta[1].a[0] is 2.
   (sta[0].a[1], sta[0].a[2], and sta[0].b
   are all zero.)
   Summary:
      1. PCC-based compilers handle initializations
         with all { }'s as K&R says.
      2. If the initialization lists all members and omits all (but the 
      outermost) { }'s PCC and K&R agree.
      3. When some members are missing and some { }'s are omitted, there are
      three possible conflicts:
         a. PCC rejects, K&R accepts
         b. PCC accepts, K&R rejects
         c. both accept and give different behavior
   ====== QUESTION TO YOU =====
   Cases b and c WILL BREAK your code.  Do you have any initializations that
   would be broken by the K&R
   interpretation?  If so, would such a change cause
   you serious trouble.  (Case c is more worrisome than Case b because it is
   silently different.)
   I particularly want to hear from people with Case c examples or who 
   otherwise consider this a serious
   compatibility problem.
   I will welcome (preferably short) code
   examples that exhibit compatibility problems.
   Please do a "cc -P ..." and send me the .i file.
   David Kristol, AT&T-ISL
   attunix!dmk
   (201) 522-6162
      -------
   From: jsdy@hadron.UUCP (Joseph S. D. Yao)
   Newsgroups: net.lang.c
   Subject: Re: type cast in initializer
   Date: 10 Feb 86 17:22:44 GMT
   Organization: Hadron, Inc., Fairfax, VA
   Summary: reply/explanation?
   In article <1100@lsuc.UUCP> msb@lsuc.UUCP (Mark Brader) writes: >In 
   regard to...
   >> > >    int     x = 0;
   >> > >    char    *ptr = (char *) &x;
   >> >    In any case, I'm not sure why you'd want to do what your example 
   does,
   >> >since the cast here is a no-op.
   >Joseph S. D. Yao responds...
   >> Two reasons are immediately obvious...
   >
   >and goes on to give three reasons.  Two are excellent, but the other is 
   wrong: >> ... on some computer
   >> architectures, e.g. one with type-tagged pointers, the cast may >> [ 
   NOTE:  n o t  "will", just "may" ] not be a no-op.
   (and this was the non-obvious, third reason.)
   >If this is not a slip, it stems from a misconception of casting which 
   >is a Frequently Repeated Error in this newsgroup.  ... >The cast 
   specifies a conversion.  ...
   >In the case of type-tagged pointers, the cast specifies that the 
   >pointer tagged "int" is to be converted to one tagged "char" and >stored
   in the variable, but so would the initialization or assignment >without 
   the cast, if the compiler accepts it at all.
   Perhaps this is my mistake, but I don't see what you have said that 
   differs from mine.  Yes, it specifies a conversion (if necessary). 
   Therefore the cast may possibly not be a no-op.  As you note, to even 
   compile with some compilers, it may be required.  Even if it is not 
   required, however, then it is implicit and (possibly) not a no-op.  The 
   fact that it is required to be explicit on some machines and not cared 
   about on others implies that you should use it if you desire that your 
   code be more "portable".  Does this explain why I say that it may not be 
   a no-op?
   --
     Joe Yao         hadron!jsdy@seismo.{CSS.GOV,ARPA,UUCP}
      -------
   From: jsdy@hadron.UUCP (Joseph S. D. Yao)
   Newsgroups: net.lang.c
   Subject: Re: ANSI C and function prototypes
   Date: 11 Feb 86 04:11:44 GMT
   Organization: Hadron, Inc., Fairfax, VA
   Summary: (void *) in spcl cases; else union.
   In article <681@harvard.UUCP> steve@harvard.UUCP (Kaufer - Lopez - 
   Pratap) writes:
   > Let's say I want to write a 'dispatcher' routine that is
   >passed a code number and a pointer to a function to call. >I wish to use
   a prototype to make sure that I am always passing >two arguments, the 
   first of which is an int and the >second of which is a function pointer.
   > I might define the prototype as:
   > dispatcher(int code, void (*disp_func)());
   > Is there any way to prototype the second argument as a pointer to
   >a function returning 'anything'?
   If 'anything' is limited to pointers, you can say: int dispatcher(int 
   code, void *(*disp_func)());
   as I understand it.  (If you are going to explicitly declare the 
   arguments to your functions, then by all means declare the function 
   itself!!)  Otherwise, if you want to include scalars and structures, you 
   must build a union and have the prototype return that.  Of course, since 
   no one but EcoSoft (tentative as that is) has prototyping, there's no 
   compiler to check this against.  (I don't have EcoSoft C.)
   --
     Joe Yao         hadron!jsdy@seismo.{CSS.GOV,ARPA,UUCP}
      -------
   From: nather@utastro.UUCP (Ed Nather)
   Newsgroups: net.lang.c
   Subject: Re: type cast in initializer
   Date: 11 Feb 86 14:50:12 GMT
   Organization: U. Texas, Astronomy, Austin, TX
   In article <792@brl-smoke.ARPA>, gwyn@brl-smoke.ARPA (Doug Gwyn ) writes:
   > C note of the day: 'x' is of type (int), not (char).
   *sigh*  -- thanks, Doug.  I just found that out yesterday, the hard way. 
   The values of '\377' and -1 are one and the same without a type cast. 
   Now, if I'd just read the news, instead of debugging ... --
   Ed Nather
   Astronomy Dept, U of Texas @ Austin
   {allegra,ihnp4}!{noao,ut-sally}!utastro!nather
   nather@astro.UTEXAS.EDU
      -------
   From: gwyn@brl-smoke.ARPA (Doug Gwyn )
   Newsgroups: net.lang.c
   Subject: Re: type cast in initializer
   Date: 14 Feb 86 09:03:56 GMT
   Organization: /usr/local/lib/news/organization
   >The values of '\377' and -1 are one and the same without a type cast.
   Well, on some architectures they are and on some they aren't. X3J11 
   appears to have decided that they are the same whenever a plain (char) is
   treated as (signed char); otherwise '\377' has the value 255.  I don't 
   like this, but I suspect it's in the rules for "historical reasons".
      -------
EXT-pkm-pierce-uucp-8O6V0 19-Feb-86 Wanted:Compaction Algorithm
   From: {"P.K. Maheshwari" <pkm%pierce.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-pkm-pierce-uucp-8O6V0 / <207@pierce.UUCP>
   Posted: 19-Feb-86 11:26-PST  Received: 27-Apr-86 15:43-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 22 Feb 86 18:03:10 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a006236; 22 Feb 86 20:53
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a000508; 22 Feb 86 20:39 EST
   Newsgroups: net.lang.c,net.unix
   Xref: seismo net.lang.c:8070 net.unix:7513
      TO WHOM IT MAY CONCERN
      ----------------------
   I am in need of a packing algorithm which works better than the PACK 
   Utility of UNIX.  I have also looked at COMPRESS ( developed at 
   University of Utah ).  COMPRESS works great if distinct number of input 
   bytes is small.  But if the distinct input bytes reach 256 ( binary data 
   ), PACK works better than COMPRESS.  With PACK I am getting a saving of 
   20-25%.  If anybody has an algorithm that would do better in packing 
   "load modules", I would like to know about it.
   THNX...........Padam
   Name:                     Padam Maheshwari
   Phone:                    (201) 580-4552
   Organization:             AT&T Bell Labs
   Address:          3ND15
                     184 Liberty Corner Rd
                     Warren, NJ 07060-0908
   NET Mail Address: ihnp4!pierce!pkm
EXT--LYNNE-8O6WF 27-Apr-86 C compilers for the Apple IIe
   From: {"LYNNE C MOORE"@BRL.ARPA}DDN
   Reply-to: {"LYNNE C MOORE"@BRL.ARPA}DDN
   To: {info-c <info-c@BRL.ARPA>}DDN
   Cc: moorel@BRL.ARPA
   Identifier: EXT--LYNNE-8O6WF
   Posted: 27-Apr-86 00:00-PST  Received: 27-Apr-86 15:43-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 22 Feb 86 18:30:23 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a006322; 22 Feb 86 21:19
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id a001608; 22 Feb 86 21:02
   EST
   Received: from eglin-vax.arpa by AOS.BRL.ARPA id a006232; 22 Feb 86 20:50
   EST
   MMDF-Warning:  Parse error in original version of preceding line at 
   BRL.ARPA
   MMDF-Warning:  Parse error in original version of preceding line at 
   BRL.ARPA
      I recently saw an ad for both a C++ and a Hyper C compiler for the 
      Apple IIe in a recent issue of inCider magazine. They were being 
      advertised by WSM Group, Inc., of Tuscon, Az. Has anyone heard 
      anything about either of these products, the company, whether they 
      come with a linker which produces executable code, etc? If they do 
      provide all the capabilities needed to prod- uce executable code, then
      they are quite reasonably priced.
      Lynne C. Moore <moorel@eglin-vax.arpa>
   ------
EXT-brooks-8O6ZJ 19-Feb-86 Re: Stack Frames
   From: {"Eugene D. Brooks III" <brooks@LLL-CRG.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-brooks-8O6ZJ / <1269@lll-crg.ARpA>
   Posted: 19-Feb-86 15:39-PST  Received: 27-Apr-86 15:43-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 22 Feb 86 19:25:55 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a006431; 22 Feb 86 22:13
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a003027; 22 Feb 86 21:32 EST
   Newsgroups: net.lang.c
   The idea of creating a new context with each entry to a {} block, or at 
   least for some very special ones, has some merit worth thinking about.  
   Suppose you have extended C for parallel programming.
   main()
   {
      int i;
      int shared;
      forall(i from 0 to 9) {
         int private;
         /* lines of code */
      }
   }
   if the forall loop is looked at as a fork of 10 lines of control which 
   join up at the closing brace then the opening brace must do something 
   special to the stack frame so that 10 seperate copies of 'private' are 
   generated.  The int 'shared' is on the stack of the parent and can be 
   read or written by all of the lines of control but the stack splits into 
   10 segments at the opening brace of the forall loop.
EXT-jst-abic-uucp-8O80E 18-Feb-86 Re: Integer division
   From: {Shack Toms <jst%abic.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-jst-abic-uucp-8O80E / <739@abic.UUCP>
   Posted: 18-Feb-86 12:17-PST  Received: 27-Apr-86 15:43-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 23 Feb 86 06:29:07 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a007795; 23 Feb 86 9:25 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a009703; 23 Feb 86 9:15 EST
   Newsgroups: net.lang.c
   > [ Thomas Spencer writes...]
   > There is of course, always another way to look at it.  The '%' operator
   > is not defined to be MOD, it is defined such that
   >         (a/b)*b + a%b = a
   > In other words, it is the REMAINDER upon dividing a by b.  Now, if you 
   > want a%b to always be positive, you must then have
   >         (-a)/b != -(a/b)
   > which, I think you will agree, is much worse....
   This property [(-a)/b == -(a/b)] is *not* guaranteed by the definition of
   % in C.  An implementation of C is free to return nonnegative remainders,
   so long as the implementation of / rounds toward -infinity.  This 
   property does not seem all that precious to me, though.  Anyone who 
   writes code which utilizes the entire range of int soon learns not to be 
   too cavalier with negation, since the range of int is not always 
   symmetric about 0.
   > ...  If you really want MOD,
   > here it is:
   > mod(a,b)
   > {
   >         return (( a % b ) + b) % b;
   > }
   And if you really want quotients to round toward 0 and negative 
   remainders [although I believe this is desired less frequently] you had 
   better write those too.
EXT-herndon-umn-cs-uucp-8O81B 17-Feb-86 Arcane C hacks?
   From: herndon%umn-cs.uucp@BRL.ARPA
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-herndon-umn-cs-uucp-8O81B / <1700003@umn-cs.UUCP>
   Posted: 17-Feb-86 20:44-PST  Received: 27-Apr-86 15:43-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 23 Feb 86 06:45:56 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a007819; 23 Feb 86 9:36 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a009819; 23 Feb 86 9:18 EST
   Newsgroups: net.lang.c
   Nf-ID: #N:umn-cs:1700003:000:1667
   Nf-From: umn-cs!herndon    Feb 17 22:44:00 1986
      I wrote a mild flame in another newsgroup about this, but somebody out
      there might know another way.
      The problem is this:  I'd like to construct a jump table by putting 
      lots of labels into an array, and then issuing a statement like
         goto jumptab[i];
   Unfortunately, labels are no longer simple integers (and haven't been for
   most of a decade now).  They can no longer be type coerced to integer or 
   pointer-to-integer, nor can other types be coerced to type label.  Is 
   there any way around this?  Admittedly, for the static case with a dense 
   list, a switch statement usually constructs a jump table, but I'd like to
   construct one on the fly.
      If I just want to execute machine code out of an array ("goto 
      array_name;" used to be legal C) I can write a simple assembly 
      language routine of one argument to do it.  Is there a legal way to do
      this in pure C any more?  (Yes, one can type coerce the address of the
      array to pointer-to-function and call it, but is it possible to jump 
      to the array?)
      Both of these problems are admittedly things one would not often do.  
      They are, however, things one might do in an interpreter. The former 
      operation may be considered to be "machine independent", as there is 
      one reasonable, consistent interpretation.  The latter is much more 
      open to question, as the contents of the array are not machine 
      independent.  However, if one is to write portable inter- preters, 
      being able to jump to an array without assembly language help would be
      a plus.  (Individual pseudo-machine operations can then be relegated 
      to data tables, leaving the C code machine independent.)
                                     Robert Herndon
                                     ...!{ihnp4|stolaf}!umn-cs!herndon
EXT-info-c-request-8P0D7 24-Feb-86 info-c lost message: the integer division
discussion
   From: {Mark Plotnick (MIT) <info-c-request@BRL.ARPA>}DDN
   To: info-c-arpa@BRL.ARPA
   Identifier: EXT-info-c-request-8P0D7
   Length: 10 page(s)[estimate]
   Posted: 24-Feb-86 07:28-PST  Received: 27-Apr-86 15:44-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 24 Feb 86 07:55:28 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a017561; 24 Feb 86 10:39
   EST
   [ I cut out a couple of messages that said nothing except "please stop 
   the discussion".  -- mp ]
   From: weemba@brahms.BERKELEY.EDU (Matthew P. Wiener) Newsgroups: 
   net.lang.c,net.arch
   Subject: Re: Integer division
   Date: 2 Feb 86 04:29:52 GMT
   Organization: University of California, Berkeley
   Summary: nyeah nyeah nyeah
   WARNING!  The following article contains heavy flamage and sarcasm and no
   smiley faces.  And it is not guaranteed to be interesting, accurate or 
   informative.  Any worse and it would have been rot13ed. Read at your own 
   risk.
   Last chance to hit the 'n' key!
   In article <4917@alice.UUCP> td@alice.UucP (Tom Duff) writes: >Pardon my 
   flamage, but what sort of nonsense is this: >[in reference to divide 
   instructions that give -(a/b)=(-a)/b] >>I have NEVER seen an instance 
   where the first one is preferable.  Not >>only is it not preferable, it 
   is just incorrect. >Wrong!
   Which sentence is wrong?  It is an undeniable fact that *I* have never 
   seen such instances, but you do include that as some "sort of nonsense".
   >        That's the definition.  It can't be incorrect.  It might be 
   different
   >from what a number theorist wants, but by no stretch of the imagination 
   can >it be called incorrect.  A mathematician should be able to to handle
   this >elementary concept.
   Of course it can be incorrect!  'correct' has the meanings of 'logically 
   correct', in particular definitions must be tautologically correct, 
   normally the proper usage within pure mathematics, and secondly of 
   'proper to do', as in "If I define f(a):=xyz, that is incorrect, because 
   what users want is f(a):=xyzz".  Which sense seems appropriate here?
   To quote from E W Dijkstra, "How Do We Tell Truths that Might Hurt", "...
   an exceptionally good mastery of one's native tongue is the most vital 
   asset of a competent programmer".  I must thank Tom Duff for illustrating
   that assertion so vividly.
   >>Why such a routine
   >>has been allowed to be 50% inaccurate in every existing language all 
   >>these years is beyond me.
   >Well, it's that way because that's the way it's defined in the ANSI 
   Fortran >standard, and Fortran is probably a Good Thing for a computer to
   support --
   And of course it is important that C and other languages copy Fortran's 
   mistakes.  That way we won't have to strain our brains that much.  I 
   mean, why bother implementing what users want?
   Or am I confused, and Fortran did everything perfectly right off the bat,
   and every language since then has only confused people (like myself)?
   By the way, just out of curiosity mind you, this question popped into my 
   head out of nowhere, but is anyone out there still using card readers?
   >certainly more important than niggling know-nothing number-theoretic 
   nonsense.
   Oh wow, a Spiro Agnew fan!  Or is William Safire your ghost-poster?
   >Why does Fortran do it that way?
   >Probably because the IBM 701 did it that way.
   Let's all take a deep bow for backwards compatibility!  <Clap Clap>
   >                                               Why did the IBM 701
   >do it that way?  Well, at the time people thought that a divide 
   >instruction that satisfied certain identities was more important >than 
   mod function behavior.
   Is that opinion or fact?  I've sent the question off to the man who wrote
   the original Fortran compiler.
   >                             Certainly in most of the applications
   >for which Fortran was designed (i.e. engineering numerical calculations)
   >the behavior of the mod function is of minimal interest.
   Of course it is of minimal interest in most applications!  So what is 
   wrong with getting it right--excuse me, in case my digression earlier 
   wasn't that clear--what is wrong with implementing the more common 
   application that does occur?
   >In any case, why should you be worried that some operation you want to 
   do >isn't primitive.  Most programming languages don't provide arithmetic
   >on multivariate polynomials with arbitrary precision rational 
   coefficients >either (which I want more often than I want a 
   number-theoretic mod function.)
   And if they did, and all did it incorrectly--can you guess which meaning 
   I'm using?--you'd be annoyed too.
   >In any case, it's fairly easy to write:
   > a=b%c
   > if(a<0) a+=c
   >I can't believe that you couldn't discover this code sequence yourself. 
   >(Note that it works whether the range of b%c is [0,c) or (-c,c) -- the 
   >C language definition allows either.)
   Your beliefs are accurate.  What I can't believe is that I should have to
   do something so stupid myself each time.  So close, and yet so far.
   >>[Whether CS people should even be *allowed* to make such mathematical 
   >>decisions is another question.  In C on UNIX, for example, one has 
   >>log(-x) == log(x), a rather dangerous identity, not based on anything 
   >>comprehensible.  Thus, the implementation of general exponentiation, 
   >>a**b = pow(a,b) = exp( b*log(a) ) will silently return the wrong value 
   >>if a is negative.  (Try taking cube roots this way!)] >This sort of 
   nonsense makes me wonder whether the writer should be >allowed to make 
   *any* sort of decision at all.  No plausible definition >of the log 
   function will let you use it to take cube roots of arbitrary >reals in 
   this manner.
   I agree, both about the "sort of nonsense" advocated inducing wonder and 
   the impossibility of defining log to take arbitrary *odd* roots.  [To 
   take cube roots plausibly requires defining log(-a):=log(a)+3*pi*i.]  The
   example comes from a numerical analysis class I was teaching, where the 
   students solved y'=y^third.  I forgot that a lot of the students would 
   not know that a**b cannot be used with a<0, and those who programmed in C
   got silently burned because of that "rather dangerous identity".
   And this is an example of my complaint.  If one is doing a *mathematical*
   problem on the computer, one should not have to keep second guessing what
   the language is doing with the *mathematics*!  We all can argue about the
   little things in languages that bug us--does ';' terminate or separate, 
   for example--but certain little things, like what is a%b when a<0, don't 
   seem to be decided without regard for their mathematical reasonableness. 
   And then try to find a description in the manual of what was actually 
   implemented!  [The WORST offenders are random number generators.  I have 
   ended up writing my own because the one given is proprietary etc.  UGH!]
   In the cube root of negative numbers example, there is no implementation 
   that returns the correct--back to the logical sense--answer, so the 
   proper thing to do is crash the program, and not return something for the
   sake of returning something.
   The CRAY-1's floating point multiply shaves many nanoseconds by a method 
   that only gets 47 out of the 48 bit mantissa.  That is clearly incorrect.
   In this case, I can only admire Seymour's boldness and imagination to 
   take this step, and the lost bit seems worth it.
   Is there a similar reason to have (-a)/b == -(a/b) ?
   >On a higher level of discourse, this writer (Matthew P Whiner) seems
         ^^^^^^                                            ^^^^^^
   Emerson once said "Consistency is the hobgoblin of little minds".  So sue
   me for having a little mind.
   >to think that mathematicians enjoy some sort of moral and intellectual 
   >superiority to engineers and computer scientists.
   Well, maybe a little.  It depends on the engineer/computer scientist.
   >                                                   Usually, this
   >attitude is a symptom of envy, since mathematicians are so hard to 
   >employ, can't get decent salaries when they do find work, and have >a 
   much harder time raising grant money.  The smart ones embrace >computer 
   science rather than denigrating it.  The dull ones just >say ``Computer 
   Science? Pfui: that's not mathematics,'' thus demonstrating >their lack 
   of understanding of the nature of mathematics and of >computer science.
   What a bunch of bullshit.
   >In summary:
   > It is better to remain silent and be thought a fool than
   >to speak up and remove all doubt.
   I agree!
   By the way, Tom Duff, have YOU ever seen an example where a%b<0 is 
   preferred?
   ucbvax!brahms!weemba      Matthew P Wiener/UCB Math Dept/Berkeley CA 
   94720
      -------
   From: jer@peora.UUCP (J. Eric Roskos)
   Newsgroups: net.math,net.lang.c,net.arch
   Subject: Re: Integer division
   Date: 3 Feb 86 13:39:12 GMT
   Organization: Concurrent Computer Corporation, Orlando, Fl
   > Pardon my flamage, but what sort of nonsense is this: > [in reference 
   to divide instructions that give -(a/b)=(-a)/b] > >I have NEVER seen an 
   instance where the first one is preferable.  Not > Wrong!  That's the 
   definition.  It can't be incorrect.  It might be > different from what a 
   number theorist wants, but by no stretch of the > imagination can it be 
   called incorrect.  A mathematician should be able to > to handle this 
   elementary concept.
   But it may not be too usable to mathematicians if your definition is 
   different from the generally accepted one... after all, mathematicians 
   are one of the main groups of people these machines are built for...
   Anyway, I thought he was talking about "%", not "/"...  I would think 
   that since
      3 * -2 = -6
   then
      -6 / 3 = -2
   and
      -6 / -2 = 3
   Could someone who is a genuine number theorist please post the way the 
   "modulo" function is supposed to work, and also what number theorists 
   would prefer the results of integer divisions with nonzero remainders to 
   be (for various permutations of signs), so that people who have some say 
   in the way instruction sets get designed can make sure it's done right in
   the future?  Please put "I am a number theorist" at the start of your 
   posting (include some proofs too if you want!) ... this discussion has 
   been going around and around for weeks.
   Better yet, put "Number theory" in the "subject" line ...
   Be sure to post it to net.arch, not just net.math. --
   UUCP: Ofc:  jer@peora.UUCP  Home: jer@jerpc.CCUR.UUCP  CCUR DNS: peora, 
   pesnta
     US Mail:  MS 795; CONCURRENT Computer Corp. SDC; (A Perkin-Elmer 
   Company)
         2486 Sand Lake Road, Orlando, FL 32809-7642     xxxxx4xxx
      "There are other places that are also the world's end ... But this is 
      the nearest ... here and in England." -TSE
   -------
   From: weemba@brahms.BERKELEY.EDU (Matthew P. Wiener) Newsgroups: 
   net.lang.c,net.arch
   Subject: Re: Integer division
   Date: 3 Feb 86 03:23:54 GMT
   Organization: University of California, Berkeley
   In article <561@jplgodo.UUCP> steve@jplgodo.UUCP (Steve Schlaifer x3171 
   156/224) writes: >If you think of % as returning the *mathematical* 
   remainder of a/b then >it should return a value >=0.  On the other hand, 
   to be consistent with this >view, the quotient operator (/) will also 
   have to be modified to preserve >the formulae
   >
   > b=qa+r (0<=r<a)
   > q=b/a
   >
   >i.e. (-3)/2 must be -2 if (-3)%2 is 1. But this then means that (|a|)/b 
   is not >the same as |a/b| for a<0.  Maybe *An Angry Number Theorist* 
   wants this, but it >seems to me to be a trap just waiting for the unwary 
   to fall into.
   [sic:  you go back and forth between a/b and b/a above  :-(]
   But that's what we have been saying all along!  Someone doing integer 
   division, is not doing floating point division, and if he doesn't know 
   that the rules are different, then yes, he will fall into trouble.  There
   are several identities running around that are incompatible.
    (1)            a == (a/b) * b + a%b
    (2)       (-a)/b == -(a/b)
    (3)      (a+b)/b == a/b + 1
    (4)      (a+b)%b == a%b
   Notice that (3) and (4) are compatible with what the number theorists 
   want, but (2) isn't.  Sure the naive user is fooled by (2) under the 
   version we want, but then he's fooled by (3) and (4) in the usual 
   version.  (1) holds when the / and % are both what the number theorist 
   wants or when neither are what the number theorist wants.
   >As for why the restriction of 0<=r<a was decided on, my only guess is 
   that >it then always produces a unique (q,r) for any given (a,b); this is
   a useful >property when you are proving theorems or doing theoretical 
   investigations.
   That is correct.  It is also useful for programming a circular list. 
   -------------------------------------------------------------------------
   ----- Related question: what about floating to integer conversions?  That
   is always done by truncating after the decimal point.  That always seemed
   wrong to me, but it doesn't seem to bother me as much, and I can't 
   remember a time when it got in my way.  (unlike %)
   ucbvax!brahms!weemba      Matthew P Wiener/UCB Math Dept/Berkeley CA 
   94720
      -------
   From: ladkin@kestrel.ARPA
   Newsgroups: net.math,net.lang.c,net.arch
   Subject: Re: Integer division
   Date: 3 Feb 86 19:31:08 GMT
   Organization: Kestrel Institute, Palo Alto, CA
   In article <4917@alice.UUCP>, td@alice.UucP (Tom Duff) writes: > Pardon 
   my flamage, but what sort of nonsense is this: > reals in this manner.
   > [......]
   > On a higher level of discourse, this writer (Matthew P Whiner) seems > 
   to think that mathematicians enjoy some sort of moral and intellectual > 
   superiority to engineers and computer scientists.  Usually, this > 
   attitude is a symptom of envy, since mathematicians are so hard to > 
   employ, can't get decent salaries when they do find work, and have > a 
   much harder time raising grant money.  The smart ones embrace > computer 
   science rather than denigrating it.  The dull ones just > say ``Computer 
   Science? Pfui: that's not mathematics,'' thus demonstrating > their lack 
   of understanding of the nature of mathematics and of > computer science.
   >
   > In summary:
   >         It is better to remain silent and be thought a fool than
   > to speak up and remove all doubt.
   I don't think anybody should pardon this sort of thing. Arrogance and 
   snobbishness are best indulged in
   between consenting adults in private.
   Please let's clean up the discussion. This is an
   important and interesting issue, as shown by the inability of the 
   participants to resolve it easily.
   Peter Ladkin
      -------
   From: mouse@mcgill-vision.UUCP (der Mouse)
   Newsgroups: net.math,net.lang.c,net.arch
   Subject: Re: Integer division
   Date: 3 Feb 86 00:00:44 GMT
   Organization: McGill University, Montreal
   [ Line eaters?  Who ever hea
        Don't you  think this issue  has been beaten to death already?  How
   about just agreeing that  both sorts  of behavior should be provided and
   letting it  go at  that?   We have  different instructions which produce
   this  behavior when the divisor is a power of two (shifts  and divides);
   why can't we just have two sorts of divide?  Some will want one and some 
   the other, as in all religious debates -- and it's surely  not that hard 
   to satisfy both.
   --
                                     der Mouse
   USA: {ihnp4,decvax,akgua,etc}!utcsri!mcgill-vision!mouse 
   philabs!micomvax!musocs!mcgill-vision!mouse
   Europe: mcvax!decvax!utcsri!mcgill-vision!mouse
      mcvax!seismo!cmcl2!philabs!micomvax!musocs!mcgill-vision!mouse
   Hacker: One who accidentally destroys /
   Wizard: One who recovers it afterward
      -------
   From: laura@hoptoad.uucp (Laura Creighton)
   Newsgroups: net.lang.c,net.lang
   Subject: Re: Integer division
   Date: 4 Feb 86 14:21:22 GMT
   Organization: Nebula Consultants in San Francisco
   In article <11689@ucbvax.BERKELEY.EDU> weemba@brahms.UUCP (Matthew P. 
   Wiener) writes: >....  There are several identities
   >running around that are incompatible.
   >
   > (1)           a == (a/b) * b + a%b
   > (2)      (-a)/b == -(a/b)
   > (3)     (a+b)/b == a/b + 1
   > (4)     (a+b)%b == a%b
   >
   >Notice that (3) and (4) are compatible with what the number theorists 
   want, >but (2) isn't.  Sure the naive user is fooled by (2) under the 
   version we >want, but then he's fooled by (3) and (4) in the usual 
   version.  (1) holds >when the / and % are both what the number theorist 
   wants or when neither are >what the number theorist wants.
   While it is true that number theorists want 3 and 4, it is not the naive 
   user who will be fooled by 2.  It is the naive *mathematician*, which is 
   just about everybody.  To non-mathematicians, 2 is a law, with about the 
   same force as the law of gravity, and not something that you can 
   redefine.
   Sure they are wrong about the force of this law -- but blame the way 
   mathematics is taught in hich schools and grade schools.  In the 
   meantime, only the mathematicians, as a class, will have the perspective 
   to see this. Everybody else (again as a class) will look at (-a)/b != 
   -(a/b) and say ***BUG!!!*** So, as a practical matter, the mathematicians
   will have to come up with a work-around, since only they are going to be 
   able to understand what they want. In letting non-mathematicians design 
   the languages they use, mathematicians may have seriously goofed, because
   the non-mathematicians may not understand what it is that the 
   mathematicians want -- if they did they would be mathematicians.  Of 
   course, I am not sure that there is consensus among mathematicians as to 
   what they want.  If there is, maybe they should write their own language.
   [I'm glad I wrote that last line.  It tells me where to post this fool 
   thing, which has been in the back of my mind, bothering me, the whole 
   time I was writing this.  Before that, I was strongly tempted to post to 
   net.philosophy...] --
   Laura Creighton
   ihnp4!hoptoad!laura
   hoptoad!laura@lll-crg.arpa
      -------
   From: thomas@utah-gr.UUCP (Spencer W. Thomas)
   Newsgroups: net.lang.c,net.arch
   Subject: Re: Integer division
   Date: 5 Feb 86 00:52:55 GMT
   Organization: University of Utah, Salt Lake City
   At least C calls it '%', and not 'MOD', as in Pascal.  Unless someone 
   tells you that % means MOD, you have some small chance of realizing that 
   it might not do exactly what you want.
   I would still rather have (-1)/1000000000000 = 0, not -1. --
   =Spencer   ({ihnp4,decvax}!utah-cs!thomas, thomas@utah-cs.ARPA)
      -------
   From: gwyn@brl-smoke.ARPA (Doug Gwyn )
   Newsgroups: net.math,net.lang.c,net.arch
   Subject: Re: Integer division
   Date: 5 Feb 86 23:41:50 GMT
   Organization: Ballistic Research Lab
   What I would like is for the language to provide a notation for obtaining
   BOTH the quotient and the remainder of an integer division in a single 
   operation.  Too often I need both and have to go through extra overhead 
   to get them (many computers compute both parts at the same time).
   (I would also like to get both the sine and the cosine of an angle in a 
   single operation with reduced overhead, but that seems much less 
   feasible.)
   This % vs. Mod debate is rather silly.  C's % operator is NOT repeat NOT 
   intended to be a modulo operator, although people often use it that way 
   for positive operands.  All reasonable mathematicians agree on what the 
   definition of
      a mod b
   is for positive b and negative a.  That should not be confused with what 
   the result of
      a % b
   should be under similar circumstances.  C intentionally hedges a bit on 
   the meaning of % in such a case (which makes that a generally inadvisable
   situation to allow to arise in one's C code).
      -------
   From: omondi@unc.UUCP (Amos Omondi)
   Newsgroups: net.math,net.lang.c,net.arch
   Subject: Re: Integer division
   Date: 4 Feb 86 12:23:32 GMT
   Organization: CS Dept, U. of N. Carolina, Chapel Hill
   > In article <4917@alice.UUCP>, td@alice.UucP (Tom Duff) writes: > > 
   Pardon my flamage, but what sort of nonsense is this: > > reals in this 
   manner.
   > > [......]
   > > On a higher level of discourse, this writer (Matthew P Whiner) seems 
   > > to think that mathematicians enjoy some sort of moral and 
   intellectual > > superiority to engineers and computer scientists.  
   Usually, this > > attitude is a symptom of envy, since mathematicians are
   so hard to > > employ, can't get decent salaries when they do find work, 
   and have > > a much harder time raising grant money.  The smart ones 
   embrace > > computer science rather than denigrating it.  The dull ones 
   just > > say ``Computer Science? Pfui: that's not mathematics,'' thus 
   demonstrating > > their lack of understanding of the nature of 
   mathematics and of > > computer science.
   > >
   > > In summary:
   > >       It is better to remain silent and be thought a fool than
   > > to speak up and remove all doubt.
   >
   > I don't think anybody should pardon this sort of thing. > Arrogance and
   snobbishness are best indulged in
   > between consenting adults in private.
   >
   Presumably this also applies, notwithstanding how angry the number 
   theorists are, to articles implying that all CS types are idiots who 
   don't have the foggiest idea of what they are doing.
      -------
   From: gsmith@brahms.BERKELEY.EDU (Gene Ward Smith) Newsgroups: 
   net.lang.c,net.arch
   Subject: Re: Integer division
   Date: 5 Feb 86 12:10:05 GMT
   Organization: University of California, Berkeley
   Summary: Tom Duff, rot13 before reading.
   In article <4917@alice.UUCP> td@alice.UucP (Tom Duff) writes: >standard, 
   and Fortran is probably a Good Thing for a computer to support -- 
   >certainly more important than niggling know-nothing number-theoretic 
   nonsense.
      Personally, I think we should do everything the way Cobol does it, and
      to hell with niggling nonsense about the "right" way to do numerical 
      computations. So what if floating point arithmetic gets a little 
      screwed up, as long as you can do double entry bookkeeping.
   >Why does Fortran do it that way?
   >Probably because the IBM 701 did it that way.  Why did the IBM 701 >do 
   it that way?  Well, at the time people thought that a divide >instruction
   that satisfied certain identities was more important >than mod function 
   behavior.  Certainly in most of the applications >for which Fortran was 
   designed (i.e. engineering numerical calculations) >the behavior of the 
   mod function is of minimal interest. [DUFF]
      And this attitude shows; what do you think we are complaining about?
   >
   >On a higher level of discourse, this writer (Matthew P Whiner) seems >to
   think that mathematicians enjoy some sort of moral and intellectual 
   >superiority to engineers and computer scientists.  Usually, this 
   >attitude is a symptom of envy, since mathematicians are so hard to 
   >employ, can't get decent salaries when they do find work, and have >a 
   much harder time raising grant money.  The smart ones embrace >computer 
   science rather than denigrating it.  The dull ones just >say ``Computer 
   Science? Pfui: that's not mathematics,'' thus demonstrating >their lack 
   of understanding of the nature of mathematics and of >computer science.
      What are you trying to do here -- prove yourself wrong by 
      self-referential example? Do you really think those mathematicians 
      (the vast majority, I assure you) who think there is some kind of 
      difference between mathematics and Computer Science are wrong? If so, 
      why are you attacking mathematicians but not Computer Scientists? Do 
      you make as much money as your doctor? What about your lawyer?
   >In summary:
   > It is better to remain silent and be thought a fool than
   >to speak up and remove all doubt.
      Tell me the truth -- is this a gag or are you serious???
      To everyone else but Tom Duff -- thank you for letting me blow off 
      years of accumulated steam. To Tom Duff -- thank you for letting me 
      feel that mathematicians *really are* a little bit better than 
      Computer Scientists/ Engineers (in fact, I never thought this before, 
      and I probably won't think it next week).
   ucbvax!brahms!gsmith    Gene Ward Smith/UCB Math Dept/Berkeley CA 94720
   ucbvax!weyl!gsmith      "When Ubizmo talks, people listen."
   -------
   From: franka@mmintl.UUCP (Frank Adams)
   Newsgroups: net.lang.c,net.arch
   Subject: Re: Integer division
   Date: 4 Feb 86 00:05:07 GMT
   Organization: Multimate International, E. Hartford, CT
   We seem to agree that there are three at least somewhat important 
   identities.
   1) (a/b)*b + a%b = a
   2) (a+b)%b = a%b        or  (a+b)/b = a/b + 1
   3) (-a)%b = -(a%b)      or  (-a)/b = -(a/b)
   As a mathematician and as a computer scientist, I cannot accept 
   definitions of these functions for which (1) does not hold.  Given (1), 
   the two forms given for (2) and (3) are equivalent.
   Now, in fact, (3) in the division form is important.  The area I know of 
   where it is important is in financial applications.  Suppose I own 200 
   shares of stock, which I purchased at a total cost of $2,098.75, 
   including commission.  I now sell 100 shares.  I have to compute the cost
   basis for those 100 shares: $1,049.38.  Now, suppose I had a short 
   position with the same cost basis: -$2,098.75.  If I buy back half of 
   these, the rounding has to be done the same way: -$1,049.38.
   Of course, this application is not rounding toward zero; it is rounding 
   to the *nearest* penny.  So what we want for this application is to round
   to the nearest integer, with 1/2 rounded away from zero.  This choice is 
   very common in financial applications.  (By the way, financial 
   applications fairly often divide by negative numbers.)
   There are also a lot of number theoretic algorithms which run faster if 
   the least absolute remainder is used; I once heard a professor of 
   mathematics (Hans Zassenhaus, if memory serves) state that the least 
   absolute remainder is what computer division *should* return.
   I believe that computers (CISC) and programming languages should provide 
   at least three different division and remainder operations: round towards
   0, round towards -infinity, and round to nearest (with 1/2 rounded away 
   from 0).  There is something to be said for round away from zero, and 
   round to +infinity, as well.
   Frank Adams                           ihpn4!philabs!pwa-b!mmintl!franka
   Multimate International    52 Oakland Ave North    E. Hartford, CT 06108
      -------
   From: ladkin@kestrel.ARPA
   Newsgroups: net.math,net.lang.c,net.arch
   Subject: Re: Integer division
   Date: 6 Feb 86 00:28:30 GMT
   Organization: Kestrel Institute, Palo Alto, CA
   (ladkin)
   > > Arrogance and snobbishness are best indulged in > > between 
   consenting adults in private.
   (omondi)
   > Presumably this also applies, notwithstanding how angry > the number 
   theorists are, to articles implying that all > CS types are idiots who 
   don't have the foggiest idea of > what they are doing.
   Yes it does, witness the paragraph you edited out, and my previous 
   postings.
   A plea: please include uucp pathnames so that we on arpa can avoid 
   posting personal replies like this.
   Peter Ladkin
      -------
   From: hansen@mips.UUCP (Craig Hansen)
   Newsgroups: net.lang.c,net.arch,net.math
   Subject: Re: Integer division
   Date: 5 Feb 86 17:59:38 GMT
   Organization: MIPS Computer Systems, Mountain View, CA
   I assume that everyone else is as sick and tired of seeing this dead 
   horse beaten as I am, but I find a point still unstated.
   Several people have asked for mathematical reasons for choosing integer 
   division with rounding to - infinity rather than zero.  I submit the 
   following:
      If you wish to compute an approximation to a/b
      to the NEAREST integer, when a/b is rounded to
      minus infinity, you can use (a+a+b)/(b+b).
      I can think of no expression except those
      that involve conditionals for which this can
      be done when a/b is rounded to zero.
   Craig Hansen
   MIPS Computer Systems
   ...decvax!decwrl!mips!hansen
      -------
   From: jst@abic.UUCP (Shack Toms)
   Newsgroups: net.lang.c,net.arch
   Subject: Re: Integer division
   Date: 6 Feb 86 01:19:40 GMT
   Organization: Allen-Bradley Co., Highland Heights, OH 44143
   > By the way, Tom Duff, have YOU ever seen an example where a%b<0 is 
   preferred?
   I am squarely in the 0<=a%b<b camp.  I don't believe I have ever used a 
   mod function on signed integers when it was not "corrected" with that 
   obnoxious "if (a<0) a+=b".
   However:  One might use a%b<0 iff a<0 in an algorithm which printed the 
   value of an integer in a given radix.  The least significant digit of a 
   in radix b would then be |a%b|.  :-)
   Note:  K&R allows the definition of a%b to take on either of two values, 
   when a<0 or b<0.  This means that, even on the rare (in my experience) 
   algorithm which requires a%b<0 iff a<0, the programmer will have to add 
   extra code to compensate for implementations which always return a 
   non-negative modulus.
   It is the *ambiguity* in the specification which is most disconcerting. 
   Perhaps K&R thought that the performance penalty of implementing a 
   consistent modulus (or divide) was not justified, since negative integers
   are rarely encountered in "C" [this comment cannot be traced to K&R.]  
   However, this performance penalty can be avoided simply by declaring 
   unsigned integers as "unsigned int".  The way the definition is now, one 
   cannot portably take advantage of either implementation of divide.  That 
   is:  even on machines which implement modulus according to the whims of 
   the particular net.flame(r) [:-)], the overhead of either:
      m = a%b;
      if (m<0) m += b;
   or:
      m = a%b;
      if (a<0 && m>0) m -= b;
   is always incurred in portable code.  (Unless your compiler is more 
   intelligent than any of the "C" compilers I have ever used.)
   On the other hand:  the lack of the property
      -a/b == -(a/b)
   Is easily accounted for portably (simply write the expression you mean 
   rather than the other one. :-))
   Disclaimer:  blah blah blah....
   Shack Toms
      -------
   From: earl@mips.UUCP (Earl Killian)
   Newsgroups: net.math,net.lang.c,net.arch
   Subject: Re: Integer division
   Date: 6 Feb 86 21:03:42 GMT
   Organization: MIPS Computer Systems, Mountain View, CA
   Of the languages I'm familiar with, I believe integer division is best 
   handled in Common Lisp.  There are four functions of two arguments: 
   trunc, floor, ceil, and round.  Each divides the first argument by the 
   second and then rounds the result to an integer using round to zero, 
   round to -infinity, round to +infinity, and round to nearest 
   respectively.  The second return value is the remainder of that division.
   Thus:
   (trunc 7 3)       =>  2,  1               ; 2*3 + 1 = 7
   (trunc -7 3)      => -2, -1               ; -2*3 + -1 = -7
   (floor 7 3)       =>  2,  1               ; 2*3 + 1 = 7
   (floor -7 3)      => -3,  2               ; -3*3 + 2 = -7
   (ceil 7 3)        => 3, -2                ; 3*3 + -2 = 7
   (ceil -7 3)       => -2, -1               ; -2*3 + -1 = -7
   (round 7 3)       => 2, 1                 ; 2*3 + 1 = 7
   (round -7 3)      => -2, -1               ; -2*3 + -1 = -7
   The programmer picks what is appropriate.  I have found floor and ceil to
   be the most useful, and trunc somewhat less.  I have never used round.
   Actually these are also functions of one argument: (floor 3.5) => 3 0.5, 
   etc.
      -------
   From: radford@calgary.UUCP (Radford Neal)
   Newsgroups: net.lang.c,net.arch
   Subject: Re: Integer division
   Date: 5 Feb 86 00:16:02 GMT
   Organization: University of Calgary, Calgary, Alberta
   First, let me say that I'm firmly in the (-3)%2 == 1, (-3)/2 == (-2) 
   camp. This is normally what one wants.
   There is one case, however, where the (-3)/2 == 3/(-2) == -(3/2) == -1 
   identity is usefull - writing software floating point routines. I offer 
   this as a suggestion as to why the initial "mistake" was made.
   Now that we "all" have hardware floating point, can we change divide?
   Actually, I'd be satisfied if people would at least *document* what their
   divide operation does! (E.g. the MC68000 processor manual just says "the 
   division is done using signed arithmetic"...)
      Radford Neal
   -------
   From: ark@alice.UucP (Andrew Koenig)
   Newsgroups: net.lang.c,net.arch
   Subject: Re: Integer division
   Date: 7 Feb 86 04:11:12 GMT
   Organization: Bell Labs, Murray Hill
   To add some more fuel to the fire, consider extending a%b to 
   floating-point operands.  If we do this, we find that defining a%b to 
   have the sign of a in all cases allows a%b to be represented exactly as a
   floating-point number, whereas giving a%b the sign of b does not.  
   Consider, for instance, the case where b is huge and positive and a is 
   tiny and negative.
      -------
   From: weemba@brahms.BERKELEY.EDU (Matthew P. Wiener) Newsgroups: 
   net.math,net.lang.c,net.arch
   Subject: Re: Integer division
   Date: 7 Feb 86 21:47:08 GMT
   Organization: University of California, Berkeley
   In article <367@mcgill-vision.UUCP> mouse@mcgill-vision.UUCP (der Mouse) 
   writes:
   >     Don't you  think this issue  has been beaten to death already?
   yes
   > ....
   >why can't we just have two sorts of divide?
   How would you implement that?  If you make one form get / and the other a
   function call, you haven't changed things very much!
   >                                             Some will want one and some
   >the other...
   Is there someone out there who *wants* a/b to round towards 0 (for 
   reasons that say that is the desired result)?  I asked that before and 
   have not seen any affirmatives.
   ucbvax!brahms!weemba      Matthew P Wiener/UCB Math Dept/Berkeley CA 
   94720
      -------
   From: weemba@brahms.BERKELEY.EDU (Matthew P. Wiener) Newsgroups: 
   net.lang.c,net.arch
   Subject: Re: Integer division
   Date: 9 Feb 86 05:58:43 GMT
   Organization: University of California, Berkeley
   In article <1671@utah-gr.UUCP> thomas@utah-gr.UUCP (Spencer W. Thomas) 
   writes: >At least C calls it '%', and not 'MOD', as in Pascal.  Unless 
   someone >tells you that % means MOD, you have some small chance of 
   realizing that >it might not do exactly what you want.
   ??????
   >I would still rather have (-1)/1000000000000 = 0, not -1.
   What about (-999999999999)/1000000000000 ?
   What about (+999999999999)/1000000000000 ?
   ucbvax!brahms!weemba      Matthew P Wiener/UCB Math Dept/Berkeley CA 
   94720
      -------
   From: weemba@brahms.BERKELEY.EDU (Matthew P. Wiener) Newsgroups: 
   net.lang.c,net.arch
   Subject: Re: Integer division
   Date: 10 Feb 86 06:53:59 GMT
   Organization: University of California, Berkeley
   In article <731@abic.UUCP> jst@abic.UUCP (Shack Toms) writes: >However:  
   One might use a%b<0 iff a<0 in an algorithm which printed >the value of 
   an integer in a given radix.  The least significant >digit of a in radix 
   b would then be |a%b|.  :-)
   So would |a|%b, and it works under either convention.  :-)
   ucbvax!brahms!weemba      Matthew P Wiener/UCB Math Dept/Berkeley CA 
   94720
      -------
   From: hofbauer@utcsri.UUCP (John Hofbauer)
   Newsgroups: net.math,net.lang.c,net.arch
   Subject: Re: Integer division
   Date: 10 Feb 86 00:21:24 GMT
   Organization: CSRI, University of Toronto
   > This % vs. Mod debate is rather silly.  C's % operator is > NOT repeat 
   NOT intended to be a modulo operator, although > people often use it that
   way for positive operands.  All > reasonable mathematicians agree on what
   the definition of
   >         a mod b
   > is for positive b and negative a.  That should not be > confused with 
   what the result of
   >         a % b
   > should be under similar circumstances.  C intentionally > hedges a bit 
   on the meaning of %
   To paraphrase Alice In Wonderland loosely, an operator means whatever you
   want it to mean, nothing more, nothing less. The remainder of a machine 
   integer division is defined as being whatever the engineer's found 
   convenient to implement. Any resemblance to mathematics is purely 
   coincidental.
      -------
   From: jsdy@hadron.UUCP (Joseph S. D. Yao)
   Newsgroups: net.math,net.lang.c,net.arch
   Subject: Re: Integer division
   Date: 10 Feb 86 16:54:51 GMT
   Organization: Hadron, Inc., Fairfax, VA
   Keywords: int, div, rem, mod
   Summary: (1) return quot & rem (2) mod != rem (!!!!!)
   In article <685@brl-smoke.ARPA> gwyn@brl.ARPA writes: >What I would like 
   is for the language to provide a notation >for obtaining BOTH the 
   quotient and the remainder of an >integer division in a single operation.
   C doesn't provide a notation for an op with two returns, so this might be
   a little hard.  (How I Did It:)  On a PDP-11 with no FPP and V6 (that 
   long ago), I wrote the long div/rem functions.  Since the work involved 
   was massive, I saved the operands, the quotient, and the remainder.  If 
   subsequent calls had the same operands, I just returned the 
   already-computed values!
   If a div or rem is "cheap", this loses.  However, if it is done in 
   microcode the same way, this technique is recommended to the microcoders.
   >This % vs. Mod debate is rather silly.  C's % operator is >NOT repeat 
   NOT intended to be a modulo operator, although >people often use it that 
   way for positive operands.
   Hooray.  Modulo() != Remainder() except under certain circumstances, as 
   this branch of net.flame has shown.  I was at the point of posting this 
   myself, the discussion was getting so disgusting (not to mention ad 
   hominem -- or ad speciem).
   My degrees and first job titles all said "mathematics".  Subsequent job 
   titles have included phrases like "computer scientist" and "software 
   engineer."  This may qualify me to speak.  (One degree also says "CS", 
   and > 1 decade of experience lends credence to "engineer".)
   I consider each occupation to be superior to the others in what they do. 
   Period.  I don't expect the M or SE to immediately see a CS point of 
   view, nor an SE or CS the M point of view, or any of the other possible 
   permutations.  SE's and programmers have made the remainder function what
   it is because the specs said so -- great!
   CS'ers, who don't use  i m p l e m e n t e d  languages unless they
   have to, are free to use mod() or rem() as they please.  Mathematicians 
   (pure) use anything they want, as long as it's in the realm of pure 
   thought.  Mathematicians (applied) have to use the tools that are 
   available:  so it is necessary for the SE's to provide their users d o c 
   u m e n t a t i o n  that clearly says, e.g., what rem is (it isn't mod, 
   for instance).  Then it is necessary for the users to r e a d  said 
   documentation, before complaining.  Or take a class and  l i s t e n .  
   (No, I'm not saying none of my students ever did -- just the ones that 
   complained most that they didn't
   understand.       ;-})
   All
   >reasonable mathematicians agree on what the definition of
   > a mod b
   >is for positive b and negative a.  That should not be >confused with 
   what the result of
   > a % b
   >should be under similar circumstances.  C intentionally >hedges a bit on
   the meaning of % in such a case (which >makes that a generally 
   inadvisable situation to allow to >arise in one's C code).
   --
     Joe Yao         hadron!jsdy@seismo.{CSS.GOV,ARPA,UUCP}
      -------
   From: gwyn@brl-smoke.ARPA (Doug Gwyn )
   Newsgroups: net.lang.c
   Subject: Re: Integer division
   Date: 14 Feb 86 08:54:44 GMT
   Organization: /usr/local/lib/news/organization
   >... Since
   >the work involved was massive, I saved the operands, the quotient, >and 
   the remainder.  If subsequent calls had the same operands, I >just 
   returned the already-computed values!
   This is a nice example of a "good idea".  It paid off because long 
   division was frequently accompanied by long remainder with the same 
   operands, and the extra bookkeeping overhead per call was more than 
   compensated by the average computational savings.  Thanks, Joe. The 
   obvious generalization can be applied in a variety of codes. A 
   conceptually related example is:
   /*
      RnNorm -- random normal deviate with specified mean & std. dev.
     last edit:      86/01/04        D A Gwyn
     SCCS ID:        @(#)rnnorm.c    1.1
   Method:
      Polar method; see Knuth 3.4.1C(1)
   */
   #include  <math.h>
   #include  <random.h>              /* defines RnFlt() (uniform range) */
   #include  <std.h>                 /* defines "bool", "true", "false" */
   double
   RnNorm( mu, sigma )                       /* return range (-inf,inf) */
     double          mu;             /* desired mean */
     double          sigma;          /* desired std. deviation */
      {
     static bool     saved = false;  /* "have saved value" flag */
     static double   rndsave = 0.0;  /* saved value iff `saved' */
     double          s, x, y;
   if ( saved )
      {
             x = rndsave;            /* already on hand */
             saved = false;          /* now used up */
   }
     else    {
   /* generate a pair of numbers */
             do      {
                     x = RnFlt( -1.0, 1.0 );
                     y = RnFlt( -1.0, 1.0 );
                     s = x * x + y * y;
                     }
             while ( s >= 1.0        /* 0.25 probability */
      || s == 0.0    /* practically never */
                   );
   rndsave = sqrt( -2.0 * log( s ) / s );
      x *= rndsave;
             rndsave *= y;                   /* save for next call */
   saved = true;
   }
   return mu + sigma * x;
      }
   -------
EXT-info-c-request-8P3CO 24-Feb-86 missing info-c articles: lambda 
definitions in C
   From: {Mark Plotnick (MIT) <info-c-request@BRL.ARPA>}DDN
   To: info-c-arpa@BRL.ARPA
   Identifier: EXT-info-c-request-8P3CO
   Length: 5 page(s)[estimate]
   Posted: 24-Feb-86 07:31-PST  Received: 27-Apr-86 15:44-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 25 Feb 86 16:10:41 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a017924; 25 Feb 86 18:50
   EST
   From: rich@rexago1.UUCP (K. Richard )
   Newsgroups: net.lang.c
   Subject: lambda defs in C
   Date: 5 Feb 86 17:39:53 GMT
   Organization: Roadway Express Inc., Akron, OH
   I often find myself creating highly localized register variables in an 
   attempt to synthesize common sub expression optimization:
      {
         register  char _q = *((x.y)->z);
         if (_q == 'a' || _q == 'b' || _q == 'c') { ...
   I also want to return values from arbitrary expressions like a for loop. 
   Lisp has something called a lambda definition which is something like a 
   local temporary function definition. Sort of like:
     if ( lambda int f(register char _q = *((x.y)->z)) {
                     return(_q == 'a' || _q == 'b' || _q == 'c');
             }       /* end of lambda def */ ) { ...
   or
      x = lambda int f() {
         for (...) {
                     ...
                     return(some expression);
                     ...
             }       /* for */
     }       /* lambda */
   So, academically, if we were to add a simlar feature to a new dialect of 
   C, or to construct a pre-preprocessor for ansii C (a la C++), what 
   problems do you see?
   K. Richard Magill
      -------
   From: rose@think.ARPA (John Rose)
   Newsgroups: net.lang.c
   Subject: Re: lambda defs in C
   Date: 7 Feb 86 02:08:21 GMT
   Organization: Thinking Machines, Cambridge, MA
   Keywords: lambda
   (Pls. forgive/correct errs of etiquette; 1st time poster.)
   In article <187@rexago1.UUCP> rich@rexago1.UUCP (K. Richard) writes: 
   >Lisp has something called a lambda definition which is something like >a
   local temporary function definition.
   >So, academically, if we were to add a simlar feature to a new dialect of
   C, >... what problems do you see?
   >
   >K. Richard Magill
   Yes, I've been wishing for this kind of thing too.  We probably all feel 
   that C macrology is greatly complicated by the "statement/expression" 
   distinction; extreme cleverness is sometimes required to turn control 
   flow into commas and question marks.  Finding temporaries to use can be a
   nightmare.
   Here's another reason for wanting lambda's:
   Something called a "lexical closure" can provide an extremely clean way 
   to create special a purpose "message-handling object".  (Why are they 
   always called "object" or "instance" or some equally nondescript name?) 
   First, a digression on closures, then discussion of their relation to 
   "objects", finally syntax and implementation notes.
   Functions may have free variables; in C, a block's free variables are 
   just those which are declared outside that block but used inside it. Most
   languages allow you to take a block of code, declare some of its free 
   variables to be formal arguments, and obtain some value which you can 
   store and later function-call on some actual arguments to execute the 
   original block.  The block is usually allowed to have free variables 
   other than the arguments (there are often restrictions on their nature). 
   At the moment the function-callable value is obtained, we say that the 
   block is "closed", and the "bindings" of the free variables are included 
   in the value obtained.  This is most interesting when the free variables 
   are automatics declared by enclosing blocks, because this implies that 
   the variable must exist as long as EITHER the enclosing block OR the 
   value of the closed block exist.  Note that the bindings, not just the 
   values, are captured, in a lexical closure.  For example, if the code in 
   the closed block ever changes the value of a closed variable, the code 
   from the enclosing block can see the change, and vice versa; also, 
   closures made in the same activation of the enclosing block share 
   bindings.
   In many Lisps, including that of our 3600's, one passes a message to an 
   object by function-calling it with a special message selector as the 
   first argument.  Thus, objects can be declared and created in a single, 
   simple block of code:  (***LISP ALERT***)
      (defun make-char-deletion-stream (instream chars-to-delete) ;; This 
      program is buggy, but illustrative.
         #'(lambda (op &rest args)
            (loop for res = (common-lisp:apply instream op args) unless (and
            (eq op :tyi)
                             (memq res chars-to-delete))
                   return res)))
   You don't need to understand Lisp to understand the following:  The 
   "(LOOP ...)" is the block which is closed; the value obtained is returned
   as the value of the function MAKE-CHAR-DELETION-STREAM.  That block has 
   four free variables:  INSTREAM, CHARS-TO-DELETE, OP, and ARGS. The last 
   two are argument variables.  The first two are automatics which are 
   defined in an enclosing block.  When the LOOP block is closed (by the 
   "#'(LAMBDA...)" construct) the bindings of INSTREAM and CHARS-TO-DELETE 
   are captured; they would ordinarily disappear on exit from 
   MAKE-CHAR-DELETION-STREAM, but now they persist as long as the returned 
   closure value exists.  They are, in fact, "instance variables" in O.O.P. 
   sense.  But what a difference from most object oriented languages!  There
   is no complicated declaration of object contents or operations; 
   everything is in one place.  This is not always desirable: in C it is 
   often necessary to have a declarations file, and perhaps several files of
   implementation, for some data structure.  But for a simple specialization
   of an already-defined data structure, such a syntax cannot be beat.
   So, that's why I like closures.  Now I'll say why they are not always 
   appropriate in plain C, but might find a place in C++.
   In C, block-closings are only allowed at file top level, the closing is 
   done once as a static "initialization", and the "value obtained" is 
   permanently bound to the function symbol.  Note that all free variables 
   in such top-level blocks CANNOT be automatic, and have static 
   (indefinitely long) lifetime.  Therefore there is no reason to add the 
   following restriction, which I commend to your attention:  When a block 
   is closed, all non-argument free variables MUST have static lifetime. In 
   the presence of this restriction, the value of a closed block can be 
   implemented simply as a function pointer (to some anonymous static 
   function, generated by a hypothetical preprocessor).  This is because the
   addresses of static-lifetime variables can be compiled into code.
   If auto variables are to be closed over (something like this is necessary
   to get "instance variables"), then a simple function pointer cannot 
   represent the closure; there must be additional information carried 
   around which says where to find the bindings.  Moreover, the compiler 
   must arrange to put captured automatic variables in the heap.  There is a
   lot of hair in a good implementation of this.  C probably shouldn't allow
   this, because the simple operation of closing (taking the address of) a 
   block implies heap-allocation, a task not regarded as primitive.  Also, 
   captured auto variables are really not auto, a misrepresentation which is
   foreign to C (reference to a captured auto, even in the enclosing block, 
   would require an extra indirection to reference the heap, a hidden 
   inefficiency).
   One could also allow free automatic variables in a closure, and say that 
   use of them is equivalent to indirecting through a pointer taken to the 
   auto variable in question.  Returning such a closure (passing it "up" the
   stack) is just as erroneous as returning the address of an automatic 
   variable. (A compiler could catch common cases of both.)  Passing a 
   closure "down" the stack is fine; this would be done when calling library
   functions like "qsort" or Lisp "MAPCAR", which is probably a common 
   usage.
   By the way, if a variable being closed over is declared "const", the 
   value of the variable itself, not the binding (address of the variable), 
   can be put into the closure.  This can remove a restriction about 
   returning things "up" the stack.  It might be reasonable to do this 
   *always*, and require bindings, when required, to be simulated with 
   addresses (or C++ references).  This latter rule produces only 
   approximate lexical closures; it may be called "capture by value". It 
   eases (implementation of) "upward" closures (e.g., objects), but 
   "downward" closures often want to "capture by reference", say to 
   accumulate a count into a captured variable from inside MAPCAR.
   There is a need to worry about the *type* of the closure value. We'd like
   to pass it to such utilities as "qsort", but you can't store BOTH a 
   static function pointer AND pointer(s) to variable bindings in a single 
   word, and then expect it to be function callable by naive software.  A 
   quick solution would be to allow only one closure from any given block to
   exist at a time, and have static variables for it point to its current 
   bindings.  This would work for "qsort", for example, but fail if the same
   sort were called recursively.  (There are further solutions here, but I'm
   uncomfortable with allowing only one closure. Perhaps others aren't?)
   Another solution is to introduce a new type, which is a struct of a 
   function pointer and some bindings, which is function-callable in the 
   obvious manner.  Since this is a special case of a C++ class (with 
   function-calling overloaded), class-declaration syntax could be extended 
   (I'm still thinking about this one).  Naive code cannot accept these 
   pseudo-function-pointers.
   The best solution would be to in fact "compile code onto the stack", to 
   use a hoary phrase.  The struct (or class) of the previous paragraph 
   would have some bytes inside it which would cause a call to some 
   appropriate static function (which would be the closed block).  Magic 
   code in the function prologue of the static function would examine the 
   return address and deduce the location of the struct, hence the bindings.
    If pointers to such structs are to be returned "up" the stack, they must
   be put in the heap using malloc (or "new" in C++). I've sometimes felt 
   frustrated that in C programs the number of functions is fixed before run
   time.  Function-generating functions are useful.  I'd be willing to 
   manage the heap storage; just give me a way to make such things.  I will 
   return to this below, after some syntax.
   Note that if the address of a closure isn't taken, but it is just 
   immediately function-called, then we needn't worry about types, and 
   inline expansion can be done.  This would be the case with many macros.
   To give an example, we must define some syntax.  I suggest *not* using a 
   new keyword like "lambda".  Consider the cast syntax.  Inside the parens 
   goes a declaration, sans declared identifier and terminating semicolon.  
   Well, extend this to allow the top-level function definition syntax.  The
   function body is syntactically like an initializer, which is not allowed 
   in a cast, so we have our choice of where to put it.  Some possibilities 
   (Yacc allows any, I think):
      (int /*absent_id*/(arg1, arg2) char *arg2;) { /*body*/ } (int 
      /*absent_id*/(int arg1, char *arg2)) { /*body*/ } (int 
      /*absent_id*/(int arg1, char *arg2) { /*body*/ })
   This is an expression syntax.  The semantics are those of a function 
   identifier.  Syntactic precedence should be that of a parenthesized 
   subexpression.  I favor the last, because it is more obviously a 
   syntactic unit, and the contents look most like a file-level form, but 
   the second makes sense too, because it looks like a cast-application. 
   Also, the following rewrite might be considered:
      ({ /*body*/ })
     ==>     (appropriate_type /*absent_id*/(void) { /*body*/ })()
   I.e., the closure is immediately invoked with no arguments.  The type is 
   deduced from all of the return statements, as with "?:".
   Finally!  An example!  Here is a variant of "qsort" which is passed a 
   key-extraction function instead of a comparison function.
      qsort_key(vec, vec_len, vec_size, key_extract)
         void *vec; int key_extract(void *);
     {       /* Sort the vector, using the given key. */
   qsort(vec, vec_len, vec_size,
                     (int (void* p, void* q) /* upward */
                             { return key_extract(p) - key_extract(q); }));
   }
   Also, one can "Curry" a function, say exponentiation:
     double (*make_myexp(const double base))(double exp)
     {       extern double pow(double,double);
      return (double (double exp) /* downward */
                     {       return pow(base,exp);  });
   }
      /* pow(x,y) == make_myexp(x)(y) */
   Here's a "combinator":
     int (*curry_2_1(int (*f)(int,int), int arg1)) (int arg2)
     {       return (int (int arg2) { return f(arg1, arg2); });  }
   Back to implementation.  We want to be able to create function objects.  
   Since C doesn't specify primitives for creating functions, a hypothetical
   pre-processor must generate implementation-dependent code.  One can write
   a mixture of C and assembler code which will initialize a piece of memory
   to look like a function; this function will presumably put the arguments 
   and the closure's data-pointer into standard places and then call the 
   actual code for the block.  A simple example, for the Vax, follows the 
   signature below.  The callable piece of memory might be (as it is below) 
   the initial part of the closure's structure; subsequent parts of the 
   closure struct might contain pointers to the various bindings, and the 
   whole thing could be declared as a struct (or class).
   So, that fourth argument to "sort" is simply the address of a local 
   structure.  In order to return such a thing, it should be saved in the 
   heap (or copied into a waiting buffer).  In order to be moved around, it 
   must be typed, sized, etc.  It may be that the thing would even object to
   being moved (non-PIC, and all that).  Well, at that point it's time to 
   start thinking about C++, with its greater control of initialization and 
   assignment.
   One amusing possibility to think about, regarding C++ extensions, is to 
   make all this happen automatically under certain conditions.  For 
   example, if operator() is virtual (and not overloaded), implement it as 
   above, so that the class is REALLY function-callable.  Also, allow 
   classes to be declared inside blocks, and allow the operator() member 
   function to contain free variables, and interpret such free variables to 
   generate implicit member definitions (which are copies of the original 
   value, or references to the original binding).
   The syntaxes for lambda and expression blocks given above could then be 
   viewed as "sugar" for such class declarations.  Or, if C++ is not 
   desired, one could use small syntactic variations on the lambda construct
   to control whether the closure was allocated on stack ("upward") or heap 
   ("downward"), or data segment ("downward, but 1 at a time").  One might 
   use the storage class specifiers "auto", "extern", and "static", 
   respectively, distinguish those cases.
   At this point I'll make my exit.  Cheers!
   ---------------------------------------------------------- John R. Rose, 
   Thinking Machines Corporation, Cambridge, MA
   245 First St., Cambridge, MA  02142  (617) 876-1111 X270
   rose@think.arpa                           ihnp4!think!rose
   /* Implementation example:  Creation of function objects. */ #include 
   <sys/types.h>
   #include <frame.h>
   extern _tmpl(), _tmplSize, _tmplOff, _tmplRet;
   #define _TMPL_SIZE 12  /*>= ((int)&_tmplSize)*/
   struct _closure { char cl_bits[_TMPL_SIZE]; };
   /* _TMPL is a real function, which serves as a template for our objs. */
   asm("             .text");
   asm("__tmpl:      .word 0");
   asm("             callg (ap), __tmpl_blank");
   asm("tmplRet:     ret");
   asm("tmplEnd:");
   /* Set up some constants: */
   asm("     .set __tmplSize, tmplEnd - __tmpl"); /* sizeof(_tmpl) */
   asm("     .set __tmplRet, tmplRet - __tmpl"); /* offset of ret */
   asm("     .set __tmplOff, __tmplRet - 4"); /* offset of func */
   static _tmpl_blank()
   { abort();  }
   /* This stuff goes into any function which is called by a _TMPL. * It 
   sets up a self-pointer to point to the _TMPL. */
   #define _closure_decls(type,this) \
      register type* this
   #define _closure_inits(type,this) \
             asm("   movl fp,r11"); \
      this = (type*)(((struct frame *)this)->fr_savpc - (int)&_tmplRet)
   void
   _init_closure(func, cl)
      void (*func)(); struct _closure *cl;
   { *cl = *(struct _closure *)_tmpl;
   *(char **)(&cl->cl_bits[(int)&_tmplOff]) +=
      (char *)func - (char *)_tmpl_blank -
      /* pc-relative: */
      ((char *)cl - (char *)_tmpl);
   }
   /* Example of a closure:
      double (*make_myexp(const double base))(double exp) {  return (static 
      double (double exp){ return pow(base,exp); }) }
   *** (*make_myexp(2.71828*))(x) should be equivalent to exp(x), etc. *** 
   *** Curried exponentiation:  pow(x,y) == make_myexp(x)(y) *** */
   /* Preprocessor yields: */
   struct make_myexp_cl { struct _closure cl; double base; }; static double 
   make_myexp_1(exp)  double exp;
   { _closure_decls(struct make_myexp_cl, this);
      extern double pow();
      _closure_inits(struct make_myexp_cl, this);
      return pow(this->base, exp);
   }
   double (*make_myexp(base))()
      double base;
   { struct make_myexp_cl *r;
   r = (struct make_myexp_cl *)malloc(sizeof(struct make_myexp_cl)); 
   _init_closure((void (*)())make_myexp_1, &r->cl);
   r->base = base;
   return (double (*)()) r;
   }
   --
   ---------------------------------------------------------- John R. Rose, 
   Thinking Machines Corporation, Cambridge, MA
   245 First St., Cambridge, MA  02142  (617) 876-1111 X270
   rose@think.arpa                           ihnp4!think!rose
      -------
   From: dmiruke@isis.UUCP (Dataram Miruke)
   Newsgroups: net.lang.c
   Subject: Re: lambda defs in C
   Date: 7 Feb 86 04:45:37 GMT
   Organization: University of Denver Math and Computer Science
   > I often find myself creating highly localized register variables in an 
   > attempt to synthesize common sub expression optimization: >
   >         {
   >                 register  char _q = *((x.y)->z);
   >
   >                 if (_q == 'a' || _q == 'b' || _q == 'c') { ...
   >
   > I also want to return values from arbitrary expressions like a for 
   loop. > Lisp has something called a lambda definition which is something 
   like > a local temporary function definition. Sort of like: >
   >         if ( lambda int f(register char _q = *((x.y)->z)) {
   >                         return(_q == 'a' || _q == 'b' || _q == 'c');
   >                 }       /* end of lambda def */ ) { ...
   >
   > or
   >
   >         x = lambda int f() {
   >                 for (...) {
   >                         ...
   >                         return(some expression);
   >                         ...
   >                 }       /* for */
   >         }       /* lambda */
   >
   > So, academically, if we were to add a simlar feature to a new dialect 
   of C, > or to construct a pre-preprocessor for ansii C (a la C++), what 
   problems > do you see?
   >
   > K. Richard Magill
      Don't the inline functions in C++ provide a similar feature?
                                                     - Datta Miruke
   -------
   From: bs@alice.UucP (Bjarne Stroustrup)
   Newsgroups: net.lang.c
   Subject: lambda defs in C (and C++ inlines)
   Date: 8 Feb 86 21:20:57 GMT
   Organization: Bell Labs, Murray Hill
   > From allegra!mit-eddie!think!harvard!seismo!hao!nbires!isis!dmiruke Wed
   Dec 31 19:00:00 1969 > From: dmiruke@isis.UUCP (Dataram Miruke)
   > Subject: Re: lambda defs in C
   > Organization: University of Denver Math and Computer Science >
   >> I often find myself creating highly localized register variables in an
   >> attempt to synthesize common sub expression optimization: >>
   >>        {
   >>                register  char _q = *((x.y)->z);
   >>
   >>                if (_q == 'a' || _q == 'b' || _q == 'c') { ...
   >>
   >> I also want to return values from arbitrary expressions like a for 
   loop. >> Lisp has something called a lambda definition which is something
   like >> a local temporary function definition. Sort of like: >>
   >>        if ( lambda int f(register char _q = *((x.y)->z)) {
   >>                        return(_q == 'a' || _q == 'b' || _q == 'c');
   >>                }       /* end of lambda def */ ) { ...
   >>
   >> or
   >>
   >>        x = lambda int f() {
   >>                for (...) {
   >>                        ...
   >>                        return(some expression);
   >>                        ...
   >>                }       /* for */
   >>        }       /* lambda */
   >>
   >> So, academically, if we were to add a simlar feature to a new dialect 
   of C, >> or to construct a pre-preprocessor for ansii C (a la C++), what 
   problems >> do you see?
   >>
   >> K. Richard Magill
   > Don't the inline functions in C++ provide a similar feature?
   >
                                                     - Datta Miruke
   Yes, the following is legal C++
      inline int f()
      {
         for (...) {
                     ...
                     return(some expression);
                     ...
   }
   }
   However, the current implementation cannot handle loops or switches in an
   inline, so you get a ``sorry, not implemented'' message. Sorry, we will 
   have to wait a bit longer. The non-looping example can be handled quite 
   nicely using an inline. Inline functions differ from lambdas in that they
   must be defined (outside any function) before they can be used.
      - Bjarne Stroustrup (AT&T Bell Labs, Murray Hill).
   PS Calling the current C++ implementation a pre-processor for C is as 
   accurate as calling C a pre-processor for the assembler. The C++ 
   front-end does a complete typecheck and performs non-trivial code 
   transformations (like inline expansion). It relies on the underlying C 
   compiler for the part of the code generation process (only). ANY message 
   from the C compiler is considered a C++ compiler bug.
      -------
EXT-info-c-request-8P3CU 24-Feb-86 missing info-c articles: want-ads for 
programs and documentation
   From: {Mark Plotnick (MIT) <info-c-request@BRL.ARPA>}DDN
   To: info-c-arpa@BRL.ARPA
   Identifier: EXT-info-c-request-8P3CU
   Length: 2 page(s)[estimate]
   Posted: 24-Feb-86 07:35-PST  Received: 27-Apr-86 15:44-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 25 Feb 86 16:12:06 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a017936; 25 Feb 86 18:51
   EST
   From: cdl@mplvax.ARPA (Carl Lowenstein)
   Newsgroups: net.wanted.sources,net.lang.c
   Subject: Re: C shell to C converter...
   Date: 2 Feb 86 02:39:19 GMT
   Organization: Marine Physical Laboratory, UCSD
   Keywords: no luck finding it.
   In article <11649@ucbvax.BERKELEY.EDU> rosen@ucbvax.BERKELEY.EDU (Rob 
   Rosen) writes: >
   >   A few weeks ago I posted a query about a C shell to C converter which
   >I had believed was in existence somewhere.
   From an ad in "attage" magazine, Jan-Feb 1985:
   Shacc - the shell accelerator - is a compiler for the Bourne shell. It 
   translates Bourne shell programs into C and then invokes the C compiler 
   ...
      Concentric Associates Inc
      One Harmon Plaza
     Secaucus NJ 07094       201-866-2880
   All that I know about it is that somebody near here got a copy and it 
   seemed to work, and greatly speeded up the SysV administrative shell 
   scripts. Don't know if it is still alive, or anything else.  Thought 
   everybody knew, or I would have answered sooner.
   --
     carl lowenstein         marine physical lab     u.c. san diego
     {ihnp4|decvax|akgua|dcdwest|ucbvax}     !sdcsvax!mplvax!cdl
      -------
   From: jimb@daisy.UUCP (Jim Becker)
   Newsgroups: net.sources,net.lang.c,net.lang
   Subject: Looking for PLM --> C language converter
   Date: 3 Feb 86 19:24:07 GMT
   Organization: Daisy Systems Corp., Mountain View, Ca
   I am looking for software that is available that
   will take the PLM language (from Intel) and convert it into C source 
   code. Public Domain or commercial is acceptable... Please post mail to me
   privately, Thanks !!
   - Jim Becker
      -------
   From: iverson@cory.BERKELEY.EDU (Tim Iverson)
   Newsgroups: net.lang.c
   Subject: Any recommendations for a good C tutorial? Date: 3 Feb 86 
   19:26:05 GMT
   Organization: University of California, Berkeley
      I have a friend who wants to learn C, so I recommended the book I 
      learned from, The C Programming Language by Kernighan and Ritchie.  
      However, he is finding it a little obtuse.  He is a programmer, so no 
      kiddie C books please, but if anyone knows of a good tutorial on C, I 
      would appreciate it if you would recommend it.
   - Thanks, Tim Iverson.
      iverson@cory.BERKELEY.EDU
      iverson@cory.UUCP
   -------
   From: stevet@ihuxl.UUCP (Turpin)
   Newsgroups: net.wanted.sources,net.lang.c
   Subject: Re: C shell to C converter...
   Date: 3 Feb 86 23:15:30 GMT
   Organization: AT&T Bell Laboratories
   >
   >    A few weeks ago I posted a query about a C shell to C converter 
   which
   > I had believed was in existence somewhere.  After receiving many 
   replies > of the "please send it to me if you find it" variety and no 
   replies > of the "yes I have it, here is the answer to your question" 
   variety, I have > regrettably come to the conclusion that it probably 
   doesn't exist. > Rather than sending ~20 separate letters out, I thought 
   I'd post instead > since the issue seems to have generated quite a bit of
   interest. >
   > Thanks anyway,
   >
   > --Rob
   > --
   >                        --Rob Rosen
   >
   >                        ...ucbvax!rosen
   >                        rosen@ucbvax.berkeley.edu
   There is a program, called "shacc" from Concentric Associates that 
   converts Bourne shell scripts to C programs.  I don't know about C-shell 
   scripts.  You may want to give them a call.  The phone number is 
   201-866-2880.  They even offer an online demonstration.  Hope this is of 
   some help.
      -------
   From: gelfand@valid.UUCP (Brooks Galfand)
   Newsgroups: net.lang.c
   Subject: Re: Any recommendations for a good C tutorial? Date: 5 Feb 86 
   18:52:47 GMT
   Organization: Valid Logic, San Jose, CA
   >
   >
   >         I have a friend who wants to learn C, so I recommended the book
   I
   > learned from, The C Programming Language by Kernighan and Ritchie.  
   However, > he is finding it a little obtuse.  He is a programmer, so no 
   kiddie C books > please, but if anyone knows of a good tutorial on C, I 
   would appreciate it if > you would recommend it.
   >
   > - Thanks, Tim Iverson.
   >   iverson@cory.BERKELEY.EDU
   >   iverson@cory.UUCP
   I have been programming for a while and found that the Kernighan and 
   Ritchie book left much to be desired as a tutorial although it makes a 
   good reference. The book I learned from is:
                              Programming in C
                              by Stephen G. Kochan
   published by Hayden Book Company, Rochelle Park, New Jersey, ISBN 
   0-8104-6261-3.
   I found the examples in the book quite straight forward and easy to 
   follow. The sections on I/O and memory allocation are a bit skimpy, but 
   for a first books it is very good.
      -------
   From: gardos@kodak.UUCP (tom gardos)
   Newsgroups: net.lang.c,net.unix,net.unix-wizards,net.micro.pc Subject: 
   outb() fcn on IBM XENIX not found
   Date: 4 Feb 86 20:26:19 GMT
   Organization: Eastman Kodak Co., Rochester, NY
   Keywords: outb() function, XENIX, IBM XENIX
   I am trying to write a device driver  in C for the IBM PC AT running 
   XENIX Version 1.00. The program requires use of the functions out() and 
   outb(), however the C compiler cannot find them. Has anyone had this 
   problem? Does anyone know where the functions are defined?
      Please respond by mail and I will summarize the responses. Thanks.
   --
   Tom Gardos
   --
      -------
   From: rlw@well.UUCP (Bob Weissman)
   Newsgroups: net.wanted,net.wanted.sources,net.lang.pascal,net.lang.c 
   Subject: Pascal to C Translator Pointer Found
   Date: 6 Feb 86 22:41:24 GMT
   Organization: Whole Earth Lectronic Link, Sausalito, CA Keywords: Pascal,
   C, Translator
   Summary: but the price, she is very high
   I got many replies to my previous request for a Pascal to C translator. 
   Unfortunately, all but one of them were also requests, so I decided to 
   post the one information-filled response to you all.
   Below is the one and only message I received with an actual pointer to a 
   translator.  Alas, the price puts it out of range for most of us...
   ------------------------------------------------------------------ 
   Return-Path: <well!hplabs!hp-pcd!orstcs!lewis@lll-crg.ARPA> Date: Tue, 4 
   Feb 86 09:27:27 pst
   From: <well!hplabs!hp-pcd!orstcs!lewis@lll-crg.ARPA> Posted-Date: Tue, 4 
   Feb 86 09:27:27 pst
   Message-Id: <8602041727.AA28378@orstcs.UUCP>
   To: rlw@well
   Subject: Pascal-to-C
   Call 503-745-7476 TGL Inc. has C source for a Pascal-to-C translator. It 
   is not freeware ($5,000), but it does 98% of most Pascals including MS, 
   MT+, UCSD, or Apollo Domain.
   ------------------------------------------------------------------
      -------
   From: dmiruke@isis.UUCP (Dataram Miruke)
   Newsgroups: net.lang,net.lang.c
   Subject: Wanted : a copy or info about the paper Calling Sequences in C 
   Date: 9 Feb 86 20:06:14 GMT
   Organization: University of Denver Math and Computer Science
      I have been so far unable to locate a copy the paper by S. C. Johnson 
      and D. M. Ritchie titled "The C Language calling sequences". It was 
      published in Set. 1981. Could some kind soul please send me a copy of 
      it if they have one or give me some pointer as to where to obtain it 
      from? I know you could probably get it from one of the Bell Tech. 
      Journals but could not find in any issue of those that we have.
   thanx..
                                                     - Datta T. Miruke
                                                       2455, S. York St.
                                                       Denver, CO 80210
                                                       (303) 871-3073
                                                       (303) 744-6045
                                                       CSNET : dmiruke@isis
                                                             dmiruke@udenva
      -------
EXT-info-c-request-8P3EJ 24-Feb-86 missing info-c messages: miscellaneous
   From: {Mark Plotnick (MIT) <info-c-request@BRL.ARPA>}DDN
   To: info-c-arpa@BRL.ARPA
   Identifier: EXT-info-c-request-8P3EJ
   Length: 4 page(s)[estimate]
   Posted: 24-Feb-86 07:37-PST  Received: 27-Apr-86 15:44-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 25 Feb 86 16:26:20 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id aa17945; 25 Feb 86 18:52
   EST
   From: geoff@burl.UUCP (geoff)
   Newsgroups: net.lang.c
   Subject: Re: fast code and no morals
   Date: 2 Feb 86 16:56:27 GMT
   Organization: AT&T Technologies, Burlington NC
   In article <2138@brl-tgr.ARPA> gwyn@brl-tgr.ARPA (Doug Gwyn <gwyn>) 
   writes: >> There is no such thing as a program that runs too fast... >
   >Ahem.  I have seen some programs where so much attention was >paid to 
   running speed that the question of whether the correct >results were 
   being computed was ignored..
   While I was in school some people were working on a 'paint' graphics 
   program. One of the operations was 'fill' to color large areas easily.  
   Kind of like pouring a bottle of ink on the screen and letting it run any
   place not bounded by other objects.  As I recall the fill code was 
   written in Ikonas microcode and was so fast that users were uncomfortable
   with it.  It was artificially slowed down so that you could see the 
   operation occurring rather than *blink* its done.  Gave 'em a feeling of 
   control or something.
      Does happen.  Rarely, tho'.
         geoff sherwood
         ihnp4!burl!geoff
   -------
   From: SofPasuk@imagen.UUCP (Munach Rvi'i)
   Newsgroups: net.lang.c
   Subject: Re: Re: fast code and no morals
   Date: 3 Feb 86 01:17:48 GMT
   Organization: Imagen Corp., Santa Clara, CA
   > In article <651@brl-smoke.ARPA> ron@brl-smoke.ARPA (Ron Natalie <ron>) 
   writes: > >>> So what?  This can be written "structured" ... > >> Sure is
   recommended if you are optimizing for speed > >If you are going to blast 
   away at all the good features of a high level > >language for the sake of
   speed, why don't you just program in assembler? >
   > Assembler isn't portable, C is.
   >
   > Since C is not sensitive to newlines that often, additional comments > 
   could be added.
   "C" is as portable as Stonehedge!!  At least assembler languages don't 
   pretend to be portable.  You know that there is work to go from system to
   system.  The "security" of porting with "C" is the killer - the insidious
   differences between implementations can kill you because you don't expect
   them and can't plan well for them.
      -------
   From: chris@umcp-cs.UUCP (Chris Torek)
   Newsgroups: net.lang.c
   Subject: Re: Re: fast code and no morals
   Date: 4 Feb 86 04:54:38 GMT
   Organization: U of Maryland, Computer Science Dept., College Park, MD
   In article <231@imagen.UUCP> SofPasuk@imagen.UUCP writes: > "C" is as 
   portable as Stonehedge!!
      ... and more about C code making hidden assumptions.
   C is portable:
      /* echo */
      #include <stdio.h>
      main(argc, argv)
         register int argc;
         register char **argv;
      {
         register int i;
         argc--;
         for (i = 1; i <= argc; i++)
                     printf("%s%c", argv[i], i < argc ? ' ' : '\n');
   exit(0);
   }
   C is not portable:
      /* probebus */
      main(argc, argv)
      {
         register int i;
         register int size = 1;
             if (strcmp(argv[1], "i") == 0)  /* by ints */
                     size = 4;
   for (i = 1 << 18; i < (1 << 19); i += size) {
                     switch (size) {
                     case 1:
                             if (*(char *) i != 0) {
                                     printf("%x\n", i);
                                     exit(1);
                             }
                             break;
                     case 4:
                             if (*(int *) i != 0) {
                                     printf("%x\n", i);
                                     exit(1);
                             }
                             break;
                     }
   }
   exit(0);
   }
      /* unportable assumptions: sizeof (int) == sizeof (char *); *(char *)0
      == ""; ints hold > 16 bits; type casts can be used pretty much 
      arbitrarily. */
   It is not the language that makes code portable, though it can help or 
   hurt:  Programmers make code portable, or do not.
   Incidentally, it is `Stonehenge'.
   --
   In-Real-Life: Chris Torek, Univ of MD Comp Sci Dept (+1 301 454 1415)
   UUCP:     seismo!umcp-cs!chris
   CSNet:    chris@umcp-cs           ARPA:   chris@mimsy.umd.edu
      -------
   From: ckk@g.cs.cmu.edu (Chris Koenigsberg)
   Newsgroups: net.lang.c
   Subject: gamma function
   Date: 5 Feb 86 16:59:46 GMT
   Organization: Carnegie-Mellon University, CS/RI
   Someone mentioned the C gamma function which is really the log of the 
   gamma function, and asked why this is still called "gamma"... The C math 
   library for IBM's 4.2 BSD running on the new IBM RT PC has renamed the 
   gamma function to "lgama" since it returns the log of gamma anyway. So 
   all programs which call the gamma function now get compiler errors on the
   RT PC. We have to add conditional compilation commands to #DEFINE gamma 
   as lgama on the RT PC. (Our programs run on the Andrew system which is 
   supposed to be machine-transparent on a network of RT PCs, Suns, and 
   microVaxen, so they get compiled on all three machines and all compiler 
   differences must be ferreted out)
      -------
   From: henry@utzoo.UUCP (Henry Spencer)
   Newsgroups: net.lang.c
   Subject: Re: Re: fast code and no morals
   Date: 5 Feb 86 21:39:16 GMT
   Organization: U of Toronto Zoology
   > > Assembler isn't portable, C is. ...
   >
   > "C" is as portable as Stonehedge!!  At least assembler languages don't 
   > pretend to be portable.  You know that there is work to go from system 
   to > system.  The "security" of porting with "C" is the killer - the 
   insidious > differences between implementations can kill you because you 
   don't expect > them and can't plan well for them.
   How curious.  At U of T we routinely move C code among half a dozen or so
   different processors (more than that if you count different C compilers 
   for things like the 68000).  Compile it and it runs.
   C's portability is more than just pretense.  Of course, you have to know 
   what you're doing when you write the code.  There is *no* "security" in 
   porting with C; it is easy to write unportable C, and writing portable C 
   takes knowledge, care, and attention.  Once you get used to it, it's not 
   hard.  We can and do plan for the aspects that vary between machines. --
                             Henry Spencer @ U of Toronto Zoology
                             {allegra,ihnp4,linus,decvax}!utzoo!henry
      -------
   From: msb@lsuc.UUCP (Mark Brader)
   Newsgroups: net.astro,net.travel,net.lang.c
   Subject: Portability of Stonehenge
   Date: 8 Feb 86 06:54:17 GMT
   Organization: Law Society of Upper Canada, Toronto Summary: Even less 
   than you think
   Whatever we think of the content, we must all agree on the charm of this 
   simile posted by Munach Rvi'i in net.lang.c:
   > "C" is as portable as Stonehenge!!
   Thank you, Munach.
   This article is just to point out that Stonehenge is actually even less 
   portable than all you net.lang.c readers probably think.  Big stones can 
   be moved -- they had to be moved to build it -- but it turns out that the
   DESIGN of Stonehenge is not portable!
   See, one of the several stoneworks at Stonehenge -- possibly the oldest 
   -- consisted of 4 stones called the "station stones", marking the corners
   of a rectangle.  (2 of the 4 station stones survive now.) The great stone
   circle that you think of when you think of Stonehenge sits inside the 
   rectangle, just clearing its sides by a few feet.
   Now, from a given place on Earth, the directions where the sun will rise 
   and set depend only on the day of the year.  The directions where the 
   moon will rise and set, however, depend on a composition of three things:
   the day of the year, the phase of the moon, and a further cycle of 18.61 
   years "caused by the combined effects of tilt and precession of the orbit
   ... [which] even an astronomer has trouble visualizing".
   The interesting thing is this:  if you stand at a certain one of the 
   station stones, on the summer solstice, at sunrise, you will see the sun 
   rise over another of the station stones.  Now, if it also happens that 
   the moon is full [so that two of the three cycles affecting the moon are 
   at their extreme points], AND if you wait the 1/2 day until moonrise, 
   THEN the range of positions along which the moon might rise [according to
   the 18.61-year cycle] is precisely delimited by the OTHER TWO station 
   stones as seen from where you are.
   But the station stones are set in a rectangle!  So this means that at 
   Stonehenge, the angle between sunrise and moonrise can get as large as 90
   degrees but no larger.  This is true ONLY at the particular latitude of 
   Stonehenge (north or south).  (Whether the builders realized that the 
   maximum angle varies with latitude is, of course, a matter of 
   conjecture.)
   There are many other astronomical alignments in Stonehenge, mostly with 
   the rising or setting sun or moon at the solstices.  The station stone 
   rectangle can be used in reverse at the winter solstice -- I'm 
   simplifying a bit here -- and the great stone circle and trilithons 
   (arches) have their own alignments.  Most of these are specific to the 
   latitude also, though the unusual 90-degree angle is featured only in the
   station stones.
   There are also traces of some circles of pits, and from the numbers of 
   pits in the circles and the other information known to have been provided
   by the alignments, it is conjectured that the circles (plus movable 
   markers) acted as registers in a computer for predicting eclipses.
   "There is a replica of Stonehenge at Maryhill, Klickitat County, WA, 
   where the Stonehenge sarsens and trilithons have been duplicated real- 
   istically in tons of concrete.  But Maryhill is at the wrong latitude (5 
   degrees too far south), so alas, the alignments of the American version 
   of Stonehenge do not work."
   Hmm, maybe Canada should build one at Banff, where the latitude is right.
   :-)
   REFERENCE: "Stonehenge Decoded", by Gerald S. Hawkins in collaboration 
   with John B. White; Doubleday, 1965.  Specifically pages 107 and 154-5 
   for the station stone alignments, and Maryhill, and the quotations above;
   and the footnote on page 144 for the signature quote below, attributed to
   "a Boston University research student."
   Anyway, I hope you all enjoyed this insight into the difficulties of 
   porting with Stone Age architecture.  It seems unlikely that followups 
   will be of interest to ALL of net.astro, net.travel, and net.lang.c, so 
   I'm directing followups to net.astro alone, and you can edit the 
   Newsgroups line if that's not what you want.
   Mark Brader
   "Okay -- so it was a computer -- but it was only a single-purpose 
   machine."
      -------
   From: levy@ttrdc.UUCP (Daniel R. Levy)
   Newsgroups: net.lang.c
   Subject: Re: Re: fast code and no morals
   Date: 9 Feb 86 00:35:39 GMT
   Organization: AT&T, Computer Systems Division, Skokie, IL
   <Oh oh here it comes.  Watch out boy, it'll chew you up! \ Oh oh here it 
   comes.  The LINE EATER!  [Line eater]>
   In article <3032@umcp-cs.UUCP>, chris@umcp-cs.UUCP (Chris Torek) writes: 
   >
   >C is portable:
   >
   > /* echo */
   > #include <stdio.h>
   >
   > main(argc, argv)
   >         register int argc;
   >         register char **argv;
   > {
   >         register int i;
   >
   >         argc--;
   >         for (i = 1; i <= argc; i++)
   >                 printf("%s%c", argv[i], i < argc ? ' ' : '\n');
   >         exit(0);
   > }
   >--
   >In-Real-Life: Chris Torek, Univ of MD Comp Sci Dept (+1 301 454 1415)
   What about a system where it is impossible to give command line arguments
   to a program, like the early-stone-age card reading IBM systems?   Not 
   all C runs on Unix ya know....  (Is C only allowed to run on machines 
   that DO allow command line arguments?  What does the proposed ANSI C 
   standard say about this?) Would this program just get run with an argc of
   0 in the case of a stone age system?  As a matter of fact, must a system 
   support both upper and lower case characters to support C?  (Would 
   Cyber-type machines with 6 bit character codes be out of the running?)  
   Perhaps nobody these days would WANT such a sys- tem, rendering the point
   moot, but for the sake of argument :-), what if someone had such a system
   and wanted to keep on using it, but with C rather than say, Fortran 
   (which would have no trouble with the absence of command line arguments 
   and the single case of characters)?
   --
    -------------------------------    Disclaimer:  The views contained 
   herein are
   |       dan levy | yvel nad      |  my own and are not at all those of my
   em-
   |         an engihacker @        |  ployer or the administrator of any 
   computer
   | at&t computer systems division |  upon which I may hack.
   |        skokie, illinois        |
    --------------------------------   Path: 
   ..!{akgua,homxb,ihnp4,ltuxa,mvuxa,
                                             vax135}!ttrdc!levy
      -------
   From: chris@umcp-cs.UUCP (Chris Torek)
   Newsgroups: net.lang.c
   Subject: Re: portability and `echo'
   Date: 10 Feb 86 05:23:55 GMT
   Organization: U of Maryland, Computer Science Dept., College Park, MD
   In article <720@ttrdc.UUCP> levy@ttrdc.UUCP writes: >In article 
   <3032@umcp-cs.UUCP>, chris@umcp-cs.UUCP (Chris Torek) writes: [followed 
   by my sample portable program, namely a simplified reimplementation of 
   `echo'.]
   > What about a system where it is impossible to give command line > 
   arguments to a program, like the early-stone-age card reading > IBM 
   systems?
   On such a system an `echo' program is useless, since it always prints a 
   blank line.  However, note that my sample program would indeed 
   successfully print a blank line on such a system.
   > Is C only allowed to run on machines that DO allow command line > 
   arguments?
   No; but such a system requires severe design constraints which rule out a
   program like `echo'.  Yet that does not make echo unportable.
   > Would this program just get run with an argc of 0 in the case > of a 
   stone age system?
   As to that I cannot say, but again, my code will still print a blank 
   line.
   > As a matter of fact, must a system support both upper and lower > case 
   characters to support C?
   No.  But it would no doubt break quite a bit of code.  That code can be 
   considered unportable in that sense; but here I think one must begin to 
   consider just what extremes of portability are worthwhile. Would you say 
   that screen editors should not exist because they are unportable to some 
   machines?
   I think the real point is that one should write code as portably as 
   possible given the constraints under which that code is to operate.  
   Window systems cannot run on teletypes; bitmapped graphics cannot run on 
   character-oriented CRTs.  Yet I can write a portable routine that does 
   bitmapped graphics using the MIT X window system as a base.  I claim 
   there is no contradiction here: that portability does not mean that code 
   runs on any machine anywhere; rather, that it is not *unnecessarily* 
   limited.
   --
   In-Real-Life: Chris Torek, Univ of MD Comp Sci Dept (+1 301 454 1415)
   UUCP:     seismo!umcp-cs!chris
   CSNet:    chris@umcp-cs           ARPA:   chris@mimsy.umd.edu
      -------
   From: gwyn@brl-smoke.ARPA (Doug Gwyn )
   Newsgroups: net.lang.c
   Subject: Re: Re: fast code and no morals
   Date: 10 Feb 86 20:41:29 GMT
   Organization: /usr/local/lib/news/organization
   In article <720@ttrdc.UUCP> levy@ttrdc.UUCP (Daniel R. Levy) writes: 
   >What about a system where it is impossible to give command line 
   arguments to a >program, like the early-stone-age card reading IBM 
   systems?   Not all C runs >on Unix ya know....  (Is C only allowed to run
   on machines that DO allow >command line arguments?  What does the 
   proposed ANSI C standard say about this?) >Would this program just get 
   run with an argc of 0 in the case of a stone >age system?  As a matter of
   fact, must a system support both upper and lower >case characters to 
   support C?  (Would Cyber-type machines with 6 bit character >codes be out
   of the running?)  Perhaps nobody these days would WANT such a sys- >tem, 
   rendering the point moot, but for the sake of argument :-), what if 
   someone >had such a system and wanted to keep on using it, but with C 
   rather than say, >Fortran (which would have no trouble with the absence 
   of command line arguments >and the single case of characters)?
   In a hosted (as opposed to stand-alone) environment, yes, C requires that
   programs be able to obtain arguments specified at the time they are run. 
   The Software Tools people have accomplished this on virtually every major
   mainframe and minicomputer OS, so it is doable.
   Yes, C requires support of both upper- and lower-case characters. Modern 
   Cybers claim to have support for 8- or 12-bit characters.
   Nobody promised that C could be implemented on an abacus.
      -------
EXT-info-c-request-8P3F6 24-Feb-86 missing info-c messages: more miscellany
   From: {Mark Plotnick (MIT) <info-c-request@BRL.ARPA>}DDN
   To: info-c-arpa@BRL.ARPA
   Identifier: EXT-info-c-request-8P3F6
   Length: 2 page(s)[estimate]
   Posted: 24-Feb-86 07:40-PST  Received: 27-Apr-86 15:44-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 25 Feb 86 16:32:17 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a017954; 25 Feb 86 18:53
   EST
   From: greenber@phri.UUCP (Ross Greenberg)
   Newsgroups: net.micro.pc,net.lang.c,net.ai,net.games Subject: A contest 
   in 'C'...
   Date: 5 Feb 86 13:32:05 GMT
   Organization: Public Health Research Inst. (NY, NY)
   while (TRUE){ puts("*** REPLACE THIS LINE WITH YOUR MESSAGE ***");}
   There is a game making the rounds on some of the MS-DOS BBS's called 
   CROBOTS.  An interesting game that can allow those that respond to 
   determine just how good their 'C' programming is.
   In this game, you program your "robot" to seek out and destroy other 
   robots that have been programmed by someone else.  Each robot has the 
   capability of movement, sensor detection of other robots, and the ability
   to fire a cannon at a given direction and range.
   Typical robots might use programs that allow the robot to scan the 
   playfield, locate any one of four opponents, fire a cannon at that 
   opponent, and start zig-zagging towards that opponent while firing a 
   cannon.
   If you are interested in determining how *your* robot stands up to other 
   robots, then here are the contest rules:
   1)        Get a copy of the program from a local MS-DOS machine.
      There may be a UNIX version out, but I'm not aware of it
   2)        Create a robot that will (2 out of 3 times), destroy
   the preconfigured robots that come in the .ARC package.
   3)        Document your robot's code and send it off to me at the
   below address.  Entries accepted until March 1, 1986.
   4)        You may enter no more than two robots.
   The way I'll run the contest should work, although comments are welcomed:
   For every four robots that come in, I'll send them off to battle. I'll 
   run the simulation twice for each four, or until a have a clear consensus
   of which two out of the robots make it to the next round.
   This process will be repeated until there are finally only four top 
   robots.  They'll slug it out until I can determine which are the top two.
    From that, of course, I can determine which is the robot that deserves 
   the applause.
   The top four robots will be posted to the net.  Each losing robot will be
   returned to its designer, along with the code for the robots which 
   destroyed it.
   Consider this first contest the beginning round.  The next round will be 
   in about three months.
   Good Luck!
   Ross
   --
   ------
   ross m. greenberg
   ihnp4!allegra!phri!sysdes!greenber
   [phri rarely makes a guest-account user a spokesperson. Especially not 
   me.]
      -------
   From: greenber@phri.UUCP (Ross Greenberg)
   Newsgroups: net.micro.pc,net.lang.c,net.ai,net.games Subject: Re: A 
   contest in 'C'...
   Date: 6 Feb 86 22:31:54 GMT
   Organization: Public Health Research Inst. (NY, NY)
   >
   >
   >There is a game making the rounds on some of the MS-DOS BBS's called 
   >CROBOTS.
   And I forgot to tell you where some of these boards are....
   Two that I know of are:
   NYACC (New York Amateur Computer Club) at 1-718-539-3338 and my board at 
   1-212-889-6438, login with 'demo' and 'demo'.
   Happy Robot Designing....
   ross
   --
   ------
   ross m. greenberg
   ihnp4!allegra!phri!sysdes!greenber
   [phri rarely makes a guest-account user a spokesperson. Especially not 
   me.]
      -------
   From: bad@npoiv.UUCP (Bruce Dautrich)
   Newsgroups: net.micro.pc,net.lang.c,net.ai,net.games Subject: Re: A 
   contest in 'C'...
   Date: 8 Feb 86 15:54:14 GMT
   Organization: ATTIS, Neptune, NJ
      This games sounds like a game called bolo which to my knowledge was 
      first written by Peter Langston who also wrote empire.
   -------
   From: cim1@pyuxv.UUCP (G. Bogatko)
   Newsgroups: net.lang.c,net.sources,net.micro.pc,net.unix-wizards Subject:
   Disgusting Code
   Date: 6 Feb 86 14:07:09 GMT
   Organization: AGS Computers
      In music_land, there exists the "Max Reger Society".  Once a year, 
      they gather together and give out an award to the person who can write
      the most revolting chord progression while still maintaining even the 
      smallest link to the syntax of tonal music.
      Why don't we do the same thing, and have a "Most Disgusting Code" 
      award.  The rules are simple.  Just produce your favorite bit of 
      un-maintainable, or un-readable code. (something that would be too 
      much for the puzzle book).  Obviously, it must compile.
      Besides being a goof,  all of us might also learn some more of the 
      inner workings of C.
      Here, to start the ball rolling, is my entry.
   /* nasty.c */
   main()
   {
   int a;
      printf("%s 
      me\n",(a=getchar()-48)<4?&(a["\0\005\015\022"]["help\0abandon\0save\0l
      ose"]):"wrong"); }
   George Bogatko
      -------
   From: gwyn@brl-smoke.ARPA (Doug Gwyn )
   Newsgroups: net.lang.c,net.micro.pc,net.unix-wizards Subject: Re: 
   Disgusting Code
   Date: 9 Feb 86 11:32:25 GMT
   Organization: /usr/local/lib/news/organization
   In article <168@pyuxv.UUCP> cim1@pyuxv.UUCP (G. Bogatko) writes: > ...
   > Why don't we do the same thing, and have a "Most Disgusting Code"
   >award.  The rules are simple.  Just produce your favorite bit of 
   >un-maintainable, or un-readable code. (something that would be too much 
   for >the puzzle book).  Obviously, it must compile.
   Please, let's nip this in the bud.  It is all too easy to find examples 
   of disgusting code; there is no need to burden the net with such garbage.
    Some people even have to pay to receive the garbage; surely that 
   wouldn't be nice..
      -------
   From: boykin@datagen.UUCP
   Newsgroups: net.lang.c,net.sources,net.micro.pc,net.unix-wizards Subject:
   Re: Disgusting Code
   Date: 9 Feb 86 18:18:12 GMT
   Organization: Data General Distributed Systems, Westborough, MA
   Seeing how easy it is to produce "disgusting code" the last thing we need
   is a "Most Disgusting Code" award.  With good code (defined as portable, 
   readable and maintainable) being much rarer, much more valuable to look 
   at (and learn from), and (unfortunately) alot harder to find. Perhaps 
   what we need is a "Best Code I've ever seen" award.
   Learning the "tricks" from code which is admittedly "disgusting" (and 
   which won't compile under most compilers) isn't the kind of trick that 
   you should be striving to learn.
   Joe Boykin
   Sr. Project Leader
   Data General Corp.
   Distributed Systems Group
   {allegra, ihnp4, decvax}!datagen!boykin
      -------
   From: chongo@nsc.UUCP (Landon Noll)
   Newsgroups: net.lang.c,net.sources,net.micro.pc,net.unix-wizards Subject:
   Re: Disgusting Code
   Date: 10 Feb 86 22:10:16 GMT
   Organization: Rational Swamiconductor, Sanivale
   In article <168@pyuxv.UUCP> cim1@pyuxv.UUCP (G. Bogatko) writes: >
    >        Why don't we do the same thing, and have a "Most Disgusting 
   Code"
      >award.  The rules are simple.  Just produce your favorite bit of 
      >un-maintainable, or un-readable code. (something that would be too 
      much for >the puzzle book).  Obviously, it must compile.
   Such a thing already exists.  It is called the International Obfuscated C
   Code Contest already in its 3rd year.  Rules and winners of the contest 
   will be posted to this newsgroup and will be published in a computer mag.
   as well.
   Watch this space for the 1986 contest rules in the comming weeks.
   chongo <..> /\oo/\
      -------
EXT-ark-alice-uucp-8P3OD 18-Feb-86 Re: Arcane C hacks?
   From: {Andrew Koenig <ark%alice.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-ark-alice-uucp-8P3OD / <4993@alice.uUCp>
   Posted: 18-Feb-86 19:53-PST  Received: 27-Apr-86 15:44-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 25 Feb 86 19:40:30 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a018952; 25 Feb 86 22:31
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a008156; 25 Feb 86 22:09 EST
   Newsgroups: net.lang.c
   In "pure C," the only thing you can do with a label is use it as the 
   subject of a goto.  The closest you can come is to call an element of an 
   array rather than jumping to it; the array must then be an array of 
   function pointers.
EXT-bjorn-dataiodataio-u-8P3TL 16-Feb-86 Re: exit() on VMS
   From: {Bjorn Benson <bjorn%dataiodataio.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-bjorn-dataiodataio-u-8P3TL / <913@dataioDataio.UUCP>
   Posted: 16-Feb-86 15:26-PST  Received: 27-Apr-86 15:44-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 25 Feb 86 21:12:36 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a019189; 25 Feb 86 23:41
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a009512; 25 Feb 86 23:02 EST
   Newsgroups: net.lang.c
   In article <3174@umcp-cs.UUCP> chris@umcp-cs.UUCP (Chris Torek) writes:
   >>   This isn't portable to VMS.
   >I would hope that on VMS, exit(0) maps to status code 1...
   No such luck.  Here is what we use in exit():
     __UNIX__        __VMS__
   Success      0               1
   Failure      1            0x10000002
   Ugly but true under VMS with VAX-11 C.
                     Bjorn Benson
                     Software Engineer
                     FutureNet - a Data I/O company
EXT-bzs-bu-cs-uucp-8P3NL 19-Feb-86 Record Locking
   From: {Barry Shein <bzs%bu-cs.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-bzs-bu-cs-uucp-8P3NL / <183@bu-cs.UUCP>
   Posted: 19-Feb-86 17:54-PST  Received: 27-Apr-86 15:44-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 25 Feb 86 19:27:24 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a018896; 25 Feb 86 22:19
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a007324; 25 Feb 86 21:48 EST
   Newsgroups: net.lang.c
   >From: cottrell@NBS-VMS.ARPA (COTTRELL, JAMES)
   >Allow me to propose a kluge. Since on can create lockfiles of any >name,
   create a parrallel directory /whatever/lock, and create lock >files of 
   the form `name#number' in that directory. Thus to lock >record three of 
   file `foo' create a lock /whatever/lock/foo#3'. >Multi-record lox are 
   more difficult, but can be done with a little >head scratching. Yeah, it 
   ain't pretty, but it just might work.
   I have a better idea. Being as 4.2bsd can have up to 256 characters in a 
   file name and that most data-bases can live with less than 256 characters
   in a record (or a multiple, fixed record scheme can be used, or even 
   variable) why not just store the data in the file names and leave the 
   files empty (or fill them with change info or something.) You can then 
   use all those file searching things (like wildcards and 'find') as 
   data-base queries, you can do 'record' locking etc etc. Touch becomes the
   data-entry program, rm for removing, built in dates of creation, 
   modification, access, ownership kept in the inode, guaranteed synchronous
   write-through on update, atomicity of record creation...
   I know, shut up Barry, you've lost your mind again....
      -Barry Shein, Boston University
EXT-C346595-UMCVMB-BITNE-8P3LK 25-Feb-86 ProComm
   From: {Bruce Barkelew <C346595%UMCVMB.BITNET@WISCVM.ARPA>}DDN
   To: info-c@BRL.ARPA
   Identifier: EXT-C346595-UMCVMB-BITNE-8P3LK
   Posted: 25-Feb-86 06:41-PST  Received: 27-Apr-86 15:45-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 25 Feb 86 18:50:40 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a018605; 25 Feb 86 21:39
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id bf01557; 25 Feb 86 20:37
   EST
   Received: from wiscvm.arpa by AOS.BRL.ARPA id a004663; 25 Feb 86 9:44 EST
   Received: from (MAILER)UMCVMB.BITNET by WISCVM.WISC.EDU on 02/25/86 at
     08:43:16 CST
   Received: by UMCVMB (Mailer X1.23) id 4343; Tue, 25 Feb 86 08:44:04 CST
   PIL Software Systems
   PO Box 1471
   Columbia, MO 65201
   (314) 449-9401
   I am the co-author of the communications program ProComm.  I noticed our 
   program mentioned here, so I thought I would let you know some more 
   information.  ProComm is a user supported product.  We have just released
   version 2.2 (02/21/86).  Version 2.2 has many improvements and additions.
    We now emulate 10 popular async terminals.  The VT-100 emulation has 
   been greatly improved.  We support XMODEM, YMODEM, TELINK, MODEM7 and 
   KERMIT file transfer protocols.  Our KERMIT implementation has been 
   completely re-coded from the ground up, and now supports all the latest 
   features such as data compression, file attributes, and the new Sliding 
   Window (full duplex) extension.  Our script command language has been 
   expanded also.  ProComm runs under MS-DOS 2.0 or greater, and requires 
   128k of RAM.  We a 24 hour support BBS running at (314) 449- 9401.  The 
   latest version is always available there.  ProComm is written in C with 
   assembler routines for maximum optimization.
   I don't mean this to sound like a commercial, but I saw messages here 
   inquiring about us, so I thought I would supply the information.  I can 
   be reached at the above address or at C346595 at UMCVMB.
   -Bruce Barkelew
EXT-daemon-8P3S9 19-Feb-86 Re: exit() on VMS
   From: dyer%dec-vaxuum.uucp@BRL.ARPA
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-daemon-8P3S9 / <1235@decwrl.DEC.COM>
   Sender: daemon@decwrl.ARPA
   Posted: 19-Feb-86 08:10-PST  Received: 27-Apr-86 15:45-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 25 Feb 86 20:51:18 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a019130; 25 Feb 86 23:28
   EST
   Received: from USENET by SMOKE.BRL.ARPA id aa09373; 25 Feb 86 22:56 EST
   Newsgroups: net.lang.c
   Re: exit() on VMS_________________________________________________
   > I get the impression that VMS C was implemented by people who > did not
   have much practical experience with C programming.
      Bad impression, one that certainly does not follow from an 
      incompatible exit() function.  I work in the same building as the VAX 
      C people, and they are all brave and heroic, with IQs of at least 170.
       They all know what they're doing, too.
      I've had very few problems compiling and running Unix-written programs
      with VAX C.  The exit() inconsistency is, after all, quite minor.
   > Quoting from X3J11 section D.10.4.2: "Finally, control is > returned to
   the host environment.  If the value of `status' is > zero, the status 
   returned is *successful termination*; otherwise > an 
   implementation-defined form of the status *unsuccessful > termination* is
   returned.
      This standard wasn't around when the VAX C exit() routine was written,
      but I agree that the exit() routine should be changed now that this 
      behavior has been cast in ANSI concrete.
         <_Jym_>
   P.S.:  I have no connection with the VAX C group outside of an ad- 
   miration for their bravery, heroism, and high IQs.  I also do not presume
   to speak for DEC, only for myself.
   ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
   ::::'  ::  `::::             Jym Dyer             ::::'  ::  `::::
   ::'    ::    `::       Dracut, Massachusetts      ::'    ::    `::
   ::     ::     ::::::::::::::::::::::::::::::::::::::     ::     ::
   ::   .::::.   ::   DYER%VAXUUM.DEC@DECWRL.ARPA    ::   .::::.   ::
   ::..:' :: `:..::  {allegra|decvax|ihnp4|ucbvax}   ::..:' :: `:..::
   ::::.  ::  .:::: decwrl!dec-rhea!dec-vaxuum!dyer  ::::'  ::  `::::
   ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
EXT-Dave-Platt-LADC-8P3KS 24-Feb-86 Incorrect address posted here last week
   From: {Dave Platt <Dave-Platt%LADC@CISL-SERVICE-MULTICS.ARPA>}DDN
   To: {Info-C <Info-C@BRL.ARPA>}DDN
   Identifier: EXT-Dave-Platt-LADC-8P3KS
   Posted: 24-Feb-86 15:59-PST  Received: 27-Apr-86 15:45-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 25 Feb 86 18:36:58 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a018510; 25 Feb 86 21:30
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id ae01557; 25 Feb 86 20:03
   EST
   Received: from cisl-service-multics.arpa by AOS.BRL.ARPA id a028786;
             24 Feb 86 19:07 EST
   Received: FROM LADC BY CISL-SERVICE-MULTICS.ARPA WITH dial; 24 FEB 1986 
   19:07:41 EST
   Randomness: Some men are discovered; others are found out.
   Apologies to anyone who tried to send me a request for the Second Annual 
   Obfuscated C award at the address I used last week (.DCPHOST%LADC...). A 
   bug in our mailer [for which I'm responsible ;-(] put an incomplete 
   return address on it, and our inbound mailer tried to send your requests 
   to the wrong machine... from which they bounced.
   If you send me a request and I haven't responded yet with at least a mea 
   culpa, please resend your request to the address on this mailgram.
EXT-hfavr-mtuxo-uucp-8P3PP 18-Feb-86 Re: Arcane C hacks?
   From: {"a.reed" <hfavr%mtuxo.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-hfavr-mtuxo-uucp-8P3PP / <1318@mtuxo.UUCP>
   Posted: 18-Feb-86 17:33-PST  Received: 27-Apr-86 15:45-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 25 Feb 86 20:05:23 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a019015; 25 Feb 86 22:55
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a008403; 25 Feb 86 22:15 EST
   Newsgroups: net.lang.c
   Robert Herndon writes:
   >   I wrote a mild flame in another newsgroup about this, but
   > somebody out there might know another way.
   >   The problem is this:  I'd like to construct a jump table by
   > putting lots of labels into an array, and then issuing a > statement 
   like
   >                 goto jumptab[i];
   Such a table is automatically built by the compiler when you do
     switch (i) {    case 1: goto label_a;
                     case 2: goto label_b;   } /* etc. */
   This can do everything you need, and gives you the benefit of readable 
   labels.
                     Adam Reed (ihnp4!npois!adam)
EXT-LINNDR-VUENGVAX-BITN-8P3TI 25-Feb-86 Wanted - A TOPS-10 C compiler
   From: LINNDR%VUENGVAX.BITNET@wiscvm.ARPA
   To: INFO-C@BRL.ARPA
   Identifier: EXT-LINNDR-VUENGVAX-BITN-8P3TI
   Posted: 25-Feb-86 19:55-PST  Received: 27-Apr-86 15:45-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 25 Feb 86 21:13:16 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a019200; 25 Feb 86 23:41
   EST
   Received: from brl-aos.arpa by SMOKE.BRL.ARPA id aa09542; 25 Feb 86 23:05
   EST
   Received: from wiscvm.arpa by AOS.BRL.ARPA id a019024; 25 Feb 86 22:58 
   EST
   Received: from (LINNDR)VUENGVAX.BITNET by WISCVM.WISC.EDU on 02/25/86
     at 21:56:25 CST
   Can anyone provide me with pointers to a TOPS-10 C compiler? Since I am 
   not yet on the mailing list, please send replies directly to me and I can
   post a summary.
   LINNDR@VUEngVAX.BITNET
   David Linn
   Center for Intelligent Systems
   Vanderbilt University
   P.O. 3241-B
   Nashville, TN 37235
EXT-mouse-mcgill-vision--8P3PT 17-Feb-86 code and comments disagreeing
   From: {der Mouse <mouse%mcgill-vision.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-mouse-mcgill-vision--8P3PT / <376@mcgill-vision.UUCP>
   Posted: 17-Feb-86 21:50-PST  Received: 27-Apr-86 15:45-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 25 Feb 86 20:07:27 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a019026; 25 Feb 86 22:58
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a008867; 25 Feb 86 22:33 EST
   Newsgroups: net.lang.c
   Found in our kernel code:
   /* this should be SEQ_LT; is SEQ_LEQ for BBN vax TCP only */ 
   (SEQ_LT(ti->ti_ack, tp->iss) ||
   (gee, I wonder now, should I worry about posting "secret" code? :-) --
                                     der Mouse
   USA: {ihnp4,decvax,akgua,utzoo,etc}!utcsri!mcgill-vision!mouse 
   philabs!micomvax!musocs!mcgill-vision!mouse
   Europe: mcvax!decvax!utcsri!mcgill-vision!mouse
      mcvax!seismo!cmcl2!philabs!micomvax!musocs!mcgill-vision!mouse 
      ARPAnet: utcsri!mcgill-vision!mouse@uw-beaver.arpa
   Hacker: One who accidentally destroys /
   Wizard: One who recovers it afterward
EXT-thomas-utah-gr-uucp-8P3NO 19-Feb-86 Re: Wanted:Compaction Algorithm
   From: {"Spencer W. Thomas" <thomas%utah-gr.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-thomas-utah-gr-uucp-8P3NO / <1687@utah-gr.UUCP>
   Posted: 19-Feb-86 18:31-PST  Received: 27-Apr-86 15:45-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 25 Feb 86 19:26:59 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a018879; 25 Feb 86 22:17
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a006834; 25 Feb 86 21:35 EST
   Newsgroups: net.lang.c,net.unix
   Xref: seismo net.lang.c:8075 net.unix:7519
   Actually, compress works best if there are repeated SEQUENCES in the 
   input data.  It doesn't really matter so much how many different codes 
   there are, except that one is more likely to get repeated sequences if 
   there are fewer codes.
   --
   =Spencer   ({ihnp4,decvax}!utah-cs!thomas, thomas@utah-cs.ARPA)
EXT-throopw-dg-rtp-uucp-8P3OA 18-Feb-86 Re: casting structures
   From: throopw%dg_rtp.uucp@BRL.ARPA
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-throopw-dg-rtp-uucp-8P3OA / <165@dg_rtp.UUCP>
   Posted: 18-Feb-86 16:04-PST  Received: 27-Apr-86 15:45-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 25 Feb 86 19:39:36 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a018928; 25 Feb 86 22:30
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a007969; 25 Feb 86 22:04 EST
   Newsgroups: net.lang.c
   I'd like to correct a misleading and mistaken example posted in  message 
   <392@ccivax.UUCP>.   You may consider this a flamage warning.
   >>Are there any other cases where casts are NEEDED besides:
   >>              [some cases]
   In message <392@ccivax.UUCP> <rb@ccivax.UUCP (rex ballard)> says:
   > Yes, accessing members of structures.
   > ie:
   > struct x y;
   > struct i j;
   > i.memb=y.memb;  /* some compilers hate this */
   > should be written:
   > i.memb= ((struct i)x).memb;
   >
   > this is especially true if both structures contain 'memb' but
   > 'memb' is different type or placement.
   > A union is probably preferred.
   Where to begin?  Well, let's start out by pointing out that the 'i' in 
   'i.memb' must be a 'j' (both places), and the 'x' in '(struct i)x' must 
   be a 'y'. I can't think of any reasonable way of making this fragment 
   into a legal C program otherwise. Next, the definitions of 'memb' are 
   missing, so I'm not sure what is meant by "different type or placement". 
   Let's assume he means something like the following somewhat more complete
   example:
      struct s1 {int a; char b;};
      struct s2 {char b; int a;};
      void f(){
         struct s1 x1;
         struct s2 x2;
         x1.a = x2.a;
         x1.a = ((struct s1)x2).a;
      }
   Ok, now with a complete example in hand, let's see what's what.  To start
   with, Harbison and Steele says (sec 6.5, pg 129, chant along if you have 
   the hymnal folks)
      An object of a structure or union type *T* may be converted only to a 
      type that is the same as *T* (the trivial conversion).  There is no 
      change of representation, except that the bit patterns in any unused 
      "holes" in the structure or union are not necessarily preserved.
   Amen.  From this I predict that any adequate typechecker will get sick 
   all over my complete example, and I am not let down by my favorite one. 
   It points out the cast as illegal, and raises not a peep over the 
   uncasted assignment that Rex claims might not work.
   I will even stick my neck out further and assert that any compiler which 
   does not accept the uncasted expression is not a compiler for the C 
   language.  But what will a compiler do with the cast (as opposed to a 
   typechecker, which had better complain)?  Well, my handy-dandy "You Asked
   For It, You Got It" C compiler allocates the structs like so:
               |       |       |       |       |       |       |
       s1:     |int a;     (32 bits)           |char b;|padding|
       s2:     |char b;|padding|int a;    (32 bits)            |
               |       |       |       |       |       |       |
   For x1.a = x2.a, the compiler moves the 32 bits of integer in the s2 
   shaped record to the 32 bits of integer in the s1 shaped record.  For the
   casted abomination, (got your barf bags ready?) it moves the 8 bits of b,
   plus the 8 bits of padding, plus the first 16 bits of a in the s2 shaped 
   structure, and places them in the 32 bits of a in the s1 shaped 
   structure.  (Trust me.  That's what it does.  I tried it out.)
   Somehow I think that maybe (just maybe) Rex hasn't actually used his 
   handy-dandy coding tip in any working program... what do y'all think?
   (Unless of course the posting was a joke, in which case I'd merely say 
   that it was a moderately dangerous and ill-conceived joke.)
   --
   Wayne Throop at Data General, RTP, NC
   <the-known-world>!mcnc!rti-sel!dg_rtp!throopw
EXT-usenet-8P3S0 19-Feb-86 Re: Integer division
   From: {"Matthew P. Wiener" <weemba@ucbbrahms.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-usenet-8P3S0 / <11921@ucbvax.BERKELEY.EDU>
   Sender: usenet@ucb-vax.ARPA
   Posted: 19-Feb-86 01:26-PST  Received: 27-Apr-86 15:45-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 25 Feb 86 20:46:26 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a019119; 25 Feb 86 23:26
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a009252; 25 Feb 86 22:50 EST
   Newsgroups: net.lang,net.lang.c
   Followup-To: net.lang
   Xref: seismo net.lang:2190 net.lang.c:8097
   In article <736@abic.UUCP> jst@abic.UUCP (Shack Toms) writes: >> In 
   article <731@abic.UUCP> jst@abic.UUCP (Shack Toms) writes: >> >However:  
   One might use a%b<0 iff a<0 in an algorithm which printed >> >the value 
   of an integer in a given radix.  The least significant >> >digit of a in 
   radix b would then be |a%b|.  :-) >>
   >> So would |a|%b, and it works under either convention.  :-) >
   >Except that |a| is not available for the full range of a.  In 
   >particular, on a 16 bit computer |-32768| is not expressible.
   I don't know about you, but I'm too paranoid about the least negative 
   number to begin with.  In fact, I try not to get close, if possible.
   Frankly, if it's a question of a language getting integer division done 
   correctly on -32767 to 32767 or getting it done incorrectly on -32768 to 
   32767, I think there is no debate about which is preferable.  Or, to 
   express my point in less prejudicial terms: in arguing A vs B in a 
   language, the question of what happens with the least negative number is 
   almost always irrelevant.
   >The real point [of the :-)] etc.
   Agreed etc.
   Personal to Shack Toms- I got mail asking me to keep this issue off of 
   net.arch.  As you reposted to net.arch, I wonder if you did?  As it is, 
   I'm sending this up to net.lang, since it is not really a C specific 
   question.
   ucbvax!brahms!weemba      Matthew P Wiener/UCB Math Dept/Berkeley CA 
   94720
EXT-hamish-root44-uucp-8P4BS 18-Feb-86 Wanted: C Programming Standards 
(Reposting)
   From: {Hamish REID <hamish%root44.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-hamish-root44-uucp-8P4BS / <5506@root44.UUCP>
   Posted: 18-Feb-86 03:24-PST  Received: 27-Apr-86 15:45-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 26 Feb 86 02:42:01 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a020268; 26 Feb 86 5:31 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a013135; 26 Feb 86 5:15 EST
   Newsgroups: net.wanted,net.lang.c
   Xref: seismo net.wanted:8822 net.lang.c:8100
   Does anyone have, or know of, a set of PUBLIC DOMAIN C programming 
   standards in machine readable form - i.e. that I can get directly from 
   the net, and that I can use as a basis for a set of project standards?
   The standards should cover such things as:
      . style, layout, format, #defines, etc
      . use of language constructs
      . use of comments
      . side effects
      . etc...
   in fact, almost anything will do, as long as I can panel-beat them into 
   shape for my own purposes. (They MUST be public domain, or the author(s) 
   must be prepared to see them cut about and used in a variety of possibly 
   non-academic ways for internal company project standards - all sources 
   will be acknowledged in any final documents where they are used).
   I seem to remember that Tim Long from Sydney University once produced 
   something like this - were they Public Domain? Are they still available?
   Incidentally, I know there are several books (eg Thomas(?) Plum's C book,
   whose name I can't recall) with standards in them - unfortunately, I need
   a machine readable version.
   Please mail me any responses direct rather than posting as news; I'll 
   summarise if there's any response or interest at all.
   Hamish REID               UUCP:   mcvax!ukc!root44!rootcl!hamish
   Root Computers Ltd, Saunderson House, Hayne Street, LONDON EC1 ENGLAND
EXT-bowles-cbosgd-uucp-8P4DB 18-Feb-86 Re: Arcane C hacks?
   From: {Jeff Bowles <bowles%cbosgd.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-bowles-cbosgd-uucp-8P4DB / <1836@cbosgd.UUCP>
   Posted: 18-Feb-86 19:42-PST  Received: 27-Apr-86 15:45-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 26 Feb 86 03:09:47 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a020366; 26 Feb 86 5:55 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a013876; 26 Feb 86 5:46 EST
   Newsgroups: net.lang.c
   (Gee, wasn't the article I'm replying to supposed to be here, too?)
   Well, anyway, the article I'm following up is one where a programmer asks
   why:
      int i;
      ...
     goto labels[i]; /* "levels" contains pointers to, well,
                      * you get it...
                      */
   went away from C. [I guess it used to be valid. Hmmmm.]
   If you feel the need to do something like this, you probably want to just
   use a structure:
      struct bletch {
             int     l_token;        /* If you see this, */
             void    (*l_whither)(); /* then call this routine */
   };
   Then you can just do a table lookup, calling the appropriate routines for
   each item.
   Or, :-), you can use the "computed goto" that C provides: switch (i) {
      case 0:
                     ...
                     break;
   case 1:
   ...
   }
   The "table lookup" that C provides will usually do what you need, with 
   minimal effort. If you're translating an assembler program and need to 
   "jump to the location specified by the N'th element of this array", I 
   suggest finding a BCPL compiler.
      Jeff Bowles
      Lisle, IL
EXT-ka-hropus-uucp-8P4E2 19-Feb-86 Re: Stack Frames
   From: {Kenneth Almquist <ka%hropus.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-ka-hropus-uucp-8P4E2 / <289@hropus.UUCP>
   Posted: 19-Feb-86 14:26-PST  Received: 27-Apr-86 15:45-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 26 Feb 86 03:24:07 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a020464; 26 Feb 86 6:12 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a014149; 26 Feb 86 5:56 EST
   Newsgroups: net.lang.c
   >> If your C compiler generates additional overhead for local >> blocks, 
   it is not very good.  Most reasonable implementations >> reserve enough 
   stack at function entry for the deepest local >> block nesting within the
   function, so that there is no >> run-time action required upon entering a
   local block. [DAGWYNN] >
   > Not only `not very good' but seemingly impossible. If a separate > 
   stack frame [were] created, access to arguments would be different > 
   within the new block. Still doable, but now try jumping in or
   > out of the block. Getting Hairy!                [COTTRELL]
   There is at least one compiler out there for which does this.  I know 
   because I got a bug report on vnews concerning a piece of code where I 
   jumped into the middle of a block.  The rule is that the effect of 
   jumping into a block containing declarations is machine dependent.  All 
   other jumps, such as jumping into a block that contains no variable 
   declarations or jumping out of a block that does, are all legal, just as 
   in PL/1.
   Cottrell overestimates the difficulty of allocating variables declared in
   a block when that block is entered.  On a stack based machine, when you 
   enter a block with declarations, the compiler merely adjusts the stack 
   pointer to make room for the variables.  When you exit the block, either 
   by reaching the bottom or by doing a goto out of it, the stack pointer 
   must be adjusted back.  This is also fairly simple if the com- piler is 
   prepared to read the entire routine before it starts generating code 
   (otherwise it wouldn't know which goto's required adjustment to the stack
   pointer).  Ideally, the compiler should also adjust the stack pointer 
   when compiling a goto into a block that contains declarations, but C does
   not require this.
   The advantage of this approach is that stack space may be saved if 
   subroutines are called outside the block.  In most code the space savings
   won't make much difference.  The disadvantage is the extra time spent 
   adjusting the stack pointer.  Again this cost is likely to be small, but 
   my guess is that is the cost of adjusting the stack pointer will usually 
   outweigh the space savings that it brings, and most compiler writers 
   appear to agree.  Still, you cannot count on this if you want to write 
   portable code.
                             Kenneth Almquist
                             ihnp4!houxm!hropus!ka   (official name)
                             ihnp4!opus!ka           (shorter path)
EXT-cbk-se-sd-uucp-8P4F8 19-Feb-86 Re: Command line arguments, redirection, 
etc.
   From: {cbk <cbk%se-sd.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-cbk-se-sd-uucp-8P4F8 / <36@se-sd.UUCP>
   Keywords: redirection  arguments
   Posted: 19-Feb-86 15:08-PST  Received: 27-Apr-86 15:45-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 26 Feb 86 03:45:17 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a020530; 26 Feb 86 6:38 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a014836; 26 Feb 86 6:20 EST
   Newsgroups: net.lang.c
   Followup-To: net.lang.c
   [ Inscribed on the line, in very tiny letters, were the words: EAT ME ]
      Hopefully, this "discussion" about argument passing, redirection, and 
      such can be put to rest once and for all.  Here's my two cents worth, 
      having just completed porting the PCC C compiler to a proprietary, 
      decidedly non-UNIX (tm) operating system.
   1. Redirection of standard I/O is a part of C, piping is not. Ref: K&R, 
   chapter 7
      "Finally, the routines are meant to be 'portable', in the sense that 
      they will exist *in compatible form* on any system where C exists"...
      The routines mentioned are those which use "standard I/O".  See page 
      144... "output can be redirected to a file by using >...", and "On the
      UNIX system, a pipe can also be used..."  This implies that 
      redirection is required functionality, whereas piping is a part of a 
      particular operating system.
   2. Command-line arguments are a part of C.
      Ref: K&R, chapter 5.11
      "In environments that support C, there is a way to pass command-line 
      arguments or parameters to a program when it begins executing."
   It sounds to me like this whole issue boils down to whether or not 
   someone has taken the time to *correctly* implement C to provide the 
   functionality as specified in K&R (or whatever else happens to be your 
   favorite standard).
   [ Personal opinion, FLAME ON ]
   Any implementation of C that doesn't provide redirection and command-line
   argument passing is half-assed at best.
   [ FLAME OFF]
   You know, I feel better already!  Hey kiddies, get out YOUR copy of K&R 
   and read, read, read!
   -- Carl Kuck  (apply all standard disclaimers to the preceeding babble)
   UseNet (west) : {wherever}!sdcsvax!ncr-sd!se-sd!cbk (east) : 
   {wherever}!ihnp4!ncr-sd!se-sd!cbk
   PacBell: (619) 450-6271 (w), 944-1705 (h)
   Quote #1: Only those who attempt the absurd can achieve the impossible. 
   Quote #2: 55 mph isn't a good idea, it's just the law...
EXT-guy-sun-uucp-8P4G2 20-Feb-86 Re: Wanted:Compaction Algorithm
   From: {Guy Harris <guy%sun.uucp@BRL.ARPA>}DDN
   To: info-c@BRL-SMOKE.ARPA
   Identifier: EXT-guy-sun-uucp-8P4G2 / <3261@sun.uucp>
   Posted: 20-Feb-86 11:59-PST  Received: 27-Apr-86 15:45-PDT
   Message:
   Return-path: <info-c-request@BRL.ARPA>
   Received: from BRL-AOS.ARPA by OFFICE-1.ARPA; 26 Feb 86 04:00:16 PST
   Received: from brl-smoke.arpa by AOS.BRL.ARPA id a020666; 26 Feb 86 6:56 
   EST
   Received: from USENET by SMOKE.BRL.ARPA id a015398; 26 Feb 86 6:40 EST
   Newsgroups: net.lang.c,net.unix
   Xref: seismo net.lang.c:8107 net.unix:7533
   > I am in need of a packing algorithm which works better than the > PACK 
   Utility of UNIX.  I have also looked at COMPRESS ( developed > at 
   University of Utah ).  COMPRESS works great if distinct number > of input
   bytes is small.  But if the distinct input bytes reach > 256 ( binary 
   data ), PACK works better than COMPRESS.  With PACK > I am getting a 
   saving of 20-25%.  If anybody has an algorithm > that would do better in 
   packing "load modules", I would like to > know about it.
   Are you sure you have the latest version of "compress"?  I tried 
   "pack"ing and "compress"ing "/usr/bin/suntools" (which is a BMF 
   executable image) and "compress" did significantly better than "pack" did
   (it took significantly more time doing it, but that's life).  Remember, 
   Lempel-Ziv compression will discover frequently-occurring sequences of 
   bytes, and unless your machine has all one-byte instructions you're 
   likely to get some multi-byte sequences occurring frequently.
   --
      Guy Harris
      {ihnp4, decvax, seismo, decwrl, ...}!sun!guy
     guy@sun.arpa    (yes, really)
V 2