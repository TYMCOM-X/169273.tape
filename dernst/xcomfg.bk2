	STTL(FOREGROUND LOGIC                         )

  IF	LAPB!LAP
	SEG	A.CODE

::	FOREGROUND EXEC LOOP FOR LAPB and LAP

FEXPSD	WC	0000,FGEX10		:SET 1000 FOR HARDWARE TRACE

FGEXEC	UPSW	FEXPSD			:J FGEX10, SET PSW (FOR POSSIBLE HARDWARE TRACE)

FGEX10	SVC	DISMIS,0
	JAL	R10,FPFORE,,		:UPDATE FRONT PANEL
	J	RFGND						:DRE 9-MAY-86
  EI	LAPB!LAP
	SSTTL(RECEIVE DECISION TABLES)

  IF	LAPB!LAP
:	FOREGROUND RECEIVE COMMAND TABLE USED TO GET AN ADDRESSING INDEX FACTOR
:	INTO DECISION TABLE.
:	ENTRY OF 0 MEANS SABM OR SABME COMMAND RECEIVED.
:	ENTRY OF 2 MEANS DISC COMMAND RECEIVED.
:	ENTRY OF 4 MEANS UA RESPONSE RECEIVE.
:	ENTRY OF 6 MEANS FRMR OR CMDR RESPONSE RECEIVED.
:	ENTRY OF 8 MEANS RR RECEIVED.
:	ENTRY OF 0A MEANS RNR RECEIVED.
:	ENTRY OF 0C MEANS REJ RESPONSE RECEIVED.
:	ENTRY OF 0E MEANS ILLEGAL CONTROL FIELD RECEIVED.
:	ENTRY OF 10 MEANS DM RESPONSE RECEIVED (LAPB) OR A SARM(LAP).
:	ENTRYS ARE BASED ON UPPER 7 BITS OF CONTROL FIELDS.

CMDTBL	HS
:		0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
	BC	08,0E,0A,0E,0C,0E,0E,10,0E,0E,0E,0E,0E,0E,0E,0E	: 0x	:DRE 30-JAN-85
	BC	08,0E,0A,0E,0C,0E,0E,00,0E,0E,0E,0E,0E,0E,0E,0E : 1x	:DRE 30-JAN-85
	BC	08,02,0A,0E,0C,0E,0E,0E,0E,0E,0E,0E,0E,0E,0E,0E : 2x	:DRE 30-JAN-85
	BC	08,04,0A,0E,0C,0E,0E,00,0E,0E,0E,0E,0E,0E,0E,0E : 3x	:DRE 30-JAN-85
	BC	08,0E,0A,06,0C,0E,0E,0E,0E,0E,0E,0E,0E,0E,0E,0E	: 4x	:DRE 30-JAN-85
	BC	08,0E,0A,0E,0C,0E,0E,0E,0E,0E,0E,0E,0E,0E,0E,0E : 5x	:DRE 30-JAN-85
	BC	08,0E,0A,0E,0C,0E,0E,0E,0E,0E,0E,0E,0E,0E,0E,0E : 6x	:DRE 30-JAN-85
	BC	08,0E,0A,0E,0C,0E,0E,0E,0E,0E,0E,0E,0E,0E,0E,0E : 7x	:DRE 30-JAN-85


:	DECISION TABLE FOR RESPONSES RECEIVED ON RESPONSE ADDRESS.

 TABLE(PRIDEC,CODE)			:RESPONSE HANDLER RECEIVE DECISION TABLE
NPSTAT	EQ	0			:INIT # OF RESPONSE HANDLER STATES

:	NOT ARMED TABLE.  ANY CORRECT FRAME RECEIVED WILL BE
:	DISCARDED IF THE POLL BIT IS NOT SET.  THIS STATE CORRESPONDS TO
:	THE DISCONNECTED PHASE OF THE NBS TEST EXCEPT THAT WE ARE STAYING IN
:	THE STATE.
PNARM	EQ	NPSTAT
NPSTAT	EQ	NPSTAT+1
	TENTRY(LPBKER)		:ILLEGAL RESPONSE, SABM(E) RECV., ERROR ON RESPONSE ADDRESS
	TENTRY(LPBKER)		:ILLEGAL RESPONSE, DISC RECV., ERROR ON RESPONSE ADDRESS
	TENTRY(FMDSCD)		:UA RECV., HAVE NO SARM OR DISC OUT, ERROR, DISCARD
	TENTRY(FMDSCD)		:CMDR OR FRMR RECV.,  DISCARD
	TENTRY(FMDSCD)		:SAME FOR RR COMMAND		:DRE 1-MAY-86
	TENTRY(FMDSCD)		:SAME FOR RNR COMMAND		:DRE 1-MAY-86
	TENTRY(FMDSCD)		:SAME FOR REJ COMMAND		:DRE 1-MAY-86
	TENTRY(SNFMSW)		:ILLEGAL CONTROL FIELD,COMPLAIN	:DRE 1-MAY-86
	TENTRY(PLPER1)		:DM RECEIVED
STAT.L	EQ	.-PRIDEC	:LENGTH OF STATE TABLE ENTRY


:	RESPONSE HANDLER ARMING.  A SABM OR SABME OR SARM HAS BEEN TRANSMITTED.
:	CORRESPONDS TO LINK STARTUP STATE IN NBS TESTS.
PARMG	EQ	NPSTAT
NPSTAT	EQ	NPSTAT+1
	TENTRY(LPBKER)		:ILLEGAL RESPONSE, SABM(E) RECEIVED ON RESPONSE ADDR. ERROR
	TENTRY(LPBKER)		:ILLEGAL RESPONSE, DISC RECEIVED ON RESPONSE ADDR. ERROR
	TENTRY(PUAARM)		:UA RECEIVED, PROCESS IT
	TENTRY(FMDSCD)		:CMDR OR FRMR RECEIVED, ERROR, DISCARD
	TENTRY(FMDSCD)		:RR RECEIVED,  ERROR, DISCARD
	TENTRY(FMDSCD)		:RNR RECEIVED  ERROR, DISCARD
	TENTRY(FMDSCD)		:REJ RECEIVED  ERROR, DISCARD
	TENTRY(FMDSCD)		:ILLEGAL CONTROL FIELD, DISCARD	:HJR 12-08-86
	TENTRY(ARM.DM)		:DM RECEIVED

:	PRIMARY STATION WAITING FOR SECONDARY STATION TO ARM.
:	NO RECEIVED FRAMES FOR PRIMARY STATION WILL BE LOOKED AT, TIMEOUT LOGIC
:	AND FOREGROUND XMIT LOGIC WILL HANDLE NEXT DECISION.
  IF	LAP
PWSARM	EQ	NPSTAT
NPSTAT	EQ	NPSTAT+1
	TENTRY(LPBKER)		:ILLEGAL RESPONSE, SABM/SABME  RECEIVED, ERROR
	TENTRY(LPBKER)		:ILLEGAL RESPONSE, DISC RECEIVED, ERROR
	TENTRY(FMDSCD)		:UA   RECEIVED, ERROR, DISCARD
	TENTRY(FMDSCD)		:CMDR RECEIVED, ERROR, DISCARD
	TENTRY(FMDSCD)		:RR   RECEIVED, ERROR, DISCARD
	TENTRY(FMDSCD)		:RNR  RECEIVED, ERROR, DISCARD
	TENTRY(FMDSCD)		:REJ RECEIVED, ERROR, DISCARD
	TENTRY(SNFMSW)		:ILLEGAL CONTROL FIELD.
	TENTRY(PLPER1)		:DM RECEIVED
  EI

:	RESPONSE HANDLER IN INFO XSFER.
:	CALLED THE NORMAL STATE IN THE NBS TEST DOCUMENT.
PINFO	EQ	NPSTAT
NPSTAT	EQ	NPSTAT+1
	TENTRY(PRER2)		:ILLEGAL RESPONSE, SABM(E) RECEIVED,  ISSUE A RESET.
	TENTRY(PRER2)		:ILLEGAL RESPONSE, DISC RECEIVED,  ISSUE A RESET.
	TENTRY(PUAINF)		:UA RECEIVED, SEND FRMR IF NOT SABM COLLISION:DRE 1-MAY-86
	TENTRY(PFRINF)		:CMDR OR FRMR RECEIVED, PROCESS IT
	TENTRY(PRRINF)		:RR RECEIVED, PROCESS IT
	TENTRY(PRNINF)		:RNR RECEIVED, PROCESS IT
	TENTRY(PRJINF)		:REJ RECEIVED, PROCESS IT
	TENTRY(PRER2)		:ILLEGAL CONTROL FIELD, ISSUE A RESET.
	TENTRY(PDMINF)		:DM RECEIVED

:	RESPONSE HANDLER IN TIMER RECOVERY CONDITION.
:	DOESN'T HAVE A SEPARATE STATE THE NBS TESTS.
PTRECV	EQ	NPSTAT
NPSTAT	EQ	NPSTAT+1
	TENTRY(PRER2)		:ILLEGAL RESPONSE, SABM(E) RECEIVED, ISSUE A RESET
	TENTRY(PRER2)		:ILLEGAL RESPONSE, DISC RECEIVED, ISSUE A RESET
	TENTRY(PUAINF)		:UA RECEIVED, SEND FRMR (MAYBE) :DRE 1-MAY-86
	TENTRY(PFRINF)		:FRMR OR CMDR RECEIVED, PROCESS IT
	TENTRY(PRRTMR)		:RR RECEIVED, PROCESS IT
	TENTRY(PRNTMR)		:RNR RECEIVED, PROCESS IT
	TENTRY(PRJTMR)		:REJ RECEIVED, PROCESS IT
	TENTRY(PRER2)		:ILLEGAL CONTROL FIELD, ISSUE RESET.
	TENTRY(PDMINF)		:DM RECEIVED, ENTER DISCONNECTED PHASE

:	RESPONSE HANDLER IN RESET CONDITION.
:	RESPONSE HANDLER LOOKING FOR A UA TO SARM OR SABM(E) SENT. MOST OTHER
:	FRAMES IGNORED.
PRESET	EQ	NPSTAT
NPSTAT	EQ	NPSTAT+1
	TENTRY(LPBKER)		:ILLEGAL RESPONSE, SABM(E) RECEIVED, ERROR.
	TENTRY(LPBKER)		:ILLEGAL RESPONSE, DISC RECEIVED, ERROR.
	TENTRY(PUARST)		:UA RECEIVED, PROCESS IT
	TENTRY(FMDSCD)		:CMDR OR FRMR RECEIVED, ERROR, DISCARD
	TENTRY(FMDSCD)		:RR RECEIVED, ERROR, DISCARD
	TENTRY(FMDSCD)		:RNR RECEIVED, ERROR, DISCARD
	TENTRY(FMDSCD)		:REJ RECEIVED, ERROR, DISCARD
	TENTRY(FMDSCD)		:ILLEGAL CONTROL FIELD, DISCARD	:HJR 12-08-86
	TENTRY(PDMINX)		:DM RECEIVED, ENTER DISCONNECTED PHASE :HJR 04-28-87

:	INTERFACE IN FRAME REJECT STATE. RETRANSMIT FRMR IF ANYTHING
:	RECEIVED EXECPT ANOTHER FRMR.
:
  IF	LAPB
PRFRMR	EQ	NPSTAT
NPSTAT	EQ	NPSTAT+1
	TENTRY(SNFMSW)		:ILLEGAL RESPONSE, SABM(E) RECEIVED ON WRONG ADDRESS :HJR 11-06-86
	TENTRY(SNFMSW)		:ILLEGAL RESPONSE, SAME FOR DISC :HJR 11-06-86
	TENTRY(FMDSCD)		:UNEXPECTED UA RESPONSE		:LSH 01-20-87
	TENTRY(PFRINF)		:RECEIVED AN FRMR, COLLISION,SEND RESET
	TENTRY(FMDSCD)		:RECEIVED AN RR			:HJR 11-06-86
	TENTRY(FMDSCD)		:RECEIVED AN RNR		:HJR 11-06-86
	TENTRY(FMDSCD)		:RECEIVED AN REJ		:HJR 11-06-86
	TENTRY(PFMXMT)		:RECEIVED AN ILLEGAL CONTROL FIELD
	TENTRY(PDMINF)		:RECEIVED A DM, ENTER DISCONNECTED PHASE
  EI

:	RESPONSE HANDLER IN LINK DISCONNECT STATE.
:	RESPONSE HANDLER LOOKING FOR UA TO DISC SENT, ALL OTHER FRAMES IGNORED.
PRDISC	EQ	NPSTAT
NPSTAT	EQ	NPSTAT+1
	TENTRY(LPBKER)		:ILLEGAL RESPONSE, SABM(E) RECEIVED, ERROR
	TENTRY(LPBKER)		:ILLEGAL RESPONSE, DISC RECEIVED, ERROR
	TENTRY(PUADSC)		:UA RECEIVED, PROCESS IT
	TENTRY(FMDSCD)		:CMDR OR FRMR RECEIVED, ERROR, DISCARD
	TENTRY(FMDSCD)		:RR RECEIVED, ERROR, DISCARD
	TENTRY(FMDSCD)		:RNR RECEIVED, ERROR, DISCARD
	TENTRY(FMDSCD)		:REJ RECEIVED, ERROR, DISCARD
	TENTRY(SNFMSW)		:ILLEGAL CONTROL FIELD.
	TENTRY(PDMDSC)		:DM RECEIVED

:	PRIMARY STATION WAITING FOR SECONDARY STATION TO DISCONNECT.
  IF	LAP
PWDISC	EQ	NPSTAT
NPSTAT	EQ	NPSTAT+1
	TENTRY(LPBKER)		:ILLEGAL RESPONSE, SABM(E) RECEIVED, ERROR.
	TENTRY(LPBKER)		:ILLEGAL RESPONSE, DISC RECEIVED, ERROR.
	TENTRY(FMDSCD)		:UA RECEIVED, ERROR, DISCARD
	TENTRY(FMDSCD)		:CMDR RECEIVED, ERROR, DISCARD
	TENTRY(FMDSCD)		:RR RECEIVED, ERROR, DISCARD
	TENTRY(FMDSCD)		:RNR RECEIVED, ERROR, DISCARD
	TENTRY(FMDSCD)		:REJ RECEIVED, ERROR, DISCARD
	TENTRY(SNFMSW)		:ILLEGAL CONTROL FIELD, ERROR, DISCARD
	TENTRY(PLPER1)		:DM RECEIVED
  EI


	SEG	A.RTBL
PRISIX	HS		:INDEX INTO PRIDEC TABLE
  .DOB.(Q,0,NPSTAT)
	HC	Q*STAT.L
  .DOE.0


:	FOREGROUND RECEIVE DECISION TABLE FOR COMMANDS
:	ENTRY BASED ON STATE OF FRAME LEVEL AND RECEIVED CONTROL FIELD.


 TABLE(SECDEC,CODE)
NSSTAT	EQ	0		:INIT COMMAND HANDLER STATE
:	NOT ARMED TABLE  THIS STATE CORRESPONDS TO
:	THE DISCONNECTED PHASE OF THE NBS TEST EXCEPT THAT WE ARE STAYING IN
:	THE STATE.
SECADM	EQ	NSSTAT
NSSTAT	EQ	NSSTAT+1
	TENTRY(SSBNAR)		:RECEIVED A SABM(E) COMMAND, SEND A DM
	TENTRY(SDSNAR)		:RECEIVED A DISCONNECT COMMAND
	TENTRY(SNFMSW)		:RECEIVED A UA ON COMMAND ADDRESS :DRE 1-MAY-86
	TENTRY(SNFMSW)		:SAME FOR FRMR OR CMDR		:DRE 1-MAY-86
	TENTRY(SRRNAR)		:RR RECEIVED, SEND DM IF P=1 FOR LAPB :DRE 1-MAY-86
	TENTRY(SRRNAR)		:RNR RECEIVED, SEND DM IF P=1 FOR LAPB :DRE 1-MAY-86
	TENTRY(SRRNAR)		:REJ RECEIVED, SEND DM IF P=1 FOR LAPB :DRE 1-MAY-86
	TENTRY(SNFMSW)		:SAMEILLEGAL CONTROL FIELD, COMPLAIN! :DRE 1-MAY-86
	TENTRY(SSRNAR)		:SARM

:	TRYING TO ARM
:	CORRESPONDS TO LINK STARTUP STATE IN NBS TESTS.
  IF	LAPB
NSSTAT	EQ	NSSTAT+1
	TENTRY(SSBARM)		:RECEIVED A SABM(E) COMMAND
	TENTRY(SDSARM)		:RECEIVED DISCONNECT, COLLISION OF UNLIKE COMMANDS
	TENTRY(SNFMSW)		:RECEIVED UA ON COMMAND ADDRESS, COMPLAIN!.
	TENTRY(SNFMSW)		:SAME FOR CMDR WITH SEC. ADDRESS
	TENTRY(FMDSCD)		:RR RECEIVED, DISCARD.
	TENTRY(FMDSCD)		:RNR RECEIVED, DISCARD.
	TENTRY(FMDSCD)		:REJ RECEIVED, DISCARD.
	TENTRY(FMDSCD)		:ILLEGAL CONTROL FIELD, DISCARD	:HJR 12-08-86
	TENTRY(ILLCMD)		:SAME FOR DM COMMAND (OR SARM)
  EI


:	INFORMATION TRANSFER STATE
:	CALLED THE NORMAL STATE IN THE NBS TEST DOCUMENT.
SECINF	EQ	NSSTAT
NSSTAT	EQ	NSSTAT+1
	TENTRY(SSBINF)		:RECEIVED A SABM(E)
	TENTRY(SDSINF)		:RECEIVED A DISCONNECT
	TENTRY(SNFMSW)		:RECEIVED A UA WITH WRONG ADDRESS
	TENTRY(SNFMSW)		:RECEIVED FRMR OR CMDR WITH WRONG ADDRESS
	TENTRY(SRRINF)		:RECEIVED RR COMMAND
	TENTRY(SRNINF)		:RECEIVED RNR COMMAND
	TENTRY(SRJINF)		:RECEIVED REJ COMMAND
	TENTRY(SNFMSW)		:RECEIVED ILLEGAL CONTROL FIELD
	TENTRY(SSRINF)		:RECEIVED SARM


:	IN TIMER RECOVERY STATE.
:	DOESN'T HAVE A SEPARATE STATE THE NBS TESTS.
  IF	LAPB
NSSTAT	EQ	NSSTAT+1
	TENTRY(SSBINF)		:RECEIVED A SABM(E) COMMAND
	TENTRY(SDSINF)		:RECEIVED A DISC COMMAND
	TENTRY(SNFMSW)		:RECEIVED A UA WITH WRONG ADDRESS
	TENTRY(SNFMSW)		:RECEIVED AN FRMR WITH WRONG ADDRESS
	TENTRY(SRRINF)		:RECEIVED RR COMMAND FRAME
	TENTRY(SRNINF)		:RECEIVED RNR COMMAND FRAME
	TENTRY(SRJINF)		:RECEIVED REJ COMMAND FRAME
	TENTRY(SNFMSW)		:RECEIVED ILLEGAL CONTROL FIELD
	TENTRY(SSRINF)		:RECEIVED SARM
  EI


:	RESET STATE. MOST FRAMES IGNORED IN THIS STATE (A UA TO THE RESPONSE
:	HANDLER GETS US OUT).
  IF	LAPB
NSSTAT	EQ	NSSTAT+1
	TENTRY(SSBRST)		:RECEIVED A SABM, RETURN A UA, SET FLAG AND GO TO INFO TRNAS :DRE 16-MAY-86
	TENTRY(COLUNL)		:RECEIVED A DISCONNECT, COLLISION OF UNLIKE COMMANDS:DRE 8-MAY-86
	TENTRY(SNFMSW)		:RECEIVED A UA COMMAND, COMPLAIN!
	TENTRY(SNFMSW)		:RECEIVED A FRMR COMMAND, COMPLAIN!
	TENTRY(FMDSCD)		:RECEIVED A RR COMMAND	,IGNOR IT
	TENTRY(FMDSCD)		:RECEIVED A RNR COMMAND ,IGNOR IT
	TENTRY(FMDSCD)		:RECEIVED A REJ COMMAND ,IGNOR IT
	TENTRY(FMDSCD)		:ILLEGAL CONTROL FIELD, DISCARD	:HJR 12-08-86
	TENTRY(SNFMSW)		:RECEIVED A SARM IN LAPB, COMPLAIN!
  EI


:	FRAME REJECT STATE
SECMDR	EQ	NSSTAT
NSSTAT	EQ	NSSTAT+1
	TENTRY(SSBINF)		:EXPECTED COMMAND RECEIVED, GO HANDLE IT
	TENTRY(SDSINF)		:RECEIVED A DISCONNECT
	TENTRY(SNFMSW)		:UA COMMAND, ILLEGAL		:HJR 11-06-86
	TENTRY(SNFMSW)		:FRMR COMMAND, ILLEGAL		:HJR 11-06-86
	TENTRY(SFRFMR)		:RR COMMAND, RESEND FRMR	:HJR 11-06-86
	TENTRY(SFRFMR)		:SAME FOR RNR COMMAND
	TENTRY(SFRFMR)		:SAME FOR REJ COMMAND
	TENTRY(SNFMSW)		:UNKNOWN CONTROL FIELD, ILLEGAL	:HJR 11-06-86
	TENTRY(SNFMSW)		:SARM, ILLEGAL			:HJR 11-06-86


:	LINK DISCONNECT STATE.
SECDSC	EQ	NSSTAT
NSSTAT	EQ	NSSTAT+1
	TENTRY(SSBDSC)		:RETURN A DM RESPONSE AND ENTER NOT ARMED
	TENTRY(SDSDSC)		:RECEIVED DISC
	TENTRY(SNFMSW)		:RECEIVED A UA COMMAND, COMPLAIN!
	TENTRY(SNFMSW)		:SAME FOR FRMR OR CMDR
	TENTRY(SRRNAR)		:RR RECEIVED, SEND DM IF P=1 FOR LAPB :DRE 1-MAY-86
	TENTRY(SRRNAR)		:RNR RECEIVED, SEND DM IF P=1 FOR LAPB :DRE 1-MAY-86
	TENTRY(SRRNAR)		:REJ RECEIVED, SEND DM IF P=1 FOR LAPB :DRE 1-MAY-86
	TENTRY(SNFMSW)		:COMPLAIN ABOUT ILLEGAL CONTROL FIELD :DRE 1-MAY-86
	TENTRY(SSRDSC)		:SARM


	SEG	A.RTBL
SECSIX	HS			:INDEX INTO SECDEC
  .DOB.(Q,0,NSSTAT)
	HC	Q*STAT.L
  .DOE.0


:	COMMAND DECISION TABLE USED WHEN AN I-FRAME IS RECEIVED.
 TABLE(ISEDEC,CODE)
	TENTRY(RINAR)		:RECEIVED I FRAME WHEN NOT ARMED
  IF	LAPB
	TENTRY(RIARM)		:RECEIVED I-FRAME WHEN TRYING TO ARM
  EI
	TENTRY(RIINF)		:IN INFO TRANSFER, PROCESS I FRAME
  IF	LAPB
	TENTRY(RIINF)		:IN TIMER RECOVERY, NO DIFFERENCE ON RECEIVE.
	TENTRY(RIARM)		:IN RESET STATE		:DRE 1-MAY-86
  EI
	TENTRY(RIFRMR)		:IN FRAME OR COMMAND REJECT STATE
	TENTRY(RIDISC)		:IN DISCONNECT STATE
  EI	LAPB!LAP

	STTL(FOREGROUND LOGIC - HDLC                  )
	SSTTL(RECEIVE FRAME)

  IF	HDLC&(LAPB!LAP)


:	RECLAIM ANY RECEIVE SECTORS RTD IS DONE WITH

RFGND	LCS	R0,1
RFG002	L	R1,RTD.FG		:FLAGS OF LINKS WITH RETURNING SECTORS
	JFFO	R1,RFG004		:(R2)=LINK #
	J	RFG008			:NO MORE
RFG004	RBT	R2,RTD.FG		:TELL RTD NOTHING TO DO HERE
	LB	R3,RSC.SZ,R2,		:GET RELATIVE BUFFER SIZE (0,1,2,3)
	SLLS	R3,1			:USE AS HALF WORD OFFSET
	LH	R4,RSC.RT,R2,R2		:HEAD OF RETURNING CHAIN
	JGEFS	RFG003			:IF IT'S REALLY THERE	:HJR 12-12-86
	TRAP(R4,0FF)			:ELSE DIE		:HJR 12-12-86
RFG003	LH	R5,RSC.AE,R3		:END OF AVAIL CHAIN PTR	:HJR 12-12-86
	JGEFS	RFG005			:AVAIL CHAIN IS NOT EMPTY
	STH	R4,RSC.AV,R3		:RETURNING CHAIN BECOMES WHOLE AVAIL CHAIN.
	JFS	RFG006
RFG005	A	R5,RSC.BF,R3,R3		:FIND ABS END OF AVAIL CHAIN
	STH	R4,,R5			:LINK TO END OF AVAIL CHAIN
RFG006	LH	R4,RSC.RE,R2,R2		:END OF RETURNING CHAIN IS NOW
	STH	R4,RSC.AE,R3		:THE END OF THE AVAIL CHAIN
	STH	R0,RSC.RT,R2,R2		:CLEAR PTRS TO BKG CHAIN
	STH	R0,RSC.RE,R2,R2		:FRONT AND END PTRS
	STH	R0,RSC.RA,R2,R2		:AND ADVANCING PTR
	J	RFG002			:SEE IF ANY MORE SECTORS CAN BE RECLAIMED
RFG008	LHI	RL,NLINE
	LHI	RL2,NLINE*2


RFG010	SIS	RL2,2
	JL	FGEXEC
	SIS	RL,1

	LB	RSG,SCGBIA,RL,		:SECTOR GROUP BIAS
	LR	RFB,RL
	SLLS	RFB,4			:FRAME ARRAY BIAS (128 BITS PER LINE)
	LIS	R0,7
	TBT	RL,F128.F
	JEFS	RFG020			:IF NOT MOD128
	LHI	R0,7F
RFG020	STH	R0,FMMSK		:SAVE FRAME LEVEL MOD MASK
	L	RSIO,SIOTBL,RL2,RL2	:GET SIOTABLE BASE ADDRESS
	LB	R2,5,RSIO		:GET BYTE WITH IDLE FLAG :DRE 9-MAY-86
	THI	R2,2						:DRE 9-MAY-86
	JEFS	RFG030			:IF NOT IDLE		:DRE 9-MAY-86
	LIS	R0,1						:DRE 9-MAY-86
	AHM	R0,ABTCNT,RL2					:DRE 9-MAY-86
RFG030	:LB	R5,SECST,RL		:GET STATE OF RECEIVE LOGIC
	:CLHI	R5,SECINF		:
	LIS	R5,SECINF		:
	CLB	R5,SECST,RL		:GET STATE OF RECEIVE LOGIC
	JN	RFG100			:IF COMMAND HANDLER NOT IN INFO XFFER

:	IF COMMAND HANDLER WAS LEFT BUSY, SEE IF ENOUGH BUFFER SPACE HAS
:	OPENED UP TO CLEAR BUSY CONDITION.

	TBT	RL,XSBUSY		:SEE IF BUSY FLAG SET
	JE	RFG100			:IF NOT

	LB	R1,RSC.SZ,RL,		:RELATIVE SIZE OF BUFFER
	LH	R1,RSC.AV,R1,R1		:AVAILABLE PTR
	JGEFS	RFG040			:IF SOME SECTORS LEFT IN AVAIL POOL
	LH	R2,RSC.FD,RL2		:SEE IF LAST SECTOR LEFT DANGLING
	JGEFS	RFG040			:IF EXACTLY ONE MORE AVAILABLE SECTOR
	SBT	RL,NOSTOR		:PREVENT DATA FROM BEING STORED IN RTD RING
	J	RFG100

:	ROOM IN RING, CLEAR BUSY
RFG040	RBT	RL,NOSTOR		:CLEAR NOSTORE FLAG
	RBT	RL,XSBUSY		:CLEAR BUSY
	RBT	RL,DSCARD		:CLEAR DATA DISCARDED FLAG
	JE	RFG050			:IF DISCARD FLAG NOT SET

:	IF DISCARD FLAG SET QUEUE UP A REJ RESPONSE TO CLEAR BUSY
	LIS	R2,XMSREJ		:GET SEND REJ INDEX
	STB	R2,XSSTAT,RL
	SBT	RL,SNTREJ		:SET SENT REJECT FLAG
	LIS	R3,1
	AHM	R3,REJDSC,RL2,		:REJECT SENT BECAUSE OF FRAMES DISCARDED
  IF	XOM
	AHM	R3,LKS.5,RL2,		:SAVE FOR LINK STATISTICS
  EI
	J	RFG100

:	IF DISCARD FLAG NOT SET, QUEUE UP AN RR RESPONSE
RFG050	LIS	R2,XMSRRM		:QUEUE UP A MANDATORY RR RESPONSE
	STB	R2,XSSTAT,RL


::	CHECK FOR INPUT FRAME.

RFG100	LHL	R7,RINDEX,RL2
	A	R7,SIORBF,RSIO		:ADD IN ADDRESS OF RECEIVE BUFFER
	LH	R9,,R7			:READ THE NEXT BYTE COUNT, IS THERE DATA?
	JGE	RFG105			:YES
RFG102	LH	R0,RSC.RT,RL2		:SEE IF RTD CAUGHT UP ON THIS LINE :DRE 21-APR-86
	JGE	TFGND			:NO, GO HANDLE TRANSMIT ROUTINE :DRE 30-DEC-86
	LH	R0,RSC.FG,RL2		:ANYTHING TO GIVE IT ??
	JL	TFGND			:NO, GO HANDLE TRANSMIT ROUTINE :DRE 30-DEC-86
	STH	R0,RSC.RT,RL2		:MOVE CHAIN PTRS FG TO RTD
	STH	R0,RSC.RA,RL2		:INITIALIZE STARTING POINTER
	LH	R0,RSC.FE,RL2
	STH	R0,RSC.RE,RL2
	LCS	R0,1
	STH	R0,RSC.FG,RL2		:CLEAR FG CHAIN PTRS
	STH	R0,RSC.FE,RL2
	SBT	RL,FG.RTD		:TELL RTD TO GET TO WORK
	J	TFGND			:GO HANDLE TRANSMIT ROUTINE :DRE 30-DEC-86
RFG105	STH	R9,RINBYT,RL2		:SAVE BYTE COUNT FOR LATER
  IF	XOM
	TBT	RL,XOMLDH
	JN	RFG200			:IF LINK FORCED TO MARK, IGNORE ALL INPUT
  EI
	AIS	R7,2			:POINT PAST BYTE COUNT
	LIS	R0,2
	TBT	RL,F128.F
	JEFS	RFG110			:IF NOT MOD 128
	LIS	R0,3
RFG110	CR	R9,R0
	JGEFS	RFG130			:IF ENOUGH DATA FOR A FRAME
	LIS	R0,1
	AHM	R0,RERR1,RL2,		:INCREMENT THIS FACT
  IF	XOM
	AHM	R0,LKS.14,RL2,		:SAVE FOR XOM LINK STATISTICS
  EI
	OOPS(2)
	J	RFG200

:	HERE IF ENOUGH DATA TO START ANALYZING FRAME
RFG130	HS
  IF	FINACT				:IF INTERFRAME FILL TIMER ENABLED
	SBT	RL,FRMRCV		:INDICATE FRAME RECEIVED
  EI	FINACT
	LB	R4,,R7			:GET ADDR
	LB	R1,1,R7			:GET CTL1
	AIS	R7,2
	STB	R1,RECVCM,RL		:SAVE 1ST CTL OCTET
	RBT	RL,PFBIT
	RBT	RL,CRBIT
	TBT	RL,F128.F
	JEFS	RFG140			:IF NOT MOD128
	LB	R0,,R7			:GET CTL 2
	AIS	R7,1			:ADVANCE PAST CTL2
	STB	R0,RECVCN,RL		:SAVE CTL 2
	THI	R0,CT.2PF
	JEFS	RFG150			:IF P/F BIT NOT SET
	SBT	RL,PFBIT
	JFS	RFG150

RFG140	STB	R1,RECVCM,RL
	THI	R1,CT.1PF		:CHECK FOR POLL/FINAL BIT
	JEFS	RFG150			:IF P/F BIT NOT SET
	SBT	RL,PFBIT
RFG150	CLH	R9,MFS.LT,RL2,		:SEE IF TOO MUCH DATA
	JLE	RFG155
	FTRACE(,FE.MAX)			:PUT IT IN THE TRACE	:DRE 11-MAR-86
	LIS	R0,1
	AHM	R0,RERR0,RL2,
  IF	XOM
	AHM	R0,LKS.13,RL2,		:SAVE FOR XOM LINK STATISTICS
  EI
	CLB	R4,PADRT,RL,		:COMPARE WITH RESPONSE ADDRESS :DRE 8-MAY-86
	JE	SNFMRY			:IF SO, HANDLE AS RESPONSE :DRE 8-MAY-86
	SBT	RL,CRBIT					:DRE 8-MAY-86
	J	SNFMRY			:GO SEND FRMR WITH Y BIT SET

RFG155	CLB	R4,PADRT,RL,		:COMPARE WITH RESPONSE ADDRESS
	JE	XPRES			:IF SO, HANDLE RESPONSE
	SBT	RL,CRBIT
	CLB	R4,SADRT,RL,		:COMPARE WITH COMMAND ADDRESS
	JN	RFER20			:IF UNKNOWN ADDRESS

:	FRAME IS FOR COMMAND HANDLER OR I-FRAME HANDLER.  PROCESS IT.
RFG160	THI	R1,CT.NIF		:SEE IF AN I-FRAME
	JE	IFRAME			:IF SO

:	HAVE A COMMAND FRAME TO PROCESS.

	FTRACE				:TRACE INPUT FRAME	:DRE 11-MA
	CLHI	R9,3			:HOW LONG IS THE MESSAGE :DRE 1-MAY-86
	JG	SNFMRX			:TOO LONG, SEND FRMR	:DRE 1-MAY-86
	LB	R5,RECVCM,RL
	NHI	R5,CT.TM!0EE		:MASK OFF USED BIT	:DRE 30-JAN-85
	SRLS	R5,1			:DIVIDE BY 2
	LB	R5,CMDTBL,R5		:GET ENTRY FROM TABLE
	LB	R2,SECST,RL
	AH	R5,SECSIX,R2,R2
	LHL	R2,SECDEC,R5
	J	SECDEC,R2


::	RETURN TO HERE.

RFG200	RBT	RL,PFBIT
RFG210	LHL	R2,RINDEX,RL2		:GET RING INDEX USED
	JNFS	RFG220			:IF NOT AT START OF BUFFER
	LCS	R0,1
	L	R3,SIORBF,RSIO		:GET BASE ADDRESS FOR RECEIVE BUFFER
	STH	R0,,R3
RFG220	AIS	R2,3			:ADJ FOR HW CNT FIELD + ROUNDING FOR ODD COUNT
	AH	R2,RINBYT,RL2		:ADD IN BYTE COUNT TO FORM NEXT RINDEX
	NHI	R2,0FFFE		:ADJUST INDEX FOR ROUNDING TO NEXT HW

:	SEE IF ROOM FOR AT LEAST ONE MORE FRAME + HW CNT + HW OF 0FFFF
	CLH	R2,SIORBL,RSIO		:COMPARE AGAINST LENGTH OF THIS BUFFER
	JLEFS	RFG240			:IF ROOM FOR A MAX FRAME
	LIS	R2,0
RFG240	STH	R2,RINDEX,RL2
	TBT	RL,PFBIT		:IS A FINAL RESPONSE NECESSARY :DRE 21-APR-86
	JN	RFG102			:GO DO TRANSMIT OF RESPONSE WITH FINAL BIT ON :DRE 21-APR-86
	J	RFG100
  EI	HDLC&(LAPB!LAP)
	SSTTL(RECEIVE COMMAND HANDLER)

  IF	LAPB!LAP
::	COMMAND HANDLER RECEIVE FRAME ROUTINES.

:	ILLEGAL COMMAND RECEIVED.. IGNORE OR SEND FRAME REJECT

  IF	LAP
SRRNAR	HS
ILLCMD	HS
  EI
FMDSCD	LIS	R5,1
	AHM	R5,ILERR1,RL2,
	J	RFG200
ARM.DM	LIS	R5,1			:SENT SABM AND RECEIVED DM:JL 30-Sep-85
	AHM	R5,ILERR1,RL2,					:JL 30-Sep-85
	AHM	R5,ARMER1,RL2,		:FOR LINK STATUS PURPOSE:JL 30-Sep-85
	J	RFG200

:	SEND FRAME REJECT ROUTINES.

SNFMRX	LIS	R0,FRMR.X!FRMR.W	:SET X AND W BITS	:DRE 1-MAY-86
	JFS	SNFRMR						:DRE 1-MAY-86

SNFMRZ	LIS	R0,FRMR.Z		:SET Z BIT
	JFS	SNFRMR

SNFMRY	LIS	R0,FRMR.Y
	JFS	SNFRMR

  IF	LAP
SRRINF	HS							:DRE 1-MAY-86
SRNINF	HS							:DRE 1-MAY-86
SRJINF	HS							:DRE 1-MAY-86
SSBINF	HS							:DRE 1-MAY-86
  ELSE	LAPB
SSRINF	HS
  EI	LAP
SNFMSW	LIS	R0,FRMR.W

SNFRMR	JAL	R6,SENDFR		:QUEUE UP A FRAME REJECT
	OOPS							:DRE 8-MAY-86
	J	RFG200			:GO CHECK NEXT LINE

:	UNIMPLEMENTED MODE SEND DM OR DISC

  IF	LAPB
SSRDSC	HS
SSRNAR	HS
ILLCMD	HS							:DRE 1-MAY-86
	LIS	R5,1
	AHM	R5,ILERR1,RL2,
DWNRSP	TBT	RL,PFBIT		:SEE IF WE HAVE TO RESPOND :DRE 1-MAY-86
	JE	RFG200			:NO, THEN IGNORE IT
	LIS	R5,XMSDM		:SET UP FOR SENDING DM
	STB	R5,XSSTAT,RL		:PASS REQUEST TO XMIT SIDE
	J	RFG210
  ELSE	LAP
:	RECEIVED SABM IN UNARMED OR DISC STATE.  IF THE OTHER SIDE WANTS AN
:	ANSWER REAL BAD SEND A DM SINCE HE IS A LAPB INTERFACE.
SSBNAR	HS
SSBDSC	HS
	LIS	R5,1
	AHM	R5,ILERR1,RL2,
	TBT	RL,PFBIT		:SEE IF WE HAVE TO RESPOND
	JE	RFG200			:NO, THEN IGNORE IT
	LIS	R5,XMSDM		:SET UP FOR SENDING DM
	STB	R5,XSSTAT,RL		:PASS REQUEST TO XMIT SIDE
	J	RFG210
  EI

:------------------------------------------------------
:	DISCONNECTED PHASE.
:------------------------------------------------------
:LAPB:	SABM	SEND BACK A UA AND ENTER INFO XFER STATE
:	DISC	SENDS BACK A DM
:	RR,RNR,REJ COMMANDS
:		IF P=1, SEND DM W/ F=1
:	(OTHERS ARE IGNORED)
:
:LAP:	DISC	SEND BACK A UA AND SET (STARM)=0
:	SARM	SEND UA IF PRIMARY STATION NOT IN DISC STATE, SET (SARMED)=1.
:-------------------------------------------------------

  IF	LAPB
:	SEE IF WE WILL BE TRYING TO SEND A SABM(E) NEXT TO SET
:	UP THE LINK... IF NOT, WE WILL BE DOING ONE SOON.
:	(POSSIBLE SOFTWARE RACE CONDITION)

SSBNAR	TBT	RL,BCKFLG
	JE	DWNRSP			:IF WE ARE NOT TRYING TO SET UP LINK :DRE 6-MAY-86
  IF	XOM							:DRE 6-MAY-86
	TBT	RL,XOMLDS					:DRE 6-MAY-86
	JN	DWNRSP			:IF XOM WANTS LINK IN DISC STATE :DRE 6-MAY-86
	TBT	RL,XOMLDH					:DRE 6-MAY-86
	JN	DWNRSP			:IF XOM WANTS LINK IN MARKING STATE:DRE 6-MAY-86
  EI
	LB	R5,RECVCM,RL		:GET THE BITS		:DRE 28-APR-86
	THI	R5,40			:THIS BIT IS DIFFERENT IN SABM AND SABME :DRE 28-APR-86
	JEFS	SSBNA2			:SABM, GO CHECK FOR MOD 8:DRE 28-APR-86
	TBT	RL,F128.F		:SABME, ARE WE MOD 128?	:DRE 28-APR-86
	JE	RFG200			:NO, IGNORE IT		:DRE 28-APR-86
	JFS	SSBNA4						:DRE 28-APR-86
SSBNA2	TBT	RL,F128.F		:SABM, ARE WE MOD 8?	:DRE 28-APR-86
	JN	RFG200			:NO, IGNORE IT		:DRE 28-APR-86
SSBNA4	LIS	R5,XMSUA					:DRE 28-APR-86
	STB	R5,XSSTAT,RL		:QUEUE UP AN UA RESPONSE
	SBT	RL,LINKUP		:DECLARE LINK LEVEL UP
	LIS	R5,PINFO
	STB	R5,PRIST,RL		:PUT PACKET LEVEL INTO INFO XFER STATE
	LIS	R5,0
	STB	R5,XPSTAT,RL		:KILL ANY SABM QUEUED UP
	J	RFG210
  EI

  IF	LAP:	RECEIVING A SARM WHEN SECONDARY STATION IS NOT ARMED.
:	IF PRIMARY STATION WAS IN DISCONNECT STATE, THEN SARM IS IGNORED.
:	OTHERWISE SEND A UA AND SET SECONDARY STATION ARMED FLAG.

SSRNAR	LB	R5,PRIST,RL
	CLHI	R5,PRDISC		:SEE IF PRIMARY STATION IN DISCONNECT STATE
	JGE	RFG200			:IGNORE SARM IF SO
	TBT	RL,BCKFLG		:IS THE BACKGROUND STILL RUNNING?
	JE	RFG200			:YES, IGNORE THIS FRAME
	RBT	RL,STARM		:RESET SEC TRYING TO ARM
	JE	RFG200			:IF NOT TRYING ALREADY, SKIP RESPONDING TO SAxM
	SBT	RL,SARMED		:SAY SECONDARY IS ARMED	:DRE 1-MAY-86
	LIS	R5,XMSUA		:GET XMT UA INDEX AND BRING UP :DRE 1-MAY-86
	STB	R5,XSSTAT,RL		:QUEUE UP UA RESPONSE	:DRE 1-MAY-86
	J	RFG210
  EI	LAP


:------------------------------------------------------
:	LINK START-UP PHASE.
:------------------------------------------------------
:LAPB:	SABM	SEND BACK A UA WAIT FOR UA TO OUR SABM
:	DISC	SENDS BACK A DM
:	RR,RNR,REJ COMMANDS
:		IF P=1, SEND DM W/ F=1
:	(OTHERS ARE IGNORED)
:-------------------------------------------------------



  IF	LAPB
:	RECEIVED SABM(E) IN SECRMG 
:	SEND BACK A UA RESPONSE.  SET COLCMD TO INDICATE THAT THERE WAS
:	A SABM COLLISION, THEN GO INTO INFO TRANSFER STATE.

SSBARM	LB	R5,RECVCM,RL		:GET THE BITS		:DRE 28-APR-86
	THI	R5,40			:THIS BIT IS DIFFERENT IN SABM AND SABME :DRE 28-APR-86
	JEFS	SSBAR2			:SABM, GO CHECK FOR MOD 8:DRE 28-APR-86
	TBT	RL,F128.F		:SABME, ARE WE MOD 128?	:DRE 28-APR-86
	JE	RFG200			:NO, IGNORE IT		:DRE 28-APR-86
	JFS	SSBAR4						:DRE 28-APR-86
SSBAR2	TBT	RL,F128.F		:SABM, ARE WE MOD 8?	:DRE 28-APR-86
	JN	RFG200			:NO, IGNORE IT		:DRE 28-APR-86
SSBAR4	LIS	R5,XMSUA		:GET XMT UA INDEX
	STB	R5,XSSTAT,RL		:QUEUE UP UA RESPONSE
	SBT	RL,COLCMD		:INDICATE COLLISION OF LIKE COMMANDS :DRE 1-MAY-86
	SBT	RL,LINKUP		:DECLARE LINK LEVEL UP	:DRE 1-MAY-86
	LIS	R5,PINFO					:DRE 1-MAY-86
	STB	R5,PRIST,RL		:PUT PACKET LEVEL INTO INFO XFER STATE   :DRE 1-MAY-86
	LIS	R5,0						:DRE 1-MAY-86
	STB	R5,XPSTAT,RL		:KILL ANY SABM QUEUED UP :DRE 1-MAY-86
	J	RFG210
  EI	LAPB

:	RECEIVED A DISC COMMAND.
SDSNAR	HS
  IF	LAPB
SDSARM	LIS	R5,XMSDM		:GET XMIT A DM INDEX TO SAY WE ARE ALREADY DISCED
  ELSE	LAP
:	DO NOT RESET THIS FLAG SINCE WE ARE IN THE DESIRED STATE :DRE 7-OCT-87
:	RBT	RL,STARM		:TELL PRIMARY STATION TO ABORT SARM AND SEND DISC
	RBT	RL,SARMED		:IN ANY CASE SECONDARY STATION NO LONGER ARMED
	LIS	R5,XMSUA		:ACKNOLEDGE RECEIPT OF DISC
  EI
	STB	R5,XSSTAT,RL
	J	RFG210

:	RECEIVED AN RR, RNR, OR REJ COMMAND.
:	RESPOND WITH A DM IF P=1.

  IF	LAPB
SRRNAR	TBT	RL,PFBIT
	JNBS	SDSARM			:GO SEND DM
	J	RFG200
  EI


:------------------------------------------------------
:	INFORMATION TRANSFER PHASE.
:------------------------------------------------------
:
:LAPB:	SABM	RESET...  SEND BACK A UA
:	DISC	SEND UA, ENTER DISCONNECT STATE
:	RR,RNR,REJ COMMANDS
:		IF P=1, SEND BACK RR/RNR RESP WITH F=1
:	DM	SEND FRMR WITH W=1
:
:LAP:	DISC	SEND BACK A UA AND SET (STARM)=0
:	SARM	RESET... SEND BACK A UA
:
:------------------------------------------------------


  IF	LAPB
:	RESET OF THE LINK. DO APPROPPRIATE SUFF AND SEND BACK A UA.

SSBINF	LB	R5,RECVCM,RL		:GET THE BITS		:DRE 28-APR-86
	THI	R5,40			:THIS BIT IS DIFFERENT IN SABM AND SABME :DRE 28-APR-86
	JEFS	SSBIN2			:SABM, GO CHECK FOR MOD 8:DRE 28-APR-86
	TBT	RL,F128.F		:SABME, ARE WE MOD 128?	:DRE 28-APR-86
	JE	SNFMSW			:NO, ERROR		:HJR 12-10-86
	JFS	SSBIN4						:DRE 28-APR-86
SSBIN2	TBT	RL,F128.F		:SABM, ARE WE MOD 8?	:DRE 28-APR-86
	JN	RFG200			:NO, IGNORE IT		:DRE 28-APR-86
SSBIN4	LIS	R5,XMSUA		:GET XMIT UA INDEX
	STB	R5,XSSTAT,RL
	LIS	R5,1
	AHM	R5,SRSTER,RL2,		:INCCREMENT #RECVD RESETS IN INFO/CMDR STATE

SSBI10	RBT	RL,COLCMD		:CLEAR SABM COLLISION FLAG :DRE 1-MAY-86
SSBI15	LIS	R5,0
	STB	R5,XVR,RL		:RESET V(R)
	STB	R5,XTNR,RL		:RESET LAST TRANSMITTED N(R)
	RBT	RL,XSBUSY		:RESET BUSY
	RBT	RL,SNTREJ		:RESET SENT REJECT FLAG
	RBT	RL,DSCARD		:RESET DISCARD FLAG
	RBT	RL,NOSTOR
	RBT	RL,T1TA.F		:RESET TRANSMIT TIMER FLAG
	RBT	RL,T1TO.F		:RESET TIMEOUT OCCURRED FLAG
	RBT	RL,OTHBSY		:RESET OTHER END BUSY FLAG
	STB	R5,XVS,RL		:SET V(S) TO ZERO
  IF	FINACT
	RBT	RL,FRMRCV
	RBT	RL,FRMTMT
	RBT	RL,SNTRRC
  EI

:	CLEAR SECTOR ARRAYS
	LB	R2,SCGBIA+1,RL,
	LR	R3,RSG
SSBI20	STH	R5,SECSNT,R3,
	AIS	R3,2
	CR	R3,R2
	JLBS	SSBI20
	ST	R5,VSENT,RFB
	ST	R5,VSENT+4,RFB
	ST	R5,VSENT+8,RFB
	ST	R5,VSENT+0C,RFB

	LH	R5,FMMSK		:INITIALIZE LAST FRAME ACKED CELL
	STB	R5,LVACK,RL
	LB	R5,LSACK,RL		:GET LAST SECTOR ACKED
	AIS	R5,1
	CLB	R5,K.LT,RL,
	JLFS	SSBI30
	LIS	R5,0
SSBI30	STB	R5,NXTSEC,RL		:UPDATE NEXRT SECTOR TO SEND
	LIS	R5,PINFO		:GET INFORMATION TRANSFER STATE
	STB	R5,PRIST,RL		:SET STATE
	J	RFG210


:	RECEIVED A DISCONNECT.
:	PUT INTERFACE IN DISCONNECT STATE AND QUEUE UP A UA RESPONCE.
:	THE FOREGROUND TRANSMIT LOGIC WILL PUT THE INTERFACE IN DISCONNETED
:	STATE.
:	THE BACKGROUND LOGIC WILL THEN INITIATE LINK SET-UP.
:	PDMINF HANDLES DM RECEIVED WHILE IN INFO TRANSFER
:	SDSIN1 IS ENTERRED FROM PDMINX, NOT GOING TO SEND A DM.	:HJR 04-28-87

SDSINF	LIS	R5,XMSUAM		:GET XMIT UA INDEX
	STB	R5,XSSTAT,RL
SDSIN0	LIS	R5,0						:DRE 15-APR-85
	STB	R5,XPSTAT,RL		:SET COMMAND ADDRESS XMIT CELL TO ZERO
	LIS	R5,PRDISC		:GET DISCONNECT STATE	
	STB	R5,PRIST,RL
SDSIN1	LIS	R5,1						:HJR 04-28-87
	AHM	R5,SM.E4,RL,RL
	RBT	RL,PACKUP		:INDICATE PACKET LEVEL DOWN:GLEE 22-Jun-84
	RBT	RL,LINKUP		:INIDCATE LINK LEVEL DOWN:GLEE 22-Jun-84
	JE	RFG210			:IF LINK LEVEL ALREADY DOWN:GLEE 22-Jun-84
	SBT	RL,HANGEM		:HANG ALL USERS		:GLEE 22-Jun-84
	J	RFG210			:GO CHECK NEXT LINE


:	RECEIVED AN RR COMMAND.
:	IF P BIT IS SET, SEND BACK RR RNR WITH F BIT SET.
:	GO TO APPROPRIATE ROUTINE IF WE ARE IN TIMER RECOERY.

SRRINF	JAL	R5,ANR			:GO SEE IF N(R) VALID
	J	SNFMRZ			:IF NOT,SEND FRMR
	RBT	RL,OTHBSY		:CLEAR BUSY FLAG IF SET
	TBT	RL,PFBIT		:POLL BIT ON?		:DRE 6-MAY-86
	JEFS	SRRI20			:NO, NO NEED TO SEND RESP :DRE 6-MAY-86
	LIS	R4,XMSRRM		:GET MUST XMIT RR INDEX
	TBT	RL,XSBUSY		:SEE IF WE WERE LAST LEFT BUSY
	JEFS	SRRI10			:IF NOT
	LIS	R4,XMSRNR		:SEND RNR INSTEAD OF RR
SRRI10	STB	R4,XSSTAT,RL
SRRI20	LB	R5,PRIST,RL		:GET STATE OF INTERFACE	:DRE 6-MAY-86
	CLHI	R5,PINFO		:SEE IF IN INFO XSFER
	JE	RFG210			:IF SO
	J	PRRT10			:MUST BE IN TIMER RECOVERY, GO HANDLE IT


:	RECEIVED AN RNR COMMAND.

SRNINF	JAL	R5,ANR			:CHECK N(R)
	J	SNFMRZ			:IF BAD
	SBT	RL,OTHBSY		:FLAG OTHER END AS BUSY
	TBT	RL,PFBIT		:POLL BIT ON?		:DRE 6-MAY-86
	JEFS	SRNI20			:NO, NO NEED TO SEND RESP :DRE 6-MAY-86
	LIS	R5,XMSRRM		:GET MUST XMIT RR INDEX
	TBT	RL,XSBUSY		:SEE IF WE ARE BUSY
	JEFS	SRNI10			:IF NOT
	LIS	R5,XMSRNR		:GET XMIT RNR INDEX
SRNI10	STB	R5,XSSTAT,RL
SRNI20	LB	R5,PRIST,RL					:DRE 6-MAY-86
	CLHI	R5,PINFO		:SEE IF IN INFO XSFER
	JE	RFG210			:IF SO
	J	PRNT10			:MUST BE IN TIMER RECOVERY


:	RECEIVED A REJECT COMMAND.

SRJINF	JAL	R5,ANR			:CHECK N(R)
	J	SNFMRZ			:IF BAD
	RBT	RL,OTHBSY		:RESET OTHER END BUSY IF SET
	TBT	RL,PFBIT		:POLL BIT ON?		:DRE 6-MAY-86
	JEFS	SRJI20			:NO, NO NEED TO SEND RESP :DRE 6-MAY-86
	LIS	R5,XMSRRM		:GET MUST XMIT RR INDEX
	TBT	RL,XSBUSY
	JEFS	SRJI10			:IF WE ARE NOT BUSY
	LIS	R5,XMSRNR
SRJI10	STB	R5,XSSTAT,RL
SRJI20	LB	R5,PRIST,RL		:CHECK INTERFACE STATE	:DRE 6-MAY-86
	CLHI	R5,PINFO		:SEE IF IN INFO XSFER
	JE	PRJI10			:IF SO
	J	PRJT10			:MUST BE IN TIMER RECOVERY
  ELSE	LAP
:	RECEIVED A SARM WHILE IN INFO XSFER OR CMD REJECT STATE.
:	RETURN A UA AND SET V(R) AND
:	LAST TRANSMITTED N(R) EQUAL TO ZERO.

SSRINF	HS
SSRFMR	HS
	LIS	R5,SECINF
	STB	R5,SECST,RL		:INSURE INFO XFR STATE
	LB	R5,PRIST,RL
	CLHI	R5,PRDISC		:SEE IF PRIMARY STATION IN DISCONNECT STATE
	JGE	RFG200			:IF SO.
	LIS	R5,XMSUA		:GET XMIT UA INDEX
	STB	R5,XSSTAT,RL		:QUEUE UP A UA RESPONSE
	LIS	R5,0
	STB	R5,XVR,RL		:RESET V(R) VALUE TO ZERO
	STB	R5,XTNR,RL		:RESET LAST TRANSMITTED N(R) VALUE
	AIS	R5,1
	AHM	R5,SRSTER,RL2,
	RBT	RL,XSBUSY		:CLEAR BUSY IF SET
	RBT	RL,SNTREJ		:CLEAR SENT REJECT FLAG
	RBT	RL,DSCARD		:RESET DSCARD FLAG IF SET
	RBT	RL,NOSTOR		:RESET NOSTOR FLAG IF SET.
	J	RFG210			:EXIT


:	SECONDARY STATION RECEIVED A DISC COMMAND WHILE IN INFO XSFER.
:	QUEUE UP A UA RESPONSE AND PUT SECONDARY STATION IN DISCONNECT STATE.
:	PRIMARY STATION FUNCTION WILL RETURN SECONDARY STATION TO NOT-ARMED STATE
:	AFTER DISCONNECT OPERATION COMPLETES.

SDSINF	LIS	R5,XMSUA
	STB	R5,XSSTAT,RL		:QUEUE UP A UA RESPONSE
	RBT	RL,SARMED		:RESET SECONDARY STATION ARMED FLAG
	LIS	R5,SECDSC
	STB	R5,SECST,RL		:PUT SECONDARY STATION IN DISCONNECT STATE
	LIS	R5,1
	AHM	R5,SM.E4,RL2,
	J	RFG210			:EXIT


:	SECONDARY STATION RECEIVED WITH CORRECT CHKSUM AN ILLEGAL CONTROL FIELD
:	OR A RESPONSE ON SECONDARY STATION ADDRESS DURING INFO XSFER. SEND A
:	CMDR AND ENTER COMMAND REJECTION CONDITION.		:DRE 1-MAY-86
:SRRINF	HS							:DRE 1-MAY-86
:SRNINF	HS							:DRE 1-MAY-86
:SRJINF	HS							:DRE 1-MAY-86
:SNFMSW	HS							:DRE 1-MAY-86
:SSBINF	LB	R5,RECVCM,RL		:GET CONTROL FIELD BYTE :DRE 1-MAY-86
::	NOTE- P BIT IS NOT TESTED HERE BECAUSE ILLEGAL FRAME MAY HAVE :DRE 1-MAY-86
::	BEEN A RESPONSE.					:DRE 1-MAY-86
:	RBT	RL,PFBIT		:DO THIS IN CASE PREVIOUS RESPONSE MAY NOT :DRE 1-MAY-86
::	HAVE GONE OUT YET					:DRE 1-MAY-86
:	STB	R5,XCMDA1,RL		:PUT IN FIRST OCTET OF INFO FIELD :DRE 1-MAY-86
:	LB	R5,XVR,RL		:GET CURRENT V(R) VALUE	:DRE 1-MAY-86
:	SLLS	R5,5						:DRE 1-MAY-86
:	STB	R5,XCMDA2,RL		:STORE SECOND OCTET	:DRE 1-MAY-86
:	LIS	R5,FRMR.W					:DRE 1-MAY-86
:	STB	R5,XCMDA3,RL		:SET W BIT OF THIRD OCTET :DRE 1-MAY-86
:	LIS	R5,XMSCMD					:DRE 1-MAY-86
:	STB	R5,XSSTAT,RL		:QUEUE UP AN CMDR RESPONSE :DRE 1-MAY-86
:	LIS	R5,SECMDR					:DRE 1-MAY-86
:	STB	R5,SECST,RL		:PUT SECONDARY STATION IN COMMAND REJECT STATE :DRE 1-MAY-86
:	J	RFG200			:EXIT			:DRE 1-MAY-86
  EI	LAP


  IF	LAPB
:	SABM RECEIVED DURING RESET.  COLLISION OF LIKE COMMANDS.  PREFORM
:	RESET, AND SET FLAG TO IGNORE POSSIBLE UA ARRIVING LATER.

SSBRST	LB	R5,RECVCM,RL		:GET THE BITS		:DRE 16-MAY-86
	THI	R5,40			:THIS BIT IS DIFFERENT IN SABM AND SABME :DRE 16-MAY-86
	JEFS	SSBRS2			:SABM, GO CHECK FOR MOD 8:DRE 16-MAY-86
	TBT	RL,F128.F		:SABME, ARE WE MOD 128?	:DRE 16-MAY-86
	JE	RFG200			:NO, IGNORE IT		:DRE 16-MAY-86
	JFS	SSBRS4						:DRE 16-MAY-86
SSBRS2	TBT	RL,F128.F		:SABM, ARE WE MOD 8?	:DRE 16-MAY-86
	JN	RFG200			:NO, IGNORE IT		:DRE 16-MAY-86
SSBRS4	LIS	R5,XMSUA		:GET XMIT UA INDEX
	STB	R5,XSSTAT,RL
	SBT	RL,COLCMD		:COLLISION OF LIKE COMMANDS :DRE 16-MAY-86
	J	SSBI15			:CONTINUE WITH CLEANUP
  EI	LAPB


:------------------------------------------------------
:	FRAME REJECT PHASE.
:------------------------------------------------------
:
:LAPB:	SABM	RESET, SEND UA
:	DISC	SENDS BACK A UA, ENTER DISCONNECT STATE
:	FRMR,DM	RETRANSMIT FRMR
:
:LAP:	DISC	SEND BACK A UA AND SET (SARMD)=0,ENTER DISC STATE
:	SARM	SEND UA, TREAT AS RESET
:	(OTHERS)	SEND CMRJ
:------------------------------------------------------

  IF	LAPB
:	RETRANSMIT FRAME REJECT.
SSRFMR	HS
SFRFMR	LIS	R5,XMSCMD		:GET XMIT FRMR INDEX
	STB	R5,XSSTAT,RL					:LSH 16-APR-87
	TBT	RL,CRBIT		:IS THIS A COMMAND	:DRE 2-MAY-86
	JE	RIARM			:NO, HANDLE AS RESPONSE :DRE 2-MAY-86
	J	RFG210			:PRESERVE POLL BIT	:DRE 2-MAY-86

  ELSE	LAP

:	RETRANSMIT COMMAND REJECT.
SFRFMR	LIS	R5,XMSCMD
	STB	R5,XSSTAT,RL		:QUEUE UP CMDR RESPONSE	:LSH 16-APR-87
	J	RFG200			:EXIT
  EI	LAP


:------------------------------------------------------
:	DISCONNECT STATE.
:------------------------------------------------------
:
:LAPB:	SABM	SEND DM
:	DISC	SENDS BACK A UA
:	(OTHERS ARE IGNORED)
:
:LAP:	DISC	SEND BACK A UA AND SET (STARM)=0, (SARMED)=0
:	SARM	IGNORE
:------------------------------------------------------

:	RECEIVED SABM.
:	SEND A DM RESPONSE AND STAY IN DISCONNECT STATE.

SSBDSC	LB	R5,RECVCM,RL		:GET THE BITS		:DRE 28-APR-86
	THI	R5,40			:THIS BIT IS DIFFERENT IN SABM AND SABME :DRE 28-APR-86
	JEFS	SSBDS2			:SABM, GO CHECK FOR MOD 8:DRE 28-APR-86
	TBT	RL,F128.F		:SABME, ARE WE MOD 128?	:DRE 28-APR-86
	JE	RFG200			:NO, IGNORE IT		:DRE 28-APR-86
	JFS	SSBDS4						:DRE 28-APR-86
SSBDS2	TBT	RL,F128.F		:SABM, ARE WE MOD 8?	:DRE 28-APR-86
	JN	RFG200			:NO, IGNORE IT		:DRE 28-APR-86
SSBDS4	HS							:DRE 8-MAY-86
  IF	LAP							:DRE 8-MAY-86
	LIS	R5,XMSDM		:GET XMIT DM INDEX	
	LB	R0,XSSTAT,RL		:FIRST SEE IF ANYTHING ALREADY QUEUED
	LR	R0,R0
	JN	RFG210			:IF SO, DO NOT QUEUE ANYTHING UP
	STB	R5,XSSTAT,RL
	J	RFG210
  ELSE	LAPB							:DRE 8-MAY-86
	J	COLUNL			:COLLISION OF UNLIKE COMMANDS :DRE 8-MAY-86
  EI	LAP							:DRE 8-MAY-86

:	RECEIVED A DISCONNECT IN DISCONNECT STATE.
:	THIS IS A COLLISION OF LIKE COMMANDS -- SEND BACK AN UA AND
:	ENTER NOT ARMED STATE.

SDSDSC	LIS	R5,XMSUA
	STB	R5,XSSTAT,RL
	RBT	RL,T1TA.F
	RBT	RL,T1TO.F		:TURN TIMER FLAGS OFF
  IF	XOM
	TBT	RL,XOMLDS
	JN	RFG200			:IF XOM WANTS IT DOWN, LEAVE IT DOWN
  EI
	LIS	R5,PNARM
	STB	R5,PRIST,RL		:EXIT DISCONNECTED STATE
  IF	LAP
	LIS	R5,SECADM
	STB	R5,SECST,RL		:EXIT DISCONNECTED STATE
	RBT	RL,SARMED		:RESET SECONDARY STATION ARMED FLAG
	RBT	RL,STARM		:RESET SECONDARY STATION TRYING TO ARM FLAG
  EI
	J	RFG210

  IF	LAP

:	SECONDARY STATION RECEIVED A SARM.
:	INCREMENT ERROR CELL AND DISREGARD SARM.
SSRDSC	LIS	R5,1
	AHM	R5,ILERR2,RL2,		:INCREMENT ERROR CELL
	J	RFG200			:EXIT

:	LAP SECONDARY STATION RECEIVED A DISCONNECT.
:	RETURN A UA AND RESET SECONDARY STATION ARMED FLAG.
:	PRIMARY STATION WILL TAKE SECONDARY STATION OUT OF THIS STATE.

:SDSDSC	LIS	R5,XMSUA
:	STB	R5,XSSTAT,RL		:QUEUE UP A UA RESPONSE
:	RBT	RL,SARMED		:RESET SECONDARY STATION ARMED FLAG
:	RBT	RL,STARM		:RESET SECONDARY STATION TRYING TO ARM FLAG
:	J	RFG210			:EXIT
  EI	LAP

	SSTTL(INFO FRAME)

:------------------------------------------------------
::	I-FRAME PROCESSING ROUTINES.
:------------------------------------------------------


IFRAME	LIS	R5,1
  IF	XOM
	AM	R5,FCNTLK,RL2,RL2	:COUNT NO. OF I-FRAMES RECEIVED
  EI
	LB	R5,SECST,RL		:GET COMMAND HANDLER STATE
	LHL	R5,ISEDEC,R5,R5
	J	ISEDEC,R5

:	COMMAND HANDLER RECEIVED AN I-FRAME IN DISCONNECTED PHASE.
:	FOR LAPB, IF P=1, SEND DM WITH F=1.

  IF	LAPB
RINAR	TBT	RL,PFBIT
	JEFS	RIARM			:IF P BIT NOT SET
	LIS	R5,XMSDM
	STB	R5,XSSTAT,RL		:QUEUE UP A DM RESPONSE
  EI	LAPB

:	RECEIVED AN I-FRAME IN ARMING STATE.
:	DISCARD IT.

RIARM	HS
  IF	LAP
RINAR	EQ	RIARM
  EI	LAP

  IF	BSC			:BYSINC FRAMING
	LA	R5,XSYNC
	ST	R5,XYSUB,RL2,RL2	:SET UP LINE TO GO BACK LOOKING FOR
:					 THE START OF A NEW FRAME
  EI
	FTRACE(SADRT,FE.ERR)		:TRACE INPUT FRAME
   IF	HDLC
	J	RFG200
   ELSE	BSC
	J	RQPOP1			:GO LOOK FOR MORE DATA ON LINE
   EI

:	COMMAND HANDLER RECEIVED AN I-FRAME WHILE IN DISCONNECT,
:	COUNT IT AND SEND DM/F IF I/P.

RIDISC	LIS	R5,1
	AHM	R5,ILERR4,RL2,		:INCREMENT ERROR CELL
	J	RINAR						:DRE 1-MAY-86


  IF	LAPB
:	RECEIVED I-FRAME WHILE IN FRAME REJECT STATE.
:	RETRANSMIT FRMR.

RIFRMR	EQ	SFRFMR			:GO SEND FRMR AGAIN

  ELSE	LAP
:	SECONDARY STATION RECEIVED AN I-FRAME WHILE IN THE COMMAND REJECTION
:	STATE.  SINCE WE ARE STILL TRANSMITTING INFORMATION
:	FRAMES, USE N(R) TO UPDATE OUR WINDOW.
RIFRMR	SBT	RL,NOSTOR		:DO NOT STORE I-FRAME IN RTD RING
	JAL	R5,IIC			:INPUT I-FRAME AND CHECK
	J	RIF040			:RETURN HERE AND JUMP IF MAX BYTE COUNT ERROR

:	NORMAL RETURN
	RBT	RL,NOSTOR
	LB	R4,PRIST,RL
	CLHI	R4,PRESET		:SEE IF PRIMARY STATION IN RESET STATE
	JEFS	SNCMDR			:IF SO, N(R) IS NOT LOOKED AT
	JAL	R5,ANR			:GO LOOK AT N(R) VALUE
	J	RIF100			:INVALID N(R)

:	NOW RETRANSMIT THE CMDR.
SNCMDR	FTRACE(SADRT,FE.ERR)		:INPUT FRAME TRACE	:DRE 11-MAR-86
	RBT	RL,NOSTOR
:	SINCE ALREADY IN COMMAND REJECT NO NEED TO RESET UP INFO FIELD OF CMDR.
	LIS	R5,XMSCMD		:SET UP SECONDARY STATION XMIT TO SEND CMDR
	STB	R5,XSSTAT,RL					:LSH 16-APR-87
	J	RFG200			:EXIT.

  EI	LAP



:	COMMAND HANDLER RECEIVED AN I-FRAME WHEN IN INFO XSFER, PROCESS IT.
:
RIINF	JAL	R5,IIC			:INPUT I-FRAME AND CHECK
	J	RIF040			:RETURN HERE IF MAX BYTE COUNT ERROR
	RBT	RL,COLCMD		:CLEAR SABM COLLISION FLAG :DRE 1-MAY-86

:	HAD A GOOD CHECKSUM ON I-FRAME, GO CHECK N(S).
:	*NOTE* SEQUENCE ERROR IS NOT AN INVALID N(S).
	JAL	R5,ANS			:CHECK N(S)
	J	RIF050			:RETURN HERE IF N(S) INVALID.

:	VALIDATE N(R).
:	FOR *LAP*, IF PRIMARY STATION IS IN RESET STATE, IGNORE THE N(R)
  IF	LAP
	LB	R4,PRIST,RL
	CLHI	R4,PRESET
	JEFS	RIF030			:IF PRIMARY STATION IN RESET STATE
  EI	LAP
	JAL	R5,ANR			:GO CHECK N(R) VALUE
	J	RIF100			:RETURN HERE IF N(R) INVALID.

RIF030	TBT	RL,NOSTOR
	JE	RIF035			:IF FRAME NOT DISCARDED
	FTRACE(SADRT,FE.DSC)		:TRACE WITH DISCARD ERROR FLAG
	JFS	RIF037			:PROCESS I-FRAME
RIF035	FTRACE(SADRT)			:INPUT FRAME TRACE
RIF037	JAL	R5,FIF			:GO FINISH I-FRAME PROCESS IF ALL O'K
	J	RFG210


:	ROUTINE TO PROCESS MAX BYTE COUNT EXCEEDED BEFORE FINDING AN END
:	FLAG ERROR.
RIF040	FTRACE(SADRT,FE.MAX)		:INPUT FRAME TRACE
	LIS	R5,1
	AHM	R5,MAXERR,RL2,		:INCREMENT MAX ERROR CELL
  IF	XOM
	AHM	R5,LKS.17,RL2,		:SAVE XOM LINK STATISTICS
  EI
:	OOPS
	RBT	RL,NOSTOR
:	LIS	R0,FRMR.Y
:	JAL	R6,SENDFR		:QUEUE UP A FRMR/CMDR
:	J	RFG200			:EXIT
	J	SNFMRY			:QUEUE UP A FRMR/CMDR	:DRE 8-MAY-86

:	I-FRAME WITH AN INVALID N(S). SEND A FRMR IF X.75 OR RESET LINK
:	IF X.25
RIF050	FTRACE(SADRT,FE.NS)		:INPUT FRAME TRACE
	OOPS
  IF	LAPB
	JAL	R5,ANR			:FIRST SEE IF N(R) VALID
	J	RIF100			:INVALID N(R), SEND FRMR

	RBT	RL,NOSTOR		:RESET FLAG IN CASE IT GOT SET
    IF	X.75
	LIS	R0,FRMR.W
	JAL	R6,SENDFR		:SEND FRMR
    ELSE	X.25
	LIS	R5,XMPSAM		:GET XMIT SABM INDEX
	STB	R5,XPSTAT,RL
	LIS	R5,PRESET		:GET RESET STATE
	STB	R5,PRIST,RL
	LIS	R5,1
	AHM	R5,SM.E3,RL2,		:INCREMENT ERROR CELLS
    EI	X.25
	J	RFG200
  ELSE	LAP
	LIS	R0,FRMR.W
	JAL	R6,SENDFR			:QUEUE UP A CMDR

:	NOW SEE IF N(R) IS VALID AND IF SO ACK FRAMES. IF NOT
:	TELL PRIMARY STATION TO SEND A SARM AND GO INTO RESET CONDITION.
	LB	R5,PRIST,RL
	CLHI	R5,PRESET		:SEE IF PRIMARY STATION ALREADY IN RESET STATE
	JEFS	RIF070			:IF SO
	JAL	R5,ANR			:GO LOOK AT N(R)
	J	RIF080			:RETURN HERE IF N(R) INVALID

RIF070	RBT	RL,NOSTOR		:RESET NO STORE FLAG IF SET
	J	RFG210			:AND EXIT

RIF080	LIS	R5,XMPSAM		:GET XMIT SARM INDEX
	STB	R5,XPSTAT,RL		:TELL PRIMARY STATION XMIT ABOUT IT
	LIS	R5,PRESET
	STB	R5,PRIST,RL		:SET PRIMARY STATION STATE TO RESET CONDITION
	LIS	R5,1
	AHM	R5,SM.E3,RL2,
	J	RIF070

  EI	LAP

:	I FRAME DETECTED WITHOUT AN INVALID N(S) BUT WITH A BAD N(R).
:	HAVE PRIMARY STATION SEND RESET.
:	
RIF100	FTRACE(SADRT,FE.NR)		:INPUT FRAME TRACE
  IF	LAPB
	J	SNFMRZ			:GO SEND FRAME REJECT
  ELSE	LAP
	LIS	R5,XMPSAM		:GET XMIT SARM INDEX
	STB	R5,XPSTAT,RL		:SET UP FOREGROUND XMIT
	LIS	R5,PRESET
	STB	R5,PRIST,RL		:SET PRIMARY STATION STATE TO RESET
	LIS	R5,1
	AHM	R5,SM.E3,RL2,

:	NOW GO FINISH I-FRAME PROCESS AS IF IN NORMAL MODE.
:	THIS I-FRAME MAY BE ACCEPTED SINCE THE N(S) WAS NOT INVALID AND
:	IF NO SEQUENCE ERROR WAS DETECTED.
	JAL	R5,FIF
	J	FMDSCD

  EI	LAP

  EI	LAPB!LAP
	SSTTL(RECEIVER RESPONSE HANDLERS)


  IF	LAPB!LAP
:	ROUTINE TO PROCESS RESPONSES DIRECTED TO RESPONSE HANDLER
:	RR,RNR,REJ,UA AND CMDR ARE PROCESSED HERE.
:	CMDR WILL HAVE 3 BYTES OF INFO WITH IT, ALL OTHERS DO NOT
:	HAVE AN INFO FIELD.
:
   IF	HDLC
XPRES	LB	R0,RECVCM,RL		:GET CTL1 BACK
	THI	R0,CT.NIF		:SEE IF INFO FRAME
	JE	XPRERR			:ERROR IF SO
	NHI	R0,@CT.NIF		:MASK OFF UNUSED BIT
	TBT	RL,F128.F
	JE	XPR020			:IF NOT MOD128
	CLHI	R0,CT.FR		:SEE IF AN FRMR RESPONSE
	JEFS	XPR010			:IF FRMR
	SIS	R9,3
	JE	XPR080			:IF BYTE COUNT CORRECT
	J	RFER40

XPR010	SIS	R9,8
	JN	RFER30			:IF NOT CORRECT LENGTH
	LIS	R9,5
	LIS	R5,4			:POSITION OF N(R)BYTE
	J	XPR040

XPR020	CLHI	R0,CT.FR
	JEFS	XPR030			:IF FRMR
	SIS	R9,2
	JE	XPR080			:IF CORRECT LENGTH
	J	RFER40

XPR030	SIS	R9,5
	JN	RFER30			:IF NOT CORRECT LENGTH
	LIS	R9,3
	LIS	R5,2			:POSITION OF N(R) IN FRMR
XPR040	:LB	R0,RBUF,R7		:GET NEXT OCTET
	LB	R0,,R7			:GET NEXT OCTET
	AIS	R7,1
	CR	R9,R5
	JNFS	XPR050			:IF NOT N(R) OF FRMR
	STB	R0,FRMRNR		:SAVE REJECTED N(R)
XPR050	SIS	R9,1
	JGBS	XPR040
  ELSE	BSC
XPRES	LB	R0,RECVCM,RL
	THI	R0,CT.NIF		:SEE IF I-FRAME
	JE	XPRERR			:ERROR-NO I FRAME SHOULD BE RECEIVED ON PRIMARY STATION ADDRESS
	NHI	R0,@CT.NIF		:MASK OFF UNUSED BIT	:DRE 1-MAY-86
	CLHI	R0,CT.FR		:CHECK IF THIS IS A CMDR RESPONSE
	JN	XPR070			:IF NOT

:	CONTROL FIELD WAS A CMDR, READ 3 OCTETS OF INFO FIELD AND SAVE.
	LCS	R5,3
	STH	R5,XPCNT,RL2		:COUNT USED TO READ 3 OCTETS
XPR040	JAL	R5,BVCHAR		:GET BYTE OF DATA
	J	XSYEXI
	CLHI	R2,DLE			:SEE IF A DLE
	JNFS	XPR050			:IF NOT

	JAL	R5,BVCHAR		:GET NEXT BYTE
	J	XSYEXI
	CLHI	R2,DLE			:SEE IF THIS IS A DLE
	JEFS	XPR050			:IF SO
	CLHI	R2,SYN
	JE	XPR040
	J	RFER10			:ERROR IF NOT

XPR050	JAL	R5,ICHKSM		:CHECKSUM CHAR
	LH	R6,XPCNT,RL2		:GET CHAR READ COUNT
	CHI	R6,-2
	JNFS	XPR060
	STB	R0,FRMRNR		:SAVE CMDR BYTE
XPR060	AIS	R6,1			:INCREMENT BYTE READ COUNT
	JEFS	XPR070			:IF HAVE 3 BYTES
	STH	R6,XPCNT,RL2		:SAVE NEW COUNT
	J	XPR040			:GET NEXT BYTE

:	NOW GET DLE/ETX END FLAG AND CHECKSUM
XPR070	JAL	R5,BVCHAR		:THIS SHOULD BE A DLE
	J	XSYEXI
	CLHI	R2,DLE			:SEE IF A DLE
	JN	XSYER5			:IF NOT, FRAME IS IN ERROR

:	NOTE- DLE BEFORE ETX IS NOT CHECKSUMMED BUT ETX IS.
	JAL	R5,BVCHAR
	J	XSYEXI
	CLHI	R2,SYN			:SEE IF INTERFRAME TIME FILL
	JEBS	XPR070
	CLHI	R2,ETX			:THIS SHOULD BE AN ETX
	JN	RFER10			:IF NOT
	JAL	R5,ICHKSM		:CHECKSUM ETX

:	NOW GO COMPUTE FINAL CHECKSUM AND COMPARE AGAINST ONE SENT
	JAL	R6,CKFNAL
   EI	BSC


XPR080	FTRACE(PADRT)			:INPUT FRAME TRACE
	LB	R5,RECVCM,RL		:GET CONTROL FIELD BACK
	NHI	R5,CT.TM!0EE		:MASK OF UNDEFINED BIT	:DRE 30-JAN-85
	SRLS	R5,1			:DIVIDE BY 2
	LB	R5,CMDTBL,R5		:GET ENTRY FROM COMMAND TABLE
	LB	R2,PRIST,RL		:ADD IN RESPONSE HANDLER STATE
	AH	R5,PRISIX,R2,R2
	LHL	R2,PRIDEC,R5
	J	PRIDEC,R2


:------------------------------------------------------
::	RECEIVE RESPONSE HANDLERS.
:------------------------------------------------------


:	RESPONSE HANDLER RECEIVED A SABM OR SARM OR DISCONNECT COMMAND
:	WITH ITS OWN ADDRESS... LOOP BACK ERROR.
:	(I-FRAMES ARE NOT COUNTED FOR LOOP BACKS.)

LPBKER	LIS	R5,1
	AHM	R5,SM.F,RL2,
  IF	XOM
	AHM	R5,LKS.10,RL2,		:SAVE FOR XOM LINK STATISTICS
  EI
	J	RFG200

  IF	LAPB
PLPER1	EQ	FMDSCD			:DM RECEIVED
  ELSE	LAP
PLPER1	EQ	LPBKER			:SARM RECEIVED
  EI
:------------------------------------------------------
:	LINK START-UP PHASE.
:------------------------------------------------------
:LAPB:	UA	RESPONSE TO OUR SABM, GO INTO INFO TRANSFER
:	(OTHERS ARE IGNORED)
:LAP:	UA	IF SECONDARY STATION ARMED GO INTO INFO TRANSFER
:		 ELSE GOINTO WAITING FOR SECONDARY TO ARM
:	(OTHERS ARE IGNORED)
:-------------------------------------------------------



  IF	LAPB
:	RESPONSE HANDLER RECEIVED A UA RESPONSE WHEN IT HAS A SABM OUT AND IN ARMING
:	STATE. PUT INTERFACE INTTO INFO XSFER STATE.
:
PUAARM	HS
	TBT	RL,PFBIT		:TEST FBIT
	JE	RFG200			:IF NOT SET, IGNORE SINCE NOT RESPONSE TO SABM
	RBT	RL,T1TA.F		:TURN OFF TIMER ON SABM
	RBT	RL,T1TO.F		:RESET TIMEOUT OCCURRED FLAG
	LCS	R5,1
	STH	R5,XRETER,RL2		:ZERO OUT RETRANSMISSION COUNTER
	SBT	RL,LINKUP		:FLAG LINK AS BEING UP
	LIS	R5,PINFO
	STB	R5,PRIST,RL		:SET INFO XSFWR STATE
	J	RFG200			:EXIT AND LOOK AT NEXT LINE

  ELSE	LAP
:	PRIMARY STATION RECEIVED A UA RESPONSE WHEN IT HAS A SARM OUT AND IN ARMING
:	STATE.	SET PRIMARY STATION ARMED FLAG AND CHECK SECONDARY STATION FUNCTION TO SEE
:	IF ARMED.
:
PUAARM	:SBT	RL,PARMED		:FLAG PRIMARY STATION AS ARMED
	RBT	RL,T1TA.F		:TURN OFF TIMER ON SARM
	RBT	RL,T1TO.F		:RESET TIMEOUT OCCURRED FLAG
	LCS	R5,1
	STH	R5,XRETER,RL2		:RESET RETRANSMISSION COUNTER
	TBT	RL,SARMED		:SEE IF SECONDARY STATION ARMED.
	JN	PUAA10			:IF SO

:	SINCE SECONDARY STATION IS NOT ARMED YET, PUT PRIMARY STATION IN
:	WAITING FOR SECONDARY STATION TO ARM STATE AND RESTART TIMER T1.
:	IF TIMER RUNS OUT BEFORE SECONDARY STATION ARMS PUT TRANSMIT IN
:	ARMING STATE AND SEND SARM AGAIN.

	LIS	R5,PWSARM
	STB	R5,PRIST,RL		:SET PRIMARY STATION STATE TO WAITING FOR SEC. TO ARM
	L	R5,FASTC,,		:GET PRESENT CLOCK TIME FROM ISIS
	AH	R5,T1.LT,RL2,		:GET NEW T1 TIME
	ST	R5,T1CNTR,RL2,RL2	:SAVE NEW T1 TIME
	SBT	RL,T1TA.F		:TURN TIMER BACK ON
	LB	R5,RTCNT,RL		:GET RETRANSMISSION COUNT
	STH	R5,XRETER,RL2		:SAVE NEW RETRANSMISSION COUNT
	J	RFG200			:EXIT AND LOOK AT NEXT LINE


:	IF SECONDARY STATION IS ARMED WHEN PRIMARY STATION ARMS MAKE SURE SECONDARY STATION
:	IS IN THE NOT ARMED STATE. (PROGRAMMING ERROR IF NOT.)
:	BACKGROUND PROCESSING WILL HAVE TAKEN CARE OF INITIALIZING ALL
:	NECESSARY VARIABLES.
:	NOTE- BE SURE TO DO THIS.!!!!!
:	SET FLAG TELLING BACKGROUND LOGIC THAT LINK IS UP SO
:	PACKET LEVEL LOGIC WILL RUN.
:
PUAA10	LB	R5,SECST,RL		:GET SECONDARY STATION STATE
	JN	PUAA30			:IF NOT IN NOT ARMED STATE
PUAA20	LIS	R5,PINFO
	STB	R5,PRIST,RL		:PUT PRIMARY STATION IN INFO XSFER
	LIS	R5,SECINF
	STB	R5,SECST,RL		:PUT SECONDARY STATION IN INFO XSFER
	SBT	RL,LINKUP		:FLAG LINK AS BEING UP
	J	RFG200			:EXIT AND LOOK AT NEXT LINE

:	PRIMARY STATION STATE JUST GOT ARMED BUT SECONDARY STATION WAS NOT IN NOT
:	ARMED STATE.  THIIS IS A PROBABLE PROGRAMMING ERROR.
:
PUAA30	LIS	R5,1
	AHM	R5,ILERR9,RL2,		:INCREMENT ERROR CELL
	OOPS
	J	PUAA20			:AND CONTINUE.

  EI	LAP

:------------------------------------------------------
:	INFORMATION TRANSFER PHASE.
:------------------------------------------------------
:
:LAPB:	RR,RNR,REJ RESPONSE
:		IF F=1, SEND A SABM AND ENTER RESET STATE
:	FRMR	SEND A SABM AND ENTER RESET STATE
:	DM	SEND FRMR WITH W=1
:	UA	IGNORE IF ENTERED INFO STATE FROM SABM COLISION
:		 ELSE SEND FRMR WITH W=1
:
:LAP:	RR,RNR,REJ RESPONSE
:		IF F=1, SEND A SARM AND ENTER RESET STATE
:	UA	SEND FRMR WITH W=1
:
:------------------------------------------------------



:	RECEIVED A FRMR RESPONSE WHILE IN INFO XSFER.
:	THIS IS A PROBABLE PROGRAMMING ERROR AND MAY NOT GET
:	RESOLVED BY DOING A RESET AND RETRANSMITTING FRAME IN ERROR.
:	FOR NOW JUST USE N(R) IN INFO FIELD OF FRMR AND ACK ANY
:	FRAMES USING THIS N(R) AND THEN SEND A SABM AND PUT
:	RESPONSE HANDLER IN RESET STATE.
:
PFRINF	RBT	RL,T1TA.F		:TURN TIMER OFF
	RBT	RL,T1TO.F		:RESET TIMEOUT OCCURRED FLAG
	LB	R5,FRMRNR		:GET N(R) VALUE
	STB	R5,RECVCN,RL		:SET UP CELL FOR N(R) ANALYSIS (MOD8)
	STB	R5,RECVCM,RL		:SET UP N(R) FOR ANALYSIS (MOD128)
:	NOW GO LOOK AT N(R) VALUE AND USE IT TO ACK ANY FRAMES.
	JAL	R5,ANR
	NOP	0,0			:ERROR RETURN HERE, BUT NO MATTER SINCE A SARM
:	IS BEING SENT ANYWAY.
	LIS	R5,1
	AHM	R5,CMDRCV,RL2,		:INCREMENT ERROR CELL

:	SEND RESET AND ENTER RESET STATE.
SNDSAM	LIS	R5,XMPSAM		:GET XMIT SABM INDEX	:LSH 16-APR-87
	STB	R5,XPSTAT,RL		:QUEUE UP A SARM COMMAND
	RBT	RL,T1TA.F		:STOP TIMER IF RUNNING
	RBT	RL,T1TO.F		:RESET TIMEOUT OCCURRED FLAG
	LIS	R5,PRESET
	STB	R5,PRIST,RL		:SET RESPONSE HANDLER STATE TO RESET
	J	RFG200			:EXIT AND LOOK AT NEXT LINE
:  IF	LAPB
:	RECEIVED AN ILLEGAL OR CORRECT FRAME WHEN IN FRAME REJECT STATE.
:	SEND FRMR AGAIN, BUT SINCE THIS IS COMMAND ADDRESS DO  NOT
:	CHECK F BIT.

:PFMXMT	LHI	R5,XMSCMD		:GET XMIT FRMR INDEX
:	STB	R5,XSSTAT,RL
:	J	RFG200
:  EI
PFMXMT	EQ	SNFMSW			:SEND REJECT WITH W BIT:DRE 1-MAY-86

:	RECEIVED UA WHILE IN INFO TRANSFER STATE.  COULD BE LEFT OVER FROM
:	SABM COLLISION AT LINK SETUP.

  IF 	LAPB
PUAINF	RBT	RL,COLCMD		:WAS THERE A COLLISION?	:DRE 1-MAY-86
	JN	RFG200			:YES, IGNORE THE EXTRA UA :DRE 1-MAY-86
	J	SNFMSW			:COMPLAIN ABOUT IT	:DRE 1-MAY-86
  ELSE	LAP				:THIS SHOULDN'T HAPPEN IN LAP :DRE 1-MAY-86
PUAINF	EQ	SNFMSW						:DRE 1-MAY-86
  EI	LAPB


:-------------------------------------------------------------	:HJR 04-28-87
  IF	LAPB
:	RECEIVED AN UNSOLICITED DM WHILE IN RESET STATE.  GO INTO NOT
:	ARMED STATE AND TELL BACKGROUND TO REINITIALIZE.

PDMINX	LIS	R5,PNARM		:SET NOT ARMED
	STB	R5,PRIST,RL
	SBT	RL,REINIT		:REINITIALIZE
	RBT	RL,BCKFLG		:INHIBIT ACTIVITY UNTIL BACKGROUND DONE
	J	SDSIN1			:FINISH UP
  ELSE	LAP
PDMINX	EQ	LPBKER			:IN LAP THIS IS A SARM
  EI
:-----------------------------------------------------------------------

:	RECEIVED AN UNSOLICITED DM RESPONSE WHILE IN INFO TRANSFER
:	OR TIMER RECOVERY.
:	GO INTO NOT ARMED STATE AFTER SENDING DM FROM DISCONNECTED STATE
:	COLUNL SEND DM AFTER COLLISION OF UNLIKE COMMANDS

  IF	LAPB
COLUNL	HS							:DRE 1-MAY-86
PDMINF	LIS	R5,XMSDMM		:GET XMIT DM INDEX
	STB	R5,XSSTAT,RL
	RBT	RL,REINIT		:SIGNAL BACKGROUND TO RUN IMMEDIATELY:DRE 15-APR-85
	RBT	RL,BCKFLG		:INHIBIT ACTIVITY UNTIL BACKGROUND DONE:DRE 15-APR-85
	J	SDSIN0						:DRE 15-APR-85
  ELSE	LAP
PDMINF	EQ	LPBKER			:IN LAP THIS IS A SARM
  EI


:	RECEIVED AN ILLEGAL CONTROL FIELD OR COMMAND.
:	SEND FRMR AND ENTER FRAME REJECT STATE FOR LAPB.

PRER2	LIS	R5,1
	AHM	R5,ILERR6,RL2,		:INCREMENT FACT THIS HAPPENED
  IF	LAPB
	J	SNFMSW			:GO SEND FRMR AND ENTER FRAME REJECT STATE
  ELSE	LAP
	J	SNDSAM			:SEND SARM AND ENTER RESET STATE
  EI


:	RECEVIED A FRAME ON COMMAND ADDRESS WITH A BAD N(R),
:	 SEND AN FRMR.
  IF	LAPB
PRER2X	LIS	R5,1
	AHM	R5,ILERR6,RL2,
	J	SNFMRZ
  ELSE	LAP
PRER2X	EQ	PRER2			:DO RESET FOR LAP
  EI



:	RESPONSE HANDLER RECEIVED AN I-FRAME. THIS IS AN ERROR, JUST THROW REST
:	OF FRAME AWAY AND GO LOOK FOR START OF A NEW FRAME.
:	NOTE- THIS I-FRAME IS NOT INPUTTED TO CHKSUM BUT IS JUST THROWN AWAY.
:	ASSUMING FRAME HAS BEEN CHANGED BY HITS ON LINE.
:	
XPRERR	LIS	R5,1
	AHM	R5,ILERR8,RL2,		:INCREMENT ERROR CELL
   IF	HDLC
    IF	LAPB
	J	SNFMSW			:SEND FRMR
    ELSE	LAP
	J	RFG200
    EI
   ELSE	BSC
	LA	R5,XSYNC
	ST	R5,XYSUB,RL2,RL2
	J	RQPOP1
   EI




:	RESPONSE HANDLER RECEIVED AN RR RESPONSE WHILE IN TIMER RECOVERY CONDITION.
:	CHECK IF N(R) ACKS FRAME BEING RETRANSMITTED.  IF NOT CONTINUE
:	IN TIMER RECOVERY CONDITION.
:	IF IT DOES CHECK F BIT.  IF SET GO OUT OF TIMER RECOVERY.
:	IF NOT SEE IF ANY MORE FRAMES OUT NOT ACKED.  IF SO
:	LET TIMER T1 RUN OUT AND IT WILL BEGIN RETRANSMISSION WITH THIS
:	FRAME (FIRST UNACKED FRAME).  CLEAR RETRANSMISSION COUNTER.
:	NO NEW FRAMES WILL BE TRANSMITTED UNTIL THE TIMER RECOVERY CLEARS.
:
:	IF NO MORE FRAMES ARE OUTSTANDING RESEND LAST FRAME ACKED WITH
:	P BIT ON TRYING TO FORCE A REJ RESPONSE WITH F ON TO CLEAR
:	TIMER RECOVERY.
:
PRRTMR	RBT	RL,OTHBSY		:CLEAR OTHER END BUSY IF SET.
	JAL	R5,ANR			:EVALUATE N(R)
	J	PRER2X			:ERROR RETURN, ISSUE AN FRMR.

PRRT10	LB	R5,RTVS,RL		:GET V(S) OF FRAME BEING RETRANSMITTED
	TBT	R5,VSENT,RFB		:SEE IF THIS FRAME GOT ACKED
  IF	HDLC&LAPB
	JEFS	PRRT20			:IF NOT, CONTINUE IN TIMER RECOVERY
	TBT	RL,CRBIT
	JE	RFG200			:IF NOT A COMMAND FRAME
	J	RFG210			:PRESERVE PFBIT VALUE
  ELSE
	JN	RFG200			:IF NOT, CONTINUE IN TIMER RECOVERY

  EI

PRRT20	LCS	R5,1
	STH	R5,XRETER,RL2		:CLEAR RETRANSMISSION CNTR.
  IF	HDLC&LAPB
	TBT	RL,CRBIT
	JNFS	PRRT25			:IF COMMAND FRAME, DO NOT TEST FOR F-BIT
  EI
	TBT	RL,PFBIT
	JN	PRRT60			:IF FBIT SET TO CLEAR TIMER RECOVERY
PRRT25	LB	R5,LVACK,RL		:GET LAST FRAME ACKED
	AIS	R5,1
	NH	R5,FMMSK
	CLB	R5,XVS,RL		:SEE IF ALL FRAMES OUT WERE ACKED
	JEFS	PRRT30			:IF NONE TO RETRANSMIT LAST FRAME ACKED

:	IF RR ACKED FRAME(S) BUT F BIT WAS NOT SET AND STILL SOME FRAMES
:	OUT, STAY IN TIMER RECOVERY AND LET LOGIC TIMER RUN OUT ON FIRST
:	UNACKED FRAME BEFORE RETRANSMITTING.
:	NOTE-!! THIS MAY BE TOO SLOW A PROCESS AND MAY HAVE TO BE
:	CHANGED SO FRAME GETS RETRANSMITTED IMMEDIATELY.
:	
	LIS	R5,1
	AHM	R5,ILERRD,RL2,		:INCREMENT FACT THIS HAPPENED.
  IF	HDLC&LAPB
	TBT	RL,CRBIT
	JN	RFG210			:COMAND FRAME, PRESERVE PFBIT
  EI
	J	RFG200			:GO CHECK NEXT LINE


:	IF RR ACKED ALL FRAMES SENT BUT F BIT WAS NOT SET, SET UP TO
:	RETRANSMIT LAST FRAME ACKED AS IF IT WAS NOT ACKED.
:
PRRT30	HS
  IF	FINACT
	TBT	RL,SNTRRC
	JN	RFG210			:IF RR COMMAND RECOVERY MODE, LET TRANSMIT
:					:LOGIC HANDLE RETRANSMISSION
  EI	FINACT
	LIS	R5,1
	AHM	R5,ILERRA,RL2,		:INCREMENT FACT THIS HAPPENED

PRRT40	LB	R5,LVACK,RL		:GET LAST FRAME ACKED  NUMBER
	STB	R5,RTVS,RL		:SET UP V(S) OF FRAME BEING RETRANSMITTED
	SBT	R5,VSENT,RFB		:FLAG FRAME AS BEING OUT
	SIS	R5,1
	NH	R5,FMMSK
	STB	R5,LVACK,RL		:SET LAST FRAME ACKED BACK BY ONE
	LB	R5,LSACK,RL		:GET LAST SECTOR ACKED
	SBT	R5,SECBLT,RSG		:SET UP LAST SECTOR ACKED
	SBT	R5,SECSNT,RSG		:FLAG SECTOR AS STILL BEING OUT
	SIS	R5,1
	JGEFS	PRRT50
	LB	R5,K.LT,RL,
	SIS	R5,1
PRRT50	STB	R5,LSACK,RL
	SBT	RL,T1TA.F		:MAKE SURE TIME IS ON
  IF	HDLC&LAPB
	TBT	RL,CRBIT
	JN	RFG210			:COMMAND FRAME, PRESERVE PFBIT
  EI
	J	RFG200			:EXIT AND LOOK AT NEXT LINE.

:	CLEAR TIMER RECOVERY.
PRRT60	LIS	R5,PINFO
	STB	R5,PRIST,RL		:PUT RESPONSE HANDLER BACK IN INFO XSFER
  IF	FINACT
	RBT	RL,SNTRRC		:RESET RR COMMAND INACTIVE CONDITION
  EI	FINACT
	J	PRJI10			:GO START XMISSSION WITH FIRST UNACKED FRAME


:	RESPONSE HANDLER RECEIVED AN RNR RESPONSE WHILE IN TIMER RECOVERY.
:	DO THE SAME THING AS GETTING AN RR BUT IN THIS CASE DO NOT
:	RESET OTHER END BUSY FLAG.

PRNTMR	SBT	RL,OTHBSY		:MAKE SURE BUSY SET
	JAL	R5,ANR			:GO EVALUATE N(R)
	J	PRER2X			:ERROR RETURN

PRNT10	LB	R5,RTVS,RL		:GET V(S) OF FRAME BEING RETRANSMITTED
	TBT	R5,VSENT,RFB
	JE	PRRT20			:IF THIS FRAME WAS ACKED
  IF	HDLC&LAPB
	TBT	RL,CRBIT
	JN	RFG210			:IF RNR COMMAND RECEIVED
  EI
	TBT	RL,PFBIT
	JE	RFG200
	LB	R5,RTCNT,RL
	STH	R5,XRETER,RL2		:RESET RETRANSMISSION COUNT
:	SINCE IN TIMER RECOVERY AND RNR DID NOT ACK FRAME BEING RETRANSMITTED
:	BUT F BIT WAS SET, JUST REINITIALIZING RETRANSMISSION CNTR IS ENOUGH
:	TO PREVENT A RESET FROM BEING SET.
	J	RFG200


:	RESPONSE HANDLER RECEIVED A REJ RESPONSE WHILE IN TIMER RECOVERY.
:	CHECK IF N(R) ACKS FRAME BEING RETRANSMITTED. IF SO
:	CHECK IF F BIT SET.  IF SO THEN CLEAR TIMER RECOVERY.
:	IF F BIT NOT SET SEE IF ANY FRAMES NOT ACKED. IF SO CLEAR
:	SECTOR SENT AND FRAME SENT ARRAYS. USE N(R) OF REJ
:	TO GET A NEW  NEW V(S) AND START RETRANSMITTING THIS FRAME.

PRJTMR	RBT	RL,OTHBSY		:CLEAR OTHER END BUSY FLAG.
	JAL	R5,ANR			:GO CHECK N(R).
	J	PRER2X			:ERROR RETURN IF N(R) INVALID

PRJT10	LB	R5,RTVS,RL		:SEE IF FRAME BEING RETRANSMITTED GOT ACKED
	TBT	R5,VSENT,RFB
	JN	PRJT60			:IF IT WAS NOT
	LCS	R5,1
	STH	R5,XRETER,RL2		:CLEAR RETRANSMISSION CNTR
  IF	HDLC&LAPB
	TBT	RL,CRBIT
	JNFS	PRJT15			:IF A COMMAND FRAME
  EI
	TBT	RL,PFBIT
	JN	PRJT80			:IF F BIT SET, CLEAR TIMER RECOVERY
PRJT15	LB	R5,LVACK,RL
	AIS	R5,1
	NH	R5,FMMSK
	CLB	R5,XVS,RL		:SEE IF ANY MORE FRAMES OUT
	JE	PRJT40			:IF NONE TO RETRANSMIT LAST FRAME ACKED

:	NOW FIRST FRAME NOT ACKED SHOULD EQUAL VALUE OF N(R) IN REJ.
:	SET UP TO RETRANSMIT THIS ONE AND RESET FLAGS ON ANY OTHERS OUT
:	SO THAT THEY WILL BE SENT AGAIN ONCE TIMER RECOVERY CLEARS.
:
	RBT	RL,T1TA.F		:STOP TIMER
	RBT	RL,T1TO.F		:RESET TIMEOUT OCCURRED FLAG
	LIS	R5,0
	LB	R2,SCGBIA+1,RL,
	LR	R3,RSG
PRJT20	STH	R5,SECSNT,R3,
	AIS	R3,2
	CR	R3,R2
	JLBS	PRJT20
	ST	R5,VSENT,RFB
	ST	R5,VSENT+4,RFB
	ST	R5,VSENT+8,RFB
	ST	R5,VSENT+0C,RFB
	LB	R5,LVACK,RL		:GET LAST FRAME ACKED
	AIS	R5,1
	NH	R5,FMMSK
	STB	R5,XVS,RL		:SAVE NEW V(S) VALUE
	STB	R5,RTVS,RL
	SBT	R5,VSENT,RFB		:FLAG FRAME AS BEING OUT

	LB	R5,LSACK,RL		:GET LAST SECTOR ACKED
	AIS	R5,1			:ADD ONE
	CLB	R5,K.LT,RL,
	JLFS	PRJT30
	LIS	R5,0
PRJT30	SBT	R5,SECSNT,RSG		:FLAG SECTOR AS OUT
	SBT	R5,SECBLT,RSG

	L	R5,FASTC,,		:GET PRESENT TIME FROM ISIS
	AH	R5,T1.LT,RL2,		:FORM NEW T1 TIME
	ST	R5,T1CNTR,RL2,RL2	:STORE NEW T1 TIME
	SBT	RL,T1TA.F		:START TIMER UP
	LB	R5,RTCNT,RL		:GET RETRANSMISSION COUNT
	STH	R5,XRETER,RL2		:SAVE NEW RETRANSMISSION CNT
	LIS	R5,1
	AHM	R5,ILERRB,RL2,		:INCREMENT FACT THIS HAPPENED
  IF	HDLC&LAPB
	TBT	RL,CRBIT
	JN	RFG210			:IF COMMAND FRAME, PRESERVE PFBIT
  EI
	J	RFG200			:EXIT AND LOOK AT NEXT LINE


:	REJ ACKED ALL FRAMES OUT BUT SINCE F BIT NOT SET MUST RETRANSMIT
:	LAST FRAME ACKED AND REMAIN IN TIMER RECOVERY.
:	
PRJT40	LIS	R5,1
	AHM	R5,ILERRC,RL2,		:INCREMENT FACT THIS HAPPENED
	J	PRRT40

:	FRAME BEING RETRANSMITTED WAS NOT ACKED BY REJ.
:	INCREMENT A COUNTER AND STAY IN TIMER RECOVERY.
PRJT60	LIS	R5,1
	AHM	R5,ILERRD,RL2,		:INCREMENT COUNTER
  IF	HDLC&LAPB
	TBT	RL,CRBIT
	JN	RFG210			:IF COMMAND FRAME, PRESERVE PFBIT
  EI
	J	RFG200			:EXIT


:	REJ ACKED FRAME BEING RETRANSMITTED AND F BIT WAS SET.
PRJT80	RBT	RL,T1TA.F		:STOP TIMER
	RBT	RL,T1TO.F		:RESET TIMEOUT OCCURRED FLAG
	LIS	R5,PINFO
	STB	R5,PRIST,RL		:SET RESPONSE HANDLER IN INFO XSFER
  IF	FINACT
	RBT	RL,SNTRRC		:RESET RR COMMAND INACTIVE CONDITION
  EI	FINACT
	J	PRJI20			:PROCESS REJECT NOW.

:	RESPONSE HANDLER RECEIVED AN RNR WHILE IN INFO XSFER.  CHECK F BIT TO MAKE
:	SURE NOT SET.
:	USE N(R) TO POSSIBLY ACK FRAMES OUT AND SET OTHER END BUSY FLAG.
:	THIS WILL PREVENT THE RESPONSE HANDLER XMIT LOGIC FROM SENDING ANY NEW
:	FRAMES IF SOME ARE STILL UNACKED.
:	IF ALL ARE ACKED THEN THE RESPONSE HANDLER WILL NOT SEND MORE THEN
:	ONE NEW FRAME.	THE RESPONSE HANDLER XMIT ENTERS A POLLING SITUATION
:	IF TIMER T1 RUNS OUT ON ANY FRAME XMITTED.

PRNINF	TBT	RL,PFBIT		:PBIT
	JN	PRER3			:IF SO TO SEND RESET
	JAL	R5,ANR			:GO LOOK AT N(R)
	J	PRER2X			:IF N(R) INVALID
:	RETURN HERE IF N(R) VALID
	SBT	RL,OTHBSY		:TURN ON BUSY FLAG
	J	RFG200			:EXIT


:	RESPONSE HANDLER RECEIVED A REJ WHILE IN INFO XSFER.
:	CHECK F BIT TO MAKE SURE NOT SET.
:	CLEAR BUSY FLAG IF SET.  USE N(R) TO ACK ANY FRAMES OUT AND STOP
:	TIMER. BEGIN TRANSMISSION WITH FRAME RQUESTED IN REJ IF AVAILABLE.
:	SET UP SECTOR SENT AND FRAME SENT FLAGS AS IF NO FRAMES ARE
:	OUT, AND BEGIN TRANSMISSION WITH FIRST UNACKED FRAME. SET THE VALUE
:	OF V(S) TO THE N(R) RECEIVED IN REJ.

PRJINF	LIS	R0,1
	AHM	R0,REJRCV,RL2,
  IF	XOM
	AHM	R0,LKS.6,RL2,		:SAVE  XOM FOR LINK STATISTICS
  EI
	TBT	RL,PFBIT
	JN	PRER3			:IF SO TO SEND RESET, ERROR
	JAL	R5,ANR			:GO EVALUATE N(R)
	J	PRER2X			:ERROR RETURN IF N(R) INVALID
	RBT	RL,OTHBSY		:CLEAR OTHER END BUSY FLAG
PRJI10	RBT	RL,T1TA.F		:STOP TIMER IF RUNNING
	RBT	RL,T1TO.F		:RESET TIMEOUT OCCURRED FLAG
PRJI20	LIS	R5,0
	LB	R2,SCGBIA+1,RL,
	LR	R3,RSG
PRJI30	STH	R5,SECSNT,R3,
	AIS	R3,2
	CR	R3,R2
	JLBS	PRJI30
	ST	R5,VSENT,RFB
	ST	R5,VSENT+4,RFB
	ST	R5,VSENT+8,RFB
	ST	R5,VSENT+0C,RFB

	LB	R5,LVACK,RL		:GET LAST FRAME ACKED
	AIS	R5,1
	NH	R5,FMMSK
	STB	R5,XVS,RL
	LB	R5,LSACK,RL
	AIS	R5,1
	CLB	R5,K.LT,RL,
	JLFS	PRJI40
	LIS	R5,0
PRJI40	STB	R5,NXTSEC,RL		:SAVE NEXT SECTOR TO SEND
:	NOW THE RESPONSE HANDLER XMIT LOGIC WILL BEGIN XMITTING WITH THE FRAME
:	ASKED FOR BY THE REJ.
  IF	HDLC&LAPB
	TBT	RL,CRBIT
	JN	RFG210			:IF COMMAND FRAME, PRESERVE PFBIT
  EI
	J	RFG200			:EXIT


:	RESPONSE HANDLER RECEIVED AN RR RESPONSE WHILE IN INFO XSFER.
:	CHECK F BIT AND IF SET ISSUE A RESET.
:	CHECK N(R) TO POSSIBLY ACK FRAMES OUT AND CLEAR OTHER
:	END BUSY STATUS IF SET.
PRRINF	TBT	RL,PFBIT
	JN	PRER3			:IF SO TO SEND RESET

	JAL	R5,ANR			:GO EVALUATE N(R)
	J	PRER2X			:ERROR RETURN

	RBT	RL,OTHBSY		:CLEAR BUSY IF SET
	J	RFG200			:EXIT


:	RECEIVED A RR,RNR OR REJ FRAME SENT TO RESPONSE ADDRESS WITH
:	A F BIT SET AND NOT IN TIMER RECOVERY. SEND A RESET.
:	NOTE-X.75 AS OF MAY,1978 HAS THIS LEFT FOR FURTHER STUDY.
PRER3	LIS	R5,1
	AHM	R5,ILERR9,RL2,		:COUNT ERROR
	OOPS
	J	SNDSAM			:GO SEND RESET


  IF	LAPB
:	HAVE RECEIVED A UA FOR AN SABM THAT WE HAVE SENT.
:	PUT INTERFACE BACK INTO INFORMATION TRANSFER AND DO PROPER
:	CLEANUP AND SET ALL STATE VARIABLES BACK TO ZERO.
:
PUARST	RBT	RL,PFBIT
	JE	RFG200			:IGNOR FRAME IF NOT
	J	SSBI10			:TO DO CLEANUP

:------------------------------------------------------
:	DISCONNECT STATE.
:------------------------------------------------------
:
:LAPB:	UA	GO TO NOT ARMED STATE
:	DM	GO TO NOT ARMED STATE
:	(OTHERS ARE IGNORED)
:
:LAP:	UA	IF SECONDARY STATION DISCONNEDTED GO TO NOT ARMED STATE
:		 ELSE GO TO WAITING FOR SECONDARY TO DISCONNECT STATE
:------------------------------------------------------



:	RECEIVED A UA TO A DISC THAT WE HAVE SENT. STOP TIMER ON DISC
:	AND PUT INNTERFACE IN NOT ARMED STATE. (DM RESPONSE TO DISC
:	IS ALSO HANDLED THIS WAY.)
PDMDSC	HS			:DM
PUADSC	HS			:UA
	RBT	RL,PFBIT
	JE	RFG200			:IGNOR IF NOT SET
	RBT	RL,T1TA.F		:STOP TIMER ON DISC
	RBT	RL,T1TO.F		:RESET TIMEOUT OCURRED FLAG
	LIS	R5,PNARM
	STB	R5,PRIST,RL		:PUT RESPONSE HANDLER IN NOT ARMED STATE
	J	RFG200			:EXIT AND LOOK AT NEXT LINE
  ELSE	LAP
:	PRIMARY STATION RECV A UA WHILE IN RESET STATE. THIS IS THE
:	EXPECTED RESPONSE.  PUT PRIMARY STATION BACK INTO INFO XSFER.
:	SET V(S) EQUAL TO ZERO AND CLEAR SECTOR SENT AND FRAME SENT ARRAYS
:	SO INFO XSFER PICKS UP SENDING ALL FRAMES THAT WERE OUT OVER AGAIN.
:	ALSO SET LVACK (LAST FRAME ACKED) TO 7 AS IS DONE IN INITIALZE LOGIC.
:	LSACK DOES NOT GET CHANGED.
:
PUARST	RBT	RL,T1TA.F		:TURN TIMER OFF ON SARM
	RBT	RL,T1TO.F		:RESET TIMEOUT OCCURRED FLAG
	RBT	RL,PFBIT
	LIS	R5,0
	STB	R5,XVS,RL		:SET V(S) TO ZERO
	LB	R2,SCGBIA+1,RL,
	LR	R3,RSG
PUAR10	STH	R5,SECSNT,R3,		:CLEAR SECTOR SENT ARRAY
	AIS	R3,2
	CR	R3,R2
	JLBS	PUAR10
	ST	R5,VSENT,RFB
	ST	R5,VSENT+4,RFB
	ST	R5,VSENT+8,RFB
	ST	R5,VSENT+0C,RFB
	LH	R5,FMMSK
	STB	R5,LVACK,RL		:INITIALIZE LAST FRAME ACKED CELL
	LB	R5,LSACK,RL		:GET LAST SECTOR ACKED
	AIS	R5,1
	CLB	R5,K.LT,RL,
	JLFS	PUAR20
	LIS	R5,0
PUAR20	STB	R5,NXTSEC,RL		:UPDATE NEXT SECTOR TO SEND CELL
	RBT	RL,OTHBSY		:CLEAR OTHER END BUSY FLAG
	LIS	R5,PINFO
	STB	R5,PRIST,RL		:PUT PRIMARY STATION BACK INTO INFO XSFER
	J	RFG200			:EXIT AND LOOK AT NEXT LINE

PDMDSC	EQ	LPBKER		:THIS IS A SARM IN LAP


:	PRIMARY STATION RECV A UA WHILE IT HAS A DISC OUT AND IS IN DISCONNECT STATE.
:	CHECK IF SECONDARY STATION IS ARMED AND IF SO PLACE SECONDARY STATION IN DISCONNECT
:	STATE AND PRIMARY STATION IN WAITING FOR SECONDARY STATION TO DISCONNECT STATE.
:	IF SECONDARY STATION WAS NOT ARMED CHECK IF IT WAS TRYING TO ARM. IF SO
:	PUT PRIMARY STATION IN WAITING FOR SECONDARY STATION TO DISCONNECT STATE.
:
PUADSC	RBT	RL,T1TA.F		:STOP TIMER ON DISC
	RBT	RL,T1TO.F		:RESET TIMEOUT OCURRED FLAG
	RBT	RL,PFBIT
  IF	XOM
	TBT	RL,XOMLDS		:IF XOM WANTS IT DOWN, LEAVE DOWN
	JN	RFG200
  EI
	TBT	RL,DWD.F
	JEFS	PUAD05			:IF PRIMARY STATION WAITS FOR SECONDARY STATION
	RBT	RL,SARMED
	RBT	RL,STARM
	JFS	PUAD10

PUAD05	TBT	RL,SARMED		:SEE IF SECONDARY STATION ARMED
	JN	PUAD20			:IF SO
	TBT	RL,STARM		:SEE IF SECONDARY STATION WAS TRYING TO ARM
	JN	PUAD20			:IF SO
PUAD10	:RBT	RL,PARMED		:RESET PRIMARY STATION ARMED FLAG
	LIS	R5,PNARM
	STB	R5,PRIST,RL		:PUT PRIMARY STATION IN NOT ARMED STATE
	LIS	R5,SECADM
	STB	R5,SECST,RL		:PUT SECONDARY STATION IN NOT ARMED STATE
	J	RFG200
:	NOW BACKGROUND LOGIC WILL HAVE TO REINITIALIZE LINK SET UP.

PUAD20	LIS	R5,PWDISC
	STB	R5,PRIST,RL		:PUT PRIMARY STATION IN WAITING FOR SECONDARY STATION TO DISCONNECT
	LIS	R5,SECDSC
	STB	R5,SECST,RL		:PUT SECONDARY STATION IN DISCONNECT STATE
	L	R5,FASTC,,
	AH	R5,T1.LT,RL2,
	ST	R5,T1CNTR,RL2,RL2	:STORE NEW T1 TIME
	SBT	RL,T1TA.F		:TURN TIMER ON
	LB	R5,RTCNT,RL		:GET COMPLEMENT OF RETRANSMISSION COUNT
	STH	R5,XRETER,RL2		:SAVE IT
	J	RFG200			:EXIT
  EI	LAP


:------------------------------------------------------
::	RECEIVE FRAME ERROR ROUTINES
:------------------------------------------------------



:	FRAME RECEIVED FOR COMMAND HANDLER OTHER THEN AN I-FRAME WITH AN
:	INFO FIELD, ERRROR.
RFER10	LIS	R5,1
	AHM	R5,RERR3,RL2,
   IF	LAPB
RFER12	LB	R5,PRIST,RL
	CLHI	R5,PRFRMR
	JE	SFRFMR			:GO SEND FRMR AGAIN
	CLHI	R5,PINFO
	JEFS	RFER14			:IF IN XFER
	CLHI	R5,PTRECV		:IF IN TIMER RECOVERY
	JEFS	RFER14
	J	RFG200			:IGNOR IT

RFER14	:LIS	R0,FRMR.W+FRMR.X	:SET W AND X BIT
:	JAL	R6,SENDFR		:QUEUE UP A FRAME REJECT
:	J	RFG200			:GO CHECK NEXT LINE
	J	SNFMRX			:SEND W AND X FRAME REJECT :DRE 8-MAY-86
   ELSE	LAP
	J	RFG200
   EI


:	FRAME RECEIVED WITH AN UNKNOWN ADDRESS
RFER20	FTRACE(,FE.ERR)			:TRACE INPUT FRAME	:DRE 11-MAR-86
	LIS	R5,1
	AHM	R5,RERR4,RL2,
	J	RFG200

:	FRMR RECEIVED WITH INCORRECT BYTE COUNT.
RFER30	FTRACE(,FE.ERR)			:TRACE INPUT FRAME	:DRE 11-MAR-86
	LIS	R5,1
	AHM	R5,RERR7,RL2,
  IF	LAPB
	J	SNFMRX						:HJR 11-06-86
  ELSE	LAP
	J	RFG200
  EI


:	RESPONSE FRAME RECEIVED ON RESPONSE HANDLER HAD WRONG BYTE COUNT,
:	OTHER THEN AN FRMR
RFER40	FTRACE(,FE.ERR)			:TRACE INPUT FRAME	:DRE 11-MAR-86
	LIS	R5,1
	AHM	R5,RERR8,RL2,
  IF	LAP
	J	RFG200
  ELSE	LAPB
	J	SNFMRX			:SEND XW FRAME REJECT	:HJR 11-06-86
  EI	LAPB

  EI	LAPB!LAP
	STTL(FOREGROUND LOGIC - BYSINC		)
	SSTTL(RECEIVE FRAME)

  IF	LAP&BSC		:IF LAP AND BYSINC




:	RECLAIM ANY RECEIVE SECTORS RTD IS DONE WITH.
:	IF THERE IS A LINKED CHAIN OF RECEIVE SECTORS WHICH
:	HAVE BEEN PROCESSED BY BACKGROUND AND ARE READY TO BE RETURNED
:	TO THE AVAILABLE POOL, THEY ARE RELINKED AT THE BACK END
:	OF THE AVAIL CHAIN SINCE THE FIRST AVAILABLE RECEIVE
:	SECTOR MAY BE PARTIALLY FILLED WITH AN INCOMING FRAME,
:	BUT WILL NOT BE DELINKED UNTIL IT IS ACCEPTED.
:
:
RFGND	LCS	R0,1
RFG000	L	R1,RTD.FG		:RE-AVAILABLE RECEIVE SECTOR FLAGS
	JFFO	R1,RFG001		:GET (R2)=LINE #
	J	RFG004			:NO MORE
RFG001	RBT	R2,RTD.FG		:NOTHING FOR RTD TO DO NOW ON THIS LINE
	LB	R3,RSC.SZ,R2,		:GET RELATIVE BUFFER SIZE (0,1,2,3)
	SLLS	R3,1
	LH	R4,RSC.RT,R2,R2		:HEAD PTR OF RETURNING CHAIN
	LH	R5,RSC.AE,R3		:GET END OF AVAIL CHAIN THIS SIZE
	JGEFS	RFG002			:IT IS NOT EMPTY
	STH	R4,RSC.AV,R3		:SINCE IT WAS EMPTY
	JFS	RFG007
RFG002	A	R5,RSC.BF,R3,R3		:FIND ABS END OF AVAIL CHAIN
	STH	R4,,R5			:IT POINTS TO START OF RETURNING CHAIN
RFG007	LH	R4,RSC.RE,R2,R2		:END OF RETURNING CHAIN IS NOW
	STH	R4,RSC.AE,R3		:END OF AVAIL CHAIN
	STH	R0,RSC.RT,R2,R2		:CLEAR BKG CHAIN PTRS
	STH	R0,RSC.RE,R2,R2
	STH	R0,RSC.RA,R2,R2
	J	RFG000			:GO TO NEXT LINE

RFG004	LHI	RL2,NLINE*2		:GET TWICE THE NUMBER OF X25 LINES
	LHI	RBA,NLINE*(BNTLN+2)+2	:GET LINE INDEX INTO RECV. BUFFER
	JFS	RFG010
RFG005	STH	RTP,YTP,RL2		:SAVE TRAILING POINTER
RFG010	SHI	RBA,BNTLN+2
	SIS	RL2,2			:MOVE TO NEXT LINE
	JL	FGEXEC			:ALL DONE!		:DRE 30-DEC-86
	LR	RL,RL2
	SRLS	RL,1
	LIS	R0,7			:FORM DEFAULT MODULUS	:DRE 7-OCT-87
	TBT	RL,F128.F					:DRE 7-OCT-87
	JEFS	RFG015			:IF NOT MOD128		:DRE 7-OCT-87
	LHI	R0,7F						:DRE 7-OCT-87
RFG015	STH	R0,FMMSK		:SAVE FRAME LEVEL MOD MASK :DRE 7-OCT-87
	LR	RFB,RL
	SLLS	RFB,4
	LB	RSG,SCGBIA,RL,
	LHL	RLP,RBUF-2,RBA,		:GET LEAD POINTER INDEX FROM FIRST HLF WRD
:	OF BUFFER
	LHL	RTP,YTP,RL2		:GET TRAILING POINTER
	LH	R0,RSC.RT,RL2		:SEE IF RTD CAUGHT UP ON THIS LINE
	JGE	RFG020			:NO
	LH	R0,RSC.FG,RL2		:ANYTHING TO GIVE IT ??
	JL	RFG020			:NO
	STH	R0,RSC.RT,RL2		:MOVE CHAIN PTRS FG TO RTD
	STH	R0,RSC.RA,RL2		:INITIALIZE STARTING POINTER
	LH	R0,RSC.FE,RL2
	STH	R0,RSC.RE,RL2
	LCS	R0,1
	STH	R0,RSC.FG,RL2		:CLEAR FG CHAIN PTRS
	STH	R0,RSC.FE,RL2		:  HEAD AND TAIL
	SBT	RL,FG.RTD		:TELL RTD TO GET TO WORK
RFG020	CLR	RTP,RLP			:SEE IF ANY DATA TO PROCESS
	JE	TFGND			:NO, GO CHECK TRANSMITTER :DRE 30-DEC-86
	L	R5,XYSUB,RL2,RL2	:GET SUBROUTINE ADDRESS
	JR	R5			:GO TO IT



:
:	SUBROUTINE TO GET INTO SYNC ON X25 LINE
:	FIRST DO CHECK ON BUSY STATUS.
:
XSYNC	LB	R5,SECST,RL		:GET SECONDARY STATION FUNCTION STATE
	CLHI	R5,SECINF		:SEE IF SECONDARY STATION IN INFO XSFER
	JN	RFG100			:IF NOT

:	NOW CHECK TO SEE IF SECONDARY STATION WAS LEFT BUSY. IF SO SEE IF
:	ENOUGH BUFFER SPACE HAS OPENED UP TO CLEAR BUSY CONDITION.

	TBT	RL,XSBUSY		:SEE IF BUSY FLAG SET
	JE	RFG100			:IF NOT
	LB	R3,RSC.SZ,RL,		:BUFFER SIZE INDEX
	LH	R3,RSC.AV,R3,R3		:AVAILABLE PTR
	JGEFS	RFG040			:SOME LEFT IN AVAIL POOL
	LH	R0,RSC.FD,RL2		:SEE IF LAST AVAILABLE SECTOR LEFT DANGLING
	JGEFS	RFG040			:IF EXACTLY ONE MORE TO USE
	SBT	RL,NOSTOR		:PREVENT DATA FROM BEING STORED IN RTD RING
	J	RFG100

:	ROOM IN RING, CLEAR BUSY
RFG040	RBT	RL,NOSTOR		:CLEAR NOSTORE FLAG
	RBT	RL,XSBUSY		:CLEAR BUSY
	RBT	RL,DSCARD		:CLEAR DATA DISCARDED FLAG
	JE	RFG050			:IF DISCARD FLAG NOT SET

:	IF DISCARD FLAG SET QUEUE UP A REJ RESPONSE TO CLEAR BUSY
	LIS	R2,XMSREJ		:GET SEND REJ INDEX
	STB	R2,XSSTAT,RL
	SBT	RL,SNTREJ		:SET SENT REJECT FLAG
	LIS	R3,1
	AHM	R3,REJDSC,RL2,
  IF	XOM
	AHM	R3,LKS.5,RL2,		:SAVE FOR XOM LINK STATISTICS
  EI
	J	RFG100

:	IF DISCARD FLAG NOT SET, QUEUE UP AN RR RESPONSE
RFG050	LIS	R2,XMSRRM		:QUEUE UP A MANDATORY RR RESPONSE
	STB	R2,XSSTAT,RL


:	NOW GET INTO SYNC ON X25 LINE BY LOOKING FOR SYNC CHARS.
RFG100	JAL	R5,FNDSYN		:GO SEARCH FOR SYNC CHARS
	J	TFGND			:RETURN HERE IF NO SYNC CHARS FOUND :DRE 30-DEC-86
	LIS	R5,0
	STH	R5,IBCRCT,RL2		:ZERO OUT CHECKSUM CELL

RFG110	JAL	R5,BVCHAR		:GET CHAR FROM ISIS RING
	J	XSYEXI			:RETURN HERE IF NO MORE DATA IN RING
	CLHI	R2,SYN			:SEE IF A SYNC CHAR
	JEBS	RFG110			:IF SO

	CLHI	R2,DLE			:SEE IF A DLE
	JN	XSYER1			:IF NOT A DLE THEN ERROR
RFG130	JAL	R5,BVCHAR		:GET NEXT CHAR, SHOULD BE AN STX
	J	XSYEXI
	CLHI	R2,SYN
	JE	RFG110
	CLHI	R2,STX
	JN	XSYER2			:IF NOT AN STX, ERROR

:	NOW HAVE SYN CHARS AND DLE/STX, PROCESS FRAME
RFG140	JAL	R5,BVCHAR		:GET ADDRESS BYTE
	J	XSYEXI
	CLHI	R2,DLE			:SEE IF A DLE
	JNFS	RFG150
	JAL	R5,BVCHAR		:GET NEXT BYTE
	J	XSYEXI
	CLHI	R2,DLE			:THIS SHOULD BE A DLE
	JEFS	RFG150			:IF SO
	CLHI	R2,SYN
	JE	RFG140
	J	RFER10			:MISSING SECOND DLE AFTER FIRST, ERROR.

:	NOW HAVE THE ADDRESS BYTE
RFG150	JAL	R5,ICHKSM		:CHECKSUM ADDRESS
	STB	R0,RECVCM,RL		:STORE IN HERE FOR NOW
RFG160	JAL	R5,BVCHAR		:GO GET CONTROL FIELD BYTE
	J	XSYEXI

	CLHI	R2,DLE			:SEE IF A DLE
	JNFS	RFG180			:IF NOT
	JAL	R5,BVCHAR
	J	XSYEXI

	CLHI	R2,DLE			:THIS SHOULD BE A DLE
	JEFS	RFG180			:IF SO
	CLHI	R2,SYN
	JE	RFG160
	J	RFER10			:MISSING SECOND DLE, ERROR.

RFG180	JAL	R5,ICHKSM		:CHECKSUM CHAR
  IF	FINACT
	SBT	RL,FRMRCV		:INDICATE FRAME RECEIVED
  EI

:	NOW HAVE CONTROL FIELD. DECIDE WHAT ACTION TO BE TAKEN BASED
:	ON WHETHER THE FRAME IS AN I-FRAME OR SOME OTHER COMMAND.

	LB	R12,RECVCM,RL		:GET ADDRESS
	STB	R0,RECVCM,RL		:SAVE CONTROL FIELD.
	RBT	RL,PFBIT
	LHI	R1,CT.1PF
	NR	R1,R0
	JEFS	RFG190			:IF P/F IT NOT SET
	SBT	RL,PFBIT
RFG190	LB	R5,PADRT,RL,
	CR	R12,R5			:CHECK IF RESPONSE ADDRESS.
:	(IE. SECONDARY STATION AT OTHER END HAS SENT A RESPONSE)
	JE	XPRES			:IF SO
	LB	R5,SADRT,RL,
	CR	R12,R5			:SEE IF SECONDARY STATION ADDRESS
	JN	RFER20			:NOT CORRECT ADDRESS, ERROR.
	LB	R0,RECVCM,RL
	THI	R0,CT.NIF		:CHECK IF I-FRAME
	JE	IFRAME			:IF I-FRAME

:	HAVE A COMMAND FOR SECONDARY STATION FUNCTION. CHECKSUM REST OF FRAME
:	BEFORE PROCESSING COMMAND.
:	NOTE: COMMANDS FOR SECONDARY STATION FUNCTION (OTHER THEN I-FRAMES) DO
:	NOT CONTAIN AN INFORMATION FIELD, THEREFORE EXPECT END FLAGS
:	(DLE/ETX) TO FOLLOW NOW.

RFG195	JAL	R5,BVCHAR		:GET NEXT BYTE, SHOULD BE A DLE
	J	XSYEXI
	CLHI	R2,DLE			:SEE IF A DLE
	JN	XSYER5			:IF NOT, ERROR.

:	NOTE- DLE BEFORE ETX IS NOT CHECKSUMMED.
	JAL	R5,BVCHAR		:GET NEXT CHAR, SHOULD BE AN ETX
	J	XSYEXI
	CLHI	R2,SYN
	JE	RFG195
	CLHI	R2,ETX			:IS IT.
	JN	RFER10			:NOT CORRECT,  ERROR.
:	NOTE-ETX IS CHECKSUMMED.
	JAL	R5,ICHKSM
	JAL	R6,CKFNAL		:GO FINISH CHECKSUM

:	RETURN BACK HERE IF GOOD CHECKSUM.

	FTRACE(SADRT)			:INPUT FRAME TRACE
	LB	R5,RECVCM,RL		:GET CONTROL FIELD BACK
	NHI	R5,CT.TM		:MASK OFF P/F BIT
	SRLS	R5,1			:DIVIDE BY 2
	LB	R5,CMDTBL,R5		:GET ENTRY FROM COMMAND TABLE INDEXED BY COMMAND
	LB	R2,SECST,RL
	AH	R5,SECSIX,R2,R2
	LHL	R2,SECDEC,R5
	J	SECDEC,R2


::	RETURN TO HERE.

RFG200	RBT	RL,PFBIT
RFG210	LA	R5,XSYNC
	ST	R5,XYSUB,RL2,RL2	:SET UP SUBROUTINE TO START LOOKING FOR SYNCS
RQPOP	LCS	R2,1
	STB	R2,BVLSDT,RL		:SET LAST DATA BYTE TO FF FOR NEX SYNC DETECT
	J	RFG005

RQPOP1	LCS	R2,1
	STB	R2,BVLSDT,RL
	J	XSYNC


:	ROUTINE USED IF WHEN GETTING CHARS FROM ISIS RING THE ROUTINE
:	CATCHES UP TO ISIS POINTER, IE. NO MORE DATA YET.
XSYEXI	SIS	R5,04
	ST	R5,XYSUB,RL2,RL2	:SET SUBROUTINE ADDRESS BACK FOR NEXT TIME
	J	RFG005			:GO LOOK AT NEXT LINE



:	ERROR ROUTINES
:	----------------
:	ERROR IF AFTER DETECTING SYNC CHARS A CHAR OTHER THAN A DLE IS RECEIVED
XSYER1	LIS	R5,1
	AHM	R5,RERR1,RL2,		:INCREMENT ERROR CELL
  IF	XOM
	AHM	R5,LKS.14,RL2,		:SAVE FOR LINK STATISTICS
  EI
	OOPS(2)
	J	RFG200			:EXIT

:	ERROR IF STX MISSING AFTER INITIAL DLE CHAR
XSYER2	LIS	R5,1
	AHM	R5,RERR2,RL2,		:INCREMENT ERROR
	OOPS(2)
	J	RFG200			:EXIT

:	ERROR IF A CHAR AFTER A DLE WAS NOT A DLE, STX OR ETX
RFER10	CLHI	R2,EOT			:FIRST SEE IF A EOT
	JEFS	XSYABT			:IF SO
	LIS	R5,1
	AHM	R5,RERR3,RL2,		:NOT PROPER CHAR AFTER A DLE
	OOPS(2)
	J	RFG200

:	A DLE/EOT IS A FRAME ABORTION SEQUENCE
XSYABT	LIS	R5,1
	AHM	R5,RERR0,RL2,		:INCREMENT ERROR CELL
  IF	XOM
	AHM	R5,LKS.13,RL2,		:SAVE FOR LINK STATISTICS
  EI
	OOPS
	J	RFG200

:	ERROR IF A FRAME HAS AN INCORRECT ADDRESS BYTE
RFER20	FTRACE(,FE.ERR)			:TRACE INPUT FRAME	:DRE 11-MAR-86
	LIS	R5,1
	AHM	R5,RERR4,RL2,		:INCREMENT ERROR
	OOPS
	J	RFG200

:	ERROR IF A FRAME IS MISSING AN END FLAG
XSYER5	LIS	R5,1
	AHM	R5,RERR5,RL2,
	OOPS(2)
	FTRACE(,FE.FME)			:TRACE FRAME(ADDRESS UNKNOWN)
	J	RFG200

:	ERROR ROUTINE IF CHECKSUM WRONG
XSYER6	LIS	R5,1
	AHM	R5,RERR6,RL2,
  IF	XOM
	AHM	R5,LKS.3,RL2,		:SAVE FOR XOM LINK STATISTICS
  EI
	FTRACE(,FE.CKS)			:TRACE FRAME (CHECKSUM ERROR)
	OOPS(2)
	J	RFG200

:	ERROR IF AN I-FRAME IS RECEIVED WITH A WRONG ADDRESS
RFER30	FTRACE(,FE.ERR)			:TRACE INPUT FRAME	:DRE 11-MAR-86
	LIS	R5,1
	AHM	R5,RERR7,RL2,
	OOPS
	J	RFG200

  EI	LAP&BSC

	STTL(TRANSMIT ROUTINES                 )
 	SSTTL(BACKGROUND REQUESTS)

:FOREGROUND TRANSMIT LOGIC FOR BOTH RESPONSE AND COMMAND FUNCTIONS.
:	-------------------------------------------------------------
:
:
:


  IF	LAPB!LAP
TFGND	:LHI	RL2,NLINE*2		:GET TWICE NUMBER OF LINES :DRE 30-DEC-86
	:LHI	RL,NLINE
TFG010	:SIS	RL2,2			:MOVE TO NEXT LINE
	:JL	FGEXEC			:EXIT IF ALL LINES SERVICED
	:SIS	RL,1

  IF	HDLC
	L	RSIO,SIOTBL,RL2,RL2	:GET SIOTABLE BASE ADDRESS FOR LINE
	LB	R1,SI.INT,RSIO,		:GET INTERRUPT BYTE		ERB-041286
	JE	TFGX11			:IF NO INTERRUPT		ERB-041286
	SRHLS	R1,4			:INTERRUPT CAUSE		ERB-041286
	CLHI	R1,6			:				ERB-041286
	JEFS	TFG011			:IF OVER-RUN			ERB-041286
	TRAP(R1,E0)			:UNRECOVERABLE SIO INTERRUPT	ERB-041286
TFG011	LIS	R1,0			:				ERB-041286
	STB	R1,SI.INT,RSIO,		:				ERB-041286
	LIS	R1,1			:				ERB-041286
	AHM	R1,SIOER2,RL2,		:				ERB-041286
  IF	XOM				:				ERB-041286
	AHM	R1,LKS.12,RL,RL		:SAVE FOR XOM LINK STATISTICS LSH 16-APR-87
  EI					:				ERB-041286
	JAL	R13,INISIO,,		:RE-INITIALIZE SIO FOR LINE *RL*ERB-041286
TFGX11	L	RSIO,SIOTBL,RL2,RL2	:GET SIOTABLE BASE ADDRESS FOR LINE
  EI
  IF	BSC			:IF BYSINC FRAMING
	RBT	RL,SVCFLG
  EI

  IF	XOM
:	CHECK FOR BACKGROUND REQUESTS. AT PRESENT ONLY THE XOM MAY REQUEST
:	 ANYTHING BUT "SEND A RESET"
:	ASSUMPTION THAT BACKGROUND DOESN'T INTERRUPT FOREGROUND MUST HOLD
:	 IF RACE CONDITION ON BPSTAT FLAG IS TO BE AVOIDED
	LB	R2,BPSTAT,RL
	JE	TFG012			:BACKGROUND DOESN'T WANT ANYTHING
	LIS	R0,0
	STB	R0,BPSTAT,RL		:RESET SEMAPHORE (HOPE BKGND DOESN'T INTR!)
	CLHI	R2,L.BPST
	JG	BSEXOM,,
	LHL	R1,BPSTAB,R2,R2		:LOOKUP PROCESSOR IN JUMP TABLE
	J	BPSTAB,R1



 TABLE(BPSTAB)
	TENTRY(TFG012)		:   NO STATE CHANGE REQ. BY BKGND
	TENTRY(TFG1XX)		:   RESET LINK
	TENTRY(TFG2XX)		:   BRING DISC LINK UP
	TENTRY(TFG3XX)		:   BRING MARKING LINK UP
	TENTRY(TFG4XX)		:   PUT LINK IN DISC STATE
	TENTRY(TFG5XX)		:   PUT LINK IN MARKING STATE
	TENTRY(TFG6XX)		:   PUT MARKING LINK IN DISC STATE
 ENDTABLE(BPSTAB)		:DEFINE L.BPST

:	Send a reset
TFG1XX	LIS	R2,XMPSAM		:SABM
	STB	R2,XPSTAT,RL		:INDICATE MUST SEND RESET
	LIS	R2,PRESET
	STB	R2,PRIST,RL		:RESET STATE
	J	TFG030

:	Bring marking link up
TFG3XX	RBT	RL,XOMLDH		:INDICATE XOM WANTS IT NOT DOWN
  IF	BSC
	LA	R8,CROTOR,,
	LIS	R3,4			:TURN ON RTS COMMAND
	STH	R3,,R8
	LIS	R3,9			:TURN ON DTR COMMAND
	STH	R3,8,R8
	LIS	R3,0			:STOP LIST PROCESSING & OUTPUT MARKS
	STH	R3,10,R8
	LB	R7,SLU.LT,RL,
	SVC	IO,(FSYNO.^4)+R7
	J	RFG010			:ERROR RETURN		:DRE 30-DEC-86
  EI
:	Bring DISC link up
TFG2XX	LIS	R0,PNARM
	STB	R0,PRIST,RL		:ENTER UNARMED STATE
	RBT	RL,XOMLDS		:INDICATE XOM WANTS LINK UP
	RBT	RL,BCKFLG		:LET BCKGND BRING UP LINK
	RBT	RL,REINIT
	J	RFG010						:DRE 30-DEC-86

:	BRING DOWN SOFT (DISCONNECT STATE)
TFG4XX	JAL	R5,XROOM		:SEE IF SPACE FOR OUTPUT
  IF	HDLC
	J	TFG4XY			:IF NO ROOM, CHECK AGAIN NEXT FG LOOP
  EI
	SBT	RL,XOMLDS		:INDICATE XOM WANTS LINK DOWN
	LB	R5,PADRT,RL,		:SET UP COMMAND ADDRESS
	J	SNDDSC			:SEND A DISC

TFG4XY	LIS	R5,4			:DISCONNECT INDICATOR...
	STB	R5,BPSTAT,RL		: FOR NEXT FG LOOP
	J	TFG100

:	BRING DOWN HARD (MARKING STATE)
TFG5XX	SBT	RL,XOMLDH		:INDICATE XOM WANTS IT DOWN
	LIS	R0,PNARM		:PLACE IN NOT ARMED STATE
	STB	R0,PRIST,RL
  IF	LAP
	LIS	R0,SECADM
	STB	R0,SECST,RL
  EI
	LIS	R0,0
	STB	R0,XSSTAT,RL		:CLEAR TRANSMIT QUEUES
	STB	R0,XPSTAT,RL
	LB	R0,SLU.LT,RL,
  IF	HDLC
	TS	SIOACT			:IS SIO ACTIVE			ERB-041286
	JEFS	TFG5XZ			:NO				ERB-041286
	LIS	R5,5			:MARKING INDICATOR...		ERB-041286
	STB	R5,BPSTAT,RL,		:  FOR NEXT FG LOOP		ERB-041286
	J	TFG100

TFG5XY	LIS	R5,0			:INDICATE SIO NOT ACTIVE	ERB-041286
	STH	R5,SIOACT		:				ERB-041286
	J	RFG010			:				ERB-041286:DRE 30-DEC-86

TFG5XZ	LR	R1,RSIO			:COMMAND TABLE BASE ADR FOR LINK
	AHI	R1,MICCW		:COMMAND TO SEND MARKS
	SVC	IO,(FMBOT.^4)+R0
	J	TFG5XY			:ERROR RETURN			ERB-041286
:	SHI	R1,MICCW					:DRE 16-JAN-87
:	AHI	R1,DICCW		:TURN RTS/DTR OFF
:	SVC	IO,(FMBOT.^4)+R0
:	J	TFG5XY			:ERROR RETURN			ERB-041286
	LIS	R5,0			:INDICATE SIO NOT ACTIVE	ERB-041286
	STH	R5,SIOACT		:				ERB-041286
  ELSE	BSC
	LA	R1,CROTOR,,		:ADR OF OUTPUT DESCRIPTOR FOR CONTROL
	LIS	R2,3			:TURN OFF RTS COMMAND
	STH	R2,,R1
	LIS	R2,8			:TURN OFF DTR COMMAND
	STH	R2,8,R1
	LIS	R2,0			:STOP OUTPUT & SEND MARKS COMMAND
	STH	R2,10,R1
	SVC	IO,(FSYNO.^4)+R0	:FORCE CMD LIST EXECUTION
	J	RFG010			:ERROR RETURN		:DRE 30-DEC-86
  EI
	RBT	RL,LINKUP		:INDICATE LINK LEVEL DOWN
	JEFS	TFG5X0			:IF LINK ALREADY DOWN	:DRE 7-APR-86
	SBT	RL,HANGEM		: ELSE TELL BKGND TO HANG USERS :DRE 7-APR-86
TFG5X0	RBT	RL,PACKUP		:INDICATE PACKET LEVEL DOWN :DRE 7-APR-86
	RBT	RL,BCKFLG		:KEEP THINGS FROM HAPPENING UNTIL BG HAS FINISHED:DRE 7-APR-86
	RBT	RL,REINIT		:MAKE LINK MANAGEMENT RUN :DRE 7-APR-86
	J	RFG010						:DRE 30-DEC-86

:	Put marking link in DISC state
TFG6XX	RBT	RL,XOMLDH		:INDICATE XOM WANTS IT NOT DOWN
   IF	BSC
	LA	R8,CROTOR,,
	LIS	R3,4			:TURN ON RTS COMMAND
	STH	R3,,R8
	LIS	R3,9			:TURN ON DTR COMMAND
	STH	R3,8,R8
	LIS	R3,0			:STOP LIST PROCESSING & OUTPUT MARKS
	STH	R3,10,R8
	LB	R7,SLU.LT,RL,
	SVC	IO,(FSYNO.^4)+R7
	J	RFG010			:ERROR RETURN		:DRE 30-DEC-86
   EI (BSC)
	J	TFG4XX			:PUT LINK IN DISCONNECT STATE
  EI (XOM)

	SSTTL(FOREGROUND REQUESTS)
TFG012	HS
  IF	XOM
	TBT	RL,XOMLDH
	JN	RFG010			:IF XOM WANTS IT DOWN-LEAVE IT ALONE :DRE 30-DEC-86
	TBT	RL,XOMLDS
	JN	RFG010			: EVEN IF DISC (BY XOM) :DRE 30-DEC-86
  EI
:	LB	RSG,SCGBIA,RL,					:DRE 30-DEC-86
:	LR	RFB,RL
:	SLLS	RFB,4			:FORM FRAME ARRAY BIAS
:	LIS	R0,7
:	TBT	RL,F128.F
:	JEFS	TFG020			:IF NOT MOD128
:	LHI	R0,7F
:TFG020	STH	R0,FMMSK
	TBT	RL,REINIT
	JN	TFG050

:	NOW CHECK IF COMMAND HANDLER HAS QUEUED UP A RESPONSE TO SEND
	LB	R1,XSSTAT,RL		:SEE IF AN ENTRY
	JE	TFG030			:IF NONE TO CHECK RESPONSE HANDLER
	JAL	R5,XROOM		:MAKE SURE ROOM IN OUTPUT LIST BEFORE CONTINUING
  IF	HDLC
	J	TFG040			:IF NO ROOM
  EI

:	FORM ADDRESS OF SUBROUTINE TO ENTER
	LHL	R2,STMDEC,R1,R1		:GET ADDRESS FROM TABLE
	LB	R5,SADRT,RL,		:USE RESPONSE ADDRESS
	LIS	R3,0
	STB	R3,XSSTAT,RL
	JAL	R0,STMDEC,R2		:GO TO ROUTINE
	J	TFG030			:JUMP AROUND THE STMDEC TABLE

:	COMMAND HANDLER FOREGROUND TRANSMIT DECISION TABLE.
:	ENTRY BASED ON INDEX VALUE STORED IN XSSTAT CELL.
:	
 TABLE(STMDEC)
	TENTRY(STMERR)		:ZERO ENTRY NOT USED
	TENTRY(XRR)		:COMMAND HANDLER XMIT AN RR
	TENTRY(XRRM)		:MUST TRANSMIT AN RR
	TENTRY(XRNR)		:XMIT AN RNR
	TENTRY(XREJ)		:TRANSMIT AN REJ
	TENTRY(XCMDR)		:XMIT A FRMR
	TENTRY(XUA)		:XMIT A UA
	TENTRY(XDM)		:XMIT A DM RESPONSE
	TENTRY(XUAM)		:XMIT A UA AND GO NOT ARMED
	TENTRY(XDMM)		:XMIT A DM AND GO NOT ARMED
	TENTRY(XRRC)		:XMIT AN RR/ RNR COMMAND
	TENTRY(XRRC)		:XMIT AN RR/ RNR COMMAND OR I-FRAME POLL
 ENDTABLE(STMDEC)

:------------------------------------------------------
::	COMMAND HANDLER TRANSMIT ROUTINES.
:	ENTRY	(R1)= CONTROL FIELD
:		(R5)= COMMAND ADDRESS
:------------------------------------------------------


:	ERROR ROUTINE- CODE TRYS TO EXECUTE A FORGRAOUND XMIT DECISION ON
:	COMMAND HANDLER WHEN XSSTAT=0.

STMERR	LIS	R3,1
	AHM	R3,PRGER1,,
	J	TFG100


:	COMMAND HANDLER HAS AN RR RESPONSE QUEUED UP. FIRST CHECK IF AN OUTPUT
:	SECTOR IS BUILT BUT NOT SENT. IF SO DO NOT SEND RR, LET I-FRAME
:	CARRY LATEST ACKNOWLEDGEMENT.

XRR	LB	R1,NXTSEC,RL		:GET NEXT SECTOR TO SEND
	TBT	R1,SECBLT,RSG		:SEE IF READY TO GO
	JEFS	XRRM			:NO SECTOR, SEND RR

:	IF SECTORS A BUILT AND NOT SET SEE IF IN TIMER RECOVERY. IF SO
:	SEE IA A TIMEOUT HAS OCCURRED, IF NOT SEND RR RESPONSE.
XRR010	LB	R1,PRIST,RL
	CLHI	R1,PTRECV		:SEE IF IN TIMER RECOVERY
	JNR	R0			:IF NOT
	TBT	RL,T1TO.F		:SEE IF A TIME OUT HAS OCCURRED
	JNR	R0			:IF SO


:	COMMAND HANDLER HAS AN RR RESPONSE QUEUED UP THAT MUST BE SENT.
:
XRRM	LHI	R1,CT.RR		:LOAD RR RESPONSE
	J	OUTFRM			:GO XMIT IT


:	COMMAND HANDLER HAS AN RNR QUEUED UP.
XRNR	LHI	R1,CT.RNR		:LOAD RNR RESPONSE
	J	OUTFRM			:GO SEND IT


:	COMMAND HANDLER HAS A REJ QUEUED UP
XREJ	LHI	R1,CT.REJ		:LOAD REJ RESPONSE
	J	OUTFRM


:	COMMAND HANDLER HAS A FRMR OR CMDR QUEUED UP
XCMDR	LIS	R1,1					:LSH 16-APR-87
	AHM	R1,ERFRMR,RL2,		:NUMBER OF FRMR/CMDRS SENT
  					:EXCLUDE RETRANSMITTED FRMR/CMDRS SENT
  IF	LAPB
	LB	R3,RTCNT,RL
	STH	R3,XRETER,RL2		:SET RETRANSMISSION COUNT
:	ENTRY TO RETRANSMIT FRMR			:LSH 16-APR-87
XCMDRE	RBT	RL,T1TO.F
	L	R3,FASTC,,
	AH	R3,T1.LT,RL2,
	ST	R3,T1CNTR,RL2,RL2
	SBT	RL,T1TA.F
  EI
	LHI	R1,CT.FR		:LOAD FRMR RESPONSE

	:CHANGES BEGIN HERE					:LSH 16-APR-87
	:TO COUNT LINK ERROR STATISTICS
	LIS	R3,1
	AHM	R3,CMDSNT,RL,RL		:# OF FRMR/CMDR SENT, INCLUDING
					:RETRANSMITTED FRMR/CMDR SENT(LOG 94)
   IF	XOM
	AHM	R3,LKS.9,RL,RL		:# OF FRMR/CMDR SENT, INCLUDING
					:RETRANSMITTED FRMR/CMDR SENT (XOM)
   EI	:XOM
	:CHANGES END HERE					:LSH 16-APR-87

	J	OUTFRM			:GO SEND IT


:	COMMAND HANDLER HAS A UA QUEUED UP.
XUA	LHI	R1,CT.UA		:LOAD UA RESPONSE
	J	OUTFRM			:GO SEND IT

:ROUTINE TO XMIT A UA RESPONSE AND ALSO GO NOT ARMED.
:
XUAM	LIS	R1,PNARM
	STB	R1,PRIST,RL
:	SHOULD THIS BE SET?????
	SBT	RL,REINIT		:SET UP TO GO NOT ARMED
	RBT	RL,PACKUP		:FLAG PACKET LEVEL AS DOWN
	RBT	RL,LINKUP		:FLAG LINK AS DOWN
	JE	XUA			:IF ALREADY DOWN
	SBT	RL,HANGEM		: ELSE INDICATE HANG USERES
	J	XUA


:XMIT A DM RESPONSE AND FLAG LINK AS DOWN

  IF LAPB
XDMM	LIS	R1,PNARM		:GET NOT ARMED STATE
	STB	R1,PRIST,RL
	SBT	RL,REINIT		:SET FLAG SO LINK CONTROL LOGIC DOES NOT RUN
	RBT	RL,PACKUP		:FLAG PACKET LEVEL AS DOWN
	RBT	RL,LINKUP
	JEFS	XDM			:IF LINK ALREADY DOWN
	SBT	RL,HANGEM		: ELSE HANG USERS
:	J	XDM
  ELSE LAP
XDMM	JR	R0			:MISTAKE OF SOME SORT, IGNORE
  EI	LAPB


:	SEND A DM RESPONSE.
:
XDM	LHI	R1,CT.DM		:GET DM RESPONSE
	J	OUTFRM

:	SEND AN RR OR RNR COMMNAD DEPENDING ON WHETHER WE ARE BUSY
:	OR NOT.

XRRC
  IF	FINACT
	TBT	RL,SNTRRC
	JER	R0			:IGNORE IF FLAG NOT SET
	LB	R1,PRIST,RL
	CLHI	R1,PTRECV
	JER	R0			:IF IN TIMER RECOVERY
	RBT	RL,T1TO.F		:TURN OFF TIMER OCURRED FLAG
	LB	R3,RTCNT,RL
	STH	R3,XRETER,RL2		:SET RETRANSMISSION COUNT

:	SEND RR OR RNR COMMNAD.
SNDRRC	L	R3,FASTC,,
	AH	R3,T1.LT,RL2,
	ST	R3,T1CNTR,RL2,RL2	:SET TIMER
	SBT	RL,T1TA.F
	LHI	R1,CT.RR
	SBT	RL,PFBIT		:TURN ON P BIT
	LB	R5,LVACK,RL
	STB	R5,RTVS,RL		:FAKE RETRANSMISSION N(S)
	LIS	R1,PTRECV
	STB	R1,PRIST,RL		:ENTER TIMER RECOVERY STATE
	LB	R5,PADRT,RL,		:SET UP COMMAND ADDRESS
	LHI	R1,CT.RR
	TBT	RL,XSBUSY
	JE	OUTFRM			:PUT OUT A RR COMMNAD
	LHI	R1,CT.RNR
	J	OUTFRM			:PUT OUT A RNR COMMAND
  ELSE
	JR	R0
  EI	FINACT

:  EI	LAPB!LAP
 	SSTTL(RESPONSE TRANSMIT ROUTINES)
:  IF	LAPB!LAP

TFG030	JAL	R5,XROOM		:MAKE SURE ROOM IN OUTPUT LIST BEFORE CONT.
  IF	HDLC
	J	TFG040			:IF NO ROOM
  EI
	LB	R3,PRIST,RL		:GET RESPONSE HANDLER STATE
	LHL	R3,PTMDEC,R3,R3		:GET TABLE ENTRY
	LB	R5,PADRT,RL,		:SET UP COMMAND ADDRESS
	J	PTMDEC,R3
:	RETURN TO TFG100

 TABLE(PTMDEC)
	TENTRY(TPNARM)		:INTERFACE IN NOT ARMED STATE
	TENTRY(TPARMG)		:INTERFACE IN ARMING STATE
  IF	LAP
	TENTRY(TPPWSA)		:PRIMARY STATION WAITING FOR SECONDARY STATION TO ARM
  EI
	TENTRY(TPINFO)		:INTERFACE IN INFO XSFER
	TENTRY(TPTMRC)		:INTERFACE IN TIMER RECOVERY
	TENTRY(TPREST)		:INTERFACE IN RESET STATE
  IF	LAPB
	TENTRY(TPFRMR)		:INTERFACE IN FRAME REJECT STATE
  EI
	TENTRY(TPDISC)		:INTERFACE IN DISCONNECT STATE
  IF	LAP
	TENTRY(TPPWSD)		:PRIMARY STATION WAITING FOR SECONDARY STATION TO DISC
  EI

TFG040	TBT	RL,T1TO.F
	JE	TFG100			:IF XMTR NOT TIMED OUT
TFG050	LIS	R5,PNARM
	STB	R5,PRIST,RL		:PUT LINE IN NOT ARMED STATE
	RBT	RL,T1TA.F
	RBT	RL,T1TO.F
  IF	LAP
	LIS	R5,SECADM
	STB	R5,SECST,RL
	RBT	RL,SARMED
:	THE FOLLOWING MAY BE NECESSARY FOR CLEAN UP
	RBT	RL,STARM
:	RBT	RL,PARMED
  EI
	RBT	RL,LINKUP
	JEFS	TFG055			:IF LINK ALREADY DOWN	:DRE 7-APR-86
	SBT	RL,HANGEM		: ELSE INDICATE HANG USERS
TFG055	RBT	RL,PACKUP					:DRE 7-APR-86
	RBT	RL,BCKFLG					:DRE 7-APR-86
	RBT	RL,REINIT					:DRE 7-APR-86
	J	RFG010						:DRE 30-DEC-86

   IF	HDLC
TFG100	EQ	RFG010						:DRE 30-DEC-86
   ELSE	BSC
TFG100	RBT	RL,SVCFLG		:SEE IF AN SVC TO DO
	JE	RFG010			:IF NOT TO CHECK NEXT LINE :DRE 30-DEC-86
	LB	R6,SLU.LT,RL,
	L	R7,SVCADR		:GET ADDRESS
	LIS	R2,1
	STH	R2,,R7	 		:PUT IN OPERATION CODE
	SVC	IO,(CSYNO.^4)+R6
	J	RFG010			:FAILED - INVALID SPEC OR LU ACTIVE :DRE 30-DEC-86
	J	RFG010						:DRE 30-DEC-86
   EI	BSC



::	RESPONSE HANDLER TRANSMIT ROUTINES.
:	ENTRY	(R5)= RESPONSE ADDRESS

:	INTERFACE IS IN  NOT ARMED STATE. SEE IF BACKGROUND HAS QUEUED UP
:	A SABM COMMAND TO INITIATE LINK SET UP.
:
TPNARM	HS
	LB	R1,XPSTAT,RL		:SEE IF ANYTHING QUEUED UP
	JE	TFG100			:IF NOT TO CHECK NEXT LINE
:	LIS	R3,0						:SCY 15-Feb-85
:	STB	R3,XPSTAT,RL		:ZERO OUT CELL		:SCY 15-Feb-85
	CLHI	R1,XMPSAM		:VERIFY ITS A SABM
	JEFS	TNAR40			:IF IT IS A SABM
:	PROGRAMMING ERROR.
	LIS	R3,1
	AHM	R3,PRGER2,,		:INCREMENT ERROR CELL
	J	TFG100


TNAR40	HS
  IF	LAP
:	NOW SEE IF SECONDARY STATION IS STILL TRYING TO ARM, IE: HAS NOT RECEIVED
:	A DISCONNECT.
	TBT	RL,STARM		:SEE IF SECONDARY STATION STILL TRYING TO ARM
	JNFS	TNAR20			:IF SO
	TBT	RL,SARMED		:CHECK IF SECONDARY STATION MAY HAVE ARMED FIRST
	JNFS	TNAR20			:IF SO
	TBT	RL,BCKFLG		:TEST BACKGROUND FLAG	:DRE 27-MAY-86
	JE	SNDDSC			:SEND DISC IF BACKGROUND HASN'T RUN
TNAR20	HS
  EI

:	HAVE A SABM OR SARM TO SEND. SEE IF ROOM IN OUTPUT LIST AND SEND IT.
  IF	LAPB
	LHI	R1,CT.SBE		:LOAD SABME COMMAND
	TBT	RL,F128.F
	JNFS	TNAR60
	LHI	R1,CT.SB		:LOAD SABM COMMAND CONTROL FIELD
  ELSE	LAP
	LHI	R1,CT.SR		:LOAD SARM
  EI
:	CHECK LINE STATUS BEFORE SENDING A SABM.		:SCY 15-Feb-85
:	IF LINE IS UP, THEN PUT INTERFACE			:SCY 15-Feb-85
:	IN ARMING STATE AND START TIMER T1 ON SABM/SARM.	:SCY 15-Feb-85
TNAR60								:SCY 15-Feb-85
  IF	HDLC							:SCY 25-Feb-85
	L	R2,SIOTBL,RL2,RL2	:GET SIOTBL BASE ADDRESS:SCY 15-Feb-85
	LB	R3,SI.RS+5,R2		:GET 5TH BYTE OF READ STATUS:SCY 15-Feb-85
	THI	R3,2			:CHECK WHETHER LINE IS IDLE:SCY 15-Feb-85
	JN	TFG100			:EXIT IF LINE IS IDLE	:SCY 15-Feb-85
	TBT	RL,CLKC.F					:SCY 15-Feb-85
	JEFS	TNAR65			:SKIP IF NOT CHECK CLOCK STATUS:SCY 15-Feb-85
	NHI	R3,07			:ISOLATE CLOCK AND IDLE BITS:SCY 15-Feb-85
	SIS	R3,5						:SCY 15-Feb-85
	JN	TFG100			:EXIT IF CLOCK NOT PRESENT:SCY 15-Feb-85
  EI	HDLC							:SCY 25-Feb-85
TNAR65								:SCY 15-Feb-85
	LIS	R3,0						:SCY 15-Feb-85
	STB	R3,XPSTAT,RL		:ZERO OUT XPSTAT CELL	:SCY 15-Feb-85
	SBT	RL,PFBIT		:SET P BIT
	JAL	R0,OUTFRM
	LIS	R2,PARMG
	STB	R2,PRIST,RL		:GOTO ARMING STATE
	RBT	RL,T1TO.F		:MAKE SURE TIMEOUT OCCURRED FLAG NOT SET
	L	R3,FASTC,,
	AH	R3,T1.LT,RL2,
	ST	R3,T1CNTR,RL2,RL2	:STORE T1 TIME
	SBT	RL,T1TA.F		:TURN TIMER ON
	LB	R3,RTCNT,RL		:GET RETRANSMISSION COUNT
	STH	R3,XRETER,RL2		:SAVE IT
:	RBT	RL,BCKFLG		:RESET BACKGROUND FLAG TO LET IT KNOW
					:WE ARE TRYING TO ARM LINK
	J	TFG100			:GO CHECK NEXT LINE


:	INTERFACE IS IN ARMING STATE. WHEN A UA IS RECEIVED FOR SABM OUT
:	INTERFACE RECV LOGIC WILL TAKE INTERFACE OUT OF THIS STATE. WHILE
:	IN THIS STATE CHECK FOR A TIMEOUT ON SABM.
:	
TPARMG	RBT	RL,T1TO.F		:SEE IF A TIMEOUT OCCURRED
	JE	TFG100			:IF NOT
	RBT	RL,T1TA.F		:TURN TIMER OFF
	LCS	R3,1
	AHM	R3,XRETER,RL2		:INCREMENT RETRANS. CNTER
	LIS	R3,1			:			:JL 30-Sep-85
	AHM	R3,ARMER2,RL2,		:FOR LINK STATUS PURPOSE
  IF	LAPB
:	IF RETRANSMISSION COUNTER GOES TO ZERO JUST SET IT BACK UP
:	AGAIN SINCE INTERFACE IS TRYING TO ARM AND HAS NOT RECEIVED A UA YET.
	JNFS	TARM10
	LB	R3,RTCNT,RL
	STH	R3,XRETER,RL2
TARM10	LHI	R1,CT.SBE		:LOAD SABME COMAND
	TBT	RL,F128.F
	JNFS	TARM30
	LHI	R1,CT.SB		:LOAD SABM COMMAND
  ELSE	LAP
:	IF RETRANSMISSION COUNTER GOES TO ZERO, SEND DISCONNECT.
	JE	SNDDSC

TARM10	LHI	R1,CT.SR		:LOAD SARM COMMAND
	TBT	RL,STARM		:MAKE SURE SECONDARY STATION STILL TRING TO ARM
	JNFS	TARM30			:IF SO
	TBT	RL,SARMED
	JE	SNDDSC
  EI
:	CHANGE X INTERFACE FROM ARMING STATE TO NOT ARMED	:SCY 15-Feb-85
:	STATE WHEN LINE BECOMES IDLE.				:SCY 15-Feb-85
TARM30								:SCY 15-Feb-85
   IF	HDLC
	L	R2,SIOTBL,RL2,RL2	:GET SIOTBL BASE ADDRESS:SCY 15-Feb-85
	LB	R3,SI.RS+5,R2		:GET 5TH BYTE		:SCY 15-Feb-85
	THI	R3,2			:CHECK WHETHER LINE IS IDLE:SCY 15-Feb-85
	JN	TARM35			:SKIP IF LINE IS IDLE	:SCY 15-Feb-85
   EI	HDLC							:SCY 25-Feb-85
	SBT	RL,PFBIT		:SET P BIT
	JAL	R0,OUTFRM		:GO SEND IT

	L	R3,FASTC,,
	AH	R3,T1.LT,RL2,
	ST	R3,T1CNTR,RL2,RL2	:STORE NEW T1 TIME
	SBT	RL,T1TA.F		:TURN TIMER ON
	J	TFG100			:GO LOOK AT NEXT LINE
TARM35								:SCY 15-Feb-85
   IF	HDLC
	LIS	R1,XMPSAM		:LOAD A SABM		:SCY 15-Feb-85
	STB	R1,XPSTAT,RL		:QUEUE UP A SABM	:SCY 15-Feb-85
	LIS	R1,PNARM					:SCY 15-Feb-85
	STB	R1,PRIST,RL		:GOTO NOT ARMED STATE	:SCY 15-Feb-85
	J	TFG100			:GO BACK TO LOOK AT NEXT LINE:SCY 15-Feb-85
   EI	HDLC							:SCY 25-Feb-85

  IF	LAP
:	PRIMARY STATION IN WAITING FOR SECONDARY STATION TO ARM STATE.
:	CHECK TO SEE IF SECONDARY STATION HAS ARMED YET. IF SO TURN OFF TIMER
:	AND PLACE BOTH PRIMARY STATION AND SECONDARY STATION IN INFO XSFER. IF NOT SEE IF
:	TIMER HAS RUN OUT. IF SO CHECK RETRANSMISSION CNTR. IF ZERO
:	SEND A DISCONNECT, OTHERWISE RETRANSMIT SARM.
:
TPPWSA	TBT	RL,SARMED		:SEE IF SECONDARY STATION ARMED YET
	JE	TWSA20			:IF IT IS
	RBT	RL,T1TA.F		:STOP TIMER
	RBT	RL,T1TO.F		:RESET TIMEOUT OCCURRED FLAG
	LIS	R3,SECINF
	STB	R3,SECST,RL		:PUT SECONDARY STATION IN INFO XSFER
	LIS	R3,PINFO
	STB	R3,PRIST,RL		:PUT PRIMARY STATION IN INFO XSFER
	SBT	RL,LINKUP		:FLAG LINK AS BEING UP
	J	TFG100

TWSA20	RBT	RL,T1TO.F		:RESET TIMEOUT OCCURRED FLAG
	JE	TFG100			:IF NO TIME OUT
	RBT	RL,T1TA.F		:TURN TIMER OFF
	LCS	R3,1
	AHM	R3,XRETER,RL2		:INCREMENT RETRANS CNTR

:	IF RETRANSMISSION CNTR GOES TO ZERO GO TO DISCONNECT STATE
	JN	TARM10			:GO SEND SARM AGAIN.
	LCS	R3,1
	AHM	R3,ILERRE,RL2,		:INCREMENT FACT THIS HAPPEND
  EI

:	SEND DISCONNECT AND ENTER DISCONNECT STATE.
SNDDSC	LHI	R1,CT.DIS		:LOAD DISC CONTROL FIELD
	JAL	R0,OUTFRM
  IF	LAP
	RBT	RL,STARM		:NO LONGER TRYING TO ARM
  EI
	LIS	R2,PRDISC
	STB	R2,PRIST,RL		:PUT INTERFACE IN DISCONNECT STATE
	L	R3,FASTC,,
	AH	R3,T1.LT,RL2,
	ST	R3,T1CNTR,RL2,RL2	:STORE NEW T1 TIME
	SBT	RL,T1TA.F		:TURN TIMER BACK ON
	LB	R3,RTCNT,RL
	STH	R3,XRETER,RL2		:STORE NEW RETRANSMISSION COUNT
	RBT	RL,LINKUP		:MAKE SURE LINK UP FLAG IS RESET. :DRE 28-APR-86
	JEFS	SNDDS5			:IF LINK ALREADY DOWN	:DRE 28-APR-86
	SBT	RL,HANGEM		: ELSE INDICATE HANG USERS :DRE 28-APR-86
SNDDS5	RBT	RL,BCKFLG		:SIGNAL BACKGROUND TO RUN :DRE 28-APR-86
	RBT	RL,PACKUP		:FLAG PACKET LEVEL AS DOWN :DRE 28-APR-86
	RBT	RL,REINIT					:DRE 28-APR-86
	J	TFG100			:GO CHECK NEXT LINE


:	INTERFACE IN INFO XSFER.
:	CHECK IF A TIMEOUT ON ANY OUTSTANDING FRAMES. IF SO VERIFY A
:	FRAME IS REALLY OUT AND GO INTO TIMER RECOVERY.
:	SEE IF ANY NEW SECTORS BUILT IF NONE OF THE ABOVE. IF SO
:	CHECK TO MAKE SURE OTHER END IS NOT BUSY. IF IT IS SEE IF
:	ANY FRAMES ALREADY OUT.  IF SO DO NOT BUILD A NEW FRAME.
:	IF NOT SEND NEW FRAME TO INITIATE A POLLING SITUATION.
:
TPINFO	HS
  IF	LAP
	TBT	RL,SARMED
	JE	SNDDSC			:IF SECONDARY STATION NOT ARMED, SEND DISC
  EI
	RBT	RL,T1TO.F		:HAS A TIMEOUT OCCURRED
	JN	TINF40			:IF SO
	LB	R3,NXTSEC,RL		:GET NEXT SECTOR TO SEND
	TBT	R3,SECBLT,RSG		:SEE IF THIS SECTOR READY
	JE	TFG100			:IF NOT TO CHECK NEXT LINE

:	CHECK TO MAKE SURE HAVE NOT XMITTED MAX FRAMES ALLOWED.
	LB	R5,LVACK,RL		:GET LAST FRAME ACKED
	AIS	R5,1
	LB	R3,K.LT,RL,
	AR	R5,R3
	NH	R5,FMMSK
	CLB	R5,XVS,RL		:SEE IF THIS WOULD BE TOO MANY FRAMES
	JE	TINF05			:IF SO
	TBT	RL,OTHBSY		:SEE IF OTHER END BUSY
	JE	TINF10			:IF NOT BUSY

:	OTHER END BUSY. SEE IF ALREADY HAVE FRAMES OUT. IF NOT SEND
:	THIS ONE.
	LB	R5,LVACK,RL
	AIS	R5,1
	NH	R5,FMMSK
	CLB	R5,XVS,RL		:SEE IF ANY FRAMES OUT
	JE	TINF10			:NO, SEND ONE TO HAVE SOMETHING TO POOL WITH :DRE 7-OCT-87
TINF05	LB	R1,XVR,RL		:LOAD CURRENT N(R) VALUE :DRE 7-OCT-87
	CLB	R1,XTNR,RL		:SAME AS LAST TRANSMITTED? :DRE 7-OCT-87
	JE	TFG100			:YES, ALL DONE		:DRE 7-OCT-87
	LHI	R1,CT.RR		:SET UP TO SEND RR	:DRE 7-OCT-87
	TBT	RL,XSBUSY		:ARE WE BUSY		:DRE 7-OCT-87
	JEFS	TINF07			:NO, SEND THE RR	:DRE 7-OCT-87
	LHI	R1,CT.RNR		:YES, SEND A RNR	:DRE 7-OCT-87
TINF07	LB	R5,SADRT,RL,		:SET-UP RESPONSE ADDRESS :DRE 20-NOV-87
	JAL	R0,OUTFRM		:SEND THE RR/RNR	:DRE 7-OCT-87
	J	TFG100			:FINISHED UP		:DRE 7-OCT-87

:	BUILD NEW FRAME TO SEND.
TINF10	LIS 	R1,1			:FOR XOM LINK STATISTICS PURPOSE
  IF	XOM
	AM	R1,FCNTLK,RL2,RL2	:INCREMENT NO. OF I-FRAMES OUT
  EI
	TBT	RL,F128.F
	JE	TINF20			:IF NOT MOD128
	LB	R1,XVR,RL		:GET N(R) VALUE
	STB	R1,XTNR,RL		:UPDATE LAST XMITTED N(R)
	SLLS	R1,1			:PUT INTO POSITION
	RBT	RL,PFBIT 		:SEE IF WE SHOULD SET P BIT
	JEFS	TINF15
	OHI	R1,CT.2PF		:SET P BIT
	OOPS
TINF15	STB	R1,TECVCN,RL		:2ND CONTROL BYTE
	LB	R1,XVS,RL		:GET V(S)
	SLLS	R1,1			:PUT INTO POSITION
	STB	R1,TECVCM,RL		:1ST CONTROL BYTE
	J	TINF25

TINF20	LB	R1,XVR,RL		:GET N(R) VALUE
	STB	R1,XTNR,RL		:UPDATE LAST XMITTED N(R)
	SLLS	R1,5			:PUT N(R) INTO POSITION
	LB	R2,XVS,RL		:GET V(S) VALUE
	SLLS	R2,1			:PUT IN PROPER POSITION
	OR	R1,R2			:OR IN N(S) VALUE
	RBT	RL,PFBIT		:SEE IF P BIT FLAG SET
	JEFS	TINF25			:IF NOT
	OHI	R1,CT.1PF		:OR IN P BIT
	OOPS

:	GO FINISH CHECKSUM AND TERMINATE ENTRY IN ROTOR.
TINF25	LB	R5,NXTSEC,RL
	LHL	R0,SECBIA,RL2,
	AR	R5,R0
	AR	R5,R5
	JAL	R0,INFTRM		:GO FINISH CHECKSUM

:	NOW HAVE A NEW FRAME IN OUTPUT LIST. UPDATE SECTOR AND FRAME SENT
:	ARRAYS AND VARIABLES.

	LB	R5,XVS,RL		:GET V(S) VALUE
	SBT	R5,VSENT,RFB		:SET FRAME SENT FLAG
	AIS	R5,1			:UPDATE V(S)
	NH	R5,FMMSK
	STB	R5,XVS,RL
	LB	R5,NXTSEC,RL		:GET NEXT SECTOR NUMBER
	SBT	R5,SECSNT,RSG		:SET FLAG
	AIS	R5,1
	CLB	R5,K.LT,RL,
	JLFS	TINF30
	LIS	R5,0
TINF30	STB	R5,NXTSEC,RL
	TBT	RL,T1TA.F		:SEE IF TIMER ALREADY ON
	JN	TFG030			:IF SO
	RBT	RL,T1TO.F		:MAKE SURE TIMEOUT FLAG RESET
	L	R5,FASTC,,
	AH	R5,T1.LT,RL2,
	ST	R5,T1CNTR,RL2,RL2	:STORE NEW T1 TIME
	SBT	RL,T1TA.F		:TURN TIMER ON
	J	TFG030


:	INTERFACE IS IN INFO XSFER AND HAS DETECTED A TIMEOUT ON A
:	PREVIOUSLY XMITTED I-FRAME. RETRANSMIT FIRST I-FRAME NOT ACKED.
:	
TINF40	RBT	RL,T1TA.F		:STOP TIMER

:	SET UP FRAME TO RETRANSMIT AND PUT INTERFACE IN TIMER RECOVERY.
TINF45	LB	R5,LVACK,RL		:GET LAST FRAME ACKED
	AIS	R5,1			:COMPUTE FRAME TO SEND
	NH	R5,FMMSK
	STB	R5,RTVS,RL		:SET UP RETRANSITTED V(S)
	TBT	R5,VSENT,RFB		:MAKE SURE FRAME IS OUT
	JE	TINF80			:POSSIBLE PROGRAMMING ERROR IF NOT
	SLLS	R5,1			:SHIFT V(S) INTO POSITION IN FRAME:DRE 30-JAN-85
	LB	R1,XVR,RL		:GET N(R) VALUE		:DRE 30-JAN-85
	STB	R1,XTNR,RL		:UPDATE LAST XMITTED N(R):DRE 30-JAN-85

:	HANDLE MOD 8 AND MOD128 DIFFERENTLY			:DRE 30-JAN-85
	TBT	RL,F128.F					:DRE 30-JAN-85
	JEFS	TINF50						:DRE 30-JAN-85

:	MOD128							:DRE 30-JAN-85
	STB	R5,TECVCM,RL		:STORE V(S) IN MOD128 SAVE AREA	:DRE 30-JAN-85
	SLLS	R1,1			:PUT N(R) INTO POSITION	:DRE 30-JAN-85
	OHI	R1,CT.2PF		:TURN ON P BIT		:DRE 30-JAN-85
	STB	R1,TECVCN,RL		:SAVE FOR LATER		:DRE 30-JAN-85
	LR	R1,R5			:1ST CTL FIELD HAS TO BE IN R1 :DRE 30-DEC-86
	JFS	TINF60						:DRE 30-JAN-85

:	MOD8							:DRE 30-JAN-85
:	NOW FORM CONTROL FIELD IN REG 1				:DRE 30-JAN-85
TINF50	SLLS	R1,5			:PUT N(R) INTO POSITION	:DRE 30-JAN-85
	OR	R1,R5			:OR IN V(S) INTO CONTROL FIELD:DRE 30-JAN-85
	OHI	R1,CT.1PF		:TURN P BIT ON		:DRE 30-JAN-85
TINF60	LB	R5,LSACK,RL		:GET LAST SECTOR ACKED	:DRE 30-JAN-85
	AIS	R5,1			:COMPUTE SECTOR TO SEND
	CLB	R5,K.LT,RL,
	JLFS	TINF70
	LIS	R5,0
TINF70	TBT	R5,SECSNT,RSG
	JE	TINF90			:PROGRAMMING ERROR IF NOT
	LHL	R0,SECBIA,RL2,
	AR	R5,R0
	AR	R5,R5

:	NOW GO AND STORE ADDRESS AND CONTROL FIELD INTO SECTTOR AND FINISH
:	CHECKSUM AND ENTER ENTRY INTO OUTPUT LIST.
	JAL	R0,INFTRM

:	RETURN HERE WHEN ENTRY MADE IN OUTPUT LIST
	RBT	RL,T1TO.F		:MAKE SURE TIMOUT FLAG IS RESET
	L	R5,FASTC,,
	AH	R5,T1.LT,RL2,
	ST	R5,T1CNTR,RL2,RL2	:STORE NEW T1 TIME
	SBT	RL,T1TA.F		:TURN TIMER ON
	LB	R5,PRIST,RL
	CLHI	R5,PTRECV
	JE	TFG100			:IF ALREADY IN TIMER RECOVERY
	LIS	R5,PTRECV
	STB	R5,PRIST,RL		:PUT INTERFACE IN TIMER RECOVERY
	LB	R5,RTCNT,RL
	STH	R5,XRETER,RL2		:INITIALIZE RETRANSMISSION COUNT
	LIS	R3,1
	AHM	R3,NTRECV,RL2,
  IF	XOM
	AHM	R3,LKS.7,RL2,		:SAVE FOR XOM LINK STATISTICS
  EI
	J	TFG100			:GO CHECK NEXT LINE


:	TIMING ERROR, TINF40 ROUTINE TRIED TO RETRANSMIT A FRAME
:	THAT WAS NOT OUT ALREADY, OR FRAME ACKED BY NON-FINAL RR
TINF80  IF	LAPB						:DRE 18-APR-86
	JAL	R0,SNDRRC		:SEND RRC		:DRE 18-APR-86
	J	TFG100						:DRE 18-APR-86
  ELSE
	LIS	R0,1
	AHM	R0,ILERR3,RL2,
	TRAP(RL,FD)		:TRIED TO RETRANSMIT FRAME NOT OUT ALREADY
  EI

:	PROGRAMMING ERROR, TINF40 ROUTINE TRIED TO RETRANSMIT A SECTOR NOT
:	OUT ALREADY.
TINF90	LIS	R0,1
	AHM	R0,ILERR5,RL2,
	TRAP(RL,FE)		:TRIED TO RETRANSMIT SECTOR NOT OUT ALREAY



:	INTERFACE IN TIMER RECOVERY.
:	CHECK FOR TIMEOUT ON A FRAME BEING RETRANSMITTED. IF NOT GO TO
:	NEXT LINE
:	IF A TIMEOUT OCCURRED INCREMENT RETRANSMISSION COUNTER AND CHECK
:	IF REACHED MAX. IF SO GO AND SEND RESET.
:	NOTE: IF OTHER END IS BUSY, RETRANSMITTING A FRAME WITH P BIT
:	ON SHOULD GET AN RNR WITH F BIT ON.  THIS IS ESSENTIALLY THE
:	POLLING SITUATION.
:
TPTMRC	HS
  IF	LAP
	TBT	RL,SARMED
	JE	SNDDSC			:IF SECONDARY STATION NOT ARMED, SEND DISC
  EI
	RBT	RL,T1TO.F		:SEE IF A TIMEOUT OCCURRED
	JE	TFG100			:IF NOT
	RBT	RL,T1TA.F		:TURN TIMER OFF
	LIS	R3,1
	AHM	R3,SM.C,RL2,		:INCREMENT ERROR FOR SECONDARY STATION LOGIC
  IF	XOM
	AHM	R3,LKS.0,RL2,		:INCREMENT ERROR FOR XOM LINK STATISTICS
  EI
	LCS	R3,1
	AHM	R3,XRETER,RL2		:INCREMENT RETRANSMISSION CNTR.
	JE	TTMR10			:IF MAX RETRANSMISSION REACHED
  IF	FINACT
	LA	R0,TFG100		:FAKE RETURN ADRESS
	TBT	RL,SNTRRC
	JN	SNDRRC			:IF IN RR COMMAND SENDING MODE
  EI
	J	TINF45			:GO RETRANSMIT I FRAME

TTMR10	LIS	R3,XMPSAM
	STB	R3,XPSTAT,RL		:QUEUE UP A SABM
	LIS	R3,PRESET
	STB	R3,PRIST,RL		:PUT INTERFACE IN RESET STATE
:	J	TPREST			:GO SEND RESET

:	INTERFACE IN RESET STATE. CHECK FIRST TO SEE IF THIS IS FIRST TIME
:	INTO THIS STATE FROM ANOTHER STATE. IF SO XPSTAT WILL EQUAL XMIT
:	SABM INDEX. IF SO SEND A SABM. IF NOT CHECK FOR TIMEOUT.
:	RETRANSMIT SABM UNTIL RETRANSMISSION CNTR GOES TO ZERO
:	IF NO RESPONSE IS RECEIVED THEN ISSUE A DISCONNECT.
:	
TPREST	LB	R3,XPSTAT,RL		:SEE IF ENTRY QUED UP
	JE	TRES40			:IF NONE QUEUED UP
	LIS	R2,0
	STB	R2,XPSTAT,RL
	CLHI	R3,XMPSAM		:VERIFY SABM INDEX
	JEFS	TRES10
	LIS	R3,1
	AHM	R3,PRGER2,RL2,		:PROGRAMMING ERROR, INCREMENT CELL
TRES10	HS
  IF	LAPB
	LHI	R1,CT.SBE		:LOAD SABME COMMAND
	SBT	RL,PFBIT		:SET P BIT
	TBT	RL,F128.F
	JNFS	TRES20
	LHI	R1,CT.SB		:LOAD SABM COMMAND
  ELSE	LAP
	LHI	R1,CT.SR		:LOAD SARM
  EI
	:CHANGES BEGIN HERE					:LSH 16-APR-87
	:TO COUNT LINK ERROR STATISTICS
TRES20	LIS	R0,1
	AHM	R0,RSTERR,RL,RL		:ENTERED RESET STATE COUNT (LOG 99)
	AHM	R0,SM.E2,RL,RL		:NUMBER OF RESET SENT (LOG 85)
   IF	XOM
	AHM	R0,LKS.8,RL,RL		:ENTERED RESET STATE COUNT (XOM)
	AHM	R0,LKS.16,RL,RL		:NUMBER OF RESET SENT (XOM)
   EI	:XOM
	:CHANGES END HERE					:LSH 16-APR-87

	JAL	R0,OUTFRM		:GO SEND IT		:LSH 16-APR-87
	LB	R3,RTCNT,RL
	STH	R3,XRETER,RL2		:SAVE NEW RETRANS. CNT
TRES30	L	R3,FASTC,,
	AH	R3,T1.LT,RL2,
	ST	R3,T1CNTR,RL2,RL2	:SAVE NEW T1 TIME
	RBT	RL,T1TO.F		:RESET TIMEOUT OCCURRED FLAG
	SBT	RL,T1TA.F		:TURN TIMER ON
	J	TFG100			:GO CHECK NEXT LINE

:	CHECK IF TIME OUT OCCURED
TRES40	RBT	RL,T1TO.F		:SEE IF TIMEOUT OCCURRED
	JE	TFG100
	RBT	RL,T1TA.F
	LIS	R3,1			:			:JL 1-Oct-85
	AHM	R3,ARMER2,RL2,		:FOR LINK STATUS PURPOSE:JL 1-Oct-85
  IF	LAP
	TBT	RL,SARMED
	JE	SNDDSC			:IF SECONDARY STATION NOT ARMED, SEND DISC
  EI
	LCS	R3,1
	AHM	R3,XRETER,RL2		:INCREMENT RETRANS. CNTR
	JE	TRES60			:IF ZERO TO SEND DISC.
  IF	LAPB
	LHI	R1,CT.SBE		:LOAD SABME COMMAND
	TBT	RL,F128.F
	JNFS	TRES50
	LHI	R1,CT.SB		:LOAD SABM COMMAND
  ELSE	LAP
	LHI	R1,CT.SR		:LOAD SARM
  EI
TRES50	SBT	RL,PFBIT		:SET P BIT

	:CHANGES BEGIN HERE					:LSH 16-APR-87
	:TO COUNT LINK ERROR STATISTICS
	LIS	R0,1
	AHM	R0,SM.E2,RL,RL		:NUMBER OF RESET SENT (LOG 85)
   IF	XOM
	AHM	R0,LKS.16,RL,RL		:NUMBER OF RESET SENT (XOM)
   EI	:XOM
	:CHANGES END HERE					:LSH 16-APR-87

	JAL	R0,OUTFRM		:GO SEND IT
	J	TRES30			:SET NEW T1 TIME

TRES60	LIS	R3,1
	AHM	R3,ILERRI,RL2,		:ERROR, RESET SENT MAX TIMES WITHOUT A UA RETURNED
	AHM	R3,SM.E4,RL2,
	J	SNDDSC			:GO SEND DISC AND AND ENTER DISC STATE

:	INTERFACE IS IN DISCONNECT STATE.  WHEN A UA IS RECEIVED FOR DISC
:	OUT, INTERFACE RECV LOGIC WILL TAKE INTERFACE OUT OF THIS STATE.
:	UNTIL THIS HAPPENS WATCH FOR TIMEOUT ON DISC. IF ONE OCCURRS
:	RETRANSMIT DISCONNECT. IF MAX RETRANSMISSIONS OCCUR PUT BOTH
:	INTERFACE AND COMMAND HANDLER IN NOT ARMED STATE

TPDISC	RBT	RL,T1TO.F		:SEE IF TIMEOUT OCURRED
	JE	TFG100
	LCS	R3,1
	AHM	R3,XRETER,RL2		:INCREMENT RETRANSMISSION COUNT
	JN	TDIS10
  IF	LAPB
	LIS	R3,PNARM
	STB	R3,PRIST,RL		:PUT INTERFACE IN NOT ARMED STATE
	LIS	R3,1
	AHM	R3,ILERRF,RL2,		:INCREMENT FACT THIS HAPPENED
	RBT	RL,T1TA.F		:STOP TIMER
	RBT	RL,T1TO.F
	RBT	RL,LINKUP		:MAKE SURE LINK UP FLAG RESET
	JEFS	TDIS05			:IF LINK ALREADY DOWN	:DRE 7-APR-86
	SBT	RL,HANGEM		: ELSE INDICATE HANG USERS
TDIS05	RBT	RL,PACKUP		:FLAG PACKET LEVEL AS DOWN :DRE 7-APR-86
	RBT	RL,BCKFLG		:SO LINK WILL INITIATE LINK UP :DRE 7-APR-86
	RBT	RL,REINIT					:DRE 7-APR-86
	J	TFG100			:GO CHECK NEXT LINE
  ELSE	LAP
	LB	R3,RTCNT,RL
	STH	R3,XRETER,RL2
  EI
TDIS10	RBT	RL,T1TA.F		:TURN TIMER OFF
	LHI	R1,CT.DIS		:GET DISC CONTROL FIELD
	SBT	RL,PFBIT		:SET P BIT
	JAL	R0,OUTFRM		:GO SEND IT
	L	R3,FASTC,,
	AH	R3,T1.LT,RL2,
	ST	R3,T1CNTR,RL2,RL2	:SAVE NEW T1 TIME
	SBT	RL,T1TA.F		:TURN TIMER BACK ON
	J	TFG100			:GO CHECK NEXT LINE

  IF	LAPB
:	INTERFACE IN FRAME REJECT STATE.
:	RETRANSMIT FRMR IF T1 TIMER EXPIRED.
:	AFTER N2 RETRANSMISSION, RESET THE LINK.
TPFRMR	RBT	RL,T1TO.F
	JE	TFG100			:IF TIME OUT DID NOT OCCUR
	LCS	R3,1
	AHM	R3,XRETER,RL2
	JEFS	TFMR10			:IF MAX RETRNSMIT CNT REACHED :DRE 9-JUN-87
	LB	R5,SADRT,RL,		:GET RESPONSE ADDRESS
	JAL	R0,XCMDRE		:RETRANSMIT FRAME REJECT
	J	TFG100
TFMR10	RBT	RL,T1TA.F					:DRE 9-JUN-87
	OOPS
	J	TTMR10

  ELSE	LAP
:	PRIMARY STATION IS IN WAITING FOR SECONDARY STATION TO DISCONNECT STATE.
:	CHECK TO SEE IF SECONDARY STATION IS STILL ARMED. IF NOT RESET PRIMARY STATION
:	ARMED FLAG AND PLACE BOTH IN NOT ARMED STATE.
:	IF MAX RETRANSMISSIONS OCCUR AND SECONDARY STATION STILL NOT DISARMED,
:	KEEP SENDING DISCONNECT.
:
TPPWSD	TBT	RL,STARM		:SEE IF SECONDARY STATION TRYING TO ARM
	JNFS	TWSD10			:IF SO
	TBT	RL,SARMED		:SEE IF SECONDARY STATION ARMED
	JE	TWSD20			:IF NOT
TWSD10	RBT	RL,T1TO.F		:SEE IF A TIMEOUT HAS OCCURRED
	JE	TFG100			:IF NOT
	RBT	RL,T1TA.F		:TURN TIMER OFF
	LCS	R3,1
	AHM	R3,XRETER,RL2		:INCREMENT RETRANS CNT
	JN	TWSD30			:IF NOT ZERO TO SEND DISC AGAIN
	LIS	R3,1
	AHM	R3,ILERRG,,		:INCREMENT FACT THIS HAPPEND
	LB	R3,RTCNT,RL 		:RESTORE RETRANSMISSION COUNT
	STH	R3,XRETER,RL2
	J	TWSD30			:GO SEND DISCONNECT AGAIN

TWSD20	RBT	RL,T1TA.F		:TURN OFF TIMER
	RBT	RL,T1TO.F		:RESET TIMEOUT OCURRED FLAG
	LIS	R3,PNARM
	STB	R3,PRIST,RL		:PUT PRIMARY STATION IN NOT ARMED STATE
	LIS	R3,SECADM
	STB	R3,SECST,RL		:PUT SECONDARY STATION IN NOT ARMED STATE
	RBT	RL,SARMED		:RESET SECONDARY STATION ARMED FLAG
:	RBT	RL,PARMED		:RESET PRIMARY STATION ARMED FLAG
	RBT	RL,PACKUP		:FLAG PACKET LEVEL DOWN
	RBT	RL,LINKUP		:FLAG LINK AS NOT UP
	JE	TFG100			:IF LINK ALREADY DOWN
	SBT	RL,HANGEM		: ELSE INDICATE HANG USERS
	J	TFG100			:EXIT


TWSD30	LHI	R1,CT.DIS		:GET DISC CONTROL FIELD
	SBT	RL,PFBIT		:SET P BIT
	JAL	R0,OUTFRM		:GO SEND IT
	L	R3,FASTC,,
	AH	R3,T1.LT,RL2,
	ST	R3,T1CNTR,RL2,RL2	:STORE NEW T1 TIME
	SBT	RL,T1TA.F		:TURN TIMER BACK ON
	J	TFG100
  EI	LAP

  EI	LAPB!LAP
	SSTTL(SUBROUTINES)


  IF	LAPB!LAP
::	ANS -	ANALYZE N(S) PORTION OF I-FRAME CONTROL FIELD.
:
:	INPUT	(RECVCM)= CONTROL BYTE CONTAINING N(S)VALUE
:	OUTPUT	(SEQERR) SET IF SEQUENCE ERROR FOUND
:	EXIT	SKIP RETURN IF N(S) OK, ELSE NORMAL RETURN
:	LINK IS R5

ANS	LB	R6,RECVCM,RL		:GET CONTROL FIELD
	SRLS	R6,1
	NH	R6,FMMSK
	CLB	R6,XVR,RL		:SEE IF N(S) EQUALS V(R)
	JE	ANS010
	SBT	RL,SEQERR		:SEQUENCE ERROR, SET FLAG FOR LATER
	AIS	R5,4			:FORM GOOD RETURN
	JR	R5

:	NOW CHECK TO MAKE SURE N(S) IS NOT OUTSIDE WINDOW BY COMPARING
:	N(S) AGAINST LAST TRANSMITTED N(R) PLUS MAXOUT (MAXIMUM
:	NUMBER OF OUTSTANDING FRAMES.)

ANS010	LB	R4,XTNR,RL		:GET LAST XMITTED N(R) VALUE
	LB	R3,K.LT,RL,
	AR	R4,R3
	NH	R4,FMMSK
	CLR	R4,R6
	JER	R5			:ERROR RETURN IF N(S) IS INVALID.
	AIS	R5,4
	JR	R5


::	ANR-	ANALYZE N(R) VALUE OF A RECEIVED FRAME CONTROL FIELD.
:
:	INPUT	(RECVCM), (RECVCN)
:	LINK IS R5

ANR	TBT	RL,F128.F
	JEFS	ANR010			:IF MOD8
	LB	R4,RECVCN,RL		:GET N(R) VALUE
	SRLS	R4,1			:SHIFT OUT P/F BIT
	JFS	ANR020

ANR010	LB	R4,RECVCM,RL		:GET CONTROL FIELD
	SRLS	R4,5			:GET N(R) VALUE
ANR020	LR	R3,R4			:PUT COPY IN R3
	SIS	R3,1			:DECREMENT VALUE
	NH	R3,FMMSK		:MASK OFF UNNEEDED BITS
	CLB	R4,XVS,RL		:SEE IF N(R)=V(S). IF SO ALL FRAMES OUT
:	IF ANY ARE ACKED.
	JE	ANR030
	TBT	R3,VSENT,RFB		:VERIFY N(R)-1 WAS SENT
	JN	ANR030			:IF IT WAS
	TBT	R4,VSENT,RFB		:SEE IF THE VALUE OF N(R) WAS SENT
	JN	ANR080			:GOOD N(R) BUT NO NEW FRAMES ACKED.
	JR	R5

ANR030	LB	R2,LVACK,RL		:GET LAST FRAME ACKED
	STB	R3,LVACK,RL		:SAVE NEW LAST FRAME ACKED
	SR	R3,R2			:CALCULATE NUMBER OF FRAMES ACKED
	JGEFS	ANR040
	AIS	R3,08			:ADJ FOR MINUS #
	TBT	RL,F128.F
	JEFS	ANR040			:IF NOT MOD128
	AHI	R3,080-08
ANR040	LR	R3,R3
	JE	ANR080			:IF NO NEW FRAMES ACKED

:	NOW RESSET FLAGS IN VSENT (FRAMES SENT BASED ON V(S) VALUES) AND
:	SECSNT (FRAMES SENT BASED ON ACTUAL SECTOR NUMBERS USED INTERNALLY)
:	ARRAYS IF FRAMES WERE ACKED.
:	R3 EQUALS # OF FRAMES ACKED,  R2 EQUALS LAST FRAME ACKED VARIABLE,
:	R1 EQUALS LAST SECTOR ACKED.

	LB	R1,LSACK,RL		:GET LAST OUTPUT SECTOR ACKED
ANR050	AIS	R1,1
	CLB	R1,K.LT,RL,
	JLFS	ANR060
	LIS	R1,0
ANR060	AIS	R2,1			:LAST VARIABLE FRAME ACKED+1
	NH	R2,FMMSK
	RBT	R2,VSENT,RFB		:RESET VSENT ARRAY BITS ACKING FRAME
	RBT	R1,SECSNT,RSG		:RESET SECSNT ARRAY BITD
	RBT	R1,SECBLT,RSG		:RESET SECTOR BUILT FLAGS
	SIS	R3,1
	JN	ANR050			:IF HAVE NOT RESET ALL FLAGS
	STB	R1,LSACK,RL		:SAVE NEW LAST SECTOR ACKED NUMBER


:	NOW HAVE A GOOD I-FRAME WITH GOOD N(R). STOP TIMER IF SOME
:	FRAMES WERE ACKED AND CLEAR RETRANSMISSION COUNTER. IF
:	SOME FRAMES STILL OUT STRART TIEMER AGAIN.

	LB	R12,PRIST,RL
	CLHI	R12,PTRECV		:SEE IF RESPONSE HANDLER IN TIMER RECOVERY
	JN	ANR070			:IF NOT
	LB	R12,RECVCM,RL
	THI	R12,CT.NIF		:SEE IF THIS IS AN I-FRAME
	JE	ANR100			:IF SO
	J	ANR075			:RESTART TIMER IN RECOVERY :DRE 18-APR-86

ANR070	RBT	RL,T1TA.F		:TURN OFF TIMER
	RBT	RL,T1TO.F		:RESET TIMEOUT OCCURRED FLAG
	LCS	R12,1
	STH	R12,XRETER,RL2		:RESET RETRANSMISSION COUNTER
	LB	R12,LVACK,RL		:GET LAST FRAME ACKED
	AIS	R12,1
	NH	R12,FMMSK
	CLB	R12,XVS,RL		:SEE IF ALL FRAMES OUT WERE ACKED
	JE	ANR080
ANR075	L	R12,FASTC,,		:GET PRESENT CLOCK TIME FROM ISIS :DRE 18-APR-86
	AH	R12,T1.LT,RL2,		:GET NEW T1 TIME
	ST	R12,T1CNTR,RL2,RL2	:SAVE NEW T1 TIME COUNT
	SBT	RL,T1TA.F		:TURN TIMER BACK ON
	LB	R12,RTCNT,RL		:GET RETRANSMISSION CNT
	STH	R12,XRETER,RL2		:SAVE NEW RETRANSMISSION CNT
ANR080	AIS	R5,4
	JR	R5			:RETURN TO CALLER

:	WHEN RECEIVEING AN I-FRAME WITH RESPONSE HANDLER IN TIMER RECOVERY, CHECK
:	TO SEE IF ALL FRAMES OUT WERE ACKED. IF SO SET UP FACTORS SO
:	THAT IT LOOKS AS IF THE LAST FRAME ACKED WAS NOT.
ANR100	LB	R12,LVACK,RL		:GET LAST FRAME ACKED
	AIS	R12,1
	NH	R12,FMMSK
	CLB	R12,XVS,RL		:SEE IF ALL FRAMES OUT WERE ACKED
	JN	ANR075			:IF ALL FRAMES OUT WERE NOT ACKED :DRE 18-APR-86
	LB	R12,LVACK,RL
	STB	R12,RTVS,RL		:SET UP RETRANSMITTED V(S)
	SBT	R12,VSENT,RFB		:FLAG FRAME AS BEING OUT
	SIS	R12,1
	NH	R12,FMMSK
	STB	R12,LVACK,RL		:SET LAST FRAME ACKED BACK UP
	LB	R12,LSACK,RL		:GET LAST SECTOR ACKED
	SBT	R12,SECSNT,RSG		:DO THE SAME FOR SECTRO ARRAYS
	SBT	R12,SECBLT,RSG
	SIS	R12,1
	JGE	ANR110
	LB	R12,K.LT,RL,
	SIS	R12,1
ANR110	STB	R12,LSACK,RL		:SAVE LAST SECTOR ACKED
	J	ANR075						:DRE 18-APR-86


::	FIF -	FINISH INFORMATION FRAME.
:		USED TO WRAP UP THE RECEPTION OF AN I-FRAME AND
:		UPDATES POINTERS TO TELL RTD OF MORE DATA.
:
:	INPUT	(NOSTOR)=1 IF WE ALREADY KNOW THERE ISN'T  AN AVAILABLE SECTOR
:		OR ERROR IN THIS FRAME
:		(SEQERR)=1 IF A SEQUENCE ERROR HAS BEEN DETECTED
:
:	LINK IS R5

FIF	ST	R5,RQRET,RL2,RL2
	RBT	RL,SEQERR		:SEE IF A SEQ. ERROR OCCURRED
	JN	FIF100			:IF SO
	TBT	RL,NOSTOR
	JN	FIF050			:IF NO MORE ROOM

	LB	R2,RSC.SZ,RL,		:GET RELATIVE BUFFER SIZE
	SLLS	R2,1
	LH	R3,RSC.FD,RL2		:GET DANGLING SECTOR POINTER
	JGEFS	FIF001			:OK, GOOD, THERE IS ONE SETUP
	TRAP(RL2,DC)		:NO GOOD.  PROGRAMMING ERROR.
FIF001	LR 	R12,R3
	A	R12,RSC.BF,R2,R2	:(R12)=ABSOLUTE BUFFER ADDRESS
  IF	BSC
	LH	R6,MFS.LT,RL2,
	SH	R6,XPCNT,RL2		:GET ACTUAL PACKET COUNT
	LIS	R4,2
	TBT	RL,F128.F
	JEFS	FIF003			:IF MOD 128
	LIS	R4,3
FIF003	SR	R6,R4			:SUBTRACT OUT HEADER
	STH	R6,2,R12		:PUT IN BYTE COUNT
  ELSE	HDLC
	LH	R6,2,R12		:GET KNOWN PACKET BYTE COUNT
  EI
	JE	FIF010			:IF EMPTY I FRAME, DONT CHAIN IT
	LCS	R6,1
	STH	R6,,R12			:CLEAR ITS FORWARD PTR
	STH	R6,RSC.FD,RL2		:CLEAR DANGLING SECTOR POINTER
	LH	R6,RSC.FE,RL2		:FG CHAIN END PTR
	JGEFS	FIF004			:NOT EMPTY
	STH	R3,RSC.FG,RL2		:PUT NEW RSC AT HEAD OF CHAIN
	JFS	FIF006

FIF004	A	R6,RSC.BF,R2,R2		:ABSOLUTE PREVIOUS TAIL RSC PTR
	STH	R3,,R6			:APPEND NEW RSC
FIF006	STH	R3,RSC.FE,RL2		:CURRENT TAIL OF FG CHAIN
FIF010	LB	R12,XVR,RL		:INCREMENT V(R) VALUE SINCE FRAME WAS ACCEPTED
	AIS	R12,1
	NH	R12,FMMSK
	STB	R12,XVR,RL		:SAVE NEW V(R)

:	CHECK RTD RING TO SEE IF AT LEAST ONE MORE MAX FRAME OF
:	SPACE LEFT.  IF NOT SEND AN RNR.
	LB	R2,RSC.SZ,RL,		:RELATIVE BUFFER SIZE
	LH	R2,RSC.AV,R2,R2		:AVAIL CHAIN HEAD
	JGEFS	FIF020			:SOME LEFT IN AVAIL CHAIN
	LH	R2,RSC.FD,RL2		:SEE IF LAST SECTOR DANGLING
	JL	FIF060			:IF NONE LEFT ANYWHERE

:	HAVE RECEIVED A GOOD I-FRAME AND STORED IT IN RTD RING AND HAVE
:	ROOM FOR MORE.	CHECK TO SEE IF BUSY IS SET AND RESET DISCARD FLAGG.
:	IF BUSY WAS SET THEN RR MUST GO OUT TO CLEAR BUSY.  ALSO CLEAR
:	SENT REJECT FLAG.

FIF020	RBT	RL,SNTREJ		:CLEAR SENT REJECT FLAG
	RBT	RL,DSCARD		:CLEAR DISCARD FLAG
	LIS	R2,XMSRR		:GET XMIT RR RESPONSE INDEX
	RBT	RL,XSBUSY		:CHECK IF LAST BUSY
	JEFS	FIF030			:IF BUSY WAS NOT SET
	LIS	R2,XMSRRM		:INDEX OF A MUST TRANSMIT RR RESPONSE
FIF030	TBT	RL,PFBIT
	JEFS	FIF040			:IF NOT
	LIS	R2,1
	AHM	R2,SM.D,RL2,		:INCREMENT FACT RECV. AN I FRAME WITH P BIT ON
  IF	XOM
	AHM	R2,LKS.1,RL2,		:SAVE FOR LINK STATISTICS FOR XOM
  EI
	LIS	R2,XMSRRM		:IF P BIT SET IN I-FRAME MUST SEND RR
FIF040	STB	R2,XSSTAT,RL		:SET UP COMMAND HANDLER XMIT LOGIC
	L	R5,RQRET,RL2,RL2
	JR	R5			:EXIT


:	HAVE RECEIVED A GOOD I FRAME BUT DID NOT STORE IT. HAVE
:	USED N(R) TO ACK FRAMES.  SET FLAG SO WHEN BUSY CLEARS A
:	REJ WILL BE SENT.

FIF050	SBT	RL,DSCARD		:SET FLAG SAYING GOOD FRAME DISCARDED
	SBT	RL,XSBUSY		:MAKE SURE BUSY FLAG SET
	JN	FIF080			:IF BUSY IS ALREADY SET

:	QUEUE UP AN RNR RESPONSE.
FIF060	SBT	RL,XSBUSY
	TBT	RL,PFBIT
	JEFS	FIF070
FIF065	LIS	R2,1
	AHM	R2,SM.D,RL2,
  IF	XOM
	AHM	R2,LKS.1,RL2,		:SAVE FOR XOM LINK STATISTICS
  EI
FIF070	LIS	R2,XMSRNR		:GET SEND RNR INDEX
	STB	R2,XSSTAT,RL		:SET UP COMMAND HANDLER XMIT	LOGIC
	J	RFG210

:	IF BUSY WAS SET, CHECK P BIT OF I FRAME.  IF SET RETURN AN RNR WITH
:	F SET.
FIF080	TBT	RL,PFBIT
	JE	RFG210
	J	FIF065

:	NOTE- NOSTOR FLAG WILL BE RESET WHEN BUSY CLEARS.  ALSO WHEN
:	BUSY CLEARS AND NOSTOR WAS SET THEN A CHECK WILL BE MADE TO SEE
:	IF ANY FRAMES WERE DISCARDED. IF SO THEN AN REJ WILL BE SENT
:	TO CLEAR THE BUSY AND ALSO INFORM OTHER END OF LOST FRAMES
:	INSTEAD OF JUST AN RR.

:	PROCESS SEQUENCE ERRORS
FIF100	TBT	RL,XSBUSY
	JN	FIF110			:IF WE ARE ALREADY BUSY
	SBT	RL,SNTREJ
:	use the new bellcore porcedure of keeping the last N(S) that
:	caused a REJ and send the REJ if this N(S) is equal to or less
:	than the saved N(S) (and updating the saved N(S))
:	the use of the new procedure will eliminate delays if the 
:	retransmission is lost or the REJ is lost.
	JN	RFG210			:IF ALREADY SENT A REJECT :HJR 12-19-86

:	NOW QUEUE UP A REJ RESPONSE
	LIS	R2,XMSREJ		:GET INDEX VALUE FOR FOREGROUND XMIT
	STB	R2,XSSTAT,RL
	TBT	RL,PFBIT
	JNFS	FIF105			:IF P=1
	OOPS(2)
FIF105	LIS	R3,1
	AHM	R3,REJSEQ,RL2,
  IF	XOM
	AHM	R3,LKS.4,RL2,		:SAVE FOR XOM LINK STATISTICS
  EI
	J	RFG210

FIF110	TBT	RL,PFBIT
	JEFS	FIF120
	LIS	R2,XMSRNR		:QUEUE UP AN RNR
	STB	R2,XSSTAT,RL
FIF120	SBT	RL,DSCARD
	J	RFG210


::	OUTFRM-	OUTPUT A QUEUED UP RESPONSE OR COMMAND .
:
:	ENTRY	(R1)= CONTROL FIELD TO USE
:		(R5)= RESPONSE OR COMMAND ADDRESS
:	USES
:	EXIT TO *XSEND*


OUTFRM	TBT	RL,F128.F
	JE	OTF040			:IF NOT MOD128
:	MOD128
	LIS	R2,0
	RBT	RL,PFBIT 		:SEE IF WE HAVE TO SET F BIT
	JEFS	OTF010			:IF NOT
	LIS	R2,CT.2PF		:SET F BIT

OTF010	CLHI	R1,CT.RR
	JEFS	OTF020			:IF N(R) NEEDED
	CLHI	R1,CT.REJ
	JEFS	OTF020			:IF N(R) NEEDED
	CLHI	R1,CT.RNR
	JNFS	OTF030			:IF N(R) NOT NEEDED
OTF020	LB	R6,XVR,RL		:GET CURRENT N(R)
	STB	R6,XTNR,RL		:SAVE LAST XMITTED N(R)
	SLLS	R6,1			:PUT INTO POSITION
	OR	R2,R6			:OR IN F BIT

OTF030	STB	R2,TECVCN,RL		:SAVE IT
	J	OTF060

:	MOD8
OTF040	CLHI	R1,CT.RR
	JEFS	OTF050			:IF N(R) NEEDED
	CLHI	R1,CT.REJ
	JEFS	OTF050			:IF N(R) NEEDED
	CLHI	R1,CT.RNR
	JNFS	OTF060			:IF N(R) NOT NEEDED
OTF050	LB	R2,XVR,RL		:GET CURRENT V(R) VALUE
	STB	R2,XTNR,RL		:UPDATE LAST XMITTED N(R) VALUE
	SLLS	R2,5
	OR	R1,R2			:OR IN N(R) VALUE
OTF060	OHI	R1,CT.NIF		:ADD IN "NOT-I-FRAME" BIT
	RBT	RL,PFBIT		:SEE IF F BIT FLAG SET
	JEFS	OTF070			:IF NOT
	OHI	R1,CT.1PF		:PUT F BIT ON IN RESPONSE
OTF070	STB	R1,TECVCM,RL		:SAVE CTL
	LIS	R3,0
	STH	R3,XBRCHK,RL2		:ZERO OUT CHECKSUM
	LR	R4,R5			:GET ADDRESS
	JAL	R6,FTRCOT,,
	LR	R2,R5			:GET ADDRESS
  IF	BSC
	L	R6,XBUFF		:GET PAGE INDEX
	L	R7,XPOINT		:GET ROTOR POINTER
  EI
	J	XSEND			:GO SEND RESPONSE


  IF	HDLC
::	IIC -	INPUT INFORMATION FRAME AND CHECK.
:		SET *NOSTOR* IF FRAME SIZE EXCEEDS MAXIMUM.
:		PUT PACKET INFO IN RTD RING.
:
:	INPUT	(R9)= NO. OF BYTES IN FRAME
:		R7-> PAST CONTROL OCTETS IN RBUF
:	OUTPUT	SKIP RETURN IF FRAME OK, ELSE NORMAL RETURN
:	LINK	R5


IIC	LB	R1,RSC.SZ,RL,		:RECEIVE SECTOR BUFFER SIZE INDEX
	SLLS	R1,1
	CLH	R9,RSC.LN,R1,		:WILL PACKET FIT IN BUFFER ??
	JGR	R5			:PACKET TOO LONG, ERROR RETURN
	AIS	R5,4			:PREPARE FOR NORMAL RETURN
	SIS	R9,2			:REMOVE ADR AND CTL1 FROM FRAME COUNT
	TBT	RL,F128.F
	JEFS	IIC010			:IF NOT MOD 128
	SIS	R9,1			:REMOVE CTL2 FROM FRAME COUNT
IIC010	LH	R2,RSC.FD,RL2
	JGE	IIC020			:USE DANGLING SECTOR
	LH	R2,RSC.AV,R1		:GET ONE FROM AVAILABLE POOL
	JL	IIC060			:NO MORE, SET NOSTOR
	STH	R2,RSC.FD,RL2		:SAVE DANGLING SECTOR POINTER
	LR	R12,R2			:GO AHEAD AND RESERVE THIS SECTOR
	A	R12,RSC.BF,R1,R1	:ADD BASE FOR ABSOLUTE ADDRESS
	LH	R0,,R12			:GET ITS FORWARD LINK
	STH	R0,RSC.AV,R1		:UPDATE (REMOVE FROM) AVAIL CHAIN
	JGEFS	IIC030			:IF AVAIL NOT YET EMPTY
	STH	R0,RSC.AE,R1		:CLEAR AVAIL END PTR TOO
	JFS	IIC030
IIC020	LR	R12,R2			:SETUP TO USE DANGLING SECTOR
	A	R12,RSC.BF,R1,R1	:ADD BASE FOR ABS ADDRESS
IIC030	STH	R9,2,R12		:PUT IN BYTE COUNT
	LR	R9,R9			:CHECK FOR EMPTY I FRAME
	JG	IIC050			:IF FRAME NOT EMPTY	:DRE 30-JAN-85
	LIS	R0,1
	AHM	R0,EMPTYI,RL2,
  IF	XOM
	AHM	R0,LKS.15,RL2,		:SAVE FOR LINK STATISTICS
  EI
	OOPS
	JR	R5

IIC050	LCS	R0,2			:FORM FFFFFFE IN R0	:DRE 30-JAN-85
	NR	R7,R0			:TRUNCATE ADDRESS IN R7	:DRE 30-JAN-85
	SIS	R9,2-1			:SUB TWO FROM COUNT AND THEN ROUND UP:DRE 30-JAN-85
	TBT	RL,F128.F					:DRE 30-JAN-85
	JEFS	IIC052			:IF NOT MOD 128		:DRE 30-JAN-85
	AIS	R9,1			:ADD CTL2 BACK INTO FRAME COUNT:DRE 30-JAN-85
IIC052	NR	R9,R0			:MAKE HALFWORD ADDRESS	:DRE 30-JAN-85
:	LA	R0,RBUF,R7,R9		:CALC LAST ADDRESS TO TRANSFER:DRE 30-JAN-85
	LA	R0,,R7,R9		:CALC LAST ADDRESS TO TRANSFER:DRE 25-MAR-85
	LA	R1,4,R12,R9		:CALC LAST DEST ADDRESS	:DRE 30-JAN-85
	SLLS	R9,3			:CONVERT TO HW TIMES 10x:DRE 30-JAN-85
	COPY	R0,R9			:PERFORM MICROCODE COPY	:DRE 30-JAN-85
	JR	R5

:	WE HAVEN'T ENOUGH SECTORS TO HANDLE THIS FRAME.
:	SET (NOSTOR) AND DO NORMAL RETURN.
:	*FIF* ROUTINE WILL HANDLE IT.
IIC060	SBT	RL,NOSTOR
	LIS	R12,1
	AHM	R12,SM.E1,RL2,
  IF	XOM
	AHM	R12,LKS.11,RL2,		:SAVE FOR XOM LINK STATISTICS
  EI
	JR	R5

  ELSE	BSC
::	IIC -	INPUT INFO FRAME AND CHECK FOR GOOD CHKSUM.
:		(BISYNC VERSION)
:		ALSO CHECKS TO SEE IF MAX FRAME SIZE IS EXCEEDED AND IF
:		A 'DLE' IS NOT FOLLOWED BY A 'DLE', 'STX', 'ETX', OR 'EOT'
:
:	LINK IS R5

IIC	ST	R5,RQRET,RL2,RL2	:SAVE RETURN ADDRESS TO CALLER
	LCS	R7,2			:SUBTRACT FRAME HEADER (MOD8)
	TBT	RL,F128.F
	JEFS	IIC005			:IF MODE 8
	LCS	R7,3			:SUBTRACT FRAME HEADER (MOD128)
IIC005	AH	R7,MFS.LT,RL2,
	STH	R7,XPCNT,RL2		:SAVE MAX PACKET COUNT
	LB	R5,RSC.SZ,RL,		:RELATIVE BUFFER SIZE (MAX)
	SLLS	R5,1
	LH	R7,RSC.FD,RL2		:IS THERE A DANGLING SECTOR LEFTOVER ??
	JGE	IIC030			:YES, USE IT
	LH	R7,RSC.AV,R5		:NO, ALLOCATE ONE
	JGEFS	IIC010			:OK, GOT IT
	JAL	R6,XSINER		:NO MORE, SET NOSTOR
	J	IIC040			:SKIP CHAIN MAINTAINANCE
IIC010	STH	R7,RSC.FD,RL2		:SAVE DANGLING SECTOR POINTER
	LR	R2,R7			:GO AHEAD AND RESERVE THIS SECTOR
	A	R2,RSC.BF,R5,R5		:ADD BASE ADDRESS FOR ABS ADDR
	LH	R2,,R2			:GET ITS FORWARD LINK
	STH	R2,RSC.AV,R5		:UPDATE (REMOVE FROM) AVAIL CHAIN
	JGEFS	IIC030			:JUMP IF AVAIL NOT YET EMPTY
	STH	R2,RSC.AE,R5		:OTHERWISE CLEAR AVAIL END PTR
IIC030	A	R7,RSC.BF,R5,R5		:SETUP TO USE DANGLING SECTOR
	AIS	R7,4			:ALLOW FOR LINK(2) AND BYTE COUNT(2)
	ST	R7,NXTIN,RL2,RL2	:SAVE FILL PTR
IIC040	JAL	R5,BVCHAR		:GET CHAR. FROM ISIS RING
	J	XSYEXI			:RETURN HERE AND EXIT IF NO MORE CHARS.

	CLHI	R2,DLE			:SEE IF A DLE
	JNFS	IIC050			:IF NOT
	JAL	R5,BVCHAR		:GET CHAR FOLLOWING DLE
	J	XSYEXI

	CLHI	R2,DLE			:CHECK IF ANOTHER DLE
	JEFS	IIC050			:IF CHAR PAIR ARE DLE/DLE
	CLHI	R2,SYN
	JE	IIC040
	J	IIC080			:IF NOT (PROBABLY AN ETX.)


IIC050	JAL	R5,ICHKSM		:CHECKSUM CHAR
	TBT	RL,NOSTOR		:SEE IF NOT TO STORE DATA IN RTD RING
	JNFS	IIC070			:IF NOT STORING

:	NOW PUT DATA INTO RTD RECEIVE RING
	L	R2,NXTIN,RL2,RL2	:GET INPUT POINTER
	STB	R0,,R2			:STORE BYTE
	AIS	R2,1			:INCREMENT POINTER
	ST	R2,NXTIN,RL2,RL2
IIC070	LCS	R5,1
	AHM	R5,XPCNT,RL2		:DECREMENT MAX FRAME BYTE COUNT
	JG	IIC040			:IF HAVE NOT REACHED MAX BBYTE COUNT
	L	R5,RQRET,RL2,RL2
	JR	R5			:ERROR JUMP, IF MAX BYTE CNT EXCEEDED


:	HAD A DLE FOLLOWED BY A CHAR. OTHER THEN A DLE. PROCESS THIS CHAR.
IIC080	CLHI	R2,ETX			:SEE IF AN ETX CHAR.
	JN	RFER10			:IF NOT TO PROCESS ERROR
	JAL	R5,ICHKSM		:CHKSUM ETX (DLE BEFORE ETX IS NOT CHKSMMED)
:	NOW COMPUTE FINAL CKSUM AND COMPARE AGAINST ONE RECEIVE.
	JAL	R6,CKFNAL
:	RETURN BACK HERE IF CHKSUM GOOD.
	L	R5,RQRET,RL2,RL2
	AIS	R5,4
	JR	R5			:RETURN TO CALLER WITH GOOD JUMP
  EI	BSC


::	SENDFR-	SEND A FRMR/ CMDR.
:
:	INPUT	(R0)= WXYZ BIT VALUE
:	USES	R2,R5,R6
:		XVS,XVR, RECVCM,RECVCN,
:	EXIT	XCMDA1, XCMDA2, XCMDA3,XCMDA4 SET FOR *OUTFRM*
:	LINK IS R6

SENDFR	STB	R0,WXYZBT
	LB	R5,RECVCM,RL		:GET CONTROL FIELD
	TBT	RL,F128.F
	JE	SFR030			:IF NOT MOD128
	STB	R5,XCMDA1,RL		:SAVE REJECTED COMMAND CONTROL FIELD
	LB	R5,RECVCN,RL		:GET SECOND BYTE OF CONTROL
  IF	LAPB
	TBT	RL,PFBIT
	JEFS	SFR010			:IF P/F BIT WAS NOT SET
	OHI	R5,CT.2PF		:PUT IT BACK
SFR010	HS
  EI	LAPB
	STB	R5,XCMDA2,RL
	LB	R5,XVS,RL		:GET CURRENT V(S)
	SLLS	R5,1			:PUT INTO PROPER POSITION
	STB	R5,XCMDA3,RL
	LB	R5,XVR,RL
	SLLS	R5,1
  IF	LAPB
	LIS	R2,0			:INIT CR BIT TO 0
	TBT	RL,CRBIT
	JNFS	SFR020			:IF IT WAS A COMMAND FRAME
	LIS	R2,FR.2CR		:ADD IN CR BIT FOR RESPONSE FRAME
SFR020	OR	R5,R2
  EI	LAPB
	STB	R5,XCMDA4,RL
	LB	R5,WXYZBT		:GET LAST BYTE
	STB	R5,XCMDA5,RL
	J	SFR060

SFR030	HS
  IF	LAPB
	TBT	RL,PFBIT
	JEFS	SFR040			:IF P/F BIT WAS NOT SET
	OHI	R5,CT.1PF		:PUT IT BACK
SFR040	HS
  EI	LAPB
	STB	R5,XCMDA1,RL		:SAVE REJECTED COMMAND CONTROL FIELD
	LB	R5,XVR,RL		:GET CURRENT N(R)
	SLLS	R5,5			:PUT INTO POSITION
	LB	R2,XVS,RL		:GET CURRENT N(S)
	SLLS	R2,1			:PUT INTO POSITION
	OR	R5,R2			:FORM SECOND OCTET OF FRMR DATA
  IF	LAPB
	LIS	R2,0			:INIT CR BIT TO 0
	TBT	RL,CRBIT
	JNFS	SFR050			:IF IT WAS A COMMAND FRAME
	LHI	R2,FR.1CR		:SET CR BIT FOR RESPONSE FRAME
SFR050	OR	R5,R2
  EI	LAPB
	STB	R5,XCMDA2,RL		:SAVE IT
	LB	R5,WXYZBT
	STB	R5,XCMDA3,RL
SFR060	LB	R5,SECST,RL		:GET STATE		:DRE 2-MAY-86
  IF	LAPB
	CLHI	R5,SECINF		:INFO STATE?		:DRE 2-MAY-86
	JEFS	SFR070			:YES, ENTER FRAME/COMMAND REJECT STATE :DRE 2-MAY-86
	CLHI	R5,PTRECV		:RECOVERY STATE?	:DRE 2-MAY-86
	JNFS	SFR080			:SKIP THIS STUFF	:DRE 2-MAY-86	LIS	R5,PRFRMR		:GET FRAME REJECT STATE
SFR070	LIS	R5,PRFRMR					:DRE 2-MAY-86
	STB	R5,PRIST,RL		:SAVE IT
	SBT	RL,T1TA.F		:TURN ON T1 TIMER
	RBT	RL,T1TO.F
  ELSE	LAP
	CLHI	R5,SECINF		:INFO STATE?		:DRE 2-MAY-86
	JNFS	SFR080			:NO, DON'T ENTER COMMAND REJECT STATE :DRE 2-MAY-86
	LIS	R5,SECMDR
	STB	R5,SECST,RL		:PUT SECONDARY STATION IN COMMAND REJECT COMDITION
  EI	LAP
SFR080	LIS	R5,XMSCMD		:GET XMIT FRMR/ CMDR INDEX :DRE 2-MAY-86
	STB	R5,XSSTAT,RL		:MARK SECONDARY TRANSMIT :HJR 12-11-86
	JR	R6			:RETURN			:LSH 16-APR-87
  EI	LAPB!LAP
	SSTTL(BISYNC INPUT SUBROUTINES)


  IF	LAP&BSC
::	XSINER-	ERROR ROUTINE FOR OVERWRITING DATA IN RTD RING.
:
:	USES	R6,RL,R12
:	LINK IS R6
XSINER	SBT	RL,NOSTOR		:SET FLAG SAYING NOT TO STORE DATA IN RTD RING
	LIS	R12,1
	AHM	R12,SM.E1,RL2,
  IF	XOM
	AHM	R12,LKS.11,RL2,	:SAVE FOR XOM LINK STATISTICS
  EI
	JR	R6


::	ICHKSM-	FOREGROUND RECEIVE CHECKSUM ROUTINE
:
:	INPUT	(R2)= CHAR TO BE CHECKSUMED
:	OUTPUT
:	USES	R2-R5
:	LINK IS R5

ICHKSM	LH	R3,IBCRCT,RL2		:GET PARTIAL CHECKSUM
	EXBR	R3,R3
	LBR	R4,R3
	STBR	R2,R3
	XH	R3,CRCTBL,R4,R4		:XOR CRC TABLE
	STH	R3,IBCRCT,RL2		:SAVE PARTIAL CHECKSUM
	JR	R5			:RETURN TO CALLER


::	CKFNAL-	COMPUTE FINAL CHECKSUM AND COMPARE AGAINST ONE
:		RECEIVED.
:
:	INPUT
:	OUTPUT
:	USES	R2-R6
:	LINK IS R6

CKFNAL	ST	R6,CKRET,RL2,RL2	:SAVE RETURN ADDRESS
	LIS	R2,0
	JAL	R5,ICHKSM		:FINISH OFF CHECKSUM
	JAL	R5,ICHKSM

	JAL	R5,BVCHAR		:GET FIRST BYTE OF CRC
	J	XSYEXI
	CLB	R2,IBCRCT,RL2		:SEE IF EQUAL
	JN	XSYER6			:IF NOT CHECKSUM ERROR
	JAL	R5,BVCHAR		:GET SECOND BYTE OF CRC
	J	XSYEXI
	CLB	R2,IBCRCT+1,RL2		:CHECK SECOND BYTE
	JN	XSYER6			:CHECKSUM ERROR
	L	R6,CKRET,RL2,RL2	:GET RETURN ADDRESS
	JR	R6


::	FNDSYN-	FIND BEGINNING OF A BYSINC FRAME.
:
:	The sync receive buffer contains all bits received from the line
:	including marking state.  Characters in the buffer do not necessarily
:	start on a byte boundary.  Therefore it is necessary to search the
:	buffer for a syncing character which could start anywhere in a byte
:	and continue into the next byte.  At this point the bit position of
:	all remaining bytes in a frame will be known.  It would not be
:	efficient to just keep shifting the buffer by one character to test
:	for a SYN character so a different method is used.
:	The bits are shifted 4 bits at a time until at least 5 bits of
:	the SYN character appear in a memory byte.  This is determined
:	by using the memory byte value to test the SYFLG 256 bit array.
:	If a possible SYN is found the last bits (2 for ebcdic, 3 for ascii)
:	of the byte are concatenated with the first 3 bits of the next
:	memory byte to index SYTAB to find the shift index.  If a shift
:	index is not found then this is not a SYN character.
:	For example, the ebcdic SYN character is 01001100.
:	If the current byte contains six bits of the SYN character
:	it would look like xx010011 where xx has 4 possible values from 00 to 11.
:	SYFLG would have a bit on for each possible value of xx (10010011=bit
:	93h for example).  This would indicate that this byte contained the
:	beginning of a possible SYN.  The last 2 bits 11 of the byte is
:	concatenated with the next 3 bits of the next byte which is
:	00xyyyyy where x is 0 or 1 and yyyy is any pattern.  We now have the
:	value 1100x which is 11000 or 11001. Entry 18 and 19 of SYTAB
:	each contain the shift value of 3.  If only 5 bits of SYN
:	were in the first byte then all 3 bits of the next byte would be
:	significant instead of two and the two bytes would be
:	xxx01001/100xxxxx and entry 01100 (0C) would contain the shift
:	count of 4.  Note that the shift count is one more than the
:	number of bit positions the pattern needs to be shifted left.
:
:	INPUT
:	OUTPUT
:	USES
:	LINK IS R5



  IF	BSCEBC
SYFLG	WC	00401000,02400000,00481000,00400000
	WC	00401000,02400000,00401000,00400000

SYTAB	BC	1,1,1,1,1,1,1,1,0,0,0,0,4,0,0,0
	BC	2,2,2,2,0,0,0,0,3,3,0,0,0,0,0,0

  ELSE	BSCASC		:IF ASCII CONTROL CHARS
SYFLG	WC	00040020,00040800,00040020,00840000
	WC	00040020,00040800,00040020,00040000

SYTAB	BC	1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0
	BC	3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	BC	2,2,2,2,0,0,0,0,4,0,0,0,0,0,0,0
  EI	BSCASC


FNDSYN	LCS	R0,1			:INITIALIZE LAST DATA BYTE
	STB	R0,BVLSDT,RL

FSY010	CLR	RTP,RLP			:SEE IF TRAILING PTR AND LEAD ARE EQUAL
	JNFS	FSY020			:IF TRAILING PTR AND LEAD PTR ARE NOT EUQAL
	STH	RTP,YTP,RL2
	JR	R5			:RETURN

FSY020	LHL	R3,RBUF,RBA,RTP		:GET WORD
	AIS	RTP,2			:INCREMENT TRAILING PTR
	CLHI	RTP,BNTLN		:SEE IF AT END OF RING
	JNFS	FSY030
	SHI	RTP,BNTLN
FSY030	CLI	R3,0FFFF		:CHECK IF WORD ALL ONES
	JE	FSY010			:IF SO
	LB	R2,BVLSDT,RL		:LAST DATA BYTE TO LEFT HW
	STB	R3,BVLSDT,RL		:SAVE LAST DATA BYTE
	EXHR	R0,R2			:AND TO LEFT HW OF R0
	AR	R0,R3			:THREE GOOD BYTES IN R0
	TBT	R2,SYFLG		:BIT ARRAY TELLS IF PATTERN MAY...
	JN	FSY110			:START IN THIS BYTE
FSY040	SLLS	R0,4			:NO, TRY THE NEXT HALF-BYTE
	EXHR	R2,R0
	LBR	R2,R2
	TBT	R2,SYFLG
	JEFS	FSY050
	LIS	R3,3
	LA	R6,FSY050
	J	FSY120

FSY050	SLLS	R0,4			:TRY NEXT BYTE - FIRST ONE HALF-BYTE...
	EXHR	R2,R0
	LBR	R2,R2
	TBT	R2,SYFLG
	JEFS	FSY060
	LCS	R3,1
	LA	R6,FSY060
	JFS	FSY080

FSY060	SLLS	R0,4			:THEN THE OTHER
	EXHR	R2,R0
	LBR	R2,R2
	TBT	R2,SYFLG
	JE	FSY010

	LIS	R3,3
	LA	R6,FSY010
FSY080	RBT	RL,BVHOB		:NEXT CHAR IS IN LO-ORD BYTE

FSY090	LR	R2,R0			:3 BITS FOLLOWING CHAR WILL TELL IF...
	SLLS	R2,3			:WE HAVE IT AND YIELD SHIFT COUNT
	EXHR	R2,R2
  IF	BSCEBC
	NHI	R2,1F
  ELSE	BSCASC
	NHI	R2,3F
  EI
	LB	R4,SYTAB,R2
	LR	R4,R4
	JER	R6			:AIN'T GOT IT, RETRY

	AR	R3,R4			:WE'VE GOT IT - COMPUTE SHIFT COUNT
	STB	R3,BVSHFT,RL		:AND SAVE IT FOR LATER
	STH	RTP,YTP,RL2		:DON'T FORGET TO SAVE THE OUTPUT PTR
	LHI	R0,SYN			:INIT BVCHAR  (SYN)
	STB	R0,BVLSCH,RL
	AIS	R5,4
	JR	R5

FSY110	LCS	R3,1			:POSSIBLE SYN IN LEFT HALF-BYTE
	LA	R6,FSY040
FSY120	SBT	RL,BVHOB		:NEXT CHAR IS IN HI-ORDER BYTE
	J	FSY090


::	BVCHAR-	GET NEXT CHARACTER FROM A SYNC INPUT FRAME.
:		PARAMTERS ARE INITIALIZED BY *FNDSYN*
:
:	OUTPUT	NORMAL RETURN SKIPS 4 BYTES.
:		TAKES IMMEDIATE RETURN IF THERE ARE NO MORE CHARS.
:		(R2)=NEXT RECEIVED CHARACTER
:		(R0)=CHARACTER INVERTED
:	USES
:	LINK IS R5

BVCHAR	CLR	RTP,RLP			:SEE IF LEAD AND TRAILING PTRS ARE EUAL
	JER	R5
	CBT	RL,BVHOB		:IS NEXT CHAR IN HI-ORDER BYTE OF DATA?
	JE	BVCH2			:NO
	LB	R2,BVLSCH,RL		:YUP, SO WE ALREADY HAVE IT
	LB	R0,TCHINV,R2,
	AIS	R5,4
	J	STRCIN,,		:GO TO TRACE LOGIC

BVCH2	LHL	R3,RBUF,RBA,RTP		:GET HALFWORD
	AIS	RTP,2			:INC PTR
	CLHI	RTP,BNTLN
	JNFS	BVCH3
	SHI	RTP,BNTLN
BVCH3	STH	RTP,YTP,RL2		:AND REPLACE IT
	LB	R2,BVLSDT,RL		:GET 3 BYTES IN R0
	STB	R3,BVLSDT,RL
	EXHR	R0,R2
	AR	R0,R3
	LB	R3,BVSHFT,RL
	SLL	R0,,R3			:JUSTIFY CHARACTERS
	EXBR	R0,R0
	STB	R0,BVLSCH,RL		:SAVE THIS, IT'S FOLLOWING CHAR
	EXHR	R2,R0
	LBR	R2,R2
	LB	R0,TCHINV,R2,
	AIS	R5,4
	J	STRCIN,,

  EI	LAP&BSC		:END BYSINC RECEIVE LOGIC
	SSTTL(SIO OUTPUT)

  IF	HDLC&(LAPB!LAP)

::	XROOM-	ROOM CHECKING ROUTINE, HDLC VERSION
:
:	INPUT
:	OUTPUT
:	USES
:	LINK IS R5

::	XROOM - CLEAN UP COMPLETED SIO COMMANDS, CHECK FOR ROOM
:		FOR MORE.
:	INPUT
:	OUTPUT
:	USES
:	LINK IS R5

XROOM	LB	RSIP,PSTPAG,RL		:OLDEST ENTRY POINTER
	TS	SIOACT			:IS SIO ACTIVE			ERB-041286
	JN	XROOM8			:YES				ERB-041286 :DRE 30-DEC-86
XROOM1	CLB	RSIP,PREPAG,RL		:NEXT FREE ENTRY POINTER :DRE 30-DEC-86
	JE	XROOM6			:PLENTY OF ROOM
	LR	R4,RSIP			:COPY TO USE AS OFFSET
	SLLS	R4,4			:OUT CMD (4), JMP CMD(4), SKIPPED(8)
	LHL	R3,TCCWL,R4,RSIO	:LOOK AT OLDEST ENTRY
	JEFS	XROOM2			:IF DONE (NO COMMAND THERE)
	CLHI	R3,100			:DID IF COMPLETE AND JUMP ?
	JN	XROOM3			:IF NOT

:	OLDEST COMMAND IS DONE.  CLEAN IT UP AND CHECK NEXT ONE.

XROOM2	LIS	R0,0
	ST	R0,TCCWL,R4,RSIO	:CLEAR ITS COMMAND AND QUAD 4 ADDRESS
	STH	R0,TCCWL+4,R4,RSIO	:CLEAR ITS JUMP COMMAND TOO
	LCS	R0,1
	AHM	R0,XROOMC,RL2		:DECREMENT NUMBER OF COMMANDS SETUP
	AIS	RSIP,1			:STEP TO NEXT ONE
	NH	RSIP,K.MSK,RL2,		:FOLD IF NECESSARY
	STB	RSIP,PSTPAG,RL		:SAVE OLDEST ENTRY
	J	XROOM1			:SEE IF IT IS DONE TOO

:	COMMAND NOT FINISHED, EITHER STILL EXECUTING OR HALTED.
:	IF STILL EXECUTING JUST CHECK FOR AVAILABLE ROOM.

XROOM3	CLHI	R3,200			:CHECK FOR STOPPED
	JEFS	XROOM4			:IF SO
	LHL	R3,XROOMC,RL2		:CURRENT ACTIVE COMMAND COUNT
	CLH	R3,K.MSK,RL2,		:MAX ALLOWED, DON'T CLOSE AROUND
	JL	XROOM6			:IF ROOM FOR MORE
	J	XROOM7			:ELSE TAKE NO ROOM RETURN :DRE 30-DEC-86

:	THIS ONE HALTED. IF THERE IS ANOTHER FOLLOWING IT THEN RE-ISSUE
:	ITS SVC.  IF NOT THEN WE ARE CAUGHT UP.

XROOM4	LIS	R0,0
	ST	R0,TCCWL,R4,RSIO	:FIRST CLEAN UP THIS ONE
	STH	R0,TCCWL+4,R4,RSIO
	LCS	R0,1
	AHM	R0,XROOMC,RL2		:DECREMENT ACTIVE COMMAND COUNT
	AIS	RSIP,1			:STEP TO NEXT ONE
	NH	RSIP,K.MSK,RL2,		:FOLD IF NECESSARY
	STB	RSIP,PSTPAG,RL		:SAVE OLDEST ENTRY POINTER
	CLB	RSIP,PREPAG,RL		:COMPARE TO NEXT FREE SLOT
	JE	XROOM6			:PLENTY OF ROOM
	LB	R0,SI.INT,RSIO		:GET INTERRUPT STATUS	:DRE 11-MAR-86
	JN	XROOM7			:DON'T DO IO, WAIT FOR BACKGROUND TO FIX :DRE 11-MAR-86 :DRE 30-DEC-86
	SLLS	RSIP,4			:CONVERT TO TCCWL OFFSET
	LR	R4,RSIO			:SIO AREA BASE ADDRESS
	AHI	R4,TCCWL,RSIP		:ADDRESS OF NEXT COMMAND
	LB	R3,SLU.LT,RL,		:DO LOGICAL UNIT CONVERSION
	SVC	IO,(FMBOT.^4)+R3	:START IT UP
	J	TXRERR			:IF SVC FAILED
	LIS	R0,1			:COUNT THESE
	AHM	R0,T2ERR,,		:COUNT OF JUMP CONFLICTS IN ROTOR
XROOM7	LIS	R0,0			:INDICATE SIO NOT ACTIVE	ERB-041286
	STH	R0,SIOACT		:				ERB-041286
XROOM8	LIS	R0,1						:DRE 30-DEC-86
	AHM	R0,NOROOM,RL2,		:COUNT FAILURES
	JR	R5			:TAKE NO-ROOM RETURN

XROOM6	LIS	R0,0			:INDICATE SIO NOT ACTIVE	ERB-041286
	STH	R0,SIOACT		:				ERB-041286
	LB	RSIP,PREPAG,RL		:NEXT FREE ENTRY POINTER
	SLLS	RSIP,4			:EXIT WITH THIS SET
	J	4,R5			:TAKE ROOMY RETURN


::	XSEND-	TRANSMIT A RESPONSE OR COMMAND OTHER THAN AN I-FRAME.
:
:	INPUT	R1=CONTROL FIELD
:		R2=ADDRESS BYTE
:		R5=USED FOR BYTE COUNT
:	USES
:	EXIT TO XBTERM

XSEND	HS
  IF	FINACT			:IF INTERFRAME FILL TIMER ENABLED
	SBT	RL,FRMTMT		:INDICATE FRAME TRANSMITTED
  EI
	LR	R6,RSIO
:............................................................
:	change reference of OUTSCT to NIOSOF because XMIT CMD LIST(TCCLn)
:	has variable length . (FML not changed)
:	AHI	R6,OUTSCT,RSIP
	LHL	R5,NIOSOF,RSIO		:GET OFFSET TO NON-IFRAME OUTPUT
					: SECTOR AREA.
	AR	R6,R5			:ADD AS BEFORE
	AR	R6,RSIP
:............................................................
	STB	R2,2,R6 		:SAVE ADDRESS BYTE
	LIS	R5,1
	TBT	RL,F128.F
	JE	XSE010			:IF NOT MOD128
	LB	R2,TECVCM,RL		:GET CONTROL BYTE
	STB	R2,3,R6
	LB	R2,TECVCN,RL		:GET SECOND BYTE
	STB	R2,4,R6
	AIS	R5,2
	LB	R1,TECVCM,RL
	CLHI	R1,CT.FR+CT.NIF		:IS RESPONSE AN FRMR
	JN	XBTERM
	AIS	R6,1			:BIAS FOR REMAINING FIELDS
	JFS	XSE020

XSE010	STB	R1,3,R6
	AIS	R5,1
	LR	R2,R1
	NHI	R2,@CT.1PF		:MASK OFF F BIT
	CLHI	R2,CT.FR+CT.NIF		:IS CONTROL FIELD A CMDR
	JN	XBTERM			:IF NOT TO TERMINATE ROTOR ENTRY

:	SET UP INFO FIELD OF CMDR,
XSE020	LB	R2,XCMDA1,RL		:GET FIRST OCTET
	STB	R2,4,R6
	LB	R2,XCMDA2,RL		:GET SECOND BYTE
	STB	R2,5,R6
	LB	R2,XCMDA3,RL		:GET THIRD BYTE
	STB	R2,6,R6
	AIS	R5,3
	TBT	RL,F128.F
	JE	XBTERM			:IF NOT MOD128
	LB	R2,XCMDA4,RL
	STB	R2,7,R6
	LB	R2,XCMDA5,RL
	STB	R2,8,R6
	AIS	R5,2
	SIS	R6,1			:RESTORE R6
	J	XBTERM			:TERMINATE ENTRY IN ROTOR


:	INFTRM-	FINISH UP AN OUTPUT SECTOR FOR TRANSMISSION.
:		COMPUTES FINAL CHECKSUM AND ENTERS ENTRY INTO OUTPUT LIST.
:
:	ENTRY	ALSO THROUGH XBTERM
:	INPUT	R1=CONTROL FIELD. (1ST CONTROL BYTE)
:		R5=INDEX INTO SECTOR POINTERS
:		(TECVCM)= 1ST CONTROL BYTE
:		(TECVCN)= 2ND CONTROL BYTE
:	USES
:	LINK IS R0

INFTRM	HS
  IF	FINACT			:IF INTERFRAM FILL TIMER ENABLED
	SBT	RL,FRMTMT		:INDICATE FRAME TRANSMITTED
  EI
	LB	R4,PADRT,RL,		:SET UP COMMAND ADDRESS
	JAL	R6,FTRCOT,,
	L	R6,SECADR,R5,R5
	LR	R7,R6			:PUT A COPY IN REG 7
	TBT	RL,F128.F
	JEFS	INF010			:IF NOT MOD 128
	LB	R2,TECVCN,RL		:GET SECOND CONTROL BYTE
	STB	R2,4,R6
INF010	STB	R1,3,R6
	LB	R2,PADRT,RL,		:SET UP COMMAND ADDRESS
	STB	R2,2,R6
	LHL	R5,BYTCNT,R5		:BYTE COUNT

:	ENTRY:	XBTERM

XBTERM	TS	SIOACT			:IS SIO ACTIVE			ERB-041286
	JEFS	XBT010			:NO				ERB-041286
	SVC	DISMIS,0		:WAIT ONE CYCLE			ERB-041286
	JBS	XBTERM			:				ERB-041286
XBT010	STH	R5,,R6			:STORE BYTE COUNT
	LR	R4,R6
	LB	R7,PREPAG,RL		:GET CURRENT COMMAND INDEX
	LR	RSIP,R7
	SLLS	RSIP,4			:MAKE OFFSET INTO TCCWL
	LIS	R5,1
	STH	R5,TCCWL,RSIP,RSIO	:PUT IN A WRITE COMMAND
	SRLS	R4,4			:FORM QUAD WORD FROM BUFFER ADDRESS
	STH	R4,TCCWL+2,RSIP,RSIO	:FOLLOWS WRITE COMMAND
	SIS	R7,1			:FORM PREVIOUS ENTRY
	NH	R7,K.MSK,RL2,		:FOLD IF NECESSARY
	SLLS	R7,4			:MAKE OFFSET INTO TCCWL
	AR	R7,RSIO			:TO THIS LINES AREA
	LHL	R4,TCCWL,R7		:GET PREVIOUS COMMAND
	CLHI	R4,1			:STILL A WRITE ??
	JN	TXROM1			:IF NOT

:	PREVIOUS ENTRY STILL BUSY XMITTING. TACK ON A JUMP TO THIS ONE.
	LIS	R4,2
	STH	R4,TCCWL+4,R7		:STORE JUMP COMMAND
	LHL	R4,TCCWL,R7		:MAKE SURE PREVIOUS COMMAND DID NOT FINISH
					:BEFORE JUMP GOT STORED.
	CLHI	R4,0200			:COMPARE TO STOPPED STATUS
	JN	TXROMX			:IF DID NOT STOP
	LIS	R4,1						:DRE 11-MAR-86
	AHM	R4,T2ERR,,		:COUNT THIS PROBLEM	:DRE 11-MAR-86

TXROM1	LIS	R4,0			:IF IT JUMPED OR STOPPED :DRE 11-MAR-86
	STH	R4,TCCWL,R7		:CLEAR ITS COMMAND FIELD
	STH	R4,TCCWL+4,R7		:CLEAR ITS JUMP COMMAND

:	ISSUE SVC FOR OUTPUT.
	LR	R4,RSIO			:GET SIO TABLE BASE ADDRESS
	AHI	R4,TCCWL,RSIP		:FORM ENTRY ADDRESS
	LB	R3,SLU.LT,RL,		:GET TRUE LINE# FROM LU
	SVC	IO,(FMBOT.^4)+R3	:ISSUE SVC
	J	TXRERR			:IF SVC FAILED
TXROMX	LB	R4,PREPAG,RL		:GET CURRENT PAGE POINTER
	AIS	R4,1			:STEP TO NEXT ONE
	NH	R4,K.MSK,RL2,		:FOLD IF NECESSARY
	STB	R4,PREPAG,RL		:SAVE AS NEXT FREE COMMAND PTR
	LIS	R4,1
	AHM	R4,XROOMC,RL2
	LIS	R4,0			:INDICATE SIO NOT ACTIVE	ERB-041286
	STH	R4,SIOACT		:				ERB-041286
	JR	R0

TXRERR	TRAP(R3,E4)		:SIO OUTPUT SVC ERROR
  EI	HDLC&(LAPB!LAP)
	SSTTL(SYNC OUTPUT)


  IF	BSC		:IF BISYNC
::	XROOM-	SEE IF AN OUTPUT LIST ENTRY IS EMPTY INROTOR.
:
:	USES
:	RETURN	TO *TFG100* IF NO ROOM TO CHECK NEXT LINE.
:	LINK IS R5

XROOM	L	R4,XQNEXT,RL2,RL2	:GET WHICH ROUTINE TO START WITH
	JR	R4			:GO TO IT

XROOM0	TBT	RL,XQFLG1,,		:SEE IF FIRST OUTPUT LIST ENTRY AVAIL.
:	JE	XROOM1			:IF NOT TO CHECK SECOND ENTRY
	JE	XROOM3			:IF NOT  
	LA	R6,XROOM1		:GET ADDRESS OF NEXT ENTRY TO USE
	ST	R6,XQNEXX,,		:SAVE FOR LATER
	LA	R6,XQFLG1,,
	ST	R6,XQFLAG,,		:SAVE ADDRESS OF FLAG WORD FOR LATER
	L	R6,OUTBF1,RL2,RL2	:GET OUTPUT BUFFER ADDRESS
	L	R7,XROTO1,RL2,RL2	:GET ROTOR POINTER
	ST	R6,XBUFF		:SAVE OUTPUT BUFFER ADDRESS
	ST	R7,XPOINT		:SAVE ROTOR POINTER
	LIS	R3,05
	STH	R3,8,R7			:RESTORE SET FLAG OPERATOR IN OUTPUT LIST
	JR	R5			:RETURN TO CALLER

XROOM1	TBT	RL,XQFLG2,,		:SEE IF SECOND ENTRY AVAILABLE
:	JE	XROOM2			:IF NOT
	JE	XROOM3			:IF NOT
	LA	R6,XROOM2		:GET NEXT ENTRY TO USE
	ST	R6,XQNEXX,,
	LA	R6,XQFLG2,,		:GET FLAG WORD ADDRESS
	ST	R6,XQFLAG,,
	L	R6,OUTBF2,RL2,RL2
	L	R7,XROTO2,RL2,RL2
	ST	R6,XBUFF
	ST	R7,XPOINT
	LIS	R3,05
	STH	R3,8,R7
	JR	R5

XROOM2	TBT	RL,XQFLG3,,		:SEE IF ROOM IN THIRD ENTRY
	JE	XROOM3
	LA	R6,XROOM0
	ST	R6,XQNEXX,,
	LA	R6,XQFLG3,,		:GET ADDRESS OF FLAG WORD
	ST	R6,XQFLAG,,		:SAVE FOR LATER
	L	R6,OUTBF3,RL2,RL2	:GET OUTPUT BUFFER ADDRESS
	ST	R6,XBUFF		:SAVE FOR LATER
	L	R7,XROTO3,RL2,RL2	:GET ROTOR ADDRESS
	ST	R7,XPOINT		:SAVE FOR LATER
	LIS	R3,05
	STH	R3,8,R7			:RESTORE SET FLAG OPERATOR
	LIS	R3,2
	STH	R3,10,R7		:RESTORE TRANSFER OPERATOR
	JR	R5

XROOM3	LIS	R5,1
	AHM	R5,NOROOM,RL2,		:INCREMENT FOUND NO ROOM WHEN ASKED BY FOREGROUND
	J	TFG100			:GO CHECK NEXT LINE


::	XSEND-	FRAME TRANSMIT ROUTINE, BISYNC VERSION.
:		(TRANSMIT ALL FRAMES EXCEPT I-FRAME)
:
:	INPUT	R1=CONTROL FIELD
:		R2=ADDRESS BYTE
:		R6=OUTPUT BUFFER ADDRESS
:		R7=ROTOR POINTER
:		R5=USED FOR BYTE COUNT
:	USES
:	EXIT	THROUGH *XBTERM*

XSEND	HS
  IF	FINACT
	SBT	RL,FRMTMT		:INDICATE FRAME TRANSMITTED
  EI
	LIS	R5,0
	AIS	R6,6			:FORM STARTING ADDR IN BUFFER PAST SYN'S AND DLE/STX
	AIS	R5,6			:REG 5 NOW HAS PROPER INITIAL BYTE COUNT
	JAL	R4,XQSTOR		:GO STORE ADDRESS BYTE
	LR	R2,R1			:GET CONTROL FIELD INTO REG 2
	JAL	R4,XQSTOR		:GO STORE IT
	NHI	R2,0F7			:MASK OFF F BIT (XQSTOR REVERSED THE BITS)
	CLHI	R2,0E1			:IS CONTROL FIELD A CMDR
	JN	XBTERM			:IF NOT TO TERMINATE ROTOR ENTRY

:	SET UP INFO FIELD OF CMDR, OCTETS ARE ALREADY REVERSED.
	LB	R2,XCMDA1,RL		:GET FIRST OCTET
	JAL	R4,XQSTOR		:GO STORE IT
	LB	R2,XCMDA2,RL		:GET SECOND BYTE
	JAL	R4,XQSTOR
	LB	R2,XCMDA3,RL		:GET THIRD BYTE
	JAL	R4,XQSTOR
	J	XBTERM			:TERMINATE ENTRY IN ROTOR


:	XQSTOR-	STORE A RESPONSE OR COMMAND OTHER THEN AN I-FRAME INTO
:		OUTPUT BUFFER.
:	INPUT	R2=CHAR TO STORE
:		R5=BYTE COUNT
:		R6=BUFFER ADDRESS
:		R4=RETURN ADDRESS
:	USES

XQSTOR	LB	R2,TCHINV,R2,
	CLHI	R2,DLE			:SEE IF CHAR=DLE
	JNFS	XQSTR1
	AIS	R5,1			:INCREMENT BYTE COUNT
	STB	R2,,R6			:STORE BYTE
	AIS	R6,1			:INCREMENT BUFFER ADDRESS

XQSTR1	JAL	09,XBCKSM		:CHECKSUM CHAR
	AIS	R5,1			:INCREMENT BYTE COUNT
	STB	R2,,R6			:STORE BYTE IN BUFFER
	AIS	R6,1			:INCREMENT BUFFER ADDRESS
	JR	R4			:RETURN TO CALLER


:	XBTERM-	TERMINATE A RESPONSE OR COMMAND OTHER THEN AN I-FRAME
:		IN OUTPUT BUFFERS.
:	INPUT	R5=BYTE COUNT
:		R6=BUFFER ADDRESS
:	USES
:	LINK IS R0

XBTERM	LHI	R2,DLE
	STB	R2,,R6			:STORE DLE IN BUFFER
	LHI	R2,ETX
	STB	R2,1,R6			:STORE ETX IN BUFFER
	JAL	09,XBCKSM		:CHECKSUM ETX
	LIS	R2,0			:FINISH CHECKSUM
	JAL	09,XBCKSM
	JAL	09,XBCKSM
	LB	R2,XBRCHK,RL2		:GET CHKSUM HIGH BYTE
	STB	R2,2,R6			:STORE IN BUFFER
	LB	R2,XBRCHK+1,RL2		:GET LOW BYTE OF CHECKSUM
	STB	R2,3,R6			:STORE IN BUFFER
	LHI	R2,0FF			:GET PAD CHAR
	STB	R2,4,R6			:STORE IN BUFFER
	STB	R2,5,R6			:STORE ANOTHER IN BUFFER
	STB	R2,6,R6
	AIS	R5,7			:ADJUST BYTE COUNT
	NHI	R5,0FFFE		:MAKE INTO AN EVEN NUMBER

:	NOW STORE ENTRY IN ROTOR AND SET SVC POINTER IF NECESSARY
	L	R7,XPOINT		:GET ROTOR POINTER
	STH	R5,2,R7			:STORE BYTE COUNT INTO OUTPUT COMMAND ENTRY
	L	R6,XBUFF		:GET OUTPUT BUFFER STARTING ADDRESS BACK
	ST	R6,4,R7			:SAVE IN OUTPUT LIST
	L	R2,XQNEXX,,
	ST	R2,XQNEXT,RL2,RL2	:SAVE NEXT ROOM ROUTINE TO RUN
	L	R2,XQFLAG,,		:GET ADDRESS BACK OF WHAT FOREGROUND FLAG TO RESET
	RBT	RL,,R2			:RESET FLAG
	SBT	RL,SVCFLG		:HAVE WE ALREADY QUEUED UP A ROTOR ENTRY
	JNFS	XBT010			:IF SO, GO CHAIN IN THE OPERATION
	ST	R7,SVCADR		:STORE ADDRESS FOR SVC
	JR	R0

XBT010	LIS	R2,1			:GET XMIT OPERATION CODE
	STH	R2,,R7			:ENTER OPERATION CODE
	JR	R0			:RETURN


:	XBCKSM-	TRANSMIT CHECKSUM ROUTINE.
:	INPUT	R2=CHAR
:		R9=RETURN ADDRESS
:	USES
:	LINK IS R9

XBCKSM	LH	R13,XBRCHK,RL2		:GET PARTIAL CHECKSUM
	EXBR	R13,R13
	LBR	R14,R13
	STBR	R2,R13
	XH	R13,CRCTBL,R14,R14	:XOR CRC TABLE
	STH	R13,XBRCHK,RL2
	JR	R9


:	INFTRM-	FINISH UP AN OUTPUT SECTOR FOR TRANSMISSION.
:		COMPUTES FINAL CHECKSUM AND ENTERS ENTRY INTO OUTPUT LIST.
:
:	INPUT	R1=CONTROL FIELD.
:		R5=INDEX INTO SECTOR POINTERS
:	USES
:	LINK IS R0

INFTRM	HS
  IF	FINACT
	SBT	RL,FRMTMT		:INDICATE FRAME TRANSMITTED
  EI
	LB	R4,PADRT,RL,		:SET UP COMMAND ADDRESS
	JAL	R6,FTRCOT,,
	L	R6,SECADR,R5,R5		:GET ADDRESS OF OUTPUT SECTOR
	LR	R7,R6			:PUT A COPY IN REG
	AIS	R6,7			:FORM ADDRESS IN SECTOR FOR CONTROL FIELD
	LB	R1,TCHINV,R1,
	CLHI	R1,DLE			:SEE IF CONTROL FIELD EQUALS A DLE
	JN	INFTR1			:IF NOT
	STB	R1,,R6			:STORE CONTROL FIELD INTO SECTOR
	SIS	R6,1			:DECREMENT ADDRESS

INFTR1	STB	R1,,R6			:STORE CONTROL FIELD BYTE
	SIS	R6,1			:DECREMENT ADDRESS
	LB	R2,PADRT,RL,		:SET UP COMMAND ADDRESS
	LB	R2,TCHINV,R2,
	CLHI	R2,DLE			:SEE IF A DLE
	JN	INF020			:IF NOT
	STB	R2,,R6			:STORE ADDRESS BYTE
	SIS	R6,1
INF020	STB	R2,,R6			:STORE ADDRESS BYTE
	SIS	R6,1			:DECREMENT ADDRESS
	LHI	R2,STX			:GET STX FLAG CHAR
	STB	R2,,R6			:STORE IN SECTOR
	SIS	R6,1			:DECREMENT ADDRESS
	LHI	R2,DLE			:GET DLE FLAG CHAR
	STB	R2,,R6			:STORE IN SECTOR
	SIS	R6,1
	LHI	R2,SYN			:GET SYN CHAR
INF030	STB	R2,,R6			:STORE IN SECTOR
	SIS	R6,1			:DECREMENT ADDRESS
	CLR	R6,R7			:SEE IF AT START OF SECTOR YET
	JGEBS	INF030			:IF NOT

    IF	FORCHK			:IF DOING ALL CHECKSUM IN FOREGROUND
	J	INF200
    ELSE
	LHL	R2,BYT10,R5		:SEE HOW MANY COUNTS OF 10 BYTES INCLUDED IN CHECKSUM
	JE	INF200			:IF NONE TO COMPUTE FINAL CHECKSUM
	SLLS	R2,4			:FORM INDEX INTO PARTIAL TABLE
	LIS	R4,7			:GET NUMBER OF TIMES TO SHIFT CONTROL FIELD
	LIS	R6,0			:INITIALIZE PARTIAL TABLE INDEX
	LIS	R7,0
	LIS	R9,0
INF040	SRLS	R1,1			:SHIFT CONTROL FIELD RIGHT ONE BYTE
	JNCFS	INF050			:IF BIT SHIFTED OUT IS A ZERO
	XH	R7,PARCNT,R2,R6		:EXCLUSIVE OR IN PARTIAL
	AIS	R9,1			:COUNT UP TIMES A BIT WAS A 1
INF050	AIS	R6,2			:UPDATE TABLE INDEX
	SIS	R4,1			:DECREMENT SHIFT COUNT
	JNBS	INF040			:IF NOT DONE YET

:	NOW HAVE PARTIAL TO EXCLUSIVE OR WITH PARTIAL MADE UP BY RMAKE.
	SRLS	R2,3			:FORM HALF WORD INDEX INTO PARZER TABLE
	NHI	R9,1			:SEE IF AN EVEN NUMBER OF ONE BITS
	JNFS	INF060
	XH	R7,PARZER,R2,
INF060	XH	R7,PARCKM,R5		:OR IN PARTIAL FROM SECTOR TABLE

:	HAVE NEW PARTIAL CHECKSUM
	STH	R7,XBRCHK,RL2		:SAVE NEW PARTIAL

:	NOW SEE IF THERE ARE SOME BYTES LEFT IN SECTOR NOT INCLUDED IN PARTIAL CHKSUM
	L	R1,BYTADR,R5,R5		:GET ADDRESS IN SECTOR OF NEXT BYTE TO CHKSUM
	JE	INF130			:IF ZERO, ALL DONE NO BYTES LEFT
    EI

INF070	LB	R2,,R1			:GET BYTE FROM SECTOR
	AIS	R1,1			:UPDATE SECTOR ADDRESS
	CLHI	R2,DLE			:SEE IF A DLE CHAR
	JNFS	INF080			:IF NOT
	LB	R2,,R1			:GET NEXT BYTE
	AIS	R1,1			:UPDATE SECTOR ADDRESS
	CLHI	R2,DLE			:SEE IF ALSO A DLE
	JN	INF090			:NOT A DLE, CHECK TO MAKE SURE AN ETX
INF080	JAL	R9,XBCKSM		:GO CHECKSUM CHAR
	J	INF070			:CONTINUE

:	HAD A DLE NOT FOLLOWED BY A DLE, VERIFY ETX AND CONTINUE.
:	IF NOT AN ETX THEN A PROGRAMMING ERROR.
:
INF090	CLHI	R2,ETX
	JEFS	INF100			:IF NOT 'ETX'

:	PROGRAMMING ERROR. FOUND A SEQUENCE OF DLE FOLLOWED BY SOMETHING
:	OTHER THEN A DLE OR ETX IN SECTOR.
	LIS	R0,1
	AHM	R0,ILERR7,RL2,
	TRAP(RL,FC)		:DLE FOLLOWED BY NOT DLE OR ETX

INF100	JAL	R9,XBCKSM		:GO CHECKSUM ETX
INF110	LIS	R2,0
	JAL	R9,XBCKSM		:GO FINISH OF CHECKSUM
	JAL	R9,XBCKSM
	LB	R2,XBRCHK,RL2		:GET FIRST BYTE OF CHECKSUM
	STB	R2,,R1			:STORE IT IN SECTOR
	AIS	R1,1			:UPDATE SECTOR ADDRESS
	LB	R2,XBRCHK+1,RL2		:GET SECOND BYTE OF CHECKSUM
	STB	R2,,R1			:STORE IN SECTOR
	AIS	R1,1			:UPDATE ADDRESS
	LHI	R2,0FF			:GET PAD CHAR
	STB	R2,,R1			:STOR IN SECTOR
	AIS	R1,1
	STB	R2,,R1			:STORE ANOTHER
	AIS	R1,1
	STB	R2,,R1

:	COMPUTE FINAL BYTE COUNT.
:	BYTE COUNT SAVED IN BYTCNT INCLUDES EVERYTHING UP TO DLE/STX
:	IN SECTOR.
	LHL	R2,BYTCNT,R5		:GET BYTE COUNT FROM SECTOR TABLES
	AIS	R2,5			:ADD IN CRC PLUS PAD CHARS
	NHI	R2,0FFFE		:ADJUST TO HALFWORD NUMBER

:	R2 EQUALS BYTE COUNT IN SECTOR.
:	GET START ADDRESS OF SECTOR FROM SECTOR TABLES AND TERMINATE ENTRY
:	IN ROTOR.
	L	R3,SECADR,R5,R5		:GET SECTOR START ADDRESS
	L	R7,XPOINT		:GET ROTOR POINTER
	STH	R2,2,R7			:STORE BYTE COUNT IN OUTPUT LIST
	ST	R3,4,R7			:STORE SECTOR ADDRESS IN OUTPUT LIST
	L	R2,XQNEXX,,
	ST	R2,XQNEXT,RL2,RL2	:SAVE NEXT ROOM ROUTINE TO RUN
	L	R2,XQFLAG,,
	RBT	RL,,R2			:RESET FOREGROUND FLAG
	LIS	R2,1			:GET XMIT CODE OPERATOR
	SBT	RL,SVCFLG		:SET DO SVC FLAG
	JNFS	INF120
	ST	R7,SVCADR		:SAVE ADDRESS
	JR	R0

INF120	STH	R2,,R7			:ENTER OPERATION CODE
	JR	R0			:RETURN


:	COMPUTE ADDRESS IN SECTOR OF WHERE TO STORE CHKSUM.
INF130	L	R1,SECADR,R5,R5		:GET SECTOR START ADDRESS
	AH	R1,BYTCNT,R5		:ADD NUMBER OF BYTES IN SECTOR ALSREADY
	J	INF110

:	ROUTINE TO PUT CHECKSUM IN SECTOR IF LESS THEN 10 BYTES PUT IN
:	BY RMAKE .
INF200	LIS	R2,0
	STH	R2,XBRCHK,RL2 		:MAKE SURE CHECKSUM STARTS OUT EQUAL ZERO
	LB	R2,PADRT,RL,		:SET UP COMMAND ADDRESS
	LB	R2,TCHINV,R2,		:REVERSE IT BEFORE CHECKSUM
	JAL	09,XBCKSM		:CHECKSUM IT
	LR	R2,R1			:PUT CONTROL FIELD IN REG 2
	JAL	09,XBCKSM		:CHECK SUM IT
	L	R1,SECADR,R5,R5		:GET SECTOR ADDRRESS
	AIS	R1,08			:MOVE ADDRESS TO POINT TO NEXT BYTE PAST CONTROL FIELD
	J	INF070			:GO FINISH CHECKSUM
  EI	BSC			:END LAP BYSINC FRAMING

  IF	FML			:IF FRENCH MULTI-LINE
	STTL(FOREGROUND LOGIC -                 )
	SSTTL(FRENCH MULTI-LINE)

:		FRENCH MULTI-LINE FOREGROUND

FMMOD	EQ	FMMOD2			:THIS VERSION FOR 128 FRAME MODULUS ONLY
RL4	EQ	0C			:HOLDS FOUR TIMES LINE #
FVERNO	EQ	2

:	STATES OF THE INDIVIDUAL LINES
L.MRKS	EQ	0			:PUT MARKS ON THE LINE
L.FLGS	EQ	4			:PUT FLAGS ON THE LINE
L.PROM	EQ	8			:WAITING TO PROMOTE THE LINE TO UP
L.UP	EQ	0C			:LINE IS UP


TBBITC	EQ	PADRT			:USE RESPONSE ADDRESS FOR TRANSMIT B BIT
RBBITC	EQ	SADRT			:USE COMMAND ADDRESS FOR RECEIVE B BIT

RBBITR	EQ	RBBITC			:B BIT RECEIVED REVERSED IN POSITION
TBBITR	EQ	TBBITC			:B BIT XMITTED REVERSED IN POSITION
	SEG	A.DATA
RBBITU	HC	SAR.0^7			:B BIT UNREVERSED IN POS ON RECEIVE
TBBITU	HC	PAR.0^7			:B BIT UNREVERSED IN POS ON XMIT

:	INCREMENT HALFWORD COUNTER
BUMP	MACRO(CELL,REG)[
	LIS REG,1
	AHM REG,CELL,,
]



	SEG	A.CODE
FEXPSD	WC	0000,FGEX10		:SET 1000 FOR HARDWARE TRACE
FGEXEC	UPSW	FEXPSD			:LOAD PROGRAM STATUS DOUBLE-WORD
FGEX10	SVC	FASTD,0			:DISMISS ONCE MINIMUM PER FG LOOP
	JAL	R10,FPFORE,,		:UPDATE FRONT PANEL

:	SEE IF ANY RECEIVE SECTORS CAN BE RECLAIMED AFTER HAVING BEEN
:	PROCESSED BY BACKGROUND.  FOR COMPATIBILITY, FOREGROUND AND
:	BACKGROUND SECTOR CHAINS ARE STILL LINKED TOGETHER VIA THE FIRST
:	HALFWORD OF EACH BUFFER, WHICH IS A FORWARD LINK POINTER.
:	HOWEVER, TWO SETS OF FLAGS, RSC.FW AND RSC.BW, INDICATE
:	WHICH RECEIVE SECTORS ARE CURRENTLY INCLUDED IN THE
:	`FOREGROUND` AND `BACKGROUND` PORTIONS OF THE WINDOW,
:	RESPECTIVELY.  THESE FLAGS ARE USED TO `FREE` RETURNING
:	SECTORS BY CLEARING RSCUSE (SECTOR-IN-USE) FLAGS, RATHER
:	THAN REPOOLING SECTORS IN AN AVAILABLE SECTOR CHAIN.  EACH
:	SECTOR IS THEREFORE POSITIONALLY `FIXED` AND CAN BE USED
:	ONLY FOR A GIVEN SET OF FRAME NUMBERS.

RFGND	L	R4,RTD.FG		:CAN WE RECLAIM ANY SECTORS FROM RT
	JE	RFG050			:IF RTD->FG RETURNING FLAG 0
	LCS	R1,1			:-1 FOR EMPTY CHAIN POINTERS
	STH	R1,RSC.RT		:CLEAR RTD CHAIN UNCONDITIONALLY
	STH	R1,RSC.RE		:HEAD PTR (RT), END PTR (RE),
	STH	R1,RSC.RA		:AND ADVANCING PTR (RA)
	LHL	R4,RSC.BW		:FLAGS TELL PART OF WINDOW PROCESSED
	XR	R1,R4			:TURN THEM OFF
	NH	R1,RSCUSE		:LEAVE SET THOSE CURRENTLY IN USE BY FG
	STH	R1,RSCUSE		:AND SAVE THEM
	LIS	R1,0
	ST	R1,RTD.FG		:RTD CAUGHT UP
	STH	R1,RSC.BW		:BACKGROUND-PORTION-OF WINDOW FLAGS
	LB	R1,XMR			:TO UPDATE MAX RECEIVEABLE FRAME #,
	AH	R1,RSCNT2		:ADD # SECTORS PROCESSED BY BACKGROUND
	NH	R1,FMMSK		:STAY WITHIN MODULUS
	STB	R1,XMR			:AND SAVE


RFG050	LHI	R0,FMMOD-1		:FRAME MODULUS MINUS 1
	STH	R0,FMMSK		:SAVE COMPUTED MASK BEFORE...
	LHI	RL2,NLINES*2		:...IT GETS USED IN CODE ABOVE.
	LHI	RL4,NLINES*4		:LOAD UP LINE COUNTERS
RFG060	SIS	RL2,2			:STEP TO THE NEXT LINE
	JL	RFG200			:IF DONE ALL LINES
	SIS	RL4,4			:DECREMENT BOTH COUNTERS
	L	RSIO,SIOTBL,RL4,	:GET SIO TABLE BASE ADDRESS
	LR	RL,RL2			:COMPUTE SIMPLE LINE #
	SRLS	RL,1			:AS LINE*2/2
	LB	R1,PRIST,RL		:GET STATE OF LINE
	J	RFGDEC,R1		:DISPATCH ON LINE STATE

RFGDEC	J	RFG060			:LINE IS MARKING, IGNORE
	J	RFG060			:LINE IS FLAGGING, IGNORE
	J	RFG070			:LINE WAITING TO PROMOTE TO UP
	J	RFG0A0			:LINE IS UP AND USABLE


RFG070	LHL	R1,4,RSIO		:GET STATUS WITH CLOCK AND IDLE FLAGS
	THI	R1,01			:SEE IF TRANSMIT CLOCK PRESENT
	JEFS	RFG080			:IF NOT
	THI	R1,04			:SEE IF RECEIVE CLOCK PRESENT
	JEFS	RFG080			:IF NOT
	THI	R1,02			:TEST HDLC IDLE, IE LINE MARKING ??
	JEFS	RFG090			:IF NOT
	LIS	R0,1
	AHM	R0,ABTCNT,RL2		:INCREMENT ABORT COUNT FOR BACKGROUND
RFG080	RBT	RL,FLGNOW		:EITHER NO CLOCK(S) OR LINE MARKING
	J	RFG060

RFG090	SBT	RL,FLGNOW		:CLOCKS OK & LINE NOT MARKING
	J	RFG060

RFG0A0  LHL	R1,4,RSIO		:GET LINE STATUS BITS
	THI	R1,01			:SEE IF TRANSMIT CLOCK PRESENT
	JEFS	RFG0B0			:IF NOT
	THI	R1,04			:SEE IF RECEIVE CLOCK PRESENT
	JEFS	RFG0B0			:IF NOT
	THI	R1,02			:HDLC IDLE ??  IE, LINE MARKING ??
	JE	RFG0C0			:IF NOT
	LIS	R0,1
	AHM	R0,ABTCNT,RL2		:INCREMENT ABORT COUNT FOR BACKGROUND
	AHM	R0,SM.11,RL2,		:IDLE LINE COUNT FOR SUP MESSAGES
  IF	XOM
	AHM	R0,LKS.2,RL2,		:SAVE FOR XOM LINK STATISTICS
  EI
RFG0B0	RBT	RL,FLGNOW		:EITHER NO CLOCK(S) OR LINE IS MARKING
	JN	RFG060			:IF FIRST TIME DETECTING MARKS
	LIS	R0,0
	STB	R0,PRIST,RL		:PUT LINE BACK IN INITIALIZING LOGIC
	RBT	RL,LTIMER		:TURN OFF TIMER
	RBT	RL,LTMFLG		:TURN OFF TIMED-OUT FLAG
	RBT	RL,LINEUP		:SET LINE NOT UP
	JE	RFG060			:IF LINE ALREADY DOWN
	TBT	RL,LDNSUD		:DO WE WANT DEBUG MESSAGES ??
	JE	RFG0B4			:IF NOT
	STM	R0,SAVSVC		:PROTECT FROM SVC CALL
	L	R0,LDNDIA,RL2,RL2	:GET LINE DOWN MESSAGE
	SVC	SYS,SUDIA.		:SET USER DIAGNOSTIC MESSAGE
	LM	R0,SAVSVC		:NEED RSIO
	LHL	R1,4,RSIO		:RELOAD STATUS BYTE
	NHI	R1,0F			:WANT CLOCK, MARKING BITS
	LA	R0,LSTATS,R1,R1		:GET ASCII EQUIVALENT SC
	SVC	SYS,SUDIA.		:INCLUDE FOR ?HIST AND ?DIAG
	LM	R0,SAVSVC		:RESTORE REGISTERS
RFG0B4	J	RFG060

RFG0C0	LB	R1,3,RSIO		:GET CKSUM ERROR COUNT BYTE
	SBT	RL,FLGNOW		:CLOCKS OK AND LINE NOT MARKING
	LR	R3,R1
	LHL	R2,CKECNT,RL2		:LAST SAVED CHECKSUM ERROR COUNT
	SR	R1,R2			:HAS IT CHANGED ??
	JE	RFG060			:IF NOT
	AHM	R1,GARBAG,RL2		:KEEP A RUNNING TOTAL
	STH	R3,CKECNT,RL2		:SAVE CURRENT COUNT FOR NEXT TIME
	J	RFG060

RFG200	LHI	RL2,NLINES*2		:# LINES*2
	LHI	RL4,NLINES*4		:# LINES*4
RFG220	SIS	RL2,2			:STEP TO NEXT LINE
	JGE	RFG230			:IF DATA IN SIO INPUT
	LH	R0,RSC.RT		:RTD CAUGHT UP ??
	JGE	FGLINE			:NO,  DONT GIVE IT ANYMORE YET
	LH	R0,RSC.FG		:ANYTHING TO GIVE IT ??
	JL	FGLINE			:IF NOT
	STH	R0,RSC.RT		:MOVE CHAIN HEAD PTR FG TO BG
	STH	R0,RSC.RA		:INITIALIZE STARTING POINTER
	LH	R0,RSC.FE		:MOVE CHAIN END PTR FG TO BG
	STH	R0,RSC.RE
	LCS	R0,1
	STH	R0,RSC.FG		:CLEAR FG CHAIN PTRS
	STH	R0,RSC.FE
	LHL	R0,RSC.FW		:REMEMBER WHICH SECTORS GO TO BACKGROUND
	STH	R0,RSC.BW		:SO CAN BE FREED WHEN DONE WITH THEM
	LH	R0,RSCNT1		:# SECTORS LINKED IN FOREGROUND CHAIN
	STH	R0,RSCNT2		:IS NOW # IN BACKGROUND CHAIN
	LIS	R0,0
	STH	R0,RSCNT1		:CLEAR FOREGROUND SECTOR COUNTER
	STH	R0,RSC.FW		:CLEAR FOREGROUND FLAGS
	SBT	R0,FG.RTD		:TELL RTD TO GET TO WORK
	J	FGLINE			:NOW GO TO LINE CONTROL LOGIC

:	LOOK FOR INPUT IN SIO BUFFER
RFG230	SIS	RL4,4
	L	RSIO,SIOTBL,RL4,	:GET SIO AREA FOR THIS LINE
	LR	RL,RL2
	SRLS	RL,1			:GET LINE NUMBER
RFG240	LHL	R7,RINDEX,RL2		:GET RECEIVE INDEX
	LH	R8,RBUF,R7,RSIO		:SEE IF A NEW FRAME THERE
	STH	R8,RINBYT,RL2		:SAVE INPUT FRAME BYTE COUNT
	JL	RFG220			:NEG BYTE COUNT IF NO FRAME
	JE	XSYERT			:IF 0 LENGTH BYTE COUNT, STEP TO NEXT

:	FOUND AN INPUT FRAME WITH NONZERO BYTE COUNT
RFG250	AIS	R7,2			:ADVANCE POINTER PAST BYTE COUNT
	AR	R7,RSIO			:(R7)=RECORD ADDRESS
	CLHI	R8,3			:CHECK FRAME SIZE
	JGEFS	RFG260			:IF ENOUGH FOR A FRAME
	BUMP(TFGS02,R0)
	J	XSYERT			:STEP TO NEXT INPUT FRAME ON SAME LINE

RFG260	CLHI	R8,MAXFRM		:SEE IF A GOOD FRAME WITH TOO MUCH DATA
	JLEFS	RFG270			:IF NOT
	BUMP(TFGS03,R0)
	J	XSYERT			:STEP TO NEXT INPUT FRAME ON SAME LINE

:	REMEMBER ON WHICH LINE WE LAST RECEIVED GOOD DATA,
:	GET BYTES OF FRAME HEADER, REVERSED, AND SAVE.
:					--- MOD 128 ---
RFG270	STH	RL,LASTLN
	JAL	R5,BVCHAR		:  X X X X X X X I
	STB	R0,RECVC1,RL2		:  .....M(R).....

	JAL	R5,BVCHAR		:  X X X X X X X 0
	STB	R0,RECVC2,RL2		:  .....N(R).....

	JAL	R5,BVCHAR		:  X X X X X X X B
	STB	R0,RECVC3,RL2		:  .....N(S).....

	JAL	R6,FTRCIN,,		:ENTER INTO FRAME TRACE

:	NOW SEE IF A RESET OR INFO FRAME.
	LIS	R5,7			:LOW ORDER BIT=0 IF INFORMATION FRAME
	TBT	R5,RECVC1,RL2
	JE	IFRAME			:IF INFORMATION FRAME

:	SEE WHAT TYPE OF RESET FRAME (REQUEST OR CONFIRMATION)
	LB	R5,RECVC1,RL2		:GET FIRST OCTET
	CLHI	R5,01			:SEE IF M(R)=0
	JEFS	RFG290			:IF SO
RFG280	BUMP(TFGS04,R0)			:FIRST OCTET HAS MORE THAN JUST I BIT
	J	XSYERT			:STEP TO NEXT INPUT FRAME ON SAME LINE

RFG290	LB	R5,RECVC3,RL2		:CHECK B BIT
	CLB	R5,RBBITR,,		:SEE IF RECEIVED B BIT REVERSED
	JEFS	RFG2A0			:YES, OK
:	SEE IF A LOOPED BACK RESET
	CLB	R5,TBBITR,,		:XMIT B BIT REVERSED ??
	JE	XSYR4D			:YES, GO FLAG LINE AS DOWN
	J	RFG280			:SEND RESET (UNEXPECTED FRAME HEADER)

:	NOW SEE IF A RESET REQUEST OR CONFIRMATION
RFG2A0	BUMP(TFGS06,R0)
	LB	R5,RECVC2,RL2		:GET CAUSE FIELD
	JEFS	RFG2D0			:IF RESET CONFIRMATION
:	HANDLE RESET REQUEST.
	LHL	R1,PRISTC		:GET STATE OF LINK
	J	DECS1,R1		:TAKE JUMP

:	RESET CONFIRMATION RECEIVED.
RFG2D0	LHL	R1,PRISTC		:GET STATE OF LINK
	J	DECS2,R1		:DISPATCH BASED ON THAT

:DECISION TABLE USED IF RECEIVED FRAME ON AN OPEN LINE IS A RESET REQUEST.
:
DECS1	J	RRES1			:LINK DOWN
	J	RRES2			:LINK IN RESET STATE
	J	RRES3			:LINK IN MUST SEND RESET CONF. STATE
	J	RRES4			:LINK ASLEEP FOR TIME D
	J	RRES5			:LINK ASLEEP ON XMIT BUT CAN RECEIVE
	J	RRES6			:LINK LEVEL IN INFO XSFER
	J	RRES6			:LINK LEVEL RETRANSMITTING

:DECISION TABLE USED IF RECEIVED FRAME IS A RESET CONFIRMATION.
:
DECS2	J	RCES1			:LINK DOWN
	J	RCES2			:LINK IN RESET STATE
	J	RCES3			:LINK IN MUST SEND RESET CONF. STATE
	J	RCES4			:LINK ASLEEP FOR TIME D
	J	RCES4			:LINK ASLEEP ON XMIT BUT CAN RECEIVE
	J	RCES6			:LINK LEVEL IN INFO TRANSFER
	J	RCES6			:LINK LEVEL RETRANSMITTING

:DECISION TABLE USED IF LINK RECEIVES AN INFO FRAME.
:
DECS3	J	IFR030			:LINK DOWN
	J	IFR030			:LINK IN RESET STATE
	J	IFR030			:LINK IN MUST SEND RESET CONF. STATE
	J	IFR030			:LINK ASLEEP FOR TIME D
	J	IFR040			:LINK ASLEEP ON XMIT BUT CAN RECEIVE
	J	IFR040			:LINK LEVEL IN INFO XFER
	J	IFR040			:LINK LEVEL RETRANSMITTING

:	ROUTINE TO PROCESS AN INFO FRAME.
IFRAME	LIS	R5,1
  IF	XOM
	AM	R5,FCNTLK,RL2,RL2	:INCREMENT NO. OF I-FRAME RECIEVED
  EI
	RBT	RL,FRMEMT		:INITIALLY CLEAR EMPTY FRAME FLAG
	CLHI	R8,3			:SEE IF AN EMPTY FRAME
	JNFS	IFR010			:IF NOT
	SBT	RL,FRMEMT		:YES, SET FLAG
	JFS	IFR020
IFR010	CLHI	R8,6			:MAKE SURE ENOUGH DATA FOR A PACKET
	JL	RCES6			:SEND A RESET FRAME IF NOT
IFR020	LB	R1,RECVC3,RL2		:CHECK B BIT
	NHI	R1,01			:MASK OFF N(S)
	CLB	R1,RBBITR,,		:SEE IF CORRECT
	JN	XSYER4			:IF ERROR
	LHL	R1,PRISTC		:GET STATE OF LINK
	J	DECS3,R1		:GO PROCESS INFORMATION FRAME

:	LINK IN A STATE WHERE FRAME IS IGNORED.
IFR030	LIS	R5,1
	AHM	R5,RERR8,RL2,		:COMMAND HANDLER RECEIVED I FRAME WHEN NOT ARMED,
	J	XSYERT

:	RECEIVED AN INFO FRAME WHILE IN INFO XFER.
:	GET VALUE OF N(S) FROM RECVC3 AND MAKE SURE RECEIVE SECTOR
:	IS EMPTY FOR FRAME INPUT. IF NOT DISCARD FRAME.
IFR040	RBT	RL,NOSTOR		:RESET NOSTORE FLAG
	LB	R1,RECVC3,RL2		:GET N(S)
	LB	R1,TCHINV,R1,		:UNREVERSE IT
	NHI	R1,7F			:MASK OFF B BIT
	LB	R2,RURADD,R1,		:GET CORRESPONDING SECTOR # FOR N(S)
	SBT	R2,RSCUSE		:SEE IF SECTOR ALREADY IN USE
	JE	IFR050			:IF NOT
	SIS	R8,3			:TEST RECEIVED FRAME FOR EMPTY
	JE	XSYERT			:IF EMPTY, TO NEXT FRAME
	BUMP(TFGS07,R0)
	J	XSYERT

:O'K SECTOR IS AVAILABLE. SET UP AND PUT DATA IN IT.
:FIRST SEE IF AN EMPTY FRAME
IFR050	STB	R2,RSCCUR,RL,		:SAVE SECTOR BEING MESSED WITH
	SIS	R8,3			:SUBTRACT 3 FROM BYTE COUNT
	JE	IFR0C0			:IF AN EMPTY FRAME
	AR	R2,R2			:FRAME# * 2
	L	R6,RSCADR,R2,R2		:GET RECEIVE SECTOR ADDRESS
	ST	R6,RSCBEG,RL2,RL2		:SAVE BEGINNING ADDRESS
	STH	R8,RSCCNT,R2		:SAVE BYTE COUNT
	STH	R8,2,R6			:PUT BYTE COUNT INTO RSC BUFFER
	AIS	R6,4			:ALLOW FOR LINK AND BYTE COUNT
IFR060	JAL	R5,BVCHAX		:GET NEXT BYTE FROM SIO INPUT, UNREVERSED
	STB	R0,,R6			:PUT INTO RECEIVE SECTOR
	AIS	R6,1			:INCREMENT ADDRESS
	SIS	R8,1			:DECREMENT BYTE COUNT
	JNBS	IFR060			:IF NOT DONE YET
	RBT	RL,FRMEMT		:RESET EMPTY FRAME FLAG

	JAL	R5,NS.CHK		:GO CHECK N(S)
	 J	IFR080			:N(S) IS OUTSIDE WINDOW
	 J	IFR068			:N(S) INSIDE WONDOW AND EMPTY
	 J	IFR068			:N(S)=LOWER WINDOW EDGE, ADVANCED XIR
	 J	IFR068			:N(S) OUT OF ORDER, XHR ADVANCED
	 J	IFR068			:N(S) OUT OF ORDER, XHR NOT ADVANCED

IFR068	JAL	R5,NR.CHK		:CHECK N(R)
	 J	IFR070			:NO NEW FRAMES ACKED OR OLD N(R)
	 J	IFR070			:SOME BUT NOT ALL FRAMES ACKED
	 J	IFR070			:ALL FRAMES OUT ACKED

IFR070	JAL	R5,MR.CHK		:CHECK M(R)
	 J	IFR072			:M(R) UPDATED
	 J	IFR072			:M(R) NOT CURRENT BUT INSIDE WINDOW
	 J	XSYERT			:M(R) BAD, RESET QUEUED UP
IFR072	EQ	.

:	NOW SEE IF NOSTOR FLAG WAS SET. IF SO EXIT
IFR080	RBT	RL,NOSTOR
	JN	IFR0B0
:	QUEUE UP AN EMPTY I-FRAME IN CASE XMIT LOGIC HAS NO NEW ONES TO SEND
	LHI	R1,LINKIN
	STH	R1,XPSTAT
	J	XSYERT

IFR0B0	EQ .
	BUMP(TFGS08,R0)
	LB	R2,RSCCUR,RL,		:GET SECTOR JUST MESSED WITH
	RBT	R2,RSCUSE		:RESET IN USE FLAG
	J	XSYERT

:	ROUTINE TO HANDLE A RECEIVED EMPTY I FRAME
IFR0C0	SBT	RL,FRMEMT		:SET FRAME EMPTY FLAG
	JAL	R5,NS.CHK		:CHECK N(S)
	 J	IFR0E0			:N(S) OUTSIDE WINDOW
	 J	IFR0C2			:N(S) INSIDE WINDOW AND EMPTY
	 J	IFR0C2			:N(S)=LOWER WINDOW EDGE, XIR ADVANCED
	 J	IFR0C2			:N(S) OUT OF ORDER, XHR ADVANCED
	 J	IFR0C2			:N(S) OUT OF ORDER, XHR NOT ADVANCED

IFR0C2	JAL	R5,NR.CHK		:CHECK N(R)
	 J	IFR0C4			:N(R) OLD OR NO FRAMES ACKED
	 J	IFR0C4			:N(R) ACKED SOME BUT NOT ALL FRAMES OUT
	 J	IFR0C4			:N(R) ACKED ALL FRAMES OUT

IFR0C4	JAL	R5,MR.CHK		:CHECK M(R)
	 J	IFR0D0			:M(R) UPDATED
	 J	IFR0D0			:M(R) NOT CURRENT BUT INSIDE WINDOW
	 J	XSYERT			:M(R) BAD, RESET QUEUED UP

IFR0D0	LB	R2,RSCCUR,RL		:GET SECTOR BEING MESSED WITH
	RBT	R2,RSCUSE		:RESET IN USE FLAG
	J	XSYERT

:	ROUTINE TO SEND A RESET IF N(S) WAS OUTSIDE WINDOW IN EMPTY FRAME
IFR0E0	BUMP(TFGS09,R5)
	J	IFR0D0

:	ROUTINE TO ANALYZE THE N(S) PORTION OF A FRAME.
NS.CHK	LB	R6,RECVC3,RL2		:GET THE N(S) RECEIVED FRAME #
	LB	R6,TCHINV,R6,		:UNREVERSE IT
	NH	R6,FMMSK		:MASK OFF B BIT
:	FIRST VERIFY THE N(S) IS INSIDE THE WINDOW
	LR	R1,R6
	LB	R2,XMR			:GET XM(R) UPPER LIMIT OF RECEPTION WINDOW+1
	LB	R3,XIR			:LOWER EDGE OF RECEPTION WINDOW
	SR	R2,R3			:(R2)=WINDOW SIZE(UPPER-LOWER)EDGE TO EDGE
	JGEFS	NS010
	AHI	R2,FMMOD		:ADJUST NEGATIVE NUMBER
NS010	SR	R1,R3			:(R1)=RECEIVED FRAME#-LOWER EDGE FRAME#
	JGEFS	NS020
	AHI	R1,FMMOD		:ADJUST NEGATIVE NUMBER
NS020	CLR	R1,R2			:SEE IF INSIDE WINDOW
	JLFS	NS022			:IF N(S) IS INSIDE WINDOW
	BUMP(TFGS10,R1)
	SBT	RL,NOSTOR		:DON`T STORE THIS FRAME
	J	0,R5			:N(S) OUTSIDE WINDOW RETURN

NS022	RBT	RL,FRMEMT		:SEE IF THIS WAS AN EMPTY I-FRAME
	JN	4,R5			:N(S) INSIDE WINDOW AND EMPTY, RETURN
:	N(S) WAS INSIDE WINDOW & NOT EMPTY
NS030	CLB	R6,XIR			:RECEIVED FRAME=LOWER WINDOW EDGE?
	JN	NS070			:IF NOT
	LB	R1,XHR			:HIGHEST RECEIVED FRAME# +1
	CLB	R1,XIR			:=LOWER EDGE OF RECEPTION WINDOW? (NO GAPS)
	JNFS	NS040			:JUMP IF GAPS
	AIS	R1,1			:INCREMENT VALUE OF LOWER EDGE
	NH	R1,FMMSK		:FRAME MOD MASK
	STB	R1,XHR			:SAVE NEW XH(R) HIGHEST RECEIVED FRAME # +1
NS040	LB	R1,XIR			:LOWER EDGE OF RECEPTION WINDOW
	JAL	R0,XIRRSC,,		:LINK THIS SECTOR INTO FG CHAIN
	AIS	R1,1			:INCREMENT FRAME NUMBER
	NH	R1,FMMSK		:FRAME MOD MASK
	LB	R2,XHR			:HIGHEST RECEIVED FRAME# +1
	SR	R2,R1			:SUBTRACT LOWER EDGE PLUS 1
	JE	NS060			:JUMP IF NO GAPS
	JGFS	NS050			:JUMP IF POSITIVE, IE., GAP
	AHI	R2,FMMOD		:ADJUST NEGATIVE NUMBER

:	R2 NOW HAS SIZE OF GAP.
:	ADVANCE LOWER EDGE OF WINDOW TO FIRST EMPTY SECTOR IF
:	GAP EXISTS DUE TO NONCONSECUTIVE FRAMES RECEIVED.
NS050	LB	R3,RURADD,R1,		:GET RECEIVE SECTOR EQUIVALENT
	TBT	R3,RSCUSE		:HAVE WE FILLED THIS SECTOR YET ??
	JEFS	NS060			:IF NOT, THATS IT FOR NOW
	JAL	R0,XIRRSC,,		:LINK THIS SECTOR INTO FG CHAIN
	AIS	R1,1			:INCREMENT XR
	NH	R1,FMMSK		:FRAME MOD MASK
	SIS	R2,1			:SCAN FROM (LOWER EDGE+1) TO (HIGHEST RECVED+1)
	JNBS	NS050			:IF MORE CONSECUTIVE FRAMES FOR BACKGROUND
NS060	STB	R1,XIR			:SAVE LOWER EDGE OF WINDOW
	J	8,R5			:N(S)=LOWER EDGE, XIR ADVANCED

:	HERE IF FRAME RECEIVED OUT OF ORDER.
NS070	CLB	R6,XHR			:SEE IF N(S)=XH(R), ..IS THIS ONE NEXT?
	JNFS	NS080			:IF NOT
	AIS	R6,1			:YES, ADVANCE XHR
	NH	R6,FMMSK		:FRAME MOD MASK
	STB	R6,XHR			:SAVE HIGHEST RECEIVED FRAME# +1
	J	0C,R5			:N(S) OUT OF ORDER, XHR ADVANCED

NS080	LB	R2,XMR			:UPPER LIMIT OF WINDOW
	LB	R3,XHR			:HIGHEST RECEIVED FRAME# +1
	SR	R2,R3			:(R2)= XHR TO XMR COUNT
	JGEFS	NS090
	AHI	R2,FMMOD		:ADJUST NEGATIVE NUMBER
NS090	LB	R3,XMR			:UPPER LIMIT OF WINDOW
	LR	R1,R6			:PUT N(S) INTO R1
	SR	R3,R1			:(R3)= N(S) TO XMR COUNT
	JGEFS	NS0A0
	AHI	R3,FMMOD		:ADJUST NEGATIVE NUMBER
NS0A0	CLR	R2,R3			:SEE IF N(S) IS BETWEEN XHR AND XMR
	JL	10,R5			:N(S) OUT OF ORDER, XHR NOT ADVANCED
	AIS	R6,1			:YES, N(S)+1 IS NEW XHR
	NH	R6,FMMSK		:FRAME MOD MASK
	STB	R6,XHR			:SAVE HIGHEST RECEIVED FRAME# +1
	J	0C,R5			:N(S) OUT OF ORDER, XHR ADVANCED

:	ROUTINE TO EVALUATE N(R)
NR.CHK	LB	R6,RECVC2,RL2		:CONTAINS N(R) ACKNOWLEDGEMENT TO N(R)-1
	LB	R6,TCHINV,R6,		:INVERT BACK SO N(R) RIGHT-ADJUSTED
	NH	R6,FMMSK		:FRAME MOD MASK
	LR	R3,R6
	SIS	R3,1			:FOR N(R)-1
	NH	R3,FMMSK		:FRAME MOD MASK
	CLB	R6,XVS			:IF N(R)=V(S) ALL FRAMES OUT ARE ACKED
	JEFS	NR010
	TBT	R3,VSENT		:SEE IF FRAME WAS SENT
	JE	0,R5			:NO FRAMES ACKED OR OLD N(R) RETURNED
NR010	LB	R2,LVACK		:GET LAST FRAME ACKED
	STB	R3,LVACK		:SAVE NEW LAST FRAME ACKED
	SR	R3,R2			:SEE HOW MANY FRAMES ACKED
	JGEFS	NR020
	AHI	R3,FMMOD		:ADJUST FOR NEGATIVE NUMBER
NR020	JE	0,R5			:JUMP IF NONE ACKED
:	NOW RESET FLAGS IN VSENT AND SECSNT ARRAYS
	LB	R1,LSACK		:GET LAST SECTOR ACKED
NR030	LB	R1,ADDONE,R1		:ADD 1 SECTOR INDEX
	AIS	R2,1			:UP YOUR FRAME NUMBER
	NH	R2,FMMSK		:FRAME MOD MASK
	RBT	R2,VSENT		:CLEAR FRAME OUT FLAG
	RBT	R1,SECSNT		:CLEAR SECTOR OUT FLAG
	RBT	R1,SECBLT		:CLEAR SECTOR BUILT FLAG
	SIS	R3,1			:DECREMENT # ACK`ED COUNTER
	JN	NR030			:IF MORE TO DO
	STB	R1,LSACK		:SAVE NEW LAST SECTOR ACKED
	LHL	R1,PRISTC		:GET STATE OF LINK
	CLHI	R1,LINKRT		:SEE IF HAVE BEEN RETRANSMITTING INFO FRAMES
	JNFS	NR040			:IF NOT
	LB	R0,RTVS			:GET FRAME BEING RETRANSMITTED
	TBT	R0,VSENT		:SEE IF IT GOT ACKED
	JNFS	NR040			:IF NOT
	LHI	R0,LINKIN		:CLEAR TIMER RECOVERY
	STH	R0,PRISTC		:PUT LINK IN INFO TRANSFER
NR040	LIS	R0,0
	RBT	R0,T1TA.F		:TURN OFF TIMER
	RBT	R0,T1TO.F		:CLEAR TIMED OUT FLAG
	LIS	R0,1
	STH	R0,XRETER,,		:RESET RETRANSMISSION COUNTER
	LB	R0,LVACK		:GET LAST FRAME ACKED
	AIS	R0,1			:INCREMENT BY ONE
	NH	R0,FMMSK		:KEEP WITHIN FRAME MOD MASK
	CLB	R0,XVS			:COMPARE TO OUT NEXT SEND FRAME #
	JE	8,R5			:IF ALL FRAMES OUT WERE ACKED
	L	R0,FASTC,,0
	AHI	R0,XTIME1		:FORM NEW T1 TIME
	ST	R0,T1CNTR		:SET T1 TIMER SAVE CELL
	LIS	R0,0
	SBT	R0,T1TA.F		:TURN TIMER BACK ON
	LHI	R0,-N2.0		:GET NEW RETRANSMISSION COUNT
	STH	R0,XRETER,,		:STORE NEW RETRANSMISSION COUNT
	J	4,R5			:SOME BUT NOT ALL FRAMES ACKED

:	ROUTINE TO EVALUATE M(R)
MR.CHK	LB	R6,RECVC1,RL2		:GET UPPER LIMIT OF RECEIVE WINDOW
	LB	R6,TCHINV,R6,		:UN-REVERSE IT
	NH	R6,FMMSK		:KEEP RECEIVED M(R)
:	NOW MAKE SURE M(R) IS VALID AND IF SO UPDATE OUR XMS.
	LR	R1,R6			:MOVE IT
	LB	R2,XMS			:GET PRESENT XMS VALUE
	LR	R3,R2			:MOVE IT
	LB	R0,K.LT,,		:WINDOW SIZE
	AR	R2,R0			:(R2)=XMS+K
	NH	R2,FMMSK		:FRAME MOD MASK
	SR	R2,R3
	JGEFS	MR010
	AHI	R2,FMMOD		:ADJUST NEGATIVE NUMBER
MR010	SR	R1,R3			:RECEIVED M(R) - OLD XMS
	JGEFS	MR020
	AHI	R1,FMMOD		:ADJUST NEGATIVE NUMBER
MR020	CLR	R1,R2			:(M(R)-XMS) - K
	JGFS	MR030			:JUMP IF M(R) NOT CURRENT
	STB	R6,XMS			:UPDATE XMS
	J	0,R5			:M(R) UPDATED

MR030	LR	R1,R6			:GET M(R) INTO R1 FOR WINDOW CHECK
	LB	R2,XMS
	LB	R0,K.LT,,		:WINDOW SIZE
	AR	R2,R0
	NH	R2,FMMSK		:FORM XMS + K
	LR	R6,R2			:SAVE A COPY OF XMS+K
	LB	R3,LVACK		:GET LAST FRAME ACKED
	AIS	R3,1			:FORM XIS
	NH	R3,FMMSK		:FRAME MOD MASK
	SR	R2,R3
	JGEFS	MR040			:SEE IF RESULT NEG.
	AHI	R2,FMMOD		:ADJUST NEGATIVE NUMBER
MR040	SR	R6,R1
	JGEFS	MR050
	AHI	R6,FMMOD		:ADJUST NEGATIVE NUMBER
MR050	CLR	R6,R2			:SEE IF M(R) INSIDE ALLOWED WINDOW
	JGFS	MR060			:JUMP IF NOT
	J	4,R5			:M(R) NOT CURRENT BUT INSIDE WINDOW

:	M(R) BAD. QUEUE UP A RESET FRAME
MR060	RBT	RL,NOSTOR		:RESET NOSTOR SO RSCUSE IS RESET
	LHI	R0,LINKRS		:LINK IN RESET STATE
	STH	R0,PRISTC
	STH	R0,XPSTAT
	BUMP(TFGS11,R0)
	J	8,R5			:M(R) BAD, SEND A RESET FRAME

:	RECEIVED A RESET REQUEST WHEN LINK LEVEL IS DOWN.
:	IGNORE IT
RRES1	BUMP(TFGS20,R0)
	J	XSYERT			:GET NEXT FRAME THIS LINE

:	RECEIVED A RESET REQ. WHEN WE HAVE ONE OUT. ASSUME COLLISION.
RRES2	LHI	R5,LINKSL		:PUT LINK ASLEEP FOR TIME D
	STH	R5,PRISTC
	LIS	R5,0			:LINK ALWAYS 0
	RBT	R5,T1TO.F		:TURN OFF TIMED-OUT FLAG
	L	R1,FASTC,,
	AHI	R1,XTIME2		:FORM TIME D
	ST	R1,T1CNTR		:SET T1 TIMER SAVE CELL
	SBT	R5,T1TA.F		:TURN TIMER ON
	BUMP(TFGS21,R0)
	J	XSYERT			:GO GET NEXT FRAME THIS LINE

:	LINK IN MUST SEND RESET CONFIRM. STATE . IGNORE RESET RECEIVED
RRES3	BUMP(TFGS22,R0)
	J	XSYERT			:GO GET NEXT FRAME THIS LINE

:	LINK ASLEEP FOR TIME D. NO FRAMES LOOKED AT.
RRES4	BUMP(TFGS23,R0)
	J	XSYERT			:GO GET NEXT FRAME THIS LINE

:	LINK ASLEEP FOR SECOND TIME D. IF RESET OCCURS GO TO SEND CONFIRM STATE.
RRES5	LIS	R5,0			:ALWAYS LINK 0 IN THIS VERSION
	RBT	R5,T1TA.F		:TURN OFF TIMER-ACTIVE FLAG
	RBT	R5,T1TO.F		:TURN OFF TIME-OUT OCCURRED FLAG
	LHI	R5,LINKRC		:GET SEND RESET CONFIRMATION STATE
	STH	R5,PRISTC
	BUMP(TFGS24,R0)
	J	XSYERT			:GET NEXT FRAME THIS LINE

:	RECEIVED A RESET REQ WHILE IN INFO TRANSFER.
:	HANDLE AS A RESET.
RRES6	LIS	R5,0			:ALWAYS LINK 0 IN THIS VERSION
	RBT	R5,T1TA.F		:TURN OFF TIMER-ACTIVE FLAG
	RBT	R5,T1TO.F		:TURN OFF TIME-OUT OCCURRED FLAG
	LHI	R5,LINKRC		:GO TO SEND RESET CONFIRMATION STATE
	STH	R5,PRISTC
	BUMP(TFGS25,R0)
	J	XSYERT			:GET NEXT FRAME THIS LINE

:	RECEIVED A RESET CONF. WHEN LINK LEVEL DOWN.
:	IGNORE IT
RCES1	BUMP(TFGS30,R0)
	J	XSYERT			:GET NEXT FRAME THIS LINE

:	RECEIVED A CONF. WHEN WE HAVE A RESET OUT. EXPECTED RESPONSE.
RCES2	BUMP(TFGS31,R0)
	J	RRES2

:	RECEIVED A CONF. ON LINK IN MUST SEND CONF. IGNORE IT
RCES3	BUMP(TFGS32,R0)
	J	XSYERT			:GET NEXT FRAME THIS LINE

:	RECEIVED CONF. WHILE ASLEEP. IGNORE IT
RCES4	BUMP(TFGS33,R0)
	J	XSYERT			:GET NEXT FRAME THIS LINE

:	RECEIVED A CONF. WHILE IN INFO XSFER OR TIMER RECOVERY.
:	PUT LINK IN RESET STATE.
RCES6	LHI	R5,LINKRS
	STH	R5,PRISTC
	STH	R5,XPSTAT
	BUMP(TFGS34,R0)
	J	XSYERT

:	LINK SECTOR INTO FOREGROUND CHAIN OF SECTORS.
:	R1	FRAME NUMBER
:	R0	RETURN LINK ADDRESS
:	RL2	TWICE LINE#
XIRRSC	LB	R4,RURADD,R1,		:GET SECTOR # =F(FRAME#)
	SBT	R4,RSC.FW		:FLAG FG WINDOW CONTAINS IT
	JN	XIR030			:WHOA, SECTOR ALREADY IN CHAIN
	SBT	R4,RSCUSE		:MAKE SURE SECTOR IN USE IS SET
	JE	XIR040			:SHOULD BE SET FOR NON-EMPTY FRAMES
	TBT	R4,RSC.BW		:SEE IF ALREADY IN BKG CHAIN ??
	JN	XIR050			:IF SO, IT SHOULDN'T BE
	LR	R7,R4			:MOVE SECTOR #
	SLLS	R7,1			:HALF WORD OFFSET
	L	R6,RSCADR,R7,R7		:ABSOLUTE SECTOR ADDRESS
	LR	R7,R6			:MOVE TO COMPUTE RELATIVE SEC ADDR
	SI	R7,RSC			:OFFSET TO SECTOR
	LCS	R8,1			:-1 LINK IS NULL
	STH	R8,,R6			:NEW SECTOR LINK IS NULL
	LH	R8,RSC.FE		:IS FG CHAIN EMPTY ??
	JGEFS	XIR010			:NO
	STH	R7,RSC.FG		:START CHAIN WITH THIS SECTOR
	JFS	XIR020
XIR010	AI	R8,RSC			:ABS ADDR OF PREV LAST SECTOR IN CHAIN
	STH	R7,,R8			:LET IT POINT TO NEW ONE
XIR020	STH	R7,RSC.FE		:NEW END OF CHAIN POINTER
	LIS	R7,1			:INCREMENT COUNTER OF SECTORS
	AHM	R7,RSCNT1		:IN FOREGROUND CHAIN
	JR	R0			:EXIT
XIR030	TRAP(R1,D0)			:RSC.FOREGROUND WINDOW ERROR	:AHM 5-28-87
XIR040	TRAP(R1,D0)			:RSCUSE ERROR		     	:AHM 5-28-87
XIR050	TRAP(R1,D0)			:SECTOR ALREADY IN BKG CHAIN	:AHM 5-28-87

XSYER4	HS				:INFO FRAME LOOP BACK ERROR
XSYR4D	HS				:RESET FRAME LOOP BACK ERROR
	LIS	R0,1
	AHM	R0,SM.F,RL2,		:COUNTER FOR SUP MESSAGES
  IF	XOM
	AHM	R0,LKS.10,RL2,		:SAVE FOR XOM LINK STATISTICS
  EI
	LIS	R0,0
	STB	R0,PRIST,RL		:PUT LINE IN CLOSED STATE
	RBT	RL,LTIMER		:TURN OFF LINE TIMER
	RBT	RL,LTMFLG		:TURN OFF TIMED OUT FLAG
	RBT	RL,LINEUP		:FLAG LINE AS DOWN
	JE	XSYERT			:JUMP IF ALREADY DOWN
	TBT	RL,LDNSUD		:DO WE WANT SUP MESSAGES ??
	JEFS	XSYERT			:IF NOT
	STM	R0,SAVSVC		:PROTECT FROM SVC
	L	R0,LDNDIB,RL2,RL2	:LINE DOWN DIAGNOSTIC MESSAGE
	SVC	SYS,SUDIA.		:SET USER DIAGNOSTIC
	LM	R0,SAVSVC		:RESTORE REGISTERS

:	STEP TO NEXT FRAME IN RECEIVE BUFFER OF THE SAME LINE.
XSYERT	LCS	R3,1
	LHL	R2,RINDEX,RL2		:GET SIO RECEIVE BUFFER TAKE-OUT INDEX
	JNFS	XSYRTA			:BR IF NOT AT START OF BUFFER
	STH	R3,RBUF,R2,RSIO		:PUT FIRST -1 AT BUFFER START
XSYRTA  AIS	R2,3			:STEP OVER BYTE COUNT, ROUND UP
	AH	R2,RINBYT,RL2		:ADD BYTE COUNT OF LAST FRAME
	NHI	R2,0FFFE		:ROUND DOWN TO HALF-WORD OFFSET

:NOW SEE IF ROOM FOR AT LEAST ONE MORE FRAME +1 HW COUNT +1 HW FFFF MARKER
:COMPARE OUR NEXT READ OFFSET IN THE BUFFER TO THE LAST VALUE AT WHICH
:THE SIO HARDWARE WILL PUT A FRAME BEFORE WRAPPING TO THE BUFFER START.
	CLHI	R2,(RBUFHS-(RBUFRS+2))*2
	JLEFS	XSYRTB			:IF ROOM FOR ONE MORE
	LIS	R2,0			:BUFFER WRAP-AROUND TO START
XSYRTB	STH	R2,RINDEX,RL2		:SAVE NEW TAKE-OUT INDEX
	SBT	RL,NOTIDL		:SET LINE NOT IDLE
	J	RFG240			:GO SEE IF A FRAME IS THERE

:	ROUTINE TO GET A CHAR FROM PAGE AREA AND INVERT IT
BVCHAR  LB	R2,RBUF,R7
	AIS	R7,1
	LB	R0,TCHINV,R2,		:REVERSE IT FOR OLD LOGIC
	JR	R5

:	ROUTINE TO GET A CHAR FROM INFO PORTION OF A FRAME
BVCHAX  LB	R0,RBUF,R7
	AIS	R7,1
	JR	R5

:	DECISION TABLE USED BY LINE CONTROL LOGIC
FGLDEC	J	FGL010			:PUT MARKS ON LINE
	J	FGL020			:PUT FLAGS ON LINE
	J	FGL030			:PROMOTE LINE TO LINE-UP IF FLAGS RECEIVED
	J	FGL040			:LINE IS UP AND USEABLE

FGLINE	LHI	RL2,NLINES*2		:# LINES * 2
	LHI	RL4,NLINES*4		:# LINES * 4
FGL000	SIS	RL2,2			:LOOP DOWN THROUGH LINES
	JL	FGTRAN			:GO TO TRANSMIT LOGIC IF DONE
	SIS	RL4,4			:DECREMENT BOTH COUNTERS
	LR	RL,RL2			:BUT COMPUTE LINE NUMBER
	SRLS	RL,1
	L	RSIO,SIOTBL,RL4,	:GET SIO AREA ADDRESS
  IF	XOM
	TBT	RL,XOMLDH
	JE	FGL005			:IF XOM NOT KEEPING LINE DOWN
	LIS	R0,L.MRKS		:GET MARKING STATE
	CLB	R0,PRIST,RL
	JE	FGL000			:IF LINE ALREADY MARKING
	LB	R4,SLU.LT,RL,
	LHI	R5,MICCW,RSIO
	SVC	IO,(FMBOT.^4)+R4	:FORCE 1'S OUTPUT ON LINE
	J	TXRERR
	STB	R0,PRIST,RL		:MARKING STATE
	RBT	RL,LINEUP		:INDICATE LINE DOWN
	L	R0,LINEUP
	JN	FGL000			:IF AT LEAST ONE LINE UP ON LINK
	LHI	R0,LINKDN		: ELSE PUT LINK DOWN
	STH	R0,PRISTC
	LIS	R0,0
	SBT	R0,XOMLDC		: INDICATE XOM WANTS LINK DOWN
	RBT	RL,PACKUP		:PUT PACKET LEVEL DOWN
	RBT	RL,LINKUP		:PUT LINK DOWN
	JE	FGL000			:IF LINK ALREADY DOWN
	SBT	RL,HANGEM		: ELSE INDICATE HANG USERS
	J	FGL000
  EI
FGL005	JAL	R5,XROOM		:SEE IF ROOM IN OUTPUT PAGES
	J	FGL000			:IF NO ROOM TO DO OUTPUT
	LB	R5,PRIST,RL		:GET STATE OF LINE
	J	FGLDEC,R5		:AND DISPATCH ACCORDINGLY

:	FOLLOWING PUTS LINE TO STATE OF OUTPUTTING MARKS
FGL010	RBT	RL,LTMFLG		:TURN OFF TIMED OUT FLAG
	LB	R4,SLU.LT,RL,		:LOGICAL UNIT # FROM LINE ORDINAL
	LHI	R5,MICCW,RSIO		:CHANNEL COMMAND TO OUTPUT MARKS
	SVC	IO,(FMBOT.^4)+R4		:FORCE SIO OUTPUT
	J	TXRERR			:JUMP IF SVC FAILS
	LIS	R0,L.FLGS		:GET FLAGS STATE OF LINE
	STB	R0,PRIST,RL		:SET UP NEXT STATE
	L	R1,FASTC,,
	AHI	R1,STIME1		:TIME TO OUTPUT MARKS
	ST	R1,SIMCNT,RL4		:OUTPUT MARKS FOR STIME1
	RBT	RL,LTMFLG
	SBT	RL,LTIMER		:TURN ON TIMER
	J	FGL000			:GO CHECK NEXT LINE

:	FOLLOWING PUTS LINE TO STATE OF OUTPUTTING FLAGS
FGL020	RBT	RL,LTMFLG		:SEE IF A TIMEOUT YET
	JE	FGL000			:NO, WAIT
	LB	R4,SLU.LT,RL,		:LOGICAL UNIT # FROM LINE ORDINAL
	LHI	R5,FICCW,RSIO		:CHANNEL COMMAND TO OUTPUT FLAGS
	SVC	IO,(FMBOT.^4)+R4	:FORCE SIO OUTPUT
	J	TXRERR			:JUMP IF SVC FAILS
	LIS	R0,L.PROM		:GET WAITING TO PROMOTE STATE
	STB	R0,PRIST,RL		:PUT LINE IN NEXT STATE
	RBT	RL,FLGNOW
	L	R1,FASTC,,
	AHI	R1,STIME1+STIME1	:OUTPUT FLAGS FOR TWICE STIME1
	ST	R1,SIMCNT,RL4		:OUTPUT FLAGS FOR 2*T1
	RBT	RL,LTMFLG
	SBT	RL,LTIMER
	J	FGL000

:	FOLLOWING PROMOTES LINE TO UP IF FLAGS HAVE BEEN
:	CONTINUOUSLY RECEIVED.
FGL030	RBT	RL,LTMFLG		:SEE IF A TIMEOUT YET
	JE	FGL000			:NO, WAIT
	RBT	RL,FLGNOW		:HAVE WE BEEN RECEIVING FLAGS ??
	JE	FGL010			:NOPE GO TRY AGAIN
	SBT	RL,LINEUP		:FLAG LINE AS USABLE
	LIS	R1,L.UP			:GET LINE UP STATE
	STB	R1,PRIST,RL
	TBT	RL,LDNSUD		:DO WE WANT ?HIST MESSAGES ??
	JEFS	FGL032			:IF NOT
	STM	R0,SAVSVC		:PROTECT REGS FROM SVC
	L	R0,LUPDIA,RL2,RL2	:LINE UP MESSAGE
	SVC	SYS,SUDIA.		:SET USER DIAGNOSTIC
	LM	R0,SAVSVC		:RELOAD SAVED REGISTERS
FGL032	LCS	R1,2
	STH	R1,MARKS,RL2
	J	FGL000

LUPDIA	WS
	WC	LUP.D0
	WC	LUP.D1

LUP.D0	SC	/FML: Line 0 coming up/
LUP.D1	SC	/FML: Line 1 coming up/

LDNDIA	WS
	WC	LDN.D0
	WC	LDN.D1

LDNDIB	WS
	WC	LDN.D2
	WC	LDN.D3

LDN.D0	SC	/FML: Line 0 going down, status bits are../
LDN.D1	SC	/FML: line 1 going down, status bits are../
LDN.D2	SC	/FML: Line 0 going down, loop back addr error/
LDN.D3	SC	/FML: Line 1 going down, loop back addr error/

LSTATS	SC	/0/		:LINE STATUS BITS
	SC	/1/
	SC	/2/
	SC	/3/
	SC	/4/
	SC	/5/
	SC	/6/
	SC	/7/
	SC	/8/
	SC	/9/
	SC	/A/
	SC	/B/
	SC	/C/
	SC	/D/
	SC	/E/
	SC	/F/

:	LINE IS UP AND USEABLE, NOTHING TO DO.
FGL040	EQ	FGL000

:	DECISION TABLE USED BY TRANSMIT LOGIC.
:	ENTRY BASED ON STATE OF LINK.
FGTDEC	J	FGT100			:LINK DOWN
	J	FGT200			:LINK IN RESET STATE
	J	FGT300			:LINK IN SEND RESET CONFIRMATION STATE
	J	FGT400			:LINK IN FIRST DORMANT STATE
	J	FGT500			:LINK IN SECOND DORMANT STATE
	J	FGT600			:LINK IN INFO XSFER
	J	FGT700			:LINK IN RETRANSMISSION STATE.


FGTRAN	LH	RL,LASTLN		:LAST LINE TO RECEIVE GOOD FRAME
TQUAAA	LR	RL2,RL			:COMPUTE TWICE LINE #
	SLLS	RL2,1
	LR	RL4,RL2			:COMPUTE FOUR TIMES LINE #
	SLLS	RL4,1
	L	RSIO,SIOTBL,RL4,	:GET SIO AREA ADDRESS
	LIS	R5,0			:ALWAYS LINK 0
	RBT	R5,REINIT		:BACKGROUND SAYS TO REINIT ??
	JN	FGT030			:IF SO
	TBT	RL,LINEUP		:SEE IF THIS LINE IS USABLE
	JE	FGT050			:NO, STEP TO NEXT LINE
FGT010	JAL	5,XROOM			:MAKE SURE ROOM IN OUTPUT LIST BEFORE CONT.
	J	FGT050			:IF NO ROOM
	LHL	R5,PRISTC		:GET STATE OF LINK
	J	FGTDEC,5		:GO TO ROUTINE, EXIT TO FGT050

FGT030	LHI	R1,LINKDN
	STH	R1,PRISTC		:PUT LINK IN DOWN STATE
	LIS	R5,0
	RBT	R5,PACKUP		:SET PACKET LEVEL DOWN
	RBT	R5,LINKUP		:SET LINK LEVEL DOWN
	JE	FGT050			:IF LINK ALREADY DOWN
	SBT	RL,HANGEM		: ELSE INDICATE HANG USERS
	J	FGT050

:	NOW FOR TEST PURPOSES SEE IF XMS DOES NOT EQUAL XVS
FGT040	LB	R1,XMS
	CLB	R1,XVS
	JEFS	FGT050
	BUMP(TFGS50,R1)
FGT050	XHI	RL,1			:FLIP TO OTHER LINE
	CH	RL,LASTLN		:SAME LINE WE STARTED WITH ??
	JN	TQUAAA			:IF NOT
FGT070	J	FGEXEC			:REPEAT FOREGROUND LOOP

:	ROUTINE USED WHEN LINK IS IN DOWN STATE.
:	CHECKS BCKFLG AND IF SET ISSUES A RESET FRAME.
FGT100	LIS	R1,0
	RBT	R1,BCKFLG		:SEE IF BACKGROUND WANTS US TO SEND RESET
	JE	FGT050			:IF NOT
  IF	XOM
	TBT	RL,XOMLDH
	JN	FGT050			:IF XOM WANTS IT IN MARKING STATE, OK
  EI
FGT110	JAL	R0,BLD.RS		:BUILD RESET FRAME, CAUSE=0FF
	JAL	R5,TMCOMD		:GO TRANSMIT COMMAND FRAME
	LHI	R1,LINKRS		:GET RESET STATE
	STH	R1,PRISTC		:PUT LINK IN IT
	LIS	R1,0			:FOR LINK 0,
	RBT	R1,T1TO.F		:CLEAR TIMED-OUT FLAG
	L	R5,FASTC,,		:GET FAST CLOCK
	AHI	R5,XTIME0		:FORM T0 FOR RETRANSMISSION OF RESET
	ST	R5,T1CNTR		:SET T1 TIMER SAVE CELL
	LHI	R5,-N2.0		:GET RETRANSMISSION COUNT
	STH	R5,XRETER,,		:SAVE NEW COUNTER
	SBT	R1,T1TA.F		:PUT TIMER ON
	J	FGT050

:	ROUTINE USED IN RESET STATE.
FGT200	LHL	R1,XPSTAT		:SEE IF ANY RESETS TO SEND BECAUSE
	CLHI	R1,LINKRS		:INFO TRANSFER WANTS TO
	JNFS	FGT210			:JUMP IF NOT
	JAL	R6,OUTINT		:DO CLEANUP
	J	FGT110			:GO SEND ONE
FGT210	LIS	R5,0
	RBT	R5,T1TO.F		:SEE IF A TIMOUT
	JE	FGT050			:JUMP IF NOT
	RBT	R5,T1TA.F		:RESET TIMER ACTIVE FLAG
	LIS	R5,1
	AHM	R5,XRETER,,		:INCREMENT RETRANSMISSION COUNT
	JN	FGT220			:IF NOT EXHAUSTED RETRIES YET
	LIS	R5,0			:FOR LINK 0,
	RBT	R5,PACKUP		:FLAG PACKET LEVEL AS DOWN
	RBT	R5,LINKUP		:FLAG LINK LEVEL DOWN
	JE	FGT110			:IF LINK ALREADY DOWN JUST GO SEND RESET AGAIN
					:ELSE FLAG LINK AS DOWN AND LET BACKGROUND DO RESET UP
	SBT	RL,HANGEM		: AND INDICATE HANG USERS
	LHI	R1,LINKDN		:GET DOWN STATE
	STH	R1,PRISTC
	J	FGT050

FGT220	JAL	R0,BLD.RS		:BUILD RESET FRAME, CAUSE=0FF
	JAL	R5,TMCOMD		:GO TRANSMIT COMMAND FRAME
	LIS	R1,0			:FOR LINK 0,
	RBT	R1,T1TO.F		:CLEAR TIMED-OUT FLAG
	L	R5,FASTC,,		:GET FAST CLOCK
	AHI	R5,XTIME0		:FORM NEW TIME T0
	ST	R5,T1CNTR		:SET T1 TIMER SAVE CELL
	SBT	R1,T1TA.F		:TURN ON TIMER
	J	FGT050

:	ROUTINE USED TO SEND A RESET CONFIRM.
FGT300	JAL	R6,OUTINT,,		:DO INITIALIZATION
	JAL	R0,BLD.RC		:BUILD RESET CONFIRMATION FRAME
	JAL	R5,TMCOMD		:GO TRANSMIT COMMAND FRAME
	LHI	R1,LINKSL		:GET FIRST DORMANT STATE
	STH	R1,PRISTC
	LIS	R1,0
	RBT	R1,PACKUP		:FLAG PACKET LEVEL AS DOWN
	L	R5,FASTC,,
	AHI	R5,XTIME2		:FORM TIME D
	ST	R5,T1CNTR		:SET T1 TIMER SAVE CELL
	RBT	R1,T1TO.F		:CLEAR TIMED-OUT FLAG
	SBT	R1,T1TA.F		:SET TIMER ON
	J	FGT050

:	DORMANT TIME LOGIC. JUST WAITS FOR TIMEOUT. THEN SETS NEW TIMEOUT
:	AND GOES TO SECOND DORMANT STATE
FGT400	LIS	R1,0			:WAITING FOR PREVIOUS STATE ??
	RBT	R1,T1TO.F		:CLEAR TIMED-OUT FLAG, SET YET ??
	JE	FGT050			:IF NOT, KEEP WAITING
	RBT	R1,T1TA.F		:TURN TIMER OFF
	LHI	R5,LINKSD		:HAD A TIMEOUT, GO TO NEXT STATE
	STH	R5,PRISTC		:CAN RECEIVE BUT NOT SEND FRAMES
	L	R5,FASTC,,		:GET FAST CLOCK
	AHI	R5,XTIME2		:FORM NEW TIMER VALUE
	ST	R5,T1CNTR		:SET T1 TIMER SAVE CELL
	SBT	R1,T1TA.F		:TURN ON TIMER
	J	FGT050

:	ROUTINE USED WHEN SECOND DORMANT TIMEOUT OCCURS.
:	LINK IS PUT IN INFO XSFER AND AN EMPTY I-FRAME IS SENT
FGT500	LIS	R1,0			:LOOK AT LINK 0
	RBT	R1,T1TO.F		:TIMER EXPIRED ??
	JE	FGT050			:IF NOT
	RBT	R1,T1TA.F		:YES, TURN IT OFF
	LHI	R5,LINKIN
	STH	R5,PRISTC		:PUT LINK IN INFO XFER STATE
	SBT	R1,LINKUP		:FLAG LINK AS UP
:	QUEUE UP AN EMPTY I FRAME ON EACH LINE THAT IS UP
	LHI	RL2,NLINES*2		:GET TWICE # OF LINES
	LHI	RL4,NLINES*4		:GET FOUR TIMES # OF LINES
FGT520	SIS	RL2,2			:DECREMENT COUNTER
	JL	FGT070			:IF DONE ALL LINES
	SIS	RL4,4			:ELSE DECREMENT OTHER COUNTER TOO
	L	RSIO,SIOTBL,RL4,	:SIO AREA ADDRESS
	LR	RL,RL2			:COMPUTE LINE #
	SRLS	RL,1			:AS HALF TWICE LINE #
	TBT	RL,LINEUP		:IS THIS LINE UP ??
	JEBS	FGT520			:IF NOT, GO TO NEXT ONE
FGT530	LB	RSIP,PREPAG,RL		:GET PRESENT PAGE INDEX (0 1 2 )
	SLLS	RSIP,4			:COMPUTE TRANSMIT COMMAND INDEX
	LHL	R3,TCCWL,RSIP,RSIO	:SEE IF ENTRY IN USE
	JEFS	FGT540			:IF NOT (0 IF NO COMMAND THERE)
	CLHI	R3,100			:DID IT EXECUTE AND JUMP OR HALT ??
	JGEFS	FGT540			:IF SO, ENTRY IS ALSO FREE
	SVC	DISMIS,0		:DISMISS UNTIL ABLE TO SEND IT
	BUMP(TFGS40,R0)
	J	FGT530

FGT540  LIS	R0,0
	STH	R0,TCCWL,RSIP,RSIO	:CLEAR OUT WRITE HDLC RECORD COMMAND
	STH	R0,TCCWL+4,RSIP,RSIO	:CLEAR OUT JUMP COMMAND
:	NOW SEND EMPTY FRAME
	LB	R1,XMR
	STB	R1,TECVC1,RL
	LB	R1,XIR
	STB	R1,TECVC2,RL		:SAVE SECOND OCTET
	LB	R1,XVS
	OH	R1,TBBITU		:OR IN B BIT
	STB	R1,TECVC3,RL
	SBT	RL,SNTEMT		:SET FLAG FOR TRACE LOGIC TO KNOW ITS AN EMPTY FRAME
	JAL	R5,TMCOMD		:GO SEND NEXT ENTRY
	J	FGT520

:	LINK IN INFO XSFER.
FGT600	LIS	R1,0
	RBT	R1,T1TO.F		:SEE IF A TIMOUT
	JN	FGT630			:JUMP IF SO
	LHL	R5,XPSTAT		:SEE IF WE ARE TOLD TO SEND AN EMPTY FRAME
	CLHI	R5,LINKIN
	JGE	FGT670			:IF SO
FGT610	LB	R5,NXTSEC		:GET NEXT SECTOR # TO BE OUTPUT
	TBT	R5,SECBLT
	JN	FGT620			:NEXT SECTOR READY TO GO
	L	R1,FASTC,,
	C	R1,FIDL.C,,		:PAST IDLE FRAME EXPIRATION YET
	JL	FGT070			:NO
	AHI	R1,RATE*4/5		:FORM NEXT EXPIRATION TIME
	ST	R1,FIDL.C,,		:SAVE FOR NEXT TIME
	J	FGT680			:GO SEND EMPTY I FRAME

FGT620	LB	R1,LVACK
	AIS	R1,1
	LB	R0,K.LT,,		:WINDOW SIZE
	AR	R1,R0
	NH	R1,FMMSK		:FRAME MOD MASK
	CLB	R1,XVS
	JE	FGT040
	LB	R1,XMS			:GET UPPER XMIT WINDOW EDGE
	CLB	R1,XVS			:SEE IF WINDOW CLOSED
	JE	FGT050			:JUMP IF SO

:	O'K TO SEND FRAME. BUILD FIRST 3 OCTETS
	LB	R1,XMR
	STB	R1,TECVC1,RL		:SAVE FIRST OCTET
	LB	R1,XIR
	STB	R1,TECVC2,RL
	LB	R1,XVS
	OH	R1,TBBITU		:OR IN B BIT
	STB	R1,TECVC3,RL
	LB	R5,NXTSEC		:GET NEXT SECTOR TO SEND
	AR	R5,R5			:FORM INDEX INTO SECTOR TABLES
	JAL	R0,INFTRM		:GO SEND IT
	LB	R5,XVS			:GET FRAME SENT
	SBT	R5,VSENT		:FLAG FRAME AS OUT
	AIS	R5,1			:INCREMENT XVS
	NH	R5,FMMSK		:FRAME MOD MASK
	STB	R5,XVS
	LB	R5,NXTSEC		:GET NEXT SECTOR # TO BE SENT
	SBT	R5,SECSNT,,		:FLAG SECTOR AS SENT
	LB	R5,ADDONE,R5,		:FORM NEXT SECTOR NUMBER
	STB	R5,NXTSEC		:SAVE NEXT SECTOR # TO BE SENT
	L	R1,FASTC,,
	AHI	R1,XTIME1		:FORM T1 TIME
	ST	R1,T1CNTR		:SET T1 TIMER SAVE CELL
	LIS	R5,0
	SBT	R5,T1TA.F
	J	FGT010			:SEE IF MORE TO DO

:	TIMEOUT OCCURRED
FGT630	RBT	R1,T1TA.F
	LB	R5,LVACK		:GET LAST FRAME ACKED
	AIS	R5,1			:FORM FRAME TO RETRANSMIT
	NH	R5,FMMSK		:FRAME MOD MASK
	STB	R5,RTVS
	TBT	R5,VSENT		:MAKE SURE FRAME IS OUT
	JE	FGT650			:JUMP IF NOT, ERROR
	OH	R5,TBBITU		:OR IN B BIT
	STB	R5,TECVC3,RL
	LB	R5,XIR
	STB	R5,TECVC2,RL
	LB	R5,XMR
	STB	R5,TECVC1,RL
	LB	R5,LSACK		:FORM SECTOR TO RETRANSMIT
	LB	R5,ADDONE,R5,		:FORM NEXT SECTOR INDEX
	TBT	R5,SECSNT		:MAKE SURE IT WAS SENT
	JE	FGT660			:ERROR IF NOT
	AR	R5,R5			:FORM INDEX INTO SECTOR TABLES
	JAL	R0,INFTRM
	LIS	R1,0
	RBT	R1,T1TO.F
	L	R5,FASTC,,
	AHI	R5,XTIME1
	ST	R5,T1CNTR		:SET T1 TIMER SAVE CELL
	SBT	R1,T1TA.F		:PUT TIMER ON
	LHL	R5,PRISTC
	CLHI	R5,LINKRT		:SEE IF IN TIMER RECOVERY
	JE	FGT050			:JUMP IF SO
	LHI	R5,LINKRT		:PUT INTERFACE IN THIS STATE
	STH	R5,PRISTC
	LHI	R5,-N2.0		:GET NEW RETRANSMISSION COUNT
	STH	R5,XRETER,,
	J	FGT050

:	ERROR IF TRIED TO RETRANSMIT A FRAME NOT OUTSTANDING.
FGT650	JAL	R10,CRASH,,0

:	ERROR IF TRIED TO RETRANSMIT A SECTOR NOT OUTSTANDING
FGT660	JAL	R10,CRASH,,0

:	ROUTINE USED TO SEND AN EMPTY I FRAME
FGT670	CLHI	R5,LINKRT		:SEE IF WE MUST SEND THIS FRAME
	JE	FGT680			:JUMP IF SO
:	FIRST MAKE SURE NO FRAME REMAINS OUTSTANDING.
	LIS	R5,0
	STH	R5,XPSTAT		:RESET XPSTAT CELL
:	NOW SEE IF ANY NEW FRAMES WAITING TO GO
	LB	R5,NXTSEC		:GET NEXT SECTOR # TO BE SENT
	TBT	R5,SECBLT
	JE	FGT680			:JUMP IF NOT READY

:	FRAMES TO SEND. SEE IF WINDOW IS CLOSED. IF SO SEND AN EMPTY
:	FRAME, ELSE GO SEND DATA FRAME
	LB	R1,XMS
	CLB	R1,XVS
	JN	FGT610
FGT680	LB	R1,XMR
	STB	R1,TECVC1,RL
	LB	R1,XIR
	STB	R1,TECVC2,RL		:SAVE SECOND OCTET
	LB	R1,XVS
	OH	R1,TBBITU		:OR IN B BIT
	STB	R1,TECVC3,RL
	SBT	RL,SNTEMT		:SET FLAG FOR TRACE LOGIC TO KNOW ITS AN EMPTY FRAME
	JAL	R5,TMCOMD		:GO SEND NEXT ENTRY
:	NOW FRAME IDLE TIMER GETS SET BY TMCOMD ROUTINE. WHEN IT FIRES AGAIN
:	IS WHEN WE WILL SEE IF TO SEND AN EMPTY FRAME
	J	FGT050

:	ROUTINE USED TO RETRANSMIT A FRAME.
FGT700	LIS	R1,0
	RBT	R1,T1TO.F		:SEE IF A TIMEOUT
	JE	FGT610			:JUMP IF NOT
	LIS	R0,1
	AHM	R0,XRETER,,
	JN	FGT630			:JUMP IF NOT MAX RETRANS COUNT
	SBT	R1,REINIT
	J	FGT050

:	ROUTINE TO BUILD A RESET COMMAND FRAME IN TECVC OCTETS
BLD.RS	LHI	R1,080			:BIT 7 SET FOR RESET FRAME
	STB	R1,TECVC1,RL
	LHI	R1,0FF			:CAUSE CODE
	STB	R1,TECVC2,RL
	LH	R1,TBBITU		:B ADDRESS BIT
	STB	R1,TECVC3,RL
	JR	R0			:RETURN

:	ROUTINE TO BUILD A RESET CONFIRMATION FRAME IN CONTROL OCTETS
BLD.RC	LHI	R1,080			:BIT 7 SET FOR RESET CONFIRMATION
	STB	R1,TECVC1,RL
	LIS	R1,0
	STB	R1,TECVC2,RL
	LH	R1,TBBITU		:B ADDRESS BIT
	STB	R1,TECVC3,RL
	JR	R0			:RETURN

:	ROUTINE TO SET UP THINGS WHEN DOING A RESET.
:	R6=RETURN
:	FOREGROUND ENTRY POINT
OUTINT	STM	R0,SAVSVC		:PROTECT FROM SVC
	LA	R0,LLRINI		:LINK LEVEL REINITIALIZING MESSAGE
	SVC	SYS,SUDIA.		:SET USER DIAGNOSTIC
	LM	R0,SAVSVC		:RELOAD CONTENTS PREVIOUS TO SVC

:	BACKGROUND ENTRY POINT, DON'T SHARE STORAGE AREAS (SAVSVC)
OUTIN2	LIS	R5,0
	STH	R5,RSCNT1		:CLEAR COUNT SECTORS IN FG CHAIN
	STH	R5,RSCNT2		:CLEAR COUNT SECTORS IF RT CHAIN
	STB	R5,XR			:SET UP TERMS
	STB	R5,XVS
	STB	R5,XIR
	STB	R5,XHR
	STB	R5,XMS
	LB	R1,K.LT,,
	STB	R1,XMR
	STH	R5,NOSTOR		:SET ARRAYS TO ZERO
	STH	R5,RSC.BW
	STH	R5,RSC.FW
	RBT	R5,T1TA.F
	RBT	R5,T1TO.F
	ST	R5,VSENT
	ST	R5,VSENT+4
	ST	R5,VSENT+8
	ST	R5,VSENT+0C
	ST	R5,SECSNT
	ST	R5,SECSNT+4
	ST	R5,SECSNT+08
	ST	R5,SECSNT+0C
	LHI	R1,FMMOD-1		:GET FRAME MOD MASK
	STB	R1,LVACK
	LB	R1,LSACK
	LB	R1,ADDONE,R1,		:FORM FIRST SECTOR TO SEND
	STB	R1,NXTSEC
	STH	R5,XRETER,,
	STH	R5,RSCEMT
	STH	R5,RSCUSE
	JR	R6

LLRINI	SC	/FML: Link level reinitializing/

	HS	0
S1MD8	BC	7,0,1,2,3,4,5,6	

	HC	0
A1MD4	BC	1,2,3,0

:	FOLLOWING IS USED TO COMPUTE THE NEXT SECTOR NUMBER - TRANSMIT.
Q	EQ	1
ADDONE	HS	0
	RE	MXK.0-1
	BC	Q
Q	EQ	Q+1
	ER
	BC	0

	HC	0
S2MD4   BC	2,3,0,1			:SUBTRACT 2, MOD 4

	HS	0
S1MD4   BC	3,0,1,2			:SUBTRACT 1, MOD 4

:	RURADD TRANSLATES AN INPUT FRAME NUMBER INTO ITS DESIGNATED
:	RECEIVE SECTOR NUMBER.
RURADD	HS
 	RE	8
	BC	0,1,2,3,4,5,6,7,8,9,0A,0B,0C,0D,0E,0F
	ER

:	FOLLOWING ROUTINE WATCHES 2 ENTRY TRANSMIT COMMAND LIST TO SEE
:	IF WE HAVE AN EMPTY ENTRY.
XROOM	LB	RSIP,PREPAG,RL		:GET PRESENT ENTRY TO LOOK AT
	LB	R4,S1MD4,RSIP		:GO BACK TWO ENTRIES, MOD 4
	SLLS	R4,4
	LHL	R3,TCCWL,R4,RSIO	:SEE IF ENTRY IN USE
	JE	XROOM0			:JUMP IF NOT (NO COMMAND THERE)
	CLHI	R3,100			:DID IT COMPLETE AND JUMP ??
	JL	XROOMX			:NO, NOT DONE YET
	JE	XROOM0			:YES, IT FINISHED

:VALUE MUST HAVE BEEN A 200, SEE IF A CONFLICT WITH A JUMP THAT
:DID NOT EXECUTE DUE TO TIMING RACE.
:
	LHL	R0,TCCWL+4,R4,RSIO
	JE	XROOM0			:JUMP IF NO CONFLICT

:WAS A 2, SO REISSUE SVC IF ENTRY BEHIND PRESENT ONE NOT EXECUTED.
:
	LR	R3,RSIP
	SLLS	R3,4
	LHL	R0,TCCWL,R3,RSIO
	SIS	R0,1
	JN	XROOM0			:JUMP IF OK

:NOW ISSUE SVC AGAIN AND EXIT ROUTINE  AS IF WE HAD NO ROOM
:
	STH	R0,TCCWL,R4,RSIO	 :DO CLEANUP ON TWO BEHIND ENTRY
	STH	R0,TCCWL+4,R4,RSIO
	LR	R4,RSIO
	AHI	R4,TCCWL,R3
	LB	R3,SLU.LT,RL,		:LOGICAL UNIT # FROM LINE ORDINAL
	STM	R0,SAVSVC		:***** DON'T FORGET TO REMOVE
	SVC	IO,(FMBOT.^4)+R3
	J	TXRERR			:JUMP IF SVC FAILED
	LM	R0,SAVSVC		:***** DON'T FORGET TO REMOVE
	JR	R5
XROOM0  LIS	R0,0
	STH	R0,TCCWL,R4,RSIO
	STH	R0,TCCWL+4,R4,RSIO
:NOW MAKE SURE THIS ENTRY IS FREE.
	SLLS	RSIP,4			:MAKE QUAD WORD INDEX
	LHL	R3,TCCWL,RSIP,RSIO	:GET FIRST HALFWORD OF LIST
	JEFS	XROOM1
	CLHI	R3,100			:SEE IF FINISHED AN OPERATION
	JGEFS	XROOM1
XROOMX  LIS	R7,1
	AHM	R7,NOROOM,,
	JR	R5
XROOM1  LIS	R0,0
	STH	R0,TCCWL,RSIP,RSIO
	STH	R0,TCCWL+4,RSIP,RSIO
	AIS	R5,4
	JR	R5






:ROUTINE TO SEND A RESET OR EMPTY I-FRAME
:
TMCOMD	ST	R5,TMRET
	LIS	R5,0
	STH	R5,XPSTAT
	L	R5,FASTC,,		:GET PRESENT CLOCK TIME
	AHI	R5,RATE*2/5		:CALCULATE NEW IDLE TIME
	ST	R5,FIDL.C,,		:SAVE NEXT EXPIRATION TIME
	LHI	R6,OUTSCT,RSIO
	ST	R6,INBUFF,,		:OUTPUT SECTOR ADDRESS
	AIS	R6,2			:ALLOW FOR BYTE COUNT
	LB	R0,TECVC1,RL		:GET FIRST OCTET
	STB	R0,0,R6			:PUT IN FIRST OCTET
	LB	R0,TECVC2,RL		:GET SECOND OCTET
	STB	R0,1,R6
	LB	R0,TECVC3,RL		:GET THIRD OCTET
	STB	R0,2,R6
	LIS	R5,3
	STH	R5,XBYTE		:SAVE BYTE COUNT
	J	XBTERM			:GO TO COMMON PROCESSING




:ROUTINE TO SEND AN INFO FRAME
INFTRM	LIS	R6,1			:FOR XOM LINK STATISTICS PURPOSE
  IF	XOM
	AM	R6,FCNTLK,RL2,RL2		:INCREMENT NO. OF I-FRAMES SENT
  EI
	ST	R0,TMRET		:SAVE RETURN ADDRESS
	L	R6,FASTC,,
	AHI	R6,RATE*2/5		:FORM NEW IDLE TIME
	ST	R6,FIDL.C,,		:SAVE NEXT EXPIRATION TIME
	L	R6,SECADR,R5,R5		:GET SECTOR ADDRESS TO BE OUTPUT
	LR	R7,R6
	ST	R6,INBUFF,,
	AIS	R6,2			:ALLOW 2 BYTES PER BYTE COUNT
	LB	R1,TECVC1,RL		:GET FIRST OCTET
	STB	R1,0,R6
	LB	R1,TECVC2,RL		:GET SECOND OCTET
	STB	R1,1,R6
	LB	R1,TECVC3,RL		:GET THIRD OCTET
	STB	R1,2,R6
	LHL	R1,BYTCNT,R5
	STH	R1,XBYTE

XBTERM
	JAL	R6,FTRCOT,,		:ENTER INTO FRAME TRACE TABLE
	L	R6,INBUFF		:GET ADDRESS WHERE DATA IS BEING PUT
	LHL	R5,XBYTE		:GET BYTE COUNT
	STH	R5,0,R6

TXROOM  LB	R7,PREPAG,RL		:GET PRESENT PAGE NUMBER
	LR	R6,RL			:***** DON'T FORGET TO REMOVE
	AR	R6,R6			:***** DON'T FORGET TO REMOVE
	L	RSIO,SIOTBL,R6,R6	:***** DON'T FORGET TO REMOVE
	LR	R6,R7
	SLLS	R6,4			:MAKE INTO BYTE OFFSET
	AR	R6,RSIO			:ADD IN SIOTABLE ADDRESS
	LIS	R0,1
	STH	R0,TCCWL,R6		:PUT WRITE HDLC RECORD COMMAND IN
	L	R0,INBUFF		:OUTPUT SECTOR ADDRESS
	SRLS	R0,4			:FORM QUAD WORD
	STH	R0,TCCWL+2,R6		:ADDRESS FOLLOWS WRITE COMMAND
	LB	R7,S1MD4,R7		:BACKUP ONE MOD 4
	SLLS	R7,4			:MAKE BYTE OFFSET
	AR	R7,RSIO			:ADD SIO AREA BASE ADDRESS
	LHL	R0,TCCWL,R7		:GET ITS COMMAND
	CLHI	R0,1			:STILL A WRITE ??
	JN	TXROM1			:NO, MUST HAVE BEGUN OR FINISHED

:PREVIOUS ENTRY STILL BUSY XMITTING. TACK ON A JUMP TO THIS ONE.
	LIS	R0,2			:JUMP DESTINATION ASSEMBLED IN
	STH	R0,TCCWL+4,R7		:STORE JUMP COMMAND
	LHL	R0,TCCWL,R7		:NOW MAKE SURE PREVIOUS COMMAND DID NOT FINISH BEFORE
:				JUMP GOT STORED.
	CLHI	R0,0200			:DID IT COMPLETE AND HALT ??
	JN	TXROMX
	LIS	R0,0			:YES
	STH	R0,TCCWL,R7		:CLEAR ITS WRITE COMMAND
	STH	R0,TCCWL+4,R7		:CLEAR ITS JUMP COMMAND TOO

:NOW ISSUE SVC FOR OUTPUT.
TXROM1  LR	R4,RSIO			:GET SIOTABLE BASE ADDRESS
	LB	RSIP,PREPAG,RL		:GET PRESENT PAGE
	SLLS	RSIP,4			:16 BYTES PER ENTRY
	AHI	R4,TCCWL,RSIP		:FORM ENTRY ADDRESS
	LB	R3,SLU.LT,RL,		:LOGICAL UNIT # FROM LINE ORDINAL
	STM	R0,SAVSVC		:***** DON'T FORGET TO REMOVE
	SVC	IO,(FMBOT.^4)+R3
	J	TXRERR	  		:JUMP IF SVC FAILED
	LM	R0,SAVSVC		:***** DON'T FORGET TO REMOVE
TXROMX  LB	R4,PREPAG,RL		:GET PAGE # JUST USED
	LB	R4,A1MD4,R4,		:INCREMENT AND WRAP AT MOD 4
	STB	R4,PREPAG,RL		:SAVE NEXT PAGE # TO USE
	L	R0,TMRET
	JR	R0
TXRERR	JAL	R10,CRASH,,
	JR	R0

  EI	FML
-~3*