
	STTL(RECORD TEARDOWN LOGIC                   )


::	ACCEPT - ARRAY TO CHECK FOR ACCEPTABLILITY OF PACKET
:
:	1 HALFWORD PER PACKET STATE, HALFWORD INDEXED BY
:	PACKET TYPE.
:	TYPES AND STATES DESCRIBED IN OPTIONS AREA.
:	(SEE SYMBOL YCALRQ ET AL.)

	SEG	A.RTBL
ACCEPT	HS
:	   PACKET TYPE
:	0123456789ABCDEF
:	-----------------+
 HC $2	0101000000000000 :0		P1 - READY
 HC $2	0001000000000000 :1  P		P3 - SEND INCOMING CALL (CALL REQUEST)
 HC $2	0011000000000000 :2  A		P3 - WAIT FOR CALL ACCEPT (CALL CONNECTED)
 HC $2	0001000000000000 :3  C		P2 - MUST SEND CALL CONNNECTED
 HC $2	0001000100100000 :4  K		P7 - SEND CLEAR INDICATION
 HC $2	0001100000000000 :5  E		P7 - WAIT FOR CLEAR CONFIRMATION
 HC $2	0000000000000000 :6  T		P6 - SEND CLEAR CONFIRMATION
 HC $2	0001010111100000 :7		P4 - FLOW CONTROL READY
 HC $2	0001010000000000 :8  S		D3 - MUST SEND RESET INDICATION
 HC $2	0001011000000000 :9  T		D3 - WAIT FOR RESET CONFIRMATION
 HC $2	0001010000000000 :A  A		D2 - MUST SEND RESET CONFIRMATION
 HC $2	0000000000000000 :B  T		R3 - SEND RESTART INDICATION
 HC $2	0000000000000000 :C  E		R3 - WAIT FOR RESTART CONFIRMATION
 HC $2	0000000000000000 :D		R2 - SEND RESTART CONFIRMATION
 HC $2	0000011000000000 :E		   - PVC BUILD STATE



:	VALUE ASSIGNED TO PACKET TYPES
:ZCALRQ	EQ	01		:CALL REQUEST PACKET
:ZCLACP	EQ	02		:CALL ACCEPTED PACKET
:ZCLRQ	EQ	03		:CLEAR REQUEST
:ZCLRCN	EQ	04		:CLEAR CONFIRMATION
:ZRESET	EQ	05		:RESET REQUEST
:ZRESCN	EQ	06		:RESET CONFIRMATION
:ZDATA	EQ	07		:DATA PACKET
:ZINTP	EQ	08		:INTERRUPT PACKET
:ZINTPC	EQ	09		:INTERRUPT CONFIRMATION
:ZFLOW	EQ	0A		:RR PACKET
::FOLLOWING PACKET TYPES USED ONLY ON CHANNEL ZERO
:ZRSTRT	EQ	0B		:RESTART REQUEST
:ZRSTRC	EQ	0C		:RESTART CONFIRMATION
:ZILLCN	EQ	0D		:ILLEGAL CHANNEL #, SEND CLEAR REQUEST OR CONF
:ZDIAG	EQ	0E		:DIAGNOSTIC PACKET
::	FOLLOWING PACKET TYPE FOR INTERNAL COMMUNICATION FROM DP TO RM
:ZTERM	EQ	0F		:TERMINAL PARAMETER MESSAGES
:ZMAX	EQ	10		:MAXIMUM VALUE

:	SUBROUTINE TABLE FOR RTD LOGIC. ENTRY BASED ON DECODE OF LOW 5 BITS
:	OF OCTET 3 OF A PACKET.

 TABLE(RTDFAN,CODE)	:NOTE THIS TABLE IS FOR FORWARD REFERENCES ONLY
			: IT SHOULD APPEAR BEFORE ALL REFERENCED ROUTINES
	TENTRY(RTDAT)		:00,  DATA PACKET.
	TENTRY(RTRR)		:01,  RR PACKET
	TENTRY(RTDAT)		:02,  DATA PACKET
	TENTRY(RTINT)		:03,  INTERRUPT PACKET
	TENTRY(RTDAT)		:04,  DATA PACKET
	TENTRY(RTRNR)		:05,  RNR PACKET
	TENTRY(RTDAT)		:06,  DATA PACKET
	TENTRY(RTINTC)		:07,  INTERRUPT CONFIRMATION
	TENTRY(RTDAT)		:08,  DATA PACKET
	TENTRY(RTREJ)		:09,  REJ PACKET
	TENTRY(RTDAT)		:0A,  DATA PACKET
	TENTRY(RTCALR)		:0B,  CALL REQUEST PACKET
	TENTRY(RTDAT)		:0C,  DATA PACKET
	TENTRY(RTEILL)		:0D,  UNDEFINED PACKET TYPE
	TENTRY(RTDAT)		:0E,  DATA PACKET
	TENTRY(RTCALC)		:0F,  CALL ACCEPTED PACKET
	TENTRY(RTDAT)		:10,  DATA PACKET
	TENTRY(RTEILL)		:11,  UNDEFINED PACKET TYPE	:DRE 4-JAN-88
	TENTRY(RTDAT)		:12,  DATA PACKET
	TENTRY(RTCLR)		:13,  CLEAR REQUEST (INDICATION) PACKET
	TENTRY(RTDAT)		:14,  DATA PACKET
	TENTRY(RTEILL)		:15,  UNDEFINED PACKET TYPE
	TENTRY(RTDAT)		:16,  DATA PACKET
	TENTRY(RTCLRC)		:17,  CLEAR CONFIRMATION
	TENTRY(RTDAT)		:18,  DATA PACKET
	TENTRY(RTEILL)		:19,  UNDEFINED PACKET TYPE
	TENTRY(RTDAT)		:1A,  DATA PACKET
	TENTRY(RTRSE)		:1B,  RESET REQUEST (INDICATION)
	TENTRY(RTDAT)		:1C,  DATA PACKET
	TENTRY(RTEILL)		:1D,  UNDEFINED PACKET TYPE
	TENTRY(RTDAT)		:1E,  DATA PACKET
	TENTRY(RTRSEC)		:1F,  RESET CONFIRMATION


:	TABLE USED TO EVALUATE A PACKETS ACCEPTABLE NATURE.

	SEG	A.RTBL
RTGO	BC	ZDATA,ZFLOW,ZDATA,ZINTP,ZDATA,ZFLOW,ZDATA,ZINTPC
	BC	ZDATA,ZFLOW,ZDATA,ZCALRQ,ZDATA,0,ZDATA,ZCLACP
	BC	ZDATA,0,ZDATA,ZCLRQ,ZDATA,0,ZDATA,ZCLRCN	:dre 8-jan-88
	BC	ZDATA,0,ZDATA,ZRESET,ZDATA,0,ZDATA,ZRESCN


:	VALPKT - TABLE OF PACKETS THAT ARE LEGAL FOR SVCS
VALPKT	HS

:	0123456789ABCDEF	ALL EVEN # PACKETS ARE VALID AS DATA
 HC $2	1110111011111011 :0X	RR, RNR, REJ, CALLR, CALLC
 HC $2	1011101110111011 :1X	CLRI, CLRC, RESET, RESETC
 HC $2	1111111111101010 :2X	INI, INTC
 HC $2	1010101010101010 :3X
 HC $2	1110111011101010 :4X
 HC $2	1010101010101010 :5X
 HC $2	1110111011101010 :6X
 HC $2	1010101010101010 :7X
 HC $2	1110111011101010 :8X
 HC $2	1010101010101010 :9X
 HC $2	1110111011101010 :AX
 HC $2	1010101010101010 :BX
 HC $2	1110111011101010 :CX
 HC $2	1010101010101010 :DX
 HC $2	1110111011101010 :EX
 HC $2	1010101010101010 :FX
:	0123456789ABCDEF


:	VALPVC - TABLE OF PACKETS THAT ARE LEGAL FOR PVCS
  IF	PVC
VALPVC	HS
:	0123456789ABCDEF	ALL EVEN # PACKETS ARE VALID AS DATA
 HC $2	1110111011101010 :0X	RR, RNR, REJ
 HC $2	1010101010111011 :1X	RESET, RESETC
 HC $2	1111111111101010 :2X	INT, INTC
 HC $2	1010101010101010 :3X
 HC $2	1110111011101010 :4X
 HC $2	1010101010101010 :5X
 HC $2	1110111011101010 :6X
 HC $2	1010101010101010 :7X
 HC $2	1110111011101010 :8X
 HC $2	1010101010101010 :9X
 HC $2	1110111011101010 :AX
 HC $2	1010101010101010 :BX
 HC $2	1110111011101010 :CX
 HC $2	1010101010101010 :DX
 HC $2	1110111011101010 :EX
 HC $2	1010101010101010 :FX
:	0123456789ABCDEF
  EI


:	ZLCN - TABLE PACKETS THAT ARE REQUIRED TO HAVE A ZERO LCN
ZLCN	HS

:	0123456789ABCDEF
 HC $2	0000000000000000 :0X
 HC $2	0000000000000000 :1X
 HC $2	0000000000000000 :2X
 HC $2	0000000000000000 :3X
 HC $2	0000000000000000 :4X
 HC $2	0000000000000000 :5X
 HC $2	0000000000000000 :6X
 HC $2	0000000000000000 :7X
 HC $2	0000000000000000 :8X
 HC $2	0000000000000000 :9X
 HC $2	0000000000000000 :AX
 HC $2	0000000000000000 :BX
 HC $2	0000000000000000 :CX
 HC $2	0000000000000000 :DX
 HC $2	0000000000000000 :EX
 HC $2	0101000100010001 :FX	DIAG, REGR, REGC, RSTR, RSTC
:	0123456789ABCDEF


	SSTTL(MAIN LOOP)
::	RTD - RECORD TEAR DOWN
:	R15 USED BY RING LOGIC
:	R0 THRU R4 WILL BE ALTERED BY RING LOGIC
:	RL2 EQUALS TWO TIMES X25 LINK NUMBER.
:	RL EQUALS X25 LINK NUMBER
:	R5 EQUALS RTD RING OUTPUT POINTER
:	R6 EQUALS COUNT OF CHARS LEFT IN A PACKET IN RTD RING


	SEG	A.CODE
RTD	ST	R0,BCKRET		:SAVE RETURN TO CALLER
RTD010	L	R1,FG.RTD		:ANY SECTOR CHAINS TO TEAR DOWN ??
	JFFO	R1,RTD014		:GET (R2)=LINK #
	J	BGEXRT,,		:ALL LINKS (RECEIVE SECTORS) SERVICED
RTD014	LR	RL,R2
	STB	RL,LINUM		:(LINK #)
	SLLS	R2,1
	LR	RL2,R2
	STB	RL2,LINUM2		:2*(LINK #)
:
:	SEE IF ANOTHER SECTOR TO BE TORN DOWN.
:
RTD020	LH	R1,RSC.RA,RL2,		:GET CURRENT SECTOR OFFSET
	JGEFS	RTD025			:SOMEBODY IS HOME
	RBT	RL,FG.RTD		:TELL MYSELF THIS LINK IS DONE
	SBT	RL,RTD.FG		:TELL FG TO RECLAIM THESE SECTORS
	J	RTD010			:GO TO NEXT SECTOR

RTD025	LB	R2,RSC.SZ,RL,		:GET BUFFER SIZE INDEX
	SLLS	R2,1
	L	R5,RSC.BF,R2,R2		:BASE ADDRESS OF EQUAL-SIZED BUFFERS
	AR	R5,R1			:ADD OFFSET TO CURRENT BUFFER
	JAL	R0,PBT,,		:TRACE PACKETS IN RECEIVE SECTORS
	LH	R1,,R5			:GET ITS FORWARD POINTER
	STH	R1,RSC.RA,RL2,		:SAVE IT FOR RTD020 LOOP
	AIS	R5,2			:SKIP TO BYTE COUNT AND PACKET DATA
	RBT	RL,LEVEL1		:RESET GOT Q-BIT TYPE PACKET
	RBT	RL,SEEDBT		:RESET GOT DBIT PACKET
	TBT	RL,LINKUP
	JE	RTD010			:IF LINK IS NOT UP
  IF	X.32	
	LB	R1,IDSTAT,RL,		:STATE OF DTE ID PROCESSING:JS-ONREG
	CLHI	R1,IDFAL		:DTE IDENTIFICATION FAILED?:JS-ONREG
	JE	RTD020			:YES-DISCARD THE PACKET:JS-ONREG
  EI	:X.32

:	PICK OUT FIRST TWO CHARS IN RING WHICH ARE PACKET SIZE.

  IF	\PFRMAC!\PFAMAC
	ST	R5,PXSADR		:SAVE POINTER TO RTD SECTOR LENGTH
  EI

	LIS	R3,0
	STB	R3,PCTL2
	STB	R3,PSDIAS+1		:FOR TRACE PURPOSE
	LHI	R6,3			:PUT A FAKE CHAR CNT IN R6 UNTIL REAL CNT IS READ
	JAL	R4,PICKCH		:GET FIRST BYTE
	STB	R0,TEMP			:SAVE IT
	JAL	R4,PICKCH		:GET SECOND CHAR
	STB	R0,TEMP+1		:SAVE IT

:	PICK UP FIRST TWO OCTETS OF PACKET.
	LHL	R6,TEMP			:GET NUMBER OF CHARS IN PACKET
	CLHI	R6,2						:DRE 01-MAR-85
	JL	RTEIGN			:IF LESS THAN 2 BYTES, IGNORE!	:DRE 01-MAR-85
  IF	1-FML							:DRE 29-MAR-85
	TBT	RL,F128.F		:IS THIS A MOD 128 LINK?	:DRE 14-JAN-85
	JEFS	RTD028			:NO, THEN DATA IS CORRECT IN RECEIVE SECTOR:DRE 14-JAN-85
	AIS	R5,1			:YES, SKIP OVER SECOND CONTROL BYTE:DRE 14-JAN-85
  EI
RTD028	JAL	R4,PICKCH		:GET FIRST OCTET
	LR	R7,R0
	NHI	R0,0F			:GET LGN
	STB	R0,ELGN
	NHI	R7,0F0			:GET GFI
	STB	R7,TRCGFI		:SAVE FOR TRACE			:DRE 12-DEC-84
	THI	R7,DBIT
	JEFS	RTD030			:IF D BIT NOT SET
	NHI	R7,0BF			:TURN D BIT OFF
	SBT	RL,SEEDBT
RTD030	THI	R7,QBIT			:SEE IF Q BIT SET
	JEFS	RTD100			:IF NOT
	NHI	R7,7F			:TURN OFF Q BIT FOR CHECK
	SBT	RL,LEVEL1		:SET FLAG SAYING Q BIT WAS SET

:	VALIDATE GFI.
RTD100	LIS	R1,7						:DRE 12-DEC-84
	LHI	R3,SBIT
	TBT	RL,P128.F
	JEFS	RTD120			:IF MOD 8
	LHI	R1,7F
	LHI	R3,LBIT
RTD120	CR	R7,R3
	JN	RTEGFI			:IF GFI BAD
	STH	R1,PMMSK
	JAL	R4,PICKCH		:GET LOGICAL CHANNEL NUMBER
	STB	R0,ELCN			:SAVE IT
	LR	R6,R6			:TEST LENGTH OF PACKET		:DRE 01-MAR-85
	JE	RTESHT			:NO PACKET TYPE, THIS IS ERROR #38 :DRE 01-MAR-85
	JAL	R4,PICKCH		:GET PACKET TYPE
	STB	R0,PACKET
	STH	RL,IPORT
	LH	R4,ELCI			:CHECK LCN		:DRE 4-JAN-88
	JN	RTD140			:HANDLE AS NOT VALID PACKET IF 0 :DRE 4-JAN-88
	CLHI	R0,YRSTRT
	JE	RTRSTI			:IF RESTART INDICATION
	CLHI	R0,YRSTRC
	JE	RTRSTC			:IF RESTART CONFIRMATION
	CLHI	R0,YDIAG
	JE	RTDIAG			:IF DIAGNOSTIC PACKET
  IF	X.25
	CLHI	R0,YREGR		:IF REGISTRATION REQUEST PACKET :JS-ONREG
	JE	RTDREG,,		:JS-ONREG
  EI

:	CONVERT LOGICAL CHANNEL IDENTIFIER TO EXTERNAL PORT #
:	EPORT = ELCI+EPB.LT(RL2)-LCC.LT(RL2)

RTD140	LH	R4,ELCI
 IF	PVC
	LIS	R3,0
	STB	R3,PVCLCI		:CLEAR PVCHANNEL INDICATOR
	LH	R3,LPC.LT,RL2,		:LOW PVC CHANNEL NUMBER
	JLFS	RTD145			:NO PVC DEFINED, CHECK OTHER RANGES.
	CR	R4,R3			:COMPARE LCN WITH LPC
	JL	RTD460			:LOWER THAN LPC, ILLEGAL
	CH	R4,HPC.LT,RL2,		:COMPARE LCN WITH HPC
	JGFS	RTD145			:GREATER THAN HPC
	LIS	R3,1
	STB	R3,PVCLCI		:SET PVCHANNEL INDICATOR ON
	J	RTD180			:VALID PVC CHANNEL
RTD145
 EI	PVC
	LH	R3,LIC.LT,RL2,		:LOW INCOMING CHANNEL #
	JL	RTD150			:IF NO INCOMING CHANNELS	:SCHEN 20-May-85
	CR	R4,R3
	JL	RTD460			:IF LCI < LOW
	CH	R4,HIC.LT,RL2,
	JGFS	RTD150						:SCHEN 15-May-85
	LB	R0,PACKET		:GET PACKET TYPE		:SCHEN 20-May-85
	CLHI	R0,YCALR					:SCHEN 20-May-85
	JN	RTD180			:IF NOT CALL REQUEST		:SCHEN 20-May-85
	LHI	R13,CLRCAU^8!DIA034				:SCHEN 15-May-85
	J	RTD480			:LCI WITHIN LOW TO HIGH INCOMING RANGE :SCHEN 15-May-85
RTD150	LH	R3,LTC.LT,RL2,		:LOW TWO WAY CHANNEL #
	JLFS	RTD170			:IF NO TWOWAY CHANNELS
	CR	R4,R3
	JL	RTD460			:IF BETWEEN HIC AND LTC
	CH	R4,HTC.LT,RL2,
	JLEFS	RTD180			:IF IN LTC TO HTC RANGE
RTD170	LH	R3,LOC.LT,RL2,
	JL	RTD460			:IF NO OUTGOING CHANNELS
	CR	R4,R3
	JL	RTD460			:IF BETWEEN HTC AND LOC
	CH	R4,HOC.LT,RL2,
	JG	RTD460			:IF > HIGH CHANNEL
RTD180	TBT	RL,PACKUP		:IF PACKET LEVEL NOT UP, :DRE 4-JAN-88
	JE	RTEDSC			:DON'T LOOK AT ANY PACKETS :DRE 22-NOV-87
	SH	R4,LCC.LT,RL2,		:BIAS TO LOW CONFIGURED CHANNEL #
	AH	R4,EPB.LT,RL2,		:POSITION IN TABLE
	STH	R4,EPORT		:SAVE EXTERNAL PORT #
	LH	R1,EI.MT,R4,R4
	JLE	RTD400			:IF NO INTERNAL PORT ASSIGNED
	STH	R1,IPORT
	LR	R7,R1			:(R7)= IPORT
	LH	R4,ID.MT,R1,R1		:GET MAPPING TABLE ENTRY
	STH	R4,DPORT		:SAVE DISPATCHER PORT IF ANY

:	INTERNAL PORT ASSIGNED.
:	LHL	R1,IPORT
	SLLS	R1,2
	AHI	R1,IEDBIA
	STH	R1,IEDBUF
	AHI	R1,IECBIA-IEDBIA
	STH	R1,IECBUF
	LB	R1,PACKET

  IF	PVC
:	CHECK FOR PVC, IF IT IS THEN CHECK THE PACKET TYPES AND THE OTHER
:	DTE'S STATUS (UP/DOWN)
:
:	IF NOTHING IS INCORRECT OR ILLEGAL THEN PROCESS THE PACKET
:	NORMALLY.
:
	LB	R0,PVCLCI		:IS THIS A PVC ??
	JE	RTD190			:NO, JUMP OUT
	TBT	R1,ZLCN,,		:TEST AGAINST ZERO LCN TYPES :DRE 12-JAN-88
	JNFS	RTD182			:NOT LEGAL FOR PVC	:DRE 12-JAN-88
:	CLHI	R1,YRSTRT					:DRE 6-DEC-87
:	JEFS	RTD182			:IF RESTART INDICATION	:DRE 6-DEC-87
:	CLHI	R1,YRSTRC					:DRE 6-DEC-87
:	JEFS	RTD182			:IF RESTART CONFIRMATION :DRE 6-DEC-87
:	CLHI	R1,YDIAG					:DRE 6-DEC-87
:	JEFS	RTD182			:IF DIAGNOSTIC PACKET	:DRE 6-DEC-87
	JAL	R4,RTPV10		:SEE IF GOT AN 'ILLEGAL' PACKET
	J	RTD185			:PACKET LEGAL, CHECK OTHER DTE STATUS
:	PACKET ILLEGAL SEND APPROPRIATE RESET TO LINK AND NETWORK
RTD182	ERRPTRACE						:DRE 6-FEB-86
	LHI	R13,RLOCPE^8!DIA035	:LOC PROC, INVALID PACKET TYPE :DRE 25-JAN-85
	JAL	R8,RESETP,,		:SEND RESET TO LINK AND OTHER DTE
	J	RTD020
:	CHECK OTHER DTE'S STATUS\
RTD185	LHI	R13,RNETCG^8!DIA000	:START WITH 'NET CONGESTED' CAUSE :DRE 25-JAN-85
	LHL	R4,IPORT
	LB	R0,PCKSTE,R4,		:GET PACKET STATE
	CLHI	R0,PWPVCR		:ARE WE IN PVC BUILD STATE ??
	JEFS	RTD187			:YES, JUMP
	LHI	R13,ROUTOD^8!DIA000	:SEND DTE 'OUT OF ORDER' CAUSE
	LHL	R4,EPORT
	TBT	R4,PVCOUT		:IS OTHER DTE 'DOWN'
	JE	RTD190			:NO, CONTINUE NORMALLY
RTD187	CLHI	R1,YRESTC		:IS THIS A RESET CONFIRMATION ??:DRE 6-FEB-86
	JE	RTD190			:YES, PROCESS NORMALLY
	ERRPTRACE						:DRE 6-FEB-86
	LHI	R0,YREST		:SEND RESET
	STB	R0,PACKET
	JAL	R8,RESETP,,		:SEND RESET TO LINK
	J	RTD020
RTD190
  EI	PVC

:	CHECK FOR PACKETS THAT SHOULD HAVE ZERO ADDRESS	:DRE 6-DEC-87
	TBT	R1,ZLCN,,		:TEST AGAINST ZERO LCN TYPES :DRE 12-JAN-88
	JN	RTD500			:NOT LEGAL FOR PVC	:DRE 12-JAN-88
:	CLHI	R1,YRSTRT					:DRE 6-DEC-87
:	JE	RTD500			:IF RESTART INDICATION	:DRE 6-DEC-87
:	CLHI	R1,YRSTRC					:DRE 6-DEC-87
:	JE	RTD500			:IF RESTART CONFIRMATION :DRE 6-DEC-87
:	CLHI	R1,YDIAG					:DRE 6-DEC-87
:	JE	RTD500			:IF DIAGNOSTIC PACKET	:DRE 6-DEC-87

:	IF AN INCOMING CALL, HANDLE COLLISION IF ANY AND EXIT TO
:	ERROR ROUTINE.
	CLHI	R1,YCALR
	JN	RTD340			:IF NOT INCOMING CALL
	LIS	R0,1
	AHM	R0,COLLID,,
	LB	R1,PCKSTE,R7,
  IF	X.25
	CLHI	R1,PSCLRQ		:CHECK FOR STATE P7	:DRE 4-JAN-88
	JE	RTEDSC			:IGNORE IF ABOUT TO SEND A CLR :DRE 4-JAN-88
	CLHI	R1,PWCLRC		:CHECK FOR STATE P7	:DRE 4-JAN-88
	JE	RTEDSC			:IGNORE IF ONE ALREADY SENT :DRE 4-JAN-88
	CLHI	R1,PSCALR		:CHECK FOR DCE WAITING (P3) :DRE 20-JAN-88
	JE	RTD200			:HANDLE CALL COLLISION	:DRE 20-JAN-88
	CLHI	R1,PWCALC		:CHECK FOR DCE WAITING (P3) :DRE 20-JAN-88
	JE	RTD200			:HANDLE CALL COLLISION	:DRE 20-JAN-88
  EI	X.25
	ERRPTRACE			:LOG THE PACKET		:DRE 11-JAN-88
	LB	R1,PCKSTE,R7,
	LB	R13,DIAGTB,R1,		:GET DIAGNOSTIC BYTE TO SEND
	J	SNDCLR			:GO SEND CLEAR

  IF	X.25	:IMPLEMENTATION OF CALL COLLISTION CODE BEGINS HERE DRE 20-JAN-88
RTD200	ST	R5,TEMP5		:SAVE BUFFER POINTER	:DRE 20-JAN-88
	STH	R6,TEMP6		:SAVE DATA COUNT	:DRE 20-JAN-88
	LHI	R13,CNMBSY^8!DIA072	:SET ERROR TO CALL COLLISION :DRE 20-JAN-88
	STH	R13,PSDIAG,R7,R7	:SAVE THE NEW DIAGNOSTIC
	LH	R2,ID.MT,R7,R7		:GET DPORT
	JLE	RTD221			:IF ALREADY CLEANED OUT
	LI	R7,AA.CCD!CNMBSY^8!DIA072 :PREPARE ACCOUNTING MESSAGE
	JAL	R9,GENRPT,,		:SEND TO SUPE	'E00F' message
	:Removed by Louisa Hsu	:LSH 14-JUL-87
	:Won,t report call clear status until version 5
	:for fast select call
			:CHANGES BEGIN HERE			:LSH 10-FEB-87
:  IF	FSTSLT		:CHANGE TO REPORT FAST SELECT CLEAR REQUEST ACCOUNTING
:					:			:LSH 27-APR-87
:	TBT	R8,FSTSEL,,		:CLEAR CAN BE SENT FROM EITHER DTE
:	JE	RTD222			:IF NOT FAST SELECT
:	LI	R7,AA.FST!FST.CL	:REPORT FAST SELECT CLEAR
:	JAL	R9,GENRPT,,		:REQUEST (E0160003) ACCOUNTING
:RTD222	HS
:  EI	:FSTSLT		:CHANGES END HERE			:LSH 10-FEB-87

	LHL	R7,IPORT				:LSH 14-JUL-87
RTD221	LH	R1,DPORT		:GET DISPATCHER PORT
	JLE	RTD270			:IF NO DISPATCHER PORT ASSIGNED
	RBT	R1,DBKPR		:CLEAR DPORT BP BIT ARRAR - JH 4/4/86
	JEFS	RTD230			:IF WE HAVE NOT APPLIED BACK PRESSURE
	CTLMSG(SND)			:RELEASE BACKPRESSURE

:	PASS THE CLEAR REQUEST TO THE OTHER SIDE OF THE NETWORK.
RTD230	LHL	R1,DPORT
	TBT	R1,TURKEY
	JE	RTD270
	LB	R2,TURLEV,R1,
	JE	RTD268			:IF TURKEY LEVEL =0, NO WAY TO PASS INFO
: NOT A CLEAR FROM THE LINK, SO FIRST SET CLEAR INFO TO 0 FOR BCAESC :HJR-SWBT1
: BCAESC WILL BUILD ADDRESS AND FACILITY IF WE MUST RETURN CLAMN :HJR-SWBT1
RTD266	LIS	R6,0			:NOT REAL CLEAR		:HJR-SWBT1
	JAL	R7,BCAESC		:START CLEAR DATA BUF	:HJR-SWBT1
	LHI	R12,EXM17		:ESCPD CLEAR INFO MSG
	JAL	R14,MCAESC		:GO SEND CLEAR DATA MSG	:HJR-SWBT1
RTD268	TURMSG(CLEAR)			:OUTPUT CAUSE/DIAG ESCAPED MSG

RTD270	LIS	R0,AA.DBH		:'DROP BY HOST' TERM CODE
	STH	R0,TERMCD
	LH	R7,DPORT		:GET DISPATCHER PORT
	JG	RTD28A			:IF NOT ZERO
	TRAP(R2,FB)			: ZERO DISPATCHER PORT WHILE WAITING CALL CONF


:	IN WAITING CALL CONF STATE,IE, AN INCOMING CALL IS OUT.
:	SEND USER A MESSAGE TO TELL HIM WHY IT CANNOT BE COMPLETED.

RTD28A	TBT	R7,TURKEY
	JN	RTD28F			:IF DIALECT
	LHL	R5,IPORT
RTD28D	LA	R3,CLMSHD,,		:CLEAR MESSAGE HEADER
	JAL	R6,OUTCDR,,		:OUTPUT CAUSE AND DIAGNOSTIC
	LHL	R9,IPORT
	LH	R3,CLADRS+(2*CNMBSY),,	:GET OFFSET OF BUSY MESSAGE
	AI	R3,S.RT
RTD28C	LR	R2,R7			:GET DPORT
	OUTMSG(,FORCE)
	LHL	R9,IPORT
	LH	R1,PSDIAG,R9,R9		:GET CAUS,DIAG
RTD28F	JAL	R9,IDONE,,		:CLEAN UP IPORT
	JAL	R9,DDONE,,
	L	R5,TEMP5		:RESTORE BUFFER POINTER
	LH	R6,TEMP6		:RESTORE DATA COUNT
	J	RTD140
  EI	X.25

RTD340	TBT	R1,VALPKT,,		:VALID PACKET?		:DRE 11-JAN-88
	JE	RTEILL			:NO, HANDLE DIRECTLY	:DRE 11-JAN-88
	NHI	R1,1F			:USE LOW 5 BITS ONLY
	LB	R2,RTGO,R1,		:GET INTERNAL PACKET EQUIVALENT
	STB	R2,IPACKT		:SAVE IT
	LHL	R3,RTDFAN,R1,R1		:GET 64K FORWARD REFERENCE
	J	RTDFAN,R3		:GO TO SUBROUTINE, (R7) HAS IPORT


:	INTERNAL PORT NOT ASSIGNED.
:	CHECK TO SEE IF IT IS A CLEAR, CLEAR CONF., OR AN IMCOMING CALL.
:	ALSO CHECK IF PVC, IN WHICH CASE RESETS WILL BE SENT
:
RTD400
  IF	PVC
	LB	R1,PVCLCI		:IS THIS A PVC ??
	JE	RTD422			:NO, JUMP OUT	:DRE 4-JAN-88
	LHI	R13,RLOCPE^8!DIA035	:LOC PROC, INVALID PACKET :DRE 4-JAN-88
	LB	R1,PACKET
	JAL	R4,RTPV10		:CHECK IF ILLEGAL PACKET
	J	RTD410			:PACKET NOT ILLEGAL, CHECK SOME MORE
	LHI	R0,YREST		:SEND RESET PACKET
	STB	R0,PACKET
	J	RTD480
RTD410	CLHI	R1,YREST		:IS IT A RESET PACKET TYPE ??
	JNFS	RTD415			:NO, JUMP
	LHI	R0,YRESTC		:SEND RESET CONFIRMATION PACKET
	STB	R0,PACKET
	J	RTD480
RTD415	CLHI	R1,YRESTC		:IS IT A RESET CONFIRMATION PACKET ??
	JE	RTD020			:IGNORE RESET CONFIRMATIONS
RTD417	LHI	R0,YREST
	STB	R0,PACKET		:SEND RESET PACKET
	LHI	R13,RNETCG^8!DIA000	:CAUSE, NETWORK CONGESTED
	J	RTD480
  EI	PVC

RTD422	LB	R1,PACKET
:	CHECK FOR PACKETS THAT SHOULD HAVE ZERO ADDRESS	:DRE 6-DEC-87
:	CLHI	R1,YRSTRT					:DRE 6-DEC-87
:	JE	RTD500			:IF RESTART INDICATION	:DRE 6-DEC-87
:	CLHI	R1,YRSTRC					:DRE 6-DEC-87
:	JE	RTD500			:IF RESTART CONFIRMATION :DRE 6-DEC-87
:	CLHI	R1,YDIAG					:DRE 6-DEC-87
:	JE	RTD500			:IF DIAGNOSTIC PACKET	:DRE 6-DEC-87

	CLHI	R1,YCLRR
	JE	RTD480			:IF A CLEAR REQUEST
	CLHI	R1,YCALR
	JE	RTD430
	CLHI	R1,YCLRC
  IF	X.75
	JE	RTD	:IF A CLEAR CONFIRMATION
  EI
	ERRPTRACE
	JAL	R3,FINDIP,,		:GET AN AVAILABLE INTERNAL PORT:JS 29-JAN-88
	J	RTD480			:NO AVAILABLE PORT,DISCARD PACKET:JS 29-JAN-88
	JAL	R9,INICAL		:JS 29-JAN-88
	LB	R1,PACKET		:JS 29-JAN-88
	TBT	R1,ZLCN,,		:TEST AGAINST ZERO LCN TYPES :DRE 12-JAN-88
	JN	RTD500			:NOT LEGAL FOR PVC	:DRE 12-JAN-88
	LHI	R13,DIA033		:UNDEFINED PACKET	:DRE 6-JAN-88
	TBT	R1,VALPKT,,		:VALID PACKET?		:DRE 11-JAN-88
	JE	SNDCLR			:NO, HANDLE DIRECTLY	:DRE 11-JAN-88
	LHI	R13,DIA020		:ILLEGAL PACKET FOR STATE P1 :DRE 31-DEC-87
	J	SNDCLR						:DRE 6-JAN-88

:	CALL REQUEST
RTD430	LHL	R1,EPORT
	LHI	R13,CLRCAU^8!DIA023	:"CALL ON ALREADY ASSIGNED CHANNEL" :DRE 25-JAN-85
	TBT	R1,EPA.F		:CALL ON ASSIGNED CHANNEL:JS 19-FEB-88
	JN	RTD440			:NO - OK:JS 19-FEB-88
	OOPS				:YES - ERROR CALL ON ASSIGNED CHANNEL:JS 19-FEB-88
	J	RTD480			:JS 19-FEB-88
RTD440	LIS	R0,0
	STH	R0,DPORT
	J	RTCALR			:GO PROCESS CALL REQUEST

:	CHANNEL # RECEIVED IS NOT IN CONFIGURED RANGE OF CHANNELS.
:	IF NOT A CLEAR REQUEST, IGNORE THE PACKET.
:	IF A CLEAR REQUEST, SEND A CLEAR CONFIRMATION.

RTD460	TBT	RL,NDIA.F		:DIAGNOSTICS ALLOWED?	:DRE 31-DEC-87
	JEFS	RTD465			:YES, DO DIAGNOSTIC	:DRE 31-DEC-87
	LB	R0,PACKET		:NO, CHECK FOR SPECIAL CASE
	CLHI	R0,YCLRR
	JE	RTD480			:IF CLEAR REQUEST
RTD465	ERRPTRACE			:TRACE ILLEGAL PACKET
	LHI	R5,DIA036		:PACKET ON UNASSIGNED CHANNEL :DRE 31-DEC-87
:	J	SNDIAG			:SEND A DIAGNOSTIC PACKET :DRE 31-DEC-87


SNDIAG	LR	R1,RL			:FORM CONTROL BUFFER # FOR :DRE 31-DEC-87
	SLLS	R1,2			:THIS LINE		:DRE 31-DEC-87
	AHI	R1,IECBIA					:DRE 31-DEC-87
	LHI	R0,ZDIAG		:QUEUE UP DIAGNOSTIC PACKET :DRE 31-DEC-87
	JAL	R4,WCI						:DRE 31-DEC-87
	LR	R0,R5			:GET DIAGNOSTIC		:DRE 31-DEC-87
	JAL	R4,WCI						:DRE 31-DEC-87
	LIS	R0,0			:NO ADDITIONAL INFORMATION :DRE 31-DEC-87
	JAL	R4,WCI						:DRE 31-DEC-87
	J	RTD020

:	HERE IF -
:	GOT A CALL REQUEST BUT NO IPORTS AVAILABLE,
:	PACKET WAS SENT ON PVC BUT NO IPORT,
:	GOT CALL REQUEST ON ALREADY ASSIGNED CHANNEL,
:	IF PVC THEN PACKET TO SEND IS IN 'PACKET' VARIABLE
:	WHICH MAY BE A RESET OR RESET CONFIRMATION
:	IF NOT A PVC THEN
:	FOR EVERYTHING BUT A CLEAR REQUEST, SEND A CLEAR REQUEST.
:	(R13)=CAUSE AND DIAGNOSTIC TO SEND
:	FOR A CLEAR REQUEST, SEND A CLEAR CONFIRMATION.
RTD480	ERRPTRACE			:TRACE ILLEGAL PACKET
	LR	R1,RL
	SLLS	R1,2
	AHI	R1,IECBIA		:FORM BUFFER
	LHI	R0,ZILLCN
	JAL	R4,WCI
	LB	R0,ELGN
	JAL	R4,WCI
	LB	R0,ELCN
	JAL	R4,WCI
  IF	PVC
	LB	R0,PVCLCI		:IS THIS A PVC ??
	JEFS	RTD485			:NO, JUMP
	LHI	R0,YREST
	LB	R4,PACKET		:GET PACKET TYPE TO SEND
	CR	R0,R4			:IS IT A RESET ??
	JEFS	RTD490			:YES, SEND A RESET
RTD482	LR	R0,R4			:NO, ASSUME RESET CONFIRMATION
	J	RTD495
RTD485
  EI	PVC
	LHI	R0,YCLRR		:CLEAR REQUEST TYPE
	LB	R4,PACKET		:THIS PACKET TYPE
	CR	R4,R0
	JNFS	RTD490			:IF THIS PACKET NOT CLEAR REQUEST
	LHI	R0,YCLRC		:CLEAR CONF
	JFS	RTD495

RTD490	JAL	R4,WCI			:WRITE CLEAR REQUEST TYPE
	EXBR	R0,R13			:GET CAUSE TO SEND
	JAL	R4,WCI
	LR	R0,R13			:GET DIAGNOSTIC TO SEND
RTD495	JAL	R4,WCI			:SEND CLEAR DIAGNOSTIC OR CLEAR CONF
	LIS	R0,1
	AHM	R0,RTDER3,RL,RL		:INCREMENT ERROR
	J	RTD020

RTD500	LHI	R13,DIA041		:ILLEGAL LCN FOR PACKET :DRE 31-DEC-87
	LA	R12,NZRMSG,,		:NON ZERO LOGICAL CHANNEL ON RESTART
	OOPS							:DRE 4-JAN-88
	J	RTELN1			:HANDLE ERROR FOR STATE	:DRE 4-JAN-88
  IF	PVC
:	ROUTINE TO CHECK FOR INVALID/ILLEGAL PACKETS ON A PVC
:	(NOT ALL INVALID CONDITIONS ARE TESTED/ FIRST 3 BITS ARE UNCHECKED)
:
:	R4 = NORMAL RETURN
:	R4+4 = INVALID PACKET RETURN
:	R1 = PACKET TYPE UPON ENTERING ROUTINE
:
RTPV10	:CLHI	R1,YCLRR		:IS IT CLEAR REQUEST ??
:	JE	4,R4			:YES, JUMP			:DRE 25-JAN-85
:	CLHI	R1,YCLRC		:IS IT CLEAR CONFIRMATION ??
:	JEFS	RTPV11			:YES, JUMP
:	CLHI	R1,YCALR		:IS IT CALL REQUEST ??
:	JEFS	RTPV11			:YES, JUMP
:	CLHI	R1,YCALA		:IS IT CALL ACCEPT ??
:	JEFS	RTPV11			:YES, JUMP
	TBT	R1,VALPVC,,		:VALID PACKET?		:DRE 11-JAN-88
:	NHI	R1,1F			:USE ONLY LOWER 5 BITS
					:TO CHK INVALID PACKET TYPE
:	LB	R2,RTGO,R1,		:GET INTERNAL PACKET EQUIVALENT
	JNR	R4						:DRE 25-JAN-85
RTPV11	J	4,R4						:DRE 25-JAN-85
  EI	PVC

	SSTTL(RESTART INDICATION/ CONFIRMATION)
:	PROCESS RESTART INDICATION.

RTRSTI	TBT	RL,LEVEL1		:CHECK FOR BAD GFI	:DRE 31-DEC-87
	JN	RTEGFI			:IF Q BIT ON		:DRE 31-DEC-87
	TBT	RL,SEEDBT					:DRE 31-DEC-87
	JN	RTEGFI			:IF D BIT ON		:DRE 31-DEC-87
	CLHI	R6,2
	JG	RSTLNG			:IF PACKET TOO LONG	:DRE 5-JAN-88
:	LHL	R1,ELCI			:CHECKED IN RTD MAIN LOGIC :DRE 4-JAN-88
:	JEFS	TRI010			:IF 0 LOGICAL CHANNEL
:	LHI	R13,DIA041
:	LA	R12,NZRMSG,,		:NON ZERO LOGICAL CHANNEL ON RESTART
:	J	RTELN1			:GO TO ERROR ROUTINE

TRI010	LR	R6,R6
	JE	RSTSHT			:IF NO CAUSE FIELD
	JAL	R4,PICKCH		:GET CAUSE FIELD
	STB	R0,PCTL2		:SAVE FOR TRACE
	LIS	R0,0
	LR	R6,R6
	JEFS	TRI020			:IF NO DIAGNOSTIC CODE
	JAL	R4,PICKCH
TRI020	STB	R0,PSDIAG+1,RL,RL
	STB	R0,PSDIAS+1		:SAVE FOR TRACE

:	QUEUE UP A RESTART CONFIRMATION AND GO TO SEND RESTART CONF STATE.
	LR	R1,RL
	SLLS	R1,2
	AHI	R1,IECBIA
	JAL	R4,EMPTY,,		:CLEAR QUEUE
  IF  X.75							:DRE 1-JUN-87
	LHI	R5,8000			:INDICATE "NETWORK CONGESTION" HEADER
	LB	R2,PCTL2		:GET SAVED CAUSE CODE	:DRE 1-JUN-87
	CLHI	R2,RSTNCG		:IS THIS NETWORK CONGESTION? :DRE 1-JUN-87
	JN	TRI024			:NO, IGNORE DIAGNOSTIC CODE :DRE 1-JUN-87
	LB	R0,PSDIAS+1		:TEST THE DIAGNOSTIC CODE :DRE 1-JUN-87
	JEFS	TRI024			:ZERO IS UNCHANGED	:DRE 1-JUN-87
	LHI	R4,DIA114		:SET UP FOR 1 TO 111	:DRE 1-JUN-87
	CLHI	R0,DIA112		:COMPARE WITH HIGHEST PROTOCOL ERROR :DRE 1-JUN-87
	JLFS	TRI022			:CONVERT TO 114		:DRE 1-JUN-87
	LHI	R4,DIA113		:SET UP FOR NETWORK ERROR :DRE 1-JUN-87
	CLHI	R0,DIA128		:COMPARE WITH NETWORK	:DRE 1-JUN-87
	JLFS	TRI024			:NOT A NETWORK ERROR	:DRE 1-JUN-87
TRI022	STB	R4,PSDIAG+1,RL,RL	:STORE IN PER LINE AREA	:DRE 1-JUN-87
TRI024	LHI	R2,CNETCG		:SET ALL CAUSES		:DRE 1-JUN-87
	STB	R2,PSDIAG,RL,RL		:TO CLEAR NETWORK CONGESTION :DRE 1-JUN-87					:DRE 1-JUN-87
  ELSE  X.25							:DRE 1-NOV-85
	LHI	R5,1000			:INDICATE "DTE ORIGINATED" HEADER :DRE 20-JAN-88
	LB	R2,PCTL2		:GET SAVED CAUSE CODE	:DRE 1-JUN-87
	STB	R2,PSDIAG,RL,RL					:DRE 1-NOV-85
	JEFS	TRI025			:ZERO IS ALWAYS OK	:DRE 1-NOV-85
	THI	R2,80			:IS BIT 8 ON?		:DRE 1-NOV-85
	JNFS	TRI025			:ANYTHING WITH THE BIT ON IS OK	:DRE 1-NOV-85
	TBT	RL,PCAU.F		:DO WE ALLOW NETWORK CAUSE CODES THROUGH?
	JNFS	TRI025			:YES, LET IT GO THROUGH	:DRE 1-NOV-85
	LHI	R5,DIA081		:SET UP BAD CAUSE DIAG	:DRE 5-JAN-88
	J	RSTLN1			:SEND A DIAGNOSTIC INSTEAD :DRE 5-JAN-88
  EI	X.25							:DRE 1-NOV-85
TRI025	PTRACE
	RBT	RL,PACKUP					:DRE 5-JAN-88
	JEFS	TRI030			:IF PACKET LEVEL WAS NOT UP :DRE 5-JAN-88
	JAL	R9,HANGAL,,		:GO TO HANG LOGIC	:DRE 1-NOV-85
TRI030	LB	R1,PCKSTE,RL,					:DRE 5-JAN-88
	CLHI	R1,PWRSTC		:WAITING FOR RESTART CONF? :DRE 5-JAN-88
	JE	TRC050			:IF SO SET PACKET LEVEL UP :DRE 5-JAN-88
	CLHI	R1,PSRSTC
	JE	RTD020			:IF ABOUT TO SEND RESTART CONF
:					:IGNORE THIS RESTART
	LR	R1,RL
	SLLS	R1,2
	AHI	R1,IECBIA
	LHI	R0,ZRSTRC		:GET RESTART CONFIRMATION PACKET TYPE
	JAL	R4,WCI			:PUT ON QUUEUE
	LHI	R0,PSRSTC		:GET SEND RESTART CONF. STATE
	STB	R0,PCKSTE,RL,
	J	RTD020
RSTSHT	LHI	R5,DIA038		:RESTART TOO LONG	:DRE 5-JAN-88
	JFS	RSTLN1			:SEND A DIAGNOSTIC OR RESTART :DRE 5-JAN-88
RSTLNG	LHI	R5,DIA039		:RESTART TOO LONG	:DRE 5-JAN-88
RSTLN1	ERRPTRACE						:DRE 11-JAN-88
	LIS	R13,PREADY		:LOAD UP READY STATE	:DRE 6-JAN-88
	CLB	R13,PCKSTE,RL,		:CHECK FOR R1 STATE	:DRE 6-JAN-88
	JE	SNDIAG			:SEND A DIAGNOSTIC PACKET :DRE 5-JAN-88
	LR	R13,R5			:COPY THE DIAGNOSTIC	:DRE 6-JAN-88
	J	SNDRST			:INVOKE ERROR FOR R3 STATE :DRE 6-JAN-87

:	PROCESS RESTART CONFIRMATION.
:	IF WE HAVE A RESTART OUT, FLAG PACKET LEVEL AS BEING UP.

RTRSTC	TBT	RL,LEVEL1		:CHECK FOR BAD GFI	:DRE 31-DEC-87
	JN	RTEGFI			:IF Q BIT ON		:DRE 31-DEC-87
	TBT	RL,SEEDBT					:DRE 31-DEC-87
	JN	RTEGFI			:IF D BIT ON		:DRE 31-DEC-87
	LR	R6,R6
	JG	RSTLNG			:IF PACKET TOO LONG	:DRE 5-JAN-88
:	LHL	R1,ELCI						:DRE 4-JAN-88
:	JEFS	TRC015			:IF 0 LOGICAL CHANNEL
:	LHI	R13,DIA041		:DIAGNOSTIC FOR NON-ZERO RESTART CHANNEL
:	LA	R12,NZRMSG,,
:	J	RTELN1			:GO TO ERROR ROUTINE

TRC015	PTRACE
	LB	R1,PCKSTE,RL,
	CLHI	R1,PWRSTC		:SEE IF IN WAITING RESTART CONF. STATE
	JE	TRC050			:IF SO, SET PACKET LEVEL UP
	LHI	R13,DIA018
	CLHI	R1,PSRSTC
	JEFS	SNDRST			:IF IN SEND RESTART CONF STATE
	LHI	R13,DIA017

:	SEND BACK A RESTART PACKET AND HANG ANY USERS IF ON.
:	(R13)= DIAGNOSTIC CODE TO USE
SNDRST	OHI	R13,CLRCAU^8
	STH	R13,PSDIAG,RL,RL
	LR	R1,RL
	SLLS	R1,2
	AHI	R1,IECBIA
	JAL	R4,EMPTY,,		:EMPTY IEC BUFFER
	RBT	RL,PACKUP
	JEFS	TRC030			:IF PACKET LEVEL ALREADY DOWN
	LIS	R5,0			:INDICATE LOCAL HEADER
	JAL	R9,HANGAL,,

:	SEND RESTART INDICATION.
TRC030	LHI	R13,RSTCAU
	STB	R13,PSDIAG,RL,RL
	LHI	R0,PSRSTI
	STB	R0,PCKSTE,RL,		:PUT IN SEND RESTART INDICATION STATE
	LR	R1,RL
	SLLS	R1,2
	AHI	R1,IECBIA
	LHI	R0,ZRSTRT
	JAL	R4,WCI
	J	RTD020

:	SET PACKET LEVEL UP.
TRC050	HS
  IF	XOM
	TBT	RL,XOMBPD
	JNFS	TRC060			:IF XOM DOESN'T WANT PACKET LEVEL BROUGHT UP
  EI
	SBT	RL,PACKUP		:FLAG PACKET LEVEL UP
  IF	PVC
	JAL	R9,PKLVUP,,		:CHK FOR PVC'S TO SEND RESET, DTE OPERATIONAL
  EI	PVC
TRC060	LIS	R0,PREADY
	STB	R0,PCKSTE,RL,
	RBT	RL,TNTA.F
	LR	R1,RL
	SLLS	R1,2
	AHI	R1,IECBIA
	JAL	R4,EMPTY,,		:CLEAR QUEUE
	J	RTD020


:	DIAGNOSTIC PACKET, IGNORE.
RTDIAG	J	RTEDSC

	SSTTL(DATA PACKET)

::	PROCESS DATA PACKETS.
:	REGS R5,R6, AND RL THRU R15 RESRVED.
:	R7 has IPORT

RTDAT
  IF	X.25
	LHI	R13,RSEINC^8!DIA040	:INCOMPATIBLE DESTINATION
  ELSE	X.75
	LHI	R13,RNETCG^8!DIA040	:NETWORK CONGESTION
  EI
	LA	R12,RSMSGA,,
	TBT	RL,SEEDBT
	JN	SNDRS0			:IF DBIT ON, GO SEND RESET
  REMIND(RTDAT- SEND RESET ON DATA PACKET WITH D-BIT FOR NOW)
	JAL	R4,RACCPT		:SEE IF ACCEPTABLE AT THIS TIME

	STH	R6,RUFCNR
	JAL	R4,CIP1SX,,		:UPDATE INPUT PACKET COUNT:LSH 14-JUL-87
TDA020	TBT	RL,P128.F
	JEFS	TDA025			:IF NOT MOD128
	LR	R6,R6
	JE	RTESHT			:IF PACKET TOO SHORT
	JAL	R4,PICKCH		:GET P(R)
	STB	R0,PCTL2		:SAVE FOR PACKET TRACE
	STB	R0,RMPRV		:SAVE BYTE FOR LATER
TDA025	PTRACE
:	RETURN HERE IF PACKET OK TO DO. EVALUATE P(R) AND P(S)
	LHL	R0,PMMSK		:GET MODULUS MASK INTO REGISTER
	LB	R2,PACKET		:GET PACKET TYPE
	SRLS	R2,1			:GET P(S) INTO POSITION
	NR	R2,R0			:MASK OFF ONLY P(S)
	CLB	R2,PPR,R7,		:SEE IF P(S) EQUALS OUR P(R)
	JN	RTEPS			:ERROR IF NOT, SEND RESET

:	MAKE SURE P(S) OF THIS PACKET IS NOT OUTSIDE WINDOW.
	LB	R3,LTPR,R7,		:GET LAST XMITTED P(R)
	LB	R4,PWRCV,R7,		:GET WINDOW SIZE
	AR	R3,R4			:CALCULATE UPPER EDGE OF WINDOW
	NR	R3,R0			:MAKE RESULT MODULO
	SR	R3,R2			:SUBTRACT P(S) FROM UPPER EDGE OF WINDOW
	JE	RTEPS2			:IF EQUAL THEN PACKET IS NOT ALLOWED.

:HANDLE WINDOW ROTATION HERE
	SBT	R7,WINROT		:INDICATE NECESSITY OF WINDOW ROTATION
	RBT	R7,WINROX		:CLEAR DELAY FLAG
	SRLS	R4,1			:DIVIDE WINDOW BY 2
	NR	R3,R0			:MAKE DISTANCE FROM UPPER EDGE MODULO
	CLR	R3,R4			:COMPARE POSITION IN WINDOW WITH HALF POINT
	JLEFS	TDA030			:DO NOT DELAY IF MORE THAN HALF WAY INTO WINDOW
	SBT	R7,WINROX		:DELAY ONE BACKGROUND FOR ROTATION
TDA030	AIS	R2,1
	NR	R2,R0
	STB	R2,PPR,R7,		:UPDATE P(R) TERM

:	SEE IF P(R) IS VALID AND ACKS ANY PACKETS OUT
	LB	R8,PACKET		:GET P(R)
	SRLS	R8,5
	TBT	RL,P128.F
	JEFS	TDA040			:IF MOD 8
	LB	R8,RMPRV		:GET P(R) FOR MOD 128
	SRLS	R8,1
TDA040	JAL	R9,CPR			:CHECK P(R) VALUE
	SKIPAD(RTEPR)			:INVALID P(R) VALUE, SEND RESET

:	CHECK TO SEE HOW MANY CHARS LEFT IN RING FOR PACKET TO MAKE
:	SURE NOT GREATER THAN ALLOWED.  UPDATE CHARACTER COUNTS FOR DPORT,
:	LINK, AND INTERFACE.
	CH	R6,PSRCV,R7,R7		:RECEIVE PACKET SIZE
	JG	DATLNG			:RESET IF SIZE GREATER THAN ALLOWED
	LHL	R9,DPORT
	SLLS	R9,2
	AM	R6,COCNT,R9,		:DATA CHAR OUT PER DPORT
	AM	R6,CCNTLK,RL2,RL2	:DATA CHAR OUT FOR LINK
	AM	R6,CHRTOT		:DATA CHAR OUT FOR WHOLE INTERFACE

:	SEE IF THIS IS A Q-BIT DATA PACKET. IF SO IT REQUIRES SPECIAL
:	HANDLING.
	LIS	R9,0			:ACCUMULATE FLAG BYTE
	TBT	R7,LSTMBT
	JE	TDA055			:IF LAST PACKET MBIT=0
	TBT	R7,LSTQBT
	JEFS	TDA050			:IF LAST PACKET QBIT=0
	TBT	RL,LEVEL1
	JE	RTEQB			:IF LAST M=1, Q=1 BUT THIS Q=0, RESET
	JFS	TDA055

TDA050	TBT	RL,LEVEL1
	JN	RTEQB			:IF LAST M=7, Q=0 BUT THIS Q=1, RESET
TDA055	RBT	R7,LSTMBT		:ASSUME M=0
	SBT	R7,LSTQBT		:ASSUME Q=1
	TBT	RL,P128.F
	JEFS	TDA060			:IF NOT MOD128
	LB	R2,RMPRV		:GET BYTE
	THI	R2,MBIT
	JFS	TDA065			:GO SEE IF M BIT SET

TDA060	LB	R2,PACKET
	THI	R2,MBIT^4
TDA065	JEFS	TDA070			:IF M BIT NOT SET
	CH	R6,PSRCV,R7,R7		:RECEIVE PACKET SIZE
	JNFS	TDA070			:IF NOT FULL PACKET, IGNORE M-BIT
	SBT	R7,LSTMBT		:FLAG LAST AS MBIT
	OHI	R9,MBIT
TDA070	LHI	R13,DIA128		:IN CASE NO DPORT
	LH	R1,DPORT
	JLE	RTEDEC			:IF NO DISPATCHER PORT ASSIGNED
	TBT	RL,LEVEL1
	JN	TDA160			:IF THIS HAD Q BIT SET
	RBT	R7,LSTQBT		:FLAG LAST NO Q BIT
	TBT	R7,IFLUSH
	JN	TDA300			:IF IN DATA FLUSH MODE

:	NOT A Q-BIT. MOVE DATA FROM RTD RING TO DISPATCHER RING.
:	SEE IF CHANNEL IS IN NETWORK LOGIN MODE, IF SO JUST PUT DATA IN
:	DISPATCHER BUFFER.
	TBT	R1,CHLOGN		:SEE IF IN LOGIN MODE		:DRE 12-DEC-84
	JE	TDA120
	SLLS	R1,2
	AHI	R1,IDBIA		:FORM DISPATCHER BUFFER
	LR	R0,R6
	JE	TDA300			:IF ZERO LENGTH DATA PACKET
	JAL	R4,WCI			:PUT PCKET BYTE COUNT AS FIRST CHAR IN BUFFER
TDA100	JAL	R4,PICKCH		:GO GET A CHAR
	JAL	R4,WCI
	LR	R6,R6			:SEE IF DONE
	JNBS	TDA100
	J	TDA300

TDA120	HS
  IF	DDTDIA-2
	LB	R0,TCANFL,,		:SEE IF CANNING X LINK DATA
	JN	TDA300			:IF SO
  EI	DDTDIA-2
	TBT	R1,TURKEY		:SEE IF PORT IN DIALECT MODE
	JN	TDA170			:IF SO

:	SEE IF NUMBER OF CHARS IN DATA FIELD OF PACKET WILL EXCEED
:	MAXIMUM ALLOWED IN DATA TEXT MESSAGE TO DISPATCHER
:
TDA130	LR	R0,R6			:PUT COPY OF CHARS IN RING
	JE	TDA290			:IF NO CHARS
	SHI	R6,CM.FST-1
	JLEFS	TDA140			:IF WIL FIT IN ONE MESSAGE
	LHI	R0,CM.FST-1		:USE MAX
TDA140	LR	R8,R6			:PUT COUNT LEFT IN R8
	LR	R6,R0			:GET COUNT BEING USED
	LR	R2,R0			:GET CHAR COUNT FOR TEXT MSG.
	AIS	R0,3			:ADJUST COUNT TO INCLUDE PORT NUMBER
					:AND CHAR COUNT
	JAL	R4,BSLOR,,		:GO START OUTPUT RECORD
  IF	PDO.|XONOF|			:IF AT LEAST ONE LINK CAN XON/OFF BACKPR.
	LHL	R9,IPORT
	TBT	R9,RXONEN,,		:JS 12-SEP-86
	JE	TDA150			:IF XON/XOFF FEATURE DISABLED FOR THIS PORT
	ST	R10,ATRSAV,,		:STORE FOR LINK NUMBER	:SCHEN 4-Nov-85
	LR	R10,R6			:ACTUAL CHAR COUNT (NOT INCL. XON AND XOFFS) :SCHEN 17-Sep-85
TDA141	JAL	R4,PICKCH
	LR	R7,R0
	NHI	R7,07F			:MASK OFF PARITY
	CLHI	R7,XON
	JNFS	TDA142			:IF NOT AN XON CHAR
	RBT	R9,XBKPR		:RELEASE BACKPRESSURE
	JEFS	TDA142			:IF NONE WAS APPLIED, TREAT AS DATA CHAR
	SIS	R10,1			: ELSE TREAT AS CTL CHAR (TRASH IT) :SCHEN 17-Sep-85
	JFS	TDA146

TDA142	CLHI	R7,XOFF
	JNFS	TDA144			:IF NOT AN XOFF CHAR
	SBT	R9,XBKPR		:APPLY BACKPRESSURE TO THIS PORT
	JNFS	TDA144			:IF ALREADY APPLIED TREAT AS DATA CHAR
	SIS	R10,1			: ELSE TREAT AS CTL CHAR (TRASH IT) :SCHEN 17-Sep-85
	JFS	TDA146

TDA144	JAL	R4,BPUTCH		:PUT CHAR INTO DISPATCHER RING
TDA146	LR	R6,R6
	JN	TDA141			:IF MORE CHARS TO PROCESS
	LR	R3,R10						:SCHEN 17-Sep-85
	L	R10,ATRSAV,,		:GET LINK NUMBER	:SCHEN 4-Nov-85
	JAL	R4,BELODR,,		:END DATA RECORD
	J	TDA152
  EI

TDA150	LB	R0,,R5			:GET CHAR FROM RTD BUFFER
	JAL	R4,BPUTCH		:PUT CHAR IN DISPATCHER RING
	AIS	R5,1			:UPDATE POINTER
	SIS	R6,1			:DECREMENT COUNTER
	JNBS	TDA150			:IF NOT GONE TO ZERO
:								:ISW 20-Jul-84
  IF	TCRLF							:ISW 20-Jul-84
:								:ISW 20-Jul-84
:IF TRANSPAC <LF> INSERTION SIMULATION IS SUPPORTED AND ENABLED	:ISW 20-Jul-84
:    THEN CHECK IF THE LAST CHARACTER IN THE PACKET IS <CR>.	:ISW 20-Jul-84
:  IF IT IS, THEN PUT A <LF> IN IEDBUF TO BE SENT TOWARD PAD.	:ISW 20-Jul-84
:								:ISW 20-Jul-84
	NHI	R0,7F			:MASK OFF MSB		:ISW 20-Jul-84
	CHI	R0,0D			:IS IT A <CR>?		:ISW 20-Jul-84
	JN	TDA151			:NO			:ISW 20-Jul-84
	LHL	R9,IPORT					:ISW 20-Jul-84
	TBT	R9,SIMLFI		:SIMULATING <LF> INSERTION?	:ISW 20-Jul-84
	JE	TDA151			:NO			:ISW 20-Jul-84
:								:ISW 20-Jul-84
:	SIMLFI=TRUE IMPLIES ITICAL=1 & EXTCAL=1			:ISW 20-Jul-84
:		SEE CODE NEAR (RT)PCR500 AND (MI)STP33D		:ISW 20-Jul-84
	TBT	R9,LX3P2		:IS EXTERNAL PAD ECHOING?	:ISW 20-Jul-84
	JE	TDA151			:NO			:ISW 20-Jul-84
	LHL	R1,IEDBUF					:ISW 20-Jul-84
	LHI	R0,ZDATA		:TYPE = DATA		:ISW 20-Jul-84
	JAL	R4,WCI						:ISW 20-Jul-84
	LIS	R0,2			:LENGTH=2, A FLAG BYTE AND <LF>	:ISW 20-Jul-84
	WHI				:WRITE LENGTH		:ISW 20-Jul-84
	LIS	R0,0A			:FLAG=0, DATA=<LF>	:ISW 20-Jul-84
	WHI							:ISW 20-Jul-84
TDA151								:ISW 20-Jul-84
  EI	TCRLF							:ISW 20-Jul-84

	JAL	R4,BELOR,,		:END LOGICAL RECORD

:	CHECK R8 TO SEE IF ANY MORE DATA TO DO
TDA152	LR	R6,R8
	JLE	TDA290			:IF ALL DONE
	LHL	R1,DPORT		:GET DISPATCHER PORT
	J	TDA130			:GO BACK AND FINISH


:	DIALECT MODE, PUT DATA OUT IN ESCAPED MESSAGE FORMAT.
:	(R6)= PACKET BYTE COUNT
:	(R9) HAS MBIT IF THIS PACKET HAS M=1

:	Q-BIT PACKET.
TDA160	TBT	R1,TURKEY
	JE	RTLEV1,,		:IF NOT DIALECT MODE
	LHI	R12,EXM2
	STB	R12,TEMP2		:STORE ESCAPED CODE TO USE
	JFS	TDA175

:	NON Q-BIT PACKET.
TDA170	LHI	R12,EXM0
	STB	R12,TEMP2		:STORE ESCAPED CODE FOR DATA
TDA175	LB	R2,TURLEV,R1,
	CLHI	R2,1
	JGE	TDA270			:IF TURKEY LEVEL >0,USE NEW ESCAPED MESSAGE
	LHL	R4,PSRCV,R7,R7
	SHI	R4,$A128
	JE	TDA190			:IF PACKET SIZE 128, DO NOTHING TO GROUP
	JGFS	TDA180			:IF PACKET > 128
	RBT	R7,LSTMBT		:TURN OFF M-BIT
	J	TDA190

:	PACKET SIZE > 128, NEED TO BREAK IT UP IN CHUNKS OF 128
:	SO THE OTHER SIDE WOULD NOT END UP SENDING IT AS IS.
TDA180	STH	R6,TEMP1		:STORE TOTAL LENGTH
TDA185	LH	R6,TEMP1		:GET CURRENT LENGTH
	JLE	TDA290			:IF END
	LR	R4,R6
	LHL	R7,IPORT
	RBT	R7,LSTMBT		:ASSUME M-BIT OFF
	SHI	R4,$A128
	JLEFS	TDA190			:IF PACKET SIZE <= 128
	SBT	R7,LSTMBT		:SET M-BIT
	LHI	R6,$A128		:COPY FULL PACKET WORTH

:	PUT OUT PACKET IN ESCAPED MESSAGE FORMAT IN CHUNCKS OF 128.
:	(R6)=
TDA190	STH	R4,TEMP1		:STORE REMAINING LENGTH
	LB	R12,TEMP2		:GET ESCAPED CODE,
	TBT	R7,LSTMBT
	JEFS	TDA200			:IF M BIT NOT SET
	AIS	R12,1			:INDICATE M=1
TDA200	LR	R0,R6
	LR	R8,R6			:SAVE PACKET BYTE COUNT
	SHI	R6,CM.FST-1-3		:SUBTRACT OUT 2/IIX HEADR, 1/LEN
	JLEFS	TDA210			:IF WILL FIT IN ONE MESSAGE
	LHI	R0,CM.FST-1-3
TDA210	LR	R7,R0			:NO OF CHARS TO PUT IN THIS MESSAGE
	AIS	R7,1			:ACCOUNT FOR LENGTH BYTE
	JAL	R9,ESCAPN,,
	LR	R0,R8			:GET PACKET COUNT
	JAL	R4,BPUTCH
	LR	R8,R6			:SET UP REMAINING CHAR COUNT
	LR	R6,R7			:GET BACK NO. OF CHARS IN THIS MESSAGE
	SIS	R6,1
	JAL	R7,ESCDTA		:FINISH OFF ESCAPED MESSAGE
	J	TDA185			:SEE IF ANYMORE TO PUT OUT


:	TURKEY LEVEL GREATER THAN 0, OK TO PUT OUT NEW ESCAPED DATA MESSAGE.
:	EXM14/ FLAG BYTE/ 2 BYTE LENGTH
TDA270	LHI	R12,EXM14
	LR	R0,R6
	LR	R8,R0			:STORE TOTAL LENGTH
	SHI	R6,CM.FST-1-5		:ACCOUNT FOR 2/IIX HEADR, 1/FLAG BYTE, 2/LEN
	JLEFS	TDA280			:IF WILL FIT IN ONE MESSAGE
	LHI	R0,CM.FST-1-5		:USE MAX
TDA280	LR	R7,R0
	AIS	R7,2+1			:ACCOUNT FOR LENGTH + FLAG BYTE
	JAL	R9,ESCAPN,,		:GET MESSAGE STARTED
	LHL	R2,IPORT
	LIS	R0,0			:NO Q-BIT
	TBT	RL,LEVEL1
	JEFS	TDA282			:IF NOT Q-BIT
	LHI	R0,QBIT
TDA282	TBT	R2,LSTMBT
	JEFS	TDA285			:IF NO M-BIT
	OHI	R0,MBIT
TDA285	JAL	R4,BPUTCH		:OUTPUT FLAG BYTE
	LR	R0,R8
	EXBR	R0,R0			:GET FIRST BYTE OF LENGTH
	JAL	R4,BPUTCH
	LR	R0,R8			:SECOND BYTE OF LENGTH
	JAL	R4,BPUTCH,,
	LR	R8,R6
	LR	R6,R7			:GET BACK NO. CHARS IN THIS MSG
	SIS	R6,3
	JAL	R7,ESCDTA		:FINISH OFF ESCAPED MESSAGE

:	UPDATE RTD POINTERS AND EXIT.
TDA290	LHL	R7,DPORT		:GET DISPATCHER PORT
	SBT	R7,OSTD			:SET OUTPUT STARTED FLAG
	SBT	R7,OTMR			:SET OUTPUT ONGOING FLAG
	TBT	R7,GBOUT		:GREEN BALL OUT ??
	JEFS	TDA300			:IF NOT
	SBT	R7,RBOUT		:FLAG RB OUT
	JNFS	TDA300			:IF ALREADY ONE OUT
	CTLMSB(RB,RX3)			:SEND ONE
TDA300	J	RTD020
	SSTTL(CONTROL PACKETS)


:	PROCESS AN RR PACKET.

RTRR	JAL	R4,RTACCP		:SEE IF ACCEPTABLE
	TBT	RL,P128.F
	JNFS	TRR010			:IF NOT MOD128
	LB	R8,PACKET		:GET PACKET TYPE
	SRLS	R8,5
	JFS	TRR015

TRR010	LR	R6,R6			:MAKE SURE AT LEAST ONE MORE BYTE
	JE	RTESHT			:IF PACKET TOO SHORT
	JAL	R4,PICKCH		:GET P(R) OCTET
	STB	R0,PCTL2		:SAVE FOR TRACE TABLE
	LR	R8,R0
	SRLS	R8,1			:SHIFT P(R) INTO POSITION
TRR015	PTRACE
	LR	R6,R6			:MAKE SURE NO MORE DATA
	JN	RTELNG			:PACKET TOO LONG
	LHL	R7,IPORT
:	USE P(R) TO OPEN OUR WINDOW, MAYBE..
	JAL	R9,CPR			:CHECK P(R) VALUE
	SKIPAD(RTEPR)			:BAD P(R)

	RBT	R7,IBKPR		:RESET ISIS BACKPRESSURE
	J	RTD020			:ALL DONE


:	PROCESS AN RNR PACKET.
RTRNR	JAL	R4,RTACCP
	TBT	RL,P128.F
	JNFS	TRN010			:IF NOT MOD128
	LB	R8,PACKET		:GET P(R)
	SRLS	R8,5
	JFS	TRN015

TRN010	LR	R6,R6			:MAKE SURE AT LEAST ONE MORE BYTE
	JE	RTESHT
	JAL	R4,PICKCH		:GET P(R) OCTET
	STB	R0,PCTL2		:SAVE FOR PACKET TRACE
	LR	R8,R0
	SRLS	R8,1			:SHIFT P(R) INTO POSITION
TRN015	PTRACE
	LR	R6,R6			:MAKE SURE NO MORE DATA
	JN	RTELNG			:PACKET TOO LONG
	LHL	R7,IPORT
	JAL	R9,CPR			:CHECK P(R) VALUE
	SKIPAD(RTEPR)			:INVALID P(R), RESET

:	APPLY BACKPRESSURE ON DISPATCHER PORT.
	SBT	R7,IBKPR		:SET BACK PRESSURE FLAG
	LH	R1,DPORT		:GET DISPATCHER PORT
	JLE	RTD020			:IF NONE ASSIGNED
	SBT	R1,DBKPR		:SET BACK PRESSURE FLAG
	JN	RTD020			:IF ALREADY SET
	CTLMSG(NOS)			:APPLY BACK PRESSURE
	LIS	R0,1
	AHM	R0,BKPSNT,,
  IF	DDTDIA-1
	AHM	R0,BKP2NT		:COUNT # TIMES SENT FOR DDT DIAGNOSTIC
  EI	DDTDIA-1
	J	RTD020


:	PROCESS AN INTERRUPT PACKET.
RTINT	LB	R1,PACKET
	CLHI	R1,YINTP		:VERIFY AN INTERRUPT PACKET
	JN	RTEILL
	JAL	R4,RTACCP		:SEE IF ACCEPTABLE
	JAL	R4,CIP1S1,,		:UPDATE INPUT PACKET COUNT:LSH 14-JUL-87
	LR	R6,R6			:MAKE SURE A DATA BYTE LEFT
	JLE	RTESHT			:IF TOO SHORT
	PTRACE				:INPUT PACKET TRACE
	LHL	R1,DPORT
	LHI	R13,DIA044
	TBT	R1,TURKEY		:IF NOT IN DIALECT MODE
	JE	TIN020
	SBT	R1,RFLINT		:SET FLAG SAYING INTERRUPT OUT IN XSPARENCY
	JN	SNDRSE			:IF IN PROCESS OF DOING ONE ALREADY

:BEGIN OF CHENGE FOR EXT. INTERRUPT PACKET		:AHM-XINTRPT 05-AUG-87
	LB	R2,TURLEV,R1,		:GET LEVEL
	CLHI	R6,1			:CHECK DATA BYTE LENGTH
	JE	TIN012			:IF DATA BYTE = 1

:	PROCESS EXTENDED INTERRUPT PACKET
	CLHI	R6,20			:CHECK DATA BYTE LENGTH
	JG	RTELNG			:IF DATA BYTE > 32, PACKET TOO LONG
	CLHI	R2,2			:CHECK TURKEY LEVEL
	JLE	RTEINT			:IF TURKEY LEVEL <= 2, RESET CIRCUIT
	
:	START PROCESS INTERRUPT PACKET, 1 <= DATA BYTE LENGTH <= 32
:	EXM1B/DATA BYTE LENGTH/DATA BYTE(S)
TIN011	LHI	R12,EXM1B		:START PROCESS INT. PACKET
	LR	R7,R6
	AIS	R7,1			:ACCOUNT FOR ONE BYTE OF LENGTH
	JAL	R9,ESCAPN,,		:GET MESSAGE STARTED
	LR	R0,R6			:GET BYTE OF LENGTH
	JAL	R4,BPUTCH		:OUTPUT LENGTH BYTE
	LIS	R8,0			:ALL DATA BYTES FIT IN ONE ISIS MSG
	LR	R6,R7
	SIS	R6,1			:NO. OF CHARS IN THIS MESSAGE
	JAL	R7,ESCDTA		:FINISH OFF ESCAPED MESSAGE
	J	RTD020

:	PROCESS ONE BYTE INTERRUPT PACKET
TIN012	CLHI	R2,2			:CHECK LEVEL
	JG	TIN011			:IF LEVEL > 2
	LHI	R12,EXMA		:START PROCESS LEVEL 2 INT PACKET
	JAL	R4,PICKCH		:GET DATA BYTE
	LR	R7,R0			:SAVE DATA BYTE
	JAL	R9,ESCAP1,,
	J	RTD020
	
:END OF CHANGE FOR EXT. INTERRUPT PACKET		:AHM-XINTRPT 05-AUG-87

:	MAKE SURE WE HAVE NOT ALREADY RECEIVED AN INTERRUPT PACKET
:	THAT HAS NOT BEEN CONFIRMED YET.
TIN020	LHL	R0,IPORT
	SBT	R0,FLINTC		:SET FLAG SAYING INTERRUPT CONF. QUEUED UP
	JN	SNDRSE			:IF ALREADY SET
	CLHI	R6,1			:CHECK DATA BYTE LENGTH		:AHM-XINTRPT 05-AUG-87
	JN	RTEINT			:IF COUNT > 1, RESET CIRCUIT	:AHM-XINTRPT 05-AUG-87
	LHL	R1,IECBUF
	LHI	R0,ZINTPC		:GET INT. CONF. PACKET TYPE
	JAL	R4,WCI
:	JAL	R4,COP,,		:UPDATE OUTPUT PACKET COUNT	:LSH 14-JUL-87
	J	RTD020

:	PROCESS AN INTERRUPT CONFIRMATION..
RTINTC	LB	R1,PACKET
	CLHI	R1,YINTPC		:MAKE SURE AN INTERRUPT CONFIRMATION
	JN	RTEILL
	JAL	R4,RTACCP
:	JAL	R4,CIP,,		:UPDATE INPUT PACKET COUNT :LSH 14-JUL-87
	PTRACE
	LR	R6,R6			:MAKE SURE NO MORE DATA
	JN	RTELNG			:IF TOO LONG

:	MAKE SURE WE ARE EXPECTING THIS.
	LHL	R0,IPORT
	LHI	R13,DIA043
	RBT	R0,FLINT
	JE	SNDRSE			:IF WE DID NOT SEND ONE
	LHL	R1,DPORT
	TBT	R1,TURKEY
	JE	RTD020			:IF NOT IN DIALECT MODE
	LHI	R12,EXMB
	JAL	R9,ESCAP0,,
	J	RTD020


:	PROCESS REJECT PACKET.
:	IF AT ACCEPTABLE STATE, SEND RESET WITH DIAG#37.
:	ELSE PROCESS AS ERROR.
RTREJ	JAL	R4,RTACCP
	TBT	RL,P128.F
	JEFS	TREJ10
	LR	R6,R6
	JE	RTESHT			:IF TOO SHORT
	JAL	R4,PICKCH
	STB	R0,PCTL2
TREJ10	LR	R6,R6
	JN	RTELNG			:PACKET TOO LONG
	PTRACE
	LHI	R13,DIA037
	LA	R12,RSMSG9,,
	J	SNDRSE			:GO SEND RESET

	SSTTL(CLEAR REQUEST)
:	PROCESS A CLEAR REQUEST.

RTCLR	LB	R1,PACKET
	CLHI	R1,YCLRR
	JN	RTEILL			:IF NOT A CLEAR REQUEST PACKET
	JAL	R4,RTACCP		:ACCEPTABLE PACKET?	:DRE 31-DEC-87
	LIS	R0,0
	LR	R6,R6
	JE	RTESHT			:IF TOO SHORT (NO CAUSE FIELD)
	JAL	R4,PICKCH		:GET CAUSE FIELD
	STB	R0,PCTL2		:SAVE FOR TRACE
TCLR10	STB	R0,PSDIAG,R7,R7
	LIS	R0,0
	LR	R6,R6
	JEFS	TCLR12			:IF NO DIAGNOSTIC
	JAL	R4,PICKCH		:GET DIAGNOSTIC BYTE
TCLR12	STB	R0,PSDIAG+1,R7,R7
	STB	R0,PSDIAS+1		:SO THAT DIAGNOSTIC SHOWS UP IN TRACE TABLE
	LB	R2,PCTL2		:GET SAVED CAUSE CODE	:HJR 05-29-87
  IF  X.75							:HJR 05-29-87
	CLHI	R2,CNETCG		:IS THIS NETWORK CONGESTION? :DRE 1-JUN-87
	JN	TCLR16			:NO, IGNORE DIAGNOSTIC CODE :DRE 1-JUN-87
	LR	R0,R0			:TEST THE DIAGNOSTIC CODE :DRE 1-JUN-87
	JEFS	TCLR16			:ZERO IS UNCHANGED	:DRE 1-JUN-87
	LHI	R4,DIA114		:SET UP FOR 1 TO 111	:DRE 1-JUN-87
	CLHI	R0,DIA112		:COMPARE WITH HIGHEST PROTOCOL ERROR :DRE 1-JUN-87
	JLFS	TCLR14			:CONVERT TO 114		:DRE 1-JUN-87
	LHI	R4,DIA113		:SET UP FOR NETWORK ERROR :DRE 1-JUN-87
	CLHI	R0,DIA128		:COMPARE WITH NETWORK	:DRE 1-JUN-87
	JLFS	TCLR16			:NOT A NETWORK ERROR	:DRE 1-JUN-87
TCLR14	STB	R4,PSDIAG+1,R7,R7	:STORE IN PER CIRCUIT	:DRE 1-JUN-87
TCLR16	CLHI	R2,CLOCPE		:CONVERT		:HJR 05-29-87
	JNFS	TCLR19			 :LOCAL PROCEDURE ERROR	:HJR 05-29-87
	LHI	R2,CNETCG		 :TO NETWORK CONGESTION	:HJR 05-29-87
	STB	R2,PSDIAG,R7,R7					:HJR 05-29-87
TCLR19								:HJR 05-29-87
  EI  X.75							:HJR 05-29-87
  IF  X.25							:HJR 05-29-87
	JEFS	TCLR15			:ZERO IS ALWAYS OK
	THI	R2,80			:IS BIT 8 ON?
	JNFS	TCLR15			:ANYTHING WITH THE BIT ON IS OK
	TBT	RL,PCAU.F		:DO WE ALLOW NETWORK CAUSE CODES THROUGH?
	JNFS	TCLR15			:YES, LET IT GO THROUGH
	LHI	R13,CLOCPE^8!DIA081	:SET ERROR TO INPROPER CAUSE CODE :DRE 5-JAN-88
	STH	R13,PSDIAG,R7,R7	:SAVE THE NEW DIAGNOSTIC :DRE 5-JAN-88
	J	SNDCL0			:SEND A CLEAR		:DRE 5-JAN-88
TCLR15	HS
  EI	X.25
	LB	R4,PCKSTE,R7,		:CHECK PACKET STATE	:DRE 19-JUN-87
	CLHI	R4,PSCLRC		:ARE WE WAITING FOR A CONF? :DRE 19-JUN-87
	JE	CLRC10			:YES, TREAT CLEAR LIKE CONF :DRE 19-JUN-87
	LH	R2,ID.MT,R7,R7		:GET DPORT 		:GML 16-Aug-84
	JLE	TCLR21			:IF ALREADY CLEANED OUT	:GML 16-Aug-84
:	LR	R8,R7			:SAVE IPORT	:LSH 14-JUL-87
	LHL	R7,PSDIAG,R7,R7		:GET CAUSE AND DIAGNOSTIC
	OI	R7,AA.CCD		:PREPARE ACCOUNTING MESSAGE
	JAL	R9,GENRPT,,		:SEND TO SUPE	'E00F' message
	:Removed by Louisa Hsu	:LSH 14-JUL-87
	:Won,t report call clear status until version 5
	:for fast select call
			:CHANGES BEGIN HERE			:LSH 10-FEB-87
:  IF	FSTSLT		:CHANGE TO REPORT FAST SELECT CLEAR REQUEST ACCOUNTING
:					:			:LSH 27-APR-87
:	TBT	R8,FSTSEL,,		:CLEAR CAN BE SENT FROM EITHER DTE
:	JE	TCLR22			:IF NOT FAST SELECT
:	LI	R7,AA.FST!FST.CL	:REPORT FAST SELECT CLEAR
:	JAL	R9,GENRPT,,		:REQUEST (E0160003) ACCOUNTING
:TCLR22	HS
:  EI	:FSTSLT		:CHANGES END HERE			:LSH 10-FEB-87

:	LR	R7,R8			:RESTORE IPORT	:LSH 14-JUL-87
	LHL	R7,IPORT				:LSH 14-JUL-87
TCLR21	HS
  IF	X.75
	RBT	R7,TNIRCV,,		:RESET 'TRANSIT NET ID UTILITY' FLAG
  EI	X.75
			:MOVE ONE BLOCK OF CODE TO ALLOW ZERO 	:LSH 10-FEB-87
			:ADDRESS LENGTH AND ZERO FACILITY LENGTH:LSH 10-FEB-87
			:FOR NON FAST SELECT CALL WHEN SWITCH	:LSH 10-FEB-87
			:FSTSLT IS TURNED JON			:LSH 10-FEB-87
	JAL	R7,BCAESC		:BEGIN ESC MSG DATA	:HJR-SWBT1
	JN	TCLR85			:IF ERROR		:HJR-SWBT1
	LR	R6,R6						:HJR-SWBT1
	JE	TCLR25			:IF NO OTHER FIELDS ARE PRESENT :HJR-SWBT1

:	SCAN ADDRESS, UTILITY/FACILITY, CLEAR USER DATA FIELD.
	JAL	R7,CCAC			:CHECK CALLED ADDRESS	:DRE 19-JUN-87
	JL	TCLR85			:FORMAT ERROR		:DRE 19-JUN-87
:- BEGIN -----------------------------------------------------	:HJR-SWBT1
 IF LIIFLAG
	JEFS	TCLR22			:IF OK
	SIS	R0,1			:CALLED OR CALLING ERR?
	JG	TCLR85			:IF CALLING ERR
	SBT	RL,TEMP4		:ELSE MARK CALLED ERR
	JFS	TCLR23
TCLR22	RBT	RL,TEMP4		:MARK NO ERR
 EI :LIIFLAG
TCLR23	LR	R6,R6
	JE	TCLR25			:NO MORE INFO
:-- END ------------------------------------------------------	:HJR-SWBT1

  IF	X.75
	LHL	R1,IPORT
	SLLS	R1,2
	AHI	R1,FACBIA
	STH	R1,FACBUF		:SET UP FACILITIES BUFFER ADDRESS
	JAL	R4,EMPTY,,		:MAKE SURE IT IS EMPTY
	LIS	R14,2			:INDICATE CLEAR UTILITY PROCESSING
	JAL	R13,CUF			:LEAVE TO *CUF* TO DETECT TRANSIT NET ID
:				 	 UTILITY AND COPY TO FAC BUF
	LR	R6,R6			:			:LSH 10-FEB-87
	JE	TCLR25			:IF NO MORE INFO
  EI	X.75

	LIS	R14,0			:HANDLE LIKE ACCEPT FOR NOW :DRE 19-JUN-87
	JAL	R13,CUF			:PROCESS THE FACILITIES	:DRE 19-JUN-87
	LR	R6,R6
	JE	TCLR25			:IF NO CLEAR USER DATA

			:CHANGES BEGIN HERE			:LSH 10-FEB-87
    IF	FSTSLT		:ONLY ALLOW FAST SELECT CLEAR REQUEST CARRY USER DATA
					:			:LSH 27-APR-87
	LHL	R7,IPORT		:CLEAR CAN BE SENT FROM EITHER DTE
	TBT	R7,FSTSEL,,
	JE	TCLR90			:ERROR IF NOT FAST SELECT CLEAR REQUEST
	CLHI	R6,$A128
	JG	TCLR90			:ERROR IF USER DATA > 128 BYTES
	STH	R6,RUFCNR		:FOR ROUTINE CIP1SX	:LSH 14-JUL-87
	JAL	R4,CIP1SX,,		:COUNT CUD FOR ACCOUNTING :LSH 14-JUL-87
:@@@@@@@:In version 5, should set up FSTFLG (set bit FST.CL) and report
:	:it in fast select accounting message (E016 + FSTFLG) :LSH 14-JUL-87
   ELSE:NON FSTSLT
	J	TCLR90			:PACKET TOO LONG
    EI	:FSTSLT		:CHANGES END HERE			:LSH 10-FEB-87

TCLR25	LHI	R12,DIA067		:SET UP FOR BAD CALLED ADDRESS ERROR :DRE 19-JUN-87
	TBT	RL,TEMP4		:IS THE BAD ADDRESS BIT SET? :DRE 19-JUN-87
	JN	TCLR85			:YES, RETURN ERROR	:DRE 19-JUN-87
	LH	R1,DPORT		:GET DISPATCHER PORT
	JLE	TCLR70			:IF NO DISPATCHER PORT ASSIGNED
	RBT	R1,DBKPR		:CLEAR DPORT BP BIT ARRAR - JH 4/4/86
	JEFS	TCLR30			:IF WE HAVE NOT APPLIED BACK PRESSURE
	CTLMSG(SND)			:RELEASE BACKPRESSURE
TCLR30	LHL	R1,IPORT
	TBT	R1,NEWLOG,,
	JE	TCLR60			:IF PORT NOT STILL IN LOGIN

:	WE SENT THE PSUEDO NEEDLE REQUEST AND IS STILL WAITING FOR THE
:	CIRCUIT TO BE COMPLETED,IE, WE GOT (B2) MSG BUT NOT (B6) YET.
	LB	R0,PCKSTE,R1,
	CLHI	R0,PSCALC
	JEFS	TCLR40			:IF IN SEND CALL CONF STATE
	CLHI	R0,PFLOWC
	JN	TCLR50			:IF NOT IN FLOW CONTROL READY

:	SET A ONE MINUTE TIMER TO ALLOW THE CIRCUIT COMPLETE MESSAGE TO COME
:	BEFORE WE SEND BACK THE CLEAR CONFIRMATION AND FREE UP THE IPORT.
:	MEANWHILE PUT PACKET LEVEL IN 'SEND CLEAR CONFIRMATION' STATE,
:	AND DETACH THE CIRCUIT. THE 1 SECOND TIMEOUT ROUTINE WILL SEND THE
:	QUEUE UP THE CLEAR CONFIRMATION WHEN TIMEOUR OCCURS.

TCLR40	J	TCLR70			:handle like any other	:DRE 2-24-88
:	SBT	R1,TNTA.F		:SET A ONE MINUTE TIMER
:	LHI	R0,$A60
:	STB	R0,TNCNTR,R1,
:	LHI	R0,PSCLRC
:	STB	R0,PCKSTE,R1,
:	PTRACE				:INPUT PACKET TRACE
:	JAL	R9,DDONE,,
:	J	RTD020

TCLR50	CLHI	R0,PSCLRC
	JNFS	TCLR60			:IF NOT IN SEND CLEAR CONF STATE
TCLR55	PTRACE				:INPUT PACKET TRACE
	J	RTD020

:	PASS THE CLEAR REQUEST TO THE OTHER SIDE OF THE NETWORK.
TCLR60	LHL	R1,DPORT
	TBT	R1,TURKEY
  IF	X.75
	JE	TCLR69			:IF NOT IN DIALECT MODE
  ELSE	X.25
	JE	TCLR70
  EI
	LB	R2,TURLEV,R1,
	JE	TCLR68			:IF TURKEY LEVEL =0, NO WAY TO PASS INFO
TCLR66	LHI	R12,EXM17		:ESCPD CLEAR INFO MSG
	JAL	R14,MCAESC,,		:USE CALL ACCEPTED ROUTINE :HJR-SWBT1
TCLR68	TURMSG(CLEAR)			:OUTPUT CAUSE/DIAG ESCAPED MSG

  IF	X.75
:	REPORT RECEIVED TRANSIT NET ID LIST TO ACCOUNTING, IF ANY.
TCLR69	JAL	R6,TNIRPT
  EI	X.75

:	USE PRESENT STATE OF CHANNEL TO GET SUBROUTINE TO HANDLE CLEAR
:	INDICATION.
TCLR70	PTRACE				:INPUT PAKCET TRACE
	LIS	R0,AA.DBH		:'DROP BY HOST' TERM CODE
	STH	R0,TERMCD
	LHL	R7,IPORT
	LB	R1,PCKSTE,R7,		:GET CHANNELS STATE
	LH	R1,CLRFAN,R1,R1
	J	CLRFAN,R1

:	ERROR IN CLEAR REQUEST PACKET.
:	CLEAR THE LOGICAL CHANNEL BUT MAKE SURE WE DO NOT EXPECT A CLEAR
:	CONFIRMATION BACK.
TCLR80	LHI	R12,DIA174		:ERROR IN CLEAR REQ PACKET

TCLR85	LHL	R7,IPORT
	SBT	R7,ERRCLR,,		:TELL RM TO CLEAN UP INTERNAL PORT
:					 AFTER SENDING THE CLEAR
	ERRPTRACE			:ERROR INPUT PACKET TRACE
	LHI	R13,CLRCAU^8,R12	:ERROR IN CLEAR REQ PACKET
	JAL	R8,CLEARP
	J	RTD020

TCLR90	LIS	R0,1
	AHM	R0,CLRLNG,RL,RL		:RCVD CLEAR REQ PACKET TOO LONG
	LHL	R7,IPORT
	SBT	R7,ERRCLR,,		:IN CASE WE ARE SENDING A CLEAR
	ERRPTRACE
	J	RTELNG

:	DECISION TABLE USED WHEN RECEIVING A CLEAR REQUEST ON A CHANNEL.

 TABLE(CLRFAN)
	TENTRY(CLRF0) :0	P1 - READY
	TENTRY(CLRF1) :1	P3 - SEND INCOMING CALL (CALL REQUEST)
	TENTRY(CLRF2) :2	P3 - WAIT FOR CALL ACCEPT (CALL CONNECTED)
	TENTRY(CLRF3) :3	P2 - MUST SEND CALL CONNNECTED
	TENTRY(CLRF4) :4	P7 - SEND CLEAR INDICATION
	TENTRY(CLRF5) :5	P7 - WAIT FOR CLEAR CONFIRMATION
	TENTRY(CLRF6) :6	P6 - SEND CLEAR CONFIRMATION
	TENTRY(CLRF7) :7	P4 - FLOW CONTROL READY	:DRE 19-JAN-88
	TENTRY(CLRF8) :8	D3 - MUST SEND RESET INDICATION	:DRE 19-JAN-88
	TENTRY(CLRF8) :9	D3 - WAIT FOR RESET CONFIRMATION :DRE 19-JAN-88
	TENTRY(CLRF8) :A	D2 - MUST SEND RESET CONFIRMATION :DRE 19-JAN-88

CLRF0	TRAP(R7,E7)		:INTERNAL PORT ASSIGNED BUT INNREADY STATE

:	IN SEND INCOMING CALL STATE.
:
CLRF1	LIS	R0,AA.UNR
	STH	R0,TERMCD
	RBT	R7,FIRSTR
	LH	R7,DPORT		:GET DISPATCHER PORT
	JG	CLRF7A			:IF NOT ZERO
	TRAP(R2,FB)			: ZERO DISPATCHER PORT WHILE WAITING CALL CONF


:	IN WAITING CALL CONF STATE,IE, AN INCOMING CALL IS OUT.
:	SEND USER A MESSAGE TO TELL HIM WHY IT CANNOT BE COMPLETED.
CLRF2	EQ	CLRF1


:	IN SEND CALL CONFIRMATION STATE.
:	SEE IF PORT HAS ALREADY BEEN ASSIGNED ON DISPATCHER.
:	IF SO SEND BACK A CLEAR CONFIRMATION AND ZAP DISPATCHER PORT.
:	IF NOT JUST PUT CHANNEL IN SEND CLEAR CONF STATE AND
:	DO NOT QUEUE UP A CLEAR CONFIRMATION YET.
:
CLRF3	LIS	R0,1
	AHM	R0,RTDERA,RL,RL		:INCREMENT FACT THIS HAPPENED
	LH	R1,DPORT
	JGFS	CLRF3A			:IF PORT ASSIGNED
	LHL	R7,IPORT
	LHI	R0,PSCLRC
	STB	R0,PCKSTE,R7,		:PUT CHANNEL IN DCE CLEAR REQ. STATE
	J	RTD020

CLRF3A	JAL	R9,DDONE,,		:GO ZAP DISPATCHER PORT
	JAL	R9,QCC			:GO QUEUE UP A CLEAR CONFIRMATION
	J	RTD020

:	IN SEND CLEAR REQUEST STATE.
:	CONTROL QUEUE ENTRYS FOR THIS CHANNEL HAVE ALREADY BEEN FLUSHED.
:	CHECK MAPPING TABLE ENTRY FOR A NEGATIVE VALUE. IF SO THEN PORT HAS
:	A PSEUDO NEEDLE OUT TO DISPATCHER AND IS WAITING FOR A RESPONCE
:	ON TYMNET.  JUST PUT PORT IN SEND RECLEAR CONF REQUEST STATE.
:	OTHERWISE PUT PORT IN THIS STATE PLUS QUEUE UP A CLEAR CONFIRMATION.

CLRF4	LH	R1,DPORT		:GET DISPATCHER PORT IF ANY
	JLFS	CLRF4A			:IF NEAGATIVE
	JAL	R9,QCC			:GO QUEUE UP A CLEAR CONFIRMATION
	J	RTD020

CLRF4A	LHL	R7,IPORT
	LHI	R0,PSCLRC
	STB	R0,PCKSTE,R7,		:STORE NEW STATE
	J	RTD020


:	IN WAITING FOR CLEAR CONFIRMATION STATE.
:	THIS WILL BE CONSIDERED A CLEAR COLLISION. JUST TREAT AS A CONFIRMATION.
CLRF5	JAL	R9,IDONE,,
	JAL	R9,DDONE,,
	J	RTD020


:	IN SEND CLEAR CONFIRMATION STATE.
:	THIS SHOULD NOT HAPPEN BUT IF IT DOES COUNT UP FACT AND CHECK CHANNEL
:	TO SEE IF IT HAS A PSUEDO NEEDLE OUT BY LOOKING AT MAPPING TABLE ENTRY.
:	IF NEGATIVE DO NOTHING. ELSE REQUEUE UP THE CLEAR CONFIRMATION.
CLRF6	LIS	R0,1
	AHM	R0,RTDERB,RL,RL		:INCREMENT FACT
	LH	R1,DPORT		:GET DISPATCHER PORT
	JL	RTD020			:IF NEGATIVE
	JAL	R9,QCC			:REQUEUE UP CLEAR CONFIRMATION
	J	RTD020


:	IN FLOW CONTROL READY,
:	SEND RESET, WAITING RESET, OR SEND RESET CONF STATES.
:
CLRF8	LIS	R0,1						:DRE 19-JAN-88
	AHM	R0,RTDERC,RL,RL		:INCREMENT FACT THIS HAPPEND
CLRF7	LHL	R7,DPORT					:DRE 25-JAN-85
	JLE	CLRF7B			:IF NOT ASSIGNED
CLRF7A	TBT	R7,TURKEY
	JN	CLRF7F			:IF DIALECT
	LHL	R5,IPORT
	TBT	R5,EXTCAL		:SEE IF CALL FROM EXTERNAL
	JN	CLRF7F			:USE ZAPPER IF SO
	TBT	R7,CHLOGN					:DRE 12-DEC-84
	JN	CLRF7F			:IF IN LOGIN MODE
	LH	R1,PSDIAG,R5,R5		:GET CAUSE,DIAG
	CLHI	R1,DIA164		:DO WE HANG UP PHONE LINE ??
	JNFS	CLRF7D			:JUMP, IF NO
	CTLMSB(SHG)			:SEND SUPERHANG FOR 2741 HDUPLEX TYPE
CLRF7D	LA	R3,CLMSHD,,		:CLEAR MESSAGE HEADER
	JAL	R6,OUTCDR,,		:OUTPUT CAUSE AND DIAGNOSTIC
	LHL	R9,IPORT
	LB	R1,PSDIAG,R9,R9
	LA	R3,CLMS0,,		:DTE ORIGINATED MESSAGE
	THI	R1,80			:DTE ORIGINATED?
	JNFS	CLRF7C			:YES, USE DTE ORG MESSAGE
	LA	R3,CLMSUC,,		:UNKNOWN CAUSE MESSAGE
	CLHI	R1,CLMAX
	JGFS	CLRF7C			:IF CAUSE NOT IN RANGE OF KNOWN MSGS
	LH	R3,CLADRS,R1,R1
	AI	R3,S.RT
CLRF7C	LR	R2,R7			:GET DPORT
	OUTMSG(,FORCE)
	LHL	R9,IPORT
	LH	R1,PSDIAG,R9,R9		:GET CAUS,DIAG
	CLHI	R1,DIA164		:DO WE HANG UP PHONE LINE ??
	JNFS	CLRF7F			:JUMP, IF NO
	CTLMSB(HNG)			:SEND A HANG TO PHYSICALLY DISCONNECT
	LH	R7,DPORT
	JFS	CLRF7B
CLRF7F	JAL	R9,DDONE,,
CLRF7B	JAL	R9,QCC			:QUEUE UP A CLEAR CONFIRMATION
	J	RTD020
	SSTTL(CLEAR CONF/RESET)

:	PROCESS CLEAR CONFIRMATION.

RTCLRC	LB	R1,PACKET		:GET PACKET TYPE
	CLHI	R1,YCLRC		:VERIFY CLEAR CONFIRMATION
	JN	RTEILL			:IF NOT
	JAL	R4,RTACCP		:SEE IF ACCEPTABLE
	LR	R6,R6			:CHECK THE LENGTH	:DRE 4-JAN-88
	JN	RTELNG
CLRC10	PTRACE
	JAL	R9,IDONE,,
	LHI	R0,AA.ERR		:WE SHOULD HAVE ALREADY PUT OUT TERM CODE
	STH	R0,TERMCD
	JAL	R9,DDONE,,
	J	RTD020


:	PROCESS RESET INDICATION.

RTRSE	LB	R1,PACKET		:GET PACKET TYPE
	CLHI	R1,YREST
	JN	RTEILL			:IF NOT A RESET INDICATION
	JAL	R4,RTACCP		:SEE IF ACCEPTABLE
	CLHI	R6,02			:MAKE SURE STILL HAVE CAUSE FIELD IN RING
	JG	RTELNG			:SEND A RESET IF TOO LONG
	LR	R6,R6
	JE	RTESHT			:IGNORE IF NOT ENOUGH
	JAL	R4,PICKCH		:GET CAUSE FIELD
	STB	R0,PCTL2		:SAVE FOR TRACE
	STB	R0,PSDIAG,R7,R7		:SAVE CAUSE CODE
	CHI	R0,RDTERS					:SCHEN 7-Jan-86
	JE	TRSE02			:IF DTE CLEAR		:SCHEN 7-Jan-86
	CHI	R0,RREMPE					:SCHEN 7-Jan-86
	JE	TRSE02			:IF REMOTE PROCEDURE ERROR :SCHEN 7-Jan-86
	CHI	R0,RLOCPE					:SCHEN 7-Jan-86
	JNFS	TRSE03						:SCHEN 7-Jan-86
TRSE02	JAL	R4,CIP1S1,,		:UPDATE INPUT COUNTS	:LSH 14-JUL-87
TRSE03	LIS	R0,0						:SCHEN 7-Jan-86
	LR	R6,R6
	JEFS	TRSE05			:IF NO DIAGNOSTIC
	JAL	R4,PICKCH		:GET DIAGNOSTIC FIELD
TRSE05	STB	R0,PSDIAG+1,R7,R7
	STB	R0,PSDIAS+1		:SO THAT DIAGNOSTIC SHOWS UP IN TRACE TABLE
	PTRACE
	LB	R2,PCTL2		:GET SAVED CAUSE CODE	:HJR 05-29-87
  IF  X.75							:HJR 05-29-87
	CLHI	R2,RNETCG		:IS THIS NETWORK CONGESTION? :DRE 1-JUN-87
	JN	TRSE08			:NO, IGNORE DIAGNOSTIC CODE :DRE 1-JUN-87
	LB	R0,PSDIAS+1		:TEST THE DIAGNOSTIC CODE :DRE 1-JUN-87
	JEFS	TRSE08			:ZERO IS UNCHANGED	:DRE 1-JUN-87
	LHI	R4,DIA114		:SET UP FOR 1 TO 111	:DRE 1-JUN-87
	CLHI	R0,DIA112		:COMPARE WITH HIGHEST PROTOCOL ERROR :DRE 1-JUN-87
	JLFS	TRSE06			:CONVERT TO 114		:DRE 1-JUN-87
	LHI	R4,DIA113		:SET UP FOR NETWORK ERROR :DRE 1-JUN-87
	CLHI	R0,DIA128		:COMPARE WITH NETWORK	:DRE 1-JUN-87
	JLFS	TRSE08			:NOT A NETWORK ERROR	:DRE 1-JUN-87
TRSE06	STB	R4,PSDIAG+1,R7,R7	:STORE IN PER CIRCUIT	:DRE 1-JUN-87
TRSE08	CLHI	R2,RLOCPE		:CONVERT		:HJR 05-29-87
	JNFS	TRSE09			 :LOCAL PROCEDURE ERROR	:HJR 05-29-87
	LHI	R2,RNETCG		 :TO NETWORK CONGESTION	:HJR 05-29-87
	STB	R2,PSDIAG,R7,R7					:HJR 05-29-87
TRSE09								:HJR 05-29-87
  EI  X.75							:HJR 05-29-87
  IF  X.25							:HJR 05-29-87
	JEFS	TRSE07			:ZERO IS ALWAYS OK
	THI	R2,80			:IS BIT 8 ON?
	JNFS	TRSE07			:ANYTHING WITH THE BIT ON IS OK
	TBT	RL,PCAU.F		:DO WE ALLOW NETWORK CAUSE CODES THROUGH?
	JNFS	TRSE07			:YES, LET THE CAUSE CODE THROUGH
	LHI	R2,CLOCPE^8!DIA081	:SET ERROR TO INPROPER CAUSE CODE
	STH	R2,PSDIAG,R7,R7		:SAVE THE NEW DIAGNOSTIC
TRSE07	HS
  EI	X.25

:	IF IN FLOW CONTROL STATE, SEND BACK A RESET CONF. AND DO CLEAN UP.
:	IF WE ARE ABOUT TO SEND A RESET OURSELF, CHANGE THAT TO
:	A RESET CONF.
:	FOR RESET COLLISION, JUST PUT CHANNEL BACK TO FLOW CONTROL READY STATE.

	LB	R1,PCKSTE,R7,		:GET CHANNELS STATE
	CLHI	R1,PSRESC
	JE	RTD020			:IF WE ALREADY RECEIVED ONE, JUST IGNORE
	CLHI	R1,PFLOWC
	JE	TRSE10			:IF IN FLOW CONTROL READY
	CLHI	R1,PSRESI
	JE	TRSE80			:IF WE ARE ABOUT TO SEND ONE

: NONE OF THE ABOVE, MUST BE WAITING FOR RESET CONFIRMATION, (SEE ACCEPT TABLE)
:  MAY NEED BE MODIFIED FOR PVC SUPPORT
:	RESET COLLISON.
	LHI	R1,PFLOWC		:GET FLOW CONTROL READY STATE
	STB	R1,PCKSTE,R7,		:STORE NEW STATE
	RBT	R7,TNTA.F
	RBT	R7,FIRSTR
	RBT	R7,IFLUSH
	LHL	R1,DPORT
	TBT	R1,TURKEY
	JE	RTD020
:	SEND ESCAPED MSG FOR RESET CONFIRMATION.
	LB	R2,TURLEV,R1,
	JN	RTD020			:FOR TURLEV >=1, NO NEED TO SEND IT
	LHI	R12,EXM11
	JAL	R9,ESCAP0,,
	J	RTD020

:	IN FLOW CONTROL READY STATE.
:	DO PROPER CLEANUP AND INVOKE FLUSHING OF DATA FROM THE NETWORK UNTIL
:	WE RECEIVE A GOBBLER (FOR TURKEY) OR AN ORAGE BALL (NON TURKEY).
:	SEND BACK A RESET CONFIRMATION AND PUT CHANNEL IN SEND RESET CONF STATE.
TRSE10	LHL	R7,IPORT
	LHI	R1,PSRESC		:GET SEND RESET CONF STATE
	STB	R1,PCKSTE,R7,
	LHI	R0,ZRESCN		:GET RESET CONFIRMATION PACKET TYPE
	JAL	R9,CNR			:GO DO CLEANUP
	LIS	R0,1
	AHM	R0,SM.102,RL,RL
	LH	R7,DPORT
	JE	RTD020			:IF DISPATCHER PORT NOT ASSINGED
	TBT	R7,CHLOGN		:SEE IF IN LOGIN MODE		:DRE 12-DEC-84
	JE	TRSE15			:NOT IN LOGIN, FLUSH AND SEND RESET
	LHL	R1,DPORT		:ELSE SEND AN ESC TO GET PLI PROMPT.
	LIS	R0,4			:LENGTH OF OUTPUT MSG.
	LHL	R7,IPORT
	TBT	R7,NEWLOG,,		:IF TALKING TO OUR SUP
	JN	TRSE13			:YES, OUTPUT AN ESC AS NLC
	LIS	R2,1			:ELSE (IIX) ESC AS DATA MSG.
	JAL	R4,SLOR,,
	LHI	R0,1B			:PUT ESC IN
	JAL	R4,PUTCH
	JAL	R4,ELODR,,
	J	RTD020
TRSE13	LHI	R2,0B3			:ISIS MSG. CODE FOR NLC
	JAL	R4,SLOR,,
	LHI	R0,1B			:VALUE FOR ESC
	JAL	R4,PUTCH
	JAL	R4,ELOR,,
	J	RTD020
TRSE15	SBT	R7,DFLUSH
	CTLMSG(GOB)			:SEND A GOBBLER
	TBT	R7,TURKEY
	JE	TRSE20			:IF NOT TALKING TURKEY DIALECT
	TURMSG(RESET)			:SEND RESET DIALECT MESSAGE
	J	RTD020

:	SEND MESSAGE TO THE USER IF TALKING TO A TYMSAT.
:	SEND A YELLOW BALL.
TRSE20	LHL	R5,IPORT
	TBT	R5,EXTCAL		:SEE IF CALL ORIG EXTERNALLY
	JN	TRSE50			:IF SO ,DO NOT SEND HOST ERROR MSG
	LA	R3,RSMSHD,,		:RESET HEADER
	JAL	R6,OUTCDR,,		:OUTPUT CAUSE AND DIAGNOSTIC
	LA	R3,RSMSUC,,		:GET UNKNOWN CALL RESET MESG ADDRESS
	LHL	R1,IPORT
	LB	R1,PSDIAG,R1,R1		:GET CAUSE
	CLHI	R1,RSMAX		:VERIFY RANGE
	JGFS	TRSE40			:IF NOT IN RANGE
	LH	R3,RSADRS,R1,R1		:GET ERROR MESSAGE ADDRESS
	AI	R3,S.RT
TRSE40	LR	R2,R7
	OUTMSG(,FORCE)
TRSE50	CTLMSG(YB)			:SEND A YELLOW BALL
	J	RTD020

:	IN SEND RESET INDICATION STATE.
TRSE80	LHL	R7,IPORT
	LHI	R0,PSRESC
	STB	R0,PCKSTE,R7,		:PUT INTO SEND RESET CONFIRMATION STATE
	LHL	R1,IECBUF
	JAL	R4,EMPTY,,
	LHL	R4,DPORT
:
  IF	PVC
: IF THIS PORT IS FOR A PVC THEN
:	IF NO DPORT LINKED TO THIS IPORT THEN
:		THE PVC MUST HAVE BEEN ZAPPED;
:		HERE WE QUEUE A RESET CONFIRMATION ON THIS IPORT
:		  AND LET CODE IN RM TO SCHDULE A PVC REBUILD/OR FREE THE IPORT
:
	JLE	TRSE90
  EI	PVC
:
	TBT	R4,TURKEY
	JEFS	TRSE90			:IF NOT TALKING TURKEY DIALECT
	LB	R2,TURLEV,R7,
	JNFS	TRSE90			:IF NO NEED TO SEND RESET CONF. TO NETWORK
	LHI	R12,EXM11		:ESCAPED MSG FOR RESET CONFIRMATION
	JAL	R9,ESCAP0,,
TRSE90	LHI	R0,ZRESCN		:QUEUE UP A RESET CONFIRMATION
	JAL	R4,WCI
	RBT	R7,TNTA.F
	RBT	R7,FIRSTR
:	JAL	R4,COP,,		:UPDATE OUTPUT PACKET COUNT:LSH 14-JUL-87
	J	RTD020


:	PROCESS A RESET CONFIRMATION.

RTRSEC	LB	R1,PACKET		:GET PACKET TYPE
	CLHI	R1,YRESTC		:IS IT A RESET CONFIRMATION
	JN	RTEILL			:IF NOT

:	PROCESS RESET CONFIRMATION.
	JAL	R4,RTACCP		:SEE IF ACCEPTABLE
	LR	R6,R6
	JN	RTELNG			:IF LENGTH NOT CORREECT
:	JAL	R4,CIP,,		:UPDATE INPUT PACKET COUNT:LSH 14-JUL-87
	PTRACE
	LHL	R7,IPORT
	RBT	R7,TNTA.F		:TURN OFF TN TIMER
	RBT	R7,FIRSTR		:TURN OFF FIRST RETRY SWITCH
	RBT	R7,IFLUSH		:STOP FLUSHING OF DATA FROM X-LINE
	LIS	R0,0			:TO PREVENT ERRONEOUS ERROR MESSAGES :DRE 17-APR-86
	STH	R0,PSDIAG,R7,R7		:CLEAR CAUSE AND DIAG	:DRE 17-APR-86
	LHI	R1,PFLOWC		:GET FLOW CONTROL READY STATE :DRE 17-APR-86

  IF	PVC
	LIS	R2,PWPVCR		:GET PVC BUILD STATE	:DRE 17-APR-86
	CLB	R0,PCKSTE,R7,		:ARE WE IN PVC BUILD STATE ?? :DRE 17-APR-86
	JE	RTD020			:YES, RETURN
  EI	PVC

	STB	R1,PCKSTE,R7,		:STORE NEW STATE
	LHL	R1,DPORT
	TBT	R1,TURKEY
	JE	RTD020
	LB	R2,TURLEV,R1,
	JN	RTD020			:NO NEED TO SEND RESET CONF. TO THE NETWORK
	LHI	R12,EXM11		:SEND RESET CONFIRMATION DIALECT MSG
	JAL	R9,ESCAP0,,
	J	RTD020
	SSTTL(CALL REQUEST)

:	PROCESS A CALL REQUEST PACKET.

RTCALR	LB	R1,PACKET		:GET PACKET TYPE
	CLHI	R1,YCALR		:VERIFY CALL REQUEST PACKET
	JE	PCR020			:GOOD PACKET TYPE:JS 19-FEB-88
	OOPS				:BAD PACKET TYPE:JS 19-FEB-88
	J	RTEILL			:JS 19-FEB-88
PCR020	PTRACE
:	FIND AN INTERNAL PORT TO ASSIGN USER TO.
	LHI	R13,CNETCG^8!DIA192	:SET CLEARING DIAG IN CASE NOT FOUND :DRE 25-JAN-85
	JAL	R3,FINDIP,,		:FIND AN IPORT
	SKIPAD(RTD480)			:NORMAL RETURN - NO PORT AVAILABLE
	JAL	R9,INICAL		:INITIALIZE FOR CALLS

:: BEGIN OF THE CHANGES :JS-ONREG  :LSH ONREG
  IF	X.25
:	CHECK OUTGOING CALLS BARRED FACILITY
	LHI	R13,CACBAR^8!DIA078	:OUTGOING CALLS BARRED:JS-ONREG
	TBT	RL,OBAR.F		:OUTGOING CALLs BARRED ?:JS-ONREG
	JN	SNDCL0			:YES - CLEAR THE CALL:JS-ONREG
	LHI	R13,CLOCPE^8!DIA030	:ON-LINE REGISTRATION IN PROGRESS
	TBT	RL,ONREG,,		:REGISTRATION IN PROGRESS?
	JN	SNDCL0			:YES - CLEAR THE CALL
  EI	:X.25
:: END OF THE CHANGES	:JS-ONREG
  IF	X.25
	LHI	R13,CLRINC^8!DIA040	:INCOMPATIBLE DESTINATION
  ELSE	X.75
	LHI	R13,CNETCG^8!DIA040	:NETWORK CONGESTION
  EI
	TBT	RL,LEVEL1
	JN	SNDCL0			:IF Q BIT ON
	TBT	RL,SEEDBT
	JN	SNDCL0			:IF D BIT ON
  REMIND(RTCALR- SEND CLEAR FOR CALL REQUEST WITH DBIT ON FOR NOW)

  IF	XOM
	LHI	R13,CNETCG^8!DIA191	:'XOM WANTS NO MORE CALLS' :DRE 25-JAN-85
	TBT	RL,XOMBPD
	JN	SNDCL0			:IF XOM WANTS NO MORE CALLS MADE:JS 19-FEB-88
  EI


:	GET DATA FROM CALL REQUEST PACKET AND IF VALID BUILD A PSEUDO-
:	NEEDLE

:	GET AND VALIDATE THE CALLED AND CALLING ADDRESSES, PUT THEM IN
:	DTESAX AND DTESAV BUFFERS

:	ROUTINE HEIRARCHY;
:		PCR100 - MAIN
:			VALADR1 - ADDRESS VALIDATION
:				GDG100 - GET DIGIT (SEMI-OCTET)
:				SDG100 - STORE DIGIT (SEMI-OCTET)

:	REGISTER USAGE;
:		ALL LEVELS
:		  R3,R7,R8,R12,R6
:			VALIDATION ON DOWN
:			  R9,R1,R2
:				GET DIGIT
:				  R4

:	LOCAL STORAGE
:TEMP5	HS	1		:  1ST BYTE-GET RTN ADDR SAVE AREA
				:  2ND BYTE-UPPER/LOWER DIGIT SWITCHES
				:	BIT 6 - GET RTN SWITCH
				:	BIT 7 - STORE RTN SWITCH

:MAIN ROUTINE
PCR100	LR	R6,R6			:PACKET BYTES LEFT
	JE	RTESHT			:   NO

: THIS CODE EXECUTED IF THE PFXFLR MACRO HAS BEEN SPECIFIED
  IF	\PFRMAC
	LHL	R1,PFR.LT,RL2,		:GET OFFSET INTO PREFIX TABLE
	JEFS	PCR101			:JUMP, IF NO TABLE ENTRY
	LA	R1,FLR.LT,R1,		:GET ADDRESS OF PREFIX ENTRY
	ST	R1,PFXEAD
	JAL	R9,PFXMN1		:MODIFY THE PACKET ADDRESSES
	SKIPAD(PCR101)
	LHI	R12,DIA064		:GENERIC CALL SETUP PROBLEM DIAGNOSTIC
	J	RTECAL			:SEND CLEAR WITH CALL SETUP PROBLEM
PCR101	ST	R6,TEMP1		:SAVE UPDATED RTD SECTOR LENGTH
	L	R9,PXSADR		:GET ADDRESS OF RTD SECTOR LENGTH
	LHL	R4,,R9			:GET RTD SECTOR LENGTH
	AH	R4,PXBDIF		:ADD/SUB LENGTH DIFFERENCE
	STH	R4,,R9			:UPDATE SECTOR LENGTH
  EI

	JAL	R4,PICKCH		:GET ADDR. LENGTHS
	LR	R7,R0
	NHI	R7,0F			:GET CALLED ADDR LENGTH
	SRLS	R0,4			:GET CALLING ADDR LENGTH
	LHL	R3,IPORT		:SETUP ADDR. BUFFR INDEX
	SLLS	R3,3
	LIS	R4,0
	ST	R4,DTESAX,R3,		:CLEAR ADDR. BUFFRS
	ST	R4,DTESAX+4,R3,
	ST	R4,DTESAV,R3,
	ST	R4,DTESAV+4,R3,
	STB	R7,DTESAX+7,R3,		:STORE CALLED ADDR LEN	:HJR-SWBT1
	STB	R0,DTESAV+7,R3,		:STORE CALLING ADR LEN	:HJR-SWBT1
	STH	R4,TEMP5
	LHI	R12,DIA067		:SET UP 'ILLEGAL CALLED ADR'
	LA	R13,DTESDX,,		:SET UP 'DNIC PRESENT' FLAG :HJR-SWBT1
	LA	R8,DTESAX,,
	JAL	R7,VALADR		:VALIDATE CALLED ADDRESS
	SKIPAD(RTECAL)			:ERROR RETURN
PCR110	LHL	R3,IPORT		:SETUP ADDR.BUFFR INDEX
	SLLS	R3,3
	LIS	R4,0F
	RBT	R4,TEMP5		:CLEAR ONLY 'STORE DGT RTN' SWITCH
	LHI	R12,DIA068		:SETUP 'ILLEGAL CALLING ADDR'
	LA	R13,DTESDV,,		:SET UP 'DNIC PRESENT' FLAG :HJR-SWBT1
	LA	R8,DTESAV,,
	JAL	R7,VALADR		:VALIDATE CALLING ADDRESS
	SKIPAD(RTECAL)			:ERROR RETURN

  IF	\CLD.SW
:	ADDRESS TRANSLATION.
:	THE CALLED ADDRESS SPECIFIED IN DTESAX IS COMPARED WITH A LIST OF
:	ADDRESSES CONSISTING OF THE FIRST PARAMETER OF THE CLDMAP MACRO
:	CALL SPECIFIED FOR THIS LINK OPTION GROUP.
:	THE COMPARISON WILL BE MADE BETWEEN EACH ADDRESS IN THE ABOVE
:	MENTIONED LIST IN ITS ENTIRETY AND THE SAME NUMBER OF DIGITS
:	IN DTESAX.  IF A MATCH IS FOUND, THE CORRESPONDING SECOND PARAMETER
:	OF THE CLDMAP MACRO APPENDED WITH THE REMAINING DIGITS (IF ANY)
:	IN DTESAX WILL BE STORED INTO DTESAX AND BE USED AS THE CALLED
:	ADDRESS FOR SUBSEQUENT PROCESSING.

	STM	R0,ATRSAV		:SAVE R0-R15
	LR	R7,RL			:LINK #
	SLLS	R7,2			:LINK # * 4 FOR FULL WORD INDEXING
	L	R1,CDM.LT,R7,		:PTR TO CLDMP1 FOR THIS LINK
	JE	CLDEXI			:NO CLDMAP MACRO INVOKED FOR THIS LINK
	LHL	R3,IPORT		:DTESAX HAS 8 BYTES / IPORT
	SLLS	R3,3			:SETUP CALLED ADDR BUFFER INDEX
	LR	R13,R3			:MAKE A COPY
	LB	R6,DTESAX+7,R3,		:GET CALLED ADDR LENGTH	:HJR-SWBT1
	JE	CLDEXI			:NO CALLED ADDR RECEIVED FOR THIS LINK
	LIS	R0,0
	ST	R0,REMBUF		:CLEAR THE REMAINING DIGITS BUFFER
	ST	R0,REMBUF+4
CLDS10
	LR	R3,R13			:RESTORE DTESAX INDEX
	LB	R6,DTESAX+7,R3,		:GET CALLED ADDR LENGTH	:HJR-SWBT1
	LHL	R0,,R1			:GET OFFSET INTO CLDMP2 TABLE
	JE	CLDEXI			:END OF L.O.G FOR THIS LINK, NO MATCH IS FOUND
	LR	R11,R1			:SAVE PTR FOR THIS L.O.G.
	AIS	R1,2			:UPDATE PTR, POINTS TO LENGTH FIELD
	LB	R8,,R1			:GET LENGTH OF THE 1ST PARAM. OF CLDMAP MACRO
	CR	R8,R6			:COMPARE WITH CALLED ADDR LENGTH IN DTESAX
	JG	NENTRY			:IF >, NO COMPARISON NEED TO BE MADE
					:SKIP TO NEXT ENTRY IN CLDMP1

CLDS20	LB	R2,DTESAX,R3,		:GET 2 DIGITS OF CALLED ADDR :HJR-SWBT1
	AIS	R3,1			:INCRE. CALLED ADDR BUFFER (DTESAX) INDEX :HJR-SWBT1
	LR	R12,R2			:MAKE A COPY
	NHI	R12,0F			:GET LOWER DIGIT
	SRLS	R2,4			:GET UPPER DIGIT
	AIS	R1,1			:INCRE. PTR TO GET NEXT 2 DIGITS
	LB	R5,,R1			:GET 2 DIGITS OF 1ST PARAM. OF CLDMAP MACRO
	LR	R9,R5			:MAKE A COPY
	NHI	R9,0F			:GET LOWER DIGIT INTO R9
	SRLS	R5,4			:GET UPPER DIGIT INTO R5
	CR	R2,R5			:COMPARE THIS TWO UPPER DIGIT
	JN	NENTRY			:SKIP IF MATCH IS NOT FOUND
	SIS	R6,1			:DECRE. CALLED ADDR LENGTH
	SIS	R8,1			:DECRE. LENGTH OF 1ST PARAM. OF CLDMAP MACRO
	JE	CLDODD			:TO THE END OF COMPARISON, MATCH IS FOUND
	CR	R12,R9			:COMPARE THIS TWO LOWER DIGIT
	JNFS	NENTRY			:SKIP IF MATCH IS NOT FOUND
	SIS	R6,1			:DECRE. CALLED ADDR LENGTH
	SIS	R8,1			:DECRE. LENGTH OF 1ST PARAM. OF CLDMAP MACRO
	JN	CLDS20			:LOOP BACK TO CHECK THE NEXT 2 DIGITS
	J	CLDEVN			:TO THE END OF COMPARISON, MACH IS FOUND
:
:FIND NEXT ENTRY IN CLDMP1 ROUTINE.  EACH ENTRY HAS 3 ELEMENTS.  THE 1ST
:TWO BYTES ARE THE OFFSET TO CLDMP2 TABLE, THE NEXT BYTE IS THE LENGTH
:(NO. OF DIGITS) OF THE 1ST PARAM. OF CLDMAP MACRO.  THE 1ST PARAM IS
:THEN STORED IN SUCCESSIVE BYTES IN BCD FORM WITH OR W/OUT A BYTE OF ZERO
:FILLED AT THE END DUE TO H.W BOUNDARY.
:
NENTRY
	LB	R1,2,R11		:GET # OF DIGITS
	AIS	R1,1			:CONVERT TO # OF BYTES
	SRLS	R1,1
	AIS	R1,3+1			:3 FOR OFFSET & LENGTH
					: 1 FOR H.W ALIGNMENT
	AR	R1,R11			:TO NEXT ENTRY
	NI	R1,0FFFFFFFE		:H.W ALIGNMENT
	J	CLDS10			:GO TO CHECK WHETHER A MATCH IS FOUND FOR
					: THIS NEW ENTRY

CLDEVN
	LIS	R2,0			:INDICATES THE DIGIT IS IN UPPER NIBBLE :HJR-SWBT0
	JFS	CLDE10
CLDODD
	LIS	R2,1			:INDICATES THE DIGIT IS IN LOWER NIBBLE
CLDE10
	AR	R3,R3			:CHANGE BYTE INDEX INTO NIBBLE INDEX
	AR	R3,R2
	LA	R1,DTESAX,,
	LA	R8,REMBUF		:GET THE REMAINING DIGITS BUFFER ADDR
	LIS	R7,2			:R7 IS THE NIBBLE INDEX FOR REMBUF
	STB	R6,REMBUF		:STORE THE REMAINING LENGTH OF DTESAX
					: INTO REMBUF
	JEFS	FND2ND			:NO REMAINING DIGITS LEFT
CLDE20
	JAL	R4,GETDGT		:GET THE REMAINING DIGITS FROM DTESAX
	JAL	R4,PUTDGT		:PUT IT INTO REMBUF
	SIS	R6,1			:DECRE. DIGIT COUNTER
	JGBS	CLDE20

:
:	FIND THE CORRESPONDING SECOND PARAM. OF CLDMAP MACRO AND
:	CONCATENATE IT WITH THE REMAINING DIGITS IN REMBUF(IF ANY)
:	AND SAVE INTO DTEAX
:
FND2ND
	LHL	R1,,R11			:GET OFFSET INTO CLDMP2
	LB	R6,CLDMP2,R1,		:GET LENGTH OF 2ND PARAM OF CLDMAP MACRO
	LR	R7,R13			:GET DTESAX INDEX
	LIS	R4,0
	ST	R4,DTESAX,R7,		:CLEAN UP
	ST	R4,DTESAX+4,R7,
	LB	R4,REMBUF		:GET LENGTH OF REMAINING DIGITS BUFFER
	AR	R4,R6			:ADD TWO LENGTH UP
	CLHI	R4,$A 14		:COMPARE WITH MAX. ALLOWABLE LENGTH
	JG	CLDERR			:CLEAR THE CALL WITH DIAG. C1
	STB	R4,DTESAX+7,R7,		:STORE NEW LENGTH & CALLED ADDRESS :HJR-SWBT1
	LA	R1,CLDMP2,R1,		:GET THE BEGINING ADDR OF 2ND PARAM.
	LIS	R3,2			:SET NIBBLE INDEX FROM BYTE 1
	LA	R8,DTESAX,R7,
	LIS	R7,0			:NIBBLE INDEX		:HJR-SWBT1
FND200
	JAL	R4,GETDGT		:GET THE 2ND PARAM. OF CLDMAP MACRO
					: FROM CLDMP2 TABLE
	JAL	R4,PUTDGT		:SAVE INTO DTESAX
	SIS	R6,1			:DECRE. DIGIT COUNTER
	JGBS	FND200
	LA	R1,REMBUF
	LB	R6,REMBUF		:GET THE LENGTH OF REMBUF
	JE	CLDEXI
	LIS	R3,2			:SET UPPER NIBBLE INDEX
FND300
	JAL	R4,GETDGT		:GET THE DIGIT FROM REMBUF
	JAL	R4,PUTDGT		:PUT IT INTO DTESAX
	SIS	R6,1			:DECRE. DIGIT COUNTER
	JGBS	FND300

CLDEXI
	LM	R0,ATRSAV		:RESTORE R0-R15

  EI	\CLD.SW

	LHL	R1,IPORT
	RBT	R1,CUGCAL,,
	RBT	R1,EXTDCA,,		:RESET 'RECEIVED EXT CALL ACCEPT MSG' FLAG
	RBT	R1,EXTCLR,,		:RESET 'RECEIVED EXT CLEAR INFO MSG' FLAG
  IF	X.75
	RBT	R1,CIDRCV,,		:RESET FLAG SAYING CID RECEIVED FROM UTIL
  EI
	SLLS	R1,2
	AHI	R1,FACBIA		:FORM FACILITYS BUFFER
	STH	R1,FACBUF
	JAL	R4,EMPTY,,
	LHL	R4,IPORT
  IF	DTARS				:IF ANY DATAPAC TARIFF CLASS LINKS
	LCS	R0,1
	STB	R0,TARIFF,R4,
  EI
	LIS	R0,0
	STB	R0,TCLTR,R4,		:INIT TPUT CLASS
	STB	R0,PWTMT,R4,		:PACKET WINDOW
	STB	R0,PWRCV,R4,
	STH	R0,PSTMT,R4,R4		:PACKET SIZE
	STH	R0,PSRCV,R4,R4
  IF	CUGENA			:IF CUG CODE ENABLED
	ST	R0,TEMP
  EI

:- BEGIN ----------------------------------------------------- :HJR-SWBT1
 IF LIIFLAG
:	DETERMINE WHETHER CALL IS XCOM-I OR XCOM-II AND SET IN XCOM2
  IF .EQ.(L2BUBB,0)
	LB	R4,SUP.SP,,		:GET SUPE BYTE
	SRHLS	R4,7			:GET 'LOG-II SUPE' BIT
  ELSE
	LIS	R4,1		:***TEMP***
  EI
	STB	R4,XCOM2,,		:AND SAVE
 EI :LIIFLAG
:-- END ------------------------------------------------------ :HJR-SWBT1

:	FIGURE OUT BY LOOKING AT CALLED ADDRESS WHAT TYPE OF LOGIN
:	WE ARE DOING.  VALIDATE CALLED ADDRESS AND SEE IF THE DNIC MATCH OURS.
:	THE 'REAL' GATEWAY CHECK IS DONE LATER AFTER WE PROCESSED ALL THE
:	UTILITY AND FACILITY FIELDS.

	LHL	R4,IPORT
	SBT	R4,GATWAY,,		:ASSUME 'GATEWAY CALL' FIRST
	JAL	R14,CHKADR		:VALIDATE CALLED ADDRESS :HJR-SWBT1
	JAL	R14,CHKADG		:CHECK CALLING ADDRESS	:HJR-SWBT1

:	EMPTY THE TMPBF1 AND TMPBF2 BEFORE PROCESS THE UTILITY/FACILITY
	LHI	R1,TMPBF1		:GET NUMBER OF TEM BUFF1	:JS 14-OCT-86
	JAL	R4,EMPTY,,		:MAKE SURE IT IS EMPTY	:JS 14-OCT-86
	LHI	R1,TMPBF2		:GET NUMBER OF TEM BUFF2 :JS 14-OCT-86
	JAL	R4,EMPTY,,		:MAKE SURE IT IS EMPTY	:JS 14-OCT-86

  IF	X.75
:	ADDRESS O'K, NOW GET NETWORK UTILITIES.
	LHI	R12,DIA101					:DRE 12-DEC-84
	LR	R6,R6
	JE	RTECAL			:IF MISSING LENGTH FIELD
	JAL	R4,PICKCH		:GET LENGTH
	LR	R7,R0
	JE	RTECAL			:CLEAR CALL IF NO UTILITIES
	CLHI	R7,$A63			:MAKE SURE NET UTIL LENGTH NOT GREATER THEN 63
	JG	RTECAL			:CLEAR CALL IF SO
	LHI	R12,DIA038
	CLR	R7,R6
	JG	RTECAL			:IF NOT ENOUGH IN BUFFER
	LIS	R9,1			:INDICATE PROCESSING UTILITY
	JAL	R14,CRFAC		:PROCESS UTILITY AND COPY TO FAC BUF
	LHI	R12,DIA099		:'MISSING CALL ID'	:DRE 12-DEC-84
	TBT	RL,CIC.F
	JEFS	PCR290			:IF NOT TO CHECK PRESENCE OF CALL ID
	LHL	R2,IPORT
	TBT	R2,CIDRCV,,
	JE	RTECAL			:IF HAVE NOT RCVD CALL ID, CLEAR CALL

:	FIGURE OUT HOW MANY TRANSIT NETWORK ID UTILITY WE GOT AND
:	SET THE BYTE COUNT IN (TNICNT), SO LATER WE CAN COPY THE
:	LIST TO FACILITIES BUFFER.

PCR290	LHI	R2,TMPBF2					:DRE 23-MAY-86
	LHL	R3,IPORT
	CBCT(R4,R2)			:GET COUNT IN BUFFER
	STB	R4,TNICNT,R3,
  EI	X.75

:	PROCESS FACILITY FIELD.
	LCS	R0,1
	ST	R0,TEMP2		:MARK 'CUG' NOT RECEIVED :HJR 02-02-87
	LR	R6,R6
	JNFS	PCR332			:GO TO GET FACILITY LENGTH
	LIS	R0,0			:MARK FACILITY LENGTH = 0
	LR	R7,R0			:COPY
	J	PCR335
PCR332	JAL	R4,PICKCH		:GET FACILITY FIELD LENGTH
	LR	R7,R0
	LHI	R12,DIA069					:DRE 25-JAN-85
	CLHI	R0,$A109		:CHECK SIZE		:DRE 25-JAN-85
	JG	RTECAL			:IF FACILITY LEN .GT. 109
	LHI	R12,DIA038
	CLR	R7,R6
	JG	RTECAL			:IF NOT ENOUGH DATA LEFT
PCR335	LIS	R9,0			:INDICATE PROCESSING FACILITY
	JAL	R14,CRFAC		:PROCESS FACILITY, COPY TO FACBUF
					:MAIN FACILITIES, AND END-TO-END,
					:END-NETWORK TO TMPBF1


:	IF SUBSCRIBED TO THROUGHPUT CLASS NEGOTIATION AND HAVE NOT GOTTEN
:	ANY TC FACILITY FROM THE CALL REQUEST, ADD A TC FACILITY TO THE
:	END OF FACILITY ESCPD MSG SO THAT THIS VALUE WILL BE PASSED TO THE
:	OTHER SIDE.
	LHL	R9,IPORT
	LIS	R8,0			:INITAILIZE COUNTER OF ADDED BYTE :DRE 23-MAY-86
:  IF	X.75							:DRE 25-JAN-85
:	TBT	RL,TCN.F					:DRE 25-JAN-85
:	JE	PCR390			:IF NOT SUBSCRIBED TO TC NEGOTIATION :DRE 25-JAN-85
:  EI	X.75							:DRE 25-JAN-85
	RBT	R9,TCRCV,,		:ALREADY RECEIVED ONE FROM FACILITY?
	JN	PCR336			:YES,SKIP ADDING ONE	:DRE 16-JUN-87
:	USE VALUES STORED IN (TEMP), (TEMP1), (TEMP1)+2 TO ADD TO THE
:	FACILITIES BUFFER.
	LHL	R1,FACBUF
	LHI	R0,FC.TC		:TC FACILITY CODE
	JAL	R4,WCI
	LB	R0,TTR.LT,RL,		:GET DEFAULT TC VALUES
	JAL	R4,WCI
	AIS	R8,2			:COUNT THESE TWO BYTES

:	ENFORCE LOCAL CHARGING PREVENTION BY CHANGING CALLS WITHOUT NUI
:	 TO REVERSE CHANGED OR TKSUP CALL
PCR336	HS
  IF	X.25
	LHL	R4,IPORT
	TBT	RL,LCP.F		:IS LOCAL CHARGING PREVENTION SET?
	JE	PCR340			:NO,SKIP THESE TESTS
	TBT	R4,NUICAL,,		:IS THIS A NUI CALL?
	JN	PCR340			:YES, ALL IS OK
	TBT	R4,RVCHRG,,		:NO, IS IT REVERSE CHARGED
	JN	PCR340			:YES, NO PROBLEM
	TBT	R4,GATWAY,,		:NO, IS IT A GATEWAY CALL? :DRE 30-JUN-86
	JN	PCR338			:YES, FORCE REVERSE CHARGING :DRE 30-JUN-86
	LR	R1,R4			:NO, TEST LENGTH OF LOGIN STRING :DRE 30-JUN-86
	SLLS	R1,3			:FORM POINTER TO DTESAX ARRAY :DRE 30-JUN-86
	LB	R0,DTESAX+7,R1,		:GET COUNT OF DIGITS	:HJR-SWBT1
	JE	PCR337						:DRE 30-JUN-86
	SIS	R0,5			:COMPARE WITH 5 DIGIT MAX :DRE 30-JUN-86
	JG	PCR338			:FORCE RC ON		:DRE 30-JUN-86
	LB	R0,DTESAX,R1,		:GET FIRST 2 DIGITS	:HJR-SWBT1
	NHI	R0,0F0			:MASK OFF FIRST DIGIT	:DRE 30-JUN-86
	JEFS	PCR338						:DRE 30-JUN-86
	LB	R0,DTESAX+2,R1,		:GET FIRST DIGIT AFTER DNIC :HJR-SWBT1
	SRLS	R0,4						:DRE 30-JUN-86
	SIS	R0,9			:COMPARE WITH 9		:DRE 30-JUN-86
	JNFS	PCR338			:WHATEVER IT IS DON'T ALLOW CALLER PAID :DRE 30-JUN-86
PCR337	TBT	RL,TKSP.F		:NO, CAN WE FORCE A LOGIN? :DRE 30-JUN-86
	JNFS	PCR340			:YES, LET HIM THROUGH	:DRE 30-JUN-86
PCR338	LHL	R1,FACBUF		:SEND A FACILITY TO FORCE REVERSE CHARGING
	LIS	R0,FC.RF		:REVERSE CHARGE FACILITY
	JAL	R4,WCI			:PUT INTO FACBUF
	LIS	R0,RF.RC		:REVERSE CHARGE CODE
	JAL	R4,WCI			:PUT INTO FACBUF
	AIS	R8,2			:COUNT THESE TWO BYTES
  EI

PCR340	LHI	R1,TMPBF1		:TEMPORARY BUFFER NUMBER :DRE 22-MAY-86
	CBCT(R12)			:ANY DATA IN TMPBF1?	:DRE 22-MAY-86
	LHL	R1,FACBUF		:JS 22-SEP-86
	LR	R12,R12			:REST RESULT		:DRE 22-MAY-86
	JEFS	PCR360			:NO, SKIP THIS 		:DRE 22-MAY-86
	AR	R8,R12			:SET UP LENGTH OF MESSAGE :DRE 22-MAY-86
PCR350	LHI	R1,TMPBF1		:TEMPORARY BUFFER	:DRE 22-MAY-86
	JAL	R4,GCI			:GET A CHARACTER	:DRE 22-MAY-86
	LHL	R1,FACBUF					:DRE 22-MAY-86
	JAL	R4,WCI			:PUT IT IN FACBUF	:DRE 22-MAY-86
	SIS	R12,1			:DECREMENT COUNTER	:DRE 22-MAY-86
	JGBS	PCR350			:CONTINUE IF NOT FINISHED :DRE 22-MAY-86
PCR360	L	R4,TEMP			:POSITION OF TOTAL LENGTH
	LB	R0,,R4			:UPDATE IT BY R8
	AR	R0,R8
	STB	R0,,R4
	L	R4,TEMP1
	LB	R0,,R4
	AR	R0,R8
	STB	R0,,R4
	L	R4,TEMP4
	LB	R0,,R4
	AR	R0,R8
	STB	R0,,R4


:	IF SUBSCRIBED TO CUG FACILITY AND HAVE NOT GOTTEN ANY CUG INDICATION
:	IN THE CALL REQUEST, USE THE PREFERENTIAL CUG.
PCR390	HS
  IF	X.25&CUGENA			:IF CUG CODE ENABLED
	TBT	RL,CUS.F
	JE	PCR396			:IF NOT SUBSCRIBED TO CUG

:-------------------------------------------------------------	:HJR 02-02-87
:   temp2+2 ::= 0FFFF, 03, or 09 if had no facil code, CUG facil, or
:   CUG+OA respectively.  Make into 0, 4, or 8, respectively, to create
:   index based on type of facility received.  Then adjust index to
:   account for subscription to pref CUG and to Outgoing Access.
	lis	r12,0
	lh	r2,temp2+2		:get saved facil code
	jlfs	pcr39a			:if none
	ais	r12,4			:since at least cug
	chi	r2,fc.cug		:is it cug?
	jefs	pcr39a			:if yes
	ais	r12,4			:else must be cug/oa

:   Check Pref because it can make a difference even if we have a cug
:   facility in the Call Request.
pcr39a	lh	r4,cup.lt,rl,rl		:get pref CUG
	jlfs	pcr39b			:skip if dont have one
	ais	r12,1			: else adjust index
pcr39b	tbt	rl,cuo.f		:check if subscr to OA
	jefs	pcr39c			:skip if not
	ais	r12,2			: else adjust index

:   Since we dont have a cug # yet, we cant tell whether outgoing calls
:   are barred within the CUG.  In any case, we may just want to clear
:   the call or send and ordinary call without making the OCB check.
pcr39c	lb	r2,pcr.oc,r12		:jump thru table assuming
	j	pcr.od,r2		: -OCB until we know cug #

pcr.od
pcr3aa	lhi	r12,dia076		:cug[oa] facil required	:HJR 07-06-87
	jfs	pcr3a0						:HJR 07-06-87
pcr3ab	lhi	r12,dia182		:-OUTGOING/cugoa recvd	:HJR 07-06-87
	jfs	pcr3a0						:HJR 07-06-87
pcr3ac	lhi	r12,dia065		:facil not allowed	:HJR 07-06-87
pcr3a0	j	rteca0			:go clear the call	:HJR 07-06-87
pcr3a1	j	pcr396			:ordinary call
pcr3a2	lh	r4,temp2		:cug
pcr3a3	lhi	r8,ut.cug		:pref			:DRE 15-JUN-87
	jfs	pcr39f
pcr3a4	lh	r4,temp2		:cug+oa
pcr3a5	lhi	r8,ut.cuo		:pref+oa		:DRE 15-JUN-87

pcr39f	lr	r7,rl			:now that we have a cug#
	slls	r7,cug.sc		: check for +/-OCB
	tbt	r4,ocb.f,r7,
	je	pcr394			:go create cug iix msg	:HJR 07-06-87
	tbt	r12,pcrocb		:check for clear or OA	:HJR 07-06-87
	jn	pcr396			:if ordinary call	:HJR 07-06-87
	lhi	r12,dia182		:call barred		:HJR 07-06-87
	j	rteca4						:HJR 07-06-87

: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:   Now we can fill in the jump table.  NAD won't allow us to fill in a
:   BC table using addresses which are yet to be defined. ?!?!?!##??
:   Jump table offsets use PCR.OD as their base.
: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:
:   PCR.OC is a 12 byte array based on the following chart, which
:   specifies the action to be taken for a CUG facility received under
:   various possible combinations of Preferential CUG and/or Outgoing
:   Access subscribed or not subscribed when outgoing calls are not
:   barred within the CUG.  For definition of action see below.  The
:   chart should match Table 24 in X.25-1984 and Figure 4-5 in draft
:   X.301-1986 (which corrects errors in Figure 25 in X.300-1984).
:   
:       ----------------------------------------------------
:       | SUBSC \ FACIL  || NONE     | CUG      | CUGOA    |
:       ====================================================
:       | NONE           || call     | clear    | clear    |
:       ----------------------------------------------------
:       | IA (1)         || clear    | cug      | clear    |
:       ----------------------------------------------------
:       | [IA], PREF     || pref     | cug      | clear    |
:       ----------------------------------------------------
:       | [IA], OA       || call     | cug      | cug+oa   |
:       ----------------------------------------------------
:       | [IA], OA, PREF || pref+oa  | cug+oa   | clear    |
:       ----------------------------------------------------
:	(1) - CUG without any of Pref, IA, or OA is not allowed.
:
: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:   
:   PCROCB is a 16 bit array, of which only 12 bits are significant,
:   each of which specifies an action to be taken, clear or ordinary
:   call, when Outgoing Calls are barred within the CUG selected for a
:   call.  The index generated for use with PCR.OC is also used here.
:   
:       ----------------------------------------------------
:       | SUBSC \ FACIL  || NONE     | CUG      | CUGOA    |
:       ====================================================
:       | IA (1)         || clear    | clear    | clear    |
:       ----------------------------------------------------
:       | [IA], PREF     || clear    | clear    | clear    |
:       ----------------------------------------------------
:       | [IA], OA       || call     | clear    | call     |
:       ----------------------------------------------------
:       | [IA], OA, PREF || call     | clear    | clear    |
:       ----------------------------------------------------
:   
: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:   
:   	The various actions are:
:   
:   	    clear	= clear call with 'outgoing access barred'
:   	    call	= make call without any cug facility
:   	    cug		= make a cug call using the requested cug #
:   	    cug+oa	= make a cug/oa call using requested cug #
:   	    pref	= make a cug call using the preferential cug #
:   	    pref+oa	= make a cug/oa call using preferential cug #
:
: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:   NOTE:  the case where we have a cug or cug/oa facility but have no
:   CUG subscription is handled in the CRFAC routine (PCAC30).  The call
:   is cleared.
: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

pcr.oc	bc	pcr3aa-pcr.od		:clear, facil required	:HJR 07-06-87
	bc	pcr3a3-pcr.od		:pref
	bc	pcr3a1-pcr.od		:ordinary call
	bc	pcr3a5-pcr.od		:pref+oa
	bc	pcr3a2-pcr.od		:cug
	bc	pcr3a2-pcr.od		:cug
	bc	pcr3a2-pcr.od		:cug
	bc	pcr3a4-pcr.od		:cug+oa
	bc	pcr3ab-pcr.od		:clear, -OUTGOING	:HJR 07-06-87
	bc	pcr3ac-pcr.od		:clear, cug/oa not allowed with PREF :HJR 07-06-87
	bc	pcr3a4-pcr.od		:cug+oa
	bc	pcr3ac-pcr.od		:clear, cug/oa not allowed with PREF :HJR 07-06-87

pcrocb	hc	3020		:0=clear, 1=ordinary call

:-----------------------------------------------------------------------

PCR394	SLLS	R4,2			:MAKE INTO FULL WORD INDEX
	LHI	R12,DIA187		:NON EXISTENT CUG
	LHL	R7,CUG.LT,RL,RL					:HJR 02-02-87
	JE	RTECA4			:IF NO TABLE PRESENT
	L	R7,CUGTAB,R7,R4		:GET INTERLOCK CODE	:HJR 02-02-87
	JE	RTECA4			:IF NO INTERLOCK CODE PRESENT

:	SEND INTERLOCK CODE VIA UTILITY ESCPAED MSG
	LIS	R0,6+1+2		:CUG UTILITY+MSG CODE+2 LENGTHES
	JAL	R4,WCI
	LHI	R0,EXMC			:UTILITY ESCAPED MSG CODE
	JAL	R4,WCI
	LIS	R0,6+1			:CUG UTILITY + 1 LENGTH
	JAL	R4,WCI			:1ST LENGTH
	SIS	R0,1
	JAL	R4,WCI			:2ND LENGTH
	LR	R0,R8			:COPY CODE		:HJR 02-02-87:DRE 15-JUN-87
	JAL	R4,WCI			:WRITE UTILITY CODE	:HJR 02-02-87
	LIS	R0,4			:LENGTH OF CUG UTILITY
	JAL	R4,WCI
	EXHR	R0,R7
	EXBR	R0,R0
	JAL	R4,WCI			:1ST BYTE OF INTERLOCK CODE
	SRLS	R0,8
	JAL	R4,WCI			:2ND BYTE
	EXBR	R0,R7
	JAL	R4,WCI			:3RD BYTE
	SRLS	R0,8
	JAL	R4,WCI			:4TH BYTE
	CBCT(R12)			:GET TOTAL COUNT IN FACBUF :DRE 15-JUN-87
	SIS	R12,$A10		:MINUS LENGTH OF CUG	:DRE 15-JUN-87
	J	PCR398

:ALWAYS SEND A UTILITY MESSAGE EVEN IF WE CAN'T FIND ANY THING TO PUT IN IT
PCR396	LIS	R0,1+2			:MSG CODE+2 LENGTHES
	JAL	R4,WCI
	LHI	R0,EXMC			:UTILITY ESCAPED MSG CODE
	JAL	R4,WCI
	LIS	R0,1			:1 LENGTH
	JAL	R4,WCI			:1ST LENGTH
	LIS	R0,0
	JAL	R4,WCI			:2ND LENGTH
	CBCT(R12)			:GET TOTAL COUNT IN FACBUF :DRE 15-JUN-87
	SIS	R12,$A4			:MINUS LENGTH OF DUMMY	:DRE 15-JUN-87
PCR398	JAL	R4,GCI			:GET BYTE FROM HEAD	:DRE 15-JUN-87
	JAL	R4,WCI			:PUT AT END		:DRE 15-JUN-87
	SIS	R12,1			:CONTINUE UNTIL UTILITIES :DRE 15-JUN-87
	JGBS	PCR398			:ARE AT THE BEGINING	:DRE 15-JUN-87
  EI
PCR400	LIS	R12,1			:INDICATE RECEIVING CALL REQUEST FROM 
					:LINK	:JS 30-DEC-87
	JAL	R7,SETTWP,,		:SET CLASS,WINDOW SIZE, PACKET SIZE
	LHI	R12,DIA039		:PACKET TOO LONG DIAGNOSTIC :DRE 22-NOV-85
	LHI	R2,$A16
	LHL	R4,IPORT
  IF	FSTSLT
:	TBT	RL,FSS.F		:(Have checked it when processed
					:facility)		:LSH 14-JUL-87
:	JEFS	PCR410			:IF NOT SUBSCRIBED TO FAST SELECT
	TBT	R4,FSTSEL,,
	JEFS	PCR410			:IF NO FAST SELCET
	LHI	R2,$A128
	CR	R6,R2						:JL 16-Nov-84
	JG	RTECAL						:JL 16-Nov-84
	STH	R6,FSTCNT,R4,R4					:JL 16-Nov-84
	JFS	PCR411						:JL 16-Nov-84
  EI
PCR410	CR	R6,R2
	JG	RTECAL			:IF TOO MUCH CALL USER DATA
PCR411	HS	0
:: BEGIN OF THE CHANGES	:JS-ONREG
: IF NUI FACILITY IS NOT SPECIFIED IN THE CALL REQUEST PACKET AND THE 
: DTE IDENTIFICATION PROCESS IS IN SUCCESSFUL STATE, THE DTE IDENTIFICATION
: WHICH INCLIDES THE USERNAME AND PASSWORD IS COPIED FROM IDN BUFFER AND/OR
: SIG BUFFER TO NUISAV BUFFER.  THE INTERFACE WILL USE THIS VALIDATED DTE
: IDENTIFICATION TO LOG INTO THE DESTINATION DCE.
  IF	X.32
	TBT	R4,NUICAL,,		:WAS THIS A NUI CALL?
	JN	PCR412			:YES - FORGET DTEID
	LB	R0,IDSTAT,RL,		:GET STATE OF IDENTIFICATION PROCESS
	CLHI	R0,IDSUC		:DTE IDENTIFICATIN SUCCESSFUL?
	JN	PCR412			:NO - SKIP
	LIS	R9,0			:MAKE NUI SAVE AREA INDEX
	LR	RL2,RL
	SLLS	RL2,1			:MAKE HALF-WORD INDEX
	L	R13,IDNPNT,RL2,RL2	:GET ADDRESS OF IDN BUFFER
	JAL	R12,IDSAVE		:COPY USERNAME AND/OR PASSWRD TO NUISAV
	L	R13,SIGPNT,RL2,RL2	:GET ADDRESS OF SIG BUFFER
	JAL	R12,IDSAVE
	STH	R9,TEMP6		:SAVE LENGTH OF NUI
	LHL	R3,IPORT
	SBT	R3,NUICAL,,		:TREAT AS NUI CALL
  EI	:X.32
:: END OF THE CHANGES	:JS-ONREG
:	IF RCVD RPOA FACILITY, CLEAR THE CALL IF THE REQUESTED RPOA MATCHES
:	OUR DNIC.
PCR412	LHL	R3,IPORT
	TBT	R3,RPOA.F,,
	JE	PCR420			:IF DID NOT RCV RPOA
	LHI	R12,DIA178		:CLEARING DIAGNOSTIC IF RPOA ON ODNIC TABLE
	LHL	R0,RPOA.R,R3,R3		:RPOA DNIC TO COMPARE WITH
 IF LIIFLAG							:HJR-SWBT1
	LB	R1,XCOM2,,		:IF XCOM2, USE 'MYDNIC'	:HJR-SWBT1
	JEFS	PCR415						:HJR-SWBT1
	CLH	R0,MYDNIC,,		:IS IT OURS		:HJR-SWBT1
	JE	RTECA0			:CLEAR IF YES		:HJR-SWBT1
	J	PCX000,,		:ELSE GO DO XCOM2 FINISH :HJR-SWBT1
PCR415								:HJR-SWBT1
 EI :LIIFLAG							:HJR-SWBT1
	JAL	R1,FNDONI		:SEARCH ODNIC TABLE
	SKIPAD(RTECA0)			:MATCH FOUND,GO CLEAR THE CALL

PCR420
 IF LIIFLAG							:HJR-SWBT1
	LB	R1,XCOM2,,		:IF XCOM2,		:HJR-SWBT1
	JN	PCX000,,		: GO DO XCOM2 FINISH	:HJR-SWBT1
 EI :LIIFLAG							:HJR-SWBT1
	LHL	R4,IPORT					:DRE 22-MAY-86
	TBT	R4,GATWAY,,
	JE	PCR460			:IF DEFINITELY NOT A GATEWAY CALL
	LHL	R12,DIA065		:SET UP BAD FACILITY	:HJR-SWBT0
	TBT	R4,NUICAL,,		:WAS THIS A NUI CALL	:DRE 31-DEC-85
	JN	PCR457			:YES, THEN ONLY TARGET PROFILE IS COMPATABLE	:DRE 31-DEC-85

:	SEARCH THROUGH BOC DNICS TABLE TO SEE WHETHER THIS IS BOC NETWORK CALL,
:	 IF NOT BOC NETWORK CALL, THEN
:	SEARCH THROUGH GATEWAY TABLES TO SEE IF WE HAVE LOGIN STRING TO
:	 USE FOR THIS DNIC
	LHI	R12,DIA067		:INVALID CALLED ADDRESS
	SLLS	R4,3
	LHL	R0,DTESAX,R4,		:GET DNIC		:HJR-SWBT1
   IF	\BOC.SW							:SCY 10-Mar-86
	LIS	R1,0			:INDEX INTO BOCTAB
PCR427	LHL	R3,BOCTAB,R1,
	JEFS	PCR429			:GOTO SEARCH GATWAY TABLE
	CR	R0,R3			:COMPARE DNIC WITH BOC DNIC
	JE	PCRB10			:GOTO HANDLE BOC NETWORK CALL
	AIS	R1,2			:INCRE. INDEX INTO BOCTAB
	JBS	PCR427
   EI	\BOC.SW						:SCY 10-Mar-86
PCR429	LR	R2,RL
	SLLS	R2,2
	L	R4,GWDNIC,R2,		:PTR TO DNICS FOR THIS LINK
	JE	PCR457
PCR430	LHL	R3,,R4			:FLAGS AND GA.LIS OFFSET
	JN	PCR433
	TBT	RL,NNTN.F
	JE	PCR457						:SCHEN 25-Feb-85
	LHL	R3,IPORT
	RBT	R3,GATWAY,,		:NOT GATWAY CALL
	ST	R5,TEMP			:SAVE RING POINTER
	ST	R6,TEMP1		:SAVE RING CHAR POINTER
	J	PCR500			:GO HANDLE CALL USER DATA
PCR433	THI	R3,0C000		:GATEWAY DNIC ??	:SCHEN 25-Feb-85
	JNFS	PCR435			:IF NOT
	LHL	R1,2,R4						:SCHEN 28-Feb-85
	CR	R0,R1			:MATCH DNIC IN TABLE ??	:SCHEN 28-Feb-85
	JEFS	PCR440			:IF MATCH
PCR435	AIS	R4,4			:TO NEXT DNIC ENTRY
	J	PCR430

PCR440	LHI	R12,DIA119		:CLEARING CAUSE FOR UNKNOWN RPOA :DRE 22-NOV-85
	NHI	R3,3FFF			:OFFSET TO CANNED USER LOGIN STRING
	LI	R8,GA.LIS,R3		:BIAS
	LHL	R1,IPORT
	TBT	R1,RPOA.F,,		:WAS RPOA FACILITY REQUESTED ??
	JE	PCR450			:IF NOT, USE GATEWAY LOGIN STRING
	LHL	R0,RPOA.R,R1,R1		:ELSE FIND RPOA STRING
PCR445	AIS	R4,4
	LHL	R2,,R4			:TYPE (2), LIS OFFSET (14)
	JE	PCR457
	THI	R2,0C000		:TABLE ENTRY FOR RPOA DNIC ??
	JE	PCR457
	CLH	R0,2,R4			:DNIC MATCH ??
	JNBS	PCR445			:IF NOT
	NHI	R2,3FFF			:MASK OFF TYPE FLAGS
	LI	R8,GA.LIS,R2		:BIAS


:	GATEWAY CALL.
:	SEND CANNED USER NAME AND PASSWORD THAT TAKES US TO GATEWAY
:	INDEXED BY DNIC (FROM CALLED ADDRESS OR RPOA) CALLED.
:	USERNAME IS SAVED IN IEDBUF UNTIL ISIS TELLS US THE DISPATCHER
:	PORT TO USE. IT IS THEN MOVED TO THE IDBUF FOR THAT PORT.
:	(R1)= IPORT
:	(R8)= SC FORMAT LOGON STRING ADDRESS.

PCR450	SBT	R1,GATWAY,,		:SET FLAG
	LHL	R1,IEDBUF
	LB	R7,,R8			:FIRST BYTE IS LENGTH
	AIS	R8,1
	LR	R0,R7
	AIS	R0,1			:ACCOUNT FOR CIRCUIT SPEED INDICATOR
	JAL	R4,WCI			:WRITE LENGTH
	JAL	R12,GETCSI		:GET (R0)= CIRCUIT SPEED INDICATOR
	JAL	R4,WCI			:WRITE CIRCUIT SPEED INDICATOR
PCR455  LB	R0,,R8			:GET DATA
	JAL	R4,WCI			:WRITE REST OF NAME
	AIS	R8,1
	SIS	R7,1
	JNBS	PCR455
	ST	R5,TEMP			:SAVE RING POINTER
	ST	R6,TEMP1		:SAVE RING CHAR POINTER
	J	PCR500			:GO HANDLE CALL USER DATA

PCR457	LHI	R12,DIA065		:"FACILITY CODE NOT ALLOWED":JS 15-MAR-88
	TBT	RL,TRGP.F		:TARGET PROFILE REQUEST FOR THIS LINK?
	JE	RTECAL			:UNKNOWN DNIC/RPOA, CLEAR THE CALL

:	SEND A LOGIN STRING "username:GdnicTtnic" TO REQUEST THE
:	TARGET PROFILE SUPPORT FROM THE NETWORK SUPERVISOR

	LHL	R2,IPORT
	SBT	R2,CUNTRG,,		:SET THE FLAG FOR GOING TO USE :G
:	RBT	R2,GATWAY,,					:DRE 2-JUN-87
	LHI	R0,$A11+X.25		:COMPUTE LENGTH OF LOGIN STRING:LSH 18-MAR-87
	TBT	R2,RPOA.F,,		:WAS RPOA FACILITY REQUESTED?
	JEFS	PCR459
	AIS	R0,5			:ADD T + TNIC
PCR459
	SBT	RL,TEMP2		:SET "USE NETUSERPREFIX" FLAG
	SBT	R2,NTNCAL,,		:SET NTN CALL FLAG
	ST	R5,TEMP			:SAVE RING POINTER
	ST	R6,TEMP1		:SAVE RING CHAR COUNT
	LHL	R1,IEDBUF		:RESTORE BUFFER INDEX
	TBT	R2,NUICAL,,		:WAS THIS A NUI CALL?	:DRE 31-DEC-85
	JE	PCR472			:NO, PUT LOGIN STRING INTO IEDBUF :DRE 16-JAN-86
	LR	R7,R2			:COPY IPORT		:DRE 16-JAN-86
	SLLS	R7,3			:CONVERT TO DWORD INDEX	:DRE 16-JAN-86
	J	PCR900			:HANDLE NUI CALL	:DRE 16-JAN-86

   IF	\BOC.SW						:SCY 10-Mar-86
PCRB10
	ST	R5,TEMP			:SAVE RING POINTER
	ST	R6,TEMP1		:SAVE RING CHAR COUNT
	LR	R7,R4			:COPY INDEX
	LIS	R0,7			:4 DIGITS OF DNIC + 3 DIGITS OF DNPA
	LHL	R2,DTESAX+2,R4,		:GET 4 DIGITS		:HJR-SWBT1
	SRLS	R2,4			:R2 CONTAINS DNPA
	LIS	R5,0			:R5= INDEX INTO MLDTAB
PCRB30
	LHL	R6,MLDTAB,R5,
	JEFS	PCRB50			:END OF TABLE
	CR	R2,R6		
	JEFS	PCRB40
	AIS	R5,4
	JBS	PCRB30
PCRB40
	AH	R0,MLDTAB+2,R5,		:ADD ADDITIONAL DIGITS FORM DCO
PCRB50
	LHL	R1,IPORT
	RBT	R1,GATWAY,,
	SBT	R1,NTNCAL,,
	SBT	R1,NUNCAL,,
	RBT	RL,TEMP2,,		:RESET USE NETUSERPREFIX FLAG
	LHL	R1,IEDBUF
	LR	R8,R0			:COPY LENGTH
	AIS	R0,2			:ADD CS AND AN ASCII 9
	JAL	R4,WCI,,		:WRITE LENGTH
	JAL	R12,GETCSI,,
	JAL	R4,WCI,,		:WRITE CIRCUIT SPEED
	LHI	R0,42
	JAL	R4,WCI,,		:WRITE AN ASCII B	:AHM-XINTRPT 05-29-87
	LIS	R9,0			:NO APPENDING PERIOD NEEDED
	J	PCR494,,
   EI	\BOC.SW							:SCY 10-Mar-86

:	OUR DNIC OR CALLED ADDRESS < 4 DIGITS.
:	USERNAME IS SAVED IN IEDBUF UNTIL ISIS TELLS US THE DISPATCHER
:	PORT TO USE.  IT IS THEN MOVED TO THE IDBUF FOR THAT PORT.
:	USE DTE ADDRESS PAST DNIC FOR USER NAME, AND EXPECT TO FIND
:	PASSWORD IN CALL USER DATA IF NEEDED.

:	NUNCAL SET IF NUMERIC USERNAME PAST DNIC STARTS WITH 9.
:	NTNCAL SET IF CLD LENGTH > 4 AND DOESN'T START WITH 9.

:	LOGIN STRING MAY BE OF THE FOLLOWING FORMATS:
: <CS> <X25.> <5 DIGIT O HOST> : <5 DIGIT D HOST> [.<0-4 DIGIT S HOST>]
: <CS> <X75.> <4 DIGIT O DNIC> : <5 DIGIT D HOST> [.<0-4 DIGIT S HOST>]
: <CS> <1-10 DIGIT USERNAME>
:	WHERE
:		<CS>   = CIRCUIT SPEED CHARACTER  (1)
:		<X25.> = NETWORK USERNAME PREFIX CHARACTERS  (4)
:		<X75.> = NETWORK USERNAME PREFIX CHARACTERS  (4)
:		O HOST = ORIGINATING HOST OF LINK RECEIVING THE CALL  (4)
:		O DNIC = ORIGINATING NETWORK DNIC FROM CALLING ADDRESS  (5)
:		D HOST = DESTINATION HOST #  (5)
:		S HOST = SUB HOST ADDRESS DIGITS  (variable)



PCR460	ST	R5,TEMP			:SAVE RING POINTER
	ST	R6,TEMP1		:SAVE RING CHAR COUNT
	RBT	RL,TEMP2		:RESET "USE NETUSERPREFIX" FLAG
	LHL	R2,IPORT
	LR	R7,R2
	SLLS	R7,3			:INDEX TO SAVED CALLED ADDRESS
	TBT	R2,NUICAL,,		:WAS THIS A NUI CALL?	:DRE 31-DEC-85
	JN	PCR900			:HANDLE NUI CALL	:DRE 31-DEC-85
	LB	R8,DTESAX+7,R7,		:# OF CLD DIGITS	:HJR-SWBT1
	JE	PCR500			:IF 0 DIGIT, HANDLE AS DIRECT CALL
  IF	ITNTN				:IF ITAPAC NTN OPTION ENABLED :SCY 24-Mar-86
	TBT	RL,ITNT.F
	JE	PCR461
	SBT	R2,NTNCAL,,
	RBT	RL,TEMP2		:RESET USE NETUSERPREFIX FLAG
	LHL	R1,IEDBUF		:LOGIN NAME IS SAVED IN IEDBUF
	LIS	R0,1+1+2		:COMPUTE LENGTH OF LOGIN STRING
					:<CS>+9+<2 DIGITS FROM NTN>
	JAL	R4,WCI			:WRITE LENGTH
	JAL	R12,GETCSI		:GET CIRCUIT SPEED INDICATOR
	JAL	R4,WCI			:WRITE CIRCUIT SPEED INDICATOR
	LHI	R0,39			:9 INDICATE A NATIONAL USER NUMBER
	JAL	R4,WCI			:WRITE AN ASCII 9
	AIS	R7,2			:ADVANCE FOR DNIC	:HJR-SWBT1
	LIS	R8,2			:R8 CONTAIN DIGIT COUNT
	LIS	R9,0			:NO APPENDING PERIOD NEEDED
	J	PCR494			:GOTO COPY CALLED ADR INTO IEDBUF
  EI	ITNTN							:SCY 24-Mar-86
PCR461								:SCY 24-Mar-86
	TBT	RL,NNTN.F		:NO NTN FOR THIS LINK?	:SCHEN 25-Feb-85
	JN	PCR500			:IF SO, PROCESS PID	:SCHEN 25-Feb-85
	LB	R0,DTESAX,R7,		:FIRST TWO DIGITS OF DNIC :HJR-SWBT1
	NHI	R0,0F0			:MASK TO FIRST DIGIT ONLY
	JE	PCR466			:IF NOT A DNIC,  0 + <HOST #>
	SIS	R8,4			:SUBTRACT OFF DNIC
	JLE	PCR500			:IF <=4, NON-NTN CALL
	SBT	R2,NTNCAL,,		:SET NTN CALL FLAG
	LCS	R9,1			:NO REMAINDER FLAG
	LB	R12,DTESAX+2,R7,	:GET FIRST TWO DIGITS	:HJR-SWBT1
	SRHLS	R12,4			:POSITION FOR FIRST DIGIT PAST DNIC
	CLHI	R12,9			:IS IT A 9 ??
	JN	PCR462			:IF NOT
	SBT	R2,NUNCAL,,		:FLAG NUMERIC USERNAME
	CLHI	R8,1			:IS THAT ALL THERE IS ??
	JN	PCR490			:IF NOT, PROCESS CLD PAST DNIC AS USERNAME
	RBT	R2,NTNCAL,,		:ELSE RESET NTN CALL FLAG
	RBT	R2,NUNCAL,,		:RESET NUMERIC USERNAME FLAG
	J	PCR500			:TREAT AS A DIRECT CALL

PCR462	CLHI	R12,8			:IS IT A 8 NUMERIC USER	:DRE 11-APR-86
	JN	PCR464			:NO, TRY FOR REGULAR NTN :DRE 11-APR-86
	SBT	R2,NUNCAL,,		:YES, HANDLE AS NUN	:DRE 11-APR-86
	LHI	R9,-6,R8		:CALCULATE REMAINDER, NEG OK :DRE 11-APR-86
	JLE	PCR490			:GO DO SHORT NUN	:DRE 11-APR-86
	LIS	R8,6			:INDICATE LENGTH OF NUN IS 6 CHARS :DRE 11-APR-86	
	J	PCR490			:GO DO NUN WITN SUBHOST	:DRE 11-APR-86
PCR464	CLHI	R8,6			:TOO SHORT FOR X.121 #?	:DRE 11-APR-86
	JL	PCR490			:TREAT WHOLE NTN AS USERNAME
	L	R0,DTESAX+2,R7,		:GET A BUNCH OF CLD	:HJR-SWBT1
	SRLS	R0,8			:KEEP FIRST 6 DIGITS OF NTN :HJR-SWBT1
	CL	R0,HIHST,,		:COMPARE AGAINST USER SPECIFIED LIMIT
	JG	PCR490			:TREAT WHOLE NTN AS USERNAME

:	CONSTRUCT USERNAME, USE NTN AS DESTINATION HOST
PCR466	SBT	R2,NTNCAL,,		:FLAG NTN CALL
	SBT	RL,TEMP2		:SET "USE NETUSERPREFIX" FLAG
	LHI	R0,$A11+X.25		:COMPUTE LENGTH OF LOGIN STRING:LSH 18-MAR-87
	LHL	R1,IEDBUF		:<CS>+<O HOST/O DNIC>+:+<D HOST> (PREFIX LATER)
	CLHI	R8,5
	JGEFS	PCR468			:IF ENOUGH DIGITS
	LIS	R8,5			:FAKE 5 DIGITS
PCR468	SIS	R8,6			:ANY SUB HOST DIGITS ?
	JLEFS	PCR470			:IF NOT
	AHI	R0,1,R8			:ACCOUNT FOR PERIOD AND DIGITS
PCR470	TBT	R2,GATWAY,,		:TEST FOR GATEWAY CALL
	JEFS	PCR472			:IF NOT
	AIS	R0,5			:ALLOW FOR PERIOD AND ODNIC
PCR472	JAL	R4,WCI			:WRITE LENGTH
	L	R12,BE,R1,		:GET POSITION OF LENGTH
	ST	R12,TEMP7		:SAVE FOR LATER
	LHL	R12,IPORT
	SBT	R12,CUN,,		:SET CONSTRUCTED USERNAME FLAG
	JAL	R12,GETCSI		:GET CIRCUIT SPEED INDICATOR
	JAL	R4,WCI			:WRITE CIRCUIT SPEED INDICATOR

:	FIRST PART OF USERNAME IS NETUSERPREFIX
	LIS	R8,0			:INIT COUNTER FOR PREFIX LENGTH
	LB	R0,LIP.LT,RL2,RL2	:FIRST CHARACTER
	JE	PCR473			:BRANCH IF NULL CHARACTER
	JAL	R4,WCI
	AIS	R8,1			:BUMP PREFIX LENGTH COUNTER
	LB	R0,LIP.LT+1,RL2,RL2	:SECOND CHARACTER
	JE	PCR473			:BRANCH IF NULL CHARACTER
	JAL	R4,WCI
	AIS	R8,1			:BUMP PREFIX LENGTH COUNTER
	LB	R0,LIP.LT+2,RL2,RL2	:THIRD CHARACTER
	JE	PCR473			:BRANCH IF NULL CHARACTER
	JAL	R4,WCI
	AIS	R8,1			:BUMP PREFIX LENGTH COUNTER
	LB	R0,LIP.LT+3,RL2,RL2	:FOURTH CHARACTER
	JEFS	PCR473			:BRANCH IF NULL CHARACTER
	JAL	R4,WCI
	AIS	R8,1			:BUMP PREFIX LENGTH COUNTER
PCR473	L	R2,TEMP7		:GET POSITION OF BYTE COUNT
	LB	R0,,R2			:GET STARTING BYTE COUNT
	AR	R0,R8			:ADD IN LENGTH OF PREFIX
	STB	R0,,R2			:UPDATE BYTE COUNT IN BUFFER
  IF	X.25
:	SECOND PART OF USER NAME IS ORIGINATING HOST # <O HOST>
	LB	R2,LH.MT,RL,		:HOST ORDINAL
	SLLS	R2,1			:CONVERT TO HALFWORD OFFSET
	LHL	R0,HOSTS,R2,		:GET HOST #
	JAL	R9,GETBCD,,		:CONVERT TO DECIMAL, R2=RESULT
	LR	R5,R2			:MOVE TO PROTECT RESULT
	LHI	R6,10			:LOOP AND SHIFT COUNT
  ELSE	X.75
:	SECOND PART OF USERNAME IS ORIGINATION NETWORK DNIC <O DNIC>
	LIS	R2,0			:DEFAULT CLG DNIC OF 0
	LHL	R7,IPORT					:SCY 1-Oct-84
	SLLS	R7,3			:INDEX TO SAVED CALLING ADDRESS	:SCY 1-Oct-84
	LB	R1,DTESAV+7,R7,		:GET BYTE COUNT OF CLG	:HJR-SWBT1
	CLHI	R1,4			:WAS A DNIC SPECIFIED ??
	JLFS	PCR474			:IF NOT, USE 0000
	LHL	R2,DTESAV,R7,		:GET CALLING ADDRESS DNIC :HJR-SWBT1
PCR474	LHI	R6,0C			:LOOP AND SHIFT COUNT	:LSH 18-MAR-87
    EI	:X.75							:LSH 18-MAR-87
	LR	R5,R2			:MOVE TO PROTECT RESULT	:LSH 18-MAR-87
	LHL	R1,IEDBUF		:RESTORE BUFFER INDEX
PCR476	LR	R0,R5			:POSITION RESULT
	SRL	R0,,R6			:GET OCTET INTO POSITION
	NHI	R0,0F			:KEEP ONLY FOUR BITS
	AHI	R0,30			:CONVERT TO ASCII DIGIT
	JAL	R4,WCI			:ACCUMULATE AS PART OF USERNAME
	SIS	R6,4			:DECREMENT SHIFT COUNT
	JGEBS	PCR476			:IF MORE DIGITS
  IF	0		:THIS CODE DELETED BECAUSE IT DOESN'T	:DRE 2-JUN-87
			:MAKE ANY SENSE EVEN FOR X.75		:DRE 2-JUN-87
	LHL	R2,IPORT		:RELOAD IPORT
	TBT	R2,GATWAY,,		:IS THIS A GATEWAY CALL ??
	JE	PCR480			:IF NOT, FINISH USERNAME
	LHI	R0,2E			:ADD A PERIOD
	JAL	R4,WCI			:WRITE TO BUFFER
	LR	R4,RL2
	SLLS	R4,ONI.SC		:TABLE START POINTER
	LHL	R5,ONI.LT,R4,		:FIRST ODNIC TABLE ENTRY THIS LINK
	LIS	R6,0C			:LOOP AND SHIFT COUNTER
PCR478	LR	R0,R5			:COPY ODNIC
	SRL	R0,,R6			:SHIFT FOR NEXT OCTET
	NHI	R0,0F			:MASK TO 4 BITS
	AHI	R0,30			:MAKE ASCII
	JAL	R4,WCI			:ADD TO BUFFER
	SIS	R6,4			:DECREMENT LOOP COUNTER
	JGEBS	PCR478			:AND CONTINUE
  EI								:DRE 2-JUN-87
								:HJR-SWBT1
PCR480	JAL	R13,BLDHST		:BUILD HOST NAME	:HJR-SWBT1
	J	PCR500			:GO HANDLE CUD		:DRE 20-JAN-86
:   DELETED A ABOUT 80 LINES OF CODE THAT NEVER GOT EXECUTED	:HJR-SWBT1

:	HERE TO TREAT WHOLE NTN AS USERNAME

PCR490	LHL	R1,IEDBUF		:STORE IN IEDBUF PENDING DPORT
	LHI	R0,1,R8			:LEN=USERNAME LENGTH PLUS CIRCUIT SPEED IND
	LR	R9,R9			:ANY REMAINDER ??
	JLEFS	PCR492			:IF NOT
	AHI	R0,2,R9			:LEN=LEN+PERIOD+COLON PLUS REMAINDER 
:					 OF CLD			:AHM-XINTRPT 05-29-87
PCR492	JAL	R4,WCI			:WRITE LENGTH
	JAL	R12,GETCSI		:GET CIRCUIT SPEED INDICATOR
	JAL	R4,WCI			:WRITE IT
	AIS	R7,2			:ADVANCE FOR DNIC	:HJR-SWBT1

:	HERE TO COPY ALL OR PART OF CALLED ADDRESS INTO LOGIN STRING.
:	IF CLD FIRST DIGIT WAS 0 AND AT LEAST 6 DIGITS, THEN OF THE FORM
:		0 + <5 DIGIT DEST HOST> AND NO DNIC GIVEN.
:	IF CLD PAST DNIC BEGINS WITH 9 THEN NUMERIC USERNAME AND ALL ARE
:		COPIED AS USER NAME WITH NO HOST SPECIFIED.
:	IF CLD PAST DNIC SPECIFIES 4 DIGIT HOST PLUS 0-6 DIGITS OF SUBADDRESS
:		THEN ALL ARE USED AS USERNAME AND NO HOST SPECIFIED.
:	IF CLD PAST DNIC IS OF THE FORMAT 0 + <5 DIGIT HOST> + <0-4>
:		SUBADDRESSING DIGITS THEN USERNAME HAS ALREADY BEEN CONSTRUCTED
:		AND HERE TO BUILD DESTINATION HOST # AND POSSIBLY A PERIOD
:		FOLLOWED BY SUBADDRESSING DIGITS.

:	R7=BYTE ADDRESS INTO STORED CALLED ADDRESS IN DTESAX
:	R8=LOGIN USERNAME DIGIT COUNT.  R9>0 MEANS APPEND PERIOD
:	AND REST OF CLD DIGITS AS SUBHOST NUMBER

PCR494	LB	R12,DTESAX,R7,		:GET NEXT 2 DIGITS
	AIS	R7,1			:ADVANCE DTESAX INDEX
	LBR	R0,R12			:LOAD DIGIT PAIR
	SRHLS	R0,4			:POSITION TO FIRST OF TWO DIGITS
	JAL	R5,PUTNUN		:PUT INTO IEDBUF, MAYBE PERIOD TOO	:AHM-XINTRPT 05-29-87
	SKIPAD(PCR500)			:RETURN HERE IF DONE:JS-SKY
	LR	R0,R12			:RELOAD DIGIT PAIR
PCR498	NHI	R0,0F			:POSITION TO SECOND OF TWO DIGITS
	JAL	R5,PUTNUN		:WRITE IT, MAYBE PERIOD TOO		:AHM-XINTRPT 05-29-87
	SKIPAD(PCR500)			:RETURN HERE IF DONE
	J	PCR494			:ELSE GO FOR MORE DIGITS

:	HANDLE NUI LOGIN HERE					:DRE 3-JAN-86

PCR900	JAL	R13,BLDUSR		:CONSTRUCT CIRCUIT SPEED INDICATOR
					:AND USERNAME HERE	:JS-ONREG
:HERE TO CONSTRUCT HOST NUMBER (OR NAME)			:DRE 3-JAN-86
	LB	R8,DTESAX+7,R7,		:# OF CLD DIGITS	:HJR-SWBT1
	JE	PCR950			:IF 0 DIGIT, HANDLE AS HOMED USERNAME :DRE 3-JAN-86
	LB	R0,DTESAX,R7,		:FIRST TWO DIGITS OF DNIC :HJR-SWBT1
	NHI	R0,0F0			:MASK TO FIRST DIGIT ONLY :DRE 3-JAN-86
	JE	PCR930			:IF NOT A DNIC,  0 + <HOST #> :DRE 3-JAN-86
	SIS	R8,4			:SUBTRACT OFF DNIC	:DRE 3-JAN-86
	JLE	RTECAL			:IF <=4, NON-NTN CALL, CLEAR CALL :DRE 3-JAN-86
	LHL	R2,IPORT		:RESTORE IPORT#		:JS 15-MAR-88
	SBT	R2,NTNCAL,,		:SET NTN CALL FLAG	:DRE 3-JAN-86
	LCS	R9,1			:NO REMAINDER FLAG	:DRE 3-JAN-86
	LB	R12,DTESAX+2,R7,	:GET FIRST TWO DIGITS	:HJR-SWBT1
	SRHLS	R12,4			:POSITION FOR FIRST DIGIT PAST DNIC :DRE 3-JAN-86
	CLHI	R12,9			:IS IT A 9 ??		:DRE 3-JAN-86
	JN	PCR932			:IF NOT			:DRE 3-JAN-86
	LHI	R12,DIA065		:"FACILITY CODE NOT ALLOWED":JS 15-MAR-88
	CLHI	R8,1			:IS THAT ALL THERE IS ?? :DRE 3-JAN-86
	JN	RTECAL			:IF NOT, FORMAT INCOMPATABLE WITH NUI :DRE 3-JAN-86
	RBT	R2,NTNCAL,,		:ELSE RESET NTN CALL FLAG :DRE 3-JAN-86
	J	PCR950			:TREAT AS A DIRECT CALL	:DRE 3-JAN-86
PCR930	LIS	R0,5+1+1		:BASIC LENGTH OF THE HOST NUMBER STRI :DRE 3-JAN-86NG
	LB	R3,DTESAX+7,R7,		:GET LENGTH OF CALLED ADDRESS :HJR-SWBT1
	SIS	R3,$A6			:COMPUT SUBPROCESS ID DIGET COUNT :DRE 3-JAN-86
	JFS	PCR937						:DRE 3-JAN-86

PCR932	CLHI	R8,6			:AT LEAST 6 DIGITS OF NTN? :DRE 3-JAN-86
	JL	RTECAL			:ERROR IF LESS		:DRE 3-JAN-86
PCR936	TBT	R2,CUNTRG,,		:TARGET PROGILE USED?	:DRE 3-JAN-86
	JNFS	PCR938			:YES			:DRE 3-JAN-86
	LIS	R0,5+1			:BASIC LENGTH OF THE HOST NUMBER STRING :DRE 3-JAN-86
	LB	R3,DTESAX+7,R7,		:GET LENGTH OF CALLED ADDRESS :HJR-SWBT1
	SIS	R3,$A10			:COMPUT SUBPROCESS ID DIGET COUNT :DRE 3-JAN-86
PCR937	JLEFS	PCR940			:NO SUBPROCESSID DIGITS	:DRE 3-JAN-86
	AHI	R0,1,R3			:ADD DIGIT COUNT AND PERIOD :DRE 3-JAN-86
	JFS	PCR940						 :DRE 3-JAN-86
PCR938	LIS	R0,5+1			:LENGTH OF Gdnic	:DRE 3-JAN-86
								:JS 15-MAR-88
	TBT	R2,RPOA.F,,		:RPOA SPECIFIED		:DRE 3-JAN-86
	JEFS	PCR940			:NO			:DRE 3-JAN-86
	AIS	R0,5			:YES, ADD LENGTH OF Tdnic :DRE 3-JAN-86
PCR940	LHL	R1,IEDBUF					:DRE 3-JAN-86
	JAL	R4,WCI			:WRITE LENGTH		:DRE 3-JAN-86
	JAL	R13,BLDHST		:BUILD HOST NAME STRING	:DRE 3-JAN-86
PCR950	LHL	R1,IEDBUF		:WRITE INTO DATA BUFFER	:DRE 3-JAN-86
	JAL	R4,WCI			:WRITE LENGTH		:DRE 3-JAN-86
	JAL	R13,BLDPWD		:CONSTRUCT PASSWORD	:JS-ONREG

PCR500	JAL	R14,GETCUD		:PROCESS CUD		:HJR-SWBT1
PCR550	JAL	R14,GETTID		:TID, TIMER, (TNIC LIST) :HJR-SWBT1

:	SEND A NORMAL CIRCUIT REQUEST TO DISPATCHER.

PCR559	LHI	R0,RNP.L
	LIS	R1,0			:PORT ZERO
	LHI	R2,NM.RNP		:NORMAL NEEDLE MESSAGE TYPE
	JAL	R4,SLOR,,		:BUILD THE MESSAGE HEADER
	LIS	R0,0
	JAL	R4,PUTCH		:KEY FIELD
	LHL	R0,IPORT
	JAL	R4,PUTH,,		:PUT IN LOCAL KEY
  IF	IIX
	LHI	R0,IX.HIQ		:SMART FLAG
  EI	IIX
:: BEGIN OF THE CHANGES	:JS-ONREG
  IF	X.32
	LHL	R4,IPORT
	TBT	R4,IDICRT,,
	JE	PCR561
	LHI	R0,IX.HIE		:SMART INTERFACE AND REQUEST EXTENDED
PCR561					:LOGIN-STATUS
  EI	:X.32
:: END OF THE CHANGES	:JS-ONREG
	JAL	R4,PUTH,,		:ENTER DIALECT CODE
	LB	R4,LH.MT,RL,		:GET HOST ORDINAL FOR THIS LINK #
	LHL	R0,HOSTS,R4,R4		:GET NETWORK HOST #
	JAL	R4,PUTH,,
	JAL	R12,GETCCT		:GET CCT (TID) - IN R0	:HJR-SWBT1
	JAL	R4,PUTCH		:STICK IN TID		:HJR-SWBT1
	JAL	R4,ELOR,,
	J	RTD020

:-BEGIN - moved and made into subroutine ---------------------	:HJR-SWBT1
: GETCCT - return CCT in R0
: Uses R0,R4.   Link is R12.
:
GETCCT	LB	R0,SAVTID		:GET TID BACK		:HJR-SWBT1
	LHL	R4,IPORT
	RBT	R4,TPAR2		:RESET BIT FOR REAL MODE
  IF	TPIDS				:IF ANY TELENET PROTOCOL ID LINKS
	LR	R0,R0			:CHECK TID		:HJR-SWBT1
	JE	GETCT3
	TBT	RL,TPID.F		:IS THIS LINK ??
	JER	R12			:DONE IF NOT		:HJR-SWBT1
	THI	R0,080			:SEE IF TID SAYS TO USE VIRTUAL MODE
	JEFS	GETCT0			:IF NOT
	SBT	R4,TPAR2		:FLAG TO USE VIRTUAL MODE
  REMIND(GETCCT - EX2741 NOT HANDLED)
:::::	SBT	R4,EX2741		:SET FLAG FOR EXTERNAL 2741 TYPE TTY
GETCT0	OHI	R0,0C0			:MAKE INTO A TYMNET ID
	LB	R4,SAVSPD		:GET SPEED INDEX BACK	:HJR-SWBT1
	TBT	R4,RELSPD,,		:SEE IF THIS SHOULD BE FLAGGED AS HIGH SPEED
	JER	R12			:DONE IF NOT		:HJR-SWBT1
GETCT3	LHI	R0,0CC			:GET 1200 BAUD TID
  EI	TPIDS
	JR	R12			:DONE			:HJR-SWBT1
:-- END ------------------------------------------------------	:HJR-SWBT1

:	BLDUSR - THIS ROUTINE BUILDS THE FIRST PART OF LOGIN STRING
:		 WHICH INCLUDES CIRCUIT SPEED INDICATOR AND USERNAME
:		 INTO IED BUFFER	:JS-ONREG
:	OUTPUT	R1=CURRENT BUFFER ADDRESS OF IED BUFFER
:	USES 	R0-R4, R8,R9
:	LINK	R13 

BLDUSR	LHL	R1,IEDBUF		:WRITE INTO DATA BUFFER	:DRE 3-JAN-86
	JAL	R4,WCI			:WRITE LENGTH		:DRE 3-JAN-86
	L	R12,BE,R1,		:GET POSITION OF LENGTH	:DRE 3-JAN-86
	ST	R12,TEMP7		:SAVE FOR LATER		:DRE 3-JAN-86
	LHL	R12,IPORT					:DRE 3-JAN-86
	SBT	R12,CUN,,		:SET CONSTRUCTED USERNAME FLAG :DRE 3-JAN-86
	JAL	R12,GETCSI		:GET CIRCUIT SPEED INDICATOR :DRE 3-JAN-86
	JAL	R4,WCI			:WRITE CIRCUIT SPEED INDICATOR :DRE 3-JAN-86

:	FIRST PART OF LOGIN STRING IS THE USERNAME		:DRE 3-JAN-86

	LHL	R8,TEMP6		:GET THE LENGTH OF THE ENTIRE NUI :DRE 3-JAN-86
	LIS	R9,0			:MAKE NUI SAVE AREA INDEX :DRE 3-JAN-86
PCR910	SIS	R8,1			:COUNT IT DOWN		:DRE 3-JAN-86
	JLFS	PCR915			:DONE WITH NUI STRING	:DRE 3-JAN-86
	LB	R0,NUISAV,R9		:GET A BYTE OF DATA	:DRE 3-JAN-86
	CLHI	R0,0BB			:DID WE RUN INTO A SEMI-COLON :DRE 3-JAN-86
	JEFS	PCR920			:YES			:DRE 3-JAN-86
	JAL	R4,WCI			:WRITE USERNAME BYTE INTO THE IEDBUF :DRE 3-JAN-86
	AIS	R9,1			:POINT TO NEXT NUI BYTE	:DRE 3-JAN-86
	JBS	PCR910
PCR915
PCR920	LHI	R0,1,R9			:LENGTH OF STRING SO FAR :DRE 3-JAN-86
	L	R4,TEMP7		:GET ADDRESS OF LENGTH BYTE :DRE 3-JAN-86
	STB	R0,,R4			:PUT LENGTH INTO BUFFER	:DRE 3-JAN-86
	STH	R9,TEMP7		:SAVE NUI POINTER	:DRE 3-JAN-86
	STH	R8,TEMP6		:STORE THE LENGTH OF THE REST OF THE  :DRE 3-JAN-86NUI
	JR	R13			:JS-ONREG

:	BLDPWD - BUILD SECOND PART OF LOGIN STRING WHICH IS PASSWORD
:		 INTO IED BUFFER	:JS-ONREG
:	INPUT	R1=CURRENT BUFFER ADDDRESS OF IED BUFFER
:	USES	R0-R4, R8,R9,R12
:	LINK	R13

BLDPWD	LH	R8,TEMP6		:GET THE LENGTH OF THE REST OF THE NUI :DRE 3-JAN-86
	L	R12,BE,R1,		:GET POSITION OF LENGTH	:DRE 3-JAN-86
	ST	R12,TEMP6		:SAVE FOR LATER		:DRE 3-JAN-86
	LHI	R0,0BB			:SEMI-COLON TO TERMINATE USERNAME PART :DRE 3-JAN-86
	JAL	R4,WCI			:WRITE SEMI-COLON TO IEDBUF :DRE 3-JAN-86
	LHL	R9,TEMP7		:RECOVER NUI SAVE AREA INDEX :DRE 3-JAN-86

:	SECOND PART OF LOGIN STRING IS THE PASSWORD		:DRE 3-JAN-86
PCR960	SIS	R8,1			:COUNT IT DOWN		:DRE 3-JAN-86
	JLFS	PCR965			:DONE WITH NUI STRING	:DRE 3-JAN-86
	LB	R0,NUISAV+1,R9		:GET A BYTE OF DATA	:DRE 3-JAN-86
	CLHI	R0,0BB			:DID WE RUN INTO A SEMI-COLON :DRE 3-JAN-86
	JEFS	PCR970			:YES			:DRE 3-JAN-86
	JAL	R4,WCI			:WRITE PASSWORD BYTE INTO THE IEDBUF :DRE 3-JAN-86
	AIS	R9,1			:POINT TO NEXT NUI BYTE	:DRE 3-JAN-86
	JBS	PCR960						:DRE 3-JAN-86
PCR965
PCR970	LHI	R0,1,R9			:LENGTH OF STRING SO FAR :DRE 3-JAN-86
	SH	R0,TEMP7		:SUBTRACT STARTING POINT :DRE 3-JAN-86
	L	R4,TEMP6		:GET ADDRESS OF LENGTH BYTE :DRE 3-JAN-86
	STB	R0,,R4			:PUT LENGTH INTO BUFFER	:DRE 3-JAN-86
	JR	R13			:JS-ONREG
:
::	INICAL - DO SOME INITIALIZATION FOR A CALL FROM THE LINK :DRE 29-MAR-85
:
:	INPUT	IPORT, EPORT
:	LINK IS R9
:
INICAL
	LHL	R2,IPORT
	LIS	R0,0
	STH	R0,PSDIAG,R2,R2
	RBT	R2,FIRSTR
	RBT	R2,TCRCV,,
  IF	PVC
	RBT	R2,PVCCAL		:SHOULDN'T BE SET, RESET ANYWAY!!
  EI	PVC
  IF	X.32				:JS-ONREG
	RBT	R2,IDICRT,,		:RESET VALIDATION CIRCUIT FLAG
  EI	:X.32
	RBT	R2,CUDUSD,,		:MARK CUD NOT USED
 IF LIIFLAG							:HJR-SWBT1
	RBT	R2,CUDSNT,,		:MARK CUD NOT SENT	:HJR-SWBT1
 EI :LIIFLAG							:HJR-SWBT1
	RBT	R2,IPA.F
:	RBT	R2,RPOA.F,,		:MARK RPOA NOT FOUND	:DRE 29-JUN-87
	RBT	R2,NTNCAL,,		:MARK NOT NTN CALL
	RBT	R2,NUNCAL,,		:MARK NOT NUN CALL
	RBT	R2,NUICAL,,		:MARK NOT A NUI CALL	:DRE 23-MAY-86
	RBT	R2,CUN,,		:MARK NOT CONSTRUCTED USERNAME CALL
	RBT	R2,CUNTRG,,		:MARK NOT :G USERNAME CALL
	RBT	R2,PADCHD,,		:MARK NO PAD USE DURING TKSUP
	LHL	R3,EPORT
	RBT	R3,EPA.F
	STB	RL,IL.MT,R2,
	STH	R3,IE.MT,R2,R2
	STH	R2,EI.MT,R3,R3
	AHI	R3,(IEC.BF-FLAGS)*8	:INIT BF PTR FOR CTL,
	SLLS	R2,2
	STH	R3,BF+IECBIA,R2,	:IED IS DONE WHEN PSEUDONEEDLE RETURNS
	AHI	R2,IECBIA
	STH	R2,IECBUF
	AHI	R2,IEDBIA-IECBIA
	STH	R2,IEDBUF
	LIS	R0,1
	STH	R0,BF,R2,		:STORE DUMMY FLAG POINTER
	LR	R1,R2
	JAL	R4,EMPTY,,		:MAKE SURE IED STARTS OUT EMPTY
:					Move the following code from PCR :DRE 2-24-88
:	Keep track of incoming and two-way channels and do host cost, HPA
	LIS	R7,1			:INCREASE ACTIVE CHANNEL COUNT
	AHM	R7,AELCNT,RL2		:INCREMENT COUNT OF USERS ON LINK
					:change to increase APORTS counter
					:in routine FINDIP rather than 
					:here			:LSH 1-JUN-87
:	AHM	R7,APORTS		:COUNT TOTAL PORTS
	LH	R0,LOC.LT,RL,RL
	JLFS	PCR050			:IF CHANNEL MUST BE INC. OR TWO-WAY
	LHL	R1,ELCI			:CHANNEL NUMBER
	CLR	R1,R0
	JLFS	PCR050			:IF NOT OUTGOING
	LIS	R7,0			:DONT COUNT IT
PCR050	ST	R5,TEMP			:SAVE REGS
	ST	R6,TEMP1
	ST	R9,TEMP2
	LCS	R5,1			:INDICATE LESS PATHS AVAILABLE
	JAL	R9,HPACHK,,
   IF	HCO.MX
	JAL	R9,HCOST,,		:CALC HOST COST -- REPORT IF NECESSARY
   EI
	L	R5,TEMP			:RESTORE REGS
	L	R6,TEMP1
	L	R9,TEMP2
	JR	R9			:RETURN


:VALIDATION ROUTINE
VALADR	LB	R2,7,R8,R3		:GET ADDR LENGTH	:HJR-SWBT1
	JE	4,R7			:  ZERO LENGTH, NORMAL RETN :DRE 30-APR-85
:- BEGIN ----------------------------------------------------- :HJR-SWBT1
 IF LIIFLAG

: FOR X.25 - 
: IF PREFIXED ADDRESSING AND HAVE PREFIX THEN DISCARD IT AND UPDATE COUNT.
: IF IDN THEN LENGTH MUST BE FROM 4 TO 14.
: IF JUST NTN THEN LENGTH MUST BE LESS THAN OR EQUAL TO 10.
: APPLIES TO BOTH XCOM-I AND XCOM-II
: FOR X.75 - ASSUME DNIC AND CHECK LENGTH

  IF X.25
	JAL	R9,GDG100		:GET 1st DIGIT
   IF IDNPFX
	LH	R9,PREFIX,,		:PREFIXED ADDRESSING?
	JLFS	VAL020			:IF NOT, DO DNIC CHECK
	CR	R0,R9			:IS DIGIT A PREFIX?
	JN	VAL040			:IF NOT, DO NTN LENGTH CHECK 
	SIS	R2,1			:ELSE WANT TO DISCARD PREFIX
	STB	R2,7,R8,R3		:AND UPDATE SAVED DIGIT COUNT
	JAL	R9,GDG100		:GET 2nd DIGIT, 1st DIGIT OF DNIC
	JFS	VAL070			:GO CHECK IF SUFFICIENT LENGTH
   EI :IDNPFX

VAL020	TBT	R0,DDIGIT,,		:HAVE A DNIC?
	JEFS	VAL040			:IF NOT, DO NTN LENGTH CHECK
	CLHI	R2,0F			:HAVE DNIC, LEN MUST BE < 15
	JLFS	VAL070			:MAX CHECK OK, GO CHECK MIN
	J	VAL090			:ERROR RETURN

VAL040	CLHI	R2,0B			:NO DNIC, LEN MUST BE < 11
	JL	VAL105			:GOOD, GO PROCESS ADDR
	JFS	VAL090			:ERROR RETURN
  EI :X.25

VAL070	LIS	R9,4			:SET UP COMPARE FOR JGE AT VAL090
	CR	R9,R2			:IS DNIC LESS THAN 4 DIGITS
	JGFS	VAL090			:ERROR RETURN IF YES
	LHL	R4,IPORT		:FOR DNIC PRESENT BIT
	SBT	R4,0,R13		:SET HAVE DNIC
  IF X.25
	JFS	VAL105			:GO SAVE 1st DIGIT OF ADDR
  EI :X.25
 EI :LIIFLAG
:-- END ------------------------------------------------------ :HJR-SWBT1

	CLHI	R2,0F			:ERROR > 14
VAL090								:HJR-SWBT1
	SKIPEQ(0,R7)			:   YES
VAL100	JAL	R9,GDG100		:GET DIGIT
VAL105	CHI	R0,9			:TEST IF BCD		:HJR-SWBT1
	SKIPGT(0,R7)			:   NO, ERROR RETURN
VAL110	JAL	R9,SDG100		:STORE DIGIT
	SIS	R2,1			:DECREMENT DIGIT CNTR
					:ALL DIGITS PROCESSED?
	JNBS	VAL100			:   NO, CONTINUE
	J	4,R7			:NORMAL RETURN		:DRE 30-APR-85

:GET DIGIT ROUTINE
GDG100	LIS	R0,0E
	CBT	R0,TEMP5		:WAS SWITCH SET TO GET UPPER NIBBLE (FLIP SWITCH)
	JNFS	GDG150			:   NO
	LR	R6,R6			:PACKET BYTES LEFT
	JLE	RTESHT			:   NO
	JAL	R4,PICKCH		:GET BYTE FROM RING
	STB	R0,TEMP5		:SAVE BYTE
	SRLS	R0,4			:SEND BACK UPPER DIGIT
	JR	R9			:RETURN
					:GET LOWER (NIBBLE) DIGIT
GDG150	LB	R0,TEMP5		:GET BYTE SAVED PREVIOUSLY
	NHI	R0,0F			:SEND BACK  LOWER DIGIT
	JR	R9			:RETURN

:STORE DIGIT ROUTINE
SDG100	LIS	R4,0F
	CBT	R4,TEMP5		:FLIP SWITCH (TEST FOR LOWER NIBBLE) :DRE 31-MAY-85
	JNFS	SDG150			:   GO DO LOWER NIBBLE	:DRE 31-MAY-85
	SLLS	R0,4			:MOVE DIGIT TO UPPER NIBBLE
	STB	R0,,R8,R3		:STORE DIGIT IN BUFFER
	JR	R9			:RETURN
					:STORE LOWER DIGIT
SDG150	LB	R4,,R8,R3		:GET BYTE FROM BUFFER
	OR	R0,R4			:COMBINE TWO DIGITS
	STB	R0,,R8,R3		:STORE BACK IN BUFFER
	AIS	R3,1						:HJR-SWBT1
	JR	R9			:RETURN



:	UTILITY ROUTINE TO PUT DIGIT INTO IEDBUF, AND ALSO A PERIOD
:	IF NTN LONGER THAN 6 DIGIT HOST FOR SUBHOST ADDRESSING
PUTNUN	AHI	R0,30			:MAKE INTO ASCII DIGIT	:AHM 05-29-87
	JAL	R4,WCI			:PUT INTO IEDBUF	:AHM 05-29-87
	SIS	R8,1			:DECREMENT DIGITS LEFT	:AHM 05-29-87
	JN	4,R5			:IF MORE TO DO		:AHM 05-29-87
	LR	R8,R9			:TEST FOR PERIOD NEEDED	:AHM 05-29-87
	SKIPLE(0,R5)			:IF NOT, TAKE DONE RETURN :AHM 05-29-87
	LHI	R0,3A			:COLON			:AHM 05-29-87
	JAL	R4,WCI			:INCLUDE IT IN USERNAME BUFFER	:AHM 05-29-87
	J	PUTDOT						:AHM 05-29-87
PUTDIG	AHI	R0,30			:MAKE INTO ASCII DIGIT
	JAL	R4,WCI			:PUT INTO IEDB
	SIS	R8,1			:DECREMENT DIGITS LEFT
	JN	4,R5			:IF MORE TO DO
	LR	R8,R9			:TEST FOR PERIOD NEEDED
	SKIPLE(0,R5)			:IF NOT, TAKE DONE RETURN
PUTDOT	LHI	R0,2E			:PERIOD
	JAL	R4,WCI			:INCLUDE IT IN USERNAME BUFFER
	LCS	R9,1			:FLAG LAST PART OF HOST #
	J	4,R5			:RETURN TO MAIN LOOP FOR MORE


:	PUT DNIC/TNIC INTO IEDBUF

PDTNIC
	LIS	R6,0C			:LOOP AND SHIFT COUNT
	LHL	R1,IEDBUF
PDTN20	LR	R0,R5
	SRL	R0,,R6			:GET OCTET INTO POSITION
	NHI	R0,0F			:KEEP ONLY 4 BITS
	AHI	R0,30			:CONVERT TO ASCII DIGIT
	JAL	R4,WCI			:WRITE INTO IEDBUF
	SIS	R6,4			:DECREMENT SHIFT COUNT
	JGEBS	PDTN20
	JR	R9			:RETURN

  IF	\CLD.SW
:
:	GET DIGIT ROUTINE
:	INPUT :
:		R1 = ADDR OF THE BUFFER CONTAINING THE DIGIT TO GET
:		R3 = NIBBLE INDEX OF THE BUFFER
:	OUTPUT :
:		R0 = THE DIGIT IN LOWER 4 BITS
:	USES:	R2, R9
:	LINK REGISTER: R4
:
GETDGT
	LR	R2,R3			:MAKE A COPY
	AIS	R3,1			:INCRE. NIBBLE INDEX OF THE BUFFER
	LR	R9,R2			:MAKE A COPY
	SRLS	R2,1			:CONVERT NIBBLE INDEX TO BYTE INDEX
	LB	R0,,R1,R2		:GET THE BYTE
	SRLS	R9,1			:L.S.B IS IN CARRY FLAG
	JCFS	GETD10			:IF CARRY SET, GO GET LOWER DIGIT
	SRLS	R0,4			:MOVE UPPER NIBBLE TO LOWER NIBBLE
	JR	R4			:RETURN
GETD10
	NHI	R0,0F			:SEND BACK LOWER DIGIT
	JR	R4			:RETURN
:
:	PUT DIGIT ROUTINE
:	INPUT:
:		R8 = ADDR OF THE BUFFER
:		R7 = NIBBLE INDEX OF THE BUFFER
:		R0 = THE DIGIT TO PUT (LOWER 4 BIT)
:	USES:	R9
:	LINK REGISTER:	R4
:
PUTDGT
	LR	R9,R7			:MAKE A COPY
	AIS	R7,1			:INCRE. NIBBLE INDEX
	SRLS	R9,1			:CONVERT NIBBLE INDEX TO BYTE INDEX
	JCFS	PUTD10
	SLLS	R0,4			:MOVE DIGIT TO UPPER NIBBLE
	STB	R0,,R8,R9		:STORE DIGIT IN BUFFER
	JR	R4			:RETURN
PUTD10
	LB	R12,,R8,R9		:GET BYTE FROM BUFFER
	OR	R0,R12			:COMBINE TWO DIGITS
	STB	R0,,R8,R9		:STORE BACK IN BUFFER
	JR	R4			:RETURN

CLDERR

	LM	R0,ATRSAV		:RESTORE R0-R15
	LHI	R12,DIA067		:SET UP 'ILLEGAL CALLED ADDR'
	J	RTECAL			:CLEAR THE CALL
  EI	\CLD.SW




::	BLDHST - BUILD HOST NUMBER OF DEST FOR LOGIN STRING	:DRE 3-JAN-86
:	(RELOCATED FROM PCR480 THROUGH PCR498)			:DRE 3-JAN-86
:	
:	LINK IS R13						:DRE 3-JAN-86
:

BLDHST	LHI	R0,3A			:COLON AT END OF USERNAME
	JAL	R4,WCI			:WRITE TO COMPLETE USERNAME
	LHL	R2,IPORT
	TBT	R2,CUNTRG,,		:USE TARGET PROFILE?
	JE	BLDH02
	LHI	R0,$047			:LOAD G
	JAL	R4,WCI			:WRITE G INTO IEDBUF
	LHL	R7,IPORT
	SLLS	R7,3			:INDEX TO DTESAX
	LHL	R5,DTESAX,R7,		:GET CALLED ADDR DNIC	:HJR-SWBT1
	JAL	R9,PDTNIC		:GOTO PUT DNIC INTO IEDBUF
	LHL	R2,IPORT
	TBT	R2,RPOA.F,,		:WAS RPOA FACILITY REQUESTED?
	JER	R13
	LHL	R5,RPOA.R,R2,R2		:GET RPOA DNIC
	LHI	R0,$054			:LOAD A "T"
	JAL	R4,WCI			:WRITE INTO IEDBUF
	JAL	R9,PDTNIC		:GOTO PUT TNIC INTO IEDBUF
	JR	R13


:	BUILD DESTINATION HOST # PART OF LOG IN STRING USING NTN <D HOST>

BLDH02	LB	R8,DTESAX+7,R7,		:RELOAD CLD LENGTH	:HJR-SWBT1
	LCS	R9,1			:NO REMAINDER FLAG
	LB	R0,DTESAX,R7,		:LOAD FIRST TWO DIGITS OF DNIC :HJR-SWBT1
	NHI	R0,0F0			:MASK TO FIRST DIGIT ONLY
	JN	BLDH06			:IF IT LOOKS LIKE A DNIC
	L	R0,DTESAX,R7,
	LIS	R2,6
	CR	R8,R2
	JGE	BLDH04			:IF HAS ENOUGH DIGITS (0+5 OR MORE)
:	IF < 6 DIGITS OF ADDRESS, ZERO FILL TO 6 DIGITS.
	SR	R2,R8
	SLLS	R2,2			:COMPUTE SHIFT COUNT TO RIGHT JUSTIFY
	SRL	R0,,R2			:RIGHT JUSTIFY
	LIS	R8,6			:MAKE IT 6 DIGITS
:	ADD 4 DIGITS OF OUR DNIC TO THE BEGINNING OF ADDRESS.
BLDH04	AIS	R8,4
	LR	R2,R0
	NI	R2,0FFFF		:SAVE DIGITS 5-8	:HJR-SWBT1
	EXHR	R2,R2
	SRL	R0,10			:MAKE ROOM FOR DNIC	:HJR-SWBT1
	LR	R3,RL
	SLLS	R3,ONI.SC
	LHL	R3,ONI.LT,R3,R3		:GET OUR DNIC
	SLL	R3,10						:HJR-SWBT1
	OR	R0,R3
	ST	R0,DTESAX,R7,		:UPDATE CALLED ADDRESS
	LB	R3,DTESAX+4,R7,		:GET DIGITS 9-10	:HJR-SWBT1
	SRL	R3,10
	OR	R3,R2			:OR IN DIGITS 5-8	:HJR-SWBT1
	OR	R3,R8			:OR IN COUNT		:HJR-SWBT1
	ST	R3,DTESAX+4,R7,
BLDH06	AIS	R7,2			:ADVANCE DTESAX PTR PAST DNIC
	SIS	R8,4			:DECREMENT CALLED ADDRESS LENGTH
BLDH08	LB	R0,DTESAX,R7,		:GET FIRST TWO DIGITS	:HJR-SWBT1
	AIS	R7,1			:ALLOW FOR FIRST BYTE OF ADDR :HJR-SWBT1
	SIS	R8,1			:ACCOUNT FOR LEADING 0
	CLHI	R8,5			:TEST FOR HOST# WITH NO SUBHOST DIGITS
	JLE	BLDH28			:IF SO
	LR	R9,R8			:# OF NTN DIGITS TOTAL, EXCLUDING 0
	SIS	R9,5			:COMPUTE # OF SUBADDRESS DIGITS BEYOND "."
	LIS	R8,5			:FIRST PART DIGIT COUNT
	J	BLDH28			:TO PUT HOST # INTO LOGIN STRING

:	HERE TO TREAT WHOLE NTN AS USERNAME

BLDH20	LHL	R1,IEDBUF		:STORE IN IEDBUF PENDING DPORT
	LHI	R0,1,R8			:LEN=USERNAME LENGTH PLUS CIRCUIT SPEED IND
	LR	R9,R9			:ANY REMAINDER ??
	JLEFS	BLDH22			:IF NOT
	AHI	R0,1,R9			:LEN=LEN+PERIOD PLUS REMAINDER OF CLD
BLDH22	JAL	R4,WCI			:WRITE LENGTH
	JAL	R12,GETCSI		:GET CIRCUIT SPEED INDICATOR
	JAL	R4,WCI			:WRITE IT
	AIS	R7,3			:ADVANCE FOR LENGTH AND DNIC

:	HERE TO COPY ALL OR PART OF CALLED ADDRESS INTO LOGIN STRING.
:	IF CLD FIRST DIGIT WAS 0 AND AT LEAST 6 DIGITS, THEN OF THE FORM
:		0 + <5 DIGIT DEST HOST> AND NO DNIC GIVEN.
:	IF CLD PAST DNIC BEGINS WITH 9 THEN NUMERIC USERNAME AND ALL ARE
:		COPIED AS USER NAME WITH NO HOST SPECIFIED.
:	IF CLD PAST DNIC SPECIFIES 4 DIGIT HOST PLUS 0-6 DIGITS OF SUBADDRESS
:		THEN ALL ARE USED AS USERNAME AND NO HOST SPECIFIED.
:	IF CLD PAST DNIC IS OF THE FORMAT 0 + <5 DIGIT HOST> + <0-4>
:		SUBADDRESSING DIGITS THEN USERNAME HAS ALREADY BEEN CONSTRUCTED
:		AND HERE TO BUILD DESTINATION HOST # AND POSSIBLY A PERIOD
:		FOLLOWED BY SUBADDRESSING DIGITS.

:	R7=BYTE ADDRESS INTO STORED CALLED ADDRESS IN DTESAX
:	R8=LOGIN USERNAME DIGIT COUNT.  R9>0 MEANS APPEND PERIOD
:	AND REST OF CLD DIGITS AS SUBHOST NUMBER

BLDH24	LB	R12,DTESAX,R7,		:GET NEXT 2 DIGITS
	AIS	R7,1			:ADVANCE DTESAX INDEX
	LBR	R0,R12			:LOAD DIGIT PAIR
	SRHLS	R0,4			:POSITION TO FIRST OF TWO DIGITS
	JAL	R5,PUTDIG		:PUT INTO IEDBUF, MAYBE PERIOD TOO
	SKIPAD(BLDH40)			:JS-SKYN
	LR	R0,R12			:RELOAD DIGIT PAIR
BLDH28	NHI	R0,0F			:POSITION TO SECOND OF TWO DIGITS
	JAL	R5,PUTDIG		:WRITE IT, MAYBE PERIOD TOO
	SKIPAD(BLDH40)			:JS-SKY
	J	BLDH24			:ELSE GO FOR MORE DIGITS
BLDH40	JR	R13			:JS-SKY

::  BEGIN OF THE CHANGES	:JS-ONREG
:	IDSAVE - COPY NETWORK USERNAME AND PASSWORD FROM IDN BUFFER
:	         AND/OR SIG BUFFER TO NUISAV
:	INPUT	R13=BUFFER POINT OF IND BUFFER/SIG BUFFER
:		R9=INDEX OF NUISAV
:	USES	R0,R7,R8
:	LINK	R12

  IF	X.32
IDSAVE	LB	R8,,R13			:GET BUFFER LENGTH
	JER	R12
	LIS	R7,1			:SET BUFFER OF IDN/SIG BUFFER
IDSAV1	LB	R0,,R7,R13		:GET A BYTE OF DATA
	STB	R0,NUISAV,R9		:STORE INTO NUISAV
	AIS	R9,1			:INCREASE INDEX OF NUISAV 
	AIS	R7,1			:INCREASE INDEX OF IDN/SIG BUFFER
	SIS	R8,1			:COUNT IT DOWN
	JG	IDSAV1
	JR	R12
  EI  :X.32
::END OF THE CHANGES	:JS-ONREG
: Moved following code but did't change it			:HJR-SWBT1
::	CHKADR-	VALIDATE CALLED ADDRESS AND RESET 'GATWAY' FLAG IF DNIC
:		MATCH OUR DNIC
:
:	INPUT	(GATWAY) SET
:		DTESAX HAS CALLED ADDRESS
:	OUTPUT	(GATWAY) RESET IF CALLED DNIC MATCH OUR DNIC
:		(INFCAL) SET IF CALLED DNIC MATCH INFOSWITCH DNIC
:		NORNAL RETURN IF ERROR IN CALLED ADDRESS, ELSE SKIP RETURN
:		(R12-R14
:	USES	R0-R4,R12 R14
:	CALLS	FNDONI
:	LINK IS R14

CHKADR	LHL	R4,IPORT
	LHI	R12,DIA067		:'INVALID CALLED ADDRESS'
	SLLS	R4,3			:FORM INDEX
 IF LIIFLAG							:HJR-SWBT1
	LB	R1,XCOM2,,		:FOR XCOM-II		:HJR-SWBT1
	JN	CKADRX			:GO DO NEW PROCESSING	:HJR-SWBT1
CKADRY		:TEMPORARY - RETURN HERE IF TKSUP	 	:HJR-SWBT1
	LIS	R1,0			:NEED CLEAR LOG-II FLAG	:HJR-SWBT1
	STB	R1,XCOM2,,					:HJR-SWBT1
 EI :LIIFLAG							:HJR-SWBT1
	LB	R2,DTESAX+7,R4,		:GET COUNT		:HJR-SWBT1
  IF	X.75
	JNFS	CKAD20			:IF DIGITS PRESENT
	TBT	RL,TKSP.F
	JN	CKAD90			:OK TO HAVE NO DNIC PRESENT IF TALK SUP IS SET
CKAD20	TBT	RL,NNTN.F					:SCHEN 25-Feb-85
	JNFS	CKAD25			:IF NTN IGNORED			:SCHEN 25-Feb-85
	CLHI	R2,4
	JL	RTECAL			:IF < 4 DIGITS, CLEAR THE CALL :HJR-SWBT1
  ELSE	X.25
	JE	CKAD90			:IF NO DIGITS PRESENT, TREAT AS 'OUR DNIC'
  EI

CKAD25	LHL	R0,DTESAX,R4,		:GET DNIC		:HJR-SWBT1
	THI	R0,0F000		:LEADING 0 ??		:HJR-SWBT1
	JNFS	CKAD30			:IF NOT, TEST FOR VALID DNIC
	CLHI	R2,1			:ELSE 0 + <1-5 DIGIT DEST HOST #>
	JE	RTECAL			:IF ONLY ONE DIGIT OF 0, CLEAR THE CALL :HJR-SWBT1
	CLHI	R2,$A10
	JG	RTECAL			:IF MORE THAN 10 DIGITS	:HJR-SWBT1
	J	CKAD90			:ASSUME OUR DNIC

CKAD30	CLHI	R2,4			:DO WE HAVE 4 DIGITS?	:DRE 2-JUN-87
	JL	CKAD90			:NO, TREAT AS OUR DNIC	:DRE 2-JUN-87

:	SEE DINIC CALLED IS ON LIST OF ALLOWBLE GATEWAY NUMBER.
  IF	INFSW1
	CLHI	R0,INDNIC		:SEE IF INFO SWITCH DNIC
	JNFS	CKAD40
	LHL	R4,IPORT
	SBT	R4,INFCAL,,
	J	CKAD90
CKAD40	HS
  EI
	JAL	R1,FNDONI		:SEARCH ODNIC TABLE FOR MATCHING DNIC
	SKIPAD(CKAD90)			:IF MATCH FOUND
	JR	R14			:NO MATCH FOUND, RETURN	:HJR-SWBT1

CKAD90	LHL	R4,IPORT
	RBT	R4,GATWAY,,		:RESET GATWAY FLAG
	JR	R14			:MATCH FOUND, RETURN	:HJR-SWBT1
: End of moved code						:HJR-SWBT1

: Made following code into procedure --------------------------	:HJR-SWBT1
::	CHKADG-	VALIDATE CALLING ADDRESS
:
:	INPUT	DTESAV HAS CALLING ADDRESS
:	OUTPUT	DEFAULT CALLING ADDR FROM CHK.LT IF DTESAV IS EMPTY
:		NORNAL RETURN IF ERROR, ELSE JUMP TO RTECAL
:	USES	R0-R4,R12 R14
:	LINK IS R14

CHKADG	HS
:	SEE IF CALLING ADDRESS IS WHAT WE EXPECT FROM HOST TO PREVENT
:	THE HOST FROM FOOLING CALLED ADDRESS.

	LHL	R4,IPORT
	SLHLS	R4,3
 IF LIIFLAG							:HJR-SWBT1
	LB	R1,XCOM2,,		:FOR XCOM-II		:HJR-SWBT1
	JN	CKADGX			:GO DO NEW PROCESSING	:HJR-SWBT1
 EI :LIIFLAG							:HJR-SWBT1
	LB	R3,DTESAV+7,R4,		:LEN OF CLG ADR FROM CALL REQ PACKET :HJR-SWBT1
	JN	CHKG15			:IF CLG ADR PRESENT, MAY NEED TO CHECK IT

:	CALL REQUEST PACKET HAD NO CALLING ADR. IF CHK.LT TABLE HAS,
:	THEN COPY IT INTO DTESAV AS IF IT CAME FROM CALL REQ PACKET
	LR	R3,RL			:GET LINE NUMBER
	SLHLS	R3,CHK.SC
	LB	R1,CHK.LT,R3,		:LENGTH OF DEFAULT CLG ADR
	JE	CHKG30			:IF NO DEFAULT CLG ADR
	STB	R1,DTESAV+7,R4,		:SAVE LENGTH		:HJR-SWBT1
	SRHLS	R1,1			:CONVERT DIGIT COUNT TO BYTE COUNT
	JEFS	CHKG10			:IF 0 OR 1 DIGITS
CHKG05	LB	R2,CHK.LT,R3,R1
	STB	R2,DTESAV-1,R4,R1				:HJR-SWBT1
	SIS	R1,1
	JGBS	CHKG05			:IF MORE DIGITS TO SAVE
CHKG10	LB	R1,CHK.LT,R3,		:GET LENGTH AGAIN
	THI	R1,01			:ODD NUMBER OF DIGITS
	JE	CHKG30			:IF ZERO OR EVEN NO. OF DIGITS
	SRHLS	R1,1
	LB	R2,CHK.LT+1,R3,R1
	STB	R2,DTESAV,R4,R1					:HJR-SWBT1
	J	CHKG30			:DON'T CHECK DEFAULT CLG ADR

CHKG15	LHI	R12,DIA135		:DIAG TO USE IF ADR DOES NOT MATCH
	LR	R3,RL
	SLHLS	R3,CHK.SC		:FORM TABLE INDEX
	LB	R1,CHK.LT,R3,		:LENGTH OF ADR TO CHECK
	SRHLS	R1,1			:MAKE IT A BYTE COUNT (MINUS ANY ODD DIGIT)
	JEFS	CHKG25			:IF 0 OR 1 DIGITS
CHKG20	LB	R2,CHK.LT,R3,R1
	CLB	R2,DTESAV-1,R4,R1				:HJR-SWBT1
	JN	RTECAL			:IF ADR DOES NOT MATCH
	SIS	R1,1
	JGBS	CHKG20			:IF MORE TO CHECK
CHKG25	LB	R1,CHK.LT,R3,		:GET LENGTH AGAIN
	THI	R1,01
	JEFS	CHKG30			:IF NOT ODD NUMBER OF DIGITS
	SRHLS	R1,1
	LB	R2,CHK.LT+1,R3,R1
	LB	R3,DTESAV,R4,R1					:HJR-SWBT1
	NHI	R3,0F0
	CR	R2,R3
	JN	RTECAL			:IF LAST DIGIT DID NOT MATCH
CHKG30	JR	R14			:DONE
: End of created procedure ------------------------------------	:HJR-SWBT1

:- BEGIN ----------------------------------------------------- :HJR-SWBT1
 IF LIIFLAG
:*******************************************************************************
: CKADRX:  LOG-II EXTENSION TO CHKADR
:	ENTER WITH -	R4 = IPORT << 3
:			R12 = DIA067
:
:	REMEMBER - R2 CONTAINS ADDRESS LENGTH THROUGHOUT
:		 - R9 CONTAINS IPORT
:
CKADRX
:
: IF THERE IS NO CALLED ADDRESS THEN
:   FOR X.25, USE DEFAULT, IF AVAILABLE
:   FOR X.75, JUST RETURN
:   FOR TKSUP CALLS, DO LOG-I PROCESSING FOR NOW
:
	LHL	R9,IPORT		:GET IPORT # FOR USE LATER
	TBT	RL,NNTN.F		:IF NONTN THEN GO CKECK TKSUP
	JNFS	CKRX02
	LB	R2,DTESAX+7,R4,		:GET ADDR LENGTH
	JN	CKRX10			:IF NOT 0, CONTINUE
  IF X.75
CKRX02	J	RTECAL			:NO CALLED ADDR, CLEAR		:AHM-SWBT1
  ELSE X.25
	LB	R1,DFDOFF,RL,		:IF 0, CHECK FOR DEFAULT
	JNFS	CKRX04
CKRX02	TBT	RL,TKSP.F		:IF TKSUP THEN DO OLD STYLE CALL
	JN	CKADRY
	J	CKRX45			:GO SET LOCAL AND RETURN

CKRX04	L	R0,DFDADR,R1,		:MOVE DEFAULT INTO DTESAX
	ST	R0,DTESAX,R4,
	L	R0,DFDADR+4,R1,
	ST	R0,DTESAX+4,R4,
	TBT	RL,DFDNIC,,		:HAVE DNIC?
	JE	CKRX40			:IF NOT, SET LOCAL AND RETURN
	SBT	R9,DTESDX,,
	JFS	CKRX15			:AND GO CHECK IF LOCAL OR GATEWAY
  EI :X.25
:
: WE HAVE AN ADDRESS
:   FOR X.75, CLEAR CALL IF NO DNIC
:   FOR X.25, WE NEED TO GO CHECK FOR DEFAULT DNIC INSERTION
: RETURN IF GATEWAY CALL, 'GATWAY ALREADY SET'
: NOTE - PRESENCE OF A DNIC WAS SET IN "VALADR"
:
CKRX10	TBT	R9,DTESDX,,
 IF X.75
	JE	RTECAL			:CLEAR CALL IF NONE
 ELSE X.25
	JE	CKRX30			:SKIP IF NONE
 EI :X.75
CKRX15	LHL	R0,DTESAX,R4,		:ELSE GET IT
	CLH	R0,MYDNIC,,		:AND COMPARE TO OURS
	JN	CKRX40			:GATEWAY CALL, DONE HERE
:
: CLEAR DTESAX IF THIS IS A TKSUP CALL
: WE'RE HERE BECAUSE THIS IS A LOCAL CALL WITH A DNIC,
:  SO, IF TKSUP ALLOWED, JUST CHECK IF NTN = "" OR "9"
:
	TBT	RL,TKSP.F,,		:TKSUP ALLOWED?
	JE	CKRX40			:NO, CONTINUE
	CLHI	R2,5			:3-WAY JUMP
	JG	CKRX40			:>5 - TO BIG FOR TKSUP CALL
	JLFS	CKRX20			:<5 - DNIC ONLY, MUST BE TKSUP
	LB	R1,DTESAX+2,R4,		:=5 - GET NTN (ONLY 1 DIGIT)
	CLHI	R1,90			:SINCE "9" IS IN LEFT NIBBLE
	JN	CKRX40			:SKIP IF NOT TKSUP REQUEST
CKRX20	J	CKADRY			:IF TKSUP THEN DO OLD STYLE CALL
 IF X.25
:
: NO DNIC, INSERT ONE
:
CKRX30	LA	R8,DTESAX,,		:SET FOR INSDNI
	LA	R7,DTESDX,,		:TO MARK HAVE DNIC
	JAL	R13,INSDNI		:GO INSERT DNIC
 EI :X.25

CKRX40	SBT	R9,NTNCAL,,		:MARK  SHIP ADDR IN ICRM
CKRX45	RBT	R9,GATWAY,,		:CLEAR 'GATWAY' - LOCAL CALL
	JR	R14

:*******************************************************************************
:*******************************************************************************
: CKADGX:  LOG-II EXTENSION TO CHKADG
:	ENTER WITH -	R4 = IPORT << 3
:	REMEMBER - R2 CONTAINS ADDRESS LENGTH THROUGHOUT
:		 - R9 CONTAINS IPORT
:
CKADGX
:
: IF THERE IS NO CALLING ADDRESS THEN
:   FOR X.25, IF DEFAULT AVAILABLE, THEN USE IT AND RETURN,
:     ELSE CHECK IF EMPTY IS ALLOWED
:   FOR X.75, CLEAR CALL
:
	LHI	R12,DIA068		:SET 'ILLEGAL CALLING ADDR'
	LHL	R9,IPORT		:GET IPORT FOR LATER USE
	LB	R2,DTESAV+7,R4,		:GET ADDR LENGTH
	JN	CKGX10			:SKIP IF NON-0
 IF X.75
 	J	RTECAL			:FOR X.75, CLEAR CALL
 ELSE
	LB	R3,DFLOFO,RL,		:GET DEFAULT ADDR OFFSET
	JE	CKGX10			:IF NONE, SEE IF EMPTY ALLOWED
	L	R0,DFLADO,R3,		:ELSE MOVE IT
	ST	R0,DTESAV,R4,
	L	R0,DFLADO+4,R3,
	ST	R0,DTESAV+4,R4,
	SBT	R9,DTESDV,,		:MARK DNIC PRESENT
	JR	R14			:AND RETURN
 EI
:
: WE HAVE AN ADDRESS TO CHECK
:   FOR X.75, ONLY REQUIRE PRESENCE OF DNIC
:   FOR X.25, CHECK DNIC IF PRESENT AND SET DTESAV OFFSET TO NTN IN R8
:	R7 WILL CONTAIN THE COMPARE ADDRESS OFFSET INTO "CKONTN"
:	R9 WILL CONTAIN THE DNIC BIT FLAG OFFSET
:
CKGX10
 IF X.75
	TBT	R9,DTESDV,,		:HAVE A DNIC?
	JNR	R14			:RETURN IF YES
	J	RTECAL			:ELSE CLEAR CALL
 ELSE X.25
	LB	R7,CKNOFF,RL,		:GET CKADDR OFFSET
	JE	CKGX80			:NO CHECK, CHECK DNIC INSERT
	LIS	R8,0			:SET OFFSET TO NO DNIC
	TBT	R9,DTESDV,,		:HAVE A DNIC?
	JEFS	CKGX20			:IF NOT, SKIP CHECK
	LHL	R2,DTESAV,R4,		:GET CALLING DNIC
	CLH	R2,MYDNIC,,		:COMPARE
	JN	RTECAL			:CLEAR IF MISMATCH
	AIS	R8,2			:SET OFFSET PAST DNIC
:
: SEE IF WE NEED TO CHECK NTN, R7 CONTAINS INDICATOR
: IF SO, FIRST CHECK NTN SIZE THEN DO MATCH CHECK
:
CKGX20	CLHI	R7,1			:CHECK NTN?
	JLE	CKGX80			:SKIP IF NO
	LB	R0,DTESAV+7,R4,		:GET ADDR DIGIT COUNT
	TBT	R9,DTESDV,,		:DNIC INCLUDED?
	JEFS	CKGX24			:SKIP IF NOT
	SIS	R0,4			:ELSE ACCOUNT FOR IT

CKGX24	LHI	R12,DIA135		:SET CHECK ERROR
	LIS	R13,1			:SET NEED EXACT ALT MATCH
	CLB	R0,CKOMIN,RL,		:COMPARE TO MINNTN
	JL	CKGX50			:GO LOOK FOR EXACT ALTERNATE
	CLB	R0,CKOMAX,RL,		:COMPARE TO MAXNTN
	JG	CKGX50			:GO LOOK FOR EXACT ALTERNATE
	LIS	R13,0			:SET ONLY NEED GENERIC ALT MATCH
	L	R2,DTESAV,R4,R8		:GET CALLING NTN
	LB	R1,CKONTN+5,R7,		:GET # DIGITS TO CHECK
	SLHLS	R1,1			:MAKE HALFWORD OFFSET
	N	R2,AWMASK,R1,R1		:MASK OUT UNNEEDED DIGITS
	CL	R2,CKONTN,R7,		:AND DO COMPARE
	JNFS	CKGX50			:IF MISMATCH, GO DO ALT CHECK
	LB	R2,DTESAV+4,R4,R8
	NH	R2,ABMASK,R1,		:MASK OUT UNNEEDED DIGITS
	CLB	R2,CKONTN+4,R7,		:CHECK REST OF ADDR
	JE	CKGX80			:IF MATCH, GO CHECK DNIC INSERT
:
: NTN DIDN'T MATCH CKOADR, CHECK IT AGAINST ALTNTNs
: CLEAR IF NO ALTNTs OR CAN'T FIND A MATCH
:   R13 = 0 if generic match OK, 1 if need EXACT match
:
CKGX50	LB	R0,ALTCNT,RL,		:ANY ALT ADDRS?
	JE	RTECAL			:CLEAR IF NONE
	LHL	R7,ALTOFF,RL,RL		:GET OFFSET TO FIRST NTN
	LIS	R0,0			:START COUNT AT 0

CKGX54	L	R2,DTESAV,R4,R8		:GET CALLING NTN
	LB	R3,DTESAV+4,R4,R8
	TBT	R0,ALTEXA,RL,RL		:EXACT?
	JNFS	CKGX58			:SKIP MASKING IF YES
	LR	R13,R13			:EXACT REQUIRED?
	JN	CKGX62			:IF YES, GO TRY FOR NEXT ALTNTN
	LB	R1,ALTNTN+5,R7,		:GET # DIGITS TO CHECK
	SLHLS	R1,1			:MAKE HALFWORD OFFSET
	N	R2,AWMASK,R1,R1		:MASK OUT UNNEEDED DIGITS
	NH	R3,ABMASK,R1,		:MASK OUT UNNEEDED DIGITS
CKGX58	CL	R2,ALTNTN,R7,		:AND DO COMPARE
	JNFS	CKGX62			:IF MISMATCH, GO DO NEXT
	CLB	R3,ALTNTN+4,R7,		:CHECK REST OF ADDR
	JEFS	CKGX80			:IF MATCH, DONE
CKGX62	AIS	R0,1			:TRY FOR NEXT
	CLB	R0,ALTCNT,RL,
	JGE	RTECAL			:CLEAR CALL IF NO NEXT, NO MATCH
	AIS	R7,6			:OTHERWISE TRY NEXT ADDR
	J	CKGX54
:
: WE HAVE A VALID ADDRESS, CHECK FOR DNIC INSERT, BIT FLAG IS IN R9
:
CKGX80	TBT	R9,DTESDV,,		:NEED A DNIC?
	JNR	R14			:RETURN IF NO
	LA	R8,DTESAV,,		:"INSDNI" NEEDS ADDR POINTER
	LA	R7,DTESDV,,		:TO MARK HAVE A DNIC
	JAL	R13,INSDNI		:GO INSERT DNIC
	JR	R14			:DONE
 EI :X.25

:*******************************************************************************
:*******************************************************************************
:
::	INSDNI- INSERT DNIC IN ADDRESS IN DTESAX OR DTESAV
:
:	INPUT	R4 CONTAINS INDEX INTO ADDRESS ARRAY
:		R7 CONTAINS POINTER TO DTESDX OR DTESDV
:		R8 CONTAINS POINTER TO DTESAX OR DTESAV
:		R9 CONTAINS IPORT #
:	OUTPUT	ADDRESS CONTAINS DNIC
:	USES	R0-R4,R8,R13
:	LINK IS R13
:
INSDNI	LHL	R0,MYDNIC,,		:GET LOCAL DNIC
	L	R1,,R4,R8		:SHIFT ADDR AND INSERT DNIC
	LHL	R2,4,R4,R8		:GET DIGITS 9 & 10, HAVE ROOM FOR COUNT
	LB	R3,7,R4,R8		:GET ADDR DIGIT COUNT
	AIS	R3,4			:ADD IN LENGTH OF DNIC
	OR	R3,R2
	STH	R0,,R4,R8		:NOW STORE NEW ADDRESS
	ST	R1,2,R4,R8
	STH	R3,6,R4,R8
	SBT	R9,0,R7			:MARK HAVE DNIC
	JR	R13			:RETURN
 EI
:-- END ------------------------------------------------------ :HJR-SWBT1

: Made following code into procedure --------------------------	:HJR-SWBT1
::	GETCUD-	GET PID AND PROCESS, MOVE PID TO FACBUF
:		MOVE REST OF CUD TO IEDBUF IF CCITT PID
:		MOVE REST OF CUD TO FACBUF IF NON-CCITT PID
:	GETCVD- (ROMAN SPELLING) DOESN'T GET RING INFO FROM TEMP,TEMP1
:
:	INPUT	TEMP > SAVED RING PNTR
:		TEMP1 > SAVED RING COUNT
:		TEMP2 > NETUSERNAME PREFIX FLAG
:		GATWAY, NTNCAL
:
:	OUTPUT	START CUD IIX MESSAGE IN FACBUF AND COPIES IN PID
:		IF NON-CCITT PID THEN COPIES WHOLE CUD TO FACBUF
:		IF CCITT PID THEN COPIES WHOLE CUD TO IEDBUF AND ADDS:
:			<semi-colon><cr>
:		IF TELENET PID SETS CONVERTED TID IN SAVTID
:		  AND SPEED IN SAVSPD
:		SETS ITICAL, SETS OR RESETS SIMLFI AND LX3P2
:		R6 contains:	-1 if empty CUD
:				0 if all of CUD in FACBUF
:				1+ = count of data left in CUD after PID
:
:	USES	R0-R4,R6,R7,R12-R14
:	LINK IS R14
:	CALL IS -		JAL	R14,GETPID
:			X	HC	A1-X	:A1 = non-ccitt PID return
:				HC	A2-X	:A2 = ccitt PID return
:
:	GET PROTOCOL I.D.  SEE IF AN ITI CALL.
:	IF SO SET ITICAL FLAG.
GETCUD	L	R5,TEMP			:RELOAD SAVED RING POINTER
	L	R6,TEMP1		:RELOAD RING CHAR COUNT
GETCVD								:HJR-SWBT1
  IF	TPIDS
	LIS	R0,0
	STB	R0,SAVTID		:INITIALLY SET NO TID TO USE :HJR-SWBT1
  EI	TPIDS
	LHI	R12,DIA146
	LR	R0,R6
	JE	GCUD49			:IF NO CALL USER DATA
	JAL	R4,PICKCH		:GET 1ST OCTET
	LR	R7,R0			:SAVE FIRST CHARACTER FOR LATER
	CLHI	R6,3
	JL	GCUD50			:IF LESS THAN 3 ADDITIONAL OCTETS OF CALL USER DATA
	LR	R0,R0
	JE	GCUD05			:IF HOST CALL
	CLHI	R7,PI.PAD
	JN	GCUD50			:IF NOT A CCITT DEFINED PROTOCOL ID
	LHL	R2,IPORT		:INTERNAL PORT #
	SBT	R2,ITICAL		:SET ITI CALL FLAG
:								:ISW 20-Jul-84
:	IF THIS LINK SUPPORT TRANSPAC <LF> INSERTION		:ISW 20-Jul-84
:	  SIMULATION, THEN INITITALIZE "SIMLFI" TO TRUE.	:ISW 20-Jul-84
  IF	TCRLF							:ISW 20-Jul-84
	RBT	R2,SIMLFI		:ASSUME FEATURE ISN'T NEEDED.	:ISW 20-Jul-84
	RBT	R2,LX3P2					:ISW 20-Jul-84
	TBT	RL,TCRL.F		:LINK SIMULATES <LF> INSERTION?	:ISW 20-Jul-84
	JEFS	GCUD05			:NO		:DRE 25-JAN-85	:ISW 20-Jul-84
	SBT	R2,SIMLFI		:YES				:ISW 20-Jul-84
	SBT	R2,LX3P2		:AND ASSUME ECHO ON INITIALLY.	:ISW 20-Jul-84
  EI	TCRLF							:ISW 20-Jul-84


:	COPY THE PROTOCOL ID FIELD ONLY TO FACILITIES BUFFER.
:	REST WILL BE IN IED BUFFER.
GCUD05	LIS	R0,2+4			:PROTOCOL ID ONLY
	LHL	R1,FACBUF
	JAL	R4,WCI			:ENTER TOTAL BYTE COUNT
	LHI	R0,EXM9			:GET ESCAPED MSG TYPE FOR CALL USER DATA
	JAL	R4,WCI
	LIS	R0,4
	JAL	R4,WCI			:PUT IN LENGTH
	LR	R0,R7			:GET FIRST OCTET BACK
	JAL	R4,WCI			:WRITE IN FIRST OCTET
	JAL	R4,PICKCH		:GET 2ND OCTET
  IF	TPIDS				:IF ANY TELENET PROTOCOL ID LINKS
	TBT	RL,TPID.F		:IS THIS LINK ??
	JE	GCUD10			:IF NOT
	NHI	R0,7F
	LR	R4,R0
	LB	R0,TIDTBL,R4,		:CONVERT TELENET TID TO TYMNET TID
	STB	R0,SAVTID					:HJR-SWBT1
	JAL	R4,PICKCH		:GET 3RD OCTET
	STB	R0,SAVSPD		:STORE SPEED		:HJR-SWBT1
	LIS	R0,0
	JAL	R4,WCI			:WRITE AN OCTET OF ZERO
	JAL	R4,WCI			:WRITE ANOTHER OCTET OF ZERO
	JFS	GCUD15
	EI	TPIDS
GCUD10	JAL	R4,WCI			:WRITE IN SECOND OCTET
	JAL	R4,PICKCH		:GET 3RD OCTET
	JAL	R4,WCI			:WRITE IN THIRD OCTET

GCUD15	JAL	R4,PICKCH		:GET LAST OCTET
  IF	TPIDS				:IF ANY TELENET PROTOCOL LINKS
	TBT	RL,TPID.F		:IS THIS LINK ??
	JEFS	GCUD20			:IF NOT
	LIS	R0,0			:ZERO FOR LAST OCTET
  EI	TPIDS
GCUD20	JAL	R4,WCI			:WRITE LAST OCTET

:- BEGIN ----------------------------------------------------- :HJR-SWBT1
 IF LIIFLAG
: IF LOG-II OPERATION THEN JUST COPY THE REST OF THE CUD INTO IEDBUF,
:  WE KNOW THERE IS NOTHING IN THE BUFFER YET
:
	LB	R0,XCOM2,,		:ARE WE LOG-II
	JN	GCUD32			:SKIP A LOT OF JUNK IF WE ARE
 EI
:-- END ------------------------------------------------------ :HJR-SWBT1

:	IF THERE IS NO CALL USER DATA, STICK IN A 'CR' IF NTN CALL.
:	(FOR USERNAMES WITH "NETUSERPREFIX", PRECEDE THE 'CR' WITH A 'SEMI-COLON')
:	IF C.U.D. PRESENT AND NON-NTN, PUT A 'CR' AT THE END.
:	ELSE, PRECEED THE CUD WITH A 'SEMI-COLON' AND FOLLOW WITH A 'CR'.
	LR	R6,R6
	JG	GCUD25			:IF CALL USER DATA PRESENT :HJR-SWBT1
	LHL	R2,IPORT
	TBT	R2,NUICAL,,		:NUI USED?		:DRE 23-MAY-86
	JN	GCUD45			:JUST PUT IN CR		:DRE 23-MAY-86
	TBT	R2,CUNTRG,,		:TARGET PROFILE USED?	:DRE 2-JUN-87
	JNFS	GCUD21			:YES, ADD "SEMI CR"	:DRE 2-JUN-87
	TBT	R2,GATWAY,,
	JNR	R14			:IF GATEWAY CALL, DON'T BOTHER
	TBT	R2,NTNCAL,,
	JE	GCUD22			:IF NON NTN CALL
	TBT	RL,TEMP2
	JE	GCUD45			:NTN WITHOUT NETUSERPREFIX, JUST ADD 'CR'
GCUD21	LHL	R1,IEDBUF
	LIS	R0,1			:PUT IN A 'SEMI-COLON'
	JAL	R4,WCI
	LHI	R0,3B
	JAL	R4,WCI
	J	GCUD47			:GO PUT IN A 'CR'

GCUD22	TBT	RL,TKSP.F
	JNR	R14			:IF OK TO TALK TO SUP
	LHI	R12,DIA138
	J	RTECAL			:GO CLEAR THE CALL

GCUD25	LHL	R1,IEDBUF
	LHL	R2,IPORT
	TBT	R2,NUICAL,,		:NUI USED?		:DRE 23-MAY-86
	JNFS	GCUD26			:TERMINATE WITH SEMI	:DRE 23-MAY-86
	TBT	R2,CUNTRG,,		:TARGET PROFILE USED?	:DRE 2-JUN-87
	JNFS	GCUD26			:YES, ADD "SEMI CR"	:DRE 2-JUN-87
	TBT	R2,GATWAY,,
	JN	GCUD30			:IF GATEWAY CALL, DON'T BOTHER
	TBT	R2,NTNCAL,,
	JE	GCUD30			:IF NOT AN NTN CALL

:	ADD IN A 'SEMI-COLON'FOLLOWED BY A 'CR' BEFORE COPING CALL USER DATA.
GCUD26	LHI	R0,1,R6			:ADD IN LENGTH FOR THE 'SEMI-COLON'
	TBT	RL,TEMP2
	JEFS	GCUD28			:IF NO NETUSERPREFIX
	AIS	R0,1			:ACCOUNT FOR AN EXTRA 'CR'
GCUD28	JAL	R4,WCI			:WRITE LENGTH
	LHI	R0,3B
	JAL	R4,WCI
	TBT	RL,TEMP2
	JE	GCUD40			:IF NO NEED FOR A 'CR'
	LIS	R0,0D
	JAL	R4,WCI
	J	GCUD40			:GO COPY C.U.D.

:	PUT IN CIRCUIT SPEED INDICATOR.
GCUD30	LIS	R0,1
	JAL	R4,WCI			:WRITE LENGTH
	JAL	R12,GETCSI		:GET CIRCUIT SPEED INDICATOR
	JAL	R4,WCI			:STICK IN CIRCUIT SPEED INDICATOR

:	COPY CALL USER DATA TO IED BUFFER FOR NOW.
:	WHEN WE GET THE PSUEDO NEEDLE, IT WILL BE COPIED TO THE ID BUFFER.
GCUD32	LR	R6,R6			:ANY DATA TO MOVE	:HJR-SWBT1
	JLER	R14			:RETURN IF NOT		:HJR-SWBT1
	LHI	R0,3,R6			:CALCULATE AMOUNT OF DATA FOR CUD
	LHL	R7,IPORT					:HJR-SWBT1
	STH	R0,CUDLEN,R7,R7		:SAVE AWAY FOR  LOGIN CLEANUP :HJR-SWBT1
	LR	R0,R6
	LHL	R1,IEDBUF					:HJR-SWBT1
	JAL	R4,WCI			:PUT COUNT IN AS FIRST BYTE
GCUD40	JAL	R13,PACKC0		:MOVE A CHAR		:HJR-SWBT1
	LR	R6,R6
	JNBS	GCUD40			:IF NOT DONE
	SBT	R7,CUDUSD,,		:MARK CUD USED IN LOGIN	:HJR-SWBT1

:	PUT IN A CARRIAGE RETURN.
GCUD45	LHL	R1,IEDBUF
GCUD47	LIS	R0,1
	JAL	R4,WCI			:STICK IN SIZE OF MESSAGE
	LHI	R0,0D			:STICK C.R. IN BUFFER TO END CALL USER DATA
	JAL	R4,WCI
	JR	R14			:DONE

:	NULL CALL USER DATA FIELD.
:	PASS ON CALL USER DATA TRANSPARENTLY.
GCUD49	LCS	R6,1			:SET COUNT TO INDICATE NO DATA
	LHL	R2,IPORT
	J	GCUD60			:GO CHECK VALIDITY OF CALL :HJR-SWBT1

:	NON CCITT PROTOCOL ID.
GCUD50	LHL	R2,IPORT
	CLHI	R7,PI.DS1
	JEFS	GCUD55			:IF DSP CALL
	CLHI	R7,PI.DS2
	JNFS	GCUD60			:IF NOT DSP
GCUD55	TBT	RL,TKDS.F
	JEFS	GCUD60			:IF DSP OPTION NOT SELECTED
	SBT	R2,DSPCAL,,		:INDICATE CALL FROM DSP
GCUD60	LIS	R12,1
:- BEGIN ----------------------------------------------------- :HJR-SWBT1
 IF LIIFLAG
: IF LOG-II OPERATION THEN SKIP TESTS BELOW
	LB	R0,XCOM2,,		:ARE WE LOG-II
	JN	GCUD70			:SKIP A LOT OF JUNK IF WE ARE
 EI
:-- END ------------------------------------------------------ :HJR-SWBT1
	TBT	R2,CUNTRG,,		:TARGET PROFILE USED?	:DRE 2-JUN-87 :HJR 01/14/88
	JN	GCUD65			:YES, ADD "SEMI CR"	:DRE 2-JUN-87 :HJR 01/14/88
	TBT	R2,GATWAY,,
	JN	GCUD70			:IF GATEWAY CALL, DON'T BOTHER
	TBT	R2,NUICAL,,		:IF NUICAL, ADD A "CR' AT THE END:JS 15-MAR-88
	JN	GCUD65			:JS 15-MAR-88
	TBT	R2,NTNCAL,,
	JNFS	GCUD65			:IF NTNCALL, ADD A 'CR' AT THE END OF LOGIN STRING
	TBT	RL,TKSP.F
	JN	GCUD70			:IF OK TO TALK TO SUP
	LHI	R12,DIA138		:'LOGIN ERROR'
	J	RTECAL			:GO CLEAR THE CALL

GCUD65	LHL	R1,IEDBUF
	LIS	R0,1			:SET CHARACTER COUNT
	TBT	RL,TEMP2		:NETUSERPREFIX USED?
	JEFS	GCUD73			:IF NOT
	AIS	R0,1			:BUMP CHARACTER COUNT
	JAL	R4,WCI			:TO ADD IN
	LHI	R0,3B			:A SEMICOLON
GCUD73	JAL	R4,WCI
	LIS	R0,0D			:A CARRIAGE RETURN
	JAL	R4,WCI
GCUD70	LR	R0,R6
	AIS	R0,2			:ADD IN SIZE AND MSG TYPE + 1ST BYTE
	AR	R0,R12
	LHL	R1,FACBUF
	JAL	R4,WCI
	LHI	R0,EXM9			:GET ESCAPED MSG TYPE FOR CALL USER DATA
	JAL	R4,WCI
	LR	R0,R6
	AR	R0,R12			:ACCOUNT FOR 1ST BYTE THAT WE ALREADY TOOK
	JAL	R4,WCI			:WRITE LENGTH
	LR	R0,R7			:GET 1ST BYTE BACK
	LR	R6,R6
	JLR	R14			:IF NO 1ST BYTE
	JAL	R4,WCI			:WRITE IT
GCUD75	LR	R6,R6
	JER	R14			:IF NO MORE
	JAL	R13,PACKCH		:COPY REST
	JBS	GCUD75
: End of created procedure ------------------------------------	:HJR-SWBT1

: Made following code into procedure --------------------------	:HJR-SWBT1
::	GETTID-	MULTI-PURPOSE ROUTINE
:		1) SET TID
:		2) SET LOGIN TIMER
:		3) IF X.75, MOVE TNIC LIST TO FACBUF
:
:	INPUT	ITICAL SET OR RESET
:
:	OUTPUT	TID IN SAVTID, UNLESS TPIDS BUT NOT TPID.F
:
:	USES	R0-R4,R7-R9,R14
:	LINK IS R14
:
GETTID	LHL	R1,IPORT
	LHI	R4,TIDHST		:GET FIXED TID FOR HOST
	TBT	R1,ITICAL
	JEFS	GETT02			:IF NOT AN ITI CALL
  IF	TPIDS				:IF ANY TELENET PROTOCOL LINKS
	TBT	RL,TPID.F
	JNFS	GETT03			:IF LINK WITH TELENET PROTOCOL ID
  EI	TPIDS
	LB	R4,TCLTR,R1,
	NHI	R4,0F
	LB	R4,TCLTID,R4,		:GET TID TO USE
GETT02	STB	R4,SAVTID		:SAVE FOR LATER
GETT03	SBT	R1,NEWLOG,,
	SBT	R1,EXTLOG		:SET EXTERNAL LOGIN FLAG		:DRE 12-DEC-84
	SBT	R1,EXTCAL		:SET EXTERNAL CALL FLAG
	SBT	R1,AUXTIM,,		:START TIMER ON CIRCUIT JS 12-SEP-86
	LHI	R0,PSCALC		:SEND CALL CONF STATE
	STB	R0,PCKSTE,R1,		:SAVE NEW STATE
	LHI	R0,-LIWAIT		:LOGIN TIMER
	STH	R0,ID.MT,R1,R1		:STORE TIMER VALUE

  IF	X.75
:	COPY THE TRANSIT NETWORK ID LIST FROM THE END OF TEMP2 BUFFER
:	TO THE END OF FACILITIES BUFFER.  (TNICNT) HAS THE NO. OF BYTES.
:	THIS LIST WILL BE USED IN MAKING THE CALL ACCEPT PACKET IF WE DO
:	NOT GET ANY TRANSIT NET ID FROM THE ESCAPED CALL ACCEPT MSG.

	RBT	R1,TNIRCV,,		:RESET 'SAW TRANSIT NET ID' FLAG
	LB	R7,TNICNT,R1,
	JER	R14			:IF DID NOT GET ANY
	LHI	R1,TMPBF2					:DRE 23-MAY-86
	LR	R8,R1			:STORE TMPBF2		:DRE 23-MAY-86
	LHL	R9,FACBUF
GETT05	JAL	R4,GCI
	LR	R1,R9			:RESTORE (FACBUF)
	JAL	R4,WCI			:COPY TO FAC BUF
	LR	R1,R8			:RESTORE TMPBF2
	SIS	R7,1
	JGBS	GETT05
  EI	X.75

	JR	R14			:RETURN
: End of created procedure ------------------------------------	:HJR-SWBT1
	STTL(CR FACILITY/UTILITY)

::	CRFAC -	PROCESS FACILITY/ (X.75)UTILITY FIELD.
:
:	INPUT	F(R9)= 1 IF PROCESSING UTILITY, =0 IF FACILITY
:		(R7)= FACILITY/ UTILITY LENGTH
:	USES	ALL BUT R15, TEMP,TEMP1,TEMP2,TEMP3,TEMP4
:	EXIT	TEMP= POSITION OF TOTAL LENGTH OF ESCPD MSG
:		TEMP1,TEMP4= POSITIONS OF FACILITY LENGTH FIELDS
:		TEMP2= CUG INDICATION
:	LINK IS R14

CRFAC	
:	LHI	R1,TMPBF1		:GET # OF TMP BUFF 1	:DRE 23-MAY-86
					:JS 14-OCT-86
:	JAL	R4,EMPTY,,		:MAKE SURE IT IS EMPTY	:DRE 23-MAY-86	R,,	
					:JS 14-OCT-86
:	LHI	R1,TMPBF2		:GET # OF TMP BUFF 2	:DRE 23-MAY-86
					:JS 14-OCT-86
:	JAL	R4,EMPTY,,		:MAKE SURE IT IS EMPTY	:DRE 23-MAY-86	R,,	
					:JS 14-OCT-86
	LHL	R1,FACBUF
	LHI	R0,3,R7			:ACCOUNT FOR MSG TYPE + 2 LENGTHES
	JAL	R4,WCI			:TOTAL LENGTH
	L	R2,BE,R1,
	ST	R2,TEMP			:SAVE POSITION OF TOTAL LENGTH
	LHI	R0,EXMD			:ESCAPED MESSAGE TYPE
	SR	R0,R9			:FACILITY OR UTILITY
	JAL	R4,WCI
	LHI	R0,1,R7			:SIZE + 1 EXTRA BYTE OF LENGTH
	JAL	R4,WCI
	L	R2,BE,R1,
	ST	R2,TEMP1		:SAVE POSITION OF 1ST LENGTH
	LR	R0,R7
	JAL	R4,WCI			:ENTER IT AGAIN, FIRST ONE USED BY ESCAPE LOGIC
	L	R2,BE,R1,
	ST	R2,TEMP4		:SAVE POSITION OF 2ND LENGTH
	LR	R7,R7
	JER	R14			:IF EMPTY FACILITY FIELD
	CBCT(R2)			:GET CURRENT LENGTH OF BUFFER
	STH	R2,TEMP3		:SAVE IT TILL LATER

:	READ OUT A FACILITY CODE AND PROCESS IT.
:	(R9)= UTILITY OR FACILITY INDICATION
:	(R1)= FACBUF
:	(R7)= REMAINING LENGTH
CRF010	JAL	R4,PICKCH		:GET A FACILITY CODE
	LHI	R12,DIA038		:'PACKET TOO SHORT'		:DRE 29-MAR-85
	SIS	R7,1			:LEN = LEN - 1
	JLE	RTECAL			:CLEAR CALL IF NOT ENOUGH DATA
	LR	R8,R0			:COPY FACILITY CODE
	LR	R3,R0
	NHI	R3,3F			:MASK DOWN TO LOWER 6 BITS
	SRHLS	R8,6			:UPPER 2 BITS DETERMINE TYPE
	LR	R4,R9			:USE PROCESSOR TYPE INDEX
	SLLS	R4,2			: TO GET TO LENGTH ARRAY
	CLB	R3,CRFLEN,R8,R4
	JGE	CRF020			:IF DOES NOT FALL WITHIN DEFINED RANGE
	SLLS	R4,1			:TO GET TO CLASS BIAS ARRAY
	AR	R4,R8
	LH	R4,CRFDEC,R8,R4		:OFFSET TO GROUP WITHIN TABLE :DRE 1-JUN-87
:	AR	R3,R3			:MAKE INTO HW INDEX
	SLLS	R3,1			:MAKE INTO HW INDEX
	LH	R3,CRFDEC,R3,R4		:GET ENTRY IN JUMP TABLE :DRE 1-JUN-87
	JN	CRFDEC,R3		:JUMP TO PROCESSOR IF NON-ZERO

:	COPY OR STRIP FACILITY ELEMENT.
:	(R0) = A COPY OF FACILITY CODE
CRF020	LHI	R12,DIA065		:'FACILITY CODE NOT ALLOWED'
	TBT	RL,UNC.F
	JN	RTECA0			:IF TO CLEAR CALL ON UNKNOWN FACILITY

:	COPY FACILITY ELEMENT.
CRF030	CLHI	R8,UT.VAR
	JNFS	CRF040			:IF NOT VARIABLE LENGTH
	LB	R8,,R5			:PEEK AT LENGTH
CRF040	AIS	R8,1			:+1 TO GET LENGTH OF PARAMETER	:SCY 25-Sep-84
	SR	R7,R8						:SCY 25-Sep-84
	JL	RTECAL			:CLEAR CALL IF NOT ENOUGH DATA	:DRE 8-JUL-85
	LHL	R1,FACBUF
	JAL	R4,WCI			:COPY FACILITY CODE FIRST
CRF050	JAL	R13,PACKCH
	SIS	R8,1
	JGBS	CRF050
	J	CRF090

:	STRIP FACILITY ELEMENT.
CRF060	CLHI	R8,UT.VAR
	JNFS	CRF070			:IF NOT VARIABLE LENGTH
	LB	R8,,R5			:PEEK AT LENGTH
CRF070	AIS	R8,1
	SR	R7,R8
	JL	RTECAL			:CLEAR CALL IF NOT ENOUGH DATA
CRF080	JAL	R4,PICKCH
	SIS	R8,1
	JGBS	CRF080

:	RETURN TO HERE FROM PROCESSORS.
CRF090	LHL	R1,FACBUF		:RESTORE FAC BUF #	:DRE 22-MAY-86
	LR	R7,R7
	JN	CRF010			:CONTINUE IF NOT DONE
  IF	X.75
	LHL	R2,IPORT
	TBT	R2,TCRCV,,		:TEST IF RCVD TPUT CLASS
	JNFS	CRF092			:SKIP IF YES
	LHI	R0,FC.TC
	JAL	R4,WCI
	LB	R0,TTR.LT,RL,		:GET DEFAULT OF TC
	JAL	R4,WCI
  EI	X.75
CRF092	LHL	R2,TEMP3		:GET LENGTH OF BUF AT BEGINNING OF FACILITY
	CBCT(R3)			:GET CURRENT LENGTH
	SR	R3,R2
	L	R4,TEMP4		:POSITION OF 2ND LENGTH
	STB	R3,,R4			:2ND LENGTH UPDATED
	AIS	R3,1
	L	R4,TEMP1		:POSITION OF 1ST LENGTH
	STB	R3,,R4
	AIS	R3,2
	L	R4,TEMP			:POSITION OF TOTAL LENGTH
	STB	R3,,R4			:UPDATE BYTE COUNT
	JR	R14			:RETURN


:	JUMP TABLE FOR EACH TYPE OF FACILITY CODE CLASS.
:	DECISION TABLE USED FOR CALL REQUEST NETWORK UTILITIES/ USER FACILITES
 TABLE(CRFDEC)
:	CLASS TABLE OFFSETS FOR FACILITY PROCESSING.
	TENTRY(PCAC)		:CLASS A FACILITY CODE JUMP TABLE
	TENTRY(PCBC)		:CLASS B FACILITY CODE JUMP TABLE
	TENTRY(PCCC)		:CLASS C FACILITY CODE JUMP TABLE
	TENTRY(PCDC)		:CLASS D FACILITY CODE JUMP TABLE
  IF	X.75
:	CLASS TABLE OFFSETS FOR UTILITY PROCESSING.
	TENTRY(PCANN)		:CLASS A BEGINNING OFFSET
	TENTRY(PCBNN)		:CLASS B BEGINNING OFFSET
	TENTRY(PCCNN)		:CLASS C BEGINNING OFFSET
	TENTRY(PCDNN)		:CLASS D BEGINNING OFFSET
  EI	X.75

:	CALL REQUEST FACILITY PROCESSORS
:	CLASS A
PCAC	TENTRY(PCAC00)		:0  NATIONAL OPTIONS MARKER
  IF	X.75
	:THE FOLLOWING 3 FACILITIES HAVE EQUIVALENT UTILITIES AND THEREFORE
	:ARE ILLEGAL AS FACILITIES.  X.75 DOES NOT USE THE CHARGING INFO UTILITY.
	TENTRY(PCILL)		:1  REVERSE CHARGING/ FAST SELECT, ERROR
	TENTRY(PCILL)		:2  THROUGHPUT CLASS, ERROR	:DRE 30-APR-85
	TENTRY(PCILL)		:3  CLOSED USER GROUP, ERROR
	TENTRY(PCILL)		:4  CHARGING INFORMATION REQUEST, ERROR	:DRE 30-APR-85
  ELSE	X.25
	TENTRY(PCAN10)		:1  REVERSE CHARGING/ FAST SELECT
	TENTRY(PCAN20)		:2  THROUGHPUT CLASS
	TENTRY(PCAC30)		:3  CLOSED USER GROUP
	:PROVIDE CODE HERE FOR 1984 SUPPORT
	TENTRY(PCILL)		:4  CHARGING INFORMATION REQUEST	:DRE 30-APR-85
  EI	X.25
	TENTRY(PCILL)		:5				:DRE 30-APR-85
	TENTRY(PCILL)		:6				:DRE 30-APR-85
	TENTRY(PCILL)		:7				:DRE 30-APR-85
	:CALLED LINE ADDRESS MODIFICATION IS ONLY LEGAL IN A CALL ACCEPT OR CLEAR
	TENTRY(PCILL)		:8  CALLED LINE ADDRESS MODIFICATION	:DRE 30-APR-85
  IF	X.25							:HJR 02-02-87
	TENTRY(PCAC30)		:9  CUG/OUTGOING ACCESS		:HJR 02-02-87
  EI	X.25							:HJR 02-02-87
PCAC.L	EQ	(.-PCAC)/2

:	CLASS B
PCBC	TENTRY(PCILL)		:0				:DRE 30-APR-85
	TENTRY(0)		:1 BILATERAL CLOSED USER GROUP
  IF	X.75
	:THE FOLLOWING THREE ARE UTILITES IN X.75 AND THEREFORE THE FACILITIES
	:ARE ILLEGAL
	TENTRY(PCILL)		:2  ILLEGAL FACILITY
	TENTRY(PCILL)		:3  ILLEGAL FACILITY
	TENTRY(PCILL)		:4  ILLEGAL FACILITY		:DRE 30-APR-85
  ELSE	X.25
	TENTRY(PCBN20)		:2  PACKET SIZE
	TENTRY(PCBN30)		:3  WINDOW SIZE
	TENTRY(PCBC40)		:4  RPOA SELECTION		:DRE 30-APR-85
	TENTRY(PCILL)		:5				:DRE 30-APR-85
	TENTRY(PCILL)		:6				:DRE 30-APR-85
	TENTRY(PCILL)		:7				:DRE 30-APR-85
	TENTRY(PCILL)		:8				:DRE 30-APR-85
	TENTRY(PCBN90)		:9  TRANSIT DELAY INDICATION	:DRE 30-APR-85
  EI	X.25
PCBC.L	EQ	(.-PCBC)/2

:	CLASS C
PCCC	TENTRY(PCILL)						:DRE 30-APR-85
PCCC.L	EQ	(.-PCCC)/2

:	CLASS D
	:ALL OF THE CHARGING INFO FACILITIES BELOW ARE ILLEGAL
	: IN A CALL REQUEST
PCDC	TENTRY(PCILL)		: 0				:DRE 30-APR-85
	TENTRY(PCILL)		: 1 CALL DURATION		:DRE 30-APR-85
	TENTRY(PCILL)		: 2 SEGMENT COUNT		:DRE 30-APR-85
	TENTRY(PCILL)		: 3 REDIRECTION NOTIFICATION	:DRE 30-APR-85
	:PROVIDE CODE HERE FOR 1984 SUPPORT
  if	x.25							:lsh xrpoa
	TENTRY(pcxrpo)		: 4 EXTENDED RPOA SELECTION	:lsh xrpoa
  else	:x.75							:lsh xrpoa
	TENTRY(pcill)		: 4 EXTENDED RPOA SELECTION	:DRE 30-APR-85
  ei								:lsh xrpoa
	TENTRY(PCILL)		: 5 MONITARY UNIT		:DRE 30-APR-85
	:PROVIDE CODE HERE FOR 1984 SUPPORT
	TENTRY(NUIFAC)		: 6 NUI				:DRE 31-DEC-85
PCDC.L	EQ	(.-PCDC)/2

  IF	X.75
:	CALL REQUEST UTILITY PROCESSORS.
PCANN	TENTRY(PCAN00)		:NATIONAL OPTIONS MARKER
	TENTRY(PCAN10)		:REVERSE CHARGING/ FAST SELECT
	TENTRY(PCAN20)		:THROUGHPUT CLASS
	TENTRY(CRF030)		:TRAFFIC CLASS INDICATION, COPY	:DRE 30-APR-85
	TENTRY(PCILL)		:4				:DRE 30-APR-85
	TENTRY(PCILL)						:DRE 30-APR-85
	TENTRY(PCILL)						:DRE 30-APR-85
	TENTRY(PCILL)						:DRE 30-APR-85
	TENTRY(PCILL)		:CALLED LINE ADDRESS MODIFIED NOTIFICATION :DRE 30-APR-85
PCAN.L	EQ	(.-PCANN)/2
:CLASS B
PCBNN	TENTRY(PCILL)						:DRE 30-APR-85
	TENTRY(PCBN10)		:1 TRANSIT NETWORK DNIC
	TENTRY(PCBN20)		:2 PACKET SIZE
	TENTRY(PCBN30)		:3 WINDOW SIZE
	TENTRY(PCBC40)		:4 RPOA SELECTION		:DRE 16-JAN-86
	TENTRY(CUFILL)		:5
	TENTRY(CUFILL)		:6
	TENTRY(CUFILL)		:7
	TENTRY(CUFILL)		:8
	TENTRY(PCBN90)		:9 TRANSIT DELAY INDICATION	:DRE 16-JAN-86
	TENTRY(CUFILL)		:0A CLEARING NETWORK DNIC, BAD IN CR :DRE 16-JAN-86
	TENTRY(CRF030)		:0B TRANSIT DELAY SELECTION,COPY :DRE 11-JUN-87
PCBN.L	EQ	(.-PCBNN)/2
:CLASS C
PCCNN	TENTRY(PCILL)						:DRE 30-APR-85
	TENTRY(PCCN10)		:CALL ID UTILITY
PCCN.L	EQ	(.-PCCNN)/2
:CLASS D		VARIABLE LENGH FACILITY ELEMENT
PCDNN	TENTRY(PCILL)						:DRE 30-APR-85
	TENTRY(PCILL)						:DRE 30-APR-85
	TENTRY(PCILL)						:DRE 30-APR-85
	TENTRY(PCDN30)		:CUG INDICATION
	TENTRY(PCILL)						:DRE 30-APR-85
	TENTRY(PCILL)						:DRE 30-APR-85
	TENTRY(PCILL)						:SCY 25-Sep-84
	TENTRY(PCDN30)		:CUG INDICATION WITH OUTGOING ACCESS
PCDN.L	EQ	(.-PCDNN)/2
  EI	X.75


:	CALL REQUEST PACKET NUMBER OF USER FACILITIES PER CLASS
CRFLEN	BC	PCAC.L,PCBC.L,PCCC.L,PCDC.L		:FOR FACILITY
  IF	X.75
	BC	PCAN.L,PCBN.L,PCCN.L,PCDN.L		:FOR UTILITY
  EI	X.75

:	FACILITY/UTILITY PROCESSING ROUTINES.. (R0)= FACILITY CODE.

:	ILLEGAL FACILITY.. CLEAR CALL.
PCILL	LHI	R12,DIA065
	OOPS
	J	RTECA0			:GO CLEAR CALL

  IF	X.75
:	UTILITY MARKER.
:	IF NOT DATAPAC TARIFF CLASS, CLEAR CALL
PCAN00	JAL	R4,WCI			:COPY FACILITY CODE TO BUFFER
	SIS	R7,1			:ENSURE PARAMETER FOLLOW
	JL	RTECAL
	JAL	R13,PACKCH		:COPY PARAMETER TO BUFFER
	LR	R7,R7
	JE	CRF090			:IF NOTHING FOLLOWING MARKER
    IF	DTARS
	SIS	R7,2			:TRIFF CLASS FOLLOW
	JN	RTECAL			:IF NOT EXACT LENGTH FOR TARIFF CLASS, CLEAR
	JAL	R13,PACKCH
	LHI	R12,DIA076		:"FACILITY NOT PROVIDED" :DRE 17-APR-87
	CLHI	R0,UT.TC
	JN	RTECA0			:IF NOT TARIFF CLASS, CLEAR CALL :DRE 17-APR-87
	JAL	R13,PACKCH
	LHL	R4,IPORT
	STB	R0,TARIFF,R4,		:SAVE CLASS VALUE UNTIL ACCOUNTING STARTS
	J	CRF090			:EXIT
  ELSE
	LHI	R12,DIA181
	LHL	R4,IPORT
	LR	R8,R7
	LIS	R7,0			:INDICATE DONE WITH FACILITY ELEMENTS
	TBT	R4,GATWAY,,
	JN	CRF050			:IF A TRANSIT CALL, PASS IT
	TBT	RL,NAC.F
	JN	RTECA0			:IF OPTION TO CLEAR CALL ON NON CCITT UTILITY
	J	CRF050			:GO COPY ALL
    EI	DTARS
  EI	X.75

:	NATIONAL OPTIONS MARKER.
:	CHECK FOR NATIONAL FACILITY(PARAMETER=0, WE DON'T HAVE ANY OF OUR
:	OWN, BUT WE DO PASS THE TELENET SIZE AND WINDOW ONES TO A GATEWAY).
:	WE THEN CHECK FOR END NETWORK AND OSI END-TO-END FACILITIES.

PCAC00	JAL	R4,PICKCH		:GET THE PARAMETER VALUE
	SIS	R7,1			:ACCOUNT FOR THE BYTE
	LR	R0,R0			:TEST FOR NATIONAL OPTION
	JN	PCAC07			:EITHER END-NETWORK OR OSI MARKER
	LHI	R1,TMPBF1		:PUT IN TEMPORARY BUFFER :DRE 22-MAY-86
	JAL	R4,WCI			:COPY OPTIONS MARKER
	JAL	R4,WCI			:COPY NATIONAL MARKER
PCAC01	LR	R7,R7						:DRE 20-JAN-86
	JE	CRF090			:IF DONE		:DRE 20-JAN-86:DRE 20-JAN-86	:DRE 20-JAN-86
	JAL	R4,PICKCH		:GET A FACILITY CODE	:DRE 20-JAN-86
	SIS	R7,1			:ACCOUNT FOR THE FACILITY CODE :DRE 20-JAN-86
	JLE	RTECAL			:NOT ENOUGH DATA LEFT	:DRE 17-APR-86
	LR	R0,R0			:CHECK FOR ANOTHER OPTIONS MARKER :DRE 20-JAN-86
	JE	PCAC00			:CHECK FOR TYPE OF OPTIONS MARKER :DRE 20-JAN-86
	LHI	R1,TMPBF1		:PUT IN TEMPORARY BUFFER :DRE 22-MAY-86
	JAL	R4,WCI			:COPY THE FACILITY CODE	:DRE 20-JAN-86

  IF	TFACS				:IF ANY LINKS HANDLE TELENET FACILITIES
	TBT	RL,TFAC.F
	JE	PCAC04			:IF NOT SUBSCRIBED TO TELENET FACILITIES

:	ONLY LOOK AT TELENET OPTIONS 5 AND 6.  OTHERS ARE PASSED ON.
:	ASSUMES TELENET FACILITY ELEMENTS HAVE ONE BYTE OF PARAMETER VALUE.
PCAC02	LHI	R12,DIA066
	CLHI	R0,5
	JN	PCAC03			:IF NOT (5), WINDOW SIZE

:	TELENET WINDOW SIZE, JUST SET (PWRCV), (PWTMT).
	
	JAL	R13,PTMPCH		:GET THE VALUE		:DRE 22-MAY-86
	SIS	R7,1			:ACCOUNT FOR IT
	LR	R0,R0
	JE	RTECA0			:0 WINDOW SIZE, CLEAR CALL
	CLHI	R0,7
	JG	RTECA0			:OUT OF RANGE
	LHL	R4,IPORT
	STB	R0,PWRCV,R4,
	STB	R0,PWTMT,R4,
	J	PCAC01			:GO PROCESS NEXT ONE

:	TELENET PACKET SIZE.  CHECK IF IT IS 8.
PCAC03	CLHI	R0,6
	JNFS	PCAC04			:IF NOT (6), PACKET SIZE
	JAL	R13,PTMPCH		:COPY PARAMETER VALUE	:DRE 22-MAY-86
	SIS	R7,1
	CLHI	R0,8
	JN	RTECA0			:IF NOT PACKET SIZE OF 8
	J	PCAC01			:GO PROCESS NEXT ONE

PCAC04	HS
  EI
	LHI	R12,DIA181
	TBT	RL,NAC.F
	JN	RTECA0			:IF OK TO CLEAR CALL FOR NATIONAL FACILITY
	LR	R8,R0
	SRLS	R8,6			:MOVE TYPE IDENT TO LOWER 2 BITS
	CLHI	R8,UT.VAR
	JNFS	PCAC05			:IF NOT VARIABLE LENGTH
	LB	R8,,R5			:PEEK AT LENGTH
PCAC05	AIS	R8,1			:+1 TO GET LENGTH OF PARAMETER	:SCY 25-Sep-84
	SR	R7,R8						:SCY 25-Sep-84
	JL	RTECAL			:NOT ENOUGH DATA LEFT	:DRE 17-APR-87
PCAC06	JAL	R13,PTMPCH					:DRE 22-MAY-86
	SIS	R8,1
	JGBS	PCAC06
	J	PCAC01

PCAC07	CLHI	R0,0F			:CHECK FOR OSI END-TO-END FACILITIES
	JN	PCAC15			:END NETWORK FACILITIES
	LHI	R1,TMPBF1		:PUT IN TEMPORARY BUFFER :DRE 22-MAY-86
	LIS	R0,0			:SET UP FACILITY CODE
	JAL	R4,WCI
	LIS	R0,0F			:SET UP FACLITY PARAMETER
	JAL	R4,WCI
PCAC08	LR	R7,R7			:CHECK FOR REMAINING FACILITIES :DRE 22-MAY-86
	JE	CRF090			:FINISHED WITH FACILITIES FIELD :DRE 22-MAY-86
	JAL	R4,PICKCH		:GET NEXT FACILITY CODE
	SIS	R7,1			:ACCOUNT FOR IT
	JLE	RTECAL			:NOT LONG ENOUGH	:DRE 17-APR-87
	LR	R8,R0			:TEST FOR NATIONAL MARKER
	JE	PCAC00			:HIT ANOTHER NATIONAL MARKER
	LHI	R1,TMPBF1		:PUT IN TEMPORARY BUFFER :DRE 22-MAY-86
	JAL	R4,WCI			:COPY FACILITY CODE FIRST
	SRLS	R8,6			:MOVE TYPE IDENT TO LOWER 2 BITS
	CLHI	R8,UT.VAR
	JNFS	PCAC10			:IF NOT VARIABLE LENGTH
	LB	R8,,R5			:PEEK AT LENGTH
PCAC10	AIS	R8,1			:+1 TO GET LENGTH OF PARAMETER	:SCY 25-Sep-84
	SR	R7,R8						:SCY 25-Sep-84
	JL	RTECAL			:NOT ENOUGH DATA LEFT	:DRE 17-APR-87
PCAC11	JAL	R13,PTMPCH					:DRE 22-MAY-86
	SIS	R8,1
	JGBS	PCAC11
	J	PCAC08			:CONTINUE

PCAC15	CLHI	R0,0FF			:CHECK FOR END NETWORK MARKER
	JN	RTECA0			:CAN'T FIGURE OUT WHAT IT IS
	LHL	R4,IPORT
	TBT	R4,GATWAY,,		:IS THIS A TRANSIT CALL
	JE	CRF090			:NO, WE ARE END NET, SO HANDLE FACILITIES
	LHI	R1,TMPBF1		:PUT IN TEMPORARY BUFFER :DRE 22-MAY-86
	LIS	R0,0			:SET UP FACILITY CODE
	JAL	R4,WCI
	LHI	R0,0FF			:SET UP FACLITY PARAMETER
	JAL	R4,WCI
	J	PCAC08
	
:	REVERSE CHARGE/ FAST SELECT.
:	FACILITY IS REMOVED AND FLAGS *RVCHRG*, *FSTRES*, *FSTSEL* SET AS
:	APPROPRIATE.
PCAN10	SIS	R7,1
	JL	RTECAL			:IF MISSING VALUE	:DRE 17-APR-87
	JAL	R4,WCI			:COPY FACILITY CODE
	JAL	R13,PACKCH		:COPY AND GET VALUE
	LHI	R12,DIA066		:'INVALID FACILITY VALUE'
	LHL	R4,IPORT
	THI	R0,RF.RC
	JE	PCAN12			:IF NO REVERSE CHARGE
	TBT	RL,RCC.F
  IF	X.25
	JN	RTECA0			:IF SUPPOSED TO CLEAR CALL ON RC
  ELSE	X.75
	JEFS	PCAN11			:IF NOT TO CLEAR CALL ON RC
	TBT	R4,GATWAY,,
	JE	RTECA0			:IF NOT A TRANSIT CALL, CLEAR THE CALL
  EI	X.25
PCAN11	SBT	R4,RVCHRG,,
	JEFS	PCAN12			:IF 1ST TIME
	TBT	RL,FAL.F
	JE	RTEDUP			:IF OK TO CLEAR CALL ON DUPLICATED FACILITY
PCAN12	THI	R0,RF.FS
	JE	PCAN16			:IF NO FAST SELECT
  IF	FSTSLT
	TBT	RL,FSS.F
	JE	PCAN14			:IF NOT SUBSCRIBED TO FAST SELECT
	SBT	R4,FSTSEL,,		:INDICATE FAST SELECT
	JEFS	PCAN13			:IF 1ST TIME
	TBT	RL,FAL.F
	JE	RTEDUP			:IF OK TO CCLEAR CALL ON DUPLICATED FACILITY
PCAN13	THI	R0,RF.RS
	JE	CRF090			:IF WITHOUT RESTRICTION
	SBT	R4,FSTRES,,
	J	CRF090
PCAN14	HS
  EI	FSTSLT
	J	RTECA0			:CLEAR WITH 'INVALID FACILITY PARAMETER VALUE'

PCAN16	THI	R0,RF.RS
	JN	RTECA0			:RESTRICTION BIT SET WHILE NO FAST SELECT
	J	CRF090

:	THROUGHPUT CLASS.
PCAN20	SIS	R7,1
	JL	RTECAL			:IF NOT ENOUGH DATA
	TBT	RL,TCN.F
	JNFS	PCAN21			:IF SUBSCRIBED TO NEGOTIATION
	LHI	R12,DIA065		:"FACILITY CODE NOT ALLOWED" :DRE 17-APR-87
	TBT	RL,TCX.F
	JN	RTECA0			:IF TO CLEAR CALL ON TCLASS FACILITY
PCAN21	JAL	R4,WCI			:COPY CODE
	JAL	R4,PICKCH		:GET VALUE
	LHI	R12,DIA066
	LR	R0,R0
	JE	RTECA0			:IF VALUE OF ZERO
	LHL	R8,IPORT
	SBT	R8,TCRCV,,
	JEFS	PCAN22			:IF 1ST TIME
	TBT	RL,FAL.F
	JE	RTEDUP			:IF TO CLEAR CALL ON DUPLICATE
PCAN22	HS
  IF	TCSC			:IF MUST TRANSLATE TO STANDARD CCITT VALUE
	LR	R12,R7			:SAVE (R7)
	JAL	R7,TRTCSC,,		:TRANSLATE TO STANDARD CCITT VALUE
	LR	R7,R12			:RESTORE (R7)
  EI
:	IF THE REQUESTED VALUE IS GREATER THAN THE DEFAULT MAXIMUM VALUE,
:	CHANGE IT THE THE DEFAULT MAXIMUM VALUE.
:	MAKE SURE WE SEND THE MODIFIED VALUE IN THE FACILITY MSG.
	LR	R4,R0
	NHI	R4,0F			:ISOLATE FROM CALLING TC, COMPARE AGAINST RCV TC
	SRHLS	R0,4			:ISOLATE FROM CALLED TC, TMT VALUE
	LB	R2,TTR.LT,RL,		:GET DEFAULT TC
	LR	R3,R2
	NHI	R3,0F			:DEFAULT RCV TC
	SRHLS	R2,4			:DEFAULT TMT TC
	CR	R4,R3
	JGFS	PCAN23			:IF REQUESTED RCV TC IS LARGER THAN DEFAULT
	LR	R3,R4			:USE REQUESTED TC
PCAN23	CR	R0,R2			:COMPARE TMT TC
	JGFS	PCAN24			:IF REQUESTED TMT TC IS LARGER
	LR	R2,R0			:USE REQUSTED TMT TC
PCAN24	SLHLS	R2,4
	OR	R2,R3
	LR	R0,R2
	STB	R0,TCLTR,R8,		:SAVE VALUE FOR CALL CONNECTED PACKET
	JAL	R4,WCI			:COPY TO FACILITIES BUFFER
	J	CRF090

:	PACKET SIZE.  THIS FACILITY IS NOT PASSED TO THE NETWORK.
:	IF THE VALUE IS UNACCEPTABLE, THE DEFALT IS USED IF WE PUT OUT
:	EXTENTED CALL ACCEPT PACKET.
:	MUST SET A FLAG INDICATING WE WANT TO PUT OUT THE CHANGED SIZE
:	LATER IN RM.

PCBN20	SIS	R7,2
	JL	RTECAL			:IF NOT ENOUGH DATA
	LHI	R12,DIA065		:"FACILITY CODE NOT ALLOWED" :DRE 17-APR-87
	LHL	R8,IPORT
:  IF	X.75							:DRE 12-DEC-84
:	TBT	R8,GATWAY,,					:DRE 12-DEC-84
:	JNFS	PCBN21		:IF A TRANSIT CALL		:DRE 12-DEC-84
:  EI	X.75							:DRE 12-DEC-84
	TBT	RL,PSN.F
	JE	RTECA0			:NOT SUBSCRIBED TO NEGOTIATION, CLEAR CALL
PCBN21	LHL	R2,PSTMT,R8,R8
	JEFS	PCBN22			:IF 1ST TIME
	TBT	RL,FAL.F
	JE	RTEDUP			:IF TO CLEAR CALL IF DUPLICATE
PCBN22	JAL	R4,PICKCH		:'FROM CALLED' VALUE
	LIS	R2,0			:INDICATE TO CPSR THIS IS TRANSMIT
	JAL	R8,CPSR			:VALIDATE			:GLEE 9-Jul-84
	SKIPAD(RTECA0)			:ERROR, CLEAR CALL
	LHL	R2,IPORT
	STH	R4,PSTMT,R2,R2
	JAL	R4,PICKCH		:GET 'FROM CALLING' VALUE
	LHL	R2,PSRCV,R2,R2
	JEFS	PCBN23			:IF 1ST TIME
	TBT	RL,FAL.F
	JE	RTEDUP			:IF OPTION TO CLEAR CALL ON DUPLICATE
PCBN23	LIS	R2,1			:INDICATE TO CPSR THIS IS RCV PS
	JAL	R8,CPSR			:VALIDATE			:GLEE 9-Jul-84
	SKIPAD(RTECA0)			:ERROR, CLEAR THE CALL
	LHL	R2,IPORT
	STH	R4,PSRCV,R2,R2
	J	CRF090			:PROCESS NEXT PARM

:	PACKET WINDOW SIZE... PARAMETER NOT PASSED TO THE NETWORK.
PCBN30	SIS	R7,2
	JL	RTECAL			:IF NOT ENOUGH DATA
	LHI	R12,DIA065		:'INVALID FACILITY CODE' :DRE 17-APR-87
	LHL	R2,IPORT
:  IF	X.75
:	TBT	R2,GATWAY,,
:	JNFS	PCBN31			:IF A TRANSIT CALL
:  EI	X.75
	TBT	RL,PWN.F
	JE	RTECA0			:IF NOT SUBSCRIBED TO PACKET WINDOW NEGOTIATION
PCBN31	LHL	R2,IPORT
	LB	R4,PWTMT,R2,
	JEFS	PCBN32			:IF 1ST TIME
	TBT	RL,FAL.F
	JE	RTEDUP			:IF OPTION TO CLEAR CALL ON DUPLICATED FACILITY
PCBN32	JAL	R4,PICKCH		:GET 'FROM CALLED' VALUE
	LHI	R12,DIA066
	JAL	R8,CWS			:VALIDATE WINDLOW SIZE PARAMETER
	SKIPAD(RTECA0)			:ERROR, CLEAR CALL
	STB	R0,PWTMT,R2,		:STORE IN TMT POSITION
	JAL	R4,PICKCH		:GET 'FROM CALLING' VALUE
	LB	R4,PWRCV,R2,
	JEFS	PCBN33			:IF 1ST TIME
	TBT	RL,FAL.F
	JE	RTEDUP			:IF OPTION TO CLEAR CALL ON DUPLICATE
PCBN33	JAL	R8,CWS			:VALIDATE XMT WINDOW
	SKIPAD(RTECA0)			:ERROR, CLEAR CALL
	STB	R0,PWRCV,R2,		:STORE IN RCV POSITION
	J	CRF090			:PROCESS NEXT FACILITY ELEMENT

:	TRANSIT DELAY SELECTION/INDICATION FACILITY INDICATION UTILITY
:	-- UPDATE AND PASS ALONG
PCBN90	SIS	R7,2						:DRE 16-JAN-86
	JL	RTECAL			:IF NOT ENOUGH DATA	:DRE 16-JAN-86
  IF	X.75				:X.75 DOES NOT CHANGE	:DRE 21-JUN-87
	JAL	R4,WCI			:COPY FACILITY CODE	:DRE 16-JAN-86
  EI
	JAL	R4,PICKCH		:GET 1ST BYTE OF DELAY INDICATION :DRE 16-JAN-86
	EXBR	R8,R0						:DRE 16-JAN-86
	JAL	R4,PICKCH		:GET 2ND BYTE OF DELAY INDICATION :DRE 16-JAN-86
  IF	X.75							:DRE 3-JUN-87
	OR	R8,R0						:DRE 16-JAN-86
	AHI	R8,DELAY		:ADD 250 MILLI-SECS DELAY :DRE 16-JAN-86
  ELSE	X.25							:DRE 3-JUN-87
	OR	R8,R0						:DRE 21-JUN-86
	LHI	R0,04B			:SETUP SELECTION UTILITY:DRE 21-JUN-86
	JAL	R4,WCI						:DRE 21-JUN-86
	EXBR	R0,R8						:DRE 21-JUN-86
	JAL	R4,WCI			:STORE 1ST BYTE		:DRE 21-JUN-86
	LR	R0,R8						:DRE 21-JUN-86
	JAL	R4,WCI			:STORE 2ND BYTE		:DRE 21-JUN-86
	LHI	R0,49			:SEUP INDICATION UTILITY:DRE 21-JUN-86
	JAL	R4,WCI						:DRE 21-JUN-86
	LHI	R8,DELAY		:SET DELAY INDICATION TO 250	:DRE 21-JUN-86
  EI								:DRE 3-JUN-87
	EXBR	R0,R8						:DRE 16-JAN-86
	JAL	R4,WCI			:STORE 1ST BYTE		:DRE 16-JAN-86
	LR	R0,R8						:DRE 16-JAN-86
	JAL	R4,WCI			:STORE 2ND BYTE		:DRE 16-JAN-86
	J	CRF090						:DRE 16-JAN-86


  IF	X.75
:	TRANSIT NETWORK ID UTILITY -- COLLECT THEM AND STORE IN TEMP2 BUFFER
:	TEMPORARILY
PCBN10	SIS	R7,2
	JL	RTECAL			:IF NOT ENOUGH DATA
	JAL	R4,WCI			:COPY FACILITY CODE
	JAL	R13,PACKCH		:GET 1ST BYTE OF TNIC
	LHI	R1,TMPBF2					:DRE 23-MAY-86
	EXBR	R8,R0
	JAL	R4,WCI			:STORE 1ST BYTE
	JAL	R13,PACKCH
	OR	R8,R0
	LHI	R1,TMPBF2					:DRE 23-MAY-86
	JAL	R4,WCI			:STORE 2ND BYTE
	LHL	R1,FACBUF
	J	CRF090

:	CALL ID.  SAVE VALUE IN *INVSAV* SO THAT WHEN NORMAL CIRCUIT RESPONSE
:	IS RECEIVED, WE CAN PUT OUT THE ACCOUNTING MESSAGE.

PCCN10	SIS	R7,3
	JL	RTECAL			:IF NOT ENOUGH LENGTH
	JAL	R4,WCI			:COPY FACILITY CODE
	JAL	R13,PACKCH		:1ST BYTE
	EXHR	R8,R0
	JAL	R13,PACKCH		:2ND BYTE
	EXBR	R8,R0
	JAL	R13,PACKCH		:3RD BYTE
	OR	R8,R0
	LHL	R13,IPORT
	SBT	R13,CIDRCV,,		:FLAG 'SAW CALL ID IN CALL REQ', SO LATER AT
:		NORMAL CIRCUIT COMPLETE TIME, WE KNOW TO PUT OUT ACCOUNTING MSG
	JEFS	PCCN12			:IF FIRST TIME
	TBT	RL,FAL.F
	JE	RTEDUP			:IF OK TO CLEAR CALL ON DUPLICATE
PCCN12	SLLS	R13,2
	ST	R8,SAVINV,R13,		:SAVE VALUE FOR LATER
	J	CRF090

:	CLOSED USER GROUP INDICATION.
:	ACCEPT AND PASS ON IF SUBSCRIBED TO CLOSED USER GROUP FACILITY.
PCDN30	HS
    IF	CUGENA			:IF CUG CODE ENABLED
	TBT	RL,CUS.F
:	JN	CRF030			:GO COPY IT			:SCY 25-Sep-84
	JNFS	PCDN31						:SCY 25-Sep-84
    EI
	LHL	R4,IPORT
	TBT	R4,GATWAY,,
	JN	CRF030			:IF A TRANSIT CALL, GO COPY IT
	LHI	R12,DIA065		:'FACILITY CODE NOT ALLOWED'
	J	RTECA0			:GO CLEAR THE CALL
PCDN31								:SCY 25-Sep-84
  IF	CUG.SW							:SCY 25-Sep-84
	STM	R0,CUGSAV,,
	LHL	R6,IPORT
	SLLS	R6,3
	LHL	R2,DTESAX,R6,		:GET CALLED ADDR DNIC	:HJR-SWBT1
	LR	R3,RL
	SLLS	R3,ONI.SC
	CLH	R2,ONI.LT,R3,R3		:IS DNIC OF CALLED ADDRESS = ODNIC?
	JN	PCDN98			:JUST A TRANSIT NETWORK CALL, GO COPY IT
	LB	R4,1,R5			:GET 1ST BYTE OF I.I.C.
	LB	R3,2,R5			:GET 2ND BYTE OF I.I.C.
	SLLS	R4,8
	OR	R4,R3			:R4 CONTAINS THE DNIC PART OF I.I.C.
	LB	R2,3,R5			:GET 3RD BYTE OF I.I.C.
	LB	R3,4,R5			:GET 4TH BYTE OF I.I.C.
	SLLS	R2,8			:
	OR	R2,R3			:R2 CONTAINS THE 2ND PART OF I.I.C.
	SLL	R4,10			:MOVE DNIC PART TO UPPER HALFWORD
	OR	R4,R2			:R2 CONTAINS I.I.C. NOW
:	Look up the CUGMAPPING table (CMPTBL) to try to find a matched I.I.C.
:	If found, then check the DNIC of calling address against authorization
:	list..
:	If not found, then clear the call

	LCS	R3,8
PCDN32	AIS	R3,8			:INDEX TO CMPTBL
	L	R7,CMPTBL,R3,		:GET I.I.C.
	JE	PCDN65
	CR	R4,R7			:COMPARE TWO I.I.C.
	JNBS	PCDN32
PCDN40
	AIS	R3,4			:POIINT TO NEXT FULLWORD
	LHL	R12,CMPTBL+2,R3,	:GET listno
	JE	PCDN63			:NO CHECKING AGAINST LIST
:	GET DNIC OF CALLING ADDRESS
	LHL	R9,DTESAV,R6,		:GET CALLING ADDR DNIC	:HJR-SWBT1
	LIS	R7,0			:INITIAL INDEX TO CDNTBL
	LH	R6,CDNTBL,R7,		:GET 1ST H.W
	JE	PCDN70			:EMPTY
	LB	R6,CDNTBL+1,R7,		:GET listno
	CR	R12,R6			:IS THIS LIST?
	JE	PCDN50			:YES
PCDN45	AIS	R7,2			:POINT TO NEXT H.W
	LH	R4,CDNTBL,R7,		:GET IT
	JE	PCDN70			:END OF TABEL, NO MATCHED listno IS FOUND
	CHI	R4,2000			:DNIC NUMBER IS IN THE RANGE 2000 - 7999
	JGEBS	PCDN45			:SKIP DNICS
	LB	R6,CDNTBL+1,R7,		:GET listno
	CR	R12,R6			:IS THIS LIST
	JN	PCDN45			:NO
:	Found the listno, check DNIC of calling address against this DNIC list
PCDN50
	LR	R4,R7			:SAVE
PCDN55
	AIS	R7,2			:INDEX TO NEXT H.W STORAGE
	LH	R8,CDNTBL,R7,		:GET ITS CONTENT
	CHI	R8,2000			:IS DNIC?
	JL	PCDN90			:NO END OF LIST, NO MATCH FOUND
	CR	R9,R8			:COMPARE TWO DNIC
	JNBS	PCDN55			:LOOP BACK IF NOT THE SAME
:	Get N.I.C. from CMPTBL and write into rtd ring
PCDN60
	LB	R8,CDNTBL,R4,		:GET VALUE OF GOOD
	CLHI	R8,1			:IS +GOOD?
	JN	PCDN75			:DNIC OF CALLING ADDR IS IN BAD CUGDNIC LIST
:	Go to find the associate N.I.C.
PCDN63
	LIS	R12,0			:DNIC PART OF N.I.C. IS 0
	STB	R12,1,R5		:STORE INTO RTD RING
	STB	R12,2,R5
	LHL	R12,CMPTBL,R3,		:GET THE REST OF N.I.C.FROM CMPTBL
	LR	R9,R12			:MAKE A COPY
	SRLS	R12,8			:GET THE 1ST BYTE OF N.I.C.
	STB	R12,3,R5		:STORE THE 1ST BYTE OF N.I.C.
	STB	R9,4,R5			:STORE THE 2ND BYTE OF N.I.C.
	J	PCDN98
PCDN65
	LHI	R12,DIA198		:NO MATCHED I.I.C. IN CUGMAPPING MACRO
	J	RTECA0

PCDN70	LHI	R12,DIA194		:NO CUGDNICLIST MACRO DEFINED
	J	RTECA0

PCDN75	LHI	R12,DIA197		:DNIC OF CALLING ADDR IS IN BAD CUGDNIC LIST
	J	RTECA0

:	no matched DNIC found in the CUG DNIC LIST
PCDN90
	LB	R8,CDNTBL,R4,		:GET VALUE OF GOOD
	CLHI	R8,1			:IS GOOD DNIC LIST?
	JN	PCDN63			:NO, ACCEPT IT SINCE DNIC IN NOT IN BAD LIST
	LHI	R12,DIA195		:DNIC OF CALLING ADDR IS NOT IN GOOD DNIC LIST
	J	RTECA0
PCDN98	LM	R0,CUGSAV,,		:RESTORE R0-R15
  EI	CUG.SW							:SCY 25-Sep-84
	J	CRF030						:SCY 25-Sep-84

  ELSE	X.25
:	PROCESS CLOSED USER GROUP.
:	CUG INDEX IS CONVERTED INTO INTERLOCK CODE AND SENT TO THE NET AS
:	NETWORK UTILITY.
PCAC30	SIS	R7,1
	STH	R0,TEMP2+2		:SAVE FACILITY CODE	:HJR 02-02-87
	JAL	R4,PICKCH		:GET CUG INDEX
	LHI	R12,DIA065
    IF	CUGENA			:IF CUG CODE ENABLED
	TBT	RL,CUS.F
	JE	RTECA0			:IF NOT SUBSCRIBED TO CUG FACILITY, CLEAR CALL
	LIS	R2,0A			:MULTIPLIER TO ACCUMULATE DECIMAL VALUE
	LR	R4,R0			:COPY CUG INDEX NUMBER
	NHI	R0,0F			:GET LOWER DIGIT
	SRLS	R4,4			:GET UPPER DIGIT
	MHR	R4,R2
	AR	R0,R4			:GET CUG VALUE IN HEX
	LH	R2,TEMP2		:SEE IF WE ALREADY GOT A CUG FACILITY
	STH	R0,TEMP2		:STORE THIS ONE FOR LATER
	JL	CRF090			:IF THIS IS THE 1ST TIME
	LHI	R12,DIA073		:'DUPLICATED APPERANCE OF FACILITY'	:DRE 12-DEC-84
	TBT	RL,FAL.F
:	JE	RTECA0			:'FACILITY CODE NOT ALLOWED'	:DRE 31-JAN-84
	JN	CRF090						:DRE 31-JAN-84
    EI
	J	RTECA0			:CLEAR THE CALL
  EI	X.25


:	RPOA SELECTION
PCBC40	SIS	R7,2
	JL	RTECAL			:CLEAR CALL IF NOT ENOUGH DATA
	LHI	R12,DIA065					:DRE 11-MAY-84
	TBT	RL,FARP.F		:ALLOWED TO REQUEST RPOA? :DRE 11-MAY-84
	JN	RTECA0			:'FACILITY CODE NOT ALLOWED' :DRE 11-MAY-84
	JAL	R4,WCI			:COPY RPOA CODE
	LHL	R8,IPORT
   if	x.25							   :lsh xrpoa
	tbt	r8,rpoa.x,,		:received entended rpoa ?  :lsh xrpoa
	jn	rteca0			:yes, clear call with dia065:lsh xrpoa
	sbt	r8,rpoa.b,,		:indicates basic rpoa received:lsh xrpoa
   ei	:x.25							   :lsh xrpoa
	SBT	R8,RPOA.F,,		:FLAG RPOA FOUND	:DRE 2-JUN-87
	JE	PCBC44			:COPY DNIC & SAVE FOR ROUTING
					:for the first time.
   if	x.25	:more than one basic RPOA has received,            :lsh xrpoa 
	tbt	rl,rpf.f		:check for FIRSTSEEN option:lsh xrpoa
	jnfs	pcbc50			:set, ok to copy dnic	   :lsh xrpoa
	tbt	rl,fal.f		:check for LASTSEEN option :lsh xrpoa
	je	rtedup			:not set, clear call w/ dia073:lsh xrpoa
	jn	pcbc44			:set, copy dnic & save for routing:xrpoa
   ei	:x.25				:			   :lsh xrpoa
pcbc50	jal	r13,packch		:copy two bytes of dnic	   :lsh xrpoa
	jal	r13,packch		:without saving for routing:lsh xrpoa
	j	crf090			:done, go for next facility:lsh xrpoa
pcbc44	jal	r13,packch		:copy two bytes of dnic    :lsh xrpoa
 	STB	R0,RPOA.R,R8,R8		:and save them for routing :lsh xrpoa
	JAL	R13,PACKCH
	STB	R0,RPOA.R+1,R8,R8	:RPOA DNIC, 2 DIGITS
	J	CRF090						   :lsh xrpoa

  if	x.25
:	Extended RPOA selection		(new routine)		  :lsh xrpoa
:	Inputs: R0 = the facility code, R7 = the length of the remaining
:		facility to process, R9 = 0, the facility indicator, 
:		R5 -> the next character in the RTC buffer, R6 = the
:		remaining character count in the RTD buffer, RL(R10) =
:		the link number.
:	Register Usage: R8 = the number of the parameters to process,
:			R9 = IPORT, RPTM1 = temporary storage for R9.
:
pcxrpo	lhi	r12,dia069	:invalid facility length
	jal	r4,pickch	:get the parameter length
	je	rtecal		:if zero, clear the call
	lr	r8,r0		:load parameter length into r8
	shi	r7,1,r8		:calculate remaining facility length
	jl	rtecal		:facility field not long enough
	lhi	r12,dia065	:facility code not allowed
	tbt	rl,farp.f	:allowed for RPOA subscription ?
	jn	rteca0		:no, clear w/ facility code not allowed
	st	r9,rptm1	:store r9 in rptm1, uses r9 as iport
	lhl	r9,iport
	tbt	r9,rpoa.b,,	:has received any basic format RPOA ?
	jn	rteca0		:yes, clear w/facility code not allowed
	sbt	r9,rpoa.x,,	:indicating extended RPOA is received
	jn	rtedup		:if not first time, clear w/duplicated facility
	:Everything is OK so far; 
	:converts the extended format RPOA into a sequence of basic format
	:RPOAs.
xrpo10	lhl	r1,facbuf
	lhi	r0,44
	jal	r4,wci		:write facility code 44 into facbuf
	sbt	r9,rpoa.f,,	:indicating call request contains RPOA
	je	xrpo20		:process the 1st DNIC parameter
	:copy rest of DNICs without saving for routing
	jal	r13,packch	:copy 2 digits of DNIC from RTD buffer to facbuf
	jal	r13,packch	:copy another 2 digits of DNIC 
xrpo30	sis	r8,2		:update parameter length to process
	jn	xrpo10		:go ahead to process the next selected DNIC
	l	r9,rptm1	:restore r9	
	j	crf090		:done, go to process the next facility
	:copy 1st DNIC and save it for routing
xrpo20	jal	r13,packch	:copy 2 digits of DNIC from RTD buffer to facbuf
	stb	r0,rpoa.r,r9,r9	:save 2 digits of DNIC for routing
	jal	r13,packch	:copy another 2 digits of DNIC
	stb	r0,rpoa.r+1,r9,r9 :save another 2 digits of DNIC 
	j	xrpo30		:finish up
  ei	:x.25

:	NETWORK USER IDENTIFIER FACILITY
:	CHECK NUI, COPY TO SAVE AREA AND SET FLAGS

NUIFAC	LHI	R12,DIA069		:INVALID FACILITY LENGTH	:DRE 31-DEC-85
	LB	R8,,R5			:PEEK AT LENGTH			:DRE 31-DEC-85
	JE	RTECAL			:SOMEONE ITS TRYING TO TRICK US	:DRE 31-DEC-85
	SHI	R7,1,R8			:CALCULATE REMAINING LENGTH OF FACILITIES	:DRE 31-DEC-85
	JL	RTECAL			:FACILITY FIELD NOT LONG ENOUGH FOR THIS FACILITY	:DRE 31-DEC-85
	LHI	R12,DIA065					:DRE 11-MAY-84
	TBT	RL,FANU.F		:ALLOWED TO REQUEST NUI? :DRE 11-MAY-84
	JN	RTECA0			:'FACILITY CODE NOT ALLOWED' :DRE 11-MAY-84
	JAL	R4,PICKCH		:READ THE LENGTH FIELD		:DRE 31-DEC-85
	LHI	R12,DIA066		:FACILITY PARAMETER NOT ALLOWED	:DRE 31-DEC-85
	LIS	R3,0			:FORM POINTER TO NUI SAVE AREA	:DRE 31-DEC-85
NUIF10	JAL	R4,PICKCH		:GET A CHARACTER		:DRE 31-DEC-85
	OHI	R0,80			:TURN PARITY BIT ON		:DRE 31-DEC-85
	CLHI	R0,0A0			:CHECK FOR CONTROLS IN NAME PART:DRE 31-DEC-85
	JL	RTECA0			:COMPLAIN ABOUT THE NAME	:DRE 31-DEC-85
	STB	R0,NUISAV,R3		:PUT BYTE IN NUI SAVE		:DRE 31-DEC-85
	AIS	R3,1			:ADVANCE POINTER		:DRE 31-DEC-85
	SIS	R8,1			:COUNT THE CHARACTER		:DRE 31-DEC-85
	JLE	NUIF50			:REACHED END OF STRING		:DRE 31-DEC-85
	CLHI	R0,0BB			:IS THIS A SEMI-COLON?		:DRE 31-DEC-85
	JN	NUIF10			:NO,CONTINUE WITH NAME
NUIF20	JAL	R4,PICKCH		:GET A CHARACTER		:DRE 31-DEC-85
	OHI	R0,80			:TURN PARITY BIT ON		:DRE 31-DEC-85
	STB	R0,NUISAV,R3		:PUT BYTE IN NUI SAVE AREA	:DRE 31-DEC-85
	AIS	R3,1			:ADVANCE POINTER		:DRE 31-DEC-85
	SIS	R8,1			:COUNT THE CHARACTER	:DRE 31-DEC-85
	JLEFS	NUIF50			:REACHED END OF STRING	:DRE 31-DEC-85
	CLHI	R0,0BB			:IS THIS A SEMI-COLON?	:DRE 31-DEC-85
	JNBS	NUIF20			:NO,CONTINUE WITH PASSWORD	:DRE 31-DEC-85
NUIF50	STH	R3,TEMP6		:SAVE LENGTH OF NUI	:DRE 31-DEC-85
	LHL	R3,IPORT
	SBT	R3,NUICAL,,		:SET FLAG FOR NUI USE	:DRE 31-DEC-85
	LR	R8,R8			:TEST R8			:DRE 31-DEC-85
	JLE	CRF090			:FINISHED WITH PARAMETER FIELD	:DRE 31-DEC-85
	J	CRF080			:STRIP ANY REMAINING GARBAGE	:DRE 31-DEC-85
	SSTTL(CALL ACCEPTED)
:	PROCESS A CALL ACCEPTED PACKET.

RTCALC	LB	R1,PACKET
	CLHI	R1,YCALA		:VERIFY CALL ACCEPTED PACKET
	JN	RTEILL
  IF	X.25
	LHI	R13,CLRINC^8!DIA040	:INCOMPATIBLE DESTINATION
  ELSE	X.75
	LHI	R13,CNETCG^8!DIA040	:NETWORK CONGESTION
  EI
	TBT	RL,SEEDBT
	JN	SNDCL0			:IF DBIT ON, GO SEND CLEAR
  REMIND(RTCALC- SEND CLEAR FOR CALL ACCEPT WITH D-BIT FOR NOW)
	JAL	R4,RTACCP
	PTRACE
  IF	FSTSLT
:	TBT	RL,FSS.F		:		:LSH 14-JUL-87
:	JEFS	PCA002			:IF NOT SUBSCRIBED TO FAST SELECT
	LHL	R7,IPORT		:		:LSH 14-JUL-87
	TBT	R7,FSTSEL,,		:		:LSH 14-JUL-87
	JEFS	PCA002			:		:LSH 14-JUL-87
	LHI	R13,CLRCAU^8!DIA042
	TBT	R7,FSTRES,,
	JN	SNDCL0			:IF FAST SELECT WITH RESTRICTION, CLEAR CALL
PCA002	HS
  EI	FSTSLT

	LHL	R1,IPORT
	RBT	R1,TCRCV,,
  IF	X.75
	RBT	R1,TNIRCV,,		:RESET 'SAW TRANSIT NET ID' FLAG
  EI	X.75
	LR	R6,R6
	JE	PCA010			:IF NO OTHER FIELDS ARE PRESENT :HJR-SWBT1
: THIS CODE EXECUTED IF THE PFXFLA MACRO HAS BEEN SPECIFIED
  IF	\PFAMAC
 	LHL	R1,PFA.LT,RL2,		:GET OFFSET INTO PREFIX TABLE
	JEFS	PCA005			:JUMP, IF NO TABLE ENTRY
	LA	R1,FLA.LT,R1,		:GET ADDRESS OF PREFIX ENTRY
	ST	R1,PFXEAD
	JAL	R9,PFXMN1		:MODIFY THE PACKET ADDRESSES
	SKIPAD(PCA005)
	LHI	R12,DIA064
	J	RTECA3			:SEND CLEAR WITH CALL SETUP PROBLEM
PCA005	STH	R6,TEMP3		:SAVE UPDATED RTD SECTOR LENGTH
	L	R9,PXSADR		:GET ADDRESS OF RTD SECTOR LENGTH
	LHL	R4,,R9			:GET RTD SECTOR LENGTH
	AH	R4,PXBDIF		:ADD/SUB LENGTH DIFFERENCE
	STH	R4,,R9			:UPDATE SECTOR LENGTH
  EI

PCA010	JAL	R7,BCAESC		:START ESCAPED DATA	:HJR-SWBT1
	JN	RTECA3			:IF ERROR		:HJR-SWBT1
	LR	R6,R6						:HJR-SWBT1
	JE	PCA150			:IF NO OTHER FIELDS ARE PRESENT :HJR-SWBT1
	JAL	R7,CCAC			:CHECK CALLING AND CALLED ADDRESSES :DRE 19-JUN-87
	JL	RTECA3			:GO HANDLE ERROR	:DRE 19-JUN-87
 IF LIIFLAG							:HJR-SWBT1
	JEFS	PCA022			:IF OK			:HJR-SWBT1
	SIS	R0,1			:CALLED OR CALLING ERR?	:HJR-SWBT1
	JG	RTECA3			:IF CALLING ERR		:HJR-SWBT1
	SBT	RL,TEMP4		:ELSE MARK CALLED ERR	:HJR-SWBT1
	JFS	PCA023						:HJR-SWBT1
PCA022	RBT	RL,TEMP4		:MARK NO ERR		:HJR-SWBT1
 EI :LIIFLAG							:HJR-SWBT1
PCA023	LR	R6,R6						:HJR-SWBT1
	JE	PCA150			:IF NO MORE DATA
	LHL	R1,IPORT
	RBT	R1,TCRCV,,		:INIT 'SAW THROUGHPUT CLASS ' BIT

  IF	X.75
:	SCAN NETWORK UTILITIES.
	LHL	R1,IPORT
	SLLS	R1,2
	AHI	R1,FACBIA
	STH	R1,FACBUF		:SET UP FACILITIES BUFFER ADDRESS
	JAL	R4,EMPTY,,		:MAKE SURE IT IS EMPTY
	LIS	R14,1			:INDICATE CALL ACCEPT UTL PROCESSING
	JAL	R13,CUF			:PROCESS UTILITIES
	ST	R5,TEMP1		:MARK END OF UTILITY FIELD
	LR	R6,R6			:SEE IF ANY MORE DATA
	JE	PCA150
  EI	X.75

:	SCAN USER FACILITIES PROCESSING THROUGHPUT CLASS AND WINDOW SIZE.
	LIS	R14,0			:INDICATE CALL ACCEPT FACILITY PROCESSING
	JAL	R13,CUF			:GO COPY FACILITIES
  IF	X.25
	ST	R5,TEMP1		:MARK END OF FACILITY FIELD
  EI	X.25
	LR	R6,R6
	JE	PCA150			:IF NO CALL USER DATA FIELD
	LHL	R1,IPORT
  IF	FSTSLT
	TBT	R1,FSTSEL,,
	JNFS	PCA149			:IF FAST SELECT, OK TO HAVE C.U.D.
  EI
  IF	TCAPS				:IF ANY TELENET CALL ACCEPTED LINKS
	TBT	RL,TCAP.F		:IS THIS LINK ??
	JNFS	PCA149			:IF SO
  EI	TCAPS
	LHI	R12,DIA039		:C.U.D. ON CALL ACCEPT		:DRE 25-JAN-85
	J	RTECA3			:GO CLEAR CALL

PCA149	CLHI	R6,$A128
	JG	RTELNG			:C.U.D. > 128 BYTES, CLEAR CALL
	:changes begin here	:LSH 14-JUL-87
 IF	FSTSLT
	:Increment packet and segment count for called user data.
	:Every 64 bytes of data is counted as one segment.
:@@@@@@@:In version 5, should set up FSTFLG here.  Set FST.CA bit.
	STH	R6,RUFCNR		:FOR ROUTINE CIP1SX
	JAL	R4,CIP1SX,,	
 EI	:FSTSLT	
	:changes end here	:LSH 14-JUL-87

:	FINISH SCANNING CALL ACCEPT PACKET.
PCA150	LHI	R12,DIA067		:SET UP FOR ILLEGAL CALLED ADDRESS :DRE 10-FEB-87
	TBT	RL,TEMP4		:DID WE HAVE A BAD CALLED ADDRESS :DRE 10-FEB-87
	JN	RTECA3			:YES, REPORT ERROR	:DRE 10-FEB-87
	LHL	R1,DPORT
	TBT	R1,TURKEY
	JE	PCA300
	LHI	R12,EXMF
	TBT	R1,IIXCAL
	JE	PCA160			:IF TALKING TO 'OLD INTERFACES'
	LHI	R12,EXM12
	
:- BEGIN -----------------------------------------------------  :HJR-SWBT1
:	IF HAVE NOT GOTTEN ANY TC INDICATION FROM THE CALL ACCEPT PACKET,
:	MUST ADD ONE TO THE CALL ACCEPT ESCPD MSG BEING MADE.
:	PUT IT IN TMPBF3

	LHL	R7,IPORT
	TBT	R7,TCRCV,,
	JN	PCA160			:IF RCVD TC FACILITY INDICATION
	LHI	R1,TMPBF3		:GET BUFFER INDEX
	LHI	R0,FC.TC		:TC FACILITY CODE
	JAL	R4,WCI
	LB	R0,TCLTR,R7,		:GET TC VALUE TO SEND
	EXHB(R0,R2)
	JAL	R4,WCI
	L	R4,FACPTR		:UPDATE COUNT
	LB	R0,0,R4
	AIS	R0,2
	STB	R0,0,R4
:-- END ------------------------------------------------------  :HJR-SWBT1

PCA160	JAL	R14,MCAESC		:OUTPUT ESCAPED MESSAGE	:HJR-SWBT1

:	INITIALIZE TPAD VALUE OF DATA FORWARDING CONDITION
PCA300	LHL	R1,DPORT		:RELOAD DISPATCHER PORT
	TBT	R1,TURKEY
	JN	PCA340			:IF TURKEY, DON'T BOTHER WITH TPAD PARAMETERS
	LB	R0,TREF3,RL,		:INIT TPAD DATA FORWARDING CONDITION
	STB	R0,XMTMSK,R1,		:USE IT

:	INITIALIZE TPAD VALUE OF IDLE DATA FORWARDING TIMER
	LB	R0,TREF4,RL,		:INITIAL IDLE TIMER
	JEFS	PCA310			:IF ZERO, DON'T START IT
	STB	R0,IDLCNT,R1,		:SET UP TPAD INITIAL VALUE
	RBT	R1,NDATIM		:ENABLE TIMER

:	INITIALIZE TPAD VALUE OF BREAK HANDLING PARAMETER
PCA310	LB	R0,TREF7,RL,		:INITIAL CONFIGURATION VALUE
	STB	R0,BRKMSK,R1,		:SAVE IN CURRENT VALUE STORAGE
	LHL	R2,DPORT		:GET DPORT FOR OUTMSG
	OUTMSG(CONMSG,,REMOTE)		:OUTPUT CONNECTED MSG.	 :HJR  09-26-86
	TBT	RL,ETM.F		:WANT AUTO ETM TO 2741 ??
	JE	PCA340			:IF NOT
	LHL	R7,DPORT		:DISPATCHER PORT #
	TBT	R7,IBM27		:TEST IF TYMSAT CALL FROM 2741
	JE	PCA340			:IF NOT
	LHL	R7,IPORT
	RBT	R7,TPAR2		:RESET VIRTUAL MODE (TO TRANSPARENCY)
	LHL	R1,DPORT					:GML 3-Aug-84
	RBT	R1,WIBMCA,,		:NO LONGER WAITING FOR CALL ACCEPT	:GML 3-Aug-84
	RBT	R1,GRNBAL		:DID WE HAVE A GREEN BALL OUTSTANDING?	:GML 3-Aug-84
	JE	PCA320			:IF NOT				:GML 3-Aug-84
	CTLMSG(GB)			:SEND GREEN BALL		:GML 3-Aug-84
PCA320	CTLMSG(ETM)			:SEND ETM
	TBT	RL,EOT.F		:FOLLOW ETM WITH EOT ??
	JE	PCA340			:IF NOT
	LHL	R1,DPORT
	LIS	R0,4			:LENGTH OF MESSAGE
	LIS	R2,1			:MSG TYPE 1 = FOR SINGLE DATA CHARACTER
	JAL	R4,SLOR,,		:START MSG
	LHI	R0,0FC			:EOT
	JAL	R4,PUTCH
	JAL	R4,ELOR,,
PCA340	LHL	R7,IPORT
	LHI	R1,PFLOWC		:GET FLOW CONTROL READY STATE
	STB	R1,PCKSTE,R7,		:SAVE NEW STATE
	LHL	R2,DPORT
	RBT	R7,TNTA.F		:TURN OFF INCOMING CALLTIMER
	LIS	R12,0			:INDICATE RECEIVING CALL ACCEPT FROM
					:LINK	:JS 30-DEC-87
	JAL	R7,SETTWP,,		:SET CLASS, WINDOW SIZE, PACKET SIZE


:	SEND ACCOUNTING MESSAGES:
:		- REPORT 'CALL ACCEPTED'
:		- REPORT CALLED ADDRRESS
:		- REPORT CALLING ADDRRESS
:		- REPORT TRANSIT NETWORK ID (X.75)

	LI	R7,AA.IRC!CA.BT		:'E00E8000'
	JAL	R9,GENRPT,,		:REPORT 'CALL ACCEPTED' TO ACCOUNTING
	:Removed by Louisa Hsu		:LSH 14-JUL-87
	:When receiving incoming call, has reported called and calling
	:address already
:	LA	R9,DTESAV,,
:	LI	R8,AA.CD4
:	JAL	R13,ACTADR,,		:'CALLED ADDRESS' ACCOUNTING
:	LA	R9,DTESAX,,
:	LI	R8,AA.CL4
:	JAL	R13,ACTADR,,		:'CALLING ADDRESS' ACCOUNTING
:	:removed by Louisa Hsu		:LSH 14-JUL-87
:	:Won't report call accepted status until version 5.
:@@@@@@@:In version 5, should report fast select accounting (E016 +
	:FSTFLG) right here.
:  IF	FSTSLT
:	TBT	RL,FSA.F		:IF SUBSCRIBE TO ACCEPANTANCE
:	JE	PCA350			:NO, DON,T NEED REPORT:LSH 27-APR-87
:	LHL	R4,IPORT					:JL 14-Jan-85
:	TBT	R4,FSTSEL,,					:JL 14-Jan-85
:	JEFS	PCA350			:NOT A FAST SELECT CALL	:JL 14-Jan-85
:	LI	R7,AA.FST!FST.CA	:OTHERWISE REPORT FAST SELECT CALL
:					:ACCEPTED (E0160001) 	:LSH 10-FEB-87
:	JAL	R9,GENRPT,,		:ACCOUNTING		:JL 14-Jan-85
: EI	FSTSLT

	:Removed by Louisa Hsu		:LSH 14-JUL-87
	:When receiving incoming call, have reported all the
	:initial counts already. Routine CIP1SX has set the bits
	:already (see between PCA149 and PCA150)
:PCA350	LHL	R4,DPORT					
:	SBT	R4,POCHNG		:only input counts are changed		
:	SBT	R4,PICHNG			
:	SBT	R4,SOCHNG		:LSH 14-JUL-87	
:	SBT	R4,SICHNG				
	JAL	R4,PCTRPT,,					
	JAL	R4,SCTRPT,,					
  IF	X.75
:	REPORT TRANSIT NETWORK DNIC LIST.
	JAL	R6,TNIRPT		:REPORT TRANSIT NET ID ACCOUNTING
  EI	X.75
	J	RTD020
	SSTTL(CA/CLR FACILITY/UTILITY)

::	CUF - PROCESS UTILITY OR FACILITY FOR CALL ACCEPT PACKET, AND
:		UTILITY FOR CLEAR PACKET.
:
:	INPUT	R5-> LENGTH FIELD OF UTILITY/FACILITY IN RTD RING
:		(R6)= REMAINING CHARS IN RING
:		(R14)   =0 IF PROCESSING FACILITY FOR CALL ACCEPT
:			=1 IF PROCESSING UTILITY FOR CALL ACCEPT, X75
:			=2 IF PROCESSING UTILITY FOR CALL CLEAR PACKET, X75
:	USES	R0-R9,R12-14,TEMP3				:HJR-SWBT1
:	CALLS	PICKCH,TRTCSC,CPSA,CWS
:	EXIT TO *RTECA2* IF CODE OR VALUE WRONG
:		 *RTECA3* IF ERROR IN LENGTH
:	EXIT	TMPBF3 CONTAINS UTILITIES/FACILITIES TO BE SENT
:		 ACROSS THE NETWORK.
:	LINK IS R13

CUF	JAL	R4,PICKCH		:GET FACILITY/UTILITY LENGTH
	LHI	R12,DIA069					:DRE 25-JAN-85
	CLHI	R0,$A109		:DO RANGE CHECK		:DRE 25-JAN-85
	JG	RTECA3			:FIELD TOO LONG,GO SEND CLEAR
	LHI	R12,DIA038
	LR	R7,R0
	CLR	R7,R6
	JG	RTECA3			:CLEAR CALL IF NOT ENOUGH DATA IN PACKET
	LR	R7,R7			:CHECK FOR A COUNT OF ZERO
	JER	R13			:IF 0 LENGTH
	ST	R13,TEMP3		:SAVE RETURN		:HJR-SWBT1
	LIS	R13,0			:INIT COPY COUNT	:HJR-SWBT1
	LHI	R1,TMPBF3		:GET BUFFER INDEX	:HJR-SWBT1

:	(R7)= REMAINING LENGTH OF UTIL/FAC FIELD
CUF020	JAL	R4,PICKCH		:GET FACILITY CODE
	LHI	R12,DIA038		:"packet too short"	:DRE 17-APR-87
	SIS	R7,1
	JLE	RTECA3			:IF MISSING PARAMETER VALUE
	LR	R9,R0
	LR	R4,R0
	NHI	R4,3F			:GET LOWER 6 BIS
	SRHLS	R9,6			:USE UPPER 2 BITS, FOR CLASS BIAS
	LR	R3,R14			:GET PROCESSOR TYPE
	SLHLS	R3,2			:GET OFFSET TO CLASS LENGTH TABLE
	CLB	R4,CUFLEN,R9,R3
	JGE	CUF040			:IF DOES NOT FALL WITHIN DEFINED RANGE
	SLHLS	R3,1			:GET OFFSET TO CLASS TABLE
	AR	R3,R9
	LH	R3,CUFDEC,R3,R9		:GET OFFSET TO GROUP WITHIN TABLE :DRE 1-JUN-87
	AR	R4,R4
	LH	R4,CUFDEC,R4,R3		:GET ADDRESS TO JUMP TO :DRE 1-JUN-87
	JN	CUFDEC,R4		:JUMP TO PROCESSOR

:	COPY FACILITY ELEMENT OR CLEAR THE CALL.
:	(R9) = NO. OF BYTES TO COPY
CUF040	LHI	R12,DIA065
	TBT	RL,UNC.F
	JN	RTECA2			:IF TO CLEAR CALL
:	COPY FACILITY ELEMENT.
CUF050	CLHI	R9,UT.VAR
	JNFS	CUF055			:IF NOT VARIABLE LENGTH
	LB	R9,,R5			:PEEK AT LENGTH
CUF055	AIS	R9,1
CUF056	LHI	R12,DIA038		:'packet too short' :DRE 17-APR-87
	SR	R7,R9
	JL	RTECA3			:IF NOT ENOUGH LENGTH
	CR	R6,R9						:HJR-SWBT1
	JL	RTECA3			:IF NOT ENOUGH LENGTH
:- BEGIN -----------------------------------------------------	:HJR-SWBT1
	JAL	R4,WCI			:PUT IN FACILITY CODE
	AHI	R13,1,R9		:UPDATE TOTAL, INCLUDE FACIL CODE
	LR	R8,R13			:SAVE COUNT
CUF060	JAL	R13,PACKC0		:MOVE CHARACTERS
	SIS	R9,1
	JGBS	CUF060
	LR	R13,R8			:RESTORE COUNT
:-- END ------------------------------------------------------	:HJR-SWBT1
:	RETURN HERE FROM PROCESSORS.
CUF090	LR	R7,R7
	JG	CUF020			:IF MORE FACILITY ELEMENTS TO GO
:- BEGIN -----------------------------------------------------	:HJR-SWBT1
	L	R4,FACPTR		:UPDATE UTIL/FACIL COUNT
	LB	R0,0,R4
	AR	R0,R13
	STB	R0,0,R4
	L	R13,TEMP3		:GET BACK RETURN ADDR
	LR	R14,R14			:FACILITIES?
	JER	R13			:DONE IF YES
	LIS	R0,0			:ELSE ADD IN 0 FACILITY COUNT
	JAL	R4,WCI
	L	R0,BE,R1,		:UPDATE FACIL COUNT POINTER
	ST	R0,FACPTR
:-- END ------------------------------------------------------	:HJR-SWBT1
	JR	R13			:EXIT

:	JUMP TABLE ADDRESSES.

 TABLE(CUFDEC)

:	CLASS TABLES... OFFSET TO BEGINNING OF EACH CLASS
:	FOR FACILITY, CALL ACCEPT
	TENTRY(PCFAT)		:SINGLE OCTET FACILITY CODES
	TENTRY(PCFBT)		:DOUBLE OCTET FACILITY CODES
	TENTRY(PCFCT)		:TRIPLE OCTET FACILITY CODES
	TENTRY(PCFDT)		:VARIABLE OCTET FACILITY CODES
  IF	X.75
:	FOR UTILITY, CALL ACCEPT
	TENTRY(PCUAT)
	TENTRY(PCUBT)
	TENTRY(PCUCT)
	TENTRY(PCUDT)
:	FOR UTILITY, CALL CLEAR
	TENTRY(PLUAT)
	TENTRY(PLUBT)
	TENTRY(PLUCT)
	TENTRY(PLUDT)
  EI	X.75

:	PROCESSOR ADDRESS TABLES.
:	CALL ACCEPT FACILITY PROCESSORS.
PCFAT	TENTRY(PCAA00)		:0  NATIONAL OPTIONS MARKER
	TENTRY(CUFILL)		:1  REVERSE CHARGE
	TENTRY(PCAA20)		:2  THROUGHPUT CLASS
	TENTRY(CUFILL)		:3  CUG SELECTION		:DRE 30-APR-85
  IF	X.25
	:PROVIDE CODE HERE FOR 1984 SUPPORT
	TENTRY(CUFILL)		:4 CHARGING INFO REQUEST	:DRE 30-APR-85
	TENTRY(CUFILL)		:5				:DRE 30-APR-85
	TENTRY(CUFILL)		:6				:DRE 30-APR-85
	TENTRY(CUFILL)		:7				:DRE 30-APR-85
	TENTRY(PCAA80)		:8  CALLED LINE ADDRESS MODIFIED NOTIFICATION				:DRE 30-APR-85
  EI
PCFA.L	EQ	(.-PCFAT)/2

PCFBT	TENTRY(CUFILL)		:0				:DRE 30-APR-85
	TENTRY(CUFILL)		:1  BILATERAL CLOSED USER GROUP	:DRE 30-APR-85
	TENTRY(PCBA20)		:2  PACKET SIZE
	TENTRY(PCBA30)		:3  WINDOW SIZE
	TENTRY(CUFILL)		:4  RPOA SELECTION
	TENTRY(CUFILL)		:5				:DRE 30-APR-85
	TENTRY(CUFILL)		:6				:DRE 30-APR-85
	TENTRY(CUFILL)		:7				:DRE 30-APR-85
	TENTRY(CUFILL)		:8				:DRE 30-APR-85
	TENTRY(CUFILL)		:9  TRANSIT DELAY INDICATION	:DRE 30-APR-85
PCFB.L	EQ	(.-PCFBT)/2

PCFCT	TENTRY(CUFILL)		:0				:DRE 30-APR-85
PCFC.L	EQ	(.-PCFCT)/2

				:VARIABLE LENGTH FACILITY ELEMENT
PCFDT	TENTRY(CUFILL)		:0				:DRE 30-APR-85
	TENTRY(CUFILL)		:1 CALL DURATION		:DRE 30-APR-85
	TENTRY(CUFILL)		:2 SEGMENT COUNT		:DRE 30-APR-85
	TENTRY(CUFILL)		:3 CALL REDIRECTION NOTIFICATION	:DRE 30-APR-85
	TENTRY(CUFILL)		:4 RPOA - EXTENDED		:DRE 30-APR-85
	TENTRY(CUFILL)		:5 MONITARY UNIT		:DRE 30-APR-85
	:PROVIDE CODE HERE FOR 1984 SUPPORT
	TENTRY(CUFILL)		:6 NUI			:DRE 30-APR-85
PCFD.L	EQ	(.-PCFDT)/2

  IF	X.75
:	CALL ACCEPT UTILITY.
PCUAT	TENTRY(PCAA00)		:0  NATIONAL OPTIONS MARKER
	TENTRY(CUFILL)		:1 REVERSE CHAGE, ILLEGAL
	TENTRY(PCAA20)		:2  THROUGHPUT CLASS
	TENTRY(CUF050)		:3 TRAFFIC CLASS INDICATION, COPY	:DRE 30-APR-85
	TENTRY(CUFILL)		:4				:DRE 30-APR-85
	TENTRY(CUFILL)		:5				:DRE 30-APR-85
	TENTRY(CUFILL)		:6				:DRE 30-APR-85
	TENTRY(CUFILL)		:7				:DRE 30-APR-85
	TENTRY(PCAA80)		:8  CALLED LINE ADDRESS MODIFIED NOTIFICATION				:DRE 30-APR-85
PCUA.L	EQ	(.-PCUAT)/2

PCUBT	TENTRY(CUFILL)		:0				:DRE 30-APR-85
	TENTRY(PCBA10)		:1  TRANSIT NETWORK ID
	TENTRY(PCBA20)		:2  PACKET SIZE
	TENTRY(PCBA30)		:3  WINDOW SIZE
	TENTRY(CUFILL)		:4  RPOA SELECTION
	TENTRY(CUFILL)		:5
	TENTRY(CUFILL)		:6
	TENTRY(CUFILL)		:7
	TENTRY(CUFILL)		:8
	TENTRY(CUF050)		:9  TRANSIT DELAY INDICATION, COPY :DRE 11-JUN-87
	TENTRY(CUFILL)		:10 CLEARING NETWORK IDENTIFICATION :DRE 30-APR-85
PCUB.L	EQ	(.-PCUBT)/2

PCUCT	TENTRY(CUFILL)		:0				:DRE 30-APR-85
	TENTRY(PCCA10)		:1  CALL ID
PCUC.L	EQ	(.-PCUCT)/2

		:VARIABLE LENGTH FACILITY ELEMENT
PCUDT	TENTRY(CUFILL)						:DRE 30-APR-85
	TENTRY(CUFILL)						:DRE 30-APR-85
	TENTRY(CUFILL)					:DRE 30-APR-85
	TENTRY(CUFILL)		:3 CUG INDICATION		:DRE 30-APR-85
	TENTRY(CUFILL)						:DRE 30-APR-85
	TENTRY(CUFILL)						:DRE 30-APR-85
	TENTRY(CUFILL)		:6 CUG INDICATION WITH OUTGOING ACCESS	:DRE 30-APR-85
PCUD.L	EQ	(.-PCUDT)/2

:	CLEAR REQUEST UTILITY.
PLUAT	TENTRY(PCAA00)		:0  NATIONAL OPTIONS MARKER
	TENTRY(CUFILL)		:1  REVERSE CHARGING/FAST SELECT	:DRE 30-APR-85
	TENTRY(CUFILL)		:2  THROUGHPUT CLASS
	TENTRY(CUFILL)		:3  CUG SELECTION		:DRE 30-APR-85
	TENTRY(CUFILL)		:4  CHARGING INFO REQUEST	:DRE 30-APR-85
	TENTRY(CUFILL)		:5				:DRE 30-APR-85
	TENTRY(CUFILL)		:6				:DRE 30-APR-85
	TENTRY(CUFILL)		:7				:DRE 30-APR-85
	TENTRY(PCAA80)		:8  CALLED LINE ADDRESS MODIFIED NOTIFICATION	:DRE 30-APR-85
PLUA.L	EQ	(.-PLUAT)/2

PLUBT	TENTRY(CUFILL)		:0				:DRE 30-APR-85
	TENTRY(PCBA10)		:1  TRANSIT NETWORK ID
	TENTRY(CUFILL)		:2  PACKET SIZE
	TENTRY(CUFILL)		:3  WINDOW SIZE
	TENTRY(CUFILL)		:4  RPOA SELECTION
	TENTRY(CUFILL)		:5
	TENTRY(CUFILL)		:6
	TENTRY(CUFILL)		:7
	TENTRY(CUFILL)		:8
	TENTRY(CUFILL)		:9
	TENTRY(CUF050)		:10 CLEARING NETWORK IDENTIFICATION :DRE 30-APR-85
PLUB.L	EQ	(.-PLUBT)/2

PLUCT	TENTRY(CUFILL)		:0				:DRE 30-APR-85
	TENTRY(CUFILL)		:1  CALL ID
PLUC.L	EQ	(.-PLUCT)/2

				:VARIABLE LENGTH FACILITY ELEMENT
PLUDT	TENTRY(CUFILL)		:0				:DRE 30-APR-85
	TENTRY(CUFILL)						:DRE 30-APR-85
	TENTRY(CUFILL)						:DRE 30-APR-85
	TENTRY(CUFILL)		:3 CUG INDICATION		:DRE 30-APR-85
	TENTRY(CUFILL)						:DRE 30-APR-85
	TENTRY(CUFILL)						:DRE 30-APR-85
	TENTRY(CUFILL)		:6 CUG INDICATION WITH OUTGOING ACCESS	:DRE 30-APR-85
PLUD.L	EQ	(.-PLUDT)/2
  EI	X.75

:	LENGTH ARRAY FOR EACH PROCESSOR TYPE
CUFLEN	BC	PCFA.L,PCFB.L,PCFC.L,PCFD.L
  IF	X.75
	BC	PCUA.L,PCUB.L,PCUC.L,PCUD.L
	BC	PLUA.L,PLUB.L,PLUC.L,PLUD.L
  EI	X.75

:	ILLEGAL FACILITY, CLEAR CALL.
CUFILL	LHI	R12,DIA065		:'FACILITY CODE NOT ALLOWED'
	J	RTECA2

:	NATIONAL OPTIONS MARKER.
PCAA00	LHI	R12,DIA181
	TBT	RL,NAC.F
	JN	RTECA2			:IF NATIONAL OPTIONS NOT ALLOWED
	LR	R9,R7
	J	CUF056			:GO COPY TILL END OF FACILITY

:	THROUGHPUT CLASS.
PCAA20	JAL	R4,WCI			:PUT TC CODE IN BUFFER	:HJR-SWBT1
	AIS	R13,2			:UPDATE COUNT FOR CODE AND VALUE :HJR-SWBT1
	JAL	R4,PICKCH		:GET TC VALUE		:HJR-SWBT1
	SIS	R7,1
  IF	TCSC				:IF NEED TO TRANSLATE TO STANDARD VALUE
	LR	R9,R7			:SAVE (R7)
	JAL	R7,TRTCSC,,		:TRANSLATE TPUT CLASS TO STANDARD CLASS
	LR	R2,R5			:CURRENT RTD INDEX
	SIS	R2,1
	STB	R0,,R2			:ALTER VALUE TO BE PASSED TO THE NETWORK
	LR	R7,R9			:RESTORE (R7)
  EI
	LHL	R4,IPORT
	LR	R2,R0
	NHI	R2,0F			:ISOLATE CALLING VALUE
	SRHLS	R0,4			:ISOLATE CALLED VALUE
	TBT	RL,TCN.F
	JNFS	PCAA22			:IF SUBSCRIBED TO TC NEGOTIATION
	LHI	R12,DIA065		:'FACILITY CODE NOT ALLOWED'
	TBT	RL,TCX.F
	JN	RTECA2			:IF TO CLEAR CALL ON TC

:	MAKE SURE VALUE RECVD IS LESS OR EQUAL TO THE VALUE SENT IN CALL REQ.
PCAA22	LHI	R12,DIA066		:'FACILITY VALUE NOT ALLOWED'
	LB	R3,TCLTR,R4,		:GET TC SENT ON CALL REQ.
	LR	R9,R3
	NHI	R9,0F			:COMPARE RCV WITH CALLED VALUE
	CR	R9,R0
	JL	RTECA2			:'TC IN CALL ACCEPT > REQUESTED VALUE'
	SRHLS	R3,4
	CR	R3,R2
	JL	RTECA2			:'TC IN CALL ACCEPT > REQUESTED VALUE'
PCAA24	SLHLS	R2,4			:MOVE CLG VALUE TO TMT POSITION
	OR	R0,R2
	STB	R0,TCLTR,R4,		:STORE FINAL TC
	JAL	R4,WCI			:PUT IN BUFFER		:HJR-SWBT1
	LHL	R4,IPORT					:HJR-SWBT1
	SBT	R4,TCRCV,,		:SET TCRCV		:HJR-SWBT1
	J	CUF090

:	CALLED LINE ADDRESS MODIFIED NOTIFICATION
:	INDICATION THAT CALLED ADDRESS HAS BEEN INTENTIONALLY CHANGED
:	IF WE HAVE OUR OWN ALREADY, DISCARD THIS ONE		:HJR-SWBT1

PCAA80	RBT	RL,TEMP4		:CLEAR CALLED ADDRESS ERROR FLAG :DRE 10-FEB-87
  IF	X.25
	LB	R0,,R5			:PEEK AT PARAMETER FIELD :DRE 10-FEB-87
	THI	R0,80			:IS THE DTE ORG FLAG ON?
	JNFS	PCAA82			:YES, ACCEPT IT		:HJR-SWBT1
	TBT	RL,PCAU.F		:PASS ANYWAY?		:HJR-SWBT0
	JNFS	PCAA82			:IF YES			:HJR-SWBT0
	LHI	R12,DIA066		:DISALLOW
	J	RTECA2			:SEND INVALID FAC REQUEST,66
:- BEGIN -----------------------------------------------------	:HJR-SWBT1
PCAA82
 IF LIIFLAG
	LHL	R2,IPORT		:CHECK REDIRECTION INDICATION
	LB	R0,CALRDR,R2,
	JEFS	PCAA84			:SKIP IF WE DON'T HAVE ONE
	JAL	R4,PICKCH		:ELSE DISCARD THIS
	SIS	R7,1			:UPDATE TOTAL FACILITY LENGTH
	J	CUF090
 EI :LIIFLAG
PCAA84	LHI	R0,FC.CLA		:CLAMN FACILITY CODE	:AHM-SWBT1
	J	CUF050			:GO COPY FACILITY
:-- END ------------------------------------------------------	:HJR-SWBT1
  ELSE	X.75
	J	CUF050			:COPY THE UTILITY AS IS :DRE 10-FEB-87
  EI
:	PACKET SIZE FACILITY.
:	THE REQUESTED VALUE FROM CALL ACCEPT PACKET IS SUBJECTED TO THE
:	CONSTRAINTS:	PI = PACKET SIZE INDICATED IN CALL REQUEST
:			PR = PACKET SIZE DREQUESTED IN CALL ACCEPT
:
:	IF PI >= 128,	PI >=PR >=128
:	IF PI <  128,	128 >= PR >= PI

PCBA20	SIS	R7,2
	JL	RTECA3			:IF NOT ENOUGH LENGTH
	LHI	R12,DIA065		:'FACILITY CODE NOT ALLOWED'
	TBT	RL,PSN.F
	JE	RTECA2			:CLEAR CALL IF NOT SUBSCRIBED TO NEGOTIATION
	JAL	R4,PICKCH		:GET 'FROM CALLED' PACKET SIZE
	LIS	R2,1			:INDICATE THIS IS RCV PS
	JAL	R8,CPSA			:VALIDATE		:GLEE 9-Jul-84
	SKIPAD(RTECA2)			:ERROR, CLEAR CALL
	LHL	R2,IPORT
	LHL	R3,PSRCV,R2,R2		:GET INDICATED VALUE FROM CALL REQ (PI)
	STH	R4,PSRCV,R2,R2		:STORE REQUESTED VALUE (PR)
	LHI	R12,DIA185		:'REJECTED VALUE REQUESTED FROM PS NEGOTIATION'
	SHI	R4,$A128
	SHI	R3,$A128
	JLFS	PCBA22			:IF PI < 128
	LR	R4,R4
	JL	RTECA2			:IF PR < 128
	SR	R4,R3
	JG	RTECA2			:IF PR > PI
	JFS	PCBA24			:VALUE ACCEPTABLE

:	INDICATED PS WAS LESS THAN 128.
PCBA22	LR	R4,R4
	JG	RTECA2			:IF PR > 128
	CR	R3,R4
	JG	RTECA2			:IF PR LESS THAN PI
PCBA24	JAL	R4,PICKCH		:GET 'FROM CALLING' PACKET SIZE
	LIS	R2,0			:INDICATE THIS IS TMT PS
	JAL	R8,CPSA			:VALIDATE			:GLEE 9-Jul-84
	SKIPAD(RTECA2)			:ERROR, CLEAR CALL
	LHL	R2,IPORT
	LHL	R3,PSTMT,R2,R2		:GET PI
	STH	R4,PSTMT,R2,R2		:STORE PR
	LHI	R12,DIA185		:'PS VALUE IN CALL ACCEPT NOT ACCEPTABLE'
	SHI	R4,$A128
	SHI	R3,$A128
	JLFS	PCBA26			:IF PI LESS THAN 128
	LR	R4,R4
	JL	RTECA2			:IF PR LESS THAN 128
	SR	R4,R3
	JG	RTECA2			:IF PR > PI
	J	CUF090			:VALUE ACCEPTABLE

PCBA26	LR	R4,R4
	JG	RTECA2			:IF PR > 128
	CR	R3,R4
	JG	RTECA2			:IF LESS THAN CALL REQ VALUE
	J	CUF090


:	WINDOW SIZE FACILITY.
:	REQUESTED WINDOW SIZE VALUE FROM THE CALL ACCEPT PACKET IS SUBJECTED
:	TO THE FOLLOWING CONSTRAINT:	WI = INDICATED WS FROM CALL REQ
:					WR = REQUESTED WS FROM CALL ACCEPT
:
:	IF WI > 2	WI >= WR >= 2
:	IF WI = 1	WR = 1 OR 2

PCBA30	SIS	R7,2
	JL	RTECA3			:IF NOT ENOUGH DATA
	LHI	R12,DIA065
	TBT	RL,PWN.F
	JE	RTECA2			:CLEAR CALL IF NOT SUBSCRIBED TO NEGOTIATION
	JAL	R4,PICKCH		:GET 'FROM CALLED' WINDOW SIZE
	JAL	R8,CWS			:VALIDATE
	SKIPAD(RTECA2)			:ERROR, CLEAR CALL
	LHI	R12,DIA186		:'VALUE NOT ACCEPTABLE IN PW NEGOTIATION'
	LHL	R4,IPORT
	LB	R3,PWRCV,R4,		:GET WI
	STB	R0,PWRCV,R4,		:STORE WR
	SIS	R3,2
	JGEFS	PCBA32			:IF WI > 1
	SIS	R0,2
	JG	RTECA2			:IF WR > 2
	J	PCBC34			:VALUE ACCEPTABLE

:	INDICATED WINDOW SIZE WAS >= 2.
PCBA32	SIS	R0,2
	JL	RTECA2			:IF WR < 2
	SR	R0,R3
	JG	RTECA2			:IF WR IS LARGER
PCBC34	JAL	R4,PICKCH		:GET 'FROM CALLING' WINDOW SIZE
	JAL	R8,CWS			:VALIDATE WINDOW SIZE
	SKIPAD(RTECA2)			:ERROR, CLEAR CALL
	LHI	R12,DIA186		:'VALUE NOT ACCEPTABLE IN PW NEGOTIATION'
	LHL	R4,IPORT
	LB	R3,PWTMT,R4,		:GET WI VALUE
	STB	R0,PWTMT,R4,		:STORE WR
	SIS	R3,2
	JGEFS	PCBA34			:IF WI > 1
	SIS	R0,2
	JG	RTECA2			:IF WR > 2
	J	CUF090			:VALUE ACCEPTABLE

PCBA34	SIS	R0,2
	JL	RTECA2			:IF WR < 2
	SR	R0,R3
	JG	RTECA2			:IF WR IS LARGER
	J	CUF090

  IF	X.75
:	TRANSIT NETWORK ID-- COPY TO FACILITIES BUFFER AND SET *TNIRCV*
:	SO THAT WE CAN REPORT THE TRANSIT NET ID ACCOUNTING MESSAGE LATER.
PCBA10	SIS	R7,2
	JL	RTECA3			:IF NOT ENOUGH LENGTH
	JAL	R4,WCI			:COPY UTIL CODE		:HJR-SWBT1
	AIS	R13,3			:UPDATE TOTAL IN BUFFER	:HJR-SWBT1
	LHL	R1,IPORT
	SBT	R1,TNIRCV,,		:MARK 'SAW TRANIST NET ID'
:- BEGIN -----------------------------------------------------	:HJR-SWBT1
PCBA11	JAL	R4,PICKCH		:GET BYTE OF DNIC
	LHL	R1,FACBUF
	JAL	R4,WCI			:COPY TO FAC BUF
	LHI	R1,TMPBF3		:RESTORE COPY BUFFER
	JAL	R4,WCI			:COPY
	SIS	R9,1			:DONE?
	JGBS	PCBA11			:CONTINUE IF NOT
:-- END ------------------------------------------------------	:HJR-SWBT1
	J	CUF090

:	CALL ID UTILITY -- SAVE THE VALUE IN *SAVINV* AND SET *CIDRCV*
:	SO THAT WE CAN REPORT THE GATEWAY INVOICE NUMBER ACCT MSG LATER.
:	**** NOTE - JUST DISCARD FOR NOW ****
PCCA10	SIS	R7,3
	JL	RTECA3			:IF NOT ENOUGH LENGTH
	JAL	R4,PICKCH		:GET 1ST BYTE OF CALL ID
:	EXHR	R9,R0						:HJR-SWBT0
	JAL	R4,PICKCH		:GET 2ND BYTE OF CALL ID
:	EXBR	R9,R0						:HJR-SWBT0
	JAL	R4,PICKCH		:GET 3RD BYTE OF CALL ID
:	OR	R9,R0						:HJR-SWBT0
	J	CUF090
  EI	X.75
	SSTTL(ERROR IN PACKET -- RTEXXX)

	SEG	A.RTBL
:	DIAGNOSTIC BYTE TABLE.
:	FOLLOWING ARE GENERAL DIAGNOSTIC BYTES USED FOR EACH PACKET STATE.


DIAGTB	HS
	BC	DIA020	:0	P1 - READY
	BC	DIA022	:1  P	P3 - SEND INCOMING CALL (CALL REQUEST)
	BC	DIA022	:2  A	P3 - WAIT FOR CALL ACCEPTED (CALL CONNECTED)
	BC	DIA021	:3  C	P2 - MUST SEND CALL ACCEPTED (CALL CONNECTED)
	BC	DIA026	:4  K	P7 - SEND CLEAR INDICATION
	BC	DIA026	:5  E	P7 - WAIT FOR CLEAR CONF.
	BC	DIA025	:6  T	P6 - SEND CLEAR CONF.
	BC	DIA023	:7	P4 - FLOW CONTROL READY
	BC	DIA029	:8  S	D3 - MUST SEND RESET INDICATION
	BC	DIA029	:9  T	D3 - WAIT FOR RESET CONF :DRE 14-APR-86
	BC	DIA028	:A  A	D2 - MUST SEND RESET CONF.
	BC	DIA019	:B  T	R3 - SEND RESTART INDICATION :DRE 14-APR-86
	BC	DIA019	:C  E	R3 - WAIT FOR RESTART CONF. :DRE 14-APR-86
	BC	DIA018	:D	R2 - SEND RESTART CONF	:DRE 14-APR-86
	BC	DIA027	:E	   - PVC BUILDING STATE	:DRE 14-APR-86

	SEG	A.CODE

:	INVALID GFI
RTEGFI	ERRPTRACE						:DRE 12-DEC-84
	LIS	R0,1
	AHM	R0,BADGFI,RL,RL
	OOPS
	LHI	R5,DIA040		:INVALID GFI DIAG	:DRE 31-DEC-87
	J	SNDIAG			:SEND DIAGNOSTIC	:DRE 31-DEC-87

::	PICKCH-	GET A CHARACTER OUT OF RTD BUFFER.
:
:	INPUT	R5->NEXT CHAR IN BUFFER
:		(R6)=CHAR COUNT LEFT IN BUFFER
:	OUTPUT	(R0)=CHARACTER RETURNED
:	USES	R0,R5,R6
:	LINK IS R4

PICKCH	LB	R0,,R5			:GET CHAR
	AIS	R5,1			:UPDATE POINTER
	SIS	R6,1
	JGER	R4			:IF OK
	TRAP(R5,FA)			:TRIED TO GET DATA FROM EMPTY RTD BUFFER

:	PACKET TOO SHORT.
RTESHT	ERRPTRACE						:DRE 12-DEC-84
	LIS	R0,1						:DRE 01-MAR-85
	AHM	R0,SHTPKT,RL,RL
	OOPS
	LHI	R13,DIA038		:SET UPT TOO SHORT DIAG :DRE 5-JAN-88
	LA	R12,RSMSG4,,
	J	RTELN1			:HANDLE ACCORDING TO STATE :DRE 5-JAN-88
:	LHI	R13,CLRCAU^8!DIA038	:SET UP TOO SHORT DIAG	:DRE 01-MAR-85
:	JAL	R8,CLEARP		:CLEAR THE CIRCUIT	:DRE 01-MAR-85
:	J	RTD020			:DISCARD PACKET

:	PACKET TOO SHORT TO BLAME IT ON A PARTICULAR CHANNEL	:DRE 01-MAR-85
RTEIGN	LIS	R0,1						:DRE 01-MAR-85
	AHM	R0,SHTPKT,RL,RL
	OOPS
	LHI	R5,DIA038		:SHORT PACKET DIAG	:DRE 31-DEC-87
	J	SNDIAG			:SEND DIAGNOSTIC	:DRE 31-DEC-87


:	PACKET ON UNASSIGNED LOGICAL CHANNEL.
RTEUNA	ERRPTRACE						:DRE 12-DEC-84
	REMIND(RTEIGN,RTEGFI,RTEUNA - ISSUE DIAG PACKET #38,#40,36)
	OOPS
	LHI	R5,DIA036		:UNASSIGNED CHANNEL DIAG:DRE 31-DEC-87
	J	SNDIAG			:SEND DIAGNOSTIC	:DRE 31-DEC-87

:	ILLEGAL PACKET TYPE.
RTEILL	LHI	R13,DIA033
	LA	R12,IPTMSG,,
	ERRPTRACE			:TRACE ILLEGAL PACKET
	J	RTELN1			:GO TO ERROR DECISION

:	INVALID P(S) IN A DATA PACKET.
RTEPS	LA	R12,RSMSG1,,		:GET ERROR MESSAGE ADDRESS
	LHI	R13,DIA001
	OOPS
	J	SNDRSE			:GO SEND RESET

:	P(S) NOT ALLOWED, OUTSIDE WINDOW.
RTEPS2	LA	R12,RSMSG2,,		:GET ERROR MESSAGE ADDRESS
	LHI	R13,DIA001
	OOPS
	J	SNDRSE

:	INVALID P(R) IN DATA PACKET.
RTEPR	LA	R12,RSMSG3,,		:ERROR MESSAGE ADDRESS
	LHI	R13,DIA002
	OOPS
	J	SNDRSE			:GO SEND  RESET

:	Q BIT VIOLATION
RTEQB	LHI	R13,DIA083					:DRE 12-DEC-84
	LA	R12,RSMSG8,,
	OOPS
	J	SNDRSE

:	PACKET EXCEEDS MAXIMUM PERMITTED LENGTH.
RTELNG	LHI	R13,DIA039
	LA	R12,LNGMSG,,
	OOPS
RTELN1	LHL	R7,IPORT		:INTERNAL PORT #
	LB	R2,PCKSTE,RL,		:CHECK LINE STATE	:DRE 5-JAN-88
	CLHI	R2,PREADY		:COMPARE WITH READY	:DRE 5-JAN-88
	JNFS	RTELN3			:NOT READY, USE LINE STATE :DRE 5-JAN-88
	LB	R2,PCKSTE,R7,		:READY STATE, USE CHANNEL STATE :DRE 5-JAN-88
RTELN3	LH	R2,LNGTBL,R2,R2		:GET ROUTINE ADDRESS	:DRE 5-JAN-88
	J	LNGTBL,R2

:BEGIN OF CHANGE FOR EXT. INTERRUPT PACKET			:AHM-XINTRPT 05-AUG-87
:	INCOMPATIABLE TURKEY LEVEL FOR SENDING AN EXT. INTERRUPT PACKET
RTEINT	LA	R12,RSMSG4,,		:ERROR MSG - DATA FIELD TOO LONG
	LHI	R13,RSEINC^8!DIA044	:CAUSE, INCOMPATIABLE DESTINATION
					:DIAG, UNAUTHORIZED INTERRUPT
	OOPS
	J	SNDRS0			:GO SEND RESET				
:END OF CHANGE FOR EXT. INTERRUPT PACKET			:AHM-XINTRPT 05-AUG-87

 TABLE(LNGTBL)
  TENTRY(SNDCLR) :0	P1 - CHANNEL IN READY STATE
  TENTRY(SNDCLR) :1	P3 - SEND INCOMING CALL STATE
  TENTRY(SNDCLR) :2	P3 - WAIT FOR CALL ACCEPTED STATE
  TENTRY(SNDCLR) :3	P2 - SENT CALL CONNECTED STATE
  TENTRY(SNDCLR) :4	P7 - SEND CLEAR INDICATION STATE
  TENTRY(ERRP7)  :5	P7 - WAIT FOR CLEAR CONFIRMATION STATE	:DRE 6-JAN-88
  TENTRY(SNDCLR) :6	P6 - SEND CLEAR CONFIRMATION STATE
  TENTRY(LNGFCR) :7	P4 - FLOW CONTROL READY
  TENTRY(SNDRSE) :8	D3 - SEND RESET INDICATION
  TENTRY(ERRD3)  :9	D3 - WAIT FOR RESET CONFIRMATION 
  TENTRY(SNDRSE) :A	D2 - SEND RESET CONF STATE
  TENTRY(RTD020) :B	R3 - SEND RESTART
  TENTRY(RTD020) :C	R3 - WAIT FOR RESTART CONF
  TENTRY(RTD020) :D	R2 - SEND RESTART CONF
  TENTRY(SNDRSE) :E	     PVC BUILDING STATE			:DRE 14-APR-86

:	IF CLEAR REQ, SEND CLEAR ELSE SEND RESET.
LNGFCR	LB	R1,PACKET
	CLHI	R1,YCLRR
	JE	SNDCLR
	J	SNDRSE


:	ERROR IN STATE P7
ERRP7	LB	R1,PACKET		:GET PACKET TYPE	:DRE 6-JAN-88
	CLHI	R1,YCLRR		:CHECK FOR CLEAR REQUEST :DRE 6-JAN-88
	JE	SNDCLR			:RESPOND TO BAD CLEAR WITH CLEAR :DRE 6-JAN-88
	CLHI	R1,YCLRC		:CHECK FOR CLEAR CONF	:DRE 6-JAN-88
	JE	SNDCLR			:TELL THEM ABOUT IT	:DRE 6-JAN-88
	J	RTD020


:	ERROR IN STATE D3
ERRD3	LB	R1,PACKET		:GET PACKET TYPE	:DRE 6-JAN-88
	CLHI	R1,YREST		:CHECK FOR RESET REQUEST :DRE 6-JAN-88
	JE	SNDRSE			:RESPOND TO BAD RESET WITH RESET :DRE 6-JAN-88
	CLHI	R1,YRESTC		:CHECK FOR RESET CONF	:DRE 6-JAN-88
	JE	SNDRSE			:TELL THEM ABOUT IT	:DRE 6-JAN-88
	J	RTD020

:	DATA PACKET TOO LONG.
DATLNG	LA	R12,RSMSG4,,		:GET ERROR MESSAGE ADDRESS
	LHI	R13,DIA039
	OOPS

:	SEND A RESET ON A LOGICAL CHANNEL.
:	(R13)= DIAGNOSTIC CODE TO SEND
:	(R12)= MESSAGE TO SEND

SNDRSE	OHI	R13,RSECAU^8
SNDRS0	JAL	R8,RESETP		:DO REST OF RESET PROCESSING
	J	RTD020


:	ERROR IN CALL REQUEST PACKET.
:	(R12)= DIAGNOSTIC BYTE TO SEND

RTEDUP	LHI	R12,DIA073		:DUPLICATED FACILITY CODE
RTECA0	HS
  IF	X.75
	OHI	R12,CNETCG^8		:USE NETWORK CONGESTION CAUSE
  ELSE	X.25
	OHI	R12,CINVLD^8		:USE INVALID FACILITY REQ
  EI
	JFS	RTECA1

RTECA4	OHI	R12,CACBAR^8		:USE 'ACCESS BARRED' CAUSE
	JFS	RTECA1

RTECAL	OHI	R12,CLRCAU^8
RTECA1	LHL	R1,IPORT
	STH	R12,PSDIAG,R1,R1
	JAL	R9,QCR			:QUEUE UP A CLEAR REQ
	LIS	R0,1
	AHM	R0,SM.103,RL,RL
	J	RTD020


:	ERROR IN CALL ACCEPT PACKET.
:	(R12)= DIAGNOSTIC BYTE TO SEND
RTECA3	LR	R13,R12
	LB	R4,PACKET
	CLHI	R4,YCLRR
	JN	SNDCLR			:IF NOT RESPONDING TO A CLEAR PACKET
	LHL	R2,IPORT
	SBT	R2,ERRCLR,,		:TELL RM TO CLEAN UP PORT AFTER SENDING CLEAR
	J	SNDCLR			:GO SEND CLEAR REQ

RTECA2	OHI	R12,CINVLD^8
	LR	R13,R12
	LB	R4,PACKET
	CLHI	R4,YCLRR
	JN	SNDCL0			:IF NOT RESPONDING TO A CLEAR PACKET
	LHL	R2,IPORT
	SBT	R2,ERRCLR,,		:TELL RM TO CLEAN UP PORT AFTER SENDING CLEAR
	J	SNDCL0

:	ERROR DECISION FOR RT.
:	(R13)= DIAGNOSTIC BYTE TO SEND
:	(R12)= MESSAGE TO SEND

RTEDEC	LHL	R7,IPORT
RTEDE1	LB	R1,PCKSTE,R7,				:DRE 4-JAN-88
	LH	R1,RTDFER,R1,R1
	J	RTDFER,R1		:GO HANDLE RESULTS AS UNACCEPTABLE


  IF	\PFXMAC							:FAK 28-Aug-84
:  THE FOLLOWING CODE IS EXERCISED ONLY WHEN THE PREFIX MACROS ARE CONFIGURED.
:  THIS CODE IS USED ONLY TO MODIFY CALL REQUESTS AND CALL ACCEPTS.
:  SIMILAR CODE EXISTS UNDER LABEL PFXMN2.
:  THE GENERAL CODE FLOW IS AS FOLLOWS,
:
:	PFXMN1	MAIN ROUTINE
:	   PFXGAB   GET ADDRESSES FROM SECTOR AND PUT IN WORK AREAS
:	   PFXMTC   DOES ADDRESS MATCH OF CALLED ADDRESS IF NECESSARY
:	   PFXFNA   SETS TRUE/FALSE ACTION FOR CALLED ADDRESS IN PREFIX TABLE
:	   PFXMTC   DOES ADDRESS MATCH OF CALLING ADDRESS IF NECESSARY
:	   PFXFNA   SETS TRUE/FALSE ACTION FOR CALLING ADDR. IN PREFIX TABLE
:
:	RETURN CAN BE MADE BACK TO NORMAL FLOW FOR A VARIETY OF REASONS. AN
:	ERROR (CLEARING) RETURN CAN ALSO BE MADE
:
:	PFXMN1	MAIN ROUTINE
:	   AT ENTRANCE,
:		PFXEAD = ADDRESS OF PREFIX TABLE ENTRY
:		R5	= BYTE POINTER INTO SECTOR
:		R6	= NUMBER CHARS. LEFT IN SECTOR
:	   UPON NORMAL EXIT,
:		THE SECTOR IS MODIFIED AS SPECIFIED BY THE PREFIX MACROS
:		R5 = UNMODIFIED
:		R6 = UPDATED NUMBER OF CHARS LEFT IN SECTOR
:		PXBDIF = PACKET LENGTH DIFFERENCE IN BYTES
:	   ERROR EXIT (CLEARING ASSUMED),
:		JUMP RETURN + 4
:

PFXMN1	ST	R9,PFXRTN		:SAVE RETURN ADDRESS
	ST	R5,PXBADR		:SAVE SECTOR ADDRESS
	STH	R6,PXBLEN		:SAVE SECTOR LENGTH
	LIS	R0,0
	STH	R0,PXBDIF		:INITIALIZE PKT LENGTH DIFFERENCE
	JAL	R9,PFXGAB		:PUT ADDRESSES IN WORK AREA
	L	R2,PFXEAD		:GET PREFIX ENTRY ADDRESS
	LHL	R3,IPORT					:FAK 26-Jul-84
	LB	R0,,R2			:GET CALLED ADDR MATCH BYTE
	JNFS	MN20			:JUMP, IF NOT ZERO
	SBT	R3,PXCD.F,		:NO MATCH, THEN ASSUME TRUE ACTION
MN15	LR	R0,R2
	AIS	R0,1
MN18	ST	R0,ACTPTR		:SET TRUE CALLED ACTION ADDR
	J	MN100
MN20	LB	R9,DOMATC		:ARE WE TO COMPARE CALLED ADDR'S??	:FAK 26-Jul-84
	JEFS	MN25			:JUMP, IF NOT		:FAK 26-Jul-84
	CLHI	R0,0FF			:WAS TLR/FLR SPECIFIED ??
	JN	MN30			:JUMP IF NO
	TBT	R3,PXCD.F,		:IS ACTION TRUE OR FALSE??
	JN	MN15			:SET ACTION PTR TO TRUE COND.
MN25	RBT	R3,PXCD.F,		:INDICATE FALSE ACTION TAKEN	:FAK 26-Jul-84
	LIS	R0,0			:FIND FALSE ACTION FOR CALLED ADDR
	JAL	R9,PFXFNA
	J	MN18			:SET ACTION POINTER TO FALSE COND.
:
:   DO THE PREFIX TABLE TO SECTOR CALLED ADDRESS COMPARE
MN30	LA	R1,PFXCLD,		:SET PTR TO CALLED WORK AREA
	JAL	R9,PFXMTC		:COMPARE CALLED ADDR PREFIX
	LHL	R3,IPORT
	RBT	R3,PXCD.F,		:INITIALIZE TO FALSE ACTION
:	CLHI	R0,0			:IS THE ACTION FALSE ?
	LR	R0,R0			:IS THE ACTION FALSE ?	:DRE 31-JAN-85
	JEFS	MN35			:JUMP, IF YES
	SBT	R3,PXCD.F,		:SET TO TRUE ACTION
MN35	JAL	R9,PFXFNA		:GET MATCH RESULTS ACTION ADDR
	ST	R0,ACTPTR		:SET CALLED ACTION ADDR
:
:   CALLING ADDRESS BEGINS HERE
MN100	LIS	R3,3			:LOOP COUNTER TO GET TO MATCH BYTE2 :FAK 26-Jul-84
	LIS	R4,0			:INDEX INTO THE TABLE ENTRY
MN110	LB	R0,,R2,R4		:GET MATCH OR CONDITION BYTE
	JEFS	MN112			:JUMP, IF 0
	THI	R0,0080			:TEST FOR NEGATIVE NUMBER
	JEFS	MN120			:JUMP, IF POSITIVE
MN112	AIS	R4,1
MN115	SIS	R3,1
	JNBS	MN110
	JFS	MN140
MN120	SRLS	R0,1			:INCREMENT ENTRY INDEX PAST
	JNCFS	MN130			:    MATCH STRING
	AIS	R4,1
MN130	AIS	R4,1
	AR	R4,R0
	JBS	MN115
MN140	AR	R2,R4			:POINT R2 TO CALLING ADDR MATCH BYTE
	ST	R2,MBYTE2		:SAVE ADDRESS OF CALLING MATCH BYTE
	LHL	R3,IPORT
	LB	R0,,R2			:GET CALLING ADDR MATCH BYTE
	JNFS	MN150			:JUMP, IF NOT ZERO
	SBT	R3,PXCL.F,		:NO MATCH, THEN ASSUME TRUE ACTION
MN145	LR	R0,R2
	AIS	R0,1
MN148	ST	R0,ACTPTR+4		:SET TRUE CALLING ACTION ADDRESS
	J	MN200
MN150	LB	R9,DOMATC+1		:ARE WE TO COMPARE CALLING ADDR'S?? :FAK 26-Jul-84
	JEFS	MN155						:FAK 26-Jul-84
	CLHI	R0,0FF			:WAS TLR/FLR SPECIFIED ??
	JNFS	MN160			:JUMP IF NO
	TBT	R3,PXCL.F,		:IS ACTION TRUE OR FALSE??
	JN	MN145			:SET ACTION PTR TO TRUE COND.
MN155	RBT	R3,PXCL.F,					:FAK 26-Jul-84
	LIS	R0,0			:FIND FALSE ACTION FOR CALLING ADDR
	JAL	R9,PFXFNA
	J	MN148			:SET ACTION POINTER TO FALSE COND.
:
:   DO THE PREFIX TABLE TO SECTOR CALLING ADDRESS COMPARE
MN160	LA	R1,PFXCLL,		:SET PTR TO CALLING WORK AREA
	JAL	R9,PFXMTC		:COMPARE CALLING ADDR PREFIX
	LHL	R3,IPORT
	RBT	R3,PXCL.F,		:INITIALIZE TO FALSE ACTION
:	CLHI	R0,0			:IS THE ACTION FALSE ?
	LR	R0,R0			:IS THE ACTION FALSE ?	:DRE 31-JAN-85
	JEFS	MN165			:JUMP, IF YES
	SBT	R3,PXCL.F,		:SET TO TRUE ACTION
MN165	JAL	R9,PFXFNA		:GET MATCH RESULTS ACTION ADDR
	ST	R0,ACTPTR+4		:SET CALLING ACTION ADDRESS
:
:   VALIDATE THAT THE ACTIONS CAN BE PERFORMED ON THE SECTOR ADDRESSES
:	CORRECTLY. IF THE ACTIONS CANNOT BE PERFORMED OR IF THE CLR (F5)
:	KEYWORD WAS SPECIFIED THE ERROR RETURN IS TAKEN.
MN200	LB	R4,PFXCLD		:GET EXISTING CALLED LENGTH	:FAK 26-Jul-84
	L	R2,ACTPTR		:GET CALLED ACTION ADDRESS
	LB	R0,,R2			:GET CONDITION BYTE
	JE	MN250			:JUMP, IF CALLED VALID. UNNECESSARY
	CLHI	R0,0F5			:WAS CLR KEYWORD SPECIFIED??
	JE	MN900			:TAKE ERROR RETURN
	RRL	R0,8
	SRA	R0,18			:SIGN EXTEND BIT 7
	AR	R0,R4			:NEW CALLED ADDR LENGTH IN R0
	JL	MN900			:INVALID IF .LT. 0
	CLB	R0,PXADLN,,					:FAK 29-Nov-84
	JG	MN900			:INVALID IF .GT. 14 OR 15	:FAK 29-Nov-84
	JFS	MN300						:DRE 5-DEC-84
MN250	LR	R0,R4			:NEW AND OLD ADDRESSES THE SAME
MN300	LB	R5,PFXCLL		:GET EXISTING CALLING ADDR LENGTH
	L	R2,ACTPTR+4		:GET CALLING ACTION ADDRESS	:FAK 26-Jul-84
	LB	R1,,R2			:GET CONDITION BYTE
	JE	MN350			:JUMP, IF CALLING VALID. UNNECESSARY
	CLHI	R1,0F5			:WAS CLR KEYWORD SPECIFIED??
	JE	MN900			:TAKE ERROR RETURN
	RRL	R1,8
	SRA	R1,18			:SIGN EXTEND BIT 7
	AR	R1,R5			:COMBINE LENGTHS
	JL	MN900			:INVALID IF .LT. 0
	CLB	R1,PXADLN,,						:FAK 29-Nov-84
	JG	MN900			:INVALID IF .GT. 14 OR 15	:FAK 29-Nov-84
	JFS	MN400						:DRE 5-DEC-84
MN350	LR	R1,R5			:OLD AND NEW ADDRESSES SAME
MN400	LR	R6,R4			:COMBINE ORIG.ADDR. LENGTHS
	SLLS	R6,4
	OR	R6,R5
	LR	R7,R0			:COMBINE NEW ADDR. LENGTHS
	SLLS	R7,4
	OR	R7,R1
	CR	R6,R7			:COMPARE LENGTHS
	JE	MN700			:JUMP IF NO ACTIONS PERFORMED
	LR	R6,R4			:DETERMINE THE NUMBER OF BYTES
	AR	R6,R5			:   NECESSARY TO HOLD THE NEW
	LR	R7,R0			:   ADDRESSES IN THE SECTOR
	AR	R7,R1			:R6=OLD LENGTH, R7=NEW LENGTH
	SRLS	R6,1
	JNCFS	MN410
	AIS	R6,1
MN410	SRLS	R7,1
	JNCFS	MN420
	AIS	R7,1
MN420	LR	R8,R7			:COMPUTE DIFFERENCE BETWEEN
	SR	R8,R6			:   OLD & NEW ADDRESSES
	STH	R8,PXBDIF		:SAVE PKT LENGTH DIFFERENCE
	AH	R8,PXBLEN		:UPDATE SECTOR LENGTH
:
: RELOCATE SECTOR TO REFLECT CHANGES TO THE CALLED AND CALLING ADDRESS
: LENGTH
	STB	R0,PFXCLD		:SAVE NEW CALLED ADDR. LENGTH
	STB	R1,PFXCLL		:SAVE NEW CALLING ADDR. LENGTH
	L	R5,PXBADR		:GET CURRENT SECTOR POINTER
	LHL	R4,PXBLEN		:GET CURRENT REMAINING LENGTH
	STH	R8,PXBLEN		:REPLACE OLD WITH NEW LENGTH
	CR	R8,R4			:COMPARE OLD AND NEW LENGTHS
	JE	MN500			:JUMP, IF THE SAME LENGTH
	JG	MN450			:JUMP, IF NEW GREATER THAN OLD LENGTH
	LR	R6,R4			:SETUP TO RELOCATE SECTOR DATA
	SR	R6,R8
	LIS	R1,0
MN430	LB	R0,,R5,R6		:ROUTINE TO RELOCATE SECTOR BYTES
	STB	R0,,R5,R1		:   WHEN NEW LENGTH IS LESS THAN
	AIS	R1,1			:   OLD LENGTH
	AIS	R6,1
	CR	R6,R4
	JNBS	MN430
	JFS	MN500
MN450	LB	R0,,R5,R4		:ROUTINE TO RELOCATE SECTOR BYTES
	STB	R0,,R5,R8		:   WHEN OLD LENGTH IS LESS THAN
	SIS	R8,1			:   NEW LENGTH
	SIS	R4,1
	JGEBS	MN450						:DRE 29-JAN-85

: NOW MOVE THE NEW ADDRESSES INTO THE SECTOR, REPLACING THE OLD ADDRESSES
MN500	L	R5,PXBADR		:GET BEGINNING ADRESS INTO SECTOR
	LB	R7,PFXCLD		:GET NEW CALLED ADDR LENGTH
	LB	R1,PFXCLL		:GET NEW CALLING ADDR LENGTH
	SLLS	R1,4
	OR	R1,R7			:COMBINE LENGTHS
	STB	R1,,R5			:STORE LENGTHS INTO SECTOR
	AIS	R5,1			:INCREMENT ADDRESS POINTER
:
: MOVE AND MODIFY THE CALLED ADDRESS
	LIS	R0,0
	STH	R0,DOMATC		:CLEAR TEMPORARY DIGIT/SWITCH AREA
	L	R2,ACTPTR		:GET ACTION ADDRESS FOR CALLED ADDR
	LA	R1,PFXCLD+1		:POINT TO UNMODIFIED CALLED ADDR
	LB	R6,,R2			:GET CONDITION BYTE
	JEFS	MN520			:JUMP, IF NO MODIFICATION TO BE DONE
	RRL	R6,8
	SRA	R6,18			:SIGN EXTEND BIT 7
	JGFS	MN530			:JUMP, TO ADD  DIGITS
MN510	JAL	R9,PFXGDG		:SUBTRACT CALLED ADDR DIGITS
	AIS	R6,1
	JNBS	MN510
MN520	LR	R7,R7			:MOVE REMAINING ADDR TO SECTOR
MN525	JE	MN550
	JAL	R9,PFXGDG		:GET CALLED ADDR DIGIT
	JAL	R9,PFXSDG		:STORE CALLED ADDR DIGIT
	SIS	R7,1
	JBS	MN525
MN530	LR	R1,R2			:POINT TO DIGITS TO ADD
	AIS	R1,1
MN535	JAL	R9,PFXGDG		:GET DIGIT TO ADD TO ADDRESS
	JAL	R9,PFXSDG		:STORE INTO SECTOR
	SIS	R7,1			:DECREMENT NEW ADDRESS LENGTH
	SIS	R6,1			:DECREMENT PREFIX LENGTH BYTE
	JNBS	MN535
	LA	R1,PFXCLD+1		:POINT TO UNMODIFIED CALLED ADDR
	LIS	R0,0E			:RESET GET DIGIT VARIABLES
	RBT	R0,DOMATC
	LR	R7,R7			:MOVE CALLED ADDR TO SECTOR
MN540	JEFS	MN550
	JAL	R9,PFXGDG		:GET CALLED ADDR DIGIT
	JAL	R9,PFXSDG		:STORE CALLED ADDR DIGIT
	SIS	R7,1
	JBS	MN540
:
: MOVE AND MODIFY THE CALLING ADDRESS IN THE SECTOR
MN550	LB	R7,PFXCLL		:GET NEW LENGTH FOR CALLING ADDR
	LA	R1,PFXCLL+1		:POINT TO UNMODIFIED CALLING ADDR
	LIS	R0,0E			:RESET GET DIGIT VARIABLES
	RBT	R0,DOMATC
	L	R2,ACTPTR+4		:GET CALLING ADDR ACTION  ADDRESS
	LB	R6,,R2			:GET THE CONDITION BYTE
	JEFS	MN570			:JUMP, IF NO MODIFICATION TO BE DONE
	RRL	R6,8
	SRA	R6,18			:SIGN EXTEND BIT 7
	JGFS	MN580			:JUMP, TO ADD  DIGITS
MN560	JAL	R9,PFXGDG		:SUBTRACT CALLING ADDR DIGITS
	AIS	R6,1
	JNBS	MN560
MN570	LR	R7,R7			:MOVE REMAINING ADDR TO SECTOR
MN575	JE	MN600
	JAL	R9,PFXGDG		:GET CALLING ADDR DIGIT
	JAL	R9,PFXSDG		:STORE CALLING ADDR DIGIT
	SIS	R7,1
	JBS	MN575
MN580	LR	R1,R2			:POINT TO DIGITS TO ADD
	AIS	R1,1
MN585	JAL	R9,PFXGDG		:GET DIGIT TO ADD TO ADDRESS
	JAL	R9,PFXSDG		:STORE INTO SECTOR
	SIS	R7,1			:DECREMENT NEW ADDRESS LENGTH
	SIS	R6,1			:DECREMENT PREFIX LENGTH BYTE
	JNBS	MN585
	LA	R1,PFXCLL+1		:POINT TO UNMODIFIED CALLING ADDR
	LIS	R0,0E			:RESET GET DIGIT VARIABLES
	RBT	R0,DOMATC
	LR	R7,R7			:MOVE CALLING ADDR TO SECTOR
MN590	JEFS	MN600
	JAL	R9,PFXGDG		:GET CALLING ADDR DIGIT
	JAL	R9,PFXSDG		:STORE CALLING ADDR DIGIT
	SIS	R7,1
	JBS	MN590
MN600	LIS	R4,0F			:ZERO FILL LOWER 4 BITS IF
	TBT	R4,DOMATC		:  ODD NUMBER DIGITS
	JEFS	MN700			:JUMP, IF EVEN DIGITS
	LIS	R0,0
	JAL	R9,PFXSDG
MN700	L	R9,PFXRTN		:GOOD RETURN
	L	R5,PXBADR		:RESTORE POINTER
	LHL	R6,PXBLEN		:RESTORE UPDATED SECTOR LENGTH
	SKIP(0,R9)
MN900	L	R9,PFXRTN		:ERROR OR CLEARING RETURN
	J	4,R9
:
: GET DIGIT ROUTINE FOR PREFIX ADDRESS MODIFICATION
PFXGDG	LIS	R0,0E
:	TBT	R0,DOMATC,,		:GET UPPER NIBBLE DIGIT	:DRE 31-MAY-85
:	JN	PGDG10			:JUMP, IF NO		:DRE 31-MAY-85
	CBT	R0,DOMATC		:FLIP SWITCH (TEST FOR LOWER NIBBLE) :DRE 31-MAY-85
	JNFS	PGDG10			:GO DO LOWER NIBBLE	:DRE 31-MAY-85
	LB	R0,,R1			:GET BYTE FROM ADDR WORK AREA
	AIS	R1,1			:INCREMENT ADDRESS
	STB	R0,DOMATC		:SAVE BYTE
	SRLS	R0,4			:SEND BACK UPPER NIBBLE DIGIT
	JR	R9
PGDG10	:CBT	R0,DOMATC,,		:FLOP SWITCH		:DRE 31-MAY-85
	LB	R0,DOMATC		:GET PREVIOUSLY SAVED BYTE
	NHI	R0,0F			:SEND BACK LOWER NIBBLE DIGIT
	JR	R9
:
: STORE DIGIT ROUTINE FOR PREFIX ADDRESS MODIFICATION IN SECTOR
PFXSDG	LIS	R4,0F
:	TBT	R4,DOMATC,,		:STORE UPPER NIBBLE DIGIT :DRE 31-MAY-85
:	JNFS	PSDG10			:JUMP, IF NO		:DRE 31-MAY-85
	CBT	R4,DOMATC		:FLIP SWITCH (TEST FOR LOWER NIBBLE) :DRE 31-MAY-85
	JNFS	PSDG10			:GO DO LOWER NIBBLE	:DRE 31-MAY-85
	SLLS	R0,4			:MOVE DIGIT TO UPPER NIBBLE
	STB	R0,,R5			:STORE DIGIT IN SECTOR
	JR	R9
PSDG10	:CBT	R4,DOMATC,,		:FLOP SWITCH		:DRE 31-MAY-85
	LB	R4,,R5			:GET BYTE FROM SECTOR
	OR	R0,R4			:COMBINE TWO DIGITS
	STB	R0,,R5			:STORE BACK IN SECTOR
	AIS	R5,1			:INCREMENT SECTOR ADDRESS
	JR	R9

:   PFXGAB, GETS CALLED/CALLING ADDRESSES FROM THE CURRENT SECTOR POINTED
:	TO BY VAR. PXBADR AND PACKET LENGTH FROM PXBLEN AND MOVES THEM INTO
:	WORK AREAS PFXCLD AND PFXCLL. THIS ROUTINE ALSO DETERMINES WHETHER
:	THE PACKET HAS ADDRESSES IN THE FIRST PLACE AND SO INDICATES IN THE
:	DOMATC VAR.
:
PFXGAB	LIS	R2,0
	LIS	R0,0
	STB	R0,PFXCLD		:ZERO CALLED ADDR LENGTH BYTE
	STB	R0,PFXCLL		:ZERO CALLING ADDR LENGTH BYTE
	LIS	R0,1
	STB	R0,DOMATC		:INITIALIZE CALLED MATCH FLAG TO TRUE
	STB	R0,DOMATC+1		:INIT. CALLING MATCH FLAG TO TRUE
	L	R5,PXBADR		:GET SECTOR POIMNTER
	LHL	R6,PXBLEN		:GET REMAINING PACKET LENGTH
	JAL	R4,PICKCH		:GET PACKET ADDRESS LENGTH BYTE
	LR	R7,R0
	NHI	R7,0F
	STB	R7,PFXCLD		:STORE CALLED ADDR LENGTH
	LR	R8,R0
	SRLS	R8,4
	STB	R8,PFXCLL		:STORE CALLING ADDR LENGTH
	LR	R7,R7			:IS CALLED ADDR LENGTH 0?? :DRE 31-JAN-85
	JNFS	GAB10			:JUMP, IF NOT
	LIS	R0,0
	STB	R0,DOMATC		:NO MATCH TO BE DONE
	J	GAB30
GAB10	LIS	R1,1
	SRLS	R7,1			:COMPUTE BYTE COUNT FOR TRANSFER
	JNCFS	GAB20			:JUMP, IF EVEN DIGITS
	AIS	R7,1
	LIS	R2,1			:USE R2 FOR ODD DIGIT FLAG
GAB20	LR	R6,R6			:enough data in sector?  	:HJR 06-24-87
	JE	RTESHT			:clear if packet too short	:HJR 06-24-87
	JAL	R4,PICKCH		:MOVE PACKET CALLED ADDR	:HJR 06-24-87
	STB	R0,PFXCLD,R1		:  FROM SECTOR TO WORK AREA
	AIS	R1,1
	SIS	R7,1
	JNBS	GAB20
	LR	R2,R2			:WAS THEIR AN ODD DIGIT ??	:DRE 31-JAN-85
	JEFS	GAB30			:JUMP, IF NOT
	SLLS	R0,4			:PUT LAST DIGIT IN CALLING ADDR
	STB	R0,PFXCLL+1
:
:   DO THE SAME AS ABOVE FOR CALLING ADDRESS
GAB30	:CLHI	R8,0			:IS CALLING ADDRESS LENGTH 0 ??
	LR	R8,R8			:IS CALLING ADDRESS LENGTH 0 ?? :DRE 31-JAN-85
	JNFS	GAB40			:JUMP, IF NOT
	LIS	R0,0
	STB	R0,DOMATC+1		:DO NOT DO MATCH FOR CALLING ADDR
	JR	R9			:RETURN
GAB40	LIS	R1,1
	SRLS	R8,1			:COMPUTE BYTE COUNT FOR TRANSFER
	JNCFS	GAB50			:JUMP, IF EVEN ADDR LENGTH
	LR	R2,R2			:ALSO CHK CALLED ADDR ODD DIGIT FLAG :DRE 31-JAN-85
	JNFS	GAB45						:SCHEN 11-Jan-85
	AIS	R8,1
GAB45	LR	R8,R8			:SINGLE DIGIT ADDR AND CALL ADDR ODD
	JER	R9			:RETURN, IF YES	:SCHEN 11-Jan-85 :DRE 31-JAN-85
GAB50	LR	R6,R6			:enough data in sector?  	:HJR 06-24-87
	JE	RTESHT			:clear if packet too short	:HJR 06-24-87
	JAL	R4,PICKCH		:MOVE SECTOR CALLING ADDR TO	:HJR 06-24-87
	LR	R2,R2			:   TO CALLING ADDR WORK AREA
	JNFS	GAB60			:FLIP/FLOPS SEMI OCTETS
	STB	R0,PFXCLL,R1
	AIS	R1,1
	SIS	R8,1
	JNBS	GAB50
	JR	R9
GAB60	LB	R3,PFXCLL,R1		:FLIP/FLOP SEMI OCTETS RTN
	LR	R4,R0
	SRLS	R4,4
	OR	R3,R4
	STB	R3,PFXCLL,R1
	SLLS	R0,4
	AIS	R1,1
	STB	R0,PFXCLL,R1
	SIS	R8,1
	JN	GAB50
	JR	R9			:RETURN
GAB70	JR	R9			:RETURN			:SCHEN 11-Jan-85

:   PFXMTC, IS USED TO SEE IF THE ADDRESS POINTED TO IN THE PREFIX TABLE
:	MATCHES ONE OF THE PACKETS ADDRESS. A MATCH EXISTS IF THE BEGINNING
:	ADDRESS PART IN THE PREFIX TABLE EQUALS THE SAME BEGINNING ADDRESS
:	PART IN THE PACKET ADDRESS POINTED TO.
:
:	UPON ENTRANCE,
:	   R0 = MATCH LENGTH (MATCH BYTE)
:	   R1 = POINTS TO EITHER CALLED OR CALLING  WORKAREA
:	   R2 = ADDRESS OF CURRENT MATCH BYTE
:	AT EXIT,
:	   R0 = 0 - FALSE, 1 - TRUE
:
PFXMTC	LIS	R3,0
	SRLS	R0,1			:COMPUTE BYTES TO MATCH
	JNCFS	MTC10			:JUMP, IF EVEN
	AIS	R0,1
	LIS	R3,1			:USE R3 AS ODD DIGIT FLAG
MTC10	LIS	R4,1			:DO BYTE BY BYTE COMPARISON
MTC20	LB	R7,,R1,R4
	LB	R8,,R2,R4
	CR	R7,R8
	JNFS	MTC30
	AIS	R4,1
	SIS	R0,1
	JNBS	MTC20
MTC25	LIS	R0,1			:INDICATE A MATCH
	JR	R9			:RETURN
MTC30	:CLHI	R3,0			:WAS ODD DIGIT FLAG SET ??
	LR	R3,R3			:WAS ODD DIGIT FLAG SET ??	:DRE 31-JAN-85
	JNFS	MTC40			:JUMP, IF YES
MTC35	LIS	R0,0			:INDICATE NO MATCH
	JR	R9			:RETURN
MTC40	SIS	R0,1			:WAS THIS THE LAST BYTE??
	JNBS	MTC35			:JUMP, IF NO
	NHI	R7,0F0
	NHI	R8,0F0
	CR	R7,R8			:RECOMPARE LAST DIGIT
	JE	MTC25
	JBS	MTC35

:   PFXFNA, USED TO LOCATE THE BEGINNING OF THE APPROPRIATE ACTION BYTE IN THE
:	PREFIX TABLE
:
:   UPON ENTRANCE,
:	   R0 = ACTION TO LOCATE, 0 - FALSE, 1 - TRUE
:	   R2 = ADDRESS OF THE MATCH BYTE
:   AT EXIT,
:	   R0 = ADDRESS IN THE PREFIX TABLE OF THE ACTION TO PERFORM
:
PFXFNA	LIS	R8,0
	LB	R1,,R2			:GET MATCH BYTE
	JEFS	FN20			:JUMP, IF NO MATCH STRING
	CLHI	R1,0FF			:TLR/FLR PARAMETER??
	JEFS	FN20
	SRLS	R1,1			:COMPUTE BYTES TO BYPASS IN TABLE
	JNCFS	FN10
	AIS	R1,1
FN10	AR	R8,R1
FN20	AR	R8,R2			:TEMPORARILY SET ACTION ADDRESS
	AIS	R8,1
:	CLHI	R0,0			:IS ACTION DESIRED FALSE ??
	LR	R0,R0			:IS ACTION DESIRED FALSE ??	:DRE 31-JAN-85
:	JEFS	FN30			:JUMP, IF YES			:DRE 31-JAN-85
	JN	FN50			:RETURN				:DRE 31-JAN-85
FN30	LB	R0,,R8			:GET CONDITION BYTE
	JEFS	FN35			:JUMP, IF 0
	THI	R0,0080			:TEST FOR NEGATIVE
	JEFS	FN40			:JUMP, IF POSITIVE
FN35	AIS	R8,1			:ADD 1 TO ACTION ADDRESS
	JFS	FN50			:RETURN
FN40	SRLS	R0,1			:COMPUTE CONDITIONAL MATCH STR LENGTH
	JNCFS	FN45
	AIS	R0,1
FN45	AR	R8,R0
	AIS	R8,1
FN50	LR	R0,R8			:SET ACTION ADDRESS
	JR	R9
  EI

:	PACKET NOT ACCEPTABLE , ERROR ROUTINE JUMP TABLE.

 TABLE(RTDFER)
  TENTRY(RTEREA) :0		P1 - READY
  TENTRY(SNDCLR) :1  P		P3 - SEND INCOMING CALL (CALL REQUEST)
  TENTRY(SNDCLR) :2  A		P3 - WAIT FOR CALL ACCEPT (CALL CONNECTED)
  TENTRY(SNDCLR) :3  C		P2 - MUST SEND CALL CONNNECTED
  TENTRY(RTEDS1) :4  K		P7 - SEND CLEAR INDICATION
  TENTRY(RTEDS1) :5  E		P7 - WAIT FOR CLEAR CONFIRMATION
  TENTRY(SNDCLR) :6  T		P6 - SEND CLEAR CONFIRMATION
  TENTRY(RTEFCR) :7		P4 - FLOW CONTROL READY
  TENTRY(RTESRE) :8  S		D3 - MUST SEND RESET INDICATION
  TENTRY(RTESRE) :9  T		D3 - WAIT FOR RESET CONFIRMATION
  TENTRY(RTERSC) :A  A		D2 - MUST SEND RESET CONFIRMATION
  TENTRY(RTEDS1) :B  T		R3 - SEND RESTART INDICATION
  TENTRY(RTEDS1) :C  E		R3 - WAIT FOR RESTART CONFIRMATION
  TENTRY(SNDRST) :D		R2 - SEND RESTART CONFIRMATION
  TENTRY(SNDRSE) :E		   - PVC BUILD STATE		:DRE 14-APR-86


:	FOR X.75, UNSOLOCITED CLEAR CONFIRMATION IN READY STATE IS
:	THROWN AWAY INSTEAD OF SENDING A CLEAR.
  IF	X.25
RTEREA	J	SNDCLR
  ELSE	X.75
RTEREA	LB	R1,PACKET
	CLHI	R1,YCLRC
	JN	SNDCLR		:IF NOT A CLEAR CONFIRMATION
	J	RTEDS1		:JUST IGNORE
  EI	X.75

:	RECEIVED A PACKET THAT IS UNACCEPTABLE IN FLOW CONTROL
:	READY STATE.  IF A RESET CONFIRMATION, SEND BACK A RESET, ELSE
:	SEND A CLEAR.
RTEFCR	LB	R1,PACKET
	CLHI	R1,YRESTC
	JNFS	SNDCLR			:IF NOT A RESET CONF.
	LA	R12,RSMSG5,,
	LHI	R13,DIA027
	J	SNDRSE			:GO SEND RESET

:	RECEIVED A PACKET ON A LOGICAL CHANNEL THAT IS UNACCEPTABLE
:	IN THE CHANNELS PRESENT STATE.
:	RETURN A CLEAR REQUEST AND ZAP DISPATCHER PORT IF ASSIGNED.
:	(R13)= DIAGNOSTIC CODE TO SEND

SNDCLR	OHI	R13,CLRCAU^8
SNDCL0	JAL	R8,CLEARP		:DO CLEAR PROCESSING
	J	RTD020

:	RECEIVED A PACKET THAT IS UNACCEPTABLE IN SEND RESET CONFIRMATION
:	STATE.  IF IT IS A  CALL ACCEPT OR A CLEAR CONFIRMATION, SEND BACK
:	A CLEAR REQUEST ELSE SEND RESET.

RTERSC	LB	R1,PACKET
	CLHI	R1,YCLRC
	JE	SNDCLR			:IF CLEAR CONF., GO SEND CLEAR
	CLHI	R1,YCALA
	JE	SNDCLR			:IF CALL ACCEPT, GO SEND CLEAR
	J	SNDRSE			:GO SEND RESET


:	RECEIVED AN UN-ACCEPTABLE PACKET IN SEND RESET OR WAITING FOR
:	RESET CONFIRMATION STATE.
:	IF CALL ACCEPT OR CLEAR CONFIRMATION, SEND CLEAR, ELSE
:	IGNORE.
RTESRE	LB	R1,PACKET
	CLHI	R1,YCLRC
	JE	SNDCLR			:IF CLEAR CONFIRMATION, SEND CLEAR
	CLHI	R1,YCALA
	JE	SNDCLR			:IF CALL ACCEPT
	J	RTEDS1			:IGNORE IT

:	RECEIVED A PACKET ON A LOGICAL CHANNEL THAT IS UNACCEPTABLE
:	OR IS NOT LOOKED AT THIS TIME. JUST IGNOR IT.

RTEDSC	ERRPTRACE			:TRACE ILLEGAL PACKET
RTEDS1	LIS	R0,1
	AHM	R0,RTDDSC,RL,RL		:INCREMENT FACT THIS HAPPENED
	J	RTD020

	SSTTL(SUBROUTINES)
::	RTACCP-	SEE IF A PACKET RECEIVED IS ACCEPTABLE AT THE TIME.
:
:	INPUT	(IPORT)
:	LINK IS R4
:	EXIT	NORMAL RETURN IF PACKET TYPE ACCEPTABLE,
:		ELSE EXIT TO APPROPRIATE ERROR ROUTINE

RTACCP	TBT	RL,LEVEL1
	JN	RTEGFI			:IF Q-BIT BIT SET IN NON-DATA PACKET
RACCPT	LB	R2,IPACKT		:GET INTERNAL PACKET EQUIVALENT :DRE 4-JAN-88
	LB	R1,PCKSTE,RL,		:CHECK LINE STATE	:DRE 4-JAN-88
	CLHI	R1,PREADY		:COMPARE WITH READY	:DRE 4-JAN-88
	JEFS	RACCP1			:READY STATE, CONTINUE	:DRE 4-JAN-88
	LR	R7,RL			:SET UP STATE LOOKUP	:DRE 4-JAN-88
	TBT	R2,ACCEPT,R1,R1		:SEE IF ACCEPTABLE FOR LINE STATE :DRE 4-JAN-88
	JEFS	RACCP2			:NOT ACCEPTABLE		:DRE 4-JAN-88
RACCP1	LHL	R7,IPORT		:INTERNAL PORT #
	LB	R1,PCKSTE,R7,		:GET CHANNELS STATE
	TBT	R2,ACCEPT,R1,R1		:SEE IF ACCEPTABLE
	JNR	R4			:IF ACCEPTABLE
RACCP2	LB	R13,DIAGTB,R1,					:DRE 4-JAN-88
	ERRPTRACE			:TRACE ILLEGAL PACKET
	J	RTEDE1			:GO TO ERROR ROUTINES	:DRE 4-JAN-88




::	CLEARP-	DO CLEAR PROCESSING.
:
:	INPUT	(R13)= CLEAR CAUSE/DIAGNOSTIC TO SEND
:		(IPORT), (DPORT) SET
:	USES	R0-R15
:	LINK IS R8

CLEARP	LHL	R7,IPORT
	STH	R13,PSDIAG,R7,R7
	RBT	R7,FIRSTR
	LH	R1,DPORT
	JG	SNDC10			:IF DISPATCHER PORT ASSIGNED
	LB	R1,PCKSTE,R7,		:GET CHANNELS STATE
	CLHI	R1,PSCALC		:SEE IF IN SEND CALL CONF STATE
	JN	SNDC40			:IF NOT

:	PUT CHANNEL IN SEND CLEAR REQUEST STATE BUT DO NOT QUEUE ONE UP.
:	WAIT FOR RESPONSE FROM DISPATCHER ON PSEUDO NEEDLE BEFORE
:	HANGING PORT.
	LHI	R0,PSCLRQ		:GET SEND CLEAR REQUEST STATE
	STB	R0,PCKSTE,R7,
	JR	R8			:RETURN

SNDC10	TBT	R1,DPLOGN		:STILL TALKING TO THE SUP?	:DRE 1-NOV-85
	JN	SNDC30			:YES, DON'T SEND GARBAGE TO SUP	:DRE 1-NOV-85
	TBT	R1,TURKEY
	JE	SNDC20			:IF NOT TRANSPARENT
  IF	X.25				:ALWAYS REPORT REMOTE PROC ERROR :DRE  2-JUN-87
	TURMSG(CLEAR,CREMPE,)		:IF THE DCE INITIATES THE CLEAR :DRE 2-JUN-87
  ELSE	X.75
	TURMSG(CLEAR,CNETCG,)		:ALWAYS REPORT NET CONGESTION :DRE 2-JUN-87
  EI					:IF WE INITIATE THE CLEAR :DRE 2-JUN-87
	J	SNDC30

SNDC20	LR	R7,R1
	LA	R3,CLMSHD,,
	JAL	R6,OUTCDL,,
	LHL	R9,IPORT
	LB	R13,PSDIAG+1,R9,R9	:GET DIAGNOSTIC
	LA	R3,CLMSG1,,		:'UNAUTHORIZED PACKET TYPE..."
	CLHI	R13,DIA032
	JLE	SNDC25			:IF IN ONE OF 'PACKET IN ILLEGAL STATE'
	LB	R13,PSDIAG,R9,R9	:GET CAUSE
	LA	R3,CLMSUC,,		:UNKOWN CAUSE MESSAGE
	CLHI	R13,CLMAX
	JGFS	SNDC25			:IF UNKONW CAUSE (SHOULD NOT BE)
	LH	R3,CLADRS,R13,R13	:GET CORRESPONDING CAUSE MESSAGE
	AI	R3,S.RT
SNDC25	LR	R2,R7
	OUTMSG(,FORCE)
SNDC30	LIS	R0,AA.DBH		:'DROP BY HOST' TERM CODE
	STH	R0,TERMCD
	JAL	R9,DDONE,,		:DO DISPATCHER PORT CLEANUP
SNDC40	JAL	R9,QCR			:QUEUE UP A CLEAR REQUEST
	LIS	R0,1
	AHM	R0,SM.101,RL,RL
	JR	R8			:RETURN


::	FNDONI-	SEARCH ODNIC TABLE FOR MATCH OF DNIC.
:
:	INPUT	(R0)= DNIC TO COMPARE
:	OUTPUT	NORMAL RETURN IF MATCH FOUND, SKIP RETURN IF NOT FOUND
:	USES	R0-R4
:	LINK IS R1

FNDONI	LHI	R4,(ONI.MX-1)*2		:MAX HALFWORDS IN ODNIC TABLE ENTRY
	LR	R3,RL2
	SLLS	R3,ONI.SC		:TABLE START POINTER
FNDO10	CLH	R0,ONI.LT,R3,R4		:COMPARE CALLED DNIC TO ODNIC
	SKIPEQ(0,R1)			:IF OUR DNIC
	SIS	R4,2
	JGEBS	FNDO10			:IF MORE TO CHECK
	J	4,R1			:FAILURE TO FIND DNIC

 IF LIIFLAG							:HJR-SWBT1
:- BEGIN -----------------------------------------------------  :HJR-SWBT1
::	CCAC - CHECK CALLED ADDRESS IN CALL ACCEPTED OR CALL CLEARED PACKET
::	LOG-II VERSION
:
:	INPUT	REGISTER SET UP FOR PICKCH
:	OUTPUT	(R0) = 0 IF BOTH ADDRESSES MATCHES ORIGINAL VALUES
:		(R0) = 1 IF NO CALLED MATCH
:		(R0) = 2 IF NO CALLING MATCH
:		(R0) = -1 IF FORMAT ERROR (R12)
:		IF (R0) <> 0 THEN R12 CONTAINS THE DIAGNOSTIC
:	USES	R0,R2-R9,R12-R14 - TEMP5, TEMP8-9, PFXCLD, PFXCLL
:	LINK	R7
:	CALLS	VALADR

ccac	jal	R4,pickch		:get addr lengths
	lr	R8,R0			:save addr lengths
	jer	R7			:if nothing to do (R0 = 0)
	st	R7,temp9		:save return
	lis	R9,0
	st	R9,temp5		:clear for use by VALADR
	st	R9,pfxcld
	nhi	R0,0F			:extract called addr len
	st	R0,pfxcld+4
	st	R9,pfxcll
	srhls	R8,4			:extract calling addr len
	st	R8,pfxcll+4

: Move addresses
	lhi	R12,dia067		:set called addr error
	li	R13,dtesdv		:get pntr to called addr DNIC array
	li	R8,pfxcld		:get pntr to called addr save
	lis	R3,0			:set for VALADR
	jal	R7,valadr		:move address
	skipad(ccac52)			:format error return
	
	lhi	R12,dia068		:set calling addr error
	lis	R7,0F			:clear VALADR "store digit flag"
	rbt	R7,temp5
	li	R13,dtesdx
	li	R8,pfxcll		:get pntr to calling addr save
	lis	R3,0			:set for VALADR
	jal	R7,valadr		:move address
	skipad(ccac52)			:format error return

: Check calling addr - mismatch is always an error.
	tbt	RL,ckrclg,,		:check calling?
	jefs	ccac20			:if not
	li	R8,dtesax		:get addr pointers
	li	R9,pfxcll
	jal	R3,ccac80
	jefs	ccac20			:good return
	ais	R0,1			:calling mismatch return
	j	ccac51

: Check called addr last - mismatch might not be an error.
ccac20	tbt	RL,ckrcld,,		:check called?
	jefs	ccac50
	lhi	R12,dia067		:set called addr error
	li	R8,dtesav		:get addr pointers
	li	R9,pfxcld
	jal	R3,ccac80
	jgfs	ccac51			:called mismatch return

ccac50	lis	R0,0			:good return
ccac51	l	R7,temp9		:restore return addr
	lr	R0,R0			:set condition code
	jr	R7
ccac52	lcs	R0,1			:format error return
	jbs	ccac51

: * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
: Enter:	R8 = pntr to original addr array (DTESAV or DTESAX)
:		R9 = pntr to response address (PFXCLD or PFXCLL)
: Link:		R3
: Exit:		R0 = 0 if match, 1 if no match
: Uses:		R0,R3,R7-R9
ccac80	lhl	R7,iport		:indexed by iport
	slls	R7,3			:make dblword index
	ar	R8,R7			:add into array pointer
	l	R0,0,R9			:compare addrs
	c	R0,0,R8
	jnfs	ccac85			:mismatch exit
	l	R0,4,R9
	c	R0,4,R8
	jnfs	ccac85			:mismatch exit
	lis	R0,0
	jr	R3

ccac85	lis	R0,1
	jr	R3
:-- END ------------------------------------------------------  :HJR-SWBT1
 ELSE :LIIFLAG							:HJR-SWBT1
::	CCAC - CHECK CALLED ADDRESS IN CALL ACCEPTED OR CALL CLEARED PACKET
:
:	INPUT	REGISTER SET UP FOR PICKCH
:	OUTPUT	(R0) = 0 IF CALLED ADDRESS MATCHES ORIGINAL VALUE
:		(R0) = 1 IF NO MATCH
:		(R0) = -1 IF FORMAT ERROR (R12) CONTAINS THE DIAGNOSTIC
:	USES	R0,R3,R4,R5,R6,R8,R9,R12
:	LINK	R7

CCAC	JAL	R4,PICKCH		:GET DTE ADDRESS LENGTHS
	LR	R8,R0
	NHI	R8,0F
	SRLS	R0,4
	LR	R9,R0			:SAVE CALLING DTE ADDRESS LENGTH

	RBT	RL,TEMP4		:CLEAR CALLED ADDRESS ERROR :DRE 10-FEB-87
	LHI	R12,DIA038		:PACKET TOO SHORT CHECKED FOR HERE :DRE 10-FEB-87:DRE 4-JAN-88E
	LR	R8,R8
	JE	CCAC60			:IF NO CALLED ADDRESS
	LB	R4,CDL.LT,RL,		:CALLED ADR LENGTH TO CHECK (LINK OPTION)
	JE	CCAC50			:IF CALLED ADR NOT TO BE CHECKED
	LH	R3,IPORT

:	CALC MIN OF CALLED ADR LEN IN CALL REQ AND DEFAULT
	STB	R8,TEMP1		:SAVE CALLED ADDR LENGTH
	LR	R8,R4			:"DEFAULT" CALLED ADR LENGTH TO CHECK
	SLLS	R3,3			:INDEX INTO CALL REQ CLD ADR ARRAY
	CLB	R8,DTESAV+7,R3,					:HJR-SWBT1
	JLEFS	CCAC15			:IF DEFAULT CALLED ADDR LEN IS SMALLER
	LB	R8,DTESAV+7,R3,					:HJR-SWBT1
CCAC15	STB	R8,TEMP2		:MIN [DEFAULT, CLD ADR LEN IN CALL REQ]
	CLB	R8,TEMP1
	JLEFS	CCAC20			:IF CALLED ADDR IS OK	:HJR-SWBT1
	SBT	RL,TEMP4		:SET CALLED ADDRESS ERROR :DRE 10-FEB-87
	LB	R8,TEMP1		:IF CALLED ADDR IS TOO SHORT
CCAC20	LR	R6,R6
	JE	CCAC95			:CLEAR CALL IF OUT OF DATA
	JAL	R4,PICKCH
	SIS	R8,1
	JE	CCAC70			:ODD CALLED ADDRESS LENGTH
	CLB	R0,DTESAV,R3,
	JEFS	CCAC40			:CONTINUE IF DIGITS MATCH :DRE 10-FEB-87
					:IF DIGIT(S) DON'T MATCH THOSE IN CALL REQ
	SBT	RL,TEMP4		:SET CALLED ADDRESS ERROR :DRE 10-FEB-87
CCAC40	AIS	R3,1
	SIS	R8,1
	JG	CCAC20			:IF MORE CALLED ADDR DIGITS TO CHECK
	LB	R8,TEMP1
	LB	R4,TEMP2
	SR	R8,R4			:CALC CLD ADR LEN - CHECKABLE DIGITS :DRE 9-JUN-87
	JLEFS	CCAC60			:IF NOTHING LEFT IN CLD ADR :DRE 9-JUN-87
CCAC50	LR	R6,R6						:DRE 10-FEB-87
	JE	CCAC95			:CLEAR CALL IF OUT OF DATA
	JAL	R4,PICKCH		:DON'T CHECK REST OF CALLED ADDR
	SIS	R8,1
	JE	CCAC77			:IF IGNORING 1 DIGIT
	SIS	R8,1
	JGBS	CCAC50			:IF IGNORING MORE THAN 2 DIGITS

:	EVEN CALLING ADDRESS LEN
CCAC60	LR	R8,R9			:GET CALLING ADDRESS LENGTH
	JE	CCAC90			:IF LENGTH 0
	J	CCAC80

CCAC70	NHI	R0,0F0
	LB	R4,DTESAV,R3,
	NHI	R4,0F0			:ONLY LOOK AT SINGLE DI	:  HAS BOTH M AND Q.  TURN IT OFF.
	RBT	R3,NX3YET		:FLAG INDICATING "HAVN'T SEEN INTL X.3 PARM"
					: TURN IT OFF.
	RBT	R3,DFLUSH		:TURN OFF DISPATCHER FLUSH MODE
	RBT	R3,RFLINT
	RBT	R3,INPROG
CNR010	LIS	R2,0
	STB	R2,PPS,R7,		:ZERO OUT P(R) AND P(S) TERMS
	STB	R2,PPR,R7,
	STB	R2,TPPR,R7,
	STB	R2,LRPR,R7,
	STB	R2,LTPR,R7,

	RBT	R7,WINROT
	RBT	R7,WINROX
	RBT	R7,FLINT		:RESET FLAG SAYING INTERRUPT OUT
	RBT	R7,IBKPR		:RESET INPUT BACKPRESSURE FLAG
	RBT	R7,OBKPR		:RESET OUTPUT BACKPRESSURED FLAG
	RBT	R7,FLINTC
	RBT	R7,LSTQBT
	RBT	R7,LSTMBT
	RBT	R7,IFLUSH		:TURN OFF FLUSH MODE
	RBT	R7,FLRR
	RBT	R7,FLREJ,,		:JS 12-R	R6,R6
	JE	CCAC95
	JAL	R4,PICKCH
	SIS	R8,1
	JEFS	CCAC90
	SIS	R8,1
	JNBS	CCAC80

CCAC90	TBT	RL,TEMP4		:DID WE ENCOUNTER ERROR?
	JNFS	CCAC92			:YES, FLAG ERROR
	LIS	R0,0			:SET FLAG FOR FINISH
	JR	R7			:RETURN

CCAC92	LIS	R0,1			:SET ERROR FLAG
	JR	R7

CCAC95	LCS	R0,1			:SET ERROR FLAG
	JR	R7
 EI :LIIFLAG							:HJR-SWBT1

::	CNR-	DO CLEAN-UP NECESSARY FOR RESET OF A CHANNEL.
:
:	INPUT	(R0)=ZRESET OR ZRESCN OR 0 IF NEITHER
:	USES	R0-4,R7,R9
:	LINK IS R9


CNR	LHL	R7,IPORT
	LH	R3,ID.MT,R7,R7		:GET DISPATCHER PORT
	STH	R3,DPORT
	JLEFS	CNR010
	RBT	R3,LASTMQ		:FLAG INDICATING LAST ESCAPE DATA (94) MSG
				  jBE  X`3  j2>  jB  jB@    
x 
N{~	X  I`  @     p             >O0 ($@ (-P (m0 (d@ <A0 1i  $,  (!@ (!  (!  '"       '"  + ($@ (-P (!  (!  (d@ )GP 1i       '"  (d@      )b` 1i  + ($@ (-P (!  (!  (!@      	` (d@ )GP %`0 *&0  @     jB  jB  jBm  ZB  J   v@      0   	
'b @H    
'b @da+%!H        J   t    <    =Lz    @     j2#  X
Y  [J  jB$  jBm  jB  jF$@     j4  j2#  j:  jN  Z"`  jB  jB  ZB  jBE  [J  X
Y  jL=  X`3  jR3%I." @H     1Jg    @     j:  jBE  X
Y  jB  Z"`  ZB@     jB  X
Y  jB  Z8"  
,$b     !$SEP-86
	RBT	R7,FLFLOW
	RBT	R7,FLRNR
	LH	R1,DPORT
	JLEFS	CNR020			:IF NO DPORT, BYPASS DPORT RELATED CODE
	SLLS	R1,2
	AHI	R1,DIBIA
	JAL	R4,EMPTY,,
	LHL	R1,DPORT
	SLLS	R1,2
	AHI	R1,IDBIA
	JAL	R4,EMPTY,,
CNR020	LR	R1,R7
	SLLS	R1,2
	AHI	R1,IEDBIA
	JAL	R4,EMPTY,,
	LR	R1,R7
	SLLS	R1,2
	AHI	R1,IECBIA
	JAL	R4,EMPTY,,
	LR	R0,R0
	JER	R9			:IF NOT TO SEND RESET OR CONF.
	JAL	R4,WCI,,
	CHI	R0,ZRESET		:CHECK RESET PACKET	:SCHEN 7-Jan-86
	JNR	R9			:IF NO			:HJR 12-9-86 #1
	LHL	R1,IPORT					:HJR 12-9-86 #1
	LB	R13,PSDIAG,R1,R1				:SCHEN 7-Jan-86
	JEFS	CNR030			:0 = DTE ORIGINATED	:HJR 12-9-86 #1
	THI	R13,80						:HJR 12-9-86 #1
	JGEFS	CNR030			:IF DTE CLEAR		:HJR 12-9-86 #1
	CHI	R13,RREMPE					:SCHEN 7-Jan-86
	JEFS	CNR030			:IF REMOTE PROCED ERROR :HJR 12-9-86 #1
	CHI	R13,RLOCPE		:LOCAL PROCEDURE ERROR?	:SCHEN 7-Jan-86
	JNR	R9			:RETURN IF NOT		:HJR 12-9-86 #1
CNR030	JAL	R4,COP1S1,,		:UPDATE OUTPUT PACKET COUNT:LSH 14-JUL-87
	JR	R9


::	CPR-	CHECK AND VALIDATE P(R) VALUE.
:
:	INPUT	(R8)= P(R) TO BE CHECKED
:		(R7)= IPORT
:	OUTPUT	SKIP RETURN IF P(R) OK
:		NORMAL RETURN IF P(R) INVALID
:	USES	R0,R2,R3,R4,R7,R8,R9
:	LINK IS R9

CPR	LR	R4,R8			:SAVE A COPY OF P(R)
	LB	R2,PPS,R7,
	LB	R0,LRPR,R7,
	LR	R3,R2
	SR	R2,R0			:CALCULATE  P(S)-LRPR
	NH	R2,PMMSK
	SR	R3,R8			:CALCULATE  P(S)-P(R)
	NH	R3,PMMSK
	CLR	R2,R3
	SKIPLT(0,R9)			:RESET CALL, P(R) IS NOT IN WINDOW
	CLB	R3,PWTMT,R7,
	SKIPGT(0,R9)			:IF GREATER THEN ERROR, RESET CHANNEL
	STB	R4,LRPR,R7,		:UPDATE LRPR
	J	4,R9			:RETURN


::	PTMPCH- GET A CHAR FROM RING AND PUT IT IN TEMPORARY BUFFER. :DRE 22-MAY-86
:
:	INPUT	R5-> NEXT CHAR IN RTD RING
:		(R6)=REMAINING CHAR COUNT IN RING
:	USES	R0-6,13
:	LINK IS R13

PTMPCH	LHI	R1,TMPBF1					:DRE 22-MAY-86
	JFS	PACKC0						:DRE 22-MAY-86

::	PACKCH- GET A CHAR FROM RING AND PUT IT IN FACILITIES BUFFER.
:
:	INPUT	R5-> NEXT CHAR IN RTD RING
:		(R6)=REMAINING CHAR COUNT IN RING
:	USES	R0-6,13
:	LINK IS R13

PACKCH	LHL	R1,FACBUF
PACKC0	LB	R0,,R5			:GET CHAR
	AIS	R5,1			:UPDATE POINTER
	SIS	R6,1
	JLFS	PAKCHB			:IF TRIED TO GET DATA THAT WAS NOT THERE
	JAL	R4,WCI,,			:PUT CHAR IN BUFFER
	JR	R13

PAKCHB	TRAP(R5,FA)			:TRIED TO GET DATA FROM EMPTY RTD RING



::	QCC-	QUEUE UP A CLEAR CONFIRCATION ON A CHANNEL.
:		(EMPTY CONTROL BUFFER FIRST)
:
:	INPUT	(IPORT)
:	LINK IS R9

QCC	LHL	R1,IPORT
	LHI	R0,PSCLRC		:GET SEND CLEAR CONF STATE
	STB	R0,PCKSTE,R1,		:STORE NEW STATE
	SLLS	R1,2
	AHI	R1,IECBIA
	JAL	R4,EMPTY,,
	LHI	R0,ZCLRCN		:GET CLEAR CONFIRMATION
	JAL	R4,WCI,,
	JR	R9


::	QCR-	QUEUE UP A CLEAR REQUEST ON A CHANNEL.
:		(EMPTY CONTROL BUFFER FIRST)
:
:	INPUT	(IPORT)
:	LINK IS R9

QCR	LHL	R1,IPORT
	LHI	R0,PSCLRQ		:GET SEND CLEAR REQUEST STATE
	STB	R0,PCKSTE,R1,		:SAVE NEW STATE
	SLLS	R1,2
	AHI	R1,IECBIA
:	JAL	R4,EMPTY,,		:EMPTY BUFFER FIRST:JS 25-MAR-88
	LHI	R0,ZCLRQ		:GET CLEAR REQUEST
	JAL	R4,WCI,,
	JR	R9


::	RESETP-	RESET PROCESSING.
:
:	INPUT	(R13)= RESET DIAGNOSTIC TO SEND
:		(R12)= MESSAGE TO SEND
:		(IPORT), (DPORT) SET
:	USES	R0-R13
:	LINK IS R8

RESETP	LHL	R7,IPORT
	STH	R13,PSDIAG,R7,R7
	LB	R1,PCKSTE,R7,
	LIS	R0,0			:SET TO NOT SENDING RESET REQUEST
	CLHI	R1,PSRESI
	JE	SNDR20			:IF ALREADY SENT OUT A RESET
	CLHI	R1,PSRESC
	JE	SNDR20			:IF IN SEND RESET CONFIRMATION STATE
	LIS	R0,1
	AHM	R0,SM.102,RL,RL
  IF	PVC
	CLHI	R1,PWPVCR		:ARE WE IN PVC BUILD STATE ??
	JEFS	SNDR10			:YES, JUMP AROUND
  EI	PVC
	LIS	R2,PSRESI		:GET SEND RESET INDICATION STATE
	STB	R2,PCKSTE,R7,
SNDR10	LIS	R0,ZRESET		:GET RESET INDICATION PACKET TYPE
SNDR20	JAL	R9,CNR			:GO DO CLEANUP NECESSARY FOR RESET
	LHL	R1,IPORT
	SBT	R1,IFLUSH
  IF	PVC
	LIS	R2,PWPVCR					:DRE 6-FEB-86
	CLB	R2,PCKSTE,R1,		:ARE WE IN PVC BUILDING STATE :DRE 6-FEB-86
	JER	R8			:YES, DONT SEND GOBBLER BECAUSE IT WILL :DRE 6-FEB-86
					:INTERFERE WITH THE PVC SETUP MESSAGES  :DRE 6-FEB-86
	LHL	R2,EPORT
	TBT	R2,PVCOUT		:IS OTHER DTE 'DOWN' ??
	JNR	R8			:YES, RETURN
  EI	PVC
	LH	R2,DPORT
	JLER	R8			:IF DISPATCHER PORT NOT ASSIGNED
	TBT	R2,DPLOGN		:STILL TRYING TO LOGIN?		:DRE 1-NOV-85
	JNR	R8			:YES, DON'T SENT THIS GARBAGE TO THE SUP	:DRE 1-NOV-85
	SBT	R2,DFLUSH
	CTLMSG(GOB,RX3)			:SEND A GOBBLER TO THE NETWORK
	LHL	R2,DPORT
	TBT	R2,TURKEY
	JN	SNDR40			:IF  TALKING TURKEY DIALECT
	TBT	R7,EXTCAL
	JN	SNDR30			:NO NEED TO SEND MESSAGE TO HOST
	LA	R3,RSMSHD,,
	LR	R7,R2
	JAL	R6,OUTCDL,,
	LR	R3,R12			:GET MESSAGE TO SEND
	LR	R2,R7
	OUTMSG(,FORCE)
SNDR30	CTLMSG(YB,RX3)			:SEND A YELLOW BALL
	JR	R8

:	SEND THIS RESET IN ESCAPED FORMAT TO OTHER END.
SNDR40	LHL	R2,IPORT
	LIS	R3,RLOCPE
	CLB	R3,PSDIAG,R2,R2		:COMPARE CAUSE BYTE
	JN	SNDR50			:IF NOT 'LOCAL PROC ERROR'
  IF	X.25
	TURMSG(RESET,RREMPE)		:USE 'REMOTE PROC ERROR' CAUSE INSTEAD
  ELSE	X.75
	TURMSG(RESET,RNETCG)		:USE 'NETWORK CONGESTION' CAUSE INSTEAD
  EI
	JR	R8			:RETURN

SNDR50	TURMSG(RESET)
	JR	R8			:RETURN


::	CPSR -	CHECK PACKET SIZE IN CALL REQUEST, AND CONVERT FROM LOG2
:		TO ACTUAL VALUE.
:		IF GREATER THAN THE CONFIGURED MAXIMUM PACKET
:		SIZE (MST.LT, MSR.LT), NEGOTIATE DOWN TO MAX PACKET SIZE.
:
:	INPUT	R0 PACKET SIZE IN LOG 2
:		(R2)= 0 IF TMT PS, =1 IF RCV PS
:	OUTPUT	(R4)= ACTUAL PACKET SIZE VALUE
:	USES	R0,R2,R4,R8,R12
:	EXIT	NORMAL RETURN  IF VALUE INVALID
:		ELSE SKIP RETURN
:		(R12) SET TO PROPER DIAGNOSTIC CODE IF NORMAL RETURN
:	LINK IS R8

PSMAX	EQ	$A12			:MAX OF PACKET SIZE 4096
PSMIN	EQ	4			:MINIMUM OF PACKET SIZE 16

CPSR	LHI	R12,DIA066		:'INVALID PARAMETER VALUE' :GLEE 9-Jul-84
	CLHI	R0,PSMAX					:GLEE 9-Jul-84
	SKIPGT(0,R8)			:IF GREATER THAN MAX	:DAVE 16-Sept-87
	CLHI	R0,PSMIN					:GLEE 9-Jul-84
	SKIPLT(0,R8) 			:IF LESS THAN MIN	:DAVE 16-Sept-87
	LR	R3,R0						:GLEE 9-Jul-84
	POWER2(R3,R4)			:CONVER TO ACTUAL PACKET SIZE :GLEE 9-Jul-84
	LHL	R3,MST.LT,RL,RL		:XMT MAX PS		:GLEE 9-Jul-84
	LR	R2,R2						:GLEE 9-Jul-84
	JEFS	CPSR10			:IF PROCESSING XMT PS	:GLEE 9-Jul-84
	LHL	R3,MSR.LT,RL,RL		:GET RCV MAX PS		:GLEE 9-Jul-84
CPSR10	CR	R4,R3						:GLEE 9-Jul-84
	JLEFS	CPSR20			:IF WE CAN HANDLE IT	:GLEE 9-Jul-84
	LR	R4,R3			:NEGOTIATE DOWN TO MAX PS :GLEE 9-Jul-84
CPSR20	J	4,R8			:SKIP RETURN		:DAVE 16-Sept-87

::	CPSA -	CHECK PACKET SIZE IN CALL ACCEPT, AND CONVERT FROM LOG2
:		TO ACTUAL VALUE.
:		MAKE SURE IT IS NOT GREATER THAN THE CONFIGURED MAXIMUM PACKET
:		SIZE. (MST.LT, MSR.LT)
:
:	INPUT	R0 PACKET SIZE IN LOG 2
:		(R2)= 0 IF TMT PS, =1 IF RCV PS
:	OUTPUT	(R4)= ACTUAL PACKET SIZE VALUE
:	USES	R0,R2,R4,R8,R12
:	EXIT	NORMAL RETURN  IF VALUE INVALID OR GREATER THAN MAX FRAME SIZE
:		ELSE SKIP RETURN
:		(R12) SET TO PROPER DIAGNOSTIC CODE IF NORMAL RETURN
:	LINK IS R8

CPSA	LHI	R12,DIA066		:'INVALID PARAMETER VALUE'	:GLEE 9-Jul-84
	CLHI	R0,PSMAX
	SKIPGT(0,R8)			:IF GREATER THAN MAX
	CLHI	R0,PSMIN
	SKIPLT(0,R8)			:IF LESS THAN MIN
	LR	R3,R0
	POWER2(R3,R4)			:CONVER TO ACTUAL PACKET SIZE
	LHL	R3,MST.LT,RL,RL		:XMT MAX PS
	LR	R2,R2
	JEFS	CPSA10			:IF PROCESSING XMT PS		:GLEE 9-Jul-84
	LHL	R3,MSR.LT,RL,RL		:GET RCV MAX PS
CPSA10	CR	R4,R3						:GLEE 9-Jul-84
	SKIPGT(0,R8)			:ERROR RETURN WHEN > MAX PS CONFIGURED
	J	4,R8			:SKIP RETURN

::	CWS -	CHECK PACKET WINDOW SIZE
:
:	INPUT	R0=PACKET WINDOW PARAMETER TO BE CHECKED
:	OUTPUT	R0 UNCHANGED
:	NORMAL RETURN IF VALUE INVALID
:		ELSE, SKIP RETURN
:	USES	R0,R4,R8,R12
:	LINK IS R8

MAXWS	EQ	$a127			:MAX WINDOW SIZE

CWS	LHI	R12,DIA066		:FACILITY PARAMETER NOT ALLOWED'
	LR	R0,R0
	SKIPEQ(0,R8)			:IF ZERO
	CLHI	R0,MAXWS
	SKIPGT(0,R8)			:CLEAR CALL IF GREATER THAN MAX
	TBT	RL,P128.F
	JNFS	CWS10			:IF PACKET MODE 128
	CLHI	R0,7
	SKIPGT(0,R8)			:VALUE TOO LARGE FOR MOD 8
CWS10	J	4,R8			:VALUE ACCEPTABLE


::	ESCDTA-	FINISH OFF ESCAPED MESSAGE.
:		COPY DATA FROM RTD BUFFER TO DISPATCHER.
:		BREAK UP DATA INTO ISIS MESSAGE LENGTH
:
:	INPUT	(R6)= NO. OF CHARS IN THE STARTING ESCPD MESSAGE FOLLOWING THE
:			LENGTH FIELD
:		(R8)= REMAINING CHARS TO PUT OUT (.LE. 0 IF THE ESCPD MSG CAN
:			FIT IN ONE ISIS MSG)
:		R5-> BEGINNING OF DATA IN RTD BUFFER
:		*ESCAPN* ALREADY CALLED AND LENGTH FIELD PUT IN
:	USES	R0-R9,R12,R13,R15				:HJR-SWBT1
:	CALLS	PICKCH,BPUTCH,ESCAPN
:	LINK IS R7
:- BEGIN -----------------------------------------------------	:HJR-SWBT1
::	ESCDTB - SAME AS ESCDTA EXCEPT GETS DATA FROM BUFFER
:		R5 CONTAINS THE BUFFER POINTER
:
ESCDTA	LIS	R12,0		:MARK - GET DATA FROM SECTOR
	J	ESCD06

ESCDTB	LIS	R12,1
	J	ESCD06

ESCD00	LR	R12,R12			:SECTOR OR TMPBF3?
	JNFS	ESCD01			:SKIP IF TMPBF3
	LB	R0,,R5			:GET CHAR FROM RTD BUFFER
	AIS	R5,1			:UPDATE POINTER
	JFS	ESCD02
ESCD01	LR	R1,R5			:RESTORE BUFFER POINTER
	JAL	R4,GCI			:GET CHARACTER
ESCD02	SIS	R6,1			:DECREMENT COUNTER
:-- END ------------------------------------------------------	:HJR-SWBT1
	JEFS	ESCD04			:IF THIS WAS LAST ONE
	JAL	R4,BPUTCH,,		:PUT IT INTO OUTPUT RING
	JBS	ESCD00			:GO AGAIN

ESCD04	JAL	R4,BPUTCH,,
ESCD06	LR	R6,R6						:HJR-SWBT1
	JN	ESCD00			:IF MORE TO GO		:HJR-SWBT1
	LR	R6,R8			:GET REMAINING CHARS
	JGFS	ESCD10			:IF NOT DONE WITH THIS PACKET
	JAL	R9,ESCAPX,,		:TERMINATE MESSAGE
	JR	R7			:RETURN

ESCD10	JAL	R4,BELOR,,
	LR	R0,R6
	SHI	R6,CM.FST-1
	JLEFS	ESCD20			:IF WILL FIT IN ONE MSG
	LHI	R0,CM.FST-1		:TAKE MAX
ESCD20	LR	R8,R6			:SAVE REMAINING CHARS
	LR	R6,R0			:NO. OF CHARS TO PUT OUT
	LR	R2,R0
	AIS	R0,3
	LHL	R1,DPORT
	JAL	R4,BSLOR,,		:START OFF MESSAGE
	J	ESCD00			:GO COPY MORE


::	GETCSI-	DERIVE A TYMNET CIRCUIT SPEED INDICATOR VALUE FROM THROUGHPUT
:		CLASS.
:
:	OUTPUT	(R0)= CIRCUIT SPEED INDICATOR
:	USES	R0-4,R9
:	LINK IS R12

GETCSI	LHL	R2,IPORT
	LB	R3,TCLTR,R2,		:GET THROUGHPUT CLASS
	LR	R4,R3
	SRHLS	R4,4			:TMT = FROM CALLED VALUE
	NHI	R3,0F			:RCV = FROM CALLING VALUE
	CR	R3,R4
	JGEFS	GETC10			:IF RCV TC IS LARGER
	LR	R3,R4			:USE TMT TC
GETC10	LR	R4,RL
	SLLS	R4,TCT.SC
	LB	R0,TCT.LT,R3,R4		:GET CORRESPONDING CIRCUIT SPEED
	JR	R12			:RETURN

 IF	PVC
:	GETCSP- SAME AS GETCSI EXCEPT FOR PVC 'S
:
:	REGISTER USAGE THE SAME AS GETCSI PLUS ON INPUT
:		R6 = CHANNEL POINTER INTO PVCTAB
GETCSP	LHL	R3,PVCLNK,RL,RL		:LINK POINTER INTO PVCTAB
	LB	R0,PVCTAB+PV.TCT,R6,R3	:GET TRANSMITTED THROUGHPUT CLASS
	CLB	R0,PVCTAB+PV.TCR,R6,R3	:COMPARE TO RECEIVED THROUGHPUT CLASS
	JGEFS	GETC15			:USE TRANSMITTED THROUGHPUT CLASS
	LB	R0,PVCTAB+PV.TCR,R6,R3	:USE RECEIVED THROUGHPUT CLASS
GETC15	LR	R3,R0
	LB	R3,TCLTID,R3,		:GET TID FOR THIS TCLASS
	STB	R3,SAVTID		:SAVE FOR P. NDL REQUEST
	LR	R3,R0
	J	GETC10
 EI

:- BEGIN -----------------------------------------------------  :HJR-SWBT1
:***********************************************************************
:
::  BCAESC - Begin Call Accept ESCape
:	Begin escaped message data buffer for call accept or clear data
:	IIX message in TMPBF3.  The packet address field is put into
:	the buffer.  If a CLAMN is to be inserted then the addresses in
:	DTESAX and DTESAV are put in the buffer instead of those in the
:	packet.  For X.25, 0 length utility field and facility fields
:	are added.  For X.75, only a 0 length utility field is added.
:	Upon exit, FACPTR points to the utility length field for X.75
:	and to the facility length field for X.25.
:
:	NOTE: Also checks for packet too short if addresses are present.
:
:	ENTRY -	R5,R6 point to address length field
:
:	LINK -	R7
:
:	USES -	R0-R9,R12,R13,TEMP(CRQADR),TEMP0,TEMP8,TEMP9
:
:	CALLS -	EMPTY, PICKCH, WCI, CRQADR
:
:	EXIT -	FACPTR = pointer to facility length field for X.25, to
:			 the utility length field for X.75.  This will be
:			 0 if the tmpbf3 is empty.
:		TMPBF3 set up with start of IIX message data
:		R1 = TMPBF3 index
:		R5,R6 unchanged
:		R12 = 0
:		Condition Codes = 0 (EQ)
:
:	ERROR EXIT -	R12 = Diagnostic code
:			Condition Codes <> 0 (NE)
:
BCAESC	lhi	R1,tmpbf3		:first empty buffer
	jal	R4,empty,,
	st	R5,temp8		:save sector pointer
	sth	R6,temp0		: and offset

 if LIIFLAG&X.25
	lhl	R9,iport
	lb	R0,calrdr,R9,		:put in CLAMN?
	je	bcaes3			:skip if not
	st	R7,temp9		:save return
	li	R5,dtesax		:get address pointers
	li	R6,dtesav
  if IDNPFX
	li	R8,dtesdx		:get DNIC indication pointers
	li	R9,dtesdv
  ei :IDNPFX
	jal	R13,crqadr,,		:put in addresses

	lis	R0,0			:put in dummy util for X.25
	jal	R4,wci
	lis	R0,2			:and placeholder facility length
	jal	R4,wci			
	l	R0,be,R1,		:get facil length field pointer
	st	R0,facptr		: and save
	lhi	R0,fc.cla		:and put in CLAMN facility
	jal	R4,wci
	lhl	R9,iport
	lb	R0,calrdr,R9,
	jal	R4,wci
	l	R7,temp9		:restore return address
	j	bcaes9			:go finish up
 ei :LIIFLAG&X.25

bcaes3	lr	R0,R6			:anything left in sector?
	jnfs	bcaes4			:if yes, go move
	jal	R4,wci			:else put in 0 address field
	j	bcaes7			:and go finish up

bcaes4	jal	R13,packc0		:move addr lengths to buffer
	lr	R8,R0			:copy length nibbles
	je	bcaes7			:skip if empty
	nhi	R8,0F			:else get byte len of addrs
	srhls	R0,4
	ar	R8,R0
	ais	R8,1
	srhls	R8,1
	lhl	R12,dia038		:set up for packet too short error
	cr	R8,R6			:packet all there?
	jgr	R7			:if not, take error exit - CC <>
bcaes5	jal	R13,packc0		:move bytes
	sis	R8,1
	jgbs	bcaes5
	lis	R0,0

bcaes7		:NOTE - must get here with 0 in R0
 if X.25
	jal	R4,wci			:for X.25, put in 0 util field
 ei :X.25
	jal	R4,wci			:put in 0 util or facil field
	l	R0,be,R1,		:get util/facil length field pointer
	st	R0,facptr		: and save

bcaes9	l	R5,temp8		:restore R5,R6
	lhl	R6,temp0
	lis	R12,0			:set CC =
	jr	R7			:return

:***********************************************************************

:***********************************************************************
:
::  MCAESC - Make Call Accept ESCape message
:	Make call accept or clear data IIX message using contents of
:	TMPBF3, which contains the message ID and the packet info to
:	be sent.
:
:	If old style call accept message (EXMF), use 1 byte count field,
:	else use 2 byte count field.
:
:	ENTRY -	R12 = message type
:		TMPBF3 = IIX message ID and packet info.
:
:	LINK -	R14
:
:	USES -	R0-R9,R12,R14
:
:	CALLS -	ESCDTB
:
MCAESC
 IF LIIFLAG&X.25
	LHL	R1,IPORT		:CLEAR CALRDR, DON'T RETURN TWICE
	LIS	R0,0			: IF THIS IS CALL ACCEPT
	STB	R0,CALRDR,R1,
 EI :LIIFLAG&X.25
	LHI	R1,TMPBF3		:GET BUFFER POINTER
MCAES1	LR	R6,R6			:WHILE CUD
	JEFS	MCAES2			: DO
	JAL	R13,PACKC0		: MOVE CHARACTERS INTO TMPBF3
	JBS	MCAES1
MCAES2	CBCT(R6,R1)			:GET BUFFER COUNT
	CLHI	R6,3			:ANYTHING TO SEND?
	JLER	R14			:RETURN IF NOT
	STH	R6,TEMP3		:SAVE FOR LATER
	LR	R5,R1			:SAVE COPY FOR CALL TO ESCDTB
:-- END ------------------------------------------------------  :HJR-SWBT1
	LIS	R8,1			:ALLOW 1 BYTE OF LENGTH FIELD
	CLHI	R12,EXMF
	JE	MAKS25			:IF SINGLE BYTE LENGTH MSG
	LHL	R9,DPORT
	LB	R9,TURLEV,R9,
	JEFS	MAKS25			:IF TURKEY LEVEL 1
	AIS	R8,1
MAKS25	LR	R0,R6
	SHI	R6,CM.FST-4-2,R8	:SUBTRACT OUT 2/IIX HEADER, 1 OR 2/LEN
	JLEFS	MAKS35			:IF WILL FIT IN ONE MESSAGE
	LHI	R0,CM.FST-1-2,R8
MAKS35	LR	R7,R0
	AR	R7,R8			:ADD IN LENGTH FOR LENGTH FIELD
	JAL	R9,ESCAPN,,		:GET THE MESSAGE STARTED
	SR	R7,R8			:GET BACK NO. OF CHARS IN THIS MSG
	LHL	R9,TEMP3		:GET BACK TOTAL CHARS IN MSG
	SIS	R8,1
	JEFS	MAKS40			:IF BYTE LENGTH
	EXBR	R0,R9
	JAL	R4,BPUTCH,,		:1ST BYTE OF LENGTH
MAKS40	LR	R0,R9
	JAL	R4,BPUTCH,,		:2ND BYTE OF LENGTH
	LR	R8,R6			:SET UP REMAINING CHAR LENGTH
	LR	R6,R7			:NO. OF CHARS IN THIS MESSAGE

:	COPY REST OF INFO FROM RTD BUFFER.
	JAL	R7,ESCDTB		:COPY FROM RTD BUFFER TO DISPATCHER RING :HJR-SWBT1
:					BREAKING UP INTO ISIS MESSAGE LENGTH
	JR	R14			:RETURN


  IF	X.75
::	TNIRPT-	REPORT TRANSIT NETWORK DNIC ACCOUNTING.
:
:	INPUT	(TNIRCV) SET IF RCVD TNI LIST
:	OUTPUT	ACCOUNTING MESSAGE (AA.TNI)
:	USES	R0-R4,R6-R9,R12
:	LINK IS R6

TNIRPT	LHL	R7,IPORT
	RBT	R7,TNIRCV,,					:HJR 12-05-86
	JER	R6			:IF DID NOT GET ANY TRANSIT NET ID

:	REPORT TRANSIT NETWORK DNIC LIST.
	LR	R12,R7
	SLLS	R12,2
	AHI	R12,FACBIA
	CBCT(R8,R12)			:GET TOTAL COUNT
	STB	R8,TNICNT,R7,		:STORE COUNT FOR LATER
	JE	TNIR30			:CRASH IF FLAG SET AND NOTHING IN BUFFER
	AIS	R8,2
TNIR10	SIS	R8,2
	JE	TNIR20			:IF FINISHED, GO OUTPUT TERMINATOR
	JL	TNIR30			:PROGRAMMING ERROR
	LR	R1,R12			:GET (FACBUF)
	JAL	R4,GCI			:GET NEXT DINC
	EXBR	R7,R0
	JAL	R4,GCI
	OR	R7,R0
	OI	R7,AA.TNI
	JAL	R9,GENRPT,,
	J	TNIR10

:	OUTPUT TRANSIT DNIC TERMINATOR.
TNIR20	LHL	R7,IPORT
	LB	R7,TNICNT,R7,		:GET BYTE COUNT
	SRLS	R7,1			:GET NO. OF DNICS
	OI	R7,AA.TNI!0FF00
	JAL	R9,GENRPT,,
	LHL	R7,IPORT		:CLEAR TNIC COUNT	:HJR 12-05-86
	LIS	R4,0						:HJR 12-05-86
	STB	R4,TNICNT,R7,					:HJR 12-05-86
	JR	R6			:RETURN

TNIR30	LHL	R7,IPORT
	TRAP(R7,D5)			:INCORRECT LENGTH IN TRANSIT DNIC LIST
  EI	X.75
	KILL	GCI,WCI		:FORCE FORWARD REFERENCE	:HJR-SWBT0
	GL	GCI,WCI						:HJR-SWBT0

:: BEGIN OF THE CHANGES	:JS-ONREG

  IF	X.25
	SSTTL(REGISTRATION REQUEST)

:PROCESS REGISTRATION REQUEST 
RTDREG	PTRACE
	SBT	RL,ONREG,,		:INDICATE REGISTRATION IS IN PROGRESS
	LHI	R13,CLOCPE^8!DIA042	:"ON-LINE REGISTRATION NOT SUBSCRIBE"
	TBT	RL,OREG.F		:SUBSCRIBE TO ON-LINE REGISTRATION?
	JE	RTEREG
	TBT	RL,NREG.F		:ACCEPT REGISTRATION REQUEST PACKET?
	JN	RTEREG
:	PROCESSING THE PACKET HEADER
REG100	LHI	R13,CLOCPE^8!DIA038	:PACKET TOO SHORT
	LR	R6,R6			:ANY BYTE LEFT?
	JE	RTEREG			:NO - ERROR
	LHI	R13,CLOCPE^8!DIA074	:NON-ZERO ADDRESS LENGTH
	JAL	R4,PICKCH		:GET ADDRESS LENGTH
	LR	R0,R0			:NON-ZERO ADDRESS LENGTH?
	JN	RTEREG			:YES - ERROR
	LR	R1,RL
	SLLS	R1,2			:MAKE FULLWORD INDEX
	AHI	R1,REGBIA		:CURRENT ADDRESS OF REG BUFFER
	STH	R1,REGBUF
	JAL	R4,EMPTY,,
  IF	X.32
	RBT	RL,IDNRCV,,		:HAVN'T RECEIVED IDENTITY ELEMENT
	RBT	RL,SIGRCV,,		:HAVN'T RECEIVED SIGNATURE ELEMENT
	LIS	R4,0
	STB	R4,DIAPAR,,
  EI	:X.32
	LR	R6,R6			:HAS REGISTRATION FIELD?
	JE	REG140			:NO - RETURN CONFIRMATION PACKET
	ST	R5,RTDPNT,,		:SAVE THE POINT OF NEXT CHAR IN RING
	ST	R6,RTDCNT,,		:SAVE CHAR COUNT LEFT IN RING
	JAL	R4,PICKCH		:GET REGISTRATION LENGTH
	LR	R7,R0			:ZERO REGISTRATION LENGTH?
	JE	REG140			:YES - RETURN CONFIRMATION PACKET
	LHI	R13,CLOCPE^8!DIA069	:"REGISTRATION LENGTH > 109"
	CLHI	R0,$A109		:REGISTRATION LENGTH > 109?
	JG	RTEREG			:YES - ERROR
	LHI	R13,CLOCPE^8!DIA038	:REGISTRATION LENGTH GREATER THAN
	CLR	R7,R6			:REMAINDER OF PACKET?
	JG	RTEREG			:YES - ERROR
:	CHECKING OF REGISTRATION ELEMENT
	LIS	R0,0			:CLEAN UP TEMPORARY BUFFER
	STB	R0,DUPREG,,
REG120	LIS	R9,0			:INDICATE FOR CHECKING ONLY
	JAL	R12,RELEMT		:GET REGISTRATION ELEMENT
	LR	R7,R7			:ANY REGISTRATION ELEMENT LEFT?
	JN	REG120			:YES - GO CHECK IT
:	PROCESSING OF REGISTRATION ELEMENT
	L	R5,RTDPNT,,		:GET THE POINT OF NEXT CHAR IN RING
	L	R6,RTDCNT,,		:GET THE CHAR COUNT IN RING
	JAL	R4,PICKCH		:GET ONE BYTE FROM RTD BUFFER
	LR	R7,R0			:REGISTRATION LENGTH
REG130	LIS	R9,1			:INDICATE FOR PROCESSING 
	JAL	R12,RELEMT		:GO GET REGISTRATION ELEMENT
	LR	R7,R7			:ANY REGISTRATION ELEMENT LEFT?
	JN	REG130			:YES - GO PROCESS IT

:	INTERFACE WILL RETURN A REGISTRATION CONFIRMATION PACKET
:	TO REPORT THE CURRENT VALUE OF ALL FACILITIES APPLICABLE 
:	TO THE INTERFACE.  THE REGISTRATION FILED OF THIS PACKET
:	IS NOW CODED INTO REG BUFFER

REG140	LIS	R2,0			:CLEAR TEMPORARY BUFFER
	STB	R2,PARSAV,,

:	FACILITIES THAT MAY BE NEGOTIATED AT ANY TIME
:	EACH ONE OF THE FOLLOWING BITS OF THE PARAMETER FIELD CORRESPONDS
:	TO ONE FACILITY THAT MAY BE NEGOTIATED AT ANY TIME
:	OCTET 1 BIT 6: THROUGHPUT CLASS NEGOTIATION FACILITY
:	        BIT 5: FLOW CONTROL PARAMETER NEGOTIATION FACILITY
:	        BIT 4: REVERSE CHARGING ACCEPTANCE FACILITY
:	        BIT 3: FAST SELECT ACCEPTANCE FACILITY
:	        BIT 2: OUTGOING CALLS BARRED FACILITY
:	        BIT 1: INCOMING CALLS BARRED FACILITY
:	A BIT VALUE OF 1/0 INDICATES THAT THE CORRESPONDING FACILITY IS
:	INVOKE/REVOKE BY THE DCE.   BIT 8 IS HIGH ORDER BIT.

TCL.N	EQ	2	:OFFSET TO THROUGHPUT CALSS NEGOTIATION FACILITY
FLOW.N	EQ	3	:OFFSET TO FLOW CONTROL PARAMETER NEGOTIATION FACILITY
RCVA.N	EQ	4	:OFFSET TO REVERSE CHARGING ACCEPTANCE FACILITY
FSA.N	EQ	5	:OFFSET TO FAST SELECT ACCEPTANCE FACILITY
OBAR.N	EQ	6	:OFFSET TO OUTGOING CALLS BARRED FACILITY
IBAR.N	EQ	7	:OFFSET TO INCOMING CALLS BARRED FACILITY

NEGFAC	LH	R1,REGBUF		:GET CURRENT ADDRESS OF REG BUFFER
	LHI	R0,RG.FAC		:GET REGISTRATION CODE
	JAL	R4,WCI			:WRITE INTO REG BUFFER
	TBT	RL,TCN.F		:INVOKE THROUGHPUT CLASS NEGOTIATION?
	JE	NEGF00			:NO - SKIP
	LIS	R2,TCL.N
	SBT	R2,PARSAV,,
NEGF00	TBT	RL,PSN.F		:INVOKE PACKET SIZE NEGOTIATION?
	JE	NEGF10			:NO - SKIP
	TBT	RL,PWN.F		:INVOKE WINDOW SIZE NEGOTIATION?
	JE	NEGF10
	LIS	R2,FLOW.N
	SBT	R2,PARSAV,,
NEGF10	TBT	RL,RCNA.F		:INVOKE REVERSE CHARGING ACCEPTANCE?
	JN	NEGF20			:NO - SKIP
	LIS	R2,RCVA.N
	SBT	R2,PARSAV,,
NEGF20	TBT	RL,FSA.F		:INVOKE FAST SELECT ACCEPTANCE?
	JE	NEGF30			:NO - SKIP
	LIS	R2,FSA.N
	SBT	R2,PARSAV,,
NEGF30	TBT	RL,OBAR.F		:INVOKE OUTGOING CALLS BARRED?
	JE	NEGF40			:NO - SKIP
	LIS	R2,OBAR.N
	SBT	R2,PARSAV,,
NEGF40	TBT	RL,IBAR.F		:INVOKE INCOMING CALLS BARRED?
	JE	NEGF50
	LIS	R2,IBAR.N
	SBT	R2,PARSAV,,
NEGF50	LB	R0,PARSAV,,		:GET PARAMETER FIELD
	JAL	R4,WCI			:WRITE FIRST OCTET OF PARAMETER
	LIS	R0,0
	JAL	R4,WCI			:WRITE SECOND OCTET OF PARAMETER
	STB	R0,PARSAV,,

:	CODING OF AVAILABILITY OF FACILITIES
:	EACH ONE OF THE FOLLOWING BITS OF THE REGISTRATION PARAMETER FIELD 
:	CORRESPONDS TO ONE FACILITY WHOSE AVAILABILITY MUST BE INDICATED
:	TO THE DTE.
:	OCTET 1 BIT 8: REVERSE CHARGING FACILITY
:		BIT 7: REVERSE CHARGING ACCEPTANCE FACILITY
:		BIT 1: EXTENDED PACKET SEQUENCE NUMBERING
:	OCTET 2 BIT 5: RPOA SELECTION FACILITY
:		BIT 4: LOGICAL CHANNEL TYPE RANGES REGISTRATION FACILITY
:		BIT 3: NON-STANDARD DEFAULT PACKET SIZE REGISTRATION FACILITY
:		BIT 2: NON-STANDARD DEFAULT WINDOW SIZE REGISTRATION FACILITY
:		BIT 1: DEFAULT THROUGHPUT CLASSES ASSIGNMENT REGISTRATION FAC
:	A BIT VALUE OF 1/0 INDICATES THAT THE CORRESPONDING FACILITY IS 
:	AVAILABLE/UNAVAILABLE OR NRGOTIABLR/NOT NEGOTIABLE
:	FOR THE DTE.  BIT 8 IS HIGH ORDER BIT.
:

: FIRST OCTET
RCV.B	EQ	0	:OFFSET TO REVERSE FACILITY
RCVA.B	EQ	1	:OFFSET TO REVERSE CHARGING ACCEPTANCE FACILITY
EXTP.B	EQ	7	:OFFSET TO EXTENDED PACKET SEQUENCE NUMBERING

: SECOND OCTET
RPOA.B	EQ	3	:OFFSET TO RPOA SELECTION FACILITY
LCNR.B	EQ	4	:OFFSET TO LOGICAL CHANNEL TYPE RANGE REGISTRATION FAC
DPSR.B	EQ	5	:OFFSET TO NON-STANDARD DEFAULT PACKET SIZE REGIST
DWSR.B	EQ	6	:OFFSET TO NON-STANDARD DEFAULT WINDOW SIZE REGIST
DTCL.B	EQ	7	:OFFSET TO DEFAULT THROUGHPUT CLASS AASIGNMENT REGIST

AVLFAC	LHI	R0,RG.AVL		:GET REGISTRATION CODE
	JAL	R4,WCI			:WRITE INTO REG BUFFER
	TBT	RL,RCC.F		:REVERSE CHARGE NOT AVAILABLE FOR DTE?
	JN	AVLF00			:YES - SKIP
	LIS	R2,RCV.B		:GET BIT OFFSET
	SBT	R2,PARSAV,,
AVLF00	TBT	RL,LCP.F		:RCV CHARGE ACCEPTANCE NEGOTIABLE?
	JN	AVLF20			:NO - SKIP
	LIS	R2,RCVA.B		:GET BIT OFFSET
	SBT	R2,PARSAV,,		:INDICATE RCV CHARGE ACCEP NEGOTIABLE
AVLF20	LB	R0,PARSAV,,		:GET FIRST BYTE OF PARAMETER FIELD
	JAL	R4,WCI			:WRITE INTO REG BUFFER
	LIS	R2,0			:CLEAR TEMPORARY BUFFER
	STB	R2,PARSAV,,
	TBT	RL,FARP.F		:RPOA SELECTION NOT AVAILABLE?
	JN	AVLF30			:YES - SKIP
	LIS	R2,RPOA.B
	SBT	R2,PARSAV,,		:INDICATE RPOA SELECTION AVAILABLE
AVLF30	LIS	R2,LCNR.B		:INDICATE CHANNEL TYPE RANGES 
	SBT	R2,PARSAV,,		:REGISTRATION FACILITY NEGOTIABLE
	LIS	R2,DPSR.B		:INDICATE NON-STANDARD DEFAULT PACKET
	SBT	R2,PARSAV,,		:SIZE REGISTRATION FACILITY NEGOTIABLE
	LIS	R2,DWSR.B		:INDICATE NON-STANDARD DEFAULT WINDOW
	SBT	R2,PARSAV,,		:SIZE RGISTRATION FACILITY NEGOTIABLE
	LIS	R2,DTCL.B		:INDICATE DEFAULT THROUGHPUT CLASSES
	SBT	R2,PARSAV,,		:ASSIGNMENT REGISTRATION FAC NEGOTIABLE
	LB	R0,PARSAV,,
	JAL	R4,WCI			:WRITE SECOND BYTE OF PARAMETER FIELD
	LIS	R2,0			:CLEAR TEMPORARY BUFFER
	STB	R2,PARSAV,,

:	CODING OF NON-NEGOTIABLE FACILITY VALUE
:	BIT 1 OF PARAMETER FIELD INDICATES WHETHER THE DCE INVOKE/REVOKE 
:	THE LOCAL CHARGING PREVENTION FACILITY

LCP.B	EQ	7	:OFFSET TO LOCAL CHARGING PREVENTION FACILITY

NGOFAC	LHI	R0,RG.NGO		:GET REGISTRATION CODE
	JAL	R4,WCI
	TBT	RL,LCP.F		:LOCAL CHARGE PREVETION AVAILABLE?
	JE	NGOF00			:NO -SKIP
	LIS	R2,LCP.B
	SBT	R2,PARSAV,,		:INDICATE LOCAL CHARGE PREVENTION
NGOF00	LB	R0,PARSAV,,		:GET PARAMETER FIELD
	JAL	R4,WCI			:WRITE INTO REG BUFFER

:	CODING OT DEFAULT THROUGHPUT CLASS
:	BIT 8, 7, 6 AND 5 OF REGISTRATION PARAMETER FIELD
:	INDICATES THROUGHPUT CLASS FOR THE DIRECTION FROM THE DTE
:	BIT 4, 3, 2 AND 1 OF REGISTRATION PARAMETER FIELD
:	INDICATES THROUGHPUT CLASS FOR THE DIRECTION FROM THE DCE

DEFTCL	LHI	R0,RG.TCL		:GET REGISTRATION CODE
	JAL	R4,WCI
	LB	R0,TTR.LT,RL,		:GET DEFAULT THROUGHPUT CLASS
	LR	R4,R0
	NHI	R4,0F			:GET RCV THROUGHPUT CLASS
	SLHLS	R4,4
	SRHLS	R0,4			:GET XMT THROUGHPUT CLASS
	OR	R0,R4
	JAL	R4,WCI

:	CODING OF NON-STANDARD DEFAULT PACKET SIZE
:	OCTET 1 OF REGISTRATION PARAMETER FIELD INDICATES THE PACKET SIZE
:	FOR THE DIRECTION FROM THE DCE.
:	OCTET 2 OF REGISTRATION PARAMETER FIELD INDICATES THE PACKET SIZE
:	FOR THE DIRECTION FROM THE DTE.
:	"XMT" INDIICATES THE DIRECTION FROM DCE.
:	"RCV" INDICATES THE DIRECTION FROM DTE.

DEFPSZ	LHI	R0,RG.PSZ		:GET REGISTRATION CODE
	JAL	R4,WCI
	LHL	R2,PST.LT,RL2,		:GET DEFAULT XMT PACKET SIZE
	LOG2(R2,R0)			:CONVERT ACTUAL SIZE TO LOG 2 FORM
	JAL	R4,WCI
	LHL	R2,PSR.LT,RL2,		:GET DEFAULT RCV PACKET SIZE
	LOG2(R2,R0)			:CONVERT ACTUAL SIZE TO LOG 2 FORM
	JAL	R4,WCI

:	CODING OF NON-STANDARD DEFAULT WINDOW SIZE
:	OCTET 1 OF THE REGISTRATION PARAMETER FIELD INDICATES THE WINDOW SIZE
:	FOR THE DIRECTION FROM THE DCE.
:	OCTET 2 OF THE REGISTRATION PARAMETER FIELD INDICATES THE WINDOW SIZE
:	FOR THE DIRECTION FROM THE DTE.
:	"XMT" INDICATES THE DIRECTION FROM DCE.
:	"RCV" INDICATES THE DIRECTION FROM DTE.

DEFWSZ	LHI	R0,RG.PWZ		:GET REGISTRATION CODE
	JAL	R4,WCI
	LB	R0,PWT.LT,RL,		:GET XMT WINDOW SIZE
	JAL	R4,WCI
	LB	R0,PWR.LT,RL,		:GET RCV WINDOW SIZE
	JAL	R4,WCI


:	CODING OF LOGICAL CHANNEL TYPES RANGES
:	OCTET 1 AND 2 OF REGISTRATION PARAMETER FIELD IS LIC
:	OCTET 3 AND 4 OF REGISTRATION PARAMETER FIELD IS HIC
:	OCTET 5 AND 6 OF REGISTRATION PARAMETER FIELD IS LTC
:	OCTET 7 AND 8 OF REGISTRATION PARAMETER FIELD IS HTC
:	OCTET 9 AND 10 OF REGISTRATION PARAMETER FIELD IS LOC
:	OCTET 11 AND 12 OF REGISTRATION PARAMETER FIELD IS HOC
:	OCTET 13 AND 14 OF REGISTRATION FIELD IS TOTAL NUMBER OF
:	LOGICAL CHANNELS

LOGCNL	LHI	R0,RG.CNL		:GET REGISTRATION CODE
	JAL	R4,WCI
	LHI	R0,$A14			:REGISTRATION PARAMETER LENGTH
	JAL	R4,WCI
	LH	R8,HIC.LT,RL2,		:ANY INCOMING CHANNEL DEFINED?
	JL	LCNL00			:NO - SKIP
	LB	R0,LIC.LT,RL2,		:GET HIGH BYTE OF LIC
	LB	R7,LIC.LT+1,RL2,		:GET LOW BYTE OF LIC
	JAL	R9,LCNUM		:WRITE LIC INTO REG BUFFER
	LB	R0,HIC.LT,RL2,		:GET HIGH BYTE OF HIC
	LB	R7,HIC.LT+1,RL2,		:GET LOW BYTE OF HIC
	JAL	R9,LCNUM		:WRITE HIC INTO REG BUFFER
	JFS	LCNL10
LCNL00	JAL	R9,ZLCNUM		:NO INCOMING CHANNEL DEFINED
LCNL10	LH	R8,HTC.LT,RL2,		:ANY TWO-WAY CHANNEL DEFINED?
	JL	LCNL20			:NO -SKIP
	LB	R0,LTC.LT,RL2,		:GET HIGH BYTE OF LTC
	LB	R7,LTC.LT+1,RL2,	:GET LOW BYTE OF LTC
	JAL	R9,LCNUM		:WRITE LTC INTO REG BUFFER
	LB	R0,HTC.LT,RL2,		:GET HIGH BYTE OF HTC
	LB	R7,HTC.LT+1,RL2,	:GET LOW BYTE OF HTC
	JAL	R9,LCNUM		:WRITE HTC INTO REG BUFFER
	JFS	LCNL30
LCNL20	JAL	R9,ZLCNUM		:NO TWO-WAY CHANNEL DEFINED
LCNL30	LH	R8,HOC.LT,RL2,		:ANY OUGOING CHANNEL DEFINED?
	JL	LCNL40			:NO - SKIP
	LB	R0,LOC.LT,RL2,		:GET HIGH BYTE OF LOC
	LB	R7,LOC.LT+1,RL2,	:GET LOW BYTE OF LOC
	JAL	R9,LCNUM		:WRITE INTO REG BUFFER
	LB	R0,HOC.LT,RL2,		:GET HIGH BYTE OF HOC
	LB	R7,HOC.LT+1,RL2,	:GET LOW BYTE OF HOC
	JAL	R9,LCNUM		:WRITE INTO REG BUFFER
	JFS	LCNL50
LCNL40	JAL	R9,ZLCNUM		:NO OUTGOING CHANNEL DEFINED
LCNL50	LB	R0,NEC.LT,RL2,		:GET FIRST BYTE OF TOTAL CHANNEL NO.
	LB	R7,NEC.LT+1,RL2,	:GET SECOND BYTE OF TOTAL CHANNEL NO.
	JAL	R9,LCNUM		:WRITE INTO REG BUFFER

:	FOR X.32 INTERFACE, IF IDENTITY OR/AND SIGNATURE ELEMENT
:	IS RECEIVED FROM THE DTE, THE INTERFACE WILL VALIDATE
:	THE DTE IDENTIFICATION FIRST AND RETURN THE REGISTRATION
:	CONFIRMATION PACKET TO THE DTE WHEN THE VALIDATION PROCESS 
:	IS DONE.

    IF	X.32
	LB	R13,DIAPAR,,		:PARAMETER OF DIAGNOSTIC ELEMENT=0?
	JN	REG150
	TBT	RL,IDNRCV,,		:RECEIVED IDENTITY ELEMENT?
	JN	VLDIDR			:YES - GO DO THE VALIDATION
	TBT	RL,SIGRCV,,		:RECEIVED SIGNATURE ELEMENT?
	JE	REG160			:NO - DIDN'T RECEIVE ID[,SIG]
	LHI	R13,REA086		:IDENTITY ELEMENT IS MISSED
REG150	LH	R1,REGBUF		:GET CURRENT ADDRESS OF REGISTRATION BUFFER
	LHI	R0,RG.DIA		:REGISTRATION CODE OF DIAGNOSTIC ELEMENT
	JAL	R4,WCI
	LR	R0,R13			:PARAMETER OF DIAGNOSTIC ELEMENT
	JAL	R4,WCI
REG160					:GO RETURN CONFIRMATION
    EI
	LIS	R13,0			:ZERO CAUSE & DIAGNOSTIC CODE
	J	RTEREG

:	LCNUM - WRITE LOGICAL CHANNEL TYPE RANGE INTO REG BUFFER
:	INPUT	(R0)=HIGH BYTE OF CHANNEL RANGE
:   		(R7)=LOW BYTE OF CHANNEL RANGE
:		(R1)=CURRENT ADDRESS OF REG BUFFER
:	USES	R4
:	LINK	R9

LCNUM	JAL	R4,WCI		:WRITE FIRST BYTE OF CHANNEL RANGE
	LR	R0,R7
	JAL	R4,WCI		:WRITE SECOND BYTE OF CHANNEL RANGE
	JR	R9

:	ZLCNUM - WRITE ZERO INTO IEC BUFFER IF NO CHANNEL RANGE IS DEFINED
:	INPUT	(R1)=CURRENT ADDRESS OF REG BUFFER
:	USES	R4
:	LINK	R9

ZLCNUM	LIS	R0,0
	JAL	R4,WCI
	JAL	R4,WCI
	JAL	R4,WCI
	JAL	R4,WCI
	JR	R9

:	VLDIDR - REQUEST A CIRCUIT FOR VALIDATING THE DTE 
:	         IDENTIFICATION

  IF	X.32
VLDIDR	L	R13,IDNPNT,RL2,RL2	:GET IDENTITY ELEMENT BUFFER POINT
	LB	R6,,R13			:GET LENGTH BYTE
	LIS	R9,1
VDID10	LB	R0,,R9,R13		:GET ONE CHARACTER FROM IND BUFFER
	CLHI	R0,0A0			:ILLEGAL CHARACTER IN USERNAME?
	JL	INVLDC			:YES - RETURN ERROR CODE
	AIS	R9,1			:INCREASE THE INDEX OF IDN BUFFER
	SIS	R6,1			:ANY CHARACTER LEFT?
	JLE	VDID20			:NO - FINISH CHECKING?
	CLHI	R0,0BB			:IS A SEMI-COLON?
	JN	VDID10			:NO - CONTINUE CHECKING
VDID20	LB	R6,VLDHST		:GET RELATIVE HOST NO FOR VALIDATION HOST
	CLHI	R6,0FF			:DEFINE A VALIDATION HOST?
	JE	NVLDHT			:NO - CANNOT PROVIDE IDENTIFIED SERVICE
	LHL	R0,PORTS,R6,R6
	SRLS	R0,$A 14		:STATUS IS BITS 14, 15
	LR	R0,R0			:HOST ANSWERED?
	JN	VLDOFF			:NO - CANNOT DO VALIDATION
	JAL	R3,FINDIP,,		:FIND A INTERNAL PORT
	SKIPAD(NOPORT)			:NO IPORT AVAILABLE
	RBT	R2,IPA.F		:INDICATE IPORT IS UNAVAILABLE
	LIS	R0,VLDID		:VALIDATING THE DTE IDENTIFICATION
	STB	R0,IDSTAT,RL,
	STB	RL,IL.MT,R2,		:SAVE LINK NUMBER
	SBT	R2,IDICRT,,		:INDICATE BUILDING FOR VALIDATION
	SLLS	R2,2
	AHI	R2,IEDBIA		:GET CURRENT ADDRESS OF IED BUFFER
	STH	R2,IEDBUF
	LIS	R0,1
	STH	R0,BF,R2,		:STORE DUMMY FLAG POINTER
	LR	R1,R2
	JAL	R4,EMPTY,,		:EMPTY IED BUFFER
	LIS	R9,0			:RESET THE INDEX OF NUISAV TO ZERO
	L	R13,IDNPNT,RL2,RL2	:GET IDN BUFFER POINT
	JAL	R12,IDSAVE		:MOVE DATA FROM IDNBUF TO NUISAV
	TBT	RL,SIGRCV,,		:RECEIVED SIGNATURE ELEMENT?
	JE	VDID25			:NO - SKIP
	L	R13,SIGPNT,RL2,RL2	:GET IDN BUFFER POINT
	JAL	R12,IDSAVE		:MOVE DATA FROM SIGBUF TO NUISAV
VDID25	STH	R9,TEMP6		:SAVE LENGTH OF NUI SAVE
	JAL	R13,BLDUSR		:BUILD USERNAME OF LOGIN STRING
	LIS	R0,5+1			:BASIC LENGTH OF THE HOST NUMBER STRING
	JAL	R4,WCI
	LHI	R0,3A			:COLON AT END OF USERNAME
	JAL	R4,WCI
	LB	R6,VLDHST		:GET RELATIVE HOST NO. OF VALIDAT HOST
	LHL	R1,HOSTS,R6,R6		:GET VALIDATION HOST NUMBER
	JAL	R5,CLDT80,,		:CONVERT FROM HEX TO DECIMAL :HJR-SWBT1
:	HERE TO CONSTRUCT HOST NUMBER
	LH	R1,IEDBUF		:GET CURRENT ADDRESS OF IED BUFFER
	LIS	R7,0			:INDEX TO HOST NUMBER
	LIS	R8,5			:NO. OF DIGITS IN HOST NUMBER
	LB	R0,CLDFM		:GET FIRST BYTE OF HOST NUMBER
VDID30	NHI	R0,0F			:POSITION TO SECOND OF TWO DIGIT
	AHI	R0,30			:MAKE INTO ASCII DIGIT
	JAL	R4,WCI			:PUT INTO IED BUFFER
	SIS	R8,1			:DECREASE DIGIT 
	JLE	VDID40
	AIS	R7,1			:INCREASE BYTE COUNT
	LB	R12,CLDFM,R7		:GET NEXT BYTE OF HOST NUMBER
	LBR	R0,R12			:LOAD DIGIT PAIR
	SRHLS	R0,4			:POSITION TO FIRST OF TWO DIGITS
	AHI	R0,30			:MAKE INTO ASCII DIGIT
	JAL	R4,WCI			:PUT INTO IED BUFFER
	LBR	R0,R12			:RELOAD DIGIT PAIR
	SIS	R8,1			:DECREASE DIGIT LEFT
	JG	VDID30			:GO PROCESS NEXT DIGIT
VDID40	JAL	R4,WCI			:WRITE LENGTH
	JAL	R13,BLDPWD		:BUILD PASSWORD OF LOGIN STRING
	LIS	R0,1
	JAL	R4,WCI
	LIS	R0,0D			:PUT <CR> INTO IED BUFFER
	JAL	R4,WCI
	LIS	R0,0			:CLEAR SAVTID BUFFER
	ST	R0,SAVTID
	LHI	R0,0CC			:STORE TERMINAL ID
	STB	R0,SAVTID
	J	PCR559			:GO SEND PSEUDO NEEDLE REQUEST

:	NVLDHT - NO VALIDATION HOST DEFINED, CANNOT VALIDATE
:		 DTE IDENTIFICATION

NVLDHT	LHI	R8,REA081		:NO VALIDATION HOST DEFINED
NVLD10	JAL	R12,REGELE		:FILL THE DIAGNOSTIC ELEMENT
	J	RTD020,,

:	INVLDC - INVALID CHARACTER IN USERNAME OF IDENTITY ELEMENT

INVLDC	LHI	R8,REA082		:INVALID CHARACTER IN USERNAME
	JAL	R12,REGELE		:GO FILL THE DIAGNOSTIC ELEMENT
	JAL	R4,VLDERR		:GO CHECK RETRY LIMIT
	J	RTD020,,

:	NOPORT	- CANNOT FIND AN AVAILABLE INTERNAL PORT

NOPORT	LHI	R8,REA084		:TEMPORARY NETWORK CONGESTION
	J	NVLD10

:	VLDOFF	- VALIDATION HOST IS NOT IN ANSWERED STATE
:		  SAME HOST NUMBER IS USED IN THE NETWORK

VLDOFF	LHI	R8,REA087		:VALIDATION HOST NOT ANSWERED
	J	NVLD10

:	REGELE - FILL THE DIAGNOSTIC ELEMENT AND RETURN 
:		 THE REGISTRATION CONFIRMATION PACKET
:	INPUT	 (R8)=IDENTIFICATION FAILED REASON
:	LINK	 R12

REGELE	LHL	R1,IPORT		:GET INTERNAL PORT NUMBER
	LB	RL,IL.MT,R1,		:GET LINK NUMBER
	LR	R1,RL
	SLLS	R1,2			:MAKE FULLWORD INDEX
	CI	R8,7F			:IDENTIFICATION SUCCESS?
	JE	REGEL1			:YES - DONN'T RESET BYTE COUNT
	LIS	R0,0			:OF IDN AND SIG BUFFER
	L	R13,IDNPNT,R1,		:RESET IDN BUFFER LENGTH TO ZERO
	STB	R0,,R13
	L	R13,SIGPNT,R1,		:RESET SIGBUF BUFFER LENGTH TO ZERO
	STB	R0,,R13
	LIS	R0,WATID		:CHANGE STATE TO WAITING STATE
	STB	R0,IDSTAT,RL,
REGEL1	RBT	RL,IDNRCV,,
	RBT	RL,SIGRCV,,
	AHI	R1,REGBIA		:CURRENT ADDRESS OF REGBUF
	LHI	R0,RG.DIA		:REGISTRATION CODE OF DIAGNOSTIC ELEMENT
	JAL	R4,WCI			:WRITE INTO REG BUFFER
	LR	R0,R8			:PARAMETER OF DIAGNOSTIC ELEMENT
	JAL	R4,WCI			:WRITE INTO REG BUFFER
	LIS	R13,0			:ZERO CAUSE AND DIAGNOSTIC CODE
	STH	R13,REGDIA,RL,RL
	JAL	R9,REGCON		:GO RETURN REGISTRATION CONFIRMATION
	JR	R12

:	VLDERR - CHECK WHETHER THE DTE IDENTIFICATION RETRY LIMIT
:		 IS REACHED.  IF YES, CLEARS ALL THE NETWORK CALLS
:		 AND ENABLE TIMER TO DISCONNECT THE LINK 10 SECOND LATTER.
:		 IF NO, INCREASE THE ERROR COUNT.
:		 IN BOTH CASES, THE INTERFACE WILL RETURN A CONFIRMATION
:		 PACKET TO THE DTE TO INDICATE THE FAILED REASON.
:	INPUT	 (RL)=LINK NUMBER
:	USES	 R0,R5
:	LINK	 R4

MAXTRY	EQ	3			:MAXIMUM RETRY COUNT

VLDERR	LB	R0,IDERR,RL,		:GET ERROR COUNT
	CI	R0,MAXTRY		:REACH RETRY LIMIT?
	JGE	VLDER2			:YES-GO SET TIMER TO DISCONNECT LINK
	AIS	R0,1			:INCREASE ERROR COUNT
	STB	R0,IDERR,RL,
	JR	R4
VLDER2	LIS	R0,IDFAL		:CHAGE STATE TO ID UNSUCCESSFUL
	STB	R0,IDSTAT,RL,
	SBT	RL,IDTO,,		:ENABLE TIMER TO DISCONNECT LINK
	L	R5,FASTC,,
	AI	R5,RATE*$A10		:DISCONNECT THE LINK 10 SECOND LATTER
	LR	R1,RL
	SLLS	R1,2			:MAKE FULLWORD INDEX
	ST	R5,DISTIM,R1,		:SAVE THE TIME
	JR	R4

:	NOPORT - CANNOT FIND AN AVAILABLE INTERNAL PORT.
:		 TEMPORARY NETWORK CONGESTION OR FAULT
:		 CONDITION WITHIN THE NETWORK

NOPORT	LH	R1,REGBUF		:GET CURRENT ADDRESS OF REG BUFFER
	LHI	R0,RG.DIA		:DIAGNOSTIC ELEMENT
	JAL	R4,WCI
	LHI	R0,REA084		:INDICATE FAULT CONDITION WITHIN
	JAL	R4,WCI			:THE NETWORK
	J	RTEREG

  EI	:X.32	
	


:	THE FACILITY NEGOTIATION IS DONE, NOW MOVE THE INFORMATION
:	STORED IN THE REG BUFFER TO IEC BUFFER FOR BUILDING
:	THE REGISTRATION CONFIRMATION PACKET
:       INPUT	(R13)=CAUSE & DIAGNOSTIC CODE
:	USES	R9

RTEREG	STH	R13,REGDIA,RL,RL	:SAVE CAUSE & DIAGNOSTIC CODES
	JAL	R9,REGCON
	J	RTD020,,

:	REGCON - THE INFORMATION FOR BUILDING THE REGISTRATION 
:                CONFIRMATION PACKET ARE CODED INTO IEC BUFFER
:		 THE INFORMATION INCLUDE:
:		 ========================================================
:               |      FIELD          | SIZE |   CONTENT                 |
:               |--------------------------------------------------------|
:               |PACKET TYPE          | BS   | 10                        |
:               |--------------------------------------------------------|
:               |BYTE COUNT           | HS   |1 BYTE CONTROL FLAG        |
:		|                     |      |+ 1 BYTE DTE & DCE ADDRESS | 
:		|                     |      |[+ 1 BYTE REGISTRATION LEN]|
:		|                     |      |+ BYTE COUNT OF REG BUFFER |
:               |--------------------------------------------------------|
:               |CONTROL FLAG         | BS   | 0                         |
:               |--------------------------------------------------------|
:               |DTE & DCE ADDRESS    | BS   | 0                         |
:               |--------------------------------------------------------|
:               |REGISTRATION LENGTH  | BS   |BYTE COUNT OF REG BUFFER   |
:               |--------------------------------------------------------|
:               |REGISTRATION ELEMENTS|      |CONTENT OF REG BUFFER      |
:                =========================================================
:
:		USES    R0,R1,R2,R3,R4,R8
:		CALLS	RTEREG
:		LINK	R9


REGCON	LR 	R1,RL
	SLLS	R1,2
	AHI	R1,IECBIA		:CURRENT BUFFER ADDRESS
	STH	R1,BUFADR
	LHI	R0,ZREGC		:REGISTRATION CONFIRMATION PACKET
	JAL	R4,WCI
	LH	R1,REGBUF
	CBCT(R8)			:BYTE COUNT OF REGBUF
	LIS	R5,2			:1 BYTE BYTE COUNT+1 BYTE CONTROL FLAG
	LR	R8,R8			:EMPTY REG BUFFER?
	JE	REGC05			:YES - SKIP
	AIS	R5,1			:1 BYTE REGISTRATION LENGTH
REGC05	AR	R5,R8
	LR	R0,R5
	SRLS	R0,8
	LH	R1,BUFADR		:CURRENT ADDRESS OF IEC BUFFER
	JAL	R4,WCI			:WRITE HIGH BYTE OF LENGTH
	LR	R0,R5
	NHI	R0,0FF	
	JAL	R4,WCI			:WRITE LOW BYTE OF LENGTH
	LIS	R0,0
	JAL	R4,WCI			:WRITE CONTROL FLAG BYTE
	JAL	R4,WCI			:WRITE DTE & DCE ADDRESS LENGTH
	LR	R0,R8			:EMPTY REG BUFFER?
	JER	R9
	JAL	R4,WCI			:WRITE REGISTRATION LENGTH
REGC10	LH	R1,REGBUF		:GET CURRENT ADDRESS OF REG BUFFER
	JAL	R4,GCI			:GET A BYTE FROM REG BUFFER
	LH	R1,BUFADR		:GET CURRENT ADDRESS OF IEC BUFFER
	JAL	R4,WCI			:WRITE IT INTO IEC BUFFER
	SIS	R8,1			:ANY MORE BYTE TO BE COPIED?
	JG	REGC10			:YES - CONTINUE
	JR	R9

	
	

	
	

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::	RELEMT - GET A REGISTRATION ELEMENT FROM RTD RING AND THEN
:		 CHECK OR PROCESS THE REGISTRATION CODE AND REGISTRATION
:                PARAMETER 
:       
:	INPUT	R5->NEXT CHAR IN THE RTD RING
:		(R6)=CHAR COUNT LEFT IN RING
:		(R7)=LENGTH OF REGISTRATION FIELD
:		(R9)=0 INDICATE FOR CHECKING THE REGISTRATION ELEMENTS
:		    =1 INDICATE FOR PROCESSING THE REGISTRATION ELEMENTS
:	USES	R3,R4,R8
:	LINK	R12

RELEMT	JAL	R4,PICKCH		:GET FACILITY CODE
	LHI	R13,CLOCPE^8!DIA038	:"PACKET TOO SHORT"
	SIS	R7,1			:LENGTH=LENGTH-1
	JLE	RTEREG			:SEND CONFIRMATION IF NOT ENOUGH DATA
	LR	R8,R0			:SAVE REGISTRATION CODE
	LR	R3,R0
	NHI	R3,3F			:MASK DOWN TO 6 BITS
	SRHLS	R8,6			:UPPER 2 BITS DETERMINE TYPE
	CLB	R3,REGLNG,R8		:REGISTRATION CODE>DEFINED RANGE?
	JGE	RELE10			:YES - DISCARD UNDEFINED CODE?
	LH	R4,REGDEC,R8,R8		:OFFSET TO GROUP WITHIN TABLE
	SLLS	R3,1			:MAKE INTO HW INDEX
	LH	R3,REGDEC,R3,R4		:GET ENTRY IN JUMP TABLE
	JN	REGDEC,R3		:JUMP TO PROCESSOR IF NON-ZERO
:	STRIP UNDEFINED REGISTRATION CODE
RELE10	CLHI	R8,UT.VAR		:VARIABLE LENGTH?
	JNFS	RELE20			:NO - TYPE INDICATE LENGTH
	LB	R8,,R5			:PEEK AT LENGTH
RELE20	AIS	R8,1
	SR	R7,R8			:ENOUGH DATA IN PACKET?
	JL	RTEREG			:NO - ERROR
RELE30	JAL	R4,PICKCH		:STRIP REGISTRATION CODE & PARAMETER
	SIS	R8,1
	JGBS	RELE30
	JR	R12

:	JUMP TABLE FOR EACH TYPE OF REGISTRATION CODE CLASS
:	DECISION TABLE USED FOR REGISTRATION REQUEST REGISTRATION CODE

 TABLE(REGDEC)
:	CLASS TABLE OFFSETS FOR REGISTRATION CODE PROCESSING
	TENTRY(PRAC)			:CLASS A REGISTRATION CODE JUMP TABLE
	TENTRY(PRBC)			:CLASS B REGISTRATION CODE JUMP TABLE
	TENTRY(PRCC)			:CLASS C REGISTRATION CODE JUMP TABLE
	TENTRY(PRDC)			:CLASS D REGISTRATION CODE JUMP TABLE

:	REGISTRATION REQUEST REGISTRATION CODE PROCESSORS
:	CLASS A
PRAC	TENTRY(0)		:0 ILLEGAL REGISTRATION CODE
	TENTRY(0)		:1 ILLEGAL REGISTRATION CODE
	TENTRY(PRTCL)		:2 DEFAULT THROUGHPUT CLASS ASSIGNMENT
PRAC.L	EQ	(.-PRAC)/2	:LENGTH OF CLASS A TABLE

:	CALSS B
PRBC	TENTRY(0)		:0 ILLEGAL REGISTRATION CODE
	TENTRY(0)		:1 ILLEGAL REGISTRATION CODE
	TENTRY(PRPSZ)		:2 NON-STNADARD DEFAULT PACKET SIZE
	TENTRY(PRWSZ)		:3 NON-STANDARD DEFAULT WINDOW SIZE
	TENTRY(0)		:4 ILLEGAL REGISTRATION CODE
	TENTRY(PRNGO)		:5 FACILITY MAY BE NEGOTIATED AT ANY TIME
PRBC.L	EQ	(.-PRBC)/2	:LENGTH OF CLASS B TABLE

:	CLASS C
PRCC	TENTRY(0)		:0 ILLEGAL REGISTRATION CODE
PRCC.L	EQ	(.-PRCC)/2	:LENGTH OF CLASS C TABLE

:	CLASS D
PRDC	TENTRY(0)		:0 ILLEGAL REGISTRATION CODE
	TENTRY(0)		:1 ILLEGAL REGISTRATION CODE
	TENTRY(0)		:2 ILLEGAL REGISTRATION CODE
	TENTRY(0)		:3 ILLEGAL REGISTRATION CODE
	TENTRY(0)		:4 ILLEGAL REGISTRATION CODE
	TENTRY(0)		:5 ILLEGAL REGISTRATION CODE
	TENTRY(0)		:6 ILLEGAL REGISTRATION CODE
	TENTRY(0)		:7 ILLEGAL REGISTRATION CODE
	TENTRY(PRCNL)		:8 LOGICAL CHANNEL TYPES RANGES
	TENTRY(0)		:9 ILLEGAL REGISTRATION CODE
	TENTRY(0)		:0A ILLEGAL REGISTRATION CODE
	TENTRY(0)		:0B ILLEGAL REGISTRATION CODE
  IF	X.32
	TENTRY(PRIDN)		:0C IDENTITY ELEMENT
	TENTRY(PRSIG)		:0D SIGNATURE ELEMENT
  EI
PRDC.L	EQ	(.-PRDC)/2

:	REGISTRATION REQUEST PACKET NMBER OF REGISTRATION CODES PER CLASS
REGLNG	BC	PRAC.L,PRBC.L,PRCC.L,PRDC.L

:	EACH ONE OF THE FOLLOWING BITS OF BIT ARRAY "DUPREG" CORRESPONDS
:	TO ONE REGISTRATION CODE WHICH MAY BE RECEIVED IN THE REGISTRATION 
:	REQUEST PACKET.
:	BIT 0: FACILITIES THAT MAY BE NEGOTIATED AT ANY TIME
:	BIT 1: DEFAULT THROUGHPUT CLASSES ASSIGNMENT
:	BIT 2: NON-STANDARD DEFAULT PACKET SIZES
:	BIT 3: NON-STANDARD DEFAULT WINDOW SIZES
:	BIT 4: LOGICAL CHANNEL TYPES RANGES
:	THE CORRESPONDING BIT IS SET WHEN A REGISTRATION CODE IS RECEIVED
:	FIRST TIME.

FACDUP	EQ	0
TCLDUP	EQ	1
PSZDUP	EQ	2
WSZDUP	EQ	3
CNLDUP	EQ	4
  IF	X.32
IDNDUP	EQ	5
SIGDUP	EQ	6
  EI	:X.32

:	PRTCL - DEFAULT THROUGHPUT CLASSES ASSIGNMENT
:		BIT 8, 7, 6 AND 5 OF REGISTRATION PARAMETER FIELD
:		INDICATES THROUGHPUT CLASS FOR THE DIRECTION FROM THE DTE
:		BIT 4, 3, 2 AND 1 OF REGISTRATION PARAMETER FIELD
:		INDICATES THROUGHPUT CLASS FOR THE DIRECTION FROM THE DCE
:		"XMT" INDICATE THE DIRECTION FROM THE DCE
:		"RCV" INDICATE THE DIRECTION FROM THE DTE

PRTCL	LR	R9,R9			:CHECKING ONLY?
	JN	PRTCL2			:NO - GO MODIFY IT
: CHECK REGISTRATION CODE AND REGISTRATION PARAMETER
	SIS	R7,1			:ENOUGH DATA?
	JL	RTEREG			:NO - ERROR
	LHI	R13,CLOCPE^8!DIA073	:"REGISTRATION CODE REPEATED"
	LIS	R2,TCLDUP	
	SBT	R2,DUPREG,,		:FIRST TIME RECEIVE?
	JN	RTEREG			:NO - ERROR
	JAL	R4,PICKCH		:GET REQUESTED THROUGHPUT CLASS
	LR	R4,R0
	NHI	R0,0F			:GET XMT THROUGHPUT CLASS
	LIS	R2,0			:ERROR FLAG 0=NO 1=YES
	JAL	R8,PRCKTC		:CHECK THE RANGE
	LR	R13,R0			:SAVE ALLOWED XMT THROUGHPUT CLASS
	LR	R0,R4
	SRHLS	R0,4			:GET RCV THROUGHPUT CLASS
	JAL	R8,PRCKTC		CHECK THE RANGE
	LR	R2,R2			:ANY ERROR FOUND IN PARAMETER FIELD?
	JER	R12
: ERROR FOUNG IN PARAMETER FIELD THEN STORE THE ALLOWED VALUES IN REG BUFFER
PRTCL1	SLHLS	R0,4
	OR	R0,R13
	STB	R0,PARSAV,,		:RESTORE THE ALLOWED VALUES
	LHI	R13,CINVLD^8!DIA066	:"INVALID FACILITY VALUE"
	LH	R1,REGBUF		:GET CURRENT ADDRESS OF REG BUFFER
	LHI	R0,RG.TCL		:GET REGISTRATION CODE
	JAL	R4,WCI
	LB	R0,PARSAV,,		:GET ALLOWED THROUGHPUT CLASS
	JAL	R4,WCI
	J	RTEREG

: MODIFY THE DEFAULT THROUGHPUT CLASS
PRTCL2	
  IF	X.32
	LIS	R2,TCLRCV
	SBT	R2,FACRST,RL2,		:INDICATE FACILITY IS MODIFIED
  EI	:X.32
	JAL	R4,PICKCH		:GET REQUESTED THROUGHPUT CLASS
	LR	R2,R0
	SRHLS	R2,4			:GET REQUESTED RCV THROUGHPUT CLASS
	NHI	R0,0F			:GET REQUESTED XMT THROUGHPUT CLASS
	SLHLS	R0,4
	OR	R0,R2			:EXCHANGE THE POSITION
  IF	TCSC
	LR	R13,R7
	JAL	R7,TRTCSC,,		:TRANSLATE TO STANDARD CCITT VALUE
	LR	R7,R13
  EI
	LIS	R3,1			:INDICATE MODIFY BYTE
	LA	R1,TTR.LT,RL,
	JAL	R4,XMROTM,,
	SIS	R7,1
	JR	R12

:	PRCKTC - CHECK THROUGHPUT CLASS IN REGISTRATION REQUEST PACKET
:		 IF THE REQUESTED VALUE IS GREATER THAN THE MAXIMUN ALLOWED
:       	 THEN RETURN THE MAXIMUM ALLOWED VALUE TO THE DTE
:		 IF THE REQUESTED VALUE IS LESS THAN THE MINIMUM ALLOWED
:		 THEN RETURN THE MINIMUM ALLOWED VALUE TO THE DTE
:	INPUT	(RO)=REQUESTED VALUE
:	OUTPUT  (R0)=ALLOWED/ACCEPTED VALUE
:		(R2)=0 REQUESTED VALUE IS OK
:		(R2)=1 REQUESTED VALUE IS NOT ALLOWED
:	USES    R3
:	LINK    R8

MAXTCL	EQ	$A12			:MAX OF THROUGHPUT CLASS
MINTCL	EQ	3			:MIN OF THROUGHPUT CLASS

PRCKTC	LHI	R3,MAXTCL
	CR	R0,R3			:REQUESTED>0C?
	JG	CKTC10			:YES - ERROR
	LIS	R3,MINTCL
	CR	R0,R3			:REQUESTED<3?
	JGER	R8			:NO - OK
CKTC10	LIS	R2,1			:INDICATE TCL OUT OF RANGE
	LR	R0,R3			:RETURN THE MAX/MIN ALLOWED VALUE
	JR	R8
	
:
:	PRPSZ - NON-STANDARD DEFAULT PACKET SIZE NEGOTIATION
:		OCTET 1 OF REGISTRATION PARAMETER FIELD INDICATES THE PACKET 
:		SIZE FOR THE DIRECTION FROM THE DCE.
:		OCTET 2 OF REGISTRATION PARAMETER FIELD INDICATES THE PACKET 
:		SIZE FOR THE DIRECTION FROM THE DTE.
:		"XMT" INDICATE THE DIRECTION FROM DCE
:		"RCV" INDICATE THE DIRECTION FROM DTE

PRPSZ	LR	R9,R9			:CHECKING ONLY?
	JN	PRPSZ2			:NO - GO MODIFYIT
: CHECK THE REGISTRATION CODE AND REGISTRATION PARAMETER
	SIS	R7,2			:ENOUGH DATA?
	JL	RTEREG			:NO - ERROR
	LHI	R13,CLOCPE^8!DIA073	"REGISTRATION CODE REPEATED"
	LIS	R2,PSZDUP	
	SBT	R2,DUPREG,,		:FIRST TIME RECEIVE?
	JN	RTEREG			:NO - ERROR
	JAL	R4,PICKCH		:GET TRANSMIT PACKET SIZE 
	STB	R0,PARSAV,,
	LIS	R2,0			:ERROR FLAG 0=NO 1=YES
	LIS	R9,0			:DIRECTION FLAG 0=XMT 1=RCV
	JAL	R8,PRCKPS		:GO CHECK THE RANGE
	JAL	R4,PICKCH		:GET RECEIVE PACKET SIZE
	STB	R0,PARSAV+1,,
	LIS	R9,1
	JAL	R8,PRCKPS		:GO CHECK THE REQUESTED VALUE
	LR	R2,R2			:ERROR FOUND IN PARAMETER FIELD?
	JER	R12

: ERROR FOUND IN THE PARAMETER FIELD THEN STORE THE ALLOWED VALUES 
: IN REG BUFFER
PRPSZ1	LHI	R13,CINVLD^8!DIA066	:"INVALID FACILITY VALUE"
	LH	R1,REGBUF		:GET CURRENT ADDRESS OF REG BUFFER
	LHI	R0,RG.PSZ		:GET REGISTRATION CODE
	JAL	R4,WCI,,
	LB	R0,PARSAV,,		:GET ALLOWED/ACCEPTED XMT PACKET SIZE
	JAL	R4,WCI,,
	LB	R0,PARSAV+1,,		:GET ALLOWED/ACCEPTED RCV PACKET SIZE
	JAL	R4,WCI,,
	J	RTEREG

: MODIFY THE DEFAULT PACKET SIZES
PRPSZ2	
  IF	X.32
	LIS	R2,PSZRCV
	SBT	R2,FACRST,RL2,		:INDICATE FACILITY IS MODIFIED
  EI	:X.32
	JAL	R4,PICKCH		:GET REQUESTED XMT PACKET SIZE
	LR	R13,R0
	POWER2(R13,R4)			:CONVERT TO ACTUAL PACKET SIZE
	LR	R0,R4
	LA	R1,PST.LT,RL2,
	LIS	R3,2			:INDICATE MODIFY HALFWORD
	JAL	R4,XMROTM,,		:MODIFY XMT PACKET SIZE
	JAL	R4,PICKCH		:GET REQUESTED RCV PACKET SIZE
	LR	R13,R0
	POWER2(R13,R4)
	LR	R0,R4
	LA	R1,PSR.LT,RL2,
	JAL	R4,XMROTM,,
	SIS	R7,2			:REMAINDER OF REGISTRATION LENGTH
	JR	R12

:	PRCKPS - CHECK THE REQUESTED NON-STANDARD DEFAULT PACKET SIZE
:		 IF THE REQUESTED PACKET SIZE IS GREATER THAN THE MAXIMUM
:		 ALLOWED PACKET SIZE/ CONFIGURED
:		 MAXIMUM SIZE THEN RETURN THE CONFIGURED MAXIMUM SIZE TO DTE.
:		 IF THE REQUESTED PACKET IS LESS THAN THE MINIMUM ALLOWED
:		 PACKET SIZE/CONFIGURED MINIMUM
:		 SIZE THEN RETURN THE CONFIGURED MINIMUM SIZE TO DTE.
:
:	INPUT	(R0)=REQUESTED PACKET SIZE
:		(R9)=0 INDICATE XMT PACKET SIZE
:  		     1 INDICATE RCV PACKET SIZE
:	OUTPUT  (R2)=0 INDICATE NO ERROR FOUND IN PARAMETER FIELD
:                   =1 INDICATE ERROR FOUND IN PARAMETER FIELD
:	USES	R3,R4
:	LINK    R8

PRCKPS	LR	R13,R0
	CLHI	R13,PSMAX		:<= MAXIMUM PACKET SIZE
	JLE	CKPS10			:YES - GET TO CHECK LOW BOUND
	LHL	R3,MST.LT,RL2,		:GET MAX CONFIGURED XMT PACKET SIZE
	LR	R9,R9			:CHECKING FOR XMT PACKET SIZE?
	JE	CKPS40			:YES - GO TO RETURN MAX ALLOWED VALUE
	LHL	R3,MSR.LT,RL2,		:GET MAX CONFIGURED RCV PACKET SIZE
	J	CKPS40			:GO TO RETURN MAX ALLOWED VALUE
CKPS10	CLHI	R13,PSMIN		:>= MINIMUM PACKET SIZE
	JGE	CKPS20			:YES - IN RANGE
	LIS	R2,1			:INDICATE INVALID FACILITY VALUE
	LHI	R13,PSMIN
	J	CKPS45			:GO RETURN MIN ALLOWED VALUE
CKPS20	POWER2(R13,R4)			:CONVERT TO ACTUAL PACKET SIZE
	LHL	R3,MST.LT,RL2,		:GET MAX CONFIGURED XMT PACKET SIZE
	LR	R9,R9			:CHECKING FOR XMT PACKET SIZE?
	JEFS	CKPS30			:YES - SKIP
	LHL	R3,MSR.LT,RL2,		:GET MAX CONFIGURED RCV PACKET SIZE
CKPS30	CR	R4,R3			:REQUEST SIZE<=MAX CONFIGURED SIZE
	JLER	R8			:YES - OK RETURN
CKPS40	LIS	R2,1			:INDICATE INVALID FACILITY VALUE
	LOG2(R3,R13)			:CONVERT TO LOG 2
CKPS45	LIS	R3,0			:GET RTD POINTER
	LR	R9,R9			:CHECKING FOR XMT PACKET SIZE?
	JE	CKPS50			:YES - SKIP
	AIS	R3,1
CKPS50	STB	R13,PARSAV,R3,		:STORE THE MIN/MAX ALLOWED VALUE
	JR	R8			:ERROR RETURN


:	PRWSZ - NON-STANDARD DEFAULT WINDOW SIZE NEGOTIATION
:		OCTET 1 OF REGISTRATION PARAMETER FIELD INDICATES THE WINDOW
:		SIZE FOR THE DIRECTION FROM THE DCE.
:		OCTET 2 OF REGISTRATION PARAMETER FIELD INDICATES THE WINDOW
:		SIZE FOR THE DIRECTION FROM THE DTE.
:		"XMT" INDICATE THE DIRECTION FROM DCE
:		"RCV" INDICATE THE DIRECTION FROM DTE

PRWSZ	LR	R9,R9			:CHECKING ONLY?
	JN	PRWSZ2			:NO - GO MODIFY IT
: CHECK THE REGISTRATION CODE AND REGISTRATION PARAMETER
	SIS	R7,2			:ENOUGH DATA?
	JL	RTEREG			:NO - ERROR
	LHI	R13,CLOCPE^8!DIA073	:"REGISTRATION CODE REPEATED"
	LIS	R2,WSZDUP
	SBT	R2,DUPREG,,		:FIRST TIME RECEIVE?
	JN	RTEREG			:NO - ERROR
	JAL	R4,PICKCH		:GET REQUESTED XMT WINDOW SIZE
	STB	R0,PARSAV,,
	LIS	R2,0			:ERROR FLAG 0=NO 1=YES
	LIS	R9,0			:DIRECTION FLAG 0=XMT 1=RCV
	JAL	R8,PRCKPW		:GO TO CHECK THE RANGE
	JAL	R4,PICKCH		:GET REQUESTED RCV WINDOW SIZE
	STB	R0,PARSAV+1,,
	LIS	R9,1
	JAL	R8,PRCKPW		:GO TO CHECK THE RANGE
	LR	R2,R2			:ERROR FOUND IN PARAMETER FIELD?
	JER	R12

: ERROR FOUND IN THE PARAMETER FIELD
PRWSZ1	LHI	R13,CINVLD^8!DIA066	:"INVALID FACILITY VALUE"
	LH	R1,REGBUF		:GET CURRENT ADDRESS OF REG BUFFER
	LHI	R0,RG.PWZ		:GET REGISTRATION CODE
	JAL	R4,WCI,,
	LB	R0,PARSAV,,		:GET ALLOWED XMT WINDOW SIZE
	JAL	R4,WCI,,
	LB	R0,PARSAV+1,,		:GET ALLOWED RCV WINDOW SIZE
	JAL	R4,WCI,,
	J	RTEREG

: MODIFY THE REQUESTED FACILITY
PRWSZ2	
  IF	X.32
	LIS	R2,WSZRCV
	SBT	R2,FACRST,RL2,		:INDICATE FACILITY IS MODIFIED
  EI	:X.32
	JAL	R4,PICKCH		:GET REQUESTED XMT WINDOW SIZE
	LIS	R3,1			:INDICATE MODIFY BYTE
	LA	R1,PWT.LT,RL,
	JAL	R4,XMROTM,,		:MODIFY DEFALUT XMT WINDOW SIZE
	JAL	R4,PICKCH		:GET REQUESTED RCV WINDOW SIZE
	LA	R1,PWR.LT,RL,
	JAL	R4,XMROTM,,
	SIS	R7,2			:REMAINDER OF REGISTRATION LENGTH
	JR	R12

:	PRCKPW - CHECK THE REQUESTED NON-STANDARD DEFAULT WINDOW SIZE
:		 IF THE REQUESTED PACKET SIZE IS GREATER THAN THE MAXIMUM
:		 ALLOWED(7 FOR MOD 8, 127 FOR MOD 128) VALUE THEN RETURN
:		 THE MAXIMUM ALLOWED VALUE TO THE DTE.
:		 IF THE REQUESTED PACKET SIZE IS LESS THAN THE MINIMUM
:		 ALLOWED(1) VALUE THAN RETURN THE MINIMUM ALLOWED VALUE 
:		 TO THE DCE.
:
:	INPUT	(R0)=REQUESTED DEFAULT WINDOW SIZE
:               (R9)=0 INDICATE XMT WINDOW SIZE
:		     1 INDICATE RCV WINDOW SIZE
:		R5->NEXT CHARACTER IN RTD BUFFER
:	OUTPUT	(R2)=0 NO ERROR FOUND IN REGISTRATION PARAMETER
:  		    =1 ERROR WAS FOUND IN REGISTRATION PARAMETER
:	USES	R3,R4
:	LINK	R8

PRCKPW	LR	R0,R0			:WINDOW SIZE>0?
	JG	CKPW10			:YES - CHECK UPPER BOUND
	LIS	R3,1			:NO - INDICATE MINIMUM VALUE IS 1
	J	CKPW30
CKPW10	LHI	R3,MAXWS
	TBT	RL,P128.F		:MOD 128?
	JN	CKPW20			:YES - UPPER BOUND IS 127
	LIS	R3,7			:NO - UPPER BOUND IS 7
CKPW20	CR	R0,R3			:WINDOW SIZE IN RANGE?
	JLER	R8			:YES - OK RETURN
CKPW30	LIS	R2,1
	LIS	R4,0			:POINT TO THE FIRST BYTE OF PARSAV
	LR	R9,R9			:CHECKING XMT WINDOW SIZE?
	JE	CKPW40			:YES - SKIP
	AIS	R4,1			:POINT TO NEXT BYTE OF PARSAV
CKPW40	STB	R3,PARSAV,R4,		:STORE MIN/MAX-ALLOWED VALUE
	JR	R8

:	PRNGO - THE FACILITIES THAT MAY BE NEGOTIATED AT ANY TIME
:		EACH ONE OF THE FOLLOWING BITS OF THE REGISTRATION PARAMETER
:		FIELD CORRESPONDS TO ONE FACILITY THANT MAY BE NEGOTIATED
:		AT ANY TIME (BIT 8 IS THE HIGH ORDER BIT)
:		BIT 6: THROUGHPUT CLASS NEGOTIATION FACILITY
:		BIT 5: FLOW CONTROL PARAMETER NEGOTIATION FACILITY
:		BIT 4: REVERSE CHARGING ACCEPTANCE FACILITY
:		BIT 3: FAST SELECT ACCEPTANCE FACILITY
:		BIT 2: OUTGOING CALLS BARRED FACILITY
:		BIT 1: INCOMING CALLS BARRED FACILITY
:		A BIT VALUE OF 1/0 INDICATES THAT THE DTE ASKS FOR THE DCE
:		TO INVOKE/REVOKE THE CORRESPONDING FACILITY.

PRNGO	LR	R9,R9			:FOR CHECKING?
	JN	PRNGO2			:NO - GO INVOKE/REVOKE THE FACILITY
: CHECK THE REGISTRATION CODE AND REGISTRATION PARAMETER
	SIS	R7,2			:ENOUGH DATA?
	JL	RTEREG			:NO -ERROR
	LHI	R13,CLOCPE^8!DIA073	:"REGISTRATION CODE REPEATED"
	LIS	R2,FACDUP
	SBT	R2,DUPREG,,		:FIRST TIME RECEIVE?
	JN	RTEREG			:NO - ERROR
	JAL	R4,PICKCH		:STRIP PARAMETER FIELD
	JAL	R4,PICKCH
	JR	R12

: INVOKE/REVOKE THE REQUESTED FACILITY
PRNGO2	
  IF	X.32
	LIS	R2,NGORCV
	SBT	R2,FACRST,RL2,		:INDICATE FACILITY IS MODIFIED
  EI	:X.32
	JAL	R4,PICKCH		:GET FIRST BYTE OF PARAMETER FIELD
	STB	R0,PARSAV,,
	JAL	R4,PICKCH		:GET SECOND BYTE OF PARAMETER FIELD
	STB	R0,PARSAV+1,,
	LIS	R3,0			:INDICATE MODIFY BIT
	LIS	R0,0			:INDICATE RESET BIT
	LR	R2,RL			:BIT OFFSET FROM MODIFY ADDRESS

: THROUGHPUT CLASS NEGOTIATION FACILITY
PTCL	LIS	R8,TCL.N		:BIT TO BE CHECKED
	TBT	R8,PARSAV,,		:INVOKE/REVOKE THROUGHPUT CLASS
	JE	PTCL10			:NEGOTIATION FACILITY?
	LIS	R0,1			:INDICATE SET BIT
PTCL10	LA	R1,TCN.F		:ADDRESS TO MODIFY
	JAL	R4,XMROTM,,
: FLOW CONTROL PARAMETER NEGOTIATION FACILITY
	LIS	R0,0			:INDICATE RESET BIT
PFCO	LIS	R8,FLOW.N		:BIT TO CHECKED
	TBT	R8,PARSAV,,		:INVOKE/REVOKE FLOW CONTROL PARAMETER
	JE	PFCO10			:NEGOTIATION FACILITY?
	LIS	R0,1			:INDICATE SET BIT
PFCO10	LA	R1,PSN.F
	JAL	R4,XMROTM,,
	LA	R1,PWN.F
	JAL	R4,XMROTM,,
: REVERSE CHARGING ACCEPTANCE FACILITY
: IF LOCAL CHARGING PREVENTION IS SUBSCRIBED, DTE IS NOT ALLOWED TO
: INVOKE REVERSE CHARGING ACCEPTANCE FACILITY
	LIS	R0,1			:INDICATE SET BIT
PRCA	TBT	RL,LCP.F		:LOCAL CHARGE PREVENTION INVOKE?
	JN	PRCA20			:YES-CANNOT NEGOTIATE RCVA
	LIS	R8,RCVA.N
	TBT	R8,PARSAV,,		:INVOKE/REVOKE REVERSE CHARGING
	JE	PRCA10			:ACCEPTANCE FACILITY?
	LIS	R0,0
PRCA10	LA	R1,RCNA.F
	JAL	R4,XMROTM,,
PRCA20	LIS	R0,0
: FAST SELECT ACCEPTANCE FACILITY
PFSA	
  IF	FSTSLT
	LIS	R8,FSA.N
	TBT	R8,PARSAV,,		:INVOKE/REVOKE FAST SELECT ACCEPTANCE
	JE	PFSA10			:FACILITY?
	LIS	R0,1
PFSA10	LA	R1,FSA.F
	JAL	R4,XMROTM,,
  EI
	LIS	R0,0
: OUTGOING CALLS BARRED FACILITY
POCB	LIS	R8,OBAR.N
	TBT	R8,PARSAV,,		:INVOKE/REVOKE OUTGOING CALLS BARRED
	JE	POCB10			:FACILITY?
	LIS	R0,1
POCB10	LA	R1,OBAR.F
	JAL	R4,XMROTM,,
	LIS	R0,0
: INCOMING CALLS BARRED FACILITY
PICB	LIS	R8,IBAR.N
	TBT	R8,PARSAV,,		:INVOKE/REVOKE OUTGOING CALLS BARRED
	JE	PICB10			:FACILITY?
	LIS	R0,1
PICB10	LA	R1,IBAR.F
	JAL	R4,XMROTM,,
	SIS	R7,2			:REMAINDER OF REGISTRATION LENGTH
	JR	R12

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:	PRCNL - ALLOCATION OF LOGICAL CHANNEL TYPE RANGES
:	OCTET 1 AND 2 OF REGISTRATION PARAMETER FIELD IS LIC
:	OCTET 3 AND 4 OF REGISTRATION PARAMETER FIELD IS HIC
:	OCTET 5 AND 6 OF REGISTRATION PARAMETER FIELD IS LTC
:	OCTET 7 AND 8 OF REGISTRATION PARAMETER FIELD IS HTC
:	OCTET 9 AND 10 OF REGISTRATION PARAMETER FIELD IS LOC
:	OCTET 11 AND 12 OF REGISTRATION PARAMETER FIELD IS HOC
:	OCTET 13 AND 14 OF REGISTRATION FIELD IS TOTAL NUMBER OF
:	LOGICAL CHANNELS

LIC.RT	EQ	0			:OFFSET TO LIC
HIC.RT	EQ	2			:OFFSET TO HIC
LTC.RT	EQ	4			:OFFSET TO LTC
HTC.RT	EQ	6			:OFFSET TO HTC
LOC.RT	EQ	8			:OFFSET TO LOC
HOC.RT	EQ	$A10			:OFFSET TO HOC
CCN.RT	EQ	$A12			:OFFSET TOTAL LOGICAL CHANNEL RANGE

PRCNL	LR	R9,R9			:CHECKING OR PROCESSING?
	JN	PRCNL2			:JUMP TO DO THE MODIFICATION
	LIS	R0,0
	STH	R0,SUMLCN,,		:RESET TOTAL CHANNEL NUMBER TO ZERO
	LHI	R13,CLOCPE^8!DIA069
	LB	R8,,R5			:PEAK PARAMETER LENGTH
	CLHI	R8,$A14			:PARAMETER LENGTH=14?
	JN	RTEREG			:NO - ERROR
	SHI	R7,1,R8			:ENOUGH DATA IN REGISTRATION FIELD?
	JL	RTEREG			:NO - ERROR
	JAL	R4,PICKCH		:STRIP PARAMETER LENGTH
	LHI	R13,CLOCPE^8!DIA073	:"REGISTRATION CODE REPEATED"
	LIS	R2,CNLDUP
	SBT	R2,DUPREG,,
	JN	RTEREG
:	COPY THE PARAMETER INTO TEMPORARY BUFFER
	LIS	R2,0			:INDEX OF THE TEMP BUFFER
CPYPAR	JAL	R4,PICKCH		:GET ONE CHARACTER FROM RTD BUFFER
	STB	R0,PARCNL,R2,		:SAVE IT
	AIS	R2,1
	SIS	R8,1
	JGBS	CPYPAR
	LHI	R13,CINVLD^8!DIA066
:	CHECKING OF INCOMING CHANNEL RANGE
CKICCN	LIS	R2,LIC.RT		:OFFSET OF LOC
	JAL	R4,PICKHW		:GET REQUESTED LOC
	LR	R3,R0			:LIC=0?
	JN	PRCN10	
	LIS	R2,HIC.RT		:OFFSET OF HOC
	JAL	R4,PICKHW		:GET REQUESTED HIC
	LR	R0,R0			:HIC=0?
	JE	CKTCN			:YES = GO CHECK TWO-WAY CHANNELS
	LIS	R0,0			:HIC MUST BE ZERO TOO
	JAL	R4,PUTHW
	J	CNLERR
PRCN10	LH	R0,HPC.LT,RL2,		:CURRENT HPC < 0?
	JL	PRCN12			:YES - NO PVC CHANNEL DEFINED
	CR	R3,R0			:REQUESTED LIC>CURRENT HPC?
	JG	PRCN14			:YES - OK
	AIS	R0,1			:REQUESTED LIC=CURRENT HPC+1
	JAL	R4,PUTHW
	J	CNLERR
PRCN12	CLH	R3,LCC.LT,RL2,		:REQUEST LIC>=CURRENT LCC?
	JGE	PRCN14			:YES - OK
	LHL	R0,LCC.LT,RL2,		:GET CURRENT LCC
	JAL	R4,PUTHW		:REQUESTED LIC=CONFIGURED LCC
	J	CNLERR			:EQUAL TO LOWEST CONFIGURED CHANNEL
PRCN14	LIS	R2,HIC.RT		:OFFSET OF HIC
	JAL	R4,PICKHW		:GET REQUESTED HIC
	CLH	R0,HCG.LT,RL2,		:REQUESTED HIC<=CURRENT HCC?
	JLE	PRCN16			:YES - OK
	LHL	R0,HCG.LT,RL2,		:REQUESTED HIC=CONFIGURE HCC
	JAL	R4,PUTHW
	J	CNLERR
PRCN16	CR	R0,R3			:REQUESTED HIC>=REQUESTED LIC?
	JGE	PRCN18			:YES - OK
	LR	R0,R3			:REQUESTED HIC=REQUESTED LIC
	JAL	R4,PUTHW
	J	CNLERR
PRCN18	SR	R0,R3			:GET NUMBER OF INCOMING CHANNELS
	AIS	R0,1
	AHM	R0,SUMLCN,,		:ACCUMULATE TOTAL CHANNEL NUMBERS
:	CHECKING OF TWO-WAY CHANNEL RANGE
CKTCN	LIS	R2,LTC.RT		:OFFSET TO REQUESTED LTC
	JAL	R4,PICKHW		:GET REQUESTED LTC
	LR	R3,R0			:LTC=0?
	JN	PRCN20
	LIS	R2,HTC.RT		:OFFSET TO REQUESTED HTC
	JAL	R4,PICKHW		:GET REQUESTED HTC
	LR	R0,R0			:HTC=0?
	JE	CKOCN			:YES - GO CHECK OUTGOING CHANNEL
	LIS	R0,0
	JAL	R4,PUTHW
	J	CNLERR	
PRCN20	LIS	R2,HIC.RT		:OFFSET TO REQUESTED HIC
	JAL	R4,PICKHW		:GET REQUESTED HIC
	LR	R0,R0			:REQUESTED HIC>0?
	JG	PRCN22			:YES - JUMP
	LH	R0,HPC.LT,RL2,		:CURRENT HPC>0?
	JL	PRCN24			:NO -JUMP
	CR	R3,R0			:REQUEST LTC>CURRENT HPC?
	JG	PRCN26			:YES - JUMP
	AIS	R0,1			:REQUESTED LTC=CURRENT HPC+1
	LIS	R2,LTC.RT		:OFFSET TO REQUESTESD LTC
	JAL	R4,PUTHW
	J	CNLERR
PRCN22	CR	R3,R0			:REQUEST LTC>REQUEST HIC?
	JG	PRCN26			:YES - OK
	LHI	R13,CINVLD^8!DIA079	:CHANNEL RANGES OVERLAPPED
	J	CNLERR
PRCN24	CLH	R3,LCC.LT,RL2,		:REQUEST LTC>=CURRENT LCC?
	JGE	PRCN26			:YES - OK
	LHL	R0,LCC.LT,RL2,		:REQUESTED LTC=CONFIGURED LCC
	LIS	R2,LTC.RT		:OFFSET TO REQUESTED LTC
	JAL	R4,PUTHW
	J	CNLERR
PRCN26	LIS	R2,HTC.RT
	JAL	R4,PICKHW
	CLH	R0,HCG.LT,RL2,		:REQUEST HTC<=CURRENT HCC?
	JLE	PRCN28			:YES - OK
	LHL	R0,HCG.LT,RL2,
	JAL	R4,PUTHW
	J	CNLERR
PRCN28	CR	R0,R3			:REQUEST HTC>=REQUEST LTC?
	JGE	PRCN29			:YES - OK
	LR	R0,R3			:NO - REQUEST HTC=REQUEST LTC
	JAL	R4,PUTHW
	J	CNLERR
PRCN29	SR	R0,R3			:GET NUMBER OF TWO-WAY CHANNELS
	AIS	R0,1
	AHM	R0,SUMLCN,,		:ACCUMULATE TOTAL CHANNEL NUMBER
:	CHECKING OF OUTGOING CHANNEL RANGE
CKOCN	LHI	R2,LOC.RT		:OFFSET TO REQUESTED LOC
	JAL	R4,PICKHW		:GET REQUESTED LOC
	LR	R3,R0			:LOC=0?
	JN	PRCN30			:NO - GO CHECK RANGE
	LIS	R2,HOC.RT		:OFFSET TO REQUESTED HOC
	JAL	R4,PICKHW		:GET REQUESTED HOC
	LR	R0,R0			:HOC=0?
	JE	CKSUM			:YES - GO CHECK TOTAL CHANNEL NO.
	LIS	R0,0			:HOC=0
	JAL	R4,PUTHW
	J	CNLERR
PRCN30	LHI	R2,HTC.RT		:OFFSET TO REQUESTED HTC
	JAL	R4,PICKHW		:GET REQUESTED HTC
	LR	R0,R0			:REQUESTED HTC>0?
	JG	PRCN32			:YES - GO CHECK RANGE
	LIS	R2,HIC.RT		:OFFSET TO REQUESTED HIC
	JAL	R4,PICKHW		:GET REQUESTED HIC
	LR	R0,R0			:REQUESTED HIC>0?
	JG	PRCN32			:YES - GO CHECK RANGE
	LH	R0,HPC.LT,RL2,		:CURRENT HPC<0?
	JL	PRCN34			:YES - GO CHECK RANGE
	CR	R3,R0			:REQUEST LOC>CURRENT HPC?
	JG	PRCN36			:YES - OK
	AIS	R0,1			:REQUEST LOC MUST BE GREATER THAN
	LHI	R2,LOC.RT
	JAL	R4,PUTHW
	J	CNLERR
PRCN32	CR	R3,R0			:REQUEST LOC>REQUESTED HIC/HTC?
	JG	PRCN36			:YES - OK
	LHI	R13,CINVLD^8!DIA079	:CHANNEL RANGES OVERLAPPED
	J	CNLERR
PRCN34	CLH	R3,LCC.LT,RL2,		:REQUESTED LOC>=CONFIGURED LCC?
	JGE	PRCN36			:YES - OK
	LHL	R0,LCC.LT,RL2,		:REQUESTED LOC=CONFIGURED LCC?
	LHI	R2,LOC.RT
	JAL	R4,PUTHW		
	J	CNLERR
PRCN36	LHI	R2,HOC.RT		:OFFSET TO REQUESTED HOC
	JAL	R4,PICKHW		:GET REQUESTED HOC
	CLH	R0,HCG.LT,RL2,		:REQUEST HOC<CONFIGURED HCC?
	JLE	PRCN38			:YES - OK
	LHL	R0,HCG.LT,RL2,		:REQUESTED HOC=CONFIGURED HCC
	JAL	R4,PUTHW
	J	CNLERR
PRCN38	CR	R0,R3			:REQUESTED HOC>=REQUESTED LOC?
	JGE	PRCN39			:YES - OK
	LR	R0,R3			:REQUESTED HOC=REQUESTED LOC
	JAL	R4,PUTHW
	J	CNLERR
PRCN39	SR	R0,R3			:GET NO. OF OUTGOING CHANNELS
	AIS	R0,1
	AHM	R0,SUMLCN,,		:ACCUMULATE TOTAL CHANNEL NO.
CKSUM	LHI	R2,CCN.RT		:OFFSET TO REQUESTE TOTAL CHANNEL NO.
	JAL	R4,PICKHW		:GET REQUESTED TOTAL CHANNEL NUMBER
	CLH	R0,SUMLCN,,		:ACCUMULATED=REQUESTED?
	JER	R12			:YES - OK
	LH	R0,SUMLCN,,		:REQUESTED=ACCUMULATED
	JAL	R4,PUTHW
	J	CNLERR


:	RETURN MAXIMUM/MINIMUM REQUESTED VALUE TO DTE
CNLERR	LH	R1,REGBUF		:GET CURRENT ADDRESS OF REGBUF
	LHI	R0,RG.CNL		:GET THE REGISTRATION CODE
	JAL	R4,WCI,,
	LHI	R0,$A14			:GET REGISTRATION LENGTH
	JAL	R4,WCI,,
	LIS	R9,0			:INDEX TO PARAMETER BUFFER
	LHI	R8,$A14			:PARAMETER LENGTH
:	COPY PARAMETER FIELD TO REGBUF
CNLER1	LB	R0,PARCNL,R9,		:GET ONE BYTE FOR PARAMETER BUFFER
	JAL	R4,WCI,,
	AIS	R9,1
	SIS	R8,1
	JGBS	CNLER1
	J	RTEREG

:	ALLOCATING LOGICAL CHANNEL TYPE RANGE

PRCNL2	
  IF	X.32
	LIS	R2,CNLRCV
	SBT	R2,FACRST,RL2,		:INDICATE FACILITY IS MODIFIED
  EI	:X.32
	JAL	R4,PICKCH		:GET PARAMETER LENGTH
	LR	R8,R0			:SAVE PARAMETER LENGTH
	SHI	R7,1,R8			:REMAINDER OF REGISTRATION LENGTH
	LHL	R3,AELCNT,RL2,		:NO. OF ACTIVE CHANNEL IN USE
	JN	PRCN82			:YES-DO NOT MODIFY CHANNEL RANGE
:	MODIFY & MARK HIC TO LIC AS REQUESTED
	LIS	R3,2				:INDICATE MODIFY HALFWORD
PRCN50	LIS	R2,HIC.RT			:OFFSET TO REQUESTED HIC
	JAL	R4,PICKHW			:GET REQUESTED HIC
	LR	R0,R0				:REQUESTED HIC=0?
	JN	PRCN52				:NO - GO UPDATE RANGE
	LHI	R0,0FFFF
PRCN52	LA	R1,HIC.LT,RL2,			:UPDATE HIC
	JAL	R4,XMROTM,,
	LIS	R2,LIC.RT
	JAL	R4,PICKHW			:GET REQUESTED LIC
	LR	R0,R0				:REQUESTED LIC=0?
	JN	PRCN54				:NO - GO UPDATE NEW RANGE
	LHI	R0,0FFFF
PRCN54	LA	R1,LIC.LT,RL2,
	JAL	R4,XMROTM,,

:	MARK HTC TO LTC AS REQUESTED
PRCN60	LIS	R2,HTC.RT
	JAL	R4,PICKHW		:GET REQUESTED HTC
	LR	R0,R0			:REQUESTED HTC=0?
	JN	PRCN62			:NO - GO UPDATE IT
	LHI	R0,0FFFF
PRCN62	LA	R1,HTC.LT,RL2,
	JAL	R4,XMROTM,,		:MODIFY HTC
	LIS	R2,LTC.RT
	JAL	R4,PICKHW		:GET REQUESTED LTC
	LR	R0,R0			:REQUESTED LTC=0?
	JN	PRCN64			:NO - GO UPDATE IT
	LHI	R0,0FFFF
PRCN64	LA	R1,LTC.LT,RL2,		
	JAL	R4,XMROTM,,		:MODITY LTC

:	MARK HOC TO LOC AS REQUESTED
PRCN70	LHI	R2,HOC.RT
	JAL	R4,PICKHW		:GET REQUESTED HOC
	LR	R0,R0			:REQUESTED HOC=0?
	JN	PRCN72			:NO - GO UPDATE IT
	LHI	R0,0FFFF
PRCN72	LA	R1,HOC.LT,RL2,
	JAL	R4,XMROTM,,		:MODIFY HOC
	LHI	R2,LOC.RT
	JAL	R4,PICKHW		:GET REQUESTED LOC
	LR	R0,R0			:REQUESTED LOC=0?
	JN	PRCN74			:NO - GO UPDATE IT
	LHI	R0,0FFFF
PRCN74	LA	R1,LOC.LT,RL2,
	JAL	R4,XMROTM,,		:MODIFY LOC
PRCN80	LH	R0,SUMLCN,,		:GET TOTAL NUMBER OF REQUESTED CHANNELS
	LA	R1,NEC.LT,RL2,		:UPDATE #OF CHANNEL ALLOWED ACTIVE 
	JAL	R4,XMROTM,,
	LCS	R9,2
	ST	R5,TEMP1
	ST	R6,TEMP2
	ST	R7,TEMP3
	JAL	R4,MRKCNL,,		:SET UP EPA.F ARRAY
	L	R5,TEMP1
	L	R6,TEMP2
	L	R7,TEMP3
PRCN82	JAL	R4,PICKCH		:UPDATE RTD BUFFER POINTER AND COUNT
	SIS	R8,1
	JGBS	PRCN82
	JR	R12

:	PICKHW - GET A HALFWORD FROM RTD BUFFER
:
:	INPUT	(R2)=OFFSET TO THE HALFWORD TO BE GOTTEN
:	OUTPUT	(R0)=HALFWORD RETURNED
:	USES	R1
:	LINK	R4

PICKHW	LB	R0,PARCNL,R2,		:GET FIRST CHARACTER
	LB	R1,PARCNL+1,R2,		:GET SECOND CHARACTER
	SLHL	R0,8
	OR	R0,R1
	JR	R4

:	PUTHW - PUT A HALFWORD INTO RTD BUFFER
:
:	INPUT	(R0)=HALFWORD TO BE WRITTEN
:		R2=OFFSET TO THE HALFWORD TO BE WRITTEN
:	USES	R1
:	LINK	R4

PUTHW	LR	R1,R0			:SAVE THE INPUT
	SRHL	R1,8			:GET FIRST CHARACTER
	STB	R1,PARCNL,R2,		:STORE FIRST BYTE
	NHI	R0,0FF			:GET SECOND CHARACTER
	STB	R0,PARCNL+1,R2,
	JR	R4
:

    IF	X.32
PRIDN	LR	R9,R9			:CHECKING OR PROCESSING?
	JN	PRIDN2			:GO TO PROCESS IT
	LHI	R13,CLOCPE^8!DIA069
	JAL	R4,PICKCH		:GET PARAMETER LENGTH
	SIS	R7,1
	LR	R8,R0
	JER	R12
	SR	R7,R8			:ENOUGH DATA IN REGISTRATION FIELD?
	JL	RTEREG
	LHI	R13,CLOCPE^8!DIA073
	LIS	R2,IDNDUP
	SBT	R2,DUPREG,,
	JN	RTEREG
PRID10	JAL	R4,PICKCH
	SIS	R8,1
	JGBS	PRID10
	JR	R12
:
PRIDN2	JAL	R4,PICKCH		:GET PARAMETER LENGTH
	SIS	R7,1
	LHI	R2,REA088		:ZERO PARAMETER LENGTH
	STB	R2,DIAPAR,,
	LR	R8,R0	
	JER	R12
	SR	R7,R8			:REMAINDER OF REGISTRATION LENGTH
	LHI	R2,REA089		:NOT IN WAITING FOR ID [,SIG] STATE
	STB	R2,DIAPAR,,
	LB	R2,IDSTAT,RL,		:GET THE STATE OF ID PROCESS
	CLHI	R2,WATID		:STATE=WAITING FOR ID?
	JN	PRID10			:NO - DISCARD THE ELEMENT
	LIS	R2,0			:CLEAR PARAMETER FIELD OF DIAGNOSTIC ELEMENT
	STB	R2,DIAPAR,,		
	SBT	RL,IDNRCV,,		:INDICATE RECEIVING IDENTITY ELEMENT
	L	R13,IDNPNT,RL2,RL2	:GET BUFFER POINT
	STB	R0,,R13			:SAVE PARAMETER LENGTH
	LIS	R1,1			:SET BUFFER INDEX TO 1
PRID20	JAL	R4,PICKCH		:COPY PARAMETER TO IDN BUFFER
	OHI	R0,80
	STB	R0,,R1,R13
	AIS	R1,1
	SIS	R8,1
	JGBS	PRID20
	JR	R12
:
PRSIG	LR	R9,R9			:CHECKING OR PROCESSING?
	JN	PRSIG2			:GO TO PROCESS IT
	LHI	R13,CLOCPE^8!DIA069
	JAL	R4,PICKCH		:GET PARAMETER LENGTH
	SIS	R7,1
	LR	R8,R0
	JER	R12
	SR	R7,R8			:ENOUGH DATA IN REGISTRATION FIELD?
	JL	RTEREG
	LHI	R13,CLOCPE^8!DIA073
	LIS	R2,SIGDUP
	SBT	R2,DUPREG,,
	JN	RTEREG
PRSG10	JAL	R4,PICKCH
	SIS	R8,1
	JGBS	PRSG10
	JR	R12
:
PRSIG2	JAL	R4,PICKCH		:GET PARAMETER LENGTH
	SIS	R7,1
	LHI	R2,REA088		:ZERO PARAMETER LENGTH
	STB	R2,DIAPAR,,
	LR	R8,R0	
	JER	R12
	SR	R7,R8			:REMAINDER OF REGISTRATION LENGTH
	LHI	R2,REA089		:NOT IN WAITING FOR ID [,SIG] STATE
	STB	R2,DIAPAR,,
	LB	R2,IDSTAT,RL,		:GET THE STATE OF ID PROCESS
	CLHI	R2,WATID		:STATE=WAITING FOR ID?
	JN	PRSG10			:NO - DISCARD THE ELEMENT
	LIS	R2,0
	STB	R2,DIAPAR,,		:CLEAR PARAMETER FIELD OF DIAGNOSTIC ELEMENT
	SBT	RL,SIGRCV,,		:INDICATE RECEIVING SIGNATURE ELEMENT
	L	R13,SIGPNT,RL2,RL2	:GET BUFFER POINT
	AIS	R0,1			:LENGTH=PARAMETER LENGTH+1(FOR "0BB")
	STB	R0,,R13
	LHI	R0,0BB			:STICK A SEMI-COLON AFTER USERNAME
	STB	R0,1,R13
	LIS	R1,2			:SET BUFFER TO 2
PRSG20	JAL	R4,PICKCH		:MOVE PARAMETER FIELD OF SIGNATURE
	OHI	R0,80			:ELEMENT TO SIG BUF
	STB	R0,,R1,R13
	AIS	R1,1
	SIS	R8,1
	JGBS	PRSG20
	JR	R12

    EI	X.32	:X.32
  EI	X.25
:: END OF CHANGES	:JS-ONREG
 if LIIFLAG
	STTL(PCX000 - LOG2 FINAL PROCESSING & ICRM CREATION)
:- BEGIN ----------------------------------------------------- :HJR-SWBT1
pcx000
	jal	R14,getcvd		:process CUD
	jal	R14,gettid		:finish up
:
: Now determine if we have what it takes to complete the call
:
	lhl	R1,iport
	tbt	R1,nuical,,	:first, is it a NUI call?
	jefs	pcx010		:if not, do more checking
	lhi	R0,sm.nui	: else set nui call smo set
	j	pcx100		: and try for circuit

: NOTE:  any TKSUP calls should have been converted to LOG-I in CKADRX.
: For NONTN call, the SDL is not shipped.  Also, for NONTN or no called
: address, we ship info from the CUD, if present.
pcx010	lhi	R0,sm.nc	:preset normal smo set
	tbt	R1,ntncal,,	:NONTN call?
	jnfs	pcx030		:if not, try for normal call
	lhi	R0,sm.nnt	: else set NONTN call smo set

: At this point, a call is allowed only if a Calling Address or CUD is present.
pcx030	lhi	R12,dia064	:preset generic call setup problem
	lr	R3,R1		:save iport # for CUD check
	slls	R1,3		:make doubleword index
	lb	R2,dtesav+7,R1,	:have calling address?
	jnfs	pcx100		:if yes, try for circuit
	tbt	R3,cudusd,,	:CUD present?
	je	rtecal		:if not, clear call
:
: Build ICRM in IEDBUF.
:
pcx100	jal	r14,mkicrm	:go build the ICRM
	j	rtd020,,	:done

:*******************************************************************************
:*******************************************************************************
:
: MKICRM - Make ICRM
: Builds the ICRM in port 0 IDBUF since we don't know how big it will be.
:
:	Input -	DTESAX = Called Address
:		DTESAV = Calling Address
:		DTESDX,DTESDV = DNIC present bit flags
:		NUISAV = NUI save area
:		IEDBUF = Call User Data
:		RVCHRG = reverse charge bit flags
:		SAVTID = SAVED tid
:		SAVSPD = SAVED Telenet circuit speed (if TPIDS)
:		TEMP6  = NUI count (bytes 0:1)
:		IPORT  = iport #
:		[R0]   = SMO bit flags (bytes 2:3)
:
:	Output - ICRM port 0 message in dport 0 idbuf
:
:	Calls - GETCSI, GETCCT, GCI, WCI
:
:	Uses R0-R9,R12-R14,temp0,temp3-temp9
:	Uses idbuf,dport
:	Link is R14
:
:	R13 is msg size accumulator
:	temp0 := saved SMO bit flags
:	temp3 := saved MKICRM return address
:	temp4 := temporary return addres save are for SMO subroutines
:	temp5 := full msg size pntr into idbuf
:	temp7 := ICRM msg size pntr into idbuf
:	temp8 := ICRM MOs size pntr into idbuf
:	temp9 := SMOs size pntr into idbuf
:
:	R1 = IDBUF index throughout
:
: * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
: ICRM message object ID literals.
: Some are 2 byte long IDs, others are one byte of ID + one byte of length.
: Some include the entire MO - these are 3 bytes long.
: The literals are in reverse byte order for making sequential calls to WCI.
:
x4icrm	eq	0347F		:ICRM - 2*ID
x4rmos	eq	00C30		:required MOs - count/ID
x4icfl	eq	002375F		:ICRM flags ID - length/2*ID
x4icfs	eq	00007		:ICRM lfags data - false/bits
x4ohst	eq	0024E		:our host # - length/ID
x4cct	eq	00142		:CCT - length/ID
x4smos	eq	031		:supplemental MOs - ID
x4upls	eq	048		:unparsed login string MO - ID
x4sdl	eq	077		:specified dest list MO - ID
x4rpoa	eq	00516		:RPOA octet string - length/Univ IA5 str ID
x4uia5	eq	016		:Universal IA5 string - ID
x4oadr	eq	047		:our address MO - ID
x4tc	eq	00149		:thruput class MO - length/ID
x4iix	eq	0FF0143		:IIX capable MO - true/length/ID
x4rc	eq	0FF0150		:reverse charge MO - true/length/ID
:
: * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
: MO bit flags used to select the SMO set for each type of call.
: Bit definitions withing the halfword of bit flags are:
:
:	bit		definition
:
:	 0	= make unparsed login string (UPLS) from NUISAV
:	 1	= not used
:	 2	= put username[:host#] from IEDBUF (CUD) into UPLS
:	 3	= need SDL from RPOA and/or DTESAX
:	 4	= need OADR MO from DTESAV
:	 5	= need thruput class MO, call GETCSI
:	 6	= need IIX capable MO, always
:	 7	= need reverse charge MO, check RVCHRG
:
sm.nc	eq	01F00		:normal call - sdl,oadr,tc,iix,rc
sm.nnt	eq	02F00		:NONTN call - CUD,oadr,tc,iix,rc
				:NOTE:  CUD --> UPLS MO
sm.nui	eq	09F00		:NUI call - NUI,sdl,oadr,tc,iix,rc
				:NOTE:  NUI + sdl --> UPLS MO
:
: * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
: Standard length definitions for ICRM message and MO set(s)
:
molsmh	eq	2		:length of SMO set header - ID/len
molrmo	eq	0C+2		:total length of RMO set
molich	eq	3		:length of ICRM set header
molpre	eq	4		:length of fixed header following msg size field
molcrh	eq	6		:length of rest of ICRM fixed header
: * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
:
MKICRM
	sth	R0,temp0		:save smo set bit flags:
	st	R14,temp3		:save return address
:
: First build the ICRM Header
:
	lhi	R1,idbia		:get offset to port 0 idbuf
	sth	R1,idbuf		:save
	lis	R0,0			:set dport to 0
	sth	R0,dport

	:set up HW of count, only save pointer to second byte for now
	jal	R12,mo2byt		:2 bytes for total size
	l	R6,be,R1,
	st	R6,temp5		:save pntr to ICRM msg size

	lhi	R0,nm.crm		:message type + flags=0
	exhr	R0,R0			:make dport = 0
	jal	R12,mo4byt

	: save pointer to full ICRM MOs size in temp7
	lis	R0,0
	jal	R12,mo2byt		:dummy 2 bytes for size
	l	R6,be,R1,		:save pointer to message size
	st	R6,temp7
	jal	R12,mo2byt		:dispatcher key = 0

	lhl	R0,iport		:local key
	exbr	R0,R0			:switch, gets put in 1 byte at a time
	jal	R12,mo2byt
:
: Now build ICRM as X.409 message
: First put in ICRM constructor ID and save length placeholder in temp8
:
	lhi	R0,x4icrm		:bytes are backwards for WCI
	jal	R12,moinit		:put in buffer
	st	R6,temp8		:save pntr to count byte for later
:
: Next, construct the RMO set
:
	lhi	R0,x4rmos		:1 byte RMO seq ID & 1 byte length
	jal	R12,mo2byt		:length is always the same (12 bytes)

	li	R0,x4icfl		:get 3 bytes of ICRM flags
	jal	R12,moinit		:these are always the same
	lhi	R0,x4icfs		:2 bytes of flags data
	jal	R12,mo2byt

	lb	R4,lh.mt,RL,		:get our host #
	lhl	R0,hosts,R4,R4
	exbr	R0,R0			:reverse order for WCI
	exhr	R0,R0			:put in upper HW
	ohi	R0,x4ohst		:1 byte orig host ID & 1 byte length
	jal	R12,mo4byt		:length is always the same (2 bytes)

	jal	R12,getcct		:get in CCT - in R0
	nhi	R0,1F			:knock off high bits for LOG-II
	exhr	R0,R0			:set for call to moinit
	ohi	R0,x4cct		:1 byte CCT ID & 1 byte length
	jal	R12,moinit		:length is always the same (1 byte)
:
: Now build the SMO set.
: R13 will contain the SMO count
:
	lhi	R0,x4smos		:1 byte SMO seq ID
	jal	R12,moinit
	st	R6,temp9		:save pntr
	lis	R13,0			:init count

smos00	lhl	R8,temp0		:get SMO bit flags
	jffoh	R8,smos10		:any more to put in
	jfs	smos20			:else go finish up
smos10	rbt	R9,temp0		:turn off bit
	slls	R9,1			:make HW index
	lhl	R9,smotbl,R9,		:get jump offset
	j	smotbl,R9

: Done putting in SMOs, put in counts and tell BFRITD
smos20	l	R1,temp9	:put in smo total
	stb	R13,0,R1

	ahi	R13,molsmh+molrmo	:add in smo header + rmo len
	l	R1,temp8		:and set in ICRM MO total
	stb	R13,0,R1

	ahi	R13,molich+molpre	:add in ICRM MO header + mo predecessors
	l	R1,temp7		:and set in ICRM header message size
	stb	R13,0,R1

	ahi	R13,molcrh		:add in rest to get total message len
	l	R1,temp5		:and set at begining of message
	stb	R13,0,R1

	lhl	R1,iport		:clear transparency mode
	rbt	R1,tpar2
	l	R14,temp3		:and return
	jr	R14

: * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
: The SMO routines will only add the specified MO if there is data in the 
:  appropriate place to be added.
: All return to SMOS00
:
table(smotbl)
 tentry(smonui)		:add NUI in unparsed login string MO
 tentry(smcrsh)		:not used yet, shouldn't be set
 tentry(smocud)		:add CUD username MO from IEDBUF
 tentry(smosdl)		:add specified destination list MO
 tentry(smoadr)		:add calling address MO
 tentry(smotc)		:add thruput class MO
 tentry(smoiix)		:add IIX MO
 tentry(smorc)		:add reverse charge MO
 tentry(smcrsh)		:not used yet, shouldn't be set
 tentry(smcrsh)
 tentry(smcrsh)
 tentry(smcrsh)
 tentry(smcrsh)
 tentry(smcrsh)
 tentry(smcrsh)
 tentry(smcrsh)
 tentry(smcrsh)

: * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
:
smcrsh	trap(R9,CF)	:tried to create unknown MO
:
: * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
: SMONUI -
: If NUICAL then copy contents of NUISAV to Unparsed Login Characters MO.
:
smonui	lhi	R0,x4upls	:set unparsed login string MO
	jal	R12,moinit	:REM - retruns with BE pntr in R6
	lhl	R9,temp6	:get length of NUI
	stb	R9,0,R6		:save count
	ar	R13,R9		:add to total
	lis	R8,0		:init offset

smnui1	lb	R0,nuisav,R8	:get a character
	nhi	R0,7F		:remove parity bit
	jal	R4,wci		:put in buffer
	ais	R8,1		:increment offset
	sis	R9,1		:decrement count
	jgbs	smnui1		:if more, continue
	j	smos00		:done

: * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
: SMOCUD -
: Move data in IEDBUF up to first semi-colon into UPLS MO
:
smocud
	lhl	R1,iedbuf	:get pntr
	cbct(R3,R1)		:get count
	lr	R3,R3		:any data
	je	smcud8		:return if not

	jal	R4,gci		:get count
	lr	R9,R0		:and save
	je	smcud8		:return if nothing

	lr	R7,R1		:save copy of iedbuf pntr
	lhl	R1,iport
	sbt	R1,cudsnt,,	:mark cud sent in ICRM
	lhl	R1,idbuf	:get idbuf pntr
	lhi	R0,x4upls	:set up UPLS MO
	jal	R12,moinit
	lr	R12,R1		:save copy of idbuf index
	lis	R8,0		:init counter

: If there is any data following the semi-colon (eg. password), we'll
: need to put the remaining character count into IEDBUF in place of the
: semi-colon.  Don't send semi-colon, discard it instead.
smcud2	l	R3,bb,r7,	:peek at next character
	lb	R0,0,R3
	nhi	R0,7F		:strip off any parity
	clhi	R0,03B		:semi-colon?
	jefs	smcud4		:done if yes
	lr	R1,R12		:point to idbuf
	jal	R4,wci		:put in char
	ais	R8,1		:increment count of chars moved
	lr	R1,R7		:point to iedbuf
	jal	R4,gci		:get char for real
	sis	R9,1		:decrement count of chars left
	jn	smcud2		:continue if more

smcud4	sis	R9,1		:anything left?
	jlefs	smcud6		:skip if not
	l	R3,bb,R7,	:else put count remaining into IEDBUF
	stb	R9,0,R3
	jfs	smcud7		:go finish up
smcud6	lr	R1,R7		:here to make sure IEDBUF is empty
	jal	R4,empty,,
smcud7	stb	R8,0,R6		:put in UPLS MO length
	ar	R13,R8		:update total
smcud8	lhl	R1,idbuf	:restore IDBUF index
	j	smos00		:done

: * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
: SMOSDL -
: Create specified destination list MO.
: This is actually a sequence of type 'Universal' IA5 strings.
: If RPOA then put in "-rpoa" as the first IA5 string.
: Add in address from DTESAX as an IA5 string.
: 
smosdl
	lhl	R9,iport
	lr	R8,R9			:make copy
	slls	R8,3			:and convert to dblword offset
	lb	R0,dtesax+7,R8,		:get addr length
	je	smos00			:return up if no addr
	lr	R7,R0			:else save count for "momvad"

	lhi	R0,x4sdl		:put in sdl ID
	jal	R12,moinit		:returns sdl length pntr in R6
	lis	R14,2			:init length, account for string header

	tbt	R9,rpoa.f,,		:RPOA?
	jefs	smsdl2			:if not, skip this part
	lhi	R0,x4rpoa		:put in rpoa string header
	jal	R12,mo2byt
	ais	R14,2			:add in string header
	lhl	R8,rpoa.r,R9,R9		:get RPOA
	jal	R12,modnic		:put in buffer

smsdl2	exbr	R0,R7			:move count and make 2nd byte
	tbt	R9,dtesdx,,		:test for DNIC
	jefs	smsdl3			:skip if none
	ahi	R0,100			:add count for "-"
smsdl3	ohi	R0,x4uia5		:or in Universal octet string ind
	jal	R12,mo2byt		:put in buffer
	li	R8,dtesdx		:to check for DNIC
	slls	R9,3
	ai	R9,dtesax		:for use by MOMVAD
	jal	R12,momvad		:go move address

smsdl8	stb	R14,0,R6		:put in sdl length
	ar	R13,R14			:and add to total
smsdl9	j	smos00			:done

: * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
: SMOADR -
: Create OADR MO.  Put in address from DTESAV as an ASCII string.
: 
smoadr
	lhl	R9,iport
	slls	R9,3
	lb	R7,dtesav+7,R9,		:get addr length
	je	smos00			:done if no addr

	lhi	R0,x4oadr		:start MO
	jal	R12,moinit

	lis	R14,0			:init count
	li	R8,dtesdv		:to check for DNIC
	ai	R9,dtesav		:for use by MOMVAD
	jal	R12,momvad		:go move address
	stb	R14,0,R6		:put in count
	ar	R13,R14			:and add to total
	j	smos00			:done

: * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
: SMOTC -
: Create throughput class MO.
: 
smotc
	jal	R12,getcsi		:get circuit speed
	nhi	R0,7F			:remove high order bit
	sis	R0,1			:convert to throughput class
	exhr	R0,R0			:set for moinit
	ohi	R0,x4tc			:get MO ID and length (reverse order)
	jal	R12,moinit		:put in everything
	j	smos00			:done

: * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
: SMOIIX -
: Create IIX MO set to true (FF).
: 
smoiix
	li	R0,x4iix		:get MO ID, length, FF (reverse order)
	jal	R12,moinit		:put in everything
	j	smos00			:done

: * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
: SMORC -
: Create reverse charge MO set to true (FF) if reverse charging requested.
: 
smorc
	lhl	R4,iport		:get to test for RC
	tbt	R4,rvchrg,,
	je	smos00			:no MO if no reverse charge

	li	R0,x4rc			:get MO ID, length, FF (reverse order)
	jal	R12,moinit		:put in everything
	j	smos00			:done

: * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
: SMO subroutines
:
:**********
: MOINIT - put MO ID and dummy count into the buffer.
: Link is R12.  Enter with bytes in R0, buffer offset in R1.
: Outputs buffer end pointer (BE) in R6.  Uses R0-R4,R6,R12
: Writes up to 3 bytes into buffer.  If 2nd is 0 then only writes 2

moinit	jal	R4,wci		:put in 1st byte
	srls	R0,8		:get second
	jefs	moini2		:only want 2 if 2nd is 0
	jal	R4,wci
	ais	R13,1		:count 3rd byte
	srls	R0,8		:get last byte
moini2	jal	R4,wci
	ais	R13,2		:count 1st two bytes
	l	R6,be,R1,	:save pointer to length entry
	jr	R12		:return

:**********
: MODNIC - convert BCD DNIC to ASCII and put in the buffer.
: Link is R12.  Enter with DNIC in R8.
: Uses R0-R4,R8,R12.  Increments count in R14.
:*****
: MO4NIB - same except no "-" and R0 is alread set, no increment
:*****
: MO2NIB - only puts in 2 nibbles in right hand byte of R0, no increment
:
modnic	lhi	R0,0AD		:put in "-"
	jal	R4,wci
	lr	R0,R8		:get DNIC
	ais	R14,5		:account for "-"
	jfs	mo4nib

mo2nib	li	R8,mo2byt	:point to finish up 2 nibbles
	jfs	modni4

mo4nib	li	R8,modni6	:point to finish up 4 nibbles
	:name nibbles A,B,C,D and start with word - |  |  |AB|CD|
	: or with - |  |  |  |CD| when enter at modni3
	slls	R0,4		:|  | A|BC|D |
	srhls	R0,4		:|  | A| B|CD|
modni4	slls	R0,0C		:|A |BC|D |  |
	srhls	R0,4		:|A |BC| D|  |
	srls	R0,4		:| A| B|C |D |
	srhls	R0,4		:| A| B| C| D|
	oi	R0,0B0B0B0B0	:make ascii
	exbr	R0,R0		:| A| B| D| C|
	jr	R8		:go do appropriate finish

modni6	exhr	R0,R0		:| D| C| A| B|
	exbr	R0,R0		:| D| C| B| A|
	j	mo4byt		:go put in 4 bytes

:**********
: MO4BYT - put 4 bytes in the buffer.
: Link is R12.  Enter with bytes in R0.
: Uses R0-R4,R8,R12.  Increments count in R14.
:*****
: MO2BYT - put 2 bytes in buffer
mo2byt	lis	R8,2		:put in 2 bytes
	jfs	mo4by2
mo4byt	lis	R8,4		:put in 4 bytes
mo4by2	jal	R4,wci
	srls	R0,8
	sis	R8,1
	jgbs	mo4by2
	jr	R12		:return

:**********
: MOMVAD - move BCD address to buffer.
: Link is R12.  Enter with R7 = count, R8 = pntr to DNIC bits, R9 = addr pntr.
: Uses R0-R4,R7-R9,R12.  Increments count in R14.
:
momvad	st	R12,temp4,,		:save return
	lhl	R0,iport
	tbt	R0,0,R8			:check for DNIC
	jefs	momva4			:if no DNIC
	lhl	R8,0,R9,		:else put in DNIC
	jal	R12,modnic
	ais	R9,2
	sis	R7,4

momva4	ar	R14,R7			:add remaining count
momva6	chi	R7,2			:2 nibbles left?
	jl	momva8			:skip if not
	lb	R0,0,R9,		:else get them
	jal	R12,mo2nib		:and stick them in the buffer
	ais	R9,1
	sis	R7,2
	j	momva6

momva8	lr	R7,R7			:anything left?
	jefs	momva9			:skip if not
	lb	R0,0,R9,		:get last nibble
	srhls	R0,4			:it must have been an upper nibble
	ohi	R0,0B0			:make ASCII
	jal	R4,wci

momva9	l	R12,temp4,,		:get back return addr
	jr	R12

: * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
:-- END ------------------------------------------------------ :HJR-SWBT1
 ei :LIIFLAG
    3/df