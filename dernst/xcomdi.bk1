:****************************************************************************:
:                                                                            :
:                     X CODE DIAGNOSTIC ROUTINE PACKAGE                      :
:                                                                            :
:****************************************************************************:
:
:	To enable this package, the command file must set the switch 
:	DDTDIA to nonzero.
:
:
:	The ISIS command "?STAT" causes control to go to STATUS.LIB.
:	STATUS.LIB contains a command table which causes control to
:	go to any of many debug routines in XCOMDI.  STATUS.LIB also
:	contains a quit command which gets you back to DDT.  A typical
:	sequence of events might therefore be:
:	1. slot code running halts/breakpoints.  registers get saved in 
:		CRREG after a halt, and saved in DDT register save area 
:		after a breakpoint.
:	2. user logs into DDT, enters a "?STAT" command to get access
:		to debug routines.
:	3. user executes some debug routine.
:	4. user returns to DDT, but current (altered) registers get saved
:		on top of original slot code registers.
:	5. user continues execution from breakpoint, but DDT has restored
:		the second set of registers.
:
:	The ?STAT command "XCREG" saves all crash registers from CRREG in
:	the debugger register save area.  Entering STATUS.LIB via the
:	?STAT command causes current register contents to be saved in the
:	debugger save area.  When STATUS.LIB returns to DDT it reloads
:	its registers from this same area.  So why bother? Apparently
:	each time DDT is entered either by a breakpoint or by an SVC
:	it saves current registers in the same area, and when it leaves
:	to go do something (like continue from breakpoint) it reloads them.
:	The "XCREG" command allows the registers saved from the crash to 
:	be restored and used by assuring that DDT always has that set saved.
:
:	All routines may be aborted through NAD with %c.
:
:	An index of the routines is available through the NAD-DDT
:	query    ::?STAT (HELP command)
:
:	This package contains the following diagnostic routines:
:
:	1. Bufferlet trace
:	    Activated through NAD-DDT with the command    BH
:	    this routine lists each buffer by buffer number and prints
:	    any contents in hex.  Empty buffers are so indicated.
:
:	    A display of the contents in ASCII may be obtained with the
:	    command     BA
:
:	    Non-empty buffers only may be displayed with the commands
:	        BHN    for hex
:	        BAN    for ASCII
:
:	2. Packet/frame trace dump
:	    Packet trace table PTTBL and frame trace table FTRTBL are
:	    dumped with the command    PFT
:	    The routine will prompt with "SEC=" for the number of seconds
:	    to continue dumping.  Reply with     ::numberofsecondsinhex
:
:	    Packet trace only may be obtained with the command   PT
:	    Frame trace only may be obtained with the command    FT
:
:	    Packet trace interprets packets.
:
:	3. IRING/ORING dump
:	    This routine dumps the IRING or ORING and interprets the
:	    ISIS message type.  Contents are also dumped in ASCII.
:
:	    Activated by the command     RI (for the IRING) 
:	                              or RO (for the ORING)
:	    the routine prompts with "+".  The routine will start at the
:	    top of the ring and dump until the ring pointer is reached
:	    if given the following replies:
:
:	    ::<cr>
:	    ::B    for both rings
:
:	    To continue dumping the rings for a time, follow the "+"
:	    prompt with a number of seconds (hex) :
:
:	    ::seconds
:	    ::Bseconds    for both rings
:
:	    To dump the entire ring, the routine can be asked to "wrap"
:	    with the commands
:
:	    ::Wseconds
:	    ::WBseconds    for both rings
:
:	    This routine make a guess at the first ISIS message in the ring.
:
:	4. SIO status interpreter
:	    SIO status tables SIOTn are interpreted for each unit available.
:
:	    Activated with the command    SIO
:
:	5. Packet buffer trace table dump
:	    This routine dumps received packets as indicated by the
:	    packet buffer trace table PBTTBL starting at the entry
:	    following the next entry to be used.  Activated by the command
:
:	        PB
:
:	    the routine prompts for the number of seconds to continue
:	    dumping exactly as the packet frame trace routine, namely,
:
:	        SEC=
:
:	    It expects a reply of the form    ::numberofsecondsinhex
:
:	6. Output sector dump (Available for HDLC only)
:	    Starts at the entry following the one pointed at by CURSEC.
:	    Activated by the command     OS
:
:	    Prompts for time as in packet buffer dump.
:	    Prompts for line to dump.  <cr> will dump all lines.
:
:	7. Move registers from CRREG to XRSAVE save area.  Registers
:	    are reloaded from this area by STATUS.LIB before returning
:	    to DDT.  If this is not done then the contents of the 
:	    registers upon entry to STATUS.LIB are used.
:	    Activated by the command	CREG

:	8. The SELECT command will allow several diagnostics to be run in
:	    sequence.  A list of choices will be displayed.  Choose any of
:	    the routines listed in any order.  Repeats are allowed.  Choices
:	    are separated by any nonalphanumeric chararacter(s).  The list
:	    is terminated by a return. Routine names that are not recognized
:	    will be ignored.
:
:	    SELECT will then prompt for specific dispatcher ports, links,
:	    and/or channels to display.  Reply with numeric choices up to 4
:	    digits each, separated by nonnumeric characters.  Only the last
:	    4 digits are used.  Any port, link, or channel that is NOT
:	    specified will be filtered out of the display.  Any number
:	    specified that is out of range will be ignored.
:	    A solitary carriage return at the prompt will allow ALL
:	    ports/links/channels to be displayed. A reply that consists
:	    entirely of nonnumerics and out of range values will be
:	    treated as a solitary return.
:
:	    NOTE: When making several entries in SELECT through NAD, you
:	    will probably have to use the %R command.
:
:	    SELECT then starts the diagnostic routines in turn.  Each output
:	    is separated from the output of the next routine by a label.  A
:	    dismiss is performed after the whole list has been run.
:
:	    During a run, any character enterd at the terminal will
:	    interrupt SELECT and bring it back to the ?STAT level.
:
:	    The interrupt will not be noticed until the routine that is
:	    currently running is finished, so a control-O (%O in NAD)
:	    will help if you are impatient.  The control-O will probably
:	    cause you to lose the ?STAT prompt.
:
:	    If you are VERY impatient, you may interrupt out with control-C
:	    (%C in NAD), but this will also take you out of the ?STAT.
:
:	9. REDO will start the routine list set up in the previous
:	    SELECT. It can also be interrupted as in SELECT.
:
:	10. SNAP will give a single-shot display of the routines set up
:	     in the previous SELECT.
:
:	11. Error table dump
:	     Not yet implemented.  Will indicate error table entries with
:	     nonzero counts.

	GL	X.HELP

  IF	DDTDIA

	GL	X.XF,X.XBA,X.XPB,X.XP,X.XBHN,X.XBH
	GL	X.XRO,X.XRI,X.XBAN,X.XPF,DSTART,DSTRT2
	GL	DS.GCH,DS.DIG,DS.DEL,DS.NUM
	GL	DDMMY1,DDMMY2
	GL	X.SF,X.SPB,X.SP,X.SBHN
	GL	X.SRO,X.SRI
	GL	SELECT,REDO,SNAP,XOSTR			:LSH 17-DEC-86
  IF	DDTDIA-1
	GL	AVERAG,DPRT,IPRT,ILINK,ILINE,ERRRPT
    IF	DDTDIA-2
	GL	TCAN,GPKT,DPKT,REMRK,PAWS,VUE.00,SSSEND
    EI	DDTDIA-2
  EI	DDTDIA-1
   IF	HDLC
	GL	XSIO
   EI	HDLC

	SEG	A.RTBL
:	BUFFERLET TRACE MESSAGES AND TABLES

XDBEQ	SC	/"2D"2D"3E/		: -->
SIAASC	AC	/0123456789ABCDEF/
XDBUFL	SC	/"8D"8ABUF /
XDBEM	SC	/ EMPTY/

:	IRING/ORING TRACE MESSAGES AND TABLES
XDRPLU	SC	/"2B/			:+
M.I	SC	/I /
M.O	SC	/O /
XDRMS5	SC	/    /
XDRMS4	SC	/NDL/			:NEEDLE
XDRMS3	SC	/DTA/			:DATA
XDRMS2	SC	/"8D"8ARING EMPTY"8D"8A/

	BND	2

CAPITT	HC	0,0,0,0,0,0,7FFF,0FFE0
XDRECH	HC	0,0,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFE
	HC	0,0,0FFFF,0FFFF,0FFFF,0FFFF,0FFFF,0FFFE
XDRVL	HC	0082,0000		:VARIABLE LENGTH MESSAGE FLAGS

M.SINT	SC	/"8A"8DSelect routines from the following list:"8A/
M.PRTS	SC	/"8D"8AEnter ports to be displayed: /
M.LINS	SC	/"8D"8AEnter lines to be displayed: /
M.CHNS	SC	/"8D"8AEnter channels to be displayed: /

ASC2HX	BC	0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,0A,0B,0C,0D,0E,0F

	BND	2

ALNUM	HC	0,0,0,0FFC0,7FFF,0FFFF,7FFF,0FFE0
HEXNUM	HC	0,0,0,0FFC0,07E00,0,0

	BND	4

:	EACH OF THE FOLLOWING ROUTINE NAMES (FOR MATCHING PURPOSES)
:	OCCUPIES 4 BYTES AND IS NULL FILLED ON THE LEFT.
ROUTAB	AC	/"00"00RO/		:ORING DISPLAY
	AC	/"00"00RI/		:IRING DISPLAY
	AC	/"00"00PT/		:PACKET TRACE
	AC	/"00"00FT/		:FRAME TRACE
	AC	/"00"00PB/		:PACKET BUFFER TRACE
	AC	/"00"00OS/		:OUTPUT SECTOR TRACE
	AC	/"00BHN/		:NONEMPTY BUFFERLET TRACE (IN HEX)
ROUTSZ	EQ	.-ROUTAB

:	THE ADDRESSES IN THIS ROUTINE TABLE CORRESPOND TO THE ENTRIES IN
:	ROUTAB.
ROUTAD	WC	X.SRO		:ORING DISPLAY ADDRESS
	WC	X.SRI		:IRING DISPLAY ADDRESS
	WC	X.SP		:PACKET TRACE DISPLAY ADDRESS
	WC	X.SF		:FRAME TRACE DISPLAY ADDRESS
	WC	X.SPB		:PACKET BUFFER TRACE ADDRESS
  IF	HDLC
	WC	XSOSM		:OUTPUT SECTOR ADDRESS
  EI	HDLC
	WC	X.SBHN		:NONEMPTY BUFFERLET TRACE ADDRESS

PFILBT	EQ	80		:PORT FILTERING BIT FLAG
LFILBT	EQ	40		:LINK FILTERING BIT FLAG
CFILBT	EQ	20		:CHANNEL FILTERING BIT FLAG
BFILBT	EQ	10		:BUFFERLET FILTERING BIT FLAG

:	THE FLAGS IN THIS TABLE CORRESPOND TO THE ENTRIES IN
:	ROUTAB.
ROUTFL	HC	PFILBT		:FILTERING FLAGS FOR ORING DISPLAY
	HC	PFILBT		:FILTERING FLAGS FOR IRING DISPLAY
	HC	LFILBT!CFILBT	:FILTERING FLAGS FOR PACKET TRACE
	HC	LFILBT		:FILTERING FLAGS FOR FRAME TRACE
	HC	LFILBT!CFILBT	:FILTERING FLAGS FOR PACKET BUFFER TRACE
	HC	LFILBT!CFILBT	:FILTERING FLAGS FOR OUTPUT SECTOR TRACE
	HC	PFILBT!BFILBT	:FILTERING FLAGS FOR BUFFERLET TRACE


M.RO	SC	/"8D"8AORING----------------------"8D"8A/	:ORING DISPLAY
M.RI	SC	/"8D"8AIRING----------------------"8D"8A/	:IRING DISPLAY
M.PT	SC	/"8D"8APACKET TRACE---------------"8D"8A/	:PACKET TRACE
M.FT	SC	/"8D"8AFRAME TRACE----------------"8D"8A/	:FRAME TRACE
M.PB	SC	/"8D"8APACKET BUFFERS-------------"8D"8A/	:PACKET BUFFER TRACE
M.OS	SC	/"8D"8AOUTPUT SECTORS-------------"8D"8A/	:OUTPUT SECTOR TRACE
M.BHN	SC	/"8D"8ABUFFERLETS-----------------"8D"8A/	:NONEMPTY BUFFERLET TRACE (IN HEX)

	SEG	A.WTBL

MAXCHN	EQ	400						:DRE 10-JAN-84

	BND	2

CFILT	HS	(MAXCHN+0F)/10		:BIT ARRAY OF CHANNELS TO BE DISPLAYED
PFILT	HS	(MAXPRT+0F)/10		:BIT ARRAY OF DPORTS TO BE DISPLAYED
NBGRPS	EQ	(2*NDGRPS)+(3*NIGRPS)	:NUMBER OF BUFFER GROUPS
BFILT	HS	NBGRPS			:BIT ARRAY OF BUFFERLETS TO BE DISPLAYED

	BND	4

REQTAB	WS	40			:TABLE OF REQUESTED ROUTINES
XOSLNK	WS	1			:LINK REGISTER OF XOSLP  :LSH 17-DEC-86

XDRASC	SC	/  *                */
M.LINK	SC	/LINK xx /

:	ISIS CONTROL MESSAGES
	SEG	A.RTBL
XDRICA	HS	0
	SC	/DET/		:DETACH MESSAGE TYPE
	SC	/ZAP/		:DISCONNECT MESSAGE
	SC	/NOS/		:APPLY BACK-PRESSURE (NO SEND)
	SC	/SND/		:RELEASE BACK-PRESSURE (SEND)
	SC	/ICM/		:FLUSH OUTPUT (GOBBLER)
	SC	/BKG/		:FLUSH INPUT (BACK GOBBLER)
	SC	/BLK/		:DATA LOST IN THIS DIRECTION (BLACK BALL)
	SC	/GRY/		:DATA LOST IN OPPOSITE DIRECTION (GREY BALL)
	SC	/EDE/		:ENTER DEFERED ECHO MESSAGE
	SC	/LDE/		:LEAVE DEFERED ECHO MESSAGE
	SC	/ETM/		:ENTER TRANSPARENCY MODE
	SC	/LTM/		:LEAVE TRANSPARENCY MODE
	SC	/GB /		:GREEN BALL
	SC	/RB /		:RED BALL
	SC	/YB /		:YELLOW BALL
	SC	/OB /		:ORANGE BALL
	SC	/BRK/		:BREAK DETECTED
	SC	/HNG/		:HANG UP
	SC	/QTP/		:QUERY TERMINAL PARAMETER
	SC	/STP/		:SET TERMINAL PARAMETER
	SC	/PSN/		:PSEUDO NEEDLE
	SC	/NLC/		:NORMAL LOGON CHAR
	SC	/NLS/		:NORMAL LOGON STATUS
	SC	/LOF/		:LOG ON FAILURE
	SC	/NCC/		:NORMAL CIRCUIT COMPLETE
	SC	/ADA/		:ADDENDUM TO ACCOUNTING
	SC	/SHG/		:SUPER-HANG UP
	SC	/TLM/		:SET TRANSMIT LIMIT
	SC	/EBK/		:END OF BREAK
	SC	/ZAK/		:ZAP ACK
	SC	/EAO/		:ENTER ALTERNATE OUTPUT DEVICE MODE
	SC	/LAO/		:LEAVE ALTERNATE OUTPUT DEVICE MODE
	SC	/ZAR/		:ZAP WITH REASON
	SC	/SIX/		:START INTERFACE INFORMATION EXCHANGE
	SC	/TIX/		:TERMINATE INTERFACERFACE INFORMATION EXCHANGE
	SC	/***/		:UNDEFINED TYPE

:	ISIS CONTROL MESSAGE LENGTHS
:	----------------------------

	BND	2

XDRILA	HS	0
	BC	3		:DETACH MESSAGE TYPE
	BC	3		:DISCONNECT MESSAGE
	BC	3		:APPLY BACK-PRESSURE (NO SEND)
	BC	3		:RELEASE BACK-PRESSURE (SEND)
	BC	3		:FLUSH OUTPUT (GOBBLER)
	BC	3		:FLUSH INPUT (BACK GOBBLER)
	BC	3		:DATA LOST IN THIS DIRECTION (BLACK BALL)
	BC	3		:DATA LOST IN OPPOSITE DIRECTION (GREY BALL)
	BC	3		:ENTER DEFERED ECHO MESSAGE
	BC	3		:LEAVE DEFERED ECHO MESSAGE
	BC	3		:ENTER TRANSPARENCY MODE
	BC	3		:LEAVE TRANSPARENCY MODE
	BC	3		:GREEN BALL
	BC	3		:RED BALL
	BC	3		:YELLOW BALL
	BC	3		:ORANGE BALL
	BC	3		:BREAK DETECTED
	BC	3		:HANG UP
	BC	4		:QUERY TERMINAL PARAMETER
	BC	5		:SET TERMINAL PARAMETER
	BC	6		:PSEUDO NEEDLE
	BC	4		:NORMAL LOGON CHAR
	BC	4		:NORMAL LOGON STATUS
	BC	4		:LOG ON FAILURE
	BC	0A		:NORMAL CIRCUIT COMPLETE
	BC	8		:ADDENDUM TO ACCOUNTING
	BC	3		:SUPER-HANG UP
	BC	4		:SET TRANSMIT LIMIT
	BC	3		:END OF BREAK
	BC	3		:ZAP ACK
	BC	3		:ENTER ALTERNATE OUTPUT DEVICE MODE
	BC	3		:LEAVE ALTERNATE OUTPUT DEVICE MODE
	BC	4		:ZAP WITH REASON
	BC	3		:START INTERFACE INFORMATION EXCHANGE
	BC	3		:TERMINATE INTERFACE INFORMATION EXCHANGE




:	INTRA NODE MESSAGES
:	-------------------
	BND	2

XDRICB	HS	0
	SC	/RQR/		:RESTART REQUEST
	SC	/RST/		:RESTART INTERFACE
	SC	/NTO/		:NODE HAS BEEN TAKEN OVER
	SC	/REP/		:REPORT TO SUPERVISOR'S LOG
	SC	/RHS/		:REPORT HOST STATUS (OBSOLETE)
	SC	/RAC/		:REPORT ACCOUNTING
	SC	/TIM/		:GMT TIME
	SC	/RNP/		:REQUEST FOR NORMAL PSEUDO NEEDLE
	SC	/RAP/		:REQUEST AUX PSEUDO-NEEDLE
	SC	/PSR/		:PSEUDO-NEEDLE REJECTED
	SC	/HPA/		:HOST PORT AVAILABILITY
	SC	/HNA/		:HOST NOT ACCEPTABLE
	SC	/RHC/		:REPORT HOST COST
	SC	/NSU/		:NO SUPERVISOR
	SC	/ODN/		:1-DOWN TEXT
	SC	/RAH/		:REPORT ALL HOSTS
	SC	/HSR/		:HOST STATUS REPORT
	SC	/***/		:UNDEFINED TYPE


:	INTRANODE MESSAGE LENGTHS
:	-------------------------
	BND	2

XDRILB	HS	0
	BC	3		:RESTART REQUEST
	BC	3		:RESTART INTERFACE
	BC	4		:NODE HAS BEEN TAKEN OVER
	BC	9		:REPORT TO SUPERVISOR'S LOG
	BC	0C		:REPORT HOST STATUS (OBSOLETE)
	BC	8		:REPORT ACCOUNTING
	BC	8		:GMT TIME
	BC	0B		:REQUEST FOR NORMAL PSEUDO NEEDLE
	BC	0E		:REQUEST AUX PSEUDO-NEEDLE
	BC	7		:PSEUDO-NEEDLE REJECTED
	BC	0A		:HOST PORT AVAILABILITY
	BC	07		:HOST NOT ACCEPTABLE
	BC	0A		:REPORT HOST COST
	BC	3		:NO SUPERVISOR
	BC	9		:1-DOWN TEXT
	BC	3		:REPORT ALL HOSTS
	BC	0E		:HOST STATUS REPORT
	BC	0



	SEG	A.RTBL
P.CRLF	SC	/"8D"8AP  /	:PACKET HEADER
F.CRLF	SC	/"8D"8AF /	:FRAME HEADER
XDFPRO	SC	/SEC=/		:USER PROMPT

:	PACKET/FRAME INTERPRETATION MESSAGES
M.IN	SC	/  IN /
M.OUT	SC	/ OUT /
M.LEV1	SC	/Q-BIT /					:DRE 10-DEC-84
M.MBIT	SC	/M-BIT /					:DRE 10-DEC-84
M.DBIT	SC	/D-BIT /					:DRE 10-DEC-84
M.ILGF	SC	/ILL GFI /					:DRE 10-DEC-84
M.UNGF	SC	/NEW GFI /					:DRE 10-DEC-84
M.ILL	SC	/ILL. /
M.LINE	SC	/LINE /
M.CHAN	SC	/CHAN /
M.CLRR	SC	/CLEAR REQ  /		:CLEAR REQUEST/INDICATION
M.CLRC	SC	/CLEAR CON  /		:CLEAR CONFIRMATION
M.CALR	SC	/CALL REQ   /		:CALL REQUEST
M.CALA	SC	/CALL ACC   /		:CALL ACCEPTED
M.RES	SC	/RESET      /		:RESET
M.RESC	SC	/RESET CON  /		:RESET CONFIRMATION
M.INT	SC	/INTERRUPT  /		:INTERRUPT
M.INTC	SC	/INTRPT CON /		:INTERRUPT CONFIRMATION
M.RR	SC	/RR /			:RR
M.RNR	SC	/RNR /			:RNR
M.REJ	SC	/REJ /			:REJ
M.DIAG	SC	/DIAGNOSTIC /		:DIAGNOSTIC
M.RST	SC	/RESTART /		:RESTART
M.RSTC	SC	/RESTART CONF /		:RESTART CONFIRMATION	:DRE 10-DEC-84
M.REGR	SC	/REGISTRATION REQ /	:REGISTRATION REQUEST	:DRE 10-DEC-84
M.REGC	SC	/REGISTRATION CONF /	:REGISTRATION CONFIRMATION :DRE 10-DEC-84

	SEG	A.RTBL
:	PACKET CHANNEL STATE MESSAGES
M.PRDY	SC	/PREADY/		:READY STATE
M.PSCR	SC	/PSCALR/		:SEND CALL REQUEST SOFTWARE STATE
M.PWCC	SC	/PWCALC/		:WAITING FOR CALL CONFIRMATION
M.PSCC	SC	/PSCALC/		:MUST SEND CALL CONFIRMATION STATE
M.PSCL	SC	/PSCLRQ/		:SEND CLEAR REQUEST SOFTWARE STATE
M.PWCL	SC	/PWCLRC/		:WAITING FOR CLEAR CONFIRMATION STATE
M.PSLC	SC	/PSCLRC/		:SEND CLEAR CONFIRMATION STATE
M.PFLO	SC	/PFLOWC/		:FLOW CONTROL READY STATE
M.PSRI	SC	/PSRSETI/		:MUST SEND RESET INDICATION
M.PWRC	SC	/PWRSETC/		:WAITING FOR RESET CONFIRMATION STATE
M.PSRC	SC	/PSRSETC/		:MUST SEND RESET CONFIRMATION STATE
M.PSTI	SC	/PSRSTRTI/		:0B SEND RESTART INDICATION STATE
M.PWTC	SC	/PWRSTRTC/		:0C WAITING FOR RESTART CONFIRMATION STATE
M.PSTC	SC	/PSRSTRTC/		:0D SEND RESTART CONFIRMATION STATE
M.PWPV	SC	/PWPVC/			:0E WAITING TO BUILD PVC STATE

:	FRAME INTERFACE STATE MESSAGES
   IF	LAP!LAPB
M.PNAR	SC	/PNARM   /		:PRIMARY - NOT ARMED
M.PARM	SC	/PARMG   /		:PRIMARY - ARMING
M.PWSM	SC	/PWSARM  /		:PRIMARY - WAITING FOR SARM
M.PINF	SC	/PINFO   /		:PRIMARY - INFORMATION TRANSFER
M.PTRC	SC	/PTRECV  /		:PRIMARY - TIMER RECOVERY
M.PRST	SC	/PRESET  /		:PRIMARY - RESET
M.PDSC	SC	/PRDISC  /		:PRIMARY - DISCONNECT
M.PFMR	SC	/PFRMR   /		:PRIMARY - FRAME REJECT
M.PWDS	SC	/PWDISC  /		:PRIMARY - WAITING FOR DISCONNECT
M.SADM	SC	/SECADM  /		:SECONDARY - NOT ARMED
M.SINF	SC	/SECINF  /		:SECONDARY - INFORMATION TRANSFER
M.SMDR	SC	/SECMDR  /		:SECONDARY - FRAME REJECT
M.SDSC	SC	/SECDSC  /		:SECONDARY - DISCONNECT
M.SWDS	SC	/SECRMG  /		:SECONDARY - TRYING TO ARM
M.STRC	SC	/SECRECV /		:SECONDARY - TIMER RECOVERY
M.SRST	SC	/SECRSET /		:SECONDARY - RESET		:DRE 10-DEC-84
   EI	LAP!LAPB

M.POLL	SC	/POLL/			:POLL BIT MESSAGE
M.FINAL	SC	/FINAL/			:FINAL BIT MESSAGE (MUST IMMEDIATELY FOLLOW M.POLL)
M.UA	SC	/UA   /			:UA MESSAGE
M.DISC	SC	/DISC /			:DISC MESSAGE
M.FRMR	SC	/FRMR /			:FRMR MESSAGE
M.QUES	SC	/ILL. TYPE /		:UNKNOWN MESSAGE	:DRE 28-APR-86
  IF	LAPB
M.SARM	SC	/DM   /			:DM MESSAGE
  ELSE
M.SARM	SC	/SARM /			:SARM MESSAGE
  EI	LAPB
M.SABM	SC	/SABM /			:SABM MESSAGE
M.SABE	SC	/SABME /		:SABME MESSAGE

	SEG	A.WTBL
M.1NUM	SC	/  /						:DRE 10-DEC-84
M.2NUM	SC	/   /						:DRE 10-DEC-84
M.3NUM	SC	/    /						:DRE 10-DEC-84
M.4NUM	SC	/     /						:DRE 10-DEC-84
M.DATA	SC	/DATA RX,SX  /		:DATA P(R), P(S)
M.DATE	SC	/DATA RXX,SXX /		 P(R), P(S) EXTENDED
M.IFRM	SC	/INFO RX,SX /		:I-FRAME N(R),N(S)
M.IFRE	SC	/INFO RXX,SXX /		:I-FRAME N(R),N(S) EXTENDED

:	PACKET INTERPRETATION TABLE
 TABLE(XPBYTE,CODE)
	TENTRY(PBYTE0)
	TENTRY(PBYTE1)
	TENTRY(PBYTE2)
	TENTRY(PBYTE3)
	TENTRY(PBYTE4)
	TENTRY(PBYTE5)
	TENTRY(PBYTE6)
	TENTRY(PBYTE7)
	TENTRY(PBYTE8)
	TENTRY(PBYTE9)
 ENDTABLE(XPBYTE)		:DEFINE L.XPBY

 TABLE(SPBYTE,CODE)		:TABLE FOR SELECT PT
	TENTRY(PSBYT0)
	TENTRY(PSBYT1)
	TENTRY(PSBYT2)
	TENTRY(PSBYT3)
	TENTRY(PSBYT4)
	TENTRY(PSBYT5)
	TENTRY(PSBYT6)
	TENTRY(PSBYT7)
	TENTRY(PSBYT8)
	TENTRY(PSBYT9)
 ENDTABLE(SPBYTE)		:DEFINE L.SPBY

:	PACKET TYPE TABLES
	SEG	A.RTBL
 TABLE(PGTF)
	TENTRY(M.DIAG)			:DIAGNOSTIC
	TENTRY(M.REGR)			:REGISTRATION REQUEST	:DRE 10-DEC-84
	TENTRY(0)			:ERROR
	TENTRY(M.REGC)			:REGISTRATION CONFIRMATION :DRE 10-DEC-84
	TENTRY(0)			:ERROR
	TENTRY(M.RST)			:RESTART
	TENTRY(0)			:ERROR
	TENTRY(M.RSTC)			:RESTART CONFIRMATION
 ENDTABLE(PGTF)			:DEFINE L.PGTF

 TABLE(PGTB)
	TENTRY(0)			:ERROR
	TENTRY(0)			:ERROR
	TENTRY(M.CALR)			:CALL REQUEST
	TENTRY(M.CALA)			:CALL ACCEPTED
	TENTRY(M.CLRR)			:CLEAR REQUEST/INDICATION
	TENTRY(M.CLRC)			:CLEAR CONFIRMATION
	TENTRY(M.RES)			:RESET
	TENTRY(M.RESC)			:RESET CONFIRMATION
	TENTRY(M.INT)			:INTERRUPT
	TENTRY(M.INTC)			:INTERRUPT CONFIRMATION
 ENDTABLE(PGTB)			:DEFINE L.PGTB

:	PACKET CHANNEL STATE MESSAGE TABLE
 TABLE(PCHST)
	TENTRY(M.PRDY)			:0 READY STATE
	TENTRY(M.PSCR)			:1 SEND CALL REQUEST SOFTWARE STATE
	TENTRY(M.PWCC)			:2 WAITING FOR CALL CONFIRMATION
	TENTRY(M.PSCC)			:3 MUST SEND CALL CONFIRMATION STATE
	TENTRY(M.PSCL)			:4 SEND CLEAR REQUEST SOFTWARE STATE
	TENTRY(M.PWCL)			:5 WAITING FOR CLEAR CONFIRMATION STATE
	TENTRY(M.PSLC)			:6 SEND CLEAR CONFIRMATION STATE
	TENTRY(M.PFLO)			:7 FLOW CONTROL READY STATE
	TENTRY(M.PSRI)			:8 MUST SEND RESET INDICATION
	TENTRY(M.PWRC)			:9 WAITING FOR RESET CONFIRMATION STATE
	TENTRY(M.PSRC)			:0A MUST SEND RESET CONFIRMATION STATE
	TENTRY(M.PSTI)			:0B SEND RESTART INDICATION STATE
	TENTRY(M.PWTC)			:0C WAITING FOR RESTART CONFIRMATION STATE
	TENTRY(M.PSTC)			:0D SEND RESTART CONFIRMATION STATE
	TENTRY(M.PWPV)			:0E WAITING TO BUILD PVC STATE
 ENDTABLE(PCHST)			:DEFINE L.PCHS

:	FRAME INTERFACE STATE
   IF	LAP!LAPB
      IF	LAP
 TABLE(LAPIST)
	TENTRY(M.PNAR)			:STATE 0 PRIMARY - NOT ARMED
	TENTRY(M.PARM)			:STATE 1 PRIMARY - ARMING
	TENTRY(M.PWSM)			:STATE 2 PRIMARY - WAITING FOR SARM
	TENTRY(M.PINF)			:STATE 3 PRIMARY - INFORMATION TRANSFER
	TENTRY(M.PTRC)			:STATE 4 PRIMARY - TIMER RECOVERY
	TENTRY(M.PRST)			:STATE 5 PRIMARY - RESET
	TENTRY(M.PDSC)			:STATE 6 PRIMARY - DISCONNECT
	TENTRY(M.PWDS)			:STATE 7 PRIMARY - WAITING FOR DISCONNECT
	TENTRY(M.SADM)			:STATE 0 SECONDARY - NOT ARMED
	TENTRY(M.SINF)			:STATE 1 SECONDARY - INFORMATION TRANSFER
	TENTRY(M.SMDR)			:STATE 2 SECONDARY - FRAME REJECT
	TENTRY(M.SDSC)			:STATE 3 SECONDARY - DISCONNECT
 ENDTABLE(LAPIST)		:DEFINE L.LAPI
      ELSE
 TABLE(LABIST)
	TENTRY(M.PNAR)			:STATE 0 PRIMARY - NOT ARMED
	TENTRY(M.PARM)			:STATE 1 PRIMARY - ARMING
	TENTRY(M.PINF)			:STATE 2 PRIMARY - INFORMATION TRANSFER
	TENTRY(M.PTRC)			:STATE 3 PRIMARY - TIMER RECOVERY
	TENTRY(M.PRST)			:STATE 4 PRIMARY - RESET
	TENTRY(M.PFMR)			:STATE 5 PRIMARY - FRAME REJECT
	TENTRY(M.PDSC)			:STATE 6 PRIMARY - DISCONNECT
	TENTRY(M.SADM)			:STATE 0 SECONDARY - NOT ARMED
	TENTRY(M.SWDS)			:STATE 1 SECONDARY - TRYING TO ARM
	TENTRY(M.SINF)			:STATE 2 SECONDARY - INFORMATION TRANSFER
	TENTRY(M.STRC)			:STATE 3 SECONDARY - TIMER RECOVERY
	TENTRY(M.SRST)			:STATE 4 SECONDARY - RESET
	TENTRY(M.SMDR)			:STATE 5 SECONDARY - FRAME REJECT
	TENTRY(M.SDSC)			:STATE 6 SECONDARY - DISCONNECT
 ENDTABLE(LABIST)		:DEFINE L.LABI
      EI	LAP
   EI	LAP!LAPB


:	FRAME INTERPRETATION TABLE
 TABLE(XFBYTE,CODE)
	TENTRY(FBYTE0)
	TENTRY(FBYTE1)
	TENTRY(FBYTE2)
	TENTRY(FBYTE3)
	TENTRY(FBYTE4)
	TENTRY(FBYTE5)
	TENTRY(FBYTE6)
	TENTRY(FBYTE7)
 ENDTABLE(XFBYTE)

 TABLE(SFBYTE,CODE)			:TABLE FOR SELECT FT
	TENTRY(FSBYT0)
	TENTRY(FSBYT1)
	TENTRY(FSBYT2)
	TENTRY(FSBYT3)
	TENTRY(FSBYT4)
	TENTRY(FSBYT5)
	TENTRY(FSBYT6)
	TENTRY(FSBYT7)
 ENDTABLE(SFBYTE)

:	PACKET TYPE TABLE
 TABLE(PTYPE)
	TENTRY(PDATA)		:DATA PACKET
	TENTRY(PRR)		:RR PACKET
	TENTRY(PDATA)		:DATA PACKET
	TENTRY(PGEN)		:GENERAL PACKET
	TENTRY(PDATA)		:DATA PACKET
	TENTRY(PRNR)		:RNR PACKET
	TENTRY(PDATA)		:DATA PACKET
	TENTRY(PGEN)		:GENERAL PACKET
	TENTRY(PDATA)		:DATA PACKET
	TENTRY(PREJ)		:REJ PACKET
	TENTRY(PDATA)		:DATA PACKET
	TENTRY(PGEN)		:GENERAL PACKET
	TENTRY(PDATA)		:DATA PACKET
	TENTRY(P.025)		:NO SUCH TYPE
	TENTRY(PDATA)		:DATA PACKET
	TENTRY(PGEN)		:GENERAL PACKET
 ENDTABLE(PTYPE)

 TABLE(SPTYPE,CODE)		:TABLE FOR SELECT PT
	TENTRY(PSDATA)		:DATA PACKET
	TENTRY(PSRR)		:RR PACKET
	TENTRY(PSDATA)		:DATA PACKET
	TENTRY(PSGEN)		:GENERAL PACKET
	TENTRY(PSDATA)		:DATA PACKET
	TENTRY(PSRNR)		:RNR PACKET
	TENTRY(PSDATA)		:DATA PACKET
	TENTRY(PSGEN)		:GENERAL PACKET
	TENTRY(PSDATA)		:DATA PACKET
	TENTRY(PSREJ)		:REJ PACKET
	TENTRY(PSDATA)		:DATA PACKET
	TENTRY(PSGEN)		:GENERAL PACKET
	TENTRY(PSDATA)		:DATA PACKET
	TENTRY(P.S080)		:NO SUCH TYPE
	TENTRY(PSDATA)		:DATA PACKET
	TENTRY(PSGEN)		:GENERAL PACKET
 ENDTABLE(SPTYPE)

:	FRAME TYPE TABLE
 TABLE(FTYPE)
	TENTRY(FINFO)		:INFORMATION FRAME
	TENTRY(FBRR)		:RR FRAME
	TENTRY(FINFO)		:INFORMATION FRAME
	TENTRY(FBDUA)		:DISC OR UA
	TENTRY(FINFO)		:INFORMATION FRAME
	TENTRY(FBRNR)		:RNR FRAME
	TENTRY(FINFO)		:INFORMATION FRAME
	TENTRY(FBFRM)		:FRAME REJECT
	TENTRY(FINFO)		:INFORMATION FRAME
	TENTRY(FBREJ)		:REJ FRAME
	TENTRY(FINFO)		:INFORMATION FRAME
	TENTRY(FBQUES)		:NO SUCH TYPE			:DRE 28-APR-86
	TENTRY(FINFO)		:INFORMATION FRAME
	TENTRY(FBQUES)		:NO SUCH TYPE			:DRE 28-APR-86
	TENTRY(FINFO)		:INFORMATION FRAME
	TENTRY(FBSAM)		:SARM OR SABM

 TABLE(FSTYPE,CODE)		:TABLE FOR SELECT FT
	TENTRY(FSINFO)		:INFORMATION FRAME
	TENTRY(FSBRR)		:RR FRAME
	TENTRY(FSINFO)		:INFORMATION FRAME
	TENTRY(FSBDUA)		:DISC OR UA
	TENTRY(FSINFO)		:INFORMATION FRAME
	TENTRY(FSBRNR)		:RNR FRAME
	TENTRY(FSINFO)		:INFORMATION FRAME
	TENTRY(FSBFRM)		:FRAME REJECT
	TENTRY(FSINFO)		:INFORMATION FRAME
	TENTRY(FSBREJ)		:REJ FRAME
	TENTRY(FSINFO)		:INFORMATION FRAME
	TENTRY(FSQUES)		:NO SUCH TYPE			:DRE 28-APR-86
	TENTRY(FSINFO)		:INFORMATION FRAME
	TENTRY(FSQUES)		:NO SUCH TYPE			:DRE 28-APR-86
	TENTRY(FSINFO)		:INFORMATION FRAME
	TENTRY(FSBSAM)		:SARM OR SABM

	SEG	A.RTBL
:	SARM/SABM/SABME TABLE

TABLE(FSAMTB)
	TENTRY(M.SARM)
	TENTRY(M.SABM)
	TENTRY(M.QUES)
	TENTRY(M.SABE)
 ENDTABLE(FSAMTB)


  IF	HDLC

:	SIO TRACE MESSAGES AND TABLES

 TABLE(XSIOTB,CODE)
	TENTRY(XSHAF0)		:HALFWORD 0
	TENTRY(XSHAF1)		:HALFWORD 1
	TENTRY(XSHAF2)		:HALFWORD 2
	TENTRY(XSHAF3)		:HALFWORD 3
	TENTRY(XSHAF4)		:HALFWORD 4
	TENTRY(XSHAF5)		:HALFWORD 5
	TENTRY(XSHAF6)		:HALFWORD 6

	SEG	A.RTBL
 TABLE(XSHW0)
	TENTRY(M.H0B0)		:HALFWORD 0 BIT 0
	TENTRY(M.H0B1)		:HALFWORD 0 BIT 1
	TENTRY(M.H0B2)		:HALFWORD 0 BIT 2
	TENTRY(M.H0B3)		:HALFWORD 0 BIT 3
	TENTRY(M.H0B4)		:HALFWORD 0 BIT 4
	TENTRY(M.H0B5)		:HALFWORD 0 BIT 5
	TENTRY(M.H0B6)		:HALFWORD 0 BIT 6
	TENTRY(M.H0B7)		:HALFWORD 0 BIT 7
	TENTRY(M.H0B8)		:HALFWORD 0 BIT 8
	TENTRY(M.H0B9)		:HALFWORD 0 BIT 9
	TENTRY(M.H0BA)		:HALFWORD 0 BIT A
	TENTRY(M.H0BB)		:HALFWORD 0 BIT B
	TENTRY(0)		:HALFWORD 0 BIT C
	TENTRY(0)		:HALFWORD 0 BIT D
	TENTRY(0)		:HALFWORD 0 BIT E
	TENTRY(0)		:HALFWORD 0 BIT F		:DRE 25-MAR-86

	SEG	A.RTBL
M.H0B0	SC	/Abort received"8A"8D/
M.H0B1	SC	/Transmit underrun"8A"8D/
M.H0B2	SC	/Clear to send"8A"8D/
M.H0B3	SC	/Searching for non-flag"8A"8D/			:DRE 25-MAR-86
M.H0B4	SC	/Carrier detected"8A"8D/
M.H0B5	SC	/Transmit buffer empty"8A"8D/
M.H0B6	SC	/Interrupt pending"8A"8D/
M.H0B7	SC	/Receive character available"8A"8D/
M.H0B8	SC	/End of frame detected"8A"8D/
M.H0B9	SC	/CRC status bit on"8A"8D/			:DRE 25-MAR-86
M.H0BA	SC	/Receive overrun"8A"8D/
M.H0BB	SC	/Parity error"8A"8D/
M.READ	SC	/"8A"8DREAD STATUS"8A"8D/

	SEG	A.WTBL
M.IDLE	SC	/Idle count  = xxx"8A"8D/
M.CRC	SC	/CRC count   = xxx"8A"8D/
M.ABOR	SC	/Abort count = xxxx"8A"8D/
M.ROVC	SC	/Recovered overrun count =  xxx"8A"8D/		:DRE 25-MAR-86
M.TUNC	SC	/Recovered underrun count = xxx"8A"8D/		:DRE 25-MAR-86
M.LINX	SC	/Line xx"8A"8D/

	SEG	A.RTBL
 TABLE(XSHW2)
	TENTRY(0)		:HALFWORD 2 BIT 0
	TENTRY(0)		:HALFWORD 2 BIT 1
	TENTRY(0)		:HALFWORD 2 BIT 2
	TENTRY(0)		:HALFWORD 2 BIT 3
	TENTRY(0)		:HALFWORD 2 BIT 4
	TENTRY(0)		:HALFWORD 2 BIT 5
	TENTRY(0)		:HALFWORD 2 BIT 6
	TENTRY(0)		:HALFWORD 2 BIT 7
	TENTRY(0)		:HALFWORD 2 BIT 8
	TENTRY(0)		:HALFWORD 2 BIT 9
	TENTRY(0)		:HALFWORD 2 BIT A
	TENTRY(0)		:HALFWORD 2 BIT B
	TENTRY(M.H2BC)		:HALFWORD 2 BIT C
	TENTRY(M.H2BD)		:HALFWORD 2 BIT D
	TENTRY(M.H2BE)		:HALFWORD 2 BIT E
	TENTRY(M.H2BF)		:HALFWORD 2 BIT F

	SEG	A.RTBL
M.H2BC	SC	/Read status complete"8A"8D/
M.H2BD	SC	/Receive clock present"8A"8D/
M.H2BE	SC	/HDLC line idle"8A"8D/
M.H2BF	SC	/Transmit clock present"8A"8D/

 TABLE(XSHW4)
	TENTRY(0)		:HALFWORD 4 NIBBLE = 0
	TENTRY(0)		:HALFWORD 4 NIBBLE = 1
	TENTRY(M.H4N2)		:HALFWORD 4 NIBBLE = 2
	TENTRY(0)		:HALFWORD 4 NIBBLE = 3
	TENTRY(0)		:HALFWORD 4 NIBBLE = 4
	TENTRY(0)		:HALFWORD 4 NIBBLE = 5
	TENTRY(M.H4N6)		:HALFWORD 4 NIBBLE = 6
	TENTRY(0)		:HALFWORD 4 NIBBLE = 7
	TENTRY(M.H4N8)		:HALFWORD 4 NIBBLE = 8
	TENTRY(0)		:HALFWORD 4 NIBBLE = 9
	TENTRY(0)		:HALFWORD 4 NIBBLE = A
	TENTRY(0)		:HALFWORD 4 NIBBLE = B
	TENTRY(0)		:HALFWORD 4 NIBBLE = C
	TENTRY(0)		:HALFWORD 4 NIBBLE = D
	TENTRY(0)		:HALFWORD 4 NIBBLE = E
	TENTRY(0)		:HALFWORD 4 NIBBLE = F

	SEG	A.RTBL
M.H4N2	SC	/CCW error"8A"8D/
M.H4N6	SC	/Receive overrun or transmit underrun"8A"8D/	:DRE 25-MAR-86
M.H4N8	SC	/IO command error"8A"8D/
M.NFNE	SC	/Nonfunctioning"2Fnonexistent board"8A"8D/
M.BUSY	SC	/Busy - not ready for new command"8A"8D/
M.INTS	SC	/"8A"8DINTERRUPT STATUS"8A"8D/

  EI	HDLC



	SEG	A.RTBL
:	LABEL: ACC/CNT = XXXX [LWM,HWM]
M.CL	SC	/: /
M.SL	SC	/"2F/
M.EQ	SC	/ = /
M.LB	SC	/ [/
M.RB	SC	/]  /
M.CO	SC	/, /

M.CRLF	SC	/"8A"8D/
	SEG	A.WTBL
M.NUM	SC	/    /
	IF	NLINES-1
M.SIO	SC	/"8A"8D"8A"8DSIO xxx"8A"8D/
	EI
:M.HEAD	SC	/"8A"8DLOCATION ROUTINE   FUNCTION/
:M.NONE	SC	/"8A"8DNO DIAGNOSTIC ROUTINES"8A"8D/


M.LINQ	SC	/LINE NUMBER? /
M.EMPT	SC	/   /
M.4SPC	SC	/    /				  :LSH 17-DEC-86
M.QUEM	SC	/??/				  :LSH 17-DEC-86
M.DLET	SC	/ 1003/		:DLE ETX	  :LSH 17-DEC-86
  EI	DDTDIA
M.0	SC /"8A"8DHELP  Prints this list          QUIT  Returns to DDT/
  IF	DDTDIA
M.1	SC /"8A"8DBH    Bufferlet dump in hex     BA    Bufferlet dump in ascii/
M.2	SC /"8A"8DBHN   Non-empty dump in hex     BAN   Non-empty dump in ascii/
M.3	SC /"8A"8DPB    Packet buffer trace       PT    Packet trace/
M.4	SC /"8A"8DFT    Frame trace               PFT   Packet and frame trace/
M.4X	SC /"8A"8DFT    Frame trace               BHN   Non-empty dump in hex/
M.5	SC /"8A"8DRI    Input ring trace          RO    Output ring trace/
M.6	SC /"8A"8DAVE   Measurement averaging     LNKS  Dump Link variables/
M.7	SC /"8A"8DIPRT  Dump IPORT variables      DPRT  Dump DPORT variables/
M.8	SC /"8A"8DGPKT  Packet(s) seq control     SEND  Send packet once/
M.9	SC /"8A"8DCREG  Move crash reg to DDT     TCAN  Trash-can link data/
M.10	SC /"8A"8DVUE   Real-time monitor         DPKT  Define test packets/
M.11	SC /"8A"8DREM   Remark comment line       PAWS  Pause command proc/
  IF	HDLC
M.12	SC /"8A"8DSIO   SIO interpreter           OS    Output sector trace/
M.121	SC /"8A"8DOS    Output sector trace/
  EI	HDLC
M.13	SC /"8A"8DLINS  Dump LINE variables       ERRS  Global error counters/
M.14	SC /"8A"8DDMY1  Spare Diagnostic          DMY2  Spare Diagnostic/
M.16	SC /"8A"8DSELECT Diagnostic selection     REDO  Repeat selection/
M.17	SC /"8A"8DSNAP  One-shot selection/

M.15				:Message to display CRAT address
	BC	0		:length of message
	BC	8D,8A,8A	:<CR><LF><LF>

QQ	EQ	(CRAT^-10)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7		:Close the gap between 9 and A
	EI
QQ	EQ	QQ+30		:Make it ASCII
	BC	QQ

QQ	EQ	(CRAT^-0C)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
QQ	EQ	QQ+30
	BC	QQ

QQ	EQ	(CRAT^-08)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
QQ	EQ	QQ+30
	BC	QQ

QQ	EQ	(CRAT^-04)&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
QQ	EQ	QQ+30
	BC	QQ

QQ	EQ	CRAT&0F
	IF	.GT.(QQ,9)
QQ	EQ	QQ+7
	EI
QQ	EQ	QQ+30
	BC	QQ
	AC	/ = CRAT, address of the Crash Table."8A/
QQ	EQ	.
	ORG	M.15
	BC	QQ-M.15-1		:Store the length
	ORG	QQ			:Restore the location counter

M.20	SC	/"8A"8D----- Average per instance ----- [   HWM      LWM   ]/
M.21	SC	/  ave"2Fsec /

 IF	DDTDIA-2
M.30	SC	/"8A"8DENTER 0 (OFF) OR 1 (ON): /
M.35	SC	/"8A"8DDATA SENT ON COMMAND "22SEND"22/
M.37	SC /"8A"8D HOW'S THIS? (0=NO, 1=YES ADD BYTE COUNT, 2=YES AS IS /
M.40	SC /"8A"8D ENTER I PORT# /
M.41	SC /"8A"8D ENTER BUFFER SEQUENCE CONTROL AS AAAAAAAA, WHERE/
M.42	SC /"8A"8D A=(00=NONE,01=IRING,10=IED,11=IEC)+BUF#(00-11X)"8A"8D/
M.43	SC /"8A"8D ENTER FREQUENCY IN FASTC, 0=SINGLE SHOT, FFFF=FULL SPEED /
M.50	SC /"8A"8D ENTER PACKET BUFFER # (0-3) /
M.51	SC /"8A"8D ENTER PACKET AS TYPE, FLAGS, DATA..."8A"8D/
M.52	SC /"8A"8D COMPUTE BYTE COUNT (0) OR SEND AS IS (1) /
M.53	SC /"8A"8D TOO LARGE PACKET FOR THIS BUFFER"8A"8A/
M.54	SC /"8A"8D INVALID PORT#"8A"8D/
M.55	SC /"8A"8D INVALID BUFFER#"8A"8D/
M.56	SC /"8A"8D CURRENT CONTROL BUFFER"8A"8D/

V.M0	SC	/"8A"8D Commands are:/
V.M1	SC	/"8A"8DP - pause/
V.M2	SC	/"8A"8DQ - quit to command handler/
V.M3	SC	/"8A"8DF - flush output/
V.M4	SC	/"8A"8DR - refresh screen/
V.M5	SC	/"8A"8DC - continue/
V.M6	SC	/"8A"8D To make an entry in display../
V.M7	SC	/"8A"8DM<row>,<col>/
V.M8	SC	/"8A"8Dlabel,<address>,<bytecount-1>/
V.M9	SC	/"8A"8D To activate a window../
V.M10	SC	/"8A"8DW<window#>,address,<firstrow>,<lastrow>/
V.M11	SC	/"8A"8D Note: VUE.EM to output variable display"8A"8D/
 EI	DDTDIA-2

	BND	2


MSGSPC	BS	100

	SEG	A.CODE

:	UTILITY ROUTINES

:	MOVE MESSAGE TO STORAGE

:	R3  = SCRATCH REGISTER
:	R4  = USED AS MESSAGE STORE POINTER
:	R9  = ENTER WITH POINTER TO MESSAGE
:	R10 = USED AS BYTE COUNT OF MESSAGE 
:	R12 = LINK REGISTER

MSGMOV	LB	R10,,R9			:GET MESSAGE LENGTH
	JER	R12			:GET OUT IF NULL
	LB	R4,MSGSPC,,		:GET CURRENT LENGTH OF MESSAGE STORE
	LR	R3,R4	
	AR	R3,R10			:CALCULATE NEW STORE LENGTH
	STB	R3,MSGSPC,,		:SET NEW LENGTH
MSMV10	LB	R3,,R9,R10		:GET BYTE OF MESSAGE
	STB	R3,MSGSPC,R4,R10	:MOVE TO STORE
	SIS	R10,1			:DECREMENT BYTE COUNT
	JNBS	MSMV10			:IF MORE TO DO
	JR	R12

:	MOVE BYTE TO STORAGE

:	R5 = BYTE TO BE MOVED
:	R10 = SCRATCH REGISTER
:	R11 = LINK REGISTER

BYTMOV	LB	R10,MSGSPC,,		:GET BYTE COUNT
	AIS	R10,1			:BUMP COUNT
	STB	R10,MSGSPC,,		:REPLACE
	STB	R5,MSGSPC,R10,		:PUT BYTE INTO STORAGE
	JR	R11			:RETURN

:	MOVE NUMBER TO STORAGE

:	R5  = NUMBER TO BE CONVERTED AND MOVED
:	R1  = FIELD WIDTH
:	R3 = SCRATCH REGISTER
:	R4 = SCRATCH REGISTER
:	R10 = SCRATCH REGISTER
:	R11 = LINK REGISTER

NUMMOV	LB	R3,MSGSPC,,		:GET OLD MESSAGE LENGTH
	AR	R3,R1			:COMPUTE NEW LENGTH
	STB	R3,MSGSPC,,		:SAVE NEW LENGTH
NUMM00	LIS	R4,0F			:GET MASK
	NR	R4,R5			:GET LAST DIGIT
	LB	R4,SIAASC,R4,		:CONVERT TO ASCII
	STB	R4,MSGSPC,R3,		:PUT INTO STORE
	SIS	R1,1			:BUMP COUNT
	JER	R11
	SIS	R3,1			:MOVE POINTER
	SRLS	R5,4			:DISCARD USED DIGIT
	J	NUMM00			:GO DO IT AGAIN

:	OUTPUT A BYTE AS 2 DIGITS TO TTY

:	R0  = SCRATCH REGISTER
:	R3  = SCRATCH REGISTER
:	R4  = SCRATCH REGISTER
:	R5  = BYTE TO BE OUTPUT.  REMAINS INTACT
:	R7  = BYTE COUNTER (INPUT)
:	R11 = LINK REGISTER

XDTPUT	LBR	R4,R5			:COPY IT
	LBR	R3,R5			:COPY AGAIN
	SRHLS	R4,4			:LEFT NIBBLE
	LB	R0,SIAASC,R4,		:CONVERT TO ASCII
	SVC	KIO,0E			:PUT IT OUT TO TTY
	NHI	R3,0F			:RIGHT NIBBLE
	LB	R0,SIAASC,R3,		:CONVERT TO ASCII
	SVC	KIO,0E			:PUT IT OUT TO TTY
	LBR	R3,R7			:GET BYTE COUNTER
	NHI	R3,1			:EVERY OTHER BYTE, PUT OUT EXTRA SPACE
	JER	R11			:IF EVEN
	LHI	R0,0A0			:GET SPACE
	SVC	KIO,0E			:PUT IT OUT TO TTY
	JR	R11			:RETURN

:	OUTPUT A BYTE AS 2 DIGITS TO STORAGE

:	R3  = SCRATCH REGISTER
:	R5  = BYTE TO BE OUTPUT
:	R10, R11 DESTROYED
:	R12 = LINK REGISTER

XDSPUT	LBR	R3,R5			:COPY IT
	SRHLS	R5,4			:LEFT NIBBLE
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII
	JAL	R11,BYTMOV		:MOVE BYTE TO STORAGE
	NHI	R3,0F			:RIGHT NIBBLE
	LB	R5,SIAASC,R3,		:CONVERT TO ASCII
	JAL	R11,BYTMOV		:MOVE BYTE TO STORAGE
	JR	R12			:RETURN

:	PROMPT FOR TIME TO DUMP WITH "SEC="
:	SAVE TIME TO END IN XDRSEC
:	R0,R1 DESTROYED
:	R13 = LINK REGISTER

XDTIME	LIS	R1,0			:INIT ACCUMULATOR
	SVC	0B,XDFPRO,,		:PRINT "SEC=" PROMPT
XDTIM1	SVC	0A,0010			:GET CHAR IN R0
	J	XDTIM2			:16 SECOND TIME OUT
	NHI	R0,7F			:OFF PARITY BIT
	CLHI	R0,0D			:CR ??
	JEFS	XDTIM2			:IF SO
	NHI	R0,0F			:GET DIGIT PART
	SLLS	R1,4			:POSITION ACCUMULATOR
	OR	R1,R0			:ADD IN LAST DIGIT
	JBS	XDTIM1			:GO FOR NEXT DIGIT
XDTIM2	A	R1,SLOWC,,		:ADD CURRENT CLOCK
	ST	R1,XDRSEC		:SAVE TIME TO QUIT
	JR	R13			:RETURN
	

:	DUMP CONTENTS OF ALL BUFFERLET CHAINS IN HEX.
X.XBHN	LIS	R4,0
	STB	R4,XSTRSH		:SET "NON-EMPTY BUFFERLETS ONLY" FLAG
	JFS	XDBF00
X.XBH	LIS	R4,1
	STB	R4,XSTRSH		:SET "ALL BUFFERLETS" FLAG
XDBF00	LIS	R6,0			:INITIALIZE BUFFER #
XDBF20	LIS	R3,0
	STB	R3,MSGSPC,,		:INIT STORAGE
	LIS	R1,3			:BUFFER NUMBER FIELD WIDTH
:	R6=BUFFER NUMBER*4 (INDEX)
	CLHI	6,NBUF*4		:RANGE CHECK BUFFER #
	JGE	XDBF99			:TOO BIG
	LA	R9,XDBUFL,,		:"BUF" MESSAGE
	JAL	R12,MSGMOV		:MOVE TO STORE
	LR	R5,R6			:MOVE BUFFER NUMBER
	JAL	R11,NUMMOV		:MOVE TO STORE
	L	R2,BB,6,		:BUFFER BEGINNING
	CBCT(7,6)			:LOOK AT BYTE COUNT OF BUFFER
	LR	R7,R7
	JN	XDBF22			:IF NOT EMPTY
	LB	R9,XSTRSH		:CHECK IF EMPTY BUFFERS TO BE PRINTED
	JNFS	XDBF21			:IF SO
	STB	R9,MSGSPC,,		:CLEAR STORE
	AIS	R6,4			:GO TO NEXT BUFFER
	J	XDBF20

XDBF21	LA	R9,XDBEM,,		:POINT TO "EMPTY"
	JAL	R12,MSGMOV		:MOVE TO STORE
	J	XDBF50			:CHECK NEXT ONE

XDBF22	LA	R9,XDBEQ,,		:POINT TO COLON MESSAGE
	JAL	R12,MSGMOV		:MOVE TO STORE
	LIS	R1,2			:SET FIELD WIDTH = 2
XDBF30	LB	R5,,R2			:GET NEXT CHARACTER FROM BUFFER
	JAL	R12,XDSPUT		:CONVERT TO ASCII AND STORE
	AIS	R2,1			:NEXT CHARACTER IN BUFFERLET
	THI	R2,0F			:END OF BUFFERLET ??
	JN	XDBF40			:IF NOT
	SVC	0B,MSGSPC,,		:PRINT WHAT WE HAVE NOW
	LIS	R3,0
	STB	R3,MSGSPC,,		:CLEAR OUT ACCUMULATED MSG
	LHL	R2,,R2			:STEP TO NEXT BUFFERLET
	CLHI	R2,NBFLET		:GOOD BUFFER LINK?
	JGE	XDBF50			:NO, SKIP REST OF BUFFER
	SLLS	R2,4			:CONVERT TO BUFFERLET POINTER
	AI	R2,BUFERS-0E		:ADJUST TO ITS START
	LA	R9,M.CRLF,,		:POINT TO CRLF MESSAGE
	JAL	R12,MSGMOV		:MOVE TO STORE
XDBF40	SIS	R7,1			:DECREMENT CHARACTER COUNT
	JG	XDBF30			:IF NOT DONE YET
XDBF50	AIS	R6,4			:TO NEXT BUFFER
	SVC	0B,MSGSPC,,		:PRINT CONTENTS OF BUFFER
	J	XDBF20

XDBF99	LA	R9,M.CRLF,,		:POINT TO CRLF MESSAGE
	JAL	R12,MSGMOV		:MOVE TO STORE
	SVC	0B,MSGSPC,,		:PRINT STORE
	J	DSTRT2,,		:RETURN TO COMMAND HANDLER	:DRE 25-MAR-86



:	DUMP CONTENTS OF ALL BUFFERLET CHAINS IN ASCII.
X.XBAN	LIS	R4,0
	STB	R4,XSTRSH		:SET "NON-EMPTY BUFFERLETS ONLY" FLAG
	JFS	XDBA00
X.XBA	LIS	R4,1
	STB	R4,XSTRSH		:SET "ALL BUFFERLETS" FLAG
XDBA00	LIS	R6,0			:INITIALIZE BUFFER #
XDBA20	LIS	R3,0
	STB	R3,MSGSPC,,		:INIT STORAGE
	LIS	R1,3			:BUFFER NUMBER FIELD WIDTH
:	R6=BUFFER NUMBER*4 (INDEX)
	CLHI	6,NBUF*4		:RANGE CHECK BUFFER #
	JGE	XDBA99			:TOO BIG
	LA	R9,XDBUFL,,		:"BUF" MESSAGE
	JAL	R12,MSGMOV		:MOVE TO STORE
	LR	R5,R6			:MOVE BUFFER NUMBER
	JAL	R11,NUMMOV		:MOVE TO STORE
	L	R2,BB,6,		:BUFFER BEGINNING
	CBCT(7,6)			:LOOK AT BYTE COUNT OF BUFFE
	LR	R7,R7
	JN	XDBA22			:IF NOT EMPTY
	LB	R9,XSTRSH		:CHECK IF EMPTY BUFFERS TO BE PRINTED
	JNFS	XDBA21			:IF SO
	STB	R9,MSGSPC,,		:CLEAR STORE
	AIS	R6,4			:GO TO NEXT BUFFER
	J	XDBA20

XDBA21	LA	R9,XDBEM,,		:POINT TO "EMPTY"
	JAL	R12,MSGMOV		:MOVE TO STORE
	J	XDBA50			:CHECK NEXT ONE

XDBA22	LA	R9,XDBEQ,,		:POINT TO COLON MESSAGE
	JAL	R12,MSGMOV		:MOVE TO STORE
	LIS	R1,2			:SET FIELD WIDTH = 2
XDBA30	LB	R5,,R2			:GET NEXT CHARACTER FROM BUFFER
	CLHI	R5,20			:IS IT PRINTABLE?
	JGEFS	XDBA35			:YES, GO DO IT
	LHI	R5,5E			:PUT ^ IN BUFFER
	JAL	R11,BYTMOV		:MOVE TO STORE
	LB	R5,,R2			:GET THE CHARACTER
	AHI	R5,40			:MAKE PRINTABLE
XDBA35	JAL	R11,BYTMOV		:MOVE TO STORE
	AIS	R2,1			:NEXT CHARACTER IN BUFFERLET
	THI	R2,0F			:END OF BUFFERLET ??
	JN	XDBA40			:IF NOT
	SVC	0B,MSGSPC,,		:PRINT WHAT WE HAVE NOW
	LIS	R3,0
	STB	R3,MSGSPC,,		:CLEAR OUT ACCUMULATED MSG
	LHL	R2,,R2			:STEP TO NEXT BUFFERLET
	CLHI	R2,NBFLET		:GOOD BUFFER LINK?
	JGE	XDBA50			:NO, SKIP REST OF BUFFER
	SLLS	R2,4			:CONVERT TO BUFFERLET POINTER
	AI	R2,BUFERS-0E		:ADJUST TO ITS START
	LA	R9,M.CRLF,,		:POINT TO CRLF MESSAGE
	JAL	R12,MSGMOV		:MOVE TO STORE
XDBA40	SIS	R7,1			:DECREMENT CHARACTER COUNT
	JG	XDBA30			:IF NOT DONE YET
XDBA50	AIS	R6,4			:TO NEXT BUFFER
	SVC	0B,MSGSPC,,		:PRINT CONTENTS OF BUFFER
	J	XDBA20

XDBA99	LA	R9,M.CRLF,,		:POINT TO CRLF MESSAGE
	JAL	R12,MSGMOV		:MOVE TO STORE
	SVC	0B,MSGSPC,,		:PRINT STORE
	J	DSTRT2,,		:RETURN TO COMMAND HANDLER	:DRE 25-MAR-86




:	DUMP I/O RINGS
:
RR	EQ	8			:REGISTER ADDRESS OF RING
RS	EQ	9			:REGISTER RING SIZE
MAXINM	EQ	10			:MAX NUMBER OF INTRA NODE MESSAGE TYPES

XDRING	HS				:DEFAULT CALL FOR XDRING IS IRING
X.XRI	LA	RR,IRING,,		:SET UP FOR IRING
	LHI	RS,IRSIZE
	JFS	XDR000

X.XRO	LA	RR,ORING,,		:SET UP FOR ORING
	LHI	RS,ORSIZE

XDR000	SVC	0B,XDRPLU,,		:+ PROMPT
	LIS	R0,0
	STH	R0,XDRWFL		:CLEAR WRAPPED FLAG
	STH	R0,IORING		:CLEAR "BOTH RINGS" FLAG
	STH	R0,INFMI		:CLEAR STORAGE FOR IRING POINTER
	STH	R0,ONFMI		:CLEAR STORAGE FOR ORING POINTER
	SVC	0A,0010			:TTY INPUT INTO R0, 16 SEC TIMEOUT
	J	XDR0FF			:TIMEOUT, RETURN TO DDT
	NHI	R0,7F			:OFF THE PARITY
	LIS	R1,0			:INIT ACCUMULATOR JUST IN CASE
	CLHI	R0,41			:ALPHABETIC?
	JL	XDR055			:IF NOT
	JAL	R1,CAPIT		:CAPITALIZE IT
	CLHI	R0,57			:W ??
	JNFS	XDR004			:IF NOT
	STH	R0,XDRWFL		:ASSUME TO HAVE WRAPPED
	SVC	0A,0010			:GET NEXT CHARACTER
	J	XDR0FF			:TIMEOUT, EXIT
	JAL	R1,CAPIT		:CAPITALIZE IT 
XDR004	CHI	R0,49			:I ??
	JE	XDR020			:IF SO DO IRING
	CHI	R0,4F			:O ??
	JE	XDR030			:IF SO DO ORING
	CHI	R0,42			:B ??
	JN	XDR040			:IF NOT, DO SPECIFIED RING
XDR010	LIS	R1,1
	STH	R1,IORING		:SET "BOTH RINGS" FLAG
	LA	RR,ORING,,		:SET UP ORING FOR LATER
	LHI	RS,ORSIZE		:RING SIZE
	LH	R1,XDRWFL		:RING WRAP?
	JEFS	XDR015			:IF NOT
	LH	R1,NFMI,RR		:GET CURRENT POINTER
XDR015	JAL	R10,BEGMSG		:GUESS AT FIRST MESSAGE
	STH	R1,ONFMI		:SAVE GUESS
XDR020	LA	RR,IRING,,		:HANDLE IRING
	LHI	RS,IRSIZE		:RING SIZE
	JFS	XDR040
XDR030	LA	RR,ORING,,		:HANDLE ORING
	LHI	RS,ORSIZE		:RING SIZE
XDR040	LIS	R1,0			:CLEAR ACCUMULATOR
XDR050	SVC	0A,0008			:NEXT CHARACTER INTO R0
	J	XDR060			:TIMEOUT, CONTINUE
	NHI	R0,7F			:FORGET PARITY
XDR055	CLHI	R0,0D			:CR ??
	JEFS	XDR060			:DONE INPUTTING IF SO
	NHI	R0,0F			:REDUCE TO 0-F
	SLLS	R1,4			:POSITION ACCUMULATOR 
	OR	R1,R0			:ACCUMULATE ADDRESS
	J	XDR050
XDR060	A	R1,SLOWC,,		:ADD CURRENT TIME
	ST	R1,XDRSEC		:SAVE TIME TO QUIT
	LIS	R1,0			:ASSUME START AT BEG OF RING
	JAL	R10,BEGMSG		:GUESS AT FIRST MESSAGE
	LH	R2,XDRWFL		:DO WE KNOW IT WRAPPED ??
	JE	XDR0A0			:IF NOT
	LH	R1,NFMI,RR		:USE OLDEST ENTRY
	JAL	R10,BEGMSG		:GUESS AT FIRST MESSAGE
	SVC	0B,M.CRLF,,		:NEW LINE
	J	XDR0A4
XDR090	AIS	R1,3			:ROUND UP TO FULL WORD
	NHI	R1,-4			:AND I.E., NEXT MESSAGE
	CR	R1,RS			:TO END OF RING ??
	JLFS	XDR0A0			:IF NOT
	LIS	R1,0			:FOLD TO START OF RING		:DRE 4-JAN-84
XDR0A0	SVC	0B,M.CRLF,,		:CR LF
XDR0A1	CLH	R1,NFMI,RR		:CAUGHT UP ?
	JN	XDR0A4			:NOT YET
	LHL	R0,IORING		:GET "BOTH RINGS" FLAG
	JE	XDR0A3			:IF NOT SET
	CLI	RR,IRING		:SEE IF JUST FINISHED IRING
	JN	XDR0A2			:GO DO IRING NEXT
	LA	RR,ORING,,		:GET SET TO DO ORING
	LHI	RS,ORSIZE
	STH	R1,INFMI		:SAVE IRING POINTER
	LHL	R1,ONFMI		:GET ORING POINTER
	J	XDR0A1			:GO DO IT
XDR0A2	LA	RR,IRING,,		:GET SET TO DO IRING
	LHI	RS,IRSIZE
	STH	R1,ONFMI		:SAVE ORING POINTER
	LHL	R1,INFMI		:GET IRING POINTER
XDR0A3	L	R0,XDRSEC		:TIME TO END THIS 
	CL	R0,SLOWC,,		:COMPARE TO ENDING SECOND
	JL	XDR0FF			:YES, RETURN TO DDT
	SVC	DISMIS,0		:DISMISS A BIT
	J	XDR0A1			:WATCH FOR A CHANGE IN RING
XDR0A4	CLI	RR,ORING		:IS THIS THE ORING?
	JEFS	XDR0A6			:IF SO
	SVC	0B,M.I,,		:OUTPUT "I "
	JFS	XDR0A8			:CONTINUE
XDR0A6	SVC	0B,M.O,,		:OUTPUT "O "
XDR0A8	LB	R2,RING+2,R1,RR		:GET MESSAGE CODE
	LHL	R3,RING,R1,RR		:GET PORT #
	JE	XDR0C0			:IF INTRANODE MESSAGE
	LR	R2,R2			:CHECK FOR NEEDLE
	JE	XDR0F0			:IF SO
	CLHI	R2,9E			:DATA MESSAGE ??
	JL	XDR0B0			:IF SO
	SHI	R2,9E			:BIAS TO 0
	CLHI	R2,L.ISCT		:CHECK MAX MSG TYPE
	JLEFS	XDR0A9			:IF OK
	LHI	R2,L.ISCT+1		:GET "UNDEFINED" MESSAGE
XDR0A9	LA	R4,,R2,R2		:FOR INDEXING
	SVC	0B,XDRICA,R4,R4		:ASCII MESSAGE LABEL
	JAL	R10,XDRISB		:GO DUMP ISIS CONTROL MESSAGE
	J	XDR090			:GO TO NEXT MESSAGE
XDR0B0	SVC	0B,XDRMS3,,		:"DATA" MESSAGE HEADER
	JAL	R10,XDRISA		:GO DUMP ISIS DATA MSG
	J	XDR090			:GO TO NEXT MESSAGE
XDR0C0	CLHI	R2,MAXINM		:CHECK MAX MSG TYPE
	JLE	XDR0C1			:IF OK
	LHI	R2,MAXINM+1		:GET "UNDEFINED" MESSAGE
XDR0C1	LA	R4,,R2,R2		:FOR INDEXING
	SVC	0B,XDRICB,R4,R4		:ASCII MESSAGE LABEL
	TBT	R2,XDRVL,,		:VARIABLE LENGTH MESSAGE ??
	JNFS	XDR0D0			:IF SO BECAUSE CAN'T HANDLE YET
	JAL	R10,XDRISC		:GO DUMP ISIS INTRANODE MESSAGE
	J	XDR090			:GO TO NEXT MESSAGE
XDR0D0	CLHI	R2,8			:AUX CIRCUIT REQUEST ??
	JN	XDR0E0			:MUST BE "1-DOWN"
	LA	R4,0A,R1		:STEP TO SIZE BYTE
	CR	R4,RS			:CHECK FOR WRAP AROUND
	JLFS	XDR0D4			:IF NOT
	SR	R4,RS			:IF SO
XDR0D4	LB	R6,RING,RR,R4		:GET VARIABLE STRING SIZE
	AIS	R6,0B			:ADD CONSTANT PORTION
	LHI	R0,20			:INSERT A SPACE
	SVC	KIO,0E
	JAL	R10,XDRISE		:TO PUT OUT MESSAGE
	J	XDR090
XDR0E0	LA	R4,5,R1			:STEP TO 1-DOWN STRING SIZE
	CR	R4,RS			:CHECK FOR WRAP AROUND		:DRE 4-JAN-84
	JLFS	XDR0E4			:IF NOT
	SR	R4,RS			:IF SO				:DRE 4-JAN-84
XDR0E4	LB	R6,RING,RR,R4		:GET VARIABLE MESSAGE SIZE
	AIS	R6,6			:ADD FIXED MESSAGE LENGTH
	LHI	R0,20			:INSERT A SPACE
	SVC	KIO,0E
	JAL	R10,XDRISE		:TO PUT OUT MESSAGE
	J	XDR090			:TO CONTINUE
XDR0F0	SVC	0B,XDRMS4,,		:NEEDLE MESSAGE
	LB	R6,RING+3,R1,RR		:GET ADDITIONAL LENGTH
	AIS	R6,4			:ADD FIXED PORTION
	LHI	R0,20			:INSERT A BLANK
	SVC	KIO,0E			:PUT IT OUT
	JAL	R10,XDRISE		:TO PUT REST OF MESSAGE
	J	XDR090

XDR0FF	J	DSTRT2			:RETURN TO COMMAND PROCESSOR

CAPIT	TBT	R0,CAPITT,,		:TEST FOR LOWER CASE CHARACTER
	JER	R1			:IF NOT
	SHI	R0,20			:ADJUST TO CAPITALIZE
	JR	R1			:RETURN

:	GUESS AT FIRST MESSAGE IN RING

BEGMSG	AIS	R1,3			:ROUND UP IF GIVEN BUM STEER :DRE 31-DEC-84
	NHI	R1,-4			:ROUND DOWN TO WORD BOUNDARY
BEG010	CR	R1,RS			:SEE IF AT END OF RING
	JLFS	BEG020			:IF NOT			:DRE 31-DEC-84
	LIS	R1,0			:START FRESH
BEG020	LHL	R3,RING,R1,RR		:GET BYTE		:DRE 31-DEC-84
	CLHI	R3,NDPORT		:IS IT A RESONABLE START :DRE 31-DEC-84
	JGFS	BEGCON			:NO, GO TO NEXT FULL WORD :DRE 31-DEC-84
	L	R3,RING,R1,RR		:IS WHOLE WORD NONZERO?
	JNR	R10			:IF SO, SHOULD DO FOR A GUESS
BEGCON	AIS	R1,4			:BUMP POINTER		:DRE 31-DEC-84
	J	BEG010			:TEST NEXT WORD 

:	R1 - RING INDEX
:	R2 - MSG CODE TYPE
:	RS - RING SIZE
:	RR - RING START

:	DATA MESSAGE
XDRISA	LA	R6,3,R2			:MESSAGE LENGTH=MESSAGE TYPE+3
	LHI	R0,20			:INSERT A SPACE
	SVC	KIO,0E			:LETS BE TIDY
	J	XDRISE
:	CONTROL MESSAGE
XDRISB	LB	R6,XDRILA,R2,		:MESSAGE LENGTH FROM TABLE
	LHI	R0,20			:INSERT A SPACE
	SVC	KIO,0E
	J	XDRISE
:	INTRANODE MESSAGE TYPE
XDRISC	LB	R6,XDRILB,R2,		:MESSAGE LENGTH FROM TABLE
	LHI	R0,20			:INSERT A SPACE
	SVC	KIO,0E
	JFS	XDRISE
XDRISD	SVC	0B,XDRASC,,		:ASCII EQUIVALENT OF LINE
	SVC	0B,M.CRLF,,		:NEW LINE
	SVC	0B,XDRMS5,,		:4 BLANKS FOR ALIGNMENT
XDRISE	LIS	R7,0			:LINE LENGTH COUNTER
XDRISF	LB	R5,RING,R1,RR		:NEXT BYTE FROM RING
	LHI	R0,20			:DEFAULT BLANK CHARACTER
	TBT	R5,XDRECH,,		:PRINTABLE ??
	JEFS	XDRISH			:IF NOT, USE BLANK
	LR	R0,R5			:ELSE IF OK TO PRINT IT
XDRISH	LR	R4,R7			:COMPUTE WHERE TO PLUG INTO LINE
	NHI	R4,0F			:16 BYTES PER LINE
	STB	R0,XDRASC+4,R4,,	:PUT 'ER THERE
	JAL	R11,XDTPUT		:PUT IT OUT
	AIS	R1,1			:BUMP RING INDEX
	CR	R1,RS			:END OF RING ??
	JLFS	XDRISG			:IF NOT
	LIS	R1,0			:FOLD TO RING START	:DRE 4-JAN-84
XDRISG	AIS	R7,1			:LINE LENGTH
	CLH	R1,NFMI,RR		:SEE IF AT RING POINTER
	JE	XDRISI			:IF SO GET OUT
	SIS	R6,1			:CHECK FOR END OF MSG
	JLE	XDRISI			:FINISH BLANKING AND PRINT	
	THI	R7,0F			:END OF LINE
	JE	XDRISD			:IF SO
	THI	R7,1			:END OF HALFWORD
	JN	XDRISF			:IF NOT TO CONTINUE
	LHI	R0,20			:ADD A SPACE
	SVC	KIO,0E			:TO FORMAT WORDS
	J	XDRISF
XDRISI	LHI	R0,20			:BLANK
XDRISJ	NHI	R7,0F			:LINE LENGTH OF 16
	JEFS	XDRISK			:IF TO END OF LINE
	STB	R0,XDRASC+4,R7,,	:PUT IN A BLANK
	AIS	R7,1			:COUNT ON UP
	JBS	XDRISJ			:AND SEE IF DONE
XDRISK	SVC	0B,XDRASC,,		:PUT IT OUT
	JR	R10			:DONE



:	PACKET AND FRAME TRACE


X.XF	HS
XFTRAC	LCS	R1,1			:FLAG FRAME TRACE ONLY
	JFS	XDTR05			:GO SET FLAG

X.XP	HS
XPTRAC	LIS	R1,1			:FLAG PACKET TRACE ONLY
	JFS	XDTR05			:GO SET FLAG

X.XPF	HS
XTRACE	LIS	R1,0			:FLAG BOTH PACKET AND FRAME TRACE
XDTR05	STH	R1,PAKFRM		:SET FLAG
	LIS	R1,0
	STB	R1,MSGSPC,,		:INIT STORE BYTE COUNT
	SVC	0B,XDFPRO,,		:PRINT "SEC=" PROMPT
	LIS	R1,0			:CLEAR INTERVAL TIMER
	STH	R1,P.PTR		:CLEAR PACKET TRACE PTR
	STH	R1,F.PTR		:CLEAR FRAME TRACE PTR
XDTR10	SVC	0A,0010			:GET CHAR IN R0
	J	F.099			:16 SECOND TIME OUT
	NHI	R0,7F			:OFF PARITY BIT
	CLHI	R0,030			:DIGIT? ??
	JLFS	XDTR20			:NO, CHECK IT OUT
	NHI	R0,0F			:GET DIGIT PART
	SLLS	R1,4			:POSITION ACCUMULATOR
	OR	R1,R0			:ADD IN LAST DIGIT
	JBS	XDTR10			:GO FOR NEXT DIGIT
XDTR20	A	R1,SLOWC,,		:ADD CURRENT CLOCK
	ST	R1,XDRSEC		:SAVE TIME TO QUIT
	CLHI	R0,0D			:CHECK FOR TYPE OF TERMINATOR
	JE	P.010			:DO IT FROM TOP
	LH	R6,PTRINP,,		:GET PACKET POINTER
	LH	R1,FTRINP,,		:GET FRAME POINTER
	CLHI	R0,2D			:CHECK FOR - TERMINATOR
	JE	XDTR30			:GOT IT SKIP OLD TRACE
	LB	R4,PTRTBL+1,R6,		:GET LINK NUMBER
	AIS	R6,6			:ASSUME MOD 8
  IF	DDTDIA-2						:DRE 8-OCT-87
	AIS	R6,2			:ALLOW ROOM FOR TIME STAMP :DRE 8-OCT-87
  EI
	TBT	R4,P128.F		:TEST FOR MOD 128	:DRE 10-DEC-84
	JEFS	XDTR24			:JUMP IF NOT
	AIS	R6,2			:SET UP FOR MOD 128
XDTR24	LB	R0,FTRTBL,R1,		:GET LINK NUMBER
	NHI	R0,37			:MASK OFF JUNK
	AIS	R1,4			:ASSUME MOD 8
  IF	DDTDIA-2						:DRE 8-OCT-87
	AIS	R6,2			:ALLOW ROOM FOR TIME STAMP :DRE 8-OCT-87
  EI
	TBT	R0,F128.F		:CHECK FOR MOD 128	:DRE 10-DEC-84
	JEFS	XDTR30			:MOD 8
	AIS	R1,2			:MOD 128
XDTR30	STH	R6,P.PTR		:SAVE AS STARTING POINT OF TRACE
	STH	R1,F.PTR		:DITTO

:	PACKET TRACE TABLE
P.010	LH	R6,PAKFRM		:GET PACKET/FRAME TRACE FLAG
	JL	F.010			:IF PACKET TRACE NOT ENABLED
	LH	R6,P.PTR		:OUR PACKET TRACE PTR
	CLH	R6,PTRINP,,		:SAME AS INTERFACE ??
	JE	F.010			:IF PACKET TRACE CAUGHT UP
	SVC	0B,P.CRLF,,		:PUT P HEADER
	LB	R4,PTRTBL+1,R6,		:GET LINK # OF NEXT ENTRY
	STB	R4,XTLINK		:SAVE LINK #
	LIS	R7,6			:ASSUME 6 BYTES FOR MOD 8
	TBT	R4,P128.F		:SEE IF REALLY MOD 8	:DRE 10-DEC-84
	JEFS	P.015			:IF SO
	LIS	R7,8			:8 BYTES/ENTRY FOR MOD 128
P.015	LIS	R8,0			:INIT BYTE POSITION POINTER
  IF	DDTDIA-2						:DRE 25-AUG-86
	AIS	R7,2			:ALLOW FOR EXTENDED TIME STAMP
  EI
P.020	LB	R5,PTRTBL,R6,		:GET BYTE OF TRACE TABLE
	JAL	R11,XDTPUT		:CONVERT AND PRINT
 REMIND(P.020 - MIGHT WANT TO TEST LIMITS BEFORE JUMPING, USE L.XPBY)
	LH	R3,XPBYTE,R8,R8		:FIND ROUTINE TO INTERPRET BYTE
	J	XPBYTE,R3		:GO INTERPRET BYTE

P.025	AIS	R6,1			:ADVANCE OUR PTR
	AIS	R8,1			:INCREMENT BYTE POSITION POINTER
	SIS	R7,1			:DECREMENT ENTRY LENGTH COUNT
	JN	P.020			:CONTINUE
	CLHI	R6,PTRLEN		:END OF TRACE TABLE ??
	JLFS	P.030			:IF NOT
	LIS	R6,0			:WRAP TO START
P.030	STH	R6,P.PTR		:SAVE OUR UPDATED PTR
	SVC	0B,MSGSPC,,		:PRINT INTERPRETATION
	STB	R7,MSGSPC,,		:RESET MESSAGE LENGTH
	J	P.010			:START NEW PACKET ENTRY

:	FRAME TRACE TABLE
F.010	LH	R6,PAKFRM		:GET PACKET/FRAME TRACE FLAG
	JG	F.098			:IF FRAME TRACE NOT ENABLED
	LHL	R6,F.PTR		:GET OUR FRAME TRACE PTR
	CLH	R6,FTRINP,,		:SAME AS INTERFACE PTR ??
	JE	F.098			:IF FRAME TRACE CAUGHT UP
	SVC	0B,F.CRLF,,		:PUT F HEADER
  IF	FML
	LIS	R7,6			:6 BYTE ENTRIES FOR FML
  ELSE
	LB	R0,FTRTBL,R6,		:LINK # OF THIS ENTRY
	NHI	R0,37			:MASK OFF I/O FLAGS
	STB	R0,XTLINK		:SAVE LINK #
	LIS	R7,4			:4 BYTES FOR MOD 8
	TBT	R0,F128.F		:TEST IF LINK MOD 128		:DRE 10-DEC-84
	JEFS	F.015			:IF SO
	LIS	R7,6			:6 BYTES PER ENTRY MOD 128
F.015	HS
  IF	DDTDIA-2						:DRE 25-AUG-86
	AIS	R7,2			:ALLOW FOR EXTENDED TIME STAMP
  EI
  EI	FML
	LIS	R8,0			:INIT BYTE POINTER
F.020	LB	R5,FTRTBL,R6,		:GET BYTE FROM TRACE TABLE
	CLHI	R8,L.XFBY		:RANGE CHECK
	JGFS	F.025			:NOT IN THE TABLE
	JAL	R11,XDTPUT		:CONVERT AND PRINT IT
	LH	R3,XFBYTE,R8,R8		:GET ROUTINE TO INTERPRET BYTE
	J	XFBYTE,R3		:GO INTERPRET BYTE

F.025	AIS	R6,1			:ADVANCE OUR PTR
	AIS	R8,1			:INCREMENT BYTE POINTER
	SIS	R7,1			:DECREMENT ENTRY LENGTH COUNTER
	JN	F.020			:CONTINUE SAME ENTRY
	CLHI	R6,FTRLEN		:TO END OF TABLE ??
	JLFS	F.030			:IF NOT
	LIS	R6,0			:TO WRAP TO START OF TABLE
F.030	STH	R6,F.PTR		:SAVE OUR PTR
	SVC	0B,MSGSPC,,		:PRINT INTERPRETATION
	STB	R7,MSGSPC,,		:RESET MESSAGE LENGTH
	J	F.010			:START NEW FRAME ENTRY

F.098	L	R0,XDRSEC		:SLOWC TIME TO QUIT
	CL	R0,SLOWC,,		:TIME YET ??
	JLFS	F.099			:YES, END OF TRACE TIME
	SVC	DISMIS,0		:DISMISS TO DDT
	J	P.010			:GO LOOK FOR ANOTHER PACKET
F.099	J	DSTRT2			:RETURN TO COMMAND PROCESSOR


:	PACKET INTERPRETATION ROUTINES
PBYTE0	LA	R9,M.IN,,		:INIT WITH "IN" MESSAGE
	CLHI	R5,80			:SEE IF OUT MESSAGE
	JLFS	PB010			:IF NOT
	LA	R9,M.OUT,,		:SET WITH "OUT" MESSAGE
PB010	JAL	R12,MSGMOV		:MOVE MESSAGE TO STORAGE
	NHI	R5,7			:GET LAST 3 BITS
	JE	P.025			:IF NOTHING ELSE
	SIS	R5,1
	JN	P.025			:IF NOT ILLEGAL
	LA	R9,M.ILL,,		:ILLEGAL PACKET
PB020	JAL	R12,MSGMOV		:STORE MESSAGE
	J	P.025			:RETURN

PBYTE1	HS
  IF	NLINES-1
	LA	R9,M.LINE,,		:GET "LINE" MESSAGE
	JAL	R12,MSGMOV		:MOVE TO STORE
	LB	R5,SIAASC,R5,		:CONVERT CHARACTER TO ASCII
	STB	R5,M.1NUM+1,,		:SET CHARACTER INTO MESSAGE
	LA	R9,M.1NUM,,		:GET NUMBER MESSAGE
	JAL	R12,MSGMOV		:MOVE TO STORE
  EI
	J	P.025

PBYTE2	LBR	R3,R5			:GET COPY OF BYTE	:DRE 10-DEC-84
	LHI	R9,020			:LOAD UP BLANK
	NHI	R5,0F			:GET RIGHT NIBBLE	:DRE 10-DEC-84
	JEFS	PBYT25			:ZERO SKIP CONVERSION	:DRE 10-DEC-84
	LB	R9,SIAASC,R5,		:CONVERT SECOND DIGIT TO ASCII	:DRE 10-DEC-84
PBYT25	STB	R9,M.3NUM+1,,		:SAVE RESULT FOR PBYTE3	:DRE 10-DEC-84
	NHI	R3,0F0			:GET LEFT NIBBLE	:DRE 10-DEC-84
	SRLS	R3,4						:DRE 10-DEC-84
	LBR	R5,R3			:GET COPY OF GFI	:DRE 10-DEC-84
	STB	R5,B1M128		:SAVE FOR LATER		:DRE 10-DEC-84
	LA	R9,M.UNGF,,		:GET UNIMPLEMENTED GFI MESSAGE	:DRE 10-DEC-84
	CLHI	R3,3			:GENERAL FORMAT EXTENDER? :DRE 10-DEC-84
	JE	PBYT28			:YES, TELL US ABOUT IT	:DRE 10-DEC-84
	NHI	R5,3			:EXTRACT LOWER 2 BITS	:DRE 10-DEC-84
	JE	PBYT28			:NO MESSAGE IF "RESERVED FOR OTHER APPS":DRE 10-DEC-84
	LA	R9,M.ILGF,,		:COMPLAIN ABOUT ILLEGAL GFI MESSAGE :DRE 10-DEC-84
	CLHI	R5,3			:BAD GFI?		:DRE 10-DEC-84
	JNFS	PBYT29			:NO, SKIP PUMP OUT OF THE MESSAGE :DRE 10-DEC-84
PBYT28	JAL	R12,MSGMOV		:PUT OUT MESSAGE	:DRE 10-DEC-84
PBYT29	LA	R9,M.CHAN,,		:GET "CHAN" MESSAGE	:DRE 10-DEC-84
	JAL	R12,MSGMOV		:MOVE TO STORE		:DRE 10-DEC-84
	J	P.025						:DRE 10-DEC-84

PBYTE3	LBR	R3,R5			:GET CHARACTER
	NHI	R5,0F			:GET RIGHT NIBBLE
	NHI	R3,0F0			:GET LEFT NIBBLE
	SRHLS	R3,4
	LB	R3,SIAASC,R3,		:CONVERT FIRST DIGIT TO ASCII
	LB	R5,SIAASC,R5,		:CONVERT SECOND DIGIT TO ASCII
	STB	R3,M.3NUM+2,,		:SAVE RESULT 		:DRE 10-DEC-84
	STB	R5,M.3NUM+3,,		:SAVE RESULT 		:DRE 10-DEC-84
	LA	R9,M.3NUM,,		:GET CHANNEL NUMBER MESSAGE :DRE 10-DEC-84
	JAL	R12,MSGMOV		:MOVE TO STORE		:DRE 10-DEC-84
	J	P.025

PBYTE4	LB	R3,B1M128		:GET SAVED GFI		:DRE 10-DEC-84
	LA	R9,M.LEV1,,		:LOAD UP Q-BIT MESSAGE	:DRE 10-DEC-84
	THI	R3,08			:CHECK FOR QBIT MESSAGE	:DRE 10-DEC-84
	JEFS	PBYT42			:NOT ON, SKIP MESSAGE	:DRE 10-DEC-84
	JAL	R12,MSGMOV		:PUT OUT MESSAGE	:DRE 10-DEC-84
PBYT42	LA	R9,M.DBIT,,		:GET D-BIT MESSAGE READY :DRE 10-DEC-84
	THI	R3,04			:CHECK FOR D-BIT	:DRE 10-DEC-84
	JEFS	PBYT44			:NOT ON			:DRE 10-DEC-84
	JAL	R12,MSGMOV		:PUT OUT MESSAGE	:DRE 10-DEC-84
PBYT44	LB	R3,XTLINK		:GET LINK #
	TBT	R3,P128.F		:SEE IF MOD 128
	JEFS	PBYT46			:IF MOD 8		:DRE 16-JAN-84
	STB	R5,B1M128		:SAVE FOR LATER
	J	P.025			:GO ON

PBYT46	LBR	R3,R5			:SAVE BYTE		:DRE 16-JAN-84
	NHI	R3,0F			:GET RIGHT DIGIT
	CLHI	R3,L.PTYP		:RANGE CHECK
	JG	P.025			:NOT IN THE TABLE
	LH	R4,PTYPE,R3,R3		:GET ROUTINE TO HANDLE TYPE
	J	PTYPE,R4

PBYTE5	LB	R3,XTLINK		:GET LINK #
	TBT	R3,P128.F		:SEE IF MOD 128		:DRE 10-DEC-84
	JE	PBYT75			:IF NOT
	STB	R5,B2M128		:SAVE FOR LATER
	LB	R5,B1M128		:GET TYPE BYTE
	J	PBYT46

PBYTE6	J	P.025

PBYTE7	LB	R3,XTLINK		:GET LINK #
	TBT	R3,P128.F		:SEE IF MOD 128		:DRE 10-DEC-84
	JE	PBYTE9			:IF NOT
PBYT75	CLHI	R5,L.PCHS		:RANGE CHECK
	JG	P.025			:NOT IN THE TABLE
	LH	R9,PCHST,R5,R5		:GET CHANNEL STATE MESSAGE ADDRESS
	AI	R9,PCHST		:UNBIAS
	JAL	R12,MSGMOV		:MOVE TO STORE


PBYTE8	HS
PBYTE9	J	P.025

PDATA	LB	R2,XTLINK		:GET LINK #
	TBT	R2,P128.F		:SEE IF MOD 128		:DRE 10-DEC-84
	JE	PDA30			:IF MOD 8

	SRLS	R5,1			:CONVERT TO P(S)
	LBR	R2,R5
	NHI	R5,0F			:GET RIGHTMOST DIGIT
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII
	STB	R5,M.DATE+0C,,		:STORE IN MESSAGE
	SRLS	R2,4			:GET LEFT DIGIT
	JEFS	PDA10			:SUPRESS LEADING ZERO
	LB	R2,SIAASC,R2,		:CONVERT TO ASCII
PDA10	STB	R2,M.DATE+0B,,		:STORE IN MESSAGE
	LB	R5,B2M128		:GET FOURTH BYTE
	THI	R5,1			:CHECK FOR M-BIT	:DRE 10-DEC-84
	JEFS	PDA15			:NOT ON			:DRE 10-DEC-84
	LA	R9,M.MBIT,,		:GET MESSAGE		:DRE 10-DEC-84
	JAL	R12,MSGMOV		:PUT IT OUT		:DRE 10-DEC-84
PDA15	SRLS	R5,1			:CONVERT TO P(R)	:DRE 10-DEC-84
	LBR	R2,R5
	NHI	R5,0F			:GET RIGHTMOST DIGIT
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII
	STB	R5,M.DATE+8,,		:STORE IN MESSAGE
	SRLS	R2,4			:GET LEFT DIGIT
	JEFS	PDA20			:SUPRESS LEADING ZERO
	LB	R2,SIAASC,R2,		:CONVERT TO ASCII
PDA20	STB	R2,M.DATE+7,,		:STORE IN MESSAGE
	LA	R9,M.DATE,,		:POINT TO EXTENDED I-FRAME MESSAGE
	JAL	R12,MSGMOV		:MOVE TO STORE
	J	P.025			:GO BACK

PDA30	THI	R5,1			:CHECK M-BIT		:DRE 10-DEC-84
	JEFS	PDA35			:NOT SET		:DRE 10-DEC-84
	LA	R9,M.MBIT,,				:DRE 10-DEC-84
	JAL	R12,MSGMOV		:PUT OUT M-BIT MESSAGE	:DRE 10-DEC-84
	LBR	R3,R5			:GET BACK P(S)		:DRE 10-DEC-84
	NHI	R3,0F			:CLEAR P(R) AND M-BIT	:DRE 10-DEC-84
PDA35	SRHLS	R3,1			:DETERMINE P(S)		:DRE 10-DEC-84
	SRHLS	R5,5			:DETERMINE P(R)		:DRE 10-DEC-84
	AHI	R3,30			:CONVERT TO ASCII
	AHI	R5,30			:CONVERT TO ASCII
	STB	R5,M.DATA+7,,		:PUT INTO DATA MESSAGE
	STB	R3,M.DATA+0A,,		:PUT INTO DATA MESSAGE
	LA	R9,M.DATA,,		:GET DATA MESSAGE
	JAL	R12,MSGMOV		:MOVE TO STORE
	J	P.025

PGEN	CLHI	R5,0F0
	JL	PGEN10			:IF DIAG, RESTART, OR RESTART CONF.
	SRHLS	R5,1			:DIVIDE BY 2		:DRE 10-DEC-84
	NHI	R5,7			:JUST GET 3 BITS	:DRE 10-DEC-84
	LH	R4,PGTF,R5,R5		:GET MESSAGE ADDRESS
	JE	P.025			:GET OUT IF NONE
	LI	R9,PGTF,R4		:GET FULL ADDRESS
	J	PGEN20			:GO MOVE MESSAGE

PGEN10	SRHLS	R5,2			:DIVIDE BY 4
	LH	R4,PGTB,R5,R5		:GET MESSAGE ADDRESS
	JE	P.025			:GET OUT IF NONE
	LI	R9,PGTB,R4		:GET FULL ADDRESS
PGEN20	JAL	R12,MSGMOV		:MOVE MESSAGE
	J	P.025

PRR	LA	R9,M.RR,,		:GET RR MESSAGE
	JFS	PREJ10

PRNR	LA	R9,M.RNR,,		:GET RNR MESSAGE
	JFS	PREJ10

PREJ	LA	R9,M.REJ,,		:GET REJ MESSAGE
PREJ10	JAL	R12,MSGMOV		:MOVE TO STORE
	LB	R2,XTLINK		:GET LINK #
	TBT	R2,P128.F		:SEE IF MOD 128		:DRE 10-DEC-84
	JE	PREJ30			:IF MOD 8

	LB	R2,B2M128		:GET N(R) SAVED FROM BEFORE
	LBR	R5,R2
	SRLS	R5,1			:CONVERT TO N(S)
	NHI	R5,0F			:GET RIGHTMOST DIGIT
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII
	STB	R5,M.2NUM+2,,		:PUT INTO MESSAGE	:DRE 10-DEC-84
	SRLS	R2,5			:GET LEFT DIGIT		:DRE 10-DEC-84
	JEFS	PREJ40			:SUPPRESS LEADING ZERO	:DRE 10-DEC-84
	LB	R2,SIAASC,R2,		:CONVERT TO ASCII	:DRE 10-DEC-84
PREJ20	STB	R2,M.2NUM+1,,		:PUT INTO MESSAGE	:DRE 10-DEC-84
	LA	R9,M.2NUM,,		:POINT TO MESSAGE	:DRE 10-DEC-84
	JFS	PREJ50					:DRE 10-DEC-84	

PREJ30	SRHLS	R5,5			:CONVERT TO P(R)	:DRE 10-DEC-84
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII	:DRE 10-DEC-84
PREJ40	STB	R5,M.1NUM+1,,		:PUT INTO MESSAGE	:DRE 10-DEC-84
	LA	R9,M.1NUM,,		:POINT TO NUMBER MESSAGE:DRE 10-DEC-84
PREJ50	JAL	R12,MSGMOV		:MOVE TO STORE		:DRE 10-DEC-84
	J	P.025			:RETURN

:	FRAME INTERPRETATION ROUTINES

FBYTE0	LIS	R9,5
	STH	R9,XFTPF		:INIT TO FRAME COMING IN
	LA	R9,M.IN,,		:INIT WITH "IN" MESSAGE
	CLHI	R5,80			:SEE IF OUT MESSAGE
	JLFS	FB010			:IF NOT
	LIS	R9,0
	STH	R9,XFTPF		:INDICATE FRAME GOING OUT
	LA	R9,M.OUT,,		:SET WITH "OUT" MESSAGE
FB010	JAL	R12,MSGMOV		:MOVE MESSAGE TO STORAGE
	NHI	R5,1F			:GET LAST 5 BITS
	STB	R5,FLN			:SAVE LINE NUMBER
  IF	.GE.(NLINES,2)						:DRE 10-DEC-84
	LA	R9,M.LINE,,		:GET "LINE" MESSAGE
	JAL	R12,MSGMOV		:MOVE TO STORE
     IF	.GE.(NLINES,10)
	LBR	R9,R5			:GET RIGHTMOST DIGIT
	SRLS	R5,4			:GET LEFT DIGIT		:DRE 10-DEC-84
	JE	FB012			:SKIP THIS FOR  SMALL NUMBERS:DRE 10-DEC-84
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII	:DRE 10-DEC-84
	STB	R5,M.2NUM+1,,		:PLACE INTO NUMBER MESSAGE:DRE 10-DEC-84
	LB	R9,SIAASC,R9,		:CONVERT CHARACTER TO ASCII:DRE 10-DEC-84
	STB	R9,M.2NUM+2,,		:PLACE INTO NUMBER MESSAGE:DRE 10-DEC-84
	LA	R9,M.2NUM,,		:GET NUMBER MESSAGE	:DRE 10-DEC-84
	JFS	FB014						:DRE 10-DEC-84
     EI
FB012	LB	R5,SIAASC,R5,		:CONVERT CHARACTER TO ASCII:DRE 10-DEC-84
	STB	R5,M.1NUM+1,,		:SET CHARACTER INTO MESSAGE:DRE 10-DEC-84
	LA	R9,M.1NUM,,		:GET NUMBER MESSAGE	:DRE 10-DEC-84
FB014	JAL	R12,MSGMOV		:MOVE TO STORE		:DRE 10-DEC-84
  EI								:DRE 10-DEC-84
	J	F.025

FBYTE1	STB	R5,XFTIS		:SAVE INTERFACE STATE
	J	F.025

FBYTE2	HS
   IF	LAP!LAPB
	LB	R3,XFTIS		:GET INTERFACE STATE
	NHI	R3,0F			:MASK OUT ERROR VALUE
	LB	R9,FLN			:GET LINE NUMBER
	CLB	R5,PADRT,R9,		:SEE IF PRIMARY (RESPONSE) ADDRESS
	JE	FB210			:IF PRIMARY ADDRESS
	CLB	R5,SADRT,R9,		:SEE IF SECONDARY (COMMAND) ADDRESS
	JN	F.025			:IF NOT PRIMARY OR SECONDARY ADDRESS
	LHL	R9,XFTPF		:GET POLL/FINAL INDICATOR
	SIS	R9,6			:REVERSE FOR SECONDARY
	XHI	R9,0FFFF
	STH	R9,XFTPF
      IF	LAP
	AIS	R3,8			:ADD BIAS FOR SECONDARY
      ELSE
	AIS	R3,7			:ADD BIAS FOR SECONDARY
      EI	LAP
FB210	HS
      IF	LAP
	CLHI	R3,L.LAPI
	JG	F.025			:IF INTERFACE STATE OUT OF RANGE
	LH	R9,LAPIST,R3,R3		:GET LAP INTERFACE STATE MESSAGE ADDRESS
	LI	R9,LAPIST,R9		:GET FULL ADDRESS
      ELSE
	CLHI	R3,L.LABI
	JG	F.025			:IF INTERFACE STATE OUT OF RANGE
	LH	R9,LABIST,R3,R3		:GET LAPB INTERFACE STATE MESSAGE ADDRESS
	LI	R9,LABIST,R9		:GET FULL ADDRESS
      EI	LAP
	JAL	R12,MSGMOV		:MOVE STATE MESSAGE TO STORE
   ELSE
   EI	LAP!LAPB
	J	F.025

FBYTE3	HS
  IF	LAP!LAPB
	LB	R2,XTLINK		:GET LINK #
	TBT	R2,F128.F		:SEE IF MOD 128		:DRE 10-DEC-84
	JEFS	FB330			:IF MOD 8
	STB	R5,B1M128		:SAVE TYPE FOR LATER
	J	F.025			:GO BACK
FB330	LBR	R2,R5
	SRLS	R2,4			:GET LEFT DIGIT
	NHI	R5,0F			:GET RIGHTMOST DIGIT ONLY 	
	LH	R9,FTYPE,R5,R5		:GET ROUTINE ADDRESS
	J	FTYPE,R9
  ELSE
	J	F.025
  EI	LAP!LAPB

FBYTE4	HS
  IF	LAP!LAPB
	LB	R2,XTLINK		:GET LINK #
	TBT	R2,F128.F		:SEE IF MOD 128		:DRE 10-DEC-84
	JEFS	FBYTE5			:IF MOD 8
	STB	R5,B2M128		:SAVE FOR LATER
	LB	R5,B1M128		:GET TYPE
	J	FB330			:GO PROCESS TYPE
  ELSE
	J	F.025
  EI	LAP!LAPB

FBYTE5	HS
FBYTE6	HS
FBYTE7	J	F.025

FBQUES	LA	R9,M.QUES,,		:LOAD UP ILLEGAL TYPE MSG :DRE 28-APR-86
	J	FBSAM2			:HANDLE REST OF PROCESS	:DRE 28-APR-86

FBREJ	LA	R9,M.REJ,,		:POINT TO REJ MESSAGE	:DRE 10-DEC-84
	JFS	FBRR0						:DRE 10-DEC-84

FBRNR	LA	R9,M.RNR,,		:POINT TO RNR MESSAGE	:DRE 10-DEC-84
	JFS	FBRR0						:DRE 10-DEC-84

FBRR	LA	R9,M.RR,,		:POINT TO RR MESSAGE	:DRE 10-DEC-84
FBRR0	JAL	R12,MSGMOV		:MOVE TO STORE		:DRE 10-DEC-84
	LB	R5,XTLINK		:GET LINK #
	TBT	R5,F128.F		:SEE IF MOD 128		:DRE 10-DEC-84
	JE	FBRR2			:IF MOD 8
	LB	R2,B2M128		:GET N(R) SAVED FROM BEFORE
	LBR	R5,R2
	SRLS	R5,1			:CONVERT TO N(S)
	NHI	R5,0F			:GET RIGHTMOST DIGIT
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII
	STB	R5,M.2NUM+2,,		:PUT INTO MESSAGE	:DRE 10-DEC-84
	SRLS	R2,5			:GET LEFT DIGIT
	JE	FBRR25			:SUPPRESS LEADING ZERO
	LB	R2,SIAASC,R2,		:CONVERT TO ASCII
FBRR1	STB	R2,M.2NUM+1,,		:PUT INTO MESSAGE	:DRE 10-DEC-84
	LA	R9,M.2NUM,,		:POINT TO MESSAGE	:DRE 10-DEC-84
	JAL	R12,MSGMOV		:MOVE TO STORE
	JFS	FBRR3			:TAKE CARE OF P/F BIT	:DRE 10-DEC-84
FBRR2	LBR	R5,R2			:GET LEFT DIGIT		:DRE 10-DEC-84
	SRLS	R5,1			:CONVERT TO N(R)
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII
FBRR25	STB	R5,M.1NUM+1,,		:PUT INTO MESSAGE	:DRE 10-DEC-84
	LA	R9,M.1NUM,,		:POINT TO NUMBER MESSAGE:DRE 10-DEC-84
	JAL	R12,MSGMOV		:MOVE TO STORE
FBRR3	LB	R9,XTLINK		:GET LINK #		:DRE 10-DEC-84
	TBT	R9,F128.F		:SEE IF MOD 128		:DRE 10-DEC-84
	JEFS	FBRR5			:IF NOT			:DRE 10-DEC-84
	LB	R2,B2M128		:GET BYTE SAVED FROM BEFORE
FBRR5	NHI	R2,1			:TEST P/F BIT		:DRE 10-DEC-84
	JE	F.025			:IF NOT SET
	LHL	R2,XFTPF		:GET POLL/FINAL MESSAGE DISPLACEMENT
	LA	R9,M.POLL,R2,		:POINT TO ADDRESS
	JAL	R12,MSGMOV		:MOVE TO STORE
	J	F.025

FBSAM	LBR	R5,R2			:GET LEFT DIGIT
	NHI	R5,0E
	CLHI	R5,L.FSAM*2		:RANGE CHECK
	JG	FBQUES			:NOT IN TABLE		:DRE 28-APR-86

	LH	R5,FSAMTB,R5,		:GET APPROPRIATE MESSAGE DISPLACEMENT
	LI	R9,FSAMTB,R5		:GET MESSAGE ADDRESS
FBSAM2	JAL	R12,MSGMOV		:MOVE TO STORE
	J	FBRR3			:TAKE CARE OF P/F BIT	:DRE 10-DEC-84

FBDUA	LA	R9,M.UA,,		:POINT TO UA MESSAGE
	CLHI	R2,8			:SEE IF ILLEGAL		:DRE 28-APR-86
	JGE	FBQUES			:PUT OUT ILL MSG IF NOT	:DRE 28-APR-86
	CLHI	R2,6			:SEE IF UA
	JGEFS	FBDUA2			:IF SO
	CLHI	R2,4			:SEE IF DISC		:DRE 28-APR-86
	JL	FBQUES			:PUT OUT ILL MSG IF NOT	:DRE 28-APR-86
	LA	R9,M.DISC,,		:POINT TO DISC MESSAGE
FBDUA2	JAL	R12,MSGMOV		:MOVE TO STORE
	J	FBRR3			:TAKE CARE OF P/F BIT	:DRE 10-DEC-84

FBFRM	CLHI	R2,9			:REALLY A FRMR		:DRE 28-APR-86
	JG	FBQUES			:PUT OUT ILL MSG IF NOT	:DRE 28-APR-86
	CLHI	R2,8			:REALLY A FRMR		:DRE 28-APR-86
	JL	FBQUES			:PUT OUT ILL MSG IF NOT	:DRE 28-APR-86
	LA	R9,M.FRMR,,		:POINT TO FRAME REJECT MESSAGE
	JAL	R12,MSGMOV		:MOVE TO STORE
	J	FBRR3			:TAKE CARE OF P/F BIT	:DRE 10-DEC-84

FINFO	LB	R9,XTLINK		:GET LINK #
	TBT	R9,F128.F		:SEE IF MOD 128		:DRE 10-DEC-84
	JE	FINF8			:IF MOD 8
	LB	R5,B1M128		:GET THIRD BYTE
	SRLS	R5,1			:CONVERT TO N(S)
	LBR	R2,R5
	NHI	R5,0F			:GET RIGHTMOST DIGIT
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII
	STB	R5,M.IFRE+0C,,		:STORE IN MESSAGE
	SRLS	R2,4			:GET LEFT DIGIT
	JEFS	FINF1			:SUPRESS LEADING ZERO
	LB	R2,SIAASC,R2,		:CONVERT TO ASCII
FINF1	STB	R2,M.IFRE+0B,,		:STORE IN MESSAGE
	LB	R5,B2M128		:GET FOURTH BYTE
	SRLS	R5,1			:CONVERT TO N(R)
	LBR	R2,R5
	NHI	R5,0F			:GET RIGHTMOST DIGIT
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII
	STB	R5,M.IFRE+8,,		:STORE IN MESSAGE
	SRLS	R2,4			:GET LEFT DIGIT
	JEFS	FINF2			:SUPRESS LEADING ZERO
	LB	R2,SIAASC,R2,		:CONVERT TO ASCII
FINF2	STB	R2,M.IFRE+7,,		:STORE IN MESSAGE
	LA	R9,M.IFRE,,		:POINT TO EXTENDED I-FRAME MESSAGE
	LB	R2,B2M128		:GET BYTE WITH P/F BIT
	J	FINF9

FINF8	SRLS	R5,1			:CONVERT RIGHTMOST DIGIT TO N(S)
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII
	STB	R5,M.IFRM+0A,,		:PUT DIGIT INTO I-FRAME MESSAGE
	LBR	R5,R2			:GET LEFT DIGIT
	SRLS	R5,1			:CONVERT LEFT DIGIT TO N(R)
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII
	STB	R5,M.IFRM+7,,		:PUT DIGIT INTO I-FRAME MESSAGE
	LA	R9,M.IFRM,,		:POINT TO I-FRAME MESSAGE
FINF9	JAL	R12,MSGMOV		:MOVE TO STORE
	J	FBRR3			:TAKE CARE OF P/F BIT	:DRE 10-DEC-84

  IF	HDLC

:	SIO STATUS INTERPRETER

XSIO	LIS	R5,0			:INIT SIO STATUS POINTER
XSIO10	LR	R3,R5
	SLLS	R3,2			:CONVERT WORD POINTER TO BYTE POINTER
	L	R6,SIOTBL,R3,		:GET ADDRESS OF SIO STATUS
	LIS	R7,0			:INIT HALFWORD COUNTER
	STB	R7,MSGSPC,,		:INIT MESSAGE STORE
  IF	NLINES-1
	LR	R3,R5
	SRLS	R3,4			:GET FIRST NIBBLE OF LINE NUMBER
	LB	R3,SIAASC,R3,		:CONVERT SIO UNIT NUMBER TO ASCII
	STB	R3,M.SIO+9,,		:PUT INTO SIO MESSAGE
	LR	R3,R5
	NHI	R3,0F			:GET SECOND NIBBLE
	LB	R3,SIAASC,R3,		:CONVERT SIO UNIT NUMBER TO ASCII
	STB	R3,M.SIO+0A,,		:PUT INTO SIO MESSAGE
	LA	R9,M.SIO,,		:POINT TO SIO MESSAGE
	JAL	R12,MSGMOV		:MOVE TO STORE
  EI
XSIO20	LHL	R1,,R6,R7		:GET HALFWORD OF STATUS
	STH	R1,XSTRSH		:SAVE IN WORK SPACE
	LH	R3,XSIOTB,R7		:FIND HALFWORD HANDLER
	JEFS	XSIO40			:IF NO HANDLER
	J	XSIOTB,R3		:GO DO IT

XSIO30	SVC	0B,MSGSPC,,		:PRINT MESSAGES IN STORE
XSIO40	LIS	R1,0
	STB	R1,MSGSPC,,		:REINIT STORE
	AIS	R7,2			:GO TO NEXT HALFWORD
	CLHI	R7,0E
	JL	XSIO20			:IF NOT DONE
	AIS	R5,1			:BUMP SIO UNIT NUMBER
	CLHI	R5,NLINES
	JL	XSIO10			:DO IT AGAIN
	J	DSTRT2			:RETURN TO COMMAND PROCESSOR

XSHAF0	LA	R9,M.READ,,		:POINT TO READ STATUS HEADER
	JAL	R12,MSGMOV		:MOVE TO STORE
XSHF00	JFFOH	R1,XSHF01		:SEE IF ANY BITS SET
	J	XSIO30			:RETURN
XSHF01	LH	R9,XSHW0,R2,R2		:GET MESSAGE ADDRESS
	JE	XSHF02			:IF NONE
	AI	R9,XSHW0		:UNBIAS
	JAL	R12,MSGMOV		:MOVE MESSAGE TO STORE
XSHF02	RBT	R2,XSTRSH		:RESET BIT
	LHL	R1,XSTRSH		:GET UPDATED HALFWORD
	J	XSHF00			:LOOK FOR MORE BITS

XSHAF1	LR	R3,R1	
	NHI	R3,0F			:GET NIBBLE
	LB	R3,SIAASC,R3,		:TRANSLATE TO ASCII
	STB	R3,M.CRC+10,,		:PUT INTO CRC MESSAGE
	SRHLS	R1,4			:DISCARD USED NIBBLE
	LR	R3,R1
	NHI	R3,0F			:GET NEXT NIBBLE
	LB	R3,SIAASC,R3,		:TRANSLATE TO ASCII
	STB	R3,M.CRC+0F,,		:PUT INTO CRC MESSAGE
	SRHLS	R1,4			:DISCARD USED NIBBLE
	LR	R3,R1	
	NHI	R3,0F			:GET NIBBLE
	LB	R3,SIAASC,R3,		:TRANSLATE TO ASCII
	STB	R3,M.IDLE+10,,		:PUT INTO ABORT MESSAGE
	SRHLS	R1,4			:DISCARD USED NIBBLE
	LR	R3,R1
	NHI	R3,0F			:GET NEXT NIBBLE
	LB	R3,SIAASC,R3,		:TRANSLATE TO ASCII
	STB	R3,M.IDLE+0F,,		:PUT INTO IDLE MESSAGE
	LA	R9,M.IDLE,,		:POINT TO IDLE MESSAGE
	JAL	R12,MSGMOV		:MOVE TO STORE
	LA	R9,M.CRC,,		:POINT TO CRC MESSAGE
	JAL	R12,MSGMOV		:MOVE TO STORE
	J	XSIO30			:RETURN

XSHAF2	LR	R4,R1			:TRANSFER VALUE
	SRHLS	R4,4			:GET ABORT COUNT
	LR	R3,R4
	NHI	R3,0F			:GET NIBBLE
	LB	R3,SIAASC,R3,		:TRANSLATE TO ASCII
	STB	R3,M.ABOR+11,,		:PUT INTO ABORT COUNT MESSAGE
	SRHLS	R4,4			:DISCARD USED NIBBLE
	LR	R3,R4
	NHI	R3,0F			:GET NEXT NIBBLE
	LB	R3,SIAASC,R3,		:TRANSLATE TO ASCII
	STB	R3,M.ABOR+10,,		:PUT INTO ABORT COUNT MESSAGE
	SRHLS	R4,4			:DISCARD USED NIBBLE
	LR	R3,R4
	NHI	R3,0F			:GET NIBBLE
	LB	R3,SIAASC,R3,		:TRANSLATE TO ASCII
	STB	R3,M.ABOR+0F,,		:PUT INTO ABORT COUNT MESSAGE
	LA	R9,M.ABOR,,		:POINT TO ABORT MESSAGE
	JAL	R12,MSGMOV		:MOVE TO STORE

	NHI	R1,0F			:GET FLAG BITS
	STH	R1,XSTRSH		:SAVE FLAG BITS
XSHF20	JFFOH	R1,XSHF21		:SEE IF ANY BITS SET
	J	XSIO30			:RETURN

XSHF21	LH	R9,XSHW2,R2,R2		:GET MESSAGE ADDRESS
	JE	XSHF22			:IF NONE
	AI	R9,XSHW2		:UNBIAS
	JAL	R12,MSGMOV		:MOVE MESSAGE TO STORE
XSHF22	RBT	R2,XSTRSH		:RESET BIT
	LHL	R1,XSTRSH		:GET UPDATED HALFWORD
	J	XSHF20			:LOOK FOR MORE BITS

XSHAF3	LR	R3,R1						:DRE 25-MAR-86
	NHI	R3,0F			:GET NIBBLE		:DRE 25-MAR-86
	LB	R3,SIAASC,R3,		:TRANSLATE TO ASCII	:DRE 25-MAR-86
	STB	R3,M.TUNC+1D,,		:PUT INTO TRANSMIT UNDERRUN MESSAGE	:DRE 25-MAR-86
	SRHLS	R1,4			:DISCARD USED NIBBLE	:DRE 25-MAR-86
	LR	R3,R1						:DRE 25-MAR-86
	NHI	R3,0F			:GET NEXT NIBBLE	:DRE 25-MAR-86
	LB	R3,SIAASC,R3,		:TRANSLATE TO ASCII	:DRE 25-MAR-86
	STB	R3,M.TUNC+1C,,		:PUT INTO TRANSMIT UNDERRUN MESSAGE	:DRE 25-MAR-86
	SRHLS	R1,4			:DISCARD USED NIBBLE	:DRE 25-MAR-86
	LR	R3,R1						:DRE 25-MAR-86
	NHI	R3,0F			:GET NIBBLE		:DRE 25-MAR-86
	LB	R3,SIAASC,R3,		:TRANSLATE TO ASCII	:DRE 25-MAR-86
	STB	R3,M.ROVC+1D,,		:PUT INTO RECEIVE OVERFLOW MESSAGE	:DRE 25-MAR-86
	SRHLS	R1,4			:DISCARD USED NIBBLE	:DRE 25-MAR-86
	LR	R3,R1						:DRE 25-MAR-86
	NHI	R3,0F			:GET NEXT NIBBLE	:DRE 25-MAR-86
	LB	R3,SIAASC,R3,		:TRANSLATE TO ASCII	:DRE 25-MAR-86
	STB	R3,M.ROVC+1C,,		:PUT INTO RECEIVE OVERRUN MESSAGE	:DRE 25-MAR-86
	LA	R9,M.ROVC,,		:POINT TO RECEIVE OVERRUN MESSAGE	:DRE 25-MAR-86
	JAL	R12,MSGMOV		:MOVE TO STORE		:DRE 25-MAR-86
	LA	R9,M.TUNC,,		:POINT TO TRANSMIT UNDERRUN MESSAGE	:DRE 25-MAR-86
	JAL	R12,MSGMOV		:MOVE TO STORE		:DRE 25-MAR-86
	J	XSIO30			:RETURN			:DRE 25-MAR-86

XSHAF4	LA	R9,M.INTS,,		:POINT TO INTERRUPT STATUS HEADER
	JAL	R12,MSGMOV		:MOVE TO STORE
	SRHLS	R1,3			:PUT BIT 13 INTO CARRY
	JNCFS	XSHF40			:IF NOT SET
	LA	R9,M.NFNE,,		:POINT TO NONFUNCTIONING BOARD MESSAGE
	JAL	R12,MSGMOV
XSHF40	SRHLS	R1,1			:PUT BIT 12 INTO CARRY
	JNCFS	XSHF41			:IF NOT SET
	LA	R9,M.BUSY,,		:POINT TO BUSY MESSAGE
	JAL	R12,MSGMOV
XSHF41	SRHLS	R1,8			:GET LAST NIBBLE	:DRE 25-MAR-86
	LH	R9,XSHW4,R1,R1		:GET MESSAGE ADDRESS
	JE	XSIO30			:IF NONE
	AI	R9,XSHW4		:UNBIAS
	JAL	R12,MSGMOV		:MOVE MESSAGE TO STORE
	J	XSIO30			:RETURN

XSHAF5	J	XSIO30			:RETURN

XSHAF6	J	XSIO30			:RETURN

  EI	HDLC

:	PACKET BUFFER TRACE TABLE

X.XPB	HS
XPBTR	LH	R1,PBTINP,,		:GET PRESENT POINTER
	AIS	R1,4			:BUMP TO NEXT ENTRY
	CLHI	R1,PBTLEN		:END OF TABLE?
	JLFS	XPBT00			:IF NOT
	LIS	R1,0			:POINT TO BEGINNING OF TABLE
XPBT00	STH	R1,P.PTR		:INIT POINTER TO ONE AFTER PRESENT POINTER
	LIS	R1,0
	STB	R1,MSGSPC,,		:INIT STORE BYTE COUNT
	SVC	0B,XDFPRO,,		:PRINT "SEC=" PROMPT
XPBT10	SVC	0A,0010			:GET CHAR IN R0
	J	PBT99			:16 SECOND TIME OUT
	NHI	R0,7F			:OFF PARITY BIT
	CLHI	R0,0D			:CR ??
	JEFS	XPBT20			:IF SO
	NHI	R0,0F			:GET DIGIT PART
	SLLS	R1,4			:POSITION ACCUMULATOR
	OR	R1,R0			:ADD IN LAST DIGIT
	JBS	XPBT10			:GO FOR NEXT DIGIT
XPBT20	A	R1,SLOWC,,		:ADD CURRENT CLOCK
	ST	R1,XDRSEC		:SAVE TIME TO QUIT

PBT10	LH	R6,P.PTR		:OUR PACKET TRACE PTR
PBT12	CLH	R6,PBTINP,,		:SAME AS INTERFACE ??
	JE	PBT98			:IF PACKET BUFFER TRACE CAUGHT UP
	L	R13,PBTTBL,R6,		:GET ADDRESS OF BUFFER
	NI	R13,0FFFFFF		:MASK OFF LINK NUMBER
	CI	R13,RSC
	JL	PBT25			:IF TOO SMALL FOR TABLE ENTRY
	LHL	R7,2,R13		:GET BYTE COUNT FROM BUFFER
	JE	PBT25			:IF NOTHING IN BUFFER
	AIS	R7,4			:ADD HEADER LENGTH
	CLHI	R7,44			:TRUNCATE IF > 68 BYTES :LSH 30-MAR-87
	JLE	PBT13			:<= 68, GO AHEAD.	:LSH 30-MAR-87
	LHI	R7,44			:OTHERWISE SET IT TO 68 :LSH 30-MAR-87
PBT13	LIS	R8,0			:INIT BYTE POSITION POINTER
PBT20	LIS	R1,2			:INIT FIELD WIDTH FOR NUMBER CONVERSION
	LB	R5,,R13,R8		:GET BYTE OF BUFFER
	JAL	R11,NUMMOV,,		:CONVERT AND PRINT
	AIS	R8,1			:INCREMENT BYTE POSITION POINTER
	LR	R3,R8			:SEE IF NEED CR
	NHI	R3,1F			:CR ADDED AFTER 20x BYTES
	JNFS	PBT22			:IF NOT
	LA	R9,M.CRLF,,		:POINT TO CRLF
	JAL	R12,MSGMOV		:MOVE TO STORE
PBT22	NHI	R3,1			:ODD BYTE?
	JN	PBT23			:IF NOT			:DRE 22-MAR-85
	LHI	R5,0A0			:GET SPACE CHARACTER
	JAL	R11,BYTMOV		:MOVE TO STORE
  IF	1-FML							:DRE 29-MAR-85
	CLHI	R8,4			:FOURTH CHAR?		:DRE 22-MAR-85
	JNFS	PBT23			:NO, SKIP NEXT TEST	:DRE 22-MAR-85
	LB	RL,PBTTBL,R6,		:GET LINE NUMBER	:DRE 22-MAR-85
	TBT	RL,F128.F		:IS THIS MOD 128 FRAMING?:DRE 22-MAR-85
	JEFS	PBT23			:NO			:DRE 22-MAR-85
	AIS	R13,1			:YES, SKIP OVER EXTRANEOUS BYTE:DRE 22-MAR-85
  EI
PBT23	SIS	R7,1			:DECREMENT ENTRY LENGTH COUNT
	JN	PBT20			:CONTINUE
	LA	R9,M.CRLF,,		:END WITH CRLF
	JAL	R12,MSGMOV		:MOVE TO STORE
	SVC	0B,MSGSPC,,		:PRINT INTERPRETATION
	STB	R7,MSGSPC,,		:RESET MESSAGE LENGTH
PBT25	AIS	R6,4			:ADVANCE OUR PTR
	CLHI	R6,PBTLEN		:END OF TRACE TABLE ??
	JLFS	PBT30			:IF NOT
	LIS	R6,0			:WRAP TO START
PBT30	STH	R6,P.PTR		:SAVE OUR UPDATED PTR
	J	PBT12			:START NEW PACKET ENTRY


PBT98	L	R0,XDRSEC		:SLOWC TIME TO QUIT
	CL	R0,SLOWC,,		:TIME YET ??
	JLFS	PBT99			:YES, END OF TRACE TIME
	SVC	DISMIS,0		:DISMISS TO DDT
	J	PBT10			:GO LOOK FOR ANOTHER PACKET
PBT99	J	DSTRT2			:RETURN TO COMMAND PROCESSOR

   IF HDLC!BSC				:FOR HDLC AND BSC :LSH 17-DEC-86
:	OUTPUT SECTOR TRACE TABLE

XOSTR	LHI	R2,NLINES-1
XOST00	LB	R1,CURSEC,R2,		:GET CURRENT POINTER
	AIS	R1,1			:POINT TO NEXT ENTRY
	CLB	R1,K.LT,R2,		:END OF TABLE FOR THIS LINE?
	JLFS	XOST01			:IF NOT
	LIS	R1,0			:POINT TO BEGINNING OF TABLE
XOST01	STB	R1,P.PTR,R2,		:INIT TRACE POINTER TO ONE AFTER CURRENT
	SIS	R2,1			:BUMP POINTER
	JGEBS	XOST00			:IF MORE TO DO

	LIS	R1,0
	STB	R1,MSGSPC,,		:INIT STORE BYTE COUNT

	JAL	R13,XDTIME		:ASK FOR DUMP TIME

   IF	.EQ.(NLINES,1)
	LHI	R14,100			:FOR SINGLE LINE, NO "LINE NUMBER?" PROMPT
   ELSE
	LIS	R14,0			:INIT LINE NUMBER
	SVC	0B,M.LINQ,,		:ASK FOR LINE NUMBER
XOST10	SVC	0A,0010			:WAIT FOR RESPONSE
	J	XOST20			:IF NO MORE CHARACTERS
	NHI	R0,7F			:STRIP PARITY
	CLHI	R0,0D			:CR?
	JEFS	XOST20			:IF SO
	OHI	R14,100			:INDICATE THAT RESPONSE NOT JUST CR
	NHI	R0,0F			:JUST GET LAST DIGIT
	SLLS	R14,4			:MOVE ACCUMULATION OVER A DIGIT
	OR	R14,R0			:INSERT NEW DIGIT
	J	XOST10			:GO BACK FOR MORE
   EI	NLINES

XOST20	LR	R14,R14			:LOOK AT LINE NUMBER
	JE	XOSM			:IF NOTHING, GO DO ALL LINES

XOSS	NHI	R14,1F			:REDUCE LINE MOD 32
	CLHI	R14,NLINES		:LINE NUMBER TOO BIG?
	JGE	DSTRT2			:IF SO, GET OUT		:LSH 30-MAR-87
	LHL	R15,SECBIA,R14,R14	:GET SECTOR BIAS
	SLLS	R15,2			:CONVERT WORD INDEX TO BYTE INDEX

XOSS10	JAL	R13,XOSLP		:GO PRINT SECTORS FOR LINE
	L	R0,XDRSEC		:SLOWC TIME TO QUIT
	CL	R0,SLOWC,,		:TIME YET ??
	JL	DSTRT2			:YES, END OF TRACE TIME :LSH 30-MAR-87
	SVC	DISMIS,0		:DISMISS TO DDT
	JBS	XOSS10			:GO LOOK FOR ANOTHER PACKET
XOSS99	J	DSTRT2			:RETURN TO COMMAND PROCESSOR

XOSM	LIS	R14,0			:INIT LINE NUMBER
XOSM10	LIS	R13,0
	STB	R13,MSGSPC,,		:INIT MESSAGE SPACE
  IF	NLINES-1						:DRE 10-DEC-84
	LA	R9,M.LINE,,		:POINT TO LINE MESSAGE
	JAL	R12,MSGMOV		:MOVE TO STORE
	LIS	R1,2			:SET FIELD WIDTH TO 2
	LR	R5,R14			:GET LINE NUMBER
	JAL	R11,NUMMOV		:MOVE TO STORE
	LA	R9,M.CRLF,,		:POINT TO CRLF :LSH 17-DEC-86
	JAL	R12,MSGMOV		:MOVE TO STORE
  EI								:DRE 10-DEC-84
	LHL	R15,SECBIA,R14,R14,	:GET SECTOR BIAS
	SLLS	R15,2			:CONVERT WORD INDEX TO BYTE INDEX
	JAL	R13,XOSLP		:GO PRINT SECTOR
	AIS	R14,1			:BUMP LINE NUMBER
	CLHI	R14,NLINES		:LINE NUMBER TOO BIG?
	JL	XOSM10			:GO ON

XOSM98	L	R0,XDRSEC		:SLOWC TIME TO QUIT
	CL	R0,SLOWC,,		:TIME YET ??
	JLFS	XOSM99			:YES, END OF TRACE TIME
	SVC	DISMIS,0		:DISMISS TO DDT
	J	XOSM			:GO LOOK FOR ANOTHER PACKET
XOSM99	J	DSTRT2			:RETURN TO COMMAND PROCESSOR
    EI	:HDLC!BSC					:LSH 17-DEC-86

    IF	HDLC				:HDLC ONLY	:LSH 17-DEC-86
:	SUBROUTINE TO GET ALL SECTORS AND PRINT IT FOR A HDLC LINE
:	R13 = LINK REGISTER
:	R14 = LINE NUMBER
:	R15 = SECTOR BIAS

XOSLP	HS
XOSL10	LB	R6,P.PTR,R14,		:OUR TRACE PTR
XOSL30	CLB	R6,CURSEC,R14,		:SAME AS INTERFACE ??
	JE	XOSL98			:IF PACKET BUFFER TRACE CAUGHT UP
	LR	R7,R6			:GET POINTER
	SLLS	R7,2			:CONVERT WORD INDEX TO BYTE INDEX
	L	R2,SECADR,R7,R15	:GET ADDRESS OF BUFFER
	LHL	R7,,R2			:GET BYTE COUNT FROM BUFFER
	JE	XOSL70			:IF NOTHING IN BUFFER
	AIS	R7,2			:ACCOUNT FOR HEADER
	CLHI	R7,42			:TRUNCATE IF > 66 BYTES :LSH 30-MAR-87
	JLE	XOSL31			:<= 66, GO AHEAD.	:LSH 30-MAR-87
	LHI	R7,42			:OTHERWISE SET IT TO 66 :LSH 30-MAR-87
XOSL31	LIS	R8,0			:INIT BYTE POSITION POINTER
XOSL40	LIS	R1,2			:INIT FIELD WIDTH FOR NUMBER CONVERSION
	LB	R5,,R2,R8		:GET BYTE OF BUFFER
	JAL	R11,NUMMOV,,		:CONVERT AND PRINT
	AIS	R8,1			:INCREMENT BYTE POSITION POINTER
	LR	R3,R8			:SEE IF NEED CR
	NHI	R3,0F
	JNFS	XOSL50			:IF NOT
	CLHI	R7,1			:LAST BYTE?
	JEFS	XOSL50			:IF SO
	LA	R9,M.CRLF,,		:POINT TO CRLF
	JAL	R12,MSGMOV		:MOVE TO STORE
	LA	R9,M.4SPC,,		:PRINT 4 SPACES		:LSH 17-DEC-86
	JAL	R12,MSGMOV		:			:LSH 17-DEC-86
XOSL50	NHI	R3,1			:ODD BYTE?
	JNFS	XOSL60			:IF NOT
	LHI	R5,0A0			:GET SPACE CHARACTER
	JAL	R11,BYTMOV		:MOVE TO STORE
XOSL60	SIS	R7,1			:DECREMENT ENTRY LENGTH COUNT
	JN	XOSL40			:CONTINUE
	LA	R9,M.CRLF,,		:END WITH CRLF
	JAL	R12,MSGMOV		:MOVE TO STORE
	SVC	0B,MSGSPC,,		:PRINT INTERPRETATION
	STB	R7,MSGSPC,,		:RESET MESSAGE LENGTH
XOSL70	AIS	R6,1			:ADVANCE OUR PTR
	CLB	R6,K.LT,R14,		:END OF TRACE TABLE ??
	JLFS	XOSL80			:IF NOT
	LIS	R6,0			:WRAP TO START
XOSL80	STB	R6,P.PTR,R14,		:SAVE OUR UPDATED PTR
 	J	XOSL30			:START NEW PACKET ENTRY

XOSL98	JR	R13			:RETURN

   EI HDLC

    IF	BSC				:BSC ONLY	:LSH 17-DEC-86
:	SUBROUTINE TO GET ALL SECTORS AND PRINT IT FOR A BSC LINE
:	THIS IS A NEW ROUTINE FOR BSC LINK ONLY, WRITTEN BY LOUISA HSU
:	R13 = LINK REGISTER
:	R14 = LINE NUMBER
:	R15 = SECTOR BIAS
:    The following is the description of how the new implemented 
:    'OS' command will display output sectors for BSC links.

:      A. Will translate every character in output sector, including
:         SYN, DLE, STX, and ETX, by character inversion table
:         TCHINV and display it.

:      B. A '??' will be displayed in the end of the line when
:         'DLE STX' can not be found in the first 15 characters.

:      C. After 'DLE STX' has been found, in the text portion,
:         any non_DLE or non_ETX character following DLE will be
:         treated as garbage.  In this case, a '??' will be displayed.

:      D. In the text portion, only one DLE will be displayed
:         when two contiguous DLE's are found.

:      E. Will scan each output sector and translate, display it
:         until 'DLE ETX' is found or 64 bytes of text has
:	  been displayed after 'DLE STX'.

:      F. For instance, a 'call request' packet will be displayed
:         as '1616 1616 1002 0342 1001 0BAA ...... 1003'.

XOSLP	HS
	ST	R13,XOSLNK,,		:SAVE LINK REGISTER :LSH 17-DEC-86
XOSL10	LB	R6,P.PTR,R14,		:OUR TRACE PTR
:	MAIN LOOP FOR EACH SECTOR
XOSL30	CLB	R6,CURSEC,R14,		:IF SECTOR TRACE POINTER CAUGHT UP
	JE	XOSL98			:HAVE SCANNED ALL THE SECTORS,RETURN
	LR	R7,R6			:GET POINTER
	SLLS	R7,2			:CONVERT WORD INDEX TO BYTE INDEX
	L	R2,SECADR,R7,R15	:GET ADDRESS OF SECTOR
	LIS	R7,0F			:SET COUNTER. IF DLE STX CAN'T BE FOUND
					:IN FIRST 15 BYTES, ASSUME EMPTY.
	LIS	R8,0			:INIT BYTE POINTER IN SECTOR
	LIS	R13,0			:# OF BYTE HAS DISPLAYED IN A LINE
:	SCAN DLE
XOSL35	LB	R5,,R2,R8		:GET CHAR FROM SECTOR
	LB	R5,TCHINV,R5,		:NEED BIT INVERSE BEFORE DISPLAY
	LR	R6,R5			:SAVE R5 IN R6, NUMMOV DESTROY R5
	LIS	R1,2			:INIT FIELD WIDTH FOR CONVERSION
	JAL	R11,NUMMOV,,		:CONVERT AND PRINT
	AIS	R13,1			:INCREMENT LINE COUNTER
	LR	R3,R13
	NHI	R3,1			:ODD BYTE ?
	JNFS	XOSL36			:IF NOT
	LHI	R5,0A0
	JAL	R11,BYTMOV
XOSL36	AIS	R8,1			:INCREMENT POINTER IN SECTOR
	SIS	R7,1			:DECREMENT COUNTER (MAX. DISPLAY)
	JE	XOSL99			:HAVE REACHED COUNTER, GO NEXT SECTOR
	CLHI	R6,10			:CHECK FOR DLE 
	JN	XOSL35			:IF NOT DLE, REPEAT SCAN
:	DLE FOUND, GO CHECK IF NEXT CHAR IS STX	
	LB	R5,,R2,R8		:GET CHAR FROM SECTOR
	LB	R5,TCHINV,R5,		:NEED BIT INVERSE BEFORE DISPLAY
	LR	R6,R5			:SAVE R5 IN R6, NUMMOV DESTROY R5
	LIS	R1,2			:INIT FIELD WIDTH FOR CONVERSION
	JAL	R11,NUMMOV,,		:CONVERT AND PRINT
	AIS	R13,1			:INCREMENT LINE COUNTER
	LR	R3,R13
	NHI	R3,1			:ODD BYTE ?
	JNFS	XOSL37			:IF NOT
	LHI	R5,0A0
	JAL	R11,BYTMOV
XOSL37	AIS	R8,1			:INCREMENT POINTER IN SECTOR
	SIS	R7,1			:DECREMENT COUNTER (MAX. DISPLAY)
	JE	XOSL99			:HAVE REACHED COUNTER, GO NEXT SECTOR
	CLHI	R6,02			:CHECK FOR STX 
	JN	XOSL35			:IF NOT DLE STX, CONTINUE SCANNING

:	DLE STX FOUND, START TO SCAN TEXT
	LHI	R7,40			:TRUNCATE IF > 64	:LSH 30-MAR-87
XOSL40	LB	R5,,R2,R8		:GET BYTE FROM SECTOR
	LB	R5,TCHINV,R5,		:NEED BIT INVERSE BEFORE DISPLAY
	AIS	R8,1			:INCREMENT BYTE POSITION POINTER
	CLHI	R5,10			:CHECK FOR DLE 
	JN	XOSL45			:IF NOT DLE, GO TO DISPLAY IT
					:IF DLE, CHECK NET BYTE
	LB	R5,,R2,R8		:GET BYTE FROM SECTOR
	LB	R5,TCHINV,R5,		:NEED BIT INVERSE BEFORE DISPLAY
	AIS	R8,1			:INCREMENT BYTE POSITION POINTER
	CLHI	R5,10			:CHECK FOR DLE 
	JE	XOSL45			:DLE DLE FOUND, DISPLAY ONE DLE
	CLHI	R5,03			:CHECK FOR ETX 
	JE	XOSL9A			:DLE ETX FOUND, DISPLAY IT,GO NEXT
	LA	R9,M.QUEM,,		:GARBAGE FOUND, DISPLAY A '??'	
	JAL	R12,MSGMOV,,
	J	XOSL47			:SEE IF NEED CR
:	INVERSE AND DISPLAY TEXT
XOSL45	LIS	R1,2			:INIT FIELD WIDTH FOR CONVERSION
	JAL	R11,NUMMOV,,		:CONVERT AND PRINT
XOSL47	AIS	R13,1			:INCREMENT LINE COUNTER
	LR	R3,R13			:SEE IF NEED CR
	NHI	R3,0F
	JN	XOSL50			:DON'T NEED CR, CHECK FOR ODD BYTE
	CHI	R7,1			:NEED CR. IS LAST BYTE IN THE SECTOR?
	JE	XOSL50			:THIS IS THE LAST BYTE IN THE SECTOR
:	END OF ONE DISPLAY LINE
	LA	R9,M.CRLF,,		:POINT TO CRLF
	JAL	R12,MSGMOV		:MOVE TO STORE
	LA	R9,M.4SPC,,		:PRINT 4 SPACES	
	JAL	R12,MSGMOV		:			
:	ODD BYTE ?
XOSL50	NHI	R3,1			:ODD BYTE?
	JNFS	XOSL60			:IF NOT
	LHI	R5,0A0			:GET SPACE CHARACTER
	JAL	R11,BYTMOV		:MOVE TO STORE
XOSL60	SIS	R7,1			:UPDATE AND CHECK FOR MAX. COUNTER 
	JN	XOSL40			:CONTINUE SCANNING TEXT

:	END OF THE SECTOR. (EITHER DLE ETX FOUND, OR MAX. COUNTER REACHED)
XOSL61	LA	R9,M.CRLF,,		:DISPLAY CRLF
	JAL	R12,MSGMOV		:
	SVC	0B,MSGSPC,,		:REALLY PRINT MESSAGES
	LIS	R3,0
	STB	R3,MSGSPC,,		:RESET MESSAGE LENGTH

:	PREPARE TO SCAN NEXT SECTOR
XOSL70	LB	R6,P.PTR,R14,		:RESTORE TRACE POINTER INTO R6
	AIS	R6,1			:ADVANCE OUR PTR
	CLB	R6,K.LT,R14,		:END OF TRACE TABLE ??
	JLFS	XOSL80			:IF NOT
	LIS	R6,0			:WRAP TO START
XOSL80	STB	R6,P.PTR,R14,
	J	XOSL30			:START NEW SECTOR

:	RETURN
XOSL98	L	R13,XOSLNK,,		:RESTORE LINK REGISTER
	JR	R13			:RETURN

:	DLE STX CAN'T BE FOUND IN FIRST 15 CHARS.  DISPLAY '??',
:	AND START TO SCAN THE NEXT SECTOR.
XOSL99	LA	R9,M.QUEM,,		:DISPLAY QUESTION MARK '??'
	JAL	R12,MSGMOV
	J	XOSL61			:DISPLAY CRLF, AND SCAN NEXT ONE

:	DLE ETX FOUND, DISPLAY IT AND START TO SCAN THE NEXT SECTOR.
XOSL9A	LA	R9,M.DLET,,		:DISPLAY DLE ETX
	JAL	R12,MSGMOV
	J	XOSL61			:DISPLAY CRLF, AND SCAN NEXT ONE

   EI BSC	:BSC ONLY 					:LSH 17-DEC-86



  IF	DDTDIA-1
::	AVERAG - PERFORM AVERAGING 
:
AVERAG	LIS	R0,0
	STH	R0,DIAFLG		:FIRST TURN OFF

:	INITIALIZE CELL BLOCKS

	AVEINI(EXTIME)			:EXECUTION TIME PER BACKGROUND LOOP
	AVEINI(BGRETI)			:BACKGROUND REAL TIME
	AVEINI(BGWAIT)			:BACKGROUND CYCLE TIME
	AVEINI(IRNGCH)			:# CHARACTERS IN IRING AT BG START
	AVEINI(ORNGCH)			:# CHARACTERS IN ORING AT BG END
	AVEINI(YBOB)			:YB-OB NETWORK DELAY

:	INITIALIZE SINGLE CELL COUNTERS

	LIS	R0,0
	STH	R0,CNTUNB,,		:# TIMES DID NOT USE BUFFERLETS (SLOR)
	STH	R0,CNTBUF,,		:# TIMES DID BUFFER OUTPUT (SLOR)
	STH	R0,BKP2NT,,		:# TIMES APPLIED BACK PRESSURE TO NET
	STH	R0,BKP2LK,,		:# TIMES APPLIED BACK PRESSURE TO LINK
	ST	R0,LSTYB,,		:CLEAR LAST YB SENT TIME FASTC
	ST	R0,LSTYB2,,		:AND SLOWC
:	ST	R0,GCIWCI,,		:GCI - WCI COUNTER
	ST	R0,PKTTOT,,		:TOTAL PACKET COUNTER
	ST	R0,CHRTOT,,		:TOTAL DATA CHARACTER COUNTER
	L	R0,FASTC,,
	ST	R0,LBGCLK,,		:INITIALIZE LAST BACKGROUNG TIME PROPERLY
	LH	R1,SLOTNO,,		:FIND OUT OUR SLOT NUMBER
	SLLS	R1,2			:CONVERT TO FULL WORD INDEX
	AH	R1,LCX,,		:ADD OFFSET INTO CLOCK TABLE
	LH	R0,NRATE,R1,		:GET LOCAL CLOCK FOR OUR SLOT
	AH	R0,NRATE+2,R1,		:ADD LOCAL SYSTEM CLOCK FOR OUR SLOT
	STH	R0,LBGCL2,,		:SAVE CURRENT VALUE

	LIS	R0,1
	STH	R0,DIAFLG		:START GATHERING STATISTICS
	SVC	0B,M.20,,		:HEADER OF AVERAGE PER INSTANCE, HWM, LWM
	SVC	0B,M.21,,		:HEADER OF AVERAGE PER SECOND
	SVC	DISMIS,$A60		:DISMISS A BIT
	LIS	R0,0			:FIRST TURN OFF BLOCKS
	STH	R0,DIAFLG
	STB	R0,MSGSPC,,		:CLEAR MESSAGE BUFFER

:	OUTPUT AVERAGING BLOCK STATISTICS

	AVE(EXTIME)			:EXECUTION TIME
	AVE(BGRETI)			:BACKGROUND REAL TIME
	AVE(BGWAIT)			:BACKGROUND CYCLE TIME
	AVE(IRNGCH)			:# CHARACTERS IN IRING AT BG START
	AVE(ORNGCH)			:# CHARACTERS IN ORING AT BG END
	AVE(YBOB)			:YB-OB NETWORK RESPONSE TIME

:	OUTPUT SINGLE CELL COUNTERS

	LIS	R0,0
	STH	R0,X.PORT		:SET INDEX TO ZERO
	STB	R0,MSGSPC,,		:RESET BUFFER LENGTH
	SVC	0B,M.CRLF,,		:START A NEW LINE
	SVC	0B,M.CRLF,,

	V.VAL(CNTUNB,4)			:# TIMES DID NOT BUFFER OUTPUT
	V.VAL(CNTBUF,4)			:# TIMES DID BUFFER OUTPUT
	V.VAL(BKP2NT,4)			:# TIMES BACKPRESSURED NETWORK
	V.VAL(BKP2LK,4)			:# TIMES BACKPRESSURED LINK
:	V.VAL(GCIWCI,8)			:# TIMES GCI OR WCI CALLED
	V.VAL(PKTTOT,8)			:TOTAL PACKETS TRANSFERED
	V.VAL(CHRTOT,8)			:TOTAL DATA CHARACTERS TRANSFERED

	LB	R0,MSGSPC,,		:SEE IF BUFFER LEFT EMPTY
	JE	DSTRT2			:IF SO
	SVC	0B,MSGSPC,,		:ELSE PRINT REMAINDER OF IT
	LIS	R0,0
	STB	R0,MSGSPC,,		:AND CLEAR IT
	J	DSTRT2			:RETURN TO COMMAND HANDLER


::	AVEPUT - PUT OUT THE CURRENT STATS ON AN AVERAGED VARIABLE
:
AVEPUT	ST	R0,AV.TMP,,		:SAVE RETURN
	LR	R6,R1			:MOVE BLOCK POINTER
	LA	R9,M.CRLF,,		:NEW LINE
	JAL	R12,MSGMOV,,
	LA	R9,LBL,R6,		:LABEL
	JAL	R12,MSGMOV,,
	LA	R9,M.CL,,		:COLON
	JAL	R12,MSGMOV,,

:	AVERAGE PER INSTANCE
	LIS	R1,8
	L	R5,ACC,R6,		:ACCUMULATOR
	JAL	R11,NUMMOV,,
	LA	R9,M.SL,,		:SLASH
	JAL	R12,MSGMOV,,
	LIS	R1,4
	LHL	R5,CNT,R6,		:SAMPLE COUNT
	JAL	R11,NUMMOV,,
	LA	R9,M.EQ,,		:EQUAL
	JAL	R12,MSGMOV,,
	LIS	R1,0
	L	R2,ACC,R6,		:DIVIDEND
	JE	AVEPU1			:SKIP DIVIDE SO 0/0 = 0
	LHL	R3,CNT,R6,		:LOAD DIVISOR
	DR	R1,R3			:ACC/CNT-->(R2)
AVEPU1	LIS	R1,8
	LR	R5,R2
	JAL	R11,NUMMOV,,
	LA	R9,M.LB,,		:[
	JAL	R12,MSGMOV,,
	LIS	R1,8
	L	R5,HWM,R6,		:HWM
	JAL	R11,NUMMOV,,
	LA	R9,M.CO,,		:COMMA
	JAL	R12,MSGMOV,,
	LIS	R1,8
	L	R5,LWM,R6,		:LWM
	JAL	R11,NUMMOV,,
	LA	R9,M.RB,,		:]
	JAL	R12,MSGMOV,,

:	AVERAGE PER SECOND
	LIS	R1,0
	L	R2,ACC,R6		:DIVIDEND
	LHI	R3,$A60			:LOAD DIVISOR
	DR	R1,R3			:ACC/60-->(R2)
	LIS	R1,8
	LR	R5,R2
	JAL	R11,NUMMOV,,

	SVC	0B,MSGSPC,,		:PUT OUT LINE JUST CONSTRUCTED
	LIS	R0,0
	STB	R0,MSGSPC,,		:RESET LINE LENGTH
	L	R1,AV.TMP,,		:RELOAD RETURN ADDRESS
	JR	R1			:DONE SO RETURN


::	AVEINT - INITIALIZE AN AVERAGING BLOCK
:
AVEINT	LIS	R0,0
	ST	R0,ACC,R1,		:CLEAR OUT ACCUMULATOR
	ST	R0,HWM,R1,		:CLEAR HIGH WATER MARK
	STH	R0,CNT,R1,		:CLEAR COUNTER OF SAMPLES
	LI	R0,7FFFFFFF		:CLEAR LOW WATER MARK
	ST	R0,LWM,R1,
	JR	R2			:RETURN


::	V.PRNT - VARIABLE PRINT ROUTINE
:
:	(R1)=SIZE (1=BIT, 2=BYTE, 4=HALFWORD, 8=FULLWORD)
:	(R2)=VARIABLE ADDRESS
:	(R6)=RETURN ADDRESS
:	(R9)=MSG ADDRESS
:	(R11)=DPORT,IPORT, ETC (SUBSCRIPT INDEX)
:
V.PRNT	JAL	R12,MSGMOV,,		:MOVE MESSAGE INTO BUFFER
	CLHI	R1,8			:LOOKING FOR FULLWORD?
	JNFS	V.PRN1			:IF NOT
	SLLS	R11,2			:GET FULLWORD ADDRESS-ABILITY
	L	R5,,R2,R11		:GET VALUE
	J	V.PRN4

V.PRN1	CLHI	R1,4			:LOOKING FOR HALF-WORD?
	JNFS	V.PRN2			:IF NOT
	SLLS	R11,1
	LHL	R5,,R2,R11		:GET VALUE
	J	V.PRN4

V.PRN2	CLHI	R1,2			:LOOKING FOR A BYTE VALUE?
	JNFS	V.PRN3			:IF NOT
	LB	R5,,R2,R11		:GET VALUE
	JFS	V.PRN4

V.PRN3	LIS	R5,0			:ASSUME RESET
	TBT	R11,,R2			:TEST BIT VALUE
	JEFS	V.PRN4			:IF RESET
	LIS	R5,1			:GET A 1 FOR SET
V.PRN4	JAL	R11,NUMMOV,,		:MOVE VALUE TO BUFFER
	LA	R9,XDRMS5,,		:INSERT SOME BLANKS
	JAL	R12,MSGMOV,,		:FOR READIBILITY
	LB	R3,MSGSPC,,		:CURRENT BUFFER LENGTH
	CLHI	R3,$A50			:TIME TO PRINT LINE ??
	JLER	R6			:RETURN IF NOT
	SVC	0B,MSGSPC,,		:PRINT WHAT WE HAVE
	SVC	0B,M.CRLF,,		:START ANOTHER LINE
	LIS	R3,0			:RESET LINE LENGTH
	STB	R3,MSGSPC,,		:CLEAR OUT BUFFER
	LA	R9,XDRMS5,,		:INDENT
	JAL	R12,MSGMOV,,		:4 SPACES
	JR	R6			:NOW RETURN

::	DPRT - PRINT DISPATCHER VARIABLES
:
DPRT	LHI	R1,NDPORT
	STH	R1,X.PORT
DPRT1	LHL	R5,X.PORT
	SIS	R5,1
	JE	DPRT2			:DONE ALL DPORTS
	STH	R5,X.PORT
	LH	R1,DI.MT,R5,R5		:SEE IF PORT IN USE
	JLEBS	DPRT1			:IF NOT
	LIS	R1,3			:FIELD WIDTH
	JAL	R11,NUMMOV,,		:PUT OUT PORT #
	LA	R9,XDRMS5,,		:4 BLANKS
	JAL	R12,MSGMOV,,		:FOLLOWING PORT #

	V.VAL(DI.MT,4)			:INTERNAL PORT #
	V.VAL(POCNT,8)			:OUTPUT PACKET COUNT
	V.VAL(PICNT,8)			:INPUT PACKET COUNT
	V.VAL(CICNT,8)			:INPUT DATA CHAR COUNT
	V.VAL(COCNT,8)			:OUTPUT DATA CHAR COUNT
	V.VAL(TURLEV,2)			:TURKEY LEVEL
	V.VAL(XMTMSK,2)			:TRANSMIT MASK HOLD CELL
	V.VAL(BRKMSK,2)			:BREAK HANDLING PARAMETER
	V.VAL(ORGTID,2)			:TID
	V.VAL(DESHST,4)			:DESTINATION HOST NUMBER
	V.VAL(ORGNOD,4)			:ORIGINATING NODE NUMBER
	V.VAL(ORGHST,4)			:ORIGINATING HOST NUMBER
	V.VAL(ORGPRT,4)			:ORIGINATING PORTNUMBER
	V.VAL(IDLCNT,2)			:INITIAL FORWARDING TIMER
	V.VAL(NUN.F,1)			:NUMERIC USERNAME IN NEEDLE
	V.VAL(IIXCAL,1)			:REACHED BY IIX INTERFACE
	V.VAL(TGATE,1)			:GOING TO T-T GATEWAY
	V.VAL(ITP.4,1)			:INITIAL CR DELAY
	V.VAL(ITP.12,1)			:INITIAL X-ENABLE
	V.VAL(ITP.14,1)			:INITIAL REVERSE X-ENABLE
	V.VAL(PAR0,1)			:CURRENT TPAD ECHO
	V.VAL(PAR1,1)			:CURRENT ECHO ^I
	V.VAL(PAR2,1)			:INSERT CR AFTER LF
	V.VAL(PAR3,1)			:INSERT LF AFTER CR
	V.VAL(PAR4,1)			:CR DELAY FLAG
	V.VAL(PAR12,1)			:CURRENT X-ENABLE FLAG
	V.VAL(PAR13,1)			:CURRENT ECHO ^I
	V.VAL(PAR14,1)			:CURRENT REVERSE-X ENABLE
	V.VAL(DFLUSH,1)			:DISPATCHER IN FLUSH MODE
	V.VAL(IDBP.F,1)			:DISPATCHER BACKPRESSURED US
	V.VAL(DBKPR,1)			:DISPATCHER BACKPRESSURE SET
	V.VAL(DEM,1)			:DEFERRED ECHO MODE
	V.VAL(EXTWDR,1)			:WAITING DIALECT RESPONSE
	V.VAL(IBM27,1)			:TALKING TO 2741
	V.VAL(NDATIM,1)			:DATA TIMER DISABLED
  IF	DNICND
	V.VAL(SAVDNC,4)			:SAVED DNIC VALUE TO USE
  EI	DNICND
	V.VAL(TMTLIM,2)			:TRANSMIT LIMIT IN # OF CHARACTERS
	V.VAL(CSREQ,1)			:SET IF CAN SEND LOGIN DATA TO SUP

	LB	R0,MSGSPC,,		:SEE IF BUFFER LEFT EMPTY
	JE	DPRT1			:IF SO
	SVC	0B,MSGSPC,,		:ELSE PRINT IT
	LIS	R0,0
	STB	R0,MSGSPC,,
	LA	R9,M.CRLF,,		:START AT NEW LINE
	JAL	R12,MSGMOV,,
	J	DPRT1			:GO TO NEXT PORT

DPRT2	LB	R0,MSGSPC,,		:SEE IF BUFFER LEFT EMPTY
	JE	DSTRT2			:IF SO, RETURN TO COMMAND HANDLER
	SVC	0B,MSGSPC,,		:ELSE PRINT IT
	LIS	R0,0
	STB	R0,MSGSPC,,
	J	DSTRT2			:RETURN TO COMMAND HANDLER

::	IPRT - PRINT IPORT VARIABLES
:
IPRT	LHI	R1,NIPORT
	STH	R1,X.PORT
IPRT1	LHL	R5,X.PORT
	SIS	R5,1
	STH	R5,X.PORT
	CLHI	R5,NLINKS		:DO ONLY DOWN TO ASSIGNABLE CHANNELS
	JL	DSTRT2			:DONE, REST ARE FOR LINK CONTROL
	LH	R1,ID.MT,R5,R5		:SEE IF PORT IN USE
	JLEBS	IPRT1			:IF NOT
	LIS	R1,3			:FIELD WIDTH
	JAL	R11,NUMMOV,,		:PUT OUT PORT #
	LA	R9,XDRMS5,,		:4 BLANKS
	JAL	R12,MSGMOV,,		:FOLLOWING PORT #

	V.VAL(ID.MT,4)			:DISPATCHER PORT #	:DRE 4-MAR-86
	V.VAL(IL.MT,2)			:LINK #			:DRE 4-MAR-86
	V.VAL(IE.MT,4)			:EPORT ASSIGNED		:DRE 4-MAR-86
	V.VAL(PCKSTE,2)			:LOGICAL CHANNEL STATE
	V.VAL(TCLTR,2)			:THROUGHPUT CLASSES	:DRE 4-MAR-86
	V.VAL(PWTMT,2)			:TRANSMIT WINDOW SIZE	:DRE 4-MAR-86
	V.VAL(PWRCV,2)			:RECEIVE WINDOW SIZE	:DRE 4-MAR-86
	V.VAL(PPS,2)			:NEXT P(S) TO SEND
	V.VAL(LRPR,2)			:LAST RECEIVED P(R)
	V.VAL(PPR,2)			:NEXT P(R) TO SEND
	V.VAL(TPPR,2)			:NEXT POSSIBLE P(R) TO SEND
	V.VAL(LTPR,2)			:LAST TRANSMITTED P(R)
	V.VAL(PSDIAG,4)			:CAUSE AND DIAGNOSTIC BYTES
	V.VAL(IBKPR,1)			:SET IF WE RECEIVED AN RNR ON CHANNEL
	V.VAL(OBKPR,1)			:SET IF WE SENT RNR TO OTHER SIDE
	V.VAL(XBKPR,1)			:SET IF BACKPRESSURING WITH XOFF
	V.VAL(EXTCAL,1)			:SET IF CALL ORIGINATED EXTERNALLY
	V.VAL(ITICAL,1)			:SET IF EXTERNAL CALLER WAS A PAD
	V.VAL(DBKHI,4)			:HI COUNT TO APPLY BACKPRESSURE
	V.VAL(DBKLO,4)			:LOW COUNT TO RELEASE BACKPRESSURE
	V.VAL(GATWAY,1)			:SET IF CALL TO X.75 GATEWAY
	V.VAL(CUDUSD,1)			:SET IF CUD USED IN LOGIN
	V.VAL(NTNCAL,1)			:SET IF LOGIN IS NTN
	V.VAL(NUNCAL,1)			:SET IF NATIONAL USER NUMBER
	V.VAL(CUN,1)			:SET IF CONSTRUCTED USERNAME

	LB	R0,MSGSPC,,		:SEE IF BUFFER LEFT EMPTY
	JE	IPRT1			:IF SO
	SVC	0B,MSGSPC,,		:ELSE PRINT IT
	LIS	R0,0
	STB	R0,MSGSPC,,
	LA	R9,M.CRLF,,		:START AT NEW LINE
	JAL	R12,MSGMOV,,
	J	IPRT1			:GO TO NEXT PORT

IPRT2	LB	R0,MSGSPC,,		:SEE IF BUFFER LEFT EMPTY
	JE	DSTRT2			:IF SO, RETURN TO COMMAND HANDLER
	SVC	0B,MSGSPC,,		:ELSE PRINT IT
	LIS	R0,0
	STB	R0,MSGSPC,,
	J	DSTRT2			:RETURN TO COMMAND HANDLER


ILINK	LHI	R1,NLINKS		:STEP THROUGH ALL LINKS
	STH	R1,X.PORT
ILNK1	LHL	R5,X.PORT		:STEP TO NEXT LINK #
	SIS	R5,1
	JL	DSTRT2			:DONE, RETURN TO COMMAND HANDLER
	STH	R5,X.PORT		:SAVE TO PRINT
	LIS	R1,3			:FIELD WIDTH
	JAL	R11,NUMMOV,,		:PUT OUT LINK #
	LA	R9,XDRMS5,,		:4 BLANKS
	JAL	R12,MSGMOV,,		:FOLLOWING LINK #

	V.VAL(PCNTLK,8)			:TOTAL PACKETS OVER LINK
	V.VAL(CCNTLK,8)			:TOTAL DATA CHAR OVER LINK
	V.VAL(RSC.FG,4)			:FG RSC CHAIN START
	V.VAL(RSC.FE,4)			:FG RSC CHAIN END
	V.VAL(RSC.FD,4)			:FG RSC CHAIN DANGLING PTR
	V.VAL(RSC.RT,4)			:BG RSC CHAIN START
	V.VAL(RSC.RE,4)			:BG RSC CHAIN END
	V.VAL(RSC.RA,4)			:BG RSC CHAIN ADVANCING PTR
	V.VAL(XTNR,2)			:LAST TRANSMITTED N(R) VALUE
	V.VAL(XVR,2)			:V(R) SAVE CELL
	V.VAL(XVS,2)			:V(S) SAVE CELL
	V.VAL(RTVS,2)			:V(S) OF RETRANSMITTED FRAME
	V.VAL(LVACK,2)			:LAST FRAME ACKED
	V.VAL(LSACK,2)			:LAST SECTOR ACKED
	V.VAL(NXTSEC,2)			:NEXT SECTOR TO SEND
	V.VAL(XROOMC,4)			:ACTIVE TCCL COMMANDS
	V.VAL(RTDER3,4)			:RECEIVED PACKET ON ILLEGAL CHANNEL
	V.VAL(RTDDSC,4)			:ILLEGAL PACKET
	V.VAL(LERR1,4)			:BAD Q PACKET

	LB	R0,MSGSPC,,		:SEE IF BUFFER LEFT EMPTY
	JE	ILNK1			:IF SO
	SVC	0B,MSGSPC,,		:ELSE PRINT IT
	LIS	R0,0
	STB	R0,MSGSPC,,
	LA	R9,M.CRLF,,		:START AT NEW LINE
	JAL	R12,MSGMOV,,
	J	ILNK1			:GO TO NEXT LINK

ILNK2	LB	R0,MSGSPC,,		:SEE IF BUFFER LEFT EMPTY
	JE	DSTRT2			:IF SO, RETURN TO COMMAND HANDLER
	SVC	0B,MSGSPC,,		:ELSE PRINT IT
	LIS	R0,0
	STB	R0,MSGSPC,,
	J	DSTRT2			:RETURN TO COMMAND HANDLER

ILINE	LHI	R1,NLINES		:STEP THROUGH ALL LINES
	STH	R1,X.PORT
ILIN1	LHL	R5,X.PORT		:STEP TO NEXT LINE #
	SIS	R5,1
	JL	DSTRT2			:DONE, RETURN TO COMMAND HANDLER
	STH	R5,X.PORT		:SAVE TO PRINT
	LIS	R1,3			:FIELD WIDTH
	JAL	R11,NUMMOV,,		:PUT OUT LINE #
	LA	R9,XDRMS5,,		:4 BLANKS
	JAL	R12,MSGMOV,,		:FOLLOWING LINE #

	V.VAL(XRETER,4)			:RETRANSMISSION COUNT
	V.VAL(ABTCNT,4)			:ABORT COUNT
	V.VAL(SM.C,4)			:RETRANSMISSION SEND WITH P=1
	V.VAL(SM.D,4)			:RECEIVED RETRANSMISSIONS
	V.VAL(SM.E3,4)			:BAD N(S) OR N(R)
	V.VAL(SIOER2,4)			:SIO OVERRUN HALT
	V.VAL(RERR1,4)			:FRAME TOO SHORT
	V.VAL(CMDSNT,4)			:FRMR/CMDR SENT
	V.VAL(REJRCV,4)			:REJECTS RECEIVED
	V.VAL(EMPTYI,4)			:RECEIVED EMPTY I FRAME
	V.VAL(ILERR3,4)			:TRIED TO RETRANSMIT SECTOR NOT OUT
	V.VAL(ILERR4,4)			:TRIED TO OUTPUT FRAME NO OUT
	V.VAL(NOROOM,4)			:NO ROOM IN TRANSMIT COMMAND LIST

	LB	R0,MSGSPC,,		:SEE IF BUFFER LEFT EMPTY
	JE	ILIN1			:IF SO
	SVC	0B,MSGSPC,,		:ELSE PRINT IT
	LIS	R0,0
	STB	R0,MSGSPC,,
	LA	R9,M.CRLF,,		:START AT NEW LINE
	JAL	R12,MSGMOV,,
	J	ILIN1			:GO TO NEXT LINE

ILIN2	LB	R0,MSGSPC,,		:SEE IF BUFFER LEFT EMPTY
	JE	DSTRT2			:IF SO, RETURN TO COMMAND HANDLER
	SVC	0B,MSGSPC,,		:ELSE PRINT IT
	LIS	R0,0
	STB	R0,MSGSPC,,
	J	DSTRT2			:RETURN TO COMMAND HANDLER

::	ERRRPT - REPORT ON ALL GLOBAL ERROR COUNTERS
ERRRPT	LIS	R0,0
	STH	R0,X.PORT		:SET INDEX TO ZERO
	STB	R0,MSGSPC,,		:RESET BUFFER LENGTH
	SVC	0B,M.CRLF,,		:START A NEW LINE
	SVC	0B,M.CRLF,,

	V.VAL(NOBUFF,4)			:# TIMES RTD DISMISSED DUE TO BUFFER LIMITS
	V.VAL(T2ERR,4)			:# JUMP CONFLICTS IN ROTOR
	V.VAL(LOGOUT,4)			:# TIMES LOGIN TIMED OUT
	V.VAL(BLKRCV,4)			:# TIMES BLACK BALL RECEIVED


	LB	R0,MSGSPC,,		:SEE IF BUFFER LEFT EMPTY
	JE	DSTRT2			:IF SO
	SVC	0B,MSGSPC,,		:ELSE PRINT REMAINDER OF IT
	LIS	R0,0
	STB	R0,MSGSPC,,		:AND CLEAR IT
	J	DSTRT2			:RETURN TO COMMAND HANDLER


 IF	DDTDIA-2			:GENERATE PERFORMANCE STUFF ON COMMAND ONLY

::	TCAN - TRASH CAN DATA FROM THE X LINK
TCAN	SVC	0B,M.30,,		:PROMPT FOR 0 OR 1
	LIS	R4,2			:RADIX
	JAL	R5,DS.NUM,,		:READ A NUMBER
	STB	R0,TCANFL		:SET A FLAG
	J	DSTRT2			:RETURN TO COMMAND HANDLER


:	PROMPT FOR I PORT SUBROUTINE
:	R6=LINK
GPSUB1	SVC	0B,M.40,,		:PROMPT FOR I PORT
	LHI	R4,10			:RADIX
	JAL	R5,DS.NUM,,		:READ PORT FROM USER
	STH	R0,GPORT,,		:SAVE IT
	LR	R10,R0
	SLLS	R10,1			:DOUBLE IPORT
	CLHI	R0,NIPORT		:RANGE CHECK IT
	JLER	R6			:IF WITHIN RANGE, RETURN
	SVC	0B,M.54,,		:ELSE APPROPRIATE NASTY MESSAGE
	J	DSTRT2			:AND BACK TO COMMAND HANDLER

::	GPSUB2 - CONTROL GROUP HANDLER
:	R10 = IPORT*2
:	R11 = RETURN
GPSUB2	ST	R11,GPRETN,,		:SAVE RETURN
	L	R9,GPFLAG,R10,R10	:GET FLAGS
	JE	GPSB40			:NONE SET
	LIS	R8,8			:LOOP COUNTER
GPSB20	LR	R5,R9			:COPY FLAGS
	SRLS	R9,4			:GET NEXT GROUP
	NHI	R5,0F			:MASK TO JUST THEM
	JEFS	GPSB30			:NOTHING DOING HERE
	JAL	R6,SEND			:SEND THIS BUFFER
GPSB30	SIS	R8,1			:CHECK COUNTER OF GROUPS
	JNBS	GPSB20			:IF NOT DONE YET
GPSB40	L	R11,GPRETN,,		:RELOAD RETURN
	JR	R11

::	GPKT - GENERATE PACKET CONTROL PARAMETERS
GPKT	JAL	R6,GPSUB1		:GO GET IPORT, RETURN R10=IPORT*2
	SVC	0B,M.56,,		:ECHO OLD BUFFER
	LHI	R1,1F			:BIT COUNTER
	L	R2,GPFLAG,R10,R10	:OLD FLAGS
GPKT70	LHI	R0,30			:ASCII ZERO
	TI	R2,80000000		:IS FIRST BIT 0?
	JEFS	GPKT80			:IF SO
	LHI	R0,31			:ASCII ONE
GPKT80	SVC	KIO,0E			:PRINT IT
	SLLS	R2,1			:SHIFT OLD FLAGS
	THI	R1,3			:TEST FOR SPACE CONTROL
	JNFS	GPKT90			:IF NOT YET
	LHI	R0,20			:BLANK
	SVC	KIO,0E			:PRINT IT
GPKT90	SIS	R1,1			:COUNT BITS
	JGE	GPKT70			:MORE TO DO
	SVC	0B,M.41,,		:PROMPT FOR BUFFER SEQUENCE CONTROL
	SVC	0B,M.42,,
	LIS	R4,2			:GET IN BINARY
	JAL	R5,DS.NUM,,		:GET 32 BIT CONTROL FLAGS FROM USER
	ST	R0,GPFLAG,R10,R10
	SVC	0B,M.43,,		:PROMPT FOR FREQUENCY
	LHI	R4,10			:BACK TO HEX INPUT
	JAL	R5,DS.NUM,,		:READ FROM USER
	STH	R0,GPFREQ,R10,		:SAVE IT
	J	DSTRT2			:RETURN TO COMMAND HANDLER

::	DPKT - DEFINE PACKET BUFFER CONTENTS
DPKT	SVC	0B,M.50,,		:PROMPT FOR PACKET #
	JAL	R5,DS.NUM,,		:GET FROM USER
	THI	R0,-4			:TEST FOR VALID VALUE 0-3
	JEFS	GPKT08			:IF OK
	SVC	0B,M.55,,		:ELSE SEND MESSAGE
	J	DSTRT2			:AND RETURN TO COMMAND HANDLER

GPKT08	LR	R1,R0			:MOVE PACKET BUFFER #
	SLLS	R1,3			:FOR DOUBLE WORD INDEXING
	L	R8,GBTABL,R1,		:BUFFER ADDRESS
	L	R9,GBTABL+4,R1,		:MAX BYTE COUNT INTO BUFFER

GPKT09	SVC	0B,M.51,,		:PROMPT FOR PACKET DATA
	LIS	R6,0			:INIT INDEX COUNTER
	STH	R6,,R8			:CLEAR OUT BUFFER
	LIS	R7,0			:CLEAR NIBBLE FLAG
GPKT10	JAL	R1,DS.GCH,,		:GET A CHARACTER
	J	GPKT09			:^W.. FLUSH INPUT
	J	GPKT10			:^H.. BACKSPACE
	JAL	R2,DS.DEL,,		:CHECK FOR DELIMITER
	J	GPKT10			:IF DELIMITER, JUST IGNORE IT
	JAL	R2,DS.DIG,,		:CHECK FOR DIGIT
	J	GPKT30			:IF NOT DIGIT, QUIT
	LR	R7,R7			:CHECK IF FIRST NIBBLE
	JNFS	GPKT20			:IF NOT
	LR	R7,R0			:COPY TO SAVE IT
	SLLS	R7,4			:AND POSITION AS SECOND NIBBLE
	OI	R7,80000000		:SET FLAG SO NEVER 0
	J	GPKT10			:GO FOR SECOND NIBBLE
GPKT20	OR	R7,R0			:COMBINE TWO DIGITS
	STB	R7,2,R6,R8		:PUT DIRECTLY INTO BUFFER
	AIS	R6,1			:BUMP BY ONE
	STH	R6,BPKNT,,		:SAVE CURRENT LENGTH
	LIS	R7,0			:CLEAR NIBBLE FLAG
	CLR	R6,R9
	JL	GPKT10			:IF WITHIN MAX LENGTH
	SVC	0B,M.53,,		:BUFFER OVERFLOW MSG
	J	DSTRT2			:AND ABORT

GPKT30	SVC	0B,M.37,,		:HOW'S THIS ??
	SVC	0B,M.CRLF,,
	LR	R6,R8			:ADDRESS OF BUFFER ??
	LIS	R5,0
GPKT40	CLH	R5,BPKNT,,		:DONE ??
	JE	GPKT50			:IF SO, GO GET REPLY
	LB	R1,2,R5,R6		:GET NEXT BYTE OF BUFFER
	LR	R7,R1			:SAVE IT
	SRHLS	R1,4			:GET HIGH NIBBLE
	LB	R0,SIAASC,R1,		:CONVERT TO ASCII
	SVC	KIO,0E			:AND PRINT IT
	NHI	R7,0F			:THEN DO LOW NIBBLE
	LB	R0,SIAASC,R7,		:CONVERT TO ASCII
	SVC	KIO,0E			:AND PRINT IT
	AIS	R5,1			:BUMP INDEX
	THI	R5,3			:TEST FORMAT CONTROL TIME ?
	JN	GPKT40			:NOT YET
	LHI	R0,20			:YES, DO A BLANK
	SVC	KIO,0E			:PUT IT OUT
	THI	R5,1F			:HOW ABOUT A NEW LINE ??
	JN	GPKT40			:NOT YET
	SVC	0B,M.CRLF,,		:OK, DO THAT TOO
	J	GPKT40
GPKT50	SVC	0B,M.CRLF,,		:NEW LINE FOR REPLY
	LIS	R4,3			:RADIX
	JAL	R5,DS.NUM,,		:GET A SINGLE DIGIT REPLY
	LR	R0,R0			:TEST FOR >0=YES
	JE	DSTRT2			:IF NO GO
	SIS	R0,1			:ADJUST FROM 1-2 TO 0-1
	NHI	R0,1			:MAKE SURE WITHIN RANGE
	LH	R1,BPKNT,,		:MOVE IN GOOD LENGTH COUNT
	SLHLS	R0,0F
	OR	R1,R0			:SET BYTE INCLUDED FLAG
	STH	R1,,R8			:SET AS-IS FLAG AND BUFFER LENGTH
GPKT60	SVC	0B,M.CRLF,,
	J	DSTRT2			:AND BACK TO COMMAND HANDLER

::	RESEND - SEND USER DEFINED PACKET REPEATEDLY
:	R7=	LINK
RESEND	LHI	R10,NIPORT*2
RSND1	SIS	R10,2
	JLR	R7			:RETURN TO RMAKE
	LH	R0,ID.MT,R10,		:TEST CURRENT STATE OF THIS CHANNEL
	JLEBS	RSND1			:IF NOT IN USE
	LH	R0,GPFREQ,R10,
	JEBS	RSND1			:IF SINGLE SHOT MODE
	LR	R1,R10			:MOVE IPORT*2
	SRLS	R1,1			:GET JUST IPORT
	TBT	R1,IBKPR		:SEE IF LINK BACKPRESSURED
	JNBS	RSND1			:DON'T SEND IF SO
	AIS	R0,1
	JEFS	RSND2			:IF FULL SPEED RUNNING
	L	R0,GPLSTC,R10,R10 	:LAST TIME SENT
	AH	R0,GPFREQ,R10,		:ADD TIME TO NEXT TRANSMISSION
	CL	R0,FASTC,,		:COMPARE UNSIGNED WITH CURRENT CLOCK
	JC	RSND1			:NOT TIME YET
RSND2	JAL	R11,GPSUB2		:CONTROL GROUP CHECK
	L	R0,FASTC,,		:GET CURRENT TIME
	ST	R0,GPLSTC,R10,R10	:SAVE AS LAST TIME SEQUENCE SENT
	J	RSND1			:AND CONTINUE PORT LOOP


::	SSSEND - SINGLE SHOT SEND ON COMMAND
:	CALLED ON COMMAND, RETURN TO STATUS COMMAND PROCESSOR
SSSEND	JAL	R6,GPSUB1		:GET PORT #
	LHL	R0,GPFREQ,R10,,		:GET TICKER INTERVAL
	JN	DSTRT2			:IF NOT SET UP ON COMMAND BASIS
	JAL	R11,GPSUB2		:SEND BUFFERS
	J	DSTRT2			:THEN RETURN TO COMMAND PROCESSOR

::	SEND - SEND USER DEFINED PACKET TO SPECIFIED BUFFER
:	R5=	GROUP FLAGS
:	R6=	LINK
:	R7=	RESEND RETURN LINK (DON'T DESTROY)
:	R8=	CALLING LOOP COUNTER (DON'T DESTROY)
:	R9=	GROUP FLAGS FOR WHOLE PORT (DON'T DESTROY)
:	R10=	IPORT*2 (DON'T DESTROY)
SEND	THI	R5,0C			:IS THIS BUFFER DISABLED ?
	JER	R6			:IF SO
	LR	R1,R10			:COPY TWICE PORT #
	SRHLS	R1,1			:GET I PORT # TO SEND ON
	LB	R0,PCKSTE,R1,		:GET CURRENT PACKET STATE
	CLHI	R0,PFLOWC		:IN FLOW CONTROL STATE ??
	JEFS	SEND01			:OK IF SO
	LIS	R0,0			:ELSE CLEAR CONTROL
	SLLS	R1,2			:SO SOMEBODY RE-LOGGING IN
	ST	R0,GPFLAG,R1,		:ON THIS PORT ISN'T BLASTED
	JR	R6			:IMMEDIATELY WITH OUTPUT
SEND01	THI	R5,8			:STUFFING IRING ??
	JE	SEND20			:IF SO, HANDLE SEPARATELY
	SLLS	R1,2			:GET AS PORT*4 FOR BUFFERS
	AHI	R1,IECBIA		:ASSUME IECBUF AT FIRST
	THI	R5,4			:TEST BUFFER FLAG
	JNFS	SEND02			:IF SO
	AHI	R1,IEDBIA-IECBIA	: ADJUST FOR IEDBUF
SEND02	CBCT(R0,R1)			:SEE HOW MUCH STUFF IS QUEUED NOW
	CLHI	R0,400			:PRETTY HIGH LIMIT
	JGER	R6			:DON'T PUSH A BUFFER ZAP
	LR	R11,R5			:MOVE FLAGS
	NHI	R11,3			:GET BUFFER #
	SLLS	R11,3			:FOR DOUBLE WORD INDEX
	L	R11,GBTABL,R11,		:GET PACKET BUFFER ADDRESS
	LHL	R13,,R11		:GET ITS CURRENT CONTENTS LENGTH
	JER	R6			:IF EMPTY
	LB	R0,2,R11		:GET FIRST BYTE=PACKET TYPE
	NHI	R13,7FFF		:OFF INCLUDE BC FLAG
	JAL	R4,WCI,,		:PUT IT IN
	SIS	R13,1			:DECREMENT LENGTH COUNT
	JER	R6			:IF THAT'S ALL SHE WROTE
	LH	R0,,R11			:IS THIS BUFFER SEND-AS-IS ??
	JLFS	SEND10			:IF SO
	EXBR	R0,R13
	JAL	R4,WCI,,		:PUT IN TWO BYTE LENGTH
	LBR	R0,R13
	JAL	R4,WCI,,
SEND10	LB	R0,3,R11		:GET NEXT BYTE (SKIP OVER PACKET TYPE)
	JAL	R4,WCI,,		:PUT IT INTO BUFFER
	AIS	R11,1			:INCREMENT BUFFER INDEX
	SIS	R13,1			:DECREMENT PACKET BYTE LENGTH
	JNBS	SEND10			:IF MORE TO DO
	JR	R6			:ELSE RETURN

SEND20	LCS	R11,4			:COMPUTE SPACE LEFT IN IRING
	LHL	R12,NFMI+IRING,,
	NH	R11,CEI+IRING,,		:FORCE EMPTIER TO WORD BOUNDARY
	SR	R11,R12			:SPACE BETWEEN US AND EMPTIER
	JGFS	SEND30			:SKIP IF NO WRAP AROUND
	AHI	R11,IRSIZE		:ELSE CORRECT FOR WRAP
SEND30	SIS	R11,4			:(R11)=# FREE BYTES LEFT
	SHI	R12,IRSIZE		:CONVERT TO NEGATIVE INDEX
	LR	R13,R5			:MOVE FLAGS
	NHI	R13,3			:GET BUFFER #
	SLLS	R13,3			:FOR DOUBLE WORD INDEX
	L	R1,GBTABL,R13,		:GET BUFFER ADDRESS
	LH	R2,,R1			:GET BUFFER BYTE COUNT
	JER	R6			:EMPTY, SKIP OUT
	LR	R3,R10			:MOVE IPORT*2
	SLLS	R3,1			:TO COMPUTE BUFFER #
	AHI	R3,IEDBIA		:ALL RING DATA GOES TO IEDBUF
	CBCT(R0,R3)			:SEE HOW FULL ALREADY
	CLHI	R0,$0400		:A REASONABLE AMOUNT ??
	JGER	R6			:DON'T OVER DO IT

:	GOING TO SEIZE R14 SO DON'T TAKE ANY EXITS UNTIL DONE
	LR	R14,R12			:ALREADY HAS NEGATIVE INDEX
	LHL	R3,ID.MT,R10,		:DPORT #
	STH	R3,IRING+RING+IRSIZE,R14, :ISIS PORT #
	STB	R2,2+IRING+RING+IRSIZE,R14, :BYTE COUNT
	AIS	R14,3			:BUMP PAST THESE THREE CHAR
SEND40	LB	R0,2,R1			:GET NEXT BYTE OF BUFFER
	AIS	R1,1			:BUMP BUFFER PTR
	STB	R0,IRING+RING+IRSIZE,R14,  :PLACE I RING
	AIS	R14,1			:BUMP RING INDEX
	JLFS	SEND50			:IF NOT TIME TO WRAP
	LHI	R14,-IRSIZE		:ELSE WRAP RING
SEND50	SIS	R2,1			:DECREMENT BYTE COUNT
	JGBS	SEND40			:AND LOOP FOR NEXT BYTE
	AIS	R14,3			:ROUND UP MESSAGE LENGTH
	NHI	R14,-4			:TO HALF-WORD BOUNDARY
	JLFS	SEND60			:IF NO NEED TO FOLD
	LHI	R14,-IRSIZE		:ELSE FOLD RING INDEX
SEND60	AHI	R14,IRSIZE		:CONVERT BACK TO OFFSETS
	STH	R14,NFMI+IRING,,	:ADVANCE PTR TO NEXT MESSAGE
	JR	R6			:DONE PUTTING INTO IRING

::	REMRK - IGNORE REMARK LINE 
REMRK	SVC	0A,0F			:GET NEXT CHARACTER
	J	REMRK			:NOT YET
	OHI	R0,80			:SET HIGH BIT
	CLHI	R0,8D			:FLUSH TO <LF>
	JNBS	REMRK			:NOT YET
	J	DSTRT2		

::	PAWS - PAUSE COMMAND PROCESSING FOR N SECONDS
PAWS	LHI	R4,10			:RADIX
	JAL	R5,DS.NUM,,		:GET ARG VALUE=SECONDS
	NHI	R0,7F			:PUT A REASONABLE LIMIT ON IT
PAWS1	SVC	DISMIS,1		:DISMISS FOR ONE SECOND
	SIS	R0,0			:DECREMENT COUNTER
	JGBS	PAWS1			:NOT DONE YET
	J	DSTRT2			:DONE, RETURN TO COMMAND PROCESSOR

	SEG	A.WTBL
GPRETN	HS	2			:TEMP RETURN STORAGE FOR GPSUB2
BPKNT	HS	1			:TEMPORARY COUNT BYTES IN BPKBUF
GPORT	HS	1			:PORT #

GBUF1	HS	202			:FIRST BUFFER ALLOWS 1024 PACKET
GBUF2	HS	82			:OTHERS ALLOW 128 BYTE PACKETS
GBUF3	HS	82
GBUF4	HS	82

GPLSTC	HS	NIPORT*2		:FASTC LAST TIME WE SENT SEQUENCE
GPFREQ	HS	NIPORT			:FREQUENCY IN FASTC TO SEND PACKET
					:SEQUENCE OVER THIS PORT.  
					: 0 = SINGLE SHOT, BY COMMAND ONLY
					: FFFF = FULL SPEED, WATCH BACKPRESSURE
					: XXXX = FASTC TICKS INTERVAL
GPFLAG	HS	NIPORT*2		:SEQUENCE CONTROL FLAGS, 8 GROUPS OF 4.
:	ORDER OF OUTPUT IS LAST GROUP FIRST, THEN SECOND TO LAST, ETC.
					: BIT DEFINITION WITHIN EACH GROUP:
: WXYZ WXYZ WXYZ WXYZ WXYZ WXYZ WXYZ WXYZ WHERE W = 1 TO DISABLE, ELSE 0
					:	X = 1 FOR IECBUF, ILSE IEDBUF
					:	YZ = BUFFER #
XDBSS0	HS	0


:	BUFFER ADDRESSES AND MAX LENGTHS
GBTABL	WC	GBUF1,$0402
	WC	GBUF2,$0102
	WC	GBUF3,$0102
	WC	GBUF4,$0102
TCANFL	BS	1			:FLAG, 1= TRASHING DATA
XDBSS0	HS	0
AVETIM	HS	2			:SLOWC TO END AVERAGING INTERVAL
POS.A	SC	/"1B&arrr ccC/		:ABSOLUTE CURSOR POSITIONING
	HS	0
POS.R	SC	/"1B&a +rrr+ccC/	:RELATIVE CURSOR POSITIONING
X.ADD	WS	40		:CELL ADDRESS
X.LBL	WS	40*2		:USER LABEL
X.VAL	WS	40		:LAST PRINTED VALUE
	HS	0
ROW	BS	1		:ABSOLUTE ROW # FOR POSITIONING ROUTINE
COL	BS	1		:ABSOLUTE COL # FOR POSITIONING ROUTINE
	HS	0
C.ROW	BS	1		:FIRST ROW OF CURRENT WINDOW
	BS	1		:LAST ROW OF CURRENT WINDOW
RROW	HS	1		:RELATIVE # OF ROWS TO MOVE CURSOR
RCOL	HS	1		:RELATIVE # OF COLS TO MOVE CURSOR
VUE.PL	BS	1		:PAUSED FLAG
VWSAVE	BS	1
V.TEMP	HS	1
VT1	HS	2
VT2	HS	2
:	WINDOWS
WIN.CM	BS	2		:COMMAND WINDOW
	BS	2
	BS	2
	BS	2
	BS	2
	BS	2

:	WINDOW PROCESS ADDRESSES
WJUMPS	WS	1		:COMMAND WINDOW NOT USED THIS WAY
	WS	1
	WS	1
	WS	1
	WS	1
	WS	1
NJUMPS	EQ	(.-WJUMPS)/2

XDB0SZ	EQ	.-XDBSS0

: ------------------------------------------------------------

	SEG	A.RTBL

	KILL	SCROLL
SCROLL	MACRO(window)[
	LIS	R1,window
	JAL	R4,SCROL,,
]

XDBSS1	HS	0
POS.A2	SC	/"1B&arrr ccC/			:ABSOLUTE CURSOR POSITIONING
	HS	0
POS.R2	SC	/"1B&a +rrr+ccC/	:RELATIVE CURSOR POSITIONING
POS.2L	EQ	.-POS.A2
VUE.M1	SC	/VDDT Version 1/
BL1	SC	/ /

	SEG	A.CODE
:	ENTER HERE TO START FRESH
:	ZERO SEGMENT 0 STORAGE
VUE.00	LIS	R0,0
	LA	R1,XDBSS0,,
	LHI	R2,XDB0SZ-1
VUE.10	STB	R0,,R1,R2
	SIS	R2,1
	JGEBS	VUE.10
	LHI	R1,POS.2L-1
VUE.12	LB	R0,POS.A2,R1,
	STB	R0,POS.A,R1,
	SIS	R1,1
	JGEBS	VUE.12

:	PRINT USER MESSAGES OF HOW TO USE THIS DISPLAY
	SVC	0B,V.M0,,
	SVC	0B,V.M1,,
	SVC	0B,V.M2,,
	SVC	0B,V.M3,,
	SVC	0B,V.M4,,
	SVC	0B,V.M5,,
	SVC	0B,V.M6,,
	SVC	0B,V.M7,,
	SVC	0B,V.M8,,
	SVC	0B,V.M9,,
	SVC	0B,V.M10,,
	SVC	0B,V.M11,,

:	READ FIRST AND LAST ROW#'S OF COMMAND WINDOW
:		::row#,row#
:	JAL	R2,VUE.H0
	LIS	R1,0			:FORCE COMMAND WINDOW HERE
	STB	R1,WIN.CM,,
:	JAL	R2,VUE.H0
	LIS	R1,4			:TO SIMPLY USER INTERACTION
	STB	R1,WIN.CM+1,,

:	ENTER HERE TO CONTINUE WITH OLD SETUP
:	CLEAR THE SCREEN, SEND USER GREETING
VUE.20	SVC	0D,5			:SEND GOBBLER
	SVC	0B,VUE.HU,,		:HOME UP
	SVC	0B,VUE.CS,,		:CLEAR THE SCREEN
	SCROLL(0)			:POSITION IN COMMAND WINDOW
	SVC	0B,VUE.M1,,		:USER HELLO
	SCROLL(0)			:AND THEN REPOSITION

:	LOOK FOR USER INPUT COMMANDS
VUE.30	SVC	0A,0000			:ANY INPUT, DON'T WAIT
	J	VUE.50			:NO,
	NHI	R0,7F			:OFF THE PARITY
	CLHI	R0,60			:UPPER CASE ?
	JLEFS	VUE.40			:IF SO
	SHI	R0,20			:BIAS TO UPPER CASE
VUE.40	CLHI	R0,52			:"R" REFRESH THE SCREEN ?
	JE	VUE.20			:IF SO
	CLHI	R0,51			:"Q" QUIT ?
	JE	VUE.Q			:IF SO
	CLHI	R0,50			:"P" PAUSE ?
	JE	VUE.P			:IF SO
	CLHI	R0,43			:"C" CONTINUE ?
	JE	VUE.C			:IF SO
	CLHI	R0,4D			:"M" MAKE AN ENTRY ?
	JE	VUE.M			:IF SO
	CLHI	R0,57			:"W" WINDOW DEFINITION
	JE	VUE.W			:IF SO
	CLHI	R0,46			:"F" FLUSH OUTPUT
	JE	VUE.F			:IF SO

:	CONTROL LOOP THROUGH ACTIVE WINDOWS
VUE.50	LB	R0,VUE.PL,,		:PAUSED ?
	JN	VUE.90			:IF SO, NO WINDOW PROCESSING
	LIS	R1,2			:OFFSET OT ACTIVE WINDOW ADDRS
VUE.60	L	R2,WJUMPS,R1,R1		:IS THIS ONE ACTIVE ?
	JEFS	VUE.80			:IF NOT
	STB	R1,VWSAVE,,		:SAVE PLACE IN TABLE
	LH	R0,WIN.CM,R1,		:WINDOW LIMITS
	STH	R0,C.ROW,,		:CURRENT WINDOW FIRST, LAST ROW
	JALR	R2,R2			:GO TO IT
VUE.70	LB	R1,VWSAVE,,		:RESTORE TABLE OFFSET
VUE.80	AIS	R1,2
	CLHI	R1,NJUMPS		:DONE ??
	JN	VUE.60			:IF NOT
VUE.90	SVC	FASTD,0			:FAST DISMISS
	J	VUE.30			:AND CONTINUE

: ------------------------------------------------------------
:	DEFINE A WINDOW
:	::W<window#>,label,row#,row#
VUE.W	JAL	R2,VUE.H0		:GET WINDOW #
	LA	R4,,R1,R1
	JAL	R2,VUE.H0		:GET WINDOW ADDRESS
	ST	R1,WJUMPS,R4,R4		:PUT INTO JUMP TABLE
	JE	VUE.30			:IF TURNING OFF THIS WINDOW
	JAL	R2,VUE.H0		:FIRST ROW# OF WINDOW
	STB	R1,WIN.CM,R4,
	JAL	R2,VUE.H0		:LAST ROW# OF WINDOW
	STB	R1,WIN.CM+1,R4,
	SCROLL(0)			:SCROLL COMMAND WINDOW
	J	VUE.30

: ------------------------------------------------------------
:	MAKE AN ENTRY IN MONITOR TABLES
:	::M<row#>,<col#>
:	::<displaylabel>,address,length
VUE.M	JAL	R2,VUE.H0		:GET ROW#
	NHI	R1,0F			:PUT IN 0-15 RANGE
	LR	R5,R1
	SLLS	R5,4			:0,10,20,30 FOR TABLE OFFSETS
	JAL	R2,VUE.H0		:GET COL#
	NHI	R1,3			:FORCE TO 0-3 RANGE
	LR	R6,R1
	SLLS	R6,2			:0,4,8,C FOR TABLE OFFSETS
	ST	R2,X.VAL,R5,R6		:ARBITRARY VALUE, CAUSES INITIAL DISPLAY
	SCROLL(0)
	LA	R1,,R5,R6
	AI	R1,X.LBL,R1		:COMPUTE STORAGE ADDRESS
	LR	R4,R1			:SAVE FOR STORING LENGTH
	JAL	R2,VUE.A0		:GET ASCII LABEL
	JAL	R2,VUE.H0		:GET TRACE ADDRESS
	ST	R1,X.ADD,R5,R6		:AND SAVE IN ADDRESS TABLE
	JAL	R2,VUE.H0		:GET LENGTH
	NHI	R1,3			:FORCE TO 0-3 (+1 BYTES)
	STB	R1,7,R4			:SAVE AS FLAGS BYTE
	SCROLL(0)
	J	VUE.30

: ------------------------------------------------------------
:	FLUSH OUTPUT
VUE.F	SVC	KIO,5			:EMIT GOBBLER
	J	VUE.30

: ------------------------------------------------------------
:	PAUSE DISPLAY
VUE.P	STB	R0,VUE.PL,,		:SET PAUSE FLAG NONZERO
	J	VUE.30

: ------------------------------------------------------------
:	CONTINUE DISPLAY
VUE.C	LIS	R0,0
	STB	R0,VUE.PL,,		:CLEAR PAUSE FLAG
	J	VUE.30
: ------------------------------------------------------------
:	EXIT TO ?STAT COMMAND HANDLER
VUE.Q	SVC	0B,VUE.HU,,		:HOME UP
	SVC	0B,VUE.CS,,		:CLEAR THE SCREEN
	J	DSTRT2			:RETURN TO ?STAT COMMAND HANDLER
: ------------------------------------------------------------
:	DISPLAY TRACED CELLS WHICH HAVE CHANGED IN VALUE
VUE.EM	LIS	R6,0			:ROW OFFSETS IN TABLES (0,10,20,30)
	LIS	R7,0			:COL OFFSETS IN TABLES (0,4,8,C)
VUEM10	JAL	R8,VUEM20		:CALL FOR EACH ENTRY
	AIS	R7,4			:NEXT COL
	NHI	R7,0F			:WATCH FOR WRAP
	JNBS	VUEM10			:NOT YET
	AHI	R6,10			:TO NEXT ROW
	NHI	R6,0FF			:WATCH FOR WRAP
	JNBS	VUEM10			:NOT YET
	J	VUE.70			:DONE WITH THIS ROUTINE

:	IF THIS ENTRY HAS CHANGED, SEND IT OUT
VUEM20	L	R1,X.ADD,R6,R7		:GET ADDRESS OF CELL
	JER	R8			:EXIT IF NOT IN USE
	LA	R11,,R6,R7
	LB	R0,X.LBL+7,R11,R11	:FLAGS WORD FROM LABEL STORAGE
	NHI	R0,3			:KEEP LENGTH ONLY (0-3)
	LIS	R3,0			:INITIALIZE ACCUMULATOR
VUEM30	SLLS	R3,8			:POSITION ACCUMULATOR
	LB	R2,,R1			:GET NEXT BYTE
	OR	R3,R2			:ADD IN TO ACCUMULATOR
	AIS	R1,1			:ALSO ADVANCE CHANGING ADDR
	SIS	R0,1			:DECREMENT COUNTER
	JGEBS	VUEM30			:LOOP IF MORE BYTES
	L	R0,X.VAL,R6,R7		:HAS IT CHANGED ?
	CR	R0,R3
	JER	R8			:IF NOT
	ST	R3,X.VAL,R6,R7		:SAVE NEW VALUE
	JAL	R0,PCURSW,,		:POSITION TO CURRENT WINDOW
	LR	R0,R7			:CONVERT TABLE OFFSETS
	SLLS	R0,2			:TO CURSOR POSITIONS
	STH	R0,RCOL,,		:(0,4,8,C) TO (0,10,20,30)
	LR	R0,R6
	SRHLS	R0,4			:(0,10,20,30) TO (0,1,2,3)
	STH	R0,RROW,,
	JAL	R0,PCURSR,,		:RELATIVE CURSOR POSITIONING
	SVC	0B,BL1,,		:PRECEED WITH A BLANK
	LA	R11,,R6,R7
	SVC	0B,X.LBL,R11,R11	:THEN USER LABEL
	SVC	0B,BL1,,		:AND ONE MORE BLANK
	L	R0,X.VAL,R6,R7		:VALUE
	LB	R1,X.LBL+7,R11,R11	:FLAGS WORD FROM LABEL STORAGE
	NHI	R1,3			:LENGTH
	AIS	R1,1			:ADJUST (0,1,2,3) TO (1,2,3,4) 
	SLLS	R1,9			:POSITION FOR FORMAT, DOUBLE
	OHI	R1,50			:ALSO ZERO FILL, HEX RADIX
	SVC	KIO,0A			:TO TTY
	SVC	0B,XDCRLF,,		:FOR NAD
	LB	R0,WIN.CM+1,,		:LAST ROW OF COMMAND WINDOW
	EXBR	R0,R0			:ROW, COL 0
	STH	R0,ROW,,
	JAL	R0,PCURSA,,		:GO TO LAST ROW OF COMMAND WINDOW
	JR	R8			:RETURN

: ------------------------------------------------------------
:	GET A HEX VALUE FROM THE USER
VUE.H0	LIS	R1,0			:CLEAR ACCUMULATOR
VUE.H4	SRLS	R1,4			:SHIFT OFF LAST DIGIT
VUE.H1	JAL	R3,VUE.GC		:GET NEXT CHARACTER
	JR	R2			:IF DELIMITER
	JBS	VUE.H4			:^A BACKSPACE ONE CHARACTER
	JBS	VUE.H0			:^W BACKSPACE TOKEN
	TBT	R0,ALPNUM,,		:ALPHA NUMERIC ??
	JER	R2			:IF NOT, ASSUME DELIMITER
	CLHI	R0,40			:DIGIT ?
	JLEFS	VUE.H3			:IF SO
	CLHI	R0,60			:CAPITAL
	JLFS	VUE.H2			:IF SO
	SHI	R0,20			:BIAS
VUE.H2	SIS	R0,7			:A(41) -> 0A(3A)
VUE.H3	NHI	R0,0F			:GET DIGIT PART
	SLLS	R1,4			:POSITION
	OR	R1,R0			:ADD INTO ACCUMULATOR
	J	VUE.H1			:LOOK FOR MORE INPUT
:	HEX DIGITS
ALPNUM	BC	0,0,0,0,0,0,0FF,0C0,7E,0,0,0,7E,0,0,0

: ------------------------------------------------------------
:	GET AN ASCII (6 BYTES) LABEL FROM THE USER
:	R1 =	STORAGE ADDRESS
:	R2 =	LINK ADDRESS
VUE.A0	LIS	R0,0
	STB	R0,,R1			:INITIALIZE BYTE COUNT
VUE.A1	JAL	R3,VUE.GC		:GET NEXT CHARACTER
	JR	R2			:DELIMITER, RETURN
	JFS	VUE.A4			:^A BACKSPACE ONE CHARACTER
	JBS	VUE.A0			:^W BACKSPACE LAST TOKEN
	LB	R3,,R1			:GET CURRENT BYTE COUNT
	JFS	VUE.A2			:KEEP UP TO 6 CHARACTERS
VUE.A4	LB	R3,,R1			:CURRENT BYTE COUNT
	SIS	R3,1			:DECREMENT IT
	JFS	VUE.A3			:SAVE IT
VUE.A2	CLHI	R3,6			:ALLOW ONLY 6 CHARACTERS
	JE	VUE.A1			:IGNORE IF FULL
	AIS	R3,1			:BUMP IT
	STB	R0,,R1,R3		:SAVE CHARACTER
VUE.A3	STB	R3,,R1			:SAVE BYTE COUNT
	J	VUE.A1			:GO GET ANOTHER CHARACTER

: ------------------------------------------------------------
:	GET A CHARACTER
:	JAL	R3,VUE.GC
:	 +0	RETURN IF DELIMITER
:	 +2	RETURN IF ^A BACKSPACE ONE CHARACTER
:	 +4	RETURN IF ^W BACKSPACE ONE TOKEN
:	 +6	RETURN OTHERWISE
VUE.GC	SVC	0A,0010
	J	VUE.GC			:TIMEOUT
	NHI	R0,7F
	CLHI	R0,01			:^A ?
	JE	2,R3			:IF SO
	CLHI	R0,17			:^W ?
	JE	4,R3			:IF SO
	TBT	R0,DELIMT		:DELIMITER ?
	JNR	R3			:IF SO
	J	6,R3			:OTHERWISE, JUST RETURN IT
DELIMT	HC	0FFFF,0FFFF,0FFFD,003F,8000,001F,8000,0FFE0

: ------------------------------------------------------------
:	SCROLL A WINDOW
:	LIS	R1,window number
:	JAL	R4,SCROLL,,
SCROL	LH	R1,WIN.CM,R1,R1
	STH	R1,V.TEMP,,
	LIS	R0,0
	STB	R0,COL,,
	EXBR	R1,R1
	STB	R1,ROW,,
	JAL	R0,PCURSA,,		:GO THERE
	SVC	0B,VUE.DL,,		:DELETE ONE LINE
	SVC	0B,XDCRLF,,		:FOR NAD
	LB	R1,V.TEMP+1,,
	STB	R1,ROW,,
	JAL	R0,PCURSA,,		:GO THERE
	SVC	0B,VUE.IL,,		:INSERT LINE
	JR	R4			:RETURN

: ------------------------------------------------------------
:	POSITION CURSOR TO FIRST ROW OF CURRENT WINDOW
:	LINK	R0
:	USES	R1,R2
PCURSW	LB	R1,C.ROW,,		:FIRST ROW OF CURRENT WINDOW
	EXBR	R1,R1			:WE WANT ROW # ONLY, COL TO BE 0
	STH	R1,ROW,,		:SET BYTE PAIR FOR PCURSA ROUTINE

:	POSITION CURSOR TO ABSOLUTE "ROW" AND "COL"
PCURSA	LB	R1,ROW,,		:GET ROW #
	LH	R2,H2A,R1,R1		:GET ASCII EQUIVALENT
	STH	R2,POS.A+4,,		:PUT INTO ESCAPE SEQUENCE
	LB	R1,COL,,		:GET COLUMN #
	LH	R2,H2A,R1,R1		:GET ASCII EQUIVALENT
	STH	R2,POS.A+8,,		:PUT INTO ESCAPE SEQUENCE
	SVC	0B,POS.A,,		:SEND POSITIONING ESCAPE SEQUENCE
	JR	R0

: ------------------------------------------------------------
:	POSITION CURSOR "RROW" AND "RCOL" RELATIVE TO CURRENT POSITION
PCURSR	LHI	R1,2B			:"+" SIGN OF MOVEMENT
	LH	R2,RROW,,		:RELATIVE ROW #
	JGEFS	PCUR10			:IF POSITIVE
	LIS	R2,0			:ELSE USE POSITIVE VALUE
	SH	R2,RROW,,		:AND NEGATIVE SIGN
	LHI	R1,2D			:"-" SIGN OF MOVEMENT
PCUR10	STB	R1,POS.R+5,,		:PUT INTO ESCAPE SEQUENCE
	LH	R2,H2A,R2,R2		:GET ASCII DECIMAL EQUIVALENT
	STH	R2,POS.R+6,,		:PUT IT IN
	LHI	R1,2B			:"+" SIGN OF MOVEMENT
	LH	R2,RCOL,,		:RELATIVE COLUMN #
	JGEFS	PCUR20			:IF POSITIVE
	LIS	R2,0			:ELSE USE POSITIVE VALUE
	SH	R2,RCOL,,		:WITH NEGATIVE SIGN
	LHI	R1,2D			:"-" SIGN OF MOVEMENT
PCUR20	STB	R1,POS.R+9,,		:PUT IN DIRECTION OF MOVEMENT
	LH	R2,H2A,R2,R2		:GET ASCII DECIMAL EQUIVALENT
	STH	R2,POS.R+0A,,		:PUT IT IN
	SVC	0B,POS.R,,		:SEND ESCAPE SEQUENCE
	JR	R0			:RETURN

: ------------------------------------------------------------
	SEG	A.RTBL
:	CLEAR THE SCREEN
VUE.CS	SC	/"1B"4A"1BH"1BJ"1BH"1BJ/
:	CLEAR THE LINE
VUE.CL	SC	/"1B"4B"1B"4B/
:	UNDER SCORE ENABLE
VUE.UE	SC	/"1B"26"64"41/
:	UNDER SCORE DISABLE
VUE.UD	SC	/"1B"26"64"40/
:	DELETE LINE
VUE.DL	SC	/"1B"4D/
:	INSERT LINE
VUE.IL	SC	/"1B"4C/
:	INSERT CHARACTER ON
VUE.IN	SC	/"1B"51/
:	INSERT CHARACTER OFF
VUE.IF	SC	/"1B"52/
:	DELETE CHARACTER
VUE.DC	SC	/"1B"50/
:	CURSOR HOME UP
VUE.HU	SC	/"1B"48/
:	CURSOR HOME DOWN
VUE.HD	SC	/"1B"46/

XDCRLF	SC	/"8D"8A/
H2A	AC	/0001020304050607080910111213141516171819/
	AC	/2021222324252627282930313233343536373839/
	AC	/4041424344454647484950515253545556575859/
	AC	/6061626364656667686970717273747576777879/
: **************************************************
	EI	DDTDIA-2
	EI	DDTDIA-1
	SEG	A.CODE

:	MOVE MESSAGE TO STORAGE

:	R1  = ENTER WITH POINTER TO MESSAGE
:	R0, R2, R3 DESTROYED
:	R4 = LINK REGISTER

MSGMV	LB	R3,,R1			:GET MESSAGE LENGTH
	JER	R4			:GET OUT IF NULL
	LB	R2,MSGSPC,,		:GET CURRENT LENGTH OF MESSAGE STORE
	LR	R0,R2	
	AR	R0,R3			:CALCULATE NEW STORE LENGTH
	STB	R0,MSGSPC,,		:SET NEW LENGTH
MSMV10	LB	R0,,R1,R3		:GET BYTE OF MESSAGE
	STB	R0,MSGSPC,R2,R3		:MOVE TO STORE
	SIS	R3,1			:DECREMENT BYTE COUNT
	JNBS	MSMV10			:IF MORE TO DO
	JR	R4

:	MOVE BYTE TO STORAGE

:	R0 = BYTE TO BE MOVED
:	R1 DESTROYED
:	R2 = LINK REGISTER

BYTMV	LB	R1,MSGSPC,,		:GET BYTE COUNT
	AIS	R1,1			:BUMP COUNT
	STB	R1,MSGSPC,,		:REPLACE
	STB	R0,MSGSPC,R1,		:PUT BYTE INTO STORAGE
	JR	R2			:RETURN

:	MOVE NUMBER TO STORAGE

:	R0  = NUMBER TO BE CONVERTED AND MOVED
:	R1  = FIELD WIDTH
:	R2, R3 DESTROYED
:	R4 = LINK REGISTER

NUMMV	LB	R2,MSGSPC,,		:GET OLD MESSAGE LENGTH
	AR	R2,R1			:COMPUTE NEW LENGTH
	STB	R2,MSGSPC,,		:SAVE NEW LENGTH
NUMM00	LIS	R3,0F			:GET MASK
	NR	R3,R0			:GET LAST DIGIT
	LB	R3,SIAASC,R3,		:CONVERT TO ASCII
	STB	R3,MSGSPC,R2,		:PUT INTO STORE
	SIS	R1,1			:BUMP COUNT
	JER	R4
	SIS	R2,1			:MOVE POINTER
	SRLS	R0,4			:DISCARD USED DIGIT
	J	NUMM00			:GO DO IT AGAIN


:	DUMP CONTENTS OF ALL BUFFERLET CHAINS IN HEX.
X.SBHN	ST	R0,DDTRET		:SAVE RETURN ADDRESS
	LIS	R15,0			:INITIALIZE FLAG INDICATING NOTHING FOUND
	LIS	R6,0			:INITIALIZE BUFFER #
XSBF00	LIS	R3,0
	STB	R3,MSGSPC,,		:INIT STORAGE
:	R6=BUFFER NUMBER*4 (INDEX)
	CLHI	R6,NBUF*4		:RANGE CHECK BUFFER #
	JGE	XSBF98			:TOO BIG
	LR	R2,R6			:GET BUFFER INDEX
	SRLS	R2,2			:CONVERT TO BUFFER INDEX
	TBT	R2,BFILT,,		:ARE WE DISPLAYING THIS BUFFER?
	JE	XSBF10			:IF NOT
	LA	R1,XDBUFL,,		:"BUF" MESSAGE
	JAL	R4,MSGMV		:MOVE TO STORE
	LIS	R1,3			:BUFFER NUMBER FIELD WIDTH
	LR	R0,R6			:MOVE BUFFER NUMBER
	JAL	R4,NUMMV		:MOVE TO STORE
	L	R8,BB,R6,		:BUFFER BEGINNING
	CBCT(7,6)			:LOOK AT BYTE COUNT OF BUFFER
	LR	R7,R7
	JN	XSBF20			:IF NOT EMPTY
XSBF10	LIS	R9,0
	STB	R9,MSGSPC,,		:CLEAR STORE
	AIS	R6,4			:GO TO NEXT BUFFER
	J	XSBF00

XSBF20	LR	R15,R15			:FIRST TIME?
	JNFS	XSBF25			:IF NOT
	SVC	0B,M.BHN,,		:TELL WHO WE ARE
XSBF25	AIS	R15,1			:INDICATE SOMETHING FOUND
	LA	R1,XDBEQ,,		:POINT TO COLON MESSAGE
	JAL	R4,MSGMV		:MOVE TO STORE
XSBF30	LB	R0,,R8			:GET NEXT CHARACTER FROM BUFFER
	LBR	R3,R0			:COPY IT
	LBR	R1,R0			:COPY IT AGAIN
	SRHLS	R1,4			:LEFT NIBBLE
	LB	R0,SIAASC,R1,		:CONVERT TO ASCII
	JAL	R2,BYTMV		:MOVE BYTE TO STORAGE
	NHI	R3,0F			:RIGHT NIBBLE
	LB	R0,SIAASC,R3,		:CONVERT TO ASCII
	JAL	R2,BYTMV		:MOVE BYTE TO STORAGE
	AIS	R8,1			:NEXT CHARACTER IN BUFFERLET
	THI	R8,0F			:END OF BUFFERLET ??
	JN	XSBF40			:IF NOT
	SVC	0B,MSGSPC,,		:PRINT WHAT WE HAVE NOW
	LIS	R3,0
	STB	R3,MSGSPC,,		:CLEAR OUT ACCUMULATED MSG
	LHL	R8,,R8			:STEP TO NEXT BUFFERLET
	CLHI	R8,NBFLET		:GOOD BUFFER LINK?
	JGE	XSBF50			:NO, SKIP REST OF BUFFER
	SLLS	R8,4			:CONVERT TO BUFFERLET POINTER
	AI	R8,BUFERS-0E		:ADJUST TO ITS START
	LA	R1,M.CRLF,,		:POINT TO CRLF MESSAGE
	JAL	R4,MSGMV		:MOVE TO STORE
XSBF40	SIS	R7,1			:DECREMENT CHARACTER COUNT
	JG	XSBF30			:IF NOT DONE YET
XSBF50	AIS	R6,4			:TO NEXT BUFFER
	SVC	0B,MSGSPC,,		:PRINT CONTENTS OF BUFFER
	J	XSBF00

XSBF98	LR	R15,R15			:ANYTHING FOUND?
	JE	XSBF99			:IF NOT
	LA	R1,M.CRLF,,		:POINT TO CRLF MESSAGE
	JAL	R4,MSGMV		:MOVE TO STORE
	SVC	0B,MSGSPC,,		:PRINT STORE
XSBF99	L	R0,DDTRET		:GET RETURN ADDRESS
	JR	R0			:RETURN

:	DUMP I/O RINGS
:
RR	EQ	8			:REGISTER ADDRESS OF RING
RS	EQ	9			:REGISTER RING SIZE
MAXINM	EQ	10			:MAX NUMBER OF INTRA NODE MESSAGE TYPES

X.SRO	ST	R0,DDTRET		:SAVE RETURN ADDRESS
	LIS	R15,0			:RESET COUNT OF PASSES
	LA	RR,ORING,,		:SET UP FOR ORING
	LHI	RS,ORSIZE
	LH	R1,ONFMI		:GET CURRENT POINTER
	CLH	R1,NFMI,RR,		:ARE WE CAUGHT UP?
	JE	XSROA4			:IF SO
	JAL	R10,BEGMSG		:GUESS AT FIRST MESSAGE
	STH	R1,ONFMI		:SAVE GUESS
	LHL	R3,RING,R1,RR		:GET PORT #
	TBT	R3,PFILT,,		:DOES THIS PORT GET THROUGH THE FILTER?
	JNFS	XSRO70			:IF SO
	JAL	R0,SKPDSP,,		:SKIP DISPLAY
	J	XSRO90			:CONTINUE

XSRO70	SVC	0B,M.CRLF,,		:NEW LINE
	LR	R15,R15			:FIRST TIME?
	JNFS	XSRO75			:IF NOT
	SVC	0B,M.RO,,		:TELL WHO WE ARE
XSRO75	AIS	R15,1			:BUMP COUNT OF PASSES
	SVC	0B,M.O,,		:OUTPUT "O "
	JAL	R0,RNGDSP		:DISPLAY MESSAGE

XSRO90	AIS	R1,3			:ROUND UP TO FULL WORD
	NHI	R1,-4			:AND I.E., NEXT MESSAGE
	CR	R1,RS			:TO END OF RING ??
	JLFS	XSROA0			:IF NOT
	LIS	R1,0			:FOLD TO START OF RING	:DRE 4-JAN-84
XSROA0	CLH	R1,NFMI,RR		:CAUGHT UP ?
	JE	XSROA4			:IF SO
	LHL	R3,RING,R1,RR		:GET PORT #
	:changes begin here to fix illegal instruction crash due to ring
	:wrapped.						:LSH 30-JUN-87
	CLHI	R3,NDPORT		:CHECK IF IT IS A RIGHT PORT #
	JL	XSROA5			:YES
	JAL	R10,BEGCON		:GUESS AT NEXT MESSAGE
	LHL	R3,RING,R1,RR		:GET PORT NUMBER
	:changes end here					:LSH 30-JUN-87
XSROA5	TBT	R3,PFILT,,		:DOES THIS PORT GET THROUGH THE FILTER?
	JNFS	XSROA2			:IF SO
	JAL	R0,SKPDSP		:SKIP DISPLAY
	J	XSRO90			:CONTINUE

XSROA2	CLH	R1,NFMI,RR		:CAUGHT UP ?
	JE	XSROA4			:IF SO
	SVC	0B,M.CRLF,,		:CR LF
	LR	R15,R15			:FIRST TIME?
	JNFS	XSROA3			:IF NOT
	SVC	0B,M.RO,,		:TELL WHO WE ARE
XSROA3	AIS	R15,1			:BUMP COUNT OF PASSES
	SVC	0B,M.O,,		:OUTPUT "O "
	JAL	R0,RNGDSP		:DISPLAY MESSAGE
	J	XSRO90			:NEXT MESSAGE

XSROA4	STH	R1,ONFMI		:SAVE ORING POINTER
	L	R0,DDTRET
	JR	R0			:RETURN



X.SRI	ST	R0,DDTRET		:SAVE RETURN ADDRESS
	LIS	R15,0			:RESET COUNT OF PASSES
	LA	RR,IRING,,		:SET UP FOR IRING
	LHI	RS,IRSIZE
	LH	R1,INFMI		:USE LAST ENTRY
	CLH	R1,NFMI,RR,		:ARE WE CAUGHT UP?
	JE	XSRIA4			:IF SO
	JAL	R10,BEGMSG		:GUESS AT FIRST MESSAGE
	LHL	R3,RING,R1,RR		:GET PORT #
	TBT	R3,PFILT,,		:DOES THIS PORT GET THROUGH THE FILTER?
	JN	XSRI70			:IF SO
	JAL	R0,SKPDSP		:SKIP DISPLAY
	J	XSRI90			:CONTINUE

XSRI70	SVC	0B,M.CRLF,,		:NEW LINE
	LR	R15,R15			:FIRST PASS?
	JNFS	XSRI75			:IF NOT
	SVC	0B,M.RI,,		:TELL WHO WE ARE
XSRI75	AIS	R15,1			:BUMP COUNT OF PASSES
	SVC	0B,M.I,,		:OUTPUT "I "
	JAL	R0,RNGDSP		:DISPLAY MESSAGE

XSRI90	AIS	R1,3			:ROUND UP TO FULL WORD
	NHI	R1,-4			:AND I.E., NEXT MESSAGE
	CR	R1,RS			:TO END OF RING ??
	JLFS	XSRIA0			:IF NOT
	LIS	R1,0			:FOLD TO START OF RING	:DRE 4-JAN-84
XSRIA0	CLH	R1,NFMI,RR		:CAUGHT UP ?
	JE	XSRIA4			:IF SO
	LHL	R3,RING,R1,RR		:GET PORT #
	:changes begin here to fix illegal instruction crash due to ring
	:wrapped.						:LSH 30-JUN-87
	CLHI	R3,NDPORT		:CHECK IF IT IS A RIGHT PORT #
	JL	XSRIA5			:YES
	JAL	R10,BEGCON		:GUESS AT NEXT MESSAGE
	LHL	R3,RING,R1,RR		:GET PORT NUMBER
	:changes end here					:LSH 30-JUN-87
XSRIA5	TBT	R3,PFILT,,		:DOES THIS PORT GET THROUGH THE FILTER?
	JN	XSRIA2			:IF SO
	JAL	R0,SKPDSP		:SKIP DISPLAY
	J	XSRI90			:CONTINUE

XSRIA2	SVC	0B,M.CRLF,,		:CR LF
	LR	R15,R15			:FIRST PASS?
	JNFS	XSRIA3			:IF NOT
	SVC	0B,M.RI,,		:TELL WHO WE ARE
XSRIA3	AIS	R15,1			:BUMP COUNT OF PASSES
	SVC	0B,M.I,,		:OUTPUT "I "
	JAL	R0,RNGDSP		:DISPLAY MESSAGE
	J	XSRI90

XSRIA4	STH	R1,INFMI		:SAVE IRING POINTER
	L	R0,DDTRET		:GET RETURN ADDRESS
	JR	R0

RNGDSP	ST	R0,RDSAV		:SAVE RETURN
	LB	R2,RING+2,R1,RR		:GET MESSAGE CODE
	LHL	R3,RING,R1,RR		:GET PORT #
	JE	RNGDC0			:IF INTRANODE MESSAGE
	LR	R2,R2			:CHECK FOR NEEDLE
	JE	RNGDF0			:IF SO
	CLHI	R2,9E			:DATA MESSAGE ??
	JL	RNGDB0			:IF SO
	SHI	R2,9E			:BIAS TO 0
	CLHI	R2,L.ISCT		:CHECK MAX MSG TYPE
	JLE	RNGDA9			:IF OK
	LHI	R2,L.ISCT+1		:GET "UNDEFINED" MESSAGE
RNGDA9	LA	R4,,R2,R2		:FOR INDEXING
	SVC	0B,XDRICA,R4,R4		:ASCII MESSAGE LABEL
	JAL	R10,XSRISB		:GO DUMP ISIS CONTROL MESSAGE
	J	RNGDFF			:GO TO NEXT MESSAGE
RNGDB0	SVC	0B,XDRMS3,,		:"DATA" MESSAGE HEADER
	JAL	R10,XSRISA		:GO DUMP ISIS DATA MSG
	J	RNGDFF			:GO TO NEXT MESSAGE
RNGDC0	CLHI	R2,MAXINM		:CHECK MAX MSG TYPE
	JLE	RNGDC1			:IF OK
	LHI	R2,MAXINM+1		:GET "UNDEFINED" MESSAGE
RNGDC1	LA	R4,,R2,R2		:FOR INDEXING
	SVC	0B,XDRICB,R4,R4		:ASCII MESSAGE LABEL
	TBT	R2,XDRVL,,		:VARIABLE LENGTH MESSAGE ??
	JNFS	RNGDD0			:IF SO BECAUSE CAN'T HANDLE YET
	JAL	R10,XSRISC		:GO DUMP ISIS INTRANODE MESSAGE
	J	RNGDFF			:GO TO NEXT MESSAGE
RNGDD0	CLHI	R2,8			:AUX CIRCUIT REQUEST ??
	JN	RNGDE0			:MUST BE "1-DOWN"
	LA	R4,0A,R1		:STEP TO SIZE BYTE
	CR	R4,RS			:CHECK FOR WRAP AROUND
	JLFS	RNGDD4			:IF NOT
	SR	R4,RS			:IF SO
RNGDD4	LB	R6,RING,RR,R4		:GET VARIABLE STRING SIZE
	AIS	R6,0B			:ADD CONSTANT PORTION
	LHI	R0,20			:INSERT A SPACE
	SVC	KIO,0E
	JAL	R10,XSRISE		:TO PUT OUT MESSAGE
	J	RNGDFF
RNGDE0	LA	R4,5,R1			:STEP TO 1-DOWN STRING SIZE
	C	R4,RS			:CHECK FOR WRAP AROUND		:DRE 4-JAN-84
	JLFS	RNGDE4			:IF NOT
	SR	R4,RS			:IF SO			:DRE 4-JAN-84
RNGDE4	LB	R6,RING,RR,R4		:GET VARIABLE MESSAGE SIZE
	AIS	R6,6			:ADD FIXED MESSAGE LENGTH
	LHI	R0,20			:INSERT A SPACE
	SVC	KIO,0E
	JAL	R10,XSRISE		:TO PUT OUT MESSAGE
	J	RNGDFF			:TO CONTINUE
RNGDF0	SVC	0B,XDRMS4,,		:NEEDLE MESSAGE
	LB	R6,RING+3,R1,RR		:GET ADDITIONAL LENGTH
	AIS	R6,4			:ADD FIXED PORTION
	LHI	R0,20			:INSERT A BLANK
	SVC	KIO,0E			:PUT IT OUT
	JAL	R10,XSRISE		:TO PUT REST OF MESSAGE
RNGDFF	L	R0,RDSAV		:GET RETURN ADDRESS
	JR	R0

:	R1 - RING INDEX
:	R2 - MSG CODE TYPE
:	RS - RING SIZE
:	RR - RING START

:	DATA MESSAGE
XSRISA	LA	R6,3,R2			:MESSAGE LENGTH=MESSAGE TYPE+3
	LHI	R0,20			:INSERT A SPACE
	SVC	KIO,0E			:LETS BE TIDY
	J	XSRISE
:	CONTROL MESSAGE
XSRISB	LB	R6,XDRILA,R2,		:MESSAGE LENGTH FROM TABLE
	LHI	R0,20			:INSERT A SPACE
	SVC	KIO,0E
	J	XSRISE
:	INTRANODE MESSAGE TYPE
XSRISC	LB	R6,XDRILB,R2,		:MESSAGE LENGTH FROM TABLE
	LHI	R0,20			:INSERT A SPACE
	SVC	KIO,0E
	JFS	XSRISE
XSRISD	SVC	0B,XDRASC,,		:ASCII EQUIVALENT OF LINE
	SVC	0B,M.CRLF,,		:NEW LINE
	SVC	0B,XDRMS5,,		:4 BLANKS FOR ALIGNMENT
XSRISE	LIS	R7,0			:LINE LENGTH COUNTER
XSRISF	LB	R5,RING,R1,RR		:NEXT BYTE FROM RING
	LHI	R0,20			:DEFAULT BLANK CHARACTER
	TBT	R5,XDRECH,,		:PRINTABLE ??
	JEFS	XSRISH			:IF NOT, USE BLANK
	LR	R0,R5			:ELSE IF OK TO PRINT IT
XSRISH	LR	R4,R7			:COMPUTE WHERE TO PLUG INTO LINE
	NHI	R4,0F			:16 BYTES PER LINE
	STB	R0,XDRASC+4,R4,		:PUT 'ER THERE
	LR	R3,R1			:SAVE POINTER
	LR	R0,R5			:GET CHARACTER
	LHI	R1,250			:FIELD WIDTH OF 2, ZERO FIELD FILL
	SVC	KIO,0A			:OUTPUT TO TTY
	LR	R1,R3			:RESTORE POINTER
	AIS	R1,1			:BUMP RING INDEX
	CR	R1,RS			:END OF RING ??
	JLFS	XSRISG			:IF NOT
	LIS	R1,0			:FOLD TO RING START	:DRE 4-JAN-84
XSRISG	AIS	R7,1			:LINE LENGTH
	CLH	R1,NFMI,RR		:SEE IF AT RING POINTER
	JE	XSRISI			:IF SO GET OUT
	SIS	R6,1			:CHECK FOR END OF MSG
	JLE	XSRISI			:FINISH BLANKING AND PRINT	
	THI	R7,0F			:END OF LINE
	JE	XSRISD			:IF SO
	THI	R7,1			:END OF HALFWORD
	JN	XSRISF			:IF NOT TO CONTINUE
	LHI	R0,20			:ADD A SPACE
	SVC	KIO,0E			:TO FORMAT WORDS
	J	XSRISF
XSRISI	LHI	R0,20			:BLANK
XSRISJ	NHI	R7,0F			:LINE LENGTH OF 16
	JEFS	XSRISK			:IF TO END OF LINE
	STB	R0,XDRASC+4,R7,		:PUT IN A BLANK
	AIS	R7,1			:COUNT ON UP
	JBS	XSRISJ			:AND SEE IF DONE
XSRISK	SVC	0B,XDRASC,,		:PUT IT OUT
	JR	R10			:DONE

SKPDSP	ST	R0,RDSAV		:SAVE RETURN
	LB	R2,RING+2,R1,RR		:GET MESSAGE CODE
	LHL	R3,RING,R1,RR		:GET PORT #
	JE	SKPDC0			:IF INTRANODE MESSAGE
	LR	R2,R2			:CHECK FOR NEEDLE
	JE	SKPDF0			:IF SO
	CLHI	R2,9E			:DATA MESSAGE ??
	JL	SKPDB0			:IF SO
	SHI	R2,9E			:BIAS TO 0
	CLHI	R2,L.ISCT		:CHECK MAX MSG TYPE
	JLE	SKPDA9			:IF OK
	JAL	R10,BEGCON		:GUESS AT NEXT MESSAGE
	JR	R0			:RETURN

SKPDA9	LB	R6,XDRILA,R2,		:GET MESSAGE LENGTH
	J	SKPDFE			:GO TO NEXT MESSAGE

SKPDB0	LA	R6,3,R2			:MESSAGE LENGTH IS MESSAGE TYPE+3
	J	SKPDFE			:GO TO NEXT MESSAGE

SKPDC0	CLHI	R2,MAXINM		:CHECK MAX MSG TYPE
	JLE	SKPDC1			:IF OK
	JAL	R10,BEGCON		:LOOK FOR NEXT MESSAGE
	JR	R0			:RETURN

SKPDC1	TBT	R2,XDRVL,,		:VARIABLE LENGTH MESSAGE ??
	JNFS	SKPDD0			:IF SO BECAUSE CAN'T HANDLE YET
	LB	R6,XDRILB,R2,		:GET MESSAGE LENGTH
	J	SKPDFE			:GO TO NEXT MESSAGE

SKPDD0	CLHI	R2,8			:AUX CIRCUIT REQUEST ??
	JN	SKPDE0			:MUST BE "1-DOWN"
	LA	R4,0A,R1		:STEP TO SIZE BYTE
	CR	R4,RS			:CHECK FOR WRAP AROUND
	JLFS	SKPDD4			:IF NOT
	SR	R4,RS			:IF SO
SKPDD4	LB	R6,RING,RR,R4		:GET VARIABLE STRING SIZE
	AIS	R6,0B			:ADD CONSTANT PORTION
	J	SKPDFE			:TO CONTINUE

SKPDE0	LA	R4,5,R1			:STEP TO 1-DOWN STRING SIZE
	CR	R4,RS			:CHECK FOR WRAP AROUND	:DRE 4-JAN-84
	JLFS	SKPDE4			:IF NOT
	SR	R4,RS			:IF SO			:DRE 4-JAN-84
SKPDE4	LB	R6,RING,RR,R4		:GET VARIABLE MESSAGE SIZE
	AIS	R6,6			:ADD FIXED MESSAGE LENGTH
	J	SKPDFE			:TO CONTINUE

SKPDF0	SVC	0B,XDRMS4,,		:NEEDLE MESSAGE
	LB	R6,RING+3,R1,RR		:GET ADDITIONAL LENGTH
	AIS	R6,4			:ADD FIXED PORTION

SKPDFE	AR	R1,R6			:GO TO MESSAGE END
	CR	R1,RS			:PAST END OF RING?
	JL	SKPDFF			:IF NOT
	SR	R1,RS			:ADJUST INDEX
SKPDFF	L	R0,RDSAV		:GET RETURN ADDRESS
	JR	R0

:	PACKET AND FRAME TRACE



:	PACKET TRACE TABLE
X.SP	ST	R0,DDTRET		:SAVE RETURN ADDRESS
	LIS	R15,0			:RESET COUNT OF PASSES
P.S010	LH	R6,P.PTR		:OUR PACKET TRACE PTR
	CLH	R6,PTRINP,,		:SAME AS INTERFACE ??
	JNFS	P.S020			:IF NOT
	L	R0,DDTRET		:GET RETURN ADDRESS
	JR	R0

P.S020	LB	R4,PTRTBL+1,R6,		:GET LINK NUMBER
	TBT	R4,LFILT		:ARE WE DISPLAYING THIS LINK?
	JEFS	P.S030			:IF NOT
	LH	R7,PTRTBL+2,R6,		:GET CHANNEL NUMBER
	NHI	R7,0FFF			:MASK OFF GFI		:DRE 10-DEC-84
	TBT	R7,CFILT,,		:ARE WE DISPLAYING THIS CHANNEL?
	JN	P.S050			:IF SO
P.S030	AIS	R6,6			:ASSUME MOD 8
	TBT	R4,P128.F		:TEST FOR MOD 128	:DRE 10-DEC-84
	JEFS	P.S035			:JUMP IF NOT
	AIS	R6,2			:SET UP FOR MOD 128
P.S035	CLHI	R6,PTRLEN		:ARE WE AT END OF TABLE?
	JLFS	P.S040			:IF NOT
	LIS	R6,0						:DRE 10-DEC-84
P.S040	STH	R6,P.PTR		:SAVE POINTER
	J	P.S010			:TRY AGAIN

P.S050	LR	R15,R15			:FIRST PASS?
	JNFS	P.S060			:IF NOT
	SVC	0B,M.PT,,		:TELL WHO WE ARE
P.S060	AIS	R15,1			:BUMP COUNT OF PASSES
	SVC	0B,P.CRLF,,		:PUT P HEADER
	LB	R4,PTRTBL+1,R6,		:GET LINK # OF NEXT ENTRY
	STB	R4,XTLINK		:SAVE LINK #
	LIS	R7,6			:ASSUME 6 BYTES FOR MOD 8
	TBT	R4,P128.F		:SEE IF REALLY MOD 8	:DRE 10-DEC-84
	JEFS	P.S065			:IF SO
	LIS	R7,8			:8 BYTES/ENTRY FOR MOD 128
P.S065	LIS	R8,0			:INIT BYTE POSITION POINTER
  IF	DDTDIA-2						:DRE 25-AUG-86
	AIS	R7,2			:ALLOW FOR EXTENDED TIME STAMP
  EI
P.S070	LB	R0,PTRTBL,R6,		:GET BYTE OF TRACE TABLE
	LR	R5,R0
	LHI	R1,250			:FIELD WIDTH OF 2, ZERO FIELD FILL
	SVC	KIO,0A			:OUTPUT TO TTY
	THI	R7,1			:EVERY OTHER BYTE, PUT OUT EXTRA SPACE
	JEFS	P.S075			:IF EVEN
	LHI	R0,0A0			:GET SPACE
	SVC	KIO,0E			:PUT IT OUT TO TTY
P.S075	CLHI	R8,L.SPBY
	JGFS	P.S080			:IF BEYOND INTERPRETATION
	LH	R3,SPBYTE,R8,R8		:FIND ROUTINE TO INTERPRET BYTE
	J	SPBYTE,R3,		:GO INTERPRET BYTE

P.S080	AIS	R6,1			:ADVANCE OUR PTR
	AIS	R8,1			:INCREMENT BYTE POSITION POINTER
	SIS	R7,1			:DECREMENT ENTRY LENGTH COUNT
	JN	P.S070			:CONTINUE
	CLHI	R6,PTRLEN		:END OF TRACE TABLE ??
	JLFS	P.S090			:IF NOT
	LIS	R6,0			:WRAP TO START
P.S090	STH	R6,P.PTR		:SAVE OUR UPDATED PTR
	SVC	0B,MSGSPC,,		:PRINT INTERPRETATION
	STB	R7,MSGSPC,,		:RESET MESSAGE LENGTH
	J	P.S010			:START NEW PACKET ENTRY


:	PACKET INTERPRETATION ROUTINES
PSBYT0	LA	R1,M.IN,,		:INIT WITH "IN" MESSAGE
	CLHI	R5,80			:SEE IF OUT MESSAGE
	JLFS	PSB010			:IF NOT
	LA	R1,M.OUT,,		:SET WITH "OUT" MESSAGE
PSB010	JAL	R4,MSGMV		:MOVE MESSAGE TO STORAGE
	NHI	R5,7			:GET LAST 3 BITS
	JE	P.S080			:IF NOTHING ELSE
	SIS	R5,1
	JN	P.S080			:IF LEVEL 1 PACKET
	LA	R1,M.ILL,,		:ILLEGAL PACKET
PSB020	JAL	R4,MSGMV		:STORE MESSAGE
	J	P.S080			:RETURN

PSBYT1	HS
  IF	NLINES-1
	LA	R1,M.LINE,,		:GET "LINE" MESSAGE
	JAL	R4,MSGMV		:MOVE TO STORE
     IF .GE.(NLINES,10)						:DRE 10-DEC-84
	LR	R4,R5			:COPY LINE #		:DRE 10-DEC-84
	SRLS	R4,4			:SHIFT OFF LOWER NIBBLE	:DRE 10-DEC-84
	JE	PSBY11			:FITS IN ONE BYTE	:DRE 10-DEC-84
	LB	R4,SIAASC,R4,		:CONVERT CHARACTER TO ASCII:DRE 10-DEC-84
	STB	R4,M.2NUM+1,,		:SET CHARACTER INTO MESSAGE:DRE 10-DEC-84
	NHI	R5,0F			:MASK OFF UPPER NIBBLE	:DRE 10-DEC-84
	LB	R5,SIAASC,R5,		:CONVERT CHARACTER TO ASCII:DRE 10-DEC-84
	STB	R5,M.2NUM+2,,		:SET CHARACTER INTO MESSAGE:DRE 10-DEC-84
	LA	R1,M.2NUM,,		:GET NUMBER MESSAGE	:DRE 10-DEC-84
	JFS	PSBY12			:OUTPUT NUMBERS		:DRE 10-DEC-84
     EI
PSBY11	LB	R5,SIAASC,R5,		:CONVERT CHARACTER TO ASCII:DRE 10-DEC-84
	STB	R5,M.1NUM+1,,		:SET CHARACTER INTO MESSAGE:DRE 10-DEC-84
	LA	R1,M.1NUM,,		:GET NUMBER MESSAGE	:DRE 10-DEC-84
PSBY12	JAL	R4,MSGMV		:MOVE TO STORE		:DRE 10-DEC-84
  EI
	J	P.S080

PSBYT2	LBR	R3,R5			:GET A COPY OF BYTE	:DRE 10-DEC-84
	LHI	R9,020			:LOAD UP BLANK
	NHI	R5,0F			:MASK OFF GFI		:DRE 10-DEC-84
	JEFS	PSBY22			:IF CHANNEL NUMBER < 100:DRE 10-DEC-84
	LB	R9,SIAASC,R5,		:CONVERT THIRD DIGIT TO ASCII:DRE 10-DEC-84
PSBY22	STB	R9,M.3NUM+1,,		:SAVE RESULT FOR PSBYT3	:DRE 10-DEC-84
	NHI	R3,0F0			:GET LEFT NIBBLE	:DRE 10-DEC-84
	SRLS	R3,4						:DRE 10-DEC-84
	LBR	R5,R3			:GET COPY OF GFI	:DRE 10-DEC-84
	STB	R5,B1M128		:SAVE FOR LATER		:DRE 10-DEC-84
	LA	R9,M.UNGF,,		:GET UNIMPLEMENTED GFI MESSAGE:DRE 10-DEC-84
	CLHI	R3,3			:GENERAL FORMAT EXTENDER?:DRE 10-DEC-84
	JE	PSBY26			:YES, TELL US ABOUT IT	:DRE 10-DEC-84
	NHI	R5,3			:EXTRACT LOWER 2 BITS	:DRE 10-DEC-84
	JE	PSBY26			:NO MESSAGE IF "RESERVED FOR OTHER APPS":DRE 10-DEC-84
	LA	R9,M.ILGF,,		:COMPLAIN ABOUT ILLEGAL GFI MESSAGE:DRE 10-DEC-84
	CLHI	R5,3			:BAD GFI?		:DRE 10-DEC-84
	JNFS	PSBY28			:NO, SKIP PUMP OUT OF THE MESSAGE:DRE 10-DEC-84
PSBY26	JAL	R12,MSGMOV		:PUT OUT MESSAGE	:DRE 10-DEC-84
PSBY28	LA	R1,M.CHAN,,		:GET "CHAN" MESSAGE
	JAL	R4,MSGMV		:MOVE TO STORE
	J	P.S080						:DRE 10-DEC-84

PSBYT3	LBR	R3,R5			:GET CHARACTER
	NHI	R5,0F			:GET RIGHT NIBBLE
	NHI	R3,0F0			:GET LEFT NIBBLE
	SRLS	R3,4
	LB	R3,SIAASC,R3,		:CONVERT FIRST DIGIT TO ASCII
	LB	R5,SIAASC,R5,		:CONVERT SECOND DIGIT TO ASCII
	STB	R3,M.3NUM+2,,		:SAVE RESULT		:DRE 10-DEC-84
	STB	R5,M.3NUM+3,,		:SAVE RESULT 		:DRE 10-DEC-84
	LA	R1,M.3NUM,,		:GET CHANNEL NUMBER MESSAGE:DRE 10-DEC-84
	JAL	R4,MSGMV		:MOVE TO STORE
	J	P.S080

PSBYT4	LB	R3,B1M128		:GET SAVED GFI		:DRE 10-DEC-84
	LA	R9,M.LEV1,,		:LOAD UP Q-BIT MESSAGE	:DRE 10-DEC-84
	THI	R3,08			:CHECK FOR QBIT MESSAGE	:DRE 10-DEC-84
	JEFS	PSBY42			:NOT ON, SKIP MESSAGE	:DRE 10-DEC-84
	JAL	R12,MSGMOV		:PUT OUT MESSAGE	:DRE 10-DEC-84
PSBY42	LA	R9,M.DBIT,,		:GET D-BIT MESSAGE READY:DRE 10-DEC-84
	THI	R3,04			:CHECK FOR D-BIT	:DRE 10-DEC-84
	JEFS	PSBY44			:NOT ON			:DRE 10-DEC-84
	JAL	R12,MSGMOV		:PUT OUT MESSAGE	:DRE 10-DEC-84
PSBY44	LB	R3,XTLINK		:GET LINK #
	TBT	R3,P128.F		:SEE IF MOD 128		:DRE 10-DEC-84
	JEFS	PSBY46			:IF MOD 8
	STB	R5,B1M128		:SAVE FOR LATER
	J	P.S080			:GO ON

PSBY46	LBR	R3,R5			:SAVE BYTE
	NHI	R3,0F			:GET RIGHT DIGIT
	CLHI	R3,L.SPTYP		:RANGE CHECK
	JG	P.S080			:NOT IN THE TABLE
	LH	R4,SPTYPE,R3,R3		:GET ROUTINE TO HANDLE TYPE
	J	SPTYPE,R4,,

PSBYT5	LB	R3,XTLINK		:GET LINK #
	TBT	R3,P128.F		:SEE IF MOD 128		:DRE 10-DEC-84
	JE	PSBY75			:IF NOT
	STB	R5,B2M128		:SAVE FOR LATER
	LB	R5,B1M128		:GET TYPE BYTE
	J	PSBY46

PSBYT6	J	P.S080

PSBYT7	LB	R3,XTLINK		:GET LINK #
	TBT	R3,P128.F		:SEE IF MOD 128		:DRE 10-DEC-84
	JE	PSBYT9			:IF NOT
PSBY75	CLHI	R5,L.PCHS		:RANGE CHECK
	JG	P.S080			:NOT IN THE TABLE
	LH	R1,PCHST,R5,R5		:GET CHANNEL STATE MESSAGE ADDRESS
	AI	R1,PCHST		:UNBIAS
	JAL	R4,MSGMV		:MOVE TO STORE
	J	P.S080

PSBYT8	HS
PSBYT9	J	P.S080

PSDATA	LB	R2,XTLINK		:GET LINK #
	TBT	R2,P128.F		:SEE IF MOD 128		:DRE 10-DEC-84
	JE	PSDA30			:IF MOD 8

	SRLS	R5,1			:CONVERT TO P(S)
	LBR	R2,R5
	NHI	R5,0F			:GET RIGHTMOST DIGIT
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII
	STB	R5,M.DATE+0C,,		:STORE IN MESSAGE
	SRLS	R2,4			:GET LEFT DIGIT
	JEFS	PSDA10			:SUPRESS LEADING ZERO
	LB	R2,SIAASC,R2,		:CONVERT TO ASCII
PSDA10	STB	R2,M.DATE+0B,,		:STORE IN MESSAGE
	LB	R5,B2M128		:GET FOURTH BYTE
	SRLS	R5,1			:CONVERT TO P(R)
	LBR	R2,R5
	NHI	R5,0F			:GET RIGHTMOST DIGIT
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII
	STB	R5,M.DATE+8,,		:STORE IN MESSAGE
	SRLS	R2,4			:GET LEFT DIGIT
	JEFS	PSDA20			:SUPRESS LEADING ZERO
	LB	R2,SIAASC,R2,		:CONVERT TO ASCII
PSDA20	STB	R2,M.DATE+7,,		:STORE IN MESSAGE
	LA	R1,M.DATE,,		:POINT TO EXTENDED I-FRAME MESSAGE
	JAL	R4,MSGMV		:MOVE TO STORE
	J	P.S080			:GO BACK

PSDA30	SRHLS	R3,1			:DETERMINE P(S)
	SRHLS	R5,5			:DETERMINE P(R)
	AHI	R3,30			:CONVERT TO ASCII
	AHI	R5,30			:CONVERT TO ASCII
	STB	R5,M.DATA+7,,		:PUT INTO DATA MESSAGE
	STB	R3,M.DATA+0A,,		:PUT INTO DATA MESSAGE
	LA	R1,M.DATA,,		:GET DATA MESSAGE
	JAL	R4,MSGMV		:MOVE TO STORE
	J	P.S080

PSGEN	CLHI	R5,0F0
	JL	PSGN10			:IF DIAG, RESTART, OR RESTART CONF.
	SRHLS	R5,1			:DIVIDE BY 2		:DRE 29-JAN-85
	NHI	R5,7			:JUST GET 3 BITS	:DRE 29-JAN-85
	LH	R4,PGTF,R5,R5		:GET MESSAGE ADDRESS
	JE	P.S080			:GET OUT IF NONE
	LI	R1,PGTF,R4		:GET FULL ADDRESS
	J	PSGN20			:GO MOVE MESSAGE

PSGN10	SRHLS	R5,2			:DIVIDE BY 4
	LH	R4,PGTB,R5,R5		:GET MESSAGE ADDRESS
	JE	P.S080			:GET OUT IF NONE
	LI	R1,PGTB,R4		:GET FULL ADDRESS
PSGN20	JAL	R4,MSGMV		:MOVE MESSAGE
	J	P.S080

PSRR	LA	R1,M.RR,,		:GET RR MESSAGE
	JFS	PSRJ10

PSRNR	LA	R1,M.RNR,,		:GET RNR MESSAGE
	JFS	PSRJ10

PSREJ	LA	R1,M.REJ,,		:GET REJ MESSAGE
PSRJ10	JAL	R4,MSGMV		:MOVE TO STORE
	LB	R2,XTLINK		:GET LINK #
	TBT	R2,P128.F		:SEE IF MOD 128		:DRE 10-DEC-84
	JE	PSRJ30			:IF MOD 8

	LB	R2,B2M128		:GET N(R) SAVED FROM BEFORE
	LBR	R5,R2
	SRLS	R5,1			:CONVERT TO N(S)
	NHI	R5,0F			:GET RIGHTMOST DIGIT
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII
	STB	R5,M.2NUM+2,,		:PUT INTO MESSAGE	:DRE 10-DEC-84
	SRLS	R2,5			:GET LEFT DIGIT
	JEFS	PSRJ20			:SUPPRESS LEADING ZERO
	LB	R2,SIAASC,R2,		:CONVERT TO ASCII
PSRJ20	STB	R2,M.2NUM+1,,		:PUT INTO MESSAGE	:DRE 10-DEC-84
	LA	R1,M.2NUM,,		:POINT TO MESSAGE	:DRE 10-DEC-84
	JAL	R4,MSGMV		:MOVE TO STORE
	J	P.S080			:GO BACK

PSRJ30	SRHLS	R5,5			:CONVERT TO P(R)
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII
	STB	R5,M.1NUM+1,,		:PUT INTO MESSAGE
	LA	R1,M.1NUM,,		:POINT TO NUMBER MESSAGE
	JAL	R4,MSGMV		:MOVE TO STORE
	J	P.S080			:RETURN

:	FRAME TRACE TABLE
X.SF	ST	R0,DDTRET		:SAVE RETURN ADDRESS
	LIS	R15,0			:RESET COUNT OF PASSES
F.S010	LHL	R6,F.PTR		:GET OUR FRAME TRACE PTR
	CLH	R6,FTRINP,,		:SAME AS INTERFACE PTR ??
	JNFS	F.S012			:IF FRAME TRACE NOT CAUGHT UP
	L	R0,DDTRET		:GET RETURN ADDRESS
	JR	R0

F.S012	LB	R0,FTRTBL,R6,		:LINK # OF THIS ENTRY
	NHI	R0,37			:MASK OFF JUNK
	TBT	R0,LFILT		:ARE WE DISPLAYING THIS LINK?
	JN	F.S020			:IF SO
	AIS	R6,4			:ASSUME MOD 8
	TBT	R0,F128.F		:CHECK FOR MOD 128	:DRE 10-DEC-84
	JEFS	F.S013			:MOD 8
	AIS	R6,2			:MOD 128
F.S013	CLHI	R6,FTRLEN		:ARE WE PAST THE TABLE END?
	JLFS	F.S015			:IF NOT			:DRE 20-MAY-86
	LIS	R6,0			:RESET			:DRE 10-DEC-84
F.S015	STH	R6,F.PTR,,		:STORE UPDATED POINTER	:DRE 20-MAY-86
	J	F.S010						:DRE 20-MAY-86

F.S020	LR	R15,R15			:FIRST PASS?
	JNFS	F.S030			:IF NOT
	SVC	0B,M.FT,,		:TELL WHO WE ARE
F.S030	AIS	R15,1			:BUMP COUNT OF PASSES
  IF	FML
	LIS	R7,6			:6 BYTE ENTRIES FOR FML
  ELSE
	SVC	0B,F.CRLF,,		:PUT F HEADER
	STB	R0,XTLINK		:SAVE LINK #
	LIS	R7,4			:4 BYTES FOR MOD 8
	TBT	R0,F128.F		:TEST IF LINK MOD 128	:DRE 10-DEC-84
	JEFS	F.S040			:IF SO
	LIS	R7,6			:6 BYTES PER ENTRY MOD 128
F.S040	HS
  IF	DDTDIA-2						:DRE 25-AUG-86
	AIS	R7,2			:ALLOW FOR EXTENDED TIME STAMP
  EI
  EI	FML
	LIS	R8,0			:INIT BYTE POINTER
F.S050	LB	R0,FTRTBL,R6,		:GET BYTE FROM TRACE TABLE
	CLHI	R8,L.SFBY		:RANGE CHECK
	JG	F.S070			:NOT IN THE TABLE
	LR	R5,R0
	LHI	R1,250			:FIELD WIDTH OF 2, ZERO FIELD FILL
	SVC	KIO,0A			:OUTPUT TO TTY
	THI	R7,1			:EVERY OTHER BYTE, PUT OUT EXTRA SPACE
	JEFS	F.S060			:IF EVEN
	LHI	R0,0A0			:GET SPACE
	SVC	KIO,0E			:PUT IT OUT TO TTY
F.S060	CLHI	R8,L.SFBY
	JGFS	F.S070			:IF BEYOND INTERPRETATION
	LH	R3,SFBYTE,R8,R8		:GET ROUTINE TO INTERPRET BYTE
	J	SFBYTE,R3,,		:GO INTERPRET BYTE

F.S070	AIS	R6,1			:ADVANCE OUR PTR
	AIS	R8,1			:INCREMENT BYTE POINTER
	SIS	R7,1			:DECREMENT ENTRY LENGTH COUNTER
	JN	F.S050			:CONTINUE SAME ENTRY
	CLHI	R6,FTRLEN		:TO END OF TABLE ??
	JLFS	F.S080			:IF NOT
	LIS	R6,0			:TO WRAP TO START OF TABLE
F.S080	STH	R6,F.PTR		:SAVE OUR PTR
	SVC	0B,MSGSPC,,		:PRINT INTERPRETATION
	STB	R7,MSGSPC,,		:RESET MESSAGE LENGTH
	J	F.S010			:START NEW FRAME ENTRY


:	FRAME INTERPRETATION ROUTINES

FSBYT0	LIS	R9,5
	STH	R9,XFTPF		:INIT TO FRAME COMING IN
	LA	R1,M.IN,,		:INIT WITH "IN" MESSAGE
	CLHI	R5,80			:SEE IF OUT MESSAGE
	JLFS	FSB010			:IF NOT
	LIS	R9,0
	STH	R9,XFTPF		:INDICATE FRAME GOING OUT
	LA	R1,M.OUT,,		:SET WITH "OUT" MESSAGE
FSB010	JAL	R4,MSGMV		:MOVE MESSAGE TO STORAGE
	NHI	R5,1F			:GET LAST 5 BITS
	STB	R5,FLN			:SAVE LINE NUMBER
  IF	.GE.(NLINES,2)						:DRE 10-DEC-84
	LA	R1,M.LINE,,		:GET "LINE" MESSAGE
	JAL	R4,MSGMV		:MOVE TO STORE
     IF	.GE.(NLINES,10)
	LBR	R9,R5			:GET RIGHTMOST DIGIT
	SRLS	R5,4			:GET LEFT DIGIT		:DRE 10-DEC-84
	JE	FSB012			:DO SINGLE DIGIT IF OK	:DRE 10-DEC-84
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII	:DRE 10-DEC-84
	STB	R5,M.2NUM+1,,		:PLACE INTO NUMBER MESSAGE:DRE 10-DEC-84
	LB	R9,SIAASC,R9,		:CONVERT CHARACTER TO ASCII
	STB	R9,M.2NUM+2,,		:PLACE INTO NUMBER MESSAGE:DRE 10-DEC-84
	LA	R1,M.2NUM,,		:GET NUMBER MESSAGE	:DRE 10-DEC-84
	JFS	FSB014			:OUTPUT MESSAGE
     EI
FSB012	LB	R5,SIAASC,R5,		:CONVERT CHARACTER TO ASCII:DRE 10-DEC-84
	STB	R5,M.1NUM+1,,		:SET CHARACTER INTO MESSAGE:DRE 10-DEC-84
	LA	R1,M.1NUM,,		:GET NUMBER MESSAGE	:DRE 10-DEC-84
FSB014	JAL	R4,MSGMV		:MOVE TO STORE
  EI
	J	F.S070

FSBYT1	STB	R5,XFTIS		:SAVE INTERFACE STATE
	J	F.S070

FSBYT2	HS
   IF	LAP!LAPB
	LB	R3,XFTIS		:GET INTERFACE STATE
	NHI	R3,0F			:MASK OUT ERROR VALUE
	LB	R9,FLN			:GET LINE NUMBER
	CLB	R5,PADRT,R9,		:SEE IF PRIMARY (RESPONSE) ADDRESS
	JE	FSB210			:IF PRIMARY ADDRESS
	CLB	R5,SADRT,R9,		:SEE IF SECONDARY (COMMAND) ADDRESS
	JN	F.S070			:IF NOT PRIMARY OR SECONDARY ADDRESS
	LHL	R9,XFTPF		:GET POLL/FINAL INDICATOR
	SIS	R9,6			:REVERSE FOR SECONDARY
	XHI	R9,0FFFF
	STH	R9,XFTPF
      IF	LAP
	AIS	R3,8			:ADD BIAS FOR SECONDARY
      ELSE
	AIS	R3,7			:ADD BIAS FOR SECONDARY
      EI	LAP
FSB210	HS
      IF	LAP
	CLHI	R3,L.LAPI
	JG	F.S070			:IF INTERFACE STATE OUT OF RANGE
	LH	R9,LAPIST,R3,R3		:GET LAP INTERFACE STATE MESSAGE ADDRESS
	LI	R1,LAPIST,R9		:GET FULL ADDRESS
      ELSE
	CLHI	R3,L.LABI
	JG	F.S070			:IF INTERFACE STATE OUT OF RANGE
	LH	R9,LABIST,R3,R3		:GET LAPB INTERFACE STATE MESSAGE ADDRESS
	LI	R1,LABIST,R9		:GET FULL ADDRESS
      EI	LAP
	JAL	R4,MSGMV		:MOVE STATE MESSAGE TO STORE
   ELSE
   EI	LAP!LAPB
	J	F.S070

FSBYT3	HS
  IF	LAP!LAPB
	LB	R2,XTLINK		:GET LINK #
	TBT	R2,F128.F		:SEE IF MOD 128		:DRE 10-DEC-84
	JEFS	FSB330			:IF MOD 8
	STB	R5,B1M128		:SAVE TYPE FOR LATER
	J	F.S070			:GO BACK
FSB330	LBR	R11,R5
	SRLS	R11,4			:GET LEFT DIGIT
	NHI	R5,0F			:GET RIGHTMOST DIGIT ONLY 	
	LH	R9,FSTYPE,R5,R5		:GET ROUTINE ADDRESS
	J	FSTYPE,R9,,
  ELSE
	J	F.S070
  EI	LAP!LAPB

FSBYT4	HS
  IF	LAP!LAPB
	LB	R2,XTLINK		:GET LINK #
	TBT	R2,F128.F		:SEE IF MOD 128		:DRE 10-DEC-84
	JEFS	FSBYT5			:IF MOD 8
	STB	R5,B2M128		:SAVE FOR LATER
	LB	R5,B1M128		:GET TYPE
	J	FSB330			:GO PROCESS TYPE
  ELSE
	J	F.S070
  EI	LAP!LAPB

FSBYT5	HS
FSBYT6	HS
FSBYT7	J	F.S070

FSQUES	LA	R1,M.QUES,,		:LOAD UP ILLEGAL TYPE MSG :DRE 28-APR-86
	JAL	R4,MSGMV		:MOVE TO STORE
	J	FSBRJ4			:TAKE CARE OF P/F BIT	:DRE 28-APR-86

FSBRR	LA	R1,M.RR,,		:POINT TO RR MESSAGE
	JFS	FSBRJ0						:DRE 10-DEC-84

FSBRNR	LA	R1,M.RNR,,		:POINT TO RNR MESSAGE
	JFS	FSBRJ0						:DRE 10-DEC-84

FSBREJ	LA	R1,M.REJ,,		:POINT TO REJ MESSAGE
FSBRJ0	JAL	R4,MSGMV		:MOVE TO STORE
	LB	R5,XTLINK		:GET LINK #
	TBT	R5,F128.F		:SEE IF MOD 128		:DRE 10-DEC-84
	JE	FSBRJ2			:IF MOD 8
	LB	R11,B2M128		:GET N(R) SAVED FROM BEFORE
	LBR	R5,R11
	SRLS	R5,1			:CONVERT TO N(S)
	NHI	R5,0F			:GET RIGHTMOST DIGIT
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII
	STB	R5,M.2NUM+2,,		:PUT INTO MESSAGE	:DRE 10-DEC-84
	SRLS	R11,5			:GET LEFT DIGIT
	JE	FSBRJ3			:SUPPRESS LEADING ZERO	:DRE 10-DEC-84
	LB	R11,SIAASC,R11,		:CONVERT TO ASCII
FSBRJ1	STB	R11,M.2NUM+1,,		:PUT INTO MESSAGE	:DRE 10-DEC-84
	LA	R1,M.2NUM,,		:POINT TO MESSAGE	:DRE 10-DEC-84
	JAL	R4,MSGMV		:MOVE TO STORE
	JFS	FSBRJ4			:TAKE CARE OF P/F BIT	:DRE 10-DEC-84
FSBRJ2	LBR	R5,R11			:GET LEFT DIGIT
	SRLS	R5,1			:CONVERT TO N(R)
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII
FSBRJ3	STB	R5,M.1NUM+1,,		:PUT INTO MESSAGE	:DRE 10-DEC-84
	LA	R1,M.1NUM,,		:POINT TO NUMBER MESSAGE
	JAL	R4,MSGMV		:MOVE TO STORE
FSBRJ4	LB	R9,XTLINK		:GET LINK #		:DRE 10-DEC-84
	TBT	R9,F128.F		:SEE IF MOD 128		:DRE 10-DEC-84
	JEFS	FSBRJ5			:IF NOT
	LB	R11,B2M128		:GET BYTE SAVED FROM BEFORE
FSBRJ5	NHI	R11,1			:TEST P/F BIT
	JE	F.S070			:IF NOT SET
	LHL	R11,XFTPF		:GET POLL/FINAL MESSAGE DISPLACEMENT
	LA	R1,M.POLL,R11,		:POINT TO ADDRESS
	JAL	R4,MSGMV		:MOVE TO STORE
	J	F.S070

FSBSAM	LBR	R5,R11			:GET LEFT DIGIT
	NHI	R5,0E
	CLHI	R5,L.FSAM*2		:RANGE CHECK
	JG	FSQUES			:NOT IN TABLE		:DRE 28-APR-86
	LH	R5,FSAMTB,R5,		:GET APPROPRIATE MESSAGE DISPLACEMENT
	LI	R1,FSAMTB,R5		:GET MESSAGE ADDRESS
	JAL	R4,MSGMV		:MOVE TO STORE
	J	FSBRJ4			:TAKE CARE OF P/F BIT	:DRE 10-DEC-84
FSBDUA	LA	R1,M.UA,,		:POINT TO UA MESSAGE
	CLHI	R11,8			:SEE IF ILLEGAL		:DRE 28-APR-86
	JGE	FSQUES			:PUT OUT ILL MSG IF NOT	:DRE 28-APR-86
	CLHI	R11,6			:SEE IF UA
	JGEFS	FSBDU2			:IF SO
	CLHI	R11,4			:SEE IF DISC		:DRE 28-APR-86
	JL	FSQUES			:PUT OUT ILL MSG IF NOT	:DRE 28-APR-86
	LA	R1,M.DISC,,		:POINT TO DISC MESSAGE
FSBDU2	JAL	R4,MSGMV		:MOVE TO STORE
	J	FSBRJ4			:TAKE CARE OF P/F BIT	:DRE 10-DEC-84

FSBFRM	CLHI	R11,9			:REALLY A FRMR		:DRE 28-APR-86
	JG	FSQUES			:PUT OUT ILL MSG IF NOT	:DRE 28-APR-86
	CLHI	R11,8			:REALLY A FRMR		:DRE 28-APR-86
	JL	FSQUES			:PUT OUT ILL MSG IF NOT	:DRE 28-APR-86
	LA	R1,M.FRMR,,		:POINT TO FRAME REJECT MESSAGE
	JAL	R4,MSGMV		:MOVE TO STORE
	J	FSBRJ4			:TAKE CARE OF P/F BIT	:DRE 10-DEC-84

FSINFO	LB	R9,XTLINK		:GET LINK #
	TBT	R9,F128.F		:SEE IF MOD 128		:DRE 10-DEC-84
	JE	FSINF8			:IF MOD 8
	LB	R5,B1M128		:GET THIRD BYTE
	SRLS	R5,1			:CONVERT TO N(S)
	LBR	R11,R5
	NHI	R5,0F			:GET RIGHTMOST DIGIT
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII
	STB	R5,M.IFRE+0C,,		:STORE IN MESSAGE
	SRLS	R11,4			:GET LEFT DIGIT
	JEFS	FSINF1			:SUPRESS LEADING ZERO
	LB	R11,SIAASC,R11,		:CONVERT TO ASCII
FSINF1	STB	R11,M.IFRE+0B,,		:STORE IN MESSAGE
	LB	R5,B2M128		:GET FOURTH BYTE
	SRLS	R5,1			:CONVERT TO N(R)
	LBR	R11,R5
	NHI	R5,0F			:GET RIGHTMOST DIGIT
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII
	STB	R5,M.IFRE+8,,		:STORE IN MESSAGE
	SRLS	R11,4			:GET LEFT DIGIT
	JEFS	FSINF2			:SUPRESS LEADING ZERO
	LB	R11,SIAASC,R11,		:CONVERT TO ASCII
FSINF2	STB	R11,M.IFRE+7,,		:STORE IN MESSAGE
	LA	R1,M.IFRE,,		:POINT TO EXTENDED I-FRAME MESSAGE
	LB	R11,B2M128		:GET BYTE WITH P/F BIT
	J	FSINF9

FSINF8	SRLS	R5,1			:CONVERT RIGHTMOST DIGIT TO N(S)
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII
	STB	R5,M.IFRM+0A,,		:PUT DIGIT INTO I-FRAME MESSAGE
	LBR	R5,R11			:GET LEFT DIGIT
	SRLS	R5,1			:CONVERT LEFT DIGIT TO N(R)
	LB	R5,SIAASC,R5,		:CONVERT TO ASCII
	STB	R5,M.IFRM+7,,		:PUT DIGIT INTO I-FRAME MESSAGE
	LA	R1,M.IFRM,,		:POINT TO I-FRAME MESSAGE
FSINF9	JAL	R4,MSGMV		:MOVE TO STORE
	J	FSBRJ4			:TAKE CARE OF P/F BIT	:DRE 10-DEC-84

:	PACKET BUFFER TRACE TABLE

X.SPB	ST	R0,DDTRET		:SAVE RETURN ADDRESS
	LIS	R15,0			:RESET COUNT OF PASSES
	LH	R6,PB.PTR		:OUR PACKET TRACE PTR
SPBT00	CLH	R6,PBTINP,,		:SAME AS INTERFACE ??
	JNFS	SPBT10			:IF PACKET BUFFER TRACE NOT CAUGHT UP
	L	R0,DDTRET		:GET RETURN ADDRESS
	JR	R0

SPBT10	LB	R7,PBTTBL,R6,		:GET LINE NUMBER
	TBT	R7,LFILT		:ARE WE DISPLAYING THIS LINE?
	JE	SPBT50			:IF NOT
	LR	R8,R7			:COPY LINE NUMBER
	SRLS	R8,4			:GET FIRST DIGIT
	LB	R8,SIAASC,R8,		:CONVERT TO ASCII
	STB	R8,M.LINK+6,,		:SAVE IN LINK MESSAGE
	NHI	R7,0F			:GET SECOND DIGIT
	LB	R7,SIAASC,R7,		:GET SECOND DIGIT
	STB	R7,M.LINK+7,,		:SAVE IN LINK MESSAGE

	L	R13,PBTTBL,R6,		:GET ADDRESS OF BUFFER
	NI	R13,0FFFFFF		:MASK OFF LINK NUMBER
	CI	R13,RSC
	JL	SPBT50			:IF TOO SMALL FOR TABLE ENTRY
	LHL	R7,2,R13		:GET BYTE COUNT FROM BUFFER
	JE	SPBT50			:IF NOTHING IN BUFFER
	LHL	R8,4,R13		:GET GFI
	NHI	R8,0FFF			:MASK DOWN TO LCN
	TBT	R8,CFILT,,		:ARE WE DISPLAYING THIS CHANNEL?
	JE	SPBT50			:IF NOT
	LA	R1,M.LINK,,
	JAL	R4,MSGMV		:MOVE "LINK" TO MESSAGE STORE
	LR	R15,R15			:FIRST PASS?
	JNFS	SPBT15			:IF NOT
	SVC	0B,M.PB,,		:TELL WHO WE ARE
SPBT15	AIS	R15,1			:BUMP COUNT OF PASSES
	AIS	R7,4			:ADD HEADER LENGTH TO BYTE COUNT
	LIS	R8,0			:INIT BYTE POSITION POINTER
SPBT20	LIS	R1,2			:INIT FIELD WIDTH FOR NUMBER CONVERSION
	LB	R0,,R13,R8		:GET BYTE OF BUFFER
	JAL	R4,NUMMV,,		:CONVERT AND PRINT
	AIS	R8,1			:INCREMENT BYTE POSITION POINTER
	LR	R9,R8			:SEE IF NEED CR
	NHI	R9,0F			:CR ADDED AFTER 10x BYTES
	JN	SPBT30			:IF NOT
	CLHI	R7,1			:LAST BYTE?
	JE	SPBT40			:IF SO, DON'T BOTHER PREP FOR NEXT LINE
	LA	R1,M.CRLF,,		:POINT TO CRLF
	JAL	R4,MSGMV		:MOVE TO STORE
	SVC	0B,MSGSPC,,		:PRINT WHAT WE HAVE
	LIS	R3,0
	STB	R3,MSGSPC,,		:CLEAR OUT BYTE COUNT FOR NEXT MESSAGE
	JFS	SPBT35			:START NEXT LINE WITH BLANK FOR INDENTATION

SPBT30	NHI	R9,1			:ODD BYTE?
	JNFS	SPBT40			:IF NOT
SPBT35	LHI	R0,0A0			:GET SPACE CHARACTER
	JAL	R2,BYTMV		:MOVE TO STORE
SPBT40	SIS	R7,1			:DECREMENT ENTRY LENGTH COUNT
	JN	SPBT20			:CONTINUE
	LA	R1,M.CRLF,,		:END WITH CRLF
	JAL	R4,MSGMV		:MOVE TO STORE
	SVC	0B,MSGSPC,,		:PRINT INTERPRETATION
	STB	R7,MSGSPC,,		:RESET MESSAGE LENGTH
SPBT50	AIS	R6,4			:ADVANCE OUR PTR
	CLHI	R6,PBTLEN		:END OF TRACE TABLE ??
	JLFS	SPBT60			:IF NOT
	LIS	R6,0			:WRAP TO START
SPBT60	STH	R6,PB.PTR		:SAVE OUR UPDATED PTR
	J	SPBT00			:START NEW PACKET ENTRY


   IF HDLC
:	OUTPUT SECTOR TRACE TABLE

XSOSM	ST	R0,DDTRET		:SAVE RETURN ADDRESS
	LIS	R15,0			:REST COUNT OF PASSES
	LIS	R14,0			:INIT LINE NUMBER
XSOSM1	TBT	R14,LFILT		:ARE WE DISPLAYING THIS LINK?
	JE	XSOSM5			:IF NOT
	LIS	R13,0
	STB	R13,MSGSPC,,		:INIT MESSAGE SPACE
  IF	NLINES-1						:DRE 10-DEC-84
	LA	R1,M.LINE,,		:POINT TO LINE MESSAGE
	JAL	R4,MSGMV		:MOVE TO STORE
	LIS	R1,2			:SET FIELD WIDTH TO 2
	LR	R0,R14			:GET LINE NUMBER
	JAL	R4,NUMMV		:MOVE TO STORE
	LA	R1,M.EMPT,,		:POINT TO EMPTY SPACE
	JAL	R4,MSGMV		:MOVE TO STORE
  EI								:DRE 10-DEC-84
	LHL	R12,SECBIA,R14,R14,	:GET SECTOR BIAS
	SLLS	R12,2			:CONVERT WORD INDEX TO BYTE INDEX
	JAL	R13,XSOSLP		:GO PRINT SECTOR
XSOSM5	AIS	R14,1			:BUMP LINE NUMBER
	CLHI	R14,NLINES		:LINE NUMBER TOO BIG?
	JL	XSOSM1			:IF NOT
	L	R0,DDTRET		:GET RETURN ADDRESS
	JR	R0			:GO ON

:	SUBROUTINE TO GET SECTOR AND PRINT IT
:	R13 = LINK REGISTER
:	R14 = LINE NUMBER
:	R12 = SECTOR BIAS

XSOSLP	HS
	LB	R6,OSPTR,R14,		:OUR TRACE PTR
XSOSL1	CLB	R6,CURSEC,R14,		:SAME AS INTERFACE ??
	JER	R13			:RETURN IF PACKET BUFFER TRACE CAUGHT UP
	LR	R7,R6			:GET POINTER
	SLLS	R7,2			:CONVERT WORD INDEX TO BYTE INDEX
	L	R10,SECADR,R7,R12	:GET ADDRESS OF BUFFER
	LHL	R7,,R10			:GET BYTE COUNT FROM BUFFER
	JE	XSOSL8			:IF NOTHING IN BUFFER
	LHL	R8,4,R10,		:GET GFI
	NHI	R8,0FFF			:MASK DOWN TO LCN
	TBT	R8,CFILT,,		:ARE WE DISPLAYING THIS CHANNEL?
	JE	XSOSL8			:IF NOT
	LR	R15,R15			:FIRST PASS?
	JNFS	XSOSL2			:IF NOT
	SVC	0B,M.OS,,		:TELL WHO WE ARE
XSOSL2	AIS	R15,1			:BUMP COUNT OF PASSES
	AIS	R7,2			:ACCOUNT FOR HEADER
	LIS	R8,0			:INIT BYTE POSITION POINTER
XSOSL4	LIS	R1,2			:INIT FIELD WIDTH FOR NUMBER CONVERSION
	LB	R0,,R10,R8		:GET BYTE OF BUFFER
	JAL	R4,NUMMV,,		:CONVERT AND PRINT
	AIS	R8,1			:INCREMENT BYTE POSITION POINTER
	LR	R9,R8			:SEE IF NEED CR
	NHI	R9,0F
	JN	XSOSL5			:IF NOT
	CLHI	R7,1			:LAST BYTE?
	JE	XSOSL7			:IF SO
	LA	R1,M.CRLF,,		:POINT TO CRLF
	JAL	R4,MSGMV		:MOVE TO STORE
	SVC	0B,MSGSPC,,		:PRINT MESSAGE
	LIS	R3,0
	STB	R3,MSGSPC,,		:GO CLEAR BYTE COUNT
	JFS	XSOSL6			:START NEXT LINE WITH BLANK FOR INDENTATION

XSOSL5	NHI	R9,1			:ODD BYTE?
	JNFS	XSOSL7			:IF NOT
XSOSL6	LHI	R0,0A0			:GET SPACE CHARACTER
	JAL	R2,BYTMV		:MOVE TO STORE
XSOSL7	SIS	R7,1			:DECREMENT ENTRY LENGTH COUNT
	JN	XSOSL4			:CONTINUE
	LA	R1,M.CRLF,,		:END WITH CRLF
	JAL	R4,MSGMV		:MOVE TO STORE
	SVC	0B,MSGSPC,,		:PRINT INTERPRETATION
	STB	R7,MSGSPC,,		:RESET MESSAGE LENGTH
XSOSL8	AIS	R6,1			:ADVANCE OUR PTR
	CLB	R6,K.LT,R14,		:END OF TRACE TABLE ??
	JLFS	XSOSL9			:IF NOT
	LIS	R6,0			:WRAP TO START
XSOSL9	STB	R6,OSPTR,R14,		:SAVE OUR UPDATED PTR
	J	XSOSL1			:START NEW PACKET ENTRY

   EI HDLC


:	LIST ROUTINES THAT MAY BE CHOSEN

SELECT	SVC	0B,M.SINT,,		:ASK FOR SELECTION
	SVC	0B,M.3,,
	SVC	0B,M.4X,,		:LIST CHOICES
	SVC	0B,M.5,,
  IF	HDLC
	SVC	0B,M.121,,
  EI	HDLC
	SVC	0B,M.14,,
	SVC	0B,M.CRLF,,		:END WITH CRLF
	SVC	0B,M.CL,,		:AND COLON PROMPT

:	PROCESS REQUESTS AS THEY COME IN FROM THE TTY.  PLACE
:	REQUESTS IN TABLE REQTAB.  SAVE TABLE SIZE IN REQSIZ.

ROUTIN	LIS	R8,0			:ZERO OUT REQUEST TABLE INDEX
	LIS	R9,0			:ZERO OUT ACCUMULATOR
	SVC	0A,0010			:GET CHARACTER IN R0.  TIMEOUT IN 16 SEC
	J	DSTRT2			:TIMEOUT
	NHI	R0,7F			:STRIP OFF PARITY
	CLHI	R0,60			:UPPERCASE?
	JL	ROUT10			:IF SO
	SHI	R0,20			:CONVERT TO LOWER CASE
ROUT10	CLHI	R0,0D
	JE	ROUT60			:IF DONE
	TBT	R0,ALNUM,,
	JEFS	ROUT20			:IF NOT ALPHANUMERIC
	SLLS	R9,8			:MAKE ROOM IN ACCUMULATOR
	OHI	R0,80			:SET PARITY BIT
	OR	R9,R0			:SAVE CHARACTER IN ACCUMULATOR
	JFS	ROUT30

ROUT20	LR	R9,R9
	JEFS	ROUT30			:IF ACCUMULATOR EMPTY
	ST	R9,REQTAB,R8,		:SAVE REQUEST
	LIS	R9,0			:CLEAR ACCUMULATOR
	AIS	R8,4			:BUMP SAVE INDEX
ROUT30	SVC	0A,0010			:GET ANOTHER CHARACTER
	J	ROUT60			:IF TIMEOUT
	NHI	R0,7F			:STRIP PARITY
	CLHI	R0,60
	JLFS	ROUT40			:IF UPPERCASE
	SHI	R0,20			:CONVERT TO UPPERCASE
ROUT40	CLHI	R0,0D
	JE	ROUT50			:IF DONE
	TBT	R0,ALNUM,,
	JE	ROUT20			:IF NOT ALPHANUMERIC
	SLLS	R9,8			:MAKE ROOM IN ACCUMULATOR
	OHI	R0,80			:SET PARITY BIT
	OR	R9,R0			:SAVE CHARACTER IN ACCUMULATOR
	J	ROUT30

ROUT50	LR	R9,R9
	JEFS	ROUT60			:IF ACCUMULATOR EMPTY
	ST	R9,REQTAB,R8,		:SAVE REQUEST
	AIS	R8,4			:BUMP SAVE INDEX

ROUT60	STH	R8,REQSIZ		:SAVE REQUEST TABLE SIZE

:	TRY TO MATCH EACH REQUEST IN REQTAB WITH A ROUTINE NAME IN 
:	ROUTAB.  IF A MATCH IS FOUND, CONVERT THE REQUEST NAME TO
:	A ROUTINE ADDRESS.  IF NO MATCH IS FOUND, SKIP REQUEST.
:	UPDATE REQUEST TABLE SIZE REQSIZ.

SERCH	LIS	R8,0			:ZERO OUT REQUEST INDEX
	LIS	R9,0			:ZERO OUT SAVE INDEX
	STH	R9,REQFLG		:START REQUEST FLAGS FRESH 
SER10	CLH	R8,REQSIZ
	JE	SER40			:IF END OF REQUESTS
	L	R6,REQTAB,R8,		:GET REQUEST
	LIS	R10,0			:ZERO OUT INDEX INTO ROUTINE TABLE
SER20	L	R7,ROUTAB,R10,		:GET ROUTINE NAME
	CR	R6,R7			:SEE IF NAME MATCH
	JN	SER30			:IF NO MATCH
	LR	R5,R10			:GET ROUTINE INDEX
	SRLS	R5,1			:CONVERT TO INDEX BY HALFWORDS
	LH	R7,ROUTFL,R5,		:GET ROUTINE FLAGS
	OH	R7,REQFLG		:OR IN OLD FLAGS
	STH	R7,REQFLG		:SAVE FLAGS
	L	R7,ROUTAD,R10,		:GET ROUTINE ADDRESS
	ST	R7,REQTAB,R9,		:SAVE ROUTINE ADDRESS IN REQUEST TABLE
	AIS	R9,4			:BUMP SAVE INDEX
SER30	AIS	R10,4			:BUMP INDEX
	CHI	R10,ROUTSZ
	JL	SER20			:IF NOT AT END OF ROUTINE TABLE
	AIS	R8,4			:BUMP REQUEST INDEX
	J	SER10			:GET NEXT REQUEST

SER40	STH	R9,REQSIZ		:UPDATE REQUEST TABLE SIZE

:	CHECK THE FLAG BYTE REQFLG FOR ADDITIONAL INFORMATION 
:	NEEDED SUCH AS PORTS, LINES, AND CHANNELS.  ASK FOR
:	THE NECESSARY INFORMATION, PROCESS THE REPLIES, AND SET THE
:	APPROPRIATE FLAG BITS.

ADDATA	LH	R7,REQFLG		:GET FLAGS
	JE	SINIT			:IF NO ADDITIONAL INFORMATION NEEDED
	THI	R7,PFILBT		:PORTS FILTER ON?
	JE	ADLINE			:IF NOT, GO CHECK FOR LINE FILTER

:	ASK FOR PORTS TO BE DISPLAYED

ADPORT	LIS	R1,0			:RESET ALL BITS (NO PORTS DISPLAYED)
	LHI	R2,2*((MAXPRT+0F)/10)-2
ADP005	STH	R1,PFILT,R2,
	SIS	R2,2
	JGEBS	ADP005

	SVC	0B,M.PRTS,,		:ASK FOR PORTS
	LIS	R11,0			:ZERO OUT FLAG INDICATING IF ANY PORTS CHOSEN
ADP010	LI	R10,80000000		:INITIALIZE ACCUMULATOR
	SVC	0A,0110			:GET CHARACTER
	J	ADP050			:TIMEOUT
ADP020	NHI	R1,7F			:STRIP PARITY
	CLHI	R1,60			:UPPER CASE?
	JLFS	ADP025			:IF SO
	SHI	R1,20			:CONVERT TO UPPER CASE
ADP025	TBT	R1,HEXNUM,,		:SEE IF HEX DIGIT
	JEFS	ADP030			:IF NOT
	SHI	R1,30			:SCALE NUMBER DOWN
	LB	R0,ASC2HX,R1,		:CONVERT TO HEX
	SLLS	R10,4			:MAKE ROOM FOR DIGIT
	OR	R10,R0			:MOVE NEW DIGIT IN
	SVC	0A,0110			:GET CHARACTER
	J	ADP050			:IF TIMEOUT
	J	ADP020

ADP030	LR	R10,R10
	JL	ADP040			:IF ACCUMULATOR STILL IN INITIAL STATE
	CHI	R10,MAXPRT
	JG	ADP040			:IF TOO BIG
	SBT	R10,PFILT,,		:ROUTINES SHOULD LOOK FOR THIS PORT
	LIS	R11,1			:INDICATE A PORT SELECTED
	THI	R7,BFILBT		:ARE WE CHECKING BUFFERLETS?
	JE	ADP040			:IF NOT
	SBT	R10,BFILT,,		:SET DI BUFFER BIT
	LHI	R2,IDBIA/4		:CALCULATE ID BUFFER NUMBER
	AR	R2,R10	
	SBT	R2,BFILT,,		:SET ID BUFFER BIT
	LH	R3,DI.MT,R10,R10	:GET CORRESPONDING IPORT
	JL	ADP040			:IF NOT ASSIGNED
	LHI	R2,IECBIA/4		:CALCULATE IEC BUFFER NUMBER
	AR	R2,R3
	SBT	R2,BFILT,,		:SET IEC BUFFER BIT
	LHI	R2,IEDBIA/4		:CALCULATE IED BUFFER NUMBER
	AR	R2,R3
	SBT	R2,BFILT,,		:SET IED BUFFER BIT
	LHI	R2,FACBIA/4		:CALCULATE FAC BUFFER NUMBER
	AR	R2,R3
	SBT	R2,BFILT,,		:SET FAC BUFFER BIT
ADP040	CLHI	R1,0D
	JN	ADP010
ADP050	LR	R11,R11
	JN	ADLINE			:IF MARKER SET (SOME PORT WAS SELECTED)
	LCS	R1,1			:SET ALL BITS (ALL PORTS DISPLAYED)
	LHI	R2,2*((MAXPRT+0F)/10)-2
ADP055	STH	R1,PFILT,R2,
	SIS	R2,2
	JGEBS	ADP055

	THI	R7,BFILBT		:ARE WE CHECKING BUFFERS?
	JE	ADLINE			:IF NOT
	LHI	R2,NBGRPS		:DISPLAY ALL BUFFERS
ADP060	STH	R1,BFILT,R2,
	SIS	R2,2
	JGEBS	ADP060
	
:	ASK FOR LINES TO BE DISPLAYED

ADLINE	THI	R7,LFILBT		:LINES FILTER ON?
	JE	ADCHAN			:IF NOT, GO CHECK FOR CHANNEL FILTER
	LIS	R1,0			:INITIALIZE LINE FILTER ARRAY
	ST	R1,LFILT		:LOOK AT NO LINES

	SVC	0B,M.LINS,,		:ASK FOR LINES
	LIS	R11,0			:ZERO OUT FLAG INDICATING IF ANY LINES CHOSEN
ADL010	LI	R10,80000000		:INITIALIZE ACCUMULATOR
	SVC	0A,0110			:GET CHARACTER
	J	ADL050			:TIMEOUT
ADL020	NHI	R1,7F			:STRIP PARITY
	CLHI	R1,60			:UPPER CASE?
	JLFS	ADL025			:IF SO
	SHI	R1,20			:CONVERT TO UPPER CASE
ADL025	TBT	R1,HEXNUM,,		:SEE IF HEX DIGIT
	JE	ADL030			:IF NOT
	SHI	R1,30			:SCALE NUMBER DOWN
	LB	R0,ASC2HX,R1,		:CONVERT TO HEX
	SLLS	R10,4			:MAKE ROOM FOR DIGIT
	OR	R10,R0			:MOVE NEW DIGIT IN
	SVC	0A,0110			:GET CHARACTER
	J	ADL050			:IF TIMEOUT
	J	ADL020

ADL030	LR	R10,R10
	JLFS	ADL040			:IF ACCUMULATOR STILL IN INITIAL STATE
	CHI	R10,NLINES
	JGFS	ADL040			:IF TOO BIG
	SBT	R10,LFILT		:ROUTINES SHOULD LOOK FOR THIS LINE
	LIS	R11,1			:INDICATE A LINE SELECTED
ADL040	CLHI	R1,0D
	JN	ADL010
ADL050	LR	R11,R11
	JNFS	ADCHAN			:IF MARKER SET (SOME LINE WAS SELECTED)
	LCS	R1,1
	ST	R1,LFILT,,		:LOOK AT ALL LINES


:	ASK FOR CHANNELS TO BE DISPLAYED

ADCHAN	THI	R7,CFILBT		:CHANNELS FILTER ON?
	JE	SINIT			:IF NOT, GO RUN ROUTINES
	LIS	R1,0			:RESET ALL BITS (NO CHANNELS DISPLAYED)
	LHI	R2,2*((MAXCHN+0F)/10)-2
ADC005	STH	R1,CFILT,R2,
	SIS	R2,2
	JGEBS	ADC005

	SVC	0B,M.CHNS,,		:ASK FOR CHANNELS
	LIS	R11,0			:ZERO OUT FLAG INDICATING IF ANY CHANNELS CHOSEN
ADC010	LI	R10,80000000		:INITIALIZE ACCUMULATOR
	SVC	0A,0110			:GET CHARACTER
	J	ADC050			:TIMEOUT
ADC020	NHI	R1,7F			:STRIP PARITY
	CLHI	R1,60			:UPPER CASE?
	JLFS	ADC025			:IF SO
	SHI	R1,20			:CONVERT TO UPPER CASE
ADC025	TBT	R1,HEXNUM,,		:SEE IF HEX DIGIT
	JE	ADC030			:IF NOT
	SHI	R1,30			:SCALE NUMBER DOWN
	LB	R0,ASC2HX,R1,		:CONVERT TO HEX
	SLLS	R10,4			:MAKE ROOM FOR DIGIT
	OR	R10,R0			:MOVE NEW DIGIT IN
	SVC	0A,0110			:GET CHARACTER
	J	ADC050			:IF TIMEOUT
	J	ADC020

ADC030	LR	R10,R10
	JLFS	ADC040			:IF ACCUMULATOR STILL IN INITIAL STATE
	CHI	R10,MAXCHN
	JGFS	ADC040			:IF TOO BIG
	SBT	R10,CFILT,,		:ROUTINES SHOULD LOOK FOR THIS CHANNEL
	LIS	R11,1			:INDICATE A CHANNEL SELECTED
ADC040	CLHI	R1,0D
	JN	ADC010
ADC050	LR	R11,R11
	JNFS	SINIT			:IF MARKER SET (SOME CHANNEL WAS SELECTED)
	LCS	R1,1			:SET ALL BITS (ALL CHANNELS DISPLAYED)
	LHI	R2,2*((MAXCHN+0F)/10)-2
ADC055	STH	R1,CFILT,R2,
	SIS	R2,2
	JGEBS	ADC055


:	INITIALIZE POINTERS FOR ROUTINES

SINIT	LH	R0,ORING+NFMI,,		:GET CURRENT ORING POINTER
	STH	R0,ONFMI		:SAVE FOR DIAGNOSTIC
	LH	R0,IRING+NFMI,,		:GET CURRENT IRING POINTER
	STH	R0,INFMI		:SAVE FOR DIAGNOSTIC
	LH	R0,PTRINP,,		:GET CURRENT PACKET TRACE POINTER
	STH	R0,P.PTR		:SAVE FOR DIAGNOSTIC
	LH	R0,FTRINP,,		:GET CURRENT FRAME TRACE POINTER
	STH	R0,F.PTR		:SAVE FOR DIAGNOSTIC
	LH	R0,PBTINP,,		:GET CURRENT PACKET BUFFER TRACE POINTER
	STH	R0,PB.PTR		:SAVE FOR DIAGNOSTIC
  IF	HDLC
	LHI	R2,NLINES-1
SIN00	TBT	R2,LFILT		:ARE WE DISPLAYING THIS LINK?
	JEFS	SIN50			:IF NOT
	LB	R1,CURSEC,R2,		:GET CURRENT POINTER
	STB	R1,OSPTR,R2,		:INIT TRACE POINTER TO CURRENT POINTER
SIN50	SIS	R2,1			:BUMP LINE INDEX
	JGEBS	SIN00			:IF MORE TO DO
  EI	HDLC

REDO	LIS	R1,0			:INIT REQUEST INDEX
	CH	R1,REQSIZ		:GET COUNT OF REQUESTS	:DRE 4-JAN-84
	JGE	DSTRT2			:NO REQUESTS, ALL DONE	:DRE 4-JAN-84
RED010	STH	R1,REQINX		:SAVE REQUEST INDEX 
	L	R2,REQTAB,R1,		:GET ADDRESS OF NEXT ROUTINE TO EXECUTE
	JAL	R0,,R2			:GO TO REQUESTED ROUTINE
	SVC	0A,0			:ANY CHARACTERS WAITING FOR US?
	J	RED015			:IF NOT, CONTINUE
	J	DSTRT2			:IF SO THEN GET OUT
RED015	LHL	R1,REQINX		:GET INDEX OF LAST ROUTINE
	AIS	R1,4			:BUMP INDEX
	CH	R1,REQSIZ
	JL	RED010			:IF NOT TIME TO WRAP
	LIS	R1,0	
	SVC	DISMIS,0		:TAKE A BREAK
RED020	J	RED010			:DO IT AGAIN

:	INITIALIZE POINTERS FOR SNAPSHOT

SNAP	HS
SNINIT	LH	R0,ORING+NFMI,,		:GET CURRENT ORING POINTER
	AIS	R0,4			:GO PAST IT
	STH	R0,ONFMI		:SAVE FOR DIAGNOSTIC
	LH	R0,IRING+NFMI,,		:GET CURRENT IRING POINTER
	AIS	R0,4			:GO PAST IT
	STH	R0,INFMI		:SAVE FOR DIAGNOSTIC
	LH	R6,PTRINP,,		:GET CURRENT PACKET TRACE POINTER
SNI005	LB	R4,PTRTBL+1,R6,		:GET LINK NUMBER
	CLHI	R4,NLINKS		:IN RANGE?		:DRE 18-JAN-84
	JLFS	SNI008			:YES			:DRE 18-JAN-84
	AIS	R6,2			:SKIP TO NEXT POSSIBLE TRACE ENTRY:DRE 18-JAN-84
	CLHI	R6,PTRLEN		:COMPARE WITH LENGTH OF TABLE:DRE 18-JAN-84
	JLBS	SNI005			:NOT AT END YET		:DRE 18-JAN-84
	JFS	SNI010			:START OF LIST IS OK	:DRE 18-JAN-84
SNI008	AIS	R6,6			:ASSUME MOD 8
  IF	DDTDIA-2						:DRE 8-OCT-87
	AIS	R6,2			:ALLOW ROOM FOR TIME STAMP :DRE 8-OCT-87
  EI
	TBT	R4,P128.F		:TEST FOR MOD 128	:DRE 10-DEC-84
	JEFS	SNI010			:JUMP IF NOT
	AIS	R6,2			:SET UP FOR MOD 128
SNI010	CLHI	R6,PTRLEN
	JLFS	SNI020
	LIS	R6,0
SNI020	STH	R6,P.PTR		:SAVE FOR DIAGNOSTIC
	LH	R1,FTRINP,,		:GET CURRENT FRAME TRACE POINTER
SNI022	LB	R0,FTRTBL,R1,		:GET LINK NUMBER
	NHI	R0,37			:MASK OFF JUNK
	CLHI	R0,NLINES		:CHECK FOR VALID VALUE	:DRE 18-JAN-84
	JLFS	SNI025			:OK			:DRE 18-JAN-84
	AIS	R1,2			:SKIP TO NEXT ONE	:DRE 18-JAN-84
	CLHI	R1,FTRLEN		:OVER THE EDGE		:DRE 18-JAN-84
	JLBS	SNI022			:NOT YET		:DRE 18-JAN-84
	JFS	SNI030			:START OF RING IS GOOD ENOUGH:DRE 18-JAN-84
SNI025	AIS	R1,4			:ASSUME MOD 8		:DRE 18-JAN-84
  IF	DDTDIA-2						:DRE 8-OCT-87
	AIS	R6,2			:ALLOW ROOM FOR TIME STAMP :DRE 8-OCT-87
  EI
	TBT	R0,F128.F		:CHECK FOR MOD 128	:DRE 10-DEC-84
	JEFS	SNI030			:MOD 8
	AIS	R1,2			:MOD 128
SNI030	CLHI	R1,FTRLEN
	JLFS	SNI040
	LIS	R1,0
SNI040	STH	R1,F.PTR		:SAVE FOR DIAGNOSTIC
	LH	R0,PBTINP,,		:GET CURRENT PACKET BUFFER TRACE POINTER
	AIS	R0,4			:GO PAST IT
	CLHI	R0,PBTLEN
	JLFS	SNI050
	LIS	R0,0
SNI050	STH	R0,PB.PTR		:SAVE FOR DIAGNOSTIC
  IF	HDLC
	LHI	R2,NLINES-1
SNI60	TBT	R2,LFILT		:ARE WE DISPLAYING THIS LINK?
	JE	SNI080			:IF NOT
	LB	R1,CURSEC,R2,		:GET CURRENT POINTER
	AIS	R1,1			:POINT TO NEXT ENTRY
	CLB	R1,K.LT,R2,		:END OF TABLE FOR THIS LINE?
	JLFS	SNI070			:IF NOT
	LIS	R1,0			:POINT TO BEGINNING OF TABLE
SNI070	STB	R1,OSPTR,R2,		:INIT TRACE POINTER TO ONE AFTER CURRENT
SNI080	SIS	R2,1			:BUMP POINTER
	JGE	SNI60			:IF MORE TO DO
  EI	HDLC

	LIS	R1,0
	CH	R1,REQSIZ		:GET COUNT OF REQUESTS	:DRE 4-JAN-84
	JGE	DSTRT2			:NO REQUESTS, ALL DONE	:DRE 4-JAN-84
SNP010	STH	R1,REQINX		:INITIALIZE REQUEST INDEX TO ZERO
	L	R2,REQTAB,R1,		:GET ADDRESS OF NEXT ROUTINE
	JAL	R0,,R2			:EXECUTE NEXT ROUTINE
	LHL	R1,REQINX		:GET INDEX OF LAST ROUTINE
	AIS	R1,4			:BUMP INDEX
	CH	R1,REQSIZ
	JL	SNP010			:IF NOT DONE
	J	DSTRT2			:ALL DONE, GET OUT

	EI	DDTDIA


:	INDEX TO DIAGNOSTICS, ACTIVATED BY ?STAT COMMAND "HELP"
	SEG	A.CODE
X.HELP	NOP,,				:STALL
	SVC	0B,M.0,,
  IF	DDTDIA
	SVC	0B,M.1,,
	SVC	0B,M.2,,
	SVC	0B,M.3,,
	SVC	0B,M.4,,
	SVC	0B,M.5,,
  IF	DDTDIA-1
	SVC	0B,M.6,,
	SVC	0B,M.7,,
	SVC	0B,M.13,,
   IF	DDTDIA-2
	SVC	0B,M.8,,
	SVC	0B,M.9,,
	SVC	0B,M.10,,
	SVC	0B,M.11,,
   EI	DDTDIA-2
  EI	DDTDIA-1
   IF	HDLC
	SVC	0B,M.12,,
   EI	HDLC
	SVC	0B,M.16,,
	SVC	0B,M.17,,
	SVC	0B,M.14,,
	SVC	0B,M.15,,		:Display CRAT address
	J	DSTRT2			:ON COMPLETION OF COMMAND
:	Spare routines
DDMMY1	J	DSTRT2	
DDMMY2	J	DSTRT2	
  EI	DDTDIA

    Q:8`