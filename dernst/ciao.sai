begin "CIAO"


  forward simple procedure OUTSTR (string X);
  forward simple procedure outerr(integer I,J; string out);
  require "FRAME.DEF" source!file;
  require "(SAILIB)TYMINT.DEF" source!file;
  require 02 version;
  define ver!date = {"8 FEB 83"};

!	CIAO - Circuit (or Child) Input And Output


CIAO is used to do I/O either to whatever is at the end of an
auxiliary circuit or to a child frame on the same system.  The
latter case allows command files to be executed without using up
a port on the base or getting the Supervisor involved.

;

define HELP!bugs =
{"	Known Bugs --

1.	Child does not have parents licenses on Unatt and Pty.

	Unimplemented new features --

1.	A method of rerunning a job periodically
2.	Replacing RPG to allow ciao command files to execute when a
	PDP10 monitor command is not recognized
3.	Add examples to HELP DUMP documentation.
4.	Allow <cr> without <lf> in display and wait strings.
5.	Assign numbers to err messages and allow abort on ERR=n
6.	IFs, ABORTs and GOTO labels.
"};




!	Warning:
This program does not work (unless by chance).  That is,  the
way it does interrupts is guarenteed to break sooner or later.
This program has been maintained from its birth (when it
was called TOUT and only had one feature) until now with the
philosophy that all new features are implemented without any
knowledge of existing features.  This holds down to the routines
used to do the work.  Do not be confused therefore if you find 12
different routines all doing the same thing.  Also, be warned,
it isn't very well indented or structured.  It is NOT supported!
By the way none of the original features of this program still
exist, if that tells you anything about how its written.
;


define HELP!INTRO =
{"
		CIAO - Circuit (or Child) Input And Output


CIAO is used to do I/O either to whatever is at the end of an auxiliary
circuit or to a child frame on the same system.  The latter case allows
PDP10 command files to be executed without using up a port on the base
or getting the Supervisor involved.

CIAO accepts commands from the command port (hereafter referred to as
TTY) or from procedures on a command file.  Input to the created circuit
or child frame (hereafter called PORT) may come from the TTY, the
command file or an input file.  Output from the PORT may go to the TTY,
an output file, both or be trashed.  Input to the PORT may also be
copied to the output file.  If CIAO is running detached, all TTY output
will go to a file xxxCIO.OUT where xxx is the current ""job"" number.

CIAO may be started from the TTY in operating system command mode or from a
program by executing a RUN UUO.

If CIAO is started by user command, a CIAO command may be entered on
the operating system command line following a semicolon.  When CIAO
completes the processing of this command, control will return to the
TTY unless the command executed a procedure that was ended by a QUIT
command.  For example, 

                         R CIAO;DOIT

will execute procedure DOIT and then prompt the TTY for more input
(unless DOIT ended with a QUIT command).

If started by a RUN UUO with an offset of 1, CIAO expects a command
file on the file xxxCIO.TMP, where xxx is the current ""job"" number.
File xxxCIO.TMP must contain only one procedure without a procedure
header (explained below).

A CIAO command line consists of a command name, optionally one or more
blanks followed by arguments, and a carriage return.  A comment line may
be entered by begining the command line with a blank.  Within the
argument field of a command, when the command file is in Input Mode, or
when reading from the input file a special escape character (user
definable with the SET command (default ^P) and hereafter referred to as
ESC) causes the next character to be interpreted as follows.

	D	Display everything until the next ESC-D to the TTY
                  (display may be several lines long)
	F	turn TTY echo ofF
	N	turn TTY echo oN
	I	Input from TTY until a <CR>
	U	substitute the current GFDed Username
	S	substitute the system number CIAO is running on
	<cr>	return to command mode from Input or Resume modes
	n	n=0 to 9, substitute nth arg from command line (works
                with arguments from procedure calls)

All other characters are just passed as if the ESC was not present.


CIAO command files can be in either Command Mode or Input Mode.  In
Command Mode, commands are read and executed by CIAO.  In Input Mode,
characters are read from the file and sent as data on the PORT.  In
Input Mode the only character interpreted by CIAO is the ESC.  When an
ESC is seen in Input Mode, the next character is examined by CIAO to
determine the action taken (described above).  CIAO input files cannot
contain CIAO commands but they will be examined for the ESC and the
character following the ESC will cause the action as in a command file.
This may be inhibited by clearing the ESC definition (see SET command).

A command file is made up of one or more procedures.  Each procedure is
a set of CIAO commands (and possibly Input Mode data).  A procedure
begins with a procedure header and ends at the next procedure header or
at the end of the file.  A procedure header starts with @ in column 1
and is immediately followed by the procedure name (without an
intervening blank).  A procedure name can consist of alphanumerics and
period.  The header is ended with a carriage return.  The first line of a
command file must be a procedure header except when the command file
contains only one procedure.  In the later case, the procedure may be
unnamed and no header is required.  Blank lines in a command file will
be ignored except in Input Mode.  Procedures may call other procedures
with a nesting of up to ten deep.  When CIAO has finished executing the
last line of a procedure it will return to the calling procedure at the
line following the call (or to the TTY if this is the original
procedure call).  If ESCn (where n = 0 to 9) is encountered within a
procedure the nth argument of the procedure call is substituted for the
ESCn (If less than n arguments were entered, the ESCn is just removed).

     COMMANDS (uppercase indicates minimum specification) -
     --------

? 		same as HELP command below
<blank><comment>	place one line of comment in the command file
"};

define HELP!creaux =
{"Creaux <login-string> [I]	
	Build an auxiliary circuit to the given username and system.
	If executed from a TTY, a RESUME command (q.v.) is implied
	after the Creaux.  If <login-string> is null then the
	current system and the GFDed Username are implied.  If ""I""
	is present following the login string, Input Mode instead of
	Resume Mode is implied.  Input Mode is different from Resume
	Mode in that Resume Mode turns off TTY echo (assumes that the
	other end of the aux circuit is echoing) and Input Mode does
	not turn off TTY echo (assumes that the other end of the aux
	circuit does not echo).  Only one aux circuit or Pty (see) is
	allowed at any time.
"};

define HELP!dial =
{"DIAL <phoneno>	dial out using <phoneno> as number
"};

define HELP!force =
{"FORCE <string>	outputs <string> on PORT
	A <CR> will follow <string> unless it ends with the ascii
	character <esc>.  In this case neither the <cr> or the <esc> is sent.
	Hint: to send a line ending with <esc><cr> enter:
		Force <string><esc><esc><cr>
		Force <cr>
"};

define HELP!hang =
{"HANG	sends yellowball followed by hang character on PORT
"};

define HELP!help =
{"HELP <arg>	give explanation of command
	if args are missing a short explanation of all commands is given.
	""HELP ALL"" lists all commands.  ""HELP DUMP"" will put it on
	file ""CIAO.DOC"" in your directory with an intro and examples.
"};

define HELP!input =
{"Input <file-spec>	Enter Input Mode and copy a file to PORT.
	ESC sequences will be processed on the input file.

	If <file-spec> is missing, input will start with the next line
	of the command-file; ESC<cr> will end Input Mode and return to
	Command Mode.

	An end-of-file acts as an ESC<cr>.  On a separate input file
	(i.e. <file-spec> not null) everything past an ESC<cr> is ignored.

	Input without a <file-spec> entered at the TTY will connect the
	TTY directly to the PORT.  TTY echo will not be affected; if the
	remote end of the PORT echoes, either ESCf or the Resume command
	should be used to turn off TTY echo.  ESC<cr> will return the TTY to
	Command Mode.  ESC sequences are processed in Input Mode.

	The OMITlf/SENDlf, NoHandshake/YellowBall/LineFeed, TRACE/NOTRACE,
	ESCape= and BLIPS/NOBLIPS arguments to the SET command effect
	Input Mode.
"};

define HELP!list =
{"LISt	List version, settings for SET args, OUTPUT filename and PORT username
"};

define HELP!nest =
{"Nest <file-spec>;<procedure-name> arg0 arg1 ... arg9
	executes commands from procedure <procedure-name> out of file
	<file-spec>.  ""Nest "" may be omitted as long as the procedure
	call does not duplicate a CIAO command name.  <file-spec> is of
	the form (username)file.ext. <procedure-name> can be any
	displayable characters.  Not all parts of the command are required.
	The following examples illustrate all possibility.  In the
	examples, ""gfd"" represents the current GFDed username, ""aun""
	represents the logged in username.

	name		procedure ""name"" will be searched for on:
			current command file if any
			(gfd)CIAO.COM
			(gfd)NAME
			(aun)CIAO.COM
			(aun)NAME
	;name		procedure ""name"" will be searched for on:
			(gfd)CIAO.COM
			(aun)CIAO.COM
	name;		procedure ""name"" will be searched for on:
			(gfd)NAME
			(aun)NAME
	file;name	procedure ""name"" will be searched for on:
			(gfd)FILE
			(aun)FILE
	(un)name	procedure ""name"" will be searched for on:
			(UN)NAME
	(un)file;name	procedure ""name"" will be searched for on:
			(UN)FILE

	For any command file except CIAO.COM, if the first character is not
	""@"", the file will be immediately executed without searching
	for ""name"" in a procedure header.
"};

define HELP!output =
{"Output <file-spec>	declare file for PORT output
	If a file is already open, close and release it.
	If <file-spec> exists, rename it to file.BAK.
	Open <file-spec> in Update mode thus allowing another process
	to read the file while it is being written.  The file
	will be updated at least every UPD seconds (see SET command).
	The COPY, NOTRACE and BLANK flags will be set (see SET command).
"};

define HELP!pty =
{"Pty <username>	works like Creaux except that a child frame will be
	created with a Pseudo tTY instead of an aux circuit.  This
	saves a base port and a network supervisor call for procedures
	that need to be executed on the same system.  The child will
	have the same licenses as the parent frame.  If no <username>
	is given the GFDed name is used.  The TTY is left in Resume
	Mode, i.e., connected to the child frame with TTY echo turned
	off (child frame will perform all echoing).  Only one Pty or
	Creaux may be active at any one time.
"};

define HELP!resume =
{"Resume	Send characters transparently from TTY to PORT
	starts reading from TTY, all characters are passed
	except that the ESC sequences will be processed. ESC<cr> will
	return to command mode (next line of command file if any or TTY).
	In Resume mode all output from PORT is sent to TTY
	regardless of the SEE flag (see SET command).  TTY echo is
	turned off.  Echoing, if any, is performed by the remote end
	of the PORT circuit.
"};

define HELP!SET!header =
{"SET <arg1>[ <arg2>...]	sets arguments as follows
"};

define HELP!SET!blank =
{"	BLANK/NOBLANK	turns off/on blank line suppression from PORT,
		initially BLANK, i.e. no suppression.
"};

define HELP!SET!BLIPO =
{"	BLIPO/NOBLIPO   select whether a character count is output to
		the TTY for every 100 characters from the PORT.
		""TIME n"" command will reset counter to zero.
		Default is NOBLIPO.
"};

define HELP!SET!blips =
{"	BLIPS/NOBLIPS   select whether a character count is output to
		the TTY for every <lf> on input file (or 1024 characters
		if no <lf>).  Default is BLIPS.
"};

define HELP!SET!captain =
{"	CAPTAIN=<string>	set outdial captain username
"};

define HELP!SET!copy =
{"	COPY/NOCOPY	turns on/off recording of PORT output to
		OUTPUT file, set to COPY automatically by the
		OUTPUT command.
"};

define HELP!SET!escape =
{"	ESCape=<esc-char>	sets ESC to <esc-char> (default ESCape=^P)
			If <esc-char> is <cr>, <lf> or <blank> then ESC will
			not be defined and the circuit will be transparent.
			Note that ESC is looked for even on the input file,
			so undefining the ESC may be important.
			Lower case a-z are not allowed ESC characters.
"};

define HELP!SET!nohandshake =
{"	NoHandshake/LineFeed/YellowBall select handshake for INPUT command.
		NoHandshake sends the entire input file without waiting.
		LineFeed waits for a <lf> from the PORT after every <cr>
		from the Input File.  YellowBall sends a yellow ball after
		every <lf> from the input file and waits for an orangeball.
		Default is NoHandshake.
"};

define HELP!SET!omit =
{"	OMITlf/SENDlf	select whether linefeeds following carriage returns
                from input file is sent on PORT (see INPUT command).
		If OMITlf then a linefeed which follows a carriage return
		on the input file will not be sent to the PORT.  This
		option assumes that the processes at the other end of the
		PORT adds <lf> after a <cr>.  A <lf> not after a <cr> is
		always sent.   default OMITLF
"};

define HELP!SET!prompt =
{"	PROMPT=""<string>""	sets CIAO prompt (default PROMPT=""ciao: "")
"};

define HELP!SET!nosee =
{"	NOSEE/SEE	turns on/off copying of PORT output to TTY
		starts out NOSEE except that during in RESUME mode (i.e.,
		when TTY is connected to PORT) it is ignored (always
		assumed on).
"};

define HELP!SET!trace =
{"	TRACE/NOTRACE	turns on/off copying of PORT input to the output
		file.  (default NOTRACE).  TRACE is useful if the PORT
		is not echoing and a full record of input/output is needed.
"};

define HELP!SET!upd =
{"	UPD=<sec>	number of seconds of no PORT output before
		flushing OUTPUT file buffers to disk.  This allows the
		output file to be monitored by another process.
		Initially 60 seconds.
"};

define HELP!SET!wait =
{"	WAIT=""string"" n     Set wait string for next FORCE, Creaux or Pty
		command.  As soon as one of these commands is executed,
		PORT output is watched for ""string"" before the next CIAO
		command is read.  If n seconds pass without seeing
		""string"", execution will continue. If n is 0 or missing,
		""string"" must be found.
"};

define HELP!time =
{"TIME <n>	wait for n seconds of no characters from PORT or
		PORT zapped, n=0 or missing implies wait only for zap.
"};

define HELP!unattach =
{"Unattach <file-spec>;<procedure-name>	Run detached job
	If <file-spec>;<procedure-spec> is missing just detach current
	frame else create a detached frame belonging to the GFDed username
	and execute procedure <file-spec>;<procedure-name> in that frame.
	The frame will have the same licenses that the parent frame had.
	The frame will be destroyed when the command file completes.  See
	the Nest command for a description of <file-spec>;<procedure-spec>.
"};

define HELP!wait =
{"WAIT <n>	wait for n seconds or for event
	n=0	send yellow ball and wait for an orange ball or PORT zapped
	n>0	wait for n seconds or until PORT zapped
	n<0	wait for n seconds or until character from PORT or zapped
"};

define HELP!zap =
{"ZAP	sends zapper on PORT
"};

define HELP!examples =
{"		Examples --  Watch this space for future examples"};

  define HELP!MESSAGE = {"Valid commands are:
?			type this list
<blank><comment>	comment line
Creaux <user>:<sys>	build circuit over Tymnet
DIAL <phone#>		dialout 
FORCE <string>		send string to host followed by <cr>
HANG			sends yellowball and hang character
HELP <arg>		explain arg: <command>,ALL or DUMP (Try ? HELP)
Input <file-spec>	send contents of file over circuit
LISt			display version, current settings and connections
Output <file-spec>	record all chars from host in file
Pty <user>		creates child frame <user> default is GFDed name
Resume			resume transparent connection
Nest <file>;<proc>	execute <proc> (""<file>;"" and ""Nest "" optional)
SET <arg>		sets <arg>, enter ? SET or ? SET <arg> for details
TIME <seconds>		wait until no chars rec'd for n secs
Unattach		detach job
Unattach <file>;<proc>  run command file as a detached frame
WAIT <seconds>		wait for n seconds to elapse or event
ZAP			disconnect auxiliary connection
"};

  define HELP!SET = {"Valid SET arguments are:
? SET <arg>             for more details on <arg>
Set BLANK | NOBLANK	turn on and off blank line suppression
Set BLIPO | NOBLIPO	send character counts to TTY for OUTPUT from PORT
Set BLIPS | NOBLIPS     send character counts to TTY in INPUT mode
Set Captain=<uname>	set captain username for outdial
Set COPY | NOCOPY	turn on and off recording
Set ESCape=<char>	set escape character (default is ^P)
Set NoHandshake | LineFeed | YellowBall select handshake in INPUT mode
Set OMITlf | SENDlf	omit lfs following crs in INPUT mode
Set PROMPT=""<string"">	Change Ciao prompt to <string>
Set NOSEE | SEE		turn off and on Port output to TTY
Set UPD=<sec>		set output file flush time (def 60 sec)
Set WAIT=""<string>"" <n>   wait for string after next FORCE or wait n sec
"};
  integer PORT,EOF,BRK,TOSS,DSK!IN,DSK!OUT,TTY!OUT,SLOT,BAUD,ESCAPE,LF!cnt;
  integer PTY!PORT;
  integer FD,Com!File,DISK!WRD,DISK!PTR,CHR!RCD,UPD!SEC;
  integer array DialAcct[0:4];	! accounting data goes here;
  integer NEST!LEVEL,Wait!time;
  string array COMMAND!PARAMETER[0:9];
  integer array NEST!FILE[1:10];
  string Current!File,WAIT!String,CH!string,LOG!STR,OUT!FILE;
  string DIAL!UNAME,ARG,CIAO!PROMPT;
  boolean DIAL!!,DIALACCT!,Waiting,No!Prompt;
  boolean COPY,BLANK,NO!LF,CARRIER,SEE,SENDLF!,NOBLIPS,NOBLIPO,TTY!ECHO,TRACE;
  integer HANDSHAKE; define NO!HS=0, YB!HS=1, LF!HS=2;

  define service!routine = {forward simpleedure};

  define CREAUX = -'44, AX!SIC = '10, AX!SIL = '50, SETLIC = -'10,
    RETACH = -'135, DISPLAY!ESC='104, OFFECHO!ESC='106, ONECHO!ESC='116,
    INPUT!ESC='111, USER!ESC='125, SYSNO!ESC='123, RETURN!ESC='15,
    P0!ESC='60, P1!ESC='61, P2!ESC='62, P3!ESC='63, P4!ESC='64,
    P5!ESC='65, P6!ESC='66, P7!ESC='67, P8!ESC='70, P9!ESC='71,
    AX!STS = '61, AX!I8C = 0, AX!O8 = 3, AX!CFS = '64, AX!HNG = '60,
    AX!IB = '15, AX!OB = '16, AX!IC = '44, AX!OCI = '51, AX!SI = '33,
    HIBER = '72, AX!I8S = '1, AX!CBO = '7, AX!LDEM = '11, CRPTY = -'141,
    INTACT = -'35, SETTIM = -'37, SETPRV = -'11;

  define ac!lic = '400;

define ATTACH = "CALLI (0,-'6)"; ! attach command port to frame;
define ZAPCIR = "CALLI (-1,-'45)"; ! zap all aux circuits;
define PJOB = "CALLI (0,'30)"; ! get job number;
define LOGOUT = {
  begin
  calli (0,-'21); ! SETJAL, set JB.LOG;
  calli (0,'17); ! log frame off; end};

define CASEOF (blklab) = {
  begin "blklab"
  label IEND;
  integer I;
  string IS;
  boolean IB;
  begin if false then };

define COF (cmd,min) = {
  goto IEND;  end;
  IS:= cmd;
  IB:= true;
  for I:=1 step 1 until length(COM) DO
    if not equ(COM[I for 1], IS[I for 1]) then IB:=false;
  if length(COM) < min then IB:=false;
  if IB then begin };

define CELSE = { goto IEND; end; begin };

define CASEND (blklab) = {
  end;
IEND: ; end "blklab"; };

  service!routine ZAPPED;
  service!routine TIMINT;
  service!routine CHARACTER;

simple procedure OUTSTR (string X); begin "OUTSTR"                 ! "OUTSTR";
  if TTY!OUT then OUT(TTY!OUT,X)
  else
    start!code
      define SP = '16;
      hrroi 1,'67;	comment !AXOPC;
      auxcal 1,-1(SP);
    end;
  end "OUTSTR";

simple boolean procedure Detached; begin "DETACHED"              ! "DETACHED";
  if lh(calli(0,'34)) then return(false)
  else return(true);
  end "DETACHED";

service!routine HANG;
service!routine CLOSE!OUT;

simple procedure OUTERR (integer CODE,LEVEL; string MSG); begin    "OUTERR"
  if not msg=null then OUTSTR(7&7&MSG);
  if CODE then outstr(" ["&cvs(CODE)&"]"&crlf) else outstr(crlf);
  if CARRIER then HANG;
  close(DSK!IN);
  CLOSE!OUT;
  if TTY!OUT then begin close(TTY!OUT); release(TTY!OUT); TTY!OUT:=0 end;
  if COM!FILE then begin
    close(COM!FILE); release(COM!FILE);
    COM!FILE:=0; NEST!LEVEL:=0; end;
  if DETACHED then LOGOUT else if LEVEL then call(0,"EXIT");
  end "OUTERR";

simple procedure AUXOPC (string X); begin "AUXOPC"                 ! "AUXOPC";
start!code
    define SP = '16;
    hrrzi 1,'67;	comment !AXOPC;
    hrl 1,PORT;
    auxcal 1,-1(SP);	comment takes word 1 of a sail string;
end;
end "AUXOPC";

simple integer procedure GetLch; begin "GETLCH"                    ! "GETLCH";
    integer I;
    start!code
	move 1,Port;
	movem 1,I;
	ttcall 6,I;
	end "GETLCH";
    return(I);
    end;

simple procedure YellowBall; begin "YELLOWBALL"                ! "YELLOWBALL";
    GetLch;
    do begin
	calli((PORT lsh (35-8))+hl('140),HIBER);
	if not !SKIP! then outerr(0,1,"?HIBER uuo failed");
    end until (Port=0) or (GetLch land '020000000000);
end "YELLOWBALL";

simple procedure CRWait; begin "CRWAIT"                            ! "CRWAIT";
    integer LF!tmp;
    LF!tmp:=LF!cnt;
    do begin
	calli(1000,HIBER);
	if not !SKIP! then outerr(0,1,"?HIBER uuo failed");
    end until (Port=0) or (LF!tmp < LF!cnt);
end "CRWAIT";

  simple procedure turn!on(integer LIC); begin "TURN!ON"          ! "TURN!ON";
    integer I;
    I:=call(-'20,"GETTAB");
    if (I land (LIC lsh 18))=0
      then calli(I lor (LIC lsh 18),SETLIC);
  end "TURN!ON";

  simple procedure turn!off(integer LIC); begin "TURN!OFF"       ! "TURN!OFF";
    integer I;
    I:=call(-'20,"GETTAB");
    if (I land (LIC lsh 18))and((I land LIC)=0)
      then calli(I xor (LIC lsh 18),SETLIC);
  end "TURN!OFF";

  simple procedure diskout(integer CH); begin "DISKOUT"           ! "DISKOUT";
    dpb(CH,DISK!PTR);
    ibp(DISK!PTR);
    if rh(DISK!PTR)neq location(DISK!WRD) then begin
      WORDOUT(DSK!OUT,DISK!WRD);
      DISK!PTR:=point(7,DISK!WRD,6);
      DISK!WRD:=0;
      end;
  end "DISKOUT";

  simple procedure traceout(integer CH); begin "TRACEOUT"       ! "TRACEOUT;
! don't let interupt catch us in the middle;
    if OUT!FILE and PORT then begin
      intmap(tinass(PORT,cause!tty!chr,0),CHARACTER,0);
      diskout(CH);
      intmap(tinass(PORT,cause!tty!chr,7),CHARACTER,0); end
  end "TRACEOUT";

  simple procedure CLOSE!OUT; begin "CLOSE!OUT"                 ! "CLOSE!OUT";
    if OUT!FILE then begin
      OUT!FILE:=null;
      if (DISK!PTR neq point(7,DISK!WRD,6))
      then wordout(DSK!OUT,DISK!WRD); end;
    close(DSK!OUT);
  end "CLOSE!OUT";

  simple procedure INTERRUPTS(integer PORT);
  begin "INTERRUPTS"                                           ! "INTERRUPTS";
    define
      ZC = 5, SC = 6, CC = 7, TI = 8;   ! channels;
    if PORT
      then begin "TURN-ON"                                        ! "TURN-ON";
	calli('377777777777,INTACT);	! uncause all interrupts;
	enable(newenb(zc));
	enable(newenb(cc));
	enable(newenb(ti));
	intmap(tinass(PORT,cause!tty!zap,zc),ZAPPED,0);
	intmap(intass(cause!timer,ti),TIMINT,0);
	intmap(tinass(PORT,cause!tty!chr,cc),CHARACTER,0);
	end "TURN-ON"
      else begin "TURN-OFF"                                      ! "TURN-OFF";
	disable(newenb(zc));
	disable(newenb(cc));
	intmap(tinass(PORT,cause!tty!zap,0),ZAPPED,0);
	intmap(tinass(PORT,cause!tty!chr,0),CHARACTER,0);
	intmap(intass(cause!timer,0),TIMINT,0);
	end "TURN-OFF";
    end "INTERRUPTS";

  simple procedure TIMINT; begin "TIMINT"                          ! "TIMINT";
  if PORT and COPY and OUT!FILE then begin
    calli(('1000000 lor UPD!SEC),SETTIM); ! call again in UPD!SEC seconds;
    if not (DISK!WRD=0) then begin
      wordout(DSK!OUT,DISK!WRD);
    	DISK!PTR:=point(7,DISK!WRD,6);
    	DISK!WRD:=0;
      end;
    useto(DSK!OUT,1); ! set file position to start of block to flush buffers;
    useti(DSK!OUT,'377777); ! set file to back to end;
  end;
  end "TIMINT";

  simple procedure ZAPPED; begin "ZAPPED"                          ! "ZAPPED";
    own integer SKIP;
    SKIP:=!SKIP!;
    if PORT and not DIAL!! then outstr(crlf&"[circuit zapped]"&crlf);
    PORT:=0;
    CARRIER:=false;
    INTERRUPTS(0);
    ZAPCIR;
    !SKIP!:=SKIP;
  end "ZAPPED";

  simple integer procedure GETWRD(integer port); begin "GETWRD"    ! "GETWRD";
	integer I,J;
	I := 0;
	for J := 3 step -1 until 0 do 
	  I := I lsh 8 lor auxclv(PORT,0,AX!IC);
	return(I);
  end  	"GETWRD";

  simple procedure CHARACTER; begin "CHARACTER"                 ! "CHARACTER";
    own integer CH,SKIP;
    SKIP:=!SKIP!;
    do begin "eat chars"
      auxclv(PORT,0,AX!SIC);
      if not !SKIP! then begin
	auxclv(PORT,0,AX!LDEM);
	done "eat chars";
	end;
      CH:=auxclv(PORT,0,AX!IC);
      if length(Wait!String) then begin
        if length(CH!STRING)=length(Wait!STRING) then lop(CH!STRING);
        CH!STRING:=CH!STRING&CH;
        if equ(CH!String,Wait!String) then begin
          Wait!Time:=0; Wait!String:=null end;
        end;
      CHR!RCD:=CHR!RCD+1;
      if not NOBLIPO and not (CHR!RCD MOD 100) then outstr(" "&cvs(CHR!RCD));
      if DIAL!! and CH=1 then begin
	CH:=auxclv(PORT,0,AX!IC);
	if CH neq 1 then begin
	  case CH of begin
	  ['176] begin
		DialAcct[0] := auxclv(PORT,0,AX!IC) lsh 8 + auxclv(PORT,0,AX!IC);
		DialAcct[1] := getwrd(PORT);
		DialAcct[2] := getwrd(PORT);
		DialAcct[3] := getwrd(PORT);
		DialAcct[4] := getwrd(PORT);
		DialAcct! := true;
	  end;
	  ['177] outstr(crlf&"[disconnect]"&crlf);
	  else outstr("[mysterious message type]"&crlf)
	  end;
	  continue "eat chars";
	end;
      end;
      if CH='12 then LF!cnt:=LF!cnt+1;
      if CH>'40 then NO!LF:=false;
      if (CH='12) and NO!LF and not BLANK then continue;
      if CH='12 then NO!LF:=true;
      if SEE then auxclv(-1,CH,AX!O8);
      if COPY and OUT!FILE then diskout(CH);
      end "eat chars" until PORT=0;
    !SKIP!:=SKIP;
    end "CHARACTER";

boolean procedure FILEBAD(string FILE); begin "FILEBAD"           ! "FILEBAD";
  own string NAME; own integer BRK;
  BRK:=false;
  NAME:=FILE;
  if equ(NAME[1 for 1],"(") then begin
    SCAN(NAME,10,BRK);
    if equ(BRK,")") then BRK:=false else BRK:=true;
    if not NAME then BRK:=true end;
  if not brk then SCAN(NAME,11,BRK);
  if brk then begin outerr(0,0,"?Invalid file specification");
    return(true) end
    else return(false);
  end "FILEBAD";

                                                           ! "PROCESS!ESCAPE";
recursive boolean procedure PROCESS!ESCAPE (value integer brkc;
  reference string A; value boolean DSK!FILE; value boolean CMD!LINE);
  begin "PROSESC"
  case brkc of begin
    [OFFECHO!ESC] auxcli(-1,'301,AX!CFS);
    [ONECHO!ESC] auxcli(-1,1,AX!CFS);
    [INPUT!ESC] A := A&ttyinl(4,toss);
    [USER!ESC] A := A&USER!NAME;
    [SYSNO!ESC] A := A&SYS!NO;
    [DISPLAY!ESC] begin
        if CMD!LINE then outstr(Scan(ARG,5,Brk))
        else outstr(input(dsk!file,5));
        while not (BRK=ESCAPE) do
          if CMD!LINE then begin
            if DSK!FILE then ARG:=input(DSK!FILE,4)
              else ARG:=ttyin(4,brk);
              outstr(crlf&scan(Arg,5,brk)); end
            else outstr(crlf&input(dsk!file,5));
        if DSK!FILE then scan(ARG,7,brk) else input(dsk!file,7);
        if not(brk=DISPLAY!ESC) then PROCESS!ESCAPE(BRK,A,COM!FILE,CMD!LINE);
       end;
    [P0!ESC] A:=A&COMMAND!PARAMETER[0];
    [P1!ESC] A:=A&COMMAND!PARAMETER[1];
    [P2!ESC] A:=A&COMMAND!PARAMETER[2];
    [P3!ESC] A:=A&COMMAND!PARAMETER[3];
    [P4!ESC] A:=A&COMMAND!PARAMETER[4];
    [P5!ESC] A:=A&COMMAND!PARAMETER[5];
    [P6!ESC] A:=A&COMMAND!PARAMETER[6];
    [P7!ESC] A:=A&COMMAND!PARAMETER[7];
    [P8!ESC] A:=A&COMMAND!PARAMETER[8];
    [P9!ESC] A:=A&COMMAND!PARAMETER[9];
    [else] return(false) end;
  return(true);
  end "PROSESC";

  simple procedure SLAVE(boolean ECHO); begin "SLAVE"               ! "SLAVE";
    own integer CH,SAVE!SEE;
    string A;
    SAVE!SEE:=SEE;
    SEE:=true;
 ! full char set, mode=binary;
    if ECHO then auxcli(-1,'014,AX!CFS) else auxcli(-1,'314,AX!CFS);
    do begin
      CH:=auxclv(-1,0,AX!I8S);
      if !SKIP! then begin
        if (CH land '177)=ESCAPE then begin
          A:=null;
          CH:=INCHRW;
          if PROCESS!ESCAPE(CH,A,false,false) then continue
          else if CH=RETURN!ESC then done;
          end;
        if TRACE then TRACEOUT(CH);
        auxclv(PORT,CH,AX!O8);
	if DIAL!! and CH=1 then auxclv(PORT,1,AX!O8);
      end;
    calli(hl('10),HIBER);
    end until PORT=0;
    auxcli(-1,0,AX!CFS); ! back to ascii I/O;
    SEE:=SAVE!SEE;
    if PORT then auxclv(PORT,0,AX!CBO);
    if DialAcct! then begin
!	outstr("[time=");
!	outstr(cvs(DialAcct[2]-DialAcct[1]));
!	outstr("sec chin=");
!	outstr(cvs(DialAcct[3]));
!	outstr(" chout=");
!	outstr(cvs(DialAcct[4]));
!	outstr("]");
	DialAcct! := false;
    end;
    outstr(crlf);
    end "SLAVE";

  simple procedure SEND(string FILE); begin "SEND"                   ! "SEND";
    own integer CH,FOO2,Blips,IN!DSK;
    string FOO;
    LF!cnt:=Blips:=0;
    FILE:=SCAN(FILE,1,BRK);
    if FILEBAD(FILE) then return;
    if EQU(file,"TTY") then begin SLAVE(true); RETURN end;
    if length(FILE) then begin
      lookup(DSK!IN,FILE,EOF);
      IN!DSK:=DSK!IN
            end
    else if COM!FILE then IN!DSK:=COM!FILE
      else begin SLAVE(true); RETURN end;
    if EOF
      then outerr(0,0,"?Can't read file "&FILE)
      else do begin
	Foo := input(IN!DSK, 5);	! break on ESC or lf (and skip);
	Blips:=Blips+length(foo);
        if length(FOO) then 
          if equ(FOO[length(FOO) for 1],'15) then FOO2:=true else FOO2:=false
          else FOO2:=false;
	while length(Foo) do begin
	  CH := lop(Foo);
          if TRACE then TRACEOUT(ch);
	  auxclv(Port,CH,AX!O8);
	  if DIAL!! and CH=1 then auxclv(Port,1,AX!O8);
	end;
        if Brk='12 then 
          if (not FOO2) or SendLf! then begin
           if TRACE then TRACEOUT(brk);
           auxclv(Port,Brk,AX!O8) end;
        if BRK=ESCAPE then begin
          INPUT(IN!DSK,7);
          foo := null;
          if PROCESS!ESCAPE(BRK,FOO,IN!DSK,false) then
            begin if FOO then AUXOPC(FOO);
              if TRACE then TRACEOUT(foo) end
            else if BRK=RETURN!ESC then done
              else begin if TRACE then TRACEOUT(brk);
                 auxclv(PORT,BRK,AX!O8) end;
          end
        else if HANDSHAKE=YB!HS then YellowBall 
	    else if HANDSHAKE=LF!HS then if Brk then CRWait;
	if not NOBLIPS then outstr(cvs(blips)&" ");
	end until EOF or PORT=0;
    if length(FILE) then begin close(DSK!IN); EOF:=false end;
    outstr(crlf);
    outstr(crlf);
    end "SEND";

  boolean procedure CREATE(string LOGSTR;
	reference integer PORT); begin "CREATE"                    ! "CREATE";
    integer array FOO[0:length(LOGSTR)%5];
    integer I;
    for I:=1 step 5 until length(LOGSTR)
      do FOO[I%5]:=cvasc(LOGSTR[I for 5]);
    PORT:=calli(location(FOO[0]),CREAUX);
    if not !SKIP! then begin
      outstr("?Can't build circuit to "&LOGSTR&crlf);
      case lh(PORT) of begin
	[0][7] case rh(PORT) of begin
	  [1] outerr(0,0,"?Format error");
	  [2] outerr(0,0,"?User name not in MUD");
	  [3] outerr(0,0,"?Bad MUD");
	  [4] outerr(0,0,"?System unavailable or out of ports");
	  [5] outerr(0,0,"?Downline/dialout request failure");
	  [6] outerr(0,0,"?Tymout");
	  [7] outerr(0,0,"?Access barred") end;
	[1] outerr(0,0,"?Too many circuits without AC license");
	[2] outerr(0,0,"?Not your user name without AC license");
	[3] outerr(0,0,"?No room for DDB");
	[4] outerr(0,0,"?Supervisor not responding to request");
	[5] outerr(0,0,"?Supervisor not responding to string");
	[6] outerr(0,0,"?Supervisor not supplying a channel") end;
      return(false);
      end;
    return(true);
    end "CREATE";

boolean procedure BUILD(string ARG; reference boolean TTY!ECHO);
  begin "BUILD"                                                     ! "BUILD";
  own string username;
  integer TARG;
  if PORT then begin outerr(0,0,"?Circuit already assigned");
    return(false) end;
  username:=scan(ARG,1,brk);
  ARG:=scan(ARG,1,brk);
  if ARG="I" then TTY!ECHO:=true else TTY!ECHO:=false;
  if not length(username) then username := USER!NAME&":"&SYS!NO;
  DIAL!! := false;
  turn!off(ac!lic);
  if CREATE(USERNAME,PORT) then begin
    outstr("[connected to "&username&"]"&crlf);
    NO!LF:=true;
    INTERRUPTS(PORT);
    if Waiting then begin
      Waiting:=false;
      TARG:=call(0,"MSTIME")+Wait!Time*1000+500;
      While PORT and Wait!Time and (call(0,"MSTIME")<TARG)
        do call(1,"SLEEP");
      Wait!String:=null;
      end;
    LOG!STR:=USERNAME;
    return(not Com!File);
    end;
  LOG!STR:=null;
  PORT:=0;
  return(false);
end "BUILD";

boolean procedure CREPTY(reference integer PORT); begin "CREPTY"   ! "CREPTY";
  PORT:=calli(0,CRPTY);
  if not !SKIP! then begin
    if PORT=1 then outerr(0,0,"?PTY capacity exceeded")
    else outerr(0,0,"?error "&cvs(PORT)&" creating PTY");
    PORT:=0;
    return(false);
    end;
  return(true);
  end "CREPTY";

simple boolean procedure ptypty; begin "PTYPTY"                    ! "PTYPTY";

 label tcini,tcdon,tccclr,fatal1,fatal2,fatal3,fatal4;
start!code
	HRROI	1,'73	; ! copy terminal characteristics;
	HRROI	2,'73	;
	HRL	2,pty!port;
	SETZ	3,		; ! start with characteristic 0;
TCINI:	HLLOS	3		; ! read characteristics;
	AUXCAL	1,3		; ! get characteristeristic from real TTY;
	 JRST	TCDON		; ! no more characteristics;
	AUXCAL	2,3		; ! set it on other end of PTY;
	 jrst fatal1;
	hrlzi 4,1;
	ADD	3,4	; ! incriment terminal char #;
	JRST	TCINI;
TCDON:;
	HRL	1,port		; ! set mode on our end of PTY;
	HRRI	1,AX!CFS	; ! change file status for port;
	AUXCAL	1,'214		; ! image binary no echo;
	HRRO	1,FD		; ! move PTY to child;
	HRLI	2,'200000	; ! attach in command mode;
	HRR	2,pty!port		; ! his port number;
	MOVEI	3,1		; ! address of arg block;
	calli	3,-'135;
	 jrst fatal2;

	hrroi	1,6	; ! set logout on disconnect;
	calli	1,'41	; ! gettab;
	 jrst	fatal4;
	trz	1,'300000;
	calli	1,setprv;

	HRROI	5,'74	; ! get next characteristic;
	HRL	5,port;
TCCCLR:	AUXCAL	5,6;
	 jrst fatal3;
	JUMPGE	6,TCCCLR	; ! more;
end;
return(true);
fatal1:	outerr(0,0,"?cant set terminal characteristic"); return(false);
fatal2:	outerr(0,0,"?cant retach PTY to child frame"); return(false);
fatal3:	outerr(0,0,"?cant read terminal characteristics from PTY"); return(false);
fatal4: outerr(0,0,"?cant get JBTPRV"); return(false);
 end "PTYPTY";

boolean procedure BLDPTY(string username); begin "BLDPTY"          ! "BLDPTY";
  integer TARG;
  if PORT then begin outerr(0,0,"?Circuit already assigned");
    return(false) end;
  if CREPTY(PORT) then begin
    PTY!PORT:=rh(PORT);
    PORT:=lh(PORT);
    username:=scan(username,1,brk);
    FD:=MakFrm(username);
    if FD then begin
!      COPYLIC(FD);	! give parents licenses to child;
      if PTYPTY then begin
        outstr("[child connected as frame "&cvs(fd land '777)&"]"&crlf);
        NO!LF:=true;
        INTERRUPTS(PORT);
        if Waiting then begin
          Waiting:=false;
          TARG:=call(0,"MSTIME")+Wait!Time*1000+500;
          While PORT and Wait!Time and (call(0,"MSTIME")<TARG)
           do call(1,"SLEEP");
          Wait!String:=null;
          end;
        LOG!STR:=USERNAME;
        return(not Com!file);
        end;
      end;
    end;
  LOG!STR:=null;
  PORT:=0;
  return(false);
end "BLDPTY";

string CAPT!UN;
simple procedure CAPTini; BEGIN "CAPTINI"                         ! "captini";
CAPT!UN := "RAILDIAL:804";
  end "CAPTINI";
require CAPTini initialization;

boolean procedure DIAL(string PHONENO); begin "DIAL"                 ! "DIAL";
  DIAL!! := true;
  turn!on(ac!lic);
  PORT:=0; LOG!STR:=null; ZAPCIR;
  outstr("Trying.");
  if not CREATE(CAPT!UN&";",PORT) then return(0);
  outstr(".");
  auxclv(PORT,'20,3);		! msg type;
  auxclv(PORT,'01,3);		! fill;
  auxclv(PORT,'02,3);		! service;
  auxclv(PORT,'01,3);		! tid;
  auxclv(PORT,'01,3);		! modem;
  auxclv(PORT,length(PhoneNo),3);! # length;
  auxclv(PORT,'00,3);		! options (high);
  auxclv(PORT,'03,3);	       	! options (low);
  begin
    integer I;
    string X;
    X := PhoneNo;
    for I := 1 upto 10 do 
	auxclv(PORT,(lop(X)-"0")lsh 4 lor (lop(X)-"0"),3);
  end;
  LOG!STR:=PHONENO;
  begin "bar"
    integer Index;
    integer STAT;
    string Host;
    string RESP;
    RESP := null;
    do
	RESP := RESP & auxclv(PORT,0,0)
    until length(RESP)=20;
    outstr(crlf);
    if not equ(RESP[1 for 2],'40&'01) then begin
	outstr("?Response to Dial-Out Request is illegal:"&crlf);
	while length(RESP) do outstr ("'"&cvos(lop(RESP))&" ");
	outerr(0,0,null);
	return(0);
    end;
    STAT := RESP[3 for 1];
    Index := RESP[4 for 1];
    Host := RESP[5 for 4];
    case STAT of begin
	[0] outstr("[connection established]"&crlf);
	[4] outerr(0,0,"[remote busy]");
	[8] outerr(0,0,"[trunk busy]");
	[12] outerr(0,0,"[no answer]");
	[16] outerr(0,0,"[no carrier]");
	[20] outerr(0,0,"[one of (4,8,C,10)]");
	[24] outerr(0,0,"[service not available at this priority]");
	[28] outerr(0,0,"[service not available at this time]");
	[32] outerr(0,0,"[equipment not available]");
	[36] outerr(0,0,"[equipment out of service]");
	else outerr(0,0,"[unexpected status: "&cvs(stat)&"]")
    end;
    if STAT then return(0);
    auxclv(PORT,'100,3);	! establish modem connection;
    auxclv(PORT,'02,3);		! fill;
    auxclv(PORT,Index,3);	! modem index;
  end;
  if auxclv(PORT,0,0) neq '40
    or auxclv(PORT,0,0) neq '2
    then outerr(0,0,"[modem connection not acknowledged]");
  auxclv(PORT,0,0);
  interrupts(PORT);
  return(true);
  end "DIAL";

  procedure OUTPUT(string FILE); begin "OUTPUT"                    ! "OUTPUT";
    string FBAK;
    if FILEBAD(FILE) then return;
    CLOSE!OUT;
    IF (not FILE) or equ(FILE,"TTY") then return;
    FBAK:=FILE;
    FBAK:=SCAN(FBAK,9,brk);
    FBAK:=FBAK&".BAK";
    lookup(DSK!OUT,FBAK,BRK);	! check for old backup;
    if not BRK then RENAME(DSK!OUT,null,null,BRK); ! remove old backup;
    lookup(DSK!OUT,FILE,BRK);	! get old file;
    if not BRK then RENAME(DSK!OUT,FBAK,null,BRK);	! make new backup;
    enter(DSK!OUT,FILE,BRK);	! create new file;
    close(DSK!OUT);	! start out empty;
    lookup(DSK!OUT,FILE,BRK);	! reopen in update mode;
    enter(DSK!OUT,FILE,BRK);
    if BRK
      then outerr(0,0,"?Can't enter file "&FILE)
    else begin
	OUT!FILE:=FILE;
	COPY:=true;
	DISK!PTR:=point(7,DISK!WRD,6);
	DISK!WRD:=0;
	end;
    end "OUTPUT";

  procedure LIST; begin "LIST"                                       ! "LIST";
    outstr("	Ciao version "&cvs(memory['137])&" - "&ver!date&crlf);
    if PORT then outstr("Remote="&LOG!STR&'40);
    if OUT!FILE then outstr("Output=DSK:"&OUT!FILE&'40);
    outstr("PROMPT="""&CIAO!PROMPT&""""&'40);
    if (ESCAPE<'40) then
      outstr("ESCape=^"&(ESCAPE lor '100)&'40)
    else outstr("ESCape="&ESCAPE&'40);
    outstr("UPD="&cvs(UPD!SEC)&'40);
    outstr("CAPTAIN="&CAPT!UN&'40);
    outstr(crlf);
    outstr((if COPY then "COPY " else "NOCOPY "));
    outstr((if SEE then "SEE " else "NOSEE "));
    outstr((if BLANK then "BLANK " else "NOBLANK "));
    outstr((if HANDSHAKE=YB!HS then "YellowBalls " 
       else if HANDSHAKE=LF!HS then "LineFeeds " else "NoHandshake "));
    outstr((if NOBLIPO then "NOBLIPO " else "BLIPO "));
    outstr((if NOBLIPS then "NOBLIPS " else "BLIPS "));
    outstr((if SendLf! then "SENDlf " else "OMITlf "));
    outstr((if TRACE then "TRACE " else "NOTRACE "));
    outstr(crlf);
    end "LIST";

  procedure HELPOUT(string arg); begin "HELPOUT"
string FOO;
integer TMP;
define HA(nam,sym) = "else if equ(FOO,""nam"") then HO(sym)";
define HO(nam) = "outstr(crlf&nam&crlf)";
FOO:=scan(ARG,1,brk);
  if FOO=0 then outstr(HELP!MESSAGE)
ha(CREAUX,help!CREAUX)
ha(DIAL,help!DIAL)
ha(FORCE,help!FORCE)
ha(HANG,help!HANG)
ha(HELP,help!HELP)
ha(INPUT,help!INPUT)
ha(LIST,help!LIST)
ha(NEST,help!NEST)
ha(OUTPUT,help!OUTPUT)
ha(PTY,help!PTY)
ha(RESUME,help!RESUME)
ELSE IF EQU(foo,"SET") THEN BEGIN
  IF NOT BRK=" " THEN ho(help!SET)
  ELSE foo:=SCAN(arg,1,BRK);
 IF FALSE THEN arg:=arg
ha(BLANK,help!set!BLANK)
ha(NOBLANK,help!set!BLANK)
ha(BLIPO,help!set!BLIPO)
ha(NOBLIPO,help!set!BLIPO)
ha(BLIPS,help!set!BLIPS)
ha(NOBLIPS,help!set!BLIPS)
ha(CAPTAIN,help!set!CAPTAIN)
ha(COPY,help!set!COPY)
ha(NOCOPY,help!set!COPY)
ha(ESCAPE,help!set!ESCAPE)
ha(NOHANDSHAKE,help!set!NOHANDSHAKE)
ha(LINEFEED,help!set!NOHANDSHAKE)
ha(YELLOWBALL,help!set!nohandshake)
ha(OMITLF,help!set!OMIT)
ha(SENDLF,help!set!OMIT)
ha(PROMPT,help!set!PROMPT)
ha(SEE,help!set!NOSEE)
ha(NOSEE,help!set!NOSEE)
ha(TRACE,help!set!TRACE)
ha(NOTRACE,help!set!TRACE)
ha(UPD,help!set!UPD)
ha(WAIT,help!set!WAIT)
END
ha(TIME,help!TIME)
ha(UNATTACH,help!UNATTACH)
ha(WAIT,help!WAIT)
ha(ZAP,help!ZAP)
ELSE IF EQU(foo,"ALL") or equ(foo,"DUMP") THEN BEGIN
  if EQU(foo,"DUMP") then begin
    TMP:=TTY!OUT;
    open(TTY!OUT:=getchan,"DSK",0,0,1,0,0,0);
    lookup(TTY!OUT,"CIAO.DOC",brk);
    if not brk then rename(TTY!OUT,null,null,brk);
    enter(TTY!OUT,"CIAO.DOC",brk);
  ho(help!INTRO);
  end;
  ho(help!CREAUX);
  ho(help!DIAL);
  ho(help!FORCE);
  ho(help!HANG);
  ho(help!HELP);
  ho(help!INPUT);
  ho(help!LIST);
  ho(help!NEST);
  ho(help!OUTPUT);
  ho(help!PTY);
  ho(help!RESUME);
  ho(help!set!HEADER);
  ho(help!set!BLANK);
  ho(help!set!BLIPO);
  ho(help!set!BLIPS);
  ho(help!set!CAPTAIN);
  ho(help!set!COPY);
  ho(help!set!ESCAPE);
  ho(help!set!NOHANDSHAKE);
  ho(help!set!OMIT);
  ho(help!set!PROMPT);
  ho(help!set!NOSEE);
  ho(help!set!TRACE);
  ho(help!set!UPD);
  ho(help!set!WAIT);
  ho(help!TIME);
  ho(help!UNATTACH);
  ho(help!WAIT);
  ho(help!ZAP);
  if equ(foo,"DUMP") then begin
    ho(HELP!examples);
    ho(help!bugs);
    close(TTY!OUT);
    TTY!OUT:=TMP;
    end;
  end
else outerr(0,0,"?Unknown HELP argument "&FOO);
 end "HELPOUT";

  procedure SET(string ARG); begin "SET"                              ! "SET";
    string FOO,FOO2;
    while ARG do begin
      FOO2:=scan(ARG,12,BRK);
      FOO:=FOO2;
      FOO:=scan(FOO,1,BRK);
      if equ(FOO,"?") then outstr(HELP!SET)
      else if equ(FOO[1 to 7],"ESCAPE=") then begin
             ESCAPE:=FOO[8 to 8];
             setbreak(5,ESCAPE&'12,null,"FINS");
             if (length(FOO)<8) then ESCAPE:='777 end
      else if equ(FOO[1 to 4],"ESC=") then begin
             ESCAPE:=FOO[5 to 5];
             setbreak(5,ESCAPE&'12,null,"FINS");
             if (length(FOO)<5) then ESCAPE:='777 end
      else if equ(FOO,"NH") then HANDSHAKE := NO!HS
      else if equ(FOO,"NOHANDSHAKE") then HANDSHAKE := NO!HS
      else if equ(FOO,"LF") then HANDSHAKE := LF!HS
      else if equ(FOO,"LINEFEED") then HANDSHAKE := LF!HS
      else if equ(FOO,"LINEFEEDS") then HANDSHAKE := LF!HS
      else if equ(FOO,"YB") then HANDSHAKE := YB!HS
      else if equ(FOO,"YELLOWBALL") then HANDSHAKE := YB!HS
      else if equ(FOO,"YELLOWBALLS") then HANDSHAKE := YB!HS
      else if equ(FOO,"COPY") then COPY:=true
      else if equ(FOO,"NOCOPY") then COPY:=false
      else if equ(FOO,"SEE") then SEE:=true
      else if equ(FOO,"NOSEE") then SEE:=false
      else if equ(FOO,"BLANK") then BLANK:=true
      else if equ(FOO,"NOBLANK") then BLANK:=false
      else if equ(FOO,"BLIPO") then NOBLIPO:=false
      else if equ(FOO,"NOBLIPO") then NOBLIPO:=true
      else if equ(FOO,"BLIPS") then NOBLIPS:=false
      else if equ(FOO,"NOBLIPS") then NOBLIPS:=true
      else if equ(FOO,"SENDLF") then SendLf!:=true
      else if equ(FOO,"OMITLF") then SendLf!:=false
      else if equ(FOO,"SEND") then SendLf!:=true
      else if equ(FOO,"OMIT") then SendLf!:=false
      else if equ(FOO,"TRACE") then TRACE:=true
      else if equ(FOO,"NOTRACE") then TRACE:=false
      else if equ(FOO[1 to 4],"UPD=") then UPD!SEC:=cvd(FOO[5 to inf])
      else if equ(FOO[1 to 8],"CAPTAIN=") then CAPT!UN := FOO[9 to inf]
      else if equ(FOO[1 to 8],"PROMPT=""") then begin
        ARG:=FOO2[9 to inf]&" "&ARG;
        CIAO!PROMPT:=scan(ARG,13,brk);
        While brk="""" do begin
          brk:=0;
          if lop(ARG)="""" then
            CIAO!PROMPT:=CIAO!PROMPT&""""&scan(ARG,13,brk); end; end
      else if equ(FOO[1 to 6],"WAIT=""") then begin
        ARG:=FOO[7 to inf]&" "&ARG;
        Wait!String:=scan(ARG,13,brk);
        While brk="""" do begin
          brk:=0;
          if lop(ARG)="""" then
            Wait!String:=Wait!String&""""&scan(ARG,13,brk); end;
        if equ(ARG[1 for 1]," ") then lop(ARG);
        Wait!Time:=cvd(scan(ARG,1,brk));
        CH!String:=null;
        if Wait!Time=0 then Wait!Time:='77777777;
        Waiting:=true;
        if PORT then intmap(tinass(PORT,cause!tty!chr,0),CHARACTER,0);
        end          
      else begin 
	outerr(0,0,"?Unrecognized token: "&FOO);
	done;
	end;
      end;
    end "SET";

  simple procedure DIRECT!FILE(string CMD; string ARG);
  begin "DIRECT!FILE"                                         ! "DIRECT!FILE";
    own string PPN,AUN,S,FILE,UNAME;
    boolean CIAO!FILE,CUR!FILE,NAM!FILE;
    integer I;
    CIAO!FILE:=true; CUR!FILE:=true; NAM!FILE:=true;
    UNAME:=scan(CMD,10,brk);
    if brk=")" then begin CIAO!FILE:=false; CUR!FILE:=false end
    else begin CMD:=UNAME; UNAME:=null end;
    FILE:=scan(CMD,8,brk);
    if brk=";" then begin 
      CUR!FILE:=false;
      if FILE=null then NAM!FILE:=false else CIAO!FILE:=false end;
    if CMD=null then CMD:=FILE;
    if FILEBAD(FILE) then return;
    if COM!FILE then begin
      NEST!LEVEL:=NEST!LEVEL+1;
      NEST!FILE[NEST!LEVEL]:=COM!FILE;
      COM!FILE:=0;
      end;
    for I:=0 step 1 until 9
      do COMMAND!PARAMETER[I]:=SCAN(ARG,1,brk);
    AUN:="["&cvos(lh(calli(-'23,'41)))
      &","&cvos(rh(calli(-'23,'41)))&"]";
    PPN:="["&cvos(lh(calli(2,'41)))
      &","&cvos(rh(calli(2,'41)))&"]";
    open(Com!File:=getchan,"DSK",1,5,0,256,BRK,EOF);
    I:=true;
    if CUR!FILE and not equ(Current!file,null) then begin
      lookup(Com!file, Current!File, EOF);
        while not EOF do begin
          S:=input(Com!file,6);
          if S="@" and equ(S[2 to inf], CMD) then return;
          end;
    end;
    if CIAO!FILE then begin
      Current!File:="CIAO.COM";
      lookup(Com!File, Current!file, EOF);
        while not EOF do begin
          S:=input(Com!File,6);
          if S="@" and equ(S[2 to inf],CMD) then return;
          end;
    end;
    if NAM!FILE then begin
      Current!file:=Uname&File;
      lookup(Com!File,Current!file, EOF);
      if not EOF then begin
        S:=input(Com!File,6);
        if not S="@" then begin
          lookup(COM!FILE, Current!FILE, EOF); return end;
        if equ(S[2 to inf],CMD) then return;
        while not EOF do begin
          S:=input(Com!File,6);
          if S="@" and equ(S[2 to inf],CMD) then return;
          end;
        I:=true; end
      else I:=false;
    end;
    if CIAO!FILE and not equ(AUN,PPN) then begin
      Current!File:="CIAO.COM"&AUN;
      lookup(Com!File, Current!file, EOF);
        while not EOF do begin
          S:=input(Com!File,6);
          if S="@" and equ(S[2 to inf],CMD) then return;
          end;
      I:=true;
    end;
    if NAM!FILE and not equ(AUN,PPN) and equ(UNAME,null) then begin
      Current!file:=FILE&AUN;
      lookup(Com!File, Current!file, EOF);
      if not EOF then begin
        S:=input(Com!File,6);
        if not S="@" then begin lookup(COM!FILE, FILE, EOF); return end;
        if equ(S[2 to inf],CMD) then return;
        while not EOF do begin
          S:=input(Com!File,6);
          if S="@" and equ(S[2 to inf],CMD) then return;
          end;
        I:=true; end
      else I:=false;
    end;
    if I then outerr(0,0,"?Procedure "&CMD&" not found")
    else outerr(0,0,"?Command file "&UNAME&FILE&" not found");
    Current!File:=null;
    end "DIRECT!FILE";


simple procedure WAIT(integer TIME(0)); begin "WAIT"                 ! "WAIT";
  own integer TARG;
    if PORT and (TIME=0) then begin
      YellowBall;
      if not !SKIP! then outerr(0,0,"?HIBER failed durring WAIT");
      end
    else if PORT and (Time>0) then begin
      TARG:=call(0,"MSTime")+Time*1000+500;
      while PORT and (call(0,"MSTIME")<TARG) do call(1,"SLEEP");
      end
    else if PORT and (Time<0) then begin
      calli(hl(1)-Time,HIBER);
      if not !SKIP! then outerr(0,0,"?HIBER failed during WAIT -n");
    end;
  end "WAIT";

simple procedure FORCE(string MSG); begin "FORCE"                   ! "FORCE";
  integer TARG;
  if Msg[inf for 1]= "" 
	then Msg := Msg[1 to inf-1]
	else Msg := Msg & cr;
  if PORT then begin
    while Msg do  begin
      TARG:=lop(msg);
      if TRACE then TRACEOUT(TARG);
      auxclv(PORT,targ,AX!O8) end;
    if Waiting then begin
      Waiting:=false;
      intmap(tinass(PORT,cause!tty!chr,7),CHARACTER,0);
      TARG:=call(0,"MSTIME")+Wait!Time*1000+500;
      While PORT and Wait!Time and (call(0,"MSTIME")<TARG)
        do call(1,"SLEEP");
      Wait!String:=null;
      end;
    end;
  end "FORCE";

simple procedure UNATT(string ARG); begin "UNATT"                  ! "UNATT";
  integer TMP!FILE;
  own string FILE;
  File:=SCAN(ARG,1,brk);
  if FILEBAD(FILE) then return;
  if FILE then begin
    FD:=MakFrm;
    if FD then begin
      COPYLIC(FD);	! give parents licenses to child;
      open(TMP!FILE:=getchan,"DSK",1,0,2,0,0,0);
      enter(TMP!FILE,xxx(FD)&"CIO.TMP",brk);
      if brk then outerr(0,0,"?Can not enter file "&xxx(FD)&"CIO.TMP")
      else begin
        out(TMP!FILE,FILE&" "&ARG&crlf);
        out(TMP!FILE,"Quit"&crlf);
        close(TMP!FILE);
        release(TMP!FILE);
        RunFrm(FD,MYNAME,1);
        if !SKIP! then outstr("[ "&MYNAME&" started in frame "&
    	cvs(FD land '777)& "]"&crlf)
        else outerr(0,0,"?can not RUN "&MYNAME&" in frame "&cvs(FD land '777));
        end
      end
    end
  else  begin
    calli(calli('777777000006,'41) lor (1 lsh 34),SETPRV);
    outstr("frame "&cvs(PJOB)&" detaching...");
    if not TTY!OUT then begin
      open(TTY!OUT:=getchan,"DSK",0,0,1,0,0,0);
      enter(TTY!OUT,xxx(PJOB)&"CIO.OUT",brk);
      end;
    ATTACH;
    end;
end "UNATT";

simple procedure HANG; begin "HANG"                                  ! "HANG";
  YellowBall;
  ! wait for an orange ball;
  auxclv(PORT,0,AX!HNG);
  calli(10000,HIBER);
  ! wait for acknowledge interrupt;
  end "HANG";

simple procedure SLEEP(integer TIME); begin "SLEEP"                 ! "SLEEP";
  own integer TARG,IT;
  if TIME=0 then TIME:='777777777;
  do begin "bigone"
    TARG:=(IT:=call(0,"MSTIME"))+TIME*1000;
    CHR!RCD:=0;
    do begin
      call(5,"SLEEP");
      if (PORT=0) then done "bigone";
      if call(0,"MSTIME")<IT then begin
	IT:=call(0,"MSTIME");
	TARG := TARG - 1000*60*60*24;
      end;
      if CHR!RCD then continue "bigone";
    end until TARG < call(0,"MSTIME");
  end until CHR!RCD=0;
end "SLEEP";


begin "MAIN"                                                         ! "MAIN";
  string COM;
  BLANK:=true; BAUD:=2; ESCAPE:="P" land '37; HANDSHAKE:=NO!HS;
  COPY:=false; SEE:=false; DIAL!UNAME:="LOCAL"; TTY!OUT:=0; TRACE:=false;
  COM!FILE:=0; NEST!LEVEL:=0; UPD!SEC:=60; NOBLIPS:=false; SENDLF!:=false;
 NOBLIPO:=true; CHR!RCD:=0;
  CIAO!PROMPT:="ciao:"; Current!file:=null; Wait!String:=null; Wait!Time:=0;
  Waiting:=false; No!prompt:=false;
  ARG:=null;
! !!!!  ttyup(true);
  setbreak(1," ",null,"KINS");
  setbreak(2,null,'12,"FXNA");
  setbreak(3,null,"-/() ","KINS");
  setbreak(4,'12,'15,"FINS");
  setbreak(5,ESCAPE&'12,null,"FINS");
  setbreak(6,'12,'15,"KINS");
  setbreak(7,null,null,"KXNS");
  setbreak(8,";"&'12,null,"KINS");
  setbreak(9,".",null,"FINS");
  setbreak(10,")",null,"KINA");
  setbreak(11,"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.",null,"KXNS");
  setbreak(12," ",null,"FINS");
  setbreak(13,"""",null,"FINS");
  if DETACHED then begin
    open(TTY!OUT:=getchan,"DSK",0,0,1,0,0,0);
    enter(TTY!OUT,xxx(PJOB)&"CIO.OUT",brk);
    end;
  open(DSK!IN:=getchan,"DSK",0,5,0,1024,BRK,EOF);
  open(DSK!OUT:=getchan,"DSK",'14,0,5,0,0,0);
  Backup;	! rescan command line if any;
  auxclv(-1,0,AX!SIL);	! check for a line in the tty input buffer;
  if not !SKIP! then begin
    if RPGSW then begin
      !	started with an offset of 1, probably by RUN uuo;
      ARG := (xxx(PJOB)&"CIO.TMP");
      RPGSW := false;
      end
    else begin
      ! started at regular startpoint, probably by RUN uuo;
      ARG := null;
      end
    end
  else begin
    ! started at regularstartpoint, probably by a RUN or START command;
    ttyinl(8,BRK);	! skip passed the semicolon;
    if brk=";" then no!prompt:=true;
  end;
  if ARG then Direct!FILE(ARG,null);
  while true do begin "COMMAND"                                   ! "COMMAND";
    auxclv(-1,0,AX!SIL);
    while COM!FILE do begin
      ARG:=input(COM!FILE,4);
      if EOF or ARG="@" then begin
        close(COM!FILE); release(COM!FILE);
        if NEST!LEVEL then begin
          COM!FILE:=NEST!FILE[NEST!LEVEL];
          NEST!LEVEL:=NEST!LEVEL-1;
          end
        else COM!FILE:=0;
        end
      else done;
      end;
    if not COM!FILE then begin
      if DETACHED then outerr(0,1,null)
      else begin
        if not no!prompt then outstr(CIAO!PROMPT);
        no!prompt:=false;
        ARG:=inchwl;
        end;
      end;
    COM:=scan(ARG,1,BRK);
    begin "Fixup ESC characters"
	string A;
	integer Brk;
	A := null;
	do begin
	    A := A & Scan(Arg,5,Brk);	! scan to end-of-line or ESC;
	    if Brk=0 then done;
            SCAN(ARG,7,BRK);	! get ESCed character;
          if not PROCESS!ESCAPE(BRK,A,COM!FILE,true) then A := A&BRK;
	    end until 0;
	Arg := A;
	end;

    caseof(COM)
      cof(null,0) ;
      cof(";",1) ;
      cof("NEST",1) DIRECT!FILE(scan(ARG,1,brk),ARG);
      cof("CREAUX",1) if BUILD(ARG,TTY!ECHO) then SLAVE(TTY!ECHO);
      cof("PTY",1) if BLDPTY(ARG) then SLAVE(false);
      cof("DIAL",4) if DIAL(ARG) then SLAVE(false);
      cof("FORCE",5) FORCE(ARG);
      cof("WAIT",4) WAIT(cvd(ARG));
      cof("TIME",4) SLEEP(cvd(ARG));
      cof("OUTPUT",1) OUTPUT(ARG);
      cof("INPUT",1) if PORT then SEND(ARG) else outerr(0,0,"?no circuit");
      cof("SET",3) SET(ARG);
      cof("LIST",3) LIST;
      cof("ZAP",3) ZAPPED;
      cof("HELP",4) HELPOUT(ARG);
      cof("HANG",4) if CARRIER then HANG;
      cof("QUIT",1) outerr(0,1,null);
      cof("UNATTACH",1) UNATT(ARG);
      cof("RESUME",1) if PORT then SLAVE(TTY!ECHO)
        else outerr(0,0,"?No circuit");
      cof("?",1) HELPOUT(ARG);
      celse DIRECT!FILE(COM,ARG);
      casend(COM);
    end "COMMAND";
  end "MAIN";
end "CIAO"
   'JMU