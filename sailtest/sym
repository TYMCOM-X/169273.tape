COMMENT \HISTORY
AUTHOR,REASON
021  102100000060 \;

COMMENT \
VERSION 17-1(48) 24-JAN-79 by SDD remove EXPO, TYMSHR uses line nos*10
VERSION 17-1(47) 24-JAN-79 by SDD get rid of EXPO macro
VERSION 17-1(46) 10-OCT-79 by SDD get rid of AOSSOS and use expression
VERSION 17-1(45) 15-MAY-79 by SDD SCNACT turn off PRMSCN for , ) p14
VERSION 17-1(44) 05-DEC-78 by SDD replace decimal powers table p24:27
VERSION 17-1(43) 27-NOV-78 by SDD fix numscan for overspc'd nums p24:27
VERSION 17-1(42) 25-OCT-78 by SDD add nofill,noerror cnt to SCNACT p14
VERSION 17-1(41) 25-OCT-78 by SDD no errmes in SCNUMB if falsec p24:27
VERSION 17-1(40) 3-OCT-78 by SDD rewrite for better string handling
VERSION 17-1(38) 4-14-75 BY JFR ANOTHER PASS AT BAIL COORDINATE FIXES P.6
VERSION 17-1(37) 3-1-75 BY RLS CHECK FOR END OF BUFFER IN TENEX ADVBUF (PROB. SHOULD BE ADDED TO DEC ALSO)
VERSION 17-1(36) 2-8-75 BY JFR BAIL SOURCE POINTERS P.6
VERSION 17-1(35) 11-17-74 BY JFR BAIL SOURCE FILE POINTER BUGS P. 6,21
VERSION 17-1(34) 10-16-74 BY JFR FIX BAIL SOURCE FILE COUNTING
VERSION 17-1(33) 10-10-74 BY JFR REVISE WAY BAIL PUTS OUT TEXT FILE POINTERS
VERSION 17-1(32) 9-26-74 BY JFR BAIL INSTALLED 9-19-74.  FIX VERSION, AUTHOR, REASON STUFF
VERSION 17-1(31) 9-15-74 BY HJS BUG #TG# PREVENT PARSE STACK OVERFLOW WHEN SCANNING ACTUAL PARAMETERS TO MACROS 
VERSION 17-1(30) 5-30-74 BY RLS TENEX FIX #SI# BETTER LISTING FORMAT
VERSION 17-1(29) 5-30-74 
VERSION 17-1(28) 5-28-74 BY RHT BUG #SD# NEEDED A FLAG TO DETECT EXTERNAL-INTERNAL CHANGES
VERSION 17-1(27) 4-12-74 BY RHT %BI% ASS RECORD STUFF TO ENTID
VERSION 17-1(26) 3-17-74 BY RLS INSTALL TENEX
VERSION 17-1(25) 3-17-74 
VERSION 17-1(24) 2-5-74 BY HJS BUG #RA# ALLOW TEXT PAST FINAL END OF PROGRAM 
VERSION 17-1(23) 1-29-74 BY HJS BUG #QV# ASSIGNC PROBLEMS
VERSION 17-1(22) 1-25-74 BY RHT BUG #QO# PNAME MAY BE SPLIT BY STRING SPACE EXPANSION
VERSION 17-1(21) 1-11-74 BY JRL CHANGE MACRO EXPANSION LIST CHARACTER
VERSION 17-1(20) 12-14-73 BY RHT BUG #PZ# A KLUGE THAT NO LONGER WORKED FIXED BY NEW DCS KLUGE
VERSION 17-1(19) 12-14-73 
VERSION 17-1(18) 12-7-73 BY JRL REMOVE SPECIAL STANFORD CHARACTERS
VERSION 17-1(17) 11-27-73 BY RLS BUG #PF# AVOID DYING IF SOURCE FILE ENDS IN FF
VERSION 17-1(16) 11-27-73 
VERSION 17-1(15) 11-25-73 BY JRL FEAT %AN% HAVE SOURCE!FILE SWITCHING CHECK ARG AS STRING CONSTANT
VERSION 17-1(14) 11-16-73 BY HJS BUG #PC# OVERWRITNG FIRST LINE IN CREF 
VERSION 17-1(13) 11-10-73 BY KVL MERGE:CORERR
VERSION 17-1(12) 9-24-73 BY HJS BUG #OH# NO CREFFING OF MACRO FORMALS ALLOWED
VERSION 17-1(11) 9-24-73 
VERSION 17-1(10) 9-21-73 BY HJS INHIBIT LISTING IN FALSE PART OF CONDITIONAL COMPILATION 
VERSION 17-1(9) 9-21-73 BY RHT PATCH UP VERSION STUFF
VERSION 17-1(7) 9-21-73 BY HJS MAKE BUG OG FIX RIGHT
VERSION 17-1(6) 9-19-73 BY HJS BUG #OG# SAVE PNAME COUNT BEFORE SGCOL
VERSION 17-1(5) 9-19-73 
VERSION 17-1(4) 9-17-73 BY HJS BUG #OF# MAKE SURE PARSE TOKEN IN AC A WHEN GOING TO STACK
VERSION 17-1(3) 9-17-73 
VERSION 17-1(2) 9-17-73 
VERSION 17-1(1) 8-14-73 BY RHT TURN JRST .CORERR AT GETTOP BACK TO JRST CORERR
VERSION 16-2(48) 7-12-73 BY HJS SAVE CHARACTER COUNT IN CASE GARBAGE COLLECTION HAPPENS DURING MACRO ACTUAL SCANNING
VERSION 16-2(47) 6-20-73 BY HJS IFCR, REDEFINE, EVALDEFINE, AND ASSIGNC IMPLEMENTATION 
VERSION 16-2(46) 6-10-73 BY JRL BUG #MQ# LPNT NOT PROPERLY SAVED FOR BACKUP WHEN SAVCHR=0
VERSION 16-2(45) 6-1-73 BY DCS BUG #MP# KEEP REMCHR HONEST (STRNGC BUG)
VERSION 16-2(44) 3-19-73 BY HJS ALLOW TEMPORARY OVERRIDING OF NULL DELIMITERS MODE
VERSION 16-2(43) 3-13-73 BY JRL REMOVE REFERENCES TO WOM,SLS,GAG,NODIS
VERSION 16-2(42) 3-12-73 BY RHT BUG #LS# OWN THINGS GETTING THE WRONG LEVEL INFO
VERSION 16-2(41) 1-31-73 BY HJS ADD NOEMIT, ACKSAV, AND SBSAV FOR EXPR!TYPE
VERSION 16-2(40) 1-17-73 BY HJS BUG #LC# MACRO FORMALS ARE NOT MACRO REDEFINTION
VERSION 16-2(39) 1-17-73 
VERSION 16-2(38) 12-11-72 BY HJS DISABLE ENDC PARSER SWITCH TRIGGER IN WHILEC, CASEC, FORC, AND FORLC BODIES
VERSION 16-2(37) 12-2-72 BY HJS SAVE BITS DURING CONDITIONAL COMPILATION AND MACRO DEFINITIONS (CBTSTK AND DBTSTK)
VERSION 16-2(36) 11-20-72 BY JRL FIX SUGG BY R. SMITH AT CHKPRC
VERSION 16-2(35) 11-19-72 BY HJS BUG #JZ# CORRECTION - MACRO REDEFINITION AND RESERVED WORD REDEFINITION IN ENTERS
VERSION 16-2(34) 11-15-72 BY HJS INSERT DEFDLM QSTACK FOR DEFLUK BIT OF FF FOR COMPILE-TIME MACROS WITHIN MACROS
VERSION 16-2(33) 11-5-72 BY DCS BUG #JZ# CHANGE MACRO SCOPE RULES
VERSION 16-2(32) 11-3-72 BY DCS SIMILARLY, ALLOW ALL EXTERNALS TO OVERRIDE
VERSION 16-2(31) 11-2-72 BY DCS BUG #JX# ALLOW INTRNL PROC TO OVERRIDE EXTRNL ONE.
VERSION 16-2(30) 10-24-72 BY HJS EMIT ERR MSG FOR UNINIT MACRO VAR USE
VERSION 16-2(29) 7-5-72 BY DCS BUG #IF# FIX SOME GOERGE BUGS
VERSION 15-6(18-28) 7-5-72 
VERSION 15-6(17) 3-10-72 BY DCS REPLACE RING,ULINK MACRO WITH VARIOUS ROUTINES
VERSION 15-6(8-16) 3-9-72 
VERSION 15-6(7) 2-21-72 BY HJS THE BRAVE NEW PARSER WORLD
VERSION 15-2(6) 2-18-72 BY DCS BUG #GP# CHECK OLD FORMALS AGAINST NEW FORMALS
VERSION 15-2(5) 2-5-72 BY DCS BUG #GJ# ADD LSTON LIST-CONTROL STUFF
VERSION 15-2(4) 2-5-72 BY DCS BUG #GI# REMOVE TOPSTR
VERSION 15-2(3) 2-1-72 BY DCS BUG #GE# LPSBOT FROM USER TABLE TO COMPILER DATA
VERSION 15-2(2) 12-22-71 BY DCS BUG #FT# PROVIDE LINE NUMBER IF NOT SOS FILE
VERSION 15-2(1) 12-2-71 BY DCS INSTALL VERSION NUMBER

\;


SUBTTL	SCAN
	LSTON	(SYM)
BEGIN SYM

DSCR SCANNER -- get next "ATOM" from source file
CAL PUSHJ from PARSE (or recursively)
PAR PNEXTC is bp to next input char (from file or macro)
 SAVCHR, if non-zero, is a scan-ahead char which should
  be considered first.
 File variables, Listing variables used by I/O part.
 Define stack, variables, macro semantics used when
  recurring into macros

RES The ATOM will be either:

1. An operator or other character atom, in which case
	the Parse token representing it will be placed in the
	parse stack, a 0 in the generator stack (null entry).

2. A reserved word, in which case the Parse token will be 
	placed on the parse stack from the word's symbol 
	entry, and again a null semantic entry will be stacked.

3. An IDENTIFIER, in which case the Parse token for the appro-
	iate class of IDs will appear on the parse stack, the
	Semantics for the symbol on the generator stack. If the
	symbol is undefined, a 0 is represents null Semantics.

4. A STRING or numeric constant. These entities are ENTERed 
	in their respective symbol tables if previously 
	undefined, and the stacks are set up as above.


 In all cases, the semantic entry will be repeated in the cell
	NEWSYM. In those cases where a hash was made, the
	MOVE or MOVS instr to fetch the list on which the symbol
	appears (or will appear after ENTERy) is located in
	the cell HPNT. For string constants or identifiers, the
	string	identifier is left in PNAME, PNAME+1. For numeric
	arguments, the value is left in SCNVAL. DBLVAL is zeroed
	in these cases.

SID SCANNER uses temporary ACs indiscriminately, so look out for it.
 Many variables are changed as a result of calling SCANNER.



BITDATA (SCNWRD -- LISTING CONTROL, ETC.)

Comment $ SCAN table -- good bits that make the whole thing work $

^^LSTEXP__400000		;ON IF "<"-">" PAIRS TO BE PRINTED
^^MACEXP__200000		;EXPAND MACRO TEXTS
^^MACLST__100000		;LIST MACRO NAMES BEFORE EXPANSION
^^LINESO__ 40000		;ON IF LINE NUMBERS SHOULD BE PRINTED
^^PCOUT __ 20000		;ON IF PCNT SHOULD BE PRINTED
^^CREFIT__ 10000		;ON IF A CREF S HAPPENING
^^MACIN __  4000		;ON IF IN A MACRO EXPANSION
^^EOFOK __  2000		;ON IF CAN GET EOF WITHOUT FATALITY
^^BACKON__  1000		;ON IF LISTING BACK ON AFTER PARAM RESCAN
^^LOKPRM__  400			;ON IF LOOKING FOR POSSIBLE MACRO PARAM
^^RDYPRM__  200			;GETTING READY FOR MACRO PARAM (RANSCN)
^^INLIN __  100			;TREAT @ AS DELIMITER IN IN-LINE CODE
^^INSWT __   40			;SCANNING A SWITCHED-TO SOURCE FILE
^^NOLIST__    1			;ON IN RH IF NO LISTING HAPPENING NOW

BITDATA (SCANNER TABLE -- character property bits)

SPCL  __400000		;special character--RH has address of routine
			;  to handle this condition MUST be sign bit
ATSIGN__ 20000		;@ -- REAL EXPONENT COMING
DOT   __ 10000		;. -- DECIMAL POINT
QUOCTE__  4000		;' -- OCTAL NUMBER COMING
			;  moved from 40, 4000 was NUMB (redundant)
DIG   __  2000		;0 THRU 9
LETDG __  1000		;legal sail identifier character (not first)
			;secretly, first can be any char with this on
			;and DIG+DOT+ATSIGN+QUOCTE (number parts) off
QUOTE __   400		;" -- STRING CONSTANT DELIMITER
^NEST __   200		; NESTABLE CHARACTER
^LNEST__   100		; LEFT NESTED CHARACTER
PAIRPT__    40		;first char of a special two-char unit like :=
			;this is new  used to be QUOCTE here

; BITS FOR NUMBER SCANNER

INTOV __200000		;INTEGER OVERFLOW
REALOV__100000		;REAL OVERFLOW
EXPNEG__ 40000		;NEGATIVE EXPONENT
NUMNST __3		; NUMBER OF NESTABLE CHARACTERS
RPAROF __2		; RIGHT PAREN OFFSET FOR LOCNST ENSTRY
^NUMCHA __200		; NUMBER OF CHARACTERS
^DELNUM __4		; NUMBER OF DELIMITERS AS INPUT TO REQ. DEL.


TABCONDATA (SCANNER CHARACTER TABLE)

DEFINE IGL <XWD SPCL,IGLCHR>
;;was: DEFINE OPER <.-SCNTBL>   (unused)
DEFINE LTR <XWD LETDG,.-SCNTBL>
DEFINE NESTED <<XWD NEST,0>>
DEFINE LNESTD <<XWD NEST+LNEST,0>>
define paired <<XWD pairpt,0>>

	IGL			;this is for special EOF character
^SCNTBL:
	XWD	SPCL,SEOB		;0 -- END OF BUFFER
	LTR 				;DWNARROW
	LTR 				;ALPHA
	LTR 				;BETA
	RAND				;AND
	RNOT				;NOT
	RIN				;ELEMENTOF
	REPEAT 2,<LTR >			;PI, LAMBDA
	0				;TAB
	XWD SPCL,SEOL			;LF -- END OF LINE
	0				;VTAB
	XWD SPCL,SEOP			;FF -- END OF PAGE
	0				;CARRIAGE RETURN
	RINF				;INFINITY.
	LTR 				;PARTIAL
	LTR 				;LEFTHORSESHOE
	LTR 				;RGHTHORSESHOE
	RINTER				;INTERSECT
	RUNION				;UNION
	LTR 				;FOREACH
	LTR 				;EXISTS
	RXOR				;XOR
	RSWAP				;BOTHWAYSARROW
	LTR 				;UNDERLINE ?
	LTR				;RGT ARRW
	RAND				;STANFORD TILDE (AND)
	RNEQ 				;NTEQUAL
	RLEQ				;LTEQUAL
	RGEQ				;GTEQUAL
	REQV				;EQUIVALENCE
	ROR				;OR
	0				;SPACE
 	XWD LETDG,30			; ! -- SAME AS UNDERLINE.
	XWD	QUOTE,.-SCNTBL		; "
	LTR				; #
	LTR				; $ 
	TPRC				; %
	TANDD				; &
	XWD	LETDG+QUOCTE,.-SCNTBL	; ' (had NUMB)
	LNESTD+TLPRN			; (
	NESTED+TRPRN			; )
	paired+TTIMS			; *		pair is ** (^)
	TPLUS 				; +
	TCOMA				; ,
	TMINUS				; -
	XWD	LETDG+DOT,.-SCNTBL	; . (had NUMB)
	TSLSH				; /
	REPEAT 12,<XWD LETDG+DIG,.-SCNTBL>	;DIGITS (had NUMB)
	paired+TCOL			; :		pair is := (_)
	TSEMI	 			; ;
	paired+TLES			;LESS THAN	pair is (LEQ)
	TEQU       			; =
	paired+TGRE			;GREATER THAN	pair is (GEQ)
	TQUES				;?
	XWD	LETDG+ATSIGN,.-SCNTBL	; @  (had NUMB)
	REPEAT =26,<LTR>			;UPPER CASE LETTERS
	LNESTD+TLBR			; [
	LTR  				; TILDE
	NESTED+TRBR			; ]
	TUPRW				; ^
	TLARW				; _
	RASSOC				;`
	REPEAT =26,<LTR-40>			;LOWER CASE LETTERS
	LNESTD+RSETO			; {
	TVERT				; |
	NESTED+RSETC			; RIGHT CURLY BRACKET
	NESTED+RSETC			; RIGHT CURLY BRACKET
; 175 AND 176 WILL BOTH BE CURLY BRACKETS FOR A WHILE.
	XWD	SPCL,EOM		;177 -- END MACRO OR PARAM
ENDSCN_.


DATA (SCANNER PARSE TOKENS)

COMMENT \
  These variables provide symbolic access to the PARSE token
 numbers for several delimiter characters -- they are used in
 those cases where the SCANNER or some EXEC needs to examine
 a value directly
\
%ATS:	TINDR		;BITS FOR @ DELIMITER IN INLINE(SEE SCNUMB)
%COMMENT: RCOMME+1B0
^^%ID:	TI
%NUMCON: TICN		;ARITHMETIC CONSTANT.
%SEMICOL: TSEMI
^^%STCON:TSTC		;STRING CONSTANT.

ZERODATA (SCANNER VARIABLES)

BAIL<
^^BCORDN: 0	;DEBUGGER COORDINATE NUMBER.  RIGHT HALF CONTAINS CURRENT
		;COORDINATE, LEFT HALF IS ZERO IF WE ARE NOT NOW PUTTING OUT
		;COORDINATES TO THE .SM1 FILE, AND NON-ZERO IF WE ARE.
BCRDW1:	0	;SPACE TO SAVE COORD INFO TO BE WRITTEN TO .SM1 FILE, SINCE
BCRDW2:	0	;  LOCATION MUST BE MARKED AT BEGINNING OF STATEMENT, BUT
		;  WE DONT KNOW IF WE WANT A COORD UNTIL THE END OF STATEMENT
>;BAIL

^^DEFRN2: 0	;TEMP RING-VARIABLE WHILE SCANNING MACRO ACTUAL PARAMS

COMMENT \
HPNT, HSPNT -- When the hashing routines (SHASH, NHASH) locate the
  right bucket pointer in the appropriate bucket Semblk, they create
  a [MOVE LPSA,addr] or [MOVS LPSA,addr] instruction which will fetch
  this pointer, and put it into HPNT -- also leaving it in LPSA. They
  then execute the instruction to begin their lookup phases.  ENTERS
  again uses this pointer when adding a new Semblk to a bucket -- first
  as is, to fetch the old pointer, then modified to MOVEM or MOVSM, to 
  update the bucket.
  HSPNT is the saved HPNT value for the last string constant scanned.
  The "string constant as comment" EXEC uses it to remove the constant
  from the bucket (provided, of course, that it hasn't also been used
  as a string constant).
\
^HPNT: 0

^HSPNT: 0

^^LOCMBD:  BLOCK 2		; MACRO BODY DELIMITERS BLOCK
^^LOCMPR:  BLOCK 2		; MACRO PARAMETER DELIMITERS BLOCK
BAKDLM:	   0		; A FLAG WHICH IS SET TO -1 IF DLMSTG IS ON
				;  (I.E. ONE WANTS A DELIMITED MACRO BODY)
				;  AND QUOTES ARE USED INSTEAD BECAUSE A 
				;  REQUIRE NULL DELIMITERS STATEMENT WAS NOT
				;  USED.
^^CURMBG:  0			; CURRENT MACRO BODY BEGIN DELIMITER
^^CURMED:  0			; CURRENT MACRO BODY END DELIMITER 
^^CURPBG:  0			; CURRENT PARAMETER BEGIN DELIMITER
^^CURPED:  0			; CURRENT PARAMETER END DELIMITER
^^DELSTK:  0			; DELIMITER "BLOCK-STRUCTURE" STACK
^^LOKDLM:  0			; DLMSTG (LOOKING FOR DELIMITERS FLAG) QSTACK
^^DEFDLM:  0			; DEFLUK (SCANNING A MACRO BODY OR LOOKING FOR
				;  ACTUAL PARAMETERS) QSTACK
^^CBTSTK:  0			; POINTER TO QSTACK FOR SAVING BITS WHILE SCANNING 
				;  CONDITIONAL COMPILATION EXPRESSIONS
^^DBTSTK:  0			; POINTER TO QSTACK FOR SAVING BITS WHILE SCANNING 
				;  MACRO DEFINITIONS
^^ENDCTR:  0			; POINTER TO QSTACK INDICATING WHETHER OR NOT ENDC 
				;  SHOULD TRIGGER A PARSER SWITCH (NO IF ONE IS 
				;  SCANNING A WHILEC, CASEC, FORC, OR FORLC BODY)
^^REQDLM:  0			; REQUIRE DELIMITER STATEMENT SEEN FLAG
^^SWBODY:  0			; SPECIAL DELIMITER DEFINITION SEEN
^^BNSTCN:  0			; NESTED DELIMITER COUNT
^^LOCNST:  BLOCK NUMNST  	; NESTABLE CHARACTERS BLOCK
^^NSTABL:  BLOCK NUMCHA		; NESTABLE CHARACTERS ADDRESS INDEX BLOCK

^^NOEMIT:  0			; DON'T EMIT CODE FLAG FOR THE EMITTER
^^ACKSAV:  BLOCK 13		; SAVE ACKTAB HERE WHILE EVALUATING EXPR!TYPE
^^SBSAV:   BLOCK 13		; SAVE $SBITS CORRESPONDING TO ACKSAV VALUES WHILE 
				;  EVALUATING EXPR!TYPE (AVOIDS HARMFUL SIDE 
				;  EFFECTS OF CODE GENERATORS)
^^ADPTSV:  0			; ADEPTH VALUE BEFORE EXPR!TYPE PROCESSING
^^PCNTSV:  0			; PCNT VALUE BEFORE EXPR!TYPE PROCESSING
^^SDPTSV:  0			; SDEPTH VALUE BEFORE EXPR!TYPE PROCESSING
^^RSTDLM:  0			; TEMPORARY OVERRIDING OF NULL DELIMITERS MODE FLAG
^^RECSTK:  0			; POINTER TO QSTACK INDICATING WHETHER MACROS SHOULD 
				;  BE EXPANDED IN THE FALSE PART OF CONDITIONAL 
				;  COMPILATION 
^^IFCREC:  0			; FLAG INDICATING WHETHER MACROS SHOULD BE EXPANDED IN 
				;  THE FALSE PART OF CONDITIONAL COMPILATION 
NULCNT:	   0			; COUNTER INDICATING THE NUMBER OF ACTUAL PARAMETERS 
				;  THAT HAVE NOT BEEN SPECIFIED AT THE END OF THE LIST OF 
				;  ACTUALS IN A MACRO CALL.  THEY ARE TREATED AS IF THEY 
				;  HAD BEEN THE NULL STRING (AS DONE AT CMU) 
LPTRSV:	   0			; SAVE WORD FOR LISTING BUFFER POINTER SO THAT 
				;  FALSE PART OF CONDITIONAL COMPILATION DOES NOT 
				;  GET LISTED 
^^LSTSTK:  0			; POINTER TO QSTACK INDICATING WHETHER OR NOT ONE 
				;  IS IN THE FALSE PART OF CONDITIONAL COMPILATION 
^^CNDLST:  0			; FLAG INDICATING IF ONE IS IN THE FALSE PART OF 
				;  CONDITIONAL COMPILATION 
;;%CI% (1/5) JFR 7-18-75
TRKMCR:	0		;ADDR OF $PNAME+1 OF CURRENT MACRO NAME
TRKMCS:	0		;SAME FOR LAST MACRO IN SOURCE FILE
TRKM.P:	0		;PAGE # OF LAST MACRO IN SOURCE FILE
TRKM.L:	0		;ASCLIN # OF LAST MACRO IN SOURCE FILE
^^TRKBEG:	0	;PTR TO SECOND BLOCK SEMBLK OF CURRENT BLOCK
		;FOR INFORMATIVE ERROR MESSAGES, "FATAL EOF"
;;%CI% ^
;; #RA#	(1 OF 2) ! 
^^EOFCEL:  0			; FLAG INDICATING FINAL END OF PROGRAM SEEN 

?srcprm:	0	;turned on when passing parameter text
			;turned off at end-of-macro or end-of-parameter
			;used only when filling a parameter (prmscn)

BAIL <
^^BSRCFC: 0			; BUFFER ADDR,,BLOCK COUNT  FOR SOURCE FILE
^^BNSRC:  0			; NUMBER OF SOURCE FILES SEEN
^^BSRCFN: 0			; CURRENT SOURCE FILE NUMBER
^^BSRCFQ: 0			; QSTACK FOR  REQUIRE  SAVING
^^BLSTFC: 0			; WORD COUNT FOR LISTING FILE
^^BPPCNT: 0			; PREVIOUS PROGRAM COUNTER
>;BAIL
 
IFN FTL$DBG,<
^^L$CNT:	0		;#CHARS LEFT IN LSTBUF
>;IFN FTL$DBG

ifn ftdebug,<
flag$st:0	;;when 0, remchr and pname are normal, non-0
		;; means C contains values for both (see p 8)
rem$ch:	0	;;-# of hidden characters in string space
		;;when C used for more details see page 8
;;and now variables for cn.frb (see page 8) lost characters stuff
cn..cl:	0	;;number of times cn.frb called
cn..gc:	0	;;number of string garbage collects at last call
cn..ls:	0	;;number of "lost" characters at last call

>;ifn ftdebug

ENDDATA

DSCR  LSTDPB


DEFINE LSTDPB	<		;OUTPUT CHAR TO LISTING FILE IF REQD
	TRNN	TBITS2,NOLIST	;IS LISTING HAPPENING, BABY?
	ML$CHR			;YES, DO THE REQUIRED THING
>

IFE FTL$DBG,<
	DEFINE ML$CHR <IDPB B,LPNT>
	DEFINE ML$BAK <MOVEM SBITS2,LPNT>
>;IFE FTL$DBG
IFN FTL$DBG,<
	DEFINE ML$CHR <PUSHJ P,L$CHR>
	DEFINE ML$BAK <PUSHJ P,L$BAK>

L$CHR:	SOSGE	L$CNT		;ADD CHAR IN B TO LSTBUF, CHECKING OVERFLOW
	 ERR	<LSTBUF OVERFLOW>,1
	IDPB	B,LPNT
	POPJ	P,

	5*<POINT 7,0,-1>-5 
	0 
	0
	0
	0
L$TAB:	5*<POINT 7,0,34>-4
	5*<POINT 7,0,27>-3
	5*<POINT 7,0,20>-2
	5*<POINT 7,0,13>-1
	5*<POINT 7,0,06>-0

L$BAK:				;BACK UP LPNT TO SBITS2, CHECKING AND COUNTING
	CAMN	SBITS2,LPNT
	 POPJ	P,		;FREQUENT SPECIAL CASE
	PUSH	P,LPSA
	PUSH	P,LPSA+1
	MOVE	LPSA,SBITS2	;SUPPOSED BACK BP
	MULI	LPSA,5		;HAKMEM STRIKES AGAIN (PROG. HAX,ITEM 165-FREIBERG)
	SUB	LPSA+1,L$TAB(LPSA)	;LPSA+1 IS NOW CHAR ADDR
	PUSH	P,LPSA+1
	MOVE	LPSA,LPNT	;CURRENT BP
	MULI	LPSA,5
	SUB	LPSA+1,L$TAB(LPSA)
	CAML	LPSA+1,(P)	;CURRENT CHR ADDR MUST BE geq BACKUP
	 JRST	L$BAK1
	ERR	<LPNT FORWARD "BACKUP">,1
	JRST	L$BAK2
L$BAK1:	MOVEM	SBITS2,LPNT	;BACKUP BP
	SUB	LPSA+1,(P)
	ADDM	LPSA+1,L$CNT	;AND CNT
L$BAK2:	SUB	P,X11
	POP	P,LPSA+1
	POP	P,LPSA
	POP
>;IFN FTL$DBG

;;#YV# JFR 2-4-77 SET 'NOLIST' FROM ABSOLUTE BEARINGS
^^L$SET:
;;SDD: these tests boil down to:
;; turn on NOLIST bit iff:
;;	(NOT ff.listng)
;;	OR cndlst
;;	OR (ff.prmscn AND NOT tbits2.maclst)
;;	OR fmtwd.40
;;	OR (tbits2.macin AND NOT tbits2.macexp)
;;	OR tbits2.lokprm
	TLNE	FF,LISTNG	;.LST FILE EXIST?
	SKIPE	CNDLST		;CHECK FOR EXPLICIT NOLIST OF COND COMP
	 JRST	L$NO
	MOVE	TEMP,FMTWRD
	TLNE	FF,PRMSCN
	TLNE	TBITS2,MACLST	;SCANNING PRMS, NOT LISTING MACRO NAMES, DONT LIST ARGS EITHER
	TRNE	TEMP,40		;USER MIGHT HAVE EXPLICITLY TURNED IT OFF
	 JRST	L$NO
	TLNE	TBITS2,MACIN
	TLNE	TBITS2,MACEXP	;IN A MACRO, NOT LISTING EXPANDED TEXTS
	TLNE	TBITS2,LOKPRM
L$NO:	 TROA	TBITS2,NOLIST	;HUNTING PRM, OR IN MACRO AND NOT LISTING EXPANSIONS
	TRZ	TBITS2,NOLIST	;YES LIST
	POPJ	P,

DSCR main SCANNER Dispatch loop
RES gets first char from SAVCHR or PNEXTC, dispatches to
 routine to handle what it found (IDENT, STRING, DELIM, etc.)

^SCANNER:	
	TLZE	FF,BAKSCN	;SCANNER BACKED UP BY ERROR RECOVERY?
	 JRST	 GOAGAIN	; YES, RETURN EXACTLY WHAT WE WERE TOLD
;; eventually goes to
;	STRNG (quoted string--includes delimited strings for macros)
;		(this may make a recursive call to SCANNER),
;	PRMSTR (macro parameters strings--where not delimited),
;   or  CONCHK which can go to STRNG or
;		CHAROUT (single char ID's),
;		SCNUMB (get a number),
;		DSCAN (pick up an ID),
;
	MOVE	TBITS2,SCNWRD	; SET UP SCANNER PARAMS
;; #RA# (2 OF 2) 
	SKIPE	EOFCEL		; FINAL END OF PROGRAM SEEN? 
	JRST	[TLO TBITS2,EOFOK ; 
		 MOVEM TBITS2,SCNWRD ; 
		 JRST .+1]; 
;; #RA# 
	MOVE	USER,GOGTAB	;USER DATA TABLE ADDR FOR STRING STUFF
	TLNE	TBITS2,INLIN	;SPECIAL START!CODE FEATURE?
	 SETZM	PNAME		;YES, ASSURE NO PNAME USED
;;#MQ# SET UP SBITS2 FOR BACKING UP LPNT EVEN IF HAVE SAVCHR non-0
	MOVE	SBITS2,LPNT
	MOVEM	SBITS2,LPTRSV	; SAVE IN CASE FALSE PART OF COND COMP 

	SKIPN	B,SAVCHR	;IS ANYTHING LEFT OVER?
	 jrst	getmor		;since nothing saved, don't list it
	setzm	savchr		;clear saved character
	skipn	a,scntbl(b)	;is the saved character ignorable?
	 jrst	getmor		;yes, go continue skipping
	skipn	asgflg		;looking for a macro parameter?
	 jrst	spchar		;no, dispatch on the saved character
	err <SCANNER had character while looking for parameter>,1
	setzm	asgflg		;better stop EOM from nasty returns
	jrst	spchar

getmor:	skipn	asgflg		;separate looking for assignc case
	 jrst	skpign		;just a nice, simple scan. procede
	jrst	getm.l		;go look for macro parameter
	
	ml$chr
getm.l:	ildb	b,pnextc	;read a character
	skipge	a,scntbl(b)	;check it out for specials
	 pushj	p,(a)		;NOTE: asgflg will make EOM come here
	jumpe	a,getm.l-1(tbits2)	;and will have non-zero A

	skipn	asgflg		;were we stopped by EOM?
	 jrst	[movem	a,asgflg	;yes, restore asgflg (why?)
		 move	lpsa,b		;return parameter number in the
		 move	a,%NUMCON	;semantic stack
		 jrst	stack]
	err <SCANNER found character while looking for parameter>,1
	setzm	asgflg		;no, turn off nasty flag
	jrst	skpi.d		;and pretend we were in skpign loop
;; here we are looking for the beginning of something (skipping blanks)
;;
	ML$CHR			;TO LISTING FILE
skpign:	ILDB	B,PNEXTC	;SKIP IGNORABLE CHARACTERS
	SKIPGE	A,SCNTBL(B)	;ANYTHING SPECIAL REQUIRED?
	 PUSHJ	P,(A)		;YES, DO IT
	JUMPE	A,skpign-1(TBITS2) ;MAYBE LIST, GET NEXT IGNORABLE
skpi.d:
;; have found the first non-ignorable character here
	TLNN	FF,PRMSCN	;SCANNING MACRO PARAMETERS?
	 JRST	 DISPT		; NO
;;which was a macro parameter
	TLO	FF,PRMXXX	;SET SPECIAL PARAM SCANNING BIT
	TLNE	A,QUOTE		;DOES HE WANT COMPLETE FREEDOM?
				; ie: macro parameter in string quotes
	 JRST	 STRLST		; ok, get string (first list quote)
	jrst	prmstr		;SPECIAL MODE -- "," OR ")" WILL BREAK

;; here we have the beginning of the next (normal) parameter
DISPT:	MOVE	SBITS2,LPNT	;SAVE IN CASE BACKUP MUST HAPPEN
	MOVEM	SBITS2,LPTRSV	; SAVE IN CASE FALSE PART OF COND COMP 
STRLST:	LSTDPB			;TO LISTING FILE IF REQD

SPCHAR:	SETZM	LSTCHR
	JUMPL	B,[TLZN	TBITS2,EOFOK	;OK FOR EOF HERE?
		   ERR  <FATAL END OF SOURCE FILE>	;NO
		   MOVE	A,%EOFILE	;YES, RETURN `EOF'
		   JRST	CHAROUT]	;NULL SEMANTICS
	SKIPE	DLMSTG		;LOOKING FOR SPECIALLY DELIMITED STRING
	 CAME	B,CURMBG	;POSSIBLY, MACRO BODY BEGIN DELIMITER?
	  JRST CONCHK		; GO DO A NORMAL SCAN
	SETZM	BNSTCN		; SET DELIMITER NEST COUNT TO ZERO
	JRST	STRNG		; GET MACRO BODY


BAIL<
^^BMKSRC:
	MOVE	TEMP,BAILON
	TRNN	TEMP,BBCRD	;SKIP IF WE WANT COORDS
	 POPJ	P,
	PUSH	P,A
	PUSH	P,B
	PUSH	P,C		;WE ARE IN THE HEART OF THE SCANNER, SO BEWARE
;;%##% 1! JFR 4-18-76
	PUSH	P,D

	MOVE	TBITS2,SCNWRD		;PICK UP SCANNER FLAGS
	TRNN	TBITS2,NOLIST		;LISTING IN PROGRESS?
	 JRST	BCRDLS			;YES
;;#%%# JFR 2-8-75 FIX THIS CRUFFT FOR MACROS AND CONDITIONAL COMPILATION
	TLNE	TBITS2,MACIN		;IN A MACRO?
	 JRST	BCRDN2			;YES, UPDATE COUNTERS ONLY, NOT POINTERS
	HRRZ	TEMP,PNEXTC
	HRRZ	SBITS,SRCPNT
	SUBI	TEMP,(SBITS)
	CAIL	TEMP,1
	CAILE	TEMP,200		;SRCPNT IS A WORD EARLY
	 JRST	BCRDN2			;PNEXTC IS OUT IN THE BOONIES
;;#%%# ^
	MOVE	TEMP,PNEXTC
	MOVEM	TEMP,BPNXTC		;SAVE BYTE POINTER

	HRR	SBITS,BSRCFC		;BLOCK COUNT FOR SOURCE FILE
	HRRZ	A,BPNXTC		;ADDR OF CURRENT WORD IN BUFFER
;;#%%# BY JFR 11-17-74  CORRECT COMPUTATION OF WORD OFFSETS
	HRRZ	B,SRCPNT		;WORD EARLY POINTER
	ADDI	B,1			;CORRECT
;;#%%# ^
	LDB	C,[POINT 5,BSRCFN,35-0]	;FILE NUMBER
	LDB	D,[POINT 6,BPNXTC,35-30];"P" PORTION OF BYTE POINTER
	JRST	BCRDN1
BCRDLS:
NOTENX<
	LDB	SBITS,[POINT 18,BLSTFC,35-7]	;BLOCK COUNT FOR LIST FILE
	ADDI	SBITS,1			;FIRST BLOCK IS 1, NOT 0
	HRRZ	A,LPNT			;ADDR OF CURRENT WORD IN BUFFER
	HRRZ	B,LSTBUF		;ADDR OF FIRST WORD
	LDB	D,[POINT 6,LPNT,35-30]	;"P" PORTION OF BYTE POINTER
>;NOTENX
TENX<
	MOVE	A,BLSTFC		; CHAR COUNT FOR LIST FILE
	IDIVI	A,5			;WORD COUNT IN A, REMAINDER IN B
	SUBI	B,5			;BEGIN CONSTRUCTION OF "P" OF BYTE POINTER
	MOVM	D,B
	IMULI	D,7
	ADDI	D,1			;FINISHED
	LDB	SBITS,[POINT 18,A,35-7]	;BLOCK COUNT FOR FILE
	ADDI	SBITS,1
	ANDI	A,177			;WORD OFFSET IN A
	SETZ	B,			; FAKE IT FOR BCRND1
>;TENX	
	SETZ	C,			;LIST FILE IS NUMBER 0
BCRDN1:	SUBI	A,(B)			;WORD OFFSET IN BUFFER
;;
	TLCE	TBITS2,PCOUT!LINESO
	 ADDI	A,2			;PC OR SOS LINE NUMBER GIVES 2 EXTRA WDS
	TLCN	TBITS2,PCOUT!LINESO
	 ADDI	A,1			;BOTH GIVE 3
;;
	DPB	A,[POINT 7,SBITS,35-18]	;INSERT WORD OFFSET
	DPB	C,[POINT 5,SBITS,35-25]	;INSERT FILE NUMBER
	DPB	D,[POINT 6,SBITS,35-30]	;INSERT "P" POINTER
	MOVEM	SBITS,BCRDW1		;SAVE
BCRDN2:	HRL	SBITS,BCORDN		;COORD NUMBER
				;SEE IF ANYTHING IS IN THE ACS
	MOVSI	TEMP,-20		;LENGTH OF ACKTAB
	MOVE	A,ACKTAB(TEMP)
	JUMPE	A,.+3			;JUMP IF VACANT
	ADDI	A,1
	JUMPN	A,.+3			;JUMP IF NOT PROTECTED, I.E. BUSY
	AOBJN	TEMP,.-4		;LOOP
	TLO	SBITS,400000		;MARK AS ALLSTO

	HRR	SBITS,PCNT
	MOVEM	SBITS,BCRDW2		;SAVE

BXCRD:
;;%##% 1! JFR 4-18-76
	POP	P,D
	POP	P,C
	POP	P,B
	POP	P,A
	POPJ	P,

^^BCROUT:			;PUT COORD OUT TO .SM1 FILE IF NECESSARY
;;%##% 1! JFR 4-18-76
	SKIPE	TEMP,BPNXTC	;DONT PUT ONE OUT IF TEXT NOT MARKED YET
	SKIPLE	TEMP,BAILON	;SKIP IF BAIL OFF
	TRNN	TEMP,BBCRD	;SKIP IF WE WANT COORDS
	 POPJ	P,
	MOVE	TEMP,PCNT
	SKIPN	NOEMIT		;NO COORDS FOR EXPR TYPE
	CAMN	TEMP,BPPCNT	;NO SKIP IF PCNT SAME AS BEFORE
BCRPJ:	 POPJ	P,
	SETZM	BPNXTC		;REMEMBER TO MARK SOURCE AT NEXT TOKEN
	EXCH	TEMP,BPPCNT	;UPDATE, KEEP OLD VALUE
	JUMPE	TEMP,BCRPJ	;FIRST TIME THROUGH IS JUST SETUP
	PUSH	P,A
	PUSH	P,B
	PUSH	P,C		;TAKE CARE IN SCANNER
;;%##% 1! JFR 4-18-76
	PUSH	P,D
	AOS	A,BCORDN	;INCREMENT COORD COUNT
	TLOE	A,1		;IS CURRENT TABLE OF .SM1 FILE A COORD TABLE?
	 JRST	BCROU1		;YES
	MOVEM	A,BCORDN	;UPDATE
	SETZ	SBITS,
	PUSHJ	P,VALOUT	;END PREVIOUS TABLE OF .SM1 FILE
	MOVEI	SBITS,BAICRD
	PUSHJ	P,VALOUT	;START COORD TABLE
BCROU1:	MOVE	SBITS,BCRDW1
	PUSHJ	P,VALOUT	;FIRST WORD
	MOVE	SBITS,BCRDW2
	PUSHJ	P,VALOUT	;SECOND WORD
	JRST	BXCRD
>;BAIL
	

CONCHK:
;;%DI% 3! JFR 12-2-75 CLEAN UP BEGINNING OF COORDINATE, ESP. FOR "CASE"
BAIL<	SKIPN	BPNXTC		;IF SOURCE NOT MARKED
	 PUSHJ	P,BMKSRC	; THEN DO SO
>;BAIL
	tlne	a,dig+dot+atsign+quocte	;possible number part?
	 JRST	 SCNUMB		; YES, SCAN NUMBER
	TLNE	A,LETDG		;valid id start (no numbers get here)
	 jrst	dscan		; yes, go scan identifier
BAIL<	CAIN	B,";"		;TEST FOR END OF STATEMENT
	 PUSHJ	P,BCROUT	;YES. PUT OUT COORDINATE
>;BAIL
	TLNE	A,QUOTE		;STRING CONSTANT?
	 JRST	conc.q		;yes, go set it up
	tlnn	a,pairpt	;could it be a fake _, ^, LEQ, or GEQ
	 JRST	CHAROUT		;no, OPERATOR, OUTPUT ID,NULL SEMANTICS
;;\UR#4\ ALLOW := FOR _, <= FOR LEQ, >= FOR GEQ , ** FOR ^
        CAIN    B,":"
	 JRST	[PUSHJ	P,SNEAKC
		SCNTBL+"_"	;ASSUME SEMANTICS OF _
		0,,"="		;2ND CHAR OF := IS "="
		SCNTBL+":"	;SEMANTICS IN CASE ASSUMPTION FAILS
                ]
        CAIN    B,76		;a  GREATER THAN CHAR
	 JRST    [PUSHJ P,SNEAKC
		SCNTBL+""	;ASSUME WE REALLY HAVE GEQ
		0,,"="		;2ND CHAR IS "="
		SCNTBL+76]	;ASSUMPTION FAILS, WE HAVE GTR
        CAIN    B,74		;a less than character
	 JRST    [PUSHJ P,SNEAKC
		SCNTBL+""	; LEQ is from "less than"
		0,,"="		; followed by "="
		SCNTBL+74]
        CAIN	B,"*"
	 JRST    [PUSHJ P,SNEAKC
		SCNTBL+"^"	;"^" (exponentiation)
		0,,"*"		;comes from "**"
		SCNTBL+"*"]
	err <DRYROT: CONCHK thought it might have had a magic pair>
	jrst	charout
;;\UR#4\
;;#XO# ! JFR 10-14-76
conc.q:	TLZ	TBITS2,EOFOK	;saw a " char, must see another
				; (particularly after final END "FOO )
	SKIPN	DLMSTG		;WAS A QUOTE USED TO DELIMIT A MACRO
				;BODY IN REQUIRE DELIMITERS MODE?
	 JRST	STRNG		;NO, SCAN STRING CONSTANT -NORMAL MODE.
	SETZM	DLMSTG		;YES, TURN OFF DLMSTG FLAG AND TURN ON
	SETOM	BAKDLM		;BAKDLM FLAG SO THAT WHEN SCANNING THE
	JRST	STRNG		;MACRO BODY A QUOTE WILL BREAK THE SCAN


SNEAKC:	ILDB	B,PNEXTC	; PICK UP NEXT CHARACTER
	SKIPGE	A,SCNTBL(B)	; MAKE SURE NOT END OF BUFFER ETC.
	 PUSHJ	P,(A)		; IF IS. HANDLE IT.
	LSTDPB			; LISTING if desired
	POP	P,TEMP		;RETRIEVE PTR TO ARGS
	MOVE	A,@(TEMP)	;ASSUME THIS
	CAMN	B,1(TEMP)	;DOES 2ND CHAR MATCH?
	 JRST	CHAROUT		;YES, ASSUMPTION CORRECT
	MOVEM	B,SAVCHR	;ASSUMPTION WRONG. SAVE 2ND CHAR
	MOVEM	B,LSTCHR 
	MOVE	A,@2(TEMP)	;GET ORIGINAL SEMANTICS
	JRST	  CHAROUT	;AND LEAVE

;clr$str sets up pname and c with an initially null
;	string for use with the AOBJN-style count
;	of -# available chars left,,true string length
;cls$str fixes pname and remchr from value in c
;	thus returning to the more normal and correct
;	use of remchr and so on
;mor$str is called to garbage collect and reset c
;	this is used when c goes positive from an aobjn
;add$str is called to extend a string stored in pname
;	in the inimitable style mentioned above.  The
;	string need not have been developed here before
ife ftdebug,<
 define clr$str <
	pushj	p,inset		;align to FW, set PNAME, ...
	hrlz	c,remchr(user)	;get -#remaining characters into c
 >
 define cls$str <
	hlrem	c,remchr(user)	;update remaining characters count
	hrrm	c,pname		;update count in PNAME from c
	hrrzi	c,(c)		;clear out remaining characters count
 >
 define mor$str <pushj	p,mor.st>	;has to be a single instruction
 define add$str <
	pushj	p,add.st
 >
>;ife ftdebug

mor.st:	sub	c,[xwd 1,1]	;since AOBJN stopped before use
	hlrem	c,remchr(user)	;replace values in c to normal places
	hrrm	c,pname		;(remchr and length part of pname)
	pushj	p,add.st	;now bring in as if wasn't C-based
	aobjp	c,.+2		;better have enough room for 1 char
	popj	p,		;and return
	err <DRYROT: mor.st failed to get at least two chars>

add.st:	move	c,tbits		;save tbits (since this can mangle)
	exch	sp,stpsav	;since calling strings in runtimes
	movss	povtab+6	;which may overflow stack

	push	sp,pname	;call routine to move string
	push	sp,pname+1	;on stack to top of string space
	push	p,[=50]		;and guarantee at least N characters
	EXTERN .SONTP	;(it is in the run-time package)
printx get rid of this line (and next) when .SONTP handles RACS+RF
	movem	rf,racs+rf(user);crock: the runtime is wrong
	pushj	p,.sontp	;of free storage

	pop	sp,pname+1	;  put (possibly moved) string
	pop	sp,pname	;  back into pname
	exch	sp,stpsav	;now restore sp to former state
	movss	povtab+6	;and stop treating as string stack
	movem	c,tbits		;restore tbits
	movni	c,=50		;restore the guaranteed characters
	addb	c,remchr(user)	;to the free characters count
	hrlzi	c,(c)		;re-establish register c
	hrr	c,pname		; to be AOBJN for adding to string
	popj	p,		; and return

ifn ftdebug,<
 define clr$str <pushj p,clr.sd>
 define cls$str <pushj p,cls.sd>
 define mor$str <pushj p,mor.sd>
 define add$str <pushj p,add.sd>

clr.sd:	skipe	flag$st
	 err <attempt to create a string while C active>
	pushj	p,inset		;align to FW boundary
	hrlz	c,remchr(user)	;make AOBJN style count in c

fixcxt:	setzm	remchr(user)	;to detect other uses of string space
	add	c,[xwd 10,0]	;dont show more than eight characters
	jumpge	c,[		;we dont really have much space anyway
		sub	c,[xwd 10,0]	;undo the add above
		cail	c,0		;make sure remchr not positive
		 err <fixct: about to return with no characters>
		setzm	rem$ch		;indicate no remchr kluge
		movem	c,flag$st	;save count (to check at close)
		popj	p,		;and leave
		]
	hlrom	c,rem$ch	;store amount hidden
	hrli	c,-10		;and set as if only eight chars left
	movem	c,flag$st	;save count (to check at close)
	popj	p,		;finally, return

cls.sd:	skipn	temp,flag$st	;pick up starting C value
	 err <attempt to close a string while C inactive>
	tlnn	c,-1		;make sure not closed at over-run
	 err <string closed with lh(c)=0>
stop.d:	caile	c,-1		;lh should be at most 0
	 err <over-run detected when closing a string>
	xor	temp,pname	;make sure count in PNAME didn't change
	trne	temp,-1		;from last setup of C (RH is old count)
	 err <when closing a string, PNAME disagrees with FLAG$ST>
	move	temp,c		;find out how many characters added
	sub	temp,flag$st	;and free characters used (used,,add)
	tsc	temp,temp	;see if both halves adjusted equally
	caie	temp,0		;note cute trick that clears bits
	 err <closing a string where both halves not updated evenly>
	skipe	remchr(user)	;make sure no-one fiddled remchr
	 err <Warning: someone used string space while C in use>
	hrrm	c,pname		;well, everything looks ok, store it
	hlre	temp,c		;get "new remchr"
	add	temp,rem$ch	;add in "sneaked" amount
	movem	temp,remchr(user)
	setzm	flag$st		;clear stored c-value
	hrrzi	c,(c)		;and change c to be pure length
	jrst	cn.frb		;and return checking string space stuff

mor.se:	err <mor.sd failed to get enough (any?) characters>
mor.sd:	skipn	temp,flag$st	;stop.d will want temp set up this way
	 err <attempt to extend a string while C inactive>
	tlne	c,-1		;make sure count just went to zero
	 err <attempt to unnecessarily extend string>
	sub	c,[xwd 1,1]	;since AOBJN stopped before deposit
	pushj	p,stop.d	;what we will do is a close-open
	hrl	c,remchr(user)	;for speed, check to see if space left
	caml	c,[xwd -1,0]	;do we really have no more room?
	 pushj	p,add.st	;oh well, we need 2 characters, GC
				;by treating as pulling in a new string
	pushj	p,fixcxt	;go do accounting saying what we got
	aobjp	c,mor.se	;do the add that got us here, and
	popj	p,		;return unless no space was obtained

add.sd:	skipe	flag$st
	 err <attempt to add to string while C active>
	pushj	p,add.st	;set up PNAME, c, ...
	jrst	fixcxt		;go use the new C (may do remchr cheat)


cn.frb:
;;this is called very frequently, hang all sorts of consistency checks
;; off of here.  Currently checks for the mystical "lost characters" 
;; which happen when REMCHR and TOPBYTE are not both equally fiddled.
	aosn	cn..cl		;bump number of times called
	 err <cn.frb: count went to 0>,1 ;so negative count will stop
	push	p,a
	move	user,gogtab	;get table (just making sure)
	hrrz	a,sttop(user)	;and calculate number of words in
	sub	a,st(user)	;string space - 1
	imuli	a,5		;convert to number of bytes-5
	add	a,remchr(user)	;minus number of remaining bytes
	push	p,a		;yields number of passed bytes -5
	move	a,topbyte(user)	;now check where we actually point
cn.fr0:	tlnn	a,760000	;(walk forward to word boundary)
	 jrst	cn.fr1		;we have a 010700 type now
	ibp	a		;bump byte pointer
	aos	(p)		;and how many this should cover
	jrst	cn.fr0		;and loop until 010700 pointer made
cn.fr1:	sub	a,st(user)	;subtract off the base address
	hrrei	a,(a)		;mask left half and make it a count
				;of words covered by topbyte (fiddled)
	imul	a,[-5]		;convert to a negative byte count
	hrrei	a,0(a)		;this is for fudging during debug
	addb	a,(p)		;add in results of previous calculation
				;giving total missing characters
	camn	a,cn..ls	;is lost character count the same?
	 jrst	cn.fr2		;it sure is, why did we worry?
	move	a,sgccnt(user)	;get string GC serial number
	came	a,cn..gc	;and see if same as last time
	 jrst cn.fr2		;if not, measures incomensurable
	move	a,(p)		;get current lost characters
	sub	a,cn..ls	;figure out how many more we lost
	jump	cn.fr2		;change this for other checks
	skipn	cn..ls		;if we previously had zero lost (?!)
	 skipe	sgccnt(user)	;and it was before first string GC
				;then assume just initial values there
				;and skip over the error message
cn.bkp:	err <cn.frb changed lost characters by contents of A>,1
				;this is a good breakpoint place
cn.fr2:	move	a,sgccnt(user)	;get string GC serial number
	movem	a,cn..gc	;update gc serial number
	pop	p,cn..ls	;store new copy of lost byte count
	pop	p,a		;restore a
	popj	p,		;and leave
>;ifn ftdebug

; ID -- RESET FOR SCAN

DSCAN:
BAIL<
	SKIPN	BPNXTC		;DOES DEBUGGER KNOW WHERE WE ARE?
	 PUSHJ	P,BMKSRC	;NO -- GO MARK PLACE
>;BAIL
	MOVE	TBITS2,SCNWRD	;MAKE SURE THE BITS ARE RIGHT
	TLO	TBITS2,EOFOK	;EOF CAN END THE WORLD SAFELY
	clr$str			; set up for reading ID
	aobjn	c,idscan	;skip the listing part
	mor$str			;we needed a buffer immediately
	jrst	idscan

	ML$CHR			;TO LISTING FILE
IDSCAN:	IDPB	A,TOPBYTE(USER)	;STORE CONVERTED CHAR
	ILDB	B,PNEXTC	; GET NEXT CHARACTER
	SKIPGE	A,SCNTBL(B)	;GET GOOD BITS, CHECK SPECIAL
	 PUSHJ	P,CSPEC		;SPECIAL, DO SOMETHING
	TLNN	A,LETDG		;DONE WITH ID?
	 jrst	idscnd		;yup, stop the loop
	aobjn	 c,idscan-1(tbits2) ;no, go get more.
	mor$str			;need more space for string
	jrst	idscan-1(tbits2);got it, proceed

idscnd:	cls$str			;finished getting ID (fix string space)

Comment $ Now the symbol is in string space, pointed to
	by the string descriptor in PNAME, etc. Store the
	count, make the lookup, set up the results
$

	CAIE	B,12		;IF LF, ALREADY HANDLED, LEAVE SAVCHR 0
	 MOVEM	B,SAVCHR	;SAVE THE BREAK BITS (0 IF BLANK OR CR BROKE)
	MOVEM	B,LSTCHR	;ALSO HERE ANY TIME
	TLZ	TBITS2,EOFOK	;DONE WITH THIS MODE
	MOVE	LPSA,SYMTAB	;TRY TO FIND IT
	PUSH	P,B		;SAVE FOR LATER
	PUSHJ	P,SHASH		;LIKE SO
	POP	P,B		;GET IT BACK
	MOVEM	TBITS2,SCNWRD	;SAVE ANY CHANGES
	TLNE	TBITS2,LOKPRM	;STACK IT?
	 POPJ	 P,		; NO, IN STRING CONSTANT MODE

;  GET RELEVANT DATA TO STACKS

	MOVE	A,%ID		;IT IS AN IDENTIFIER
	SKIPG	LPSA,NEWSYM	;IF IT IS UNDEFINED,
	 JRST	 LSTACK		;   PUSH TO STACKS

	MOVE	TBITS,$TBITS(LPSA)
;IF CREFFING, DO IT NOW...
	TLNE	FF,CREFSW	;
	 PUSHJ	P,LCREFIT

	JUMPGE	 TBITS,USID	; NO, USER ID
	LSTDPB
	MOVE	A,TBITS		;RESULTANT PL-ID
;;%CI% ! JFR 7-26-75
	MOVEI	TEMP,$PNAME+1(LPSA)	;ADDR OF B.P. TO RES WORD
	MOVEI	LPSA,0		;MAKE NULL SEMANTICS
	CAMN	A,%COMMENT	; COMMENT?
	 JRST	 CHKSAV		; YES, GO PROCESS IT
	TLNN	TBITS,CONRES	; PARSER SWITCHING RESERVED WORD?
	 JRST	STACK		; NO, RETURN RESERVED WORD
;;%CI%
	MOVEM	TEMP,TRKMCR	;CURRENT "MACRO"
	SKIPN	SWCPRS		; YES, NEED TO SWITCH PARSERS?
	 JRST	STACK		; NO, RETURN RESERVED WORD
	TLNN	TBITS2,MACIN	;ARE WE INSIDE A MACRO?
	 JRST	[MOVEM	TEMP,TRKMCS	;NO, RECORD SOURCE-FILE TOKEN
		MOVEI	TEMP,TRKM.P-1
		PUSH	TEMP,FPAGNO	;	PAGE #
		PUSH	TEMP,ASCLIN	;	LINE #
		jrst	.+1]		; and proceed
;;%CI% ^
	TLNE	TBITS,DEFINT	;PARSER INTERRUPT (I.E. NO SWITCHING)?
	 JRST [	SKIPE NODFSW	; DEFER DEFINE HANDLING FOR BLOCK EXECUTION?
		 JRST	STACK	; YES, RETURN RESERVED WORD
		MOVE 	TEMP,SCNNO; YES, SAVE NUMBER OF SCANS REMAINING IN LEFT HALF 
		MOVE	B,PCSAV	;  OF TOP OF PRODUCTION STACK, UNPACK $TBITS ENTRY 
		HRLM	TEMP,(B);  OF THE RESERVED WORD TO GET AN INDEX OF ADDRESS 
		JRST	CONDAD]	;  TO PUSHJ TO, AND SET SCNNO TO ONE.
	TLNE	TBITS,CONDIN	; CHECK IF ENDC HAS OCCURRED AS THE END OF A WHILEC,
	 JRST	ENDCOK		;  CASEC, FORC, OR FORLC BODY AND IF SO, THEN DO NOT
	HLRZ	TEMP,ENDCTR	;  SWITCH PARSERS.  ENDCTR IS A POINTER TO A QSTACK 
	SKIPE	(TEMP)		;  INDICATING SUCH INFORMATION.  
	 JRST	STACK		;
ENDCOK:	MOVEI	TEMP,CGPSAV-1		; DETERMINE WHICH PARSER ONE IS CURRENTLY IN AND 
	SKIPN	PRSCON		;  GET THE ADDRESS TO SAVE ITS PARSER DESCRIPTOR.
	 MOVEI	TEMP,SGPSAV-1	;  SAVE SEMANTIC STACK POINTER, PARSE STACK POINTER,
	PUSH	TEMP,GPSAV	;  NUMBER OF SCANS REMAINING IN LEFT HALF OF TOP OF 
	PUSH	TEMP,PPSAV	;  PRODUCTION STACK, PRODUCTION STACK POINTER, 
	MOVE	SP,SCNNO	;  CURRENT SCNWRD, AND A POINTER TO THE SCNWRD 
	MOVE	B,PCSAV		;
	HRLM	SP,(B)		;  STACK.
	PUSH	TEMP,PCSAV	;
	MOVE	B,SCWSV		;
	MOVEM	TBITS2,(B)	; SAVE SCNWRD
	PUSH	TEMP,SCWSV	;
	HRROI	TEMP,SSCWSV ; DETERMINE WHICH PARSER IS TO BE RESUMED AND GET 
	SKIPN	PRSCON		;  THE ADDRESS OF ITS PARSER DESCRIPTOR.
	  HRROI	TEMP,CSCWSV	;
	POP	TEMP,B		; RESTORE SCNWRD STACK POINTER
	TLNE	TBITS,CONDIN	; IF ONE IS SWITCHING PARSERS VIA A PUSHJ INSTEAD OF
	 JRST [	TLZ TBITS2,INLIN;  PROPER SCANNING OF INLINE STARTCODE.
		TRO	TBITS2,NOLIST	;COMPENSATE FOR NOT POPPING
		PUSH	B,TBITS2	;TEMP
		JRST	.+2]		;
	MOVE	TBITS2,(B)	; RESTORE SCNWRD AND TBITS2
	MOVEM	B,SCWSV		;
	MOVEM	TBITS2,SCNWRD	;
	ML$BAK			; DON'T LIST PARSER SWITCH
				;  TRIGGERING RESERVED WORDS
	POP	TEMP,B		; RESTORE CONTROL STACK POINTER
	POP	TEMP,SP		; RESTORE PARSE STACK POINTER.  MUST
	MOVEM	SP,PPSAV	;BE IN AC AS WELL AS IN MEMORY.
	POP	TEMP,GPSAV	; RESTORE SEMANTIC STACK POINTER
	SETCMM	PRSCON		; COMPLEMENT PARSER IN CONTROL FLAG
	MOVEI	C,1001		; ASSUME A RESUME TYPE SWITCH
	TLNN	TBITS,CONDIN	; RESUME TYPE SWITCH?
	 JRST	SWTPRE		; YES
CONDAD:	HLRZ	C,TBITS		;CONDAD IS CALLED WITH THE $TBITS ENTRY
	TRZ	C,RES+CONBTS	;OF A PARSER INTERRUPT RESERVED WORD IN
	LSH	C,-IF0SHF	;TBITS.  IT INSERTS THE ADDRESS OF THE 
	MOVEI	C,PRODGO(C)	;NEXT PRODUCTION TO EXECUTE
	PUSH	B,C		;IN THE PRODUCTION CONTROL STACK. TBITS
	MOVEI	C,4001		;IS UNPACKED TO GET AN INDEX TO A TABLE
				;STARTING AT PRODG0 (BITS 6-8).  SET 
				;REMAINING NUMBER OF SCANNER CALLS TO 
				;ONE SO THAT THE PARSER WILL NOT SCAN 
				;AGAIN AND SET A BIT TO DO A PUSHJ.
SWTPRE:	MOVEM	B,PCSAV		; RESTORE CONTROL STACK POINTER IN CORE
	MOVEM	C,SCNNO		; SET REMAINING NUMBER OF CALLS TO
	JRST	STACK		; SCANNER, AND GO STACK



Comment $  COMMENT -- throw out everything to next semicolon
$

CHKSAV:	SETZB	B,LSTCHR
	exch	b,savchr	;be sure savchr is not ";"
;; #PC#! OVERWRITING FIRST LINE IN CREF 
	JUMPE	B,COMLUP	; NULL HAS ALREADY BEEN HANDLED 
	SKIPGE	A,SCNTBL(B)	;GET BITS, CHECK SPECIAL
	 PUSHJ	P,(A)		;SPECIAL, GET PAST PROBLEM
	JRST	COMLUP		;GET THEM ALL

	ML$CHR			;TO LISTING FILE
COMLUP:	CAIN	B,";"		;DONE?
BAIL<	 jrst	[SETZM	BPNXTC	;YES. MARK SOURCE AT NEXT TOKEN
		JRST	SCANNER]
; ELSE>	 JRST	 SCANNER	; YES
	ILDB	B,PNEXTC	;GET NEXT CHAR
	SKIPGE	A,SCNTBL(B)	;USUAL
	 PUSHJ	P,(A)
	JRST	 COMLUP-1(TBITS2) ;GO PUT AWAY, GET ANOTHER


DSCR -- USID
DES An identifier has been found.  If it is a macro name, go
  expand it.  Otherwise call TYPDEC routine to provide the
  proper parse token for this identifier (differentiates 
  ARRAYS from PROCEDURES from STRINGS from ....
SEE TYPDEC in GEN, for providing correct parse token.


USID:	SKIPN	SWCPRS		; IN FALSE CONDITIONAL COMPILATION? 
	 SKIPN	IFCREC		; YES, SHOULD MACROS BE EXPANDED? 
	  JRST	TSTDEF		; YES, GO EXPAND MACROS 
;; #OF# ! MAKE SURE A IS VALID BEFORE GOING OFF TO STACK
	MOVE	A,%ID		;  NO, DON'T EXPAND MACROS OR 
	JRST	STACK		;CHECK TYPES AND RETURN
TSTDEF:	TLNE	TBITS,DEFINE	;NEED TO EXPAND MACRO?
	 JRST	DEFRG		;YES
GOHEQ:	LSTDPB
	PUSHJ	P,TYPDEC
	JRST	STACK


DSCR DEFRG -- prepare to expand a macro
DES The Ident is a DEFINE Ident.  The steps are
1.	Save current Parse and Semantic Stack state,
	 other state which will be destroyed.
2.	If no parameters to get, go to step 5.
3.	Get a parameter (special form string constant,
	 see manual), via SCANNER (recursive call, also
	 ENTERS); place on special VARB-RING whose ring
	 variable is VARB, and whose starting element is
	 in DEFRN2.
4.	If comma, go to step 3 for more, else check for 
	 right paren.
5.	Save previous SCANNER information on DEFPDP stack,
	 set up DEFRNG for actuals, put macro body descrip-
	 tor in PNEXTC, restore stacks and VARB, etc.
6.	Handle macro expansions in listing.
7.	JRST to SCANNER for another try with the new PNEXTC


DEFRG:	HLRZ	A,%TLINK(LPSA)	; CHECK IF MACRO HAS BEEN INITIALIZED.
	JUMPN	A,DEFRG1	;
	ERR <MACRO WAS NOT INITIALIZED. INITIALIZE TO 0 AND CONTINUE>,1
	SETZM	A		; SOLVES PROBLEMS SUCH AS:
	PUSHJ	P,CREINT	;  DEFINE NAME=NAME+1 WITHOUT A
	MOVE	LPSA,PNT	;  DEFINE NAME= SOME INITIAL VALUE.
	MOVE	A,%NUMCON	;
	JRST	STACK		;
DEFRG1:				;CREATE A NEW DEFINE ELEMENT
	TLNE	FF,NOMACR	;EXPAND MACROS??
	 JRST	[LSTDPB
		 MOVE A,%ID
		 JRST STACK];NO -- USER ID.

; IF WE DON'T WANT TO SEE MACRO NAMES IN OUTPUT LISTING, BACK UP
; OUTPUT PTR.  ALSO TURN OFF LISTING FOR PARAMS

	TLNN	TBITS2,MACLST	;LIST MACRO NAMES?
	 JRST	 [ML$BAK	;NO, NULLIFY ALL TO DATE
		  TRO	TBITS2,NOLIST ;LIST NO MORE FOR A WHILE
		  JRST	.+1]

	PUSHJ	P,SCNACT	; GET ACTUAL PARAMETER LIST
	PUSHJ	P,ACPMED	; FINISH OFF THE MACRO CALL PREPARATION
	JRST	SCANNER		; TRY AGAIN (SCAN THE MACRO BODY!)


; SPECIAL DELIMITER MODE ACTUAL PARAMETER SCANNING ROUTINE
; obtains a macro parameter in "special delimiter" mode
; called with PUSHJ P,SCNPMR   all chars obtained through PNEXTC
; loops in DSPRMS until arg started, in which case it dispatches
; either to PSCAN loop (parameter encased in delimiters), or to the
; BALCHK loop (parameter is not encased in delimeters, break on
; a comma or close-paren which is nest-balanced).
; in either case this returns via ENDSTR

SCNPMR:
begin MACPAR
	setzm	srcprm		;clear "parameter just obtained" flag
	jrst	dsprms		; this char listed already
	ML$CHR			; LIST MAYBE
DSPRMS:	ILDB	B,PNEXTC	; GET NEXT CHAR.
	SKIPGE	A,SCNTBL(B)	; SPECIAL?
	 jrst	[PUSHJ	P,(A)		;do special handling
		skipn	srcprm		;if didn't switch to parameter
		 jrst	.+1		;then keep on looking
		clr$str			;otherwise set to store chars
		pushj	p,parcop	;copy macro parameter untested
		jrst	balchk		;and go to undelimited loop
		]
	JUMPE	A,DSPRMS-1(TBITS2) ; AGAIN IF IGNORABLE

	clr$str			; SET UP STRING SPACE ENTRY
	CAME	B,CURPBG	; PARAMETER BEGIN DELIMITER?
	 JRST	BALCHK		; NO, NESTED-BALANCED COMMA OR RPAR 
				;  WILL BREAK

;begin PSCAN loop	(macro parameter encased in delimiters)

	SETZM 	BNSTCN		; SET NEST COUNT TO ZERO
	JRST	pscn.c		; CONTINUE SCAN

PSCAN:	IDPB	B,TOPBYTE(USER)	; DEPOSIT
pscn.c:	LSTDPB			; LIST IT?
	ILDB	B,PNEXTC	; GET NEXT CHAR.
	SKIPGE	A,SCNTBL(B)	; SPECIAL?
	 pushj	p,partst	;do special, if param, read in full
	CAMN	B,CURPED	; PARAMETER END DELIMITER?
	 JRST    SPMEND		; YES, CHECK IF DONE
	CAMN	B,CURPBG	; PARAMETER BEGIN DELIMITER?
	 AOS	BNSTCN		; INCREMENT NEST COUNT
pscn.l:	aobjn	c,pscan		; scan again
	mor$str			;we needed more buffer
	jrst	pscan		;NOW, go on (got more buffer)

SPMEND: SOSL	BNSTCN		;DECREMENT NEST COUNT AND CHECK IF DONE
	 jrst	pscn.l		; NO, SCAN AGAIN
				;leave PSCAN loop
	ILDB	B,PNEXTC	; ADVANCE CHAR. TO KEEP IN SYNCH.
	SKIPGE	A,SCNTBL(B)	; SPECIAL?
	 PUSHJ	P,CSPEC		; DO IT
	JRST 	ENDSTR		; GO TO END

deposb:	mor$str			;we needed more buffer
DEPOSA:	IDPB	B,TOPBYTE(USER)	; DEPOSIT
	LSTDPB			; LIST IT?
	ILDB	B,PNEXTC	; GET NEXT CHAR.
	SKIPGE	A,SCNTBL(B)	; SPECIAL?
	 pushj	p,partst	;do special, if param, read in full
BALCHK:	CAIE	B,","		; END OF PARAMETER?
	 CAIN	B,")"		; 
	  JRST	ENDCHK		; POSSIBLY, GO CHECK
	TLNE 	A,NEST		; NESTED CHARACTER?
	 jrst	balnst		;go check proper nesting
	aobjn	c,deposa
	jrst	deposb

balnst:	MOVE 	TEMP,[AOS LOCNST-1(LPSA)] ; SET UP INSTRUCTION TO
					; UPDATE APPROP. NEST COUNT
	TLNN	A,LNEST		; LEFT NESTED?
;;SDD 10-OCT-79 use expression, not bit "AOSSOS_20000" below
	 TLC	TEMP,(<AOS><SOS>) ; NO, CHANGE INSTRUCTION TO SUBTRACT
	HRRZ	LPSA,NSTABL(B)	; LOAD CHAR'S NESTED COUNT INDEX
	XCT	TEMP		; MODIFY NEST COUNT
	aobjn	c,deposa
	jrst	deposb

ENDCHK:	MOVEI	TEMP,NUMNST-1	; SET UP COUNT
EDLOOP:	SKIPN	LOCNST(TEMP)	; NEST COUNTEQUAL ZERO?
	 SOJGE	TEMP, EDLOOP	; YES, AND TRY NEXT IF NOT DONE
	JUMPL	TEMP,ENDSTR	;if all nest counts=0, exit with ENDSTR
		; not even on nest counts, continue getting parameter
	CAIN	B,")"		; RIGHT PAREN WITH NONZERO NEST COUNT?
	 SOS	LOCNST+RPAROF	; DECREMENT NEST COUNT
	aobjn	c,deposa	; bump character count and keep going
	jrst	deposb

partst:	;special obtained in "check for balanced args" this is
	;necessary in case we get to insert a macro parameter into
	;another macro parameter.  The macro parameter coming in
	;should not be examined for nesting counts, commas, or the like
	pushj	p,cspec		;first perform the special handling
	skipn	srcprm		;if characters aren't coming from a
	 popj	p,		;macro parameter, go back like cspec
				;keeping char in B unlisted
parcop:	;reading a macro parameter into another, don't check contents
	aobjp	c,parc.b	;make sure enough room, and add char

	lstdpb			;list char if necessary
parc.l:	;here we are reading macro parameter characters into parameter
	idpb	b,topbyte(user)	;store character
	ildb	b,pnextc	;get next character
	skipge	a,scntbl(b)	;check for specials
	 jrst	partst		;special (this may be end-of-parameter)
	aobjn	c,parc.l-1(tbits2);go do listing and store
parc.b:	mor$str			;must make more room first
	jrst	parc.l-1(tbits2);list (if necessary) and deposit b

bend MACPAR

DSCR -- SCNACT
DES This procedure is used to scan a list of actual parmeters for a
  macro or a conditional compilation FORLC statement.  When the latter
  happens SCNACT is called from the EXEC routine GETACT which appears
  in GEN.  FORLC statements have a body which is scanned as many times
  as one has parameters in the actual list; in each case a different
  actual is used as the parameter.
	SDD: GETACT sets "macro parameters wanted" to -1, indicating
		that unspecified parameters are undefined, not null.
		everyone else knows how many they want.
PAR LPSA contains the semantics of the macro name or macro pseudonym in
  case a FORLC list is being scanned (address of semblk of name).
	SDD: (as above, lh($VAL) = parameter count desired -1 magic)
RES DEFRN2 contains the address of the first actual parameter
  in the list.  If parameter count exceeds existing, no complaint,
  and nulls (actually '177&0 s) are added for the rest.  If the
  parameter count is low then all provided parameters are passed,
  and a complaint is issued (except for magic -1).


^SCNACT: PUSH	P,LPSA		;SAVE SEMANTICS OF DEFINE SYMBOL
	PUSH	P,VARB		;WILL MAKE NEW ONE FOR MACRO ARGUMENTS
	PUSH	P,PPSAV	;SAVE THE STACKS
	PUSH	P,GPSAV
	SETZM	DEFRN2		;INITIALIZE FOR NEW MACRO
	SETZM	VARB
;;%CI% (2,3/5) JFR 7-25-75
	MOVEI	TEMP,$PNAME+1(LPSA)	;ADDR OF B.P. TO MACRO NAME
	MOVEM	TEMP,TRKMCR	;CURRENT MACRO
	TLNE	TBITS2,MACIN	;IN A MACRO??
	 JRST	scna.1		;YES, DON'T RECORD SOURCE-FILE INFO
	MOVEM	TEMP,TRKMCS
	MOVEI	TEMP,TRKM.P-1
	PUSH	TEMP,FPAGNO
	PUSH	TEMP,ASCLIN
;;%CI% ^
scna.1:	HLRZ	TEMP,$VAL(LPSA)	;ANY PARAMETERS NEEDED?
	JUMPE	TEMP,NOPRMS	 	; NO
	MOVEM	TBITS2,SCNWRD	;NOTE CHANGES
SCNAGN:	PUSHJ	P,SCANNER	;LOOKING FOR "("
	move	temp,p		;restore saved stacks
	POP	temp,GPSAV	;to keep stacks in synch
	POP	temp,PPSAV
	MOVE	TEMP,(SP)	;SYNTAX OF SCANNED ELEMENT
	CAMN	TEMP,%STCON	; A SPECIAL DELIMITER DECLARATION?
	 SKIPE 	SWBODY		; YES, COULD WE POSSIBLY HAVE SEEN ONE
				;  I.E. DID WE SEE ONE ALREADY?
	  JRST	TSLPRN		; NO, GET LEFT PAREN.
	SKIPN	REQDLM		; TRYING TO OVERRIDE NULL DELIMITERS?
	 SETOM	RSTDLM		; YES, SET APPROPRIATE FLAGS
	SETOM	REQDLM		;
	SETOM 	SWBODY		; SET SWITCH DELIMITER DECLARATION FLAG
	MOVE	TEMP,[XWD -2,2]	; SET UP A COUNT
	MOVE	PNT,$PNAME+1(LPSA);PNT HAS BYTE POINTER TO DELIM STRING
	HRRZ	LPSA,$PNAME(LPSA) ; LPSA HAS DELIMITER STRING LENGTH
	PUSHJ	P,GETDL2	; GET SPECIAL DELIMITER DECLARATION
	JRST 	SCNAGN		; GO BACK AND GET LEFT PAREN.
TSLPRN:	CAME	TEMP,[TLPRN&17777777]	;PARAMS? 
;;%CU% (1/2) JFR 8-16-75 make this error continuable
	 JRST	[ERR	 <MISSING "(" IN MACRO CALL>,1
		MOVEI TEMP,SCANNER
		MOVEM TEMP,-4(P)
		JRST CONACT+2] ; NO
;;%CU% ^
	MOVEI	B,"("
	LSTDPB
	TLO	FF,PRMSCN 	; PRIME THE SCANNER FOR PARAMETER
	PUSHJ	P,FFPUSH	; SAVE OLD DEFLUK BIT OF FF AND TURN IT ON IN FF
;;#TG#	9-15-74 HJS RESTORE PARSE STACK POINTER 
PRMLUP:	MOVE	SP,PPSAV	; RESTORE SP SINCE IT POINTS TO THE
				; PARSE STACK SINCE OTHERWISE IT MAY
				; OVERFLOW SINCE STACK IS CALLED AT
				; THE END OF EACH PARAMETER SCAN 
;;#TG# 
	SKIPN 	REQDLM		; IN SPECIAL DELIMITER MODE? 
 	JRST	PRMOLD		; NO	
	PUSHJ	P,SCNPMR	; YES, GET THE PARAMETERS
	TRNA
PRMOLD:	PUSHJ	P,SCANNER	;GET A PARAMETER
	move	temp,p		;restore saved stacks
	POP	temp,GPSAV	;to keep stacks in synch
	POP	temp,PPSAV

; WE KNOW RESULT IS STRING CONSTANT, SCANNER WILL RETURN NO OTHER
ifn ftdebug,<		;but friends, officer Opie was just makin sure
	move	temp,(sp)	;semantics of scanned element
	came	temp,%stcon	;had better be a string
	 err <DRYROT: PRMLUP-SCANNER got a non-string as a parameter>
>;ifn ftdebug

	SKIPN	TEMP,DEFRN2	;PUT PTR TO FIRST ARG IN DEFRN2
	 MOVE	 TEMP,NEWSYM
	MOVEM	TEMP,DEFRN2

;; SDD 15-MAY-79 when looking for comma or paren, we are not scanning
;;		parameters.  (otherwise, the scanner will give null).
;;Was simply:	pushj	p,scanner
	tlzn	ff,prmscn	;clear "looking for parameter"
	 err <DRYROT: Scanning macro parameters, but not really>
	pushj 	p,scanner	;get next token (punctuation)
	tlo	ff,prmscn	;back into parameter scanning mode
;; ^^ SDD 15-MAY-79 ^^
	move	temp,p		;restore saved stacks
	POP	temp,GPSAV	;to keep stacks in synch
	POP	temp,PPSAV
	MOVE	TEMP,(SP)	;SYNTAX OF SCANNED ELEMENT
				;should be a comma or close paren
	CAMN	TEMP,[TCOMA&17777777]	;LOOPING?	
	 JRST	 PRMLUP		;YES
	CAME	TEMP,[TRPRN&17777777]	;DONE?  
;;%CU% (2/2) JFR 8-16-75 make this error continuable; even recoverable
;;	 JRST	[ERR	 <MISSING "," OR ")" IN MACRO CALL>,1
;;		MOVEI TEMP,SCANNER
;;		MOVEM TEMP,-4(P)
;;		JRST CONACT]
	 PUSHJ	P,[PUSHJ  P,ER40	;inserted missing )
		   JRST	SCNBAK]		;scanner is ahead
;;%CU% ^
	MOVE	LPSA,DEFRN2	; DETERMINE IF ALL PARAMETERS HAVE BEEN
	MOVEI	TEMP,0		;  SPECIFIED AND IF NOT FORM NULL'S FOR
DEFLNK:	HRRZ	LPSA,%RVARB(LPSA);  ALL THOSE LEFT OUT SO THAT ASSIGNC 
	ADDI	TEMP,1		;  WILL WORK PROPERLY 
	JUMPN	LPSA,DEFLNK	;
	MOVE	LPSA,-3(P)	; 
	HLRZ	LPSA,$VAL(LPSA)
;; SDD 25-OCT-78 KLUGE!!! special parameter count for "FORLC", since
;		it takes an arbitrary number of params, -1 for count
;		says "as many as I can get".  (There must be a better
;		way to do this.
	cain	lpsa,-1		;special "exactly" flag
	 jrst	conact		;yes, then don't bother making nulls
;; ^^ SDD 25-OCT-78 ^^
	SUB	TEMP,LPSA	; NUMBER OF UNSPECIFIED PARAMETERS
	MOVEM	TEMP,NULCNT	; 
	jumple	temp,tstdon
	err	<Warning: macro called with too many parameters>,1
TSTDON:	AOSLE	NULCNT		; ALL PARAMETERS SPECIFIED? 
	 JRST	CONACT		; YES, 
;;SDD 16-AUG-78 might as well use a constant string here
	getblk	newsym		; 
	movei	temp,2		;constant string, 2 characters long
	movem	temp,$pname(lpsa)
	move	temp,[point	7,[byte (7) 177,0] ]	; DEL,0 (EOM)
	movem	temp,$pname+1(lpsa)
;;^^ SDD 18-AUG-78 ^^
	MOVE	TEMP,[XWD CNST,STRING] ; 
	MOVEM	TEMP,$TBITS(LPSA) ; 
	PUSHJ	P,RNGSTR	; 
	PUSHJ	P,RNGVRB	; 
	JRST	TSTDON		; 

CONACT:	TLZ	FF,PRMSCN 	; DONE WITH THESE
	PUSHJ	P,FFPOP		; RESTORE DEFLUK BIT OF FF
	SKIPE 	REQDLM		; IN SPECIAL DELIMITER MODE?
	 SKIPN	SWBODY		; YES, HAVE TO REVERT TO OLD DELS?
	  JRST	NOPRMS		; NO
	SETZM	SWBODY		; RESET SWITCH DELIMITER DECLARATION FLAG
	SKIPN	RSTDLM		; RESTORING NULL DELIMITERS MODE?
	 JRST	cona.1		; NO
	SETZM	RSTDLM		; YES, RESTORE APPROPRIATE FLAGS
	SETZM	REQDLM		;
	JRST	NOPRMS		;
cona.1:	HRROI	TEMP,LOCMPR+1	; GET RESTORING ADDRESS
	POP	TEMP,CURPED	; RESTORE START DEL.
	POP	TEMP,CURPBG	; RESTORE END DEL.
NOPRMS: POP	P,GPSAV		; GET SEMANTIC STACK BACK
	POP	P,PPSAV		; GET PARSE STACK BACK
	POP	P,VARB		; GET OLD VARB BACK
	POP	P,LPSA		; SEMANTICS FOR DEFINE
	MOVE	SP,PPSAV	; RESTORE SP IN CASE IT GOT
				; FOULED UP IN SCANNER CALLS
	POPJ	P,		; RETURN




DSCR -- ACPMED
DES ACPMED prepares for a macro call once the actual parameters have
  been scanned.  It is also used to prepare for the first instantiation
  of the body of a conditional compilation WHILEC, CASEC, FORC, or
  FORLC statement.
PAR LPSA contains the semantics of the macro name or macro pseudonym in
  case a conditional compilation WHILEC, CASEC, FORC, or FORLC body is
  being scanned for the first time.  DEFRN2 contains the address of the
  actual parameter list in case of a FORLC statement, the address of
  the loop variable semblk in case of a FORC statement, and zero in
  the case of a WHILEC or CASEC statement.
RES At the end of this procedure one has effectively switched PNEXTC &
  PNEXTC-1 to scan the macro body or the conditional compilation body.
  Relevant information is saved on the DEFPDP stack.



^ACPMED: MOVE	PNT,DEFPDP	;RESTORE NOW
	PUSH	PNT,DEFRNG	;SAVE OLD RING OF PARAMETERS


	PUSH	PNT,PNEXTC-1	;STRING NUMBER
	PUSH	PNT,PNEXTC	;INSTEAD SAVE THOSE WHICH
	PUSH	PNT,SAVCHR	; PARAMETERS
	MOVEM	PNT,DEFPDP
	MOVE	PNT,PLINE	;SAVE IN IPLINE IF LEAVING INPUT LEVEL

	HLRZ	LPSA,%TLINK(LPSA) ; STORE THE LENGTH OF THE MACRO BODY
	HRLZ	TEMP,$PNAME(LPSA) ; lh OF DEFRNG SO THAT WHEN FINISHED
	HRR	TEMP,DEFRN2	;  SCANNING THERE WILL BE AN INDICATION
	MOVEM	TEMP,DEFRNG	;  OF THE AMOUNT OF STRING SPACE NEEDED
	PUSHJ	P,CONTX2	;  TO SCAN THE REMAINDER OF THE MACRO

; DECIDE WHETHER MACRO EXPANSION SHOULD BE LISTED.

	MOVEI	B,"<"		;MARK EXPANSION IF MACRO NAME
;;#YV# JFR 2-4-77
	TLNN	TBITS2,LSTEXP	; IS ALSO BEING LISTED
	 JRST	ACPM.1
	LSTDPB			;LISTING MIGHT BE OFF FOR OTHER REASONS
ACPM.1:
	TLON	TBITS2,MACIN	;IN A MACRO NOW
	MOVEM	PNT,IPLINE	;CAN GET CURRENT LINE LOC FROM HERE
	TLNN	TBITS2,MACEXP	;IF MACRO EXPANSION SHOULDNT BE LISTED,
	 TRO	TBITS2,NOLIST	; INDICATE IT
;;#YV# ^
	MOVEM	TBITS2,SCNWRD	;UPDATE IN CORE
	POPJ	P,		; RETURN




DSCR -- CONTXT
DES CONTXT is used to switch the input pointers before a macro call or
  prior to each invocation of the body of conditional compilation
  WHILEC, CASEC, FORC, or FORLC statement.  If conditional compilation
  is the case then this is virtually all that need be done for the
  reinvocation of the body, and thus it is clearly cheaper than
  calling the macro in the old sense several times with different
  variables (this statement is only true for the WHILEC, FORC, and
  FORLC statement since the body of a CASEC is only scanned once).
PAR LPSA contains the semantics of the macro name or macro pseudonym
  in the case of a conditional compilation WHILEC, CASEC, FORC, or
  FORLC statement.
RES PNEXTC, PNEXTC-1, PLINE, and PLINE-1 are set.



^CONTXT: HLRZ	LPSA,%TLINK(LPSA)	;SEMANTICS FOR MACRO BODY
CONTX2:	PUSHJ	P,SGCOL1	  ;MAKE SURE THERE'S ENOUGH ROOM
	HLLZ	TEMP,$PNAME(LPSA) ;STRING NUMBER -- NULL STRING
	MOVEM	TEMP,PNEXTC-1
	MOVEM	TEMP,PLINE-1
	MOVE	temp,$PNAME+1(LPSA)	;SET UP NEW INPUT POINTER
	MOVEM	temp,PNEXTC		;SET UP NEW INPUT POINTER
	MOVEM	TEMP,PLINE
	SETZM	SAVCHR		; NOTHING SCANNED AHEAD AT THIS LEVEL
	SETZM	LSTCHR		; NOTHING SCANNED AHEAD AT THIS LEVEL
	POPJ	P,		; RETURN


DSCR STRNG, etc.
DES Input a string constant. Check all identifiers to see if
  they are formal parameters to a DEFINE (macro). If so,
  replace them by their internal identifiers (delete <177>
  followed by unique code). Store string constant in string
  space, place entry in table, results to HPNT and NEWSYM. 
SEE Comments on following page for details of actual param thing.
  This loop is left by a jump to either DEFCHK (which may come back)
   or ENDSTR (which closes off the string and exits scanner)


prmstr:	clr$str			;setup buffer for creating string
				;and prepare c for id count
	jrst	bakstr		;use B for first char of result
STRNG:	TLZ	FF,PRMXXX	;IF " FIRST CHAR, NOT IN SPECIAL MODE
	clr$str			;setup buffer for creating string
				;and prepare c for id count
STSCAN:	ILDB	B,PNEXTC	;PRESERVE NEXT CHARACTER
BAKSTR:	SKIPGE	A,SCNTBL(B)	;DO SPECIAL THINGS
	 PUSHJ	P,CSPEC		;IF REQUIRED
BAKST1:	TLNN	A,LETDG		;THINK HARD ONLY ON QUOTE, LETTDIG
	 JRST 	MORSTR		; NOT LETTER OR DIGIT
	TLNE	FF,DEFLUK	;inputting a macro body?
	 TLNE	FF,PRMSCN	; YES, SCANNING MACRO PARAMETERS
	  JRST 	MORSTR		; YES, CHECK DELIMITERS
	SKIPN 	REQDLM		; SPECIAL DELIMITER MODE?
	 JRST	DEFCHK 		; NO, THINK HARD
	CAMN 	B,CURMED	; MACRO BODY END DELIMITER?
	 JRST	LTDEND		; YES, CHECK IF DONE
	CAMN	B,CURMBG	; MACRO BODY BEGIN DELIMITER?
	 AOS	BNSTCN		; YES, INCREMENT NEST COUNT
	JRST	DEFCHK		; THINK HARD

LTDEND:	SOSL	BNSTCN		;DECREMENT NEST COUNT AND CHECK IF DONE
	 JRST	DEFCHK		; THINK HARD
	JRST 	LTDCON		; TERMINATE MACRO BODY SCAN

MORSTR:	TLNN	FF,PRMXXX	;IN SPECIAL PARAMETER-SCANNING MODE?
	 JRST	 MORST1		; NO, CONTINUE

	CAIE	B,","		;END OF PARAMETER?
	 CAIN	B,")"
	  JRST	 ENDSTR		; YES
				;LET SINGLE QUOTES THRU IN THIS MODE
	aobjn	c,depo1-1(tbits2)
	jrst	depo.b
MORST1:	SKIPN	DLMSTG		; A SPECIALLY DELIMITED STRING?
	 JRST 	MORST2		; NO, GO CHECK FOR QUOTES
	CAMN	B,CURMED	; MACRO BODY END DELIMITER?
	 JRST	MBDEND		; YES
	CAMN	B,CURMBG	; MACRO BEGIN DELIMITER?
	 AOS	BNSTCN		; YES, INCREMENT NEST COUNT
	aobjn	c,depo1-1(tbits2)
	jrst	depo.b

MBDEND:	SOSL	BNSTCN		;DECREMENT NEST COUNT AND CHECK IF DONE
	 jrst 	depo.c		; DEPOSIT
LTDCON:	LSTDPB			; PUT IT AWAY
	ILDB	B,PNEXTC 	; GET NEXT CHAR. TO KEEP IN SYNCH.
	SKIPGE	A,SCNTBL(B)	; SPECIAL?
	 PUSHJ	P,CSPEC		;DO IT
	JRST	ENDSTR		; GO TO END

MORST2:	TLNN	A,QUOTE		;END OR DOUBLE-QUOTE ?
	 jrst	 depo.c		; NO, PUT IT AWAY

	LSTDPB			;PUT IT AWAY
	ILDB	B,PNEXTC	;TRY NEXT
	SKIPGE	A,SCNTBL(B)	; DO THE USUAL IF SPCL
	 PUSHJ	P,CSPEC
	TLNN	A,QUOTE		;IS IT ONE?
	 JRST[	SKIPE BAKDLM	; YES, CHECK IF NEED TO RESTORE DLMSTG
		 SETOM	DLMSTG		; YES
		SETZM	BAKDLM		; TURN OFF BAKDLM
		JRST	ENDSTR]	; DONE

depo.c:	aobjn	c,depo1-1(tbits2)
depo.b:	mor$str
DEPOSIT:
	LSTDPB			;TO LISTING FILE IF REQD
DEPO1:	IDPB	B,TOPBYTE(USER)	;STORE CHARACTER AS IS
	jrst	stscan		;LOOP ON RANDOM CHARACTERS



cnstrg:	;;actually just a string constant, no DEFCHK or parameter check
ifn ftdebug, <
	tlnn	ff,prmxxx	;special parameter scanning bit
	 skipe	bakdlm		;says we have single-use delimiters
	  err	<DRYROT: BAKDLM and-or PRMXXX on at CNSTRNG>
	skipe	dlmstg		;nor should string delimiters be here
	 err	<DRYROT: DLMSTG on at CNSTRNG>
>;ifn ftdebug
	clr$str			;set up AOBJN style C for pname length
	jrst	cns.lp+1	;initial quote already listed,
				; and is not part of the actual string
	ml$chr			;list character in B
cns.lp:	idpb	b,topbyte(user)	;put character into string being built
	ildb	b,pnextc	;get another character
	skipge	a,scntbl(b)	;check for specials
	 pushj	p,cspec		;and cope with them
	tlne	a,quote		;was this a (possible) end-of-string
	 jrst	cns.qt(tbits2)	; yes, go find out if really done
cns.go:	aobjn	c,cns.lp-1(tbits2);list if necessary and deposit
	mor$str			;hold on, we need more buffer
	jrst	cns.lp-1(tbits2);and proceed

cns.qt:	ml$chr			;list the quote mark
	ildb	p,pnextc	;now see if two quotes in a row
	skipge	a,scntbl(b)	;but handle specials correctly
	 pushj	p,cspec		; this makes very strange macros maybe
	tlnn	a,quote		;well, were we done with the string?
	 jrst	cns.go		; no, go put the quote in the string
ifn ftdebug, <
	tlnn	ff,prmxxx	;special parameter scanning bit
	 skipe	bakdlm		;says we have single-use delimiters
	  err	<DRYROT: BAKDLM and-or PRMXXX on at CNSTRNG>
	skipe	dlmstg		;nor should string delimiters be here
	 err	<DRYROT: DLMSTG on at CNSTRNG>
>;ifn ftdebug
	jrst	endstr		;well, go finish off the poor string

COMMENT $ 
We come here if a letter or number has been seen.  If we are not
 scanning a macro body, we simply scan the rest of the characters
 which could be an identifier into the string constant, and return
 to the main string constant scanning loop.

If we are scanning a macro body, this may be a parameter name.
 The following algorithm is used:
   1. If not a letter, continue as if were not scanning macro body.
   2. Save the length of the string up to the start of the ident.
   3. Scan this (possible) param into the constant, no case conversion.
   4. Save the length of the string up to the end of the ident.
   5. Save state of scanner (char, bits), then get enough room for the
      ident aligned on a word boundary in string space.  Copy the ident
      into that space (converting to upper case and fixing !'s), and
      look up the name so obtained.  Quickly erase and return the
      space that was used to convert the identifier.  (This replaces
      a messy recursion into DSCAN).
   6. If not a DEFINE parameter, reset TOPBYTE and PNAME pointers to
      their state at the end of step 3, and return to main string
      constant loop.
   7. Back TOPBYTE pointer up to the length of step 2, insert '177
      (param marker), followed by param number into string, clear space
      used during steps 3 and 4, update PNAME count properly, and
      return to main loop.  (Note this may have extended space by one
      character if the parameter name was one character long).

 Substring operations are used to retrieve the relevant byte
 pointers from the saved lengths, and only when they are really
 needed, to avoid the garbage collect problems with multiple
 saved pointers which plagued past implementations, and made
 the multiple string space implementation impossible.

Be warned (again) that the current setup is the result of several
 (+1) killed bugs  --  each  thought to  be the  last.  No
 guarantees are proferred that no more exist, but chances are
 (even) better than ever.
$


;; DEFCHK either immediately leaves, or stacks C and loops until time
;; to go to SEEPRM
DEFCHK:	TLNE	A,dig+dot+atsign+quocte	;any of these start numbers,
	 JRST	 depo.c		; not identifiers, proceed with scan

	hrrzi	temp,(c)
	push	p,temp		;save length just before scanning ident
RANSCN:	aobjn	c,ransc1-1(tbits2)	;COUNT FIRST CHAR
	mor$str		;(GC if necessary)

	LSTDPB			;LIST IF NECESSARY
RANSC1:	IDPB	B,TOPBYTE(USER)	;KNOW FIRST ONE IS OK
	ILDB	B,PNEXTC
	SKIPGE	A,SCNTBL(B)	;USUAL TEST
	 PUSHJ	 P,CSPEC
	TLNN	A,LETDG
	 JRST	SEEPRM		; NOT A LETTER OR DIGIT
	SKIPN	REQDLM		; SPECIAL DELIMITER MODE
	 JRST 	ranscn		; NO
	CAMN	B,CURMED	; MACRO BODY END DELIMITER
	 JRST	MBEDCK		; YES
	CAMN	B,CURMBG	; MACRO BODY BEGIN DELIMITER
	 AOS	BNSTCN		; YES, INCREMENT NEST COUNT
	aobjn	c,ransc1-1(tbits2); CONTINUE ID SCAN
	mor$str			;(oh well, go GC)
	jrst	ransc1-1(tbits2)
MBEDCK:	SOSL 	BNSTCN		; DONE WITH MACRO BODY
	 jrst	ranscn		; COUNT AND LOOP

; NOW CONVERT IDENT TO UPPER CASE (ALIGNED) AND GO LOOK IT UP

SEEPRM:	exch	a,(p)		;save bits to handle
	push	p,b		;and actual character (for later)
	push	p,a		;and length of string before ID
	cls$str			;now update the string in PNAME
				;(after all, we may need to GC)
				;total length is in PNAME (and C)
; P stack is:
;  -2 -- "a" bits at end of ID
;  -1 -- character received at end of ID
;   0 -- length before ident scanned into string const
	hrrz	temp,(p)	;now estimate space needed
				; length(macro-body up to ID)
	subi	temp,5(c)	; - length(macro-body with ID)
				; - 5   [max bytes needed to align]
				; gives -(free chars needed)
	camle	temp,remchr(user);make sure we have enough space
				;see: remchr and temp are both negative
	 jrst	seep.g		;yep, what's the worry?
	movn	temp,temp	;get positive of size we need
	push	p,temp		;number of necessary chars
	exch	c,tbits		;save tbits
	pushj	p,strgc		;go do a gc
	move	tbits,c		;recover tbits

seep.g:
   ;OK, now we will CHEAT on string space.  The id will be converted to
   ;token chars (upper case+) in unused string space, the token version
   ;will be used to do a symbol lookup to determine if it is a macro
   ;parameter, and then immediately wiped out (end of illegal use).
	exch	sp,stpsav	;we may cheat on char area, but stack..
	movss	povtab+6	;had better not overflow while we do
	push	sp,pname	;save what we have passed so far
	push	sp,pname+1

	hrrz	c,(p)		;get length(macro-body upto ID start)
	jsp	b,pn.sub	;stack pname[1+c TO INF] on sp
	move	temp,topbyte(user);make new ID byte pointer
	addi	temp,1		;make sure don't tromp on PNAME string
	hrli	temp,440700	;(must be word-aligned)
	movem	temp,pname+1
	hrrz	c,-1(sp)	; length(ID)
	movem	c,pname		; now PNAME is constant pointer to ID
				;update area where it will be converted
coplup:	ildb	b,(sp)		;get old ID char (null strings bomb)
IFN FTDEBUG, <
	skipl	a,scntbl(b)	;note that all of the ID chars should
	 tlnn	a,letdg		;be non-special and valid in ID's
	  err	<DRYROT: SEEPRM says uggh>
; ELSE>	move	a,scntbl(b)	;translate to proper ID character
	idpb	a,temp		;store converted character in new ID
	sojg	c,coplup	;and keep going until full id processed
	sub	sp,x22		;remove leftover junk from string stack

	move	lpsa,symtab
	pushj	p,shash		;go find ID in symbol table (if we can)

	hrrz	c,pname		;now throw away temp string quick
	move	b,pname+1	;we know for sure word boundary
clrlup:	setzm	(b)		;clear a word of the ID
	subi	c,5		;c is characters left to clear
	caile	c,0		;stop when everything cleared
	 aoja	b,clrlup	;bump address of word to clear and go

	pop	sp,pname+1	;restore pname to macro body including
	pop	sp,pname	;including the ID we just looked up

;;check if if we did find a macro parameter
	SKIPG	LPSA,NEWSYM	;THESE TESTS DETERMINE IF 
	 JRST	 NOPAR		; (1) THERE IS A SYMBOL OF THIS NAME
	SKIPGE	TBITS,$TBITS(LPSA)
	 JRST	 NOPAR		; (2) IT IS NOT A RESERVED WORD
	TLNE	TBITS,FORMAL
	TLNN	TBITS,DEFINE
	 JRST	 NOPAR		; (3) IT IS A MACRO PARAMETER NAME

	hrrz	c,(p)		;pick up length to start of ID
	jsp	b,pn.sub	;redo the substring to get ident start
	pop	sp,temp		;get byte pointer to ident part
	pop	sp,c		;and get count of chars in ident part
	movei	b,177		;replace ident w/ DEL (parameter flag)
	idpb	b,temp
	hrrz	b,$VAL(lpsa)	;followed by parameter number
	idpb	b,temp		;which could be extending the string by
				;one, but we had extra at seep.g anyway
	movem	temp,topbyte(user) ;fix TOPBYTE to point after those 2
	hrrei	c,-2(c)		;we are backing up the end pointer by
	movn	c,c		; length(ID)-2 characters, so fix up
	addm	c,pname		;the string in pname
	addm	c,remchr(user)	;and REMCHR(USER) to reflect the change
	jumpge	c,nopar		;now erase remains of ident (if any)
	setz	b,		;get a zero to spread around
	idpb	b,temp		;in the otherwise clean string space
	aojl	c,.-1

nopar:	exch	sp,stpsav	;OK, done with string stuff
	movss	povtab+6	;let sp change flavor again
	pop	p,b		;remove saved length
	pop	p,b		;get back char after ID (or pseudo-id)
	pop	p,a		;and also recover its various bits
	add$str			;re-establish AOBJN-style string
	jrst	morstr		;and go back to string loop (we know
				;that the pending character in A/B
				;was not a letter or digit since it
				;stopped the loop at RANSCN

pn.sub:	; called with JSP b,pn.sub
	;takes in C an arg (sc) -- count of chars to skip over in PNAME
	;returns with PNAME [1+sc TO INF] pushed onto SP

	push	sp,pname	;string we want the substring from
	push	sp,pname+1
	hrrz	temp,pname
	subi	temp,(c)	; ie: FOR INF-sc
	push	p,temp
	MOVEI	c,1(c)		;ADAPT TO SAIL CONVENTIONS
	push	p,c		;now we have PNAME[1+sc FOR INF-sc]
	MOVE	C,LPSA		;SAVE LPSA
EXTERN	SUBSR
	PUSHJ	P,SUBSR		;call the real substringer
	MOVE	LPSA,C		;RESTORE LPSA
	MOVE	USER,GOGTAB	;and USER
	JRST	(B)		;and return


Comment $	End of string constant -- set up results for stacking,
	go do it
$

ENDSTR:
	MOVEM	TBITS2,SCNWRD	;PUT ALL THE BITS AWAY
	LSTDPB			;PUT "," OR ")" AWAY
	TLZ	FF,PRMXXX
	CAIE	B,12		;LF IS SPECIAL PROBLEM!
	 MOVEM	B,SAVCHR	;SAVE BITS FOR NEXT TIME
	MOVEM	B,LSTCHR	;ALSO HERE ANY TIME
	SKIPN	SWCPRS		; SWITCHING PARSERS OK?  
	 JRST	NOSWCH		; NO, 
;; #QV (1 OF 2) WILL NOW USE ENDMAC TO ADD 177-0 TO ASSIGNC BODIES
	TLNE	FF,PRMSCN	; SCANNING ACTUALS? 
	 JRST	ENDACT		; YES, APPEND 1770 TO MACRO ACTUALS 
	JRST	NOMACW		; NO, 
;; #QV#
NOSWCH:	SKIPN	IFCREC		;EXPAND MACROS IN FALSE OF COND COMP? 
	 TLNN	FF,PRMSCN	; YES, SCANNING MACRO ACTUALS? 
	  JRST	[cls$str		;finish off string
		 JRST	STCTYP]		;but don't enter it
ENDACT: aobjn	c,enda.1	;FOR ACTUAL PARAMETERS APPEND 177-0 TO
	mor$str
enda.1:	MOVEI	TEMP,177	;STRING, GET A SEMBLK AND PLACE IT ON
	IDPB	TEMP,TOPBYTE(USER);THE STRING RING. ACTUAL PARAMETERS
	aobjn	c,enda.2
	mor$str
enda.2:	MOVEI	TEMP,0		;TO MACROS ARE LINKED ON THE VARB RING.
	IDPB	TEMP,TOPBYTE(USER);A MACRO CALL IS FINISHED ALL THAT
	cls$str			;REMAINS TO DO IS KILLST ALONG THE 
	GETBLK	NEWSYM		;VARB RING POINTED TO BY DEFRNG.  
	HRROI	TEMP,PNAME+1	;
	POP	TEMP,$PNAME+1(LPSA) ;
	POP	TEMP,$PNAME(LPSA) ;
	MOVE	TEMP,[XWD CNST,STRING];MAKE SEMBLK OF ACTUAL PARAMETER
	MOVEM	TEMP,$TBITS(LPSA);LOOK LIKE A STRING CONSTANT SEMBLK
	PUSHJ	P,RNGSTR	;EXCEPT FOR THE FACT THAT IT IS NOT
				;LINKED ON THE STRING CONSTANT RING
;; #QV (2 OF 2) ! REMOVED TEST ON ASGFLG HERE
	PUSHJ	P,RNGVRB	;
	MOVE	LPSA,NEWSYM	;
	MOVE	A,%STCON	;
	JRST	STACK		;
NOMACW:
	cls$str			; finish off string being collected
	PUSH	P,BITS
	PUSHJ	P,STRINS	; CHECK IF STRING HAS ALREADY BEEN 
	POP	P,BITS		; ENTERED IN THE SYMBOL TABLE AND IF
	MOVE	LPSA,PNT	; NOT THEN ENTER IT
	MOVEM	LPSA,NEWSYM	;
STCTYP:	MOVE	A,%STCON	;
	JRST	STACK		;


DSCR SCNUMB -- number scanner
DES Scan a number -- keep both REAL (floating) and fixed
  representations around, use the appropriate one at the end.
 A number is composed of integers and various special characters.
 See the syntax for a better definition, but here is a summary:

		<int><.<int>><@<+|->int>

 Common sense should indicate that some of these things must
  be present to constitute a legal number. The results
  are returned as described on the opening page of SCAN.


begin	number
^SCNUMB:
;; eventual return either charout or stack
;; (charout iff "@" and false cond comp or inline (@=indirect))


; @ CHARACTER TO BE TREATED AS DELIMITER IF INSIDE START!CODE
;  BLOCK

	TLNN	A,ATSIGN	; AT SIGN? 
;;#YA# ! (1/2) JFR 1-3-77 CLEAR FLAGS FOR SAFETY
	 JRST	2,@[SCNM1]	; NO, GET REST OF NUMBER 
	SKIPN	cndlst		;YES,IN FALSE CONDITIONAL COMPILATION? 
	 JRST	ATOUT		; YES, TREAT AT SIGN AS A PARSE TOKEN 
	TLNN	TBITS2,INLIN	; NO, IN-LINE CODE? 
;;#YA# ! (2/2)
	 JRST	2,@[SCNM1]	; NO, GET REST OF NUMBER 

ATOUT:	MOVE	A,%ATS		;GET BITS FOR AT SIGN DELIMITER
	JRST	CHAROUT		;HANDLE AS DELIMITER

SCNM1:
	SETZB	C,SCNVAL	;DIGITS CTR, VALUE
	SETZB	SBITS2,DBLVAL	;FLAGS, LOW HALF OF LONG VALUE
	TLNN	A,QUOCTE	;OCTAL QUOTE MARK (') ?
	 JRST	 DECIM		;NO, DECIMAL NUMBER

	SETZB	LPSA,LPSA+1	;ACCUMULATE HERE
OCTL:	ILDB	B,PNEXTC	;GET BACK IN SYNCH
	SKIPGE	A,SCNTBL(B)
	 PUSHJ	P,(A)		;USUAL SPECIAL TREATMENT
	LSTDPB
	MOVE	LPSA,SCNVAL
	MOVE	LPSA+1,DBLVAL
;; 25-OCT-78 SDD single or double checked later anyway
	tlnn	a,dig
	 jrst	endnum		;we ran out of digits, must be done
;; WAS:
;	TLNE	A,DIG
;	 JRST	OCTL1
;	JUMPE	LPSA,ENDNUM	;SINGLE PRECISION INTEGER
;	IORI	SBITS2,DBLPRC	;LONG INTEGER
;	JRST	ENDNUM
;; ^^ 25-OCT-78 SDD ^^
OCTL1:
;; 25-OCT-78 SDD check for overflow on octal constants
	tlne	lpsa,700000	;make sure no triple precision
	 tlo	sbits2,intov	;call that an overflow
;; ^^ 25-OCT-78 SDD ^^
	LSHC	LPSA,3
	ADDI	LPSA+1,-"0"(A)
	JOV	[ADDI	LPSA,1	;IN CASE SOME JOKER SAYS '777777777778
;; 25-OCT-78 SDD check for overflow on octal constants
		jov [tlo sbits2,intov	;this we really call overflow
		     jrst .+1]
;;WAS:
;		JOV	.+1	;TOP PART COULD OVERFLOW, TOO
;; ^^ 25-OCT-78 SDD ^^
		JRST	.+1]
	MOVEM	LPSA,SCNVAL
	MOVEM	LPSA+1,DBLVAL
	AOJA	C,OCTL		;COUNT DIGITS TO DETECT LONE '


DECIM:
	PUSHJ	P,GETINT	;CLEAR COUNT, GET INTEGER
	TLNN	A,DOT+ATSIGN	;PART OF REAL NUMBER?
	 JRST	ENDNMZ		;NO, REST OF TRASH GOES
	PUSH	P,C		;SAVE DIGIT COUNTS
	TLNE	A,DOT
	 PUSHJ	P,TZ		;TRY FOR MORE INTEGER
	HLRZ	D,C		;# TRAILING ZEROES
	SUBI	D,(C)		;-(# DIGITS WHICH ARE NOT TRAILING ZEROES)
	ADDM	D,(P)		;RH (P) = AMOUNT TO ADD TO EXPONENT
	PUSH	P,SCNVAL	;SAVE FRACTION VALUE
	PUSH	P,DBLVAL
	TLZ	SBITS2,INTOV	;IGNORE OVERFLOW FROM MANTISSA,
				;SINCE THAT JUST MEANS SOME OF
				;THE DIGITS WERE INSIGNIFICANT
	SETZM	SCNVAL		;INITIAL EXPONENT VALUE
	SETZB	C,DBLVAL
	TLNN	A,ATSIGN	;ANY MORE REAL LEFT?
	 JRST	FIXAT1		;END OF REAL NUMBER
NODOT1:	ILDB	B,PNEXTC	;GET NEXT CHARACTER,
	SKIPGE	A,SCNTBL(B)	;BUT DEFER LISTING A BIT
	 PUSHJ	P,(A)
	TLNN	A,ATSIGN	;SECOND "@"
	 JRST	NODOT2		;NO
	IORI	SBITS2,DBLPRC	;YES, LONG PRECISION
	LSTDPB			;WELL, WE HAD BETTER LIST IT
	ILDB	B,PNEXTC	;NOW GET A CHARACTER FORWARD
	SKIPGE	A,SCNTBL(B)	;BUT DON'T LIST JUST YET
	 PUSHJ	P,(A)
NODOT2:
	PUSH	P,[FIXAT]	;WHEVER WE GO, WE RETURN THERE
	CAIN	B,"-"		;MINUS?
	 TLOA	 SBITS2,EXPNEG	; YES, EXPONENT NEGATIVE
	CAIN	B,"+"		;NO, PLUS?
	 JRST	 LGETINT-1(TBITS2)	;LIST, PLUS OR MINUS, GET DIGIT
	 JRST	 GETINT-1(TBITS2)	;LIST DIGIT, USE IN NUMBER
FIXAT:	PUSHJ	P,TZMUL		;EXPAND TRAILING ZEROS
FIXAT1:		;CONVERT NUMBER TO FLOATING POINT. EXPONENT IS
		;IN SCNVAL,DBLVAL (SIGN IS EXPNEG IN SBITS2),
		;MANTISSA IS -1(P),(P) (FRACTION) RH(-2(P)) ADDS TO
		;OVERFLOW CONDITIONS ARE PRESUMED TO BE FOR EXPONENT
	TRO	SBITS2,FLOTNG
	SKIPN	(P)		;IS RESULT ZERO?
	SKIPE	-1(P)
	 JRST	fixa.n		;NO
	SUB	P,X33		;YES, REMOVE 2 VALUE WORDS AND DIGIT
	JRST	RETZER		; COUNTER WORD, AND MAKE LIFE SIMPLE
fixa.n:	MOVE	D,DBLVAL	;PICK UP EXPONENT
	TLNN	D,-1		;THAT WOULD BE A HUGE EXPONENT
	SKIPE	SCNVAL		;IF THIS IS NOT ZERO
	 JRST	EXPER3		;THEN WE HAVE A WHOPPING BIG EXPONENT
	TLZN	SBITS2,EXPNEG	;NEGATIVE EXPONENT?
	SKIPA	D,DBLVAL	;NO
	MOVN	D,DBLVAL	;YES
	POP	P,DBLVAL	;RETRIEVE MANTISSA
	POP	P,SCNVAL
	ADD	D,(P)
	HRREI	D,(D)		;EXPONENT OF 10
	SUB	P,X11		;DONE WITH FORMER DIGIT CTR WORD
	MOVE	LPSA,SCNVAL	;BEGIN CONVERTING MANTISSA TO PURE FRACTION
	JFFO	LPSA,DFSC
	MOVE	LPSA,DBLVAL	;HIGH ORDER WORD WAS ALL ZERO
	JFFO	LPSA,.+1
	ADDI	LPSA+1,=35	;HIGH WORD WAS ALL ZERO
DFSC:	MOVEI	C,-1(LPSA+1)	;# OF PLACES TO SHIFT (REMEMBER SIGN BIT)
	MOVE	LPSA,SCNVAL	;GET MANTISSA
	MOVE	LPSA+1,DBLVAL
	ASHC	LPSA,(C)	;MAKE MANTISSA INTO PURE FRACTION
	SUBI	C,=70
	MOVN	C,C		;C=EXPONENT OF 2 OF MANTISSA
	JUMPE	D,DFSC2		;EXPONENT OF 10 WAS ZERO
	PUSH	P,A		;SAVE BITS
	hrrzi	A,ten.p1	;ASSUME EXPONENT OF 10 IS POSITIVE
	JUMPG	D,DFSCA
	TLO	SBITS2,EXPNEG	;EXPONENT WAS NEG
	MOVN	D,D
	addi	a,3		;use the negative powers table part
DFSCA:	MOVEM	LPSA,SCNVAL
	MOVEM	LPSA+1,DBLVAL
	TRNE	D,777700	;CHECK MAGNITUDE OF EXP OF 10
	 JRST	EXPERR		;EXPONENT IS TOO BIG
;	TRNE	D,40		;E+-32 INVOLVED?
;	TLNE	SBITS2,EXPNEG	;EXPONENT NEGATIVE?
;	 JRST	MULOOP		;NO
;	TRNE	D,20		;OUT OF RANGE IF E-48
;	 JRST	EXPERR		;BAD
MULOOP:	TRNE	D,1		;SHOULD WE MULTIPLY?
	 PUSHJ	P,DMUL..		;YES
	ASH	D,-1		;NEXT BIT INTO POSITION
	addi	a,6		;point to next table entry
	jumpn	d,muloop	;and keep going until no more exponent

DFSC1:	POP	P,A		;GET BITS BACK
	MOVE	LPSA,SCNVAL	;GET VALUE
	MOVE	LPSA+1,DBLVAL
	TRNN	LPSA+1,400	;ROUND?
	 JRST	DFSC2		;NO
	TLO	LPSA,400000	;PREVENT
	TLO	LPSA+1,400000	; OVERFLOWS
	ADDI	LPSA+1,400	;YES
	TLZN	LPSA+1,400000	;WOULD THERE HAVE BEEN AN OVERFLOW?
	 ADDI	LPSA,1		;YES
	TLZE	LPSA,400000
	 JRST	DFSC2		;NO OVERFLOW
	MOVSI	LPSA,200000	;HIGH WD EXACTLY .1 (BASE 2)
	ADDI	C,1		;EXPONENT HAS INCREASED
	LSH	LPSA+1,-1	;KEEP LOW WD ALIGNED PROPERLY
DFSC2:	ASHC	LPSA,-8		;MAKE ROOM FOR EXPONENT
	FSC	LPSA,200(C)	;AND INSERT IT
	JFOV	EXPERR
	JRST	ENDNUM		;FINALLY DONE (EXCEPT TEST OVERFLOW FLAGS)

EXPER3:	SUB	P,X33
EXPERR:
;; SDD 25-OCT-78 don't complain in false conditional compilation
	skipe	swcprs		;seems like it should be cndlst, but no
;; ^^ SDD 25-OCT-78
	ERR	<EXPONENT RANGE EXCEEDED>,1
	HRLOI	LPSA,377777	;SET UP AN INFINITY
	MOVE	LPSA+1,LPSA
	TLNE	SBITS2,EXPNEG
RETZER:	 SETZB	LPSA,LPSA+1	;BUT USE ZERO IF EXPONENT WAS NEG
	JRST	ENDNUM

ENDNMZ:	PUSHJ	P,TZMUL		;TRAILING ZEROES NOW SIGNIF.
	MOVE	LPSA,SCNVAL
	MOVE	LPSA+1,DBLVAL
ENDNUM:
	TLNN	A,LETDG 	;MUST NOT BE LEETTER OR DIG OR
	JRST	EATEN
EATEND:	ILDB	B,PNEXTC	;SCAN TILL PAST GARBAGE
	SKIPGE	A,SCNTBL(B)
	 PUSHJ	P,(A)
	TLNE	A,LETDG
	 JRST	EATEND-1(TBITS2)
	SKIPE	SWCPRS		;DONT COMPLAIN IF FALSE PART
	ERR <ILLEGAL CONSTANT>,1
	LSTDPB
EATEN:	CAIE	B,12		;EXCEPT FOR LINE FEED,
	 MOVEM	B,SAVCHR	;SAVE FOR NEXT SCAN
	MOVEM	B,LSTCHR	;ALSO HERE ANY TIME
	TRNN	SBITS2,FLOTNG	;REAL OR INTEGER?
	 JRST	 INTEG
	TRNN	SBITS2,DBLPRC
	 SNGL	LPSA,LPSA	;ONLY SINGLE ASKED FOR
	JRST	NUMRET

	ML$CHR
	
INTEG:
	TRO	SBITS2,INTEGR	;MARK TYPE
;; SDD 25-OCT-78 don't complain in false conditional compilation
	exch	lpsa,lpsa+1	;since we only have single precision
	skipn	swcprs		;seems like it should be cndlst, but no
	 jrst	numtyp
	cain	lpsa+1,0	;integer wound up needing two words?
;; ^^ SDD 25-OCT-78
	TLNE	SBITS2,INTOV	;INTEGER OVERFLOW?
	 ERR	 <INTEGER CONSTANT TOO LARGE>,1
	SKIPN	C		;MAKE SURE THERE WAS SOMETHING
	 ERR	 <ILLEGAL INTEGER CONSTANT>,1
NUMRET:	SKIPN	SWCPRS		; not cndlst (why?)
				; INSIDE FALSE CONDITIONAL COMPILATION? 
	 JRST	NUMTYP		; YES, DON'T ENTER THE NUMBER 
	HRLI	SBITS2,CNST	; MAKE INTO TBITS WORD
	PUSH	P,BITS		;DON'T EFFECT OUTSIDE WORLD
	MOVEM	SBITS2,BITS		;SET UP FOR ENTER
;; SDD 25-OCT-78 this just has to be wrong!!!
;	JUMPN	LPSA,.+2
;	 EXCH	LPSA,LPSA+1	;SINGLE PRECISION INTEGER ONLY
;; ^^ SDD 25-OCT-78 ^^
	MOVEM	LPSA,SCNVAL
	MOVEM	LPSA+1,DBLVAL
	PUSHJ	P,NHASH		;LOOK UP THE NUMBER
	SKIPG	NEWSYM		;WAS IT THERE ALREADY?
	 PUSHJ	 P,ENTERS	; NO, BUT IT IS NOW
	POP	P,BITS		;GET OLD BITS BACK
	MOVE	LPSA,NEWSYM	;SET UP FOR STACKING
NUMTYP:	MOVE	A,%NUMCON
	JRST	STACK		;GO DO IT



;MULTIPLY TWO DOUBLE-LENGTH PURE FRACTIONS.
; ONE IS 0(A),1(A) [exponent of two at -1(A)],
; OTHER IS SCNVAL,DBLVAL [exponent of two at C].
;RETURN DOUBLE-LENGTH RESULT IN SCNVAL,DBLVAL [C]
DMUL..:
NOKL10<	PUSH	P,SCNVAL	;SAVE HIGH
	SETZM	SCNVAL		;1ST WORD, FINAL PRODUCT
	MOVE	LPSA,(A)	;HIGH
	MULM	LPSA,DBLVAL	;* LOW
				;IGNORING 3RD WORDS: 8 EXP BITS TO BURN
	MOVE	LPSA,1(A)	;LOW
	MUL	LPSA,(P)	;* HIGH
	TLO	LPSA,400000	;PREVENT OVERFLOWS
	ADD	LPSA,DBLVAL	;ADD 2ND WORDS
	TLZN	LPSA,400000	;WOULD THERE HAVE BEEN AN OVERFLOW?
	 AOS	SCNVAL		;YES, DO CARRY (SETS SCNVAL TO 1)
	MOVEM	LPSA,DBLVAL	;STORE LOW RESULT
	POP	P,LPSA		;HIGH
	MUL	LPSA,(A)	;* HIGH
	TLO	LPSA+1,400000	;PREVENT OVERFLOW
	ADD	LPSA+1,DBLVAL	;COLLECT 2ND WORD
	TLZN	LPSA+1,400000	;WOULD THERE HAVE BEEN AN OVERFLOW?
	 ADDI	LPSA,1		;YES
	ADD	LPSA,SCNVAL	;COLLECT 1ST WORD (THIS CAN'T OVERFLOW)
>;NOKL10
KL10<
	DMOVE	LPSA,SCNVAL
	DMOVEM	LPSA+2,SCNVAL
	DMUL	LPSA,(A)
	JOV	[TLO	SBITS2,INTOV
		JRST	.+1]
	DMOVE	LPSA+2,SCNVAL
>;KL10
	TLNE	LPSA,(1B1)	;NORMALIZED FRACTION?
	 JRST	.+3		;YES
	ASHC	LPSA,1		;NO, SHIFT OVER
	SUBI	C,1		;AND ADJUST EXPONENT
	ADD	C,-1(A)		;COLLECT EXPONENT CHANGES
	MOVEM	LPSA,SCNVAL	;STORE RESULT SO FAR
	MOVEM	LPSA+1,DBLVAL
	POPJ	P,


Comment $
Get an integer (base 10 only for the present).
C has	# trailing zeroes ,, # digits
$
	ML$CHR		;SO WE CAN LIST COMING IN
LGETINT:		;GET A CHARACTER FIRST
	ILDB	B,PNEXTC
	SKIPGE	A,SCNTBL(B)
	PUSHJ	P,(A)	;SIGH!
	LSTDPB

GETINT:	JOV	.+1	;GET AN INTEGER
	TDZA	C,C		;SET # DECIMAL PLACES TO 0

	ML$CHR			;PUT AWAY
GETLUP:	TLNN	A,DIG		;IS IT A DIG?
	 POPJ	  P,		; NO, RETURN
	TLNN	SBITS2,INTOV	;TREAT REST OF DIGITS AS TRAILING ZERO
	CAIN	B,"0"
	AOBJP	C,TZ		;A TRAILING ZERO
	TLNN	C,-1		;HAVE DIGIT. WERE THERE TRAILING ZEROES BEFORE IT?
	 JRST	NOTZ		;NO. COUNT DIGIT AND LEAVE
	PUSHJ	P,TZMUL		;TRAILING ZEROES NOW SIGNIF.
	TLNE	C,-1		;COULDN'T DISCHARGE ZEROES, ERROR
	 AOBJP	C,TZ		;OK, MAKE BELIEVE A TRAILING ZERO
NOTZ:	PUSHJ	P,M10ADA	;MULTIPLY BY 10 AND ADD A
	TLNE	SBITS2,INTOV	;DIDN'T ACTUALLY WORK?
	 AOBJP	C,TZ		;caused overflow, treat as trailing 0
	AOJA	C,TZ		;IT WORKED, COUNT THE SUCKER
TZ:	ILDB	B,PNEXTC	; GET ANOTHER
	SKIPGE	A,SCNTBL(B)	;COULD IT STILL BE A DIGIT?
	PUSHJ	P,(A)
	JRST	GETLUP-1(TBITS2);LOOP

TZMUL:	HLRZ	D,C		;# TRAILING ZEROES
	JUMPE	D,TZMUL1	;QUIT IF NONE
	CAIN	D,(C)
	 JRST	TZMUL1		;TRAILERS WERE ALSO LEADERS!
	PUSH	P,A
	MOVEI	A,"0"
	PUSHJ	P,M10ADA	;ADJUST VALUE TO ACCOUNT FOR TRAILING ZEROES
	TLNN	SBITS2,INTOV	;STOP IF OVERFLOW (BEFORE COUNTING)
	SOJG	D,.-2
	POP	P,A
	HRLI	C,(D)		;PUT BACK NUMBER UNDONE
	POPJ	P,
TZMUL1:	TLZ	C,-1		;NO TRAILING ZEROES NOW
	POPJ	P,

M10ADA:
	PUSH	P,SCNVAL
	PUSH	P,DBLVAL	;SAVE IN CASE WE ABORT
NOKL10<	SKIPN	LPSA,SCNVAL	;ANY HIGH ORDER PART?
	 JRST	M10A.1		;NO
	IMULI	LPSA,=10	;YES
	JOV	M10A.F		;WOOPS, ABORT
	MOVEM	LPSA,SCNVAL
M10A.1:	MOVE	LPSA,DBLVAL	;LOW HALF
	MULI	LPSA,=10
	TLO	LPSA+1,400000	;PREVENT OVERFLOW
	ADDI	LPSA+1,-"0"(A)	;ADD THE NEW DIGIT
	TLZN	LPSA+1,400000	;WOULD THERE HAVE BEEN AN OVERFLOW?
	 ADDI	LPSA,1		;YES. (THIS CAN'T OVERFLOW; LPSA WAS AT MOST =9)
	TLO	LPSA,400000
	ADD	LPSA,SCNVAL	;TAKE CARE OF HIGH HALF
	TLZN	LPSA,400000
	 JRST	M10A.F		;WOULD HAVE OVERFLOWED, ABORT
	MOVEM	LPSA,SCNVAL	;SAVE HIGH HALF
	MOVEM	LPSA+1,DBLVAL	;SAVE LOW HALF
>;NOKL10
KL10<
	DMOVE	LPSA,SCNVAL	;FETCH ONE VALUE
	DMOVEM	LPSA+2,SCNVAL	;SAVE 2 REGS CLOBBERED BY DMUL
	DMUL	LPSA,[0  =10]	;RESULT SHOULD BE IN LPSA+2,+3
;	JOV	M10A.F		;OH, WELL, GIVE IT UP
;	JUMPN	LPSA,M10A.F
	JUMPN	LPSA+1,M10A.F
	MOVEI	LPSA+1,-"0"(A)	;CONSTRUCT VALUE TO ADD. LPSA HAS 0 ALREADY
	DADD	LPSA,LPSA+2	;ADD
	JOV	M10A.F		;OH, WELL, GIVE IT UP
	DMOVE	LPSA+2,SCNVAL	;RESTORE 2 REGS
	DMOVEM	LPSA,SCNVAL
>;KL10
	SUB	P,X22
	POPJ	P,
M10A.F:	TLO	SBITS2,INTOV	;BUT IT MIGHT HAVE OVERFLOWED
KL10<	DMOVE	LPSA+2,SCNVAL  >
	POP	P,DBLVAL	;RECOVER OLD VALUE
	POP	P,SCNVAL
	POPJ	P,


	4		; 10^+1  Binary exponent
ten.p1:	240000,,000000	;	Fraction word 1
	000000,,000000	;	Fraction word 2
	-3		; 10^-1  Binary exponent
	314631,,463146	;	Fraction word 1
	146314,,631463	;	Fraction word 2
	7		; 10^+2  Binary exponent
	310000,,000000	;	Fraction word 1
	000000,,000000	;	Fraction word 2
	-6		; 10^-2  Binary exponent
	243656,,050753	;	Fraction word 1
	205075,,341217	;	Fraction word 2
	16		; 10^+4  Binary exponent
	234200,,000000	;	Fraction word 1
	000000,,000000	;	Fraction word 2
	-15		; 10^-4  Binary exponent
	321556,,135307	;	Fraction word 1
	020626,,245364	;	Fraction word 2
	33		; 10^+8  Binary exponent
	276570,,200000	;	Fraction word 1
	000000,,000000	;	Fraction word 2
	-32		; 10^-8  Binary exponent
	253630,,734214	;	Fraction word 1
	043034,,737477	;	Fraction word 2
	66		; 10^+16  Binary exponent
	216067,,446770	;	Fraction word 1
	040000,,000000	;	Fraction word 2
	-65		; 10^-16  Binary exponent
	346453,,122766	;	Fraction word 1
	042336,,053323	;	Fraction word 2
	153		; 10^+32  Binary exponent
	235613,,266501	;	Fraction word 1
	133413,,263574	;	Fraction word 2
	-152		; 10^-32  Binary exponent
	317542,,172552	;	Fraction word 1
	051631,,227231	;	Fraction word 2
;; the following will not fit the floating point format:
;	325		; 10^+64  Binary exponent
;	302360,,175117	;	Fraction word 1
;	376372,,332517	;	Fraction word 2
;	-324		; 10^-64  Binary exponent
;	250377,,650475	;	Fraction word 1
;	051636,,464517	;	Fraction word 2
bend	number

Comment $ LSTACK, GOAGAIN, CHAROUT, and STACK (all leave SCANNER)
$


Comment $ LSTACK -- Print the last character, then stack the result
$
LSTACK:	LSTDPB
	JRST	STACK


Comment $ GOAGAIN -- We have been backed up by the wonderful error
routines in the parser.  So we return things to their normal states:
$
GOAGAIN: MOVE	A,SAVPAR
	SKIPA	LPSA,SAVSEM


DSCR CHAROUT -- returns value for single char operator.
DES No Semantic stack entry is necessary (a null pointer
  is stacked). The indirect, address, and index fields
  of the character comprise its PL-ID. 


CHAROUT:
	MOVEI	LPSA,0		;SEMANTICS RETURNED ARE NULL


DSCR STACK  
DES All SCANNER sub-sections return here to place Parse
  token on parse stack (PPDL) and Semantics on EXEC stack
  (GPDL). STACK is bypassed only by the string constant
  scanner when calling SCANNER recursively to modify for-
  mal parameters.

STACK:	HRRZS	LPSA		;MAKE SURE ONLY RH
	TLZ	A,777740	;CLEAR SCANNER BITS
	PUSH	SP,A		;PL ENTRY
	EXCH	SP,GPSAV	;GET GP POINTER
	PUSH	SP,LPSA		;SEMANTIC ENTRY
	EXCH	SP,GPSAV	;PUT AWAY SEMANTIC POINTER
	MOVEM	SP,PPSAV	;PUT AWAY PARSE POINTER
	SKIPN	CNDLST		; IN FALSE PART OF COND. COMP.? 
	 POPJ	P,		; NO, RETURN 
	MOVE	SBITS2,LPTRSV	; YES, DO NOT LIST - I.E. RESTORE LPNT 
	ML$BAK
	POPJ	P,


DSCR INSET
DES prepare for ID or STRING constant scan
RES sets up TOPBYTE, REMCHR, PNAME, C (char count)
SID Uses TEMP

^^INSET:
;;#GI# DCS 2-5-72 REMOVE TOPSTR
ifn ftdebug, <
	pushj	p,cn.frb	;check out the string space situation
>;ifn ftdebug
	MOVSI	c,40		; MOST HARMLESS non-CONST BIT
;;#GI
	MOVEM	c,PNAME		;FIRST PNAME DESCRIPTOR WORD
	HLL	c,TOPBYTE(USER)	;ADJUST REMCHR FOR
	HRRI	c,[BYTE (7) 0,4,3,2,1,0] ;CHARACTERS SKIPPED
	ILDB	c,c
	ADDB	c,REMCHR(USER)	;UPDATE REMCHR
	jumpl	c,insetg	;and procede iff room left
	push	p,[=50]		;make sure we will have a bunch of
	pushj	p,strgc		;characters left after GC
	HLL	c,TOPBYTE(USER)	;ADJUST REMCHR FOR
	HRRI	c,[BYTE (7) 0,4,3,2,1,0] ;CHARACTERS SKIPPED
	ILDB	c,c
	ADDB	c,REMCHR(USER)	;UPDATE REMCHR
	jumpl	c,insetg	;and procede iff room left
	err <DRYROT: can't get enough string space>

insetg:
	SKIPL	c,TOPBYTE(USER)	;ADJUST TOPBYTE TO
	 ADDI	c,1		; WORD BDRY (440700 OK ALREADY)
	HRLI	c,440700	;[POINT 7,WORD]
	MOVEM	c,PNAME+1	;BP FOR THIS STRING
	MOVEM	c,TOPBYTE(USER)	;ADJUSTED TOPBYTE
	setz	c,		;and clear c to reflect count
		;NOW GC CAN GO AHEAD AND HAPPEN
ifn ftdebug, <
	jrst	cn.frb		;and go check out string space garbage
;else >	POPJ	P,		;return (we're ok)
SUBTTL	SCANNER I/O, MACRO EXPANSION


DSCR CSPEC, SEOL, SEOM, SEOB -- Special handling routines
PAR A contains address of appropriate routine.  Many SCANNER
  state variables are perused and changed.
RES PNEXTC, SAVCHR, and friends are set to proper values after
  more file has been read, macro has been returned from, etc.
DES Called by SCANNER routines when an input char is detected
  whose SCNTBL entry indicates special conditions.  The routine
  address is in the right half of this SCNTBL word.
 CSPEC is sometimes called to save the char count (C) before dis-
  patching to the special routine (for STRINGC integrity)
 SEOL is called when the SCANNER is reading from the input file
   or a macro and an end of of line condition is detected.  A
   new line is found and the PNEXTC pointer is reinitialized.
 EOM is called when the SCANNER is reading a DEFINE body, and end
   of text (177 char) is seen. If the character following the EOT
   is non-zero, it indicates the right actual parameter to expand
   here.  If it is 0, it signals end of macro. Old input values are
   restored, things like PNEXTC and SAVCHR.
 SEOB is called when a 0 is detected while scanning. This can mean
  two things -- a TECO-type file is being read, and a buffer has
  ended in the middle of a line, or the string scanner has called
  SCANNER recursively to pick up a possible formal param.  In either
  case the right thing happens.
SEE ADVBUF routine, which these call for for file input

ZERODATA (SCANNER INPUT/OUTPUT VARIABLES)
;LINNUM -- physical line number of this output line.  Used
;    to force page ejects and new sub-numbering when too
;    many have gone out since last logical page encountered
?LINNUM: 0

?LNCREF: 0	;IF ON, CREF INFO HAS GONE OUT FOR THIS LINE

COMMENT $
LPNT -- byte pointer used to deposit characters in output
    buffer (LSTBUF) -- SEOL code transfers this data, along
    with CREF data, to the output file buffers.  IDPB B,LPNT
    instructions are scattered throughout the SCANNER to build
    this output file
$
^^LPNT: 0

^^LSTBUF: 0	;ADDRESS OF LISTING BUFFER

;LSTCHR -- saved scan-ahead character -- sometimes slightly different
;   from SAVCHR -- used for error message (the arrow) output
^^LSTCHR: 0
flag$cs: 0	;called via cspec (do add$str before returning
ENDDATA

SUBTTL	Cspec, Seol

; CALL SPECIAL ROUTINE, BUT FIRST MAKE SURE CHARACTER COUNT IS
;  CORRECT IN "PNAME" (THE DESCRIPTOR FOR THE CURRENTLY DEVELOPING
;  IDENTIFIER OR STRING)

cspec:	cls$str			;make sure PNAME is safe for GC
	setom	flag$cs		;indicate string to be used again
	jrst	(a)		;and go do your stuff

IGLCHR:	err <EOF got all the way into the scanner!!>
	popj	p,
SEOL:	PUSH	P,C		;SAVE CHARACTER COUNT (OVER BY HDROV)
	TRNE	TBITS2,NOLIST	;ARE WE LISTING NOW?
	 JRST	 NOLST		; NO

ifn 0,<
;;JFR 12-11-76 causes Address check for device DSK on PASS1.SAI (PUB)
;; \UR#5\ BETTER LISTING FOR CONDITIONAL COMPILATION
	SKIPE	CNDLST			;SUPPRESSING LISTING?
	 JRST	[ MOVE SBITS2,LPTRSV
		  ML$BAK
		 JRST  NOLST ]
;; \UR#5\
>;ifn 0,

; TIME TO DO A LISTING

	MOVE	TBITS,LPNT	;PUT THE LINE FEED IN LIST BUFFER
LLL2:	IDPB	B,TBITS
	MOVEI	B,0		;ZERO REMAINING CHARS OF CURRENT WORD
	TLNE	TBITS,760000	;ALL DONE?
	 JRST	LLL2		;NO, PUT OUT ZERO
	MOVEM	TBITS,LPNT	;SAVE AGAIN FOR A WHILE

;IF CREFING WAS DONE ON THIS LINE, TERMINATE THE CREF STUFF
	SKIPN	LNCREF		;CREF GONE OUT?
	 JRST	 NOLNX		;NOPE
	SETZM	LNCREF		;RESET.
	MOVEI	TBITS,177	;DELETE
	PUSHJ	P,CHROUT
	MOVEI	TBITS,"A"	;AND AN A
	PUSHJ	P,CHROUT
NOLNX:

; IF PCNT OUTPUT DESIRED, DO THAT FIRST

	TLNN	TBITS2,PCOUT	;WANT TO PRINT PC?
	 JRST	 NOPC		; NO

	MOVE	TBITS,PCNT	;YET ANOTHER FRNP
	ADD	TBITS,LSTSTRT	;OFFSET BY USER-PROVIDED LOC
	MOVEI	B,CHROUT	;ROUTINE TO USE
	MOVEI	PNT2,6		;ALWAYS DO 6 CHARS
BAIL<
	SKIPN	BAILON
	 JRST	pcprtr		;NO BAIL
	HRRZ	TBITS,BCORDN	;IF DEBUGGER IN USE, PRINT COORDINATE INSTEAD
	PUSHJ	P,FRNPD		;IN DECIMAL
	JRST	pcprtr+1	;AND SKIP OVER PC PRINTER
pcprtr:
>;BAIL
	PUSHJ	P,[
^FRNP1:		SKIPA	TEMP,[10]
^FRNPD:		 MOVEI	TEMP,=10
FRNP3:		IDIV	TBITS,TEMP
		IORI	SBITS,"0"
		HRLM	SBITS,(P)
		SOJE	PNT2,FRNP2
		PUSHJ	P,FRNP3
FRNP2:		HLRZ	TBITS,(P)
		JRST	(B)		;CHARACTER TO OUTPUT
	]
	MOVE	SBITS,[POINT 7,[ASCII /   /]]
	PUSHJ	P,LL1+1		;SEE BELOW

; IF LINE NUMBER OUTPUT DESIRED, DO IT NEXT.

NOPC:	MOVE	SBITS,[POINT 7,ASCLIN] ;ASSUME WANT LINE NUMBER
	TLNE	TBITS2,LINESO		;IS IT THE CASE
	 PUSHJ	P,[LL1: PUSHJ P,CHROUT ;CHARACTER TO OUTPUT
		      ILDB  TBITS,SBITS ;NEXT CHAR
		      JUMPN TBITS,LL1
		      POPJ   P,]+1	;KLUDGE........

; NEXT LINE UP THE BP FOR SOME RAPID-FIRE STUFF

NOTENX <
NLNO:	MOVE	TBITS,LSTPNT	;LST OUTPUT  BYTE POINTER
	MOVE	SBITS,LSTCNT	;IF ALREADY LINED UP....
HARRY:	TLNN	TBITS,760000	;LINED UP WHEN PTR PART IS 01
	 JRST	LNDUP
	SOS	SBITS,LSTCNT	;DENOTE CHANGE
	IBP	TBITS		;MAINLY WANT TO ADJUST COUNT
	JRST	HARRY		;COULD PROBABLY DO CALCULATION

LNDUP:	MOVEM	TBITS,LSTPNT	;UPDATE
	IDIVI	SBITS,5		;#WORDS LEFT, NO REMAINDER GUARANTEED
	AOS	PNT2,LPNT	;WE GOT THIS FAR
	HRRZS	PNT2
	SUB	PNT2,LSTBUF	;HOW MANY WORDS?
	CAMGE	SBITS,PNT2	;IS THERE ROOM?
	 PUSHJ	 P,LSTDO	; NOW THERE IS
BAIL<
	ADDM	PNT2,BLSTFC	;WORD COUNT FOR LIST FILE
>;BAIL
	MOVNI	SBITS,5		;UPDATE CHAR COUNT
	IMUL	SBITS,PNT2
	ADDM	SBITS,LSTCNT
	EXCH	PNT2,LSTPNT	;AND LSTPNT
	ADDM	PNT2,LSTPNT	;PREV VERSION IN PNT2
	ADDI	PNT2,1
	HRL	PNT2,LSTBUF	;BLT WORD (LSTBUF,,OUTBUF)
	BLT	PNT2,@LSTPNT	;WRITE THE LINE!
>;NOTENX
TENX<
	PUSH	P,C
	PUSH	P,B
	HRRZ	2,LPNT
	HRRZ	3,LSTBUF
	SUBI	3,1(2)		;-#WRDS, INCLUDING CURRENT WORD
	IMULI	3,5		;-#CHRS, INCL. EXTRAS IN CURRENT WRD
	SKIPA	2,LPNT
	 IBP	2
	TLNE	2,760000	;LAST CHAR IN WORD COUNTED?
	 AOJA	3,.-2		;UN-COUNT AN EXTRA CHAR
BAIL<
	ADDM	3,BLSTFC	; UPDATE COUNT
>;BAIL
	EXCH	1,LISJFN
	HRRO	2,LSTBUF
	JSYS	SOUT
	EXCH	1,LISJFN
	HRRZ	3,LSTBUF	;NOW ZERO LSTBUF, JUST IN CASE.
	SETZM	(3)
	HRLI	3,(3)
	ADDI	3,1
	BLT	3,(2)
	POP	P,B
	POP	P,C
>;TENX
	HRRO	TEMP,LSTBUF	;ADDR OF FIRST WORD OF BUFFER
	SUB	TEMP,[XWD 677077,1] ;POINT 5,@LSTBUF,29
	MOVEM	TEMP,LPNT	;NEW LIST POINTER
IFN FTL$DBG,<
	MOVEI	TEMP,5*=50
	MOVEM	TEMP,L$CNT
>;IFN FTL$DBG
	MOVE	TEMP,[ASCID /     /] ;BLANKS IN CASE
	MOVEM	TEMP,ASCLIN	;IN MACRO AND MORE LINES TO COME
	AOS	TBITS,LINNUM	;CHECK LINE OVERFLOW
	IDIVI	TBITS,PGSIZ
	SKIPN	SBITS
	 PUSHJ	P,HDROV		;PRINT FF

;; and fall into NOLST

; ENOUGH OUTPUT, NOW FOR SOME INPUT

NOLST:
	SKIPE	SRCDLY		;SWITCHING SOURCE INPUT?
	 JRST	 NXTSRC		; YES

	MOVE	PNT,PNEXTC
	IBP	PNT
	MOVEM	PNT,PLINE	;UPDATE IF MACRO
	TLNE	TBITS2,MACIN	;DONE IF MACRO
	 JRST	 LDO1		;DONE

; MAKE A LINE NUMBER IN CASE FILE HAS NONE
	AOS	TBITS,BINLIN	;SEQUENTIAL WITHIN PAGE
;;%DM% CMU =F4= LDE 14-JUN-76	GENERATE MORE LIKELY SOS LINE NUMBERS.
NOSTAN <
	CAIG	TBITS,tymshr<=9999;>=999 ;HIGHEST LEGAL LINE NUMBER
	 IMULI	TBITS,tymshr<=10;>=100
>;NOSTAN =F4=
;;%DM% ^
	MOVEI	B,[IDPB TBITS,A ;ROUTINE TO DISPENSE CHARS
		   POPJ P,]
	MOVEI	PNT2,5		;5 CHARS ALWAYS
	MOVE	A,[POINT 7,ASCLIN] ;PUT IT HERE
	PUSHJ	P,FRNPD		;GET ASCII VERSION
	MOVEI	TEMP,1
	ORM	TEMP,ASCLIN	;MAKE ASCID
; ACTUAL LINE NUMBER WILL OVERRIDE THIS IF THERE

	LDB	TEMP,PNT	;NEXT CHAR.
	JUMPE	TEMP,NULCHR	;GO FIND NON-NULL
LINCHA:	MOVE	TEMP,(PNT)
LINCHK:	TRNN	TEMP,1		;ARE WE IN LINE NUMBER?
	JRST LDUNA		;NO THIS IS THE NEXT CHAR.
BAIL<	;JFR 4-18-76 AT COMPLAINT OF REM
	PUSH	P,TEMP
	SKIPN	BPNXTC		;IF SOURCE NOT MARKED
	 PUSHJ 	P,BMKSRC	;THEN MARK IT BEGINNING AT LINE NUMBER
	POP	P,TEMP
>;BAIL
	CAME	TEMP,[ASCID/     /];IS IT A PAGE MARK PERHAPS
	 AOJA	PNT,LDUN	;NO JUST SKIP LINE NUM AND TAB
	MOVEM	PNT,PNEXTC	;HDR CLOBBERS THIS
	PUSHJ	P,HDR		;WRITE PAGE MARK, NEW TITLE LINE
	MOVE	PNT,PNEXTC	;GET HIM BACK
	SKIPN	1(PNT)		;END OF BUFFER?
	 PUSHJ	P,ADVBUF	;YES, GET NEXT.
	ADDI	PNT,1		;POINT BEHIND NEXT LINE NUMBER
	SKIPN	TEMP,1(PNT)	;IS IT IN THIS BUFFER?
	 PUSHJ	P,ADVBUF	;NO.
	HRLI	PNT,350700	;POINT TO FIRST CHAR. OF LINE NUMBER
	AOJA	PNT,LINCHA	;AND DO IT AGAIN (IN CASE 2 PAGE MARKS)

NULCHR:	ILDB	B,PNT		;MOVE ON UP
	MOVE	TEMP,(PNT)	;GET COMPLETE WORD
	JUMPN	B,LINCHK	;FINALLY WE GOT SOMETHING
	IBP	PNEXTC		;KEEP IN STEP
	JUMPN	TEMP,NULCHR	;END OF BUFFER?
	PUSHJ	P,ADVBUF	;YES.
	JRST	NULCHR		;HERE WE GO LOOP-D-LOOP

LDUN:	SKIPE	(PNT)		;IS TAB IN THIS BUFFER
	 JRST	LDUN1		;YES
	PUSHJ	P,ADVBUF	;NO
	IBP	PNT		;MAKE IT CURRENT
LDUN1:	MOVEM	TEMP,ASCLIN	;CURRENT LINE#
	MOVEM	PNT,PNEXTC	;THIS GUY POINTS TO TAB
LDUNA:	MOVE	TEMP,PNEXTC	;MAY NOT USE PNT
	MOVEM	TEMP,PLINE	;BEGINNING OF LINE
IFN FTDEBUG,<
	AOS	LINCNT		;COUNT NUMBER OF LINES SEEN
	SKIPL	STPAGE		;ARE WE LOOKING FOR A PAGE/LINE?
	 PUSHJ	P,STPLIN	;LINE BREAK IF NECESSARY.
>;IFN FTDEBUG
LDO1:	MOVEI	B,12		;GET LINE FEED BACK.
	MOVEI	A,0		;HARMLESS LF
	MOVE	USER,GOGTAB
	POP	P,C		;RESTORE CHARACTER COUNT.
goback:	skipn	flag$c		;was this called via cspec
	 popj	p,		;no, just return
	setzm	flag$c
	add$str			;rebuild C from PNAME...
	popj	p,


; HERE WE SAVE INFO ABOUT SOURCE FILE, AND PREPARE TO GET INFO
; ABOUT NEW ONE.


NXTSRC:
NOTENX <
	MOVE	A,AVLSRC		;BITS TELLING FREE CHANNELS
	JFFO	A,GOTNEW		;FOUND A FREE ONE
	 ERR	 <NO MORE AVAILABLE SOURCE CHANNELS>
GOTNEW:
	PUSH	P,B			;SAVE NEW CHANNEL #
	MOVEI	C,ENDSRC-SRCCDB+1	;SIZE OF SAVE AREA
>;NOTENX
TENX <
	MOVEI 	C,ENDSRC-BGNSWA+1	;SIZE OF SAVE AREA
>;TENX
	PUSHJ	P,CORGET		;GET ONE
	 ERR	 <NO CORE AVAILABLE FOR FILE SWITCH>
	HRR	TEMP,B			;BLT WORD
NOTENX <
	HRLI	TEMP,SRCCDB
	BLT	TEMP,ENDSRC-SRCCDB(B)
>;NOTENX
TENX <
	HRLI	TEMP,BGNSWA
	BLT	TEMP,ENDSRC-BGNSWA(B)
>;TENX
	HRRZM	B,SWTLNK		;SAVE PTR TO SAVE AREA
	TLO	TBITS2,INSWT		;WE'RE SCANNING SWITCHED-TO FILE
	MOVEM	TBITS2,SCNWRD
	SETZM	LSTCHR			;ALWAYS DO IT
	SETZM	SAVCHR
NOTENX <
	SETZM	SAVTYI
	SETZM	EOF
	SETZM	EOL
	POP	P,A			;CHANNEL NUMBER
FOR II_0,1 <
	DPB	A,[POINT 4,SRCOP+II,12]
>
FOR II_0,3 <
	DPB	A,[POINT 4,INSRC+II,12]
>
STANFO <
	DPB	A,[POINT 4,SRCOP+2,12]	;PUSHJ IF EXPORT
>;STANFO
	MOVN	TEMP,A			;-CHANNEL NUMBER
	MOVSI	LPSA,400000		;BIT
	LSH	LPSA,(TEMP)
	ANDCAM	LPSA,AVLSRC		;THIS CHANNEL UNAVAILABLE
>;NOTENX
;;%CF% JFR 7-8-75
IFN 0,<
	AOS	TEMP,LININD		;HOW FAR IN TO SPACE ON TTY
	CAILE	TEMP,MAXIND		;TOO FAR?
	 SOS	LININD			;NOT REALLY
>;IFN 0
	MOVEI	TEMP,2		;INDENT ON TTY
	ADDM	TEMP,LININD
;;%CF% ^
NOTENX <
	SETOM	TYICORE			;WILL SCAN FROM STRING
>;NOTENX
	MOVE	TEMP,GENLEF+2
;; %AN% CHECK TO BE SURE STRING CONSTANT, SINCE PRODUCTIONS NO LONGER CHECK
	MOVE	TEMP,$TBITS(TEMP)
	TRNN	TEMP,STRING	
	 ERR	<SOURCE!FILE NAME MUST BE STRING>
	MOVE	TEMP,GENLEF+2
;; %AN%
	HRROI	TEMP,$PNAME+1(TEMP)	;GET STRING TO BE SCANNED
	POP	TEMP,PNAME+1
	POP	TEMP,PNAME		;PUT ER THERE
BAIL<
	SKIPN	SRCDLY			;SWITCHING SOURCE INPUT?
	 JRST	BNSRCD			;NO
	QPUSH	BSRCFQ,BSRCFC		;YES. SAVE BUFF. ADDR,,BLOCK COUNT
	QPUSH	BSRCFQ,BSRCFN		;SAVE FILE NUMBER
;;#%%# ! BY JFR 11-17-74  ZERO THE BLOCK COUNT FOR THE NEW FILE
	SETZM	BSRCFC
BNSRCD:
>;BAIL
	PUSHJ	P,ENDSWT		;USE EOF CODE TO GET NEW FILE
					;SRCDLY WILL BE TURNED OFF HERE
	JRST	NOLST			;AND GO BACK TO END OF LINE CODE


; END OF BUFFER CODE.

SEOB:	TLNE	TBITS2,LOKPRM	;END OF POSSIBLE MACRO PARAM SCAN?
	 POPJ	P,		;YES, IGNORE THE WHOLE THING
	MOVE	PNT,PNEXTC	;CURRENT BP
	JUMPE	PNT,ADVIT	;INITIALIZATION TIME
	SKIPE	TEMP,(PNT)	;REAL END OF BUFFER?
	 JRST	 SEOBAK		; NO, WILL COME BACK UNTIL NOT NULL
ADVIT:	
;; #PF# PUT CORRECT # OF THINGS ON STACK IN CASE ADVBUF DOESN'T RETURN
	PUSH	P,C
	PUSHJ	P,ADVBUF
	POP	P,C
;; #PF#
	TRNN	TEMP,1		;LINE NUMBER? (INIT SCAN FOR SOS FILES)
	 JRST	 SEOBAK		;NO, FIND NEXT CHAR
	MOVEM	TEMP,ASCLIN	;SAVE LINE NUMBER
	IBP	PNT		;OVER TAB
	ADDI	PNT,1		;BACK IN BUSINESS
SEOBAK:	MOVEM	PNT,PLINE	;BEGINNING OF LINE
	ILDB	B,PNT		;GET CHAR
	MOVEM	PNT,PNEXTC	;UPDATE
	SKIPGE	A,SCNTBL(B)	;SPECIAL?
	 JRST	(A)		;YES, HANDLE
	jrst	goback		;NO, DONE

; END OF PAGE (TECO FILES ONLY)

SEOP:	PUSHJ	P,HDR		;PRINT FF, TITLE LINE
;; #PC#! OVERWRITING FIRST LINE OF CREF 
	setzb	b,a		;pretend a null character, bits for CR 
	jrst	goback		;return

Comment $ Parameter delimiter or end of message $

EOM:
;;WAS IN debug
;;	tlnn	tbits2,macin	;if end-of-macro or macro parameter
;;	 err <macro codes while not in macro?>;then better be in macro
;; ^^ debug
	ILDB	B,PNEXTC	;CHECK WHICH
	SKIPN	ASGFLG		;ASSIGNC PARAMETER NUMBER? 
	 JRST	CONEOM		;NO, 
	jumpe	b,asgc.e	;better not hit EOM now (I think)
	setz	a,		;make A break loop, he'll be waiting
	exch	a,asgflg	;and turn this off (it's dangerous)
	jrst	goback		;and return (no more input, please)
				;the caller will notice asgflg _ 0
asgc.e:	 err	<DRYROT: EOM --ASSIGNC parameter 0>

CONEOM:	JUMPE	B,RESTOR	;ZERO, END OF MACRO (OR PARAM) TEXT
; PARAMETER NEEDED

	SETZM	SAVCHR
	SETZM	LSTCHR
	hrrz	LPSA,DEFRNG
GETIT:	SOJLE	B,GOTIT		;LOOK FOR PARAMETER WITH PROPER NUMBER
	RIGHT	,%RVARB,,
	JUMPN	LPSA,GETIT	;KEEP LOOKING
	ERR <NOT ENOUGH ARGUMENTS SUPPLIED TO MACRO>,1
	hrrz	lpsa,defrng	;try to get something to work
				;by using the first parameter
	jumpn	lpsa,gotit	;was there at least one parameter?
	err <NO ARGUMENTS SUPPLIED TO MACRO AT ALL(?)>

GOTIT:	MOVE	PNT,DEFPDP	;NOW SAVE STATE OF SCANNER AND RECUR
	PUSH	PNT,DEFRNG	;SAVE DEFRNG WHICH has the text of the
	PUSH	PNT,PNEXTC-1	;ACTUAL PARAMETER TO BE  EXPANDED.
	PUSH	PNT,PNEXTC	;INPUT POINTER
	PUSH	PNT,SAVCHR	;SCANNED AHEAD
	MOVEM	PNT,DEFPDP	;SAVE POINTER
	HLLZ	TEMP,$PNAME(LPSA) ;now make the parameter body
	addi	temp,1		;kluge to keep string updated at GC
	MOVEM	TEMP,PNEXTC-1
	MOVEM	TEMP,PLINE-1
	MOVE	temp,$PNAME+1(LPSA)	;the NEW INPUT POINTER
	movem	temp,PNEXTC
	MOVEM	TEMP,PLINE
;;#YV# JFR 2-4-77
	TLNN	TBITS2,LSTEXP	;WANT to list macro expansion delims?
	 JRST	DFNE.1		;SURELY NOT
	MOVEI	B,"<"		;MARKER FOR MACRO EXP
	LSTDPB			;MAYBE
DFNE.1:	TLO	TBITS2,MACIN	;MARK IN MACRO
	TLNN	TBITS2,MACEXP	;EXPANDING?
	 TRO	TBITS2,NOLIST	;NO
;;#YV# ^
	MOVEM	TBITS2,SCNWRD	;UPDATE
	setom	srcprm		;indicate scanning macro parameter
				;(checked when reading actual: scnpmr)
	jrst	newchr

RESTOR:	MOVE	PNT,DEFPDP
	POP	PNT,SAVCHR	;CHAR SCANNED AHEAD
	POP	PNT,PNEXTC	;OLD INPUT POINTER
	POP	PNT,PNEXTC-1	;STRING NUMBER
	ADD	PNT,X22			;START PLINE HERE
	POP	PNT,PLINE
	POP	PNT,PLINE-1
	POP	PNT,LPSA	;PERHAPS OLD DEFRNG
	MOVEM	PNT,DEFPDP
	setzm	srcprm		;clear "in parameter" flag
				;(checked when reading actual: scnpmr)
;;is the following a nasty kluge???
	CAMN	LPSA,DEFRNG	;if old and current DEFRNG values same,
	 JRST	DDUN		;then just finished a parameter insert
	EXCH	LPSA,DEFRNG	;otherwise have finised macro, restore
	HRRZS	LPSA		;old DEFRNG value, and drop params ring
	PUSHJ	P,KILLST	;note KILLST EXPECTS lh LPSA = 0

DDUN:
;;#YV# JFR 2-4-77
	TLNN	TBITS2,LSTEXP
	 JRST	DDUN.1
	MOVEI	B,">"		;END OF EXPANSION MARKER
	LSTDPB
DDUN.1:
	SKIPE	PNEXTC-1	;OUT OF MACROS?
	 JRST	DUNRST		;NO
	TLZ	TBITS2,MACIN	;YES
	PUSHJ	P,L$SET		;GET 'NOLIST' FROM ABSOLUTE BEARINGS
;;#YV# ^
	MOVE	TEMP,IPLINE	;PLINE TO OUTER LEVEL VALUE
	MOVEM	TEMP,PLINE
	SETZM	PLINE-1

DUNRST:	MOVEM	TBITS2,SCNWRD	;SAFETY FIRST

; NOW GET A CHARACTER FOR THE SCANNER
	SKIPN	B,SAVCHR	;HAVE IT ALREADY?
	 JRST	NEWCHR		;NO
	SETZM	SAVCHR		;NO LONGER AHEAD (DCS 5-27-71)******
	MOVE	A,SCNTBL(B)	;YES, DON'T DISPATCH AGAIN
	jrst	goback

NEWCHR:	ILDB	B,PNEXTC	;GET FROM INPUT
	SKIPGE	A,SCNTBL(B)	;SPECIAL?
	JRST	(A)		;YES, DISPATCH
	jrst	goback		;NO, DONE

SUBTTL	SCANNER INPUT AND LISTING ROUTINES

DSCR ADVBUF -- new input buffer routine
DES Reads a new input buffer, gets a new source file
  if this one is exhausted or if file switching is
  happening (prints loser message if no files remain),
  and assures that the buffer ends in zero for EOB
  detection by SEOL. The buffers were made long enough
  to allow the inclusion of an extra word of zero.
SID Saves USER, C -- reinits A,B -- all others vulnerable
SEE SEOL, SEOB, routines which detect EOB and call ADVBUF.

ADVBUF:	
NOTENX <
	XCT	INSRC		;ADVANCE BUFFER
	XCT	TSTSRC		;ANY ERRORS?
	 ERR	 <I-O ERROR ON SOURCE DEVICE>,1
	XCT	EOFSRC		;TO ENDFL ON EOF
	JRST	ENDFL
BAIL <
	AOS	BSRCFC		; ADD ONE TO SOURCE FILE BLOCK COUNT
>;BAIL
	PUSHJ	P,SGCHK		;STRING GC, IF NECESSARY, TBITS_SRCCNT
	ADDI	TBITS,4		;(CHAR CT+4)/5 IS WORD COUNT
	IDIVI	TBITS,5
	ADD	TBITS,SRCPNT	;ADD BASE ADDRESS
	IBP	TBITS		;PTR TO LAST WORD+1, MAKE 0 TO
	SETZM	(TBITS)		; DENOTE EOB
	MOVE	PNT,SRCPNT	;RESET PNT TO CURRENT BP,
	MOVEM	PNT,PNEXTC	;FIX THIS GUY TOO.
	MOVE	TEMP,1(PNT)	; TEMP TO WORD NEXT REFERENCED
	POPJ	P,
>;NOTENX
TENX <
	PUSH	P,1
	PUSH	P,2
	PUSH	P,3
	SKIPE	TTYSRC		;CONTROLLING TERMINAL SOURCE DEVICE?
	  JRST	ADVTTY		;YES
	SKIPN	TNXBND		;ANYTHING IN THE BUFFER?
	  JRST	ADVBF1		;NO DONT CHECK
	HRRZ	1,PNEXTC 	;LOOK AT ADDR
ADVBF2:	CAML	1,TNXBND	;BEYOND BUFFER?
	  JRST	ADVBF1		;YES, CHECK EOF, GET MORE IF THERE
	SKIPN	1(1)		;0 WORD?
	  AOJA	1,ADVBF2	;YES KEEP LOOKING FOR INFO IN THE BUFFER
	HRLI	1,010700
	PUSH	P,1		;SAVE NEW BP
	PUSHJ	P,SGCHK		;CHECK GARBAGE COLLECTION
	POP	P,PNT		;BP TO PNT
	POP	P,3		;RESTORE
	POP	P,2
	POP	P,1
	MOVEM	PNT,PNEXTC
	MOVE	TEMP,1(PNT)	;WHICH IS NON-ZERO BECAUSE WE JUST CHECKED
	POPJ	P,

ADVBF1:	HRRZ	1,SRCJFN
	JSYS	GTSTS
	TLNE	2,1000		;EOF?
	 JRST	ENDFL		;YES
BAIL <
	AOS	BSRCFC		;ADD ONE TO SOURCE FILE BLOCK COUNT
>;BAIL
	HRR	2,SRCPNT
	ADDI	2,1		;SRCPNT IS A 7-BIT POINTER THAT IS A WORD EARLY
	HRLI	2,444400	;36-BIT POINTER.
	MOVNI	3,SRCBSZ	;SIZE OF SRC BUF IN WRDS, MINUS EOB NULL
	JSYS	SIN		;SRCJFN OPEN FOR 36BIT INPUT
	HRRZM	2,TNXBND	;SAVE END OF BUFFER ADDRESS FOR CHECKS ABOVE
	SETZM	1(2)		;EOB NULL.
ADVDUN:	PUSHJ	P,SGCHK
	POP	P,3
	POP	P,2
	POP	P,1
	MOVE	PNT,SRCPNT	;RESET PNT TO CURRENT BP,
	MOVEM	PNT,PNEXTC	;FIX THIS GUY TOO.
	MOVE	TEMP,1(PNT)	;GET THE FIRST WORD IN TEMP
	POPJ	P,

DSCR ADVTTY
	Since the boys at BBN have seen fit to not provide a standard
line editor into their system, we must resort to using some runtimes
to handle input in the case that the source is a TTY.  We confine the
problem to the case that the source is the controlling teletype, as
indicated by the SRCTTY (set in CC), and use INTTY.  INTTY at IMSSS
uses the IMSSS PSTIN jsys, otherwise a simulation of same.
;

ADVTTY:
EXTERNAL .SKIP.
EXTERNAL INTTY
	EXCH	SP,STPSAV
	PUSHJ	P,INTTY		;GET A STRING USING THE PSTIN JSYS
	POP	SP,A		;BYTE POINTER
	POP	SP,C		;XWD -1, LENGTH -- STACKS ARE NOW OK
	EXCH	SP,STPSAV
	MOVE	B,.SKIP.
	CAIN	B,32		;CONTROL-Z TO INDIATE EOF
	  JRST	ENDFL		;YES END OF FILE
	MOVE	B,SRCPNT
	HRRZ	C,C	
	MOVNS	C		;NUMBER OF CHARS TO TRANSFER
	JSYS	SIN		;USE SIN TO TRANSFER STRING
	MOVEI	C,15
	IDPB	C,B
	MOVEI	C,12
	IDPB	C,B
	SETZ	C,
	REPEAT 5, <IDPB	C,B>	;PUT NULLS THERE
	SETZM	(B)		;BE SURE TO INDICATE EOF
	SETZM	1(B)		
	JRST	ADVDUN		;AND FINISH UP, ABOVE
>;TENX

; CHECK FOR STRING SPACE FULL, GC IF SO

SGCHK:
notenx < HRRZ	TBITS,SRCCNT >;notenx	;;GET # OF CHARACTERS
tenx <	MOVEI	TBITS,SRCBSZ*5 >;tenx	;;TENEX BUFFER SIZE
	MOVE	TEMP,REMCHR(USER)	;REMAINING CHARS
	ADD 	TEMP,TBITS
	jumpge	temp,sgcol	;NO, COLLECT SPACE
	POPJ	P,		;NOW THERE IS

ENDFL:
notenx <
	XCT	RELSRC		;RELEASE OLD FILE,
>;notenx
TENX <
	HRRZ	A,SRCJFN
	JSYS	CLOSF
	  JFCL
	HRRZ	A,SRCJFN
	JSYS	RLJFN
	  JFCL
	POP	P,3
	POP	P,2
	POP	P,1
>;TENX



ENDSWT:	MOVEM	TBITS2,SCNWRD	;UPDATE IN CORE VERSION
	PUSHJ	P,FILEIN	;FIND AND INIT NEW ONE
	JRST	[TLNN	TBITS2,EOFOK
;;%CI% ! (4/5)
		 JRST	ENDSW1
		 MOVNI	B,1	;MARK END OF FILE NEXT TIME
		 MOVEI	A,1	;HARMLESS, BUT BREAKS IGNORABLE
;;***** horrors ***** a nasty non- return *****
		 SUB	P,X11	;RETURN EARLY
		 POP	P,C	;CHAR COUNT BACK
		 jrst	goback]
ENDSW3:
;;%DE% ! JFR 10-25-75	PUSHJ	P,MAKT		;PREPARE NEW TITLE LINE
	SKIPE	SRCDLY		;COMING BACK FROM SWTCHED-TO FILE?
	 JRST	 SWTBKP		; YES, DO MORE BOOKKEEPING
	SETZM	FPAGNO		;FIRST PAGE IN NEW FILE
	PUSHJ	P,HDR		; , DENOTE IT
	JRST	ADVBUF		; OR PRINT LOSING MESSAGE, TRY AGAIN


^^XTCONT:MOVSI	16,INIACS	;RESTORE
	BLT	16,16
	JRST	ENDSW3

;;%CI% (5/5) JFR 7-18-75
ENDSW1:
	MOVEI	TEMP,LININD+1	;MAKE SURE TRKMCS AND TRKMCR POINT A LEGIT STRING
	SKIPN	TRKMCS
	 MOVEM	TEMP,TRKMCS
	SKIPN	TRKMCR
	 MOVEM	TEMP,TRKMCR
	MOVEI	TEMP,0		;ASSUME FILE JUST RAN OUT
	TLNE	FF,PRMSCN	;SCANNING MACRO ACTUALS?
	 MOVEI	TEMP,[ASCIZ/macro parameters/]
	SKIPE	CNDLST
	 MOVEI	TEMP,[ASCIZ/false conditional compilation/]
	JUMPN	TEMP,.+4	;IF ALREADY SOME BAD REASON
	SKIPE	XTFLAG		;ELSE TEST FOR EXTENDED COMPILATION
	 JRST	XTCOMP
	MOVEI	TEMP,[ASCIZ/file/]
	HRLI	TEMP,(<POINT 7,0>)	;MAKE BYTE POINTER
;;%DH%
	MOVE	SBITS,TRKBEG	;SECOND SEMBLK OF CURRENT BEGIN
	HLRZ	TBITS,(SBITS)	;FIRST SEMBLK OF BEGIN
	ERRSPL	[[ASCIZ\
Fatal end of source file, scanning @A.
BEGIN @I  @E/@D
Last source-file macro: @I  @E/@D
Current macro: @I
\]
		PWORD	TEMP		;MORE EXPLICIT REASON
		PWORD	$PNAME+1(TBITS)	;BLOCK NAME
		PWORD	$PNAME+1(SBITS)	;LINE #
		PWORD	$PNAME(SBITS)	;PAGE #
		PWORD	@TRKMCS		;MACRO NAME
		PWORD	TRKM.L		;LINE #
		PWORD	TRKM.P		;PAGE #
		PWORD	@TRKMCR]	;MACRO NAME
	JRST	ENDSW3


XTCOMP:
NOTENX<
;;%DL% JFR 4-30-76 prevent enclobberment if /X and /B
IFN 0,<	;some problems remain
	SKIPE	BAILON
	SKIPN	XTFLAG
	 JRST	XTC.NR		;MISSING ONE OR BOTH OF /X, /B
	MOVE	TEMP,SM1FIL
	MOVEM	TEMP,NAME
	MOVSI	TEMP,'SM0'	;NEW EXTENSION
	MOVEM	TEMP,EXTEN
	MOVEM	TEMP,SM1EXT
	SETZM	WORD3
	MOVE	TEMP,SM1PPN
	MOVEM	TEMP,PPN
	RENAME	SM1,NAME
	 ERR	<RENAME error .SM1>,1
XTC.NR:
>;IFN 0,
;;%DL% ^
	PUSH	P,SM1DEV	;SAVE NAME OF .SM1 FILE
	PUSH	P,SM1FIL
	PUSH	P,SM1EXT
	PUSH	P,SM1PPN
	PUSH	P,BINDEV	;AND .REL FILE
	PUSH	P,BINFIL
	PUSH	P,BINEXT
	PUSH	P,BINPPN
>;NOTENX
	MOVEI	TEMP,INIACS	;SAVE OUR ACS HERE
	BLT	TEMP,INIACS+17
TENX<
	HRROI	1,XTSFIL
	SETZ	3,
	SKIPN	2,SM1JFN
	 JRST	.+2
	JSYS	JFNS
	HRROI	1,XTBFIL
	SETZ	3,
	SKIPN	2,BINJFN
	 JRST	.+2
	JSYS	JFNS
>;TENX
	HRLZS	XTFLAG		;WHEN WE START AGAIN, WE ARE XTENDED!!!!!
	HRROS	JOBHRL		;GET RID OF SECOND SEGMENT??
	HRRZ	TEMP,JOBREL	;HIGHEST LEGAL ADDR IN LOW SEG
	MOVSI	TEMP,1(TEMP)	;FIRST FREE LOC,,0
	HRRI	TEMP,XSTART	;NEW START ADDR
	MOVEM	TEMP,JOBSA	;NOW .SAVE HAD BETTER DO THE RIGHT THING
	PUUO	3,[ASCIZ/
SAVE ME FOR USE AS XSAIL./]
	JRST	RELSE

; WE HAVE OLD SOURCE FILE BACK, FAKE ADVBUF
SWTBKP:
BAIL <
	QPOP	BSRCFQ,BSRCFN	;RETRIEVE PREVIOUS FILE NUMBER
	QPOP	BSRCFQ,BSRCFC	;RETRIEVE BUFF.ADDR,,BLOCK COUNT
>;BAIL
	PUSHJ	P,HDROV		;CONTINUE PAGE NUMBERING FOR FILE
	SETZM	SRCDLY
	PUSHJ	P,SGCHK		;CHECK (LIBERALLY) FOR STRING SPACE FULL
	MOVE	TEMP,PNEXTC	;NOW SET UP PNT, PNEXTC, AND TEMP AS
SWTLUP:	SKIPN	(TEMP)		; THEY WOULD BE COMING OUT OF ADVBUF
	 JRST	 ADVBUF		;WE WERE AT END OF BUFFER ANYWAY
	MOVE	PNT,TEMP	;WE'RE GOING TO GET AHEAD OF SELVES
	ILDB	TBITS,TEMP	;CHECK NULLS
	JUMPE	TBITS,SWTLUP	;ALL THIS UNECESSARY IF SOS FILES, BUT...
	MOVEM	PNT,PNEXTC	;FAKE ADVBUF
	MOVE	TEMP,(TEMP)	;WORD WITH NON-NULL CHAR
	POPJ	P,
;;%CI% ^


BAIL <
^^UPDCNT:
>;BAIL
NOBAIL<
UPDCNT:
>;NOBAIL
	HRRM	C,PNAME			;UPDATE PNAME
	ADDB	C,REMCHR(USER)		;AND REMCHR
	CAMGE	C,[-=50]		;ARE WE NEARING CATASTROPHE?
	 POPJ	 P,			; NO
;EVEN THIS CANNOT PREVENT OCCASIONAL DEATH
	MOVEI	TBITS,=50		;REQUIRE AT LEAST THIS MANY
	JRST	SGCOL			;GO COLLECT

SGCOL1:	HRRZ	TBITS,$PNAME(LPSA)	;CHAR COUNT
SGCOL2:	MOVE	USER,GOGTAB
	MOVE	TEMP,REMCHR(USER)		;REMAINING CHARS
	ADD	TEMP,TBITS
	SKIPGE	TEMP				;NOT ENOUGH?
	 POPJ	 P,				;NO, OK

SGCOL:	EXCH	SP,STPSAV	;GET STRING STACK
	MOVSS	POVTAB+6	;calling seq. to .SONTP may oflow
	PUSH	P,TBITS		;PASS TO STRGC THIS WAY
	PUSHJ	P,STRGC	;COLLECT STRING SPACE
;;#QO# -- BE SURE PNAME STAYS TOGETHER 1-25-74 RHT
	EXTERN 	.SONTP
	PUSH	SP,PNAME
	PUSH	SP,PNAME+1
	PUSH	P,[0]
	PUSHJ	P,.SONTP
	POP	SP,PNAME+1
	POP	SP,PNAME
;;#QO#
	EXCH	SP,STPSAV	;GET IT BACK
	MOVSS	POVTAB+6
	POPJ	P,		; NO, GO AHEAD
NOTENX <

?CHROUT: SOSG	LSTCNT		;ONE CHAR OUTPUT ROUTINE
	PUSHJ	P,LSTDO		;DO AN OUTPUT
	IDPB	TBITS,LSTPNT	;DO THE OUTPUT
	POPJ	P,

?LSTDO:	OUT	LST,
	POPJ	P,
	ERR	<I-O ERROR ON LISTING DEVICE>,1
	POPJ	P,
>;NOTENX
TENX <
?CHROUT: EXCH	TBITS,2
	EXCH	1,LISJFN
	JSYS	BOUT
	EXCH	1,LISJFN
	EXCH	TBITS,2
	POPJ	P,
>;TENX


DSCR --HERE IS THE CREFFINF STUFF (STRANGE PLACE N'EST CE PAS?)
DES We'll leave it at these comments for the nonce:
 For those of you who are interested in what cref output looks like,
 allow me to discourse for a while on it.  Basically, the output line
 is preceeded by a whole mess of garbage. (In the following discussion,
 let # stand for delete -- octal 177).

1. The first thing in a line with cref information in it must be
	#B    .  This is handled in crefout.

2. There are two types of symbols:
	a. NUMSYM's, which are represented by a 6-digit number(decimal)
		which is unique to that occurrance of the symbol.
		The number is represented by octal 6 (length of symbol)
		followed by the number in ASCII.
	b. SYMSYM's, which are the real symbolic symbols. These consist
		of one byte of length, followed by the symbol in ASCII

3. When an identifier is seen in the source text, you do one of
	several things:
	1  followed by the NUMSYM -- a regular identifer seen.
	3  followed by the SYMSYM -- a reserved word.
	5  followed by the NUMSYM -- a macro use.
  -- it is occasionally necessary to flush the last type 1 instance.
	  This is done by following it immediately with a 7. --

4. When defining things, we put out:
	1 followed by the NUMSYM followed by 2 -- ordinary identifier
	6 followed by NUMSYM -- macro.

5. When beginning a block, we put out a 15 followed by the SYMSYM.
6. When ending a block, we put out a 16 followed by the SYMSYM.
	Then come the equivalences of numbers and symbolic names.
7. To equivalence an ordinary symbol, we put out 11 followed by
	the NUMSYM followed by the SYMSYM.

8. When all done with the cref information for a line, we put out
	#A    .


BEGIN CREF

^LCREFIT: 
	TDZA	C,C
^ECREFIT: MOVNI C,1		;CREF FOR ENTER.
	SKIPE	CNDLST		; IN FALSE PART OF CONDITIONAL COMPILATION? 
	 POPJ	P,		; YES, DO NOT CREF 
	TLNN	TBITS,CNST	;IF A CONSTANT, FORGET IT.
	 TLNE	FF,NOCRFW	;AN EXTERNAL PROCEDURE -- DO NOT CREF;
	  POPJ	P,
	MOVE	A,X11		;ORDINARY IDENTIFIER.
	TLNE	TBITS,DEFINE	;IF THIS IS A MACRO.
	 MOVE	A,[XWD 6,5]
	TLNE	TBITS,400000	;RESERVED WORD?
	 MOVE	A,X33
	TLNE	C,-1		;ENTER OR LOOKUP?
	 MOVSS	A
	PUSHJ	P,CREFOUT	;AND PUT OUT THE CHARACTER.
	PUSHJ	P,CREFSYM	;CREF THE SYMBOL IN LPSA,TBITS.
	TLNN	A,-2		;IF REGULAR SYMBOL,
	 SKIPL	C		;BEING DEFINED,
	  POPJ	P,
	MOVEI	A,2		;THEN PUT OUT EXTRA THING.
	JRST	CREFOUT		;....


CREFSYM: PUSH	P,TBITS
	JUMPL	TBITS,ASC1	;A RESERVED WORD ----
	MOVEI	TBITS,6
	PUSHJ	P,CHROUT	;NUMBER OF CHARACTERS.
	MOVEI	TBITS,(LPSA)
	MOVEI	PNT2,6		;FOR THE RECURSIVE NUMBER PRINTER IN SEOL.
;;#MF#! 5-1-73 DCS (1 OF 2) AC B NEEDED IN CALLER OF LCREFIT
	PUSH	P,B
	MOVEI	B,CHROUT	;OUTPUT ROUTINE FOR SAME --
	PUSHJ	P,FRNP1		;  FRNP1 IS IN SEOL ABOVE.
;;#MF#! (2 OF 2) SAVE, RESTORE B
	POP	P,B
	POP	P,TBITS
	POPJ	P,		;GO AWAY.
ASC1:	PUSH	P,A
	PUSHJ	P,CREFASC	;ASCII CREF.....
	POP	P,A
	POP	P,TBITS
	POPJ	P,


CREFCHR: CAIN	A,30		;UNDERLINE
	MOVEI	A,"."		;CHANGE UNDERLINE TO .
^^CREFOUT:
	SKIPE	LNCREF	;CREF GONE FOR THIS LINE?
	 JRST	GONEF		;YES
	SETOM	LNCREF
	PUSH	P,A
	MOVEI	A,177
	PUSHJ	P,CREFOUT
	MOVEI	A,"B"
	PUSHJ	P,CREFOUT
	POP	P,A
NOTENX <
GONEF:	SOSG	LSTCNT
	 PUSHJ	P,LSTDO
	IDPB	A,LSTPNT
	POPJ	P,
>;NOTENX
TENX <
GONEF:	EXCH	1,2
	EXCH	1,LISJFN
	JSYS	BOUT
	EXCH	1,LISJFN
	EXCH	1,2
	POPJ	P,
>;TENX


^^CREFASC:			;CREF THE ASCII FOR A SYMBOL.
	HRRZ	A,$PNAME(LPSA)	;COUNT.
	PUSHJ	P,CREFOUT	;AND CREF...
	MOVE	TEMP,A
	MOVE	C,$PNAME+1(LPSA)	;BYTE POINTER.
	ILDB	A,C
	PUSHJ	P,CREFCHR
	SOJG	TEMP,.-2
GPOPJ:	POPJ	P,

^^CREFDEF:			;PUT OUT SYMBOL DEFINTION.
	MOVEI	A,11		;ORDINARY SYMBOL
	MOVE	TEMP,$TBITS(LPSA)
	TLNE	TEMP,DEFINE
	 MOVEI	A,13		;FOR MACRO
	PUSHJ	P,CREFOUT
	PUSHJ	P,CREFSYM
	JRST	CREFASC		;CODE,SYMBOL,PRINT-NAME.

^^CREFBLOCK:			;END OF A BLOCK.
	MOVEI	A,16
	PUSHJ	P,CREFOUT
	JRST	CREFASC		;AND THE NAME.


BEND CREF


DSCR HDR, HDROV 
DES List routines for top of (physical page). Reset page,
  line counters.  Print a page header if listing.
 HDR is called when new page (logical) is sensed.
 HDROV is called when PGSIZ lines have been printed
  since last time a header was printed.
SID Uses D, TEMP,USER -- saves USER, C, others vulnerable.


^HDR:	
	AOS	PAGENO		;NEXT PAGE, PLEASE
	AOS	FPAGNO		;NEXT IN THIS FILE
	SETZM	PAGINC		;FIRST PHYSICAL PAGE NO
	SETZM	BINLIN		;SEQUENTIAL LINE #
	AOS	BINLIN		;ALWAYS STARTS AT 1
	MOVE	TEMP,[ASCII /00001/]
	MOVEM	TEMP,ASCLIN	;SO DOES THE SUFF WHICH APPEARS ON LISTING
;;#HU# 6-20-72 DCS BETTER TTY LISTING
	SKIPN	CRIND		;NEED CRLF/INDENT?
	 JRST	 NCRIND		;NO
	SETZM	CRIND
	TERPRI
;;%CF% JFR 7-8-75
	SKIPA	TEMP,LININD	;HOW MANY
	PUUO	1,[" "]
	SOJGE	TEMP,.-1
;;%CF% ^
NCRIND:	PRINT	< >
	DECPNT	FPAGNO		;JUST KEEP TRACK
;;%CT% warnings if in macro or false conditional scan
	MOVEI	TEMP,LININD+1	;TRKMCR AND TRKMCS MUST POINT TO A STRING
	SKIPN	TRKMCR
	 MOVEM	TEMP,TRKMCR
	SKIPN	TRKMCS
	 MOVEM	TEMP,TRKMCS
	MOVEI	TEMP,0
	TLNE	FF,PRMSCN	;SCANNING MACRO PARAMS?
	 MOVEI	TEMP,[ASCIZ/macro parameters/]
	SKIPE	CNDLST		;OR FALSE CONDIITIONAL?
	 MOVEI	TEMP,[ASCIZ/false conditional compilation/]
	JUMPE	TEMP,SEOP1	;IF OK
	HRLI	TEMP,440700	;COMPLETE BYTE POINTER
	MOVEI	A,[ASCIZ\
WARNING: Form-feed while scanning @A.
Last source-file macro: @I  @E/@D
Current macro: @I
\]
	MOVEI	B,-1+[	PWORD	TEMP
			PWORD	@TRKMCS
			PWORD	TRKM.L
			PWORD	TRKM.P
			PWORD	@TRKMCR]
	PUSH	P,C		;SAVE THIS
	PUSHJ	P,SPLPRT
	POP	P,C
;	jrst	seop1

SEOP1:
;;%CT% ^

;;%DE% JFR 10-25-75
^HDROV:	SETZM	LINNUM		;HERE WHEN LINES OVERFLOW PAGE
	AOS	PAGINC
	push	p,c		;save C (I am not sure why?)
	pushj	p,updbnr	;update compiler!banner to current
				;file, page, whatever
	POP	P,C
;;%DF% RHT 10-25-75
	MOVE	TEMP,FMTWRD	;CHECK FORMAT BITS
	TRNN	TEMP,140	; USER REQUESTED LIST OFF (40) OR NO HEADING (100)
;;%DF% ^
	 TLNN	FF,LISTNG	;LISTING FILE OPEN?
	  POPJ	 P,		; NO
	MOVE	TEMP,SCNWRD
TENX<	SKIPLE	A,LISJFN	;is there actually no listing file
				;this also cleverly loads A for TENEX
>;TENX
	TRNE	TEMP,NOLIST	;DID SCANNER TURN LISTING OFF?
	 POPJ	P,		; YES
NOTENX<
;;%XM% ! JFR 8-22-76 WAS =5*28+4	28 IS A FUNNY OCTAL CONSTANT!
	HRRZ	TEMP,BANMAC+$PNAME	;MAKE SURE ENOUGH ROOM REMAINS
					;length will be l(macro)-4+5
					;4:quotes,177,0  5:ff,crlf,crlf
	CAML	TEMP,LSTCNT	;IS THERE
	 PUSHJ	P,LSTDO		;NOW THERE IS (I hope buffer is large)
	movn	a,lstcnt	;HDROV1 will count up
	move	b,lstpnt	;where to put results
	MOVE	TEMP,BANMAC+$PNAME+1	;B.P.
	IBP	TEMP		;SKIP OPENING QUOTE
	MOVEI	D,14		;output FF, then banner without quotes
	PUSHJ	P,HDROV1
	MOVEI	D,15		;CR
	MOVE	TEMP,[POINT 7,[BYTE (7) 12,15,12,42],-1] ;LF CR LF "
				;the quote will stop HDROV1
	pushj	p,hdrov1	;output two crlf's
	movnm	a,lstcnt	;and store number of characters left
	movem	b,lstpnt	;and the updated byte pointer
	popj	p,		;now we are all done

HDROV1:			;move D then characters from bp B to bp TEMP
			;stop when a quote loadede (don't deposit)
			;A will be incremented by the number deposited
	IDPB	D,LSTPNT
	ILDB	D,TEMP		;CHAR FROM BANNER
	CAIE	D,042
	 aoja	a,hdrov1	;CONTINUE UNTIL 042 CLOSE QUOTE
	addi	a,1		;bump character count for first char
	POPJ	P,
;;%DE% ^
>;NOTENX
TENX<				;note the tricky load of A when
				;testing for listing on above
	exch	temp,c		;save C since SOUT uses it
	HRRZI	B,14
	JSYS	BOUT
	MOVE	B,BANMAC+$PNAME+1	;B.P.
	IBP	B		;SKIP OPENING QUOTE
	HRRZ	C,BANMAC+$PNAME	;COUNT
	SUBI	C,4		;OMIT QUOTES AND 177&0
	JSYS	SOUT		;DISPOSE OF IT
	MOVE	B,[POINT 7,[BYTE (7) 15,12,15,12],-1]	;CRLF CRLF
	MOVEI	C,4
	JSYS	SOUT
	exch	temp,c		;restore C
	POPJ	P,
>;TENX


^^updbnr:	;;update compiler!banner
bnbfmx__=60	;;compiler!banner buffer size in words
		;;(was effectively =28 for nontenex)
printx COMPILER!BANNER might be broken for TENEX now
	MOVE	TEMP,TTOP	;CUR BLOCK SEMBLK
TENX<
	HRROI	2,TITLIN	;DESTINATION
	HRROI	1,TITTIM	;SOURCE -- SAIL time date
	SETZ	3,
	JSYS	SIN		;COPY INTO MACRO BODY STRING
	MOVE	1,2		;UPDATED DESTINATION
	HRRZ	2,SRCJFN	;GET file name open on JFN
	SETZ	3,		;format (just take the default)
	JSYS	JFNS		;FILE NAME
	MOVE	D,1		;UPDATED DESTINATION BYTE POINTER
	MOVSI	C,-5*=28	;it used to, but it doesn't look right
>;TENX
NOTENX<
	MOVE	D,[IPCHAR TITLIN]
	MOVSI	C,-5*bnbfmx
>;NOTENX
	MOVEI	A,TITPAT
	MOVEI	B,-1+[
TENX<		PWORD	FPAGNO
		PWORD	PAGINC
>;TENX
		PWORD	IPROC+$PNAME+1	;OUTER BLOCK NAME B.P.
NOTENX<		PWORD	SRCDEV
		PWORD	SRCFIL
		PLEFT	SRCEXT
		PWORD	SRCPPN
		PWORD	FPAGNO
		PWORD	PAGINC
>;NOTENX
		PWORD	$PNAME+1(TEMP)	;CURRENT BLOCK NAME B.P.
		PWORD	ASWITCH	;/A
		PWORD	BAILON	;/B
		POINT	1,SCNWRD,5;/C
		PRIGHT	DFMAX	;/D
		PWORD	FMTWRD	;/F
TENX<		PWORD	LODMOD	;/G
>;TENX
		PWORD	HISW	;/H
		PWORD	KOUNT	;/K
		PWORD	LSTSTRT	;/L
		PRIGHT	PDLMAX	;/P
		PRIGHT	SPMAX	;/Q
		PRIGHT	PPMAX	;/R
		PRIGHT	STMAXX	;/S
TENX<		PWORD	LODDDT	;/T
		PWORD	LODSDT	;/U
>;TENX
		PWORD	OVRSAI	;/V
		PWORD	WHERSW	;/W
		PWORD	XTFLAG	;/X
		]
EXTERNAL SPLICE
	PUSHJ	P,SPLICE
NOTENX<
	jumpl	c,ban.ok	;well, what do you know, we got it
	move	c,[BYTE (7) "*",042,177,0,0]	;indicate shortened (*)
				;close the string with a quote (042)
				;and indicate end of macro (177&0)
	movem	c,(d)		;forcibly chop it short
	movei	c,5*bnbfmx-1	;and get length of shortened block
				;-1 since last 0 was wasted
ban.ok:	HRRZM	C,BANMAC+$PNAME	;store macro body CHAR COUNT
>;NOTENX
TENX<
	MOVE	C,D		;UPDATED B.P.
	SUBI	C,TITLIN	;rh(C) has # words
	MULI	C,5		;C_4,3,2,1 or 0, rh(D)_5*#words
	SUBI	D,-4(C)		;rh(D)_# chars
	HRRZM	D,BANMAC+$PNAME
printx TENEX should check for buffer over-write here
>;TENX
	popj	p,		;now we have fixed the banner


DATA(TITLE LINE)
^BANMAC:0		;FAKE SEMBLK FOR BODY OF MACRO
	0
	POINT	7,TITLIN
	CNST,,STRING
	0
TITLIN:	BLOCK	bnbfmx		;compiler!banner macro body goes here
TENX<
TITTIM:	BLOCK =10	;SAIL day time
TITPAT:	ASCII  /  @D-@D   @I
@I  @BA @BB @DC @DD @BF @DG @DH @DK @BL @DP @DQ @DR @DS @DT @DU @DV @DW @DX"/
	BYTE (7) 177,"@",0		; 177&0=END OF MACRO
>;TENX
NOTENX<
TITPAT:	ASCII	/"@I		/
NOTYMSHR <ASCII	/SAIL />
TYMSHR <ASCII /SAIL-TYMSHARE  />
	ASCII	/   dd/
	ASCII	/-mon-/
	ASCII	/yr   /
	ASCII	/hr:mn/
	ASCII	/ @F:@F.@F@G	@D-@D   /
	ASCII	/
@I		@BA @BB @DC @DD @BF @DH @DK @BL @DP @DQ @DR @DS @DV @DW @DX/
	BYTE (7) 042,177,"@",0		;" 177&0=END OF MACRO
	0
>;NOTENX
ENDDATA

;  MAKT -- PREPARE A TITLE LINE

^MAKT:
NOTENX<
NOTYMSHR <MOVE	TEMP,[POINT 7,TITPAT+2,20]> ;IDPB PNTR TO DAY OF MONTH
TYMSHR <MOVE TEMP,[POINT 7,TITPAT+4,20]>
	CALL6	C,DATE
	IDIVI	C,=31		;DAY IN D
	ADDI	D,1		;DAY - 1 THAT IS
	PUSHJ	P,MAKT.1
	IDIVI	C,=12		;MONTH - 1 IN D
	MOVE	D,[ASCII /-JAN--FEB--MAR--APR--MAY--JUN--JUL-/
		   ASCII /-AUG--SEP--OCT--NOV--DEC-/](D)
	AOJ	TEMP,
	MOVEM	D,(TEMP)	;-mon-
	MOVEI	D,=64(C)	;YEAR
	PUSHJ	P,MAKT.1
NOTYMSHR <MOVE	TEMP,[POINT 7,TITPAT+5]>
TYMSHR <MOVE TEMP,[POINT 7,TITPAT+7]>
	CALL6	C,MSTIME	;TIME IN MS
	IDIVI	C,=60000
	IDIVI	C,=60		;MINUTES IN D
	EXCH	D,C		;HOURS IN D
	PUSHJ	P,MAKT.1
	IBP	TEMP		;COLON
	MOVE	D,C		;MINUTES
MAKT.1:	IDIVI	D,=10
	ADDI	D,"0"
	IDPB	D,TEMP
	ADDI	D+1,"0"
	IDPB	D+1,TEMP
	POPJ	P,
;;%DE% ^
>;NOTENX


TENX <
	HRROI	2,TITTIM	;DEST. DESIGN. FOR ALL THAT FOLLOWS
	HRROI	1,[ASCIZ /"SAIL  /]
	SETZ	3,
	JSYS	SIN		;MERELY COPY
	MOVE	1,2		;UPDATED DEST
	SETO	2,		;CURRENT TIME
	SETZ	3,		;KEEP IT SIMPLE
	JSYS	ODTIM		;APPEND DATE AND TIME
	SETZ	2,
	IDPB	2,1		;MAKE SURE ITS ASCIZ
	POPJ	P,
>;TENX

SUBTTL	ENTERS -- ENTER A SYMBOL


DSCR ENTERS -- make new symbol entry
DES Will use existing comments, not use standard form
 ENTERS creates a block of proper type for this "ATOM", and
  installs the proper links to assure this thing can be found
  again. ENTERS can handle the following kinds of things:
		1. Variables -- numeric, STRING, ITEM, etc.
		2. Labels
		3. Procedure identifiers
		4. Numeric constants
		5. String constants
 STEPS:
 1-3: Create a block for ID. Check that level is greater
  for new symbol if old one was present (FORWARD Procedures
  are a special case). Install level, $TBITS, $PNAME; link
  to SYMTAB hash table (ptr to instr to fetch right bucket in HPNT).
  Link to current VARB structure via %RVARB, to STRRNG via
  %RSTR for STRINGC collector. Return ptr to Semantics in  NEWSYM
  (replaces ptr to found block if redefinition).
 4: Insert numeric value entry in CONST bucket. No checking
  (level, etc.) is necessary because ENTERS is called for
  constants only when the lookup fails. Bucket fetching instr
  found in HPNT, new Semantics to NEWSYM.
 5: Insert new string constant entry in STRCON bucket. #4 
  arguments also apply here.

PAR "BITS" -- the TBITS flags for the ATOM. These will be
  installed in the entry. They also guide the entry process.

"PNAME" -- String descriptor for $PNAME or String constant.

"SCNVAL" -- value of (1st word of) numeric constant. Second
  word, if any, is the adjacent word DBLVAL.

"HPNT"  -- The instr which when executed will load LPSA with
  the correct bucket in the right half. SHASH, NHASH set up.

"NEWSYM" -- if 0, ptr to block matching PNAME or SCNVAL. This ptr
  is set by SCAN, STRINS, etc., using SHASH, NHASH. If -0,
  this is the first occurrence of the symbol.

"QRCTYP" -- Record class id. ... if  not zero, put into lhs of $acno

Also, the prodef bit in ff is used to tell if the symbol is a formal param

RES "NEWSYM"_pointer to new block.

SID Uses A,C, TBITS, LPSA, TEMP; alters symbol table structure



^ENTERS:	
	MOVE	TBITS,BITS	;TYPE BITS
	TLNE	TBITS,CNST	;CONSTANT?
	 JRST	 ENCNST		; YES

; ENTER AN IDENTIFIER -- CHECK FOR RESERVED (ERROR), FORWARD
;  PROCEDURE BEING DEFINED. CHECK LEVEL VALIDITY FOR REDEFINED
;  SYMBOLS

ENIDNT:
	MOVE	C,LEVEL		;CURRENT LEVEL OF DEFINITION
	SKIPG	LPSA,NEWSYM	;IS THIS THE FIRST OCCURRENCE?
	 JRST	 BRANEW		; YES

;;#JZ# 11-4-72 HJS (1-2) CHANGE MACRO SCOPE
;;#JZ# THIS GROUP AND THE NEXT WERE INTERCHANGED
	SETCM	TEMP,$TBITS(LPSA);PREVIOUS TYPE BITS, COMPLEMENTED
	SKIPL	$TBITS(LPSA)	;CHECK FOR REDEFINITION OF A RESERVED
				; WORD AS AS A MACRO (HJS 11-19-72)
	 TLNN	TBITS,DEFINE	;SPECIAL TREATMENT FOR REDEFINITION
	  JRST	 NODEFN		; IT ISN'T ONE (HJS 11-19-72)
;; #LC# (1-17-73) HJS MACRO FORMAL,NOT MACRO REDEFINITION
	TLNE	TBITS,FORMAL	;
	 JRST	NODEFN		;MACRO FORMAL, NOT MACRO REDEFINTION
;; #LC#
	TLNN	TEMP,DEFINE	;WAS PREVIOUS DEFINITION ALSO A MACRO? 
	 SKIPN	REDEFN		; YES, MACRO REDEFINITION? 
	  JRST	NODEFN		; NO, GO CHECK LEVELS 
	 JRST	DFEN1		; IT IS ONE
;;#JZ# (1-2)

;;#JZ# 11-4-72 HJS (2-2) WAS INTERCHANGED WITH ABOVE
NODEFN:	LDB	A,PLEVEL	;OLD LEVEL OF DEFINITION (HJS 11-19-72)
	SKIPL	$TBITS(LPSA)	;IF OLD WAS RESERVED WORD, THEN OK.
	 CAMLE	C,A		;C=CURRENT -- MUST BE GREATER
	  JRST	 OKOLD		; AND IS
	CAME	C,A		;IF =, MAY BE FORWARD COMING
	 ERR	 <SAIL IN LEVEL TROUBLE>,1
;;#JZ# 2-2

CHKPRC:	SETCM	A,TBITS		;NEW BITS
;; SUGG BY R. SMITH LOAD A BEFORE TRNN
	TRNN	TEMP,PROCED!FORWRD; MUST BE FORWARD PROCEDURE
	 JRST	 ISPRC
	TLO	A,OWN		;THIS IS SORT OF IRRELEVANT
	TLO	TEMP,OWN
	TLOE	TEMP,EXTRNL
	 ERR	 <DUPLICATE IDENTIFIER DECLARATION>,1,BRANEW ; ISN'T ANY GOOD!
	TLC	A,INTRNL	;SHOULD BE ON (=0), TURN OFF (=1) OR ON (ERROR)
	CAME	A,TEMP
	 ERR	 <DUPLICATE IDENTIFIER DECLARATION>,1,BRANEW ; ISN'T ANY GOOD!
	MOVEM	TBITS,$TBITS(LPSA)
REC <
	SKIPE	C,QRCTYP	;RECORD CLASS ID SPECIFIED
	 HRLM	C,$ACNO(LPSA)
>;REC
	PUSHJ	P,URGVRB
	PUSHJ	P,RNGVRB
	POPJ	P,

ISPRC:	TRNN	TBITS,PROCED	 ;THIS SHOULD ALSO BE A PROCEDURE
	 ERR	 <DUPLICATE IDENTIFIER DECLARATION FOR >,3,BRANEW

; FORWARD PROCEDURE BEING DEFINED NOW, CHECK VALIDITY, CHANGE BITS

	TRZE	A,FORWRD 	;TO MATCH OLD(COMPLEMENTED)
	 TLNN	A,EXTRNL	;MAKE SURE NOT DUPLICATE EXTERNAL
	  ERR	 <DUPLICATE FORWARD/EXTERNAL DECLARATION FOR >,3,NOPROG
;;#JX#2! 11-2-72 DCS ALLOW INTERNAL PROC TO OVERRIDE EXTERNAL PROC.
	TLON	TEMP,EXTRNL	;Turn off EXTRNL in old, but if it was on, flip
	 TLC	 A,INTRNL	; INTRNL in new (will turn it off was on -- correct)
;;#JX#
	CAME	A,TEMP		;CHECK MATCHING TYPES
	 ERR	 <FORWARD TYPE DISAGREES>,1
	TRO	TBITS,INPROG	;MARK PROCEDURE UNDER DEFINITION
;;#SD#	ADD A FLAG IF OLD IS EXTERNAL & NEW IS INTERNAL
	MOVE	C,$TBITS(LPSA)	; COULD HAVE USED THE HAIR ABOVE, BUT ...
	SETOM	IEFLAG		;SET THE FLAG
	TLNE	C,EXTRNL	;RESET IT IF OLD NOT EXTERNAL
	 TLNN	TBITS,INTRNL	;OR NEW NOT INTERNAL
	  SETZM	IEFLAG		;
;;#SD#

	MOVEM	TBITS,$TBITS(LPSA) ;STORE NEW
REC <
	SKIPE	C,QRCTYP	;RECORD CLASS ID SPECIFIED
	 HRLM	C,$ACNO(LPSA)
>;REC
NOPROG:	PUSHJ	P,URGVRB	;REMOVE FROM VARB RING
	PUSHJ	P,RNGVRB	;PUT BACK ON THE END
	LEFT	,%TLINK,LPSERR	;PTR TO SECOND BLOCK
	LEFT	(,%TLINK)
;;#GP# DCS 2-6-72 (2-4) CHECK OLD FORMALS AGAINST ACTUAL ONES
	HRRZM	LPSA,OLDPRM	;SAVE OLD FORMALS -- USED TO KILLST HERE
	POPJ	P,		;FOR A BIT LATER
;;#GP# (2)

; REDEFINITION IF NOT A PARAMETER TO A MACRO

DFEN1:	TLNN	TEMP,FORMAL	;BITS ARE COMPLEMENTED HERE, CAN'T BE FORMAL
	 ERR	<DUPLICATE IDENTIFIER DECLARATION>,1
	POPJ	P,		; GET OUT IF MACRO REDEFINITION AT THE
				; SAME LEVEL.  BODY IS DELETED IN 
				; DFENT IF %TLINK IS NON-ZERO



 
; NOW CREATE A NEW BLOCK, PUT STUFF IN IT

BRANEW:	;NO CHECKING WAS DONE
OKOLD:	;IT'S ALL OK

	GETBLK	NEWSYM		;GET A NEW BLOCK

; INSERT PNAME, BITS -- LINK TO BUCKET, STRING RING,(VARB IF ID)

	MOVE	LPSA,NEWSYM	;POINTER TO NEW BLOCK
	HRROI	TEMP,PNAME+1	;GET PDP FOR POPPING DATA

	POP	TEMP,$PNAME+1(LPSA) ;STORE STUFF
	POP	TEMP,$PNAME(LPSA)

;CREFFING FOR THE WORLD.
	TLNE	FF,CREFSW
;;#OH# -- HJS 9-24-73 DO NOT CREF MACRO FORMALS 
	PUSHJ	P,[ TLNE TBITS,DEFINE ; DO NOT CREF MACRO FORMALS
		     TLNN TBITS,FORMAL
		      JRST ECREFIT
		    POPJ P,] 
;;#OH#

	TRNN	TBITS,PROCED	;PROCEDURE?
	 JRST	NOPROC		;NO
	MOVE	PNT,LPSA
	GETBLK			;SECOND PROCEDURE BLOCK
	HRLM	LPSA,%TLINK(PNT) ;%TLINK PNTS TO 2D BLOCK
	MOVE	LPSA,PNT
	TRNN	TBITS,FORTRAN	;A FORTRAN CALL?
	 TLNE	TBITS,EXTRNL	;OR EXTERNAL
	  TRO	TBITS,FORWRD	;TURN ON FORWARD.
	TRNN	TBITS,FORWRD	;A FORWARD PROCEDURE?
	 TRO	TBITS,INPROG	;NO -- TURN ON IN PROGRESS.
NOPROC:	MOVEM	TBITS,$TBITS(LPSA) ;TYPE BITS
REC <
	SKIPE	C,QRCTYP	;RECORD CLASS ID SPECIFIED
	 HRLM	C,$ACNO(LPSA)
>;REC
	SKIPE	C,SIMPSW	;IF SIMPLE
	 AOJA	C,FILLEV	;CLEVER TRICK: LOAD C 0 & GO PUT IN LL
	TRNN	TBITS,LABEL	;OR NOT A LABEL, DONT CARE
	 JRST	DOLL		;GO DO LEVELS
	MOVE	C,TPROC		;PICK UP CURRENT PROCEDURE
	HRRZ	C,$VAL(C)	;PICK UP PD SEMBLK
	HRLM	C,$ACNO(LPSA)	;PUT AWAY FOR LABEL SEMBLK
;#HY# RHT 6-26-72 OWN WAS BEING TESTED AS A RIGHT HALF BIT
DOLL:	SKIPE	C,CDLEV		;PICK UP DISPLY LEVEL
;;#IU# 8-12-72 ! RHT PREVENT EXTERNALS FROM BEING REFD (RF)
	 TLNE	TBITS,OWN!EXTRNL;IF NON-ZERO DISPLY LEV, BUT OWN, OK
;;#LS# RHT 2! 3-12-73 WAS GETTING TO FILLEV WITH NOD ZERO C FOR OWN&EXTERNAL
	  JRST	[SETZM C	;NO WORRY, ID IS AT LEVEL 0
		JRST FILLEV]
	SKIPE	RECSW		;IF  CURRENT PROC IS RECURSVE
;#HY# RHT  HERE IS WHERE OWN WAS BEING TESTED
	 TRNE	TBITS,ITEM!LABEL!PROCED; YES, IF NOT ITEM,LABEL, OR
					; PROC THEN USE STACK
	  TLNE	FF,PRODEF	;IF FORMAL USE STACK -- PRODEF SAYS WAS AN ARG LST
	   LSH	C,LLFLDL	;SHIFT LEVEL  T RIGHT SPOT
	TRZ	C,LLFLDM
	;MASK OUT LEX LEV FLD AREA
FILLEV:	TDO	C,LEVEL		;PUT IN THE LEX LEVEL
	HRRZM	C,$SBITS(LPSA)	;LEVEL OF DEFINITION

; LINK TO BUCKET, STRING RING

	MOVEI	A,LNKRET+1	;IN-LINE "CALL"
LNK:	MOVE	B,HPNT		;WORD SET UP BY HASH
	XCT	B		;THIS PICKS UP THE TIE INTO LPSA
	MOVE	TEMP,NEWSYM	;POINTER TO NEW ONE
	HRRM	LPSA,%TBUCK(TEMP)	;LINK DOWN NEW BLOCK
	HRR	LPSA,TEMP	;GET LPSA READY TO PUT BACK
	TLO	B,2000		;TURN ON "MOVE TO MEMORY" BIT
	XCT	B
LNKRET:	JRST	(A)		;ALL DONE

	MOVE	LPSA,NEWSYM
	PUSHJ	P,RNGSTR	;PUT ON STRING RING


; IF NOT A CONSTANT, LINK TO VARB LIST -- RETURN

	TLNE	TBITS,CNST	;NOT ON VARB IF CONST
	 POPJ	 P,		; DONE

	MOVE	LPSA,NEWSYM
	JRST	RNGVRB		;PUT ON VARB RING



Comment $ Constants, String or Numeric $

ENCNST:	TRNN	TBITS,STRING	;STRING CONSTANT?
	 JRST	 ENNUMB		; NO, NUMERIC

ENSTRNG:
	MOVEI	C,0		;STRCONS ARE AT LEVEL 0
	PUSHJ	P,BRANEW	;USE VARIABLE STUFF TO PERFORM THE ENTER.
	MOVE	LPSA,NEWSYM	;SEMANTICS OF RESULT
	HLLZS	$SBITS(LPSA)	;NO LEVELS FOR STRING CONSTANTS
	JRST	RNGCST		;PUT ON CONSTANT RING.


; NUMERIC CONSTANT

ENNUMB:
	GETBLK	NEWSYM
	HRROI	TEMP,DBLVAL	;STORE STUFF
	POP	TEMP,$VAL+1(LPSA)
	POP	TEMP,$VAL(LPSA)
	POP	TEMP,$TBITS(LPSA)
	JSP	A,LNK		;LINK TO BUCKET LIST
	PUSHJ	P,RNGCNM	;PUT ON CONSTANT RING
	POPJ	P,


DSCR ADCINS, CREINT, CONINS
CAL PUSHJ from EXECS which create constants for runtime.
PAR A contains value for CREINT, ADCINS
 SCNVAL,DBLVAL contains two-word value for CONINS (numeric)
 BITS contains type bits for CONINS
 PNAME string is value for CONINS (String)
RES Semantics for constant (new or used) in rh of PNT
DES These routines are used to create constants, for
  adjusting the stack, doing compile-time computation
  of constant expressions, providing address constants, etc.
 CONINS uses SCNVAL and BITS to make a constant of the
  proper flavor (PNAME string for String constants).
 CREINT makes an Integer constant.
 ADCINS is CONINS, except it forces a new constant to be
  made (code in SCANNER does it).  It is used to provide
  unique addresses for REFERENCE calls, which might wipe
  the values out.
SID TEMP,LPSA (USER?) mangled.  TBITS,SBITS, and rh PNT get results


^ADCINS:
	MOVEM	A,SCNVAL	;SPECIAL UNIQUE CONSTANT FOR
	MOVE	TBITS,[XWD CNST+RECURS,0] ;ADCON MAKER
	ORM	TBITS,BITS		;(CONSTANT BY REFERENCE)
	JRST	CONINS		;CONTINUE

^CREINT: MOVEM	A,SCNVAL	;CREATE AN INTEGER
	SKIPA	TBITS,[XWD CNST,INTEGR]

^CONINS: MOVE	TBITS,BITS
;;#  # DCS 3-1-72
	TRNE	TBITS,STRING	;INSERT A STRING IF REQUESTED
	 JRST	 STRINS
;;#  #
	PUSH	P,NUM1		;FLAGS
	PUSH	P,NUM2
CINS:	MOVE	TEMP,[XWD A,CONACS] ; SAVE REGISTERS 1-12
	BLT	TEMP,CONACS+SBITS2-A
	MOVE	LPSA,STRCON	;STRING CONSTANT BUCKET.
	MOVEM	TBITS,BITS
	XCT	-1(P)		;HASH AND LOOKUP
	MOVE	TBITS,TBITS+CONACS-A
	MOVEM	TBITS,BITS
	SKIPN	NEWSYM		;WAS IT FOUND?
	 XCT	(P)		;NO -- ENTERS
	MOVE	TEMP,[XWD CONACS,A] ; RESTORE REGISTERS 1-12
	BLT	TEMP,SBITS2
	SUB	P,X22		; ADJUST STACK POINTER TO GET RID OF ROUTINE NAMES 
	HRR	PNT,NEWSYM	;DO NOT CLOBBER LEFT HALF INCASE
				; ADCONS ARE BEING MADE.
	JRST	GETAD		; LOAD SBITS AND TBITS

^STRINS: PUSHJ	P,STRNS1	; 
	AOS	$VAL2(PNT)	; INCREMENT REFERENCE COUNT 
	POPJ	P,		; 

STRNS1:	PUSH	P,STR1		;FOR STRINGS
	PUSH	P,STR2
	MOVE	TBITS,[XWD CNST,STRING]
	JRST	CINS		;GO DO IT.

NUM1:	PUSHJ	P,NHASH
NUM2:	PUSHJ	P,ENNUMB
STR1:	PUSHJ	P,SHASH
STR2:	PUSHJ	P,ENSTRNG

ZERODATA (AC SAVE AREA FOR CONSTANT-MAKERS)
CONACS:	BLOCK SBITS2-A+1
ENDDATA

SUBTTL	HASH ROUTINES


DSCR SHASH -- look up symbol entries in hashed buckets.

PAR LPSA -- ptr to bucket Semblk (since there are two).
 PNAME -- String search argument

RES HPNT -- [MOVE LPSA, bucketaddr] or [MOVS LPSA, bucketaddr]
  as explained in HPNT declaration.
 NEWSYM -- 0 if not found, else Semantics of found entity.
 LPSA   -- same as NEWSYM

SID Uses TEMP, TBITS, A, B, C, D, PNT -- Results in LPSA
SEE HPNT, NEWSYM, Bucket descriptions in main SAIL DATA area


^SHASH:
	hrrz	a,pname		;#CHARACTERS
	jumpe	a,nulfnd	;null string search is special case
IFN FTDEBUG, <
	skipl	temp,pname+1	;get byte pointer
	 err	<DRYROT: SHASH misaligned string>,1
; ELSE>	MOVE	TEMP,PNAME+1	;BYTE POINTER
	XOR	a,(temp)	;1ST STRING WORD (mixed with length)
	PUSHJ	P,HASH		;COMPUTE HASH,GET POINTER,STORE IN HPNT

Comment $ Search for symbol identical to string in pname.
	Put pointer to it in NEWSYM if found.
	Computed hash pointer is in HPNT on entry
$
SFIND:	JUMPE	LPSA,NOFND		;IN CASE BUCKET WAS EMPTY
	HRRZ	A,PNAME		;LENGTH
	MOVEI	B,-1(A)
	IDIVI	B,5		;# WORDS - 1  IN B
	HRLI	PNT,D		;SET UP INDICES
	HRR	PNT,PNAME+1	;BYTE POINTER TO NEW NAME
	HRLI	C,D
	MOVE	TBITS,(PNT)	;FIRST WORD OF NEW NAME

BUKS:	CAMN	TBITS,@$PNAME+1(LPSA)	;SAME FIRST WORD?
	 jrst	lcomp		;yup, go make full compare
BUKLS:	RIGHT	,%TBUCK,,	;GO DOWN BUCKET
	jumpn	lpsa,buks	;as long as there are any buckets
	setzm	newsym		;indicate no match
	popj	p,		;and return

	LCOMP:	move	TEMP,$PNAME(LPSA)    ;LENGTH OF OBJECT STRING
		CAIE	A,(TEMP)	;SAME LENGTH?
		 JRST	BUKLS		;NO -- FAILURE
		SKIPG	D,B		;# WORDS-1
		 JRST	FND		;SAME SYMBOL, ONE WORD LONG
		HRR	C,$PNAME+1(LPSA);BYTE POINTER ADDR -- INDEX

	SFNLUP:	MOVE	TEMP,@PNT
		CAMN	TEMP,@C		;SAME WORD?
		 SOJG	D,SFNLUP	;YES, KEEP AT IT!
		JUMPG	D,BUKLS		;FAILURE if didn't complete

FND:	MOVEM	LPSA,NEWSYM
	POPJ	P,

	;;SDD added this so no null string checks needed above
nulfnd:	pushj	p,hash		;get hash for 0
	jumpe	lpsa,nofnd	;bucket empty, get out
nulfl:	hrrz	temp,$PNAME(lpsa)	;is this a null string?
	jumpe	temp,fnd		;yep, go match
	RIGHT	,%TBUCK,,	;chase the link down another string
	jumpn	lpsa,nulfl	;as long as there is more to check

nofnd:	setzb	lpsa,newsym		;indicate not found
	popj	p,		;and return

DSCR NHASH -- look up symbol entries in hashed buckets.

PAR SCNVAL -- Numeric search argument (high order word)
 DBLVAL -- Numeric search argument (low order word)
 BITS   -- type bits for numeric search (note: types must match)

RES HPNT -- [MOVE LPSA, bucketaddr] or [MOVS LPSA, bucketaddr]
  as explained in HPNT declaration.
 NEWSYM -- 0 if not found, else Semantics of found entity.
 LPSA   -- same as NEWSYM

SID Uses TEMP, A, B -- Results in LPSA
SEE HPNT, NEWSYM, Bucket descriptions in main SAIL DATA area


^NHASH:	MOVE	A,SCNVAL	;HASH ON 1ST WORD OF VALUE
	MOVE	LPSA,CONST	; HASH TO CONST BUCKET
	PUSHJ	P,HASH
	JUMPE	LPSA,NOFND	;can't find a thing in an empty bucket
	MOVE	TEMP,BITS	;get type bits for comparison
	TLNE	TEMP,RECURS	;WANT UNIQUE CONSTANT?
	 JRST	 NOFND		; YES, SAME AS FAILURE
			;this is the only NOFND with lpsa non-zero
	MOVE	A,SCNVAL	;GET VALUES FOR COMPARISON
	MOVE	B,DBLVAL

BUK:	CAMN	A,$VAL(LPSA)	;FIRST VALUE EQUAL?
	 CAME	B,$VAL2(LPSA)	;SECOND VALUE EQUAL?
	  JRST	BUKL		;NO -- FAILURE
	CAMN	TEMP,$TBITS(LPSA) ;MAKE SURE TYPE IS SAME
	 JRST	FND		;OK, USE IT
BUKL:	RIGHT	,%TBUCK		;DOWN BUCKET LIST
	jumpn	lpsa,buk	;while anything left to do

	JRST	NOFND		;FINISH OUT


Comment $ HASH routine itself --

IN:  A -- number to be hashed
     LPSA -- bucket pointer

OUT: HPNT contains an instruction which, when executed
	will load LPSA with the bucket word in the RH.
	See LNK above for the cute way of entering
	the new symbol.

ACS: uses A, B -- results in LPSA

$

HASH:	IDIVI	A,BUKLEN	;GET  (A mod BUKLEN)
	MOVMS	B		;USE MAGNITUDE
	ROT	B,-1		;DIVIDE BY TWO
	ADD	LPSA,B		;ADD TO THE BUCKET POINTER
	HRLI	LPSA,(<MOVE LPSA,0>)
	SKIPL	B
	HRLI	LPSA,(<MOVS LPSA,0>)
	MOVEM	LPSA,HPNT	;AND STORE AWAY
	XCT	LPSA
	HRRZS	LPSA		;SO THE JUMPE WILL WORK.
	POPJ	P,


SUBTTL	SEMBLK Allocation Routines
DSCR BLKGET, BLKFRE -- Semblk Allocators
CAL PUSHJ via GETBLK, FREBLK macros.

DES Routines to perform the following:
 BLKGET allocates a new 11-word Semblk.
 BLKFRE restores such a Semblk to the BLFREE storage list
 SETBLK Initializes BLFREE with blocks as determined by
  determined by the area allocated in lpsbot, lpstop.
 NEEBLK	Gets more blocks when you need them
 BLKZER	Zeroes the block pointed to by LPSA

PAR LPSA is Semblk address for BLKFRE

RES LPSA contains Semblk address from BLKGET

SID USER used for GOGTAB by SET-&NEE- blk
 TEMP  destroyed by same
 LPSA changed by SETBLK and BLKZER, set to good thing by NEEBLK


ZERODATA (BLOCK-GETTER VARIABLES)
COMMENT $
BLFREE -- Semblk Free Storage List pointer.  Points to first Semblk
   on list, whose first word points to next, etc. -- 0 terminates.
   Semblks are put on the list by BLKZER when allocating more, and
   by the BLKFRE (via FREBLK macro) routine.  They are removed by
   the BLKGET (via GETBLK macro) routine.
$
^^BLFREE: 0

;FRECNT -- # free blocks when enabled by FTCOUNT switch
IFN FTDEBUG, <
^^FRECNT: 0
>

TSTALO__0		;SPECIAL TEST MODE FOR BLOCK ALLOCATOR
IFNDEF TSTALO, <TSTALO__0>
IFE TSTALO,<BLLEN__BLKLEN; ELSE>BLLEN__BLKLEN+2 ;SET TOTAL BLOCK SIZE
IFN TSTALO, <BLKUSE: 0>
ENDDATA

^SETBLK:
IFN TSTALO ,<
	MOVEI	TEMP,BLKUSE-BLKLEN-1 ;initialize pointer to
	HRLS	TEMP		     ;doubly-linked list of IN USE
	MOVEM	TEMP,BLKUSE	     ; blocks for finding lacking FREBLKs
>;TSTALO

	MOVE	TEMP,LPSBOT
SETBL1:	MOVEM	TEMP,BLFREE		;STARTING ADDRESS
GOK:	MOVEI	LPSA,BLLEN(TEMP)	;NEXT AREA
	CAML	LPSA,LPSTOP		;TOO FAR?
	JRST	SETD
	MOVEM	LPSA,(TEMP)		;STORE THE POINTER
	MOVE	TEMP,LPSA
	JRST	GOK

SETD:	SUBI	TEMP,BLLEN		;GO BACK AND
	SETZM	(TEMP)			;TERMINATE LIST
	POPJ	P,

^NEEBLK:
	PUSH	P,B			;NEEDED FOR CORE GETTERS
	PUSH	P,C
	MOVE	B,LPSBOT		;TRY TO INCREMENT THIS BLOCK
	MOVEI	C,=100*BLLEN		;TRY TO INCREMENT THIS BLOCK
	PUSHJ	P,CANINC		;IS IT POSSIBLE?
	 JRST	 NOINC			;NO

	JRST	INCR3			;YES, GO DO IT

NOINC:	
	CAIGE	C,=20*BLLEN		;WILL SETTLE FOR THIS
	 JRST	 GETTOP			;NO, GET NEW BLOCK

INCR3:	PUSHJ	P,CORINC		;EXPAND BY ALLOWABLE AMOUNT
	 ERR	 <DRYROT>		;CAN'T HAPPEN
	EXCH	C,LPSTOP		;OLD TOP IS NEW FREE AREA
	ADDM	C,LPSTOP		;NEW UPPER LIMIT
	MOVE	TEMP,C			;SO LEAVE IT WHERE IT WILL BE NOTICED
	JRST	NEERT1			;NOW GO AND RELINK


GETTOP:	MOVEI	C,=100*BLLEN		;GET NEW BLOCK THIS SIZE
	PUSHJ	P,CORGET
	 CORERR <RAN OUT OF CORE AT GETTOP>
	MOVEM	B,LPSBOT		;SET LIMITS ANEW
	MOVEM	B,LPSTOP
	ADDM	C,LPSTOP

NEERET:	
	MOVE	TEMP,B			;PTR TO BOTTOM OF NEW
NEERT1:	POP	P,C
	POP	P,B
	PUSHJ	P,SETBL1		;LINK THEM UP
	MOVE	LPSA,BLFREE		;SO THAT WE CAN CONTINUE
	POPJ	P,

^BLKGET: 
IFN FTDEBUG,<AOS FRECNT>
	SKIPN	LPSA,BLFREE
	PUSHJ	P,NEEBLK	;GET A WHOLE NOTHER SET.
	MOVE	TEMP,(LPSA)
	MOVEM	TEMP,BLFREE	;UPDATE FREE STORAGE.
^BLKZER: SETZM	(LPSA)		;FIRST WORD
	MOVSI	TEMP,(LPSA)		;ZERO THE BLOCK
	HRRI	TEMP,1(LPSA)
	BLT	TEMP,BLLEN-1(LPSA)
IFN TSTALO,<
; ADD BLOCK TO DOUBLY-LINKED RING OF IN USE BLOCKS
	POP	P,BLKLEN(LPSA) ;SAVE RET ADDR FOR HISTORY OF CALL TO BLKGET
	HLRZ	TEMP,BLKUSE	;GET POINTER TO LAST BLOCK IN RING
	HRLM	LPSA,BLKUSE	;UPDATE SAID POINTER
	HRRM	LPSA,BLKLEN+1(TEMP) ;UPDATE FOR'RD PNTR IN OLD LAST BLOCK
	HRLM	TEMP,BLKLEN+1(LPSA) ;UPDATE BCK'RD PNTR IN NEW (LAST) BLOCK
	MOVEI	TEMP,BLKUSE-BLKLEN-1 ;UPDATE FOR'RD PNTR IN NEW BLOCK
	HRRM	TEMP,BLKLEN+1(LPSA)
	JRST	@BLKLEN(LPSA)	    ;RETURN DEVIOUSLY
; ELSE >POPJ	P,

^BLKFRE:
IFN FTDEBUG,<SOS FRECNT>
	EXCH	LPSA,-1(P)		;GET ARG, SAVE LPSA
	MOVE	TEMP,BLFREE
	HRRZM	TEMP,(LPSA)		;STRINGOUT FREE STORAGE
	HRRM	LPSA,BLFREE
IFN TSTALO, <
; REMOVE FROM IN USE RING
	MOVE	TEMP,BLKLEN+1(LPSA)	;BCK'RD,,FOR'RD
	HLLM	TEMP,BLKLEN+1(TEMP)	;UPDATE BCK'RD IN NEXT TO PNT TO  PREV
	MOVSS	TEMP
	HLRM	TEMP,BLKLEN+1(TEMP)	;UPDATE FOR'RD IN LAST TO PNT TO NEXT
>
	MOVE	LPSA,-1(P)		;GET OLD VALUE BACK
	SUB	P,X22
	JRST	@2(P)


SUBTTL	RNGVRB, RNGSTR, etc. -- `Ring' Linkage Routines


DSCR RNGSTR, RNGGEN, RNGTMP, RNGCST, RNGVRB, RNGADR, RNGCNM
PAR (Sometimes) LPSA is Semblk address
RES The Semblk is linked onto a `ring' based on a variable
 implied by the routine name.  RNGSTR uses %RSTR -- all others
 use %RVARB.  The ring header variables are STRRNG, VARB, TTEMP,
 CONINT, CONSTR, ADRTAB.
DES These routines replace the RING macro -- for space efficiency.


^RNGDIS:MOVEI	TEMP,DISLST	;DISPLAY TEMPS
	JRST	RNGGEN
^RNGADR:SKIPA	TEMP,[ADRTAB]	;ADDRESS CONSTANTS
^RNGTMP:MOVEI	TEMP,TTEMP	;CORE TEMPS
	JRST	RNGGEN
^RNGCNM:SKIPA	TEMP,[CONINT]	;NUMERICAL CONSTANTS -- ASSUMES NEWSYM
^RNGCST:MOVEI	TEMP,CONSTR	;STRING CONSTANTS    -- ASSUMES NEWSYM
	SKIPA	LPSA,NEWSYM	;GET SEMBLK FROM HERE
^RNGVRB:MOVEI	TEMP,VARB	;VARB RING
RNGGEN:	PUSH	P,A
	SKIPN	A,(TEMP)	;The left half of %RVARB(Semblk) is
	 JRST	 .+3		; made to point to the previous `newest'
	HRRM	LPSA,%RVARB(A)	; Semblk, if one exists -- the right
	HRLZM	A,%RVARB(LPSA)	; half of %RVARB(Previous) points to
	MOVEM	LPSA,(TEMP)	; this one -- the vase vbl (TEMP) always
	POP	P,A		; indicates the new (right-hand) end
	POPJ	P,		; of the list -- the oldest lh is always 0


^RNGSTR:SKIPN	TEMP,STRRNG	;String ring linkage -- same business
	 JRST	 .+3
	HRRM	LPSA,%RSTR(TEMP)
	HRLZM	TEMP,%RSTR(LPSA)
	MOVEM	LPSA,STRRNG
	POPJ	P,



DSCR URGVRB, URGADR, URGTMP, URGCST, URGSTR
PAR LPSA is a Semblk Address
 The Header vbl is set up by calling the right routine
DES Undoes the damage done by RING


^URGDIS:SKIPA	TEMP,[DISLST]
^URGCNM:MOVEI	TEMP,CONINT
	JRST	URGGEN
^URGVRB:SKIPA	TEMP,[VARB]
^URGTMP:MOVEI	TEMP,TTEMP
	JRST	URGGEN
^URGADR:SKIPA	TEMP,[ADRTAB]
^URGCST:MOVEI	TEMP,CONSTR
URGGEN:	PUSH	P,A		;If there are no pointers in %RVARB, then
	SKIPN	A,%RVARB(LPSA)	;1) The Semblk is not on the ring, or:
	CAMN	LPSA,(TEMP)	;2) It is the only member, in which case its
	 JRST	 DOU		;   address is that of the header vbl (TEMP)
ENDU:	POP	P,A		;So you get here immediately in CASE 1 above,
	POPJ	P,		;   and after you've unlinked in other cases.
DOU:	TRNE	A,-1		;If there is a younger neighbor, tell him
	 HLLM	 A,%RVARB(A)	;   you're gone.
	TRNN	A,-1		;If there is not a younger neighbor, update
	 HLRZM	 A,(TEMP)	;   the header, because you were youngest.
	MOVSS	A
	TRNE	A,-1		;If there is an older neigbor, tell him
	 HLRM	 A,%RVARB(A)	;   you're gone.
	JRST	ENDU

^URGSTR:SKIPN	TEMP,%RSTR(LPSA);Same stuff for string ring.
	CAMN	LPSA,STRRNG
	 JRST	 DOST
	 POPJ	 P,
DOST:	TRNE	TEMP,-1
	 HLLM	 TEMP,%RSTR(TEMP)
	TRNN	TEMP,-1
	 HLRZM	 TEMP,STRRNG
	MOVSS	TEMP
	TRNE	TEMP,-1
	 HLRM	 TEMP,%RSTR(TEMP)
	POPJ	P,

DSCR KILLST
CAL PUSHJ
PAR LPSA ptr to first Semblk to be released
RES Unlinks Semblk from %RSTR, releases it to free
  storage, then continues right down %RVARB until
  all Semblks on this VARB-Ring are released. (LPSA unchanged)
SEE FREBLK, ULINK


^KILLST:  
	PUSH	P,LPSA
	JUMPE	LPSA,KLPDUN

KLLUP:	PUSHJ	P,URGSTR	;UNLINK FROM STRING RING
	FREBLK
	RIGHT	,%RVARB,,
	JUMPN	LPSA,KLLUP	;and proceed until done

KLPDUN:	POP	P,LPSA
	POPJ	P,

SUBTTL  Mark insertion routine for counter routines
DSCR LSTOUT -- write to list file
CAL PUSHJ P,LSTOUT
PAR Reg A contains character to be listed
RES The character right justified in A is placed in the output
 line of the list file.  If the last character was a CR, the character 
 is inserted before the CR.  This routine is called by the exec
 routines KOUNT1, KOUNT2, etc. to put markers in the list file
 indicating where counters were placed into the object code.
SID the contents of A may be changed.


^LSTOUT: PUSH	P,B		;SAVE B
	LDB	B,LPNT		;GET PREV LAST CHAR
	CAIE	B,15		;IS IT A CR
	 JRST	lsto.a		;NO
	DPB	A,LPNT		;YES, WIPE IT OUT
	MOVEI	A,15		;AND PUT CR AFTER IT
lsto.a:	MOVEI	B,(A)
	ML$CHR
	POP	P,B		;RESTORE B
	POPJ	P,		;RETURN



DSCR LSTOU1 -- Write to list file
CAL PUSHJ P,LSTOU1
PAR Reg A contains character to be listed
 Reg C contains character that the char in A should follow
RES If the last character in the line matches the one in
 C, the character in A is put at the end of the line.  If
 not, the char in A is placed before the last character.
 The necessity for doing this comes from the fact that some
 single character tokens are placed in the listing file before
 they are parsed.
SID Register A may be changed

^LSTOU1:  PUSH	P,B		;SAVE B
	LDB	B,LPNT		;GET THE LAST CHAR
	CAMN	B,C		;IS IT THE ONE WE WANT...
	 JRST	lsto.a		;YES, GO STORE CHARACTER
	CAIGE	C,"A"		;IS THE COMPARE CHAR A LETTER
	 JRST	lst1.d		;NO
	ADDI	C,"a"-"A"	;CONVERT TO LOWERCASE
	CAMN	B,C		;IS IT THE RIGHT THING?
	 JRST	lsto.a		;YES, GO STORE CHARACTER AND RETURN
lst1.d:	DPB	A,LPNT		;NO, STORE NEW CHAR
	MOVEI	A,(B)		;THEN OLD CHARACTER
	jrst	lsto.a

BEND SYM
^KILLST_KILLST

SUBTTL	Generator Data

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        xJD