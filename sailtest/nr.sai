COMMENT \HISTORY
SAIL
004  401200000043  \;

COMMENT \
VERSION 10-4(35) 27-feb-80 SDD check dangerous EOF, drop some AI chars
VERSION 10-4(34) 12-9-73  (33) 12-2-73  (32) 7-27-73  (31) 3-18-73
VERSION 10-4(30:12) 10-29-72 
VERSION 10-4(11) 10-29-72 BY DCS ADD BUILT-IN MACRO CAPABILITY
VERSION 10-4(10) 10-29-72 
VERSION 10-4(9:6) 3-2-72
VERSION 10-4(5:3) 3-1-72 
VERSION 10-4(2) 2-6-72 BY DCS CONVERT TO SLS-COMPATIBLE, CMDSCNSCNCMD
VERSION 10(1) 1-14-72 BY DCS REPLACE CMDSCN BY SCNCMD
\;


COMMENT Declarations, Trivial Procedures;

BEGIN "RTRAN" 
  DEFINE VERSION!NUMBER = "'401200000043";
  LET DEFINE = REDEFINE;
 REQUIRE VERSION!NUMBER VERSION;

REQUIRE "<><>" DELIMITERS;
  REQUIRE 5000 STRING!SPACE;

IFC DECLARATION(GTJFN)
 THENC DEFINE TENX(A)=<A>, NOTENX(A)=<>;
 ELSEC DEFINE TENX(A)=<>,NOTENX(A)=<A>; 
ENDC
IFC EQU(COMPILER!BANNER[LENGTH(SCANC(COMPILER!BANNER,"-",NULL,
	"IA"))+1 FOR 8],"TYMSHARE")
 THENC DEFINE TYMSW(A)=<A>,NOTYMSW(A)=<>;
 ELSEC DEFINE TYMSW(A)=<>,NOTYMSW(A)=<A>; 
ENDC

REQUIRE TENX(<"Tenex">) TYMSW(<"Tymshare">) NOTENX(NOTYMSW(<"Tops10">))
	&" version " & cvms(version!number) & " " MESSAGE;

COMMENT For now we will suppress the SOS type line numbers, if it is
	ever desirable to include them later , delete the following
	macro definition;
DEFINE LINOUT(X,Y) = <>;

COMMENT This is a program to generate the initial symbol table for the
 SAIL compiler.  The input is in the form of files -- containing data
 about the reserved words -- both syntactic and reserved function names.

THE FORMAT IS:

"<TRUECONDITIONALS>"

	a list of all conditional compilation flags which are "on".
	Conditional compilation uses "[]" for brackets, and
	the left bracket must immediately follow the flag word, i.e.,
	TENX[  ...  ]

"<FALSECONDITIONALS>"

	a list of all conditional compilation flags which are "off".
	Note: undeclared conditional compilation switches are false, 
		and cause error messages.

"<RESERVED-WORDS>"

(SYMBOL)	(NUMBER)	(C OR N)
	...C MEANS MEMBER OF A CLASS, N NOT

"<ASSIGN>"
(PASSED RIGHT ON TO FAIL AS SYMBOLIC ASSIGNMENTS FOR
	THE ARGUMENTS TO THE FUNCTION PARAMETERS)

"<FUNCTIONS>"

(SYMBOL)	(TYPE)	(NUMBER OF PARAMETERS)

FOR EACH PARAMTER:
(DESCRIPTOR)	(TYPE)	(VALUE,REFERENCE)

"<END>"
;

DEFINE RELMODE=<0>, LSTMODE=<0>, SRCMODE=<0>, LSTEXT=<NULL>, RELEXT=<NULL>,
	SWTSIZ=<2>, SRCEXT=<"QQQ">, PROCESSOR=<"RTRAN">, GOODSWT=<NULL>;
REQUIRE "SCNCMD.SAI" SOURCEFILE;

DEFINE SRC=<1>,SNK=<2>,BREAK=<SRCBRK>,EOF=<SRCEOF>,
	NORSCAN=<2>,SUPSPC=<1>,MACSCAN=<3>, ONESCAN=<4>, FBRK=<5>, CBRK=<6>,
	FF=<'14>, CR=<'15>,
	LF=<'12>,CRLF=<('15&'12)>,PRINT=<OUTSTR(>,
	MSG=<&CRLF)>,FUNCNO=<20>,
	RESNO=<220>,LINCNT=<5>,BUCKLEN=<13>;

INTEGER	COMMAND,LINENO,SYMCNT,RESCNT,TYPCNT,TYPARAM;
STRING	WORD,CURSYM,ABC,PARM,TEMPSTR;

STRING BAITSTR;
INTEGER BAICH2,BAIDUM; INTEGER ARRAY BCHPD[1:5];

INTEGER NCOND; STRING ARRAY CONDWORD[1:12];
integer nfcond; string array falsecondword[1:12];

STRING ARRAY RESPRINT[1:RESNO];
STRING ARRAY BUCKET[0:BUCKLEN];
INTEGER ARRAY RESNUM[1:RESNO];
STRING ARRAY PARAMS[1:20];

simple PROCEDURE PUTOUT(STRING A);
	BEGIN LINOUT(SNK,LINENO_LINENO+LINCNT); OUT(SNK,A&CRLF); END;

STRING simple PROCEDURE PRINTOCT(INTEGER A);
	RETURN(CVOS(ABS A));

simple PROCEDURE PRINTROOM;
	BEGIN PUTOUT(NULL); PUTOUT(NULL); END;
COMMENT Initialization, Getword, Hash, Reserved, Nxtsym, Gensym, Ison;

PROCEDURE INITIALIZATION;
BEGIN "Initialization"	INTEGER T; STRING TEM;

	SIMPLE PROCEDURE outFILE(STRING NAME; REFERENCE INTEGER CHAN);
	 BEGIN INTEGER D; 
	 D_0;
	 OPEN(CHAN_GETCHAN,"DSK",0,0,5,D,D,D);
	 if d then usererr(0,0,"Can't write to DSK");
	 ENTER(CHAN,NAME,D);
	 if d then usererr(0,0,"Can't ENTER " & name & " on DSK");
	 END;

	SETBREAK(NORSCAN," 	["&LF&FF,CR&"]","KINR");
	SETBREAK(SUPSPC," 	"&CRLF&FF&"]",NULL,"XNR");
	SETBREAK(MACSCAN,'5&"?"&'15,NULL,"IN");
	SETBREAK(ONESCAN,NULL,NULL,"XNA");
	SETBREAK(FBRK,"!"&'30,NULL,"INS");
	SETBREAK(CBRK,"[]",NULL,"INS");

	NX!TFIL_0; WANTBIN_TRUE; 
	NCOND_2; nfcond_2; 
	TYMSW (<CONDWORD[1]_"TYMSHARE"; 
		falsecondword[1]_"NOTYMSHARE";>)
	NOTYMSW (<CONDWORD[1]_"NOTYMSHARE"; 
		falsecondword[1]_"TYMSHARE";>)
	COMMAND!SCAN;
	BailSet;
...
procedure BailSet;
begin "BailSet"		integer t;
preset!with "BAISM1", "BAICLC", "BAIIO1", "BAIIO2", "BAIMSC", "BAIPRC";
	own safe string array BailNames[0:5];

for t_0 step 1 until 5 
   do begin
	outFILE( BailNames[t]&".FAI", BCHPD[t] );
	CPRINT(BCHPD[t],"	TITLE	", BailNames[t], 
		if t>0 then crlf&"$BEGIN__.+1"&crlf else crlf);
      end;
baich2_BCHPD[0];
CPRINT(BCHPD[5], crlf & "ITMVAR_ITMVAR+UNTYPE	;TYPE KLUGE" & crlf );
cprint(baich2,"
F_1
B_2
DP_10
P_17

PDL:	BLOCK 10
^^START: RESET
	MOVE	P,[IOWD 10,PDL]
	MOVE	DP,[POINT 36,$BEGIN]
");
if ForTenex
 then begin "tenex setup" 
	cprint(baich2,"
	MOVEI	D,5
GTNEXT:	MOVSI	1,1
	HRRO	2,-1+[
");
	for t_1 step 1 until 5
	 do cprint(baich2,"	[ASCIZ /",BailName[t],".SM1/]" & crlf);
	cprint(baich2,"		](D)
	GTJFN	
	 PUSHJ	P,ERR
	MOVEM	2,JFN-1(D)
	MOVE	2,[440000100000]
	OPENF
	 PUSHJ	P,ERR
	SOJG	D,GTNEXT
");
      end "tenex setup"
 else begin
	for t_1 step 1 until 5 
	   do cprint(baich2, crlf & "	OPEN	", t, ",FDB", t,
			crlf &	"	HALT	." &
			crlf &  "	ENTER	", t, ",ENT", t,
			crlf &	"	HALT	." );
      end;

OutWord_ if ForTenex then "BOUT" else "PUSHJ	P,WORD";
cprint(BAICH2,"
NEXT:	ILDB	F,DP		;WHICH FILE IT GOES TO
	CAMN	F,[-1]
	 JRST	FIN
	MOVE	F,filedt-1(F)	;ADDR OF BUFFER RING (or JFN)
	ILDB	B,DP		;FIRST DATA WORD
	", OutWord, "
	ILDB	B,DP		;SECOND DATA WORD
	", OutWord, "
	hrrei	D,400003(B)	;NUMBER OF ADDITIONAL DATA WORDS",
  if ForTenex then crlf & "	BOUT" else null, "
	ILDB	B,DP
	", OutWord, "
	SOJG	D,.-2
	JRST	NEXT

$BEGIN:
PDA1__PDA2__PDA3__PDA4__PDA5__1
");>) COMMENT TENX;
	
FIN:	MOVEI	D,5
	MOVE	F,buflst-1(D)	;ADDR OF BUFFER RING
	HRROI	B,-1		;END-OF-FILE FLAG
	", OutWord,
  if ForTenex then "
	CLOSF
	 PUSHJ	P,ERR" else "
	XCT	4(F)		;and release channel","
	SOJG	D,FIN+1		;FOR EACH FILE",
  if ForTenex then "
	HALTF

ERR:	HRROI	1,[ASCIZ /ERROR!/]
	PSOUT
	JRST	ERR-1
" else "
	EXIT

WORD:	SOSG	2(F)	;DECR CHR COUNT
	XCT	3(F)	;NO ROOM. DO OUT
	JRST	WORD1
	HALT	.
WORD1:	IDPB	B,1(F)
	POPJ	P,

buflst:");
for t_1 step 1 until 5 do CPRINT(baich2, crlf & "	OBUF", t);
for t_1 step 1 until 5 do CPRINT(baich2, "
FDB",t,":	14	;IMAGE MODE
	SIXBIT	/DSK/
	.+1,,0		;OUTPUT BUFFER RING
OBUF",t,":
	BLOCK	3
	OUT	",t,",	;XCT'ED TO WRITE BUFFER
	RELEASE	",t,",	;XCT'ED TO FINISH FILE 

ENT",t,":	SIXBIT /",bailName[t],"/
	SIXBIT	/SM1/
	0
	0
");

CPRINT(baich2, "
$BEGIN:
PDA1__PDA2__PDA3__PDA4__PDA5__1
");


	FOR T_0 STEP 1 UNTIL BUCKLEN DO BUCKET[T]_"0";

	LINENO_ TYPCNT_SYMCNT_COMMAND_EOF_0;
END "Initialization";

SIMPLE BOOLEAN PROCEDURE ISON(STRING A);
BEGIN INTEGER I;
FOR I_1 STEP 1 UNTIL NCOND DO IF EQU(A,CONDWORD[I]) THEN RETURN(TRUE);
for i_1 step 1 until nfcond 
   do if equ(a,falsecondword[i]) then return(false);
outstr(" [defaulting: " & a & " to FALSE] ");
falsecondword[nfcond_nfcond+1]_a;
RETURN(FALSE) 
END;

RECURSIVE STRING PROCEDURE GETWORD;
BEGIN INTEGER BR; 
	COMMAND_0;
	WORD_INPUT(SRC,SUPSPC);
	IF EOF THEN BEGIN
		COMMAND!SCAN;
		WORD_INPUT(SRC,SUPSPC); 
		if eof then usererr(0,1,"Switched to Null File!!");
		WHILE COMMAND=0 and eof=0 DO WORD _ GETWORD ;
		if eof then usererr(0,1,"File with No beginning!");
		RETURN (WORD);
	END;
	WORD_INPUT(SRC,NORSCAN);
	IF EQU (WORD,"MUMBLE") THEN BEGIN
		WHILE eof=0 and WORD neq ";" AND WORD[inf FOR 1] neq ";"
			DO WORD_ GETWORD;
		if eof then usererr(0,1,"Mumbled off the end of file");
		WORD_GETWORD;
	END;
	IF SRCBRK="[" THEN BEGIN COMMENT CONDITIONAL COMPILATION;
		INPUT(SRC,ONESCAN);
		IF ISON(WORD) THEN WORD_GETWORD
		ELSE BEGIN INTEGER CCNT;
		    CCNT_1;
		    DO BEGIN
			INPUT(SRC,CBRK);
			IF SRCBRK="[" THEN CCNT_CCNT+1;
			IF SRCBRK="]" THEN CCNT_CCNT-1 END
		    UNTIL CCNT=0 or eof;
		if eof
		 then usererr(ccnt,2,"C-comp "&word&" off file");
		WORD_GETWORD
		END
	    END;
	IF WORD="<" THEN COMMAND_1;
	RETURN (WORD);
END;


PROCEDURE RESERVED;
BEGIN STRING A;
	A_GETWORD;

	FOR RESCNT_1 STEP 1 WHILE COMMAND=0 DO BEGIN
	RESPRINT[RESCNT]_A;
	RESNUM[RESCNT]_CVO(GETWORD);
	A_GETWORD;
	IF A="C" THEN RESNUM[RESCNT]_-RESNUM[RESCNT];
	A_GETWORD;
	END;
END;

STRING PROCEDURE NXTSYM;
	RETURN("SYM"&CVS(SYMCNT+1));

STRING PROCEDURE GENSYM;
BEGIN
	SYMCNT_SYMCNT+1;
	CURSYM_"SYM"&CVS(SYMCNT);
	RETURN(CURSYM);
END;


INTEGER PROCEDURE HASH(STRING A);
BEGIN
	INTEGER J,HASS;
	HASS_0;
	FOR J_1 STEP 1 UNTIL 5 DO BEGIN
	IF J>LENGTH(A) THEN HASS_(HASS LSH 7) ELSE
	HASS_ (HASS LSH 7)+(A[J FOR 1]);
	END;
	HASS_(HASS LSH 1);
	HASS_((HASS XOR LENGTH(A)) MOD BUCKLEN);
	IF HASS>0 THEN RETURN(HASS) ELSE RETURN(-HASS);
END;


COMMENT Printreserved, Assigned;

PROCEDURE PRINTRESERVED;
BEGIN	INTEGER I,J;
	STRING A,OLDRES;
	OLDRES_"0";
	FOR I _1 STEP 1 UNTIL RESCNT-1 DO BEGIN
		PUTOUT(" ");
		J_HASH(RESPRINT[I]);
		A_BUCKET[J];
		BUCKET[J]_GENSYM;
		PUTOUT(CURSYM&":	XWD "&OLDRES&","&A);
		OLDRES_BUCKET[J];
		PUTOUT("	"&PRINTOCT(LENGTH(RESPRINT[I])));
		PUTOUT("	POINT 7,.+2");
		IF RESNUM[I]<0
		 THEN PUTOUT("	XWD RES+CLSIDX,"&PRINTOCT(-RESNUM[I]))
		 ELSE PUTOUT("	XWD RES,"&PRINTOCT(RESNUM[I]));
		PUTOUT("	ASCIZ/"&RESPRINT[I]&"/");
	  END;
	PUTOUT(OLDRES);
	PUTOUT("^RESEND:");
COMMENT PRINT BUCKET;

	PRINTROOM; PRINTROOM;
	PUTOUT("^MBUCK:	;INITIALIZED BUCKET");
	FOR I_0 STEP 2 UNTIL BUCKLEN-1
	   do PUTOUT("	XWD "&BUCKET[I]&","&BUCKET[I+1]);
END;


PROCEDURE ASSIGN;
BEGIN STRING A,B;
    WHILE COMMAND=0 DO BEGIN
	A_NULL;
	BREAK_0;
	WHILE BREAK neq LF AND COMMAND=0 DO A_A& ( B_GETWORD );
	IF COMMAND=0 THEN PUTOUT(A);
	END;
END;


COMMENT Macros;

PROCEDURE MACROS;
BEGIN "MACROS"
   STRING A, B, NPR, BODY, BODADD;
   INTEGER J, BRF, NUM;

   PROCEDURE OUTBYT(INTEGER BYT);
   BEGIN "OUTBYT"	OWN STRING B;
      IF NUM=0 THEN B_"BYTE (7) " ELSE B_B&",";
      B_B& (IF BYT<'41 or BYT='177 or BYT=""""
		 THEN CVOS(BYT) ELSE """"&BYT&"""");
      NUM_NUM+1;
      IF NUM=15 or BYT=0 THEN BEGIN PUTOUT(B&";"); NUM_0 END
   END "OUTBYT";

   PUTOUT ("; BUILT-IN MACROS");
   WHILE COMMAND = 0 DO BEGIN "A MACRO"
      PRINTROOM;
      A_GETWORD; IF COMMAND THEN DONE;
      NPR_GETWORD;
      BODY_NULL; NUM_0; INPUT(SRC,ONESCAN);
      DO BEGIN "GET BODY"
	BODY_BODY&INPUT(SRC,MACSCAN);
	BRF_SRCBRK;
	INPUT(SRC,ONESCAN);
	IF BRF="?" THEN
	     BODY_BODY&SRCBRK&
		(IF SRCBRK='15 THEN INPUT(SRC,ONESCAN) ELSE NULL)
	   ELSE IF BRF="" THEN BODY_BODY&'177&(SRCBRK-"0")
      END "GET BODY"
       UNTIL BRF=""SRCBRK="0";
      BODADD_GENSYM;
      PUTOUT(BODADD&":	0	;MACRO BODY STRING");
      PUTOUT("	"&PRINTOCT(LENGTH(BODY)));
      PUTOUT("	POINT 7.,.+3");
      PUTOUT("	XWD CNST,STRING		;TBITS");
      PUTOUT("	0			;SBITS");
      while length(body) DO OUTBYT(LOP(BODY));
      PRINTROOM;

      J_HASH(A);
      B_BUCKET[J];  BUCKET[J]_GENSYM;
      PUTOUT (CURSYM&":	XWD	"&BODADD&","&B&"	; HEADER FOR "&A);
      PUTOUT ("	"&PRINTOCT(LENGTH(A)));
      PUTOUT ("	POINT 7,.+6");
      PUTOUT ("	XWD DEFINE,0");
      PUTOUT ("	0");
      PUTOUT ("	0");
      PUTOUT ("	0");
      PUTOUT ("	XWD	"&NPR&",0");
      PUTOUT ("	ASCII	/"&A&"/")
   END "A MACRO"
END "MACROS";

PROCEDURE COND;
BEGIN 
    do CONDWORD[NCOND_NCOND+1]_ getword until command;
    condword[ncond]_0; ncond_ncond-1;
END;


PROCEDURE FALSECOND;
BEGIN 	integer i,j;
    do FALSECONDWORD[NFCOND_NFCOND+1]_ getword until command;
    falsecondword[nfcond]_0; nfcond_nfcond-1;
    for i_ 1 step 1 until ncond
	do for j_ 1 step 1 until nfcond
	   do if equ(condword[i],falsecondword[j])
		then outstr("***"&condword[i]&" is false and true***");
END;
COMMENT Functions;

PROCEDURE FUNCTIONS;
BEGIN
   INTEGER J,PAR,I,EXTREF;	INTEGER NVSTRPAR,NPDA,BRCHAR,BCH;
   STRING FIRVARB,CURVARB,A,C,VARBLOW,PREVARB,B,TYPE,BILTIN,QQ,D,E;
   STRING XXY;	 STRING BTSTR;
   PUTOUT ("; FUNCTION SYMBOL TABLE ENTRIES");
   PUTOUT("^IPROC:");
   PREVARB _ "0";
   WHILE COMMAND=0 DO BEGIN "A FUNCTION"
      EXTREF_FALSE;
      PRINTROOM;
      E_A_GETWORD;
      IF COMMAND=0 THEN BEGIN "FUN"
	 TYPE_GETWORD; BILTIN _ GETWORD; IF EQU(BILTIN[INF-5 FOR 6],"FNYNAM") THEN E_E&"$";
	 D_NULL; WHILE LENGTH(E) DO BEGIN
	    D_D&SCAN(E,FBRK,BRCHAR); IF BRCHAR="!" OR BRCHAR="" THEN D_D&"." END;
	 J_HASH(A);
	 B_BUCKET[J];
	 BUCKET[J]_GENSYM;
	 CURVARB_CURSYM;
	 IF A="." THEN BEGIN "PROVIDE NAMED ACCESS TO THIS SEMBLK"
	    PUTOUT("^"&A&":"); COMMENT FOR .LOP. ETC;
	    A_A[2 TO ];
	 END;
         XXY_GETWORD; IF XXY="X" THEN BEGIN "EXTERN TOO"
	    PUTOUT("EXTERNAL "&A); EXTREF_TRUE; XXY_XXY[2 TO ]
	 END "EXTERN TOO";
	 PAR_CVD(XXY); NVSTRPAR_CVD(GETWORD); BCH_CVD(GETWORD);
	 PUTOUT(CURSYM&":	"&B&"	;HEADER FOR "&A);
	 PUTOUT("	"&PRINTOCT(LENGTH(A)));
	 PUTOUT("	POINT 7,.+"&
	   (IF EQU(A,"M") THEN "11" ELSE IF PAR  10000 THEN "10" ELSE "4"));

	IF BCH NEQ 0 THEN CPRINT(BCHPD[BCH],"


	EXTERNAL ",D,"
	0
	LINK	PDLNK,.-1
	,",D,"
	",CVOS(LENGTH(A)),"
	POINT	7,[ASCII/",A,"/]
	REFB+PROCB+"&TYPE&"
	XWD	2*",CVOS(NVSTRPAR),",",CVOS(PAR-NVSTRPAR+1),"
	0
	0
	XWD	0,.+4
	XWD	.-10,0
	XWD	",D,",0
	XWD	",D,",0");

	IF BCH NEQ 0 THEN CPRINT(BAICH2,"

	",BCH,"
	4
	400000+",CVOS((LENGTH(A)+4)%5),"
	XWD	777777,0
	XWD	BBLTPRC+",TYPE,",PDA",BCH,"
	ASCII	/",A,"/
PDA",BCH,"__PDA",BCH,"+14+",CVOS(PAR),"
	0");



	 IF PAR > 10000 THEN BEGIN "SOME SORT OF SPECIAL GLITCH"
	    PUTOUT("	XWD "&BILTIN&","&TYPE);
	    PUTOUT("	00");
	    PUTOUT("	ASCII/"&A&"/");
	    J_(LENGTH(A)+4)%5;
	    PUTOUT("	BLOCK "&PRINTOCT(3-J));
	 END ELSE BEGIN "REGULAR FUNCTION"
	    STRING PARSTR; INTEGER I,ZZ;
	    PUTOUT("	XWD	EXTRNL+"&BILTIN&",PROCED+FORWRD+"
		      &TYPE);
	    PUTOUT("	0");
	    QQ_NULL;
	    FOR I_1 STEP 1 UNTIL LENGTH(A) DO
		  QQ_QQ&(IF (ZZ_A[I FOR 1])=
		 "" THEN "." ELSE ZZ);
	    IF EXTREF THEN
	       PUTOUT("	XWD 0+"&QQ&",IFN DCS,<0+"&QQ&" ;>0 ")
	    ELSE 
	       PUTOUT("	IFN DCS,<0+"&QQ&" ;>0 ");
	    PARSTR_"	BYTE (6) ";	BAITSTR_NULL;
	    FOR I_1 STEP 1 UNTIL PAR DO BEGIN "ONE PARAM"
		INTEGER DFVFLG;
		DFVFLG_0;
	       B_GETWORD ; COMMENT SWINEHART'S DUMMY;
	       B_GETWORD ; COMMENT DESCRIPTOR;
	       TEMPSTR_GETWORD;
		IF TEMPSTR="$" THEN
			BEGIN
			DFVFLG_'40;
			TEMPSTR_GETWORD;
			END;
		PARM_(BTSTR_GETWORD) &","& TEMPSTR;
		IF LENGTH(TEMPSTR)>6 THEN TEMPSTR_"UNTYPE";
		IF DFVFLG THEN TEMPSTR_"DEFLT+$DFLT$+" & TEMPSTR;
		IF BCH NEQ 0 THEN CPRINT(BCHPD[BCH],"
	0+",TEMPSTR,"+",BTSTR);
	       TYPARAM_0;
	       FOR J_1 STEP 1 UNTIL TYPCNT DO BEGIN "MATCH TYPES"
		  IF EQU(PARAMS[J],PARM) THEN BEGIN
			  TYPARAM_J;DONE; END;
	       END;
	       IF 0=TYPARAM THEN PARAMS[TYPCNT_TYPARAM_TYPCNT+1]_PARM;
	       PARSTR _ PARSTR&CVOS(TYPARAM+DFVFLG)&",";

	    END "ONE PARAM";
	    PUTOUT(PARSTR&"0");

	    PUTOUT("	BLOCK	"&CVS(3-((PAR+6)%6)));
	 END; "REGULAR FUNCTION";
	 C _ NXTSYM;
	 PUTOUT("	XWD "&C&","&PREVARB&"");
	 IF EQU(A,"M") THEN PUTOUT("	0");
	 IF PAR < 10000 THEN 
	     PUTOUT("	ASCII /"&A&"/");
	 PREVARB _ CURSYM ;
         PRINTROOM;
      END "FUN"
   END "A FUNCTION";
   PUTOUT ("^BLTTBL_.-1");
   FOR I_1 STEP 1 UNTIL TYPCNT DO PUTOUT("XWD "&PARAMS[I]);
   PUTOUT(NXTSYM&"__0");
	C_GENSYM;
END "FUNCTIONS";


COMMENT Defin; 

PROCEDURE DEFIN;
BEGIN
PRINTROOM;
WHILE true
   DO BEGIN	STRING A; INTEGER I;
	A_GETWORD;
	if command or eof then return;
	FOR I_1 STEP 1 UNTIL RESCNT-1
	 DO IF EQU(A,RESPRINT[I]) THEN BEGIN
		PUTOUT("^R" & ((A & "     ")[1 FOR 5])
		    & (IF RESNUM[I]=0 THEN "__CLASOP+" ELSE "__OPER+") 
		    & PRINTOCT(RESNUM[I]) );
		done;
	      END;
      END;
END;

COMMENT Main Loop; 

STRING TEM1,TEM2;
ON!ETIME_FALSE;
WHILE TRUE DO BEGIN "EXEC" 
	STRING A;

	INITIALIZATION;
	PUTOUT("SUBTTL	INITIAL SYMBOL TABLE");
	PUTOUT("BEGIN	RESTAB");
	PUTOUT("IFNDEF DCS,<DCS __ 0>");
	PUTOUT("^RESYM:");
	PUTOUT("LSTON(SMTB)");
	WHILE EOF = 0 AND EQU(WORD,"<END>")=0
	   do begin
		WHILE COMMAND=0 DO A_GETWORD;
		COMMAND_0;
		IF EQU(WORD,"<TRUECONDITIONALS>") THEN COND;
		IF EQU(WORD,"<FALSECONDITIONALS>") THEN FALSECOND;
		IF EQU(WORD,"<RESERVED-WORDS>") THEN RESERVED;
		IF EQU(WORD,"<FUNCTIONS>") THEN FUNCTIONS;
		IF EQU(WORD,"<MACROS>") THEN MACROS;
		IF EQU(WORD,"<DEFINITIONS>") THEN DEFIN;
		IF EQU(WORD,"<ASSIGN>") THEN ASSIGN;
	      END;
	PRINTRESERVED;

	CPRINT(BCHPD[2],";SOME PROCEDURES NORMALLY COMPILED INLINE

	0		;WORD FOR PROCEDURE DESCRIPTOR LINK
	LINK	PDLNK,.-1
	..LDB		;ENTRY ADDRESS
	3		;SAIL STRING DESCRIPTOR FOR NAME
	POINT	7,[ASCII/LDB/]
	REFB+PROCB+INTEGR	;TYPE OF PROCEDURE
	XWD	0,2	;STRING PARAMS*2,,ARITH PARAMS+1
	0		;SS DISPL,,AS DISPL
	0		;LEX LEV,,LOCAL VAR INFO
	XWD	0,.+4	;DISPL LEV,,PNTR TO PARAM INFO
	XWD	.-10,0	;PDA,,0
	XWD	..LDB,0	;PCNT AT END OF MKSEMT,,PARENTS PDA
	XWD	..LDB,0	;PCNT AT PRDEC,,LOC FOR JRST EXIT
	0+INTEGR+VALUE	;TYPE BITS FOR PARAMETER

	0
	LINK	PDLNK,.-1
	..ILDB
	4
	POINT	7,[ASCII/ILDB/]
	REFB+PROCB+INTEGR
	XWD	0,2
	0
	0
	XWD	0,.+4
	XWD	.-10,0
	XWD	..ILDB,0
	XWD	..ILDB,0
	0+INTEGR+REFRNC


	0
	LINK	PDLNK,.-1
	..IBP
	3
	POINT	7,[ASCII/IBP/]
	REFB+PROCB
	XWD	0,2
	0
	0
	XWD	0,.+4
	XWD	.-10,0
	XWD	..IBP,0
	XWD	..IBP,0
	0+INTEGR+REFRNC


	0
	LINK	PDLNK,.-1
	..DPB
	3
	POINT	7,[ASCII/DPB/]
	REFB+PROCB
	XWD	0,3
	0
	0
	XWD	0,.+4
	XWD	.-10,0
	XWD	..DPB,0
	XWD	..DPB,0
	0+INTEGR+VALUE
	0+INTEGR+REFRNC


	0
	LINK	PDLNK,.-1
	..IDPB
	4
	POINT	7,[ASCII/IDPB/]
	REFB+PROCB
	XWD	0,3
	0
	0
	XWD	0,.+4
	XWD	.-10,0
	XWD	..IDPB,0
	XWD	..IDPB,0
	0+INTEGR+VALUE
	0+INTEGR+REFRNC
P__17
TEMP__14
	INTERNAL ..LDB,..ILDB,..DPB,..IDPB,..IBP
	EXTERNAL X22,X33
..LDB:	LDB	1,-1(P)
..RET2:	SUB	P,X22
	JRST	@2(P)
..ILDB:	ILDB	1,@-1(P)
	JRST	..RET2
..IBP:	IBP	  @-1(P)
	JRST	..RET2
..DPB:	MOVE	TEMP,-2(P)
	DPB	TEMP,-1(P)
..RET3:	SUB	P,X33
	JRST	@3(P)
..IDPB:	MOVE	TEMP,-2(P)
	IDPB	TEMP,@-1(P)
	JRST	..RET3
");

OUT(BAICH2,"
OR THE FAKE RUNTIMES
	2		;'MAJOR IO' FILE
	4		;PROCEDURE INFO COMING
	400000+1	;FLAG+ NUMBER OF WORDS IN NAME
	XWD	777777,0	;THIS WORD IGNORED BY BAIL'S LOADER
	XWD	BBLTPRC+INTEGR,PDA2	;TYPE BITS,,ADDR OF PDA IN BAIPDn FILE
	ASCII	/LDB/	;NAME
	0
PDA2__PDA2+14+1

	2
	4
	400000+1
	XWD	777777,0
	XWD	BBLTPRC+INTEGR,PDA2
	ASCII	/ILDB/
	0
PDA2__PDA2+14+1

	2
	4
	400000+1
	XWD	777777,0
	XWD	BBLTPRC,PDA2
	ASCII	/IBP/
	0
PDA2_PDA2+14+1

	2
	4
	400000+1
	XWD	777777,0
	XWD	BBLTPRC,PDA2
	ASCII	/DPB/
	0
PDA2__PDA2+14+2

	2
	4
	400000+1
	XWD	777777,0
	XWD	BBLTPRC,PDA2
	ASCII	/IDPB/
	0			;END OF FAKIRS
PDA2__PDA2+14+2
");

	TEM1_"
	0
$DFLT$:	0

	0
	LINK	BALNK,.-1
	XWD	$BEGIN,$BEGIN
";

	TEM2_"
	-1
	END
";
BEGIN "UGHFAIL"
SIMPLE STRING PROCEDURE F(STRING A); RETURN("
	sm1ppn
IFNDEF GTJFN,<
	SIXBIT	/"&A&"/
>;IFNDEF GTJFN
IFDEF GTJFN,<
	ASCII	/<SAIL>"&A&".SM1/
>;IFDEF GTJFN
");

	CPRINT(BCHPD[1],TEM1,F("BAICLC"),TEM2);
	CPRINT(BCHPD[2],TEM1,F("BAIIO1"),TEM2);
	CPRINT(BCHPD[3],TEM1,F("BAIIO2"),TEM2);
	CPRINT(BCHPD[4],TEM1,F("BAIMSC"),TEM2);
	CPRINT(BCHPD[5],TEM1,F("BAIPRC"),TEM2);
END "UGHFAIL";

	RELEASE(BCHPD[1]); RELEASE(BCHPD[2]); RELEASE(BCHPD[3]);
	RELEASE(BCHPD[4]); RELEASE(BCHPD[5]);

	OUT(BAICH2,"
	-1
	END	START
");
	RELEASE(BAICH2);

	PUTOUT("BEND	RESTAB");
  END "EXEC";

END "RTRAN";

=*