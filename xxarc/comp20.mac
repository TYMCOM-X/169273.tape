TITLE COMPILE V20 -- CCL CONTROL CUSP
;PROGRAM TO COMPILE, LOAD, EXECUTE AND DEBUG USER PROGRAMS
SUBTTL WEIHER/CLEMENTS/RCC/PMH/NGP/DMN - 3-DEC-71

VCOMPIL==20
VUPDATE==0			;DEC UPDATE LEVEL
VEDIT==40			;EDIT LEVEL
VCUSTOM==0			;NON-DEC UPDATE LEVEL

;THE ORIGINAL VERSION OF
;THIS PROGRAM WAS WRITTEN AT THE STANFORD UNIVERSITY
;ARTIFICIAL INTELLIGENCE LABORATORY BY WILLIAM F. WEIHER.
;MR. WEIHER'S COOPERATION, AND THAT OF THE A-I LABORATORY,
;ARE GRATEFULLY ACKNOWLEDGED.
;
;CONVERTED TO MACRO SOURCE LANGUAGE FROM FAIL ON
;1 NOVEMBER 68 BY R CLEMENTS

INTERN VCOMPILE,.JBVER	;FOR LOADER MAP AND LIBRARY

LOC	<.JBVER==137>
	<VCUSTOM>B2+<VCOMPIL>B11+<VUPDATE>B17+VEDIT
RELOC	0

IFNDEF TEMP,<TEMP==1>		;TEMP=1 ALLOWS THE TMPCOR UUO TO BE USED

IFNDEF RUNSW,<RUNSW==1>		;NON-ZERO TO USE THE RUN UUO
IFNDEF PURESW,<PURESW==1>	;NON-ZERO FOR A SHARED VERSION OF COMPIL
IFNDEF SYSSW,<SYSSW=0>		;NON ZERO USES DSK [1,1] FOR RUNS

IFNDEF STANSW,<STANSW=0>	;NON-ZERO TO INCLUDE STANFORD FEATURES
IFNDEF LSTRSW,<LSTRSW=0>	;NON-ZERO TO USE "LISTER" INSTEAD OF PIP
				;FOR TYPE AND LIST COMMANDS
IFNDEF SAVEXT,<SAVEXT=<SIXBIT /   SAV/>>	;USE DMP FOR PDP6'S
IFE SYSSW,<SYSDEV=<SIXBIT /SYS/>>
IFN SYSSW,<SYSDEV=<SIXBIT /DSK/>>	;USE DSK [1,1]
IFNDEF FASTFS,<FASTFS=0>	;FASTEST FILE STRUCTURE
				;IF ZERO COMPIL WILL FIND IT AT RUN TIME


IFNDEF DIRSW,<DIRSW==0>	;USE DIRECT CUSP IF NON-ZERO

IFNDEF SNOBOL,<SNOBOL==0>	;ACCEPT SNOBOL AS A COMPILER
IFNDEF MACX11,<MACX11==0>	;ACCEPT MACX11 (PDP-11) ASSEMBLER
IFNDEF BLISS,<BLISS==0>		;ACCEPT BLISS COMPILER
;ACS
P=17		;PUSHDOWN POINTER
C=16		;CHARACTERS RETURNED HERE
CS=15		;CHARACTER STATUS BITS HERE
SVPT=14		;POINTER TO CURRENT FILE IN LIST OF FILES (AOBJN)
SWPT=13		;BYTE POINTER INTO SWITCH STORAGE AREA
SWCNT=12	;NUMBER OF BYTES LEFT FOR SWITCH STORAGE
FL3=11		;FLAG REGISTER (LEFT HALF IS GLOBAL SWITCHES)
FL2=10		;FLAG REGISTER (LEFT HALF INDICATES PROCESSOR)
IOP=7		;PDL FOR INPUT NESTING
IOPNT=6	;POINTER TO CURRENT INPUT FILE

T5=5		;USED IN OUTPUT ROUTINES ONLY (DMN)
T4=4		;TEMPORARY ACCUMS
T3=3
T2=2
T1=1
FL=0		;FLAG REGISTER (LEFT HALF LOCAL SWITCHES)
		;(RIGHT HALF MISC BITS)

IFN PURESW,<IFE RUNSW,<
PRINTX ;ASSEMBLY SWITCHES CONFLICT>>

	SALL	;SUPPRESS ALL MACROS AND REPEATS

	MLON
;FLAGS (RH OF FL)

PROCS==1	;PROCESSOR SWITCHES SEEN
DOLOD==2	;WE WANT TO DO LOADING
PCM1==4		;FIRST COMMA SEEN IN PROCESSOR SWITCHES
PCM2==10	;SECOND COMMA SEEN
IDF==20		;SCAN SAW AN IDENTIFIER
LODOUT==40	;SOME OUTPUT HAS BEEN DONE TO LOADER
PERF==200	;PERMANENT TYPE FLAGS
MAPST==400	;A MAP DEVICE HAS BEN GENERATED FOR LOADER
CMDSN==1000	;THE COMMAND SHOULD BE WRITTEN AS SVC OR EDS
INCRF==2000	;WE ARE FINISHING CREF OUTPUT
INPRNT==4000	;WE ARE PRINTING A CHARACTER STRING IN ERROR MSG
PIPF==10000	;DOING SOMETHING FOR PIP
EDITF==20000	;IN EDIT OR CREATE
CREATF==40000	;CREATE
FFLG==PCM1	;/F FLAG IN DIRECTORY COMMAND
LPTFG==PCM2	;/L FLAG IN DIRECTORY COMMAND
NODAT==PCM1	;FILE FROM OTHER THAN DSK
NOLOOK==PCM2	;LOOKUP FAILED
TECOF==100000	;WE WANT TECO
RECALF==200000	;WE ARE READING A COMMAND SAVE FILE


;FLAGS (SWITCH TYPE)
LISTSW==1	;DO LISTING
CRSW==2		;DO A CREF
LIBSW==4	;DO A LIBRARY SEARCH OF THIS FILE
RELSW==10	;DO A LOAD ONLY ON THIS FILE
COMPLS==20	;COMPILE REGARDLESS OF DATES
MAP1==40	;MAP SWITCH SEEN MAP_ NOT GENERATED
MAP2==100	;MAP SWITCH SEEN MAP_ GENERATED
MAPL==200	;LOCAL MAP SWITCH SEEN /1M TO BE OUTPUT
FUDGSW==400	;DO A FUDGE (PIP UNTIL FUDGE2 ACCEPTS CCL)

PDL==40	;LENGTH OF PDL
SWBK==5	;NUMBER OF WORDS FOR SWITCHES TO PROCESSOR
LODSCT==10	;NUMBER OF LOADER SWITCHES PER FILE ALLOWED
REPEAT 0,< THE MACRO PROCESS DEFINES DETAILS ABOUT THE VARIOUS
	PROCESSORS WHICH COMPILE IS EXPECTED TO HANDLE BY CALLING
	THE MACRO X WHICH IS REDEFINED TO PRODUCE THE INFORMATION REQUIRED.
	THE ARGUMENTS ARE SWITCH NAME,EXTENSION,PROCESSOR NAME
	<OPTIONAL>EXTENSION OF NEXT PROCESSOR IF MUST BE PROCESSED MORE
	THAN ONCE (AS COBOL),EXTENSION PRODUCED

	USE F4 OR F40 AS APPROPRIATE FOR THE SYSTEM
>

DEFINE PROCESS<
X FORTRAN,F4,F40
X MACRO,MAC,MACRO
X COBOL,CBL,COBOL
X ALGOL,ALG,ALGOL
IFN SNOBOL,<X SNOBOL,SNO,SNOBOL>
IFN MACX11,<X MACX11,P11,MACX11>
IFN BLISS,<X BLISS,BLI,BLISS>
IFN STANSW,<X FAIL,FAI,FAIL>
>

;DEFINE VARIOUS BITS

ALPROC==RELSW	;OR OF BITS FOR ALL THE PROCESSORS
NPROCS==0	;NUMBER OF PROCESSORS
FCHLOD==400000	;LOADER CHANNEL HAS BEEN INITED
CHN==17		;USED TO DEFINE CHANNEL NUMBER
SPRC==0		;BITS FOR THOSE PROCESSORS WHICH OUTPUT TO ANOTHER

DEFINE X (A,B,C,D,E)<
B'SW==FCHLOD	;PROCESSOR BIT
IFDIF <D><>,<SPRC==SPRC!FCHLOD>
ALPROC==ALPROC!FCHLOD
NPROCS==NPROCS+1
FCH'B==FCHLOD
CHN'B==CHN	;CHANNEL NUMBER
CHN==CHN-1
FCHLOD==FCHLOD_-1>
PROCESS
CHNLOD==CHN
CHNLST==CHN
FCHLST==FCHLOD
CHNEDT==CHN
FCHEDT==FCHLOD
CHNPIP==CHN-2
FCHPIP==FCHLOD_-2
CHNCRF==CHN-1		;CREF OUTPUT CHANNEL
FCHCRF==FCHLOD_-1
LOOK==0		;CHANNEL FOR DOING LOOKUPS FOR INFORMATION
NFILE==^D40	;NUMBER OF FILES PERMITTED IN A + CONSTRUCTION
MAXNST==17	;MAXIMUM NESTING DEPTH TO PERMIT
NESTDP==CHN-3	;MAXIMUM NESTING DEPTH POSSIBLE WITH THESE PROCESSORS
IFG NESTDP-MAXNST,<NESTDP==MAXNST>	;PICK SMALLER

EXTERN	.JBFF,.JBREL,.JBERR

IFN PURESW,<	TWOSEGMENTS
.ZZ:
	RELOC	400000>

OPDEF	STRING	[TTCALL	3,]

DEFINE SKIP (J)<JRST .+1+'J>

;MACROS FOR THE DATA STORAGE IN PURE AND IMPURE VERSIONS

DEFINE WORDS(A)<
IRP A,<
U(A,1)>>

IFE PURESW,<
DEFINE U(A,B)<
A:	BLOCK B>>

IFN PURESW,<
DEFINE U(A,B)<
	RELOC
A:	BLOCK B
	RELOC>>
IFE RUNSW,<
NUNPNT==6
NUNTOP==7
EXTERN	.JBDDT,.JBSA,.JBS41,.JBCOR

OFFSET==INHERE-74

NUNCOM:	IOWD 0,INHERE
	0
NUNGO2:	CALLI 15,11	;GET PROPER CORE SIZE
	JRST NOCOR	;LOSE
	IN 1,NUNCOM	;GET IT
	JRST NUNGO3	;OK
NUNERR:	CALLI NUNPNT,3	;WE LOSE, PRINT ERROR
	CALLI 12
NUNERM:	ASCIZ #?LINKAGE ERROR - I/O#
NUNGO3:	SKIPE 12,OFFSET+.JBCOR	;GET JOBCOR
	CAMG 12,.JBREL	;AND SEE IF WE SHOULD EXPAND
	JRST NUNGO4	;NO, START THE BLT
	MOVEI NUNPNT,NUNCER
	CALLI 12,11	;YES, DO IT
	JRST NUNERR	;LOSE
	MOVE 12,OFFSET+.JBS41	;RESET 41
	MOVEM 12,41
	JRST NUNGO4	;WIN
NUNCER:	ASCIZ /?CORE NEEDED/
INHERE:

NUNAC:	PHASE 0	;THE CODE TO GO IN THE ACS
NUNGO4:	MOVE 12,OFFSET+.JBDDT	;SET JOBDDT
	CALLI 12,2
NUNBLT:	BLT NUNTOP,0
	CALLI	;RESET THE WORLD
	AOS 1,.JBSA	;GET STARTING ADDRESS
	JRST (1)
	NUNERM
	XWD INHERE+1,75	;THE BLT WORD
DEPHASE
>
MOUNT:	SKIPA	T1,['UMOUNT']	;RUN MOUNT CUSP
RUNAME:	MOVE	T1,COMTAB(T1)	;GET NAME OF CUSP TO RUN
	SETZ	T2,
	JRST	NUNDO+1		;START AT NORMAL ENTRY

CREFIT:	SKIPA	T1,[SIXBIT /CREF/]
FUDGIT:	MOVSI	T1,'PIP'
NUNDO:	MOVSI	T2,1	;START ADDR PLUS ONE
	MOVEM T1,NAME	;SET NAME
	CALLI		;RESET THINGS
IFE SYSSW,<	SETZM	NAME+3>
IFN SYSSW,<	MOVE T1,[XWD 1,1]
	MOVEM	T1,NAME+3	;CUSPS FROM DSK [1,1]>
IFE PURESW,<SETZM NAME+4	;CLEAR CORE ARG>
IFN RUNSW,<
	MOVSI	T1,(SYSDEV)	;GET SYS DEVICE
	MOVEM	T1,RUNBLK	;INTO RUN UUO DATA BLOCK
	SETZM NAME+1	;LET MONITOR SUPPLY SAV OR SHR
	HRRI	T2,RUNBLK	;ARGUMENTS
	CALLI	T2,35	;RUN UUO
	MOVEI	FL,0		;ACS ARE GONE
	MOVE	P,PDP
	STRING	[ASCIZ /?LINKAGE ERROR - RUN UUO
/]
	JRST	NOFIL		;TRY TO GIVE FILE-NAME
>
IFE RUNSW,<
NORUN:	INIT 1,16	;GET A DSK IN DUMP MODE
	EXP SYSDEV	;SIXBIT SYS OR DSK
	0
	JRST DSKNA
	MOVSI T1,SAVEXT		;SIXBIT FOR SAVE OR DMP.
	MOVEM T1,NAME+1
	LOOKUP 1,NAME
	JRST NOFIL
	MOVE T1,NAME	;SET NAME OF NEW PROCESSOR
	CALL T1,[SIXBIT /SETNAM/]
	HLRO 15,NAME+3	;GET COUNT
	HRLM 15,NUNCOM
	MOVNS 15	;MAKE POSITIVE
	MOVEI 16,73(15)	;GET END
	ADDI 15,INHERE	;CHECK CORE SIZE
	IORI 15,1777
	MOVSI NUNTOP,NUNAC
	BLT NUNTOP,NUNTOP	;GET ACS LOADER
	HRR NUNBLT,16	;AND SET END OF BLT
	JRST NUNGO2
>
TERMF==200000
NUMF==100000
SPCF==400000
SPACT==40000	;SPECIAL ACTION TO BE TAKEN ON CHAR

SCANAM:	PUSHJ	P,SCAN		;GET NEXT CHAR. FIRST
GETNAM:	SETZM SVNAM(SVPT)	;ZERO OUT CELLS IN CASE NOTHING
	SETZM SVEXT(SVPT)	;GETS PUT THERE
	SETZM SVPPN(SVPT)
	SETZM SWBKS(SVPT)
	SETZM SVDEV(SVPT)
	TRNN FL,IDF		;WAS THE THING SCANNED AN IDENT
	JRST SYNERP	;NO, LOSE UNLESS A PIP COMMAND
	PUSH P,ACCUM
	PUSHJ P,SCANS	;CHECK FOR EXT OR PPN
	CAIE C,":"	;IS IT A DEVICE NAME
	JRST NODEV	;NO
	POP P,SVDEV(SVPT)	;WE WERE HIDING IT IN THE STACK
	PUSHJ P,SCAN	;BYPASS
	PUSHJ P,SCAN	;AND GET NEXT
	CAIN	C,"["	;CHECK FOR PROJ-PROG
	PUSHJ P,[PUSHJ P,GETPPN+1
		JRST	SCAN]	;POPJ RETURN
	TRNN FL,IDF	;MUST BE AN IDENT
	POPJ	P,	;RETURN, ONLY DEVICE SEEN
	PUSH P,ACCUM
	PUSHJ P,SCANS
NODEV:	POP P,SVNAM(SVPT)
	CAIN C,"["	;IS IT PPN
	JRST GETPPN
	CAIE C,"."	;NO, EXT?
	POPJ P,		;NEITHER, RETURN
	PUSHJ P,SCAN	;NO. GO OVER DOT
	PUSHJ P,SCANS	;PEEK AT NEXT CHAR
	SKIPG SAVCHR	;ALPHANUMERIC?
	JRST	GETN1	;NO. IT MAY BE A STAR IN PIP MODE
GETN2:	PUSHJ P,SCAN	;GET EXT
	TRNN FL,IDF
	JRST SYNERR
	MOVE T1,ACCUM
	HLLZM T1,SVEXT(SVPT)
	PUSHJ P,SCANS
	CAIE C,"["	;CHECK FOR PPN AGAIN
	POPJ P,
	JRST	GETPPN	;READ PROG-PROG PAIR

GETN1:	TRNE	FL,PIPF	;PIP MODE?
	CAIE	C,52	;YES. ASTERISK?
	POPJ	P,0	;NO. NULL EXTENSION.
	JRST	GETN2	;WILD EXTENSION. GO GET IT.
GETPPN:	PUSHJ P,SCAN
	PUSHJ P,SCAN
	TRNN FL,IDF
	JRST SYNERR
	MOVE T1,ACCUM
	PUSHJ P,RJUST	;THIS NEED TO BE RIGHT JUSTIFIED
	HRLM T1,SVPPN(SVPT)	;STORE LEFT HALF
	PUSHJ P,SCAN
	CAIE C,","
	JRST SYNERR
	PUSHJ P,SCAN
	TRNN FL,IDF
	JRST SYNERR
	MOVE T1,ACCUM
	PUSHJ P,RJUST
	HRRM T1,SVPPN(SVPT)
	PUSHJ P,SCAN
	CAIN C,"]"
	POPJ P,		;ALL DONE
	TLNN	CS,TERMF	;END OF LINE?
	JRST	SYNERR		;NO
	MOVEI	C,"]"		;FAKE CLOSING  BRACKET
	MOVEM	CS,SAVCHR	;SEE TRMF NEXT TIME
	POPJ	P,		;RETURN

	IFN STANSW,<
RJUST:	TRNE T1,77
	POPJ P,	;GET IT OVER THERE
	LSH T1,-6
	JRST RJUST>

IFE STANSW,<
RJUST:	PUSH	P,T3
	MOVE T3,T1	;CONVERT SIXBIT TO OCTAL
	MOVEI T1,0
CONVOC:	MOVEI T2,0
	LSHC T2,6
	CAIL T2,20
	CAILE T2,27
	JRST SYNERR
	LSH T1,3
	IORI T1,-20(T2)
	JUMPN T3,CONVOC
	POP	P,T3
	POPJ P,0
>
SCANS:	MOVNI T1,1	;FLAG AS NOTHING SEEN YET
	SKIPN CS,SAVCHR	;CHARACTER WAITING?
SCNS2:	PUSHJ P,GETCH
	JUMPN CS,SCNS1	;FOUND SOMETHING
	MOVEI T1,0
	JRST SCNS2
SCNS1:	JUMPL CS,SCNS4	;SPECIAL CHARACTER
	MOVEM CS,SAVCHR	;SAVE THAT CHARACTER
	JUMPL T1,SCNS3	;DO NOTHING ELSE IF NO BLANKS SEEN
	MOVEM T1,SAVCHR	;IF BLANKS SEEN, SAVE ONE
	MOVSI T1,70000
	ADDM T1,@GETB3(IOPNT)	;AND BACK UP POINTER
SCNS3:	TDZA CS,CS	;IN EITHER CASE, RETURN 0
SCNS4:	MOVEM CS,SAVCHR	;SAVE SPECIAL CHARACTER
	HRRZ C,CS		;GET A CHARACTER TO RETURN
	POPJ P,
SCAN:	TRZ FL,IDF	;RESET IN CASE NOT
	SKIPN CS,SAVCHR	;WAS THERE SOMETHING LEFT OVER
CONSN:	PUSHJ P,GETCH	;NO, GET ANOTHER
	JUMPE CS,.-1	;IGNORE BLANKS
	JUMPL CS,SPCHR	;IS IT A SPECIAL CHARACTER
	SETZM ACCUM	;PREPARE TO STORE IT
	MOVE T1,[POINT 6,ACCUM]
SCAN1:	TLNE T1,770000	;ALL SIX STORED?
	IDPB CS,T1	;NO, STORE ANOTHER
	PUSHJ P,GETCH	;GET NEXT
	JUMPG CS,SCAN1	;ANOTHER ALPHA
	TRO FL,IDF	;IT SURE IS
	MOVEM CS,SAVCHR
	SETZB C,CS	;TO AVOID CONFUSION
	POPJ P,
SPCHR:	HRRZ C,CS	;RETURN HIM THE HALF OF IT
	SETZM SAVCHR	;NOTHING SAVED BY NOW
	CAIN C,"*"
	TRNN FL,PIPF
	JRST SPCHR1
	PUSH P,[SIXBIT /*/]	;IN PIP MODE * IS AN IDENT
	POP P,ACCUM
	TROA FL,IDF
SPCHR1:	TLNN CS,SPACT	;DO WE WANT SPECIAL ACTION?
	POPJ P,		;NO
	JRST (CS)	;YES, RH IS DISPATCH
;GETCH RETURNS 7-BIT ASCII CHAR IN C, TABLE ENTRY IN CS

GETCH:	SOSLE @GETB1(IOPNT)	;USE CORRECT BUFFER HEADER
	JRST OKPICK
IFN TEMP,<	MOVE C,TMPFLG(IOPNT)	;IS TMPCOR BEING USED
	CAMN C,[-1]		;SET TO -1 IF YES
	JRST [SETZM TMPFLG(IOPNT)	;CLEAR TMPFLAG
		JRST POPFIL+1]		;YES FINISHED WITH THIS READ>
	XCT GETB2(IOPNT)	;AN IN UUO
	JRST	OKPICK
	XCT GETB4(IOPNT)	;TO A STATZ
	JRST READER	;AN INPUT ERROR
	JRST POPFIL	;GO GET PREVIOUS FILE

OKPICK:	IBP @GETB3(IOPNT)
	MOVE C,@GETB3(IOPNT)	;PICK UP THE NEW BYTE POINTER
	MOVE CS,(C)	;GET THE WORD IT CAME FROM
	TRNE CS,1	;AND CHECK FOR SEQ NUM
	JRST 	[AOS @GETB3(IOPNT)	;ADVANCE POINTER
		MOVNI CS,5	;AND ADJUST COUNT
		ADDB CS,@GETB1(IOPNT)
		SKIPG CS	;CHECK FOR BUFFER OVERRUN
		PUSHJ P,GETCH	;GET RID OF TAB
		JRST GETCH]
	LDB C,@GETB3(IOPNT)
	JUMPE C,GETCH	;IGNORE NULLS
	CAIN	C,";"	;IS IT A COMMENT?
	TRNE	FL,INPRNT	;IN PRINTING ERROR
	JRST	EOFRT	;YES, DONT PROCESS ";"
SEMIC:	TRO	FL,INPRNT	;HACK SO THAT "@" COME HERE
	PUSHJ	P,GETCH		;READ CHRS
	MOVE	CS,CTBL(C)	;GET STATUS
	TLNN	CS,TERMF	;END OF LINE?
	JRST	SEMIC		;NO, KEEP GOING
	TRZ	FL,INPRNT	;CLEAR FLAG AGAIN
EOFRT:	MOVE CS,CTBL(C)	;GET STATUS BITS
EOFRT1:	TRNN FL,INPRNT	;IF PRINTING ERROR, DO NOT NEST
	CAIE C,100	;IS IT @
	POPJ P,
	JRST NEST	;SPECIAL

XALL		;BACK TO NORMAL LISTING
CTBL:	0
REPEAT 10,<XWD SPCF,.-CTBL>
	0		;TAB
	XWD SPCF!SPACT!TERMF+12,CHKTRM
XWD SPCF!SPACT!TERMF+13,CHKTRM	;VTAB
XWD SPCF!SPACT!TERMF+14,CHKTRM	;FORM
	0		;CARRET
REPEAT 15,<XWD SPCF,.-CTBL>
	XWD SPCF!TERMF!SPACT+44,CHKTRM
REPEAT 4,<XWD SPCF,.-CTBL>
	0		;SPACE
REPEAT 17,<XWD SPCF,.-CTBL>
REPEAT 12,<XWD NUMF,.-CTBL-40		;DIGIT>
REPEAT 5,<XWD SPCF,.-CTBL>
	EXP	.-CTBL-40	;?
	XWD SPCF,100
REPEAT 32,<EXP .-CTBL-40		;UPPER CASE LETTERS>
REPEAT 6,<XWD SPCF,.-CTBL>
REPEAT 32,<EXP .-CTBL-100		;LOWER CASE LETTERS>
	XWD SPCF,.-CTBL
	XWD SPCF,.-CTBL
	XWD SPCF!TERMF!SPACT+44,CHKTRM
	XWD SPCF!TERMF!SPACT+44,CHKTRM
	XWD SPCF!SPACT,POPFIL

COMMA==CTBL+","

CHKTRM:	PUSH P,CS	;SAVE MAGIC BITS
TERMC1:	PUSHJ P,GETCH
	JUMPE CS,TERMC1	;ALSO IGNORE TABS AND SPACES
	TLNE CS,TERMF
	JRST TERMC1	;BYPASS TERMINATORS
	CAMN CS,COMMA	;CHECK FOR , AFTER CRET
	JRST	[POP P,(P)	;GET STACK IN SYNC
		POPJ P,]	;RETURN THE COMMA
	MOVEM CS,SAVCHR	;SAVE FOR LATER
	POP P,CS
	MOVEI C,0	;AS GOOD AS ANYTHING ELSE
	POPJ P,

DEFINE QQ<
N=1
REPEAT NESTDP+1,<MAC(\N)
	N=N+1>>

GETB1:	DINCT
DEFINE MAC(X)<IBUF'X+2>
QQ
GETB2:	HALT
DEFINE MAC(X)<IN X,0>
QQ
GETB3:	DINPT
DEFINE MAC(X)<IBUF'X+1>
QQ
GETB4:	HALT
DEFINE MAC(X)<STATZ X,740000>
QQ

NEST:	PUSH P,ACCUM	;SAVE STATE OF SCANNER
	PUSH P,FL	;SAVE THE FLAGS (AS IDF?)
	PUSH P,T1
	SETZM SAVCHR
	PUSH P,NAME	;AND THIS OTHER STUFF
	PUSH P,NAME+1
	PUSH P,NAME+2
	PUSH P,NAME+3
	AOBJP SVPT,TMNER	;GET A CLEAR SPACE FOR NAME
	PUSHJ P,SCANAM	;GET ONE TO USE
	AOBJP IOPNT,NESTTD	;TOO DEEP?
	PUSH IOP,SAVCHR
	PUSHJ P,CHKRM		;GET BUFFER SPACE
	SKIPE	C,SVDEV(SVPT)	;WAS A DEVICE SPECIFIED?
	JRST	NSTDEV		;YES, USE IT
IFN TEMP,<MOVE C,.JBFF		;GET START OF BUFFER
	MOVEM C,BUFTAB(IOPNT)	;SAVE IT FOR RELEASING INFO
	MOVEM C,TMPFIL+1	;SAVE IOWD FOR TMPCOR UUO
	MOVEM C,@GETB3(IOPNT)	;DUMMY UP BYTE POINTER
	SOS TMPFIL+1		;MAKE TMPFIL INTO CORRECT IOWD FORMAT
	MOVNI C,200		;GET BUFFER LENGTH
	HRLM C,TMPFIL+1		;STORE NEGATIVE WORD COUNT
	MOVE C,SVNAM(SVPT)	;PICK UP FILNAM
	HRLZM C,TMPFIL	;STORE RIGHT THREE LETTERS
	MOVE C,[XWD 1,TMPFIL]	;SET UP FOR TMPCOR READ
	TMPCOR C,		;READ FILE AND DON'T DELETE
	JRST NOTMP		;NO SUCH FILE, TRY THE DISK
	SETOM TMPFLG(IOPNT)	;FLAG THAT TMPCOR READ WAS DONE
	IMULI C,5		;CALCULATE CHARACTER COUNT
	MOVEM C,@GETB1(IOPNT)	;STORE IN BUFFER HEADER
	MOVEI C,440700		;SET UP BYTE POINTER
	HRLM C,@GETB3(IOPNT)	;BUFFER HEADER FINALLY SET UP
	JRST NEXT2		;CONTINUE INTO MAIN STREAM
NOTMP:			>
	MOVSI	C,'DSK'
NSTDEV:	SETZM	OPENB
	MOVEM	C,OPENB+1
	MOVE C,NESTB(IOPNT)	;GET BUFFER POINTER
	MOVEM C,OPENB+2
	MOVE	C,[OPEN .-.,OPENB]
	DPB IOPNT,[POINT 4,C,12]
	XCT	C
	JRST DSKNA	;LOSE BIG
	MOVE C,.JBFF
	MOVEM C,BUFTAB(IOPNT)	;SAVE THE PLACE PUT
	XCT INTAB(IOPNT)	;DO AN INBUFF
	MOVE C,SVNAM(SVPT)
	MOVEM C,LNAM	;SET UP FOR LOOKUP
	SKIPA C,SVEXT(SVPT)
NEST1:	MOVSI C,SIXBIT '   CMD'	;TRY .CMD
	MOVEM C,LEXT
	MOVE C,SVPPN(SVPT)
	MOVEM C,LPPN
	XCT LKTAB(IOPNT)
	JRST	[TRNE FL,INCRF	;SPECIAL IF TRYING TO READ QQCREF
		JRST DNCRF
		HLLZ C,LEXT	;SEE IF BLANK USED
		JUMPN C,NOFIL	;NO, NOT THERE
		JRST NEST1]
NEXT2:	SUB SVPT,[XWD 1,1]	;GET HIM POINTED BACK RIGHT
	POP P,NAME+3	;RESTORE THINGS
	POP P,NAME+2
	POP P,NAME+1
	POP P,NAME
	POP P,T1
	POP P,FL
	POP P,ACCUM
	TRZ FL,RECALF	;WE HAVE DONE THE FIND
	JRST GETCH	;AND CONTINUE TO GET THAT CHR

POPFIL:
	XCT RELTAB(IOPNT)	;RELEASE HIM
IFN TEMP,<	SETZM TMPFLG(IOPNT)	;CLEAR TMPCOR FLAG>
	MOVE C,BUFTAB(IOPNT)
	MOVEM C,FREBUF(IOPNT)	;MARK BUFFER FREE
	POP IOP,CS
	HRRZ C,CS
	SUB IOPNT,[XWD 1,1]	;POINT IT BACK
	JRST EOFRT1	;AND GIVE BACK THE CHARACTER

	SALL
NESTB:	0
DEFINE MAC(X)<IBUF'X>
QQ
DEFINE MAC(X)<U (IBUF'X,3)>
QQ
IFN TEMP,<U(TMPFLG,NESTDP+2)>
INTAB:	HALT	;INBUFS
DEFINE MAC(X)<INBUF X,2>
QQ

LKTAB:	HALT
DEFINE MAC(X)<LOOKUP X,NAME>
QQ
RELTAB:	JRST ALLDON
DEFINE MAC(X)<RELEAS X,0>
QQ
;ERROR ROUTINES
IFDEF SALL,<SALL>	;MAKE LISTING NEATER
ETMS:	STRING [ASCIZ /?TOO MANY SWITCHES: /]
ERRCOM:	MOVEI T1,20	;SET TO TYPE SOME CHRS TO TELL WHERE ERROR
	MOVE T2,[POINT 7,ERRBUF]	;IS FROM
	TRO FL,INPRNT	;IN CASE EOF WHILE READING CHRS TO TYPE
	SKIPN C,SAVCHR	;FIND THE ONE LEFT
	JRST PUTER
	TLNE C,SPACT	;IS IT SPECIAL
	MOVSS C	;YES. GET IT
	SKIP 1
PUTER:	PUSHJ P,GETCH
	CAIN C,177	;THIS IS EOF
	JRST FINER
	IDPB C,T2
	SOJGE T1,PUTER
NOFIL0:	MOVE	T1,T2
	JRST NOFIL1	;PRINT WITH CR/LF
TMNER:	STRING [ASCIZ /?TOO MANY NAMES: /]
	JRST ERRCOM
DSKNA:	STRING [ASCIZ /?DISK NOT AVAILABLE: /]
	JRST ERRCOM
OUTER:	STRING [ASCIZ /?OUTPUT ERROR: /]
	JRST ERRCOM
PROCON:	STRING [ASCIZ /?LANGUAGE PROCESSOR CONFLICT: /]
	JRST ERRCOM
NOCOR:	STRING [ASCIZ /?NOT ENOUGH CORE: /]
	JRST ERRCOM
READER:	STRING [ASCIZ /?INPUT ERROR: /]
	JRST ERRCOM
SYNRR1:	SUB IOPNT,[XWD 1,1]	;GET HIM BACK TO RIGHT PLACE
SYNERR:	STRING [ASCIZ /?COMMAND ERROR: /]
	JRST ERRCOM
NESTTD:	STRING [ASCIZ /?NESTING TOO DEEP: /]
	JRST ERRCOM
UNRECS:	STRING [ASCIZ /?UNRECOGNIZABLE SWITCH: /]
	MOVE T3,ACCUM	;BAD SWITCH IN HERE
	JRST ERRBF1
NOFIL:	TRNE FL,RECALF	;WE WERE LOOKING UP A SVC FILE
	JRST SYNRR1	;SO GIVE SPECIAL MESSAGE
	STRING [ASCIZ /?NO SUCH FILE - /]
NAMCOM:	MOVE T1,[POINT 7,ERRBUF]
	MOVE T3,NAME
	PUSHJ P,SIXOUT
	HLLZ T3,NAME+1
	JUMPE T3,NOFIL1
	MOVEI T2,"."
	IDPB T2,T1
NOFIL2:	PUSHJ P,SIXOUT
NOFIL1:	MOVEI T2,0
	IDPB T2,T1
	STRING ERRBUF
	CLRBFI		;CLEAR INPUT BUFFER SO GARBAGE IS NOT READ
	RESET
	EXIT		;GO AWAY

FIU:	STRING [ASCIZ /?FILE IN USE OR PROTECTED - /]
	JRST NAMCOM

SIXOUT:	MOVEI T2,0
	LSHC T2,6
	ADDI T2,40
	IDPB T2,T1
	JUMPN T3,SIXOUT
	POPJ P,

DEVNA:	STRING [ASCIZ /?DEVICE NOT AVAILABLE - /]
	MOVE T3,LOKNAM
ERRBF1:	MOVE T1,[POINT 7,ERRBUF]
	JRST NOFIL2

FINER:	CAIGE T1,10	;HAVE WE PRINTED ENOUGH??
	JRFIL0	;YES
	MOVEI C,11	;NO, PRINT A TAB
	IDPB C,T2
	JRST NOFIL0	;AND GO AWAY


SYNERP:	TRNN	FL,PIPF		;A PIP COMMAND?
	JRST	SYNERR		;NO, YOU LOSE
	CAIN	C,"["		;START OF PPN?
	JRST	GETPPN+1	;YES, AND PROBABLY NO DEVICE
	POPJ	P,		;RETURN AND HOPE IT MAKES SENSE

UNKERR:	STRING	[ASCIZ /?Unknown command: /]
	MOVE	T3,ACCUM	;GET IT
	JRST	ERRBF1		;OUTPUT IT
ALLDON:	TRNE FL,INCRF	;JUST FOUND END OF QQCREF FILE
	JRST DNCRF
	SKIPE	FDGFLG		;WRITING A FUDGE FILE?
	PUSHJ	P,DNFUDG	;YES, CLOSE IT
	TRNE FL,INPRNT
	JRST FINER	;IF PRINTENG AND EOF THEN FIINSH UP
	HRRZ T1,(P)	;GET THE ADDRESS WE WANT TO RETURN TO
	CAIE T1,NXFIL1	;THIS SHOULD BE HERE
	JRST SYNERR	;ELSE ERROR
	SETZM PCNAM	;NO LINK NAME TO START WITH
	MOVEI T3,OUTLOD
	TRNN FL,DOLOD		;ARE WE LOADING?
	JRST	ALDN2		;NO
	TLZN FL3,MAP2	;DO A MAP?
	JRST	MAPDN	;NO
	MOVE	T2,['/F/M  ']
	TLZE	FL,MAPL		;LOCAL SYMBOL MAP?
	HRRI	T2,'1M '	;YES
	PUSHJ P,OUTSIX
	TLZ FL,MAP2	;TURN OFF PERM FLAG
MAPDN:	MOVSI T2,'/G '	;SET UP FOR TERMINATE LOADING
	PUSHJ P,OUTSIX		;YES, PUT IT OUT
ALDN2:	MOVEI T4,FCHLOD	;START WITH LOADER
	MOVEI T3,NPROCS	;WHICH IS HERE
	SKIP 1
ALDN1:	LSH T4,1	;LOOK FOR NEXT PROCESSOR
	TRNN FL2,(T4)	;HAS THAT PROCESSOR BEEN SET UP FOR OUTPUT?
	SOJGE T3,ALDN1	;NO, TRY NEXT (BUT NOT TOO MANY)
	JUMPL T3,DONE	;IF OUT OF PROCESSORS THEN DONE
	PUSH P,T3	;SAVE IT FOR LATER
	MOVE T3,PRCTAB(T3)	;GET PROCESSOR OUTPUT ROUTINE
	SKIPN T2,PCNAM	;IS THERE A PROCESSOR FOR IT TO CALL?
	JRST NONAM	;NO
	PUSHJ P,OUTSIX	;YES, PUT OUT ITS NAME
	MOVEI T1,"!"	;AND THE LOAD SYMBOL
	PUSHJ P,(T3)
	PUSHJ	P,OUCRLF
NONAM:	POP P,T3	;GET BACK PROCESSOR NUMBER
	XCT RLSTAB(T3)	;CLOSE UP ITS OUTPUT
	MOVE T1,PRCNAM(T3)	;GET THE NAME OF THAT PROCESSOR
	MOVEM T1,PCNAM	;AND SET AS THE ONE TO LINK TO
	SOJGE T3,ALDN1	;GO BACK IF MORE TO LOOK AT
DONE:	TRNE FL,CMDSN	;DID WE SEE COMMAND FROM TTY?
	JRST DONE1	;NO, DO NOT WRITE FILE
	MOVE T1,JOBNAM
	HRRI T1,'SVC'
	TRNE FL,EDITF
	HRRI T1,'EDS'
	MOVEM T1,LNAM	;SET UP OUTPUT FILE
IFN TEMP,<	HRLZM T1,TMPFIL		;SAVE NAME IN TMPFIL
	MOVE T1,[POINT 7,DDTBUF]	;SET UP BYTE POINTER
	MOVNI T2,4			;SET UP FOR CHARACTER COUNT
	ILDB T3,T1			;GET NEXT CHARACTER
	CAIE T3,177			;IS IT A EOF CHARACTER
	SOJA T2,.-2			;NO, TRY AGAIN
	IDIVI T2,5			;CALCULATE CHARACTER COUNT
	HRLM T2,TMPFIL+1		;STORE IN TMPCOR OUTPUT BLOCK
	LDB T3,[POINT 6,T1,5]		;PICK UP BIT POS OF LAST CHAR
	SETO T2,			;PREPARE TO BUILD MASK
	LSH T2,7(T3)			;MASK OFF REST OF LAST WORD
	ANDM T2,(T1)			;  IN DDT BUFFER
	MOVEI T2,DDTBUF-1		;GET START OF BUFFER
	HRRM T2,TMPFIL+1		;STORE IN WRITE BLOCK FOR TMPCOR UUO
	MOVE T2,[XWD 3,TMPFIL]		;SET UP FOR WRITE
	TMPCOR T2,			;WRITE OUT FILE INTO CORE
	  SKIP 1			;IT DID NOT FIT, TRY DISK
	JRST DONE1			;GO CLEAN UP AND LEAVE
	MOVEI T2,177			;RESTORE EOF CHARACTER IN DDTBUF
	IDPB T2,T1			;ALL BACK TO NORMAL
NOFIT:			>
	MOVSI T1,'TMP'
	MOVEM T1,LEXT
	SETZM LDAT
	SETZM LPPN
	CLOSE LOOK,20	;MAKE SURE NOTHING USING THIS CHANEL
IFE FASTFS,<
	SKIPN	FSNAME		;IS F/S FOUND
	PUSHJ	P,FNDFST	;NO FIND IT>
	MOVE	T1,FSNAME	;GET F/S 
	CAMN	T1,[SIXBIT /DSK/]	;IS IT JUST DSK
	JRST	DONE4		;YES, WILL USE FASTEST F/S ANYWAY
	RELEAS	LOOK,0		;GIVE UP THE CHANNEL
	EXCH	T1,DSKLK+1	;PUT IN BLOCK FOR INIT
	OPEN	LOOK,DSKLK	;INIT THE CHAN.
	  JRST	DSKNA		;SHOULD N'T HAPPEN
	MOVEM	T1,DSKLK+1	;RESTORE THE OLD VALUE IN CASE IT IS NEEDED
DONE4:	PUSHJ P,CHKRM	;GET ROOM FOR BUFFERS
	ENTER LOOK,LNAM	;GET SET TO WRITE
	JRST FIU	;TREAT THIS AS A FATAL ERROR
	OUTBUF LOOK,2
	MOVE T1,[POINT 7,DDTBUF]	;WRITE ALL OF COMMAND
DONE3:	ILDB T2,T1
	CAIN T2,177	;DONE?
	JRST DONE2
	SOSG LOOKBF+2
	OUTPUT LOOK,0
	IDPB T2,LOOKBF+1
	JRST DONE3
DONE2:	CLOSE	LOOK,20	;SAVE THE NAME BLOCKS (LEVEL D)
	RELEASE LOOK,0	;LET IT GO
DONE1:	TRNE FL2,FCHCRF	;DID WE DO ANY CREF?
	PUSHJ P,FINCRF	;YES, FINISH OFF CREF
	SKIPN T1,PCNAM	;IS THERE ONE TO LOAD?
	EXIT		;NO, EXIT
	JRST NUNDO	;GO LOAD IT
	XALL
IFE TEMP,<DEFINE X (A,B,C,D,E)<
RELEASE CHN'B,0>>

IFN TEMP,<DEFINE X (A,B,C,D,E)<
PUSHJ P,CHK'B>>

RLSTAB:	PROCESS
IFE TEMP,<	RELEASE CHNLOD,0	;DON'T FORGET LOADER>
IFN TEMP,<	PUSHJ P,CHKLOD>

	DEFINE X (A,B,C,D,E)<
<SIXBIT /C/>>

PRCNAM:	PROCESS
	SIXBIT /LOADER/
CHKRM:	PUSH P,T1	;SAVE THE REGISTERS WE ARE USING
	PUSH P,T2
	MOVSI T1,-<NESTDP+2>	;LOOK TO SEE IF ANY FREED BUFFERS
	SKIPN T2,FREBUF(T1)
	AOBJN T1,.-1	;TRY AGAIN
	JUMPGE T1,USTOP	;NO, GET IT FROMTOP OF STORAGE
	MOVEM T2,.JBFF	;YES, SET JOBFF THERE
	SETZM FREBUF(T1)	;AND MARK IT USED
	JRST TPOPJ	;THATS ALL FOR NOW
USTOP:	MOVE T1,SVJFF	;GET THE CURRENT TOP OF BUFFER AREA
	MOVEM T1,.JBFF
	ADDI T1,<203*2>+1	;LEAVE THIS MUCH ROOM
	MOVEM T1,SVJFF	;THATS THE NEW TOP
	CAMGE T1,CORTOP	;WILL THAT RUN US OUT OF CORE?
	JRST TPOPJ	;NO, LEAVE
	PUSH P,CTPOPJ
XPAND:	MOVEI T1,2000	;GET SET TO EXPAND
	ADDM T1,CORTOP
	ADDM T1,CORT1
	ADD T1,.JBREL	;NEW TOP DESIRED
	CALLI T1,11	;ASK FOR IT
	JRST NOCOR	;LOSE BIG
	MOVE T1,.JBREL
MVCR:	MOVE T2,-2000(T1)	;MVOVE CORE UP
	MOVEM T2,(T1)
	CAMLE T1,CORTOP	;ARE WE DONE?
	SOJA T1,MVCR
CTPOPJ:	POPJ	P,TPOPJ
TPOPJ:	POP P,T2	;ALL FINISHED
TPOPJ1:	POP P,T1
	POPJ P,
DEFINE TABLE<
COMAND	COMPILE,<TRZ	FL,DOLOD>
COMAND	LOAD,JFCL
COMAND	DEBUG,<PUSHJ	P,DEBUG>
COMAND	EXECUTE,<PUSHJ	P,XCTR>
COMAND	EDIT,<TRO	FL,EDITF>
COMAND	CREATE,<TRO	FL,EDITF!CREATF>
COMAND	LIST,<JRST	LISTR>
COMAND	CREF,<JRST	CREFIT>
COMAND	CROSS,<JRST	CREFIT>
COMAND	DELETE,<JRST	DODEL>
COMAND	TECO,<TRO	FL,EDITF!TECOF>
COMAND	MAKE,<TRO	FL,EDITF!TECOF!CREATF>
COMAND	RENAME,<JRST	DOREN>
COMAND	TYPE,<JRST	TYPR>
COMAND	COPY,<JRST	DOCOPY>
COMAND	PRESERVE,<JRST	DOPRES>
COMAND	PROTECT,<JRST	DOPROT>
COMAND	REWIND,<JRST	DOREW>
COMAND	UNLOAD,<JRST	DOUNLD>
COMAND	ZERO,<JRST	DOZERO>
COMAND	SKIP,<JRST	DOSKIP>
COMAND	BACKSPACE,<JRST	DOBKSP>
COMAND	EOF,<JRST	DOEOF>
COMAND	FUDGE,<JRST	FUDGIT>
COMAND	CTEST,<JRST	TESTIT>
COMAND	DIRECTORY,<JRST	DODIR>
COMAND	HELP,<JRST	RUNAME>
COMAND	INITIA,<JRST	RUNAME>
COMAND	SYSTAT,<JRST	RUNAME>
COMAND	PLEASE,<JRST	RUNAME>
COMAND	FILE,<JRST	MOUNT>
>

IFN DIRSW,<SYN	RUNAME,DODIR>
DEFINE COMAND (A,B)<
<SIXBIT /A/>>
COMTAB:	TABLE
COMTLG==.-COMTAB
DEFINE COMAND (A,B)<
B>
COMT2:	TABLE

	IFDEF SALL,<SALL>
DEBUG:	MOVSI  T2,'/T '
	SKIP 1
XCTR:	MOVSI T2,'/E '
	MOVEI T3,OUTLOD
	JRST OUTSIX

RPGSET:	MOVE T1,[POINT 7,FCOMD]
	MOVEM T1,DINPT
	MOVEI FL,RECALF!CMDSN
	JRST RPGRET

IFE FASTFS,<
			;USE FIRST F/S IF SEARCH LIST IS OF FORM
			; DSKA/N,DSKB,...FENCE
FNDFST:
IFN TEMP,<PUSH	P,T1		;SAVE SOME ACS
	PUSH	P,T2
	PUSH	P,T3
	PUSH	P,T4>
	MOVE	T1,[3,,T2]	;SET UP BLOCK
	SETOB	T2,T4		;REQUEST FIRST F/S
	JOBSTR	T1,		;GET FIRST F/S IN SEARCH LIST
	  JRST	USEDSK		;LEVEL C
	JUMPL	T4,USEDSK	;SWP BIT SET
	TLNN	T4,200000	;IS NO CREATE SET?
	JRST	USEDSK		;NO, GENERIC DSK WILL USE THIS F/S
	DSKCHR	T1,		;GET FIRST 3 ARGS
	  JRST	USEDSK		;SHOULD NEVER HAPPEN BUT ...
	TLNN	T1,740200	;RHB!OFL!HWP!SWP!NNA! SET?
	CAIGE	T3,10		;ANY ROOM? ,TEN SHOULD BE ENOUGH
USEDSK:	MOVSI	T2,'DSK'	;JUST USE DSK
	MOVEM	T2,FSNAME	;STORE FASTEST F/S NAME
IFN TEMP,<POP	P,T4		;RESTORE ACS
	POP	P,T3
	POP	P,T2
	POP	P,T1>
	POPJ	P,		;RETURN
>
;HERE WE GO TO START THE WORLD TURNING

STPT:	TDZA	T4,T4		;NORMAL ENTRY
	MOVNI	T4,1		;REENTRY FROM AN EDITOR
IFN PURESW,<	SETZM	.ZZ		;MUST CLEAR LOW CORE
	MOVE	T1,[XWD .ZZ,.ZZ+1]
	BLT	T1,LOWTOP
>
	JUMPL	T4,RPGSET
	TTCALL 10,0	;RESET POINTER TO START OF COMMAND
	MOVEI FL,0
	MOVE T1,[POINT 7,DDTBUF]	;SET POINTER
	MOVEM T1,DINPT
START1:	TTCALL 5,T2	;READ A COMMAND CHAR INTO T2
	MOVEI	T2,33		;NON-SKIP MEANS END
	IDPB	T2,T1		;STORE IN DDTINBUF
	MOVE	T3,CTBL(T2)	;GET CHARACTER DESCRIPTOR
	TLNN	T3,TERMF	;IS IT A BREAK CHAR?
	JRST	START1		;NO. GO GET MORE.
	MOVEI	T2,177		;MARK END WITH AN EOF FLAG
	IDPB T2,T1
	IDPB T2,T1	;MAKE SURE
RPGRET:
IFN PURESW,<
	MOVE T1,[XWD INIDAT,INILOW]
	BLT T1,INILOW+INILEN
>
	RESET
IFN FASTFS,<MOVE T1,[EXP FASTFS]	;IF GIVEN FASTEST F/S
	MOVEM	T1,FSNAME	;USE IT>
IFE TEMP,<IFE FASTFS,<
	PUSHJ	P,FNDFST	;MAY AS WELL GET IT OVER WITH>>
	MOVEI T1,3
	CALLI T2,30	;PJOB
	IDIVI T2,12
	ADDI T3,20	;TO SIXBIT
	LSHC T3,-6
	SOJG T1,.-3	;THREE DIGITS
	HLLZM T4,JOBNAM	;SAVE TO MAKE UNIQUE NAMES
	TLO T4,404040	;NOW TO ASCII FOR ASCIZ'S
	MOVEI T1,3	;THREE CHARS
	LSH T3,1
	LSHC T3,6	;BRING IN A CHAR
	SOJG T1,.-2
	DPB T3,[POINT 21,CRFRDR,27]	;SAVE IN ASCIZ
	DPB T3,[POINT 21,FCOMD,27]
	DPB T3,[POINT 21,FCOMD2,27]
	MOVSI T1,377777	;SET COUNT TO A LARGE NUMBER
	MOVEM T1,DINCT
	MOVE P,PDP		;SET UP PDL
	MOVE IOP,[IOWD <NESTDP+2>*3,IOPD]	;AND IO PDL
	MOVSI IOPNT,-<NESTDP+1>	;SET NEXT LIMIT
	TRO FL,DOLOD		;WE WANT TO LOAD
	HRLI FL,F4SW	;ASSUME F4
	SETZB	FL2,LOKNAM	;NO ALTERNATE DEVICE YET
	OPEN LOOK,DSKLK	;GET THE DSK
	JRST DSKNA
	INBUF LOOK,2
IFE PURESW,<SETZM FREBUF	;MARK NO FREED BUFFERS
	MOVE T1,[XWD FREBUF,FREBUF+1]
	BLT T1,FREBUF+NESTDP+1>
	MOVE T1,.JBFF
	MOVEM T1,SVJFF
	MOVE T1,.JBREL
	MOVEM T1,CORTOP
	MOVEM T1,CORT1
IFE PURESW,<SETZM SAVCHR	;TO START THINGS>
	HLLZS .JBERR	;RESET ERROR COUNT
	MOVSI SVPT,-NFILE
TESTIT:	PUSHJ P,SCAN	;SCAN PAST THE COMPILE ETC
	MOVE T1,ACCUM	;FIND OUT WHICH COMMAND
	MOVNI T2,1
STPT1:	LSH T1,6
	LSH T2,-6
	JUMPN T1,STPT1
	MOVSI T1,-COMTLG
STPT2:	MOVE T3,COMTAB(T1)
	ANDCM T3,T2
	CAMN T3,ACCUM
	JRST COMATC
	AOBJN T1,STPT2
	JRST UNKERR
COMATC:	XCT COMT2(T1)	;DO THE APPROPRIATE THING
	PUSHJ P,SCAN	;GET NEXT THING
	TRNN IOPNT,-1	;IF DOWN A LEVEL ITS OK
	TLNN CS,TERMF	;OR IF NOTHING SEEN
	SKIP 1
	JRST COMAT1
	TRNE FL,EDITF
	JRST DOEDT1
	JRST NXFIL1
COMAT1:	MOVE T1,[POINT 7,FCOMD]	;GENERATE FAKE COMMAND TO READ
	TRNE FL,EDITF
	MOVE T1,[POINT 7,FCOMD2]
	MOVEM T1,DINPT	;SAVE FILE
	TRO FL,RECALF+CMDSN	;MARK RECALLING FILE, DONT WRITE
	SETZM SAVCHR	;CLEAR OUT SCANNER
	MOVSI IOPNT,-<NESTDP+2>	;ALLOW EXTRA NESTING
	PUSHJ P,SCAN
	TRNE FL,EDITF
	JRST DOEDIT
NXFIL:	PUSHJ P,SCAN
NXFIL1:	MOVSI SVPT,-NFILE	;SET UP FOR NUMBER OF FILES
	MOVEI SWCNT,SWBK*5	;SET UP FOR SWITCHES
	MOVE SWPT,[POINT 7,SWBLK]	;AND POINTER
	SETZM SWBKL
	SETZM SWBKB
	SETZM ONAM
	SETZM	OEXT
	HLL FL3,FL	;SET TEMP FLAGS FROM PERM FLAGS
	MOVE T1,[POINT 7,LODSBK]	;SET POINTER TO LOADER
	MOVEM T1,LODSP		;SWITCH BLOCK
	MOVEI T1,LODSCT
	MOVEM T1,LODCTR
	MOVEM	T1,LODCT2	;AND SET COUNT FOR AFTER FILE NAME SWITCHES
	MOVE T1,[POINT 7,LODSB2]
	MOVEM T1,LODSP2
	SETZM BROCNT	;CLEAR OUT THE <> COUNT
	JRST	ILP0A
;MAIN LOOP FOR READING INPUT

ILP0:	PUSHJ P,SCAN	;GET FIRST "THING"
ILP0A:	CAIN C,"/"	;CHECK FOR PERM COMPILE SWITCHES
	JRST COMPS1
	CAIN C,"%"	;CHECK FOR PERM LOADER FLAGS
	JRST LOADS1
ILP1A:	TRZ FL,PROCS	;NO PROCESSOR SWITCHES SEEN YET
ILP1:	PUSHJ P,GETNAM	;GO GET A FILE NAME
	MOVE C,LODSP	;EXCHANGE POINTERS
	EXCH C,LODSP2
	MOVEM C,LODSP
	MOVE C,LODCTR
	EXCH C,LODCT2
	MOVEM C,LODCTR
ILP2A:	PUSHJ P,SCAN	;GET THE SPECIAL CHR OR WHATEVER
ILP2:	CAIE C,","	;DONE WITH THIS SET OF NAMES?
	TLNE CS,TERMF	;WILL ACCEPT A TERMINATOR
	JRST SETUP	;GO SET UP THE FILES FOR PROCESSORS
	CAIN C,"("	;MAYBE SWITCHES TO BE PASSED TO PROCESSORS
	JRST PROCSW
	CAIN C,"/"	;OR FOR US
	JRST COMPSW
	CAIN C,"%"
	JRST LOADS2
	CAIN C,">"
	JRST ENDBRO	;THIS IS THE END OF A BROKET STRING
	CAIN C,"="	;MAYBE HE IS SETTING THE OUTPUT NAME
	JRST SETONM
	CAIN C,"["	;IS IT PROJECT-PROGRAMMER NUMBER?
	JRST GETPPN+1	;YES, BUT ONLY ONE PUSHJ TO SCAN
	CAIE C,"+"	;IS THIS A SECOND FILE
	JRST SYNERR	;IT SHOULD HAVE BEEN ONE OF THOSE
	AOBJP SVPT,TMNER	;MAYBE TOO MANY FILES
	MOVE C,LODSP	;EXCHANGE POINTERS AGAIN
	EXCH C,LODSP2
	MOVEM C,LODSP
	MOVE C,LODCTR
	EXCH C,LODCT2
	MOVEM C,LODCTR
	PUSHJ P,SCAN	;GET NEXT
	CAIE C,"<"	;IS THIS THE <> CONSTRUCTION
	JRST ILP0A	;NO
	AOS BROCNT	;WE ARE ONE DEEPER IN BROKETS
	PUSHSZ==.
	PUSH P,OEXT
	PUSH P,SVPT	;SAVE AWAY ALL THE IMPORTANT INFORMATION
	PUSH P,SWPT
	PUSH P,SWCNT
	PUSH P,LODSP
	PUSH P,LODSP2
	PUSH P,LODCTR
	PUSH P,LODCT2
	PUSH P,SWBKL
	PUSH P,SWBKB
	PUSH P,ONAM
	PUSHSZ==.-PUSHSZ
	JRST ILP0	;GO FINISH THINGS UP

ENDBRO:	PUSHJ P,SCAN	;GO GET NEST THING (SHOULD BE A ",")
	TLNN CS,TERMF
	CAIN C,","
	SOSGE BROCNT	;ALSO ERROR IF NO < WAS SEEN
	JRST SYNERR
	SUB P,[PUSHSZ,,PUSHSZ]	;RESET PDL
	JRST SETUP	;GO TAKE CARE OF THINGS

NXFILP:	SKIPG BROCNT	;ARE WE DONING BROKETS?
	JRST NXFIL	;NO, JUST CONTINUE
	MOVE T1,(P)
	MOVEM T1,ONAM
	MOVE T1,-1(P)
	MOVEM T1,SWBKB
	MOVE T1,-2(P)
	MOVEM T1,SWBKL
	MOVE T1,-3(P)
	MOVEM T1,LODCT2
	MOVE T1,-4(P)
	MOVEM T1,LODCTR
	MOVE T1,-5(P)
	MOVEM T1,LODSP2
	MOVE T1,-6(P)
	MOVEM T1,LODSP
	MOVE SWCNT,-7(P)
	MOVE SWPT,-10(P)
	MOVE SVPT,-11(P)
	MOVE T1,-12(P)
	MOVEM T1,OEXT
	JRST ILP0
COMPS:	PUSHJ P,SCAN	;GET THE NAME OF THE SWITCH
	TRNN FL,IDF	;WAS THERE REALLY AN IDENTIFIER THERE?
	JRST SYNERR	;LOSE
	MOVE T1,ACCUM	;GET ITS SIXBIT
	MOVNI T2,1	;SET UP MASK
CMP1:	LSH T1,6
	LSH T2,-6
	JUMPN T1,CMP1	;WHEN DONE T2 HAS 0'S FOR ALL CHRS IN T1
	MOVSI T1,-TBLG	;GET SET TO SCAN FOR NAME
	SETOM NUMAT	;-1 TO NUMBER FOUND
CMP3:	MOVE T3,SWTAB(T1)	;GET A SWITCH
	CAMN T3,ACCUM	;EXACT MATCH?
	JRST MATCH	;YES, ALL DONE
	ANDCM T3,T2	;0 OUT UNNECESSARY CHRS
	CAME T3,ACCUM
	JRST CMP2	;NO MATCH
	AOS NUMAT	;POSSIBLE MATCH
	MOVEM T1,SVIND	;SAVE POINTER
CMP2:	AOBJN T1,CMP3
	SKIPE NUMAT	;WAS THERE AT LEAST ONE BUT NO MORE?
	JRST UNRECS
	MOVE	T1,SVIND	;RESTORE THE POINTER
MATCH:	MOVE T1,SWTAB2(T1)	;GET ACTION
	TLZ FL3,(T1)	;TURN OFF SWITCHES AS NEEDED
	TRNE FL,PERF	;PERMANENT?
	TLZ FL,(T1)	;SET THAT TOO
	MOVSS T1
	TLO FL3,(T1)	;AND TURN ON OTHERS
	TRNE FL,PERF
	TLO FL,(T1)
	TLZE	FL3,FUDGSW	;MAKING LIBRARY?
	PUSHJ	P,SETFUD	;YES
	TLZE FL3,MAP1	;ARE WE DOING MAPING?
	JRST SETMAP	;YES, SET IT UP
	JRST SCAN	;GET SOMETHING ELSE

	XALL
DEFINE X (A,B,C,D,E)<
SWITCH A,<XWD B'SW,ALPROC>>
	DEFINE TABLE<
SWITCH LIST,<XWD LISTSW,CRSW>
SWITCH CREF,<XWD CRSW!LISTSW,0>
SWITCH M,<XWD MACSW,ALPROC>
SWITCH C,<XWD CRSW!LISTSW,0>
SWITCH LIBRARY,<XWD LIBSW,0>
SWITCH REL,<XWD RELSW,ALPROC>
SWITCH NOLIST,LISTSW
SWITCH NOSEARCH,LIBSW
SWITCH L,<XWD LISTSW,CRSW>
SWITCH F,<XWD F4SW,ALPROC>
SWITCH N,LISTSW
SWITCH COMPILE,<XWD COMPLS,0>
SWITCH NOCOMPILE,COMPLS
SWITCH MAP,<XWD  MAP1!MAP2,0>
SWITCH LMAP,<XWD MAP1!MAP2!MAPL,0>
SWITCH FUDGE,<XWD FUDGSW,0>
PROCESS
>

DEFINE SWITCH (A,B)<
<SIXBIT /A/>>
SWTAB:	TABLE
TBLG==.-SWTAB
DEFINE SWITCH (A,B)<
B>
SWTAB2:	TABLE
;HERE ON "/" AFTER A FILE NAME

COMPSW:	TRZ FL,PERF	;DOING TEMP
	PUSHJ P,COMPS
	JRST ILP2

;HERE ON "/" AS FIRST CHAR OF IDENT, I.E. PERM SW

COMPS1:	TRO FL,PERF
	PUSHJ P,COMPS
	CAIE	C,","	;IS NEXT CHAR. A COMMA
	JRST ILP0A
	JRST	ILP0	;YES,SO SCAN FOR CHAR. AFTER IT

SETMAP:	TLZ FL,MAP1	;IN CASE WAS A PERM TYPE FLAG
	TRON FL,MAPST	;IS IT SET?
	TRNN FL,DOLOD	;OR NOT LOADING?
	JRST SCAN
	MOVEI T3,OUTLOD
	PUSHJ	P,OUCRLF
	PUSHJ	P,SCAN		;LOOK AT NEXT CHAR.
	CAIE	C,":"		;IS THIS A KEY WORD SPECIFICATION
	JRST	SETMP1		;NO
	AOBJP	SVPT,NESTTD	;MAKE SPACE FOR FIELDS
	PUSHJ	P,SCANAM	;YES, SO GO GET SPECIFICATIONS
	SKIPE	T2,SVDEV(SVPT)	;A DEVICE SPECIFIED?
	PUSHJ	P,OUTDEV	;YES
	SKIPN	T2,SVNAM(SVPT)	;NAME SPECIFIED?
	MOVSI	T2,'MAP'	;DEFAULT NAME
	PUSHJ	P,OUTSIX	;OUTPUT IT
	SKIPE	T2,SVEXT(SVPT)	;AN EXTENSION ALSO?
	PUSHJ	P,OUTEXT	;YES
	SUB	SVPT,[1,,1]	;BACK TO WHERE IT WAS
	PUSHJ	P,SCAN
	JRST	SETMP2

SETMP1:	MOVSI T2,'MAP'		;DEFAULT NAME
	PUSHJ P,OUTSIX
SETMP2:	MOVSI	T2,'_  '
	PUSHJ	P,OUTSIX
	TRZ FL,LODOUT	;DO NOT NEED A COMMA FOR NEXT FILE
	POPJ	P,
PROCSW:	TROE FL,PROCS	;HAVE WE ALREADY SEEN SOME?
	JRST SYNERR	;YES, I DEFINE THIS AS ILLEGAL
	MOVEM SWPT,SWBKS(SVPT)	;SAVE BYTE POINTER TO NEW ONES
	TRZ FL,PCM1!PCM2	;NO COMMAS YET
PROCS1:	PUSHJ P,GETCH	;GIVE ME A CHARACTER
	CAIN C,")"	;DONE?
	JRST ESTR	;YES
	CAIN C,","	;POSSIBLY COMMA
	JRST PCCOM	;GO TAKE GOOD CARE OF IT
	JUMPLE CS,SYNERR	;NOT ANUMBER OR LETTER, HE LOSES
	IDPB C,SWPT	;SAVE IT AWAY
	SOJG SWCNT,PROCS1	;NEXT PLEASE
	JRST ETMS	;TOO MANY SWITCHES FOR SPACE RESERVED

PCCOM:	TROE FL,PCM1	;IS THIS THE FIRST OR SECOND COMMA
	JRST NOTBIN	;NOT FIRST, TRY FOR SECOND
	CAMN SWPT,SWBKS(SVPT)	;WAS ANYTHING STORED?
	JRST PROCS1	;NO, JUST IGNORE
	SKIPE SWBKB	;ARE THERE ALREADY BINARY SWITCHES
	JRST SYNERR	;YES, MORE NOT ALLOWED
	MOVE T1,SWBKS(SVPT)	;GIVE THIS TO BINARY
	MOVEM T1,SWBKB
COMCOM:	MOVEI C,0	;MARK END OF STRING
	IDPB C,SWPT
	SOJLE SWCNT,ETMS	;HAVE WE RUN OUT?
	MOVEM SWPT,SWBKS(SVPT)	;AND A NEW ONE FOR SRC
	JRST PROCS1
NOTBIN:	TROE FL,PCM2	;SECOND ALREADY SEEN?
	JRST SYNERR	;YES, THREE NOT PERMITTED
	CAMN SWPT,SWBKS(SVPT)	;ANYTHING THERE?
	JRST PROCS1	;HE WOULD HAVE BEEN JUST AS WELL WITHOUT IT
	SKIPE SWBKL	;ALREADY LIST SWITCHES?
	JRST SYNERR	;YES, HE LOSES
	MOVE T1,SWBKS(SVPT)	;AND GIVE TO CORRECT PERSON
	MOVEM T1,SWBKL
	JRST COMCOM
ESTR:	CAMN SWPT,SWBKS(SVPT)	;WAS ANYTHING STORED?
	JRST	[SETZM SWBKS(SVPT)	;NO, ZERO IT
		JRST ILP2A]
	MOVEI C,0
	IDPB C,SWPT	;MARK
	SOJLE SWCNT,ETMS
	JRST ILP2A	;NEXT
SETONM:	SKIPE	ONAM	;OUTPUT NAME GIVEN BEFORE?
	SKIPLE	BROCNT	;BUT OK IN BROKETS
	TRNE FL,PROCS	;PROCESSOR SWITCHES NOT PERMITTED HERE
	JRST SYNERR
	MOVE T1,SVNAM(SVPT)	;GET THE NAME
	MOVEM T1,ONAM	;AND SAVE IT AWAY
	MOVE	T1,SVEXT(SVPT)
	MOVEM	T1,OEXT
	PUSHJ P,SCAN
	JRST ILP1

LOADS1:	PUSHJ P,LODS1
	JRST ILP0
LOADS2:	PUSH P,[ILP2A]	;SET RETURN POINT
LODS1:	PUSHJ P,GETCH	;NEXT CHR
	CAIG	C," "		;NON-PRINTING CHARS. NOT ALLOWED
	JRST	SYNERR		;THIS REALLY IS A BUG
	CAIN	C,"-"		;SPECIAL CHECK FOR -SWITCH
	TLO	CS,NUMF		;PRETEND ITS A NUMBER
	IDPB C,LODSP	;SAVE IT
	SOSG LODCTR	;CHECK SIZE
	JRST ETMS
	TLNN CS,NUMF	;A NUMBER
	POPJ P,		;NO, DONE
	JRST LODS1	;YES, THEY GET PASSED ON
SETUP:	SKIPE ONAM	;SET ONAM IF NOT ALREADY
	JRST ONSET
	MOVE T1,SVNAM(SVPT)	;AS LAST FILE NAME
	MOVEM T1,ONAM
ONSET:	MOVSI T1,-NFILE	;NUMBER OF FILES
	TRZ FL,NODAT	;WE HAVE NOT SEEN A DIFFERENT DEVICE
	SETZM SDAT	;LATEST DATE
	SETZM STIM	;AND LATEST TIME
	TLZ FL2,-1	;NO PROCESSOR YET
	PUSHJ P,GETPRO	;GO FIND DATE AND PROCESSOR
	TLNN FL2,RELSW	;IF A REL FILE
	TLNE FL3,LIBSW!RELSW	;OR LIBRARY SEARCH
	JRST LDREL	;GO LOAD IT NOW
	TRNN FL,NODAT	;NO DATES ON OTHER DEVICES
	TLNE FL3,COMPLS	;DO WE ALWAYS WANT TO COMPILE?
	JRST DOCOMP	;YES, IGNORE DATES
	SKIPA T1,SVPPN	;LOOK ON THIS AREA FOR REL
REREL:	SETZ	T1,
	MOVEM T1,LPPN	;BUT ONLY FIRST TIME
	MOVEM T1,SVRPP	;SO WE KNOW IF SECOND TIME
	MOVE T1,ONAM	;SEE IF REL IS THERE
	MOVEM T1,LNAM
	SKIPN	T1,OEXT	;USE SPECIFIED OUTPUT EXT.
	MOVSI T1,'REL'
IFN MACX11,<
	TLNN FL2,P11SW	;USE 'OBJ' IF MACX11 INSTEAD OF 'REL'
	JRST REREL1	;NOT MACX11, SO DON'T BOTHER
	SKIPN T1,OEXT	;USE OUTPUT EXT IF SPECIFIED
	MOVSI T1,'OBJ'	;USE PDP-11 DEFAULT BINARY EXTENSION
REREL1:>
	MOVEM T1,LEXT
	LOOKUP LOOK,LNAM	;IS IT THERE
	JRST DOCOMP	;NO, WE MUST RECOMPILE
	LDB T2,[POINT 12,LDAT,35]	;GET DATE
	CAMGE T2,SDAT	;EARLIER
	JRST DOCOMP	;YES, COMPILE
	CAME T2,SDAT	;SAME?
	JRST NOCOM1	;NO, ALL OK
	LDB T2,[POINT 11,LDAT,23]	;YES, GET TIME
	CAMLE T2,STIM	;LATER?
	JRST NOCOM1	;YES
DOCOMP:	SKIPE SVRPP	;DID WE LOOK ON THIS AREA?
	JRST REREL	;NO, TRY IT
	MOVEI T3,0	;GET THE PROCESSOR
	SKIPA T1,FL2
DC1:	LSH T1,1	;TRY NEXT BIT
	TLNN T1,400000	;IS HIGH BIT ON YET?
	AOJA T3,DC1	;TURNS IT INTO A NUMBER
DC2:	MOVEM T3,PCNUM	;SAVE IT FOR LATER
	MOVE T3,PRCTAB(T3)	;GET THE NAME OF THE OUTPUT ROUTINE
	MOVE T2,ONAM	;START PUTTING OUT
	PUSHJ P,OUTSIX
	SKIPE	T2,OEXT	;EXTENSION EXPLICITLY GIVEN?
	PUSHJ	P,OUTEXT	;YES
	SKIPE T2,SWBKB	;ARE THERE SWITCHES
	PUSHJ P,OUTSW	;YES, OUTPUT THEM
	TLNN FL3,LISTSW	;LISTING REQUESTED?
	JRST NOLST
	MOVEI T1,","	;YES, NEED A COMMA
	PUSHJ P,(T3)
	MOVE T2,ONAM	;SET IT UP
	PUSHJ P,OUTSIX
	TLNN FL3,CRSW	;CREF MAYBE
	JRST NOLST1
	MOVSI T2,'/C '
	PUSHJ P,OUTSIX
	PUSH P,T3
	PUSHJ P,ENTCRF	;PUT IT IN THE ###CREF FILE
	POP P,T3
NOLST1:	SKIPE T2,SWBKL	;SWITCHES?
	PUSHJ P,OUTSW
NOLST:	MOVEI T1,"_"
	PUSHJ P,(T3)
	MOVSI T4,-NFILE
PRCLP:	SKIPE T2,SVDEV(T4)	;IS THERE A DEVICE THERE
	PUSHJ P,OUTDEV	;YES, PRINT IT
	MOVE T2,SVNAM(T4)	;PUT OUT NAME
	PUSHJ P,OUTSIX
	SKIPE T2,SVEXT(T4)	;AND EXT IF NECESSARY
	PUSHJ P,OUTEXT
NOEXT:	SKIPE T2,SVPPN(T4)	;NEED PPN?
	PUSHJ P,OUTPPN	;PUT THEM OUT
	SKIPE T2,SWBKS(T4)	;AND SWITCHES
	PUSHJ P,OUTSW
	CAMN T4,SVPT	;ALL DONE?
	JRST ENDPRC	;YES, GO FINISH UP AND CONSIDER LOADING
	MOVEI T1,","
	PUSHJ P,(T3)	;NEXT FILE
	AOBJN T4,PRCLP
ENDPRC:	PUSHJ	P,OUCRLF
IFN SPRC,<
	TLNN FL2,SPRC>
	JRST NOCOMP	;GO LOAD
IFN SPRC,<
	MOVSI SVPT,-NFILE	;RESET POINTER
	MOVE T1,ONAM	;AND FAKE WORLD
	MOVEM T1,SVNAM
	MOVE T3,PCNUM	;GET BACK PROCESSOR NUMBER
	MOVE T1,INTEXT(T3)	;GET EXTENSION
	MOVEM T1,SVEXT
	SETZM SVPPN
	SETZM SWBKS
	SETZM SWBKB
	SETZM SWBKL
	HRL FL2,NXPC(T3)	;SET FOR NEXT PROCESSOR
	JRST DOCOMP	;AND GO EMIT CALLS
>
LDREL:	TRNE SVPT,-1	;CHECK FOR ONLY ONE FILE
	JRST NOFIL		;IF MORE THAN ONE, THERE IS AN ERROR
NOCOMP:	TLNN	FL,FUDGSW	;TEST LOCAL SWITCH ALSO
	TLNE	FL3,FUDGSW	;NEED TO MAKE FUDGED LIBRARY?
	PUSHJ	P,ENTFUD	;YES
	TRNN FL,DOLOD	;DO WE WANT TO LOAD?
	JRST NXFILP	;NO, GO TO NEXT
	MOVEI C,0
	IDPB C,LODSP	;END SECOND SET OF SWITCHES
	IDPB C,LODSP2
	MOVEI T3,OUTLOD	;SET FOR LOADER
	TRZE FL,LODOUT	;IS THERE ALREADY OUTPUT THERE?
	PUSHJ P,OUCRLF	;YES, OUTPUT A CRLF AS SEPARATOR
	MOVE T2,[POINT 7,LODSBK]	;OUTPUT FIRST SWITCHES
	PUSHJ P,OUTSW
	MOVSI T2,'DSK'
	TLNN FL3,LIBSW
	TLNE FL2,RELSW	;USING A REL FILE?
LODR0:	SKIPE T2,LOKNAM	;ON NON-DISK DEVICE?
LODR3:	PUSHJ P,OUTDEV	;YES. OUTPUT DEVICE
LODR1:	MOVE T2,ONAM	;NOW FILE NAME
	PUSHJ P,OUTSIX
	TLNN FL3,LIBSW	;IF LIBRARY
	TLNE FL2,RELSW	;OR REL
	SKIP 3
	SKIPE	T2,OEXT	;EXTENSION GIVEN?
	PUSHJ	P,OUTEXT;YES
	JRST	ELOD	;AND CONTINUE
	SKIPE T2,SVEXT	;ALSO USE EXT IF GIVEN
	PUSHJ P,OUTEXT
LODR2:	SKIPE T2,SVPPN	;THEN THINK ABOUT PPN
	PUSHJ P,OUTPPN
	MOVSI T2,'/L '	;TELL LOADER
	TLNE FL3,LIBSW	;LIBRARY?
	PUSHJ P,OUTSIX
ELOD:	MOVE T2,[POINT 7,LODSB2]	;OUTPUT SECOND SET OF SWITCHES
	PUSHJ P,OUTSW
ELOD2:	TRO FL,LODOUT	;MARK AS HAVING OUTPUT THERE
	JRST NXFILP
NOCOM1:	SKIPN SVRPP	;DID WE FIND THE REL FILE SOMEWHERE ELSE?
	JRST NOCOMP	;NO
	SETZM SVEXT	;ZERO SOURCE EXTENSION
	TLO FL2,RELSW	;AND PRETEND HE SAID .REL
	JRST NOCOMP

GETPRO:	MOVEI T3,NPROCS+1	;SET UP LOOK OF EXTENSION POINTER
NFIL:	MOVE T2,SVNAM(T1)	;SET UP NAME AND PPN
	MOVEM T2,LNAM
	MOVE T2,SVEXT(T1)
NXEXT:	MOVEM T2,LEXT	;START WITH ORIGINAL EXT
	MOVEM T2,OLDEXT	;SAVE FOR RAS SYSTEM
	MOVE T2,SVPPN(T1)
	MOVEM T2,LPPN
	SKIPN T2,SVDEV(T1)	;A DEVICE?
	SKIPE T2,LOKNAM	;OR SAVING ONE UP
	JRST ALTDEV
OKLOOK:	LOOKUP LOOK,LNAM
	JRST NOTYET	;HAVE NOT FOUND IT YET
DNLOK:	HLLZ T2,LEXT	;GET THE EXTENSION
	CAME T2,OLDEXT	;WAS IT WHAT WE ASKED FOR
	JRST NOTYET	;TREAT AS IF LOOKUP FAILED
	MOVEM T2,SVEXT(T1)	;SAVE EXT (WILL HELP <> CODE)
	LDB T2,[POINT 12,LDAT,35]	;GET DATE
	CAMLE T2,SDAT	;AND CHECK TO SEE IF LATEST
	JRST SETDT
	CAME T2,SDAT
	JRST OLDAT
	LDB T2,[POINT 11,LDAT,23]
	CAMLE T2,STIM
SETTM:	MOVEM T2,STIM	;MARK WITH LATER ONE
OLDAT:	HLLZ T2,LEXT	;GET THE EXTENSION WE FOUND
	JUMPE T2,SETCP	;SET TO CURRENT PROCESSOR
	MOVSI T3,-<NPROCS+1>	;LOOK AT EXTENSION TO FIND PROCESSOR
	CAME T2,PXTAB(T3)
	AOBJN T3,.-1
	JUMPGE T3,SETCP	;NOT THERE
	TLNE FL2,@ISPTAB(T3)	;IS THAT ONE ALREADY SET?
	JRST NFIL2
	TLNE FL2,ALPROC	;IS ANY SET?
	JRST FIXCON	;YES, WE MAY HAVE A CONFLICT
	TLO FL2,@ISPTAB(T3)	;SET UP FOR THIS ONE
NFIL2:	CAME T1,SVPT	;ARE WE DONE?
NFIL1:	AOBJN T1,GETPRO	;NO, GO ON
	POPJ P,
	;THERE IS NO CONFLICT IF THIS IS A REL FILE

FIXCON:	MOVE	T2,ONAM
	CAMN	T2,LNAM
	TRNE	T3,-1		;IF NOT OUTPUT REL FILE
	JRST	PROCON		;THEN WE HAVE A CONFLICT
FIX1:	SETOM	SDAT		;FORCE USE OF REL FILE
	POPJ	P,		;AND RETURN TO SETUP

SETDT:	MOVEM T2,SDAT
	LDB T2,[POINT 11,LDAT,23]	;AND TIME
	JRST SETTM

SETCP:	CAME T1,SVPT	;AT END?
	JRST NFIL1	;NO, DO NOT SET
	TLNN FL2,ALPROC	;SOMETHING ALREDY SET?
	HLL FL2,FL3	;NO, SET TO CURRENT PROCESSOR
	POPJ P,		;AND DONE

NOTYET:	MOVE T2,SVEXT(T1)	;GET THE CURRENT EXT
	JUMPN T2,OKREL	;IF HE SPECIFIED AN EXT WE LOSE
	MOVE T2,PXTAB-1(T3)	;ELSE PICK UP ONE
	SOJGE T3,NXEXT
	MOVE T2,SVEXT(T1)	;GET THE ORIGINAL EXT
	MOVEM T2,LEXT
	JRST NOFIL	;ARE OUT OF THINGS TO TRY

	;MAKE IT OKAY IF THE OUTPUT REL FILE IS THERE

OKREL:	TRNN	FL,DOLOD	;IF NOT JUST COMPILING
	JRST	LOSE1		;THEN
	MOVE	T3,LNAM		;PROTECT CURRENT NAME
	MOVE	T1,ONAM		;TRY LOOKING UP
	MOVEM	T1,LNAM		;OUTPUT FILE
	SKIPN	T1,OEXT		;USUNG EXTENSION
	MOVSI	T1,'REL'	;IF GIVEN
	MOVEM	T1,LEXT		;AND TRYING SVPPN
	MOVE	T1,SVPPN
OKREL1:	MOVEM	T1,LPPN
	LOOKUP	LOOK,LNAM
	JRST	.+2
	JRST	FIX1		;FOUND SO NO COMPIL
	JUMPE	T1,LOSE		;IF THIS WASN'T OUR PPN
	SETZ	T1,		;THEN TRY IT NOW
	JRST	OKREL1

LOSE:	MOVEM	T3,LNAM		;RESTORE FILE NAME FOR ERROR MESSAGE
LOSE1:	MOVEM	T2,LEXT		;RESTORE EXTENSION
	JRST	NOFIL		;OUT OF THINGS TO TRY
ALTDEV:	MOVEM T2,LOKNAM	;SAVE FOR LATER
	MOVEM T2,SVDEV(T1)	;AND IN DEVICE FOR OUTPUT
	DEVCHR T2,	;GET CHARACTERISTICS
	TLNE T2,200000	;A DSK?
	JRST	ALTDSK	;YES
	TLNE T2,4	;A DECTAPE?
	JRST	ALTDAT	;YES, 
	TRO FL,NODAT	;NO DATES ON OTHER DEVICES
	JRST OLDAT	;DON'T BOTHER WITH LOOKUP

ALTDSK:	MOVSI 	T2,'DSK'
	CAMN	T2,LOKNAM	;LOGICAL NAME?
	JRST	OKLOOK	;NO, STILL DSK
ALTDAT:	TRZ FL,NOLOOK	;NOT FAILED YET
	OPEN LOOK,LOKINT	;OPEN FOR INPUT
	JRST DEVNA	;NOT THERE
	LOOKUP LOOK,LNAM	;SEE IF FILE IS
	TRO FL,NOLOOK	;NO
	OPEN LOOK,DSKLK	;GET THE DSK BACK
	JRST DSKNA	;I HOPE THIS NEVER HAPPENES
	TRZE FL,NOLOOK	;SEE IF FAILED
	JRST NOTYET	;IT DID
	TLNN	T2,4	;DECTAPE?
	JRST DNLOK	;NO, BUT LOOKUP HAPPENED
	HLRZ	T2,LEXT	;GET EXTENSION LOOKED UP
	CAIE	T2,'REL'
	AOS	LDAT	;IF SOURCE FILE MAKE IT MIDNIGHT TONIGHT
	JRST	DNLOK	;AND CONTINUE

IFE STANSW,<
OUTPPN:	HRRZM T2,SAVPPN	;CONVERT TO SIXBIT FOR OUTPUT
	MOVEI T1,"["	;START OUT
	PUSHJ P,(T3)
	HLRZ T1,T2	;GET NUMBER
	PUSHJ P,OUTOCT
	MOVEI T1,","
	PUSHJ P,(T3)
	HRRZ T1,SAVPPN
	PUSHJ P,OUTOCT
	MOVEI T1,"]"
	JRST (T3)

OUTOCT:	IDIVI T1,10	;OCTAL OUTPUT
	HRLM T2,(P)
	SKIPE T1
	PUSHJ P,OUTOCT
	HLRZ T1,(P)
	ADDI T1,"0"
	JRST (T3)
>
DEFINE X (A,B,C,D,E)<
SIXBIT /B/>

PXTAB:	SIXBIT /REL/
	PROCESS

DEFINE X (A,B,C,D,E)<
B'SW>

ISPTAB:	RELSW
	PROCESS

OUTSIX:	MOVEI T1,0
	LSHC T1,6
	ADDI T1,40
	PUSHJ P,(T3)
	JUMPN T2,OUTSIX
CPOPJ:	POPJ P,

IFN STANSW,<
OUTPPN:	MOVEM T1,SAVPPN	;SAVE IT AWAY
	ANDCMI T2,-1
	MOVEI T1,"["
	PUSHJ P,(T3)
	PUSHJ P,OUTSIX	;PRINT IT
	MOVEI T1,","	;AND A COMMA
	PUSHJ P,(T3)
	HRLZ T2,SVPPN
	PUSHJ P,OUTSIX
	MOVEI T1,"]"
	JRST (T3)
>

OUTSW:	MOVEM T2,SVSWP	;SAVE THE POINTER
	ILDB T1,T2	;PICK UP THE FIRST CHR
	JUMPE T1,CPOPJ	;AND CHECK FOR NULL AS A PRECAUTION
	MOVEI T1,"("
	PUSHJ P,(T3)	;SWITCHES ARE IN () TO PROCESSOR
OUTSW1:	ILDB T1,SVSWP
	JUMPE T1,LPAR
	PUSHJ P,(T3)
	JRST OUTSW1	;A NULL WILL MARK THE END
LPAR:	MOVEI T1,")"
	JRST (T3)
ENTCRF:	MOVE T1,CORTOP	;CHECK TO SEE IF NAME ALREADY THERE
	MOVE T2,ONAM
ENTC1:	CAMN T1,CORT1
	JRST ENTC2
	CAMN T2,1(T1)
	POPJ P,	;NAME THERE, EXIT
	AOJA T1,ENTC1	;CHECK ANOTHERE
ENTC2:	MOVEM T2,@CORTOP	;SAVE IT
	SOS T1,CORTOP
	CAMG T1,SVJFF	;CHECK TO SEE IF CORE EXCEEDED
	PUSHJ P,XPAND
	MOVEI T1,"_"
	PUSHJ P,OUTCRF
	MOVE T2,ONAM
	MOVEI T3,OUTCRF
	PUSHJ P,OUTSIX
	JRST	OUCRLF

FINCRF:	MOVSI IOPNT,-2	;PERMIT ONLY THIS ONE LEVEL
	TRO FL,INCRF	;SAY WE ARE FINISHING
	MOVEM P,SVPDL	;SAVE THE PDL FOR LATER
	MOVE T1,[POINT 7,CRFRDR]
	MOVEM T1,DINPT
FINC1:	PUSHJ P,SCAN	;GET SOMETHING
	TRNN FL,IDF	;IGNORE ALL BUT IDENTIFIERS
	JRST FINC1
	MOVE T1,ACCUM
	MOVEM T1,ONAM	;SET AS NAME
	PUSHJ P,ENTCRF	;ENTER IT
	JRST FINC1
DNCRF:
IFE TEMP,<	RELEASE CHNCRF,0	;LET GO OF THE CHANNEL>
IFN TEMP,<	PUSHJ P,CHKCRF	;CHECK FOR TMPCOR UUO BEING DONE>
	MOVE P,SVPDL	;GET THE ENTERING PDL BACK
	TRZ FL,INCRF	;NO LONGER THERE
	POPJ P,
SETFUD:	SKIPE	FDGFLG		;ENTER DONE ALREADY?
	POPJ	P,		;YES , RETURN
	MOVEI	T3,OUTPIP	;USE PIP FOR NOW
	PUSHJ	P,SCAN		;LOOK AT NEXT CHAR
	CAIE	C,":"		;THERE BETTER BE A NAME
	JRST	SYNERR		;YOU LOSE
	AOBJP	SVPT,NESTTD	;MAKE SPACE FOR FIELDS
	PUSHJ	P,SCANAM	;GO GET THEM
	SKIPE	T2,SVDEV(SVPT)	;A DEVICE?
	PUSHJ	P,OUTDEV	;YES
	SKIPN	T2,SVNAM(SVPT)	;THERE HAS TO BE A NAME
	JRST	SYNERR		;NOT FOUND
	PUSHJ	P,OUTSIX	;OUTPUT IT
	SKIPN	T2,SVEXT(SVPT)	;EXTENSION?
	MOVSI	T2,'REL'	;USE REL  IF MISSING
	PUSHJ	P,OUTEXT
	SKIPE	T2,SVPPN(SVPT)	;PPN
	PUSHJ	P,OUTPPN	;YES
	SUB	SVPT,[1,,1]	;BACK AS IT WAS
	MOVSI	T2,'/B_'	;FORSE BINARY
	PUSHJ	P,OUTSIX
	SETOM	FDGFLG		;ONLY DO IT ONCE
	POPJ	P,		;RETURN

ENTFUD:	PUSH	P,T3		;SAVE T3
	MOVEI	T3,OUTPIP	;USE PIP TIL FUDGE20FIXED FOR CCL
	MOVEI	T1,","		;SETUP COMMA
	SKIPL	FDGFLG		;BUT NOT FIRST TIME THROUGH
	PUSHJ	P,(T3)		;OUTPUT SEPARATING COMMA
	MOVE	T2,ONAM		;GET NAME
	PUSHJ	P,OUTSIX	;OUTPUT IT
	SKIPN	T2,OEXT		;SPECIFIED EXT?
	MOVSI	T2,'REL'	;NO USE DEFAULT
	PUSHJ	P,OUTEXT
	HRRZS	FDGFLG		;COMMA NEXT TIME
	POP	P,T3		;RESTORE T3
	POPJ	P,		;RETURN

DNFUDG:	MOVEI	T3,OUTPIP	;MAKE SURE USING PIP
	PUSHJ	P,OUCRLF	;TERMINATE LINE

IFE TEMP,<RELEAS CHNPIP,0	;LET GO OF CHANNEL>
IFN TEMP,<PUSHJ P,CHKPIP	;CHECK FOR TMPCOR UUO>
	SETZM	FDGFLG		;CLEAR FLAG
	TRZ	FL2,FCHPIP	;AND CHANNEL FLAG
	TLZ	FL3,FUDGSW	;CLEAR FUDGING SWITCH
	POPJ	P,		;RETURN

	
	WORDS (FDGFLG)
	DEFINE X (A,B,C,D,E)<
OUT'B>
PRCTAB:	PROCESS
	OUTLOD

	DEFINE X (A,B,C,D,E)<
IFNB <E>,<SIXBIT /E/>>
INTEXT:	PROCESS

IFN SPRC,<	DEFINE X (A,B,C,D,E)
	<D'SW>>
NXPC:	PROCESS

SW==0

IFDEF SALL,<SALL>
IFE DIRSW,<
DODIR:	TROA	FL,PIPF	;SO *.* WILL WORK
DODIR0:	PUSHJ P,GETPPN+1;GET PROJ-PROG
DODIR1:	PUSHJ P,SCAN	;FIND OUT IF HE WANTS /L OR /F SWITCH
DODIR2:	TRNN FL,IDF	;WAS IT AN IDENT?
	JRST SLSH	;NO, CHECK FOR  "/"
	PUSH	P,SVPPN	;IN CASE WE HAVE SEEN PPN ALREADY
	PUSHJ P,GETNAM	;GET DEV AND FILE NAME
	POP	P,T2	;GET PREVIOUS PPN
	JUMPE	T2,.+3	;WASN'T ONE
	SKIPN	SVPPN	;SEEN ONE AFTER DEVICE?
	MOVEM	T2,SVPPN;NO SO USE ONE BEFORE
	CAIE	C,"]"	;SCAN OVER PPN
	TRNE	FL,IDF	;LAST THING AN IDENT.?
	PUSHJ P,SCAN	;YES, GET NEXT CHAR
SLSH:	CAIE C,"/"
	JRST NOSLSH
	PUSHJ P,SCAN	;WHICH ONE
	TRNN FL,IDF	;MUST SEEN AN IDENTIFIER
	JRST	[PUSHJ	P,SCAN	;TRY NEXT (NUL EXT FAILS)
		TRNN	FL,IDF	;FOUND IDENT. NOW?
		JRST	SYNERR	;NO, FATAL ERROR
		JRST	.+1]	;OK NOW
	MOVS T1,ACCUM
	CAIN T1,'F  '
	JRST SETF
	CAIE T1,'L  '
	JRST SYNERR	;DO NOT RECOGNIZE THIS SWITCH
	TROA FL,LPTFG	;HE WANTS IT ON THE LINE PRINTER
SETF:	TRO FL,FFLG
	JRST DODIR1	;BACK FOR MORE


NOSLSH:	CAIN	C,"["	;PROJ-PROG NUMBER
	JRST	DODIR0	;YES
	MOVE T2,['TTY:/L']
	TRNE FL,LPTFG	;ON LINE PRINTER INSTEAD?
	HRLI T2,'LPT'	;YES
	MOVEI T3,OUTPIP
	TRNE FL,FFLG
	HRRI T2,':/F'
	PUSHJ P,OUTSIX
	MOVSI	T2,'_  '
	PUSHJ	P,OUTSIX
DODIR3:	SKIPE T2,SVDEV	;SEE IF DEVICE SPECIFIED
	PUSHJ	P,OUTDEV	;OUTPUT DEVICE AND COLON
	PUSHJ	P,OUTNAM	;SEE IF NAME AND EXT  OR PROJ-PROG
OPIP1A:	CAIE	C,","
	JRST	OPIP1	;FINISHED
	MOVSI	T2,',  '
	PUSHJ	P,OUTSIX
	PUSHJ	P,SCAN
	CAIN	C,","		;STILL ON COMMA?
	JRST	.-2		;YES, GET RID OF IT
	PUSHJ	P,GETNAM
	JRST	DODIR3
	JRST	OPIP1
>

DODEL:	TRO FL,PIPF	;SET TO ALLOW * AS AN IDENT
	PUSHJ P,SCANAM
	MOVSI T1,'DSK'
	SKIPN SVDEV	;FORCE TO DSK IF NONE
	MOVEM T1,SVDEV
	JRST DEL2
DEL3:	PUSHJ P,SCANAM
DEL2:	MOVEI T3,OUTPIP
	SKIPN T2,SVDEV	;DEVICE?
	JRST NODVC
	PUSHJ	P,OUCRLF
	PUSHJ P,OUTSIX	;DUMP NAME
	MOVE T2,[':/D_  ']
	PUSHJ P,OUTSIX
	JRST DIDDEV
NODVC:	MOVEI T1,","	;IF NO DEV, JUST A ,
	PUSHJ P,OUTPIP
DIDDEV:	PUSHJ P,OUTNAM	;WRITE THE NAME
	PUSHJ P,SCAN	;SEE IF MORE THERE
	CAIN C,","
	JRST DEL3	;GO ON
	TLNN CS,TERMF	;MAKE SURE THAT LINE ENDS PROPERLY
	JRST SYNERR
OPIP1:	PUSHJ	P,OUCRLF
OPIP2:
IFE TEMP,<	RELEASE CHNPIP,0>
IFN TEMP,<	PUSHJ P,CHKPIP	;CHECK FOR TMPCOR UUO>
	MOVSI T1,'PIP'
	MOVEM T1,PCNAM	;LOAD THIS ONE
	JRST DONE1
DOCOPY:	SKIPA	T2,['/X_',,0]	;FOR COPY
DOREN:	MOVSI	T2,'/R_'	;SET FOR RENAME
	PUSH	P,T2		;SAVE IT
	TRO FL,PIPF	;PERMIT * IN FILES
NXTNAM:	PUSHJ P,SCANAM	;GET A FILE NAME
	MOVEI T3,OUTPIP
	SKIPN T2,SVDEV	;SEE IF DEVICE SPECIFIED
	MOVE T2,LOKNAM	;OR SAVED
	MOVEM T2,LOKNAM
	JUMPE	T2,.+2	;IF NO NAME SPECIFIED
	PUSHJ P,OUTDEV	;PUT IT OUT
	PUSHJ P,OUTNAM
	CAIE	C,"]"		;ALWAYS GET RID OF SPARE "]"
	TRNE	FL,IDF		;DON'T SCAN IF WE ALREADY HAVE IT
	PUSHJ P,SCAN
	CAIE	C,"<"	;IS IT PROTECTION?
	JRST	NXTNM1	;NO
	PUSHJ	P,SCAN	;GET NUMBER
	PUSHJ	P,SCAN	;AND DELIMITER
	CAIE	C,">"	;IT BETTER BE
	JRST	SYNERR	;IT WASN'T
	HLRZ	T2,ACCUM;GET 3 NUMBERS
	TLO	T2,'<'
	LSH	T2,^D12	;SHIFT TO LEFT END
	TRO	T2,' > '
	PUSHJ	P,OUTSIX
	PUSHJ P,SCAN
	CAIE	C,"["		;CHECK FOR PROJ-PROG
	JRST	NXTNM1		;NO
	PUSHJ	P,GETPPN+1	;YES, GET IT
	SKIPE	T2,SVPPN	;IF NON-ZERO
	PUSHJ	P,OUTPPN	;PUT IT OUT
	PUSHJ	P,SCAN		;GO BEYOND "]"
NXTNM1:	CAIN	C,"("		;CHECK FOR SWITCHES
	PUSHJ	P,COPYSW	;AND OUTPUT THEM
	MOVE	T2,(P)
	CAME	T2,['/X_',,0]	;IS IT COPY?
	JRST	NOTCPY		;NO, MUST BE RENAME
	MOVS	T1,SVNAM	;GET NAME
	JUMPE	T1,NOTCPY	;ZERO FILE NAME NEEDS /X
	CAIN	T1,'*  '	;WILD CARD?
	JRST	NOTCPY		;YES, USE /X
	MOVS	T1,SVEXT	;NO, TRY EXT
	CAIE	T1,'*  '	;IS THIS WILD CARD?
	MOVSI	T2,'_  '	;NO, SO JUST COPY
NOTCPY:	PUSHJ P,OUTSIX
	CAIE C,"="	;= MUST BE THERE
	JRST SYNERR
COPY1:	PUSHJ P,SCANAM
	SKIPE	T2,SVDEV	;DEVICE SEEN?
	PUSHJ	P,OUTDEV
	MOVEI T3,OUTPIP	;RSET
	PUSHJ P,OUTNAM
	MOVE	T1,(P)		;GET EITHER /X OR /R
	CAMN	T1,['/X_',,0]	;WHICH IS IT?
	JRST	COPY2		;IT WAS COPY
	PUSHJ P,SCAN	;CHECK FOR MORE
FINCPY:	PUSHJ	P,OUCRLF
	CAIN C,","
	JRST NXTNAM	;YES
	TLNN CS,TERMF	;NO MORE, SEE IF END
	JRST SYNERR
	POP	P,T2		;CLEAR STACK
	JRST OPIP2

COPY2:	PUSHJ	P,SCAN		;GET NEXT CHAR
	CAIN	C,"("		;FIRST SEE IF ANY SWITCHES
	PUSHJ	P,COPYSW	;YES
	CAIE	C,","		;MORE COMMAND?
	JRST	FINCPY		;NO, GIVE UP
	MOVEI	T1,","		;OUTPUT THE COMMA
	PUSHJ	P,(T3)
	JRST	COPY1		;GET NEXT NAME

DOPRES:	TRO	FL,PIPF		;SO *.* WILL WORK
	MOVE	T2,[12,,16]	;TABLE FOR STANDARD PROTECTION
	GETTAB	T2,		;GET IT
	  MOVSI	T2,057000	;BETTER THAN NOTHING
	TLO	T2,(1B2)	;PRESERVE BIT
	MOVEI	T1,'<'		;START WITH OPEN ANGLE
	LSH	T1,3		;GET FIRST DIGIT
	LSHC	T1,3		;IN AS SIXBIT
	ADDI	T1,20
	JUMPN	T2,.-3		;FOR ALL OF NUMBER
	LSH	T1,^D12		;LEFT JUSTIFY
	TRO	T1,'> '		;CLOSE PROTECTION
	PUSH	P,T1		;AND SAVE IT
	SETZM	LOKNAM		;NO DEVICE YET
	MOVEI	T3,OUTPIP	;USE PIP
PRES1:	PUSHJ	P,SCANAM	;GO GET FILE NAMES ETC.
	SKIPN	T2,SVDEV	;DEVICE GIVEN
	SKIPA	T2,LOKNAM	;NO, USE LAST
	MOVEM	T2,LOKNAM	;SAVE THIS AS LAST
	JUMPE	T2,.+2		;SKIP IF NO DEVICE
	PUSHJ	P,OUTDEV	;OUTPUT IT
	MOVE	T2,(P)		;GET PROTECTION
	PUSHJ	P,OUTSIX	;OUTPUT IT
	MOVSI	T2,'/R_'	;RENAME FOR PIP
	PUSHJ	P,OUTSIX
	PUSHJ	P,OUTNAM	;OUTPUT NAME.EXT
	PUSHJ	P,OUCRLF	;FINISH WITH CR-LF
	PUSHJ	P,SCAN
	CAIN	C,","		;MORE?
	JRST	PRES1		;YES
	SUB	P,[1,,1]	;STACK BACK IN SYNK.
	JRST	OPIP2

DOPROT:	TRO	FL,PIPF		;SO *.* WILL WORK
	SETZM	LOKNAM		;INITIAL DEVICE
	PUSH	P,[0]		;INITIAL PROTECTION
	MOVEI	T3,OUTPIP	;SET TO USE PIP
PROT1:	PUSHJ	P,SCANAM	;GO GET FILE NAME ETC
	SKIPN	T2,SVDEV	;A NEW DEVICE?
	SKIPA	T2,LOKNAM	;WELL AN OLD ONE THEN?
	MOVEM	T2,LOKNAM	;STORE NEW ONE AS OLD ONE
	CAIN	C,"<"		;DEFAULT PROTECTION?
	SKIPE	SVNAM		;WAS NAME SEEN?
	JRST	.+2		;NO
	JRST	PROT3		;YES, SINCE BEFORE FILE NAME
	JUMPE	T2,.+2		;NO NAME SPECIFIED
	PUSHJ	P,OUTDEV	;PUT IT OUT
	TRNE	FL,SCAN		;DON'T IF WE ALREADY HAVE IT
	PUSHJ	P,SCAN
	CAIE	C,"<"		;PROTECTION CODE
	JRST	PROT2		;NO
	PUSHJ	P,GTPROT	;GET PROTECTION IN T2
	PUSHJ	P,OUTSIX
	PUSHJ	P,SCAN
	CAIE	C,"["		;CHECK AGAIN FOR PPN
	JRST	PROT4		;NO
	PUSHJ	P,GETPPN+1	;YES, GET IT
	PUSHJ	P,SCAN		;PASS OVER "]"
	JRST	PROT4		;ALREADY PUT OUT PROTECTION

PROT2:	MOVE	T2,(P)		;GET DEFAULT PROTECTION
	PUSHJ	P,OUTSIX	;USE IT EVEN IF ZERO
PROT4:	MOVSI	T2,'/R_'	;RENAME FOR PIP
	PUSHJ	P,OUTSIX
	PUSHJ	P,OUTNAM	;NAME.EXT [PPN]
	PUSHJ	P,OUCRLF	;END WITH CR-LF
	CAIN	C,","		;MORE TO COME
	JRST	PROT1		;YES
	SUB	P,[1,,1]	;PUT STACK BACK
	JRST	OPIP2		;AND EXIT

GTPROT:	PUSHJ	P,SCAN		;GET NUMBER
	PUSHJ	P,SCAN		;AND DELIMITER
	CAIE	C,">"		;IT BETTER BE RIGHT ONE
	JRST	SYNERR		;IT WASN'T
	HLRZ	T2,ACCUM	;GET 3 NUMBERS
	TLO	T2,'<'
	LSH	T2,^D12		;SHIFT TO LEFT
	TRO	T2,'> '
	POPJ	P,		;RETURN WITH PROTECTION IN T2 IN SIXBIT

PROT3:	PUSHJ	P,GTPROT	;GET PROTECTION
	MOVEM	T2,(P)		;SAVE AS NEW DEFAULT
	JRST	PROT1		;SCAN AGAIN FOR FILE NAME
	PUSHJ	P,OUTSIX
	PUSHJ	P,SCAN
	CAIE	C,"["		;CHECK AGAIN FOR PPN
	JRST	PROT2		;NO
DOEDIT:	PUSHJ P,SCAN	;START ON THE FILE NAME
DOEDT1:	PUSHJ P,GETNAM
	MOVEI	T3,OUTEDT
	MOVEI	T1,"S"		;COMMAND FOR LINED
;CROCK IN TECO DELETES FIRST CHARACTER
;	TRNN	FL,TECOF	;NOT IF TECO
	PUSHJ	P,OUTEDT	;OUTPUT THE S
	TRNE	FL,TECOF	;IF TECO
	SKIPN	T2,SVDEV	;AND A DEVICE SEEN
	JRST	.+2		;NO, NOT BOTH CONDITIONS
	PUSHJ	P,OUTDEV	;OUTPUT THE DEVICE
	PUSHJ	P,OUTNAM	;OUTPUT THE NAME & EXT
	TRNE	FL,CREATF	;EDIT OR CREATE?
	JRST	DOEDT3		;CREATE (OR MAKE)
	PUSHJ	P,OUCRLF	;EDIT (OR TECO) - OUTPUT CRLF
DOEDT2:
IFE TEMP,<	RELEAS	CHNEDT,0	;END OF COMMAND>
IFN TEMP,<	PUSHJ P,CHKEDT		;CHECK FOR TMPCOR UUO>
	MOVE T1,[SIXBIT /LINED/]
	TRNE FL,TECOF
	JRST	ISTECO		;TECO OR MAKE COMMAND
ENDED:	MOVEM T1,PCNAM
	JRST DONE	;GO GET IT LOADED

DOEDT3:	MOVEI	T1,175		;OLD ALTMODE
	PUSHJ	P,OUTEDT	;ENDS CREATE OR MAKE COMMAND
	JRST	DOEDT2

ISTECO:	MOVE	14,SVNAM	;EDITING THIS PROGRAM
	TRNE	FL,CREATF	;CHECK FOR MAKE COMMAND
	CAME	14,[SIXBIT /LOVE/]	;WITH ARGUMENT OF LOVE
	JRST	ISTEC1		;NO SUCH HACK
	MOVEI	T2,2		;YES. PAUSE THOUGHTFULLY
	CALLI	T2,31		;BY SLEEPING
	STRING [ASCIZ /NOT WAR?
/]
ISTEC1:	MOVE	T1,[SIXBIT /TECO/]	;NAME OF CUSP
	JRST	ENDED

;NOTE: LEAVE THE ABOVE HACK IN FOR SALES DEMOS
IFE LSTRSW,<
OUTLST=OUTPIP		;USE PIP FOR A LISTER
CHNLST=CHNPIP
IFN TEMP,<CHKLST=CHKPIP>>

TYPR:	SKIPA T2,['TTY:/X']
LISTR:	MOVE T2,['LPT:/X']
	MOVEI T3,OUTLST
	PUSHJ P,OUTSIX
	MOVEI	T1,"_"
	PUSHJ	P,OUTLST	;DON'T FORGET "_"
IFE LSTRSW,<TRO	FL,PIPF>	;IF IT'S PIP, ALLOW *.MAC, ETC.
LSTLP:	PUSHJ P,SCANAM	;GET NAME
	SKIPN T2,SVDEV
	JRST	LSTLP1	;USE PREV NAME IF NO NEW NAME
	PUSHJ P,OUTDEV	;OUTPUT IT
LSTLP1:	PUSHJ P,OUTNAM	;FILE NAME
	PUSHJ P,SCAN
IFE LSTRSW,<
	CAIN	C,"("		;SWITCHES?
	PUSHJ	P,COPYSW	;YES, OUTPUT THEM>
IFN LSTRSW,<
	CAIE C,"("	;PAGE SPEC?
	JRST ENDLST	;NO
	MOVEI T1,"("	;OUTPUT THE ( TO FILE
	PUSHJ P,OUTLST
LST1:	PUSHJ P,GETCH	;COPY PAGE SPEC
	MOVE T1,C	;TO OUTPUT AC
	PUSHJ P,OUTLST	;THENCE TO FILE
	CAIE C,")"	;THROUGH END OF ARG
	JRST LST1	;MORE
	PUSHJ P,SCAN	;NOW WHAT?
>
ENDLST:	CAIN C,","	;SHOULD BE COMMA OR CR
	JRST [MOVEI T1,","
		PUSHJ P,OUTLST
		JRST LSTLP]
	TLNN CS,TERMF	;SHOULD BE TERMINATOR
	JRST SYNERR	;WASNT
IFE LSTRSW,<JRST OPIP1>
IFN LSTRSW,<PUSHJ P,OUCRLF	;ADD CRLF TO COMMAND
IFE TEMP,<	RELEASE CHNLST,0>
IFN TEMP,<	PUSHJ P,CHKLST		;CHECK FOR TMPCOR UUO BEING USED>
	MOVE T1,[SIXBIT /LISTER/]
	MOVEM T1,PCNAM
	JRST DONE1>

;TAPE FUNCTIONS

DOEOF:	SKIPA	T2,['(MF)_ ']
DOZERO:	MOVSI	T2,'/Z_'
	JRST	DOREW+2

DOREW:	SKIPA	T2,['(MW)_ ']
DOUNLD:	MOVE	T2,['(MU)_ ']
	TRO	FL,PIPF		;INCASE *.*
	PUSH	P,T2		;SAVE COMMAND
	MOVEI	T3,OUTPIP	;OUTPUT CHANNEL
	TRO	FL,PIPF		;JUST IN CASE
TAPEF:	PUSHJ	P,SCANAM	;GO GET DEVICE ETC
	SKIPE	T2,SVDEV	;WAS DEVICE SPECIFIED?
	PUSHJ	P,OUTDEV	;YES, OUTPUT IT
	PUSHJ	P,OUTNAM	;FILENAME AND PPN
	MOVE	T2,(P)		;GET TAPE FUNCTION
	PUSHJ	P,OUTSIX
	PUSHJ	P,OUCRLF	;FINISH LINE
	CAIN	C,","		;MORE COMMAND?
	JRST	TAPEF		;YES
	POP	P,T2		;CLEAR STACK
	JRST	OPIP2

DOSKIP:	TDZA	T2,T2		;SIGNAL FORWARDS BY 0
DOBKSP:	SETO	T2,		;BACKWARDS BY -1
	PUSH	P,T2		;STORE IT
	PUSH	P,[0]		;AND COUNT
	TRO	FL,PIPF		;JUST INCASE
TAPESP:	MOVEI	T3,OUTPIP	;USE PIP
	PUSHJ	P,SCANAM	;GO GET SOMETHING
	SKIPE	T2,SVDEV	;FIND A DEVICE?
	PUSHJ	P,OUTDEV	;YES
	SKIPN	T2,SVNAM	;FIND SOMETHING IN FILE NAME?
	JRST	SYNERR		;MUST FIND SOMETHING
	SETO	T1,		;FIND THE MASK
	LSH	T1,-6		;MUST BE AT LEAST ONE CHAR. ANYWAY
	TDNE	T2,T1		;DON'T MASK REAL CHAR.
	JRST	.-2		;SHIFT AND TRY AGAIN
	SETZ	T4,		;START AT FRONT OF TABLE
TPSRCH:	MOVE	T3,TPTBL(T4)	;GET FUNCTION
	ANDCM	T3,T1		;MASK IT
	CAMN	T2,T3		;FOUND IT?
	JRST	TPFND		;YES
	CAIGE	T4,TPLEN	;STILL IN TABLE
	AOJA	T4,TPSRCH	;YES, TRY NEXT
	TLNE	T2,(1B0)	;IS IT A NUMBER?
	JRST	SYNERR		;NO
	MOVEM	T2,(P)		;REPLACE DUMMY COUNT
	JRST	TAPESP


TPFND:	MOVEI	T3,OUTPIP	;RESTORE PIP
	MOVSI	T2,'(M '	;START OF SWITCH
	SKIPE	(P)		;NUMBER SPECIFIED
	TLO	T2,'  #'	;YES
	PUSHJ	P,OUTSIX	;OUTPUT IT
	POP	P,T2		;GET NUMBER
	SKIPE	T2		;DON'T BOTHER IF ZERO
	PUSHJ	P,OUTSIX
	MOVE	T2,TPFN(T4)	;PICK UP PIP CHAR
	SKIPE	(P)		;IF FORWARDS
	MOVSS	T2		;NO, BACKSPACE
	HLLZS	T2		;CLEAR RIGHT
	PUSHJ	P,OUTSIX
	PUSHJ	P,OUCRLF	;FINISH WITH CRLF
	CAIN	C,","		;MORE TO COME
	JRST	DOBKSP+2	;YES, START AGAIN
	JRST	OPIP2		;COMMON END

TPTBL:	SIXBIT	/FILES/
	SIXBIT	/RECORD/
	SIXBIT	/EOT/
TPLEN==.-TPTBL

TPFN:	'A)_',,'B)_'
	'D)_',,'P)_'
	'T)_',,'T)_'

OUTDEV:	PUSHJ	P,OUTSIX	;OUTPUT DEVICE
	MOVEI	T1,":"		;AND A COLON
	JRST	(T3)		;RETURN TO USER

OUTNAM:	SKIPN T2,SVNAM
	JRST OUTPP
	PUSHJ P,OUTSIX
	SKIPE T2,SVEXT
	PUSHJ P,OUTEXT
OUTPP:	SKIPN T2,SVPPN
	POPJ P,
	JRST OUTPPN

OUTEXT:	MOVEI	T1,"."
	PUSHJ	P,(T3)
	JRST	OUTSIX

OUCRLF:	MOVEI	T1,15		;CARRIAGE RETURN
	PUSHJ	P,0(T3)		;TO CURRENT OUTPUT FILE
	MOVEI	T1,12		;LINE FEED
	JRST	0(T3)		;TO OUTPUT FILE

	PUSHJ	P,GETCH		;COPY THE SWITCH
COPYSW:	MOVE	T1,C		;TO OUTPUT AC
	PUSHJ	P,(T3)		;THENCE TO FILE
	CAIE	C,")"		;UNTIL END OF SWITCH
	JRST	COPYSW-1	;BUT NOT YET
	JRST	SCAN		;GET NEXT AND RETURN
;HERE IS THE SET OF OUTPUT ROUTINES
XALL
IFN TEMP,<			;USE DUMP MODE IF TMPCOR MAY BE USED

DEFINE X (A,B,C,D,E)<
	U (B'DATA,0)
OUT'B:	TRON	FL2,FCH'B	;HAS CHAN BEEN SET UP?
	PUSHJ	P, B'INITCH
B'DNINIT: SOSG	B'OBUF+2
	JRST	B'OU1		;NONE LEFT
	IDPB	T1,B'OBUF+1
	POPJ	P,
B'OU1:	SKIPN	B'FLG		;HAS THE DISK BEEN INITIALIZED
	PUSHJ	P,B'INOLD	;INIT DSK FOR OUTPUT
	SETOM	B'FLG		;MARK THAT TMPCOR NO LONGER USED
	MOVEI	T5,B'DATA
	PUSHJ	P,%%OUT		;FORM I/O WORD
	OUT	CHN'B,B'OBUF
	JRST	B'ROUT
	JRST	OUTER		;OUTPUT ERROR
B'ROUT: PUSHJ	P,%%ROUT	;SET UP BUFFER AGAIN
	JRST	B'DNINIT+2
B'INITCH: PUSHJ	P,CHKRM		;GET BUFFER SPACE FOR CHARACTERS
	PUSH	P,T1		;SAVE IT
	MOVEI	T5,B'DATA	;START OF DATA
	JRST	%%BUFR		;COMMON CODE
B'INOLD: PUSH	P,T1		;SAVE T1
IFDIF <A><MACX11>,<
	MOVEI	T1,<SIXBIT /A/>_-22 ;CUSP NAME>
IFIDN <A><MACX11>,<
	MOVEI	T1,<SIXBIT /B/>_-22 ;AVOID CONFLICT WITH MACRO-10>
	PUSHJ	P,%%NAME	;SET UP NAME
	MOVEI	T1,16		;SET MODE TO DUMP RECORD
	MOVEM	T1,FSINIT
	SETZM	FSBHD		;CLEAR BUFFER HEADERS
	OPEN	CHN'B,FSINIT	;INIT THE F/S
	  EXIT			;ERROR
	ENTER	CHN'B,NAME
	  JRST	FIU		;LOSE BIG
	JRST	TPOPJ1	;WE HAVE INITED IT

CHK'B:	SKIPE	B'FLG		;IS TMPCOR BEING USED?
	JRST	CK1'B		;NO, RELEASE DEVICE
	PUSH	P,T1		;SAVE AC T1
IFDIF <A><MACX11>,<
	MOVSI	T1,<SIXBIT /A/>_-22 ;CUSP NAME>
IFIDN <A><MACX11>,<
	MOVSI	T1,<SIXBIT /B/>_-22 ;AVOID CONFLICT WITH MACRO-10>
	MOVEI	T5,B'DATA	;START OF DATA
	PUSHJ	P,%%CHK		;COMMON CODE
	POP	P,T1		;RESTORE T1
	PUSHJ	P,B'INOLD		;GO USE THE DISK FOR FILE
CK1'B:	PUSHJ	P,%%OUT		;SET UP I/O WORD
	OUTPUT	CHN'B,B'OBUF
	RELEASE CHN'B,0		;RELEASE DEVICE
	POPJ	P,			;RETURN

U (B'FLG,1)
	%%FLG==B'FLG-B'DATA

U (B'OBUF,3)
	%%OBUF==B'OBUF-B'DATA
	PAGE
>>
IFE TEMP,<			;IF NOT TMPCOR USE BUFFERED MODE

DEFINE X (A,B,C,D,E)<
	U (B'DATA,0)
OUT'B:	TRON FL2,FCH'B	;IS IT INITTED
	PUSHJ P, B'INITCH
B'DNINIT: SOSG B'OBUF+2
	JRST B'OU1		;NONE LEFT
	IDPB T1,B'OBUF+1
	POPJ P,
B'OU1:	OUT CHN'B,0
	JRST	B'DNINIT+2
	JRST OUTER		;OUTPUT ERROR
B'INITCH: PUSHJ P,CHKRM	;GET BUFFER SPACE FOR CHARACTERS
	PUSH P,T1		;SAVE IT
	MOVEI	T1,1		;SET MODE TO AL
	MOVEM	T1,FSINIT
	MOVSI	T1,B'OBUF	;OUTPUT BUFFER
	MOVEM	T1,FSBHD	;SAVE IN OPEN BLOCK
	OPEN	CHN'B,FSINIT	;INIT THE F/S
	  CALLI	12		;ERROR
	OUTBUF CHN'B,2	;SET UP BUFFERS
IFDIF <A><MACX11>,<
	MOVEI T1,<SIXBIT /A/>_-22 ;CUSP NAME>
IFIDN <A><MACX11>,<
	MOVEI T1,<SIXBIT /B/>_-22 ;AVOID CONFLICT WITH MACRO-10>
	PUSHJ P,%%NAME	;SET UP NAME
	ENTER CHN'B,NAME
	JRST FIU	;LOSE BIG
	JRST TPOPJ1	;WE HAVE INITED IT

U (B'OBUF,3)
	%%OBUF==B'OBUF-B'DATA
	PAGE
>>
;COMMON OUTPUT ROUTINES

IFN TEMP,<
%%BUFR:	HRRZ	T1,.JBFF	;GET START OF BUFFER
	SETZM %%FLG(T5)		;MARK THAT TMPCOR IS BEING USED
	MOVEM	T1,%%OBUF(T5)	;MARK BUFFERS SET UP
	SOS	%%OBUF(T5)	;FOR IOWD
%%BFR1:	HRLI T1,440700		;GET CHAR AND SIZE INFO FOR POINTER
	MOVEM T1,%%OBUF+1(T5)	;SET UP BYTE POINTER IN HEADER
	PUSH P,T2		;SAVE IT
	HRLS T1			;SET UP BLT WORD
	ADDI T1,1		;JOBFF+3,,JOBFF+4
	SETZM -1(T1)		;ZERO FIRST WORD
	MOVEI T2,176(T1)	;GET END OF BUFFER AREA
	BLT T1,(T2)		;ZERO BUFFER AREA
	MOVEI T1,400*5		;GET CHARACTER COUNT
	MOVEM T1,%%OBUF+2(T5)	;HEADER HAS BEEN COMPLETELY DUMMIED
	JRST	TPOPJ		;RESTORE T2 AND T1


%%CHK:	MOVEM T1,TMPFIL		;STORE FILE NAME IN TMPCOR BLOCK
	MOVE T1,%%OBUF(T5)	;PICK UP START OF BUFFER
	HRRM T1,TMPFIL+1	;STORE IT IN TMPCOR OUTPUT BLOCK
	HRRZ T1,%%OBUF+1(T5)	;PICK UP END OF BUFFER
	SUB T1,%%OBUF(T5)	;GET WORD COUNT
	CAILE	T1,200		;ONLY ALLOW 200 WORDS FOR TMPCOR
	POPJ	P,		;TOO MANY SO USE DSK
	MOVNS T1		;NEGATE IT
	HRLM T1,TMPFIL+1	;IOWD IS NOW SET UP
	MOVE T1,[XWD 3,TMPFIL]	;SET UP FOR WRITE
	TMPCOR T1,		;WRITE OUT FILE INTO CORE
	POPJ P,			;IT DIDN'T FIT USE DISK
	POP P,(P)		;REMOVE ONE RETURN
	JRST TPOPJ1		;RESTORE T1 AND RETURN 

%%OUT:	PUSH	P,T1		;SAVE AN AC
	MOVE	T1,%%OBUF(T5)	;START OF LIST
	HRRZ	T1,%%OBUF+1(T5)	;END OF LIST
	SUB	T1,%%OBUF(T5)	;LENGTH
	MOVNS	T1
	HRLM	T1,%%OBUF(T5)	;IOWD
	SETZM	%%OBUF+1(T5)	;FINISH LIST
	JRST	TPOPJ1

%%ROUT:	PUSH	P,T1
	HRRZS	%%OBUF(T5)	;RESET HEADER
	MOVE	T1,%%OBUF(T5)
	ADDI	T1,1
	JRST	%%BFR1		;SET UP BYTE POINTER AND WORD COUNT
>

%%NAME:	HLL T1,JOBNAM	;JOB NUMBER IN SIXBIT
	MOVEM T1,NAME
	MOVSI T1,SIXBIT /   TMP/
	MOVEM T1,NAME+1
	SETZM NAME+2
	SETZM NAME+3
IFE FASTFS,<
	SKIPN	FSNAME		;DO WE HAVE FASTEST F/S
	JRST	FNDFST		;NO, GO GET IT>
	POPJ P,
PROCESS
;ALSO THESE
X LOADER,LOD
IFN LSTRSW,<X LIST,LST>
X PIP,PIP
X CREF,CRF
X EDT,EDT
;DATA STORAGE ASSIGNMENTS
IFDEF SALL,<SALL>

PDP:	IOWD	PDL,PDLB		;INITIAL PDL POINTER

WORDS <PCNAM,SAVPPN,SVSWP,PCNUM,OLDEXT,SDAT,STIM,SAVCHR>
WORDS <ACCUM,DINPT,DINCT,SVJFF,CORTOP,CORT1,SVRPP,NUMAT>
WORDS <SVIND,SVPDL,JOBNAM,BROCNT,LODSP2,LODCT2,LODSP,LODCTR>

U (LODSBK,<LODSCT/5+1>)
U (LODSB2,<LODSCT/5+1>)

WORDS <SWBKB,SWBKL>

U (SWBKS,NFILE)
U (ONAM,1)
U (OEXT,1)

U (SVDEV,NFILE)
U (SVNAM,NFILE)
U (SVEXT,NFILE)
U (SVPPN,NFILE)

U (DDTBUF,^D30)
U (LOOKBF,3)
U (PDLB,PDL+1)
U (SWBLK,SWBK+1)
U (OPENB,3)
U (IOPD,<<NESTDP+2>*3+1>)
U ERRBUF,22		;FOR TYPEOUTS
U BUFTAB,<NESTDP+2>		;WHERE THE BUFFERS ARE FOR FILES
U FREBUF,<NESTDP+2>		;FREED BUFFERS
IFN TEMP,<U (TMPFIL,2)>
WORDS	<FSINIT,FSNAME,FSBHD>
;THIS IS THE PART THAT MUST BE INITIALIZED IF PURE.
;JUST USED AS IS IF IMPURE

WORDS <RUNBLK,NAME,LEXT,LDAT,LPPN,ZZZ>
PURGE ZZZ
LNAM=NAME
IFN PURESW,<
INIDAT:
U (INILOW,0)		;WHERE IT GOES IN THE LOW SEGMENT
	PHASE	INILOW>

LOKINT:	1
LOKNAM:	0
	XWD LOOKBF,LOOKBF
DSKLK:	1
	SIXBIT /DSK/
	XWD LOOKBF,LOOKBF

FCOMD:	ASCII /@***SVC.TMP
/
	BYTE (7) 177,177	;MARK EOF

FCOMD2:	ASCII /@***EDS.TMP
/
	BYTE (7) 177,177

CRFRDR:	ASCII /@***CRE.TMP/
	BYTE (7) 177,177

IFN PURESW,<
	DEPHASE
INITOP==.		;END OF INITIALIZED DATA
INILEN==INITOP-INIDAT	;LENGTH OF DATA
U (INILOW,INILEN)	;BLOCK OF STORAGE FOR DATA
>
U (LOWTOP,0)

	END	STPT
>
@