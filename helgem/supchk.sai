







begin "SUPCHK"
COMMENT SUPCHK.SAI -------------------------------------------------

	SUPCHK is a master program that successively builds auxiliary
circuits to a list of target hosts, checks for pending mail to the
username OPER and runs a slave program on the target host that collects 
information on pending requests and sends them back to SUPCHK.
Once activated, SUPCHK does the following:

     1. Build AUX circuits to each host included in the HOST.LST file.
        For each host: 

          a. Collect oper mail.

          b. Activate the slave program (SLVSUP).

          c. Interpret the codes and signals generated by SLVSUP.

          d. Report the results to the tty on which it runs. 

     2. Sleep for a specified interval then repeat 1 - 2.


   SLVSUP exists on all  PDP-10 hosts in the UTIL directory.  It is
written in MACRO.  Through a series of specialized single-character
codes, SLVSUP communicates with the master program that is running it
(SUPCHK) and, if the proper responses are received from SUPCHK,
accesses files in the SPOOL and *1BATCH directories that contain info on
pending requests.  The files accessed by SLVSUP are: (SPOOL)SPLCNT,
(*1BATCH)SSPOOL.DAT, and (*1BATCH)PPRTMP.DAT.  SLVSUP will also generate
specific error codes that can be interpreted by SUPCHK if there is
any trouble encountered when accessing these files.






		  SUMMARY OF SLVSUP INTERACTION CODES
		  -----------------------------------

The following are the normal codes sent by SLVSUP, the responses it
expects from the master and what the interaction means:

SENDS:	EXPECTS:	MEANS:
------	--------	------------------------------------------------
ppabcd	ABCD		Normal handshake, SLVSUP is active and ready to run.
i	nothing		Handshake accepted, all is well.
`	`		Error on handshake, repeat abcd string.
k	K		Ready to send Spool Count (SPLCNT file).
v	V		Ready to send SSPOOL.DAT records.
w	W		Done sending SSPOOL.DAT records.
g	G		Ready to send first PPRTMP.DAT record.
n	N		Ready to send another PPRTMP.DAT record.
kk	K		Done sending PPRTMP.DAT records.
x	X		Done sending block of data, ready to send another.
f	F		No batch requests to report (file empty).
e	nothing		Normal exit from SLVSUP.

In addition, the following error codes may be sent by SLVSUP:

CODE:	EXPECTS:	ERROR:
-----	--------	------------------------------------------------
u	nothing		All purpose error code for SSPOOL.DAT or SSPOOL.BAK
			files.  If any problems are encountered with these
			files, SLVSUP sends the "u" and proceeds to look for
			pending batch requests.
h	H		The "h" precedes all other error codes (aside from
			the "u" error above) and waits for an "H" from the
			master before sending the actual error code.  The 
			actual error codes (below) are always two control
			characters.
^A^A	nothing		Error on inputting PPRTMP.DAT file, abort.
^K^K	nothing		PPRTMP.DAT file not found, abort.
^L^L	nothing		Error outputting PPRTMP.DAT file, abort.
^M^M	nothing		Error renaming PPRTMP.DAT as PPRCLR.DAT, abort.
^N^N	nothing		Unable to open PPRCLR.DAT file after rename, abort.
^O^O	nothing		Error creating new PPRTMP.DAT file, abort.
^P^P	nothing		PPRCLR.DAT file expected but not found, abort.
^Q^Q	nothing		Error inputting PPRCLR.DAT, abort.
^R^R	nothing		Format error on PPRCLR.DAT, abort.
^S^S	nothing		Error deleting PPRCLR.DAT, abort.
^T^T	nothing		Unable to open SPLCNT file, abort.

In addition to being able to interpret the above SLVSUP codes, SUPCHK
translates the text being sent by SLVSUP.
Text is sent in blocks of 96 characters and is preceded by one 
of the "ready to send" codes above ("v", "g", "n" or "x").  Carriage
return/line feed pairs are translated into the ASCII code octal 155 
("m") and are counted as only one character in the 96 character block.
All other ASCII codes have octal 40 subtracted from them, which in 
effect translates lower case to upper case (to distinguish text from 
SLVSUP codes).  SUPCHK translates back to proper ASCII codes in order
to create legible text.





NOTE:

1.  SUPCHK will abort if the user name of the current user is not the
same as the user name in the body of the macro "ValidUserName".

2.  On each host there must be a file named HOST.LST that contains a
list of the hosts that are valid for that center.  The user can update
the host list (with SUPCHK) in order to keep the lists current.  



-----------------------------------------------------------------------;

require ('1 lsh 18) lor '0 version;
require "(SAILIB)sail.def" source!file;
require "(MPL)UUOSYM.SAI" source!file;
require "(SAILIB)xtend.dcl" source!file;

define  nhosts = 30,
	TimeOut = 10,
	Asterisks = {for a_1 upto 72 do print("*") ; print(crlf) },
	AlertOperator = {print(crlf,#lf,#lf,#bel,#bel,#bel)},
	DefaultWaitPeriod = 15,
	SiteFileName = {"(UTIL)HOST.LST"}, 
	ValidUserName = {"OPER"}; ! to be sure correct mail is collected ;
				  ! MUST be caps ;
boolean AbortHostError, ! Signal to abort current host due to error ;
	AUXTRACE,
	ReDoingFailures, ! Set if can't log on to one host ;
	CircuitGone, ! Set when auxinc returns -1 ;
	!Trace,        ! enable user/debugger to see which hosts
                         are being procesed, as they are processed.
                         true when ^Z is typed in response to any Y/N question;
	SecondPassInProgress; ! signal to use array of failed hosts ;

itemvar AUXDEAD;
integer inbrchar,
	CurrentHost,
	AUXPORT,
	ineof,
	outchan,
	h, ! hostloop index ;
	a, ! "*" counter ;
	WaitPeriod, ! time to sleep between polling of hosts ;
	NumOfBadHosts, ! number of failures during first pass ;
	LastHost; ! array position of last host in list ;

string  UserName, ! used in AUXCRE ; 
	ErrMsg,
	ValidUser, ! user name confirmed same as ValidUserName (above) ;
	line,SiteNameLine,SiteID;

integer array hosts[0:nhosts-1], ! store hosts read in from host file ;
	      FailedHosts[0:nhosts-1]; ! store failed hosts ;

integer procedure CREAUX (string UNAME);
!----------------------------------------------------------------------;

! Build aux circuit to User and host specified in UNAME;

!----------------------------------------------------------------------;
begin   "CREAUX"
    integer I;
    integer array X[0:5];

    for I _ 0 upto 5 do X[i] _ cvasc(UNAME[1+5*i to 5+5*i]);
    AUXPORT _ I _ calli(location(X[0]),calli!CREAUX);
    if !SKIP! then return(AUXPORT);
    case !lh(I) of begin

      [CXSUP#] case !rh(I) of begin
                 [CXSFE#] ErrMsg _ "?FORMAT ERROR" ;
                 [CXSBU#] ErrMsg _ "?USER NOT IN MUD" ;
                 [CXSBM#] ErrMsg _ "?BAD MUD" ;
                 [CXSHU#] ErrMsg _ "?HOST UNAVAILABLE" ;
                 [CXSDF#] ErrMsg _ "?DOWCRLFINE LOAD/DIALOUT REQUEST FAILURE" ;
                 [CXSTO#] ErrMsg _ "?TIMEOUT" ;
                 [CXSAB#] ErrMsg _ "?ACCESS BARRED" ;
                 [CXSIS#] ErrMsg _ "?ERROR IN ISIS" ;
                 [CXSLQ#] ErrMsg _ "?LONG QUEUE IN SUPERVISOR" ;
                 else ErrMsg _ "?UNKNOWN SUPERVISOR ERROR CODE: '"&cvos(!rh(I))
               end;

      [CX2AX#] ErrMsg _ "?TOO MANY CIRCUITS W'OUT AC LICENSE" ;

      [CXLOG#] ErrMsg _ "?NOT YOUR USERNAME W'OUT AC LICENSE" ;

      [CXDCB#] ErrMsg _ "?NO ROOM IN MONITOR" ;

      [CXNRR#] ErrMsg _ "?SUP DID NOT RESPOND TO ORIGINAL REQ" ;

      [CXNRL#] ErrMsg _ "?SUP DID NOT RESPOND TO LOGIN MESSAGE" ;

      [CXNCH#] ErrMsg _ "?SUP DID NOT SUPPLY A CIRCUIT" ;
 
      [CXERR#] ErrMsg _ "?SUP ERROR FROM ORIGINAL REQUEST" ;

      else     ErrMsg _ "?UNKNOWN CREAUX ERROR CODE: '"&cvos(!lh(I) )

    end;
    print(crlf);
    !SKIP! _ false;
    return(-1);
end     "CREAUX";

simple procedure AUXOUT(string S);
!----------------------------------------------------------------------;
!----------------------------------------------------------------------;
begin!code "AUXOUT"
        HRL     1,AuxPort;
        HRRI    1,!AXOPC;
        HRRZ    2,-1(SP);
        MOVE    3,0(SP);
        AUXCAL  1,2;
end "AUXOUT";

simple integer procedure AUXIN (integer TIM(0) );
!----------------------------------------------------------------------;
!----------------------------------------------------------------------;
begin   "AUXIN"
    integer C;
    calli( (auxport lsh 27) + !hl('111) + TIM, calli!HIBER);
    if !SKIP! then begin
        C _ auxclv(AuxPort,0,!AXI8S);
        if AuxTrace then outchr(C);
        if !SKIP! then return(C) else return(-1);
    end;
    auxport _ !hl(1);
    if typeit(AuxDead)=8 then apply(datum(AuxDead));
    !SKIP! _ false;
    return(-1);
end     "AUXIN";

simple procedure AUXZAP;
!----------------------------------------------------------------------;
!----------------------------------------------------------------------;
begin!code
        MOVE 1,AuxPort;
        uuo!ZAPCIR 1,;
         JFCL;
end;



string procedure GetDate;
!----------------------------------------------------------------------;

! returns MM/DD/YYYY .                                                   ;

!----------------------------------------------------------------------;
Begin "GetDate"
  integer Day,Month,Year,Raw;
  Raw _ calli( 0,'14 );
  Month _ ( ( Raw DIV 31 ) MOD 12 ) + 1;
  Day _ ( Raw MOD 31 ) + 1;Year _ ( Raw DIV 365 ) + 64;
  Return( CVS( Month )&"/"&CVS( DAY )&"/"&CVS( Year ) );
End "GetDate";

string procedure GetTime;
!----------------------------------------------------------------------;

! returns HH:MM .                                                      ;

!----------------------------------------------------------------------;
Begin "GetTime"
  string sHours,sMinutes;
  integer Hours,Minutes,Raw;
  Raw _ calli( 0,'23 );
  Hours _ ( ( Raw DIV 1000 ) DIV 3600 );
  Minutes _ ( ( ( Raw DIV 1000 )-( Hours * 3600 ) ) DIV 60 );
  if Hours < 10 then
    sHours _ ( "0"&CVS( Hours ) )
  else
    sHours _ ( CVS( Hours ) );
  if Minutes < 10 then
    sMinutes _ ( "0"&CVS( Minutes ) )
  else
    sMinutes _ ( CVS( Minutes ) );
  Return( sHours&":"&sMinutes );
End "GetTime";

integer procedure GetWaitPeriod;
!----------------------------------------------------------------------;

! Obtain wait period from operator.                                    ;

!----------------------------------------------------------------------;
begin "GetWaitPeriod"
	integer foo,
		Period;
	string  line,
		SavLine;
while true do
  begin "WaitPeriodLoop"
    print( "ENTER RESTART INTERVAL [DEFAULT ");
    print( cvs( DefaultWaitPeriod )," MINUTES]: " );
    if NOT EQU( line _ SavLine _ inchwl,null ) then  ! check for <cr> ;
      if EQU ( line,"?" ) then                       ! help ;
        begin "help"
          print( crlf,#lf,"THIS PROGRAM WILL POLL DESIGNATED SYSTEMS ",crlf );
          print( "     WITH A SPECIFIED WAIT PERIOD BETWEEN EACH RUN. ",crlf );
          print( "ENTER EITHER: ",crlf );
          print( "- WAITPERIOD PERIOD IN MINUTES <CR>",crlf );
          print( "- <CR> (ONLY) FOR DEFAULT PERIOD OF " );
          print( cvs( DefaultWaitPeriod )," MINUTES",crlf );
          AlertOperator;
        end "help"
      else
        begin "make sure it is an integer"
          period _ intscan( line,foo );
          if foo = -1 then ! integer only ;
            begin
              print( crlf&"?"&Savline&"?"&crlf&#lf );
              continue;
            end;
          Return( period ); ! any integer obtained is returned ;
        end "make sure it is an integer"
    else
      ! Default is used if response was <cr> only;
      Return( DefaultWaitPeriod );
  end "WaitPeriodLoop";
end "GetWaitPeriod";

simple procedure Waiting( integer WaitPeriod );
!----------------------------------------------------------------------;

! Waits for a specified period.                                        ;

!----------------------------------------------------------------------;

begin "Waiting"

print( "BEGINNING ",cvs( WaitPeriod )," MINUTE WAIT  " );
print( GetDate,"  ",GetTime,crlf,#lf,#lf,#lf );
calli( !xwd( 2,WaitPeriod ),calli!Hiber ); ! zzzzz ;
end "Waiting";

string procedure SeeIfValidUser; ! $$ ;
!----------------------------------------------------------------------;

! If the logged on user-name is the same as the macro "ValidUserName" then ;
! return the user-name, else abort.                                        ;

!----------------------------------------------------------------------;

begin "user name"
	string temp;
temp _ ( cv6str( calli( -1 lsh 18 lor -'22, '41 ) )
       & cv6str( calli( -1 lsh 18 lor -'21, '41 ) ) );
if EQU(temp,ValidUserName) then 
  return(temp)
else
  usererr( 0,0,"SUPCHK CANNOT BE RUN BY USER NAME ["&temp&"]."&crlf&
               "MUST BE LOGGED IN AS ["&ValidUserName&"].","X" );

End   "user name";

string procedure AddForty( integer C );
!----------------------------------------------------------------------;

! SLVSUP sends most chars with 40 subtracted, so the uncorrected text  ;
! would consist of a bunch of punctuation characters and numbers.      ;
! Adding '40 to this apparent garbage converts it to uppercase chars   ;
! which make sense.  This procedure is applied to any char coming which ;
! has an ASCII value < '141. Any characters received from SLVSUP with  ;
! ASCII values > '140 (lower case letters) are special control characters ;
! and this function returns them unchanged.                               ;

!----------------------------------------------------------------------;

begin
    if C > '140 then  ! lower case chars are all special ;
      if C = "m" then ! "m" is SLVSUP signal to insert crlf into text. ;
        return( crlf )
      else
        return( C ) ! return lower case char unchanged. ;
    else
      return( C + '40 ); ! convert to a letter ;
end;

simple procedure Fatal( integer Host ; String Msg ; integer Location );
!----------------------------------------------------------------------;

! Handles errors not reported by SLVSUP (usually circuit trouble).     ;

!----------------------------------------------------------------------;
BEGIN
print( SiteID & cvs( Host )," :  " ); ! begin message to operator. ;
if Equ(Msg,null) then       ! No Message supplied in procedure call ;
  if EQU(ErrMsg,null) then  ! No AUXCRE supplied error message ;
    print("CIRCUIT ZAPPED OR TIMEOUT #",cvs(location),"." )
  else                      ! Use AUXCRE supplied error message ;
    print( ErrMsg," #",cvs(location),"." )
else                        ! Use Message supplied in procedure call ;
  print(Msg," #",cvs(location),"." );
AlertOperator;
auxzap; ! do not continue this host if error ;
AuxPort _ -1;
ErrMsg _ null;
AbortHostError _ True; ! Signal to abort current host due to error. ;
CircuitGone _ true; ! skip back to beginning of hostloop. ;
  
END;

simple procedure ErrorRoutine( integer HostNum ); 
!----------------------------------------------------------------------;

! responses to errors generated by SLVSUP.                             ;

!----------------------------------------------------------------------;

begin "ErrorRoutine"
	integer ch;

auxout( "H" ); ! tell SLVSUP to send error code ;
ch _ AuxIn( TimeOut ); ! error codes are sent twice in succession ;
if ch = -1 then
  BEGIN
    Fatal( HostNum , null , 1 );
    return;
  END;
ch _ AuxIn( TimeOut ); ! second time ;
if ch = -1 then
  BEGIN
    Fatal( HostNum , null , 2 );
    return;
  END;

print( SiteID & cvs( HostNum ),"  - " ); ! begin message to operator ;
case CH of begin

  ['1]  ! ^A ; print( " ERROR INPUTTING PPRTMP.DAT FILE," );

  ['13] ! ^K ; print( "PPRTMP.DAT FILE NOT FOUND," );  

  ['14] ! ^L ; print( "ERROR OUTPUTTING PPRTMP.DAT FILE," );

  ['15] ! ^M ; print( "ERROR RENAMING PPRTMP.DAT AS PPRCLR.DAT," );

  ['16] ! ^N ; print( "UNABLE TO OPEN PPRCLR.DAT FILE AFTER RENAME" );

  ['17] ! ^O ; print( "ERROR CREATING NEW PPRTMP.DAT FILE," );

  ['20] ! ^P ; print( "PPRCLR.DAT FILE EXPECTED BUT NOT FOUND," );

  ['21] ! ^Q ; print( "ERROR INPUTTING PPRCLR.DAT," );

  ['22] ! ^R ; print( "FORMAT ERROR ON PPRCLR.DAT," );

  ['23] ! ^S ; print( "ERROR DELETING PPRCLR.DAT," );

  ['24] ! ^T ; print( "UNABLE TO OPEN SPLCNT FILE," );

  else  print( "UNKNOWN ERROR CODE: "&cvs(ch)&" FROM SLVSUP," )

  end; ! case ;
print( "ABORT",crlf );
AlertOperator;
AuxZap; ! do not continue this host if error ;
AbortHostError _ True; ! Signal to abort current host due to error ;
end "ErrorRoutine";

simple procedure ReadSpoolReq( integer host );
!----------------------------------------------------------------------;

! get pending spool requests and print them.                           ;
! looks for "w" from SLVSUP, indicating the end.                       ;

!----------------------------------------------------------------------;

begin "ReadSpoolReq"
	integer ch;
	string  CStr; ! "ch" converted by adding 40 ;
	boolean FirstCharWasW; ! first char received in a spool rec should
                                 not be 'w' since this indicates end ;

auxout( "V" );   ! Indicate ready to receive ;
ch _ AuxIn( TimeOut );
if ch = -1 then
  BEGIN
    Fatal( Host , null , 3 );
    return;
  END;
CStr _ AddForty( ch );
if ch neq "w" then    ! "w" here means there is actually no spool request ;
  begin               ! so if ch = "w" then fall through this procedure. ;
    AlertOperator;
    Asterisks;
    print( SiteID & cvs( Currenthost )&": SPOOL REQUEST - " );
    print( GetDate,"  ",GetTime,crlf,#lf);
    FirstCharWasW _ False; 
  end
else
  FirstCharWasW _ True; ! probable something wrong somewhere ;
while Not EQU( CStr,"w" ) do    ! "w" indicates end of SPOOL recs ;
  begin "reading"
    if Not EQU( CStr,"x" ) then 
      print( CStr ); 
    ch _ AuxIn( TimeOut );
    if ch = -1 then
      BEGIN
        Fatal( Host , null , 4 );
        return;
      END;
    CStr _ AddForty( ch );
    if ch = "h" then ! trouble signal from SLVSUP ;
      begin
        ErrorRoutine( host        return;
      end;
    if CStr = "x" then ! "x" indicates end of a block of chars ;
      begin
        auxout( "X" );   ! Indicate ready to continue ;
        continue "reading";
      end;
  end "reading";
if CStr = "w" then
  auxout( "W" );   ! Acknowledge receipt of end indicator. ;
if Not FirstCharWasW then ! prevent these operator signals in this case. ;
  begin
    Asterisks;
    AlertOperator;
  end;
end "ReadSpoolReq";

simple procedure ReadBatchReq( integer beginMark,host );
!----------------------------------------------------------------------;

! prints pending batch requests sent by SLVSUP.                        ;
! looks for "k" from SLVSUP, indicating the end.                       ;

!----------------------------------------------------------------------;

begin "ReadBatchReq"
	integer ch;
	string  CStr; ! "ch" converted by adding 40 ;

AlertOperator;
Asterisks;
print( SiteID & cvs(Currenthost )&": BATCH REQUEST - " );
print( GetDate,"  ",GetTime,crlf,#lf);
print( "FILE LAST CLEARED" );
if EQU( beginMark,"g" ) then
  auxout( "G" )    ! Indicate ready to receive first Batch req ;
else
  auxout( "N" );   ! Indicate ready to receive another Batch req ;
CStr _ null;
while Not EQU( CStr,"k" ) do                    ! "k" means done ;
  begin "reading"
    if Not EQU( CStr,"x" ) and Not EQU( CStr,"g") and Not EQU( CStr,"n" ) then 
      print( CStr ); ! print everthing but SLVSUP signal chars ;
    ch _ AuxIn( TimeOut );
    if ch = -1 then
      BEGIN
        Fatal( Host , null , 5 );
        return;
      END;
    CStr _ AddForty( ch );
    if CStr = "h" then ! trouble indicator ;
      begin
        ErrorRoutine( host );
        return;
      end;
    if ( CStr = "x" ) then ! end of one block of data ;
      begin
        auxout( "X" ); ! Signal ready to continue ;
        continue "reading";
      end;
      if CStr = "n" then ! SLVSUP is ready with more ;
        begin
          auxout( "N" ); ! Signal ready to continue ;
          Asterisks;
          AlertOperator;
          Asterisks;
          print( SiteID & cvs(Currenthost )&": BATCH REQUEST - " );
          print( GetDate,"  ",GetTime,crlf,#lf);
          print( "FILE LAST CLEARED" );
          continue "reading";
        end;
  end "reading";
  if Cstr = "k" then ! End of Batch requests signal from SLVSUP ;
    begin
      ch _ AuxIn( TimeOut ); ! Get second "k" ;
      if ch = -1 then
        BEGIN
          Fatal( Host , null , 6 );
          return;
        END;
      CStr _ AddForty( ch );
      Asterisks;
      AlertOperator;
      auxout( "K" );   ! Acknowledge end ;
    end;
end "ReadBatchReq";

integer procedure CreateNewFil( String NameForTheNewFile );
!----------------------------------------------------------------------;

! create a new file.                                                   ;

!----------------------------------------------------------------------;

begin
	integer eof,
		NewFilChan;

open( NewFilChan _ getchan,"DSK",0,0,4,0,0,eof );
enter( NewFilChan,NameForTheNewFile,eof );
if eof then
  usererr( 0,0,"Can't enter "&NameForTheNewFile,"X" );
return( NewFilChan );
end;

simple procedure DisplaySystems;
!----------------------------------------------------------------------;

! show systems which were read into the array                          ;

!----------------------------------------------------------------------;

begin
	integer i;

  print( crlf,"CURRENT ",SiteNameLine," SYSTEMS ARE:",crlf );
  for i _ 0 upto LastHost do
    print( cvs( hosts[i] )," " );
end;

simple boolean procedure YES( string TheQuestion );
!----------------------------------------------------------------------;

! Prompts for yes or no response to TheQuestion.                       ;
 
!----------------------------------------------------------------------;

begin
	string line;

while true do
  begin "ask"
    print( crlf,TheQuestion&" ( Y OR N )? " );
    while true do
      case ( Line _ inchwl ) of begin
  
        [000&'32] begin
                !Trace _ true; 
                ! hostnums are displayed as circuits are built ;
                continue "ask"; ! still need answer to "Y or N". ;
              end;
  
        ['131] ['171] return( true );
  
        ['116] ['156] return( false );
  
        else          Continue "ask"
  
      end; ! case ;
  end "ask";
end;! YES ;

simple integer procedure OpenFil( String NameOfTheFile );
!----------------------------------------------------------------------;

! Open a currently existing file                                       ;

!----------------------------------------------------------------------;

begin
	integer eof,
		FilChan;

open( FilChan _ getchan,"DSK",0,2,0,500,0,eof );
LookUp( FilChan,NameOfTheFile,eof );
if eof then
  usererr( 0,0,"Can't find "&NameOfTheFile,"X" );
return( FilChan );
end;
  
  simple boolean procedure DeleteSys;
!----------------------------------------------------------------------;

! to remove a system from those in hosts array.                        ;

!----------------------------------------------------------------------;

begin
	integer i,j,SysNum,foo;
	string SavLine;

while true do
  begin "GetSysNum"
    print( crlf,"ENTER SYSTEM NUMBER[S] ( OMIT LETTERS ): " );
    line _ inchwl;
    while true do
      begin "ReadIn"
        if ( SavLine _ Line ) = null then ! if nothin remains ;
          done "GetSysNum";
        SysNum _ intscan( line,foo );
        if foo = -1 then
          begin
            print( crlf,"?",Savline,"?",crlf );
            continue "GetSysNum";
          end;
        if SysNum = 0 then
          continue;
        for i _ 0 upto ( nhosts - 1 ) do
          begin "DeleteIt"
            if hosts[i] = SysNum then
              begin
                for j _ i upto ( nhosts - 2 ) do ! take it out ;
                  hosts[j] _ hosts[j + 1];
                LastHost  _ LastHost - 1;
              end;
          end "DeleteIt";
      end "ReadIn";
  end "GetSysNum";
end;  ! DeleteSys ;
  
simple boolean procedure AddSys;
!----------------------------------------------------------------------;

! to add a system to those in hosts array.                             ;

!----------------------------------------------------------------------;

begin
	boolean found;
	integer i,j,SysNum,foo;
	string SavLine;

while true do
  begin "GetSysNum"
    print( crlf,"ENTER SYSTEM NUMBER[S] ( OMIT LETTERS ): " );
    line _ inchwl;
    while true do
      begin "ReadIn"
        if ( SavLine _ line ) = null then ! if nothing remains on line ;
          done "GetSysNum";
        SysNum _ intscan( line,foo );
        if foo = -1 then
          begin
            print( crlf,"?",Savline,"?",crlf );
            continue "GetSysNum";
          end;
        found _ false;
        for i _ 0 upto ( nhosts - 1 ) do
          begin "InsertIt"
            if hosts[i] = SysNum then ! no duplicates ;
              begin
                found _ true;
                done;
              end;
            if hosts[i] > SysNum then ! insert into proper position ;
              begin
                found _ true;
                for j _ LastHost downto i do
                  hosts[j + 1] _ hosts[j];
                hosts[i] _ SysNum;
                LastHost _ LastHost + 1;
                done;
              end;
          end "InsertIt";
        if not found then ! must be higher number ;
          begin
            print( #bel );
            hosts[LastHost _ LastHost + 1] _ SysNum;
          end;
      end "ReadIn";
  end "GetSysNum";
end;  ! AddSys ;
  
simple procedure StoreChanges;
!----------------------------------------------------------------------;

! for making system number changes permanent                           ;

!----------------------------------------------------------------------;

begin
	integer i;

  setbreak( InBrChar _ GetBreak,#lf,#cr,"I" );
  OutChan _ CreateNewFil( SiteFileName );
  cprint( OutChan,SiteNameLine&crlf );
  for i _ 0 upto LastHost - 1 do
    cprint( OutChan,cvs( hosts[i] ),"," );
  cprint( OutChan,cvs( hosts[LastHost] ) );
  print( crlf,#lf,"(UTIL)HOST.LST UPDATED",crlf );
  release( OutChan );
end; ! StoreChanges ;
  
simple procedure ChangeHosts;
!----------------------------------------------------------------------;

! ask user whether to add or remove systems from those displayed       ;

!----------------------------------------------------------------------;

begin ! ChangeHosts ;
while true do
  begin "Changes"
    if YES( "REMOVE SYSTEM[S]" ) then
      begin "GetDeletes"
        DeleteSys;
      end "GetDeletes";
    if YES( "ADD SYSTEM[S]" ) then
      begin "GetAdds"
        AddSys;
      end "GetAdds";
    DisplaySystems;
    if NOT YES( "OKAY" ) then
      continue
    else
      done;      
  end "Changes";
if YES( "ARE CHANGES PERMANENT" ) THEN
  StoreChanges;
end;  ! ChangeHosts ;
  
simple procedure Gethosts;
!----------------------------------------------------------------------;

! Gets site from user and looks to a file for list of hosts             ;

!----------------------------------------------------------------------;

begin
	integer h,OneHost,foo,Chan;
	string  line,savline;

Chan _ OpenFil( SiteFileName );
  begin ! Get a line from file ;
    setbreak( InBrChar _ GetBreak,#lf,#cr,"I" );
    SiteNameLine _ input( Chan,InBrChar ); ! ex: "FREMONT" or "VALLEY FORGE" ;
    SiteID _ SiteNameLine[1 for 1];  ! first letter, ex: "F" for "FREMONT" ;
    Line _ input( Chan,InBrChar );
    for h _ 0 step 1 until nhosts-1 do
      begin "ReadHostsIntoArray"
        LastHost _ h-1;
        if ( savline _ line ) = null then
          done;
        OneHost _ intscan( line,foo );
        if foo = -1 then
          print( savline&"?"&crlf );
        hosts[h] _ OneHost;
      end "ReadHostsIntoArray";
    DisplaySystems;
    if NOT YES( "OKAY" ) then
      ChangeHosts;
  end;
print( crlf&crlf );
end; ! Gethosts ;

simple procedure SaveForRetry( integer Host );
!----------------------------------------------------------------------;

! Place hosts that could not be logged into into the Retry array.      ;
! Do not insert hosts that have failed twice.                          ;

!----------------------------------------------------------------------;

BEGIN
  if NOT SecondPassInProgress then ! No retries of retries. ;
    begin
      ReDoingFailures _ true; ! do not reset if this is second pass ;
      NumOfBadHosts _ NumOfBadHosts + 1; ! increment on first pass only ;
      FailedHosts[NumOfBadHosts - 1] _ Host; ! save for second pass ;
    end;
END;


simple procedure CheckMail(integer HostNum);
!----------------------------------------------------------------------;

! print oper mail if there is any waiting                              ;

!----------------------------------------------------------------------;

begin
	integer ch;
	string response;
	boolean MailWaiting; ! set true if "mail waiting" comes with
				with logon messages ;

  if !Trace then print( " CHECK MAIL  " );
  response _ null;
  MailWaiting _ false;
  auxout( "mail"&#cr );                    ! ask for mail ;
  if !Trace then print( "-" );
  
while ( ch _ AuxIn( TimeOut ) ) neq -1 do
    begin                           ! look for echo of command "mail" ;
      response _ response & ch;                        ! tack it on ;
      if equ( ch,#lf ) then                     ! clear for new line ;
          response _ null;
      if equ( response[1 for 12],"mail waiting" ) then
        MailWaiting _ true;
      if equ( response[1 for 5],"-mail" ) or ! true if echo of "mail" rec'd;
         equ( response[1 for 5],".mail" ) then 
                            ! After echo of the "mail" command, see if the next
                              seven character rec'd after crlf is the string 
                              "No mail".  If it is, then return with No mail.
                              If what follows is not "no mail", then assume
                              that the next seven characters is the beginning
                              of a mail message and print those seven and 
                              also print whatever follows up to the next
                              system prompt ( "." or "-" in column 1 ). ;

        while ( ch _ AuxIn( TimeOut ) ) neq -1 do
          begin "AfterCommandEcho"
            response _ response & ch;                 ! tack it on ;
            if equ( ch,#lf ) then            !  end of a line of echo'd stuff ;
              response _ null;               
            if    ( length( response ) = 7 ) and
               equ( response[1 for 7],"No mail" ) then ! return no mail ;
              begin "ResponseIsNoMail"
                if !Trace then print( "NO MAIL ",crlf );
                if MailWaiting then
		  BEGIN ! something wrong ;
                    AlertOperator;
                    Asterisks;
                    print( SiteID & cvs(Currenthost )&": ");
                    print( "ERROR...no response to 'mail' command");
		    print( "...continuing" );
                    Asterisks;
                    AlertOperator;
		  END;                  
                return; 
              end "ResponseIsNoMail"
           else          ! if stuff coming after echo of "mail" is not        ;
                         !  "No mail",  then what is coming is mail - copy it ;
            if ( length( response ) = 7 ) then ! copy the mail ;
              begin "copythemail"
                AlertOperator;
                Asterisks;
                print( SiteID & cvs(Currenthost )&": MAIL - " );
                print( GetDate,"  ",GetTime,crlf,#lf);
                print(crlf,"SYSTEM "&SiteID&cvs(HostNum)&" MAIL.",crlf);
                print( response );            ! was not "No mail" so print it ;
                response _ null;

                while ( ch _ AuxIn( TimeOut ) ) neq -1 do
                  begin "CopyUntilSysPrompt"
                    response _ response & ch; ! tack it on ;
                    if equ( response[1 for 1],"-" ) or   ! assumes "." or "-" ;
                       equ( response[1 for 1],"." ) then ! in col 1 indicates ;
                         done;                           ! mail is done.;      
                    if equ( ch,#lf ) then
                      response _ null;        ! end of a line without "<cr>." ;
                    print( null&ch );      ! print latest character from mail ;
                  end "CopyUntilSysPrompt";

		if ch = -1 then    ! if circuit was cut ;
                  BEGIN
                    Fatal( HostNum , null , 7 );
                    return;
                  END;
                Asterisks;
                AlertOperator;
                return;            ! return with mail copied and no problem ;
              end "copythemail";

          end "AfterCommandEcho";

    end; ! while ;

  if ch = -1  then
    BEGIN
      Fatal( HostNum , "HOST UNAVAILABLE" , 8 );
      SaveForRetry( HostNum );
      return;
    END;

end; ! CheckMail ;


simple procedure Pollhosts;
!----------------------------------------------------------------------;

! checks each host for mail then runs SLVSUP on each host              ;

!----------------------------------------------------------------------;

begin 
	integer ch,Count,i;
	boolean HandShakeRecd;

if Not ReDoingFailures then                      ! don't do when retrying ;
  begin                                         ! stuff for first pass only ;
    print( crlf,#lf,"CLEARING ",SiteNameLine);    
    print( " CENTER HOSTS  ",GetDate,"  ",GetTime,crlf );
    AlertOperator;
    NumOfBadHosts _ 0;                          ! clear it during first try ;
    SecondPassInProgress _ false;
    arrclr( FailedHosts );  ! get rid of fail hosts from any previous passes ;
  end
else
  SecondPassInProgress _ true;             ! so hostloop will use FailedHosts ;
  
ReDoingFailures _ false; ! will be set if needed in hostloop ;

for h _ 0 upto LastHost do
begin "hostloop"

  ! Initializations and see if this is first pass through hostlist ;
  ! ************************************************************ ;
  CircuitGone _ false; ! becomes true if an auxin fails somewhere. ;
  AbortHostError _ false; ! becomes true if error message comes from SLVSUP ;
  HandShakeRecd _ false;
  if SecondPassInProgress and h > NumOfBadHosts - 1 then
    done; ! finished with retry's ;
  if NOT SecondPassInProgress then
    CurrentHost _ hosts[h]
  else
    ! second time around get hosts from array of failures ;
    CurrentHost _ FailedHosts[h];
      
  if !Trace then print( SiteID & cvs( Currenthost )&":" );
  ! ------------------------------------------------------------ ;


  ! Establish circuit to a host ;
  ! ************************************************************ ;
  AuxPort _ creaux( ValidUser&":"&cvs(CurrentHost ) );
  if !Trace then Print( " port("&cvs(AUXPORT)&")" );
  if AuxPort = -1 then
    begin
      FATAL(CurrentHost, null , 15 );
      SaveForRetry( CurrentHost );
      continue;
    end;
  auxout( #cr&#cr ); ! proj code/attach msgs ;
  ! ------------------------------------------------------------ ;


  ! Check for mail ;
  ! ************************************************************ ;
  CheckMail(CurrentHost);         ! Checkfor mail waiting ;
  if CircuitGone then ! CIRCUIT FAILURE OR TIMEOUT during checkmail ;
    Continue;  ! next host ;
  ! ------------------------------------------------------------ ;


  ! Call SLVSUP and establish that it is running ;
  ! ************************************************************ ;
  auxout( "run (UTIL)SLVSUP"&#cr );
  if !Trace then print( "     RUN SLVSUP , " );
  while NOT CircuitGone do 
    begin "Findppabcd"
      ch _ AuxIn( TimeOut );
      if ch = -1 then
        BEGIN
          Fatal( CurrentHost , null , 9 );
          Continue "hostloop" ; ! next host ;
        END;
      if ch = "p" then
        begin "beginMarkFound"
          ch _ AuxIn( TimeOut );
          if ch = -1 then
            BEGIN
              Fatal( CurrentHost , null , 10 );
              Continue "hostloop" ; ! next host ;
            END;
          if ch = "p" then
            begin "SecondPFound"
              ch_AuxIn( TimeOut );
              if ch = "a" then
                ch_AuxIn( TimeOut )
              else continue;
              if ch = "b" then
                ch_AuxIn( TimeOut )
              else continue;
              if ch = "c" then
                ch_AuxIn( TimeOut )
              else continue;
              if ch = "d" then
                done;
            end "SecondPFound"
          else
            ! if second consecutive "p" is not found ;
            continue "Findppabcd";
        end "beginMarkFound" 
      else
        if ch = -1 then
                BEGIN
                  Fatal( CurrentHost , null , 11 );
                  Continue "hostloop" ; ! next host ;
                END;
    end "Findppabcd";
  if !Trace then print( " RUNNING, " );
  ! ------------------------------------------------------------ ;


  ! Handshake with SLVSUP ;
  ! ************************************************************ ;
  if !Trace then print( "HANDSHAKE:" );
  Count _ 0;
  while NOT HandShakeRecd
    and NOT CircuitGone do  ! send "ABCD" then look for "i" ;
    begin "CheckHandShake"
      if ch = -1 then
        BEGIN
          Fatal( CurrentHost , null , 12 );
          Continue "hostloop" ; ! next host ;
        END;
      Count _ Count + 1;
      If Count > 5 then ! Don't try more than 5 times ;
        begin
          if !Trace then print( crlf );
          Fatal( CurrentHost,"Handshake failure...continuing",0 );       
          Done "CheckHandShake";
        end;
      auxout( "ABCD" ); ! expected here by SLVSUP ;
      if !Trace then print( " ABCD-" );
      if ( ch _ AuxIn( TimeOut ) ) = "i" then
        BEGIN
          if !Trace then print( "OK" );
          HandShakeRecd _ true;
        END
      else
        if ch = "`" then ! error signal from SLVSUP ;
          begin
            if !Trace then print( "`" );
            auxout( "`" ); ! expected here by SLVSUP ;
            ch _ AuxIn( TimeOut );  ! get "a" ;
            if ch = "a" then
              ch_AuxIn( TimeOut )
            else continue;
            if ch = "b" then
              ch_AuxIn( TimeOut )
            else continue;
            if ch = "c" then
              ch_AuxIn( TimeOut )
            else continue;
            if ch = "d" then
              continue;
          end
        else
          if ch = -1 then
            BEGIN
              Fatal( CurrentHost , null , 13 );
              Continue "hostloop" ; ! next host ;
            END;
  if !Trace then print( "," );
      
    end "CheckHandShake";
  ! ------------------------------------------------------------ ;


  ! Interact with SLVSUP ;
  ! ************************************************************ ;
  if !Trace and
     NOT AbortHostError and
     NOT CircuitGone 
       then print( crlf,"     INTERACT: " );
   while Not AbortHostError
     and NOT CircuitGone do
   ! read from host until/unless SLVSUP signal an error ;
      begin "EndMarkFound"
        ch _ AuxIn( TimeOut ); 
        if ch = -1 then
          BEGIN
            Fatal( CurrentHost , null , 14 );
            Continue "hostloop" ; ! next host ;
          END;
        if !Trace then print( null&ch );
          case CH of begin

              ["u"] ! Non-Fatal Error on SSPOOL.DAT records ;
                    begin
                      print( #bel,null );
	              print( SiteID & cvs(CurrentHost ),"  - " );
                      print( "ERROR: Problem with SSPOOL.DAT or SSPOOL.BAK." );
                      print( crlf );
                    end;

              ["v"] ! Ready to send SSPOOL.DAT records ;
                    ReadSpoolReq( CurrentHost );

              ["g"] ! Ready to send first PPRTMP.DAT record ;
                    ReadBatchReq( "g",CurrentHost );

              ["n"] ! Ready to send another  PPRTMP.DAT record ;
                    ReadBatchReq( "n",CurrentHost );

              ["k"] ! Ready to send Spool Count ;
                    auxout( "K" ); ! expected here by SLVSUP ;

              ["f"] ! No batch requests to report ( file empty );
                    auxout( "F" ); ! expected here by SLVSUP ;

              ["e"] ! Normal exit from SLVSUP ;
                    begin
                      AuxZap;
		      if !Trace then print( " NORMAL EXIT ",crlf );
                      done "EndMarkFound"; ! next host ; 
                    end;

              ["h"] ! Error code follows ;
                    begin  "ErrorCode"
                      ErrorRoutine( CurrentHost );
                      done "EndMarkFound";
                    end "ErrorCode";

              [ 000&'1 ] if !Trace then print( "^A");
              [ 000&'2 ] if !Trace then print( "^B");
              [ 000&'3 ] if !Trace then print( "^C");
              [ 000&'4 ] if !Trace then print( "^D");
              [ 000&'5 ] if !Trace then print( "^E");
              [ 000&'6 ] if !Trace then print( "^F");
              [ 000&'7 ] if !Trace then print( "^G");
              [ 000&'8 ] if !Trace then print( "^H");
              [ 000&'9 ] if !Trace then print( "^I");
              [ 000&'10 ] if !Trace then print( "^J");
              [ 000&'11 ] if !Trace then print( "^K");
              [ 000&'12 ] if !Trace then print( "^L");
              [ 000&'13 ] if !Trace then print( "^M");
              [ 000&'14 ] if !Trace then print( "^N");
              [ 000&'15 ] if !Trace then print( "^O");
              [ 000&'16 ] if !Trace then print( "^P");
              [ 000&'17 ] if !Trace then print( "^Q");
              [ 000&'18 ] if !Trace then print( "^R");
              [ 000&'19 ] if !Trace then print( "^S");
              [ 000&'20 ] if !Trace then print( "^T");
              [ 000&'21 ] if !Trace then print( "^U");
              [ 000&'22 ] if !Trace then print( "^V");
              [ 000&'23 ] if !Trace then print( "^W");
              [ 000&'24 ] if !Trace then print( "^X");
              [ 000&'25 ] if !Trace then print( "^Y");
              [ 000&'26 ] if !Trace then print( "^Z");
              [ 000 ] ! sometimes comes after "k", calls for no action ;
		      if !Trace then print( "null");

	      else 
                if !Trace then print( "{",ch )

             end; ! case ;
         if AbortHostError then
           done "EndMarkFound";
       end "EndMarkFound";
  ! ------------------------------------------------------------ ;
  end "hostloop" ;
end;


!----------------------------------------------------------------------;

!  *** main *** ;

!----------------------------------------------------------------------;

print(crlf,#lf,#lf,"SUPCHK     VERSION 1.0");

AlertOperator;   ! Signals that program has started;

ValidUser _ SeeIfValidUser; ! logged in user name must equal ValidUserName ;
                            ! othrwise SUPCHK will abort.                  ;

GetHosts;        ! Gets file with list of host numbers of hosts to be polled. ;
                 ! User can make temporary changes to the list or permanent   ;
                 ! changes to the file.                                       ;

WaitPeriod _ GetWaitPeriod;  ! User is prompted for the time interval to wait ;
                             ! between polls of the hosts.                    ;

while true do
  begin
    PollHosts;               ! Build circuit in turn to each host in the host ;
                             ! list, print mail if mail is waiting, then run  ;
                             ! SLVSUP to check for SPOOL or BATCH requests.   ;
                             ! Keep a list of hosts to which circuits could   ;
                             ! not be built, and sets flag to retry them.     ;

    if ReDoingFailures then  ! True if some circuits could not be built above.;
      PollHosts;             ! This time use list of first time failures.     ;

    Waiting( WaitPeriod );   !  Hold here for the wait period.                ;

    continue;                ! Continue forever.                              ;

  end;

end "SUPCHK"
   2i
