;[CSM] B361LB.REL is on SYS:, not DSKB:[1,5]
;   0001  0	%TITLE 'KERMSG - Kermit message processing'
;   0002  0	MODULE KERMSG (IDENT = '3.0.041'
;   0003  0			) =
;   0004  1	BEGIN
;   0005  1	
;   0006  1	SWITCHES LANGUAGE (COMMON);
;   0007  1	
;   0008  1	!<BLF/WIDTH:100>
;   0009  1	
;   0010  1	!++
;   0011  1	! FACILITY:
;   0012  1	!   Kermit-10, VMS Kermit, Pro/Kermit
;   0013  1	!
;   0014  1	! ABSTRACT:
;   0015  1	!	KERMSG is the message processing routines for Kermit-10, VMS Kermit,
;   0016  1	!	and PRO/Kermit.
;   0017  1	!	This module is written in common BLISS, so that it can be
;   0018  1	!	transported for the DECsystem-10 and VAX/VMS systems.
;   0019  1	!
;   0020  1	! ENVIRONMENT:
;   0021  1	!   User mode
;   0022  1	!
;   0023  1	! AUTHOR: Robert C. McQueen, CREATION DATE: 24-January-1983
;   0024  1	!
;   0025  1	! MODIFIED BY:
;   0026  1	!
;   0027  1	!--
;   0028  1	
;   0029  1	%SBTTL 'Table of Contents'
;   0030  1	!+
;   0031  1	!.pag.lit
;   0032  1	!		Table of Contents for KERMSG
;   0033  1	!
;   0034  1	!
;   0035  1	!			   Section			      Page
;   0036  1	!   1. Revision History . . . . . . . . . . . . . . . . . . .    3
;   0037  1	!   2. Interface requirements . . . . . . . . . . . . . . . .    4
;   0038  1	!   3. Declarations
;   0039  1	!        3.1.   Forward definitions . . . . . . . . . . . . .    5
;   0040  1	!   4. Require files. . . . . . . . . . . . . . . . . . . . .   28
;   0041  1	!   5. Macro definitions. . . . . . . . . . . . . . . . . . .   29
;   0042  1	!   6. KERMIT Protocol Definitions. . . . . . . . . . . . . .   30
;   0043  1	!        6.1.   Packet offsets. . . . . . . . . . . . . . . .   31
;   0044  1	!        6.2.   Message dependent field . . . . . . . . . . .   32
;   0045  1	!        6.3.   SEND initiate packet. . . . . . . . . . . . .   33
;   0046  1	!   7. KERMIT Protocol States . . . . . . . . . . . . . . . .   34
;   0047  1	!   8. Internal constants . . . . . . . . . . . . . . . . . .   35
;   0048  1	!   9. Storage - External . . . . . . . . . . . . . . . . . .   36
;   0049  1	!  10. Storage - Local. . . . . . . . . . . . . . . . . . . .   37
;   0050  1	!  11. External references. . . . . . . . . . . . . . . . . .   38
;   0051  1	!  12. MSG%INIT . . . . . . . . . . . . . . . . . . . . . . .   39
;   0052  1	!  13. SND%ERROR. . . . . . . . . . . . . . . . . . . . . . .   40
;   0053  1	!  14. SERVER - Server mode . . . . . . . . . . . . . . . . .   41
;   0054  1	!  15. SEND%SWITCH. . . . . . . . . . . . . . . . . . . . . .   42
;   0055  1	!  16. REC%SWITCH . . . . . . . . . . . . . . . . . . . . . .   43
;   0056  1	!  17. Server
;   0057  1	!       17.1.   DO%GENERIC - Execute a generic command. . . .   44
;   0058  1	!  18. DO%TRANSACTION - Main loop for FSM . . . . . . . . . .   45
;   0059  1	!  19. REC%SERVER%IDLE - Idle server state. . . . . . . . . .   46
;   0060  1	!  20. SEND%SERVER%INIT . . . . . . . . . . . . . . . . . . .   47
;   0061  1	!  21. SEND%DATA. . . . . . . . . . . . . . . . . . . . . . .   48
;   0062  1	!  22. SEND%FILE. . . . . . . . . . . . . . . . . . . . . . .   49
;   0063  1	!  23. SEND%EOF . . . . . . . . . . . . . . . . . . . . . . .   50
;   0064  1	!  24. SEND%INIT. . . . . . . . . . . . . . . . . . . . . . .   51
;   0065  1	!  25. SEND%OPEN%FILE - Open file for sending . . . . . . . .   52
;   0066  1	!  26. SEND%GENCMD. . . . . . . . . . . . . . . . . . . . . .   53
;   0067  1	!  27. SEND%BREAK . . . . . . . . . . . . . . . . . . . . . .   54
;   0068  1	!  28. REC%INIT . . . . . . . . . . . . . . . . . . . . . . .   55
;   0069  1	!  29. REC%FILE . . . . . . . . . . . . . . . . . . . . . . .   56
;   0070  1	!  30. REC%DATA . . . . . . . . . . . . . . . . . . . . . . .   57
;   0071  1	!  31. SERVER - Generic commands. . . . . . . . . . . . . . .   58
;   0072  1	!  32. HOST%COMMAND - perform a host command. . . . . . . . .   59
;   0073  1	!  33. CALL%SY%RTN - handle operating system dependent functions  60
;   0074  1	!  34. Message processing
;   0075  1	!       34.1.   PRS%SEND%INIT - Parse send init params. . . .   61
;   0076  1	!  35. SET%SEND%INIT. . . . . . . . . . . . . . . . . . . . .   62
;   0077  1	!  36. SEND%PACKET. . . . . . . . . . . . . . . . . . . . . .   63
;   0078  1	!  37. REC%MESSAGE - Receive a message. . . . . . . . . . . .   64
;   0079  1	!  38. REC%PACKET . . . . . . . . . . . . . . . . . . . . . .   65
;   0080  1	!  39. CALC%BLOCK%CHECK . . . . . . . . . . . . . . . . . . .   66
;   0081  1	!  40. NORMALIZE%FILE - Put file name into normal form. . . .   67
;   0082  1	!  41. Buffer filling
;   0083  1	!       41.1.   Main routine. . . . . . . . . . . . . . . . .   68
;   0084  1	!  42. BFR%EMPTY. . . . . . . . . . . . . . . . . . . . . . .   69
;   0085  1	!  43. Buffer filling and emptying subroutines. . . . . . . .   70
;   0086  1	!  44. Add parity routine . . . . . . . . . . . . . . . . . .   71
;   0087  1	!  45. Parity routine . . . . . . . . . . . . . . . . . . . .   72
;   0088  1	!  46. Per transfer
;   0089  1	!       46.1.   Initialization. . . . . . . . . . . . . . . .   73
;   0090  1	!  47. Statistics
;   0091  1	!       47.1.   Finish message transfer . . . . . . . . . . .   74
;   0092  1	!  48. Status type out
;   0093  1	!       48.1.   STS%OUTPUT. . . . . . . . . . . . . . . . . .   75
;   0094  1	!  49. TYPE%CHAR - Type out a character . . . . . . . . . . .   76
;   0095  1	!  50. Debugging
;   0096  1	!       50.1.   DBG%SEND. . . . . . . . . . . . . . . . . . .   77
;   0097  1	!       50.2.   DBG%RECEIVE . . . . . . . . . . . . . . . . .   78
;   0098  1	!       50.3.   DBG%MESSAGE . . . . . . . . . . . . . . . . .   79
;   0099  1	!  51. End of KERMSG. . . . . . . . . . . . . . . . . . . . .   80
;   0100  1	!.end lit.pag
;   0101  1	!-
;   0102  1	%SBTTL 'Revision History'
;   0103  1	
;   0104  1	!++
;   0105  1	! Start of version 1.
;   0106  1	!
;   0107  1	! 1.0.000	By: Robert C. McQueen		On: 4-Jan-1983
;   0108  1	!		Create this program.
;   0109  1	!
;   0110  1	! 1.0.001	By: Robert C. McQueen		On: 30-Apr-1983
;   0111  1	!		Change PAR%xxx to be PR%xxx, so that they can be used for
;   0112  1	!		KERMIT-10.
;   0113  1	!
;   0114  1	! 1.0.002	By: Robert C. McQueen		On: 1-May-1983
;   0115  1	!		Add DO%GENERIC routine to cause a generic Kermit command to
;   0116  1	!		be executed on the remote Kermit.
;   0117  1	!
;   0118  1	! 1.0.003	By: Robert C. McQueen		On: 3-May-1983
;   0119  1	!		Fix message number incrementing.
;   0120  1	!
;   0121  1	! 1.0.004	By: Robert C. McQueen		On: 4-May-1983
;   0122  1	!		Allow RECEIVE file-specification to work correctly.
;   0123  1	!
;   0124  1	! 1.0.005	By: Robert C. McQueen		On: 6-May-1983
;   0125  1	!		Add more stats support.
;   0126  1	!
;   0127  1	! 1.0.006	By: Nick Bush			On: 13-June-1983
;   0128  1	!		Fix SEND%PACKET to copy correct characters when fixing
;   0129  1	!		parity bits.
;   0130  1	!
;   0131  1	! 1.1.007	By: Nick Bush			On: 15-July-1983
;   0132  1	!		Correct SEND-INIT message handling to do the right things
;   0133  1	!		with the protocol version 3 items.
;   0134  1	!
;   0135  1	! 1.1.010	By: Robert C. McQueen		On: 20-July-1983
;   0136  1	!		Make PARITY a global routine, so that it can be called by
;   0137  1	!		CONNECT processing.  Change the name from PARITY to GEN%PARITY
;   0138  1	!		add a new routine to generate the parity, since it is not
;   0139  1	!		part of the checksum.
;   0140  1	!
;   0141  1	! 1.1.011	By: Robert C. McQueen		On: 28-July-1983
;   0142  1	!		KER%TIMEOUT errors in the SERVER loop would cause
;   0143  1	!		KER%UNISRV error messages to be returned to the remote.
;   0144  1	!		Check for receive failures and send NAKs instead.
;   0145  1	!
;   0146  1	! 1.2.012	By: Robert C. McQueen		On: 23-August-1983
;   0147  1	!		Don't abort if we get a message that is just an end of line
;   0148  1	!		character.  It could be noise on the line.
;   0149  1	!
;   0150  1	! 1.2.013	By: Nick Bush			On: 7-September-1983
;   0151  1	!		Fix several problems with the SEND%xxx parameters
;   0152  1	!
;   0153  1	! 1.2.014	By: Robert C. McQueen		On: 15-September-1983
;   0154  1	!		Add routine calls to XFR%STATUS to tell the user on the
;   0155  1	!		number of packets have changed.
;   0156  1	!
;   0157  1	! 1.2.015	By: Nick Bush			On: 5-October-1983
;   0158  1	!		Add 2 and 3 character checksum (block check) support.
;   0159  1	!		Add support for data within acknowledgement packets
;   0160  1	!		and withing end-of-file packets to allow for file
;   0161  1	!		transmission to be aborted.  Also add support for
;   0162  1	!		"I" packet to allow server parameters to be initialized.
;   0163  1	!
;   0164  1	! 1.2.016	By: Nick Bush			On: 19-October-1983
;   0165  1	!		Add repeat character support.
;   0166  1	!
;   0167  1	! 2.0.017	Release TOPS-10 Kermit-10 version 2.0
;   0168  1	!		Release VAX/VMS Kermit-32 version 2.0
;   0169  1	!
;   0170  1	! 2.0.018	By: Robert C. McQueen		On: 16-November-1983
;   0171  1	!		Fix four checks on the message number that were not
;   0172  1	!		mod 64.
;   0173  1	!
;   0174  1	! 2.0.019	By: Robert C. McQueen		On: 16-November-1983
;   0175  1	!		Remove the CLEAR routine.  It is not really needed.
;   0176  1	!
;   0177  1	! 2.0.020	By: Nick Bush			On: 12-Dec-1983
;   0178  1	!		Fix SEND%DATA and BFR%FILL to handle empty files and
;   0179  1	!		files which happen to end just on a message boundary.
;   0180  1	!		This would sometimes produce extra nulls.
;   0181  1	!
;   0182  1	! 2.0.021	By: Nick Bush			On: 15-Dec-1983
;   0183  1	!		Fix some problems with REC%MESSAGE which would cause
;   0184  1	!		aborts when a message timed out.
;   0185  1	!
;   0186  1	! 2.0.022	By: Robert C. McQueen		19-Dec-1983
;   0187  1	!		Make STATUS a local for most routines and remove FILE%DUMP
;   0188  1	!		as it is nolonger needed.
;   0189  1	!
;   0190  1	! 2.0.023	By: Nick Bush			On: 3-Jan-1984
;   0191  1	!		Change FIL%NORMAL%FORM to contain not just a flag, but
;   0192  1	!		a file name type instead.
;   0193  1	!
;   0194  1	! 2.0.024	By: Nick Bush			On: 11-Jan-1984
;   0195  1	!		Fix REC%MESSAGE to send NAK for packet we expect, not
;   0196  1	!		previous packet.
;   0197  1	!
;   0198  1	! 2.0.025	By: Nick Bush			On: 23-Jan-1984
;   0199  1	!		Re-enable server-init packet and complete code so that
;   0200  1	!		parameters set by it will remain set.
;   0201  1	!		Fix file name copying to use BFR%FILL or BFR%EMPTY
;   0202  1	!		so that all quoting/compression is done properly.
;   0203  1	!
;   0204  1	! 2.0.026	By: Nick Bush			On: 15-Feb-1984
;   0205  1	!		Add code for generic command support (both directions).
;   0206  1	!		There is now only one state dispatch loop, entered
;   0207  1	!		in various states for different functions.
;   0208  1	!
;   0209  1	! 2.0.027	By: Robert C. McQueen		On: 16-Feb-1984
;   0210  1	!		At some point SEND%TIMEOUT became global, but it was not moved
;   0211  1	!		to KERGLB.  This edit moves it to KERGLB.BLI.
;   0212  1	!
;   0213  1	! 2.0.030	By: Nick Bush			On: 2-March-1984
;   0214  1	!		Fix BFR%FILL to handle case of last repeated character
;   0215  1	!		not fitting within a packet.  It was forgetting to
;   0216  1	!		send the characters at all.
;   0217  1	!
;   0218  1	! 2.0.031	By: Nick Bush			On: 6-March-1984
;   0219  1	!		Make sure FILE%OPEN%FLAG is set properly when advancing
;   0220  1	!		to next file of a wild-card send.  The file was not
;   0221  1	!		being set true, leading to problems after a couple files.
;   0222  1	!
;   0223  1	! 2.0.032	By: Nick Bush			On: 9-March-1984
;   0224  1	!		Fix UNPACK%DATA in SERVER%GENERIC to properly store
;   0225  1	!		new string pointer.
;   0226  1	!
;   0227  1	! 2.0.033	By: Robert C. McQueen		On: 12-March-1984
;   0228  1	!		If NEXT%FILE fails with anything other than a NOMORFILES
;   0229  1	!		it should change state to STATE%A not STATE%SB.  This
;   0230  1	!		fixes a problem caused by Pro/Kermit and KERFIL (VMS).
;   0231  1	!
;   0232  1	! 2.0.034	By: Nick Bush			On: 15-March-1984
;   0233  1	!		Put file spec into X packet as well as F packet. This
;   0234  1	!		makes wild card TYPE's work nicer.
;   0235  1	!
;   0236  1	! 2.0.035	By: Nick Bush			On: 20-March-1984
;   0237  1	!		Fix send/receive quoting to conform to the way the
;   0238  1	!		protocol manual says it should be done, rather
;   0239  1	!		than the way we (and Kermit-20) have always done it.
;   0240  1	!
;   0241  1	! 2.0.036	By: Nick Bush			On: 28-March-1984
;   0242  1	!		Make SERVER%GENERIC more defensive against badly
;   0243  1	!		constructed packets.  If an argument has negative
;   0244  1	!		length, punt the request.  Also put angle brackets
;   0245  1	!		around data from "X" packet header, so file names will
;   0246  1	!		stick out.
;   0247  1	!
;   0248  1	! 3.0.037	Start of version 3.
;   0249  1	!
;   0250  1	! 3.0.040	By: Nick Bush			On: 2-April-1984
;   0251  1	!		Add separate server timeout.  This allows stopping the
;   0252  1	!		server NAK's without affecting the normal packet timeout.
;   0253  1	!
;   0254  1	! 3.0.041	By: Nick Bush			On: 12-April-1984
;   0255  1	!		Fix block check calculation to account for the fact
;   0256  1	!		that the parity bits are put onto the message when
;   0257  1	!		it is sent (in place), so that if a retransmission is
;   0258  1	!		done without refilling the buffer (as is normal with
;   0259  1	!		data messages), the parity bits will be there.  Make
;   0260  1	!		sure we strip them out for block check calculation.
;   0261  1	!--
;   0262  1	
;   0263  1	%SBTTL 'Interface requirements'
;   0264  1	
;   0265  1	!++
;   0266  1	!		Interface requirements
;   0267  1	!
;   0268  1	! The following routines and data locations are rquired for a correct
;   0269  1	! implementation of KERMIT.
;   0270  1	!
;   0271  1	! File routines:
;   0272  1	!
;   0273  1	!	FILE%OPEN (Function)
;   0274  1	!		This routine will open a file for reading or writting.  It
;   0275  1	!		will assume that FILE%SIZE contains the number of bytes
;   0276  1	!		and FILE%NAME contains the file name of length FILE%SIZE.
;   0277  1	!		The function that is passed is either FNC%READ or FNC%WRITE.
;   0278  1	!
;   0279  1	!	FILE%CLOSE ()
;   0280  1	!		This routine will close the currently open file.  This
;   0281  1	!		routine will return the status of the operation.
;   0282  1	!
;   0283  1	!	GET%FILE (Character)
;   0284  1	!		This routine will get a character from the currently open file
;   0285  1	!		and store it in the location specified by "Character".  There
;   0286  1	!		will be a true/false value returned by the routine to determine
;   0287  1	!		if there was an error.
;   0288  1	!
;   0289  1	!	PUT%FILE (Character)
;   0290  1	!		This routine will output a character to the currently open
;   0291  1	!		file.  It will return a true/false value to determine if the
;   0292  1	!		routine was successful.
;   0293  1	!
;   0294  1	!	NEXT%FILE ()
;   0295  1	!		This routine will advance to the next file.  This routine
;   0296  1	!		will return false if there are no more files to process.
;   0297  1	!
;   0298  1	! Communications line routines:
;   0299  1	!
;   0300  1	!	RECEIVE (Buffer address, Address of var to store length into)
;   0301  1	!		This routine will receive a message from the remote Kermit.
;   0302  1	!
;   0303  1	!	SEND (Buffer address, Length in characters)
;   0304  1	!		This routine will send a message to the remote Kermit.
;   0305  1	!
;   0306  1	!	GEN%CRC (Buffer address, length in characters)
;   0307  1	!		This routine will calculate the CRC-CCITT for the characters
;   0308  1	!		in the buffer.
;   0309  1	!
;   0310  1	! Operating system routines:
;   0311  1	!
;   0312  1	!	SY%DISMISS (Seconds)
;   0313  1	!		This routine will cause Kermit to sleep for the specified
;   0314  1	!		number of seconds.  It is used to handle the DELAY parameter.
;   0315  1	!
;   0316  1	!	SY%LOGOUT ()
;   0317  1	!		Log the job off of the system. (Kill the process).
;   0318  1	!
;   0319  1	!	SY%TIME ()
;   0320  1	!		This routine will return the starting time milliseconds.
;   0321  1	!		It can be the start of Kermit, the system, etc, so long
;   0322  1	!		as it always is incrementing.
;   0323  1	!
;   0324  1	! Status routines:
;   0325  1	!
;   0326  1	!	XFR%STATUS (Type, Subtype);
;   0327  1	!		This routine is called to indicate the occurance of
;   0328  1	!		a significant event that the user interface may wish
;   0329  1	!		to inform the user about.  The arguments indicate the
;   0330  1	!		type of event.
;   0331  1	!		Type: "S" - Send, "R" - Receive
;   0332  1	!			Subtype: "P" - Packet
;   0333  1	!				 "N" - NAK
;   0334  1	!				 "T" - timeout
;   0335  1	!		For type = "I" (initiate), "T" (terminate):
;   0336  1	!			Subtype: "S" - a file send
;   0337  1	!				 "R" - a file receive
;   0338  1	!				 "G" - a generic command
;   0339  1	!				 "I" - for "T" only, returning to server idle
;   0340  1	!		For type = "F" (file operation):
;   0341  1	!			Subtype: "S" - open for sending
;   0342  1	!				 "R" - open for receiving
;   0343  1	!				 "C" - closing file OK
;   0344  1	!				 "X" - aborting file by user request
;   0345  1	!				 "Z" - aborting group by user request
;   0346  1	!				 "D" - aborting file, but saving due to disposition
;   0347  1	!				 "A" - aborting file due to protocol error
;   0348  1	!
;   0349  1	! Error processing:
;   0350  1	!
;   0351  1	!	KRM%ERROR (Error parameter)
;   0352  1	!		This routine will cause an error message to be issued.
;   0353  1	!		The error parameter is defined by KERERR.  This may cause
;   0354  1	!		SND%ERROR to be called to send an "E" message to the remote.
;   0355  1	!
;   0356  1	! Terminal I/O routines:
;   0357  1	!
;   0358  1	!	TERM%DUMP (Buffer, Count)
;   0359  1	!	DBG%DUMP (Buffer, Count)
;   0360  1	!		This routine will dump the buffer onto the user's terminal.
;   0361  1	!		Tutine is supplied with the count of the characters
;   0362  1	!		and the address of the buffer.
;   0363  1	!		These may be the same routine or different.  DBG%DUMP
;   0364  1	!		is only called for debugging output.
;   0365  1	!
;   0366  1	!
;   0367  1	!			ENTRY POINTS
;   0368  1	!
;   0369  1	! KERMSG contains the following entry points for the KERMIT.
;   0370  1	!
;   0371  1	!	SERVER ()
;   0372  1	!		This routine will cause KERMIT go enter server mode.
;   0373  1	!
;   0374  1	!	SEND%SWITCH ()
;   0375  1	!		This routine will send a file.  It expects that the user
;   0376  1	!		has stored the text of the file name into FILE%NAME and
;   0377  1	!		the length of the text into FILE%SIZE.
;   0378  1	!
;   0379  1	!	REC%SWITCH ()
;   0380  1	!		This routine will receive a file.  It expects that the default
;   0381  1	!		file name is set up in FILE%NAME and the length is in
;   0382  1	!		FILE%SIZE.
;   0383  1	!
;   0384  1	!	GEN%PARITY (Character)
;   0385  1	!		This routine will return the character with the proper parity
;   0386  1	!		on the character.
;   0387  1	!
;   0388  1	!	SND%ERROR (COUNT, ADDRESS)
;   0389  1	!		This routine will send the text of an error to the remote
;   0390  1	!		Kermit.
;   0391  1	!
;   0392  1	!	DO%GENERIC (TYPE)
;   0393  1	!		This routine will cause a generic function to be sent to
;   0394  1	!		the remote Kermit.  This routine will then do all of the
;   0395  1	!		necessary hand shaking to handle the local end of the generic
;   0396  1	!		Kermit command.
;   0397  1	!
;   0398  1	!
;   0399  1	!		GLOBAL Storage
;   0400  1	!
;   0401  1	! The following are the global storage locations that are used to interface
;   0402  1	! to KERMSG.  These locations contains the various send and receive parameters.
;   0403  1	!
;   0404  1	! Receive parameters:
;   0405  1	!
;   0406  1	!	RCV%PKT%SIZE
;   0407  1	!		Receive packet size.
;   0408  1	!	RCV%NPAD
;   0409  1	!		Padding length
;   0410  1	!	RCV%PADCHAR
;   0411  1	!		Padding character
;   0412  1	!	RCV%TIMEOUT
;   0413  1	!		Time out
;   0414  1	!	RCV%EOL
;   0415  1	!		End of line character
;   0416  1	!	RCV%QUOTE%CHR
;   0417  1	!		Quote character
;   0418  1	!	RCV%8QUOTE%CHR
;   0419  1	!		8-bit quoting character
;   0420  1	!	RCV%SOH
;   0421  1	!		Start of header character
;   0422  1	!
;   0423  1	! Send parameters (Negative values denote the default, positive user supplied):
;   0424  1	!
;   0425  1	!	SND%PKT%SIZE
;   0426  1	!		Send packet size
;   0427  1	!	SND%NPAD
;   0428  1	!		Padding length
;   0429  1	!	SND%PADCHAR
;   0430  1	!		Padding character
;   0431  1	!	SND%TIMEOUT
;   0432  1	!		Time out
;   0433  1	!	SND%EOL
;   0434  1	!		End of line character
;   0435  1	!	SND%QUOTE%CHR
;   0436  1	!		Quote character
;   0437  1	!	SND%SOH
;   0438  1	!		Start of header character (normally 001)
;   0439  1	!
;   0440  1	! Statistics:
;   0441  1	!
;   0442  1	!	SND%TOTAL%CHARS
;   0443  1	!		Total characters sent for this Kermit session
;   0444  1	!	RCV%TOTAL%CHARS
;   0445  1	!		Total characters received for this Kermit session
;   0446  1	!	SND%DATA%CHARS
;   0447  1	!		Total number of data characters sent for this Kermit session
;   0448  1	!	RCV%DATA%CHARS
;   0449  1	!		Total number of data characters received for this Kermit session
;   0450  1	!	SND%COUNT
;   0451  1	!		Total number of packets that have been sent
;   0452  1	!	RCV%COUNT
;   0453  1	!		Total number of packets that have been received.
;   0454  1	!	SMSG%TOTAL%CHARS
;   0455  1	!		Total characters sent for this file transfer
;   0456  1	!	RMSG%TOTAL%CHARS
;   0457  1	!		Total characters received for this file transfer
;   0458  1	!	SMSG%DATA%CHARS
;   0459  1	!		Total data characters sent for this file transfer
;   0460  1	!	RMSG%DATA%CHARS
;   0461  1	!		Total data characters received for this file transfer
;   0462  1	!	SMSG%NAKS
;   0463  1	!		Total number of NAKs sent for this file transfer
;   0464  1	!	RMSG%NAKS
;   0465  1	!		Total number of NAKs received for this file transfer
;   0466  1	!	XFR%TIME
;   0467  1	!		Amount of time the last transfer took in milliseconds.
;   0468  1	!	TOTAL%TIME
;   0469  1	!		Total amount of time spend transfering data.
;   0470  1	!
;   0471  1	! Misc constants:
;   0472  1	!
;   0473  1	!	LAST%ERROR
;   0474  1	!		ASCIZ of the last error message issued.
;   0475  1	!	FILE%NAME
;   0476  1	!		Vector containing the ASCII characters of the file name.
;   0477  1	!	FILE%SIZE
;   0478  1	!		Number of characters in the FILE%NAME vector.
;   0479  1	!	DELAY
;   0480  1	!		Amount of time to delay
;   0481  1	!	DUPLEX
;   0482  1	!		DP%HALF or DP%FULL to denote either half duplex or full duplex.
;   0483  1	!		[Currently only DP%FULL is supported]
;   0484  1	!	PKT%RETRIES
;   0485  1	!		Number of retries to attempt to read a message.
;   0486  1	!	SI%RETRIES
;   0487  1	!		Number of retries to attempt on send inits
;   0488  1	!	DEBUG%FLAG
;   0489  1	!		Debugging mode on/off
;   0490  1	!	WARN%FLAG
;   0491  1	!		File warning flag
;   0492  1	!	IBM%FLAG
;   0493  1	!		True if talking to an IBM system, else false.
;   0494  1	!	ECHO%FLAG
;   0495  1	!		Local echo flag
;   0496  1	!	CONNECT%FLAG
;   0497  1	!		Connected flag; True if terminal and SET LINE are the same
;   0498  1	!	PARITY%TYPE
;   0499  1	!		Type of parity to use on sends.
;   0500  1	!	DEV%PARITY%FLAG
;   0501  1	!		Device will add parity to message.  True if device adds
;   0502  1	!		parity and false if we must do it.
;   0503  1	!
;   0504  1	!--
;   0505  1	
;   0506  1	%SBTTL 'Declarations -- Forward definitions'
;   0507  1	!<BLF/NOFORMAT>
;   0508  1	!
;   0509  1	! Forward definitions
;   0510  1	!
;   0511  1	
;   0512  1	FORWARD ROUTINE
;   0513  1	
;   0514  1	! Main loop for a complete transaction
;   0515  1	    DO%TRANSACTION,		! Perform a complete transaction
;   0516  1	
;   0517  1	! Send processing routines
;   0518  1	
;   0519  1	    SEND%SERVER%INIT,		![026] Send a server init packet
;   0520  1	    SEND%DATA,			! Send data to the micro
;   0521  1	    SEND%FILE,			! Send file name
;   0522  1	    SEND%OPEN%FILE,			! Open file for sending
;   0523  1	    SEND%GENCMD,		! Send generic command
;   0524  1	    SEND%EOF,			! Send EOF
;   0525  1	    SEND%INIT,			! Send initialization msg
;   0526  1	    SEND%BREAK,			! Send break end of transmission
;   0527  1	
;   0528  1	! Receive processing routines
;   0529  1	
;   0530  1	    REC%SERVER%IDLE,		! Wait for message while server is idle
;   0531  1	    REC%INIT,			! Receive initialization
;   0532  1	    REC%FILE,			! Receive file information
;   0533  1	    REC%DATA,			! Receive data
;   0534  1	!
;   0535  1	! Server processing routines
;   0536  1	!
;   0537  1	    SERVER%GENERIC,		! Process generic KERMIT commands
;   0538  1	    HOST%COMMAND,		! Process host command
;   0539  1	    KERMIT%COMMAND,		! Process Kermit command
;   0540  1	    CALL%SY%RTN,		! Handle calling system routine and returning result
;   0541  1	!
;   0542  1	! Statistic gathering routines
;   0543  1	!
;   0544  1	    END%STATS	: NOVALUE,	! End of a message processing stats routine
;   0545  1	
;   0546  1	! Low level send/receive routines
;   0547  1	
;   0548  1	    CALC%BLOCK%CHECK,		! Routine to calculate the block check value
;   0549  1	    SET%SEND%INIT : NOVALUE,	! Set up the MSG%SND%INIT parameters.
;   0550  1	    PRS%SEND%INIT,		! Parse MSG%SND%INIT parameters.
;   0551  1	    DO%PARITY : NOVALUE,	! Routine to generate parity for a message
;   0552  1	    GEN%PARITY,			! Routine to add parity to a character
;   0553  1	    SEND%PACKET,		! Send a packet to the remote
;   0554  1	    REC%MESSAGE,		! Receive a message with retry processing
;   0555  1	    REC%PACKET,			! Receive a packet from the remote
;   0556  1	
;   0557  1	! Utility routines
;   0558  1	
;   0559  1	    NORMALIZE%FILE : NOVALUE,	! Force file name into normal form
;   0560  1	    BFR%EMPTY,			! Empty the data buffer
;   0561  1	    BFR%FILL,			! Fill the data buffer from a file
;   0562  1	    SET%STRING,			![025] Routine to set alternate get/put routines
;   0563  1	    				! for use with in memory strings
;   0564  1	    TYPE%CHAR,			! Type a character from a packet
;   0565  1	    INIT%XFR	: NOVALUE,	! Initialize the per transfer processing
;   0566  1	    STS%OUTPUT	: NOVALUE,	! Output current transfer status
;   0567  1	!
;   0568  1	! Debugging routines
;   0569  1	!
;   0570  1	    DBG%MESSAGE	: NOVALUE,	! Type out a formatted message
;   0571  1	    DBG%SEND	: NOVALUE,	! Send message debugging routine
;   0572  1	    DBG%RECEIVE	: NOVALUE;	! Receive message debugging routine
;   0573  1		%SBTTL	'Require files'
;   0574  1	
;   0575  1	!
;   0576  1	!<BLF/FORMAT>
;   0577  1	!
;   0578  1	! REQUIRE FILES:
;   0579  1	!
;   0580  1	
; L 0581  1	%IF %BLISS (BLISS32)
; U 0582  1	%THEN
; U 0583  1	
; U 0584  1	LIBRARY 'SYS$LIBRARY:STARLET';
; U 0585  1	
;   0586  1	%FI
;   0587  1	
;   0588  1	REQUIRE 'KERCOM';
;   0789  1	
;   0790  1	REQUIRE 'KERERR';
;   0813  1	
;   0814  1	%SBTTL 'Macro definitions'
;   0815  1	!
;   0816  1	! MACROS:
;   0817  1	!
;   0818  1	
;   0819  1	MACRO
; M 0820  1	    CTL (C) =
;   0821  1	 ((C) XOR %O'100')%,
; M 0822  1	    CHAR (C) =
;   0823  1	 ((C) + %O'40')%,
; M 0824  1	    UNCHAR (C) =
;   0825  1	 ((C) - %O'40')%;
;   0826  1	
;   0827  1	%SBTTL 'KERMIT Protocol Definitions'
;   0828  1	
;   0829  1	!++
;   0830  1	! The following describes the various items that are found in the
;   0831  1	! KERMIT messages.  A complete and through desription of the protocol can be
;   0832  1	! found in the KERMIT PROTOCOL MANUAL.
;   0833  1	!
;   0834  1	!
;   0835  1	! All KERMIT messages have the following format:
;   0836  1	!
;   0837  1	! <Mark><CHAR(Count)><CHAR(Seq)><Message-dependent information><Check><EOL>
;   0838  1	!
;   0839  1	! <MARK>
;   0840  1	!	Normally SOH (Control-A, octal 001).
;   0841  1	!
;   0842  1	! <CHAR(Count)>
;   0843  1	!	Count of the number of characters following this position.
;   0844  1	!	Character counts of ONLY 0 to 94 are valid.
;   0845  1	!
;   0846  1	! <CHAR(Seq)>
;   0847  1	!	Packet sequence number, modulo 100 (octal).
;   0848  1	!
;   0849  1	! <MESSAGE-DEPENDENT INFORMATION>
;   0850  1	!	This field contains the message dependent information.  There can
;   0851  1	!	be multiple fields in this section.  See the KERMIT Protocol document
;   0852  1	!	for a complete description of this.
;   0853  1	!
;   0854  1	! <Check>
;   0855  1	!	A block check on the characters in the packet between, but not
;   0856  1	!	including, the mark and the checksum itself.  It may be one to three
;   0857  1	!	characters, depending upon the type agreed upon.
;   0858  1	!
;   0859  1	!	1. Single character arithmetic sum equal to:
;   0860  1	!		chksum = (s + ((s AND 300)/100)) AND 77
;   0861  1	!	    Character sent is CHAR(chksum).
;   0862  1	!
;   0863  1	!	2. Two character arithmetic sum.  CHAR of bits 6-11 are the first
;   0864  1	!	   character, CHAR of bits 0-5 are the second character.
;   0865  1	!
;   0866  1	!	3. Three character CRC-CCITT.  First character is CHAR of bits 12-15,
;   0867  1	!	   second is CHAR of bits 6-11, third is CHAR of bits 0-5.
;   0868  1	!
;   0869  1	!
;   0870  1	! <EOL>
;   0871  1	!	End of line.  Any line terminator that may be required by the host.
;   0872  1	!--
;   0873  1	
;   0874  1	%SBTTL 'KERMIT Protocol Definitions -- Packet offsets'
;   0875  1	
;   0876  1	!++
;   0877  1	! The following define the various offsets of the standard KERMIT
;   0878  1	! packets.
;   0879  1	!--
;   0880  1	
;   0881  1	LITERAL
;   0882  1	    PKT%MARK = 0,				! <MARK>
;   0883  1	    PKT%COUNT = 1,				! <CHAR(Count)>
;   0884  1	    PKT%SEQ = 2,				! <CHAR(Seq)>
;   0885  1	    PKT%TYPE = 3,				! <Message type>
;   0886  1	    PKT%MSG = 4,				! <MESSAGE-DEPENDENT INFORMATION>
;   0887  1	    PKT%MAX%MSG = 94 - 5,			! Maximum size of the message dependent
;   0888  1	    						!  information
;   0889  1	    PKT%CHKSUM = 0,				! <CHAR(Chksum)> offset from end of
;   0890  1	    						!    Message dependent information
;   0891  1	    PKT%EOL = 1,				! <Eol> offset from end of data
;   0892  1	    PKT%OVR%HEAD%B = 2,				! Header overhead
;   0893  1	    PKT%OVR%HEAD%E = 1,				! Overhead at the end
;   0894  1	    PKT%OVR%HEAD = 3,				! Overhead added to data length
;   0895  1	    PKT%TOT%OVR%HEAD = 6;			! Total overhead of the message
;   0896  1	
;   0897  1	%SBTTL 'KERMIT Protocol Definitions -- Message dependent field'
;   0898  1	
;   0899  1	!++
;   0900  1	! The MESSAGE-DEPENDENT information field of the message contains at
;   0901  1	! least one part.  That is the type of message.  The remainder of the message
;   0902  1	! MESSAGE-DEPENDENT field is different depending on the message.
;   0903  1	!
;   0904  1	! <TYPE><TYPE-DEPENDENT-INFORMATION>
;   0905  1	!
;   0906  1	! <TYPE>
;   0907  1	!	The type defines the type of message that is being processed.
;   0908  1	!
;   0909  1	!--
;   0910  1	
;   0911  1	! Protocol version 1.0 message types
;   0912  1	
;   0913  1	LITERAL
;   0914  1	    MSG%DATA = %C'D',				! Data packet
;   0915  1	    MSG%ACK = %C'Y',				! Acknowledgement
;   0916  1	    MSG%NAK = %C'N',				! Negative acknowledgement
;   0917  1	    MSG%SND%INIT = %C'S',			! Send initiate
;   0918  1	    MSG%BREAK = %C'B',				! Break transmission
;   0919  1	    MSG%FILE = %C'F',				! File header
;   0920  1	    MSG%EOF = %C'Z',				! End of file (EOF)
;   0921  1	    MSG%ERROR = %C'E';				! Error
;   0922  1	
;   0923  1	! Protocol version 2.0 message types
;   0924  1	
;   0925  1	LITERAL
;   0926  1	    MSG%RCV%INIT = %C'R',			! Receive initiate
;   0927  1	    MSG%COMMAND = %C'C',			! Host command
;   0928  1	    MSG%GENERIC = %C'G',			! Generic KERMIT command.
;   0929  1	    MSG%KERMIT = %C'K';				! Perform KERMIT command (text)
;   0930  1	
;   0931  1	! Protocol version 4.0 message types
;   0932  1	
;   0933  1	LITERAL
;   0934  1	    MSG%SER%INIT = %C'I',			! Server initialization
;   0935  1	    MSG%TEXT = %C'X';				! Text header message
;   0936  1	
;   0937  1	!++
;   0938  1	! Generic KERMIT commands
;   0939  1	!--
;   0940  1	
;   0941  1	LITERAL
;   0942  1	    MSG%GEN%LOGIN = %C'I',			! Login
;   0943  1	    MSG%GEN%EXIT = %C'F',			! Finish (exit to OS)
;   0944  1	    MSG%GEN%CONNECT = %C'C',			! Connect to a directory
;   0945  1	    MSG%GEN%LOGOUT = %C'L',			! Logout
;   0946  1	    MSG%GEN%DIRECTORY = %C'D',			! Directory
;   0947  1	    MSG%GEN%DISK%USAGE = %C'U',			! Disk usage
;   0948  1	    MSG%GEN%DELETE = %C'E',			! Delete a file
;   0949  1	    MSG%GEN%TYPE = %C'T',			! Type a file specification
;   0950  1	!    MSG%GEN%SUBMIT = %C'S',			! Submit
;   0951  1	!    MSG%GEN%PRINT = %C'P',			! Print
;   0952  1	    MSG%GEN%WHO = %C'W',			! Who's logged in
;   0953  1	    MSG%GEN%SEND = %C'M',			! Send a message to a user
;   0954  1	    MSG%GEN%HELP = %C'H',			! Help
;   0955  1	    MSG%GEN%QUERY = %C'Q',			! Query status
;   0956  1	    MSG%GEN%RENAME = %C'R',			! Rename file
;   0957  1	    MSG%GEN%COPY = %C'K',			! Copy file
;   0958  1	    MSG%GEN%PROGRAM = %C'P',			! Run program and pass data
;   0959  1	    MSG%GEN%JOURNAL = %C'J',			! Perform journal functions
;   0960  1	    MSG%GEN%VARIABLE = %C'V';			! Return/set variable state
;   0961  1	
;   0962  1	!
;   0963  1	! Acknowledgement modifiers (protocol 4.0)
;   0964  1	!
;   0965  1	
;   0966  1	LITERAL
;   0967  1	    MSG%ACK%ABT%CUR = %C'X',			! Abort current file
;   0968  1	    MSG%ACK%ABT%ALL = %C'Z';			! Abort entire stream of files
;   0969  1	
;   0970  1	!
;   0971  1	! End of file packet modifier
;   0972  1	!
;   0973  1	
;   0974  1	LITERAL
;   0975  1	    MSG%EOF%DISCARD = %C'D';			! Discard data from previous file
;   0976  1	
;   0977  1	%SBTTL 'KERMIT Protocol Definitions -- SEND initiate packet'
;   0978  1	
;   0979  1	!++
;   0980  1	!
;   0981  1	! The following describes the send initiate packet.  All fields in the message
;   0982  1	! data area are optional.
;   0983  1	!
;   0984  1	! <"S"><CHAR(Bufsiz)><CHAR(Timeout)><CHAR(npad)><CTL(pad)><CHAR(Eol)><Quote>
;   0985  1	!	<8-bit-quote><Check-type><Repeat-count-processing><Reserved><Reserved>
;   0986  1	!
;   0987  1	! BUFSIZ
;   0988  1	!	Sending Kermit's maximum buffer size.
;   0989  1	!
;   0990  1	! Timeout
;   0991  1	!	Number of seconds after which the sending Kermit wishes to be timed out
;   0992  1	!
;   0993  1	! Npad
;   0994  1	!	Number of padding caracters the sending Kermit needs preceding each
;   0995  1	!	packet.
;   0996  1	!
;   0997  1	! PAD
;   0998  1	!	Padding character.
;   0999  1	!
;   1000  1	! EOL
;   1001  1	!	A line terminator required on all packets set by the receiving
;   1002  1	!	Kermit.
;   1003  1	!
;   1004  1	! Quote
;   1005  1	!	The printable ASCII characer the sending Kermit will use when quoting
;   1006  1	!	the control cahracters.  Default is "#".
;   1007  1	!
;   1008  1	! 8-bit-quote
;   1009  1	!	Specify quoting mecanism for 8-bit quantities.  A quoting mecanism is
;   1010  1	!	mecessary when sending to hosts which prevent the use of the 8th bit
;   1011  1	!	for data.  When elected, the quoting mechanism will be used by both
;   1012  1	!	hosts, and the quote character must be in the range of 41-76 or 140-176
;   1013  1	!	octal, but different from the control-quoting character.  This field is
;   1014  1	!	interpreted as follows:
;   1015  1	!
;   1016  1	!	"Y" - I agree to 8-bit quoting if you request it.
;   1017  1	!	"N" - I will not do 8-bit quoting.
;   1018  1	!	"&" - (or any other character in the range of 41-76 or 140-176) I want
;   1019  1	!	      to do 8-bit quoting using this character (it will be done if the
;   1020  1	!	      other Kermit puts a "Y" in this field.
;   1021  1	!	Anything else: Quoting will not be done.
;   1022  1	!
;   1023  1	! Check-type
;   1024  1	!	Type of block check.  The only values presently allowed in this
;   1025  1	!	field are "1", "2" or "3".  Future implementations may allow other
;   1026  1	!	values.  Interpretation of the values is:
;   1027  1	!
;   1028  1	!	"1" - Single character checksum.  Default value if none specified.
;   1029  1	!	"2" - Double character checksum.
;   1030  1	!	"3" - Three character CRC.
;   1031  1	!
;   1032  1	! Repeat-count-processing
;   1033  1	!	The prefix character to be used to indicate a repeated character.
;   1034  1	!	This can be any printable cahracter other than blank (which denotes
;   1035  1	!	no repeat count).
;   1036  1	!
;   1037  1	! Fields 10 to 11 reserved.
;   1038  1	!--
;   1039  1	
;   1040  1	LITERAL
;   1041  1	    P%SI%BUFSIZ = 0,				! Buffersize
;   1042  1	    MY%PKT%SIZE = 80,				! My packet size
;   1043  1	    P%SI%TIMOUT = 1,				! Time out
;   1044  1	    MY%TIME%OUT = 15,				! My time out
;   1045  1	    P%SI%NPAD = 2,				! Number of padding characters
;   1046  1	    MY%NPAD = 0,				! Amount of padding I require
;   1047  1	    P%SI%PAD = 3,				! Padding character
;   1048  1	    MY%PAD%CHAR = 0,				! My pad character
;   1049  1	    P%SI%EOL = 4,				! End of line character
;   1050  1	    MY%EOL%CHAR = %O'015',			! My EOL cahracter
;   1051  1	    P%SI%QUOTE = 5,				! Quote character
;   1052  1	    MY%QUOTE%CHAR = %C'#',			! My quoting character
;   1053  1	    P%SI%8QUOTE = 6,				! 8-bit quote
;   1054  1	    MY%8BIT%QUOTE = %C'&',			! Don't do it
;   1055  1	    P%SI%CHKTYPE = 7,				! Checktype used
;   1056  1	    MY%CHKTYPE = CHK%1CHAR,			! Use single character checksum
;   1057  1	    P%SI%REPEAT = 8,				! Repeat character
;   1058  1	    MY%REPEAT = %C'~',				! My repeat character
;   1059  1	    P%SI%LENGTH = 9;				! Length of the message
;   1060  1	
;   1061  1	%SBTTL 'KERMIT Protocol States'
;   1062  1	
;   1063  1	!++
;   1064  1	! The following are the various states that KERMIT can be in.
;   1065  1	! The state transitions are defined in the KERMIT Protocol manual.
;   1066  1	!--
;   1067  1	
;   1068  1	LITERAL
;   1069  1	    STATE%MIN = 1,				! Min state number
;   1070  1	    STATE%S = 1,				! Send init state
;   1071  1	    STATE%SF = 2,				! Send file header
;   1072  1	    STATE%SD = 3,				! Send file data packet
;   1073  1	    STATE%SZ = 4,				! Send EOF packet
;   1074  1	    STATE%SB = 5,				! Send break
;   1075  1	    STATE%R = 6,				! Receive state (wait for send-init)
;   1076  1	    STATE%RF = 7,				! Receive file header packet
;   1077  1	    STATE%RD = 8,				! Receive file data packet
;   1078  1	    STATE%C = 9,				! Send complete
;   1079  1	    STATE%A = 10,				! Abort
;   1080  1	    STATE%SX = 11,				! Send text header
;   1081  1	    STATE%SG = 12,				! Send generic command
;   1082  1	    STATE%SI = 13,				! Send server init
;   1083  1	    STATE%ID = 14,				! Server idle loop
;   1084  1	    STATE%II = 15,				! Server idle after server init
;   1085  1	    STATE%FI = 16,				! Server should exit
;   1086  1	    STATE%LG = 17,				! Server should logout
;   1087  1	    STATE%OF = 18,				! Send - open first input file
;   1088  1	    STATE%EX = 19,				! Exit back to command parser
;   1089  1	    STATE%ER = 20,				! Retries exceeded error
;   1090  1	    STATE%MAX = 20;				! Max state number
;   1091  1	
;   1092  1	%SBTTL 'Internal constants'
;   1093  1	
;   1094  1	!++
;   1095  1	! The following represent various internal KERMSG constants.
;   1096  1	!--
;   1097  1	
;   1098  1	LITERAL
;   1099  1	    MAX%PKT%RETRIES = 16,			! Maximum packet retries
;   1100  1	    MAX%SI%RETRIES = 5;				! Maximum send init retries
;   1101  1	
;   1102  1	%SBTTL 'Storage - External'
;   1103  1	!
;   1104  1	! OWN STORAGE:
;   1105  1	!
;   1106  1	
;   1107  1	EXTERNAL
;   1108  1	!
;   1109  1	! Receive parameters
;   1110  1	!
;   1111  1	    RCV%PKT%SIZE,				! Receive packet size
;   1112  1	    RCV%NPAD,					! Padding length
;   1113  1	    RCV%PADCHAR,				! Padding character
;   1114  1	    RCV%TIMEOUT,				! Time out
;   1115  1	    RCV%EOL,					! EOL character
;   1116  1	    RCV%QUOTE%CHR,				! Quote character
;   1117  1	    RCV%SOH,					! Start of header character
;   1118  1	    RCV%8QUOTE%CHR,				! 8-bit quoting character
;   1119  1	!
;   1120  1	! Miscellaneous parameters
;   1121  1	!
;   1122  1	    SET%REPT%CHR,				! Repeat character
;   1123  1	!
;   1124  1	! Send parameters
;   1125  1	!
;   1126  1	    SND%PKT%SIZE,				! Send packet size
;   1127  1	    SND%NPAD,					! Padding length
;   1128  1	    SND%PADCHAR,				! Padding character
;   1129  1	    SND%TIMEOUT,				! Time out
;   1130  1	    SND%EOL,					! EOL character
;   1131  1	    SND%QUOTE%CHR,				! Quote character
;   1132  1	    SND%SOH,					! Start of header character
;   1133  1	    SEND%TIMEOUT,				! Time to wait for receiving message
;   1134  1	!
;   1135  1	! Server parameters
;   1136  1	!
;   1137  1	    SRV%TIMEOUT,				! Time between NAK's when server is idle
;   1138  1	!
;   1139  1	! Statistics
;   1140  1	!
;   1141  1	    SND%TOTAL%CHARS,				! Total characters sent
;   1142  1	    RCV%TOTAL%CHARS,				! Total characters received
;   1143  1	    SND%DATA%CHARS,				! Total number of data characters sent
;   1144  1	    RCV%DATA%CHARS,				! Total number of data characters received
;   1145  1	    SND%NAKS,					! Total NAKs sent
;   1146  1	    RCV%NAKS,					! Total NAKs received
;   1147  1	    SND%COUNT,					! Count of total number of packets
;   1148  1	    RCV%COUNT,					! Count of total number packets received
;   1149  1	    SMSG%COUNT,					! Total number of packets sent
;   1150  1	    RMSG%COUNT,					! Total number of packets received
;   1151  1	    SMSG%TOTAL%CHARS,				! Total chars sent this file xfer
;   1152  1	    RMSG%TOTAL%CHARS,				! Total chars rcvd this file xfer
;   1153  1	    SMSG%DATA%CHARS,				! Total data chars this file xfer
;   1154  1	    RMSG%DATA%CHARS,				! Total data chars this file xfer
;   1155  1	    SMSG%NAKS,					! Total number of NAKs this file xfer
;   1156  1	    RMSG%NAKS,					! Total number of NAKs received
;   1157  1	    XFR%TIME,					! Amount of time last xfr took
;   1158  1	    TOTAL%TIME,					! Total time of all xfrs
;   1159  1	    						!  this file xfer
;   1160  1	    LAST%ERROR : VECTOR [CH$ALLOCATION (MAX%MSG + 1)],	! Last error message
;   1161  1	!
;   1162  1	! Misc constants.
;   1163  1	!
;   1164  1	    FILE%NAME : VECTOR [CH$ALLOCATION (MAX%FILE%NAME)],
;   1165  1	    FILE%SIZE,
;   1166  1	    SI%RETRIES,					! Send init retries to attempt
;   1167  1	    PKT%RETRIES,				! Number of retries to try for a message
;   1168  1	    DELAY,					! Amount of time to delay
;   1169  1	    DUPLEX,					! Type of connection (half or full)
;   1170  1	    PARITY%TYPE,				! Type of parity to use
;   1171  1	    DEV%PARITY%FLAG,				! True if output device does
;   1172  1	    						!  parity, false if we do it
;   1173  1	    CHKTYPE,					! Type of block check desired
;   1174  1	    ABT%FLAG,					! True if aborted file should be discarded
;   1175  1	    DEBUG%FLAG,					! Debugging mode on/off
;   1176  1	    WARN%FLAG,					! File warning flag
;   1177  1	    IBM%FLAG,					! Talking to an IBM system
;   1178  1	    IBM%CHAR,					! Turnaround character for IBM mode
;   1179  1	    ECHO%FLAG,					! Local echo flag
;   1180  1	    CONNECT%FLAG,				! Connected flag; True if
;   1181  1	    						!  terminal and SET LINE are
;   1182  1	    						!  the same
;   1183  1	    ABT%CUR%FILE,				! Abort current file
;   1184  1	    ABT%ALL%FILE,				! Abort all files in stream
;   1185  1	    TYP%STS%FLAG,				! Type status next message
;   1186  1	    TY%FIL,					! Type file specs
;   1187  1	    TY%PKT,					! Type packet info
;   1188  1	    FIL%NORMAL%FORM,				! If true, file names should be normalized
;   1189  1	    GEN%1DATA : VECTOR [CH$ALLOCATION (MAX%MSG)],	! Data for generic command
;   1190  1	    GEN%1SIZE,					! Size of data in GEN%1DATA
;   1191  1	    GEN%2DATA : VECTOR [CH$ALLOCATION (MAX%MSG)],	! Second argument for generic command
;   1192  1	    GEN%2SIZE,					! Size of data in GEN%2DATA
;   1193  1	    GEN%3DATA : VECTOR [CH$ALLOCATION (MAX%MSG)],	! Third arg for generic command
;   1194  1	    GEN%3SIZE;					! Size of data in GEN%3DATA
;   1195  1	
;   1196  1	%SBTTL 'Storage - Local'
;   1197  1	!
;   1198  1	! LOCAL OWN STORAGE:
;   1199  1	!
;   1200  1	
;   1201  1	OWN
;   1202  1	!
;   1203  1	! Receive parameters
;   1204  1	!
;   1205  1	    RECV%8QUOTE%CHR,				! 8th-bit quoting character
;   1206  1	    REPT%CHR,					! Repeat prefix character
;   1207  1	!
;   1208  1	! Send parameters
;   1209  1	!
;   1210  1	    SEND%PKT%SIZE,				! Send packet size
;   1211  1	    SEND%NPAD,					! Padding length
;   1212  1	    SEND%PADCHAR,				! Padding character
;   1213  1	    SEND%EOL,					! EOL character
;   1214  1	    SEND%QUOTE%CHR,				! Quote character
;   1215  1	    SEND%8QUOTE%CHR,				! 8-bit quoting character
;   1216  1	!
;   1217  1	! Misc parameters
;   1218  1	!
;   1219  1	    INI%CHK%TYPE,				! Type of block checking from init message
;   1220  1	    BLK%CHK%TYPE,				! Type of block check to use
;   1221  1	    FLAG%8QUOTE,				! Flag to determine if doing 8bit quoting
;   1222  1	    FLAG%REPEAT,				! True if doing repeated character compression
;   1223  1	    STATE,					! Current state
;   1224  1	    SIZE,					! Size of the current message
;   1225  1	    OLD%RETRIES,				! Saved number of retries done.
;   1226  1	    NUM%RETRIES,				! Number of retries
;   1227  1	    MSG%NUMBER,					! Current message number
;   1228  1	    REC%SEQ,					! Sequence number of msg in REC%MSG
;   1229  1	    REC%LENGTH,					! Length of the message recv'd
;   1230  1	    REC%TYPE,					! Type of the message received.
;   1231  1	    REC%MSG : VECTOR [CH$ALLOCATION (MAX%MSG, CHR%SIZE)],	! Message received
;   1232  1	    SND%MSG : VECTOR [CH$ALLOCATION (MAX%MSG, CHR%SIZE)],	! Message sent
;   1233  1	    FILE%OPEN%FLAG,				! File is opened.
;   1234  1	    FILE%CHARS,					! Number of characters sent or received
;   1235  1	    TEXT%HEAD%FLAG,				! Text header received, not file header
;   1236  1	    NO%FILE%NEEDED,				! Don't open a file
;   1237  1	    INIT%PKT%SENT,				! Server-init sent and ACKed
;   1238  1	    GEN%TYPE,					! Command message type
;   1239  1	    GEN%SUBTYPE,				! Generic command subtype
;   1240  1	    GET%CHR%ROUTINE,			![025] Address of routine to get a character for BFR%FILL
;   1241  1	    PUT%CHR%ROUTINE;			![025] Address of routine to put a character for BFR%EMPTY
;   1242  1	
;   1243  1	%SBTTL 'External references'
;   1244  1	!
;   1245  1	! EXTERNAL REFERENCES:
;   1246  1	!
;   1247  1	! Packet I/O routines
;   1248  1	
;   1249  1	EXTERNAL ROUTINE
;   1250  1	    SEND,					! Send a packet to the remote
;   1251  1	    IBM%WAIT,					! Wait for IBM turnaround
;   1252  1	    RECEIVE;					! Receive a packet from the remote
;   1253  1	
;   1254  1	!
;   1255  1	! Terminal I/O routines
;   1256  1	!
;   1257  1	
;   1258  1	EXTERNAL ROUTINE
;   1259  1	    TERM%DUMP : NOVALUE,			! Normal terminal output
;   1260  1	    DBG%DUMP : NOVALUE,				! Debugging output
;   1261  1	    TT%SET%OUTPUT,				! Set output routine
;   1262  1	    TT%CHAR : NOVALUE,				! Output a single character
;   1263  1	    TT%CRLF : NOVALUE,				! Output a CRLF
;   1264  1	    TT%NUMBER : NOVALUE,			! Output a three digit number to the
;   1265  1	    						!  terminal
;   1266  1	    TT%TEXT : NOVALUE,				! Output a string to the user's
;   1267  1	    TT%OUTPUT : NOVALUE;			! Force buffered output to terminal
;   1268  1	
;   1269  1	! Operating system routines and misc routines
;   1270  1	
;   1271  1	EXTERNAL ROUTINE
;   1272  1	    CRCCLC,					! Calculate a CRC-CCITT
;   1273  1	    XFR%STATUS : NOVALUE,			! Routine to tell the user the
;   1274  1	    						!  status of a transfer
;   1275  1	    KRM%ERROR : NOVALUE,			! Issue an error message
;   1276  1	    SY%LOGOUT : NOVALUE,			! Log the job off
;   1277  1	    SY%GENERIC,					! Perform a generic command
;   1278  1	    SY%TIME,					! Return elapsed time in milliseconds
;   1279  1	    SY%DISMISS : NOVALUE;			! Routine to dismiss for n seconds.
;   1280  1	
;   1281  1	!
;   1282  1	! External file processing routines
;   1283  1	!
;   1284  1	
;   1285  1	EXTERNAL ROUTINE
;   1286  1	    FILE%OPEN,					! Open a file for reading/writing
;   1287  1	    FILE%CLOSE,					! Close an open file
;   1288  1	    NEXT%FILE,					! Determine if there is a next file
;   1289  1	    						!  and open it for reading.
;   1290  1	    GET%FILE,					! Get a byte from the file
;   1291  1	    PUT%FILE;					! Put a byte in the file.
;   1292  1	
;   1293  1	%SBTTL 'MSG%INIT'
;   1294  1	
;   1295  1	GLOBAL ROUTINE MSG%INIT : NOVALUE =
;   1296  1	
;   1297  1	!++
;   1298  1	! FUNCTIONAL DESCRIPTION:
;   1299  1	!
;   1300  1	!	This routine will initialize the message processing for
;   1301  1	!	KERMIT-32/36.
;   1302  1	!
;   1303  1	! CALLING SEQUENCE:
;   1304  1	!
;   1305  1	!	MSG%INIT();
;   1306  1	!
;   1307  1	! INPUT PARAMETERS:
;   1308  1	!
;   1309  1	!	None.
;   1310  1	!
;   1311  1	! IMPLICIT INPUTS:
;   1312  1	!
;   1313  1	!	None.
;   1314  1	!
;   1315  1	! OUTPUT PARAMETERS:
;   1316  1	!
;   1317  1	!	None.
;   1318  1	!
;   1319  1	! IMPLICIT OUTPUTS:
;   1320  1	!
;   1321  1	!	None.
;   1322  1	!
;   1323  1	! COMPLETION CODES:
;   1324  1	!
;   1325  1	!	None.
;   1326  1	!
;   1327  1	! SIDE EFFECTS:
;   1328  1	!
;   1329  1	!	None.
;   1330  1	!
;   1331  1	!--
;   1332  1	
;   1333  2	    BEGIN
;   1334  2	!
;   1335  2	! Initialize some variables
;   1336  2	!
;   1337  2	! Receive parameters first
;   1338  2	!
;   1339  2	    RCV%PKT%SIZE = MY%PKT%SIZE;
;   1340  2	    RCV%NPAD = MY%NPAD;
;   1341  2	    RCV%PADCHAR = MY%PAD%CHAR;
;   1342  2	    RCV%TIMEOUT = MY%TIME%OUT;
;   1343  2	    RCV%EOL = MY%EOL%CHAR;
;   1344  2	    RCV%QUOTE%CHR = MY%QUOTE%CHAR;
;   1345  2	    RCV%SOH = CHR%SOH;
;   1346  2	    RCV%8QUOTE%CHR = MY%8BIT%QUOTE;
;   1347  2	    SET%REPT%CHR = MY%REPEAT;
;   1348  2	!
;   1349  2	! Send parameters.
;   1350  2	!
;   1351  2	    SND%PKT%SIZE = -MY%PKT%SIZE;
;   1352  2	    SND%NPAD = -MY%NPAD;
;   1353  2	    SND%PADCHAR = -MY%PAD%CHAR;
;   1354  2	    SND%TIMEOUT = -MY%TIME%OUT;
;   1355  2	    SND%EOL = -MY%EOL%CHAR;
;   1356  2	    SND%QUOTE%CHR = -MY%QUOTE%CHAR;
;   1357  2	    SND%SOH = CHR%SOH;
;   1358  2	!
;   1359  2	! Server parameters
;   1360  2	!
;   1361  2	    SRV%TIMEOUT = 5*MY%TIME%OUT;
;   1362  2	!
;   1363  2	! Other random parameters
;   1364  2	!
;   1365  2	    PKT%RETRIES = MAX%PKT%RETRIES;		! Number of retries per message
;   1366  2	    SI%RETRIES = MAX%SI%RETRIES;		! Number of retries on send inits
;   1367  2	    DELAY = INIT%DELAY;
;   1368  2	    DUPLEX = DP%FULL;				! Use full duplex
;   1369  2	    DEBUG%FLAG = FALSE;
;   1370  2	    WARN%FLAG = FALSE;
;   1371  2	    ECHO%FLAG = FALSE;
;   1372  2	    BLK%CHK%TYPE = CHK%1CHAR;			! Start using single char checksum
;   1373  2	    CHKTYPE = MY%CHKTYPE;			! Desired block check type
;   1374  2	    INI%CHK%TYPE = .CHKTYPE;			! Same as default for now
;   1375  2	    DEV%PARITY%FLAG = FALSE;			! We generate parity
;   1376  2	    PARITY%TYPE = PR%NONE;			! No parity
;   1377  2	    ABT%FLAG = TRUE;				! Discard incomplete files
;   1378  2	    FILE%OPEN%FLAG = FALSE;
;   1379  2	    IBM%FLAG = FALSE;				! Not talking to an IBM
;   1380  2	    IBM%CHAR = CHR%DC1;				! XON is IBM turnaround character
;   1381  2	    TY%FIL = TRUE;				! Default to typing files
;   1382  2	    TY%PKT = FALSE;				! But not packet numbers
;   1383  2	    FIL%NORMAL%FORM = FNM%NORMAL;		! Default to normal form names
;   1384  2	    GET%CHR%ROUTINE = GET%FILE;			![025] Initialize the get-a-char routine
;   1385  2	    PUT%CHR%ROUTINE = PUT%FILE;			![025] And the put-a-char
;   1386  1	    END;					! End of MSG%INIT


	TITLE	KERMSG
	TWOSEG


;[CSM]	.REQUEST  DSKB:B361LB.REL[1,5]
	.REQUEST  SYS:B361LB.REL	;[CSM]


	RELOC	0
; RECV%8QUOTE%CHR
U.37:	BLOCK	1
; REPT%CHR
U.38:	BLOCK	1
; SEND%PKT%SIZE
U.39:	BLOCK	1
; SEND%NPAD
U.40:	BLOCK	1
; SEND%PADCHAR
U.41:	BLOCK	1
; SEND%EOL
U.42:	BLOCK	1
; SEND%QUOTE%CHR
U.43:	BLOCK	1
; SEND%8QUOTE%CHR
U.44:	BLOCK	1
; INI%CHK%TYPE
U.45:	BLOCK	1
; BLK%CHK%TYPE
U.46:	BLOCK	1
; FLAG%8QUOTE
U.47:	BLOCK	1
; FLAG%REPEAT
U.48:	BLOCK	1
; STATE
U.49:	BLOCK	1
; SIZE
U.50:	BLOCK	1
; OLD%RETRIES
U.51:	BLOCK	1
; NUM%RETRIES
U.52:	BLOCK	1
; MSG%NUMBER
U.53:	BLOCK	1
; REC%SEQ
U.54:	BLOCK	1
; REC%LENGTH
U.55:	BLOCK	1
; REC%TYPE
U.56:	BLOCK	1
; REC%MSG
U.57:	BLOCK	30
; SND%MSG
U.58:	BLOCK	30
; FILE%OPEN%FLAG
U.59:	BLOCK	1
; FILE%CHARS
U.60:	BLOCK	1
; TEXT%HEAD%FLAG
U.61:	BLOCK	1
; NO%FILE%NEEDED
U.62:	BLOCK	1
; INIT%PKT%SENT
U.63:	BLOCK	1
; GEN%TYPE
U.64:	BLOCK	1
; GEN%SUBTYPE
U.65:	BLOCK	1
; GET%CHR%ROUTINE
U.66:	BLOCK	1
; PUT%CHR%ROUTINE
U.67:	BLOCK	1


	EXTERN	RCV%PKT%SIZE, RCV%NPAD, RCV%PADCHAR, RCV%TIMEOUT, RCV%EOL, RCV%QUOTE%CHR, RCV%SOH
	EXTERN	RCV%8QUOTE%CHR, SET%REPT%CHR, SND%PKT%SIZE, SND%NPAD, SND%PADCHAR, SND%TIMEOUT, SND%EOL
	EXTERN	SND%QUOTE%CHR, SND%SOH, SEND%TIMEOUT, SRV%TIMEOUT, SND%TOTAL%CHARS, RCV%TOTAL%CHARS
	EXTERN	SND%DATA%CHARS, RCV%DATA%CHARS, SND%NAKS, RCV%NAKS, SND%COUNT, RCV%COUNT, SMSG%COUNT
	EXTERN	RMSG%COUNT, SMSG%TOTAL%CHARS, RMSG%TOTAL%CHARS, SMSG%DATA%CHARS, RMSG%DATA%CHARS, SMSG%NAKS
	EXTERN	RMSG%NAKS, XFR%TIME, TOTAL%TIME, LAST%ERROR, FILE%NAME, FILE%SIZE, SI%RETRIES, PKT%RETRIES
	EXTERN	DELAY, DUPLEX, PARITY%TYPE, DEV%PARITY%FLAG, CHKTYPE, ABT%FLAG, DEBUG%FLAG, WARN%FLAG
	EXTERN	IBM%FLAG, IBM%CHAR, ECHO%FLAG, CONNECT%FLAG, ABT%CUR%FILE, ABT%ALL%FILE, TYP%STS%FLAG
	EXTERN	TY%FIL, TY%PKT, FIL%NORMAL%FORM, GEN%1DATA, GEN%1SIZE, GEN%2DATA, GEN%2SIZE, GEN%3DATA
	EXTERN	GEN%3SIZE, SEND, IBM%WAIT, RECEIVE, TERM%DUMP, DBG%DUMP, TT%SET%OUTPUT, TT%CHAR, TT%CRLF
	EXTERN	TT%NUMBER, TT%TEXT, TT%OUTPUT, CRCCLC, XFR%STATUS, KRM%ERROR, SY%LOGOUT, SY%GENERIC
	EXTERN	SY%TIME, SY%DISMISS, FILE%OPEN, FILE%CLOSE, NEXT%FILE, GET%FILE, PUT%FILE


FNM%NORMAL==:	    1
FNM%FULL==:	    2
FNM%UNTRAN==:	    4
PR%MIN==:	    0
PR%NONE==:	    0
PR%MARK==:	    1
PR%EVEN==:	    2
PR%ODD==:	    3
PR%SPACE==:	    4
PR%MAX==:	    4
GC%MIN==:	    1
GC%EXIT==:	    1
GC%DIRECTORY==:     2
GC%DISK%USAGE==:    3
GC%DELETE==:	    4
GC%TYPE==:	    5
GC%HELP==:	    6
GC%LOGOUT==:	    7
GC%LGN==:	    10
GC%CONNECT==:	    11
GC%RENAME==:	    12
GC%COPY==:	    13
GC%WHO==:	    14
GC%SEND%MSG==:	    15
GC%STATUS==:	    16
GC%COMMAND==:	    17
GC%KERMIT==:	    20
GC%JOURNAL==:	    21
GC%VARIABLE==:	    22
GC%PROGRAM==:	    23
GC%MAX==:	    23
DP%FULL==:	    0
DP%HALF==:	    1
CHK%1CHAR==:	    61
CHK%2CHAR==:	    62
CHK%CRC==:	    63
MAX%MSG==:	    140


AC0=	0
AC1=	1
AC2=	2
AC3=	3
AC4=	4
AC5=	5
AC6=	6
AC7=	7
AC10=	10
AC11=	11
AC12=	12
AC13=	13
AC14=	14
FP=	15
AC16=	16
SP=	17


	RELOC	400000
MSG%INIT::
	MOVEI	AC1,120				; AC1,120									1339
	MOVEM	AC1,RCV%PKT%SIZE		; AC1,RCV%PKT%SIZE
	SETZM	RCV%NPAD			; RCV%NPAD									1340
	SETZM	RCV%PADCHAR			; RCV%PADCHAR									1341
	MOVEI	AC1,17				; AC1,17									1342
	MOVEM	AC1,RCV%TIMEOUT			; AC1,RCV%TIMEOUT
	MOVEI	AC1,15				; AC1,15									1343
	MOVEM	AC1,RCV%EOL			; AC1,RCV%EOL
	MOVEI	AC1,43				; AC1,43									1344
	MOVEM	AC1,RCV%QUOTE%CHR		; AC1,RCV%QUOTE%CHR
	MOVEI	AC1,1				; AC1,1										1345
	MOVEM	AC1,RCV%SOH			; AC1,RCV%SOH
	MOVEI	AC1,46				; AC1,46									1346
	MOVEM	AC1,RCV%8QUOTE%CHR		; AC1,RCV%8QUOTE%CHR
	MOVEI	AC1,176				; AC1,176									1347
	MOVEM	AC1,SET%REPT%CHR		; AC1,SET%REPT%CHR
	HRROI	AC1,-120			; AC1,-120									1351
	MOVEM	AC1,SND%PKT%SIZE		; AC1,SND%PKT%SIZE
	SETZM	SND%NPAD			; SND%NPAD									1352
	SETZM	SND%PADCHAR			; SND%PADCHAR									1353
	HRROI	AC1,-17				; AC1,-17									1354
	MOVEM	AC1,SND%TIMEOUT			; AC1,SND%TIMEOUT
	HRROI	AC1,-15				; AC1,-15									1355
	MOVEM	AC1,SND%EOL			; AC1,SND%EOL
	HRROI	AC1,-43				; AC1,-43									1356
	MOVEM	AC1,SND%QUOTE%CHR		; AC1,SND%QUOTE%CHR
	MOVEI	AC1,1				; AC1,1										1357
	MOVEM	AC1,SND%SOH			; AC1,SND%SOH
	MOVEI	AC1,113				; AC1,113									1361
	MOVEM	AC1,SRV%TIMEOUT			; AC1,SRV%TIMEOUT
	MOVEI	AC1,20				; AC1,20									1365
	MOVEM	AC1,PKT%RETRIES			; AC1,PKT%RETRIES
	MOVEI	AC1,5				; AC1,5										1366
	MOVEM	AC1,SI%RETRIES			; AC1,SI%RETRIES
	MOVEI	AC1,5				; AC1,5										1367
	MOVEM	AC1,DELAY			; AC1,DELAY
	SETZM	DUPLEX				; DUPLEX									1368
	SETZM	DEBUG%FLAG			; DEBUG%FLAG									1369
	SETZM	WARN%FLAG			; WARN%FLAG									1370
	SETZM	ECHO%FLAG			; ECHO%FLAG									1371
	MOVEI	AC1,61				; AC1,61									1372
	MOVEM	AC1,U.46			; AC1,BLK%CHK%TYPE
	MOVEI	AC1,61				; AC1,61									1373
	MOVEM	AC1,CHKTYPE			; AC1,CHKTYPE
	MOVEM	AC1,U.45			; AC1,INI%CHK%TYPE								1374
	SETZM	DEV%PARITY%FLAG			; DEV%PARITY%FLAG								1375
	SETZM	PARITY%TYPE			; PARITY%TYPE									1376
	MOVEI	AC1,1				; AC1,1										1377
	MOVEM	AC1,ABT%FLAG			; AC1,ABT%FLAG
	SETZM	U.59				; FILE%OPEN%FLAG								1378
	SETZM	IBM%FLAG			; IBM%FLAG									1379
	MOVEI	AC1,21				; AC1,21									1380
	MOVEM	AC1,IBM%CHAR			; AC1,IBM%CHAR
	MOVEI	AC1,1				; AC1,1										1381
	MOVEM	AC1,TY%FIL			; AC1,TY%FIL
	SETZM	TY%PKT				; TY%PKT									1382
	MOVEI	AC1,1				; AC1,1										1383
	MOVEM	AC1,FIL%NORMAL%FORM		; AC1,FIL%NORMAL%FORM
	MOVEI	AC1,GET%FILE			; AC1,GET%FILE									1384
	MOVEM	AC1,U.66			; AC1,GET%CHR%ROUTINE
	MOVEI	AC1,PUT%FILE			; AC1,PUT%FILE									1385
	MOVEM	AC1,U.67			; AC1,PUT%CHR%ROUTINE
	POPJ	SP,				; SP,										1295

; Routine Size:  63 words


;   1387  1	
;   1388  1	%SBTTL 'SND%ERROR'
;   1389  1	
;   1390  1	GLOBAL ROUTINE SND%ERROR (COUNT, ADDRESS) : NOVALUE =
;   1391  1	
;   1392  1	!++
;   1393  1	! FUNCTIONAL DESCRIPTION:
;   1394  1	!
;   1395  1	!	This routine will send an error packet to the remote KERMIT.  It
;   1396  1	!	is called with the count of characters and the address of the text.
;   1397  1	!
;   1398  1	! CALLING SEQUENCE:
;   1399  1	!
;   1400  1	!	SND%ERROR(COUNT, %ASCII 'Error text');
;   1401  1	!
;   1402  1	! INPUT PARAMETERS:
;   1403  1	!
;   1404  1	!	None.
;   1405  1	!
;   1406  1	! IMPLICIT INPUTS:
;   1407  1	!
;   1408  1	!	None.
;   1409  1	!
;   1410  1	! OUTPUT PARAMETERS:
;   1411  1	!
;   1412  1	!	None.
;   1413  1	!
;   1414  1	! IMPLICIT OUTPUTS:
;   1415  1	!
;   1416  1	!	None.
;   1417  1	!
;   1418  1	! COMPLETION CODES:
;   1419  1	!
;   1420  1	!	None.
;   1421  1	!
;   1422  1	! SIDE EFFECTS:
;   1423  1	!
;   1424  1	!
;   1425  1	!--
;   1426  1	
;   1427  2	    BEGIN
;   1428  2	!
;   1429  2	! Pack the message into the buffer
;   1430  2	!
;   1431  2	    SET%STRING (CH$PTR (.ADDRESS), .COUNT, TRUE);
;   1432  2	    BFR%FILL (TRUE);
;   1433  2	    SET%STRING (0, 0, FALSE);
;   1434  2	!
;   1435  2	! Save the last error message also
;   1436  2	!
;   1437  2	
;   1438  2	    IF .COUNT GTR MAX%MSG THEN COUNT = MAX%MSG;
;   1439  2	
;   1440  2	    CH$COPY (.COUNT, CH$PTR (.ADDRESS), 0, MAX%MSG + 1, CH$PTR (LAST%ERROR));
;   1441  2	
;   1442  2	    IF NOT SEND%PACKET (MSG%ERROR, .SIZE, .MSG%NUMBER) THEN RETURN KER%ABORTED;
;   1443  2	
;   1444  1	    END;					! End of SND%ERROR


SND%ERROR::
	PUSH	SP,AC14				; SP,AC14									1390
	PUSH	SP,AC16				; SP,AC16
	MOVE	AC16,-3(SP)			; AC16,ADDRESS									1431
	MOVEI	AC1,-1(AC16)			; AC1,-1(AC16)
	HRLI	AC1,10700			; AC1,10700
	PUSH	SP,AC1				; SP,AC1
	MOVE	AC14,-5(SP)			; AC14,COUNT
	PUSH	SP,AC14				; SP,AC14
	PUSH	SP,C.2				; SP,[1]
	PUSHJ	SP,U.30				; SP,SET%STRING
	PUSH	SP,C.2				; SP,[1]									1432
	PUSHJ	SP,U.29				; SP,BFR%FILL
	SETZM	-2(SP)				; -2(SP)									1433
	SETZM	-1(SP)				; -1(SP)
	SETZM	0(SP)				; 0(SP)
	PUSHJ	SP,U.30				; SP,SET%STRING
	CAIG	AC14,140			; AC14,140									1438
	JRST	L.1				; L.1
	MOVEI	AC1,140				; AC1,140
	MOVEM	AC1,-10(SP)			; AC1,COUNT
L.1:	MOVEI	AC2,-1(AC16)			; AC2,-1(AC16)									1440
	HRLI	AC2,10700			; AC2,10700
	MOVE	AC1,-10(SP)			; AC1,COUNT
	MOVEI	AC4,141				; AC4,141
	MOVE	AC5,C.3				; AC5,[POINT 7,LAST%ERROR-1,34]  <1,7>
	EXTEND	AC1,C.1				; AC1,C.1
	JFCL					;
	PUSH	SP,C.4				; SP,[105]									1442
	PUSH	SP,U.50				; SP,SIZE
	PUSH	SP,U.53				; SP,MSG%NUMBER
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	ADJSP	SP,-7				; SP,-7
	POP	SP,AC16				; SP,AC16									1390
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,
C.1:	MOVSLJ					;
	EXP	0				; 0
C.2:	EXP	1				; 1
C.3:	POINT	7,LAST%ERROR-1,34		; 7,LAST%ERROR-1,34
C.4:	EXP	105				; 105

; Routine Size:  40 words


;   1445  1	
;   1446  1	%SBTTL 'SERVER - Server mode'
;   1447  1	
;   1448  1	GLOBAL ROUTINE SERVER =
;   1449  1	
;   1450  1	!++
;   1451  1	! FUNCTIONAL DESCRIPTION:
;   1452  1	!
;   1453  1	!	This routine will handle the server function in the v2.0 protocol
;   1454  1	!	for KERMIT.  This routine by it's nature will call various operating
;   1455  1	!	system routines to do things like logging off the system.
;   1456  1	!
;   1457  1	! CALLING SEQUENCE:
;   1458  1	!
;   1459  1	!	EXIT%FLAG = SERVER();
;   1460  1	!
;   1461  1	! INPUT PARAMETERS:
;   1462  1	!
;   1463  1	!	None.
;   1464  1	!
;   1465  1	! IMPLICIT INPUTS:
;   1466  1	!
;   1467  1	!	None.
;   1468  1	!
;   1469  1	! OUTPUT PARAMETERS:
;   1470  1	!
;   1471  1	!	None.
;   1472  1	!
;   1473  1	! IMPLICIT OUTPUTS:
;   1474  1	!
;   1475  1	!	None.
;   1476  1	!
;   1477  1	! COMPLETION CODES:
;   1478  1	!
;   1479  1	!	None.
;   1480  1	!
;   1481  1	! SIDE EFFECTS:
;   1482  1	!
;   1483  1	!	None.
;   1484  1	!
;   1485  1	!--
;   1486  1	
;   1487  2	    BEGIN
;   1488  2	
;   1489  2	    LOCAL
;   1490  2		STATUS;					! Status returned by various routines
;   1491  2	
;   1492  2	    DO
;   1493  3		BEGIN
;   1494  3		INIT%XFR ();
;   1495  3		XFR%STATUS (%C'T', %C'I');		! Now idle
;   1496  3		STATUS = DO%TRANSACTION (STATE%ID);
;   1497  3		END
;   1498  2	    UNTIL .STATUS EQL KER%EXIT OR .STATUS EQL KER%ABORTED;
;   1499  2	
;   1500  2	    RETURN .STATUS;
;   1501  1	    END;					! End of GLOBAL ROUTINE SERVER


SERVER::PUSH	SP,AC16				; SP,AC16									1448
L.2:	PUSHJ	SP,U.32				; SP,INIT%XFR									1494
	PUSH	SP,C.5				; SP,[124]									1495
	PUSH	SP,C.6				; SP,[111]
	PUSHJ	SP,XFR%STATUS			; SP,XFR%STATUS
	PUSH	SP,C.7				; SP,[16]									1496
	PUSHJ	SP,U.1				; SP,DO%TRANSACTION
	MOVE	AC16,AC1			; STATUS,AC1
	ADJSP	SP,-3				; SP,-3										1493
	CAIN	AC16,223			; STATUS,223									1498
	JRST	L.3				; L.3
	CAIE	AC16,312			; STATUS,312
	JRST	L.2				; L.2										1492
L.3:	MOVE	AC1,AC16			; AC1,STATUS									1487
	POP	SP,AC16				; SP,AC16									1448
	POPJ	SP,				; SP,
C.5:	EXP	124				; 124
C.6:	EXP	111				; 111
C.7:	EXP	16				; 16

; Routine Size:  19 words


;   1502  1	
;   1503  1	%SBTTL 'SEND%SWITCH'
;   1504  1	
;   1505  1	GLOBAL ROUTINE SEND%SWITCH =
;   1506  1	
;   1507  1	!++
;   1508  1	! FUNCTIONAL DESCRIPTION:
;   1509  1	!
;   1510  1	!	This routine is the state table switcher for sending files.  It
;   1511  1	!	loops until either it is finished or an error is encountered.  The
;   1512  1	!	routines called by SEND%SWITCH are responsible for changing the state.
;   1513  1	!
;   1514  1	! CALLING SEQUENCE:
;   1515  1	!
;   1516  1	!	SEND%SWITCH();
;   1517  1	!
;   1518  1	! INPUT PARAMETERS:
;   1519  1	!
;   1520  1	!	None.
;   1521  1	!
;   1522  1	! IMPLICIT INPUTS:
;   1523  1	!
;   1524  1	!	None.
;   1525  1	!
;   1526  1	! OUTPUT PARAMETERS:
;   1527  1	!
;   1528  1	!	Returns:
;   1529  1	!	    TRUE - File sent correctly.
;   1530  1	!	    FALSE - Aborted sending the file.
;   1531  1	!
;   1532  1	! IMPLICIT OUTPUTS:
;   1533  1	!
;   1534  1	!	None.
;   1535  1	!
;   1536  1	! COMPLETION CODES:
;   1537  1	!
;   1538  1	!	None.
;   1539  1	!
;   1540  1	! SIDE EFFECTS:
;   1541  1	!
;   1542  1	!	None.
;   1543  1	!
;   1544  1	!--
;   1545  1	
;   1546  2	    BEGIN
;   1547  2	
;   1548  2	    LOCAL
;   1549  2		STATUS;					! Status result
;   1550  2	
;   1551  2	    IF .CONNECT%FLAG THEN SY%DISMISS (.DELAY);	! Sleep if the user wanted us to
;   1552  2	
;   1553  2	    INIT%XFR ();				! Initialize for this transfer
;   1554  2	    TEXT%HEAD%FLAG = FALSE;			! Set text flag correctly
;   1555  2	    XFR%STATUS (%C'I', %C'S');			! Start of file send
;   1556  2	    STATUS = DO%TRANSACTION (STATE%S);		! Call routine to do real work
;   1557  2	    XFR%STATUS (%C'T', %C'S');			! Done with send
;   1558  2	    RETURN .STATUS;				! Return the result
;   1559  1	    END;


SEND%SWITCH::
	PUSH	SP,AC16				; SP,AC16									1505
	MOVEI	AC1,1				; AC1,1										1551
	TDNN	AC1,CONNECT%FLAG		; AC1,CONNECT%FLAG
	JRST	L.4				; L.4
	PUSH	SP,DELAY			; SP,DELAY
	PUSHJ	SP,SY%DISMISS			; SP,SY%DISMISS
	ADJSP	SP,-1				; SP,-1
L.4:	PUSHJ	SP,U.32				; SP,INIT%XFR									1553
	SETZM	U.61				; TEXT%HEAD%FLAG								1554
	PUSH	SP,C.6				; SP,[111]									1555
	PUSH	SP,C.8				; SP,[123]
	PUSHJ	SP,XFR%STATUS			; SP,XFR%STATUS
	PUSH	SP,C.2				; SP,[1]									1556
	PUSHJ	SP,U.1				; SP,DO%TRANSACTION
	MOVE	AC16,AC1			; STATUS,AC1
	PUSH	SP,C.5				; SP,[124]									1557
	PUSH	SP,C.8				; SP,[123]
	PUSHJ	SP,XFR%STATUS			; SP,XFR%STATUS
	ADJSP	SP,-5				; SP,-5										1558
	MOVE	AC1,AC16			; AC1,STATUS									1546
	POP	SP,AC16				; SP,AC16									1505
	POPJ	SP,				; SP,
C.8:	EXP	123				; 123

; Routine Size:  23 words


;   1560  1	
;   1561  1	%SBTTL 'REC%SWITCH'
;   1562  1	
;   1563  1	GLOBAL ROUTINE REC%SWITCH =
;   1564  1	
;   1565  1	!++
;   1566  1	! FUNCTIONAL DESCRIPTION:
;   1567  1	!
;   1568  1	!	This routine will cause file(s) to be received by the remote
;   1569  1	!	KERMIT.  This routine contains the main loop for the sending of the
;   1570  1	!	data.
;   1571  1	!
;   1572  1	! CALLING SEQUENCE:
;   1573  1	!
;   1574  1	!	REC%SWITCH();
;   1575  1	!
;   1576  1	! INPUT PARAMETERS:
;   1577  1	!
;   1578  1	!	None.
;   1579  1	!
;   1580  1	! IMPLICIT INPUTS:
;   1581  1	!
;   1582  1	!	FILE%DESC - Descriptor describing the file to be received by
;   1583  1	!		the remote KERMIT.
;   1584  1	!
;   1585  1	! OUTPUT PARAMETERS:
;   1586  1	!
;   1587  1	!	None.
;   1588  1	!
;   1589  1	! IMPLICIT OUTPUTS:
;   1590  1	!
;   1591  1	!	None.
;   1592  1	!
;   1593  1	! COMPLETION CODES:
;   1594  1	!
;   1595  1	!	True - File received correctly.
;   1596  1	!	FALSE - File transfer aborted.
;   1597  1	!
;   1598  1	! SIDE EFFECTS:
;   1599  1	!
;   1600  1	!	None.
;   1601  1	!
;   1602  1	!--
;   1603  1	
;   1604  2	    BEGIN
;   1605  2	
;   1606  2	    LOCAL
;   1607  2		INIT%STATE,				! State to start up DO%TRANSACTION in
;   1608  2		STATUS;					! Status returned by various routines
;   1609  2	
;   1610  2	    INIT%STATE = STATE%R;			! Initialize the state
;   1611  2	    MSG%NUMBER = 0;
;   1612  2	    INIT%XFR ();				! Initialize the per transfer info
;   1613  2	!
;   1614  2	! Determine if they said REC <file-spec>
;   1615  2	!	Send MSG%RCV%INIT and then receive the file
;   1616  2	!
;   1617  2	
;   1618  2	    IF .FILE%SIZE GTR 0
;   1619  2	    THEN
;   1620  3		BEGIN
;   1621  3		GEN%TYPE = MSG%RCV%INIT;		! Use receive-init message
;   1622  3		CH$MOVE (.FILE%SIZE, CH$PTR (FILE%NAME), CH$PTR (GEN%1DATA));
;   1623  3		GEN%1SIZE = .FILE%SIZE;			! Save the length
;   1624  3		INIT%STATE = STATE%SI;			! Start out with server init
;   1625  2		END;
;   1626  2	
;   1627  2	!
;   1628  2	! Now receive the file normally
;   1629  2	!
;   1630  2	    XFR%STATUS (%C'I', %C'R');			! Start of a file receive
;   1631  2	    STATUS = DO%TRANSACTION (.INIT%STATE);
;   1632  2	    XFR%STATUS (%C'T', %C'R');			! End of file receive
;   1633  2	    RETURN .STATUS;				! Return the result
;   1634  1	    END;					! End of REC%SWITCH


REC%SWITCH::
	PUSH	SP,AC16				; SP,AC16									1563
	MOVEI	AC16,6				; INIT%STATE,6									1610
	SETZM	U.53				; MSG%NUMBER									1611
	PUSHJ	SP,U.32				; SP,INIT%XFR									1612
	MOVE	AC3,FILE%SIZE			; AC3,FILE%SIZE									1618
	JUMPLE	AC3,L.5				; AC3,L.5
	MOVEI	AC1,122				; AC1,122									1621
	MOVEM	AC1,U.64			; AC1,GEN%TYPE
	MOVE	AC1,AC3				; AC1,AC3									1622
	MOVE	AC2,C.10			; AC2,[POINT 7,FILE%NAME-1,34]  <1,7>
	MOVE	AC4,AC3				; AC4,AC3
	MOVE	AC5,C.11			; AC5,[POINT 7,GEN%1DATA-1,34]  <1,7>
	EXTEND	AC1,C.9				; AC1,[MOVSLJ ]
	JFCL					;
	MOVEM	AC3,GEN%1SIZE			; AC3,GEN%1SIZE									1623
	MOVEI	AC16,15				; INIT%STATE,15									1624
L.5:	PUSH	SP,C.6				; SP,[111]									1630
	PUSH	SP,C.12				; SP,[122]
	PUSHJ	SP,XFR%STATUS			; SP,XFR%STATUS
	MOVEM	AC16,0(SP)			; INIT%STATE,0(SP)								1631
	PUSHJ	SP,U.1				; SP,DO%TRANSACTION
	MOVE	AC16,AC1			; STATUS,AC1
	PUSH	SP,C.5				; SP,[124]									1632
	PUSH	SP,C.12				; SP,[122]
	PUSHJ	SP,XFR%STATUS			; SP,XFR%STATUS
	ADJSP	SP,-4				; SP,-4										1633
	MOVE	AC1,AC16			; AC1,STATUS									1604
	POP	SP,AC16				; SP,AC16									1563
	POPJ	SP,				; SP,
C.9:	MOVSLJ					;
C.10:	POINT	7,FILE%NAME-1,34		; 7,FILE%NAME-1,34
C.11:	POINT	7,GEN%1DATA-1,34		; 7,GEN%1DATA-1,34
C.12:	EXP	122				; 122

; Routine Size:  33 words


;   1635  1	
;   1636  1	%SBTTL 'Server -- DO%GENERIC - Execute a generic command'
;   1637  1	
;   1638  1	GLOBAL ROUTINE DO%GENERIC (TYPE) =
;   1639  1	
;   1640  1	!++
;   1641  1	! FUNCTIONAL DESCRIPTION:
;   1642  1	!
;   1643  1	!	This routine will send a generic command to the remote Kermit.
;   1644  1	!	it will do all the processing required for the generic command
;   1645  1	!	that was executed.  It will return to the caller after the
;   1646  1	!	command has be executed.
;   1647  1	!
;   1648  1	! CALLING SEQUENCE:
;   1649  1	!
;   1650  1	!	STATUS = DO%GENERIC (Command-type);
;   1651  1	!
;   1652  1	! INPUT PARAMETERS:
;   1653  1	!
;   1654  1	!	Command-type -- Command type to be executed.
;   1655  1	!
;   1656  1	! IMPLICIT INPUTS:
;   1657  1	!
;   1658  1	!	None.
;   1659  1	!
;   1660  1	! OUTPUT PARAMETERS:
;   1661  1	!
;   1662  1	!	None.
;   1663  1	!
;   1664  1	! IMPLICIT OUTPUTS:
;   1665  1	!
;   1666  1	!	None.
;   1667  1	!
;   1668  1	! COMPLETION CODES:
;   1669  1	!
;   1670  1	!	None.
;   1671  1	!
;   1672  1	! SIDE EFFECTS:
;   1673  1	!
;   1674  1	!	None.
;   1675  1	!
;   1676  1	!--
;   1677  1	
;   1678  2	    BEGIN
;   1679  2	
;   1680  2	    LOCAL
;   1681  2		INIT%STATE;				! Initial state for FSM
;   1682  2	
;   1683  2	!
;   1684  2	! Set up the per transfer items
;   1685  2	!
;   1686  2	    INIT%XFR ();
;   1687  2	    NUM%RETRIES = 0;
;   1688  2	    MSG%NUMBER = 0;
;   1689  2	!
;   1690  2	! These are all generic commands
;   1691  2	!
;   1692  2	    GEN%TYPE = MSG%GENERIC;
;   1693  2	!
;   1694  2	! Assume we will not need server init
;   1695  2	!
;   1696  2	    INIT%STATE = STATE%SG;
;   1697  2	
;   1698  2	    CASE .TYPE FROM GC%MIN TO GC%MAX OF
;   1699  2		SET
;   1700  2	
;   1701  2		[GC%EXIT] :
;   1702  2		    GEN%SUBTYPE = MSG%GEN%EXIT;
;   1703  2	
;   1704  2		[GC%LOGOUT] :
;   1705  2		    GEN%SUBTYPE = MSG%GEN%LOGOUT;
;   1706  2	
;   1707  2		[GC%DIRECTORY] :
;   1708  3		    BEGIN
;   1709  3		    INIT%STATE = STATE%SI;		! We will need server-init
;   1710  3		    GEN%SUBTYPE = MSG%GEN%DIRECTORY;
;   1711  2		    END;
;   1712  2	
;   1713  2		[GC%DISK%USAGE] :
;   1714  3		    BEGIN
;   1715  3		    INIT%STATE = STATE%SI;		! We will need server-init
;   1716  3		    GEN%SUBTYPE = MSG%GEN%DISK%USAGE;
;   1717  2		    END;
;   1718  2	
;   1719  2		[GC%DELETE] :
;   1720  2		    GEN%SUBTYPE = MSG%GEN%DELETE;
;   1721  2	
;   1722  2		[GC%TYPE] :
;   1723  3		    BEGIN
;   1724  3		    INIT%STATE = STATE%SI;		! We will need server-init
;   1725  3		    GEN%SUBTYPE = MSG%GEN%TYPE;
;   1726  2		    END;
;   1727  2	
;   1728  2		[GC%HELP] :
;   1729  3		    BEGIN
;   1730  3		    INIT%STATE = STATE%SI;		! We will need server-init
;   1731  3		    GEN%SUBTYPE = MSG%GEN%HELP;
;   1732  2		    END;
;   1733  2	
;   1734  2		[GC%LGN] :
;   1735  2		    GEN%SUBTYPE = MSG%GEN%LOGIN;	! Login just gets ACK
;   1736  2	
;   1737  2		[GC%CONNECT] :
;   1738  2		    GEN%SUBTYPE = MSG%GEN%CONNECT;	! CWD just gets ACK
;   1739  2	
;   1740  2		[GC%RENAME] :
;   1741  2		    GEN%SUBTYPE = MSG%GEN%RENAME;	! Rename file just needs ACK
;   1742  2	
;   1743  2		[GC%COPY] :
;   1744  2		    GEN%SUBTYPE = MSG%GEN%COPY;		! Copy file just needs ACK
;   1745  2	
;   1746  2		[GC%WHO] :
;   1747  3		    BEGIN
;   1748  3		    INIT%STATE = STATE%SI;		! May get large response
;   1749  3		    GEN%SUBTYPE = MSG%GEN%WHO;
;   1750  2		    END;
;   1751  2	
;   1752  2		[GC%SEND%MSG] :
;   1753  2		    GEN%SUBTYPE = MSG%GEN%SEND;		! Just need an ACK
;   1754  2	
;   1755  2		[GC%STATUS] :
;   1756  3		    BEGIN
;   1757  3		    INIT%STATE = STATE%SI;		! May get large response
;   1758  3		    GEN%SUBTYPE = MSG%GEN%QUERY;
;   1759  2		    END;
;   1760  2	
;   1761  2		[GC%COMMAND] :
;   1762  3		    BEGIN
;   1763  3		    INIT%STATE = STATE%SI;		! Large response likely
;   1764  3		    GEN%TYPE = MSG%COMMAND;		! This is host command
;   1765  2		    END;
;   1766  2	
;   1767  2		[GC%KERMIT] :
;   1768  2		    GEN%TYPE = MSG%KERMIT;		! Perform Kermit command (short response)
;   1769  2	
;   1770  2		[GC%PROGRAM] :
;   1771  3		    BEGIN
;   1772  3		    INIT%STATE = STATE%SI;		! Assume large response
;   1773  3		    GEN%SUBTYPE = MSG%GEN%PROGRAM;	! Generic program command
;   1774  2		    END;
;   1775  2	
;   1776  2		[GC%JOURNAL] :
;   1777  2		    GEN%SUBTYPE = MSG%GEN%JOURNAL;	! Do journal function (short reply)
;   1778  2	
;   1779  2		[GC%VARIABLE] :
;   1780  2		    GEN%SUBTYPE = MSG%GEN%VARIABLE;	! Set or get a variable value
;   1781  2	
;   1782  2		[INRANGE, OUTRANGE] :
;   1783  3		    BEGIN
;   1784  3		    KRM%ERROR (KER%UNIMPLGEN);
;   1785  3		    RETURN STATE%A;
;   1786  2		    END;
;   1787  2		TES;
;   1788  2	
;   1789  2	    RETURN DO%TRANSACTION (.INIT%STATE);	! Go do the command
;   1790  1	    END;					! End of DO%GENERIC


DO%GENERIC::
	PUSH	SP,AC16				; SP,AC16									1638
	PUSHJ	SP,U.32				; SP,INIT%XFR									1686
	SETZM	U.52				; NUM%RETRIES									1687
	SETZM	U.53				; MSG%NUMBER									1688
	MOVEI	AC1,107				; AC1,107									1692
	MOVEM	AC1,U.64			; AC1,GEN%TYPE
	MOVEI	AC16,14				; INIT%STATE,14									1696
	MOVE	AC1,-2(SP)			; AC1,TYPE									1698
	SOJL	AC1,L.7				; AC1,L.7
	CAIGE	AC1,23				; AC1,23
	JRST	L.6(AC1)			; L.6(AC1)
	JRST	L.7				; L.7
L.6:	JRST	L.8				; L.8
	JRST	L.10				; L.10
	JRST	L.11				; L.11
	JRST	L.12				; L.12
	JRST	L.13				; L.13
	JRST	L.14				; L.14
	JRST	L.9				; L.9
	JRST	L.15				; L.15
	JRST	L.16				; L.16
	JRST	L.17				; L.17
	JRST	L.18				; L.18
	JRST	L.19				; L.19
	JRST	L.20				; L.20
	JRST	L.21				; L.21
	JRST	L.22				; L.22
	JRST	L.23				; L.23
	JRST	L.26				; L.26
	JRST	L.27				; L.27
	JRST	L.25				; L.25
L.7:	PUSH	SP,C.13				; SP,[232]									1784
	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
	ADJSP	SP,-1				; SP,-1										1785
	MOVEI	AC1,12				; AC1,12									1783
	JRST	L.30				; L.30
L.8:	MOVEI	AC1,106				; AC1,106									1702
	JRST	L.28				; L.28
L.9:	MOVEI	AC1,114				; AC1,114									1705
	JRST	L.28				; L.28
L.10:	MOVEI	AC16,15				; INIT%STATE,15									1709
	MOVEI	AC1,104				; AC1,104									1710
	JRST	L.28				; L.28
L.11:	MOVEI	AC16,15				; INIT%STATE,15									1715
	MOVEI	AC1,125				; AC1,125									1716
	JRST	L.28				; L.28
L.12:	MOVEI	AC1,105				; AC1,105									1720
	JRST	L.28				; L.28
L.13:	MOVEI	AC16,15				; INIT%STATE,15									1724
	MOVEI	AC1,124				; AC1,124									1725
	JRST	L.28				; L.28
L.14:	MOVEI	AC16,15				; INIT%STATE,15									1730
	MOVEI	AC1,110				; AC1,110									1731
	JRST	L.28				; L.28
L.15:	MOVEI	AC1,111				; AC1,111									1735
	JRST	L.28				; L.28
L.16:	MOVEI	AC1,103				; AC1,103									1738
	JRST	L.28				; L.28
L.17:	MOVEI	AC1,122				; AC1,122									1741
	JRST	L.28				; L.28
L.18:	MOVEI	AC1,113				; AC1,113									1744
	JRST	L.28				; L.28
L.19:	MOVEI	AC16,15				; INIT%STATE,15									1748
	MOVEI	AC1,127				; AC1,127									1749
	JRST	L.28				; L.28
L.20:	MOVEI	AC1,115				; AC1,115									1753
	JRST	L.28				; L.28
L.21:	MOVEI	AC16,15				; INIT%STATE,15									1757
	MOVEI	AC1,121				; AC1,121									1758
	JRST	L.28				; L.28
L.22:	MOVEI	AC16,15				; INIT%STATE,15									1763
	MOVEI	AC1,103				; AC1,103									1764
	JRST	L.24				; L.24
L.23:	MOVEI	AC1,113				; AC1,113									1768
L.24:	MOVEM	AC1,U.64			; AC1,GEN%TYPE
	JRST	L.29				; L.29										1698
L.25:	MOVEI	AC16,15				; INIT%STATE,15									1772
	MOVEI	AC1,120				; AC1,120									1773
	JRST	L.28				; L.28
L.26:	MOVEI	AC1,112				; AC1,112									1777
	JRST	L.28				; L.28
L.27:	MOVEI	AC1,126				; AC1,126									1780
L.28:	MOVEM	AC1,U.65			; AC1,GEN%SUBTYPE
L.29:	PUSH	SP,AC16				; SP,INIT%STATE									1789
	PUSHJ	SP,U.1				; SP,DO%TRANSACTION
	ADJSP	SP,-1				; SP,-1
L.30:	POP	SP,AC16				; SP,AC16									1638
	POPJ	SP,				; SP,
C.13:	EXP	232				; 232

; Routine Size:  89 words


;   1791  1	
;   1792  1	%SBTTL 'DO%TRANSACTION - Main loop for FSM'
;   1793  1	ROUTINE DO%TRANSACTION (INIT%STATE) =
;   1794  1	
;   1795  1	!++
;   1796  1	! FUNCTIONAL DESCRIPTION:
;   1797  1	!
;   1798  1	!	This is the main routine for performing a Kermit transaction.
;   1799  1	!	It is structured as a finite state machine with each state
;   1800  1	!	determining the next based upon the packet which is received.
;   1801  1	!	It is supplied with the initial state by the caller.
;   1802  1	!
;   1803  1	! CALLING SEQUENCE:
;   1804  1	!
;   1805  1	!	Status = DO%TRANSACTION(.INIT%STATE);
;   1806  1	!
;   1807  1	! INPUT PARAMETERS:
;   1808  1	!
;   1809  1	!	INIT%STATE - Initial state.
;   1810  1	!
;   1811  1	! IMPLICIT INPUTS:
;   1812  1	!
;   1813  1	!	None.
;   1814  1	!
;   1815  1	! OUTPUT PARAMETERS:
;   1816  1	!
;   1817  1	!	None.
;   1818  1	!
;   1819  1	! IMPLICIT OUTPUTS:
;   1820  1	!
;   1821  1	!	None.
;   1822  1	!
;   1823  1	! COMPLETION CODES:
;   1824  1	!
;   1825  1	!	None.
;   1826  1	!
;   1827  1	! SIDE EFFECTS:
;   1828  1	!
;   1829  1	!	None.
;   1830  1	!
;   1831  1	!--
;   1832  1	
;   1833  2	    BEGIN
;   1834  2	
;   1835  2	    LOCAL
;   1836  2		RETURN%VALUE;
;   1837  2	
;   1838  2	    NUM%RETRIES = 0;				! Initialize the number of retries
;   1839  2	    STATE = .INIT%STATE;			! Initialize the state
;   1840  2	
;   1841  2	    WHILE TRUE DO
;   1842  2	
;   1843  2		CASE .STATE FROM STATE%MIN TO STATE%MAX OF
;   1844  2		    SET
;   1845  2	!
;   1846  2	! Send states
;   1847  2	!
;   1848  2	
;   1849  2		    [STATE%ID] :
;   1850  2	!
;   1851  2	! Server while idle.  Set the timeout to twice the normal wait
;   1852  2	! and wait for something to show up
;   1853  2	!
;   1854  3			BEGIN
;   1855  3	
;   1856  3			LOCAL
;   1857  3			    SAVED%TIMEOUT;
;   1858  3	
;   1859  3			SAVED%TIMEOUT = .SEND%TIMEOUT;
;   1860  3	
;   1861  3			IF .SEND%TIMEOUT NEQ 0 THEN SEND%TIMEOUT = .SRV%TIMEOUT;
;   1862  3	
;   1863  3			STATE = REC%SERVER%IDLE ();
;   1864  3			SEND%TIMEOUT = .SAVED%TIMEOUT;
;   1865  2			END;
;   1866  2	
;   1867  2		    [STATE%II] :
;   1868  2	!
;   1869  2	! Here while server idle after having received a server-init packet
;   1870  2	!
;   1871  2			STATE = REC%SERVER%IDLE ();
;   1872  2	
;   1873  2		    [STATE%FI, STATE%LG] :
;   1874  2	!
;   1875  2	! Here when we are supposed to exit
;   1876  2	!
;   1877  2			RETURN KER%EXIT;
;   1878  2	
;   1879  2		    [STATE%SD] :
;   1880  2			STATE = SEND%DATA ();
;   1881  2	
;   1882  2		    [STATE%SF] :
;   1883  2			STATE = SEND%FILE ();
;   1884  2	
;   1885  2		    [STATE%SZ] :
;   1886  2			STATE = SEND%EOF ();
;   1887  2	
;   1888  2		    [STATE%S] :
;   1889  2			STATE = SEND%INIT ();
;   1890  2	
;   1891  2		    [STATE%OF] :
;   1892  2			STATE = SEND%OPEN%FILE ();
;   1893  2	
;   1894  2		    [STATE%SI] :
;   1895  2			STATE = SEND%SERVER%INIT ();
;   1896  2	
;   1897  2		    [STATE%SG] :
;   1898  2			STATE = SEND%GENCMD ();
;   1899  2	
;   1900  2		    [STATE%SB] :
;   1901  2			STATE = SEND%BREAK ();
;   1902  2	!
;   1903  2	! Receiving of the data and the end of file message.
;   1904  2	!
;   1905  2	
;   1906  2		    [STATE%RD] :
;   1907  2			STATE = REC%DATA ();
;   1908  2	!
;   1909  2	! Receiving the FILE information of the break to end the transfer of
;   1910  2	! one or more files
;   1911  2	!
;   1912  2	
;   1913  2		    [STATE%RF] :
;   1914  2			STATE = REC%FILE ();
;   1915  2	!
;   1916  2	! Initialization for the receiving of a file
;   1917  2	!
;   1918  2	
;   1919  2		    [STATE%R] :
;   1920  2			STATE = REC%INIT ();
;   1921  2	!
;   1922  2	! Here if we have completed the receiving of the file
;   1923  2	!
;   1924  2	
;   1925  2		    [STATE%C] :
;   1926  3			BEGIN
;   1927  3			RETURN%VALUE = TRUE;
;   1928  3			EXITLOOP;
;   1929  2			END;
;   1930  2	!
;   1931  2	! Here if we aborted the transfer or we have gotten into some random
;   1932  2	! state (internal KERMSG problem).
;   1933  2	!
;   1934  2	
;   1935  2		    [STATE%A, STATE%EX, STATE%ER, INRANGE, OUTRANGE] :
;   1936  3			BEGIN
;   1937  3			RETURN%VALUE = FALSE;
;   1938  3	
;   1939  3			IF .STATE EQL STATE%EX THEN RETURN%VALUE = KER%ABORTED;
;   1940  3	
;   1941  3			!
;   1942  3			! Determine if the file is still open and if so close it
;   1943  3			!
;   1944  3	
;   1945  3			IF .FILE%OPEN%FLAG
;   1946  3			THEN
;   1947  4			    BEGIN
;   1948  4			    FILE%OPEN%FLAG = FALSE;
;   1949  4	
;   1950  4			    IF ( NOT .CONNECT%FLAG) AND .TY%FIL
;   1951  4			    THEN
;   1952  5				BEGIN
;   1953  5				TT%TEXT (UPLIT (%ASCIZ' [Aborted]'));
;   1954  5				TT%CRLF ();
;   1955  4				END;
;   1956  4	
;   1957  5			    FILE%CLOSE (.ABT%FLAG AND (.STATE EQL STATE%A OR .STATE EQL STATE%EX OR .STATE
;   1958  4				EQL STATE%ER));
;   1959  4			    XFR%STATUS (%C'F', %C'A');
;   1960  3			    END;
;   1961  3	
;   1962  3	!
;   1963  3	! Give error if aborted due to too many retries
;   1964  3	!
;   1965  3	
;   1966  3			IF .STATE EQL STATE%ER THEN KRM%ERROR (KER%RETRIES);
;   1967  3	
;   1968  3			EXITLOOP;
;   1969  2			END;
;   1970  2		    TES;
;   1971  2	
;   1972  2	!
;   1973  2	! End the stats and return to the caller
;   1974  2	!
;   1975  2	    END%STATS ();
;   1976  2	!
;   1977  2	    RETURN .RETURN%VALUE;
;   1978  1	    END;					! End of DO%TRANSACTION


P.AAA:	BYTE	(7)" ","[","A","b","o"		;  [Abo
	BYTE	(7)"r","t","e","d","]"		; rted]
	BYTE	(7)000,000,000,000,000


; DO%TRANSACTION
U.1:	PUSH	SP,AC14				; SP,AC14									1793
	PUSH	SP,AC16				; SP,AC16
	SETZM	U.52				; NUM%RETRIES									1838
	MOVE	AC1,-3(SP)			; AC1,INIT%STATE								1839
L.31:	MOVEM	AC1,U.49			; AC1,STATE
L.32:	MOVE	AC1,U.49			; AC1,STATE									1843
	MOVE	AC2,AC1				; AC2,AC1
	SOJL	AC2,L.34			; AC2,L.34
	CAIGE	AC2,24				; AC2,24
	JRST	L.33(AC2)			; L.33(AC2)
	JRST	L.34				; L.34
L.33:	JRST	L.44				; L.44
	JRST	L.42				; L.42
	JRST	L.41				; L.41
	JRST	L.43				; L.43
	JRST	L.48				; L.48
	JRST	L.51				; L.51
	JRST	L.50				; L.50
	JRST	L.49				; L.49
	JRST	L.52				; L.52
	JRST	L.34				; L.34
	JRST	L.34				; L.34
	JRST	L.47				; L.47
	JRST	L.46				; L.46
	JRST	L.37				; L.37
	JRST	L.39				; L.39
	JRST	L.40				; L.40
	JRST	L.40				; L.40
	JRST	L.45				; L.45
	JRST	L.34				; L.34
	JRST	L.34				; L.34
L.34:	SETZ	AC14,				; RETURN%VALUE,									1937
	CAIN	AC1,23				; AC1,23									1939
	MOVEI	AC14,312			; RETURN%VALUE,312
	MOVEI	AC1,1				; AC1,1										1945
	TDNN	AC1,U.59			; AC1,FILE%OPEN%FLAG
	JRST	L.36				; L.36
	SETZM	U.59				; FILE%OPEN%FLAG								1948
	MOVEI	AC1,1				; AC1,1										1950
	TDNE	AC1,CONNECT%FLAG		; AC1,CONNECT%FLAG
	JRST	L.35				; L.35
	MOVEI	AC1,1				; AC1,1
	TDNN	AC1,TY%FIL			; AC1,TY%FIL
	JRST	L.35				; L.35
	PUSH	SP,C.14				; SP,[0,,P.AAA]									1953
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	ADJSP	SP,-1				; SP,-1
	PUSHJ	SP,TT%CRLF			; SP,TT%CRLF									1954
L.35:	MOVE	AC3,U.49			; AC3,STATE									1957
	SETZ	AC1,				; AC1,
	CAIN	AC3,12				; AC3,12
	MOVEI	AC1,1				; AC1,1
	SETZ	AC2,				; AC2,
	CAIN	AC3,23				; AC3,23
	MOVEI	AC2,1				; AC2,1
	IOR	AC2,AC1				; AC2,AC1
	SETZ	AC1,				; AC1,										1958
	CAIN	AC3,24				; AC3,24
	MOVEI	AC1,1				; AC1,1
	IOR	AC1,AC2				; AC1,AC2									1957
	AND	AC1,ABT%FLAG			; AC1,ABT%FLAG
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,FILE%CLOSE			; SP,FILE%CLOSE
	ADJSP	SP,-1				; SP,-1
	PUSH	SP,C.15				; SP,[106]									1959
	PUSH	SP,C.16				; SP,[101]
	PUSHJ	SP,XFR%STATUS			; SP,XFR%STATUS
	ADJSP	SP,-2				; SP,-2
L.36:	MOVEI	AC1,24				; AC1,24									1966
	CAME	AC1,U.49			; AC1,STATE
	JRST	L.53				; L.53
	PUSH	SP,C.17				; SP,[212]
	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
	ADJSP	SP,-1				; SP,-1
	JRST	L.53				; L.53
L.37:	MOVE	AC1,SEND%TIMEOUT		; AC1,SEND%TIMEOUT								1859
	MOVE	AC16,AC1			; SAVED%TIMEOUT,AC1
	JUMPE	AC1,L.38			; AC1,L.38									1861
	MOVE	AC1,SRV%TIMEOUT			; AC1,SRV%TIMEOUT
	MOVEM	AC1,SEND%TIMEOUT		; AC1,SEND%TIMEOUT
L.38:	PUSHJ	SP,U.10				; SP,REC%SERVER%IDLE								1863
	MOVEM	AC1,U.49			; AC1,STATE
	MOVEM	AC16,SEND%TIMEOUT		; SAVED%TIMEOUT,SEND%TIMEOUT							1864
	JRST	L.32				; L.32										1843
L.39:	PUSHJ	SP,U.10				; SP,REC%SERVER%IDLE								1871
	JRST	L.31				; L.31
L.40:	MOVEI	AC1,223				; AC1,223									1877
	JRST	L.54				; L.54
L.41:	PUSHJ	SP,U.3				; SP,SEND%DATA									1880
	JRST	L.31				; L.31
L.42:	PUSHJ	SP,U.4				; SP,SEND%FILE									1883
	JRST	L.31				; L.31
L.43:	PUSHJ	SP,U.7				; SP,SEND%EOF									1886
	JRST	L.31				; L.31
L.44:	PUSHJ	SP,U.8				; SP,SEND%INIT									1889
	JRST	L.31				; L.31
L.45:	PUSHJ	SP,U.5				; SP,SEND%OPEN%FILE								1892
	JRST	L.31				; L.31
L.46:	PUSHJ	SP,U.2				; SP,SEND%SERVER%INIT								1895
	JRST	L.31				; L.31
L.47:	PUSHJ	SP,U.6				; SP,SEND%GENCMD								1898
	JRST	L.31				; L.31
L.48:	PUSHJ	SP,U.9				; SP,SEND%BREAK									1901
	JRST	L.31				; L.31
L.49:	PUSHJ	SP,U.13				; SP,REC%DATA									1907
	JRST	L.31				; L.31
L.50:	PUSHJ	SP,U.12				; SP,REC%FILE									1914
	JRST	L.31				; L.31
L.51:	PUSHJ	SP,U.11				; SP,REC%INIT									1920
	JRST	L.31				; L.31
L.52:	MOVEI	AC14,1				; RETURN%VALUE,1								1927
L.53:	PUSHJ	SP,U.18				; SP,END%STATS									1975
	MOVE	AC1,AC14			; AC1,RETURN%VALUE								1833
L.54:	POP	SP,AC16				; SP,AC16									1793
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,
C.14:	XWD	0,P.AAA				; 0,P.AAA
C.15:	EXP	106				; 106
C.16:	EXP	101				; 101
C.17:	EXP	212				; 212

; Routine Size:  120 words


;   1979  1	%SBTTL 'REC%SERVER%IDLE - Idle server state'
;   1980  1	ROUTINE REC%SERVER%IDLE =
;   1981  1	
;   1982  1	!++
;   1983  1	! FUNCTIONAL DESCRIPTION:
;   1984  1	!
;   1985  1	! This routine is called from DO%TRANSACTION when is the server idle
;   1986  1	! state.  It will receive a message and properly dispatch to the new
;   1987  1	! state.
;   1988  1	!
;   1989  1	! CALLING SEQUENCE:
;   1990  1	!
;   1991  1	!	STATE = REC%SERVER%IDLE ();
;   1992  1	!
;   1993  1	! INPUT PARAMETERS:
;   1994  1	!
;   1995  1	!	None.
;   1996  1	!
;   1997  1	! IMPLICIT INPUTS:
;   1998  1	!
;   1999  1	!	Almost everything.
;   2000  1	!
;   2001  1	! OUPTUT PARAMETERS:
;   2002  1	!
;   2003  1	!	Routine value is new state for FSM
;   2004  1	!
;   2005  1	! IMPLICIT OUTPUTS:
;   2006  1	!
;   2007  1	!	None.
;   2008  1	!
;   2009  1	! COMPLETION CODES:
;   2010  1	!
;   2011  1	!	None.
;   2012  1	!
;   2013  1	! SIDE EFFECTS:
;   2014  1	!
;   2015  1	!	None.
;   2016  1	!
;   2017  1	!--
;   2018  1	
;   2019  2	    BEGIN
;   2020  2	
;   2021  2	    LOCAL
;   2022  2		STATUS;
;   2023  2	
;   2024  2	    STATUS = REC%PACKET ();
;   2025  2	!
;   2026  2	! Now determine what to do by the type of message we have receive.
;   2027  2	!
;   2028  2	
;   2029  2	    IF .STATUS EQL KER%ABORTED THEN RETURN STATE%EX;
;   2030  2	
;   2031  2	    IF .STATUS
;   2032  2	    THEN
;   2033  3		BEGIN
;   2034  3	
;   2035  3		SELECTONE .REC%TYPE OF
;   2036  3		    SET
;   2037  3		    !
;   2038  3		    ! Server initialization message received. ACK the
;   2039  3		    ! message and continue.
;   2040  3		    !
;   2041  3	
;   2042  3		    [MSG%SER%INIT] :
;   2043  4			BEGIN
;   2044  4	
;   2045  5			IF (STATUS = PRS%SEND%INIT ())
;   2046  4			THEN
;   2047  5			    BEGIN
;   2048  5			    SET%SEND%INIT ();
;   2049  5	
;   2050  6			    IF (STATUS = SEND%PACKET (MSG%ACK, P%SI%LENGTH, .REC%SEQ))
;   2051  5			    THEN
;   2052  6				BEGIN
;   2053  6				SND%PKT%SIZE = -.SEND%PKT%SIZE;
;   2054  6				SND%TIMEOUT = -.SEND%TIMEOUT;
;   2055  6				SND%NPAD = -.SEND%NPAD;
;   2056  6				SND%PADCHAR = -.SEND%PADCHAR;
;   2057  6				SND%EOL = -.SEND%EOL;
;   2058  6				SND%QUOTE%CHR = -.SEND%QUOTE%CHR;
;   2059  6				RCV%8QUOTE%CHR = .SEND%8QUOTE%CHR;
;   2060  6				CHKTYPE = .INI%CHK%TYPE;
;   2061  6				SET%REPT%CHR = .REPT%CHR;
;   2062  6				RETURN STATE%II;	! Now idle after INIT
;   2063  5				END;
;   2064  5	
;   2065  4			    END;
;   2066  4	
;   2067  4			KRM%ERROR (KER%PROTOERR);
;   2068  4			RETURN STATE%A;
;   2069  3			END;
;   2070  3		    !
;   2071  3		    ! Send init message received.  We must ACK the message and
;   2072  3		    ! then attempt to receive a file from the remote.
;   2073  3		    !
;   2074  3	
;   2075  3		    [MSG%SND%INIT] :
;   2076  4			BEGIN
;   2077  4			MSG%NUMBER = (.REC%SEQ + 1) AND %O'77';
;   2078  4	
;   2079  5			IF (STATUS = PRS%SEND%INIT ())
;   2080  4			THEN
;   2081  5			    BEGIN
;   2082  5			    SET%SEND%INIT ();
;   2083  5			    !
;   2084  5			    ! ACK the message then receive everything.
;   2085  5			    !
;   2086  5	
;   2087  5			    IF SEND%PACKET (MSG%ACK, P%SI%LENGTH, .REC%SEQ)
;   2088  5			    THEN
;   2089  6				BEGIN
;   2090  6				BLK%CHK%TYPE = .INI%CHK%TYPE;	! Switch to desired form of block check
;   2091  6				XFR%STATUS (%C'I', %C'R');	! Start of file receive
;   2092  6				RETURN STATE%RF;
;   2093  5				END;
;   2094  5	
;   2095  4			    END;
;   2096  4	
;   2097  4			KRM%ERROR (KER%PROTOERR);
;   2098  4			RETURN STATE%A;
;   2099  3			END;
;   2100  3		    !
;   2101  3		    ! Here if we receive a receive init message.
;   2102  3		    ! We will be sending a file to the other end.
;   2103  3		    !
;   2104  3	
;   2105  3		    [MSG%RCV%INIT] :
;   2106  4			BEGIN
;   2107  4			!
;   2108  4			! Move the file specification if we received one
;   2109  4			!
;   2110  4			SET%STRING (CH$PTR (FILE%NAME), MAX%FILE%NAME, TRUE);
;   2111  4			BFR%EMPTY ();
;   2112  4			FILE%SIZE = SET%STRING (0, 0, FALSE);
;   2113  4			CH$WCHAR (CHR%NUL, CH$PTR (FILE%NAME, .FILE%SIZE));
;   2114  4	
;   2115  4			IF .FILE%SIZE GTR 0
;   2116  4			THEN
;   2117  5			    BEGIN
;   2118  5			    XFR%STATUS (%C'I', %C'S');	! Start of a file send
;   2119  5			    RETURN STATE%S;
;   2120  4			    END;
;   2121  4	
;   2122  4			KRM%ERROR (KER%PROTOERR);
;   2123  4			RETURN STATE%A;
;   2124  3			END;
;   2125  3	!
;   2126  3	! Generic KERMIT commands
;   2127  3	!
;   2128  3	
;   2129  3		    [MSG%GENERIC] :
;   2130  3			RETURN SERVER%GENERIC ();
;   2131  3	!
;   2132  3	! Host command
;   2133  3	!
;   2134  3	
;   2135  3		    [MSG%COMMAND] :
;   2136  3			RETURN HOST%COMMAND ();
;   2137  3	!
;   2138  3	! Kermit command
;   2139  3	!
;   2140  3	
;   2141  3		    [MSG%KERMIT] :
;   2142  3			RETURN KERMIT%COMMAND ();
;   2143  3	!
;   2144  3	! Unimplimented server routines
;   2145  3	!
;   2146  3	
;   2147  3		    [OTHERWISE] :
;   2148  4			BEGIN
;   2149  4			KRM%ERROR (KER%UNISRV);
;   2150  4			RETURN STATE%A;
;   2151  3			END;
;   2152  3		    TES;
;   2153  3	
;   2154  2		END;
;   2155  2	
;   2156  2	!
;   2157  2	! If we get here, we must have gotten something random.  Therefore,
;   2158  2	! just send a NAK and remain in the current state (unless we have done this
;   2159  2	! too many times).
;   2160  2	!
;   2161  2	    NUM%RETRIES = .NUM%RETRIES + 1;
;   2162  2	
;   2163  2	    IF .NUM%RETRIES GTR .SI%RETRIES THEN RETURN STATE%A;
;   2164  2	
;   2165  2	    IF SEND%PACKET (MSG%NAK, 0, 0) THEN RETURN .STATE ELSE RETURN STATE%EX;
;   2166  2	
;   2167  1	    END;					! End of REC%SERVER%IDLE


; REC%SERVER%IDLE
U.10:	PUSH	SP,AC14				; SP,AC14									1980
	PUSH	SP,AC16				; SP,AC16
	PUSHJ	SP,U.26				; SP,REC%PACKET									2024
	MOVE	AC14,AC1			; STATUS,AC1
	CAIN	AC14,312			; STATUS,312									2029
	JRST	L.67				; L.67
	TRNN	AC14,1				; STATUS,1									2031
	JRST	L.64				; L.64
	MOVE	AC16,U.56			; AC16,REC%TYPE									2035
	CAIE	AC16,111			; AC16,111									2042
	JRST	L.55				; L.55
	PUSHJ	SP,U.21				; SP,PRS%SEND%INIT								2045
	MOVE	AC14,AC1			; STATUS,AC1
	TRNN	AC14,1				; STATUS,1
	JRST	L.56				; L.56
	PUSHJ	SP,U.20				; SP,SET%SEND%INIT								2048
	PUSH	SP,C.20				; SP,[131]									2050
	PUSH	SP,C.21				; SP,[11]
	PUSH	SP,U.54				; SP,REC%SEQ
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	MOVE	AC14,AC1			; STATUS,AC1
	ADJSP	SP,-3				; SP,-3
	TRNN	AC14,1				; STATUS,1
	JRST	L.56				; L.56
	MOVE	AC1,U.39			; AC1,SEND%PKT%SIZE								2053
	MOVNM	AC1,SND%PKT%SIZE		; AC1,SND%PKT%SIZE
	MOVE	AC1,SEND%TIMEOUT		; AC1,SEND%TIMEOUT								2054
	MOVNM	AC1,SND%TIMEOUT			; AC1,SND%TIMEOUT
	MOVE	AC1,U.40			; AC1,SEND%NPAD									2055
	MOVNM	AC1,SND%NPAD			; AC1,SND%NPAD
	MOVE	AC1,U.41			; AC1,SEND%PADCHAR								2056
	MOVNM	AC1,SND%PADCHAR			; AC1,SND%PADCHAR
	MOVE	AC1,U.42			; AC1,SEND%EOL									2057
	MOVNM	AC1,SND%EOL			; AC1,SND%EOL
	MOVE	AC1,U.43			; AC1,SEND%QUOTE%CHR								2058
	MOVNM	AC1,SND%QUOTE%CHR		; AC1,SND%QUOTE%CHR
	MOVE	AC1,U.44			; AC1,SEND%8QUOTE%CHR								2059
	MOVEM	AC1,RCV%8QUOTE%CHR		; AC1,RCV%8QUOTE%CHR
	MOVE	AC1,U.45			; AC1,INI%CHK%TYPE								2060
	MOVEM	AC1,CHKTYPE			; AC1,CHKTYPE
	MOVE	AC1,U.38			; AC1,REPT%CHR									2061
	MOVEM	AC1,SET%REPT%CHR		; AC1,SET%REPT%CHR
	MOVEI	AC1,17				; AC1,17									2052
	JRST	L.68				; L.68
L.55:	CAIE	AC16,123			; AC16,123									2075
	JRST	L.57				; L.57
	MOVE	AC1,U.54			; AC1,REC%SEQ									2077
	ADDI	AC1,1				; AC1,1
	LDB	AC2,C.18			; AC2,[POINT 6,AC1,35]  <0,6>
	MOVEM	AC2,U.53			; AC2,MSG%NUMBER
	PUSHJ	SP,U.21				; SP,PRS%SEND%INIT								2079
	MOVE	AC14,AC1			; STATUS,AC1
	TRNN	AC14,1				; STATUS,1
	JRST	L.56				; L.56
	PUSHJ	SP,U.20				; SP,SET%SEND%INIT								2082
	PUSH	SP,C.20				; SP,[131]									2087
	PUSH	SP,C.21				; SP,[11]
	PUSH	SP,U.54				; SP,REC%SEQ
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	ADJSP	SP,-3				; SP,-3
	TRNN	AC1,1				; AC1,1
	JRST	L.56				; L.56
	MOVE	AC1,U.45			; AC1,INI%CHK%TYPE								2090
	MOVEM	AC1,U.46			; AC1,BLK%CHK%TYPE
	PUSH	SP,C.6				; SP,[111]									2091
	PUSH	SP,C.12				; SP,[122]
	PUSHJ	SP,XFR%STATUS			; SP,XFR%STATUS
	ADJSP	SP,-2				; SP,-2										2092
	MOVEI	AC1,7				; AC1,7										2089
	JRST	L.68				; L.68
L.56:	PUSH	SP,C.22				; SP,[252]									2097
	JRST	L.63				; L.63
L.57:	CAIE	AC16,122			; AC16,122									2105
	JRST	L.59				; L.59
	PUSH	SP,C.10				; SP,[POINT 7,FILE%NAME-1,34]  <1,7>						2110
	PUSH	SP,C.23				; SP,[204]
	PUSH	SP,C.2				; SP,[1]
	PUSHJ	SP,U.30				; SP,SET%STRING
	PUSHJ	SP,U.28				; SP,BFR%EMPTY									2111
	SETZM	-2(SP)				; -2(SP)									2112
	SETZM	-1(SP)				; -1(SP)
	SETZM	0(SP)				; 0(SP)
	PUSHJ	SP,U.30				; SP,SET%STRING
	MOVEM	AC1,FILE%SIZE			; AC1,FILE%SIZE
	SETZ	AC3,				; AC3,										2113
	MOVE	AC2,FILE%SIZE			; AC2,FILE%SIZE
	MOVE	AC4,C.19			; AC4,[POINT 7,FILE%NAME,-1]  <36,7>
	MOVE	AC1,AC2				; AC1,AC2
	ADJBP	AC1,AC4				; AC1,AC4
	IDPB	AC3,AC1				; AC3,AC1
	JUMPLE	AC2,L.58			; AC2,L.58									2115
	PUSH	SP,C.6				; SP,[111]									2118
	PUSH	SP,C.8				; SP,[123]
	PUSHJ	SP,XFR%STATUS			; SP,XFR%STATUS
	ADJSP	SP,-5				; SP,-5										2119
	MOVEI	AC1,1				; AC1,1										2117
	JRST	L.68				; L.68
L.58:	PUSH	SP,C.22				; SP,[252]									2122
	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
	ADJSP	SP,-4				; SP,-4										2106
	JRST	L.65				; L.65
L.59:	CAIE	AC16,107			; AC16,107									2129
	JRST	L.60				; L.60
	PUSHJ	SP,U.14				; SP,SERVER%GENERIC								2130
	JRST	L.68				; L.68										2035
L.60:	CAIE	AC16,103			; AC16,103									2135
	JRST	L.61				; L.61
	PUSHJ	SP,U.15				; SP,HOST%COMMAND								2136
	JRST	L.68				; L.68										2035
L.61:	CAIE	AC16,113			; AC16,113									2141
	JRST	L.62				; L.62
	PUSHJ	SP,U.16				; SP,KERMIT%COMMAND								2142
	JRST	L.68				; L.68										2035
L.62:	PUSH	SP,C.24				; SP,[242]									2149
L.63:	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
	ADJSP	SP,-1				; SP,-1										2148
	JRST	L.65				; L.65
L.64:	AOS	AC1,U.52			; AC1,NUM%RETRIES								2163
	CAMG	AC1,SI%RETRIES			; AC1,SI%RETRIES
	JRST	L.66				; L.66
L.65:	MOVEI	AC1,12				; AC1,12
	JRST	L.68				; L.68
L.66:	PUSH	SP,C.25				; SP,[116]									2165
	PUSH	SP,C.26				; SP,[0]
	PUSH	SP,C.26				; SP,[0]
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	ADJSP	SP,-3				; SP,-3
	TRNE	AC1,1				; AC1,1
	SKIPA	AC1,U.49			; AC1,STATE
L.67:	MOVEI	AC1,23				; AC1,23
L.68:	POP	SP,AC16				; SP,AC16									1980
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,
C.18:	POINT	6,AC1,35			; 6,AC1,35
C.19:	POINT	7,FILE%NAME,-1			; 7,FILE%NAME,-1
C.20:	EXP	131				; 131
C.21:	EXP	11				; 11
C.22:	EXP	252				; 252
C.23:	EXP	204				; 204
C.24:	EXP	242				; 242
C.25:	EXP	116				; 116
C.26:	EXP	0				; 0

; Routine Size:  142 words


;   2168  1	%SBTTL 'SEND%SERVER%INIT'
;   2169  1	ROUTINE SEND%SERVER%INIT =
;   2170  1	
;   2171  1	!++
;   2172  1	! FUNCTIONAL DESCRIPTION:
;   2173  1	!
;   2174  1	!	This routine will send a server initialization message to the
;   2175  1	!	remote KERMIT.
;   2176  1	!
;   2177  1	! CALLING SEQUENCE:
;   2178  1	!
;   2179  1	!	STATE = SEND%SERVER%INIT();
;   2180  1	!
;   2181  1	! INPUT PARAMETERS:
;   2182  1	!
;   2183  1	!	None.
;   2184  1	!
;   2185  1	! IMPLICIT INPUTS:
;   2186  1	!
;   2187  1	!	RECV%xxx - desired receive parameters
;   2188  1	!
;   2189  1	! OUTPUT PARAMETERS:
;   2190  1	!
;   2191  1	!	New state to change the finite state machine to.
;   2192  1	!
;   2193  1	! IMPLICIT OUTPUTS:
;   2194  1	!
;   2195  1	!	SEND%xxx - Other Kermit's desired parameters
;   2196  1	!
;   2197  1	! COMPLETION CODES:
;   2198  1	!
;   2199  1	!	None.
;   2200  1	!
;   2201  1	! SIDE EFFECTS:
;   2202  1	!
;   2203  1	!	None.
;   2204  1	!
;   2205  1	!--
;   2206  1	
;   2207  2	    BEGIN
;   2208  2	
;   2209  2	    LOCAL
;   2210  2		OLD%OUTPUT,				! Saved terminal output routine
;   2211  2		STATUS;					! Status returned by various routines
;   2212  2	
;   2213  2	![026] Local routine to ignore error message output
;   2214  2	    ROUTINE IGNORE%ERROR (ADDRESS, LENGTH) =
;   2215  3		BEGIN
;   2216  3		RETURN TRUE;
;   2217  2		END;


; IGNORE%ERROR
U.74:	MOVEI	AC1,1				; AC1,1										2215
	POPJ	SP,				; SP,										2214

; Routine Size:  2 words


;   2218  2	    SET%SEND%INIT ();
;   2219  2	![026] If too many tries, just give up.  Maybe the other Kermit doesn't
;   2220  2	![026] know what to do with this packet.
;   2221  2	
;   2222  2	    IF .NUM%RETRIES GTR .SI%RETRIES THEN RETURN STATE%ER;
;   2223  2	
;   2224  2	![026]
;   2225  2	![026] Count the number of times we try this
;   2226  2	![026]
;   2227  2	    NUM%RETRIES = .NUM%RETRIES + 1;
;   2228  2	
;   2229  2	    IF NOT SEND%PACKET (MSG%SER%INIT, P%SI%LENGTH, .MSG%NUMBER) THEN RETURN STATE%A;
;   2230  2	
;   2231  2	![026]
;   2232  2	![026] Determine if we received a packet it good condition.  If we timed out
;   2233  2	![026] just try again.  If we get an error packet back, ignore it and
;   2234  2	![026] just continue.  The other Kermit must not support this packet.
;   2235  2	![026]
;   2236  2	    OLD%OUTPUT = TT%SET%OUTPUT (IGNORE%ERROR);
;   2237  2	    STATUS = REC%PACKET ();
;   2238  2	    TT%OUTPUT ();
;   2239  2	    TT%SET%OUTPUT (.OLD%OUTPUT);
;   2240  2	
;   2241  2	    IF .STATUS EQL KER%ERRMSG THEN RETURN STATE%SG;
;   2242  2	
;   2243  2	    IF NOT .STATUS
;   2244  2	    THEN
;   2245  2	
;   2246  4		IF NOT ((.STATUS EQL KER%ZEROLENMSG) OR (.STATUS EQL KER%TIMEOUT) OR (.STATUS EQL
;   2247  3		    KER%CHKSUMERR))
;   2248  2		THEN
;   2249  2		    RETURN STATE%EX
;   2250  2		ELSE
;   2251  2		    RETURN .STATE;
;   2252  2	
;   2253  2	!
;   2254  2	! Determine if the packet is good.
;   2255  2	!
;   2256  2	
;   2257  2	    IF .REC%TYPE EQL MSG%ACK AND .REC%SEQ EQL .MSG%NUMBER
;   2258  2	    THEN
;   2259  3		BEGIN
;   2260  3	!
;   2261  3	! Here if we have an ACK for the initialization message that was just sent
;   2262  3	! to the remote KERMIT.
;   2263  3	!
;   2264  3	
;   2265  3		IF NOT (STATUS = PRS%SEND%INIT ()) THEN RETURN STATE%A;
;   2266  3	
;   2267  3		NUM%RETRIES = 0;
;   2268  3		INIT%PKT%SENT = TRUE;			! We have exchanged init's
;   2269  3		RETURN STATE%SG;
;   2270  2		END;
;   2271  2	
;   2272  2	!
;   2273  2	! If we haven't returned yet, we must have gotten an invalid response.
;   2274  2	! Just stay in the same state so we try again
;   2275  2	!
;   2276  2	    RETURN .STATE;
;   2277  1	    END;


; SEND%SERVER%INIT
U.2:	PUSH	SP,AC14				; SP,AC14									2169
	PUSH	SP,AC16				; SP,AC16
	PUSHJ	SP,U.20				; SP,SET%SEND%INIT								2218
	MOVE	AC1,U.52			; AC1,NUM%RETRIES								2222
	CAMG	AC1,SI%RETRIES			; AC1,SI%RETRIES
	JRST	L.69				; L.69
	MOVEI	AC1,24				; AC1,24
	JRST	L.77				; L.77
L.69:	AOS	U.52				; NUM%RETRIES									2227
	PUSH	SP,C.6				; SP,[111]									2229
	PUSH	SP,C.21				; SP,[11]
	PUSH	SP,U.53				; SP,MSG%NUMBER
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	ADJSP	SP,-3				; SP,-3
	TRNN	AC1,1				; AC1,1
	JRST	L.73				; L.73
	PUSH	SP,C.27				; SP,[0,,IGNORE%ERROR]								2236
	PUSHJ	SP,TT%SET%OUTPUT		; SP,TT%SET%OUTPUT
	MOVE	AC14,AC1			; OLD%OUTPUT,AC1
	PUSHJ	SP,U.26				; SP,REC%PACKET									2237
	MOVE	AC16,AC1			; STATUS,AC1
	PUSHJ	SP,TT%OUTPUT			; SP,TT%OUTPUT									2238
	MOVEM	AC14,0(SP)			; OLD%OUTPUT,0(SP)								2239
	PUSHJ	SP,TT%SET%OUTPUT		; SP,TT%SET%OUTPUT
	CAIN	AC16,162			; STATUS,162									2241
	JRST	L.75				; L.75
	TRNE	AC16,1				; STATUS,1									2243
	JRST	L.72				; L.72
	CAIE	AC16,262			; STATUS,262									2246
	CAIN	AC16,300			; STATUS,300
	JRST	L.70				; L.70
	CAIN	AC16,172			; STATUS,172
	JRST	L.70				; L.70
	MOVEI	AC1,23				; AC1,23									2251
	JRST	L.71				; L.71
L.70:	MOVE	AC1,U.49			; AC1,STATE
L.71:	ADJSP	SP,-1				; SP,-1
	JRST	L.77				; L.77										2246
L.72:	MOVEI	AC1,131				; AC1,131									2257
	CAME	AC1,U.56			; AC1,REC%TYPE
	JRST	L.76				; L.76
	MOVE	AC1,U.54			; AC1,REC%SEQ
	CAME	AC1,U.53			; AC1,MSG%NUMBER
	JRST	L.76				; L.76
	PUSHJ	SP,U.21				; SP,PRS%SEND%INIT								2265
	MOVE	AC16,AC1			; STATUS,AC1
	TRNE	AC16,1				; STATUS,1
	JRST	L.74				; L.74
	ADJSP	SP,-1				; SP,-1
L.73:	MOVEI	AC1,12				; AC1,12
	JRST	L.77				; L.77
L.74:	SETZM	U.52				; NUM%RETRIES									2267
	MOVEI	AC1,1				; AC1,1										2268
	MOVEM	AC1,U.63			; AC1,INIT%PKT%SENT
L.75:	ADJSP	SP,-1				; SP,-1										2269
	MOVEI	AC1,14				; AC1,14									2259
	JRST	L.77				; L.77
L.76:	ADJSP	SP,-1				; SP,-1										2276
	MOVE	AC1,U.49			; AC1,STATE									2207
L.77:	POP	SP,AC16				; SP,AC16									2169
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,
C.27:	XWD	0,U.74				; 0,IGNORE%ERROR

; Routine Size:  63 words


;   2278  1	%SBTTL 'SEND%DATA'
;   2279  1	ROUTINE SEND%DATA =
;   2280  1	
;   2281  1	!++
;   2282  1	! FUNCTIONAL DESCRIPTION:
;   2283  1	!
;   2284  1	!	This routine will send a data message to the remote KERMIT.
;   2285  1	!
;   2286  1	! CALLING SEQUENCE:
;   2287  1	!
;   2288  1	!	STATE = SEND%DATA();
;   2289  1	!
;   2290  1	! INPUT PARAMETERS:
;   2291  1	!
;   2292  1	!	None.
;   2293  1	!
;   2294  1	! IMPLICIT INPUTS:
;   2295  1	!
;   2296  1	!	None.
;   2297  1	!
;   2298  1	! OUTPUT PARAMETERS:
;   2299  1	!
;   2300  1	!	New state to change the finite state machine to.
;   2301  1	!
;   2302  1	! IMPLICIT OUTPUTS:
;   2303  1	!
;   2304  1	!	None.
;   2305  1	!
;   2306  1	! COMPLETION CODES:
;   2307  1	!
;   2308  1	!	None.
;   2309  1	!
;   2310  1	! SIDE EFFECTS:
;   2311  1	!
;   2312  1	!	None.
;   2313  1	!
;   2314  1	!--
;   2315  1	
;   2316  2	    BEGIN
;   2317  2	
;   2318  2	    LOCAL
;   2319  2		SUB%TYPE,				! Subtype for XFR%STATUS call
;   2320  2		STATUS;					! Status returned by various routines
;   2321  2	
;   2322  2	!
;   2323  2	! If there is nothing in the data packet, we should not bother to send it.
;   2324  2	! Instead, we will just call BFR%FILL again to get some more data
;   2325  2	!
;   2326  2	
;   2327  2	    IF .SIZE GTR 0
;   2328  2	    THEN
;   2329  3		BEGIN
;   2330  3	!
;   2331  3	! Check to see if the number of retries have been exceeded.
;   2332  3	!
;   2333  3	
;   2334  3		IF .NUM%RETRIES GTR .PKT%RETRIES THEN RETURN STATE%ER;
;   2335  3	
;   2336  3	!
;   2337  3	! Not exceeded yet.  Increment the number of retries we have attempted
;   2338  3	! on this message.
;   2339  3	!
;   2340  3		NUM%RETRIES = .NUM%RETRIES + 1;
;   2341  3	!
;   2342  3	! Attempt to send the packet and abort if the send fails.
;   2343  3	!
;   2344  3	
;   2345  3		IF NOT SEND%PACKET (MSG%DATA, .SIZE, .MSG%NUMBER) THEN RETURN STATE%EX;
;   2346  3	
;   2347  3	!
;   2348  3	! Attempt to receive a message from the remote KERMIT.
;   2349  3	!
;   2350  3		STATUS = REC%PACKET ();
;   2351  3	
;   2352  3		IF NOT .STATUS
;   2353  3		THEN
;   2354  4		    BEGIN
;   2355  4	
;   2356  5		    IF (.STATUS EQL KER%ZEROLENMSG) OR (.STATUS EQL KER%TIMEOUT) OR (.STATUS EQL
;   2357  5			KER%CHKSUMERR)
;   2358  4		    THEN
;   2359  4			RETURN .STATE
;   2360  4		    ELSE
;   2361  4			RETURN STATE%EX;
;   2362  4	
;   2363  3		    END;
;   2364  3	
;   2365  3	!
;   2366  3	! Determine if the message is a NAK and the NAK is for the message number
;   2367  3	! that we are current working on.  If the NAK is for the next packet then
;   2368  3	! treat it like an ACK for this packet
;   2369  3	!
;   2370  3	
;   2371  4		IF .REC%TYPE EQL MSG%NAK AND (.REC%SEQ NEQ ((.MSG%NUMBER + 1) AND %O'77'))
;   2372  3		THEN
;   2373  3		    RETURN .STATE;
;   2374  3	
;   2375  3	!
;   2376  3	! Make sure we have a NAK or ACK
;   2377  3	!
;   2378  3	
;   2379  4		IF NOT (.REC%TYPE EQL MSG%ACK OR .REC%TYPE EQL MSG%NAK)
;   2380  3		THEN
;   2381  3	!
;   2382  3	! Not an ACK or NAK, abort.
;   2383  3	!
;   2384  4		    BEGIN
;   2385  4		    KRM%ERROR (KER%PROTOERR);
;   2386  4		    RETURN STATE%A;
;   2387  3		    END;
;   2388  3	
;   2389  3	!
;   2390  3	! Is this for this message?
;   2391  3	!
;   2392  3	
;   2393  3		IF .REC%TYPE EQL MSG%ACK AND .REC%SEQ NEQ .MSG%NUMBER THEN RETURN .STATE;
;   2394  3	
;   2395  3	!
;   2396  3	! It was.  Set up for sending the next data message to the remote KERMIT
;   2397  3	! and return.
;   2398  3	!
;   2399  3	!
;   2400  3	! Check for data field in ACK indicating abort file or stream
;   2401  3	!
;   2402  3	!
;   2403  3	
;   2404  3		IF .REC%TYPE EQL MSG%ACK AND .REC%LENGTH EQL 1
;   2405  3		THEN
;   2406  3	
;   2407  3		    SELECTONE CH$RCHAR (CH$PTR (REC%MSG, PKT%MSG, CHR%SIZE)) OF
;   2408  3			SET
;   2409  3	
;   2410  3			[MSG%ACK%ABT%CUR] :
;   2411  3			    ABT%CUR%FILE = TRUE;
;   2412  3	
;   2413  3			[MSG%ACK%ABT%ALL] :
;   2414  3			    ABT%ALL%FILE = TRUE;
;   2415  3			TES;
;   2416  3	
;   2417  3		NUM%RETRIES = 0;
;   2418  3		MSG%NUMBER = (.MSG%NUMBER + 1) AND %O'77';
;   2419  2		END;					! End of IF .SIZE GTR 0
;   2420  2	
;   2421  3	    IF (BFR%FILL (FALSE) EQL KER%NORMAL) AND NOT (.ABT%CUR%FILE OR .ABT%ALL%FILE)
;   2422  2	    THEN
;   2423  2		RETURN STATE%SD
;   2424  2	    ELSE
;   2425  3		BEGIN
;   2426  3	
;   2427  3		IF ( NOT .CONNECT%FLAG) AND .TY%FIL
;   2428  3		THEN
;   2429  4		    BEGIN
;   2430  4	
;   2431  4		    IF .ABT%ALL%FILE
;   2432  4		    THEN
;   2433  4			TT%TEXT (UPLIT (%ASCIZ' [Group interrupted]'))
;   2434  4		    ELSE
;   2435  4	
;   2436  4			IF .ABT%CUR%FILE
;   2437  4			THEN
;   2438  4			    TT%TEXT (UPLIT (%ASCIZ' [Interrupted]'))
;   2439  4			ELSE
;   2440  4			    TT%TEXT (UPLIT (%ASCIZ' [OK]'));
;   2441  4	
;   2442  4		    TT%CRLF ();
;   2443  3		    END;
;   2444  3	
;   2445  3		IF .FILE%OPEN%FLAG THEN FILE%CLOSE (FALSE);
;   2446  3	
;   2447  3		SUB%TYPE = %C'C';			! Assume ok
;   2448  3	
;   2449  3		IF .ABT%ALL%FILE
;   2450  3		THEN
;   2451  3		    SUB%TYPE = %C'Z'
;   2452  3		ELSE
;   2453  3	
;   2454  3		    IF .ABT%CUR%FILE THEN SUB%TYPE = %C'X';
;   2455  3	
;   2456  3		XFR%STATUS (%C'F', .SUB%TYPE);
;   2457  3		FILE%OPEN%FLAG = FALSE;
;   2458  3		RETURN STATE%SZ;
;   2459  2		END;
;   2460  2	
;   2461  1	    END;


P.AAB:	BYTE	(7)" ","[","G","r","o"		;  [Gro
	BYTE	(7)"u","p"," ","i","n"		; up in
	BYTE	(7)"t","e","r","r","u"		; terru
	BYTE	(7)"p","t","e","d","]"		; pted]
	BYTE	(7)000,000,000,000,000
P.AAC:	BYTE	(7)" ","[","I","n","t"		;  [Int
	BYTE	(7)"e","r","r","u","p"		; errup
	BYTE	(7)"t","e","d","]",000		; ted]
P.AAD:	BYTE	(7)" ","[","O","K","]"		;  [OK]
	BYTE	(7)000,000,000,000,000


; SEND%DATA
U.3:	MOVE	AC1,U.50			; AC1,SIZE									2327
	JUMPLE	AC1,L.87			; AC1,L.87
	MOVE	AC2,U.52			; AC2,NUM%RETRIES								2334
	CAMG	AC2,PKT%RETRIES			; AC2,PKT%RETRIES
	JRST	L.78				; L.78
	MOVEI	AC1,24				; AC1,24
	POPJ	SP,				; SP,
L.78:	AOS	U.52				; NUM%RETRIES									2340
	PUSH	SP,C.28				; SP,[104]									2345
	PUSH	SP,AC1				; SP,AC1
	PUSH	SP,U.53				; SP,MSG%NUMBER
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	ADJSP	SP,-3				; SP,-3
	TRNN	AC1,1				; AC1,1
	JRST	L.79				; L.79
	PUSHJ	SP,U.26				; SP,REC%PACKET									2350
	TRNE	AC1,1				; STATUS,1									2352
	JRST	L.80				; L.80
	CAIE	AC1,262				; STATUS,262									2356
	CAIN	AC1,300				; STATUS,300
	JRST	L.83				; L.83
	CAIN	AC1,172				; STATUS,172
	JRST	L.83				; L.83										2359
L.79:	MOVEI	AC1,23				; AC1,23									2361
	POPJ	SP,				; SP,										2354
L.80:	MOVE	AC2,U.56			; AC2,REC%TYPE									2371
	SETZ	AC3,				; AC3,
	CAIE	AC2,116				; AC2,116
	JRST	L.81				; L.81
	MOVEI	AC3,1				; AC3,1
	MOVE	AC1,U.53			; AC1,MSG%NUMBER
	ADDI	AC1,1				; AC1,1
	LDB	AC4,C.18			; AC4,[POINT 6,AC1,35]  <0,6>
	CAME	AC4,U.54			; AC4,REC%SEQ
	JRST	L.83				; L.83
L.81:	CAIE	AC2,131				; AC2,131									2379
	TRNE	AC3,1				; AC3,1
	JRST	L.82				; L.82
	PUSH	SP,C.22				; SP,[252]									2385
	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
	ADJSP	SP,-1				; SP,-1										2386
	MOVEI	AC1,12				; AC1,12									2384
	POPJ	SP,				; SP,
L.82:	SETZ	AC1,				; AC1,										2393
	MOVEI	AC2,131				; AC2,131
	CAME	AC2,U.56			; AC2,REC%TYPE
	JRST	L.84				; L.84
	MOVEI	AC1,1				; AC1,1
	MOVE	AC2,U.54			; AC2,REC%SEQ
	CAMN	AC2,U.53			; AC2,MSG%NUMBER
	JRST	L.84				; L.84
L.83:	MOVE	AC1,U.49			; AC1,STATE
	POPJ	SP,				; SP,
L.84:	TRNN	AC1,1				; AC1,1										2404
	JRST	L.86				; L.86
	MOVEI	AC1,1				; AC1,1
	CAME	AC1,U.55			; AC1,REC%LENGTH
	JRST	L.86				; L.86
	MOVE	AC1,C.29			; AC1,[POINT 8,REC%MSG,31]  <4,8>						2407
	ILDB	AC1,AC1				; AC1,AC1
	CAIE	AC1,130				; AC1,130									2410
	JRST	L.85				; L.85
	MOVEI	AC2,1				; AC2,1										2411
	MOVEM	AC2,ABT%CUR%FILE		; AC2,ABT%CUR%FILE
	JRST	L.86				; L.86										2407
L.85:	CAIE	AC1,132				; AC1,132									2413
	JRST	L.86				; L.86
	MOVEI	AC1,1				; AC1,1										2414
	MOVEM	AC1,ABT%ALL%FILE		; AC1,ABT%ALL%FILE
L.86:	SETZM	U.52				; NUM%RETRIES									2417
	MOVE	AC1,U.53			; AC1,MSG%NUMBER								2418
	ADDI	AC1,1				; AC1,1
	LDB	AC2,C.18			; AC2,[POINT 6,AC1,35]  <0,6>
	MOVEM	AC2,U.53			; AC2,MSG%NUMBER
L.87:	PUSH	SP,C.26				; SP,[0]									2421
	PUSHJ	SP,U.29				; SP,BFR%FILL
	ADJSP	SP,-1				; SP,-1
	CAIE	AC1,13				; AC1,13
	JRST	L.88				; L.88
	MOVEI	AC1,1				; AC1,1
	TDNE	AC1,ABT%CUR%FILE		; AC1,ABT%CUR%FILE
	JRST	L.88				; L.88
	MOVEI	AC1,1				; AC1,1
	TDNE	AC1,ABT%ALL%FILE		; AC1,ABT%ALL%FILE
	JRST	L.88				; L.88
	MOVEI	AC1,3				; AC1,3										2425
	POPJ	SP,				; SP,
L.88:	MOVEI	AC1,1				; AC1,1										2427
	TDNE	AC1,CONNECT%FLAG		; AC1,CONNECT%FLAG
	JRST	L.92				; L.92
	MOVEI	AC1,1				; AC1,1
	TDNN	AC1,TY%FIL			; AC1,TY%FIL
	JRST	L.92				; L.92
	MOVEI	AC1,1				; AC1,1										2431
	TDNN	AC1,ABT%ALL%FILE		; AC1,ABT%ALL%FILE
	JRST	L.89				; L.89
	PUSH	SP,C.30				; SP,[0,,P.AAB]									2433
	JRST	L.91				; L.91
L.89:	MOVEI	AC1,1				; AC1,1										2436
	TDNN	AC1,ABT%CUR%FILE		; AC1,ABT%CUR%FILE
	JRST	L.90				; L.90
	PUSH	SP,C.31				; SP,[0,,P.AAC]									2438
	JRST	L.91				; L.91
L.90:	PUSH	SP,C.32				; SP,[0,,P.AAD]									2440
L.91:	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSHJ	SP,TT%CRLF			; SP,TT%CRLF									2442
	ADJSP	SP,-1				; SP,-1										2429
L.92:	MOVEI	AC1,1				; AC1,1										2445
	TDNN	AC1,U.59			; AC1,FILE%OPEN%FLAG
	JRST	L.93				; L.93
	PUSH	SP,C.26				; SP,[0]
	PUSHJ	SP,FILE%CLOSE			; SP,FILE%CLOSE
	ADJSP	SP,-1				; SP,-1
L.93:	MOVEI	AC1,103				; SUB%TYPE,103									2447
	MOVEI	AC2,1				; AC2,1										2449
	TDNN	AC2,ABT%ALL%FILE		; AC2,ABT%ALL%FILE
	JRST	L.94				; L.94
	MOVEI	AC1,132				; SUB%TYPE,132									2451
	JRST	L.95				; L.95										2449
L.94:	MOVEI	AC2,1				; AC2,1										2454
	TDNE	AC2,ABT%CUR%FILE		; AC2,ABT%CUR%FILE
	MOVEI	AC1,130				; SUB%TYPE,130
L.95:	PUSH	SP,C.15				; SP,[106]									2456
	PUSH	SP,AC1				; SP,SUB%TYPE
	PUSHJ	SP,XFR%STATUS			; SP,XFR%STATUS
	SETZM	U.59				; FILE%OPEN%FLAG								2457
	ADJSP	SP,-2				; SP,-2										2425
	MOVEI	AC1,4				; AC1,4
	POPJ	SP,				; SP,										2279
C.28:	EXP	104				; 104
C.29:	POINT	8,U.57,31			; 8,REC%MSG,31
C.30:	XWD	0,P.AAB				; 0,P.AAB
C.31:	XWD	0,P.AAC				; 0,P.AAC
C.32:	XWD	0,P.AAD				; 0,P.AAD

; Routine Size:  134 words


;   2462  1	%SBTTL 'SEND%FILE'
;   2463  1	ROUTINE SEND%FILE =
;   2464  1	
;   2465  1	!++
;   2466  1	! FUNCTIONAL DESCRIPTION:
;   2467  1	!
;   2468  1	!	This routine will send the file specification that is being
;   2469  1	!	transfered, or it will send a text header message.
;   2470  1	!
;   2471  1	! CALLING SEQUENCE:
;   2472  1	!
;   2473  1	!	STATE = SEND%FILE();
;   2474  1	!
;   2475  1	! INPUT PARAMETERS:
;   2476  1	!
;   2477  1	!	None.
;   2478  1	!
;   2479  1	! IMPLICIT INPUTS:
;   2480  1	!
;   2481  1	!	TEXT%HEAD%FLAG - If true, send text header instead of file header
;   2482  1	!
;   2483  1	! OUTPUT PARAMETERS:
;   2484  1	!
;   2485  1	!	New state to change the finite state machine to.
;   2486  1	!
;   2487  1	! IMPLICIT OUTPUTS:
;   2488  1	!
;   2489  1	!	None.
;   2490  1	!
;   2491  1	! COMPLETION CODES:
;   2492  1	!
;   2493  1	!	None.
;   2494  1	!
;   2495  1	! SIDE EFFECTS:
;   2496  1	!
;   2497  1	!	None.
;   2498  1	!
;   2499  1	!--
;   2500  1	
;   2501  2	    BEGIN
;   2502  2	
;   2503  2	    LOCAL
;   2504  2		M%TYPE,					! Message type to send
;   2505  2		STATUS;					! Status returned by various routines
;   2506  2	
;   2507  2	!
;   2508  2	! Flag we don't want to abort yet
;   2509  2	!
;   2510  2	    ABT%CUR%FILE = FALSE;
;   2511  2	    ABT%ALL%FILE = FALSE;
;   2512  2	!
;   2513  2	! First determine if we have exceed the number of retries that are
;   2514  2	! allowed to attempt to send this message.
;   2515  2	!
;   2516  2	
;   2517  2	    IF .NUM%RETRIES GTR .PKT%RETRIES THEN RETURN STATE%ER;
;   2518  2	
;   2519  2	!
;   2520  2	! The number of retries are not exceeded.  Increment the number and then
;   2521  2	! attempt to send the packet again.
;   2522  2	!
;   2523  2	    NUM%RETRIES = .NUM%RETRIES + 1;
;   2524  2	    SIZE = 0;					! Assume no name
;   2525  2	
;   2526  2	    IF .TEXT%HEAD%FLAG THEN M%TYPE = MSG%TEXT ELSE M%TYPE = MSG%FILE;
;   2527  2	
;   2528  2	    IF .FILE%SIZE NEQ 0 AND NOT .NO%FILE%NEEDED
;   2529  2	    THEN
;   2530  3		BEGIN
;   2531  3	![025]	CH$MOVE (.FILE%SIZE, CH$PTR (FILE%NAME),
;   2532  3	![025]	    CH$PTR (SND%MSG, PKT%MSG,
;   2533  3	![025]		CHR%SIZE));
;   2534  3	![025]
;   2535  3	![025] Fill packet with file name
;   2536  3	![025]
;   2537  3		SET%STRING (CH$PTR (FILE%NAME), .FILE%SIZE, TRUE);
;   2538  3		BFR%FILL (TRUE);
;   2539  3		SET%STRING (0, 0, FALSE);
;   2540  2		END;
;   2541  2	
;   2542  2	    IF NOT SEND%PACKET (.M%TYPE, .SIZE, .MSG%NUMBER) THEN RETURN STATE%EX;
;   2543  2	
;   2544  2	!
;   2545  2	! Now get the responce from the remote KERMIT.
;   2546  2	!
;   2547  2	    STATUS = REC%PACKET ();
;   2548  2	
;   2549  2	    IF NOT .STATUS
;   2550  2	    THEN
;   2551  3		BEGIN
;   2552  3	
;   2553  4		IF (.STATUS EQL KER%ZEROLENMSG) OR (.STATUS EQL KER%TIMEOUT) OR (.STATUS EQL KER%CHKSUMERR)
;   2554  3		THEN
;   2555  3		    RETURN .STATE
;   2556  3		ELSE
;   2557  3		    RETURN STATE%EX;
;   2558  3	
;   2559  2		END;
;   2560  2	
;   2561  2	!
;   2562  2	! Determine if the packet is good.
;   2563  2	!
;   2564  2	
;   2565  3	    IF NOT (.REC%TYPE EQL MSG%ACK OR .REC%TYPE EQL MSG%NAK)
;   2566  2	    THEN
;   2567  3		BEGIN
;   2568  3		KRM%ERROR (KER%PROTOERR);
;   2569  3		RETURN STATE%A;
;   2570  2		END;
;   2571  2	
;   2572  2	!
;   2573  2	! If this is a NAK and the message number is not the one we just send
;   2574  2	! treat this like an ACK, otherwise resend the last packet.
;   2575  2	!
;   2576  2	
;   2577  2	    IF .REC%TYPE EQL MSG%NAK AND (.REC%SEQ NEQ ((.MSG%NUMBER + 1) AND %O'77')) THEN RETURN .STATE;
;   2578  2	
;   2579  2	    IF .REC%TYPE EQL MSG%ACK AND .REC%SEQ NEQ .MSG%NUMBER THEN RETURN .STATE;
;   2580  2	
;   2581  2	!
;   2582  2	! If all is ok, bump the message number and fill first buffer
;   2583  2	!
;   2584  2	    NUM%RETRIES = 0;
;   2585  2	    MSG%NUMBER = (.MSG%NUMBER + 1) AND %O'77';
;   2586  2	
;   2587  2	    IF BFR%FILL (TRUE) THEN RETURN STATE%SD ELSE RETURN STATE%A;
;   2588  2	
;   2589  1	    END;					! End of SEND%FILE


; SEND%FILE
U.4:	PUSH	SP,AC16				; SP,AC16									2463
	SETZM	ABT%CUR%FILE			; ABT%CUR%FILE									2510
	SETZM	ABT%ALL%FILE			; ABT%ALL%FILE									2511
	MOVE	AC1,U.52			; AC1,NUM%RETRIES								2517
	CAMG	AC1,PKT%RETRIES			; AC1,PKT%RETRIES
	JRST	L.96				; L.96
	MOVEI	AC1,24				; AC1,24
	JRST	L.107				; L.107
L.96:	AOS	U.52				; NUM%RETRIES									2523
	SETZM	U.50				; SIZE										2524
	MOVEI	AC1,1				; AC1,1										2526
	TDNN	AC1,U.61			; AC1,TEXT%HEAD%FLAG
	JRST	L.97				; L.97
	MOVEI	AC16,130			; M%TYPE,130
	JRST	L.98				; L.98
L.97:	MOVEI	AC16,106			; M%TYPE,106
L.98:	MOVE	AC1,FILE%SIZE			; AC1,FILE%SIZE									2528
	JUMPE	AC1,L.99			; AC1,L.99
	MOVEI	AC2,1				; AC2,1
	TDNE	AC2,U.62			; AC2,NO%FILE%NEEDED
	JRST	L.99				; L.99
	PUSH	SP,C.10				; SP,[POINT 7,FILE%NAME-1,34]  <1,7>						2537
	PUSH	SP,AC1				; SP,AC1
	PUSH	SP,C.2				; SP,[1]
	PUSHJ	SP,U.30				; SP,SET%STRING
	PUSH	SP,C.2				; SP,[1]									2538
	PUSHJ	SP,U.29				; SP,BFR%FILL
	SETZM	-2(SP)				; -2(SP)									2539
	SETZM	-1(SP)				; -1(SP)
	SETZM	0(SP)				; 0(SP)
	PUSHJ	SP,U.30				; SP,SET%STRING
	ADJSP	SP,-4				; SP,-4										2530
L.99:	PUSH	SP,AC16				; SP,M%TYPE									2542
	PUSH	SP,U.50				; SP,SIZE
	PUSH	SP,U.53				; SP,MSG%NUMBER
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	ADJSP	SP,-3				; SP,-3
	TRNN	AC1,1				; AC1,1
	JRST	L.100				; L.100
	PUSHJ	SP,U.26				; SP,REC%PACKET									2547
	TRNE	AC1,1				; STATUS,1									2549
	JRST	L.101				; L.101
	CAIE	AC1,262				; STATUS,262									2553
	CAIN	AC1,300				; STATUS,300
	JRST	L.104				; L.104
	CAIN	AC1,172				; STATUS,172
	JRST	L.104				; L.104										2555
L.100:	MOVEI	AC1,23				; AC1,23									2557
	JRST	L.107				; L.107										2551
L.101:	MOVE	AC1,U.56			; AC1,REC%TYPE									2565
	CAIE	AC1,131				; AC1,131
	CAIN	AC1,116				; AC1,116
	JRST	L.102				; L.102
	PUSH	SP,C.22				; SP,[252]									2568
	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
	ADJSP	SP,-1				; SP,-1										2569
	JRST	L.106				; L.106
L.102:	MOVE	AC2,U.56			; AC2,REC%TYPE									2577
	CAIE	AC2,116				; AC2,116
	JRST	L.103				; L.103
	MOVE	AC1,U.53			; AC1,MSG%NUMBER
	ADDI	AC1,1				; AC1,1
	LDB	AC3,C.18			; AC3,[POINT 6,AC1,35]  <0,6>
	CAME	AC3,U.54			; AC3,REC%SEQ
	JRST	L.104				; L.104
L.103:	CAIE	AC2,131				; AC2,131									2579
	JRST	L.105				; L.105
	MOVE	AC1,U.54			; AC1,REC%SEQ
	CAMN	AC1,U.53			; AC1,MSG%NUMBER
	JRST	L.105				; L.105
L.104:	MOVE	AC1,U.49			; AC1,STATE
	JRST	L.107				; L.107
L.105:	SETZM	U.52				; NUM%RETRIES									2584
	MOVE	AC1,U.53			; AC1,MSG%NUMBER								2585
	ADDI	AC1,1				; AC1,1
	LDB	AC2,C.18			; AC2,[POINT 6,AC1,35]  <0,6>
	MOVEM	AC2,U.53			; AC2,MSG%NUMBER
	PUSH	SP,C.2				; SP,[1]									2587
	PUSHJ	SP,U.29				; SP,BFR%FILL
	ADJSP	SP,-1				; SP,-1
	TRNN	AC1,1				; AC1,1
	JRST	L.106				; L.106
	MOVEI	AC1,3				; AC1,3
	JRST	L.107				; L.107
L.106:	MOVEI	AC1,12				; AC1,12
L.107:	POP	SP,AC16				; SP,AC16									2463
	POPJ	SP,				; SP,

; Routine Size:  87 words


;   2590  1	%SBTTL 'SEND%EOF'
;   2591  1	ROUTINE SEND%EOF =
;   2592  1	
;   2593  1	!++
;   2594  1	! FUNCTIONAL DESCRIPTION:
;   2595  1	!
;   2596  1	!	This routine will send the end of file message to the remote
;   2597  1	!	KERMIT.  It will then determine if there are more files to
;   2598  1	!	send to the remote.
;   2599  1	!
;   2600  1	! CALLING SEQUENCE:
;   2601  1	!
;   2602  1	!	STATE = SEND%EOF();
;   2603  1	!
;   2604  1	! INPUT PARAMETERS:
;   2605  1	!
;   2606  1	!	None.
;   2607  1	!
;   2608  1	! IMPLICIT INPUTS:
;   2609  1	!
;   2610  1	!	None.
;   2611  1	!
;   2612  1	! OUTPUT PARAMETERS:
;   2613  1	!
;   2614  1	!	New state to change the finite state machine to.
;   2615  1	!
;   2616  1	! IMPLICIT OUTPUTS:
;   2617  1	!
;   2618  1	!	None.
;   2619  1	!
;   2620  1	! COMPLETION CODES:
;   2621  1	!
;   2622  1	!	None.
;   2623  1	!
;   2624  1	! SIDE EFFECTS:
;   2625  1	!
;   2626  1	!	Sets up for the next file to be processed if there is one.
;   2627  1	!
;   2628  1	!--
;   2629  1	
;   2630  2	    BEGIN
;   2631  2	
;   2632  2	    LOCAL
;   2633  2		STATUS,					! Status returned by various routines
;   2634  2		EOF%MSG%LEN;				! Length of EOF message to send
;   2635  2	
;   2636  2	!
;   2637  2	! First determine if we have exceed the number of retries that are
;   2638  2	! allowed to attempt to send this message.
;   2639  2	!
;   2640  2	
;   2641  2	    IF .NUM%RETRIES GTR .PKT%RETRIES THEN RETURN STATE%ER;
;   2642  2	
;   2643  2	!
;   2644  2	! The number of retries are not exceeded.  Increment the number and then
;   2645  2	! attempt to send the packet again.
;   2646  2	!
;   2647  2	    NUM%RETRIES = .NUM%RETRIES + 1;
;   2648  2	!
;   2649  2	! Store character in packet to indicate discard of file
;   2650  2	! Character will only be sent if file should be discarded
;   2651  2	!
;   2652  2	    CH$WCHAR (MSG%EOF%DISCARD, CH$PTR (SND%MSG, PKT%MSG, CHR%SIZE));
;   2653  2	
;   2654  2	    IF .ABT%CUR%FILE OR .ABT%ALL%FILE THEN EOF%MSG%LEN = 1 ELSE EOF%MSG%LEN = 0;
;   2655  2	
;   2656  2	    IF NOT SEND%PACKET (MSG%EOF, .EOF%MSG%LEN, .MSG%NUMBER) THEN RETURN STATE%EX;
;   2657  2	
;   2658  2	!
;   2659  2	! Now get the responce from the remote KERMIT.
;   2660  2	!
;   2661  2	    STATUS = REC%PACKET ();
;   2662  2	
;   2663  2	    IF NOT .STATUS
;   2664  2	    THEN
;   2665  3		BEGIN
;   2666  3	
;   2667  4		IF (.STATUS EQL KER%ZEROLENMSG) OR (.STATUS EQL KER%TIMEOUT) OR (.STATUS EQL KER%CHKSUMERR)
;   2668  3		THEN
;   2669  3		    RETURN .STATE
;   2670  3		ELSE
;   2671  3		    RETURN STATE%EX;
;   2672  3	
;   2673  2		END;
;   2674  2	
;   2675  2	!
;   2676  2	! Determine if the packet is good.
;   2677  2	!
;   2678  2	
;   2679  3	    IF NOT (.REC%TYPE EQL MSG%ACK OR .REC%TYPE EQL MSG%NAK)
;   2680  2	    THEN
;   2681  3		BEGIN
;   2682  3		KRM%ERROR (KER%PROTOERR);
;   2683  3		RETURN STATE%A;
;   2684  2		END;
;   2685  2	
;   2686  2	!
;   2687  2	! If this is a NAK and the message number is not the one we just send
;   2688  2	! treat this like an ACK, otherwise resend the last packet.
;   2689  2	!
;   2690  2	
;   2691  2	    IF .REC%TYPE EQL MSG%NAK AND (.REC%SEQ NEQ ((.MSG%NUMBER + 1) AND %O'77')) THEN RETURN .STATE;
;   2692  2	
;   2693  2	    IF .REC%TYPE EQL MSG%ACK AND .REC%SEQ NEQ .MSG%NUMBER THEN RETURN .STATE;
;   2694  2	
;   2695  2	!
;   2696  2	! Here to determine if there is another file to send.
;   2697  2	!
;   2698  2	    NUM%RETRIES = 0;
;   2699  2	    MSG%NUMBER = (.MSG%NUMBER + 1) AND %O'77';
;   2700  2	
;   2701  2	    IF NOT .ABT%ALL%FILE THEN STATUS = NEXT%FILE () ELSE STATUS = KER%NOMORFILES;
;   2702  2	
;   2703  3	    IF ( NOT .STATUS) OR (.STATUS EQL KER%NOMORFILES)
;   2704  2	    THEN
;   2705  3		BEGIN
;   2706  3	
;   2707  3		IF (.STATUS NEQ KER%NOMORFILES) THEN RETURN STATE%A ELSE RETURN STATE%SB;
;   2708  3	
;   2709  3		END
;   2710  2	    ELSE
;   2711  3		BEGIN
;   2712  3		FILE%OPEN%FLAG = TRUE;			! Have a file open again
;   2713  3	
;   2714  3		IF .FIL%NORMAL%FORM THEN NORMALIZE%FILE (FILE%NAME, FILE%SIZE, -1, -1);
;   2715  3	
;   2716  3		XFR%STATUS (%C'F', %C'S');		! Inform display routine
;   2717  3	
;   2718  3		IF ( NOT .CONNECT%FLAG) AND .TY%FIL
;   2719  3		THEN
;   2720  4		    BEGIN
;   2721  4		    TT%TEXT (UPLIT (%ASCIZ'Sending: '));
;   2722  4		    TT%TEXT (FILE%NAME);
;   2723  4		    TT%OUTPUT ();
;   2724  3		    END;
;   2725  3	
;   2726  3		FILE%CHARS = 0;				! No characters sent yet
;   2727  3		RETURN STATE%SF;
;   2728  2		END;
;   2729  2	
;   2730  1	    END;					! End of SEND%EOF


P.AAE:	BYTE	(7)"S","e","n","d","i"		; Sendi
	BYTE	(7)"n","g",":"," ",000		; ng:


; SEND%EOF
U.7:	PUSH	SP,AC16				; SP,AC16									2591
	MOVE	AC1,U.52			; AC1,NUM%RETRIES								2641
	CAMG	AC1,PKT%RETRIES			; AC1,PKT%RETRIES
	JRST	L.108				; L.108
	MOVEI	AC1,24				; AC1,24
	JRST	L.125				; L.125
L.108:	AOS	U.52				; NUM%RETRIES									2647
	MOVEI	AC2,104				; AC2,104									2652
	MOVE	AC1,C.33			; AC1,[POINT 8,SND%MSG,31]  <4,8>
	IDPB	AC2,AC1				; AC2,AC1
	MOVEI	AC1,1				; AC1,1										2654
	TDNE	AC1,ABT%CUR%FILE		; AC1,ABT%CUR%FILE
	JRST	L.109				; L.109
	MOVEI	AC1,1				; AC1,1
	TDNN	AC1,ABT%ALL%FILE		; AC1,ABT%ALL%FILE
	JRST	L.110				; L.110
L.109:	MOVEI	AC1,1				; EOF%MSG%LEN,1
	JRST	L.111				; L.111
L.110:	SETZ	AC1,				; EOF%MSG%LEN,
L.111:	PUSH	SP,C.34				; SP,[132]									2656
	PUSH	SP,AC1				; SP,EOF%MSG%LEN
	PUSH	SP,U.53				; SP,MSG%NUMBER
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	ADJSP	SP,-3				; SP,-3
	TRNN	AC1,1				; AC1,1
	JRST	L.112				; L.112
	PUSHJ	SP,U.26				; SP,REC%PACKET									2661
	MOVE	AC16,AC1			; STATUS,AC1
	TRNE	AC16,1				; STATUS,1									2663
	JRST	L.113				; L.113
	CAIE	AC16,262			; STATUS,262									2667
	CAIN	AC16,300			; STATUS,300
	JRST	L.116				; L.116
	CAIN	AC16,172			; STATUS,172
	JRST	L.116				; L.116										2669
L.112:	MOVEI	AC1,23				; AC1,23									2671
	JRST	L.125				; L.125										2665
L.113:	MOVE	AC1,U.56			; AC1,REC%TYPE									2679
	CAIE	AC1,131				; AC1,131
	CAIN	AC1,116				; AC1,116
	JRST	L.114				; L.114
	PUSH	SP,C.22				; SP,[252]									2682
	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
	ADJSP	SP,-1				; SP,-1										2683
	JRST	L.120				; L.120
L.114:	MOVE	AC2,U.56			; AC2,REC%TYPE									2691
	CAIE	AC2,116				; AC2,116
	JRST	L.115				; L.115
	MOVE	AC1,U.53			; AC1,MSG%NUMBER
	ADDI	AC1,1				; AC1,1
	LDB	AC3,C.18			; AC3,[POINT 6,AC1,35]  <0,6>
	CAME	AC3,U.54			; AC3,REC%SEQ
	JRST	L.116				; L.116
L.115:	CAIE	AC2,131				; AC2,131									2693
	JRST	L.117				; L.117
	MOVE	AC1,U.54			; AC1,REC%SEQ
	CAMN	AC1,U.53			; AC1,MSG%NUMBER
	JRST	L.117				; L.117
L.116:	MOVE	AC1,U.49			; AC1,STATE
	JRST	L.125				; L.125
L.117:	SETZM	U.52				; NUM%RETRIES									2698
	MOVE	AC1,U.53			; AC1,MSG%NUMBER								2699
	ADDI	AC1,1				; AC1,1
	LDB	AC2,C.18			; AC2,[POINT 6,AC1,35]  <0,6>
	MOVEM	AC2,U.53			; AC2,MSG%NUMBER
	MOVEI	AC1,1				; AC1,1										2701
	TDNE	AC1,ABT%ALL%FILE		; AC1,ABT%ALL%FILE
	JRST	L.118				; L.118
	PUSHJ	SP,NEXT%FILE			; SP,NEXT%FILE
	SKIPA	AC16,AC1			; STATUS,AC1
L.118:	MOVEI	AC16,133			; STATUS,133
	TRNN	AC16,1				; STATUS,1									2703
	JRST	L.119				; L.119
	CAIE	AC16,133			; STATUS,133
	JRST	L.122				; L.122
L.119:	CAIN	AC16,133			; STATUS,133									2707
	JRST	L.121				; L.121
L.120:	MOVEI	AC1,12				; AC1,12
	JRST	L.125				; L.125
L.121:	MOVEI	AC1,5				; AC1,5
	JRST	L.125				; L.125										2711
L.122:	MOVEI	AC1,1				; AC1,1										2712
	MOVEM	AC1,U.59			; AC1,FILE%OPEN%FLAG
	MOVEI	AC1,1				; AC1,1										2714
	TDNN	AC1,FIL%NORMAL%FORM		; AC1,FIL%NORMAL%FORM
	JRST	L.123				; L.123
	PUSH	SP,C.35				; SP,[0,,FILE%NAME]
	PUSH	SP,C.36				; SP,[0,,FILE%SIZE]
	PUSH	SP,C.37				; SP,[-1]
	PUSH	SP,C.37				; SP,[-1]
	PUSHJ	SP,U.27				; SP,NORMALIZE%FILE
	ADJSP	SP,-4				; SP,-4
L.123:	PUSH	SP,C.15				; SP,[106]									2716
	PUSH	SP,C.8				; SP,[123]
	PUSHJ	SP,XFR%STATUS			; SP,XFR%STATUS
	MOVEI	AC1,1				; AC1,1										2718
	TDNE	AC1,CONNECT%FLAG		; AC1,CONNECT%FLAG
	JRST	L.124				; L.124
	MOVEI	AC1,1				; AC1,1
	TDNN	AC1,TY%FIL			; AC1,TY%FIL
	JRST	L.124				; L.124
	PUSH	SP,C.38				; SP,[0,,P.AAE]									2721
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSH	SP,C.35				; SP,[0,,FILE%NAME]								2722
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSHJ	SP,TT%OUTPUT			; SP,TT%OUTPUT									2723
	ADJSP	SP,-2				; SP,-2										2720
L.124:	SETZM	U.60				; FILE%CHARS									2726
	ADJSP	SP,-2				; SP,-2										2711
	MOVEI	AC1,2				; AC1,2
L.125:	POP	SP,AC16				; SP,AC16									2591
	POPJ	SP,				; SP,
C.33:	POINT	8,U.58,31			; 8,SND%MSG,31
C.34:	EXP	132				; 132
C.35:	XWD	0,FILE%NAME			; 0,FILE%NAME
C.36:	XWD	0,FILE%SIZE			; 0,FILE%SIZE
C.37:	EXP	-1				; -1
C.38:	XWD	0,P.AAE				; 0,P.AAE

; Routine Size:  118 words


;   2731  1	%SBTTL 'SEND%INIT'
;   2732  1	ROUTINE SEND%INIT =
;   2733  1	
;   2734  1	!++
;   2735  1	! FUNCTIONAL DESCRIPTION:
;   2736  1	!
;   2737  1	!	This routine will send the initialization packet to the remote
;   2738  1	!	KERMIT.  The message type sent is S.
;   2739  1	!
;   2740  1	! CALLING SEQUENCE:
;   2741  1	!
;   2742  1	!	STATE = SEND%INIT();
;   2743  1	!
;   2744  1	! INPUT PARAMETERS:
;   2745  1	!
;   2746  1	!	None.
;   2747  1	!
;   2748  1	! IMPLICIT INPUTS:
;   2749  1	!
;   2750  1	!	None.
;   2751  1	!
;   2752  1	! OUTPUT PARAMETERS:
;   2753  1	!
;   2754  1	!	New state to change the finite state machine to.
;   2755  1	!
;   2756  1	! IMPLICIT OUTPUTS:
;   2757  1	!
;   2758  1	!	None.
;   2759  1	!
;   2760  1	! COMPLETION CODES:
;   2761  1	!
;   2762  1	!	None.
;   2763  1	!
;   2764  1	! SIDE EFFECTS:
;   2765  1	!
;   2766  1	!	None.
;   2767  1	!
;   2768  1	!--
;   2769  1	
;   2770  2	    BEGIN
;   2771  2	
;   2772  2	    LOCAL
;   2773  2		STATUS;					! Status returned by various routines
;   2774  2	
;   2775  2	    SET%SEND%INIT ();
;   2776  2	
;   2777  2	    IF .NUM%RETRIES GTR .SI%RETRIES THEN RETURN STATE%ER;
;   2778  2	
;   2779  2	!
;   2780  2	! Count the number of times we try this
;   2781  2	!
;   2782  2	    NUM%RETRIES = .NUM%RETRIES + 1;
;   2783  2	
;   2784  2	    IF NOT SEND%PACKET (MSG%SND%INIT, P%SI%LENGTH, .MSG%NUMBER) THEN RETURN STATE%EX;
;   2785  2	
;   2786  2	!
;   2787  2	! Determine if we received a packet it good condition.  If we timed out or
;   2788  2	! got an illegal message, just try again.
;   2789  2	!
;   2790  2	    STATUS = REC%PACKET ();
;   2791  2	
;   2792  2	    IF NOT .STATUS
;   2793  2	    THEN
;   2794  3		BEGIN
;   2795  3	
;   2796  4		IF (.STATUS EQL KER%ZEROLENMSG) OR (.STATUS EQL KER%TIMEOUT) OR (.STATUS EQL KER%CHKSUMERR)
;   2797  3		THEN
;   2798  3		    RETURN .STATE
;   2799  3		ELSE
;   2800  3		    RETURN STATE%EX;
;   2801  3	
;   2802  2		END;
;   2803  2	
;   2804  2	!
;   2805  2	! Determine if the packet is good.
;   2806  2	!
;   2807  2	
;   2808  2	    IF .REC%TYPE NEQ MSG%ACK THEN RETURN .STATE;
;   2809  2	
;   2810  2	    IF .REC%SEQ NEQ .MSG%NUMBER THEN RETURN .STATE;
;   2811  2	
;   2812  2	!
;   2813  2	! Here if we have an ACK for the initialization message that was just sent
;   2814  2	! to the remote KERMIT.
;   2815  2	!
;   2816  2	
;   2817  2	    IF NOT (STATUS = PRS%SEND%INIT ()) THEN RETURN STATE%A;
;   2818  2	
;   2819  2	    BLK%CHK%TYPE = .INI%CHK%TYPE;		! We now use agreed upon block check type
;   2820  2	    NUM%RETRIES = 0;
;   2821  2	    MSG%NUMBER = (.MSG%NUMBER + 1) AND %O'77';
;   2822  2	    RETURN STATE%OF;				! Now need to open the file
;   2823  1	    END;


; SEND%INIT
U.8:	PUSHJ	SP,U.20				; SP,SET%SEND%INIT								2775
	MOVE	AC1,U.52			; AC1,NUM%RETRIES								2777
	CAMG	AC1,SI%RETRIES			; AC1,SI%RETRIES
	JRST	L.126				; L.126
	MOVEI	AC1,24				; AC1,24
	POPJ	SP,				; SP,
L.126:	AOS	U.52				; NUM%RETRIES									2782
	PUSH	SP,C.8				; SP,[123]									2784
	PUSH	SP,C.21				; SP,[11]
	PUSH	SP,U.53				; SP,MSG%NUMBER
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	ADJSP	SP,-3				; SP,-3
	TRNE	AC1,1				; AC1,1
	JRST	L.127				; L.127
	MOVEI	AC1,23				; AC1,23
	POPJ	SP,				; SP,
L.127:	PUSHJ	SP,U.26				; SP,REC%PACKET									2790
	TRNE	AC1,1				; STATUS,1									2792
	JRST	L.129				; L.129
	CAIE	AC1,262				; STATUS,262									2796
	CAIN	AC1,300				; STATUS,300
	JRST	L.128				; L.128
	CAIN	AC1,172				; STATUS,172
L.128:	SKIPA	AC2,U.49			; AC2,STATE									2800
	MOVEI	AC2,23				; AC2,23
	MOVE	AC1,AC2				; AC1,AC2									2794
	POPJ	SP,				; SP,
L.129:	MOVEI	AC2,131				; AC2,131									2808
	CAME	AC2,U.56			; AC2,REC%TYPE
	JRST	L.130				; L.130
	MOVE	AC2,U.54			; AC2,REC%SEQ									2810
	CAMN	AC2,U.53			; AC2,MSG%NUMBER
	JRST	L.131				; L.131
L.130:	MOVE	AC1,U.49			; AC1,STATE
	POPJ	SP,				; SP,
L.131:	PUSHJ	SP,U.21				; SP,PRS%SEND%INIT								2817
	TRNE	AC1,1				; STATUS,1
	JRST	L.132				; L.132
	MOVEI	AC1,12				; AC1,12
	POPJ	SP,				; SP,
L.132:	MOVE	AC1,U.45			; AC1,INI%CHK%TYPE								2819
	MOVEM	AC1,U.46			; AC1,BLK%CHK%TYPE
	SETZM	U.52				; NUM%RETRIES									2820
	MOVE	AC1,U.53			; AC1,MSG%NUMBER								2821
	ADDI	AC1,1				; AC1,1
	LDB	AC2,C.18			; AC2,[POINT 6,AC1,35]  <0,6>
	MOVEM	AC2,U.53			; AC2,MSG%NUMBER
	MOVEI	AC1,22				; AC1,22									2770
	POPJ	SP,				; SP,										2732

; Routine Size:  49 words


;   2824  1	%SBTTL 'SEND%OPEN%FILE - Open file for sending'
;   2825  1	ROUTINE SEND%OPEN%FILE =
;   2826  1	
;   2827  1	!++
;   2828  1	! FUNCTIONAL DESCRIPTION:
;   2829  1	!
;   2830  1	! This routine is called from DO%TRANSACTION when the first input file
;   2831  1	! needs to be opened.
;   2832  1	!
;   2833  1	! CALLING SEQUENCE:
;   2834  1	!
;   2835  1	!	STATE = SEND%OPEN%FILE ();
;   2836  1	!
;   2837  1	! INPUT PARAMETERS:
;   2838  1	!
;   2839  1	!	None.
;   2840  1	!
;   2841  1	! IMPLICIT INPUTS:
;   2842  1	!
;   2843  1	!	FILE%NAME, FILE%SIZE, etc.
;   2844  1	!
;   2845  1	! OUPTUT PARAMETERS:
;   2846  1	!
;   2847  1	!	New state for FSM.
;   2848  1	!
;   2849  1	! IMPLICIT OUTPUTS:
;   2850  1	!
;   2851  1	!	None.
;   2852  1	!
;   2853  1	! COMPLETION CODES:
;   2854  1	!
;   2855  1	!	None.
;   2856  1	!
;   2857  1	! SIDE EFFECTS:
;   2858  1	!
;   2859  1	!	None.
;   2860  1	!
;   2861  1	!--
;   2862  1	
;   2863  2	    BEGIN
;   2864  2	
;   2865  2	    IF ( NOT .CONNECT%FLAG) AND .TY%FIL
;   2866  2	    THEN
;   2867  3		BEGIN
;   2868  3		TT%TEXT (UPLIT (%ASCIZ'Sending: '));
;   2869  3		TT%OUTPUT ();
;   2870  2		END;
;   2871  2	
;   2872  2	    FILE%CHARS = 0;				! No characters sent yet
;   2873  2	
;   2874  2	    IF NOT .NO%FILE%NEEDED
;   2875  2	    THEN
;   2876  2	
;   2877  2		IF NOT FILE%OPEN (FNC%READ) THEN RETURN STATE%A ELSE FILE%OPEN%FLAG = TRUE;
;   2878  2	
;   2879  2	![023]
;   2880  2	![023] If we want normalized file names, beat up the name now
;   2881  2	![023]
;   2882  2	
;   2883  2	    IF .FIL%NORMAL%FORM THEN NORMALIZE%FILE (FILE%NAME, FILE%SIZE, -1, -1);
;   2884  2	
;   2885  2	    XFR%STATUS (%C'F', %C'S');			! Inform display routine
;   2886  2	
;   2887  2	    IF ( NOT .CONNECT%FLAG) AND .TY%FIL
;   2888  2	    THEN
;   2889  3		BEGIN
;   2890  3		TT%TEXT (FILE%NAME);
;   2891  3		TT%OUTPUT ();
;   2892  2		END;
;   2893  2	
;   2894  2	    RETURN STATE%SF;
;   2895  1	    END;					! End of FSM%OPEN%FILE


P.AAF:	BYTE	(7)"S","e","n","d","i"		; Sendi
	BYTE	(7)"n","g",":"," ",000		; ng:


; SEND%OPEN%FILE
U.5:	MOVEI	AC1,1				; AC1,1										2865
	TDNE	AC1,CONNECT%FLAG		; AC1,CONNECT%FLAG
	JRST	L.133				; L.133
	MOVEI	AC1,1				; AC1,1
	TDNN	AC1,TY%FIL			; AC1,TY%FIL
	JRST	L.133				; L.133
	PUSH	SP,C.39				; SP,[0,,P.AAF]									2868
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSHJ	SP,TT%OUTPUT			; SP,TT%OUTPUT									2869
	ADJSP	SP,-1				; SP,-1										2867
L.133:	SETZM	U.60				; FILE%CHARS									2872
	MOVEI	AC1,1				; AC1,1										2874
	TDNE	AC1,U.62			; AC1,NO%FILE%NEEDED
	JRST	L.135				; L.135
	PUSH	SP,C.26				; SP,[0]									2877
	PUSHJ	SP,FILE%OPEN			; SP,FILE%OPEN
	ADJSP	SP,-1				; SP,-1
	TRNE	AC1,1				; AC1,1
	JRST	L.134				; L.134
	MOVEI	AC1,12				; AC1,12
	POPJ	SP,				; SP,
L.134:	MOVEI	AC1,1				; AC1,1
	MOVEM	AC1,U.59			; AC1,FILE%OPEN%FLAG
L.135:	MOVEI	AC1,1				; AC1,1										2883
	TDNN	AC1,FIL%NORMAL%FORM		; AC1,FIL%NORMAL%FORM
	JRST	L.136				; L.136
	PUSH	SP,C.35				; SP,[0,,FILE%NAME]
	PUSH	SP,C.36				; SP,[0,,FILE%SIZE]
	PUSH	SP,C.37				; SP,[-1]
	PUSH	SP,C.37				; SP,[-1]
	PUSHJ	SP,U.27				; SP,NORMALIZE%FILE
	ADJSP	SP,-4				; SP,-4
L.136:	PUSH	SP,C.15				; SP,[106]									2885
	PUSH	SP,C.8				; SP,[123]
	PUSHJ	SP,XFR%STATUS			; SP,XFR%STATUS
	MOVEI	AC1,1				; AC1,1										2887
	TDNE	AC1,CONNECT%FLAG		; AC1,CONNECT%FLAG
	JRST	L.137				; L.137
	MOVEI	AC1,1				; AC1,1
	TDNN	AC1,TY%FIL			; AC1,TY%FIL
	JRST	L.137				; L.137
	PUSH	SP,C.35				; SP,[0,,FILE%NAME]								2890
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSHJ	SP,TT%OUTPUT			; SP,TT%OUTPUT									2891
	ADJSP	SP,-1				; SP,-1										2889
L.137:	ADJSP	SP,-2				; SP,-2										2894
	MOVEI	AC1,2				; AC1,2										2863
	POPJ	SP,				; SP,										2825
C.39:	XWD	0,P.AAF				; 0,P.AAF

; Routine Size:  49 words


;   2896  1	%SBTTL 'SEND%GENCMD'
;   2897  1	ROUTINE SEND%GENCMD =
;   2898  1	
;   2899  1	!++
;   2900  1	! FUNCTIONAL DESCRIPTION:
;   2901  1	!
;   2902  1	!	This routine will send a command packet to the server Kermit.
;   2903  1	!	The new state will depend upon the response.  If a send-init
;   2904  1	!	is received, it will process it and switch to STATE%RF.
;   2905  1	!	If a text-header is received it will switch to STATE%RD.
;   2906  1	!	If an ACK is received, it will type the data portion and
;   2907  1	!	switch to STATE%C.
;   2908  1	!
;   2909  1	! CALLING SEQUENCE:
;   2910  1	!
;   2911  1	!	STATE = SEND%GENCMD();
;   2912  1	!
;   2913  1	! INPUT PARAMETERS:
;   2914  1	!
;   2915  1	!	None.
;   2916  1	!
;   2917  1	! IMPLICIT INPUTS:
;   2918  1	!
;   2919  1	!	GEN%TYPE - Message type to send (normally MSG%GENERIC)
;   2920  1	!	GEN%SUBTYPE - Message subtype (only if MSG%GENERIC)
;   2921  1	!	GEN%1DATA - First argument string
;   2922  1	!	GEN%1SIZE - Size of first argument
;   2923  1	!	GEN%2DATA - Second argument string
;   2924  1	!	GEN%2SIZE - Size of second argument
;   2925  1	!	GEN%3DATA - Third argument string
;   2926  1	!	GEN%3SIZE - Size of third argument
;   2927  1	!
;   2928  1	! OUTPUT PARAMETERS:
;   2929  1	!
;   2930  1	!	New state for the finite state machine.
;   2931  1	!
;   2932  1	! IMPLICIT OUTPUTS:
;   2933  1	!
;   2934  1	!	None.
;   2935  1	!
;   2936  1	! COMPLETION CODES:
;   2937  1	!
;   2938  1	!	None.
;   2939  1	!
;   2940  1	! SIDE EFFECTS:
;   2941  1	!
;   2942  1	!	None.
;   2943  1	!
;   2944  1	!--
;   2945  1	
;   2946  2	    BEGIN
;   2947  2	
;   2948  2	    LOCAL
;   2949  2		POINTER,				! Pointer at DATA%TEXT
;   2950  2		DATA%TEXT : VECTOR [CH$ALLOCATION (MAX%MSG)],	! Data buffer
;   2951  2		DATA%SIZE,				! Length of data buffer used
;   2952  2		STATUS;					! Status returned by various routines
;   2953  2	
;   2954  2	    ROUTINE PACK%DATA (POINTER, LENGTH, SRC%ADDR, SRC%LEN) =
;   2955  2	!
;   2956  2	! Routine to pack an argument into the buffer.
;   2957  2	!
;   2958  3		BEGIN
;   2959  3	
;   2960  3		IF .SRC%LEN GTR MAX%MSG - .LENGTH - 1 THEN SRC%LEN = MAX%MSG - .LENGTH - 1;
;   2961  3	
;   2962  3		LENGTH = .LENGTH + .SRC%LEN + 1;
;   2963  3		CH$WCHAR%A (CHAR (.SRC%LEN), .POINTER);
;   2964  3		.POINTER = CH$MOVE (.SRC%LEN, CH$PTR (.SRC%ADDR), ..POINTER);
;   2965  3		RETURN .LENGTH;
;   2966  2		END;


; PACK%DATA
U.75:	MOVE	AC1,-3(SP)			; AC1,LENGTH									2960
	SUBI	AC1,137				; AC1,137
	MOVN	AC2,AC1				; AC2,AC1
	CAMGE	AC2,-1(SP)			; AC2,SRC%LEN
	MOVNM	AC1,-1(SP)			; AC1,SRC%LEN
	MOVE	AC1,-3(SP)			; AC1,LENGTH									2962
	ADD	AC1,-1(SP)			; AC1,SRC%LEN
	ADDI	AC1,1				; AC1,1
	MOVEM	AC1,-3(SP)			; AC1,LENGTH
	MOVE	AC2,-1(SP)			; AC2,SRC%LEN									2963
	ADDI	AC2,40				; AC2,40
	MOVE	AC1,-4(SP)			; AC1,POINTER
	IDPB	AC2,0(AC1)			; AC2,0(AC1)
	MOVE	AC3,-4(SP)			; AC3,POINTER									2964
	MOVE	AC1,-2(SP)			; AC1,SRC%ADDR
	MOVEI	AC2,-1(AC1)			; AC2,-1(AC1)
	HRLI	AC2,10700			; AC2,10700
	MOVE	AC1,-1(SP)			; AC1,SRC%LEN
	MOVE	AC4,-1(SP)			; AC4,SRC%LEN
	MOVE	AC5,0(AC3)			; AC5,0(AC3)
	EXTEND	AC1,C.9				; AC1,[MOVSLJ ]
	JFCL					;
	MOVEM	AC5,0(AC3)			; AC5,0(AC3)
	MOVE	AC1,-3(SP)			; AC1,LENGTH									2958
	POPJ	SP,				; SP,										2954

; Routine Size:  25 words


;   2967  2	!
;   2968  2	! First determine if we have exceed the number of retries that are
;   2969  2	! allowed to attempt to send this message.
;   2970  2	!
;   2971  2	
;   2972  2	    IF .NUM%RETRIES GTR .PKT%RETRIES THEN RETURN STATE%ER;
;   2973  2	
;   2974  2	!
;   2975  2	! The number of retries are not exceeded.  Increment the number and then
;   2976  2	! attempt to send the packet again.
;   2977  2	!
;   2978  2	    NUM%RETRIES = .NUM%RETRIES + 1;
;   2979  2	!
;   2980  2	! Build the packet data field
;   2981  2	!
;   2982  2	    POINTER = CH$PTR (DATA%TEXT);
;   2983  2	    DATA%SIZE = 0;
;   2984  2	
;   2985  2	    IF .GEN%TYPE EQL MSG%GENERIC
;   2986  2	    THEN
;   2987  3		BEGIN
;   2988  3		CH$WCHAR%A (.GEN%SUBTYPE, POINTER);
;   2989  3		DATA%SIZE = 1;
;   2990  3	
;   2991  3		IF .GEN%1SIZE GTR 0 OR .GEN%2SIZE GTR 0 OR .GEN%3SIZE GTR 0
;   2992  3		THEN
;   2993  4		    BEGIN
;   2994  4		    DATA%SIZE = PACK%DATA (POINTER, .DATA%SIZE, GEN%1DATA, .GEN%1SIZE);
;   2995  4	
;   2996  4		    IF .GEN%2SIZE GTR 0 OR .GEN%3SIZE GTR 0
;   2997  4		    THEN
;   2998  5			BEGIN
;   2999  5			DATA%SIZE = PACK%DATA (POINTER, .DATA%SIZE, GEN%2DATA, .GEN%2SIZE);
;   3000  5	
;   3001  5			IF .GEN%3SIZE GTR 0
;   3002  5			THEN
;   3003  6			    BEGIN
;   3004  6			    DATA%SIZE = PACK%DATA (POINTER, .DATA%SIZE, GEN%3DATA, .GEN%3SIZE);
;   3005  5			    END;
;   3006  5	
;   3007  4			END;
;   3008  4	
;   3009  3		    END;
;   3010  3	
;   3011  3		END
;   3012  2	    ELSE
;   3013  3		BEGIN
;   3014  3	
;   3015  3		IF .GEN%1SIZE GTR MAX%MSG THEN GEN%1SIZE = MAX%MSG;
;   3016  3	
;   3017  3		DATA%SIZE = .GEN%1SIZE;
;   3018  3		CH$MOVE (.GEN%1SIZE, CH$PTR (GEN%1DATA), .POINTER);
;   3019  2		END;
;   3020  2	
;   3021  2	    SET%STRING (CH$PTR (DATA%TEXT), .DATA%SIZE, TRUE);
;   3022  2	    BFR%FILL (TRUE);
;   3023  2	    SET%STRING (0, 0, FALSE);
;   3024  2	!
;   3025  2	! Send the packet
;   3026  2	!
;   3027  2	
;   3028  2	    IF NOT SEND%PACKET (.GEN%TYPE, .SIZE, .MSG%NUMBER) THEN RETURN STATE%EX;
;   3029  2	
;   3030  2	!
;   3031  2	! Now get the responce from the remote KERMIT.
;   3032  2	!
;   3033  2	    STATUS = REC%PACKET ();
;   3034  2	
;   3035  2	    IF NOT .STATUS
;   3036  2	    THEN
;   3037  3		BEGIN
;   3038  3	
;   3039  4		IF (.STATUS EQL KER%ZEROLENMSG) OR (.STATUS EQL KER%TIMEOUT) OR (.STATUS EQL KER%CHKSUMERR)
;   3040  3		THEN
;   3041  3		    RETURN .STATE
;   3042  3		ELSE
;   3043  3		    RETURN STATE%EX;
;   3044  3	
;   3045  2		END;
;   3046  2	
;   3047  2	! Did we get a send-init?
;   3048  2	
;   3049  2	    SELECTONE .REC%TYPE OF
;   3050  2		SET
;   3051  2	
;   3052  2		[MSG%SND%INIT] :
;   3053  3		    BEGIN
;   3054  3		    MSG%NUMBER = .REC%SEQ;		! Initialize sequence numbers
;   3055  3	! Determine if the parameters are ok.  If not, give up
;   3056  3	
;   3057  3		    IF NOT (STATUS = PRS%SEND%INIT ()) THEN RETURN .STATUS;
;   3058  3	
;   3059  3		    SET%SEND%INIT ();			! Set up our acknowledgement to the send-init
;   3060  3		    SEND%PACKET (MSG%ACK, P%SI%LENGTH, .MSG%NUMBER);	! Send it
;   3061  3		    BLK%CHK%TYPE = .INI%CHK%TYPE;	! Can now use agreed upon type
;   3062  3		    OLD%RETRIES = .NUM%RETRIES;
;   3063  3		    NUM%RETRIES = 0;
;   3064  3		    MSG%NUMBER = (.MSG%NUMBER + 1) AND %O'77';
;   3065  3		    RETURN STATE%RF;			! Now expect file header
;   3066  2		    END;
;   3067  2	
;   3068  2		[MSG%TEXT] :
;   3069  2	!
;   3070  2	! If we just got a text header, set up for typing on the terminal and
;   3071  2	! shift to receiving data
;   3072  2	!
;   3073  3		    BEGIN
;   3074  3		    TEXT%HEAD%FLAG = TRUE;		! We want terminal output
;   3075  3		    PUT%CHR%ROUTINE = TYPE%CHAR;	! Set up the put a character routine
;   3076  3	
;   3077  3		    IF .REC%LENGTH GTR 0
;   3078  3		    THEN
;   3079  4			BEGIN
;   3080  4			TT%TEXT (UPLIT (%ASCIZ'<<'));	! Make sure file name sticks out
;   3081  4			BFR%EMPTY ();			! Dump the packet data to the terminal
;   3082  4			TT%TEXT (UPLIT (%ASCIZ'>>'));	! So user can tell where name ends
;   3083  4			TT%CRLF ();			! And a CRLF
;   3084  3			END;
;   3085  3	
;   3086  3		    SEND%PACKET (MSG%ACK, 0, .MSG%NUMBER);	! Send an ACK
;   3087  3		    OLD%RETRIES = .NUM%RETRIES;
;   3088  3		    NUM%RETRIES = 0;
;   3089  3		    MSG%NUMBER = (.MSG%NUMBER + 1) AND %O'77';
;   3090  3		    RETURN STATE%RD;			! We now want data
;   3091  2		    END;
;   3092  2	
;   3093  2		[MSG%ACK] :
;   3094  2	!
;   3095  2	! If we get an ACK, just type the data on the terminal and complete the
;   3096  2	! transaction.
;   3097  2	!
;   3098  3		    BEGIN
;   3099  3		    PUT%CHR%ROUTINE = TYPE%CHAR;	! Dump to terminal
;   3100  3		    BFR%EMPTY ();			! Do it
;   3101  3	
;   3102  3		    IF .REC%LENGTH GTR 0 THEN TT%CRLF ();
;   3103  3	
;   3104  3		    RETURN STATE%C;			! And go idle
;   3105  2		    END;
;   3106  2	
;   3107  2		[MSG%NAK] :
;   3108  2	!
;   3109  2	! If we get a NAK, stay in the same state.  We will re-transmit the
;   3110  2	! packet again.
;   3111  2	!
;   3112  2		    RETURN .STATE;
;   3113  2		TES;
;   3114  2	
;   3115  2	!
;   3116  2	! If we get here, we didn't get anything resembling an acceptable
;   3117  2	! packet, so we will abort.
;   3118  2	!
;   3119  2	    KRM%ERROR (KER%PROTOERR);
;   3120  2	    RETURN STATE%A;
;   3121  1	    END;


P.AAG:	BYTE	(7)"<","<",000,000,000		; <<
P.AAH:	BYTE	(7)">",">",000,000,000		; >>


; SEND%GENCMD
U.6:	ADJSP	SP,25				; SP,25										2897
	MOVE	AC1,U.52			; AC1,NUM%RETRIES								2972
	CAMG	AC1,PKT%RETRIES			; AC1,PKT%RETRIES
	JRST	L.138				; L.138
	MOVEI	AC1,24				; AC1,24
	JRST	L.155				; L.155
L.138:	AOS	U.52				; NUM%RETRIES									2978
	MOVEI	AC1,-25(SP)			; AC1,DATA%TEXT-1								2982
	HRLI	AC1,10700			; AC1,10700
	MOVEM	AC1,0(SP)			; AC1,POINTER
	SETZ	AC3,				; DATA%SIZE,									2983
	MOVEI	AC1,107				; AC1,107									2985
	CAME	AC1,U.64			; AC1,GEN%TYPE
	JRST	L.143				; L.143
	MOVE	AC1,U.65			; AC1,GEN%SUBTYPE								2988
	IDPB	AC1,0(SP)			; AC1,POINTER
	MOVEI	AC3,1				; DATA%SIZE,1									2989
	MOVE	AC1,GEN%1SIZE			; AC1,GEN%1SIZE									2991
	JUMPG	AC1,L.139			; AC1,L.139
	SKIPLE	GEN%2SIZE			; GEN%2SIZE
	JRST	L.139				; L.139
	SKIPG	GEN%3SIZE			; GEN%3SIZE
	JRST	L.145				; L.145
L.139:	MOVEI	AC2,0(SP)			; AC2,POINTER									2994
	PUSH	SP,AC2				; SP,AC2
	PUSH	SP,AC3				; SP,DATA%SIZE
	PUSH	SP,C.40				; SP,[0,,GEN%1DATA]
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,U.75				; SP,PACK%DATA
	MOVE	AC3,AC1				; DATA%SIZE,AC1
	MOVE	AC1,GEN%2SIZE			; AC1,GEN%2SIZE									2996
	JUMPG	AC1,L.140			; AC1,L.140
	SKIPG	GEN%3SIZE			; GEN%3SIZE
	JRST	L.142				; L.142
L.140:	MOVEI	AC2,-4(SP)			; AC2,POINTER									2999
	PUSH	SP,AC2				; SP,AC2
	PUSH	SP,AC3				; SP,DATA%SIZE
	PUSH	SP,C.41				; SP,[0,,GEN%2DATA]
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,U.75				; SP,PACK%DATA
	MOVE	AC3,AC1				; DATA%SIZE,AC1
	MOVE	AC1,GEN%3SIZE			; AC1,GEN%3SIZE									3001
	JUMPLE	AC1,L.141			; AC1,L.141
	MOVEI	AC2,-10(SP)			; AC2,POINTER									3004
	PUSH	SP,AC2				; SP,AC2
	PUSH	SP,AC3				; SP,DATA%SIZE
	PUSH	SP,C.42				; SP,[0,,GEN%3DATA]
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,U.75				; SP,PACK%DATA
	MOVE	AC3,AC1				; DATA%SIZE,AC1
	ADJSP	SP,-4				; SP,-4										3003
L.141:	ADJSP	SP,-4				; SP,-4										2998
L.142:	ADJSP	SP,-4				; SP,-4										2993
	JRST	L.145				; L.145										2991
L.143:	MOVEI	AC1,140				; AC1,140									3015
	CAML	AC1,GEN%1SIZE			; AC1,GEN%1SIZE
	JRST	L.144				; L.144
	MOVEI	AC1,140				; AC1,140
	MOVEM	AC1,GEN%1SIZE			; AC1,GEN%1SIZE
L.144:	MOVE	AC3,GEN%1SIZE			; DATA%SIZE,GEN%1SIZE								3017
	MOVE	AC1,GEN%1SIZE			; AC1,GEN%1SIZE									3018
	MOVE	AC2,C.11			; AC2,[POINT 7,GEN%1DATA-1,34]  <1,7>
	MOVE	AC4,GEN%1SIZE			; AC4,GEN%1SIZE
	MOVE	AC5,0(SP)			; AC5,POINTER
	EXTEND	AC1,C.9				; AC1,[MOVSLJ ]
	JFCL					;
L.145:	MOVEI	AC1,-25(SP)			; AC1,DATA%TEXT-1								3021
	HRLI	AC1,10700			; AC1,10700
	PUSH	SP,AC1				; SP,AC1
	PUSH	SP,AC3				; SP,DATA%SIZE
	PUSH	SP,C.2				; SP,[1]
	PUSHJ	SP,U.30				; SP,SET%STRING
	PUSH	SP,C.2				; SP,[1]									3022
	PUSHJ	SP,U.29				; SP,BFR%FILL
	SETZM	-2(SP)				; -2(SP)									3023
	SETZM	-1(SP)				; -1(SP)
	SETZM	0(SP)				; 0(SP)
	PUSHJ	SP,U.30				; SP,SET%STRING
	PUSH	SP,U.64				; SP,GEN%TYPE									3028
	PUSH	SP,U.50				; SP,SIZE
	PUSH	SP,U.53				; SP,MSG%NUMBER
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	ADJSP	SP,-3				; SP,-3
	TRNE	AC1,1				; AC1,1
	JRST	L.146				; L.146
	ADJSP	SP,-4				; SP,-4
	MOVEI	AC1,23				; AC1,23
	JRST	L.155				; L.155
L.146:	PUSHJ	SP,U.26				; SP,REC%PACKET									3033
	TRNE	AC1,1				; STATUS,1									3035
	JRST	L.148				; L.148
	CAIE	AC1,262				; STATUS,262									3039
	CAIN	AC1,300				; STATUS,300
	JRST	L.147				; L.147
	CAIN	AC1,172				; STATUS,172
L.147:	SKIPA	AC2,U.49			; AC2,STATE									3043
	MOVEI	AC2,23				; AC2,23
	ADJSP	SP,-4				; SP,-4										3039
	MOVE	AC1,AC2				; AC1,AC2									3037
	JRST	L.155				; L.155
L.148:	MOVE	AC2,U.56			; AC2,REC%TYPE									3049
	CAIE	AC2,123				; AC2,123									3052
	JRST	L.150				; L.150
	MOVE	AC3,U.54			; AC3,REC%SEQ									3054
	MOVEM	AC3,U.53			; AC3,MSG%NUMBER
	PUSHJ	SP,U.21				; SP,PRS%SEND%INIT								3057
	TRNE	AC1,1				; STATUS,1
	JRST	L.149				; L.149
	ADJSP	SP,-4				; SP,-4
	JRST	L.155				; L.155
L.149:	PUSHJ	SP,U.20				; SP,SET%SEND%INIT								3059
	PUSH	SP,C.20				; SP,[131]									3060
	PUSH	SP,C.21				; SP,[11]
	PUSH	SP,U.53				; SP,MSG%NUMBER
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	MOVE	AC1,U.45			; AC1,INI%CHK%TYPE								3061
	MOVEM	AC1,U.46			; AC1,BLK%CHK%TYPE
	MOVE	AC1,U.52			; AC1,NUM%RETRIES								3062
	MOVEM	AC1,U.51			; AC1,OLD%RETRIES
	SETZM	U.52				; NUM%RETRIES									3063
	MOVE	AC1,U.53			; AC1,MSG%NUMBER								3064
	ADDI	AC1,1				; AC1,1
	LDB	AC2,C.18			; AC2,[POINT 6,AC1,35]  <0,6>
	MOVEM	AC2,U.53			; AC2,MSG%NUMBER
	ADJSP	SP,-7				; SP,-7										3065
	MOVEI	AC1,7				; AC1,7										3053
	JRST	L.155				; L.155
L.150:	CAIE	AC2,130				; AC2,130									3068
	JRST	L.152				; L.152
	MOVEI	AC1,1				; AC1,1										3074
	MOVEM	AC1,U.61			; AC1,TEXT%HEAD%FLAG
	MOVEI	AC1,U.31			; AC1,TYPE%CHAR									3075
	MOVEM	AC1,U.67			; AC1,PUT%CHR%ROUTINE
	SKIPG	U.55				; REC%LENGTH									3077
	JRST	L.151				; L.151
	PUSH	SP,C.43				; SP,[0,,P.AAG]									3080
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSHJ	SP,U.28				; SP,BFR%EMPTY									3081
	PUSH	SP,C.44				; SP,[0,,P.AAH]									3082
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSHJ	SP,TT%CRLF			; SP,TT%CRLF									3083
	ADJSP	SP,-2				; SP,-2										3079
L.151:	PUSH	SP,C.20				; SP,[131]									3086
	PUSH	SP,C.26				; SP,[0]
	PUSH	SP,U.53				; SP,MSG%NUMBER
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	MOVE	AC1,U.52			; AC1,NUM%RETRIES								3087
	MOVEM	AC1,U.51			; AC1,OLD%RETRIES
	SETZM	U.52				; NUM%RETRIES									3088
	MOVE	AC1,U.53			; AC1,MSG%NUMBER								3089
	ADDI	AC1,1				; AC1,1
	LDB	AC2,C.18			; AC2,[POINT 6,AC1,35]  <0,6>
	MOVEM	AC2,U.53			; AC2,MSG%NUMBER
	ADJSP	SP,-7				; SP,-7										3090
	MOVEI	AC1,10				; AC1,10									3073
	JRST	L.155				; L.155
L.152:	CAIE	AC2,131				; AC2,131									3093
	JRST	L.153				; L.153
	MOVEI	AC1,U.31			; AC1,TYPE%CHAR									3099
	MOVEM	AC1,U.67			; AC1,PUT%CHR%ROUTINE
	PUSHJ	SP,U.28				; SP,BFR%EMPTY									3100
	SKIPLE	U.55				; REC%LENGTH									3102
	PUSHJ	SP,TT%CRLF			; SP,TT%CRLF
	ADJSP	SP,-4				; SP,-4										3104
	MOVEI	AC1,11				; AC1,11									3098
	JRST	L.155				; L.155
L.153:	CAIE	AC2,116				; AC2,116									3107
	JRST	L.154				; L.154
	ADJSP	SP,-4				; SP,-4										3112
	MOVE	AC1,U.49			; AC1,STATE
	JRST	L.155				; L.155
L.154:	PUSH	SP,C.22				; SP,[252]									3119
	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
	ADJSP	SP,-5				; SP,-5										3120
	MOVEI	AC1,12				; AC1,12									2946
L.155:	ADJSP	SP,-25				; SP,-25									2897
	POPJ	SP,				; SP,
C.40:	XWD	0,GEN%1DATA			; 0,GEN%1DATA
C.41:	XWD	0,GEN%2DATA			; 0,GEN%2DATA
C.42:	XWD	0,GEN%3DATA			; 0,GEN%3DATA
C.43:	XWD	0,P.AAG				; 0,P.AAG
C.44:	XWD	0,P.AAH				; 0,P.AAH

; Routine Size:  182 words


;   3122  1	%SBTTL 'SEND%BREAK'
;   3123  1	ROUTINE SEND%BREAK =
;   3124  1	
;   3125  1	!++
;   3126  1	! FUNCTIONAL DESCRIPTION:
;   3127  1	!
;   3128  1	!	This routine will send the break (end of transmission) message
;   3129  1	!	to the remote KERMIT.  On an ACK the state becomes STATE%C.
;   3130  1	!
;   3131  1	! CALLING SEQUENCE:
;   3132  1	!
;   3133  1	!	STATE = SEND%BREAK();
;   3134  1	!
;   3135  1	! INPUT PARAMETERS:
;   3136  1	!
;   3137  1	!	None.
;   3138  1	!
;   3139  1	! IMPLICIT INPUTS:
;   3140  1	!
;   3141  1	!	None.
;   3142  1	!
;   3143  1	! OUTPUT PARAMETERS:
;   3144  1	!
;   3145  1	!	New state for the finite state machine.
;   3146  1	!
;   3147  1	! IMPLICIT OUTPUTS:
;   3148  1	!
;   3149  1	!	None.
;   3150  1	!
;   3151  1	! COMPLETION CODES:
;   3152  1	!
;   3153  1	!	None.
;   3154  1	!
;   3155  1	! SIDE EFFECTS:
;   3156  1	!
;   3157  1	!	None.
;   3158  1	!
;   3159  1	!--
;   3160  1	
;   3161  2	    BEGIN
;   3162  2	
;   3163  2	    LOCAL
;   3164  2		STATUS;					! Status returned by various routines
;   3165  2	
;   3166  2	!
;   3167  2	! First determine if we have exceed the number of retries that are
;   3168  2	! allowed to attempt to send this message.
;   3169  2	!
;   3170  2	
;   3171  2	    IF .NUM%RETRIES GTR .PKT%RETRIES THEN RETURN STATE%ER;
;   3172  2	
;   3173  2	!
;   3174  2	! The number of retries are not exceeded.  Increment the number and then
;   3175  2	! attempt to send the packet again.
;   3176  2	!
;   3177  2	    NUM%RETRIES = .NUM%RETRIES + 1;
;   3178  2	
;   3179  2	    IF NOT SEND%PACKET (MSG%BREAK, 0, .MSG%NUMBER) THEN RETURN STATE%EX;
;   3180  2	
;   3181  2	!
;   3182  2	! Now get the responce from the remote KERMIT.
;   3183  2	!
;   3184  2	    STATUS = REC%PACKET ();
;   3185  2	
;   3186  2	    IF NOT .STATUS
;   3187  2	    THEN
;   3188  3		BEGIN
;   3189  3	
;   3190  4		IF (.STATUS EQL KER%ZEROLENMSG) OR (.STATUS EQL KER%TIMEOUT) OR (.STATUS EQL KER%CHKSUMERR)
;   3191  3		THEN
;   3192  3		    RETURN .STATE
;   3193  3		ELSE
;   3194  3		    RETURN STATE%EX;
;   3195  3	
;   3196  2		END;
;   3197  2	
;   3198  2	!
;   3199  2	! Determine if the packet is good.
;   3200  2	!
;   3201  2	
;   3202  3	    IF NOT (.REC%TYPE EQL MSG%ACK OR .REC%TYPE EQL MSG%NAK)
;   3203  2	    THEN
;   3204  3		BEGIN
;   3205  3		KRM%ERROR (KER%PROTOERR);
;   3206  3		RETURN STATE%A;
;   3207  2		END;
;   3208  2	
;   3209  2	!
;   3210  2	! If this is a NAK and the message number is not the one we just send
;   3211  2	! treat this like an ACK, otherwise resend the last packet.
;   3212  2	!
;   3213  2	
;   3214  2	    IF .REC%TYPE EQL MSG%NAK AND .REC%SEQ NEQ 0 THEN RETURN .STATE;
;   3215  2	
;   3216  2	    IF .REC%TYPE EQL MSG%ACK AND .REC%SEQ NEQ .MSG%NUMBER THEN RETURN .STATE;
;   3217  2	
;   3218  2	!
;   3219  2	! Here to determine if there is another file to send.
;   3220  2	!
;   3221  2	    NUM%RETRIES = 0;
;   3222  2	    MSG%NUMBER = (.MSG%NUMBER + 1) AND %O'77';
;   3223  2	    RETURN STATE%C;
;   3224  1	    END;


; SEND%BREAK
U.9:	MOVE	AC1,U.52			; AC1,NUM%RETRIES								3171
	CAMG	AC1,PKT%RETRIES			; AC1,PKT%RETRIES
	JRST	L.156				; L.156
	MOVEI	AC1,24				; AC1,24
	POPJ	SP,				; SP,
L.156:	AOS	U.52				; NUM%RETRIES									3177
	PUSH	SP,C.45				; SP,[102]									3179
	PUSH	SP,C.26				; SP,[0]
	PUSH	SP,U.53				; SP,MSG%NUMBER
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	ADJSP	SP,-3				; SP,-3
	TRNN	AC1,1				; AC1,1
	JRST	L.157				; L.157
	PUSHJ	SP,U.26				; SP,REC%PACKET									3184
	TRNE	AC1,1				; STATUS,1									3186
	JRST	L.158				; L.158
	CAIE	AC1,262				; STATUS,262									3190
	CAIN	AC1,300				; STATUS,300
	JRST	L.161				; L.161
	CAIN	AC1,172				; STATUS,172
	JRST	L.161				; L.161										3192
L.157:	MOVEI	AC1,23				; AC1,23									3194
	POPJ	SP,				; SP,										3188
L.158:	MOVE	AC1,U.56			; AC1,REC%TYPE									3202
	CAIE	AC1,131				; AC1,131
	CAIN	AC1,116				; AC1,116
	JRST	L.159				; L.159
	PUSH	SP,C.22				; SP,[252]									3205
	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
	ADJSP	SP,-1				; SP,-1										3206
	MOVEI	AC1,12				; AC1,12									3204
	POPJ	SP,				; SP,
L.159:	MOVE	AC1,U.56			; AC1,REC%TYPE									3214
	CAIN	AC1,116				; AC1,116
	SKIPN	U.54				; REC%SEQ
	JRST	L.160				; L.160
	JRST	L.161				; L.161
L.160:	CAIE	AC1,131				; AC1,131									3216
	JRST	L.162				; L.162
	MOVE	AC1,U.54			; AC1,REC%SEQ
	CAMN	AC1,U.53			; AC1,MSG%NUMBER
	JRST	L.162				; L.162
L.161:	MOVE	AC1,U.49			; AC1,STATE
	POPJ	SP,				; SP,
L.162:	SETZM	U.52				; NUM%RETRIES									3221
	MOVE	AC1,U.53			; AC1,MSG%NUMBER								3222
	ADDI	AC1,1				; AC1,1
	LDB	AC2,C.18			; AC2,[POINT 6,AC1,35]  <0,6>
	MOVEM	AC2,U.53			; AC2,MSG%NUMBER
	MOVEI	AC1,11				; AC1,11									3161
	POPJ	SP,				; SP,										3123
C.45:	EXP	102				; 102

; Routine Size:  52 words


;   3225  1	%SBTTL 'REC%INIT'
;   3226  1	ROUTINE REC%INIT =
;   3227  1	
;   3228  1	!++
;   3229  1	! FUNCTIONAL DESCRIPTION:
;   3230  1	!
;   3231  1	!	This routine will process an initialization message received from
;   3232  1	!	the remote KERMIT.
;   3233  1	!
;   3234  1	! CALLING SEQUENCE:
;   3235  1	!
;   3236  1	!	STATE = REC%INIT();
;   3237  1	!
;   3238  1	! INPUT PARAMETERS:
;   3239  1	!
;   3240  1	!	None.
;   3241  1	!
;   3242  1	! IMPLICIT INPUTS:
;   3243  1	!
;   3244  1	!	None.
;   3245  1	!
;   3246  1	! OUTPUT PARAMETERS:
;   3247  1	!
;   3248  1	!	New machine state.
;   3249  1	!
;   3250  1	! IMPLICIT OUTPUTS:
;   3251  1	!
;   3252  1	!	None.
;   3253  1	!
;   3254  1	! COMPLETION CODES:
;   3255  1	!
;   3256  1	!	None.
;   3257  1	!
;   3258  1	! SIDE EFFECTS:
;   3259  1	!
;   3260  1	!	None.
;   3261  1	!
;   3262  1	!--
;   3263  1	
;   3264  2	    BEGIN
;   3265  2	
;   3266  2	    LOCAL
;   3267  2		STATUS;					! Status returned by various routines
;   3268  2	
;   3269  2	    ROUTINE CHECK%INIT =
;   3270  3		BEGIN
;   3271  3	
;   3272  3		IF .REC%TYPE EQL MSG%SND%INIT THEN RETURN TRUE ELSE RETURN FALSE;
;   3273  3	
;   3274  2		END;


; CHECK%INIT
U.76:	MOVEI	AC1,123				; AC1,123									3272
	CAME	AC1,U.56			; AC1,REC%TYPE
	JRST	L.163				; L.163
	MOVEI	AC1,1				; AC1,1
	POPJ	SP,				; SP,
L.163:	SETZ	AC1,				; AC1,
	POPJ	SP,				; SP,										3269

; Routine Size:  7 words


;   3275  2	
;   3276  3	    IF NOT (STATUS = REC%MESSAGE (CHECK%INIT))
;   3277  2	    THEN
;   3278  2	
;   3279  2		IF .STATUS NEQ KER%ABORTED THEN RETURN STATE%A ELSE RETURN STATE%EX;
;   3280  2	
;   3281  2	    MSG%NUMBER = .REC%SEQ;
;   3282  2	
;   3283  2	    IF NOT (STATUS = PRS%SEND%INIT ()) THEN RETURN STATE%A;
;   3284  2	
;   3285  2	    SET%SEND%INIT ();
;   3286  2	    SEND%PACKET (MSG%ACK, P%SI%LENGTH, .MSG%NUMBER);
;   3287  2	    BLK%CHK%TYPE = .INI%CHK%TYPE;		! Can now use agreed upon type
;   3288  2	    OLD%RETRIES = .NUM%RETRIES;
;   3289  2	    NUM%RETRIES = 0;
;   3290  2	    MSG%NUMBER = (.MSG%NUMBER + 1) AND %O'77';
;   3291  2	    RETURN STATE%RF;
;   3292  1	    END;					! End of REC%INIT


; REC%INIT
U.11:	PUSH	SP,C.46				; SP,[0,,CHECK%INIT]								3276
	PUSHJ	SP,U.25				; SP,REC%MESSAGE
	ADJSP	SP,-1				; SP,-1
	TRNE	AC1,1				; STATUS,1
	JRST	L.166				; L.166
	CAIN	AC1,312				; STATUS,312									3279
	JRST	L.164				; L.164
	MOVEI	AC2,12				; AC2,12
	JRST	L.165				; L.165
L.164:	MOVEI	AC2,23				; AC2,23
L.165:	MOVE	AC1,AC2				; AC1,AC2
	POPJ	SP,				; SP,
L.166:	MOVE	AC2,U.54			; AC2,REC%SEQ									3281
	MOVEM	AC2,U.53			; AC2,MSG%NUMBER
	PUSHJ	SP,U.21				; SP,PRS%SEND%INIT								3283
	TRNE	AC1,1				; STATUS,1
	JRST	L.167				; L.167
	MOVEI	AC1,12				; AC1,12
	POPJ	SP,				; SP,
L.167:	PUSHJ	SP,U.20				; SP,SET%SEND%INIT								3285
	PUSH	SP,C.20				; SP,[131]									3286
	PUSH	SP,C.21				; SP,[11]
	PUSH	SP,U.53				; SP,MSG%NUMBER
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	MOVE	AC1,U.45			; AC1,INI%CHK%TYPE								3287
	MOVEM	AC1,U.46			; AC1,BLK%CHK%TYPE
	MOVE	AC1,U.52			; AC1,NUM%RETRIES								3288
	MOVEM	AC1,U.51			; AC1,OLD%RETRIES
	SETZM	U.52				; NUM%RETRIES									3289
	MOVE	AC1,U.53			; AC1,MSG%NUMBER								3290
	ADDI	AC1,1				; AC1,1
	LDB	AC2,C.18			; AC2,[POINT 6,AC1,35]  <0,6>
	MOVEM	AC2,U.53			; AC2,MSG%NUMBER
	ADJSP	SP,-3				; SP,-3										3291
	MOVEI	AC1,7				; AC1,7										3264
	POPJ	SP,				; SP,										3226
C.46:	XWD	0,U.76				; 0,CHECK%INIT

; Routine Size:  37 words


;   3293  1	%SBTTL 'REC%FILE'
;   3294  1	ROUTINE REC%FILE =
;   3295  1	
;   3296  1	!++
;   3297  1	! FUNCTIONAL DESCRIPTION:
;   3298  1	!
;   3299  1	!	This routine expects to receive an MSG%FILE packet from the remote
;   3300  1	!	KERMIT.  If the message is correct this routine will change the state
;   3301  1	!	to STATE%RD.
;   3302  1	!
;   3303  1	!	This routine also expects MSG%SND%INIT, MSG%EOF, or MSG%BREAK.
;   3304  1	!
;   3305  1	! CALLING SEQUENCE:
;   3306  1	!
;   3307  1	!	STATE = REC%FILE();
;   3308  1	!
;   3309  1	! INPUT PARAMETERS:
;   3310  1	!
;   3311  1	!	None.
;   3312  1	!
;   3313  1	! IMPLICIT INPUTS:
;   3314  1	!
;   3315  1	!	None.
;   3316  1	!
;   3317  1	! OUTPUT PARAMETERS:
;   3318  1	!
;   3319  1	!	New state.
;   3320  1	!
;   3321  1	! IMPLICIT OUTPUTS:
;   3322  1	!
;   3323  1	!	None.
;   3324  1	!
;   3325  1	! COMPLETION CODES:
;   3326  1	!
;   3327  1	!	None.
;   3328  1	!
;   3329  1	! SIDE EFFECTS:
;   3330  1	!
;   3331  1	!	None.
;   3332  1	!
;   3333  1	!--
;   3334  1	
;   3335  2	    BEGIN
;   3336  2	
;   3337  2	    LOCAL
;   3338  2		STATUS;
;   3339  2	
;   3340  2	    ROUTINE CHECK%FILE =
;   3341  3		BEGIN
;   3342  3	
;   3343  4		IF (.REC%TYPE EQL MSG%SND%INIT) OR (.REC%TYPE EQL MSG%EOF) OR (.REC%TYPE EQL MSG%FILE) OR (
;   3344  4		    .REC%TYPE EQL MSG%BREAK) OR (.REC%TYPE EQL MSG%TEXT)
;   3345  3		THEN
;   3346  3		    RETURN TRUE
;   3347  3		ELSE
;   3348  3		    RETURN FALSE;
;   3349  3	
;   3350  2		END;


; CHECK%FILE
U.77:	MOVE	AC1,U.56			; AC1,REC%TYPE									3343
	CAIE	AC1,123				; AC1,123
	CAIN	AC1,132				; AC1,132
	JRST	L.168				; L.168
	CAIE	AC1,106				; AC1,106
	CAIN	AC1,102				; AC1,102
	JRST	L.168				; L.168
	CAIE	AC1,130				; AC1,130									3344
	JRST	L.169				; L.169
L.168:	MOVEI	AC1,1				; AC1,1										3348
	POPJ	SP,				; SP,
L.169:	SETZ	AC1,				; AC1,
	POPJ	SP,				; SP,										3340

; Routine Size:  13 words


;   3351  2	!
;   3352  2	! Initialize the abort flags
;   3353  2	!
;   3354  2	    ABT%CUR%FILE = FALSE;
;   3355  2	    ABT%ALL%FILE = FALSE;
;   3356  2	!
;   3357  2	! Get a message
;   3358  2	!
;   3359  2	
;   3360  3	    IF NOT (STATUS = REC%MESSAGE (CHECK%FILE))
;   3361  2	    THEN
;   3362  2	
;   3363  2		IF .STATUS NEQ KER%ABORTED THEN RETURN STATE%A ELSE RETURN STATE%EX;
;   3364  2	
;   3365  2	    SELECTONE .REC%TYPE OF
;   3366  2		SET
;   3367  2	
;   3368  2		[MSG%SND%INIT] :
;   3369  3		    BEGIN
;   3370  3	
;   3371  3		    IF .OLD%RETRIES GTR .SI%RETRIES THEN RETURN STATE%ER;
;   3372  3	
;   3373  3		    OLD%RETRIES = .OLD%RETRIES + 1;
;   3374  3	
;   3375  3		    IF ((.MSG%NUMBER - 1) AND %O'77') EQL .REC%SEQ
;   3376  3		    THEN
;   3377  4			BEGIN
;   3378  4			SET%SEND%INIT ();
;   3379  4			BLK%CHK%TYPE = CHK%1CHAR;	! Must use 1 character CHKSUM
;   3380  4			SEND%PACKET (MSG%ACK, P%SI%LENGTH, .REC%SEQ);
;   3381  4			BLK%CHK%TYPE = .INI%CHK%TYPE;	! Back to agreed upon type
;   3382  4			NUM%RETRIES = 0;
;   3383  4			RETURN .STATE;
;   3384  4			END
;   3385  3		    ELSE
;   3386  4			BEGIN
;   3387  4			KRM%ERROR (KER%PROTOERR);
;   3388  4			RETURN STATE%A;
;   3389  3			END;
;   3390  3	
;   3391  2		    END;
;   3392  2	
;   3393  2		[MSG%EOF] :
;   3394  3		    BEGIN
;   3395  3	
;   3396  3		    IF .OLD%RETRIES GTR .PKT%RETRIES THEN RETURN STATE%ER;
;   3397  3	
;   3398  3		    OLD%RETRIES = .OLD%RETRIES + 1;
;   3399  3	
;   3400  3		    IF ((.MSG%NUMBER - 1) AND %O'77') EQL .REC%SEQ
;   3401  3		    THEN
;   3402  4			BEGIN
;   3403  4			SEND%PACKET (MSG%ACK, 0, .REC%SEQ);
;   3404  4			NUM%RETRIES = 0;
;   3405  4			RETURN .STATE;
;   3406  4			END
;   3407  3		    ELSE
;   3408  4			BEGIN
;   3409  4			KRM%ERROR (KER%PROTOERR);
;   3410  4			RETURN STATE%A;
;   3411  3			END;
;   3412  3	
;   3413  2		    END;
;   3414  2	
;   3415  2		[MSG%FILE] :
;   3416  3		    BEGIN
;   3417  3	
;   3418  3		    IF .MSG%NUMBER NEQ .REC%SEQ THEN RETURN STATE%ER;
;   3419  3	
;   3420  3		    IF .REC%LENGTH EQL 0
;   3421  3		    THEN
;   3422  4			BEGIN
;   3423  4			KRM%ERROR (KER%PROTOERR);
;   3424  4			RETURN STATE%A;
;   3425  3			END;
;   3426  3	
;   3427  3	![025]
;   3428  3	![025] Get file name from packet with all quoting undone
;   3429  3	![025]
;   3430  3		    SET%STRING (CH$PTR (FILE%NAME), MAX%FILE%NAME, TRUE);
;   3431  3		    BFR%EMPTY ();
;   3432  3		    FILE%SIZE = SET%STRING (0, 0, FALSE);
;   3433  3		    CH$WCHAR (CHR%NUL, CH$PTR (FILE%NAME, .FILE%SIZE));
;   3434  3	![025]	    FILE%SIZE = .REC%LENGTH;
;   3435  3	![025]	    CH$COPY (.REC%LENGTH, CH$PTR (REC%MSG, PKT%MSG, CHR%SIZE), CHR%NUL, MAX%FILE%NAME,
;   3436  3	![025]		CH$PTR (FILE%NAME));
;   3437  3	
;   3438  3		    IF ( NOT .CONNECT%FLAG) AND .TY%FIL
;   3439  3		    THEN
;   3440  4			BEGIN
;   3441  4			TT%TEXT (UPLIT (%ASCIZ'Receiving: '));
;   3442  4			TT%TEXT (FILE%NAME);
;   3443  4			TT%OUTPUT ();
;   3444  3			END;
;   3445  3	
;   3446  3	![023]
;   3447  3	![023] Force file name into normal form if desired
;   3448  3	![023]
;   3449  3	
;   3450  3		    IF .FIL%NORMAL%FORM THEN NORMALIZE%FILE (FILE%NAME, FILE%SIZE, 9, 3);
;   3451  3	
;   3452  3		    FILE%CHARS = 0;			! No characters received yet
;   3453  3	
;   3454  3		    IF NOT FILE%OPEN (FNC%WRITE) THEN RETURN STATE%A;
;   3455  3	
;   3456  3		    XFR%STATUS (%C'F', %C'R');		! Tell display routine
;   3457  3		    TEXT%HEAD%FLAG = FALSE;		! Got an F, not an X
;   3458  3		    FILE%OPEN%FLAG = TRUE;
;   3459  3		    SEND%PACKET (MSG%ACK, 0, .MSG%NUMBER);
;   3460  3		    OLD%RETRIES = .NUM%RETRIES;
;   3461  3		    NUM%RETRIES = 0;
;   3462  3		    MSG%NUMBER = (.MSG%NUMBER + 1) AND %O'77';
;   3463  3		    RETURN STATE%RD;
;   3464  2		    END;
;   3465  2	
;   3466  2		[MSG%TEXT] :
;   3467  2	!
;   3468  2	! If we get a text header, we will want to type the data on
;   3469  2	! the terminal.  Set up the put a character routine correctly.
;   3470  2	!
;   3471  3		    BEGIN
;   3472  3	
;   3473  3		    IF .MSG%NUMBER NEQ .REC%SEQ
;   3474  3		    THEN
;   3475  4			BEGIN
;   3476  4			KRM%ERROR (KER%PROTOERR);
;   3477  4			RETURN STATE%A;
;   3478  3			END;
;   3479  3	
;   3480  3		    TEXT%HEAD%FLAG = TRUE;		! Got an X, not an F
;   3481  3		    PUT%CHR%ROUTINE = TYPE%CHAR;	! Empty buffer on terminal
;   3482  3	
;   3483  3		    IF .REC%LENGTH GTR 0
;   3484  3		    THEN
;   3485  4			BEGIN
;   3486  4			TT%TEXT (UPLIT (%ASCIZ'<<'));	! Make file name stick out
;   3487  4			BFR%EMPTY ();			! Do the header data
;   3488  4			TT%TEXT (UPLIT (%ASCIZ'>>'));
;   3489  4			TT%CRLF ();			! And a crlf
;   3490  3			END;
;   3491  3	
;   3492  3		    SEND%PACKET (MSG%ACK, 0, .MSG%NUMBER);
;   3493  3		    OLD%RETRIES = .NUM%RETRIES;
;   3494  3		    NUM%RETRIES = 0;
;   3495  3		    MSG%NUMBER = (.MSG%NUMBER + 1) AND %O'77';
;   3496  3		    RETURN STATE%RD;
;   3497  2		    END;
;   3498  2	
;   3499  2		[MSG%BREAK] :
;   3500  3		    BEGIN
;   3501  3	
;   3502  3		    IF .MSG%NUMBER NEQ .REC%SEQ
;   3503  3		    THEN
;   3504  4			BEGIN
;   3505  4			KRM%ERROR (KER%PROTOERR);
;   3506  4			RETURN STATE%A;
;   3507  3			END;
;   3508  3	
;   3509  3		    SEND%PACKET (MSG%ACK, 0, .REC%SEQ);
;   3510  3		    RETURN STATE%C;
;   3511  2		    END;
;   3512  2	
;   3513  2		[OTHERWISE] :
;   3514  3		    BEGIN
;   3515  3		    KRM%ERROR (KER%PROTOERR);
;   3516  3		    RETURN STATE%A;
;   3517  2		    END;
;   3518  2		TES;
;   3519  2	
;   3520  1	    END;					! End of REC%FILE


P.AAI:	BYTE	(7)"R","e","c","e","i"		; Recei
	BYTE	(7)"v","i","n","g",":"		; ving:
	BYTE	(7)" ",000,000,000,000
P.AAJ:	BYTE	(7)"<","<",000,000,000		; <<
P.AAK:	BYTE	(7)">",">",000,000,000		; >>


; REC%FILE
U.12:	SETZM	ABT%CUR%FILE			; ABT%CUR%FILE									3354
	SETZM	ABT%ALL%FILE			; ABT%ALL%FILE									3355
	PUSH	SP,C.47				; SP,[0,,CHECK%FILE]								3360
	PUSHJ	SP,U.25				; SP,REC%MESSAGE
	ADJSP	SP,-1				; SP,-1
	TRNE	AC1,1				; STATUS,1
	JRST	L.170				; L.170
	CAIE	AC1,312				; STATUS,312									3363
	JRST	L.184				; L.184
	MOVEI	AC1,23				; AC1,23
	POPJ	SP,				; SP,
L.170:	MOVE	AC1,U.56			; AC1,REC%TYPE									3365
	CAIE	AC1,123				; AC1,123									3368
	JRST	L.171				; L.171
	MOVE	AC2,U.51			; AC2,OLD%RETRIES								3371
	CAMLE	AC2,SI%RETRIES			; AC2,SI%RETRIES
	JRST	L.174				; L.174
	AOS	U.51				; OLD%RETRIES									3373
	MOVE	AC1,U.53			; AC1,MSG%NUMBER								3375
	SUBI	AC1,1				; AC1,1
	LDB	AC2,C.18			; AC2,[POINT 6,AC1,35]  <0,6>
	CAME	AC2,U.54			; AC2,REC%SEQ
	JRST	L.186				; L.186
	PUSHJ	SP,U.20				; SP,SET%SEND%INIT								3378
	MOVEI	AC1,61				; AC1,61									3379
	MOVEM	AC1,U.46			; AC1,BLK%CHK%TYPE
	PUSH	SP,C.20				; SP,[131]									3380
	PUSH	SP,C.21				; SP,[11]
	PUSH	SP,U.54				; SP,REC%SEQ
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	MOVE	AC1,U.45			; AC1,INI%CHK%TYPE								3381
	MOVEM	AC1,U.46			; AC1,BLK%CHK%TYPE
	JRST	L.172				; L.172
L.171:	CAIE	AC1,132				; AC1,132									3393
	JRST	L.173				; L.173
	MOVE	AC2,U.51			; AC2,OLD%RETRIES								3396
	CAMLE	AC2,PKT%RETRIES			; AC2,PKT%RETRIES
	JRST	L.174				; L.174
	AOS	U.51				; OLD%RETRIES									3398
	MOVE	AC1,U.53			; AC1,MSG%NUMBER								3400
	SUBI	AC1,1				; AC1,1
	LDB	AC2,C.18			; AC2,[POINT 6,AC1,35]  <0,6>
	CAME	AC2,U.54			; AC2,REC%SEQ
	JRST	L.186				; L.186
	PUSH	SP,C.20				; SP,[131]									3403
	PUSH	SP,C.26				; SP,[0]
	PUSH	SP,U.54				; SP,REC%SEQ
	PUSHJ	SP,U.24				; SP,SEND%PACKET
L.172:	SETZM	U.52				; NUM%RETRIES									3404
	ADJSP	SP,-2				; SP,-2										3402
	MOVE	AC1,U.49			; AC1,STATE									3408
	JRST	L.187				; L.187
L.173:	CAIE	AC1,106				; AC1,106									3415
	JRST	L.179				; L.179
	MOVE	AC2,U.53			; AC2,MSG%NUMBER								3418
	CAMN	AC2,U.54			; AC2,REC%SEQ
	JRST	L.175				; L.175
L.174:	MOVEI	AC1,24				; AC1,24
	POPJ	SP,				; SP,
L.175:	SKIPN	U.55				; REC%LENGTH									3420
	JRST	L.183				; L.183
	PUSH	SP,C.10				; SP,[POINT 7,FILE%NAME-1,34]  <1,7>						3430
	PUSH	SP,C.23				; SP,[204]
	PUSH	SP,C.2				; SP,[1]
	PUSHJ	SP,U.30				; SP,SET%STRING
	PUSHJ	SP,U.28				; SP,BFR%EMPTY									3431
	SETZM	-2(SP)				; -2(SP)									3432
	SETZM	-1(SP)				; -1(SP)
	SETZM	0(SP)				; 0(SP)
	PUSHJ	SP,U.30				; SP,SET%STRING
	MOVEM	AC1,FILE%SIZE			; AC1,FILE%SIZE
	SETZ	AC2,				; AC2,										3433
	MOVE	AC3,C.19			; AC3,[POINT 7,FILE%NAME,-1]  <36,7>
	MOVE	AC1,FILE%SIZE			; AC1,FILE%SIZE
	ADJBP	AC1,AC3				; AC1,AC3
	IDPB	AC2,AC1				; AC2,AC1
	MOVEI	AC1,1				; AC1,1										3438
	TDNE	AC1,CONNECT%FLAG		; AC1,CONNECT%FLAG
	JRST	L.176				; L.176
	MOVEI	AC1,1				; AC1,1
	TDNN	AC1,TY%FIL			; AC1,TY%FIL
	JRST	L.176				; L.176
	PUSH	SP,C.48				; SP,[0,,P.AAI]									3441
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSH	SP,C.35				; SP,[0,,FILE%NAME]								3442
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSHJ	SP,TT%OUTPUT			; SP,TT%OUTPUT									3443
	ADJSP	SP,-2				; SP,-2										3440
L.176:	MOVEI	AC1,1				; AC1,1										3450
	TDNN	AC1,FIL%NORMAL%FORM		; AC1,FIL%NORMAL%FORM
	JRST	L.177				; L.177
	PUSH	SP,C.35				; SP,[0,,FILE%NAME]
	PUSH	SP,C.36				; SP,[0,,FILE%SIZE]
	PUSH	SP,C.21				; SP,[11]
	PUSH	SP,C.49				; SP,[3]
	PUSHJ	SP,U.27				; SP,NORMALIZE%FILE
	ADJSP	SP,-4				; SP,-4
L.177:	SETZM	U.60				; FILE%CHARS									3452
	PUSH	SP,C.2				; SP,[1]									3454
	PUSHJ	SP,FILE%OPEN			; SP,FILE%OPEN
	ADJSP	SP,-1				; SP,-1
	TRNE	AC1,1				; AC1,1
	JRST	L.178				; L.178
	ADJSP	SP,-3				; SP,-3
	JRST	L.184				; L.184
L.178:	PUSH	SP,C.15				; SP,[106]									3456
	PUSH	SP,C.12				; SP,[122]
	PUSHJ	SP,XFR%STATUS			; SP,XFR%STATUS
	SETZM	U.61				; TEXT%HEAD%FLAG								3457
	MOVEI	AC1,1				; AC1,1										3458
	MOVEM	AC1,U.59			; AC1,FILE%OPEN%FLAG
	PUSH	SP,C.20				; SP,[131]									3459
	PUSH	SP,C.26				; SP,[0]
	PUSH	SP,U.53				; SP,MSG%NUMBER
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	MOVE	AC1,U.52			; AC1,NUM%RETRIES								3460
	MOVEM	AC1,U.51			; AC1,OLD%RETRIES
	SETZM	U.52				; NUM%RETRIES									3461
	MOVE	AC1,U.53			; AC1,MSG%NUMBER								3462
	ADDI	AC1,1				; AC1,1
	LDB	AC2,C.18			; AC2,[POINT 6,AC1,35]  <0,6>
	MOVEM	AC2,U.53			; AC2,MSG%NUMBER
	ADJSP	SP,-7				; SP,-7										3416
	JRST	L.181				; L.181
L.179:	CAIE	AC1,130				; AC1,130									3466
	JRST	L.182				; L.182
	MOVE	AC1,U.53			; AC1,MSG%NUMBER								3473
	CAME	AC1,U.54			; AC1,REC%SEQ
	JRST	L.183				; L.183
	MOVEI	AC1,1				; AC1,1										3480
	MOVEM	AC1,U.61			; AC1,TEXT%HEAD%FLAG
	MOVEI	AC1,U.31			; AC1,TYPE%CHAR									3481
	MOVEM	AC1,U.67			; AC1,PUT%CHR%ROUTINE
	SKIPG	U.55				; REC%LENGTH									3483
	JRST	L.180				; L.180
	PUSH	SP,C.50				; SP,[0,,P.AAJ]									3486
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSHJ	SP,U.28				; SP,BFR%EMPTY									3487
	PUSH	SP,C.51				; SP,[0,,P.AAK]									3488
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSHJ	SP,TT%CRLF			; SP,TT%CRLF									3489
	ADJSP	SP,-2				; SP,-2										3485
L.180:	PUSH	SP,C.20				; SP,[131]									3492
	PUSH	SP,C.26				; SP,[0]
	PUSH	SP,U.53				; SP,MSG%NUMBER
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	MOVE	AC1,U.52			; AC1,NUM%RETRIES								3493
	MOVEM	AC1,U.51			; AC1,OLD%RETRIES
	SETZM	U.52				; NUM%RETRIES									3494
	MOVE	AC1,U.53			; AC1,MSG%NUMBER								3495
	ADDI	AC1,1				; AC1,1
	LDB	AC2,C.18			; AC2,[POINT 6,AC1,35]  <0,6>
	MOVEM	AC2,U.53			; AC2,MSG%NUMBER
	ADJSP	SP,-2				; SP,-2										3471
L.181:	MOVEI	AC1,10				; AC1,10									3365
	JRST	L.187				; L.187
L.182:	CAIE	AC1,102				; AC1,102									3499
	JRST	L.186				; L.186
	MOVE	AC1,U.53			; AC1,MSG%NUMBER								3502
	CAMN	AC1,U.54			; AC1,REC%SEQ
	JRST	L.185				; L.185
L.183:	PUSH	SP,C.22				; SP,[252]									3505
	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
	ADJSP	SP,-1				; SP,-1										3506
L.184:	MOVEI	AC1,12				; AC1,12									3504
	POPJ	SP,				; SP,
L.185:	PUSH	SP,C.20				; SP,[131]									3509
	PUSH	SP,C.26				; SP,[0]
	PUSH	SP,U.54				; SP,REC%SEQ
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	ADJSP	SP,-2				; SP,-2										3500
	MOVEI	AC1,11				; AC1,11									3365
	JRST	L.187				; L.187
L.186:	PUSH	SP,C.22				; SP,[252]									3515
	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
	MOVEI	AC1,12				; AC1,12									3365
L.187:	ADJSP	SP,-1				; SP,-1										3514
	POPJ	SP,				; SP,										3294
C.47:	XWD	0,U.77				; 0,CHECK%FILE
C.48:	XWD	0,P.AAI				; 0,P.AAI
C.49:	EXP	3				; 3
C.50:	XWD	0,P.AAJ				; 0,P.AAJ
C.51:	XWD	0,P.AAK				; 0,P.AAK

; Routine Size:  183 words


;   3521  1	%SBTTL 'REC%DATA'
;   3522  1	ROUTINE REC%DATA =
;   3523  1	
;   3524  1	!++
;   3525  1	! FUNCTIONAL DESCRIPTION:
;   3526  1	!
;   3527  1	! This routine will accept data messages and write them to disk.
;   3528  1	! It will also accept MSG%FILE, MSG%TEXT and MSG%EOF messages.
;   3529  1	!
;   3530  1	! CALLING SEQUENCE:
;   3531  1	!
;   3532  1	!	STATE = REC%DATA();
;   3533  1	!
;   3534  1	! INPUT PARAMETERS:
;   3535  1	!
;   3536  1	!	None.
;   3537  1	!
;   3538  1	! IMPLICIT INPUTS:
;   3539  1	!
;   3540  1	!	None.
;   3541  1	!
;   3542  1	! OUTPUT PARAMETERS:
;   3543  1	!
;   3544  1	!	New state for the finite state machine.
;   3545  1	!
;   3546  1	! IMPLICIT OUTPUTS:
;   3547  1	!
;   3548  1	!	None.
;   3549  1	!
;   3550  1	! COMPLETION CODES:
;   3551  1	!
;   3552  1	!	None.
;   3553  1	!
;   3554  1	! SIDE EFFECTS:
;   3555  1	!
;   3556  1	!	None.
;   3557  1	!
;   3558  1	!--
;   3559  1	
;   3560  2	    BEGIN
;   3561  2	
;   3562  2	    LOCAL
;   3563  2		STATUS;
;   3564  2	
;   3565  2	    ROUTINE CHECK%DATA =
;   3566  3		BEGIN
;   3567  3	
;   3568  3		IF .REC%TYPE EQL MSG%DATA OR (.REC%TYPE EQL MSG%FILE AND NOT .TEXT%HEAD%FLAG) OR .REC%TYPE
;   3569  4		    EQL MSG%EOF OR (.REC%TYPE EQL MSG%TEXT AND .TEXT%HEAD%FLAG)
;   3570  3		THEN
;   3571  3		    RETURN TRUE
;   3572  3		ELSE
;   3573  3		    RETURN FALSE;
;   3574  3	
;   3575  2		END;


; CHECK%DATA
U.78:	MOVE	AC1,U.56			; AC1,REC%TYPE									3568
	CAIN	AC1,104				; AC1,104
	JRST	L.189				; L.189
	CAIE	AC1,106				; AC1,106
	JRST	L.188				; L.188
	MOVEI	AC2,1				; AC2,1
	TDNN	AC2,U.61			; AC2,TEXT%HEAD%FLAG
	JRST	L.189				; L.189
L.188:	CAIN	AC1,132				; AC1,132									3569
	JRST	L.189				; L.189
	CAIE	AC1,130				; AC1,130
	JRST	L.190				; L.190
	MOVEI	AC1,1				; AC1,1
	TDNN	AC1,U.61			; AC1,TEXT%HEAD%FLAG
	JRST	L.190				; L.190
L.189:	MOVEI	AC1,1				; AC1,1										3573
	POPJ	SP,				; SP,
L.190:	SETZ	AC1,				; AC1,
	POPJ	SP,				; SP,										3565

; Routine Size:  19 words


;   3576  2	
;   3577  2	    LOCAL
;   3578  2		SUB%TYPE,				! Subtype for XFR%STATUS
;   3579  2		DISCARD%FILE%FLAG,			! Sender requested discard
;   3580  2		ACK%MSG%LEN;				! Length of ACK to send
;   3581  2	
;   3582  2	!
;   3583  2	! First get a message
;   3584  2	!
;   3585  2	
;   3586  3	    IF NOT (STATUS = REC%MESSAGE (CHECK%DATA))
;   3587  2	    THEN
;   3588  2	
;   3589  2		IF .STATUS NEQ KER%ABORTED THEN RETURN STATE%A ELSE RETURN STATE%EX;
;   3590  2	
;   3591  2	    SELECTONE .REC%TYPE OF
;   3592  2		SET
;   3593  2	
;   3594  2		[MSG%DATA] :
;   3595  3		    BEGIN
;   3596  3	
;   3597  3		    IF .MSG%NUMBER NEQ .REC%SEQ
;   3598  3		    THEN
;   3599  4			BEGIN
;   3600  4	
;   3601  4			IF .OLD%RETRIES GTR .PKT%RETRIES THEN RETURN STATE%ER;
;   3602  4	
;   3603  4			OLD%RETRIES = .OLD%RETRIES + 1;
;   3604  4	
;   3605  4			IF ((.MSG%NUMBER - 1) AND %O'77') EQL .REC%SEQ
;   3606  4			THEN
;   3607  5			    BEGIN
;   3608  5			    SEND%PACKET (MSG%ACK, 0, .REC%SEQ);
;   3609  5			    NUM%RETRIES = 0;
;   3610  5			    RETURN .STATE;
;   3611  5			    END
;   3612  4			ELSE
;   3613  5			    BEGIN
;   3614  5			    KRM%ERROR (KER%PROTOERR);
;   3615  5			    RETURN STATE%A;
;   3616  4			    END;
;   3617  4	
;   3618  3			END;
;   3619  3	
;   3620  3	!
;   3621  3	! Here if we have a message with a valid message number
;   3622  3	!
;   3623  3	
;   3624  3		    IF NOT BFR%EMPTY () THEN RETURN STATE%A;
;   3625  3	
;   3626  3	!
;   3627  3	! Check if we wish to abort for some reason
;   3628  3	!
;   3629  3	
;   3630  3		    IF .ABT%CUR%FILE
;   3631  3		    THEN
;   3632  4			BEGIN
;   3633  4			CH$WCHAR (MSG%ACK%ABT%CUR, CH$PTR (SND%MSG, PKT%MSG, CHR%SIZE));
;   3634  4			ACK%MSG%LEN = 1;
;   3635  4			END
;   3636  3		    ELSE
;   3637  3	
;   3638  3			IF .ABT%ALL%FILE
;   3639  3			THEN
;   3640  4			    BEGIN
;   3641  4			    CH$WCHAR (MSG%ACK%ABT%ALL, CH$PTR (SND%MSG, PKT%MSG, CHR%SIZE));
;   3642  4			    ACK%MSG%LEN = 1;
;   3643  4			    END
;   3644  3			ELSE
;   3645  3			    ACK%MSG%LEN = 0;
;   3646  3	
;   3647  3	!
;   3648  3	! Now send the ACK
;   3649  3	!
;   3650  3		    SEND%PACKET (MSG%ACK, .ACK%MSG%LEN, .REC%SEQ);
;   3651  3		    OLD%RETRIES = .NUM%RETRIES;
;   3652  3		    NUM%RETRIES = 0;
;   3653  3		    MSG%NUMBER = (.MSG%NUMBER + 1) AND %O'77';
;   3654  3		    RETURN STATE%RD;
;   3655  2		    END;
;   3656  2	
;   3657  2		[MSG%FILE, MSG%TEXT] :
;   3658  3		    BEGIN
;   3659  3	
;   3660  3		    IF .OLD%RETRIES GTR .PKT%RETRIES THEN RETURN STATE%ER;
;   3661  3	
;   3662  3		    OLD%RETRIES = .OLD%RETRIES + 1;
;   3663  3	
;   3664  3		    IF ((.MSG%NUMBER - 1) AND %O'77') EQL .REC%SEQ
;   3665  3		    THEN
;   3666  4			BEGIN
;   3667  4			SEND%PACKET (MSG%ACK, 0, .REC%SEQ);
;   3668  4			NUM%RETRIES = 0;
;   3669  4			RETURN .STATE;
;   3670  4			END
;   3671  3		    ELSE
;   3672  4			BEGIN
;   3673  4			KRM%ERROR (KER%PROTOERR);
;   3674  4			RETURN STATE%A;
;   3675  3			END;
;   3676  3	
;   3677  2		    END;
;   3678  2	
;   3679  2		[MSG%EOF] :
;   3680  3		    BEGIN
;   3681  3	
;   3682  3		    IF .MSG%NUMBER NEQ .REC%SEQ
;   3683  3		    THEN
;   3684  4			BEGIN
;   3685  4			KRM%ERROR (KER%PROTOERR);
;   3686  4			RETURN STATE%A;
;   3687  3			END;
;   3688  3	
;   3689  3		    SEND%PACKET (MSG%ACK, 0, .REC%SEQ);
;   3690  3	
;   3691  3		    IF NOT .TEXT%HEAD%FLAG
;   3692  3		    THEN
;   3693  4			BEGIN
;   3694  4			FILE%OPEN%FLAG = FALSE;
;   3695  4			DISCARD%FILE%FLAG = FALSE;	! Assume we want file
;   3696  4	
;   3697  4			IF .REC%LENGTH EQL 1
;   3698  4			THEN
;   3699  4	
;   3700  4			    IF CH$RCHAR (CH$PTR (REC%MSG, PKT%MSG, CHR%SIZE)) EQL MSG%EOF%DISCARD
;   3701  4			    THEN
;   3702  4				DISCARD%FILE%FLAG = TRUE;
;   3703  4	
;   3704  4			IF ( NOT .CONNECT%FLAG) AND .TY%FIL
;   3705  4			THEN
;   3706  5			    BEGIN
;   3707  5	
;   3708  5			    IF .DISCARD%FILE%FLAG
;   3709  5			    THEN
;   3710  5	
;   3711  5				IF .ABT%FLAG
;   3712  5				THEN
;   3713  5				    TT%TEXT (UPLIT (%ASCIZ' [Interrupted]'))
;   3714  5				ELSE
;   3715  5				    TT%TEXT (UPLIT (%ASCIZ' [Interrupted, partial file saved]'))
;   3716  5	
;   3717  5			    ELSE
;   3718  5				TT%TEXT (UPLIT (%ASCIZ' [OK]'));
;   3719  5	
;   3720  5			    TT%CRLF ();
;   3721  4			    END;
;   3722  4	
;   3723  4			IF NOT FILE%CLOSE (.DISCARD%FILE%FLAG AND .ABT%FLAG) THEN RETURN STATE%A;
;   3724  4	
;   3725  4			IF .DISCARD%FILE%FLAG
;   3726  4			THEN
;   3727  4	
;   3728  4			    IF .ABT%FLAG THEN SUB%TYPE = %C'X' ELSE SUB%TYPE = %C'D'
;   3729  4	
;   3730  4			ELSE
;   3731  4			    SUB%TYPE = %C'C';
;   3732  4	
;   3733  4			END
;   3734  3		    ELSE
;   3735  4			BEGIN
;   3736  4			TT%CRLF ();			! Make sure we have a CRLF
;   3737  4			TT%OUTPUT ();			! And make sure all output is sent
;   3738  3			END;
;   3739  3	
;   3740  3		    XFR%STATUS (%C'F', .SUB%TYPE);
;   3741  3		    MSG%NUMBER = (.MSG%NUMBER + 1) AND %O'77';
;   3742  3		    RETURN STATE%RF;
;   3743  2		    END;
;   3744  2	
;   3745  2		[OTHERWISE] :
;   3746  3		    BEGIN
;   3747  3		    KRM%ERROR (KER%PROTOERR);
;   3748  3		    RETURN STATE%A;
;   3749  2		    END;
;   3750  2		TES;
;   3751  2	
;   3752  1	    END;					! End of REC%DATA


P.AAL:	BYTE	(7)" ","[","I","n","t"		;  [Int
	BYTE	(7)"e","r","r","u","p"		; errup
	BYTE	(7)"t","e","d","]",000		; ted]
P.AAM:	BYTE	(7)" ","[","I","n","t"		;  [Int
	BYTE	(7)"e","r","r","u","p"		; errup
	BYTE	(7)"t","e","d",","," "		; ted,
	BYTE	(7)"p","a","r","t","i"		; parti
	BYTE	(7)"a","l"," ","f","i"		; al fi
	BYTE	(7)"l","e"," ","s","a"		; le sa
	BYTE	(7)"v","e","d","]",000		; ved]
P.AAN:	BYTE	(7)" ","[","O","K","]"		;  [OK]
	BYTE	(7)000,000,000,000,000


; REC%DATA
U.13:	PUSH	SP,AC16				; SP,AC16									3522
	PUSH	SP,C.52				; SP,[0,,CHECK%DATA]								3586
	PUSHJ	SP,U.25				; SP,REC%MESSAGE
	ADJSP	SP,-1				; SP,-1
	TRNE	AC1,1				; STATUS,1
	JRST	L.191				; L.191
	CAIE	AC1,312				; STATUS,312									3589
	JRST	L.208				; L.208
	MOVEI	AC1,23				; AC1,23
	JRST	L.216				; L.216
L.191:	MOVE	AC1,U.56			; AC1,REC%TYPE									3591
	CAIE	AC1,104				; AC1,104									3594
	JRST	L.197				; L.197
	MOVE	AC2,U.53			; AC2,MSG%NUMBER								3597
	CAMN	AC2,U.54			; AC2,REC%SEQ
	JRST	L.192				; L.192
	MOVE	AC1,U.51			; AC1,OLD%RETRIES								3601
	CAMLE	AC1,PKT%RETRIES			; AC1,PKT%RETRIES
	JRST	L.199				; L.199
	JRST	L.200				; L.200										3522
L.192:	PUSHJ	SP,U.28				; SP,BFR%EMPTY									3624
	TRNN	AC1,1				; AC1,1
	JRST	L.208				; L.208
	MOVEI	AC1,1				; AC1,1										3630
	TDNN	AC1,ABT%CUR%FILE		; AC1,ABT%CUR%FILE
	JRST	L.193				; L.193
	MOVEI	AC2,130				; AC2,130									3633
	JRST	L.194				; L.194
L.193:	MOVEI	AC1,1				; AC1,1										3638
	TDNN	AC1,ABT%ALL%FILE		; AC1,ABT%ALL%FILE
	JRST	L.195				; L.195
	MOVEI	AC2,132				; AC2,132									3641
L.194:	MOVE	AC1,C.33			; AC1,[POINT 8,SND%MSG,31]  <4,8>
	IDPB	AC2,AC1				; AC2,AC1
	MOVEI	AC3,1				; ACK%MSG%LEN,1									3642
	JRST	L.196				; L.196										3638
L.195:	SETZ	AC3,				; ACK%MSG%LEN,									3645
L.196:	PUSH	SP,C.20				; SP,[131]									3650
	PUSH	SP,AC3				; SP,ACK%MSG%LEN
	PUSH	SP,U.54				; SP,REC%SEQ
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	MOVE	AC1,U.52			; AC1,NUM%RETRIES								3651
	MOVEM	AC1,U.51			; AC1,OLD%RETRIES
	SETZM	U.52				; NUM%RETRIES									3652
	MOVE	AC1,U.53			; AC1,MSG%NUMBER								3653
	ADDI	AC1,1				; AC1,1
	LDB	AC2,C.18			; AC2,[POINT 6,AC1,35]  <0,6>
	MOVEM	AC2,U.53			; AC2,MSG%NUMBER
	ADJSP	SP,-2				; SP,-2										3595
	MOVEI	AC1,10				; AC1,10									3591
	JRST	L.215				; L.215
L.197:	CAIE	AC1,106				; AC1,106									3657
	CAIN	AC1,130				; AC1,130
	JRST	L.198				; L.198
	JRST	L.201				; L.201
L.198:	MOVE	AC1,U.51			; AC1,OLD%RETRIES								3660
	CAMG	AC1,PKT%RETRIES			; AC1,PKT%RETRIES
	JRST	L.200				; L.200
L.199:	MOVEI	AC1,24				; AC1,24
	JRST	L.216				; L.216
L.200:	AOS	U.51				; OLD%RETRIES									3662
	MOVE	AC1,U.53			; AC1,MSG%NUMBER								3664
	SUBI	AC1,1				; AC1,1
	LDB	AC2,C.18			; AC2,[POINT 6,AC1,35]  <0,6>
	CAME	AC2,U.54			; AC2,REC%SEQ
	JRST	L.214				; L.214
	PUSH	SP,C.20				; SP,[131]									3667
	PUSH	SP,C.26				; SP,[0]
	PUSH	SP,U.54				; SP,REC%SEQ
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	SETZM	U.52				; NUM%RETRIES									3668
	ADJSP	SP,-2				; SP,-2										3666
	MOVE	AC1,U.49			; AC1,STATE									3672
	JRST	L.215				; L.215
L.201:	CAIE	AC1,132				; AC1,132									3679
	JRST	L.214				; L.214
	MOVE	AC1,U.53			; AC1,MSG%NUMBER								3682
	CAMN	AC1,U.54			; AC1,REC%SEQ
	JRST	L.202				; L.202
	PUSH	SP,C.22				; SP,[252]									3685
	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
	ADJSP	SP,-1				; SP,-1										3686
	JRST	L.208				; L.208
L.202:	PUSH	SP,C.20				; SP,[131]									3689
	PUSH	SP,C.26				; SP,[0]
	PUSH	SP,U.54				; SP,REC%SEQ
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	MOVEI	AC1,1				; AC1,1										3691
	TDNE	AC1,U.61			; AC1,TEXT%HEAD%FLAG
	JRST	L.212				; L.212
	SETZB	AC16,U.59			; DISCARD%FILE%FLAG,FILE%OPEN%FLAG						3694
	MOVEI	AC1,1				; AC1,1										3697
	CAME	AC1,U.55			; AC1,REC%LENGTH
	JRST	L.203				; L.203
	MOVE	AC1,C.29			; AC1,[POINT 8,REC%MSG,31]  <4,8>						3700
	ILDB	AC1,AC1				; AC1,AC1
	CAIN	AC1,104				; AC1,104
	MOVEI	AC16,1				; DISCARD%FILE%FLAG,1								3702
L.203:	MOVEI	AC1,1				; AC1,1										3704
	TDNE	AC1,CONNECT%FLAG		; AC1,CONNECT%FLAG
	JRST	L.207				; L.207
	MOVEI	AC1,1				; AC1,1
	TDNN	AC1,TY%FIL			; AC1,TY%FIL
	JRST	L.207				; L.207
	TRNN	AC16,1				; DISCARD%FILE%FLAG,1								3708
	JRST	L.205				; L.205
	MOVEI	AC1,1				; AC1,1										3711
	TDNN	AC1,ABT%FLAG			; AC1,ABT%FLAG
	JRST	L.204				; L.204
	PUSH	SP,C.53				; SP,[0,,P.AAL]									3713
	JRST	L.206				; L.206
L.204:	PUSH	SP,C.54				; SP,[0,,P.AAM]									3715
	JRST	L.206				; L.206
L.205:	PUSH	SP,C.55				; SP,[0,,P.AAN]									3718
L.206:	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSHJ	SP,TT%CRLF			; SP,TT%CRLF									3720
	ADJSP	SP,-1				; SP,-1										3706
L.207:	MOVE	AC1,AC16			; AC1,DISCARD%FILE%FLAG								3723
	AND	AC1,ABT%FLAG			; AC1,ABT%FLAG
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,FILE%CLOSE			; SP,FILE%CLOSE
	ADJSP	SP,-1				; SP,-1
	TRNE	AC1,1				; AC1,1
	JRST	L.209				; L.209
	ADJSP	SP,-3				; SP,-3
L.208:	MOVEI	AC1,12				; AC1,12
	JRST	L.216				; L.216
L.209:	TRNN	AC16,1				; DISCARD%FILE%FLAG,1								3725
	JRST	L.211				; L.211
	MOVEI	AC1,1				; AC1,1										3728
	TDNN	AC1,ABT%FLAG			; AC1,ABT%FLAG
	JRST	L.210				; L.210
	MOVEI	AC1,130				; SUB%TYPE,130
	JRST	L.213				; L.213
L.210:	MOVEI	AC1,104				; SUB%TYPE,104
	JRST	L.213				; L.213										3725
L.211:	MOVEI	AC1,103				; SUB%TYPE,103									3731
	JRST	L.213				; L.213										3691
L.212:	PUSHJ	SP,TT%CRLF			; SP,TT%CRLF									3736
	PUSHJ	SP,TT%OUTPUT			; SP,TT%OUTPUT									3737
L.213:	PUSH	SP,C.15				; SP,[106]									3740
	PUSH	SP,AC1				; SP,SUB%TYPE
	PUSHJ	SP,XFR%STATUS			; SP,XFR%STATUS
	MOVE	AC1,U.53			; AC1,MSG%NUMBER								3741
	ADDI	AC1,1				; AC1,1
	LDB	AC2,C.18			; AC2,[POINT 6,AC1,35]  <0,6>
	MOVEM	AC2,U.53			; AC2,MSG%NUMBER
	ADJSP	SP,-4				; SP,-4										3680
	MOVEI	AC1,7				; AC1,7										3591
	JRST	L.215				; L.215
L.214:	PUSH	SP,C.22				; SP,[252]									3747
	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
	MOVEI	AC1,12				; AC1,12									3591
L.215:	ADJSP	SP,-1				; SP,-1										3746
L.216:	POP	SP,AC16				; SP,AC16									3522
	POPJ	SP,				; SP,
C.52:	XWD	0,U.78				; 0,CHECK%DATA
C.53:	XWD	0,P.AAL				; 0,P.AAL
C.54:	XWD	0,P.AAM				; 0,P.AAM
C.55:	XWD	0,P.AAN				; 0,P.AAN

; Routine Size:  160 words


;   3753  1	%SBTTL 'SERVER - Generic commands'
;   3754  1	ROUTINE SERVER%GENERIC =
;   3755  1	
;   3756  1	!++
;   3757  1	! FUNCTIONAL DESCRIPTION:
;   3758  1	!
;   3759  1	!	This routine will handle the generic server messages.
;   3760  1	!	The generic server messages include FINISH, LOGOUT.
;   3761  1	!
;   3762  1	! CALLING SEQUENCE:
;   3763  1	!
;   3764  1	!	STATE = SERVER%GENERIC();
;   3765  1	!
;   3766  1	! INPUT PARAMETERS:
;   3767  1	!
;   3768  1	!	None.
;   3769  1	!
;   3770  1	! IMPLICIT INPUTS:
;   3771  1	!
;   3772  1	!	Generic message receive in REC%MSG.
;   3773  1	!
;   3774  1	! OUTPUT PARAMETERS:
;   3775  1	!
;   3776  1	!	Returns new state for FSM
;   3777  1	!
;   3778  1	! IMPLICIT OUTPUTS:
;   3779  1	!
;   3780  1	!	None.
;   3781  1	!
;   3782  1	! COMPLETION CODES:
;   3783  1	!
;   3784  1	!	None.
;   3785  1	!
;   3786  1	! SIDE EFFECTS:
;   3787  1	!
;   3788  1	!	None.
;   3789  1	!
;   3790  1	!--
;   3791  1	
;   3792  2	    BEGIN
;   3793  2	
;   3794  2	    LOCAL
;   3795  2		STATUS,					! Returned status
;   3796  2		G%FUNC,					! Generic command function
;   3797  2		POINTER,				! Character pointer
;   3798  2		DATA%TEXT : VECTOR [CH$ALLOCATION (MAX%MSG)],	! Unpacked message
;   3799  2		DATA%SIZE;				! Actual size of data
;   3800  2	
;   3801  2	    ROUTINE UNPACK%DATA (POINTER, SIZE, DST%ADDR, DST%LEN) =
;   3802  2	!
;   3803  2	! Routine to unpack an argument.
;   3804  2	! This will copy the argument data to the desired buffer.
;   3805  2	!
;   3806  3		BEGIN
;   3807  3	
;   3808  3		IF .SIZE GTR 0				! If we have something to unpack
;   3809  3		THEN
;   3810  4		    BEGIN
;   3811  4		    .DST%LEN = UNCHAR (CH$RCHAR%A (.POINTER));
;   3812  4	
;   3813  4		    IF ..DST%LEN LSS 0
;   3814  4		    THEN
;   3815  5			BEGIN
;   3816  5			KRM%ERROR (KER%PROTOERR);	! Someone screwed up
;   3817  5			..DST%LEN = 0;
;   3818  5			RETURN -1;
;   3819  4			END;
;   3820  4	
;   3821  4		    IF ..DST%LEN GTR .SIZE - 1 THEN .DST%LEN = .SIZE - 1;
;   3822  4	
;   3823  4		    CH$COPY (..DST%LEN, ..POINTER, CHR%NUL, MAX%MSG, CH$PTR (.DST%ADDR));
;   3824  4		    .POINTER = CH$PLUS (..POINTER, ..DST%LEN);
;   3825  4		    RETURN .SIZE - ..DST%LEN - 1;
;   3826  4		    END
;   3827  3		ELSE
;   3828  3	!
;   3829  3	! If nothing left in buffer, return the current size (0)
;   3830  3	!
;   3831  3		    RETURN .SIZE;
;   3832  3	
;   3833  2		END;


; UNPACK%DATA
U.79:	PUSH	SP,AC12				; SP,AC12									3801
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	PUSH	SP,AC16				; SP,AC16
	MOVE	AC12,-7(SP)			; AC12,SIZE									3808
	JUMPLE	AC12,L.218			; AC12,L.218
	MOVE	AC13,-5(SP)			; AC13,DST%LEN									3811
	MOVE	AC16,-10(SP)			; AC16,POINTER
	ILDB	AC1,0(AC16)			; AC1,0(AC16)
	SUBI	AC1,40				; AC1,40
	MOVEM	AC1,0(AC13)			; AC1,0(AC13)
	MOVE	AC14,0(AC13)			; AC14,0(AC13)									3813
	JUMPGE	AC14,L.217			; AC14,L.217
	PUSH	SP,C.22				; SP,[252]									3816
	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
	SETZM	0(AC14)				; 0(AC14)									3817
	ADJSP	SP,-1				; SP,-1										3818
	SETO	AC1,				; AC1,										3815
	JRST	L.219				; L.219
L.217:	MOVE	AC1,AC12			; AC1,AC12									3821
	SUBI	AC1,1				; AC1,1
	CAMLE	AC14,AC1			; AC14,AC1
	MOVEM	AC1,0(AC13)			; AC1,0(AC13)
	MOVE	AC1,-6(SP)			; AC1,DST%ADDR									3823
	MOVEI	AC5,-1(AC1)			; AC5,-1(AC1)
	HRLI	AC5,10700			; AC5,10700
	MOVE	AC1,0(AC13)			; AC1,0(AC13)
	MOVE	AC2,0(AC16)			; AC2,0(AC16)
	MOVEI	AC4,140				; AC4,140
	EXTEND	AC1,C.1				; AC1,C.1
	JFCL					;
	MOVE	AC1,0(AC13)			; AC1,0(AC13)									3824
	ADJBP	AC1,0(AC16)			; AC1,0(AC16)
	MOVEM	AC1,0(AC16)			; AC1,0(AC16)
	MOVE	AC1,AC12			; AC1,AC12									3825
	SUB	AC1,0(AC13)			; AC1,0(AC13)
	SOJA	AC1,L.219			; AC1,L.219									3831
L.218:	MOVE	AC1,AC12			; AC1,AC12
L.219:	POP	SP,AC16				; SP,AC16									3801
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POPJ	SP,				; SP,

; Routine Size:  43 words


;   3834  2	!
;   3835  2	! First unpack the message data into its various pieces
;   3836  2	!
;   3837  2	    SET%STRING (CH$PTR (DATA%TEXT), MAX%MSG, TRUE);	! Initialize for unpacking
;   3838  2	    BFR%EMPTY ();				! Unpack the data
;   3839  2	    DATA%SIZE = SET%STRING (0, 0, FALSE);	! All done, get size
;   3840  2	
;   3841  2	    IF .DATA%SIZE LEQ 0
;   3842  2	    THEN
;   3843  3		BEGIN
;   3844  3		KRM%ERROR (KER%PROTOERR);		! Someone screwed up
;   3845  3		RETURN STATE%A;				! Since no subtype
;   3846  2		END;
;   3847  2	
;   3848  2	!
;   3849  2	! Get the arguments from the unpacked data (if any)
;   3850  2	!
;   3851  2	    GEN%1SIZE = 0;				! Assume no args
;   3852  2	    GEN%2SIZE = 0;				! none at all
;   3853  2	    GEN%3SIZE = 0;
;   3854  2	    CH$WCHAR (CHR%NUL, CH$PTR (GEN%1DATA));	! Ensure all are null terminated
;   3855  2	    CH$WCHAR (CHR%NUL, CH$PTR (GEN%2DATA));
;   3856  2	    CH$WCHAR (CHR%NUL, CH$PTR (GEN%3DATA));
;   3857  2	    POINTER = CH$PTR (DATA%TEXT, 1);		! Point at second character
;   3858  2	    DATA%SIZE = .DATA%SIZE - 1;			! Account for subtype
;   3859  2	
;   3860  2	    IF .DATA%SIZE GTR 0				! Room for first arg?
;   3861  2	    THEN
;   3862  3		BEGIN
;   3863  3		DATA%SIZE = UNPACK%DATA (POINTER, .DATA%SIZE, GEN%1DATA, GEN%1SIZE);
;   3864  3	
;   3865  3		IF .DATA%SIZE LSS 0 THEN RETURN STATE%A;	! Punt if bad arguments
;   3866  3	
;   3867  3		IF .DATA%SIZE GTR 0			! Second argument present?
;   3868  3		THEN
;   3869  4		    BEGIN
;   3870  4		    DATA%SIZE = UNPACK%DATA (POINTER, .DATA%SIZE, GEN%2DATA, GEN%2SIZE);
;   3871  4	
;   3872  4		    IF .DATA%SIZE LSS 0 THEN RETURN STATE%A;	! Punt if bad arguments
;   3873  4	
;   3874  4		    IF .DATA%SIZE GTR 0			! Third argument here?
;   3875  4		    THEN
;   3876  5			BEGIN
;   3877  5			DATA%SIZE = UNPACK%DATA (POINTER, .DATA%SIZE, GEN%3DATA, GEN%3SIZE);
;   3878  5	
;   3879  5			IF .DATA%SIZE LSS 0 THEN RETURN STATE%A;	! Punt if bad arguments
;   3880  5	
;   3881  4			END;
;   3882  4	
;   3883  3		    END;
;   3884  3	
;   3885  2		END;
;   3886  2	
;   3887  2	    SELECTONE CH$RCHAR (CH$PTR (DATA%TEXT)) OF
;   3888  2		SET
;   3889  2		!
;   3890  2		! EXIT command, just return the status to the upper level
;   3891  2		!
;   3892  2	
;   3893  2		[MSG%GEN%EXIT] :
;   3894  3		    BEGIN
;   3895  3		    SEND%PACKET (MSG%ACK, 0, .REC%SEQ);
;   3896  3		    RETURN STATE%FI;
;   3897  2		    END;
;   3898  2		!
;   3899  2		! LOGOUT command, ACK the message then call the system routine to
;   3900  2		! kill the process (log the job out, etc.)
;   3901  2		!
;   3902  2	
;   3903  2		[MSG%GEN%LOGOUT] :
;   3904  3		    BEGIN
;   3905  3		    SEND%PACKET (MSG%ACK, 0, .REC%SEQ);
;   3906  3		    SY%LOGOUT ();
;   3907  3		    RETURN STATE%LG;
;   3908  2		    END;
;   3909  2	!
;   3910  2	! For a type command, just set up a transfer flagging we want a text header
;   3911  2	! instead of a file header.
;   3912  2	!
;   3913  2	
;   3914  2		[MSG%GEN%TYPE] :
;   3915  3		    BEGIN
;   3916  3		    CH$COPY (.GEN%1SIZE, CH$PTR (GEN%1DATA), CHR%NUL, MAX%FILE%NAME, CH$PTR (FILE%NAME));
;   3917  3		    FILE%SIZE = .GEN%1SIZE;
;   3918  3		    TEXT%HEAD%FLAG = TRUE;		! Now want text header
;   3919  3		    XFR%STATUS (%C'I', %C'G');		! Tell display routine we are doing a command
;   3920  3	
;   3921  3		    IF .STATE EQL STATE%II AND .BLK%CHK%TYPE EQL .INI%CHK%TYPE
;   3922  3		    THEN
;   3923  3			RETURN STATE%OF			! Must open the file
;   3924  3		    ELSE
;   3925  3			RETURN STATE%S;			! Start the transaction with a send
;   3926  3	
;   3927  2		    END;
;   3928  2	
;   3929  2		[MSG%GEN%DIRECTORY] :
;   3930  2		    G%FUNC = GC%DIRECTORY;
;   3931  2	
;   3932  2		[MSG%GEN%DISK%USAGE] :
;   3933  2		    G%FUNC = GC%DISK%USAGE;
;   3934  2	
;   3935  2		[MSG%GEN%DELETE] :
;   3936  2		    G%FUNC = GC%DELETE;
;   3937  2	
;   3938  2		[MSG%GEN%HELP] :
;   3939  2		    G%FUNC = GC%HELP;
;   3940  2	
;   3941  2		[MSG%GEN%LOGIN] :
;   3942  2		    G%FUNC = GC%LGN;
;   3943  2	
;   3944  2		[MSG%GEN%CONNECT] :
;   3945  2		    G%FUNC = GC%CONNECT;
;   3946  2	
;   3947  2		[MSG%GEN%RENAME] :
;   3948  2		    G%FUNC = GC%RENAME;
;   3949  2	
;   3950  2		[MSG%GEN%COPY] :
;   3951  2		    G%FUNC = GC%COPY;
;   3952  2	
;   3953  2		[MSG%GEN%WHO] :
;   3954  2		    G%FUNC = GC%WHO;
;   3955  2	
;   3956  2		[MSG%GEN%SEND] :
;   3957  2		    G%FUNC = GC%SEND%MSG;
;   3958  2	
;   3959  2		[MSG%GEN%QUERY] :
;   3960  2		    G%FUNC = GC%STATUS;
;   3961  2	
;   3962  2		[MSG%GEN%PROGRAM] :
;   3963  2		    G%FUNC = GC%PROGRAM;
;   3964  2	
;   3965  2		[MSG%GEN%JOURNAL] :
;   3966  2		    G%FUNC = GC%JOURNAL;
;   3967  2	
;   3968  2		[MSG%GEN%VARIABLE] :
;   3969  2		    G%FUNC = GC%VARIABLE;
;   3970  2	!
;   3971  2	! Here if we have a function that is not implemented in KERMSG.
;   3972  2	!
;   3973  2	
;   3974  2		[OTHERWISE] :
;   3975  3		    BEGIN
;   3976  3		    KRM%ERROR (KER%UNIMPLGEN);
;   3977  3		    RETURN STATE%A;
;   3978  2		    END;
;   3979  2		TES;
;   3980  2	
;   3981  2	!
;   3982  2	! If we get here, we have gotten a known type of generic message that
;   3983  2	! we need to have our operating system dependent routine handle.
;   3984  2	!
;   3985  2	    RETURN CALL%SY%RTN (.G%FUNC);
;   3986  1	    END;					! End of SERVER%GENERIC


; SERVER%GENERIC
U.14:	PUSH	SP,AC14				; SP,AC14									3754
	PUSH	SP,AC16				; SP,AC16
	ADJSP	SP,25				; SP,25
	MOVEI	AC1,-25(SP)			; AC1,DATA%TEXT-1								3837
	HRLI	AC1,10700			; AC1,10700
	PUSH	SP,AC1				; SP,AC1
	PUSH	SP,C.56				; SP,[140]
	PUSH	SP,C.2				; SP,[1]
	PUSHJ	SP,U.30				; SP,SET%STRING
	PUSHJ	SP,U.28				; SP,BFR%EMPTY									3838
	SETZM	-2(SP)				; -2(SP)									3839
	SETZM	-1(SP)				; -1(SP)
	SETZM	0(SP)				; 0(SP)
	PUSHJ	SP,U.30				; SP,SET%STRING
	MOVE	AC14,AC1			; DATA%SIZE,AC1
	JUMPG	AC14,L.220			; DATA%SIZE,L.220								3841
	PUSH	SP,C.22				; SP,[252]									3844
	JRST	L.246				; L.246
L.220:	SETZM	GEN%1SIZE			; GEN%1SIZE									3851
	SETZM	GEN%2SIZE			; GEN%2SIZE									3852
	SETZB	AC2,GEN%3SIZE			; AC2,GEN%3SIZE									3853
	MOVE	AC1,C.11			; AC1,[POINT 7,GEN%1DATA-1,34]  <1,7>						3854
	IDPB	AC2,AC1				; AC2,AC1
	SETZ	AC2,				; AC2,										3855
	MOVE	AC1,C.57			; AC1,[POINT 7,GEN%2DATA-1,34]  <1,7>
	IDPB	AC2,AC1				; AC2,AC1
	SETZ	AC2,				; AC2,										3856
	MOVE	AC1,C.58			; AC1,[POINT 7,GEN%3DATA-1,34]  <1,7>
	IDPB	AC2,AC1				; AC2,AC1
	MOVEI	AC1,-27(SP)			; AC1,DATA%TEXT									3857
	HRLI	AC1,350700			; AC1,350700
	MOVEM	AC1,-3(SP)			; AC1,POINTER
	SOJLE	AC14,L.226			; DATA%SIZE,L.226								3860
	MOVEI	AC1,-3(SP)			; AC1,POINTER									3863
	PUSH	SP,AC1				; SP,AC1
	PUSH	SP,AC14				; SP,DATA%SIZE
	PUSH	SP,C.40				; SP,[0,,GEN%1DATA]
	PUSH	SP,C.59				; SP,[0,,GEN%1SIZE]
	PUSHJ	SP,U.79				; SP,UNPACK%DATA
	MOVE	AC14,AC1			; DATA%SIZE,AC1
	JUMPGE	AC14,L.221			; DATA%SIZE,L.221								3865
	ADJSP	SP,-7				; SP,-7
	JRST	L.247				; L.247
L.221:	JUMPLE	AC14,L.225			; DATA%SIZE,L.225								3867
	MOVEI	AC1,-7(SP)			; AC1,POINTER									3870
	PUSH	SP,AC1				; SP,AC1
	PUSH	SP,AC14				; SP,DATA%SIZE
	PUSH	SP,C.41				; SP,[0,,GEN%2DATA]
	PUSH	SP,C.60				; SP,[0,,GEN%2SIZE]
	PUSHJ	SP,U.79				; SP,UNPACK%DATA
	MOVE	AC14,AC1			; DATA%SIZE,AC1
	JUMPGE	AC14,L.222			; DATA%SIZE,L.222								3872
	ADJSP	SP,-13				; SP,-13
	JRST	L.247				; L.247
L.222:	JUMPLE	AC14,L.224			; DATA%SIZE,L.224								3874
	MOVEI	AC1,-13(SP)			; AC1,POINTER									3877
	PUSH	SP,AC1				; SP,AC1
	PUSH	SP,AC14				; SP,DATA%SIZE
	PUSH	SP,C.42				; SP,[0,,GEN%3DATA]
	PUSH	SP,C.61				; SP,[0,,GEN%3SIZE]
	PUSHJ	SP,U.79				; SP,UNPACK%DATA
	MOVE	AC14,AC1			; DATA%SIZE,AC1
	JUMPGE	AC14,L.223			; DATA%SIZE,L.223								3879
	ADJSP	SP,-17				; SP,-17
	JRST	L.247				; L.247
L.223:	ADJSP	SP,-4				; SP,-4										3876
L.224:	ADJSP	SP,-4				; SP,-4										3869
L.225:	ADJSP	SP,-4				; SP,-4										3862
L.226:	MOVEI	AC1,-30(SP)			; AC1,DATA%TEXT-1								3887
	HRLI	AC1,10700			; AC1,10700
	ILDB	AC16,AC1			; AC16,AC1
	CAIE	AC16,106			; AC16,106									3893
	JRST	L.227				; L.227
	PUSH	SP,C.20				; SP,[131]									3895
	PUSH	SP,C.26				; SP,[0]
	PUSH	SP,U.54				; SP,REC%SEQ
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	ADJSP	SP,-6				; SP,-6										3896
	MOVEI	AC1,20				; AC1,20									3894
	JRST	L.249				; L.249
L.227:	CAIE	AC16,114			; AC16,114									3903
	JRST	L.228				; L.228
	PUSH	SP,C.20				; SP,[131]									3905
	PUSH	SP,C.26				; SP,[0]
	PUSH	SP,U.54				; SP,REC%SEQ
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	PUSHJ	SP,SY%LOGOUT			; SP,SY%LOGOUT									3906
	ADJSP	SP,-6				; SP,-6										3907
	MOVEI	AC1,21				; AC1,21									3904
	JRST	L.249				; L.249
L.228:	CAIE	AC16,124			; AC16,124									3914
	JRST	L.231				; L.231
	MOVE	AC1,GEN%1SIZE			; AC1,GEN%1SIZE									3916
	MOVE	AC2,C.11			; AC2,[POINT 7,GEN%1DATA-1,34]  <1,7>
	MOVEI	AC4,204				; AC4,204
	MOVE	AC5,C.10			; AC5,[POINT 7,FILE%NAME-1,34]  <1,7>
	EXTEND	AC1,C.1				; AC1,C.1
	JFCL					;
	MOVE	AC1,GEN%1SIZE			; AC1,GEN%1SIZE									3917
	MOVEM	AC1,FILE%SIZE			; AC1,FILE%SIZE
	MOVEI	AC1,1				; AC1,1										3918
	MOVEM	AC1,U.61			; AC1,TEXT%HEAD%FLAG
	PUSH	SP,C.6				; SP,[111]									3919
	PUSH	SP,C.62				; SP,[107]
	PUSHJ	SP,XFR%STATUS			; SP,XFR%STATUS
	MOVEI	AC1,17				; AC1,17									3921
	CAME	AC1,U.49			; AC1,STATE
	JRST	L.229				; L.229
	MOVE	AC1,U.46			; AC1,BLK%CHK%TYPE
	CAME	AC1,U.45			; AC1,INI%CHK%TYPE
	JRST	L.229				; L.229
	MOVEI	AC1,22				; AC1,22									3925
	JRST	L.230				; L.230
L.229:	MOVEI	AC1,1				; AC1,1
L.230:	ADJSP	SP,-5				; SP,-5										3921
	JRST	L.249				; L.249										3915
L.231:	CAIE	AC16,104			; AC16,104									3929
	JRST	L.232				; L.232
	MOVEI	AC14,2				; G%FUNC,2									3930
	JRST	L.248				; L.248										3887
L.232:	CAIE	AC16,125			; AC16,125									3932
	JRST	L.233				; L.233
	MOVEI	AC14,3				; G%FUNC,3									3933
	JRST	L.248				; L.248										3887
L.233:	CAIE	AC16,105			; AC16,105									3935
	JRST	L.234				; L.234
	MOVEI	AC14,4				; G%FUNC,4									3936
	JRST	L.248				; L.248										3887
L.234:	CAIE	AC16,110			; AC16,110									3938
	JRST	L.235				; L.235
	MOVEI	AC14,6				; G%FUNC,6									3939
	JRST	L.248				; L.248										3887
L.235:	CAIE	AC16,111			; AC16,111									3941
	JRST	L.236				; L.236
	MOVEI	AC14,10				; G%FUNC,10									3942
	JRST	L.248				; L.248										3887
L.236:	CAIE	AC16,103			; AC16,103									3944
	JRST	L.237				; L.237
	MOVEI	AC14,11				; G%FUNC,11									3945
	JRST	L.248				; L.248										3887
L.237:	CAIE	AC16,122			; AC16,122									3947
	JRST	L.238				; L.238
	MOVEI	AC14,12				; G%FUNC,12									3948
	JRST	L.248				; L.248										3887
L.238:	CAIE	AC16,113			; AC16,113									3950
	JRST	L.239				; L.239
	MOVEI	AC14,13				; G%FUNC,13									3951
	JRST	L.248				; L.248										3887
L.239:	CAIE	AC16,127			; AC16,127									3953
	JRST	L.240				; L.240
	MOVEI	AC14,14				; G%FUNC,14									3954
	JRST	L.248				; L.248										3887
L.240:	CAIE	AC16,115			; AC16,115									3956
	JRST	L.241				; L.241
	MOVEI	AC14,15				; G%FUNC,15									3957
	JRST	L.248				; L.248										3887
L.241:	CAIE	AC16,121			; AC16,121									3959
	JRST	L.242				; L.242
	MOVEI	AC14,16				; G%FUNC,16									3960
	JRST	L.248				; L.248										3887
L.242:	CAIE	AC16,120			; AC16,120									3962
	JRST	L.243				; L.243
	MOVEI	AC14,23				; G%FUNC,23									3963
	JRST	L.248				; L.248										3887
L.243:	CAIE	AC16,112			; AC16,112									3965
	JRST	L.244				; L.244
	MOVEI	AC14,21				; G%FUNC,21									3966
	JRST	L.248				; L.248										3887
L.244:	CAIE	AC16,126			; AC16,126									3968
	JRST	L.245				; L.245
	MOVEI	AC14,22				; G%FUNC,22									3969
	JRST	L.248				; L.248										3887
L.245:	PUSH	SP,C.13				; SP,[232]									3976
L.246:	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
	ADJSP	SP,-4				; SP,-4										3977
L.247:	MOVEI	AC1,12				; AC1,12									3975
	JRST	L.249				; L.249
L.248:	MOVEM	AC14,0(SP)			; G%FUNC,0(SP)									3985
	PUSHJ	SP,U.17				; SP,CALL%SY%RTN
	ADJSP	SP,-3				; SP,-3
L.249:	ADJSP	SP,-25				; SP,-25									3754
	POP	SP,AC16				; SP,AC16
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,
C.56:	EXP	140				; 140
C.57:	POINT	7,GEN%2DATA-1,34		; 7,GEN%2DATA-1,34
C.58:	POINT	7,GEN%3DATA-1,34		; 7,GEN%3DATA-1,34
C.59:	XWD	0,GEN%1SIZE			; 0,GEN%1SIZE
C.60:	XWD	0,GEN%2SIZE			; 0,GEN%2SIZE
C.61:	XWD	0,GEN%3SIZE			; 0,GEN%3SIZE
C.62:	EXP	107				; 107

; Routine Size:  191 words


;   3987  1	%SBTTL 'HOST%COMMAND - perform a host command'
;   3988  1	ROUTINE HOST%COMMAND =
;   3989  1	
;   3990  1	!++
;   3991  1	! FUNCTIONAL DESCRIPTION:
;   3992  1	!
;   3993  1	! This routine will handle the host command packet.
;   3994  1	! It will set up the data for the call to the system routine.
;   3995  1	!
;   3996  1	! CALLING SEQUENCE:
;   3997  1	!
;   3998  1	!	STATE = HOST%COMMAND();
;   3999  1	!
;   4000  1	! INPUT PARAMETERS:
;   4001  1	!
;   4002  1	!	None.
;   4003  1	!
;   4004  1	! IMPLICIT INPUTS:
;   4005  1	!
;   4006  1	!	Generic message receive in REC%MSG.
;   4007  1	!
;   4008  1	! OUTPUT PARAMETERS:
;   4009  1	!
;   4010  1	!	Returns new state for FSM
;   4011  1	!
;   4012  1	! IMPLICIT OUTPUTS:
;   4013  1	!
;   4014  1	!	None.
;   4015  1	!
;   4016  1	! COMPLETION CODES:
;   4017  1	!
;   4018  1	!	None.
;   4019  1	!
;   4020  1	! SIDE EFFECTS:
;   4021  1	!
;   4022  1	!	None.
;   4023  1	!
;   4024  1	!--
;   4025  1	
;   4026  2	    BEGIN
;   4027  2	    GEN%1SIZE = 0;
;   4028  2	    GEN%2SIZE = 0;
;   4029  2	    GEN%3SIZE = 0;
;   4030  2	
;   4031  2	    IF .REC%LENGTH LEQ 0
;   4032  2	    THEN
;   4033  3		BEGIN
;   4034  3		KRM%ERROR (KER%PROTOERR);		! Return an error
;   4035  3		RETURN STATE%A;				! Just abort
;   4036  2		END;
;   4037  2	
;   4038  2	    SET%STRING (CH$PTR (GEN%1DATA), MAX%MSG, TRUE);	! Start writing to buffer
;   4039  2	    BFR%EMPTY ();				! Dump the text
;   4040  2	    GEN%1SIZE = SET%STRING (0, 0, FALSE);	! Get the result
;   4041  2	    RETURN CALL%SY%RTN (GC%COMMAND);
;   4042  1	    END;					! End of HOST%COMMAND


; HOST%COMMAND
U.15:	SETZM	GEN%1SIZE			; GEN%1SIZE									4027
	SETZM	GEN%2SIZE			; GEN%2SIZE									4028
	SETZM	GEN%3SIZE			; GEN%3SIZE									4029
	SKIPLE	U.55				; REC%LENGTH									4031
	JRST	L.250				; L.250
	PUSH	SP,C.22				; SP,[252]									4034
	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
	ADJSP	SP,-1				; SP,-1										4035
	MOVEI	AC1,12				; AC1,12									4033
	POPJ	SP,				; SP,
L.250:	PUSH	SP,C.11				; SP,[POINT 7,GEN%1DATA-1,34]  <1,7>						4038
	PUSH	SP,C.56				; SP,[140]
	PUSH	SP,C.2				; SP,[1]
	PUSHJ	SP,U.30				; SP,SET%STRING
	PUSHJ	SP,U.28				; SP,BFR%EMPTY									4039
	SETZM	-2(SP)				; -2(SP)									4040
	SETZM	-1(SP)				; -1(SP)
	SETZM	0(SP)				; 0(SP)
	PUSHJ	SP,U.30				; SP,SET%STRING
	MOVEM	AC1,GEN%1SIZE			; AC1,GEN%1SIZE
	PUSH	SP,C.63				; SP,[17]									4041
	PUSHJ	SP,U.17				; SP,CALL%SY%RTN
	ADJSP	SP,-4				; SP,-4
	POPJ	SP,				; SP,										3988
C.63:	EXP	17				; 17

; Routine Size:  25 words


;   4043  1	%SBTTL 'KERMIT%COMMAND - perform a KERMIT command'
;   4044  1	ROUTINE KERMIT%COMMAND =
;   4045  1	
;   4046  1	!++
;   4047  1	! FUNCTIONAL DESCRIPTION:
;   4048  1	!
;   4049  1	! This routine will handle the KERMIT command packet.
;   4050  1	! It will set up the data for the call to the system routine.
;   4051  1	!
;   4052  1	! CALLING SEQUENCE:
;   4053  1	!
;   4054  1	!	STATE = KERMIT%COMMAND();
;   4055  1	!
;   4056  1	! INPUT PARAMETERS:
;   4057  1	!
;   4058  1	!	None.
;   4059  1	!
;   4060  1	! IMPLICIT INPUTS:
;   4061  1	!
;   4062  1	!	Generic message receive in REC%MSG.
;   4063  1	!
;   4064  1	! OUTPUT PARAMETERS:
;   4065  1	!
;   4066  1	!	Returns new state for FSM
;   4067  1	!
;   4068  1	! IMPLICIT OUTPUTS:
;   4069  1	!
;   4070  1	!	None.
;   4071  1	!
;   4072  1	! COMPLETION CODES:
;   4073  1	!
;   4074  1	!	None.
;   4075  1	!
;   4076  1	! SIDE EFFECTS:
;   4077  1	!
;   4078  1	!	None.
;   4079  1	!
;   4080  1	!--
;   4081  1	
;   4082  2	    BEGIN
;   4083  2	    GEN%1SIZE = 0;
;   4084  2	    GEN%2SIZE = 0;
;   4085  2	    GEN%3SIZE = 0;
;   4086  2	
;   4087  2	    IF .REC%LENGTH LEQ 0
;   4088  2	    THEN
;   4089  3		BEGIN
;   4090  3		KRM%ERROR (KER%PROTOERR);		! Return an error
;   4091  3		RETURN STATE%A;				! Just abort
;   4092  2		END;
;   4093  2	
;   4094  2	    SET%STRING (CH$PTR (GEN%1DATA), MAX%MSG, TRUE);	! Start writing to buffer
;   4095  2	    BFR%EMPTY ();				! Dump the text
;   4096  2	    GEN%1SIZE = SET%STRING (0, 0, FALSE);	! Get the result
;   4097  2	    RETURN CALL%SY%RTN (GC%KERMIT);
;   4098  1	    END;					! End of KERMIT%COMMAND


; KERMIT%COMMAND
U.16:	SETZM	GEN%1SIZE			; GEN%1SIZE									4083
	SETZM	GEN%2SIZE			; GEN%2SIZE									4084
	SETZM	GEN%3SIZE			; GEN%3SIZE									4085
	SKIPLE	U.55				; REC%LENGTH									4087
	JRST	L.251				; L.251
	PUSH	SP,C.22				; SP,[252]									4090
	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
	ADJSP	SP,-1				; SP,-1										4091
	MOVEI	AC1,12				; AC1,12									4089
	POPJ	SP,				; SP,
L.251:	PUSH	SP,C.11				; SP,[POINT 7,GEN%1DATA-1,34]  <1,7>						4094
	PUSH	SP,C.56				; SP,[140]
	PUSH	SP,C.2				; SP,[1]
	PUSHJ	SP,U.30				; SP,SET%STRING
	PUSHJ	SP,U.28				; SP,BFR%EMPTY									4095
	SETZM	-2(SP)				; -2(SP)									4096
	SETZM	-1(SP)				; -1(SP)
	SETZM	0(SP)				; 0(SP)
	PUSHJ	SP,U.30				; SP,SET%STRING
	MOVEM	AC1,GEN%1SIZE			; AC1,GEN%1SIZE
	PUSH	SP,C.64				; SP,[20]									4097
	PUSHJ	SP,U.17				; SP,CALL%SY%RTN
	ADJSP	SP,-4				; SP,-4
	POPJ	SP,				; SP,										4044
C.64:	EXP	20				; 20

; Routine Size:  25 words


;   4099  1	%SBTTL 'CALL%SY%RTN - handle operating system dependent functions'
;   4100  1	ROUTINE CALL%SY%RTN (G%FUNC) =
;   4101  1	
;   4102  1	!++
;   4103  1	! FUNCTIONAL DESCRIPTION:
;   4104  1	!
;   4105  1	! This routine will handle calling the operating system dependent routine
;   4106  1	! for a server function and returning the response.
;   4107  1	!
;   4108  1	! CALLING SEQUENCE:
;   4109  1	!
;   4110  1	!	STATE = CALL%SY%RTN(.G%FUNC);
;   4111  1	!
;   4112  1	! INPUT PARAMETERS:
;   4113  1	!
;   4114  1	!	G%FUNC - Generic function code
;   4115  1	!
;   4116  1	! IMPLICIT INPUTS:
;   4117  1	!
;   4118  1	!	Generic message data in GEN%1DATA
;   4119  1	!
;   4120  1	! OUTPUT PARAMETERS:
;   4121  1	!
;   4122  1	!	Returns new state for FSM
;   4123  1	!
;   4124  1	! IMPLICIT OUTPUTS:
;   4125  1	!
;   4126  1	!	None.
;   4127  1	!
;   4128  1	! COMPLETION CODES:
;   4129  1	!
;   4130  1	!	None.
;   4131  1	!
;   4132  1	! SIDE EFFECTS:
;   4133  1	!
;   4134  1	!	None.
;   4135  1	!
;   4136  1	!--
;   4137  1	
;   4138  2	    BEGIN
;   4139  2	
;   4140  2	    LOCAL
;   4141  2		STRING%ADDRESS,				! Address of string result
;   4142  2		STRING%LENGTH,				! Length of string result
;   4143  2		GET%CHR%SUBROUTINE,			! Routine to get a response character
;   4144  2		STATUS;					! Status value
;   4145  2	
;   4146  2	!
;   4147  2	! Call the routine with the desired type of command.
;   4148  2	!
;   4149  2	    STRING%LENGTH = 0;				! Initialize for no string
;   4150  2	    GET%CHR%SUBROUTINE = 0;			! And no subroutine
;   4151  2	
;   4152  2	    IF NOT SY%GENERIC (.G%FUNC, STRING%ADDRESS, STRING%LENGTH, GET%CHR%SUBROUTINE)
;   4153  2	    THEN
;   4154  2		RETURN STATE%A;				! And abort
;   4155  2	
;   4156  2	    IF .STRING%LENGTH GTR 0
;   4157  2	    THEN
;   4158  3		BEGIN
;   4159  3		SET%STRING (CH$PTR (.STRING%ADDRESS), .STRING%LENGTH, TRUE);
;   4160  3	
;   4161  3		IF .STRING%LENGTH LSS .SEND%PKT%SIZE - PKT%OVR%HEAD
;   4162  3		THEN
;   4163  4		    BEGIN
;   4164  4		    BFR%FILL (TRUE);			! If it should fit, pack it in
;   4165  4	
;   4166  4		    IF SET%STRING (0, 0, FALSE) GEQ .STRING%LENGTH
;   4167  4		    THEN 				! It fit, so just send the ACK
;   4168  4	
;   4169  4			IF SEND%PACKET (MSG%ACK, .SIZE, .REC%SEQ) THEN RETURN STATE%C ELSE RETURN STATE%EX;
;   4170  4	
;   4171  4	!
;   4172  4	! It didn't fit, reset the pointers to the beginning
;   4173  4	!
;   4174  4		    SET%STRING (CH$PTR (.STRING%ADDRESS), .STRING%LENGTH, TRUE);
;   4175  3		    END;
;   4176  3	
;   4177  3		NO%FILE%NEEDED = TRUE;			! Don't need a file
;   4178  3		END
;   4179  2	    ELSE
;   4180  2	
;   4181  2		IF .GET%CHR%SUBROUTINE NEQ 0		! If we got a subroutine back
;   4182  2		THEN
;   4183  3		    BEGIN
;   4184  3		    GET%CHR%ROUTINE = .GET%CHR%SUBROUTINE;
;   4185  3		    NO%FILE%NEEDED = TRUE;
;   4186  2		    END;
;   4187  2	
;   4188  2	    TEXT%HEAD%FLAG = TRUE;			! Send to be typed
;   4189  2	    XFR%STATUS (%C'I', %C'G');			! Doing a generic command
;   4190  2	
;   4191  2	    IF .STATE EQL STATE%II AND .BLK%CHK%TYPE EQL .INI%CHK%TYPE
;   4192  2	    THEN
;   4193  2		RETURN STATE%OF
;   4194  2	    ELSE
;   4195  2		RETURN STATE%S;				! Send the response
;   4196  2	
;   4197  1	    END;					! End of CALL%SY%RTN


; CALL%SY%RTN
U.17:	PUSH	SP,AC14				; SP,AC14									4100
	PUSH	SP,AC16				; SP,AC16
	ADJSP	SP,3				; SP,3
	SETZM	-1(SP)				; STRING%LENGTH									4149
	SETZM	-2(SP)				; GET%CHR%SUBROUTINE								4150
	PUSH	SP,-6(SP)			; SP,G%FUNC									4152
	MOVEI	AC1,-1(SP)			; AC1,STRING%ADDRESS
	PUSH	SP,AC1				; SP,AC1
	MOVEI	AC1,-3(SP)			; AC1,STRING%LENGTH
	PUSH	SP,AC1				; SP,AC1
	MOVEI	AC1,-5(SP)			; AC1,GET%CHR%SUBROUTINE
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,SY%GENERIC			; SP,SY%GENERIC
	ADJSP	SP,-4				; SP,-4
	TRNE	AC1,1				; AC1,1
	JRST	L.252				; L.252
	MOVEI	AC1,12				; AC1,12									4154
	JRST	L.261				; L.261
L.252:	MOVE	AC14,-1(SP)			; AC14,STRING%LENGTH								4156
	JUMPLE	AC14,L.257			; AC14,L.257
	MOVE	AC16,0(SP)			; AC16,STRING%ADDRESS								4159
	MOVEI	AC1,-1(AC16)			; AC1,-1(AC16)
	HRLI	AC1,10700			; AC1,10700
	PUSH	SP,AC1				; SP,AC1
	PUSH	SP,AC14				; SP,AC14
	PUSH	SP,C.2				; SP,[1]
	PUSHJ	SP,U.30				; SP,SET%STRING
	MOVE	AC1,U.39			; AC1,SEND%PKT%SIZE								4161
	SUBI	AC1,3				; AC1,3
	CAML	AC14,AC1			; AC14,AC1
	JRST	L.256				; L.256
	PUSH	SP,C.2				; SP,[1]									4164
	PUSHJ	SP,U.29				; SP,BFR%FILL
	SETZM	-2(SP)				; -2(SP)									4166
	SETZM	-1(SP)				; -1(SP)
	SETZM	0(SP)				; 0(SP)
	PUSHJ	SP,U.30				; SP,SET%STRING
	CAMGE	AC1,AC14			; AC1,AC14
	JRST	L.255				; L.255
	PUSH	SP,C.20				; SP,[131]									4169
	PUSH	SP,U.50				; SP,SIZE
	PUSH	SP,U.54				; SP,REC%SEQ
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	ADJSP	SP,-3				; SP,-3
	TRNN	AC1,1				; AC1,1
	JRST	L.253				; L.253
	MOVEI	AC1,11				; AC1,11
	JRST	L.254				; L.254
L.253:	MOVEI	AC1,23				; AC1,23
L.254:	ADJSP	SP,-4				; SP,-4
	JRST	L.261				; L.261
L.255:	MOVEI	AC1,-1(AC16)			; AC1,-1(AC16)									4174
	HRLI	AC1,10700			; AC1,10700
	PUSH	SP,AC1				; SP,AC1
	PUSH	SP,AC14				; SP,AC14
	PUSH	SP,C.2				; SP,[1]
	PUSHJ	SP,U.30				; SP,SET%STRING
	ADJSP	SP,-4				; SP,-4										4163
L.256:	MOVEI	AC1,1				; AC1,1										4177
	MOVEM	AC1,U.62			; AC1,NO%FILE%NEEDED
	ADJSP	SP,-3				; SP,-3										4158
	JRST	L.258				; L.258										4156
L.257:	MOVE	AC1,-2(SP)			; AC1,GET%CHR%SUBROUTINE							4181
	JUMPE	AC1,L.258			; AC1,L.258
	MOVEM	AC1,U.66			; AC1,GET%CHR%ROUTINE								4184
	MOVEI	AC1,1				; AC1,1										4185
	MOVEM	AC1,U.62			; AC1,NO%FILE%NEEDED
L.258:	MOVEI	AC1,1				; AC1,1										4188
	MOVEM	AC1,U.61			; AC1,TEXT%HEAD%FLAG
	PUSH	SP,C.6				; SP,[111]									4189
	PUSH	SP,C.62				; SP,[107]
	PUSHJ	SP,XFR%STATUS			; SP,XFR%STATUS
	MOVEI	AC1,17				; AC1,17									4191
	CAME	AC1,U.49			; AC1,STATE
	JRST	L.259				; L.259
	MOVE	AC1,U.46			; AC1,BLK%CHK%TYPE
	CAME	AC1,U.45			; AC1,INI%CHK%TYPE
	JRST	L.259				; L.259
	MOVEI	AC1,22				; AC1,22									4195
	JRST	L.260				; L.260
L.259:	MOVEI	AC1,1				; AC1,1
L.260:	ADJSP	SP,-2				; SP,-2										4191
L.261:	ADJSP	SP,-3				; SP,-3										4100
	POP	SP,AC16				; SP,AC16
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,

; Routine Size:  86 words


;   4198  1	%SBTTL 'Message processing -- PRS%SEND%INIT - Parse send init params'
;   4199  1	ROUTINE PRS%SEND%INIT =
;   4200  1	
;   4201  1	!++
;   4202  1	! FUNCTIONAL DESCRIPTION:
;   4203  1	!
;   4204  1	!	This routine will parse the SEND%INIT parameters that were sent by
;   4205  1	!	the remote Kermit.  The items will be stored into the low segment.
;   4206  1	!
;   4207  1	! CALLING SEQUENCE:
;   4208  1	!
;   4209  1	!	PRS%SEND%INIT ();
;   4210  1	!
;   4211  1	! INPUT PARAMETERS:
;   4212  1	!
;   4213  1	!	None.
;   4214  1	!
;   4215  1	! IMPLICIT INPUTS:
;   4216  1	!
;   4217  1	!	Message stored in REC%MSG.
;   4218  1	!
;   4219  1	! OUTPUT PARAMETERS:
;   4220  1	!
;   4221  1	!	None.
;   4222  1	!
;   4223  1	! IMPLICIT OUTPUTS:
;   4224  1	!
;   4225  1	!	None.
;   4226  1	!
;   4227  1	! COMPLETION CODES:
;   4228  1	!
;   4229  1	!	None.
;   4230  1	!
;   4231  1	! SIDE EFFECTS:
;   4232  1	!
;   4233  1	!	None.
;   4234  1	!
;   4235  1	!--
;   4236  1	
;   4237  2	    BEGIN
;   4238  2	! The following section of code will parse the various send parameters
;   4239  2	! that are found in the send-init message.  The following code will store
;   4240  2	! the following as the value.
;   4241  2	!
;   4242  2	! If the user specified a value then the user supplied value will be used else
;   4243  2	! the value in the message and if none in the message then the default value.
;   4244  2	!
;   4245  2	! User supplied values are denoted as positive values in SND%xxxxxxx.
;   4246  2	!
;   4247  2	! Parse the packet size
;   4248  2	!
;   4249  3	    SEND%PKT%SIZE = (IF .SND%PKT%SIZE GEQ 0 THEN .SND%PKT%SIZE ELSE
;   4250  4		BEGIN
;   4251  4	
;   4252  4		IF .REC%LENGTH GTR P%SI%BUFSIZ
;   4253  4		THEN
; P 4254  4		    UNCHAR (CH$RCHAR (CH$PTR (REC%MSG,
;   4255  5				PKT%MSG + P%SI%BUFSIZ, CHR%SIZE)))
;   4256  4		ELSE
;   4257  4		    ABS (.SND%PKT%SIZE)
;   4258  4	
;   4259  4		END
;   4260  2	    );
;   4261  2	!
;   4262  2	! Parse the time out value
;   4263  2	!
;   4264  3	    SEND%TIMEOUT = (IF .SND%TIMEOUT GEQ 0 THEN .SND%TIMEOUT ELSE
;   4265  4		BEGIN
;   4266  4	
;   4267  4		IF .REC%LENGTH GTR P%SI%TIMOUT
;   4268  4		THEN
; P 4269  4		    UNCHAR (CH$RCHAR (CH$PTR (REC%MSG,
;   4270  5				PKT%MSG + P%SI%TIMOUT, CHR%SIZE)))
;   4271  4		ELSE
;   4272  4		    ABS (.SND%TIMEOUT)
;   4273  4	
;   4274  4		END
;   4275  2	    );
;   4276  2	!
;   4277  2	! Parse the number of padding characters supplied
;   4278  2	!
;   4279  3	    SEND%NPAD = (IF .SND%NPAD GEQ 0 THEN .SND%NPAD ELSE
;   4280  4		BEGIN
;   4281  4	
;   4282  4		IF .REC%LENGTH GTR P%SI%NPAD
;   4283  4		THEN
; P 4284  4		    UNCHAR (CH$RCHAR (CH$PTR (REC%MSG, PKT%MSG + P%SI%NPAD,
;   4285  5				CHR%SIZE)))
;   4286  4		ELSE
;   4287  4		    ABS (.SND%NPAD)
;   4288  4	
;   4289  4		END
;   4290  2	    );
;   4291  2	!
;   4292  2	! Parse the padding character
;   4293  2	!
;   4294  3	    SEND%PADCHAR = (IF .SND%PADCHAR GEQ 0 THEN .SND%PADCHAR ELSE
;   4295  4		BEGIN
;   4296  4	
;   4297  4		IF .REC%LENGTH GTR P%SI%PAD
;   4298  4		THEN
; P 4299  4		    CTL (CH$RCHAR (CH$PTR (REC%MSG, PKT%MSG + P%SI%PAD,
;   4300  5				CHR%SIZE)))
;   4301  4		ELSE
;   4302  4		    ABS (.SND%PADCHAR)
;   4303  4	
;   4304  4		END
;   4305  2	    );
;   4306  2	!
;   4307  2	! Parse the end of line character
;   4308  2	!
;   4309  3	    SEND%EOL = (IF .SND%EOL GEQ 0 THEN .SND%EOL ELSE
;   4310  4		BEGIN
;   4311  4	
;   4312  4		IF .REC%LENGTH GTR P%SI%EOL
;   4313  4		THEN
; P 4314  4		    UNCHAR (CH$RCHAR (CH$PTR (REC%MSG, PKT%MSG + P%SI%EOL,
;   4315  5				CHR%SIZE)))
;   4316  4		ELSE
;   4317  4		    ABS (.SND%EOL)
;   4318  4	
;   4319  4		END
;   4320  2	    );
;   4321  2	!
;   4322  2	! Parse the quoting character
;   4323  2	!
;   4324  3	    SEND%QUOTE%CHR = (IF .SND%QUOTE%CHR GEQ 0 THEN .SND%QUOTE%CHR ELSE
;   4325  4		BEGIN
;   4326  4	
;   4327  4		IF .REC%LENGTH GTR P%SI%QUOTE
;   4328  4		THEN
;   4329  4		    CH$RCHAR (CH$PTR (REC%MSG, PKT%MSG + P%SI%QUOTE,
;   4330  4			    CHR%SIZE))
;   4331  4		ELSE
;   4332  4		    ABS (.SND%QUOTE%CHR)
;   4333  4	
;   4334  4		END
;   4335  2	    );
;   4336  2	!
;   4337  2	! Parse the 8-bit quoting character
;   4338  2	!
;   4339  2	! If the character was not included in the packet, assume no eight-bit
;   4340  2	! quoting allowed (we are probably talking to an old version of Kermit).
;   4341  2	!
;   4342  3	    SEND%8QUOTE%CHR = (IF .REC%LENGTH GTR P%SI%8QUOTE THEN CH$RCHAR (CH$PTR (REC%MSG,
;   4343  3			PKT%MSG + P%SI%8QUOTE, CHR%SIZE)) ELSE %C'N'	! Assume no 8-bit quoting allowed
;   4344  2	    );
;   4345  2	!
;   4346  2	! Parse the checksum type
;   4347  2	!
;   4348  2	
;   4349  2	    IF .REC%LENGTH GTR P%SI%CHKTYPE
;   4350  2	    THEN
;   4351  3		BEGIN
;   4352  3	
;   4353  3		LOCAL
;   4354  3		    REQ%CHK%TYPE;
;   4355  3	
;   4356  3		REQ%CHK%TYPE = CH$RCHAR (CH$PTR (REC%MSG, PKT%MSG + P%SI%CHKTYPE, CHR%SIZE));
;   4357  3	
;   4358  3		IF .REC%TYPE NEQ MSG%ACK
;   4359  3		THEN
;   4360  3	
;   4361  3		    IF .REQ%CHK%TYPE GEQ CHK%1CHAR AND .REQ%CHK%TYPE LEQ CHK%CRC
;   4362  3		    THEN
;   4363  3			INI%CHK%TYPE = .REQ%CHK%TYPE
;   4364  3		    ELSE
;   4365  3			INI%CHK%TYPE = CHK%1CHAR
;   4366  3	
;   4367  3		ELSE
;   4368  3	
;   4369  3		    IF .REQ%CHK%TYPE NEQ .CHKTYPE
;   4370  3		    THEN
;   4371  3			INI%CHK%TYPE = CHK%1CHAR
;   4372  3		    ELSE
;   4373  3			INI%CHK%TYPE = .REQ%CHK%TYPE
;   4374  3	
;   4375  3		END
;   4376  2	    ELSE
;   4377  2		INI%CHK%TYPE = CHK%1CHAR;		! Only single character checksum if not specified
;   4378  2	
;   4379  2	!
;   4380  2	! Parse the repeat character
;   4381  2	!
;   4382  3	    REPT%CHR = (IF .REC%LENGTH GTR P%SI%REPEAT THEN CH$RCHAR (CH$PTR (REC%MSG,
;   4383  2			PKT%MSG + P%SI%REPEAT, CHR%SIZE)) ELSE %C' ');
;   4384  2	!
;   4385  2	! Check for a valid quoting character.  If it is not valid, then we have
;   4386  2	! a protocol error
;   4387  2	!
;   4388  2	
;   4389  4	    IF NOT ((.SEND%QUOTE%CHR GEQ %O'41' AND .SEND%QUOTE%CHR LEQ %O'76') OR (.SEND%QUOTE%CHR GEQ %O
;   4390  3		'140' AND .SEND%QUOTE%CHR LEQ %O'176'))
;   4391  2	    THEN
;   4392  3		BEGIN
;   4393  3		KRM%ERROR (KER%PROTOERR);
;   4394  3		RETURN KER%PROTOERR;
;   4395  2		END;
;   4396  2	
;   4397  2	!
;   4398  2	! Check for a valid 8 bit quoting and set the 8 bit quoting flag as needed
;   4399  2	!
;   4400  2	
;   4401  5	    IF ( NOT ((.SEND%8QUOTE%CHR GEQ %O'041' AND .SEND%8QUOTE%CHR LEQ %O'076') OR (.SEND%8QUOTE%CHR
;   4402  5		GEQ %O'140' AND .SEND%8QUOTE%CHR LEQ %O'176') OR (.SEND%8QUOTE%CHR EQL %C'N') OR (
;   4403  2		.SEND%8QUOTE%CHR EQL %C'Y'))) OR .SEND%8QUOTE%CHR EQL .SEND%QUOTE%CHR OR .SEND%8QUOTE%CHR
;   4404  2		EQL .RCV%QUOTE%CHR
;   4405  2	    THEN
;   4406  3		BEGIN
;   4407  3		KRM%ERROR (KER%PROTOERR);
;   4408  3		RETURN KER%PROTOERR;
;   4409  2		END;
;   4410  2	
;   4411  2	    IF .SEND%8QUOTE%CHR EQL %C'Y' THEN SEND%8QUOTE%CHR = .RECV%8QUOTE%CHR;
;   4412  2	
;   4413  2	    IF .SEND%8QUOTE%CHR NEQ %C'N' AND .SEND%8QUOTE%CHR NEQ %C'Y'
;   4414  2	    THEN
;   4415  2		FLAG%8QUOTE = TRUE
;   4416  2	    ELSE
;   4417  2		FLAG%8QUOTE = FALSE;
;   4418  2	
;   4419  2	!
;   4420  2	! Check the repeat character and set flags
;   4421  2	!
;   4422  2	
;   4423  5	    IF ( NOT ((.REPT%CHR GEQ %O'41' AND .REPT%CHR LEQ %O'76') OR (.REPT%CHR GEQ %O'140' AND
;   4424  3		.REPT%CHR LEQ %O'176')) OR .REPT%CHR EQL .SEND%QUOTE%CHR OR .REPT%CHR EQL .SEND%8QUOTE%CHR
;   4425  2		OR .REPT%CHR EQL .RCV%QUOTE%CHR) AND .REPT%CHR NEQ %C' '
;   4426  2	    THEN
;   4427  3		BEGIN
;   4428  3		KRM%ERROR (KER%PROTOERR);
;   4429  3		RETURN KER%PROTOERR;
;   4430  2		END;
;   4431  2	
;   4432  2	    IF .REPT%CHR NEQ %C' ' THEN FLAG%REPEAT = TRUE ELSE FLAG%REPEAT = FALSE;
;   4433  2	
;   4434  2	    RETURN KER%NORMAL;
;   4435  1	    END;					! End of PRS%SEND%INIT


; PRS%SEND%INIT
U.21:	MOVE	AC1,SND%PKT%SIZE		; AC1,SND%PKT%SIZE								4249
	JUMPGE	AC1,L.263			; AC1,L.263
	SKIPG	U.55				; REC%LENGTH									4252
	JRST	L.262				; L.262
	MOVE	AC1,C.29			; AC1,[POINT 8,REC%MSG,31]  <4,8>						4255
	ILDB	AC1,AC1				; AC1,AC1
	SUBI	AC1,40				; AC1,40
	JRST	L.263				; L.263										4250
L.262:	MOVM	AC1,AC1				; AC1,AC1									4257
L.263:	MOVEM	AC1,U.39			; AC1,SEND%PKT%SIZE								4249
	MOVE	AC1,SND%TIMEOUT			; AC1,SND%TIMEOUT								4264
	JUMPGE	AC1,L.265			; AC1,L.265
	MOVEI	AC2,1				; AC2,1										4267
	CAML	AC2,U.55			; AC2,REC%LENGTH
	JRST	L.264				; L.264
	MOVE	AC1,C.65			; AC1,[POINT 8,REC%MSG+1,7]  <28,8>						4270
	ILDB	AC1,AC1				; AC1,AC1
	SUBI	AC1,40				; AC1,40
	JRST	L.265				; L.265										4265
L.264:	MOVM	AC1,AC1				; AC1,AC1									4272
L.265:	MOVEM	AC1,SEND%TIMEOUT		; AC1,SEND%TIMEOUT								4264
	MOVE	AC1,SND%NPAD			; AC1,SND%NPAD									4279
	JUMPGE	AC1,L.267			; AC1,L.267
	MOVEI	AC2,2				; AC2,2										4282
	CAML	AC2,U.55			; AC2,REC%LENGTH
	JRST	L.266				; L.266
	MOVE	AC1,C.66			; AC1,[POINT 8,REC%MSG+1,15]  <20,8>						4285
	ILDB	AC1,AC1				; AC1,AC1
	SUBI	AC1,40				; AC1,40
	JRST	L.267				; L.267										4280
L.266:	MOVM	AC1,AC1				; AC1,AC1									4287
L.267:	MOVEM	AC1,U.40			; AC1,SEND%NPAD									4279
	MOVE	AC1,SND%PADCHAR			; AC1,SND%PADCHAR								4294
	JUMPGE	AC1,L.269			; AC1,L.269
	MOVEI	AC2,3				; AC2,3										4297
	CAML	AC2,U.55			; AC2,REC%LENGTH
	JRST	L.268				; L.268
	MOVE	AC1,C.67			; AC1,[POINT 8,REC%MSG+1,23]  <12,8>						4300
	ILDB	AC1,AC1				; AC1,AC1
	TRCA	AC1,100				; AC1,100
L.268:	MOVM	AC1,AC1				; AC1,AC1									4302
L.269:	MOVEM	AC1,U.41			; AC1,SEND%PADCHAR								4294
	MOVE	AC1,SND%EOL			; AC1,SND%EOL									4309
	JUMPGE	AC1,L.271			; AC1,L.271
	MOVEI	AC2,4				; AC2,4										4312
	CAML	AC2,U.55			; AC2,REC%LENGTH
	JRST	L.270				; L.270
	MOVE	AC1,C.68			; AC1,[POINT 8,REC%MSG+1,31]  <4,8>						4315
	ILDB	AC1,AC1				; AC1,AC1
	SUBI	AC1,40				; AC1,40
	JRST	L.271				; L.271										4310
L.270:	MOVM	AC1,AC1				; AC1,AC1									4317
L.271:	MOVEM	AC1,U.42			; AC1,SEND%EOL									4309
	MOVE	AC1,SND%QUOTE%CHR		; AC1,SND%QUOTE%CHR								4324
	JUMPGE	AC1,L.273			; AC1,L.273
	MOVEI	AC2,5				; AC2,5										4327
	CAML	AC2,U.55			; AC2,REC%LENGTH
	JRST	L.272				; L.272
	MOVE	AC1,C.69			; AC1,[POINT 8,REC%MSG+2,7]  <28,8>						4329
	ILDB	AC1,AC1				; AC1,AC1
	JRST	L.273				; L.273										4325
L.272:	MOVM	AC1,AC1				; AC1,AC1									4332
L.273:	MOVEM	AC1,U.43			; AC1,SEND%QUOTE%CHR								4324
	MOVE	AC2,U.55			; AC2,REC%LENGTH								4342
	CAIG	AC2,6				; AC2,6
	JRST	L.274				; L.274
	MOVE	AC1,C.70			; AC1,[POINT 8,REC%MSG+2,15]  <20,8>
	ILDB	AC1,AC1				; AC1,AC1
	JRST	L.275				; L.275
L.274:	MOVEI	AC1,116				; AC1,116
L.275:	MOVEM	AC1,U.44			; AC1,SEND%8QUOTE%CHR
	CAIG	AC2,7				; AC2,7										4349
	JRST	L.278				; L.278
	MOVE	AC1,C.71			; AC1,[POINT 8,REC%MSG+2,23]  <12,8>						4356
	ILDB	AC1,AC1				; REQ%CHK%TYPE,AC1
	MOVEI	AC3,131				; AC3,131									4358
	CAMN	AC3,U.56			; AC3,REC%TYPE
	JRST	L.276				; L.276
	CAIL	AC1,61				; REQ%CHK%TYPE,61								4361
	CAILE	AC1,63				; REQ%CHK%TYPE,63
	JRST	L.277				; L.277
	JRST	L.279				; L.279
L.276:	CAMN	AC1,CHKTYPE			; REQ%CHK%TYPE,CHKTYPE								4369
	JRST	L.279				; L.279
L.277:	MOVEI	AC3,61				; AC3,61									4371
	MOVEM	AC3,U.45			; AC3,INI%CHK%TYPE
	JRST	L.280				; L.280										4369
L.278:	MOVEI	AC1,61				; AC1,61									4377
L.279:	MOVEM	AC1,U.45			; AC1,INI%CHK%TYPE
L.280:	CAIG	AC2,10				; AC2,10									4382
	JRST	L.281				; L.281
	MOVE	AC1,C.72			; AC1,[POINT 8,REC%MSG+2,31]  <4,8>
	ILDB	AC1,AC1				; AC1,AC1
	JRST	L.282				; L.282
L.281:	MOVEI	AC1,40				; AC1,40
L.282:	MOVEM	AC1,U.38			; AC1,REPT%CHR
	MOVE	AC1,U.43			; AC1,SEND%QUOTE%CHR								4389
	CAIGE	AC1,41				; AC1,41
	JRST	L.283				; L.283
	CAIG	AC1,76				; AC1,76
	JRST	L.284				; L.284
L.283:	CAIL	AC1,140				; AC1,140
	CAILE	AC1,176				; AC1,176									4390
	JRST	L.294				; L.294										4392
L.284:	MOVE	AC1,U.44			; AC1,SEND%8QUOTE%CHR								4401
	CAIGE	AC1,41				; AC1,41
	JRST	L.285				; L.285
	CAIG	AC1,76				; AC1,76
	JRST	L.287				; L.287
L.285:	CAIGE	AC1,140				; AC1,140									4402
	JRST	L.286				; L.286
	CAIG	AC1,176				; AC1,176
	JRST	L.287				; L.287
L.286:	CAIN	AC1,116				; AC1,116
	JRST	L.287				; L.287
	CAIE	AC1,131				; AC1,131
	JRST	L.294				; L.294
L.287:	CAME	AC1,U.43			; AC1,SEND%QUOTE%CHR								4403
	CAMN	AC1,RCV%QUOTE%CHR		; AC1,RCV%QUOTE%CHR								4404
	JRST	L.294				; L.294										4406
	MOVEI	AC1,131				; AC1,131									4411
	CAME	AC1,U.44			; AC1,SEND%8QUOTE%CHR
	JRST	L.288				; L.288
	MOVE	AC1,U.37			; AC1,RECV%8QUOTE%CHR
	MOVEM	AC1,U.44			; AC1,SEND%8QUOTE%CHR
L.288:	MOVE	AC2,U.44			; AC2,SEND%8QUOTE%CHR								4413
	CAIE	AC2,116				; AC2,116
	CAIN	AC2,131				; AC2,131
	JRST	L.289				; L.289
	MOVEI	AC1,1				; AC1,1										4415
	MOVEM	AC1,U.47			; AC1,FLAG%8QUOTE
	JRST	L.290				; L.290										4413
L.289:	SETZM	U.47				; FLAG%8QUOTE									4417
L.290:	MOVE	AC1,U.38			; AC1,REPT%CHR									4423
	CAIGE	AC1,41				; AC1,41
	JRST	L.291				; L.291
	CAIG	AC1,76				; AC1,76
	JRST	L.292				; L.292
L.291:	CAIL	AC1,140				; AC1,140
	CAILE	AC1,176				; AC1,176									4424
	JRST	L.293				; L.293
L.292:	CAME	AC1,U.43			; AC1,SEND%QUOTE%CHR
	CAMN	AC1,AC2				; AC1,AC2
	JRST	L.293				; L.293
	CAME	AC1,RCV%QUOTE%CHR		; AC1,RCV%QUOTE%CHR								4425
	JRST	L.295				; L.295
L.293:	CAIN	AC1,40				; AC1,40
	JRST	L.295				; L.295
L.294:	PUSH	SP,C.22				; SP,[252]									4428
	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
	ADJSP	SP,-1				; SP,-1										4429
	MOVEI	AC1,252				; AC1,252									4427
	POPJ	SP,				; SP,
L.295:	MOVEI	AC1,40				; AC1,40									4432
	CAMN	AC1,U.38			; AC1,REPT%CHR
	JRST	L.296				; L.296
	MOVEI	AC1,1				; AC1,1
	MOVEM	AC1,U.48			; AC1,FLAG%REPEAT
	JRST	L.297				; L.297
L.296:	SETZM	U.48				; FLAG%REPEAT
L.297:	MOVEI	AC1,13				; AC1,13									4237
	POPJ	SP,				; SP,										4199
C.65:	POINT	8,U.57+1,7			; 8,REC%MSG+1,7
C.66:	POINT	8,U.57+1,15			; 8,REC%MSG+1,15
C.67:	POINT	8,U.57+1,23			; 8,REC%MSG+1,23
C.68:	POINT	8,U.57+1,31			; 8,REC%MSG+1,31
C.69:	POINT	8,U.57+2,7			; 8,REC%MSG+2,7
C.70:	POINT	8,U.57+2,15			; 8,REC%MSG+2,15
C.71:	POINT	8,U.57+2,23			; 8,REC%MSG+2,23
C.72:	POINT	8,U.57+2,31			; 8,REC%MSG+2,31

; Routine Size:  170 words


;   4436  1	%SBTTL 'SET%SEND%INIT'
;   4437  1	ROUTINE SET%SEND%INIT : NOVALUE =
;   4438  1	
;   4439  1	!++
;   4440  1	! FUNCTIONAL DESCRIPTION:
;   4441  1	!
;   4442  1	!	This routine will initialize the various parameters for the
;   4443  1	!	MSG%SND%INIT message.
;   4444  1	!
;   4445  1	! CALLING SEQUENCE:
;   4446  1	!
;   4447  1	!	SET%SEND%INIT();
;   4448  1	!
;   4449  1	! INPUT PARAMETERS:
;   4450  1	!
;   4451  1	!	None.
;   4452  1	!
;   4453  1	! IMPLICIT INPUTS:
;   4454  1	!
;   4455  1	!	None.
;   4456  1	!
;   4457  1	! OUTPUT PARAMETERS:
;   4458  1	!
;   4459  1	!	None.
;   4460  1	!
;   4461  1	! IMPLICIT OUTPUTS:
;   4462  1	!
;   4463  1	!	SND%MSG parameters set up.
;   4464  1	!
;   4465  1	! COMPLETION CODES:
;   4466  1	!
;   4467  1	!	None.
;   4468  1	!
;   4469  1	! SIDE EFFECTS:
;   4470  1	!
;   4471  1	!	None.
;   4472  1	!
;   4473  1	!--
;   4474  1	
;   4475  2	    BEGIN
;   4476  2	    CH$WCHAR (CHAR (.RCV%PKT%SIZE), CH$PTR (SND%MSG, PKT%MSG + P%SI%BUFSIZ, CHR%SIZE));
;   4477  2	    CH$WCHAR (CHAR (.RCV%TIMEOUT), CH$PTR (SND%MSG, PKT%MSG + P%SI%TIMOUT, CHR%SIZE));
;   4478  2	    CH$WCHAR (CHAR (.RCV%NPAD), CH$PTR (SND%MSG, PKT%MSG + P%SI%NPAD, CHR%SIZE));
;   4479  2	    CH$WCHAR (CTL (.RCV%PADCHAR), CH$PTR (SND%MSG, PKT%MSG + P%SI%PAD, CHR%SIZE));
;   4480  2	    CH$WCHAR (CHAR (.RCV%EOL), CH$PTR (SND%MSG, PKT%MSG + P%SI%EOL, CHR%SIZE));
;   4481  2	    CH$WCHAR (.RCV%QUOTE%CHR, CH$PTR (SND%MSG, PKT%MSG + P%SI%QUOTE, CHR%SIZE));
;   4482  2	    CH$WCHAR (.SEND%8QUOTE%CHR, CH$PTR (SND%MSG, PKT%MSG + P%SI%8QUOTE, CHR%SIZE));
;   4483  2	    CH$WCHAR (.INI%CHK%TYPE, CH$PTR (SND%MSG, PKT%MSG + P%SI%CHKTYPE, CHR%SIZE));
;   4484  2	    CH$WCHAR (.REPT%CHR, CH$PTR (SND%MSG, PKT%MSG + P%SI%REPEAT, CHR%SIZE));
;   4485  1	    END;					! End of SET%SEND%INIT


; SET%SEND%INIT
U.20:	MOVE	AC2,RCV%PKT%SIZE		; AC2,RCV%PKT%SIZE								4476
	ADDI	AC2,40				; AC2,40
	MOVE	AC1,C.33			; AC1,[POINT 8,SND%MSG,31]  <4,8>
	IDPB	AC2,AC1				; AC2,AC1
	MOVE	AC2,RCV%TIMEOUT			; AC2,RCV%TIMEOUT								4477
	ADDI	AC2,40				; AC2,40
	MOVE	AC1,C.73			; AC1,[POINT 8,SND%MSG+1,7]  <28,8>
	IDPB	AC2,AC1				; AC2,AC1
	MOVE	AC2,RCV%NPAD			; AC2,RCV%NPAD									4478
	ADDI	AC2,40				; AC2,40
	MOVE	AC1,C.74			; AC1,[POINT 8,SND%MSG+1,15]  <20,8>
	IDPB	AC2,AC1				; AC2,AC1
	MOVE	AC2,RCV%PADCHAR			; AC2,RCV%PADCHAR								4479
	TRC	AC2,100				; AC2,100
	MOVE	AC1,C.75			; AC1,[POINT 8,SND%MSG+1,23]  <12,8>
	IDPB	AC2,AC1				; AC2,AC1
	MOVE	AC2,RCV%EOL			; AC2,RCV%EOL									4480
	ADDI	AC2,40				; AC2,40
	MOVE	AC1,C.76			; AC1,[POINT 8,SND%MSG+1,31]  <4,8>
	IDPB	AC2,AC1				; AC2,AC1
	MOVE	AC2,RCV%QUOTE%CHR		; AC2,RCV%QUOTE%CHR								4481
	MOVE	AC1,C.77			; AC1,[POINT 8,SND%MSG+2,7]  <28,8>
	IDPB	AC2,AC1				; AC2,AC1
	MOVE	AC2,U.44			; AC2,SEND%8QUOTE%CHR								4482
	MOVE	AC1,C.78			; AC1,[POINT 8,SND%MSG+2,15]  <20,8>
	IDPB	AC2,AC1				; AC2,AC1
	MOVE	AC2,U.45			; AC2,INI%CHK%TYPE								4483
	MOVE	AC1,C.79			; AC1,[POINT 8,SND%MSG+2,23]  <12,8>
	IDPB	AC2,AC1				; AC2,AC1
	MOVE	AC2,U.38			; AC2,REPT%CHR									4484
	MOVE	AC1,C.80			; AC1,[POINT 8,SND%MSG+2,31]  <4,8>
	IDPB	AC2,AC1				; AC2,AC1
	POPJ	SP,				; SP,										4437
C.73:	POINT	8,U.58+1,7			; 8,SND%MSG+1,7
C.74:	POINT	8,U.58+1,15			; 8,SND%MSG+1,15
C.75:	POINT	8,U.58+1,23			; 8,SND%MSG+1,23
C.76:	POINT	8,U.58+1,31			; 8,SND%MSG+1,31
C.77:	POINT	8,U.58+2,7			; 8,SND%MSG+2,7
C.78:	POINT	8,U.58+2,15			; 8,SND%MSG+2,15
C.79:	POINT	8,U.58+2,23			; 8,SND%MSG+2,23
C.80:	POINT	8,U.58+2,31			; 8,SND%MSG+2,31

; Routine Size:  41 words


;   4486  1	%SBTTL 'SEND%PACKET'
;   4487  1	ROUTINE SEND%PACKET (TYPE, LENGTH, MN) =
;   4488  1	
;   4489  1	!++
;   4490  1	! FUNCTIONAL DESCRIPTION:
;   4491  1	!
;   4492  1	!	This routine will cause a packet to be sent over the line
;   4493  1	!	that has been opened by OPEN%TERMINAL.
;   4494  1	!
;   4495  1	! CALLING SEQUENCE:
;   4496  1	!
;   4497  1	!	SEND%PACKET(Type, Length);
;   4498  1	!
;   4499  1	! INPUT PARAMETERS:
;   4500  1	!
;   4501  1	!	TYPE - Type of packet to send.
;   4502  1	!
;   4503  1	!	LENGTH - Length of the packet being sent.
;   4504  1	!
;   4505  1	! IMPLICIT INPUTS:
;   4506  1	!
;   4507  1	!	None.
;   4508  1	!
;   4509  1	! OUTPUT PARAMETERS:
;   4510  1	!
;   4511  1	!	None.
;   4512  1	!
;   4513  1	! IMPLICIT OUTPUTS:
;   4514  1	!
;   4515  1	!	None.
;   4516  1	!
;   4517  1	! COMPLETION CODES:
;   4518  1	!
;   4519  1	!	None.
;   4520  1	!
;   4521  1	! SIDE EFFECTS:
;   4522  1	!
;   4523  1	!	None.
;   4524  1	!
;   4525  1	!--
;   4526  1	
;   4527  2	    BEGIN
;   4528  2	
;   4529  2	    LOCAL
;   4530  2		FILLER : VECTOR [CH$ALLOCATION (MAX%MSG, CHR%SIZE)],
;   4531  2		TOT%MSG%LEN,				! Length of message including all characters
;   4532  2		CHKSUM,					! Checksum for the message we calculate
;   4533  2		POINTER;				! Pointer to the information in the message
;   4534  2	
;   4535  2	!
;   4536  2	! Do any filler processing that the remote KERMIT requires.
;   4537  2	!
;   4538  2	
;   4539  2	    IF .SEND%NPAD NEQ 0
;   4540  2	    THEN
;   4541  3		BEGIN
;   4542  3		CH$FILL (.SEND%PADCHAR, MAX%MSG, CH$PTR (FILLER, 0, CHR%SIZE));
;   4543  3	!
;   4544  3	! Update the send stats
;   4545  3	!
;   4546  3		SMSG%TOTAL%CHARS = .SMSG%TOTAL%CHARS + .SEND%NPAD;
;   4547  3	!
;   4548  3	! Send the fill
;   4549  3	!
;   4550  3		DO%PARITY (FILLER, .SEND%NPAD + PKT%TOT%OVR%HEAD);
;   4551  3		SEND (FILLER, .SEND%NPAD + PKT%TOT%OVR%HEAD);
;   4552  2		END;
;   4553  2	
;   4554  2	!
;   4555  2	! Store the header information into the message.
;   4556  2	!
;   4557  2	    CH$WCHAR (.TYPE, CH$PTR (SND%MSG, PKT%TYPE, CHR%SIZE));
;   4558  2	    CH$WCHAR (.SND%SOH, CH$PTR (SND%MSG, PKT%MARK, CHR%SIZE));
;   4559  2	    CH$WCHAR (CHAR (.LENGTH + PKT%OVR%HEAD + (.BLK%CHK%TYPE - CHK%1CHAR)),
;   4560  2		CH$PTR (SND%MSG,
;   4561  2		    PKT%COUNT, CHR%SIZE));
;   4562  2	    CH$WCHAR (CHAR ((IF .MN LSS 0 THEN 0 ELSE .MN)), CH$PTR (SND%MSG, PKT%SEQ, CHR%SIZE));
;   4563  2	!
;   4564  2	! Calculate the block check value
;   4565  2	!
;   4566  2	    POINTER = CH$PTR (SND%MSG, PKT%MARK + 1, CHR%SIZE);
;   4567  2	    CHKSUM = CALC%BLOCK%CHECK (.POINTER, .LENGTH + PKT%OVR%HEAD);
;   4568  2	    TOT%MSG%LEN = .LENGTH + PKT%TOT%OVR%HEAD;
;   4569  2	!
;   4570  2	! Store the checksum into the message
;   4571  2	!
;   4572  2	    POINTER = CH$PTR (SND%MSG, .LENGTH + PKT%OVR%HEAD + 1, CHR%SIZE);
;   4573  2	
;   4574  2	    CASE .BLK%CHK%TYPE FROM CHK%1CHAR TO CHK%CRC OF
;   4575  2		SET
;   4576  2	
;   4577  2		[CHK%1CHAR] :
;   4578  2		    CH$WCHAR%A (CHAR (.CHKSUM), POINTER);
;   4579  2	
;   4580  2		[CHK%2CHAR] :
;   4581  3		    BEGIN
;   4582  3		    CH$WCHAR%A (CHAR (.CHKSUM<6, 6>), POINTER);
;   4583  3		    CH$WCHAR%A (CHAR (.CHKSUM<0, 6>), POINTER);
;   4584  3		    TOT%MSG%LEN = .TOT%MSG%LEN + 1;
;   4585  2		    END;
;   4586  2	
;   4587  2		[CHK%CRC] :
;   4588  3		    BEGIN
;   4589  3		    CH$WCHAR%A (CHAR (.CHKSUM<12, 4>), POINTER);
;   4590  3		    CH$WCHAR%A (CHAR (.CHKSUM<6, 6>), POINTER);
;   4591  3		    CH$WCHAR%A (CHAR (.CHKSUM<0, 6>), POINTER);
;   4592  3		    TOT%MSG%LEN = .TOT%MSG%LEN + 2;
;   4593  2		    END;
;   4594  2		TES;
;   4595  2	
;   4596  2	!
;   4597  2	! Store in the end of line character
;   4598  2	!
;   4599  2	    CH$WCHAR%A (.SEND%EOL, POINTER);
;   4600  2	!
;   4601  2	! If we are debugging then type out the message we are sending.
;   4602  2	!
;   4603  2	    DBG%SEND (SND%MSG, (.TOT%MSG%LEN));
;   4604  2	!
;   4605  2	! Update the stats for total characters and the data characters
;   4606  2	!
;   4607  2	    SMSG%TOTAL%CHARS = .SMSG%TOTAL%CHARS + .TOT%MSG%LEN;
;   4608  2	! Make data characters really be that, not just characters in data field
;   4609  2	!    SMSG%DATA%CHARS = .SMSG%DATA%CHARS + .LENGTH;
;   4610  2	
;   4611  2	    IF .TYPE EQL MSG%NAK
;   4612  2	    THEN
;   4613  3		BEGIN
;   4614  3		SMSG%NAKS = .SMSG%NAKS + 1;
;   4615  3		XFR%STATUS (%C'S', %C'N');
;   4616  3		END
;   4617  2	    ELSE
;   4618  3		BEGIN
;   4619  3		SMSG%COUNT = .SMSG%COUNT + 1;
;   4620  3		XFR%STATUS (%C'S', %C'P');
;   4621  2		END;
;   4622  2	
;   4623  2	!
;   4624  2	! Check if we are in IBM mode and need to wait for an XON first
;   4625  2	! We will not wait if this is a packet which might be going out
;   4626  2	! without previous traffic (generic commands, init packets).
;   4627  2	
;   4628  3	    IF .IBM%FLAG AND NOT (.TYPE EQL MSG%SND%INIT OR .TYPE EQL MSG%SER%INIT OR .TYPE EQL MSG%RCV%INIT
;   4629  3		OR .TYPE EQL MSG%COMMAND OR .TYPE EQL MSG%GENERIC)
;   4630  2	    THEN
;   4631  2	
;   4632  2		IF NOT IBM%WAIT () THEN RETURN KER%ABORTED;
;   4633  2	
;   4634  2	!
;   4635  2	! Now call the O/S routine to send the message out to the remote KERMIT
;   4636  2	!
;   4637  2	    DO%PARITY (SND%MSG, .TOT%MSG%LEN);
;   4638  2	    RETURN SEND (SND%MSG, .TOT%MSG%LEN);
;   4639  1	    END;					! End of SEND%PACKET


; SEND%PACKET
U.24:	PUSH	SP,AC13				; SP,AC13									4487
	PUSH	SP,AC14				; SP,AC14
	PUSH	SP,AC16				; SP,AC16
	ADJSP	SP,32				; SP,32
	MOVE	AC3,U.40			; AC3,SEND%NPAD									4539
	JUMPE	AC3,L.298			; AC3,L.298
	MOVEI	AC5,-32(SP)			; AC5,FILLER-1									4542
	HRLI	AC5,41000			; AC5,41000
	SETZB	AC1,AC2				; AC1,AC2
	MOVEI	AC4,140				; AC4,140
	MOVEI	AC13,-2(SP)			; AC13,-2(SP)
	PUSH	AC13,C.9			; AC13,[MOVSLJ ]
	PUSH	AC13,U.41			; AC13,SEND%PADCHAR
	EXTEND	AC1,-1(SP)			; AC1,-1(SP)
	JFCL					;
	ADDM	AC3,SMSG%TOTAL%CHARS		; AC3,SMSG%TOTAL%CHARS								4546
	MOVEI	AC1,-31(SP)			; AC1,FILLER									4550
	PUSH	SP,AC1				; SP,AC1
	ADDI	AC3,6				; AC3,6
	PUSH	SP,AC3				; SP,AC3
	PUSHJ	SP,U.22				; SP,DO%PARITY
	MOVEI	AC1,-33(SP)			; AC1,FILLER									4551
	PUSH	SP,AC1				; SP,AC1
	MOVE	AC1,U.40			; AC1,SEND%NPAD
	ADDI	AC1,6				; AC1,6
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,SEND				; SP,SEND
	ADJSP	SP,-4				; SP,-4										4541
L.298:	MOVE	AC2,-40(SP)			; AC2,TYPE									4557
	MOVE	AC1,C.84			; AC1,[POINT 8,SND%MSG,23]  <12,8>
	IDPB	AC2,AC1				; AC2,AC1
	MOVE	AC2,SND%SOH			; AC2,SND%SOH									4558
	MOVE	AC1,C.85			; AC1,[POINT 8,SND%MSG-1,31]  <4,8>
	IDPB	AC2,AC1				; AC2,AC1
	MOVE	AC13,-37(SP)			; AC13,LENGTH									4559
	MOVE	AC14,AC13			; AC14,AC13
	ADD	AC14,U.46			; AC14,BLK%CHK%TYPE
	SUBI	AC14,16				; AC14,16
	MOVE	AC1,C.86			; AC1,[POINT 8,SND%MSG,7]  <28,8>						4560
	IDPB	AC14,AC1			; AC14,AC1									4559
	SKIPGE	AC1,-36(SP)			; AC1,MN									4562
	SETZ	AC1,				; AC1,
	ADDI	AC1,40				; AC1,40
	MOVE	AC2,C.87			; AC2,[POINT 8,SND%MSG,15]  <20,8>
	IDPB	AC1,AC2				; AC1,AC2
	MOVE	AC16,C.86			; POINTER,[POINT 8,SND%MSG,7]  <28,8>						4566
	PUSH	SP,AC16				; SP,POINTER									4567
	MOVE	AC1,AC13			; AC1,AC13
	ADDI	AC1,3				; AC1,3
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,U.19				; SP,CALC%BLOCK%CHECK
	MOVE	AC14,AC13			; TOT%MSG%LEN,AC13								4568
	ADDI	AC14,6				; TOT%MSG%LEN,6
	ADDI	AC13,4				; AC13,4									4572
	MOVE	AC3,C.81			; AC3,[POINT 8,SND%MSG,-1]  <36,8>
	MOVE	AC2,AC13			; AC2,AC13
	ADJBP	AC2,AC3				; AC2,AC3
	MOVE	AC16,AC2			; POINTER,AC2
	MOVE	AC2,U.46			; AC2,BLK%CHK%TYPE								4574
	SUBI	AC2,61				; AC2,61
	JRST	L.299(AC2)			; L.299(AC2)
L.299:	JRST	L.300				; L.300
	JRST	L.301				; L.301
	JRST	L.302				; L.302
L.300:	MOVE	AC2,AC1				; AC2,CHKSUM									4578
	ADDI	AC2,40				; AC2,40
	IDPB	AC2,AC16			; AC2,POINTER
	JRST	L.303				; L.303										4574
L.301:	LDB	AC2,C.82			; AC2,[POINT 6,CHKSUM,29]  <6,6>						4582
	ADDI	AC2,40				; AC2,40
	IDPB	AC2,AC16			; AC2,POINTER
	LDB	AC2,C.18			; AC2,[POINT 6,AC1,35]  <0,6>							4583
	ADDI	AC2,40				; AC2,40
	IDPB	AC2,AC16			; AC2,POINTER
	AOJA	AC14,L.303			; TOT%MSG%LEN,L.303								4574
L.302:	LDB	AC2,C.83			; AC2,[POINT 4,CHKSUM,23]  <12,4>						4589
	ADDI	AC2,40				; AC2,40
	IDPB	AC2,AC16			; AC2,POINTER
	LDB	AC2,C.82			; AC2,[POINT 6,CHKSUM,29]  <6,6>						4590
	ADDI	AC2,40				; AC2,40
	IDPB	AC2,AC16			; AC2,POINTER
	ANDI	AC1,77				; AC1,77									4591
	ADDI	AC1,40				; AC1,40
	IDPB	AC1,AC16			; AC1,POINTER
	ADDI	AC14,2				; TOT%MSG%LEN,2									4592
L.303:	MOVE	AC1,U.42			; AC1,SEND%EOL									4599
	IDPB	AC1,AC16			; AC1,POINTER
	PUSH	SP,C.88				; SP,[0,,SND%MSG]								4603
	PUSH	SP,AC14				; SP,TOT%MSG%LEN
	PUSHJ	SP,U.35				; SP,DBG%SEND
	ADDM	AC14,SMSG%TOTAL%CHARS		; TOT%MSG%LEN,SMSG%TOTAL%CHARS							4607
	MOVE	AC16,-44(SP)			; AC16,TYPE									4611
	CAIE	AC16,116			; AC16,116
	JRST	L.304				; L.304
	AOS	SMSG%NAKS			; SMSG%NAKS									4614
	PUSH	SP,C.8				; SP,[123]									4615
	PUSH	SP,C.25				; SP,[116]
	JRST	L.305				; L.305
L.304:	AOS	SMSG%COUNT			; SMSG%COUNT									4619
	PUSH	SP,C.8				; SP,[123]									4620
	PUSH	SP,C.89				; SP,[120]
L.305:	PUSHJ	SP,XFR%STATUS			; SP,XFR%STATUS
	MOVEI	AC1,1				; AC1,1										4628
	TDNE	AC1,IBM%FLAG			; AC1,IBM%FLAG
	CAIN	AC16,123			; AC16,123
	JRST	L.306				; L.306
	CAIE	AC16,111			; AC16,111
	CAIN	AC16,122			; AC16,122
	JRST	L.306				; L.306
	CAIE	AC16,103			; AC16,103									4629
	CAIN	AC16,107			; AC16,107
	JRST	L.306				; L.306
	PUSHJ	SP,IBM%WAIT			; SP,IBM%WAIT									4632
	TRNE	AC1,1				; AC1,1
	JRST	L.306				; L.306
	ADJSP	SP,-6				; SP,-6
	MOVEI	AC1,312				; AC1,312
	JRST	L.307				; L.307
L.306:	PUSH	SP,C.88				; SP,[0,,SND%MSG]								4637
	PUSH	SP,AC14				; SP,TOT%MSG%LEN
	PUSHJ	SP,U.22				; SP,DO%PARITY
	PUSH	SP,C.88				; SP,[0,,SND%MSG]								4638
	PUSH	SP,AC14				; SP,TOT%MSG%LEN
	PUSHJ	SP,SEND				; SP,SEND
	ADJSP	SP,-12				; SP,-12
L.307:	ADJSP	SP,-32				; SP,-32									4487
	POP	SP,AC16				; SP,AC16
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POPJ	SP,				; SP,
C.81:	POINT	8,U.58,-1			; 8,SND%MSG,-1
C.82:	POINT	6,AC1,29			; 6,CHKSUM,29
C.83:	POINT	4,AC1,23			; 4,CHKSUM,23
C.84:	POINT	8,U.58,23			; 8,SND%MSG,23
C.85:	POINT	8,U.58-1,31			; 8,SND%MSG-1,31
C.86:	POINT	8,U.58,7			; 8,SND%MSG,7
C.87:	POINT	8,U.58,15			; 8,SND%MSG,15
C.88:	XWD	0,U.58				; 0,SND%MSG
C.89:	EXP	120				; 120

; Routine Size:  139 words


;   4640  1	%SBTTL 'REC%MESSAGE - Receive a message'
;   4641  1	ROUTINE REC%MESSAGE (CHK%ROUTINE) =
;   4642  1	
;   4643  1	!++
;   4644  1	! FUNCTIONAL DESCRIPTION:
;   4645  1	!
;   4646  1	!	This routine will handle the retry processing for the various
;   4647  1	!	messages that can be received.
;   4648  1	!
;   4649  1	! CALLING SEQUENCE:
;   4650  1	!
;   4651  1	! INPUT PARAMETERS:
;   4652  1	!
;   4653  1	!	None.
;   4654  1	!
;   4655  1	! IMPLICIT INPUTS:
;   4656  1	!
;   4657  1	!	None.
;   4658  1	!
;   4659  1	! OUTPUT PARAMETERS:
;   4660  1	!
;   4661  1	!	None.
;   4662  1	!
;   4663  1	! IMPLICIT OUTPUTS:
;   4664  1	!
;   4665  1	!	None.
;   4666  1	!
;   4667  1	! COMPLETION CODES:
;   4668  1	!
;   4669  1	!	KER%NORMAL - Normal return
;   4670  1	!	KER%RETRIES - Too many retries
;   4671  1	!	(What ever REC%PACKET returns).
;   4672  1	!
;   4673  1	! SIDE EFFECTS:
;   4674  1	!
;   4675  1	!	None.
;   4676  1	!
;   4677  1	!--
;   4678  1	
;   4679  2	    BEGIN
;   4680  2	
;   4681  2	    LOCAL
;   4682  2		STATUS;					! Status returned by various routines
;   4683  2	
;   4684  2	    RETURN
;   4685  2	
;   4686  2		WHILE TRUE DO
;   4687  3		    BEGIN
;   4688  3	
;   4689  3		    IF .NUM%RETRIES GTR .PKT%RETRIES
;   4690  3		    THEN
;   4691  4			BEGIN
;   4692  4			KRM%ERROR (KER%RETRIES);	! Report the error
;   4693  4			RETURN KER%RETRIES;
;   4694  3			END;
;   4695  3	
;   4696  3		    NUM%RETRIES = .NUM%RETRIES + 1;
;   4697  3		    STATUS = REC%PACKET ();
;   4698  3	
;   4699  3		    IF NOT .STATUS AND .STATUS NEQ KER%CHKSUMERR AND .STATUS NEQ KER%TIMEOUT
;   4700  3		    THEN
;   4701  3			RETURN .STATUS;
;   4702  3	
;   4703  3		    IF NOT .STATUS
;   4704  3		    THEN
;   4705  3			SEND%PACKET (MSG%NAK, 0, .MSG%NUMBER)	![024]
;   4706  3		    ELSE
;   4707  4			BEGIN
;   4708  4	![021]
;   4709  4	![021] If the packet type is not acceptable by our caller, nak it so the
;   4710  4	![021] other end tries again, and abort the current operation.  This is so
;   4711  4	![021] we will return to server mode (if we are running that way) quickly
;   4712  4	![021] when the other Kermit has been aborted and then restarted, and should
;   4713  4	![021] also make restarting quick, since we will not need to wait for the
;   4714  4	![021] other Kermit to time this message out before retransmitting.
;   4715  4	![021]
;   4716  4	
;   4717  4			IF NOT (.CHK%ROUTINE) ()
;   4718  4			THEN
;   4719  5			    BEGIN
;   4720  5			    SEND%PACKET (MSG%NAK, 0, .REC%SEQ);
;   4721  5			    RETURN FALSE;		! Just indicate an error
;   4722  5			    END
;   4723  4			ELSE
;   4724  4			    EXITLOOP KER%NORMAL;
;   4725  4	
;   4726  3			END;
;   4727  3	
;   4728  2		    END;
;   4729  2	
;   4730  1	    END;					! End of REC%PARSE


; REC%MESSAGE
U.25:	PUSH	SP,AC16				; SP,AC16									4641
L.308:	MOVE	AC1,U.52			; AC1,NUM%RETRIES								4689
	CAMG	AC1,PKT%RETRIES			; AC1,PKT%RETRIES
	JRST	L.309				; L.309
	PUSH	SP,C.17				; SP,[212]									4692
	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
	ADJSP	SP,-1				; SP,-1										4693
	MOVEI	AC1,212				; AC1,212									4691
	JRST	L.313				; L.313
L.309:	AOS	U.52				; NUM%RETRIES									4696
	PUSHJ	SP,U.26				; SP,REC%PACKET									4697
	MOVE	AC16,AC1			; STATUS,AC1
	TRNN	AC16,1				; STATUS,1									4699
	CAIN	AC16,172			; STATUS,172
	JRST	L.310				; L.310
	CAIN	AC16,300			; STATUS,300
	JRST	L.310				; L.310
	MOVE	AC1,AC16			; AC1,STATUS									4701
	JRST	L.313				; L.313
L.310:	TRNE	AC16,1				; STATUS,1									4703
	JRST	L.311				; L.311
	PUSH	SP,C.25				; SP,[116]									4705
	PUSH	SP,C.26				; SP,[0]
	PUSH	SP,U.53				; SP,MSG%NUMBER
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	ADJSP	SP,-3				; SP,-3
	JRST	L.308				; L.308										4703
L.311:	MOVE	AC1,-2(SP)			; AC1,CHK%ROUTINE								4717
	PUSHJ	SP,0(AC1)			; SP,0(AC1)
	TRNE	AC1,1				; AC1,1
	JRST	L.312				; L.312
	PUSH	SP,C.25				; SP,[116]									4720
	PUSH	SP,C.26				; SP,[0]
	PUSH	SP,U.54				; SP,REC%SEQ
	PUSHJ	SP,U.24				; SP,SEND%PACKET
	ADJSP	SP,-3				; SP,-3										4721
	TDZA	AC1,AC1				; AC1,AC1									4719
L.312:	MOVEI	AC1,13				; AC1,13									4724
L.313:	POP	SP,AC16				; SP,AC16									4641
	POPJ	SP,				; SP,

; Routine Size:  40 words


;   4731  1	%SBTTL 'REC%PACKET'
;   4732  1	ROUTINE REC%PACKET =
;   4733  1	
;   4734  1	!++
;   4735  1	! FUNCTIONAL DESCRIPTION:
;   4736  1	!
;   4737  1	!	This routine will do the oppoiste of SEND%PACKET.  It will wait
;   4738  1	!	for the message to be read from the remote and then it will
;   4739  1	!	check the message for validity.
;   4740  1	!
;   4741  1	! CALLING SEQUENCE:
;   4742  1	!
;   4743  1	!	Flag = REC%PACKET();
;   4744  1	!
;   4745  1	! INPUT PARAMETERS:
;   4746  1	!
;   4747  1	!	None.
;   4748  1	!
;   4749  1	! IMPLICIT INPUTS:
;   4750  1	!
;   4751  1	!	None.
;   4752  1	!
;   4753  1	! OUTPUT PARAMETERS:
;   4754  1	!
;   4755  1	!	None.
;   4756  1	!
;   4757  1	! IMPLICIT OUTPUTS:
;   4758  1	!
;   4759  1	!	REC%MSG - Contains the message received.
;   4760  1	!
;   4761  1	! COMPLETION CODES:
;   4762  1	!
;   4763  1	!	True - Packet receive ok.
;   4764  1	!	False - Problem occured during the receiving of the packet.
;   4765  1	!
;   4766  1	! SIDE EFFECTS:
;   4767  1	!
;   4768  1	!	None.
;   4769  1	!
;   4770  1	!--
;   4771  1	
;   4772  2	    BEGIN
;   4773  2	
;   4774  2	    BIND
;   4775  2		ATTEMPT%TEXT = UPLIT (%ASCIZ'Attempting to receive');
;   4776  2	
;   4777  2	    LOCAL
;   4778  2		STATUS,					! Status returned by various routines
;   4779  2		MSG%LENGTH,
;   4780  2		ERR%POINTER,				! Pointer to the error buffer
;   4781  2		POINTER,
;   4782  2		CHKSUM;					! Checksum of the message
;   4783  2	
;   4784  2	!
;   4785  2	! Attempt to read the message from the remote.
;   4786  2	!
;   4787  2	!    DO
;   4788  2	!	BEGIN
;   4789  2	
;   4790  2	    IF .DEBUG%FLAG
;   4791  2	    THEN
;   4792  3		BEGIN
;   4793  3	
;   4794  3		LOCAL
;   4795  3		    OLD%RTN;
;   4796  3	
;   4797  3		OLD%RTN = TT%SET%OUTPUT (DBG%DUMP);
;   4798  3		TT%TEXT (ATTEMPT%TEXT);
;   4799  3		TT%CRLF ();
;   4800  3		TT%SET%OUTPUT (.OLD%RTN);
;   4801  2		END;
;   4802  2	
;   4803  2	!
;   4804  2	! If status type out requested, do it once
;   4805  2	!
;   4806  2	
;   4807  2	    IF .TYP%STS%FLAG
;   4808  2	    THEN
;   4809  3		BEGIN
;   4810  3		STS%OUTPUT ();
;   4811  3		TYP%STS%FLAG = FALSE;
;   4812  2		END;
;   4813  2	
;   4814  2	!
;   4815  2	! Receive the message from the remote Kermit
;   4816  2	!
;   4817  2	    STATUS = RECEIVE (REC%MSG, MSG%LENGTH);
;   4818  2	!
;   4819  2	! Check for timeouts
;   4820  2	!
;   4821  2	
;   4822  2	    IF .STATUS EQL KER%TIMEOUT THEN XFR%STATUS (%C'R', %C'T');
;   4823  2	
;   4824  2	!
;   4825  2	! If it failed return the status to the upper level
;   4826  2	!
;   4827  2	
;   4828  2	    IF NOT .STATUS
;   4829  2	    THEN
;   4830  3		BEGIN
;   4831  3	
;   4832  3		IF .STATUS NEQ KER%ABORTED AND .STATUS NEQ KER%TIMEOUT THEN KRM%ERROR (.STATUS);
;   4833  3	
;   4834  3							! Report error
;   4835  3		RETURN .STATUS;
;   4836  2		END;
;   4837  2	
;   4838  2	!
;   4839  2	! Determine if we got a good message
;   4840  2	!
;   4841  2	
;   4842  2	    IF .MSG%LENGTH LSS PKT%TOT%OVR%HEAD - 1
;   4843  2	    THEN
;   4844  3		BEGIN
;   4845  3		RETURN KER%ZEROLENMSG;
;   4846  2		END;
;   4847  2	
;   4848  2	!
;   4849  2	! Update the stats on the total number of characters received.
;   4850  2	!
;   4851  2	    RMSG%TOTAL%CHARS = .RMSG%TOTAL%CHARS + .MSG%LENGTH;
;   4852  2	!
;   4853  2	! Initialize the checksum and others
;   4854  2	!
;   4855  2	    REC%TYPE = CH$RCHAR (CH$PTR (REC%MSG, PKT%TYPE, CHR%SIZE));
;   4856  2	!
;   4857  2	! Now break the message apart byte by byte.
;   4858  2	!
;   4859  3	    REC%LENGTH = UNCHAR (CH$RCHAR (CH$PTR (REC%MSG, PKT%COUNT, CHR%SIZE))) - PKT%OVR%HEAD - (
;   4860  2	    .BLK%CHK%TYPE - CHK%1CHAR);
;   4861  2	    REC%SEQ = UNCHAR (CH$RCHAR (CH$PTR (REC%MSG, PKT%SEQ, CHR%SIZE)));
;   4862  2	!
;   4863  2	! Typed the packet if we are debugging
;   4864  2	!
;   4865  2	    DBG%RECEIVE (REC%MSG);
;   4866  2	!
;   4867  2	! Now compute the final checksum and make sure that it is identical
;   4868  2	! to what we received from the remote KERMIT
;   4869  2	!
;   4870  2	    POINTER = CH$PTR (REC%MSG, PKT%MARK + 1, CHR%SIZE);
;   4871  2	    CHKSUM = CALC%BLOCK%CHECK (.POINTER, .REC%LENGTH + PKT%OVR%HEAD);
;   4872  2	    POINTER = CH$PTR (REC%MSG, .REC%LENGTH + PKT%OVR%HEAD + 1, CHR%SIZE);
;   4873  2	    STATUS = KER%NORMAL;			! Assume good checksum
;   4874  2	
;   4875  2	    CASE .BLK%CHK%TYPE FROM CHK%1CHAR TO CHK%CRC OF
;   4876  2		SET
;   4877  2	
;   4878  2		[CHK%1CHAR] :
;   4879  2	
;   4880  2		    IF .CHKSUM NEQ UNCHAR (CH$RCHAR%A (POINTER)) THEN STATUS = KER%CHKSUMERR;
;   4881  2	
;   4882  2		[CHK%2CHAR] :
;   4883  2	
; P 4884  3		    IF (.CHKSUM<6, 6> NEQ UNCHAR (CH$RCHAR%A (POINTER))) OR (.CHKSUM<0, 6> NEQ UNCHAR (
;   4885  3			    CH$RCHAR%A (POINTER)))
;   4886  2		    THEN
;   4887  2			STATUS = KER%CHKSUMERR;
;   4888  2	
;   4889  2		[CHK%CRC] :
;   4890  2	
; P 4891  3		    IF (.CHKSUM<12, 4> NEQ UNCHAR (CH$RCHAR%A (POINTER))) OR (.CHKSUM<6, 6> NEQ UNCHAR (
;   4892  3			    CH$RCHAR%A (POINTER))) OR (.CHKSUM<0, 6> NEQ UNCHAR (CH$RCHAR%A (POINTER)))
;   4893  2		    THEN
;   4894  2			STATUS = KER%CHKSUMERR;
;   4895  2	
;   4896  2		TES;
;   4897  2	
;   4898  2	!
;   4899  2	! If we have a bad checksum, check for the special cases when we might be out
;   4900  2	! of sync with the sender.  This can occur if the sender is retransmitting
;   4901  2	! a send-init (because our ACK got lost), and we have agreed on multi-char
;   4902  2	! checksums, or because the sender is a server who has aborted back to being
;   4903  2	! idle without telling us.
;   4904  2	! Note that in either case, we return back to using single character checksums
;   4905  2	!
;   4906  2	
;   4907  2	    IF .STATUS EQL KER%CHKSUMERR
;   4908  2	    THEN
;   4909  3		BEGIN
;   4910  3	
;   4911  5		IF (.BLK%CHK%TYPE NEQ CHK%1CHAR AND .REC%SEQ EQL 0) AND (.REC%LENGTH LSS 1 - (.BLK%CHK%TYPE
;   4912  4		    - CHK%1CHAR) AND .REC%TYPE EQL MSG%NAK) OR (.REC%TYPE EQL MSG%SND%INIT)
;   4913  3		THEN
;   4914  4		    BEGIN
;   4915  4	
;   4916  4		    LOCAL
;   4917  4			SAVE%BLK%CHK%TYPE;
;   4918  4	
;   4919  4		    SAVE%BLK%CHK%TYPE = .BLK%CHK%TYPE;	! Remember what we are using
;   4920  4		    BLK%CHK%TYPE = CHK%1CHAR;
;   4921  4		    POINTER = CH$PTR (REC%MSG, PKT%MARK + 1, CHR%SIZE);
;   4922  4		    CHKSUM = CALC%BLOCK%CHECK (.POINTER, .REC%LENGTH + PKT%OVR%HEAD);
;   4923  4		    POINTER = CH$PTR (REC%MSG, .REC%LENGTH + PKT%OVR%HEAD + 1, CHR%SIZE);
;   4924  4	
;   4925  5		    IF .CHKSUM NEQ UNCHAR (CH$RCHAR%A (POINTER))
;   4926  4		    THEN
;   4927  5			BEGIN
;   4928  5			BLK%CHK%TYPE = .SAVE%BLK%CHK%TYPE;
;   4929  5			RETURN KER%CHKSUMERR;
;   4930  4			END;
;   4931  4	
;   4932  4		    END
;   4933  3		ELSE
;   4934  3		    RETURN KER%CHKSUMERR;
;   4935  3	
;   4936  2		END;
;   4937  2	
;   4938  2	!
;   4939  2	! Update the stats
;   4940  2	!
;   4941  2	!    RMSG%DATA%CHARS = .RMSG%DATA%CHARS + .REC%LENGTH;
;   4942  2	
;   4943  2	    IF .REC%TYPE EQL MSG%NAK
;   4944  2	    THEN
;   4945  3		BEGIN
;   4946  3		RMSG%NAKS = .RMSG%NAKS + 1;
;   4947  3		XFR%STATUS (%C'R', %C'N');
;   4948  3		END
;   4949  2	    ELSE
;   4950  3		BEGIN
;   4951  3		RMSG%COUNT = .RMSG%COUNT + 1;
;   4952  3		XFR%STATUS (%C'R', %C'P');
;   4953  2		END;
;   4954  2	
;   4955  2	!
;   4956  2	! Now check to see if we have an E type (Error) packet.
;   4957  2	!
;   4958  2	
;   4959  2	    IF .REC%TYPE NEQ MSG%ERROR THEN RETURN KER%NORMAL;
;   4960  2	
;   4961  2	!
;   4962  2	! Here to process an error packet.  Call the user routine to output the
;   4963  2	! error message to the terminal.
;   4964  2	!
;   4965  2	!
;   4966  2	![026] Use decoding routine to fetch the error text
;   4967  2	!
;   4968  2	    CH$FILL (CHR%NUL, MAX%MSG + 1, CH$PTR (LAST%ERROR));
;   4969  2	    SET%STRING (CH$PTR (LAST%ERROR), MAX%MSG, TRUE);
;   4970  2	    BFR%EMPTY ();
;   4971  2	    SET%STRING (0, 0, FALSE);
;   4972  2	![026]    ERR%POINTER = CH$PTR (LAST%ERROR);
;   4973  2	![026]    POINTER = CH$PTR (REC%MSG, PKT%MSG, CHR%SIZE);
;   4974  2	![026]
;   4975  2	![026]    INCR I FROM 1 TO .REC%LENGTH DO
;   4976  2	![026]	CH$WCHAR%A (CH$RCHAR%A (POINTER), ERR%POINTER);
;   4977  2	![026]
;   4978  2	![026]    CH$WCHAR (CHR%NUL, ERR%POINTER);
;   4979  2	    TT%TEXT (LAST%ERROR);
;   4980  2	    TT%CRLF ();
;   4981  2	    RETURN KER%ERRMSG;
;   4982  1	    END;					! End of REC%PACKET


P.AAO:	BYTE	(7)"A","t","t","e","m"		; Attem
	BYTE	(7)"p","t","i","n","g"		; pting
	BYTE	(7)" ","t","o"," ","r"		;  to r
	BYTE	(7)"e","c","e","i","v"		; eceiv
	BYTE	(7)"e",000,000,000,000		; e


; ATTEMPT%TEXT
U.80=		    P.AAO


; REC%PACKET
U.26:	PUSH	SP,AC14				; SP,AC14									4732
	PUSH	SP,AC16				; SP,AC16
	ADJSP	SP,1				; SP,1
	MOVEI	AC1,1				; AC1,1										4790
	TDNN	AC1,DEBUG%FLAG			; AC1,DEBUG%FLAG
	JRST	L.314				; L.314
	PUSH	SP,C.91				; SP,[0,,DBG%DUMP]								4797
	PUSHJ	SP,TT%SET%OUTPUT		; SP,TT%SET%OUTPUT
	MOVE	AC14,AC1			; OLD%RTN,AC1
	PUSH	SP,C.92				; SP,[0,,ATTEMPT%TEXT]								4798
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSHJ	SP,TT%CRLF			; SP,TT%CRLF									4799
	MOVEM	AC14,0(SP)			; OLD%RTN,0(SP)									4800
	PUSHJ	SP,TT%SET%OUTPUT		; SP,TT%SET%OUTPUT
	ADJSP	SP,-2				; SP,-2										4792
L.314:	MOVEI	AC1,1				; AC1,1										4807
	TDNN	AC1,TYP%STS%FLAG		; AC1,TYP%STS%FLAG
	JRST	L.315				; L.315
	PUSHJ	SP,U.33				; SP,STS%OUTPUT									4810
	SETZM	TYP%STS%FLAG			; TYP%STS%FLAG									4811
L.315:	PUSH	SP,C.93				; SP,[0,,REC%MSG]								4817
	MOVEI	AC1,-1(SP)			; AC1,MSG%LENGTH
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,RECEIVE			; SP,RECEIVE
	MOVE	AC14,AC1			; STATUS,AC1
	CAIE	AC14,300			; STATUS,300									4822
	JRST	L.316				; L.316
	PUSH	SP,C.12				; SP,[122]
	PUSH	SP,C.5				; SP,[124]
	PUSHJ	SP,XFR%STATUS			; SP,XFR%STATUS
	ADJSP	SP,-2				; SP,-2
L.316:	TRNE	AC14,1				; STATUS,1									4828
	JRST	L.318				; L.318
	CAIE	AC14,312			; STATUS,312									4832
	CAIN	AC14,300			; STATUS,300
	JRST	L.317				; L.317
	MOVEM	AC14,0(SP)			; STATUS,0(SP)
	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
L.317:	ADJSP	SP,-2				; SP,-2										4835
	MOVE	AC1,AC14			; AC1,STATUS									4830
	JRST	L.335				; L.335
L.318:	MOVE	AC1,-2(SP)			; AC1,MSG%LENGTH								4842
	CAIL	AC1,5				; AC1,5
	JRST	L.319				; L.319
	ADJSP	SP,-2				; SP,-2										4845
	MOVEI	AC1,262				; AC1,262									4844
	JRST	L.335				; L.335
L.319:	ADDM	AC1,RMSG%TOTAL%CHARS		; AC1,RMSG%TOTAL%CHARS								4851
	MOVE	AC1,C.94			; AC1,[POINT 8,REC%MSG,23]  <12,8>						4855
	ILDB	AC1,AC1				; AC1,AC1
	MOVEM	AC1,U.56			; AC1,REC%TYPE
	MOVE	AC1,C.95			; AC1,[POINT 8,REC%MSG,7]  <28,8>						4859
	ILDB	AC1,AC1				; AC1,AC1
	SUB	AC1,U.46			; AC1,BLK%CHK%TYPE
	ADDI	AC1,16				; AC1,16
	MOVEM	AC1,U.55			; AC1,REC%LENGTH
	MOVE	AC1,C.96			; AC1,[POINT 8,REC%MSG,15]  <20,8>						4861
	ILDB	AC1,AC1				; AC1,AC1
	SUBI	AC1,40				; AC1,40
	MOVEM	AC1,U.54			; AC1,REC%SEQ
	PUSH	SP,C.93				; SP,[0,,REC%MSG]								4865
	PUSHJ	SP,U.36				; SP,DBG%RECEIVE
	MOVE	AC16,C.95			; POINTER,[POINT 8,REC%MSG,7]  <28,8>						4870
	MOVEM	AC16,0(SP)			; POINTER,0(SP)									4871
	MOVE	AC1,U.55			; AC1,REC%LENGTH
	ADDI	AC1,3				; AC1,3
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,U.19				; SP,CALC%BLOCK%CHECK
	MOVE	AC2,U.55			; AC2,REC%LENGTH								4872
	ADDI	AC2,4				; AC2,4
	MOVE	AC3,C.90			; AC3,[POINT 8,REC%MSG,-1]  <36,8>
	ADJBP	AC2,AC3				; AC2,AC3
	MOVE	AC16,AC2			; POINTER,AC2
	MOVEI	AC14,13				; STATUS,13									4873
	MOVE	AC3,U.46			; AC3,BLK%CHK%TYPE								4875
	MOVE	AC2,AC3				; AC2,AC3
	SUBI	AC2,61				; AC2,61
	JRST	L.320(AC2)			; L.320(AC2)
L.320:	JRST	L.321				; L.321
	JRST	L.323				; L.323
	JRST	L.322				; L.322
L.321:	ILDB	AC2,AC16			; AC2,POINTER									4880
	SUBI	AC2,40				; AC2,40
	CAMN	AC1,AC2				; CHKSUM,AC2
	JRST	L.325				; L.325
	JRST	L.324				; L.324
L.322:	ILDB	AC2,AC16			; AC2,POINTER									4891
	SUBI	AC2,40				; AC2,40
	LDB	AC4,C.83			; AC4,[POINT 4,AC1,23]  <12,4>
	CAME	AC4,AC2				; AC4,AC2
	JRST	L.324				; L.324
L.323:	ILDB	AC2,AC16			; AC2,POINTER									4892
	SUBI	AC2,40				; AC2,40
	LDB	AC4,C.82			; AC4,[POINT 6,AC1,29]  <6,6>							4891
	CAME	AC4,AC2				; AC4,AC2
	JRST	L.324				; L.324
	ILDB	AC2,AC16			; AC2,POINTER									4892
	SUBI	AC2,40				; AC2,40
	LDB	AC4,C.18			; AC4,[POINT 6,AC1,35]  <0,6>
	CAME	AC4,AC2				; AC4,AC2
L.324:	MOVEI	AC14,172			; STATUS,172									4894
L.325:	CAIE	AC14,172			; STATUS,172									4907
	JRST	L.331				; L.331
	CAIE	AC3,61				; AC3,61									4911
	SKIPE	U.54				; REC%SEQ
	JRST	L.326				; L.326
	MOVE	AC2,AC3				; AC2,AC3
	SUBI	AC2,62				; AC2,62
	MOVN	AC2,AC2				; AC2,AC2
	CAMG	AC2,U.55			; AC2,REC%LENGTH
	JRST	L.326				; L.326
	MOVEI	AC2,116				; AC2,116									4912
	CAMN	AC2,U.56			; AC2,REC%TYPE
	JRST	L.327				; L.327
L.326:	MOVEI	AC2,123				; AC2,123
	CAME	AC2,U.56			; AC2,REC%TYPE
	JRST	L.329				; L.329
L.327:	MOVE	AC14,AC3			; SAVE%BLK%CHK%TYPE,AC3								4919
	MOVEI	AC2,61				; AC2,61									4920
	MOVEM	AC2,U.46			; AC2,BLK%CHK%TYPE
	MOVE	AC16,C.95			; POINTER,[POINT 8,REC%MSG,7]  <28,8>						4921
	MOVEM	AC16,0(SP)			; POINTER,0(SP)									4922
	MOVE	AC2,U.55			; AC2,REC%LENGTH
	ADDI	AC2,3				; AC2,3
	PUSH	SP,AC2				; SP,AC2
	PUSHJ	SP,U.19				; SP,CALC%BLOCK%CHECK
	MOVE	AC2,U.55			; AC2,REC%LENGTH								4923
	ADDI	AC2,4				; AC2,4
	MOVE	AC3,C.90			; AC3,[POINT 8,REC%MSG,-1]  <36,8>
	ADJBP	AC2,AC3				; AC2,AC3
	MOVE	AC16,AC2			; POINTER,AC2
	ILDB	AC2,AC16			; AC2,POINTER									4925
	SUBI	AC2,40				; AC2,40
	CAMN	AC1,AC2				; CHKSUM,AC2
	JRST	L.328				; L.328
	MOVEM	AC14,U.46			; SAVE%BLK%CHK%TYPE,BLK%CHK%TYPE						4928
	ADJSP	SP,-5				; SP,-5										4929
	JRST	L.330				; L.330
L.328:	ADJSP	SP,-1				; SP,-1										4914
	JRST	L.331				; L.331										4911
L.329:	ADJSP	SP,-4				; SP,-4										4934
L.330:	MOVEI	AC1,172				; AC1,172
	JRST	L.335				; L.335
L.331:	MOVEI	AC1,116				; AC1,116									4943
	CAME	AC1,U.56			; AC1,REC%TYPE
	JRST	L.332				; L.332
	AOS	RMSG%NAKS			; RMSG%NAKS									4946
	PUSH	SP,C.12				; SP,[122]									4947
	PUSH	SP,C.25				; SP,[116]
	JRST	L.333				; L.333
L.332:	AOS	RMSG%COUNT			; RMSG%COUNT									4951
	PUSH	SP,C.12				; SP,[122]									4952
	PUSH	SP,C.89				; SP,[120]
L.333:	PUSHJ	SP,XFR%STATUS			; SP,XFR%STATUS
	MOVEI	AC1,105				; AC1,105									4959
	CAMN	AC1,U.56			; AC1,REC%TYPE
	JRST	L.334				; L.334
	ADJSP	SP,-6				; SP,-6
	MOVEI	AC1,13				; AC1,13
	JRST	L.335				; L.335
L.334:	SETZB	AC1,AC2				; AC1,AC2									4968
	MOVEI	AC4,141				; AC4,141
	MOVE	AC5,C.3				; AC5,[POINT 7,LAST%ERROR-1,34]  <1,7>
	EXTEND	AC1,C.1				; AC1,C.1
	JFCL					;
	PUSH	SP,C.3				; SP,[POINT 7,LAST%ERROR-1,34]  <1,7>						4969
	PUSH	SP,C.56				; SP,[140]
	PUSH	SP,C.2				; SP,[1]
	PUSHJ	SP,U.30				; SP,SET%STRING
	PUSHJ	SP,U.28				; SP,BFR%EMPTY									4970
	SETZM	-2(SP)				; -2(SP)									4971
	SETZM	-1(SP)				; -1(SP)
	SETZM	0(SP)				; 0(SP)
	PUSHJ	SP,U.30				; SP,SET%STRING
	PUSH	SP,C.97				; SP,[0,,LAST%ERROR]								4979
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSHJ	SP,TT%CRLF			; SP,TT%CRLF									4980
	ADJSP	SP,-12				; SP,-12									4981
	MOVEI	AC1,162				; AC1,162									4772
L.335:	ADJSP	SP,-1				; SP,-1										4732
	POP	SP,AC16				; SP,AC16
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,
C.90:	POINT	8,U.57,-1			; 8,REC%MSG,-1
C.91:	XWD	0,DBG%DUMP			; 0,DBG%DUMP
C.92:	XWD	0,U.80				; 0,ATTEMPT%TEXT
C.93:	XWD	0,U.57				; 0,REC%MSG
C.94:	POINT	8,U.57,23			; 8,REC%MSG,23
C.95:	POINT	8,U.57,7			; 8,REC%MSG,7
C.96:	POINT	8,U.57,15			; 8,REC%MSG,15
C.97:	XWD	0,LAST%ERROR			; 0,LAST%ERROR

; Routine Size:  191 words


;   4983  1	%SBTTL 'CALC%BLOCK%CHECK'
;   4984  1	ROUTINE CALC%BLOCK%CHECK (POINTER, LENGTH) =
;   4985  1	
;   4986  1	!++
;   4987  1	! FUNCTIONAL DESCRIPTION:
;   4988  1	!
;   4989  1	!	This routine will calculate the proper value for the block check
;   4990  1	!	for a given message.  The value it returns is dependant upon the
;   4991  1	!	type of block check requested in BLK%CHK%TYPE.
;   4992  1	!
;   4993  1	! CALLING SEQUENCE:
;   4994  1	!
;   4995  1	!	CHKSUM = CALC%BLOCK%CHECK (.POINTER, .LENGTH);
;   4996  1	!
;   4997  1	! INPUT PARAMETERS:
;   4998  1	!
;   4999  1	!	POINTER - A character pointer to the first character to be
;   5000  1	!		included in the block check.
;   5001  1	!
;   5002  1	!	LENGTH - The number of characters to be included.
;   5003  1	!
;   5004  1	! IMPLICIT INPUTS:
;   5005  1	!
;   5006  1	!	BLK%CHK%TYPE - The type of block check to generate.
;   5007  1	!
;   5008  1	! OUPTUT PARAMETERS:
;   5009  1	!
;   5010  1	!	The value is the block check.
;   5011  1	!
;   5012  1	! IMPLICIT OUTPUTS:
;   5013  1	!
;   5014  1	!	None.
;   5015  1	!
;   5016  1	! COMPLETION CODES:
;   5017  1	!
;   5018  1	!	None.
;   5019  1	!
;   5020  1	! SIDE EFFECTS:
;   5021  1	!
;   5022  1	!	None.
;   5023  1	!
;   5024  1	!--
;   5025  1	
;   5026  2	    BEGIN
;   5027  2	
;   5028  2	    LOCAL
;   5029  2		CHAR%MASK,				! Mask for stripping bits
;   5030  2		BLOCK%CHECK;				! To build initial block check value
;   5031  2	
;   5032  2	    BLOCK%CHECK = 0;				! Start out at 0
;   5033  2	!
;   5034  2	! Set mask for characters so that we calculate the block check correctly
;   5035  2	!
;   5036  2	    CHAR%MASK = (IF .PARITY%TYPE EQL PR%NONE THEN %O'377' ELSE %O'177');
;   5037  2	
;   5038  2	    CASE .BLK%CHK%TYPE FROM CHK%1CHAR TO CHK%CRC OF
;   5039  2		SET
;   5040  2	
;   5041  2		[CHK%1CHAR, CHK%2CHAR] :
;   5042  2	
;   5043  2		    INCR I FROM 1 TO .LENGTH DO
;   5044  2			BLOCK%CHECK = .BLOCK%CHECK + (CH$RCHAR%A (POINTER) AND .CHAR%MASK);
;   5045  2	
;   5046  2		[CHK%CRC] :
;   5047  3		    BEGIN
;   5048  3	!
;   5049  3	! Ensure that the calculation is done with correct type of characters
;   5050  3	!
;   5051  3	
;   5052  3		    LOCAL
;   5053  3			TMP%PTR;			! Temp pointer for copying chars
;   5054  3	
;   5055  3		    TMP%PTR = .POINTER;
;   5056  3	
;   5057  3		    IF .PARITY%TYPE EQL PR%NONE
;   5058  3		    THEN
;   5059  3	
;   5060  3			INCR I FROM 1 TO .LENGTH DO
;   5061  3			    CH$WCHAR%A ((CH$RCHAR (.TMP%PTR) AND %O'177'), TMP%PTR);
;   5062  3	
;   5063  3		    BLOCK%CHECK = CRCCLC (.POINTER, .LENGTH);
;   5064  2		    END;
;   5065  2		TES;
;   5066  2	
;   5067  2	    IF .BLK%CHK%TYPE EQL CHK%1CHAR
;   5068  2	    THEN
;   5069  2		BLOCK%CHECK = (.BLOCK%CHECK + ((.BLOCK%CHECK AND %O'300')/%O'100')) AND %O'77';
;   5070  2	
;   5071  2	    RETURN .BLOCK%CHECK;			! Return the correct value
;   5072  1	    END;					! End of CALC%BLOCK%CHK


; CALC%BLOCK%CHECK
U.19:	SETZB	AC4,AC2				; BLOCK%CHECK,AC2								5032
	SKIPE	PARITY%TYPE			; PARITY%TYPE									5036
	JRST	L.336				; L.336
	MOVEI	AC2,1				; AC2,1
	MOVEI	AC3,377				; CHAR%MASK,377
	JRST	L.337				; L.337
L.336:	MOVEI	AC3,177				; CHAR%MASK,177
L.337:	MOVE	AC1,U.46			; AC1,BLK%CHK%TYPE								5038
	SUBI	AC1,61				; AC1,61
	JRST	L.338(AC1)			; L.338(AC1)
L.338:	JRST	L.339				; L.339
	JRST	L.339				; L.339
	JRST	L.342				; L.342
L.339:	SETZ	AC2,				; I,										5043
	JRST	L.341				; L.341
L.340:	ILDB	AC1,-2(SP)			; AC1,POINTER									5044
	AND	AC1,AC3				; AC1,CHAR%MASK
	ADD	AC4,AC1				; BLOCK%CHECK,AC1
L.341:	ADDI	AC2,1				; I,1										5043
	CAMG	AC2,-1(SP)			; I,LENGTH
	JRST	L.340				; L.340
	JRST	L.346				; L.346										5038
L.342:	MOVE	AC1,-2(SP)			; TMP%PTR,POINTER								5055
	TRNN	AC2,1				; AC2,1										5057
	JRST	L.345				; L.345
	MOVE	AC5,-1(SP)			; AC5,LENGTH									5060
	SETZ	AC3,				; I,
	JRST	L.344				; L.344
L.343:	MOVE	AC2,AC1				; AC2,TMP%PTR									5061
	ILDB	AC2,AC2				; AC2,AC2
	ANDI	AC2,177				; AC2,177
	IDPB	AC2,AC1				; AC2,TMP%PTR
L.344:	ADDI	AC3,1				; I,1										5060
	CAMG	AC3,AC5				; I,AC5
	JRST	L.343				; L.343
L.345:	PUSH	SP,-2(SP)			; SP,POINTER									5063
	PUSH	SP,-2(SP)			; SP,LENGTH
	PUSHJ	SP,CRCCLC			; SP,CRCCLC
	MOVE	AC4,AC1				; BLOCK%CHECK,AC1
	ADJSP	SP,-2				; SP,-2										5047
L.346:	MOVEI	AC1,61				; AC1,61									5067
	CAME	AC1,U.46			; AC1,BLK%CHK%TYPE
	JRST	L.347				; L.347
	MOVE	AC1,AC4				; AC1,BLOCK%CHECK								5069
	ANDI	AC1,300				; AC1,300
	IDIVI	AC1,100				; AC1,100
	ADD	AC1,AC4				; AC1,BLOCK%CHECK
	LDB	AC4,C.18			; BLOCK%CHECK,[POINT 6,AC1,35]  <0,6>
L.347:	MOVE	AC1,AC4				; AC1,BLOCK%CHECK								5026
	POPJ	SP,				; SP,										4984

; Routine Size:  50 words


;   5073  1	%SBTTL 'NORMALIZE%FILE - Put file name into normal form'
;   5074  1	ROUTINE NORMALIZE%FILE (FILE%ADDRESS, FILE%LENGTH, NAME%LENGTH, TYPE%LENGTH) : NOVALUE =
;   5075  1	
;   5076  1	!++
;   5077  1	! FUNCTIONAL DESCRIPTION:
;   5078  1	!
;   5079  1	!	This routine will ensure that a file specification is in normal
;   5080  1	!	form.  It does this by replacing all non-alphanumeric characters
;   5081  1	!	(except the first period) with "X".  It will also ensure that
;   5082  1	!	the resulting specification (of form name.type) has only
;   5083  1	!	a specified number of characters in the name portion and type portion.
;   5084  1	!
;   5085  1	! CALLING SEQUENCE:
;   5086  1	!
;   5087  1	!	NORMALIZE%FILE (FILE%ADDRESS, FILE%LENGTH, NAME%LENGTH, TYPE%LENGTH);
;   5088  1	!
;   5089  1	! INPUT PARAMETERS:
;   5090  1	!
;   5091  1	!	FILE%ADDRESS - Address of file specification string to be normalized
;   5092  1	!
;   5093  1	!	FILE%LENGTH - Length of file specification
;   5094  1	!
;   5095  1	!	NAME%LENGTH - Maximum length desired for "name" portion.
;   5096  1	!
;   5097  1	!	TYPE%LENGTH - Maximum length desired for "type" portion.
;   5098  1	!
;   5099  1	!	With both NAME%LENGTH and TYPE%LENGTH, a negative value indicates
;   5100  1	!	unlimited lenght.
;   5101  1	!
;   5102  1	! IMPLICIT INPUTS:
;   5103  1	!
;   5104  1	!	None.
;   5105  1	!
;   5106  1	! OUPTUT PARAMETERS:
;   5107  1	!
;   5108  1	!	FILE%LENGTH - The length of the resulting file spec
;   5109  1	!
;   5110  1	!	NAME%LENGTH - The actual length of the resulting file name
;   5111  1	!
;   5112  1	!	TYPE%LENGTH - The actual length of the resulting file type
;   5113  1	!
;   5114  1	! IMPLICIT OUTPUTS:
;   5115  1	!
;   5116  1	!	None.
;   5117  1	!
;   5118  1	! COMPLETION CODES:
;   5119  1	!
;   5120  1	!	None.
;   5121  1	!
;   5122  1	! SIDE EFFECTS:
;   5123  1	!
;   5124  1	!	None.
;   5125  1	!
;   5126  1	!--
;   5127  1	
;   5128  2	    BEGIN
;   5129  2	
;   5130  2	    LOCAL
;   5131  2		CH,					! Character being processed
;   5132  2		POINTER,				! Pointer to file spec
;   5133  2		WRT%POINTER,				! Pointer to write file spec
;   5134  2		WRT%SIZE,
;   5135  2		FIRST%PERIOD,				! Flag we have seen a period
;   5136  2		IGNORE%BAD,				! Flag we should ignore bad characters
;   5137  2		BAD%CHAR,				! Flag this character was bad
;   5138  2		FILE%CTR,				! Counter for overall length
;   5139  2		NAME%CTR,				! Counter for name characters
;   5140  2		TYPE%CTR;				! Counter for type characters
;   5141  2	
;   5142  2	    FILE%CTR = 0;
;   5143  2	    NAME%CTR = 0;
;   5144  2	    TYPE%CTR = 0;
;   5145  2	    WRT%SIZE = 0;
;   5146  2	    FIRST%PERIOD = FALSE;			! No periods yet
;   5147  2	    POINTER = CH$PTR (.FILE%ADDRESS);		! Set up pointer to file name
;   5148  2	    WRT%POINTER = .POINTER;
;   5149  2	
;   5150  2	    IF .NAME%LENGTH EQL 0 THEN FIRST%PERIOD = TRUE;	! Pretend we did name already
;   5151  2	
;   5152  2	    IGNORE%BAD = FALSE;
;   5153  2	
;   5154  2	    IF .NAME%LENGTH GTR 0
;   5155  2	    THEN
;   5156  3		BEGIN
;   5157  3	
;   5158  3		DECR I FROM ..FILE%LENGTH TO 0 DO
;   5159  3	
;   5160  3		    IF CH$RCHAR%A (POINTER) EQL %C'.'
;   5161  3		    THEN
;   5162  4			BEGIN
;   5163  4			IGNORE%BAD = TRUE;
;   5164  4			EXITLOOP;
;   5165  3			END;
;   5166  3	
;   5167  2		END;
;   5168  2	
;   5169  2	    POINTER = .WRT%POINTER;
;   5170  2	
;   5171  2	    WHILE .FILE%CTR LSS ..FILE%LENGTH DO
;   5172  3		BEGIN
;   5173  3		CH = CH$RCHAR%A (POINTER);		! Get a character
;   5174  3		FILE%CTR = .FILE%CTR + 1;
;   5175  3	
;   5176  4		IF (.CH LSS %C'0' AND (.CH NEQ %C'.' OR .FIRST%PERIOD)) OR .CH GTR %C'z' OR (.CH GTR %C'9'
;   5177  4		    AND .CH LSS %C'A') OR (.CH GTR %C'Z' AND .CH LSS %C'a')
;   5178  3		THEN
;   5179  4		    BEGIN
;   5180  4		    BAD%CHAR = TRUE;
;   5181  4		    CH = %C'X';
;   5182  4		    END
;   5183  3		ELSE
;   5184  4		    BEGIN
;   5185  4		    BAD%CHAR = FALSE;
;   5186  4	
;   5187  4		    IF .CH GEQ %C'a' THEN CH = .CH - (%C'a' - %C'A');
;   5188  4	
;   5189  3		    END;
;   5190  3	
;   5191  3		IF .CH EQL %C'.'
;   5192  3		THEN
;   5193  4		    BEGIN
;   5194  4		    FIRST%PERIOD = TRUE;
;   5195  4		    CH$WCHAR%A (.CH, WRT%POINTER);
;   5196  4		    WRT%SIZE = .WRT%SIZE + 1;
;   5197  4		    END
;   5198  3		ELSE
;   5199  3	
;   5200  3		    IF NOT .BAD%CHAR OR NOT .IGNORE%BAD
;   5201  3		    THEN
;   5202  3	
;   5203  3			IF NOT .FIRST%PERIOD
;   5204  3			THEN
;   5205  4			    BEGIN
;   5206  4	
;   5207  4			    IF .NAME%LENGTH LSS 0 OR .NAME%CTR LSS .NAME%LENGTH
;   5208  4			    THEN
;   5209  5				BEGIN
;   5210  5				NAME%CTR = .NAME%CTR + 1;
;   5211  5				WRT%SIZE = .WRT%SIZE + 1;
;   5212  5				CH$WCHAR%A (.CH, WRT%POINTER);
;   5213  4				END;
;   5214  4	
;   5215  4			    END
;   5216  3			ELSE
;   5217  3	
;   5218  3			    IF .TYPE%LENGTH LSS 0 OR .TYPE%CTR LSS .TYPE%LENGTH
;   5219  3			    THEN
;   5220  4				BEGIN
;   5221  4				TYPE%CTR = .TYPE%CTR + 1;
;   5222  4				WRT%SIZE = .WRT%SIZE + 1;
;   5223  4				CH$WCHAR%A (.CH, WRT%POINTER);
;   5224  3				END;
;   5225  3	
;   5226  2		END;
;   5227  2	
;   5228  2	    .FILE%LENGTH = .WRT%SIZE;
;   5229  2	    CH$WCHAR%A (CHR%NUL, WRT%POINTER);
;   5230  1	    END;					! End of NORMALIZE%FILE


; NORMALIZE%FILE
U.27:	PUSH	SP,AC10				; SP,AC10									5074
	PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	PUSH	SP,AC16				; SP,AC16
	SETZB	AC16,AC11			; FILE%CTR,NAME%CTR								5142
	SETZB	AC10,AC12			; TYPE%CTR,WRT%SIZE								5144
	SETZ	AC13,				; FIRST%PERIOD,									5146
	MOVE	AC1,-12(SP)			; AC1,FILE%ADDRESS								5147
	MOVEI	AC1,-1(AC1)			; AC1,-1(AC1)
	HRLI	AC1,10700			; AC1,10700
	MOVE	AC4,AC1				; WRT%POINTER,POINTER								5148
	SKIPN	AC2,-10(SP)			; AC2,NAME%LENGTH								5150
	MOVEI	AC13,1				; FIRST%PERIOD,1
	SETZ	AC14,				; IGNORE%BAD,									5152
	JUMPLE	AC2,L.350			; AC2,L.350									5154
	MOVE	AC2,-11(SP)			; AC2,FILE%LENGTH								5158
	MOVE	AC3,0(AC2)			; I,0(AC2)
	AOJA	AC3,L.349			; I,L.349
L.348:	ILDB	AC2,AC1				; AC2,POINTER									5160
	CAIE	AC2,56				; AC2,56
	JRST	L.349				; L.349
	MOVEI	AC14,1				; IGNORE%BAD,1									5163
	JRST	L.350				; L.350										5162
L.349:	SOJGE	AC3,L.348			; I,L.348									5158
L.350:	MOVE	AC1,AC4				; POINTER,WRT%POINTER								5169
L.351:	MOVE	AC3,-11(SP)			; AC3,FILE%LENGTH								5171
	CAML	AC16,0(AC3)			; FILE%CTR,0(AC3)
	JRST	L.363				; L.363
	ILDB	AC2,AC1				; CH,POINTER									5173
	ADDI	AC16,1				; FILE%CTR,1									5174
	CAIL	AC2,60				; CH,60										5176
	JRST	L.352				; L.352
	CAIN	AC2,56				; CH,56
	TRNE	AC13,1				; FIRST%PERIOD,1
	JRST	L.354				; L.354
L.352:	CAILE	AC2,172				; CH,172
	JRST	L.354				; L.354
	CAIG	AC2,71				; CH,71
	JRST	L.353				; L.353
	CAIGE	AC2,101				; CH,101									5177
	JRST	L.354				; L.354
L.353:	CAILE	AC2,132				; CH,132
	CAIL	AC2,141				; CH,141
	JRST	L.355				; L.355
L.354:	MOVEI	AC5,1				; BAD%CHAR,1									5180
	MOVEI	AC2,130				; CH,130									5181
	JRST	L.356				; L.356										5176
L.355:	SETZ	AC5,				; BAD%CHAR,									5185
	CAIL	AC2,141				; CH,141									5187
	SUBI	AC2,40				; CH,40
L.356:	CAIE	AC2,56				; CH,56										5191
	JRST	L.357				; L.357
	MOVEI	AC13,1				; FIRST%PERIOD,1								5194
	IDPB	AC2,AC4				; CH,WRT%POINTER								5195
	AOJA	AC12,L.351			; WRT%SIZE,L.351								5191
L.357:	TRNN	AC5,1				; BAD%CHAR,1									5200
	JRST	L.358				; L.358
	TRNE	AC14,1				; IGNORE%BAD,1
	JRST	L.351				; L.351
L.358:	TRNE	AC13,1				; FIRST%PERIOD,1								5203
	JRST	L.360				; L.360
	MOVE	AC3,-10(SP)			; AC3,NAME%LENGTH								5207
	JUMPL	AC3,L.359			; AC3,L.359
	CAML	AC11,AC3			; NAME%CTR,AC3
	JRST	L.351				; L.351
L.359:	AOJA	AC11,L.362			; NAME%CTR,L.362								5210
L.360:	MOVE	AC3,-7(SP)			; AC3,TYPE%LENGTH								5218
	JUMPL	AC3,L.361			; AC3,L.361
	CAML	AC10,AC3			; TYPE%CTR,AC3
	JRST	L.351				; L.351
L.361:	ADDI	AC10,1				; TYPE%CTR,1									5221
L.362:	ADDI	AC12,1				; WRT%SIZE,1									5222
	IDPB	AC2,AC4				; CH,WRT%POINTER								5223
	JRST	L.351				; L.351										5218
L.363:	MOVE	AC1,-11(SP)			; AC1,FILE%LENGTH								5228
	MOVEM	AC12,0(AC1)			; WRT%SIZE,0(AC1)
	SETZ	AC1,				; AC1,										5229
	IDPB	AC1,AC4				; AC1,WRT%POINTER
	POP	SP,AC16				; SP,AC16									5074
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POP	SP,AC10				; SP,AC10
	POPJ	SP,				; SP,

; Routine Size:  87 words


;   5231  1	%SBTTL 'Buffer filling -- Main routine'
;   5232  1	ROUTINE BFR%FILL (FIRST%FLAG) =
;   5233  1	
;   5234  1	!++
;   5235  1	! FUNCTIONAL DESCRIPTION:
;   5236  1	!
;   5237  1	!	This routine will fill the buffer with data from the file.  It
;   5238  1	!	will do all the quoting that is required.
;   5239  1	!
;   5240  1	! CALLING SEQUENCE:
;   5241  1	!
;   5242  1	!	EOF%FLAG = BFR%FILL(.FIRST%FLAG);
;   5243  1	!
;   5244  1	! INPUT PARAMETERS:
;   5245  1	!
;   5246  1	!	FIRST%FLAG - Flag whether first call for this file
;   5247  1	!
;   5248  1	! IMPLICIT INPUTS:
;   5249  1	!
;   5250  1	!	None.
;   5251  1	!
;   5252  1	! OUTPUT PARAMETERS:
;   5253  1	!
;   5254  1	!	True - Buffer filled may be at end of file.
;   5255  1	!	False - At end of file.
;   5256  1	!
;   5257  1	! IMPLICIT OUTPUTS:
;   5258  1	!
;   5259  1	!	Number of characters stored in the buffer.
;   5260  1	!
;   5261  1	! COMPLETION CODES:
;   5262  1	!
;   5263  1	!	None.
;   5264  1	!
;   5265  1	! SIDE EFFECTS:
;   5266  1	!
;   5267  1	!	None.
;   5268  1	!
;   5269  1	!--
;   5270  1	
;   5271  2	    BEGIN
;   5272  2	
;   5273  2	    LITERAL
;   5274  2		NO%CHAR = -1,				! No character next
;   5275  2		EOF%CHAR = -2;				! EOF seen
;   5276  2	
;   5277  2	    LOCAL
;   5278  2		I,					! Temp loop index
;   5279  2		MAX%SIZE,				! Maximum size of data
;   5280  2		POINTER;				! Pointer into the message buffer
;   5281  2	
;   5282  2	    OWN
;   5283  2		NEXT%CHR,				! Saved character
;   5284  2		STATUS,					! Status value
;   5285  2		REPEAT%COUNT,				! Number of times character repeated
;   5286  2		CHAR%8%BIT,				! 8 bit character from file
;   5287  2		CHRS : VECTOR [5],			! String needed to represent character
;   5288  2		CHR%IDX,				! Index into CHRS
;   5289  2		OLD%CHAR%8%BIT,				! Previous 8-bit character
;   5290  2		OLD%CHRS : VECTOR [5],			! String for previous character
;   5291  2		OLD%CHR%IDX;				! Index for previous character
;   5292  2	
;   5293  2	    ROUTINE GET%QUOTED%CHAR =
;   5294  2	!
;   5295  2	! This routine gets a character from the file and returns both
;   5296  2	! the character and the string needed to represent the character
;   5297  2	! if it needs quoting.
;   5298  2	!
;   5299  3		BEGIN
;   5300  3	
;   5301  3		IF .NEXT%CHR GEQ 0
;   5302  3		THEN
;   5303  4		    BEGIN
;   5304  4		    CHAR%8%BIT = .NEXT%CHR;
;   5305  4		    NEXT%CHR = NO%CHAR;
;   5306  4		    STATUS = KER%NORMAL;
;   5307  4		    END
;   5308  3		ELSE
;   5309  3	
;   5310  3		    IF .NEXT%CHR EQL NO%CHAR
;   5311  3		    THEN
;   5312  3			STATUS = (.GET%CHR%ROUTINE) (CHAR%8%BIT)
;   5313  3		    ELSE
;   5314  3			STATUS = KER%EOF;
;   5315  3	
;   5316  3		IF .STATUS EQL KER%NORMAL
;   5317  3		THEN
;   5318  4		    BEGIN
;   5319  4	!
;   5320  4	! Determine if we should just quote the character
;   5321  4	!	Either:
;   5322  4	!		Character is a delete (177 octal)
;   5323  4	!	or	Character is a control character (less than 40 octal)
;   5324  4	!	or	Character is a quote character
;   5325  4	!	or	Character is the repeat character and doing repeat compression
;   5326  4	!	or	Character is an eight bit quote character and doing eight bit
;   5327  4	!		  quoting.
;   5328  4	!
;   5329  4	
;   5330  5		    IF ((.CHAR%8%BIT AND %O'177') LSS %C' ') OR ((.CHAR%8%BIT AND %O'177') EQL CHR%DEL) OR (
;   5331  7			(.CHAR%8%BIT AND %O'177') EQL .RCV%QUOTE%CHR) OR (.FLAG%REPEAT AND ((.CHAR%8%BIT AND
;   5332  6			%O'177') EQL .REPT%CHR)) OR (.FLAG%8QUOTE AND ((.CHAR%8%BIT AND %O'177') EQL
;   5333  5			.SEND%8QUOTE%CHR))
;   5334  4		    THEN
;   5335  5			BEGIN
;   5336  5	!
;   5337  5	! If the character is a control character or delete we must do a CTL(Character)
;   5338  5	! so it is something that we can be sure we can send.
;   5339  5	!
;   5340  5	
;   5341  6			IF ((.CHAR%8%BIT AND %O'177') LSS %C' ') OR ((.CHAR%8%BIT AND %O'177') EQL CHR%DEL)
;   5342  5			THEN
;   5343  6			    CHRS [0] = CTL (.CHAR%8%BIT)
;   5344  5			ELSE
;   5345  5			    CHRS [0] = .CHAR%8%BIT;
;   5346  5	
;   5347  5			CHR%IDX = 1;
;   5348  5			CHRS [1] = .RCV%QUOTE%CHR;	![035] Use character we said we would send
;   5349  5			END
;   5350  4		    ELSE
;   5351  5			BEGIN
;   5352  5			CHR%IDX = 0;
;   5353  5			CHRS [0] = .CHAR%8%BIT;
;   5354  4			END;
;   5355  4	
;   5356  4		    END
;   5357  3		ELSE
;   5358  3	
;   5359  3		    IF .STATUS NEQ KER%EOF THEN KRM%ERROR (.STATUS);	! Report error
;   5360  3	
;   5361  3		RETURN .STATUS;
;   5362  2		END;


	RELOC	115
; NEXT%CHR
U.81:	BLOCK	1
; STATUS
U.82:	BLOCK	1
; REPEAT%COUNT
U.83:	BLOCK	1
; CHAR%8%BIT
U.84:	BLOCK	1
; CHRS
U.85:	BLOCK	5
; CHR%IDX
U.86:	BLOCK	1
; OLD%CHAR%8%BIT
U.87:	BLOCK	1
; OLD%CHRS
U.88:	BLOCK	5
; OLD%CHR%IDX
U.89:	BLOCK	1


	RELOC	405426
; GET%QUOTED%CHAR
U.90:	MOVE	AC1,U.81			; AC1,NEXT%CHR									5301
	JUMPL	AC1,L.364			; AC1,L.364
	MOVEM	AC1,U.84			; AC1,CHAR%8%BIT								5304
	SETOM	U.81				; NEXT%CHR									5305
	MOVEI	AC1,13				; AC1,13									5306
	JRST	L.366				; L.366
L.364:	CAME	AC1,C.37			; AC1,[-1]									5310
	JRST	L.365				; L.365
	MOVE	AC1,U.66			; AC1,GET%CHR%ROUTINE								5312
	PUSH	SP,C.99				; SP,[0,,CHAR%8%BIT]
	PUSHJ	SP,0(AC1)			; SP,0(AC1)
	MOVEM	AC1,U.82			; AC1,STATUS
	ADJSP	SP,-1				; SP,-1
	JRST	L.367				; L.367										5310
L.365:	MOVEI	AC1,113				; AC1,113									5314
L.366:	MOVEM	AC1,U.82			; AC1,STATUS
L.367:	MOVE	AC1,U.82			; AC1,STATUS									5316
	CAIE	AC1,13				; AC1,13
	JRST	L.372				; L.372
	MOVE	AC2,U.84			; AC2,CHAR%8%BIT								5330
	LDB	AC1,C.98			; AC1,[POINT 7,AC2,35]  <0,7>
	SETZ	AC3,				; AC3,
	CAIL	AC1,40				; AC1,40
	JRST	L.368				; L.368
	MOVEI	AC3,1				; AC3,1
	JRST	L.370				; L.370
L.368:	CAIE	AC1,177				; AC1,177
	CAMN	AC1,RCV%QUOTE%CHR		; AC1,RCV%QUOTE%CHR
	JRST	L.370				; L.370
	MOVEI	AC4,1				; AC4,1										5331
	TDNN	AC4,U.48			; AC4,FLAG%REPEAT
	JRST	L.369				; L.369
	CAMN	AC1,U.38			; AC1,REPT%CHR
	JRST	L.370				; L.370
L.369:	MOVEI	AC4,1				; AC4,1										5332
	TDNE	AC4,U.47			; AC4,FLAG%8QUOTE
	CAME	AC1,U.44			; AC1,SEND%8QUOTE%CHR
	JRST	L.371				; L.371
L.370:	TRNN	AC3,1				; AC3,1										5341
	CAIN	AC1,177				; AC1,177
	TRC	AC2,100				; AC2,100									5343
	MOVEM	AC2,U.85			; AC2,CHRS									5345
	MOVEI	AC1,1				; AC1,1										5347
	MOVEM	AC1,U.86			; AC1,CHR%IDX
	MOVE	AC1,RCV%QUOTE%CHR		; AC1,RCV%QUOTE%CHR								5348
	MOVEM	AC1,U.85+1			; AC1,CHRS+1
	JRST	L.373				; L.373										5330
L.371:	SETZM	U.86				; CHR%IDX									5352
	MOVEM	AC2,U.85			; AC2,CHRS									5353
	JRST	L.373				; L.373										5316
L.372:	CAIN	AC1,113				; AC1,113									5359
	JRST	L.373				; L.373
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,KRM%ERROR			; SP,KRM%ERROR
	ADJSP	SP,-1				; SP,-1
L.373:	MOVE	AC1,U.82			; AC1,STATUS									5299
	POPJ	SP,				; SP,										5293
C.98:	POINT	7,AC2,35			; 7,AC2,35
C.99:	XWD	0,U.84				; 0,CHAR%8%BIT

; Routine Size:  59 words


;   5363  2	    ROUTINE GET%8%QUOTED%CHAR =
;   5364  2	!
;   5365  2	! This routine will get the quoted representation of a character
;   5366  2	! (by calling GET%QUOTED%CHAR), and return the 8th-bit quoted
;   5367  2	! representation.
;   5368  2	!
;   5369  3		BEGIN
;   5370  3	
;   5371  3		IF (STATUS = GET%QUOTED%CHAR ()) EQL KER%NORMAL
;   5372  3		THEN
;   5373  4		    BEGIN
;   5374  4	!
;   5375  4	! Determine if we must quote the eighth bit (parity bit on)
;   5376  4	!
;   5377  4	
;   5378  5		    IF (((.CHRS [0] AND %O'177') NEQ .CHRS [0]) AND .FLAG%8QUOTE)
;   5379  4		    THEN
;   5380  5			BEGIN
;   5381  5			CHRS [0] = .CHRS [0] AND %O'177';
;   5382  5			CHR%IDX = .CHR%IDX + 1;
;   5383  5			CHRS [.CHR%IDX] = .SEND%8QUOTE%CHR;
;   5384  4			END;
;   5385  4	
;   5386  3		    END;
;   5387  3	
;   5388  3		RETURN .STATUS;
;   5389  2		END;


; GET%8%QUOTED%CHAR
U.91:	PUSHJ	SP,U.90				; SP,GET%QUOTED%CHAR								5371
	MOVEM	AC1,U.82			; AC1,STATUS
	CAIE	AC1,13				; AC1,13
	JRST	L.374				; L.374
	LDB	AC1,C.100			; AC1,[POINT 7,CHRS,35]  <0,7>							5378
	CAMN	AC1,U.85			; AC1,CHRS
	JRST	L.374				; L.374
	MOVEI	AC1,1				; AC1,1
	TDNN	AC1,U.47			; AC1,FLAG%8QUOTE
	JRST	L.374				; L.374
	LDB	AC1,C.100			; AC1,[POINT 7,CHRS,35]  <0,7>							5381
	MOVEM	AC1,U.85			; AC1,CHRS
	AOS	AC1,U.86			; AC1,CHR%IDX									5383
	MOVE	AC2,U.44			; AC2,SEND%8QUOTE%CHR
	MOVEM	AC2,U.85(AC1)			; AC2,CHRS(AC1)
L.374:	MOVE	AC1,U.82			; AC1,STATUS									5369
	POPJ	SP,				; SP,										5363
C.100:	POINT	7,U.85,35			; 7,CHRS,35

; Routine Size:  18 words


;   5390  2	!
;   5391  2	! Start of code for BFR%FILL
;   5392  2	!
;   5393  2	! Initialize pointer and count
;   5394  2	!
;   5395  2	    SIZE = 0;
;   5396  2	    POINTER = CH$PTR (SND%MSG, PKT%MSG, CHR%SIZE);
;   5397  2	    MAX%SIZE = .SEND%PKT%SIZE - PKT%OVR%HEAD - (.BLK%CHK%TYPE - CHK%1CHAR);
;   5398  2	!
;   5399  2	! If last call got an error or eof, return it now
;   5400  2	!
;   5401  2	
;   5402  2	    IF NOT .FIRST%FLAG AND (.STATUS NEQ KER%NORMAL) THEN RETURN .STATUS;
;   5403  2	
;   5404  2	!
;   5405  2	! If first time for a file prime the pump with the first character.
;   5406  2	!
;   5407  2	
;   5408  2	    IF .FIRST%FLAG
;   5409  2	    THEN
;   5410  3		BEGIN
;   5411  3		FIRST%FLAG = FALSE;
;   5412  3		NEXT%CHR = -1;				! No backed up character
;   5413  3	
;   5414  3		IF .FLAG%8QUOTE THEN STATUS = GET%8%QUOTED%CHAR () ELSE STATUS = GET%QUOTED%CHAR ();
;   5415  3	
;   5416  3		IF .STATUS NEQ KER%NORMAL THEN RETURN .STATUS;
;   5417  3	
;   5418  3		OLD%CHAR%8%BIT = .CHAR%8%BIT;
;   5419  3	
;   5420  3		INCR OLD%CHR%IDX FROM 0 TO .CHR%IDX DO
;   5421  3		    OLD%CHRS [.OLD%CHR%IDX] = .CHRS [.OLD%CHR%IDX];
;   5422  3	
;   5423  3		OLD%CHR%IDX = .CHR%IDX;
;   5424  3		REPEAT%COUNT = 0;			! Character was not repeated yet
;   5425  3							! Will always be incremented
;   5426  2		END;
;   5427  2	
;   5428  2	!
;   5429  2	! Otherwise, loop until we fill buffer
;   5430  2	!
;   5431  2	
;   5432  2	    WHILE .SIZE LSS .MAX%SIZE DO 		! Normal exit is via an EXITLOOP
;   5433  3		BEGIN
;   5434  3	!
;   5435  3	! Check if we are doing run compression
;   5436  3	!
;   5437  3	
;   5438  3		IF .FLAG%REPEAT
;   5439  3		THEN
;   5440  4		    BEGIN
;   5441  4	!
;   5442  4	! Here with previous character in OLD%xxx.  As long as we
;   5443  4	! are getting the same character, just count the run.
;   5444  4	!
;   5445  4	
;   5446  4		    WHILE (.CHAR%8%BIT EQL .OLD%CHAR%8%BIT) AND (.REPEAT%COUNT LSS 94) DO
;   5447  5			BEGIN
;   5448  5			REPEAT%COUNT = .REPEAT%COUNT + 1;
;   5449  5	
;   5450  5			IF .FLAG%8QUOTE THEN STATUS = GET%8%QUOTED%CHAR () ELSE STATUS = GET%QUOTED%CHAR ();
;   5451  5	
;   5452  5			IF .STATUS NEQ KER%NORMAL
;   5453  5			THEN
;   5454  5	
;   5455  5			    IF .STATUS NEQ KER%EOF
;   5456  5			    THEN
;   5457  5				CHAR%8%BIT = NO%CHAR
;   5458  5			    ELSE
;   5459  6				BEGIN
;   5460  6				CHAR%8%BIT = EOF%CHAR;
;   5461  6				CHR%IDX = -1;
;   5462  5				END;
;   5463  5	
;   5464  4			END;
;   5465  4	
;   5466  5		    IF .OLD%CHR%IDX + 1 + 2 LSS ((.OLD%CHR%IDX + 1)*.REPEAT%COUNT)
;   5467  4		    THEN
;   5468  5			BEGIN
;   5469  5	
;   5470  5			IF .SIZE + .OLD%CHR%IDX + 1 + 2 GTR .MAX%SIZE
;   5471  5			THEN
;   5472  6			    BEGIN
;   5473  6	
;   5474  6			    IF .CHAR%8%BIT EQL .OLD%CHAR%8%BIT
;   5475  6			    THEN
;   5476  7				BEGIN
;   5477  7				NEXT%CHR = .CHAR%8%BIT;
;   5478  7				REPEAT%COUNT = .REPEAT%COUNT - 1;
;   5479  6				END;
;   5480  6	
;   5481  6			    IF .CHAR%8%BIT EQL EOF%CHAR
;   5482  6			    THEN
;   5483  7				BEGIN
;   5484  7				NEXT%CHR = EOF%CHAR;	! Remember EOF for next time
;   5485  7				STATUS = KER%NORMAL;	! And give good return now
;   5486  6				END;
;   5487  6	
;   5488  6			    EXITLOOP;
;   5489  5			    END;
;   5490  5	
;   5491  5			OLD%CHRS [.OLD%CHR%IDX + 1] = CHAR (.REPEAT%COUNT);
;   5492  5			OLD%CHRS [.OLD%CHR%IDX + 2] = .REPT%CHR;
;   5493  5			OLD%CHR%IDX = .OLD%CHR%IDX + 2;
;   5494  5	!
;   5495  5	! Count the number of file characters this represents
;   5496  5	!
;   5497  5			SMSG%DATA%CHARS = .SMSG%DATA%CHARS + .REPEAT%COUNT - 1;
;   5498  5			FILE%CHARS = .FILE%CHARS + .REPEAT%COUNT - 1;
;   5499  5			REPEAT%COUNT = 1;		! Only one time for this string
;   5500  4			END;
;   5501  4	
;   5502  4	!
;   5503  4	! If we don't have enough room for this character, wait till next
;   5504  4	! time.
;   5505  4	!
;   5506  4	
;   5507  4		    IF .SIZE + (.OLD%CHR%IDX + 1)*.REPEAT%COUNT GTR .MAX%SIZE
;   5508  4		    THEN
;   5509  5			BEGIN
;   5510  5	! If the next character is the same, the count will get incremented
;   5511  5	! next time we enter, so back it off now.
;   5512  5	
;   5513  5			IF .CHAR%8%BIT EQL .OLD%CHAR%8%BIT
;   5514  5			THEN
;   5515  6			    BEGIN
;   5516  6			    NEXT%CHR = .CHAR%8%BIT;
;   5517  6			    REPEAT%COUNT = .REPEAT%COUNT - 1;
;   5518  5			    END;
;   5519  5	
;   5520  5			EXITLOOP;
;   5521  4			END;
;   5522  4	
;   5523  4		    SMSG%DATA%CHARS = .SMSG%DATA%CHARS + .REPEAT%COUNT;
;   5524  4		    FILE%CHARS = .FILE%CHARS + .REPEAT%COUNT;
;   5525  4	
;   5526  4		    DECR REPEAT%COUNT FROM .REPEAT%COUNT TO 1 DO
;   5527  4	
;   5528  4			DECR I FROM .OLD%CHR%IDX TO 0 DO
;   5529  5			    BEGIN
;   5530  5			    CH$WCHAR%A (.OLD%CHRS [.I], POINTER);
;   5531  5			    SIZE = .SIZE + 1;
;   5532  4			    END;
;   5533  4	
;   5534  4	!
;   5535  4	! If we got an error (or EOF) then exit
;   5536  4	!
;   5537  4	
;   5538  4		    IF (.STATUS NEQ KER%NORMAL) THEN EXITLOOP;
;   5539  4	
;   5540  4	!
;   5541  4	! Otherwise, copy the character which broke the run
;   5542  4	!
;   5543  4		    OLD%CHAR%8%BIT = .CHAR%8%BIT;
;   5544  4	
;   5545  4		    INCR OLD%CHR%IDX FROM 0 TO .CHR%IDX DO
;   5546  4			OLD%CHRS [.OLD%CHR%IDX] = .CHRS [.OLD%CHR%IDX];
;   5547  4	
;   5548  4		    OLD%CHR%IDX = .CHR%IDX;
;   5549  4		    REPEAT%COUNT = 0;
;   5550  4		    END
;   5551  3		ELSE
;   5552  3	!
;   5553  3	! Here if we are not doing run compression.  We can do things much
;   5554  3	! easier.
;   5555  3	!
;   5556  4		    BEGIN
;   5557  4	
;   5558  4		    IF (.SIZE + .CHR%IDX + 1) GTR .MAX%SIZE THEN EXITLOOP;
;   5559  4	
;   5560  4		    SMSG%DATA%CHARS = .SMSG%DATA%CHARS + 1;
;   5561  4		    FILE%CHARS = .FILE%CHARS + 1;
;   5562  4	
;   5563  4		    DECR CHR%IDX FROM .CHR%IDX TO 0 DO
;   5564  5			BEGIN
;   5565  5			CH$WCHAR%A (.CHRS [.CHR%IDX], POINTER);
;   5566  5			SIZE = .SIZE + 1;
;   5567  4			END;
;   5568  4	
;   5569  4		    IF .FLAG%8QUOTE THEN STATUS = GET%8%QUOTED%CHAR () ELSE STATUS = GET%QUOTED%CHAR ();
;   5570  4	
;   5571  4		    IF (.STATUS NEQ KER%NORMAL) THEN EXITLOOP;
;   5572  4	
;   5573  3		    END;
;   5574  3	
;   5575  2		END;
;   5576  2	
;   5577  2	!
;   5578  2	! Determine if we really stored anything into the buffer.
;   5579  2	!
;   5580  2	
;   5581  2	    IF .SIZE NEQ 0 THEN RETURN KER%NORMAL ELSE RETURN .STATUS;
;   5582  2	
;   5583  1	    END;					! End of BFR%FILL


; BFR%FILL
U.29:	PUSH	SP,AC14				; SP,AC14									5232
	PUSH	SP,AC16				; SP,AC16
	SETZM	U.50				; SIZE										5395
	MOVE	AC14,C.33			; POINTER,[POINT 8,SND%MSG,31]  <4,8>						5396
	MOVE	AC16,U.39			; AC16,SEND%PKT%SIZE								5397
	SUB	AC16,U.46			; AC16,BLK%CHK%TYPE
	ADDI	AC16,56				; AC16,56
	MOVE	AC1,-3(SP)			; AC1,FIRST%FLAG								5402
	TRNE	AC1,1				; AC1,1
	JRST	L.375				; L.375
	MOVEI	AC2,13				; AC2,13
	CAME	AC2,U.82			; AC2,STATUS
	JRST	L.403				; L.403
L.375:	TRNN	AC1,1				; AC1,1										5408
	JRST	L.381				; L.381
	SETZM	-3(SP)				; FIRST%FLAG									5411
	SETOM	U.81				; NEXT%CHR									5412
	MOVEI	AC1,1				; AC1,1										5414
	TDNN	AC1,U.47			; AC1,FLAG%8QUOTE
	JRST	L.376				; L.376
	PUSHJ	SP,U.91				; SP,GET%8%QUOTED%CHAR
	JRST	L.377				; L.377
L.376:	PUSHJ	SP,U.90				; SP,GET%QUOTED%CHAR
L.377:	MOVEM	AC1,U.82			; AC1,STATUS
	CAIE	AC1,13				; AC1,13									5416
	JRST	L.404				; L.404
	MOVE	AC1,U.84			; AC1,CHAR%8%BIT								5418
	MOVEM	AC1,U.87			; AC1,OLD%CHAR%8%BIT
	SETO	AC1,				; OLD%CHR%IDX,									5420
	JRST	L.379				; L.379
L.378:	MOVE	AC2,U.85(AC1)			; AC2,CHRS(OLD%CHR%IDX)								5421
	MOVEM	AC2,U.88(AC1)			; AC2,OLD%CHRS(OLD%CHR%IDX)
L.379:	ADDI	AC1,1				; OLD%CHR%IDX,1									5420
	CAMG	AC1,U.86			; OLD%CHR%IDX,CHR%IDX
	JRST	L.378				; L.378
L.380:	MOVE	AC1,U.86			; AC1,CHR%IDX									5423
	MOVEM	AC1,U.89			; AC1,OLD%CHR%IDX
	SETZM	U.83				; REPEAT%COUNT									5424
L.381:	CAMG	AC16,U.50			; MAX%SIZE,SIZE									5432
	JRST	L.402				; L.402
	MOVEI	AC1,1				; AC1,1										5438
	TDNN	AC1,U.48			; AC1,FLAG%REPEAT
	JRST	L.397				; L.397
L.382:	MOVE	AC1,U.84			; AC1,CHAR%8%BIT								5446
	CAME	AC1,U.87			; AC1,OLD%CHAR%8%BIT
	JRST	L.386				; L.386
	MOVEI	AC1,136				; AC1,136
	CAMG	AC1,U.83			; AC1,REPEAT%COUNT
	JRST	L.386				; L.386
	AOS	U.83				; REPEAT%COUNT									5448
	MOVEI	AC1,1				; AC1,1										5450
	TDNN	AC1,U.47			; AC1,FLAG%8QUOTE
	JRST	L.383				; L.383
	PUSHJ	SP,U.91				; SP,GET%8%QUOTED%CHAR
	JRST	L.384				; L.384
L.383:	PUSHJ	SP,U.90				; SP,GET%QUOTED%CHAR
L.384:	MOVEM	AC1,U.82			; AC1,STATUS
	CAIN	AC1,13				; AC1,13									5452
	JRST	L.382				; L.382
	CAIN	AC1,113				; AC1,113									5455
	JRST	L.385				; L.385
	SETOM	U.84				; CHAR%8%BIT									5457
	JRST	L.382				; L.382										5455
L.385:	HRROI	AC1,-2				; AC1,-2									5460
	MOVEM	AC1,U.84			; AC1,CHAR%8%BIT
	SETOM	U.86				; CHR%IDX									5461
	JRST	L.382				; L.382										5452
L.386:	MOVE	AC2,U.89			; AC2,OLD%CHR%IDX								5466
	MOVE	AC4,AC2				; AC4,AC2
	ADDI	AC4,3				; AC4,3
	MOVE	AC1,AC2				; AC1,AC2
	AOS	AC3,AC1				; AC3,AC1
	IMUL	AC3,U.83			; AC3,REPEAT%COUNT
	CAML	AC4,AC3				; AC4,AC3
	JRST	L.389				; L.389
	MOVE	AC3,U.50			; AC3,SIZE									5470
	ADD	AC3,AC2				; AC3,AC2
	ADDI	AC3,3				; AC3,3
	CAMG	AC3,AC16			; AC3,MAX%SIZE
	JRST	L.388				; L.388
	MOVE	AC3,U.84			; AC3,CHAR%8%BIT								5474
	CAME	AC3,U.87			; AC3,OLD%CHAR%8%BIT
	JRST	L.387				; L.387
	MOVE	AC3,U.84			; AC3,CHAR%8%BIT								5477
	MOVEM	AC3,U.81			; AC3,NEXT%CHR
	SOS	U.83				; REPEAT%COUNT									5478
L.387:	HRROI	AC3,-2				; AC3,-2									5481
	CAME	AC3,U.84			; AC3,CHAR%8%BIT
	JRST	L.402				; L.402
	HRROI	AC3,-2				; AC3,-2									5484
	MOVEM	AC3,U.81			; AC3,NEXT%CHR
	MOVEI	AC3,13				; AC3,13									5485
	MOVEM	AC3,U.82			; AC3,STATUS
	JRST	L.402				; L.402										5481
L.388:	MOVE	AC3,U.83			; AC3,REPEAT%COUNT								5491
	ADDI	AC3,40				; AC3,40
	MOVEM	AC3,U.88(AC1)			; AC3,OLD%CHRS(AC1)
	MOVE	AC1,U.38			; AC1,REPT%CHR									5492
	MOVEM	AC1,U.88+2(AC2)			; AC1,OLD%CHRS+2(AC2)
	MOVEI	AC1,2				; AC1,2										5493
	ADDM	AC1,U.89			; AC1,OLD%CHR%IDX
	MOVE	AC1,SMSG%DATA%CHARS		; AC1,SMSG%DATA%CHARS								5497
	ADD	AC1,U.83			; AC1,REPEAT%COUNT
	SUBI	AC1,1				; AC1,1
	MOVEM	AC1,SMSG%DATA%CHARS		; AC1,SMSG%DATA%CHARS
	MOVE	AC1,U.60			; AC1,FILE%CHARS								5498
	ADD	AC1,U.83			; AC1,REPEAT%COUNT
	SUBI	AC1,1				; AC1,1
	MOVEM	AC1,U.60			; AC1,FILE%CHARS
	MOVEI	AC1,1				; AC1,1										5499
	MOVEM	AC1,U.83			; AC1,REPEAT%COUNT
L.389:	MOVE	AC1,U.89			; AC1,OLD%CHR%IDX								5507
	ADDI	AC1,1				; AC1,1
	IMUL	AC1,U.83			; AC1,REPEAT%COUNT
	ADD	AC1,U.50			; AC1,SIZE
	CAMG	AC1,AC16			; AC1,MAX%SIZE
	JRST	L.390				; L.390
	MOVE	AC1,U.84			; AC1,CHAR%8%BIT								5513
	CAME	AC1,U.87			; AC1,OLD%CHAR%8%BIT
	JRST	L.402				; L.402
	MOVE	AC1,U.84			; AC1,CHAR%8%BIT								5516
	MOVEM	AC1,U.81			; AC1,NEXT%CHR
	SOS	U.83				; REPEAT%COUNT									5517
	JRST	L.402				; L.402										5513
L.390:	MOVE	AC1,U.83			; AC1,REPEAT%COUNT								5523
	ADDM	AC1,SMSG%DATA%CHARS		; AC1,SMSG%DATA%CHARS
	MOVE	AC1,U.83			; AC1,REPEAT%COUNT								5524
	ADDM	AC1,U.60			; AC1,FILE%CHARS
	MOVE	AC3,U.83			; REPEAT%COUNT,REPEAT%COUNT							5526
	AOJA	AC3,L.394			; REPEAT%COUNT,L.394
L.391:	MOVE	AC1,U.89			; I,OLD%CHR%IDX									5528
	AOJA	AC1,L.393			; I,L.393
L.392:	MOVE	AC2,U.88(AC1)			; AC2,OLD%CHRS(I)								5530
	IDPB	AC2,AC14			; AC2,POINTER
	AOS	U.50				; SIZE										5531
L.393:	SOJGE	AC1,L.392			; I,L.392									5528
L.394:	SOJG	AC3,L.391			; REPEAT%COUNT,L.391								5526
	MOVEI	AC1,13				; AC1,13									5538
	CAME	AC1,U.82			; AC1,STATUS
	JRST	L.402				; L.402
	MOVE	AC1,U.84			; AC1,CHAR%8%BIT								5543
	MOVEM	AC1,U.87			; AC1,OLD%CHAR%8%BIT
	SETO	AC1,				; OLD%CHR%IDX,									5545
	JRST	L.396				; L.396
L.395:	MOVE	AC2,U.85(AC1)			; AC2,CHRS(OLD%CHR%IDX)								5546
	MOVEM	AC2,U.88(AC1)			; AC2,OLD%CHRS(OLD%CHR%IDX)
L.396:	ADDI	AC1,1				; OLD%CHR%IDX,1									5545
	CAMG	AC1,U.86			; OLD%CHR%IDX,CHR%IDX
	JRST	L.395				; L.395
	JRST	L.380				; L.380
L.397:	MOVE	AC1,U.50			; AC1,SIZE									5558
	ADD	AC1,U.86			; AC1,CHR%IDX
	ADDI	AC1,1				; AC1,1
	CAMLE	AC1,AC16			; AC1,MAX%SIZE
	JRST	L.402				; L.402
	AOS	SMSG%DATA%CHARS			; SMSG%DATA%CHARS								5560
	AOS	U.60				; FILE%CHARS									5561
	MOVE	AC1,U.86			; CHR%IDX,CHR%IDX								5563
	AOJA	AC1,L.399			; CHR%IDX,L.399
L.398:	MOVE	AC2,U.85(AC1)			; AC2,CHRS(CHR%IDX)								5565
	IDPB	AC2,AC14			; AC2,POINTER
	AOS	U.50				; SIZE										5566
L.399:	SOJGE	AC1,L.398			; CHR%IDX,L.398									5563
	MOVEI	AC1,1				; AC1,1										5569
	TDNN	AC1,U.47			; AC1,FLAG%8QUOTE
	JRST	L.400				; L.400
	PUSHJ	SP,U.91				; SP,GET%8%QUOTED%CHAR
	JRST	L.401				; L.401
L.400:	PUSHJ	SP,U.90				; SP,GET%QUOTED%CHAR
L.401:	MOVEM	AC1,U.82			; AC1,STATUS
	MOVEI	AC1,13				; AC1,13									5571
	CAMN	AC1,U.82			; AC1,STATUS
	JRST	L.381				; L.381										5432
L.402:	SKIPN	U.50				; SIZE										5581
	JRST	L.403				; L.403
	MOVEI	AC1,13				; AC1,13
	JRST	L.404				; L.404
L.403:	MOVE	AC1,U.82			; AC1,STATUS
L.404:	POP	SP,AC16				; SP,AC16									5232
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,

; Routine Size:  181 words


;   5584  1	%SBTTL 'BFR%EMPTY'
;   5585  1	ROUTINE BFR%EMPTY =
;   5586  1	
;   5587  1	!++
;   5588  1	! FUNCTIONAL DESCRIPTION:
;   5589  1	!
;   5590  1	!	This routine will empty the data from the REC%MSG message buffer
;   5591  1	!	to the file.  It will process quoting characters.
;   5592  1	!
;   5593  1	! CALLING SEQUENCE:
;   5594  1	!
;   5595  1	!	Flag = BFR%EMPTY();
;   5596  1	!
;   5597  1	! INPUT PARAMETERS:
;   5598  1	!
;   5599  1	!	None.
;   5600  1	!
;   5601  1	! IMPLICIT INPUTS:
;   5602  1	!
;   5603  1	!	None.
;   5604  1	!
;   5605  1	! OUTPUT PARAMETERS:
;   5606  1	!
;   5607  1	!	True - No problems writing the file.
;   5608  1	!	False - I/O error writing the file.
;   5609  1	!
;   5610  1	! IMPLICIT OUTPUTS:
;   5611  1	!
;   5612  1	!	None.
;   5613  1	!
;   5614  1	! COMPLETION CODES:
;   5615  1	!
;   5616  1	!	None.
;   5617  1	!
;   5618  1	! SIDE EFFECTS:
;   5619  1	!
;   5620  1	!	None.
;   5621  1	!
;   5622  1	!--
;   5623  1	
;   5624  2	    BEGIN
;   5625  2	
;   5626  2	    LOCAL
;   5627  2		STATUS,					! Status returned by various routines
;   5628  2		REPEAT%COUNT,				! Count of times to repeat character
;   5629  2		TURN%BIT%8%ON,				! If eight bit quoting
;   5630  2		COUNTER,				! Count of the characters left
;   5631  2		CHARACTER,				! Character we are processing
;   5632  2		POINTER;				! Pointer to the data
;   5633  2	
;   5634  2	    POINTER = CH$PTR (REC%MSG, PKT%MSG, CHR%SIZE);
;   5635  2	    COUNTER = 0;
;   5636  2	
;   5637  2	    WHILE (.COUNTER LSS .REC%LENGTH) DO
;   5638  3		BEGIN
;   5639  3		CHARACTER = CH$RCHAR%A (POINTER);
;   5640  3		COUNTER = .COUNTER + 1;
;   5641  3	!
;   5642  3	! If the character is the repeat character (and we are doing repeat
;   5643  3	! compression), then get the count.
;   5644  3	!
;   5645  3	
;   5646  4		IF ((.CHARACTER EQL .REPT%CHR) AND .FLAG%REPEAT)
;   5647  3		THEN
;   5648  4		    BEGIN
;   5649  4		    REPEAT%COUNT = UNCHAR (CH$RCHAR%A (POINTER) AND %O'177');
;   5650  4		    CHARACTER = CH$RCHAR%A (POINTER);
;   5651  4		    COUNTER = .COUNTER + 2;
;   5652  4		    END
;   5653  3		ELSE
;   5654  3		    REPEAT%COUNT = 1;
;   5655  3	
;   5656  3	!
;   5657  3	! If the character is an eight bit quoting character and we are doing eight
;   5658  3	! bit quoting then turn on the flag so we turn the eighth bit on when we
;   5659  3	! get the real character.
;   5660  3	!
;   5661  3	
;   5662  4		IF ((.CHARACTER EQL .SEND%8QUOTE%CHR) AND .FLAG%8QUOTE)
;   5663  3		THEN
;   5664  4		    BEGIN
;   5665  4		    TURN%BIT%8%ON = TRUE;
;   5666  4		    COUNTER = .COUNTER + 1;
;   5667  4		    CHARACTER = CH$RCHAR%A (POINTER);
;   5668  4		    END
;   5669  3		ELSE
;   5670  3		    TURN%BIT%8%ON = FALSE;
;   5671  3	
;   5672  3	!
;   5673  3	! Now determine if we are quoting the character.  If so then we must eat
;   5674  3	! the quoting character and get the real character.
;   5675  3	!
;   5676  3	
;   5677  3		IF .CHARACTER EQL .SEND%QUOTE%CHR
;   5678  3						![035] Is this character other Kermit sends as quote?
;   5679  3		THEN
;   5680  4		    BEGIN
;   5681  4		    CHARACTER = CH$RCHAR%A (POINTER);
;   5682  4		    COUNTER = .COUNTER + 1;
;   5683  4	!
;   5684  4	! Determine if we must undo what someone else has done to the character
;   5685  4	!
;   5686  4	
; P 5687  5		    IF ((.CHARACTER AND %O'177') GEQ CTL (CHR%DEL)) AND ((.CHARACTER AND %O'177') LEQ CTL (
;   5688  5			    CHR%DEL) + %O'40')
;   5689  4		    THEN
;   5690  4			CHARACTER = CTL (.CHARACTER);
;   5691  4	
;   5692  3		    END;
;   5693  3	
;   5694  3	!
;   5695  3	! Turn on the eight bit if needed and then write the character out
;   5696  3	!
;   5697  3	
;   5698  3		IF .TURN%BIT%8%ON THEN CHARACTER = .CHARACTER OR %O'200';
;   5699  3	
;   5700  3		RMSG%DATA%CHARS = .RMSG%DATA%CHARS + .REPEAT%COUNT;
;   5701  3		FILE%CHARS = .FILE%CHARS + .REPEAT%COUNT;
;   5702  3	
;   5703  3		DECR REPEAT%COUNT FROM .REPEAT%COUNT TO 1 DO
;   5704  4		    BEGIN
;   5705  4		    STATUS = (.PUT%CHR%ROUTINE) (.CHARACTER);
;   5706  4	
;   5707  4		    IF NOT .STATUS THEN RETURN .STATUS;
;   5708  4	
;   5709  3		    END;
;   5710  3	
;   5711  2		END;
;   5712  2	
;   5713  2	    RETURN KER%NORMAL;
;   5714  1	    END;					! End of BFR%EMPTY


; BFR%EMPTY
U.28:	PUSH	SP,AC10				; SP,AC10									5585
	PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	PUSH	SP,AC16				; SP,AC16
	MOVE	AC11,C.29			; POINTER,[POINT 8,REC%MSG,31]  <4,8>						5634
	SETZ	AC12,				; COUNTER,									5635
L.405:	CAML	AC12,U.55			; COUNTER,REC%LENGTH								5637
	JRST	L.414				; L.414
	ILDB	AC13,AC11			; CHARACTER,POINTER								5639
	ADDI	AC12,1				; COUNTER,1									5640
	CAME	AC13,U.38			; CHARACTER,REPT%CHR								5646
	JRST	L.406				; L.406
	MOVEI	AC2,1				; AC2,1
	TDNN	AC2,U.48			; AC2,FLAG%REPEAT
	JRST	L.406				; L.406
	ILDB	AC2,AC11			; AC2,POINTER									5649
	LDB	AC14,C.98			; REPEAT%COUNT,[POINT 7,AC2,35]  <0,7>
	SUBI	AC14,40				; REPEAT%COUNT,40
	ILDB	AC13,AC11			; CHARACTER,POINTER								5650
	ADDI	AC12,2				; COUNTER,2									5651
	JRST	L.407				; L.407										5646
L.406:	MOVEI	AC14,1				; REPEAT%COUNT,1								5654
L.407:	CAME	AC13,U.44			; CHARACTER,SEND%8QUOTE%CHR							5662
	JRST	L.408				; L.408
	MOVEI	AC2,1				; AC2,1
	TDNN	AC2,U.47			; AC2,FLAG%8QUOTE
	JRST	L.408				; L.408
	MOVEI	AC10,1				; TURN%BIT%8%ON,1								5665
	ADDI	AC12,1				; COUNTER,1									5666
	ILDB	AC13,AC11			; CHARACTER,POINTER								5667
	JRST	L.409				; L.409										5662
L.408:	SETZ	AC10,				; TURN%BIT%8%ON,								5670
L.409:	CAME	AC13,U.43			; CHARACTER,SEND%QUOTE%CHR							5677
	JRST	L.410				; L.410
	ILDB	AC13,AC11			; CHARACTER,POINTER								5681
	ADDI	AC12,1				; COUNTER,1									5682
	LDB	AC2,C.101			; AC2,[POINT 7,CHARACTER,35]  <0,7>						5687
	CAIL	AC2,77				; AC2,77
	CAILE	AC2,137				; AC2,137
	JRST	L.410				; L.410
	TRC	AC13,100			; CHARACTER,100									5690
L.410:	TRNE	AC10,1				; TURN%BIT%8%ON,1								5698
	TRO	AC13,200			; CHARACTER,200
	ADDM	AC14,RMSG%DATA%CHARS		; REPEAT%COUNT,RMSG%DATA%CHARS							5700
	ADDM	AC14,U.60			; REPEAT%COUNT,FILE%CHARS							5701
	MOVE	AC16,AC14			; REPEAT%COUNT,REPEAT%COUNT							5703
	AOJA	AC16,L.413			; REPEAT%COUNT,L.413
L.411:	MOVE	AC2,U.67			; AC2,PUT%CHR%ROUTINE								5705
	PUSH	SP,AC13				; SP,CHARACTER
	PUSHJ	SP,0(AC2)			; SP,0(AC2)
	TRNE	AC1,1				; STATUS,1									5707
	JRST	L.412				; L.412
	ADJSP	SP,-1				; SP,-1
	JRST	L.415				; L.415
L.412:	ADJSP	SP,-1				; SP,-1										5704
L.413:	SOJG	AC16,L.411			; REPEAT%COUNT,L.411								5703
	JRST	L.405				; L.405										5637
L.414:	MOVEI	AC1,13				; AC1,13									5624
L.415:	POP	SP,AC16				; SP,AC16									5585
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POP	SP,AC10				; SP,AC10
	POPJ	SP,				; SP,
C.101:	POINT	7,AC13,35			; 7,CHARACTER,35

; Routine Size:  68 words


;   5715  1	%SBTTL 'Buffer filling and emptying subroutines'
;   5716  1	ROUTINE SET%STRING (POINTER, LENGTH, START) =
;   5717  1	
;   5718  1	!++
;   5719  1	! FUNCTIONAL DESCRIPTION:
;   5720  1	!
;   5721  1	!	This routine is used to set up the buffer filling and emptying
;   5722  1	!	routines to use a string for input (or output) rather than
;   5723  1	!	the file I/O routines.
;   5724  1	!
;   5725  1	! CALLING SEQUENCE:
;   5726  1	!
;   5727  1	!	SET%STRING (.POINTER, .LENGTH, .START)
;   5728  1	!
;   5729  1	! INPUT PARAMETERS:
;   5730  1	!
;   5731  1	!	POINTER - Character pointer to string
;   5732  1	!
;   5733  1	!	LENGTH - Number of characters in string
;   5734  1	!
;   5735  1	!	START - True to start string, false to end it
;   5736  1	!
;   5737  1	! IMPLICIT INPUTS:
;   5738  1	!
;   5739  1	!	None.
;   5740  1	!
;   5741  1	! OUPTUT PARAMETERS:
;   5742  1	!
;   5743  1	!	Returns 0 if START = TRUE, actual number of characters used
;   5744  1	!	by last string if START = FALSE.
;   5745  1	!
;   5746  1	! IMPLICIT OUTPUTS:
;   5747  1	!
;   5748  1	!	GET%CHR%ROUTINE and PUT%CHR%ROUTINE modifed so that string
;   5749  1	!	routines are called instead of file I/O.
;   5750  1	!
;   5751  1	! COMPLETION CODES:
;   5752  1	!
;   5753  1	!	None.
;   5754  1	!
;   5755  1	! SIDE EFFECTS:
;   5756  1	!
;   5757  1	!	None.
;   5758  1	!
;   5759  1	!--
;   5760  1	
;   5761  2	    BEGIN
;   5762  2	
;   5763  2	    OWN
;   5764  2		STR%POINTER,				! Pointer to string
;   5765  2		STR%LENGTH,				! Length of string
;   5766  2		STR%ORG%LENGTH,				! Original length of string
;   5767  2		OLD%GET%CHR,				! Old get-char routine
;   5768  2		OLD%PUT%CHR;				! Old put-char routine
;   5769  2	
;   5770  2	!
;   5771  2	! Routine to get a character from the string
;   5772  2	!
;   5773  2	    ROUTINE GET%STRING (CHAR%ADDRESS) =
;   5774  3		BEGIN
;   5775  3	!
;   5776  3	! If some characters are left, count down the length and get next character
;   5777  3	! Otherwise return and end of file indication.
;   5778  3	!
;   5779  3	
;   5780  3		IF .STR%LENGTH GTR 0
;   5781  3		THEN
;   5782  4		    BEGIN
;   5783  4		    STR%LENGTH = .STR%LENGTH - 1;
;   5784  4		    .CHAR%ADDRESS = CH$RCHAR%A (STR%POINTER);
;   5785  4		    RETURN KER%NORMAL;
;   5786  4		    END
;   5787  3		ELSE
;   5788  3		    RETURN KER%EOF;
;   5789  3	
;   5790  2		END;					! End of GET%STRING


	RELOC	136
; STR%POINTER
U.92:	BLOCK	1
; STR%LENGTH
U.93:	BLOCK	1
; STR%ORG%LENGTH
U.94:	BLOCK	1
; OLD%GET%CHR
U.95:	BLOCK	1
; OLD%PUT%CHR
U.96:	BLOCK	1


	RELOC	406134
; GET%STRING
U.97:	SKIPG	U.93				; STR%LENGTH									5780
	JRST	L.416				; L.416
	SOS	U.93				; STR%LENGTH									5783
	MOVE	AC2,-1(SP)			; AC2,CHAR%ADDRESS								5784
	ILDB	AC1,U.92			; AC1,STR%POINTER
	MOVEM	AC1,0(AC2)			; AC1,0(AC2)
	MOVEI	AC1,13				; AC1,13									5788
	POPJ	SP,				; SP,
L.416:	MOVEI	AC1,113				; AC1,113
	POPJ	SP,				; SP,										5773

; Routine Size:  10 words


;   5791  2	    ROUTINE PUT%STRING (CHAR%VALUE) =
;   5792  3		BEGIN
;   5793  3	!
;   5794  3	! If there is enough room to store another character, store the character
;   5795  3	! and count it.  Otherwise return a line too long indication.
;   5796  3	!
;   5797  3	
;   5798  3		IF .STR%LENGTH GTR 0
;   5799  3		THEN
;   5800  4		    BEGIN
;   5801  4		    STR%LENGTH = .STR%LENGTH - 1;
;   5802  4		    CH$WCHAR%A (.CHAR%VALUE, STR%POINTER);
;   5803  4		    RETURN KER%NORMAL;
;   5804  4		    END
;   5805  3		ELSE
;   5806  3		    RETURN KER%LINTOOLNG;
;   5807  3	
;   5808  2		END;					! End of PUT%STRING


; PUT%STRING
U.98:	SKIPG	U.93				; STR%LENGTH									5798
	JRST	L.417				; L.417
	SOS	U.93				; STR%LENGTH									5801
	MOVE	AC1,-1(SP)			; AC1,CHAR%VALUE								5802
	IDPB	AC1,U.92			; AC1,STR%POINTER
	MOVEI	AC1,13				; AC1,13									5806
	POPJ	SP,				; SP,
L.417:	MOVEI	AC1,102				; AC1,102
	POPJ	SP,				; SP,										5791

; Routine Size:  9 words


;   5809  2	!
;   5810  2	! If we have a request to start a string (input or output), save the old
;   5811  2	! routines and set up ours.  Also save the string pointer and length for
;   5812  2	! use by our get/put routines.
;   5813  2	! Otherwise this is a request to stop using the string routines, so reset
;   5814  2	! the old routines and return the actual number of characters read or
;   5815  2	! written
;   5816  2	!
;   5817  2	
;   5818  2	    IF .START
;   5819  2	    THEN
;   5820  3		BEGIN
;   5821  3		STR%POINTER = .POINTER;
;   5822  3		STR%ORG%LENGTH = .LENGTH;
;   5823  3		STR%LENGTH = .LENGTH;
;   5824  3		OLD%GET%CHR = .GET%CHR%ROUTINE;
;   5825  3		OLD%PUT%CHR = .PUT%CHR%ROUTINE;
;   5826  3		GET%CHR%ROUTINE = GET%STRING;
;   5827  3		PUT%CHR%ROUTINE = PUT%STRING;
;   5828  3		RETURN 0;
;   5829  3		END
;   5830  2	    ELSE
;   5831  3		BEGIN
;   5832  3		GET%CHR%ROUTINE = .OLD%GET%CHR;
;   5833  3		PUT%CHR%ROUTINE = .OLD%PUT%CHR;
;   5834  3		RETURN .STR%ORG%LENGTH - .STR%LENGTH;
;   5835  2		END;
;   5836  2	
;   5837  1	    END;					! End of SET%STRING


; SET%STRING
U.30:	MOVEI	AC1,1				; AC1,1										5818
	TDNN	AC1,-1(SP)			; AC1,START
	JRST	L.418				; L.418
	MOVE	AC1,-3(SP)			; AC1,POINTER									5821
	MOVEM	AC1,U.92			; AC1,STR%POINTER
	MOVE	AC1,-2(SP)			; AC1,LENGTH									5822
	MOVEM	AC1,U.94			; AC1,STR%ORG%LENGTH
	MOVE	AC1,-2(SP)			; AC1,LENGTH									5823
	MOVEM	AC1,U.93			; AC1,STR%LENGTH
	MOVE	AC1,U.66			; AC1,GET%CHR%ROUTINE								5824
	MOVEM	AC1,U.95			; AC1,OLD%GET%CHR
	MOVE	AC1,U.67			; AC1,PUT%CHR%ROUTINE								5825
	MOVEM	AC1,U.96			; AC1,OLD%PUT%CHR
	MOVEI	AC1,U.97			; AC1,GET%STRING								5826
	MOVEM	AC1,U.66			; AC1,GET%CHR%ROUTINE
	MOVEI	AC1,U.98			; AC1,PUT%STRING								5827
	MOVEM	AC1,U.67			; AC1,PUT%CHR%ROUTINE
	SETZ	AC1,				; AC1,										5831
	POPJ	SP,				; SP,
L.418:	MOVE	AC1,U.95			; AC1,OLD%GET%CHR								5832
	MOVEM	AC1,U.66			; AC1,GET%CHR%ROUTINE
	MOVE	AC1,U.96			; AC1,OLD%PUT%CHR								5833
	MOVEM	AC1,U.67			; AC1,PUT%CHR%ROUTINE
	MOVE	AC1,U.94			; AC1,STR%ORG%LENGTH								5834
	SUB	AC1,U.93			; AC1,STR%LENGTH
	POPJ	SP,				; SP,										5716

; Routine Size:  26 words


;   5838  1	%SBTTL 'Add parity routine'
;   5839  1	ROUTINE DO%PARITY (MESSAGE, LENGTH) : NOVALUE =
;   5840  1	
;   5841  1	!++
;   5842  1	! FUNCTIONAL DESCRIPTION:
;   5843  1	!
;   5844  1	!	This routine will add parity for a complete message that is to be
;   5845  1	!	sent to the remote Kermit.
;   5846  1	!
;   5847  1	! CALLING SEQUENCE:
;   5848  1	!
;   5849  1	!	DO%PARITY (Message%address, Message%length);
;   5850  1	!
;   5851  1	! INPUT PARAMETERS:
;   5852  1	!
;   5853  1	!	Message%address - Address of the message to put parity on.
;   5854  1	!	Message%length  - Lengtho of the message.
;   5855  1	!
;   5856  1	! IMPLICIT INPUTS:
;   5857  1	!
;   5858  1	!	None.
;   5859  1	!
;   5860  1	! OUTPUT PARAMETERS:
;   5861  1	!
;   5862  1	!	None.
;   5863  1	!
;   5864  1	! IMPLICIT OUTPUTS:
;   5865  1	!
;   5866  1	!	None.
;   5867  1	!
;   5868  1	! COMPLETION CODES:
;   5869  1	!
;   5870  1	!	None.
;   5871  1	!
;   5872  1	! SIDE EFFECTS:
;   5873  1	!
;   5874  1	!	None.
;   5875  1	!
;   5876  1	!--
;   5877  1	
;   5878  2	    BEGIN
;   5879  2	
;   5880  2	    MAP
;   5881  2		MESSAGE : REF VECTOR [CH$ALLOCATION (MAX%MSG, CHR%SIZE)];
;   5882  2	
;   5883  2	    LOCAL
;   5884  2		POINTER;				! Point into the message
;   5885  2	
;   5886  2	    IF NOT .DEV%PARITY%FLAG
;   5887  2	    THEN
;   5888  3		BEGIN
;   5889  3		POINTER = CH$PTR (.MESSAGE,, CHR%SIZE);
;   5890  3	
;   5891  3		INCR I FROM 1 TO .LENGTH DO
;   5892  3		    CH$WCHAR%A (GEN%PARITY (CH$RCHAR (.POINTER)), POINTER);
;   5893  3	
;   5894  2		END;
;   5895  2	
;   5896  1	    END;					! End of DO%PARITY


; DO%PARITY
U.22:	PUSH	SP,AC13				; SP,AC13									5839
	PUSH	SP,AC14				; SP,AC14
	PUSH	SP,AC16				; SP,AC16
	MOVEI	AC1,1				; AC1,1										5886
	TDNE	AC1,DEV%PARITY%FLAG		; AC1,DEV%PARITY%FLAG
	JRST	L.421				; L.421
	MOVE	AC1,-5(SP)			; AC1,MESSAGE									5889
	MOVEI	AC16,-1(AC1)			; AC16,-1(AC1)
	HRLI	AC16,41000			; AC16,41000
	MOVE	AC13,-4(SP)			; AC13,LENGTH									5891
	SETZ	AC14,				; I,
	JRST	L.420				; L.420
L.419:	MOVE	AC1,AC16			; AC1,POINTER									5892
	ILDB	AC1,AC1				; AC1,AC1
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,U.23				; SP,GEN%PARITY
	IDPB	AC1,AC16			; AC1,POINTER
	ADJSP	SP,-1				; SP,-1
L.420:	ADDI	AC14,1				; I,1										5891
	CAMG	AC14,AC13			; I,AC13
	JRST	L.419				; L.419
L.421:	POP	SP,AC16				; SP,AC16									5839
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POPJ	SP,				; SP,

; Routine Size:  25 words


;   5897  1	%SBTTL 'Parity routine'
;   5898  1	
;   5899  1	GLOBAL ROUTINE GEN%PARITY (CHARACTER) =
;   5900  1	
;   5901  1	!++
;   5902  1	! FUNCTIONAL DESCRIPTION:
;   5903  1	!
;   5904  1	!	This routine will add parity to the character that is supplied.
;   5905  1	!
;   5906  1	! CALLING SEQUENCE:
;   5907  1	!
;   5908  1	!	CHARACTER = GEN%PARITY(CHARACTER)
;   5909  1	!
;   5910  1	! INPUT PARAMETERS:
;   5911  1	!
;   5912  1	!	CHARACTER - Produce the parity for this character depending on the
;   5913  1	!		setting of the SET PARITY switch.
;   5914  1	!
;   5915  1	! IMPLICIT INPUTS:
;   5916  1	!
;   5917  1	!	None.
;   5918  1	!
;   5919  1	! OUTPUT PARAMETERS:
;   5920  1	!
;   5921  1	!	None.
;   5922  1	!
;   5923  1	! IMPLICIT OUTPUTS:
;   5924  1	!
;   5925  1	!	None.
;   5926  1	!
;   5927  1	! COMPLETION CODES:
;   5928  1	!
;   5929  1	!	None.
;   5930  1	!
;   5931  1	! SIDE EFFECTS:
;   5932  1	!
;   5933  1	!	None.
;   5934  1	!
;   5935  1	!--
;   5936  1	
;   5937  2	    BEGIN
;   5938  2	
;   5939  2	    LOCAL
;   5940  2		TEMP%CHAR;
;   5941  2	
;   5942  2	    IF .IBM%FLAG THEN RETURN .CHARACTER OR %O'200';
;   5943  2	
;   5944  2	    CASE .PARITY%TYPE FROM PR%MIN TO PR%MAX OF
;   5945  2		SET
;   5946  2	
;   5947  2		[PR%NONE] :
;   5948  2		    RETURN .CHARACTER;
;   5949  2	
;   5950  2		[PR%SPACE] :
;   5951  2		    RETURN .CHARACTER AND %O'177';
;   5952  2	
;   5953  2		[PR%MARK] :
;   5954  2		    RETURN .CHARACTER OR %O'200';
;   5955  2	
;   5956  2		[PR%ODD] :
;   5957  2		    TEMP%CHAR = .CHARACTER AND %O'177' OR %O'200';
;   5958  2	
;   5959  2		[PR%EVEN] :
;   5960  2		    TEMP%CHAR = .CHARACTER AND %O'177';
;   5961  2		TES;
;   5962  2	
;   5963  2	    TEMP%CHAR = .TEMP%CHAR XOR (.TEMP%CHAR^-4);
;   5964  2	    TEMP%CHAR = .TEMP%CHAR XOR (.TEMP%CHAR^-2);
;   5965  2	
;   5966  2	    IF .TEMP%CHAR<0, 2> EQL %B'01' OR .TEMP%CHAR<0, 2> EQL %B'10'
;   5967  2	    THEN
;   5968  2		RETURN .CHARACTER AND %O'177' OR %O'200'
;   5969  2	    ELSE
;   5970  2		RETURN .CHARACTER AND %O'177';
;   5971  2	
;   5972  1	    END;					! End of GEN%PARITY


U.23:
GEN%PARITY::
	MOVEI	AC1,1				; AC1,1										5942
	TDNN	AC1,IBM%FLAG			; AC1,IBM%FLAG
	JRST	L.422				; L.422
	MOVE	AC1,-1(SP)			; AC1,CHARACTER
	JRST	L.429				; L.429
L.422:	MOVE	AC3,-1(SP)			; AC3,CHARACTER									5948
	MOVE	AC1,PARITY%TYPE			; AC1,PARITY%TYPE								5944
	JRST	L.423(AC1)			; L.423(AC1)
L.423:	JRST	L.424				; L.424
	JRST	L.425				; L.425
	JRST	L.427				; L.427
	JRST	L.426				; L.426
	JRST	L.430				; L.430
L.424:	MOVE	AC1,AC3				; AC1,AC3									5948
	POPJ	SP,				; SP,
L.425:	MOVE	AC1,AC3				; AC1,AC3									5954
	JRST	L.429				; L.429
L.426:	LDB	AC1,C.102			; TEMP%CHAR,[POINT 7,AC3,35]  <0,7>						5957
	TROA	AC1,200				; TEMP%CHAR,200
L.427:	LDB	AC1,C.102			; TEMP%CHAR,[POINT 7,AC3,35]  <0,7>						5960
	MOVE	AC2,AC1				; AC2,TEMP%CHAR									5963
	ASH	AC2,-4				; AC2,-4
	XOR	AC1,AC2				; TEMP%CHAR,AC2
	MOVE	AC2,AC1				; AC2,TEMP%CHAR									5964
	ASH	AC2,-2				; AC2,-2
	XOR	AC1,AC2				; TEMP%CHAR,AC2
	ANDI	AC1,3				; AC1,3										5966
	CAIN	AC1,1				; AC1,1
	JRST	L.428				; L.428
	CAIE	AC1,2				; AC1,2
	JRST	L.430				; L.430
L.428:	LDB	AC1,C.102			; AC1,[POINT 7,AC3,35]  <0,7>							5968
L.429:	TROA	AC1,200				; AC1,200
L.430:	LDB	AC1,C.102			; AC1,[POINT 7,AC3,35]  <0,7>							5970
	POPJ	SP,				; SP,										5899
C.102:	POINT	7,AC3,35			; 7,AC3,35

; Routine Size:  36 words


;   5973  1	
;   5974  1	%SBTTL 'Per transfer -- Initialization'
;   5975  1	ROUTINE INIT%XFR : NOVALUE =
;   5976  1	
;   5977  1	!++
;   5978  1	! FUNCTIONAL DESCRIPTION:
;   5979  1	!
;   5980  1	!	This routine will initialize the various locations that the
;   5981  1	!	send and receive statistics are kept.
;   5982  1	!
;   5983  1	! CALLING SEQUENCE:
;   5984  1	!
;   5985  1	!	INIT%XFR();
;   5986  1	!
;   5987  1	! INPUT PARAMETERS:
;   5988  1	!
;   5989  1	!	None.
;   5990  1	!
;   5991  1	! IMPLICIT INPUTS:
;   5992  1	!
;   5993  1	!	None.
;   5994  1	!
;   5995  1	! OUTPUT PARAMETERS:
;   5996  1	!
;   5997  1	!	None.
;   5998  1	!
;   5999  1	! IMPLICIT OUTPUTS:
;   6000  1	!
;   6001  1	!	None.
;   6002  1	!
;   6003  1	! COMPLETION CODES:
;   6004  1	!
;   6005  1	!	None.
;   6006  1	!
;   6007  1	! SIDE EFFECTS:
;   6008  1	!
;   6009  1	!	None.
;   6010  1	!
;   6011  1	!--
;   6012  1	
;   6013  2	    BEGIN
;   6014  2	!
;   6015  2	! Determine if we should do 8 bit quoting
;   6016  2	!
;   6017  2	
;   6018  2	    IF .PARITY%TYPE NEQ PR%NONE
;   6019  2	    THEN
;   6020  3		BEGIN
;   6021  3		RECV%8QUOTE%CHR = .RCV%8QUOTE%CHR;
;   6022  3		END
;   6023  2	    ELSE
;   6024  3		BEGIN
;   6025  3		RECV%8QUOTE%CHR = %C'Y';
;   6026  2		END;
;   6027  2	
;   6028  2	    NUM%RETRIES = 0;
;   6029  2	    SEND%8QUOTE%CHR = .RECV%8QUOTE%CHR;
;   6030  2	!
;   6031  2	! Send parameters that may not get set before we need them for the first
;   6032  2	! time.
;   6033  2	!
;   6034  2	    SEND%PKT%SIZE = ABS (.SND%PKT%SIZE);
;   6035  2	    SEND%NPAD = ABS (.SND%NPAD);
;   6036  2	    SEND%PADCHAR = ABS (.SND%PADCHAR);
;   6037  2	    SEND%TIMEOUT = ABS (.SND%TIMEOUT);
;   6038  2	    SEND%EOL = ABS (.SND%EOL);
;   6039  2	    SEND%QUOTE%CHR = ABS (.SND%QUOTE%CHR);
;   6040  2	!
;   6041  2	! For initialization messages, we must use single character checksum
;   6042  2	! When the send-init/ack sequence has been done, we will switch to the
;   6043  2	! desired form
;   6044  2	!
;   6045  2	    BLK%CHK%TYPE = CHK%1CHAR;
;   6046  2	    INI%CHK%TYPE = .CHKTYPE;			! Send desired type
;   6047  2	!
;   6048  2	! Set desired repeat character for use in we are doing send-init
;   6049  2	! Will be overwritten by other ends desired character if it sends
;   6050  2	! the send-init.
;   6051  2	!
;   6052  2	    REPT%CHR = .SET%REPT%CHR;
;   6053  2	!
;   6054  2	! Assume packet assembly/disassembly uses characters from a file
;   6055  2	!
;   6056  2	    GET%CHR%ROUTINE = GET%FILE;			! Initialize the get-a-char routine
;   6057  2	    PUT%CHR%ROUTINE = PUT%FILE;			! And the put-a-char
;   6058  2	    TEXT%HEAD%FLAG = FALSE;			! And assume we will get an File header
;   6059  2	    NO%FILE%NEEDED = FALSE;			! Assume will do file ops
;   6060  2	    INIT%PKT%SENT = FALSE;			! And no server-init sent
;   6061  2	!
;   6062  2	! Always start with packet number 0
;   6063  2	!
;   6064  2	    MSG%NUMBER = 0;				! Initial message number
;   6065  2	!
;   6066  2	! Stats information
;   6067  2	!
;   6068  2	    SMSG%TOTAL%CHARS = 0;
;   6069  2	    RMSG%TOTAL%CHARS = 0;
;   6070  2	    SMSG%DATA%CHARS = 0;
;   6071  2	    RMSG%DATA%CHARS = 0;
;   6072  2	    SMSG%COUNT = 0;
;   6073  2	    RMSG%COUNT = 0;
;   6074  2	    RMSG%NAKS = 0;
;   6075  2	    SMSG%NAKS = 0;
;   6076  2	    XFR%TIME = SY%TIME ();
;   6077  1	    END;					! End of INIT%XFR


; INIT%XFR
U.32:	SKIPE	PARITY%TYPE			; PARITY%TYPE									6018
	SKIPA	AC1,RCV%8QUOTE%CHR		; AC1,RCV%8QUOTE%CHR								6021
	MOVEI	AC1,131				; AC1,131									6025
	MOVEM	AC1,U.37			; AC1,RECV%8QUOTE%CHR
	SETZM	U.52				; NUM%RETRIES									6028
	MOVE	AC1,U.37			; AC1,RECV%8QUOTE%CHR								6029
	MOVEM	AC1,U.44			; AC1,SEND%8QUOTE%CHR
	MOVE	AC1,SND%PKT%SIZE		; AC1,SND%PKT%SIZE								6034
	MOVMM	AC1,U.39			; AC1,SEND%PKT%SIZE
	MOVE	AC1,SND%NPAD			; AC1,SND%NPAD									6035
	MOVMM	AC1,U.40			; AC1,SEND%NPAD
	MOVE	AC1,SND%PADCHAR			; AC1,SND%PADCHAR								6036
	MOVMM	AC1,U.41			; AC1,SEND%PADCHAR
	MOVE	AC1,SND%TIMEOUT			; AC1,SND%TIMEOUT								6037
	MOVMM	AC1,SEND%TIMEOUT		; AC1,SEND%TIMEOUT
	MOVE	AC1,SND%EOL			; AC1,SND%EOL									6038
	MOVMM	AC1,U.42			; AC1,SEND%EOL
	MOVE	AC1,SND%QUOTE%CHR		; AC1,SND%QUOTE%CHR								6039
	MOVMM	AC1,U.43			; AC1,SEND%QUOTE%CHR
	MOVEI	AC1,61				; AC1,61									6045
	MOVEM	AC1,U.46			; AC1,BLK%CHK%TYPE
	MOVE	AC1,CHKTYPE			; AC1,CHKTYPE									6046
	MOVEM	AC1,U.45			; AC1,INI%CHK%TYPE
	MOVE	AC1,SET%REPT%CHR		; AC1,SET%REPT%CHR								6052
	MOVEM	AC1,U.38			; AC1,REPT%CHR
	MOVEI	AC1,GET%FILE			; AC1,GET%FILE									6056
	MOVEM	AC1,U.66			; AC1,GET%CHR%ROUTINE
	MOVEI	AC1,PUT%FILE			; AC1,PUT%FILE									6057
	MOVEM	AC1,U.67			; AC1,PUT%CHR%ROUTINE
	SETZM	U.61				; TEXT%HEAD%FLAG								6058
	SETZM	U.62				; NO%FILE%NEEDED								6059
	SETZM	U.63				; INIT%PKT%SENT									6060
	SETZM	U.53				; MSG%NUMBER									6064
	SETZM	SMSG%TOTAL%CHARS		; SMSG%TOTAL%CHARS								6068
	SETZM	RMSG%TOTAL%CHARS		; RMSG%TOTAL%CHARS								6069
	SETZM	SMSG%DATA%CHARS			; SMSG%DATA%CHARS								6070
	SETZM	RMSG%DATA%CHARS			; RMSG%DATA%CHARS								6071
	SETZM	SMSG%COUNT			; SMSG%COUNT									6072
	SETZM	RMSG%COUNT			; RMSG%COUNT									6073
	SETZM	RMSG%NAKS			; RMSG%NAKS									6074
	SETZM	SMSG%NAKS			; SMSG%NAKS									6075
	PUSHJ	SP,SY%TIME			; SP,SY%TIME									6076
	MOVEM	AC1,XFR%TIME			; AC1,XFR%TIME
	POPJ	SP,				; SP,										5975

; Routine Size:  44 words


;   6078  1	%SBTTL 'Statistics -- Finish message transfer'
;   6079  1	ROUTINE END%STATS : NOVALUE =
;   6080  1	
;   6081  1	!++
;   6082  1	! FUNCTIONAL DESCRIPTION:
;   6083  1	!
;   6084  1	!	This routine will end the collection of the statistices.  It will
;   6085  1	!	update the various overall statistic parameters.
;   6086  1	!
;   6087  1	! CALLING SEQUENCE:
;   6088  1	!
;   6089  1	!	END%STATS ();
;   6090  1	!
;   6091  1	! INPUT PARAMETERS:
;   6092  1	!
;   6093  1	!	None.
;   6094  1	!
;   6095  1	! IMPLICIT INPUTS:
;   6096  1	!
;   6097  1	!	None.
;   6098  1	!
;   6099  1	! OUTPUT PARAMETERS:
;   6100  1	!
;   6101  1	!	None.
;   6102  1	!
;   6103  1	! IMPLICIT OUTPUTS:
;   6104  1	!
;   6105  1	!	None.
;   6106  1	!
;   6107  1	! COMPLETION CODES:
;   6108  1	!
;   6109  1	!	None.
;   6110  1	!
;   6111  1	! SIDE EFFECTS:
;   6112  1	!
;   6113  1	!	None.
;   6114  1	!
;   6115  1	!--
;   6116  1	
;   6117  2	    BEGIN
;   6118  2	    SND%COUNT = .SND%COUNT + .SMSG%COUNT;
;   6119  2	    RCV%COUNT = .RCV%COUNT + .RMSG%COUNT;
;   6120  2	    SND%TOTAL%CHARS = .SND%TOTAL%CHARS + .SMSG%TOTAL%CHARS;
;   6121  2	    SND%DATA%CHARS = .SND%DATA%CHARS + .SMSG%DATA%CHARS;
;   6122  2	    RCV%TOTAL%CHARS = .RCV%TOTAL%CHARS + .RMSG%TOTAL%CHARS;
;   6123  2	    RCV%DATA%CHARS = .RCV%DATA%CHARS + .RMSG%DATA%CHARS;
;   6124  2	    SND%NAKS = .SND%NAKS + .SMSG%NAKS;
;   6125  2	    RCV%NAKS = .RCV%NAKS + .RMSG%NAKS;
;   6126  2	    XFR%TIME = SY%TIME () - .XFR%TIME;
;   6127  2	    TOTAL%TIME = .TOTAL%TIME + .XFR%TIME;
;   6128  1	    END;					! End of END%STATS


; END%STATS
U.18:	MOVE	AC1,SMSG%COUNT			; AC1,SMSG%COUNT								6118
	ADDM	AC1,SND%COUNT			; AC1,SND%COUNT
	MOVE	AC1,RMSG%COUNT			; AC1,RMSG%COUNT								6119
	ADDM	AC1,RCV%COUNT			; AC1,RCV%COUNT
	MOVE	AC1,SMSG%TOTAL%CHARS		; AC1,SMSG%TOTAL%CHARS								6120
	ADDM	AC1,SND%TOTAL%CHARS		; AC1,SND%TOTAL%CHARS
	MOVE	AC1,SMSG%DATA%CHARS		; AC1,SMSG%DATA%CHARS								6121
	ADDM	AC1,SND%DATA%CHARS		; AC1,SND%DATA%CHARS
	MOVE	AC1,RMSG%TOTAL%CHARS		; AC1,RMSG%TOTAL%CHARS								6122
	ADDM	AC1,RCV%TOTAL%CHARS		; AC1,RCV%TOTAL%CHARS
	MOVE	AC1,RMSG%DATA%CHARS		; AC1,RMSG%DATA%CHARS								6123
	ADDM	AC1,RCV%DATA%CHARS		; AC1,RCV%DATA%CHARS
	MOVE	AC1,SMSG%NAKS			; AC1,SMSG%NAKS									6124
	ADDM	AC1,SND%NAKS			; AC1,SND%NAKS
	MOVE	AC1,RMSG%NAKS			; AC1,RMSG%NAKS									6125
	ADDM	AC1,RCV%NAKS			; AC1,RCV%NAKS
	PUSHJ	SP,SY%TIME			; SP,SY%TIME									6126
	SUBB	AC1,XFR%TIME			; AC1,XFR%TIME
	ADDM	AC1,TOTAL%TIME			; AC1,TOTAL%TIME								6127
	POPJ	SP,				; SP,										6079

; Routine Size:  20 words


;   6129  1	%SBTTL 'Status type out -- STS%OUTPUT'
;   6130  1	ROUTINE STS%OUTPUT : NOVALUE =
;   6131  1	
;   6132  1	!++
;   6133  1	! FUNCTIONAL DESCRIPTION:
;   6134  1	!
;   6135  1	!	This routine will output the current status of a transfer.
;   6136  1	!	This is used when the user types a ^A during a transfer.
;   6137  1	!
;   6138  1	! CALLING SEQUENCE:
;   6139  1	!
;   6140  1	!	STS%OUTPUT ()
;   6141  1	!
;   6142  1	! INPUT PARAMETERS:
;   6143  1	!
;   6144  1	!	None.
;   6145  1	!
;   6146  1	! IMPLICIT INPUTS:
;   6147  1	!
;   6148  1	!	Statistics blocks, file names, etc.
;   6149  1	!
;   6150  1	! OUPTUT PARAMETERS:
;   6151  1	!
;   6152  1	!	None.
;   6153  1	!
;   6154  1	! IMPLICIT OUTPUTS:
;   6155  1	!
;   6156  1	!	None.
;   6157  1	!
;   6158  1	! COMPLETION CODES:
;   6159  1	!
;   6160  1	!	None.
;   6161  1	!
;   6162  1	! SIDE EFFECTS:
;   6163  1	!
;   6164  1	!	None.
;   6165  1	!
;   6166  1	!--
;   6167  1	
;   6168  2	    BEGIN
;   6169  2	    TT%CHAR (%C'[');				! Start the message
;   6170  2	
;   6171  2	    CASE .STATE FROM STATE%MIN TO STATE%MAX OF
;   6172  2		SET
;   6173  2	
;   6174  2		[STATE%ID, STATE%II] :
;   6175  2		    TT%TEXT (UPLIT (%ASCIZ'Idle in server mode'));
;   6176  2	
;   6177  2		[STATE%S, STATE%SF] :
;   6178  3		    BEGIN
;   6179  3		    TT%TEXT (UPLIT (%ASCIZ'Initializing for sending file '));
;   6180  3		    TT%TEXT (FILE%NAME);
;   6181  2		    END;
;   6182  2	
;   6183  2		[STATE%SI] :
;   6184  2		    TT%TEXT (UPLIT (%ASCIZ'Initializing for remote command'));
;   6185  2	
;   6186  2		[STATE%SG] :
;   6187  2		    TT%TEXT (UPLIT (%ASCIZ'Waiting for response to remote command'));
;   6188  2	
;   6189  2		[STATE%SD] :
;   6190  3		    BEGIN
;   6191  3		    TT%NUMBER (.FILE%CHARS);
;   6192  3		    TT%TEXT (UPLIT (%ASCIZ' characters sent for file '));
;   6193  3		    TT%TEXT (FILE%NAME);
;   6194  2		    END;
;   6195  2	
;   6196  2		[STATE%SZ] :
;   6197  3		    BEGIN
;   6198  3		    TT%TEXT (UPLIT (%ASCIZ'At end of file '));
;   6199  3		    TT%TEXT (FILE%NAME);
;   6200  2		    END;
;   6201  2	
;   6202  2		[STATE%SB] :
;   6203  2		    TT%TEXT (UPLIT (%ASCIZ'Finishing transfer session'));
;   6204  2	
;   6205  2		[STATE%R] :
;   6206  2		    TT%TEXT (UPLIT (%ASCIZ'Waiting for initialization'));
;   6207  2	
;   6208  2		[STATE%RF] :
;   6209  2		    TT%TEXT (UPLIT (%ASCIZ'Waiting for next file or end of session'));
;   6210  2	
;   6211  2		[STATE%RD] :
;   6212  3		    BEGIN
;   6213  3		    TT%NUMBER (.FILE%CHARS);
;   6214  3		    TT%TEXT (UPLIT (%ASCIZ' characters received for file '));
;   6215  3		    TT%TEXT (FILE%NAME);
;   6216  2		    END;
;   6217  2	
;   6218  2		[STATE%C] :
;   6219  2		    TT%TEXT (UPLIT (%ASCIZ' Session complete'));
;   6220  2	
;   6221  2		[STATE%A] :
;   6222  2		    TT%TEXT (UPLIT (%ASCIZ' Session aborted'));
;   6223  2	
;   6224  2		[INRANGE, OUTRANGE] :
;   6225  2		    TT%TEXT (UPLIT (%ASCIZ' Unknown state'));
;   6226  2		TES;
;   6227  2	
;   6228  2	    SELECTONE .STATE OF
;   6229  2		SET
;   6230  2	
;   6231  2		[STATE%S, STATE%SF, STATE%SD, STATE%SZ, STATE%SB] :
;   6232  3		    BEGIN
;   6233  3	
;   6234  3		    IF .RMSG%NAKS GTR 0
;   6235  3		    THEN
;   6236  4			BEGIN
;   6237  4			TT%TEXT (UPLIT (%ASCIZ', '));
;   6238  4			TT%NUMBER (.RMSG%NAKS);
;   6239  4			TT%TEXT (UPLIT (%ASCIZ' NAKs received'));
;   6240  3			END;
;   6241  3	
;   6242  2		    END;
;   6243  2	
;   6244  2		[STATE%R, STATE%RF, STATE%RD] :
;   6245  3		    BEGIN
;   6246  3	
;   6247  3		    IF .SMSG%NAKS GTR 0
;   6248  3		    THEN
;   6249  4			BEGIN
;   6250  4			TT%TEXT (UPLIT (%ASCIZ', '));
;   6251  4			TT%NUMBER (.SMSG%NAKS);
;   6252  4			TT%TEXT (UPLIT (%ASCIZ' NAKs sent'));
;   6253  3			END;
;   6254  3	
;   6255  2		    END;
;   6256  2		TES;
;   6257  2	
;   6258  2	    TT%CHAR (%C']');				! End the line
;   6259  2	    TT%CRLF ();					! with a CRLF
;   6260  1	    END;					! End of STS%OUTPUT


P.AAP:	BYTE	(7)"I","d","l","e"," "		; Idle
	BYTE	(7)"i","n"," ","s","e"		; in se
	BYTE	(7)"r","v","e","r"," "		; rver
	BYTE	(7)"m","o","d","e",000		; mode
P.AAQ:	BYTE	(7)"I","n","i","t","i"		; Initi
	BYTE	(7)"a","l","i","z","i"		; alizi
	BYTE	(7)"n","g"," ","f","o"		; ng fo
	BYTE	(7)"r"," ","s","e","n"		; r sen
	BYTE	(7)"d","i","n","g"," "		; ding
	BYTE	(7)"f","i","l","e"," "		; file
	BYTE	(7)000,000,000,000,000
P.AAR:	BYTE	(7)"I","n","i","t","i"		; Initi
	BYTE	(7)"a","l","i","z","i"		; alizi
	BYTE	(7)"n","g"," ","f","o"		; ng fo
	BYTE	(7)"r"," ","r","e","m"		; r rem
	BYTE	(7)"o","t","e"," ","c"		; ote c
	BYTE	(7)"o","m","m","a","n"		; omman
	BYTE	(7)"d",000,000,000,000		; d
P.AAS:	BYTE	(7)"W","a","i","t","i"		; Waiti
	BYTE	(7)"n","g"," ","f","o"		; ng fo
	BYTE	(7)"r"," ","r","e","s"		; r res
	BYTE	(7)"p","o","n","s","e"		; ponse
	BYTE	(7)" ","t","o"," ","r"		;  to r
	BYTE	(7)"e","m","o","t","e"		; emote
	BYTE	(7)" ","c","o","m","m"		;  comm
	BYTE	(7)"a","n","d",000,000		; and
P.AAT:	BYTE	(7)" ","c","h","a","r"		;  char
	BYTE	(7)"a","c","t","e","r"		; acter
	BYTE	(7)"s"," ","s","e","n"		; s sen
	BYTE	(7)"t"," ","f","o","r"		; t for
	BYTE	(7)" ","f","i","l","e"		;  file
	BYTE	(7)" ",000,000,000,000
P.AAU:	BYTE	(7)"A","t"," ","e","n"		; At en
	BYTE	(7)"d"," ","o","f"," "		; d of
	BYTE	(7)"f","i","l","e"," "		; file
	BYTE	(7)000,000,000,000,000
P.AAV:	BYTE	(7)"F","i","n","i","s"		; Finis
	BYTE	(7)"h","i","n","g"," "		; hing
	BYTE	(7)"t","r","a","n","s"		; trans
	BYTE	(7)"f","e","r"," ","s"		; fer s
	BYTE	(7)"e","s","s","i","o"		; essio
	BYTE	(7)"n",000,000,000,000		; n
P.AAW:	BYTE	(7)"W","a","i","t","i"		; Waiti
	BYTE	(7)"n","g"," ","f","o"		; ng fo
	BYTE	(7)"r"," ","i","n","i"		; r ini
	BYTE	(7)"t","i","a","l","i"		; tiali
	BYTE	(7)"z","a","t","i","o"		; zatio
	BYTE	(7)"n",000,000,000,000		; n
P.AAX:	BYTE	(7)"W","a","i","t","i"		; Waiti
	BYTE	(7)"n","g"," ","f","o"		; ng fo
	BYTE	(7)"r"," ","n","e","x"		; r nex
	BYTE	(7)"t"," ","f","i","l"		; t fil
	BYTE	(7)"e"," ","o","r"," "		; e or
	BYTE	(7)"e","n","d"," ","o"		; end o
	BYTE	(7)"f"," ","s","e","s"		; f ses
	BYTE	(7)"s","i","o","n",000		; sion
P.AAY:	BYTE	(7)" ","c","h","a","r"		;  char
	BYTE	(7)"a","c","t","e","r"		; acter
	BYTE	(7)"s"," ","r","e","c"		; s rec
	BYTE	(7)"e","i","v","e","d"		; eived
	BYTE	(7)" ","f","o","r"," "		;  for
	BYTE	(7)"f","i","l","e"," "		; file
	BYTE	(7)000,000,000,000,000
P.AAZ:	BYTE	(7)" ","S","e","s","s"		;  Sess
	BYTE	(7)"i","o","n"," ","c"		; ion c
	BYTE	(7)"o","m","p","l","e"		; omple
	BYTE	(7)"t","e",000,000,000		; te
P.ABA:	BYTE	(7)" ","S","e","s","s"		;  Sess
	BYTE	(7)"i","o","n"," ","a"		; ion a
	BYTE	(7)"b","o","r","t","e"		; borte
	BYTE	(7)"d",000,000,000,000		; d
P.ABB:	BYTE	(7)" ","U","n","k","n"		;  Unkn
	BYTE	(7)"o","w","n"," ","s"		; own s
	BYTE	(7)"t","a","t","e",000		; tate
P.ABC:	BYTE	(7)","," ",000,000,000		; ,
P.ABD:	BYTE	(7)" ","N","A","K","s"		;  NAKs
	BYTE	(7)" ","r","e","c","e"		;  rece
	BYTE	(7)"i","v","e","d",000		; ived
P.ABE:	BYTE	(7)","," ",000,000,000		; ,
P.ABF:	BYTE	(7)" ","N","A","K","s"		;  NAKs
	BYTE	(7)" ","s","e","n","t"		;  sent
	BYTE	(7)000,000,000,000,000


; STS%OUTPUT
U.33:	PUSH	SP,C.103			; SP,[133]									6169
	PUSHJ	SP,TT%CHAR			; SP,TT%CHAR
	MOVE	AC1,U.49			; AC1,STATE									6171
	SOJL	AC1,L.432			; AC1,L.432
	CAIGE	AC1,24				; AC1,24
	JRST	L.431(AC1)			; L.431(AC1)
	JRST	L.432				; L.432
L.431:	JRST	L.434				; L.434
	JRST	L.434				; L.434
	JRST	L.437				; L.437
	JRST	L.438				; L.438
	JRST	L.440				; L.440
	JRST	L.441				; L.441
	JRST	L.442				; L.442
	JRST	L.443				; L.443
	JRST	L.445				; L.445
	JRST	L.446				; L.446
	JRST	L.432				; L.432
	JRST	L.436				; L.436
	JRST	L.435				; L.435
	JRST	L.433				; L.433
	JRST	L.433				; L.433
	JRST	L.432				; L.432
	JRST	L.432				; L.432
	JRST	L.432				; L.432
	JRST	L.432				; L.432
	JRST	L.432				; L.432
L.432:	PUSH	SP,C.104			; SP,[0,,P.ABB]									6225
	JRST	L.447				; L.447
L.433:	PUSH	SP,C.105			; SP,[0,,P.AAP]									6175
	JRST	L.447				; L.447
L.434:	PUSH	SP,C.106			; SP,[0,,P.AAQ]									6179
	JRST	L.439				; L.439
L.435:	PUSH	SP,C.107			; SP,[0,,P.AAR]									6184
	JRST	L.447				; L.447
L.436:	PUSH	SP,C.108			; SP,[0,,P.AAS]									6187
	JRST	L.447				; L.447
L.437:	PUSH	SP,U.60				; SP,FILE%CHARS									6191
	PUSHJ	SP,TT%NUMBER			; SP,TT%NUMBER
	PUSH	SP,C.109			; SP,[0,,P.AAT]									6192
	JRST	L.444				; L.444
L.438:	PUSH	SP,C.110			; SP,[0,,P.AAU]									6198
L.439:	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSH	SP,C.35				; SP,[0,,FILE%NAME]								6199
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	ADJSP	SP,-1				; SP,-1										6197
	JRST	L.448				; L.448										6171
L.440:	PUSH	SP,C.111			; SP,[0,,P.AAV]									6203
	JRST	L.447				; L.447
L.441:	PUSH	SP,C.112			; SP,[0,,P.AAW]									6206
	JRST	L.447				; L.447
L.442:	PUSH	SP,C.113			; SP,[0,,P.AAX]									6209
	JRST	L.447				; L.447
L.443:	PUSH	SP,U.60				; SP,FILE%CHARS									6213
	PUSHJ	SP,TT%NUMBER			; SP,TT%NUMBER
	PUSH	SP,C.114			; SP,[0,,P.AAY]									6214
L.444:	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSH	SP,C.35				; SP,[0,,FILE%NAME]								6215
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	ADJSP	SP,-2				; SP,-2										6212
	JRST	L.448				; L.448										6171
L.445:	PUSH	SP,C.115			; SP,[0,,P.AAZ]									6219
	JRST	L.447				; L.447
L.446:	PUSH	SP,C.116			; SP,[0,,P.ABA]									6222
L.447:	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
L.448:	MOVE	AC1,U.49			; AC1,STATE									6228
	JUMPLE	AC1,L.449			; AC1,L.449									6231
	CAILE	AC1,5				; AC1,5
	JRST	L.449				; L.449
	SKIPG	RMSG%NAKS			; RMSG%NAKS									6234
	JRST	L.451				; L.451
	PUSH	SP,C.117			; SP,[0,,P.ABC]									6237
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSH	SP,RMSG%NAKS			; SP,RMSG%NAKS									6238
	PUSHJ	SP,TT%NUMBER			; SP,TT%NUMBER
	PUSH	SP,C.118			; SP,[0,,P.ABD]									6239
	JRST	L.450				; L.450
L.449:	CAIL	AC1,6				; AC1,6										6244
	CAILE	AC1,10				; AC1,10
	JRST	L.451				; L.451
	SKIPG	SMSG%NAKS			; SMSG%NAKS									6247
	JRST	L.451				; L.451
	PUSH	SP,C.119			; SP,[0,,P.ABE]									6250
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSH	SP,SMSG%NAKS			; SP,SMSG%NAKS									6251
	PUSHJ	SP,TT%NUMBER			; SP,TT%NUMBER
	PUSH	SP,C.120			; SP,[0,,P.ABF]									6252
L.450:	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	ADJSP	SP,-3				; SP,-3										6249
L.451:	PUSH	SP,C.121			; SP,[135]									6258
	PUSHJ	SP,TT%CHAR			; SP,TT%CHAR
	PUSHJ	SP,TT%CRLF			; SP,TT%CRLF									6259
	ADJSP	SP,-3				; SP,-3										6168
	POPJ	SP,				; SP,										6130
C.103:	EXP	133				; 133
C.104:	XWD	0,P.ABB				; 0,P.ABB
C.105:	XWD	0,P.AAP				; 0,P.AAP
C.106:	XWD	0,P.AAQ				; 0,P.AAQ
C.107:	XWD	0,P.AAR				; 0,P.AAR
C.108:	XWD	0,P.AAS				; 0,P.AAS
C.109:	XWD	0,P.AAT				; 0,P.AAT
C.110:	XWD	0,P.AAU				; 0,P.AAU
C.111:	XWD	0,P.AAV				; 0,P.AAV
C.112:	XWD	0,P.AAW				; 0,P.AAW
C.113:	XWD	0,P.AAX				; 0,P.AAX
C.114:	XWD	0,P.AAY				; 0,P.AAY
C.115:	XWD	0,P.AAZ				; 0,P.AAZ
C.116:	XWD	0,P.ABA				; 0,P.ABA
C.117:	XWD	0,P.ABC				; 0,P.ABC
C.118:	XWD	0,P.ABD				; 0,P.ABD
C.119:	XWD	0,P.ABE				; 0,P.ABE
C.120:	XWD	0,P.ABF				; 0,P.ABF
C.121:	EXP	135				; 135

; Routine Size:  113 words


;   6261  1	%SBTTL 'TYPE%CHAR - Type out a character'
;   6262  1	ROUTINE TYPE%CHAR (CHARACTER) =
;   6263  1	
;   6264  1	!++
;   6265  1	! FUNCTIONAL DESCRIPTION:
;   6266  1	!
;   6267  1	! This routine is used as an alternate output routine for BFR%EMPTY.
;   6268  1	! It will type the character on the terminal, and always return a
;   6269  1	! true status.
;   6270  1	!
;   6271  1	! CALLING SEQUENCE:
;   6272  1	!
;   6273  1	!	STATUS = TYPE%CHAR (.CHARACTER);
;   6274  1	!
;   6275  1	! INPUT PARAMETERS:
;   6276  1	!
;   6277  1	!	CHARACTER - The character to type
;   6278  1	!
;   6279  1	! IMPLICIT INPUTS:
;   6280  1	!
;   6281  1	!	None.
;   6282  1	!
;   6283  1	! OUPTUT PARAMETERS:
;   6284  1	!
;   6285  1	!	None.
;   6286  1	!
;   6287  1	! IMPLICIT OUTPUTS:
;   6288  1	!
;   6289  1	!	None.
;   6290  1	!
;   6291  1	! COMPLETION CODES:
;   6292  1	!
;   6293  1	!	None.
;   6294  1	!
;   6295  1	! SIDE EFFECTS:
;   6296  1	!
;   6297  1	!	None.
;   6298  1	!
;   6299  1	!--
;   6300  1	
;   6301  2	    BEGIN
;   6302  2	    TT%CHAR (.CHARACTER);			! Type the character
;   6303  2	    RETURN KER%NORMAL;				! And return OK
;   6304  1	    END;					! End of TYPE%CHAR


; TYPE%CHAR
U.31:	PUSH	SP,-1(SP)			; SP,CHARACTER									6302
	PUSHJ	SP,TT%CHAR			; SP,TT%CHAR
	ADJSP	SP,-1				; SP,-1										6303
	MOVEI	AC1,13				; AC1,13									6301
	POPJ	SP,				; SP,										6262

; Routine Size:  5 words


;   6305  1	%SBTTL 'Debugging -- DBG%SEND'
;   6306  1	ROUTINE DBG%SEND (ADDRESS, LENGTH) : NOVALUE =
;   6307  1	
;   6308  1	!++
;   6309  1	! FUNCTIONAL DESCRIPTION:
;   6310  1	!
;   6311  1	!	This routine will output the message that is going to be sent
;   6312  1	!	as part of the debugging information that is turned on in the
;   6313  1	!	SET DEBUG command.
;   6314  1	!
;   6315  1	! CALLING SEQUENCE:
;   6316  1	!
;   6317  1	!	DBG%SEND(MSG%ADDRESS, MSG%LENGTH);
;   6318  1	!
;   6319  1	! INPUT PARAMETERS:
;   6320  1	!
;   6321  1	!	MSG%ADDRESS - Address of the message that is going to be sent
;   6322  1	!		to the remote KERMIT.  The bytes are CHR%SIZE.
;   6323  1	!	MSG%LENGTH - Length of the message.
;   6324  1	!
;   6325  1	! IMPLICIT INPUTS:
;   6326  1	!
;   6327  1	!	None.
;   6328  1	!
;   6329  1	! OUTPUT PARAMETERS:
;   6330  1	!
;   6331  1	!	None.
;   6332  1	!
;   6333  1	! IMPLICIT OUTPUTS:
;   6334  1	!
;   6335  1	!	None.
;   6336  1	!
;   6337  1	! COMPLETION CODES:
;   6338  1	!
;   6339  1	!	None.
;   6340  1	!
;   6341  1	! SIDE EFFECTS:
;   6342  1	!
;   6343  1	!	None.
;   6344  1	!
;   6345  1	!--
;   6346  1	
;   6347  2	    BEGIN
;   6348  2	
;   6349  2	    BIND
;   6350  2		SEND%TEXT = UPLIT (%ASCIZ'Sending...');
;   6351  2	
;   6352  2	    IF .DEBUG%FLAG
;   6353  2	    THEN
;   6354  3		BEGIN
;   6355  3	
;   6356  3		LOCAL
;   6357  3		    OLD%RTN;
;   6358  3	
;   6359  3		OLD%RTN = TT%SET%OUTPUT (DBG%DUMP);
;   6360  3		TT%TEXT (SEND%TEXT);
;   6361  3		DBG%MESSAGE (.ADDRESS, .LENGTH);
;   6362  3		TT%SET%OUTPUT (.OLD%RTN);
;   6363  2		END;
;   6364  2	
;   6365  1	    END;					! End of DBG%SEND


P.ABG:	BYTE	(7)"S","e","n","d","i"		; Sendi
	BYTE	(7)"n","g",".",".","."		; ng...
	BYTE	(7)000,000,000,000,000


; SEND%TEXT
U.100=		    P.ABG


; DBG%SEND
U.35:	PUSH	SP,AC16				; SP,AC16									6306
	MOVEI	AC1,1				; AC1,1										6352
	TDNN	AC1,DEBUG%FLAG			; AC1,DEBUG%FLAG
	JRST	L.452				; L.452
	PUSH	SP,C.91				; SP,[0,,DBG%DUMP]								6359
	PUSHJ	SP,TT%SET%OUTPUT		; SP,TT%SET%OUTPUT
	MOVE	AC16,AC1			; OLD%RTN,AC1
	PUSH	SP,C.122			; SP,[0,,SEND%TEXT]								6360
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSH	SP,-5(SP)			; SP,ADDRESS									6361
	PUSH	SP,-5(SP)			; SP,LENGTH
	PUSHJ	SP,U.34				; SP,DBG%MESSAGE
	MOVEM	AC16,0(SP)			; OLD%RTN,0(SP)									6362
	PUSHJ	SP,TT%SET%OUTPUT		; SP,TT%SET%OUTPUT
	ADJSP	SP,-4				; SP,-4										6354
L.452:	POP	SP,AC16				; SP,AC16									6306
	POPJ	SP,				; SP,
C.122:	XWD	0,U.100				; 0,SEND%TEXT

; Routine Size:  18 words


;   6366  1	%SBTTL 'Debugging -- DBG%RECEIVE'
;   6367  1	ROUTINE DBG%RECEIVE (ADDRESS) : NOVALUE =
;   6368  1	
;   6369  1	!++
;   6370  1	! FUNCTIONAL DESCRIPTION:
;   6371  1	!
;   6372  1	!	This routine will output the message that was received from
;   6373  1	!	the remote KERMIT.  This routine is called only if the DEBUG%FLAG
;   6374  1	!	is true.
;   6375  1	!
;   6376  1	! CALLING SEQUENCE:
;   6377  1	!
;   6378  1	!	DBG%RECEIVE(MSG%ADDRESS);
;   6379  1	!
;   6380  1	! INPUT PARAMETERS:
;   6381  1	!
;   6382  1	!	MSG%ADDRESS - Address of the message received by the remote KERMIT.
;   6383  1	!
;   6384  1	! IMPLICIT INPUTS:
;   6385  1	!
;   6386  1	!	None.
;   6387  1	!
;   6388  1	! OUTPUT PARAMETERS:
;   6389  1	!
;   6390  1	!	None.
;   6391  1	!
;   6392  1	! IMPLICIT OUTPUTS:
;   6393  1	!
;   6394  1	!	None.
;   6395  1	!
;   6396  1	! COMPLETION CODES:
;   6397  1	!
;   6398  1	!	None.
;   6399  1	!
;   6400  1	! SIDE EFFECTS:
;   6401  1	!
;   6402  1	!	None.
;   6403  1	!
;   6404  1	!--
;   6405  1	
;   6406  2	    BEGIN
;   6407  2	
;   6408  2	    BIND
;   6409  2		RECEIVE%TEXT = UPLIT (%ASCIZ'Received...');
;   6410  2	
;   6411  2	    IF .DEBUG%FLAG
;   6412  2	    THEN
;   6413  3		BEGIN
;   6414  3	
;   6415  3		LOCAL
;   6416  3		    OLD%RTN;
;   6417  3	
;   6418  3		OLD%RTN = TT%SET%OUTPUT (DBG%DUMP);
;   6419  3		TT%TEXT (RECEIVE%TEXT);
;   6420  3		DBG%MESSAGE (.ADDRESS, .REC%LENGTH);
;   6421  3		TT%SET%OUTPUT (.OLD%RTN);
;   6422  2		END;
;   6423  2	
;   6424  1	    END;					! End of DBG%RECEIVE


P.ABH:	BYTE	(7)"R","e","c","e","i"		; Recei
	BYTE	(7)"v","e","d",".","."		; ved..
	BYTE	(7)".",000,000,000,000		; .


; RECEIVE%TEXT
U.101=		    P.ABH


; DBG%RECEIVE
U.36:	PUSH	SP,AC16				; SP,AC16									6367
	MOVEI	AC1,1				; AC1,1										6411
	TDNN	AC1,DEBUG%FLAG			; AC1,DEBUG%FLAG
	JRST	L.453				; L.453
	PUSH	SP,C.91				; SP,[0,,DBG%DUMP]								6418
	PUSHJ	SP,TT%SET%OUTPUT		; SP,TT%SET%OUTPUT
	MOVE	AC16,AC1			; OLD%RTN,AC1
	PUSH	SP,C.123			; SP,[0,,RECEIVE%TEXT]								6419
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSH	SP,-4(SP)			; SP,ADDRESS									6420
	PUSH	SP,U.55				; SP,REC%LENGTH
	PUSHJ	SP,U.34				; SP,DBG%MESSAGE
	MOVEM	AC16,0(SP)			; OLD%RTN,0(SP)									6421
	PUSHJ	SP,TT%SET%OUTPUT		; SP,TT%SET%OUTPUT
	ADJSP	SP,-4				; SP,-4										6413
L.453:	POP	SP,AC16				; SP,AC16									6367
	POPJ	SP,				; SP,
C.123:	XWD	0,U.101				; 0,RECEIVE%TEXT

; Routine Size:  18 words


;   6425  1	%SBTTL 'Debugging -- DBG%MESSAGE'
;   6426  1	ROUTINE DBG%MESSAGE (MSG%ADDRESS, MSG%LENGTH) : NOVALUE =
;   6427  1	
;   6428  1	!++
;   6429  1	! FUNCTIONAL DESCRIPTION:
;   6430  1	!
;   6431  1	!	This routine will display a message that is either being sent
;   6432  1	!	or received on the user's terminal.
;   6433  1	!
;   6434  1	! CALLING SEQUENCE:
;   6435  1	!
;   6436  1	!	DBG%MESSAGE(MSG%ADDRESS, MSG%LENGTH);
;   6437  1	!
;   6438  1	! INPUT PARAMETERS:
;   6439  1	!
;   6440  1	!	MSG%ADDRESS - Address of the message to be output
;   6441  1	!	MSG%LENGTH - Length of the message to be output.
;   6442  1	!
;   6443  1	! IMPLICIT INPUTS:
;   6444  1	!
;   6445  1	!	None.
;   6446  1	!
;   6447  1	! OUTPUT PARAMETERS:
;   6448  1	!
;   6449  1	!	None.
;   6450  1	!
;   6451  1	! IMPLICIT OUTPUTS:
;   6452  1	!
;   6453  1	!	None.
;   6454  1	!
;   6455  1	! COMPLETION CODES:
;   6456  1	!
;   6457  1	!	None.
;   6458  1	!
;   6459  1	! SIDE EFFECTS:
;   6460  1	!
;   6461  1	!	None.
;   6462  1	!
;   6463  1	!--
;   6464  1	
;   6465  2	    BEGIN
;   6466  2	
;   6467  2	    MAP
;   6468  2		MSG%ADDRESS : REF VECTOR [CH$ALLOCATION (MAX%MSG, CHR%SIZE)];	! Point to the vector
;   6469  2	
;   6470  2	    LOCAL
;   6471  2		OLD%RTN,				! Old type out routine
;   6472  2		CHKSUM,					! Numeric value of block check
;   6473  2		TEMP%POINTER,				! Temporary character pointer
;   6474  2		MSG%LEN;
;   6475  2	
;   6476  2	!
;   6477  2	! Message type text
;   6478  2	!
;   6479  2	
;   6480  2	    BIND
;   6481  2		DATA%TEXT = UPLIT (%ASCIZ' (Data)'),
;   6482  2		ACK%TEXT = UPLIT (%ASCIZ' (ACK)'),
;   6483  2		NAK%TEXT = UPLIT (%ASCIZ' (NAK)'),
;   6484  2		SND%INIT%TEXT = UPLIT (%ASCIZ' (Send init)'),
;   6485  2		BREAK%TEXT = UPLIT (%ASCIZ' (Break)'),
;   6486  2		TEXT%TEXT = UPLIT (%ASCIZ' (Text header)'),
;   6487  2		FILE%TEXT = UPLIT (%ASCIZ' (File header)'),
;   6488  2		EOF%TEXT = UPLIT (%ASCIZ' (EOF)'),
;   6489  2		ERROR%TEXT = UPLIT (%ASCIZ' (Error)'),
;   6490  2		RCV%INIT%TEXT = UPLIT (%ASCIZ' (Receive initiate)'),
;   6491  2		COMMAND%TEXT = UPLIT (%ASCIZ' (Command)'),
;   6492  2		KERMIT%TEXT = UPLIT (%ASCIZ' (Generic KERMIT command)');
;   6493  2	
;   6494  2	!
;   6495  2	! Header information
;   6496  2	!
;   6497  2	
;   6498  2	    BIND
;   6499  2		MN%TEXT = UPLIT (%ASCIZ'Message number: '),
;   6500  2		LENGTH%TEXT = UPLIT (%ASCIZ'	Length: '),
;   6501  2		DEC%TEXT = UPLIT (%ASCIZ' (dec)'),
;   6502  2		MSG%TYP%TEXT = UPLIT (%ASCIZ'Message type: '),
;   6503  2		CHKSUM%TEXT = UPLIT (%ASCIZ'Checksum: '),
;   6504  2		CHKSUM%NUM%TEXT = UPLIT (%ASCIZ' = '),
;   6505  2		OPT%DATA%TEXT = UPLIT (%ASCIZ'Optional data: '),
;   6506  2		PRE%CHAR%TEXT = UPLIT (%ASCIZ' "');
;   6507  2	
;   6508  2	!
;   6509  2	! Ensure that the type out will go to the debugging location
;   6510  2	!
;   6511  2	    OLD%RTN = TT%SET%OUTPUT (DBG%DUMP);
;   6512  2	!
;   6513  2	! Preliminary calculations
;   6514  2	!
;   6515  2	    MSG%LEN = UNCHAR (CH$RCHAR (CH$PTR (.MSG%ADDRESS, PKT%COUNT, CHR%SIZE)));
;   6516  2	!
;   6517  2	! First output some header information for the packet.
;   6518  2	!
;   6519  2	    TT%CRLF ();
;   6520  2	    TT%TEXT (MN%TEXT);
;   6521  2	    TT%NUMBER (UNCHAR (CH$RCHAR (CH$PTR (.MSG%ADDRESS, PKT%SEQ, CHR%SIZE))));
;   6522  2	    TT%TEXT (DEC%TEXT);
;   6523  2	    TT%TEXT (LENGTH%TEXT);
;   6524  2	    TT%NUMBER (.MSG%LEN);
;   6525  2	    TT%TEXT (DEC%TEXT);
;   6526  2	    TT%CRLF ();
;   6527  2	!
;   6528  2	! Now output the message type and dependent information
;   6529  2	!
;   6530  2	    TT%TEXT (MSG%TYP%TEXT);
;   6531  2	    TT%CHAR (CH$RCHAR (CH$PTR (.MSG%ADDRESS, PKT%TYPE, CHR%SIZE)));
;   6532  2	
;   6533  2	    SELECTONE CH$RCHAR (CH$PTR (.MSG%ADDRESS, PKT%TYPE, CHR%SIZE)) OF
;   6534  2		SET
;   6535  2	
;   6536  2		[MSG%DATA] :
;   6537  2		    TT%TEXT (DATA%TEXT);
;   6538  2	
;   6539  2		[MSG%ACK] :
;   6540  2		    TT%TEXT (ACK%TEXT);
;   6541  2	
;   6542  2		[MSG%NAK] :
;   6543  2		    TT%TEXT (NAK%TEXT);
;   6544  2	
;   6545  2		[MSG%SND%INIT] :
;   6546  2		    TT%TEXT (SND%INIT%TEXT);
;   6547  2	
;   6548  2		[MSG%BREAK] :
;   6549  2		    TT%TEXT (BREAK%TEXT);
;   6550  2	
;   6551  2		[MSG%FILE] :
;   6552  2		    TT%TEXT (FILE%TEXT);
;   6553  2	
;   6554  2		[MSG%TEXT] :
;   6555  2		    TT%TEXT (TEXT%TEXT);
;   6556  2	
;   6557  2		[MSG%EOF] :
;   6558  2		    TT%TEXT (EOF%TEXT);
;   6559  2	
;   6560  2		[MSG%ERROR] :
;   6561  2		    TT%TEXT (ERROR%TEXT);
;   6562  2	
;   6563  2		[MSG%GENERIC] :
;   6564  2		    TT%TEXT (KERMIT%TEXT);
;   6565  2	
;   6566  2		[MSG%COMMAND] :
;   6567  2		    TT%TEXT (COMMAND%TEXT);
;   6568  2		TES;
;   6569  2	
;   6570  2	    TT%CRLF ();
;   6571  2	!
;   6572  2	! Now output any of the optional data.
;   6573  2	!
;   6574  2	
;   6575  2	    IF .MSG%LEN - PKT%OVR%HEAD - (.BLK%CHK%TYPE - CHK%1CHAR) NEQ 0
;   6576  2	    THEN
;   6577  3		BEGIN
;   6578  3		TT%TEXT (OPT%DATA%TEXT);
;   6579  3		TT%CRLF ();
;   6580  3		TEMP%POINTER = CH$PTR (.MSG%ADDRESS, PKT%MSG, CHR%SIZE);
;   6581  3	
;   6582  3		INCR I FROM 1 TO .MSG%LEN - PKT%OVR%HEAD - (.BLK%CHK%TYPE - CHK%1CHAR) DO
;   6583  4		    BEGIN
;   6584  4	
;   6585  4		    IF (.I MOD 10) EQL 1
;   6586  4		    THEN
;   6587  5			BEGIN
;   6588  5			TT%CRLF ();
;   6589  5			TT%CHAR (CHR%TAB);
;   6590  4			END;
;   6591  4	
;   6592  4		    TT%TEXT (PRE%CHAR%TEXT);
;   6593  4		    TT%CHAR (CH$RCHAR%A (TEMP%POINTER));
;   6594  4		    TT%CHAR (%C'"');
;   6595  3		    END;
;   6596  3	
;   6597  3		IF ((.MSG%LEN - PKT%OVR%HEAD - (.BLK%CHK%TYPE - CHK%1CHAR)) MOD 10) EQL 1 THEN TT%CRLF ();
;   6598  3	
;   6599  3		TT%CRLF ();
;   6600  2		END;
;   6601  2	
;   6602  2	!
;   6603  2	! Now output the checksum for the message that we received
;   6604  2	!
;   6605  2	! This could be either 1 two or three characters.
;   6606  2	    TT%TEXT (CHKSUM%TEXT);
;   6607  2	    TEMP%POINTER = CH$PTR (.MSG%ADDRESS,
;   6608  2		PKT%MSG + .MSG%LEN + PKT%CHKSUM - PKT%OVR%HEAD - (.BLK%CHK%TYPE - CHK%1CHAR), CHR%SIZE);
;   6609  2	
;   6610  2	    CASE .BLK%CHK%TYPE FROM CHK%1CHAR TO CHK%CRC OF
;   6611  2		SET
;   6612  2	
;   6613  2		[CHK%1CHAR] :
;   6614  3		    BEGIN
;   6615  3		    TT%TEXT (PRE%CHAR%TEXT);
;   6616  3		    TT%CHAR (CH$RCHAR (.TEMP%POINTER));
;   6617  3		    TT%CHAR (%C'"');
;   6618  3		    CHKSUM = UNCHAR (CH$RCHAR (.TEMP%POINTER));
;   6619  2		    END;
;   6620  2	
;   6621  2		[CHK%2CHAR] :
;   6622  3		    BEGIN
;   6623  3		    CHKSUM = 0;
;   6624  3		    TT%TEXT (PRE%CHAR%TEXT);
;   6625  3		    TT%CHAR (CH$RCHAR (.TEMP%POINTER));
;   6626  3		    TT%CHAR (%C'"');
;   6627  3		    CHKSUM<6, 6> = UNCHAR (CH$RCHAR%A (TEMP%POINTER));
;   6628  3		    TT%TEXT (PRE%CHAR%TEXT);
;   6629  3		    TT%CHAR (CH$RCHAR (.TEMP%POINTER));
;   6630  3		    TT%CHAR (%C'"');
;   6631  3		    CHKSUM<0, 6> = UNCHAR (CH$RCHAR (.TEMP%POINTER));
;   6632  2		    END;
;   6633  2	
;   6634  2		[CHK%CRC] :
;   6635  3		    BEGIN
;   6636  3		    CHKSUM = 0;
;   6637  3		    TT%TEXT (PRE%CHAR%TEXT);
;   6638  3		    TT%CHAR (CH$RCHAR (.TEMP%POINTER));
;   6639  3		    TT%CHAR (%C'"');
;   6640  3		    CHKSUM<12, 4> = UNCHAR (CH$RCHAR%A (TEMP%POINTER));
;   6641  3		    TT%TEXT (PRE%CHAR%TEXT);
;   6642  3		    TT%CHAR (CH$RCHAR (.TEMP%POINTER));
;   6643  3		    TT%CHAR (%C'"');
;   6644  3		    CHKSUM<6, 6> = UNCHAR (CH$RCHAR%A (TEMP%POINTER));
;   6645  3		    TT%TEXT (PRE%CHAR%TEXT);
;   6646  3		    TT%CHAR (CH$RCHAR (.TEMP%POINTER));
;   6647  3		    TT%CHAR (%C'"');
;   6648  3		    CHKSUM<0, 6> = UNCHAR (CH$RCHAR (.TEMP%POINTER));
;   6649  2		    END;
;   6650  2		TES;
;   6651  2	
;   6652  2	    TT%TEXT (CHKSUM%NUM%TEXT);
;   6653  2	    TT%NUMBER (.CHKSUM);
;   6654  2	    TT%TEXT (DEC%TEXT);
;   6655  2	    TT%CRLF ();
;   6656  2	    TT%SET%OUTPUT (.OLD%RTN);			! Reset output destination
;   6657  1	    END;					! End of DBG%MESSAGE


P.ABI:	BYTE	(7)" ","(","D","a","t"		;  (Dat
	BYTE	(7)"a",")",000,000,000		; a)
P.ABJ:	BYTE	(7)" ","(","A","C","K"		;  (ACK
	BYTE	(7)")",000,000,000,000		; )
P.ABK:	BYTE	(7)" ","(","N","A","K"		;  (NAK
	BYTE	(7)")",000,000,000,000		; )
P.ABL:	BYTE	(7)" ","(","S","e","n"		;  (Sen
	BYTE	(7)"d"," ","i","n","i"		; d ini
	BYTE	(7)"t",")",000,000,000		; t)
P.ABM:	BYTE	(7)" ","(","B","r","e"		;  (Bre
	BYTE	(7)"a","k",")",000,000		; ak)
P.ABN:	BYTE	(7)" ","(","T","e","x"		;  (Tex
	BYTE	(7)"t"," ","h","e","a"		; t hea
	BYTE	(7)"d","e","r",")",000		; der)
P.ABO:	BYTE	(7)" ","(","F","i","l"		;  (Fil
	BYTE	(7)"e"," ","h","e","a"		; e hea
	BYTE	(7)"d","e","r",")",000		; der)
P.ABP:	BYTE	(7)" ","(","E","O","F"		;  (EOF
	BYTE	(7)")",000,000,000,000		; )
P.ABQ:	BYTE	(7)" ","(","E","r","r"		;  (Err
	BYTE	(7)"o","r",")",000,000		; or)
P.ABR:	BYTE	(7)" ","(","R","e","c"		;  (Rec
	BYTE	(7)"e","i","v","e"," "		; eive
	BYTE	(7)"i","n","i","t","i"		; initi
	BYTE	(7)"a","t","e",")",000		; ate)
P.ABS:	BYTE	(7)" ","(","C","o","m"		;  (Com
	BYTE	(7)"m","a","n","d",")"		; mand)
	BYTE	(7)000,000,000,000,000
P.ABT:	BYTE	(7)" ","(","G","e","n"		;  (Gen
	BYTE	(7)"e","r","i","c"," "		; eric
	BYTE	(7)"K","E","R","M","I"		; KERMI
	BYTE	(7)"T"," ","c","o","m"		; T com
	BYTE	(7)"m","a","n","d",")"		; mand)
	BYTE	(7)000,000,000,000,000
P.ABU:	BYTE	(7)"M","e","s","s","a"		; Messa
	BYTE	(7)"g","e"," ","n","u"		; ge nu
	BYTE	(7)"m","b","e","r",":"		; mber:
	BYTE	(7)" ",000,000,000,000
P.ABV:	BYTE	(7)011,"L","e","n","g"		;  Leng
	BYTE	(7)"t","h",":"," ",000		; th:
P.ABW:	BYTE	(7)" ","(","d","e","c"		;  (dec
	BYTE	(7)")",000,000,000,000		; )
P.ABX:	BYTE	(7)"M","e","s","s","a"		; Messa
	BYTE	(7)"g","e"," ","t","y"		; ge ty
	BYTE	(7)"p","e",":"," ",000		; pe:
P.ABY:	BYTE	(7)"C","h","e","c","k"		; Check
	BYTE	(7)"s","u","m",":"," "		; sum:
	BYTE	(7)000,000,000,000,000
P.ABZ:	BYTE	(7)" ","="," ",000,000		;  =
P.ACA:	BYTE	(7)"O","p","t","i","o"		; Optio
	BYTE	(7)"n","a","l"," ","d"		; nal d
	BYTE	(7)"a","t","a",":"," "		; ata:
	BYTE	(7)000,000,000,000,000
P.ACB:	BYTE	(7)" ",042,000,000,000		;  "


; DATA%TEXT
U.103=		    P.ABI
; ACK%TEXT
U.104=		    P.ABJ
; NAK%TEXT
U.105=		    P.ABK
; SND%INIT%TEXT
U.106=		    P.ABL
; BREAK%TEXT
U.107=		    P.ABM
; TEXT%TEXT
U.108=		    P.ABN
; FILE%TEXT
U.109=		    P.ABO
; EOF%TEXT
U.110=		    P.ABP
; ERROR%TEXT
U.111=		    P.ABQ
; RCV%INIT%TEXT
U.112=		    P.ABR
; COMMAND%TEXT
U.113=		    P.ABS
; KERMIT%TEXT
U.114=		    P.ABT
; MN%TEXT
U.115=		    P.ABU
; LENGTH%TEXT
U.116=		    P.ABV
; DEC%TEXT
U.117=		    P.ABW
; MSG%TYP%TEXT
U.118=		    P.ABX
; CHKSUM%TEXT
U.119=		    P.ABY
; CHKSUM%NUM%TEXT
U.120=		    P.ABZ
; OPT%DATA%TEXT
U.121=		    P.ACA
; PRE%CHAR%TEXT
U.122=		    P.ACB


; DBG%MESSAGE
U.34:	PUSH	SP,AC0				; SP,AC0									6426
	PUSH	SP,AC10				; SP,AC10
	PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	PUSH	SP,AC16				; SP,AC16
	PUSH	SP,C.91				; SP,[0,,DBG%DUMP]								6511
	PUSHJ	SP,TT%SET%OUTPUT		; SP,TT%SET%OUTPUT
	MOVE	AC0,AC1				; OLD%RTN,AC1
	MOVE	AC12,-12(SP)			; AC12,MSG%ADDRESS								6515
	MOVEI	AC1,0(AC12)			; AC1,0(AC12)
	HRLI	AC1,341000			; AC1,341000
	ILDB	AC2,AC1				; AC2,AC1
	MOVE	AC14,AC2			; MSG%LEN,AC2
	SUBI	AC14,40				; MSG%LEN,40
	PUSHJ	SP,TT%CRLF			; SP,TT%CRLF									6519
	PUSH	SP,C.127			; SP,[0,,MN%TEXT]								6520
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	MOVEI	AC1,0(AC12)			; AC1,0(AC12)									6521
	HRLI	AC1,241000			; AC1,241000
	ILDB	AC1,AC1				; AC1,AC1
	SUBI	AC1,40				; AC1,40
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,TT%NUMBER			; SP,TT%NUMBER
	PUSH	SP,C.128			; SP,[0,,DEC%TEXT]								6522
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSH	SP,C.129			; SP,[0,,LENGTH%TEXT]								6523
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	MOVEM	AC14,0(SP)			; MSG%LEN,0(SP)									6524
	PUSHJ	SP,TT%NUMBER			; SP,TT%NUMBER
	PUSH	SP,C.128			; SP,[0,,DEC%TEXT]								6525
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSHJ	SP,TT%CRLF			; SP,TT%CRLF									6526
	PUSH	SP,C.130			; SP,[0,,MSG%TYP%TEXT]								6530
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	MOVEI	AC1,0(AC12)			; AC1,0(AC12)									6531
	HRLI	AC1,141000			; AC1,141000
	ILDB	AC1,AC1				; AC1,AC1
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,TT%CHAR			; SP,TT%CHAR
	MOVEI	AC1,0(AC12)			; AC1,0(AC12)									6533
	HRLI	AC1,141000			; AC1,141000
	ILDB	AC16,AC1			; AC16,AC1
	CAIE	AC16,104			; AC16,104									6536
	JRST	L.454				; L.454
	PUSH	SP,C.131			; SP,[0,,DATA%TEXT]								6537
	JRST	L.464				; L.464
L.454:	CAIE	AC16,131			; AC16,131									6539
	JRST	L.455				; L.455
	PUSH	SP,C.132			; SP,[0,,ACK%TEXT]								6540
	JRST	L.464				; L.464
L.455:	CAIE	AC16,116			; AC16,116									6542
	JRST	L.456				; L.456
	PUSH	SP,C.133			; SP,[0,,NAK%TEXT]								6543
	JRST	L.464				; L.464
L.456:	CAIE	AC16,123			; AC16,123									6545
	JRST	L.457				; L.457
	PUSH	SP,C.134			; SP,[0,,SND%INIT%TEXT]								6546
	JRST	L.464				; L.464
L.457:	CAIE	AC16,102			; AC16,102									6548
	JRST	L.458				; L.458
	PUSH	SP,C.135			; SP,[0,,BREAK%TEXT]								6549
	JRST	L.464				; L.464
L.458:	CAIE	AC16,106			; AC16,106									6551
	JRST	L.459				; L.459
	PUSH	SP,C.136			; SP,[0,,FILE%TEXT]								6552
	JRST	L.464				; L.464
L.459:	CAIE	AC16,130			; AC16,130									6554
	JRST	L.460				; L.460
	PUSH	SP,C.137			; SP,[0,,TEXT%TEXT]								6555
	JRST	L.464				; L.464
L.460:	CAIE	AC16,132			; AC16,132									6557
	JRST	L.461				; L.461
	PUSH	SP,C.138			; SP,[0,,EOF%TEXT]								6558
	JRST	L.464				; L.464
L.461:	CAIE	AC16,105			; AC16,105									6560
	JRST	L.462				; L.462
	PUSH	SP,C.139			; SP,[0,,ERROR%TEXT]								6561
	JRST	L.464				; L.464
L.462:	CAIE	AC16,107			; AC16,107									6563
	JRST	L.463				; L.463
	PUSH	SP,C.140			; SP,[0,,KERMIT%TEXT]								6564
	JRST	L.464				; L.464
L.463:	CAIE	AC16,103			; AC16,103									6566
	JRST	L.465				; L.465
	PUSH	SP,C.141			; SP,[0,,COMMAND%TEXT]								6567
L.464:	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	ADJSP	SP,-1				; SP,-1
L.465:	PUSHJ	SP,TT%CRLF			; SP,TT%CRLF									6570
	MOVE	AC11,AC14			; AC11,MSG%LEN									6575
	SUBI	AC11,3				; AC11,3
	MOVE	AC1,U.46			; AC1,BLK%CHK%TYPE
	SUBI	AC1,61				; AC1,61
	CAMN	AC11,AC1			; AC11,AC1
	JRST	L.469				; L.469
	PUSH	SP,C.142			; SP,[0,,OPT%DATA%TEXT]								6578
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSHJ	SP,TT%CRLF			; SP,TT%CRLF									6579
	MOVEI	AC16,0(AC12)			; AC16,0(AC12)									6580
	HRLI	AC16,41000			; AC16,41000
	MOVE	AC2,AC11			; AC2,AC11									6582
	SUB	AC2,U.46			; AC2,BLK%CHK%TYPE
	MOVE	AC10,AC2			; AC10,AC2
	ADDI	AC10,61				; AC10,61
	SETZ	AC13,				; I,
	JRST	L.468				; L.468
L.466:	MOVE	AC1,AC13			; AC1,I										6585
	IDIVI	AC1,12				; AC1,12
	CAIE	AC2,1				; AC2,1
	JRST	L.467				; L.467
	PUSHJ	SP,TT%CRLF			; SP,TT%CRLF									6588
	PUSH	SP,C.21				; SP,[11]									6589
	PUSHJ	SP,TT%CHAR			; SP,TT%CHAR
	ADJSP	SP,-1				; SP,-1										6587
L.467:	PUSH	SP,C.143			; SP,[0,,PRE%CHAR%TEXT]								6592
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	ILDB	AC1,AC16			; AC1,TEMP%POINTER								6593
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,TT%CHAR			; SP,TT%CHAR
	PUSH	SP,C.144			; SP,[42]									6594
	PUSHJ	SP,TT%CHAR			; SP,TT%CHAR
	ADJSP	SP,-3				; SP,-3										6583
L.468:	ADDI	AC13,1				; I,1										6582
	CAMG	AC13,AC10			; I,AC10
	JRST	L.466				; L.466
	MOVE	AC2,AC11			; AC2,AC11									6597
	SUB	AC2,U.46			; AC2,BLK%CHK%TYPE
	ADDI	AC2,61				; AC2,61
	MOVE	AC1,AC2				; AC1,AC2
	IDIVI	AC1,12				; AC1,12
	CAIN	AC2,1				; AC2,1
	PUSHJ	SP,TT%CRLF			; SP,TT%CRLF
	PUSHJ	SP,TT%CRLF			; SP,TT%CRLF									6599
	ADJSP	SP,-1				; SP,-1										6577
L.469:	PUSH	SP,C.145			; SP,[0,,CHKSUM%TEXT]								6606
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	MOVE	AC1,U.46			; AC1,BLK%CHK%TYPE								6608
	SUB	AC14,AC1			; MSG%LEN,AC1
	ADDI	AC14,62				; AC14,62
	MOVEI	AC2,0(AC12)			; AC2,0(AC12)
	HRLI	AC2,-337000			; AC2,-337000
	ADJBP	AC14,AC2			; AC14,AC2
	MOVE	AC16,AC14			; TEMP%POINTER,AC14
	SUBI	AC1,61				; AC1,61									6610
	JRST	L.470(AC1)			; L.470(AC1)
L.470:	JRST	L.471				; L.471
	JRST	L.472				; L.472
	JRST	L.473				; L.473
L.471:	PUSH	SP,C.143			; SP,[0,,PRE%CHAR%TEXT]								6615
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	MOVE	AC14,AC16			; AC14,TEMP%POINTER								6616
	ILDB	AC1,AC14			; AC1,AC14
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,TT%CHAR			; SP,TT%CHAR
	PUSH	SP,C.144			; SP,[42]									6617
	PUSHJ	SP,TT%CHAR			; SP,TT%CHAR
	MOVE	AC14,AC16			; AC14,TEMP%POINTER								6618
	ILDB	AC14,AC14			; AC14,AC14
	SUBI	AC14,40				; AC14,40
	JRST	L.474				; L.474										6610
L.472:	SETZ	AC14,				; CHKSUM,									6623
	PUSH	SP,C.143			; SP,[0,,PRE%CHAR%TEXT]								6624
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	MOVE	AC2,AC16			; AC2,TEMP%POINTER								6625
	ILDB	AC1,AC2				; AC1,AC2
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,TT%CHAR			; SP,TT%CHAR
	PUSH	SP,C.144			; SP,[42]									6626
	PUSHJ	SP,TT%CHAR			; SP,TT%CHAR
	ILDB	AC1,AC16			; AC1,TEMP%POINTER								6627
	SUBI	AC1,40				; AC1,40
	DPB	AC1,C.124			; AC1,[POINT 6,CHKSUM,29]  <6,6>
	PUSH	SP,C.143			; SP,[0,,PRE%CHAR%TEXT]								6628
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	MOVE	AC2,AC16			; AC2,TEMP%POINTER								6629
	ILDB	AC1,AC2				; AC1,AC2
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,TT%CHAR			; SP,TT%CHAR
	PUSH	SP,C.144			; SP,[42]									6630
	PUSHJ	SP,TT%CHAR			; SP,TT%CHAR
	MOVE	AC2,AC16			; AC2,TEMP%POINTER								6631
	ILDB	AC1,AC2				; AC1,AC2
	SUBI	AC1,40				; AC1,40
	DPB	AC1,C.125			; AC1,[POINT 6,CHKSUM,35]  <0,6>
	ADJSP	SP,-3				; SP,-3										6622
	JRST	L.474				; L.474										6610
L.473:	SETZ	AC14,				; CHKSUM,									6636
	PUSH	SP,C.143			; SP,[0,,PRE%CHAR%TEXT]								6637
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	MOVE	AC2,AC16			; AC2,TEMP%POINTER								6638
	ILDB	AC1,AC2				; AC1,AC2
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,TT%CHAR			; SP,TT%CHAR
	PUSH	SP,C.144			; SP,[42]									6639
	PUSHJ	SP,TT%CHAR			; SP,TT%CHAR
	ILDB	AC1,AC16			; AC1,TEMP%POINTER								6640
	SUBI	AC1,40				; AC1,40
	DPB	AC1,C.126			; AC1,[POINT 4,CHKSUM,23]  <12,4>
	PUSH	SP,C.143			; SP,[0,,PRE%CHAR%TEXT]								6641
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	MOVE	AC2,AC16			; AC2,TEMP%POINTER								6642
	ILDB	AC1,AC2				; AC1,AC2
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,TT%CHAR			; SP,TT%CHAR
	PUSH	SP,C.144			; SP,[42]									6643
	PUSHJ	SP,TT%CHAR			; SP,TT%CHAR
	ILDB	AC1,AC16			; AC1,TEMP%POINTER								6644
	SUBI	AC1,40				; AC1,40
	DPB	AC1,C.124			; AC1,[POINT 6,CHKSUM,29]  <6,6>
	PUSH	SP,C.143			; SP,[0,,PRE%CHAR%TEXT]								6645
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	MOVE	AC2,AC16			; AC2,TEMP%POINTER								6646
	ILDB	AC1,AC2				; AC1,AC2
	PUSH	SP,AC1				; SP,AC1
	PUSHJ	SP,TT%CHAR			; SP,TT%CHAR
	PUSH	SP,C.144			; SP,[42]									6647
	PUSHJ	SP,TT%CHAR			; SP,TT%CHAR
	ILDB	AC1,AC16			; AC1,AC16									6648
	SUBI	AC1,40				; AC1,40
	DPB	AC1,C.125			; AC1,[POINT 6,CHKSUM,35]  <0,6>
	ADJSP	SP,-6				; SP,-6										6635
L.474:	PUSH	SP,C.146			; SP,[0,,CHKSUM%NUM%TEXT]							6652
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	MOVEM	AC14,0(SP)			; CHKSUM,0(SP)									6653
	PUSHJ	SP,TT%NUMBER			; SP,TT%NUMBER
	PUSH	SP,C.128			; SP,[0,,DEC%TEXT]								6654
	PUSHJ	SP,TT%TEXT			; SP,TT%TEXT
	PUSHJ	SP,TT%CRLF			; SP,TT%CRLF									6655
	MOVEM	AC0,0(SP)			; OLD%RTN,0(SP)									6656
	PUSHJ	SP,TT%SET%OUTPUT		; SP,TT%SET%OUTPUT
	ADJSP	SP,-16				; SP,-16									6465
	POP	SP,AC16				; SP,AC16									6426
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POP	SP,AC10				; SP,AC10
	POP	SP,AC0				; SP,AC0
	POPJ	SP,				; SP,
C.124:	POINT	6,AC14,29			; 6,CHKSUM,29
C.125:	POINT	6,AC14,35			; 6,CHKSUM,35
C.126:	POINT	4,AC14,23			; 4,CHKSUM,23
C.127:	XWD	0,U.115				; 0,MN%TEXT
C.128:	XWD	0,U.117				; 0,DEC%TEXT
C.129:	XWD	0,U.116				; 0,LENGTH%TEXT
C.130:	XWD	0,U.118				; 0,MSG%TYP%TEXT
C.131:	XWD	0,U.103				; 0,DATA%TEXT
C.132:	XWD	0,U.104				; 0,ACK%TEXT
C.133:	XWD	0,U.105				; 0,NAK%TEXT
C.134:	XWD	0,U.106				; 0,SND%INIT%TEXT
C.135:	XWD	0,U.107				; 0,BREAK%TEXT
C.136:	XWD	0,U.109				; 0,FILE%TEXT
C.137:	XWD	0,U.108				; 0,TEXT%TEXT
C.138:	XWD	0,U.110				; 0,EOF%TEXT
C.139:	XWD	0,U.111				; 0,ERROR%TEXT
C.140:	XWD	0,U.114				; 0,KERMIT%TEXT
C.141:	XWD	0,U.113				; 0,COMMAND%TEXT
C.142:	XWD	0,U.121				; 0,OPT%DATA%TEXT
C.143:	XWD	0,U.122				; 0,PRE%CHAR%TEXT
C.144:	EXP	42				; 42
C.145:	XWD	0,U.119				; 0,CHKSUM%TEXT
C.146:	XWD	0,U.120				; 0,CHKSUM%NUM%TEXT

; Routine Size:  263 words


;   6658  1	%SBTTL 'End of KERMSG'
;   6659  1	END
;   6660  1	
;   6661  0	ELUDOM



	END

; Low  segment length:      99 words
; High segment length:    3893 words






;			COMPILER INTERNAL TIMING

;	Phase	     Faults	  Cpu-time	Elapsed-time
;	LEXSYN	          0	   00:20.6	   00:45.9
;	FLOWAN	          0	   00:05.5	   00:11.1
;	DELAY	          0	   00:05.1	   00:11.8
;	TNBIND	          0	   00:04.5	   00:08.2
;	CODE	          0	   00:04.5	   00:10.2
;	FINAL	          0	   00:20.0	   00:46.1
;	Total	          0	   01:00.2	   02:13.2

; Compilation Complete

	END
  5p^3