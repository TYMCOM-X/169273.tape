			
				SUBTTL	FMAIN - CB2033.F01 - This is the foreground for Carl's slot
			
010616				SEG	A.CODE
				MO	.,FMAIN		: Start of module FMAIN
			
000000			ASY1	EQ	0		: LUN of async bank
000001			SYN1	EQ	1		: LUN of sync line
000002			SIO1	EQ	2		: LUN of sio channel
			
000020			RTLMAX	EQ	20		: Maximum size of buffer ring
000100			RECSIZ	EQ	100		: Size of X.GK records
			
				GL	FSTART		: Entry point (called from background)
				GL	SYNCBF		: Entry to Put/Get SYNC buffer
				GL	XGKREQ		: Entry to request X.GK message
				GL	XGKREC		: Entry to read any X.GK message lines
				GL	XGKRDN		: Entry to finish X.GK message line
				GL	STORHW		: Entry to fill buffer
			
				GL	MOUTSC		: Move output string
				GL	MVBYTE		: Byte Move routine
			
			
						
0000D6				SEG	A.DATA			: Separate section for I/O data
			
0000D8				WS	0			: same as BND 4
			
0000D8	0000 0100 	RTLLST	WC	RTL001			: Address to check
0000DC	0001 0200 	RTLCMD	HC	1,200			: Write, 200 bytes
000008			RTLSIZ	EQ	.-RTLLST		: Entry size
0000E0	0000 0108 		WC	RTL002			: Address of list entry 2
0000E4	0001 0200 		HC	1,200			: Write, 200 bytes
0000E8	0000 0110 		WC	RTL003			: Address of list entry 3
0000EC	0002 0000 		HC	2,0			: Transfer, no buffer
000018			RTLLEN	EQ	.-RTLLST
			
0000F0			RTLCNT	HS	1			: Count times found 0
0000F2			RTLONE	HS	1			: Count times found 1
			
			
000100				BND	100			: Probably locate at <100>
000100	0001 0200 	RTL001	HC	1,200			: Write, 200 bytes
000104	0000 0200 	RTLBUF	WC	BUFPAD			: Buffer 1
000108	0001 0200 	RTL002	HC	1,200			: Write, 200 bytes
00010C	0000 0200 	RTLALT	WC	BUFPAD			: Buffer 2
000110	0002 0000 	RTL003	HC	2,0			: Transfer, 0 byte buffer
000114	0000 0100 		WC	RTL001			: Loop back to here
			
000200				BND	100		: Make it a block boundary
000200			BUFPAD	HS	200			: Idle padding buffer
000600			BUFBUF	HS	200			: Normal buffer
000A00			BUFALT	HS	200			: Alternate buffer
000E00			BUF000	HS	200
001200			BUF001	HS	200
001600			BUF002	HS	200
			
001A00			PTRIN	HS	1			: My pointer
001A02			BUFIN	HS	1			: His pointer
001A04				HS	200			: Buffer to use ( 200 bytes )
			
001E04	0010 0000 0010 	RTLPTR	HC	4*4,4*0,4*4,4*4			: ptr offsets
	0010 		
001E0C	0000 0600 0000 		WC	BUFBUF,BUFALT,BUF000,BUF001	: buffer addresses
	0A00 0000 0E00 	
	0000 1200 	
000018			RTLINL	EQ	.-RTLPTR			: length of table
			
001E1C			RTL.TF	HS	1			: BG wrote to here ==>   To FG
001E1E			RTL.FF	HS	1			: BG reads to here ==> From FG
001E20			RTL.TB	HS	1			: FG wrote to here ==>   To BG
001E22			RTL.FB	HS	1			: FG reads to here ==> From BG
001E24			RTL.BF	WS	RTLMAX			: Buffer address ring for RTL
			
001EA4	0000 		XGK.RD	HC	0			: Read pointer used by BG
001EA6	0000 		XGK.WT	HC	0			: Write pointer used by FG
001EA8	000E 		XGK.RM	HC	0E			: Room indicator for SIO requests
001EAA			XGK.XX	HS	1			: -- Extra --
001EAC			XGKBUF	BS	RECSIZ*10		: Twice size of SIO buffer (16d)
			
			
						
002EAC	30BF 0A0D BFC6 	FATSIC	SC	\?"0A"0D?FATSIC Fatal -- Sync Input Connect failure"0A"0D\
	C1D4 D3C9 C3A0 	
	C6E1 F4E1 ECA0 	
	ADAD A0D3 F9EE 	
	E3A0 C9EE F0F5 	
	F4A0 C3EF EEEE 	
	E5E3 F4A0 E6E1 	
	E9EC F5F2 E50A 	
	0D		
002EDD	31 BF0A 0DBF C6	FATSOC	SC	\?"0A"0D?FATSOC Fatal -- Sync Output Connect failure"0A"0D\
	C1 D4D3 CFC3 A0	
	C6 E1F4 E1EC A0	
	AD ADA0 D3F9 EE	
	E3 A0CF F5F4 F0	
	F5 F4A0 C3EF EE	
	EE E5E3 F4A0 E6	
	E1 E9EC F5F2 E5	
	0A 0D		
002F0F	2C BF0A 0DBF C6	FATSRW	SC	\?"0A"0D?FATSRW Fatal -- Sync Ring Wrap failure"0A"0D\
	C1 D4D3 D2D7 A0	
	C6 E1F4 E1EC A0	
	AD ADA0 D3F9 EE	
	E3 A0D2 E9EE E7	
	A0 D7F2 E1F0 A0	
	E6 E1E9 ECF5 F2	
	E5 0A0D 	
002F3C	2DBF 0A0D BFC6 	FATXGT	SC	\?"0A"0D?FATXGT Fatal -- eXception on GT pointer"0A"0D\
	C1D4 D8C7 D4A0 	
	C6E1 F4E1 ECA0 	
	ADAD A0E5 D8E3 	
	E5F0 F4E9 EFEE 	
	A0EF EEA0 C7D4 	
	A0F0 EFE9 EEF4 	
	E5F2 0A0D 	
			
002F6A	2FA5 0A0D A5D7 	WRNBSC	SC	\%"0A"0D%WRNBSC Warning -- Bad Sync output Command"0A"0D\
	D2CE C2D3 C3A0 	
	D7E1 F2EE E9EE 	
	E7A0 ADAD A0C2 	
	E1E4 A0D3 F9EE 	
	E3A0 EFF5 F4F0 	
	F5F4 A0C3 EFED 	
	EDE1 EEE4 0A0D 	
			
			
						
			: SIO - data area
			
002FA0				BND	10
002FA0			SIOWIN	EQ	.		: Start of SIO window
			
002FA0				BND	10
002FA0	0003 0018 	SIOSIO	WC	30018		: Reset SIO chip
002FA4	0003 1100 		WC	31100		: Clear interrupts, set SDLC, clock x1
002FA8	0003 03D8 		WC	303D8		: Setup input CRC, byte size, etc
002FAC	0003 05EB 		WC	305EB		: Setup output CRC, enable transmit
002FB0	0003 877E 		WC	3877E		: Reset CRC, Set framing character 7E
002FB4	0003 13D9 		WC	313D9		: Setup input byte size, enable receive
002FB8	0000 0000 		WC	    0		: Done
			
002FC0				BND	10
002FC0	0001 02FE 	SIOOUT	HC	1,MSGOUT/10		: out- my buffer is MSGOUT
002FC4	0000 0000 		WC	0			: cmd- stop, end of list
			
002FC8			MSGLIN	HS	1			: Filler - How many lines in GK-MSG
002FCA			XGKHEL	HS	1			: Filler - Sent hello message
002FCC			XGKRDY	HS	1			: Filler - Are we ready to go
002FCE			XGKINP	HS	1			: Filler - Where to read input
			
002FD0				BND	10
002FD0	0003 0408 	SIOIN	HC	3,8*(RECSIZ+2)/2	: cmd- set buffer size
002FD4	0001 030F 		HC	1,SIOIBF/10		: inp- my buffer is SIOIBF
002FD8	0000 0000 		WC	0			: cmd- stop, end of list
			
002FDC			FxPORT	HS	1			: Filler - Port number
002FDE				HS	1			: Filler - 
			
002FE0				BND	10			: output buffer
002FE0	0100 		MSGOUT	HC	RECSIZ
002FE4			MSGHDR	WS	1			: holds AAAA,D3D3 or E4E4
002FE8			MSGBYT	BS	1			: holds byte count of data
002FE9			MSGDAT	BS	RECSIZ-5		: holds message data
			
0030F0				BND	10			: input buffer
0030F0	FFFF 		SIOIBF	HC	0FFFF			: byte count filled in by SIO
0030F2				BS	8*(RECSIZ+2)		: data bytes
003900			SIOIBE	EQ	.-2			: end of input buffer (last FFFF)
			
003910				BND	10
003910			SIOSTS	WS	2			: status info for SIO
			
003920				BND	10
003920			SIOEND	EQ	.			: end of SIO window
			
						
003920			XGKLIN	BS	MAXPRT			: One byte each of line-count
003930			XGKSND	WS	MAXBIT			: Bit array - Set when sending msg
			
			: Note: Since X.GK (mini) ignores the bytes following the header
			:	and message type field, I am depending on this to conserve
			:	space below.  All but the last message will overlap the
			:	header-type as part of the ignored data.
			
003934	AAAA B1B1 	MSGHEL	WC	0AAAAB1B1		: initial hello message
003938	AAAA D3D3 	MSGGET	WC	0AAAAD3D3		: get (next) line of message
00393C			MSGONE	WS	1			: holds AAAA,E4E4 first line
003940				BS	1			: holds byte count of data
003941				BS	RECSIZ-5		: holds message data
			
003A3C			INPHDR	WS	1			: holds AAAA,D3D3 or E4E4
003A40			INPBYT	BS	1			: holds byte count of data
003A41			INPDAT	BS	RECSIZ-5		: holds message data
			
			
						
010616				SEG	A.CODE
			
010616	E600 4000 2EAC 	FSTART	LA	R0,FATSIC,,		: An appropriate error message
01061C	C810 0001 		LHI	R1,SYN1			: Load logical unit #
010620	E620 4000 1A02 		LA	R2,BUFIN,,		: And buffer
010626	C830 0202 		LHI	R3,2+200		: Header + buffer size
01062A	E130 0001 		SVC	IO,01			: Begin input
01062E	4300 831C 		  J	GIVEUP			: Hmm, something is wrong
			
010632	E610 4000 0200 		LA	R1,BUFPAD,,		: Address of pad buffer
010638	5010 4000 0104 		ST	R1,RTLBUF,,		: Store in main buffer
01063E	5010 4000 010C 		ST	R1,RTLALT,,		: Store in alternate buffer
			
010644	C800 FFFF 		LHI	R0,0FFFF		: What to store
010648	4000 4000 00F0 		STH	R0,RTLCNT,,		: Zero count
01064E	4000 4000 00F2 		STH	R0,RTLONE,,		:  of finds
010654	E610 4000 0200 		LA	R1,BUFPAD,,		: Where
01065A	C820 0200 		LHI	R2,200			: Number of halfwords
01065E	4140 4001 0958 		JAL	R4,STORHW,,		: Store in buffer
			
			:  Use of R10 - R15 for this instruction to copy data to initial buffer
010664	D1A0 1E04 		LM	R10,RTLPTR		: Get initial buffer constants
010668	D0A0 1E1C 		STM	R10,RTL.TF		: Store initial buffer constants
			
01066C	E600 4000 2EDD 		LA	R0,FATSOC,,		: An appropriate error message
010672	C810 0001 		LHI	R1,SYN1			: Load logical unit #
010676	E620 4000 0100 		LA	R2,RTL001,,		: And beginning of rotor list
01067C	E130 0011 		SVC	IO,11			: Begin output
010680	4300 82CA 		  J	GIVEUP			: Hmm, something wrong!
			
010684	41F0 82E0 		JAL	R15,SIOINI		: Setup SIO motherboard
010688	2400 			LIS	R0,0			: And clear out variables
01068A	4000 2FC8 		STH	R0,MSGLIN		: Number of lines in message
01068E	4000 2FCA 		STH	R0,XGKHEL		: Hello message sent
010692	4000 2FCC 		STH	R0,XGKRDY		: Ready to "GET" message
010696	4000 1EA4 		STH	R0,XGK.RD		: Reset XGK RD
01069A	4000 1EA6 		STH	R0,XGK.WT		: Reset XGK WT
01069E	C800 000E 		LHI	R0,0E			: Initialize to 14 messages (16)
0106A2	4000 1EA8 		STH	R0,XGK.RM		:  for communications buffer
0106A6	E600 30F0 		LA	R0,SIOIBF		: Get SIO input buffer start
0106AA	4000 2FCE 		STH	R0,XGKINP		:  for my input scan ring
0106AE	C800 FFFF 		LHI	R0,0FFFF		: Set my initial port to -1
0106B2	4000 2FDC 		STH	R0,FxPORT		: until I've scanned the message
			
						
0106B6	E100 0000 	FGLOOP	SVC	DISMIS			: Look at things next time
0106BA	41F0 82E0 		JAL	R15,XGKINI		: Setup X.GK and read message once
								: - controlled by XGKHEL and XGKRDY
0106BE	41F0 810A 		JAL	R15,XGKRED		: Read any input available
0106C2	41F0 81CE 		JAL	R15,XGKWRT		: Write any output (if not busy)
			
			: Look at sync input here!!!
			
			: Now for sync output
			
0106C6	2410 			LIS	R1,0			: Get initial offset
0106C8	C910 0018 	RTLOOP	CHI	R1,RTLLEN		: Are we done?
0106CC	4330 FFE6 		  JE	FGLOOP			: Seems so to me
0106D0	5821 4000 00D8 		L	R2,RTLLST,R1,		: Load address
0106D6	4802 0000 		LH	R0,0,R2			: Has sync finished with rotor entry?
0106DA	4230 807E 		  JN	RTLNXT			: Not as I can see
0106DE	4801 4000 00DC 		LH	R0,RTLCMD,R1,		: Get the command type
0106E4	C900 0001 		CHI	R0,1			: Is it a write?
0106E8	4230 8078 		  JN	CHKTRN			: No, check transfer
			
0106EC	5802 4000 0004 		L	R0,4,R2,		: Pull address from rotor
0106F2	F900 0000 0200 		CI	R0,BUFPAD		: Is it a padding buffer?
0106F8	4330 802C 		  JE	RTLNGT			: Yes, nothing to return
			
0106FC	4830 4000 1E20 		LH	R3,RTL.TB,,		: Get pointer
010702	4930 4000 1E22 		CH	R3,RTL.FB,,		: Does it match? cannot pass FB
010708	4330 2F0F 		  JE	FATSRW			: Yes, no room - should't happen
01070C	5003 4000 1E24 		ST	R0,RTL.BF,R3,		: Put buffer address into list
010712	2634 			AIS	R3,4*1			: Move to next entry
010714	C930 0080 		CHI	R3,4*RTLMAX		: At end of ring?
010718	2132 			  JNFS	NWRPTB			: No, skip ahead
01071A	2430 			LIS	R3,0			: Yes, reset to top
01071C	4030 4000 1E20 	NWRPTB	STH	R3,RTL.TB,,		: Ok, remember the pointer
			
010722	E600 4000 0200 		LA	R0,BUFPAD,,		: Default buffer if none available
010728	4830 4000 1E22 	RTLNGT	LH	R3,RTL.FB,,		: Get pointer to next
01072E	4930 4000 1E1C 		CH	R3,RTL.TF,,		: Does it match?  cannot pass TF
010734	233B 			  JEFS	SETPAD			: Yes, set padding and finish up
010736	5803 4000 1E24 		L	R0,RTL.BF,R3,		: Get buffer address from list
01073C	2634 			AIS	R3,4*1			: Move to next entry
01073E	C930 0080 		CHI	R3,4*RTLMAX		: At end of ring?
010742	2132 			  JNFS	NWRPFB			: No, skip ahead
010744	2430 			LIS	R3,0			: Yes, reset to top
010746	4030 1E22 	NWRPFB	STH	R3,RTL.FB		: Store pointer
01074A	5002 4000 0004 	SETPAD	ST	R0,4,R2,		: Store into rotor list
010750	4801 4000 00DC 		LH	R0,RTLCMD,R1,		: Get "write" command from RTLLST
010756	4002 4000 0000 		STH	R0,0,R2,		: Set it in the rotor list
01075C	CA10 0008 	RTLNXT	AHI	R1,RTLSIZ		: Bump to the next RTLLST entry
010760	4300 FF64 		J	RTLOOP			: Check next rotor entry
			
010764	C900 0002 	CHKTRN	CHI	R0,2			: Is it a transfer
010768	4230 81C2 		  JN	ERRBSC			: Bad command type
01076C	5800 4000 00D8 		L	R0,RTLLST,,		: Transfer, get beginning
010772	4300 FFD4 		J	SETPAD			:  address and store it
			
						
			: SYNCBF - Called from background to store a full sync buffer
			:	   Called from background to get an empty sync buffer
			:
			: call:
			:	R0 = 0	No buffer supplied, just get a free buffer
			:	R0 # 0	Buffer supplied, also get a new free buffer
			:	JAL	R4,SYNCBF
			:
			: non-skip return:
			:	R0 = 0	No buffers available, please wait
			:	R0 # 0	R0 contains what was passed
			:
			: skip return:
			:	R0 # 0	R0 contains a new empty buffer
			:
			
010776	C900 0000 	SYNCBF	CHI	R0,0			: Test for 0
01077A	4330 8026 		  JE	GSYNBF			: Nothing here, go get a buffer
01077E	4830 4000 1E1C 		LH	R3,RTL.TF,,		: Get pointer to next
010784	4930 4000 1E1E 		CH	R3,RTL.FF,,		: Does it match?  cannot pass FF
01078A	0334 			  JER	R4			: No room for buffer, non-skip
01078C	5003 4000 1E24 		ST	R0,RTL.BF,R3,		: Put buffer address from list
010792	2634 			AIS	R3,4*1			: Move to next entry
010794	C930 0080 		CHI	R3,4*RTLMAX		: At end of ring?
010798	2132 			  JNFS	NWRPTF			: No, skip ahead
01079A	2430 			LIS	R3,0			: Yes, reset to top
01079C	4030 4000 1E1C 	NWRPTF	STH	R3,RTL.TF,,		: Store pointer
			
0107A2	2400 			LIS	R0,0			: Set default for fall-through
0107A4	4830 4000 1E1E 	GSYNBF	LH	R3,RTL.FF,,		: Get pointer
0107AA	4930 4000 1E20 		CH	R3,RTL.TB,,		: Does it match? cannot pass TB
0107B0	0334 			  JER	R4			: Yes, no buffers available
0107B2	5803 4000 1E24 		L	R0,RTL.BF,R3,		: Get buffer
0107B8	2634 			AIS	R3,4*1			: Move to next entry
0107BA	C930 0080 		CHI	R3,4*RTLMAX		: At end of ring?
0107BE	2132 			  JNFS	NWRPFF			: No, skip ahead
0107C0	2430 			LIS	R3,0			: Yes, reset to top
0107C2	4030 4000 1E1E 	NWRPFF	STH	R3,RTL.FF,,		: Remember the pointer
0107C8	2644 			AIS	R4,4			: Set skip return
0107CA	0304 			JR	R4			:  and go
			
			
						
			: XGKRED - Called from forground to look at the SIO input buffer and
			:	   copy any records from it into the background ring buffer.
			:
			
0107CC	5820 4000 2FCE 	XGKRED	L	R2,XGKINP,,		: Get address where left off
0107D2	4802 4000 0000 		LH	R0,0,R2,		: Get record byte count
0107D8	C900 FFFF 		CHI	R0,0FFFF		: Are we available?
0107DC	033F 			  JER	R15			: No, nothing so far
0107DE	0812 			LR	R1,R2			: Copy address for update
0107E0	0A10 			AR	R1,R0			: Update record using count
0107E2	2612 			AIS	R1,2			: Add 2 for the byte count HW
0107E4	F910 0000 3900 		CI	R1,SIOIBE		: Have we finished reading?
0107EA	4210 8006 		  JL	XGKRIP			: No, we are fine
0107EE	E610 4000 30F0 		LA	R1,SIOIBF,,		: Yes, start again at the top
0107F4	5010 4000 2FCE 	XGKRIP	ST	R1,XGKINP,,		: Remember where we left off
			
0107FA	4812 4000 0000 		LH	R1,0,R2,		: Get the Header (X.GK)
010800	C910 AAAA 		CHI	R1,0AAAA		: Is it a good record?
010804	023F 			  JNR	R15			: No, Ignore it
010806	4812 4000 0002 		LH	R1,2,R2,		: Yes, get the message type
01080C	C910 C2C2 		CHI	R1,0C2C2		: Is it an "I hear you"
010810	4330 806C 		  JE	XGKHER			: Yes, fall out of loop
010814	C910 E4E4 		CHI	R1,0E4E4		: Is it a data message
010818	4230 8074 		  JN	XGKERR			: No, Illegal data message
01081C	4810 2FDC 		LH	R1,FxPORT		: Get port info
010820	4320 806E 		  JLE	NOPORT			: Not yet, must be doing scan
			
			: Here with R2 setup as address of message in input buffer
010824	4830 4000 1EA6 		LH	R3,XGK.WT,,		: Get pointer
01082A	4930 4000 1EA4 		CH	R3,XGK.RD,,		: Does it match? cannot pass RD
010830	4330 8114 		  JE	ERRSRW			: Yes, no room - should't happen
			
			: Good record, count lines for each port
010834	C810 2FDC 		LHI	R1,FxPORT		: Get current SIO port
010838	4012 4000 0002 		STH	R1,2,R2,		: Overwrite E4E4 with port id
01083E	D301 3920 		LB	R0,XGKLIN,R1		: Get a line counter
010842	2601 			AIS	R0,1			: Increment it
010844	4900 4000 2FC8 		CH	R0,MSGLIN,,		: Do we have all the lines?
01084A	4210 8004 		  JL	XGKRE4			: No, skip this
01084E	7610 3930 		RBT	R1,XGKSND		: Yes, so reset line (we're done)
010852	D201 3920 	XGKRE4	STB	R0,XGKLIN,R1		: Remember count
			
			: Good record, now move it to the background
010856	C800 0100 		LHI	R0,RECSIZ		: 100 bytes
01085A	E613 4000 1EAC 		LA	R1,XGKBUF,R3,		: Get address in background buffer
								: R2 is already setup above
010860	4160 0000 		JAL	R6,MVBYTE		: Move the message
			
			: Now update pointer so background can read it
010864	4830 4000 1EA6 		LH	R3,XGK.WT,,		: Get pointer
01086A	CA30 0100 		AHI	R3,RECSIZ		: Move to next entry
01086E	C930 1000 		CHI	R3,10*RECSIZ		: At end of ring?
010872	2132 			  JNFS	NWRPXP			: No, skip ahead
010874	2430 			LIS	R3,0			: Yes, reset to top
010876	4030 4000 1EA6 	NWRPXP	STH	R3,XGK.WT,,		: Ok, remember the pointer
01087C	4300 FF4C 		J	XGKRED			: Any more to read?
						
			: Come here if receive "I'm listening" when already listening
010880	4800 2FCC 	XGKHER	LH	R0,XGKRDY		: Am I already ready?
010884	4230 8008 		  JN	XGKERR			: Error - go to ignore errors for now
010888	2401 			LIS	R0,1			: Get set value
01088A	4000 2FCC 		STH	R0,XGKRDY		:  for ready flag
01088E	030F 			JR	R15			: Return
			
			
			: Come here on input errors, right now XGKRED does NOT skip return, so ignore
010890	030F 		XGKERR	JR	R15			: Return
			
			
			: NOPORT - We're not readig for anyport at the moment
			
010892	030F 		NOPORT	JR	R15			: Return
			
						
			: XGKWRT - Routine to check to see if we need to send message to one
			:	   of the background ports.  XGKSND is a bit array of ports
			:	   waiting to send.
			
010894	5810 3930 	XGKWRT	L	R1,XGKSND		: Get ports list
010898	3112 			JFFO	R1,XGKWR0		: Any to send?
01089A	030F 			  JR	R15			: No, return
			
			: R1 now contains the port number
01089C	4800 2FDC 	XGKWR0	LH	R0,FxPORT		: Already have a port?
0108A0	4310 8004 		  JGE	XGKWR1			: Yes, keep using it
0108A4	4010 2FDC 		STH	R1,FxPORT		: We are working on one port
0108A8	4800 1EA8 	XGKWR1	LH	R0,XGK.RM		: See if any room in ring
0108AC	032F 			  JLER	R15			: No, try again later
			
			: Room is available, so send an XGK D3D3
0108AE	E610 4000 2FE4 		LA	R1,MSGHDR,,		: Address of output message
0108B4	E620 4000 3938 		LA	R2,MSGGET,,		: Address of message to send
0108BA	4160 0000 		JAL	R6,MVBYTE		: Move the record
0108BE	2401 			LIS	R0,1			: Get "WRITE" command
0108C0	4000 4000 2FC0 		STH	R0,SIOOUT,,		: Setup command
0108C6	C800 0100 		LHI	R0,RECSIZ		: Message is 100 bytes
0108CA	4000 4000 2FC2 		STH	R0,SIOOUT+2,,		: Setup byte count
0108D0	2402 			LIS	R0+0,SIO1		: Get logical unit for SIO port
0108D2	E610 4000 2FC0 		LA	R0+1,SIOOUT,,		: Address of command list
0108D8 00B0 		SVC	IO,0B0+R0		: Call for output
0108DC	4300 8108 		  J	SIOCHK			: Not yet, see if we're busy
0108E0	2501 			LCS	R0,1			: Get -1 to decrement
0108E2	6100 4000 1EA8 		AHM	R0,XGK.RM,,		:  the room counter
0108E8	030F 			JR	R15			: Return
			
						
			: XGKREQ - Called from background to request XGK message for port
			:
			: call:
			:	R1 = Port number to initiate message
			:	JAL	R4,XGKREQ
			:
			: non-skip return if port already processing message
			: skip return if request queued and ready
			:
0108EA	7410 3930 	XGKREQ	TBT	R1,XGKSND		: Am I already sending? 
0108EE	4230 0004 		  JN	R4			: Yes, give error return
			:	CLB	XGKLIN,R1		: No, clear lines sent
0108F2	7510 3930 		SBT	R1,XGKSND		:  and set sending flag
0108F6	2644 			AIS	R4,4			: Do skip return
0108F8	0304 			JR	R4
			
			
			: XGKREC - Called from background to read a message for a port
			:	   coming from the SIO port
			: call:
			:	JAL	R4,XGKREC
			:
			: non-skip return if nothing to send
			: skip return:
			:	R1 = Address of message in the following format
			:	     .---.---.--------.-.-.-.-.-.-.
			:	     | port# | #bytes | data ...  |
			:	     |___:___|________|_:_:_:_:_:_|
			:
0108FA	4820 2FCC 	XGKREC	LH	R2,XGKRDY		: Are we ready to go?
0108FE	0334 			  JER	R4			: No, skip out
010900	4820 1EA4 		LH	R2,XGK.RD		: Get pointer
010904	4920 1EA6 		CH	R2,XGK.WT		: Does it match? cannot pass WT
010908	0334 			  JER	R4			: Yes, no buffers available
01090A	E612 4000 1EAC 		LA	R1,XGKBUF,R2,		: Get buffer address
010910	2644 			AIS	R4,4			: Set skip value
010912	0304 			JR	R4			: Jump to skip return
			
010914	4820 1EA4 	XGKRDN	LH	R2,XGK.RD		: Get pointer
010918	CA20 0100 		AHI	R2,RECSIZ		: Move to next entry
01091C	C930 1000 		CHI	R3,10*RECSIZ		: At end of ring?
010920	2132 			  JNFS	NWRPXG			: No, skip ahead
010922	2420 			LIS	R2,0			: Yes, reset to top
010924	4020 4000 1EA4 	NWRPXG	STH	R2,XGK.RD,,		: Remember the pointer
01092A	2644 			AIS	R4,4			: Set skip return
01092C	0304 			JR	R4			:  and go
			
			
						
01092E	E600 4000 2F6A 	ERRBSC	LA	R0,WRNBSC,,		: Warn about bad command
010934	E120 001D 		SVC	SYS,SUDIA.		: Set diagnostic message
010938	E120 0005 		SVC	SYS,FREEZ.		: Now freeze the slot
01093C	4300 FD76 		J	FGLOOP			: Return to FG loop
			
			
010940	E600 4000 2F3C 	ERRXGT	LA	R0,FATXGT,,		: non-eXistant check on GT
010946	2304 			JFS	GIVEUP
010948	E600 4000 2F0F 	ERRSRW	LA	R0,FATSRW,,		: Sync Ring wrap problem
01094E	E120 001D 	GIVEUP	SVC	SYS,SUDIA.		: Set diagnostic message
010952	E120 0020 		SVC	SYS,HALT.		: and halt the slot
010956	2204 			JBS	GIVEUP			: Loop in case dummy says go
			
			
			: STORHW - Used to pre-fill a buffer with a given half-word
			:
			: call:
			:	R0 = byte/half-word to store
			:	R1 = address of buffer
			:	R2 = count of halfwords
			:	JAL	R4,STORHW
010958	ED20 0001 	STORHW	SLL	R2,1			: Convert HW to Bytes
01095C	2722 		STORME	SIS	R2,2			: Decrement counter
01095E	0214 			  JLR	R4			: Return when out of data
010960	4001 4200 0000 		STH	R0,0,R1,R2		: Store halfword
010966	2205 			JBS	STORME			:  and loop till done
			
			
						
010968	2402 		SIOINI	LIS	R0+0,SIO1		: Get logical unit
01096A	E610 4000 2FA0 		LA	R0+1,SIOWIN,,		: Start of SIO window
010970	E620 4000 3920 		LA	R0+2,SIOEND,,		: End of SIO window
010976	E630 4000 3910 		LA	R0+3,SIOSTS,,		: SIO status bytes
01097C	E130 0090 		SVC	IO,090+R0		: Connect motherboard
010980	E120 0005 		  SVC	SYS,FREEZ.		: No? --- Something wrong!!!
010984	E610 4000 2FA0 		LA	R0+1,SIOSIO,,		: Initialization parameters
01098A	E130 00B0 		SVC	IO,0B0+R0		: Initialize!
01098E	E120 0005 		  SVC	SYS,FREEZ.		: No? --- Something wrong!!!
010992	E610 4000 2FD0 		LA	R0+1,SIOIN,,		: Start SIO input
010998	E130 00A0 		SVC	IO,0A0+R0		: Start
01099C	030F 			JR	R15			: Return from initialization
			
01099E	4800 4000 2FCC 	XGKINI	LH	R0,XGKRDY,,		: Is XGK talking to me?
0109A4	023F 			  JNR	R15			: Yes, don't do this again
0109A6	4800 4000 2FCA 		LH	R0,XGKHEL,,		: Have we sent Hello?
0109AC	023F 			  JNR	R15			: Yes, XGKRDY gets set elsewhere
0109AE	C800 0100 		LHI	R0,100			: 100 byte messages
0109B2	E610 4000 2FE4 		LA	R1,MSGHDR,,		: Store message here
0109B8	E620 4000 3934 		LA	R2,MSGHEL,,		: Get hello message
0109BE	4160 4000 0000 		JAL	R6,MVBYTE,,		: Setup message
0109C4	C800 0002 		LHI	R0+0,SIO1		: Get logical unit
0109C8	E610 4000 2FC0 		LA	R0+1,SIOOUT,,		: And buffer address
0109CE	E130 00B0 		SVC	IO,0B0+R0		: Do the output
0109D2	4300 8012 		  J	SIOCHK			: Check problem
0109D6	2401 			LIS	R0,1			: Get flag
0109D8	4000 4000 2FCA 		STH	R0,XGKHEL,,		: We have sent hello
0109DE	C800 FFFF 		LHI	R0,0FFFF		: Get magic port number
0109E2	4000 2FDC 		STH	R0,FxPORT		:  and store it
0109E6	030F 			JR	R15			: Return for now
			
			
0109E8	EC00 0010 	SIOCHK	SRL	R0,10			: Get high byte of calling register
0109EC	C900 0003 		CHI	R0,0003			: 0003 = Motherboard busy
0109F0	033F 			  JER	R15			: Try again later
0109F2	E120 0005 		SVC	SYS,FREEZ.		: Fatal error, freeze slot
0109F6	030F 			JR	R15			: Now, Try again later
			
			
			
				EM		: End of module FMAIN
			
			:
			:	Carl A Baltrunas,   TTE 442	Lab #6
			:	Source file for SLOT #1
			:
			
				GL	FSTART		: start of foreground
				GL	SYNCBF		: put/get sync buffer
				GL	STORHW		: Fill buffer with halfword
				GL	MOUTSC		: Move output string
				GL	MVBYTE		: Byte Move routine
				GL	XGKREQ		: Entry to request X.GK message on port
				GL	XGKREC		: Entry to read any X.GK message lines
				GL	XGKRDN		: Entry to finish X.GK message line
			
				RA	0			: Reset radix (some libraries don't)
			
000004			WRDSIZ	EQ	4			: Bytes per word
			
000003			CmETX	EQ	03			: Control-C
000007			CmBELL	EQ	07			: Bell
00000A			CmLF	EQ	0A			: Line-feed
00000D			CmCR	EQ	0D			: Carriage return
00000E			CmSI	EQ	0E			: Control-O
00001B			CmESC	EQ	1B			: Escape
000020			CmSPAC	EQ	20			: Space
			
00003F			CmQMRK	EQ	3F			: "?" Help
000043			CmCONN	EQ	43			: "C"onnect
000048			CmHELP	EQ	48			: "H"elp
00004D			CmMSGS	EQ	4D			: "M"essage
00004E			CmNOSY	EQ	4E			: "N"oisy
00004F			CmSOUT	EQ	4F			: "O"utput synch byte
000051			CmQUIT	EQ	51			: "Q"uit
000052			CmSDIS	EQ	52
000054			CmTIME	EQ	54			: "T"ime of day
000057			CmWHAT	EQ	57			: "W"hat
			
			CTRLM	MACRO(TYP,ADDR)	[	CHI	R2,TYP		: Message TYP ?
							  JE	ADDR	]	: Yes, handle at ADDR
			
			
						
			: Beginning of some constant data
			
003B3C				SEG	A.DATA
			
			
003B3C	019E 		MxDET	HC	019E			: Detach message
003B3E	019F 		MxZAP	HC	019F			: Zap message
003B40	01A0 		MxEBP	HC	01A0			: Enable back-pressure message
003B42	01A1 		MxDBP	HC	01A1			: Disable back-pressure message
003B44	01A2 		MxGOB	HC	01A2			: Character gobbler message
003B46	01A3 		MxFINP	HC	01A3			: Flush input message
003B48	01A4 		MxBLB	HC	01A4			: Black ball message
003B4A	01A5 		MxGRB	HC	01A5			: Grey ball message
003B4C	01A6 		MxSDEM	HC	01A6			: Start Deferred Echo Mode
003B4E	01A7 		MxFDEM	HC	01A7			: Finish Deferred Echo Mode
003B50	01AA 		MxGB	HC	01AA			: Green ball message
003B52	01AB 		MxRB	HC	01AB			: Red ball message
003B54	01AC 		MxYB	HC	01AC			: Yellow ball message
003B56	01AD 		MxOB	HC	01AD			: Orange ball message
003B58	03B1 0001 	M1TP00	HC	03B1,0001		: B1 message echo-control ON
003B5C	03B1 0000 	M0TP00	HC	03B1,0000		: B1 message echo-control OFF
			
			
003B60	0010 		UIDSIZ	HC	4*WRDSIZ		: Words for user id entry
			
003B62	0202 0202 0202 	CCCTAB	BC	2,2,2,2,2,2		: NUL,SOH,STX,ETX,EOT,ENQ
003B68	0201 0101 0101 		BC	2,1,1,1,1,1		: ACK,BEL,BS ,HT ,LF ,VT
003B6E	0102 0202 0202 		BC	1,2,2,2,2,2		: FF ,CR ,SO ,SI ,DLE,DC1
003B74	0202 0202 0202 		BC	2,2,2,2,2,2		: DC2,DC3,DC4,NAK,SYN,ETB
003B7A	0202 0201 0202 		BC	2,2,2,1,2,2		: CAN,EM ,SUB,ESC,FS ,GS
003B80	0202 0101 0101 		BC	2,2,1,1,1,1		: RS ,US ,SP , ! , " , #
						
			: More Constant data storage  (strings)
			
003B86	00			BC	0			: Dummy
003B87	0E 		HUPMSG	BC	0E			: Msg byte count
003B88	1000 000A 0004 		HC	1000,HST0,HPRT0,0,0	: Host up message (type 10)
	0000 0000 	
003B92	0099 0000 		HC	PRODID,0		: Prod ID & filler for msg
003B96	00			BC	0			: Dummy
003B97	08 		HSTOOP	BC	8			: Msg byte count
003B98	0A00 000A 0000 		HC	0A00,HST0,0,0		: Host port availability (none)
	0000 		
003BA0	00			BC	0			: Dummy
003BA1	08 		HSTOKP	BC	8			: Msg byte count
003BA2	0A00 000A 0004 		HC	0A00,HST0,HPRT0,0	: Host port availability
	0000 		
			
003BAA	290A 0D0D C7A7 	WELMSG	SC	\"0A"0D"0DG'Day Bubba!"0A"0DWelcome to Carl's Host"0A"0D\
	C4E1 F9A0 C2F5 	
	E2E2 E1A1 0A0D 	
	D7E5 ECE3 EFED 	
	E5A0 F4EF A0C3 	
	E1F2 ECA7 F3A0 	
	C8EF F3F4 0A0D 	
003BD4	0A0A 0DD5 F3E5 	UIDMSG	SC	\"0A"0DUserid: \
	F2E9 E4BA A0	
003BDF	05 0A0D BDBE A0	PMTMSG	SC	\"0A"0D=> \
003BE5	10 0A0D C7EF A0	MxBYE	SC	\"0A"0DGo Away!!!"0A"0D"0A"0D\
	C1 F7E1 F9A1 A1	
	A1 0A0D 0A0D 	
003BF6	2A0A 0DD1 F5E9 	MxALQ	SC	\"0A"0DQuit already in progress! Go Away!!!"0A"0D"0A"0D\
	F4A0 E1EC F2E5 	
	E1E4 F9A0 E9EE 	
	A0F0 F2EF E7F2 	
	E5F3 F3A1 A0C7 	
	EFA0 C1F7 E1F9 	
	A1A1 A10A 0D0A 	
	0D		
003C21	0E 0A0D D4E9 ED	MxTIME	SC	\"0A"0DTime now is \
	E5 A0EE EFF7 A0	
	E9 F3A0 	
003C30	0207 A1		MxBELL	SC	\"07!\			: Ding!
003C33	02 0A0D 	MxCRLF	SC	\"0A"0D\
			
						
			:	C = Connect to another line (echo on both)
			:	H = Help, (or ?)
			:	M = Message another line (send one time message)
			:	N = Noisy terminal toggle
			:	O = Output Sync (enable)
			:	Q = Quit, teardown circuit and wait for a new login
			:	R = Reset Sync output (dismiss)
			:	S = Status message about slot
			:	T = Print daytime in local time zone
			:	W = What lines are active and Who is on-line
			:
			:	any other character causes a bell
			:
				LIST	L,-X,-R
003C36	10C3 EDE4 A0A0 	MxHELP	SC	\Cmd   Function"0A"0D\
	A0C6 F5EE E3F4 	
	E9EF EE0A 0D	
003C47	17 A0D8 A0A0 A0	MhHELP	SC	\ X    Type this message\
	A0 D4F9 F0E5 A0	
	F4 E8E9 F3A0 ED	
	E5 F3F3 E1E7 E5	
			:MhCONN	SC	\ X    Connect a port to another user-port\
003C5F	2D A0D8 A0A0 A0	MhMSGS	SC	\ X    Get secret message from George via X.GK\
	A0 C7E5 F4A0 F3	
	E5 E3F2 E5F4 A0	
	ED E5F3 F3E1 E7	
	E5 A0E6 F2EF ED	
	A0 C7E5 EFF2 E7	
	E5 A0F6 E9E1 A0	
	D8 AEC7 CB	
003C8D	17 A0D8 A0A0 A0	MhNOSY	SC	\ X    Noisy flag toggle\
	A0 CEEF E9F3 F9	
	A0 E6EC E1E7 A0	
	F4 EFE7 E7EC E5	
003CA5	1D A0D8 A0A0 A0	MhSOUT	SC	\ X    Output new Sync pattern\
	A0 CFF5 F4F0 F5	
	F4 A0EE E5F7 A0	
	D3 F9EE E3A0 F0	
	E1 F4F4 E5F2 EE	
003CC3	20 A0D8 A0A0 A0	MhQUIT	SC	\ X    Leave the system (LOG OFF)\
	A0 CCE5 E1F6 E5	
	A0 F4E8 E5A0 F3	
	F9 F3F4 E5ED A0	
	A8 CCCF C7A0 CF	
	C6 C6A9 	
003CE4	19A0 D8A0 A0A0 	MhSDIS	SC	\ X    Dismiss Sync output\
	A0C4 E9F3 EDE9 	
	F3F3 A0D3 F9EE 	
	E3A0 EFF5 F4F0 	
	F5F4 		
			:MhSTAT	SC	\ X    Type system statistics\
003CFE	1EA0 D8A0 A0A0 	MhTIME	SC	\ X    Type current time of day\
	A0D4 F9F0 E5A0 	
	E3F5 F2F2 E5EE 	
	F4A0 F4E9 EDE5 	
	A0EF E6A0 E4E1 	
	F9		
003D1D	20 A0D8 A0A0 A0	MhWHAT	SC	\ X    Type user-port information\
	A0 D4F9 F0E5 A0	
	F5 F3E5 F2AD F0	
	EF F2F4 A0E9 EE	
	E6 EFF2 EDE1 F4	
	E9 EFEE 	
			
			CmdMAC	MACRO(Chr,Fnc,Hlp,ExtHlp) [	WC	Chr*01000000+Fnc
								HC	Hlp,ExtHlp	   ]
003D40				WS	0	: Make sure word boundary
			CmdTAB						: Command table
000000			CmdChr	EQ	(.-CmdTAB)			:   Offset for Character
000000			CmdFnc	EQ	(.-CmdTAB)			:   Offset for Dispatch
003D40	3F01 0F38 		WC	CmQMRK*01000000+CxHELP		:   Function address
000004			CmdHlp	EQ	(.-CmdTAB)			:   Offset for Help text
003D44	3C47 0000 		HC	MhHELP,0			:   Help message address
000008			CmdSiz	EQ	(.-CmdTAB)			:   Entry size
			
003D4C	3C47 3C47 		CmdMAC(	CmHELP,CxHELP,MhHELP,MhHELP )	: Help
			:	CmdMAC(	CmCONN,CxCONN,MhCONN,MhCONN )	: Connect
003D54	3C5F 3C5F 		CmdMAC(	CmMSGS,CxMSGS,MhMSGS,MhMSGS )	: Message
003D5C	3C8D 3C8D 		CmdMAC(	CmNOSY,CxNOSY,MhNOSY,MhNOSY )	: Noisy
003D64	3CA5 3CA5 		CmdMAC(	CmSOUT,CxSOUT,MhSOUT,MhSOUT )	: SyncOUTbyte
003D6C	3CC3 3CC3 		CmdMAC(	CmQUIT,CxQUIT,MhQUIT,MhQUIT )	: Quit
003D74	3CE4 3CE4 		CmdMAC(	CmSDIS,CxSDIS,MhSDIS,MhSDIS )	: SyncDISmiss
			:	CmdMAC(	CmSTAT,CxSTAT,MhSTAT,MhSTAT )	: Statistics
003D7C	3CFE 3CFE 		CmdMAC(	CmTIME,CxTIME,MhTIME,MhTIME )	: Time
003D84	3D1D 3D1D 		CmdMAC(	CmWHAT,CxWHAT,MhWHAT,MhWHAT )	: What (Who)
000009			CmdLEN	EQ	(.-CmdTAB)/CmdSiz
			
				LIST	-L,F,X,R
						
			: Variable data
			
003D88			TCLASS	BS	MAXPRT			: Throughput class of port
003D98			CCTYPE	BS	MAXPRT			: CCT for each port
003DA8			XMTMAX	BS	MAXPRT			: Save transmit limits
003DB8			NFROM	HS	MAXPRT			: Node of origin for each port
003DD8			HFROM	HS	MAXPRT			: Host of origin for each port
003DF8			PORTID	HS	MAXPRT			: Address of each Port Id string
			
003E18			MsMSGC	BS	1			: Byte count for single char string
003E19			MsCHAR	BS	1			: Current character
003E1A			MsPORT	HS	1			: Current message port
003E1C			MsTYPE	HS	1			: Current message type
			
003E20			LOGINS	WS	1			: Count number of active logins
003E24			SIMSGS	WS	1			: Address of next SIO message
003E28			MySYNC	WS	1			: Current/next sync buffer
003E2C			SIPORT	HS	1			: Port for next SIO message 
003E2E			MsSOUT	HS	1			: Sync output pattern
003E30			MsSFLG	HS	1			: Place sync
003E32			CHRCNT	HS	1			: Place to hold character count
			
			: Flags
			
003E34			WAITB1	WS	MAXBIT			: Bit array - Waiting for B1 return
003E38			PORTBP	WS	MAXBIT			: Bit array - Port is backpressured
003E3C			ECHOME	WS	MAXBIT			: Bit array - Can echo characters
003E40			ECHOHT	WS	MAXBIT			: Bit array - Can echo HT
003E44			ECHOCR	WS	MAXBIT			: Bit array - Can echo CR (RUB on LF)
003E48			ECHOBS	WS	MAXBIT			: Bit array - Can echo BS
003E4C			ECHOES	WS	MAXBIT			: Bit array - Can echo ESC
003E50			LOGGED	WS	MAXBIT			: Bit array - Logged-in
003E54			LOGDET	WS	MAXBIT			: Bit array - DET sent
003E58			NEEDID	WS	MAXBIT			: Bit array - need Id
003E5C			NEEDCH	WS	MAXBIT			: Bit array - need CH
003E60			NEEDCR	WS	MAXBIT			: Bit array - need CR
003E64			NOISEY	WS	MAXBIT			: Bit array - noisy terminal
			
003E68			PORTSC	WS	MAXPRT*4		: Storage for port id's
			
						
003F68	11CA EFE2 F3BD 	MxLOGS	SC	\Jobs=NN, max=NN"0A"0D\
	CECE ACA0 EDE1 	
	F8BD CECE 0A0D 	
003F7A	022A 3F6E 	LxJOBS	HC	0220+0A,MxLOGS+06	: LOGINS at the moment
003F7E	022A 3F76 	LxHPRT	HC	0220+0A,MxLOGS+0E	: Maximum logins
			
003F82	08C8 C8BA CDCD 	SvTIME	SC	\HH:MM:SS\		: Time of day
	BAD3 D3		
003F8B	33 A0A0 D0EF F2	MxWHAT	SC	\  Port Username      ST    Node    Host  CCT TPC "0A"0D\
	F4 A0D5 F3E5 F2	
	EE E1ED E5A0 A0	
	A0 A0A0 A0D3 D4	
	A0 A0A0 A0CE EF	
	E4 E5A0 A0A0 A0	
	C8 EFF3 F4A0 A0	
	C3 C3D4 A0D4 D0	
	C3 A00A 0D	
003FBF	33 A0A0 AAD0 D0	SvWHAT	SC	\  *PP  ------------  --  NNNNNN  HHHHHH  CCT TPC "0A"0D\
	A0 A0AD ADAD AD	
	AD ADAD ADAD AD	
	AD ADA0 A0AD AD	
	A0 A0CE CECE CE	
	CE CEA0 A0C8 C8	
	C8 C8C8 C8A0 A0	
	C3 C3D4 A0D4 D0	
	C3 A00A 0D	
003FF4	0120 3FC2 	WxMINE	HC	0120+00,SvWHAT+03	: * = My port
003FF8	0230 3FC3 	WxPORT	HC	0220+10,SvWHAT+04	: Port mask
003FFC	0C20 3FC7 	WxUSER	HC	0C20+00,SvWHAT+08	: User ID
004000	0220 3FD5 	WxSTAT	HC	0220+00,SvWHAT+16	: Status code
004004	0628 3FD9 	WxNODE	HC	0620+08,SvWHAT+1A	: Origin Node
004008	062A 3FE1 	WxHOST	HC	0620+0A,SvWHAT+22	: Origin Host
00400C	0348 3FE9 	WxCCT	HC	0340+08,SvWHAT+2A	: CCT
004010	0348 3FED 	WxTPC	HC	0340+08,SvWHAT+2E	: TPC
			
			0109F8				SEG	A.CODE
			
			: Program begins here, entry defined by START.LIB
			: Output initial host-up message to the SUP
			
0109F8	2420 		START	LIS	R2,0			: RPORT = 0
0109FA	E630 4000 3B87 		LA	R3,HUPMSG,,		: Setup msg address
010A00	4150 4001 0070 		JAL	R5,OCM,,		: Send message
010A06	E600 FC0C 		LA	R0,FSTART		: Foreground start address
010A0A	E120 0001 		SVC	SYS,CFGND.		: Connect foreground
			
			: Main message input loop, all routines return here one way or another
			
010A0E	E100 0000 	NOMSGS	SVC	DISMIS			: Done
010A12	41D0 831A 		JAL	R13,DOSYNC		: Dumping Sync?
010A16	41D0 834E 		JAL	R13,DOSIO		: Dumping SIO?
010A1A	4140 4001 0000 	ISMSG	JAL	R4,LOOK,,		: Look for a message (FRING)
010A20	4300 FFEA 		  J	NOMSGS			: No messages
			
			: R1 condition codes setup. for message port (by FRING)
			: Messages with RPORT=0 can be tested at this point
			
010A24	4330 8080 		JE	ZFLUSH			: RPORT 0 Msg!  Flush it
			
			: Save RPORT and message TYPE for this message for later
			
010A28	4010 4000 3E1A 		STH	R1,MsPORT,,		: Save current port
010A2E	4020 4000 3E1C 		STH	R2,MsTYPE,,		: Save current type
010A34	0822 			LR	R2,R2			: Set condition codes for type
010A36	4330 816C 		JE	ISNDL			: Got a needle?
			
			: Decide whether this is control or data
			
010A3A	C920 009E 		CHI	R2,09E			: Control or data message?
010A3E	4210 836C 		JL	MsDATA			: Data! -- Process the data
			
010A42	C920 009F 		CTRLM(	09F,MsIZAP )[	CHI	R2,	09F		: Message 	09F ?
010A46	4330 806E 					  JE	MsIZAP 	]		: ZAP?, handle incoming zap!
010A4A	C920 00A0 		CTRLM(	0A0,MsEBP  )[	CHI	R2,	0A0		: Message 	0A0 ?
010A4E	4330 8124 					  JE	MsEBP  	]		: Enable backpressure
010A52	C920 00A1 		CTRLM(	0A1,MsDBP  )[	CHI	R2,	0A1		: Message 	0A1 ?
010A56	4330 8106 					  JE	MsDBP  	]		: Disable backpressure
010A5A	C920 00A6 		CTRLM(	0A6,MsEDEF )[	CHI	R2,	0A6		: Message 	0A6 ?
010A5E	4330 80DE 					  JE	MsEDEF 	]		: Enter deferred echo mode
010A62	C920 00A7 		CTRLM(	0A7,MsLDEF )[	CHI	R2,	0A7		: Message 	0A7 ?
010A66	4330 80E6 					  JE	MsLDEF 	]		: Leave deferred echo mode
010A6A	C920 00AA 		CTRLM(	0AA,MSIGB  )[	CHI	R2,	0AA		: Message 	0AA ?
010A6E	4330 80BA 					  JE	MSIGB  	]		: GB (Green ball)?,  reflect it
010A72	C920 00AB 		CTRLM(	0AB,MsIRB  )[	CHI	R2,	0AB		: Message 	0AB ?
010A76	4330 80BC 					  JE	MsIRB  	]		: RB (Red ball)?,    reflect it
010A7A	C920 00AC 		CTRLM(  0AC,MsIYB  )[	CHI	R2,  0AC		: Message   0AC ?
010A7E	4330 8094 					  JE	MsIYB  	]		: YB (Yellow ball)?, reflect it
010A82	C920 00B1 		CTRLM(	0B1,MsITPM )[	CHI	R2,	0B1		: Message 	0B1 ?
010A86	4330 807C 					  JE	MsITPM 	]		: Process (ignore) term paramete
			**rs
010A8A	C920 00B9 		CTRLM(	0B9,MsXMTL )[	CHI	R2,	0B9		: Message 	0B9 ?
010A8E	4330 80FA 					  JE	MsXMTL 	]		: Set transmit limit for port
			
						
			: Come here to flush non-rport=0 messages
			: before returning to main loop
			
010A92	4820 4000 3E1C 	MFLUSH	LH	R2,MsTYPE,,		: Remember type
010A98	D302 400F 0028 		LB	R0,LENGTH,R2,		: Get RPORT=N index byte
010A9E	4140 4001 0056 	XFLUSH	JAL	R4,FLUSH,,		: Flush message
010AA4	4300 FF72 		J	ISMSG			: Any more messages
			
			: Come here to flush rport=0 messages
			: before returning to main loop
			
010AA8	4860 400F 0026 	ZFLUSH	LH	R6,LP0LST,,		: Get RPORT=0 index table
010AAE	D306 420F 0000 		LB	R0,NRATE,R6,R2		: NRATE+TABLE(R2) Get message size
010AB4	4300 FFE6 		J	XFLUSH			: Flush above
						
			: Control message code:  Handle Circuit-ZAP
			
010AB8	4820 4000 3E1A 	MsIZAP	LH	R2,MsPORT,,		: Get current port
010ABE	7420 4000 3E54 		TBT	R2,LOGDET,,		: Check DET bit for this port
010AC4	4230 8028 		  JN	MsEZAP			: Yes, expected zap, don't reflect
010AC8	E630 4000 3B3E 		LA	R3,MxZAP,,		: Get zap message
010ACE	4150 4001 0070 		JAL	R5,OCM,,		: Send it <Whack>
010AD4	2420 			LIS	R2,0			: Tell the supervisor
010AD6	E630 4000 3BA1 		LA	R3,HSTOKP,,		: host no longer
010ADC	4150 4001 0070 		JAL	R5,OCM,,		: out of ports
010AE2	4800 4000 3E20 		LH	R0,LOGINS,,		: Decrement login count
010AE8	2701 			SIS	R0,1			:  by 1
010AEA	4000 4000 3E20 		STH	R0,LOGINS,,		: to keep us honest
010AF0	4820 4000 3E1A 	MsEZAP	LH	R2,MsPORT,,		: Get current port
010AF6	7620 4000 3E50 		RBT	R2,LOGGED,,		: Clear logged-in bit
010AFC	7620 4000 3E54 		RBT	R2,LOGDET,,		: Clear DET bit for this port
010B02	4300 FF8C 		J	MFLUSH			: Return through flushing code
			
			: Terminal parameter message - for now, just mark we were waiting for it
			:  Later, we need to check each type and keep track of parameter values
			
010B06	4820 4000 3E1A 	MsITPM	LH	R2,MsPORT,,		: Get current port
010B0C	7620 4000 3E34 		RBT	R2,WAITB1,,		: Clear bit waiting
010B12	4300 FF7C 		J	MFLUSH			: and flush message
			
			: Control message code:  Handle Yellow-Ball
			: by reflecting an Orange-Ball on the same port
			
010B16	E630 4000 3B56 	MsIYB	LA	R3,MxOB,,		: Get OB message
010B1C	4820 4000 3E1A 	MsPMSG	LH	R2,MsPORT,,		: Get current port
010B22	4150 4001 0070 		JAL	R5,OCM,,		: Send it <Whack>
010B28	4300 FF66 		J	MFLUSH			: And flush message
			
			: Other single byte reflecting messages
			
010B2C	E630 4000 3B50 	MsIGB	LA	R3,MxGB,,		: Get GB message
010B32	4300 FFE6 		J	MsPMSG			: Send message
			
010B36	E630 4000 3B52 	MsIRB	LA	R3,MxRB,,		: Get RB message
010B3C	4300 FFDC 		J	MsPMSG			: And flush message
			
010B40	4820 4000 3E1A 	MsEDEF	LH	R2,MsPORT,,		: Get current port
010B46	7620 4000 3E3C 		RBT	R2,ECHOME,,		: Clear echo flag (HOST ECHO)
010B4C	4300 FF42 		J	MFLUSH			: and clear input message
			
010B50	4820 4000 3E1A 	MsLDEF	LH	R2,MsPORT,,		: Get current port
010B56	7520 4000 3E3C 		SBT	R2,ECHOME,,		: Set echo flag (CONSAT ECHO)
010B5C	4300 FF32 		J	MFLUSH			: and clear input message
			
010B60	4820 4000 3E1A 	MsDBP	LH	R2,MsPORT,,		: Get current port
010B66	7620 4000 3E38 		RBT	R2,PORTBP,,		: Clear backpressure (reflect)
010B6C	E630 4000 3B42 		LA	R3,MxDBP,,		: Get disable backpressure
010B72	4300 FFA6 		J	MsPMSG			: And flush message
			
010B76	4820 4000 3E1A 	MsEBP	LH	R2,MsPORT,,		: Get current port
010B7C	7520 4000 3E38 		SBT	R2,PORTBP,,		: Set backpressure (reflect)
010B82	E630 4000 3B40 		LA	R3,MxEBP,,		: Get enable backpressure
010B88	4300 FF90 		J	MsPMSG			: And flush message
			
010B8C	4820 4000 3E1A 	MsXMTL	LH	R2,MsPORT,,		: Get current port
010B92	4140 4001 0036 		JAL	R4,GETH,,		: Get B9xx from message
010B98	D202 3DA8 		STB	R0,XMTMAX,R2		: Store it (to be ignored)
010B9C	4140 4001 0058 		JAL	R4,ELIR,,		: Flush end of message
010BA2	4300 8160 		J	PRMPT			: And finish
						
			: We have a needle, print startup (welcome) message to port and fall through
			
010BA6	4820 4000 3E1A 	ISNDL	LH	R2,MsPORT,,		: Get RPORT
010BAC	7620 4000 3E54 		RBT	R2,LOGDET,,		: Clear DET sent bit
010BB2	7620 4000 3E60 		RBT	R2,NEEDCR,,		:  and CR needed bit
010BB8	7520 4000 3E64 		SBT	R2,NOISEY,,		: Set initial noisy state
010BBE	4140 4001 0036 		JAL	R4,GETH,,		: Get 00+Messagelength
010BC4	0860 			LR	R6,R0			: Remember length (bytes)
010BC6	4140 4001 0046 		JAL	R4,GETW,,		: Grab invoice Number (to throw away)
010BCC	4140 4001 0046 		JAL	R4,GETW,,		: Grab Dest-host, Orig Node
010BD2	4002 4000 3DB8 		STH	R0,NFROM,R2,		: Store NODE of origin
010BD8	4140 4001 0036 		JAL	R4,GETH,,		: Grab HOST of origin
010BDE	4002 4000 3DD8 		STH	R0,HFROM,R2,		: Store it
010BE4	4140 4001 0036 		JAL	R4,GETH,,		: Get port of origin (logical)
010BEA	4140 4001 0046 		JAL	R4,GETW,,		: Get xxxx, xx Throughput class
010BF0	D202 4000 3D88 		STB	R0,TCLASS,R2,		: Store it (byte)
010BF6	4140 4001 0036 		JAL	R4,GETH,,		: IIX + Destination node
010BFC	4140 4001 0026 		JAL	R4,GETCH,,		: Get Circuit Control Type
010C02	D202 4000 3D98 		STB	R0,CCTYPE,R2,		: Store for later
010C08	4140 4001 0026 		JAL	R4,GETCH,,		: Finish word
010C0E	CB60 0014 		SHI	R6,5*4			: Decrement count by 5 full words
010C12	0806 			LR	R0,R6			: Get remaining byte count
010C14	4140 4001 0056 		JAL	R4,FLUSH,,		: Flush needle
			
			: Instead of prompting for Userid, later just use the username from the needle
			
010C1A	4820 4000 3E1A 		LH	R2,MsPORT,,		: Get current port
010C20	7620 4000 3E3C 		RBT	R2,ECHOME,,		: Clear who's echoing
010C26	7520 4000 3E34 		SBT	R2,WAITB1,,		: Waiting for a B1 return
010C2C	E630 4000 3B58 		LA	R3,M1TP00,,		: Send my initial B1 message
010C32	4150 4001 0070 		JAL	R5,OCM,,		: to the other end
			
010C38	4820 4000 3E1A 		LH	R2,MsPORT,,		: Get current port
010C3E	E630 4000 3BAA 		LA	R3,WELMSG,,		: Get my greeting message
010C44	4150 4001 008C 		JAL	R5,OCS,,		: Print message
010C4A	4820 4000 3E20 		LH	R2,LOGINS,,		: Get login count
010C50	2621 			AIS	R2,1			:   increment
010C52	4020 4000 3E20 		STH	R2,LOGINS,,		:   and store
010C58	4800 4000 3F7A 		LH	R0,LxJOBS,,		: What it looks like
010C5E	4810 4000 3F7C 		LH	R1,LxJOBS+2,,		: Where it goes
			:	LH	R2,LOGINS,,		: Get login count
010C64	4160 4001 0558 		JAL	R6,OUTNUM,,		: Store job number
010C6A	4800 4000 3F7E 		LH	R0,LxHPRT,,		: Mask
010C70	4810 4000 3F80 		LH	R1,LxHPRT+2,,		: position
010C76	C820 0004 		LHI	R2,HPRT0		: Max jobs we allow
010C7A	4160 4001 0558 		JAL	R6,OUTNUM,,		: Store in string message
010C80	4820 4000 3E1A 		LH	R2,MsPORT,,		: Get current port
010C86	E630 4000 3F68 		LA	R3,MxLOGS,,		: Get usage message
010C8C	4150 4001 008C 		JAL	R5,OCS,,		: Print message
010C92	4810 4000 3E20 		LH	R1,LOGINS,,		: Have we reached
010C98	C910 0004 		CHI	R1,HPRT0		:  our port limit?
010C9C	4210 800E 		  JL	WANTID			: No, keep going
010CA0	2420 			LIS	R2,0			: Tell the supervisor
010CA2	E630 4000 3B97 		LA	R3,HSTOOP,,		: host out of ports
010CA8	4150 4001 0070 		JAL	R5,OCM,,		: so no more circuits
						
			: Ask the user for an ID - This need not be unique
			
010CAE	4820 4000 3E1A 	WANTID	LH	R2,MsPORT,,		: Get current port
010CB4	7520 4000 3E58 		SBT	R2,NEEDID,,		: Set need ID bit for this port
010CBA	7520 4000 3E60 		SBT	R2,NEEDCR,,		:  and wait for a CR too
010CC0	0832 			LR	R3,R2			: Copy for offset
010CC2	2731 			SIS	R3,1			: Decrement for 0 offset
010CC4	4C30 4000 3B60 		MH	R3,UIDSIZ,,		: Multiply by entry size
010CCA	2410 			LIS	R1,0			: Set to initial constant
010CCC	4013 4000 3E68 		STH	R1,PORTSC,R3,		:  for user id
010CD2	2306 			JFS	ASKID			: And skip to asking message
010CD4	7420 4000 3E60 	ASKUID	TBT	R2,NEEDCR,,		: Need a CR before re-prompt?
010CDA	4230 FD3C 		  JN	ISMSG			: Yes, don't say a thing
010CDE	7520 4000 3E34 	ASKID	SBT	R2,WAITB1,,		: Waiting for a B1 return
010CE4	E630 4000 3B5C 		LA	R3,M0TP00,,		: Send my no-echo B1 message
010CEA	4150 4001 0070 		JAL	R5,OCM,,		: to the other end
010CF0	4820 4000 3E1A 		LH	R2,MsPORT,,		: Get current port
010CF6	E630 4000 3BD4 		LA	R3,UIDMSG,,		: Get user id message
010CFC	4150 4001 008C 		JAL	R5,OCS,,		: Print request
010D02	4300 FD14 		J	ISMSG			: Any others
			
			: Send a prompt to the currently selected port
			
010D06	4820 4000 3E1A 	PRMPT	LH	R2,MsPORT,,		: Get RPORT
010D0C	7420 4000 3E58 		TBT	R2,NEEDID,,		: Waiting for user id?
010D12	4230 FFBE 		  JN	ASKUID			: Yes, ask instead of prompt
010D16	7420 4000 3E5C 		TBT	R2,NEEDCH,,		: Waiting for a character?
010D1C	4230 FCFA 		  JN	ISMSG			: Yes, don't prompt!
010D20	E630 4000 3BDF 		LA	R3,PMTMSG,,		: Get prompt message
010D26	4150 4001 008C 		JAL	R5,OCS,,		: Print message
010D2C	4300 FCEA 		J	ISMSG			: Any more messages
			
						
			: DoSYNC - Routine to check for SYNC characters to be dumped to the
			:	   forground SYNC process.
			:
			
010D30	4800 3E30 	DoSYNC	LH	R0,MsSFLG		: Are we doing Sync output?
010D34	033D 			  JER	R13			: No, just return
			:	LIS	R0,0			: Get a zero to
			:	STH	R0,MsSFLG		:  clear the flag,
010D36	5800 3E28 		L	R0,MySYNC		: Do I have a buffer?
010D3A	2135 			  JNFS	OkSYNC			: Yes, use the one I have
010D3C	4140 FA36 		JAL	R4,SYNCBF		: No, get a buffer
010D40	430D 0000 		  J	0,R13			: None available
010D44	0810 		OkSYNC	LR	R1,R0			: Copy buffer address
010D46	4800 3E2E 		LH	R0,MsSOUT		: Get byte to store
010D4A	C820 0200 		LHI	R2,200			:  and count
010D4E	4140 FC06 		JAL	R4,STORHW		: Store it
010D52	0801 			LR	R0,R1			: Copy buffer
010D54	4140 FA1E 		JAL	R4,SYNCBF		: Store it
010D58	4300 8006 		  J	NoSYNC			: Cannot store at this time
010D5C	C900 0000 		CHI	R0,0			: Anything in store?
010D60	033D 			  JER	R13			: No, go home
010D62	5000 3E28 	NoSYNC	ST	R0,MySYNC		: Store buffer to use	  
010D66	030D 			JR	R13			: Return to loop
			
			
			: DoSIO  - Routine to see if there is any SIO data for any of my
			:	   current ports.
			:
			
010D68	4820 4000 3E2C 	DoSIO	LH	R2,SIPORT,,		: Any saved SIO message?
010D6E	2115 			  JLFS	NewSIO			: No, get a new one
010D70	5830 4000 3E24 		L	R3,SIMSGS,,		:  and the message address
010D76	230D 			JFS	OldSIO			:  and fall into code
010D78	4140 4001 08FA 	NewSIO	JAL	R4,XGKREC,,		: See if any input for me
010D7E	030D 			  JR	R13			: No
010D80	030D 			  JR	R13			: No (use 2nd halfword)
010D82	4821 0000 		LH	R2,0,R1			: Get port number
010D86	E631 0002 		LA	R3,2,R1			: Get address of "byte" count+msg
010D8A	7420 3E38 		TBT	R2,PORTBP		: Is port backpressured
010D8E	2139 			  JNFS	NoSIO			: No SIO this time through
010D90	4150 4001 008C 	OldSIO	JAL	R5,OCS,,		: Output the message
010D96	4140 4001 0914 		JAL	R4,XGKRDN,,		: Indicate we are done with message
010D9C	2420 			LIS	R2,0			: Always clear saved area
010D9E	2430 			LIS	R3,0			:  (or maybe set it up)
010DA0	4020 4000 3E2C 	NoSIO	STH	R2,SIPORT,,		:  so re-entry works
010DA6	5030 4000 3E24 		ST	R3,SIMSGS,,		:  all the time
010DAC	030D 			JR	R13			: Return
			
			
						
			: Received a data message.  For this exercise, we are looking for
			: a particular command, sans case, sans parity:
			:
010DAE	4140 4001 0026 	MsDATA	JAL	R4,GETCH,,		: Get count of characters (MsType)
010DB4	4000 4000 3E32 		STH	R0,CHRCNT,,		: Copy byte count to loop register
010DBA	4820 4000 3E1A 		LH	R2,MsPORT,,		: Get current port number
010DC0	7420 4000 3E5C 		TBT	R2,NEEDCH,,		: Waiting for a char?
010DC6	4230 80A8 		  JN	MsGetC			: Yes, get char and store
010DCA	7420 4000 3E58 		TBT	R2,NEEDID,,		: Waiting for UserId?
010DD0	4230 80B4 		  JN	MuDATA			: Yes, get user Id
010DD4	4140 4001 0026 	MsLOOP	JAL	R4,GETCH,,		: Get data byte
010DDA	4140 4001 11C4 		JAL	R4,CSEVEN,,		: Clip it to 7 bits (upper case)
010DE0	41D0 4001 124A 		JAL	R13,RxECHO,,		: See if we need to echo R0
010DE6	C900 0003 		CHI	R0,CmETX		: User typed ^C
010DEA	4330 8066 		  JE	MsCNCL			:  so cancel output
010DEE	C900 000E 		CHI	R0,CmSI			: Do the same if
010DF2	4330 805E 		  JE	MsCNCL			:  we see ^O
010DF6	2420 			LIS	R2,0			: Start at first entry
010DF8	C830 0009 		LHI	R3,CmdLEN		: Get length
010DFC	D402 4000 3D40 	MsLOOK	CLB	R0,CmdTAB+CmdChr,R2,	: Is it this character?
010E02	2138 			  JNFS	MsFIND			: No, try next
010E04	5802 4000 3D40 		L	R0,CmdTAB+CmdFnc,R2,	: Get function
010E0A	F400 00FF FFFF 		NI	R0,00FFFFFF		:  and remove high byte
010E10	0300 			JR	R0			: Then dispatch ??
			
010E12	CA20 0008 	MsFIND	AHI	R2,CmdSiz		: Point to next entry
010E16	2731 			SIS	R3,1			: Are we done?
010E18	4220 FFE0 		JG	MsLOOK			: No, try next command
			
			: All messages reaching here contain unknown characters
			: Ignore the rest of the message (later until we see a CR)
			
010E1C	4820 4000 3E1A 	MsUNK	LH	R2,MsPORT,,		: Get current port
010E22	7420 4000 3E64 		TBT	R2,NOISEY,,		: Are we a noisy terminal?
010E28	4330 800C 		  JE	MsNEXT			: No, not a peep!
010E2C	E630 4000 3C30 		LA	R3,MxBELL,,		: Get bell message
010E32	4150 4001 008C 		JAL	R5,OCS,,		: Send message
			
			: All commands return to MsNEXT to complete reading input
			: and to flush the remainder of the message if needed!
			
010E38	4800 4000 3E32 	MsNEXT	LH	R0,CHRCNT,,		: Get characters left
010E3E	2701 			SIS	R0,1			: Decrement loop counter
010E40	4000 4000 3E32 		STH	R0,CHRCNT,,		: And remember the result
010E46	4220 FF8A 		JG	MsLOOP			: More characters, go get em
010E4A	4140 4001 0058 		JAL	R4,ELIR,,		: None left, fixup iring index
010E50	4300 FEB2 		J	PRMPT			: New prompt and go
			
010E54	E630 4000 3B44 	MsCNCL	LA	R3,MxGOB,,		: Get character gobbler message
010E5A	4820 4000 3E1A 		LH	R2,MsPORT,,		: Get current port
010E60	4150 4001 0070 		JAL	R5,OCM,,		: Send it to clear pipeline
010E66	D300 3E19 		LB	R0,MsCHAR		: We know ^C or ^O is still here
010E6A	41D0 83DC 		JAL	R13,RxECHO		: So echo it after the gobbler
010E6E	4300 FFC6 		J	MsNEXT			: and finish this message
			
010E72	4140 4001 0026 	MsGetC	JAL	R4,GETCH,,		: Get a character
010E78	4000 4000 3E2E 		STH	R0,MsSOUT,,		: and store it
010E7E	7620 4000 3E5C 		RBT	R2,NEEDCH,,		: clear flag
010E84	4300 FFB0 		J	MsNEXT			: next character
						
			: All messages here are for user id characters
			: Once the buffer pointer is setup, up to 12 bytes are stored
			: as String Constants for use with OCS.
			
010E88	4820 4000 3E1A 	MuDATA	LH	R2,MsPORT,,		: Get current port
010E8E	0882 			LR	R8,R2			: Copy for offset
010E90	2781 			SIS	R8,1			: Decrement for 0 offset
010E92	4C80 4000 3B60 		MH	R8,UIDSIZ,,		: Multiply by entry size
010E98	D378 4000 3E68 		LB	R7,PORTSC,R8,		: Get user id address size
010E9E	4140 4001 0026 	MuLOOP	JAL	R4,GETCH,,		: Get a byte
010EA4	C400 007F 		NHI	R0,07F			: Clip it to 7 bits (upper case)
010EA8	C900 000D 		CHI	R0,CmCR			: A Return?
010EAC	4330 8052 		  JE	MuTEND			: Yes, finish name
010EB0	C970 000C 		CHI	R7,$A12			: Allow up to 12
010EB4	2118 			  JLFS	MuSAVE			: Ok, go save it
010EB6	7420 3E64 		TBT	R2,NOISEY		: Check noise level (on overflow)
010EBA	4330 8014 		  JE	MuNEXT			: No noise - be quiet -
010EBE	C800 0007 		LHI	R0,CmBELL		: Overflow, make believe a bell
010EC2	2305 			JFS	MuECHO			: and just echo it
010EC4	2671 		MuSAVE	AIS	R7,1			: Increment byte (count) pointer
010EC6	D208 4700 3E68 		STB	R0,PORTSC,R8,R7		: Store next byte
010ECC	41D0 4001 124A 	MuECHO	JAL	R13,RxECHO,,		: See if we need to echo R0
010ED2	4800 4000 3E32 	MuNEXT	LH	R0,CHRCNT,,		: Get characters left
010ED8	2701 			SIS	R0,1			: Decrement loop counter
010EDA	4000 4000 3E32 		STH	R0,CHRCNT,,		: and remember it for later
010EE0	4220 FFBA 		JG	MuLOOP			: More characters, go get em
010EE4	4880 4000 3E1A 		LH	R8,MsPORT,,		: Get current port
010EEA	2781 			SIS	R8,1			: Decrement for 0 offset
010EEC	4C80 4000 3B60 		MH	R8,UIDSIZ,,		: Multiply by entry size
010EF2	D278 4000 3E68 		STB	R7,PORTSC,R8,		: Store counter
010EF8	4140 4001 0058 		JAL	R4,ELIR,,		: None left, fixup iring index
010EFE	4300 FE04 		J	PRMPT			: New prompt and go
			
			
010F02	7620 4000 3E58 	MuTEND	RBT	R2,NEEDID,,		: Set Id is complete
010F08	7620 4000 3E60 		RBT	R2,NEEDCR,,		:  and CR was seen
010F0E	7520 4000 3E50 		SBT	R2,LOGGED,,		: We are logged completely in
010F14	2721 			SIS	R2,1			: Decrement for 0 offset
010F16	4C20 4000 3B60 		MH	R2,UIDSIZ,,		: Multiply by entry size
010F1C	D272 4000 3E68 		STB	R7,PORTSC,R2,		: Store counter
010F22	4820 4000 3E1A 		LH	R2,MsPORT,,		: Get current port
010F28	E630 4000 3B58 		LA	R3,M1TP00,,		:  to send terminal parameter
010F2E	4150 4001 0070 		JAL	R5,OCM,,		:  message to allow consat to echo
010F34	4300 FF00 		J	MsNEXT			: All done, any more are commands
			
						
			: HELP - Print a help message about the slot
			:
			
004014				SEG	A.DATA
004014			CxHPTR	HS	1			: Place for pointer offset
004016			CxHLEN	HS	1			: Length of command list
010F38				SEG	A.CODE
			
			: Print a couple of CRLF pairs and the initial heading message
			
010F38	41D0 4001 11D4 	CxHELP	JAL	R13,TCRLF,,		: Type a carriage return
010F3E	41D0 4001 11D4 		JAL	R13,TCRLF,,		:   and another
010F44	4820 4000 3E1A 		LH	R2,MsPORT,,		: Get current port
010F4A	E630 4000 3C36 		LA	R3,MxHELP,,		: and message to print
010F50	4150 4001 008C 		JAL	R5,OCS,,		: Then print it
			
			: Setup the command index and length in memory
			: Then multiplex them through R1 to keep register usage to a minimum
			
010F56	2410 			LIS	R1,0			: Start at first entry
010F58	4010 4000 4014 		STH	R1,CxHPTR,,		: Remember the pointer offset
010F5E	C810 0009 		LHI	R1,CmdLEN		: Get length
010F62	4010 4000 4016 	CxHLOP	STH	R1,CxHLEN,,		: Remember it
010F68	4810 4000 4014 		LH	R1,CxHPTR,,		: Get offset
			
			: The first byte of each entry is the actual character
			: Here we store it in the actual one-line message before printing
			
010F6E	D301 4000 3D40 		LB	R0,CmdTAB+CmdChr,R1,	: Get character
010F74	4831 4000 3D44 		LH	R3,CmdTAB+CmdHlp,R1,	: Get help message
010F7A	D203 4000 0002 		STB	R0,0+2,R3,		: Store character in text
010F80	CA10 0008 		AHI	R1,CmdSIZ		: Point to next entry
010F84	4010 4000 4014 		STH	R1,CxHPTR,,		: Remember the pointer offset
010F8A	4820 4000 3E1A 		LH	R2,MsPORT,,		: Get the port
010F90	4150 4001 008C 		JAL	R5,OCS,,		: and print the line
010F96	41D0 4001 11D4 		JAL	R13,TCRLF,,		: Finish with a CRLF
			
			: Decrement and test the command table length, performing the
			: memory store above to save an extra instruction here.
			
010F9C	4810 4000 4016 		LH	R1,CxHLEN,,		: Get commands left	
010FA2	2711 			SIS	R1,1			: Any left?
010FA4	4220 FFBA 		JG	CxHLOP			: Yes, print them
010FA8	41D0 4001 11D4 		JAL	R13,TCRLF,,		: Finish with a CRLF
010FAE	4300 FE86 		J	MsNEXT			: Return to command loop
			
			
			: NOISY - Toggle the flag in the NOISEY array for this port
			:         if the bit is set, then we are noisy, otherwise quiet
			
010FB2	4820 4000 3E1A 	CxNOSY	LH	R2,MsPORT,,		: Get my port
010FB8	7720 4000 3E64 		CBT	R2,NOISEY,,		: Complement the bit
010FBE	4300 FE76 		J	MsNEXT			: (That was easy!)
			
			
			: CxMSGS - Request that secret X.GK message be sent to my port
			
010FC2	4810 4000 3E1A 	CxMSGS	LH	R1,MsPORT,,		: Get my port
010FC8	4140 4001 08EA 		JAL	R4,XGKREQ,,		: Request message
010FCE	4300 FE66 		J	MsNEXT			: (Whew, easier than I thought!)
						
			: OutSync buffer
			
010FD2	4820 4000 3E1A 	CxSOUT	LH	R2,MsPORT,,		: Get my port
010FD8	7520 4000 3E5C 		SBT	R2,NEEDCH,,		: Set need char
010FDE	2401 			LIS	R0,1			: Set flag true
010FE0	4000 4000 3E30 	CxSFLG	STH	R0,MsSFLG,,		:  to initiate i/o
010FE6	4300 FE4E 		J	MsNEXT			: and return
			
010FEA	2400 		CxSDIS	LIS	R0,0			: Set flag false
010FEC	2206 			JBS	CxSFLG			:  and return
			
			
			: QUIT - Mark we are in progress (check if already in progress)
			
010FEE	4820 4000 3E1A 	CxQUIT	LH	R2,MsPORT,,		: Get current port
010FF4	7420 4000 3E54 		TBT	R2,LOGDET,,		: Check in array (in progress)?
010FFA	4230 804A 		  JN	CxALQ			: Quit in progress
010FFE	E630 4000 3BE5 		LA	R3,MxBYE,,		: Get Goodbye message
011004	4150 4001 008C 		JAL	R5,OCS,,		: Send it
01100A	4820 4000 3E1A 		LH	R2,MsPORT,,		: Get port again
011010	E630 4000 3B3C 		LA	R3,MxDET,,		: Get detach message
011016	7520 4000 3E54 		SBT	R2,LOGDET,,		: Set in detach array
01101C	7620 4000 3E50 		RBT	R2,LOGGED,,		: Clear logged-in bit
011022	4150 4001 0070 		JAL	R5,OCM,,		: Send detach
011028	4820 4000 3E20 		LH	R2,LOGINS,,		: How many jobs?
01102E	2721 			SIS	R2,1			: Decrement
011030	4020 4000 3E20 		STH	R2,LOGINS,,		:  and keep track
011036	2420 			LIS	R2,0			: Tell the supervisor
011038	E630 4000 3BA1 		LA	R3,HSTOKP,,		: host no longer
01103E	4150 4001 0070 		JAL	R5,OCM,,		: out of ports
011044	4300 FDF0 		J	MsNEXT			: Get next character
			
			: %OOPS - Already waiting for OB from this port
			
011048	E630 4000 3BF6 	CxALQ	LA	R3,MxALQ,,		: Get message text
01104E	4150 4001 008C 		JAL	R5,OCS,,		: Print it
011054	4300 FDE0 		J	MsNEXT
			
			
			
			: TIME - Obtain current daytime and print it for the user
			
011058	5830 400F 000C 	CxTIME	L	R3,GMT,,		: Get current daytime
01105E	2448 			LIS	R4,8			: for HH:MM:SS format
011060	E650 4000 3F83 		LA	R5,SvTIME+1,,		: Indicate storage
011066	4160 4001 03DA 		JAL	R6,TMSTMP,,		: Get date string
			
01106C	4820 4000 3E1A 		LH	R2,MsPORT,,		: Get current port
011072	E630 4000 3C21 		LA	R3,MxTIME,,		: Get time message
011078	4150 4001 008C 		JAL	R5,OCS,,		: Print it
01107E	4820 4000 3E1A 		LH	R2,MsPORT,,		: Get current port
011084	E630 4000 3F82 		LA	R3,SvTIME,,		: Get actual time string
01108A	4150 4001 008C 		JAL	R5,OCS,,		: Print it
011090	4300 FDA4 		J	MsNEXT			: Return to loop
			
						
			: WHAT - Tell what lines are available
			
011094	41D0 4001 11D4 	CxWHAT	JAL	R13,TCRLF,,		: Free CRLF
01109A	4820 4000 3E1A 		LH	R2,MsPORT,,		: My port
0110A0	E630 4000 3F8B 		LA	R3,MxWHAT,,		: Print header message
0110A6	4150 4001 008C 		JAL	R5,OCS,,		: for this command
0110AC	2491 			LIS	R9,1			: Start with first port
0110AE	7490 4000 3E50 	CxWLOP	TBT	R9,LOGGED,,		: Is it logged?
0110B4	4330 80FE 		  JE	CxWNXT			: No, try next
0110B8	4800 4000 3FF4 		LH	R0,WxMINE,,		: Get -myself- mask
0110BE	4810 4000 3FF6 		LH	R1,WxMINE+2,,		:  and position
0110C4	C820 0020 		LHI	R2,CmSPAC		:  and value  (default = SP)
0110C8	4990 4000 3E1A 		CH	R9,MsPORT,,		: Is it my port?
0110CE	2133 			  JNFS	CxWNME			: No, not me
0110D0	C820 002A 		LHI	R2,2A			: Yes, Me!  Indicate with "*"
0110D4	D221 0000 	CxWNME	STB	R2,0,R1			: Store appropriate value
0110D8	4800 4000 3FF8 		LH	R0,WxPORT,,		: Get port mask
0110DE	4810 4000 3FFA 		LH	R1,WxPORT+2,,		:  and position
0110E4	0829 			LR	R2,R9			:  and value
0110E6	4160 4001 0558 		JAL	R6,OUTNUM,,		: Convert it for printing
0110EC	0889 			LR	R8,R9			: Copy for offset
0110EE	2781 			SIS	R8,1			: Decrement for 0 offset
0110F0	4C80 4000 3B60 		MH	R8,UIDSIZ,,		: Multiply by entry size
0110F6	4800 4000 3FFC 		LH	R0,WxUSER,,		: Get user mask
0110FC	4810 4000 3FFE 		LH	R1,WxUSER+2,,		:  and position
011102	E628 4000 3E68 		LA	R2,PORTSC,R8,		:  and address of SC
011108	4160 4001 11E8 		JAL	R6,MOUTSC,,	
01110E	4810 4000 4002 		LH	R1,WxSTAT+2,,		: Get address of status
011114	C800 004E 		LHI	R0,4E			: Assume NOISY
011118	7490 4000 3E64 		TBT	R9,NOISEY,,		: Until we check it
01111E	2133 			  JNFS	CxWNSY			: Yes, Noisy
011120	C800 0051 		LHI	R0,51			: No, Quiet
011124	D201 0000 	CxWNSY	STB	R0,0,R1			: Store "N/Q" factor
011128	C800 004C 		LHI	R0,4C			: Assume local (consat) echo
01112C	7490 4000 3E3C 		TBT	R9,ECHOME,,		: See who is echoing
011132	2133 			  JNFS	CxWLCL			: Not me, so say local to user
011134	C800 0052 		LHI	R0,52			: It's me, so say remote to user
011138	D201 0001 	CxWLCL	STB	R0,1,R1			: Store "L/R" factor
01113C	4800 4000 4004 		LH	R0,WxNODE,,		: Get NODE mask
011142	4810 4000 4006 		LH	R1,WxNODE+2,,		:  and position
011148	0829 			LR	R2,R9			:  and value
01114A	4822 4000 3DB8 		LH	R2,NFROM,R2,		:  from table
011150	4160 4001 0558 		JAL	R6,OUTNUM,,		: Convert it for printing
011156	4800 4000 4008 		LH	R0,WxHOST,,		: Get HOST mask
01115C	4810 4000 400A 		LH	R1,WxHOST+2,,		:  and position
011162	0829 			LR	R2,R9			:  and value
011164	4822 4000 3DD8 		LH	R2,HFROM,R2,		:  from table
01116A	4160 4001 0558 		JAL	R6,OUTNUM,,		: Convert it for printing
011170	4800 4000 400C 		LH	R0,WxCCT,,		: Get CCT mask
011176	4810 4000 400E 		LH	R1,WxCCT+2,,		:  and position
01117C	0829 			LR	R2,R9			:  and value
01117E	4822 4000 3D98 		LH	R2,CCTYPE,R2,		:  from table
011184	4160 4001 0558 		JAL	R6,OUTNUM,,		: Convert it for printing
01118A	4800 4000 4010 		LH	R0,WxTPC,,		: Get TPC mask
011190	4810 4000 4012 		LH	R1,WxTPC+2,,		:  and position
011196	0829 			LR	R2,R9			:  and value
011198	4822 4000 3D88 		LH	R2,TCLASS,R2,		:  from table
01119E	4160 4001 0558 		JAL	R6,OUTNUM,,		: Convert it for printing
0111A4	4820 4000 3E1A 		LH	R2,MsPORT,,		: Get my port
0111AA	E630 4000 3FBF 		LA	R3,SvWHAT,,		: and the right message
0111B0	4150 4001 008C 		JAL	R5,OCS,,		: then print it
0111B6	2691 		CxWNXT	AIS	R9,1			: Try next port
0111B8	C990 0010 		CHI	R9,MAXPRT		: Reached the limit?
0111BC	4320 FEEE 		JLE	CxWLOP			: No, check it
0111C0	4300 FC74 		J	MsNEXT			: And return
			
						
			: Utility routines: CSEVEN, TCRLF, MOUTSC
			
0111C4	C400 007F 	CSEVEN	NHI	R0,7F			: Only look at 7 bits
0111C8	C900 0060 		CHI	R0,60			: Check for lower-case range
0111CC	0214 			JLR	R4			: No, skip subtraction
0111CE	CB00 0020 		  SHI	R0,20			: Convert to upper case
0111D2	0304 			JR	R4			: Return
			
			
0111D4	4820 4000 3E1A 	TCRLF	LH	R2,MsPORT,,		: Get current port
0111DA	E630 4000 3C33 		LA	R3,MxCRLF,,		: Get message
0111E0	4150 4001 008C 		JAL	R5,OCS,,		: Print it
0111E6	030D 			JR	R13			: Return
			
			
			: MOUTSC - byte/string copy routine
			:
			:	R0 = ffff.ffff.szbr.rrrr
			:	R1 = pointer to buffer
			:	R2 = pointer to data to move
			:	JAL R6,MOUTSC
			:
0111E8	C400 FFFF 	MOUTSC	NHI	R0,0FFFF		: Check field width
0111EC	C900 0100 		CHI	R0,100			: If less than 1...
0111F0	0216 			  JLR	R6			:   nothing to do?
0111F2	0830 			LR	R3,R0			: Extract padd character
0111F4	C430 007F 		NHI	R3,7F			: (can be anything) SP = 20
0111F8	2133 			  JNFS	MOUTS0			: But must NOT be null
0111FA	C830 0020 		LHI	R3,20			: If so, make it a space
0111FE	D342 0000 	MOUTS0	LB	R4,0,R2			: Get bytes in string
011202	EC00 0008 		SRL	R0,08			: Normalize field width
011206	0904 			CR	R0,R4			: Do we have too many?
011208	2322 			  JLEFS	MOUTS1			: No, no change
01120A	0840 			LR	R4,R0			: Use the field width
01120C	2621 		MOUTS1	AIS	R2,1			: Adjust character pointer
01120E	D352 0000 		LB	R5,0,R2			: Get byte
011212	2132 			  JNFS	MOUTS2			: Non-null so keep going
011214	0853 			LR	R5,R3			: Oops! use filler instead
011216	D251 0000 	MOUTS2	STB	R5,0,R1			: Store byte
01121A	2611 			AIS	R1,1			: Adjust pointers (output)
01121C	2701 			SIS	R0,1			:  and counters (field)
01121E	2741 			SIS	R4,1			:  to suit (input)
011220	4220 FFE8 		JG	MOUTS1			: More? Yes, transfer them
011224	0904 			CR	R0,R4			: Anything left to fill?
011226	0326 			JLER	R6			: No, all done -- Return
011228	D231 0000 	MOUTS3	STB	R3,0,R1			: Add fill character
01122C	2611 			AIS	R1,1			: Adjust output pointer
01122E	2701 			SIS	R0,1			: Loop till all
011230	4220 FFF4 		JG	MOUTS3			:%  #