
EBUS02.J01                 E B U S  --  PDP-10 Base Code, Version 2.00                    8-Oct-87  Page    1
Err Source Ref. Address   value
    line   line

       1      1                               		TTL	'E B U S  --  PDP-10 Base Code, Version 2.00'
       2      2                               	
       3      3                               	*			***** ****  *   *  ****
       4      4                               	*			*     *   * *   * *
       5      5                               	*			****  ****  *   *  ***
       6      6                               	*			*     *   * *   *     *
       7      7                               	*			***** ****   ***  ****
       8      8                               	
       9      9                               	*************************************************************************
      10     10                               	**	                PROPRIETARY INFORMATION                        **
      11     11                               	**	                                                               **
      12     12                               	**	This  source code listing constitutes the proprietary pro-     **
      13     13                               	**	perty of TYMNET, Incorporated. The recipient, by receiving     **
      14     14                               	**	this program listing, agrees that neither this listing nor     **
      15     15                               	**	the   information  disclosed herein nor any  part  thereof     **
      16     16                               	**	shall be  reproduced or transferred to other documents  or     **
      17     17                               	**	used  or  disclosed to others for manufacturing or for any     **
      18     18                               	**	other   purpose except as specifically authorized in  wri-     **
      19     19                               	**	ting by  TYMNET, Incorporated.                                 **
      20     20                               	*************************************************************************
      21     21                               	
      22     22                               		OPT	A,B,-M,-I
      23     23                               	
      24     24 00000201                      	VERSION	EQU	$201			; VERSION NUMBER
      25     25 00000091                      	PRODID	EQU	$91			; product-ID
      26     26 00000000                      	DEBUG	EQU	0			; what to tell host when we come up
      27     27 00000100                      	MAXPORT	EQU	256			; maximum number of ports supported
      28     28 00000010                      	BFLSIZ	EQU	16			; bufferlet size (Power of 2!!)
      29     29 0000001B                      	ESC	EQU	$1B			; code used for escapes (in buffers)
      30     30 000000AC                      	YB_CODE	EQU	$AC			; code for Yellow-ball
      31     31                               	
      32     32                               	*	Assembly and Debugging Switches
      33     33 00000001                      	RTRACE	EQU	1			; Enable trace of PDP ring transfers
      34     34 00000000                      	BTRACE	EQU	0			; Enable trace of PDP BIO transfers
      35     35 00000001                      	ITRACE	EQU	1			; Enable trace of ISIS transfers
      36     36 00000000                      	CTRACE	EQU	0			; Enable trace of Buffer transfers
      37     37 00000001                      	TRACING	EQU	RTRACE!BTRACE!ITRACE!CTRACE	; Switch if ANY trace active
      38     38                               	
      39     39                               	
      40     40                               	*	Special (RESERVED) Register Declarations
      41     41 0000000C                      	Rp	EQU	A4			; Pointer to port-descriptor
      42     42 0000000D                      	Rs	EQU	A5			; Pointer to Start of ISIS Input Ring
      43     43 0000000E                      	Rd	EQU	A6			; Pointer to Start of ISIS Output Ring
      44     44 00000007                      	Cs	EQU	D7			; Cursor to position within Input Ring
      45     45 00000006                      	Cd	EQU	D6			; Cursor to position within Output Ring
      46     46                               	
      47     47                               	
      48     48                               	*	B A S I C   M E M O R Y   L A Y O U T
      49     49                               	
      50     50                               	*	"Magic" addresses for addressing the Engine
      51     51 FFFFF901                      	ENGINE	EQU	$FFFFF901		; address to interrupt the engineEBUS02.J01                 E B U S  --  PDP-10 Base Code, Version 2.00                    8-Oct-87  Page    2
Err Source Ref. Address   value
    line   line

      52     52                               	
      53     53 0000013C                      	ENGVECT	EQU	$13C			; Engine-interrupt Vector Location
      54     54                               	*		$900			  Bottom of stack
      55     55                               	*		$1000			  Top-of-Stack;  Beginnings of tables
      56     56                               	*					   and variable storage
      57     57 00004000                      	PATCHR	EQU	$4000			; PATCH AREA
      58     58                               	*		$4E00			  Beginning of Vector table
      59     59                               	*		$4F00			  Beginning of Bootstrap
      60     60                               	*		$5000			  Beginning of Code
      61     61                               	*		$7C00			  STARTES -- Diagnostic Routine
      62     62                               	*		$7D00			  CONWRT -- diagnostic routine
      63     63                               	*		$7E00			  READ diagnostic routine
      64     64 00008000                      	BUFER	EQU	$8000			; bufers
      65     65 0000F000                      	BUFEREND EQU	BUFER+$7000		; the end of the bufferlet area
      66     66 0000F000                      	ENDMEM	SET	BUFEREND		; the end of "memory"
      67     67                               	 if	TRACING
      68     68 00020000                      	STRACE	EQU	$20000			; beginning of trace area
      69     69 0003FFE0                      	ETRACE	EQU	$3FFE0			; end of trace area
      70     70 0003FFE0                      	ENDMEM	SET	ETRACE			; the end of "memory"
      71     71                               	 endc
      72     72                               	*		$????			
      73     73                               	
      74     74                               	*	Various Locations for doing Read and Write to PDP-10
      75     75 00D000B8                      	DSENS	EQU	$D000B8			; D0=0-BUSY, 1-NOT BUSY
      76     76 00D00138                      	DPER	EQU	$D00138			; D0=1-ERROR, DO AFTER READ
      77     77 00D001B8                      	DTMOT	EQU	$D001B8			; D0=1-TIMEOUT
      78     78 00D01038                      	DEXCO	EQU	$D01038			; RESET BOX SIGNAL ONLY
      79     79 00D010B8                      	DEXC1	EQU	$D010B8			; NEXT WRT TO PDP10 WRITE WRONG PARITY
      80     80                               	
      81     81                               	*	Locations for reading from PDP-10
      82     82 00D0403A                      	RD101	EQU	$D0403A
      83     83 00D0403C                      	RD104	EQU	$D0403C
      84     84 00D0403E                      	RD102	EQU	$D0403E
      85     85 00D04038                      	RD103	EQU	$D04038
      86     86                               	
      87     87                               	*	Locations for Writing to PDP-10
      88     88 00D0803A                      	WT101	EQU	$D0803A
      89     89 00D0803C                      	WT102	EQU	$D0803C
      90     90 00D0803E                      	WT103	EQU	$D0803E
      91     91 00D08038                      	WT104	EQU	$D08038
      92     92                               	
      93     93 00E00000                      	ESPACE	EQU	$E00000		; start of Engine memory
      94     94                               	*		$EFFFFF		  end of Engine memory
      95     95                               	
      96     96                               	*		$F00000		  start of MACSbug area
      97     97                               	*		$FFFFFF		  end of MACSbug areaEBUS02.J01                 E B U S  --  PDP-10 Base Code, Version 2.00                    8-Oct-87  Page    3
Err Source Ref. Address   value
    line   line

      99     99                               	
     100    100                               	*	Define data-structure for Port-Descriptor:
     101    101                               		OFFSET	0
     102    102 00000000                      	P_NUM	DS.B	1			; spare copy of port-number
     103    103 00000001                      	P_FLAGS	DS.B	1			; port status (flags)
     104    104 00000000                      	 PF_ACT: EQU	0			; port active
     105    105 00000001                      	 PF_ILI: EQU	1			; Port In Log-In State
     106    106 00000002                      	 PF_OBP: EQU	2			; Output Back-pressure applied (by ISIS)
     107    107 00000003                      	 PF_IBP: EQU	3			; Input Back-pressure applied (by us)
     108    108 00000004                      	 PF_HBP: EQU	4			; Input Back-pressure applied (by Host)
     109    109 00000005                      	 PF_BKO: EQU	5			; Block-Output active
     110    110 00000006                      	 PF_BKI: EQU	6			; Block-Input active
     111    111 00000007                      	 PF_BFD: EQU	7			; Block FilleD
     112    112                               	
     113    113 00000002                      	XMITLMT	DS.B	1			; transmit limit
     114    114 00000003                      	IBRATE	DS.B	1			; Input baud-rate
     115    115 00000003                      	AUXKEY	EQU	IBRATE			; hold AUX-key here too
     116    116                               	
     117    117 00000004                      	BO_TAR	DS.L	1			; Block-output -- (PDP) block start addr.
     118    118 00000008                      	BO_BYT	DS.W	1			; Block-Output -- byte position within word
     119    119 0000000A                      	BO_TCN	DS.W	1			; Block-output -- output count (total left)
     120    120                               	
     121    121 0000000C                      	BI_TIM	DS.L	1			; Block-input -- time (FASTC) last activity
     122    122 00000010                      	BI_TAR	DS.L	1			; Block-input -- (PDP) block start address
     123    123 00000014                      	BI_TCN	DS.W	1			; Block-input -- input count (total)
     124    124 00000016                      	BI_LCN	DS.W	1			; Block-input -- input count (so far)
     125    125 00000018                      	BI_BYT	DS.W	1			; Block-input -- pos. within current word
     126    126                               	
     127    127 0000001A                      	BB	DS.W	1			; bufferlet-begin
     128    128 0000001C                      	BE	DS.W	1			; bufferlet-end
     129    129 0000001E                      	BCT	DS.W	1			; count of characters
     130    130 00000020                      	PD_SIZ	DS.W	0			; size of descriptorEBUS02.J01                 E B U S  --  PDP-10 Base Code, Version 2.00                    8-Oct-87  Page    4
Err Source Ref. Address   value
    line   line

     132    132                               	
     133    133                               	***	Define some useful Macros
     134    134                               	
     135    135                               	*	Macro to Cause VCRASH with crash-code VAL
     136    136                               	CRASH	MACRO	VAL
     137    137                               		MOVE.B	#VAL,CODCASH		; set crash-code
     138    138                               		BRA	VCRASH			; go do it
     139    139                               		ENDM
     140    140                               	
     141    141                               	*	Macro to Cause (FATAL!) BCRASH with crash-code VAL
     142    142                               	FCRASH	MACRO	VAL
     143    143                               		MOVE.B	#VAL,CODCASH		; set crash-code
     144    144                               		BSR.\0	BCRASH			; go do it
     145    145                               		ENDM
     146    146                               	
     147    147                               	*	Macro to PUSH a register onto the stack
     148    148                               	PUSH	MACRO	REG
     149    149                               		MOVE.L	REG,-(SP)
     150    150                               		ENDM
     151    151                               	
     152    152                               	*	Macro to POP a register from the stack
     153    153                               	POP	MACRO	REG
     154    154                               		MOVE.L	(SP)+,REG
     155    155                               		ENDM
     156    156                               	
     157    157                               	*	Macro to PUSH multiple registers onto the stack
     158    158                               	PUSHM	MACRO	REGS
     159    159                               		MOVEM.L	REGS,-(SP)
     160    160                               		ENDM
     161    161                               	
     162    162                               	*	Macro to POP multiple registers from the stack
     163    163                               	POPM	MACRO	REGS
     164    164                               		MOVEM.L	(SP)+,REGS
     165    165                               		ENDM
     166    166                               	
     167    167                               	*	MACRO to construct a Vector-table Entry
     168    168                               	VENTRY	MACRO	WHERE,OUR
     169    169                               		DC.W	WHERE,OUR,0,0
     170    170                               		ENDM
     171    171                               	
     172    172                               	*	Macro to generate a text-string with leading count-byte
     173    173                               	TEXTC	MACRO	STRING
     174    174                               		LOCAL	BGN,CNT
     175    175                               	BGN	DC.B	CNT,STRING
     176    176                               	CNT	EQU	*-BGN-1
     177    177                               		ENDM



     179    179                               	        ORG	$900			; where we actually beginEBUS02.J01                 E B U S  --  PDP-10 Base Code, Version 2.00                    8-Oct-87  Page    5
Err Source Ref. Address   value
    line   line




     181    181                               		TTL	'E B U S  --  PDP-10 Base Code,		V A R I A B L E S'EBUS02.J01                 E B U S  --  PDP-10 Base Code,		V A R I A B L E S              8-Oct-87  Page    6
Err Source Ref. Address   value
    line   line

     183    183                               	
     184    184 00000900                      		DS.L	490			: The Bottom of the Stack
     185    185 000010A8                      		DS.L	0
     186    186                               		ORG	$1000
     187    187 00001000                      	STKTOP	DS.L	0			; the end (Top) of the stack
     188    188                               	
     189    189                               	 if	TRACING
     190    190 00001000 0002 0000            	.TRACE	DC.L	STRACE			; Current Trace Pointer
     191    191                               	 endc
     192    192                               	
     193    193 00001004 0000 0000            	CODCASH	DC.L	0			; leave as Long, even if used as Byte
     194    194 00001008 0000 0000            	PCCASH	DC.L	0			; save PC here on crash
     195    195 0000100C 0000 0000            	CASHW	DC.L	0			; information about message causing crash
     196    196                               	
     197    197                               	 if	TRACING
     198    198 00001010 FFFF                 	TR_PORT	DC.W	-1			; Trace ONLY this port if not <0
     199    199                               	 endc
     200    200                               	
     201    201                               	*	The following data is read from Engine and translated for subsequent
     202    202                               	*	references by the base code.
     203    203 00001012                      	ISTOME	DS.L	1			; Address to get info from ISIS
     204    204 00001016                      	METOIS	DS.L	1			; Address to pass info to ISIS
     205    205 0000101A 0000 0000            	SLTOME	DC.L	0			; Address to get parameters from slot
     206    206 0000101E 0000 0000            	METOSL	DC.L	0			; Address to put crash info into slot
     207    207 00001022 0000 0000            	.MDUMP	DC.L	0			; Address to dump memory to
     208    208 00001026 0000 0000            	.MDSIZ	DC.L	0			; number of bytes to dump (0=none)
     209    209 0000102A                      	.SYNC	DS.L	1			; Address to perform slot-synchronization
     210    210 0000102E                      	ORING	DS.L	1			; Dispatcher Output Ring Start Address
     211    211 00001032                      	IRING	DS.L	1			; Dispatcher Input Ring Start Address
     212    212 00001036                      	.SLOWC	DS.L	1			; Address of SLOWC Time
     213    213 0000103A                      	.FASTC	DS.L	1			; Address of FASTC
     214    214 0000103E                      	IRSIZE	DS.W	1			; record ISIS input-ring size here
     215    215 00001040                      	ORSIZE	DS.W	1			; record ISIS output-ring size here
     216    216                               	
     217    217                               	
     218    218 00001042 0000                 	P10DAH	DC.W	0			; High data
     219    219 00001044 0000                 	P10DAL	DC.W	0			; low data
     220    220 00001046 00                   	P10DLL	DC.B	0			; high address | low data (4-bits each)
     221    221 00001048 0000                 	P10ADR	DC.W	0			; low (15-bit) read/write addr. in PDP
     222    222                               	
     223    223                          	
     224    224 0000104A                      	ZERO	DS.L	0			; beginning of area to zero-out on init.
     225    225                               	
     226    226                               	
     227    227 0000104A                      	HOSTN	DS.W	1			; Host Number
     228    228 0000104C                      	HOSTP	DS.W	1			; Number of Host Ports
     229    229 0000104E                      	HSTAT	DS.W	1			; Host status | Host key
     230    230                               						; 0=ANSW 1=DOWN 2=SHUT 3=GONE
     231    231 00001050                      	HOSTTO	DS.W	1			; Host-specified timeout (for Key test)
     232    232 00001052                      	TOHOST	DS.W	1			; Current Host-Key timeoutEBUS02.J01                 E B U S  --  PDP-10 Base Code,		V A R I A B L E S              8-Oct-87  Page    7
Err Source Ref. Address   value
    line   line

     233    233 00001054                      	HVERNO	DS.W	1			; Host version number
     234    234                               	
     235    235 00001056                      	MXPORT	DS.W	1			; maximum number of active ports possible
     236    236 00001058                      	NPORTS	DS.W	1			; current number of active ports
     237    237                               	
     238    238 0000105A                      	AUXQ	DS.W	1			; AUX circuit key (= requesting port number)
     239    239 0000105C                      	AUXTIM	DS.L	1			; timeout for AUX circuit request
     240    240 00001060                      	AUXX	DS.W	1			; index into AUXC
     241    241 00001062                      	AUXC	DS.B	40			; AUX logon-string
     242    242                               	
     243    243                               	
     244    244 0000108A                      	TYPBYT	DS.B	1			; message type
     245    245 0000108B                      	HTDWN	DS.B	1			; flag -- host down if NE 0
     246    246                               	
     247    247 0000108C                      	PDPORP	DS.W	1			; start address of PDP's output ring
     248    248 0000108E                      	PDPOSZ	DS.W	1			; Size of PDP's output ring
     249    249 00001090                      	PDPOFC	DS.W	1			; PDP output ring Fill Cursor
     250    250 00001092                      	PDPOEC	DS.W	1			; our PDP output ring Empty Cursor
     251    251 00001094                      	PDPIRP	DS.W	1			; start address of PDP's input ring
     252    252 00001096                      	PDPISZ	DS.W	1			; Size of PDP's input ring
     253    253 00001098                      	PDPIEC	DS.W	1			; PDP input ring Empty Cursor
     254    254 0000109A                      	PDPIFC	DS.W	1			; our PDP input ring Fill Cursor
     255    255 0000109C                      	INRGSP	DS.W	1			; # of bytes of space in PDP input ring
     256    256 0000109E                      	INTYBT	DS.W	1			; Type byte of MSG input from ISIS
     257    257 000010A0                      	PORTNO	DS.W	1			; Current Port number
     258    258 000010A2                      	NORNODE	DS.W	1			; normal login origination node
     259    259 000010A4                      	NORHOST	DS.W	1			; normal login origination host
     260    260 000010A6                      	NORPORT	DS.W	1			; normal login origination port
     261    261 000010A8                      	DAT	DS.L	0			; DAT1--4 are both LONG, and single Bytes
     262    262 000010A8                      	DAT1	DS.B	1			; for message type
     263    263 000010A9                      	DAT2	DS.B	1			; for port number
     264    264 000010AA                      	DAT3	DS.B	1
     265    265 000010AB                      	DAT4	DS.B	1
     266    266 000010AC                      	DAT5	DS.B	48			; extra space available here
     267    267 000010DC                      	NCCT	DS.B	1			; save CCT from needle here
     268    268 000010DD                      	NSIZ	DS.B	1			; save username size from needle here
     269    269 000010DE 00                   	BLK	DC.B	0			; flag: non BIO usage if = 0
     270    270 000010E0                      	SLOWC	DS.L	1			; Clock within Engine
     271    271 000010E4                      	HTM	DS.L	1			; Time of last Open/Shut MSG (FASTC)
     272    272 000010E8                      	LFASTC	DS.L	1			; Time of last 1/2 sec logic
     273    273                               	
     274    274 000010EC                      	LASCOU	DS.W	1			; count of good keys
     275    275                               	
     276    276 000010EE                      	BKPR	DS.W	1			; # of bytes before applying back-pressure
     277    277 000010F0                      	IRRN	DS.W	1			; ISIS-input "throttle"
     278    278 000010F2                      	ORRN	DS.W	1			; host-output "throttle"
     279    279                               	
     280    280 000010F4                      	.BFLTS	DS.L	1			; pointer to bufferlet area
     281    281 000010F8                      	NBFLTS	DS.W	1			; number of bufferlets
     282    282 000010FA                      	R_TANK	DS.W	1			; bufferlet reserve tank
     283    283                               	EBUS02.J01                 E B U S  --  PDP-10 Base Code,		V A R I A B L E S              8-Oct-87  Page    8
Err Source Ref. Address   value
    line   line

     284    284 000010FC                      	BLKFREE	DS.W	1			; pointer to block-IO free-list
     285    285 000010FE                      	BKIHEAD	DS.W	1			; block-input list head (pointer or null)
     286    286 00001100                      	BKOHEAD	DS.W	1			; block-output list head (pointer or null)
     287    287 00001102                      	BUFHEAD	DS.W	1			; Buffer list head (pointer or null)
     288    288 00001104                      	SAVE1	DS.W	1
     289    289 00001106                      	TMOC	DS.B	1
     290    290 00001107                      	PFULL	DS.B	1			; flag for ports full (if non-zero)
     291    291 00001108                      	DIAG	DS.B	1			; flag for diagnostic in progress
     292    292                               	
     293    293 0000110A                      	FREEBLK	DS.L	2*MAXPORT		; Block-IO Free-list storage
     294    294                               	
     295    295 0000190A                      	PORTS	DS.B	PD_SIZ*MAXPORT		; storage for port-descriptors
     296    296                               	
     297    297                               	
     298    298 0000390A                      	ENDZERO	DS.L	0			; end of area to zero-out on init.



     300    300                               		TTL	'E B U S  --  PDP-10 Base Code,		T A B L E S'EBUS02.J01                 E B U S  --  PDP-10 Base Code,		T A B L E S                    8-Oct-87  Page    9
Err Source Ref. Address   value
    line   line

     302    302                               	
     303    303                               	*	Table of Input Baud Rates in CCT order
     304    304 0000390A 0502 0202            	CCTBD	DC.B	5,2,2,2,2,1,1,1		; GET BAUD RATE FROM CCT
     304    305 0000390E 0201 0101            	
     305    306 00003912 0607 0005            		DC.B	6,7,0,5,5,5,5,0
     305    307 00003916 0505 0500            	
     306    308 0000391A 0A05 050B            		DC.B	10,5,5,11,12,5,5,5
     306    309 0000391E 0C05 0505            	
     307    310 00003922 0505 0505            		DC.B	5,5,5,5,5,5,5,5
     307    311 00003926 0505 0505            	



     309    313                               		TTL	'E B U S  --  PDP-10 Base Code,		B O O T S T R A P'EBUS02.J01                 E B U S  --  PDP-10 Base Code,		B O O T S T R A P              8-Oct-87  Page   10
Err Source Ref. Address   value
    line   line

     311    315                               		ORG	$4E00
     312    316                               	
     313    317                               	*	VECTOR TABLE:
     314    318                               	*	Each entry is 2 shorts and a long (total 8 bytes):
     315    319                               	*	0 -	vector address (W)
     316    320                               	*	2 -	our handler address (W)
     317    321                               	*	4 -	original contents of vector (L)
     318    322                               	
     319    323 00004E00                      	VECTOR	VENTRY	ENGVECT,BOBCODE		; Engine interrupt
     320    326 00004E08                      		VENTRY	$8,BUSERR		; Buss Error
     321    329 00004E10                      		VENTRY	$C,ILLINS		; Illegal Instruction
     322    332 00004E18                      		VENTRY	$10,ADRERR		; Address Error
     323    335 00004E20                      		VENTRY	0,0			; null entry terminates list
     324    338                               	
     325    339                               		ORG	$4F00
     326    340                               	
     327    341                               	
     328    342                               	
     329    343                               	*	===== ========= ==== ==== ======= ==========
     330    344                               	*	Start Execution here upon machine reload!!!!
     331    345                               	*	===== ========= ==== ==== ======= ==========
     332    346 00004F00 21C9 1012            	ENTRY	MOVE.L	A1,ISTOME		; address of ISIS-to-us message area
     333    347 00004F04 21CA 1016            		MOVE.L	A2,METOIS		; address of us-to-ISIS message area
     334    348 00004F08 4280                 		CLR.L	D0			; prepare to divert some traps
     335    349 00004F0A 41F8 4E00            		LEA	VECTOR,A0		;	and interrupts
     336    350 00004F0E 3258                 	ENTRY1	MOVE.W	(A0)+,A1		; address of vector entry
     337    351 00004F10 3018                 		MOVE.W	(A0)+,D0		; our handler
     338    352 00004F12 6706                 		BEQ	ENTRY2			; null entry terminates list
     339    353 00004F14 20D1                 		MOVE.L	(A1),(A0)+		; else save current contents
     340    354 00004F16 2280                 		MOVE.L	D0,(A1)			; ...and put our handler address there
     341    355 00004F18 60F4                 		BRA	ENTRY1			; continue loop
     342    356                               	
     343    357 00004F1A 4238 10DE            	ENTRY2	CLR.B	BLK			; insure not expecting BIO
     344    358 00004F1E 24BC 0000 0002       		MOVE.L	#2,(A2)
     345    359 00004F24                      		POPM	D0-D7/A0-A6
     346    361 00004F28 612C                 		BSR	INTRPT			; interrupt engine
     347    362 00004F2A 4E72 2000            		STOP	#$2000			; Halt, Enable Interrupts
     348    363                               	
     349    364                               	
     350    365                               	
     351    366                               	*	Here on interrupt from engine
     352    367 00004F2E 46FC 2700            	BOBCODE	MOVE	#$2700,SR		; Disable Interrupts
     353    368 00004F32                      		PUSHM	D0-D7/A0-A6
     354    370 00004F36 2078 1012            		MOVEA.L	ISTOME,A0		; address of ISIS-to-us message area
     355    371 00004F3A 3010                 		MOVE.W	(A0),D0			; get high HW from there
     356    372 00004F3C 0240 0F00            		ANDI.W	#$0F00,D0		; examining only second nibble
     357    373 00004F40 0C40 0400            		CMPI.W	#$0400,D0
     358    374 00004F44 6748                 		BEQ	GETIOWA			; 4 is what we expect, and is OK
     359    375 00004F46 0C40 0500            		CMPI.W	#$0500,D0
     360    376 00004F4A 6618                 		BNE	FFCRA			; anything but 4 or 5 is reason to crashEBUS02.J01                 E B U S  --  PDP-10 Base Code,		B O O T S T R A P              8-Oct-87  Page   11
Err Source Ref. Address   value
    line   line

     361    377 00004F4C                      		POPM	D0-D7/A0-A6
     362    379 00004F50 46FC 2000            		MOVE	#$2000,SR		; Enable Interrupts
     363    380 00004F54 4E73                 		RTE				; got 5...just return
     364    381                               	
     365    382                               	*	Interrupt the Engine
     366    383 00004F56 11FC 00C0 F901       	INTRPT	MOVE.B	#$0C0,ENGINE		; Interrupt ENGINE
     367    384 00004F5C 11FC 00C1 F901       		MOVE.B	#$0C1,ENGINE
     368    385 00004F62 4E75                 		RTS
     369    386                               	
     370    387 00004F64 11FC 00EF 1004       	FFCRA	MOVE.B	#$EF,CODCASH		: value in case Fatal Crash
     371    388 00004F6A 0C40 0300            		CMPI.W	#$0300,D0		; additional check
     372    389 00004F6E 6600 0232            		BNE.L	BCRASH			; other than 3 causes us to crash (FATAL)
     373    390 00004F72 11FC 00EC 1004       		MOVE.B	#$EC,CODCASH		; else set reason
     374    391 00004F78 6100 01D4            		BSR.L	REGDMP			; and dump our registers
     375    392 00004F7C 6100 0776            		BSR.L	HCRASH			; then crash the host
     376    393 00004F80 11FC 0001 108B       		MOVE.B	#1,HTDWN		; set host down
     377    394 00004F86                      	        POPM	D0-D7/A0-A6
     378    396 00004F8A 4E72 2000            		STOP	#$2000			; Halt, Enable Interrupts
     379    397                               	
     380    398 00004F8E 2010                 	GETIOWA	MOVE.L	(A0),D0			; get ISIS-to-us message
     381    399 00004F90 0280 000F FFFF       		ANDI.L	#$000FFFFF,D0
     382    400 00004F96 0080 00E0 0000       		ORI.L	#ESPACE,D0		; translate for our address-space
     383    401 00004F9C 21C0 101A            		MOVE.L	D0,SLTOME		; address of slot parameters
     384    402 00004FA0 21C0 101E            		MOVE.L	D0,METOSL		; same as Slot-to-me address
     385    403 00004FA4 2078 1016            		MOVE.L	METOIS,A0		; get us-to-ISIS address
     386    404 00004FA8 20BC 0000 0004       		MOVE.L	#4,(A0)			; tell ISIS "4"
     387    405 00004FAE                      		POPM	D0-D7/A0-A6		; restore registers
     388    407                               	
     389    408 00004FB2 61A2                 		BSR	INTRPT			; interrupt engine
     390    409 00004FB4 46FC 2000            		MOVE	#$2000,SR		; Enable Interrupts
     391    410 00004FB8 6046                 		BRA	INITIAL			; go initialize
     392    411                               	
     393    412                               		ORG	$5000
     394    413                               	
     395    414                               	
     396    415                               	*		I N I T I A L I Z A T I O N
     397    416                               	
     398    417 00005000 4FF8 1000            	INITIAL	LEA	STKTOP,SP		; Set up the stack pointer
     399    418                               	
     400    419                               	*	Zero out some memory
     401    420 00005004 41F8 104A            		LEA	ZERO,A0
     402    421 00005008 303C 28C0            		MOVE.W	#ENDZERO-ZERO,D0
     403    422 0000500C 4258                 	INIT0	CLR.W	(A0)+
     404    423 0000500E 5540                 		SUB.W	#2,D0
     405    424 00005010 66FA                 		BNE	INIT0
     406    425                               	
     407    426                               	
     408    427                               	*	Get parameters from ISIS
     409    428 00005012 2078 101A            		MOVE.L	SLTOME,A0		; pointer to slot parameters
     410    429 00005016 2018                 		MOVE.L	(A0)+,D0
     411    430 00005018 0080 00E0 0000       		OR.L	#ESPACE,D0EBUS02.J01                 E B U S  --  PDP-10 Base Code,		B O O T S T R A P              8-Oct-87  Page   12
Err Source Ref. Address   value
    line   line

     412    431 0000501E 21C0 102E            		MOVE.L	D0,ORING
     413    432 00005022 31D8 1040            		MOVE.W	(A0)+,ORSIZE
     414    433 00005026 2018                 		MOVE.L	(A0)+,D0
     415    434 00005028 0080 00E0 0000       		OR.L	#ESPACE,D0
     416    435 0000502E 21C0 1032            		MOVE.L	D0,IRING
     417    436 00005032 31D8 103E            		MOVE.W	(A0)+,IRSIZE
     418    437 00005036 2018                 		MOVE.L	(A0)+,D0
     419    438 00005038 0080 00E0 0000       		OR.L	#ESPACE,D0
     420    439 0000503E 21C0 103A            		MOVE.L	D0,.FASTC
     421    440 00005042 2240                 		MOVE.L	D0,A1
     422    441 00005044 21D1 10E8            		MOVE.L	(A1),LFASTC		; initialize LFASTC to now
     423    442 00005048 2018                 		MOVE.L	(A0)+,D0
     424    443 0000504A 0080 00E0 0000       		OR.L	#ESPACE,D0
     425    444 00005050 21C0 1036            		MOVE.L	D0,.SLOWC
     426    445 00005054 2018                 		MOVE.L	(A0)+,D0
     427    446 00005056 0080 00E0 0000       		OR.L	#ESPACE,D0
     428    447 0000505C 21C0 102A            		MOVE.L	D0,.SYNC		; used for Sync with Slot code
     429    448 00005060 2018                 		MOVE.L	(A0)+,D0
     430    449 00005062 0080 00E0 0000       		OR.L	#ESPACE,D0
     431    450 00005068 21C0 101E            		MOVE.L	D0,METOSL		; prefered place to dump registers
     432    451 0000506C 2018                 		MOVE.L	(A0)+,D0
     433    452 0000506E 0080 00E0 0000       		OR.L	#ESPACE,D0
     434    453 00005074 21C0 1022            		MOVE.L	D0,.MDUMP		; prefered place to dump memory
     435    454 00005078 2018                 		MOVE.L	(A0)+,D0
     436    455 0000507A 223C 0003 FFE0       		MOVE.L	#ENDMEM,D1		: end of "memory"
     437    456 00005080 B081                 		CMP.L	D1,D0			; use minimum
     438    457 00005082 6F02                 		BLE	INIT1
     439    458 00005084 2001                 		MOVE.L	D1,D0
     440    459 00005086 21C0 1026            	INIT1	MOVE.L	D0,.MDSIZ		; size of memory dump area
     441    460 0000508A 30FC 0201            		MOVE.W	#VERSION,(A0)+		; return Version number
     442    461 0000508E 2A78 1032            		MOVE.L	IRING,Rs		; Input Ring address into Rs
     443    462 00005092 2C78 102E            		MOVE.L	ORING,Rd		; Output Ring address into Rd
     444    463                               	
     445    464                               	*	Initialize Bufferlet Storage
     446    465 00005096 41F9 0000 8000       		LEA	BUFER,A0		; pointer to start of area
     447    466 0000509C 21C8 10F4            		MOVE.L	A0,.BFLTS		; Record pointer to start of area
     448    467 000050A0 4240                 		CLR.W	D0			; record cursors here
     449    468 000050A2 0640 0010            	INIT2	ADD.W	#BFLSIZ,D0		; advance cursor
     450    469 000050A6 41E8 0010            		LEA	BFLSIZ(A0),A0		; pointer to next buferlet
     451    470 000050AA 3140 FFF0            		MOVE.W	D0,-BFLSIZ(A0)		; set last forward-chain pointer
     452    471 000050AE 5278 10F8            		ADD.W	#1,NBFLTS		; keep count of number of bufferlets
     453    472 000050B2 B1FC 0000 F000       		CMPA.L	#BUFEREND,A0		; done yet?
     454    473 000050B8 6DE8                 		BLT	INIT2			; no...continue
     455    474 000050BA 4250                 		CLR.W	(A0)			; last one signaled by 0
     456    475                               	
     457    476 000050BC 11FC 0003 104E       		MOVE.B	#3,HSTAT		; Set Host status = Gone
     458    477 000050C2 11FC 0001 108B       		MOVE.B	#1,HTDWN		; set Host Down
     459    478 000050C8 31FC FFFF 1060       		MOVE.W	#-1,AUXX		; Enable AUX circuit requests
     460    479 000050CE 50F8 1004            		ST	CODCASH			; Initialize Crash-Code to FF
     461    480 000050D2 31FC 00C8 10EE       		MOVE.W	#200,BKPR		; value to apply back-pressure
     462    481                               	 if	TRACINGEBUS02.J01                 E B U S  --  PDP-10 Base Code,		B O O T S T R A P              8-Oct-87  Page   13
Err Source Ref. Address   value
    line   line

     463    482 000050D8 21FC 0002 0000 1000  		MOVE.L	#STRACE,.TRACE		; PDP-10 Trace Start Address
     464    483                               	 endc
     465    484                               	
     466    485 000050E0 41F8 110A            		LEA	FREEBLK,A0
     467    486 000050E4 31C8 10FC            		MOVE.W	A0,BLKFREE		; initialize Block-IO free-list
     468    487 000050E8 323C 0200            		MOVE.W	#MAXPORT*2,D1		; one list for input and output
     469    488 000050EC 5848                 	BLKMAP	ADD.W	#4,A0			; point to next
     470    489 000050EE 3148 FFFC            		MOVE.W	A0,-4(A0)		; point last at this
     471    490 000050F2 5341                 		SUB.W	#1,D1
     472    491 000050F4 6EF6                 		BGT	BLKMAP
     473    492 000050F6 4268 FFFC            		CLR.W	-4(A0)			; last has null next
     474    493                               	
     475    494 000050FA 303C 0100            		MOVE.W	#MAXPORT,D0
     476    495 000050FE 49F8 190A            		LEA	PORTS,Rp		; initialize port descriptors
     477    496 00005102 4241                 		CLR.W	D1			; we'll be counting port number here
     478    497 00005104 197C 009D 0002       	PUTPORT	MOVE.B	#157,XMITLMT(Rp)	; transmit-limit
     479    498 0000510A 1941 0000            		MOVE.B	D1,P_NUM(Rp)		; set port number
     480    499 0000510E 5241                 		ADD.W	#1,D1			; advance port number
     481    500 00005110 D8FC 0020            		ADDA.W	#PD_SIZ,Rp		; advance to next port
     482    501 00005114 5340                 		SUB.W	#1,D0
     483    502 00005116 66EC                 		BNE	PUTPORT
     484    503                               	
     485    504 00005118 4A79 00D0 1038       		TST.W	DEXCO			; Reset EBUS
     486    505 0000511E 6100 0944            		BSR.L	DOKEY			; see if host is already up
     487    506 00005122 6600 0A96            		BNE.L	EXEC			; no
     488    507 00005126 06B8 0000 012C 10E8  		ADD.L	#300,LFASTC		; yes...do next host check in 1/2 second
     489    508 0000512E 6100 04EC            		BSR.L	RDPDPRP			: read PDP's Ring-parameters
     490    509 00005132 31FC 0300 10A8       		MOVE.W	#$300+DEBUG,DAT1	; set "RESET INTERFACE"
     491    510 00005138 31FC 0201 10AA       		MOVE.W	#VERSION,DAT3
     492    511 0000513E 6100 065E            		BSR.L	WAITDAT			; and send it
     493    512 00005142 6100 065A            		BSR.L	WAITDAT			;  ...twice...just in case
     494    513 00005146 6100 0690            		BSR.L	PUTIFC			; let PDP know it's there
     495    514 0000514A 6000 0A6E            		BRA.L	EXEC			; then go begin



     497    516                               		TTL	'E B U S  --  PDP-10 Base Code,		C R A S H E S'EBUS02.J01                 E B U S  --  PDP-10 Base Code,		C R A S H E S                  8-Oct-87  Page   14
Err Source Ref. Address   value
    line   line

     499    518                               	*	CRASH Routines for the Base
     500    519                               	*	Dump CODCASH, PCCASH, and all registers to slot's REGDMP area
     501    520                               	*	...if we know where it is.  NO REGISTERS AFFLICTED
     502    521 0000514E 4AB8 101E            	REGDMP	TST.L	METOSL			; do we have a place to dump to?
     503    522 00005152 6730                 		BEQ	REGDMPX			; no...just exit
     504    523 00005154                      		PUSH	A0			; yes...save A0
     505    525 00005156 2078 101E            		MOVE.L	METOSL,A0		; address to dump to
     506    526 0000515A 20F8 1004            		MOVE.L	CODCASH,(A0)+		; dump crash reason
     507    527 0000515E 20F8 1008            		MOVE.L	PCCASH,(A0)+		; PC saved
     508    528 00005162 20C0                 		MOVE.L	D0,(A0)+		; successive D-registers
     509    529 00005164 20C1                 		MOVE.L	D1,(A0)+
     510    530 00005166 20C2                 		MOVE.L	D2,(A0)+
     511    531 00005168 20C3                 		MOVE.L	D3,(A0)+
     512    532 0000516A 20C4                 		MOVE.L	D4,(A0)+
     513    533 0000516C 20C5                 		MOVE.L	D5,(A0)+
     514    534 0000516E 20C6                 		MOVE.L	D6,(A0)+
     515    535 00005170 20C7                 		MOVE.L	D7,(A0)+
     516    536 00005172 20D7                 		MOVE.L	(SP),(A0)+		; Saved value of A0
     517    537 00005174 20C9                 		MOVE.L	A1,(A0)+		; successive A-registers
     518    538 00005176 20CA                 		MOVE.L	A2,(A0)+
     519    539 00005178 20CB                 		MOVE.L	A3,(A0)+
     520    540 0000517A 20CB                 		MOVE.L	A3,(A0)+
     521    541 0000517C 20CD                 		MOVE.L	A5,(A0)+
     522    542 0000517E 20CE                 		MOVE.L	A6,(A0)+
     523    543 00005180 20CF                 		MOVE.L	SP,(A0)+
     524    544 00005182                      		POP	A0			; restore A0
     525    546 00005184 4E75                 	REGDMPX	RTS				; exit
     526    547                               	
     527    548                               	
     528    549                               	*	Possible dump 68K memory into Engine memory (memory-dump area)
     529    550 00005186 2038 1026            	MEMDMP	MOVE.L	.MDSIZ,D0		; should we do a memory-dump?
     530    551 0000518A 6FF8                 		BLE	REGDMPX			; no
     531    552 0000518C 207C 0000 0000       		MOVEA.L	#0,A0			; yes...our source
     532    553 00005192 2078 1022            		MOVEA.L	.MDUMP,A0		; Engine destination
     533    554 00005196 32D8                 	MEMDMP1	MOVE.W	(A0)+,(A1)+		; dump memory
     534    555 00005198 5580                 		SUBQ.L	#2,D0			; done yet?
     535    556 0000519A 6EFA                 		BGT	MEMDMP1			; not yet
     536    557 0000519C 42B8 1026            		CLR.L	.MDSIZ			; insure no more crashes saved
     537    558                               						;  'til told otherwise
     538    559 000051A0 4E75                 		RTS				; and exit
     539    560                               	
     540    561                               	
     541    562                               	*	CRASH ROUTINE
     542    563                               	*	Calling Sequence:	BSR	BCRASH
     543    564                               	*	FATAL CRASH:	NO RETURN!!!!!!
     544    565 000051A2 21DF 1008            	BCRASH	MOVE.L	(SP)+,PCCASH		; Location that called this routine
     545    566 000051A6 61A6                 		BSR	REGDMP			; dump registers
     546    567 000051A8 6100 054A            		BSR.L	HCRASH			; crash the host
     547    568 000051AC 11FC 0001 108B       		MOVE.B	#1,HTDWN		; ...and record it as down
     548    569 000051B2 61D2                 		BSR	MEMDMP			; try to do a memory-dumpEBUS02.J01                 E B U S  --  PDP-10 Base Code,		C R A S H E S                  8-Oct-87  Page   15
Err Source Ref. Address   value
    line   line

     549    570 000051B4 41F8 4E08            		LEA	VECTOR+8,A0		; restore traps (not Engine interrupt)
     550    571 000051B8 3258                 	BCRASH1	MOVE.W	(A0)+,A1		; address of vector entry
     551    572 000051BA 4A58                 		TST.W	(A0)+
     552    573 000051BC 6704                 		BEQ	BCRASH2			; null entry terminates list
     553    574 000051BE 2298                 		MOVE.L	(A0)+,(A1)		; else restore previous contents
     554    575 000051C0 60F6                 		BRA	BCRASH1			; continue loop
     555    576                               	
     556    577 000051C2 4280                 	BCRASH2	CLR.L	D0
     557    578 000051C4 3038 1004            		MOVE.W	CODCASH,D0		; left byte is crash-reason
     558    579 000051C8 103C 0003            		MOVE.B	#3,D0			; 3 in right byte means Base crashes
     559    580 000051CC 2078 1016            		MOVE.L	METOIS,A0		; address of Base-to-Engine MSG area
     560    581 000051D0 2080                 		MOVE.L	D0,(A0)			; move it to Base-to-Engine MSG area
     561    582 000051D2 6100 FD82            		BSR	INTRPT			; interrupt engine
     562    583 000051D6 4E72 2000            		STOP	#$2000			; and HALT! (with Interrupts Enabled)
     563    584                               	
     564    585                               	*	ISIS MSG-type FATAL CRASH!!
     565    586 000051DA 31F8 10A0 100C       	ISMGER	MOVE.W	PORTNO,CASHW		; save port, message-type
     566    587 000051E0 11F8 109F 100E       		MOVE.B	INTYBT+1,CASHW+2
     567    588 000051E6                      		FCRASH	$50			; Fatal crash, no return!
     568    591                               	
     569    592                               	*	BUFFER Fatal Crash..."split" (non-existant) escaped character
     570    593 000051EE                      	BAD_ESC	FCRASH	$ED			; crash if escape not followed
     571    596                               	
     572    597                               	*	BUFFER Fatal Crash...GCI
     573    598 000051F6                      	DGCIH	FCRASH	18			; GCI crash
     574    601                               	
     575    602                               	*	BUFFER Fatal Crash...WCI
     576    603 000051FE                      	DWCIH	FCRASH	20			; WCI crash
     577    606                               	
     578    607                               	*	Buss Error...Fatal Crash
     579    608 00005206                      	BUSERR	FCRASH	$82
     580    611                               	
     581    612                               	*	Illegal Instruction...Fatal Crash
     582    613 0000520E                      	ILLINS	FCRASH	$83
     583    616                               	
     584    617                               	*	Address Error...Fatal Crash
     585    618 00005216                      	ADRERR	FCRASH	$84



     587    622                               	 if	TRACING
     588    623                               		TTL	'E B U S -- PDP-10 Base Code,		T R A C E'EBUS02.J01                 E B U S -- PDP-10 Base Code,		T R A C E                        8-Oct-87  Page   16
Err Source Ref. Address   value
    line   line

     590    625                               	*	Tracing is individually enabled for ISIS and PDP rings, and for
     591    626                               	*	BIO and Buffering.
     592    627                               	
     593    628                               	*	An attempt is made to present a uniform trace mechanism, to permit
     594    629                               	*	the simultaneous tracing of any or all of the above.  Thus it is
     595    630                               	*	important to define the standard used:
     596    631                               	
     597    632                               	*	The trace consists of successive (time-ordered) trace-descriptors
     598    633                               	*	in a Trace-ring.  This ring starts at STRACE, folds at ETRACE, and
     599    634                               	*	the (next) descriptor address may be found in .TRACE.
     600    635                               	
     601    636                               	*	A trace-descriptor is 8 bytes long, and has the common form:
     602    637                               	
     603    638                               	*	| TR | dd | p# | ?? | V | A | L | U |
     604    639                               	
     605    640                               	*	TR|dd is a pair of characters which specify the operation (TR)
     606    641                               	*	being traced and the "direction" (dd);  p# is (usually) the current
     607    642                               	*	port;  ?? is additional information specific to the TR, and V|A|L|U
     608    643                               	*	is the (long) value being transfered.
     609    644                               	
     610    645                               	*	Possible forms are:
     611    646                               	*     TR|dd	Usage			Notes
     612    647                               	*	>R	PDP-ring input		?? is current fill-cursor
     613    648                               	*	<R	PDP-ring output		?? is current empty-cursor
     614    649                               	*	>B	Block-input		?? is current-address low byte
     615    650                               	*	@B	Block-input fetch	?? is current-address low byte
     616    651                               	*	<B	Block-output		?? is current-address low byte
     617    652                               	*	>C	DWCI
     618    653                               	*	<C	DGCI
     619    654                               	*	#C	DEMPTY
     620    655                               	*	lI	LOOK			word 3 = port, word 4 is type (right)
     621    656                               	*	<I	ISIS input		?? is number of bytes
     622    657                               	*	sI	SLOR			word 3 = port, word 4 is type (right)
     623    658                               	*	>I	ISIS output		?? is number of bytes
     624    659                               	*	Xi	FLUSH			?? is number of bytes
     625    660                               	
     626    661                               	
     627    662                               	*	This is the heart of the Trace-code
     628    663                               	*	It assumes one long has been filled already.
     629    664 0000521E 20C1                 	TRACE0	MOVE.L	D1,(A0)+		; second long = (D1)
     630    665                               	
     631    666                               	*	(Almost) everything filled...should we abort?
     632    667 00005220 3038 1010            	TRACE1	MOVE.W	TR_PORT,D0		; should we trace this port only?
     633    668 00005224 6D06                 		BLT	TRACE2			; no
     634    669 00005226 B02C 0000            		CMP.B	P_NUM(Rp),D0		; perhaps...is this the one?
     635    670 0000522A 6618                 		BNE	TRACE4			; no...just abort
     636    671 0000522C 116C 0000 FFFA       	TRACE2	MOVE.B	P_NUM(Rp),-6(A0)	; third byte = port #
     637    672 00005232 B1FC 0003 FFE0       		CMPA.L	#ETRACE,A0
     638    673 00005238 6D06                 		BLT	TRACE3
     639    674 0000523A 41F9 0002 0000       		LEA	STRACE,A0EBUS02.J01                 E B U S -- PDP-10 Base Code,		T R A C E                        8-Oct-87  Page   17
Err Source Ref. Address   value
    line   line

     640    675 00005240 21C8 1000            	TRACE3	MOVE.L	A0,.TRACE
     641    676 00005244                      	TRACE4	POPM	D0/A0
     642    678 00005248 4E75                 		RTS
     643    679                               	
     644    680                               	  if	ITRACE
     645    681                               	*	TRACE ISIS Transfers
     646    682                               	
     647    683 0000524A                      	TR_IOC	PUSHM	D0/A0			; PUTCH
     648    685 0000524E 2078 1000            		MOVE.L	.TRACE,A0
     649    686 00005252 30FC 3E49            		MOVE.W	#'>I',(A0)+		; first word = ISIS-trace flag
     650    687 00005256 30FC 0001            		MOVE.W	#1,(A0)+		; fourth byte = # bytes
     651    688 0000525A 4298                 		CLR.L	(A0)+
     652    689 0000525C 1140 FFFF            		MOVE.B	D0,-1(A0)		; eighth byte = char
     653    690 00005260 60BE                 		BRA	TRACE1
     654    691                               	
     655    692 00005262                      	TR_IOH	PUSHM	D0/A0			; PUTH
     656    694 00005266 2078 1000            		MOVE.L	.TRACE,A0
     657    695 0000526A 30FC 3E49            		MOVE.W	#'>I',(A0)+		; first word = ISIS-trace flag
     658    696 0000526E 30FC 0002            		MOVE.W	#2,(A0)+		; fourth byte = # bytes
     659    697 00005272 4258                 		CLR.W	(A0)+			; third word unused
     660    698 00005274 30C0                 		MOVE.W	D0,(A0)+		; fourth word = HW
     661    699 00005276 60A8                 		BRA	TRACE1
     662    700                               	
     663    701 00005278                      	TR_IOW	PUSHM	D0/A0			; PUTW
     664    703 0000527C 2078 1000            		MOVE.L	.TRACE,A0
     665    704 00005280 30FC 3E49            		MOVE.W	#'>I',(A0)+		; first word = ISIS-trace flag
     666    705 00005284 30FC 0004            		MOVE.W	#4,(A0)+		; fourth byte = # bytes
     667    706 00005288 20C0                 		MOVE.L	D0,(A0)+		; second long = W
     668    707 0000528A 6094                 		BRA	TRACE1
     669    708                               	
     670    709 0000528C                      	TR_IOS	PUSHM	D0/A0			; SLOR
     671    711 00005290 2078 1000            		MOVE.L	.TRACE,A0
     672    712 00005294 30FC 7349            		MOVE.W	#'sI',(A0)+		; first word = ISIS-trace flag
     673    713 00005298 30FC 0003            		MOVE.W	#3,(A0)+		; fourth byte = # bytes
     674    714 0000529C 30C3                 		MOVE.W	D3,(A0)+		; third word = port#
     675    715 0000529E 30C4                 		MOVE.W	D4,(A0)+		; fourth word = type
     676    716 000052A0 6000 FF7E            		BRA	TRACE1
     677    717                               	
     678    718 000052A4                      	TR_IIL	PUSHM	D0/A0			; LOOK
     679    720 000052A8 2078 1000            		MOVE.L	.TRACE,A0
     680    721 000052AC 30FC 6C49            		MOVE.W	#'lI',(A0)+		; first word = ISIS-trace flag
     681    722 000052B0 30FC 0003            		MOVE.W	#3,(A0)+		; fourth byte = # bytes
     682    723 000052B4 30C3                 		MOVE.W	D3,(A0)+		; third word = port#
     683    724 000052B6 30C4                 		MOVE.W	D4,(A0)+		; fourth word = type
     684    725 000052B8 6000 FF66            		BRA	TRACE1
     685    726                               	
     686    727 000052BC                      	TR_IIC	PUSHM	D0/A0			; GETCH
     687    729 000052C0 2078 1000            		MOVE.L	.TRACE,A0
     688    730 000052C4 30FC 3C49            		MOVE.W	#'<I',(A0)+		; first word = ISIS-trace flag
     689    731 000052C8 30FC 0001            		MOVE.W	#1,(A0)+		; fourth byte = # bytes
     690    732 000052CC 4298                 		CLR.L	(A0)+			; next long unusedEBUS02.J01                 E B U S -- PDP-10 Base Code,		T R A C E                        8-Oct-87  Page   18
Err Source Ref. Address   value
    line   line

     691    733 000052CE 1140 FFFF            		MOVE.B	D0,-1(A0)		; eighth byte = char
     692    734 000052D2 6000 FF4C            		BRA	TRACE1
     693    735                               	
     694    736 000052D6                      	TR_IIH	PUSHM	D0/A0			; GETH
     695    738 000052DA 2078 1000            		MOVE.L	.TRACE,A0
     696    739 000052DE 30FC 3C49            		MOVE.W	#'<I',(A0)+		; first word = ISIS-trace flag
     697    740 000052E2 30FC 0002            		MOVE.W	#2,(A0)+		; fourth byte = # bytes
     698    741 000052E6 4258                 		CLR.W	(A0)+			; next word unused
     699    742 000052E8 30C0                 		MOVE.W	D0,(A0)+		; fourth word = HW
     700    743 000052EA 6000 FF34            		BRA	TRACE1
     701    744                               	
     702    745 000052EE                      	TR_IIW	PUSHM	D0/A0			; GETW
     703    747 000052F2 2078 1000            		MOVE.L	.TRACE,A0
     704    748 000052F6 30FC 3C49            		MOVE.W	#'<I',(A0)+		; first word = ISIS-trace flag
     705    749 000052FA 30FC 0004            		MOVE.W	#4,(A0)+		; fourth byte = # bytes
     706    750 000052FE 20C0                 		MOVE.L	D0,(A0)+		; second long = W
     707    751 00005300 6000 FF1E            		BRA	TRACE1
     708    752                               	
     709    753 00005304                      	TR_IIF	PUSHM	D0/A0			; FLUSH
     710    755 00005308 2078 1000            		MOVE.L	.TRACE,A0
     711    756 0000530C 30FC 7849            		MOVE.W	#'xI',(A0)+		; first word = ISIS-trace flag
     712    757 00005310 30C0                 		MOVE.W	D0,(A0)+		; fourth byte = # bytes
     713    758 00005312 4298                 		CLR.L	(A0)+			; second long unused
     714    759 00005314 6000 FF0A            		BRA	TRACE1
     715    760                               	
     716    761                               	  endc
     717    762                               	
     718    763                               	  if	CTRACE
     744    764                               	  endc
     745    765                               	
     746    766                               	  if	BTRACE
     767    767                               	  endc
     768    768                               	
     769    769                               	  if	RTRACE
     770    770                               	*	TRACE PDP-10 Transfers
     771    771                               	
     772    772 00005318                      	TR_RIN	PUSHM	D0/A0
     773    774 0000531C 2078 1000            		MOVE.L	.TRACE,A0
     774    775 00005320 30FC 3C52            		MOVE.W	#'<R',(A0)+		; first word = ring-trace flag
     775    776 00005324 30F8 1092            		MOVE.W	PDPOEC,(A0)+		; fourth byte = PDP's OEC
     776    777 00005328 6000 FEF4            		BRA	TRACE0
     777    778                               	
     778    779 0000532C                      	TR_ROUT	PUSHM	D0/A0
     779    781 00005330 2078 1000            		MOVE.L	.TRACE,A0
     780    782 00005334 30FC 3E52            		MOVE.W	#'>R',(A0)+		; first word = ring-trace flag
     781    783 00005338 30F8 109A            		MOVE.W	PDPIFC,(A0)+		; fourth byte = PDP's OEC
     782    784 0000533C 6000 FEE0            		BRA	TRACE0
     783    785                               	
     784    786                               	  endc
     785    787                               	
     786    788                               	 endcEBUS02.J01                 E B U S -- PDP-10 Base Code,		T R A C E                        8-Oct-87  Page   19
Err Source Ref. Address   value
    line   line




     788    790                               		TTL	'E B U S  --  PDP-10 Base Code,		I S I S   R I N G S'EBUS02.J01                 E B U S  --  PDP-10 Base Code,		I S I S   R I N G S            8-Oct-87  Page   20
Err Source Ref. Address   value
    line   line

     790    792                               	
     791    793                               	*		I S I S   R I N G   R O U T I N E S
     792    794                               	
     793    795                               	
     794    796                               	*	Conventions:
     795    797                               	*	Routines use dedicated registers
     796    798                               	*	A6	Output Ring Base Address
     797    799                               	*	Rs	Input Ring Base Address
     798    800                               	*	NOTE ....
     799    801                               	*	   IRSIZE & ORSIZE MUST BE LESS THAN 32K
     800    802                               	
     801    803                               	
     802    804                               	*		RING OUTPUT ROUTINES
     803    805                               	
     804    806                               	*	Insure that there is room in ring
     805    807                               	*	Expects	D0 = # characters of space required (W)
     806    808                               	*	Returns	Z FLAG = 0 means OK, 1 is no room
     807    809                               	*	Smashes D1
     808    810 00005340 322E 0002            	ROOM	MOVE.W	2(Rd),D1		; CEI
     809    811 00005344 9256                 		SUB.W	(Rd),D1			;  - NFMI
     810    812 00005346 6E06                 		BGT	RNOWRAP			; >0 = no wrap
     811    813 00005348 670C                 		BEQ	ROOMG			; =0 = empty
     812    814 0000534A D278 1040            		ADD.W	ORSIZE,D1		; <0 = ring-wrap, compute bias
     813    815 0000534E 5941                 	RNOWRAP	SUB.W	#4,D1			; can't fill ring completely
     814    816 00005350 B240                 		CMP.W	D0,D1			; is required space available?
     815    817 00005352 6D04                 		BLT	ROOMB			; no
     816    818 00005354 9201                 		SUB.B	D1,D1			; yes..set Z=0
     817    819 00005356 4E75                 	ROOMG	RTS
     818    820                               	
     819    821 00005358 123C 00FF            	ROOMB	MOVE.B	#-1,D1			; no room...set Z=1
     820    822 0000535C 4E75                 		RTS
     821    823                               	
     822    824                               	*	Wait until there's a word available in ISIS output ring
     823    825                               	*	All registers preserved
     824    826 0000535E                      	WAITISW	PUSHM	D0/D1
     825    828 00005362 7004                 		MOVEQ	#4,D0
     826    829 00005364 6008                 		BRA	WAIT
     827    830                               	
     828    831                               	*	Wait until there's D0 bytes available in ISIS output ring
     829    832                               	*	All registers preserved
     830    833 00005366                      	WAITIS	PUSHM	D0/D1
     831    835 0000536A 0240 00FF            		AND.W	#$00FF,D0
     832    836 0000536E 61D0                 	WAIT	BSR	ROOM
     833    837 00005370 66FC                 		BNE	WAIT
     834    838 00005372                      		POPM	D0/D1
     835    840 00005376 4E75                 		RTS
     836    841                               	
     837    842                               	
     838    843                               	
     839    844                               	*	START LOGICAL OUTPUT RECORDEBUS02.J01                 E B U S  --  PDP-10 Base Code,		I S I S   R I N G S            8-Oct-87  Page   21
Err Source Ref. Address   value
    line   line

     840    845                               	*	Provides function of ROOM, PUTH & PUTCH
     841    846                               	*	for first 3 characters of message
     842    847                               	*	D3 = PORT # (B)
     843    848                               	*	D4 = Message type code (B)
     844    849 00005378                      	SLOR	PUSHM	D0/D4			; save registers
     845    851 0000537C 3C16                 		MOVE.W	(Rd),Cd			; set up cursor from NFMI
     846    852                               	 if	ITRACE
     847    853 0000537E 6100 FF0C            		BSR	TR_IOS			; record activity
     848    854                               	 endc
     849    855 00005382 4240                 		CLR.W	D0
     850    856 00005384 1003                 		MOVE.B	D3,D0
     851    857 00005386 3D80 6004            		MOVE.W	D0,4(Rd,Cd.W)
     852    858 0000538A E14C                 		LSL.W	#8,D4
     853    859 0000538C 3D84 6006            		MOVE.W	D4,6(Rd,Cd.W)
     854    860 00005390 5646                 		ADD.W	#3,Cd			; advance cursor
     855    861 00005392                      		POPM	D0/D4
     856    863 00005396 4E75                 		RTS
     857    864                               	
     858    865                               	
     859    866                               	*	Put a character into the ring
     860    867                               	*	D0 = CHARACTER
     861    868 00005398                      	PUTCH	PUSHM	D0/D2			; save registers
     862    870                               	 if	ITRACE
     863    871 0000539C 6100 FEAC            		BSR	TR_IOC			; record activity
     864    872                               	 endc
     865    873 000053A0 0806 0000            		BTST	#0,Cd			; check even/odd boundary
     866    874 000053A4 670C                 		BEQ	PUEVEN
     867    875 000053A6 3436 6003            		MOVE.W	3(Rd,Cd.W),D2		; get HW to fill
     868    876 000053AA 1400                 		MOVE.B	D0,D2			; pack in new byte
     869    877 000053AC 3D82 6003            		MOVE.W	D2,3(Rd,Cd.W)
     870    878 000053B0 6006                 		BRA	PUTODD
     871    879                               	
     872    880 000053B2 E148                 	PUEVEN	LSL.W	#8,D0
     873    881 000053B4 3D80 6004            		MOVE.W	D0,4(Rd,Cd.W)
     874    882 000053B8 5246                 	PUTODD	ADD.W	#1,Cd
     875    883 000053BA BC78 1040            		CMP.W	ORSIZE,Cd		; check for folding
     876    884 000053BE 6D02                 		BLT	PUTC1
     877    885 000053C0 4246                 		CLR.W	Cd
     878    886 000053C2                      	PUTC1	POPM	D0/D2
     879    888 000053C6 4E75                 		RTS
     880    889                               	
     881    890                               	
     882    891                               	
     883    892                               	*	Put a (short) half-word into the ring
     884    893                               	*	D0 = HALF WORD
     885    894 000053C8 3D80 6004            	PUTH	MOVE.W	D0,4(Rd,Cd.W)
     886    895                               	 if	ITRACE
     887    896 000053CC 6100 FE94            		BSR	TR_IOH			; record activity
     888    897                               	 endc
     889    898 000053D0 5446                 		ADD.W	#2,Cd
     890    899 000053D2 BC78 1040            		CMP.W	ORSIZE,Cd		; check for foldingEBUS02.J01                 E B U S  --  PDP-10 Base Code,		I S I S   R I N G S            8-Oct-87  Page   22
Err Source Ref. Address   value
    line   line

     891    900 000053D6 6D02                 		BLT	PUTH11
     892    901 000053D8 4246                 		CLR.W	Cd
     893    902 000053DA 4E75                 	PUTH11	RTS
     894    903                               	
     895    904                               	
     896    905                               	
     897    906                               	*	Put a (long) word into the ring
     898    907                               	*	D0 = WORD
     899    908 000053DC 2D80 6004            	PUTW	MOVE.L	D0,4(Rd,Cd.W)
     900    909                               	 if	ITRACE
     901    910 000053E0 6100 FE96            		BSR	TR_IOW			; record activity
     902    911                               	 endc
     903    912 000053E4 5846                 		ADD.W	#4,Cd
     904    913 000053E6 BC78 1040            		CMP.W	ORSIZE,Cd		; check for folding
     905    914 000053EA 6D02                 		BLT	PUTW11
     906    915 000053EC 4246                 		CLR.W	Cd
     907    916 000053EE 4E75                 	PUTW11	RTS
     908    917                               	
     909    918                               	*	Send a quick message to ISIS
     910    919                               	*	Expects:	D3 = port # (B)
     911    920                               	*			D4 = Type-byte (B)
     912    921                               	*	Returns:	3-byte message in ring
     913    922 000053F0 6100 FF6C            	SENDQI	BSR	WAITISW			; wait for ring-space
     914    923 000053F4 6182                 		BSR	SLOR			; start-logical-output-record...then ELOR
     915    924                               	
     916    925                               	
     917    926                               	*	END LOGICAL OUTPUT RECORD
     918    927 000053F6 5646                 	ELOR	ADD.W	#3,Cd
     919    928 000053F8 0246 FFFC            		AND.W	#-4,Cd
     920    929 000053FC BC78 1040            		CMP.W	ORSIZE,Cd		; check for ring-fold
     921    930 00005400 6D02                 		BLT	ELOR21
     922    931 00005402 4246                 		CLR.W	Cd
     923    932 00005404 3C86                 	ELOR21	MOVE.W	Cd,(Rd)			; advance NFMI, message now in ring
     924    933 00005406 4E75                 		RTS
     925    934                               	
     926    935                               	
     927    936                               	
     928    937                               	*	Sent a TEXTC string as data
     929    938                               	*	Expects:	A0 -	pointer to string
     930    939                               	*			PORTNO - current port number
     931    940 00005408 1010                 	SENDTEXT MOVE.B	(A0),D0			; get length
     932    941 0000540A 5600                 		ADD.B	#3,D0			; compute message length
     933    942 0000540C 6100 FF58            		BSR	WAITIS			; wait for space in ring
     934    943 00005410 3638 10A0            		MOVE.W	PORTNO,D3		; now place text message
     935    944 00005414 1818                 		MOVE.B	(A0)+,D4		; length is message-type
     936    945 00005416 6100 FF60            		BSR	SLOR			; Start-Logical-Output-Record
     937    946 0000541A 5304                 	SNDTXT1	SUB.B	#1,D4			; done?
     938    947 0000541C 6DD8                 		BLT	ELOR			; yes...exit via ELOR
     939    948 0000541E 1018                 		MOVE.B	(A0)+,D0		; no...append another char
     940    949 00005420 6100 FF76            		BSR	PUTCH
     941    950 00005424 60F4                 		BRA	SNDTXT1			; and do anotherEBUS02.J01                 E B U S  --  PDP-10 Base Code,		I S I S   R I N G S            8-Oct-87  Page   23
Err Source Ref. Address   value
    line   line

     943    952                               	*		INPUT ROUTINES
     944    953                               	
     945    954                               	*	LOOK at an input ring entry
     946    955                               	*	Returns:
     947    956                               	*	If ring is empty, then Z FLAG = 0
     948    957                               	*	Else Z .NE. 0, PORT returned in D3
     949    958                               	*	Message Type returned in D4
     950    959                               	*	All registers set up for transfer
     951    960                               	*	Cursor is advanced past PORT #
     952    961                               	
     953    962                               	
     954    963                               	
     955    964 00005426 3E2D 0002            	LOOK	MOVE.W	2(Rs),Cs		; get Ring's CEI
     956    965 0000542A BE55                 		CMP.W	(Rs),Cs			; check if empty
     957    966 0000542C 671A                 		BEQ	NOIRING			; yes..exit Z=0
     958    967 0000542E 3635 7004            		MOVE.W	4(Rs,Cs.W),D3		; PORT #
     959    968 00005432 3835 7006            		MOVE.W	6(Rs,Cs.W),D4		; MSG TYPE BYTE
     960    969 00005436 5778 10F0            		SUB.W	#3,IRRN
     961    970 0000543A E04C                 		LSR.W	#8,D4			; justify the type byte
     962    971 0000543C 3003                 		MOVE.W	D3,D0
     963    972 0000543E 6100 05F8            		BSR.L	SETPORT			; set up port
     964    973                               	 if	ITRACE
     965    974 00005442 6100 FE60            		BSR	TR_IIL			; record activity
     966    975                               	 endc
     967    976 00005446 5647                 		ADD.W	#3,Cs			; (sets Z .NE. 0)
     968    977 00005448 4E75                 	NOIRING	RTS				; return Z-Flag indication
     969    978                               	
     970    979                               	
     971    980                               	*	Get a character from the Input Ring
     972    981                               	*	Character returned in D0
     973    982 0000544A 5378 10F0            	GETCH	SUB.W	#1,IRRN			; count it
     974    983 0000544E 0807 0000            		BTST	#0,Cs			; getting even or odd byte?
     975    984 00005452 6706                 		BEQ	EVENBON			; skip if even
     976    985 00005454 3035 7003            		MOVE.W	3(Rs,Cs.W),D0		; get from odd boundary
     977    986 00005458 6006                 		BRA	ODDBON
     978    987                               	
     979    988 0000545A 3035 7004            	EVENBON	MOVE.W	4(Rs,Cs.W),D0		; get from even boundary
     980    989 0000545E E048                 		LSR.W	#8,D0			; ...and justify the character
     981    990 00005460 0240 00FF            	ODDBON	AND.W	#$00FF,D0		; pad out to word
     982    991                               	 if	ITRACE
     983    992 00005464 6100 FE56            		BSR	TR_IIC			; record activity
     984    993                               	 endc
     985    994 00005468 5247                 		ADD.W	#1,Cs			; advance and fold cursor
     986    995 0000546A BE78 103E            		CMP.W	IRSIZE,Cs
     987    996 0000546E 6D02                 		BLT	GETCH1
     988    997 00005470 4247                 		CLR.W	Cs
     989    998 00005472 4E75                 	GETCH1	RTS				; and exit
     990    999                               	
     991   1000                               	*	Get a half-word from the Input-Ring
     992   1001                               	*	Assumed we're on correct (HW) BoundaryEBUS02.J01                 E B U S  --  PDP-10 Base Code,		I S I S   R I N G S            8-Oct-87  Page   24
Err Source Ref. Address   value
    line   line

     993   1002                               	*	Half-word returned in D0
     994   1003                               	
     995   1004 00005474 3035 7004            	GETH	MOVE.W	4(Rs,Cs.W),D0		; get the value
     996   1005                               	 if	ITRACE
     997   1006 00005478 6100 FE5C            		BSR	TR_IIH			; record activity
     998   1007                               	 endc
     999   1008 0000547C 5578 10F0            		SUB.W	#2,IRRN
    1000   1009 00005480 5447                 		ADD.W	#2,Cs			; advance and fold cursor
    1001   1010 00005482 BE78 103E            		CMP.W	IRSIZE,Cs
    1002   1011 00005486 6D02                 		BLT	GETH1
    1003   1012 00005488 4247                 		CLR.W	Cs
    1004   1013 0000548A 4E75                 	GETH1	RTS				; ...and exit
    1005   1014                               	
    1006   1015                               	*	Get a (long) Word from the Input-ring
    1007   1016                               	*	Assumed we're at appropriate boundary
    1008   1017                               	*	Value returned in D0
    1009   1018 0000548C 2035 7004            	GETW	MOVE.L	4(Rs,Cs.W),D0
    1010   1019                               	 if	ITRACE
    1011   1020 00005490 6100 FE5C            		BSR	TR_IIW			; record activity
    1012   1021                               	 endc
    1013   1022 00005494 5978 10F0            		SUB.W	#4,IRRN
    1014   1023 00005498 5847                 		ADD.W	#4,Cs			; advance and fold cursor
    1015   1024 0000549A BE78 103E            		CMP.W	IRSIZE,Cs
    1016   1025 0000549E 6D02                 		BLT	GETW1
    1017   1026 000054A0 4247                 		CLR.W	Cs
    1018   1027 000054A2 4E75                 	GETW1	RTS				; ...and exit
    1019   1028                               	
    1020   1029                               	*	Flush an input record
    1021   1030                               	*	Expects number of Chars to flush in D0
    1022   1031 000054A4 0240 00FF            	FLUSH	AND.W	#$00FF,D0		; expand number
    1023   1032 000054A8 DE40                 		ADD.W	D0,Cs
    1024   1033                               	 if	ITRACE
    1025   1034 000054AA 6100 FE58            		BSR	TR_IIF			; record activity
    1026   1035                               	 endc
    1027   1036                               	
    1028   1037                               	*	END LOGICAL INPUT RECORD
    1029   1038 000054AE 5647                 	ELIR	ADD.W	#3,Cs			; round cursor up to next (long) word
    1030   1039 000054B0 0247 FFFC            		AND.W	#-4,Cs
    1031   1040 000054B4 BE78 103E            		CMP.W	IRSIZE,Cs		; check for folding required
    1032   1041 000054B8 6D04                 		BLT	ELIR2			; no
    1033   1042 000054BA 9E78 103E            		SUB.W	IRSIZE,Cs
    1034   1043 000054BE 3B47 0002            	ELIR2	MOVE.W	Cs,2(Rs)		; now set new CEI back into Ring
    1035   1044 000054C2 4E75                 		RTS				; and exit



    1037   1046                               		TTL	'E B U S  --  PDP-10 Base Code,		P D P   I / O'EBUS02.J01                 E B U S  --  PDP-10 Base Code,		P D P   I / O                  8-Oct-87  Page   25
Err Source Ref. Address   value
    line   line

    1039   1048                               	*		P D P - 1 0   I / O   R o u t i n e s
    1040   1049                               	
    1041   1050                               	***	ROUTINES TO READ FROM PDP-10
    1042   1051                               	
    1043   1052                               	
    1044   1053                               	
    1045   1054                               	*	Routine to Read a "Word" from PDP-10
    1046   1055                               	*	Smashes registers:	D0-D3
    1047   1056 000054C4 11FC 0010 1106       	RD10R	MOVE.B	#16,TMOC		; initialize counters
    1048   1057                               	
    1049   1058 000054CA 7246                 	RD10AG	MOVEQ	#70,D1			; counter for BUSY try
    1050   1059 000054CC 3039 00D0 00B8       	RD10R1	MOVE.W	DSENS,D0		; Sense Busy
    1051   1060 000054D2 0800 0000            		BTST	#0,D0			; is Sense BUSY?
    1052   1061 000054D6 665C                 		BNE	RDSNB			; yes...go to BUSY code
    1053   1062 000054D8 4242                 		CLR.W	D2
    1054   1063 000054DA 4A38 10DE            		TST.B	BLK
    1055   1064 000054DE 6704                 		BEQ	BLKK2
    1056   1065 000054E0 1438 1046            		MOVE.B	P10DLL,D2
    1057   1066 000054E4 33C2 00D0 803E       	BLKK2	MOVE.W	D2,WT103		; place low address
    1058   1067 000054EA 3438 1048            		MOVE.W	P10ADR,D2
    1059   1068 000054EE 0242 7FFF            		AND.W	#$7FFF,D2		; high-bit = 0 specifies READ operation
    1060   1069 000054F2 33C2 00D0 8038       		MOVE.W	D2,WT104		; send Low address
    1061   1070 000054F8 7646                 		MOVEQ	#70,D3			; counter for Busy loop
    1062   1071 000054FA 3039 00D0 00B8       	RD10R2	MOVE.W	DSENS,D0		; Sense Busy
    1063   1072 00005500 0800 0000            		BTST	#0,D0			; Is Sense BUSY?
    1064   1073 00005504 6648                 		BNE	RDSNB1			; yes...go to BUSY code
    1065   1074 00005506 31F9 00D0 403A 1042  		MOVE.W	RD101,P10DAH		; Read high 16-bits of data from PDP
    1066   1075 0000550E 31F9 00D0 403C 1044  		MOVE.W	RD104,P10DAL		; Read "middle" 16-bits of data from PDP
    1067   1076 00005516 3439 00D0 403E       		MOVE.W	RD102,D2		; Read low 4-bits of data from PDP
    1068   1077 0000551C 0242 000F            		AND.W	#$000F,D2		; zero out high-order bits
    1069   1078 00005520 11C2 1046            		MOVE.B	D2,P10DLL		; and save low 4-bits of data
    1070   1079 00005524 3439 00D0 0138       		MOVE.W	DPER,D2			; Check if there is a parity error
    1071   1080 0000552A 0802 0000            		BTST	#0,D2
    1072   1081 0000552E 6600 0488            		BNE.L	PARERR			; yes..process parity error
    1073   1082 00005532 4E75                 		RTS				; ...else return
    1074   1083                               	
    1075   1084 00005534 5301                 	RDSNB	SUB.B	#1,D1
    1076   1085 00005536 6694                 		BNE	RD10R1			; another try if < 70 times
    1077   1086 00005538 6000 0486            		BRA.L	BUSCRAS
    1078   1087                               	
    1079   1088 0000553C 5338 1106            	TMOUT	SUB.B	#1,TMOC
    1080   1089 00005540 6700 046E            		BEQ.L	TMOUT1
    1081   1090 00005544 4A79 00D0 1038       		TST.W	DEXCO			; Reset EBUS
    1082   1091 0000554A 6000 FF7E            		BRA	RD10AG
    1083   1092                               	
    1084   1093 0000554E 3439 00D0 01B8       	RDSNB1	MOVE.W	DTMOT,D2		; test for time-out
    1085   1094 00005554 0802 0000            		BTST	#0,D2
    1086   1095 00005558 66E2                 		BNE	TMOUT			; yes...go process timeout
    1087   1096 0000555A 3439 00D0 0138       		MOVE.W	DPER,D2			; check if Parity error
    1088   1097 00005560 0802 0000            		BTST	#0,D2EBUS02.J01                 E B U S  --  PDP-10 Base Code,		P D P   I / O                  8-Oct-87  Page   26
Err Source Ref. Address   value
    line   line

    1089   1098 00005564 6600 0452            		BNE.L	PARERR			; yes...go process parity error
    1090   1099 00005568 5303                 		SUB.B	#1,D3
    1091   1100 0000556A 668E                 		BNE	RD10R2			; another try if < 70
    1092   1101 0000556C 6000 0452            		BRA.L	BUSCRAS
    1093   1102                               	
    1094   1103                               	*	Read from PDP, get (left-most) high 32-bit message into D1
    1095   1104 00005570                      	GETPDPL	PUSHM	D0/D2-D3
    1096   1106 00005574 6100 FF4E            		BSR	RD10R			; read from PDP
    1097   1107 00005578 2238 1042            		MOVE.L	P10DAH,D1		;  ...into D1
    1098   1108 0000557C                      		POPM	D0/D2-D3
    1099   1110 00005580 4E75                 		RTS
    1100   1111                               	
    1101   1112                               	*	Read from PDP, get low-order 32-bits into D1
    1102   1113 00005582                      	GETPDPR	PUSHM	D0/D2-D3
    1103   1115 00005586 6100 FF3C            		BSR	RD10R			; read from PDP
    1104   1116 0000558A 2238 1042            		MOVE.L	P10DAH,D1
    1105   1117 0000558E E989                 		LSL.L	#4,D1			; left-justify 28-bits of data
    1106   1118 00005590 1438 1046            		MOVE.B	P10DLL,D2		; low 4 bits
    1107   1119 00005594 0202 000F            		AND.B	#$0F,D2			; clear high order bits
    1108   1120 00005598 8202                 		OR.B	D2,D1			; merge with previous result
    1109   1121 0000559A                      		POPM	D0/D2-D3
    1110   1123 0000559E 4E75                 		RTS
    1111   1124                               	
    1112   1125                               	*	Read Word indicated by PDPOEC & put left (high) 32 bits in D1
    1113   1126                               	*	and in DAT.  Also advance and wrap PDPOEC
    1114   1127 000055A0                      	RDPDP	PUSHM	D0/D2
    1115   1129 000055A4 5378 10F2            		SUB.W	#1,ORRN
    1116   1130 000055A8 31F8 108C 1048       		MOVE.W	PDPORP,P10ADR		; PDP output ring start address
    1117   1131 000055AE 3438 1092            		MOVE.W	PDPOEC,D2		; get output ring cursor
    1118   1132 000055B2 D578 1048            		ADD.W	D2,P10ADR		; address of current word in ring
    1119   1133 000055B6 61B8                 		BSR	GETPDPL			; get the word from ring
    1120   1134 000055B8 21C1 10A8            		MOVE.L	D1,DAT
    1121   1135                               	 if	RTRACE
    1122   1136 000055BC 6100 FD5A            		BSR	TR_RIN			; record activity
    1123   1137                               	 endc
    1124   1138 000055C0 5242                 		ADD.W	#1,D2			; advance cursor
    1125   1139 000055C2 B478 108E            		CMP.W	PDPOSZ,D2		; check if to fold it
    1126   1140 000055C6 6602                 		BNE	RDPDP1
    1127   1141 000055C8 4242                 		CLR.W	D2			; yes
    1128   1142 000055CA 31C2 1092            	RDPDP1	MOVE.W	D2,PDPOEC		; save new cursor
    1129   1143 000055CE                      		POPM	D0/D2
    1130   1145 000055D2 4E75                 		RTS
    1131   1146                               	
    1132   1147                               	
    1133   1148                               	*	Read another word from a storage-block in the PDP-10 to DAT
    1134   1149                               	*	and increment pointer
    1135   1150                               	*	Returns:	DAT and D1 = full-word of data read
    1136   1151                               	*			No other Registers Disturbed
    1137   1152 000055D4                      	RDBLK	PUSHM	D0/D2-D3
    1138   1154 000055D8 4280                 		CLR.L	D0
    1139   1155 000055DA 202C 0004            		MOVE.L	BO_TAR(Rp),D0EBUS02.J01                 E B U S  --  PDP-10 Base Code,		P D P   I / O                  8-Oct-87  Page   27
Err Source Ref. Address   value
    line   line

    1140   1156 000055DE 6100 0096            		BSR.L	SETBLKA			; set up BLOCK-IO address
    1141   1157 000055E2 6100 FEE0            		BSR	RD10R
    1142   1158 000055E6 4238 10DE            		CLR.B	BLK
    1143   1159 000055EA 2238 1042            		MOVE.L	P10DAH,D1
    1144   1160 000055EE 21C1 10A8            		MOVE.L	D1,DAT1
    1145   1161                               	 if	BTRACE
    1147   1162                               	 endc
    1148   1163 000055F2 52AC 0004            		ADD.L	#1,BO_TAR(Rp)
    1149   1164 000055F6                      		POPM	D0/D2-D3
    1150   1166 000055FA 4E75                 		RTS
    1151   1167                               	
    1152   1168                               	*	Read PDP input-ring Empty-Cursor
    1153   1169 000055FC 31FC 006D 1048       	GETIEC	MOVE.W	#$6D,P10ADR		; from o155
    1154   1170 00005602 6100 FF7E            		BSR	GETPDPR
    1155   1171 00005606 31C1 1098            		MOVE.W	D1,PDPIEC
    1156   1172 0000560A 4E75                 		RTS
    1157   1173                               	
    1158   1174                               	*	Read PDP Output-ring Fill Cursor
    1159   1175 0000560C 31FC 0071 1048       	GETOFC	MOVE.W	#$71,P10ADR		; from o161
    1160   1176 00005612 6100 FF6E            		BSR	GETPDPR
    1161   1177 00005616 31C1 1090            		MOVE.W	D1,PDPOFC
    1162   1178 0000561A 4E75                 		RTS
    1163   1179                               	
    1164   1180                               	
    1165   1181                               	*	Read PDP's Ring-parameters
    1166   1182                               	
    1167   1183                               	*	First, read Output-ring parameters
    1168   1184 0000561C 31FC 006F 1048       	RDPDPRP	MOVE.W	#$6F,P10ADR		; Read from o157 (Left)
    1169   1185 00005622 6100 FF4C            		BSR	GETPDPL
    1170   1186 00005626 31C1 108C            		MOVE.W	D1,PDPORP		;  ...Output-ring start-address
    1171   1187                               	
    1172   1188 0000562A 31FC 0070 1048       		MOVE.W	#$70,P10ADR		; from o160 (Left)
    1173   1189 00005630 6100 FF3E            		BSR	GETPDPL
    1174   1190 00005634 31C1 108E            		MOVE.W	D1,PDPOSZ		;  ...Output-ring Size
    1175   1191                               	
    1176   1192 00005638 61D2                 		BSR	GETOFC			; Get output-ring fill cursor (from o161)
    1177   1193                               	
    1178   1194 0000563A 31FC 0048 1048       		MOVE.W	#72,P10ADR		; from o162 (Right)
    1179   1195 00005640 6100 FF40            		BSR	GETPDPR
    1180   1196 00005644 31C1 1092            		MOVE.W	D1,PDPOEC		;  ...output-ring empty cursor
    1181   1197                               	
    1182   1198                               	
    1183   1199                               	*	Next, read Input-ring parameters
    1184   1200 00005648 31FC 006B 1048       		MOVE.W	#$6B,P10ADR		; from o153 (Left)
    1185   1201 0000564E 6100 FF20            		BSR	GETPDPL
    1186   1202 00005652 31C1 1094            		MOVE.W	D1,PDPIRP		;  ...Input-ring Start-address
    1187   1203                               	
    1188   1204 00005656 31FC 006C 1048       		MOVE.W	#$6C,P10ADR		; from o154 (Left)
    1189   1205 0000565C 6100 FF12            		BSR	GETPDPL
    1190   1206 00005660 31C1 1096            		MOVE.W	D1,PDPISZ		;  ...Input-ring size
    1191   1207                               	EBUS02.J01                 E B U S  --  PDP-10 Base Code,		P D P   I / O                  8-Oct-87  Page   28
Err Source Ref. Address   value
    line   line

    1192   1208 00005664 6196                 		BSR	GETIEC			; Get input-ring empty cursor (from o155)
    1193   1209                               	
    1194   1210 00005666 31FC 006E 1048       		MOVE.W	#$6E,P10ADR		; from o156 (Right)
    1195   1211 0000566C 6100 FF14            		BSR	GETPDPR
    1196   1212 00005670 31C1 109A            		MOVE.W	D1,PDPIFC		;  ...Input-ring fill cursor
    1197   1213                               	
    1198   1214                               	
    1199   1215 00005674 4E75                 		RTS				; Done...return






    1201   1217                               	*	Set up Block-IO address
    1202   1218                               	*	Expects:	D0 = address (may be more than 15 bits) (L)
    1203   1219                               	*	Returns:	P10ADR and P10DLL set up; BLK set
    1204   1220                               	*			D0 smashed; No other Registers Disturbed
    1205   1221 00005676 31C0 1048            	SETBLKA	MOVE.W	D0,P10ADR		; low-order 15-bits
    1206   1222 0000567A E398                 		ROL.L	#1,D0			; now manipulate high-order bits
    1207   1223 0000567C 4840                 		SWAP	D0
    1208   1224 0000567E E948                 		LSL.W	#4,D0
    1209   1225 00005680 11C0 1046            		MOVE.B	D0,P10DLL		; high-order 4-bits
    1210   1226 00005684 11FC 00FF 10DE       		MOVE.B	#-1,BLK
    1211   1227 0000568A 4E75                 		RTSEBUS02.J01                 E B U S  --  PDP-10 Base Code,		P D P   I / O                  8-Oct-87  Page   29
Err Source Ref. Address   value
    line   line

    1213   1229                               	*	Routines to write to PDP-10
    1214   1230                               	
    1215   1231                               	
    1216   1232                               	*	Routine to write to PDP-10
    1217   1233                               	*	Smashes Registers:	D0-D2
    1218   1234 0000568C 7246                 	WR10R	MOVEQ	#70,D1			; counter for Busy try
    1219   1235                               	
    1220   1236                               	*	Come back here to retry operation
    1221   1237 0000568E 3039 00D0 00B8       	WR10R1	MOVE.W	DSENS,D0		; Busy Sense
    1222   1238 00005694 0800 0000            		BTST	#0,D0			; Is Sense Busy?
    1223   1239 00005698 663E                 		BNE	WRSNB			; yes, go to Busy routine
    1224   1240 0000569A 4678 1042            		NOT.W	P10DAH			; MIC will invert bits
    1225   1241 0000569E 33F8 1042 00D0 803A  		MOVE.W	P10DAH,WT101		; transmit 1st HW to write
    1226   1242 000056A6 4678 1044            		NOT.W	P10DAL			; MIC will invert bits
    1227   1243 000056AA 33F8 1044 00D0 803C  		MOVE.W	P10DAL,WT102		; transmit 2nd HW to write
    1228   1244 000056B2 1438 1046            		MOVE.B	P10DLL,D2		; transmit last 4 bits of data
    1229   1245 000056B6 4A38 10DE            		TST.B	BLK
    1230   1246 000056BA 6606                 		BNE	BLKK1
    1231   1247 000056BC 4602                 		NOT.B	D2			; MIC will invert bits
    1232   1248 000056BE 0242 000F            		AND.W	#$000F,D2		; clear high order bits
    1233   1249 000056C2 33C2 00D0 803E       	BLKK1	MOVE.W	D2,WT103		; move data and address to register 3
    1234   1250 000056C8 3438 1048            		MOVE.W	P10ADR,D2		; get address within PDP
    1235   1251 000056CC 0042 8000            		OR.W	#$8000,D2		; High-bit = 1 specifies WRITE
    1236   1252 000056D0 33C2 00D0 8038       		MOVE.W	D2,WT104		; to register 3
    1237   1253 000056D6 4E75                 		RTS
    1238   1254                               	
    1239   1255 000056D8 5301                 	WRSNB	SUB.B	#1,D1
    1240   1256 000056DA 66B2                 		BNE	WR10R1			; another try if < 70 times
    1241   1257 000056DC 6000 02E2            		BRA.L	BUSCRAS
    1242   1258                               	
    1243   1259                               	
    1244   1260                               	*	Write into PDP (high), insuring that low 4 bits are ON!
    1245   1261 000056E0                      	PUTNOT0	PUSHM	D0-D3
    1246   1263 000056E4 21C1 1042            		MOVE.L	D1,P10DAH
    1247   1264 000056E8 4238 1046            		CLR.B	P10DLL			; all 1's to last 4 bits
    1248   1265 000056EC 619E                 		BSR	WR10R
    1249   1266 000056EE                      		POPM	D0-D3
    1250   1268 000056F2 4E75                 		RTS
    1251   1269                               	
    1252   1270                               	*	Crash the Host
    1253   1271 000056F4 2238 1004            	HCRASH	MOVE.L	CODCASH,D1		; get reason
    1254   1272 000056F8 E089                 		LSR.L	#8,D1			; code into high 16 bits
    1255   1273 000056FA 31FC 0068 1048       		MOVE.W	#$68,P10ADR		; put into KEY at o150
    1256   1274 00005700 4A79 00D0 1038       		TST.W	DEXCO			; Reset EBUS
    1257   1275 00005706 61D8                 		BSR	PUTNOT0
    1258   1276 00005708 31FC 0018 1048       		MOVE.W	#$18,P10ADR		; address o30
    1259   1277 0000570E 2238 1092            		MOVE.L	PDPOEC,D1		; return: Output Empty Cursor |
    1260   1278 00005712 3238 109A            		MOVE.W	PDPIFC,D1		;	  Input Fill Cursor
    1261   1279 00005716 4A79 00D0 1038       		TST.W	DEXCO			; Reset EBUS
    1262   1280 0000571C 61C2                 		BSR	PUTNOT0			; send it, insure word != 0EBUS02.J01                 E B U S  --  PDP-10 Base Code,		P D P   I / O                  8-Oct-87  Page   30
Err Source Ref. Address   value
    line   line

    1263   1281 0000571E 4A79 00D0 1038       		TST.W	DEXCO			; Reset EBUS
    1264   1282 00005724 4E75                 		RTS				; then return
    1265   1283                               	
    1266   1284                               	
    1267   1285                               	*	Write D1 to high (left) 32 bits within PDP-10
    1268   1286 00005726                      	PUTPDPL	PUSHM	D0/D2-D3
    1269   1288 0000572A 21C1 1042            		MOVE.L	D1,P10DAH		; deposit data
    1270   1289 0000572E 11FC 000F 1046       		MOVE.B	#$0F,P10DLL		; all 0's to last 4 bits
    1271   1290 00005734 6100 FF56            		BSR	WR10R
    1272   1291 00005738                      		POPM	D0/D2-D3
    1273   1293 0000573C 4E75                 		RTS
    1274   1294                               	
    1275   1295                               	*	Write D1 to low (right) 32 bits within PDP-10
    1276   1296 0000573E                      	PUTPDPR	PUSHM	D0-D3
    1277   1298 00005742 11C1 1046            		MOVE.B	D1,P10DLL		; last 4 bits to P10DLL
    1278   1299 00005746 E889                 		LSR.L	#4,D1			; right-justify value
    1279   1300 00005748 21C1 1042            		MOVE.L	D1,P10DAH
    1280   1301 0000574C 6100 FF3E            		BSR	WR10R			; call write routine
    1281   1302 00005750                      		POPM	D0-D3
    1282   1304 00005754 4E75                 		RTS
    1283   1305                               	
    1284   1306                               	*	Write another word to a storage-block in the PDP-10
    1285   1307                               	*	and increment pointer
    1286   1308                               	*	Expects:	DAT = full-word of data to write
    1287   1309                               	*	Returns:	No Registers Disturbed
    1288   1310 00005756                      	WRBLK	PUSHM	D0-D3
    1289   1312 0000575A 2238 10A8            		MOVE.L	DAT,D1
    1290   1313 0000575E 21C1 1042            		MOVE.L	D1,P10DAH		; save value to write
    1291   1314                               	 if	BTRACE
    1293   1315                               	 endc
    1294   1316 00005762 4280                 		CLR.L	D0			; compute PDP-address to write to
    1295   1317 00005764 202C 0010            		MOVE.L	BI_TAR(Rp),D0
    1296   1318 00005768 6100 FF0C            		BSR	SETBLKA			; set up the BLOCK-IO address
    1297   1319 0000576C 6100 FF1E            		BSR	WR10R
    1298   1320 00005770 4238 10DE            		CLR.B	BLK			; clear BIO flag
    1299   1321 00005774 52AC 0010            		ADD.L	#1,BI_TAR(Rp)
    1300   1322 00005778                      		POPM	D0-D3
    1301   1324 0000577C 4E75                 		RTS
    1302   1325                               	
    1303   1326                               	*	Get current output word from a storage-block in the PDP-10
    1304   1327                               	*	Returns:	Word into DAT;	No Registers Disturbed
    1305   1328 0000577E                      	GETBLK	PUSHM	D0-D3
    1306   1330 00005782 4280                 		CLR.L	D0			; compute PDP-address to read from
    1307   1331 00005784 202C 0010            		MOVE.L	BI_TAR(Rp),D0
    1308   1332 00005788 6100 FEEC            		BSR	SETBLKA			; set up the BLOCK-IO address
    1309   1333 0000578C 6100 FDE2            		BSR	GETPDPL			; get the word from the ring
    1310   1334 00005790 4238 10DE            		CLR.B	BLK			; clear BIO flag
    1311   1335 00005794 21C1 10A8            		MOVE.L	D1,DAT			; save word read
    1312   1336                               	 if	BTRACE
    1314   1337                               	 endc
    1315   1338 00005798                      		POPM	D0-D3EBUS02.J01                 E B U S  --  PDP-10 Base Code,		P D P   I / O                  8-Oct-87  Page   31
Err Source Ref. Address   value
    line   line

    1316   1340 0000579C 4E75                 		RTS
    1317   1341                               	
    1318   1342                               	
    1319   1343                               	*	Wait for space in PDP ring, then write DAT to it
    1320   1344 0000579E 615C                 	WAITDAT	BSR	WAITPDP			; wait, then go on
    1321   1345                               	
    1322   1346                               	*	Write MSG (from DAT) to PDP ring & update base pointer
    1323   1347 000057A0 2238 10A8            	WRDAT	MOVE.L	DAT,D1			; load it and fall into WRPDP
    1324   1348                               	
    1325   1349                               	*	Write MSG (in D1) to PDP ring & update base pointer
    1326   1350 000057A4                      	WRPDP	PUSHM	D1/D2
    1327   1352                               	 if	RTRACE
    1328   1353 000057A8 6100 FB82            		BSR	TR_ROUT			; record activity in trace
    1329   1354                               	 endc
    1330   1355 000057AC 31F8 1094 1048       		MOVE.W	PDPIRP,P10ADR		; Input ring Start Address
    1331   1356 000057B2 3438 109A            		MOVE.W	PDPIFC,D2		; our fill cursor
    1332   1357 000057B6 D578 1048            		ADD.W	D2,P10ADR		; address in ring
    1333   1358 000057BA 6100 FF6A            		BSR	PUTPDPL
    1334   1359 000057BE 5242                 		ADD.W	#1,D2			; advance cursor
    1335   1360 000057C0 B478 1096            		CMP.W	PDPISZ,D2		; does new cursor = ring size?
    1336   1361 000057C4 6608                 		BNE	WRIRTS			; no
    1337   1362 000057C6 6100 FE34            	WRINRG	BSR	GETIEC			; yes...locate current PDP empty cursor
    1338   1363 000057CA 67FA                 		BEQ	WRINRG			; spin until it moves off 0
    1339   1364 000057CC 4242                 		CLR.W	D2			; ...then wrap our cursor
    1340   1365 000057CE 31C2 109A            	WRIRTS	MOVE.W	D2,PDPIFC		; save new fill cursor
    1341   1366 000057D2                      		POPM	D1/D2
    1342   1368 000057D6 4E75                 		RTS
    1343   1369                               	
    1344   1370                               	*	Write Input-ring Fill Cursor
    1345   1371 000057D8 31FC 006E 1048       	PUTIFC	MOVE.W	#$6E,P10ADR		; at o156
    1346   1372 000057DE 4281                 		CLR.L	D1
    1347   1373 000057E0 3238 109A            		MOVE.W	PDPIFC,D1
    1348   1374 000057E4 6100 FF58            		BSR	PUTPDPR
    1349   1375 000057E8 4E75                 		RTS
    1350   1376                               	
    1351   1377                               	***	Write our Output-ring Empty cursor to PDP
    1352   1378 000057EA 4281                 	PUTOEC	CLR.L	D1
    1353   1379 000057EC 3238 1092            		MOVE.W	PDPOEC,D1
    1354   1380 000057F0 31FC 0072 1048       		MOVE.W	#$72,P10ADR		; at o162
    1355   1381 000057F6 6100 FF46            		BSR	PUTPDPR			; write into PDP
    1356   1382 000057FA 4E75                 		RTS
    1357   1383                               	
    1358   1384                               	
    1359   1385                               	*	Wait until (at least) 4 bytes available in PDP-10 ring
    1360   1386 000057FC 6108                 	WAITPDP	BSR	FDRGSZ			; find ring size
    1361   1387 000057FE 4A78 109C            		TST.W	INRGSP
    1362   1388 00005802 67F8                 		BEQ	WAITPDP			; wait until non-zero
    1363   1389 00005804 4E75                 		RTS
    1364   1390                               	
    1365   1391                               	
    1366   1392                               	*	Find Cursor, then Calculate # of bytes of space left in PDP-10 RingEBUS02.J01                 E B U S  --  PDP-10 Base Code,		P D P   I / O                  8-Oct-87  Page   32
Err Source Ref. Address   value
    line   line

    1367   1393 00005806                      	FDRGSZ	PUSHM	D0/D1
    1368   1395 0000580A 6100 FDF0            		BSR	GETIEC			; first read cursor
    1369   1396 0000580E 3238 1098            		MOVE.W	PDPIEC,D1		; PDP empty pointer
    1370   1397 00005812 9278 109A            		SUB.W	PDPIFC,D1		;  - our fill pointer
    1371   1398 00005816 6F0A                 		BLE	CARWRAP			; ring wrap...skip
    1372   1399 00005818 5341                 		SUB.W	#1,D1			; fill ahead of empty, insure no overflow
    1373   1400 0000581A E549                 		LSL.W	#2,D1			; * 4 to get number of bytes
    1374   1401 0000581C 31C1 109C            		MOVE.W	D1,INRGSP		; this is space available
    1375   1402 00005820 602E                 		BRA	CARRTS
    1376   1403                               	
    1377   1404 00005822 3238 1096            	CARWRAP	MOVE.W	PDPISZ,D1		; empty ahead of fill...
    1378   1405 00005826 9278 109A            		SUB.W	PDPIFC,D1		; ring size - our fill cursor
    1379   1406 0000582A E549                 		LSL.W	#2,D1			; * 4 to get number of bytes
    1380   1407 0000582C 31C1 109C            		MOVE.W	D1,INRGSP		; this is space (to end of ring)
    1381   1408 00005830 3238 109E            		MOVE.W	INTYBT,D1		; check type
    1382   1409 00005834 670C                 		BEQ	NODALN			; Skip if Needle
    1383   1410 00005836 0C41 009E            		CMP.W	#$9E,D1			; Data MSG?
    1384   1411 0000583A 6C06                 		BGE	NODALN			; no...alignment not required
    1385   1412 0000583C 4A78 10A0            		TST.W	PORTNO			; port0 MSG?
    1386   1413 00005840 660E                 		BNE	CARRTS			; no...must be data...just go exit
    1387   1414 00005842 3238 1098            	NODALN	MOVE.W	PDPIEC,D1		; non-data messages CAN wrap in ring!
    1388   1415 00005846 6708                 		BEQ	CARRTS			; no more if null
    1389   1416 00005848 5341                 		SUB.W	#1,D1			; insure no overrun
    1390   1417 0000584A E549                 		LSL.W	#2,D1			; times 4
    1391   1418 0000584C D378 109C            		ADD.W	D1,INRGSP		; actual space allows for wrap
    1392   1419 00005850                      	CARRTS	POPM	D0/D1
    1393   1421 00005854 4E75                 		RTS



    1395   1423                               		TTL	'E B U S  --  PDP-10 Base Code,		B U F F E R   S T U F F'EBUS02.J01                 E B U S  --  PDP-10 Base Code,		B U F F E R   S T U F F        8-Oct-87  Page   33
Err Source Ref. Address   value
    line   line

    1397   1425                               	**********************************
    1398   1426                               	**********************************
    1399   1427                               	**				**
    1400   1428                               	**	Bufferlet Routines	**
    1401   1429                               	**				**
    1402   1430                               	**********************************
    1403   1431                               	**********************************
    1404   1432                               	
    1405   1433                               	*	Character handlers.
    1406   1434                               	*	  These routines pass buffer char in D0
    1407   1435                               	*	  A0/D1 for working registers
    1408   1436                               	
    1409   1437                               	*	Get char from buffer and increment forward thru the buffer.
    1410   1438 00005856 2078 10F4            	DGCI	MOVEA.L	.BFLTS,A0		; get pointer to bufferlets
    1411   1439 0000585A 322C 001A            		MOVE.W	BB(Rp),D1		; Get index to character
    1412   1440 0000585E 4240                 		CLR.W	D0			; return char as word
    1413   1441 00005860 1030 1000            		MOVE.B	0(A0,D1.W),D0		; Pick up char
    1414   1442                               	 if	CTRACE
    1416   1443                               	 endc
    1417   1444 00005864 536C 001E            		SUBQ.W	#1,BCT(Rp)		; Update count
    1418   1445 00005868 6F24                 		BLE	DGCI2			; Skip if no characters left
    1419   1446 0000586A 5241                 		ADDQ.W	#1,D1			; Else increment BB value
    1420   1447 0000586C 3941 001A            		MOVE.W	D1,BB(Rp)		; save pointer
    1421   1448 00005870 0241 000F            		AND.W	#BFLSIZ-1,D1		; Test if at end of bufferlet
    1422   1449 00005874 6616                 		BNE	DGCI1			; skip to exit if not
    1423   1450 00005876 322C 001A            		MOVE.W	BB(Rp),D1		; bufferlet exhausted
    1424   1451 0000587A 3970 1000 001A       		MOVE.W	0(A0,D1.W),BB(Rp)	; get pointer to next bufferlet
    1425   1452 00005880 046C 000E 001A       		SUB.W	#BFLSIZ-2,BB(Rp)	; back it up to beginning of bufferlet
    1426   1453 00005886 3190 1000            		MOVE.W	(A0),0(A0,D1.W)		; Link last bufferlet to free list
    1427   1454 0000588A 3081                 		MOVE.W	D1,(A0)			; And put at the head of the free list
    1428   1455                               	
    1429   1456 0000588C 4E75                 	DGCI1	RTS				; Then exit
    1430   1457                               	
    1431   1458                               	*	Last char in buffer
    1432   1459 0000588E 6D00 F966            	DGCI2	BLT.L	DGCIH			; CRASH if empty
    1433   1460 00005892 0641 000E            		ADD.W	#BFLSIZ-2,D1		; Bump character pointer past
    1434   1461                               	*						end of bufferlet
    1435   1462 00005896 0241 FFF0            		AND.W	#-BFLSIZ,D1		; Make chain a multiple of BFLSIZ
    1436   1463 0000589A 3190 1000            		MOVE.W	(A0),0(A0,D1.W)		; chain free-list to this bufferlet
    1437   1464 0000589E 3081                 		MOVE.W	D1,(A0)			; Update free list
    1438   1465 000058A0 4E75                 		RTS



    1440   1467                               	*	Peek at next char in buffer.
    1441   1468                               	*	return:	CC set EQ if buffer empty
    1442   1469                               	*	else	CC set NE, char in D0.L
    1443   1470                               	*			Unless ESC'ed, then D0 contains -1.W | Char.W
    1444   1471 000058A2 4A6C 001E            	DPEEK	TST.W	BCT(Rp)			; is buffer empty?
    1445   1472 000058A6 673A                 		BEQ	DPEEKX			; exit (CC EQ) if notEBUS02.J01                 E B U S  --  PDP-10 Base Code,		B U F F E R   S T U F F        8-Oct-87  Page   34
Err Source Ref. Address   value
    line   line

    1446   1473 000058A8 2078 10F4            		MOVEA.L	.BFLTS,A0		; get pointer to bufferlets
    1447   1474 000058AC 322C 001A            		MOVE.W	BB(Rp),D1		; Get index to character
    1448   1475 000058B0 4280                 		CLR.L	D0			; return char as long
    1449   1476 000058B2 1030 1000            		MOVE.B	0(A0,D1.W),D0		; Pick up char
    1450   1477 000058B6 0C00 001B            		CMP.B	#ESC,D0			; ESC?
    1451   1478 000058BA 6626                 		BNE	DPEEKX			; exit if not ESC
    1452   1479 000058BC 5241                 		ADDQ.W	#1,D1			; Else increment BB value
    1453   1480 000058BE 0241 000F            		AND.W	#BFLSIZ-1,D1		; Test if at end of bufferlet
    1454   1481 000058C2 660E                 		BNE	DPEEK1			; skip if not
    1455   1482 000058C4 322C 001A            		MOVE.W	BB(Rp),D1		; bufferlet exhausted
    1456   1483 000058C8 3230 1001            		MOVE.W	1(A0,D1.W),D1		; get pointer to next bufferlet
    1457   1484 000058CC 0441 000F            		SUB.W	#BFLSIZ-1,D1		; back it up to beginning of bufferlet
    1458   1485 000058D0 6004                 		BRA	DPEEK2			; and skip
    1459   1486                               	
    1460   1487 000058D2 322C 001A            	DPEEK1	MOVE.W	BB(Rp),D1		; examine next char
    1461   1488                               	
    1462   1489 000058D6 203C FFFF 0000       	DPEEK2	MOVE.L	#$FFFF0000,D0		; ESC'ed char...return -1 in high-word
    1463   1490 000058DC 1030 1001            		MOVE.B	1(A0,D1.W),D0		; ESC'ed char in low word
    1464   1491 000058E0 7201                 		MOVEQ	#1,D1			; insure CC NE
    1465   1492                               	
    1466   1493 000058E2 4E75                 	DPEEKX	RTSEBUS02.J01                 E B U S  --  PDP-10 Base Code,		B U F F E R   S T U F F        8-Oct-87  Page   35
Err Source Ref. Address   value
    line   line

    1468   1495                               	*	Put a character into the buffer
    1469   1496 000058E4 2078 10F4            	DWCI	MOVEA.L	.BFLTS,A0		; get pointer to bufferlet area
    1470   1497                               	 if	CTRACE
    1472   1498                               	 endc
    1473   1499 000058E8 4A6C 001E            		TST.W	BCT(Rp)			; Check count
    1474   1500 000058EC 6F40                 		BLE	DWCI4			; If new buffer, set up attention flags
    1475   1501 000058EE 526C 001E            		ADDQ.W	#1,BCT(Rp)		; Else update count
    1476   1502 000058F2 526C 001C            		ADDQ.W	#1,BE(Rp)		; Advance BE
    1477   1503 000058F6 322C 001C            		MOVE.W	BE(Rp),D1		; Get pointer to new character position
    1478   1504 000058FA 0241 000F            		AND.W	#BFLSIZ-1,D1		; Test if bufferlet full
    1479   1505 000058FE 670A                 		BEQ	DWCI2			; End of bufferlet
    1480   1506 00005900 322C 001C            		MOVE.W	BE(Rp),D1		; ok...get index again
    1481   1507 00005904 1180 1000            		MOVE.B	D0,0(A0,D1.W)		; And save char in buffer
    1482   1508 00005908 4E75                 		RTS
    1483   1509                               	
    1484   1510                               	*	Need a new bufferlet
    1485   1511 0000590A 322C 001C            	DWCI2	MOVE.W	BE(Rp),D1
    1486   1512 0000590E 4A50                 		TST.W	(A0)			; any more bufferlets?
    1487   1513 00005910 6E04                 		BGT	DWCI3			; Skip if there is another
    1488   1514 00005912 6100 0040            		 BSR.L	WRE			; (Else open the reserve tank)
    1489   1515                               	
    1490   1516 00005916 3190 1000            	DWCI3	MOVE.W	(A0),0(A0,D1.W)		; Link new bufferlet to last one
    1491   1517 0000591A 3210                 		MOVE.W	(A0),D1			; And remove from free list
    1492   1518 0000591C 30B0 1000            		MOVE.W	0(A0,D1.W),(A0)
    1493   1519 00005920 0441 000E            		SUB.W	#BFLSIZ-2,D1		; Back up new bufferlet
    1494   1520 00005924 3941 001C            		MOVE.W	D1,BE(Rp)		; Save as new BE
    1495   1521 00005928 1180 1000            		MOVE.B	D0,0(A0,D1.W)		; Put the character there
    1496   1522 0000592C 4E75                 		RTS
    1497   1523                               	
    1498   1524                               	*	The buffer was empty
    1499   1525 0000592E 6D00 F8CE            	DWCI4	BLT.L	DWCIH			; count should NEVER be negative
    1500   1526 00005932 526C 001E            		ADD.W	#1,BCT(Rp)		; Set count = 1
    1501   1527 00005936 4A50                 		TST.W	(A0)			; Any buffers on free-list?
    1502   1528 00005938 6E02                 		BGT	DWCI5			; Skip if there was one
    1503   1529 0000593A 6118                 		 BSR	WRE			; Else open the reserve tank
    1504   1530                               	
    1505   1531 0000593C 3210                 	DWCI5	MOVE.W	(A0),D1			; Pop a bufferlet off free list
    1506   1532 0000593E 30B0 1000            		MOVE.W	0(A0,D1.W),(A0)		; Update free list
    1507   1533 00005942 0441 000E            		SUB.W	#BFLSIZ-2,D1		; Point it at first character
    1508   1534 00005946 3941 001A            		MOVE.W	D1,BB(Rp)		; Set up BB
    1509   1535 0000594A 3941 001C            		MOVE.W	D1,BE(Rp)		; And BE
    1510   1536 0000594E 1180 1000            		MOVE.B	D0,0(A0,D1.W)		; Put the character there
    1511   1537 00005952 4E75                 		RTSEBUS02.J01                 E B U S  --  PDP-10 Base Code,		B U F F E R   S T U F F        8-Oct-87  Page   36
Err Source Ref. Address   value
    line   line

    1513   1539                               	*	Move reserve storage supply to main free list
    1514   1540 00005954 30B8 10FA            	WRE	MOVE.W	R_TANK,(A0)		; Get pointer to reserve bufferlets
    1515   1541 00005958 6F00 006E            		BLE.L	WREH			; was empty...abort
    1516   1542 0000595C 4278 10FA            		CLR.W	R_TANK			; Set reserve bufferlets empty (=0)
    1517   1543 00005960 4E75                 		RTS




    1519   1545                               	*	Return all the space used by the buffer
    1520   1546                               	
    1521   1547 00005962 4A6C 001E            	DEMPTY	TST.W	BCT(Rp)			; Check contents
    1522   1548 00005966 6726                 		BEQ	C1			; empty...just exit
    1523   1549 00005968 426C 001E            		CLR.W	BCT(Rp)			; not empty...set count = 0
    1524   1550                               	 if	CTRACE
    1526   1551                               	 endc
    1527   1552 0000596C 2078 10F4            		MOVEA.L	.BFLTS,A0		; get pointer to bufferlet area
    1528   1553 00005970 302C 001C            		MOVE.W	BE(Rp),D0		; Get pointer to last character in buffer
    1529   1554 00005974 0640 000E            		ADD.W	#BFLSIZ-2,D0		; Locate the pointer in this bufferlet
    1530   1555 00005978 0240 FFF0            		AND.W	#-BFLSIZ,D0
    1531   1556 0000597C 3190 0000            		MOVE.W	(A0),0(A0,D0.W)		; Chain previous free list to this
    1532   1557                               	*						bufferlet
    1533   1558 00005980 302C 001A            		MOVE.W	BB(Rp),D0		; Pointer to first char in buffer
    1534   1559 00005984 0640 000E            		ADD.W	#BFLSIZ-2,D0
    1535   1560 00005988 0240 FFF0            		AND.W	#-BFLSIZ,D0
    1536   1561 0000598C 3080                 		MOVE.W	D0,(A0)			; Put the buffer's bufferlets
    1537   1562                               	*						onto free list
    1538   1563 0000598E 70FF                 	C1	MOVEQ	#-1,D0			; "empty" flag
    1539   1564 00005990 4E75                 		RTS				; And return



    1541   1566                               		TTL	'E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G'EBUS02.J01                 E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G    8-Oct-87  Page   37
Err Source Ref. Address   value
    line   line

    1543   1568                               	*	ERROR CONDITION DETECTED, CRASH INTERFACE
    1544   1569                               	
    1545   1570                               	
    1546   1571 00005992                      	NOKEY	CRASH	0			; key not refreshed by host
    1547   1574                               	
    1548   1575 0000599A                      	BADKEY	CRASH	3			; bad key read from host
    1549   1578                               	
    1550   1579                               	*	Crash due to bad Message Type
    1551   1580 000059A2 21F8 10A8 100C       	MERROR	MOVE.L	DAT,CASHW		; save copy of DAT
    1552   1581 000059A8                      		CRASH	4			; crash the interface
    1553   1584                               	
    1554   1585                               	*	Crash due to MIC timeout
    1555   1586 000059B0                      	TMOUT1	CRASH	8
    1556   1589                               	
    1557   1590                               	*	Crash due to MIC parity error
    1558   1591 000059B8                      	PARERR	CRASH	9
    1559   1594                               	
    1560   1595                               	*	Crash due to  MIC too busy too long
    1561   1596 000059C0                      	BUSCRAS	CRASH	10
    1562   1599                               	
    1563   1600 000059C8 11FC 0015 1004       	WREH	MOVE.B	#21,CODCASH		; WRE crash
    1564   1601                               	
    1565   1602                               	*	Routine that crashes the host for interface problems
    1566   1603 000059CE 4FF8 1000            	VCRASH	LEA	STKTOP,SP		; reset stack
    1567   1604 000059D2 4A38 1108            		TST.B	DIAG
    1568   1605 000059D6 6600 2446            		BNE.L	DIAGERR
    1569   1606 000059DA 4A79 00D0 1038       		TST.W	DEXCO			; Reset EBUS
    1570   1607 000059E0 610C                 		BSR	HODOWN			; set host down
    1571   1608 000059E2 6100 FD10            		BSR	HCRASH			; crash the host
    1572   1609 000059E6 6100 00E2            		BSR.L	EMPTY			; Empty ISIS ring
    1573   1610 000059EA 6000 01CE            		BRA.L	EXEC			; and start over
    1574   1611                               	
    1575   1612                               	
    1576   1613                               	*	HODOWN - Set HTDWN and report host down
    1577   1614 000059EE 7801                 	HODOWN	MOVEQ	#1,D4
    1578   1615 000059F0 11C4 108B            		MOVE.B	D4,HTDWN		; set down and fall through...
    1579   1616                               	
    1580   1617                               	*	HDOWN -	Report Host Down or Gone
    1581   1618                               	*	D4 = 1 for Down, 3 for Gone (B)
    1582   1619 000059F4 1038 104E            	HDOWN	MOVE.B	HSTAT,D0		; going down and already down/gone?
    1583   1620 000059F8 C004                 		AND.B	D4,D0			; or going gone and already gone?
    1584   1621 000059FA B900                 		EOR.B	D4,D0
    1585   1622 000059FC 6738                 		BEQ	HDN4			; yes...nothing to be done
    1586   1623 000059FE 11C4 104E            		MOVE.B	D4,HSTAT		; no...change required
    1587   1624 00005A02 6100 0084            		BSR.L	HREPRT			; report it
    1588   1625 00005A06 303C 00FF            		MOVE.W	#MAXPORT-1,D0		; for all ports...
    1589   1626 00005A0A 612C                 	HDN1	BSR	SETPORT			; set up port
    1590   1627 00005A0C 082C 0000 0001       		BTST	#PF_ACT,P_FLAGS(Rp)	; test if port is active
    1591   1628 00005A12 6608                 		BNE	HDN2			; yes
    1592   1629 00005A14 082C 0001 0001       		BTST	#PF_ILI,P_FLAGS(Rp)	; test if port is In_LogInEBUS02.J01                 E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G    8-Oct-87  Page   38
Err Source Ref. Address   value
    line   line

    1593   1630 00005A1A 6712                 		BEQ	HDN3			; no
    1594   1631 00005A1C 612A                 	HDN2	BSR	RBTALL			; yes...reset everything
    1595   1632 00005A1E 6100 0156            		BSR.L	DPORT			;  ...and remember to reduce the port-count
    1596   1633 00005A22 3638 10A0            		MOVE.W	PORTNO,D3		; Port #
    1597   1634 00005A26 183C 009F            		MOVE.B	#$9F,D4			; ZAPPER
    1598   1635 00005A2A 6100 F9C4            		BSR	SENDQI			; send Quick ISIS message
    1599   1636 00005A2E 3038 10A0            	HDN3	MOVE.W	PORTNO,D0		; on to next port
    1600   1637 00005A32 5340                 		SUB.W	#1,D0
    1601   1638 00005A34 6ED4                 		BGT	HDN1
    1602   1639 00005A36 4E75                 	HDN4	RTS				; done...exit
    1603   1640                               	
    1604   1641                               	
    1605   1642                               	*	set up Rp, PORTNO
    1606   1643                               	*	Expect:	D0 = port number (W)
    1607   1644                               	*	Return:	D0 smashed, Rp set up
    1608   1645 00005A38 31C0 10A0            	SETPORT	MOVE.W	D0,PORTNO		; set up port number
    1609   1646 00005A3C C0FC 0020            		MULU	#PD_SIZ,D0		; compute offset into port-descriptor
    1610   1647 00005A40 49F8 190A            		LEA	PORTS,Rp
    1611   1648 00005A44 D8C0                 		ADD.W	D0,Rp			; compute address of port-descriptor
    1612   1649 00005A46 4E75                 		RTS
    1613   1650                               	
    1614   1651                               	
    1615   1652                               	
    1616   1653                               	*	Special routine to manipulate bits-flags
    1617   1654                               	
    1618   1655                               	*	Reset everything...
    1619   1656 00005A48 6100 073E            	RBTALL	BSR.L	RBTBKO			; cancel block-output
    1620   1657 00005A4C 6100 0766            		BSR.L	RBTBKI			; cancel block-input
    1621   1658 00005A50 6100 FF10            		BSR	DEMPTY			; empty any buffer storage
    1622   1659 00005A54 6100 076C            		BSR.L	RBTBUF			; clean up buffer usage
    1623   1660 00005A58 422C 0001            		CLR.B	P_FLAGS(Rp)		; clear everything
    1624   1661 00005A5C 197C 009D 0002       		MOVE.B	#157,XMITLMT(Rp)	; initialize transmit limit
    1625   1662 00005A62 4E75                 		RTS
    1626   1663                               	
    1627   1664                               	
    1628   1665                               	*	Verify KEY-cell in PDP-10...
    1629   1666                               	*	If expected (i.e., $CDFA68CB2), zero out key, return CC EQ
    1630   1667                               	*	Else return CC NE
    1631   1668 00005A64 31FC 0068 1048       	DOKEY	MOVE.W	#$68,P10ADR		; get KEY at o150
    1632   1669 00005A6A 6100 FB16            		BSR	GETPDPR			; get (right) bits
    1633   1670 00005A6E 0C81 DFA6 8CB2       		CMP.L	#$DFA68CB2,D1
    1634   1671 00005A74 6610                 		BNE	DOKEYX			; no match...return with CC set NE
    1635   1672 00005A76 0C38 00CD 1042       		CMP.B	#$CD,P10DAH		; check high bits
    1636   1673 00005A7C 6608                 		BNE	DOKEYX			; no match...return with CC set NE
    1637   1674 00005A7E 4281                 		CLR.L	D1			; match...zero out the key
    1638   1675 00005A80 6100 FCBC            		BSR	PUTPDPR
    1639   1676 00005A84 9241                 		SUB.W	D1,D1			; insure CC set EQ
    1640   1677 00005A86 4E75                 	DOKEYX	RTS				; return
    1641   1678                               	
    1642   1679                               	
    1643   1680                               	*	HREPRT - Report Host status to SupEBUS02.J01                 E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G    8-Oct-87  Page   39
Err Source Ref. Address   value
    line   line

    1644   1681 00005A88 700E                 	HREPRT	MOVEQ	#14,D0			; we'll need 14 bytes of space in ring
    1645   1682 00005A8A 6100 F8DA            		BSR	WAITIS			; wait until it's there
    1646   1683 00005A8E 4243                 		CLR.W	D3			; for Port 0
    1647   1684 00005A90 7810                 		MOVEQ	#$10,D4			; Message Type 10
    1648   1685 00005A92 6100 F8E4            		BSR	SLOR
    1649   1686 00005A96 4200                 		CLR.B	D0			; padding (B)
    1650   1687 00005A98 6100 F8FE            		BSR	PUTCH
    1651   1688 00005A9C 3038 104A            		MOVE.W	HOSTN,D0		; Host Number (HW)
    1652   1689 00005AA0 6726                 		BEQ	HREPRTX			; abort if null host-number
    1653   1690 00005AA2 6100 F924            		BSR	PUTH
    1654   1691 00005AA6 3038 104C            		MOVE.W	HOSTP,D0		; Host Ports (HW)
    1655   1692 00005AAA 6100 F91C            		BSR	PUTH
    1656   1693 00005AAE 4240                 		CLR.W	D0			; Relative Host# = 0 (HW)
    1657   1694 00005AB0 6100 F916            		BSR	PUTH
    1658   1695 00005AB4 3038 104E            		MOVE.W	HSTAT,D0		; Status | Hkey=0 (HW)
    1659   1696 00005AB8 6100 F90E            		BSR	PUTH
    1660   1697 00005ABC 303C 0091            		MOVE.W	#PRODID,D0		; No IIX | ProductID (HW)
    1661   1698 00005AC0 6100 F906            		BSR	PUTH
    1662   1699 00005AC4 6100 F930            		BSR	ELOR
    1663   1700 00005AC8 4E75                 	HREPRTX	RTS
    1664   1701                               	
    1665   1702                               	
    1666   1703                               	*	EMPTY - EMPTY OUT ISIS INPUT RING
    1667   1704 00005ACA 6100 F95A            	EMPTY	BSR	LOOK			; see what's next in ring
    1668   1705 00005ACE 6602                 		BNE	EMP1
    1669   1706 00005AD0 4E75                 		RTS				; return..ring is empty
    1670   1707                               	
    1671   1708 00005AD2 4A43                 	EMP1	TST.W	D3			; check port number
    1672   1709 00005AD4 6724                 		BEQ	EMP2			; port0 = intra-node message
    1673   1710 00005AD6 3004                 		MOVE.W	D4,D0			; Check for Needle
    1674   1711 00005AD8 6738                 		BEQ	EMP5			; special handling for needles
    1675   1712 00005ADA 0C40 00B2            		CMP.W	#$B2,D0			; Check for Pseudo-needle
    1676   1713 00005ADE 6740                 		BEQ	EMP6			; special handling for P-needles
    1677   1714 00005AE0 0C40 009D            		CMP.W	#$9D,D0			; in range of data message?
    1678   1715 00005AE4 6F26                 		BLE	EMP4			; Just flush data
    1679   1716 00005AE6 0C40 00C1            		CMP.W	#$C1,D0			; range check
    1680   1717 00005AEA 6C00 F6EE            		BGE	ISMGER
    1681   1718 00005AEE 0444 009E            		SUB.W	#$9E,D4
    1682   1719 00005AF2 41F8 5B2C 4E71       		LEA	IMSSZ,A0
    1683   1720 00005AF8 600E                 		BRA	EMP3
    1684   1721                               	
    1685   1722                               	*	Flush port0 messages
    1686   1723 00005AFA 0C44 000E            	EMP2	CMP.W	#$0E,D4			; range check
    1687   1724 00005AFE 6C00 F6DA            		BGE	ISMGER
    1688   1725 00005B02 41F8 5B50 4E71       		LEA	IPZSZ,A0
    1689   1726                               	
    1690   1727 00005B08 1030 4000            	EMP3	MOVE.B	0(A0,D4.W),D0		; table lookup for message length
    1691   1728                               	
    1692   1729 00005B0C 6100 F996            	EMP4	BSR	FLUSH			; remove MSG from ring
    1693   1730 00005B10 60B8                 		BRA	EMPTY			; ...and get next one
    1694   1731                               	EBUS02.J01                 E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G    8-Oct-87  Page   40
Err Source Ref. Address   value
    line   line

    1695   1732                               	*	Needle
    1696   1733 00005B12 183C 009F            	EMP5	MOVE.B	#$9F,D4			; ZAPPER
    1697   1734 00005B16 6100 F8D8            		BSR	SENDQI			; send Quick Message to ISIS
    1698   1735 00005B1A 6100 F92E            		BSR	GETCH			; get needle-length
    1699   1736 00005B1E 60EC                 		BRA	EMP4
    1700   1737                               	
    1701   1738                               	*	Psuedo-needle
    1702   1739 00005B20 183C 009F            	EMP6	MOVE.B	#$9F,D4			; ZAPPER
    1703   1740 00005B24 6100 F8CA            		BSR	SENDQI			; send Quick Message to ISIS
    1704   1741 00005B28 7003                 		MOVEQ	#3,D0			; set pseudo-needle length
    1705   1742 00005B2A 60E0                 		BRA	EMP4
    1706   1743                               	
    1707   1744                               	
    1708   1745                               	*	ISIS INPUT MESSAGE LENGTHS (NOT COUNTING PORT NMBR)
    1709   1746 00005B2C 00                   	IMSSZ	DC.B	0			; 9E
    1710   1747 00005B2D 00                   		DC.B	0			; 9F
    1711   1748 00005B2E 00                   		DC.B	0			; A0
    1712   1749 00005B2F 00                   		DC.B	0			; A1
    1713   1750 00005B30 00                   		DC.B	0			; A2
    1714   1751 00005B31 00                   		DC.B	0			; A3
    1715   1752 00005B32 00                   		DC.B	0			; A4
    1716   1753 00005B33 00                   		DC.B	0			; A5
    1717   1754 00005B34 00                   		DC.B	0			; A6
    1718   1755 00005B35 00                   		DC.B	0			; A7
    1719   1756 00005B36 00                   		DC.B	0			; A8
    1720   1757 00005B37 00                   		DC.B	0			; A9
    1721   1758 00005B38 00                   		DC.B	0			; AA
    1722   1759 00005B39 00                   		DC.B	0			; AB
    1723   1760 00005B3A 00                   		DC.B	0			; AC
    1724   1761 00005B3B 00                   		DC.B	0			; AD
    1725   1762 00005B3C 00                   		DC.B	0			; AE
    1726   1763 00005B3D 00                   		DC.B	0			; AF
    1727   1764 00005B3E 01                   		DC.B	1			; B0
    1728   1765 00005B3F 02                   		DC.B	2			; B1
    1729   1766 00005B40 03                   		DC.B	3			; B2
    1730   1767 00005B41 01                   		DC.B	1			; B3
    1731   1768 00005B42 01                   		DC.B	1			; B4
    1732   1769 00005B43 01                   		DC.B	1			; B5
    1733   1770 00005B44 07                   		DC.B	7			; B6
    1734   1771 00005B45 05                   		DC.B	5			; B7
    1735   1772 00005B46 00                   		DC.B	0			; B8
    1736   1773 00005B47 01                   		DC.B	1			; B9
    1737   1774 00005B48 00                   		DC.B	0			; BA
    1738   1775 00005B49 00                   		DC.B	0			; BB
    1739   1776 00005B4A 00                   		DC.B	0			; BC
    1740   1777 00005B4B 00                   		DC.B	0			; BD
    1741   1778 00005B4C 01                   		DC.B	1			; BE
    1742   1779 00005B4D 00                   		DC.B	0			; BF
    1743   1780 00005B4E 00                   		DC.B	0			; C0
    1744   1781 00005B4F 05                   		DC.B	5			; C1
    1745   1782                               	EBUS02.J01                 E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G    8-Oct-87  Page   41
Err Source Ref. Address   value
    line   line

    1746   1783                               	
    1747   1784                               	*	ISIS INTRA-NODE MESSAGE LENGTHS
    1748   1785 00005B50 00                   	IPZSZ	DC.B	0			; 00
    1749   1786 00005B51 00                   		DC.B	0			; 01
    1750   1787 00005B52 01                   		DC.B	1			; 02
    1751   1788 00005B53 06                   		DC.B	6			; 03
    1752   1789 00005B54 09                   		DC.B	9			; 04
    1753   1790 00005B55 05                   		DC.B	5			; 05
    1754   1791 00005B56 05                   		DC.B	5			; 06
    1755   1792 00005B57 08                   		DC.B	8			; 07
    1756   1793 00005B58 08                   		DC.B	8			; 08
    1757   1794 00005B59 04                   		DC.B	4			; 09
    1758   1795 00005B5A 07                   		DC.B	7			; 0A
    1759   1796 00005B5B 04                   		DC.B	4			; 0B
    1760   1797 00005B5C 07                   		DC.B	7			; 0C
    1761   1798 00005B5D 00                   		DC.B	0			; 0D



    1763   1800                               	*		Host-port Management (soft Shut/Answer)
    1764   1801                               	
    1765   1802                               	
    1766   1803                               	*	IPORT - INCREMENT NUMBER OF PORTS
    1767   1804 00005B5E 5278 1058            	IPORT	ADD.W	#1,NPORTS		; increment number
    1768   1805 00005B62 3038 1058            		MOVE.W	NPORTS,D0
    1769   1806 00005B66 B078 1056            		CMP.W	MXPORT,D0
    1770   1807 00005B6A 6E02                 		BGT	IPORT2			; reached limit
    1771   1808 00005B6C 4E75                 	IPORT1	RTS
    1772   1809                               	
    1773   1810 00005B6E 11FC 0001 1107       	IPORT2	MOVE.B	#1,PFULL		; full (shutable)
    1774   1811 00005B74 6012                 		BRA	DPORT1
    1775   1812                               	
    1776   1813                               	
    1777   1814                               	*	DPORT - DECREMENT NUMBER OF PORTS
    1778   1815 00005B76 5378 1058            	DPORT	SUB.W	#1,NPORTS		; decrement number
    1779   1816 00005B7A 3038 1058            		MOVE.W	NPORTS,D0
    1780   1817 00005B7E B078 1056            		CMP.W	MXPORT,D0
    1781   1818 00005B82 66E8                 		BNE	IPORT1			; not at limit
    1782   1819 00005B84 4238 1107            		CLR.B	PFULL			; not full (answerable)
    1783   1820                               	
    1784   1821 00005B88 700A                 	DPORT1	MOVEQ	#10,D0			; need 10 bytes for Message
    1785   1822 00005B8A 6100 F7DA            		BSR	WAITIS			; insure there is room there
    1786   1823 00005B8E 4243                 		CLR.W	D3			; port 0,
    1787   1824 00005B90 780A                 		MOVEQ	#10,D4			; message type 10d
    1788   1825 00005B92 6100 F7E4            		BSR	SLOR
    1789   1826 00005B96 4200                 		CLR.B	D0			; 1 byte of padding
    1790   1827 00005B98 6100 F7FE            		BSR	PUTCH
    1791   1828 00005B9C 3038 104A            		MOVE.W	HOSTN,D0		; Host number (HW)
    1792   1829 00005BA0 6100 F826            		BSR	PUTH
    1793   1830 00005BA4 7001                 		MOVEQ	#1,D0
    1794   1831 00005BA6 9038 1107            		SUB.B	PFULL,D0		; soft shut/answer (HW)EBUS02.J01                 E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G    8-Oct-87  Page   42
Err Source Ref. Address   value
    line   line

    1795   1832 00005BAA 6100 F81C            		BSR	PUTH
    1796   1833 00005BAE 4240                 		CLR.W	D0			; only host is 0 (HW)
    1797   1834 00005BB0 6100 F816            		BSR	PUTH
    1798   1835 00005BB4 6100 F840            		BSR	ELOR
    1799   1836 00005BB8 4E75                 		RTS



    1801   1838                               		TTL	'E B U S  --  PDP-10 Base Code,		E X E C   L O O P'EBUS02.J01                 E B U S  --  PDP-10 Base Code,		E X E C   L O O P              8-Oct-87  Page   43
Err Source Ref. Address   value
    line   line

    1803   1840                               	
    1804   1841                               	
    1805   1842 00005BBA BFFC 0000 1000       	EXEC	CMPA.L	#STKTOP,SP		; if stack is empty,
    1806   1843 00005BC0 670A                 		BEQ	EXEC1			; then everything is OK...
    1807   1844 00005BC2                      		FCRASH	$60			; Else, something is dreadfully WRONG!
    1808   1847                               	
    1809   1848 00005BCC 2078 102A            	EXEC1	MOVE.L	.SYNC,A0		; get sync address
    1810   1849 00005BD0 3010                 		MOVE.W	(A0),D0			; did slot get back before us?
    1811   1850 00005BD2 6D0E                 		BLT	EXEC4			; yes
    1812   1851 00005BD4 9150                 		SUB.W	D0,(A0)			; no...set to 0
    1813   1852                               	
    1814   1853 00005BD6 303C 0064            	EXEC2	MOVE.W	#100,D0			; wait-loop
    1815   1854 00005BDA 5340                 	EXEC3	SUB.W	#1,D0
    1816   1855 00005BDC 6EFC                 		BGT	EXEC3			; insure we don't tie up DMA
    1817   1856 00005BDE 4A50                 		TST.W	(A0)			; waiting for slot to set it
    1818   1857 00005BE0 6CF4                 		BGE	EXEC2
    1819   1858                               	
    1820   1859                               	*	we set SYNC to 1 while we are executing, 0 when we're done
    1821   1860                               	*	Slot sets it to -1, and uses the number to generate speedometer.
    1822   1861 00005BE2 30BC 0001            	EXEC4	MOVE.W	#1,(A0)			; Syncronized...reset it and proceed
    1823   1862 00005BE6 3038 104A            		MOVE.W	HOSTN,D0		; now get host #
    1824   1863 00005BEA E148                 		LSL.W	#8,D0
    1825   1864 00005BEC 8078 1058            		OR.W	NPORTS,D0		; and get # ports
    1826   1865 00005BF0 3140 0002            		MOVE.W	D0,2(A0)		; give slot <HOST# | #PORTS> to display
    1827   1866 00005BF4 3178 104E 0004       		MOVE.W	HSTAT,4(A0)		; give slot <HSTAT> to display
    1828   1867 00005BFA 31F8 103E 10F0       		MOVE.W	IRSIZE,IRRN		; set "throttles"
    1829   1868 00005C00 31F8 108E 10F2       		MOVE.W	PDPOSZ,ORRN		;  (one "rings"-worth)



    1831   1870                               		TTL	'E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T'EBUS02.J01                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T          8-Oct-87  Page   44
Err Source Ref. Address   value
    line   line

    1833   1872                               	*		O U T P U T   F R O M   P D P - 1 0   T O   I S I S
    1834   1873                               	
    1835   1874                               	
    1836   1875                               	
    1837   1876 00005C06 4A38 108B            	HOSTOUT	TST.B	HTDWN			; check host status
    1838   1877 00005C0A 6600 0080            		BNE.L	HOUTX			; Host Down..Skip
    1839   1878 00005C0E 6100 FBDA            		BSR	PUTOEC
    1840   1879 00005C12 4A78 10F2            		TST.W	ORRN
    1841   1880 00005C16 6D74                 		BLT	HOUTX
    1842   1881 00005C18 6100 F9F2            		BSR	GETOFC			; Read PDP output Fill cursor
    1843   1882 00005C1C 3238 1090            		MOVE.W	PDPOFC,D1		; PDP cursor == Our cursor?
    1844   1883 00005C20 9278 1092            		SUB.W	PDPOEC,D1
    1845   1884 00005C24 6766                 		BEQ	HOUTX			; Yes...ring empty, go to exit
    1846   1885 00005C26 6100 F978            		BSR	RDPDP			; no...read a message
    1847   1886 00005C2A 11F8 10A8 108A       		MOVE.B	DAT1,TYPBYT		; extract TYPE byte
    1848   1887 00005C30 4240                 		CLR.W	D0			; extract port-number
    1849   1888 00005C32 1038 10A9            		MOVE.B	DAT2,D0
    1850   1889 00005C36 6100 FE00            		BSR	SETPORT			; set up ports
    1851   1890 00005C3A 6100 0096            		BSR.L	GEHTLN			; compute ISIS message-length needed
    1852   1891 00005C3E 6100 F700            		BSR	ROOM			; enough room in ORING?
    1853   1892 00005C42 6636                 		BNE	HOUT2			; no...go do input
    1854   1893 00005C44 1238 108A            		MOVE.B	TYPBYT,D1		; check for messages which require response
    1855   1894 00005C48 6D46                 		BLT	TEXTMSG			; TYP > 80 "looks" < 0, is data
    1856   1895 00005C4A 0C01 002E            		CMP.B	#$2E,D1			; Block IO
    1857   1896 00005C4E 671A                 		BEQ	HOUT1
    1858   1897 00005C50 0C01 001F            		CMP.B	#$1F,D1			; Probe (query) Terminal Characteristics?
    1859   1898 00005C54 6714                 		BEQ	HOUT1
    1860   1899 00005C56 0C01 0022            		CMP.B	#$22,D1			; Sup Clock Request?
    1861   1900 00005C5A 670E                 		BEQ	HOUT1
    1862   1901 00005C5C 0C01 0016            		CMP.B	#$16,D1			; Supervisor (Aux Circuit) request?
    1863   1902 00005C60 6708                 		BEQ	HOUT1
    1864   1903 00005C62 0C01 0019            		CMP.B	#$19,D1			; Test Pattern Probe?
    1865   1904 00005C66 6600 00B8            		BNE.L	OTFRHST			; none of the above
    1866   1905 00005C6A 6100 FB9A            	HOUT1	BSR	FDRGSZ			; find the PDP's input ring size
    1867   1906 00005C6E 3238 109C            		MOVE.W	INRGSP,D1
    1868   1907 00005C72 0C41 0008            		CMP.W	#8,D1
    1869   1908 00005C76 6C00 00A8            		BGE.L	OTFRHST			; more than 8 bytes available, go DO IT!
    1870   1909                               	
    1871   1910 00005C7A 3038 1092            	HOUT2	MOVE.W	PDPOEC,D0		; Can't process message at this time...
    1872   1911 00005C7E 5340                 		SUB.W	#1,D0			; back up our cursor
    1873   1912 00005C80 6C06                 		BGE	HOUT3
    1874   1913 00005C82 3038 108E            		MOVE.W	PDPOSZ,D0		; wrapped backward...re-cycle
    1875   1914 00005C86 5340                 		SUB.W	#1,D0
    1876   1915 00005C88 31C0 1092            	HOUT3	MOVE.W	D0,PDPOEC
    1877   1916                               	
    1878   1917 00005C8C 6000 061A            	HOUTX	BRA.L	ISISIN			; now try to do ISIS input
    1879   1918                               	
    1880   1919                               	
    1881   1920                               	*	Process Output Data Messages
    1882   1921 00005C90 3638 10A0            	TEXTMSG	MOVE.W	PORTNO,D3		; for this portEBUS02.J01                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T          8-Oct-87  Page   45
Err Source Ref. Address   value
    line   line

    1883   1922 00005C94 1838 108A            		MOVE.B	TYPBYT,D4
    1884   1923 00005C98 0404 0080            		SUB.B	#$80,D4			; message type is length
    1885   1924 00005C9C 1404                 		MOVE.B	D4,D2			; save copy for counter
    1886   1925 00005C9E 6100 F6D8            		BSR	SLOR
    1887   1926 00005CA2 43F8 10AA            		LEA	DAT3,A1			; pointer to first byte to transfer
    1888   1927 00005CA6 1019                 	TEXTLOP	MOVE.B	(A1)+,D0		; next byte
    1889   1928 00005CA8 6100 F6EE            		BSR	PUTCH
    1890   1929 00005CAC 5302                 		SUB.B	#1,D2			; Done yet?
    1891   1930 00005CAE 6710                 		BEQ	TEXTEND			; yes
    1892   1931 00005CB0 B2FC 10AC            		CMPA.W	#DAT5,A1		; have we exhausted this DAT?
    1893   1932 00005CB4 66F0                 		BNE	TEXTLOP			; no
    1894   1933 00005CB6 6100 F8E8            		BSR	RDPDP			; yes...get another
    1895   1934 00005CBA 43F8 10A8            		LEA	DAT1,A1			; re-init pointer
    1896   1935 00005CBE 60E6                 		BRA	TEXTLOP			; and proceed
    1897   1936                               	
    1898   1937 00005CC0 082C 0000 0001       	TEXTEND	BTST	#PF_ACT,P_FLAGS(Rp)	; Done...is this port active?
    1899   1938 00005CC6 6700 FF3E            		BEQ	HOSTOUT			: not active...forget it
    1900   1939 00005CCA 6100 F72A            		BSR	ELOR			; send block on it's way
    1901   1940 00005CCE 6000 FF36            		BRA	HOSTOUT			; go for next message
    1902   1941                               	
    1903   1942                               	
    1904   1943                               	*	Get length of Message (translate PDP MSG type to ISIS length)
    1905   1944                               	*	Returns:	length in D0, A0 smashed
    1906   1945 00005CD2 4240                 	GEHTLN	CLR.W	D0
    1907   1946 00005CD4 1038 108A            		MOVE.B	TYPBYT,D0		; get type byte
    1908   1947 00005CD8 6D06                 		BLT	NOCAL			; skip if data message (x80+ "looks" <0 )
    1909   1948 00005CDA 103B 000A            		MOVE.B	TRHSTLN(PC,D0.W),D0	; look up length
    1910   1949 00005CDE 6004                 		BRA	NOCAL5
    1911   1950                               	
    1912   1951                               	*	Data message is $80 + length
    1913   1952 00005CE0 0400 007D            	NOCAL	SUB.B	#$80-3,D0		; remove bias, allow for ISIS header
    1914   1953 00005CE4 4E75                 	NOCAL5	RTS
    1915   1954                               	
    1916   1955                               	
    1917   1956                               	*	TRANSLATED HOST MSG LENGTH
    1918   1957 00005CE6 00                   	TRHSTLN	DC.B	0			; 00
    1919   1958 00005CE7 0C                   		DC.B	12			; 01
    1920   1959 00005CE8 0C                   		DC.B	12			; 02
    1921   1960 00005CE9 00                   		DC.B	0			; 03
    1922   1961 00005CEA 00                   		DC.B	0			; 04
    1923   1962 00005CEB 00                   		DC.B	0			; 05
    1924   1963 00005CEC 00                   		DC.B	0			; 06
    1925   1964 00005CED 00                   		DC.B	0			; 07
    1926   1965 00005CEE 03                   		DC.B	3			; 08
    1927   1966 00005CEF 03                   		DC.B	3			; 09
    1928   1967 00005CF0 03                   		DC.B	3			; 0A
    1929   1968 00005CF1 03                   		DC.B	3			; 0B
    1930   1969 00005CF2 03                   		DC.B	3			; 0C
    1931   1970 00005CF3 03                   		DC.B	3			; 0D
    1932   1971 00005CF4 03                   		DC.B	3			; 0E
    1933   1972 00005CF5 03                   		DC.B	3			; 0FEBUS02.J01                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T          8-Oct-87  Page   46
Err Source Ref. Address   value
    line   line

    1934   1973 00005CF6 03                   		DC.B	3			; 10
    1935   1974 00005CF7 03                   		DC.B	3			; 11
    1936   1975 00005CF8 03                   		DC.B	3			; 12
    1937   1976 00005CF9 03                   		DC.B	3			; 13
    1938   1977 00005CFA 03                   		DC.B	3			; 14
    1939   1978 00005CFB 00                   		DC.B	0			; 15
    1940   1979 00005CFC 04                   		DC.B	4			; 16 ****
    1941   1980 00005CFD 00                   		DC.B	0			; 17
    1942   1981 00005CFE 34                   		DC.B	52			; 18
    1943   1982 00005CFF 06                   		DC.B	6			; 19 ****
    1944   1983 00005D00 00                   		DC.B	0			; 1A
    1945   1984 00005D01 00                   		DC.B	0			; 1B
    1946   1985 00005D02 05                   		DC.B	5			; 1C
    1947   1986 00005D03 05                   		DC.B	5			; 1D
    1948   1987 00005D04 05                   		DC.B	5			; 1E
    1949   1988 00005D05 64                   		DC.B	100			; 1F ****
    1950   1989 00005D06 00                   		DC.B	0			; 20
    1951   1990 00005D07 0C                   		DC.B	12			; 21
    1952   1991 00005D08 00                   		DC.B	0			; 22 ****
    1953   1992 00005D09 00                   		DC.B	0			; 23
    1954   1993 00005D0A 00                   		DC.B	0			; 24
    1955   1994 00005D0B 00                   		DC.B	0			; 25
    1956   1995 00005D0C 00                   		DC.B	0			; 26
    1957   1996 00005D0D 00                   		DC.B	0			; 27
    1958   1997 00005D0E 00                   		DC.B	0			; 28
    1959   1998 00005D0F 00                   		DC.B	0			; 29
    1960   1999 00005D10 00                   		DC.B	0			; 2A
    1961   2000 00005D11 00                   		DC.B	0			; 2B
    1962   2001 00005D12 00                   		DC.B	0			; 2C
    1963   2002 00005D13 00                   		DC.B	0			; 2D
    1964   2003 00005D14 00                   		DC.B	0			; 2E
    1965   2004 00005D15 00                   		DC.B	0			; 2F
    1966   2005 00005D16 00                   		DC.B	0			; 30
    1967   2006 00005D17 03                   		DC.B	3			; 31
    1968   2007 00005D18 03                   		DC.B	3			; 32
    1969   2008 00005D19 00                   		DC.B	0			; 33
    1970   2009 00005D1A 00                   		DC.B	0			; 34
    1971   2010 00005D1B 00                   		DC.B	0			; 35
    1972   2011 00005D1C 00                   		DC.B	0			; 36
    1973   2012 00005D1D 00                   		DC.B	0			; 37
    1974   2013 00005D1E 00                   		DC.B	0			; 38EBUS02.J01                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T          8-Oct-87  Page   47
Err Source Ref. Address   value
    line   line

    1976   2015                               	*		PROCESS INDIVIDUAL HOST MESSAGES
    1977   2016                               	
    1978   2017                               	*	PROCESS MESSAGE IN RECORD
    1979   2018 00005D20 4242                 	OTFRHST	CLR.W	D2
    1980   2019 00005D22 1438 108A            		MOVE.B	TYPBYT,D2		; message-type
    1981   2020 00005D26 0C42 0033            		CMP.W	#$33,D2			; range-check
    1982   2021 00005D2A 6E00 FC76            		BGT	MERROR			; invalid message
    1983   2022 00005D2E D442                 		ADD.W	D2,D2			; *2 to get offset
    1984   2023 00005D30 327B 2004            		MOVE.W	OMTAB(PC,D2.W),A1	; get target address
    1985   2024 00005D34 4ED1                 		JMP	(A1)			; go there
    1986   2025                               	
    1987   2026                               	
    1988   2027                               	*	HOST OUTPUT MESSAGE DISPATCH TABLE
    1989   2028                               	*	(	"<" -	Legal from host
    1990   2029                               	*		">" -	Legal to host	)
    1991   2030 00005D36 59A2                 	OMTAB	DC.W	MERROR			;    00 - Illegal
    1992   2031 00005D38 5D9E                 		DC.W	OPEN			; <  01 - Host Open
    1993   2032 00005D3A 5DA2                 		DC.W	SHUT			; <  02 - Host Shut
    1994   2033 00005D3C 5DE0                 		DC.W	RESET			; <> 03 - Reset Interface
    1995   2034 00005D3E 5E02                 		DC.W	RESETAK			; <> 04 - reset-Ack
    1996   2035 00005D40 59A2                 		DC.W	MERROR			;  > 05 - Takeover/Sup-lost
    1997   2036 00005D42 59A2                 		DC.W	MERROR			;  > 06 - Externally-init circuit
    1998   2037 00005D44 59A2                 		DC.W	MERROR			;  > 07 - Internally-init circuit
    1999   2038 00005D46 5E0C                 		DC.W	ONBP			; <> 08 - Backpressure On
    2000   2039 00005D48 5E22                 		DC.W	OFFBP			; <> 09 - Backpressure Off
    2001   2040 00005D4A 5E5A                 		DC.W	SPEC			; <> 0A - GOBBLER
    2002   2041 00005D4C 5E40                 		DC.W	ZAP			; <> 0B - ZAPPER
    2003   2042 00005D4E 5E5A                 		DC.W	SPEC			; <> OC - Enter DEM
    2004   2043 00005D50 5E5A                 		DC.W	SPEC			; <> 0D - Leave DEM
    2005   2044 00005D52 5E5A                 		DC.W	SPEC			; <> 0E - Green-ball
    2006   2045 00005D54 5E5A                 		DC.W	SPEC			; <> 0F - Red-ball
    2007   2046 00005D56 5E5A                 		DC.W	SPEC			; <> 10 - Yellow-ball
    2008   2047 00005D58 5E5A                 		DC.W	SPEC			; <> 11 - Orange-ball
    2009   2048 00005D5A 5E5A                 		DC.W	SPEC			; <  12 - Hang-up, forward out only
    2010   2049 00005D5C 5E5A                 		DC.W	SPEC			; <> 13 - Enter Transparency
    2011   2050 00005D5E 5E5A                 		DC.W	SPEC			; <> 14 - Leave Transparency
    2012   2051 00005D60 59A2                 		DC.W	MERROR			;  > 15 - Black/Gray-Ball
    2013   2052 00005D62 5EB4                 		DC.W	SUPREC			; <  16 - SUP (AUX-circuit) Request
    2014   2053 00005D64 59A2                 		DC.W	MERROR			;  > 17 - response to 16
    2015   2054 00005D66 5F0E                 		DC.W	SUPLOG			; <  18 - SUP Login Char
    2016   2055 00005D68 5F92                 		DC.W	TP			; <  19 - Test-pattern Probe
    2017   2056 00005D6A 59A2                 		DC.W	MERROR			;  > 1A - Test-pattern Response
    2018   2057 00005D6C 5FB0                 		DC.W	HSTSAD			; <  1B - Host-sad
    2019   2058 00005D6E 5FE8                 		DC.W	ECHOON			; <  1C - Echo On
    2020   2059 00005D70 5FF0                 		DC.W	ECHOFF			; <  1D - Echo Off
    2021   2060 00005D72 5FF6                 		DC.W	STERM			; <  1E - Set Terminal Characteristic
    2022   2061 00005D74 606A                 		DC.W	PTERM			; <  1F - Probe Terminal Characteristic
    2023   2062 00005D76 59A2                 		DC.W	MERROR			;  > 20 - Response to Terminal Char.
    2024   2063 00005D78 60EC                 		DC.W	SHNUM			; <  21 - Set Host Number (& # ports)
    2025   2064 00005D7A 613C                 		DC.W	SCLKR			; <  22 - SUP Clock Request (ignored)EBUS02.J01                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T          8-Oct-87  Page   48
Err Source Ref. Address   value
    line   line

    2026   2065 00005D7C 59A2                 		DC.W	MERROR			;  > 23 - Sup Clock Data
    2027   2066 00005D7E 6140                 		DC.W	BOK1			; <  24 - Block-output request
    2028   2067 00005D80 59A2                 		DC.W	MERROR			;  > 25 - Block-output done
    2029   2068 00005D82 61C8                 		DC.W	BOK2			; <  26 - Block-Input Request
    2030   2069 00005D84 59A2                 		DC.W	MERROR			;  > 27 - Bin Done -- Block full
    2031   2070 00005D86 59A2                 		DC.W	MERROR			;  > 28 - Bin done --EOT
    2032   2071 00005D88 59A2                 		DC.W	MERROR			;  > 29 - Bin Timeout
    2033   2072 00005D8A 623E                 		DC.W	BOK4			; <  2A - Terminate Block-input
    2034   2073 00005D8C 59A2                 		DC.W	MERROR			;  > 2B - Response to 2A
    2035   2074 00005D8E 621E                 		DC.W	BOK3			; <  2C - Terminate Block-output
    2036   2075 00005D90 59A2                 		DC.W	MERROR			;  > 2D - Response to 2C
    2037   2076 00005D92 627E                 		DC.W	BOK5			; <> 2E - Request/Response Block-IO ports
    2038   2077 00005D94 59A2                 		DC.W	MERROR			;  > 2F - Break-begin
    2039   2078 00005D96 59A2                 		DC.W	MERROR			;    30 - Illegal
    2040   2079 00005D98 5E5A                 		DC.W	SPEC			; <> 31 - Enter Alt. Dev. mode
    2041   2080 00005D9A 5E5A                 		DC.W	SPEC			; <> 32 - Leave Alt. Dev. mode
    2042   2081 00005D9C 628A                 		DC.W	SNTO			; <  33 - Set new timeout
    2043   2082                               	
    2044   2083                               	
    2045   2084                               	
    2046   2085                               	
    2047   2086                               	
    2048   2087                               	*	OMSG 01 - Host Answered/open
    2049   2088 00005D9E 4280                 	OPEN	CLR.L	D0			; set OPEN status
    2050   2089 00005DA0 6002                 		BRA	OPSHT
    2051   2090                               	
    2052   2091                               	
    2053   2092                               	*	OMSG 02 - Host shut
    2054   2093 00005DA2 7002                 	SHUT	MOVE.L	#2,D0			; set SHUT status
    2055   2094 00005DA4 1238 104E            	OPSHT	MOVE.B	HSTAT,D1
    2056   2095 00005DA8 5301                 		SUB.B	#1,D1
    2057   2096 00005DAA 661E                 		BNE	HST2
    2058   2097 00005DAC 4278 1058            		CLR.W	NPORTS
    2059   2098 00005DB0 6124                 	TIMCHK	BSR	TSLOWC
    2060   2099 00005DB2 2238 10E0            		MOVE.L	SLOWC,D1
    2061   2100                               	*	DON'T FLOOD SUP WITH OPEN/SHUT MSGS
    2062   2101 00005DB6 92B8 10E4            		SUB.L	HTM,D1
    2063   2102 00005DBA 6D06                 		BLT	HST1
    2064   2103 00005DBC 5181                 		SUB.L	#8,D1
    2065   2104 00005DBE 6E02                 		BGT	HST1
    2066   2105 00005DC0 60EE                 		BRA	TIMCHK
    2067   2106                               	
    2068   2107 00005DC2 6112                 	HST1	BSR	TSLOWC
    2069   2108 00005DC4 21F8 10E0 10E4       		MOVE.L	SLOWC,HTM
    2070   2109 00005DCA 11C0 104E            	HST2	MOVE.B	D0,HSTAT		; set new status
    2071   2110 00005DCE 6100 FCB8            		BSR	HREPRT			; report new host status to SUP
    2072   2111 00005DD2 6000 FE32            		BRA	HOSTOUT
    2073   2112                               	
    2074   2113                               	*	ROUTINE TO GET TIME FROM SLOWC
    2075   2114 00005DD6 2078 1036            	TSLOWC	MOVE.L	.SLOWC,A0
    2076   2115 00005DDA 21D0 10E0            		MOVE.L	(A0),SLOWCEBUS02.J01                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T          8-Oct-87  Page   49
Err Source Ref. Address   value
    line   line

    2077   2116 00005DDE 4E75                 		RTS
    2078   2117                               	
    2079   2118                               	
    2080   2119                               	*	OMSG 03 - RESET INTERFACE
    2081   2120 00005DE0 31F8 10AA 1054       	RESET	MOVE.W	DAT3,HVERNO		; record host version number
    2082   2121 00005DE6 6100 FCE2            		BSR	EMPTY			; empty ISIS input-ring
    2083   2122 00005DEA 6100 FC02            		BSR	HODOWN			; set host down
    2084   2123 00005DEE 31FC 0400 10A8       		MOVE.W	#$400+DEBUG,DAT1	; set "RESET ACK"
    2085   2124 00005DF4 31FC 0201 10AA       		MOVE.W	#VERSION,DAT3
    2086   2125 00005DFA 6100 F9A2            		BSR.L	WAITDAT			; and send it
    2087   2126 00005DFE 6000 FE06            		BRA	HOSTOUT
    2088   2127                               	
    2089   2128                               	*	OMSG04 - RESET ACKNOWLEDGEMENT
    2090   2129 00005E02 31F8 10AA 1054       	RESETAK	MOVE.W	DAT3,HVERNO		; just record host version number
    2091   2130 00005E08 6000 FDFC            		BRA	HOSTOUT
    2092   2131                               	
    2093   2132                               	
    2094   2133                               	*	OMSG 08 - Apply Backpressure
    2095   2134 00005E0C 08EC 0004 0001       	ONBP	BSET	#PF_HBP,P_FLAGS(Rp)	; set host-applied Backpressure
    2096   2135 00005E12 6600 FDF2            		BNE	HOSTOUT			; ...already has
    2097   2136 00005E16 08EC 0003 0001       		BSET	#PF_IBP,P_FLAGS(Rp)	; set we've-applied Backpressure
    2098   2137 00005E1C 6600 FDE8            		BNE	HOSTOUT			; ...already did
    2099   2138 00005E20 6038                 		BRA	SPEC			; SPEC does the hard work
    2100   2139                               	
    2101   2140                               	
    2102   2141                               	*	OMSG 09 - Release Backpressure
    2103   2142 00005E22 08AC 0004 0001       	OFFBP	BCLR	#PF_HBP,P_FLAGS(Rp)	; Clear host-applied Backpressure
    2104   2143 00005E28 6700 FDDC            		BEQ	HOSTOUT			; ...already did
    2105   2144 00005E2C 4A6C 001E            		TST.W	BCT(Rp)			; anything in buffer?
    2106   2145 00005E30 6600 FDD4            		BNE	HOSTOUT			; yes...we'll do it when buffer flushed
    2107   2146 00005E34 08AC 0003 0001       		BCLR	#PF_IBP,P_FLAGS(Rp)	; Clear our-applied Backpressure
    2108   2147 00005E3A 6700 FDCA            		BEQ	HOSTOUT			; ...already did
    2109   2148 00005E3E 601A                 		BRA	SPEC			; SPEC does the hard work
    2110   2149                               	
    2111   2150                               	
    2112   2151                               	*	OMSG 0B - ZAPPER
    2113   2152 00005E40 4A78 10A0            	ZAP	TST.W	PORTNO			; Check port #
    2114   2153 00005E44 6700 FDC0            		BEQ	HOSTOUT			; ignor if port 0
    2115   2154 00005E48 082C 0000 0001       		BTST	#PF_ACT,P_FLAGS(Rp)	; test if port is active
    2116   2155 00005E4E 6714                 		BEQ	SPEC1			; no
    2117   2156 00005E50 6100 FD24            		BSR	DPORT			; yes...reduce port-count
    2118   2157 00005E54 6100 FBF2            		BSR	RBTALL			; reset everything for port
    2119   2158 00005E58 600A                 		BRA	SPEC1
    2120   2159                               	
    2121   2160                               	
    2122   2161                               	*	OMSGS 08-14,31-32 - VARIOUS ONE-BYTE MESSAGES
    2123   2162 00005E5A 082C 0000 0001       	SPEC	BTST	#PF_ACT,P_FLAGS(Rp)	; test if port is active
    2124   2163 00005E60 6700 FDA4            		BEQ	HOSTOUT			; ignor if not
    2125   2164                               	
    2126   2165 00005E64 4244                 	SPEC1	CLR.W	D4
    2127   2166 00005E66 1838 108A            		MOVE.B	TYPBYT,D4		; message-typeEBUS02.J01                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T          8-Oct-87  Page   50
Err Source Ref. Address   value
    line   line

    2128   2167 00005E6A 183B 400E            		MOVE.B	SPTAB(PC,D4.W),D4	; get ISIS message-type
    2129   2168 00005E6E 3638 10A0            		MOVE.W	PORTNO,D3		; for port
    2130   2169 00005E72 6100 F57C            		BSR	SENDQI			; send Quick ISIS message
    2131   2170 00005E76 6000 FD8E            		BRA	HOSTOUT
    2132   2171                               	
    2133   2172                               	
    2134   2173                               	
    2135   2174                               	*	CONVERSION TABLE FOR HOST MSGS TO ISIS MSGS
    2136   2175 00005E7A 0000 0000            	SPTAB	DC.B	0,0,0,0,0,0,0,0,$0A0,$0A1
    2136   2176 00005E7E 0000 0000            	
    2136   2177 00005E82 A0A1                 	
    2137   2178 00005E84 A29F A6A7            		DC.B	$0A2,$9F,$0A6,$0A7,$0AA,$0AB,$0AC,$0AD,$0AF,$0A8
    2137   2179 00005E88 AAAB ACAD            	
    2137   2180 00005E8C AFA8                 	
    2138   2181 00005E8E A900 0000            		DC.B	$0A9,0,0,0,0,0,0,0,0,0
    2138   2182 00005E92 0000 0000            	
    2138   2183 00005E96 0000                 	
    2139   2184 00005E98 0000 0000            		DC.B	0,0,0,0,0,0,0,0,0,0
    2139   2185 00005E9C 0000 0000            	
    2139   2186 00005EA0 0000                 	
    2140   2187 00005EA2 0000 0000            		DC.B	0,0,0,0,0,0,0,0,0,$0BC
    2140   2188 00005EA6 0000 0000            	
    2140   2189 00005EAA 00BC                 	
    2141   2190 00005EAC BD00 0000            		DC.B	$0BD,0,0,0,0,0,0,0
    2141   2191 00005EB0 0000 0000            	
    2142   2192                               	
    2143   2193                               	
    2144   2194                               	
    2145   2195                               	*	OMSG 16 - SUPERVISOR REQUEST (for AUX circuit)
    2146   2196 00005EB4 4A78 1060            	SUPREC	TST.W	AUXX			; index into username array
    2147   2197 00005EB8 6D1C                 		BLT	SUPR1			; No AUX circuit in progress
    2148   2198 00005EBA 6100 FF1A            		BSR	TSLOWC
    2149   2199 00005EBE 2038 10E0            		MOVE.L	SLOWC,D0		; low long since last try?
    2150   2200 00005EC2 90B8 105C            		SUB.L	AUXTIM,D0
    2151   2201 00005EC6 0240 FFE0            		ANDI.W	#-32,D0
    2152   2202 00005ECA 660A                 		BNE	SUPR1
    2153   2203 00005ECC 363C 0900            		MOVE.W	#$0900,D3		; last request still in progress
    2154   2204 00005ED0 6126                 		BSR	SEND17
    2155   2205 00005ED2 6000 FD32            		BRA	HOSTOUT
    2156   2206                               	
    2157   2207 00005ED6 4278 1060            	SUPR1	CLR.W	AUXX			; give enable request
    2158   2208 00005EDA 31F8 10A0 105A       		MOVE.W	PORTNO,AUXQ		; ...for this port
    2159   2209 00005EE0 4243                 		CLR.W	D3			; response = 0
    2160   2210 00005EE2 6114                 		BSR	SEND17
    2161   2211 00005EE4 6100 FEF0            		BSR	TSLOWC
    2162   2212 00005EE8 2038 10E0            		MOVE.L	SLOWC,D0
    2163   2213 00005EEC 21C0 105C            		MOVE.L	D0,AUXTIM
    2164   2214 00005EF0 6100 F8E6            		BSR	PUTIFC
    2165   2215 00005EF4 6000 FD10            		BRA	HOSTOUT
    2166   2216                               	
    2167   2217                               	EBUS02.J01                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T          8-Oct-87  Page   51
Err Source Ref. Address   value
    line   line

    2168   2218 00005EF8 11FC 0017 10A8       	SEND17	MOVE.B	#$17,DAT1		; send SUP response
    2169   2219 00005EFE 11F8 10A1 10A9       		MOVE.B	PORTNO+1,DAT2
    2170   2220 00005F04 31C3 10AA            		MOVE.W	D3,DAT3
    2171   2221 00005F08 6100 F894            		BSR	WAITDAT			; wait, then write DAT into host
    2172   2222 00005F0C 4E75                 		RTS
    2173   2223                               	
    2174   2224                               	*	OMSG 18 - SUPERVISOR LOGIN CHAR
    2175   2225 00005F0E 3038 10A0            	SUPLOG	MOVE.W	PORTNO,D0		; port number
    2176   2226 00005F12 B078 105A            		CMP.W	AUXQ,D0			; request for valid port?
    2177   2227 00005F16 6600 FCEE            		BNE	HOSTOUT			; no...ignor
    2178   2228 00005F1A 41F8 1062            		LEA	AUXC,A0			; yes...set start-address of user-string
    2179   2229 00005F1E 3038 1060            		MOVE.W	AUXX,D0			; get index for next char
    2180   2230 00005F22 D0C0                 		ADD.W	D0,A0
    2181   2231 00005F24 1238 10AA            		MOVE.B	DAT3,D1
    2182   2232 00005F28 0001 0080            		OR.B	#$80,D1			; set high-order bit
    2183   2233 00005F2C 1081                 		MOVE.B	D1,(A0)			; save the character
    2184   2234 00005F2E 5240                 		ADD.W	#1,D0			; advance index
    2185   2235 00005F30 0240 003F            		AND.W	#$3F,D0			; wrap it if too long
    2186   2236 00005F34 31C0 1060            		MOVE.W	D0,AUXX			; save copy
    2187   2237 00005F38 0C01 00BB            		CMPI.B	#$BB,D1			; SEMICOLON?
    2188   2238 00005F3C 6708                 		BEQ	SUPOUT
    2189   2239 00005F3E 0C01 008D            		CMPI.B	#$8D,D1			; CARRIAGE RETURN?
    2190   2240 00005F42 6600 FCC2            		BNE	HOSTOUT			; no...not done yet
    2191   2241 00005F46 0640 000B            	SUPOUT	ADD.W	#$0B,D0			; done...pass to Sup
    2192   2242 00005F4A 6100 F41A            		BSR	WAITIS			; wait for space to send message
    2193   2243 00005F4E 4243                 		CLR.W	D3			; to Port 0
    2194   2244 00005F50 7808                 		MOVEQ	#8,D4			; Request AUX Circuit
    2195   2245 00005F52 6100 F424            		BSR	SLOR
    2196   2246 00005F56 4200                 		CLR.B	D0			; padding (B)
    2197   2247 00005F58 6100 F43E            		BSR	PUTCH
    2198   2248 00005F5C 3038 10A0            		MOVE.W	PORTNO,D0		; Local Key = portnumber (HW)
    2199   2249 00005F60 6100 F466            		BSR	PUTH
    2200   2250 00005F64 4240                 		CLR.W	D0			; No IIX (HW)
    2201   2251 00005F66 6100 F460            		BSR	PUTH
    2202   2252 00005F6A 3038 104A            		MOVE.W	HOSTN,D0		; Orig. Host (HW)
    2203   2253 00005F6E 6100 F458            		BSR	PUTH
    2204   2254 00005F72 3438 1060            		MOVE.W	AUXX,D2			; size of name
    2205   2255 00005F76 1002                 		MOVE.B	D2,D0			; size (B)
    2206   2256 00005F78 6100 F41E            		BSR	PUTCH
    2207   2257 00005F7C 43F8 1062            		LEA	AUXC,A1			; address of first byte
    2208   2258 00005F80 1019                 	SUPLOP	MOVE.B	(A1)+,D0		; next byte of string
    2209   2259 00005F82 6100 F414            		BSR	PUTCH
    2210   2260 00005F86 5342                 		SUB.W	#1,D2
    2211   2261 00005F88 6EF6                 		BGT	SUPLOP
    2212   2262 00005F8A 6100 F46A            		BSR	ELOR			; end request
    2213   2263 00005F8E 6000 FC76            		BRA	HOSTOUT
    2214   2264                               	
    2215   2265                               	
    2216   2266                               	*	OMSG 19 - TEST PATTERN PROBE
    2217   2267 00005F92 11FC 001A 10A8       	TP	MOVE.B	#$1A,DAT1		; Test-pattern Response
    2218   2268 00005F98 4238 10A9            		CLR.B	DAT2EBUS02.J01                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T          8-Oct-87  Page   52
Err Source Ref. Address   value
    line   line

    2219   2269 00005F9C 6100 F802            		BSR	WRDAT			; write DAT into host
    2220   2270 00005FA0 6100 F5FE            		BSR	RDPDP
    2221   2271 00005FA4 6100 F7FE            		BSR	WRPDP			; copy next word too
    2222   2272 00005FA8 6100 F82E            		BSR	PUTIFC			; mark it as done
    2223   2273 00005FAC 6000 FC58            		BRA	HOSTOUT
    2224   2274                               	
    2225   2275                               	
    2226   2276                               	*	OMSGS 1B - HOST SAD
    2227   2277 00005FB0 6100 F5EE            	HSTSAD	BSR	RDPDP			; get next word
    2228   2278 00005FB4 4841                 		SWAP	D1			; d3/d4 to low half
    2229   2279 00005FB6 700A                 		MOVEQ	#10,D0			; need 10d bytes of space
    2230   2280 00005FB8 6100 F3AC            		BSR	WAITIS			; wait for room in ring
    2231   2281 00005FBC 4243                 		CLR.W	D3			; Port 0 --
    2232   2282 00005FBE 7803                 		MOVEQ	#3,D4			; Type 3 (diagnostic)
    2233   2283 00005FC0 6100 F3B6            		BSR	SLOR
    2234   2284 00005FC4 4200                 		CLR.B	D0			; Padding
    2235   2285 00005FC6 6100 F3D0            		BSR	PUTCH
    2236   2286 00005FCA 3001                 		MOVE.W	D1,D0			; data2 (HW)
    2237   2287 00005FCC 6100 F3FA            		BSR	PUTH
    2238   2288 00005FD0 303C 1000            		MOVE.W	#$1000,D0		; Rtype 10 | 0 (B | B)
    2239   2289 00005FD4 6100 F3F2            		BSR	PUTH
    2240   2290 00005FD8 103C 0091            		MOVE.B	#PRODID,D0		; ProductID
    2241   2291 00005FDC 6100 F3BA            		BSR	PUTCH
    2242   2292 00005FE0 6100 F414            		BSR	ELOR			; send it on
    2243   2293 00005FE4 6000 FC20            		BRA	HOSTOUT
    2244   2294                               	
    2245   2295                               	
    2246   2296                               	*	OMSGS 1C & 1D - ECHO ON/OFF
    2247   2297 00005FE8 31FC 0001 10AA       	ECHOON	MOVE.W	#1,DAT3			; subtype = 0, value = 1
    2248   2298 00005FEE 600E                 		BRA	STERM1
    2249   2299                               	
    2250   2300 00005FF0 4278 10AA            	ECHOFF	CLR.W	DAT3			; subtype=0, value = 0
    2251   2301 00005FF4 6008                 		BRA	STERM1
    2252   2302                               	
    2253   2303                               	
    2254   2304                               	*	OMSG 1E - SET TERMINAL CHARACTERISTICS
    2255   2305 00005FF6 4A38 10AA            	STERM	TST.B	DAT3			; check message subtype
    2256   2306 00005FFA 6D00 F9A6            		BLT	MERROR			; range check
    2257   2307                               	
    2258   2308 00005FFE 082C 0000 0001       	STERM1	BTST	#PF_ACT,P_FLAGS(Rp)	; test if port is active
    2259   2309 00006004 6700 FC00            		BEQ	HOSTOUT			; ignor request for inactive ports
    2260   2310 00006008 0C38 0014 10AB       		CMP.B	#$14,DAT4
    2261   2311 0000600E 6E00 F992            		BGT	MERROR			; range check
    2262   2312 00006012 7008                 		MOVEQ	#8,D0
    2263   2313 00006014 6100 F350            		BSR	WAITIS			; wait for space in ring
    2264   2314 00006018 0C38 0005 10AA       		CMP.B	#5,DAT3			; special handling for input baud rate
    2265   2315 0000601E 660A                 		BNE	STERM2			; skip if not
    2266   2316 00006020 1978 10AB 0003       		MOVE.B	DAT4,IBRATE(Rp)		; save new input baud-rate
    2267   2317 00006026 6100 00A6            		BSR.L	PTMSN1			; turn around and Acknowledge it
    2268   2318 0000602A 3638 10A0            	STERM2	MOVE.W	PORTNO,D3		; port #
    2269   2319 0000602E 183C 00B1            		MOVE.B	#$B1,D4			; Type-byteEBUS02.J01                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T          8-Oct-87  Page   53
Err Source Ref. Address   value
    line   line

    2270   2320 00006032 6100 F344            		BSR	SLOR
    2271   2321 00006036 1038 10AA            		MOVE.B	DAT3,D0			; sub-type
    2272   2322 0000603A 0C00 000F            		CMP.B	#$0F,D0			;				<2.2
    2273   2323 0000603E 6602                 		BNE	NOJAP1			;				<2.2
    2274   2324 00006040 5200                 		ADD.B	#1,D0			; translate subtype 15d to subtype 16d <2.2
    2275   2325 00006042 6100 F354            	NOJAP1	BSR	PUTCH
    2276   2326 00006046 1038 10AB            		MOVE.B	DAT4,D0			; value
    2277   2327 0000604A 6712                 		BEQ	STERM3			; 0 is OK
    2278   2328 0000604C 223C 000F 719F       		MOVE.L	#$000F719F,D1		; check for single-bit use
    2279   2329 00006052 1438 10AA            		MOVE.B	DAT3,D2			; subtype
    2280   2330 00006056 0501                 		BTST	D2,D1
    2281   2331 00006058 6704                 		BEQ	STERM3			; multi-bit..use value
    2282   2332 0000605A 103C 00FF            		MOVE.B	#-1,D0			; set whole byte to 1's
    2283   2333 0000605E 6100 F338            	STERM3	BSR	PUTCH
    2284   2334 00006062 6100 F392            		BSR	ELOR
    2285   2335 00006066 6000 FB9E            		BRA	HOSTOUT
    2286   2336                               	
    2287   2337                               	
    2288   2338                               	
    2289   2339                               	
    2290   2340                               	*	OMSG 1F - PROBE TERMINAL CHARACTERISTICS
    2291   2341 0000606A 082C 0000 0001       	PTERM	BTST	#PF_ACT,P_FLAGS(Rp)	; test if port is active
    2292   2342 00006070 6700 FB94            		BEQ	HOSTOUT			; ignor for inactive ports
    2293   2343 00006074 1438 10AA            		MOVE.B	DAT3,D2			; get request sub-type
    2294   2344 00006078 6D00 FB8C            		BLT	HOSTOUT			; range-check
    2295   2345 0000607C 0C02 003F            		CMP.B	#63,D2			; special "probe all"?
    2296   2346 00006080 6712                 		BEQ	PTALL			; skip if so
    2297   2347 00006082 0C02 0014            		CMP.B	#$14,D2			; range-check
    2298   2348 00006086 6E00 FB7E            		BGT	HOSTOUT			; ignore out of range requests
    2299   2349 0000608A 6118                 		BSR	PTMSND			; else send request
    2300   2350 0000608C 6100 F74A            		BSR	PUTIFC			; clean up
    2301   2351 00006090 6000 FB74            		BRA	HOSTOUT
    2302   2352                               	
    2303   2353                               	*	Special case for "probe all"
    2304   2354 00006094 7414                 	PTALL	MOVEQ	#$14,D2			; set counter
    2305   2355 00006096 610C                 	PTAL2	BSR	PTMSND			; send another request
    2306   2356 00006098 5302                 		SUB.B	#1,D2
    2307   2357 0000609A 6CFA                 		BGE	PTAL2			; ...until done
    2308   2358 0000609C 6100 F73A            		BSR	PUTIFC			; clean up
    2309   2359 000060A0 6000 FB64            		BRA	HOSTOUT
    2310   2360                               	
    2311   2361                               	*	Process one request
    2312   2362                               	*	D2 = sub-type
    2313   2363 000060A4 0C02 0005            	PTMSND	CMP.B	#5,D2			; subtype 5?
    2314   2364 000060A8 6724                 		BEQ	PTMSN1			; fake out input baud rate request
    2315   2365 000060AA 6100 F2B2            		BSR	WAITISW			; insure space in ring
    2316   2366 000060AE 3638 10A0            		MOVE.W	PORTNO,D3		; port number
    2317   2367 000060B2 183C 00B0            		MOVE.B	#$B0,D4			; type = query parameter
    2318   2368 000060B6 6100 F2C0            		BSR	SLOR
    2319   2369 000060BA 1002                 		MOVE.B	D2,D0
    2320   2370 000060BC 0C00 000F            		CMP.B	#$0F,D0EBUS02.J01                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T          8-Oct-87  Page   54
Err Source Ref. Address   value
    line   line

    2321   2371 000060C0 6602                 		BNE	NOJAP2
    2322   2372 000060C2 5200                 		ADD.B	#1,D0			; type 15d translated to type 16d
    2323   2373 000060C4 6100 F2D2            	NOJAP2	BSR	PUTCH			; subtype
    2324   2374 000060C8 6100 F32C            		BSR	ELOR
    2325   2375 000060CC 4E75                 		RTS
    2326   2376                               	
    2327   2377                               	*	Report input baud rate
    2328   2378 000060CE 11FC 0020 10A8       	PTMSN1	MOVE.B	#$20,DAT1
    2329   2379 000060D4 11F8 10A1 10A9       		MOVE.B	PORTNO+1,DAT2
    2330   2380 000060DA 11FC 0005 10AA       		MOVE.B	#5,DAT3			; sub-type = input baud rate
    2331   2381 000060E0 11EC 0003 10AB       		MOVE.B	IBRATE(Rp),DAT4		; rate
    2332   2382 000060E6 6100 F6B8            		BSR	WRDAT			; send DAT to host
    2333   2383 000060EA 4E75                 		RTS
    2334   2384                               	
    2335   2385                               	
    2336   2386                               	
    2337   2387                               	*	OMSG 21 - SET HOST NUMBER
    2338   2388 000060EC 7801                 	SHNUM	MOVEQ	#1,D4			; assume host going down
    2339   2389 000060EE 4281                 		CLR.L	D1
    2340   2390 000060F0 1238 10AA            		MOVE.B	DAT3,D1
    2341   2391 000060F4 B278 104A            		CMP.W	HOSTN,D1		; is host number being changed?
    2342   2392 000060F8 660A                 		BNE	SHNUM1			; Skip if so
    2343   2393 000060FA 3438 10A0            		MOVE.W	PORTNO,D2		; port number = number of ports
    2344   2394 000060FE B478 104C            		CMP.W	HOSTP,D2		; did it change?
    2345   2395 00006102 6702                 		BEQ	SHNUM2			; skip if not
    2346   2396                               	
    2347   2397 00006104 7803                 	SHNUM1	MOVEQ	#3,D4			; host or number of ports changed
    2348   2398                               	*					 ...Tell SUP Host is Gone
    2349   2399 00006106 6100 F8EC            	SHNUM2	BSR	HDOWN			; make host change
    2350   2400 0000610A 4282                 		CLR.L	D2
    2351   2401 0000610C 1438 10AA            		MOVE.B	DAT3,D2
    2352   2402 00006110 31C2 104A            		MOVE.W	D2,HOSTN		; update host number
    2353   2403 00006114 1438 10A9            		MOVE.B	DAT2,D2			; port number = number of ports
    2354   2404 00006118 6706                 		BEQ	SHNUM3			; 0 defaults to MAX
    2355   2405 0000611A 0C42 00FE            		CMP.W	#MAXPORT-2,D2
    2356   2406 0000611E 6F04                 		BLE	SHNUM4
    2357   2407 00006120 343C 00FE            	SHNUM3	MOVE.W	#MAXPORT-2,D2		; we do not use port 0 or $FF
    2358   2408 00006124 31C2 104C            	SHNUM4	MOVE.W	D2,HOSTP		; number of host ports
    2359   2409 00006128 5742                 		SUB.W	#3,D2
    2360   2410 0000612A 31C2 1056            		MOVE.W	D2,MXPORT		; maximum port number
    2361   2411 0000612E 11FC 0002 104E       		MOVE.B	#2,HSTAT		; set host shut
    2362   2412 00006134 6100 F952            		BSR	HREPRT			; and report it
    2363   2413 00006138 6000 FACC            		BRA	HOSTOUT
    2364   2414                               	
    2365   2415                               	
    2366   2416                               	*	OMSG 22 - SUP CLOCK REQUEST
    2367   2417 0000613C 6000 FAC8            	SCLKR	BRA	HOSTOUT			; ignor for now
    2368   2418                               	
    2369   2419                               	
    2370   2420                               	
    2371   2421                               	*	OMSGS 24,26,2A,2C,2E (BLOCK I/O)EBUS02.J01                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T          8-Oct-87  Page   55
Err Source Ref. Address   value
    line   line

    2372   2422                               	
    2373   2423                               	*	---24---	REQ FOR BLOCK OUTPUT
    2374   2424                               	*	Block output is simple...each Bout request is independent.
    2375   2425                               	*	We transmit the block of data, and report it's transmission,
    2376   2426                               	*	thereby ending that request.
    2377   2427 00006140 31F8 10AA 1104       	BOK1	MOVE.W	DAT3,SAVE1		; save TCN value
    2378   2428 00006146 6100 F458            		BSR	RDPDP			; get address
    2379   2429 0000614A E089                 		LSR.L	#8,D1
    2380   2430 0000614C 082C 0000 0001       		BTST	#PF_ACT,P_FLAGS(Rp)	; test if port is active
    2381   2431 00006152 6700 FAB2            		BEQ	HOSTOUT			; no...ignore request
    2382   2432 00006156 08EC 0005 0001       		BSET	#PF_BKO,P_FLAGS(Rp)	; set and test block output in progress
    2383   2433 0000615C 6600 FAA8            		BNE	HOSTOUT			; was already set
    2384   2434 00006160 3078 10FC            		MOVE.W	BLKFREE,A0		; wasn't set...get an entry off free-list
    2385   2435 00006164 31D0 10FC            		MOVE.W	(A0),BLKFREE		; unlink from free-list
    2386   2436 00006168 30B8 1100            		MOVE.W	BKOHEAD,(A0)		; link list-head to element
    2387   2437 0000616C 3178 10A0 0002       		MOVE.W	PORTNO,2(A0)		; second word is port-number
    2388   2438 00006172 31C8 1100            		MOVE.W	A0,BKOHEAD		; place this element as new list-head
    2389   2439 00006176 2941 0004            		MOVE.L	D1,BO_TAR(Rp)		; TAR value
    2390   2440 0000617A 3978 1104 000A       		MOVE.W	SAVE1,BO_TCN(Rp)	; TCN value
    2391   2441 00006180 426C 0008            		CLR.W	BO_BYT(Rp)		; BYT = 0
    2392   2442 00006184 6000 FA80            		BRA	HOSTOUT
    2393   2443                               	
    2394   2444                               	
    2395   2445                               	*	Reset Block-output
    2396   2446 00006188 08AC 0005 0001       	RBTBKO	BCLR	#PF_BKO,P_FLAGS(Rp)	; clear Block-Output
    2397   2447 0000618E 6722                 		BEQ	LNKEND			; exit if not set
    2398   2448 00006190 43F8 1100            		LEA	BKOHEAD,A1		; was set...search for entry in list
    2399   2449                               	
    2400   2450 00006194 4280                 	UNLINK	CLR.L	D0
    2401   2451 00006196 2049                 	LNKLOP	MOVE.L	A1,A0			; copy NEXT to Current
    2402   2452 00006198 3010                 		MOVE.W	(A0),D0			; get address of next element
    2403   2453 0000619A 6716                 		BEQ	LNKEND			; null...list exhausted
    2404   2454 0000619C 2240                 		MOVE.L	D0,A1			; ok...set address
    2405   2455 0000619E 3029 0002            		MOVE.W	2(A1),D0		; get NEXT port
    2406   2456 000061A2 B078 10A0            		CMP.W	PORTNO,D0		; is NEXT correct element?
    2407   2457 000061A6 66EE                 		BNE	LNKLOP			; no
    2408   2458 000061A8 3091                 		MOVE.W	(A1),(A0)		; found match...unlink (NEXT) element
    2409   2459 000061AA 32B8 10FC            		MOVE.W	BLKFREE,(A1)		; link element to free-list
    2410   2460 000061AE 31C9 10FC            		MOVE.W	A1,BLKFREE		; ...and make it new free-list head
    2411   2461 000061B2 4E75                 	LNKEND	RTS
    2412   2462                               	
    2413   2463                               	
    2414   2464                               	*	Reset Block-input
    2415   2465 000061B4 08AC 0006 0001       	RBTBKI	BCLR	#PF_BKI,P_FLAGS(Rp)	; clear Block-input active
    2416   2466 000061BA 67F6                 		BEQ	LNKEND			; not set...just exit
    2417   2467 000061BC 43F8 10FE            		LEA	BKIHEAD,A1		; set address of list-head
    2418   2468 000061C0 60D2                 		BRA	UNLINK			; unlink entry from this list
    2419   2469                               	
    2420   2470                               	
    2421   2471                               	*	Reset BUFfer
    2422   2472 000061C2 43F8 1102            	RBTBUF	LEA	BUFHEAD,A1		; set address of list-headEBUS02.J01                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T          8-Oct-87  Page   56
Err Source Ref. Address   value
    line   line

    2423   2473 000061C6 60CC                 		BRA	UNLINK			; unlink entry from this list
    2424   2474                               	
    2425   2475                               	
    2426   2476                               	*	---26---	BLOCK INPUT REQUEST
    2427   2477                               	*	Block input is more complicated...each Bin request may start
    2428   2478                               	*	a series, OR continue an already-started sequence.  It is terminated
    2429   2479                               	*	by a Terminate-Block-Input request;  until that is received, we must
    2430   2480                               	*	buffer any data received after the last Bin service.
    2431   2481 000061C8 08EC 0006 0001       	BOK2	BSET	#PF_BKI,P_FLAGS(Rp)	; set Block-input active
    2432   2482 000061CE 6618                 		BNE	BOK22			; already set...don't do it again
    2433   2483 000061D0 61F0                 		BSR	RBTBUF			; wasn't set...insure buffer not on list
    2434   2484 000061D2 3078 10FC            		MOVE.W	BLKFREE,A0		; get an entry off free-list
    2435   2485 000061D6 31D0 10FC            		MOVE.W	(A0),BLKFREE		; unlink from free-list
    2436   2486 000061DA 30B8 10FE            		MOVE.W	BKIHEAD,(A0)		; link block-input list to this element
    2437   2487 000061DE 3178 10A0 0002       		MOVE.W	PORTNO,2(A0)		; install the port number
    2438   2488 000061E4 31C8 10FE            		MOVE.W	A0,BKIHEAD		; install element as new list-head
    2439   2489                               	
    2440   2490 000061E8 08AC 0007 0001       	BOK22	BCLR	#PF_BFD,P_FLAGS(Rp)	; clear Block FilleD
    2441   2491 000061EE 3978 10AA 0014       		MOVE.W	DAT3,BI_TCN(Rp)
    2442   2492 000061F4 6100 F3AA            		BSR	RDPDP
    2443   2493 000061F8 E089                 		LSR.L	#8,D1
    2444   2494 000061FA 2941 0010            		MOVE.L	D1,BI_TAR(Rp)
    2445   2495 000061FE 426C 0016            		CLR.W	BI_LCN(Rp)
    2446   2496 00006202 426C 0018            		CLR.W	BI_BYT(Rp)
    2447   2497 00006206 2478 103A            		MOVE.L	.FASTC,A2		; record current time
    2448   2498 0000620A 2952 000C            		MOVE.L	(A2),BI_TIM(Rp)
    2449   2499 0000620E 4A2C 001E            		TST.B	BCT(Rp)			; anything already in buffer?
    2450   2500 00006212 6700 F9F2            		BEQ	HOSTOUT			; no
    2451   2501 00006216 6100 0948            		BSR.L	BU_BK			; yes...try to empty the buffer
    2452   2502 0000621A 6000 F9EA            		BRA	HOSTOUT			; then quit
    2453   2503                               	
    2454   2504                               	
    2455   2505                               	*	---2A---	TERMINATE BLOCK OUTPUT
    2456   2506 0000621E 11FC 002D 10A8       	BOK3	MOVE.B	#$2D,DAT1		; acknowledge request
    2457   2507 00006224 6104                 		BSR	BKOTERM			; send termination
    2458   2508 00006226 6000 F9DE            		BRA	HOSTOUT
    2459   2509                               	
    2460   2510                               	
    2461   2511                               	*	Terminate Block-output -- DAT1 = reason
    2462   2512 0000622A 11F8 10A1 10A9       	BKOTERM	MOVE.B	PORTNO+1,DAT2		; build message
    2463   2513 00006230 6100 F56C            		BSR	WAITDAT			; wait, then write DAT into host
    2464   2514 00006234 6100 F5A2            		BSR	PUTIFC
    2465   2515 00006238 6100 FF4E            		BSR	RBTBKO			; cancel block-output
    2466   2516 0000623C 4E75                 		RTS
    2467   2517                               	
    2468   2518                               	
    2469   2519                               	
    2470   2520                               	
    2471   2521                               	*	---2C---	TERMINATE BLOCK INPUT
    2472   2522 0000623E 11FC 002B 10A8       	BOK4	MOVE.B	#$2B,DAT1
    2473   2523 00006244 6118                 		BSR	BKITERM			; send termination-messageEBUS02.J01                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T          8-Oct-87  Page   57
Err Source Ref. Address   value
    line   line

    2474   2524 00006246 6100 FF6C            		BSR.L	RBTBKI			; reset Block-input
    2475   2525 0000624A 6100 0834            		BSR.L	BU_RG			; attempt to flush buffer
    2476   2526 0000624E 4A6C 001E            		TST.W	BCT(Rp)			; anything left there?
    2477   2527 00006252 6700 F9B2            		BEQ	HOSTOUT			; no...we're done
    2478   2528 00006256 6100 08F0            		BSR.L	BU_ADD			; yes...insure it will be flushed
    2479   2529 0000625A 6000 F9AA            		BRA	HOSTOUT			; and quit
    2480   2530                               	
    2481   2531                               	
    2482   2532                               	*	Terminate Block-input -- Reason in DAT1
    2483   2533 0000625E 11F8 10A1 10A9       	BKITERM	MOVE.B	PORTNO+1,DAT2		; set up message
    2484   2534 00006264 31EC 0016 10AA       		MOVE.W	BI_LCN(Rp),DAT3		; # of characters sent
    2485   2535 0000626A 426C 0016            		CLR.W	BI_LCN(Rp)		; ...and reset count
    2486   2536 0000626E 6100 F52E            		BSR	WAITDAT			; wait, then write DAT into host
    2487   2537 00006272 6100 F564            		BSR	PUTIFC
    2488   2538 00006276 08EC 0007 0001       		BSET	#PF_BFD,P_FLAGS(Rp)	; set Block FilleD
    2489   2539 0000627C 4E75                 		RTS
    2490   2540                               	
    2491   2541                               	
    2492   2542                               	*	---2E---	REQ FOR BLK I/O PORTS
    2493   2543 0000627E 6100 F51E            	BOK5	BSR	WAITDAT			; wait, then return DAT into host
    2494   2544 00006282 6100 F554            		BSR	PUTIFC
    2495   2545 00006286 6000 F97E            		BRA	HOSTOUT
    2496   2546                               	
    2497   2547                               	
    2498   2548                               	*	OMSG $33 - Set New timeout value
    2499   2549 0000628A 31F8 10AA 1050       	SNTO	MOVE.W	DAT3,HOSTTO		; set new value
    2500   2550 00006290 31F8 10AA 1052       		MOVE.W	DAT3,TOHOST		; ...and how long we'll wait
    2501   2551 00006296 6000 F96E            		BRA	HOSTOUT			; that's all there is to this one...



    2503   2553                               		TTL	'E B U S  --  PDP-10 Base Code,		I S I S   I N P U T'EBUS02.J01                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T            8-Oct-87  Page   58
Err Source Ref. Address   value
    line   line

    2505   2555                               	*		I S I S   R I N G   I N P U T
    2506   2556                               	
    2507   2557                               	
    2508   2558                               	
    2509   2559                               	
    2510   2560                               	*	Convenient Exit routines
    2511   2561                               	
    2512   2562                               	*	Place port number at DAT2 and send DAT to host
    2513   2563 0000629A 11F8 10A1 10A9       	PUTPN	MOVE.B	PORTNO+1,DAT2		; place port number
    2514   2564                               	
    2515   2565                               	*	send DAT to host
    2516   2566 000062A0 6100 F4FE            	SENDDAT	BSR	WRDAT
    2517   2567                               	
    2518   2568                               	*	all routines exit to here to clean up
    2519   2569 000062A4 6100 F208            	CLEANUP	BSR	ELIR
    2520   2570                               	
    2521   2571                               	*	INPUT TO PDP RING FROM ISIS RING
    2522   2572 000062A8 4A38 108B            	ISISIN	TST.B	HTDWN
    2523   2573 000062AC 6600 0604            		BNE.L	VERIFY			; Host not up, try Half-second logic
    2524   2574 000062B0 6100 F526            		BSR	PUTIFC
    2525   2575 000062B4 4A78 10F0            		TST.W	IRRN			; time to throttle input?
    2526   2576 000062B8 6D00 05F8            		BLT.L	VERIFY			; yes
    2527   2577 000062BC 6100 F168            		BSR	LOOK			; no...anything in ISIS ring?
    2528   2578 000062C0 6700 05F0            		BEQ.L	VERIFY			; No...go do Half-second stuff
    2529   2579 000062C4 31C4 109E            		MOVE.W	D4,INTYBT		; yes...save input Type-byte
    2530   2580 000062C8 6100 F53C            		BSR	FDRGSZ			; compute INRGSP
    2531   2581                               	
    2532   2582                               	*	Distinguish between Needles, Port-0, data, and control
    2533   2583 000062CC 3238 109E            		MOVE.W	INTYBT,D1		; get Type byte
    2534   2584 000062D0 6700 0142            		BEQ.L	NEEDLE			; special processing for needles
    2535   2585 000062D4 3038 10A0            		MOVE.W	PORTNO,D0		; port 0?
    2536   2586 000062D8 6700 050E            		BEQ.L	IPZ			; special processing for port 0
    2537   2587 000062DC 0C41 009E            		CMP.W	#$9E,D1			; data?
    2538   2588 000062E0 6C00 02D2            		BGE.L	IMESS			; Special processing if not
    2539   2589                               	
    2540   2590                               	*	We have a data-message to process
    2541   2591 000062E4 4A6C 001E            		TST.W	BCT(Rp)			; is anything already buffered?
    2542   2592 000062E8 6670                 		BNE	IS_BU			; add to buffer if so
    2543   2593 000062EA 082C 0006 0001       		BTST	#PF_BKI,P_FLAGS(Rp)	; is Block-input active?
    2544   2594 000062F0 6600 00A6            		BNE.L	BLOKIN			; skip if block-input in progress
    2545   2595 000062F4 082C 0004 0001       		BTST	#PF_HBP,P_FLAGS(Rp)	; has host applied back-pressure?
    2546   2596 000062FA 6654                 		BNE	IS_BUF			; skip to place in buffer if so
    2547   2597 000062FC 3638 109C            		MOVE.W	INRGSP,D3		; space in ring
    2548   2598 00006300 674E                 		BEQ	IS_BUF			; skip to place in buffer if none
    2549   2599 00006302 5543                 		SUBQ	#2,D3			; allow for header
    2550   2600                               	
    2551   2601                               	*	Limit ourself to 30-byte messages to host
    2552   2602 00006304 0C43 001E            		CMP.W	#30,D3			; ring-space > 30 chars?
    2553   2603 00006308 6F04                 		BLE	ISISIN1			; less...normal processing
    2554   2604 0000630A 363C 001E            		MOVE.W	#30,D3			; yes...make ring-space = 30EBUS02.J01                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T            8-Oct-87  Page   59
Err Source Ref. Address   value
    line   line

    2555   2605                               	
    2556   2606 0000630E B641                 	ISISIN1	CMP.W	D1,D3			; ring < MSG length?
    2557   2607 00006310 6F02                 		BLE	ISISIN2			; yes
    2558   2608 00006312 3601                 		MOVE.W	D1,D3			; message-length is number to move
    2559   2609                               	
    2560   2610 00006314 11C3 10A8            	ISISIN2	MOVE.B	D3,DAT1			; New type-byte
    2561   2611 00006318 0038 0080 10A8       		OR.B	#$80,DAT1		; Header is text length + $80
    2562   2612 0000631E 11F8 10A1 10A9       		MOVE.B	PORTNO+1,DAT2		; set output port number
    2563   2613 00006324 41F8 10AA            		LEA	DAT3,A0			; where to begin placing the characters
    2564   2614 00006328 6100 F120            	ISISIN3	BSR	GETCH			; copy chars
    2565   2615 0000632C 10C0                 		MOVE.B	D0,(A0)+
    2566   2616 0000632E 5378 109E            		SUB.W	#1,INTYBT
    2567   2617 00006332 5343                 		SUB.W	#1,D3			; done yet?
    2568   2618 00006334 6EF2                 		BGT	ISISIN3			; no
    2569   2619 00006336 43F8 10A8            		LEA	DAT,A1			; set up transmit cursor
    2570   2620                               	
    2571   2621 0000633A 2219                 	ISISIN4	MOVE.L	(A1)+,D1		; write DAT into host
    2572   2622 0000633C 6100 F466            		BSR	WRPDP
    2573   2623 00006340 B0C9                 		CMPA	A1,A0
    2574   2624 00006342 6EF6                 		BGT	ISISIN4			; repeat for entire message
    2575   2625 00006344 4A78 109E            		TST.W	INTYBT			; have we split data?
    2576   2626 00006348 6700 FF5A            		BEQ	CLEANUP			; no...finish message and on to next
    2577   2627 0000634C 6100 F48A            		BSR	PUTIFC			; yes...insure host sees it...buffer rest
    2578   2628                               	
    2579   2629                               	
    2580   2630                               	
    2581   2631                               	*	Buffer data because host said to...or because we split a message
    2582   2632 00006350 4A6C 001E            	IS_BUF	TST.W	BCT(Rp)			; anything already there?
    2583   2633 00006354 6604                 		BNE	IS_BU			; yes...just go do it
    2584   2634 00006356 6100 07F0            		BSR.L	BU_ADD			; no...add this port to list
    2585   2635                               	
    2586   2636                               	*	Move ISIS message to buffer
    2587   2637 0000635A 3038 109E            	IS_BU	MOVE.W	INTYBT,D0
    2588   2638 0000635E D06C 001E            		ADD.W	BCT(Rp),D0		; calculate amount to be in buffer
    2589   2639 00006362 B078 10EE            		CMP.W	BKPR,D0			; time to set back-pressure?
    2590   2640 00006366 6D14                 		BLT	IS_BU1			; not yet
    2591   2641 00006368 08EC 0003 0001       		BSET	#PF_IBP,P_FLAGS(Rp)	; set back-pressure applied
    2592   2642 0000636E 660C                 		BNE	IS_BU1			; already was set
    2593   2643 00006370 3638 10A0            		MOVE.W	PORTNO,D3		; for port
    2594   2644 00006374 183C 00A0            		MOVE.B	#$A0,D4			; apply back-pressure
    2595   2645 00006378 6100 F076            		BSR	SENDQI			; send Quick ISIS message
    2596   2646 0000637C 6100 F0CC            	IS_BU1	BSR	GETCH			; copy char to buffer
    2597   2647 00006380 6100 F562            		BSR	DWCI
    2598   2648 00006384 0C00 001B            		CMP.B	#ESC,D0			; escape code?
    2599   2649 00006388 6604                 		BNE	IS_BU2			; no
    2600   2650 0000638A 6100 F558            		BSR	DWCI			; yes...escape it
    2601   2651 0000638E 5378 109E            	IS_BU2	SUB.W	#1,INTYBT
    2602   2652 00006392 6EE8                 		BGT	IS_BU1
    2603   2653 00006394 6000 FF0E            		BRA	CLEANUP			; finish this message and do next
    2604   2654                               	
    2605   2655                               	EBUS02.J01                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T            8-Oct-87  Page   60
Err Source Ref. Address   value
    line   line

    2606   2656                               	*	BLOCK-INPUT
    2607   2657 00006398 082C 0007 0001       	BLOKIN	BTST	#PF_BFD,P_FLAGS(Rp)	; was Block FilleD?
    2608   2658 0000639E 66BA                 		BNE	IS_BU			; yes...place data into buffer
    2609   2659                               	
    2610   2660                               	*	Copy from ISIS-Ring to Block:  If terminated by Block-full
    2611   2661                               	*	then report termination.
    2612   2662 000063A0 382C 0014            	IS_BK	MOVE.W	BI_TCN(Rp),D4		; get total count for block
    2613   2663 000063A4 6100 F3D8            		BSR	GETBLK			; get the word
    2614   2664 000063A8 366C 0018            		MOVE.W	BI_BYT(Rp),A3		; cursor within DAT
    2615   2665 000063AC 47EB 10A8            		LEA	DAT(A3),A3		; position of next byte
    2616   2666 000063B0 4A78 109E            	IS_BK1	TST.W	INTYBT			; test if anything to get
    2617   2667 000063B4 6724                 		BEQ	IS_BK2			; skip if not
    2618   2668 000063B6 B86C 0016            		CMP.W	BI_LCN(Rp),D4		; see if any space left
    2619   2669 000063BA 671E                 		BEQ	IS_BK2			; skip if not
    2620   2670 000063BC 6100 F08C            		BSR	GETCH			; OK...get from ring
    2621   2671 000063C0 5378 109E            		SUB.W	#1,INTYBT		; decrement data-counter
    2622   2672 000063C4 526C 0016            		ADD.W	#1,BI_LCN(Rp)		; count another char input
    2623   2673 000063C8 16C0                 		MOVE.B	D0,(A3)+		; and save char
    2624   2674 000063CA B6FC 10AC            		CMPA.W	#DAT5,A3		; have we exhausted DAT?
    2625   2675 000063CE 6DE0                 		BLT	IS_BK1			; no
    2626   2676 000063D0 6100 F384            		BSR	WRBLK			; yes
    2627   2677 000063D4 47F8 10A8            		LEA	DAT,A3			; reset word cursor
    2628   2678 000063D8 60D6                 		BRA	IS_BK1
    2629   2679                               	
    2630   2680 000063DA 96FC 10A8            	IS_BK2	SUB.W	#DAT,A3			; compute displacement
    2631   2681 000063DE 394B 0018            		MOVE.W	A3,BI_BYT(Rp)		; save it for next time
    2632   2682 000063E2 6708                 		BEQ	IS_BK3			; at beginning of word
    2633   2683 000063E4 6100 F370            		BSR	WRBLK			; no...write word into PDP
    2634   2684 000063E8 53AC 0010            		SUB.L	#1,BI_TAR(Rp)		; back up word-cursor
    2635   2685 000063EC B86C 0016            	IS_BK3	CMP.W	BI_LCN(Rp),D4		; have we filled block?
    2636   2686 000063F0 670C                 		BEQ	IS_BK4			; yes
    2637   2687 000063F2 2478 103A            		MOVE.L	.FASTC,A2		; no...record current time
    2638   2688 000063F6 2952 000C            		MOVE.L	(A2),BI_TIM(Rp)
    2639   2689 000063FA 6000 FEA8            		BRA	CLEANUP			; close this message and go do next
    2640   2690                               	
    2641   2691                               	*	Block-input terminated
    2642   2692 000063FE 11FC 0027 10A8       	IS_BK4	MOVE.B	#$27,DAT1
    2643   2693 00006404 6100 FE58            		BSR	BKITERM			; terminate block-input
    2644   2694                               	
    2645   2695 00006408 4A78 109E            		TST.W	INTYBT			; see if more to do
    2646   2696 0000640C 6600 FF4C            		BNE	IS_BU			; yes...go copy rest of message to buffer
    2647   2697 00006410 6000 FE92            		BRA	CLEANUP			; go clean upEBUS02.J01                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T            8-Oct-87  Page   61
Err Source Ref. Address   value
    line   line

    2649   2699                               	*		ROUTINES TO PROCESS INDIVIDUAL ISIS MESSAGES
    2650   2700                               	
    2651   2701                               	
    2652   2702                               	*	A NEEDLE REQUEST IS PROCESSED HERE
    2653   2703 00006414 7004                 	NEEDLE	MOVEQ	#4,D0			; we'll need 4 bytes in the ISIS ring
    2654   2704 00006416 6100 EF28            		BSR	ROOM			;  ...for a response
    2655   2705 0000641A 6600 0496            		BNE.L	VERIFY			; Ignore this pass if not enough room there
    2656   2706 0000641E 3638 10A0            		MOVE.W	PORTNO,D3		; port number
    2657   2707 00006422 383C 00B9            		MOVE.W	#$B9,D4			; type = set transmit limit
    2658   2708 00006426 6100 EF50            		BSR	SLOR
    2659   2709 0000642A 701E                 		MOVEQ	#30,D0			; ...to 30d
    2660   2710 0000642C 6100 EF6A            		BSR	PUTCH
    2661   2711 00006430 6100 EFC4            		BSR	ELOR
    2662   2712 00006434 3238 109C            		MOVE.W	INRGSP,D1		; Also assume we'll need at least 80 bytes
    2663   2713 00006438 0C41 0050            		CMP.W	#80,D1			;  in the PDP to process a needle
    2664   2714 0000643C 6D00 0474            		BLT.L	VERIFY			; Ignore this pass if not enough room there
    2665   2715 00006440 6100 F008            		BSR	GETCH			; key
    2666   2716 00006444 6100 F046            		BSR	GETW			; Invoice
    2667   2717 00006448 6100 F02A            		BSR	GETH			; Dest. Host
    2668   2718 0000644C 6100 F026            		BSR	GETH			; Orig. Node
    2669   2719 00006450 31C0 10A2            		MOVE.W	D0,NORNODE
    2670   2720 00006454 6100 F01E            		BSR	GETH			; Orig. Host
    2671   2721 00006458 31C0 10A4            		MOVE.W	D0,NORHOST
    2672   2722 0000645C 6100 F016            		BSR	GETH			; Orig. Port
    2673   2723 00006460 31C0 10A6            		MOVE.W	D0,NORPORT
    2674   2724 00006464 6100 F026            		BSR	GETW			; Extra I.N. | XXX | TPC
    2675   2725 00006468 6100 F00A            		BSR	GETH			; Dest. Node
    2676   2726 0000646C 6100 EFDC            		BSR	GETCH			; CCT
    2677   2727 00006470 11C0 10DC            		MOVE.B	D0,NCCT
    2678   2728 00006474 6100 EFD4            		BSR	GETCH			; size
    2679   2729 00006478 11C0 10DD            		MOVE.B	D0,NSIZ
    2680   2730                               	
    2681   2731                               	*	Move the username from needle to DAT
    2682   2732 0000647C 1400                 		MOVE.B	D0,D2			; number of bytes of username
    2683   2733 0000647E 43F8 10AC            		LEA	DAT5,A1			; copy username into DAT5+
    2684   2734 00006482 6100 EFC6            	GETUN	BSR	GETCH
    2685   2735 00006486 12C0                 		MOVE.B	D0,(A1)+
    2686   2736 00006488 5302                 		SUB.B	#1,D2
    2687   2737 0000648A 6EF6                 		BGT	GETUN			; continue until copied
    2688   2738                               	
    2689   2739 0000648C 4A38 1107            		TST.B	PFULL			; ports still available?
    2690   2740 00006490 6600 00A4            		BNE.L	NEE1			; no
    2691   2741 00006494 4A38 108B            		TST.B	HTDWN			; yes...host up?
    2692   2742 00006498 6600 00C6            		BNE.L	NEE2			; no
    2693   2743 0000649C 4A38 104E            		TST.B	HSTAT			; yes...answered?
    2694   2744 000064A0 670C                 		BEQ	NEEDLE1			; yes
    2695   2745 000064A2 1038 10AC            		MOVE.B	DAT5,D0			; no...shut
    2696   2746 000064A6 0C00 00A1            		CMP.B	#$A1,D0			; "!" (Shut override)?
    2697   2747 000064AA 6600 00CE            		BNE.L	NEE4			; no
    2698   2748                               	EBUS02.J01                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T            8-Oct-87  Page   62
Err Source Ref. Address   value
    line   line

    2699   2749 000064AE 6100 F598            	NEEDLE1	BSR	RBTALL			; reset everything for port
    2700   2750 000064B2 08EC 0000 0001       		BSET	#PF_ACT,P_FLAGS(Rp)	; set port active
    2701   2751 000064B8 6100 F6A4            		BSR	IPORT			; bump number of active ports
    2702   2752 000064BC 1038 10DC            		MOVE.B	NCCT,D0			; translate CCT
    2703   2753 000064C0 0240 001F            		AND.W	#$1F,D0
    2704   2754 000064C4 41F8 390A            		LEA	CCTBD,A0
    2705   2755 000064C8 1970 0000 0003       		MOVE.B	0(A0,D0.W),IBRATE(Rp)	; record Input Baud rate in case host asks
    2706   2756                               	
    2707   2757 000064CE 11FC 0006 10A8       		MOVE.B	#6,DAT1			; type 6...New External Logon
    2708   2758 000064D4 11F8 10A1 10A9       		MOVE.B	PORTNO+1,DAT2		; port #
    2709   2759 000064DA 31F8 10A4 10AA       		MOVE.W	NORHOST,DAT3		; Origination host #
    2710   2760 000064E0 6100 F2BE            		BSR	WRDAT			; send DAT to host
    2711   2761                               	
    2712   2762 000064E4 11FC 0082 10A8       		MOVE.B	#$82,DAT1		; 2-byte Data message
    2713   2763 000064EA 11F8 10DC 10AA       		MOVE.B	NCCT,DAT3		; CCT
    2714   2764 000064F0 3038 10A2            		MOVE.W	NORNODE,D0
    2715   2765 000064F4 EC48                 		LSR.W	#6,D0
    2716   2766 000064F6 11C0 10AB            		MOVE.B	D0,DAT4			; high 6-bits of originating node
    2717   2767 000064FA 6100 F2A4            		BSR	WRDAT			; send DAT to Host
    2718   2768                               	
    2719   2769 000064FE 3038 10A2            		MOVE.W	NORNODE,D0
    2720   2770 00006502 0240 003F            		AND.W	#$3F,D0			; low 6-bits of originating host
    2721   2771 00006506 11C0 10AA            		MOVE.B	D0,DAT3
    2722   2772 0000650A 11F8 10A6 10AB       		MOVE.B	NORPORT,DAT4		; originating port
    2723   2773 00006510 6100 F28E            		BSR	WRDAT			; send DAT to host
    2724   2774                               	
    2725   2775                               	*	Now move the username from DAT into host
    2726   2776 00006514 1438 10DD            		MOVE.B	NSIZ,D2			; number of bytes
    2727   2777 00006518 43F8 10AC            		LEA	DAT5,A1			; where to copy from
    2728   2778 0000651C 0C02 0001            	PUTUN	CMP.B	#1,D2			; single byte?
    2729   2779 00006520 6604                 		BNE	PUTUN1			; no
    2730   2780 00006522 5338 10A8            		SUB.B	#1,DAT1			; yes...reduce count
    2731   2781 00006526 31D9 10AA            	PUTUN1	MOVE.W	(A1)+,DAT3		; copy next pair of bytes
    2732   2782 0000652A 6100 F274            		BSR	WRDAT			; send DAT to host
    2733   2783 0000652E 5502                 		SUB.B	#2,D2			; reduce count
    2734   2784 00006530 6EEA                 		BGT	PUTUN			; continue until name sent
    2735   2785 00006532 6000 FD70            		BRA	CLEANUP			; Done
    2736   2786                               	
    2737   2787                               	*	Out of ports...Must zap circuit for current needle
    2738   2788 00006536 41F8 6582 4E71       	NEE1	LEA	OOPMSG,A0		; set pointer
    2739   2789 0000653C 6100 EECA            		BSR	SENDTEXT		; tell reason (with bells)
    2740   2790 00006540 6100 EE1C            		BSR	WAITISW			; we'll need 1 word to return Zapper
    2741   2791 00006544 3638 10A0            		MOVE.W	PORTNO,D3		; port number
    2742   2792 00006548 183C 00BE            		MOVE.B	#$BE,D4			; Type = Zap with reason
    2743   2793 0000654C 6100 EE2A            		BSR	SLOR
    2744   2794 00006550 4240                 		CLR.W	D0			; reason = 0 -- out of ports
    2745   2795 00006552 6100 EE44            		BSR	PUTCH
    2746   2796 00006556 6100 EE9E            		BSR	ELOR
    2747   2797 0000655A 4242                 		CLR.W	D2
    2748   2798 0000655C 6000 FD46            		BRA	CLEANUP			; go clean up
    2749   2799                               	EBUS02.J01                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T            8-Oct-87  Page   63
Err Source Ref. Address   value
    line   line

    2750   2800                               	*	Host down
    2751   2801 00006560 41F8 6598 4E71       	NEE2	LEA	HDNMSG,A0		; set pointer
    2752   2802                               	
    2753   2803 00006566 6100 EEA0            	NEE3	BSR	SENDTEXT		; tell user
    2754   2804 0000656A 3638 10A0            		MOVE.W	PORTNO,D3
    2755   2805 0000656E 183C 009E            		MOVE.B	#$9E,D4			; detach circuit
    2756   2806 00006572 6100 EE7C            		BSR	SENDQI
    2757   2807 00006576 6000 FD2C            		BRA	CLEANUP			; go clean up needle
    2758   2808                               	
    2759   2809                               	*	Host Shut
    2760   2810 0000657A 41F8 65A6 4E71       	NEE4	LEA	HSHMSG,A0		; set pointer
    2761   2811 00006580 60E4                 		BRA	NEE3			; and go clean up
    2762   2812                               	
    2763   2813 00006582                      	OOPMSG	TEXTC	<$87,'[Host out of ports]',$87>
    2764   2821 00006598                      	HDNMSG	TEXTC	<$87,'[Host down]',$87>
    2765   2827 000065A6                      	HSHMSG	TEXTC	<$87,'[Host shut]',$87>EBUS02.J01                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T            8-Oct-87  Page   64
Err Source Ref. Address   value
    line   line

    2767   2834                               	*	Determine handler for ISIS message -- D1 = INTYBT
    2768   2835 000065B4 0C41 00C1            	IMESS	CMP.W	#$C1,D1			; range check on type
    2769   2836 000065B8 6C00 EC20            		BGE	ISMGER			; Bad ISIS input MSG
    2770   2837 000065BC 0441 009E            		SUB.W	#$9E,D1			; bias type-code to tables
    2771   2838 000065C0 6D00 EC18            		BLT	ISMGER			; Bad ISIS input MSG
    2772   2839 000065C4 4240                 		CLR.W	D0
    2773   2840 000065C6 103B 1012            		MOVE.B	TRISLN(PC,D1.W),D0	; is there space to proceed?
    2774   2841 000065CA B078 109C            		CMP.W	INRGSP,D0		; space in ring
    2775   2842 000065CE 6C00 02E2            		BGE.L	VERIFY			; abort this go-roundie if not
    2776   2843 000065D2 D241                 		ADD.W	D1,D1			; *2
    2777   2844 000065D4 327B 1028            		MOVE.W	IMSTAB(PC,D1.W),A1	; look up handler address
    2778   2845 000065D8 4ED1                 		JMP	(A1)			; ...and go there
    2779   2846                               	
    2780   2847                               	
    2781   2848                               	*	TRANSLATED ISIS MSG LENGTH
    2782   2849 000065DA 00                   	TRISLN	DC.B	0			; 9E
    2783   2850 000065DB 02                   		DC.B	2			; 9F
    2784   2851 000065DC 02                   		DC.B	2			; A0
    2785   2852 000065DD 02                   		DC.B	2			; A1
    2786   2853 000065DE 02                   		DC.B	2			; A2
    2787   2854 000065DF 00                   		DC.B	0			; A3
    2788   2855 000065E0 03                   		DC.B	3			; A4
    2789   2856 000065E1 03                   		DC.B	3			; A5
    2790   2857 000065E2 02                   		DC.B	2			; A6
    2791   2858 000065E3 02                   		DC.B	2			; A7
    2792   2859 000065E4 00                   		DC.B	0			; A8
    2793   2860 000065E5 00                   		DC.B	0			; A9
    2794   2861 000065E6 02                   		DC.B	2			; AA
    2795   2862 000065E7 02                   		DC.B	2			; AB
    2796   2863 000065E8 02                   		DC.B	2			; AC
    2797   2864 000065E9 02                   		DC.B	2			; AD
    2798   2865 000065EA 02                   		DC.B	2			; AE
    2799   2866 000065EB 00                   		DC.B	0			; AF
    2800   2867 000065EC 00                   		DC.B	0			; B0
    2801   2868 000065ED 04                   		DC.B	4			; B1
    2802   2869 000065EE 00                   		DC.B	0			; B2
    2803   2870 000065EF 00                   		DC.B	0			; B3
    2804   2871 000065F0 00                   		DC.B	0			; B4
    2805   2872 000065F1 03                   		DC.B	3			; B5
    2806   2873 000065F2 06                   		DC.B	6			; B6
    2807   2874 000065F3 00                   		DC.B	0			; B7
    2808   2875 000065F4 00                   		DC.B	0			; B8
    2809   2876 000065F5 00                   		DC.B	0			; B9
    2810   2877 000065F6 00                   		DC.B	0			; BA
    2811   2878 000065F7 00                   		DC.B	0			; BB
    2812   2879 000065F8 00                   		DC.B	0			; BC
    2813   2880 000065F9 00                   		DC.B	0			; BD
    2814   2881 000065FA 00                   		DC.B	0			; BE
    2815   2882 000065FB 00                   		DC.B	0			; BF
    2816   2883 000065FC 00                   		DC.B	0			; C0EBUS02.J01                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T            8-Oct-87  Page   65
Err Source Ref. Address   value
    line   line

    2817   2884 000065FD 00                   		DC.B	0			; C1
    2818   2885                               	
    2819   2886                               	
    2820   2887                               	*	ISIS INPUT MESSAGE DISPATCH TABLE
    2821   2888 000065FE 62A4                 	IMSTAB	DC.W	CLEANUP			; 9E - DETACH, IGNORE
    2822   2889 00006600 6646                 		DC.W	ZAPPER			; 9F - ZAPPER, process and send on
    2823   2890 00006602 6658                 		DC.W	BPON			; A0 - SET BKPR, SEND ON
    2824   2891 00006604 6660                 		DC.W	BPOFF			; A1 - RELEASE BKPR, SEND ON
    2825   2892 00006606 6668                 		DC.W	GOBBLER			; A2 - GOBBLER, Send on
    2826   2893 00006608 62A4                 		DC.W	CLEANUP			; A3 - FLUSH INPUT, IGNORE
    2827   2894 0000660A 6680                 		DC.W	BLACK			; A4 - BLACK BALL
    2828   2895 0000660C 667A                 		DC.W	GRAY			; A5 - GRAY BALL
    2829   2896 0000660E 66A2                 		DC.W	STREAM			; A6 - ENTER DEM, Send on
    2830   2897 00006610 66A2                 		DC.W	STREAM			; A7 - LEAVE DEM, Send on
    2831   2898 00006612 62A4                 		DC.W	CLEANUP			; A8 - ENTER TRANSPARENCY, IGNORE
    2832   2899 00006614 62A4                 		DC.W	CLEANUP			; A9 - LEAVE TRANSPARENCY, IGNORE
    2833   2900 00006616 66A2                 		DC.W	STREAM			; AA - GREEN BALL, Send on
    2834   2901 00006618 66A2                 		DC.W	STREAM			; AB - RED BALL, Send on
    2835   2902 0000661A 6688                 		DC.W	YELLOW			; AC - YELLOW BALL, SEND ON
    2836   2903 0000661C 66BA                 		DC.W	ISP			; AD - ORANGE BALL, Send on immediately
    2837   2904 0000661E 66A2                 		DC.W	STREAM			; AE - BREAK BEGIN, Send on
    2838   2905 00006620 62A4                 		DC.W	CLEANUP			; AF - HANG UP, IGNORE
    2839   2906 00006622 62A4                 		DC.W	CLEANUP			; B0 - QUERY TERM CHAR, IGNORE
    2840   2907 00006624 66E2                 		DC.W	ITERM			; B1 - SET TERM CHAR
    2841   2908 00006626 6704                 		DC.W	PNEDL			; B2 - PSEUDO NEEDLE
    2842   2909 00006628 51DA                 		DC.W	ISMGER			; B3 - LOGON CHAR (we don't expect this)
    2843   2910 0000662A 62A4                 		DC.W	CLEANUP			; B4 - LOGON STATUS, IGNORE
    2844   2911 0000662C 6750                 		DC.W	LOGFAL			; B5 - LOGON FAILED
    2845   2912 0000662E 677C                 		DC.W	ILOG			; B6 - LOGON OKAY
    2846   2913 00006630 51DA                 		DC.W	ISMGER			; B7 - ACCOUNTING (we don't expect this)
    2847   2914 00006632 62A4                 		DC.W	CLEANUP			; B8 - SUPER HANG, IGNORE
    2848   2915 00006634 67D4                 		DC.W	SMTLMT			; B9 - SET XMT LIMIT
    2849   2916 00006636 62A4                 		DC.W	CLEANUP			; BA - BREAK END, IGNORE
    2850   2917 00006638 62A4                 		DC.W	CLEANUP			; BB - ZAP ACKNOWLEDGE, IGNORE
    2851   2918 0000663A 62A4                 		DC.W	CLEANUP			; BC - ENTER ALT DEV MODE, IGNORE
    2852   2919 0000663C 62A4                 		DC.W	CLEANUP			; BD - LEAVE ALT DEV MODE, IGNORE
    2853   2920 0000663E 62A4                 		DC.W	CLEANUP			; BE - ZAP WITH REASON,IGNORE
    2854   2921 00006640 62A4                 		DC.W	CLEANUP			; BF - SIIX COMMAND, IGNORE
    2855   2922 00006642 62A4                 		DC.W	CLEANUP			; C0 - TIIX COMMAND, IGNORE
    2856   2923 00006644 51DA                 		DC.W	ISMGER			; C1 - UUO (we don't expect this)
    2857   2924                               	
    2858   2925                               	
    2859   2926                               	*	9F -- Zapper
    2860   2927 00006646 08AC 0000 0001       	ZAPPER	BCLR	#PF_ACT,P_FLAGS(Rp)	; test if port active (and reset it)
    2861   2928 0000664C 676C                 		BEQ	ISP			; no...just proceed
    2862   2929 0000664E 6100 F526            		BSR	DPORT			; yes...count it gone
    2863   2930 00006652 6100 F3F4            		BSR	RBTALL			; reset everything
    2864   2931 00006656 6062                 		BRA	ISP			; ...and proceed
    2865   2932                               	
    2866   2933                               	
    2867   2934                               	*	A0 -- apply back-pressureEBUS02.J01                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T            8-Oct-87  Page   66
Err Source Ref. Address   value
    line   line

    2868   2935 00006658 08EC 0002 0001       	BPON	BSET	#PF_OBP,P_FLAGS(Rp)	; set output back-pressure
    2869   2936 0000665E 605A                 		BRA	ISP
    2870   2937                               	
    2871   2938                               	*	A1 -- release back-pressure
    2872   2939 00006660 08AC 0002 0001       	BPOFF	BCLR	#PF_OBP,P_FLAGS(Rp)	; clear output back-pressure
    2873   2940 00006666 6052                 		BRA	ISP
    2874   2941                               	
    2875   2942                               	*	A2 -- Gobbler
    2876   2943 00006668 082C 0006 0001       	GOBBLER	BTST	#PF_BKI,P_FLAGS(Rp)	; block-input active?
    2877   2944 0000666E 664A                 		BNE	ISP			; yes...just pass it on
    2878   2945 00006670 6100 F2F0            		BSR	DEMPTY			; no...empty the buffer
    2879   2946 00006674 6100 04BC            		BSR.L	BU_EMP			; release back-pressure
    2880   2947 00006678 6040                 		BRA	ISP			; ...then pass it on
    2881   2948                               	
    2882   2949                               	
    2883   2950                               	*	A5 -- Gray ball
    2884   2951 0000667A 4238 10AA            	GRAY	CLR.B	DAT3			; d3 = 0 for grey ball
    2885   2952 0000667E 603A                 		BRA	ISP			; then process as special message
    2886   2953                               	
    2887   2954                               	*	A4 -- Black Ball
    2888   2955 00006680 11FC 00FF 10AA       	BLACK	MOVE.B	#-1,DAT3		; special parameter
    2889   2956 00006686 6032                 		BRA	ISP
    2890   2957                               	
    2891   2958                               	
    2892   2959                               	*	AC - Yellow Ball
    2893   2960                               	*	Special handling for Block-input active, since Yellow-ball
    2894   2961                               	*	serves to indicate EOT.
    2895   2962 00006688 082C 0006 0001       	YELLOW	BTST	#PF_BKI,P_FLAGS(Rp)	; is block-input active?
    2896   2963 0000668E 6712                 		BEQ	STREAM			; no...process as normal in-stream code
    2897   2964 00006690 082C 0007 0001       		BTST	#PF_BFD,P_FLAGS(Rp)	; yes...test Block-FilleD
    2898   2965 00006696 6610                 		BNE	STREAM1			; was set...place yellow-ball into buffer
    2899   2966 00006698 11FC 0028 10A8       		MOVE.B	#$28,DAT1		; no...set Bin terminated by EOT
    2900   2967 0000669E 6100 FBBE            		BSR	BKITERM			; terminate block-input
    2901   2968                               						; ...then proceed with in-stream usage
    2902   2969                               	
    2903   2970                               	
    2904   2971                               	*	Special Message...retain in-stream
    2905   2972 000066A2 4A6C 001E            	STREAM	TST.W	BCT(Rp)			; anything in buffer?
    2906   2973 000066A6 6712                 		BEQ	ISP			; no...just pass it on
    2907   2974                               	
    2908   2975 000066A8 701B                 	STREAM1	MOVEQ	#ESC,D0			; Yes...place escape
    2909   2976 000066AA 6100 F238            		BSR	DWCI			;  ...into buffer
    2910   2977 000066AE 3038 109E            		MOVE.W	INTYBT,D0		;   ...followed by ISIS Code
    2911   2978 000066B2 6100 F230            		BSR	DWCI
    2912   2979 000066B6 6000 FBEC            		BRA	CLEANUP			; done...escaped code will be removed later
    2913   2980                               	
    2914   2981                               	
    2915   2982                               	*	Single-byte ISIS message
    2916   2983                               	*	MSG types 9F, A0, A1, A2, A6, A7, AA, AB, AC, AD, AE
    2917   2984 000066BA 6104                 	ISP	BSR	LOOKUP			; go translate message-type
    2918   2985 000066BC 6000 FBDC            		BRA	PUTPN			; go send itEBUS02.J01                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T            8-Oct-87  Page   67
Err Source Ref. Address   value
    line   line

    2919   2986                               	
    2920   2987                               	*	Translate ISIS message-type to PDP type, place into DAT1
    2921   2988 000066C0 3238 109E            	LOOKUP	MOVE.W	INTYBT,D1
    2922   2989 000066C4 0441 009F            		SUB.W	#$9F,D1
    2923   2990 000066C8 11FB 1008 10A8 4E71  		MOVE.B	ISPTAB(PC,D1.W),DAT1	; translated message-type
    2924   2991 000066D0 4E75                 		RTS
    2925   2992                               	
    2926   2993                               	*	Translation table for ISIS special ( > $9E ) messages
    2927   2994 000066D2 0B                   	ISPTAB	DC.B	11			; 9F - Zapper
    2928   2995 000066D3 08                   		DC.B	8			; A0 - Apply backpressure
    2929   2996 000066D4 09                   		DC.B	9			; A1 - Release backpressure
    2930   2997 000066D5 0A                   		DC.B	10			; A2 - Gobbler
    2931   2998 000066D6 00                   		DC.B	0			; A3 -
    2932   2999 000066D7 15                   		DC.B	21			; A4 - Black Ball
    2933   3000 000066D8 15                   		DC.B	21			; A5 - Gray Ball
    2934   3001 000066D9 0C                   		DC.B	12			; A6 - Enter DEM
    2935   3002 000066DA 0D                   		DC.B	13			; A7 - Leave DEM
    2936   3003 000066DB 00                   		DC.B	0			; A8 -
    2937   3004 000066DC 00                   		DC.B	0			; A9 -
    2938   3005 000066DD 0E                   		DC.B	14			; AA - Green Ball
    2939   3006 000066DE 0F                   		DC.B	15			; AB - Red Ball
    2940   3007 000066DF 10                   		DC.B	16			; AC - Yellow Ball
    2941   3008 000066E0 11                   		DC.B	17			; AD - Orange Ball
    2942   3009 000066E1 2F                   		DC.B	47			; AE - Break Begin
    2943   3010                               	
    2944   3011                               	
    2945   3012                               	*	B1 -- Terminal-characteristics response
    2946   3013 000066E2 11FC 0020 10A8       	ITERM	MOVE.B	#$20,DAT1		; type
    2947   3014 000066E8 6100 ED60            		BSR	GETCH			; parameter number
    2948   3015 000066EC 0C00 0010            		CMP.B	#$10,D0			;				<2.2
    2949   3016 000066F0 6602                 		BNE	NOJAP			;				<2.2
    2950   3017 000066F2 5300                 		SUB.B	#1,D0			; translate 16d to 15d		<2.2
    2951   3018 000066F4 11C0 10AA            	NOJAP	MOVE.B	D0,DAT3			; parameter code
    2952   3019 000066F8 6100 ED50            		BSR	GETCH
    2953   3020 000066FC 11C0 10AB            		MOVE.B	D0,DAT4			; value
    2954   3021 00006700 6000 FB98            		BRA	PUTPN			; send it
    2955   3022                               	
    2956   3023                               	
    2957   3024                               	*	B2 -- Pseudo-Needle
    2958   3025 00006704 6100 F342            	PNEDL	BSR	RBTALL			; first, clean up port
    2959   3026 00006708 6100 ED40            		BSR	GETCH			; padding
    2960   3027 0000670C 6100 ED66            		BSR	GETH			; local key
    2961   3028 00006710 1940 0003            		MOVE.B	D0,AUXKEY(Rp)		; save it
    2962   3029 00006714 4A38 1107            		TST.B	PFULL			; room for another circuit?
    2963   3030 00006718 6618                 		BNE	PFULL1			; skip if not
    2964   3031 0000671A 6100 F32C            		BSR	RBTALL			; reset everything for port
    2965   3032 0000671E 08EC 0001 0001       		BSET	#PF_ILI,P_FLAGS(Rp)	; set port In_Log-In
    2966   3033 00006724 6100 F438            		BSR	IPORT
    2967   3034 00006728 31FC FFFF 1060       		MOVE.W	#-1,AUXX		; enable another aux-request
    2968   3035 0000672E 6000 FB74            		BRA	CLEANUP			; go clean up
    2969   3036                               	EBUS02.J01                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T            8-Oct-87  Page   68
Err Source Ref. Address   value
    line   line

    2970   3037                               	*	Out of ports...Must zap circuit for B2
    2971   3038 00006732 6100 EC2A            	PFULL1	BSR	WAITISW			; we'll need 1 word to return Zapper
    2972   3039 00006736 3638 10A0            		MOVE.W	PORTNO,D3		; port number
    2973   3040 0000673A 183C 00BE            		MOVE.B	#$BE,D4			; Type = Zap with reason
    2974   3041 0000673E 6100 EC38            		BSR	SLOR
    2975   3042 00006742 4240                 		CLR.W	D0			; reason = 0 -- out of ports
    2976   3043 00006744 6100 EC52            		BSR	PUTCH
    2977   3044 00006748 6100 ECAC            		BSR	ELOR
    2978   3045 0000674C 7008                 		MOVEQ	#8,D0			; fake reason to "out of orig. ports"
    2979   3046 0000674E 6008                 		BRA	LOGFAL1			; tell host that Aux-circuit attempt failed
    2980   3047                               	
    2981   3048                               	
    2982   3049                               	*	B5 -- Logon failure
    2983   3050 00006750 6100 F2F6            	LOGFAL	BSR	RBTALL			; clear the port
    2984   3051 00006754 6100 ECF4            		BSR	GETCH			; get reason
    2985   3052 00006758 31FC FFFF 1060       	LOGFAL1	MOVE.W	#-1,AUXX		; enable another AUX attempt
    2986   3053 0000675E 11FC 0017 10A8       		MOVE.B	#$17,DAT1		; message type
    2987   3054 00006764 11F8 105B 10A9       		MOVE.B	AUXQ+1,DAT2		; AUX circuit key
    2988   3055 0000676A 11C0 10AA            		MOVE.B	D0,DAT3			; error code
    2989   3056 0000676E 6600 FB30            		BNE	SENDDAT			; send to PDP (unless 0)
    2990   3057 00006772 11FC 0007 10AA       		MOVE.B	#7,DAT3			; code 0 -> 7
    2991   3058 00006778 6000 FB26            		BRA	SENDDAT
    2992   3059                               	
    2993   3060                               	
    2994   3061                               	*	B6 -- Logon OK
    2995   3062 0000677C 6100 ECCC            	ILOG	BSR	GETCH			; padding
    2996   3063 00006780 6100 ED0A            		BSR	GETW			; Invoice number
    2997   3064 00006784 6100 ECEE            		BSR	GETH			; orig. host
    2998   3065 00006788 3638 10A0            		MOVE.W	PORTNO,D3		; for this port,
    2999   3066 0000678C 383C 00B9            		MOVE.W	#$B9,D4			; ...set transmit limit
    3000   3067 00006790 6100 EBE6            		BSR	SLOR
    3001   3068 00006794 701E                 		MOVEQ	#30,D0			; ...to 30d
    3002   3069 00006796 6100 EC00            		BSR	PUTCH
    3003   3070 0000679A 6100 EC5A            		BSR	ELOR
    3004   3071 0000679E 08AC 0001 0001       		BCLR	#PF_ILI,P_FLAGS(Rp)	; clear port In_Log-In
    3005   3072 000067A4 08EC 0000 0001       		BSET	#PF_ACT,P_FLAGS(Rp)	; set port active
    3006   3073 000067AA 11FC 0007 10A8       		MOVE.B	#7,DAT1
    3007   3074 000067B0 11F8 10A1 10A9       		MOVE.B	PORTNO+1,DAT2
    3008   3075 000067B6 11EC 0003 10AA       		MOVE.B	AUXKEY(Rp),DAT3		; orig port
    3009   3076 000067BC 6100 EFE2            		BSR	WRDAT			; send DAT on to PDP
    3010   3077 000067C0 11FC 0017 10A8       		MOVE.B	#$17,DAT1		; tell PDP which AUX succeeded
    3011   3078 000067C6 11EC 0003 10A9       		MOVE.B	AUXKEY(Rp),DAT2		; orig port
    3012   3079 000067CC 4278 10AA            		CLR.W	DAT3			; set success-code
    3013   3080 000067D0 6000 FACE            		BRA	SENDDAT			; send DAT to host
    3014   3081                               	
    3015   3082                               	
    3016   3083                               	*	B9 - SET XMT LIMIT
    3017   3084 000067D4 6100 EC74            	SMTLMT	BSR	GETCH			; get limit
    3018   3085 000067D8 5B00                 		SUB.B	#5,D0			; round down
    3019   3086 000067DA 0200 00FC            		AND.B	#$FC,D0
    3020   3087 000067DE 5400                 		ADD.B	#2,D0			; round back upEBUS02.J01                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T            8-Oct-87  Page   69
Err Source Ref. Address   value
    line   line

    3021   3088 000067E0 1940 0002            		MOVE.B	D0,XMITLMT(Rp)		; save transmit-limit
    3022   3089 000067E4 6000 FABE            		BRA	CLEANUP			; nothing to tell hostEBUS02.J01                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T            8-Oct-87  Page   70
Err Source Ref. Address   value
    line   line

    3024   3091                               	*	PROCESS PORT-ZERO MESSAGES
    3025   3092                               	
    3026   3093                               	
    3027   3094                               	*	D0 = 0;  D1 = INTYBT
    3028   3095 000067E8 0C41 0010            	IPZ	CMP.W	#$10,D1			; is this valid Port 0 message?
    3029   3096 000067EC 6E00 E9EC            		BGT	ISMGER			; not in range -- crash
    3030   3097 000067F0 103B 1012            		MOVE.B	INISLN(PC,D1),D0	; will MSG fit?
    3031   3098 000067F4 B078 109C            		CMP.W	INRGSP,D0		; space in ring
    3032   3099 000067F8 6C00 00B8            		BGE.L	VERIFY			; no...go to VERIFY
    3033   3100 000067FC D241                 		ADD.W	D1,D1			; 2*message type
    3034   3101 000067FE 327B 1016            		MOVE.W	IPZTAB(PC,D1),A1	; get the service address
    3035   3102 00006802 4ED1                 		JMP	(A1)			; go service port0 message
    3036   3103                               	
    3037   3104                               	*	INTRA-ISIS MSG LENGTH
    3038   3105 00006804 00                   	INISLN	DC.B	0			; 00
    3039   3106 00006805 00                   		DC.B	0			; 01
    3040   3107 00006806 02                   		DC.B	2			; 02
    3041   3108 00006807 00                   		DC.B	0			; 03
    3042   3109 00006808 00                   		DC.B	0			; 04
    3043   3110 00006809 00                   		DC.B	0			; 05
    3044   3111 0000680A 06                   		DC.B	6			; 06
    3045   3112 0000680B 00                   		DC.B	0			; 07
    3046   3113 0000680C 00                   		DC.B	0			; 08
    3047   3114 0000680D 03                   		DC.B	3			; 09
    3048   3115 0000680E 00                   		DC.B	0			; 0A
    3049   3116 0000680F 00                   		DC.B	0			; 0B
    3050   3117 00006810 00                   		DC.B	0			; 0C
    3051   3118 00006811 02                   		DC.B	2			; 0D
    3052   3119 00006812 00                   		DC.B	0			; 0E
    3053   3120 00006813 00                   		DC.B	0			; 0F
    3054   3121 00006814 00                   		DC.B	0			; 10
    3055   3122                               	
    3056   3123                               	
    3057   3124                               	*	ISIS INTRA-NODE MESSAGE DISPATCH TABLE
    3058   3125 00006816 51DA                 	IPZTAB	DC.W	ISMGER			; 00 RESTRT REQ -- Not Expected
    3059   3126 00006818 51DA                 		DC.W	ISMGER			; 01 RESTRT RESP -- Not Expected
    3060   3127 0000681A 6838                 		DC.W	SUPTAK			; 02 SUPERVISOR TAKEOVER
    3061   3128 0000681C 51DA                 		DC.W	ISMGER			; 03 REPORT TO SUP -- Not Expected
    3062   3129 0000681E 51DA                 		DC.W	ISMGER			; 04 HOST STATUS -- Not Expected
    3063   3130 00006820 51DA                 		DC.W	ISMGER			; 05 ACCNTNG -- Not Expected
    3064   3131 00006822 684C                 		DC.W	IPTIME			; 06 SUP TIME
    3065   3132 00006824 51DA                 		DC.W	ISMGER			; 07 NORM CIR REQ -- Not Expected
    3066   3133 00006826 51DA                 		DC.W	ISMGER			; 08 AUX CIR REQ -- Not Expected
    3067   3134 00006828 6874                 		DC.W	AUXERR			; 09 AUX CIRCUIT ERROR
    3068   3135 0000682A 51DA                 		DC.W	ISMGER			; 0A HOST PORT AVAIL -- Not Expected
    3069   3136 0000682C 68A2                 		DC.W	HSTUNA			; 0B HOST UNACCEPTABLE
    3070   3137 0000682E 51DA                 		DC.W	ISMGER			; 0C HOST COST -- Not Expected
    3071   3138 00006830 6838                 		DC.W	SUPTAK			; 0D SUPERVISOR LOST
    3072   3139 00006832 51DA                 		DC.W	ISMGER			; 0E 1-DOWN -- Not Expected
    3073   3140 00006834 51DA                 		DC.W	ISMGER			; 0F REPORT ALL HOSTS -- Not ExpectedEBUS02.J01                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T            8-Oct-87  Page   71
Err Source Ref. Address   value
    line   line

    3074   3141 00006836 51DA                 		DC.W	ISMGER			; 10 HOST STATUS -- Not Expected
    3075   3142                               	
    3076   3143                               	
    3077   3144                               	
    3078   3145                               	*	0.2 -- Takeover (or 0.D -- Sup. Lost)
    3079   3146 00006838 31FC FFFF 1060       	SUPTAK	MOVE.W	#-1,AUXX		; cancel outstanding AUX requests
    3080   3147 0000683E 11FC 0005 10A8       		MOVE.B	#5,DAT1			; type 5
    3081   3148 00006844 4238 10A9            		CLR.B	DAT2			; port 0
    3082   3149 00006848 6000 FA56            		BRA	SENDDAT			; send DAT to PDP
    3083   3150                               	
    3084   3151                               	
    3085   3152                               	*	0.6 -- GMT report
    3086   3153 0000684C 11FC 0023 10A8       	IPTIME	MOVE.B	#$23,DAT1
    3087   3154 00006852 4238 10A9            		CLR.B	DAT2			; for port 0...
    3088   3155 00006856 6100 EBF2            		BSR	GETCH			; skip padding
    3089   3156 0000685A 6100 EC30            		BSR	GETW
    3090   3157 0000685E 21C0 10AA            		MOVE.L	D0,DAT3			; save all bytes
    3091   3158 00006862 6100 EF3C            		BSR	WRDAT			; send to PDP
    3092   3159 00006866 2238 10AC            		MOVE.L	DAT5,D1			; get next word
    3093   3160 0000686A 4241                 		CLR.W	D1			; pad it out with 0
    3094   3161 0000686C 6100 EF36            		BSR	WRPDP			; and send it too
    3095   3162 00006870 6000 FA32            		BRA	CLEANUP			; then exit
    3096   3163                               	
    3097   3164                               	
    3098   3165                               	*	0.9 -- AUX circuit error
    3099   3166 00006874 6100 EBD4            	AUXERR	BSR	GETCH			; padding
    3100   3167 00006878 6100 EBFA            		BSR	GETH			; local key
    3101   3168 0000687C 31FC FFFF 1060       		MOVE.W	#-1,AUXX		; re-enable Aux circuits
    3102   3169 00006882 11FC 0017 10A8       		MOVE.B	#$17,DAT1		; type 23d
    3103   3170 00006888 11C0 10A9            		MOVE.B	D0,DAT2			; local key (port # - who made request)
    3104   3171 0000688C 6100 EBBC            		BSR	GETCH			; error code
    3105   3172 00006890 11C0 10AA            		MOVE.B	D0,DAT3
    3106   3173 00006894 6600 FA0A            		BNE	SENDDAT			; send DAT (unless error=0)
    3107   3174 00006898 11FC 0007 10AA       		MOVE.B	#7,DAT3			; 0 -> 7
    3108   3175 0000689E 6000 FA00            		BRA	SENDDAT			; send DAT
    3109   3176                               	
    3110   3177                               	
    3111   3178                               	*	0.0B -- HOST UNACCEPTABLE
    3112   3179 000068A2 6100 EBA6            	HSTUNA	BSR	GETCH			; IGNORE FOR NOW *****
    3113   3180 000068A6 6100 EBCC            		BSR	GETH
    3114   3181 000068AA 6100 EB9E            		BSR	GETCH
    3115   3182 000068AE 6000 F9F4            		BRA	CLEANUP



    3117   3184                               		TTL	'E B U S  --  PDP-10 Base Code,		H O S T   S T A T U S'EBUS02.J01                 E B U S  --  PDP-10 Base Code,		H O S T   S T A T U S          8-Oct-87  Page   72
Err Source Ref. Address   value
    line   line

    3119   3186                               	*		V E R I F Y   H O S T ,   C H E C K   C O N S I S T A N C Y
    3120   3187                               	
    3121   3188                               	
    3122   3189 000068B2 4A38 108B            	VERIFY	TST.B	HTDWN			; is host up?
    3123   3190 000068B6 6704                 		BEQ	HALFSEC			; yes
    3124   3191 000068B8 6100 F134            		BSR	HODOWN			; no, tel SUP Host is Down
    3125   3192                               	
    3126   3193                               	
    3127   3194                               	*	Half-second logic.  Check if Host is up
    3128   3195 000068BC 2078 103A            	HALFSEC	MOVE.L	.FASTC,A0
    3129   3196 000068C0 2010                 		MOVE.L	(A0),D0
    3130   3197 000068C2 B0B8 10E8            		CMP.L	LFASTC,D0		; LFASTC specifies NEXT time to do it!
    3131   3198 000068C6 6D00 0088            		BLT.L	HALFSEX			; not time yet
    3132   3199 000068CA 0680 0000 012C       		ADD.L	#300,D0			; we do this every half-second
    3133   3200 000068D0 21C0 10E8            		MOVE.L	D0,LFASTC		; set time for NEXT test
    3134   3201 000068D4 4A38 108B            		TST.B	HTDWN			; check current state...
    3135   3202 000068D8 6630                 		BNE	HDOWNR			; was down..go to host-down code
    3136   3203                               	
    3137   3204                               	*	Host is believed up...read key
    3138   3205                               	*	If good, just reset timeout
    3139   3206                               	*	Else if 0, timeout is in effect
    3140   3207                               	*	Else, crash for bad key
    3141   3208 000068DA 7408                 	HUPR	MOVEQ	#8,D2			; try to get key eight times
    3142   3209 000068DC 6100 F186            	HUPR1	BSR	DOKEY			; verify Key usage
    3143   3210 000068E0 671E                 		BEQ	HUPR2			; got match...all is OK
    3144   3211 000068E2 4A81                 		TST.L	D1			; did we read 0?
    3145   3212 000068E4 6600 F0B4            		BNE	BADKEY
    3146   3213 000068E8 4A38 1042            		TST.B	P10DAH			; check high-bits
    3147   3214 000068EC 6600 F0AC            		BNE	BADKEY			; wasn't zero (from last try)
    3148   3215 000068F0 5302                 		SUB.B	#1,D2			; try again?
    3149   3216 000068F2 6CE8                 		BGE	HUPR1			; yes
    3150   3217 000068F4 5378 1052            		SUB.W	#1,TOHOST		; no...decrement current timeout
    3151   3218 000068F8 6C00 0056            		BGE.L	HALFSEX			; not yet
    3152   3219 000068FC 6000 F094            		BRA	NOKEY			; timeout expired...go crash host
    3153   3220                               	
    3154   3221 00006900 31F8 1050 1052       	HUPR2	MOVE.W	HOSTTO,TOHOST		; reset timeout period
    3155   3222 00006906 6000 0048            		BRA.L	HALFSEX			; ...and exit
    3156   3223                               	
    3157   3224                               	*	Host believed down...read key
    3158   3225                               	*	if good, get parameters, begin talking to host
    3159   3226 0000690A 6100 F158            	HDOWNR	BSR	DOKEY			; do the key-stuff
    3160   3227 0000690E 6600 0038            		BNE.L	MNGOOD			; skip if no good
    3161   3228 00006912 5278 10EC            		ADD.W	#1,LASCOU
    3162   3229 00006916 3438 10EC            		MOVE.W	LASCOU,D2
    3163   3230 0000691A 0C42 0004            		CMP.W	#4,D2
    3164   3231 0000691E 6D30                 		BLT	HALFSEX			; wait 2 seconds before believe host
    3165   3232                               	
    3166   3233                               	
    3167   3234                               	*	Host has just come up...read PDP's Ring-parameters
    3168   3235 00006920 6100 ECFA            		BSR	RDPDPRPEBUS02.J01                 E B U S  --  PDP-10 Base Code,		H O S T   S T A T U S          8-Oct-87  Page   73
Err Source Ref. Address   value
    line   line

    3169   3236                               	
    3170   3237 00006924 31FC 0380 10A8       		MOVE.W	#$380+DEBUG,DAT1	; set "RESET INTERFACE"
    3171   3238 0000692A 31FC 0201 10AA       		MOVE.W	#VERSION,DAT3
    3172   3239 00006930 6100 EE6C            		BSR.L	WAITDAT			; and send it
    3173   3240 00006934 6100 EE68            		BSR.L	WAITDAT			;  ...twice...just in case
    3174   3241                               	
    3175   3242 00006938 4238 108B            		CLR.B	HTDWN			; 0 = host is up
    3176   3243 0000693C 31FC 0001 1052       		MOVE.W	#1,TOHOST		; cancel timeouts in progress
    3177   3244 00006942 31FC 0001 1050       		MOVE.W	#1,HOSTTO
    3178   3245                               	
    3179   3246 00006948 4278 10EC            	MNGOOD	CLR.W	LASCOU
    3180   3247 0000694C 6100 F17C            		BSR	EMPTY			; empty ISIS input ring
    3181   3248                               	
    3182   3249                               	HALFSEX	*				; exit to here...
    3183   3250                               	*					 ...and fall through to DOBKOUT



    3185   3252                               		TTL	'E B U S  --  PDP-10 Base Code,		B L O C K   O U T P U T'EBUS02.J01                 E B U S  --  PDP-10 Base Code,		B L O C K   O U T P U T        8-Oct-87  Page   74
Err Source Ref. Address   value
    line   line

    3187   3254                               	*		BLOCK OUTPUT
    3188   3255                               	
    3189   3256                               	*	BLOCK OUTPUT IS BEING DONE HERE
    3190   3257 00006950 4A38 108B            	DOBKOUT	TST.B	HTDWN			; quit if host down
    3191   3258 00006954 6600 F264            		BNE	EXEC
    3192   3259 00006958 3038 1100            		MOVE.W	BKOHEAD,D0		; any Block-output in progress?
    3193   3260 0000695C 6700 0092            		BEQ.L	INBKTIM			; no...just skip
    3194   3261                               	
    3195   3262 00006960 3040                 	BOUT	MOVE.W	D0,A0			; unchain pointer
    3196   3263 00006962 31D8 1104            		MOVE.W	(A0)+,SAVE1		; get NEXT
    3197   3264 00006966 3010                 		MOVE.W	(A0),D0			; fetch port number
    3198   3265 00006968 6100 F0CE            		BSR	SETPORT			; set up port
    3199   3266 0000696C 082C 0002 0001       		BTST	#PF_OBP,P_FLAGS(Rp)	; check output back-pressure
    3200   3267 00006972 6674                 		BNE	BOUTX			; set...don't output this time
    3201   3268 00006974 4241                 		CLR.W	D1			; no back-pressure...set up to transmit
    3202   3269 00006976 122C 0002            		MOVE.B	XMITLMT(Rp),D1		; extract transmit-limit
    3203   3270 0000697A 302C 000A            		MOVE.W	BO_TCN(Rp),D0		; number of characters left
    3204   3271 0000697E B041                 		CMP.W	D1,D0			; more than we can send?
    3205   3272 00006980 6F02                 		BLE	BOUT1			; no
    3206   3273 00006982 3001                 		MOVE.W	D1,D0			; yes...use limit instead
    3207   3274 00006984 3800                 	BOUT1	MOVE.W	D0,D4			; count = message-type
    3208   3275 00006986 5640                 		ADD.W	#3,D0			; ...and this is how much space we'll need
    3209   3276 00006988 6100 E9B6            		BSR	ROOM
    3210   3277 0000698C 665A                 		BNE	BOUTX			; quit if not enough room in ring
    3211   3278 0000698E 3638 10A0            		MOVE.W	PORTNO,D3		; port number
    3212   3279 00006992 6100 E9E4            		BSR	SLOR
    3213   3280 00006996 362C 0008            		MOVE.W	BO_BYT(Rp),D3		; byte position
    3214   3281 0000699A 47F8 10A8            		LEA	DAT,A3			; compute address within DAT
    3215   3282 0000699E D6C3                 		ADD.W	D3,A3
    3216   3283                               	
    3217   3284 000069A0 6100 EC32            	BOUT2	BSR	RDBLK			; get another word of input
    3218   3285 000069A4 101B                 	BOUT3	MOVE.B	(A3)+,D0		; move another byte
    3219   3286 000069A6 5243                 		ADD.W	#1,D3			; advance cursor
    3220   3287 000069A8 536C 000A            		SUB.W	#1,BO_TCN(Rp)		; number of characters left
    3221   3288 000069AC 6100 E9EA            		BSR	PUTCH
    3222   3289 000069B0 5344                 		SUB.W	#1,D4			; done yet?
    3223   3290 000069B2 670E                 		BEQ	BOUT4			; yes...clean up and quit
    3224   3291 000069B4 B6FC 10AC            		CMPA.W	#DAT5,A3		; is word exhausted?
    3225   3292 000069B8 66EA                 		BNE	BOUT3			; not yet
    3226   3293 000069BA 47F8 10A8            		LEA	DAT1,A3			; pointer to initial byte
    3227   3294 000069BE 4243                 		CLR.W	D3			; start at byte 0 again
    3228   3295 000069C0 60DE                 		BRA	BOUT2
    3229   3296                               	
    3230   3297 000069C2 6100 EA32            	BOUT4	BSR	ELOR			; done...send it on it's way
    3231   3298 000069C6 426C 0008            		CLR.W	BO_BYT(Rp)		; assume next byte is byte 0
    3232   3299 000069CA 0C43 0004            		CMP.W	#4,D3			; is current word exhausted?
    3233   3300 000069CE 6C08                 		BGE	BOUT5			; yes
    3234   3301 000069D0 53AC 0004            		SUB.L	#1,BO_TAR(Rp)		; no...back up pointer to read again
    3235   3302 000069D4 3943 0008            		MOVE.W	D3,BO_BYT(Rp)		; save position of next byte
    3236   3303 000069D8 4A6C 000A            	BOUT5	TST.W	BO_TCN(Rp)		; total number left..Done?EBUS02.J01                 E B U S  --  PDP-10 Base Code,		B L O C K   O U T P U T        8-Oct-87  Page   75
Err Source Ref. Address   value
    line   line

    3237   3304 000069DC 660A                 		BNE	BOUTX			; no
    3238   3305 000069DE 11FC 0025 10A8       		MOVE.B	#$25,DAT1		; yes...report Bout done
    3239   3306 000069E4 6100 F844            		BSR	BKOTERM			; terminate block-output
    3240   3307                               	
    3241   3308 000069E8 3038 1104            	BOUTX	MOVE.W	SAVE1,D0		; any more ports?
    3242   3309 000069EC 6600 FF72            		BNE	BOUT			; yes...service another
    3243   3310                               	*	...and fall through to INBKTIM



    3245   3312                               		TTL	'E B U S  --  PDP-10 Base Code,		C O D E'EBUS02.J01                 E B U S  --  PDP-10 Base Code,		C O D E                        8-Oct-87  Page   76
Err Source Ref. Address   value
    line   line

    3247   3314                               	*		CHECK BLOCK INPUT TIMEOUT
    3248   3315                               	
    3249   3316                               	*	Check to see if 16-seconds has elapsed since last Block-in Data
    3250   3317 000069F0 3038 10FE            	INBKTIM	MOVE.W	BKIHEAD,D0		; anything to do?
    3251   3318 000069F4 6760                 		BEQ	FL_BUF			; no...skip to service buffers
    3252   3319 000069F6 3040                 	IBM	MOVE.W	D0,A0			; chain down list
    3253   3320 000069F8 31D8 1104            		MOVE.W	(A0)+,SAVE1		; save NEXT
    3254   3321 000069FC 3010                 		MOVE.W	(A0),D0			; get port-number
    3255   3322 000069FE 6100 F038            		BSR	SETPORT
    3256   3323 00006A02 2078 103A            		MOVE.L	.FASTC,A0
    3257   3324 00006A06 2010                 		MOVE.L	(A0),D0
    3258   3325 00006A08 90AC 000C            		SUB.L	BI_TIM(Rp),D0		; compute time elapsed since last input
    3259   3326 00006A0C 0C80 0000 2580       		CMP.L	#9600,D0		; has it exceeded 16 seconds?
    3260   3327 00006A12 6D12                 		BLT	IBK1			; no
    3261   3328 00006A14 082C 0007 0001       		BTST	#PF_BFD,P_FLAGS(Rp)	; set Block FilleD
    3262   3329 00006A1A 660A                 		BNE	IBK1			; already was set
    3263   3330 00006A1C 11FC 0029 10A8       		MOVE.B	#$29,DAT1		; not set previously...
    3264   3331 00006A22 6100 F83A            		BSR	BKITERM			; terminate Block-input
    3265   3332                               	
    3266   3333 00006A26 3038 1104            	IBK1	MOVE.W	SAVE1,D0
    3267   3334 00006A2A 66CA                 		BNE	IBM
    3268   3335                               	
    3269   3336                               	
    3270   3337                               	*	Routine to put data from buffer to Host block
    3271   3338 00006A2C 3038 10FE            		MOVE.W	BKIHEAD,D0		; check block-input head
    3272   3339 00006A30 6724                 		BEQ	FL_BUF			; nothing to do here
    3273   3340 00006A32 3040                 	BBLNK	MOVE.W	D0,A0			; address of next entry
    3274   3341 00006A34 31D8 1104            		MOVE.W	(A0)+,SAVE1		; save NEXT of this block
    3275   3342 00006A38 3010                 		MOVE.W	(A0),D0			; port number
    3276   3343 00006A3A 6100 EFFC            		BSR	SETPORT			; set up port
    3277   3344 00006A3E 082C 0007 0001       		BTST	#PF_BFD,P_FLAGS(Rp)	; was Block FilleD?
    3278   3345 00006A44 660A                 		BNE	MAD20			; yes
    3279   3346 00006A46 4A6C 001E            		TST.W	BCT(Rp)			; no...any of chars in buffer?
    3280   3347 00006A4A 6704                 		BEQ	MAD20			; no
    3281   3348 00006A4C 6100 0112            		BSR.L	BU_BK			; yes...proceed to move to block
    3282   3349                               	
    3283   3350 00006A50 3038 1104            	MAD20	MOVE.W	SAVE1,D0		; done...is list exhausted?
    3284   3351 00006A54 66DC                 		BNE	BBLNK			; no...do another
    3285   3352                               	*					  ...then fall through to next test
    3286   3353                               	
    3287   3354                               	*	Try to flush buffers to PDP's input-ring
    3288   3355 00006A56 3038 1102            	FL_BUF	MOVE.W	BUFHEAD,D0		; anything to do?
    3289   3356 00006A5A 6700 F15E            		BEQ	EXEC			; no...back to beginning of EXEC loop
    3290   3357 00006A5E 3040                 	FL_BUF1	MOVE.W	D0,A0			; chain down list
    3291   3358 00006A60 31D8 1104            		MOVE.W	(A0)+,SAVE1		; save NEXT
    3292   3359 00006A64 3010                 		MOVE.W	(A0),D0			; get port-number
    3293   3360 00006A66 6100 EFD0            		BSR	SETPORT
    3294   3361 00006A6A 6114                 		BSR	BU_RG			; try to flush some stuff
    3295   3362 00006A6C 4A6C 001E            		TST.W	BCT(Rp)			; is buffer now empty?
    3296   3363 00006A70 6604                 		BNE	FL_BUF2			; noEBUS02.J01                 E B U S  --  PDP-10 Base Code,		C O D E                        8-Oct-87  Page   77
Err Source Ref. Address   value
    line   line

    3297   3364 00006A72 6100 F74E            		BSR	RBTBUF			; yes...remove buffer from list
    3298   3365                               	
    3299   3366 00006A76 3038 1104            	FL_BUF2	MOVE.W	SAVE1,D0		; any more in list?
    3300   3367 00006A7A 66E2                 		BNE	FL_BUF1			; proceed if more to do
    3301   3368 00006A7C 6000 F13C            		BRA	EXEC			; done...back to start of EXEC loop
    3302   3369                               	
    3303   3370                               	
    3304   3371                               	*	Copy data from BUffer to PDP's input RinG for this port
    3305   3372 00006A80 4A6C 001E            	BU_RG	TST.W	BCT(Rp)			; anything in buffer?
    3306   3373 00006A84 6700 00AC            		BEQ.L	BU_EMP			; no, empty...quit
    3307   3374 00006A88 082C 0004 0001       		BTST	#PF_HBP,P_FLAGS(Rp)	; has PDP applied back-pressure?
    3308   3375 00006A8E 6600 00B6            		BNE.L	BU_XIT			; yes...quit this time around
    3309   3376 00006A92 31FC 001E 109E       		MOVE.W	#30,INTYBT		; no...pretend we're doing data
    3310   3377 00006A98 6100 ED6C            		BSR	FDRGSZ			; find space available
    3311   3378 00006A9C 5578 109C            		SUB.W	#2,INRGSP		; allow for header
    3312   3379 00006AA0 6F00 00A4            		BLE.L	BU_XIT			; ...but quit if no room
    3313   3380 00006AA4 0C78 001E 109C       		CMP.W	#30,INRGSP
    3314   3381 00006AAA 6F06                 		BLE	BU_RG1
    3315   3382 00006AAC 31FC 001E 109C       		MOVE.W	#30,INRGSP		; don't send more than 30 bytes of data
    3316   3383 00006AB2 11F8 10A1 10A9       	BU_RG1	MOVE.B	PORTNO+1,DAT2
    3317   3384 00006AB8 4243                 		CLR.W	D3			; clear data-counter
    3318   3385 00006ABA 4278 109E            		CLR.W	INTYBT			; used to record escaped chars
    3319   3386 00006ABE 47F8 10AA            		LEA	DAT3,A3			; place to (begin to) put data
    3320   3387 00006AC2 4A6C 001E            	BU_RG2	TST.W	BCT(Rp)			; anything left?
    3321   3388 00006AC6 672C                 		BEQ	BU_RG4			; skip if no more
    3322   3389 00006AC8 6100 ED8C            		BSR	DGCI			; else get the data
    3323   3390 00006ACC 0C00 001B            		CMP.B	#ESC,D0			; see if escape
    3324   3391 00006AD0 6618                 		BNE	BU_RG3			; skip if data
    3325   3392 00006AD2 4A6C 001E            		TST.W	BCT(Rp)			; still data left?
    3326   3393 00006AD6 6700 E716            		BEQ	BAD_ESC			; crash if none
    3327   3394 00006ADA 6100 ED7A            		BSR	DGCI			; else get it
    3328   3395 00006ADE 0C00 001B            		CMP.B	#ESC,D0			; see if escaped data
    3329   3396 00006AE2 6706                 		BEQ	BU_RG3			; skip if so
    3330   3397 00006AE4 31C0 109E            		MOVE.W	D0,INTYBT		; else record it
    3331   3398 00006AE8 600A                 		BRA	BU_RG4			; and skip
    3332   3399                               	
    3333   3400 00006AEA 16C0                 	BU_RG3	MOVE.B	D0,(A3)+		; save in temp area
    3334   3401 00006AEC 5243                 		ADD.W	#1,D3			; increment data-counter
    3335   3402 00006AEE B678 109C            		CMP.W	INRGSP,D3		; see if that's all that fits
    3336   3403 00006AF2 66CE                 		BNE	BU_RG2			; continue if not
    3337   3404                               	
    3338   3405 00006AF4 11C3 10A8            	BU_RG4	MOVE.B	D3,DAT1			; save data-count
    3339   3406 00006AF8 671A                 		BEQ	BU_COD			; skip if no data found
    3340   3407 00006AFA 0038 0080 10A8       		OR.B	#$80,DAT1		; make host data-MSG type
    3341   3408 00006B00 5443                 		ADD.W	#2,D3
    3342   3409 00006B02 47F8 10A8            		LEA	DAT,A3
    3343   3410 00006B06 221B                 	BU_RG5	MOVE.L	(A3)+,D1		; move data to host-ring
    3344   3411 00006B08 6100 EC9A            		BSR	WRPDP			; send it (no need to wait)
    3345   3412 00006B0C 5943                 		SUB.W	#4,D3
    3346   3413 00006B0E 6EF6                 		BGT	BU_RG5			; send it all
    3347   3414 00006B10 6100 ECC6            		BSR	PUTIFC			; make sure host sees itEBUS02.J01                 E B U S  --  PDP-10 Base Code,		C O D E                        8-Oct-87  Page   78
Err Source Ref. Address   value
    line   line

    3348   3415                               	
    3349   3416 00006B14 4A78 109E            	BU_COD	TST.W	INTYBT			; see if terminated by escaped char
    3350   3417 00006B18 6712                 		BEQ	BU_RGX			; we're done if not
    3351   3418 00006B1A 6100 FBA4            		BSR	LOOKUP			; else go translate it
    3352   3419 00006B1E 11F8 10A1 10A9       		MOVE.B	PORTNO+1,DAT2		; install port #
    3353   3420 00006B24 6100 EC78            		BSR	WAITDAT			; wait, then write DAT into host
    3354   3421 00006B28 6100 ECAE            		BSR	PUTIFC			; make sure host sees it
    3355   3422                               	
    3356   3423 00006B2C 4A6C 001E            	BU_RGX	TST.W	BCT(Rp)			; is buffer now empty?
    3357   3424 00006B30 6614                 		BNE	BU_XIT			; no
    3358   3425                               	
    3359   3426 00006B32 08AC 0003 0001       	BU_EMP	BCLR	#PF_IBP,P_FLAGS(Rp)	; clear back-pressure
    3360   3427 00006B38 670C                 		BEQ	BU_XIT			; wasn't set
    3361   3428 00006B3A 3638 10A0            		MOVE.W	PORTNO,D3		; was set, must clear...for port,
    3362   3429 00006B3E 183C 00A1            		MOVE.B	#$A1,D4			; release back-pressure
    3363   3430 00006B42 6100 E8AC            		BSR	SENDQI			; send Quick ISIS message
    3364   3431                               	
    3365   3432 00006B46 4E75                 	BU_XIT	RTS				; return
    3366   3433                               	
    3367   3434                               	
    3368   3435                               	*	Put the current port onto the buffer-list
    3369   3436 00006B48 3078 10FC            	BU_ADD	MOVE.W	BLKFREE,A0		; get an entry off free-list
    3370   3437 00006B4C 31D0 10FC            		MOVE.W	(A0),BLKFREE		; unlink from free-list
    3371   3438 00006B50 30B8 1102            		MOVE.W	BUFHEAD,(A0)		; link list-head to element
    3372   3439 00006B54 3178 10A0 0002       		MOVE.W	PORTNO,2(A0)		; second word is port-number
    3373   3440 00006B5A 31C8 1102            		MOVE.W	A0,BUFHEAD		; place this element as new list-head
    3374   3441 00006B5E 4E75                 		RTS				; done...return
    3375   3442                               	
    3376   3443                               	
    3377   3444                               	*	Copy from Buffer to Block:  If terminated by Block-full
    3378   3445                               	*	or Yellow-Ball (EOT), then report termination;  if by EOT, then
    3379   3446                               	*	report Yellow-ball also.
    3380   3447 00006B60 382C 0014            	BU_BK	MOVE.W	BI_TCN(Rp),D4		; copy of # of chars expected
    3381   3448 00006B64 6100 EC18            		BSR	GETBLK			; get the current word
    3382   3449 00006B68 366C 0018            		MOVE.W	BI_BYT(Rp),A3		; cursor within DAT
    3383   3450 00006B6C 47EB 10A8            		LEA	DAT(A3),A3		; address of current byte
    3384   3451 00006B70 4278 109E            		CLR.W	INTYBT			; used to record control-codes
    3385   3452                               	
    3386   3453                               	*	Copy until buffer-empty, block-full, or found control-code
    3387   3454 00006B74 4A6C 001E            	BU_BK1	TST.W	BCT(Rp)			; anything there?
    3388   3455 00006B78 673E                 		BEQ	BU_BK3			; no, buffer empty...skip
    3389   3456 00006B7A B86C 0016            		CMP.W	BI_LCN(Rp),D4		; block full?
    3390   3457 00006B7E 6738                 		BEQ	BU_BK3			; no...skip
    3391   3458 00006B80 6100 ECD4            		BSR	DGCI			; get the char
    3392   3459 00006B84 0C00 001B            		CMP.B	#ESC,D0			; ESC?
    3393   3460 00006B88 6618                 		BNE	BU_BK2			; no..skip to place the data
    3394   3461 00006B8A 4A6C 001E            		TST.W	BCT(Rp)			; yes...anything else there?
    3395   3462 00006B8E 6700 E65E            		BEQ	BAD_ESC			; no, buffer now empty...fatal error
    3396   3463 00006B92 6100 ECC2            		BSR	DGCI			; get the code
    3397   3464 00006B96 0C00 001B            		CMP.B	#ESC,D0			; ESC?
    3398   3465 00006B9A 6706                 		BEQ	BU_BK2			; yes, data...skip to place it in blockEBUS02.J01                 E B U S  --  PDP-10 Base Code,		C O D E                        8-Oct-87  Page   79
Err Source Ref. Address   value
    line   line

    3399   3466 00006B9C 31C0 109E            		MOVE.W	D0,INTYBT		; no...save as termination-code
    3400   3467 00006BA0 6016                 		BRA	BU_BK3			; and skip to terminate copy
    3401   3468                               	
    3402   3469 00006BA2 16C0                 	BU_BK2	MOVE.B	D0,(A3)+		; save data char
    3403   3470 00006BA4 526C 0016            		ADD.W	#1,BI_LCN(Rp)		; count it
    3404   3471 00006BA8 B6FC 10AC            		CMPA.W	#DAT5,A3		; have we exhausted DAT?
    3405   3472 00006BAC 6DC6                 		BLT	BU_BK1			; no
    3406   3473 00006BAE 6100 EBA6            		BSR	WRBLK			; yes
    3407   3474 00006BB2 47F8 10A8            		LEA	DAT,A3			; reset word cursor
    3408   3475 00006BB6 60BC                 		BRA	BU_BK1
    3409   3476                               	
    3410   3477                               	*	done with copy (for this pass)
    3411   3478 00006BB8 96FC 10A8            	BU_BK3	SUB.W	#DAT,A3			; compute displacement
    3412   3479 00006BBC 394B 0018            		MOVE.W	A3,BI_BYT(Rp)		; save it for next time
    3413   3480 00006BC0 6708                 		BEQ	BU_BK4			; at beginning of word?
    3414   3481 00006BC2 6100 EB92            		BSR	WRBLK			; no...write partial word into PDP
    3415   3482 00006BC6 53AC 0010            		SUB.L	#1,BI_TAR(Rp)		; back up word-cursor
    3416   3483 00006BCA 11FC 0027 10A8       	BU_BK4	MOVE.B	#$27,DAT1		; assume terminated by FULL
    3417   3484 00006BD0 B86C 0016            		CMP.W	BI_LCN(Rp),D4
    3418   3485 00006BD4 6724                 		BEQ	BU_BK5			; skip if that's reason
    3419   3486 00006BD6 5238 10A8            		ADD.B	#1,DAT1			; no...assume terminated by EOT
    3420   3487 00006BDA 0C78 00AC 109E       		CMP.W	#YB_CODE,INTYBT		; see if Yellow-ball found
    3421   3488 00006BE0 6718                 		BEQ	BU_BK5			; skip if so
    3422   3489 00006BE2 2478 103A            		MOVE.L	.FASTC,A2		; else record current time
    3423   3490 00006BE6 2952 000C            		MOVE.L	(A2),BI_TIM(Rp)
    3424   3491 00006BEA 4A78 109E            		TST.W	INTYBT			; terminated by stream-code?
    3425   3492 00006BEE 6700 FF3C            		BEQ	BU_RGX			; no...just exit (but check for BP)
    3426   3493 00006BF2 6100 FF20            		BSR	BU_COD			; yes...send it to host
    3427   3494 00006BF6 6000 FF68            		BRA	BU_BK			; then continue copying
    3428   3495                               	
    3429   3496                               	*	Block-input terminated
    3430   3497 00006BFA 6100 F662            	BU_BK5	BSR	BKITERM			; terminate block-input
    3431   3498 00006BFE 6000 FF14            		BRA	BU_COD			; send code if encountered, and exitEBUS02.J01                 E B U S  --  PDP-10 Base Code,		C O D E                        8-Oct-87  Page   80
Err Source Ref. Address   value
    line   line

    3433   3500                               	
    3434   3501                               	
    3435   3502                               	
    3436   3503                               		ORG	$7C00
    3437   3504                               	
    3438   3505                               	*	D0 is the high order 32 bits to write to pdp-10
    3439   3506                               	*	D1 last 4 bits are the low order 4 bits to write to 10
    3440   3507                               	*	D2 is the start addr of the test
    3441   3508                               	*	D3 is the ending addr of the test
    3442   3509                               	*	D4 is the counter of mismatch between read and write
    3443   3510                               	*	D5 is the high order 32 bits read from 10's memory
    3444   3511                               	*	D6 last 4 bits are the low order 4 bits read from 10
    3445   3512                               	
    3446   3513 00007C00 4A79 00D0 1038       	STARTES	TST.W	DEXCO			; Reset EBUS
    3447   3514 00007C06 4238 10DE            		CLR.B	BLK
    3448   3515 00007C0A 4284                 		CLR.L	D4			; Initialize the mismatch counter
    3449   3516 00007C0C                      	STATE12	PUSHM	D0-D4
    3450   3518 00007C10 31C2 1048            		MOVE.W	D2,P10ADR		; move in addr(only half-word long)
    3451   3519 00007C14 21C0 1042            		MOVE.L	D0,P10DAH		; first 32 bits of data
    3452   3520 00007C18 0201 000F            		AND.B	#$0F,D1			; only need last 4 bits
    3453   3521 00007C1C 11C1 1046            		MOVE.B	D1,P10DLL		; last 4 bits of data
    3454   3522 00007C20 6100 DA6A            		BSR	WR10R			; write it to 10. memory
    3455   3523 00007C24 42B8 1042            		CLR.L	P10DAH			; clear out read area
    3456   3524 00007C28 4238 1046            		CLR.B	P10DLL
    3457   3525 00007C2C 6100 D896            		BSR	RD10R			; read it back from 10's memory
    3458   3526 00007C30                      		POPM	D0-D4
    3459   3528 00007C34 4285                 		CLR.L	D5
    3460   3529 00007C36 4286                 		CLR.L	D6
    3461   3530 00007C38 2A38 1042            		MOVE.L	P10DAH,D5		; first 32 bits read rom 10
    3462   3531 00007C3C 1C38 1046            		MOVE.B	P10DLL,D6
    3463   3532 00007C40 0201 000F            		AND.B	#$0F,D1
    3464   3533 00007C44 B085                 		CMP.L	D5,D0
    3465   3534 00007C46 6608                 		BNE	SUB7			; go mismatch routine
    3466   3535 00007C48 B206                 		CMP.B	D6,D1
    3467   3536 00007C4A 6604                 		BNE	SUB7			; go mismatch routine if not =
    3468   3537 00007C4C 4287                 		CLR.L	D7			; no mismatch add 0 to counter(d4)
    3469   3538 00007C4E 6002                 		BRA	NO77
    3470   3539                               	
    3471   3540 00007C50 7E01                 	SUB7	MOVE.L	#1,D7			; add 1 to counter D4 on mismatch
    3472   3541 00007C52 D887                 	NO77	ADD.L	D7,D4			; add to mismatch counter
    3473   3542 00007C54 5242                 		ADD.W	#1,D2			; bump to next addr in 10 memory
    3474   3543 00007C56 B682                 		CMP.L	D2,D3			; if biggert than end addr
    3475   3544 00007C58 6CB2                 		BGE	STATE12			; no go another loop
    3476   3545 00007C5A 2249                 	NOMLOP	MOVE.L	A1,A1
    3477   3546 00007C5C 60FC                 		BRA	NOMLOP			; just dummy loopEBUS02.J01                 E B U S  --  PDP-10 Base Code,		C O D E                        8-Oct-87  Page   81
Err Source Ref. Address   value
    line   line

    3479   3548                               	*	Special diagnostics for manual operation and testing
    3480   3549                               	
    3481   3550                               	
    3482   3551                               	
    3483   3552                               	
    3484   3553                               		ORG	$7D00
    3485   3554 00007D00 31C2 1048            	CONWRT	MOVE.W	D2,P10ADR
    3486   3555 00007D04 11FC 0001 1108       		MOVE.B	#1,DIAG			; set DIAG > 0
    3487   3556 00007D0A 21C0 1042            		MOVE.L	D0,P10DAH
    3488   3557 00007D0E 0201 000F            		AND.B	#$0F,D1
    3489   3558 00007D12 11C1 1046            		MOVE.B	D1,P10DLL
    3490   3559 00007D16 4A79 00D0 1038       	WRTERR	TST.W	DEXCO			; Reset EBUS
    3491   3560 00007D1C 6100 D96E            		BSR	WR10R
    3492   3561 00007D20 3A3C 0064            		MOVE.W	#100,D5
    3493   3562 00007D24 5345                 	WRERL	SUB.W	#1,D5
    3494   3563 00007D26 66FC                 		BNE	WRERL
    3495   3564 00007D28 60EC                 		BRA	WRTERR
    3496   3565                               	
    3497   3566                               	
    3498   3567                               	
    3499   3568                               	
    3500   3569                               	
    3501   3570                               		ORG	$7E00
    3502   3571 00007E00 11FC 00FF 1108       		MOVE.B	#-1,DIAG		; set DIAG < 0
    3503   3572 00007E06 31C2 1048            		MOVE.W	D2,P10ADR
    3504   3573 00007E0A 4A79 00D0 1038       	REDERR	TST.W	DEXCO			; Reset EBUS
    3505   3574 00007E10 6100 D6B2            		BSR	RD10R
    3506   3575 00007E14 3A3C 0064            		MOVE.W	#100,D5
    3507   3576 00007E18 5345                 	RELOP	SUB.W	#1,D5
    3508   3577 00007E1A 66FC                 		BNE	RELOP
    3509   3578 00007E1C 60EC                 		BRA	REDERR
    3510   3579                               	
    3511   3580                               	
    3512   3581                               	*	Return here on diagnostic error
    3513   3582 00007E1E 4A38 1108            	DIAGERR	TST.B	DIAG			; which diagnostic are we doing?
    3514   3583 00007E22 6DE6                 		BLT	REDERR			; < 0...read diagnostic
    3515   3584 00007E24 6000 FEF0            		BRA	WRTERR			; > 0...write diagnostic
    3516   3585                               	
    3517   3586                               	
    3518   3587                               		TTL	'E B U S  --  PDP-10 Base Code'
    3519   3588 00007E28                      		END	ENTRYEBUS02.J01                 E B U S  --  PDP-10 Base Code                                  8-Oct-87  Page   82

                               Symbol Table

ADRERR     00005216  AUXC       00001062  AUXERR     00006874  AUXKEY     00000003  AUXQ       0000105A
AUXTIM     0000105C  AUXX       00001060  BADKEY     0000599A  BAD_ESC    000051EE  BB         0000001A
BBLNK      00006A32  BCRASH     000051A2  BCRASH1    000051B8  BCRASH2    000051C2  BCT        0000001E
BE         0000001C  BFLSIZ     00000010  BI_BYT     00000018  BI_LCN     00000016  BI_TAR     00000010
BI_TCN     00000014  BI_TIM     0000000C  BKIHEAD    000010FE  BKITERM    0000625E  BKOHEAD    00001100
BKOTERM    0000622A  BKPR       000010EE  BLACK      00006680  BLK        000010DE  BLKFREE    000010FC
BLKK1      000056C2  BLKK2      000054E4  BLKMAP     000050EC  BLOKIN     00006398  BOBCODE    00004F2E
BOK1       00006140  BOK2       000061C8  BOK22      000061E8  BOK3       0000621E  BOK4       0000623E
BOK5       0000627E  BOUT       00006960  BOUT1      00006984  BOUT2      000069A0  BOUT3      000069A4
BOUT4      000069C2  BOUT5      000069D8  BOUTX      000069E8  BO_BYT     00000008  BO_TAR     00000004
BO_TCN     0000000A  BPOFF      00006660  BPON       00006658  BTRACE     00000000  BUFER      00008000
BUFEREND   0000F000  BUFHEAD    00001102  BUSCRAS    000059C0  BUSERR     00005206  BU_ADD     00006B48
BU_BK      00006B60  BU_BK1     00006B74  BU_BK2     00006BA2  BU_BK3     00006BB8  BU_BK4     00006BCA
BU_BK5     00006BFA  BU_COD     00006B14  BU_EMP     00006B32  BU_RG      00006A80  BU_RG1     00006AB2
BU_RG2     00006AC2  BU_RG3     00006AEA  BU_RG4     00006AF4  BU_RG5     00006B06  BU_RGX     00006B2C
BU_XIT     00006B46  C1         0000598E  CARRTS     00005850  CARWRAP    00005822  CASHW      0000100C
CCTBD      0000390A  CLEANUP    000062A4  CODCASH    00001004  CONWRT     00007D00  CTRACE     00000000
DAT        000010A8  DAT1       000010A8  DAT2       000010A9  DAT3       000010AA  DAT4       000010AB
DAT5       000010AC  DEBUG      00000000  DEMPTY     00005962  DEXC1      00D010B8  DEXCO      00D01038
DGCI       00005856  DGCI1      0000588C  DGCI2      0000588E  DGCIH      000051F6  DIAG       00001108
DIAGERR    00007E1E  DOBKOUT    00006950  DOKEY      00005A64  DOKEYX     00005A86  DPEEK      000058A2
DPEEK1     000058D2  DPEEK2     000058D6  DPEEKX     000058E2  DPER       00D00138  DPORT      00005B76
DPORT1     00005B88  DSENS      00D000B8  DTMOT      00D001B8  DWCI       000058E4  DWCI2      0000590A
DWCI3      00005916  DWCI4      0000592E  DWCI5      0000593C  DWCIH      000051FE  ECHOFF     00005FF0
ECHOON     00005FE8  ELIR       000054AE  ELIR2      000054BE  ELOR       000053F6  ELOR21     00005404
EMP1       00005AD2  EMP2       00005AFA  EMP3       00005B08  EMP4       00005B0C  EMP5       00005B12
EMP6       00005B20  EMPTY      00005ACA  ENDMEM     0003FFE0  ENDZERO    0000390A  ENGINE     FFFFF901
ENGVECT    0000013C  ENTRY      00004F00  ENTRY1     00004F0E  ENTRY2     00004F1A  ESC        0000001B
ESPACE     00E00000  ETRACE     0003FFE0  EVENBON    0000545A  EXEC       00005BBA  EXEC1      00005BCC
EXEC2      00005BD6  EXEC3      00005BDA  EXEC4      00005BE2  FDRGSZ     00005806  FFCRA      00004F64
FLUSH      000054A4  FL_BUF     00006A56  FL_BUF1    00006A5E  FL_BUF2    00006A76  FREEBLK    0000110A
GEHTLN     00005CD2  GETBLK     0000577E  GETCH      0000544A  GETCH1     00005472  GETH       00005474
GETH1      0000548A  GETIEC     000055FC  GETIOWA    00004F8E  GETOFC     0000560C  GETPDPL    00005570
GETPDPR    00005582  GETUN      00006482  GETW       0000548C  GETW1      000054A2  GOBBLER    00006668
GRAY       0000667A  HALFSEC    000068BC  HALFSEX    00006950  HCRASH     000056F4  HDN1       00005A0A
HDN2       00005A1C  HDN3       00005A2E  HDN4       00005A36  HDNMSG     00006598  HDOWN      000059F4
HDOWNR     0000690A  HODOWN     000059EE  HOSTN      0000104A  HOSTOUT    00005C06  HOSTP      0000104C
HOSTTO     00001050  HOUT1      00005C6A  HOUT2      00005C7A  HOUT3      00005C88  HOUTX      00005C8C
HREPRT     00005A88  HREPRTX    00005AC8  HSHMSG     000065A6  HST1       00005DC2  HST2       00005DCA
HSTAT      0000104E  HSTSAD     00005FB0  HSTUNA     000068A2  HTDWN      0000108B  HTM        000010E4
HUPR       000068DA  HUPR1      000068DC  HUPR2      00006900  HVERNO     00001054  IBK1       00006A26
IBM        000069F6  IBRATE     00000003  ILLINS     0000520E  ILOG       0000677C  IMESS      000065B4
IMSSZ      00005B2C  IMSTAB     000065FE  INBKTIM    000069F0  INISLN     00006804  INIT0      0000500C
INIT1      00005086  INIT2      000050A2  INITIAL    00005000  INRGSP     0000109C  INTRPT     00004F56
INTYBT     0000109E  IPORT      00005B5E  IPORT1     00005B6C  IPORT2     00005B6E  IPTIME     0000684C
IPZ        000067E8  IPZSZ      00005B50  IPZTAB     00006816  IRING      00001032  IRRN       000010F0
IRSIZE     0000103E  ISISIN     000062A8  ISISIN1    0000630E  ISISIN2    00006314  ISISIN3    00006328
ISISIN4    0000633A  ISMGER     000051DA  ISP        000066BA  ISPTAB     000066D2  ISTOME     00001012
IS_BK      000063A0  IS_BK1     000063B0  IS_BK2     000063DA  IS_BK3     000063EC  IS_BK4     000063FE
IS_BU      0000635A  IS_BU1     0000637C  IS_BU2     0000638E  IS_BUF     00006350  ITERM      000066E2
ITRACE     00000001  LASCOU     000010EC  LFASTC     000010E8  LNKEND     000061B2  LNKLOP     00006196
LOGFAL     00006750  LOGFAL1    00006758  LOOK       00005426  LOOKUP     000066C0  MAD20      00006A50EBUS02.J01                 E B U S  --  PDP-10 Base Code                                  8-Oct-87  Page   83

MAXPORT    00000100  MEMDMP     00005186  MEMDMP1    00005196  MERROR     000059A2  METOIS     00001016
METOSL     0000101E  MNGOOD     00006948  MXPORT     00001056  NARG       00000000  NBFLTS     000010F8
NCCT       000010DC  NEE1       00006536  NEE2       00006560  NEE3       00006566  NEE4       0000657A
NEEDLE     00006414  NEEDLE1    000064AE  NO77       00007C52  NOCAL      00005CE0  NOCAL5     00005CE4
NODALN     00005842  NOIRING    00005448  NOJAP      000066F4  NOJAP1     00006042  NOJAP2     000060C4
NOKEY      00005992  NOMLOP     00007C5A  NORHOST    000010A4  NORNODE    000010A2  NORPORT    000010A6
NPORTS     00001058  NSIZ       000010DD  ODDBON     00005460  OFFBP      00005E22  OMTAB      00005D36
ONBP       00005E0C  OOPMSG     00006582  OPEN       00005D9E  OPSHT      00005DA4  ORING      0000102E
ORRN       000010F2  ORSIZE     00001040  OTFRHST    00005D20  P10ADR     00001048  P10DAH     00001042
P10DAL     00001044  P10DLL     00001046  PARERR     000059B8  PATCHR     00004000  PCCASH     00001008
PDPIEC     00001098  PDPIFC     0000109A  PDPIRP     00001094  PDPISZ     00001096  PDPOEC     00001092
PDPOFC     00001090  PDPORP     0000108C  PDPOSZ     0000108E  PD_SIZ     00000020  PFULL      00001107
PFULL1     00006732  PF_ACT     00000000  PF_BFD     00000007  PF_BKI     00000006  PF_BKO     00000005
PF_HBP     00000004  PF_IBP     00000003  PF_ILI     00000001  PF_OBP     00000002  PNEDL      00006704
PORTNO     000010A0  PORTS      0000190A  PRODID     00000091  PTAL2      00006096  PTALL      00006094
PTERM      0000606A  PTMSN1     000060CE  PTMSND     000060A4  PUEVEN     000053B2  PUTC1      000053C2
PUTCH      00005398  PUTH       000053C8  PUTH11     000053DA  PUTIFC     000057D8  PUTNOT0    000056E0
PUTODD     000053B8  PUTOEC     000057EA  PUTPDPL    00005726  PUTPDPR    0000573E  PUTPN      0000629A
PUTPORT    00005104  PUTUN      0000651C  PUTUN1     00006526  PUTW       000053DC  PUTW11     000053EE
P_FLAGS    00000001  P_NUM      00000000  RBTALL     00005A48  RBTBKI     000061B4  RBTBKO     00006188
RBTBUF     000061C2  RD101      00D0403A  RD102      00D0403E  RD103      00D04038  RD104      00D0403C
RD10AG     000054CA  RD10R      000054C4  RD10R1     000054CC  RD10R2     000054FA  RDBLK      000055D4
RDPDP      000055A0  RDPDP1     000055CA  RDPDPRP    0000561C  RDSNB      00005534  RDSNB1     0000554E
REDERR     00007E0A  REGDMP     0000514E  REGDMPX    00005184  RELOP      00007E18  RESET      00005DE0
RESETAK    00005E02  RNOWRAP    0000534E  ROOM       00005340  ROOMB      00005358  ROOMG      00005356
RTRACE     00000001  R_TANK     000010FA  SAVE1      00001104  SCLKR      0000613C  SEND17     00005EF8
SENDDAT    000062A0  SENDQI     000053F0  SENDTEXT   00005408  SETBLKA    00005676  SETPORT    00005A38
SHNUM      000060EC  SHNUM1     00006104  SHNUM2     00006106  SHNUM3     00006120  SHNUM4     00006124
SHUT       00005DA2  SLOR       00005378  SLOWC      000010E0  SLTOME     0000101A  SMTLMT     000067D4
SNDTXT1    0000541A  SNTO       0000628A  SPEC       00005E5A  SPEC1      00005E64  SPTAB      00005E7A
STARTES    00007C00  STATE12    00007C0C  STERM      00005FF6  STERM1     00005FFE  STERM2     0000602A
STERM3     0000605E  STKTOP     00001000  STRACE     00020000  STREAM     000066A2  STREAM1    000066A8
SUB7       00007C50  SUPLOG     00005F0E  SUPLOP     00005F80  SUPOUT     00005F46  SUPR1      00005ED6
SUPREC     00005EB4  SUPTAK     00006838  TEXTEND    00005CC0  TEXTLOP    00005CA6  TEXTMSG    00005C90
TIMCHK     00005DB0  TMOC       00001106  TMOUT      0000553C  TMOUT1     000059B0  TOHOST     00001052
TP         00005F92  TRACE0     0000521E  TRACE1     00005220  TRACE2     0000522C  TRACE3     00005240
TRACE4     00005244  TRACING    00000001  TRHSTLN    00005CE6  TRISLN     000065DA  TR_IIC     000052BC
TR_IIF     00005304  TR_IIH     000052D6  TR_IIL     000052A4  TR_IIW     000052EE  TR_IOC     0000524A
TR_IOH     00005262  TR_IOS     0000528C  TR_IOW     00005278  TR_PORT    00001010  TR_RIN     00005318
TR_ROUT    0000532C  TSLOWC     00005DD6  TYPBYT     0000108A  UNLINK     00006194  VCRASH     000059CE
VECTOR     00004E00  VERIFY     000068B2  VERSION    00000201  WAIT       0000536E  WAITDAT    0000579E
WAITIS     00005366  WAITISW    0000535E  WAITPDP    000057FC  WR10R      0000568C  WR10R1     0000568E
WRBLK      00005756  WRDAT      000057A0  WRE        00005954  WREH       000059C8  WRERL      00007D24
WRINRG     000057C6  WRIRTS     000057CE  WRPDP      000057A4  WRSNB      000056D8  WRTERR     00007D16
WT101      00D0803A  WT102      00D0803C  WT103      00D0803E  WT104      00D08038  XMITLMT    00000002
YB_CODE    000000AC  YELLOW     00006688  ZAP        00005E40  ZAPPER     00006646  ZERO       0000104A
.BFLTS     000010F4  .FASTC     0000103A  .MDSIZ     00001026  .MDUMP     00001022  .SLOWC     00001036
.SYNC      0000102A  .TRACE     00001000    $fU