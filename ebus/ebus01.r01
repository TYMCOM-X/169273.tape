*************************************************************************
*		   Ebus PDP-10 Base code, Version 1.01			*
*************************************************************************
**                      PROPRIETARY INFORMATION                        **
**                                                                     **
**      This  source code listing constitutes the proprietary pro-     **
**      perty of TYMNET, Incorporated. The recipient, by receiving     **
**      this program listing, agrees that neither this listing nor     **
**      the   information  disclosed herein nor any  part  thereof     **
**      shall be  reproduced or transferred to other documents  or     **
**      used  or  disclosed to others for manufacturing or for any     **
**      other   purpose except as specifically authorized in  wri-     **
**      ting by  TYMNET, Incorporated.                                 **
*************************************************************************

VERSION	EQU	$101		;VERSION NUMBER

        SECT    EBSTART
PERMSGA	EQU	$900
IOWADDR	EQU	$908	
	MOVE.L	#BOBCODE,$13C
	MOVE.L	A1,$900
	MOVE.L	A2,$904
	MOVE.L	#2,(A2)
	MOVEM.L (A7)+,D0-D7/A0-A6
	MOVE.B	#$0C0,$FFF901
	MOVE.B	#$0C1,$FFF901
	STOP	#$2000
BOBCODE	MOVE	#$2700,SR
	MOVEM.L	D0-D7/A0-A6,-(A7)
	MOVEA.L	PERMSGA,A0
	MOVE.L	(A0),D0
	ANDI.L	#$0F000000,D0
	CMPI.L	#$04000000,D0
	BEQ	GETIOWA
	CMPI.L	#$05000000,D0
	BNE.S	FFCRA
	MOVEM.L	(A7)+,D0-D7/A0-A6
	MOVE	#$2000,SR
WAIT0	RTE
FFCRA   CMPI.L  #$03000000,D0
	BNE	BCRASH
	MOVE.B	#$EC,CODCASH
	BSR	ECRASH
	MOVE.L	#0,D1
	MOVE.B	CODCASH,D1
	ROL.L	#8,D1
	ROL.L	#8,D1
	MOVE.W	#$68,P10ADR
	BSR	GETWRT0
	MOVE.B	#1,HTDWN
	MOVE.W	#$18,P10ADR
	MOVE.L	#$FFFF,D1
	BSR	GETWRT
        MOVEM.L (A7)+,D0-D7/A0-A6
	STOP	#$2000

GETIOWA	EQU	*
	MOVE.L	(A0),D0
	ANDI.L	#$00FFFFFF,D0
	ORI.L	#$00E00000,D0
	MOVE.L	D0,IOWADDR
	MOVE.L	D0,ISTOME
	MOVE.L	PERMSGA+4,A0
	MOVE.L	A0,D0
	OR.L	#$00E00000,D0
	MOVE.L	D0,METOIS
	MOVE.L	#4,(A0)
	MOVEM.L	(A7)+,D0-D7/A0-A6

	MOVE	#$2000,SR
	MOVE.B	#$0C0,$FFF901
	MOVE.B	#$0C1,$FFF901
WAIT	JMP	$5000

	ORG	$1000


*   TRANSLATED ISIS MSG LENGTH
TRISLN	DC.B	0	;9E
	DC.B	2	;9F
	DC.B	2	;A0
	DC.B	2	;A1
	DC.B	2	;A2
	DC.B	0	;A3
	DC.B	3	;A4
	DC.B	3	;A5
	DC.B	2	;A6
	DC.B	2	;A7
	DC.B	0	;A8
	DC.B	0	;A9
	DC.B	2	;AA
	DC.B	2	;AB
	DC.B	2	;AC
	DC.B	2	;AD
	DC.B	2	;AE
	DC.B	0	;AF
	DC.B	0	;B0
	DC.B	4	;B1
	DC.B	0	;B2
	DC.B	0	;B3
	DC.B	0	;B4
	DC.B	3	;B5
	DC.B	6	;B6
	DC.B	0	;B7
	DC.B	0	;B8
	DC.B	0	;B9
	DC.B	0	;BA
	DC.B	0	;BB
	DC.B	0	;BC
	DC.B	0	;BD
	DC.B	0	;BE
	DC.B	0	;BF
	DC.B	0	;C0
	DC.B	0	;END

*   INTRA-ISIS MSG LENGTH
INISLN	DC.B	0	;00
	DC.B	0	;01
	DC.B	2	;02
	DC.B	0	;03
	DC.B	0	;04
	DC.B	0	;05
	DC.B	6	;06
	DC.B	0	;07
	DC.B	0	;08
	DC.B	3	;09
	DC.B	0	;0A
	DC.B	0	;0B
	DC.B	0	;0C
	DC.B	2	;0D
	DC.B	0	;0E
	DC.B	0	;0F
	DC.B	0	;10
	DC.B	0	;END


*   TRANSLATED HOST MSG LENGTH
TRHSTLN	DC.B	0	;00
	DC.B	12	;01
	DC.B	12	;02
	DC.B	0	;03
	DC.B	0	;04
	DC.B	0	;05
	DC.B	0	;06
	DC.B	0	;07
	DC.B	3	;08
	DC.B	3	;09
	DC.B	3	;0A
	DC.B	3	;0B
	DC.B	3	;0C
	DC.B	3	;0D
	DC.B	3	;0E
	DC.B	3	;0F
	DC.B	3	;10
	DC.B	3	;11
	DC.B	3	;12
	DC.B	3	;13
	DC.B	3	;14
	DC.B	0	;15
	DC.B	4	;16 ****
	DC.B	0	;17
	DC.B	52	;18
	DC.B	6	;19 ****
	DC.B	0	;1A
	DC.B	0	;1B
	DC.B	5	;1C
	DC.B	5	;1D
	DC.B	5	;1E 
	DC.B	100	;1F ****
	DC.B	0	;20
	DC.B	12	;21
	DC.B	0	;22 ****
	DC.B	0	;23
	DC.B	0	;24
	DC.B	0	;25
	DC.B	0	;26
	DC.B	0	;27
	DC.B	0	;28
	DC.B	0	;29
	DC.B	0	;2A
	DC.B	0	;2B
	DC.B	0	;2C
	DC.B	0	;2D
	DC.B	0	;2E
	DC.B	0	;2F
	DC.B	0	;30
	DC.B	3	;31
	DC.B	3	;32
	DC.B	0	;33
	DC.B	0	;34
	DC.B	0	;35
	DC.B	0	;36
	DC.B	0	;37
	DC.B	0	;38
	DC.B	0	;0


*
**:::::
*
*
*      ISIS  INPUT MESSAGE DISPATCH TABLE
*
IMSTAB	DC.L	IM4		;9E - DETACH, IGNORE
	DC.L	ISP		;9F - ZAPPER, SEND ON
	DC.L	ISP		;A0 - SET BKPR, SEND ON
	DC.L	ISP		;A1 - RELEASE BKPR, SEND ON
	DC.L	ISP		;A2 - GOBBLER, SEND ON
	DC.L	IM4		;A3 - FLUSH INPUT, IGNORE
	DC.L	BLACK		;A4 - BLACK BALL
	DC.L	GRAY		;A5 - GRAY BALL
	DC.L	ISP		;A6 - ENTER DEM, SEND ON
	DC.L	ISP		;A7 - LEAVE DEM, SEND ON
	DC.L	IM4		;A8 - ENTER TRANSPARENCY, IGNORE
	DC.L	IM4		;A9 - LEAVE TRANSPARENCY, IGNORE
	DC.L	ISP		;AA - GREEN BALL, SEND ON
	DC.L	ISP		;AB - RED BALL, SEND ON
	DC.L	ISP		;AC - YELLOW BALL, SEND ON
	DC.L	ISP		;AD - ORANGE BALL, SEND ON
	DC.L	ISP		;AE - BREAK BEGIN, SEND ON
	DC.L	IM4		;AF - HANG UP, IGNORE
	DC.L	IM4		;B0 - QUERY TERM CHAR, IGNORE
	DC.L	ITERM		;B1 - SET TERM CHAR
	DC.L	IM8		;B2 - PSEUDO NEEDLE , IGNORE
	DC.L	IM4		;B3 - LOGON CHAR, IGNORE
	DC.L	IM4		;B4 - LOGON STATUS, IGNORE
	DC.L	LOGFAL		;B5 - LOGON FAILED
	DC.L	ILOG		;B6 - LOGON OKAY
	DC.L	ISACT		;B7 - ACCOUNNTING, IGNORE
	DC.L	IM4		;B8 - SUPER HANG, IGNORE
	DC.L	SMTLMT		;B9 - SET XMT LIMIT, IGNORE
	DC.L	IM4		;BA - BREAK END, IGNORE
	DC.L	IM4		;BB - ZAP ACKNOWLEDGE, IGNORE
	DC.L	IM4		;BC - ENTER ALT DEV MODE, IGNORE
	DC.L	IM4		;BD - LEAVE ALT DEV MODE, IGNORE
	DC.L	IM4		;BE - ZAP WITH REASON,IGNORE
	DC.L	IM4		;BF - SIIX COMMAND, IGNORE
	DC.L	IM4		;C0 - TIIX COMMAND, IGNORE
	DC.L	0		;0 TERMINATES LIST

*
*  ISIS INPUT MESSAGE LENGTHS (NOT COUNTING PORT NMBR)
*
IMSSZ	DC.B	0		;9E
	DC.B	0		;9F
	DC.B	0		;A0
	DC.B	0		;A1
	DC.B	0		;A2
	DC.B	0		;A3
	DC.B	0		;A4
	DC.B	0		;A5
	DC.B	0		;A6
	DC.B	0		;A7
	DC.B	0		;A8
	DC.B	0		;A9
	DC.B	0		;AA
	DC.B	0		;AB
	DC.B	0		;AC
	DC.B	0		;AD
	DC.B	0		;AE
	DC.B	0		;AF
	DC.B	1		;B0
	DC.B	2		;B1
	DC.B	3		;B2
	DC.B	1		;B3
	DC.B	1		;B4
	DC.B	1		;B5
	DC.B	7		;B6
	DC.B	5		;B7
	DC.B	0		;B8
	DC.B	1		;B9
	DC.B	0		;BA
	DC.B	0		;BB
	DC.B	0		;BC
	DC.B	0		;BD
	DC.B	1		;BE
	DC.B	1		;BF
	DC.B	1		;C0
	DC.B	0		;END
*
*  ISIS INTRA-NODE MESSAGE DISPATCH TABLE
*
IPZTAB	DC.W	IPZERR		;00 RESTRT REQ, NONO
	DC.W	IPZERR		;01 RESTRT RESP,NONO
	DC.W	SUPTAK		;02 SUPERVISOR TAKEOVER
	DC.W	IPZERR		;03 REPORT TO SUP, NONO
	DC.W	IPZERR		;04 HOST STS, NONO
	DC.W	IPZERR		;05 ACCNTNG, NONO
	DC.W	IPTIME		;06 SUP TIME
	DC.W	IPZERR		;07 NORM CIR REQ, NONO
	DC.W	IPZERR		;08 AUX CIR REQ, NONO
	DC.W	AUXERR		;09 AUX CIRCUIT ERROR
 	DC.W	IPZERR		;0A HOST PORT AVAIL, NONO
	DC.W	HSTUNA		;0B HOST UNACCEPTABLE
	DC.W	IPZERR		;0C HOST COST, NONO
	DC.W	SUPTAK		;0D SUPERVISOR LOST

*
*  ISIS INTRA-NODE MESSAGE LENGTHS
*
IPZSZ	DC.B	0		;00
	DC.B	0		;01
	DC.B	1		;02
	DC.B	6		;03
	DC.B	9		;04
	DC.B	5		;05
	DC.B	5		;06
	DC.B	8		;07
	DC.B	8		;08
	DC.B	4		;09
	DC.B	7		;0A
	DC.B	4		;0B
	DC.B	7		;0C
	DC.B	0		;0D



*
*   HOST OUTPUT MESSAGE DISPATCH TABLE
*
OMTAB	DC.L	MERROR		;00 - (NONO)
	DC.L	OPEN		;01 - INTERFACE OPEN
	DC.L	SHUT		;02 - INTERFACE SHUT
	DC.L	RESET		;03 - RESET INTERFACE
	DC.L	MERROR		;04 - (NONO)
	DC.L	MERROR		;05 - (NONO)
	DC.L	MERROR		;06 - (NONO)
	DC.L	MERROR		;07 - (NONO)
	DC.L	SPEC		;08 - BACKPRESSURE ON,SEND ON
	DC.L	SPEC		;09 - BACKPRESSURE OFF,SEND ON
	DC.L	SPEC		;0A - GOBBLER, SEND ON
	DC.L	ZAP		;0B - ZAPPER
	DC.L	SPEC		;OC - ENTER DEM, SEND ON
	DC.L	SPEC		;0D - LEAVE DEM, SEND ON
	DC.L	SPEC		;0E - GREEN BALL, SEND ON
	DC.L	SPEC		;0F - RED BALL, SEND ON
	DC.L	SPEC		;10 - YELLOW BALL, SEND ON
	DC.L	SPEC		;11 - ORANGE BALL,SEND ON
	DC.L	SPEC		;12 - HANG UP, SEND ON
	DC.L	SPEC		;13 - ENTER TRANSPARENCY, SEND ON
	DC.L	SPEC		;14 - LEAVE TRANSPARENCY, SEND ON
	DC.L	MERROR		;15 - (NONO)
	DC.L	SUPREC		;16 - SUPERVISOR REQUEST
	DC.L	MERROR		;17 - (NONO)
	DC.L	SUPLOG		;18 - SUP LOGIN CHAR
	DC.L	TP		;19 - TEST PATTERN PROBE
	DC.L	MERROR		;1A - (NONO)
	DC.L	HSTSAD		;1B - HOST SAD (NONO)
	DC.L	ECHOON		;1C - ECHO ON
	DC.L	ECHOFF		;1D - ECHO OFF
	DC.L	STERM		;1E - SET TERM CHAR
	DC.L	PTERM		;1F - PROBE TERM CHAR
	DC.L	MERROR		;20 - (NONO)
	DC.L	SHNUM		;21 - SET HOST NUMBER
	DC.L	SCLKR		;22 - SUP CLOCK REQUEST
	DC.L	MERROR		;23 - (NONO)
	DC.L	BOK1		;24 - (NONO)
	DC.L	MERROR		;25 - (NONO)
	DC.L	BOK2		;26 - (NONO)
	DC.L	MERROR		;27 - (NONO)
	DC.L	MERROR		;28 - (NONO)
	DC.L	MERROR		;29 - (NONO)
	DC.L	BOK4		;2A - (NONO)
	DC.L	MERROR		;2B - (NONO)
	DC.L	BOK3		;2C - (NONO)
	DC.L	MERROR		;2D - (NONO)
	DC.L	BOK5		;2E - (NONO)
	DC.L	MERROR		;2F - (NONO)
	DC.L	MERROR		;30 - (NONO)
	DC.L	SPEC		;31 - ENTER ALT DEV, SEND ON
	DC.L	SPEC		;32 - LEAVE ALT DEV, SEND ON
	DC.L	MERROR		;33 - SET 4096 SEC TIMEOUT
	DC.L	MERROR		;34 - SET 60 SEC TIMEOUT
	DC.L	MERROR		;35 - SET KEY
	DC.L	MERROR		;36 - SET COST
	DC.L	MERROR		;37 - NEGATIVE ACK
	DC.L	MERROR		;38 - ENVIRONMENTAL DATA
	DC.L	0		;0 TERMINATES LIST
*


ACP	DC.L	0,0,0,0,0,0,0,0	;ACTIVE PORT BIT ARRAY
BKOBIT	DC.L	0,0,0,0,0,0,0,0	;BLK OUTPUT PORT BIT ARRAY
BKIBIT	DC.L	0,0,0,0,0,0,0,0	;BLK INPUT PORT BIT ARRY
NOINTB	DC.L	0,0,0,0,0,0,0,0	
OUTBPP	DC.L	0,0,0,0,0,0,0,0
*
*

CODCASH	DC.B	1
PCCASH	DC.L	1
*
*
IRSIZE	DC.L	1
ORSIZE	DC.L	1
*


NFMI	DC.W	0	;RELATIVE INDEX OF NEXT-FILL-MESSAGE-INDEX
CEI	DC.W	2	;RELATIVE INDEX OF CURRENT-EMPTY-INDEX


*  VARIOUS LOCATIONS FOR DOING READ AND WRITE TO PDP-10

DSENS	EQU	$D000B8	;D0=0-BUSY, 1-NOT BUSY
DPER	EQU	$D00138	;D0=1-ERROR, DO AFTER READ
DTMOT	EQU	$D001B8	;D0=1-TIMEOUT
DEXCO	EQU	$D01038	;RESET BOX SIGNAL ONLY
DEXC1	EQU	$D010B8	;NEXT WRT TO PDP10 WRITE WRONG PARITY

*** LOCATIONS FOR READ TO PDP-10

RD101	EQU	$D0403A
RD104	EQU	$D0403C
RD102	EQU	$D0403E
RD103	EQU	$D04038

*** LOCATIONS FOR WRITING TO PDP-10

WT101	EQU	$D0803A
WT102	EQU	$D0803C
WT103	EQU	$D0803E
WT104	EQU	$D08038


P10DAH	DC.W	1
P10DAL	DC.W	1
P10DLL	DC.B	1
P10ADR	DC.W	1	;ADDR OF 10 TO WRITE TO OR READ FROM


HOSTN	DC.W	1	;HOST NUM
HOSTP	DS.W	1	;MAX NUM OF PORTS
HSTAT	DC.W	$0300	;HOST STS;0=ANSW 1=DOWN 2=SHUT 3=GONE

MXPORT	DC.W	1	;MAX PORT TILL REPORT  OUT OF PORTS
NPORTS	DC.W	1	;CUR NUM OF ACTIVE PORTS

IBAUD	DS.B	256	;REMEMBER INPUT BAUD RATE
AUXQ	DC.W	1	;AUX CIRCUIT KEY
AUXTIM	DC.L	1	;TIMEOUT FOR AUX CIRCUIT REQUEST
AUXX	DC.W	-1	;INDEX INTO AUXC
AUXC	DS.B	40	;LOGIN STRING


VARPTR	DC.W	1
TYPBYT	DC.B	1
PORTNM	DC.B	1
HTDWN	DC.B	1
VPREND	DC.W	1
HTMGL	DC.W	1
PDPNOW	DC.W	1
HSTMSGW	DC.L	1	;32 BITS HOST MSG FROM PDP-10 RING

HTRGBG	DC.L	1
INRGAR	DC.L	1	;START ADR OF PDP INPUT RING
INRGSZ	DC.W	1	;INPUT RING SIZE
INPDPR	DC.W	1	;PDP RING POINTER
INBAPR	DC.W	1	;BASE RING POINTER
WRAPFG	DC.B	1	;1=INPUT RING WRAPPED 0=NO
INRGSP	DC.W	1	;# OF WORD OF SPACE IN INPUT RING
INTYBT	DC.B	1	;TYPE BYTE OF INPUT MSG TO PDP-10
BHMGL	DC.W	1	;BASE TO HOST MSG LENGTH
RSSMAL	DC.B	1	;FLAG TO TELL DATA MSG BEEN SPLIT 1=YES
INPTNM	DC.W	1	;PORT # ON ISIS MSG HEADER
INRGLOP	DC.W	1	;LOOP CONTROL
BBTY	DC.B	1	;TYPE BYTE
BBPT	DC.B	1	;PORT #
BBDA	DC.W	1	;DATA MSG
UPDFLG	DC.B	0	;0=NO NEED UPDATE BASE PTR, 1=OTHERWISE
NORNODE	DC.W	1
NORPORT	DC.W	1
TEMPWL	DC.L	1
NTID	DC.B	1
NSIZ	DC.B	1
NNSIZ	DC.B	1
DUMMY	DC.B	0
BPON	DC.B	0
BPOFF	DC.B	0


FOUR	DC.W	4


HMGLN	DC.W	0

*  LENGTH OF BASE-HOST MSG
BHMGTA	DC.W	0
	DC.W	0




*  THE DISPATCHER OUTPUT RING
ORING	DC.L	0	;OUTPUT BLOCK START ADDRESS


*  THE DISPATCHER INPUT RING
IRING	DC.L	0	;INPUT BLOCK START ADDRESS


ISISMSG	DC.L	1
ISTOME	DC.L	1
ISTOAD	DC.L	1
METOIS	DC.L	1
METOAD	DC.L	1
DAT1	DC.B	1
DAT2	DC.B	1
DAT3	DC.B	1
DAT4	DC.B	1
	DS.B	28
SLOWCA	DC.L	1		;ADR OF SLOWC TIME
GMTA	DC.L	1		;ADR OF GMT
GMT	DC.L	1
SLOWC	DC.L	1		;CLOCK IN ENGINE
HTM	DC.L	1		;TIME OF LAST OPEN/SHUT MSG
FASTCA	DC.L	1		;ADR OF FASTC
LFASTC	DC.L	1		;TIME OF LAST 1/2 SEC LOGIC
LHTDWN	DC.B	1		;HOST DOWN FLAG OF LAST CYCLE
LASCOU	DC.B	0		;COUNT OF GOOD KEY
BITCHK	DC.B	1
MAXPRT	DC.W	1
IPRTIM	DC.L	1		;TIME OF 1ST INPUT PTR
LINPDPR	DC.B	1		;1 = 1ST TIME INPUT RING FULL
BLK	DC.B	0		;0 = FOR ACP ONLY
BKOTAR	DC.L	1		;BLK OUTPUT START ADR
BKOTCN	DC.W	1		;BLK OUTPUT TOTAL COUNT
BKOLCN	DC.W	0		;BLK OUTPUT COUNT FINISHED
BKOPTR	DC.W	0		;BLK OUTPUT PTR
BKOBYT	DC.W	0		;BYTE POS WITHIN WORD
BKITIM	DC.L	0
BKITAR	DC.L	0	
BKITCN	DC.W	0
BKILCN	DC.W	0
BKIPTR	DC.W	0
BKIBYT	DC.W	0
HEXC	DC.W	12
HEX16	DC.W	16

BKOTB	DS.L	780		;OUTPUT BLK I/O TABLE
BKITB	DS.L	1040		;INPUT BLK I/O TABLE
BKBUTB	DS.L	780

SENCNT	DC.W	1
XMTLMT	DC.W	1
BKIA	DC.L	1
BKOA	DC.L	1
WBKCNT	DC.W	1
ONCOUNT	DC.W	1
BKN	DC.W	1
BKLEFT	DC.W	1		;# OF BYTES LEFT IN INP BLK BUFFER
LABYTE	DC.W	1

BKBUADR	DC.L	1
BKBUPU	DC.W	1
BKBUTA	DC.W	1
IFBKFU	DC.W	0
BKBUAV	DC.W	1

BUAR	DC.L	1
BKPR	DC.W	0		;# OF BYTES BEFORE APPLTYING BACK PRESSURE
BKPRN	DC.W	0		;# 0F BYTES BEFORE RELEASING BK PRESSURE
REG7	DC.L	0
BLKVAL	DC.W	0
BUNUM	DC.W	0
ADRTEM	DC.L	1
I2500	DC.W	2500
BLKA	DC.B	0
BLKY	DC.B	0
BLKSZZ	DC.B	0
COMSIZ	DC.B	0
A20000	DC.L	$30000
IRRN	DC.W	0
ORRN	DC.W	0
IFRPTR	DC.W	0
IUSPTR	DC.W	0
OFRPTR	DC.W	0
OUSPTR	DC.W	0
LNK1	DC.W	0
LNK2	DC.W	0
SAVE1	DC.W	0
SAVE2	DC.W	0
LMTLOP	DC.W	0
TRALMT	DS.B	256
XMTLEF	DC.W	0
TMOC	DC.B	0
TMDUM	DC.B	0
PEOC	DC.B	0
PEDUM	DC.B	0
CASHW	DC.L	0
CASH	DC.B	0
PFULL	DC.B	0
DATSPL	DC.B	0
DDDUM	DC.B	0
INSTOR	DC.L	0
OUSTOR	DC.L	0
DATRGZ	DC.B	0
DIAG	DC.B	0

	ORG	$5000

*   GET RING ADDR FROM ISIS
	MOVE.L	#$5000,A7	;SET UP THE STACK POINNTER
	BRA	FORTEST
	MOVE.L	#$E66300,IRING
	MOVE.L	#$7FC,IRSIZE
	MOVE.L	#$E65B00,ORING
	MOVE.L	#$7FC,ORSIZE
	MOVE.L	#$E0130C,GMTA
	MOVE.L	#$E01308,SLOWCA
	MOVE.L	#$E01304,FASTCA
	BRA	FORT11
	BRA.S	FORTEST
	MOVE.L	#$E000C0,A0
	MOVE.L	(A0),D1
	MOVE.L	A0,ISTOAD
	ADD.L	#4,A0
	MOVE.L	A0,METOAD
	MOVE.L	D1,ISTOME
	ROL.L	#8,D1		
	CMP.B	#4,D1
	BNE	NO4
	MOVE.L	#0,A1
	MOVE.L	ISTOME,D2
	AND.L	#$00FFFFFF,D2
	MOVE.L	D2,A1			;ADR OF I/O WINDOW
INTRUP	MOVE.B	#$0C0,$FFF901	;GO INTERRUPT ENGINE
      	MOVE.B	#$0C1,$FFF901	
	STOP	#$2000
FORTEST	MOVE.L	IOWADDR,A0
	MOVE.L	(A0)+,D0
	OR.L	#$00E00000,D0
	MOVE.L	D0,ORING
	MOVE.L	(A0)+,ORSIZE
	MOVE.L	(A0)+,D0
	OR.L	#$00E00000,D0
	MOVE.L	D0,IRING
	MOVE.L	(A0)+,IRSIZE
	MOVE.L	(A0)+,D0
	OR.L	#$00E00000,D0
	MOVE.L	D0,FASTCA
	MOVE.L	(A0)+,D0
	OR.L	#$00E00000,D0
	MOVE.L	D0,SLOWCA
	MOVE.L	(A0)+,D0
	OR.L	#$00E00000,D0
	MOVE.L	D0,GMTA
	MOVE.W	#VERSION,(A0)+		;SET VERSION NMBR
FORT11	*
	MOVE.L	IRING,A5		;INPUT RING ADR TO A5
	MOVE.L	ORING,A6		;OUTPUT RING ADR TO A6

	BSR.S	INITTO0
	BRA	UPDOUT1

NO4	SUB.B	D1,D1


**  INITIALISE TO ZERO
INITTO0	*
	MOVE.B	#0,DIAG
	MOVE.B	#0,DATRGZ
	MOVE.B	#0,DATSPL
	MOVE.B	#0,PFULL
	MOVE.W	#0,HOSTN		;MAKE HOST # ZERO
	MOVE.W	#0,HOSTP
	MOVE.W	#$0300,HSTAT		;MAKE HOST STATUS = GONE
	MOVE.W	#0,NPORTS		;MAKE # OF ACTIVE PORTS ZERO
	MOVE.B	#0,RSSMAL		;0=DATA MSG NOT SPLIT UP
	MOVE.B	#1,HTDWN		;0=HOST NOT DOWN, 1 OTHERWISE
	MOVE.W	#-1,AUXX
	MOVE.B	#0,LASCOU
	MOVE.L	#0,AUXTIM		;ZERO LAST AUX CIRCUIT TIME
	MOVE.L	#0,LFASTC		;ZERO LAST 1/2 SEC LOGIC TIME
	MOVE.L	#0,HTM			;ZERO LAST OPEN/SHUT TIME
	MOVE.B	#$FF,LINPDPR
	MOVE.B	#$FF,CODCASH		;INITIALISE CRASH CODE
	MOVE.B	#0,BLK			;ACP TABLE
	MOVE.W	#350,BKPR
	MOVE.W	#50,BKPRN
	MOVE.B	#0,BPON
	MOVE.B	#1,BPOFF
	MOVE.B	#0,BLKA
	MOVE.L	#$30000,A20000
	MOVE.B	#0,BLKY
	MOVE.B	#0,BLKSZZ
	MOVE.W	#0,IRRN
	MOVE.W	#0,ORRN
	MOVE.W	#0,IUSPTR
	MOVE.W	#0,OUSPTR
	MOVE.W	#$8000,IFRPTR
	MOVE.W	#$8500,OFRPTR

*  MAKE ALL PORTS BIT IN ACP 0
	LEA	ACP,A0
	MOVE.B	#40,D0
MAACP0	MOVE.L	#0,(A0)+
	SUB.B	#1,D0
	BNE.S	MAACP0

	MOVE.L	#$8000,A0
	MOVE.W	#260,D1
IBMAP	MOVE.W	A0,D0
	ADD.W	#4,D0
	MOVE.W	D0,(A0)
	ADD.L	#4,A0
	SUB.W	#1,D1
	BGT.S	IBMAP

	MOVE.L	#$8500,A0
	MOVE.W	#260,D1
OBMAP	MOVE.W	A0,D0
	ADD.W	#4,D0
	MOVE.W	D0,(A0)
	ADD.L	#4,A0
	SUB.W	#1,D1
	BGT.S	OBMAP

	MOVE.W	#256,D0
	LEA	TRALMT,A0
PUTLMT	MOVE.B	#157,(A0)+
	SUB.W	#1,D0
	BNE.S	PUTLMT



	LEA	DEXCO,A0
	TST.W	(A0)		;RESET TBUSS MIC

	RTS

*** GET INPUT RING START ADR
GEIRADR	MOVE.W	#$6B,P10ADR
	BSR	GETRED1
	MOVE.L	D1,INRGAR
	RTS

*** GET INPUT RING SIZE
GEIRSZ	MOVE.W	#$6C,P10ADR
	BSR	GETRED1
	MOVE.W	D1,INRGSZ
	RTS

*  TO WRITE TO INPUT RING BASE POINTER
WINBAPR	MOVE.W	#$6E,P10ADR
	MOVE.L	#0,D1
	MOVE.W	INBAPR,D1
	BSR	GETWRT
	RTS

***
*  CONVENTIONS:
*  ROUTINES USE DEDICATED REGISTERS
*  A6   OUTPUT RING INDEX
*  A5   INPUT RING INDEX
*  NOTE ....
*    IRSIZE & ORSIZE MUST BE LESS THAN 32K
*
*  INPUT ROUTINES

*  LOOK AT A RING ENTRY
*  Z FLAG = 0  IF RING EMPTY
*  ELSE SKIP RETURN, PORT RETURFFFNED IN D3
*  MESSAGE TYPE RETURNED IN D4
*  ALL REGISTERS SET UP FOR TRANSFER
*  POSITION IS ADVANCED PAST PORT#
*
*

LOOK	MOVE.W	(A5),NFMI
	MOVE.W	2(A5),CEI
	MOVE.W	NFMI,D1
	SUB.W	CEI,D1
	BEQ.S	NOIRING
	MOVE.L	#0,D7
	MOVE.W	CEI,D7
	MOVE.W	4(A5,D7.L),D3	;PORT #
	MOVE.W	6(A5,D7.L),D4	;MSG TYPE BYTE
	ADD.W	#3,IRRN
	LSR.W	#8,D4
	AND.W	#$00FF,D4
	ADD.L	#3,D7
	MOVE.B	#$FF,D1		;INDICATES NOT EMPTY
	RTS	 
NOIRING	SUB.B	D1,D1		;INDICATES RING EMPTY
	RTS


*  GET A CHARACTER FROM THE INPUT RING
*  CHARACTER RETURNED IN D0
GETCH   MOVEM.L	D1-D6/A0-A6,-(SP)
	ADD.W	#1,IRRN
GETCHN	BTST	#0,D7
	BEQ.S	EVENBON
	MOVE.W	3(A5,D7.L),D0
	BRA.S	ODDBON

EVENBON	MOVE.W	4(A5,D7.L),D0
	LSR.W	#8,D0
ODDBON	AND.W	#$00FF,D0
	ADD.L	#1,D7
	CMP.L	IRSIZE,D7
	BLT.S	GETCH1
	MOVE.L	#0,D7
GETCH1	MOVEM.L	(SP)+,D1-D6/A0-A6			;AND EXIT
	RTS
 
* QGETCH - GET CHAR FROM EITHER INPUT RING OR BUFFER
*	BLKA = 0 IF RING, +- IF BFR
*	D6 = NMBR OF CHARS IN RING OR BFR
*	D4 = MAX NMBR OF CHARS TO GET FROM RING/BFR
*	CARRY SET IF NO MORE CHARS
*	RSSMAL SET IF YELLOW BALL FOUND (BFR ONLY)

QGETCH	TST.W	D6		;SEE IF ANYTHING TO GET
	BEQ.S	QGC10		;BR IF NOT
	TST.W	D4		;SEE IF ANY PLACE TO PUT IT
	BEQ.S	QGC10		;BR IF NOT
	TST.B	BLKA		;RING OR BFR?
	BNE.S	DOBLKG		;BR IF FROM BFR
	BSR	GETCH		;GET FROM RING
	BRA.S	QGC20

DOBLKG	BSR.S	GETBFR		;GET A BYTE FROM BFR
	BNE.S	QGC20		;BR IF DATA
	SUB.W	#1,D6		;DECR DATA CNTR
	BEQ	QGC99		;CRASH IF ESCAPE ERROR
	BSR.S	GETBFR		;GET ESCAPED BYTE
	BEQ.S	QGC20		;BR IF 0 DATA
	MOVE.B	#1,RSSMAL	;INDICATE YELLOW BALL
	SUB.W	#1,D6		;DECR DATA CNTR
QGC10	MOVE	#1,CCR		;TURN ON CARRY
	RTS

QGC20	SUB.W	#1,D6		;DECR DATA CNTR
	SUB.W	#1,D4		;DECR ROOM CNTR
	MOVE	#0,CCR		;TURN OFF CARRY
	RTS
	
QGC99	MOVE.B	#$ED,CODCASH	;CRASH IF ESCAPE NOT FOLLOWED
	BSR	BCRASH		;*BY ANYTHING

* GETBFR - GET A CHAR FROM BUFFER

GETBFR	MOVEM.L	D2/A0,-(SP)
	MOVE.L	BKBUADR,A0	;GET BFR ADDR
	MOVE.W	BKBUTA,D2	;GET TAKE PTR
	MOVE.B	0(A0,D2.W),D0	;GET CHAR
	ADD.W	#1,D2		;INCR PTR
	CMP.W	#700,D2
	BLT.S	GETBF1
	MOVE.L	#0,D2
GETBF1	MOVE.W	D2,BKBUTA
	MOVEM.L	(SP)+,D2/A0
	TST.B	D0
	RTS

*  GET A HALF-WORD FHE INPUT RING
*  ASSUME WE HAVE REMOVED AN INTEGRAL NUMBER OF 
*  HALF-WORDS FROM RECORD
*  HALF-WORD RETURNED IN D0

GETH	MOVE.W	4(A5,D7.L),D0
	ADD.W	#2,IRRN
	ADD.L	#2,D7
	CMP.L	IRSIZE,D7
	BLT.S	GETH1
	MOVE.L	#0,D7
GETH1	RTS			;AND EXIT

*  GET A WORD FROM THE INPUT RING
*  ASSUME WE HAVE REMOVED AN INTEGRAL
*  NUMBER OF WORDS FROM RECORD
*  WORD RETURNED IN D0

GETW	MOVE.L	4(A5,D7.L),D0
	ADD.W	#4,IRRN
	ADD.L	#4,D7
	CMP.L	IRSIZE,D7
	BLT.S	GETW1
	MOVE.L	#0,D7
GETW1	RTS			;AND EXIT

*  FLUSH AN INPUT RECORD
*  NUMBER OF CHARS TO FLUSH IN D0
FLUSH	MOVE.L	#0,D6
	MOVE.B	D0,D6
	ADD.L	D6,D7

*  END LOGICAL INPUT RECORD
ELIR	ADD.L	#3,D7		;FORCE TO NEXT WORD
	AND.L	#-4,D7
	CMP.L	IRSIZE,D7
	BLT.S	ELIR2		;NO
	MOVE.L	#0,D7
ELIR2	MOVE.W	D7,2(A5)	;MOVE IN CEI
	RTS			;AND EXIT
*



*  OUTPUT ROUTINES

*  INSURE THERE IS ROOM IN RING(DISMISS IF NECESSARY)
*  EXPECTS D0 = # OF CHAR OF SPACE
*  Z FLAG = 0 MEANS OK, 1 IS OTHERWISE
ROOM	*

	MOVE.W	(A6),NFMI
	MOVE.W	2(A6),CEI
	MOVE.W	NFMI,D1
	SUB.W	CEI,D1		;IF WRAPPED AROUND ?
	BGT.S	RNOWRAP
	BEQ.S	ROOMG
	NEG.W	D1
	MOVE.W	D1,D2
	BRA.S	ROMCOM
RNOWRAP	MOVE.W	ORSIZE,D2
	SUB.W	D1,D2
ROMCOM	SUB.W	#4,D2
	CMP.W	D0,D2
	BLT.S	ROOMB
ROOMG	SUB.B	D1,D1
	RTS
ROOMB	MOVE.B	#$FF,D1
	RTS
	
	

*  START LOGICAL OUTPUT RECORD
*  PROVIDES FUNCTION OF ROOM, PUTH & PUTCH
*  FOR FIRST 3 CHARS OF MESSAGE
*  D2 = # OF CHARS OF SPACE REQUIRED
*  D3 = PORT #
*  D4 = MESSAGE CHARACTER CODE

SLOR	MOVEM.L	D0-D6,-(SP)
	MOVE.W	(A6),NFMI
	MOVE.L	#0,REG7
	MOVE.W	NFMI,REG7+2
	MOVE.L	#0,D0
	MOVE.B	D3,D0
	MOVE.L	REG7,D6

	MOVE.W	D0,4(A6,D6.L)
	ADD.L	#2,REG7
	LSL.W	#8,D4
	MOVE.L	REG7,D6
	MOVE.W	D4,4(A6,D6.L)
	ADD.L	#1,REG7
	MOVEM.L	(SP)+,D0-D6
	RTS

	
*  PUT A CHARACTER INTO THE RING
*  D0 = CHARACTER
PUTCH	MOVEM.L	D0-D6/A0-A6,-(SP)
	MOVE.L	REG7,D6
	BTST	#0,D6
	BEQ.S	PUEVEN
	MOVE.W	3(A6,D6.L),D2
	MOVE.B	D0,D2

	MOVE.W	D2,3(A6,D6.L)
	BRA.S	PUTODD
PUEVEN	LSL.W	#8,D0
	MOVE.W	D0,4(A6,D6.L)
PUTODD	ADD.L	#1,D6
	CMP.L	ORSIZE,D6
	
	BLT.S	PUTC1
	MOVE.L	#0,D6
PUTC1	MOVE.L	D6,REG7
	MOVEM.L	(SP)+,D0-D6/A0-A6
	RTS



*  PUT A HALF-WORD INTO THE RING
*  D0 = HALF WORD
PUTH	MOVEM.L	D0-D6/A0-A6,-(SP)
	MOVE.L	REG7,D6
	MOVE.W	D0,4(A6,D6.L)
	ADD.L	#2,D6
	CMP.L	ORSIZE,D6
	BLT.S	PUTH11
	MOVE.L	#0,D6
PUTH11	MOVE.L	D6,REG7
	MOVEM.L	(SP)+,D0-D6/A0-A6
	RTS



*  PUT A WORD INTO THE RING
*  D0 = WORD
PUTW	MOVEM.L	D0-D6/A0-A6,-(SP)
	MOVE.L	REG7,D6
	MOVE.L	D0,4(A6,D6.L)
	ADD.L	#4,D6
	CMP.L	ORSIZE,D6
	BLT.S	PUTW11
	MOVE.L	#0,D6
PUTW11	MOVE.L	D6,REG7
	MOVEM.L	(SP)+,D0-D6/A0-A6
	RTS


*  END LOGICAL OUTPUT RECORD
ELOR	MOVEM.L	D0-D6/A0-A6,-(SP)
	MOVE.L	REG7,D6
	ADD.L	#3,D6
	AND.L	#-4,D6
	CMP.L	ORSIZE,D6
	BLT.S	ELOR21
	MOVE.L	#0,D6
ELOR21	MOVE.W	D6,(A6)		;MOVE IN NFMI
	MOVE.L	D6,REG7
	MOVEM.L	(SP)+,D0-D6/A0-A6
	RTS








***  ROUTINE TO WRITE TO PDP-10

WR10R	*

	MOVE.B	#70,D1		;COUNTER FOR BUSY TRY
	LEA	DSENS,A0	;LOAD BUSY SENSE ADDRESS
WR10R1	MOVE.W	(A0),D0
	BTST 	#0,D0		;IF SENSE IS BUSY ?
	BNE.S	WRSNB		;YES, GO BUSY ROUTINE
	LEA	WT101,A1
	NOT.W	P10DAH		;MIC WILL INVERT BITS
	MOVE.W	P10DAH,(A1)	;LOAD 1ST HALF OF WORD TO WRITE
	LEA	WT102,A1
	NOT.W	P10DAL		;MIC WILL INVERT BITS
	MOVE.W	P10DAL,(A1)	;LOAD 2ND HALF OF WORD TO WRITE
	MOVE.B	P10DLL,D2	;LOAD LAST 4 BITS OF DATA
	MOVE.B	BLK,D4
	BNE.S	BLKK1
	NOT.B	D2		;MIC WILL INVEERT BITS

	AND.W	#$000F,D2	;ZERO OUT THE HIGH ORDER BITS
BLKK1	LEA	WT103,A1	;LOAD ADDRESS OF REGISTER 3
	MOVE.W	D2,(A1)		;MOVE IN DATA AND ADDRESS
	LEA	WT104,A1
	MOVE.W	P10ADR,D2	;MOVE IN 10 ADDRESS
	OR.W	#$8000,D2	;D0=1 TO INDICATE WRITE
	MOVE.W	D2,(A1)
	RTS

WRSNB	SUB.B	#1,D1
	BNE.S	WR10R1		;ANOTHER TRY IF < 56744 TIMES
	MOVE.B	DIAG,D0
	BNE	WRTERR
	BRA	BUSCRAS
	RTS


***  ROUTINE TO READ FROM PDP-10

RD10R	*
	MOVE.B	#3,TMOC
	MOVE.B	#3,PEOC
RD10AG	*
	MOVE.B	#70,D1		;COUNTER FOR BUSY TRY
	LEA	DSENS,A0
RD10R1	MOVE.W	(A0),D0
	BTST	#0,D0		;IF SENSE IS BUSY ?
	BNE.S	RDSNB		;YES, GO BUSY ROUTINE


	LEA	WT103,A1	;ADR OF D0803E
	MOVE.B	BLK,D6
	BNE.S	BLKK2
	MOVE.W	#0,(A1)		;MOVE IN 10 ADDRESS
BLKK22	LEA	WT104,A1	;ADR OF D08038
	MOVE.W	P10ADR,D2
	AND.W	#$7FFF,D2	;D0=0 TO INDICATE READ
	MOVE.W	D2,(A1)		;MOVE IN LOW ORDER ADDRESS
	MOVE.B	#70,D4		;COUNTER FOR BUSY LOOP
RD10R2	MOVE.W	(A0),D0
	BTST	#0,D0		;FI SENSE IS BUSY ?
	BNE.S	RDSNB1		;YES, GO BUSY ROUTINE
	LEA	RD101,A1	;ADR OF HI ORDER DATA
	MOVE.W	(A1),P10DAH	;MOVE IN HI 16 BITS  OF DATA FROM 10
	LEA	RD104,A1
	MOVE.W	(A1),P10DAL
	LEA	RD102,A1	;ADD OF LAST 4 BITS OF DATA FROM 10
	MOVE.W	(A1),D2
	AND.W	#$000F,D2	;ZERO OUT HIGH ORDER BITS
	MOVE.B	D2,P10DLL	;MOVE IN LAST 4 BITS OF DATA
	LEA	DPER,A3
	MOVE.W	(A3),D2		;CHECK IF THER IS PARITY ERROR ?
	BTST	#0,D2		;CHECK IF PARITY ERROR
	BNE.S	PARERR		;YES, GO PARITY ERROR ROUTINE
	RTS			;OTHERWISE RETURN

BLKK2	MOVE.L	#0,D2
	MOVE.B	P10DLL,D2
	MOVE.W	D2,(A1)
	BRA	BLKK22	
RDSNB	*
	SUB.B	#1,D1
	BNE.S	RD10R1		;ANOTHER TRY IF < 56744
	BRA	BUSCRAS
	RTS
RDSNB1	*
	LEA	DTMOT,A2
	MOVE.W	(A2),D2		;TEST IF TIME OUT ?
	BTST	#0,D2
	BNE.S	TMOUT		;YES, GO TIMEOUT ROUTINE
	LEA	DPER,A3


	MOVE.W	(A3),D2		;TEST IF PARITY ERROR
	BTST	#0,D2
	BNE.S	PARERR		;YES, GO PARITY ERR ROUTINE
RDSNB4	*
	SUB.B	#1,D4
	BNE.S	RD10R2		;ANOTHER TRY IF < 
	BRA	BUSCRAS
	RTS

BUSCRAS	*			;CRASH MIC TOO BUSY TOO LONG
	MOVE.B	#$A,CODCASH
	BRA	VCRASH1


NOREAD	*
	MOVE.L	#0,P10DAH	;0 TO INDIACTE READ FAIL
	MOVE.B	#-1,P10DLL	;-1 INDICATE READ FAIL
	RTS


TMOUT	*
	SUB.B	#1,TMOC
	BEQ.S	TMOUT1
	LEA	DEXCO,A0
	TST.W	(A0)
	BRA	RD10AG
TMOUT1	MOVE.B	#$8,CODCASH
	BRA	VCRASH1

PARERR	*
	SUB.B	#1,PEOC
	BEQ.S	PARERR1
	LEA	DEXCO,A0
	TST.W	(A0)
	BRA	RD10AG
PARERR1	MOVE.B	#$9,CODCASH

VCRASH1	*
	MOVE.B	DIAG,D0
	BNE	REDERR
	LEA	DEXCO,A0
	TST.W	(A0)			;RESET EBUSSSSSSSSSSSSSS !
	BRA	VCRASH			;GO TO CRASH HOST INTERFACE


******  ROUTINE TO WRITE TO PDP-10
*       WRITE 36 BITS WITH LAST 4 BITS ALL 0'S

WR1011	*
	MOVE.B	#$0F,P10DLL		;ALL 0'S TO LAST 4 BITS
	BSR	WR10R		;CALL WRITE ROUTINE
	RTS


***READ RING START ADR

RGADR	*
	MOVE.W	#$6F,P10ADR	;READ FROM OCTAL 157
	BSR	GETRED1
	MOVE.L	D1,HTRGBG	;RING START ADDRESS
	RTS

***  READ RING SIZE

RGSIZ	*
	MOVE.W	#$70,P10ADR
	BSR	GETRED1
	MOVE.W	D1,VPREND
	RTS

*** READ BASE POINTER

RBASPR	*
	MOVE.W	#$72,P10ADR
	BSR	GETRED
	MOVE.W	D1,VARPTR
	RTS



*** READ PDP-10 POINTER

RPDPPR	*
	MOVE.W	#$71,P10ADR
	BSR	GETRED
	MOVE.W	D1,PDPNOW
	RTS




	

UPDOUT1	*

UPDOUT	MOVE.B	HTDWN,D0
	BNE	INRG		;HOST DOWN, SKIPPPPP
	BSR	UPDVAR
	MOVE.W	ORRN,D0
	CMP.W	#$100,D0
	BGT	INRG
	BSR	RPDPPR		;READ PDP OUTPUT PTR
	BSR	COCONT		;ANYTHING IN RING ?
	BEQ	INRG		;DONE, UPDATE BASE POINTER
	BSR	REAVPT
	MOVE.L	D1,OUSTOR
	MOVE.L	D1,HSTMSGW	;STORE HOST MSG WORD
	MOVE.B	DAT1,TYPBYT
	MOVE.B	DAT2,PORTNM	;
	MOVE.W	#0,INPTNM
	MOVE.B	PORTNM,INPTNM+1
HTNODW	BSR	GEHTLN		;GET LENGTH OF MSG
	MOVE.W	HTMGL,D0
	BSR	ROOM		;ANY ROOM IN ORING ?
	BNE.S	DOIN		;NO , GO DO INPUT
	MOVE.L	#0,D1
	MOVE.B	TYPBYT,D1

	CMP.W	#$2E,D1
	BEQ	OUTIN
	CMP.W	#$1F,D1
	BEQ.S	OUTIN
	CMP.W	#$22,D1
	BEQ.S	OUTIN
	CMP.W	#$16,D1
	BEQ.S	OUTIN
	CMP.W	#$19,D1
	BNE	OTFRHST
OUTIN	BSR	INPDPT		;INPUT PDP PTR
	BSR	CARGSZ
	MOVE.L	HSTMSGW,DAT1
	MOVE.W	INRGSP,D1
	CMP.W	#8,D1
	BGE	OTFRHST
DOIN	BSR	SUBVPR		;NO, SUB BASE POINTER
	BRA	INRG

BKFMIS	*			;BACK FROM ISIS

	BRA	UPDOUT		;NO, START  ALL OVER AGAIN

UPDV	*

UPDV1	BRA	INRG

***  UPDATE BASE POINTER IN PDP-10

UPDVAR	*
	MOVE.L	#0,D1
	MOVE.W	VARPTR,D1
	MOVE.W	#$72,P10ADR
	BSR.S	GETWRT		;CALL WRITE ROUTINE
	RTS


GETWRT0	*
	MOVEM.L	D0-D7/A0-A6,-(SP)
	MOVE.L	D1,P10DAH
	MOVE.B	#$00,P10DLL
	BSR	WR10R
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS


*      WRITE D1 TO HI 32 BITS IN A WORD OF PDP-10
GETWRT1	*
	MOVEM.L	D0/D2-D7/A0-A6,-(SP)
	MOVE.L	D1,P10DAH
	BSR	WR1011
	MOVEM.L	(SP)+,D0/D2-D7/A0-A6
	RTS

*	WRITE D1 TO LO ORDER 32 BITS IN A WORD OF PDP-10
GETWRT	*
	MOVEM.L	D0-D7/A0-A6,-(SP)
	MOVE.B	D1,P10DLL	;LAST 4 BITS TO P10DLL
	ROR.L	#4,D1		;SHIFT 4 BITS TO THE RIGHT
	AND.L	#$0FFFFFFF,D1	;ZERO OUT HI 4 BITS
	MOVE.L	D1,P10DAH
	BSR	WR10R		;CALL WRITE ROUTINE
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS

***  TO BUMP BASE POINTER TO NEXT WORD

BUMVPR	*
	MOVEM.L	D0-D7/A0-A6,-(SP)
	ADD.W	#1,VARPTR
	MOVE.W	VPREND,D1	;MSG SIZE
	CMP.W	VARPTR,D1	;IF AT END
	BNE.S	BUMDONE		;NO, DONE
	MOVE.W	#0,VARPTR	;YES, WRAP BACK
BUMDONE	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS

**   SUBTRACT OUTPUT BASE POINTER BY 1
SUBVPR	*
	MOVE.W	VARPTR,D0
	SUB.W	#1,D0
	BGE.S	SUBDONE
	MOVE.W	VPREND,D0	;RING SIZE
	SUB.W	#1,D0
SUBDONE	MOVE.W	D0,VARPTR
	RTS

*** READ WORD POINTED BY VARPTR & PUT HI 32 BITS IN D1
*** ALSO BUMP BASE POINTER BY 1

REAVPT	*
	MOVEM.L	D0/D2-D7/A0-A6,-(SP)
	ADD.W	#1,ORRN
	MOVE.W	HTRGBG+2,D6	;START ADR OF OUTPUT RING
	MOVE.W	VARPTR,D2
	ADD.W	D2,D6		;ADD OFFSET
	MOVE.W	D6,P10ADR
	BSR	GETRED1
	BSR	WRPATCH
	ADD.W	#1,D2
	CMP.W	VPREND,D2
	BNE.S	REAV1
	MOVE.W	#0,D2
REAV1	MOVE.W	D2,VARPTR
	MOVEM.L	(SP)+,D0/D2-D7/A0-A6
	RTS


******TO CHECK IF MSG IS IN RING

COCONT	*
	MOVE.W	PDPNOW,D1	;PDP POINTER
	SUB.W	VARPTR,D1	;- BASE POINTER
	RTS

****READ FROM 10 PUT HI 32 BITS MSG IN D1

GETRED1	*
	MOVEM.L	D0/D2-D7/A0-A6,-(SP)
	BSR	RD10R		;READ FROM 10
	MOVE.L	P10DAH,D1	;INTO D1
	MOVE.L	D1,DAT1
	MOVEM.L	(SP)+,D0/D2-D7/A0-A6
	RTS

****READ 10 PUT LO ORDER 32 BITS IN D1

GETRED	*
	MOVEM.L	D0/D2-D7/A0-A6,-(SP)
	BSR	RD10R		;READ FROM 10
	MOVE.L	P10DAH,D1
	ROL.L	#4,D1		;SHIFT 4 BITS TO THE LEFT
	AND.L	#$FFFFFFF0,D1	;ZERO OUT LAST 4 BITS
	MOVE.B	P10DLL,D2
	AND.L	#$0000000F,D2	;ZERO OUT HI ORDER BITS
	OR.L	D2,D1		;LO BITS IN D1
	MOVE.L	D1,DAT1
	MOVEM.L	(SP)+,D0/D2-D7/A0-A6
	RTS


****** GET LENGTH OF MSG

GEHTLN	MOVEM.L	D0-D7/A0-A6,-(SP)
	MOVE.L	#0,D1
	MOVE.B	TYPBYT,D1	;MOVE IN TYPE BYTE
	CMP.W	#$80,D1
	BGT.S	NOCAL		;DATA MSG
	LEA	TRHSTLN,A0	;START ADDR OF MSG LENGTH TABLE
	ADD.L	D1,A0		;ADD OFFSET
	MOVE.L	#0,D2
	MOVE.B	(A0),D2		;MOVE ,L OF MSG TO HTMGL
	MOVE.W	D2,HTMGL
	BRA.S	NOCAL5
NOCAL	SUB.L	#$80,D1
	ADD.L	#3,D1		;ADD 3 BYTES, 2 FOR PORT 1 FOR TYPE BYTE
	MOVE.W	D1,HTMGL	;TYP BYTE - 80=LENGTH OF MSG
NOCAL5	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS
	


*     INPUT TO PDP RING FROM ISIS RING


INRG	*
	
INRGLP	MOVE.B	HTDWN,D0
	BEQ.S	INRG1		;HOST UP, CONTINEU TO PROCESSD
	BRA	BLOKIO		;GO HALF SEC LOGIC
INRG1	BSR	WINBAPR	
	MOVE.B	DATSPL,D1	;DATA MSG BEEN SPLIT ?
	BNE.S	INRGL1		;YES, GO READ PDP POINTER
	BSR	LOOK		;IF ANYTHING IN RING ?
	BEQ	BLOKIO		;NO, GO DO BLOCK I/O
	MOVE.W	D3,INPTNM	;PORT #
	MOVE.B	D4,INTYBT	;INPUT TYPE BYTE
	MOVE.W	D3,INSTOR
	MOVE.B	D4,INSTOR+2
	MOVE.B	INPTNM+1,PORTNM
INRGL1	BSR	INPDPT
	BSR	CARGSZ		;GET RING SPACE
	MOVE.W	INRGSP,D1
	BNE.S	RGSIZGG
	BRA	INRGL1

	MOVE.B	LINPDPR,D0
	BEQ.S	DOCOMP
	MOVE.B	#0,LINPDPR
	MOVE.L	(A0),IPRTIM
	BRA	BLOKIO
DOCOMP	MOVE.L	(A0),D0
	SUB.L	IPRTIM,D0
	CMP.L	#9600,D0
	BLT	BLOKIO
	MOVE.B	#$7,CODCASH
	BRA	VCRASH1

RGSIZGG	MOVE.B	#$FF,LINPDPR
	MOVE.B	DATSPL,D1	;DATA MSG BEEN SPLIT ?
	BNE	INTYD1		;YES, SKIP GETTING LENGTH OF BH MSG
	MOVE.L	#0,D1
	MOVE.W	IRRN,D1
	CMP.L	IRSIZE,D1
	BGT	BLOKIO
	MOVE.W	INPTNM,D2
	BEQ	IPZ		;BR IF PORT ZERO MSG
	MOVE.L	#0,D1
	MOVE.B	INTYBT,D1	;TYPE BYTE
	BEQ	NEEDLE		;BR IF NEEDLE
	CMP.W	#$9E,D1		;IF DATA MSG ?
	BGE	IMESS		;BR IF NOT
	
	BSR	TBTBKI
	MOVE.B	BITCHK,D0
	BEQ	INTYDA
	BSR	GEBUPOS
	BSR	GEBUF
	MOVE.W	IFBKFU,D0
	BNE	ISTOBU
	MOVE.W	BKBUPU,D0
	SUB.W	BKBUTA,D0
	BEQ	BKINDAM
ISTOBU	MOVE.L	#0,D2
	MOVE.B	INTYBT,D2
	MOVE.W	D2,BUNUM
ISTOBU1	MOVE.L	BKBUADR,A0
	MOVE.W	BUNUM,D2
	MOVE.L	#0,D0
	MOVE.W	BKBUPU,D0	
	ADD.L	D0,A0
	MOVE.L	A0,ADRTEM
	MOVE.W	BKBUAV,BPON
	MOVE.B	BPON,D6
	BNE	NOSBP
	SUB.W	BKBUTA,D0
	BGE	ISTO1
	ADD.W	#700,D0
ISTO1	ADD.W	D2,D0
	CMP.W	BKPR,D0
	BLT.S	NOSBP
	MOVE.B	#1,BPON
	MOVE.B	#0,BPOFF
	MOVE.W	BPON,BKBUAV
	MOVE.L	BUAR,A0
	BSR	PUBUF
	MOVE.L	#0,D0
	MOVE.B	#3,D0
IFDOBP	BSR	ROOM
	BNE.S	IFDOBP
	MOVE.W	INPTNM,D3
	MOVE.B	#$A0,D4
	BSR	SLOR
	BSR	ELOR
NOSBP	MOVE.L	ADRTEM,A0
	MOVE.W	BUNUM,D2
BUFMLOP	BSR	GETCH
	BSR.S	PUTBFR
	TST.B	D0
	BNE.S	BUFM1
	BSR.S	PUTBFR
BUFM1	SUB.W	#1,D2
	BGT.S	BUFMLOP
	MOVE.L	BUAR,A0
	BSR	PUBUF
	BSR	ELIR
	BRA	INRG

* PUTBFR - PUT A BYTE INTO A BUFFER

PUTBFR	MOVE.L	D0,-(SP)
	MOVE.B	D0,(A0)+
	ADD.W	#1,BKBUPU
	MOVE.W	BKBUPU,D0
	CMP.W	#700,D0
	BLT.S	BKPUGO
	MOVE.W	#0,BKBUPU
	MOVE.L	BKBUADR,A0
BKPUGO	MOVE.L	(SP)+,D0
	RTS

BKINDAM	*
	MOVE.B	INPTNM+1,PORTNM
BKIND1	BSR	GEINPO
	MOVE.L	A0,BKIA
	BSR	GETBKI
	MOVE.W	BKIBYT,LABYTE
	MOVE.L	#0,D6
	MOVE.B	INTYBT,D6
	MOVE.B	BLKA,D0
	BEQ.S	BKINBLK
	MOVE.W	BLKVAL,D6
BKINBLK	MOVE.W	BKITCN,D4	;CALC AMT OF ROOM IN BLOCK
	SUB.W	BKILCN,D4
	MOVE.W	D4,BKLEFT
	MOVE.B	#0,RSSMAL	;INDICATE NO YELLOW BALL
BKILOP	MOVE.W	#0,WBKCNT
	MOVE.W	BKIBYT,D0
	BEQ	BKILP2
	MOVE.W	BKIPTR,BKOPTR
	MOVE.L	BKITAR,BKOTAR
	BSR	RDBLK	
BKILP2	MOVE.L	#0,D5
	MOVE.W	BKIBYT,D5

BKILOOP	LEA	DAT1,A4
	ADD.L	D5,A4
BLOOP	BSR	QGETCH
	BCS	DOPUIBB
	MOVE.B	D0,(A4)+
	ADD.W	#1,WBKCNT
	ADD.B	#1,D5
	CMP.B	#4,D5
	BLT.S	BLOOP
	MOVE.L	DAT1,D1
	BSR	WRBLK
	MOVE.L	#0,D5
	BRA.S	BKILOOP

DOPUIBB	TST.B	D5
	BEQ.S	DOPUIB
	MOVE.L	DAT1,D1
	BSR	WRBLK
	SUB.W	#1,BKIPTR
DOPUIB	MOVE.W	D6,BHMGL	;SAVE AMT LEFT TO XFER
	MOVE.L	#0,D0
	MOVE.B	D5,D0
	MOVE.W	D0,BKIBYT
	MOVE.W	BKILCN,D0
	ADD.W	WBKCNT,D0
	MOVE.W	D0,BKILCN
	CMP.W	BKITCN,D0
	BEQ	BKINDON
	TST.B	RSSMAL		;SEE IF YELLOW BALL FOUND
	BNE	BKINDON		;BR IF SO
	MOVE.L	BKIA,A0
	BSR	PUTBKI

INBKEND	MOVE.B	BLKY,D0
	BNE	MAD20
	MOVE.B	BLKA,D0
	BNE.S	BUTOBK0
INBKEN1	BSR	ELIR
	BRA	INRG
BUTOBK0	MOVE.W	#0,IFBKFU
BUTOBK	MOVE.W	BKBUAV,BPON
	MOVE.B	BPOFF,D6
	BNE	BUTOBK1
	MOVE.B	#1,BPOFF
	MOVE.B	#0,BPON
	MOVE.W	BPON,BKBUAV
	MOVE.L	BUAR,A0
	BSR	PUBUF
	MOVE.L	#0,D0
	MOVE.B	#3,D0
NOBKRM	BSR	ROOM
	BNE.S	NOBKRM
	MOVE.L	#0,D3
	MOVE.B	PORTNM,D3
	MOVE.B	#$A1,D4
	BSR	SLOR
	BSR	ELOR
BUTOBK1	MOVE.L	BUAR,A0
	BSR	PUBUF
	MOVE.B	BLKY,D0
	BNE	MAD20
	MOVE.B	#0,BLKA
	BRA	UPDOUT
BKINDON	*
	MOVE.B	INPTNM+1,PORTNM
	MOVE.B	#$27,DAT1
	TST.B	RSSMAL
	BEQ.S	BKNDON2		;BR UNLESS TERM BY YELLOW BALL
	ADD.B	#1,DAT1		;MAKE TERM BY EOT MSG
BKNDON2	MOVE.B	INPTNM+1,DAT2
	MOVE.W	BKILCN,DAT3
	MOVE.L	DAT1,D1
	BSR	HTWING
	BSR	WRPDP
	BSR	WINBAPR
	TST.B	RSSMAL
	BEQ.S	BKNDON3		;BR UNLESS TERM BY YELLOW BALL
	MOVE.B	#$10,DAT1	;SEND YELLOW BALL
	MOVE.L	DAT1,D1
	BSR	HTWING
	BSR	WRPDP
	BSR	WINBAPR
BKNDON3	TST.W	BHMGL		;SEE IF MORE TO DO
	BNE.S	BKSPLIT
	MOVE.B	BLKA,D0
	BEQ.S	BKNDON
	MOVE.W	#0,BHMGL
	BRA.S	BKSPLI
BKNDON	MOVE.L	BUAR,A0
	MOVE.W	#1,IFBKFU
	MOVE.L	BUAR,A0
	BSR	PUBUF
	BRA	INBKEN1
BKSPLIT	MOVE.B	BLKA,D0
	BNE.S	BKSPLI
	MOVE.W	BHMGL,D0
	MOVE.W	D0,BUNUM
	MOVE.W	#1,IFBKFU
	MOVE.L	BUAR,A0
	BSR	PUBUF
	BRA	ISTOBU1
BKSPLI	MOVE.W	#1,IFBKFU
	MOVE.W	BHMGL,D0
	CMP.W	BKPRN,D0
	BLE	BUTOBK
	BRA	BUTOBK1
	
WRBLK	MOVEM.L	D0-D7/A0-A6,-(SP)
	MOVE.L	#0,D0
	MOVE.W	BKIPTR,D0
	ADD.L	BKITAR,D0
	MOVE.L	D1,P10DAH
	MOVE.W	D0,P10ADR
	ROL.L	#8,D0
	ROL.L	#6,D0
	ROL.L	#7,D0
	MOVE.B	D0,P10DLL
	MOVE.L	#0,D2
	MOVE.B	#$FF,BLK
	BSR	WR10R
	MOVE.B	#0,BLK
	ADD.W	#1,BKIPTR
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS
	
INTYDA	*
	BSR	GEBHLN		;GET LENGTH OF BASE-HOST MSG
INTYD1	*
	MOVE.W	BHMGL,D1	;MSG LENGTH
	CMP.W	#32,D1		;BIGGER THAN 42 ?
*            42 BECAUSE 40 + TYPBYTE + PORT # = 42
	BLE.S	NOG127		;LESS, NORMAL PROCESSING
	CMP.W	#32,INRGSP	;RING SIZE > 42 ?
	BLE.S	NOG127		;NO


	MOVE.W	#32,INRGSP	;MAKE RING SIZE = 42
NOG127	*
	MOVE.W	INRGSP,D5
	SUB.W	BHMGL,D5	;RING >= MSG LENGTH ?
	BGE.S	NORPUT		;YES
	MOVE.B	#1,DATSPL	;INDICATES DATA MSG SPLIT UP
	NEG.W	D5
	MOVE.W	INRGSP,BHMGL
	BRA.S	LESPUT
NORPUT	MOVE.B	#0,DATSPL
LESPUT	MOVE.W	BHMGL,INRGLOP	;MSG LENGTH + 2
	ADD.W	#$7E,BHMGL	;HEADER IS MSG LENGTH + HEX 80
	MOVE.W	BHMGL,D1
	MOVE.B	D1,BBTY		;NEW TYPE BYTE
	MOVE.W	INPTNM,D1
	MOVE.B	D1,BBPT		;MOVE TO OUTPUT PORT #
	MOVE.W	D5,BHMGL	;NEW MSG LENGTH AFTER SPLIT UP
	ADD.W	#2,BHMGL	;ADD 2 FOR PORT # AND TYPE BYTE
	BSR.S	PUTHEA		;ROUTINE TO PUT TYP BYTE & PORT #
	MOVE.B	DATSPL,D0
	BNE.S	LESPUT1
	BSR	ELIR
LESPUT1	BRA	INRGLP		;START OVER AGAIN

* PUT TYPE BYTE & PORT # + 2 BYTE DATA TO D1
PUTHEA	*
	MOVE.B	BBTY,DAT1		;MOVE IN TYPE BYTE

	MOVE.B	BBPT,DAT2
	BSR	GETCH
	MOVE.B	D0,DAT3
	CMP.W	#3,INRGLOP
	BEQ.S	DODEND
	BSR	GETCH
	MOVE.B	D0,DAT4
	CMP.W	#4,INRGLOP
	BEQ.S	DODEND
	SUB.W	#4,INRGLOP
	LEA	DAT1,A0
	MOVE.L	DAT1,D1
DODAMG1	BSR	WRPDP
	MOVE.B	#4,D5
	LEA	DAT1,A0
DODAMG2	BSR	GETCH
	MOVE.B	D0,(A0)+
	SUB.W	#1,INRGLOP
	BEQ.S	DODEND
	SUB.B	#1,D5
	BNE.S	DODAMG2
	MOVE.L	DAT1,D1
	BRA.S	DODAMG1
DODEND	MOVE.L	DAT1,D1
	BSR	WRPDP
	RTS


*   BLOCK OUTPUT IS BEING DONE HERE
DOBKOUT	*
	MOVE.B	HTDWN,D0
	BNE	UPDOUT
	MOVE.W	OUSPTR,D0
	BEQ	INBKTIM
	AND.L	#$0000FFFF,D0
IBM1	MOVE.L	D0,A0
	MOVE.L	(A0),D0
	MOVE.L	D0,LNK1
	MOVE.W	LNK1,SAVE1
	MOVE.W	D0,INPTNM
OUTBIT	MOVE.B	INPTNM+1,PORTNM
	LEA	TRALMT,A0
	MOVE.L	#0,D0
	MOVE.B	PORTNM,D0
	MOVE.W	#0,XMTLMT
	MOVE.B	0(A0,D0.L),XMTLMT+1
	BSR	BKOPOS
	MOVE.L	A0,BKOA
	BSR	GETBKO
	MOVE.W	BKOTCN,D0
	SUB.W	BKOLCN,D0
	CMP.W	XMTLMT,D0
	BLE.S	LESLMT
	MOVE.W	XMTLMT,D0
LESLMT	MOVE.W	D0,SENCNT
	ADD.W	#3,D0
	BSR	ROOM
	BNE	NOBIT
	MOVE.L	#0,D3
	MOVE.B	PORTNM,D3
	MOVE.B	SENCNT+1,D4
	BSR	SLOR
	MOVE.W	SENCNT,D5
	MOVE.W	BKOBYT,D0
	CMP.W	#4,D0
	BEQ	OBKLOP
	CMP.W	#1,D0
	BEQ	ONEOB
	CMP.W	#2,D0
	BEQ	TWOOB
	BSR	RDBLK
	MOVE.B	DAT4,D0
	BSR	PUTCH
	MOVE.B	#4,D4
	SUB.W	#1,D5
	BEQ	OBEND
	BRA	OBKLOP
ONEOB	BSR	RDBLK
	MOVE.B	DAT2,D0
	BSR	PUTCH
	MOVE.B	#2,D4
	SUB.W	#1,D5
	BEQ	OBEND
	MOVE.B	DAT3,D0
	BSR	PUTCH
	MOVE.B	#3,D4
	SUB.W	#1,D5
	BEQ	OBEND
	MOVE.B	DAT4,D0
	BSR	PUTCH
	MOVE.B	#4,D4
	SUB.W	#1,D5
	BEQ	OBEND
	BRA	OBKLOP
TWOOB	BSR	RDBLK
	MOVE.B	DAT3,D0
	BSR	PUTCH
	MOVE.B	#3,D4
	SUB.W	#1,D5
	BEQ	OBEND
	MOVE.B	DAT4,D0
	BSR	PUTCH
	MOVE.B	#4,D4
	SUB.W	#1,D5
	BEQ	OBEND		
OBKLOP	LEA	DAT1,A4
	MOVE.B	#1,D4
	BSR	RDBLK
OBLOP	MOVE.B	(A4)+,D0
	BSR	PUTCH
	SUB.W	#1,D5
	BEQ	OBEND
	ADD.B	#1,D4
	CMP.B	#5,D4
	BLT.S	OBLOP
	BRA.S	OBKLOP
OBEND	BSR	ELOR
	CMP.B	#4,D4
	BGE.S	YESFOUR
	SUB.W	#1,BKOPTR
YESFOUR	MOVE.W	SENCNT,D0
	ADD.W	BKOLCN,D0
	MOVE.W	D0,BKOLCN
	CMP.W	BKOTCN,D0
	BEQ	TOUTDON
	MOVE.L	#0,D0
	MOVE.B	D4,D0
	MOVE.W	D0,BKOBYT
	MOVE.L	BKOA,A0
	BSR	PUTBKO
	BRA.S	NOBIT
TOUTDON	BSR	INPDPT
	BSR	CARGSZ
	MOVE.W	INRGSP,D0
	BEQ.S	TOUTDON
	MOVE.B	#$25,DAT1
	MOVE.B	PORTNM,DAT2
	MOVE.L	DAT1,D1
	BSR	HTWING
	BSR	WRPDP
	BSR	WINBAPR
	BSR	RBTBKO
	BSR	RBTNOIN
NOBIT	*
NEXTBIT	MOVE.L	#0,D0
	MOVE.W	SAVE1,D0
	BNE	IBM1
	BRA	INBKTIM


RDBLK	MOVEM.L	D0/D2-D7/A0-A6,-(SP)
	MOVE.L	#0,D0
	MOVE.W	BKOPTR,D0
	ADD.L	BKOTAR,D0
	MOVE.W	D0,P10ADR
	ROL.L	#8,D0
	ROL.L	#6,D0
	ROL.L	#3,D0
	ROL.L	#4,D0
	MOVE.B	D0,P10DLL
	MOVE.B	#$FF,BLK
	BSR	RD10R
	MOVE.B	#0,BLK
	MOVE.L	P10DAH,D1
	MOVE.L	D1,DAT1
	ADD.W	#1,BKOPTR
	MOVEM.L	(SP)+,D0/D2-D7/A0-A6
	RTS


*  GET FASTC AND SEE IF IT IS 300 OR MORE BIGGERT THAN LFASTC
*  BGE IF ABOVE CONDITION MET, BLT OTHERWISE
TFASTC	MOVE.L	FASTCA,A0
TFASTC1	MOVE.L	(A0),D0
	SUB.L	LFASTC,D0
	CMP.L	#300,D0
	RTS

*   MOVE FASTC TO LFASTC
NFASTC	MOVE.L	FASTCA,A0
NFASTC1	MOVE.L	(A0),LFASTC
	RTS


* HALF SEC LOGIC, CHECK IF HOST UP
IFHTUP	MOVE.L	FASTCA,A0
FASTES	BSR.S	TFASTC1
	BLT	DOBKOUT
	MOVE.B	HTDWN,LHTDWN
	MOVE.B	HTDWN,D0
	BEQ	HUPR		;GO HOST UP ROUTINE
	MOVE.W	#$68,P10ADR	;0CTAL 150, WHWERE KEY IS STORED
	BSR	GETRED1
	CMP.L	#$CDFA68CB,D1
	BEQ.S	MGOOD
	MOVE.B	#0,LASCOU
	BRA.S	FINFAST

MGOOD	BSR	GETRED
	CMP.L	#$DFA68CB2,D1
	BNE.S	MNGOOD
	BSR.S	ZEROKY
	ADD.B	#1,LASCOU
	MOVE.L	#0,D2
	MOVE.B	LASCOU,D2
	CMP.W	#4,D2
	BGE.S	LASOK
	BRA.S	FINFAST
MNGOOD	MOVE.B	#0,LASCOU
	BRA.S	FINFAST
ZEROKY	MOVE.W	#$68,P10ADR
	MOVE.L	#0,D1
	BSR	GETWRT
	RTS
LASOK	MOVE.B	#0,LASCOU
	MOVE.W	#$73,P10ADR
	MOVE.L	#0,D1
	LEA	DEXCO,A0
	TST.W	(A0)
	BSR	GETWRT
	MOVE.L	#$5000,A7		;RE-INITIALIZE SP
	BSR	RGINFO
	BSR	INITTO0		;INITIALZE VARIABLES TO 0
	MOVE.B	#0,HTDWN	;0 = HOST IS UP
FINFAST	BSR	NFASTC
	BRA	DOBKOUT

KCRASH	ROL.L	#8,D1
	ROL.L	#8,D1
	MOVE.W	#$68,P10ADR
	LEA	DEXCO,A0
	TST.W	(A0)
	BSR	GETWRT0
	MOVE.B	#1,HTDWN
	MOVE.W	#$18,P10ADR
	MOVE.L	#$FFFF,D1
	LEA	DEXCO,A0
	TST.W	(A0)			;RESET EBUSSSSSSSS
	BSR	GETWRT
	LEA	DEXCO,A0
	TST.W	(A0)			;RESET EBUSSSSSSSSSSSSSSSSSS
	MOVE.B	#1,D4
	BSR	HDOWN
	BSR	EMPTY
	BRA.S	FINFAST

HUPR	MOVE.W	#$68,P10ADR
	BSR	GETRED1
	CMP.L	#$CDFA68CB,D1
	BNE.S	HNUPO
	BSR	GETRED
	CMP.L	#$DFA68CB2,D1
	BNE.S	KCASH3
	BSR	ZEROKY
	BRA.S	FINFAST
KCASH3	MOVE.L	#3,D1
	MOVE.B	#3,CODCASH
	BRA.S	KCRASH

HNUPO	CMP.L	#0,D1
	BNE.S	KCASH3
	BSR	GETRED
	CMP.L	#0,D1
	BNE.S	KCASH3
KCASH0	MOVE.L	#0,D1
	MOVE.B	#0,CODCASH
	BRA	KCRASH


*  CHECK IF 16 SEC HAS ELAPSED SINCE LAST BLK WRITE
INBKTIM	*
	MOVE.W	IUSPTR,D0
	BEQ	IBK111
	AND.L	#$0000FFFF,D0
IBM	MOVE.L	D0,A0
	MOVE.L	(A0),D0
	MOVE.L	D0,LNK1
	MOVE.W	LNK1,SAVE1
	MOVE.W	D0,INPTNM
IBKTIM	*
	MOVE.B	INPTNM+1,PORTNM
	BSR	GEBUPOS
	BSR	GEBUF
	MOVE.W	IFBKFU,D0
	BNE	IBK1
	BSR	GEINPO
	BSR	GETBKI
	MOVE.L	FASTCA,A0
	MOVE.L	(A0),D0
	SUB.L	BKITIM,D0
	CMP.L	#9600,D0
	BLT.S	IBK1
IBK0	BSR	INPDPT
	BSR	CARGSZ
	MOVE.W	INRGSP,D0
	BEQ.S	IBK0
	MOVE.B	#$29,DAT1
	MOVE.B	INPTNM+1,DAT2
	MOVE.W	BKILCN,DAT3
	MOVE.L	DAT1,D1
	BSR	HTWING
	BSR	WRPDP
	BSR	WINBAPR
	MOVE.W	#1,IFBKFU
	MOVE.L	BUAR,A0
	BSR	PUBUF
IBK1	*
	MOVE.L	#0,D0
	MOVE.W	SAVE1,D0
	BNE	IBM


**** ROUTINE TO PUT DATA FROM BUFFER TO HOST BLOCK


IBK111	MOVE.W	IUSPTR,D0
	BEQ	UPDOUT
	MOVE.B	#$FF,BLKA
	MOVE.B	#$FF,BLKY
	AND.L	#$0000FFFF,D0
BBLNK	MOVE.L	D0,A0
	MOVE.L	(A0),D0
	MOVE.L	D0,LNK1
	MOVE.W	LNK1,SAVE1
	MOVE.W	D0,INPTNM
MAD1	MOVE.B	INPTNM+1,PORTNM
	BSR	GEBUPOS
	BSR	GEBUF
	MOVE.W	IFBKFU,D0
	BNE	MAD20
	MOVE.W	BKBUPU,D0
	SUB.W	BKBUTA,D0
	BEQ	MAD20
	BGT	MADOK
	ADD.W	#700,D0
MADOK	MOVE.W	D0,BLKVAL
	BRA	BKIND1
MAD20 	MOVE.L	#0,D0
	MOVE.W	SAVE1,D0
	BNE	BBLNK
MAD26	MOVE.B	#0,BLKA
	MOVE.B	#0,BLKY
MADE	BRA	UPDOUT

*  GET RING INFO FROM 10 AFTER IT IS UP
RGINFO	BSR	RGADR		;OUTPUT RING ADR
	BSR	RGSIZ		;OUTPUT RING SIZE
	MOVE.W	#0,VARPTR	;OUTPUT BASE POINTER ZERO
	BSR	UPDVAR		;WRITE IT TO 10
	BSR	RPDPPR		;READ OUTPUT PDP POINTER

	BSR	GEIRADR		;INPUT RING ADR
	BSR	GEIRSZ		;INPUT RING SIZE
	MOVE.W	#0,INBAPR	;MAKE INPUT BASE PTR ZERO
	BSR	WINBAPR		;WRITE IT TO 10
	BSR	INPDPT		;READ INPUT PDP PTR

	RTS




*  GET LENGTH OF TRANSLATED BH MSG IN BYTES
GEBHLN	MOVEM.L	D0-D7/A0-A6,-(SP)
	MOVE.L	#0,D1
	MOVE.B	INTYBT,D1
	MOVE.W	INPTNM,D0	;PORT NUM
	BEQ.S	PRT0MG		;PORT 0 MSG
	CMP.W	#$9E,D1		;IF DATA MSG ?
	BGE.S	GEBHL1		;NO
	MOVE.W	D1,BHMGL
	ADD.W	#2,BHMGL	;ADD 2 FOR TYP BYTE & PORT #
	BRA.S	GEBHL5
GEBHL1	LEA	TRISLN,A0
	SUB.L	#$9E,D1
GEBHL2	ADD.L	D1,A0		;ADD OFFSET
	MOVE.L	#0,D0
	MOVE.B	(A0),D0		;MOVE MSG LENGTH
	MOVE.W	D0,BHMGL
GEBHL5	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS
PRT0MG	LEA	INISLN,A0
	BRA.S	GEBHL2

*
BLOKIO	*
	MOVE.B	HTDWN,D0	;IF HOST DOWN ?
	BEQ.S	BKHTND          ;NO, BR
	MOVE.B	#3,D4           ;YES, TELL SUP HOST IS DOWN
	BSR	HDOWN
BKHTND	MOVE.W	#0,IRRN
	MOVE.W	#0,ORRN
	MOVE.L	A7,D0
	CMP.L	#$3F00,D0
	BGT	IFHTUP
	MOVE.B	#$60,CODCASH
	BSR	BCRASH



*

	


	

*      TO READ THE PDP INPUT RING POINTER
INPDPT	*
	MOVE.W	#$6D,P10ADR
	BSR	GETRED
	MOVE.W	D1,INPDPR
	RTS

*      TO READ THE INPUT RING BASE POINTER
INBAPT	*
	MOVE.W	#$6E,P10ADR
	BSR	GETRED
	MOVE.W	D1,INBAPR
	RTS

*     CALCULATE # OF BYTES OF SPACE LEFT IN RING
CARGSZ	MOVEM.L	D0-D7/A0-A6,-(SP)
	MOVE.W	INBAPR,D1
	SUB.W	INPDPR,D1	;BASE - PDP POINTERS
	BGE.S	CARBGE		;NO WRAPPING
	NEG.W	D1
CARGSZ1	SUB.W	#1,D1		;TO PREVENT OVERFLOW
	MULU	FOUR,D1		;TIMES 4 TO GET # OF BYTES
	MOVE.W	D1,INRGSP	;SPACE IS ABSOLUTE VALUE OF D1
	BRA	CARRTS
ALLRING	MOVE.W	INRGSZ,D1
	SUB.W	#1,D1
	MULU	FOUR,D1
	MOVE.W	D1,INRGSP
	BRA	CARRTS
CARBGE0	MOVE.W	INRGSZ,D1
	SUB.W	INBAPR,D1
	MULU	FOUR,D1
	MOVE.W	D1,INRGSP
	MOVE.W	INPDPR,D1
	BEQ	CARRTS
	SUB.W	#1,D1
	MULU	FOUR,D1
	ADD.W	D1,INRGSP
	BRA	CARRTS
CARBGE	*
	MOVE.W	INRGSZ,D1
	SUB.W	INBAPR,D1	;SPACE IS RING SIZE-BASE POINTER
	MULS	FOUR,D1		;TIMES 4 TO GET # OF BYTES
	MOVE.W	D1,INRGSP
	MOVE.B	DATRGZ,D0
	BNE	CARRTS
	MOVE.L	#0,D0
	MOVE.B	INTYBT,D0
	CMP.W	#$9E,D0		;IF DATA MSG ?
	BGE.S	NODALN		;NO, BR
	CMP.B	#0,D0		;IF NEEDLE ?
	BEQ.S	NODALN		;YES, BR
	MOVE.W	INPTNM,D0	;IF PORT 0 MSG ?
	BEQ.S	NODALN		;YES, BRA
	BRA.S	CARRTS
NODALN	MOVE.L	#0,D1
	MOVE.W	INPDPR,D1
	BEQ.S	CARRTS
	SUB.W	#1,D1
	MULU	FOUR,D1
	ADD.W	D1,INRGSP
CARRTS	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS


HTWING	MOVEM.L	D1-D2,-(SP)
	MOVE.W	#4,D2
HTWING1	*
HTWING2	BSR	INPDPT
	BSR	CARGSZ
	CMP.W	INRGSP,D2
	BGT	HTWING2
	MOVEM.L	(SP)+,D1-D2
	RTS


*   WRITE MSG TO PDP RING & UPDATE BASE POINTER
WRPDP	*
	MOVEM.L	D0-D7/A0-A6,-(SP)
	BSR	WRPATW
	MOVE.W	INRGAR+2,D6	;INPUT RING START ADR
	MOVE.W	INBAPR,D5
	ADD.W	D5,D6
	MOVE.W	D6,P10ADR
	MOVE.L	D1,P10DAH
	BSR	GETWRT1
	ADD.W	#1,D5
	CMP.W	INRGSZ,D5	;IF BASE POINTER = RING SIZE
	BNE.S	WRIRTS
WRINRG	BSR	INPDPT
	BEQ.S	WRINRG
	MOVE.W	#0,D5
WRIRTS	MOVE.W	D5,INBAPR
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS

*******************************




*
*     CRASH ROUTINES FOR THE BASE
* EBUSS CRASH
ECRASH	MOVE.L	ISTOME,A0
	MOVE.L	#0,D0
	MOVE.B	CODCASH,D0
	ROL.L	#8,D0
	ROL.L	#8,D0
	ROL.L	#8,D0
	MOVE.L	D0,(A0)+
	MOVE.L	PCCASH,(A0)+	;PC SOTRED
	MOVE.L	D0,(A0)+
	MOVE.L	D1,(A0)+
	MOVE.L	D2,(A0)+
	MOVE.L	D3,(A0)+
	MOVE.L	D4,(A0)+
	MOVE.L	D5,(A0)+
	MOVE.L	D6,(A0)+
	MOVE.L	D7,(A0)+
	MOVE.L	A0,(A0)+
	MOVE.L	A1,(A0)+
	MOVE.L	A2,(A0)+
	MOVE.L	A3,(A0)+
	MOVE.L	A4,(A0)+
	MOVE.L	A5,(A0)+
	MOVE.L	A6,(A0)+
	MOVE.L	A7,(A0)+
	
	RTS
	
	MOVE.B	#40,D0
LSTACK	MOVE.L	(SP)+,(A0)+
	SUB.B	#1,D0
	BNE.S	LSTACK
	RTS


* CRASH ROUTINE
BCRASH	*

	MOVE.L	(A7)+,PCCASH		;LOCATION THAT CALL THIS ROUTINE
	MOVE.L	#0,D0
	MOVE.B	CODCASH,D0
	ROL.L	#8,D0			;SHIFT CRASH REASON 8 BITS TO LEFT
	MOVE.B	#3,D0			;3 IN LO BYTE MEANS THE BASE CRASHES
	MOVE.L	METOIS,A0		;ADR OF BASE-TO-ENGINE MSG AREA
	MOVE.L	D0,(A0)			;MOVE IT TO BASE-TO-ENGINE MSG AREA
	BSR	ECRASH
	BRA	INTRUP			;GO TO INTERRUPT ENGINE


*
*  ERROR CONDITION DETECTED, CRASH INTERFACE
*


MERROR	MOVE.B	#4,CODCASH		;BAD MESSAGE TYPE
	MOVE.B  #4,CASH
	MOVE.L	DAT1,CASHW
	BRA	VCRASH1			;CRASH THE HOST INTERFACE


ISMGER	MOVE.B	#$50,CODCASH
	MOVE.B	#$50,CASH
	MOVE.W	INPTNM,CASHW
	MOVE.B	INTYBT,CASHW+2
	BSR.S	BCRASH

* * * ROUTINE THAT CRASHES THE VARIAN BASE

VCRASH	MOVE.L	#$5000,A7
	MOVE.B	#3,D4
	BSR	HDOWN
	MOVE.L	#0,D1
	MOVE.B	CODCASH,D1		;CRASH REASON
	ROL.L	#8,D1
	ROL.L	#8,D1
	MOVE.W	#$68,P10ADR		;WRITE IT TO O'150' IN 10
	LEA	DEXCO,A0
	TST.W	(A0)
	BSR	GETWRT0
	MOVE.B	#1,HTDWN		;1=HOST INTERFACE IS DOWN
	MOVE.W	#$18,P10ADR		;NON-ZERO VALUE TO O'30' IN 10
	MOVE.L	#$FFFF,D1
	LEA	DEXCO,A0
	TST.W	(A0)
	BSR	GETWRT
	BSR	EMPTY
	BRA	UPDOUT1

*
*PROCESS MESSAGE IN RECORD
*
OTFRHST	MOVE.L	#0,D2
	MOVE.B	TYPBYT,D2	;MOVE IN TYPE BYTE
	CMPI.W	#$80,D2
	BGT.S	DATAM		;BR IF DATA MESSAGE
*
*	
	CMP.W	#$0000,D2	;CHK HT MSG TYPE RANGE
	BLT	MERROR		;INVALID MSG RANGE
	CMP.W	#$0039,D2
	BGE	MERROR		;INVALID MSG RANGE

HTMGKO	*
	MULU	FOUR,D2		;TIMES 4 TO GET OFFSET
	LEA	OMTAB,A0	;LOAD TABLE ADDRESS
HTMGLP	ADD.L	D2,A0
	MOVE.L	(A0),A1
HTMGOK	JMP	(A1)
*
*PROCESS OUTPUT DATA MESSAGES

DATAM	MOVE.W	#-1,LMTLOP
	MOVE.W	HTMGL,D6		;HOST TO ISIS MSG LEN
	SUB.W	#3,D6			;MINUS PRT(2 BYTE) AND TYPE(1 BYTE)
	BLE	MERROR	
	LEA	TRALMT,A0
	MOVE.L	#0,D0
	MOVE.B	PORTNM,D0
	MOVE.W	#0,XMTLMT
	MOVE.B	0(A0,D0.L),XMTLMT+1
CHKLMT1	SUB.W	XMTLMT,D6
	BLE	LMTOK
	MOVE.W	D6,XMTLEF
	MOVE.W	XMTLMT,D6
	BRA.S	LMTOK1
LMTOK	MOVE.W	#0,XMTLEF
	ADD.W	XMTLMT,D6
LMTOK1	MOVE.W	D6,D0
	ADD.W	#3,D0
	BSR	IFISRG2
		
	MOVE.B	PORTNM,D3

	MOVE.W	D6,D4			;MSG TYPE IS MSG LEN
	BSR	SLOR
	ADD.W	#1,LMTLOP
	BGT	DATOIS
	SUB.W	#2,XMTLMT
	MOVE.B	DAT3,D0
	BSR	PUTCH
	CMP.W	#1,D6
	BNE.S	DONOT1
DATAM11	BSR	ELOR
	MOVE.W	XMTLEF,D0
	BEQ	UPDOUT
	MOVE.W	XMTLEF,D6
	BRA	CHKLMT1	

DONOT1	MOVE.B	DAT4,D0
	BSR	PUTCH
	CMP.W	#2,D6
	BEQ.S	DATAM11
	SUB.W	#2,D6
DATOIS	MOVE.W	#4,D5
	BSR	REAVPT		;READ WORD FROM PDP-10
DATOIS1	ROL.L	#8,D1
	MOVE.B	D1,D0
	BSR	PUTCH
	SUB.W	#1,D6
	BEQ.S	DATAM11
	SUB.W	#1,D5
	BEQ.S	DATOIS
	BRA.S	DATOIS1





* OMSGS 01 & 02 - INTERFACE OPEN/SHUT

OPEN	MOVE.L	#0,D0		;SET OPEN STATUS
	BRA.S	OPSHT
SHUT	MOVE.L	#2,D0		;SET SHUT STATUS
OPSHT	MOVE.L	#0,D6
	MOVE.B	HSTAT,D6
	SUB.L	#1,D6
	BNE.S 	HST2
	MOVE.W	D6,NPORTS
TIMCHK	BSR	TSLOWC
	MOVE.L	SLOWC,D6
*		;DON'T FLOOD SUP WITH OPEN/SHUT MSGS
	SUB.L	HTM,D6
	BLT.S	HST1
	SUB.L	#8,D6
	BGT.S	HST1
	BRA.S	TIMCHK
HST1	BSR	TSLOWC
	MOVE.L	SLOWC,D6
  	MOVE.L	D6,HTM
HST2	MOVE.B	D0,HSTAT
	BSR	HREPRT		;REPORT NEW HOST STS TO SUP
	BRA	SKIP2
*
* OMSG 03 - RESET INTERFACE
*
RESET	BSR	EMPTY
	MOVE.L	#0,D4
	MOVE.B	#1,D4		; 1 = HOST DOWN
	BSR	HDOWN
	MOVE.B	#1,HTDWN
	BRA	BKFMIS

*
*OMSG 0B - ZAPPER
*
ZAP	MOVE.L	#0,D1
	MOVE.B	PORTNM,D1		;LOAD PORT #
	BEQ	SKIP2			;DONE IF PORT 0
	BSR	TBTACP
	MOVE.B	BITCHK,D0
	BEQ.S	NODPO
	BSR	DPORT
NODPO	BSR	RBTACP			;RESET PORT BIT MAP
	BSR	RBTALL
	BRA.S	SPEC1	

*   SET BIT IN ACP ARRAY WHOSE PORT # IS IN D1
SETACP	MOVEM.L	D0-D7/A0-A6,-(SP)
	BSR.S	GETACP
	BSET	D3,D2
	MOVE.L	D2,(A0)
	MOVEM.L	(SP)+,D0-D7/A0-A6
 	RTS


*   RESET BIT ARRAY OF THE PORT NUMBER IN D1
RBTACP	MOVEM.L	D0-D7/A0-A6,-(SP)
	BSR.S	GETACP			;GET WORD AND BIT POSITION
	BCLR	D3,D2			;D2 THE WORD, D3 THE BIT COUNT
	MOVE.L	D2,(A0)			;WRITE REG BACK TO MEM
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS

*  CALCULATE WHICH WORD & WHICH BIT WITHIN WORD IS THE PORT NUMBER
GETACP	LEA	ACP,A0			;START ADR OF ACP PORT BIT ARRAY
	MOVE.B	BLK,D0
	BEQ.S	GETNOR
	MOVE.L	A1,A0
GETNOR	MOVE.L	#0,D2
	MOVE.W	D1,D2
GETACP1	SUB.L	#32,D2			;SEE WHICH WORD IT BELONGS
	BLT.S	GTACPEN
	ADD.L	#4,A0			;ADVANCE TO NEXT WORD
	BRA.S	GETACP1
GTACPEN	MOVE.L	#32,D3
	ADD.L	D2,D3			;BIT POS WITHIN WORD
	MOVE.L	(A0),D2			;D2 IS WORD CONTAINING THE PORT BIT

	RTS


* OMSGS 08-14,31-32 - VARIOUS ONE-BYTE MESSAGES

SPEC	MOVE.W	#0,D1
	MOVE.B	PORTNM,D1		;MOVE IN PORT #
	BSR.S	TBTACP			;TEST PORT BIT MAP
	MOVE.B	BITCHK,D0 
	BEQ.S	SKIP2			;BR IF INACTIVE PORT

SPEC1	LEA	SPTAB,A0		;HOST TO ISIS MSG TABLE
	MOVE.L	#0,D0
	MOVE.B	TYPBYT,D0		;TYPE BYTE
	ADD.L	D0,A0			;ADD OFFSET
	MOVE.B	(A0),D4			;TYPE BYTE TO ISIS INPUT
	MOVE.L	#0,D3
	MOVE.B	PORTNM,D3
	BSR	SLOR
	BSR	ELOR


SKIP2	BRA	UPDOUT

ZAPEND  *
	BRA	UPDOUT			;ANOTHER OUTPUT FROM PDP RING

*   TEST THE BIT ARRAY WHOSE CORRESPONDING PORT NUM IS IN D1
TBTACP	MOVEM.L	D0-D7/A0-A6,-(SP)
	BSR.S	GETACP			;WORD IN D2, BIT POS IN D3
	BTST	D3,D2			;TEST BIT ARRAY OF PORT # IN D1
	BNE.S	BITNE
	MOVE.B	#0,BITCHK	
	BRA.S	TBITDON
BITNE	MOVE.B	#1,BITCHK
TBITDON	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS


TBTNOIN	MOVEM.L	D0-D7/A0-A6,-(SP)
	LEA	NOINTB,A1
TBT12	MOVE.L	#0,D1
	MOVE.W	INPTNM,D1
	MOVE.B	#$FF,BLK
	BSR	TBTACP
	MOVE.B	#0,BLK
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS

TBTOTBP	MOVEM.L	D0-D7/A0-A6,-(SP)
	LEA	OUTBPP,A1
	BRA	TBT12

SETNOIN	MOVEM.L	D0-D7/A0-A6,-(SP)
	LEA	NOINTB,A1
SET12	MOVE.L	#0,D1
	MOVE.W	INPTNM,D1
	MOVE.B	#$FF,BLK
	BSR	SETACP
	MOVE.B	#0,BLK
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS

SETOTBP	MOVEM.L	D0-D7/A0-A6,-(SP)
	LEA	OUTBPP,A1
	BRA	SET12

RBTNOIN	MOVEM.L	D0-D7/A0-A6,-(SP)
	LEA	NOINTB,A1
RBT12	MOVE.L	#0,D1
	MOVE.W	INPTNM,D1
	MOVE.B	#$FF,BLK
	BSR	RBTACP
	MOVE.B	#0,BLK
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS

RBTOTBP	MOVEM.L	D0-D7/A0-A6,-(SP)
	LEA	OUTBPP,A1
	BRA	RBT12


*   TEST BLK INPUT PORT BIT ARRAY, PORT NUM IS IN D1
TBTBKI	MOVE.W	IUSPTR,D0
	BEQ	NEGILK
	AND.L	#$0000FFFF,D0
ILK	MOVE.L	D0,A0
	MOVE.L	(A0),D0
	MOVE.L	D0,LNK1
	CMP.W	INPTNM,D0
	BEQ	POSILK
	MOVE.L	#0,D0
	MOVE.W	LNK1,D0
	BNE	ILK
NEGILK	MOVE.B	#0,BITCHK
	RTS
POSILK	MOVE.B	#1,BITCHK
	RTS

	LEA	BKIBIT,A1
	MOVE.L	#0,D1
	MOVE.W	INPTNM,D1
	MOVE.B	#$FF,BLK
	BSR	TBTACP
	MOVE.B	#0,BLK
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS

*   TEST BLK OUTPUT BIT ARRAY, PORT NUM IN D1
TBTBKO	MOVE.W	OUSPTR,D0
	BEQ	NEGOLK
	AND.L	#$0000FFFF,D0
IOOO	MOVE.L	D0,A0
	MOVE.L	(A0),D0
	MOVE.L	D0,LNK1
	CMP.B	PORTNM,D0
	BEQ.S	POSOLK
	MOVE.L	#0,D0
	MOVE.W	LNK1,D0
	BNE.S	IOOO
NEGOLK	MOVE.B	#0,BITCHK
	RTS
POSOLK	MOVE.B	#1,BITCHK
	RTS


	LEA	BKOBIT,A1
	MOVE.L	#0,D1
	MOVE.B	PORTNM,D1
	MOVE.B	#$FF,BLK
	BSR	TBTACP
	MOVE.B	#0,BLK
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS


*
*  CONVERSION TABLE FOR HOST MSGS TO ISIS MSGS
*
SPTAB	DC.B	0,0,0,0,0,0,0,0,$0A0,$0A1

	DC.B	$0A2,$9F,$0A6,$0A7,$0AA,$0AB,$0AC,$0AD,$0AF,$0A8

	DC.B	$0A9,0,0,0,0,0,0,0,0,0

	DC.B	0,0,0,0,0,0,0,0,0,0 

	DC.B	0,0,0,0,0,0,0,0,0,$0BC

	DC.B	$0BD,0,0,0,0,0,0,0


*
* OMSG 16 - SUPERVISOR REQUEST
*


SUPREC	MOVE.W	AUXX,D0		;INDEX INTO BYTE ARRAY
	BLT.S	SUPR1		;NO AUX CIRCUITS IN PROGRESS
	BSR	TSLOWC
	MOVE.L	SLOWC,D0		;HOW LOMG SINCE LAST TRY
	SUB.L	AUXTIM,D0
	ANDI.W	#-32,D0
	BNE.S	SUPR1
	MOVE.W	#$0900,D3		;LAST REQURST STILL IN PROGRESS
	BSR.S	OUT4M
	BRA.S	SKIP4
SUPR1	MOVE.W	#0,AUXX		;GIVE GO AHEAD
	MOVE.L	#0,D1
	MOVE.B	PORTNM,D1
	MOVE.W	D1,AUXQ
	MOVE.L	#0,D3
	BSR.S	OUT4M
	BSR	TSLOWC
	MOVE.L	SLOWC,D0
	MOVE.L	D0,AUXTIM
	BSR	WINBAPR	
SKIP4	BRA	BKFMIS


OUT4M	MOVE.B	#$17,DAT1		;SEND SUP RESPONSE
	MOVE.B	PORTNM,DAT2
	MOVE.W	D3,DAT3
	MOVE.L	DAT1,D1
	BSR	HTWING
	BSR	WRPDP
	RTS

* OMSG 18 - SUPERVISOR LOGIN CHAR

SUPLOG	MOVE.L	#0,D1
	MOVE.B	PORTNM,D1
	CMP.W	AUXQ,D1
	BNE.S	SKIP4
	MOVE.L	HSTMSGW,D0
	ROR.L	#8,D0
	MOVE.L	#0,D1
	MOVE.B	D0,D1
	LEA	AUXC,A0
	MOVE.L	#0,D6
	MOVE.W	AUXX,D6
	ADD.L	D6,A0
	MOVE.B	D1,(A0)
	ADD.L	#1,D6
	AND.L	#$3F,D6
	MOVE.W	D6,AUXX
	ANDI.W	#$7F,D1
	CMPI.W	#$3B,D1		;SEMICOLON?
	BEQ.S	SUPOUT
	CMPI.W	#$0D,D1		;CARRIAGE RETURN
	BNE.S	SKIP4
SUPOUT	MOVE.W	D6,D5
	ADD.W	#$000B,D5
	MOVE.W  D5,D0
	BSR	IFISRG2
	MOVE.B	#0,D3		;*OUT PORT 0
	MOVE.B	#8,D4		;*TO TEQUEST AUX CIRCUIT
	BSR	SLOR
	MOVE.B	D2,D0
SUPOUT1	BSR	PUTCH
	MOVE.L	#0,D0
SUPOUT2	MOVE.B	PORTNM,D0
	BSR	PUTH
SUPOUT3	BSR	PUTH	
SUPOUT4	MOVE.W	HOSTN,D0
	BSR	PUTH
	MOVE.B	D6,D0
	BSR	PUTCH
	MOVE.L	#0,D5
SUPLOP	LEA	AUXC,A0
	ADD.L	D5,A0
	MOVE.B	(A0),D0
	BSR	PUTCH
	ADD.L	#1,D5
	SUB.W	#1,D6
	BGT.S	SUPLOP
*	MOVE.W	D6,AUXQ
	BSR	ELOR
	BRA	SKIP4
*
* OMSG 19 - TEST PATTERN PROBE
*
TP	MOVE.L	#0,D0
	MOVE.B	#$1A,DAT1		;TEST PATTERN RESPONSE
	MOVE.B	#0,DAT2
	MOVE.L	HSTMSGW,D0
	MOVE.W	D0,DAT3
	MOVE.L	DAT1,D1
	BSR	WRPDP
	BSR	REAVPT
	BSR	WRPDP
	BSR	WINBAPR
	BRA	UPDOUT


SKIP6	BRA	UPDOUT


* OMSGS 1B - HOST SAD
HSTSAD	BSR	REAVPT
	ROR.L	#8,D1
	ROR.L	#8,D1
	MOVE.W	#$0A,D0
	BSR	IFISRG2
	MOVE.W	#0,D3
	MOVE.B	#3,D4
	BSR	SLOR
	MOVE.B	#0,D0
	BSR	PUTCH
	MOVE.W	D1,D0
	BSR	PUTH
	MOVE.W	#$1000,D0
	BSR	PUTH
	MOVE.B	#$91,D0
	BSR	PUTCH
	BSR	ELOR
	BRA	UPDOUT
*
* OMSGS 1C & 1D - ECHO ON/OFF
*
ECHOON	MOVE.W	#1,D5
	BRA.S	ECHO
*
ECHOFF	MOVE.W	#0,D5
ECHO	MOVE.W	#0,D6
	MOVE.L	#0,D1
	MOVE.B	PORTNM,D1
	BRA.S	STERM1
* OMSG 1E - SET TERMINAL CHARACTERISTICS
*
STERM	MOVE.L	#0,D1
	MOVE.B	PORTNM,D1
	MOVE.L	HSTMSGW,D0		;LAST 2 BYTES OF MSG
	MOVE.B	D0,D5			;LAST BYTE TO D5
	ROR.L	#8,D0			;SHIFT 8 BITS TO GET SEC-LAST BYTE
	MOVE.B	D0,D6
STERM1	*
	BSR	TBTACP
	MOVE.B	BITCHK,D0			;TEST THE BIT
	BNE.S	STERM2
	BRA	SKIP6
*
STERM2	CMP.W	#$13,D6
	BGT	MERROR
	CMP.W	#$5,D6
	BEQ.S	STERM4		; BR IF INPUT BAUD RATE
	MOVE.W	#5,D2
	MOVE.B	PORTNM,D3		;PORT #
	MOVE.B	#$B1,D4		;TYPE BYTE
	MOVE.W	#8,D0
	BSR	IFISRG2
	BSR	SLOR
	MOVE.B	D6,D0
	CMP.B	#$0F,D0
	BNE.S	NOJAP1
	MOVE.B	#$10,D0
NOJAP1	BSR	PUTCH
	MOVE.B	D5,D0
	BEQ.S	STERM3
	MOVE.L	ONEBIT,D4
	MOVE.L	#31,D2
	SUB.L	D6,D2
	BTST	D2,D4
	BEQ.S	STERM3
	MOVE.B	#-1,D0		;SET WHOLE BYTE TO ONE BITS
STERM3	BSR	PUTCH
	BSR	ELOR
	BRA	SKIP6

STERM4	LEA	IBAUD,A0
	MOVE.L	#0,D1
	MOVE.B	PORTNM,D1
	ADD.L	D1,A0
	MOVE.B	D5,(A0)		;SAVE INPUT BAUD RATE
	BRA	SKIP6

ONEBIT	DC.L	$F98EFFFF



*
* OMSG 1F - PROBE TERMINAL CHARACTERISTICS
*
PTERM	MOVE.L	#0,D1
	MOVE.B	PORTNM,D1	;PORT NUMBER
	BSR	TBTACP		;TEST BIT OF PORT #
	MOVE.B	BITCHK,D0
	BEQ	SKIP4
	MOVE.L	HSTMSGW,D0

	ROR.L	#8,D0
	MOVE.L	#0,D5
	MOVE.B	D0,D5
	CMP.W	#63,D5
	BEQ.S	PTALL		;BR IF PROBNE ALL
	CMP.W	#$13,D5
	BGT	SKIP4
	BSR.S	PTMSND
	BSR	WINBAPR
	BRA	SKIP4
*
PTALL	MOVE.W	#$13,D5	
	MOVE.L	D1,D6
PTAL2	MOVE.L	D6,D1
	BSR.S	PTMSND
	SUB.W	#1,D5
	BGE.S	PTAL2
	BSR	WINBAPR
	BRA 	SKIP4
PTMSND	MOVE.W	#4,D2		;PROCESS A PROBE REQUEST
	CMP.W	#5,D5
	BEQ.S	PTMSN1		;FAKE OUT INPUT BAUD RATE REQUEST
	MOVE.B	PORTNM,D3
	MOVE.B	#$B0,D4
	BSR	IFISRG
	BSR	SLOR
	MOVE.B	D5,D0
	CMP.B	#$0F,D0
	BNE.S	NOJAP2
	MOVE.B	#$10,D0
NOJAP2	BSR	PUTCH
	BSR	ELOR
	RTS
PTMSN1	MOVE.B	#$20,DAT1
	MOVE.L	#0,D0
	MOVE.B	PORTNM,D0
	MOVE.B	D0,DAT2
	LEA	IBAUD,A0
	ADD.L	D0,A0
	MOVE.B	(A0),DAT4
	MOVE.B	#$05,DAT3
	MOVE.L	DAT1,D1
	BSR	WRPDP
	RTS



* OMSG 21 - SET HOST NUMBER
*
SHNUM	MOVE.L	#0,D1
	MOVE.B	DAT3,D1
	CMP.W	HOSTN,D1		;SEE IF ITS BEING CHANGED ?
	BNE.S	SHNUM5			;BR IF SO
	MOVE.L	#0,D2
	MOVE.B	PORTNM,D2		;GET NMBR OF PORTS
	CMP.W	HOSTP,D2		;SEE IF IT CHANGED
	BEQ.S	SHNUM1			;BR IF NOT

SHNUM5	MOVE.B	#3,D4
	BRA.S	SHNUM2			;TELL SUP HOST IS GONE
SHNUM1	MOVE.B	#1,D4			;TELL SUP HOST IS DOWN
SHNUM2	BSR	HDOWN
	MOVE.L	#0,D2
	MOVE.B	DAT3,D2
	MOVE.W	D2,HOSTN		;UPDATE HOST #
	MOVE.B	PORTNM,D2
	MOVE.W	D2,D2
	BNE.S	SHNUM3
	MOVE.W	#48,D2			;DEFAULT NMBR OF PORTS
SHNUM3	CMP.W	#254,D2
	BLE.S	SHNUM4
	MOVE.W	#254,D2			;WE DO NOT USE PORT 0 & FF
SHNUM4	MOVE.L	#0,D2
	MOVE.B	PORTNM,D2
	MOVE.W	D2,HOSTP
	SUB.W	#3,D2
	MOVE.W	D2,MXPORT
	MOVE.B	#2,D4
	MOVE.B	D4,HSTAT		;HOST IS SHUT
	BSR	HREPRT
	BRA	SKIP4

*
*OMSG 22 - SUP CLOCK REQUEST
*
SCLKR	BRA	UPDOUT
	MOVE.B	#0,DAT2
	BSR	TGMT			;GET UPDATED GMT
	MOVE.L	GMT,D0
	MOVE.L	D0,D2
	ROL.L	#8,D2
	ROL.L	#8,D2
	MOVE.W	D2,DAT3
	MOVE.L	DAT1,D1
	BSR	WRPDP
	MOVE.L	GMT,D0
	MOVE.W	D0,DAT1
	MOVE.L	DAT1,D1
	BSR	WRPDP
	BSR	WINBAPR
	BRA	SKIP2
	

*  ROUTINE TO GET UPDATED GMT TIME
TGMT	MOVE.L	GMTA,A4
	MOVE.L	(A4),GMT
	RTS


*
*OMSGS 24,26,2A,2C,2E
*
* ---24 --  REQ FOR BLOCK OUTPUT
BOK1	MOVE.W	DAT3,BKOTCN
	BSR	REAVPT
	ROR.L	#8,D1
	AND.L	#$00FFFFFF,D1
	MOVE.L	D1,BKOTAR
	BSR	TBTOTBP
	MOVE.B	BITCHK,D0
	BEQ	NOOTBP
	BSR	SETNOIN
	BRA	BOK1MID
NOOTBP	BSR.S	SETBKO
	BRA	BOK1MID
SETBKO	MOVE.L	#0,D0
	MOVE.W	OFRPTR,D0
	MOVE.L	D0,A0
	MOVE.L	(A0),LNK1
	MOVE.W	LNK1,OFRPTR
	MOVE.W	OUSPTR,LNK1
	MOVE.W	#0,LNK2
	MOVE.B	PORTNM,LNK2+1
	MOVE.L	LNK1,(A0)
	MOVE.W	A0,OUSPTR
	RTS
	
	MOVE.L	#0,D1
	MOVE.B	PORTNM,D1
	LEA	BKOBIT,A1
	MOVE.B	#1,BLK
	BSR	SETACP
	MOVE.B	#0,BLK
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS
BOK1MID	BSR.S	BKOPOS
	BRA.S	M24MID
GETBKO	MOVE.L	(A0)+,BKOTAR
	MOVE.L	(A0)+,BKOTCN
	MOVE.L	(A0)+,BKOPTR
	RTS

BKOPOS	LEA	BKOTB,A0
	MOVE.L	#0,D0
	MOVE.B	PORTNM,D0
	MULS	HEXC,D0
	ADD.L	D0,A0
	RTS
M24MID	MOVE.W	#0,BKOLCN
	MOVE.L	#4,BKOPTR
	BSR.S	PUTBKO
	BRA.S	M24END
PUTBKO	MOVE.L	BKOTAR,(A0)+		;OUT BLK START ADR
	MOVE.L	BKOTCN,(A0)+		;OUT COUNT & COUNT LEFT
	MOVE.L	BKOPTR,(A0)+		;OUT PTR AND BYTE
	RTS	
M24END	BRA	BKFMIS	


* -----26  -----   BLOCK INPUT REQUEST
BOK2	*
	BSR	TBTBKI
	MOVE.B	BITCHK,D0
	BNE.S	BOK21
	BSR	SETBKI
	BSR	RBTNOIN
	BSR.S	GEBUPOS
	MOVE.L	#0,BKBUPU
	MOVE.L	#0,IFBKFU
	MOVE.W	#$0001,BKBUAV
	MOVE.B	PORTNM,D0
	AND.L	#$000000FF,D0
	MULU	#700,D0
	ADD.L	#$9000,D0
	MOVE.L	D0,BKBUADR
	BSR	PUBUF
	BRA	BOK2MID
BOK21	BSR	GEBUPOS
	BSR	GEBUF
	MOVE.W	BKBUPU,D0
	SUB.W	BKBUTA,D0
	BEQ.S	BOK22	
	MOVE.B	#1,BLKA
	BRA	BOK2MID
GEBUPOS	MOVEM.L	D0-D7/A1-A6,-(SP)
	LEA	BKBUTB,A0
	MOVE.L	#0,D0
	MOVE.W	INPTNM,D0
	MULS	HEXC,D0
	ADD.L	D0,A0
	MOVE.L	A0,BUAR
	MOVEM.L	(SP)+,D0-D7/A1-A6
	RTS
BOK22	MOVE.W	#0,IFBKFU
	BSR.S	PUBUF
	BRA	BOK2MID
PUBUF	MOVEM.L	D0-D7/A0-A6,-(SP)
	MOVE.L	BKBUADR,(A0)+
	MOVE.L	BKBUPU,(A0)+
	MOVE.L	IFBKFU,(A0)+
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS
GEBUF	MOVEM.L	D0-D7/A0-A6,-(SP)
	MOVE.L	(A0)+,BKBUADR
	MOVE.L	(A0)+,BKBUPU
	MOVE.L	(A0)+,IFBKFU
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS
SETBKI	MOVE.L	#0,D0
	MOVE.W	IFRPTR,D0
	MOVE.L	D0,A0
	MOVE.L	(A0),LNK1
	MOVE.W	LNK1,IFRPTR
	MOVE.W	IUSPTR,LNK1
	MOVE.W	INPTNM,LNK2
	MOVE.L	LNK1,(A0)
	MOVE.W	A0,IUSPTR
	RTS


	MOVE.B	#1,BLK
	MOVE.L	#0,D1
	MOVE.B	PORTNM,D1
	LEA	BKIBIT,A1
	BSR	SETACP			;SET PORT BIT FOR BLK INPUT
	MOVE.B	#0,BLK
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS
BOK2MID	MOVE.W	DAT3,BKITCN
	BSR	REAVPT
	ROR.L	#8,D1
	AND.L	#$00FFFFFF,D1
	MOVE.L	D1,BKITAR
	MOVE.W	#0,BKILCN
	MOVE.L	#0,BKIPTR
	BSR.S	GEINPO
	BRA.S	M26MID
GETBKI	MOVE.L	(A0)+,BKITIM
	MOVE.L	(A0)+,BKITAR
	MOVE.L	(A0)+,BKITCN
	MOVE.L	(A0)+,BKIPTR
	RTS

GEINPO	LEA	BKITB,A0
	MOVE.L	#0,D0
	MOVE.B	PORTNM,D0
	MULS	HEX16,D0
	ADD.L	D0,A0
	RTS
M26MID	BSR.S	PUTBKI
	BRA.S	M26END
PUTBKI	MOVE.L	FASTCA,A2
	MOVE.L	(A2),BKITIM
PUTBKI1	MOVE.L	BKITIM,(A0)+
	MOVE.L	BKITAR,(A0)+
	MOVE.W	BKITCN,(A0)+
	MOVE.W	BKILCN,(A0)+
	MOVE.L	BKIPTR,(A0)+
	RTS		
	
M26END  MOVE.B	BLKA,D0
	BEQ	BKFMIS
M26END1	MOVE.W	BKBUPU,D0
	SUB.W	BKBUTA,D0
	BGE	M26END4
	ADD.W	#700,D0
M26END4	MOVE.W	D0,BLKVAL
	BRA	BKIND1

* ---2A-- TERMINATE BLOCK OUTPUT
BOK3	BSR	RBTNOIN
	BSR.S	RBTBKO
	BRA.S	BOK3MID
RBTBKO	MOVE.L	#0,D0
	MOVE.W	OUSPTR,D0
	BEQ	LNKEND
	MOVE.L	D0,A0
	MOVE.L	(A0),D0
	MOVE.L	D0,LNK1
	CMP.B	PORTNM,D0
	BEQ	YESLNK
	MOVE.W	LNK1,D0
	BEQ	LNKEND
LNKLOP	MOVE.L	A0,A1
	MOVE.L	#0,D0
	MOVE.W	LNK1,D0
	MOVE.L	D0,A0
	MOVE.L	(A0),D0
	MOVE.L	D0,LNK1
	CMP.B	PORTNM,D0
	BEQ	YESLNK1
	MOVE.W	LNK1,D1
	BEQ	LNKEND
	BRA	LNKLOP
YESLNK1	MOVE.W	LNK1,D1
	MOVE.L	(A1),LNK1
	MOVE.W	D1,LNK1
	MOVE.L	LNK1,(A1)
	BRA	WAH
YESLNK	MOVE.W	LNK1,OUSPTR
WAH	MOVE.W	OFRPTR,(A0)
	MOVE.W	A0,OFRPTR
LNKEND	RTS


BOK3MID	MOVE.B	#$2D,DAT1
	MOVE.B	PORTNM,DAT2
	MOVE.L	DAT1,D1
	BSR	HTWING
	BSR	WRPDP
	BSR	WINBAPR
	BRA	BKFMIS
	

* ---2C ---TERMINATE BLOCK INPUT
BOK4	*
	BSR.S	RBTBKI
	MOVE.W	#0,INPTNM
	MOVE.B	PORTNM,INPTNM+1
	BRA.S	BOK4MID
RBTBKI	MOVE.L	#0,D0
	MOVE.W	IUSPTR,D0
	BEQ	IEND
	MOVE.L	D0,A0
	MOVE.L	(A0),D0
	MOVE.L	D0,LNK1
	CMP.B	PORTNM,D0
	BEQ	OLNK
	MOVE.W	LNK1,D0
	BEQ	IEND
OLNK0	MOVE.L	A0,A1
	MOVE.L	#0,D0
	MOVE.W	LNK1,D0
	MOVE.L	D0,A0
	MOVE.L	(A0),D0
	MOVE.L	D0,LNK1
	CMP.B	PORTNM,D0
	BEQ	OLNK1
	MOVE.W	LNK1,D1
	BEQ	IEND
	BRA	OLNK0
OLNK1	MOVE.W	LNK1,D1
	MOVE.L	(A1),LNK1
	MOVE.W	D1,LNK1
	MOVE.L	LNK1,(A1)
	BRA.S	WAH1
OLNK	MOVE.W	LNK1,IUSPTR
WAH1	MOVE.W	IFRPTR,(A0)
	MOVE.W	A0,IFRPTR
IEND	RTS


BOK4MID	MOVE.L	#0,DAT1
	MOVE.B	#$2B,DAT1
	MOVE.B	PORTNM,DAT2
	BSR	GEBUPOS
	BSR	GEBUF
	MOVE.W	IFBKFU,D0
	BNE	BOK4FUL
	BSR	GEINPO			;GET BLK INP TAB ENTRY ADR
	BSR	GETBKI			;GET TABLE ENTRY
	MOVE.W	BKILCN,DAT3		;# OF CHARS BEEN SENT
BOK4FUL	MOVE.L	DAT1,D1
	BSR	HTWING
	BSR	WRPDP
	BSR	WINBAPR
BKINGO2	MOVE.B	#0,RSSMAL	;INDICATE NO YELLOW BALL
	MOVE.W	BKBUPU,D0
	SUB.W	BKBUTA,D0
	BEQ	UPDOUT
	BGT	BKINGOO
	ADD.W	#700,D0
BKINGOO	MOVE.W	D0,BKIPTR
BKINGO1	BSR	BKINSIZ
	SUB.W	#2,INRGSP
	CMP.W	#30,INRGSP
	BLE.S	TINOK
	MOVE.W	#30,INRGSP
TINOK	MOVE.B	PORTNM,DAT2
	MOVE.L	#0,D0		;CLR DATA CNTR
	LEA	DAT3,A0		;PLACE TO PUT DATA
BKING10	BSR	GEBUDD		;GET BYTE FROM BFR
	BCS.S	BKING30		;BR IF NONE
	TST.B	D5
	BNE.S	BKING20		;BR IF DATA
	BSR	GEBUDD		;GET ESCAPED BYTE
	BCS	QGC99		;CRASH IF NONE
	TST.B	D5
	BEQ.S	BKING20		;BR IF 0 DATA
	MOVE.B	#1,RSSMAL	;INDICATE YELLOW BALL
	BRA.S	BKING30
BKING20	MOVE.B	D5,(A0)+	;SAVE IN TEMP AREA
	ADD.W	#1,D0		;INCR DATA CNTR
	CMP.W	INRGSP,D0	;SEE IF ALL THAT FITS
	BNE	BKING10		;BR IF NOT
BKING30	MOVE.B	D0,DAT1		;SAVE DATA COUNT
	BEQ.S	BKING50		;BR IF NO DATA
	OR.B	#$80,DAT1	;MAKE HOST MSG TYPE
        ADD.W   #2,D0
	LEA	DAT1,A0
BKING40	MOVE.L	(A0)+,D1	;MOVE DATA TO HOST RING
	BSR	HTWING
	BSR	WRPDP
	SUB.W	#4,D0
	BGT	BKING40
	BSR	WINBAPR
BKING50	TST.B	RSSMAL		;SEE IF TERM BY YELLOW BALL
	BEQ	BKINGO2		;DONE IF NOT
	MOVE.B	#$10,DAT1	;SEND YELLOW BALL
	MOVE.B	PORTNM,DAT2
	MOVE.L	DAT1,D1
	BSR	HTWING
	BSR	WRPDP
	BSR	WINBAPR
	BRA	BKINGO2

BKINSIZ	MOVEM.L	D0-D7/A0-A6,-(SP)
	MOVE.B	#1,DATRGZ
BKINSI1	BSR	INPDPT
	BSR	CARGSZ
	MOVE.W	INRGSP,D1
	BEQ.S	BKINSI1
	MOVE.B	#0,DATRGZ
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS

GEBUDD	MOVEM.L	D0/A0,-(SP)
	MOVE.W	BKBUTA,D0
	CMP.W	BKBUPU,D0
	BEQ.S	GEBUDD2
	MOVE.L	BKBUADR,A0
	MOVE.B	0(A0,D0.W),D5
	ADD.W	#1,D0
	CMP.W	#700,D0
	BLT.S	GEBUDD1
	MOVE.W	#0,D0
GEBUDD1	MOVE.W	D0,BKBUTA
	MOVE	#0,CCR		;CLR CARRY (DATA PRESENT)
	BRA.S	GEBUDD3
GEBUDD2	MOVE	#1,CCR		;SET CARRY (NO DATA)
GEBUDD3	MOVEM.L	(SP)+,D0/A0
	RTS


*---2E--REQ FOR BLK I/O PORTS
BOK5	MOVE.L	DAT1,D1
	BSR	WRPDP
	BSR	WINBAPR
	BRA	BKFMIS



*

*   ROUTINE TO GET TIME FROM SLOWC
TSLOWC	MOVE.L	SLOWCA,A0
	MOVE.L	(A0),SLOWC
	RTS
*
*  THESE ROUTINES ARE CALLED AFTER DOING AN INPUT

INM1	*


INM2	*
   	BSR	ELIR
	BRA	INRGLP


*  A NEEDLE REQUEST IS PROCESSED HERE
*
NEEDLE	*			;EXTERNALLY INITIATED NEW CIRCUIT
CHKRNG	*
	MOVE.W	INRGSP,D1
	CMP.W	#80,D1
	BLT	BLOKIO

	MOVE.B	#0,NNSIZ
	BSR	GETCH
	BSR	GETW
	BSR	GETH
	BSR	GETH
	MOVE.W	D0,NORNODE
	BSR	GETH
	BSR	GETH
	MOVE.W	D0,NORPORT
	BSR	GETW
	BSR	GETH
	BSR	GETCH
	MOVE.B	D0,NTID
	BSR	GETCH
	MOVE.B	D0,NSIZ
	MOVE.B	NSIZ,D0
	BEQ.S	NEE2
	MOVE.L	#0,D1
	MOVE.W	INPTNM,D1
	MOVE.B	PFULL,D0
*	BNE	PFULL2
	BSR	SETACP			;SET BIT IN PORT BIT ARRAY
	BSR	RBTALL
	BSR	IPORT			;BUMP # OF ACTIVE PORTS
PFULL2	MOVE.L	#0,D0
	MOVE.B	NTID,D0
	AND.B	#$1F,D0
	LEA	TIDBD,A0
	MOVE.B	0(A0,D0.L),D1
	LEA	IBAUD,A0
	MOVE.L	#0,D0
	MOVE.W	INPTNM,D0
	MOVE.B	D1,0(A0,D0.L)
	
	MOVE.B	#6,DAT1
	MOVE.B	D0,DAT2
	MOVE.L	DAT1,D1
	BSR	WRPDP

	BRA.S	SUDONE

NEE2	MOVE.L	#0,D0
	MOVE.B	#3,D0
DORM	BSR	ROOM
	BNE	DORM

	MOVE.W	INPTNM,D3
	MOVE.B	#$9F,D4
	BSR	SLOR
	BSR	ELOR
	BRA	INM2

PUTNE1	*
	MOVE.L	#0,D1
	MOVE.B	#$82,D1
	ROL.L	#8,D1
	MOVE.W	INPTNM,D0
	MOVE.B	D0,D1
	ROL.L	#8,D1
	RTS

SUDONE	BSR.S	PUTNE1
	MOVE.B	NTID,D1
	ROL.L	#8,D1
	MOVE.W	NORNODE,D0
	ROL.L	#8,D0
	ROL.L	#8,D0
	ROL.L	#2,D0
	ROL.L	#8,D0
	MOVE.B	D0,D1
	MOVE.L	D0,TEMPWL
	BSR	WRPDP

	BSR.S	PUTNE1
	MOVE.L	TEMPWL,D0
	ROL.L	#6,D0
	MOVE.B	D0,D1
	ROL.L	#8,D1
	MOVE.W	NORPORT,D0
	MOVE.B	D0,D1
	BSR	WRPDP

	MOVE.B	NSIZ,D2
NEEDAT	*
	MOVE.W	INBAPR,D0
	SUB.W	INPDPR,D0
	BGE.S	NNOWR
	NEG.W	D0
	SUB.W	#1,D0
	BRA.S	NNOW1
	ADD.B	#2,D2
	BRA.S	GOODRG	
NNOWR	MOVE.W	INRGSZ,D0
	SUB.W	INBAPR,D0
NNOW1	MULU	FOUR,D0
	CMP.W	#32,D0
	BLE.S	NEELNOK
	MOVE.W	#32,D0
NEELNOK	ADD.B	#2,D2
	MOVE.L	#0,D3
	MOVE.B	D2,D3
	CMP.W	D3,D0
	BLT.S	GOODRG1
	MOVE.B	#0,NNSIZ
	BRA.S	GOODRG
GOODRG1	SUB.W	D0,D3
	MOVE.B	D3,NNSIZ
	MOVE.B	D0,D2
GOODRG	BSR.S	PUNED
	MOVE.B	NNSIZ,D0
	BEQ.S	NEES2
	MOVE.B	NNSIZ,D2
	BRA.S	NEEDAT
	BSR.S	PUNED
NEES2	MOVE.B	PFULL,D0
	BNE	SSBP
NEESTOP	BRA	INM2

SSBP	MOVE.L	#0,D1
	MOVE.W	INPTNM,D1
	BSR	RBTACP
	BSR	DPORT
	BSR	IFISRG
	MOVE.B	INPTNM+1,D3
	MOVE.B	#$9F,D4
	BSR	SLOR
	BSR	ELOR

	BSR	HTWING
	MOVE.B	#$0B,DAT1
	MOVE.B	INPTNM+1,DAT2
	MOVE.L	DAT1,D1
	BSR	WRPDP
	BRA	INM2

	


PUNED	MOVE.B	D2,D0
	ADD.B	#$7E,D0
	MOVE.B	D0,DAT1
	MOVE.W	INPTNM,D0
	MOVE.B	D0,DAT2
	BSR	GETCH
	MOVE.B	D0,DAT3
	CMP.B	#3,D2
	BEQ.S	NDDONE
	BSR	GETCH
	MOVE.B	D0,DAT4
	CMP.B	#4,D2
	BEQ.S	NDDONE
	MOVE.L	DAT1,D1
	BSR	WRPDP
	SUB.B	#4,D2
PUNED1	MOVE.B	#4,D6
	LEA	DAT1,A4	
PUNED2	BSR	GETCH
	MOVE.B	D0,(A4)+
	SUB.B	#1,D2
	BEQ.S	NDDONE
	SUB.B	#1,D6
	BNE.S	PUNED2
	MOVE.L	DAT1,D1
	BSR	WRPDP
	BRA.S	PUNED1
NDDONE	MOVE.L	DAT1,D1
	BSR	WRPDP
	RTS

	




*
TIDBD	DC.B	5,2,2,2,2,1,1,1	;GET BAUD RATE FROM TID

	DC.B	6,7,0,5,5,5,5,0

	DC.B	10,5,5,11,12,5,5,5


	DC.B	5,5,5,5,5,5,5,5 


*

IM8	BSR	GETCH
	BSR	GETH
IM4	BSR	ELIR
	BRA	INRGLP

ISACT	BSR	GETCH
	BSR	GETW
	BRA.S	IM4


ISP	MOVE.L	#0,A0
	LEA	ISPTAB,A0
	SUB.L	#$9F,A0
	MOVE.L	#0,D1
	MOVE.B	INTYBT,D1
	MOVE.B	0(A0,D1.L),DAT1
	CMP.B	#$A0,D1
	BEQ	YESA0
	CMP.B	#$A1,D1
	BEQ	YESA1
	CMP.B	#$9F,D1
	BNE.S	NOZAP
	MOVEM.L	D0-D7/A0-A6,-(SP)
	MOVE.L	#0,D1
	MOVE.B	PORTNM,D1
	BSR	TBTACP
	MOVE.B	BITCHK,D0
	BEQ.S	NODP1
	BSR	DPORT
NODP1	BSR	RBTACP
	BSR	RBTALL
	BRA.S	RBTALL1
RBTALL	*
	BSR	RBTNOIN
	BSR	RBTOTBP
	BSR	RBTBKO
	BSR	RBTBKI
	LEA	TRALMT,A0
	MOVE.L	#0,D0
	MOVE.W	INPTNM,D0
	MOVE.B	#157,0(A0,D0.L)
	RTS
RBTALL1	*
	MOVEM.L	(SP)+,D0-D7/A0-A6
NOZAP	*
	MOVE.B	INPTNM+1,DAT2
	MOVE.L	DAT1,D1
	BSR	WRPDP
	BRA	INM2

YESA0	BSR	SETOTBP
	BSR	TBTBKO
	MOVE.B	BITCHK,D0
	BEQ	NOZAP
	BSR	RBTBKO
	BSR	SETNOIN
	BRA	NOZAP

YESA1	BSR	RBTOTBP
	BSR	TBTNOIN
	MOVE.B	BITCHK,D0
	BEQ	NOZAP
	BSR	SETBKO
	BSR	RBTNOIN
	BRA	NOZAP



*
ISPTAB	DC.B	11,8,9,10,0,0,0,12,13

	DC.B	0,0,14,15,16,17,47

*
GRAY	MOVE.B	#0,D2
	BRA.S	BLACK1
BLACK	MOVE.B	#$FF,D2

BLACK1	MOVE.B	D2,DAT3
	MOVE.B	#$15,DAT1
	MOVE.B	INPTNM+1,DAT2
	MOVE.L	DAT1,D1
	BSR	WRPDP
	BRA	INM2


ITERM	MOVE.B	#$20,DAT1		;TERMINAL CHARACTERISTICS RESPONSE
	MOVE.B	INPTNM+1,DAT2
	BSR	GETCH			;PARAMETER NUMBER
	CMP.B	#$10,D0
	BNE.S	NOJAP
	MOVE.B	#$F,D0
NOJAP	MOVE.B	D0,DAT3
	BSR	GETCH
	MOVE.B	D0,DAT4			;VALUE
	MOVE.L	DAT1,D1
	BSR	WRPDP
	BRA	INM2


LOGFAL	MOVE.W	#-1,AUXX		;ALLOW ANOTHER AUX ATTEMPT
	MOVE.B	#$17,DAT1
	MOVE.W	AUXQ,D0
	MOVE.B	D0,DAT2			;AUX CIRCUIT KEY
	BSR	GETCH
	MOVE.B	D0,DAT3			;ERROR CODE
	MOVE.B	D0,D0
	BNE.S	NOTZE
	MOVE.B	#7,DAT3			;CONVERT 0 TO 7
NOTZE	MOVE.L	DAT1,D1
	BSR	WRPDP
	BRA	INM2


ILOG	BSR	GETCH
	BSR	GETW
	BSR	GETH
	MOVE.L	#0,D1
	MOVE.B	INPTNM+1,D1
	MOVE.B	PFULL,D0
	BNE	PFULL1
	BSR	SETACP
	BSR	RBTALL
	BSR	IPORT
PFULL1	MOVE.W	#-1,AUXX
	MOVE.B	#7,DAT1
	MOVE.B	INPTNM+1,DAT2
	MOVE.W	AUXQ,D0
	MOVE.B	D0,DAT3
	MOVE.L	DAT1,D1
	BSR	WRPDP

	MOVE.B	#$17,DAT1
	MOVE.W	AUXQ,D1
	MOVE.B	D1,DAT2
	MOVE.W	#0,DAT3 
	MOVE.L	DAT1,D1
	BSR	WRPDP
	MOVE.B	PFULL,D0
	BEQ	HNPOT
	BSR	IFISRG
	MOVE.B	INPTNM+1,D3
	MOVE.B	#$9F,D4
	BSR	SLOR
	BSR	ELOR
	BSR	HTWING
	MOVE.B	#$0B,DAT1
	MOVE.B	INPTNM+1,DAT2
	MOVE.L	DAT1,D1
	BSR	WRPDP
	
HNPOT	BRA	INM2

*   B9 - SET XMT LIMIT
SMTLMT	BSR	GETCH
	SUB.B	#5,D0
	AND.B	#$FC,D0
	ADD.B	#2,D0
	LEA	TRALMT,A0
	MOVE.L	#0,D1
	MOVE.W	INPTNM,D1
	MOVE.B	D0,0(A0,D1.L)
	BRA	INM2

*
*  PROCESS PORT-ZERO MESSAGES
*
IPZ	BSR	GEBHLN			;LEN OF BH MSG
	MOVE.W	INRGSP,D1		;RING SPACE
	CMP.W	BHMGL,D1		;BIGGER THAN BH L
	BLT	BLOKIO			;NO, BR TO B.LOKIO
	MOVE.L	#0,D0
	MOVE.B	INTYBT,D0
   	CMPI.W	#$11,D0		:SEE IF VALID PORT ZERO MESSAGE
	BLT	IPZDSP			;BR IF SO 
IPZERR	BRA	ISMGER			;CRASH, BAD ISIS INPUT MSG
IPZDSP	LEA	IPZTAB,A0
	MOVE.L	#0,D0
	MOVE.B	INTYBT,D0
	ADD.L	D0,D0
	MOVE.L	#0,A1
	MOVE.W	0(A0,D0.L),A1

	JMP	(A1)			;GO HANDLE PORT ZERO MSG
	
*
SUPTAK	MOVE.W	#-1,AUXX
	MOVE.B	#5,DAT1
	MOVE.B	#0,DAT2
	MOVE.L	DAT1,D1
	BSR	WRPDP
	BRA	INM2
*
IPTIME	MOVE.B	#$23,DAT1	;PASS IN THE SUP TIME
	MOVE.B	#0,DAT2		;PORT IS 0
	BSR	GETCH		;SKIP ONE BYTE
	BSR	GETW
	MOVE.L	D0,ISISMSG
	ROL.L	#8,D0
	ROL.L	#8,D0
	MOVE.W	D0,DAT3
	MOVE.L	DAT1,D1
	BSR	WRPDP		;WRITE TO PDPD RING
	MOVE.L	ISISMSG,D0
	MOVE.W	D0,DAT1
	MOVE.L	DAT1,D1
	BSR	WRPDP
	BRA	INM2
*
AUXERR	BSR	GETCH
	BSR	GETH
	MOVE.W	#-1,AUXX
	MOVE.B	#$17,DAT1
	MOVE.W	AUXQ,D1
	MOVE.B	D1,DAT2
	BSR	GETCH
	MOVE.B	D0,DAT3
	MOVE.B	D0,D0
	BNE.S	AUXNO0
	MOVE.B	#7,DAT3
AUXNO0	MOVE.L	DAT1,D1
	BSR	WRPDP
	BRA	INM2


HSTUNA	BSR	GETCH		;HOST UNACCEPTABLE,IGNORE FOR NOW
	BSR	GETH
	BSR	GETCH
	BRA	INM2
*
*
* HDOWN - REPORT HOST DOWN OR GONE
*    D4 = 1 FOR DOWN, 3 FOR GONE
*
HDOWN	MOVE.L	#0,D6
	MOVE.W	HSTAT,D6		;CLEAR HOST KEY
	AND.W	#$FB00,D6
	MOVE.W	D6,HSTAT
	MOVE.L	#0,D6
	MOVE.B	HSTAT,D6	;RTRN IF GOING DOWN AND ALREADY DOWN OR GONE
	AND.L	#$000000FF,D4
	AND.L	D4,D6		;*OR IF GOING GONE AND ALREDY GONE
	EOR.L	D4,D6						
	BEQ.S	HDN3
HDOWN9	*
	MOVE.B	D4,HSTAT	
	BSR	HREPRT
	MOVE.W	#$FF,INPTNM
HDN1	MOVE.W	INPTNM,D1
	MOVE.B	INPTNM+1,PORTNM
	BSR	TBTACP		;TEST IF PORT IS ACTIVE ?
	MOVE.B	BITCHK,D0
	BEQ	HDN2
	BSR	RBTACP		;DROP ANY ACTIVE PORT
	BSR	RBTALL
	BSR	IFISRG 
	MOVE.B	PORTNM,D3		;PORT #
	MOVE.B	#$9F,D4		;ZAPPER
	BSR	SLOR
	BSR	ELOR
HDN2	SUB.W	#1,INPTNM
	BGT	HDN1
HDN3	RTS
*
IFISRG	MOVEM.L	D0-D2,-(SP)
	MOVE.W	#4,D0
	BRA	IFISRG3
IFISRG2	MOVEM.L	D0-D2,-(SP)
	AND.W	#$00FF,D0
IFISRG3	BSR	ROOM
	BNE.S	IFISRG3
	MOVEM.L	(SP)+,D0-D2
	RTS


* EMPTY - EMPTY OUT ISIS INPUT RING
*
EMPTY	BSR	LOOK		;SEE WHAT'S NEXT IN RING
	BNE.S	GOON1
	RTS			;RING EMPTY, RET							
GOON1	MOVE.W	D3,D0
	BEQ.S	EMP2		;BR IF INTRA-NODE MSG
	MOVE.W	D4,D4 		;TEST MSG TYPE
	BEQ.S	EMP3		;BR IF NEEDLE
	CMP.W	#$9E,D4		;SEE IF DATA MSG
	BGE.S	EMP1		;BR IF NOT
	MOVE.L	#0,D0
	MOVE.B	D4,D0
	BRA	EMP1C		;GO FLUSH MSG
*
EMP1	CMP.W	#$9E,D4		;SEE IF IN ISIS INPUT TABLE
	BLT	ISMGER
	CMP.W	#$C1,D4
	BGE	ISMGER

	SUB.W	#$9E,D4
	MOVE.L	#0,D2
	MOVE.W	D4,D2
	LEA	IMSSZ,A0
	MOVE.B	0(A0,D2.L),D0	;GET LENGTH OF MSG
EMP1C	BRA.S	EMP4
*
EMP2	CMP.W	#$0E,D4		;SEE IF IN TABLE
	BGE	ISMGER
	CMP.W	#$08,D4
	BNE.S	EMP21
	BRA	ISMGER
	ADD.L	#7,D7
	BSR	GETCH
	BRA.S	EMP4
EMP21	LEA	IPZSZ,A0
	MOVE.L	#0,D2
	MOVE.B	D4,D2
	MOVE.B	0(A0,D2.L),D0	;GET LENGTH OF MSG
*
EMP4	BSR	FLUSH		;REMOVE MSG FROM RING	
	BRA	EMPTY		;GO GET NEXT MSG
*
EMP3	MOVE.L	#3,D0		;NEEDLE. SEND ZAPPER
	MOVE.B	#$9F,D4		;ZAPPER
	BSR	IFISRG
	BSR	SLOR
	BSR	ELOR
	BSR	GETCH		;GET LENGTH OF NEEDLE
	BRA	EMP4
*
* HREPRT - REPORT HOST STATUS TO SUP
*
HREPRT	MOVE.W	#$0C,D0
	BSR	IFISRG2
	MOVE.W	#0,D3
	MOVE.B	#$10,D4
	BSR	SLOR
	MOVE.B	D2,D0
	BSR	PUTCH
	MOVE.L	HOSTN,D0
	BSR	PUTW		;GET HOST NUMBER AND NUMBER OF PORTS
	MOVE.L	#0,D0		;MAKE REL HOST # ZERO
	MOVE.W	HSTAT,D0	;GET STATUS
	BSR	PUTW
	MOVE.W	#$0091,D0
	BSR	PUTH
	BSR	ELOR
	RTS
*
* IPORT - INCREMENT NUMBER OF PORTS
*
IPORT	MOVEM.L	D0-D7/A0-A6,-(SP)
	MOVE.W	NPORTS,D6
	ADD.W	#1,D6
	MOVE.W	D6,NPORTS
	CMP.W	MXPORT,D6
	BGT.S	IPORT1
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS
IPORT1	MOVE.W	#0,D5
	MOVE.B 	#1,PFULL
	BRA	DPORT1
*
* DPORT - DECREMENT NUMBER OF PORTS
*
DPORT	MOVEM.L	D0-D7/A0-A6,-(SP)	
DPORT0	MOVE.L	#0,D6
	MOVE.W	NPORTS,D6
	SUB.W	#1,D6
	MOVE.W	D6,NPORTS
	CMP.W	MXPORT,D6
	BEQ.S	DPORT2
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS
DPORT2	MOVE.W	#1,D5
	MOVE.B	#0,PFULL
DPORT1	MOVE.W	#$0A,D0
	BSR	IFISRG2
	MOVE.W	#0,D3
	MOVE.B	#$0A,D4
	BSR	SLOR
	MOVE.B	D2,D0
	BSR	PUTCH
	MOVE.W	HOSTN,D0
	BSR	PUTH
	MOVE.W	D5,D0
	BSR	PUTH
	MOVE.W	#0,D0
	BSR	PUTH
	BSR	ELOR
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS

BLKYEL	MOVE.B	INPTNM+1,PORTNM
	BSR	GEINPO
	BSR	GETBKI
	BSR	GEBUPOS
	BSR	GEBUF
	MOVE.W	IFBKFU,D0
	BEQ.S	BLKYEL1
	MOVE.L	BKBUADR,A0	;SET UP BFR PTR
	MOVE.L	#0,D0
	MOVE.W	BKBUPU,D0
	ADD.L	D0,A0
	MOVE.L	#0,D0		;PUT ESCAPE BYTE IN BFR
	BSR	PUTBFR
	MOVE.L	#$AC,D0		;PUT YELLOW BALL IN BFR
	BSR	PUTBFR
	MOVE.L	BUAR,A0		;SAVE NEW BFR PTR
	BSR	PUBUF
	BRA	INM2

BLKYEL1	MOVE.B	#$28,DAT1
	MOVE.B	INPTNM+1,DAT2
	MOVE.W	BKILCN,DAT3
	MOVE.L	DAT1,D1
	BSR	HTWING
	BSR	WRPDP
	BSR	GEBUPOS
	BSR	GEBUF
	MOVE.W	#1,IFBKFU
	BSR	PUBUF
	BRA	ISP

	
*
*
IMESS	BSR	GEBHLN
	BSR	TBTBKI
	MOVE.L	#0,D0
	MOVE.B	INTYBT,D0
	MOVE.B	BITCHK,D1
	BEQ.S	IMESS1
	CMP.W	#$AC,D0
	BEQ	BLKYEL
IMESS1	MOVE.W	INRGSP,D1
	CMP.W	BHMGL,D1
	BLT	BLOKIO
	CMP.W	#$9E,D0
	BLT	ISMGER			;BAD ISIS INPUT MSG
	CMP.W	#$C1,D0
	BGE	ISMGER			;BAD ISIS INPUT MSG

ISRGOK	SUB.L	#$009E,D0
	LEA	IMSTAB,A0
GETINX	MULU	FOUR,D0
	ADD.L	D0,A0
	MOVE.L	(A0),A1
OKJUMP	JMP	(A1)


WRPATCH	MOVEM.L	D0-D7/A0-A6,-(SP)
	MOVE.L	A20000,A0
	MOVE.L	#0,D5
	MOVE.W	VARPTR,D5
	MOVE.L	D5,(A0)+
	MOVE.L	D1,(A0)+
	MOVE.L	A0,D6
	CMP.L	#$3FFE0,D6
	BLT	WPOK
	MOVE.L	#$30000,D6
WPOK	MOVE.L	D6,A20000
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS

WRPATW	MOVEM.L	D0-D7/A0-A6,-(SP)
	MOVE.L	A20000,A0
	MOVE.L	#-1,D5
	MOVE.W	INBAPR,D5
	MOVE.L	D5,(A0)+
	MOVE.L	D1,(A0)+
	MOVE.L	A0,D6
	CMP.L	#$3FFE0,D6
	BLT	WPOKW
	MOVE.L	#$30000,D6
WPOKW	MOVE.L	D6,A20000
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS

	

PATCH1	MOVE.L	#0,D0	
	MOVE.W	P10ADR,D0
	MULU	FOUR,D0
	MOVE.L	#0,A0
	MOVE.L	D0,A0
	ADD.L	#$7000,A0
	MOVE.L	(A0),D1
	MOVE.L	D1,DAT1
	MOVEM.L	(SP)+,D0/D2-D7/A0-A6
	RTS
PATCH2	MOVE.L	#0,D0
	MOVE.W	P10ADR,D0
	MULU	FOUR,D0
	MOVE.L	D0,A0
	ADD.L	#$7000,A0
	MOVE.L	D1,(A0)
	MOVEM.L	(SP)+,D0/D2-D7/A0-A6
	RTS


PATCH3	MOVE.L	#0,D0
	MOVE.W	VARPTR,D0
	MULU	FOUR,D0
	MOVE.L	D0,A0
	ADD.L	#$8000,A0
	MOVE.L	(A0),D1
	MOVE.L	D1,DAT1
	MOVEM.L	(SP)+,D0/D2-D7/A0-A6
	RTS

PATCH4	MOVE.L	#0,D0
	MOVE.W	INBAPR,D0
	MULU	FOUR,D0
	MOVE.L	D0,A0
	ADD.L	#$9000,A0
	MOVE.L	D1,(A0)
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS

PATCH5	MOVE.L	#0,D0
	MOVE.W	BKOPTR,D0
	MULU	FOUR,D0
	ADD.L	#$10000,D0
	MOVE.L	D0,A0
	MOVE.L	(A0),D1
	MOVE.L	D1,DAT1
	MOVEM.L	(SP)+,D0/D2-D7/A0-A6
	RTS

PATCH6	MOVE.L	#0,D0
	MOVE.W	BKIPTR,D0
	MULU	FOUR,D0
	ADD.L	#$11000,D0
	MOVE.L	D0,A0
	MOVE.L	D1,(A0)
	MOVEM.L	(SP)+,D0-D7/A0-A6
	RTS




	org	$7c00

*	D0 is the high order 32 bits to write to pdp-10
*	D1 last 4 bits are the low order 4 bits to write to 10
*	D2 is the start addr of the test
*	D3 is the ending addr of the test
*	D4 is the counter of mismatch between read and write
*	D5 is the high ordser 32 bits read from 10's memory
*	D6 last 4 bits are the low order 4 bits read from 10

STARTES	LEA	DEXCO,A0
	TST.W	(A0)
	MOVE.B	#0,BLK
	MOVE.L	#0,D4		;INITIALIZE THE MISMATCH COUNTER
STATE12	MOVEM.L	D0-D4,-(SP)
	MOVE.W	D2,P10ADR	;move in addr(only half-word long)
	MOVE.L	D0,P10DAH	;first 32 bits of data
	AND.B	#$0F,D1		:only need last 4 bits
	MOVE.B	D1,P10DLL	;last 4 bits of data
	BSR	WR10R		;write it to 10. memory
	MOVE.L	#0,P10DAH	;clear out read area
	MOVE.B	#0,P10DLL
	BSR	RD10R		;read it back from 10's memory
	MOVEM.L	(SP)+,D0-D4
	MOVE.L	#0,D5
	MOVE.L	#0,D6
	MOVE.L	P10DAH,D5	;first 32 bits read rom 10
	MOVE.B	P10DLL,D6
	AND.B	#$0F,D1
	CMP.L	D5,D0
	BNE	SUB7		;go mismatch routine
	CMP.B	D6,D1
	BNE	SUB7		;go mismatch routine if not =
	MOVE.L	#0,D7		;no mismatch add 0 to counter(d4)
	BRA	NO77
SUB7	MOVE.L	#1,D7		:add 1 to counter d4 on mismatch
NO77	ADD.L	D7,D4		;add to mismatch counter
	ADD.W	#1,D2		;bump to next addr in 10 memory
	CMP.L	D2,D3		;if biggert than end addr
	BGE	STATE12		;no go another loop
NOMLOP	MOVE.L	A1,A1
	BRA	NOMLOP		;just dummy loop






	ORG	$7D00
CONWRT	MOVE.W	D2,P10ADR
	MOVE.B	#1,DIAG
	MOVE.L	D0,P10DAH
	AND.B	#$0F,D1
	MOVE.B	D1,P10DLL
WRTERR	LEA	DEXCO,A0
	TST.W	(A0)
	BSR	WR10R
	MOVE.W	#100,D5
WRERL	SUB.W	#1,D5
	BNE.S	WRERL
	BRA.S	WRTERR





	ORG	$7E00
	MOVE.B	#1,DIAG
	MOVE.W	D2,P10ADR
REDERR	LEA	DEXCO,A0
	TST.W	(A0)
	BSR	RD10R
	MOVE.W	#100,D5
RELOP	SUB.W	#1,D5
	BNE.S	RELOP
	BRA	REDERR


	END



	



	
Ju