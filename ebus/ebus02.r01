: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET, Incorporated. The recipient, by receiving  **
: **  this program listing, agrees that neither this listing nor  **
: **  the   information  disclosed herein nor any  part  thereof  **
: **  shall be  reproduced or transferred to other documents  or  **
: **  used  or  disclosed to others for manufacturing or for any  **
: **  other   purpose except as specifically authorized in  wri-  **
: **  ting by  TYMNET, Incorporated.                              **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     2.0             Release Date 10/15/85    **
: **                                                              **
: **  File Name          IPI SLOT INTERFACE                       **
: **                                                              **
: **  File Description   ALLOWS ISIS INTERFACE TO THE 'IPI' BOARD **
: **  THAT RUNS 'EBUS' SOFTWARE, WHICH IS THE BASE FOR PDP10.     **
: **  REQUIRES ISIS 7.01.                                         **
: **                                                              **
: **  File Abstract      :                                        **
: **                                                              **
: ******************************************************************
: **                CONFIGURATION SPECIFICATION                   **
: **                                                              **
: **  Core Memory Requirement: 265K                               **
: **                                                              **
: **  Basic Code Size: 9K                                         **
: **                                                              **
: **  Additional Code Size per Tymfile Parameter Unit:            **
: **            EBDUMP:  256K                                     **
: **                                                              **
: **  Estimated Code Growth for Next 12 Months: none              **
: **                                                              **
: **  Hardware/Firmware Requirements:                             **
: **                                                              **
: **  Other Software Requirements: MUST BE USED WITH ISIS 7.01    **
: **                                                              **
: **  Slot Limitations:  Supports single PDP-10 Host              **
: **                                                              **
: ******************************************************************
: **                   DOCUMENT SPECIFICATION                     **
: **                                                              **
: **  Software Requirements Specification Number:                 **
: **                                                              **
: **  Functional Specification Number           :                 **
: **                                                              **
: **  Test Suite Number                         :                 **
: **                                                              **
: ******************************************************************
: **                      MAINTENANCE HISTORY                     **
: **                                                              **
: **  Ver   Date    By   PIR/NSR         Reason for Change        **
: ** ----- -------- ---  -------- ------------------------------  **
: **                                                              **
: ******************************************************************

	SUBTTL	ISIS Assembly Switch Definitions	- START.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************

	REMARK %Start.Lib Version 
SREV	EQ	0;	NUMBER SREV; REMARK .0
SLEV	EQ	05;	NUMBER SLEV

: Version 0.05 01/19/83 MDS
:	Delete Remark regarding incompatibility with ISIS 5.00
: Version 0.04 03/12/82  MDS
:	Add new fields to SYS SVC Sub-operand definitions,
:	per ISIS2 v.5.01
: Version 0.03 03/08/82  MDS
:	Add new fields to Seg F table per ISIS 5.01
:	(note - Start.lib ** NOT ** compatible with ISIS 5.00
:	because SLCNT and LCX were reversed in 5.00 )
: Version 0.02  12/08/81  MDS
:	Add QSTART remark, add I/O sub-ops for mother board.
:	Delete ISIS (one) code - force ISIS2
: Version 0.01  01/08/81  MDS
:	Correct relative addresses of local clock index and values.

	RA	0		:	START.LIB

:	this file should always be assembled IMMEDIATELY AFTER the *.TYM file


			:Note - ISIS 1 is no longer supported

:			ISIS - II Version
:
:	The following parameters should be defined in the *.TYM file:
:	MAXHST	maximum number of hosts associated with this interface slot
:	MAXPRT	number of highest port associated with this interface slot
:			(number of ports - 1)
:	IRSIZE	 number of bytes to provide for input ring, from dispatcher
:	ORSIZE	 number of bytes to provide for output ring, to dispatcher
:	CNTRL	dispatcher control bits

:	the following symbols MUST be defined SOMEWHERE in the assembly:
:	IRING	the start of the input ring, from dispatcher
:	ORING	the start of the output ring, to dispatcher
:	ENTRY	the location of the first instruction to be executed

:	the following symbols are defined for convenience:
:	RATE	the rate of the fast clock (ticks/second)
:	NRATE	word containing the value of RATE
:	FASTC	word containing  realtime fast clock
:	SLOWC	word containing  realtime slow clock (1-second)
:	GMT	word containing GMT clock
:	TEMPER	byte containing machine temperature
:	VOLTS	byte containing machine voltage
:	VERNO	halfword containing ISIS version number
:	WWVBT	word containing WWVB time
:	HOSTX	halfword containing kernel host number
:	NODEX	halfword containing kernel node number
:	LCX	halfword, offset of local clocks within seg F
:	SLCNT	halfword, number of slots known to ISIS dispatcher
:	LCT	halfword, pointer to crash table
:	MAXP0	halfword, highest port 0 msg. #
:	MAXMSG	halfword, highest msg # for all other ports
:	LP0LST	halfword, length table for port 0 msgs.
:	LENGTH	length table for msgs. all other ports
:	R0-R15	symbolic names for the registers
:	SEGn	the start address of segment n (0-0E)
:	HOSTS	halfword array of host numbers as known by the dispatcher (R/O)
:	PORTS	halfword array of ports/host as known by dispatcher (R/O)
:
:	the following symbols MAY be defined. defaults used otherwise
:	APROTn	protection byte for area n. default area 1 write protected,
:		other areas execution protected.
:	HOSTn	host number for host position n. default none.
:	HPRTn	number of ports for host position n. default none.
:	DSTART	user DDT execution start address. default none.
:	QSTART  user DDT query handler start address, default none.
:	FPANEL	halfword cell for front panel display. default cell allocated
:	FRISIS	bit array for input backpressure (1=no backpressure) default
:			array allocated.
:	TOISIS	bit array for output backpressure (1=no backpressure) default
:			array allocated.
:	VERSION	version number for slot code (default zero)
:	PCTTBL	bit array for indicating terminating character for project
:			code. (default none)
:	REVLEV	revision level for slot code (default zero)
:	A.DATA	segment number for data area. Default 0
:	A.CODE	segment number for code area. Default 1
:	A.BDAT	segment number for based data. Default 2.
:	A.RING	segment number for rings. Default 2.
:	A.BUFF	segment numberfor buffer(let)s. Default 2.
:
:	in addition most SVC calls have been assigned symbolic names.

	GL	FASTC,SLOWC,RATE,NRATE,GMT,TEMPER,VOLTS,VERNO,HOSTX,NODEX,SLOTNO
	GL	R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15
	GL	IRSIZE,ORSIZE,CNTRL
	GL	ENTRY,IRING,ORING,LCX
	GL	VERREV,COREST,FPANEL,HOSTS,PORTS,FRISIS,TOISIS

:	DEFINE SEG 15d LOCATIONS
RATE	EQ	$A 600		:clock rate, ticks per second
NRATE	EQ	0F0000		:word, contains RATE
FASTC	EQ	0F0004		:word, contains fast clock (ticks)
SLOWC	EQ	0F0008		:word, contains slow clock (seconds)
GMT	EQ	0F000C		:word, contains GMT (seconds since 1/1/72)
TEMPER	EQ	0F0010		:byte, contains machine temperature
VOLTS	EQ	0F0011		:byte, contains machine voltage
VERNO	EQ	0F0012		:halfword, ISIS version number
WWVBT	EQ	0F0014		:word, WWVB time (format ??)
HOSTX	EQ	0F0018		:halfword, kernel host number
NODEX	EQ	0F001A		:halfword, kernel node number

: Local clocks displacements

LCX	EQ	0F001C	:1/2 word, contains offset of LOCLKS within seg F
: LOCLKX and LOCLKS must be referenced by the pointer in LCX
:LOCLKX	EQ	LOCLKS-2 :1/2 word, index to current clock from LOCLKX
:LOCLKS	EQ	Seg F + contents of LCX
			:clocks for slots, array of word entries per slot
			:1st halfword is user ticks, 2nd is sys ticks for slot

SLCNT	EQ	0F001E		:halfword, number of dispatcher slots
LCT	EQ	0F0020		:halfword, pointer to crash table
MAXP0	EQ	0F0022		:halfword, max. msg. # for port 0
MAXMSG	EQ	0F0024		:halfword, max. msg #, all non-0 ports
LP0LST	EQ	0F0026		:halfword, offset to port 0 msg length table
LENGTH	EQ	0F0028		:byte table, lengths of non-0 port msgs

:	Define Registers
R0	EQ	0
R1	EQ	1
R2	EQ	2
R3	EQ	3
R4	EQ	4
R5	EQ	5
R6	EQ	6
R7	EQ	7
R8	EQ	8
R9	EQ	9
R10	EQ	$A 10
R11	EQ	$A 11
R12	EQ	$A 12
R13	EQ	$A 13
R14	EQ	$A 14
R15	EQ	$A 15

:	AREA DEFINITIONS
	GL	A.DATA,A.CODE,A.BDAT,A.RING,A.BUFF
:
  IF	\A.DATA
  ELSE
A.DATA	EQ	0	:DEFAULT DATA AREA
  EI

  IF	\A.CODE
  ELSE
A.CODE	EQ	1	:DEFAULT CODE AREA
  EI

  IF	\A.BDAT
  ELSE
A.BDAT	EQ	2	:DEFAULT BASED DATA AREA
  EI

  IF	\A.RING
  ELSE
A.RING	EQ	2	:DEFAULT RING AREA
  EI

  IF	\A.BUFF
  ELSE
A.BUFF	EQ	2	:DEFAULT BUFFER AREA
  EI

:	SVC DEFINITIONS
:
	GL	DISMIS,FASTD,SYS,RSTRT.,CFGND.,DBGON.,DBGOF.,TSTDB.
	GL	FREEZ.,THAW.,TFREZ.,RDDTR.,RDDTP.,RBREG.,RBPSD.
	GL	RFREG.,RFPSD.,RDMAC.,RBMAC.,RFMAC.,SET1P.,SETP.,SETBE.
	GL	SETFE.,IO,IOQRY.,CSYNI.,CSYNO.,FSYNO.,TIISC.
	GL	CSUPF.,CSUPR.,FREZS.,THAWS.,ALARM.,RSCLK.,SSCLK.,SUDIA.
	GL	SFREZ.,HALT.,SHALT.
	GL	TIISI.,CASYN.,CPRT.,FPRT.,CSIO.,CMBRD.,FMBIN.,FMBOT.
	GL	SHARE,K.IN,K.OUT,KIO,BDISC,SDISC
:
DISMIS	EQ	0	:DISMISS SVC
FASTD	EQ	1	:FAST DISMISS SVC
:
SYS	EQ	2	:SYS SVC

:	SYS SVC SUBOPERANDS
RSTRT.	EQ	0	:Restart syscall
CFGND.	EQ	1	:Connect foreground syscall
DBGON.	EQ	2	:Debug mode ON syscall
DBGOF.	EQ	3	:Debug mode OFF syscall
TSTDB.	EQ	4	:Test debug mode syscall
FREEZ.	EQ	5	:Freeze slot syscall
THAW.	EQ	6	:Thaw slot syscall
TFREZ.	EQ	7	:Test freeze syscall
RDDTR.	EQ	8	:Read DDT register syscall
RDDTP.	EQ	9	:Read DDT PSD syscall
RBREG.	EQ	0A	:Read background register syscall
RBPSD.	EQ	0B	:Read background PSD syscall
RFREG.	EQ	0C	:Read foreground register syscall
RFPSD.	EQ	0D	:Read foreground PSD syscall
RDMAC.	EQ	0E	:Read DDT MAC register syscall
RBMAC.	EQ	0F	:Read background MAC register syscall
RFMAC.	EQ	10	:Read foreground MAC register syscall
SET1P.	EQ	11	:Set 1 protect syscall
SETP.	EQ	12	:Set protection syscall
SETBE.	EQ	13	:Set background execution addr syscall
SETFE.	EQ	14	:Set foreground execution addr syscall
LMAC.	EQ	15	:Set up MAC from CTA (DDT only)
CSUPF.	EQ	16	:Check SUP freeze state
CSUPR.	EQ	17	:Check SUP run Q state
FREZS.	EQ	18	:Freeze the SUP
THAWS.	EQ	19	:Thaw the SUP
ALARM.	EQ	1A	:Set/Clear alarm
RSCLK.	EQ	1B	:Read the super-clock
SSCLK.	EQ	1C	:Set the super-clock
SUDIA.	EQ	1D	:Set user diagnostic
UCORE.	EQ	1E	:Get slot physical addr & size (DDT only)
SFREZ.	EQ	1F	:Super-freeze slot
HALT.	EQ	20	:Halt the slot
SHALT.	EQ	21	:Super-halt the slot
SVSPY.	EQ	22	:Start/Stop SPY
DISCO.	EQ	23	:Disconnect Logical Unit

IO	EQ	3	:I/O SVC
:	I/O SUBOPERANDS
IOQRY.	EQ	8000	:Query I/O attributes
CSYNI.	EQ	0	:Connect SYNC input
CSYNO.	EQ	1	:Connect SYNC output
FSYNO.	EQ	2	:Force SYNC output
CASYN.	EQ	3	:Connect ASYNC
CPRT.	EQ	4	:Connect Printer
FPRT.	EQ	5	:Force Printer
TIISC.	EQ	6	:T-II SYNC Connect
TIISI.	EQ	7	:T-II SYNC Idle test
CSIO.	EQ	8	:Connect SIO
CMBRD.	EQ	9	:Connect SIO mother board
FMBIN.	EQ	0A	:Force mother board input
FMBOT.	EQ	0B	:Force mother board output
SHARE	EQ	04	:Shared device SVC
K.IN	EQ	0A	:Kernel Input SVC
K.OUT	EQ	0B	:Kernel Output SVC
KIO	EQ	0D	:Kernel-I/O (general) SVC
BDISC	EQ	0E	:Big disc SVC (obsolete)
SDISC	EQ	0F	:Small disc SVC (obsolete)

	IF	IRSIZE&3;	REMARK	%IRSIZE should be multiple of 4
IRSIZE	EQ	(IRSIZE!3)+1;	EI
	IF	ORSIZE&3;	REMARK	%ORSIZE should be multiple of 4
ORSIZE	EQ	(ORSIZE!3)+1;	EI

  IF	1-\MAXPRT
MAXPRT	EQ	NPORT-1
HPRT0	EQ	MAXPRT
  EI

  IF	\MAXHST
  ELSE
	REMARK	%PLEASE DEFINE MAXHST. 1 ASSUMED.
MAXHST	EQ	1
HOST0	EQ	HOSTNO
  EI


:	DEFINE START OF SEGMENTS
Q	EQ	0
	NOLIST
	RE	0F
  IF	\SEG|Q|
	GL	SEG|Q|
  ELSE
	SEG	Q
	GL	SEG|Q|
SEG|Q|
  EI
Q	EQ	Q+1
	ER
	LIST

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
QQ	EQ	0;	RE	0F
	IF	((Q*10000)%SEG|Q|)&7FFFFFFF
QQ	EQ	1;	REMARK	%SYMBOL SEG
	NUMBER	Q
	REMARK	 IS NOT DEFINED PROPERLY. VALUE IS 
	NUMBER	SEG|Q|
	EI
Q	EQ	Q+1;	ER
	LIST

	IF	QQ;
	REMARK	%START.LIB **MUST** be assembled FIRST!!%;
	EI
	SUBTTL	ISIS Ring Handling Routines	- IPIRNG.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	FRING.LIB

:	ISIS RING HANDLERS

:	This package is the fast, efficient ring handler set
:	The following CONSTRAINTS apply:
:	1.  Once started, register 14 or 15 is dedicated to that
:		operation, until it is "ended".
:	2.  If a new operation is started before the previous operation is
:		"ended", the previous operation is aborted, and the
:		appropriate ring is effectively left unchanged.
:
:	This package now permits simultaneous input and output!!!
:		R15 is used for output operations
:		R14 is used for input operations

:*: NOTE: ISIS II will soon use negative indexing, like this ring package.
:*:	To convert this package, remove all lines with ':*:' in them,
:*:	and change all occurrences of 'LHL R15/R14' to 'LH R15/R14'.

:	The package contains both utility and primitive routines:

:	utility routines are called with link R5,
:	they preserve registers R6--R14.
:	OCS	Output Canned String
:		R2 = port #, R3 = pointer to string (SC format)
:		OCS will output string as a data message to the specified
:		port. OCS goes to completion, and "ends the operation.
:	OCM	Output Canned Message
:		R2 = port #, R3 = pointer to string (SC format)
:		OCM will output the string as a message to the specified port
:		OCM goes to completion, and "ends the operation.
:	OBS	Output Byte String
:		R2 = number of characters, R3 = pointer to string
:		OBS will output specified string into the current message
:		message must have already been "started", and is NOT "ended".

:	primitive input routines.  All link on R4, & preserve R1-R3, R5-R13, R15:
:	LOOK	Determine if an input message exists...normal return if not
:		skip (4) return if so, and then:
:		R1 = port number
:		R2 = message type code (peek)
:		On skip return, condition codes are set such that JE will
:		succeed on port 0.  The port number will have been removed
:		from the message but the message code will not have been
:		removed (you get a peek at it).
:	GETCH	Get a character, returned in R0.
:	GETH	Get a halfword, returned in R0.  An even number of bytes 
:		should have been removed previously for expected results.
:	GETW	Get a word, returned in R0.  An even number of halfwords 
:		should have been removed previously for expected results.
:	FLUSH	Flush away ("end") remainder of input message.  R0 is number
:		of bytes remaining to flush.
:	ELIR	End-Logical-Input-Record.  "Ends" current message, sets
:		up pointers for next message.

:	Primative output routines.  All link on R4, preserve R1-R3, R5-R14,
:	unless used for arguments, or otherwise specified:
:	SPACE	Returns R0 = number of characters of space available in	
:		output ring. Sets up R15 for "start" of message.
:	ROOM	R0 = number of characters required for next message,
:		returns when that much room is available in output ring.
:		MAY DISMISS.
:		sets up R15 for "start" of message. SMASHES R1.
:	SLOR	Start Logical Output Record.
:		R0 = number of bytes required.
:		R1 = port #
:		R2 = message type code.
:		Provides function of ROOM, PUTH, and PUTCH for first 3 chars
:		of message. MAY DISMISS. SMASHES R3.
:	PUTCH	places character in R0 in next position of ring.
:	PUTH	places halfword in R0 in next position of ring.  Even number
:		of bytes have been output previously in this message.
:	PUTW	places word in R0 in next position of ring.  Even number of
:		halfwords should have been output previously in this message.
:	ELODR	End Logical Output Data Record
:		places byte count into message type to make data message,
:		then "ends" message.  Smashes R0, R1.
:	ELOR	End Logical Output Record
:		"ends" message.

:	CONVENTIONS:
:	ROUTINES USE DEDICATED REGISTERS:
:	R15	OUTPUT RING INDEX
:	R14	INPUT RING INDEX
:
:	NOTE....
:		IRSIZE AND ORSIZE MUST EACH BE LESS THAN 32K.

	GL	IRING,ORING,IRSIZE,ORSIZE
	GL	OCS,OCM,OBS
	GL	LOOK,GETCH,GETH,GETW,FLUSH,ELIR
	GL	SPACE,ROOM,SLOR,PUTCH,PUTH,PUTW,ELODR,ELOR
        GL      PERBUF,IOWSIZ,STSEG2

	MO	.,RING
NFMI	EQ	0		:RELATIVE INDEX OF NEXT-FILL-MESSAGE-INDEX
CEI	EQ	2		:RELATIVE INDEX OF CURRENT-EMPTY-INDEX
RING	EQ	4		:RELATIVE INDEX OF START OF RING DATA

:NE DATA AREA
	SEG	A.RING		:RINGS IN RING AREA

STSEG2  BS      100             :SAVE 1ST 256 BYTES FOR POINTERS TO
                                :THE RINGS AND OTHER BUFFER AREAS AS
                                :DEFINED BY THE SLOT INTERFACE
:	THE DISPATCHER OUTPUT RING
ORING	HS	0		:OUTPUT BLOCK START ADDRESS
	HC	0		:OUTPUT NEXT FILL MESSAGE INDEX
	HC	0		:OUTPUT CURRENT ENTRY INDEX
	BS	ORSIZE		:THE OUTPUT RING

:	THE DISPATCHER INPUT RING
IRING	HS	0		:INPUT BLOCK START ADDRESS
	HC	0		:INPUT NEXT FILL MESSAGE INDEX
	HC	0		:INPUT CURRENT EMPTY INDEX
	BS	IRSIZE		:THE INPUT RING

PERBUF  BS      PBUFSZ                  :AREA FOR PERIPHERAL DEVICE BUFFERS

IOWSIZ  EQ      .-STSEG2

        IF      10000-IOWSIZ
         REMARK %SEG 2 SIZE = 
         NUMBER IOWSIZ
         REMARK %
        ELSE
         REMARK %I/O RINGS OR OTHER BUFFERS IN SEG 2 TOO LARGE%
         QUIT
        EI

:	CODE AREA
	SEG	A.CODE
:	INPUT ROUTINES

:	LOOK AT A RING ENTRY
:	NORMAL RETURN IF RING EMPTY
:	ELSE SKIP RETURN, PORT RETURNED IN R1
:	MESSAGE TYPE RETURNED IN R2
:	ALL REGISTERS SET UP FOR TRANSFER
:	POSITION IS ADVANCED PAST PORT#
	IF	\LOOK;.LOOK.	 HS	0;	ELSE;LOOK	 HS	0;	EI
	LHL	R14,CEI+IRING,,	:GET CURRENT EMPTY INDEX
	CLH	R14,NFMI+IRING,,	:TEST IF CAUGHT UP
	JER	R4		:EMPTY...NORMAL RETURN
	SHI	R14,IRSIZE	:*: CONVERT TO NEGATIVE INDEX
	LHL	R1,IRING+RING+IRSIZE,R14,	:GET PORT #
	AIS	R14,2		:BUMP POINTER PAST PORT #
	LB	R2,IRING+RING+IRSIZE,R14,	:GET MESSAGE TYPE
	LR	R1,R1		:SET CONDITION CODES
	J	4,R4		:THEN SKIP RETURN

:	GET A CHARACTER FROM THE INPUT RING
:	CHARACTER RETURNED IN R0
GETCH	LB	R0,IRING+RING+IRSIZE,R14,	:GET THE CHAR
	AIS	R14,1		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	GET A HALF-WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF HALF-WORDS FROM RECORD
:	HALF-WORD RETURNED IN R0
GETH	LHL	R0,IRING+RING+IRSIZE,R14,	:GET THE DATA
	AIS	R14,2		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	GET A WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF WORDS FROM RECORD
:	WORD RETURNED IN R0
GETW	L	R0,IRING+RING+IRSIZE,R14,	:GET THE DATA
	AIS	R14,4		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	FLUSH AN INPUT RECORD
:	NUMBER OF CHARS TO FLUSH IN R0
FLUSH	AR	R14,R0		:ADVANCE RING AND FALL THROUGH

:	END LOGICAL INPUT RECORD
ELIR	AIS	R14,3		:FORCE TO NEXT WORD
	NHI	R14,-4
	JLFS	ELIR2		:NO
	SHI	R14,IRSIZE	:YES
ELIR2
	AHI	R14,IRSIZE	:*: CONVERT TO POSITIVE INDEX
	STH	R14,CEI+IRING,,
	JR	R4		:AND EXIT

:	OUTPUT ROUTINES

:	OUTPUT "CANNED" MESSAGE
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO STRING (FORMAT: n\B1\...\Bn)
OCM	LB	R0,0,R3		:GET COUNT n
	AIS	R0,5		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2		:COPY PORT #
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3		:GET COUNT AGAIN
	J	OCS1		:SKIP TO PLACE THE STRING

:	OUTPUT "CANNED" STRING
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO TEXT STRING (FORMAT n\B1\...\Bn)
OCS	LB	R0,0,R3		GET COUNT n
	AIS	R0,6		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3
	LR	R0,R2		:GET THE COUNT n
	JAL	R4,PUTCH	:PLACE IT...MESSAGE TYPE 1-7D
OCS1	AIS	R3,1		:BUMP SOURCE CHARACTER POINTER
	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OCS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	JR	R5		:THEN EXIT

:	OUTPUT A BYTE STRING
:	LINK ON R5
:	R3 = POINTER TO STRING
:	R2 = NUMBER OF CHARACTERS TO OUTPUT FROM STRING
OBS1	AIS	R3,1		:BUMP CHARACTER POINTER
OBS	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OBS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JR	R5		:THEN EXIT

:	FIND SPACE IN THE RING (HOW BIG A MESSAGE IT WILL TAKE)
:	RETURNS R0 = NUMBER OF CHARS OF SPACE
SPACE	LCS	R0,4		:SET MASK
	LHL	R15,NFMI+ORING,,
	NH	R0,CEI+ORING,,	:FORCE EMPTIER TO WORD BOUNDARY
	SR	R0,R15		:SPACE BETWEEN US AND EMPTIER
	JGFS	SPACE1		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE	:ELSE CORRECT FOR WRAP
SPACE1	SIS	R0,4		:CORRECT FOR POSSIBLE OVERFLOW
	SHI	R15,ORSIZE	:*: CONVERT TO NEGATIVE INDEX
	JR	R4		:AND RETURN

:	INSURE THERE IS ROOM IN THE RING (DISMISS IF NECESSARY)
:	EXPECTS R0 = NUMBER OF CHARACTERS OF SPACE
ROOM	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
ROOM1	LCS	R1,4		:SET MASK
	NH	R1,CEI+ORING,,	:FORCE HIM TO WORD BOUNDARY
	SHI	R1,ORSIZE	:*:
	SR	R1,R15		:CHECK RELATIVE POSITIONS
	JGFS	ROOM2		:SKIP IF HE'S AHEAD OF US
	JER	R4		:EQUAL...HE'S EMPTY...GO DO IT
	AHI	R1,ORSIZE		:HE'S BEHIND US
ROOM2	SIS	R1,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R0,R1
	JLER	R4		:ROOM EXISTS...GO DO IT
	SVC	DISMISS,0
	J	ROOM1		:AND GO TRY AGAIN

:	START LOGICAL OUTPUT RECORD
:	PROVIDES FUNCTION OF ROOM, PUTH, & PUTCH FOR FIRST 3 CHARS OF MESSAGE
:	R0 = NUMBER OF CHARACTERS OF SPACE REQUIRED
:	R1 = PORT #
:	R2 = MESSAGE CHARACTER CODE
SLOR	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
SLOR1	LCS	R3,4		:SET A MASK
	NH	R3,CEI+ORING,,	:FORCE RECEIVER TO WORD BOUNDARY
	SHI	R3,ORSIZE	:*:
	SR	R3,R15
	JGFS	SLOR2
	AHI	R3,ORSIZE	:ACCOUNT FOR POSSIBLE RING FOLDING
SLOR2	SIS	R3,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R3,R0
	JGEFS	SLOR3		:SKIP IF WE CAN GO
	SVC	DISMISS,0
	JBS	SLOR1
SLOR3	STH	R1,ORING+RING+ORSIZE,R15,	:OK...PLACE MESSAGE
	STB	R2,2+ORING+RING+ORSIZE,R15,
	AIS	R15,3		:BUMP PAST THESE CHARACTERS
	JR	R4		:AND EXIT

:	PUT A CHARACTER INTO THE RING
:	R0 = CHARACTER
PUTCH	STB	R0,ORING+RING+ORSIZE,R15,	:PLACE THE CHARACTER
	AIS	R15,1		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A HALF-WORD INTO THE RING
:	R0 = HALF-WORD
PUTH	STH	R0,ORING+RING+ORSIZE,R15,	:PLACE THE HALF-WORD
	AIS	R15,2		:BUMP INDEX
	JLR	R4		:EXIT IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A WORD INTO THE RING
:	R0 = WORD
PUTW	ST	R0,ORING+RING+ORSIZE,R15,	:PLACE THE WORD
	AIS	R15,4		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	END LOGICAL OUTPUT DATA RECORD
ELODR	LHL	R1,NFMI+ORING,,	:GET START OF THIS MESSAGE
	SHI	R1,ORSIZE	:*: CONVERT TO NEG. INDEX
	LR	R0,R15		:COPY MESSAGE END
	SR	R0,R1		:COMPUTE SIZE OF THIS MESSAGE
	JGEFS	ELODR2		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE		:ELSE CORRECT FOR WRAP
ELODR2	SIS	R0,3		:MAKE ALLOWANCE FOR HEADER
	JER	R4		:EXIT IF ZERO LENGTH MESSAGE
	STB	R0,2+ORING+RING+ORSIZE,R1,	:INSERT MESSAGE TYPE INTO MESSAGE
				:AND FALL THROUGH

:	END LOGICAL OUTPUT RECORD
ELOR	AIS	R15,3
	NHI	R15,-4
	JLFS	ELOR2
	LHI	R15,-ORSIZE	:FOLD IF NECESSARY
ELOR2
	AHI	R15,ORSIZE	:*: CONVERT BACK
	STH	R15,NFMI+ORING,,	:NOW ADVANCE POINTER TO NEXT MESSAGE
	JR	R4		:AND EXIT
	EM
	SUBTTL	ISIS STARTUP AND CRASH LIBRARY	- CRASH.LIB
        REMARK  %CRASH.LIB    11-15-84 AWT
	REMARK	%THIS VERSION HAS AN OPTION FOR EXTENDED CRASH PROCESSING.

:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	CRASH.LIB	MFR 07/14/81

:       Set UPSW to turn off tracing.
:       Added CTIME and CRTIME to save crash times in GMT.
:       Added a NCRSAV option to keep old copies of crash tables.
:         April 13, 1983 AWT
:
:	Changed the supervisor's log message to report the PRODID.
:	Sep. 20, 1982 SCY.
:	ENTRY2 (restart service) changed to clear input and output
:	rings PRIOR to issuing Restart SVC to prevent crash-loop if
:	Dispatcher has crashed. June 17, 1982 MDS.

:			ISIS - II Version
:
	GL	CRASH,CRASHC,CPOINT,CFROM,CRREG,ENTRY,START,CRAT,CRSHCT,CRSTOP
        GL      PRODID,NCRSAV,CTIME,CRTIME,EXCRSH
	MO	.,CRASH


:	Generalized crash package.
:	Handles both software and hardware crashes.  On any crash, the
:	registers are saved in CRXREG, and CRSHCT is incremented.
:	Software crashes occur via  JAL R10,CRASH .  CRASH saves (R10) in cell
:	CPOINT.  Software crashes may be "good" or "bad"...if "good", the
:	calling sequence is:

:		JAL	R10,CRASH
:		HC	0		:this key distinguishes a good crash
:						from a bad one
:		BC	4*L,Y		:first byte is 4*register linked to
:						routine, Y is the reason
:	then register (L) is saved in CFROM, and Y is saved in CRASHC

:	in the event of a hardware failure, CPOINT contains the instruction
:	address at the time of failure, CRASHC contains the failure reason,
:	and CFROM is set =-1.

:	On completion of crash, transfers to label START, defined
:	in the user code.
:
:	The symbol CRSTOP may be set to 0 or 1.  If 1 the crash routine will
:	be executed only once.  the second time through the crash area will
:	be set up as specified above and then registers will be restored to
:	their entry value and the slot will be frozen. If it is thawed it
:	will restart.
:
:       The symbol NCRSAV defines the number of crash tables to be saved.
:       It will be set to 1 by default. (In TYMFIL CRSHTB macro is used
:       to define NCRSAV)
:
:       Entering :R CRAT,CRTSIZ (or 4C) will dump the last 
:       crash table, CRAT+CRTLEN (or 50),CRTSIZ will dump the    
:       previous crash table and so on.
:
:       CTIME,4 gives the last crash time (in GMT), CTIME+CRTLEN,4
:       gives the previous crash time and so on.
:
:	The symbol EXCRSH, if set to 1, allows a JAL to label
:	CRSH.P out of the crash routine for extended crash processing.
:	The link is R5.  EXCRSH is defaulted to 0.
:
:

  IF	\CRSTOP
  ELSE
CRSTOP	EQ	0
  EI
  
  IF    \NCRSAV                 :# OF CRASH TABLES TO SAVE
  ELSE                          :IT MAY BE DEFINED IN TYMFIL
NCRSAV  EQ      1               :OTHERWISE IT IS 1 BY DEFAULT
  EI

  IF	\EXCRSH			:DEFAULT TO NO EXTENDED CRASH HANDLING
  ELSE
EXCRSH	EQ	0
  EI


CRTENT  EQ      .               :CRASH TABLE ENTRY
        ORG     0
CRSHCT	HS	1		:CRASH COUNT...HOW MANY TIMES CRASHED
CRASHC	HS	1		:CRASH CODE (INIT'ED TO MANUAL RESTART)
CPOINT	HS	2		:WHERE CRASH OCCURED
CFROM	HS	2    		:WHERE CRASH WAS CALLED FROM
CRXREG	HS	20		:CRASH REGISTER SAVE AREA
CRTSIZ  WS      0               :SIZE OF CRASH TABLE WITHOUT CRTIME
CRTIME  WS      1               :REAL TIME OF CRASH (GMT)
CRTLEN  WS      0               :LENGTH OF CRASH TABLE WITH CRTIME
        ORG     CRTENT  

        SEG     A.DATA
        HS      0
CTIME   WS      1               :STORAGE FOR CRASH TIME OF LAST CRASH
CRAT    BS      CRTLEN*NCRSAV   :STORAGE FOR CRASH TABLE(S)
CRREG   EQ      CRAT+CRXREG
RGSTOR  WS      10              :TEMPORARY STORAGE FOR REGISTERS
FGNDFL	HS	1		:FOREGROUND FLAG

TRBOFF  WC      0,FAIL0         :TRACE BIT OFF, GO TO FAIL0
TRCOFF  WC      0,CRASH0        :TRACE BIT OFF, GO TO CRASH0
PSWSAV  WC      0,START         :RESTORE PSW,  GO TO INITIALIZATION CODE
CHFLAG  WC      0               :USED FOR ANY CHANGES ON PSW


	SEG	A.CODE		:CODE AREA
CRSHCD	BC	1	:MANUAL RESTART
	BC	0	:POWER FAILURE
	BC	0E	:PARITY ERROR
	BC	10	:DISPATCHER CRASH
	BC	11	:ILLEGAL INSTRUCTION
	BC	12	:ILLEGAL SVC
	BC	13	:SYSTEM CRASH
	BC	14	:PROTECTION VIOLATION
	BC	15	:NON-RECOVERABLE DEVICE CHECK
	BC	16	:WATCH FROG TIMER - - TIME OUT

	RA	0
:	GENERAL MACHINE FAILURE
FAIL	HS	4		:PSD SAVED HERE
	HS	4		:R0,R1 SAVED HERE
        ST      R0,RGSTOR,,     :SAVE R0
        ST      R2,RGSTOR+4,,   :SAVE R2
        JAL     R2,SAVPSW       :SAVE CURRENT PSW
        L       R0,RGSTOR,,     :RESTORE R0
        L       R2,RGSTOR+4,,   :RESTORE R2
        UPSW    TRBOFF          :TRACE BIT OFF AND CONTINUE
FAIL0   LB      R0,CRSHCD,R1    :CONVERT CRASH REASON
	CLHI	R0,12		:TEST IF ILLEGAL SVC
	JNFS	FAIL1		:NO...SKIP
	LHL	R0,FGNDFL	:DID FOREGROUND CAUSE THE CRASH?
	JN	ENTRY2		:YES....JUMP OVER
FAIL1   STM     R0,RGSTOR,,     :SAVE REGISTERS
        JAL     R2,PSHTBS       :PUSH DOWN CRASH TABLES
        L       R1,GMT,,        :GET GMT CLOCK
        ST      R1,CTIME,,      :SAVE IT AS THE CRASH TIME
        LM      R0,RGSTOR,,     :RESTORE REGISTERS
        STM     R2,CRAT+CRXREG+8,, :SAVE THE REGISTERS
        STH     R0,CRAT+CRASHC,,  :SAVE CRASH CODE
        LM      R12,FAIL          :GET THE REST
        STM     R14,CRAT+CRXREG,,  :SAVE R0 & R1
        ST      R13,CRAT+CPOINT,, :SAVE FAILURE ADDRESS
	LCS	R1,1
        ST      R1,CRAT+CFROM,,   :FLUSH PLACE CALLED FROM
        J       ENTRY1            :AND SKIP TO START UP AGAIN



:	CRASH ROUTINE AND GENERAL INITIALIZER
:	IF "GOOD" CALL TO CRASH, HAS HALFWORD 0'S FOLLOWING,
:	THEN BYTE WITH 4*LINK REGISTER, THEN BYTE WITH CRASH REASON

CRASH   ST      R0,RGSTOR,,     :SAVE R0
        ST      R2,RGSTOR+4,,   :SAVE R2         
        JAL     R2,SAVPSW       :SAVE CURRENT PSW
        L       R0,RGSTOR,,     :RESTORE R0
        L       R2,RGSTOR+4,,   :RESTORE R2
        UPSW    TRCOFF          :TRACE BIT OFF AND CONTINUE
CRASH0  STM     R0,RGSTOR,,     :SAVE REGISTERS
        JAL     R2,PSHTBS       :PUSH DOWN THE CRASH TABLES
        L       R1,GMT,,        :GET GMT CLOCK
        ST      R1,CTIME,,      :SAVE IT AS THE CRASH TIME
        LM      R0,RGSTOR,,     :RESTORE REGISTERS
        STM     R0,CRAT+CRXREG,, :SAVE REGISTERS AND
        ST      R10,CRAT+CPOINT,,                    
	LIS	R0,$A10		:FAKE UNKNOWN CRASH
	LCS	R1,1		:FROM NOWHERE
	LHL	R2,0,R10	:CHECK WHERE CALLED FROM
	JNFS	CRASH1		:NOT KNOWN...USE DEFAULT
	LB	R0,3,R10	:GET CRASH CONDITION
	LB	R2,2,R10	:GET CALLING REGISTER
        L       R1,CRAT+CRXREG,R2 :GET CONTENTS OF REGISTER
        
CRASH1  STH     R0,CRAT+CRASHC,, :SAVE CRASH CODE
        ST      R1,CRAT+CFROM,,  :SAVE PLACE CRASHED FROM
	JFS	ENTRY1

:	ENTER HERE WITH RESTART
ENTRY	LIS	R0,1		:LOAD CRASH CODE REGISTER
        STH     R0,CRAT+CRASHC,, :STORE IT
ENTRY1	LIS	R1,1
        AHM     R1,CRAT+CRSHCT,, :SAVE INTERESTING DATA

  IF	CRSTOP		:IF STOPPING ON CONSECUTIVE CRASHES
	CLHI	R0,1
	JLE	ENTRY2		:IF POWER FAILURE OR MANUAL RESTART
	OHI	R0,0CC00	:CRASH INDICATOR FOR FRONT PANEL
	STH	R0,FPANEL,,	:SET PANEL TO BAD CRASH
   IF	EXCRSH
	JAL	R5,CRSH.P,,	:GO DO EXTENDED CRASH PROCESSING
   EI	EXCRSH
        LM      R0,CRAT+CRXREG,, :RESTORE REGISTERS
	SVC	SYS,HALT.	:HALT THE SLOT
  EI	CRSTOP

	LIS	R0,1		:WANT SECOND WORD OF PSD
	SVC	SYS,RFPSD.	:READ FOREGROUND PSD
	CLI	R0,.		:TEST IF FOREGROUND IS EXECUTING THIS INSTRUCTION
	JNFS	ENTRY2		:SKIP IF NOT
	STH	R0,FGNDFL	:SET THE FOREGROUND FLAG

ENTRY2		: NOW RESET OUTPUT RING, REPORT CRASH
  IF	CRSTOP
  ELSE
   IF	EXCRSH
	JAL	R5,CRSH.P,,	:GO DO EXTENDED CRASH PROCESSING
   EI	EXCRSH
  EI	CRSTOP
	LIS	R0,0
	ST	R0,ORING,,	:EMPTY OUTPUT RING
	ST	R0,IRING,,	:EMPTY INPUT RING

	LA	R0,FAIL		:LOAD TRAP AREA ADDRESS
	SVC	SYS,RSTRT.	:RESTART SVC
	JAL	R10,CRASH	:NON-SKIP RETURN...CRASH


	LIS	R0,0
	STH	R0,FGNDFL	:CLEAR THE FOREGROUND FLAG

	JAL	R4,SPACE,,	:SET UP FOR DIAGNOSTIC
	LHI	R0,0300
	JAL	R4,PUTW,,	:PORT 0 + DIAGNOSTIC MESSAGE + PAD
	LHL	R0,CRAT+CRSHCT,,
	JAL	R4,PUTCH,,	:HW4 LOW = CRASH COUNT
	LIS	R0,0
	JAL	R4,PUTCH,,	:RESERVED BYTE
	LIS	R0,1
	JAL	R4,PUTCH,,	:REPORT TYPE = 1
	LHL	R0,CRAT+CRASHC,,
	JAL	R4,PUTCH,,	:HW3 HIGH = CRASH CODE
	LHI	R0,PRODID
	JAL	R4,PUTCH,,	:HW2 LOW IS PRODUCT ID
	JAL	R4,ELOR,,	:END LOGICAL OUTPUT RECORD
        L       R1,CHFLAG,,     :SEE IF PSW HAS BEEN CHANGED
        CLHI    R1,1
        JNFS    CURPSW          :NO CHANGE, GO TO USE CURRENT PSW
        LIS     R1,0
        ST      R1,CHFLAG,,     :RESET CHFLAG FOR FUTURE PSW CHANGE
        UPSW    PSWSAV          :INITIALIZE WITH RESTORED PSW
CURPSW  J       START,,         :INITIALIZE WITH CURRENT PSW

SAVPSW  LIS     R0,1            :GET PC OF BACKGROUND PSD
        ST      R0,CHFLAG,,     :ALSO INDICATE PSW WILL BE MODIFIED
        SVC     SYS,RBPSD.      :READ BACKGROUND PSD
        CLI     R0,.            :IS IT RUNNING?
        JNFS    ISFGND          :NO, IT MUST BE FOREGROUND JOB
        LIS     R0,0            :GET PSW OF BACKGROUND JOB
        SVC     SYS,RBPSD.
        ST      R0,PSWSAV,,     :SAVE IT
        JR      R2              :RETURN
ISFGND  LIS     R0,0            :GET PSW OF FORGROUND JOB
        SVC     SYS,RFPSD.
        ST      R0,PSWSAV,,     :SAVE IT
        JR      R2              :RETURN


PSHTBS  LHI     R1,CRTLEN*NCRSAV-CRTLEN*2
        JLR     R2              :IF ONLY 1 CRASH TABLE, SKIP AND RETURN
PUSHIT  LM      R6,CRAT,R1      :PUSH DOWN THE CRASH TABLE
        STM     R6,CRAT+CRTLEN,R1
        LM      R6,CRAT+CRTLEN/2,R1
        STM     R6,CRAT+CRTLEN+CRTLEN/2,R1
        SHI     R1,CRTLEN
        JGEBS   PUSHIT
        L       R1,CTIME,,
        ST      R1,CRAT+CRTSIZ,,
        JR      R2              :RETURN
         
	EM
	SUBTTL	STATL.LIB . . . Long-token version of STATUS.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of TYMNET, and may not be copied in whole
:	or in part or disclosed to any third party without
:	the prior written consent of TYMNET.
:
:*******************************************************************

  IF	1-\DB.STA			: DEFAULT DEBUG/STATUS TO ON
DB.STA	EQ	1
  EI

  IF	DB.STA				: ASSEMBLE ONLY WITH DEBUG STATUS ON

	SEG	A.CODE
	MO	.,STATUS
	RA	$00
	GL	DSTART,DS.ELL,DS.ILL,DS.ERR,DS.DLM
	GL	DS.TOK,DS.NUM,DS.EXI,DS.QUI,DS.GCH,DS.CUC,DS.DEL

:	STATUS - User Command Handler
:
:	Version history:
:	13.3  08/19/83  <JOK>Changed DS.TOK to return first 8 chars of
:		TOKEN, changed DS.CMD to retain first 8 chars of command,
:		and changed DSTART to accept up to 8-character commands.
:	13.2  01/27/81  <BAB>Added RADIX=0 at start of mod.  Added jump
:		following 'QUIT' SVC to allow DDT "P" (proceede) command
:		to return the user to ":>" prompt.
:	13.1  11/17/81	<BAB>Added DNEXTK support, DS.DLM (last delimiter),
:		and fixed backspace for > 4 character entry, added the
:		command thought to be invalid to invalid command message.
:	13	08/81	<JK>Maintenance assumed by BAB from John Kopf
:
:		The Status package is intended to provide an extension to DDT,
:	invokable via the "?STAT" command in DDT.  Once invoked you may re-
:	activate it (provided you have not issued any DDT "G" (go) commands)
:	by typing "P ".
:
:		There is limited editing control built into the package:
:	ESC	aborts back to command level,
:	^W	discards partial 'token' already input (word or number),
:	^A	discards last char of token (backspace).
:	^H	discards last char of token (backspace).

:		Delimiters may occur in multiple (e.g. ", " is OK).  Valid
:	delimiters are:
:	C/R	L/F	H/T	","	and BLANK.

:		Entry Points:
:	DSTART	Place to exit on completion of command.
:	DNEXTK  Get next token with out prompt.
:	DS.ILL	Place to exit on illegal command -- types "Illegal command"
:	DS.ERR	Place to exit on command error -- types "type '\' "
:	DS.EXI	Place to exit machine.
:	DS.QUI	Place to exit back to DDT.
:	DS.GCH	Get a character...Link on R1, char (with high-order bit forced)
:			in R0...normal return if detected ^W, skip-4 if detect
:			^A, aborts back to DSTART if detects ESC.
:	DS.DEL	Check for delimiter...Link on R2, Character in R0.  Skip-4
:			return unless this is a delimiter, then normal return.
:	DS.CUC	Convert to upper case...Link on R1, Character in R0.
:	DS.TOK	Get a string token...Link on R4, TOKEN returned in R3/R2...
:			inputs up to 4 characters, returns them (in uppercase)
:			left justified, 0 fill
:	DS.NUM	Get a number...Link on R5, expects Radix in R4...
:			number returned in R0.  May ABORT if any character is
:			input other than valid digit or delimiter.
:	DS.DLM  Location of last delimeter entered (1 byte)

:		There are two built-in commands:
:	Quit	exit back to DDT.
:	EXIt	exit machine.

:		additional commands may be defined via the DS.CMD macro:
:	 DS.CMD(TEXT,ADDR)
:	Where:	TEXT	The (UPPERCASE) target command string.
:		ADDR	The virtual address to transfer to, to service that
:				command.
:	DS.CMD generates a 16-byte descriptor for this command, at the point
:	assembly where it is invoked.  This descriptor is on a WORD boundary.



OUT	EQ	0B			: Output SVC
IN	EQ	0A			: Input SVC

DS.ELL	EQ	0			: Null pointer for end-of-linked-list

	SEG	A.DATA
DS.DLM	BS	1			: Last delimiter encountered
R4SAV	WS	1			: Save-area for R4 in DS.TOK
BADSTR	SC	/'xxxxxxxx'"8D"8A/	: Place to put bad command
STOKEN	EQ	BADSTR+2		: String-buffer for token
	SEG	A.CODE

:	Define elements for command-block
C.NEXT	EQ	0			: Pointer to next command-block
C.ADDR	EQ	C.NEXT+4		: Pointer to command-handler
C.STR	EQ	C.ADDR+4		: Relative position of string

:	Define macro to generate this command-block
DS.CMD	MACRO(STR,ADDR)[ WS	0
   IF	DS.ELL
Q	WS	0
	ORG	DS.ELL
	WC	Q
	ORG	Q
   EI
DS.ELL	WC	0,ADDR
	AC	/STR/
	WS	0
 IF	DS.ELL+10-. ; WC 0; EI
]


:	TABLE OF COMMANDS, AND TARGET ROUTINES.
CMDLST	DS.CMD(Q,DS.QUI)		: Exit back to DDT
	DS.CMD(QUIT,DS.QUI)		: Exit back to DDT
	DS.CMD(EXIT,DS.EXI)		: Exit
	DS.CMD(EXI,DS.EXI)		: Exit




:	Diagnostic messages
TERR	SC	/Illegal command /
TTERR	SC	/type '\'"8D"8A/
PROMPT	SC	/"8D"8A:>/		: "CR|LF:>"
BKSPAC	SC	/"88 "88/		: Back-space
	SUBTTL	Command-scanner, Verifier, and Bitcher

:	Command-input Handler
DOIT	L	R0,C.ADDR,R1		: Go service this command
	JALR	R0,R0

:	Next Command
DSTART	SVC	OUT,PROMPT		: Issue Prompt
DNEXTK	JAL	R4,DS.TOK		: Get command-token
	LA	R1,CMDLST		: Search for string-match
DSTAR1	CL	R3,C.STR,R1		: check first-word
	JNFS	DSTAR2			: no match
	CL	R2,C.STR+4,R1		: second-word
	JE	DOIT			: Proceed if find a match

DSTAR2	L	R1,C.NEXT,R1		: Else continue scan
	JGBS	DSTAR1

DS.ILL	SVC	OUT,TERR		: "ILLEGAL COMMAND"
	SVC	OUT,BADSTR,,

DS.ERR	SVC	OUT,TTERR		: Tell user to type Flush-char

BITCH	JAL	R1,DS.GCH		: Flush input
	 JBS	BITCH;	 NOPR	0			: ^W...Ignore
	  JBS	BITCH;	  NOPR	0			: ^A...Ignore
	CLHI	R0,0DC			: Read until "\" is found
	JNBS	BITCH
	J	DSTART			: Then exit


:	Built-in Commands

:		Command EXIt
:		===========-
DS.EXI	SVC	KIO,0			: Disconnect


:		Command Quit (exit back to DDT)
:		=========---
DS.QUI	SVC	KIO,1			: Return to DDT
	J	DSTART			: If operator typed "P", get next command
	SUBTTL	U T I L I T I E S

:	Get a Command-token...Up to 8 chars long
:		Skips over extra characters to next delimiter
:	Link on R4
:	Token returned in R3/R2, Left justified, 0-fill
DS.TOK	ST	R4,R4SAV,,		: save R4

TOKEN0	LIS	R0,0			: clear token buffer
	LA	R3,STOKEN,,		: set char-pointer
	ST	R0,0,R3
	ST	R0,4,R3

:	Scan for first character of TOKEN
TOKEN1	JAL	R1,DS.GCH		: Get next char
	 JBS	TOKEN1;	 NOPR	0			: ^W...Ignore
	  JBS	TOKEN1;	  NOPR	0			: ^A...Ignore
	JAL	R2,DS.DEL		: Skip over delimiters
	 J	TOKEN1
	JAL	R1,DS.CUC		: Convert to Upper-case
	CHI	R0,00DC			: = "\" ?
	JE	DSTART			: YES.  Print Prompt, get next command
	STB	R0,0,R3			: no...start TOKEN accumulation
	AIS	R3,1			: advance pointer
	LIS	R4,1			: 1 char. found so far

TOKEN2	JAL	R1,DS.GCH		: Get another char
	 J	TOKEN0			: ^W...Start over
	  J	TOKEN4			: ^A...Toss last char
	JAL	R1,DS.CUC		: Convert to upper-case
	JAL	R2,DS.DEL		: Check for delimiter
	 J	TOKEN3			: Got one...skip to clean up
	CHI	R0,00DC			: = "\" ?
	JE	DS.ILL			: YES.  Treat as Illegal
	AIS	R4,1			: one more character
	CHI	R4,8			: If >= 8 chars, do not use this one
	JG	TOKEN2			: YES...Scan for delimiter
	STB	R0,0,R3			: NO...Accumulate chars
	AIS	R3,1			: advance cursor
	J	TOKEN2			: ..and get another char

TOKEN3	L	R4,R4SAV,,		: Restore R4
	L	R3,STOKEN,,		: place TOKEN into Registers
	L	R2,STOKEN+4,,
	JR	R4			: Return TOKEN in R2/R3


:	Handle backspace in TOKEN
TOKEN4	SIS	R4,1			: one less char
	JLE	TOKEN0			: re-initialize if none left
	CHI	R4,8			: If after backspace TOKEN is >= 8
	JGE	TOKEN2			: then just decrement counter
	LIS	R0,0			: else... drop one character
	SIS	R3,1			:   back-up pointer
	STB	R0,0,R3
	J	TOKEN2			: and get next char

:	Utility routine to read a number
:	uses R0-R3
:	Expects RADIX in R4
:	Link on R5
:	Aborts if first non-delimiter is not digit
:	Else returns number in R0
DS.NUM	JAL	R1,DS.GCH		: get next char
	 JBS	DS.NUM;	 NOPR	0			: ^W...ignore
	  JBS	DS.NUM;	 NOPR	0			: ^A...Ignore
	JAL	R2,DS.DEL		: check for delimiter char
	 J	DS.NUM
	JAL	R2,DS.DIG		: test if char is digit
	 J	DS.ILL			: not a digit - give error-message
	CLR	R0,R4
	JGE	DS.ILL			: digit is bigger than RADIX...Abort
	LR	R3,R0			: put first digit into accumulator
NUMBER	JAL	R1,DS.GCH		: read next char
	 J	DS.NUM			: ^W...Start over
	  J	DIVIDE			: ^A...Toss last digit
	JAL	R2,DS.DEL		: Check for delimiter
	 LR	R0,R3;	 JR	R5	  :YES
	JAL	R2,DS.DIG		: skip if digit
	J	DS.ILL			: NO...Abort
	CLR	R0,R4
	JGE	DS.ILL			: RADIX error...Bitch
	MR	R2,R4			: build number
	AR	R3,R0			: add new digit
	J	NUMBER			: get next digit

DIVIDE	LIS	R2,0			: got a ^A...Make double-precision arg.
	DR	R2,R4			: Quotent into R3, where we want it
	J	NUMBER			: now go back for more digits

:	Digit test
:	Check character read...Skip return if digit
:	Then R0=Binary value of HEX digit
:	uses R1, Link on R2
DS.DIG	JAL	R1,DS.CUC		: Convert to upper-case
	LR	R1,R0			: Copy char
	SHI	R1,0B0			: is it "0"?
	JLR	R2			: return if less than "0"
	SIS	R1,0B9-0B0		: is it "9"
	JLEFS	DIGIT			: less than "9", then a good digit
	SIS	R1,0C1-0B9		: is it "A"?
	JLR	R2			: return if less than "A"
	SIS	R1,0C6-0C1		: is it "F"?
	JGR	R2			: return if greater than "F"
	SIS	R0,7			: 0A - "A" (partial conversion)

DIGIT	SHI	R0,0B0			: "0"
	J	4,R2			: skip-return

:	Check for delimiter
:	Link	R2
:	Uses	R0,R1
:	Skip-4 return unless (R0) is a delimiter-character
DS.DEL	LHI	R1,DLEN-1		: number of delimiter chars
	STB	R0,DS.DLM,,		: save delimiter

DELIM	CLB	R0,DLIST,R1		: compare to a delimiter
	JER	R2			: return if delimiter
	SIS	R1,1			: check next delimiter
	JGEBS	DELIM			: loop if any more delimiters
	J	4,R2			: skip-return

:	List of delimiter chars
DLIST	AC	' ,'			: Blank,","
	BC	8D,8A,89		: CR,LF,HT
DLEN	EQ	.-DLIST			: Number of delimiter chars

:	Input a Character
:	Link	R1
:	Normal-return:   ^W Input...Flush entry
: 	Skip-4 return:  ^A or ^H Input...flush last char
:	  SKIP-8 return: Char in R0 (high-bit on)
:	Aborts to command-scanner on "ESC"
DS.GCH	SVC	IN,0F			: get the char
	 J	DS.GCH
	OHI	R0,80			: set high-order bit
	CLHI	R0,9B			: check for escape
	 JE	DSTART			: abort, proceed with prompt if so
	CLHI	R0,97			: check for ^W
	 JER	R1			: normal-return
	CLHI	R0,81			: check for ^A
	 JE	4,R1			: Skip-4 return
	CLHI	R0,88			: check for ^H
	 JN	8,R1			: No, skip-8 return, Char in R0

	SVC	OUT,BKSPAC		: Back-space
	J	4,R1			: skip-4 return for ^H

:	Convert char in (R0) to upper-case
:	Link on R1
DS.CUC	CLHI	R0,0E1			: Compare with "a"
	JLR	R1			: Exit if it can't be lower-case
	CLHI	R0,0FA			: Compare with "z"
	JGR	R1			: Not lower-case...Just return
	SHI	R0,20			: Lower-case...Convert to upper-case
	JR	R1			: and return

	EM

  EI	: (DB.STA)
	SUBTTL	EBUS BASE CODE
	RA	0

:		***** ****  *   *  ****
:		*     *   * *   * *
:		****  ****  *   *  ***
:		*     *   * *   *     *
:		***** ****   ***  ****
:	This is the EBUS Base Code
	GL	START,FPANEL,EBDUMP
 if	1-\EBDUMP
EBDUMP	EQ	0			: switch off if not defined
 ei

	MO	.,EBUS

SSRCRC	EQ	0F0			: Crash-code for SSR-detected crash of IPI   
SVCCRC	EQ	0F1			: Crash-code for failed CONNECT-IPI SVC call
IPICRC	EQ	0F2			: Crash-code for CRASH-MSG sent by IPI

XLATE	EQ	$A 49
CONIP	EQ	0D0

:	Define some data-structure formats
Q	EQ	.

:	Parameters passed to 68K
	ORG	0			: define offsets
.ORING	HS	2			: pointer to ORING (L)
.ORSIZ	HS	1			: ORSIZE (W)
.IRING	HS	2			: pointer to IRING (L)
.IRSIZ	HS	1			: IRSIZE (W)
.FASTC	HS	2			: pointer to FASTC (L)
.SLOWC	HS	2			: pointer to SLOWC (L)
.SYNC	HS	2			: pointer to SYNC (L)
.CDUMP	HS	2			: pointer to REGDMP (L)
.MDUMP	HS	2			: pointer to Memory-dump (L)
.MSIZE	HS	2			: size of dump area in bytes (L)
.SIZE	WS	0			: size of this area

:	Parameters returned by 68K (on Crash)
	ORG	0			: define offsets
COD	WS	1			: CODCASH (L)
PC	WS	1			: PCCASH (L)
D0	WS	1			: D0 (L)
D1	WS	1			: D1 (L)
D2	WS	1			: D2 (L)
D3	WS	1			: D3 (L)
D4	WS	1			: D4 (L)
D5	WS	1			: D5 (L)
D6	WS	1			: D6 -- Cd (L)
D7	WS	1			: D7 -- Cs (L)
A0	WS	1			: A0 (L)
A1	WS	1			: A1 (L)
A2	WS	1			: A2 (L)
A3	WS	1			: A3 (L)
A4	WS	1			: A4 -- Rp (L)
A5	WS	1			: A5 -- Rs (L)
A6	WS	1			: A6 -- Rd (L)
A7	WS	1			: A7 -- SP (L)

	ORG	Q			: return to real address-space

	SEG	A.DATA
FPANEL	HC	0			: used for front-panel display
SYNC	HC	0			: used to synchronize EBUS code
HPARAM	HC	0			: front-panel display (host #|# circuits)
HSTAT	HC	0			: ditto...host state (left byte)
BITS	HS	2			: ditto
XBITS	HS	2			: ditto

:	This area is used for communication between ISIS and this slot
STAREA	WS	0			: Beginning of status (communications) area
STCRA	WS	1			: <CODCASH> placed here
STATIM	WS	1			: time of occurance
SSRCRA	WS	1			: SST reason
SSRTIM	WS	1			: time of occurance
CRATYP	WS	1			: Identifies type of SVC Crash
	WS	1			: ??


:	68K Communications Area
IOWADR	EQ	STSEG2			: in SEG 2
EVERN	EQ	IOWADR+.SIZE		: where EBUS will place it's version #
REGDMP	EQ	EVERN+2			: where EBUS will dump Regs to


 IF	EBDUMP
	SEG	3

:	Dump image area
S3ADDR	BS	40000			: reserve 256K area for dump image
 EI

	SEG	A.CODE
:	Code area


:	Begin here...Initialize parameters for 68K
START	LA	R1,IOWADR,,		: base-address of I/O Window
	LA	R0,ORING,,		: address of output-ring
	SVC	SYS,XLATE
	 J	XLCRSH
	ST	R0,.ORING,R1		: physical address of output-ring
	LHI	R0,ORSIZE		: size of output-ring
	STH	R0,.ORSIZ,R1
	LA	R0,IRING,,		: address of input-ring
	SVC	SYS,XLATE
	 J	XLCRSH
	ST	R0,.IRING,R1		: physical address of input-ring
	LHI	R0,IRSIZE		: size of input-ring
	STH	R0,.IRSIZ,R1
	LA	R0,FASTC,,		: FASTC address
	SVC	SYS,XLATE
	 J	XLCRSH
	ST	R0,.FASTC,R1		: FASTC physical address
	AIS	R0,SLOWC-FASTC		: SLOWC address
	ST	R0,.SLOWC,R1		: SLOWC physical address
	LA	R0,REGDMP-IOWADR,R1	: REGDMP address
	SVC	SYS,XLATE
	 J	XLCRSH
	ST	R0,.CDUMP,R1		: REGDMP physical address
 if	EBDUMP
	LA	R0,S3ADDR,,		: Memory-dump area
	SVC	SYS,XLATE
	 J	XLCRSH
	LI	R2,40000		: size of area
 else	:not EBDUMP
	LIS	R0,0			: no dump area
	LIS	R2,0			:  ...zero-length
 ei	:EBDUMP
	ST	R0,.MDUMP,R1		: Memory-dump physical address
	ST	R2,.MSIZE,R1		:  ...and size
	LA	R0,SYNC			: SYNC address
	SVC	SYS,XLATE
	 J	XLCRSH
	ST	R0,.SYNC,R1		: SYNC physical address

	LIS	R0,0			: Logical unit 0 (and constant)
	ST	R0,STCRA		: initialize Status area
	ST	R0,STATIM		: 
	ST	R0,SSRCRA		: 
	ST	R0,SSRTIM		: 
	LA	R2,STAREA		: set address of status area
	SVC	IO,CONIP		: connect processor:
:						R0 -	LU
:						R1 -	address of IOWindow area
:						R2 -	address of ISIS Status Area
	 J	SVCCRA

:	now running...set up for background
	LI	R0,01010101		: Set up speedometer
	ST	R0,BITS
	LI	R0,00FF00FF
	ST	R0,XBITS		: slot speedometer
	L	R3,FASTC,,		: reserve R3 for slot speedometer timeout


:	The main loop
MAIN	L	R2,XBITS		: our speedometer
	C	R3,FASTC,,
	JGFS	MAIN1
	AHI	R3,$A 60		: do our speedometer, again in 1/10 second
	RRL	R2,1
	ST	R2,XBITS
MAIN1	LH	R1,SYNC			: get a value
	TS	SYNC			: indicate to EBUS we've run again
	L	R0,BITS			: use value to shuffle bits
	RRL	R0,0,R1
	ST	R0,BITS
	XR	R0,R2			: pack EBUS speedometer with ours
	LB	R1,HSTAT
	STBR	R1,R0			: pack with host-state
	L	R1,SLOWC,,		: check time
	THI	R1,3
	JNFS	MAIN2			: for 3 seconds out of 4, show speedometer
	LHL	R0,HPARAM		: ...other second, show host parameters

MAIN2	STH	R0,FPANEL		: update front-panel
	SVC	DISMISS			: and dismiss
	L	R1,STCRA		: Any IPI MSG?
	CLHI	R1,3			: Crash MSG from 68K?
	JEFS	IPCRSH
	L	R1,SSRCRA		: SSR Crash?
	JGE	MAIN			: no
	JAL	R10,CRASH		: yes
	BC	0,0,R1*4,SSRCRC

IPCRSH	JAL	R10,CRASH
	BC	0,0,R1*4,IPICRC

XLCRSH	LCS	R0,1			: set -1
SVCCRA	ST	R0,CRATYP
	JAL	R10,CRASH		: Else, it's a failed attempt to Connect
	BC	0,0,R0*4,SVCCRC
	SUBTTL	EBUS -- Operations Monitor:

	LO	STATUS			: access STATUS

:	MACRO to print a number (in R0) on terminal
:	ARG	USE
:	1	Number of digits
:	2	Any sum of:  .S, .B, .Z, one of [ .D, .H, OR .O]
S.	EQ	80			: signed output
B.	EQ	20			: Blank fill
Z.	EQ	40			: Zero fill
D.	EQ	0A			: Decimal
O.	EQ	08			: Octal
H.	EQ	10			: Hexidecimal
	KILL	PRINTN,PRINTP,PRINTS	: insure no conflict
PRINTN	MACRO(ND,M2)[
	LHI	R1,(ND*100)!M2
	SVC	KIO,$A 10
]

:	MACRO to print a string, given the address
PRINTP	MACRO(ADDR)[ SVC	OUT,ADDR]

:	MACRO to print a string, given the string
PRINTS	MACRO(STR)[ KILL TO,AT
	PRINTP(AT)
	J	TO
AT	SC	STR
TO	HS	0]
	SUBTTL	EBUS -- Operations Monitor:  ?STAT Cmd. Handlers:  HELP, CODE, V, STATE



	DS.CMD(HELP,HELP)		: Print Command List
	DS.CMD(?,HELP)			: Print Command List
	DS.CMD(CODE,CODE)		: Print Banner (which code this is).
	DS.CMD(V,V)			: print versions
	DS.CMD(STATE,STATE)		: print host state

HELP	PRINTP(BANNER)
	PRINTS(/"8D"8AValid commands are:/)
	PRINTS(/"8D"8AEXIT or EXI - log off/)
	PRINTS(/"8D"8AQUIT or Q   - exit ?STAT (back to DDT)/)
	PRINTS(/"8D"8AHELP or ?   - print this list/)
	PRINTS(/"8D"8ACODE        - Describe the code in this slot/)
	PRINTS(/"8D"8AV           - Display the version number/)
	PRINTS(/"8D"8ASTATE       - Display the host state/)
	PRINTS(/"8D"8ARDUMP       - Display 68K register dump/)
 if	EBDUMP
	PRINTS(/"8D"8ADUMP        - Describe how to dump EBUS memory/)
 ei	:EBDUMP
	J	DSTART

CODE	PRINTP(BANNER)			: display banner
	J	DSTART

V	PRINTS(/Versions:  Slot code: /)
	LHI	R0,VERSIO
	PRINTN(2,H.)			: 2 hex digits, no fill
	PRINTP(DOT)
	LHI	R0,REVLEV
	PRINTN(2,Z.!H.)			: 2 hex digits, zero-fill
	PRINTS(/"BB  EBUS code: /)
	LB	R0,EVERN,,
	PRINTN(2,H.)			: 2 hex digits, no fill
	PRINTP(DOT)
	LB	R0,EVERN+1,,
	PRINTN(2,Z.!H.)			: 2 hex digits, zero-fill
	J	DSTART

:	Print host state
STATE	LH	R0,HSTAT
	JN	STATE1			: skip if there is a host
	PRINTS(/"8D"8ANo host connected!/)
	J	DSTART			: and quit

STATE1	PRINTS(/"8D8AHost /)
	LB	R0,HSTAT		: print host number
	PRINTN(5,D.)			: 5 decimal digits, no fill
	PRINTS(/ is /)
	LB	R0,HPARAM		: print state based on ans/shut/down
	SIS	R0,1			: down?
	JNFS	STATE2			: no
	PRINTS(/Down/)			: yes...say so
	J	DSTART			: and quit

STATE2	JLFS	STATE3			: skip if answered
	PRINTS(/Shut/)
	JFS	STATE4

STATE3	PRINTS(/Answered/)
STATE4	PRINTS(/"2C number of active circuits is /)
	LB	R0,HSTAT+1		: get number
	PRINTN(3,D.)			: 3 decimal digits, no fill
	J	DSTART

BANNER	SC	/"8A"8D"8AEBUSOM...EBUS Operations Monitor"8A/
CRLF	SC	/"8A"8D/
DOT	SC	/./
	SUBTTL	EBUS -- Operations Monitor:  ?STAT Command Handlers:  DUMP

	DS.CMD(RDUMP,RDUMP)		: dump registers
 if	EBDUMP
	DS.CMD(DUMP,DUMP)		: dump EBUS memory

DUMP	PRINTS(/"8D"8AIn order to perform a dump of EBUS [68K] memory into/)
	PRINTS(/"8D"8AEngine memory"2C activate MACSBUG and type"3A"8A/)
	PRINTS(/"8D"8A  BM 0 3FFFF E/)
	LA	R0,S3ADDR,,
	SVC	SYS,XLATE
	 NOP	0
	PRINTN(5,Z.!H.)			: 5 hex digits, zero-fill
	PRINTP(CRLF)
	J	DSTART
 ei	:EBDUMP


RDUMP	LA	R2,REGDMP,,		: address of dump area
	L	R0,COD,R2		: any dump?
	JN	DUMP1			: yes
	PRINTS(/No Register Dump/)
	J	DSTART

DUMP1	PRINTS(/"8D"8ACode: /)
	PRINTN(8,B.!H.)			: 8 hex digits, blank fill
	PRINTS(/"8D"8APC:     /)
	L	R0,PC,R2
	PRINTN(6,Z.!H.)			: 6 hex digits, zero fill
	PRINTS(/"8D"8AD0:   /)
	L	R0,D0,R2
	PRINTN(8,Z.!H.)			: 8 hex digits, zero fill
	PRINTS(/    A0:   /)
	L	R0,A0,R2
	PRINTN(8,Z.!H.)			: 8 hex digits, zero fill
	PRINTS(/"8D"8AD1:   /)
	L	R0,D1,R2
	PRINTN(8,Z.!H.)			: 8 hex digits, zero fill
	PRINTS(/    A1:   /)
	L	R0,A1,R2
	PRINTN(8,Z.!H.)			: 8 hex digits, zero fill
	PRINTS(/"8D"8AD2:   /)
	L	R0,D2,R2
	PRINTN(8,Z.!H.)			: 8 hex digits, zero fill
	PRINTS(/    A2:   /)
	L	R0,A2,R2
	PRINTN(8,Z.!H.)			: 8 hex digits, zero fill
	PRINTS(/"8D"8AD3:   /)
	L	R0,D3,R2
	PRINTN(8,Z.!H.)			: 8 hex digits, zero fill
	PRINTS(/    A3:   /)
	L	R0,A3,R2
	PRINTN(8,Z.!H.)			: 8 hex digits, zero fill
	PRINTS(/"8D"8AD4:   /)
	L	R0,D4,R2
	PRINTN(8,Z.!H.)			: 8 hex digits, zero fill
	PRINTS(/  A4(Rp): /)
	L	R0,A4,R2
	PRINTN(8,Z.!H.)			: 8 hex digits, zero fill
	PRINTS(/"8D"8AD5:   /)
	L	R0,D5,R2
	PRINTN(8,Z.!H.)			: 8 hex digits, zero fill
	PRINTS(/  A5(Rs): /)
	L	R0,A5,R2
	PRINTN(8,Z.!H.)			: 8 hex digits, zero fill
	PRINTS(/"8D"8AD6:   /)
	L	R0,D6,R2
	PRINTN(8,Z.!H.)			: 8 hex digits, zero fill
	PRINTS(/  A6(Rd): /)
	L	R0,A6,R2
	PRINTN(8,Z.!H.)			: 8 hex digits, zero fill
	PRINTS(/"8D"8AD7:   /)
	L	R0,D7,R2
	PRINTN(8,Z.!H.)			: 8 hex digits, zero fill
	PRINTS(/  A7(SP): /)
	L	R0,A7,R2
	PRINTN(8,Z.!H.)			: 8 hex digits, zero fill
	J	DSTART

	FO	STATUS			: de-access STATUS

	EM	: EBUS
        SUBTTL  Control Table Allocation and Diagnostics - FINISH.LIB
 
:**********************************************************************
:                                                                     *
:       This program is the sole property and confidential            *
:       information of Tymshare, Inc., and may not be copied          *
:       in whole or in part or disclosed to any third party           *
:       without the prior written consent of Tymshare.                *
:                                                                     *
:**********************************************************************

	RA	0		:	FINISH.LIB

:	this file should always be assembled LAST!

:ALLOCATE FPANEL IF USER HAS NOT
  IF	\FPANEL
  ELSE
	SEG	A.DATA
FPANEL  HS      1
  EI
  IF	\FRISIS
  ELSE
	SEG	0
FRISIS	HS	$A (MAXPRT+15)/16
  EI
  IF	\TOISIS
  ELSE
	SEG	0
TOISIS	HS	$A (MAXPRT+15)/16
  EI

  IF	1-(\PATCH0)
	SEG	0
PATCH0	WS	20	:SEGMENT ZERO PATCH AREA
  EI
  IF	1-(\PATCH1)
	SEG	1
PATCH1	WS	20	:SEGMENT ONE PATCH AREA
  EI
  IF	1-(\PATCH2)
	SEG	2
PATCH2	WS	20	:SEGMENT TWO PATCH AREA
  EI

	IF	\APROT0
	ELSE
APROT0	EQ	6	:EXECUTION PROTECTED
	REMARK	%DEFAULT AREA PROTECTIONS ASSUMED.%
	EI
	IF	\APROT1
	ELSE
APROT1	EQ	5	:WRITE PROTECTED
	EI
Q1	EQ	2
	RE	0C
	IF	\APROT|Q1|
	ELSE
APROT|Q1| EQ	6	:EXECUTION PROTECTED
	EI
Q1	EQ	Q1+1
	ER

:	NAD ALLOWS MORE THAN 10000X TO BE PLACED IN ONE "SEG".
:	WE MUST THEREFORE GO INTO EACH SEG AND IF > 10000X ORG BACK TO
:	10000X AND THEN ENTER THE NEXT SEG TO DEPOSIT THE REMAINDER.
:	THIS, OF COURSE, ASSUMES THAT THE NEXT SEG IS EMPTY.
:	A CHECK IS MADE TO INSURE THIS.

Q1	EQ		0
	RE		0E		:FOR Q1 = 0 TO 0E
	  SEG		Q1
Q3	  EQ		10000*(Q1+1)	:  Q3 = UPPER BOUND FOR THIS SEGMENT
	  IF		.-Q3		:  IF THIS SEGMENT OVERFLOWED
Q2	    EQ		.-Q3		:    Q2 = LENGTH OF OVERFLOW
	    ORG		Q3		:    ORG TO MAXIMUM
	    IF		0E-(Q1+1)	:    IF THE NEXT SEG IS NOT E
	      SEG	Q1+1		:      GO INTO NEXT SEG
	      IF	(.-Q3)		:      IF SEG ALREADY IN USE
	        SEG	Q1		:        RETURN TO PREVIOUS SEG
	      ELSE			:      ELSE
APROT|Q1+1|	EQ	APROT|Q1|	:        COPY PROTECTION
	      EI			:      ENDIF
	    EI				:    ENDIF
	    ORG		.+Q2		:    ADD OVERFLOW TO THE CURRENT SEG
	  EI				:  ENDIF
Q1	  EQ		Q1+1		:NEXT Q1
	ER

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
	RE	0F
SEG|Q|	EQ	SEG|Q|&07FFFFFFF
	IF	SEG|Q|%(Q*10000)
	REMARK	%"SEG
	NUMBER	Q
	REMARK	" has been redefined
	EI
:	DEFINE SIZES
	SEG	Q
S|Q|SIZE EQ	.-SEG|Q|
Q	EQ	Q+1
	ER
	LIST

:	BITCH IF ANY SEGMENTS OVERFLOW
	NOLIST
Q	EQ	0;	RE	0F;	IF	S|Q|SIZE-10000;	REMARK	%Segment 
	NUMBER	Q;	REMARK	- overflow, exceeded by 
	NUMBER	($0S|Q|SIZE-10000)$A;	REMARK	d bytes%;	EI
Q	EQ	Q+1;	ER
	LIST

      IF        \XMEMRY
      ELSE
XMEMRY  EQ      0
      EI

:	SET UP CTA TABLE
  IF	SESIZE
	REMARK	%SEGMENT E IS RESERVED FOR CTA. REMOVE OTHER ALLOCATIONS.%%
  ELSE
	SEG	0E
      IF        XMEMRY
CTA     WC      CNTRL+$01000    :Control flags
      ELSE
CTA	WC	CNTRL	:CONTROL FLAGS
      EI

	WC	CTASIZ	:SIZE OF CTA AREA
AREAS
Q	EQ	0
	RE	0E
	WC	S|Q|SIZE	:AREA SIZE
Q	EQ	Q+1
	ER

	HC	0E	:NUMBER OF PROTECTION BYTES
Q	EQ	0
	RE	0E
	BC	APROT|Q|
Q	EQ	Q+1
	ER

	WC	ENTRY	:ENTRY POINT ADDRESS
    IF	\DSTART
	WC	DSTART	:DDT START ADDRESS
    ELSE
	WC	0	:NO USER DDT CODE
    EI

	WC	FPANEL	:ADDRESS OF FRONT PANEL DISPLAY CELL

	WC	HOSTS	:HOST TABLE ADDRESS
	WC	PORTS	:PORT TABLE ADDRESS
	WC	PTABLE	:PERMUTER TABLE ADDRESS
	WC	IRING	:INPUT RING ADDRESS
	WC	ORING	:OUTPUT RING ADDRESS
	WC	FRISIS	:ADDRESS TO INPUT BACKPRESSURE BIT ARRAY
	WC	TOISIS	:ADDRESS OF OUTPUT BACKPRESSURE ARRAY
  IF	\PCTTBL
	WC	PCTTBL	:PROJECT CODE TERMINATION TABLE
  ELSE
	WC	0	:NULL TABLE
  EI
COREST	WS	1	:ABSOLUTE CORE ADDRESS OF START OF SLOT
	HC	MAXHST	:MAXIMUM HOSTS FOR SLOT
	HC	MAXPRT	:HIGHEST PORT NUMBER FOR SLOT
	HC	IRSIZE	:INPUT RING SIZE
	HC	ORSIZE	:OUTPUT RING SIZE
SLOTNO	HS	1	:SLOT NUMBER (SUPPLIED BY ISIS)
VERREV	HS	0
  IF	\VERSION
	BC	VERSION	:VERSION NUMBER
  ELSE
	BC	0
  EI
  IF	\REVLEV
	BC	REVLEV	:REVISION LEVEL
  ELSE
	BC	0
  EI

    IF	\QSTART
	WC	QSTART	:DDT QUERRY START ADDRESS
    ELSE
	WC	0	:NO USER CODE
    EI
        HC      EMMAC0-CTA
    IF  \NMACSS
        HC      NMACSS          :Number of MAC Register Sets
    ELSE
        HC      0               :No extended MAC sets
    EI
        HC      0               :Segments to be saved

    IF \PRODID
    ELSE
      IF  \HID0
PRODID  EQ      HID0            :Define PRODID as alias
      ELSE
      EI  :HID0
    EI :PRODID

    IF \PRODID
      IF PRODID-$a255
        REMARK  %PRODID is too large%
        QUIT    1
      EI
      IF PRODID-$a48
      ELSE
        REMARK  %PRODID is too small%
        QUIT    1
      EI
    ELSE
        REMARK  %PRODID - Slot Product id must be defined%
        QUIT    1
    EI :PRODID
        HC      PRODID          :slot Product id

	WS	10	:RESERVED FOR FUTURE EXPANSION

HOSTS	HS	0	:BEGINNING OF HOST TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HOST|Q|
	HC	HOST|Q|	:HOST NUMBER
    ELSE
	HC	0	:NO ASSEMBLED IN HOST NUMBER
    EI
Q	EQ	Q+1
	ER

PORTS	HS	0	:BEGINNING OF PORT TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HPRT|Q|
	HC	HPRT|Q|
    ELSE
	HC	0	:NO ASSEMBLED IN NUMBER OF PORTS
    EI
Q	EQ	Q+1
	ER

PTABLE	HS	MAXPRT+1	:PERMUTER TABLE

EMMAC0  WS      0               :Extended Memory MAC Register sets
    IF XMEMRY
      IF \NMACSS
        EXPMAC
        REMARK  %Using Extended Memory Option%
        NUMBER  $a NMACSS
        REMARK  MAC Register sets allocated%
        NUMBER  $a EMEMR3
        REMARK k allocated on non-zero meg
      ELSE
        REMARK  %NMACSS must be specified with extended memory%
        QUIT    1
      EI        :NMACSS
    EI          :XMEMRY

CTASIZ	EQ	.-CTA	:CTA AREA SIZE
SESIZE	EQ	.-CTA	:SEG E SIZE
  EI

:	TELL MEMORY REQUIREMENTS
Q	EQ	0
QQ	EQ	0
QQQ	EQ	0
	RE	0F
	IF	S|Q|SIZE
	REMARK	%SEGMENT 
	NUMBER	Q
	REMARK	-length 
QQQ	EQ	S|Q|SIZE
	NUMBER	$A QQQ
	REMARK	d, requires 
Q3	EQ	(S|Q|SIZE+0FF)&(@0FF);	NUMBER	Q3
QQ	EQ	QQ+Q3
	REMARK	x bytes of core.
	EI
Q	EQ	Q+1
	ER

:	GIVE FINAL SIZES
	REMARK	%       
	NUMBER	(QQ+$03FF)/400$A	:FORCE TO BASE 10 FOR OUTPUT
	REMARK	d K-bytes of core

	UN		:spew out all undefined symbols
:@2g