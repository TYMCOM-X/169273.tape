                                                                  June 23, 1986







                            ***** ****  *   *  ****
                            *     *   * *   * *    
                            ****  ****  *   *  *** 
                            *     *   * *   *     *
                            ***** ****   ***  **** 

                         *****     *   *      ****   
                           *       ** **     *       
                           *       * * *      ***    
                           *       *   *         *   
                         *****  *  *   *  *  ****   *

                            PDP-10 E-BUSS INTERFACE
                      INTERNAL MAINTENANCE SPECIFICATION

                                    TYMNET
                        NETWORK TECHNOLOGY DEVELOPMENT
                                 June 23, 1986

















     ====================================================================
     |   Tymnet,  Inc.'s  proprietary  rights  are  included  in  the   |
     |   information disclosed herein.   The recipient,  by receiving   |
     |   this document,  agrees  that neither this  document nor  the   |
     |   information  disclosed  herein nor any part thereof shall be   |
     |   reproduced or transferred to  other  documents  or  used  or   |
     |   disclosed  to  others  for  manufacturing  or  for any other   |
     |   purpose except  as  specifically authorized  in  writing  by   |
     |   Tymnet, Inc.                                                   |
     ====================================================================




                          Internal Maintenance Specification           EBUS.IMS
                                                                  June 23, 1986







                                   TABLE OF CONTENTS

        Section                                                            Page



        1.   Introduction                                                     1


        2.   Data Structures                                                  2
          2.1   Data -- byte-array                                            2
          2.2   Linked Lists                                                  2
          2.3   Port Descriptor                                               3


        3.   Initialization                                                   5
          3.1   IPI Slot and XPI Initialization                               5
          3.2   EBUS Initialization                                           6
          3.3   Crash Processing                                              6
             3.3.1    "Normal" Crashes                                        7
             3.3.2    "Fatal" Crashes                                         7

          3.4   The EXEC process                                              8
          3.5   The EXEC Loop                                                 8


        4.   Host and Port Management                                        10
          4.1   Host management                                              10
          4.2   Port Management                                              11
          4.3   ISIS-port Management                                         11


        5.   Host Output                                                     13


        6.   Input from ISIS                                                 20


        7.   Block-I/O                                                       28
          7.1   Request for Ports                                            28
          7.2   Block-Output                                                 28
          7.3   Block-Input                                                  30


        8.   I/O and Buffer Logic                                            37
          8.1   Engine DMA Access                                            37
             8.1.1    ISIS-ring Output Routines                              38
                8.1.1.1     Room                                             38

                          Internal Maintenance Specification           EBUS.IMS
                                                                  June 23, 1986


                8.1.1.2     WAITIS                                           38
                8.1.1.3     WAITISW                                          38
                8.1.1.4     SLOR                                             39
                8.1.1.5     PUTCH                                            39
                8.1.1.6     PUTH                                             39
                8.1.1.7     PUTW                                             40
                8.1.1.8     ELOR                                             40
                8.1.1.9     SENDQI                                           40

             8.1.2    ISIS-ring Input Routines                               40
                8.1.2.1     LOOK                                             41
                8.1.2.2     GETCH                                            41
                8.1.2.3     GETH                                             41
                8.1.2.4     GETW                                             41
                8.1.2.5     ELIR                                             42
                8.1.2.6     FLUSH                                            42

          8.2   PDP (Black-Box) I/O                                          42
             8.2.1    SETBLKA                                                44
             8.2.2    Output To PDP                                          44
                8.2.2.1     WR10R                                            44
                8.2.2.2     PUTNOT0                                          45
                8.2.2.3     HCRASH                                           45
                8.2.2.4     PUTPDPL                                          45
                8.2.2.5     PUTPDPR                                          45
                8.2.2.6     PUTIFC                                           46
                8.2.2.7     PUTOEC                                           46
                8.2.2.8     FDRGSZ                                           46
                8.2.2.9     WAITPDP                                          47
                8.2.2.10    WRPDP                                            47
                8.2.2.11    WRDAT                                            47
                8.2.2.12    WAITDAT                                          48
                8.2.2.13    WRBLK                                            48
                8.2.2.14    GETBLK                                           48

             8.2.3    Input From PDP                                         48
                8.2.3.1     RD10R                                            49
                8.2.3.2     GETPDPL                                          49
                8.2.3.3     GETPDPR                                          49
                8.2.3.4     GETOFC                                           50
                8.2.3.5     GETIEC                                           50
                8.2.3.6     RDPDPRP                                          50
                8.2.3.7     RDPDP                                            51
                8.2.3.8     RDBLK                                            51

             8.2.4    Buffer Routines                                        51
                8.2.4.1     DGCI                                             51
                8.2.4.2     DWCI                                             52
                8.2.4.3     DEMPTY                                           53


        9.   Debugging and Diagnostic Tools                                  54
          9.1   TRACE Assembly Switches                                      54

                          Internal Maintenance Specification           EBUS.IMS
                                                                  June 23, 1986


          9.2   Hardware Diagnostic Routines                                 55
             9.2.1    $7C00 Test                                             55
             9.2.2    $7D00 Test                                             56
             9.2.3    $7E00 Test                                             56


                                     APPENDICES
                                     ==========


        I.   Summary of Base-to-Host Messages                                58


        II.  Summary of Host-to-Base Messages                                59


                                      INDEX
                                      =====                                  61




































                          Internal Maintenance Specification           EBUS.IMS
        Introduction                                              June 23, 1986






                                   1 -  Introduction


             This document is  primarily oriented toward code  maintenance, and
        will address hardware only peripherally.

               NOTE:   The product contains  code executing both  in the
                       Engine,  and  in  the  XPI/68K  processor.   This
                       document  primarily  addresses  the  latter code;
                       particular  implementation details  are presented
                       in the form of  "C" code (even though  the actual
                       implementation is in ASM68K assembly-language).

             The physical configuration can be represented as:

        ENGINE/ |       ---------       ---------       ---------
        TYMNET-2| ----- |  XPI  | ----- |Blk Box| ----- | Host  |
        /ISIS   |       ---------       ---------       ---------

             TYMNET-2 / ISIS /ENGINE technology is well defined, and documented
        elsewhere (see ISIS2.DOC, and ENGINE.DOC for details).

             XPI  is  a  M68000-based  processor  peripheral  to   the  Engine,
        currently in use for MXP,  and intended as the vehicle for  many future
        products;  thus it also is easily maintainable.  Because it  is closely
        coupled  to  the  Engine  (via  direct  DMA  transfers),  it   is  also
        susceptible to bandwidths higher  than can be provided by  the Varians.
        Being an  independent peripheral  processor, it is  capable of  a great
        deal of functionality without loading down its resident Engine.

             The "Black Box" is the identical hardware once used on  the Varian
        Bases.


















        1                 Internal Maintenance Specification           EBUS.IMS
        Data Structures                                           June 23, 1986






                                 2 -  Data Structures


             There are a number of data structures used within EBUS.  These are
        described in this section, along with associated information.






                                2.1  Data -- byte-array


             One data structure used continuously is defined as:

                char    DAT[32];        /* Data-array */

        #define DAT1 DAT[0]             /* name of first byte */
        #define DAT2 DAT[1]             /* name of second byte */
        #define DAT3 DAT[2]             /* name of third byte */
        #define DAT4 DAT[3]             /* name of fourth byte */
        #define DAT5 DAT[4]             /* name of fifth byte */






                                   2.2  Linked Lists


             Another data structure used continuously is defined as:

        typdef  struct  LIST            /* linked-list descriptor */
        {
        struct  LIST    *next;          /* pointer to next element*/
                short   port;           /* port number for this element */
        }       list;

             This is referenced via:

                list    FREEBLK[2*MAXPORT]; /* linked-list of free blocks */
                list    *BLKFRE;        /* * beginning of free-list */
                list    *BKIFRE;        /* * beginning of Bin-list */
                list    *BKOFRE;        /* * beginning of Bout-list */
                list    *BUFFRE;        /* * beginning of Buf-list */
                list    *SAVE1;         /* * beginning of current-list */


        2                 Internal Maintenance Specification           EBUS.IMS
        Data Structures                                           June 23, 1986


                                 2.3  Port Descriptor


             The primary data structure is a Port descriptor, of format:

        /*      Port Descriptor Definition      */
        typedef struct
        {       char    P_NUM;          /* port number */
                char    P_FLAGS;        /* port status flags */
        #define PF_ACT 1        /* port active flag */
        #define PF_OBP 2        /* Output Back-pressure applied (by ISIS) */
        #define PF_IBP 4        /* Input Back-pressure applied (by us) */
        #define PF_HBP 8        /* Input Back-pressure applied (by Host) */
        #define PF_BKO 16       /* Block-Output active */
        #define PF_BKI 32       /* Block-Input active */
        #define PF_BFD 64       /* Block FilleD */

                char    XMITLMT;        /* transmit limit */
                char    IBRATE;         /* Input baud-rate */
                char    AUXKEY;         /* hold AUX-key here */

                /* Block-out: */
                long    BO_TAR;         /* (PDP) block start addr. */
                short   BO_BYT;         /* byte position within word */
                short   BO_TCN;         /* output count (remaining) */

                /* Block-input: */
                long    BI_TIM;         /* time (FASTC) last activity */
                long    BI_TAR;         /* (PDP) block start address */
                short   BI_TCN;         /* input count (total) */
                short   BI_LCN;         /* input count (so far) */
                short   BI_BYT;         /* pos. within current word */

                /* Buffer parameters: */
                short   BB;             /* bufferlet-begin */
                short   BE;             /* bufferlet-end */
                short   BCT;            /* count of characters */
        }       PD;     

             These parameters are recorded in an area:

                PD      PORTS[MAXPORT]; /* array of port-descriptors */

             They are referenced via:

                PD      *Rp;            /* * current port-descriptor */

             This is generated in the function:






        3                 Internal Maintenance Specification           EBUS.IMS
        Data Structures                                           June 23, 1986


        SETPORT(p)                      /* set up port-number */
        short   p;
        {       PORTNO = p;             /* record value */
                Rp = *PORTS[p];         /* set pointer */
                return;
        }
















































        4                 Internal Maintenance Specification           EBUS.IMS
        Initialization                                            June 23, 1986






                                  3 -  Initialization


             When the 68K EBUS  code first begins execution,  initialization is
        performed.

             Since  there  are a  concert  of programs  and  processors working
        together, we will consider the successive phases of initialization.






                         3.1  IPI Slot and XPI Initialization


             When the IPI slot first is activated, the 68K is HALTED!   IPI may
        thus safely initialize itself without interactions from the 68K.

             The IPI initialization sequence is:

           1.  The  CRASH Library  routine initializes  the slot's  ISIS rings,
               places a Diagnostic  report (specifying start-up) into  the ISIS
               output-ring, and performs a  RESTART SVC to connect to  the ISIS
               DISPATCHER,  and trap  errors.   Control is  then  transfered to
               IPI's START address:
           2.  IPI  initializes the  68K parameter  block (setting  up physical
               Engine Addresses where  appropriate), the ISIS  parameter block,
               and various other areas.  It then:
           3.  Performs  the  CONNECT-IO  SVC  for  the  68K,  with  parameters
               specifying the  addresses of  the 68K  parameter block,  and the
               ISIS parameter block.
           4.  ISIS sets up parameters, and activates the 68K to run MACSbug to
               load the 68K from the memory image within ISIS.
           5.  MACSbug reads the  parameters, performs the load,  and transfers
               to the load start-address (EBUS label "ENTRY"), with pointers to
               the ISIS  input and  output communications areas  in A1  and A2,
               respectively.
           6.  ENTRY  "grabs"  the  ISIS interrupt  (by  placing  a  pointer to
               "BOBCODE" at $13C), and  records the parameters in  "ISTOME" and
               "METOIS", respectively.   It then places  a (long) value  "2" at
               the address specified  by METOIS, generates an  XPI-interrupt to
               the Engine and HALTS!
           7.  Upon receiving the XPI-interrupt, ISIS places new  parameters at
               its ISTOME, and interrupts the  XPI card, thus taking it  out of
               HALT.
           8.  The  Interrupt is  intercepted  by BOBCODE,  which  verifies the
        5                 Internal Maintenance Specification           EBUS.IMS
        Initialization                                            June 23, 1986


               first parameter is $x4xxxxxx (long), and if so, proceeds to step
               9.   If  the parameter  has  a value  of  $x5xxxxxx  (long), the
               interrupt is  ignored;  any  other value is  cause to  crash and
               halt the XPI card.
           9.  The  second parameter  is read  from the  Engine, saved  both at
               "SLTOME" and "METOSL", the value "4" (long) is placed at METOIS,
               an  interrupt is  generated to  the Engine  (to verify  that the
               parameters have been accepted), and control is transfered to the
               EBUS initialization routine.






                               3.2  EBUS Initialization


             The  EBUS  initialization  routine first  initializes  an  area of
        storage to zero.

             It then recovers the pointer at SLTOME;  this is a pointer  to the
        IPI parameters.  The IPI  parameters are read and  recorded, converting
        the  Engine  Physical  Addresses  into  XPI  physical  addresses  where
        necessary.

             Next,  it initializes  additional areas:   Bufferlets,   the Free-
        Block list, and the Port Descriptors.

             Finally, it  checks to  see if the  host is  already up.   If not,
        control is transfered to the EXEC loop;  Otherwise, the host input-ring
        parameters are  located, and  an 03  host-message (Reset  Interface) is
        sent  to  the  host  (to  permit  synchronization)  before  control  is
        transfered to EXEC.






                                 3.3  Crash Processing


             EBUS supports two types of crashes: Normal and Fatal.










        6                 Internal Maintenance Specification           EBUS.IMS
        Initialization                                            June 23, 1986


                    3.3.1  "Normal" Crashes

             A  "Normal"  (i.e.,  non-fatal)  Crash  occurs  for  a  variety of
        reasons, such as an invalid message received from the host.

             In all such cases, control is transfered to VCRASH:

           1.  The Stack is reset;
           2.  The Ebuss is reset;
           3.  The Host is reported down to ISIS, and all circuits are Zapped;
           4.  The Host is crashed;
           5.  The ISIS input-ring is emptied;
           6.  Control is transfered to EXEC.

             Reasons for crashing are:

           $00 -  No KEY received from Host;
           $03 -  Bad KEY received from Host;
           $04 -  Bad message-type from Host;
           $08 -  MIC timeout;
           $09 -  MIC parity error;
           $0A -  MIC too busy too long;
           $15 -  WRE crash;





                    3.3.2  "Fatal" Crashes

             A  Fatal  crash  is  catastrophic!   The  sequence  of  operations
        performed is:

           1.  The address detecting the fatal condition is recorded;
           2.  A Register-dump is performed into Engine (within the  EBUS slot)
               memory;
           3.  A memory-dump is performed into Engine memory;
           4.  The host is crashed;
           5.  The crash reason (long;  from CODCASH) is placed at METOIS, with
               the low byte containing a "3" to indicate a fatal crash;
           6.  An XPI-interrupt is generated to the Engine;
           7.  The XPI-card is HALTED!

             Fatal Crash Reasons are:

           $12000003 -  GCI crash;
           $14000003 -  WCI crash;
           $50000003 -  Bad ISIS message;
           $60000003 -  Bad Stack Usage;
           $82000003 -  Buss Error
           $83000003 -  Address Error
           $84000003 -  Illegal Instruction
           $ED000003 -  Split Character-pair from buffer;

        7                 Internal Maintenance Specification           EBUS.IMS
        Initialization                                            June 23, 1986


           $EC000003 -  Told to crash by Engine;
           $EF000003 -  Does not understand what told to do by Engine;






                                 3.4  The EXEC process


             The EXEC process itself performs two functions:

             It  verifies that  the  Stack is  not accumulating  (i.e.,  if the
        Stack-pointer  is  not  at   STKTOP,  some  routines  are   leaving  an
        accumulation of garbage on the stack);  this condition results in a $60
        fatal crash.

             It waits in  a loop until it  "sees" that the IPI  background code
        has  executed (via  the ".SYNC"  cell,  which IPI  sets to  -1  at each
        background execution).  It then clears that cell, and proceeds  with an
        "EXEC LOOP".






                                  3.5  The EXEC Loop


             Rather  than  a  small  code-loop  which  calls  a  succession  of
        routines,  the EBUS  Exec-loop is  distributed among  all of  the major
        functional modules,  each of which  exits to the  next module  when its
        activity is completed.  The sequence of modules called is:

           Host Output;
           ISIS Input;
           Periodic (Half-second) Host State and Consistence Checking;
           Block Output;
           Block Input timeout, Buffer to Block, and Buffer to Host processing.

             Each execution  of slot-background a  "semaphore" (at  the address
        within the Engine, specified by .SYNC) is set to -1 by the  slot.  EBUS
        will not begin execution until it "sees" the semaphore being  less than
        0.  EBUS then sets the  semaphore to +1, and performs one  execution of
        it's EXEC-loop.  When done, it  sets the semaphore to 0.  The  value of
        the semaphore at each background-execution determines the  direction of
        the bit movement.

             Synchronization  occurs  when  the EBUS  code  completes  one pass
        through it's  EXEC-loop per slot  background-execution.  In  this case,
        the bit will remain fixed.

        8                 Internal Maintenance Specification           EBUS.IMS
        Initialization                                            June 23, 1986


             If, however, the EBUS takes longer than two back-ground  cycles to
        execute,  the bit  will  advance to  the  right one  position  for each
        occurrence.  (And if the EBUS code stops, the bit will advance  so fast
        that it "blurs" out.)

             If EBUS takes longer than one back-ground cycle, but less  than 2,
        then the bit will advance to the left one position for each occurrence.















































        9                 Internal Maintenance Specification           EBUS.IMS
        Host and Port Management                                  June 23, 1986






                             4 -  Host and Port Management


             There are a collection  of routines for Host and  port management.
        These are described in this section.






                                 4.1  Host management


             These routines deal with the Host itself:

        /*      Verify the Host Key     */
        DOKEY()
        {       if ( GETPDPR( $68 ) != $DFA68CB2 )
                    return FALSE;       /* Right KEY bad */
                if ( (char) P10DAH != $CD )
                    return FALSE;       /* Left KEY bad */
                PUTPDPR(0);             /* Key matched...reset to 0 */
                return TRUE;
        }



        /*      Report host status to ISIS      */
        HREPRT()
        {       WAITIS(14);             /* we'll need 14 bytes */
                SLOR(0,$10);            /* port-0 Message $10 */
                PUTCH(0);               /* padding */
                PUTH(HOSTN);            /* Host number */
                PUTH(HOSTP);            /* # ports */
                PUTH(0);                /* relative Host 0 */
                PUTH(HSTAT);            /* HSTAT | Hkey=0 */
                PUTH(PRODID);           /* no IIX | PROD-ID */
                ELOR();
                return;
        }









        10                Internal Maintenance Specification           EBUS.IMS
        Host and Port Management                                  June 23, 1986


                                 4.2  Port Management


             It is necessary to perform the "soft-" shut and answer functions:

        /*      Increment port-count and shut if necessary      */
        IPORT()
        {       if ( ++NPORTS > MXPORT ) /* count another port */
                {    PFULL = 1;         /* set "port-full" flag */
                    SOFT();             /* report it */
                }
                return;
        }



        /*      Decrement port-count and re-answer if possible  */
        DPORT()
        {       if ( --NPORTS = MXPORT ) /* count another port */
                {    PFULL = 0;         /* clear "port-full" flag */
                    SOFT();             /* report it */
                }
                return;
        }



        /*      Report soft- answer/shut        */
        SOFT()
        {       WAITIS(10);             /* we'll need 10 bytes */
                SLOR(0,$A);             /* port-0 message $A */
                PUTCH(0);               /* padding */
                PUTH(HOSTN);            /* host # */
                PUTH(PFULL-1);          /* soft answer/shut */
                PUTH(0);                /* relative host # */
                ELOR();
                return;
        }






                               4.3  ISIS-port Management


             While the host  is not available, it  is still necessary  to purge
        the ISIS input-ring of  messages.  These may be present  either because
        of a  race-condition, or  because the messages  are always  supplied by
        ISIS.

             The routine which does this is:

        11                Internal Maintenance Specification           EBUS.IMS
        Host and Port Management                                  June 23, 1986


        /*      Flush ISIS ring */
        EMPTY()
        {       /*  type  9E 9F A0 A1 A2 A3 A4 A5 A6 A7 */
            int IMMSZ[] = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0;

                /*  type  00 01 02 03 04 05 06 07       */
            int IPZSZ[] = 0, 0, 1, 6, 9, 5, 5, 8,
                /*      08 09 0A 0B 0C 0D               */
                        8, 4, 7, 4, 7, 0;
            while ( LOOK() != 0 )
            {   if ( PORTNO == 0 )
                {   if ( INTYBT > $0E ) ISMGER();
                    FLUSH( IPZSZ[INTYBT] );
                    continue;
                }
                if ( INTYBT == 0 )      /* Needle */
                {   SENDQI( PORTNO, $9F );
                    FLUSH( GETCH() );
                    continue;
                }
                if ( INTYBT == $B2 )    /* Psuedo-needle */
                {   SENDQI( PORTNO, $9F );
                    FLUSH( 3 );
                    continue;
                }
                if ( INTYBT > $9D )     /* control message */
                {   if ( INTYBT > $C1 ) ISMGER();
                    FLUSH( IMSSZ[INTYBT] );
                    continue;
                }
                FLUSH( INTYBT );        /* Data Message */
            }
            return;
        }




















        12                Internal Maintenance Specification           EBUS.IMS
        Host Output                                               June 23, 1986






                                   5 -  Host Output


             This section deals with messages received from the host.   Most of
        these will be transliterated, and forwarded to ISIS.

             Block-I/O will be treated in a seperate section.

               NOTE:   Host-output  is  "throttled"  by  counter "ORRN";
                       this limits host-output to no more  than <PDPOSZ>
                       PDP-words per EXEC-loop.

             The actual code follows (Note...for convenience, this is  shown as
        Function;  in reality, "return" means "goto ISISIN"):

        HOSTIN()
        {   while ( not HTDWN )         /* exit if Host down */
            {   PUTOEC();               /* tell Host where our Cursor is */
                if (ORRN < 0) break;    /* throttle us to 1 ring/invocation */
                GETOFP();               /* read PDP's cursor */
                if (PDPOFC==PDPOEC) break; /* quit if we've caught up */
                RDPDP();                /* get next word */
                TYPBYT = DAT1;          /* extract message-type */
                SETPORT(DAT2);          /* ..and port -- set up */
                if (not ROOM(GEHTLN()) goto HOUT2; /* abort if no room
                                                  to forward message */
                if ( TYPBYT > $80 )     /* text message */
                {       /* The message contains text (data) only */
                    TYPBYT -= $80;      /* # chars */
                    SLOR( PORTNM, TYPBYT );
                    char *next = DAT3;  /* cursor for fetching bytes */
                    while ( TYPBYT-- > 0 )
                    {   PUTCH(*next++);
                        if ( (TYPBYT > 0) && (next > DAT4)
                        {   RDPDP();    /* get another word */
                            next = DAT1; /* init. for new scan */
                        }
                    }
                    ELOR();
                    continue;
                }

                */      Control Message         */
                if (    TYPBYT==$16     /* these types require response */
                     || TYPBYT==$19
                     || TYPBYT==$1F
                     || TYPBYT==$22
                     || TYPBYT==$2E )
                {   FDRGSZ();           /* find space available */

        13                Internal Maintenance Specification           EBUS.IMS
        Host Output                                               June 23, 1986


                    if (INRGSP < 8)
                        goto HOUT2      /* abort if not enough space */
                }

                /*      Process individual Control-message Types        */
                switch (TYPBYT)
                {

                case 1:         /* Host Open */
                    int V = 0;

        OPSHT:      if (HSTAT == 1)     /* host was down */
                    {   NPORTS = 0;
                        while (*.SLOWC-HTM < 8); /* insure no "yoyo" */
                        HTM = *.SLOWC;
                    }
                    HSTAT = V;
                    HREPRT();           /* report new state */
                    break;



                case 2:         /* Host Shut */
                    V = 2; goto OPSHT;



                case 3:         /* Reset Interface */
                    HVERNO = (short) DAT3; /* record host version number */
                    EMPTY();            /* empty ISIS input-ring */
                    HODOWN();           /* set Host Down */
                    DAT1 = 4;           /* ACK it...type 4 */
                    DAT2 = DEBUG;       /* 0 = normal, 1 = debugging */
                    (short) DAT3 = VERSION;
                    WAITDAT();          /* wait and send ACK */



                case 4:         /* Reset Acknowledgement */
                    HVERNO = (short) DAT3; /* record host version number */
                    break;



                /*      The following cases all use common code SPEC    */
                case 8:         /* back-pressure On */
                    if ( Rp->P_FLAGS & PF_HBP != 0 )
                        break;          /* Ignore if repeat */
                    if ( Rp->P_FLAGS & PF_IBP != 0 )
                        break;          /* Ignore if we've applied it */
                    goto SPEC;          /* SPEC is common code */

                case 9:         /* back-pressure Off */

        14                Internal Maintenance Specification           EBUS.IMS
        Host Output                                               June 23, 1986


                    if ( Rp->P_FLAGS & PF_HBP == 0 )
                        break;          /* Ignore if repeat */
                    if ( Rp->BCT != 0 )
                        break;          /* Ignore if stuff buffered */
                    if ( Rp->P_FLAGS & PF_IBP == 0 )
                        break;          /* Ignore if we've applied it */
                    goto SPEC;          /* SPEC is common code */

                case 11:        /* Zapper */
                    if (PORTNO == 0)
                        break;  /* ignor for port 0 */
                    if ( Rp->P_FLAGS & PF_ACT != 0 )
                    {   DPORT();        /* port active...reduce count */
                        RBTALL();       /* turn port off */
                    }
                    goto SPEC1;

                case 10:        /* Gobbler */
                case 12:        /* Enter DEM */
                case 13:        /* Leave DEM */
                case 14:        /* Green Ball */
                case 15:        /* Red Ball */
                case 16:        /* Yellow Ball */
                case 17:        /* Orange Ball */
                case 18:        /* Hang-Up */
                case 19:        /* Enter Transparancy */
                case 20:        /* Leave Transparancy */
                case 49:        /* Enter Alternate Output Device */
                case 50:        /* Leave Alternate Output Device */
                                /* and, of course, 8, 9, and 11 too */
        SPEC:       if ( Rp->P_FLAGS & PF_ACT == 0 )
                        break;          /* ignor if inactive port */

        SPEC1:      SENDQI(PORTNO,SPTAB[TYPBYT]);
                    break;              /* send it and go to next one */



        /*      Case 22 and 24 together are used to request an AUX circuit.
                The PDP expects to have to deal with the Sup directly;  under
                ISIS, this is perfomed by the node code.  When PDP send the
                22, we verify that this is the only outstanding request, and
                then acknowledge it.  Subsequently, PDP send us successive
                logon characters, which we buffer until we receive <CR> or
                <;>, terminating the logon.  We then format up an ISIS Aux-
                Pseudo-needle request, and forward it to ISIS.  Subsequent
                operations are described in the ISISIN module.
        */
                case 22:        /* Supervisor Request */
                    if ( AUXX => 0 )    /* last request still in progress */
                        if (  ( ( *.SLOWC - AUXTIM ) & (-32) ) != 0  )
                        {   SEND17($0900); /* reject request, timeout */
                            break;

        15                Internal Maintenance Specification           EBUS.IMS
        Host Output                                               June 23, 1986


                        }
                    SEND17(0);          /* approve request */
                    AUXX = 0;           /* enable activity */
                    AUXQ = PORTNM;      /* ...for this port */
                    AUXTIM = *.SLOWC;   /* record time */
                    PUTIFC();           /* let PDP know */
                    break;

                case 24:        /* SUP Login Char */
                    if ( PORTNM != AUXQ )
                        break;          /* ignor if not the current port */
                    AUXC[AUXX++] = DAT3 | $80; /* save char */
                    if ( DAT3==';' || DAT3=='\n' ) /* CR or ; terminate */
                    {   WAITIS(AUXX+11); /* insure space in ISIS ring */
                        SLOR(0,8);      /* request Aux Circuit */
                        PUTCH(0);       /* padding */
                        PUTH((PORTNO);  /* local key */
                        PUTH(0);        /* no IIX */
                        PUTH(HOSTN);    /* Orig. host */
                        PUTCH(AUXX-1);  /* size */
                        for ( V=0 ; V<AUXX ; V++ )
                            PUTCH(AUXC[V]); /* login-string */
                        ELOR;
                    }
                    break;



                case 25:        /* Test pattern Probe */
                    DAT1 = $1A;         /* set response */
                    DAT2 = 0;           /* for port 0 */
                    WRDAT();            /* send back first word */
                    WRDAT(RDPDP() );    /* send back second word */
                    PUTIFC();           /* tell it's there */
                    break;



                case 27:        /* Host Sad */
                    WAITIS(10);         /* wait for space in ISIS ring */
                    SLOR(0,3);          /* port 0, diagnostic message */
                    PUTCH(0);           /* padding */
                    PUTH(RDPDP( ) );    /* host-specified value */
                    PUTH($1000);        /* diagnostic type $10 */
                    PUTCH(PRODID);      /* product-ID */
                    ELOR();
                    break;



                */      The PDP treats Echo specially;  In ISIS, Echo is a
                        special case of terminal-parameters.
                */

        16                Internal Maintenance Specification           EBUS.IMS
        Host Output                                               June 23, 1986


                case 28:        /* Echo On */
                    DAT3 = 0;           /* subtype = 0 */
                    DAT4 = 1;           /* value = 1 */
                    goto STERM;         /* STERM forwards it */

                case 29:        /* Echo Off */
                    DAT3 = 0;
                    DAT4 = 0;
                    goto STERM;         /* STERM forwards it */

                case 30:        /* Set Terminal Characteristics */
                    if ( unsigned DAT3 >= $14) MERROR(); /* range-check */

        STERM:      if ( Rp->P_FLAGS & PF_ACT == 0 )
                        break;          /* ignore inactive ports */
                    WAITIS(8);          /* insure space in ISIS ring */
                    if (DAT3 == 5)      /* special handling for
                                           Input Baud Rate */
                    {   Rp->IBRATE = DAT4;
                        PTSMN1();       /* report it back */
                        break;
                    }
                    SLOR(PORTNM,$B1);   /* B1 is Set parameters */
                    PUTCH(DAT3);        /* Dat3 is subtype */
                    PUTCH(DAT4);        /* Dat4 is value */
                    ELOR();
                    break;



        /*      subtype 63 is special case for query ALL parameters     /*
                case 31:        /* query terminal characteristics */
                    if ( Rp->P_FLAGS & PF_ACT == 0 )
                        break;          /* ignore inactive ports */
                    if ( unsigned DAT3 <= $14)
                        PTMSND();       /* send one message */
                    else if ( DAT3 = 63 )
                        for ( DAT3 = 0 ; DAT3 < $14 ; DAT3++ )
                            PTMSND();   /* query all */
                    break;



                case 33:        /* Set Host Number */
                    if ( DAT3 != HOSTN || DAT2 != NPORTS )
                        HDOWN(3);       /* set Gone if changing things */
                    else HDOWN(1);      /* ...otherwise just Down */
                    HOSTN = DAT3;       /* new host number */
                    if ( (HOSTP = PORTNO) == 0 )
                        HOSTP = MAXPORT-2; /* default number of ports */
                    if ( HOSTP > MAXPORT-2 )
                        HOSTP = MAXPORT-2; /* range-check */
                    MXPORT = HOSTP-3;

        17                Internal Maintenance Specification           EBUS.IMS
        Host Output                                               June 23, 1986


                    HSTAT = 2;          /* set Shut */
                    HREPRT();           /* report new Host-state */
                    break;



                case 34;        /* SUP Clock Request */
                    break;              /* just ignore it */



        /*      THE CASES 38, 40, 42, 44, and 46 ARE ALL RELATED TO BLOCK-IO,
                AND ARE TREATED IN THAT SECTION.



                case 51:        /* Set new Timeout Value */
                    TOHOST = HOSTTO = (short) DAT3; /* set variables */
                    break;



                Default:        /* all others */
                    MERROR();   /* message-error Crash */

                }       /* switch */
                continue;

        /*      Must abort..."unread" last message */
        HOUT2:  if ( --PDPOEC < 0 )
                        PDPOEC = PDPOSZ-1; /* back up cursor */
                break;

            }   /* while (not HTDWN) */
            return;
        }




             Specialized internal routines include:

                /* send a single Request Terminal Characteristics Message */
        PTMSND()
        {       if ( DAT3 = 5 )
                    PTSMN1();           /* special case for 5 (IBR) */
                else
                {   ROOM(4);            /* we'll need 4 chars of space */
                    SLOR(PORTNO,$B0);
                    PUTCH(DAT3);        /* subtype */
                    ELOR;
                }
                return;

        18                Internal Maintenance Specification           EBUS.IMS
        Host Output                                               June 23, 1986


        }



                /* return subtype=5 value to host */
        PTSMN1()
        {       DAT1 = $20;
                DAT2 = PORTNO;
                DAT3 = 5;
                DAT4 = Rp->IBRATE;      /* reply with internal IBR */
                WRDAT();
                return;
        }



                /* return Sup response (to AUX-circuit) to host */
        SEND17(v)
        int     v;                      /* value to return */
        {       DAT1 = $17;
                DAT2 = PORTNO;
                (short) DAT3 = v;
                WAITDAT();
                return;
        }



                /* Translate PDP message-length to ISIS message-length */
        int     GEHTLN()
        {       if (  ( int v = ( unsigned char ) TYPBYT ) > $80  )
                    return ( v - $80 + 3 );
                else
                    return ( TRHSTLN[v] );
        }



















        19                Internal Maintenance Specification           EBUS.IMS
        Input from ISIS                                           June 23, 1986






                                 6 -  Input from ISIS


             This section deals with  messages input from ISIS.  Most  of these
        will be transliterated, and forwarded to the host.

             Block-IO will be treated in a seperate section.

               NOTE:   ISIS  input  is  "throttled"  by  counter "IRRN";
                       this  limits ISIS  input to  no more  than IRSIZE
                       bytes per EXEC-loop (i.e.,  we do no more  than 1
                       input-ring's worth per go-roundie).

             The code consists of:

        ISISIN()
        {   while ( not HTDWN)          /* while the host is up... */
            {   PUTIFC();               /* tell host our current cursor */
                if ( not LOOK() )       /* if nothing there */
                    break;              /* ...then we quit */
                SETPORT(PORTNM);        /* set up port parameters */
                FDRGSZ();               /* determine space in the ring */
                if ( IRRN > IRSIZE )
                    break;              /* do no more then 1 ring's worth */
                if ( PORTNO == 0 )


        /*      Process port-0 messages         */
                {   static char INISLN[] =      /* message-length table */
                /* ISIS 0  1  2  3  4  5  6  7  8  9 0A 0B 0C 0D 0E 0F 10 */
                {       0, 0, 2, 0, 0, 0, 6, 0, 0, 3, 0, 0, 0, 2, 0, 0, 0 };

                    if ( INRGSP > $10 )
                        ISMGER();       /* range-check */
                    if ( INRGSP < INISLN[INTYBT] )
                        break;          /* no room for message */

                    switch (INTYBT)


                    case 2:             /* SUP Takeover */
                    case 13:            /* SUP lost */
                        AUXX = -1;      /* cancel any AUX in progress */
                        DAT1 = 5;
                        DAT2 = 0;
                        goto SENDDAT;   /* tell PDP Msg5, P0 */


                    case 6:             /* Sup Time */

        20                Internal Maintenance Specification           EBUS.IMS
        Input from ISIS                                           June 23, 1986


                        DAT1 = $23;     /* Msg 23 */
                        DAT2 = 0;       /* port 0 */
                        GETCH();        /* skip pading */
                        (short) DAT3 = GETH(); /* high GMT */
                        WRDAT();        /* send that in */
                        (short) DAT1 = GETH(); /* low GMT */
                        (short) DAT3 = 0; /* padding */
                        goto SENDDAT;   /* pass it on */


                    case 9:             /* Aux Circuit Error */
                        AUXX = -1;      /* cancel AUX circuit */
                        DAT1 = $17;     /* Msg 17 */
                        GETCH();        /* skip padding */
                        DAT2 = GETH();  /* p = local key */
                        DAT3 = GETCH(); /* reason */
                        if ( DAT3 = 0 )
                            DAT3 = 7;   /* 0 -> 7 */
                        goto SENDDAT;

                    case 11:            /* host unacceptable */
                        GETCH();        /* just ignore it */
                        GETH();
                        GETCH();
                        goto CLEANUP;


                    default:
                        ISMGER();       /* CRASH for anything else */

                }   /* PORTNO == 0 */
                /*      We've now processed all Port-0 messages         */


                        /* for PORTNO != 0 */
                if ( INTYBT == 0 )


        /*      special case for Needles        */
                {   if ( not ROOM(4) )
                        break;          /* quit this pass if there's not
                                           enough room in the ISIS ring to
                                           return a 4-byte message */
                    SLOR(PORTNM,$B9);   /* set transmit-limit.. */
                    PUTCH(30);          /* ...to 30 */
                    ELOR;
                    if (INRGSP < 80 )
                        break;          /* quit this pass if there's not
                                           enough room in the PDP's ring
                                           to hold 20 words of messages */
                    GETCH();            /* ignor key */
                    GETW();             /* ignor invoice */
                    GETH();             /* ignor Dest. Host */

        21                Internal Maintenance Specification           EBUS.IMS
        Input from ISIS                                           June 23, 1986


                    NORNODE = GETH();   /* record Orig. node */
                    NORHOST = GETH();   /* record Orig. Host */
                    NORPORT = GETH();   /* record Orig. port */
                    GETW();             /* ignor Extra IN | XXX | TPC */
                    NCCT = GETCH();     /* record CCT */
                    NSIZ = GETCH();     /* record user-string size */
                    for ( { n=0; char *p=DAT5 } ; n < NSIZ ; n++ )
                        *p++ = GETCH(); /* copy username into DAT5+ */
                    if ( PFULL )
                    {   WAITISW();      /* no more ports... */
                        SLOR(PORTNM,$BE); /* Zap w/reason */
                        PUTCH(0);
                        ELOR();
                        FLUSH(NSIZ);    /* flush the needle */
                        continue;
                    }
                    DAT1 = 6;           /* new logon */
                    DAT2 = PORTNM;
                    (short) DAT3 = NORHOST;
                    WAITDAT();          /* send to host */
                    DAT1 = $82;         /* send succession of 2-byte
                                           data-messages to host */
                        /* record input baud-rate */
                    Rp->IBRATE = TIDBD[ $1F & ( DAT3=NCCT) ];
                    DAT4 = NORNODE >> 6;
                    WAITDAT();          /* CCT | O.Node(high) */
                    DAT3 = NORNODE;
                    DAT4 = NORPORT;
                    WAITDAT();          /* O.Node(low) | O.Port */
                    for ( { n=NSIZE; char *p=DAT5 } ; n > 0 ; n -= 2 )
                   {    if ( n == 1 )
                            DAT1 -= 1;  /* 1-byte last Msg if odd
                                              number of chars */
                        (short) DAT3 = (short) *p++;
                        WRDAT();        /* copy username into PDP */
                    }
                    goto CLEANUP;
                }       /* INTYBT == 0 */
                /*      We've now processed Needles     */

                if ( INTYBT > $9D )


        /*      Process Normal-port Control-Signal      */
                {    switch ( INTYBT )
                    {

                */      the following cases share common code   */
                    case $9F:           /* Zapper */
                        if ( Rp->P_FLAGS & PF_ACT != 0 )
                        {   DPORT();    /* reduce port-count */
                            RBTALL();   /* clear port-stuff */
                        }

        22                Internal Maintenance Specification           EBUS.IMS
        Input from ISIS                                           June 23, 1986


                        goto ISP;       /* ISP contains common code */

                    case $A0:           /* Apply back-pressure */
                        Rp->P_FLAGS != PF_OBP; /* set back-pressure on */
                        goto ISP;

                    case $A1:           /* Release back-pressure */
                        Rp->P_FLAGS &= not PF_OBP; /* set off */
                        goto ISP;

                    case $A4:           /* black-ball */
                        DAT3 = -1;      /* distinguishes between A4 and A5 */
                        goto ISP;

                    case $A5:           /* gray-ball */
                        DAT3 = 0;       /* distinguishes between A4 and A5 */
                        goto ISP;

                    case $AC:           /* Yellow-ball */
        /*      Yellow-ball is special because it interracts with BIO   */
                        if ( Rp->P_FLAGS & PF_BKI == 0 )
                            goto STREAM; /* Block-input not active */
                        if ( Rp->P_FLAGS & PF_BFD != 0 )
                            goto STREAM1; /* Block was filled */
                        Rp->P_FLAGS != PF_BFD; /* ...it is now */
                        DAT1 = $28;     /* report it */
                        DAT2 = PORTNM;
                        (short) DAT3 = Rp->BI_LCN;
                        WAITDAT();      /* send it */

                    case $A2:           /* Gobbler */
                        if ( Rp->P_FLAGS & PF_HBP == 0 )
                        {   /* no host-applied BP */
                            DEMPTY();   /* empty the buffer */
                            BU_EMP();   /* release Bp */
                        }
                        goto ISP;       /* forward it in */


                    case $A6:           /* Enter DEM */
                    case $A7:           /* Leave DEM */
                    case $AA:           /* Green-ball */
                    case $AB:           /* Red-ball */
                    case $AE:           /* Break-begin */
        /*      Special cases for in-stream control-signals.  These must
                retain their position relative to individual data-characters.
                Thus, we can't forward them if there is data in the buffer.
        */
        STREAM:         if ( Rp->BCT == 0 )
                            goto ISP;   /* buffer empty...proceed */

        /*      We must buffer the control-signal.  We do this by placing
                the sequence "ESC" | "Sig" into the buffer.

        23                Internal Maintenance Specification           EBUS.IMS
        Input from ISIS                                           June 23, 1986


        */
        STREAM1:            DWCI(ESC); /* place ESC into buffer */
                        DWCI(INTYBT);   /* followed by signal */
                        goto CLEANUP;


                    case $AD:           /* Orange-ball */
        ISP:            LOOKUP();       /* translate it */
                        goto PUTPR;     /* ...and send it */


                    case $B1:           /* Terminal Characteristics Response */
                        DAT1 = $20;     /* type */
                        DAT3 = GETCH(); /* subtype */
                        DAT4 = GETCH(); /* value */
                        goto PUTPN;     /* place port# & send it */


        /*      In HOSTOUT, we serviced requests for an AUX circuit, and
                submitted an AUX-Pseudoneedle request to ISIS.  These cases
                are the response to that request.
                ISIS/Node code may reject the request, and we'll get a B5
                message;
                If successful, we'll get a B2, followed by a B6.
        */


                    case $B2:           /* Pseudo-needle */
                        RBTALL();       /* clean up port */
                        GETCH();        /* ignor padding */
                        Rp->AUXKEY = GETH(); /* save key */
                        if ( not PFULL )
                        {   /* ports still available */
                            AUXX = -1;  /* enable another attempt */
                            Rp->P_FLAGS != PF_ACT; /* set active */
                            IPORT();    /* count another port in use */
                            goto CLEANUP;
                        }
                        WAITISW();      /* no more ports.. */
                        SLOR(PORTNM,$BE); /* Zap W/reason */
                        PUTCH(0);
                        ELOR();
                        DAT3 = 8;       /* set out of ports */
                        goto LOGFAL;


                    case $B5:           /* Logon Failure */
                        DAT3 = GETCH(); /* reason */
                        if ( DAT3 = 0 )
                            DAT3 = 7;   /* reason 0 -> 7 */

        LOGFAL:         DAT1 = $17;     /* message $17 */
                        DAT2 = AUXQ;    /* port = key */

        24                Internal Maintenance Specification           EBUS.IMS
        Input from ISIS                                           June 23, 1986


                        AUXX = -1;      /* enable another attempt */
                        goto SENDDAT;


                    case $B6:           /* Logon OK */
                        SLOR(PORTNM,$B9); /* set transmit-limit */
                        PUTCH(30);      /* ...to 30 */
                        ELOR();
                        GETCH();        /* skip padding */
                        GETW();         /* skip Invoice */
                        GETH();         /* skip Orig. host */
                        DAT1 = 7;       /* message 7 */
                        DAT2 = PORTNM;
                        DAT3 = Rp->AUXKEY;
                        WAITDAT();      /* send it */
                        DAT1 = $17;     /* message $17 */
                        DAT2 = Rp->AUXKEY; /* requesting port */
                        (short) DAT3 = 0; /* success */
                        goto SENDDAT;



                    case $B9:           /* set transmit limit */
                        Rp->XMITLMT = ( ( GETCH() - 5 ) & -4 ) + 2;
                        goto CLEANUP;


                    case $9E:           /* Detach */
                    case $A3:           /* flush input */
                    case $A8:           /* enter transparancy */
                    case $A9:           /* leave transparancy */
                    case $AF:           /* hang-up */
                    case $B0:           /* query Terminal Characteristic */
                    case $B4:           /* Logon Status */
                    case $B8:           /* Super-hang */
                    case $BA:           /* Break-end */
                    case $BB:           /* Zap Ack. */
                    case $BC:           /* Enter alt. device mode */
                    case $BD:           /* Leave alt. device mode */
                    case $BE:           /* Zap w/reason */
                    case $BF:           /* SIIX */
                    case $C0:           /* TIIX */
                        goto CLEANUP;   /* just ignor these */


                    default:            /* all others */
                           ISMGER();    /* fatal error */

                    }   /* switch (INTYBT) */
                    continue;
                }    /* if ( INTYBT > $9D ) */
                /*      At this point, we've processed any message other than
                        a data-message */

        25                Internal Maintenance Specification           EBUS.IMS
        Input from ISIS                                           June 23, 1986


                */

                /*      Any message not yet processed must be text      */



        /*      This gets complicated.  Data from ISIS may go to any of three
                 destinations:
                  To the port's buffer (if anything is already buffered);
                  To the port's Block-input (if active and not filled);
                  To the port's buffer (if Bin active and filled);
                  To the port's buffer (if host has applied back-pressure);
                  else, To the PDP's input-ring.
                Furthermore, for a variety of reasons, we may need to "split"
                 the data, and service the ISIS message in multiple fragments.
                This may occur if:
                  The full message is too long (we limit host input to 30
                   bytes / message);
                  We must split the message to allow for PDP-ring Wrap;
                  A part of the ISIS message "fills" the Block-input buffer.
                The destination after "splitting" will always be the buffer.
        */
                if ( Rp->BCT != 0 )     /* buffer not empty */
                    goto IS_BU;         /* then copy ISIS to Buffer */
                if ( Rp->P_FLAGS & PF_BKI != 0 ) /* Block-input active */
                    goto IS_BK;         /* then copy ISIS to Block */
                if ( Rp->P_FLAGS & PF_HBP != 0 ) /* host-applied BP */
                    goto IS_BUF;        /* then copy ISIS to Buffer */
                if ( INRGSP == 0 )      /* no room in ring */
                    goto IS_BUF;        /* then copy ISIS to Buffer */

                /* Not engaged in Block-input, and no need to buffer */
                register n = INRGSP-2;  /* determine length available */
                if ( n > 30 )           /* never use more than 30 */
                    n = 30;
                if ( n > INTYBT )
                    n = INTYBT;         /* send no more than in message */
                DAT1 = n + $80;         /* message type */
                DAT2 = PORTNO;
                register char *p = DAT3;
                for ( ; n > 0; n-- )
                {   *p++ = GETCH();     /* copy data into DAT */
                    INTYBT--;
                }
                for ( register long *q = DAT ; q < p ; )
                    WRPDP( *q++ );      /* copy DAT to PDP */
                if ( INTYBT == 0 )
                    goto CLEANUP;       /* we've not split data..done */
                /* no...tell PDP data is there, buffer rest */
                PUTIFC();


        /*      Buffering data...insure we'll remove it later */

        26                Internal Maintenance Specification           EBUS.IMS
        Input from ISIS                                           June 23, 1986


        IS_BUF: if ( Rp->BCT == 0 )
                    BUFADD();           /* insure it's on buffer-queue */


        /*      Copying ISIS-ring to buffer     */
        IS_BU:  while (INTYBT-- > 0 )
                {   char c = GETCH();   /* get the char */
                    if ( c== ESC )
                        DWCI(ESC);      /* escape data-codes = ESC */
                    DWCI(c);            /* buffer the data */
                }
                if ( Rp->BCT > BKPR )   /* need to apply back-pressure */
                {   Rp->P_FLAGS != PF_IBP; /* record back-pressure */
                    SENDQI(PORTNO,$A0); /* apply back-pressure */
                }
                goto CLEANUP;           /* done */



                /*      Common Loop-exit Processes      */

        PUTPN:  DAT2 = PORTNM;          /* place port-number in message */

        SENDDAT: WRDAT();               /* forward message to PDP */

        CLEANUP: ELIR();                /* close ISIS message input */

            }   /* while ( not HTDWN) */
            return;
        }




             Some special functions are provided:

        /*      Translate ISIS control-signal to PDP-message and send it */
        LOOKUP();
        {       static char     ISPTAB[]
        /*      ISIS #  = 9F,A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,AA,AB,AC,AD,AE */
                {       = 11, 8, 9,10, 0,21,21,12,13, 0, 0,14,15,16,17,47 };
                DAT1 = ISPTAB[ INTYBT-$9F ];
                return;
        }










        27                Internal Maintenance Specification           EBUS.IMS
        Block-I/O                                                 June 23, 1986






                                    7 -  Block-I/O


             Block-I/O is a  special form of Host  I/O which is  independent of
        the normal Host input- and output-rings.

             Via  special  messages (passed  in  the rings),  the  host request
        either  Block-input (Bin)  or  Block-output (Bout);  arguments  are the
        block start-address and a byte-count.






                                7.1  Request for Ports


             Before any Block-IO transaction, the PDP queries  the availability
        of BIO  capabilities (for historical  reasons:  In  the Varian/TYMNET-I
        implementation, there  were only a  limited number of  BIO descriptors;
        this constraint does not apply to EBUS).

             Thus, in response to the host request, we perform:

                case 45:        /* $2E: Request for Block-IO ports */
                    WAITDAT();          /* just return his request */
                    PUTIFC();           /* promise all he asked for */
                    continue;






                                   7.2  Block-Output


             Block-output  is  relative  straight-forward:   The  host  makes a
        request, and  we transmit  the data  until the  block is  exhausted, or
        until the host cancels the request.  In either case, we then inform the
        host of the status.

             The requests are serviced by:

                case 36:        /* $24: Request for block-output */
                    if ( Rp->P_FLAGS & PF_ACT == 0 /* port not active */
                      || Rp->P_FLAGS & PF_BKO != 0 ) /* Bout active */
                    {   RDPDP();        /* just skip second word */

        28                Internal Maintenance Specification           EBUS.IMS
        Block-I/O                                                 June 23, 1986


                        continue;
                    }
                    list *p = BLKFREE;  /* get a list entry */
                    BLKFREE = p->next;
                    p->next = BKOHEAD;
                    p->port = PORTNO;
                    BKOHEAD = p;        /* place entry onto BKO list */
                    RP->BO_TCN = (short) DAT3; /* total count */
                    RP->BO_TAR = RDPDP(); /* block address */
                    RP->BO_BYT = 0;     /* next byte to send */
                    continue;



                case 42:        /* $2A: Terminate Block-output */
                    BKOTERM($2D);       /* reason $2D -- Bout Termination */
                    continue;




             The process which actually performs block output is:

                /*      Perform Block-output for all active ports,
                        subject to ISIS back-pressure
                */
        DOBKOUT()
        {   if ( HTDWN ) return;        /* the host must be up */
            SAVE1 = BKOHEAD;
            while  (SAVE1 != 0 )
            {   SETPORT( SAVE1->port ); /* set up port */
                SAVE1 = SAVE1->next );  /* next entry */
                if ( Rp->P_FLAGS & PF_OBP != 0 )
                    continue;           /* skip ports back-pressured */
                int n = Rp->BO_TCN;     /* number we have */
                if ( n > Rp->XMITLMT )
                    n = Rp->XMITLMT;    /* number we can send */
                if ( not ROOM( n+3 );
                    continue;           /* skip port if no room in ring */
                SLOR(PORTNO,n);         /* message-type = count */
                RDBLK();                /* get the first word */
                while ( n-- > 0 )       /* copy bytes */
                {   PUTCH( DAT[ Rp->BO_BYT++ ];
                    Rp->BO_TCN--;       /* count byte transmitted */
                    if (Rp->BO_BYT >= 4 ) /* word exhausted */
                    {   (Rp->BO_BYT = 0; /* fold cursor */
                        RDBLK();        /* ...and get next word */
                    }
                }       /* while n > 0 */

                ELOR();                 /* done */
                if ( Rp->BO_TCN == 0 )
                    BKOTERM($25);       /* block done */

        29                Internal Maintenance Specification           EBUS.IMS
        Block-I/O                                                 June 23, 1986



            }   /* while SAVE1 != 0 */
            return;
        }


        /*      Terminate Block-output  */
        BKOTERM(v)
        int     v;                      /* reason for termination */
                RBTBKO();               /* cancel Bout */
                DAT1 = v;               /* termination reason */
                DAT2 = PORTNO;
                WAITDAT();              /* send it */
                PUTIFC();
                return;
        }






                                   7.3  Block-Input


             Block-input  (Bin) is  significantly more  complicated.   The host
        will initially make a Bin  request fo a particular port;   this enables
        BKI mode.  This mode  is retained until the host  explicitly terminates
        block-input.  while this mode is in progress, successive data is placed
        into the  specified block  until this block  is terminated:   there are
        three reasons for terminating a block:

           The block is filled;
           An End-Of-Transmission (EOT, designated by arrival of a Yellow-ball)
               is received; or
           No data has been received for more than 16 seconds.

             When a block is Filled ("BFD" state), any subsequent data arriving
        is placed  into a buffer;   if a new  block is specified,  the buffered
        data will be  copied into the block.   If, however, Bin  is terminated,
        this buffered data must be forwarded into the host via the regular host
        input-ring  mechanism (subject,  of course,  to back-pressure  from the
        host).

             The code which services the requests is:

                case 38:        /* $26: Request for block-input */
                    if ( Rp->P_FLAGS & PF_BKI == 0 ) /* Bin not active */
                    {   Rp->P_FLAGS != PF_BKI; /* set active */
                        RBTBUF();       /* remove buffer from buffer-list */
                        list *p = BLKFREE; /* get a list entry */
                        BLKFREE = p->next;
                        p->next = BKIHEAD;

        30                Internal Maintenance Specification           EBUS.IMS
        Block-I/O                                                 June 23, 1986


                        p->port = PORTNO;
                        BKIHEAD = p;    /* place entry onto BKI list */
                    }
                    Rp->P_FLAGS &= not PF_BFD; /* clear Filled */
                    RP->BI_TCN = (short) DAT3; /* total count */
                    RP->BI_TAR = RDPDP(); /* block address */
                    RP->BI_LCN = 0;     /* local count (# received) */
                    RP->BI_BYT = 0;     /* next byte to fill */
                    RP->BI_TIM = *.SLOWC; /* current time */
                    if ( Rp->BCT > 0 )
                        BU_BK();        /* try to empty buffer */
                    continue;


                case 44:        /* $2C: Terminate Block-input */
                    if ( Rp->P_FLAGS & PF_BFD == 0 ) /* if Filled, */
                        BKITERM($2C);   /* message $2C */
                    else BKITERM($2B);  /* message $2B */
                    RBTBKI();           /* cancel Bin */
                    if ( Rp->BCT > 0 )
                        BU_ADD();       /* insure buffer will be flushed */
                    continue;




             ISISIN executes the following code for Block-input:

        BLOKIN: if ( Rp->P_FLAGS & PF_BFD == 0 ) /* if Filled, */
                    goto IS_BU;         /* move to buffer */
                n = Rp->BI_TCN - Rp->LCN; /* space left */
                if ( n > INTYBT )
                    n = INTYBT;         /* number of chars */
                GETBLK();               /* get the current word to fill */
                while ( n-- > 0 )
                /*      copy chars      */
                {   DAT[Rp->BI_BYT++] = GETCH();
                    if ( Rp->BI_BYT > 3 )
                    {   WRBLK();        /* word full..send it */
                        Rp->BI_BYT = 0; /* cycle counter */
                    }
                    INTYBT--;
                    Rp->BI_LCN++;       /* counting... */
                }       /* while n > 0 */

                /*      n bytes transfered...clean up   */
                if ( Rp->BI_BYT != 0 )
                {   WRBLK();            /* send in partial word */
                    Rp->BI_TAR--;       /* ...and back up word-cursor */
                }
                Rp->BI_TIM = *.SLOWC;   /* record time */
                if ( Rp->BI_TCN == Rp->BI_LCN )
                    BKITERM($27);       /* report Filled */

        31                Internal Maintenance Specification           EBUS.IMS
        Block-I/O                                                 June 23, 1986


                if ( INTYBT == 0 )
                    goto CLEANUP;       /* message exhausted */
                else
                    goto IS_BU;         /* more in message...buffer it */



               NOTE:   See also ISISIN : Control-signal case $AC:.  This
                       specifies the activity incured if an EOT (Yellow-
                       ball) is encountered.

             In  addition,  there  are  also  additional  processes  which  are
        executed as  a part  of the  "EXEC-loop", rather  than being  driven by
        input:

        /*      EXEC-loop Processes     */
            if ( HTDWN ) goto EXEC;     /* the host must be up */


        /*      Examine all active block-input for timeouts     */
            SAVE1 = BKIHEAD;
            while  (SAVE1 != 0 )
            {   SETPORT( SAVE1->port ); /* set up port */
                SAVE1 = SAVE1->NEXT );  /* next entry */
                if (  ( Rp->BI_TIM - *.FASTC )  > 9600 ) /* 16 seconds */
                    if ( Rp->P_FLAG & PF_BFD == 0 ) /* and not Filled */
                        BKITERM($29);   /* block done -- timeout */
                    continue;           /* skip ports back-pressured */

            }   /* while SAVE1 != 0 */



        /*      Examine all active block-input for buffered-data        */
            SAVE1 = BKIHEAD;
            while  (SAVE1 != 0 )
            {   SETPORT( SAVE1->port ); /* set up port */
                SAVE1 = SAVE1->NEXT );  /* next entry */
                if ( Rp->P_FLAG & PF_BFD == 0 /* not Filled */
                    && Rp->BCT > 0 )    /* and data buffered */
                        BU_BK();        /* flush those buffers */

            }   /* while SAVE1 != 0 */



        /*      Examine Buffer-list for buffered-data   */
            SAVE1 = BUFHEAD;
            while  (SAVE1 != 0 )
            {   SETPORT( SAVE1->port ); /* set up port */
                SAVE1 = SAVE1->NEXT );  /* next entry */
                BU_RG();                /* try to flush */
                if (Rp->BCT == 0 )      /* now empty */

        32                Internal Maintenance Specification           EBUS.IMS
        Block-I/O                                                 June 23, 1986


                   RBTBUF();            /* ...remove from service */

            }   /* while SAVE1 != 0 */

        goto EXEC;                      /* Done...start over */




             The functions which do all the work are:

        /*      Move data from buffer to ring   */
        BU_RG()
        {       if ( Rp->BCT == 0 )
                    return;             /* don't try if buffer empty */
                if ( Rp->P_FLAGS & PF_HBP != 0 )
                    return;             /* ...or if host has applied BP */
                INTYBT = 30;            /* parameter to call... */
                BKINSZ();               /* find size of message we can send */
                INRGSP = ( INRGSP > 32 ) ? 30 : ( INRGSP - 2 );
                DAT1 = 0;               /* count bytes */
                DAT2 = PORTNO;
                char    *p = DAT3;      /* where the next char goes */
                INTYBT = 0;             /* used to record control-codes */
                while ( Rp->BCT != 0 )
                {   if ( DAT1 >= INRGSP )
                        break;          /* message full */
                    c = DGCI();         /* get the next char */
                    if ( c == ESC )
                    {   if (Rp->BCT == 0 ) FCRASH($60);
                        c = DGCI();     /* get escaped char */
                        if (c != ESC )
                        {   INTYBT = c;
                            break;      /* abort -- Control-signal */
                        }
                    }
                    *p++ = c;           /* save char away */
                    DAT1++;             /* count another char */
                }       /* while Rp->BCT > 0 */

                if ( DAT1 != 0 )
                {   DAT1 != $80;        /* make proper message type */
                /*      now copy the message (in DAT) into the PDP      */
                    for ( char *pp = DAT ; pp < p ; WRPDP( *pp++ );
                    PUTIFC();           /* insure host sees it */
                }
                BU_COD();               /* report control-signal (if any) */
                BU_RGX();               /* see if buffer empty */
                return;
        }




        33                Internal Maintenance Specification           EBUS.IMS
        Block-I/O                                                 June 23, 1986


                /*      Input any code in INTYBT        */
        BU_COD()
        {       if ( INTYBT != 0 )      /* something to do */
                {   LOOKUP();           /* yes...look it up */
                    DAT2 = PORTNO;
                    WAITDAT();
                    PUTIFC();           /* pass to host */
                }
                return;
        }



                /*      see if buffer empty -- release Back-pressure if so */
        BU_RGX()
        {       if ( Rp->BCT == 0 )     /* something to do */
                {   if ( Rp->P_FLAG & PF_IBP == 0 )
                        return;         /* back-pressure not applied */
                    Rp->P_FLAG &= not PF_IBP;
                    SENDQI(PORTNO,$A1); /* release back-pressure */
                }
                return;
        }



        /*      Move data from buffer to block  */
        BU_BK()
        {
        BU_BK:  INTYBT = 0;             /* used to record control-codes */
                GETBLK();               /* get the current word to fill */
                while ( Rp->BCT != 0 )
                {   if ( Rp->BI_LCN == Rp->BI_TCN )
                        break;          /* block full */
                    c = DGCI();         /* get the next char */
                    if ( c == ESC )
                    {   if (Rp->BCT == 0 ) FCRASH($60);
                        c = DGCI();     /* get escaped char */
                        if (c != ESC )
                        {   INTYBT = c;
                            break;      /* abort -- Control-signal */
                        }
                    }
                    DAT[Rp->BI_BYT++] = c; /* save char away */
                    if ( Rp->BI_BYT > 3 )
                    {   WRBLK();        /* word filled */
                        Rp->BI_BYT = 0;
                    }
                    ++Rp->BI_LCN;       /* count another char */
                }       /* while Rp->BCT > 0 */

                if ( Rp->BI_BYT != 0 )


        34                Internal Maintenance Specification           EBUS.IMS
        Block-I/O                                                 June 23, 1986


                {   WRBLK();            /* save partial word */
                    Rp->BI_TAR--;       /* ...back up word-cursor */
                }

                if ( INTYBT == YB_CODE )
                    BKITERM($28);       /* EOT */
                else if ( Rp->BI_TCN == Rp->BI_LCN )
                    BKITERM($27);       /* block done */
                if ( INTYBT != 0 )
                    BU_COD();           /* report control-signal */
                if ( Rp->P_FLAG & PF_BFD == 0 ) /* not yet Filled */
                    goto BU_BK;         /* continue */
                BU_RGX();               /* release back-pressure */
                return;
        }



        BKITERM(v)
        int     v;                      /* reason for termination */
        {       Rp->P_FLAG != PF_BFD;   /* set Filled */
                DAT1 = v;               /* set reason for termination */
                DAT2 = PORTNO;
                DAT3 = (short) Rp->BI_LCN; /* how much we did */
                WAITDAT();              /* report completion to host */
                PUTIFC();               /* insure host sees it */
                return;
        }




             Primative routine for managing lists are:

                /*      Remove an entry from BKI list   */
        RBTBKI()
        {       if ( Rp->P_FLAGS & PF_BKI == 0 /* not active */
                    return;
                Rp->P_FLAGS &= not PF_BKI;
                UNLINK( $BKIHEAD );     /* unlink entry for this port */
                return;
        }



                /*      Remove an entry from BKO list   */
        RBTBKO()
        {       if ( Rp->P_FLAGS & PF_BKO == 0 /* not active */
                    return;
                Rp->P_FLAGS &= not PF_BKO;
                UNLINK( $BKOHEAD );     /* unlink entry for this port */
                return;
        }

        35                Internal Maintenance Specification           EBUS.IMS
        Block-I/O                                                 June 23, 1986


                /*      Remove an entry from BUF list   */
        RBTBUF()
        {       UNLINK( $BUFHEAD );     /* unlink entry for this port */
                return;
        }



                /*      Remove an entry from list       */
        UNLINK(p)
        link    *p;                     /* pointer to list */
        {       while (   ( link *pp = *p )  != 0 )
                {   if ( p->port != PORTNO )
                    {   p = pp;         /* continue search */
                        continue;
                    }
                    *p = pp->next;      /* unlink it */
                    pp->next = BLKFREE; /* append free-list */
                    BLKFREE = pp->next; /* this becomes new head */
                    break;              /* done */
                }       /* while... */
                return;
        }



                /*      Place an entry onto the BUF list        */
        BU_ADD();
        {       list *p = BLKFREE;      /* get a list entry */
                BLKFREE = p->next;
                p->next = BUFHEAD;
                p->port = PORTNO;
                BUFHEAD = p;            /* place entry onto BUF list */
                return;
        }



                /*      Close a port...reset everything */
        RBTALL()
        {       RBTBKO();               /* reset Block-output */
                RBTBKI();               /* reset Block-input */
                DEMPTY();               /* empty buffer */
                RBTBUF();               /* un-queue buffer */
                Rp->XMITLMT = 157;      /* reset transmit-limit */
                Rp->P_FLAGS = 0;        /* clear all flags */
                return;
        }






        36                Internal Maintenance Specification           EBUS.IMS
        I/O and Buffer Logic                                      June 23, 1986






                               8 -  I/O and Buffer Logic


             EBUS contains  code for  both Engine  DMA (i.e.,  ISIS Dispatcher-
        ring) I/O, and for PDP-10  (i.e., Ebus) transfers.  It also  contains a
        variant  of conventional  buffer (and  bufferlet)  management (although
        buffers are used ONLY on  the PDP-input path, and then only  for normal
        data and those control  signals which MUST maintain  sequentiality with
        the user data).

             These routine are so fundamental to operation that they  are coded
        as self-contained  routines, and in  the body of  the code  are treated
        almost  as  though  they   were  primative  extensions  to   the  basic
        instruction-set.






                                8.1  Engine DMA Access


             The (1-Meg address-space) memory of the engine is  mapped directly
        into the  address-space of  the 68K, consuming  addresses in  the range
        $E00000 to  $EFFFFF.  the  only constraint on  transfers is  that Byte-
        transfers are not permitted;  only word (W) and long (L)  transfers are
        allowed.  This  has an  impact only  in the  PUTCH routine,  which must
        emulate  a  byte  transfer  by  manipulation  of  Engine  Half-word (W)
        operands.

             For convenience and efficiency, certain of the 68K  registers have
        been renamed, and are reserved  for the exclusive use of  the ISIS-ring
        routines:

        typedef struct  ISISRING
        {       short   NFMI;
                short   CEI;
                char    ring[100];      /* the size "100" is a dummy */
        }       isisring;

                isisring Rs;            /* pointer to ISIS input-ring */
                isisring Rd;            /* pointer to ISIS output-ring */
                short   Cs;             /* input-ring cursor */
                short   Cd;             /* output-ring cursor */





        37                Internal Maintenance Specification           EBUS.IMS
        I/O and Buffer Logic                                      June 23, 1986


                    8.1.1  ISIS-ring Output Routines

             There are nine routines dealing with ISIS-ring output:



        8.1.1.1  Room

             Room  is passed  the number  of bytes  required.  It  examines the
        output-ring  and  determines  if that  amount  of  space  is available,
        returning TRUE if so, else FALSE:

        ROOM(n)
        int     n;
        {       int     m;              /* used to compute space */
                Cd = Rd->NFMI;
                if ( ( m = Cd - Rd->CEI ) < 0 )
                        m = ORSIZE - m;
                if ( m >= n ) return TRUE;
                else return FALSE;
        }



        8.1.1.2  WAITIS

             WAITIS is passed the number of bytes required.  It  waits, calling
        ROOM repeatedly, until ROOM returns TRUE.

        WAITIS(n)
        int     n;
        {       While ( ROOM( n ) );
                return;
        }



        8.1.1.3  WAITISW

             WAITISW  is  defined  for  convenience;   it  invokes  WAITIS with
        parameter value 4 (wait for 4 bytes):

        WAITISW
        {       WAITIS( 4 );
                return;
        }








        38                Internal Maintenance Specification           EBUS.IMS
        I/O and Buffer Logic                                      June 23, 1986


        8.1.1.4  SLOR

             Start_Logical_Output_Routine  (SLOR) is  used to  initialize ISIS-
        ring output.  Arguments are port number and message-type:

        SLOR(p,t)
        int     p, t;
        {       Cd = Rd->NFMI;
                Rd->ring[Cd] = (short) p;       /* place port-number */
                Rd->ring[Cd+2] = (char) t;      /* place type */
                Cd += 3;
                return;
        }



        8.1.1.5  PUTCH

             PUTCH places a single character into the ring.  It  is complicated
        by the inability to address single bytes in the Engine.

        PUTCH(c)
        char    c;
        short   HW;
        {       HW = (short) Rd->ring[ Cd&(-2) ];
                if ( (Cd & 1) = 0)
                        HW = (HW & $0FF) | (c << 8); /* left byte */
                else
                        HW = (HW & $0FF00) | c; /* right byte */
                (short) [ Cd&(-2) ] = HW;
                if ( ++Cd >= ORSIZE ) Cd = 0;
                return;
        }



        8.1.1.6  PUTH

             PUTH places a single short into the ring.

        PUTH(s)
        short   s;
        {
                (short) Rd->ring[ Cd ] = s;
                if ( ( Cd += 2 ) >= ORSIZE ) Cd = 0;
                return;
        }







        39                Internal Maintenance Specification           EBUS.IMS
        I/O and Buffer Logic                                      June 23, 1986


        8.1.1.7  PUTW

             PUTW places a single long into the ring.

        PUTW(l)
        long    l;
        {
                (long) Rd->ring[ Cd ] = l;
                if ( ( Cd += 4 ) >= ORSIZE ) Cd = 0;
                return;
        }



        8.1.1.8  ELOR

             End_Logical_Output_Record (ELOR) terminates the current message.

        ELOR()
        {       Cs += 3;
                Cs &= -4;               /* round up to next message boundary */
                if ( Cs >= ORSIZE ) Cs = 0;
                Rs->NFMI = Cs;          /* DONE! */
                return;
        }



        8.1.1.9  SENDQI

             SENDQI  is defined  for convenience,  to send  a quick  message to
        ISIS:

        SENDQI(p, t)
        int     p, t;                   /* p is port, t is type */
        {       WAITISW();
                SLOR( p, t );
                ELOR();
                return;
        }





                    8.1.2  ISIS-ring Input Routines

             ISIS-ring input is implemented through six routines:






        40                Internal Maintenance Specification           EBUS.IMS
        I/O and Buffer Logic                                      June 23, 1986


        8.1.2.1  LOOK

             LOOK sets up Cs, and returns TRUE if there is a message waiting in
        the ISIS input-ring (and also PORTNM and INTYBT), else FALSE:

        LOOK()
        {       Cs = Rs->CEI;
                if ( Cs == Rs->NFMI ) return FALSE;     /* ring empty */
                PORTNM = (short) Rs->ring[Cs];
                INTYBT = (char) Rs->ring[Cs+2];
                Cs += 3;
                return TRUE;
        }



        8.1.2.2  GETCH

             GETCH gets a single byte from the ring.  It is complicated  by the
        inability to fetch single bytes from the Engine memory:

        char    GETCH()
        {       int     HW;
                HW = (short) Rs->ring[Cs&(-2)]; /* get HW containing char */
                if ( (Cs&(-2)) == 0 ) HW >>= 8; /* select byte to use */
                if ( ++Cs >= IRSIZE ) Cs = 0;
                return (char) (HW&$0FF);
        }



        8.1.2.3  GETH

             GETH gets a single short from the ring:

        short   GETH()
        {       short   HW;
                HW = (short) Rs->ring[Cs];
                if ( Cs += 2 >= IRSIZE ) Cs = 0;
                return HW;
        }



        8.1.2.4  GETW

             GETW gets a single long from the ring:







        41                Internal Maintenance Specification           EBUS.IMS
        I/O and Buffer Logic                                      June 23, 1986


        long    GETW()
        {       long    l;
                l = (long) Rs->ring[Cs];
                if ( Cs += 4 >= IRSIZE ) Cs = 0;
                return l;
        }



        8.1.2.5  ELIR

             End_Logical_Input_Record (ELIR) terminates and closes input:

        ELIR()
        {       Cs += 3;                /* bring cursor to next boundary */
                Cs &= -4;
                if ( Cs >= IRSIZE ) Cs -= IRSIZE;
                Rs->CEI = Cs;
                return;
        }



        8.1.2.6  FLUSH

             FLUSH "flushes" the specified number of characters from the input-
        ring, and then closes the current message:

        FLUSH(n)
        int     n;
        {       Cs += n;                /* advance the cursor */
                ELIR();                 /* ...then close it */
                return;
        }






                               8.2  PDP (Black-Box) I/O


             The Black-box  can be  viewed as having  an extended  register, of
        form:

        ________________._______________.___.___._.______________
        |     Dleft     |     Dmid      |Ahi|Drt|C|    Alo      |
        :---------------:---------------:-------:---------------:
              "DHI"           "DLO"       "AHI"       "ALO"

             Where:


        42                Internal Maintenance Specification           EBUS.IMS
        I/O and Buffer Logic                                      June 23, 1986


           Dleft   Data-left -- Left 16-bits of PDP data-word;
           Dmid    Data-middle -- Middle 16-bits of PDP data-word;
           Drt     Data-right -- Right 4-bits of PDP data-word;
           Ahi     Address-high -- Left 4-bits of PDP address;
           Alo     Address-low -- Right 15-bits of PDP address;
           C       Control-bit -- Set to 1 for Write; set to 0 for Read.
           "DHI"   The "name" of the register addressed by the 68K.
           "DLO"   ditto.
           "AHI"   ditto. (Note:  this is a single byte).
           "ALO"   ditto.

             These are addressed by the 68K as four 16-bit registers, which map
        into the 68K's  memory.  Addresses for  input are different  than those
        for output:

        Register        Input           Output
        DHI             $D0403A         $D0803A
        DLO             $D0403C         $D0803C
        AHI             $D0403E         $D0803E
        ALO             $D04038         $D08038

             In addition, the following  addresses are also used  to manipulate
        the Black-box:

        Symbol          Address         Usage

        DSENS           $D000B8         Sense if Busy (high-bit on)
        DTMOT           $D001B8         Sense if Read Time-out (high-bit on)
        DPER            $D00138         Sense Read Parity-error (high-bit on)
        DEXC0           $D01038         Reset Black-box (by referencing)

             Commonly used operations are expressed as functions:

        SENSE() { ( (short) DSENS & $0001 ) }
        PARITY() { ( (short) DPER & $0001 ) }
        TIMEOUT() { ( (short) DTMOT & $0001 ) }
        RESET() { ( if(DEXC0); ) }

             Internal locations used globally include:

        short   P10DAH;                 /* Data-high */
        short   P10DAL;                 /* Data-low */
        short   P10ADR;                 /* Address (within PDP) */
        char    P10DLL;                 /* Ahi | Drt */

               NOTE: P10DAH | P10DAL are also regularly used as a "long"
                       with name "P10DAH".







        43                Internal Maintenance Specification           EBUS.IMS
        I/O and Buffer Logic                                      June 23, 1986


                    8.2.1  SETBLKA

             SETBLKA is a utility  function provided for both Block  -input and
        -output.  It formats the argument (an address within the PDP)  and sets
        BLK = TRUE:

        SETBLKA(adr)
        int     adr;                    /* the address */
        {       P10ADR = adr;           /* set low-15 bits */
                P10DLL = ( (adr>>15) << 4; /* set high-4 bits */
                BLK = TRUE;
                return;
        }





                    8.2.2  Output To PDP

             The primary mode of output  to the PDP is via the  PDP input-ring.
        The 68K retains the following variables related to this ring:

        short   PDPIRP;                 /* Pointer (to base of ring) */
        short   PDPISZ;                 /* size of ring */
        short   PDPIFC;                 /* fill-cursor */
        short   PDPIEC;                 /* empty-cursor */

             There are a number of routines for output:



        8.2.2.1  WR10R

             WR10R is the primative routine for all transfers from 68K to PDP:

        WR10R()
        {       short HW;               /* temp store */
                int     cnt;
                for ( cnt=0 ; cnt < 70 ; cnt++ )
                {       if (SENSE() ) continue;
                        *DHI =  P10DAH; /* MIC inverts bits */
                        *DLO =  P10DAL;
                        HW = P10DLL;    /* for Drt...*/
                        if ( BLK == 0 ) /* if NOT Block-IO... */
                                HW = (  HW ) & $0F;
                        *AHI = HW;      /* no inversion for address */
                        *ALO = $08000 | P10ADR; /* ditto. */
                        return;
                }
                BUSCRAS();
        }


        44                Internal Maintenance Specification           EBUS.IMS
        I/O and Buffer Logic                                      June 23, 1986


        8.2.2.2  PUTNOT0

             Certain special locations within the PDP cause the PDP to crash if
        non-zero.  PUTNOT0 insures that a Write will force non-zero:

        PUTNOT0(v)
        long    v;                      /* v is value */
        {       (long) P10AH = v;
                P10DLL = 0;             /* insure low 4 bits set */
                WR10R();
                return;
        }

             It is used exclusively by:



        8.2.2.3  HCRASH

             HCRASH is called  to crash the PDP.   It places the  16-bit Crash-
        code  into the  PDP-KEY cell  (at o150),  and packs  the  16-bit PDPOEC
        (Output-Empty-Cursor) with  the 16-bit PDPIFC  (Input-Fill-Cursor) into
        the PDP-CRASH cell (at o30):

        HCRASH()
        {       P10ADR = 0150; RESET(); PUTNOT0( CODCASH << 16 );
                P10ADR = 030; RESET(); PUTNOT0( PDPOEC << 16 | PDPIFC );
                return;
        }



        8.2.2.4  PUTPDPL

             PUTPDPL  places the  argument  at the  (already  specified) P10ADR
        Left-Justified:

        PUTPDPL(v)
        long    v;                      /* v is the argument */
        {       (long) P10AH = v;
                P10DLL = $0F;           /* compensates for bit-inversion */
                WR10R();
                return;
        }



        8.2.2.5  PUTPDPR

             PUTPDPR  places the  argument  at the  (already  specified) P10ADR
        Right-Justified:



        45                Internal Maintenance Specification           EBUS.IMS
        I/O and Buffer Logic                                      June 23, 1986


        PUTPDPR(v)
        long    v;                      /* v is the argument */
        {       (long) P10AH = v >> 4;
                P10DLL = (char) v;      /* place low 4-bits into Drt */
                WR10R();
                return;
        }



        8.2.2.6  PUTIFC

             PUTIFC is used to place a copy of the 68K's Input-Fill-Cursor into
        the PDP's memory (at o156), Right-justified:

               NOTE:   The  PDP will  not  examine a  message  UNTIL the
                       presence of the  message is indicated by  the PDP
                       receiving  a  copy of  PDPIFC  which  extends the
                       input-ring  data  to include  the  message.  Call
                       PUTIFC  to  "flush"  the  message  for  the PDP's
                       examination.   Conversely, do  NOT call  it after
                       each transfer, unless that call corresponds to an
                       entire message;   otherwise the PDP  will attempt
                       to process an incomplete message.

        PUTIFC()
                PUTPDPR places the argument at the (already specified) P10ADR
        {       P10ADR = 0156;
                PUTPDPR( PDPIFC );
                return;
        }



        8.2.2.7  PUTOEC

             PUTOEC is used  to place a  copy of the  68K's Output-Empty-Cursor
        into the PDP's memory (at o162), Right-justified:

        PUTOEC()
        {       P10ADR = 0162; PUTPDPR( PDPOEC );
                return;
        }



        8.2.2.8  FDRGSZ

             FDRGSZ  is used  to  determine the  space available  in  the PDP's
        input-ring (in  bytes), based upon  the constraints imposed  by certain
        ISIS message types (from  INTYBT);  in particular, data  messages input
        to the PDP are not permitted  to wrap the ring.  The value  is returned
        in INRGSP:

        46                Internal Maintenance Specification           EBUS.IMS
        I/O and Buffer Logic                                      June 23, 1986


        FDRGSZ()
        {       GETIEP();               /* get the current empty-cursor */
                if (  ( INRGSP = 4*(PDPIEC-PDPIFC-1) )  >= 0 )
                        return;         /* empty behind fill */
                INRGSP = 4*PDPISZ-PDPIFC); /* fill behind empty */
                if ( DATRGZ ) return;  /* no wrap for BIO */
                if (  (INTYBT==0) !! (INTYBT>$9D) !! (PORTNM==0)  )
                 if ( PDPIEC>0 )
                  INRGSP += 4*(PDPIEC-1); /* non-data may wrap */
                return;
        }



        8.2.2.9  WAITPDP

             WAITPDP simply waits  until there is  at least one  PDP input-ring
        word available:

        WAITPDP
        {       do FDRGSZ()             /* loop here... */
                while ( INRGSP == 0 );  /* until space becomes available */
                return;
        }



        8.2.2.10  WRPDP

             WRPDP places its argument into the PDP input ring and performs the
        necessary  operations to  advance (and  fold, if  necessary)  the fill-
        cursor:

        WRPDP(v)
        long    v;                      /* v is the argument */
        {       P10ADR = PDPIRP+PDPIFC;
                PUTPDPL(v);
                if ( ++PDPIFC >= PDPISZ ) /* need to wrap the ring
                {   for ( ; PDPIEC==0 ; )GETIEP(); /* wait */
                    PDPIFC = 0;         /* wrap once PDP not at 0 */
                }
                return;
        }



        8.2.2.11  WRDAT

             WRDAT is an alternate  entry-point to WRPDP, which forces  the use
        of DAT as the argument:

        WRDAT   { WRPDP( (long) DAT); return; }


        47                Internal Maintenance Specification           EBUS.IMS
        I/O and Buffer Logic                                      June 23, 1986


        8.2.2.12  WAITDAT

             WAITDAT  is an  alternate entry-point  to WRDAT,  which  waits for
        space in the ring first:

        WAITDAT { WAITPDP();  WRDAT(); return; }



        8.2.2.13  WRBLK

             WRBLK is used to transmit  one word from DAT into the  current Bin
        Block/word, and advance the fill cursor:

        WRBLK()
        {       P10DAH = (long) DAT;
                SETBLKA( Rp->BI_TAR++ ); /* set address */
                WR10R();                /* write word */
                BLK = FALSE;
                return;
        }



        8.2.2.14  GETBLK

             GETBLK is  used to fetch  one word into  DAT from the  current Bin
        Block/word:

        GETBLK()
        {       SETBLKA( Rp->BI_TAR );  /* set address */
                RD10R();                /* read word */
                BLK = FALSE;
                return;
        }





                    8.2.3  Input From PDP

             The primary mode of input from the PDP is via the PDP output-ring.
        The 68K retains the following variables related to this ring:

        short   PDPORP;                 /* Pointer (to base of ring) */
        short   PDPOSZ;                 /* size of ring */
        short   PDPOFC;                 /* fill-cursor */
        short   PDPOEC;                 /* empty-cursor */

             There are a number of routines for input:



        48                Internal Maintenance Specification           EBUS.IMS
        I/O and Buffer Logic                                      June 23, 1986


        8.2.3.1  RD10R

             RD10R is the primative routine for all transfers from PDP to 68K:

        RD10R()
        {       short HW;               /* temp store */
                int     cnt, cnt1, tmoc; /* counters */
                for ( tmoc=0 ; tmoc < 16 ; { RESET(); tmoc++ )
                {   for ( cnt=0 ; cnt < 70 ; cnt++ )
                    {   if (SENSE() ) continue;
                        HW = 0;         /* for Drt...*/
                        if ( BLK == 0 ) /* if NOT Block-IO... */
                                HW = P10DLL;
                        *AHI = HW;
                        *ALO = $7FFF & P10ADR; /* set read */
                        for ( cnt1=0 ; cnt1 < 70 ;
                                { if ( TMOUT() ) break;
                                if ( PARITY() ) PARERR();
                                cnt1++; }  )
                        {   if ( SENSE() ) continue;
                            P10DAH = *DHI;
                            P10DAL = *DLO;
                            P10DLL = *AHI & $0F;
                            if ( PARITY() ) PARERR;
                            return;
                        }
                        BUSCRAS();
                    }
                    BUSCRAS();
                }
                TMOUT1();
        }



        8.2.3.2  GETPDPL

             GETPDPL fetches  the (left-justified)  argument from  the (already
        specified) P10ADR:

        GETPDPL(v)
        {       RD10R();                /* do the read */
                return (long) P10AH;    /* get the argument */
        }



        8.2.3.3  GETPDPR

             GETPDPR fetches the  (right-justified) argument from  the (already
        specified) P10ADR:



        49                Internal Maintenance Specification           EBUS.IMS
        I/O and Buffer Logic                                      June 23, 1986


        GETPDPR(v)
        {       long    v;              /* v is the argument */
                RD10R();                /* get the argument */
                v = ((long) P10AH) << 4;
                v != P10DLL & $0F;      /* pack argument */
                return v;
        }



        8.2.3.4  GETOFC

             GETOFC is used to fetch a copy of the PDP's Output-Fill-Cursor (at
        o161) into the 68K's memory:

        GETOFC()
        {       P10ADR = 0161; PDPOFC = GETPDPR();
                return;
        }



        8.2.3.5  GETIEC

             GETIEC is used to fetch a copy of the PDP's Input-Empty-Cursor (at
        o155) into the 68K's memory:

        GETIEC()
        {       P10ADR = 0155; PDPIEC = GETPDPR();
                return;
        }



        8.2.3.6  RDPDPRP

             RDPDPRP  is  used  to fetch  a  copy  of all  of  the  PDP's Ring-
        parameters (both input and output):

        RDPDPRP()
        {       P10ADR = 0157; PDPORP = GETPDPL();      /* Output-ring */
                P10ADR = 0160; PDPOSZ = GETPDPL();
                GETOEC();
                P10ADR = 0162; PDPOEC = GETPDPR();
                P10ADR = 0153; PDPIRP = GETPDPL();      /* Input-ring */
                P10ADR = 0154; PDPISZ = GETPDPL();
                GETIEC();
                P10ADR = 0156; PDPIFC = GETPDPR();
                return;
        }




        50                Internal Maintenance Specification           EBUS.IMS
        I/O and Buffer Logic                                      June 23, 1986


        8.2.3.7  RDPDP

             RDPDP fetches its argument from the PDP output ring (into DAT) and
        performs the necessary operations  to advance (and fold,  if necessary)
        the empty-cursor:

        RDPDP()
        {       P10ADR = PDPORP+PDPOEC;
                DAT = GETPDPL();
                if ( ++PDPOEC >= PDPOSZ ) /* need to wrap the ring
                    PDPOEC = 0;
                return;
        }



        8.2.3.8  RDBLK

             RDBLK is  used to fetch  one word into  DAT from the  current Bout
        Block/word:

        RDBLK()
        {       SETBLKA( Rp->BO_TAR++ ); /* set address */
                RD10R();                /* read word */
                BLK = FALSE;
                return;
        }





                    8.2.4  Buffer Routines

             Buffering  may be  performed on  data and  certain control-signals
        passing into the PDP, either because of Block-input, or because the PDP
        has applied back-pressure.

             Several routine provide the primative functions required:



        8.2.4.1  DGCI

             DGCI (Get Character and  Increment) is used to remove  a character
        from the buffer (as specified by Rp):








        51                Internal Maintenance Specification           EBUS.IMS
        I/O and Buffer Logic                                      June 23, 1986


        DGCI()
        {       char    c;
                int     b;
                b = Rp->BB++;           /* copy and advance cursor */
                c = .BFLTS[b++];        /* get char */
                if ( -- Rp->BCT <= 0 )  /* count it gone...now empty? */
                {   if (Rp->BCT < 0) DGCIH(); /* crash if underflow */
                    b += BFLSIZ-2;      /* force b to boundary */
                    b &= -BFLSIZ;
                    (short) .BFLTS[b] = (short) .BFLTS;
                    (short) .BFLTS = b;
                }
                else if ( (Rp->BB & (BFLSIZ-1) ) == 0) /* Bfl't exhausted? */
                {   Rp->BB = (short) .BFLTS[b];
                    (short) .BFLTS[b] = (short) .BFLTS - (BFLSIZ-2);
                    (short) .BFLTS = b;
                }
                return c;
        }



        8.2.4.2  DWCI

             DWCI (Write Character and Increment) is used to place  a character
        into the buffer described by Rp:

        DWCI(c)
        char    c;                      /* the character to place */
        {       int     b;
                if (Rp->BCT++ == 0)     /* if buffer was empty */
                {   if (Rp->BCT <= 0) DWCIH(); /* CRASH...count was negative */
                    if ( (b = (short) .BFLTS) == 0 ) WRE(); /* none left */
                    (short) .BFLTS = (short) .BFLTS[b];
                    Rp->BE = Rp->BB = b -= BFLSIZ-2;
                    .BFLTS[b] = c;
                    return;
                }
                b = ++ Rp->BE;          /* not empty...find next position */
                if ( b & (bflsiz-1) == 0 ) /* bufferlet exhausted? */
                {   if ( (b = (short) .BFLTS) == 0 ) WRE(); /* none left */
                    (short) .BFLTS = (short) .BFLTS[b];
                    (short) .BFLTS[Rp->BE] = b;
                    Rp->BE = b -= (BFLSIZ-2);
                }
                .BFLTS[b]=c;
                return;
        }






        52                Internal Maintenance Specification           EBUS.IMS
        I/O and Buffer Logic                                      June 23, 1986


        8.2.4.3  DEMPTY

             DEMPTY is used to empty a buffer:

        DEMPTY()
        {       int     b;
                if (Rp->BCT != 0)       /* nothing to do if already empty */
                {   Rp->BCT = 0;        /* must empty it */
                    b = Rp->BE + BFLSIZ-2;
                    b &= -BFLSIZ;
                    (short) .BFLTS[b] = (short) .BFLTS;
                    b = Rp->BB + BFLSIZ-2;
                    b &= -BFLSIZ;
                    (short) .BFLTS = b;
                }
                return;
        }





































        53                Internal Maintenance Specification           EBUS.IMS
        Debugging and Diagnostic Tools                            June 23, 1986






                          9 -  Debugging and Diagnostic Tools


             The EBUS code contains a minor amount of code to aid  in debugging
        and diagnosing hardware problems.

             MACSbug  is  also  available  within  the  68K;   While  useful, a
        detailed  discussion  of its  operation  is beyond  the  scope  of this
        document.






                             9.1  TRACE Assembly Switches


             The source code contains a number of  Assembly-switches:

           ITRACE: Activates trace of ISIS rings;
           RTRACE: Activates trace of PDP rings;
           BTRACE: Activates trace of BIO transfers;
           CTRACE: Activates trace of Buffer transfers.

             These  are OR'ed  into  an Assembly-switch  called  TRACING, which
        enables certain  useful features.   In particular,  the area  of memory
        from $20000  to $3FFE0  is set aside  as a  "Trace Area".   The pointer
        ".TRACE"  (long, located  at $1000)  contains the  cursor to  the trace
        area.

             An attempt is made to present a uniform trace mechanism, to permit
        the  simultaneous tracing  of any  or  all of  the above.   Thus  it is
        important to define the standard used:

             The trace consists of successive  (time-ordered) trace-descriptors
        in a Trace-ring.  This ring starts at STRACE, folds at ETRACE,  and the
        (next) descriptor address may be found in .TRACE.

             A trace-descriptor is 8 bytes long, and has the common form:

                | TR | dd | p# | ?? | V | A | L | U |

             TR|dd is  a pair  of characters which  specify the  operation (TR)
        being traced  and the  "direction" (dd);  p#  is (usually)  the current
        port;  ?? is additional information specific to the TR, and  V|A|L|U is
        the (long) value being transfered.

             Possible forms are:

        54                Internal Maintenance Specification           EBUS.IMS
        Debugging and Diagnostic Tools                            June 23, 1986


        TR|dd   Usage                   Notes
        >R      PDP-ring input          ?? is current fill-cursor
        <R      PDP-ring output         ?? is current empty-cursor
        >B      Block-input             ?? is current-address low byte
        @B      Block-input fetch       ?? is current-address low byte
        <B      Block-output            ?? is current-address low byte
        >C      DWCI
        <C      DGCI
        #C      DEMPTY
        lI      LOOK                    word 3 = port, word 4 is type (right)
        <I      ISIS input              ?? is number of bytes
        sI      SLOR                    word 3 = port, word 4 is type (right)
        >I      ISIS output             ?? is number of bytes
        xI      FLUSH                   ?? is number of bytes

             These may profitable be  examined (with MACSbug) to  determine the
        interaction between the 68K and the activities being traced.






                           9.2  Hardware Diagnostic Routines


             The EBUS code also contains several processes which may be  of use
        to  diagnose  hardware  problems.   Each of  these  begins  at  a fixed
        location in memory, and may be accessed with MACSbug.





                    9.2.1  $7C00 Test

             This test  performs a  sequence of  Write followed  by Read  for a
        range of addresses in the PDP.  Instances of mismatch between  what was
        written and what was read are counted for later review.

             The registers used are:

           D0:  the high order 32 bits to write to pdp-10
           D1:  last 4 bits are the low order 4 bits to write to 10
           D2:  the start address of the test
           D3:  the ending address of the test
           D4:  the counter of mismatch between read and write
           D5:  the high order 32 bits read from 10's memory
           D6:  last 4 bits are the low order 4 bits read from 10

             After   initializing  these   registers  (using   MACSbug),  start
        execution at $7C00.


        55                Internal Maintenance Specification           EBUS.IMS
        Debugging and Diagnostic Tools                            June 23, 1986


                    9.2.2  $7D00 Test

             This is a simple process to write repeatedly to PDP memory.

             The 68K registers must be initialized to:

           D0:  The data to be Written (left-justified) into the PDP;
           D1:  The values for AHI/DLO (low order byte);
           D2:  The Address to Write to.

             Then execution may be started at $7E00.





                    9.2.3  $7E00 Test

             This is a simple process to read repeatedly from PDP memory.

             The 68K registers must be initialized to:

           D2:  The Address to read from.

             Then execution may be started at $7F00.





























        56                Internal Maintenance Specification           EBUS.IMS
                                                                  June 23, 1986



























                      *   ****  ****  ***** *   * ****  ***** *   *
                     * *  *   * *   * *     **  * *   *   *    * * 
                    ***** ****  ****  ****  * * * *   *   *     *  
                    *   * *     *     *     *  ** *   *   *    * * 
                    *   * *     *     ***** *   * ****  ***** *   *
























        57                Internal Maintenance Specification           EBUS.IMS
        Summary of Base-to-Host Messages                          June 23, 1986






                    APPENDIX I.   Summary of Base-to-Host Messages



             Fields  are Byte  unless otherwise  specified;   Message-types are
        specified in decimal.

        Message Format                  Message Name

            3|use|< short v >           Reset Interface
            4|use|< short v >           Reset Acknowledgement
            5|0                         Supervisor Takeover
            6|p|< short h >             Externally-Initiated New Circuit
            7|p|key                     Internally-Initiated New Circuit
            8|p                         Backpressure On
            9|p                         Backpressure Off
           10|p                         Character Gobbler
           11|p                         Circuit Zapper
           12|p                         Enter Deferred Echo Mode
           13|p                         Leave Deferred Echo Mode
           14|p                         Green Ball
           15|p                         Red Ball
           16|p                         Yellow Ball
           17|p                         Orange Ball
           21|p|0                       Gray Ball
           21|p|FF                      Black Ball
           23|p|e                       Supervisor Response (to 20)
           26|0|< long d >              Test Pattern Response
           32|p|tc|val                  Terminal Characteristics Response
           35|0|< long t >              Supervisor Clock Data
           37|p                         Block Output Done
           39|p|< short c >             Block Input Done -- Block full
           40|p|< short c >             Block Input Done -- EOT
           41|p|< short c >             Block Input Timeout
           43|p|< short c >             Response to Block-Input Termination
           45|p                         Resp. to Block-Output Termination
           46|0|np                      Resp. to Block IO Port Request
           47|p|0                       Break(-begin) Character

        $80+n|p|< n bytes of data >     Data Bytes










        58                Internal Maintenance Specification           EBUS.IMS
        Summary of Host-to-Base Messages                          June 23, 1986






                    APPENDIX II.   Summary of Host-to-Base Messages



             Fields  are Byte  unless otherwise  specified;   Message-types are
        specified in decimal.

        Message Format                  Message Name

            1                           Host is Open
            2                           Host is Shut
            3|0|< short v >             Reset Interface...Interpreted by
                                         base as 1-char message telling base
                                         that host has crashed.
            4|0|< short v >             Reset Acknowledgement
            8|p                         Backpressure On
            9|p                         Backpressure Off
           10|p                         Character Gobbler
           11|p                         Circuit Zapper
           12|p                         Enter Deferred Echo Mode
           13|p                         Leave Deferred Echo Mode
           14|p                         Green Ball
           15|p                         Red Ball
           16|p                         Yellow Ball
           17|p                         Orange Ball
           18|p                         Hang Character
           19|p                         Enter Transparency Mode
           20|p                         Leave Transparency Mode
           22|q|0                       Supervisor Request (for AUX circuit)
           24|q|d                       Supervisor Login Character
           25|0|< long d >              Test Pattern Probe
           27|0|< long d >              Host Sad
           28|p                         Echo On
           29|p                         Echo Off
           30|p|tc|val                  Set Terminal Characteristics
           31|p|tc                      Probe Terminal Characteristics
           33|np|< short hn >           Set Host Number
           34|0                         Supervisor Clock Request
                                        (Ignored by base)
           36|p|< short c >|< (3) a >   Block Output Request
           38|p|< short c >|< (3) a >   Block Input Request
           42|p                         Terminate Block Input
           44|p                         Terminate Block Output
           46|0|np                      Request for Block IO Ports
           51|0|< short d >             Set timeout limit

        $80+n|p|< n bytes of data >     Data Bytes



        59                Internal Maintenance Specification           EBUS.IMS
        Summary of Host-to-Base Messages                          June 23, 1986


             All other  message types are  considered invalid, and  grounds for
        telling the host to crash!




















































        60                Internal Maintenance Specification           EBUS.IMS
        INDEX                                                     June 23, 1986


                                         INDEX

        AUXKEY - hold AUX-key here  3@,       ELOR Routine  21, 22, 24, 25, 40@
           24, 25                             EMPTY Routine  12@
                                              EXEC process  8@

        BB - bufferlet-begin  3@
        BCT - count of characters  3@,        FDRGSZ Routine  13, 20, 46@
           23, 26, 27                         FLUSH Routine  22, 42@
        BE - bufferlet-end  3@
        BI_BYT - Block-input: pos. within
           current word  3@, 31, 34           GEHTLN Routine  13, 19@
        BI_LCN - Block-input: input count     GETBLK Routine  48@
           (so far)  3@, 31, 34, 35           GETCH Routine  21, 22, 24, 25,
        BI_TAR - Block-input: (PDP) block        26, 27, 41@
           start address  3@, 31, 35, 48      GETH Routine  21, 24, 25, 41@
        BI_TCN - Block-input: input count     GETIEC Routine  50@
           (total)  3@, 31, 34, 35            GETOFC Routine  50@
        BI_TIM - Block-input: time            GETPDPL Routine  49@
           (FASTC) last activity  3@, 31,     GETPDPR Routine  49@
           32                                 GETW Routine  41@
        BKITERM Routine  35@
        BKOTERM Routine  30@
        Black-Box  42                         HCRASH Routine  45@
        BLOKIN Process  31@                   HREPRT Function  10@
        BO_BYT - Block-output: byte
           position within word  3@, 29
        BO_TAR - Block-output: (PDP)          IBRATE - Input baud-rate  3@, 22
           block start addr.  3@, 29, 51      IPORT Routine  11@, 24
        BO_TCN - Block-output: output         ISP Label  23, 24@
           count (remaining)  3@, 29          IS_BU Label  26, 27@
        BU_ADD Routine  36@                   IS_BUF Label  26, 27@
        BU_BK Routine  34@
        BU_COD Routine  34@
        BU_EMP Routine  23                    LIST -- linked-list  2@
        BU_RG Routine  33@                    LOGFAL Label  24@
        BU_RGX Routine  34@                   LOOK Routine  41@
                                              LOOKUP Function  24, 27@

        CLEANUP Label  21, 22, 24, 25,
           26, 27@                            MACSbug  5, 55


        DAT -- Data-array  2@                 P10ADR Variable  43@, 44, 45, 46,
        DEMPTY Routine  23, 53@                  47, 49, 50, 51
        DGCI Routine  51@                     P10DAH Variable  43@, 44, 48, 49
        DOBKOUT Process  29@                  P10DAL Variable  43@, 44, 49
        DOKEY Function  10@                   P10DLL Variable  43@, 44, 45, 46,
        DPORT Routine  11@, 22                   49, 50
        DWCI Routine  24, 27, 52@             PDPIEC Variable  44@, 47, 50
                                              PDPIFC Variable  44@, 45, 46, 47,
                                                 50
        ELIR Routine  27, 42@                 PDPIRP Variable  44@, 47, 50

        61                Internal Maintenance Specification           EBUS.IMS
        INDEX                                                     June 23, 1986




        PDPISZ Variable  44@, 47, 50          Semaphore:  .SYNC  8@
        PDPOEC Variable  45, 46, 48@, 50,     SEND17 Routine  15, 19@
           51                                 SENDDAT Label  20, 21, 25, 27@
        PDPOFC Variable  48@, 50              SETBLKA Routine  44@, 48, 51
        PDPORP Variable  48@, 50, 51          SETPORT function  4@
        PDPOSZ Variable  13, 48@, 50, 51      SLOR Routine  21, 22, 24, 25, 39@
        PF_ACT - port active flag Flag-       SOFT Routine  11@
           bit  3@                            STREAM Label  23@
        PF_BFD - Block FilleD Flag-bit        STREAM1 Label  23, 24@
           3@
        PF_BKI - Block-Input active Flag-
           bit  3@                            TRACE Area of Memory  54@
        PF_BKO - Block-Output active          TRACE Assembly-Switches  54@
           Flag-bit  3@
        PF_HBP - Input Back-pressure
           applied (by Host) Flag-bit  3@     UNLINK Routine  35, 36@
        PF_IBP - Input Back-pressure
           applied (by us) Flag-bit  3@
        PF_OBP - Output Back-pressure         WAITDAT Routine  14, 19, 22, 23,
           applied (by ISIS) Flag-bit  3@        25, 48@
        Pointer .TRACER  54@                  WAITIS Routine  38@
        Port Descriptor  3@                   WAITISW Routine  22, 24, 38@
        PORTS -- Port-descriptor Array        WAITPDP Routine  47@
           3@                                 WR10R Routine  44@, 45, 46, 48
        PTMSND Routine  18@                   WRBLK Routine  48@
        PTSMN1 Routine  19@                   WRDAT Routine  16, 19, 21, 27,
        PUTCH Routine  39@                       47@
        PUTH Routine  39@                     WRPDP Routine  26, 47@
        PUTIFC Routine  16, 20, 28, 30,
           33, 34, 35, 46@
        PUTNOT0 Routine  45@                  XMITLMT - transmit limit  3@, 25
        PUTOEC Routine  13, 46@
        PUTPDPL Routine  45@
        PUTPDPR Routine  45@
        PUTPN Label  24, 27@
        PUTW Routine  40@
        P_FLAGS - port status flags  3@
        P_NUM - port number  3@


        RBTALL Routine  22, 24, 36@
        RBTBKI Routine  35@
        RBTBKO Routine  35@
        RBTBUF Routine  36@
        RD10R Routine  49@, 50, 51
        RDBLK Routine  51@
        RDPDP Routine  51@
        RDPDPRP Routine  50@
        ROOM Routine  38@
        Rp -- current port-descriptor
           pointer  3@

        62                Internal Maintenance Specification           EBUS.IMS
 M(3