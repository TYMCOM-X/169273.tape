
EBUS02.J00/X               E B U S  --  PDP-10 Base Code, Version 2.00                   15-Apr-88  Page    1
Err Source Ref. Address   value
    line   line

       1      1                          		TTL	'E B U S  --  PDP-10 Base Code, Version 2.00'
       2      2                          	
       3      3                          	*			***** ****  *   *  ****
       4      4                          	*			*     *   * *   * *
       5      5                          	*			****  ****  *   *  ***
       6      6                          	*			*     *   * *   *     *
       7      7                          	*			***** ****   ***  ****
       8      8                          	
       9      9                          	*************************************************************************
      10     10                          	**	                PROPRIETARY INFORMATION                        **
      11     11                          	**	                                                               **
      12     12                          	**	This  source code listing constitutes the proprietary pro-     **
      13     13                          	**	perty of TYMNET, Incorporated. The recipient, by receiving     **
      14     14                          	**	this program listing, agrees that neither this listing nor     **
      15     15                          	**	the   information  disclosed herein nor any  part  thereof     **
      16     16                          	**	shall be  reproduced or transferred to other documents  or     **
      17     17                          	**	used  or  disclosed to others for manufacturing or for any     **
      18     18                          	**	other   purpose except as specifically authorized in  wri-     **
      19     19                          	**	ting by  TYMNET, Incorporated.                                 **
      20     20                          	*************************************************************************
      21     21                          	
      22     22                          		OPT	A,B,-M,-I
      23     23                          	
      24     24 00000200                 	VERSION	EQU	$200			; VERSION NUMBER
      25     25 00000091                 	PRODID	EQU	$91			; product-ID
      26     26 00000000                 	DEBUG	EQU	0			; what to tell host when we come up
      27     27 00000100                 	MAXPORT	EQU	256			; maximum number of ports supported
      28     28 00000010                 	BFLSIZ	EQU	16			; bufferlet size (Power of 2!!)
      29     29 0000001B                 	ESC	EQU	$1B			; code used for escapes (in buffers)
      30     30 000000AC                 	YB_CODE	EQU	$AC			; code for Yellow-ball
      31     31                          	
      32     32                          	*	Assembly and Debugging Switches
      33     33 00000001                 	RTRACE	EQU	1			; Enable trace of PDP ring transfers
      34     34 00000000                 	BTRACE	EQU	0			; Enable trace of PDP BIO transfers
      35     35 00000000                 	ITRACE	EQU	0			; Enable trace of ISIS transfers
      36     36 00000000                 	CTRACE	EQU	0			; Enable trace of Buffer transfers
      37     37 00000001                 	TRACING	EQU	RTRACE!BTRACE!ITRACE!CTRACE	; Switch if ANY trace active
      38     38                          	
      39     39                          	
      40     40                          	*	Special (RESERVED) Register Declarations
      41     41 0000000C                 	Rp	EQU	A4			; Pointer to port-descriptor
      42     42 0000000D                 	Rs	EQU	A5			; Pointer to Start of ISIS Input Ring
      43     43 0000000E                 	Rd	EQU	A6			; Pointer to Start of ISIS Output Ring
      44     44 00000007                 	Cs	EQU	D7			; Cursor to position within Input Ring
      45     45 00000006                 	Cd	EQU	D6			; Cursor to position within Output Ring
      46     46                          	
      47     47                          	
      48     48                          	*	B A S I C   M E M O R Y   L A Y O U T
      49     49                          	
      50     50                          	*	"Magic" addresses for addressing the Engine
      51     51 FFFFF901                 	ENGINE	EQU	$FFFFF901		; address to interrupt the engineEBUS02.J00/X               E B U S  --  PDP-10 Base Code, Version 2.00                   15-Apr-88  Page    2
Err Source Ref. Address   value
    line   line

      52     52                          	
      53     53 0000013C                 	ENGVECT	EQU	$13C			; Engine-interrupt Vector Location
      54     54                          	*		$900			  Bottom of stack
      55     55                          	*		$1000			  Top-of-Stack;  Beginnings of tables
      56     56                          	*					   and variable storage
      57     57 00004000                 	PATCHR	EQU	$4000			; PATCH AREA
      58     58                          	*		$4F00			  Beginning of Bootstrap
      59     59                          	*		$5000			  Beginning of Code
      60     60                          	*		$7C00			  STARTES -- Diagnostic Routine
      61     61                          	*		$7D00			  CONWRT -- diagnostic routine
      62     62                          	*		$7E00			  READ diagnostic routine
      63     63 00008000                 	BUFER	EQU	$8000			; bufers
      64     64 0000F000                 	BUFEREND EQU	BUFER+$7000		; the end of the bufferlet area
      65     65                          	 IF	TRACING
      66     66 00020000                 	STRACE	EQU	$20000			; beginning of trace area
      67     67 0003FFE0                 	ETRACE	EQU	$3FFE0			; end of trace area
      68     68                          	 ENDC
      69     69                          	*		$????			
      70     70                          	
      71     71                          	*	Various Locations for doing Read and Write to PDP-10
      72     72 00D000B8                 	DSENS	EQU	$D000B8			; D0=0-BUSY, 1-NOT BUSY
      73     73 00D00138                 	DPER	EQU	$D00138			; D0=1-ERROR, DO AFTER READ
      74     74 00D001B8                 	DTMOT	EQU	$D001B8			; D0=1-TIMEOUT
      75     75 00D01038                 	DEXCO	EQU	$D01038			; RESET BOX SIGNAL ONLY
      76     76 00D010B8                 	DEXC1	EQU	$D010B8			; NEXT WRT TO PDP10 WRITE WRONG PARITY
      77     77                          	
      78     78                          	*	Locations for reading from PDP-10
      79     79 00D0403A                 	RD101	EQU	$D0403A
      80     80 00D0403C                 	RD104	EQU	$D0403C
      81     81 00D0403E                 	RD102	EQU	$D0403E
      82     82 00D04038                 	RD103	EQU	$D04038
      83     83                          	
      84     84                          	*	Locations for Writing to PDP-10
      85     85 00D0803A                 	WT101	EQU	$D0803A
      86     86 00D0803C                 	WT102	EQU	$D0803C
      87     87 00D0803E                 	WT103	EQU	$D0803E
      88     88 00D08038                 	WT104	EQU	$D08038EBUS02.J00/X               E B U S  --  PDP-10 Base Code, Version 2.00                   15-Apr-88  Page    3
Err Source Ref. Address   value
    line   line

      90     90                          	
      91     91                          	*	Define data-structure for Port-Descriptor:
      92     92                          		OFFSET	0
      93     93 00000000                 	P_NUM	DS.B	1			; spare copy of port-number
      94     94 00000001                 	P_FLAGS	DS.B	1			; port status (flags)
      95     95 00000000                 	 PF_ACT: EQU	0			; port active
      96     96 00000001                 	 PF_OBP: EQU	1			; Output Back-pressure applied (by ISIS)
      97     97 00000002                 	 PF_IBP: EQU	2			; Input Back-pressure applied (by us)
      98     98 00000003                 	 PF_HBP: EQU	3			; Input Back-pressure applied (by Host)
      99     99 00000004                 	 PF_BKO: EQU	4			; Block-Output active
     100    100 00000005                 	 PF_BKI: EQU	5			; Block-Input active
     101    101 00000006                 	 PF_BFD: EQU	6			; Block FilleD
     102    102                          	
     103    103 00000002                 	XMITLMT	DS.B	1			; transmit limit
     104    104 00000003                 	IBRATE	DS.B	1			; Input baud-rate
     105    105 00000003                 	AUXKEY	EQU	IBRATE			; hold AUX-key here too
     106    106                          	
     107    107 00000004                 	BO_TAR	DS.L	1			; Block-output -- (PDP) block start addr.
     108    108 00000008                 	BO_BYT	DS.W	1			; Block-Output -- byte position within word
     109    109 0000000A                 	BO_TCN	DS.W	1			; Block-output -- output count (total left)
     110    110                          	
     111    111 0000000C                 	BI_TIM	DS.L	1			; Block-input -- time (FASTC) last activity
     112    112 00000010                 	BI_TAR	DS.L	1			; Block-input -- (PDP) block start address
     113    113 00000014                 	BI_TCN	DS.W	1			; Block-input -- input count (total)
     114    114 00000016                 	BI_LCN	DS.W	1			; Block-input -- input count (so far)
     115    115 00000018                 	BI_BYT	DS.W	1			; Block-input -- pos. within current word
     116    116                          	
     117    117 0000001A                 	BB	DS.W	1			; bufferlet-begin
     118    118 0000001C                 	BE	DS.W	1			; bufferlet-end
     119    119 0000001E                 	BCT	DS.W	1			; count of characters
     120    120 00000020                 	PD_SIZ	DS.W	0			; size of descriptorEBUS02.J00/X               E B U S  --  PDP-10 Base Code, Version 2.00                   15-Apr-88  Page    4
Err Source Ref. Address   value
    line   line

     122    122                          	
     123    123                          	***	Define some useful Macros
     124    124                          	
     125    125                          	*	Macro to Cause VCRASH with crash-code VAL
     126    126                          	CRASH	MACRO	VAL
     127    127                          		MOVE.B	#VAL,CODCASH		; set crash-code
     128    128                          		BRA	VCRASH			; go do it
     129    129                          		ENDM
     130    130                          	
     131    131                          	*	Macro to Cause (FATAL!) BCRASH with crash-code VAL
     132    132                          	FCRASH	MACRO	VAL
     133    133                          		MOVE.B	#VAL,CODCASH		; set crash-code
     134    134                          		BSR	BCRASH			; go do it
     135    135                          		ENDM
     136    136                          	
     137    137                          	*	Macro to PUSH a register onto the stack
     138    138                          	PUSH	MACRO	REG
     139    139                          		MOVE.L	REG,-(SP)
     140    140                          		ENDM
     141    141                          	
     142    142                          	*	Macro to POP a register from the stack
     143    143                          	POP	MACRO	REG
     144    144                          		MOVE.L	(SP)+,REG
     145    145                          		ENDM
     146    146                          	
     147    147                          	*	Macro to PUSH multiple registers onto the stack
     148    148                          	PUSHM	MACRO	REGS
     149    149                          		MOVEM.L	REGS,-(SP)
     150    150                          		ENDM
     151    151                          	
     152    152                          	*	Macro to POP multiple registers from the stack
     153    153                          	POPM	MACRO	REGS
     154    154                          		MOVEM.L	(SP)+,REGS
     155    155                          		ENDM



     157    157                          	        ORG	$900			; where we actually begin



     159    159                          		TTL	'E B U S  --  PDP-10 Base Code,		V A R I A B L E S'EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		V A R I A B L E S             15-Apr-88  Page    5
Err Source Ref. Address   value
    line   line

     161    161                          	
     162    162 00000900                 		DS.L	490			: The Bottom of the Stack
     163    163 000010A8                 		DS.L	0
     164    164                          		ORG	$1000
     165    165 00001000                 	STKTOP	DS.L	0			; the end (Top) of the stack
     166    166                          	
     167    167                          	 IF	TRACING
     168    168 00001000 0002 0000       	.TRACE	DC.L	STRACE			; Current Trace Pointer
     169    169                          	 ENDC
     170    170                          	
     171    171 00001004 0000 0000       	CODCASH	DC.L	0			; leave as Long, even if used as Byte
     172    172 00001008 0000 0000       	PCCASH	DC.L	0			; save PC here on crash
     173    173 0000100C 0000 0000       	CASHW	DC.L	0			; information about message causing crash
     174    174                          	
     175    175                          	 IF	TRACING
     176    176 00001010 FFFF            	TR_PORT	DC.W	-1			; Trace ONLY this port if not <0
     177    177                          	 ENDC
     178    178                          	
     179    179                          	*	The following data is read from Engine and translated for subsequent
     180    180                          	*	references by the base code.
     181    181 00001012                 	ISTOME	DS.L	1			; Address to get info from ISIS
     182    182 00001016                 	METOIS	DS.L	1			; Address to pass info to ISIS
     183    183 0000101A 0000 0000       	SLTOME	DC.L	0			; Address to get parameters from slot
     184    184 0000101E 0000 0000       	METOSL	DC.L	0			; Address to put crash info into slot
     185    185 00001022                 	.SYNC	DS.L	1			; Address to perform slot-synchronization
     186    186 00001026                 	ORING	DS.L	1			; Dispatcher Output Ring Start Address
     187    187 0000102A                 	IRING	DS.L	1			; Dispatcher Input Ring Start Address
     188    188 0000102E                 	.SLOWC	DS.L	1			; Address of SLOWC Time
     189    189 00001032                 	.FASTC	DS.L	1			; Address of FASTC
     190    190 00001036                 	IRSIZE	DS.W	1			; record ISIS input-ring size here
     191    191 00001038                 	ORSIZE	DS.W	1			; record ISIS output-ring size here
     192    192                          	
     193    193                          	
     194    194 0000103A 0000            	P10DAH	DC.W	0			; High data
     195    195 0000103C 0000            	P10DAL	DC.W	0			; low data
     196    196 0000103E 00              	P10DLL	DC.B	0			; high address | low data (4-bits each)
     197    197 00001040 0000            	P10ADR	DC.W	0			; low (15-bit) read/write addr. in PDP
     198    198                          	
     199    199                          	
     200    200 00001042                 	ZERO	DS.L	0			; beginning of area to zero-out on init.
     201    201                          	
     202    202                          	
     203    203 00001042                 	HOSTN	DS.W	1			; Host Number
     204    204 00001044                 	HOSTP	DS.W	1			; Number of Host Ports
     205    205 00001046                 	HSTAT	DS.W	1			; Host status | Host key
     206    206                          						; 0=ANSW 1=DOWN 2=SHUT 3=GONE
     207    207 00001048                 	HOSTTO	DS.W	1			; Host-specified timeout (for Key test)
     208    208 0000104A                 	TOHOST	DS.W	1			; Current Host-Key timeout
     209    209                          	
     210    210 0000104C                 	MXPORT	DS.W	1			; maximum number of active ports possibleEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		V A R I A B L E S             15-Apr-88  Page    6
Err Source Ref. Address   value
    line   line

     211    211 0000104E                 	NPORTS	DS.W	1			; current number of active ports
     212    212                          	
     213    213 00001050                 	AUXQ	DS.W	1			; AUX circuit key (= requesting port number)
     214    214 00001052                 	AUXTIM	DS.L	1			; timeout for AUX circuit request
     215    215 00001056                 	AUXX	DS.W	1			; index into AUXC
     216    216 00001058                 	AUXC	DS.B	40			; AUX logon-string
     217    217                          	
     218    218                          	
     219    219 00001080                 	TYPBYT	DS.B	1			; message type
     220    220 00001081                 	HTDWN	DS.B	1			; flag -- host down if NE 0
     221    221                          	
     222    222 00001082                 	PDPORP	DS.W	1			; start address of PDP's output ring
     223    223 00001084                 	PDPOSZ	DS.W	1			; Size of PDP's output ring
     224    224 00001086                 	PDPOFC	DS.W	1			; PDP output ring Fill Cursor
     225    225 00001088                 	PDPOEC	DS.W	1			; our PDP output ring Empty Cursor
     226    226 0000108A                 	PDPIRP	DS.W	1			; start address of PDP's input ring
     227    227 0000108C                 	PDPISZ	DS.W	1			; Size of PDP's input ring
     228    228 0000108E                 	PDPIEC	DS.W	1			; PDP input ring Empty Cursor
     229    229 00001090                 	PDPIFC	DS.W	1			; our PDP input ring Fill Cursor
     230    230 00001092                 	INRGSP	DS.W	1			; # of bytes of space in PDP input ring
     231    231 00001094                 	INTYBT	DS.W	1			; Type byte of MSG input from ISIS
     232    232 00001096                 	PORTNO	DS.W	1			; Current Port number
     233    233 00001098                 	NORNODE	DS.W	1			; normal login origination node
     234    234 0000109A                 	NO	DS.W	1			; normal login origination port
     235    235 0000109C                 	DAT	DS.L	0			; DAT1--4 are both LONG, and single Bytes
     236    236 0000109C                 	DAT1	DS.B	1			; for message type
     237    237 0000109D                 	DAT2	DS.B	1			; for port number
     238    238 0000109E                 	DAT3	DS.B	1
     239    239 0000109F                 	DAT4	DS.B	1
     240    240 000010A0                 	DAT5	DS.B	48			; extra space available here
     241    241 000010D0                 	NCCT	DS.B	1			; save CCT from needle here
     242    242 000010D1                 	NSIZ	DS.B	1			; save username size from needle here
     243    243 000010D2 00              	BLK	DC.B	0			; flag: non BIO usage if = 0
     244    244 000010D4                 	SLOWC	DS.L	1			; Clock within Engine
     245    245 000010D8                 	HTM	DS.L	1			; Time of last Open/Shut MSG (FASTC)
     246    246 000010DC                 	LFASTC	DS.L	1			; Time of last 1/2 sec logic
     247    247                          	
     248    248 000010E0                 	LASCOU	DS.W	1			; count of good keys
     249    249                          	
     250    250 000010E2                 	BKPR	DS.W	1			; # of bytes before applying back-pressure
     251    251 000010E4                 	IRRN	DS.W	1			; ISIS-input "throttle"
     252    252 000010E6                 	ORRN	DS.W	1			; host-output "throttle"
     253    253                          	
     254    254 000010E8                 	.BFLTS	DS.L	1			; pointer to bufferlet area
     255    255 000010EC                 	NBFLTS	DS.W	1			; number of bufferlets
     256    256 000010EE                 	R_TANK	DS.W	1			; bufferlet reserve tank
     257    257                          	
     258    258 000010F0                 	BLKFREE	DS.W	1			; pointer to block-IO free-list
     259    259 000010F2                 	BKIHEAD	DS.W	1			; block-input list head (pointer or null)
     260    260 000010F4                 	BKOHEAD	DS.W	1			; block-output list head (pointer or null)
     261    261 000010F6                 	BUFHEAD	DS.W	1			; Buffer list head (pointer or null)EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		V A R I A B L E S             15-Apr-88  Page    7
Err Source Ref. Address   value
    line   line

     262    262 000010F8                 	SAVE1	DS.W	1
     263    263 000010FA                 	TMOC	DS.B	1
     264    264 000010FB                 	PFULL	DS.B	1			; flag for ports full (if non-zero)
     265    265 000010FC                 	DIAG	DS.B	1			; flag for diagnostic in progress
     266    266                          	
     267    267 000010FE                 	FREEBLK	DS.L	2*MAXPORT		; Block-IO Free-list storage
     268    268                          	
     269    269 000018FE                 	PORTS	DS.B	PD_SIZ*MAXPORT		; storage for port-descriptors
     270    270                          	
     271    271                          	
     272    272 000038FE                 	ENDZERO	DS.L	0			; end of area to zero-out on init.



     274    274                          		TTL	'E B U S  --  PDP-10 Base Code,		T A B L E S'EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		T A B L E S                   15-Apr-88  Page    8
Err Source Ref. Address   value
    line   line

     276    276                          	
     277    277                          	
     278    278                          	*	TRANSLATED HOST MSG LENGTH
     279    279 000038FE 00              	TRHSTLN	DC.B	0			; 00
     280    280 000038FF 0C              		DC.B	12			; 01
     281    281 00003900 0C              		DC.B	12			; 02
     282    282 00003901 00              		DC.B	0			; 03
     283    283 00003902 00              		DC.B	0			; 04
     284    284 00003903 00              		DC.B	0			; 05
     285    285 00003904 00              		DC.B	0			; 06
     286    286 00003905 00              		DC.B	0			; 07
     287    287 00003906 03              		DC.B	3			; 08
     288    288 00003907 03              		DC.B	3			; 09
     289    289 00003908 03              		DC.B	3			; 0A
     290    290 00003909 03              		DC.B	3			; 0B
     291    291 0000390A 03              		DC.B	3			; 0C
     292    292 0000390B 03              		DC.B	3			; 0D
     293    293 0000390C 03              		DC.B	3			; 0E
     294    294 0000390D 03              		DC.B	3			; 0F
     295    295 0000390E 03              		DC.B	3			; 10
     296    296 0000390F 03              		DC.B	3			; 11
     297    297 00003910 03              		DC.B	3			; 12
     298    298 00003911 03              		DC.B	3			; 13
     299    299 00003912 03              		DC.B	3			; 14
     300    300 00003913 00              		DC.B	0			; 15
     301    301 00003914 04              		DC.B	4			; 16 ****
     302    302 00003915 00              		DC.B	0			; 17
     303    303 00003916 34              		DC.B	52			; 18
     304    304 00003917 06              		DC.B	6			; 19 ****
     305    305 00003918 00              		DC.B	0			; 1A
     306    306 00003919 00              		DC.B	0			; 1B
     307    307 0000391A 05              		DC.B	5			; 1C
     308    308 0000391B 05              		DC.B	5			; 1D
     309    309 0000391C 05              		DC.B	5			; 1E
     310    310 0000391D 64              		DC.B	100			; 1F ****
     311    311 0000391E 00              		DC.B	0			; 20
     312    312 0000391F 0C              		DC.B	12			; 21
     313    313 00003920 00              		DC.B	0			; 22 ****
     314    314 00003921 00              		DC.B	0			; 23
     315    315 00003922 00              		DC.B	0			; 24
     316    316 00003923 00              		DC.B	0			; 25
     317    317 00003924 00              		DC.B	0			; 26
     318    318 00003925 00              		DC.B	0			; 27
     319    319 00003926 00              		DC.B	0			; 28
     320    320 00003927 00              		DC.B	0			; 29
     321    321 00003928 00              		DC.B	0			; 2A
     322    322 00003929 00              		DC.B	0			; 2B
     323    323 0000392A 00              		DC.B	0			; 2C
     324    324 0000392B 00              		DC.B	0			; 2D
     325    325 0000392C 00              		DC.B	0			; 2EEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		T A B L E S                   15-Apr-88  Page    9
Err Source Ref. Address   value
    line   line

     326    326 0000392D 00              		DC.B	0			; 2F
     327    327 0000392E 00              		DC.B	0			; 30
     328    328 0000392F 03              		DC.B	3			; 31
     329    329 00003930 03              		DC.B	3			; 32
     330    330 00003931 00              		DC.B	0			; 33
     331    331 00003932 00              		DC.B	0			; 34
     332    332 00003933 00              		DC.B	0			; 35
     333    333 00003934 00              		DC.B	0			; 36
     334    334 00003935 00              		DC.B	0			; 37
     335    335 00003936 00              		DC.B	0			; 38
     336    336 00003937 00              		DC.B	0			; 0
     337    337                          	
     338    338                          	*	Table of Input Baud Rates in CCT order
     339    339 00003938 0502 0202       	CCTBD	DC.B	5,2,2,2,2,1,1,1		; GET BAUD RATE FROM CCT
     339    340 0000393C 0201 0101       	
     340    341 00003940 0607 0005       		DC.B	6,7,0,5,5,5,5,0
     340    342 00003944 0505 0500       	
     341    343 00003948 0A05 050B       		DC.B	10,5,5,11,12,5,5,5
     341    344 0000394C 0C05 0505       	
     342    345 00003950 0505 0505       		DC.B	5,5,5,5,5,5,5,5
     342    346 00003954 0505 0505       	



     344    348                          		TTL	'E B U S  --  PDP-10 Base Code,		B O O T S T R A P'EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		B O O T S T R A P             15-Apr-88  Page   10
Err Source Ref. Address   value
    line   line

     346    350                          		ORG	$4F00
     347    351                          	
     348    352 00004F00 307C 4F24       	ENTRY	MOVE.W	#BOBCODE,A0		; intercept subsequent Engine interrupts
     349    353 00004F04 21C8 013C       		MOVE.L	A0,ENGVECT		; set up interrupt location
     350    354 00004F08 4238 10D2       		CLR.B	BLK			; insure not expecting BIO
     351    355 00004F0C 21C9 1012       		MOVE.L	A1,ISTOME		; address of ISIS-to-us message area
     352    356 00004F10 21CA 1016       		MOVE.L	A2,METOIS		; address of us-to-ISIS message area
     353    357 00004F14 24BC 0000 0002  		MOVE.L	#2,(A2)
     354    358 00004F1A                 		POPM	D0-D7/A0-A6
     355    360 00004F1E 612C            		BSR	INTRPT			; interrupt engine
     356    361 00004F20 4E72 2000       		STOP	#$2000			; Halt, Enable Interrupts
     357    362                          	
     358    363                          	*	Here on interrupt from engine
     359    364 00004F24 46FC 2700       	BOBCODE	MOVE	#$2700,SR		; Disable Interrupts
     360    365 00004F28                 		PUSHM	D0-D7/A0-A6
     361    367 00004F2C 2078 1012       		MOVEA.L	ISTOME,A0		; address of ISIS-to-us message area
     362    368 00004F30 3010            		MOVE.W	(A0),D0			; get high HW from there
     363    369 00004F32 0240 0F00       		ANDI.W	#$0F00,D0		; examining only second nibble
     364    370 00004F36 0C40 0400       		CMPI.W	#$0400,D0
     365    371 00004F3A 6742            		BEQ	GETIOWA			; 4 is what we expect, and is OK
     366    372 00004F3C 0C40 0500       		CMPI.W	#$0500,D0
     367    373 00004F40 6618            		BNE	FFCRA			; anything but 4 or 5 is reason to crash
     368    374 00004F42                 		POPM	D0-D7/A0-A6
     369    376 00004F46 46FC 2000       		MOVE	#$2000,SR		; Enable Interrupts
     370    377 00004F4A 4E73            		RTE				; got 5...just return
     371    378                          	
     372    379                          	*	Interrupt the Engine
     373    380 00004F4C 11FC 00C0 F901  	INTRPT	MOVE.B	#$0C0,ENGINE		; Interrupt ENGINE
     374    381 00004F52 11FC 00C1 F901  		MOVE.B	#$0C1,ENGINE
     375    382 00004F58 4E75            		RTS
     376    383                          	
     377    384 00004F5A 0C40 0300       	FFCRA	CMPI.W	#$0300,D0		; additional check
     378    385 00004F5E 6600 022E       		BNE.L	BCRASH			; other than 3 causes us to crash (FATAL)
     379    386 00004F62 11FC 00EC 1004  		MOVE.B	#$EC,CODCASH		; else set reason
     380    387 00004F68 6100 01EC       		BSR.L	REGDMP			; and dump our registers
     381    388 00004F6C 6100 05D4       		BSR.L	HCRASH			; then crash the host
     382    389 00004F70 11FC 0001 1081  		MOVE.B	#1,HTDWN		; set host down
     383    390 00004F76                 	        POPM	D0-D7/A0-A6
     384    392 00004F7A 4E72 2000       		STOP	#$2000			; Halt, Enable Interrupts
     385    393                          	
     386    394 00004F7E 2010            	GETIOWA	MOVE.L	(A0),D0			; get ISIS-to-us message
     387    395 00004F80 0280 00FF FFFF  		ANDI.L	#$00FFFFFF,D0
     388    396 00004F86 0080 00E0 0000  		ORI.L	#$00E00000,D0		; translate for our address-space
     389    397 00004F8C 21C0 101A       		MOVE.L	D0,SLTOME		; address of slot parameters
     390    398 00004F90 21C0 101E       		MOVE.L	D0,METOSL		; same as Slot-to-me address
     391    399 00004F94 2078 1016       		MOVE.L	METOIS,A0		; get us-to-ISIS address
     392    400 00004F98 20BC 0000 0004  		MOVE.L	#4,(A0)			; tell ISIS "4"
     393    401 00004F9E                 		POPM	D0-D7/A0-A6		; restore registers
     394    403                          	
     395    404 00004FA2 61A8            		BSR	INTRPT			; interrupt engineEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		B O O T S T R A P             15-Apr-88  Page   11
Err Source Ref. Address   value
    line   line

     396    405 00004FA4 46FC 2000       		MOVE	#$2000,SR		; Enable Interrupts
     397    406 00004FA8 6056            		BRA	INITIAL			; go initialize
     398    407                          	
     399    408                          		ORG	$5000
     400    409                          	
     401    410                          	
     402    411                          	*		I N I T I A L I Z A T I O N
     403    412                          	
     404    413 00005000 4FF8 1000       	INITIAL	LEA	STKTOP,SP		; Set up the stack pointer
     405    414                          	
     406    415                          	*	Zero out some memory
     407    416 00005004 41F8 1042       		LEA	ZERO,A0
     408    417 00005008 303C 28BC       		MOVE.W	#ENDZERO-ZERO,D0
     409    418 0000500C 4258            	INIT0	CLR.W	(A0)+
     410    419 0000500E 5540            		SUB.W	#2,D0
     411    420 00005010 66FA            		BNE	INIT0
     412    421                          	
     413    422                          	
     414    423                          	*	Get parameters from ISIS
     415    424 00005012 2078 101A       		MOVE.L	SLTOME,A0		; pointer to slot parameters
     416    425 00005016 2018            		MOVE.L	(A0)+,D0
     417    426 00005018 0080 00E0 0000  		OR.L	#$00E00000,D0
     418    427 0000501E 21C0 1026       		MOVE.L	D0,ORING
     419    428 00005022 31D8 1038       		MOVE.W	(A0)+,ORSIZE
     420    429 00005026 2018            		MOVE.L	(A0)+,D0
     421    430 00005028 0080 00E0 0000  		OR.L	#$00E00000,D0
     422    431 0000502E 21C0 102A       		MOVE.L	D0,IRING
     423    432 00005032 31D8 1036       		MOVE.W	(A0)+,IRSIZE
     424    433 00005036 2018            		MOVE.L	(A0)+,D0
     425    434 00005038 0080 00E0 0000  		OR.L	#$00E00000,D0
     426    435 0000503E 21C0 1032       		MOVE.L	D0,.FASTC
     427    436 00005042 2240            		MOVE.L	D0,A1
     428    437 00005044 21D1 10DC       		MOVE.L	(A1),LFASTC		; initialize LFASTC to now
     429    438 00005048 2018            		MOVE.L	(A0)+,D0
     430    439 0000504A 0080 00E0 0000  		OR.L	#$00E00000,D0
     431    440 00005050 21C0 102E       		MOVE.L	D0,.SLOWC
     432    441 00005054 2018            		MOVE.L	(A0)+,D0
     433    442 00005056 0080 00E0 0000  		OR.L	#$00E00000,D0
     434    443 0000505C 21C0 1022       		MOVE.L	D0,.SYNC		; used for Sync with Slot code
     435    444 00005060 2018            		MOVE.L	(A0)+,D0
     436    445 00005062 0080 00E0 0000  		OR.L	#$00E00000,D0
     437    446 00005068 21C0 101E       		MOVE.L	D0,METOSL		; prefered place to dump registers
     438    447 0000506C 30FC 0200       		MOVE.W	#VERSION,(A0)+		; return Version number
     439    448 00005070 2A78 102A       		MOVE.L	IRING,Rs		; Input Ring address into Rs
     440    449 00005074 2C78 1026       		MOVE.L	ORING,Rd		; Output Ring address into Rd
     441    450                          	
     442    451                          	*	Initialize Bufferlet Storage
     443    452 00005078 41F9 0000 8000  		LEA	BUFER,A0		; pointer to start of area
     444    453 0000507E 21C8 10E8       		MOVE.L	A0,.BFLTS		; Record pointer to start of area
     445    454 00005082 4240            		CLR.W	D0			; record cursors here
     446    455 00005084 0640 0010       	INIT1	ADD.W	#BFLSIZ,D0		; advance cursorEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		B O O T S T R A P             15-Apr-88  Page   12
Err Source Ref. Address   value
    line   line

     447    456 00005088 41E8 0010       		LEA	BFLSIZ(A0),A0		; pointer to next buferlet
     448    457 0000508C 3140 FFF0       		MOVE.W	D0,-BFLSIZ(A0)		; set last forward-chain pointer
     449    458 00005090 5278 10EC       		ADD.W	#1,NBFLTS		; keep count of number of bufferlets
     450    459 00005094 B1FC 0000 F000  		CMPA.L	#BUFEREND,A0		; done yet?
     451    460 0000509A 6DE8            		BLT	INIT1			; no...continue
     452    461 0000509C 4250            		CLR.W	(A0)			; last one signaled by 0
     453    462                          	
     454    463 0000509E 11FC 0003 1046  		MOVE.B	#3,HSTAT		; Set Host status = Gone
     455    464 000050A4 11FC 0001 1081  		MOVE.B	#1,HTDWN		; set Host Down
     456    465 000050AA 31FC FFFF 1056  		MOVE.W	#-1,AUXX		; Enable AUX circuit requests
     457    466 000050B0 50F8 1004       		ST	CODCASH			; Initialize Crash-Code to FF
     458    467 000050B4 31FC 00C8 10E2  		MOVE.W	#200,BKPR		; value to apply back-pressure
     459    468                          	 IF	TRACING
     460    469 000050BA 21FC 0002 0000  		MOVE.L	#STRACE,.TRACE		; PDP-10 Trace Start Address
                         1000
     461    470                          	 ENDC
     462    471                          	
     463    472 000050C2 41F8 10FE       		LEA	FREEBLK,A0
     464    473 000050C6 31C8 10F0       		MOVE.W	A0,BLKFREE		; initialize Block-IO free-list
     465    474 000050CA 323C 0200       		MOVE.W	#MAXPORT*2,D1		; one list for input and output
     466    475 000050CE 5848            	BLKMAP	ADD.W	#4,A0			; point to next
     467    476 000050D0 3148 FFFC       		MOVE.W	A0,-4(A0)		; point last at this
     468    477 000050D4 5341            		SUB.W	#1,D1
     469    478 000050D6 6EF6            		BGT	BLKMAP
     470    479 000050D8 4268 FFFC       		CLR.W	-4(A0)			; last has null next
     471    480                          	
     472    481 000050DC 303C 0100       		MOVE.W	#MAXPORT,D0
     473    482 000050E0 49F8 18FE       		LEA	PORTS,Rp		; initialize port descriptors
     474    483 000050E4 4241            		CLR.W	D1			; we'll be counting port number here
     475    484 000050E6 197C 009D 0002  	PUTPORT	MOVE.B	#157,XMITLMT(Rp)	; transmit-limit
     476    485 000050EC 1941 0000       		MOVE.B	D1,P_NUM(Rp)		; set port number
     477    486 000050F0 5241            		ADD.W	#1,D1			; advance port number
     478    487 000050F2 D8FC 0020       		ADDA.W	#PD_SIZ,Rp		; advance to next port
     479    488 000050F6 5340            		SUB.W	#1,D0
     480    489 000050F8 66EC            		BNE	PUTPORT
     481    490                          	
     482    491 000050FA 4A79 00D0 1038  		TST.W	DEXCO			; Reset EBUS
     483    492 00005100 6100 07A6       		BSR.L	DOKEY			; see if host is already up
     484    493 00005104 6600 08F8       		BNE.L	EXEC			; no
     485    494 00005108 06B8 0000 012C  		ADD.L	#300,LFASTC		; yes...do next host check in 1/2 second
                         10DC
     486    495 00005110 31FC 006B 1040  		MOVE.W	#$6B,P10ADR		; from o153
     487    496 00005116 6100 0300       		BSR.L	GETPDPL
     488    497 0000511A 31C1 108A       		MOVE.W	D1,PDPIRP		; Input-ring Start-address
     489    498 0000511E 31FC 006C 1040  		MOVE.W	#$6C,P10ADR		; from o154
     490    499 00005124 6100 02F2       		BSR.L	GETPDPL
     491    500 00005128 31C1 108C       		MOVE.W	D1,PDPISZ		; Input-ring size
     492    501 0000512C 6100 0376       		BSR.L	GETIEC			; where PDP thinks his cursor is
     493    502 00005130 31C1 1090       		MOVE.W	D1,PDPIFC		; ...we'll start there too
     494    503 00005134 11FC 0003 109C  		MOVE.B	#3,DAT1			; set "RESET INTERFACE"
     495    504 0000513A 11FC 0000 109D  		MOVE.B	#DEBUG,DAT2EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		B O O T S T R A P             15-Apr-88  Page   13
Err Source Ref. Address   value
    line   line

     496    505 00005140 31FC 0200 109E  		MOVE.W	#VERSION,DAT3
     497    506 00005146 6100 04A4       		BSR.L	WAITDAT			; and send it
     498    507 0000514A 6100 04A0       		BSR.L	WAITDAT			; twice...just in case
     499    508 0000514E 6100 04D6       		BSR.L	PUTIFC			; let PDP know it's there
     500    509 00005152 6000 08AA       		BRA.L	EXEC			; then go begin



     502    511                          		TTL	'E B U S  --  PDP-10 Base Code,		C R A S H E S'EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		C R A S H E S                 15-Apr-88  Page   14
Err Source Ref. Address   value
    line   line

     504    513                          	*	CRASH Routines for the Base
     505    514                          	*	Dump CODCASH, PCCASH, and all registers to slot's REGDMP area
     506    515                          	*	...if we know where it is.  NO REGISTERS AFFLICTED
     507    516 00005156 4AB8 101E       	REGDMP	TST.L	METOSL			; do we have a place to dump to?
     508    517 0000515A 6730            		BEQ	REGDMPX			; no...just exit
     509    518 0000515C                 		PUSH	A0			; yes...save A0
     510    520 0000515E 2078 101E       		MOVE.L	METOSL,A0		; address to dump to
     511    521 00005162 20F8 1004       		MOVE.L	CODCASH,(A0)+		; dump crash reason
     512    522 00005166 20F8 1008       		MOVE.L	PCCASH,(A0)+		; PC saved
     513    523 0000516A 20C0            		MOVE.L	D0,(A0)+		; successive D-registers
     514    524 0000516C 20C1            		MOVE.L	D1,(A0)+
     515    525 0000516E 20C2            		MOVE.L	D2,(A0)+
     516    526 00005170 20C3            		MOVE.L	D3,(A0)+
     517    527 00005172 20C4            		MOVE.L	D4,(A0)+
     518    528 00005174 20C5            		MOVE.L	D5,(A0)+
     519    529 00005176 20C6            		MOVE.L	D6,(A0)+
     520    530 00005178 20C7            		MOVE.L	D7,(A0)+
     521    531 0000517A 20D7            		MOVE.L	(SP),(A0)+		; Saved value of A0
     522    532 0000517C 20C9            		MOVE.L	A1,(A0)+		; successive A-registers
     523    533 0000517E 20CA            		MOVE.L	A2,(A0)+
     524    534 00005180 20CB            		MOVE.L	A3,(A0)+
     525    535 00005182 20CB            		MOVE.L	A3,(A0)+
     526    536 00005184 20CD            		MOVE.L	A5,(A0)+
     527    537 00005186 20CE            		MOVE.L	A6,(A0)+
     528    538 00005188 20CF            		MOVE.L	SP,(A0)+
     529    539 0000518A                 		POP	A0			; restore A0
     530    541 0000518C 4E75            	REGDMPX	RTS				; exit
     531    542                          	
     532    543                          	
     533    544                          	*	CRASH ROUTINE
     534    545                          	*	Calling Sequence:	BSR	BCRASH
     535    546                          	*	FATAL CRASH:	NO RETURN!!!!!!
     536    547 0000518E 21DF 1008       	BCRASH	MOVE.L	(SP)+,PCCASH		; Location that called this routine
     537    548 00005192 4280            		CLR.L	D0
     538    549 00005194 3038 1004       		MOVE.W	CODCASH,D0		; left byte is crash-reason
     539    550 00005198 103C 0003       		MOVE.B	#3,D0			; 3 in right byte means Base crashes
     540    551 0000519C 2078 1016       		MOVE.L	METOIS,A0		; ADR OF BASE-TO-ENGINE MSG AREA
     541    552 000051A0 2080            		MOVE.L	D0,(A0)			; MOVE IT TO BASE-TO-ENGINE MSG AREA
     542    553 000051A2 61B2            		BSR	REGDMP
     543    554 000051A4 6100 FDA6       		BSR	INTRPT			; interrupt engine
     544    555 000051A8 4E72 2000       		STOP	#$2000			; and HALT! (with Interrupts Enabled)
     545    556                          	
     546    557                          	*	ISIS MSG-type FATAL CRASH!!
     547    558 000051AC 31F8 1096 100C  	ISMGER	MOVE.W	PORTNO,CASHW		; save port, message-type
     548    559 000051B2 11F8 1095 100E  		MOVE.B	INTYBT+1,CASHW+2
     549    560 000051B8                 		FCRASH	$50			; Fatal crash, no return!
     550    563                          	
     551    564                          	*	BUFFER Fatal Crash..."split" (non-existant) escaped character
     552    565 000051C0                 	BAD_ESC	FCRASH	$ED			; crash if escape not followed
     553    568                          	EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		C R A S H E S                 15-Apr-88  Page   15
Err Source Ref. Address   value
    line   line

     554    569                          	*	BUFFER Fatal Crash...GCI
     555    570 000051C8                 	DGCIH	FCRASH	18			; GCI crash
     556    573                          	
     557    574                          	*	BUFFER Fatal Crash...WCI
     558    575 000051D0                 	DWCIH	FCRASH	20			; WCI crash



     560    579                          	 IF	TRACING
     561    580                          		TTL	'E B U S -- PDP-10 Base Code,		T R A C E'EBUS02.J00/X               E B U S -- PDP-10 Base Code,		T R A C E                       15-Apr-88  Page   16
Err Source Ref. Address   value
    line   line

     563    582                          	*	Tracing is individually enabled for ISIS and PDP rings, and for
     564    583                          	*	BIO and Buffering.
     565    584                          	
     566    585                          	*	An attempt is made to present a uniform trace mechanism, to permit
     567    586                          	*	the simultaneous tracing of any or all of the above.  Thus it is
     568    587                          	*	important to define the standard used:
     569    588                          	
     570    589                          	*	The trace consists of successive (time-ordered) trace-descriptors
     571    590                          	*	in a Trace-ring.  This ring starts at STRACE, folds at ETRACE, and
     572    591                          	*	the (next) descriptor address may be found in .TRACE.
     573    592                          	
     574    593                          	*	A trace-descriptor is 8 bytes long, and has the common form:
     575    594                          	
     576    595                          	*	| TR | dd | p# | ?? | V | A | L | U |
     577    596                          	
     578    597                          	*	TR|dd is a pair of characters which specify the operation (TR)
     579    598                          	*	being traced and the "direction" (dd);  p# is (usually) the current
     580    599                          	*	port;  ?? is additional information specific to the TR, and V|A|L|U
     581    600                          	*	is the (long) value being transfered.
     582    601                          	
     583    602                          	*	Possible forms are:
     584    603                          	*     TR|dd	Usage			Notes
     585    604                          	*	>R	PDP-ring input		?? is current fill-cursor
     586    605                          	*	<R	PDP-ring output		?? is current empty-cursor
     587    606                          	*	>B	Block-input		?? is current-address low byte
     588    607                          	*	@B	Block-input fetch	?? is current-address low byte
     589    608                          	*	<B	Block-output		?? is current-address low byte
     590    609                          	*	>C	DWCI
     591    610                          	*	<C	DGCI
     592    611                          	*	#C	DEMPTY
     593    612                          	*	lI	LOOK			word 3 = port, word 4 is type (right)
     594    613                          	*	<I	ISIS input		?? is number of bytes
     595    614                          	*	sI	SLOR			word 3 = port, word 4 is type (right)
     596    615                          	*	>I	ISIS output		?? is number of bytes
     597    616                          	*	Xi	FLUSH			?? is number of bytes
     598    617                          	
     599    618                          	
     600    619                          	*	This is the heart of the Trace-code
     601    620                          	*	It assumes one long has been filled already.
     602    621 000051D8 20C1            	TRACE0	MOVE.L	D1,(A0)+		; second long = (D1)
     603    622                          	
     604    623                          	*	(Almost) everything filled...should we abort?
     605    624 000051DA 3038 1010       	TRACE1	MOVE.W	TR_PORT,D0		; should we trace this port only?
     606    625 000051DE 6D06            		BLT	TRACE2			; no
     607    626 000051E0 B02C 0000       		CMP.B	P_NUM(Rp),D0		; perhaps...is this the one?
     608    627 000051E4 6618            		BNE	TRACE4			; no...just abort
     609    628 000051E6 116C 0000 FFFA  	TRACE2	MOVE.B	P_NUM(Rp),-6(A0)	; third byte = port #
     610    629 000051EC B1FC 0003 FFE0  		CMPA.L	#ETRACE,A0
     611    630 000051F2 6D06            		BLT	TRACE3
     612    631 000051F4 41F9 0002 0000  		LEA	STRACE,A0EBUS02.J00/X               E B U S -- PDP-10 Base Code,		T R A C E                       15-Apr-88  Page   17
Err Source Ref. Address   value
    line   line

     613    632 000051FA 21C8 1000       	TRACE3	MOVE.L	A0,.TRACE
     614    633 000051FE                 	TRACE4	POPM	D0/A0
     615    635 00005202 4E75            		RTS
     616    636                          	
     617    637                          	  IF	ITRACE
     689    638                          	  ENDC
     690    639                          	
     691    640                          	  IF	CTRACE
     717    641                          	  ENDC
     718    642                          	
     719    643                          	  IF	BTRACE
     740    644                          	  ENDC
     741    645                          	
     742    646                          	  IF	RTRACE
     743    647                          	*	TRACE PDP-10 Transfers
     744    648                          	
     745    649 00005204                 	TR_RIN	PUSHM	D0/A0
     746    651 00005208 2078 1000       		MOVE.L	.TRACE,A0
     747    652 0000520C 30FC 3C52       		MOVE.W	#'<R',(A0)+		; first word = ring-trace flag
     748    653 00005210 30F8 1088       		MOVE.W	PDPOEC,(A0)+		; fourth byte = PDP's OEC
     749    654 00005214 60C2            		BRA	TRACE0
     750    655                          	
     751    656 00005216                 	TR_ROUT	PUSHM	D0/A0
     752    658 0000521A 2078 1000       		MOVE.L	.TRACE,A0
     753    659 0000521E 30FC 3E52       		MOVE.W	#'>R',(A0)+		; first word = ring-trace flag
     754    660 00005222 30F8 1090       		MOVE.W	PDPIFC,(A0)+		; fourth byte = PDP's OEC
     755    661 00005226 60B0            		BRA	TRACE0
     756    662                          	
     757    663                          	  ENDC
     758    664                          	
     759    665                          	 ENDC



     761    667                          		TTL	'E B U S  --  PDP-10 Base Code,		I S I S   R I N G S'EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		I S I S   R I N G S           15-Apr-88  Page   18
Err Source Ref. Address   value
    line   line

     763    669                          	
     764    670                          	*		I S I S   R I N G   R O U T I N E S
     765    671                          	
     766    672                          	
     767    673                          	*	Conventions:
     768    674                          	*	Routines use dedicated registers
     769    675                          	*	A6	Output Ring Base Address
     770    676                          	*	Rs	Input Ring Base Address
     771    677                          	*	NOTE ....
     772    678                          	*	   IRSIZE & ORSIZE MUST BE LESS THAN 32K
     773    679                          	
     774    680                          	
     775    681                          	*		RING OUTPUT ROUTINES
     776    682                          	
     777    683                          	*	Insure that there is room in ring
     778    684                          	*	Expects	D0 = # characters of space required
     779    685                          	*	Returns	Z FLAG = 0 means OK, 1 is no room
     780    686                          	*	Smashes D1
     781    687 00005228 322E 0002       	ROOM	MOVE.W	2(Rd),D1		; CEI
     782    688 0000522C 9256            		SUB.W	(Rd),D1			;  - NFMI
     783    689 0000522E 6E06            		BGT	RNOWRAP			; >0 = no wrap
     784    690 00005230 670C            		BEQ	ROOMG			; =0 = empty
     785    691 00005232 D278 1038       		ADD.W	ORSIZE,D1		; <0 = ring-wrap, compute bias
     786    692 00005236 5941            	RNOWRAP	SUB.W	#4,D1			; can't fill ring completely
     787    693 00005238 B240            		CMP.W	D0,D1			; is required space available?
     788    694 0000523A 6D04            		BLT	ROOMB			; no
     789    695 0000523C 9201            		SUB.B	D1,D1			; yes..set Z=0
     790    696 0000523E 4E75            	ROOMG	RTS
     791    697                          	
     792    698 00005240 123C 00FF       	ROOMB	MOVE.B	#-1,D1			; no room...set Z=1
     793    699 00005244 4E75            		RTS
     794    700                          	
     795    701                          	*	Wait until there's a word available in ISIS output ring
     796    702                          	*	All registers preserved
     797    703 00005246                 	WAITISW	PUSHM	D0/D1
     798    705 0000524A 7004            		MOVEQ	#4,D0
     799    706 0000524C 6008            		BRA	WAIT
     800    707                          	
     801    708                          	*	Wait until there's D0 bytes available in ISIS output ring
     802    709                          	*	All registers preserved
     803    710 0000524E                 	WAITIS	PUSHM	D0/D1
     804    712 00005252 0240 00FF       		AND.W	#$00FF,D0
     805    713 00005256 61D0            	WAIT	BSR	ROOM
     806    714 00005258 66FC            		BNE	WAIT
     807    715 0000525A                 		POPM	D0/D1
     808    717 0000525E 4E75            		RTS
     809    718                          	
     810    719                          	
     811    720                          	
     812    721                          	*	START LOGICAL OUTPUT RECORDEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		I S I S   R I N G S           15-Apr-88  Page   19
Err Source Ref. Address   value
    line   line

     813    722                          	*	Provides function of ROOM, PUTH & PUTCH
     814    723                          	*	for first 3 characters of message
     815    724                          	*	D3 = PORT # (B)
     816    725                          	*	D4 = Message type code (B)
     817    726 00005260                 	SLOR	PUSHM	D0/D4			; save registers
     818    728 00005264 3C16            		MOVE.W	(Rd),Cd			; set up cursor from NFMI
     819    729                          	 IF	ITRACE
     821    730                          	 ENDC
     822    731 00005266 4240            		CLR.W	D0
     823    732 00005268 1003            		MOVE.B	D3,D0
     824    733 0000526A 3D80 6004       		MOVE.W	D0,4(Rd,Cd.W)
     825    734 0000526E E14C            		LSL.W	#8,D4
     826    735 00005270 3D84 6006       		MOVE.W	D4,6(Rd,Cd.W)
     827    736 00005274 5646            		ADD.W	#3,Cd			; advance cursor
     828    737 00005276                 		POPM	D0/D4
     829    739 0000527A 4E75            		RTS
     830    740                          	
     831    741                          	
     832    742                          	*	Put a character into the ring
     833    743                          	*	D0 = CHARACTER
     834    744 0000527C                 	PUTCH	PUSHM	D0/D2			; save registers
     835    746                          	 IF	ITRACE
     837    747                          	 ENDC
     838    748 00005280 0806 0000       		BTST	#0,Cd			; check even/odd boundary
     839    749 00005284 670C            		BEQ	PUEVEN
     840    750 00005286 3436 6003       		MOVE.W	3(Rd,Cd.W),D2		; get HW to fill
     841    751 0000528A 1400            		MOVE.B	D0,D2			; pack in new byte
     842    752 0000528C 3D82 6003       		MOVE.W	D2,3(Rd,Cd.W)
     843    753 00005290 6006            		BRA	PUTODD
     844    754                          	
     845    755 00005292 E148            	PUEVEN	LSL.W	#8,D0
     846    756 00005294 3D80 6004       		MOVE.W	D0,4(Rd,Cd.W)
     847    757 00005298 5246            	PUTODD	ADD.W	#1,Cd
     848    758 0000529A BC78 1038       		CMP.W	ORSIZE,Cd		; check for folding
     849    759 0000529E 6D02            		BLT	PUTC1
     850    760 000052A0 4246            		CLR.W	Cd
     851    761 000052A2                 	PUTC1	POPM	D0/D2
     852    763 000052A6 4E75            		RTS
     853    764                          	
     854    765                          	
     855    766                          	
     856    767                          	*	Put a (short) half-word into the ring
     857    768                          	*	D0 = HALF WORD
     858    769 000052A8 3D80 6004       	PUTH	MOVE.W	D0,4(Rd,Cd.W)
     859    770                          	 IF	ITRACE
     861    771                          	 ENDC
     862    772 000052AC 5446            		ADD.W	#2,Cd
     863    773 000052AE BC78 1038       		CMP.W	ORSIZE,Cd		; check for folding
     864    774 000052B2 6D02            		BLT	PUTH11
     865    775 000052B4 4246            		CLR.W	Cd
     866    776 000052B6 4E75            	PUTH11	RTSEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		I S I S   R I N G S           15-Apr-88  Page   20
Err Source Ref. Address   value
    line   line

     867    777                          	
     868    778                          	
     869    779                          	
     870    780                          	*	Put a (long) word into the ring
     871    781                          	*	D0 = WORD
     872    782 000052B8 2D80 6004       	PUTW	MOVE.L	D0,4(Rd,Cd.W)
     873    783                          	 IF	ITRACE
     875    784                          	 ENDC
     876    785 000052BC 5846            		ADD.W	#4,Cd
     877    786 000052BE BC78 1038       		CMP.W	ORSIZE,Cd		; check for folding
     878    787 000052C2 6D02            		BLT	PUTW11
     879    788 000052C4 4246            		CLR.W	Cd
     880    789 000052C6 4E75            	PUTW11	RTS
     881    790                          	
     882    791                          	
     883    792                          	*	END LOGICAL OUTPUT RECORD
     884    793 000052C8 5646            	ELOR	ADD.W	#3,Cd
     885    794 000052CA 0246 FFFC       		AND.W	#-4,Cd
     886    795 000052CE BC78 1038       		CMP.W	ORSIZE,Cd		; check for ring-fold
     887    796 000052D2 6D02            		BLT	ELOR21
     888    797 000052D4 4246            		CLR.W	Cd
     889    798 000052D6 3C86            	ELOR21	MOVE.W	Cd,(Rd)			; advance NFMI, message now in ring
     890    799 000052D8 4E75            		RTS
     891    800                          	
     892    801                          	*	Send a quick message to ISIS
     893    802                          	*	Expects:	D3 = port #
     894    803                          	*			D4 = Type-byte
     895    804                          	*	Returns:	3-byte message in ring
     896    805 000052DA 6100 FF6A       	SENDQI	BSR	WAITISW			; wait for ring-space
     897    806 000052DE 6180            		BSR	SLOR			; start-logical-output-record
     898    807 000052E0 60E6            		BRA	ELOR			; exit via ELOREBUS02.J00/X               E B U S  --  PDP-10 Base Code,		I S I S   R I N G S           15-Apr-88  Page   21
Err Source Ref. Address   value
    line   line

     900    809                          	*		INPUT ROUTINES
     901    810                          	
     902    811                          	*	LOOK at an input ring entry
     903    812                          	*	Returns:
     904    813                          	*	If ring is empty, then Z FLAG = 0
     905    814                          	*	Else Z .NE. 0, PORT returned in D3
     906    815                          	*	Message Type returned in D4
     907    816                          	*	All registers set up for transfer
     908    817                          	*	Cursor is advanced past PORT #
     909    818                          	
     910    819                          	
     911    820                          	
     912    821 000052E2 3E2D 0002       	LOOK	MOVE.W	2(Rs),Cs		; get Ring's CEI
     913    822 000052E6 BE55            		CMP.W	(Rs),Cs			; check if empty
     914    823 000052E8 6716            		BEQ	NOIRING			; yes..exit Z=0
     915    824 000052EA 3635 7004       		MOVE.W	4(Rs,Cs.W),D3		; PORT #
     916    825 000052EE 3835 7006       		MOVE.W	6(Rs,Cs.W),D4		; MSG TYPE BYTE
     917    826 000052F2 5678 10E4       		ADD.W	#3,IRRN
     918    827 000052F6 E04C            		LSR.W	#8,D4			; justify the type byte
     919    828 000052F8 3003            		MOVE.W	D3,D0
     920    829 000052FA 6100 0580       		BSR.L	SETPORT			; set up port
     921    830                          	 IF	ITRACE
     923    831                          	 ENDC
     924    832 000052FE 5647            		ADD.W	#3,Cs			; (sets Z .NE. 0)
     925    833 00005300 4E75            	NOIRING	RTS				; return Z-Flag indication
     926    834                          	
     927    835                          	
     928    836                          	*	Get a character from the Input Ring
     929    837                          	*	Character returned in D0
     930    838 00005302 5278 10E4       	GETCH	ADD.W	#1,IRRN			; count it
     931    839 00005306 0807 0000       		BTST	#0,Cs			; getting even or odd byte?
     932    840 0000530A 6706            		BEQ	EVENBON			; skip if even
     933    841 0000530C 3035 7003       		MOVE.W	3(Rs,Cs.W),D0		; get from odd boundary
     934    842 00005310 6006            		BRA	ODDBON
     935    843                          	
     936    844 00005312 3035 7004       	EVENBON	MOVE.W	4(Rs,Cs.W),D0		; get from even boundary
     937    845 00005316 E048            		LSR.W	#8,D0			; ...and justify the character
     938    846 00005318 0240 00FF       	ODDBON	AND.W	#$00FF,D0		; pad out to word
     939    847                          	 IF	ITRACE
     941    848                          	 ENDC
     942    849 0000531C 5247            		ADD.W	#1,Cs			; advance and fold cursor
     943    850 0000531E BE78 1036       		CMP.W	IRSIZE,Cs
     944    851 00005322 6D02            		BLT	GETCH1
     945    852 00005324 4247            		CLR.W	Cs
     946    853 00005326 4E75            	GETCH1	RTS				; and exit
     947    854                          	
     948    855                          	*	Get a half-word from the Input-Ring
     949    856                          	*	Assumed we're on correct (HW) Boundary
     950    857                          	*	Half-word returned in D0
     951    858                          	EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		I S I S   R I N G S           15-Apr-88  Page   22
Err Source Ref. Address   value
    line   line

     952    859 00005328 3035 7004       	GETH	MOVE.W	4(Rs,Cs.W),D0		; get the value
     953    860                          	 IF	ITRACE
     955    861                          	 ENDC
     956    862 0000532C 5478 10E4       		ADD.W	#2,IRRN
     957    863 00005330 5447            		ADD.W	#2,Cs			; advance and fold cursor
     958    864 00005332 BE78 1036       		CMP.W	IRSIZE,Cs
     959    865 00005336 6D02            		BLT	GETH1
     960    866 00005338 4247            		CLR.W	Cs
     961    867 0000533A 4E75            	GETH1	RTS				; ...and exit
     962    868                          	
     963    869                          	*	Get a (long) Word from the Input-ring
     964    870                          	*	Assumed we're at appropriate boundary
     965    871                          	*	Value returned in D0
     966    872                          	
     967    873 0000533C 2035 7004       	GETW	MOVE.L	4(Rs,Cs.W),D0
     968    874                          	 IF	ITRACE
     970    875                          	 ENDC
     971    876 00005340 5878 10E4       		ADD.W	#4,IRRN
     972    877 00005344 5847            		ADD.W	#4,Cs			; advance and fold cursor
     973    878 00005346 BE78 1036       		CMP.W	IRSIZE,Cs
     974    879 0000534A 6D02            		BLT	GETW1
     975    880 0000534C 4247            		CLR.W	Cs
     976    881 0000534E 4E75            	GETW1	RTS				; ...and exit
     977    882                          	
     978    883                          	*	Flush an input record
     979    884                          	*	Expects number of Chars to flush in D0
     980    885 00005350 0240 00FF       	FLUSH	AND.W	#$00FF,D0		; expand number
     981    886 00005354 DE40            		ADD.W	D0,Cs
     982    887                          	 IF	ITRACE
     984    888                          	 ENDC
     985    889                          	
     986    890                          	*	END LOGICAL INPUT RECORD
     987    891 00005356 5647            	ELIR	ADD.W	#3,Cs			; round cursor up to next (long) word
     988    892 00005358 0247 FFFC       		AND.W	#-4,Cs
     989    893 0000535C BE78 1036       		CMP.W	IRSIZE,Cs		; check for folding required
     990    894 00005360 6D04            		BLT	ELIR2			; no
     991    895 00005362 9E78 1036       		SUB.W	IRSIZE,Cs
     992    896 00005366 3B47 0002       	ELIR2	MOVE.W	Cs,2(Rs)		; now set new CEI back into Ring
     993    897 0000536A 4E75            		RTS				; and exit



     995    899                          		TTL	'E B U S  --  PDP-10 Base Code,		P D P   I / O'EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		P D P   I / O                 15-Apr-88  Page   23
Err Source Ref. Address   value
    line   line

     997    901                          	*		P D P - 1 0   I / O   R o u t i n e s
     998    902                          	
     999    903                          	***	ROUTINES TO READ FROM PDP-10
    1000    904                          	
    1001    905                          	
    1002    906                          	
    1003    907                          	*	Routine to Read a "Word" from PDP-10
    1004    908                          	*	Smashes registers:	D0-D3
    1005    909 0000536C 11FC 0010 10FA  	RD10R	MOVE.B	#16,TMOC		; initialize counters
    1006    910                          	
    1007    911 00005372 7246            	RD10AG	MOVEQ	#70,D1			; counter for BUSY try
    1008    912 00005374 3039 00D0 00B8  	RD10R1	MOVE.W	DSENS,D0		; Sense Busy
    1009    913 0000537A 0800 0000       		BTST	#0,D0			; is Sense BUSY?
    1010    914 0000537E 665C            		BNE	RDSNB			; yes...go to BUSY code
    1011    915 00005380 4242            		CLR.W	D2
    1012    916 00005382 4A38 10D2       		TST.B	BLK
    1013    917 00005386 6704            		BEQ	BLKK2
    1014    918 00005388 1438 103E       		MOVE.B	P10DLL,D2
    1015    919 0000538C 33C2 00D0 803E  	BLKK2	MOVE.W	D2,WT103		; place low address
    1016    920 00005392 3438 1040       		MOVE.W	P10ADR,D2
    1017    921 00005396 0242 7FFF       		AND.W	#$7FFF,D2		; high-bit = 0 specifies READ operation
    1018    922 0000539A 33C2 00D0 8038  		MOVE.W	D2,WT104		; send Low address
    1019    923 000053A0 7646            		MOVEQ	#70,D3			; counter for Busy loop
    1020    924 000053A2 3039 00D0 00B8  	RD10R2	MOVE.W	DSENS,D0		; Sense Busy
    1021    925 000053A8 0800 0000       		BTST	#0,D0			; Is Sense BUSY?
    1022    926 000053AC 6648            		BNE	RDSNB1			; yes...go to BUSY code
    1023    927 000053AE 31F9 00D0 403A  		MOVE.W	RD101,P10DAH		; Read high 16-bits of data from PDP
                         103A
    1024    928 000053B6 31F9 00D0 403C  		MOVE.W	RD104,P10DAL		; Read "middle" 16-bits of data from PDP
                         103C
    1025    929 000053BE 3439 00D0 403E  		MOVE.W	RD102,D2		; Read low 4-bits of data from PDP
    1026    930 000053C4 0242 000F       		AND.W	#$000F,D2		; zero out high-order bits
    1027    931 000053C8 11C2 103E       		MOVE.B	D2,P10DLL		; and save low 4-bits of data
    1028    932 000053CC 3439 00D0 0138  		MOVE.W	DPER,D2			; Check if there is a parity error
    1029    933 000053D2 0802 0000       		BTST	#0,D2
    1030    934 000053D6 6600 042E       		BNE.L	PARERR			; yes..process parity error
    1031    935 000053DA 4E75            		RTS				; ...else return
    1032    936                          	
    1033    937 000053DC 5301            	RDSNB	SUB.B	#1,D1
    1034    938 000053DE 6694            		BNE	RD10R1			; another try if < 70 times
    1035    939 000053E0 6000 042C       		BRA.L	BUSCRAS
    1036    940                          	
    1037    941 000053E4 5338 10FA       	TMOUT	SUB.B	#1,TMOC
    1038    942 000053E8 6700 0414       		BEQ.L	TMOUT1
    1039    943 000053EC 4A79 00D0 1038  		TST.W	DEXCO			; Reset EBUS
    1040    944 000053F2 6000 FF7E       		BRA	RD10AG
    1041    945                          	
    1042    946 000053F6 3439 00D0 01B8  	RDSNB1	MOVE.W	DTMOT,D2		; test for time-out
    1043    947 000053FC 0802 0000       		BTST	#0,D2
    1044    948 00005400 66E2            		BNE	TMOUT			; yes...go process timeoutEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		P D P   I / O                 15-Apr-88  Page   24
Err Source Ref. Address   value
    line   line

    1045    949 00005402 3439 00D0 0138  		MOVE.W	DPER,D2			; check if Parity error
    1046    950 00005408 0802 0000       		BTST	#0,D2
    1047    951 0000540C 6600 03F8       		BNE.L	PARERR			; yes...go process parity error
    1048    952 00005410 5303            		SUB.B	#1,D3
    1049    953 00005412 668E            		BNE	RD10R2			; another try if < 70
    1050    954 00005414 6000 03F8       		BRA.L	BUSCRAS
    1051    955                          	
    1052    956                          	*	Read from PDP, get (left-most) high 32-bit message into D1
    1053    957 00005418                 	GETPDPL	PUSHM	D0/D2-D3
    1054    959 0000541C 6100 FF4E       		BSR	RD10R			; read from PDP
    1055    960 00005420 2238 103A       		MOVE.L	P10DAH,D1		;  ...into D1
    1056    961 00005424                 		POPM	D0/D2-D3
    1057    963 00005428 4E75            		RTS
    1058    964                          	
    1059    965                          	*	Read from PDP, get low-order 32-bits into D1
    1060    966 0000542A                 	GETPDPR	PUSHM	D0/D2-D3
    1061    968 0000542E 6100 FF3C       		BSR	RD10R			; read from PDP
    1062    969 00005432 2238 103A       		MOVE.L	P10DAH,D1
    1063    970 00005436 E989            		LSL.L	#4,D1			; left-justify 28-bits of data
    1064    971 00005438 1438 103E       		MOVE.B	P10DLL,D2		; low 4 bits
    1065    972 0000543C 0202 000F       		AND.B	#$0F,D2			; clear high order bits
    1066    973 00005440 8202            		OR.B	D2,D1			; merge with previous result
    1067    974 00005442                 		POPM	D0/D2-D3
    1068    976 00005446 4E75            		RTS
    1069    977                          	
    1070    978                          	*	Read Word indicated by PDPOEC & put left (high) 32 bits in D1
    1071    979                          	*	and in DAT.  Also advance and wrap PDPOEC
    1072    980 00005448                 	RDPDP	PUSHM	D0/D2
    1073    982 0000544C 5278 10E6       		ADD.W	#1,ORRN
    1074    983 00005450 31F8 1082 1040  		MOVE.W	PDPORP,P10ADR		; PDP output ring start address
    1075    984 00005456 3438 1088       		MOVE.W	PDPOEC,D2		; get output ring cursor
    1076    985 0000545A D578 1040       		ADD.W	D2,P10ADR		; address of current word in ring
    1077    986 0000545E 61B8            		BSR	GETPDPL			; get the word from ring
    1078    987 00005460 21C1 109C       		MOVE.L	D1,DAT
    1079    988                          	 IF	RTRACE
    1080    989 00005464 6100 FD9E       		BSR	TR_RIN			; record activity
    1081    990                          	 ENDC
    1082    991 00005468 5242            		ADD.W	#1,D2			; advance cursor
    1083    992 0000546A B478 1084       		CMP.W	PDPOSZ,D2		; check if to fold it
    1084    993 0000546E 6602            		BNE	RDPDP1
    1085    994 00005470 4242            		CLR.W	D2			; yes
    1086    995 00005472 31C2 1088       	RDPDP1	MOVE.W	D2,PDPOEC		; save new cursor
    1087    996 00005476                 		POPM	D0/D2
    1088    998 0000547A 4E75            		RTS
    1089    999                          	
    1090   1000                          	
    1091   1001                          	*	Read another word from a storage-block in the PDP-10 to DAT
    1092   1002                          	*	and increment pointer
    1093   1003                          	*	Returns:	DAT and D1 = full-word of data read
    1094   1004                          	*			No other Registers Disturbed
    1095   1005 0000547C                 	RDBLK	PUSHM	D0/D2-D3EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		P D P   I / O                 15-Apr-88  Page   25
Err Source Ref. Address   value
    line   line

    1096   1007 00005480 4280            		CLR.L	D0
    1097   1008 00005482 202C 0004       		MOVE.L	BO_TAR(Rp),D0
    1098   1009 00005486 6100 003C       		BSR.L	SETBLKA			; set up BLOCK-IO address
    1099   1010 0000548A 6100 FEE0       		BSR	RD10R
    1100   1011 0000548E 4238 10D2       		CLR.B	BLK
    1101   1012 00005492 2238 103A       		MOVE.L	P10DAH,D1
    1102   1013 00005496 21C1 109C       		MOVE.L	D1,DAT1
    1103   1014                          	 IF	BTRACE
    1105   1015                          	 ENDC
    1106   1016 0000549A 52AC 0004       		ADD.L	#1,BO_TAR(Rp)
    1107   1017 0000549E                 		POPM	D0/D2-D3
    1108   1019 000054A2 4E75            		RTS
    1109   1020                          	
    1110   1021                          	*	Read PDP input-ring Empty-Cursor
    1111   1022 000054A4 31FC 006D 1040  	GETIEC	MOVE.W	#$6D,P10ADR		; from o155
    1112   1023 000054AA 6100 FF7E       		BSR	GETPDPR
    1113   1024 000054AE 31C1 108E       		MOVE.W	D1,PDPIEC
    1114   1025 000054B2 4E75            		RTS
    1115   1026                          	
    1116   1027                          	*	Read PDP Output-ring Fill Cursor
    1117   1028 000054B4 31FC 0071 1040  	GETOFC	MOVE.W	#$71,P10ADR		; from o161
    1118   1029 000054BA 6100 FF6E       		BSR	GETPDPR
    1119   1030 000054BE 31C1 1086       		MOVE.W	D1,PDPOFC
    1120   1031 000054C2 4E75            		RTS






    1122   1033                          	*	Set up Block-IO address
    1123   1034                          	*	Expects:	D0 = address (may be more than 15 bits) (L)
    1124   1035                          	*	Returns:	P10ADR and P10DLL set up; BLK set
    1125   1036                          	*			D0 smashed; No other Registers Disturbed
    1126   1037 000054C4 31C0 1040       	SETBLKA	MOVE.W	D0,P10ADR		; low-order 15-bits
    1127   1038 000054C8 E398            		ROL.L	#1,D0			; now manipulate high-order bits
    1128   1039 000054CA 4840            		SWAP	D0
    1129   1040 000054CC E948            		LSL.W	#4,D0
    1130   1041 000054CE 11C0 103E       		MOVE.B	D0,P10DLL		; high-order 4-bits
    1131   1042 000054D2 11FC 00FF 10D2  		MOVE.B	#-1,BLK
    1132   1043 000054D8 4E75            		RTSEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		P D P   I / O                 15-Apr-88  Page   26
Err Source Ref. Address   value
    line   line

    1134   1045                          	*	Routines to write to PDP-10
    1135   1046                          	
    1136   1047                          	
    1137   1048                          	*	Routine to write to PDP-10
    1138   1049                          	*	Smashes Registers:	D0-D2
    1139   1050 000054DA 7246            	WR10R	MOVEQ	#70,D1			; counter for Busy try
    1140   1051                          	
    1141   1052                          	*	Come back here to retry operation
    1142   1053 000054DC 3039 00D0 00B8  	WR10R1	MOVE.W	DSENS,D0		; Busy Sense
    1143   1054 000054E2 0800 0000       		BTST	#0,D0			; Is Sense Busy?
    1144   1055 000054E6 663E            		BNE	WRSNB			; yes, go to Busy routine
    1145   1056 000054E8 4678 103A       		NOT.W	P10DAH			; MIC will invert bits
    1146   1057 000054EC 33F8 103A 00D0  		MOVE.W	P10DAH,WT101		; transmit 1st HW to write
                         803A
    1147   1058 000054F4 4678 103C       		NOT.W	P10DAL			; MIC will invert bits
    1148   1059 000054F8 33F8 103C 00D0  		MOVE.W	P10DAL,WT102		; transmit 2nd HW to write
                         803C
    1149   1060 00005500 1438 103E       		MOVE.B	P10DLL,D2		; transmit last 4 bits of data
    1150   1061 00005504 4A38 10D2       		TST.B	BLK
    1151   1062 00005508 6606            		BNE	BLKK1
    1152   1063 0000550A 4602            		NOT.B	D2			; MIC will invert bits
    1153   1064 0000550C 0242 000F       		AND.W	#$000F,D2		; clear high order bits
    1154   1065 00005510 33C2 00D0 803E  	BLKK1	MOVE.W	D2,WT103		; move data and address to register 3
    1155   1066 00005516 3438 1040       		MOVE.W	P10ADR,D2		; get address within PDP
    1156   1067 0000551A 0042 8000       		OR.W	#$8000,D2		; High-bit = 1 specifies WRITE
    1157   1068 0000551E 33C2 00D0 8038  		MOVE.W	D2,WT104		; to register 3
    1158   1069 00005524 4E75            		RTS
    1159   1070                          	
    1160   1071 00005526 5301            	WRSNB	SUB.B	#1,D1
    1161   1072 00005528 66B2            		BNE	WR10R1			; another try if < 70 times
    1162   1073 0000552A 6000 02E2       		BRA.L	BUSCRAS
    1163   1074                          	
    1164   1075                          	
    1165   1076                          	*	Write into PDP (high), insuring that low 4 bits are ON!
    1166   1077 0000552E                 	PUTNOT0	PUSHM	D0-D3
    1167   1079 00005532 21C1 103A       		MOVE.L	D1,P10DAH
    1168   1080 00005536 4238 103E       		CLR.B	P10DLL			; all 1's to last 4 bits
    1169   1081 0000553A 619E            		BSR	WR10R
    1170   1082 0000553C                 		POPM	D0-D3
    1171   1084 00005540 4E75            		RTS
    1172   1085                          	
    1173   1086                          	*	Crash the Host
    1174   1087 00005542 2238 1004       	HCRASH	MOVE.L	CODCASH,D1		; get reason
    1175   1088 00005546 E089            		LSR.L	#8,D1			; code into high 16 bits
    1176   1089 00005548 31FC 0068 1040  		MOVE.W	#$68,P10ADR		; put into KEY at o150
    1177   1090 0000554E 4A79 00D0 1038  		TST.W	DEXCO			; Reset EBUS
    1178   1091 00005554 61D8            		BSR	PUTNOT0
    1179   1092 00005556 31FC 0018 1040  		MOVE.W	#$18,P10ADR		; address o30
    1180   1093 0000555C 2238 1088       		MOVE.L	PDPOEC,D1		; return: Output Empty Cursor |
    1181   1094 00005560 3238 1090       		MOVE.W	PDPIFC,D1		;	  Input Fill CursorEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		P D P   I / O                 15-Apr-88  Page   27
Err Source Ref. Address   value
    line   line

    1182   1095 00005564 4A79 00D0 1038  		TST.W	DEXCO			; Reset EBUS
    1183   1096 0000556A 61C2            		BSR	PUTNOT0			; send it, insure word != 0
    1184   1097 0000556C 4A79 00D0 1038  		TST.W	DEXCO			; Reset EBUS
    1185   1098 00005572 4E75            		RTS				; then return
    1186   1099                          	
    1187   1100                          	
    1188   1101                          	*	Write D1 to high (left) 32 bits within PDP-10
    1189   1102 00005574                 	PUTPDPL	PUSHM	D0/D2-D3
    1190   1104 00005578 21C1 103A       		MOVE.L	D1,P10DAH		; deposit data
    1191   1105 0000557C 11FC 000F 103E  		MOVE.B	#$0F,P10DLL		; all 0's to last 4 bits
    1192   1106 00005582 6100 FF56       		BSR	WR10R
    1193   1107 00005586                 		POPM	D0/D2-D3
    1194   1109 0000558A 4E75            		RTS
    1195   1110                          	
    1196   1111                          	*	Write D1 to low (right) 32 bits within PDP-10
    1197   1112 0000558C                 	PUTPDPR	PUSHM	D0-D3
    1198   1114 00005590 11C1 103E       		MOVE.B	D1,P10DLL		; last 4 bits to P10DLL
    1199   1115 00005594 E889            		LSR.L	#4,D1			; right-justify value
    1200   1116 00005596 21C1 103A       		MOVE.L	D1,P10DAH
    1201   1117 0000559A 6100 FF3E       		BSR	WR10R			; call write routine
    1202   1118 0000559E                 		POPM	D0-D3
    1203   1120 000055A2 4E75            		RTS
    1204   1121                          	
    1205   1122                          	*	Write another word to a storage-block in the PDP-10
    1206   1123                          	*	and increment pointer
    1207   1124                          	*	Expects:	DAT = full-word of data to write
    1208   1125                          	*	Returns:	No Registers Disturbed
    1209   1126 000055A4                 	WRBLK	PUSHM	D0-D3
    1210   1128 000055A8 2238 109C       		MOVE.L	DAT,D1
    1211   1129 000055AC 21C1 103A       		MOVE.L	D1,P10DAH		; save value to write
    1212   1130                          	 IF	BTRACE
    1214   1131                          	 ENDC
    1215   1132 000055B0 4280            		CLR.L	D0			; compute PDP-address to write to
    1216   1133 000055B2 202C 0010       		MOVE.L	BI_TAR(Rp),D0
    1217   1134 000055B6 6100 FF0C       		BSR	SETBLKA			; set up the BLOCK-IO address
    1218   1135 000055BA 6100 FF1E       		BSR	WR10R
    1219   1136 000055BE 4238 10D2       		CLR.B	BLK			; clear BIO flag
    1220   1137 000055C2 52AC 0010       		ADD.L	#1,BI_TAR(Rp)
    1221   1138 000055C6                 		POPM	D0-D3
    1222   1140 000055CA 4E75            		RTS
    1223   1141                          	
    1224   1142                          	*	Get current output word from a storage-block in the PDP-10
    1225   1143                          	*	Returns:	Word into DAT;	No Registers Disturbed
    1226   1144 000055CC                 	GETBLK	PUSHM	D0-D3
    1227   1146 000055D0 4280            		CLR.L	D0			; compute PDP-address to read from
    1228   1147 000055D2 202C 0010       		MOVE.L	BI_TAR(Rp),D0
    1229   1148 000055D6 6100 FEEC       		BSR	SETBLKA			; set up the BLOCK-IO address
    1230   1149 000055DA 6100 FE3C       		BSR	GETPDPL			; get the word from the ring
    1231   1150 000055DE 4238 10D2       		CLR.B	BLK			; clear BIO flag
    1232   1151 000055E2 21C1 109C       		MOVE.L	D1,DAT			; save word read
    1233   1152                          	 IF	BTRACEEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		P D P   I / O                 15-Apr-88  Page   28
Err Source Ref. Address   value
    line   line

    1235   1153                          	 ENDC
    1236   1154 000055E6                 		POPM	D0-D3
    1237   1156 000055EA 4E75            		RTS
    1238   1157                          	
    1239   1158                          	
    1240   1159                          	*	Wait for space in PDP ring, then write DAT to it
    1241   1160 000055EC 615C            	WAITDAT	BSR	WAITPDP			; wait, then go on
    1242   1161                          	
    1243   1162                          	*	Write MSG (from DAT) to PDP ring & update base pointer
    1244   1163 000055EE 2238 109C       	WRDAT	MOVE.L	DAT,D1			; load it and fall into WRPDP
    1245   1164                          	
    1246   1165                          	*	Write MSG (in D1) to PDP ring & update base pointer
    1247   1166 000055F2                 	WRPDP	PUSHM	D1/D2
    1248   1168                          	 IF	RTRACE
    1249   1169 000055F6 6100 FC1E       		BSR	TR_ROUT			; record activity in trace
    1250   1170                          	 ENDC
    1251   1171 000055FA 31F8 108A 1040  		MOVE.W	PDPIRP,P10ADR		; Input ring Start Address
    1252   1172 00005600 3438 1090       		MOVE.W	PDPIFC,D2		; our fill cursor
    1253   1173 00005604 D578 1040       		ADD.W	D2,P10ADR		; address in ring
    1254   1174 00005608 6100 FF6A       		BSR	PUTPDPL
    1255   1175 0000560C 5242            		ADD.W	#1,D2			; advance cursor
    1256   1176 0000560E B478 108C       		CMP.W	PDPISZ,D2		; does new cursor = ring size?
    1257   1177 00005612 6608            		BNE	WRIRTS			; no
    1258   1178 00005614 6100 FE8E       	WRINRG	BSR	GETIEC			; yes...locate current PDP empty cursor
    1259   1179 00005618 67FA            		BEQ	WRINRG			; spin until it moves off 0
    1260   1180 0000561A 4242            		CLR.W	D2			; ...then wrap our cursor
    1261   1181 0000561C 31C2 1090       	WRIRTS	MOVE.W	D2,PDPIFC		; save new fill cursor
    1262   1182 00005620                 		POPM	D1/D2
    1263   1184 00005624 4E75            		RTS
    1264   1185                          	
    1265   1186                          	*	Write Input-ring Fill Cursor
    1266   1187 00005626 31FC 006E 1040  	PUTIFC	MOVE.W	#$6E,P10ADR		; at o156
    1267   1188 0000562C 4281            		CLR.L	D1
    1268   1189 0000562E 3238 1090       		MOVE.W	PDPIFC,D1
    1269   1190 00005632 6100 FF58       		BSR	PUTPDPR
    1270   1191 00005636 4E75            		RTS
    1271   1192                          	
    1272   1193                          	***	Write our Output-ring Empty cursor to PDP
    1273   1194 00005638 4281            	PUTOEC	CLR.L	D1
    1274   1195 0000563A 3238 1088       		MOVE.W	PDPOEC,D1
    1275   1196 0000563E 31FC 0072 1040  		MOVE.W	#$72,P10ADR		; at o162
    1276   1197 00005644 6100 FF46       		BSR	PUTPDPR			; write into PDP
    1277   1198 00005648 4E75            		RTS
    1278   1199                          	
    1279   1200                          	
    1280   1201                          	*	Wait until (at least) 4 bytes available in PDP-10 ring
    1281   1202 0000564A 6108            	WAITPDP	BSR	FDRGSZ			; find ring size
    1282   1203 0000564C 4A78 1092       		TST.W	INRGSP
    1283   1204 00005650 67F8            		BEQ	WAITPDP			; wait until non-zero
    1284   1205 00005652 4E75            		RTS
    1285   1206                          	EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		P D P   I / O                 15-Apr-88  Page   29
Err Source Ref. Address   value
    line   line

    1286   1207                          	
    1287   1208                          	*	Find Cursor, then Calculate # of bytes of space left in PDP-10 Ring
    1288   1209 00005654                 	FDRGSZ	PUSHM	D0/D1
    1289   1211 00005658 6100 FE4A       		BSR	GETIEC			; first read cursor
    1290   1212 0000565C 3238 108E       		MOVE.W	PDPIEC,D1		; PDP empty pointer
    1291   1213 00005660 9278 1090       		SUB.W	PDPIFC,D1		;  - our fill pointer
    1292   1214 00005664 6F0A            		BLE	CARWRAP			; ring wrap...skip
    1293   1215 00005666 5341            		SUB.W	#1,D1			; fill ahead of empty, insure no overflow
    1294   1216 00005668 E549            		LSL.W	#2,D1			; * 4 to get number of bytes
    1295   1217 0000566A 31C1 1092       		MOVE.W	D1,INRGSP		; this is space available
    1296   1218 0000566E 602E            		BRA	CARRTS
    1297   1219                          	
    1298   1220 00005670 3238 108C       	CARWRAP	MOVE.W	PDPISZ,D1		; empty ahead of fill...
    1299   1221 00005674 9278 1090       		SUB.W	PDPIFC,D1		; ring size - our fill cursor
    1300   1222 00005678 E549            		LSL.W	#2,D1			; * 4 to get number of bytes
    1301   1223 0000567A 31C1 1092       		MOVE.W	D1,INRGSP		; this is space (to end of ring)
    1302   1224 0000567E 3238 1094       		MOVE.W	INTYBT,D1		; check type
    1303   1225 00005682 670C            		BEQ	NODALN			; Skip if Needle
    1304   1226 00005684 0C41 009E       		CMP.W	#$9E,D1			; Data MSG?
    1305   1227 00005688 6C06            		BGE	NODALN			; no...alignment not required
    1306   1228 0000568A 4A78 1096       		TST.W	PORTNO			; port0 MSG?
    1307   1229 0000568E 660E            		BNE	CARRTS			; no...must be data...just go exit
    1308   1230 00005690 3238 108E       	NODALN	MOVE.W	PDPIEC,D1		; non-data messages CAN wrap in ring!
    1309   1231 00005694 6708            		BEQ	CARRTS			; no more if null
    1310   1232 00005696 5341            		SUB.W	#1,D1			; insure no overrun
    1311   1233 00005698 E549            		LSL.W	#2,D1			; times 4
    1312   1234 0000569A D378 1092       		ADD.W	D1,INRGSP		; actual space allows for wrap
    1313   1235 0000569E                 	CARRTS	POPM	D0/D1
    1314   1237 000056A2 4E75            		RTS



    1316   1239                          		TTL	'E B U S  --  PDP-10 Base Code,		B U F F E R   S T U F F'EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		B U F F E R   S T U F F       15-Apr-88  Page   30
Err Source Ref. Address   value
    line   line

    1318   1241                          	**********************************
    1319   1242                          	**********************************
    1320   1243                          	**				**
    1321   1244                          	**	Bufferlet Routines	**
    1322   1245                          	**				**
    1323   1246                          	**********************************
    1324   1247                          	**********************************
    1325   1248                          	
    1326   1249                          	*	Character handlers.
    1327   1250                          	*	  These routines pass buffer char in D0
    1328   1251                          	*	  A0/D1 for working registers
    1329   1252                          	
    1330   1253                          	*	Get char from buffer and increment forward thru the buffer.
    1331   1254 000056A4 2078 10E8       	DGCI	MOVEA.L	.BFLTS,A0		; get pointer to bufferlets
    1332   1255 000056A8 322C 001A       		MOVE.W	BB(Rp),D1		; Get index to character
    1333   1256 000056AC 4240            		CLR.W	D0			; return char as word
    1334   1257 000056AE 1030 1000       		MOVE.B	0(A0,D1.W),D0		; Pick up char
    1335   1258                          	 IF	CTRACE
    1337   1259                          	 ENDC
    1338   1260 000056B2 536C 001E       		SUBQ.W	#1,BCT(Rp)		; Update count
    1339   1261 000056B6 6F24            		BLE	DGCI2			; Skip if no characters left
    1340   1262 000056B8 5241            		ADDQ.W	#1,D1			; Else increment BB value
    1341   1263 000056BA 3941 001A       		MOVE.W	D1,BB(Rp)		; save pointer
    1342   1264 000056BE 0241 000F       		AND.W	#BFLSIZ-1,D1		; Test if at end of bufferlet
    1343   1265 000056C2 6616            		BNE	DGCI1			; skip to exit if not
    1344   1266 000056C4 322C 001A       		MOVE.W	BB(Rp),D1		; bufferlet exhausted
    1345   1267 000056C8 3970 1000 001A  		MOVE.W	0(A0,D1.W),BB(Rp)	; get pointer to next bufferlet
    1346   1268 000056CE 046C 000E 001A  		SUB.W	#BFLSIZ-2,BB(Rp)	; back it up to beginning of bufferlet
    1347   1269 000056D4 3190 1000       		MOVE.W	(A0),0(A0,D1.W)		; Link last bufferlet to free list
    1348   1270 000056D8 3081            		MOVE.W	D1,(A0)			; And put at the head of the free list
    1349   1271                          	
    1350   1272 000056DA 4E75            	DGCI1	RTS				; Then exit
    1351   1273                          	
    1352   1274                          	*	Last char in buffer
    1353   1275 000056DC 6D00 FAEA       	DGCI2	BLT.L	DGCIH			; CRASH if empty
    1354   1276 000056E0 0641 000E       		ADD.W	#BFLSIZ-2,D1		; Bump character pointer past
    1355   1277                          	*						end of bufferlet
    1356   1278 000056E4 0241 FFF0       		AND.W	#-BFLSIZ,D1		; Make chain a multiple of BFLSIZ
    1357   1279 000056E8 3190 1000       		MOVE.W	(A0),0(A0,D1.W)		; chain free-list to this bufferlet
    1358   1280 000056EC 3081            		MOVE.W	D1,(A0)			; Update free list
    1359   1281 000056EE 4E75            		RTS



    1361   1283                          	*	Peek at next char in buffer.
    1362   1284                          	*	return:	CC set EQ if buffer empty
    1363   1285                          	*	else	CC set NE, char in D0.L
    1364   1286                          	*			Unless ESC'ed, then D0 contains -1.W | Char.W
    1365   1287 000056F0 4A6C 001E       	DPEEK	TST.W	BCT(Rp)			; is buffer empty?
    1366   1288 000056F4 673A            		BEQ	DPEEKX			; exit (CC EQ) if notEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		B U F F E R   S T U F F       15-Apr-88  Page   31
Err Source Ref. Address   value
    line   line

    1367   1289 000056F6 2078 10E8       		MOVEA.L	.BFLTS,A0		; get pointer to bufferlets
    1368   1290 000056FA 322C 001A       		MOVE.W	BB(Rp),D1		; Get index to character
    1369   1291 000056FE 4280            		CLR.L	D0			; return char as long
    1370   1292 00005700 1030 1000       		MOVE.B	0(A0,D1.W),D0		; Pick up char
    1371   1293 00005704 0C00 001B       		CMP.B	#ESC,D0			; ESC?
    1372   1294 00005708 6626            		BNE	DPEEKX			; exit if not ESC
    1373   1295 0000570A 5241            		ADDQ.W	#1,D1			; Else increment BB value
    1374   1296 0000570C 0241 000F       		AND.W	#BFLSIZ-1,D1		; Test if at end of bufferlet
    1375   1297 00005710 660E            		BNE	DPEEK1			; skip if not
    1376   1298 00005712 322C 001A       		MOVE.W	BB(Rp),D1		; bufferlet exhausted
    1377   1299 00005716 3230 1001       		MOVE.W	1(A0,D1.W),D1		; get pointer to next bufferlet
    1378   1300 0000571A 0441 000F       		SUB.W	#BFLSIZ-1,D1		; back it up to beginning of bufferlet
    1379   1301 0000571E 6004            		BRA	DPEEK2			; and skip
    1380   1302                          	
    1381   1303 00005720 322C 001A       	DPEEK1	MOVE.W	BB(Rp),D1		; examine next char
    1382   1304                          	
    1383   1305 00005724 203C FFFF 0000  	DPEEK2	MOVE.L	#$FFFF0000,D0		; ESC'ed char...return -1 in high-word
    1384   1306 0000572A 1030 1001       		MOVE.B	1(A0,D1.W),D0		; ESC'ed char in low word
    1385   1307 0000572E 7201            		MOVEQ	#1,D1			; insure CC NE
    1386   1308                          	
    1387   1309 00005730 4E75            	DPEEKX	RTSEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		B U F F E R   S T U F F       15-Apr-88  Page   32
Err Source Ref. Address   value
    line   line

    1389   1311                          	*	Put a character into the buffer
    1390   1312 00005732 2078 10E8       	DWCI	MOVEA.L	.BFLTS,A0		; get pointer to bufferlet area
    1391   1313                          	 IF	CTRACE
    1393   1314                          	 ENDC
    1394   1315 00005736 4A6C 001E       		TST.W	BCT(Rp)			; Check count
    1395   1316 0000573A 6F40            		BLE	DWCI4			; If new buffer, set up attention flags
    1396   1317 0000573C 526C 001E       		ADDQ.W	#1,BCT(Rp)		; Else update count
    1397   1318 00005740 526C 001C       		ADDQ.W	#1,BE(Rp)		; Advance BE
    1398   1319 00005744 322C 001C       		MOVE.W	BE(Rp),D1		; Get pointer to new character position
    1399   1320 00005748 0241 000F       		AND.W	#BFLSIZ-1,D1		; Test if bufferlet full
    1400   1321 0000574C 670A            		BEQ	DWCI2			; End of bufferlet
    1401   1322 0000574E 322C 001C       		MOVE.W	BE(Rp),D1		; ok...get index again
    1402   1323 00005752 1180 1000       		MOVE.B	D0,0(A0,D1.W)		; And save char in buffer
    1403   1324 00005756 4E75            		RTS
    1404   1325                          	
    1405   1326                          	*	Need a new bufferlet
    1406   1327 00005758 322C 001C       	DWCI2	MOVE.W	BE(Rp),D1
    1407   1328 0000575C 4A50            		TST.W	(A0)			; any more bufferlets?
    1408   1329 0000575E 6E04            		BGT	DWCI3			; Skip if there is another
    1409   1330 00005760 6100 0040       		 BSR.L	WRE			; (Else open the reserve tank)
    1410   1331                          	
    1411   1332 00005764 3190 1000       	DWCI3	MOVE.W	(A0),0(A0,D1.W)		; Link new bufferlet to last one
    1412   1333 00005768 3210            		MOVE.W	(A0),D1			; And remove from free list
    1413   1334 0000576A 30B0 1000       		MOVE.W	0(A0,D1.W),(A0)
    1414   1335 0000576E 0441 000E       		SUB.W	#BFLSIZ-2,D1		; Back up new bufferlet
    1415   1336 00005772 3941 001C       		MOVE.W	D1,BE(Rp)		; Save as new BE
    1416   1337 00005776 1180 1000       		MOVE.B	D0,0(A0,D1.W)		; Put the character there
    1417   1338 0000577A 4E75            		RTS
    1418   1339                          	
    1419   1340                          	*	The buffer was empty
    1420   1341 0000577C 6D00 FA52       	DWCI4	BLT.L	DWCIH			; count should NEVER be negative
    1421   1342 00005780 526C 001E       		ADD.W	#1,BCT(Rp)		; Set count = 1
    1422   1343 00005784 4A50            		TST.W	(A0)			; Any buffers on free-list?
    1423   1344 00005786 6E02            		BGT	DWCI5			; Skip if there was one
    1424   1345 00005788 6118            		 BSR	WRE			; Else open the reserve tank
    1425   1346                          	
    1426   1347 0000578A 3210            	DWCI5	MOVE.W	(A0),D1			; Pop a bufferlet off free list
    1427   1348 0000578C 30B0 1000       		MOVE.W	0(A0,D1.W),(A0)		; Update free list
    1428   1349 00005790 0441 000E       		SUB.W	#BFLSIZ-2,D1		; Point it at first character
    1429   1350 00005794 3941 001A       		MOVE.W	D1,BB(Rp)		; Set up BB
    1430   1351 00005798 3941 001C       		MOVE.W	D1,BE(Rp)		; And BE
    1431   1352 0000579C 1180 1000       		MOVE.B	D0,0(A0,D1.W)		; Put the character there
    1432   1353 000057A0 4E75            		RTSEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		B U F F E R   S T U F F       15-Apr-88  Page   33
Err Source Ref. Address   value
    line   line

    1434   1355                          	*	Move reserve storage supply to main free list
    1435   1356 000057A2 30B8 10EE       	WRE	MOVE.W	R_TANK,(A0)		; Get pointer to reserve bufferlets
    1436   1357 000057A6 6F00 006E       		BLE.L	WREH			; was empty...abort
    1437   1358 000057AA 4278 10EE       		CLR.W	R_TANK			; Set reserve bufferlets empty (=0)
    1438   1359 000057AE 4E75            		RTS




    1440   1361                          	*	Return all the space used by the buffer
    1441   1362                          	
    1442   1363 000057B0 4A6C 001E       	DEMPTY	TST.W	BCT(Rp)			; Check contents
    1443   1364 000057B4 6726            		BEQ	C1			; empty...just exit
    1444   1365 000057B6 426C 001E       		CLR.W	BCT(Rp)			; not empty...set count = 0
    1445   1366                          	 IF	CTRACE
    1447   1367                          	 ENDC
    1448   1368 000057BA 2078 10E8       		MOVEA.L	.BFLTS,A0		; get pointer to bufferlet area
    1449   1369 000057BE 302C 001C       		MOVE.W	BE(Rp),D0		; Get pointer to last character in buffer
    1450   1370 000057C2 0640 000E       		ADD.W	#BFLSIZ-2,D0		; Locate the pointer in this bufferlet
    1451   1371 000057C6 0240 FFF0       		AND.W	#-BFLSIZ,D0
    1452   1372 000057CA 3190 0000       		MOVE.W	(A0),0(A0,D0.W)		; Chain previous free list to this
    1453   1373                          	*						bufferlet
    1454   1374 000057CE 302C 001A       		MOVE.W	BB(Rp),D0		; Pointer to first char in buffer
    1455   1375 000057D2 0640 000E       		ADD.W	#BFLSIZ-2,D0
    1456   1376 000057D6 0240 FFF0       		AND.W	#-BFLSIZ,D0
    1457   1377 000057DA 3080            		MOVE.W	D0,(A0)			; Put the buffer's bufferlets
    1458   1378                          	*						onto free list
    1459   1379 000057DC 70FF            	C1	MOVEQ	#-1,D0			; "empty" flag
    1460   1380 000057DE 4E75            		RTS				; And return



    1462   1382                          		TTL	'E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G'EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G   15-Apr-88  Page   34
Err Source Ref. Address   value
    line   line

    1464   1384                          	*	ERROR CONDITION DETECTED, CRASH INTERFACE
    1465   1385                          	
    1466   1386                          	
    1467   1387 000057E0                 	NOKEY	CRASH	0			; key not refreshed by host
    1468   1390                          	
    1469   1391 000057E8                 	BADKEY	CRASH	3			; bad key read from host
    1470   1394                          	
    1471   1395                          	*	Crash due to bad Message Type
    1472   1396 000057F0 21F8 109C 100C  	MERROR	MOVE.L	DAT,CASHW		; save copy of DAT
    1473   1397 000057F6                 		CRASH	4			; crash the interface
    1474   1400                          	
    1475   1401                          	*	Crash due to MIC timeout
    1476   1402 000057FE                 	TMOUT1	CRASH	8
    1477   1405                          	
    1478   1406                          	*	Crash due to MIC parity error
    1479   1407 00005806                 	PARERR	CRASH	9
    1480   1410                          	
    1481   1411                          	*	Crash due to  MIC too busy too long
    1482   1412 0000580E                 	BUSCRAS	CRASH	10
    1483   1415                          	
    1484   1416 00005816 11FC 0015 1004  	WREH	MOVE.B	#21,CODCASH		; WRE crash
    1485   1417                          	
    1486   1418                          	*	Routine that crashes the host for interface problems
    1487   1419 0000581C 4FF8 1000       	VCRASH	LEA	STKTOP,SP		; reset stack
    1488   1420 00005820 4A38 10FC       		TST.B	DIAG
    1489   1421 00005824 6600 25F8       		BNE.L	DIAGERR
    1490   1422 00005828 4A79 00D0 1038  		TST.W	DEXCO			; Reset EBUS
    1491   1423 0000582E 610C            		BSR	HODOWN			; set host down
    1492   1424 00005830 6100 FD10       		BSR	HCRASH			; crash the host
    1493   1425 00005834 6100 00D8       		BSR.L	EMPTY			; Empty ISIS ring
    1494   1426 00005838 6000 01C4       		BRA.L	EXEC			; and start over
    1495   1427                          	
    1496   1428                          	
    1497   1429                          	*	HODOWN - Set HTDWN and report host down
    1498   1430 0000583C 7801            	HODOWN	MOVEQ	#1,D4
    1499   1431 0000583E 11C4 1081       		MOVE.B	D4,HTDWN		; set down and fall through...
    1500   1432                          	
    1501   1433                          	*	HDOWN -	Report Host Down or Gone
    1502   1434                          	*	D4 = 1 for Down, 3 for Gone (B)
    1503   1435 00005842 1038 1046       	HDOWN	MOVE.B	HSTAT,D0		; going down and already down/gone?
    1504   1436 00005846 C004            		AND.B	D4,D0			; or going gone and already gone?
    1505   1437 00005848 B900            		EOR.B	D4,D0
    1506   1438 0000584A 672E            		BEQ	HDN3			; yes...nothing to be done
    1507   1439 0000584C 11C4 1046       		MOVE.B	D4,HSTAT		; no...change required
    1508   1440 00005850 617A            		BSR	HREPRT			; report it
    1509   1441 00005852 303C 00FF       		MOVE.W	#MAXPORT-1,D0		; for all ports...
    1510   1442 00005856 6124            	HDN1	BSR	SETPORT			; set up port
    1511   1443 00005858 082C 0000 0001  		BTST	#PF_ACT,P_FLAGS(Rp)	; test if port is active
    1512   1444 0000585E 6712            		BEQ	HDN2			; no
    1513   1445 00005860 612A            		BSR	RBTALL			; yes...reset everythingEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G   15-Apr-88  Page   35
Err Source Ref. Address   value
    line   line

    1514   1446 00005862 6100 0156       		BSR.L	DPORT			;  ...and remember to reduce the port-count
    1515   1447 00005866 3638 1096       		MOVE.W	PORTNO,D3		; Port #
    1516   1448 0000586A 183C 009F       		MOVE.B	#$9F,D4			; ZAPPER
    1517   1449 0000586E 6100 FA6A       		BSR	SENDQI			; send Quick ISIS message
    1518   1450 00005872 3038 1096       	HDN2	MOVE.W	PORTNO,D0		; on to next port
    1519   1451 00005876 5340            		SUB.W	#1,D0
    1520   1452 00005878 6EDC            		BGT	HDN1
    1521   1453 0000587A 4E75            	HDN3	RTS				; done...exit
    1522   1454                          	
    1523   1455                          	
    1524   1456                          	*	set up Rp, PORTNO
    1525   1457                          	*	Expect:	D0 = port number (W)
    1526   1458                          	*	Return:	D0 smashed, Rp set up
    1527   1459 0000587C 31C0 1096       	SETPORT	MOVE.W	D0,PORTNO		; set up port number
    1528   1460 00005880 C0FC 0020       		MULU	#PD_SIZ,D0		; compute offset into port-descriptor
    1529   1461 00005884 49F8 18FE       		LEA	PORTS,Rp
    1530   1462 00005888 D8C0            		ADD.W	D0,Rp			; compute address of port-descriptor
    1531   1463 0000588A 4E75            		RTS
    1532   1464                          	
    1533   1465                          	
    1534   1466                          	
    1535   1467                          	*	Special routine to manipulate bits-flags
    1536   1468                          	
    1537   1469                          	*	Reset everything...
    1538   1470 0000588C 6100 06F4       	RBTALL	BSR.L	RBTBKO			; cancel block-output
    1539   1471 00005890 6100 071C       		BSR.L	RBTBKI			; cancel block-input
    1540   1472 00005894 6100 FF1A       		BSR	DEMPTY			; empty any buffer storage
    1541   1473 00005898 6100 0722       		BSR.L	RBTBUF			; clean up buffer usage
    1542   1474 0000589C 422C 0001       		CLR.B	P_FLAGS(Rp)		; clear everything
    1543   1475 000058A0 197C 009D 0002  		MOVE.B	#157,XMITLMT(Rp)	; initialize transmit limit
    1544   1476 000058A6 4E75            		RTS
    1545   1477                          	
    1546   1478                          	
    1547   1479                          	*	Verify KEY-cell in PDP-10...
    1548   1480                          	*	If expected (i.e., $CDFA68CB2), zero out key, return CC EQ
    1549   1481                          	*	Else return CC NE
    1550   1482 000058A8 31FC 0068 1040  	DOKEY	MOVE.W	#$68,P10ADR		; get KEY at o150
    1551   1483 000058AE 6100 FB7A       		BSR	GETPDPR			; get (right) bits
    1552   1484 000058B2 0C81 DFA6 8CB2  		CMP.L	#$DFA68CB2,D1
    1553   1485 000058B8 6610            		BNE	DOKEYX			; no match...return with CC set NE
    1554   1486 000058BA 0C38 00CD 103A  		CMP.B	#$CD,P10DAH		; check high bits
    1555   1487 000058C0 6608            		BNE	DOKEYX			; no match...return with CC set NE
    1556   1488 000058C2 4281            		CLR.L	D1			; match...zero out the key
    1557   1489 000058C4 6100 FCC6       		BSR	PUTPDPR
    1558   1490 000058C8 9241            		SUB.W	D1,D1			; insure CC set EQ
    1559   1491 000058CA 4E75            	DOKEYX	RTS				; return
    1560   1492                          	
    1561   1493                          	
    1562   1494                          	*	HREPRT - Report Host status to Sup
    1563   1495 000058CC 700E            	HREPRT	MOVEQ	#14,D0			; we'll need 14 bytes of space in ring
    1564   1496 000058CE 6100 F97E       		BSR	WAITIS			; wait until it's thereEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G   15-Apr-88  Page   36
Err Source Ref. Address   value
    line   line

    1565   1497 000058D2 4243            		CLR.W	D3			; for Port 0
    1566   1498 000058D4 7810            		MOVEQ	#$10,D4			; Message Type 10
    1567   1499 000058D6 6100 F988       		BSR	SLOR
    1568   1500 000058DA 4200            		CLR.B	D0			; padding (B)
    1569   1501 000058DC 6100 F99E       		BSR	PUTCH
    1570   1502 000058E0 3038 1042       		MOVE.W	HOSTN,D0		; Host Number (HW)
    1571   1503 000058E4 6726            		BEQ	HREPRTX			; abort if null host-number
    1572   1504 000058E6 6100 F9C0       		BSR	PUTH
    1573   1505 000058EA 3038 1044       		MOVE.W	HOSTP,D0		; Host Ports (HW)
    1574   1506 000058EE 6100 F9B8       		BSR	PUTH
    1575   1507 000058F2 4240            		CLR.W	D0			; Relative Host# = 0 (HW)
    1576   1508 000058F4 6100 F9B2       		BSR	PUTH
    1577   1509 000058F8 3038 1046       		MOVE.W	HSTAT,D0		; Status | Hkey=0 (HW)
    1578   1510 000058FC 6100 F9AA       		BSR	PUTH
    1579   1511 00005900 303C 0091       		MOVE.W	#PRODID,D0		; No IIX | ProductID (HW)
    1580   1512 00005904 6100 F9A2       		BSR	PUTH
    1581   1513 00005908 6100 F9BE       		BSR	ELOR
    1582   1514 0000590C 4E75            	HREPRTX	RTS
    1583   1515                          	
    1584   1516                          	
    1585   1517                          	*	EMPTY - EMPTY OUT ISIS INPUT RING
    1586   1518 0000590E 6100 F9D2       	EMPTY	BSR	LOOK			; see what's next in ring
    1587   1519 00005912 6602            		BNE	EMP1
    1588   1520 00005914 4E75            		RTS				; return..ring is empty
    1589   1521                          	
    1590   1522 00005916 4A43            	EMP1	TST.W	D3			; check port number
    1591   1523 00005918 6724            		BEQ	EMP2			; port0 = intra-node message
    1592   1524 0000591A 3004            		MOVE.W	D4,D0			; Check for Needle
    1593   1525 0000591C 6738            		BEQ	EMP5			; special handling for needles
    1594   1526 0000591E 0C40 00B2       		CMP.W	#$B2,D0			; Check for Pseudo-needle
    1595   1527 00005922 6740            		BEQ	EMP6			; special handling for P-needles
    1596   1528 00005924 0C40 009D       		CMP.W	#$9D,D0			; in range of data message?
    1597   1529 00005928 6F26            		BLE	EMP4			; Just flush data
    1598   1530 0000592A 0C40 00C1       		CMP.W	#$C1,D0			; range check
    1599   1531 0000592E 6C00 F87C       		BGE	ISMGER
    1600   1532 00005932 0444 009E       		SUB.W	#$9E,D4
    1601   1533 00005936 41F8 5970 4E71  		LEA	IMSSZ,A0
    1602   1534 0000593C 600E            		BRA	EMP3
    1603   1535                          	
    1604   1536                          	*	Flush port0 messages
    1605   1537 0000593E 0C44 000E       	EMP2	CMP.W	#$0E,D4			; range check
    1606   1538 00005942 6C00 F868       		BGE	ISMGER
    1607   1539 00005946 41F8 5994 4E71  		LEA	IPZSZ,A0
    1608   1540                          	
    1609   1541 0000594C 1030 4000       	EMP3	MOVE.B	0(A0,D4.W),D0		; table lookup for message length
    1610   1542                          	
    1611   1543 00005950 6100 F9FE       	EMP4	BSR	FLUSH			; remove MSG from ring
    1612   1544 00005954 60B8            		BRA	EMPTY			; ...and get next one
    1613   1545                          	
    1614   1546                          	*	Needle
    1615   1547 00005956 183C 009F       	EMP5	MOVE.B	#$9F,D4			; ZAPPEREBUS02.J00/X               E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G   15-Apr-88  Page   37
Err Source Ref. Address   value
    line   line

    1616   1548 0000595A 6100 F97E       		BSR	SENDQI			; send Quick Message to ISIS
    1617   1549 0000595E 6100 F9A2       		BSR	GETCH			; get needle-length
    1618   1550 00005962 60EC            		BRA	EMP4
    1619   1551                          	
    1620   1552                          	*	Psuedo-needle
    1621   1553 00005964 183C 009F       	EMP6	MOVE.B	#$9F,D4			; ZAPPER
    1622   1554 00005968 6100 F970       		BSR	SENDQI			; send Quick Message to ISIS
    1623   1555 0000596C 7003            		MOVEQ	#3,D0			; set pseudo-needle length
    1624   1556 0000596E 60E0            		BRA	EMP4
    1625   1557                          	
    1626   1558                          	
    1627   1559                          	*	ISIS INPUT MESSAGE LENGTHS (NOT COUNTING PORT NMBR)
    1628   1560 00005970 00              	IMSSZ	DC.B	0			; 9E
    1629   1561 00005971 00              		DC.B	0			; 9F
    1630   1562 00005972 00              		DC.B	0			; A0
    1631   1563 00005973 00              		DC.B	0			; A1
    1632   1564 00005974 00              		DC.B	0			; A2
    1633   1565 00005975 00              		DC.B	0			; A3
    1634   1566 00005976 00              		DC.B	0			; A4
    1635   1567 00005977 00              		DC.B	0			; A5
    1636   1568 00005978 00              		DC.B	0			; A6
    1637   1569 00005979 00              		DC.B	0			; A7
    1638   1570 0000597A 00              		DC.B	0			; A8
    1639   1571 0000597B 00              		DC.B	0			; A9
    1640   1572 0000597C 00              		DC.B	0			; AA
    1641   1573 0000597D 00              		DC.B	0			; AB
    1642   1574 0000597E 00              		DC.B	0			; AC
    1643   1575 0000597F 00              		DC.B	0			; AD
    1644   1576 00005980 00              		DC.B	0			; AE
    1645   1577 00005981 00              		DC.B	0			; AF
    1646   1578 00005982 01              		DC.B	1			; B0
    1647   1579 00005983 02              		DC.B	2			; B1
    1648   1580 00005984 03              		DC.B	3			; B2
    1649   1581 00005985 01              		DC.B	1			; B3
    1650   1582 00005986 01              		DC.B	1			; B4
    1651   1583 00005987 01              		DC.B	1			; B5
    1652   1584 00005988 07              		DC.B	7			; B6
    1653   1585 00005989 05              		DC.B	5			; B7
    1654   1586 0000598A 00              		DC.B	0			; B8
    1655   1587 0000598B 01              		DC.B	1			; B9
    1656   1588 0000598C 00              		DC.B	0			; BA
    1657   1589 0000598D 00              		DC.B	0			; BB
    1658   1590 0000598E 00              		DC.B	0			; BC
    1659   1591 0000598F 00              		DC.B	0			; BD
    1660   1592 00005990 01              		DC.B	1			; BE
    1661   1593 00005991 00              		DC.B	0			; BF
    1662   1594 00005992 00              		DC.B	0			; C0
    1663   1595 00005993 05              		DC.B	5			; C1
    1664   1596                          	
    1665   1597                          	
    1666   1598                          	*	ISIS INTRA-NODE MESSAGE LENGTHSEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G   15-Apr-88  Page   38
Err Source Ref. Address   value
    line   line

    1667   1599 00005994 00              	IPZSZ	DC.B	0			; 00
    1668   1600 00005995 00              		DC.B	0			; 01
    1669   1601 00005996 01              		DC.B	1			; 02
    1670   1602 00005997 06              		DC.B	6			; 03
    1671   1603 00005998 09              		DC.B	9			; 04
    1672   1604 00005999 05              		DC.B	5			; 05
    1673   1605 0000599A 05              		DC.B	5			; 06
    1674   1606 0000599B 08              		DC.B	8			; 07
    1675   1607 0000599C 08              		DC.B	8			; 08
    1676   1608 0000599D 04              		DC.B	4			; 09
    1677   1609 0000599E 07              		DC.B	7			; 0A
    1678   1610 0000599F 04              		DC.B	4			; 0B
    1679   1611 000059A0 07              		DC.B	7			; 0C
    1680   1612 000059A1 00              		DC.B	0			; 0D



    1682   1614                          	*		Host-port Management (soft Shut/Answer)
    1683   1615                          	
    1684   1616                          	
    1685   1617                          	*	IPORT - INCREMENT NUMBER OF PORTS
    1686   1618 000059A2 5278 104E       	IPORT	ADD.W	#1,NPORTS		; increment number
    1687   1619 000059A6 3038 104E       		MOVE.W	NPORTS,D0
    1688   1620 000059AA B078 104C       		CMP.W	MXPORT,D0
    1689   1621 000059AE 6E02            		BGT	IPORT2			; reached limit
    1690   1622 000059B0 4E75            	IPORT1	RTS
    1691   1623                          	
    1692   1624 000059B2 11FC 0001 10FB  	IPORT2	MOVE.B	#1,PFULL		; full (shutable)
    1693   1625 000059B8 6012            		BRA	DPORT1
    1694   1626                          	
    1695   1627                          	
    1696   1628                          	*	DPORT - DECREMENT NUMBER OF PORTS
    1697   1629 000059BA 5378 104E       	DPORT	SUB.W	#1,NPORTS		; decrement number
    1698   1630 000059BE 3038 104E       		MOVE.W	NPORTS,D0
    1699   1631 000059C2 B078 104C       		CMP.W	MXPORT,D0
    1700   1632 000059C6 66E8            		BNE	IPORT1			; not at limit
    1701   1633 000059C8 4238 10FB       		CLR.B	PFULL			; not full (answerable)
    1702   1634                          	
    1703   1635 000059CC 700A            	DPORT1	MOVEQ	#10,D0			; need 10 bytes for Message
    1704   1636 000059CE 6100 F87E       		BSR	WAITIS			; insure there is room there
    1705   1637 000059D2 4243            		CLR.W	D3			; port 0,
    1706   1638 000059D4 780A            		MOVEQ	#10,D4			; message type 10d
    1707   1639 000059D6 6100 F888       		BSR	SLOR
    1708   1640 000059DA 4200            		CLR.B	D0			; 1 byte of padding
    1709   1641 000059DC 6100 F89E       		BSR	PUTCH
    1710   1642 000059E0 3038 1042       		MOVE.W	HOSTN,D0		; Host number (HW)
    1711   1643 000059E4 6100 F8C2       		BSR	PUTH
    1712   1644 000059E8 7001            		MOVEQ	#1,D0
    1713   1645 000059EA 9038 10FB       		SUB.B	PFULL,D0		; soft shut/answer (HW)
    1714   1646 000059EE 6100 F8B8       		BSR	PUTH
    1715   1647 000059F2 4240            		CLR.W	D0			; only host is 0 (HW)EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G   15-Apr-88  Page   39
Err Source Ref. Address   value
    line   line

    1716   1648 000059F4 6100 F8B2       		BSR	PUTH
    1717   1649 000059F8 6100 F8CE       		BSR	ELOR
    1718   1650 000059FC 4E75            		RTS



    1720   1652                          		TTL	'E B U S  --  PDP-10 Base Code,		E X E C   L O O P'EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		E X E C   L O O P             15-Apr-88  Page   40
Err Source Ref. Address   value
    line   line

    1722   1654                          	
    1723   1655                          	
    1724   1656 000059FE BFFC 0000 1000  	EXEC	CMPA.L	#STKTOP,SP		; if stack is empty,
    1725   1657 00005A04 670A            		BEQ	EXEC1			; then everything is OK...
    1726   1658 00005A06                 		FCRASH	$60			; Else, something is dreadfully WRONG!
    1727   1661                          	
    1728   1662 00005A10 2078 1022       	EXEC1	MOVE.L	.SYNC,A0		; get sync address
    1729   1663 00005A14 3010            		MOVE.W	(A0),D0			; did slot get back before us?
    1730   1664 00005A16 6D0E            		BLT	EXEC4			; yes
    1731   1665 00005A18 9150            		SUB.W	D0,(A0)			; no...set to 0
    1732   1666                          	
    1733   1667 00005A1A 303C 0064       	EXEC2	MOVE.W	#100,D0			; wait-loop
    1734   1668 00005A1E 5340            	EXEC3	SUB.W	#1,D0
    1735   1669 00005A20 6EFC            		BGT	EXEC3			; insure we don't tie up DMA
    1736   1670 00005A22 4A50            		TST.W	(A0)			; waiting for slot to set it
    1737   1671 00005A24 6CF4            		BGE	EXEC2
    1738   1672                          	
    1739   1673                          	*	we set SYNC to 1 while we are executing, 0 when we're done
    1740   1674                          	*	Slot sets it to -1, and uses the number to generate speedometer.
    1741   1675 00005A26 30BC 0001       	EXEC4	MOVE.W	#1,(A0)			; Syncronized...reset it and proceed
    1742   1676 00005A2A 3038 1042       		MOVE.W	HOSTN,D0		; now get host #
    1743   1677 00005A2E E148            		LSL.W	#8,D0
    1744   1678 00005A30 8078 104E       		OR.W	NPORTS,D0		; and get # ports
    1745   1679 00005A34 3140 0002       		MOVE.W	D0,2(A0)		; give slot <HOST# | #PORTS> to display
    1746   1680 00005A38 3178 1046 0004  		MOVE.W	HSTAT,4(A0)		; give slot <HSTAT> to display
    1747   1681 00005A3E 4278 10E4       		CLR.W	IRRN			; clear "throttles"
    1748   1682 00005A42 4278 10E6       		CLR.W	ORRN



    1750   1684                          		TTL	'E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T'EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         15-Apr-88  Page   41
Err Source Ref. Address   value
    line   line

    1752   1686                          	*		O U T P U T   F R O M   P D P - 1 0   T O   I S I S
    1753   1687                          	
    1754   1688                          	
    1755   1689                          	
    1756   1690 00005A46 4A38 1081       	HOSTOUT	TST.B	HTDWN			; check host status
    1757   1691 00005A4A 6600 0082       		BNE.L	HOUTX			; Host Down..Skip
    1758   1692 00005A4E 6100 FBE8       		BSR	PUTOEC
    1759   1693 00005A52 0C78 0100 10E6  		CMP.W	#$100,ORRN
    1760   1694 00005A58 6E74            		BGT	HOUTX
    1761   1695 00005A5A 6100 FA58       		BSR	GETOFC			; Read PDP output Fill cursor
    1762   1696 00005A5E 3238 1086       		MOVE.W	PDPOFC,D1		; PDP cursor == Our cursor?
    1763   1697 00005A62 9278 1088       		SUB.W	PDPOEC,D1
    1764   1698 00005A66 6766            		BEQ	HOUTX			; Yes...ring empty, go to exit
    1765   1699 00005A68 6100 F9DE       		BSR	RDPDP			; no...read a message
    1766   1700 00005A6C 11F8 109C 1080  		MOVE.B	DAT1,TYPBYT		; extract TYPE byte
    1767   1701 00005A72 4240            		CLR.W	D0			; extract port-number
    1768   1702 00005A74 1038 109D       		MOVE.B	DAT2,D0
    1769   1703 00005A78 6100 FE02       		BSR	SETPORT			; set up ports
    1770   1704 00005A7C 6100 008C       		BSR.L	GEHTLN			; compute ISIS message-length needed
    1771   1705 00005A80 6100 F7A6       		BSR	ROOM			; enough room in ORING?
    1772   1706 00005A84 6636            		BNE	HOUT2			; no...go do input
    1773   1707 00005A86 1238 1080       		MOVE.B	TYPBYT,D1		; check for messages which require response
    1774   1708 00005A8A 6D46            		BLT	TEXTMSG			; TYP > 80 "looks" < 0, is data
    1775   1709 00005A8C 0C01 002E       		CMP.B	#$2E,D1			; Block IO
    1776   1710 00005A90 671A            		BEQ	HOUT1
    1777   1711 00005A92 0C01 001F       		CMP.B	#$1F,D1			; Probe (query) Terminal Characteristics?
    1778   1712 00005A96 6714            		BEQ	HOUT1
    1779   1713 00005A98 0C01 0022       		CMP.B	#$22,D1			; Sup Clock Request?
    1780   1714 00005A9C 670E            		BEQ	HOUT1
    1781   1715 00005A9E 0C01 0016       		CMP.B	#$16,D1			; Supervisor (Aux Circuit) request?
    1782   1716 00005AA2 6708            		BEQ	HOUT1
    1783   1717 00005AA4 0C01 0019       		CMP.B	#$19,D1			; Test Pattern Probe?
    1784   1718 00005AA8 6600 0078       		BNE.L	OTFRHST			; none of the above
    1785   1719 00005AAC 6100 FBA6       	HOUT1	BSR	FDRGSZ			; find the PDP's input ring size
    1786   1720 00005AB0 3238 1092       		MOVE.W	INRGSP,D1
    1787   1721 00005AB4 0C41 0008       		CMP.W	#8,D1
    1788   1722 00005AB8 6C00 0068       		BGE.L	OTFRHST			; more than 8 bytes available, go DO IT!
    1789   1723                          	
    1790   1724 00005ABC 3038 1088       	HOUT2	MOVE.W	PDPOEC,D0		; Can't process message at this time...
    1791   1725 00005AC0 5340            		SUB.W	#1,D0			; back up our cursor
    1792   1726 00005AC2 6C06            		BGE	HOUT3
    1793   1727 00005AC4 3038 1084       		MOVE.W	PDPOSZ,D0		; wrapped backward...re-cycle
    1794   1728 00005AC8 5340            		SUB.W	#1,D0
    1795   1729 00005ACA 31C0 1088       	HOUT3	MOVE.W	D0,PDPOEC
    1796   1730                          	
    1797   1731 00005ACE 6000 05DA       	HOUTX	BRA.L	ISISIN			; now try to do ISIS input
    1798   1732                          	
    1799   1733                          	
    1800   1734                          	*	Process Output Data Messages
    1801   1735 00005AD2 3638 1096       	TEXTMSG	MOVE.W	PORTNO,D3		; for this portEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         15-Apr-88  Page   42
Err Source Ref. Address   value
    line   line

    1802   1736 00005AD6 1838 1080       		MOVE.B	TYPBYT,D4
    1803   1737 00005ADA 0404 0080       		SUB.B	#$80,D4			; message type is length
    1804   1738 00005ADE 1404            		MOVE.B	D4,D2			; save copy for counter
    1805   1739 00005AE0 6100 F77E       		BSR	SLOR
    1806   1740 00005AE4 43F8 109E       		LEA	DAT3,A1			; pointer to first byte to transfer
    1807   1741 00005AE8 1019            	TEXTLOP	MOVE.B	(A1)+,D0		; next byte
    1808   1742 00005AEA 6100 F790       		BSR	PUTCH
    1809   1743 00005AEE 5302            		SUB.B	#1,D2			; Done yet?
    1810   1744 00005AF0 6710            		BEQ	TEXTEND			; yes
    1811   1745 00005AF2 B2FC 10A0       		CMPA.W	#DAT5,A1		; have we exhausted this DAT?
    1812   1746 00005AF6 66F0            		BNE	TEXTLOP			; no
    1813   1747 00005AF8 6100 F94E       		BSR	RDPDP			; yes...get another
    1814   1748 00005AFC 43F8 109C       		LEA	DAT1,A1			; re-init pointer
    1815   1749 00005B00 60E6            		BRA	TEXTLOP			; and proceed
    1816   1750                          	
    1817   1751 00005B02 6100 F7C4       	TEXTEND	BSR	ELOR			; Done!
    1818   1752 00005B06 6000 FF3E       		BRA	HOSTOUT			; go for next message
    1819   1753                          	
    1820   1754                          	
    1821   1755                          	*	Get length of Message (translate PDP MSG type to ISIS length)
    1822   1756                          	*	Returns:	length in D0, A0 smashed
    1823   1757 00005B0A 4240            	GEHTLN	CLR.W	D0
    1824   1758 00005B0C 1038 1080       		MOVE.B	TYPBYT,D0		; get type byte
    1825   1759 00005B10 6D0A            		BLT	NOCAL			; skip if data message (x80+ "looks" <0 )
    1826   1760 00005B12 41F8 38FE       		LEA	TRHSTLN,A0		; start addr. of MSG-length Table
    1827   1761 00005B16 D0C0            		ADD.W	D0,A0			; add offset
    1828   1762 00005B18 1010            		MOVE.B	(A0),D0			; look up length
    1829   1763 00005B1A 6004            		BRA	NOCAL5
    1830   1764                          	
    1831   1765                          	*	Data message is $80 + length
    1832   1766 00005B1C 0400 007D       	NOCAL	SUB.B	#$80-3,D0		; remove bias, allow for ISIS header
    1833   1767 00005B20 4E75            	NOCAL5	RTSEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         15-Apr-88  Page   43
Err Source Ref. Address   value
    line   line

    1835   1769                          	*		PROCESS INDIVIDUAL HOST MESSAGES
    1836   1770                          	
    1837   1771                          	*	PROCESS MESSAGE IN RECORD
    1838   1772 00005B22 4242            	OTFRHST	CLR.W	D2
    1839   1773 00005B24 1438 1080       		MOVE.B	TYPBYT,D2		; message-type
    1840   1774 00005B28 0C42 0033       		CMP.W	#$33,D2			; range-check
    1841   1775 00005B2C 6E00 FCC2       		BGT	MERROR			; invalid message
    1842   1776 00005B30 D442            		ADD.W	D2,D2			; *2 to get offset
    1843   1777 00005B32 327B 2004       		MOVE.W	OMTAB(PC,D2.W),A1	; get target address
    1844   1778 00005B36 4ED1            		JMP	(A1)			; go there
    1845   1779                          	
    1846   1780                          	
    1847   1781                          	*	HOST OUTPUT MESSAGE DISPATCH TABLE
    1848   1782                          	*	(	"<" -	Legal from host
    1849   1783                          	*		">" -	Legal to host	)
    1850   1784 00005B38 57F0            	OMTAB	DC.W	MERROR			;    00 - Illegal
    1851   1785 00005B3A 5BA0            		DC.W	OPEN			; <  01 - Host Open
    1852   1786 00005B3C 5BA4            		DC.W	SHUT			; <  02 - Host Shut
    1853   1787 00005B3E 5BE2            		DC.W	RESET			; <> 03 - Reset Interface
    1854   1788 00005B40 5A46            		DC.W	HOSTOUT			; <> 04 - reset-Ack (ignor if rec'd)
    1855   1789 00005B42 57F0            		DC.W	MERROR			;  > 05 - Takeover/Sup-lost
    1856   1790 00005B44 57F0            		DC.W	MERROR			;  > 06 - Externally-init circuit
    1857   1791 00005B46 57F0            		DC.W	MERROR			;  > 07 - Internally-init circuit
    1858   1792 00005B48 5C04            		DC.W	ONBP			; <> 08 - Backpressure On
    1859   1793 00005B4A 5C1A            		DC.W	OFFBP			; <> 09 - Backpressure Off
    1860   1794 00005B4C 5C52            		DC.W	SPEC			; <> 0A - GOBBLER
    1861   1795 00005B4E 5C38            		DC.W	ZAP			; <> 0B - ZAPPER
    1862   1796 00005B50 5C52            		DC.W	SPEC			; <> OC - Enter DEM
    1863   1797 00005B52 5C52            		DC.W	SPEC			; <> 0D - Leave DEM
    1864   1798 00005B54 5C52            		DC.W	SPEC			; <> 0E - Green-ball
    1865   1799 00005B56 5C52            		DC.W	SPEC			; <> 0F - Red-ball
    1866   1800 00005B58 5C52            		DC.W	SPEC			; <> 10 - Yellow-ball
    1867   1801 00005B5A 5C52            		DC.W	SPEC			; <> 11 - Orange-ball
    1868   1802 00005B5C 5C52            		DC.W	SPEC			; <  12 - Hang-up, forward out only
    1869   1803 00005B5E 5C52            		DC.W	SPEC			; <> 13 - Enter Transparency
    1870   1804 00005B60 5C52            		DC.W	SPEC			; <> 14 - Leave Transparency
    1871   1805 00005B62 57F0            		DC.W	MERROR			;  > 15 - Black/Gray-Ball
    1872   1806 00005B64 5CAC            		DC.W	SUPREC			; <  16 - SUP (AUX-circuit) Request
    1873   1807 00005B66 57F0            		DC.W	MERROR			;  > 17 - response to 16
    1874   1808 00005B68 5D06            		DC.W	SUPLOG			; <  18 - SUP Login Char
    1875   1809 00005B6A 5D8A            		DC.W	TP			; <  19 - Test-pattern Probe
    1876   1810 00005B6C 57F0            		DC.W	MERROR			;  > 1A - Test-pattern Response
    1877   1811 00005B6E 5DA8            		DC.W	HSTSAD			; <  1B - Host-sad
    1878   1812 00005B70 5DE0            		DC.W	ECHOON			; <  1C - Echo On
    1879   1813 00005B72 5DE8            		DC.W	ECHOFF			; <  1D - Echo Off
    1880   1814 00005B74 5DEE            		DC.W	STERM			; <  1E - Set Terminal Characteristic
    1881   1815 00005B76 5E62            		DC.W	PTERM			; <  1F - Probe Terminal Characteristic
    1882   1816 00005B78 57F0            		DC.W	MERROR			;  > 20 - Response to Terminal Char.
    1883   1817 00005B7A 5EE4            		DC.W	SHNUM			; <  21 - Set Host Number (& # ports)
    1884   1818 00005B7C 5F36            		DC.W	SCLKR			; <  22 - SUP Clock Request (ignored)EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         15-Apr-88  Page   44
Err Source Ref. Address   value
    line   line

    1885   1819 00005B7E 57F0            		DC.W	MERROR			;  > 23 - Sup Clock Data
    1886   1820 00005B80 5F3A            		DC.W	BOK1			; <  24 - Block-output request
    1887   1821 00005B82 57F0            		DC.W	MERROR			;  > 25 - Block-output done
    1888   1822 00005B84 5FC2            		DC.W	BOK2			; <  26 - Block-Input Request
    1889   1823 00005B86 57F0            		DC.W	MERROR			;  > 27 - Bin Done -- Block full
    1890   1824 00005B88 57F0            		DC.W	MERROR			;  > 28 - Bin done --EOT
    1891   1825 00005B8A 57F0            		DC.W	MERROR			;  > 29 - Bin Timeout
    1892   1826 00005B8C 6038            		DC.W	BOK4			; <  2A - Terminate Block-input
    1893   1827 00005B8E 57F0            		DC.W	MERROR			;  > 2B - Response to 2A
    1894   1828 00005B90 6018            		DC.W	BOK3			; <  2C - Terminate Block-output
    1895   1829 00005B92 57F0            		DC.W	MERROR			;  > 2D - Response to 2C
    1896   1830 00005B94 6078            		DC.W	BOK5			; <> 2E - Request/Response Block-IO ports
    1897   1831 00005B96 57F0            		DC.W	MERROR			;  > 2F - Break-begin
    1898   1832 00005B98 57F0            		DC.W	MERROR			;    30 - Illegal
    1899   1833 00005B9A 5C52            		DC.W	SPEC			; <> 31 - Enter Alt. Dev. mode
    1900   1834 00005B9C 5C52            		DC.W	SPEC			; <> 32 - Leave Alt. Dev. mode
    1901   1835 00005B9E 6084            		DC.W	SNTO			; <  33 - Set new timeout
    1902   1836                          	
    1903   1837                          	
    1904   1838                          	
    1905   1839                          	
    1906   1840                          	
    1907   1841                          	*	OMSG 01 - Host Answered/open
    1908   1842 00005BA0 4280            	OPEN	CLR.L	D0			; set OPEN status
    1909   1843 00005BA2 6002            		BRA	OPSHT
    1910   1844                          	
    1911   1845                          	
    1912   1846                          	*	OMSG 02 - Host shut
    1913   1847 00005BA4 7002            	SHUT	MOVE.L	#2,D0			; set SHUT status
    1914   1848 00005BA6 1238 1046       	OPSHT	MOVE.B	HSTAT,D1
    1915   1849 00005BAA 5301            		SUB.B	#1,D1
    1916   1850 00005BAC 661E            		BNE	HST2
    1917   1851 00005BAE 4278 104E       		CLR.W	NPORTS
    1918   1852 00005BB2 6124            	TIMCHK	BSR	TSLOWC
    1919   1853 00005BB4 2238 10D4       		MOVE.L	SLOWC,D1
    1920   1854                          	*	DON'T FLOOD SUP WITH OPEN/SHUT MSGS
    1921   1855 00005BB8 92B8 10D8       		SUB.L	HTM,D1
    1922   1856 00005BBC 6D06            		BLT	HST1
    1923   1857 00005BBE 5181            		SUB.L	#8,D1
    1924   1858 00005BC0 6E02            		BGT	HST1
    1925   1859 00005BC2 60EE            		BRA	TIMCHK
    1926   1860                          	
    1927   1861 00005BC4 6112            	HST1	BSR	TSLOWC
    1928   1862 00005BC6 21F8 10D4 10D8  		MOVE.L	SLOWC,HTM
    1929   1863 00005BCC 11C0 1046       	HST2	MOVE.B	D0,HSTAT		; set new status
    1930   1864 00005BD0 6100 FCFA       		BSR	HREPRT			; report new host status to SUP
    1931   1865 00005BD4 6000 FE70       		BRA	HOSTOUT
    1932   1866                          	
    1933   1867                          	*	ROUTINE TO GET TIME FROM SLOWC
    1934   1868 00005BD8 2078 102E       	TSLOWC	MOVE.L	.SLOWC,A0
    1935   1869 00005BDC 21D0 10D4       		MOVE.L	(A0),SLOWCEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         15-Apr-88  Page   45
Err Source Ref. Address   value
    line   line

    1936   1870 00005BE0 4E75            		RTS
    1937   1871                          	
    1938   1872                          	
    1939   1873                          	*	OMSG 03 - RESET INTERFACE
    1940   1874 00005BE2 6100 FD2A       	RESET	BSR	EMPTY			; empty ISIS input-ring
    1941   1875 00005BE6 6100 FC54       		BSR	HODOWN			; set host down
    1942   1876 00005BEA 11FC 0004 109C  		MOVE.B	#4,DAT1			; set "RESET ACK"
    1943   1877 00005BF0 11FC 0000 109D  		MOVE.B	#DEBUG,DAT2
    1944   1878 00005BF6 31FC 0200 109E  		MOVE.W	#VERSION,DAT3
    1945   1879 00005BFC 6100 F9EE       		BSR.L	WAITDAT			; and send it
    1946   1880 00005C00 6000 FE44       		BRA	HOSTOUT
    1947   1881                          	
    1948   1882                          	
    1949   1883                          	*	OMSG 08 - Apply Backpressure
    1950   1884 00005C04 08EC 0003 0001  	ONBP	BSET	#PF_HBP,P_FLAGS(Rp)	; set host-applied Backpressure
    1951   1885 00005C0A 6600 FE3A       		BNE	HOSTOUT			; ...already has
    1952   1886 00005C0E 08EC 0002 0001  		BSET	#PF_IBP,P_FLAGS(Rp)	; set we've-applied Backpressure
    1953   1887 00005C14 6600 FE30       		BNE	HOSTOUT			; ...already did
    1954   1888 00005C18 6038            		BRA	SPEC			; SPEC does the hard work
    1955   1889                          	
    1956   1890                          	
    1957   1891                          	*	OMSG 09 - Release Backpressure
    1958   1892 00005C1A 08AC 0003 0001  	OFFBP	BCLR	#PF_HBP,P_FLAGS(Rp)	; Clear host-applied Backpressure
    1959   1893 00005C20 6700 FE24       		BEQ	HOSTOUT			; ...already did
    1960   1894 00005C24 4A6C 001E       		TST.W	BCT(Rp)			; anything in buffer?
    1961   1895 00005C28 6600 FE1C       		BNE	HOSTOUT			; yes...we'll do it when buffer flushed
    1962   1896 00005C2C 08AC 0002 0001  		BCLR	#PF_IBP,P_FLAGS(Rp)	; Clear our-applied Backpressure
    1963   1897 00005C32 6700 FE12       		BEQ	HOSTOUT			; ...already did
    1964   1898 00005C36 601A            		BRA	SPEC			; SPEC does the hard work
    1965   1899                          	
    1966   1900                          	
    1967   1901                          	*	OMSG 0B - ZAPPER
    1968   1902 00005C38 4A78 1096       	ZAP	TST.W	PORTNO			; Check port #
    1969   1903 00005C3C 6700 FE08       		BEQ	HOSTOUT			; ignor if port 0
    1970   1904 00005C40 082C 0000 0001  		BTST	#PF_ACT,P_FLAGS(Rp)	; test if port is active
    1971   1905 00005C46 6714            		BEQ	SPEC1			; no
    1972   1906 00005C48 6100 FD70       		BSR	DPORT			; yes...reduce port-count
    1973   1907 00005C4C 6100 FC3E       		BSR	RBTALL			; reset everything for port
    1974   1908 00005C50 600A            		BRA	SPEC1
    1975   1909                          	
    1976   1910                          	
    1977   1911                          	*	OMSGS 08-14,31-32 - VARIOUS ONE-BYTE MESSAGES
    1978   1912 00005C52 082C 0000 0001  	SPEC	BTST	#PF_ACT,P_FLAGS(Rp)	; test if port is active
    1979   1913 00005C58 6700 FDEC       		BEQ	HOSTOUT			; ignor if not
    1980   1914                          	
    1981   1915 00005C5C 4244            	SPEC1	CLR.W	D4
    1982   1916 00005C5E 1838 1080       		MOVE.B	TYPBYT,D4		; message-type
    1983   1917 00005C62 183B 400E       		MOVE.B	SPTAB(PC,D4.W),D4	; get ISIS message-type
    1984   1918 00005C66 3638 1096       		MOVE.W	PORTNO,D3		; for port
    1985   1919 00005C6A 6100 F66E       		BSR	SENDQI			; send Quick ISIS message
    1986   1920 00005C6E 6000 FDD6       		BRA	HOSTOUTEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         15-Apr-88  Page   46
Err Source Ref. Address   value
    line   line

    1987   1921                          	
    1988   1922                          	
    1989   1923                          	
    1990   1924                          	*	CONVERSION TABLE FOR HOST MSGS TO ISIS MSGS
    1991   1925 00005C72 0000 0000       	SPTAB	DC.B	0,0,0,0,0,0,0,0,$0A0,$0A1
    1991   1926 00005C76 0000 0000       	
    1991   1927 00005C7A A0A1            	
    1992   1928 00005C7C A29F A6A7       		DC.B	$0A2,$9F,$0A6,$0A7,$0AA,$0AB,$0AC,$0AD,$0AF,$0A8
    1992   1929 00005C80 AAAB ACAD       	
    1992   1930 00005C84 AFA8            	
    1993   1931 00005C86 A900 0000       		DC.B	$0A9,0,0,0,0,0,0,0,0,0
    1993   1932 00005C8A 0000 0000       	
    1993   1933 00005C8E 0000            	
    1994   1934 00005C90 0000 0000       		DC.B	0,0,0,0,0,0,0,0,0,0
    1994   1935 00005C94 0000 0000       	
    1994   1936 00005C98 0000            	
    1995   1937 00005C9A 0000 0000       		DC.B	0,0,0,0,0,0,0,0,0,$0BC
    1995   1938 00005C9E 0000 0000       	
    1995   1939 00005CA2 00BC            	
    1996   1940 00005CA4 BD00 0000       		DC.B	$0BD,0,0,0,0,0,0,0
    1996   1941 00005CA8 0000 0000       	
    1997   1942                          	
    1998   1943                          	
    1999   1944                          	
    2000   1945                          	*	OMSG 16 - SUPERVISOR REQUEST (for AUX circuit)
    2001   1946 00005CAC 4A78 1056       	SUPREC	TST.W	AUXX			; index into username array
    2002   1947 00005CB0 6D1C            		BLT	SUPR1			; No AUX circuit in progress
    2003   1948 00005CB2 6100 FF24       		BSR	TSLOWC
    2004   1949 00005CB6 2038 10D4       		MOVE.L	SLOWC,D0		; low long since last try?
    2005   1950 00005CBA 90B8 1052       		SUB.L	AUXTIM,D0
    2006   1951 00005CBE 0240 FFE0       		ANDI.W	#-32,D0
    2007   1952 00005CC2 660A            		BNE	SUPR1
    2008   1953 00005CC4 363C 0900       		MOVE.W	#$0900,D3		; last request still in progress
    2009   1954 00005CC8 6126            		BSR	SEND17
    2010   1955 00005CCA 6000 FD7A       		BRA	HOSTOUT
    2011   1956                          	
    2012   1957 00005CCE 4278 1056       	SUPR1	CLR.W	AUXX			; give enable request
    2013   1958 00005CD2 31F8 1096 1050  		MOVE.W	PORTNO,AUXQ		; ...for this port
    2014   1959 00005CD8 4243            		CLR.W	D3			; response = 0
    2015   1960 00005CDA 6114            		BSR	SEND17
    2016   1961 00005CDC 6100 FEFA       		BSR	TSLOWC
    2017   1962 00005CE0 2038 10D4       		MOVE.L	SLOWC,D0
    2018   1963 00005CE4 21C0 1052       		MOVE.L	D0,AUXTIM
    2019   1964 00005CE8 6100 F93C       		BSR	PUTIFC
    2020   1965 00005CEC 6000 FD58       		BRA	HOSTOUT
    2021   1966                          	
    2022   1967                          	
    2023   1968 00005CF0 11FC 0017 109C  	SEND17	MOVE.B	#$17,DAT1		; send SUP response
    2024   1969 00005CF6 11F8 1097 109D  		MOVE.B	PORTNO+1,DAT2
    2025   1970 00005CFC 31C3 109E       		MOVE.W	D3,DAT3
    2026   1971 00005D00 6100 F8EA       		BSR	WAITDAT			; wait, then write DAT into hostEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         15-Apr-88  Page   47
Err Source Ref. Address   value
    line   line

    2027   1972 00005D04 4E75            		RTS
    2028   1973                          	
    2029   1974                          	*	OMSG 18 - SUPERVISOR LOGIN CHAR
    2030   1975 00005D06 3038 1096       	SUPLOG	MOVE.W	PORTNO,D0		; port number
    2031   1976 00005D0A B078 1050       		CMP.W	AUXQ,D0			; request for valid port?
    2032   1977 00005D0E 6600 FD36       		BNE	HOSTOUT			; no...ignor
    2033   1978 00005D12 41F8 1058       		LEA	AUXC,A0			; yes...set start-address of user-string
    2034   1979 00005D16 3038 1056       		MOVE.W	AUXX,D0			; get index for next char
    2035   1980 00005D1A D0C0            		ADD.W	D0,A0
    2036   1981 00005D1C 1238 109E       		MOVE.B	DAT3,D1
    2037   1982 00005D20 0001 0080       		OR.B	#$80,D1			; set high-order bit
    2038   1983 00005D24 1081            		MOVE.B	D1,(A0)			; save the character
    2039   1984 00005D26 5240            		ADD.W	#1,D0			; advance index
    2040   1985 00005D28 0240 003F       		AND.W	#$3F,D0			; wrap it if too long
    2041   1986 00005D2C 31C0 1056       		MOVE.W	D0,AUXX			; save copy
    2042   1987 00005D30 0C01 00BB       		CMPI.B	#$BB,D1			; SEMICOLON?
    2043   1988 00005D34 6708            		BEQ	SUPOUT
    2044   1989 00005D36 0C01 008D       		CMPI.B	#$8D,D1			; CARRIAGE RETURN?
    2045   1990 00005D3A 6600 FD0A       		BNE	HOSTOUT			; no...not done yet
    2046   1991 00005D3E 0640 000B       	SUPOUT	ADD.W	#$0B,D0			; done...pass to Sup
    2047   1992 00005D42 6100 F50A       		BSR	WAITIS			; wait for space to send message
    2048   1993 00005D46 4243            		CLR.W	D3			; to Port 0
    2049   1994 00005D48 7808            		MOVEQ	#8,D4			; Request AUX Circuit
    2050   1995 00005D4A 6100 F514       		BSR	SLOR
    2051   1996 00005D4E 4200            		CLR.B	D0			; padding (B)
    2052   1997 00005D50 6100 F52A       		BSR	PUTCH
    2053   1998 00005D54 3038 1096       		MOVE.W	PORTNO,D0		; Local Key = portnumber (HW)
    2054   1999 00005D58 6100 F54E       		BSR	PUTH
    2055   2000 00005D5C 4240            		CLR.W	D0			; No IIX (HW)
    2056   2001 00005D5E 6100 F548       		BSR	PUTH
    2057   2002 00005D62 3038 1042       		MOVE.W	HOSTN,D0		; Orig. Host (HW)
    2058   2003 00005D66 6100 F540       		BSR	PUTH
    2059   2004 00005D6A 3438 1056       		MOVE.W	AUXX,D2			; size of name
    2060   2005 00005D6E 1002            		MOVE.B	D2,D0			; size (B)
    2061   2006 00005D70 6100 F50A       		BSR	PUTCH
    2062   2007 00005D74 43F8 1058       		LEA	AUXC,A1			; address of first byte
    2063   2008 00005D78 1019            	SUPLOP	MOVE.B	(A1)+,D0		; next byte of string
    2064   2009 00005D7A 6100 F500       		BSR	PUTCH
    2065   2010 00005D7E 5342            		SUB.W	#1,D2
    2066   2011 00005D80 6EF6            		BGT	SUPLOP
    2067   2012 00005D82 6100 F544       		BSR	ELOR			; end request
    2068   2013 00005D86 6000 FCBE       		BRA	HOSTOUT
    2069   2014                          	
    2070   2015                          	
    2071   2016                          	*	OMSG 19 - TEST PATTERN PROBE
    2072   2017 00005D8A 11FC 001A 109C  	TP	MOVE.B	#$1A,DAT1		; Test-pattern Response
    2073   2018 00005D90 4238 109D       		CLR.B	DAT2
    2074   2019 00005D94 6100 F858       		BSR	WRDAT			; write DAT into host
    2075   2020 00005D98 6100 F6AE       		BSR	RDPDP
    2076   2021 00005D9C 6100 F854       		BSR	WRPDP			; copy next word too
    2077   2022 00005DA0 6100 F884       		BSR	PUTIFC			; mark it as doneEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         15-Apr-88  Page   48
Err Source Ref. Address   value
    line   line

    2078   2023 00005DA4 6000 FCA0       		BRA	HOSTOUT
    2079   2024                          	
    2080   2025                          	
    2081   2026                          	*	OMSGS 1B - HOST SAD
    2082   2027 00005DA8 6100 F69E       	HSTSAD	BSR	RDPDP			; get next word
    2083   2028 00005DAC 4841            		SWAP	D1			; d3/d4 to low half
    2084   2029 00005DAE 700A            		MOVEQ	#10,D0			; need 10d bytes of space
    2085   2030 00005DB0 6100 F49C       		BSR	WAITIS			; wait for room in ring
    2086   2031 00005DB4 4243            		CLR.W	D3			; Port 0 --
    2087   2032 00005DB6 7803            		MOVEQ	#3,D4			; Type 3 (diagnostic)
    2088   2033 00005DB8 6100 F4A6       		BSR	SLOR
    2089   2034 00005DBC 4200            		CLR.B	D0			; Padding
    2090   2035 00005DBE 6100 F4BC       		BSR	PUTCH
    2091   2036 00005DC2 3001            		MOVE.W	D1,D0			; data2 (HW)
    2092   2037 00005DC4 6100 F4E2       		BSR	PUTH
    2093   2038 00005DC8 303C 1000       		MOVE.W	#$1000,D0		; Rtype 10 | 0 (B | B)
    2094   2039 00005DCC 6100 F4DA       		BSR	PUTH
    2095   2040 00005DD0 103C 0091       		MOVE.B	#PRODID,D0		; ProductID
    2096   2041 00005DD4 6100 F4A6       		BSR	PUTCH
    2097   2042 00005DD8 6100 F4EE       		BSR	ELOR			; send it on
    2098   2043 00005DDC 6000 FC68       		BRA	HOSTOUT
    2099   2044                          	
    2100   2045                          	
    2101   2046                          	*	OMSGS 1C & 1D - ECHO ON/OFF
    2102   2047 00005DE0 31FC 0001 109E  	ECHOON	MOVE.W	#1,DAT3			; subtype = 0, value = 1
    2103   2048 00005DE6 600E            		BRA	STERM1
    2104   2049                          	
    2105   2050 00005DE8 4278 109E       	ECHOFF	CLR.W	DAT3			; subtype=0, value = 0
    2106   2051 00005DEC 6008            		BRA	STERM1
    2107   2052                          	
    2108   2053                          	
    2109   2054                          	*	OMSG 1E - SET TERMINAL CHARACTERISTICS
    2110   2055 00005DEE 4A38 109E       	STERM	TST.B	DAT3			; check message subtype
    2111   2056 00005DF2 6D00 F9FC       		BLT	MERROR			; range check
    2112   2057                          	
    2113   2058 00005DF6 082C 0000 0001  	STERM1	BTST	#PF_ACT,P_FLAGS(Rp)	; test if port is active
    2114   2059 00005DFC 6700 FC48       		BEQ	HOSTOUT			; ignor request for inactive ports
    2115   2060 00005E00 0C38 0013 109F  		CMP.B	#$13,DAT4
    2116   2061 00005E06 6E00 F9E8       		BGT	MERROR			; range check
    2117   2062 00005E0A 7008            		MOVEQ	#8,D0
    2118   2063 00005E0C 6100 F440       		BSR	WAITIS			; wait for space in ring
    2119   2064 00005E10 0C38 0005 109E  		CMP.B	#5,DAT3			; special handling for input baud rate
    2120   2065 00005E16 660A            		BNE	STERM2			; skip if not
    2121   2066 00005E18 1978 109F 0003  		MOVE.B	DAT4,IBRATE(Rp)		; save new input baud-rate
    2122   2067 00005E1E 6100 00A6       		BSR.L	PTMSN1			; turn around and Acknowledge it
    2123   2068 00005E22 3638 1096       	STERM2	MOVE.W	PORTNO,D3		; port #
    2124   2069 00005E26 183C 00B1       		MOVE.B	#$B1,D4			; Type-byte
    2125   2070 00005E2A 6100 F434       		BSR	SLOR
    2126   2071 00005E2E 1038 109E       		MOVE.B	DAT3,D0			; sub-type
    2127   2072 00005E32 0C00 000F       		CMP.B	#$0F,D0
    2128   2073 00005E36 6602            		BNE	NOJAP1EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         15-Apr-88  Page   49
Err Source Ref. Address   value
    line   line

    2129   2074 00005E38 5200            		ADD.B	#1,D0			; translate subtype 15d to subtype 16d
    2130   2075 00005E3A 6100 F440       	NOJAP1	BSR	PUTCH
    2131   2076 00005E3E 1038 109F       		MOVE.B	DAT4,D0			; value
    2132   2077 00005E42 6712            		BEQ	STERM3			; 0 is OK
    2133   2078 00005E44 223C 0007 719F  		MOVE.L	#$0007719F,D1		; check for single-bit use
    2134   2079 00005E4A 1438 109E       		MOVE.B	DAT3,D2			; subtype
    2135   2080 00005E4E 0501            		BTST	D2,D1
    2136   2081 00005E50 6704            		BEQ	STERM3			; multi-bit..use value
    2137   2082 00005E52 103C 00FF       		MOVE.B	#-1,D0			; set whole byte to 1's
    2138   2083 00005E56 6100 F424       	STERM3	BSR	PUTCH
    2139   2084 00005E5A 6100 F46C       		BSR	ELOR
    2140   2085 00005E5E 6000 FBE6       		BRA	HOSTOUT
    2141   2086                          	
    2142   2087                          	
    2143   2088                          	
    2144   2089                          	
    2145   2090                          	*	OMSG 1F - PROBE TERMINAL CHARACTERISTICS
    2146   2091 00005E62 082C 0000 0001  	PTERM	BTST	#PF_ACT,P_FLAGS(Rp)	; test if port is active
    2147   2092 00005E68 6700 FBDC       		BEQ	HOSTOUT			; ignor for inactive ports
    2148   2093 00005E6C 1438 109E       		MOVE.B	DAT3,D2			; get request sub-type
    2149   2094 00005E70 6D00 FBD4       		BLT	HOSTOUT			; range-check
    2150   2095 00005E74 0C02 003F       		CMP.B	#63,D2			; special "probe all"?
    2151   2096 00005E78 6712            		BEQ	PTALL			; skip if so
    2152   2097 00005E7A 0C02 0013       		CMP.B	#$13,D2			; range-check
    2153   2098 00005E7E 6E00 FBC6       		BGT	HOSTOUT			; ignore out of range requests
    2154   2099 00005E82 6118            		BSR	PTMSND			; else send request
    2155   2100 00005E84 6100 F7A0       		BSR	PUTIFC			; clean up
    2156   2101 00005E88 6000 FBBC       		BRA	HOSTOUT
    2157   2102                          	
    2158   2103                          	*	Special case for "probe all"
    2159   2104 00005E8C 7413            	PTALL	MOVEQ	#$13,D2			; set counter
    2160   2105 00005E8E 610C            	PTAL2	BSR	PTMSND			; send another request
    2161   2106 00005E90 5302            		SUB.B	#1,D2
    2162   2107 00005E92 6CFA            		BGE	PTAL2			; ...until done
    2163   2108 00005E94 6100 F790       		BSR	PUTIFC			; clean up
    2164   2109 00005E98 6000 FBAC       		BRA	HOSTOUT
    2165   2110                          	
    2166   2111                          	*	Process one request
    2167   2112                          	*	D2 = sub-type
    2168   2113 00005E9C 0C02 0005       	PTMSND	CMP.B	#5,D2			; subtype 5?
    2169   2114 00005EA0 6724            		BEQ	PTMSN1			; fake out input baud rate request
    2170   2115 00005EA2 6100 F3A2       		BSR	WAITISW			; insure space in ring
    2171   2116 00005EA6 3638 1096       		MOVE.W	PORTNO,D3		; port number
    2172   2117 00005EAA 183C 00B0       		MOVE.B	#$B0,D4			; type = query parameter
    2173   2118 00005EAE 6100 F3B0       		BSR	SLOR
    2174   2119 00005EB2 1002            		MOVE.B	D2,D0
    2175   2120 00005EB4 0C00 000F       		CMP.B	#$0F,D0
    2176   2121 00005EB8 6602            		BNE	NOJAP2
    2177   2122 00005EBA 5200            		ADD.B	#1,D0			; type 15d translated to type 16d
    2178   2123 00005EBC 6100 F3BE       	NOJAP2	BSR	PUTCH			; subtype
    2179   2124 00005EC0 6100 F406       		BSR	ELOREBUS02.J00/X               E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         15-Apr-88  Page   50
Err Source Ref. Address   value
    line   line

    2180   2125 00005EC4 4E75            		RTS
    2181   2126                          	
    2182   2127                          	*	Report input baud rate
    2183   2128 00005EC6 11FC 0020 109C  	PTMSN1	MOVE.B	#$20,DAT1
    2184   2129 00005ECC 11F8 1097 109D  		MOVE.B	PORTNO+1,DAT2
    2185   2130 00005ED2 11FC 0005 109E  		MOVE.B	#5,DAT3			; sub-type = input baud rate
    2186   2131 00005ED8 11EC 0003 109F  		MOVE.B	IBRATE(Rp),DAT4		; rate
    2187   2132 00005EDE 6100 F70E       		BSR	WRDAT			; send DAT to host
    2188   2133 00005EE2 4E75            		RTS
    2189   2134                          	
    2190   2135                          	
    2191   2136                          	
    2192   2137                          	*	OMSG 21 - SET HOST NUMBER
    2193   2138 00005EE4 7801            	SHNUM	MOVEQ	#1,D4			; assume host going down
    2194   2139 00005EE6 4281            		CLR.L	D1
    2195   2140 00005EE8 1238 109E       		MOVE.B	DAT3,D1
    2196   2141 00005EEC B278 1042       		CMP.W	HOSTN,D1		; is host number being changed?
    2197   2142 00005EF0 660A            		BNE	SHNUM1			; Skip if so
    2198   2143 00005EF2 3438 1096       		MOVE.W	PORTNO,D2		; port number = number of ports
    2199   2144 00005EF6 B478 1044       		CMP.W	HOSTP,D2		; did it change?
    2200   2145 00005EFA 6702            		BEQ	SHNUM2			; skip if not
    2201   2146                          	
    2202   2147 00005EFC 7803            	SHNUM1	MOVEQ	#3,D4			; host or number of ports changed
    2203   2148                          	*					 ...Tell SUP Host is Gone
    2204   2149 00005EFE 6100 F942       	SHNUM2	BSR	HDOWN			; make host change
    2205   2150 00005F02 4282            		CLR.L	D2
    2206   2151 00005F04 1438 109E       		MOVE.B	DAT3,D2
    2207   2152 00005F08 31C2 1042       		MOVE.W	D2,HOSTN		; update host number
    2208   2153 00005F0C 1438 109D       		MOVE.B	DAT2,D2			; port number = number of ports
    2209   2154 00005F10 6602            		BNE	SHNUM3
    2210   2155 00005F12 7430            		MOVEQ	#48,D2			; 0 defaults to 48
    2211   2156 00005F14 0C42 00FE       	SHNUM3	CMP.W	#MAXPORT-2,D2
    2212   2157 00005F18 6F04            		BLE	SHNUM4
    2213   2158 00005F1A 343C 00FE       		MOVE.W	#MAXPORT-2,D2		; we do not use port 0 or $FF
    2214   2159 00005F1E 31C2 1044       	SHNUM4	MOVE.W	D2,HOSTP		; number of host ports
    2215   2160 00005F22 5742            		SUB.W	#3,D2
    2216   2161 00005F24 31C2 104C       		MOVE.W	D2,MXPORT		; maximum port number
    2217   2162 00005F28 11FC 0002 1046  		MOVE.B	#2,HSTAT		; set host shut
    2218   2163 00005F2E 6100 F99C       		BSR	HREPRT			; and report it
    2219   2164 00005F32 6000 FB12       		BRA	HOSTOUT
    2220   2165                          	
    2221   2166                          	
    2222   2167                          	*	OMSG 22 - SUP CLOCK REQUEST
    2223   2168 00005F36 6000 FB0E       	SCLKR	BRA	HOSTOUT			; ignor for now
    2224   2169                          	
    2225   2170                          	
    2226   2171                          	
    2227   2172                          	*	OMSGS 24,26,2A,2C,2E (BLOCK I/O)
    2228   2173                          	
    2229   2174                          	*	---24---	REQ FOR BLOCK OUTPUT
    2230   2175                          	*	Block output is simple...each Bout request is independent.EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         15-Apr-88  Page   51
Err Source Ref. Address   value
    line   line

    2231   2176                          	*	We transmit the block of data, and report it's transmission,
    2232   2177                          	*	thereby ending that request.
    2233   2178 00005F3A 31F8 109E 10F8  	BOK1	MOVE.W	DAT3,SAVE1		; save TCN value
    2234   2179 00005F40 6100 F506       		BSR	RDPDP			; get address
    2235   2180 00005F44 E089            		LSR.L	#8,D1
    2236   2181 00005F46 082C 0000 0001  		BTST	#PF_ACT,P_FLAGS(Rp)	; test if port is active
    2237   2182 00005F4C 6700 FAF8       		BEQ	HOSTOUT			; no...ignore request
    2238   2183 00005F50 08EC 0004 0001  		BSET	#PF_BKO,P_FLAGS(Rp)	; set and test block output in progress
    2239   2184 00005F56 6600 FAEE       		BNE	HOSTOUT			; was already set
    2240   2185 00005F5A 3078 10F0       		MOVE.W	BLKFREE,A0		; wasn't set...get an entry off free-list
    2241   2186 00005F5E 31D0 10F0       		MOVE.W	(A0),BLKFREE		; unlink from free-list
    2242   2187 00005F62 30B8 10F4       		MOVE.W	BKOHEAD,(A0)		; link list-head to element
    2243   2188 00005F66 3178 1096 0002  		MOVE.W	PORTNO,2(A0)		; second word is port-number
    2244   2189 00005F6C 31C8 10F4       		MOVE.W	A0,BKOHEAD		; place this element as new list-head
    2245   2190 00005F70 2941 0004       		MOVE.L	D1,BO_TAR(Rp)		; TAR value
    2246   2191 00005F74 3978 10F8 000A  		MOVE.W	SAVE1,BO_TCN(Rp)	; TCN value
    2247   2192 00005F7A 426C 0008       		CLR.W	BO_BYT(Rp)		; BYT = 0
    2248   2193 00005F7E 6000 FAC6       		BRA	HOSTOUT
    2249   2194                          	
    2250   2195                          	
    2251   2196                          	*	Reset Block-output
    2252   2197 00005F82 08AC 0004 0001  	RBTBKO	BCLR	#PF_BKO,P_FLAGS(Rp)	; clear Block-Output
    2253   2198 00005F88 6722            		BEQ	LNKEND			; exit if not set
    2254   2199 00005F8A 43F8 10F4       		LEA	BKOHEAD,A1		; was set...search for entry in list
    2255   2200                          	
    2256   2201 00005F8E 4280            	UNLINK	CLR.L	D0
    2257   2202 00005F90 2049            	LNKLOP	MOVE.L	A1,A0			; copy NEXT to Current
    2258   2203 00005F92 3010            		MOVE.W	(A0),D0			; get address of next element
    2259   2204 00005F94 6716            		BEQ	LNKEND			; null...list exhausted
    2260   2205 00005F96 2240            		MOVE.L	D0,A1			; ok...set address
    2261   2206 00005F98 3029 0002       		MOVE.W	2(A1),D0		; get NEXT port
    2262   2207 00005F9C B078 1096       		CMP.W	PORTNO,D0		; is NEXT correct element?
    2263   2208 00005FA0 66EE            		BNE	LNKLOP			; no
    2264   2209 00005FA2 3091            		MOVE.W	(A1),(A0)		; found match...unlink (NEXT) element
    2265   2210 00005FA4 32B8 10F0       		MOVE.W	BLKFREE,(A1)		; link element to free-list
    2266   2211 00005FA8 31C9 10F0       		MOVE.W	A1,BLKFREE		; ...and make it new free-list head
    2267   2212 00005FAC 4E75            	LNKEND	RTS
    2268   2213                          	
    2269   2214                          	
    2270   2215                          	*	Reset Block-input
    2271   2216 00005FAE 08AC 0005 0001  	RBTBKI	BCLR	#PF_BKI,P_FLAGS(Rp)	; clear Block-input active
    2272   2217 00005FB4 67F6            		BEQ	LNKEND			; not set...just exit
    2273   2218 00005FB6 43F8 10F2       		LEA	BKIHEAD,A1		; set address of list-head
    2274   2219 00005FBA 60D2            		BRA	UNLINK			; unlink entry from this list
    2275   2220                          	
    2276   2221                          	
    2277   2222                          	*	Reset BUFfer
    2278   2223 00005FBC 43F8 10F6       	RBTBUF	LEA	BUFHEAD,A1		; set address of list-head
    2279   2224 00005FC0 60CC            		BRA	UNLINK			; unlink entry from this list
    2280   2225                          	
    2281   2226                          	EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         15-Apr-88  Page   52
Err Source Ref. Address   value
    line   line

    2282   2227                          	*	---26---	BLOCK INPUT REQUEST
    2283   2228                          	*	Block input is more complicated...each Bin request may start
    2284   2229                          	*	a series, OR continue an already-started sequence.  It is terminated
    2285   2230                          	*	by a Terminate-Block-Input request;  until that is received, we must
    2286   2231                          	*	buffer any data received after the last Bin service.
    2287   2232 00005FC2 08EC 0005 0001  	BOK2	BSET	#PF_BKI,P_FLAGS(Rp)	; set Block-input active
    2288   2233 00005FC8 6618            		BNE	BOK22			; already set...don't do it again
    2289   2234 00005FCA 61F0            		BSR	RBTBUF			; wasn't set...insure buffer not on list
    2290   2235 00005FCC 3078 10F0       		MOVE.W	BLKFREE,A0		; get an entry off free-list
    2291   2236 00005FD0 31D0 10F0       		MOVE.W	(A0),BLKFREE		; unlink from free-list
    2292   2237 00005FD4 30B8 10F2       		MOVE.W	BKIHEAD,(A0)		; link block-input list to this element
    2293   2238 00005FD8 3178 1096 0002  		MOVE.W	PORTNO,2(A0)		; install the port number
    2294   2239 00005FDE 31C8 10F2       		MOVE.W	A0,BKIHEAD		; install element as new list-head
    2295   2240                          	
    2296   2241 00005FE2 08AC 0006 0001  	BOK22	BCLR	#PF_BFD,P_FLAGS(Rp)	; clear Block FilleD
    2297   2242 00005FE8 3978 109E 0014  		MOVE.W	DAT3,BI_TCN(Rp)
    2298   2243 00005FEE 6100 F458       		BSR	RDPDP
    2299   2244 00005FF2 E089            		LSR.L	#8,D1
    2300   2245 00005FF4 2941 0010       		MOVE.L	D1,BI_TAR(Rp)
    2301   2246 00005FF8 426C 0016       		CLR.W	BI_LCN(Rp)
    2302   2247 00005FFC 426C 0018       		CLR.W	BI_BYT(Rp)
    2303   2248 00006000 2478 1032       		MOVE.L	.FASTC,A2		; record current time
    2304   2249 00006004 2952 000C       		MOVE.L	(A2),BI_TIM(Rp)
    2305   2250 00006008 4A2C 001E       		TST.B	BCT(Rp)			; anything already in buffer?
    2306   2251 0000600C 6700 FA38       		BEQ	HOSTOUT			; no
    2307   2252 00006010 6100 0914       		BSR.L	BU_BK			; yes...try to empty the buffer
    2308   2253 00006014 6000 FA30       		BRA	HOSTOUT			; then quit
    2309   2254                          	
    2310   2255                          	
    2311   2256                          	*	---2A---	TERMINATE BLOCK OUTPUT
    2312   2257 00006018 11FC 002D 109C  	BOK3	MOVE.B	#$2D,DAT1		; acknowledge request
    2313   2258 0000601E 6104            		BSR	BKOTERM			; send termination
    2314   2259 00006020 6000 FA24       		BRA	HOSTOUT
    2315   2260                          	
    2316   2261                          	
    2317   2262                          	*	Terminate Block-output -- DAT1 = reason
    2318   2263 00006024 11F8 1097 109D  	BKOTERM	MOVE.B	PORTNO+1,DAT2		; build message
    2319   2264 0000602A 6100 F5C0       		BSR	WAITDAT			; wait, then write DAT into host
    2320   2265 0000602E 6100 F5F6       		BSR	PUTIFC
    2321   2266 00006032 6100 FF4E       		BSR	RBTBKO			; cancel block-output
    2322   2267 00006036 4E75            		RTS
    2323   2268                          	
    2324   2269                          	
    2325   2270                          	
    2326   2271                          	
    2327   2272                          	*	---2C---	TERMINATE BLOCK INPUT
    2328   2273 00006038 11FC 002B 109C  	BOK4	MOVE.B	#$2B,DAT1
    2329   2274 0000603E 6118            		BSR	BKITERM			; send termination-message
    2330   2275 00006040 6100 FF6C       		BSR.L	RBTBKI			; reset Block-input
    2331   2276 00006044 6100 0800       		BSR.L	BU_RG			; attempt to flush buffer
    2332   2277 00006048 4A6C 001E       		TST.W	BCT(Rp)			; anything left there?EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         15-Apr-88  Page   53
Err Source Ref. Address   value
    line   line

    2333   2278 0000604C 6700 F9F8       		BEQ	HOSTOUT			; no...we're done
    2334   2279 00006050 6100 08BC       		BSR.L	BU_ADD			; yes...insure it will be flushed
    2335   2280 00006054 6000 F9F0       		BRA	HOSTOUT			; and quit
    2336   2281                          	
    2337   2282                          	
    2338   2283                          	*	Terminate Block-input -- Reason in DAT1
    2339   2284 00006058 11F8 1097 109D  	BKITERM	MOVE.B	PORTNO+1,DAT2		; set up message
    2340   2285 0000605E 31EC 0016 109E  		MOVE.W	BI_LCN(Rp),DAT3		; # of characters sent
    2341   2286 00006064 426C 0016       		CLR.W	BI_LCN(Rp)		; ...and reset count
    2342   2287 00006068 6100 F582       		BSR	WAITDAT			; wait, then write DAT into host
    2343   2288 0000606C 6100 F5B8       		BSR	PUTIFC
    2344   2289 00006070 08EC 0006 0001  		BSET	#PF_BFD,P_FLAGS(Rp)	; set Block FilleD
    2345   2290 00006076 4E75            		RTS
    2346   2291                          	
    2347   2292                          	
    2348   2293                          	*	---2E---	REQ FOR BLK I/O PORTS
    2349   2294 00006078 6100 F572       	BOK5	BSR	WAITDAT			; wait, then return DAT into host
    2350   2295 0000607C 6100 F5A8       		BSR	PUTIFC
    2351   2296 00006080 6000 F9C4       		BRA	HOSTOUT
    2352   2297                          	
    2353   2298                          	
    2354   2299                          	*	OMSG $33 - Set New timeout value
    2355   2300 00006084 31F8 109E 1048  	SNTO	MOVE.W	DAT3,HOSTTO		; set new value
    2356   2301 0000608A 31F8 109E 104A  		MOVE.W	DAT3,TOHOST		; ...and how long we'll wait
    2357   2302 00006090 6000 F9B4       		BRA	HOSTOUT			; that's all there is to this one...



    2359   2304                          		TTL	'E B U S  --  PDP-10 Base Code,		I S I S   I N P U T'EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           15-Apr-88  Page   54
Err Source Ref. Address   value
    line   line

    2361   2306                          	*		I S I S   R I N G   I N P U T
    2362   2307                          	
    2363   2308                          	
    2364   2309                          	
    2365   2310                          	
    2366   2311                          	*	Convenient Exit routines
    2367   2312                          	
    2368   2313                          	*	Place port number at DAT2 and send DAT to host
    2369   2314 00006094 11F8 1097 109D  	PUTPN	MOVE.B	PORTNO+1,DAT2		; place port number
    2370   2315                          	
    2371   2316                          	*	send DAT to host
    2372   2317 0000609A 6100 F552       	SENDDAT	BSR	WRDAT
    2373   2318                          	
    2374   2319                          	*	all routines exit to here to clean up
    2375   2320 0000609E 6100 F2B6       	CLEANUP	BSR	ELIR
    2376   2321 000060A2 6006            		BRA	ISISIN
    2377   2322                          	
    2378   2323                          	
    2379   2324                          	*	flush message...length in D2
    2380   2325 000060A4 3002            	INRGFL	MOVE.W	D2,D0			; copy length
    2381   2326 000060A6 6100 F2A8       		BSR	FLUSH			; ...and flush it
    2382   2327                          	
    2383   2328                          	*	INPUT TO PDP RING FROM ISIS RING
    2384   2329 000060AA 4A38 1081       	ISISIN	TST.B	HTDWN
    2385   2330 000060AE 6600 057C       		BNE.L	VERIFY			; Host not up, try Half-second logic
    2386   2331 000060B2 6100 F572       		BSR	PUTIFC
    2387   2332 000060B6 3238 10E4       		MOVE.W	IRRN,D1			; time to throttle input?
    2388   2333 000060BA B278 1036       		CMP.W	IRSIZE,D1
    2389   2334 000060BE 6E00 056C       		BGT.L	VERIFY			; yes
    2390   2335 000060C2 6100 F21E       		BSR	LOOK			; no...anything in ISIS ring?
    2391   2336 000060C6 6700 0564       		BEQ.L	VERIFY			; No...go do Half-second stuff
    2392   2337 000060CA 31C4 1094       		MOVE.W	D4,INTYBT		; yes...save input Type-byte
    2393   2338 000060CE 6100 F584       		BSR	FDRGSZ			; compute INRGSP
    2394   2339                          	
    2395   2340                          	*	Distinguish between Needles, Port-0, data, and control
    2396   2341 000060D2 3238 1094       		MOVE.W	INTYBT,D1		; get Type byte
    2397   2342 000060D6 6700 0142       		BEQ.L	NEEDLE			; special processing for needles
    2398   2343 000060DA 3038 1096       		MOVE.W	PORTNO,D0		; port 0?
    2399   2344 000060DE 6700 0482       		BEQ.L	IPZ			; special processing for port 0
    2400   2345 000060E2 0C41 009E       		CMP.W	#$9E,D1			; data?
    2401   2346 000060E6 6C00 0256       		BGE.L	IMESS			; Special processing if not
    2402   2347                          	
    2403   2348                          	*	We have a data-message to process
    2404   2349 000060EA 4A6C 001E       		TST.W	BCT(Rp)			; is anything already buffered?
    2405   2350 000060EE 6670            		BNE	IS_BU			; add to buffer if so
    2406   2351 000060F0 082C 0005 0001  		BTST	#PF_BKI,P_FLAGS(Rp)	; is Block-input active?
    2407   2352 000060F6 6600 00A6       		BNE.L	BLOKIN			; skip if block-input in progress
    2408   2353 000060FA 082C 0003 0001  		BTST	#PF_HBP,P_FLAGS(Rp)	; has host applied back-pressure?
    2409   2354 00006100 6654            		BNE	IS_BUF			; skip to place in buffer if so
    2410   2355 00006102 3638 1092       		MOVE.W	INRGSP,D3		; space in ringEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           15-Apr-88  Page   55
Err Source Ref. Address   value
    line   line

    2411   2356 00006106 674E            		BEQ	IS_BUF			; skip to place in buffer if none
    2412   2357 00006108 5543            		SUBQ	#2,D3			; allow for header
    2413   2358                          	
    2414   2359                          	*	Limit ourself to 30-byte messages to host
    2415   2360 0000610A 0C43 001E       		CMP.W	#30,D3			; ring-space > 30 chars?
    2416   2361 0000610E 6F04            		BLE	ISISIN1			; less...normal processing
    2417   2362 00006110 363C 001E       		MOVE.W	#30,D3			; yes...make ring-space = 30
    2418   2363                          	
    2419   2364 00006114 B641            	ISISIN1	CMP.W	D1,D3			; ring < MSG length?
    2420   2365 00006116 6F02            		BLE	ISISIN2			; yes
    2421   2366 00006118 3601            		MOVE.W	D1,D3			; message-length is number to move
    2422   2367                          	
    2423   2368 0000611A 11C3 109C       	ISISIN2	MOVE.B	D3,DAT1			; New type-byte
    2424   2369 0000611E 0038 0080 109C  		OR.B	#$80,DAT1		; Header is text length + $80
    2425   2370 00006124 11F8 1097 109D  		MOVE.B	PORTNO+1,DAT2		; set output port number
    2426   2371 0000612A 41F8 109E       		LEA	DAT3,A0			; where to begin placing the characters
    2427   2372 0000612E 6100 F1D2       	ISISIN3	BSR	GETCH			; copy chars
    2428   2373 00006132 10C0            		MOVE.B	D0,(A0)+
    2429   2374 00006134 5378 1094       		SUB.W	#1,INTYBT
    2430   2375 00006138 5343            		SUB.W	#1,D3			; done yet?
    2431   2376 0000613A 6EF2            		BGT	ISISIN3			; no
    2432   2377 0000613C 43F8 109C       		LEA	DAT,A1			; set up transmit cursor
    2433   2378                          	
    2434   2379 00006140 2219            	ISISIN4	MOVE.L	(A1)+,D1		; write DAT into host
    2435   2380 00006142 6100 F4AE       		BSR	WRPDP
    2436   2381 00006146 B0C9            		CMPA	A1,A0
    2437   2382 00006148 6EF6            		BGT	ISISIN4			; repeat for entire message
    2438   2383 0000614A 4A78 1094       		TST.W	INTYBT			; have we split data?
    2439   2384 0000614E 6700 FF4E       		BEQ	CLEANUP			; no...finish message and on to next
    2440   2385 00006152 6100 F4D2       		BSR	PUTIFC			; yes...insure host sees it...buffer rest
    2441   2386                          	
    2442   2387                          	
    2443   2388                          	
    2444   2389                          	*	Buffer data because host said to...or because we split a message
    2445   2390 00006156 4A6C 001E       	IS_BUF	TST.W	BCT(Rp)			; anything already there?
    2446   2391 0000615A 6604            		BNE	IS_BU			; yes...just go do it
    2447   2392 0000615C 6100 07B0       		BSR.L	BU_ADD			; no...add this port to list
    2448   2393                          	
    2449   2394                          	*	Move ISIS message to buffer
    2450   2395 00006160 3038 1094       	IS_BU	MOVE.W	INTYBT,D0
    2451   2396 00006164 D06C 001E       		ADD.W	BCT(Rp),D0		; calculate amount to be in buffer
    2452   2397 00006168 B078 10E2       		CMP.W	BKPR,D0			; time to set back-pressure?
    2453   2398 0000616C 6D14            		BLT	IS_BU1			; not yet
    2454   2399 0000616E 08EC 0002 0001  		BSET	#PF_IBP,P_FLAGS(Rp)	; set back-pressure applied
    2455   2400 00006174 660C            		BNE	IS_BU1			; already was set
    2456   2401 00006176 3638 1096       		MOVE.W	PORTNO,D3		; for port
    2457   2402 0000617A 183C 00A0       		MOVE.B	#$A0,D4			; apply back-pressure
    2458   2403 0000617E 6100 F15A       		BSR	SENDQI			; send Quick ISIS message
    2459   2404 00006182 6100 F17E       	IS_BU1	BSR	GETCH			; copy char to buffer
    2460   2405 00006186 6100 F5AA       		BSR	DWCI
    2461   2406 0000618A 0C00 001B       		CMP.B	#ESC,D0			; escape code?EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           15-Apr-88  Page   56
Err Source Ref. Address   value
    line   line

    2462   2407 0000618E 6604            		BNE	IS_BU2			; no
    2463   2408 00006190 6100 F5A0       		BSR	DWCI			; yes...escape it
    2464   2409 00006194 5378 1094       	IS_BU2	SUB.W	#1,INTYBT
    2465   2410 00006198 6EE8            		BGT	IS_BU1
    2466   2411 0000619A 6000 FF02       		BRA	CLEANUP			; finish this message and do next
    2467   2412                          	
    2468   2413                          	
    2469   2414                          	*	BLOCK-INPUT
    2470   2415 0000619E 082C 0006 0001  	BLOKIN	BTST	#PF_BFD,P_FLAGS(Rp)	; was Block FilleD?
    2471   2416 000061A4 66BA            		BNE	IS_BU			; yes...place data into buffer
    2472   2417                          	
    2473   2418                          	*	Copy from ISIS-Ring to Block:  If terminated by Block-full
    2474   2419                          	*	then report termination.
    2475   2420 000061A6 382C 0014       	IS_BK	MOVE.W	BI_TCN(Rp),D4		; get total count for block
    2476   2421 000061AA 6100 F420       		BSR	GETBLK			; get the word
    2477   2422 000061AE 366C 0018       		MOVE.W	BI_BYT(Rp),A3		; cursor within DAT
    2478   2423 000061B2 47EB 109C       		LEA	DAT(A3),A3		; position of next byte
    2479   2424 000061B6 4A78 1094       	IS_BK1	TST.W	INTYBT			; test if anything to get
    2480   2425 000061BA 6724            		BEQ	IS_BK2			; skip if not
    2481   2426 000061BC B86C 0016       		CMP.W	BI_LCN(Rp),D4		; see if any space left
    2482   2427 000061C0 671E            		BEQ	IS_BK2			; skip if not
    2483   2428 000061C2 6100 F13E       		BSR	GETCH			; OK...get from ring
    2484   2429 000061C6 5378 1094       		SUB.W	#1,INTYBT		; decrement data-counter
    2485   2430 000061CA 526C 0016       		ADD.W	#1,BI_LCN(Rp)		; count another char input
    2486   2431 000061CE 16C0            		MOVE.B	D0,(A3)+		; and save char
    2487   2432 000061D0 B6FC 10A0       		CMPA.W	#DAT5,A3		; have we exhausted DAT?
    2488   2433 000061D4 6DE0            		BLT	IS_BK1			; no
    2489   2434 000061D6 6100 F3CC       		BSR	WRBLK			; yes
    2490   2435 000061DA 47F8 109C       		LEA	DAT,A3			; reset word cursor
    2491   2436 000061DE 60D6            		BRA	IS_BK1
    2492   2437                          	
    2493   2438 000061E0 96FC 109C       	IS_BK2	SUB.W	#DAT,A3			; compute displacement
    2494   2439 000061E4 394B 0018       		MOVE.W	A3,BI_BYT(Rp)		; save it for next time
    2495   2440 000061E8 6708            		BEQ	IS_BK3			; at beginning of word
    2496   2441 000061EA 6100 F3B8       		BSR	WRBLK			; no...write word into PDP
    2497   2442 000061EE 53AC 0010       		SUB.L	#1,BI_TAR(Rp)		; back up word-cursor
    2498   2443 000061F2 B86C 0016       	IS_BK3	CMP.W	BI_LCN(Rp),D4		; have we filled block?
    2499   2444 000061F6 670C            		BEQ	IS_BK4			; yes
    2500   2445 000061F8 2478 1032       		MOVE.L	.FASTC,A2		; no...record current time
    2501   2446 000061FC 2952 000C       		MOVE.L	(A2),BI_TIM(Rp)
    2502   2447 00006200 6000 FE9C       		BRA	CLEANUP			; close this message and go do next
    2503   2448                          	
    2504   2449                          	*	Block-input terminated
    2505   2450 00006204 11FC 0027 109C  	IS_BK4	MOVE.B	#$27,DAT1
    2506   2451 0000620A 6100 FE4C       		BSR	BKITERM			; terminate block-input
    2507   2452                          	
    2508   2453 0000620E 4A78 1094       		TST.W	INTYBT			; see if more to do
    2509   2454 00006212 6600 FF4C       		BNE	IS_BU			; yes...go copy rest of message to buffer
    2510   2455 00006216 6000 FE86       		BRA	CLEANUP			; go clean upEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           15-Apr-88  Page   57
Err Source Ref. Address   value
    line   line

    2512   2457                          	*		ROUTINES TO PROCESS INDIVIDUAL ISIS MESSAGES
    2513   2458                          	
    2514   2459                          	
    2515   2460                          	*	A NEEDLE REQUEST IS PROCESSED HERE
    2516   2461 0000621A 7004            	NEEDLE	MOVEQ	#4,D0			; we'll need 4 bytes in the ISIS ring
    2517   2462 0000621C 6100 F00A       		BSR	ROOM			;  ...for a response
    2518   2463 00006220 6600 040A       		BNE.L	VERIFY			; Ignore this pass if not enough room there
    2519   2464 00006224 3638 1096       		MOVE.W	PORTNO,D3		; port number
    2520   2465 00006228 383C 00B9       		MOVE.W	#$B9,D4			; type = set transmit limit
    2521   2466 0000622C 6100 F032       		BSR	SLOR
    2522   2467 00006230 701E            		MOVEQ	#30,D0			; ...to 30d
    2523   2468 00006232 6100 F048       		BSR	PUTCH
    2524   2469 00006236 6100 F090       		BSR	ELOR
    2525   2470 0000623A 3238 1092       		MOVE.W	INRGSP,D1		; Also assume we'll need at least 80 bytes
    2526   2471 0000623E 0C41 0050       		CMP.W	#80,D1			;  in the PDP to process a needle
    2527   2472 00006242 6D00 03E8       		BLT.L	VERIFY			; Ignore this pass if not enough room there
    2528   2473 00006246 6100 F0BA       		BSR	GETCH			; key
    2529   2474 0000624A 6100 F0F0       		BSR	GETW			; Invoice
    2530   2475 0000624E 6100 F0D8       		BSR	GETH			; Dest. Host
    2531   2476 00006252 6100 F0D4       		BSR	GETH			; Orig. Node
    2532   2477 00006256 31C0 1098       		MOVE.W	D0,NORNODE
    2533   2478 0000625A 6100 F0CC       		BSR	GETH			; Orig. Host
    2534   2479 0000625E 6100 F0C8       		BSR	GETH			; Orig. Port
    2535   2480 00006262 31C0 109A       		MOVE.W	D0,NORPORT
    2536   2481 00006266 6100 F0D4       		BSR	GETW			; Extra I.N. | XXX | TPC
    2537   2482 0000626A 6100 F0BC       		BSR	GETH			; Dest. Node
    2538   2483 0000626E 6100 F092       		BSR	GETCH			; CCT
    2539   2484 00006272 11C0 10D0       		MOVE.B	D0,NCCT
    2540   2485 00006276 6100 F08A       		BSR	GETCH			; size
    2541   2486 0000627A 11C0 10D1       		MOVE.B	D0,NSIZ
    2542   2487 0000627E 4A38 10FB       		TST.B	PFULL			; ports still available?
    2543   2488 00006282 6600 0096       		BNE.L	NEE2			; no
    2544   2489 00006286 6100 F604       		BSR	RBTALL			; reset everything for port
    2545   2490 0000628A 08EC 0000 0001  		BSET	#PF_ACT,P_FLAGS(Rp)	; set port active
    2546   2491 00006290 6100 F710       		BSR	IPORT			; bump number of active ports
    2547   2492 00006294 1038 10D0       		MOVE.B	NCCT,D0			; translate CCT
    2548   2493 00006298 0240 001F       		AND.W	#$1F,D0
    2549   2494 0000629C 41F8 3938       		LEA	CCTBD,A0
    2550   2495 000062A0 1970 0000 0003  		MOVE.B	0(A0,D0.W),IBRATE(Rp)	; record Input Baud rate in case host asks
    2551   2496                          	
    2552   2497 000062A6 11FC 0006 109C  		MOVE.B	#6,DAT1			; type 6...New External Logon
    2553   2498 000062AC 11F8 1097 109D  		MOVE.B	PORTNO+1,DAT2		; port #
    2554   2499 000062B2 6100 F338       		BSR	WAITDAT			; wait, then send DAT to host
    2555   2500                          	
    2556   2501 000062B6 11FC 0082 109C  		MOVE.B	#$82,DAT1		; 2-byte Data message
    2557   2502 000062BC 11F8 10D0 109E  		MOVE.B	NCCT,DAT3		; CCT
    2558   2503 000062C2 3038 1098       		MOVE.W	NORNODE,D0
    2559   2504 000062C6 EC48            		LSR.W	#6,D0
    2560   2505 000062C8 11C0 109F       		MOVE.B	D0,DAT4			; high 6-bits of originating node
    2561   2506 000062CC 6100 F31E       		BSR	WAITDAT			; wait, then send DAT to HostEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           15-Apr-88  Page   58
Err Source Ref. Address   value
    line   line

    2562   2507                          	
    2563   2508 000062D0 3038 1098       		MOVE.W	NORNODE,D0
    2564   2509 000062D4 0240 003F       		AND.W	#$3F,D0			; low 6-bits of originating host
    2565   2510 000062D8 11C0 109E       		MOVE.B	D0,DAT3
    2566   2511 000062DC 11F8 109A 109F  		MOVE.B	NORPORT,DAT4		; originating port
    2567   2512 000062E2 6100 F308       		BSR	WAITDAT			; wait, then send DAT to host
    2568   2513                          	
    2569   2514                          	*	Move the username from needle to DAT
    2570   2515 000062E6 1438 10D1       		MOVE.B	NSIZ,D2			; number of bytes of username
    2571   2516 000062EA 43F8 109E       		LEA	DAT3,A1			; copy username into DAT3+
    2572   2517 000062EE 6100 F012       	GETUN	BSR	GETCH
    2573   2518 000062F2 12C0            		MOVE.B	D0,(A1)+
    2574   2519 000062F4 5302            		SUB.B	#1,D2
    2575   2520 000062F6 6EF6            		BGT	GETUN			; continue until copied
    2576   2521                          	
    2577   2522                          	*	Now move the username from DAT into host
    2578   2523 000062F8 1438 10D1       		MOVE.B	NSIZ,D2			; number of bytes
    2579   2524 000062FC 43F8 10A0       		LEA	DAT5,A1			; where to copy from
    2580   2525 00006300 0C02 0001       	PUTUN	CMP.B	#1,D2			; single byte?
    2581   2526 00006304 6604            		BNE	PUTUN1			; no
    2582   2527 00006306 5338 109C       		SUB.B	#1,DAT1			; yes...reduce count
    2583   2528 0000630A 6100 F2E0       	PUTUN1	BSR	WAITDAT			; wait for space, then send DAT
    2584   2529 0000630E 31D9 109E       		MOVE.W	(A1)+,DAT3		; copy next pair of bytes
    2585   2530 00006312 5502            		SUB.B	#2,D2			; reduce count
    2586   2531 00006314 6EEA            		BGT	PUTUN			; continue until name sent
    2587   2532 00006316 6000 FD86       		BRA	CLEANUP			; Done
    2588   2533                          	
    2589   2534                          	*	Out of ports...Must zap circuit for current needle
    2590   2535 0000631A 6100 EF2A       	NEE2	BSR	WAITISW			; we'll need 1 word to return Zapper
    2591   2536 0000631E 3638 1096       		MOVE.W	PORTNO,D3		; port number
    2592   2537 00006322 183C 00BE       		MOVE.B	#$BE,D4			; Type = Zap with reason
    2593   2538 00006326 6100 EF38       		BSR	SLOR
    2594   2539 0000632A 4240            		CLR.W	D0			; reason = 0 -- out of ports
    2595   2540 0000632C 6100 EF4E       		BSR	PUTCH
    2596   2541 00006330 6100 EF96       		BSR	ELOR
    2597   2542 00006334 4242            		CLR.W	D2
    2598   2543 00006336 1438 10D1       		MOVE.B	NSIZ,D2			; number of bytes left in needle
    2599   2544 0000633A 6000 FD68       		BRA	INRGFL			; go flush rest of needleEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           15-Apr-88  Page   59
Err Source Ref. Address   value
    line   line

    2601   2546                          	*	Determine handler for ISIS message -- D1 = INTYBT
    2602   2547 0000633E 0C41 00C1       	IMESS	CMP.W	#$C1,D1			; range check on type
    2603   2548 00006342 6C00 EE68       		BGE	ISMGER			; Bad ISIS input MSG
    2604   2549 00006346 0441 009E       		SUB.W	#$9E,D1			; bias type-code to tables
    2605   2550 0000634A 6D00 EE60       		BLT	ISMGER			; Bad ISIS input MSG
    2606   2551 0000634E 4240            		CLR.W	D0
    2607   2552 00006350 103B 1012       		MOVE.B	TRISLN(PC,D1.W),D0	; is there space to proceed?
    2608   2553 00006354 B078 1092       		CMP.W	INRGSP,D0		; space in ring
    2609   2554 00006358 6C00 02D2       		BGE.L	VERIFY			; abort this go-roundie if not
    2610   2555 0000635C D241            		ADD.W	D1,D1			; *2
    2611   2556 0000635E 327B 1028       		MOVE.W	IMSTAB(PC,D1.W),A1	; look up handler address
    2612   2557 00006362 4ED1            		JMP	(A1)			; ...and go there
    2613   2558                          	
    2614   2559                          	
    2615   2560                          	*	TRANSLATED ISIS MSG LENGTH
    2616   2561 00006364 00              	TRISLN	DC.B	0			; 9E
    2617   2562 00006365 02              		DC.B	2			; 9F
    2618   2563 00006366 02              		DC.B	2			; A0
    2619   2564 00006367 02              		DC.B	2			; A1
    2620   2565 00006368 02              		DC.B	2			; A2
    2621   2566 00006369 00              		DC.B	0			; A3
    2622   2567 0000636A 03              		DC.B	3			; A4
    2623   2568 0000636B 03              		DC.B	3			; A5
    2624   2569 0000636C 02              		DC.B	2			; A6
    2625   2570 0000636D 02              		DC.B	2			; A7
    2626   2571 0000636E 00              		DC.B	0			; A8
    2627   2572 0000636F 00              		DC.B	0			; A9
    2628   2573 00006370 02              		DC.B	2			; AA
    2629   2574 00006371 02              		DC.B	2			; AB
    2630   2575 00006372 02              		DC.B	2			; AC
    2631   2576 00006373 02              		DC.B	2			; AD
    2632   2577 00006374 02              		DC.B	2			; AE
    2633   2578 00006375 00              		DC.B	0			; AF
    2634   2579 00006376 00              		DC.B	0			; B0
    2635   2580 00006377 04              		DC.B	4			; B1
    2636   2581 00006378 00              		DC.B	0			; B2
    2637   2582 00006379 00              		DC.B	0			; B3
    2638   2583 0000637A 00              		DC.B	0			; B4
    2639   2584 0000637B 03              		DC.B	3			; B5
    2640   2585 0000637C 06              		DC.B	6			; B6
    2641   2586 0000637D 00              		DC.B	0			; B7
    2642   2587 0000637E 00              		DC.B	0			; B8
    2643   2588 0000637F 00              		DC.B	0			; B9
    2644   2589 00006380 00              		DC.B	0			; BA
    2645   2590 00006381 00              		DC.B	0			; BB
    2646   2591 00006382 00              		DC.B	0			; BC
    2647   2592 00006383 00              		DC.B	0			; BD
    2648   2593 00006384 00              		DC.B	0			; BE
    2649   2594 00006385 00              		DC.B	0			; BF
    2650   2595 00006386 00              		DC.B	0			; C0EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           15-Apr-88  Page   60
Err Source Ref. Address   value
    line   line

    2651   2596 00006387 00              		DC.B	0			; C1
    2652   2597                          	
    2653   2598                          	
    2654   2599                          	*	ISIS INPUT MESSAGE DISPATCH TABLE
    2655   2600 00006388 609E            	IMSTAB	DC.W	CLEANUP			; 9E - DETACH, IGNORE
    2656   2601 0000638A 63D0            		DC.W	ZAPPER			; 9F - ZAPPER, process and send on
    2657   2602 0000638C 63E2            		DC.W	BPON			; A0 - SET BKPR, SEND ON
    2658   2603 0000638E 63EA            		DC.W	BPOFF			; A1 - RELEASE BKPR, SEND ON
    2659   2604 00006390 63F2            		DC.W	GOBBLER			; A2 - GOBBLER, Send on
    2660   2605 00006392 609E            		DC.W	CLEANUP			; A3 - FLUSH INPUT, IGNORE
    2661   2606 00006394 640A            		DC.W	BLACK			; A4 - BLACK BALL
    2662   2607 00006396 6404            		DC.W	GRAY			; A5 - GRAY BALL
    2663   2608 00006398 642C            		DC.W	STREAM			; A6 - ENTER DEM, Send on
    2664   2609 0000639A 642C            		DC.W	STREAM			; A7 - LEAVE DEM, Send on
    2665   2610 0000639C 609E            		DC.W	CLEANUP			; A8 - ENTER TRANSPARENCY, IGNORE
    2666   2611 0000639E 609E            		DC.W	CLEANUP			; A9 - LEAVE TRANSPARENCY, IGNORE
    2667   2612 000063A0 642C            		DC.W	STREAM			; AA - GREEN BALL, Send on
    2668   2613 000063A2 642C            		DC.W	STREAM			; AB - RED BALL, Send on
    2669   2614 000063A4 6412            		DC.W	YELLOW			; AC - YELLOW BALL, SEND ON
    2670   2615 000063A6 6444            		DC.W	ISP			; AD - ORANGE BALL, Send on immediately
    2671   2616 000063A8 642C            		DC.W	STREAM			; AE - BREAK BEGIN, Send on
    2672   2617 000063AA 609E            		DC.W	CLEANUP			; AF - HANG UP, IGNORE
    2673   2618 000063AC 609E            		DC.W	CLEANUP			; B0 - QUERY TERM CHAR, IGNORE
    2674   2619 000063AE 646C            		DC.W	ITERM			; B1 - SET TERM CHAR
    2675   2620 000063B0 648E            		DC.W	PNEDL			; B2 - PSEUDO NEEDLE
    2676   2621 000063B2 51AC            		DC.W	ISMGER			; B3 - LOGON CHAR (we don't expect this)
    2677   2622 000063B4 609E            		DC.W	CLEANUP			; B4 - LOGON STATUS, IGNORE
    2678   2623 000063B6 64DA            		DC.W	LOGFAL			; B5 - LOGON FAILED
    2679   2624 000063B8 6502            		DC.W	ILOG			; B6 - LOGON OKAY
    2680   2625 000063BA 51AC            		DC.W	ISMGER			; B7 - ACCOUNTING (we don't expect this)
    2681   2626 000063BC 609E            		DC.W	CLEANUP			; B8 - SUPER HANG, IGNORE
    2682   2627 000063BE 654E            		DC.W	SMTLMT			; B9 - SET XMT LIMIT
    2683   2628 000063C0 609E            		DC.W	CLEANUP			; BA - BREAK END, IGNORE
    2684   2629 000063C2 609E            		DC.W	CLEANUP			; BB - ZAP ACKNOWLEDGE, IGNORE
    2685   2630 000063C4 609E            		DC.W	CLEANUP			; BC - ENTER ALT DEV MODE, IGNORE
    2686   2631 000063C6 609E            		DC.W	CLEANUP			; BD - LEAVE ALT DEV MODE, IGNORE
    2687   2632 000063C8 609E            		DC.W	CLEANUP			; BE - ZAP WITH REASON,IGNORE
    2688   2633 000063CA 609E            		DC.W	CLEANUP			; BF - SIIX COMMAND, IGNORE
    2689   2634 000063CC 609E            		DC.W	CLEANUP			; C0 - TIIX COMMAND, IGNORE
    2690   2635 000063CE 51AC            		DC.W	ISMGER			; C1 - UUO (we don't expect this)
    2691   2636                          	
    2692   2637                          	
    2693   2638                          	*	9F -- Zapper
    2694   2639 000063D0 08AC 0000 0001  	ZAPPER	BCLR	#PF_ACT,P_FLAGS(Rp)	; test if port active (and reset it)
    2695   2640 000063D6 676C            		BEQ	ISP			; no...just proceed
    2696   2641 000063D8 6100 F5E0       		BSR	DPORT			; yes...count it gone
    2697   2642 000063DC 6100 F4AE       		BSR	RBTALL			; reset everything
    2698   2643 000063E0 6062            		BRA	ISP			; ...and proceed
    2699   2644                          	
    2700   2645                          	
    2701   2646                          	*	A0 -- apply back-pressureEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           15-Apr-88  Page   61
Err Source Ref. Address   value
    line   line

    2702   2647 000063E2 08EC 0001 0001  	BPON	BSET	#PF_OBP,P_FLAGS(Rp)	; set output back-pressure
    2703   2648 000063E8 605A            		BRA	ISP
    2704   2649                          	
    2705   2650                          	*	A1 -- release back-pressure
    2706   2651 000063EA 08AC 0001 0001  	BPOFF	BCLR	#PF_OBP,P_FLAGS(Rp)	; clear output back-pressure
    2707   2652 000063F0 6052            		BRA	ISP
    2708   2653                          	
    2709   2654                          	*	A2 -- Gobbler
    2710   2655 000063F2 082C 0005 0001  	GOBBLER	BTST	#PF_BKI,P_FLAGS(Rp)	; block-input active?
    2711   2656 000063F8 664A            		BNE	ISP			; yes...just pass it on
    2712   2657 000063FA 6100 F3B4       		BSR	DEMPTY			; no...empty the buffer
    2713   2658 000063FE 6100 04F8       		BSR.L	BU_EMP			; release back-pressure
    2714   2659 00006402 6040            		BRA	ISP			; ...then pass it on
    2715   2660                          	
    2716   2661                          	
    2717   2662                          	*	A5 -- Gray ball
    2718   2663 00006404 4238 109E       	GRAY	CLR.B	DAT3			; d3 = 0 for grey ball
    2719   2664 00006408 603A            		BRA	ISP			; then process as special message
    2720   2665                          	
    2721   2666                          	*	A4 -- Black Ball
    2722   2667 0000640A 11FC 00FF 109E  	BLACK	MOVE.B	#-1,DAT3		; special parameter
    2723   2668 00006410 6032            		BRA	ISP
    2724   2669                          	
    2725   2670                          	
    2726   2671                          	*	AC - Yellow Ball
    2727   2672                          	*	Special handling for Block-input active, since Yellow-ball
    2728   2673                          	*	serves to indicate EOT.
    2729   2674 00006412 082C 0005 0001  	YELLOW	BTST	#PF_BKI,P_FLAGS(Rp)	; is block-input active?
    2730   2675 00006418 6712            		BEQ	STREAM			; no...process as normal in-stream code
    2731   2676 0000641A 082C 0006 0001  		BTST	#PF_BFD,P_FLAGS(Rp)	; yes...test Block-FilleD
    2732   2677 00006420 6610            		BNE	STREAM1			; was set...place yellow-ball into buffer
    2733   2678 00006422 11FC 0028 109C  		MOVE.B	#$28,DAT1		; no...set Bin terminated by EOT
    2734   2679 00006428 6100 FC2E       		BSR	BKITERM			; terminate block-input
    2735   2680                          						; ...then proceed with in-stream usage
    2736   2681                          	
    2737   2682                          	
    2738   2683                          	*	Special Message...retain in-stream
    2739   2684 0000642C 4A6C 001E       	STREAM	TST.W	BCT(Rp)			; anything in buffer?
    2740   2685 00006430 6712            		BEQ	ISP			; no...just pass it on
    2741   2686                          	
    2742   2687 00006432 701B            	STREAM1	MOVEQ	#ESC,D0			; Yes...place escape
    2743   2688 00006434 6100 F2FC       		BSR	DWCI			;  ...into buffer
    2744   2689 00006438 3038 1094       		MOVE.W	INTYBT,D0		;   ...followed by ISIS Code
    2745   2690 0000643C 6100 F2F4       		BSR	DWCI
    2746   2691 00006440 6000 FC5C       		BRA	CLEANUP			; done...escaped code will be removed later
    2747   2692                          	
    2748   2693                          	
    2749   2694                          	*	Single-byte ISIS message
    2750   2695                          	*	MSG types 9F, A0, A1, A2, A6, A7, AA, AB, AC, AD, AE
    2751   2696 00006444 6104            	ISP	BSR	LOOKUP			; go translate message-type
    2752   2697 00006446 6000 FC4C       		BRA	PUTPN			; go send itEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           15-Apr-88  Page   62
Err Source Ref. Address   value
    line   line

    2753   2698                          	
    2754   2699                          	*	Translate ISIS message-type to PDP type, place into DAT1
    2755   2700 0000644A 3238 1094       	LOOKUP	MOVE.W	INTYBT,D1
    2756   2701 0000644E 0441 009F       		SUB.W	#$9F,D1
    2757   2702 00006452 11FB 1008 109C  		MOVE.B	ISPTAB(PC,D1.W),DAT1	; translated message-type
                         4E71
    2758   2703 0000645A 4E75            		RTS
    2759   2704                          	
    2760   2705                          	*	Translation table for ISIS special ( > $9E ) messages
    2761   2706 0000645C 0B              	ISPTAB	DC.B	11			; 9F - Zapper
    2762   2707 0000645D 08              		DC.B	8			; A0 - Apply backpressure
    2763   2708 0000645E 09              		DC.B	9			; A1 - Release backpressure
    2764   2709 0000645F 0A              		DC.B	10			; A2 - Gobbler
    2765   2710 00006460 00              		DC.B	0			; A3 -
    2766   2711 00006461 15              		DC.B	21			; A4 - Black Ball
    2767   2712 00006462 15              		DC.B	21			; A5 - Gray Ball
    2768   2713 00006463 0C              		DC.B	12			; A6 - Enter DEM
    2769   2714 00006464 0D              		DC.B	13			; A7 - Leave DEM
    2770   2715 00006465 00              		DC.B	0			; A8 -
    2771   2716 00006466 00              		DC.B	0			; A9 -
    2772   2717 00006467 0E              		DC.B	14			; AA - Green Ball
    2773   2718 00006468 0F              		DC.B	15			; AB - Red Ball
    2774   2719 00006469 10              		DC.B	16			; AC - Yellow Ball
    2775   2720 0000646A 11              		DC.B	17			; AD - Orange Ball
    2776   2721 0000646B 2F              		DC.B	47			; AE - Break Begin
    2777   2722                          	
    2778   2723                          	
    2779   2724                          	*	B1 -- Terminal-characteristics response
    2780   2725 0000646C 11FC 0020 109C  	ITERM	MOVE.B	#$20,DAT1		; type
    2781   2726 00006472 6100 EE8E       		BSR	GETCH			; parameter number
    2782   2727 00006476 0C00 0010       		CMP.B	#$10,D0
    2783   2728 0000647A 6602            		BNE	NOJAP
    2784   2729 0000647C 5300            		SUB.B	#1,D0			; translate 16d to 15d
    2785   2730 0000647E 11C0 109E       	NOJAP	MOVE.B	D0,DAT3			; parameter code
    2786   2731 00006482 6100 EE7E       		BSR	GETCH
    2787   2732 00006486 11C0 109F       		MOVE.B	D0,DAT4			; value
    2788   2733 0000648A 6000 FC08       		BRA	PUTPN			; send it
    2789   2734                          	
    2790   2735                          	
    2791   2736                          	*	B2 -- Pseudo-Needle
    2792   2737 0000648E 6100 F3FC       	PNEDL	BSR	RBTALL			; first, clean up port
    2793   2738 00006492 6100 EE6E       		BSR	GETCH			; padding
    2794   2739 00006496 6100 EE90       		BSR	GETH			; local key
    2795   2740 0000649A 1940 0003       		MOVE.B	D0,AUXKEY(Rp)		; save it
    2796   2741 0000649E 4A38 10FB       		TST.B	PFULL			; room for another circuit?
    2797   2742 000064A2 6618            		BNE	PFULL1			; skip if not
    2798   2743 000064A4 6100 F3E6       		BSR	RBTALL			; reset everything for port
    2799   2744 000064A8 08EC 0000 0001  		BSET	#PF_ACT,P_FLAGS(Rp)	; set port active
    2800   2745 000064AE 6100 F4F2       		BSR	IPORT
    2801   2746 000064B2 31FC FFFF 1056  		MOVE.W	#-1,AUXX		; enable another aux-request
    2802   2747 000064B8 6000 FBE4       		BRA	CLEANUP			; go clean upEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           15-Apr-88  Page   63
Err Source Ref. Address   value
    line   line

    2803   2748                          	
    2804   2749                          	*	Out of ports...Must zap circuit for B2
    2805   2750 000064BC 6100 ED88       	PFULL1	BSR	WAITISW			; we'll need 1 word to return Zapper
    2806   2751 000064C0 3638 1096       		MOVE.W	PORTNO,D3		; port number
    2807   2752 000064C4 183C 00BE       		MOVE.B	#$BE,D4			; Type = Zap with reason
    2808   2753 000064C8 6100 ED96       		BSR	SLOR
    2809   2754 000064CC 4240            		CLR.W	D0			; reason = 0 -- out of ports
    2810   2755 000064CE 6100 EDAC       		BSR	PUTCH
    2811   2756 000064D2 6100 EDF4       		BSR	ELOR
    2812   2757 000064D6 7008            		MOVEQ	#8,D0			; fake reason to "out of orig. ports"
    2813   2758 000064D8 6004            		BRA	LOGFAL1			; tell host that Aux-circuit attempt failed
    2814   2759                          	
    2815   2760                          	
    2816   2761                          	*	B5 -- Logon failure
    2817   2762 000064DA 6100 EE26       	LOGFAL	BSR	GETCH			; get reason
    2818   2763 000064DE 31FC FFFF 1056  	LOGFAL1	MOVE.W	#-1,AUXX		; enable another AUX attempt
    2819   2764 000064E4 11FC 0017 109C  		MOVE.B	#$17,DAT1		; message type
    2820   2765 000064EA 11F8 1051 109D  		MOVE.B	AUXQ+1,DAT2		; AUX circuit key
    2821   2766 000064F0 11C0 109E       		MOVE.B	D0,DAT3			; error code
    2822   2767 000064F4 6600 FBA4       		BNE	SENDDAT			; send to PDP (unless 0)
    2823   2768 000064F8 11FC 0007 109E  		MOVE.B	#7,DAT3			; code 0 -> 7
    2824   2769 000064FE 6000 FB9A       		BRA	SENDDAT
    2825   2770                          	
    2826   2771                          	
    2827   2772                          	*	B6 -- Logon OK
    2828   2773 00006502 6100 EDFE       	ILOG	BSR	GETCH			; padding
    2829   2774 00006506 6100 EE34       		BSR	GETW			; Invoice number
    2830   2775 0000650A 6100 EE1C       		BSR	GETH			; orig. host
    2831   2776 0000650E 3638 1096       		MOVE.W	PORTNO,D3		; for this port,
    2832   2777 00006512 383C 00B9       		MOVE.W	#$B9,D4			; ...set transmit limit
    2833   2778 00006516 6100 ED48       		BSR	SLOR
    2834   2779 0000651A 701E            		MOVEQ	#30,D0			; ...to 30d
    2835   2780 0000651C 6100 ED5E       		BSR	PUTCH
    2836   2781 00006520 6100 EDA6       		BSR	ELOR
    2837   2782 00006524 11FC 0007 109C  		MOVE.B	#7,DAT1
    2838   2783 0000652A 11F8 1097 109D  		MOVE.B	PORTNO+1,DAT2
    2839   2784 00006530 11EC 0003 109E  		MOVE.B	AUXKEY(Rp),DAT3		; orig port
    2840   2785 00006536 6100 F0B6       		BSR	WRDAT			; send DAT on to PDP
    2841   2786 0000653A 11FC 0017 109C  		MOVE.B	#$17,DAT1		; tell PDP which AUX succeeded
    2842   2787 00006540 11EC 0003 109D  		MOVE.B	AUXKEY(Rp),DAT2		; orig port
    2843   2788 00006546 4278 109E       		CLR.W	DAT3			; set success-code
    2844   2789 0000654A 6000 FB4E       		BRA	SENDDAT			; send DAT to host
    2845   2790                          	
    2846   2791                          	
    2847   2792                          	*	B9 - SET XMT LIMIT
    2848   2793 0000654E 6100 EDB2       	SMTLMT	BSR	GETCH			; get limit
    2849   2794 00006552 5B00            		SUB.B	#5,D0			; round down
    2850   2795 00006554 0200 00FC       		AND.B	#$FC,D0
    2851   2796 00006558 5400            		ADD.B	#2,D0			; round back up
    2852   2797 0000655A 1940 0002       		MOVE.B	D0,XMITLMT(Rp)		; save transmit-limit
    2853   2798 0000655E 6000 FB3E       		BRA	CLEANUP			; nothing to tell hostEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           15-Apr-88  Page   64
Err Source Ref. Address   value
    line   line

    2855   2800                          	*	PROCESS PORT-ZERO MESSAGES
    2856   2801                          	
    2857   2802                          	
    2858   2803                          	*	D0 = 0;  D1 = INTYBT
    2859   2804 00006562 0C41 0010       	IPZ	CMP.W	#$10,D1			; is this valid Port 0 message?
    2860   2805 00006566 6E00 EC44       		BGT	ISMGER			; not in range -- crash
    2861   2806 0000656A 103B 1012       		MOVE.B	INISLN(PC,D1),D0	; will MSG fit?
    2862   2807 0000656E B078 1092       		CMP.W	INRGSP,D0		; space in ring
    2863   2808 00006572 6C00 00B8       		BGE.L	VERIFY			; no...go to VERIFY
    2864   2809 00006576 D241            		ADD.W	D1,D1			; 2*message type
    2865   2810 00006578 327B 1016       		MOVE.W	IPZTAB(PC,D1),A1	; get the service address
    2866   2811 0000657C 4ED1            		JMP	(A1)			; go service port0 message
    2867   2812                          	
    2868   2813                          	*	INTRA-ISIS MSG LENGTH
    2869   2814 0000657E 00              	INISLN	DC.B	0			; 00
    2870   2815 0000657F 00              		DC.B	0			; 01
    2871   2816 00006580 02              		DC.B	2			; 02
    2872   2817 00006581 00              		DC.B	0			; 03
    2873   2818 00006582 00              		DC.B	0			; 04
    2874   2819 00006583 00              		DC.B	0			; 05
    2875   2820 00006584 06              		DC.B	6			; 06
    2876   2821 00006585 00              		DC.B	0			; 07
    2877   2822 00006586 00              		DC.B	0			; 08
    2878   2823 00006587 03              		DC.B	3			; 09
    2879   2824 00006588 00              		DC.B	0			; 0A
    2880   2825 00006589 00              		DC.B	0			; 0B
    2881   2826 0000658A 00              		DC.B	0			; 0C
    2882   2827 0000658B 02              		DC.B	2			; 0D
    2883   2828 0000658C 00              		DC.B	0			; 0E
    2884   2829 0000658D 00              		DC.B	0			; 0F
    2885   2830 0000658E 00              		DC.B	0			; 10
    2886   2831                          	
    2887   2832                          	
    2888   2833                          	*	ISIS INTRA-NODE MESSAGE DISPATCH TABLE
    2889   2834 00006590 51AC            	IPZTAB	DC.W	ISMGER			; 00 RESTRT REQ -- Not Expected
    2890   2835 00006592 51AC            		DC.W	ISMGER			; 01 RESTRT RESP -- Not Expected
    2891   2836 00006594 65B2            		DC.W	SUPTAK			; 02 SUPERVISOR TAKEOVER
    2892   2837 00006596 51AC            		DC.W	ISMGER			; 03 REPORT TO SUP -- Not Expected
    2893   2838 00006598 51AC            		DC.W	ISMGER			; 04 HOST STATUS -- Not Expected
    2894   2839 0000659A 51AC            		DC.W	ISMGER			; 05 ACCNTNG -- Not Expected
    2895   2840 0000659C 65C6            		DC.W	IPTIME			; 06 SUP TIME
    2896   2841 0000659E 51AC            		DC.W	ISMGER			; 07 NORM CIR REQ -- Not Expected
    2897   2842 000065A0 51AC            		DC.W	ISMGER			; 08 AUX CIR REQ -- Not Expected
    2898   2843 000065A2 65EE            		DC.W	AUXERR			; 09 AUX CIRCUIT ERROR
    2899   2844 000065A4 51AC            		DC.W	ISMGER			; 0A HOST PORT AVAIL -- Not Expected
    2900   2845 000065A6 661C            		DC.W	HSTUNA			; 0B HOST UNACCEPTABLE
    2901   2846 000065A8 51AC            		DC.W	ISMGER			; 0C HOST COST -- Not Expected
    2902   2847 000065AA 65B2            		DC.W	SUPTAK			; 0D SUPERVISOR LOST
    2903   2848 000065AC 51AC            		DC.W	ISMGER			; 0E 1-DOWN -- Not Expected
    2904   2849 000065AE 51AC            		DC.W	ISMGER			; 0F REPORT ALL HOSTS -- Not ExpectedEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           15-Apr-88  Page   65
Err Source Ref. Address   value
    line   line

    2905   2850 000065B0 51AC            		DC.W	ISMGER			; 10 HOST STATUS -- Not Expected
    2906   2851                          	
    2907   2852                          	
    2908   2853                          	
    2909   2854                          	*	0.2 -- Takeover (or 0.D -- Sup. Lost)
    2910   2855 000065B2 31FC FFFF 1056  	SUPTAK	MOVE.W	#-1,AUXX		; cancel outstanding AUX requests
    2911   2856 000065B8 11FC 0005 109C  		MOVE.B	#5,DAT1			; type 5
    2912   2857 000065BE 4238 109D       		CLR.B	DAT2			; port 0
    2913   2858 000065C2 6000 FAD6       		BRA	SENDDAT			; send DAT to PDP
    2914   2859                          	
    2915   2860                          	
    2916   2861                          	*	0.6 -- GMT report
    2917   2862 000065C6 11FC 0023 109C  	IPTIME	MOVE.B	#$23,DAT1
    2918   2863 000065CC 4238 109D       		CLR.B	DAT2			; for port 0...
    2919   2864 000065D0 6100 ED30       		BSR	GETCH			; skip padding
    2920   2865 000065D4 6100 ED66       		BSR	GETW
    2921   2866 000065D8 21C0 109E       		MOVE.L	D0,DAT3			; save all bytes
    2922   2867 000065DC 6100 F010       		BSR	WRDAT			; send to PDP
    2923   2868 000065E0 2238 10A0       		MOVE.L	DAT5,D1			; get next word
    2924   2869 000065E4 4241            		CLR.W	D1			; pad it out with 0
    2925   2870 000065E6 6100 F00A       		BSR	WRPDP			; and send it too
    2926   2871 000065EA 6000 FAB2       		BRA	CLEANUP			; then exit
    2927   2872                          	
    2928   2873                          	
    2929   2874                          	*	0.9 -- AUX circuit error
    2930   2875 000065EE 6100 ED12       	AUXERR	BSR	GETCH			; padding
    2931   2876 000065F2 6100 ED34       		BSR	GETH			; local key
    2932   2877 000065F6 31FC FFFF 1056  		MOVE.W	#-1,AUXX		; re-enable Aux circuits
    2933   2878 000065FC 11FC 0017 109C  		MOVE.B	#$17,DAT1		; type 23d
    2934   2879 00006602 11C0 109D       		MOVE.B	D0,DAT2			; local key (port # - who made request)
    2935   2880 00006606 6100 ECFA       		BSR	GETCH			; error code
    2936   2881 0000660A 11C0 109E       		MOVE.B	D0,DAT3
    2937   2882 0000660E 6600 FA8A       		BNE	SENDDAT			; send DAT (unless error=0)
    2938   2883 00006612 11FC 0007 109E  		MOVE.B	#7,DAT3			; 0 -> 7
    2939   2884 00006618 6000 FA80       		BRA	SENDDAT			; send DAT
    2940   2885                          	
    2941   2886                          	
    2942   2887                          	*	0.0B -- HOST UNACCEPTABLE
    2943   2888 0000661C 6100 ECE4       	HSTUNA	BSR	GETCH			; IGNORE FOR NOW *****
    2944   2889 00006620 6100 ED06       		BSR	GETH
    2945   2890 00006624 6100 ECDC       		BSR	GETCH
    2946   2891 00006628 6000 FA74       		BRA	CLEANUP



    2948   2893                          		TTL	'E B U S  --  PDP-10 Base Code,		H O S T   S T A T U S'EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		H O S T   S T A T U S         15-Apr-88  Page   66
Err Source Ref. Address   value
    line   line

    2950   2895                          	*		V E R I F Y   H O S T ,   C H E C K   C O N S I S T A N C Y
    2951   2896                          	
    2952   2897                          	
    2953   2898 0000662C 4A38 1081       	VERIFY	TST.B	HTDWN			; is host up?
    2954   2899 00006630 6704            		BEQ	HALFSEC			; yes
    2955   2900 00006632 6100 F208       		BSR	HODOWN			; no, tel SUP Host is Down
    2956   2901                          	
    2957   2902                          	
    2958   2903                          	*	Half-second logic.  Check if Host is up
    2959   2904 00006636 2078 1032       	HALFSEC	MOVE.L	.FASTC,A0
    2960   2905 0000663A 2010            		MOVE.L	(A0),D0
    2961   2906 0000663C B0B8 10DC       		CMP.L	LFASTC,D0		; LFASTC specifies NEXT time to do it!
    2962   2907 00006640 6D00 00D4       		BLT.L	HALFSEX			; not time yet
    2963   2908 00006644 0680 0000 012C  		ADD.L	#300,D0			; we do this every half-second
    2964   2909 0000664A 21C0 10DC       		MOVE.L	D0,LFASTC		; set time for NEXT test
    2965   2910 0000664E 4A38 1081       		TST.B	HTDWN			; check current state...
    2966   2911 00006652 6630            		BNE	HDOWNR			; was down..go to host-down code
    2967   2912                          	
    2968   2913                          	*	Host is believed up...read key
    2969   2914                          	*	If good, just reset timeout
    2970   2915                          	*	Else if 0, timeout is in effect
    2971   2916                          	*	Else, crash for bad key
    2972   2917 00006654 7408            	HUPR	MOVEQ	#8,D2			; try to get key eight times
    2973   2918 00006656 6100 F250       	HUPR1	BSR	DOKEY			; verify Key usage
    2974   2919 0000665A 671E            		BEQ	HUPR2			; got match...all is OK
    2975   2920 0000665C 4A81            		TST.L	D1			; did we read 0?
    2976   2921 0000665E 6600 F188       		BNE	BADKEY
    2977   2922 00006662 4A38 103A       		TST.B	P10DAH			; check high-bits
    2978   2923 00006666 6600 F180       		BNE	BADKEY			; wasn't zero (from last try)
    2979   2924 0000666A 5302            		SUB.B	#1,D2			; try again?
    2980   2925 0000666C 6CE8            		BGE	HUPR1			; yes
    2981   2926 0000666E 5378 104A       		SUB.W	#1,TOHOST		; no...decrement current timeout
    2982   2927 00006672 6C00 00A2       		BGE.L	HALFSEX			; not yet
    2983   2928 00006676 6000 F168       		BRA	NOKEY			; timeout expired...go crash host
    2984   2929                          	
    2985   2930 0000667A 31F8 1048 104A  	HUPR2	MOVE.W	HOSTTO,TOHOST		; reset timeout period
    2986   2931 00006680 6000 0094       		BRA.L	HALFSEX			; ...and exit
    2987   2932                          	
    2988   2933                          	*	Host believed down...read key
    2989   2934                          	*	if good, get parameters, begin talking to host
    2990   2935 00006684 6100 F222       	HDOWNR	BSR	DOKEY			; do the key-stuff
    2991   2936 00006688 6600 0084       		BNE.L	MNGOOD			; skip if no good
    2992   2937 0000668C 5278 10E0       		ADD.W	#1,LASCOU
    2993   2938 00006690 3438 10E0       		MOVE.W	LASCOU,D2
    2994   2939 00006694 0C42 0004       		CMP.W	#4,D2
    2995   2940 00006698 6D00 007C       		BLT.L	HALFSEX			; wait 2 seconds before believe host
    2996   2941 0000669C 31FC 0073 1040  		MOVE.W	#$73,P10ADR		; "DUMP" flag at o163
    2997   2942 000066A2 4281            		CLR.L	D1			; set "DUMP" finished
    2998   2943 000066A4 4A79 00D0 1038  		TST.W	DEXCO			; Reset EBUS
    2999   2944 000066AA 6100 EEE0       		BSR	PUTPDPREBUS02.J00/X               E B U S  --  PDP-10 Base Code,		H O S T   S T A T U S         15-Apr-88  Page   67
Err Source Ref. Address   value
    line   line

    3000   2945                          	
    3001   2946                          	
    3002   2947                          	*	Output-ring parameters
    3003   2948 000066AE 31FC 006F 1040  		MOVE.W	#$6F,P10ADR		; Read from o157
    3004   2949 000066B4 6100 ED62       		BSR	GETPDPL
    3005   2950 000066B8 31C1 1082       		MOVE.W	D1,PDPORP		; Output-ring start-address
    3006   2951 000066BC 31FC 0070 1040  		MOVE.W	#$70,P10ADR		; from o160
    3007   2952 000066C2 6100 ED54       		BSR	GETPDPL
    3008   2953 000066C6 31C1 1084       		MOVE.W	D1,PDPOSZ		; Output-ring Size
    3009   2954 000066CA 4278 1088       		CLR.W	PDPOEC			; initialize our output-ring empty cursor
    3010   2955 000066CE 6100 EF68       		BSR	PUTOEC			; ..and tell the PDP
    3011   2956 000066D2 6100 EDE0       		BSR	GETOFC			; Get output-ring fill cursor
    3012   2957                          	
    3013   2958                          	*	Input-ring parameters
    3014   2959 000066D6 31FC 006B 1040  		MOVE.W	#$6B,P10ADR		; from o153
    3015   2960 000066DC 6100 ED3A       		BSR	GETPDPL
    3016   2961 000066E0 31C1 108A       		MOVE.W	D1,PDPIRP		; Input-ring Start-address
    3017   2962 000066E4 31FC 006C 1040  		MOVE.W	#$6C,P10ADR		; from o154
    3018   2963 000066EA 6100 ED2C       		BSR	GETPDPL
    3019   2964 000066EE 31C1 108C       		MOVE.W	D1,PDPISZ		; Input-ring size
    3020   2965 000066F2 4278 1090       		CLR.W	PDPIFC			; initialize out input-ring fill cursor
    3021   2966 000066F6 6100 EF2E       		BSR	PUTIFC			; ...and tell the PDP
    3022   2967 000066FA 6100 EDA8       		BSR	GETIEC			; Get input-ring empty cursor
    3023   2968                          	
    3024   2969 000066FE 4238 1081       		CLR.B	HTDWN			; 0 = host is up
    3025   2970 00006702 31FC 0001 104A  		MOVE.W	#1,TOHOST		; cancel timeouts in progress
    3026   2971 00006708 31FC 0001 1048  		MOVE.W	#1,HOSTTO
    3027   2972                          	
    3028   2973 0000670E 4278 10E0       	MNGOOD	CLR.W	LASCOU
    3029   2974 00006712 6100 F1FA       		BSR	EMPTY			; empty ISIS input ring
    3030   2975                          	
    3031   2976                          	HALFSEX	*				; exit to here...
    3032   2977                          	*					 ...and fall through to DOBKOUT



    3034   2979                          		TTL	'E B U S  --  PDP-10 Base Code,		B L O C K   O U T P U T'EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		B L O C K   O U T P U T       15-Apr-88  Page   68
Err Source Ref. Address   value
    line   line

    3036   2981                          	*		BLOCK OUTPUT
    3037   2982                          	
    3038   2983                          	*	BLOCK OUTPUT IS BEING DONE HERE
    3039   2984 00006716 4A38 1081       	DOBKOUT	TST.B	HTDWN			; quit if host down
    3040   2985 0000671A 6600 F2E2       		BNE	EXEC
    3041   2986 0000671E 3038 10F4       		MOVE.W	BKOHEAD,D0		; any Block-output in progress?
    3042   2987 00006722 6700 0092       		BEQ.L	INBKTIM			; no...just skip
    3043   2988                          	
    3044   2989 00006726 3040            	BOUT	MOVE.W	D0,A0			; unchain pointer
    3045   2990 00006728 31D8 10F8       		MOVE.W	(A0)+,SAVE1		; get NEXT
    3046   2991 0000672C 3010            		MOVE.W	(A0),D0			; fetch port number
    3047   2992 0000672E 6100 F14C       		BSR	SETPORT			; set up port
    3048   2993 00006732 082C 0001 0001  		BTST	#PF_OBP,P_FLAGS(Rp)	; check output back-pressure
    3049   2994 00006738 6674            		BNE	BOUTX			; set...don't output this time
    3050   2995 0000673A 4241            		CLR.W	D1			; no back-pressure...set up to transmit
    3051   2996 0000673C 122C 0002       		MOVE.B	XMITLMT(Rp),D1		; extract transmit-limit
    3052   2997 00006740 302C 000A       		MOVE.W	BO_TCN(Rp),D0		; number of characters left
    3053   2998 00006744 B041            		CMP.W	D1,D0			; more than we can send?
    3054   2999 00006746 6F02            		BLE	BOUT1			; no
    3055   3000 00006748 3001            		MOVE.W	D1,D0			; yes...use limit instead
    3056   3001 0000674A 3800            	BOUT1	MOVE.W	D0,D4			; count = message-type
    3057   3002 0000674C 5640            		ADD.W	#3,D0			; ...and this is how much space we'll need
    3058   3003 0000674E 6100 EAD8       		BSR	ROOM
    3059   3004 00006752 665A            		BNE	BOUTX			; quit if not enough room in ring
    3060   3005 00006754 3638 1096       		MOVE.W	PORTNO,D3		; port number
    3061   3006 00006758 6100 EB06       		BSR	SLOR
    3062   3007 0000675C 362C 0008       		MOVE.W	BO_BYT(Rp),D3		; byte position
    3063   3008 00006760 47F8 109C       		LEA	DAT,A3			; compute address within DAT
    3064   3009 00006764 D6C3            		ADD.W	D3,A3
    3065   3010                          	
    3066   3011 00006766 6100 ED14       	BOUT2	BSR	RDBLK			; get another word of input
    3067   3012 0000676A 101B            	BOUT3	MOVE.B	(A3)+,D0		; move another byte
    3068   3013 0000676C 5243            		ADD.W	#1,D3			; advance cursor
    3069   3014 0000676E 536C 000A       		SUB.W	#1,BO_TCN(Rp)		; number of characters left
    3070   3015 00006772 6100 EB08       		BSR	PUTCH
    3071   3016 00006776 5344            		SUB.W	#1,D4			; done yet?
    3072   3017 00006778 670E            		BEQ	BOUT4			; yes...clean up and quit
    3073   3018 0000677A B6FC 10A0       		CMPA.W	#DAT5,A3		; is word exhausted?
    3074   3019 0000677E 66EA            		BNE	BOUT3			; not yet
    3075   3020 00006780 47F8 109C       		LEA	DAT1,A3			; pointer to initial byte
    3076   3021 00006784 4243            		CLR.W	D3			; start at byte 0 again
    3077   3022 00006786 60DE            		BRA	BOUT2
    3078   3023                          	
    3079   3024 00006788 6100 EB3E       	BOUT4	BSR	ELOR			; done...send it on it's way
    3080   3025 0000678C 426C 0008       		CLR.W	BO_BYT(Rp)		; assume next byte is byte 0
    3081   3026 00006790 0C43 0004       		CMP.W	#4,D3			; is current word exhausted?
    3082   3027 00006794 6C08            		BGE	BOUT5			; yes
    3083   3028 00006796 53AC 0004       		SUB.L	#1,BO_TAR(Rp)		; no...back up pointer to read again
    3084   3029 0000679A 3943 0008       		MOVE.W	D3,BO_BYT(Rp)		; save position of next byte
    3085   3030 0000679E 4A6C 000A       	BOUT5	TST.W	BO_TCN(Rp)		; total number left..Done?EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		B L O C K   O U T P U T       15-Apr-88  Page   69
Err Source Ref. Address   value
    line   line

    3086   3031 000067A2 660A            		BNE	BOUTX			; no
    3087   3032 000067A4 11FC 0025 109C  		MOVE.B	#$25,DAT1		; yes...report Bout done
    3088   3033 000067AA 6100 F878       		BSR	BKOTERM			; terminate block-output
    3089   3034                          	
    3090   3035 000067AE 3038 10F8       	BOUTX	MOVE.W	SAVE1,D0		; any more ports?
    3091   3036 000067B2 6600 FF72       		BNE	BOUT			; yes...service another
    3092   3037                          	*	...and fall through to INBKTIM



    3094   3039                          		TTL	'E B U S  --  PDP-10 Base Code,		C O D E'EBUS02.J00/X               E B U S  --  PDP-10 Base Code,		C O D E                       15-Apr-88  Page   70
Err Source Ref. Address   value
    line   line

    3096   3041                          	*		CHECK BLOCK INPUT TIMEOUT
    3097   3042                          	
    3098   3043                          	*	Check to see if 16-seconds has elapsed since last Block-in Data
    3099   3044 000067B6 3038 10F2       	INBKTIM	MOVE.W	BKIHEAD,D0		; anything to do?
    3100   3045 000067BA 6760            		BEQ	FL_BUF			; no...skip to service buffers
    3101   3046 000067BC 3040            	IBM	MOVE.W	D0,A0			; chain down list
    3102   3047 000067BE 31D8 10F8       		MOVE.W	(A0)+,SAVE1		; save NEXT
    3103   3048 000067C2 3010            		MOVE.W	(A0),D0			; get port-number
    3104   3049 000067C4 6100 F0B6       		BSR	SETPORT
    3105   3050 000067C8 2078 1032       		MOVE.L	.FASTC,A0
    3106   3051 000067CC 2010            		MOVE.L	(A0),D0
    3107   3052 000067CE 90AC 000C       		SUB.L	BI_TIM(Rp),D0		; compute time elapsed since last input
    3108   3053 000067D2 0C80 0000 2580  		CMP.L	#9600,D0		; has it exceeded 16 seconds?
    3109   3054 000067D8 6D12            		BLT	IBK1			; no
    3110   3055 000067DA 082C 0006 0001  		BTST	#PF_BFD,P_FLAGS(Rp)	; set Block FilleD
    3111   3056 000067E0 660A            		BNE	IBK1			; already was set
    3112   3057 000067E2 11FC 0029 109C  		MOVE.B	#$29,DAT1		; not set previously...
    3113   3058 000067E8 6100 F86E       		BSR	BKITERM			; terminate Block-input
    3114   3059                          	
    3115   3060 000067EC 3038 10F8       	IBK1	MOVE.W	SAVE1,D0
    3116   3061 000067F0 66CA            		BNE	IBM
    3117   3062                          	
    3118   3063                          	
    3119   3064                          	*	Routine to put data from buffer to Host block
    3120   3065 000067F2 3038 10F2       		MOVE.W	BKIHEAD,D0		; check block-input head
    3121   3066 000067F6 6724            		BEQ	FL_BUF			; nothing to do here
    3122   3067 000067F8 3040            	BBLNK	MOVE.W	D0,A0			; address of next entry
    3123   3068 000067FA 31D8 10F8       		MOVE.W	(A0)+,SAVE1		; save NEXT of this block
    3124   3069 000067FE 3010            		MOVE.W	(A0),D0			; port number
    3125   3070 00006800 6100 F07A       		BSR	SETPORT			; set up port
    3126   3071 00006804 082C 0006 0001  		BTST	#PF_BFD,P_FLAGS(Rp)	; was Block FilleD?
    3127   3072 0000680A 660A            		BNE	MAD20			; yes
    3128   3073 0000680C 4A6C 001E       		TST.W	BCT(Rp)			; no...any of chars in buffer?
    3129   3074 00006810 6704            		BEQ	MAD20			; no
    3130   3075 00006812 6100 0112       		BSR.L	BU_BK			; yes...proceed to move to block
    3131   3076                          	
    3132   3077 00006816 3038 10F8       	MAD20	MOVE.W	SAVE1,D0		; done...is list exhausted?
    3133   3078 0000681A 66DC            		BNE	BBLNK			; no...do another
    3134   3079                          	*					  ...then fall through to next test
    3135   3080                          	
    3136   3081                          	*	Try to flush buffers to PDP's input-ring
    3137   3082 0000681C 3038 10F6       	FL_BUF	MOVE.W	BUFHEAD,D0		; anything to do?
    3138   3083 00006820 6700 F1DC       		BEQ	EXEC			; no...back to beginning of EXEC loop
    3139   3084 00006824 3040            	FL_BUF1	MOVE.W	D0,A0			; chain down list
    3140   3085 00006826 31D8 10F8       		MOVE.W	(A0)+,SAVE1		; save NEXT
    3141   3086 0000682A 3010            		MOVE.W	(A0),D0			; get port-number
    3142   3087 0000682C 6100 F04E       		BSR	SETPORT
    3143   3088 00006830 6114            		BSR	BU_RG			; try to flush some stuff
    3144   3089 00006832 4A6C 001E       		TST.W	BCT(Rp)			; is buffer now empty?
    3145   3090 00006836 6604            		BNE	FL_BUF2			; noEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		C O D E                       15-Apr-88  Page   71
Err Source Ref. Address   value
    line   line

    3146   3091 00006838 6100 F782       		BSR	RBTBUF			; yes...remove buffer from list
    3147   3092                          	
    3148   3093 0000683C 3038 10F8       	FL_BUF2	MOVE.W	SAVE1,D0		; any more in list?
    3149   3094 00006840 66E2            		BNE	FL_BUF1			; proceed if more to do
    3150   3095 00006842 6000 F1BA       		BRA	EXEC			; done...back to start of EXEC loop
    3151   3096                          	
    3152   3097                          	
    3153   3098                          	*	Copy data from BUffer to PDP's input RinG for this port
    3154   3099 00006846 4A6C 001E       	BU_RG	TST.W	BCT(Rp)			; anything in buffer?
    3155   3100 0000684A 6700 00AC       		BEQ.L	BU_EMP			; no, empty...quit
    3156   3101 0000684E 082C 0003 0001  		BTST	#PF_HBP,P_FLAGS(Rp)	; has PDP applied back-pressure?
    3157   3102 00006854 6600 00B6       		BNE.L	BU_XIT			; yes...quit this time around
    3158   3103 00006858 31FC 001E 1094  		MOVE.W	#30,INTYBT		; no...pretend we're doing data
    3159   3104 0000685E 6100 EDF4       		BSR	FDRGSZ			; find space available
    3160   3105 00006862 5578 1092       		SUB.W	#2,INRGSP		; allow for header
    3161   3106 00006866 6F00 00A4       		BLE.L	BU_XIT			; ...but quit if no room
    3162   3107 0000686A 0C78 001E 1092  		CMP.W	#30,INRGSP
    3163   3108 00006870 6F06            		BLE	BU_RG1
    3164   3109 00006872 31FC 001E 1092  		MOVE.W	#30,INRGSP		; don't send more than 30 bytes of data
    3165   3110 00006878 11F8 1097 109D  	BU_RG1	MOVE.B	PORTNO+1,DAT2
    3166   3111 0000687E 4243            		CLR.W	D3			; clear data-counter
    3167   3112 00006880 4278 1094       		CLR.W	INTYBT			; used to record escaped chars
    3168   3113 00006884 47F8 109E       		LEA	DAT3,A3			; place to (begin to) put data
    3169   3114 00006888 4A6C 001E       	BU_RG2	TST.W	BCT(Rp)			; anything left?
    3170   3115 0000688C 672C            		BEQ	BU_RG4			; skip if no more
    3171   3116 0000688E 6100 EE14       		BSR	DGCI			; else get the data
    3172   3117 00006892 0C00 001B       		CMP.B	#ESC,D0			; see if escape
    3173   3118 00006896 6618            		BNE	BU_RG3			; skip if data
    3174   3119 00006898 4A6C 001E       		TST.W	BCT(Rp)			; still data left?
    3175   3120 0000689C 6700 E922       		BEQ	BAD_ESC			; crash if none
    3176   3121 000068A0 6100 EE02       		BSR	DGCI			; else get it
    3177   3122 000068A4 0C00 001B       		CMP.B	#ESC,D0			; see if escaped data
    3178   3123 000068A8 6706            		BEQ	BU_RG3			; skip if so
    3179   3124 000068AA 31C0 1094       		MOVE.W	D0,INTYBT		; else record it
    3180   3125 000068AE 600A            		BRA	BU_RG4			; and skip
    3181   3126                          	
    3182   3127 000068B0 16C0            	BU_RG3	MOVE.B	D0,(A3)+		; save in temp area
    3183   3128 000068B2 5243            		ADD.W	#1,D3			; increment data-counter
    3184   3129 000068B4 B678 1092       		CMP.W	INRGSP,D3		; see if that's all that fits
    3185   3130 000068B8 66CE            		BNE	BU_RG2			; continue if not
    3186   3131                          	
    3187   3132 000068BA 11C3 109C       	BU_RG4	MOVE.B	D3,DAT1			; save data-count
    3188   3133 000068BE 671A            		BEQ	BU_COD			; skip if no data found
    3189   3134 000068C0 0038 0080 109C  		OR.B	#$80,DAT1		; make host data-MSG type
    3190   3135 000068C6 5443            	        ADD.W   #2,D3
    3191   3136 000068C8 47F8 109C       		LEA	DAT,A3
    3192   3137 000068CC 221B            	BU_RG5	MOVE.L	(A3)+,D1		; move data to host-ring
    3193   3138 000068CE 6100 ED22       		BSR	WRPDP			; send it (no need to wait)
    3194   3139 000068D2 5943            		SUB.W	#4,D3
    3195   3140 000068D4 6EF6            		BGT	BU_RG5			; send it all
    3196   3141 000068D6 6100 ED4E       		BSR	PUTIFC			; make sure host sees itEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		C O D E                       15-Apr-88  Page   72
Err Source Ref. Address   value
    line   line

    3197   3142                          	
    3198   3143 000068DA 4A78 1094       	BU_COD	TST.W	INTYBT			; see if terminated by escaped char
    3199   3144 000068DE 6712            		BEQ	BU_RGX			; we're done if not
    3200   3145 000068E0 6100 FB68       		BSR	LOOKUP			; else go translate it
    3201   3146 000068E4 11F8 1097 109D  		MOVE.B	PORTNO+1,DAT2		; install port #
    3202   3147 000068EA 6100 ED00       		BSR	WAITDAT			; wait, then write DAT into host
    3203   3148 000068EE 6100 ED36       		BSR	PUTIFC			; make sure host sees it
    3204   3149                          	
    3205   3150 000068F2 4A6C 001E       	BU_RGX	TST.W	BCT(Rp)			; is buffer now empty?
    3206   3151 000068F6 6614            		BNE	BU_XIT			; no
    3207   3152                          	
    3208   3153 000068F8 08AC 0002 0001  	BU_EMP	BCLR	#PF_IBP,P_FLAGS(Rp)	; clear back-pressure
    3209   3154 000068FE 670C            		BEQ	BU_XIT			; wasn't set
    3210   3155 00006900 3638 1096       		MOVE.W	PORTNO,D3		; was set, must clear...for port,
    3211   3156 00006904 183C 00A1       		MOVE.B	#$A1,D4			; release back-pressure
    3212   3157 00006908 6100 E9D0       		BSR	SENDQI			; send Quick ISIS message
    3213   3158                          	
    3214   3159 0000690C 4E75            	BU_XIT	RTS				; return
    3215   3160                          	
    3216   3161                          	
    3217   3162                          	*	Put the current port onto the buffer-list
    3218   3163 0000690E 3078 10F0       	BU_ADD	MOVE.W	BLKFREE,A0		; get an entry off free-list
    3219   3164 00006912 31D0 10F0       		MOVE.W	(A0),BLKFREE		; unlink from free-list
    3220   3165 00006916 30B8 10F6       		MOVE.W	BUFHEAD,(A0)		; link list-head to element
    3221   3166 0000691A 3178 1096 0002  		MOVE.W	PORTNO,2(A0)		; second word is port-number
    3222   3167 00006920 31C8 10F6       		MOVE.W	A0,BUFHEAD		; place this element as new list-head
    3223   3168 00006924 4E75            		RTS				; done...return
    3224   3169                          	
    3225   3170                          	
    3226   3171                          	*	Copy from Buffer to Block:  If terminated by Block-full
    3227   3172                          	*	or Yellow-Ball (EOT), then report termination;  if by EOT, then
    3228   3173                          	*	report Yellow-ball also.
    3229   3174 00006926 382C 0014       	BU_BK	MOVE.W	BI_TCN(Rp),D4		; copy of # of chars expected
    3230   3175 0000692A 6100 ECA0       		BSR	GETBLK			; get the current word
    3231   3176 0000692E 366C 0018       		MOVE.W	BI_BYT(Rp),A3		; cursor within DAT
    3232   3177 00006932 47EB 109C       		LEA	DAT(A3),A3		; address of current byte
    3233   3178 00006936 4278 1094       		CLR.W	INTYBT			; used to record control-codes
    3234   3179                          	
    3235   3180                          	*	Copy until buffer-empty, block-full, or found control-code
    3236   3181 0000693A 4A6C 001E       	BU_BK1	TST.W	BCT(Rp)			; anything there?
    3237   3182 0000693E 673E            		BEQ	BU_BK3			; no, buffer empty...skip
    3238   3183 00006940 B86C 0016       		CMP.W	BI_LCN(Rp),D4		; block full?
    3239   3184 00006944 6738            		BEQ	BU_BK3			; no...skip
    3240   3185 00006946 6100 ED5C       		BSR	DGCI			; get the char
    3241   3186 0000694A 0C00 001B       		CMP.B	#ESC,D0			; ESC?
    3242   3187 0000694E 6618            		BNE	BU_BK2			; no..skip to place the data
    3243   3188 00006950 4A6C 001E       		TST.W	BCT(Rp)			; yes...anything else there?
    3244   3189 00006954 6700 E86A       		BEQ	BAD_ESC			; no, buffer now empty...fatal error
    3245   3190 00006958 6100 ED4A       		BSR	DGCI			; get the code
    3246   3191 0000695C 0C00 001B       		CMP.B	#ESC,D0			; ESC?
    3247   3192 00006960 6706            		BEQ	BU_BK2			; yes, data...skip to place it in blockEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		C O D E                       15-Apr-88  Page   73
Err Source Ref. Address   value
    line   line

    3248   3193 00006962 31C0 1094       		MOVE.W	D0,INTYBT		; no...save as termination-code
    3249   3194 00006966 6016            		BRA	BU_BK3			; and skip to terminate copy
    3250   3195                          	
    3251   3196 00006968 16C0            	BU_BK2	MOVE.B	D0,(A3)+		; save data char
    3252   3197 0000696A 526C 0016       		ADD.W	#1,BI_LCN(Rp)		; count it
    3253   3198 0000696E B6FC 10A0       		CMPA.W	#DAT5,A3		; have we exhausted DAT?
    3254   3199 00006972 6DC6            		BLT	BU_BK1			; no
    3255   3200 00006974 6100 EC2E       		BSR	WRBLK			; yes
    3256   3201 00006978 47F8 109C       		LEA	DAT,A3			; reset word cursor
    3257   3202 0000697C 60BC            		BRA	BU_BK1
    3258   3203                          	
    3259   3204                          	*	done with copy (for this pass)
    3260   3205 0000697E 96FC 109C       	BU_BK3	SUB.W	#DAT,A3			; compute displacement
    3261   3206 00006982 394B 0018       		MOVE.W	A3,BI_BYT(Rp)		; save it for next time
    3262   3207 00006986 6708            		BEQ	BU_BK4			; at beginning of word?
    3263   3208 00006988 6100 EC1A       		BSR	WRBLK			; no...write partial word into PDP
    3264   3209 0000698C 53AC 0010       		SUB.L	#1,BI_TAR(Rp)		; back up word-cursor
    3265   3210 00006990 11FC 0027 109C  	BU_BK4	MOVE.B	#$27,DAT1		; assume terminated by FULL
    3266   3211 00006996 B86C 0016       		CMP.W	BI_LCN(Rp),D4
    3267   3212 0000699A 6724            		BEQ	BU_BK5			; skip if that's reason
    3268   3213 0000699C 5238 109C       		ADD.B	#1,DAT1			; no...assume terminated by EOT
    3269   3214 000069A0 0C78 00AC 1094  		CMP.W	#YB_CODE,INTYBT		; see if Yellow-ball found
    3270   3215 000069A6 6718            		BEQ	BU_BK5			; skip if so
    3271   3216 000069A8 2478 1032       		MOVE.L	.FASTC,A2		; else record current time
    3272   3217 000069AC 2952 000C       		MOVE.L	(A2),BI_TIM(Rp)
    3273   3218 000069B0 4A78 1094       		TST.W	INTYBT			; terminated by stream-code?
    3274   3219 000069B4 6700 FF3C       		BEQ	BU_RGX			; no...just exit (but check for BP)
    3275   3220 000069B8 6100 FF20       		BSR	BU_COD			; yes...send it to host
    3276   3221 000069BC 6000 FF68       		BRA	BU_BK			; then continue copying
    3277   3222                          	
    3278   3223                          	*	Block-input terminated
    3279   3224 000069C0 6100 F696       	BU_BK5	BSR	BKITERM			; terminate block-input
    3280   3225 000069C4 6000 FF14       		BRA	BU_COD			; send code if encountered, and exitEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		C O D E                       15-Apr-88  Page   74
Err Source Ref. Address   value
    line   line

    3282   3227                          	
    3283   3228                          	
    3284   3229                          	
    3285   3230                          		ORG	$7C00
    3286   3231                          	
    3287   3232                          	*	D0 is the high order 32 bits to write to pdp-10
    3288   3233                          	*	D1 last 4 bits are the low order 4 bits to write to 10
    3289   3234                          	*	D2 is the start addr of the test
    3290   3235                          	*	D3 is the ending addr of the test
    3291   3236                          	*	D4 is the counter of mismatch between read and write
    3292   3237                          	*	D5 is the high order 32 bits read from 10's memory
    3293   3238                          	*	D6 last 4 bits are the low order 4 bits read from 10
    3294   3239                          	
    3295   3240 00007C00 4A79 00D0 1038  	STARTES	TST.W	DEXCO			; Reset EBUS
    3296   3241 00007C06 4238 10D2       		CLR.B	BLK
    3297   3242 00007C0A 4284            		CLR.L	D4			; Initialize the mismatch counter
    3298   3243 00007C0C                 	STATE12	PUSHM	D0-D4
    3299   3245 00007C10 31C2 1040       		MOVE.W	D2,P10ADR		; move in addr(only half-word long)
    3300   3246 00007C14 21C0 103A       		MOVE.L	D0,P10DAH		; first 32 bits of data
    3301   3247 00007C18 0201 000F       		AND.B	#$0F,D1			; only need last 4 bits
    3302   3248 00007C1C 11C1 103E       		MOVE.B	D1,P10DLL		; last 4 bits of data
    3303   3249 00007C20 6100 D8B8       		BSR	WR10R			; write it to 10. memory
    3304   3250 00007C24 42B8 103A       		CLR.L	P10DAH			; clear out read area
    3305   3251 00007C28 4238 103E       		CLR.B	P10DLL
    3306   3252 00007C2C 6100 D73E       		BSR	RD10R			; read it back from 10's memory
    3307   3253 00007C30                 		POPM	D0-D4
    3308   3255 00007C34 4285            		CLR.L	D5
    3309   3256 00007C36 4286            		CLR.L	D6
    3310   3257 00007C38 2A38 103A       		MOVE.L	P10DAH,D5		; first 32 bits read rom 10
    3311   3258 00007C3C 1C38 103E       		MOVE.B	P10DLL,D6
    3312   3259 00007C40 0201 000F       		AND.B	#$0F,D1
    3313   3260 00007C44 B085            		CMP.L	D5,D0
    3314   3261 00007C46 6608            		BNE	SUB7			; go mismatch routine
    3315   3262 00007C48 B206            		CMP.B	D6,D1
    3316   3263 00007C4A 6604            		BNE	SUB7			; go mismatch routine if not =
    3317   3264 00007C4C 4287            		CLR.L	D7			; no mismatch add 0 to counter(d4)
    3318   3265 00007C4E 6002            		BRA	NO77
    3319   3266                          	
    3320   3267 00007C50 7E01            	SUB7	MOVE.L	#1,D7			; add 1 to counter D4 on mismatch
    3321   3268 00007C52 D887            	NO77	ADD.L	D7,D4			; add to mismatch counter
    3322   3269 00007C54 5242            		ADD.W	#1,D2			; bump to next addr in 10 memory
    3323   3270 00007C56 B682            		CMP.L	D2,D3			; if biggert than end addr
    3324   3271 00007C58 6CB2            		BGE	STATE12			; no go another loop
    3325   3272 00007C5A 2249            	NOMLOP	MOVE.L	A1,A1
    3326   3273 00007C5C 60FC            		BRA	NOMLOP			; just dummy loopEBUS02.J00/X               E B U S  --  PDP-10 Base Code,		C O D E                       15-Apr-88  Page   75
Err Source Ref. Address   value
    line   line

    3328   3275                          	*	Special diagnostics for manual operation and testing
    3329   3276                          	
    3330   3277                          	
    3331   3278                          	
    3332   3279                          	
    3333   3280                          		ORG	$7D00
    3334   3281 00007D00 31C2 1040       	CONWRT	MOVE.W	D2,P10ADR
    3335   3282 00007D04 11FC 0001 10FC  		MOVE.B	#1,DIAG			; set DIAG > 0
    3336   3283 00007D0A 21C0 103A       		MOVE.L	D0,P10DAH
    3337   3284 00007D0E 0201 000F       		AND.B	#$0F,D1
    3338   3285 00007D12 11C1 103E       		MOVE.B	D1,P10DLL
    3339   3286 00007D16 4A79 00D0 1038  	WRTERR	TST.W	DEXCO			; Reset EBUS
    3340   3287 00007D1C 6100 D7BC       		BSR	WR10R
    3341   3288 00007D20 3A3C 0064       		MOVE.W	#100,D5
    3342   3289 00007D24 5345            	WRERL	SUB.W	#1,D5
    3343   3290 00007D26 66FC            		BNE	WRERL
    3344   3291 00007D28 60EC            		BRA	WRTERR
    3345   3292                          	
    3346   3293                          	
    3347   3294                          	
    3348   3295                          	
    3349   3296                          	
    3350   3297                          		ORG	$7E00
    3351   3298 00007E00 11FC 00FF 10FC  		MOVE.B	#-1,DIAG		; set DIAG < 0
    3352   3299 00007E06 31C2 1040       		MOVE.W	D2,P10ADR
    3353   3300 00007E0A 4A79 00D0 1038  	REDERR	TST.W	DEXCO			; Reset EBUS
    3354   3301 00007E10 6100 D55A       		BSR	RD10R
    3355   3302 00007E14 3A3C 0064       		MOVE.W	#100,D5
    3356   3303 00007E18 5345            	RELOP	SUB.W	#1,D5
    3357   3304 00007E1A 66FC            		BNE	RELOP
    3358   3305 00007E1C 60EC            		BRA	REDERR
    3359   3306                          	
    3360   3307                          	
    3361   3308                          	*	Return here on diagnostic error
    3362   3309 00007E1E 4A38 10FC       	DIAGERR	TST.B	DIAG			; which diagnostic are we doing?
    3363   3310 00007E22 6DE6            		BLT	REDERR			; < 0...read diagnostic
    3364   3311 00007E24 6000 FEF0       		BRA	WRTERR			; > 0...write diagnostic
    3365   3312                          	
    3366   3313                          	
    3367   3314                          		TTL	'E B U S  --  PDP-10 Base Code'
    3368   3315 00007E28                 		END	ENTRYEBUS02.J00/X               E B U S  --  PDP-10 Base Code                                 15-Apr-88  Page   76

                               Symbol Table

 AUXC        00001058   AUXERR      000065EE   AUXKEY      00000003   AUXQ        00001050   AUXTIM      00001052
 AUXX        00001056   BADKEY      000057E8   BAD_ESC     000051C0   BB          0000001A   BBLNK       000067F8
 BCRASH      0000518E   BCT         0000001E   BE          0000001C   BFLSIZ      00000010   BI_BYT      00000018
 BI_LCN      00000016   BI_TAR      00000010   BI_TCN      00000014   BI_TIM      0000000C   BKIHEAD     000010F2
 BKITERM     00006058   BKOHEAD     000010F4   BKOTERM     00006024   BKPR        000010E2   BLACK       0000640A
 BLK         000010D2   BLKFREE     000010F0   BLKK1       00005510   BLKK2       0000538C   BLKMAP      000050CE
 BLOKIN      0000619E   BOBCODE     00004F24   BOK1        00005F3A   BOK2        00005FC2   BOK22       00005FE2
 BOK3        00006018   BOK4        00006038   BOK5        00006078   BOUT        00006726   BOUT1       0000674A
 BOUT2       00006766   BOUT3       0000676A   BOUT4       00006788   BOUT5       0000679E   BOUTX       000067AE
 BO_BYT      00000008   BO_TAR      00000004   BO_TCN      0000000A   BPOFF       000063EA   BPON        000063E2
 BTRACE      00000000   BUFER       00008000   BUFEREND    0000F000   BUFHEAD     000010F6   BUSCRAS     0000580E
 BU_ADD      0000690E   BU_BK       00006926   BU_BK1      0000693A   BU_BK2      00006968   BU_BK3      0000697E
 BU_BK4      00006990   BU_BK5      000069C0   BU_COD      000068DA   BU_EMP      000068F8   BU_RG       00006846
 BU_RG1      00006878   BU_RG2      00006888   BU_RG3      000068B0   BU_RG4      000068BA   BU_RG5      000068CC
 BU_RGX      000068F2   BU_XIT      0000690C   C1          000057DC   CARRTS      0000569E   CARWRAP     00005670
 CASHW       0000100C   CCTBD       00003938   CLEANUP     0000609E   CODCASH     00001004   CONWRT      00007D00
 CTRACE      00000000   DAT         0000109C   DAT1        0000109C   DAT2        0000109D   DAT3        0000109E
 DAT4        0000109F   DAT5        000010A0   DEBUG       00000000   DEMPTY      000057B0   DEXC1       00D010B8
 DEXCO       00D01038   DGCI        000056A4   DGCI1       000056DA   DGCI2       000056DC   DGCIH       000051C8
 DIAG        000010FC   DIAGERR     00007E1E   DOBKOUT     00006716   DOKEY       000058A8   DOKEYX      000058CA
 DPEEK       000056F0   DPEEK1      00005720   DPEEK2      00005724   DPEEKX      00005730   DPER        00D00138
 DPORT       000059BA   DPORT1      000059CC   DSENS       00D000B8   DTMOT       00D001B8   DWCI        00005732
 DWCI2       00005758   DWCI3       00005764   DWCI4       0000577C   DWCI5       0000578A   DWCIH       000051D0
 ECHOFF      00005DE8   ECHOON      00005DE0   ELIR        00005356   ELIR2       00005366   ELOR        000052C8
 ELOR21      000052D6   EMP1        00005916   EMP2        0000593E   EMP3        0000594C   EMP4        00005950
 EMP5        00005956   EMP6        00005964   EMPTY       0000590E   ENDZERO     000038FE   ENGINE      FFFFF901
 ENGVECT     0000013C   ENTRY       00004F00   ESC         0000001B   ETRACE      0003FFE0   EVENBON     00005312
 EXEC        000059FE   EXEC1       00005A10   EXEC2       00005A1A   EXEC3       00005A1E   EXEC4       00005A26
 FDRGSZ      00005654   FFCRA       00004F5A   FLUSH       00005350   FL_BUF      0000681C   FL_BUF1     00006824
 FL_BUF2     0000683C   FREEBLK     000010FE   GEHTLN      00005B0A   GETBLK      000055CC   GETCH       00005302
 GETCH1      00005326   GETH        00005328   GETH1       0000533A   GETIEC      000054A4   GETIOWA     00004F7E
 GETOFC      000054B4   GETPDPL     00005418   GETPDPR     0000542A   GETUN       000062EE   GETW        0000533C
 GETW1       0000534E   GOBBLER     000063F2   GRAY        00006404   HALFSEC     00006636   HALFSEX     00006716
 HCRASH      00005542   HDN1        00005856   HDN2        00005872   HDN3        0000587A   HDOWN       00005842
 HDOWNR      00006684   HODOWN      0000583C   HOSTN       00001042   HOSTOUT     00005A46   HOSTP       00001044
 HOSTTO      00001048   HOUT1       00005AAC   HOUT2       00005ABC   HOUT3       00005ACA   HOUTX       00005ACE
 HREPRT      000058CC   HREPRTX     0000590C   HST1        00005BC4   HST2        00005BCC   HSTAT       00001046
 HSTSAD      00005DA8   HSTUNA      0000661C   HTDWN       00001081   HTM         000010D8   HUPR        00006654
 HUPR1       00006656   HUPR2       0000667A   IBK1        000067EC   IBM         000067BC   IBRATE      00000003
 ILOG        00006502   IMESS       0000633E   IMSSZ       00005970   IMSTAB      00006388   INBKTIM     000067B6
 INISLN      0000657E   INIT0       0000500C   INIT1       00005084   INITIAL     00005000   INRGFL      000060A4
 INRGSP      00001092   INTRPT      00004F4C   INTYBT      00001094   IPORT       000059A2   IPORT1      000059B0
 IPORT2      000059B2   IPTIME      000065C6   IPZ         00006562   IPZSZ       00005994   IPZTAB      00006590
 IRING       0000102A   IRRN        000010E4   IRSIZE      00001036   ISISIN      000060AA   ISISIN1     00006114
 ISISIN2     0000611A   ISISIN3     0000612E   ISISIN4     00006140   ISMGER      000051AC   ISP         00006444
 ISPTAB      0000645C   ISTOME      00001012   IS_BK       000061A6   IS_BK1      000061B6   IS_BK2      000061E0
 IS_BK3      000061F2   IS_BK4      00006204   IS_BU       00006160   IS_BU1      00006182   IS_BU2      00006194
 IS_BUF      00006156   ITERM       0000646C   ITRACE      00000000   LASCOU      000010E0   LFASTC      000010DC
 LNKEND      00005FAC   LNKLOP      00005F90   LOGFAL      000064DA   LOGFAL1     000064DE   LOOK        000052E2
 LOOKUP      0000644A   MAD20       00006816   MAXPORT     00000100   MERROR      000057F0   METOIS      00001016
 METOSL      0000101E   MNGOOD      0000670E   MXPORT      0000104C   NARG        00000000   NBFLTS      000010EC
 NCCT        000010D0   NEE2        0000631A   NEEDLE      0000621A   NO77        00007C52   NOCAL       00005B1CEBUS02.J00/X               E B U S  --  PDP-10 Base Code                                 15-Apr-88  Page   77

 NOCAL5      00005B20   NODALN      00005690   NOIRING     00005300   NOJAP       0000647E   NOJAP1      00005E3A
 NOJAP2      00005EBC   NOKEY       000057E0   NOMLOP      00007C5A   NORNODE     00001098   NORPORT     0000109A
 NPORTS      0000104E   NSIZ        000010D1   ODDBON      00005318   OFFBP       00005C1A   OMTAB       00005B38
 ONBP        00005C04   OPEN        00005BA0   OPSHT       00005BA6   ORING       00001026   ORRN        000010E6
 ORSIZE      00001038   OTFRHST     00005B22   P10ADR      00001040   P10DAH      0000103A   P10DAL      0000103C
 P10DLL      0000103E   PARERR      00005806   PATCHR      00004000   PCCASH      00001008   PDPIEC      0000108E
 PDPIFC      00001090   PDPIRP      0000108A   PDPISZ      0000108C   PDPOEC      00001088   PDPOFC      00001086
 PDPORP      00001082   PDPOSZ      00001084   PD_SIZ      00000020   PFULL       000010FB   PFULL1      000064BC
 PF_ACT      00000000   PF_BFD      00000006   PF_BKI      00000005   PF_BKO      00000004   PF_HBP      00000003
 PF_IBP      00000002   PF_OBP      00000001   PNEDL       0000648E   PORTNO      00001096   PORTS       000018FE
 PRODID      00000091   PTAL2       00005E8E   PTALL       00005E8C   PTERM       00005E62   PTMSN1      00005EC6
 PTMSND      00005E9C   PUEVEN      00005292   PUTC1       000052A2   PUTCH       0000527C   PUTH        000052A8
 PUTH11      000052B6   PUTIFC      00005626   PUTNOT0     0000552E   PUTODD      00005298   PUTOEC      00005638
 PUTPDPL     00005574   PUTPDPR     0000558C   PUTPN       00006094   PUTPORT     000050E6   PUTUN       00006300
 PUTUN1      0000630A   PUTW        000052B8   PUTW11      000052C6   P_FLAGS     00000001   P_NUM       00000000
 RBTALL      0000588C   RBTBKI      00005FAE   RBTBKO      00005F82   RBTBUF      00005FBC   RD101       00D0403A
 RD102       00D0403E   RD103       00D04038   RD104       00D0403C   RD10AG      00005372   RD10R       0000536C
 RD10R1      00005374   RD10R2      000053A2   RDBLK       0000547C   RDPDP       00005448   RDPDP1      00005472
 RDSNB       000053DC   RDSNB1      000053F6   REDERR      00007E0A   REGDMP      00005156   REGDMPX     0000518C
 RELOP       00007E18   RESET       00005BE2   RNOWRAP     00005236   ROOM        00005228   ROOMB       00005240
 ROOMG       0000523E   RTRACE      00000001   R_TANK      000010EE   SAVE1       000010F8   SCLKR       00005F36
 SEND17      00005CF0   SENDDAT     0000609A   SENDQI      000052DA   SETBLKA     000054C4   SETPORT     0000587C
 SHNUM       00005EE4   SHNUM1      00005EFC   SHNUM2      00005EFE   SHNUM3      00005F14   SHNUM4      00005F1E
 SHUT        00005BA4   SLOR        00005260   SLOWC       000010D4   SLTOME      0000101A   SMTLMT      0000654E
 SNTO        00006084   SPEC        00005C52   SPEC1       00005C5C   SPTAB       00005C72   STARTES     00007C00
 STATE12     00007C0C   STERM       00005DEE   STERM1      00005DF6   STERM2      00005E22   STERM3      00005E56
 STKTOP      00001000   STRACE      00020000   STREAM      0000642C   STREAM1     00006432   SUB7        00007C50
 SUPLOG      00005D06   SUPLOP      00005D78   SUPOUT      00005D3E   SUPR1       00005CCE   SUPREC      00005CAC
 SUPTAK      000065B2   TEXTEND     00005B02   TEXTLOP     00005AE8   TEXTMSG     00005AD2   TIMCHK      00005BB2
 TMOC        000010FA   TMOUT       000053E4   TMOUT1      000057FE   TOHOST      0000104A   TP          00005D8A
 TRACE0      000051D8   TRACE1      000051DA   TRACE2      000051E6   TRACE3      000051FA   TRACE4      000051FE
 TRACING     00000001   TRHSTLN     000038FE   TRISLN      00006364   TR_PORT     00001010   TR_RIN      00005204
 TR_ROUT     00005216   TSLOWC      00005BD8   TYPBYT      00001080   UNLINK      00005F8E   VCRASH      0000581C
 VERIFY      0000662C   VERSION     00000200   WAIT        00005256   WAITDAT     000055EC   WAITIS      0000524E
 WAITISW     00005246   WAITPDP     0000564A   WR10R       000054DA   WR10R1      000054DC   WRBLK       000055A4
 WRDAT       000055EE   WRE         000057A2   WREH        00005816   WRERL       00007D24   WRINRG      00005614
 WRIRTS      0000561C   WRPDP       000055F2   WRSNB       00005526   WRTERR      00007D16   WT101       00D0803A
 WT102       00D0803C   WT103       00D0803E   WT104       00D08038   XMITLMT     00000002   YB_CODE     000000AC
 YELLOW      00006412   ZAP         00005C38   ZAPPER      000063D0   ZERO        00001042   .BFLTS      000010E8
 .FASTC      00001032   .SLOWC      0000102E   .SYNC       00001022   .TRACE      00001000 @0x