			
				SUBTTL	FMAIN - CB2033.F01 - This is the foreground for Carl's slot
			
010616				SEG	A.CODE
				MO	.,FMAIN		: Start of module FMAIN
			
000001			SYN1	EQ	1		: LUN of sync line
000020			RTLMAX	EQ	20		: Maximum size of buffer ring
			
				GL	FSTART		: Entry point (called from background)
				GL	SYNCBF		: Put/Get SYNC buffer
				GL	STORHW		: Fill buffer
			
						
0000D6				SEG	A.DATA			: Separate section for I/O data
			
0000D8				WS	0			: same as BND 4
			
0000D8	0000 0100 	RTLLST	WC	RTL001			: Address to check
0000DC	0001 0200 	RTLCMD	HC	1,200			: Write, 200 bytes
000008			RTLSIZ	EQ	.-RTLLST		: Entry size
0000E0	0000 0108 		WC	RTL002			: Address of list entry 2
0000E4	0001 0200 		HC	1,200			: Write, 200 bytes
0000E8	0000 0110 		WC	RTL003			: Address of list entry 3
0000EC	0002 0000 		HC	2,0			: Transfer, no buffer
000018			RTLLEN	EQ	.-RTLLST
			
0000F0			RTLCNT	HS	1			: Count times found 0
0000F2			RTLONE	HS	1			: Count times found 1
			
			
000100				BND	100			: Probably locate at <100>
000100	0001 0200 	RTL001	HC	1,200			: Write, 200 bytes
000104	0000 0200 	RTLBUF	WC	BUFPAD			: Buffer 1
000108	0001 0200 	RTL002	HC	1,200			: Write, 200 bytes
00010C	0000 0200 	RTLALT	WC	BUFPAD			: Buffer 2
000110	0002 0000 	RTL003	HC	2,0			: Transfer, 0 byte buffer
000114	0000 0100 		WC	RTL001			: Loop back to here
			
000200				BND	100		: Make it a block boundary
000200			BUFPAD	HS	200			: Idle padding buffer
000600			BUFBUF	HS	200			: Normal buffer
000A00			BUFALT	HS	200			: Alternate buffer
000E00			BUF000	HS	200
001200			BUF001	HS	200
001600			BUF002	HS	200
			
001A00			PTRIN	HS	1			: My pointer
001A02			BUFIN	HS	1			: His pointer
001A04				HS	200			: Buffer to use ( 200 bytes )
			
001E04	0010 0000 0010 	RTLPTR	HC	4*4,4*0,4*4,4*4			: ptr offsets
	0010 		
001E0C	0000 0600 0000 		WC	BUFBUF,BUFALT,BUF000,BUF001	: buffer addresses
	0A00 0000 0E00 	
	0000 1200 	
000018			RTLINL	EQ	.-RTLPTR			: length of table
			
001E1C			RTL.TF	HS	1			: BG wrote to here ==>   To FG
001E1E			RTL.FF	HS	1			: BG reads to here ==> From FG
001E20			RTL.TB	HS	1			: FG wrote to here ==>   To BG
001E22			RTL.FB	HS	1			: FG reads to here ==> From BG
001E24			RTL.BF	WS	RTLMAX			: Buffer address ring for RTL
			
						
001EA4	30BF 0A0D BFC6 	FATSIC	SC	\?"0A"0D?FATSIC Fatal -- Sync Input Connect failure"0A"0D\
	C1D4 D3C9 C3A0 	
	C6E1 F4E1 ECA0 	
	ADAD A0D3 F9EE 	
	E3A0 C9EE F0F5 	
	F4A0 C3EF EEEE 	
	E5E3 F4A0 E6E1 	
	E9EC F5F2 E50A 	
	0D		
001ED5	31 BF0A 0DBF C6	FATSOC	SC	\?"0A"0D?FATSOC Fatal -- Sync Output Connect failure"0A"0D\
	C1 D4D3 CFC3 A0	
	C6 E1F4 E1EC A0	
	AD ADA0 D3F9 EE	
	E3 A0CF F5F4 F0	
	F5 F4A0 C3EF EE	
	EE E5E3 F4A0 E6	
	E1 E9EC F5F2 E5	
	0A 0D		
001F07	2C BF0A 0DBF C6	FATSRW	SC	\?"0A"0D?FATSRW Fatal -- Sync Ring Wrap failure"0A"0D\
	C1 D4D3 D2D7 A0	
	C6 E1F4 E1EC A0	
	AD ADA0 D3F9 EE	
	E3 A0D2 E9EE E7	
	A0 D7F2 E1F0 A0	
	E6 E1E9 ECF5 F2	
	E5 0A0D 	
001F34	2DBF 0A0D BFC6 	FATXGT	SC	\?"0A"0D?FATXGT Fatal -- eXception on GT pointer"0A"0D\
	C1D4 D8C7 D4A0 	
	C6E1 F4E1 ECA0 	
	ADAD A0E5 D8E3 	
	E5F0 F4E9 EFEE 	
	A0EF EEA0 C7D4 	
	A0F0 EFE9 EEF4 	
	E5F2 0A0D 	
			
001F62	2FA5 0A0D A5D7 	WRNBSC	SC	\%"0A"0D%WRNBSC Warning -- Bad Sync output Command"0A"0D\
	D2CE C2D3 C3A0 	
	D7E1 F2EE E9EE 	
	E7A0 ADAD A0C2 	
	E1E4 A0D3 F9EE 	
	E3A0 EFF5 F4F0 	
	F5F4 A0C3 EFED 	
	EDE1 EEE4 0A0D 	
			
						
010616				SEG	A.CODE
			
010616	E600 4000 1EA4 	FSTART	LA	R0,FATSIC,,		: An appropriate error message
01061C	C810 0001 		LHI	R1,SYN1			: Load logical unit #
010620	E620 4000 1A02 		LA	R2,BUFIN,,		: And buffer
010626	C830 0202 		LHI	R3,2+200		: Header + buffer size
01062A	E130 0001 		SVC	IO,01			: Begin input
01062E	4300 817C 		  J	GIVEUP			: Hmm, something is wrong
			
010632	E610 4000 0200 		LA	R1,BUFPAD,,		: Address of pad buffer
010638	5010 4000 0104 		ST	R1,RTLBUF,,		: Store in main buffer
01063E	5010 4000 010C 		ST	R1,RTLALT,,		: Store in alternate buffer
			
010644	C800 FFFF 		LHI	R0,0FFFF		: What to store
010648	4000 4000 00F0 		STH	R0,RTLCNT,,		: Zero count
01064E	4000 4000 00F2 		STH	R0,RTLONE,,		:  of finds
010654	E610 4000 0200 		LA	R1,BUFPAD,,		: Where
01065A	C820 0200 		LHI	R2,200			: Number of halfwords
01065E	4140 4001 07BA 		JAL	R4,STORHW,,		: Store in buffer
			
			:  Use of R10 - R15 for this instruction to copy data to initial buffer
010664	D1A0 1E04 		LM	R10,RTLPTR		: Get initial buffer constants
010668	D0A0 1E1C 		STM	R10,RTL.TF		: Store initial buffer constants
			
01066C	E600 4000 1ED5 		LA	R0,FATSOC,,		: An appropriate error message
010672	C810 0001 		LHI	R1,SYN1			: Load logical unit #
010676	E620 4000 0100 		LA	R2,RTL001,,		: And beginning of rotor list
01067C	E130 0011 		SVC	IO,11			: Begin output
010680	4300 812A 		  J	GIVEUP			: Hmm, something wrong!
			
010684	E100 0000 	FGLOOP	SVC	DISMIS			: Look at things next time
			
				: Look at sync input here!!!
			
						
			: Now for sync output
			
010688	2410 			LIS	R1,0			: Get initial offset
01068A	C910 0018 	RTLOOP	CHI	R1,RTLLEN		: Are we done?
01068E	4330 FFF2 		  JE	FGLOOP			: Seems so to me
010692	5821 4000 00D8 		L	R2,RTLLST,R1,		: Load address
010698	4802 0000 		LH	R0,0,R2			: Has sync finished with rotor entry?
01069C	4230 807E 		  JN	RTLNXT			: Not as I can see
0106A0	4801 4000 00DC 		LH	R0,RTLCMD,R1,		: Get the command type
0106A6	C900 0001 		CHI	R0,1			: Is it a write?
0106AA	4230 8078 		  JN	CHKTRN			: No, check transfer
			
0106AE	5802 4000 0004 		L	R0,4,R2,		: Pull address from rotor
0106B4	F900 0000 0200 		CI	R0,BUFPAD		: Is it a padding buffer?
0106BA	4330 802C 		  JE	RTLNGT			: Yes, nothing to return
			
0106BE	4830 4000 1E20 		LH	R3,RTL.TB,,		: Get pointer
0106C4	4930 4000 1E22 		CH	R3,RTL.FB,,		: Does it match? cannot pass FB
0106CA	4330 1F07 		  JE	FATSRW			: Yes, no room - should't happen
0106CE	5003 4000 1E24 		ST	R0,RTL.BF,R3,		: Put buffer address into list
0106D4	2634 			AIS	R3,4*1			: Move to next entry
0106D6	C930 0080 		CHI	R3,4*RTLMAX		: At end of ring?
0106DA	2132 			  JNFS	NWRPTB			: No, skip ahead
0106DC	2430 			LIS	R3,0			: Yes, reset to top
0106DE	4030 4000 1E20 	NWRPTB	STH	R3,RTL.TB,,		: Ok, remember the pointer
			
0106E4	E600 4000 0200 		LA	R0,BUFPAD,,		: Default buffer if none available
0106EA	4830 4000 1E22 	RTLNGT	LH	R3,RTL.FB,,		: Get pointer to next
0106F0	4930 4000 1E1C 		CH	R3,RTL.TF,,		: Does it match?  cannot pass TF
0106F6	233B 			  JEFS	SETPAD			: Yes, set padding and finish up
0106F8	5803 4000 1E24 		L	R0,RTL.BF,R3,		: Get buffer address from list
0106FE	2634 			AIS	R3,4*1			: Move to next entry
010700	C930 0080 		CHI	R3,4*RTLMAX		: At end of ring?
010704	2132 			  JNFS	NWRPFB			: No, skip ahead
010706	2430 			LIS	R3,0			: Yes, reset to top
010708	4030 1E22 	NWRPFB	STH	R3,RTL.FB		: Store pointer
01070C	5002 4000 0004 	SETPAD	ST	R0,4,R2,		: Store into rotor list
010712	4801 4000 00DC 		LH	R0,RTLCMD,R1,		: Get "write" command from RTLLST
010718	4002 4000 0000 		STH	R0,0,R2,		: Set it in the rotor list
01071E	CA10 0008 	RTLNXT	AHI	R1,RTLSIZ		: Bump to the next RTLLST entry
010722	4300 FF64 		J	RTLOOP			: Check next rotor entry
			
010726	C900 0002 	CHKTRN	CHI	R0,2			: Is it a transfer
01072A	4230 8060 		  JN	ERRBSC			: Bad command type
01072E	5800 4000 00D8 		L	R0,RTLLST,,		: Transfer, get beginning
010734	4300 FFD4 		J	SETPAD			:  address and store it
						
			: SYNCBF - Called from background to store a full sync buffer
			:	   Called from background to get an empty sync buffer
			:
			: call:
			:	R0 = 0	No buffer supplied, just get a free buffer
			:	R0 # 0	Buffer supplied, also get a new free buffer
			:	JAL	R4,SYNCBF
			:
			: non-skip return:
			:	R0 = 0	No buffers available, please wait
			:	R0 # 0	R0 contains what was passed
			:
			: skip return:
			:	R0 # 0	R0 contains a new empty buffer
			:
			
010738	C900 0000 	SYNCBF	CHI	R0,0			: Test for 0
01073C	4330 8026 		  JE	GSYNBF			: Nothing here, go get a buffer
010740	4830 4000 1E1C 		LH	R3,RTL.TF,,		: Get pointer to next
010746	4930 4000 1E1E 		CH	R3,RTL.FF,,		: Does it match?  cannot pass FF
01074C	0334 			  JER	R4			: No room for buffer, non-skip
01074E	5003 4000 1E24 		ST	R0,RTL.BF,R3,		: Put buffer address from list
010754	2634 			AIS	R3,4*1			: Move to next entry
010756	C930 0080 		CHI	R3,4*RTLMAX		: At end of ring?
01075A	2132 			  JNFS	NWRPTF			: No, skip ahead
01075C	2430 			LIS	R3,0			: Yes, reset to top
01075E	4030 4000 1E1C 	NWRPTF	STH	R3,RTL.TF,,		: Store pointer
			
010764	2400 			LIS	R0,0			: Set default for fall-through
010766	4830 4000 1E1E 	GSYNBF	LH	R3,RTL.FF,,		: Get pointer
01076C	4930 4000 1E20 		CH	R3,RTL.TB,,		: Does it match? cannot pass TB
010772	0334 			  JER	R4			: Yes, no buffers available
010774	5803 4000 1E24 		L	R0,RTL.BF,R3,		: Get buffer
01077A	2634 			AIS	R3,4*1			: Move to next entry
01077C	C930 0080 		CHI	R3,4*RTLMAX		: At end of ring?
010780	2132 			  JNFS	NWRPFF			: No, skip ahead
010782	2430 			LIS	R3,0			: Yes, reset to top
010784	4030 4000 1E1E 	NWRPFF	STH	R3,RTL.FF,,		: Remember the pointer
01078A	2644 			AIS	R4,4			: Set skip return
01078C	0304 			JR	R4			:  and go
			
						
01078E	E600 4000 1F62 	ERRBSC	LA	R0,WRNBSC,,		: Warn about bad command
010794	E120 001D 		SVC	SYS,SUDIA.		: Set diagnostic message
010798	E120 0005 		SVC	SYS,FREEZ.		: Now freeze the slot
01079C	4300 FEE4 		J	FGLOOP			: Return to FG loop
			
0107A0	E600 4000 1F34 	ERRXGT	LA	R0,FATXGT,,		: non-eXistant check on GT
0107A6	2304 			JFS	GIVEUP
0107A8	E600 4000 1F07 	ERRSRR	LA	R0,FATSRW,,		: Sync Ring wrap problem
0107AE	E120 001D 	GIVEUP	SVC	SYS,SUDIA.		: Set diagnostic message
0107B2	E120 0020 		SVC	SYS,HALT.		: and halt the slot
0107B6	4300 FFF4 		J	GIVEUP			: Loop in case dummy says go
			
			
			: STORHW - Used to pre-fill a buffer with a given half-word
			:
			: call:
			:	R0 = byte/half-word to store
			:	R1 = address of buffer
			:	R2 = count of halfwords
			:	JAL	R4,STORHW
0107BA	ED20 0001 	STORHW	SLL	R2,1			: Convert HW to Bytes
0107BE	2722 		STORME	SIS	R2,2			: Decrement counter
0107C0	0214 			  JLR	R4			: Return when out of data
0107C2	4001 4200 0000 		STH	R0,0,R1,R2		: Store halfword
0107C8	2205 			JBS	STORME			:  and loop till done
			
			
				EM		: End of module FMAIN
			
			:
			:	Carl A Baltrunas,   TTE 442	Lab #5
			:	Source file for SLOT #1
			:
			
				GL	FSTART		: start of foreground
				GL	SYNCBF		: put/get sync buffer
				GL	STORHW		: Fill buffer with halfword
			
				RA	0			: Reset radix (some libraries don't)
			
000001			MAXBIT	EQ	(MAXPRT+20-1)/20	: Max ports as bits for words
000004			WRDSIZ	EQ	4			: Bytes per word
			
000003			CmETX	EQ	03			: Control-C
000007			CmBELL	EQ	07			: Bell
00000A			CmLF	EQ	0A			: Line-feed
00000D			CmCR	EQ	0D			: Carriage return
00000E			CmSI	EQ	0E			: Control-O
00001B			CmESC	EQ	1B			: Escape
000020			CmSPAC	EQ	20			: Space
			
00003F			CmQMRK	EQ	3F			: "?" Help
000043			CmCONN	EQ	43			: "C"onnect
000048			CmHELP	EQ	48			: "H"elp
00004D			CmMSGS	EQ	4D			: "M"essage
00004E			CmNOSY	EQ	4E			: "N"oisy
00004F			CmSOUT	EQ	4F			: "O"utput synch byte
000051			CmQUIT	EQ	51			: "Q"uit
000052			CmSDIS	EQ	52
000054			CmTIME	EQ	54			: "T"ime of day
000057			CmWHAT	EQ	57			: "W"hat
			
						
			: Beginning of some constant data
			
001F92				SEG	A.DATA
			
			
001F92	019E 		MxDET	HC	019E			: Detach message
001F94	019F 		MxZAP	HC	019F			: Zap message
001F96	01A0 		MxEBP	HC	01A0			: Enable back-pressure message
001F98	01A1 		MxDBP	HC	01A1			: Disable back-pressure message
001F9A	01A2 		MxGOB	HC	01A2			: Character gobbler message
001F9C	01A3 		MxFINP	HC	01A3			: Flush input message
001F9E	01A4 		MxBLB	HC	01A4			: Black ball message
001FA0	01A5 		MxGRB	HC	01A5			: Grey ball message
001FA2	01A6 		MxSDEM	HC	01A6			: Start Deferred Echo Mode
001FA4	01A7 		MxFDEM	HC	01A7			: Finish Deferred Echo Mode
001FA6	01AA 		MxGB	HC	01AA			: Green ball message
001FA8	01AB 		MxRB	HC	01AB			: Red ball message
001FAA	01AC 		MxYB	HC	01AC			: Yellow ball message
001FAC	01AD 		MxOB	HC	01AD			: Orange ball message
001FAE	03B1 0001 	M1TP00	HC	03B1,0001		: B1 message echo-control ON
001FB2	03B1 0000 	M0TP00	HC	03B1,0000		: B1 message echo-control OFF
			
			
001FB6	0010 		UIDSIZ	HC	4*WRDSIZ		: Words for user id entry
			
001FB8	0202 0202 0202 	CCCTAB	BC	2,2,2,2,2,2		: NUL,SOH,STX,ETX,EOT,ENQ
001FBE	0201 0101 0101 		BC	2,1,1,1,1,1		: ACK,BEL,BS ,HT ,LF ,VT
001FC4	0102 0202 0202 		BC	1,2,2,2,2,2		: FF ,CR ,SO ,SI ,DLE,DC1
001FCA	0202 0202 0202 		BC	2,2,2,2,2,2		: DC2,DC3,DC4,NAK,SYN,ETB
001FD0	0202 0201 0202 		BC	2,2,2,1,2,2		: CAN,EM ,SUB,ESC,FS ,GS
001FD6	0202 0101 0101 		BC	2,2,1,1,1,1		: RS ,US ,SP , ! , " , #
						
			: More Constant data storage  (strings)
			
001FDC	00			BC	0			: Dummy
001FDD	0E 		HUPMSG	BC	0E			: Msg byte count
001FDE	1000 000A 0004 		HC	1000,HST0,HPRT0,0,0	: Host up message (type 10)
	0000 0000 	
001FE8	0099 0000 		HC	PRODID,0		: Prod ID & filler for msg
001FEC	00			BC	0			: Dummy
001FED	08 		HSTOOP	BC	8			: Msg byte count
001FEE	0A00 000A 0000 		HC	0A00,HST0,0,0		: Host port availability (none)
	0000 		
001FF6	00			BC	0			: Dummy
001FF7	08 		HSTOKP	BC	8			: Msg byte count
001FF8	0A00 000A 0004 		HC	0A00,HST0,HPRT0,0	: Host port availability
	0000 		
			
002000	290A 0D0D C7A7 	WELMSG	SC	\"0A"0D"0DG'Day Bubba!"0A"0DWelcome to Carl's Host"0A"0D\
	C4E1 F9A0 C2F5 	
	E2E2 E1A1 0A0D 	
	D7E5 ECE3 EFED 	
	E5A0 F4EF A0C3 	
	E1F2 ECA7 F3A0 	
	C8EF F3F4 0A0D 	
00202A	0A0A 0DD5 F3E5 	UIDMSG	SC	\"0A"0DUserid: \
	F2E9 E4BA A0	
002035	05 0A0D BDBE A0	PMTMSG	SC	\"0A"0D=> \
00203B	10 0A0D C7EF A0	MxBYE	SC	\"0A"0DGo Away!!!"0A"0D"0A"0D\
	C1 F7E1 F9A1 A1	
	A1 0A0D 0A0D 	
00204C	2A0A 0DD1 F5E9 	MxALQ	SC	\"0A"0DQuit already in progress! Go Away!!!"0A"0D"0A"0D\
	F4A0 E1EC F2E5 	
	E1E4 F9A0 E9EE 	
	A0F0 F2EF E7F2 	
	E5F3 F3A1 A0C7 	
	EFA0 C1F7 E1F9 	
	A1A1 A10A 0D0A 	
	0D		
002077	0E 0A0D D4E9 ED	MxTIME	SC	\"0A"0DTime now is \
	E5 A0EE EFF7 A0	
	E9 F3A0 	
002086	0207 A1		MxBELL	SC	\"07!\			: Ding!
002089	02 0A0D 	MxCRLF	SC	\"0A"0D\
			
						
			:	C = Connect to another line (echo on both)
			:	H = Help, (or ?)
			:	M = Message another line (send one time message)
			:	N = Noisy terminal toggle
			:	O = Output Sync (enable)
			:	Q = Quit, teardown circuit and wait for a new login
			:	R = Reset Sync output (dismiss)
			:	S = Status message about slot
			:	T = Print daytime in local time zone
			:	W = What lines are active and Who is on-line
			:
			:	any other character causes a bell
			:
				LIST	L,-X,-R
00208C	10C3 EDE4 A0A0 	MxHELP	SC	\Cmd   Function"0A"0D\
	A0C6 F5EE E3F4 	
	E9EF EE0A 0D	
00209D	17 A0D8 A0A0 A0	MhHELP	SC	\ X    Type this message\
	A0 D4F9 F0E5 A0	
	F4 E8E9 F3A0 ED	
	E5 F3F3 E1E7 E5	
			:MhCONN	SC	\ X    Connect a port to another user-port\
			:MhMSGS	SC	\ X    Message a another port\
0020B5	17 A0D8 A0A0 A0	MhNOSY	SC	\ X    Noisy flag toggle\
	A0 CEEF E9F3 F9	
	A0 E6EC E1E7 A0	
	F4 EFE7 E7EC E5	
0020CD	1D A0D8 A0A0 A0	MhSOUT	SC	\ X    Output new Sync pattern\
	A0 CFF5 F4F0 F5	
	F4 A0EE E5F7 A0	
	D3 F9EE E3A0 F0	
	E1 F4F4 E5F2 EE	
0020EB	20 A0D8 A0A0 A0	MhQUIT	SC	\ X    Leave the system (LOG OFF)\
	A0 CCE5 E1F6 E5	
	A0 F4E8 E5A0 F3	
	F9 F3F4 E5ED A0	
	A8 CCCF C7A0 CF	
	C6 C6A9 	
00210C	19A0 D8A0 A0A0 	MhSDIS	SC	\ X    Dismiss Sync output\
	A0C4 E9F3 EDE9 	
	F3F3 A0D3 F9EE 	
	E3A0 EFF5 F4F0 	
	F5F4 		
			:MhSTAT	SC	\ X    Type system statistics\
002126	1EA0 D8A0 A0A0 	MhTIME	SC	\ X    Type current time of day\
	A0D4 F9F0 E5A0 	
	E3F5 F2F2 E5EE 	
	F4A0 F4E9 EDE5 	
	A0EF E6A0 E4E1 	
	F9		
002145	20 A0D8 A0A0 A0	MhWHAT	SC	\ X    Type user-port information\
	A0 D4F9 F0E5 A0	
	F5 F3E5 F2AD F0	
	EF F2F4 A0E9 EE	
	E6 EFF2 EDE1 F4	
	E9 EFEE 	
			
			CmdMAC	MACRO(Chr,Fnc,Hlp,ExtHlp) [	WC	Chr*01000000+Fnc
								HC	Hlp,ExtHlp	   ]
002168				WS	0	: Make sure word boundary
			CmdTAB						: Command table
000000			CmdChr	EQ	(.-CmdTAB)			:   Offset for Character
000000			CmdFnc	EQ	(.-CmdTAB)			:   Offset for Dispatch
002168	3F01 0C62 		WC	CmQMRK*01000000+CxHELP		:   Function address
000004			CmdHlp	EQ	(.-CmdTAB)			:   Offset for Help text
00216C	209D 0000 		HC	MhHELP,0			:   Help message address
000008			CmdSiz	EQ	(.-CmdTAB)			:   Entry size
			
002174	209D 209D 		CmdMAC(	CmHELP,CxHELP,MhHELP,MhHELP )	: Help
			:	CmdMAC(	CmCONN,CxCONN,MhCONN,MhCONN )	: Connect
			:	CmdMAC(	CmMSGS,CxMSGS,MhMSGS,MhMSGS )	: Message
00217C	20B5 20B5 		CmdMAC(	CmNOSY,CxNOSY,MhNOSY,MhNOSY )	: Noisy
002184	20CD 20CD 		CmdMAC(	CmSOUT,CxSOUT,MhSOUT,MhSOUT )	: SyncOUTbyte
00218C	20EB 20EB 		CmdMAC(	CmQUIT,CxQUIT,MhQUIT,MhQUIT )	: Quit
002194	210C 210C 		CmdMAC(	CmSDIS,CxSDIS,MhSDIS,MhSDIS )	: SyncDISmiss
			:	CmdMAC(	CmSTAT,CxSTAT,MhSTAT,MhSTAT )	: Statistics
00219C	2126 2126 		CmdMAC(	CmTIME,CxTIME,MhTIME,MhTIME )	: Time
0021A4	2145 2145 		CmdMAC(	CmWHAT,CxWHAT,MhWHAT,MhWHAT )	: What (Who)
000008			CmdLEN	EQ	(.-CmdTAB)/CmdSiz
			
				LIST	-L,F,X,R
						
			: Variable data
			
0021A8			TCLASS	BS	MAXPRT			: Throughput class of port
0021B8			CCTYPE	BS	MAXPRT			: CCT for each port
0021C8			NFROM	HS	MAXPRT			: Node of origin for each port
0021E8			HFROM	HS	MAXPRT			: Host of origin for each port
002208			PORTID	HS	MAXPRT			: Address of each Port Id string
			
002228			MsMSGC	BS	1			: Byte count for single char string
002229			MsCHAR	BS	1			: Current character
00222A			MsPORT	HS	1			: Current message port
00222C			MsTYPE	HS	1			: Current message type
			
002230			LOGINS	WS	1			: Count number of active logins
002234			MySYNC	WS	1			: Current/next sync buffer
002238			MsSOUT	HS	1			: Sync output pattern
00223A			MsSFLG	HS	1			: Place sync
00223C			CHRCNT	HS	1			: Place to hold character count
			
			: Flags
			
002240			WAITB1	WS	MAXBIT			: Bit array - Waiting for B1 return
002244			ECHOME	WS	MAXBIT			: Bit array - Can echo characters
002248			ECHOHT	WS	MAXBIT			: Bit array - Can echo HT
00224C			ECHOCR	WS	MAXBIT			: Bit array - Can echo CR (RUB on LF)
002250			ECHOBS	WS	MAXBIT			: Bit array - Can echo BS
002254			ECHOES	WS	MAXBIT			: Bit array - Can echo ESC
002258			LOGGED	WS	MAXBIT			: Bit a- Logged-in
00225C			LOGDET	WS	MAXBIT			: Bit array - DET sent
002260			NEEDID	WS	MAXBIT			: Bit array - need Id
002264			NEEDCH	WS	MAXBIT			: Bit array - need CH
002268			NEEDCR	WS	MAXBIT			: Bit array - need CR
00226C			NOISEY	WS	MAXBIT			: Bit array - noisy terminal
			
002270			PORTSC	WS	MAXPRT*4		: Storage for port id's
			
						
002370	11CA EFE2 F3BD 	MxLOGS	SC	\Jobs=NN, max=NN"0A"0D\
	CECE ACA0 EDE1 	
	F8BD CECE 0A0D 	
002382	022A 2376 	LxJOBS	HC	0220+0A,MxLOGS+06	: LOGINS at the moment
002386	022A 237E 	LxHPRT	HC	0220+0A,MxLOGS+0E	: Maximum logins
			
00238A	08C8 C8BA CDCD 	SvTIME	SC	\HH:MM:SS\		: Time of day
	BAD3 D3		
002393	33 A0A0 D0EF F2	MxWHAT	SC	\  Port Username      ST    Node    Host  CCT TPC "0A"0D\
	F4 A0D5 F3E5 F2	
	EE E1ED E5A0 A0	
	A0 A0A0 A0D3 D4	
	A0 A0A0 A0CE EF	
	E4 E5A0 A0A0 A0	
	C8 EFF3 F4A0 A0	
	C3 C3D4 A0D4 D0	
	C3 A00A 0D	
0023C7	33 A0A0 AAD0 D0	SvWHAT	SC	\  *PP  ------------  --  NNNNNN  HHHHHH  CCT TPC "0A"0D\
	A0 A0AD ADAD AD	
	AD ADAD ADAD AD	
	AD ADA0 A0AD AD	
	A0 A0CE CECE CE	
	CE CEA0 A0C8 C8	
	C8 C8C8 C8A0 A0	
	C3 C3D4 A0D4 D0	
	C3 A00A 0D	
0023FC	0120 23CA 	WxMINE	HC	0120+00,SvWHAT+03	: * = My port
002400	0230 23CB 	WxPORT	HC	0220+10,SvWHAT+04	: Port mask
002404	0C20 23CF 	WxUSER	HC	0C20+00,SvWHAT+08	: User ID
002408	0220 23DD 	WxSTAT	HC	0220+00,SvWHAT+16	: Status code
00240C	0628 23E1 	WxNODE	HC	0620+08,SvWHAT+1A	: Origin Node
002410	062A 23E9 	WxHOST	HC	0620+0A,SvWHAT+22	: Origin Host
002414	0348 23F1 	WxCCT	HC	0340+08,SvWHAT+2A	: CCT
002418	0348 23F5 	WxTPC	HC	0340+08,SvWHAT+2E	: TPC
			
			0107CA				SEG	A.CODE
			
			: Program begins here, entry defined by START.LIB
			: Output initial host-up message to the SUP
			
0107CA	2420 		START	LIS	R2,0			: RPORT = 0
0107CC	E630 4000 1FDD 		LA	R3,HUPMSG,,		: Setup msg address
0107D2	4150 4001 0070 		JAL	R5,OCM,,		: Send message
0107D8	E600 FE3A 		LA	R0,FSTART		: Foreground start address
0107DC	E120 0001 		SVC	SYS,CFGND.		: Connect foreground
			
			: Main message input loop, all routines return here one way or another
			
0107E0	E100 0000 	NOMSGS	SVC	DISMIS			: Done
0107E4	41D0 82B8 		JAL	R13,DOSYNC		: Dumping Sync?
0107E8	4140 4001 0000 	ISMSG	JAL	R4,LOOK,,		: Look for a message (FRING)
0107EE	4300 FFEE 		  J	NOMSGS			: No messages
			
			: R1 condition codes setup. for message port (by FRING)
			: Messages with RPORT=0 can be tested at this point
			
0107F2	4330 8068 		JE	ZFLUSH			: RPORT 0 Msg!  Flush it
			
			: Save RPORT and message TYPE for this message for later
			
0107F6	4010 4000 222A 		STH	R1,MsPORT,,		: Save current port
0107FC	4020 4000 222C 		STH	R2,MsTYPE,,		: Save current type
010802	0822 			LR	R2,R2			: Set condition codes for type
010804	4330 810E 		JE	ISNDL			: Got a needle?
			
			: Decide whether this is control or data
			
010808	C920 009E 		CHI	R2,09E			: Control or data message?
01080C	4210 82C8 		JL	MsDATA			: Data! -- Process the data
010810	C920 009F 		CHI	R2,09F			: ZAP? (received on port)
010814	4330 8056 		JE	MsIZAP			: Yes, incoming zap!
010818	C920 00AA 		CHI	R2,0AA			: GB (Green ball)?
01081C	4330 80C2 		JE	MsIGB			: Yes, be polite, reflect GB
010820	C920 00AB 		CHI	R2,0AB			: RB (Red ball)?
010824	4330 80C4 		JE	MsIRB			: Yes, be polite, reflect RB
010828	C920 00AC 		CHI	R2,0AC			: YB (Yellow ball)?
01082C	4330 809C 		JE	MsIYB			: Yes, be polite, reflect OB
			
010830	C920 00A6 		CHI	R2,0A6			: Enter deferred echo mode
010834	4330 80BE 		JE	MsEDEF			: Yes, Set flags and return
010838	C920 00A7 		CHI	R2,0A7			: Leave deferred echo mode
01083C	4330 80C6 		JE	MsLDEF			: Yes, Set flags and return
010840	C920 00B1 		CHI	R2,0B1			: Terminal parameters?
010844	4330 8074 		JE	MsITPM			: Yes, take care of it
			
			: Come here to flush non-rport=0 messages
			: before returning to main loop
			
010848	4820 4000 222C 	MFLUSH	LH	R2,MsTYPE,,		: Remember type
01084E	D302 400F 0028 		LB	R0,LENGTH,R2,		: Get RPORT=N index byte
010854	4140 4001 0056 	XFLUSH	JAL	R4,FLUSH,,		: Flush message
01085A	4300 FF8A 		J	ISMSG			: Any more messages
			
			: Come here to flush rport=0 messages
			: before returning to main loop
			
01085E	4860 400F 0026 	ZFLUSH	LH	R6,LP0LST,,		: Get RPORT=0 index table
010864	D306 420F 0000 		LB	R0,NRATE,R6,R2		: NRATE+TABLE(R2) Get message size
01086A	4300 FFE6 		J	XFLUSH			: Flush above
						
			: Control message code:  Handle Circuit-ZAP
			
01086E	4820 4000 222A 	MsIZAP	LH	R2,MsPORT,,		: Get current port
010874	7420 4000 225C 		TBT	R2,LOGDET,,		: Check DET bit for this port
01087A	4230 8028 		  JN	MsEZAP			: Yes, expected zap, don't reflect
01087E	E630 4000 1F94 		LA	R3,MxZAP,,		: Get zap message
010884	4150 4001 0070 		JAL	R5,OCM,,		: Send it <Whack>
01088A	2420 			LIS	R2,0			: Tell the supervisor
01088C	E630 4000 1FF7 		LA	R3,HSTOKP,,		: host no longer
010892	4150 4001 0070 		JAL	R5,OCM,,		: out of ports
010898	4800 4000 2230 		LH	R0,LOGINS,,		: Decrement login count
01089E	2701 			SIS	R0,1			:  by 1
0108A0	4000 4000 2230 		STH	R0,LOGINS,,		: to keep us honest
0108A6	4820 4000 222A 	MsEZAP	LH	R2,MsPORT,,		: Get current port
0108AC	7620 4000 2258 		RBT	R2,LOGGED,,		: Clear logged-in bit
0108B2	7620 4000 225C 		RBT	R2,LOGDET,,		: Clear DET bit for this port
0108B8	4300 FF8C 		J	MFLUSH			: Return through flushing code
			
			: Terminal parameter message - for now, just mark we were waiting for it
			:  Later, we need to check each type and keep track of parameter values
			
0108BC	4820 4000 222A 	MsITPM	LH	R2,MsPORT,,		: Get current port
0108C2	7620 4000 2240 		RBT	R2,WAITB1,,		: Clear bit waiting
0108C8	4300 FF7C 		J	MFLUSH			: and flush message
			
			: Control message code:  Handle Yellow-Ball
			: by reflecting an Orange-Ball on the same port
			
0108CC	E630 4000 1FAC 	MsIYB	LA	R3,MxOB,,		: Get OB message
0108D2	4820 4000 222A 	MsPMSG	LH	R2,MsPORT,,		: Get current port
0108D8	4150 4001 0070 		JAL	R5,OCM,,		: Send it <Whack>
0108DE	4300 FF66 		J	MFLUSH			: And flush message
			
0108E2	E630 4000 1FA6 	MsIGB	LA	R3,MxGB,,		: Get GB message
0108E8	4300 FFE6 		J	MsPMSG			: Send message
			
0108EC	E630 4000 1FA8 	MsIRB	LA	R3,MxRB,,		: Get RB message
0108F2	4300 FFDC 		J	MsPMSG			: And flush message
			
0108F6	4820 4000 222A 	MsEDEF	LH	R2,MsPORT,,		: Get current port
0108FC	7620 4000 2244 		RBT	R2,ECHOME,,		: Clear echo flag (HOST ECHO)
010902	4300 FF42 		J	MFLUSH			: and clear input message
			
010906	4820 4000 222A 	MsLDEF	LH	R2,MsPORT,,		: Get current port
01090C	7520 4000 2244 		SBT	R2,ECHOME,,		: Set echo flag (CONSAT ECHO)
010912	4300 FF32 		J	MFLUSH			: and clear input message
			
						
			: We have a needle, print startup (welcome) message to port and fall through
			
010916	4820 4000 222A 	ISNDL	LH	R2,MsPORT,,		: Get RPORT
01091C	7620 4000 225C 		RBT	R2,LOGDET,,		: Clear DET sent bit
010922	7620 4000 2268 		RBT	R2,NEEDCR,,		:  and CR needed bit
010928	7520 4000 226C 		SBT	R2,NOISEY,,		: Set initial noisy state
01092E	4140 4001 0036 		JAL	R4,GETH,,		: Get 00+Messagelength
010934	0860 			LR	R6,R0			: Remember length (bytes)
010936	4140 4001 0046 		JAL	R4,GETW,,		: Grab invoice Number (to throw away)
01093C	4140 4001 0046 		JAL	R4,GETW,,		: Grab Dest-host, Orig Node
010942	4002 4000 21C8 		STH	R0,NFROM,R2,		: Store NODE of origin
010948	4140 4001 0036 		JAL	R4,GETH,,		: Grab HOST of origin
01094E	4002 4000 21E8 		STH	R0,HFROM,R2,		: Store it
010954	4140 4001 0036 		JAL	R4,GETH,,		: Get port of origin (logical)
01095A	4140 4001 0046 		JAL	R4,GETW,,		: Get xxxx, xx Throughput class
010960	D202 4000 21A8 		STB	R0,TCLASS,R2,		: Store it (byte)
010966	4140 4001 0036 		JAL	R4,GETH,,		: IIX + Destination node
01096C	4140 4001 0026 		JAL	R4,GETCH,,		: Get Circuit Control Type
010972	D202 4000 21B8 		STB	R0,CCTYPE,R2,		: Store for later
010978	4140 4001 0026 		JAL	R4,GETCH,,		: Finish word
01097E	CB60 0014 		SHI	R6,5*4			: Decrement count by 5 full words
010982	0806 			LR	R0,R6			: Get remaining byte count
010984	4140 4001 0056 		JAL	R4,FLUSH,,		: Flush needle
			
			: Instead of prompting for Userid, later just use the username from the needle
			
01098A	4820 4000 222A 		LH	R2,MsPORT,,		: Get current port
010990	7620 4000 2244 		RBT	R2,ECHOME,,		: Clear who's echoing
010996	7520 4000 2240 		SBT	R2,WAITB1,,		: Waiting for a B1 return
01099C	E630 4000 1FAE 		LA	R3,M1TP00,,		: Send my initial B1 message
0109A2	4150 4001 0070 		JAL	R5,OCM,,		: to the other end
			
0109A8	4820 4000 222A 		LH	R2,MsPORT,,		: Get current port
0109AE	E630 4000 2000 		LA	R3,WELMSG,,		: Get my greeting message
0109B4	4150 4001 008C 		JAL	R5,OCS,,		: Print message
0109BA	4820 4000 2230 		LH	R2,LOGINS,,		: Get login count
0109C0	2621 			AIS	R2,1			:   increment
0109C2	4020 4000 2230 		STH	R2,LOGINS,,		:   and store
0109C8	4800 4000 2382 		LH	R0,LxJOBS,,		: What it looks like
0109CE	4810 4000 2384 		LH	R1,LxJOBS+2,,		: Where it goes
			:	LH	R2,LOGINS,,		: Get login count
0109D4	4160 4001 0558 		JAL	R6,OUTNUM,,		: Store job number
0109DA	4800 4000 2386 		LH	R0,LxHPRT,,		: Mask
0109E0	4810 4000 2388 		LH	R1,LxHPRT+2,,		: position
0109E6	C820 0004 		LHI	R2,HPRT0		: Max jobs we allow
0109EA	4160 4001 0558 		JAL	R6,OUTNUM,,		: Store in string message
0109F0	4820 4000 222A 		LH	R2,MsPORT,,		: Get current port
0109F6	E630 4000 2370 		LA	R3,MxLOGS,,		: Get usage message
0109FC	4150 4001 008C 		JAL	R5,OCS,,		: Print message
010A02	4810 4000 2230 		LH	R1,LOGINS,,		: Have we reached
010A08	C910 0004 		CHI	R1,HPRT0		:  our port limit?
010A0C	4210 800E 		  JL	WANTID			: No, keep going
010A10	2420 			LIS	R2,0			: Tell the supervisor
010A12	E630 4000 1FED 		LA	R3,HSTOOP,,		: host out of ports
010A18	4150 4001 0070 		JAL	R5,OCM,,		: so no more circuits
						
			: Ask the user for an ID - This need not be unique
			
010A1E	4820 4000 222A 	WANTID	LH	R2,MsPORT,,		: Get current port
010A24	7520 4000 2260 		SBT	R2,NEEDID,,		: Set need ID bit for this port
010A2A	7520 4000 2268 		SBT	R2,NEEDCR,,		:  and wait for a CR too
010A30	0832 			LR	R3,R2			: Copy for offset
010A32	2731 			SIS	R3,1			: Decrement for 0 offset
010A34	4C30 4000 1FB6 		MH	R3,UIDSIZ,,		: Multiply by entry size
010A3A	2410 			LIS	R1,0			: Set to initial constant
010A3C	4013 4000 2270 		STH	R1,PORTSC,R3,		:  for user id
010A42	2306 			JFS	ASKID			: And skip to asking message
010A44	7420 4000 2268 	ASKUID	TBT	R2,NEEDCR,,		: Need a CR before re-prompt?
010A4A	4230 FD9A 		  JN	ISMSG			: Yes, don't say a thing
010A4E	7520 4000 2240 	ASKID	SBT	R2,WAITB1,,		: Waiting for a B1 return
010A54	E630 4000 1FB2 		LA	R3,M0TP00,,		: Send my no-echo B1 message
010A5A	4150 4001 0070 		JAL	R5,OCM,,		: to the other end
010A60	4820 4000 222A 		LH	R2,MsPORT,,		: Get current port
010A66	E630 4000 202A 		LA	R3,UIDMSG,,		: Get user id message
010A6C	4150 4001 008C 		JAL	R5,OCS,,		: Print request
010A72	4300 FD72 		J	ISMSG			: Any others
			
			: Send a prompt to the currently selected port
			
010A76	4820 4000 222A 	PRMPT	LH	R2,MsPORT,,		: Get RPORT
010A7C	7420 4000 2260 		TBT	R2,NEEDID,,		: Waiting for user id?
010A82	4230 FFBE 		  JN	ASKUID			: Yes, ask instead of prompt
010A86	7420 4000 2264 		TBT	R2,NEEDCH,,		: Waiting for a character?
010A8C	4230 FD58 		  JN	ISMSG			: Yes, don't prompt!
010A90	E630 4000 2035 		LA	R3,PMTMSG,,		: Get prompt message
010A96	4150 4001 008C 		JAL	R5,OCS,,		: Print message
010A9C	4300 FD48 		J	ISMSG			: Any more messages
			
			
010AA0	4800 223A 	DoSYNC	LH	R0,MsSFLG		: Are we doing Sync output?
010AA4	033D 			  JER	R13			: No, just return
			:	LIS	R0,0			: Get a zero to
			:	STH	R0,MsSFLG		:  clear the flag,
010AA6	5800 2234 		L	R0,MySYNC		: Do I have a buffer?
010AAA	2135 			  JNFS	OkSYNC			: Yes, use the one I have
010AAC	4140 FC88 		JAL	R4,SYNCBF		: No, get a buffer
010AB0	430D 0000 		  J	0,R13			: None available
010AB4	0810 		OkSYNC	LR	R1,R0			: Copy buffer address
010AB6	4800 2238 		LH	R0,MsSOUT		: Get byte to store
010ABA	C820 0200 		LHI	R2,200			:  and count
010ABE	4140 FCF8 		JAL	R4,STORHW		: Store it
010AC2	0801 			LR	R0,R1			: Copy buffer
010AC4	4140 FC70 		JAL	R4,SYNCBF		: Store it
010AC8	4300 8006 		  J	NoSYNC			: Cannot store at this time
010ACC	C900 0000 		CHI	R0,0			: Anything in store?
010AD0	033D 			  JER	R13			: No, go home
010AD2	5000 2234 	NoSYNC	ST	R0,MySYNC		: Store buffer to use	  
010AD6	030D 			JR	R13			: Return to loop
			
						
			: Received a data message.  For this exercise, we are looking for
			: a particular command, sans case, sans parity:
			:
010AD8	4140 4001 0026 	MsDATA	JAL	R4,GETCH,,		: Get count of characters (MsType)
010ADE	4000 4000 223C 		STH	R0,CHRCNT,,		: Copy byte count to loop register
010AE4	4820 4000 222A 		LH	R2,MsPORT,,		: Get current port number
010AEA	7420 4000 2264 		TBT	R2,NEEDCH,,		: Waiting for a char?
010AF0	4230 80A8 		  JN	MsGetC			: Yes, get char and store
010AF4	7420 4000 2260 		TBT	R2,NEEDID,,		: Waiting for UserId?
010AFA	4230 80B4 		  JN	MuDATA			: Yes, get user Id
010AFE	4140 4001 0026 	MsLOOP	JAL	R4,GETCH,,		: Get data byte
010B04	4140 4001 0EDE 		JAL	R4,CSEVEN,,		: Clip it to 7 bits (upper case)
010B0A	41D0 4001 0F50 		JAL	R13,RxECHO,,		: See if we need to echo R0
010B10	C900 0003 		CHI	R0,CmETX		: User typed ^C
010B14	4330 8066 		  JE	MsCNCL			:  so cancel output
010B18	C900 000E 		CHI	R0,CmSI			: Do the same if
010B1C	4330 805E 		  JE	MsCNCL			:  we see ^O
010B20	2420 			LIS	R2,0			: Start at first entry
010B22	C830 0008 		LHI	R3,CmdLEN		: Get length
010B26	D402 4000 2168 	MsLOOK	CLB	R0,CmdTAB+CmdChr,R2,	: Is it this character?
010B2C	2138 			  JNFS	MsFIND			: No, try next
010B2E	5802 4000 2168 		L	R0,CmdTAB+CmdFnc,R2,	: Get function
010B34	F400 00FF FFFF 		NI	R0,00FFFFFF		:  and remove high byte
010B3A	0300 			JR	R0			: Then dispatch ??
			
010B3C	CA20 0008 	MsFIND	AHI	R2,CmdSiz		: Point to next entry
010B40	2731 			SIS	R3,1			: Are we done?
010B42	4220 FFE0 		JG	MsLOOK			: No, try next command
			
			: All messages reaching here contain unknown characters
			: Ignore the rest of the message (later until we see a CR)
			
010B46	4820 4000 222A 	MsUNK	LH	R2,MsPORT,,		: Get current port
010B4C	7420 4000 226C 		TBT	R2,NOISEY,,		: Are we a noisy terminal?
010B52	4330 800C 		  JE	MsNEXT			: No, not a peep!
010B56	E630 4000 2086 		LA	R3,MxBELL,,		: Get bell message
010B5C	4150 4001 008C 		JAL	R5,OCS,,		: Send message
			
			: All commands return to MsNEXT to complete reading input
			: and to flush the remainder of the message if needed!
			
010B62	4800 4000 223C 	MsNEXT	LH	R0,CHRCNT,,		: Get characters left
010B68	2701 			SIS	R0,1			: Decrement loop counter
010B6A	4000 4000 223C 		STH	R0,CHRCNT,,		: And remember the result
010B70	4220 FF8A 		JG	MsLOOP			: More characters, go get em
010B74	4140 4001 0058 		JAL	R4,ELIR,,		: None left, fixup iring index
010B7A	4300 FEF8 		J	PRMPT			: New prompt and go
			
010B7E	E630 4000 1F9A 	MsCNCL	LA	R3,MxGOB,,		: Get character gobbler message
010B84	4820 4000 222A 		LH	R2,MsPORT,,		: Get current port
010B8A	4150 4001 0070 		JAL	R5,OCM,,		: Send it to clear pipeline
010B90	D300 2229 		LB	R0,MsCHAR		: We know ^C or ^O is still here
010B94	41D0 83B8 		JAL	R13,RxECHO		: So echo it after the gobbler
010B98	4300 FFC6 		J	MsNEXT			: and finish this message
			
010B9C	4140 4001 0026 	MsGetC	JAL	R4,GETCH,,		: Get a character
010BA2	4000 4000 2238 		STH	R0,MsSOUT,,		: and store it
010BA8	7620 4000 2264 		RBT	R2,NEEDCH,,		: clear flag
010BAE	4300 FFB0 		J	MsNEXT			: next character
						
			: All messages here are for user id characters
			: Once the buffer pointer is setup, up to 12 bytes are stored
			: as String Constants for use with OCS.
			
010BB2	4820 4000 222A 	MuDATA	LH	R2,MsPORT,,		: Get current port
010BB8	0882 			LR	R8,R2			: Copy for offset
010BBA	2781 			SIS	R8,1			: Decrement for 0 offset
010BBC	4C80 4000 1FB6 		MH	R8,UIDSIZ,,		: Multiply by entry size
010BC2	D378 4000 2270 		LB	R7,PORTSC,R8,		: Get user id address size
010BC8	4140 4001 0026 	MuLOOP	JAL	R4,GETCH,,		: Get a byte
010BCE	C400 007F 		NHI	R0,07F			: Clip it to 7 bits (upper case)
010BD2	C900 000D 		CHI	R0,CmCR			: A Return?
010BD6	4330 8052 		  JE	MuTEND			: Yes, finish name
010BDA	C970 000C 		CHI	R7,$A12			: Allow up to 12
010BDE	2118 			  JLFS	MuSAVE			: Ok, go save it
010BE0	7420 226C 		TBT	R2,NOISEY		: Check noise level (on overflow)
010BE4	4330 8014 		  JE	MuNEXT			: No noise - be quiet -
010BE8	C800 0007 		LHI	R0,CmBELL		: Overflow, make believe a bell
010BEC	2305 			JFS	MuECHO			: and just echo it
010BEE	2671 		MuSAVE	AIS	R7,1			: Increment byte (count) pointer
010BF0	D208 4700 2270 		STB	R0,PORTSC,R8,R7		: Store next byte
010BF6	41D0 4001 0F50 	MuECHO	JAL	R13,RxECHO,,		: See if we need to echo R0
010BFC	4800 4000 223C 	MuNEXT	LH	R0,CHRCNT,,		: Get characters left
010C02	2701 			SIS	R0,1			: Decrement loop counter
010C04	4000 4000 223C 		STH	R0,CHRCNT,,		: and remember it for later
010C0A	4220 FFBA 		JG	MuLOOP			: More characters, go get em
010C0E	4880 4000 222A 		LH	R8,MsPORT,,		: Get current port
010C14	2781 			SIS	R8,1			: Decrement for 0 offset
010C16	4C80 4000 1FB6 		MH	R8,UIDSIZ,,		: Multiply by entry size
010C1C	D278 4000 2270 		STB	R7,PORTSC,R8,		: Store counter
010C22	4140 4001 0058 		JAL	R4,ELIR,,		: None left, fixup iring index
010C28	4300 FE4A 		J	PRMPT			: New prompt and go
			
			
010C2C	7620 4000 2260 	MuTEND	RBT	R2,NEEDID,,		: Set Id is complete
010C32	7620 4000 2268 		RBT	R2,NEEDCR,,		:  and CR was seen
010C38	7520 4000 2258 		SBT	R2,LOGGED,,		: We are logged completely in
010C3E	2721 			SIS	R2,1			: Decrement for 0 offset
010C40	4C20 4000 1FB6 		MH	R2,UIDSIZ,,		: Multiply by entry size
010C46	D272 4000 2270 		STB	R7,PORTSC,R2,		: Store counter
010C4C	4820 4000 222A 		LH	R2,MsPORT,,		: Get current port
010C52	E630 4000 1FAE 		LA	R3,M1TP00,,		:  to send terminal parameter
010C58	4150 4001 0070 		JAL	R5,OCM,,		:  message to allow consat to echo
010C5E	4300 FF00 		J	MsNEXT			: All done, any more are commands
			
						
			: HELP - Print a help message about the slot
			:
			
00241C				SEG	A.DATA
00241C			CxHPTR	HS	1			: Place for pointer offset
00241E			CxHLEN	HS	1			: Length of command list
010C62				SEG	A.CODE
			
			: Print a couple of CRLF pairs and the initial heading message
			
010C62	41D0 4001 0EEE 	CxHELP	JAL	R13,TCRLF,,		: Type a carriage return
010C68	41D0 4001 0EEE 		JAL	R13,TCRLF,,		:   and another
010C6E	4820 4000 222A 		LH	R2,MsPORT,,		: Get current port
010C74	E630 4000 208C 		LA	R3,MxHELP,,		: and message to print
010C7A	4150 4001 008C 		JAL	R5,OCS,,		: Then print it
			
			: Setup the command index and length in memory
			: Then multiplex them through R1 to keep register usage to a minimum
			
010C80	2410 			LIS	R1,0			: Start at first entry
010C82	4010 4000 241C 		STH	R1,CxHPTR,,		: Remember the pointer offset
010C88	C810 0008 		LHI	R1,CmdLEN		: Get length
010C8C	4010 4000 241E 	CxHLOP	STH	R1,CxHLEN,,		: Remember it
010C92	4810 4000 241C 		LH	R1,CxHPTR,,		: Get offset
			
			: The first byte of each entry is the actual character
			: Here we store it in the actual one-line message before printing
			
010C98	D301 4000 2168 		LB	R0,CmdTAB+CmdChr,R1,	: Get character
010C9E	4831 4000 216C 		LH	R3,CmdTAB+CmdHlp,R1,	: Get help message
010CA4	D203 4000 0002 		STB	R0,0+2,R3,		: Store character in text
010CAA	CA10 0008 		AHI	R1,CmdSIZ		: Point to next entry
010CAE	4010 4000 241C 		STH	R1,CxHPTR,,		: Remember the pointer offset
010CB4	4820 4000 222A 		LH	R2,MsPORT,,		: Get the port
010CBA	4150 4001 008C 		JAL	R5,OCS,,		: and print the line
010CC0	41D0 4001 0EEE 		JAL	R13,TCRLF,,		: Finish with a CRLF
			
			: Decrement and test the command table length, performing the
			: memory store above to save an extra instruction here.
			
010CC6	4810 4000 241E 		LH	R1,CxHLEN,,		: Get commands left	
010CCC	2711 			SIS	R1,1			: Any left?
010CCE	4220 FFBA 		JG	CxHLOP			: Yes, print them
010CD2	41D0 4001 0EEE 		JAL	R13,TCRLF,,		: Finish with a CRLF
010CD8	4300 FE86 		J	MsNEXT			: Return to command loop
			
			
			: NOISY - Toggle the flag in the NOISEY array for this port
			:         if the bit is set, then we are noisy, otherwise quiet
			
010CDC	4820 4000 222A 	CxNOSY	LH	R2,MsPORT,,		: Get my port
010CE2	7720 4000 226C 		CBT	R2,NOISEY,,		: Complement the bit
010CE8	4300 FE76 		J	MsNEXT			: (That was easy!)
			
						
			: OutSync buffer
			
010CEC	4820 4000 222A 	CxSOUT	LH	R2,MsPORT,,		: Get my port
010CF2	7520 4000 2264 		SBT	R2,NEEDCH,,		: Set need char
010CF8	2401 			LIS	R0,1			: Set flag true
010CFA	4000 4000 223A 	CxSFLG	STH	R0,MsSFLG,,		:  to initiate i/o
010D00	4300 FE5E 		J	MsNEXT			: and return
			
010D04	2400 		CxSDIS	LIS	R0,0			: Set flag false
010D06	2206 			JBS	CxSFLG			:  and return
			
			
			: QUIT - Mark we are in progress (check if already in progress)
			
010D08	4820 4000 222A 	CxQUIT	LH	R2,MsPORT,,		: Get current port
010D0E	7420 4000 225C 		TBT	R2,LOGDET,,		: Check in array (in progress)?
010D14	4230 804A 		  JN	CxALQ			: Quit in progress
010D18	E630 4000 203B 		LA	R3,MxBYE,,		: Get Goodbye message
010D1E	4150 4001 008C 		JAL	R5,OCS,,		: Send it
010D24	4820 4000 222A 		LH	R2,MsPORT,,		: Get port again
010D2A	E630 4000 1F92 		LA	R3,MxDET,,		: Get detach message
010D30	7520 4000 225C 		SBT	R2,LOGDET,,		: Set in detach array
010D36	7620 4000 2258 		RBT	R2,LOGGED,,		: Clear logged-in bit
010D3C	4150 4001 0070 		JAL	R5,OCM,,		: Send detach
010D42	4820 4000 2230 		LH	R2,LOGINS,,		: How many jobs?
010D48	2721 			SIS	R2,1			: Decrement
010D4A	4020 4000 2230 		STH	R2,LOGINS,,		:  and keep track
010D50	2420 			LIS	R2,0			: Tell the supervisor
010D52	E630 4000 1FF7 		LA	R3,HSTOKP,,		: host no longer
010D58	4150 4001 0070 		JAL	R5,OCM,,		: out of ports
010D5E	4300 FE00 		J	MsNEXT			: Get next character
			
			: %OOPS - Already waiting for OB from this port
			
010D62	E630 4000 204C 	CxALQ	LA	R3,MxALQ,,		: Get message text
010D68	4150 4001 008C 		JAL	R5,OCS,,		: Print it
010D6E	4300 FDF0 		J	MsNEXT
			
			
			
			: TIME - Obtain current daytime and print it for the user
			
010D72	5830 400F 000C 	CxTIME	L	R3,GMT,,		: Get current daytime
010D78	2448 			LIS	R4,8			: for HH:MM:SS format
010D7A	E650 4000 238B 		LA	R5,SvTIME+1,,		: Indicate storage
010D80	4160 4001 03DA 		JAL	R6,TMSTMP,,		: Get date string
			
010D86	4820 4000 222A 		LH	R2,MsPORT,,		: Get current port
010D8C	E630 4000 2077 		LA	R3,MxTIME,,		: Get time message
010D92	4150 4001 008C 		JAL	R5,OCS,,		: Print it
010D98	4820 4000 222A 		LH	R2,MsPORT,,		: Get current port
010D9E	E630 4000 238A 		LA	R3,SvTIME,,		: Get actual time string
010DA4	4150 4001 008C 		JAL	R5,OCS,,		: Print it
010DAA	4300 FDB4 		J	MsNEXT			: Return to loop
			
						
			: WHAT - Tell what lines are available
			
010DAE	41D0 4001 0EEE 	CxWHAT	JAL	R13,TCRLF,,		: Free CRLF
010DB4	4820 4000 222A 		LH	R2,MsPORT,,		: My port
010DBA	E630 4000 2393 		LA	R3,MxWHAT,,		: Print header message
010DC0	4150 4001 008C 		JAL	R5,OCS,,		: for this command
010DC6	2491 			LIS	R9,1			: Start with first port
010DC8	7490 4000 2258 	CxWLOP	TBT	R9,LOGGED,,		: Is it logged?
010DCE	4330 80FE 		  JE	CxWNXT			: No, try next
010DD2	4800 4000 23FC 		LH	R0,WxMINE,,		: Get -myself- mask
010DD8	4810 4000 23FE 		LH	R1,WxMINE+2,,		:  and position
010DDE	C820 0020 		LHI	R2,CmSPAC		:  and value  (default = SP)
010DE2	4990 4000 222A 		CH	R9,MsPORT,,		: Is it my port?
010DE8	2133 			  JNFS	CxWNME			: No, not me
010DEA	C820 002A 		LHI	R2,2A			: Yes, Me!  Indicate with "*"
010DEE	D221 0000 	CxWNME	STB	R2,0,R1			: Store appropriate value
010DF2	4800 4000 2400 		LH	R0,WxPORT,,		: Get port mask
010DF8	4810 4000 2402 		LH	R1,WxPORT+2,,		:  and position
010DFE	0829 			LR	R2,R9			:  and value
010E00	4160 4001 0558 		JAL	R6,OUTNUM,,		: Convert it for printing
010E06	0889 			LR	R8,R9			: Copy for offset
010E08	2781 			SIS	R8,1			: Decrement for 0 offset
010E0A	4C80 4000 1FB6 		MH	R8,UIDSIZ,,		: Multiply by entry size
010E10	4800 4000 2404 		LH	R0,WxUSER,,		: Get user mask
010E16	4810 4000 2406 		LH	R1,WxUSER+2,,		:  and position
010E1C	E628 4000 2270 		LA	R2,PORTSC,R8,		:  and address of SC
010E22	4160 4001 0F02 		JAL	R6,MOUTSC,,	
010E28	4810 4000 240A 		LH	R1,WxSTAT+2,,		: Get address of status
010E2E	C800 004E 		LHI	R0,4E			: Assume NOISY
010E32	7490 4000 226C 		TBT	R9,NOISEY,,		: Until we check it
010E38	2133 			  JNFS	CxWNSY			: Yes, Noisy
010E3A	C800 0051 		LHI	R0,51			: No, Quiet
010E3E	D201 0000 	CxWNSY	STB	R0,0,R1			: Store "N/Q" factor
010E42	C800 004C 		LHI	R0,4C			: Assume local (consat) echo
010E46	7490 4000 2244 		TBT	R9,ECHOME,,		: See who is echoing
010E4C	2133 			  JNFS	CxWLCL			: Not me, so say local to user
010E4E	C800 0052 		LHI	R0,52			: It's me, so say remote to user
010E52	D201 0001 	CxWLCL	STB	R0,1,R1			: Store "L/R" factor
010E56	4800 4000 240C 		LH	R0,WxNODE,,		: Get NODE mask
010E5C	4810 4000 240E 		LH	R1,WxNODE+2,,		:  and position
010E62	0829 			LR	R2,R9			:  and value
010E64	4822 4000 21C8 		LH	R2,NFROM,R2,		:  from table
010E6A	4160 4001 0558 		JAL	R6,OUTNUM,,		: Convert it for printing
010E70	4800 4000 2410 		LH	R0,WxHOST,,		: Get HOST mask
010E76	4810 4000 2412 		LH	R1,WxHOST+2,,		:  and position
010E7C	0829 			LR	R2,R9			:  and value
010E7E	4822 4000 21E8 		LH	R2,HFROM,R2,		:  from table
010E84	4160 4001 0558 		JAL	R6,OUTNUM,,		: Convert it for printing
010E8A	4800 4000 2414 		LH	R0,WxCCT,,		: Get CCT mask
010E90	4810 4000 2416 		LH	R1,WxCCT+2,,		:  and position
010E96	0829 			LR	R2,R9			:  and value
010E98	4822 4000 21B8 		LH	R2,CCTYPE,R2,		:  from table
010E9E	4160 4001 0558 		JAL	R6,OUTNUM,,		: Convert it for printing
010EA4	4800 4000 2418 		LH	R0,WxTPC,,		: Get TPC mask
010EAA	4810 4000 241A 		LH	R1,WxTPC+2,,		:  and position
010EB0	0829 			LR	R2,R9			:  and value
010EB2	4822 4000 21A8 		LH	R2,TCLASS,R2,		:  from table
010EB8	4160 4001 0558 		JAL	R6,OUTNUM,,		: Convert it for printing
010EBE	4820 4000 222A 		LH	R2,MsPORT,,		: Get my port
010EC4	E630 4000 23C7 		LA	R3,SvWHAT,,		: and the right message
010ECA	4150 4001 008C 		JAL	R5,OCS,,		: then print it
010ED0	2691 		CxWNXT	AIS	R9,1			: Try next port
010ED2	C990 0010 		CHI	R9,MAXPRT		: Reached the limit?
010ED6	4320 FEEE 		JLE	CxWLOP			: No, check it
010EDA	4300 FC84 		J	MsNEXT			: And return
			
						
			: Utility routines: CSEVEN, TCRLF, MOUTSC
			
010EDE	C400 007F 	CSEVEN	NHI	R0,7F			: Only look at 7 bits
010EE2	C900 0060 		CHI	R0,60			: Check for lower-case range
010EE6	0214 			JLR	R4			: No, skip subtraction
010EE8	CB00 0020 		  SHI	R0,20			: Convert to upper case
010EEC	0304 			JR	R4			: Return
			
			
010EEE	4820 4000 222A 	TCRLF	LH	R2,MsPORT,,		: Get current port
010EF4	E630 4000 2089 		LA	R3,MxCRLF,,		: Get message
010EFA	4150 4001 008C 		JAL	R5,OCS,,		: Print it
010F00	030D 			JR	R13			: Return
			
			
010F02	C400 3FFF 	MOUTSC	NHI	R0,3FFF			: Check field width
010F06	C900 0100 		CHI	R0,100
010F0A	0216 			JLR	R6			: Nothing to do?
010F0C	0830 			LR	R3,R0			: Extract padd character
010F0E	C430 007F 		NHI	R3,7F			: (can be anything) SP = 20
010F12	2133 			  JNFS	MOUTS0			: But must NOT be null
010F14	C830 0020 		LHI	R3,20			: If so, make it a space
010F18	D342 0000 	MOUTS0	LB	R4,0,R2			: Get bytes in string
010F1C	EC00 0008 		SRL	R0,08			: Normalize field width
010F20	0904 			CR	R0,R4			: Do we have too many?
010F22	2322 			  JLEFS	MOUTS1			: No, no change
010F24	0840 			LR	R4,R0			: Use the field width
010F26	2621 		MOUTS1	AIS	R2,1			: Adjust character pointer
010F28	D352 0000 		LB	R5,0,R2			: Get byte
010F2C	2132 			  JNFS	MOUTS2			: Non-null so keep going
010F2E	0853 			LR	R5,R3			: Oops! use filler instead
010F30	D251 0000 	MOUTS2	STB	R5,0,R1			: Store byte
010F34	2611 			AIS	R1,1			: Adjust pointers (output)
010F36	2701 			SIS	R0,1			:  and counters (field)
010F38	2741 			SIS	R4,1			:  to suit (input)
010F3A	4220 FFE8 		JG	MOUTS1			: More? Yes, transfer them
010F3E	0904 			CR	R0,R4			: Anything left to fill?
010F40	0326 			JLER	R6			: No, all done -- Return
010F42	D231 0000 	MOUTS3	STB	R3,0,R1			: Add fill character
010F46	2611 			AIS	R1,1			: Adjust output pointer
010F48	2701 			SIS	R0,1			: Loop till all
010F4A	4220 FFF4 		JG	MOUTS3			:  positions filled
010F4E	0306 			JR	R6			: All done, Return
						
			: Echo character routine
			
010F50	4810 4000 222A 	RxECHO	LH	R1,MsPORT,,		: Get current port number
010F56	7410 4000 2244 		TBT	R1,ECHOME,,		: See if we need to echo
010F5C	023D 			  JNR	R13			: No, just return
010F5E	D200 4000 2229 		STB	R0,MsCHAR,,		: Save byte for return
010F64	0820 			LR	R2,R0			: Move to a usable index
010F66	2401 			LIS	R0,1			: One data character
010F68	C920 0020 		CHI	R2,CmSPAC		: Is it printable
010F6C	2314 			  JGEFS	RxOCH2			: Yes, just print one
010F6E	D302 4000 1FB8 		LB	R0,CCCTAB,R2,		: No, get message length from table
010F74	0820 		RxOCH2	LR	R2,R0			: Copy for room needed
010F76	4810 4000 222A 		LH	R1,MsPORT,,		: Get my port
010F7C	4140 4001 011A 		JAL	R4,SLOR,,		: Setup record
010F82	D300 4000 2229 		LB	R0,MsCHAR,,		: Retrieve original byte
010F88	C900 0020 		CHI	R0,CmSPAC		: Printable?
010F8C	4310 803A 		  JGE	RxOCHx			: Yes, do it
010F90	C900 001B 		CHI	R0,CmESC		: Escape?
010F94	2135 			  JNFS	RxOCH4			: No, skip this
010F96	C800 0024 		LHI	R0,24			: Yes, change character to "$"
010F9A	4300 802C 		J	RxOCHx			: Output character and return
010F9E	C900 000D 	RxOCH4	CHI	R0,CmCR			: Check CR
010FA2	212A 			  JGFS	RxOCH8			: No, Too high
010FA4	2116 			  JLFS	RxOCH6			: No, See if formatting char
010FA6	4140 4001 0154 		JAL	R4,PUTCH,,		: Yes, output the CR
010FAC	C800 000A 		LHI	R0,CmLF			: Load a LF
010FB0	C900 0007 	RxOCH6	CHI	R0,CmBELL		: Check bell	
010FB4	231B 			  JGEFS	RxOCHx			: Yes!  BEL,BS,HT,LF,VT,FF to print
010FB6	C800 005E 	RxOCH8	LHI	R0,5E			: Get a "^"
010FBA	4140 4001 0154 		JAL	R4,PUTCH,,		: And put it away
010FC0	D300 4000 2229 		LB	R0,MsCHAR,,		: Get byte back
010FC6	CA00 0040 		AHI	R0,40			: Make it printable
010FCA	4140 4001 0154 	RxOCHx	JAL	R4,PUTCH,,		: Put it away
010FD0	4140 4001 01A2 		JAL	R4,ELOR,,		: Finish up
010FD6	D300 4000 2229 		LB	R0,MsCHAR,,		: Get the original character
010FDC	030D 			JR	R13			: Return
			
			
 \5<[w