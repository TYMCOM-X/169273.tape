
EBUS02.JMS                 E B U S  --  PDP-10 Base Code, Version 2.02                   22-May-88  Page    1
Err Source Ref. Address   value
    line   line

       1      1                          		TTL	'E B U S  --  PDP-10 Base Code, Version 2.02'
       2      2                          	
       3      3                          	*			***** ****  *   *  ****
       4      4                          	*			*     *   * *   * *
       5      5                          	*			****  ****  *   *  ***
       6      6                          	*			*     *   * *   *     *
       7      7                          	*			***** ****   ***  ****
       8      8                          	
       9      9                          	*************************************************************************
      10     10                          	**	                PROPRIETARY INFORMATION                        **
      11     11                          	**	                                                               **
      12     12                          	**	This  source code listing constitutes the proprietary pro-     **
      13     13                          	**	perty of TYMNET, Incorporated. The recipient, by receiving     **
      14     14                          	**	this program listing, agrees that neither this listing nor     **
      15     15                          	**	the   information  disclosed herein nor any  part  thereof     **
      16     16                          	**	shall be  reproduced or transferred to other documents  or     **
      17     17                          	**	used  or  disclosed to others for manufacturing or for any     **
      18     18                          	**	other   purpose except as specifically authorized in  wri-     **
      19     19                          	**	ting by  TYMNET, Incorporated.                                 **
      20     20                          	*************************************************************************
      21     21                          	
      22     22                          		OPT	A,B,-M,-I
      23     23                          	
      24     24                          	* Version 2.02 created by Joe Smith 19-Apr-88.
      25     25                          	* Includes fixes for bugs found by reading the code and observations
      26     26                          	* by Paul Krumviede.  This is NOT an official version!   /JMS
      27     27 00000202                 	VERSION	EQU	$202			; VERSION NUMBER
      28     28 00000091                 	PRODID	EQU	$91			; product-ID
      29     29 00000000                 	DEBUG	EQU	0			; what to tell host when we come up
      30     30 00000100                 	MAXPORT	EQU	256			; maximum number of ports supported
      31     31 00000010                 	BFLSIZ	EQU	16			; bufferlet size (Power of 2!!)
      32     32 0000001B                 	ESC	EQU	$1B			; code used for escapes (in buffers)
      33     33 000000AC                 	YB_CODE	EQU	$AC			; code for Yellow-ball
      34     34                          	
      35     35                          	*	Assembly and Debugging Switches
      36     36 00000001                 	RTRACE	EQU	1			; Enable trace of PDP ring transfers
      37     37 00000000                 	BTRACE	EQU	0			; Enable trace of PDP BIO transfers
      38     38 00000001                 	ITRACE	EQU	1			; Enable trace of ISIS transfers
      39     39 00000000                 	CTRACE	EQU	0			; Enable trace of Buffer transfers
      40     40 00000001                 	TRACING	EQU	RTRACE!BTRACE!ITRACE!CTRACE	; Switch if ANY trace active
      41     41                          	
      42     42                          	
      43     43                          	*	Special (RESERVED) Register Declarations
      44     44 0000000C                 	Rp	EQU	A4			; Pointer to port-descriptor
      45     45 0000000D                 	Rs	EQU	A5			; Pointer to Start of ISIS Input Ring
      46     46 0000000E                 	Rd	EQU	A6			; Pointer to Start of ISIS Output Ring
      47     47 00000007                 	Cs	EQU	D7			; Cursor to position within Input Ring
      48     48 00000006                 	Cd	EQU	D6			; Cursor to position within Output Ring
      49     49                          	
      50     50                          	
      51     51                          	*	B A S I C   M E M O R Y   L A Y O U TEBUS02.JMS                 E B U S  --  PDP-10 Base Code, Version 2.02                   22-May-88  Page    2
Err Source Ref. Address   value
    line   line

      52     52                          	
      53     53                          	*	"Magic" addresses for addressing the Engine
      54     54 FFFFF901                 	ENGINE	EQU	$FFFFF901		; address to interrupt the engine
      55     55                          	
      56     56 0000013C                 	ENGVECT	EQU	$13C			; Engine-interrupt Vector Location
      57     57                          	*		$900			  Bottom of stack
      58     58                          	*		$1000			  Top-of-Stack;  Beginnings of tables
      59     59                          	*					   and variable storage
      60     60 00004000                 	PATCHR	EQU	$4000			; PATCH AREA
      61     61                          	*		$4E00			  Beginning of Vector table
      62     62                          	*		$4F00			  Beginning of Bootstrap
      63     63                          	*		$5000			  Beginning of Code
      64     64                          	*		$7C00			  STARTES -- Diagnostic Routine
      65     65                          	*		$7D00			  CONWRT -- diagnostic routine
      66     66                          	*		$7E00			  READ diagnostic routine
      67     67 00008000                 	BUFER	EQU	$8000			; bufers
      68     68 0000F000                 	BUFEREND EQU	BUFER+$7000		; the end of the bufferlet area
      69     69 0000F000                 	ENDMEM	SET	BUFEREND		; the end of "memory"
      70     70                          	 if	TRACING
      71     71 00020000                 	STRACE	EQU	$20000			; beginning of trace area
      72     72 0003FFE0                 	ETRACE	EQU	$3FFE0			; end of trace area
      73     73 0003FFE0                 	ENDMEM	SET	ETRACE			; the end of "memory"
      74     74                          	 endc
      75     75                          	*		$????			
      76     76                          	
      77     77                          	*	Various Locations for doing Read and Write to PDP-10
      78     78 00D000B8                 	DSENS	EQU	$D000B8			; D0=0-BUSY, 1-NOT BUSY
      79     79 00D00138                 	DPER	EQU	$D00138			; D0=1-ERROR, DO AFTER READ
      80     80 00D001B8                 	DTMOT	EQU	$D001B8			; D0=1-TIMEOUT
      81     81 00D01038                 	DEXCO	EQU	$D01038			; RESET BOX SIGNAL ONLY
      82     82 00D010B8                 	DEXC1	EQU	$D010B8			; NEXT WRT TO PDP10 WRITE WRONG PARITY
      83     83                          	
      84     84                          	*	Locations for reading from PDP-10
      85     85 00D0403A                 	RD101	EQU	$D0403A
      86     86 00D0403C                 	RD104	EQU	$D0403C
      87     87 00D0403E                 	RD102	EQU	$D0403E
      88     88 00D04038                 	RD103	EQU	$D04038
      89     89                          	
      90     90                          	*	Locations for Writing to PDP-10
      91     91 00D0803A                 	WT101	EQU	$D0803A
      92     92 00D0803C                 	WT102	EQU	$D0803C
      93     93 00D0803E                 	WT103	EQU	$D0803E
      94     94 00D08038                 	WT104	EQU	$D08038
      95     95                          	
      96     96 00E00000                 	ESPACE	EQU	$E00000		; start of Engine memory
      97     97                          	*		$EFFFFF		  end of Engine memory
      98     98                          	
      99     99                          	*		$F00000		  start of MACSbug area
     100    100                          	*		$FFFFFF		  end of MACSbug areaEBUS02.JMS                 E B U S  --  PDP-10 Base Code, Version 2.02                   22-May-88  Page    3
Err Source Ref. Address   value
    line   line

     102    102                          	
     103    103                          	*	Define data-structure for Port-Descriptor:
     104    104                          		OFFSET	0
     105    105 00000000                 	P_NUM	DS.B	1			; spare copy of port-number
     106    106 00000001                 	P_FLAGS	DS.B	1			; port status (flags)
     107    107 00000000                 	 PF_ACT: EQU	0			; port active
     108    108 00000001                 	 PF_ILI: EQU	1			; Port In Log-In State
     109    109 00000002                 	 PF_OBP: EQU	2			; Output Back-pressure applied (by ISIS)
     110    110 00000003                 	 PF_IBP: EQU	3			; Input Back-pressure applied (by us)
     111    111 00000004                 	 PF_HBP: EQU	4			; Input Back-pressure applied (by Host)
     112    112 00000005                 	 PF_BKO: EQU	5			; Block-Output active
     113    113 00000006                 	 PF_BKI: EQU	6			; Block-Input active
     114    114 00000007                 	 PF_BFD: EQU	7			; Block FilleD
     115    115                          	
     116    116 00000002                 	XMITLMT	DS.B	1			; transmit limit
     117    117 00000003                 	IBRATE	DS.B	1			; Input baud-rate
     118    118 00000003                 	AUXKEY	EQU	IBRATE			; hold AUX-key here too
     119    119                          	
     120    120 00000004                 	BO_TAR	DS.L	1			; Block-output -- (PDP) block start addr.
     121    121 00000008                 	BO_BYT	DS.W	1			; Block-Output -- byte position within word
     122    122 0000000A                 	BO_TCN	DS.W	1			; Block-output -- output count (total left)
     123    123                          	
     124    124 0000000C                 	BI_TIM	DS.L	1			; Block-input -- time (FASTC) last activity
     125    125 00000010                 	BI_TAR	DS.L	1			; Block-input -- (PDP) block start address
     126    126 00000014                 	BI_TCN	DS.W	1			; Block-input -- input count (total)
     127    127 00000016                 	BI_LCN	DS.W	1			; Block-input -- input count (so far)
     128    128 00000018                 	BI_BYT	DS.W	1			; Block-input -- pos. within current word
     129    129                          	
     130    130 0000001A                 	BB	DS.W	1			; bufferlet-begin
     131    131 0000001C                 	BE	DS.W	1			; bufferlet-end
     132    132 0000001E                 	BCT	DS.W	1			; count of characters
     133    133 00000020                 	PD_SIZ	DS.W	0			; size of descriptorEBUS02.JMS                 E B U S  --  PDP-10 Base Code, Version 2.02                   22-May-88  Page    4
Err Source Ref. Address   value
    line   line

     135    135                          	
     136    136                          	***	Define some useful Macros
     137    137                          	
     138    138                          	*	Macro to Cause VCRASH with crash-code VAL
     139    139                          	CRASH	MACRO	VAL
     140    140                          		MOVE.B	#VAL,CODCASH		; set crash-code
     141    141                          		BRA	VCRASH			; crash host (68K keeps running)
     142    142                          		ENDM
     143    143                          	
     144    144                          	*	Macro to Cause (FATAL!) BCRASH with crash-code VAL
     145    145                          	FCRASH	MACRO	VAL
     146    146                          		MOVE.B	#VAL,CODCASH		; set crash-code
     147    147                          		BSR.\0	BCRASH			; tell ISIS then halt
     148    148                          		ENDM
     149    149                          	
     150    150                          	*	Macro to PUSH a register onto the stack
     151    151                          	PUSH	MACRO	REG
     152    152                          		MOVE.L	REG,-(SP)
     153    153                          		ENDM
     154    154                          	
     155    155                          	*	Macro to POP a register from the stack
     156    156                          	POP	MACRO	REG
     157    157                          		MOVE.L	(SP)+,REG
     158    158                          		ENDM
     159    159                          	
     160    160                          	*	Macro to PUSH multiple registers onto the stack
     161    161                          	PUSHM	MACRO	REGS
     162    162                          		MOVEM.L	REGS,-(SP)
     163    163                          		ENDM
     164    164                          	
     165    165                          	*	Macro to POP multiple registers from the stack
     166    166                          	POPM	MACRO	REGS
     167    167                          		MOVEM.L	(SP)+,REGS
     168    168                          		ENDM
     169    169                          	
     170    170                          	*	MACRO to construct a Vector-table Entry
     171    171                          	VENTRY	MACRO	WHERE,OUR
     172    172                          		DC.W	WHERE,OUR,0,0
     173    173                          		ENDM
     174    174                          	
     175    175                          	*	Macro to generate a text-string with leading count-byte
     176    176                          	TEXTC	MACRO	STRING
     177    177                          		LOCAL	BGN,CNT
     178    178                          	BGN	DC.B	CNT,STRING
     179    179                          	CNT	EQU	*-BGN-1
     180    180                          		ENDM



     182    182                          		TTL	'E B U S  --  PDP-10 Base Code,		V A R I A B L E S'EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		V A R I A B L E S             22-May-88  Page    5
Err Source Ref. Address   value
    line   line

     184    184                          	
     185    185                          	        ORG	$900			; where we actually begin



     187    187 00000900                 	STKBOT  DS.L    0			: The Bottom of the Stack
     188    188                          		ORG	$1000
     189    189 00001000                 	STKTOP	DS.L	0			; the end (Top) of the stack
     190    190                          	
     191    191                          	 if	TRACING
     192    192 00001000 0002 0000       	.TRACE	DC.L	STRACE			; Current Trace Pointer
     193    193                          	 endc
     194    194                          	
     195    195 00001004 0000 0000       	CODCASH	DC.L	0			; leave as Long, even if used as Byte
     196    196 00001008 0000 0000       	PCCASH	DC.L	0			; save PC here on crash
     197    197 0000100C 0000 0000       	CASHW	DC.L	0			; information about message causing crash
     198    198                          	
     199    199                          	 if	TRACING
     200    200 00001010 FFFF            	TR_PORT	DC.W	-1			; Trace ONLY this port if not <0
     201    201                          	 endc
     202    202                          	
     203    203                          	*	The following data is read from Engine and translated for subsequent
     204    204                          	*	references by the base code.
     205    205 00001012                 	ISTOME	DS.L	1			; Address to get info from ISIS
     206    206 00001016                 	METOIS	DS.L	1			; Address to pass info to ISIS
     207    207 0000101A 0000 0000       	SLTOME	DC.L	0			; Address to get parameters from slot
     208    208 0000101E 0000 0000       	METOSL	DC.L	0			; Address to put crash info into slot
     209    209 00001022 0000 0000       	.MDUMP	DC.L	0			; Address to dump memory to
     210    210 00001026 0000 0000       	.MDSIZ	DC.L	0			; number of bytes to dump (0=none)
     211    211 0000102A                 	.SYNC	DS.L	1			; Address to perform slot-synchronization
     212    212 0000102E                 	ORING	DS.L	1			; Dispatcher Output Ring Start Address
     213    213 00001032                 	IRING	DS.L	1			; Dispatcher Input Ring Start Address
     214    214 00001036                 	.SLOWC	DS.L	1			; Address of SLOWC Time
     215    215 0000103A                 	.FASTC	DS.L	1			; Address of FASTC
     216    216 0000103E                 	IRSIZE	DS.W	1			; record ISIS input-ring size here
     217    217 00001040                 	ORSIZE	DS.W	1			; record ISIS output-ring size here
     218    218                          	
     219    219                          	
     220    220 00001042 0000            	P10DAH	DC.W	0			; High data
     221    221 00001044 0000            	P10DAL	DC.W	0			; low data
     222    222 00001046 00              	P10DLL	DC.B	0			; high address | low data (4-bits each)
     223    223 00001048 0000            	P10ADR	DC.W	0			; low (15-bit) read/write addr. in PDP
     224    224                          	
     225    225                          	
     226    226 0000104A                 	ZERO	DS.L	0			; beginning of area to zero-out on init.
     227    227                          	
     228    228                          	
     229    229 0000104A                 	HOSTN	DS.W	1			; Host Number
     230    230 0000104C                 	HOSTP	DS.W	1			; Number of Host Ports
     231    231 0000104E                 	HSTAT	DS.W	1			; Host status | Host keyEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		V A R I A B L E S             22-May-88  Page    6
Err Source Ref. Address   value
    line   line

     232    232                          						; 0=ANSW 1=DOWN 2=SHUT 3=GONE
     233    233 00001050                 	HOSTTO	DS.W	1			; Host-specified timeout (for Key test)
     234    234 00001052                 	TOHOST	DS.W	1			; Current Host-Key timeout
     235    235 00001054                 	HVERNO	DS.W	1			; Host version number
     23236                          	
     237    237 00001056                 	MXPORT	DS.W	1			; maximum number of active ports possible
     238    238 00001058                 	NPORTS	DS.W	1			; current number of active ports
     239    239                          	
     240    240 0000105A                 	AUXQ	DS.W	1			; AUX circuit key (= requesting port number)
     241    241 0000105C                 	AUXTIM	DS.L	1			; timeout for AUX circuit request
     242    242 00001060                 	AUXX	DS.W	1			; index into AUXC
     243    243 00001062                 	AUXC	DS.B	40			; AUX logon-string
     244    244                          	
     245    245                          	
     246    246 0000108A                 	TYPBYT	DS.B	1			; message type
     247    247 0000108B                 	HTDWN	DS.B	1			; flag -- host down if NE 0
     248    248                          	
     249    249 0000108C                 	PDPORP	DS.W	1			; start address of PDP's output ring
     250    250 0000108E                 	PDPOSZ	DS.W	1			; Size of PDP's output ring
     251    251 00001090                 	PDPOFC	DS.W	1			; PDP output ring Fill Cursor
     252    252 00001092                 	PDPOEC	DS.W	1			; our PDP output ring Empty Cursor
     253    253 00001094                 	PDPIRP	DS.W	1			; start address of PDP's input ring
     254    254 00001096                 	PDPISZ	DS.W	1			; Size of PDP's input ring
     255    255 00001098                 	PDPIEC	DS.W	1			; PDP input ring Empty Cursor
     256    256 0000109A                 	PDPIFC	DS.W	1			; our PDP input ring Fill Cursor
     257    257 0000109C                 	INRGSP	DS.W	1			; # of bytes of space in PDP input ring
     258    258 0000109E                 	INTYBT	DS.W	1			; Type byte of MSG input from ISIS
     259    259 000010A0                 	PORTNO	DS.W	1			; Current Port number
     260    260 000010A2                 	NORNODE	DS.W	1			; normal login origination node
     261    261 000010A4                 	NORHOST	DS.W	1			; normal login origination host
     262    262 000010A6                 	NORPORT	DS.W	1			; normal login origination port
     263    263 000010A8                 	DAT	DS.L	0			; DAT1--4 are both LONG, and single Bytes
     264    264 000010A8                 	DAT1	DS.B	1			; for message type
     265    265 000010A9                 	DAT2	DS.B	1			; for port number
     266    266 000010AA                 	DAT3	DS.B	1
     267    267 000010AB                 	DAT4	DS.B	1
     268    268 000010AC                 	DAT5	DS.B	48			; extra space available here
     269    269 000010DC                 	NCCT	DS.B	1			; save CCT from needle here
     270    270 000010DD                 	NSIZ	DS.B	1			; save username size from needle here
     271    271 000010DE 00              	BLK	DC.B	0			; flag: non BIO usage if = 0
     272    272 000010E0                 	SLOWC	DS.L	1			; Clock within Engine
     273    273 000010E4                 	HTM	DS.L	1			; Time of last Open/Shut MSG (FASTC)
     274    274 000010E8                 	LFASTC	DS.L	1			; Time of last 1/2 sec logic
     275    275                          	
     276    276 000010EC                 	LASCOU	DS.W	1			; count of good keys
     277    277                          	
     278    278 000010EE                 	BKPR	DS.W	1			; # of bytes before applying back-pressure
     279    279 000010F0                 	IRRN	DS.W	1			; ISIS-input "throttle"
     280    280 000010F2                 	ORRN	DS.W	1			; host-output "throttle"
     281    281                          	
     282    282 000010F4                 	.BFLTS	DS.L	1			; pointer to bufferlet areaEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		V A R I A B L E S             22-May-88  Page    7
Err Source Ref. Address   value
    line   line

     283    283 000010F8                 	NBFLTS	DS.W	1			; number of bufferlets
     284    284 000010FA                 	R_TANK	DS.W	1			; bufferlet reserve tank
     285    285                          	
     286    286 000010FC                 	BLKFREE	DS.W	1			; pointer to block-IO free-list
     287    287 000010FE                 	BKIHEAD	DS.W	1			; block-input list head (pointer or null)
     288    288 00001100                 	BKOHEAD	DS.W	1			; block-output list head (pointer or null)
     289    289 00001102                 	BUFHEAD	DS.W	1			; Buffer list head (pointer or null)
     290    290 00001104                 	SAVE1	DS.W	1
     291    291 00001106                 	TMOC	DS.B	1
     292    292 00001107                 	PFULL	DS.B	1			; flag for ports full (if non-zero)
     293    293 00001108                 	DIAG	DS.B	1			; flag for diagnostic in progress
     294    294                          	
     295    295 0000110A                 	FREEBLK	DS.L	2*MAXPORT		; Block-IO Free-list storage
     296    296                          	
     297    297 0000190A                 	PORTS	DS.B	PD_SIZ*MAXPORT		; storage for port-descriptors
     298    298                          	
     299    299                          	
     300    300 0000390A                 	ENDZERO	DS.L	0			; end of area to zero-out on init.



     302    302                          		TTL	'E B U S  --  PDP-10 Base Code,		T A B L E S'EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		T A B L E S                   22-May-88  Page    8
Err Source Ref. Address   value
    line   line

     304    304                          	
     305    305                          	*	Table of Input Baud Rates in CCT order
     306    306 0000390A 0502 0202       	CCTBD	DC.B	5,2,2,2,2,1,1,1		; GET BAUD RATE FROM CCT
     306    307 0000390E 0201 0101       	
     307    308 00003912 0607 0005       		DC.B	6,7,0,5,5,5,5,0
     307    309 00003916 0505 0500       	
     308    310 0000391A 0A05 050B       		DC.B	10,5,5,11,12,5,5,5
     308    311 0000391E 0C05 0505       	
     309    312 00003922 0505 0505       		DC.B	5,5,5,5,5,5,5,5
     309    313 00003926 0505 0505       	



     311    315                          		TTL	'E B U S  --  PDP-10 Base Code,		B O O T S T R A P'EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		B O O T S T R A P             22-May-88  Page    9
Err Source Ref. Address   value
    line   line

     313    317                          		ORG	$4E00
     314    318                          	
     315    319                          	*	VECTOR TABLE:
     316    320                          	*	Each entry is 2 shorts and a long (total 8 bytes):
     317    321                          	*	0 -	vector address (W)
     318    322                          	*	2 -	our handler address (W)
     319    323                          	*	4 -	original contents of vector (L)
     320    324                          	
     321    325 00004E00                 	VECTOR	VENTRY	ENGVECT,BOBCODE		; Engine interrupt
     322    328 00004E08                 		VENTRY	$8,BUSERR		; Buss Error
     323    331 00004E10                 		VENTRY	$C,ILLINS		; Illegal Instruction
     324    334 00004E18                 		VENTRY	$10,ADRERR		; Address Error
     325    337 00004E20                 		VENTRY	0,0			; null entry terminates list
     326    340                          	
     327    341                          		ORG	$4F00
     328    342                          	
     329    343                          	
     330    344                          	
     331    345                          	*	===== ========= ==== ==== ======= ==========
     332    346                          	*	Start Execution here upon machine reload!!!!
     333    347                          	*	===== ========= ==== ==== ======= ==========
     334    348                          	
     335    349                          	*	Enter here from MACSbug with the following registers set up:
     336    350                          	*	A1 has address of kernel-to-68000 message area.
     337    351                          	*	A2 has address of 68000-to-kernel message area.
     338    352                          	*	A7 set up as stack pointer with D0-D7/A0-A6 pushed on it.
     339    353                          	
     340    354                          	
     341    355 00004F00 21C9 1012       	ENTRY	MOVE.L	A1,ISTOME		; address of ISIS-to-us message area
     342    356 00004F04 21CA 1016       		MOVE.L	A2,METOIS		; address of us-to-ISIS message area
     343    357 00004F08 4280            		CLR.L	D0			; prepare to divert some traps
     344    358 00004F0A 41F8 4E00       		LEA	VECTOR,A0		;	and interrupts
     345    359 00004F0E 3258            	ENTRY1	MOVE.W	(A0)+,A1		; address of vector entry
     346    360 00004F10 3018            		MOVE.W	(A0)+,D0		; our handler
     347    361 00004F12 6706            		BEQ	ENTRY2			; null entry terminates list
     348    362 00004F14 20D1            		MOVE.L	(A1),(A0)+		; else save current contents
     349    363 00004F16 2280            		MOVE.L	D0,(A1)			; ...and put our handler address there
     350    364 00004F18 60F4            		BRA	ENTRY1			; continue loop
     351    365                          	
     352    366 00004F1A 4238 10DE       	ENTRY2	CLR.B	BLK			; insure not expecting BIO
     353    367 00004F1E 24BC 0000 0002  		MOVE.L	#IPDLOK,(A2)		; #2 = download OK
     354    368 00004F24                 		POPM	D0-D7/A0-A6
     355    370 00004F28 612C            		BSR	INTRPT			; interrupt engine
     356    371 00004F2A 4E72 2000       		STOP	#$2000			; Halt, Enable Interrupts
     357    372                          	
     358    373                          	
     359    374                          	
     360    375                          	*	Here on interrupt from engine
     361    376                          	* The following kernel-to-68000 messages are defined in I2IS07.R03:
     362    377                          	*	EIPDLD EQ 01000000 :DOWN-LOAD AND STARTEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		B O O T S T R A P             22-May-88  Page   10
Err Source Ref. Address   value
    line   line

     363    378                          	*	EIPCRA EQ 03000000 :ENGINE CRASH - GO CRASH HOST
     364    379                          	*	EIPIOW EQ 04000000 :START ADDR OF I/O WINDOW (SLOT TO IPI DATA)
     365    380                          	*	EIPRIN EQ 05000000 :TEST MESSAGE (RE-INIT), SENT ONCE PER SECOND
     366    381                          	*	SLTINT EQ 06000000 :SLOT WANTS TO INTERRUPT THE IPI
     367    382                          	*	EIPGMB EQ 07000000 :GO TO MACSBUG
     368    383                          	* The following 68000-to-kernel responses are defined:
     369    384 00000001                 	IPANMA	EQU	1	   ;Acknowledge new message area
     370    385 00000002                 	IPDLOK	EQU	2	   ;Down-line load OK (implies IPANMA as well)
     371    386 00000003                 	IPCRSH	EQU	3	   ;IPI is requesting a crash (68K detected problem)
     372    387 00000004                 	IPAIOW	EQU	4	   ;Acknowlege I/O window addr
     373    388 00000006                 	IPASI	EQU	6	   ;Acknowlege slot interrupt request
     374    389                          	
     375    390                          	
     376    391 00004F2E 46FC 2700       	BOBCODE	MOVE	#$2700,SR		; Disable Interrupts
     377    392 00004F32                 		PUSHM	D0-D7/A0-A6
     378    394 00004F36 2078 1012       		MOVEA.L	ISTOME,A0		; address of ISIS-to-us message area
     379    395 00004F3A 3010            		MOVE.W	(A0),D0			; get high HW from there
     380    396 00004F3C 0240 0F00       		ANDI.W	#$0F00,D0		; examining only second nibble
     381    397 00004F40 0C40 0400       		CMPI.W	#$0400,D0
     382    398 00004F44 6756            		BEQ	GETIOWA			; 4 is what we expect, and is OK
     383    399 00004F46 0C40 0500       		CMPI.W	#$0500,D0
     384    400 00004F4A 6618            		BNE	FFCRA			; if not 4 or 5, go crash
     385    401                          	* Message 5 (EIPRIN) is sent once a second.  Ignore it.
     386    402 00004F4C                 		POPM	D0-D7/A0-A6
     387    404 00004F50 46FC 2000       		MOVE	#$2000,SR		; Enable Interrupts
     388    405 00004F54 4E73            		RTE				; got 5...just return
     389    406                          	
     390    407                          	*	Interrupt the Engine
     391    408 00004F56 11FC 00C0 F901  	INTRPT	MOVE.B	#$0C0,ENGINE		; Interrupt ENGINE
     392    409 00004F5C 11FC 00C1 F901  		MOVE.B	#$0C1,ENGINE
     393    410 00004F62 4E75            		RTS
     394    411                          	
     395    412                          	* Message 3 (EIPCRA) means slot is halted, go crash host and halt 68K
     396    413 00004F64 0C40 0300       	FFCRA	CMPI.W	#$0300,D0		; EIPCRA means slot has crashed
     397    414 00004F68 6600 001E       		BNE.L	FFCRA1			; illegal message
     398    415 00004F6C 11FC 00EC 1004  		MOVE.B	#$EC,CODCASH		; else set reason (KEY=354 octal)
     399    416 00004F72 6100 01DA       		BSR.L	REGDMP			; and dump our registers
     400    417 00004F76 6100 077C       		BSR.L	HCRASH			; then crash the host
     401    418 00004F7A 11FC 0001 108B  		MOVE.B	#1,HTDWN		; set host down
     402    419 00004F80                 	        POPM	D0-D7/A0-A6
     403    421 00004F84 4E72 2000       		STOP	#$2000			; Halt, Enable Interrupts
     404    422                          	
     405    423                          	* Message 1 (EIPDLD) should never get here since we give the interrupt
     406    424                          	* vector back to MACSBUG.  If it does, just do a warm start.  (4/19/88 /JMS
     407    425                          	
     408    426 00004F88 0C40 0100       	FFCRA1	CMPI.W	#$0100,D0		; Check for reload command
     409    427 00004F8C 6724            		BEQ	GETIOWB			; Use previous pointers
     410    428 00004F8E                 	        POPM	D0-D7/A0-A6		; Don't create stack overflow
     411    430 00004F92                 		FCRASH.L  $EF			; Illegal message from ISIS
     412    433                          	
     413    434                          	* Message 4 (EIPIOW) has addr of I/O window to access slot's memoryEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		B O O T S T R A P             22-May-88  Page   11
Err Source Ref. Address   value
    line   line

     414    435 00004F9C 2010            	GETIOWA	MOVE.L	(A0),D0			; get ISIS-to-us message
     415    436 00004F9E 0280 000F FFFF  		ANDI.L	#$000FFFFF,D0
     416    437 00004FA4 0080 00E0 0000  		ORI.L	#ESPACE,D0		; translate for our address-space
     417    438 00004FAA 21C0 101A       		MOVE.L	D0,SLTOME		; address of slot parameters
     418    439 00004FAE 21C0 101E       		MOVE.L	D0,METOSL		; same as Slot-to-me address
     419    440 00004FB2 2078 1016       	GETIOWB	MOVE.L	METOIS,A0		; get us-to-ISIS address
     420    441 00004FB6 20BC 0000 0004  		MOVE.L	#IPAIOW,(A0)		; tell ISIS "4"
     421    442 00004FBC                 		POPM	D0-D7/A0-A6		; restore registers
     422    444                          	
     423    445 00004FC0 6194            		BSR	INTRPT			; interrupt engine
     424    446 00004FC2 46FC 2000       		MOVE	#$2000,SR		; Enable Interrupts
     425    447 00004FC6 6038            		BRA	INITIAL			; go initialize
     426    448                          	
     427    449                          		ORG	$5000
     428    450                          	
     429    451                          	
     430    452                          	*		I N I T I A L I Z A T I O N
     431    453                          	
     432    454 00005000 4FF8 1000       	INITIAL	LEA	STKTOP,SP		; Set up the stack pointer
     433    455                          	
     434    456                          	*	Zero out some memory
     435    457 00005004 41F8 104A       		LEA	ZERO,A0
     436    458 00005008 303C 28C0       		MOVE.W	#ENDZERO-ZERO,D0
     437    459 0000500C 4258            	INIT0	CLR.W	(A0)+
     438    460 0000500E 5540            		SUB.W	#2,D0
     439    461 00005010 66FA            		BNE	INIT0
     440    462                          	
     441    463                          	
     442    464                          	*	Get parameters from ISIS
     443    465 00005012 2078 101A       		MOVE.L	SLTOME,A0		; pointer to slot parameters
     444    466 00005016 2018            		MOVE.L	(A0)+,D0
     445    467 00005018 0080 00E0 0000  		OR.L	#ESPACE,D0
     446    468 0000501E 21C0 102E       		MOVE.L	D0,ORING
     447    469 00005022 31D8 1040       		MOVE.W	(A0)+,ORSIZE
     448    470 00005026 2018            		MOVE.L	(A0)+,D0
     449    471 00005028 0080 00E0 0000  		OR.L	#ESPACE,D0
     450    472 0000502E 21C0 1032       		MOVE.L	D0,IRING
     451    473 00005032 31D8 103E       		MOVE.W	(A0)+,IRSIZE
     452    474 00005036 2018            		MOVE.L	(A0)+,D0
     453    475 00005038 0080 00E0 0000  		OR.L	#ESPACE,D0
     454    476 0000503E 21C0 103A       		MOVE.L	D0,.FASTC
     455    477 00005042 2240            		MOVE.L	D0,A1
     456    478 00005044 21D1 10E8       		MOVE.L	(A1),LFASTC		; initialize LFASTC to now
     457    479 00005048 2018            		MOVE.L	(A0)+,D0
     458    480 0000504A 0080 00E0 0000  		OR.L	#ESPACE,D0
     459    481 00005050 21C0 1036       		MOVE.L	D0,.SLOWC		; address of slow clock
     460    482 00005054 2018            		MOVE.L	(A0)+,D0
     461    483 00005056 0080 00E0 0000  		OR.L	#ESPACE,D0
     462    484 0000505C 21C0 102A       		MOVE.L	D0,.SYNC		; used for Sync with Slot code
     463    485 00005060 2018            		MOVE.L	(A0)+,D0
     464    486 00005062 0080 00E0 0000  		OR.L	#ESPACE,D0EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		B O O T S T R A P             22-May-88  Page   12
Err Source Ref. Address   value
    line   line

     465    487 00005068 21C0 101E       		MOVE.L	D0,METOSL		; prefered place to dump registers
     466    488 0000506C 2018            		MOVE.L	(A0)+,D0
     467    489 0000506E 0080 00E0 0000  		OR.L	#ESPACE,D0
     468    490 00005074 21C0 1022       		MOVE.L	D0,.MDUMP		; prefered place to dump memory
     469    491 00005078 2018            		MOVE.L	(A0)+,D0
     470    492 0000507A 223C 0003 FFE0  		MOVE.L	#ENDMEM,D1		: end of "memory"
     471    493 00005080 B081            		CMP.L	D1,D0			; use minimum
     472    494 00005082 6F02            		BLE	INIT1
     473    495 00005084 2001            		MOVE.L	D1,D0
     474    496 00005086 21C0 1026       	INIT1	MOVE.L	D0,.MDSIZ		; size of memory dump area
     475    497 0000508A 30FC 0202       		MOVE.W	#VERSION,(A0)+		; return Version number
     476    498 0000508E 2A78 1032       		MOVE.L	IRING,Rs		; Input Ring address into Rs
     477    499 00005092 2C78 102E       		MOVE.L	ORING,Rd		; Output Ring address into Rd
     478    500                          	
     479    501                          	*	Initialize Bufferlet Storage
     480    502 00005096 41F9 0000 8000  		LEA	BUFER,A0		; pointer to start of area
     481    503 0000509C 21C8 10F4       		MOVE.L	A0,.BFLTS		; Record pointer to start of area
     482    504 000050A0 4240            		CLR.W	D0			; record cursors here
     483    505 000050A2 0640 0010       	INIT2	ADD.W	#BFLSIZ,D0		; advance cursor
     484    506 000050A6 41E8 0010       		LEA	BFLSIZ(A0),A0		; pointer to next buferlet
     485    507 000050AA 3140 FFF0       		MOVE.W	D0,-BFLSIZ(A0)		; set last forward-chain pointer
     486    508 000050AE 5278 10F8       		ADD.W	#1,NBFLTS		; keep count of number of bufferlets
     487    509 000050B2 B1FC 0000 F000  		CMPA.L	#BUFEREND,A0		; done yet?
     488    510 000050B8 6DE8            		BLT	INIT2			; no...continue
     489    511 000050BA 4250            		CLR.W	(A0)			; last one signaled by 0
     490    512                          	
     491    513 000050BC 11FC 0003 104E  		MOVE.B	#3,HSTAT		; Set Host status = Gone
     492    514 000050C2 11FC 0001 108B  		MOVE.B	#1,HTDWN		; set Host Down
     493    515 000050C8 31FC FFFF 1060  		MOVE.W	#-1,AUXX		; Enable AUX circuit requests
     494    516 000050CE 50F8 1004       		ST	CODCASH			; Initialize Crash-Code to FF
     495    517 000050D2 31FC 00C8 10EE  		MOVE.W	#200,BKPR		; value to apply back-pressure
     496    518                          	 if	TRACING
     497    519 000050D8 21FC 0002 0000  		MOVE.L	#STRACE,.TRACE		; PDP-10 Trace Start Address
                         1000
     498    520                          	 endc
     499    521                          	
     500    522 000050E0 41F8 110A       		LEA	FREEBLK,A0
     501    523 000050E4 31C8 10FC       		MOVE.W	A0,BLKFREE		; initialize Block-IO free-list
     502    524 000050E8 323C 0200       		MOVE.W	#MAXPORT*2,D1		; one list for input and output
     503    525 000050EC 5848            	BLKMAP	ADD.W	#4,A0			; point to next
     504    526 000050EE 3148 FFFC       		MOVE.W	A0,-4(A0)		; point last at this
     505    527 000050F2 5341            		SUB.W	#1,D1
     506    528 000050F4 6EF6            		BGT	BLKMAP
     507    529 000050F6 4268 FFFC       		CLR.W	-4(A0)			; last has null next
     508    530                          	
     509    531 000050FA 303C 0100       		MOVE.W	#MAXPORT,D0
     510    532 000050FE 49F8 190A       		LEA	PORTS,Rp		; initialize port descriptors
     511    533 00005102 4241            		CLR.W	D1			; we'll be counting port number here
     512    534 00005104 197C 009D 0002  	PUTPORT	MOVE.B	#157,XMITLMT(Rp)	; transmit-limit
     513    535 0000510A 1941 0000       		MOVE.B	D1,P_NUM(Rp)		; set port number
     514    536 0000510E 5241            		ADD.W	#1,D1			; advance port numberEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		B O O T S T R A P             22-May-88  Page   13
Err Source Ref. Address   value
    line   line

     515    537 00005110 D8FC 0020       		ADDA.W	#PD_SIZ,Rp		; advance to next port
     516    538 00005114 5340            		SUB.W	#1,D0
     517    539 00005116 66EC            		BNE	PUTPORT
     518    540                          	
     519    541 00005118 4A79 00D0 1038  		TST.W	DEXCO			; Reset EBUS
     520    542 0000511E 6100 0944       		BSR.L	DOKEY			; see if host is already up
     521    543 00005122 6600 0A96       		BNE.L	EXEC			; no
     522    544 00005126 06B8 0000 012C  		ADD.L	#300,LFASTC		; yes...do next host check in 1/2 second
                         10E8
     523    545 0000512E 6100 04EC       		BSR.L	RDPDPRP			: read PDP's Ring-parameters
     524    546 00005132 31FC 0300 10A8  		MOVE.W	#$300+DEBUG,DAT1	; set "RESET INTERFACE"
     525    547 00005138 31FC 0202 10AA  		MOVE.W	#VERSION,DAT3
     526    548 0000513E 6100 065E       		BSR.L	WAITDAT			; and send it
     527    549 00005142 6100 065A       		BSR.L	WAITDAT			;  ...twice...just in case
     528    550 00005146 6100 0690       		BSR.L	PUTIFC			; let PDP know it's there
     529    551 0000514A 6000 0A6E       		BRA.L	EXEC			; then go begin



     531    553                          		TTL	'E B U S  --  PDP-10 Base Code,		C R A S H E S'EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		C R A S H E S                 22-May-88  Page   14
Err Source Ref. Address   value
    line   line

     533    555                          	*	CRASH Routines for the Base
     534    556                          	*	Dump CODCASH, PCCASH, and all registers to slot's REGDMP area
     535    557                          	*	...if we know where it is.  NO REGISTERS AFFLICTED
     536    558 0000514E 4AB8 101E       	REGDMP	TST.L	METOSL			; do we have a place to dump to?
     537    559 00005152 6730            		BEQ	REGDMPX			; no...just exit
     538    560 00005154                 		PUSH	A0			; yes...save A0
     539    562 00005156 2078 101E       		MOVE.L	METOSL,A0		; address to dump to
     540    563 0000515A 20F8 1004       		MOVE.L	CODCASH,(A0)+		; dump crash reason
     541    564 0000515E 20F8 1008       		MOVE.L	PCCASH,(A0)+		; PC saved
     542    565 00005162 20C0            		MOVE.L	D0,(A0)+		; successive D-registers
     543    566 00005164 20C1            		MOVE.L	D1,(A0)+
     544    567 00005166 20C2            		MOVE.L	D2,(A0)+
     545    568 00005168 20C3            		MOVE.L	D3,(A0)+
     546    569 0000516A 20C4            		MOVE.L	D4,(A0)+
     547    570 0000516C 20C5            		MOVE.L	D5,(A0)+
     548    571 0000516E 20C6            		MOVE.L	D6,(A0)+
     549    572 00005170 20C7            		MOVE.L	D7,(A0)+
     550    573 00005172 20D7            		MOVE.L	(SP),(A0)+		; Saved value of A0
     551    574 00005174 20C9            		MOVE.L	A1,(A0)+		; successive A-registers
     552    575 00005176 20CA            		MOVE.L	A2,(A0)+
     553    576 00005178 20CB            		MOVE.L	A3,(A0)+
     554    577 0000517A 20CB            		MOVE.L	A3,(A0)+
     555    578 0000517C 20CD            		MOVE.L	A5,(A0)+
     556    579 0000517E 20CE            		MOVE.L	A6,(A0)+
     557    580 00005180 20CF            		MOVE.L	SP,(A0)+
     558    581 00005182                 		POP	A0			; restore A0
     559    583 00005184 4E75            	REGDMPX	RTS				; exit
     560    584                          	
     561    585                          	
     562    586                          	*	Possible dump 68K memory into Engine memory (memory-dump area)
     563    587 00005186 2038 1026       	MEMDMP	MOVE.L	.MDSIZ,D0		; should we do a memory-dump?
     564    588 0000518A 6FF8            		BLE	REGDMPX			; no
     565    589 0000518C 207C 0000 0000  		MOVEA.L	#0,A0			; yes...our source
     566    590                          	*bug*	MOVEA.L	.MDUMP,A0	*bug* noticed 2-Jul-86 by JMS
     567    591 00005192 2278 1022       		MOVEA.L	.MDUMP,A1		; Engine destination
     568    592 00005196 32D8            	MEMDMP1	MOVE.W	(A0)+,(A1)+		; dump memory
     569    593 00005198 5580            		SUBQ.L	#2,D0			; done yet?
     570    594 0000519A 6EFA            		BGT	MEMDMP1			; not yet
     571    595 0000519C 42B8 1026       		CLR.L	.MDSIZ			; insure no more crashes saved
     572    596                          						;  'til told otherwise
     573    597 000051A0 4E75            		RTS				; and exit
     574    598                          	
     575    599                          	
     576    600                          	*	CRASH ROUTINE
     577    601                          	*	Calling Sequence:	BSR	BCRASH
     578    602                          	*	FATAL CRASH:	NO RETURN!!!!!!
     579    603 000051A2 21DF 1008       	BCRASH	MOVE.L	(SP)+,PCCASH		; Location that called this routine
     580    604 000051A6 61A6            		BSR	REGDMP			; dump registers
     581    605 000051A8 6100 054A       		BSR.L	HCRASH			; crash the host
     582    606 000051AC 11FC 0001 108B  		MOVE.B	#1,HTDWN		; ...and record it as downEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		C R A S H E S                 22-May-88  Page   15
Err Source Ref. Address   value
    line   line

     583    607 000051B2 61D2            		BSR	MEMDMP			; try to do a memory-dump
     584    608 000051B4 41F8 4E08       		LEA	VECTOR+8,A0		; restore traps (not Engine interrupt)
     585    609 000051B8 3258            	BCRASH1	MOVE.W	(A0)+,A1		; address of vector entry
     586    610 000051BA 4A58            		TST.W	(A0)+
     587    611 000051BC 6704            		BEQ	BCRASH2			; null entry terminates list
     588    612 000051BE 2298            		MOVE.L	(A0)+,(A1)		; else restore previous contents
     589    613 000051C0 60F6            		BRA	BCRASH1			; continue loop
     590    614                          	
     591    615 000051C2 4280            	BCRASH2	CLR.L	D0
     592    616 000051C4 3038 1004       		MOVE.W	CODCASH,D0		; left byte is crash-reason
     593    617 000051C8 103C 0003       		MOVE.B	#3,D0			; 3 in right byte means Base crashes
     594    618 000051CC 2078 1016       		MOVE.L	METOIS,A0		; address of Base-to-Engine MSG area
     595    619 000051D0 2080            		MOVE.L	D0,(A0)			; move it to Base-to-Engine MSG area
     596    620 000051D2 6100 FD82       		BSR	INTRPT			; interrupt engine
     597    621 000051D6 4E72 2000       		STOP	#$2000			; and HALT! (with Interrupts Enabled)
     598    622                          	
     599    623                          	*	ISIS MSG-type FATAL CRASH!!
     600    624 000051DA 31F8 10A0 100C  	ISMGER	MOVE.W	PORTNO,CASHW		; save port, message-type
     601    625 000051E0 11F8 109F 100E  		MOVE.B	INTYBT+1,CASHW+2
     602    626 000051E6                 		FCRASH	$50			; Fatal crash, no return!
     603    629                          	
     604    630                          	*	BUFFER Fatal Crash..."split" (non-existant) escaped character
     605    631 000051EE                 	BAD_ESC	FCRASH	$ED			; crash if escape not followed
     606    634                          	
     607    635                          	*	BUFFER Fatal Crash...GCI
     608    636 000051F6                 	DGCIH	FCRASH	18			; GCI crash
     609    639                          	
     610    640                          	*	BUFFER Fatal Crash...WCI
     611    641 000051FE                 	DWCIH	FCRASH	20			; WCI crash
     612    644                          	
     613    645                          	*	Buss Error...Fatal Crash
     614    646 00005206                 	BUSERR	FCRASH	$82
     615    649                          	
     616    650                          	*	Illegal Instruction...Fatal Crash
     617    651 0000520E                 	ILLINS	FCRASH	$83
     618    654                          	
     619    655                          	*	Address Error...Fatal Crash
     620    656 00005216                 	ADRERR	FCRASH	$84



     622    660                          	 if	TRACING
     623    661                          		TTL	'E B U S -- PDP-10 Base Code,		T R A C E'EBUS02.JMS                 E B U S -- PDP-10 Base Code,		T R A C E                       22-May-88  Page   16
Err Source Ref. Address   value
    line   line

     625    663                          	*	Tracing is individually enabled for ISIS and PDP rings, and for
     626    664                          	*	BIO and Buffering.
     627    665                          	
     628    666                          	*	An attempt is made to present a uniform trace mechanism, to permit
     629    667                          	*	the simultaneous tracing of any or all of the above.  Thus it is
     630    668                          	*	important to define the standard used:
     631    669                          	
     632    670                          	*	The trace consists of successive (time-ordered) trace-descriptors
     633    671                          	*	in a Trace-ring.  This ring starts at STRACE, folds at ETRACE, and
     634    672                          	*	the (next) descriptor address may be found in .TRACE.
     635    673                          	
     636    674                          	*	A trace-descriptor is 8 bytes long, and has the common form:
     637    675                          	
     638    676                          	*	| TR | dd | p# | ?? | V | A | L | U |
     639    677                          	
     640    678                          	*	TR|dd is a pair of characters which specify the operation (TR)
     641    679                          	*	being traced and the "direction" (dd);  p# is (usually) the current
     642    680                          	*	port;  ?? is additional information specific to the TR, and V|A|L|U
     643    681                          	*	is the (long) value being transfered.
     644    682                          	
     645    683                          	*	Possible forms are:
     646    684                          	*     TR|dd	Usage			Notes
     647    685                          	*	>R	PDP-ring input		?? is current fill-cursor
     648    686                          	*	<R	PDP-ring output		?? is current empty-cursor
     649    687                          	*	>B	Block-input		?? is current-address low byte
     650    688                          	*	@B	Block-input fetch	?? is current-address low byte
     651    689                          	*	<B	Block-output		?? is current-address low byte
     652    690                          	*	>C	DWCI
     653    691                          	*	<C	DGCI
     654    692                          	*	#C	DEMPTY
     655    693                          	*	lI	LOOK			word 3 = port, word 4 is type (right)
     656    694                          	*	<I	ISIS input		?? is number of bytes
     657    695                          	*	sI	SLOR			word 3 = port, word 4 is type (right)
     658    696                          	*	>I	ISIS output		?? is number of bytes
     659    697                          	*	Xi	FLUSH			?? is number of bytes
     660    698                          	
     661    699                          	
     662    700                          	*	This is the heart of the Trace-code
     663    701                          	*	It assumes one long has been filled already.
     664    702 0000521E 20C1            	TRACE0	MOVE.L	D1,(A0)+		; second long = (D1)
     665    703                          	
     666    704                          	*	(Almost) everything filled...should we abort?
     667    705 00005220 3038 1010       	TRACE1	MOVE.W	TR_PORT,D0		; should we trace this port only?
     668    706 00005224 6D06            		BLT	TRACE2			; no
     669    707 00005226 B02C 0000       		CMP.B	P_NUM(Rp),D0		; perhaps...is this the one?
     670    708 0000522A 6618            		BNE	TRACE4			; no...just abort
     671    709 0000522C 116C 0000 FFFA  	TRACE2	MOVE.B	P_NUM(Rp),-6(A0)	; third byte = port #
     672    710 00005232 B1FC 0003 FFE0  		CMPA.L	#ETRACE,A0
     673    711 00005238 6D06            		BLT	TRACE3
     674    712 0000523A 41F9 0002 0000  		LEA	STRACE,A0EBUS02.JMS                 E B U S -- PDP-10 Base Code,		T R A C E                       22-May-88  Page   17
Err Source Ref. Address   value
    line   line

     675    713 00005240 21C8 1000       	TRACE3	MOVE.L	A0,.TRACE
     676    714 00005244                 	TRACE4	POPM	D0/A0
     677    716 00005248 4E75            		RTS
     678    717                          	
     679    718                          	  if	ITRACE
     680    719                          	*	TRACE ISIS Transfers
     681    720                          	
     682    721 0000524A                 	TR_IOC	PUSHM	D0/A0			; PUTCH
     683    723 0000524E 2078 1000       		MOVE.L	.TRACE,A0
     684    724 00005252 30FC 3E49       		MOVE.W	#'>I',(A0)+		; first word = ISIS-trace flag
     685    725 00005256 30FC 0001       		MOVE.W	#1,(A0)+		; fourth byte = # bytes
     686    726 0000525A 4298            		CLR.L	(A0)+
     687    727 0000525C 1140 FFFF       		MOVE.B	D0,-1(A0)		; eighth byte = char
     688    728 00005260 60BE            		BRA	TRACE1
     689    729                          	
     690    730 00005262                 	TR_IOH	PUSHM	D0/A0			; PUTH
     691    732 00005266 2078 1000       		MOVE.L	.TRACE,A0
     692    733 0000526A 30FC 3E49       		MOVE.W	#'>I',(A0)+		; first word = ISIS-trace flag
     693    734 0000526E 30FC 0002       		MOVE.W	#2,(A0)+		; fourth byte = # bytes
     694    735 00005272 4258            		CLR.W	(A0)+			; third word unused
     695    736 00005274 30C0            		MOVE.W	D0,(A0)+		; fourth word = HW
     696    737 00005276 60A8            		BRA	TRACE1
     697    738                          	
     698    739 00005278                 	TR_IOW	PUSHM	D0/A0			; PUTW
     699    741 0000527C 2078 1000       		MOVE.L	.TRACE,A0
     700    742 00005280 30FC 3E49       		MOVE.W	#'>I',(A0)+		; first word = ISIS-trace flag
     701    743 00005284 30FC 0004       		MOVE.W	#4,(A0)+		; fourth byte = # bytes
     702    744 00005288 20C0            		MOVE.L	D0,(A0)+		; second long = W
     703    745 0000528A 6094            		BRA	TRACE1
     704    746                          	
     705    747 0000528C                 	TR_IOS	PUSHM	D0/A0			; SLOR
     706    749 00005290 2078 1000       		MOVE.L	.TRACE,A0
     707    750 00005294 30FC 7349       		MOVE.W	#'sI',(A0)+		; first word = ISIS-trace flag
     708    751 00005298 30FC 0003       		MOVE.W	#3,(A0)+		; fourth byte = # bytes
     709    752 0000529C 30C3            		MOVE.W	D3,(A0)+		; third word = port#
     710    753 0000529E 30C4            		MOVE.W	D4,(A0)+		; fourth word = type
     711    754 000052A0 6000 FF7E       		BRA	TRACE1
     712    755                          	
     713    756 000052A4                 	TR_IIL	PUSHM	D0/A0			; LOOK
     714    758 000052A8 2078 1000       		MOVE.L	.TRACE,A0
     715    759 000052AC 30FC 6C49       		MOVE.W	#'lI',(A0)+		; first word = ISIS-trace flag
     716    760 000052B0 30FC 0003       		MOVE.W	#3,(A0)+		; fourth byte = # bytes
     717    761 000052B4 30C3            		MOVE.W	D3,(A0)+		; third word = port#
     718    762 000052B6 30C4            		MOVE.W	D4,(A0)+		; fourth word = type
     719    763 000052B8 6000 FF66       		BRA	TRACE1
     720    764                          	
     721    765 000052BC                 	TR_IIC	PUSHM	D0/A0			; GETCH
     722    767 000052C0 2078 1000       		MOVE.L	.TRACE,A0
     723    768 000052C4 30FC 3C49       		MOVE.W	#'<I',(A0)+		; first word = ISIS-trace flag
     724    769 000052C8 30FC 0001       		MOVE.W	#1,(A0)+		; fourth byte = # bytes
     725    770 000052CC 4298            		CLR.L	(A0)+			; next long unusedEBUS02.JMS                 E B U S -- PDP-10 Base Code,		T R A C E                       22-May-88  Page   18
Err Source Ref. Address   value
    line   line

     726    771 000052CE 1140 FFFF       		MOVE.B	D0,-1(A0)		; eighth byte = char
     727    772 000052D2 6000 FF4C       		BRA	TRACE1
     728    773                          	
     729    774 000052D6                 	TR_IIH	PUSHM	D0/A0			; GETH
     730    776 000052DA 2078 1000       		MOVE.L	.TRACE,A0
     731    777 000052DE 30FC 3C49       		MOVE.W	#'<I',(A0)+		; first word = ISIS-trace flag
     732    778 000052E2 30FC 0002       		MOVE.W	#2,(A0)+		; fourth byte = # bytes
     733    779 000052E6 4258            		CLR.W	(A0)+			; next word unused
     734    780 000052E8 30C0            		MOVE.W	D0,(A0)+		; fourth word = HW
     735    781 000052EA 6000 FF34       		BRA	TRACE1
     736    782                          	
     737    783 000052EE                 	TR_IIW	PUSHM	D0/A0			; GETW
     738    785 000052F2 2078 1000       		MOVE.L	.TRACE,A0
     739    786 000052F6 30FC 3C49       		MOVE.W	#'<I',(A0)+		; first word = ISIS-trace flag
     740    787 000052FA 30FC 0004       		MOVE.W	#4,(A0)+		; fourth byte = # bytes
     741    788 000052FE 20C0            		MOVE.L	D0,(A0)+		; second long = W
     742    789 00005300 6000 FF1E       		BRA	TRACE1
     743    790                          	
     744    791 00005304                 	TR_IIF	PUSHM	D0/A0			; FLUSH
     745    793 00005308 2078 1000       		MOVE.L	.TRACE,A0
     746    794 0000530C 30FC 7849       		MOVE.W	#'xI',(A0)+		; first word = ISIS-trace flag
     747    795 00005310 30C0            		MOVE.W	D0,(A0)+		; fourth byte = # bytes
     748    796 00005312 4298            		CLR.L	(A0)+			; second long unused
     749    797 00005314 6000 FF0A       		BRA	TRACE1
     750    798                          	
     751    799                          	  endc
     752    800                          	
     753    801                          	  if	CTRACE
     779    802                          	  endc
     780    803                          	
     781    804                          	  if	BTRACE
     802    805                          	  endc
     803    806                          	
     804    807                          	  if	RTRACE
     805    808                          	*	TRACE PDP-10 Transfers
     806    809                          	
     807    810 00005318                 	TR_RIN	PUSHM	D0/A0
     808    812 0000531C 2078 1000       		MOVE.L	.TRACE,A0
     809    813 00005320 30FC 3C52       		MOVE.W	#'<R',(A0)+		; first word = ring-trace flag
     810    814 00005324 30F8 1092       		MOVE.W	PDPOEC,(A0)+		; fourth byte = PDP's OEC
     811    815 00005328 6000 FEF4       		BRA	TRACE0
     812    816                          	
     813    817 0000532C                 	TR_ROUT	PUSHM	D0/A0
     814    819 00005330 2078 1000       		MOVE.L	.TRACE,A0
     815    820 00005334 30FC 3E52       		MOVE.W	#'>R',(A0)+		; first word = ring-trace flag
     816    821 00005338 30F8 109A       		MOVE.W	PDPIFC,(A0)+		; fourth byte = PDP's OEC
     817    822 0000533C 6000 FEE0       		BRA	TRACE0
     818    823                          	
     819    824                          	  endc
     820    825                          	
     821    826                          	 endcEBUS02.JMS                 E B U S -- PDP-10 Base Code,		T R A C E                       22-May-88  Page   19
Err Source Ref. Address   value
    line   line




     823    828                          		TTL	'E B U S  --  PDP-10 Base Code,		I S I S   R I N G S'EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		I S I S   R I N G S           22-May-88  Page   20
Err Source Ref. Address   value
    line   line

     825    830                          	
     826    831                          	*		I S I S   R I N G   R O U T I N E S
     827    832                          	
     828    833                          	
     829    834                          	*	Conventions:
     830    835                          	*	Routines use dedicated registers
     831    836                          	*	A6	Output Ring Base Address
     832    837                          	*	Rs	Input Ring Base Address
     833    838                          	*	NOTE ....
     834    839                          	*	   IRSIZE & ORSIZE MUST BE LESS THAN 32K
     835    840                          	
     836    841                          	
     837    842                          	*		RING OUTPUT ROUTINES
     838    843                          	
     839    844                          	*	Insure that there is room in ring
     840    845                          	*	Expects	D0 = # characters of space required (W)
     841    846                          	*	Returns	Z FLAG = 0 means OK, 1 is no room
     842    847                          	*	Smashes D1
     843    848 00005340 322E 0002       	ROOM	MOVE.W	2(Rd),D1		; CEI
     844    849 00005344 9256            		SUB.W	(Rd),D1			;  - NFMI
     845    850 00005346 6E06            		BGT	RNOWRAP			; >0 = no wrap
     846    851 00005348 670C            		BEQ	ROOMG			; =0 = empty
     847    852 0000534A D278 1040       		ADD.W	ORSIZE,D1		; <0 = ring-wrap, compute bias
     848    853 0000534E 5941            	RNOWRAP	SUB.W	#4,D1			; can't fill ring completely
     849    854 00005350 B240            		CMP.W	D0,D1			; is required space available?
     850    855 00005352 6D04            		BLT	ROOMB			; no
     851    856 00005354 9201            		SUB.B	D1,D1			; yes..set Z=0
     852    857 00005356 4E75            	ROOMG	RTS
     853    858                          	
     854    859 00005358 123C 00FF       	ROOMB	MOVE.B	#-1,D1			; no room...set Z=1
     855    860 0000535C 4E75            		RTS
     856    861                          	
     857    862                          	*	Wait until there's a word available in ISIS output ring
     858    863                          	*	All registers preserved
     859    864 0000535E                 	WAITISW	PUSHM	D0/D1
     860    866 00005362 7004            		MOVEQ	#4,D0
     861    867 00005364 6008            		BRA	WAIT
     862    868                          	
     863    869                          	*	Wait until there's D0 bytes available in ISIS output ring
     864    870                          	*	All registers preserved
     865    871 00005366                 	WAITIS	PUSHM	D0/D1
     866    873 0000536A 0240 00FF       		AND.W	#$00FF,D0
     867    874 0000536E 61D0            	WAIT	BSR	ROOM
     868    875 00005370 66FC            		BNE	WAIT
     869    876 00005372                 		POPM	D0/D1
     870    878 00005376 4E75            		RTS
     871    879                          	
     872    880                          	
     873    881                          	
     874    882                          	*	START LOGICAL OUTPUT RECORDEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		I S I S   R I N G S           22-May-88  Page   21
Err Source Ref. Address   value
    line   line

     875    883                          	*	Provides function of ROOM, PUTH & PUTCH
     876    884                          	*	for first 3 characters of message
     877    885                          	*	D3 = PORT # (B)
     878    886                          	*	D4 = Message type code (B)
     879    887 00005378                 	SLOR	PUSHM	D0/D4			; save registers
     880    889 0000537C 3C16            		MOVE.W	(Rd),Cd			; set up cursor from NFMI
     881    890                          	 if	ITRACE
     882    891 0000537E 6100 FF0C       		BSR	TR_IOS			; record activity
     883    892                          	 endc
     884    893 00005382 4240            		CLR.W	D0
     885    894 00005384 1003            		MOVE.B	D3,D0
     886    895 00005386 3D80 6004       		MOVE.W	D0,4(Rd,Cd.W)
     887    896 0000538A E14C            		LSL.W	#8,D4
     888    897 0000538C 3D84 6006       		MOVE.W	D4,6(Rd,Cd.W)
     889    898 00005390 5646            		ADD.W	#3,Cd			; advance cursor
     890    899 00005392                 		POPM	D0/D4
     891    901 00005396 4E75            		RTS
     892    902                          	
     893    903                          	
     894    904                          	*	Put a character into the ring
     895    905                          	*	D0 = CHARACTER
     896    906 00005398                 	PUTCH	PUSHM	D0/D2			; save registers
     897    908                          	 if	ITRACE
     898    909 0000539C 6100 FEAC       		BSR	TR_IOC			; record activity
     899    910                          	 endc
     900    911 000053A0 0806 0000       		BTST	#0,Cd			; check even/odd boundary
     901    912 000053A4 670C            		BEQ	PUEVEN
     902    913 000053A6 3436 6003       		MOVE.W	3(Rd,Cd.W),D2		; get HW to fill
     903    914 000053AA 1400            		MOVE.B	D0,D2			; pack in new byte
     904    915 000053AC 3D82 6003       		MOVE.W	D2,3(Rd,Cd.W)
     905    916 000053B0 6006            		BRA	PUTODD
     906    917                          	
     907    918 000053B2 E148            	PUEVEN	LSL.W	#8,D0
     908    919 000053B4 3D80 6004       		MOVE.W	D0,4(Rd,Cd.W)
     909    920 000053B8 5246            	PUTODD	ADD.W	#1,Cd
     910    921 000053BA BC78 1040       		CMP.W	ORSIZE,Cd		; check for folding
     911    922 000053BE 6D02            		BLT	PUTC1
     912    923 000053C0 4246            		CLR.W	Cd
     913    924 000053C2                 	PUTC1	POPM	D0/D2
     914    926 000053C6 4E75            		RTS
     915    927                          	
     916    928                          	
     917    929                          	
     918    930                          	*	Put a (short) half-word into the ring
     919    931                          	*	D0 = HALF WORD
     920    932 000053C8 3D80 6004       	PUTH	MOVE.W	D0,4(Rd,Cd.W)
     921    933                          	 if	ITRACE
     922    934 000053CC 6100 FE94       		BSR	TR_IOH			; record activity
     923    935                          	 endc
     924    936 000053D0 5446            		ADD.W	#2,Cd
     925    937 000053D2 BC78 1040       		CMP.W	ORSIZE,Cd		; check for foldingEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		I S I S   R I N G S           22-May-88  Page   22
Err Source Ref. Address   value
    line   line

     926    938 000053D6 6D02            		BLT	PUTH11
     927    939 000053D8 4246            		CLR.W	Cd
     928    940 000053DA 4E75            	PUTH11	RTS
     929    941                          	
     930    942                          	
     931    943                          	
     932    944                          	*	Put a (long) word into the ring
     933    945                          	*	D0 = WORD
     934    946 000053DC 2D80 6004       	PUTW	MOVE.L	D0,4(Rd,Cd.W)
     935    947                          	 if	ITRACE
     936    948 000053E0 6100 FE96       		BSR	TR_IOW			; record activity
     937    949                          	 endc
     938    950 000053E4 5846            		ADD.W	#4,Cd
     939    951 000053E6 BC78 1040       		CMP.W	ORSIZE,Cd		; check for folding
     940    952 000053EA 6D02            		BLT	PUTW11
     941    953 000053EC 4246            		CLR.W	Cd
     942    954 000053EE 4E75            	PUTW11	RTS
     943    955                          	
     944    956                          	*	Send a quick message to ISIS
     945    957                          	*	Expects:	D3 = port # (B)
     946    958                          	*			D4 = Type-byte (B)
     947    959                          	*	Returns:	3-byte message in ring
     948    960 000053F0 6100 FF6C       	SENDQI	BSR	WAITISW			; wait for ring-space
     949    961 000053F4 6182            		BSR	SLOR			; start-logical-output-record...then ELOR
     950    962                          	
     951    963                          	
     952    964                          	*	END LOGICAL OUTPUT RECORD
     953    965 000053F6 5646            	ELOR	ADD.W	#3,Cd
     954    966 000053F8 0246 FFFC       		AND.W	#-4,Cd
     955    967 000053FC BC78 1040       		CMP.W	ORSIZE,Cd		; check for ring-fold
     956    968 00005400 6D02            		BLT	ELOR21
     957    969 00005402 4246            		CLR.W	Cd
     958    970 00005404 3C86            	ELOR21	MOVE.W	Cd,(Rd)			; advance NFMI, message now in ring
     959    971 00005406 4E75            		RTS
     960    972                          	
     961    973                          	
     962    974                          	
     963    975                          	*	Sent a TEXTC string as data
     964    976                          	*	Expects:	A0 -	pointer to string
     965    977                          	*			PORTNO - current port number
     966    978 00005408 1010            	SENDTEXT MOVE.B	(A0),D0			; get length
     967    979 0000540A 5600            		ADD.B	#3,D0			; compute message length
     968    980 0000540C 6100 FF58       		BSR	WAITIS			; wait for space in ring
     969    981 00005410 3638 10A0       		MOVE.W	PORTNO,D3		; now place text message
     970    982 00005414 1818            		MOVE.B	(A0)+,D4		; length is message-type
     971    983 00005416 6100 FF60       		BSR	SLOR			; Start-Logical-Output-Record
     972    984 0000541A 5304            	SNDTXT1	SUB.B	#1,D4			; done?
     973    985 0000541C 6DD8            		BLT	ELOR			; yes...exit via ELOR
     974    986 0000541E 1018            		MOVE.B	(A0)+,D0		; no...append another char
     975    987 00005420 6100 FF76       		BSR	PUTCH
     976    988 00005424 60F4            		BRA	SNDTXT1			; and do anotherEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		I S I S   R I N G S           22-May-88  Page   23
Err Source Ref. Address   value
    line   line

     978    990                          	*		INPUT ROUTINES
     979    991                          	
     980    992                          	*	LOOK at an input ring entry
     981    993                          	*	Returns:
     982    994                          	*	If ring is empty, then Z FLAG = 0
     983    995                          	*	Else Z .NE. 0, PORT returned in D3
     984    996                          	*	Message Type returned in D4
     985    997                          	*	All registers set up for transfer
     986    998                          	*	Cursor is advanced past PORT #
     987    999                          	
     988   1000                          	
     989   1001                          	
     990   1002 00005426 3E2D 0002       	LOOK	MOVE.W	2(Rs),Cs		; get Ring's CEI
     991   1003 0000542A BE55            		CMP.W	(Rs),Cs			; check if empty
     992   1004 0000542C 671A            		BEQ	NOIRING			; yes..exit Z=0
     993   1005 0000542E 3635 7004       		MOVE.W	4(Rs,Cs.W),D3		; PORT #
     994   1006 00005432 3835 7006       		MOVE.W	6(Rs,Cs.W),D4		; MSG TYPE BYTE
     995   1007 00005436 5778 10F0       		SUB.W	#3,IRRN
     996   1008 0000543A E04C            		LSR.W	#8,D4			; justify the type byte
     997   1009 0000543C 3003            		MOVE.W	D3,D0
     998   1010 0000543E 6100 05F8       		BSR.L	SETPORT			; set up port
     999   1011                          	 if	ITRACE
    1000   1012 00005442 6100 FE60       		BSR	TR_IIL			; record activity
    1001   1013                          	 endc
    1002   1014 00005446 5647            		ADD.W	#3,Cs			; (sets Z .NE. 0)
    1003   1015 00005448 4E75            	NOIRING	RTS				; return Z-Flag indication
    1004   1016                          	
    1005   1017                          	
    1006   1018                          	*	Get a character from the Input Ring
    1007   1019                          	*	Character returned in D0
    1008   1020 0000544A 5378 10F0       	GETCH	SUB.W	#1,IRRN			; count it
    1009   1021 0000544E 0807 0000       		BTST	#0,Cs			; getting even or odd byte?
    1010   1022 00005452 6706            		BEQ	EVENBON			; skip if even
    1011   1023 00005454 3035 7003       		MOVE.W	3(Rs,Cs.W),D0		; get from odd boundary
    1012   1024 00005458 6006            		BRA	ODDBON
    1013   1025                          	
    1014   1026 0000545A 3035 7004       	EVENBON	MOVE.W	4(Rs,Cs.W),D0		; get from even boundary
    1015   1027 0000545E E048            		LSR.W	#8,D0			; ...and justify the character
    1016   1028 00005460 0240 00FF       	ODDBON	AND.W	#$00FF,D0		; pad out to word
    1017   1029                          	 if	ITRACE
    1018   1030 00005464 6100 FE56       		BSR	TR_IIC			; record activity
    1019   1031                          	 endc
    1020   1032 00005468 5247            		ADD.W	#1,Cs			; advance and fold cursor
    1021   1033 0000546A BE78 103E       		CMP.W	IRSIZE,Cs
    1022   1034 0000546E 6D02            		BLT	GETCH1
    1023   1035 00005470 4247            		CLR.W	Cs
    1024   1036 00005472 4E75            	GETCH1	RTS				; and exit
    1025   1037                          	
    1026   1038                          	*	Get a half-word from the Input-Ring
    1027   1039                          	*	Assumed we're on correct (HW) BoundaryEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		I S I S   R I N G S           22-May-88  Page   24
Err Source Ref. Address   value
    line   line

    1028   1040                          	*	Half-word returned in D0
    1029   1041                          	
    1030   1042 00005474 3035 7004       	GETH	MOVE.W	4(Rs,Cs.W),D0		; get the value
    1031   1043                          	 if	ITRACE
    1032   1044 00005478 6100 FE5C       		BSR	TR_IIH			; record activity
    1033   1045                          	 endc
    1034   1046 0000547C 5578 10F0       		SUB.W	#2,IRRN
    1035   1047 00005480 5447            		ADD.W	#2,Cs			; advance and fold cursor
    1036   1048 00005482 BE78 103E       		CMP.W	IRSIZE,Cs
    1037   1049 00005486 6D02            		BLT	GETH1
    1038   1050 00005488 4247            		CLR.W	Cs
    1039   1051 0000548A 4E75            	GETH1	RTS				; ...and exit
    1040   1052                          	
    1041   1053                          	*	Get a (long) Word from the Input-ring
    1042   1054                          	*	Assumed we're at appropriate boundary
    1043   1055                          	*	Value returned in D0
    1044   1056 0000548C 2035 7004       	GETW	MOVE.L	4(Rs,Cs.W),D0
    1045   1057                          	 if	ITRACE
    1046   1058 00005490 6100 FE5C       		BSR	TR_IIW			; record activity
    1047   1059                          	 endc
    1048   1060 00005494 5978 10F0       		SUB.W	#4,IRRN
    1049   1061 00005498 5847            		ADD.W	#4,Cs			; advance and fold cursor
    1050   1062 0000549A BE78 103E       		CMP.W	IRSIZE,Cs
    1051   1063 0000549E 6D02            		BLT	GETW1
    1052   1064 000054A0 4247            		CLR.W	Cs
    1053   1065 000054A2 4E75            	GETW1	RTS				; ...and exit
    1054   1066                          	
    1055   1067                          	*	Flush an input record
    1056   1068                          	*	Expects number of Chars to flush in D0
    1057   1069 000054A4 0240 00FF       	FLUSH	AND.W	#$00FF,D0		; expand number
    1058   1070 000054A8 DE40            		ADD.W	D0,Cs
    1059   1071                          	 if	ITRACE
    1060   1072 000054AA 6100 FE58       		BSR	TR_IIF			; record activity
    1061   1073                          	 endc
    1062   1074                          	
    1063   1075                          	*	END LOGICAL INPUT RECORD
    1064   1076 000054AE 5647            	ELIR	ADD.W	#3,Cs			; round cursor up to next (long) word
    1065   1077 000054B0 0247 FFFC       		AND.W	#-4,Cs
    1066   1078 000054B4 BE78 103E       		CMP.W	IRSIZE,Cs		; check for folding required
    1067   1079 000054B8 6D04            		BLT	ELIR2			; no
    1068   1080 000054BA 9E78 103E       		SUB.W	IRSIZE,Cs
    1069   1081 000054BE 3B47 0002       	ELIR2	MOVE.W	Cs,2(Rs)		; now set new CEI back into Ring
    1070   1082 000054C2 4E75            		RTS				; and exit



    1072   1084                          		TTL	'E B U S  --  PDP-10 Base Code,		P D P   I / O'EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		P D P   I / O                 22-May-88  Page   25
Err Source Ref. Address   value
    line   line

    1074   1086                          	*		P D P - 1 0   I / O   R o u t i n e s
    1075   1087                          	
    1076   1088                          	***	ROUTINES TO READ FROM PDP-10
    1077   1089                          	
    1078   1090                          	
    1079   1091                          	
    1080   1092                          	*	Routine to Read a "Word" from PDP-10
    1081   1093                          	*	Smashes registers:	D0-D3
    1082   1094 000054C4 11FC 0010 1106  	RD10R	MOVE.B	#16,TMOC		; initialize counters
    1083   1095                          	
    1084   1096 000054CA 7246            	RD10AG	MOVEQ	#70,D1			; counter for BUSY try
    1085   1097 000054CC 3039 00D0 00B8  	RD10R1	MOVE.W	DSENS,D0		; Sense Busy
    1086   1098 000054D2 0800 0000       		BTST	#0,D0			; is Sense BUSY?
    1087   1099 000054D6 665C            		BNE	RDSNB			; yes...go to BUSY code
    1088   1100 000054D8 4242            		CLR.W	D2
    1089   1101 000054DA 4A38 10DE       		TST.B	BLK
    1090   1102 000054DE 6704            		BEQ	BLKK2
    1091   1103 000054E0 1438 1046       		MOVE.B	P10DLL,D2
    1092   1104 000054E4 33C2 00D0 803E  	BLKK2	MOVE.W	D2,WT103		; place low address
    1093   1105 000054EA 3438 1048       		MOVE.W	P10ADR,D2
    1094   1106 000054EE 0242 7FFF       		AND.W	#$7FFF,D2		; high-bit = 0 specifies READ operation
    1095   1107 000054F2 33C2 00D0 8038  		MOVE.W	D2,WT104		; send Low address
    1096   1108 000054F8 7646            		MOVEQ	#70,D3			; counter for Busy loop
    1097   1109 000054FA 3039 00D0 00B8  	RD10R2	MOVE.W	DSENS,D0		; Sense Busy
    1098   1110 00005500 0800 0000       		BTST	#0,D0			; Is Sense BUSY?
    1099   1111 00005504 6648            		BNE	RDSNB1			; yes...go to BUSY code
    1100   1112 00005506 31F9 00D0 403A  		MOVE.W	RD101,P10DAH		; Read high 16-bits of data from PDP
                         1042
    1101   1113 0000550E 31F9 00D0 403C  		MOVE.W	RD104,P10DAL		; Read "middle" 16-bits of data from PDP
                         1044
    1102   1114 00005516 3439 00D0 403E  		MOVE.W	RD102,D2		; Read low 4-bits of data from PDP
    1103   1115 0000551C 0242 000F       		AND.W	#$000F,D2		; zero out high-order bits
    1104   1116 00005520 11C2 1046       		MOVE.B	D2,P10DLL		; and save low 4-bits of data
    1105   1117 00005524 3439 00D0 0138  		MOVE.W	DPER,D2			; Check if there is a parity error
    1106   1118 0000552A 0802 0000       		BTST	#0,D2
    1107   1119 0000552E 6600 0488       		BNE.L	PARERR			; yes..process parity error
    1108   1120 00005532 4E75            		RTS				; ...else return
    1109   1121                          	
    1110   1122 00005534 5301            	RDSNB	SUB.B	#1,D1
    1111   1123 00005536 6694            		BNE	RD10R1			; another try if < 70 times
    1112   1124 00005538 6000 0486       		BRA.L	BUSCRAS
    1113   1125                          	
    1114   1126 0000553C 5338 1106       	TMOUT	SUB.B	#1,TMOC
    1115   1127 00005540 6700 046E       		BEQ.L	TMOUT1
    1116   1128 00005544 4A79 00D0 1038  		TST.W	DEXCO			; Reset EBUS
    1117   1129 0000554A 6000 FF7E       		BRA	RD10AG
    1118   1130                          	
    1119   1131 0000554E 3439 00D0 01B8  	RDSNB1	MOVE.W	DTMOT,D2		; test for time-out
    1120   1132 00005554 0802 0000       		BTST	#0,D2
    1121   1133 00005558 66E2            		BNE	TMOUT			; yes...go process timeoutEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		P D P   I / O                 22-May-88  Page   26
Err Source Ref. Address   value
    line   line

    1122   1134 0000555A 3439 00D0 0138  		MOVE.W	DPER,D2			; check if Parity error
    1123   1135 00005560 0802 0000       		BTST	#0,D2
    1124   1136 00005564 6600 0452       		BNE.L	PARERR			; yes...go process parity error
    1125   1137 00005568 5303            		SUB.B	#1,D3
    1126   1138 0000556A 668E            		BNE	RD10R2			; another try if < 70
    1127   1139 0000556C 6000 0452       		BRA.L	BUSCRAS
    1128   1140                          	
    1129   1141                          	*	Read from PDP, get (left-most) high 32-bit message into D1
    1130   1142 00005570                 	GETPDPL	PUSHM	D0/D2-D3
    1131   1144 00005574 6100 FF4E       		BSR	RD10R			; read from PDP
    1132   1145 00005578 2238 1042       		MOVE.L	P10DAH,D1		;  ...into D1
    1133   1146 0000557C                 		POPM	D0/D2-D3
    1134   1148 00005580 4E75            		RTS
    1135   1149                          	
    1136   1150                          	*	Read from PDP, get low-order 32-bits into D1
    1137   1151 00005582                 	GETPDPR	PUSHM	D0/D2-D3
    1138   1153 00005586 6100 FF3C       		BSR	RD10R			; read from PDP
    1139   1154 0000558A 2238 1042       		MOVE.L	P10DAH,D1
    1140   1155 0000558E E989            		LSL.L	#4,D1			; left-justify 28-bits of data
    1141   1156 00005590 1438 1046       		MOVE.B	P10DLL,D2		; low 4 bits
    1142   1157 00005594 0202 000F       		AND.B	#$0F,D2			; clear high order bits
    1143   1158 00005598 8202            		OR.B	D2,D1			; merge with previous result
    1144   1159 0000559A                 		POPM	D0/D2-D3
    1145   1161 0000559E 4E75            		RTS
    1146   1162                          	
    1147   1163                          	*	Read Word indicated by PDPOEC & put left (high) 32 bits in D1
    1148   1164                          	*	and in DAT.  Also advance and wrap PDPOEC
    1149   1165 000055A0                 	RDPDP	PUSHM	D0/D2
    1150   1167 000055A4 5378 10F2       		SUB.W	#1,ORRN
    1151   1168 000055A8 31F8 108C 1048  		MOVE.W	PDPORP,P10ADR		; PDP output ring start address
    1152   1169 000055AE 3438 1092       		MOVE.W	PDPOEC,D2		; get output ring cursor
    1153   1170 000055B2 D578 1048       		ADD.W	D2,P10ADR		; address of current word in ring
    1154   1171 000055B6 61B8            		BSR	GETPDPL			; get the word from ring
    1155   1172 000055B8 21C1 10A8       		MOVE.L	D1,DAT
    1156   1173                          	 if	RTRACE
    1157   1174 000055BC 6100 FD5A       		BSR	TR_RIN			; record activity
    1158   1175                          	 endc
    1159   1176 000055C0 5242            		ADD.W	#1,D2			; advance cursor
    1160   1177 000055C2 B478 108E       		CMP.W	PDPOSZ,D2		; check if to fold it
    1161   1178 000055C6 6602            		BNE	RDPDP1
    1162   1179 000055C8 4242            		CLR.W	D2			; yes
    1163   1180 000055CA 31C2 1092       	RDPDP1	MOVE.W	D2,PDPOEC		; save new cursor
    1164   1181 000055CE                 		POPM	D0/D2
    1165   1183 000055D2 4E75            		RTS
    1166   1184                          	
    1167   1185                          	
    1168   1186                          	*	Read another word from a storage-block in the PDP-10 to DAT
    1169   1187                          	*	and increment pointer
    1170   1188                          	*	Returns:	DAT and D1 = full-word of data read
    1171   1189                          	*			No other Registers Disturbed
    1172   1190 000055D4                 	RDBLK	PUSHM	D0/D2-D3EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		P D P   I / O                 22-May-88  Page   27
Err Source Ref. Address   value
    line   line

    1173   1192 000055D8 4280            		CLR.L	D0
    1174   1193 000055DA 202C 0004       		MOVE.L	BO_TAR(Rp),D0
    1175   1194 000055DE 6100 0096       		BSR.L	SETBLKA			; set up BLOCK-IO address
    1176   1195 000055E2 6100 FEE0       		BSR	RD10R
    1177   1196 000055E6 4238 10DE       		CLR.B	BLK
    1178   1197 000055EA 2238 1042       		MOVE.L	P10DAH,D1
    1179   1198 000055EE 21C1 10A8       		MOVE.L	D1,DAT1
    1180   1199                          	 if	BTRACE
    1182   1200                          	 endc
    1183   1201 000055F2 52AC 0004       		ADD.L	#1,BO_TAR(Rp)
    1184   1202 000055F6                 		POPM	D0/D2-D3
    1185   1204 000055FA 4E75            		RTS
    1186   1205                          	
    1187   1206                          	*	Read PDP input-ring Empty-Cursor
    1188   1207 000055FC 31FC 006D 1048  	GETIEC	MOVE.W	#$6D,P10ADR		; from o155
    1189   1208 00005602 6100 FF7E       		BSR	GETPDPR
    1190   1209 00005606 31C1 1098       		MOVE.W	D1,PDPIEC
    1191   1210 0000560A 4E75            		RTS
    1192   1211                          	
    1193   1212                          	*	Read PDP Output-ring Fill Cursor
    1194   1213 0000560C 31FC 0071 1048  	GETOFC	MOVE.W	#$71,P10ADR		; from o161
    1195   1214 00005612 6100 FF6E       		BSR	GETPDPR
    1196   1215 00005616 31C1 1090       		MOVE.W	D1,PDPOFC
    1197   1216 0000561A 4E75            		RTS
    1198   1217                          	
    1199   1218                          	
    1200   1219                          	*	Read PDP's Ring-parameters
    1201   1220                          	
    1202   1221                          	*	First, read Output-ring parameters
    1203   1222 0000561C 31FC 006F 1048  	RDPDPRP	MOVE.W	#$6F,P10ADR		; Read from o157 (Left)
    1204   1223 00005622 6100 FF4C       		BSR	GETPDPL
    1205   1224 00005626 31C1 108C       		MOVE.W	D1,PDPORP		;  ...Output-ring start-address
    1206   1225                          	
    1207   1226 0000562A 31FC 0070 1048  		MOVE.W	#$70,P10ADR		; from o160 (Left)
    1208   1227 00005630 6100 FF3E       		BSR	GETPDPL
    1209   1228 00005634 31C1 108E       		MOVE.W	D1,PDPOSZ		;  ...Output-ring Size
    1210   1229                          	
    1211   1230 00005638 61D2            		BSR	GETOFC			; Get output-ring fill cursor (from o161)
    1212   1231                          	
    1213   1232 0000563A 31FC 0048 1048  		MOVE.W	#72,P10ADR		; from o162 (Right)
    1214   1233 00005640 6100 FF40       		BSR	GETPDPR
    1215   1234 00005644 31C1 1092       		MOVE.W	D1,PDPOEC		;  ...output-ring empty cursor
    1216   1235                          	
    1217   1236                          	
    1218   1237                          	*	Next, read Input-ring parameters
    1219   1238 00005648 31FC 006B 1048  		MOVE.W	#$6B,P10ADR		; from o153 (Left)
    1220   1239 0000564E 6100 FF20       		BSR	GETPDPL
    1221   1240 00005652 31C1 1094       		MOVE.W	D1,PDPIRP		;  ...Input-ring Start-address
    1222   1241                          	
    1223   1242 00005656 31FC 006C 1048  		MOVE.W	#$6C,P10ADR		; from o154 (Left)
    1224   1243 0000565C 6100 FF12       		BSR	GETPDPLEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		P D P   I / O                 22-May-88  Page   28
Err Source Ref. Address   value
    line   line

    1225   1244 00005660 31C1 1096       		MOVE.W	D1,PDPISZ		;  ...Input-ring size
    1226   1245                          	
    1227   1246 00005664 6196            		BSR	GETIEC			; Get input-ring empty cursor (from o155)
    1228   1247                          	
    1229   1248 00005666 31FC 006E 1048  		MOVE.W	#$6E,P10ADR		; from o156 (Right)
    1230   1249 0000566C 6100 FF14       		BSR	GETPDPR
    1231   1250 00005670 31C1 109A       		MOVE.W	D1,PDPIFC		;  ...Input-ring fill cursor
    1232   1251                          	
    1233   1252                          	
    1234   1253 00005674 4E75            		RTS				; Done...return






    1236   1255                          	*	Set up Block-IO address
    1237   1256                          	*	Expects:	D0 = address (may be more than 15 bits) (L)
    1238   1257                          	*	Returns:	P10ADR and P10DLL set up; BLK set
    1239   1258                          	*			D0 smashed; No other Registers Disturbed
    1240   1259 00005676 31C0 1048       	SETBLKA	MOVE.W	D0,P10ADR		; low-order 15-bits
    1241   1260 0000567A E398            		ROL.L	#1,D0			; now manipulate high-order bits
    1242   1261 0000567C 4840            		SWAP	D0
    1243   1262 0000567E E948            		LSL.W	#4,D0
    1244   1263 00005680 11C0 1046       		MOVE.B	D0,P10DLL		; high-order 4-bits
    1245   1264 00005684 11FC 00FF 10DE  		MOVE.B	#-1,BLK
    1246   1265 0000568A 4E75            		RTSEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		P D P   I / O                 22-May-88  Page   29
Err Source Ref. Address   value
    line   line

    1248   1267                          	*	Routines to write to PDP-10
    1249   1268                          	
    1250   1269                          	
    1251   1270                          	*	Routine to write to PDP-10
    1252   1271                          	*	Smashes Registers:	D0-D2
    1253   1272 0000568C 7246            	WR10R	MOVEQ	#70,D1			; counter for Busy try
    1254   1273                          	
    1255   1274                          	*	Come back here to retry operation
    1256   1275 0000568E 3039 00D0 00B8  	WR10R1	MOVE.W	DSENS,D0		; Busy Sense
    1257   1276 00005694 0800 0000       		BTST	#0,D0			; Is Sense Busy?
    1258   1277 00005698 663E            		BNE	WRSNB			; yes, go to Busy routine
    1259   1278 0000569A 4678 1042       		NOT.W	P10DAH			; MIC will invert bits
    1260   1279 0000569E 33F8 1042 00D0  		MOVE.W	P10DAH,WT101		; transmit 1st HW to write
                         803A
    1261   1280 000056A6 4678 1044       		NOT.W	P10DAL			; MIC will invert bits
    1262   1281 000056AA 33F8 1044 00D0  		MOVE.W	P10DAL,WT102		; transmit 2nd HW to write
                         803C
    1263   1282 000056B2 1438 1046       		MOVE.B	P10DLL,D2		; transmit last 4 bits of data
    1264   1283 000056B6 4A38 10DE       		TST.B	BLK
    1265   1284 000056BA 6606            		BNE	BLKK1
    1266   1285 000056BC 4602            		NOT.B	D2			; MIC will invert bits
    1267   1286 000056BE 0242 000F       		AND.W	#$000F,D2		; clear high order bits
    1268   1287 000056C2 33C2 00D0 803E  	BLKK1	MOVE.W	D2,WT103		; move data and address to register 3
    1269   1288 000056C8 3438 1048       		MOVE.W	P10ADR,D2		; get address within PDP
    1270   1289 000056CC 0042 8000       		OR.W	#$8000,D2		; High-bit = 1 specifies WRITE
    1271   1290 000056D0 33C2 00D0 8038  		MOVE.W	D2,WT104		; to register 3
    1272   1291 000056D6 4E75            		RTS
    1273   1292                          	
    1274   1293 000056D8 5301            	WRSNB	SUB.B	#1,D1
    1275   1294 000056DA 66B2            		BNE	WR10R1			; another try if < 70 times
    1276   1295 000056DC 6000 02E2       		BRA.L	BUSCRAS
    1277   1296                          	
    1278   1297                          	
    1279   1298                          	*	Write into PDP (high), insuring that low 4 bits are ON!
    1280   1299 000056E0                 	PUTNOT0	PUSHM	D0-D3
    1281   1301 000056E4 21C1 1042       		MOVE.L	D1,P10DAH
    1282   1302 000056E8 4238 1046       		CLR.B	P10DLL			; all 1's to last 4 bits
    1283   1303 000056EC 619E            		BSR	WR10R
    1284   1304 000056EE                 		POPM	D0-D3
    1285   1306 000056F2 4E75            		RTS
    1286   1307                          	
    1287   1308                          	*	Crash the Host
    1288   1309 000056F4 2238 1004       	HCRASH	MOVE.L	CODCASH,D1		; get reason
    1289   1310 000056F8 E089            		LSR.L	#8,D1			; code into high 16 bits
    1290   1311 000056FA 31FC 0068 1048  		MOVE.W	#$68,P10ADR		; put into KEY at o150
    1291   1312 00005700 4A79 00D0 1038  		TST.W	DEXCO			; Reset EBUS
    1292   1313 00005706 61D8            		BSR	PUTNOT0
    1293   1314 00005708 31FC 0018 1048  		MOVE.W	#$18,P10ADR		; address o30
    1294   1315 0000570E 2238 1092       		MOVE.L	PDPOEC,D1		; return: Output Empty Cursor |
    1295   1316 00005712 3238 109A       		MOVE.W	PDPIFC,D1		;	  Input Fill CursorEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		P D P   I / O                 22-May-88  Page   30
Err Source Ref. Address   value
    line   line

    1296   1317 00005716 4A79 00D0 1038  		TST.W	DEXCO			; Reset EBUS
    1297   1318 0000571C 61C2            		BSR	PUTNOT0			; send it, insure word != 0
    1298   1319 0000571E 4A79 00D0 1038  		TST.W	DEXCO			; Reset EBUS
    1299   1320 00005724 4E75            		RTS				; then return
    1300   1321                          	
    1301   1322                          	
    1302   1323                          	*	Write D1 to high (left) 32 bits within PDP-10
    1303   1324 00005726                 	PUTPDPL	PUSHM	D0/D2-D3
    1304   1326 0000572A 21C1 1042       		MOVE.L	D1,P10DAH		; deposit data
    1305   1327 0000572E 11FC 000F 1046  		MOVE.B	#$0F,P10DLL		; all 0's to last 4 bits
    1306   1328 00005734 6100 FF56       		BSR	WR10R
    1307   1329 00005738                 		POPM	D0/D2-D3
    1308   1331 0000573C 4E75            		RTS
    1309   1332                          	
    1310   1333                          	*	Write D1 to low (right) 32 bits within PDP-10
    1311   1334 0000573E                 	PUTPDPR	PUSHM	D0-D3
    1312   1336 00005742 11C1 1046       		MOVE.B	D1,P10DLL		; last 4 bits to P10DLL
    1313   1337 00005746 E889            		LSR.L	#4,D1			; right-justify value
    1314   1338 00005748 21C1 1042       		MOVE.L	D1,P10DAH
    1315   1339 0000574C 6100 FF3E       		BSR	WR10R			; call write routine
    1316   1340 00005750                 		POPM	D0-D3
    1317   1342 00005754 4E75            		RTS
    1318   1343                          	
    1319   1344                          	*	Write another word to a storage-block in the PDP-10
    1320   1345                          	*	and increment pointer
    1321   1346                          	*	Expects:	DAT = full-word of data to write
    1322   1347                          	*	Returns:	No Registers Disturbed
    1323   1348 00005756                 	WRBLK	PUSHM	D0-D3
    1324   1350 0000575A 2238 10A8       		MOVE.L	DAT,D1
    1325   1351 0000575E 21C1 1042       		MOVE.L	D1,P10DAH		; save value to write
    1326   1352                          	 if	BTRACE
    1328   1353                          	 endc
    1329   1354 00005762 4280            		CLR.L	D0			; compute PDP-address to write to
    1330   1355 00005764 202C 0010       		MOVE.L	BI_TAR(Rp),D0
    1331   1356 00005768 6100 FF0C       		BSR	SETBLKA			; set up the BLOCK-IO address
    1332   1357 0000576C 6100 FF1E       		BSR	WR10R
    1333   1358 00005770 4238 10DE       		CLR.B	BLK			; clear BIO flag
    1334   1359 00005774 52AC 0010       		ADD.L	#1,BI_TAR(Rp)
    1335   1360 00005778                 		POPM	D0-D3
    1336   1362 0000577C 4E75            		RTS
    1337   1363                          	
    1338   1364                          	*	Get current output word from a storage-block in the PDP-10
    1339   1365                          	*	Returns:	Word into DAT;	No Registers Disturbed
    1340   1366 0000577E                 	GETBLK	PUSHM	D0-D3
    1341   1368 00005782 4280            		CLR.L	D0			; compute PDP-address to read from
    1342   1369 00005784 202C 0010       		MOVE.L	BI_TAR(Rp),D0
    1343   1370 00005788 6100 FEEC       		BSR	SETBLKA			; set up the BLOCK-IO address
    1344   1371 0000578C 6100 FDE2       		BSR	GETPDPL			; get the word from the ring
    1345   1372 00005790 4238 10DE       		CLR.B	BLK			; clear BIO flag
    1346   1373 00005794 21C1 10A8       		MOVE.L	D1,DAT			; save word read
    1347   1374                          	 if	BTRACEEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		P D P   I / O                 22-May-88  Page   31
Err Source Ref. Address   value
    line   line

    1349   1375                          	 endc
    1350   1376 00005798                 		POPM	D0-D3
    1351   1378 0000579C 4E75            		RTS
    1352   1379                          	
    1353   1380                          	
    1354   1381                          	*	Wait for space in PDP ring, then write DAT to it
    1355   1382 0000579E 615C            	WAITDAT	BSR	WAITPDP			; wait, then go on
    1356   1383                          	
    1357   1384                          	*	Write MSG (from DAT) to PDP ring & update base pointer
    1358   1385 000057A0 2238 10A8       	WRDAT	MOVE.L	DAT,D1			; load it and fall into WRPDP
    1359   1386                          	
    1360   1387                          	*	Write MSG (in D1) to PDP ring & update base pointer
    1361   1388 000057A4                 	WRPDP	PUSHM	D1/D2
    1362   1390                          	 if	RTRACE
    1363   1391 000057A8 6100 FB82       		BSR	TR_ROUT			; record activity in trace
    1364   1392                          	 endc
    1365   1393 000057AC 31F8 1094 1048  		MOVE.W	PDPIRP,P10ADR		; Input ring Start Address
    1366   1394 000057B2 3438 109A       		MOVE.W	PDPIFC,D2		; our fill cursor
    1367   1395 000057B6 D578 1048       		ADD.W	D2,P10ADR		; address in ring
    1368   1396 000057BA 6100 FF6A       		BSR	PUTPDPL
    1369   1397 000057BE 5242            		ADD.W	#1,D2			; advance cursor
    1370   1398 000057C0 B478 1096       		CMP.W	PDPISZ,D2		; does new cursor = ring size?
    1371   1399 000057C4 6608            		BNE	WRIRTS			; no
    1372   1400 000057C6 6100 FE34       	WRINRG	BSR	GETIEC			; yes...locate current PDP empty cursor
    1373   1401 000057CA 67FA            		BEQ	WRINRG			; spin until it moves off 0
    1374   1402 000057CC 4242            		CLR.W	D2			; ...then wrap our cursor
    1375   1403 000057CE 31C2 109A       	WRIRTS	MOVE.W	D2,PDPIFC		; save new fill cursor
    1376   1404 000057D2                 		POPM	D1/D2
    1377   1406 000057D6 4E75            		RTS
    1378   1407                          	
    1379   1408                          	*	Write Input-ring Fill Cursor
    1380   1409 000057D8 31FC 006E 1048  	PUTIFC	MOVE.W	#$6E,P10ADR		; at o156
    1381   1410 000057DE 4281            		CLR.L	D1
    1382   1411 000057E0 3238 109A       		MOVE.W	PDPIFC,D1
    1383   1412 000057E4 6100 FF58       		BSR	PUTPDPR
    1384   1413 000057E8 4E75            		RTS
    1385   1414                          	
    1386   1415                          	***	Write our Output-ring Empty cursor to PDP
    1387   1416 000057EA 4281            	PUTOEC	CLR.L	D1
    1388   1417 000057EC 3238 1092       		MOVE.W	PDPOEC,D1
    1389   1418 000057F0 31FC 0072 1048  		MOVE.W	#$72,P10ADR		; at o162
    1390   1419 000057F6 6100 FF46       		BSR	PUTPDPR			; write into PDP
    1391   1420 000057FA 4E75            		RTS
    1392   1421                          	
    1393   1422                          	
    1394   1423                          	*	Wait until (at least) 4 bytes available in PDP-10 ring
    1395   1424 000057FC 6108            	WAITPDP	BSR	FDRGSZ			; find ring size
    1396   1425 000057FE 4A78 109C       		TST.W	INRGSP
    1397   1426 00005802 67F8            		BEQ	WAITPDP			; wait until non-zero
    1398   1427 00005804 4E75            		RTS
    1399   1428                          	EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		P D P   I / O                 22-May-88  Page   32
Err Source Ref. Address   value
    line   line

    1400   1429                          	
    1401   1430                          	*	Find Cursor, then Calculate # of bytes of space left in PDP-10 Ring
    1402   1431 00005806                 	FDRGSZ	PUSHM	D0/D1
    1403   1433 0000580A 6100 FDF0       		BSR	GETIEC			; first read cursor
    1404   1434 0000580E 3238 1098       		MOVE.W	PDPIEC,D1		; PDP empty pointer
    1405   1435 00005812 9278 109A       		SUB.W	PDPIFC,D1		;  - our fill pointer
    1406   1436 00005816 6F0A            		BLE	CARWRAP			; ring wrap...skip
    1407   1437 00005818 5341            		SUB.W	#1,D1			; fill ahead of empty, insure no overflow
    1408   1438 0000581A E549            		LSL.W	#2,D1			; * 4 to get number of bytes
    1409   1439 0000581C 31C1 109C       		MOVE.W	D1,INRGSP		; this is space available
    1410   1440 00005820 602E            		BRA	CARRTS
    1411   1441                          	
    1412   1442 00005822 3238 1096       	CARWRAP	MOVE.W	PDPISZ,D1		; empty ahead of fill...
    1413   1443 00005826 9278 109A       		SUB.W	PDPIFC,D1		; ring size - our fill cursor
    1414   1444 0000582A E549            		LSL.W	#2,D1			; * 4 to get number of bytes
    1415   1445 0000582C 31C1 109C       		MOVE.W	D1,INRGSP		; this is space (to end of ring)
    1416   1446 00005830 3238 109E       		MOVE.W	INTYBT,D1		; check type
    1417   1447 00005834 670C            		BEQ	NODALN			; Skip if Needle
    1418   1448 00005836 0C41 009E       		CMP.W	#$9E,D1			; Data MSG?
    1419   1449 0000583A 6C06            		BGE	NODALN			; no...alignment not required
    1420   1450 0000583C 4A78 10A0       		TST.W	PORTNO			; port0 MSG?
    1421   1451 00005840 660E            		BNE	CARRTS			; no...must be data...just go exit
    1422   1452 00005842 3238 1098       	NODALN	MOVE.W	PDPIEC,D1		; non-data messages CAN wrap in ring!
    1423   1453 00005846 6708            		BEQ	CARRTS			; no more if null
    1424   1454 00005848 5341            		SUB.W	#1,D1			; insure no overrun
    1425   1455 0000584A E549            		LSL.W	#2,D1			; times 4
    1426   1456 0000584C D378 109C       		ADD.W	D1,INRGSP		; actual space allows for wrap
    1427   1457 00005850                 	CARRTS	POPM	D0/D1
    1428   1459 00005854 4E75            		RTS



    1430   1461                          		TTL	'E B U S  --  PDP-10 Base Code,		B U F F E R   S T U F F'EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		B U F F E R   S T U F F       22-May-88  Page   33
Err Source Ref. Address   value
    line   line

    1432   1463                          	**********************************
    1433   1464                          	**********************************
    1434   1465                          	**				**
    1435   1466                          	**	Bufferlet Routines	**
    1436   1467                          	**				**
    1437   1468                          	**********************************
    1438   1469                          	**********************************
    1439   1470                          	
    1440   1471                          	*	Character handlers.
    1441   1472                          	*	  These routines pass buffer char in D0
    1442   1473                          	*	  A0/D1 for working registers
    1443   1474                          	
    1444   1475                          	*	Get char from buffer and increment forward thru the buffer.
    1445   1476 00005856 2078 10F4       	DGCI	MOVEA.L	.BFLTS,A0		; get pointer to bufferlets
    1446   1477 0000585A 322C 001A       		MOVE.W	BB(Rp),D1		; Get index to character
    1447   1478 0000585E 4240            		CLR.W	D0			; return char as word
    1448   1479 00005860 1030 1000       		MOVE.B	0(A0,D1.W),D0		; Pick up char
    1449   1480                          	 if	CTRACE
    1451   1481                          	 endc
    1452   1482 00005864 536C 001E       		SUBQ.W	#1,BCT(Rp)		; Update count
    1453   1483 00005868 6F24            		BLE	DGCI2			; Skip if no characters left
    1454   1484 0000586A 5241            		ADDQ.W	#1,D1			; Else increment BB value
    1455   1485 0000586C 3941 001A       		MOVE.W	D1,BB(Rp)		; save pointer
    1456   1486 00005870 0241 000F       		AND.W	#BFLSIZ-1,D1		; Test if at end of bufferlet
    1457   1487 00005874 6616            		BNE	DGCI1			; skip to exit if not
    1458   1488 00005876 322C 001A       		MOVE.W	BB(Rp),D1		; bufferlet exhausted
    1459   1489 0000587A 3970 1000 001A  		MOVE.W	0(A0,D1.W),BB(Rp)	; get pointer to next bufferlet
    1460   1490 00005880 046C 000E 001A  		SUB.W	#BFLSIZ-2,BB(Rp)	; back it up to beginning of bufferlet
    1461   1491 00005886 3190 1000       		MOVE.W	(A0),0(A0,D1.W)		; Link last bufferlet to free list
    1462   1492 0000588A 3081            		MOVE.W	D1,(A0)			; And put at the head of the free list
    1463   1493                          	
    1464   1494 0000588C 4E75            	DGCI1	RTS				; Then exit
    1465   1495                          	
    1466   1496                          	*	Last char in buffer
    1467   1497 0000588E 6D00 F966       	DGCI2	BLT.L	DGCIH			; CRASH if empty
    1468   1498 00005892 0641 000E       		ADD.W	#BFLSIZ-2,D1		; Bump character pointer past
    1469   1499                          	*						end of bufferlet
    1470   1500 00005896 0241 FFF0       		AND.W	#-BFLSIZ,D1		; Make chain a multiple of BFLSIZ
    1471   1501 0000589A 3190 1000       		MOVE.W	(A0),0(A0,D1.W)		; chain free-list to this bufferlet
    1472   1502 0000589E 3081            		MOVE.W	D1,(A0)			; Update free list
    1473   1503 000058A0 4E75            		RTS



    1475   1505                          	*	Peek at next char in buffer.
    1476   1506                          	*	return:	CC set EQ if buffer empty
    1477   1507                          	*	else	CC set NE, char in D0.L
    1478   1508                          	*			Unless ESC'ed, then D0 contains -1.W | Char.W
    1479   1509 000058A2 4A6C 001E       	DPEEK	TST.W	BCT(Rp)			; is buffer empty?
    1480   1510 000058A6 673A            		BEQ	DPEEKX			; exit (CC EQ) if notEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		B U F F E R   S T U F F       22-May-88  Page   34
Err Source Ref. Address   value
    line   line

    1481   1511 000058A8 2078 10F4       		MOVEA.L	.BFLTS,A0		; get pointer to bufferlets
    1482   1512 000058AC 322C 001A       		MOVE.W	BB(Rp),D1		; Get index to character
    1483   1513 000058B0 4280            		CLR.L	D0			; return char as long
    1484   1514 000058B2 1030 1000       		MOVE.B	0(A0,D1.W),D0		; Pick up char
    1485   1515 000058B6 0C00 001B       		CMP.B	#ESC,D0			; ESC?
    1486   1516 000058BA 6626            		BNE	DPEEKX			; exit if not ESC
    1487   1517 000058BC 5241            		ADDQ.W	#1,D1			; Else increment BB value
    1488   1518 000058BE 0241 000F       		AND.W	#BFLSIZ-1,D1		; Test if at end of bufferlet
    1489   1519 000058C2 660E            		BNE	DPEEK1			; skip if not
    1490   1520 000058C4 322C 001A       		MOVE.W	BB(Rp),D1		; bufferlet exhausted
    1491   1521 000058C8 3230 1001       		MOVE.W	1(A0,D1.W),D1		; get pointer to next bufferlet
    1492   1522 000058CC 0441 000F       		SUB.W	#BFLSIZ-1,D1		; back it up to beginning of bufferlet
    1493   1523 000058D0 6004            		BRA	DPEEK2			; and skip
    1494   1524                          	
    1495   1525 000058D2 322C 001A       	DPEEK1	MOVE.W	BB(Rp),D1		; examine next char
    1496   1526                          	
    1497   1527 000058D6 203C FFFF 0000  	DPEEK2	MOVE.L	#$FFFF0000,D0		; ESC'ed char...return -1 in high-word
    1498   1528 000058DC 1030 1001       		MOVE.B	1(A0,D1.W),D0		; ESC'ed char in low word
    1499   1529 000058E0 7201            		MOVEQ	#1,D1			; insure CC NE
    1500   1530                          	
    1501   1531 000058E2 4E75            	DPEEKX	RTSEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		B U F F E R   S T U F F       22-May-88  Page   35
Err Source Ref. Address   value
    line   line

    1503   1533                          	*	Put a character into the buffer
    1504   1534 000058E4 2078 10F4       	DWCI	MOVEA.L	.BFLTS,A0		; get pointer to bufferlet area
    1505   1535                          	 if	CTRACE
    1507   1536                          	 endc
    1508   1537 000058E8 4A6C 001E       		TST.W	BCT(Rp)			; Check count
    1509   1538 000058EC 6F40            		BLE	DWCI4			; If new buffer, set up attention flags
    1510   1539 000058EE 526C 001E       		ADDQ.W	#1,BCT(Rp)		; Else update count
    1511   1540 000058F2 526C 001C       		ADDQ.W	#1,BE(Rp)		; Advance BE
    1512   1541 000058F6 322C 001C       		MOVE.W	BE(Rp),D1		; Get pointer to new character position
    1513   1542 000058FA 0241 000F       		AND.W	#BFLSIZ-1,D1		; Test if bufferlet full
    1514   1543 000058FE 670A            		BEQ	DWCI2			; End of bufferlet
    1515   1544 00005900 322C 001C       		MOVE.W	BE(Rp),D1		; ok...get index again
    1516   1545 00005904 1180 1000       		MOVE.B	D0,0(A0,D1.W)		; And save char in buffer
    1517   1546 00005908 4E75            		RTS
    1518   1547                          	
    1519   1548                          	*	Need a new bufferlet
    1520   1549 0000590A 322C 001C       	DWCI2	MOVE.W	BE(Rp),D1
    1521   1550 0000590E 4A50            		TST.W	(A0)			; any more bufferlets?
    1522   1551 00005910 6E04            		BGT	DWCI3			; Skip if there is another
    1523   1552 00005912 6100 0040       		 BSR.L	WRE			; (Else open the reserve tank)
    1524   1553                          	
    1525   1554 00005916 3190 1000       	DWCI3	MOVE.W	(A0),0(A0,D1.W)		; Link new bufferlet to last one
    1526   1555 0000591A 3210            		MOVE.W	(A0),D1			; And remove from free list
    1527   1556 0000591C 30B0 1000       		MOVE.W	0(A0,D1.W),(A0)
    1528   1557 00005920 0441 000E       		SUB.W	#BFLSIZ-2,D1		; Back up new bufferlet
    1529   1558 00005924 3941 001C       		MOVE.W	D1,BE(Rp)		; Save as new BE
    1530   1559 00005928 1180 1000       		MOVE.B	D0,0(A0,D1.W)		; Put the character there
    1531   1560 0000592C 4E75            		RTS
    1532   1561                          	
    1533   1562                          	*	The buffer was empty
    1534   1563 0000592E 6D00 F8CE       	DWCI4	BLT.L	DWCIH			; count should NEVER be negative
    1535   1564 00005932 526C 001E       		ADD.W	#1,BCT(Rp)		; Set count = 1
    1536   1565 00005936 4A50            		TST.W	(A0)			; Any buffers on free-list?
    1537   1566 00005938 6E02            		BGT	DWCI5			; Skip if there was one
    1538   1567 0000593A 6118            		 BSR	WRE			; Else open the reserve tank
    1539   1568                          	
    1540   1569 0000593C 3210            	DWCI5	MOVE.W	(A0),D1			; Pop a bufferlet off free list
    1541   1570 0000593E 30B0 1000       		MOVE.W	0(A0,D1.W),(A0)		; Update free list
    1542   1571 00005942 0441 000E       		SUB.W	#BFLSIZ-2,D1		; Point it at first character
    1543   1572 00005946 3941 001A       		MOVE.W	D1,BB(Rp)		; Set up BB
    1544   1573 0000594A 3941 001C       		MOVE.W	D1,BE(Rp)		; And BE
    1545   1574 0000594E 1180 1000       		MOVE.B	D0,0(A0,D1.W)		; Put the character there
    1546   1575 00005952 4E75            		RTSEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		B U F F E R   S T U F F       22-May-88  Page   36
Err Source Ref. Address   value
    line   line

    1548   1577                          	*	Move reserve storage supply to main free list
    1549   1578 00005954 30B8 10FA       	WRE	MOVE.W	R_TANK,(A0)		; Get pointer to reserve bufferlets
    1550   1579 00005958 6F00 006E       		BLE.L	WREH			; was empty...abort
    1551   1580 0000595C 4278 10FA       		CLR.W	R_TANK			; Set reserve bufferlets empty (=0)
    1552   1581 00005960 4E75            		RTS




    1554   1583                          	*	Return all the space used by the buffer
    1555   1584                          	
    1556   1585 00005962 4A6C 001E       	DEMPTY	TST.W	BCT(Rp)			; Check contents
    1557   1586 00005966 6726            		BEQ	C1			; empty...just exit
    1558   1587 00005968 426C 001E       		CLR.W	BCT(Rp)			; not empty...set count = 0
    1559   1588                          	 if	CTRACE
    1561   1589                          	 endc
    1562   1590 0000596C 2078 10F4       		MOVEA.L	.BFLTS,A0		; get pointer to bufferlet area
    1563   1591 00005970 302C 001C       		MOVE.W	BE(Rp),D0		; Get pointer to last character in buffer
    1564   1592 00005974 0640 000E       		ADD.W	#BFLSIZ-2,D0		; Locate the pointer in this bufferlet
    1565   1593 00005978 0240 FFF0       		AND.W	#-BFLSIZ,D0
    1566   1594 0000597C 3190 0000       		MOVE.W	(A0),0(A0,D0.W)		; Chain previous free list to this
    1567   1595                          	*						bufferlet
    1568   1596 00005980 302C 001A       		MOVE.W	BB(Rp),D0		; Pointer to first char in buffer
    1569   1597 00005984 0640 000E       		ADD.W	#BFLSIZ-2,D0
    1570   1598 00005988 0240 FFF0       		AND.W	#-BFLSIZ,D0
    1571   1599 0000598C 3080            		MOVE.W	D0,(A0)			; Put the buffer's bufferlets
    1572   1600                          	*						onto free list
    1573   1601 0000598E 70FF            	C1	MOVEQ	#-1,D0			; "empty" flag
    1574   1602 00005990 4E75            		RTS				; And return



    1576   1604                          		TTL	'E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G'EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G   22-May-88  Page   37
Err Source Ref. Address   value
    line   line

    1578   1606                          	*	ERROR CONDITION DETECTED, CRASH INTERFACE
    1579   1607                          	
    1580   1608                          	
    1581   1609 00005992                 	NOKEY	CRASH	0			; key not refreshed by host
    1582   1612                          	
    1583   1613 0000599A                 	BADKEY	CRASH	3			; bad key read from host
    1584   1616                          	
    1585   1617                          	*	Crash due to bad Message Type
    1586   1618 000059A2 21F8 10A8 100C  	MERROR	MOVE.L	DAT,CASHW		; save copy of DAT
    1587   1619 000059A8                 		CRASH	4			; crash the interface
    1588   1622                          	
    1589   1623                          	*	Crash due to MIC timeout
    1590   1624 000059B0                 	TMOUT1	CRASH	8
    1591   1627                          	
    1592   1628                          	*	Crash due to MIC parity error
    1593   1629 000059B8                 	PARERR	CRASH	9
    1594   1632                          	
    1595   1633                          	*	Crash due to  MIC too busy too long
    1596   1634 000059C0                 	BUSCRAS	CRASH	10
    1597   1637                          	
    1598   1638 000059C8 11FC 0015 1004  	WREH	MOVE.B	#21,CODCASH		; WRE crash
    1599   1639                          	
    1600   1640                          	*	Routine that crashes the host for interface problems
    1601   1641 000059CE 4FF8 1000       	VCRASH	LEA	STKTOP,SP		; reset stack
    1602   1642 000059D2 4A38 1108       		TST.B	DIAG
    1603   1643 000059D6 6600 2446       		BNE.L	DIAGERR
    1604   1644 000059DA 4A79 00D0 1038  		TST.W	DEXCO			; Reset EBUS
    1605   1645 000059E0 610C            		BSR	HODOWN			; set host down
    1606   1646 000059E2 6100 FD10       		BSR	HCRASH			; crash the host
    1607   1647 000059E6 6100 00E2       		BSR.L	EMPTY			; Empty ISIS ring
    1608   1648 000059EA 6000 01CE       		BRA.L	EXEC			; and start over
    1609   1649                          	
    1610   1650                          	
    1611   1651                          	*	HODOWN - Set HTDWN and report host down
    1612   1652 000059EE 7801            	HODOWN	MOVEQ	#1,D4
    1613   1653 000059F0 11C4 108B       		MOVE.B	D4,HTDWN		; set down and fall through...
    1614   1654                          	
    1615   1655                          	*	HDOWN -	Report Host Down or Gone
    1616   1656                          	*	D4 = 1 for Down, 3 for Gone (B)
    1617   1657 000059F4 1038 104E       	HDOWN	MOVE.B	HSTAT,D0		; going down and already down/gone?
    1618   1658 000059F8 C004            		AND.B	D4,D0			; or going gone and already gone?
    1619   1659 000059FA B900            		EOR.B	D4,D0
    1620   1660 000059FC 6738            		BEQ	HDN4			; yes...nothing to be done
    1621   1661 000059FE 11C4 104E       		MOVE.B	D4,HSTAT		; no...change required
    1622   1662 00005A02 6100 0084       		BSR.L	HREPRT			; report it
    1623   1663 00005A06 303C 00FF       		MOVE.W	#MAXPORT-1,D0		; for all ports...
    1624   1664 00005A0A 612C            	HDN1	BSR	SETPORT			; set up port
    1625   1665 00005A0C 082C 0000 0001  		BTST	#PF_ACT,P_FLAGS(Rp)	; test if port is active
    1626   1666 00005A12 6608            		BNE	HDN2			; yes
    1627   1667 00005A14 082C 0001 0001  		BTST	#PF_ILI,P_FLAGS(Rp)	; test if port is In_LogInEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G   22-May-88  Page   38
Err Source Ref. Address   value
    line   line

    1628   1668 00005A1A 6712            		BEQ	HDN3			; no
    1629   1669 00005A1C 612A            	HDN2	BSR	RBTALL			; yes...reset everything
    1630   1670 00005A1E 6100 0156       		BSR.L	DPORT			;  ...and remember to reduce the port-count
    1631   1671 00005A22 3638 10A0       		MOVE.W	PORTNO,D3		; Port #
    1632   1672 00005A26 183C 009F       		MOVE.B	#$9F,D4			; ZAPPER
    1633   1673 00005A2A 6100 F9C4       		BSR	SENDQI			; send Quick ISIS message
    1634   1674 00005A2E 3038 10A0       	HDN3	MOVE.W	PORTNO,D0		; on to next port
    1635   1675 00005A32 5340            		SUB.W	#1,D0
    1636   1676 00005A34 6ED4            		BGT	HDN1
    1637   1677 00005A36 4E75            	HDN4	RTS				; done...exit
    1638   1678                          	
    1639   1679                          	
    1640   1680                          	*	set up Rp, PORTNO
    1641   1681                          	*	Expect:	D0 = port number (W)
    1642   1682                          	*	Return:	D0 smashed, Rp set up
    1643   1683 00005A38 31C0 10A0       	SETPORT	MOVE.W	D0,PORTNO		; set up port number
    1644   1684 00005A3C C0FC 0020       		MULU	#PD_SIZ,D0		; compute offset into port-descriptor
    1645   1685 00005A40 49F8 190A       		LEA	PORTS,Rp
    1646   1686 00005A44 D8C0            		ADD.W	D0,Rp			; compute address of port-descriptor
    1647   1687 00005A46 4E75            		RTS
    1648   1688                          	
    1649   1689                          	
    1650   1690                          	
    1651   1691                          	*	Special routine to manipulate bits-flags
    1652   1692                          	
    1653   1693                          	*	Reset everything...
    1654   1694 00005A48 6100 0736       	RBTALL	BSR.L	RBTBKO			; cancel block-output
    1655   1695 00005A4C 6100 075E       		BSR.L	RBTBKI			; cancel block-input
    1656   1696 00005A50 6100 FF10       		BSR	DEMPTY			; empty any buffer storage
    1657   1697 00005A54 6100 0764       		BSR.L	RBTBUF			; clean up buffer usage
    1658   1698 00005A58 422C 0001       		CLR.B	P_FLAGS(Rp)		; clear everything
    1659   1699 00005A5C 197C 009D 0002  		MOVE.B	#157,XMITLMT(Rp)	; initialize transmit limit
    1660   1700 00005A62 4E75            		RTS
    1661   1701                          	
    1662   1702                          	
    1663   1703                          	*	Verify KEY-cell in PDP-10...
    1664   1704                          	*	If expected (i.e., $CDFA68CB2), zero out key, return CC EQ
    1665   1705                          	*	Else return CC NE
    1666   1706 00005A64 31FC 0068 1048  	DOKEY	MOVE.W	#$68,P10ADR		; get KEY at o150
    1667   1707 00005A6A 6100 FB16       		BSR	GETPDPR			; get (right) bits
    1668   1708 00005A6E 0C81 DFA6 8CB2  		CMP.L	#$DFA68CB2,D1
    1669   1709 00005A74 6610            		BNE	DOKEYX			; no match...return with CC set NE
    1670   1710 00005A76 0C38 00CD 1042  		CMP.B	#$CD,P10DAH		; check high bits
    1671   1711 00005A7C 6608            		BNE	DOKEYX			; no match...return with CC set NE
    1672   1712 00005A7E 4281            		CLR.L	D1			; match...zero out the key
    1673   1713 00005A80 6100 FCBC       		BSR	PUTPDPR
    1674   1714 00005A84 9241            		SUB.W	D1,D1			; insure CC set EQ
    1675   1715 00005A86 4E75            	DOKEYX	RTS				; return
    1676   1716                          	
    1677   1717                          	
    1678   1718                          	*	HREPRT - Report Host status to SupEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G   22-May-88  Page   39
Err Source Ref. Address   value
    line   line

    1679   1719 00005A88 700E            	HREPRT	MOVEQ	#14,D0			; we'll need 14 bytes of space in ring
    1680   1720 00005A8A 6100 F8DA       		BSR	WAITIS			; wait until it's there
    1681   1721 00005A8E 4243            		CLR.W	D3			; for Port 0
    1682   1722 00005A90 7810            		MOVEQ	#$10,D4			; Message Type 10
    1683   1723 00005A92 6100 F8E4       		BSR	SLOR
    1684   1724 00005A96 4200            		CLR.B	D0			; padding (B)
    1685   1725 00005A98 6100 F8FE       		BSR	PUTCH
    1686   1726 00005A9C 3038 104A       		MOVE.W	HOSTN,D0		; Host Number (HW)
    1687   1727 00005AA0 6726            		BEQ	HREPRTX			; abort if null host-number
    1688   1728 00005AA2 6100 F924       		BSR	PUTH
    1689   1729 00005AA6 3038 104C       		MOVE.W	HOSTP,D0		; Host Ports (HW)
    1690   1730 00005AAA 6100 F91C       		BSR	PUTH
    1691   1731 00005AAE 4240            		CLR.W	D0			; Relative Host# = 0 (HW)
    1692   1732 00005AB0 6100 F916       		BSR	PUTH
    1693   1733 00005AB4 3038 104E       		MOVE.W	HSTAT,D0		; Status | Hkey=0 (HW)
    1694   1734 00005AB8 6100 F90E       		BSR	PUTH
    1695   1735 00005ABC 303C 0091       		MOVE.W	#PRODID,D0		; No IIX | ProductID (HW)
    1696   1736 00005AC0 6100 F906       		BSR	PUTH
    1697   1737 00005AC4 6100 F930       		BSR	ELOR
    1698   1738 00005AC8 4E75            	HREPRTX	RTS
    1699   1739                          	
    1700   1740                          	
    1701   1741                          	*	EMPTY - EMPTY OUT ISIS INPUT RING
    1702   1742 00005ACA 6100 F95A       	EMPTY	BSR	LOOK			; see what's next in ring
    1703   1743 00005ACE 6602            		BNE	EMP1
    1704   1744 00005AD0 4E75            		RTS				; return..ring is empty
    1705   1745                          	
    1706   1746 00005AD2 4A43            	EMP1	TST.W	D3			; check port number
    1707   1747 00005AD4 6724            		BEQ	EMP2			; port0 = intra-node message
    1708   1748 00005AD6 3004            		MOVE.W	D4,D0			; Check for Needle
    1709   1749 00005AD8 6738            		BEQ	EMP5			; special handling for needles
    1710   1750 00005ADA 0C40 00B2       		CMP.W	#$B2,D0			; Check for Pseudo-needle
    1711   1751 00005ADE 6740            		BEQ	EMP6			; special handling for P-needles
    1712   1752 00005AE0 0C40 009D       		CMP.W	#$9D,D0			; in range of data message?
    1713   1753 00005AE4 6F26            		BLE	EMP4			; Just flush data
    1714   1754 00005AE6 0C40 00C1       		CMP.W	#$C1,D0			; range check
    1715   1755 00005AEA 6C00 F6EE       		BGE	ISMGER
    1716   1756 00005AEE 0444 009E       		SUB.W	#$9E,D4
    1717   1757 00005AF2 41F8 5B2C 4E71  		LEA	IMSSZ,A0
    1718   1758 00005AF8 600E            		BRA	EMP3
    1719   1759                          	
    1720   1760                          	*	Flush port0 messages
    1721   1761 00005AFA 0C44 000E       	EMP2	CMP.W	#$0E,D4			; range check
    1722   1762 00005AFE 6C00 F6DA       		BGE	ISMGER
    1723   1763 00005B02 41F8 5B50 4E71  		LEA	IPZSZ,A0
    1724   1764                          	
    1725   1765 00005B08 1030 4000       	EMP3	MOVE.B	0(A0,D4.W),D0		; table lookup for message length
    1726   1766                          	
    1727   1767 00005B0C 6100 F996       	EMP4	BSR	FLUSH			; remove MSG from ring
    1728   1768 00005B10 60B8            		BRA	EMPTY			; ...and get next one
    1729   1769                          	EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G   22-May-88  Page   40
Err Source Ref. Address   value
    line   line

    1730   1770                          	*	Needle
    1731   1771 00005B12 183C 009F       	EMP5	MOVE.B	#$9F,D4			; ZAPPER
    1732   1772 00005B16 6100 F8D8       		BSR	SENDQI			; send Quick Message to ISIS
    1733   1773 00005B1A 6100 F92E       		BSR	GETCH			; get needle-length
    1734   1774 00005B1E 60EC            		BRA	EMP4
    1735   1775                          	
    1736   1776                          	*	Psuedo-needle
    1737   1777 00005B20 183C 009F       	EMP6	MOVE.B	#$9F,D4			; ZAPPER
    1738   1778 00005B24 6100 F8CA       		BSR	SENDQI			; send Quick Message to ISIS
    1739   1779 00005B28 7003            		MOVEQ	#3,D0			; set pseudo-needle length
    1740   1780 00005B2A 60E0            		BRA	EMP4
    1741   1781                          	
    1742   1782                          	
    1743   1783                          	*	ISIS INPUT MESSAGE LENGTHS (NOT COUNTING PORT NMBR)
    1744   1784 00005B2C 00              	IMSSZ	DC.B	0			; 9E
    1745   1785 00005B2D 00              		DC.B	0			; 9F
    1746   1786 00005B2E 00              		DC.B	0			; A0
    1747   1787 00005B2F 00              		DC.B	0			; A1
    1748   1788 00005B30 00              		DC.B	0			; A2
    1749   1789 00005B31 00              		DC.B	0			; A3
    1750   1790 00005B32 00              		DC.B	0			; A4
    1751   1791 00005B33 00              		DC.B	0			; A5
    1752   1792 00005B34 00              		DC.B	0			; A6
    1753   1793 00005B35 00              		DC.B	0			; A7
    1754   1794 00005B36 00              		DC.B	0			; A8
    1755   1795 00005B37 00              		DC.B	0			; A9
    1756   1796 00005B38 00              		DC.B	0			; AA
    1757   1797 00005B39 00              		DC.B	0			; AB
    1758   1798 00005B3A 00              		DC.B	0			; AC
    1759   1799 00005B3B 00              		DC.B	0			; AD
    1760   1800 00005B3C 00              		DC.B	0			; AE
    1761   1801 00005B3D 00              		DC.B	0			; AF
    1762   1802 00005B3E 01              		DC.B	1			; B0
    1763   1803 00005B3F 02              		DC.B	2			; B1
    1764   1804 00005B40 03              		DC.B	3			; B2
    1765   1805 00005B41 01              		DC.B	1			; B3
    1766   1806 00005B42 01              		DC.B	1			; B4
    1767   1807 00005B43 01              		DC.B	1			; B5
    1768   1808 00005B44 07              		DC.B	7			; B6
    1769   1809 00005B45 05              		DC.B	5			; B7
    1770   1810 00005B46 00              		DC.B	0			; B8
    1771   1811 00005B47 01              		DC.B	1			; B9
    1772   1812 00005B48 00              		DC.B	0			; BA
    1773   1813 00005B49 00              		DC.B	0			; BB
    1774   1814 00005B4A 00              		DC.B	0			; BC
    1775   1815 00005B4B 00              		DC.B	0			; BD
    1776   1816 00005B4C 01              		DC.B	1			; BE
    1777   1817 00005B4D 00              		DC.B	0			; BF
    1778   1818 00005B4E 00              		DC.B	0			; C0
    1779   1819 00005B4F 05              		DC.B	5			; C1
    1780   1820                          	EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G   22-May-88  Page   41
Err Source Ref. Address   value
    line   line

    1781   1821                          	
    1782   1822                          	*	ISIS INTRA-NODE MESSAGE LENGTHS
    1783   1823 00005B50 00              	IPZSZ	DC.B	0			; 00
    1784   1824 00005B51 00              		DC.B	0			; 01
    1785   1825 00005B52 01              		DC.B	1			; 02
    1786   1826 00005B53 06              		DC.B	6			; 03
    1787   1827 00005B54 09              		DC.B	9			; 04
    1788   1828 00005B55 05              		DC.B	5			; 05
    1789   1829 00005B56 05              		DC.B	5			; 06
    1790   1830 00005B57 08              		DC.B	8			; 07
    1791   1831 00005B58 08              		DC.B	8			; 08
    1792   1832 00005B59 04              		DC.B	4			; 09
    1793   1833 00005B5A 07              		DC.B	7			; 0A
    1794   1834 00005B5B 04              		DC.B	4			; 0B
    1795   1835 00005B5C 07              		DC.B	7			; 0C
    1796   1836 00005B5D 00              		DC.B	0			; 0D



    1798   1838                          	*		Host-port Management (soft Shut/Answer)
    1799   1839                          	
    1800   1840                          	
    1801   1841                          	*	IPORT - INCREMENT NUMBER OF PORTS
    1802   1842 00005B5E 5278 1058       	IPORT	ADD.W	#1,NPORTS		; increment number
    1803   1843 00005B62 3038 1058       		MOVE.W	NPORTS,D0
    1804   1844 00005B66 B078 1056       		CMP.W	MXPORT,D0
    1805   1845 00005B6A 6E02            		BGT	IPORT2			; reached limit
    1806   1846 00005B6C 4E75            	IPORT1	RTS
    1807   1847                          	
    1808   1848 00005B6E 11FC 0001 1107  	IPORT2	MOVE.B	#1,PFULL		; full (shutable)
    1809   1849 00005B74 6012            		BRA	DPORT1
    1810   1850                          	
    1811   1851                          	
    1812   1852                          	*	DPORT - DECREMENT NUMBER OF PORTS
    1813   1853 00005B76 5378 1058       	DPORT	SUB.W	#1,NPORTS		; decrement number
    1814   1854 00005B7A 3038 1058       		MOVE.W	NPORTS,D0
    1815   1855 00005B7E B078 1056       		CMP.W	MXPORT,D0
    1816   1856 00005B82 66E8            		BNE	IPORT1			; not at limit
    1817   1857 00005B84 4238 1107       		CLR.B	PFULL			; not full (answerable)
    1818   1858                          	
    1819   1859 00005B88 700A            	DPORT1	MOVEQ	#10,D0			; need 10 bytes for Message
    1820   1860 00005B8A 6100 F7DA       		BSR	WAITIS			; insure there is room there
    1821   1861 00005B8E 4243            		CLR.W	D3			; port 0,
    1822   1862 00005B90 780A            		MOVEQ	#10,D4			; message type 10d
    1823   1863 00005B92 6100 F7E4       		BSR	SLOR
    1824   1864 00005B96 4200            		CLR.B	D0			; 1 byte of padding
    1825   1865 00005B98 6100 F7FE       		BSR	PUTCH
    1826   1866 00005B9C 3038 104A       		MOVE.W	HOSTN,D0		; Host number (HW)
    1827   1867 00005BA0 6100 F826       		BSR	PUTH
    1828   1868 00005BA4 7001            		MOVEQ	#1,D0
    1829   1869 00005BA6 9038 1107       		SUB.B	PFULL,D0		; soft shut/answer (HW)EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		E R R O R   H A N D L I N G   22-May-88  Page   42
Err Source Ref. Address   value
    line   line

    1830   1870 00005BAA 6100 F81C       		BSR	PUTH
    1831   1871 00005BAE 4240            		CLR.W	D0			; only host is 0 (HW)
    1832   1872 00005BB0 6100 F816       		BSR	PUTH
    1833   1873 00005BB4 6100 F840       		BSR	ELOR
    1834   1874 00005BB8 4E75            		RTS



    1836   1876                          		TTL	'E B U S  --  PDP-10 Base Code,		E X E C   L O O P'EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		E X E C   L O O P             22-May-88  Page   43
Err Source Ref. Address   value
    line   line

    1838   1878                          	
    1839   1879                          	
    1840   1880 00005BBA BFFC 0000 1000  	EXEC	CMPA.L	#STKTOP,SP		; if stack is empty,
    1841   1881 00005BC0 670A            		BEQ	EXEC1			; then everything is OK...
    1842   1882 00005BC2                 		FCRASH	$60			; Else, something is dreadfully WRONG!
    1843   1885                          	
    1844   1886 00005BCC 2078 102A       	EXEC1	MOVE.L	.SYNC,A0		; get sync address
    1845   1887 00005BD0 3010            		MOVE.W	(A0),D0			; did slot get back before us?
    1846   1888 00005BD2 6D0E            		BLT	EXEC4			; yes
    1847   1889 00005BD4 9150            		SUB.W	D0,(A0)			; no...set to 0
    1848   1890                          	
    1849   1891 00005BD6 303C 0064       	EXEC2	MOVE.W	#100,D0			; wait-loop
    1850   1892 00005BDA 5340            	EXEC3	SUB.W	#1,D0
    1851   1893 00005BDC 6EFC            		BGT	EXEC3			; insure we don't tie up DMA
    1852   1894 00005BDE 4A50            		TST.W	(A0)			; waiting for slot to set it
    1853   1895 00005BE0 6CF4            		BGE	EXEC2
    1854   1896                          	
    1855   1897                          	*	we set SYNC to 1 while we are executing, 0 when we're done
    1856   1898                          	*	Slot sets it to -1, and uses the number to generate speedometer.
    1857   1899 00005BE2 30BC 0001       	EXEC4	MOVE.W	#1,(A0)			; Syncronized...reset it and proceed
    1858   1900 00005BE6 3038 104A       		MOVE.W	HOSTN,D0		; now get host #
    1859   1901 00005BEA E148            		LSL.W	#8,D0
    1860   1902 00005BEC 8078 1058       		OR.W	NPORTS,D0		; and get # ports
    1861   1903 00005BF0 3140 0002       		MOVE.W	D0,2(A0)		; give slot <HOST# | #PORTS> to display
    1862   1904 00005BF4 3178 104E 0004  		MOVE.W	HSTAT,4(A0)		; give slot <HSTAT> to display
    1863   1905 00005BFA 31F8 103E 10F0  		MOVE.W	IRSIZE,IRRN		; set "throttles"
    1864   1906 00005C00 31F8 108E 10F2  		MOVE.W	PDPOSZ,ORRN		;  (one "rings"-worth)



    1866   1908                          		TTL	'E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T'EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         22-May-88  Page   44
Err Source Ref. Address   value
    line   line

    1868   1910                          	*		O U T P U T   F R O M   P D P - 1 0   T O   I S I S
    1869   1911                          	
    1870   1912                          	
    1871   1913                          	
    1872   1914 00005C06 4A38 108B       	HOSTOUT	TST.B	HTDWN			; check host status
    1873   1915 00005C0A 6600 0080       		BNE.L	HOUTX			; Host Down..Skip
    1874   1916 00005C0E 6100 FBDA       		BSR	PUTOEC
    1875   1917 00005C12 4A78 10F2       		TST.W	ORRN
    1876   1918 00005C16 6D74            		BLT	HOUTX
    1877   1919 00005C18 6100 F9F2       		BSR	GETOFC			; Read PDP output Fill cursor
    1878   1920 00005C1C 3238 1090       		MOVE.W	PDPOFC,D1		; PDP cursor == Our cursor?
    1879   1921 00005C20 9278 1092       		SUB.W	PDPOEC,D1
    1880   1922 00005C24 6766            		BEQ	HOUTX			; Yes...ring empty, go to exit
    1881   1923 00005C26 6100 F978       		BSR	RDPDP			; no...read a message
    1882   1924 00005C2A 11F8 10A8 108A  		MOVE.B	DAT1,TYPBYT		; extract TYPE byte
    1883   1925 00005C30 4240            		CLR.W	D0			; extract port-number
    1884   1926 00005C32 1038 10A9       		MOVE.B	DAT2,D0
    1885   1927 00005C36 6100 FE00       		BSR	SETPORT			; set up ports
    1886   1928 00005C3A 6100 0096       		BSR.L	GEHTLN			; compute ISIS message-length needed
    1887   1929 00005C3E 6100 F700       		BSR	ROOM			; enough room in ORING?
    1888   1930 00005C42 6636            		BNE	HOUT2			; no...go do input
    1889   1931 00005C44 1238 108A       		MOVE.B	TYPBYT,D1		; check for messages which require response
    1890   1932 00005C48 6D46            		BLT	TEXTMSG			; TYP > 80 "looks" < 0, is data
    1891   1933 00005C4A 0C01 002E       		CMP.B	#$2E,D1			; Block IO
    1892   1934 00005C4E 671A            		BEQ	HOUT1
    1893   1935 00005C50 0C01 001F       		CMP.B	#$1F,D1			; Probe (query) Terminal Characteristics?
    1894   1936 00005C54 6714            		BEQ	HOUT1
    1895   1937 00005C56 0C01 0022       		CMP.B	#$22,D1			; Sup Clock Request?
    1896   1938 00005C5A 670E            		BEQ	HOUT1
    1897   1939 00005C5C 0C01 0016       		CMP.B	#$16,D1			; Supervisor (Aux Circuit) request?
    1898   1940 00005C60 6708            		BEQ	HOUT1
    1899   1941 00005C62 0C01 0019       		CMP.B	#$19,D1			; Test Pattern Probe?
    1900   1942 00005C66 6600 00B8       		BNE.L	OTFRHST			; none of the above
    1901   1943 00005C6A 6100 FB9A       	HOUT1	BSR	FDRGSZ			; find the PDP's input ring size
    1902   1944 00005C6E 3238 109C       		MOVE.W	INRGSP,D1
    1903   1945 00005C72 0C41 0008       		CMP.W	#8,D1
    1904   1946 00005C76 6C00 00A8       		BGE.L	OTFRHST			; more than 8 bytes available, go DO IT!
    1905   1947                          	
    1906   1948 00005C7A 3038 1092       	HOUT2	MOVE.W	PDPOEC,D0		; Can't process message at this time...
    1907   1949 00005C7E 5340            		SUB.W	#1,D0			; back up our cursor
    1908   1950 00005C80 6C06            		BGE	HOUT3
    1909   1951 00005C82 3038 108E       		MOVE.W	PDPOSZ,D0		; wrapped backward...re-cycle
    1910   1952 00005C86 5340            		SUB.W	#1,D0
    1911   1953 00005C88 31C0 1092       	HOUT3	MOVE.W	D0,PDPOEC
    1912   1954                          	
    1913   1955 00005C8C 6000 0612       	HOUTX	BRA.L	ISISIN			; now try to do ISIS input
    1914   1956                          	
    1915   1957                          	
    1916   1958                          	*	Process Output Data Messages
    1917   1959 00005C90 3638 10A0       	TEXTMSG	MOVE.W	PORTNO,D3		; for this portEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         22-May-88  Page   45
Err Source Ref. Address   value
    line   line

    1918   1960 00005C94 1838 108A       		MOVE.B	TYPBYT,D4
    1919   1961 00005C98 0404 0080       		SUB.B	#$80,D4			; message type is length
    1920   1962 00005C9C 1404            		MOVE.B	D4,D2			; save copy for counter
    1921   1963 00005C9E 6100 F6D8       		BSR	SLOR
    1922   1964 00005CA2 43F8 10AA       		LEA	DAT3,A1			; pointer to first byte to transfer
    1923   1965 00005CA6 1019            	TEXTLOP	MOVE.B	(A1)+,D0		; next byte
    1924   1966 00005CA8 6100 F6EE       		BSR	PUTCH
    1925   1967 00005CAC 5302            		SUB.B	#1,D2			; Done yet?
    1926   1968 00005CAE 6710            		BEQ	TEXTEND			; yes
    1927   1969 00005CB0 B2FC 10AC       		CMPA.W	#DAT5,A1		; have we exhausted this DAT?
    1928   1970 00005CB4 66F0            		BNE	TEXTLOP			; no
    1929   1971 00005CB6 6100 F8E8       		BSR	RDPDP			; yes...get another
    1930   1972 00005CBA 43F8 10A8       		LEA	DAT1,A1			; re-init pointer
    1931   1973 00005CBE 60E6            		BRA	TEXTLOP			; and proceed
    1932   1974                          	
    1933   1975 00005CC0 082C 0000 0001  	TEXTEND	BTST	#PF_ACT,P_FLAGS(Rp)	; Done...is this port active?
    1934   1976 00005CC6 6700 FF3E       		BEQ	HOSTOUT			: not active...forget it
    1935   1977 00005CCA 6100 F72A       		BSR	ELOR			; send block on it's way
    1936   1978 00005CCE 6000 FF36       		BRA	HOSTOUT			; go for next message
    1937   1979                          	
    1938   1980                          	
    1939   1981                          	*	Get length of Message (translate PDP MSG type to ISIS length)
    1940   1982                          	*	Returns:	length in D0, A0 smashed
    1941   1983 00005CD2 4240            	GEHTLN	CLR.W	D0
    1942   1984 00005CD4 1038 108A       		MOVE.B	TYPBYT,D0		; get type byte
    1943   1985 00005CD8 6D06            		BLT	NOCAL			; skip if data message (x80+ "looks" <0 )
    1944   1986 00005CDA 103B 000A       		MOVE.B	TRHSTLN(PC,D0.W),D0	; look up length
    1945   1987 00005CDE 6004            		BRA	NOCAL5
    1946   1988                          	
    1947   1989                          	*	Data message is $80 + length
    1948   1990 00005CE0 0400 007D       	NOCAL	SUB.B	#$80-3,D0		; remove bias, allow for ISIS header
    1949   1991 00005CE4 4E75            	NOCAL5	RTS
    1950   1992                          	
    1951   1993                          	
    1952   1994                          	*	TRANSLATED HOST MSG LENGTH
    1953   1995 00005CE6 00              	TRHSTLN	DC.B	0			; 00
    1954   1996 00005CE7 0C              		DC.B	12			; 01
    1955   1997 00005CE8 0C              		DC.B	12			; 02
    1956   1998 00005CE9 00              		DC.B	0			; 03
    1957   1999 00005CEA 00              		DC.B	0			; 04
    1958   2000 00005CEB 00              		DC.B	0			; 05
    1959   2001 00005CEC 00              		DC.B	0			; 06
    1960   2002 00005CED 00              		DC.B	0			; 07
    1961   2003 00005CEE 03              		DC.B	3			; 08
    1962   2004 00005CEF 03              		DC.B	3			; 09
    1963   2005 00005CF0 03              		DC.B	3			; 0A
    1964   2006 00005CF1 03              		DC.B	3			; 0B
    1965   2007 00005CF2 03              		DC.B	3			; 0C
    1966   2008 00005CF3 03              		DC.B	3			; 0D
    1967   2009 00005CF4 03              		DC.B	3			; 0E
    1968   2010 00005CF5 03              		DC.B	3			; 0FEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         22-May-88  Page   46
Err Source Ref. Address   value
    line   line

    1969   2011 00005CF6 03              		DC.B	3			; 10
    1970   2012 00005CF7 03              		DC.B	3			; 11
    1971   2013 00005CF8 03              		DC.B	3			; 12
    1972   2014 00005CF9 03              		DC.B	3			; 13
    1973   2015 00005CFA 03              		DC.B	3			; 14
    1974   2016 00005CFB 00              		DC.B	0			; 15
    1975   2017 00005CFC 04              		DC.B	4			; 16 ****
    1976   2018 00005CFD 00              		DC.B	0			; 17
    1977   2019 00005CFE 34              		DC.B	52			; 18
    1978   2020 00005CFF 06              		DC.B	6			; 19 ****
    1979   2021 00005D00 00              		DC.B	0			; 1A
    1980   2022 00005D01 00              		DC.B	0			; 1B
    1981   2023 00005D02 05              		DC.B	5			; 1C
    1982   2024 00005D03 05              		DC.B	5			; 1D
    1983   2025 00005D04 05              		DC.B	5			; 1E
    1984   2026 00005D05 64              		DC.B	100			; 1F ****
    1985   2027 00005D06 00              		DC.B	0			; 20
    1986   2028 00005D07 0C              		DC.B	12			; 21
    1987   2029 00005D08 00              		DC.B	0			; 22 ****
    1988   2030 00005D09 00              		DC.B	0			; 23
    1989   2031 00005D0A 00              		DC.B	0			; 24
    1990   2032 00005D0B 00              		DC.B	0			; 25
    1991   2033 00005D0C 00              		DC.B	0			; 26
    1992   2034 00005D0D 00              		DC.B	0			; 27
    1993   2035 00005D0E 00              		DC.B	0			; 28
    1994   2036 00005D0F 00              		DC.B	0			; 29
    1995   2037 00005D10 00              		DC.B	0			; 2A
    1996   2038 00005D11 00              		DC.B	0			; 2B
    1997   2039 00005D12 00              		DC.B	0			; 2C
    1998   2040 00005D13 00              		DC.B	0			; 2D
    1999   2041 00005D14 00              		DC.B	0			; 2E
    2000   2042 00005D15 00              		DC.B	0			; 2F
    2001   2043 00005D16 00              		DC.B	0			; 30
    2002   2044 00005D17 03              		DC.B	3			; 31
    2003   2045 00005D18 03              		DC.B	3			; 32
    2004   2046 00005D19 00              		DC.B	0			; 33
    2005   2047 00005D1A 00              		DC.B	0			; 34
    2006   2048 00005D1B 00              		DC.B	0			; 35
    2007   2049 00005D1C 00              		DC.B	0			; 36
    2008   2050 00005D1D 00              		DC.B	0			; 37
    2009   2051 00005D1E 00              		DC.B	0			; 38EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         22-May-88  Page   47
Err Source Ref. Address   value
    line   line

    2011   2053                          	*		PROCESS INDIVIDUAL HOST MESSAGES
    2012   2054                          	
    2013   2055                          	*	PROCESS MESSAGE IN RECORD
    2014   2056 00005D20 4242            	OTFRHST	CLR.W	D2
    2015   2057 00005D22 1438 108A       		MOVE.B	TYPBYT,D2		; message-type
    2016   2058 00005D26 0C42 0033       		CMP.W	#$33,D2			; range-check
    2017   2059 00005D2A 6E00 FC76       		BGT	MERROR			; invalid message
    2018   2060 00005D2E D442            		ADD.W	D2,D2			; *2 to get offset
    2019   2061 00005D30 327B 2004       		MOVE.W	OMTAB(PC,D2.W),A1	; get target address
    2020   2062 00005D34 4ED1            		JMP	(A1)			; go there
    2021   2063                          	
    2022   2064                          	
    2023   2065                          	*	HOST OUTPUT MESSAGE DISPATCH TABLE
    2024   2066                          	*	(	"<" -	Legal from host
    2025   2067                          	*		">" -	Legal to host	)
    2026   2068 00005D36 59A2            	OMTAB	DC.W	MERROR			;    00 - Illegal
    2027   2069 00005D38 5D9E            		DC.W	OPEN			; <  01 - Host Open
    2028   2070 00005D3A 5DA2            		DC.W	SHUT			; <  02 - Host Shut
    2029   2071 00005D3C 5DE0            		DC.W	RESET			; <> 03 - Reset Interface
    2030   2072 00005D3E 5E02            		DC.W	RESETAK			; <> 04 - reset-Ack
    2031   2073 00005D40 59A2            		DC.W	MERROR			;  > 05 - Takeover/Sup-lost
    2032   2074 00005D42 59A2            		DC.W	MERROR			;  > 06 - Externally-init circuit
    2033   2075 00005D44 59A2            		DC.W	MERROR			;  > 07 - Internally-init circuit
    2034   2076 00005D46 5E0C            		DC.W	ONBP			; <> 08 - Backpressure On
    2035   2077 00005D48 5E22            		DC.W	OFFBP			; <> 09 - Backpressure Off
    2036   2078 00005D4A 5E5A            		DC.W	SPEC			; <> 0A - GOBBLER
    2037   2079 00005D4C 5E40            		DC.W	ZAP			; <> 0B - ZAPPER
    2038   2080 00005D4E 5E5A            		DC.W	SPEC			; <> OC - Enter DEM
    2039   2081 00005D50 5E5A            		DC.W	SPEC			; <> 0D - Leave DEM
    2040   2082 00005D52 5E5A            		DC.W	SPEC			; <> 0E - Green-ball
    2041   2083 00005D54 5E5A            		DC.W	SPEC			; <> 0F - Red-ball
    2042   2084 00005D56 5E5A            		DC.W	SPEC			; <> 10 - Yellow-ball
    2043   2085 00005D58 5E5A            		DC.W	SPEC			; <> 11 - Orange-ball
    2044   2086 00005D5A 5E5A            		DC.W	SPEC			; <  12 - Hang-up, forward out only
    2045   2087 00005D5C 5E5A            		DC.W	SPEC			; <> 13 - Enter Transparency
    2046   2088 00005D5E 5E5A            		DC.W	SPEC			; <> 14 - Leave Transparency
    2047   2089 00005D60 59A2            		DC.W	MERROR			;  > 15 - Black/Gray-Ball
    2048   2090 00005D62 5EB4            		DC.W	SUPREC			; <  16 - SUP (AUX-circuit) Request
    2049   2091 00005D64 59A2            		DC.W	MERROR			;  > 17 - response to 16
    2050   2092 00005D66 5F0E            		DC.W	SUPLOG			; <  18 - SUP Login Char
    2051   2093 00005D68 5F92            		DC.W	TP			; <  19 - Test-pattern Probe
    2052   2094 00005D6A 59A2            		DC.W	MERROR			;  > 1A - Test-pattern Response
    2053   2095 00005D6C 5FB0            		DC.W	HSTSAD			; <  1B - Host-sad
    2054   2096 00005D6E 5FE8            		DC.W	ECHOON			; <  1C - Echo On
    2055   2097 00005D70 5FF0            		DC.W	ECHOFF			; <  1D - Echo Off
    2056   2098 00005D72 5FF6            		DC.W	STERM			; <  1E - Set Terminal Characteristic
    2057   2099 00005D74 6062            		DC.W	PTERM			; <  1F - Probe Terminal Characteristic
    2058   2100 00005D76 59A2            		DC.W	MERROR			;  > 20 - Response to Terminal Char.
    2059   2101 00005D78 60E4            		DC.W	SHNUM			; <  21 - Set Host Number (& # ports)
    2060   2102 00005D7A 6134            		DC.W	SCLKR			; <  22 - SUP Clock Request (ignored)EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         22-May-88  Page   48
Err Source Ref. Address   value
    line   line

    2061   2103 00005D7C 59A2            		DC.W	MERROR			;  > 23 - Sup Clock Data
    2062   2104 00005D7E 6138            		DC.W	BOK1			; <  24 - Block-output request
    2063   2105 00005D80 59A2            		DC.W	MERROR			;  > 25 - Block-output done
    2064   2106 00005D82 61C0            		DC.W	BOK2			; <  26 - Block-Input Request
    2065   2107 00005D84 59A2            		DC.W	MERROR			;  > 27 - Bin Done -- Block full
    2066   2108 00005D86 59A2            		DC.W	MERROR			;  > 28 - Bin done --EOT
    2067   2109 00005D88 59A2            		DC.W	MERROR			;  > 29 - Bin Timeout
    2068   2110 00005D8A 6236            		DC.W	BOK4			; <  2A - Terminate Block-input
    2069   2111 00005D8C 59A2            		DC.W	MERROR			;  > 2B - Response to 2A
    2070   2112 00005D8E 6216            		DC.W	BOK3			; <  2C - Terminate Block-output
    2071   2113 00005D90 59A2            		DC.W	MERROR			;  > 2D - Response to 2C
    2072   2114 00005D92 6276            		DC.W	BOK5			; <> 2E - Request/Response Block-IO ports
    2073   2115 00005D94 59A2            		DC.W	MERROR			;  > 2F - Break-begin
    2074   2116 00005D96 59A2            		DC.W	MERROR			;    30 - Illegal
    2075   2117 00005D98 5E5A            		DC.W	SPEC			; <> 31 - Enter Alt. Dev. mode
    2076   2118 00005D9A 5E5A            		DC.W	SPEC			; <> 32 - Leave Alt. Dev. mode
    2077   2119 00005D9C 6282            		DC.W	SNTO			; <  33 - Set new timeout
    2078   2120                          	
    2079   2121                          	
    2080   2122                          	
    2081   2123                          	
    2082   2124                          	
    2083   2125                          	*	OMSG 01 - Host Answered/open
    2084   2126 00005D9E 4280            	OPEN	CLR.L	D0			; set OPEN status
    2085   2127 00005DA0 6002            		BRA	OPSHT
    2086   2128                          	
    2087   2129                          	
    2088   2130                          	*	OMSG 02 - Host shut
    2089   2131 00005DA2 7002            	SHUT	MOVE.L	#2,D0			; set SHUT status
    2090   2132 00005DA4 1238 104E       	OPSHT	MOVE.B	HSTAT,D1
    2091   2133 00005DA8 5301            		SUB.B	#1,D1
    2092   2134 00005DAA 661E            		BNE	HST2
    2093   2135 00005DAC 4278 1058       		CLR.W	NPORTS
    2094   2136 00005DB0 6124            	TIMCHK	BSR	TSLOWC
    2095   2137 00005DB2 2238 10E0       		MOVE.L	SLOWC,D1
    2096   2138                          	*	DON'T FLOOD SUP WITH OPEN/SHUT MSGS
    2097   2139 00005DB6 92B8 10E4       		SUB.L	HTM,D1
    2098   2140 00005DBA 6D06            		BLT	HST1
    2099   2141 00005DBC 5181            		SUB.L	#8,D1
    2100   2142 00005DBE 6E02            		BGT	HST1
    2101   2143 00005DC0 60EE            		BRA	TIMCHK
    2102   2144                          	
    2103   2145 00005DC2 6112            	HST1	BSR	TSLOWC
    2104   2146 00005DC4 21F8 10E0 10E4  		MOVE.L	SLOWC,HTM
    2105   2147 00005DCA 11C0 104E       	HST2	MOVE.B	D0,HSTAT		; set new status
    2106   2148 00005DCE 6100 FCB8       		BSR	HREPRT			; report new host status to SUP
    2107   2149 00005DD2 6000 FE32       		BRA	HOSTOUT
    2108   2150                          	
    2109   2151                          	*	ROUTINE TO GET TIME FROM SLOWC
    2110   2152 00005DD6 2078 1036       	TSLOWC	MOVE.L	.SLOWC,A0
    2111   2153 00005DDA 21D0 10E0       		MOVE.L	(A0),SLOWCEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         22-May-88  Page   49
Err Source Ref. Address   value
    line   line

    2112   2154 00005DDE 4E75            		RTS
    2113   2155                          	
    2114   2156                          	
    2115   2157                          	*	OMSG 03 - RESET INTERFACE
    2116   2158 00005DE0 31F8 10AA 1054  	RESET	MOVE.W	DAT3,HVERNO		; record host version number
    2117   2159 00005DE6 6100 FCE2       		BSR	EMPTY			; empty ISIS input-ring
    2118   2160 00005DEA 6100 FC02       		BSR	HODOWN			; set host down
    2119   2161 00005DEE 31FC 0400 10A8  		MOVE.W	#$400+DEBUG,DAT1	; set "RESET ACK"
    2120   2162 00005DF4 31FC 0202 10AA  		MOVE.W	#VERSION,DAT3
    2121   2163 00005DFA 6100 F9A2       		BSR.L	WAITDAT			; and send it
    2122   2164 00005DFE 6000 FE06       		BRA	HOSTOUT
    2123   2165                          	
    2124   2166                          	*	OMSG04 - RESET ACKNOWLEDGEMENT
    2125   2167 00005E02 31F8 10AA 1054  	RESETAK	MOVE.W	DAT3,HVERNO		; just record host version number
    2126   2168 00005E08 6000 FDFC       		BRA	HOSTOUT
    2127   2169                          	
    2128   2170                          	
    2129   2171                          	*	OMSG 08 - Apply Backpressure
    2130   2172 00005E0C 08EC 0004 0001  	ONBP	BSET	#PF_HBP,P_FLAGS(Rp)	; set host-applied Backpressure
    2131   2173 00005E12 6600 FDF2       		BNE	HOSTOUT			; ...already has
    2132   2174 00005E16 08EC 0003 0001  		BSET	#PF_IBP,P_FLAGS(Rp)	; set we've-applied Backpressure
    2133   2175 00005E1C 6600 FDE8       		BNE	HOSTOUT			; ...already did
    2134   2176 00005E20 6038            		BRA	SPEC			; SPEC does the hard work
    2135   2177                          	
    2136   2178                          	
    2137   2179                          	*	OMSG 09 - Release Backpressure
    2138   2180 00005E22 08AC 0004 0001  	OFFBP	BCLR	#PF_HBP,P_FLAGS(Rp)	; Clear host-applied Backpressure
    2139   2181 00005E28 6700 FDDC       		BEQ	HOSTOUT			; ...already did
    2140   2182 00005E2C 4A6C 001E       		TST.W	BCT(Rp)			; anything in buffer?
    2141   2183 00005E30 6600 FDD4       		BNE	HOSTOUT			; yes...we'll do it when buffer flushed
    2142   2184 00005E34 08AC 0003 0001  		BCLR	#PF_IBP,P_FLAGS(Rp)	; Clear our-applied Backpressure
    2143   2185 00005E3A 6700 FDCA       		BEQ	HOSTOUT			; ...already did
    2144   2186 00005E3E 601A            		BRA	SPEC			; SPEC does the hard work
    2145   2187                          	
    2146   2188                          	
    2147   2189                          	*	OMSG 0B - ZAPPER
    2148   2190 00005E40 4A78 10A0       	ZAP	TST.W	PORTNO			; Check port #
    2149   2191 00005E44 6700 FDC0       		BEQ	HOSTOUT			; ignor if port 0
    2150   2192 00005E48 082C 0000 0001  		BTST	#PF_ACT,P_FLAGS(Rp)	; test if port is active
    2151   2193 00005E4E 6714            		BEQ	SPEC1			; no
    2152   2194 00005E50 6100 FD24       		BSR	DPORT			; yes...reduce port-count
    2153   2195 00005E54 6100 FBF2       		BSR	RBTALL			; reset everything for port
    2154   2196 00005E58 600A            		BRA	SPEC1
    2155   2197                          	
    2156   2198                          	
    2157   2199                          	*	OMSGS 08-14,31-32 - VARIOUS ONE-BYTE MESSAGES
    2158   2200 00005E5A 082C 0000 0001  	SPEC	BTST	#PF_ACT,P_FLAGS(Rp)	; test if port is active
    2159   2201 00005E60 6700 FDA4       		BEQ	HOSTOUT			; ignor if not
    2160   2202                          	
    2161   2203 00005E64 4244            	SPEC1	CLR.W	D4
    2162   2204 00005E66 1838 108A       		MOVE.B	TYPBYT,D4		; message-typeEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         22-May-88  Page   50
Err Source Ref. Address   value
    line   line

    2163   2205 00005E6A 183B 400E       		MOVE.B	SPTAB(PC,D4.W),D4	; get ISIS message-type
    2164   2206 00005E6E 3638 10A0       		MOVE.W	PORTNO,D3		; for port
    2165   2207 00005E72 6100 F57C       		BSR	SENDQI			; send Quick ISIS message
    2166   2208 00005E76 6000 FD8E       		BRA	HOSTOUT
    2167   2209                          	
    2168   2210                          	
    2169   2211                          	
    2170   2212                          	*	CONVERSION TABLE FOR HOST MSGS TO ISIS MSGS
    2171   2213 00005E7A 0000 0000       	SPTAB	DC.B	0,0,0,0,0,0,0,0,$0A0,$0A1
    2171   2214 00005E7E 0000 0000       	
    2171   2215 00005E82 A0A1            	
    2172   2216 00005E84 A29F A6A7       		DC.B	$0A2,$9F,$0A6,$0A7,$0AA,$0AB,$0AC,$0AD,$0AF,$0A8
    2172   2217 00005E88 AAAB ACAD       	
    2172   2218 00005E8C AFA8            	
    2173   2219 00005E8E A900 0000       		DC.B	$0A9,0,0,0,0,0,0,0,0,0
    2173   2220 00005E92 0000 0000       	
    2173   2221 00005E96 0000            	
    2174   2222 00005E98 0000 0000       		DC.B	0,0,0,0,0,0,0,0,0,0
    2174   2223 00005E9C 0000 0000       	
    2174   2224 00005EA0 0000            	
    2175   2225 00005EA2 0000 0000       		DC.B	0,0,0,0,0,0,0,0,0,$0BC
    2175   2226 00005EA6 0000 0000       	
    2175   2227 00005EAA 00BC            	
    2176   2228 00005EAC BD00 0000       		DC.B	$0BD,0,0,0,0,0,0,0
    2176   2229 00005EB0 0000 0000       	
    2177   2230                          	
    2178   2231                          	
    2179   2232                          	
    2180   2233                          	*	OMSG 16 - SUPERVISOR REQUEST (for AUX circuit)
    2181   2234 00005EB4 4A78 1060       	SUPREC	TST.W	AUXX			; index into username array
    2182   2235 00005EB8 6D1C            		BLT	SUPR1			; No AUX circuit in progress
    2183   2236 00005EBA 6100 FF1A       		BSR	TSLOWC
    2184   2237 00005EBE 2038 10E0       		MOVE.L	SLOWC,D0		; low long since last try?
    2185   2238 00005EC2 90B8 105C       		SUB.L	AUXTIM,D0
    2186   2239 00005EC6 0240 FFE0       		ANDI.W	#-32,D0
    2187   2240 00005ECA 660A            		BNE	SUPR1
    2188   2241 00005ECC 363C 0900       		MOVE.W	#$0900,D3		; last request still in progress
    2189   2242 00005ED0 6126            		BSR	SEND17
    2190   2243 00005ED2 6000 FD32       		BRA	HOSTOUT
    2191   2244                          	
    2192   2245 00005ED6 4278 1060       	SUPR1	CLR.W	AUXX			; give enable request
    2193   2246 00005EDA 31F8 10A0 105A  		MOVE.W	PORTNO,AUXQ		; ...for this port
    2194   2247 00005EE0 4243            		CLR.W	D3			; response = 0
    2195   2248 00005EE2 6114            		BSR	SEND17
    2196   2249 00005EE4 6100 FEF0       		BSR	TSLOWC
    2197   2250 00005EE8 2038 10E0       		MOVE.L	SLOWC,D0
    2198   2251 00005EEC 21C0 105C       		MOVE.L	D0,AUXTIM
    2199   2252 00005EF0 6100 F8E6       		BSR	PUTIFC
    2200   2253 00005EF4 6000 FD10       		BRA	HOSTOUT
    2201   2254                          	
    2202   2255                          	EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         22-May-88  Page   51
Err Source Ref. Address   value
    line   line

    2203   2256 00005EF8 11FC 0017 10A8  	SEND17	MOVE.B	#$17,DAT1		; send SUP response
    2204   2257 00005EFE 11F8 10A1 10A9  		MOVE.B	PORTNO+1,DAT2
    2205   2258 00005F04 31C3 10AA       		MOVE.W	D3,DAT3
    2206   2259 00005F08 6100 F894       		BSR	WAITDAT			; wait, then write DAT into host
    2207   2260 00005F0C 4E75            		RTS
    2208   2261                          	
    2209   2262                          	*	OMSG 18 - SUPERVISOR LOGIN CHAR
    2210   2263 00005F0E 3038 10A0       	SUPLOG	MOVE.W	PORTNO,D0		; port number
    2211   2264 00005F12 B078 105A       		CMP.W	AUXQ,D0			; request for valid port?
    2212   2265 00005F16 6600 FCEE       		BNE	HOSTOUT			; no...ignor
    2213   2266 00005F1A 41F8 1062       		LEA	AUXC,A0			; yes...set start-address of user-string
    2214   2267 00005F1E 3038 1060       		MOVE.W	AUXX,D0			; get index for next char
    2215   2268 00005F22 D0C0            		ADD.W	D0,A0
    2216   2269 00005F24 1238 10AA       		MOVE.B	DAT3,D1
    2217   2270 00005F28 0001 0080       		OR.B	#$80,D1			; set high-order bit
    2218   2271 00005F2C 1081            		MOVE.B	D1,(A0)			; save the character
    2219   2272 00005F2E 5240            		ADD.W	#1,D0			; advance index
    2220   2273 00005F30 0240 003F       		AND.W	#$3F,D0			; wrap it if too long
    2221   2274 00005F34 31C0 1060       		MOVE.W	D0,AUXX			; save copy
    2222   2275 00005F38 0C01 00BB       		CMPI.B	#$BB,D1			; SEMICOLON?
    2223   2276 00005F3C 6708            		BEQ	SUPOUT
    2224   2277 00005F3E 0C01 008D       		CMPI.B	#$8D,D1			; CARRIAGE RETURN?
    2225   2278 00005F42 6600 FCC2       		BNE	HOSTOUT			; no...not done yet
    2226   2279 00005F46 0640 000B       	SUPOUT	ADD.W	#$0B,D0			; done...pass to Sup
    2227   2280 00005F4A 6100 F41A       		BSR	WAITIS			; wait for space to send message
    2228   2281 00005F4E 4243            		CLR.W	D3			; to Port 0
    2229   2282 00005F50 7808            		MOVEQ	#8,D4			; Request AUX Circuit
    2230   2283 00005F52 6100 F424       		BSR	SLOR
    2231   2284 00005F56 4200            		CLR.B	D0			; padding (B)
    2232   2285 00005F58 6100 F43E       		BSR	PUTCH
    2233   2286 00005F5C 3038 10A0       		MOVE.W	PORTNO,D0		; Local Key = portnumber (HW)
    2234   2287 00005F60 6100 F466       		BSR	PUTH
    2235   2288 00005F64 4240            		CLR.W	D0			; No IIX (HW)
    2236   2289 00005F66 6100 F460       		BSR	PUTH
    2237   2290 00005F6A 3038 104A       		MOVE.W	HOSTN,D0		; Orig. Host (HW)
    2238   2291 00005F6E 6100 F458       		BSR	PUTH
    2239   2292 00005F72 3438 1060       		MOVE.W	AUXX,D2			; size of name
    2240   2293 00005F76 1002            		MOVE.B	D2,D0			; size (B)
    2241   2294 00005F78 6100 F41E       		BSR	PUTCH
    2242   2295 00005F7C 43F8 1062       		LEA	AUXC,A1			; address of first byte
    2243   2296 00005F80 1019            	SUPLOP	MOVE.B	(A1)+,D0		; next byte of string
    2244   2297 00005F82 6100 F414       		BSR	PUTCH
    2245   2298 00005F86 5342            		SUB.W	#1,D2
    2246   2299 00005F88 6EF6            		BGT	SUPLOP
    2247   2300 00005F8A 6100 F46A       		BSR	ELOR			; end request
    2248   2301 00005F8E 6000 FC76       		BRA	HOSTOUT
    2249   2302                          	
    2250   2303                          	
    2251   2304                          	*	OMSG 19 - TEST PATTERN PROBE
    2252   2305 00005F92 11FC 001A 10A8  	TP	MOVE.B	#$1A,DAT1		; Test-pattern Response
    2253   2306 00005F98 4238 10A9       		CLR.B	DAT2EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         22-May-88  Page   52
Err Source Ref. Address   value
    line   line

    2254   2307 00005F9C 6100 F802       		BSR	WRDAT			; write DAT into host
    2255   2308 00005FA0 6100 F5FE       		BSR	RDPDP
    2256   2309 00005FA4 6100 F7FE       		BSR	WRPDP			; copy next word too
    2257   2310 00005FA8 6100 F82E       		BSR	PUTIFC			; mark it as done
    2258   2311 00005FAC 6000 FC58       		BRA	HOSTOUT
    2259   2312                          	
    2260   2313                          	
    2261   2314                          	*	OMSGS 1B - HOST SAD
    2262   2315 00005FB0 6100 F5EE       	HSTSAD	BSR	RDPDP			; get next word
    2263   2316 00005FB4 4841            		SWAP	D1			; d3/d4 to low half
    2264   2317 00005FB6 700A            		MOVEQ	#10,D0			; need 10d bytes of space
    2265   2318 00005FB8 6100 F3AC       		BSR	WAITIS			; wait for room in ring
    2266   2319 00005FBC 4243            		CLR.W	D3			; Port 0 --
    2267   2320 00005FBE 7803            		MOVEQ	#3,D4			; Type 3 (diagnostic)
    2268   2321 00005FC0 6100 F3B6       		BSR	SLOR
    2269   2322 00005FC4 4200            		CLR.B	D0			; Padding
    2270   2323 00005FC6 6100 F3D0       		BSR	PUTCH
    2271   2324 00005FCA 3001            		MOVE.W	D1,D0			; data2 (HW)
    2272   2325 00005FCC 6100 F3FA       		BSR	PUTH
    2273   2326 00005FD0 303C 1000       		MOVE.W	#$1000,D0		; Rtype 10 | 0 (B | B)
    2274   2327 00005FD4 6100 F3F2       		BSR	PUTH
    2275   2328 00005FD8 103C 0091       		MOVE.B	#PRODID,D0		; ProductID
    2276   2329 00005FDC 6100 F3BA       		BSR	PUTCH
    2277   2330 00005FE0 6100 F414       		BSR	ELOR			; send it on
    2278   2331 00005FE4 6000 FC20       		BRA	HOSTOUT
    2279   2332                          	
    2280   2333                          	
    2281   2334                          	*	OMSGS 1C & 1D - ECHO ON/OFF
    2282   2335 00005FE8 31FC 0001 10AA  	ECHOON	MOVE.W	#1,DAT3			; subtype = 0, value = 1
    2283   2336 00005FEE 600E            		BRA	STERM1
    2284   2337                          	
    2285   2338 00005FF0 4278 10AA       	ECHOFF	CLR.W	DAT3			; subtype=0, value = 0
    2286   2339 00005FF4 6008            		BRA	STERM1
    2287   2340                          	
    2288   2341                          	
    2289   2342                          	*	OMSG 1E - SET TERMINAL CHARACTERISTICS
    2290   2343 00005FF6 4A38 10AA       	STERM	TST.B	DAT3			; check message subtype
    2291   2344 00005FFA 6D00 F9A6       		BLT	MERROR			; range check
    2292   2345                          	
    2293   2346 00005FFE 082C 0000 0001  	STERM1	BTST	#PF_ACT,P_FLAGS(Rp)	; test if port is active
    2294   2347 00006004 6700 FC00       		BEQ	HOSTOUT			; ignor request for inactive ports
    2295   2348 00006008 0C38 0014 10AB  		CMP.B	#$14,DAT4
    2296   2349 0000600E 6E00 F992       		BGT	MERROR			; range check
    2297   2350 00006012 7008            		MOVEQ	#8,D0
    2298   2351 00006014 6100 F350       		BSR	WAITIS			; wait for space in ring
    2299   2352 00006018 0C38 0005 10AA  		CMP.B	#5,DAT3			; special handling for input baud rate
    2300   2353 0000601E 660A            		BNE	STERM2			; skip if not
    2301   2354 00006020 1978 10AB 0003  		MOVE.B	DAT4,IBRATE(Rp)		; save new input baud-rate
    2302   2355 00006026 6100 009E       		BSR.L	PTMSN1			; turn around and Acknowledge it
    2303   2356 0000602A 3638 10A0       	STERM2	MOVE.W	PORTNO,D3		; port #
    2304   2357 0000602E 183C 00B1       		MOVE.B	#$B1,D4			; Type-byteEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         22-May-88  Page   53
Err Source Ref. Address   value
    line   line

    2305   2358 00006032 6100 F344       		BSR	SLOR
    2306   2359 00006036 1038 10AA       		MOVE.B	DAT3,D0			; sub-type
    2307   2360                          	*	CMP.B	#$0F,D0			; *hack* remove this test when	<2.2
    2308   2361                          	*	BNE	NOJAP1			; the PDP-10 code is fixed.	<2.2
    2309   2362                          	*	ADD.B	#1,D0			; translate subtype 15d to 16d  <2.2
    2310   2363 0000603A 6100 F35C       	NOJAP1	BSR	PUTCH
    2311   2364 0000603E 1038 10AB       		MOVE.B	DAT4,D0			; value
    2312   2365 00006042 6712            		BEQ	STERM3			; 0 is OK
    2313   2366 00006044 223C 000F 719F  		MOVE.L	#$000F719F,D1		; check for single-bit use
    2314   2367 0000604A 1438 10AA       		MOVE.B	DAT3,D2			; subtype
    2315   2368 0000604E 0501            		BTST	D2,D1
    2316   2369 00006050 6704            		BEQ	STERM3			; multi-bit..use value
    2317   2370 00006052 103C 00FF       		MOVE.B	#-1,D0			; set whole byte to 1's
    2318   2371 00006056 6100 F340       	STERM3	BSR	PUTCH
    2319   2372 0000605A 6100 F39A       		BSR	ELOR
    2320   2373 0000605E 6000 FBA6       		BRA	HOSTOUT
    2321   2374                          	
    2322   2375                          	
    2323   2376                          	
    2324   2377                          	
    2325   2378                          	*	OMSG 1F - PROBE TERMINAL CHARACTERISTICS
    2326   2379 00006062 082C 0000 0001  	PTERM	BTST	#PF_ACT,P_FLAGS(Rp)	; test if port is active
    2327   2380 00006068 6700 FB9C       		BEQ	HOSTOUT			; ignor for inactive ports
    2328   2381 0000606C 1438 10AA       		MOVE.B	DAT3,D2			; get request sub-type
    2329   2382 00006070 6D00 FB94       		BLT	HOSTOUT			; range-check
    2330   2383 00006074 0C02 003F       		CMP.B	#63,D2			; special "probe all"?
    2331   2384 00006078 6712            		BEQ	PTALL			; skip if so
    2332   2385 0000607A 0C02 0014       		CMP.B	#$14,D2			; range-check
    2333   2386 0000607E 6E00 FB86       		BGT	HOSTOUT			; ignore out of range requests
    2334   2387 00006082 6118            		BSR	PTMSND			; else send request
    2335   2388 00006084 6100 F752       		BSR	PUTIFC			; clean up
    2336   2389 00006088 6000 FB7C       		BRA	HOSTOUT
    2337   2390                          	
    2338   2391                          	*	Special case for "probe all"
    2339   2392 0000608C 7414            	PTALL	MOVEQ	#$14,D2			; set counter
    2340   2393 0000608E 610C            	PTAL2	BSR	PTMSND			; send another request
    2341   2394 00006090 5302            		SUB.B	#1,D2
    2342   2395 00006092 6CFA            		BGE	PTAL2			; ...until done
    2343   2396 00006094 6100 F742       		BSR	PUTIFC			; clean up
    2344   2397 00006098 6000 FB6C       		BRA	HOSTOUT
    2345   2398                          	
    2346   2399                          	*	Process one request
    2347   2400                          	*	D2 = sub-type
    2348   2401 0000609C 0C02 0005       	PTMSND	CMP.B	#5,D2			; subtype 5?
    2349   2402 000060A0 6724            		BEQ	PTMSN1			; fake out input baud rate request
    2350   2403 000060A2 6100 F2BA       		BSR	WAITISW			; insure space in ring
    2351   2404 000060A6 3638 10A0       		MOVE.W	PORTNO,D3		; port number
    2352   2405 000060AA 183C 00B0       		MOVE.B	#$B0,D4			; type = query parameter
    2353   2406 000060AE 6100 F2C8       		BSR	SLOR
    2354   2407 000060B2 1002            		MOVE.B	D2,D0
    2355   2408 000060B4 0C00 000F       		CMP.B	#$0F,D0EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         22-May-88  Page   54
Err Source Ref. Address   value
    line   line

    2356   2409 000060B8 6602            		BNE	NOJAP2
    2357   2410 000060BA 5200            		ADD.B	#1,D0			; type 15d translated to type 16d
    2358   2411 000060BC 6100 F2DA       	NOJAP2	BSR	PUTCH			; subtype
    2359   2412 000060C0 6100 F334       		BSR	ELOR
    2360   2413 000060C4 4E75            		RTS
    2361   2414                          	
    2362   2415                          	*	Report input baud rate
    2363   2416 000060C6 11FC 0020 10A8  	PTMSN1	MOVE.B	#$20,DAT1
    2364   2417 000060CC 11F8 10A1 10A9  		MOVE.B	PORTNO+1,DAT2
    2365   2418 000060D2 11FC 0005 10AA  		MOVE.B	#5,DAT3			; sub-type = input baud rate
    2366   2419 000060D8 11EC 0003 10AB  		MOVE.B	IBRATE(Rp),DAT4		; rate
    2367   2420 000060DE 6100 F6C0       		BSR	WRDAT			; send DAT to host
    2368   2421 000060E2 4E75            		RTS
    2369   2422                          	
    2370   2423                          	
    2371   2424                          	
    2372   2425                          	*	OMSG 21 - SET HOST NUMBER
    2373   2426 000060E4 7801            	SHNUM	MOVEQ	#1,D4			; assume host going down
    2374   2427 000060E6 4281            		CLR.L	D1
    2375   2428 000060E8 1238 10AA       		MOVE.B	DAT3,D1
    2376   2429 000060EC B278 104A       		CMP.W	HOSTN,D1		; is host number being changed?
    2377   2430 000060F0 660A            		BNE	SHNUM1			; Skip if so
    2378   2431 000060F2 3438 10A0       		MOVE.W	PORTNO,D2		; port number = number of ports
    2379   2432 000060F6 B478 104C       		CMP.W	HOSTP,D2		; did it change?
    2380   2433 000060FA 6702            		BEQ	SHNUM2			; skip if not
    2381   2434                          	
    2382   2435 000060FC 7803            	SHNUM1	MOVEQ	#3,D4			; host or number of ports changed
    2383   2436                          	*					 ...Tell SUP Host is Gone
    2384   2437 000060FE 6100 F8F4       	SHNUM2	BSR	HDOWN			; make host change
    2385   2438 00006102 4282            		CLR.L	D2
    2386   2439 00006104 1438 10AA       		MOVE.B	DAT3,D2
    2387   2440 00006108 31C2 104A       		MOVE.W	D2,HOSTN		; update host number
    2388   2441 0000610C 1438 10A9       		MOVE.B	DAT2,D2			; port number = number of ports
    2389   2442 00006110 6706            		BEQ	SHNUM3			; 0 defaults to MAX
    2390   2443 00006112 0C42 00FE       		CMP.W	#MAXPORT-2,D2
    2391   2444 00006116 6F04            		BLE	SHNUM4
    2392   2445 00006118 343C 00FE       	SHNUM3	MOVE.W	#MAXPORT-2,D2		; we do not use port 0 or $FF
    2393   2446 0000611C 31C2 104C       	SHNUM4	MOVE.W	D2,HOSTP		; number of host ports
    2394   2447 00006120 5742            		SUB.W	#3,D2
    2395   2448 00006122 31C2 1056       		MOVE.W	D2,MXPORT		; maximum port number
    2396   2449 00006126 11FC 0002 104E  		MOVE.B	#2,HSTAT		; set host shut
    2397   2450 0000612C 6100 F95A       		BSR	HREPRT			; and report it
    2398   2451 00006130 6000 FAD4       		BRA	HOSTOUT
    2399   2452                          	
    2400   2453                          	
    2401   2454                          	*	OMSG 22 - SUP CLOCK REQUEST
    2402   2455 00006134 6000 FAD0       	SCLKR	BRA	HOSTOUT			; ignor for now
    2403   2456                          	
    2404   2457                          	
    2405   2458                          	
    2406   2459                          	*	OMSGS 24,26,2A,2C,2E (BLOCK I/O)EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         22-May-88  Page   55
Err Source Ref. Address   value
    line   line

    2407   2460                          	
    2408   2461                          	*	---24---	REQ FOR BLOCK OUTPUT
    2409   2462                          	*	Block output is simple...each Bout request is independent.
    2410   2463                          	*	We transmit the block of data, and report it's transmission,
    2411   2464                          	*	thereby ending that request.
    2412   2465 00006138 31F8 10AA 1104  	BOK1	MOVE.W	DAT3,SAVE1		; save TCN value
    2413   2466 0000613E 6100 F460       		BSR	RDPDP			; get address
    2414   2467 00006142 E089            		LSR.L	#8,D1
    2415   2468 00006144 082C 0000 0001  		BTST	#PF_ACT,P_FLAGS(Rp)	; test if port is active
    2416   2469 0000614A 6700 FABA       		BEQ	HOSTOUT			; no...ignore request
    2417   2470 0000614E 08EC 0005 0001  		BSET	#PF_BKO,P_FLAGS(Rp)	; set and test block output in progress
    2418   2471 00006154 6600 FAB0       		BNE	HOSTOUT			; was already set
    2419   2472 00006158 3078 10FC       		MOVE.W	BLKFREE,A0		; wasn't set...get an entry off free-list
    2420   2473 0000615C 31D0 10FC       		MOVE.W	(A0),BLKFREE		; unlink from free-list
    2421   2474 00006160 30B8 1100       		MOVE.W	BKOHEAD,(A0)		; link list-head to element
    2422   2475 00006164 3178 10A0 0002  		MOVE.W	PORTNO,2(A0)		; second word is port-number
    2423   2476 0000616A 31C8 1100       		MOVE.W	A0,BKOHEAD		; place this element as new list-head
    2424   2477 0000616E 2941 0004       		MOVE.L	D1,BO_TAR(Rp)		; TAR value
    2425   2478 00006172 3978 1104 000A  		MOVE.W	SAVE1,BO_TCN(Rp)	; TCN value
    2426   2479 00006178 426C 0008       		CLR.W	BO_BYT(Rp)		; BYT = 0
    2427   2480 0000617C 6000 FA88       		BRA	HOSTOUT
    2428   2481                          	
    2429   2482                          	
    2430   2483                          	*	Reset Block-output
    2431   2484 00006180 08AC 0005 0001  	RBTBKO	BCLR	#PF_BKO,P_FLAGS(Rp)	; clear Block-Output
    2432   2485 00006186 6722            		BEQ	LNKEND			; exit if not set
    2433   2486 00006188 43F8 1100       		LEA	BKOHEAD,A1		; was set...search for entry in list
    2434   2487                          	
    2435   2488 0000618C 4280            	UNLINK	CLR.L	D0
    2436   2489 0000618E 2049            	LNKLOP	MOVE.L	A1,A0			; copy NEXT to Current
    2437   2490 00006190 3010            		MOVE.W	(A0),D0			; get address of next element
    2438   2491 00006192 6716            		BEQ	LNKEND			; null...list exhausted
    2439   2492 00006194 2240            		MOVE.L	D0,A1			; ok...set address
    2440   2493 00006196 3029 0002       		MOVE.W	2(A1),D0		; get NEXT port
    2441   2494 0000619A B078 10A0       		CMP.W	PORTNO,D0		; is NEXT correct element?
    2442   2495 0000619E 66EE            		BNE	LNKLOP			; no
    2443   2496 000061A0 3091            		MOVE.W	(A1),(A0)		; found match...unlink (NEXT) element
    2444   2497 000061A2 32B8 10FC       		MOVE.W	BLKFREE,(A1)		; link element to free-list
    2445   2498 000061A6 31C9 10FC       		MOVE.W	A1,BLKFREE		; ...and make it new free-list head
    2446   2499 000061AA 4E75            	LNKEND	RTS
    2447   2500                          	
    2448   2501                          	
    2449   2502                          	*	Reset Block-input
    2450   2503 000061AC 08AC 0006 0001  	RBTBKI	BCLR	#PF_BKI,P_FLAGS(Rp)	; clear Block-input active
    2451   2504 000061B2 67F6            		BEQ	LNKEND			; not set...just exit
    2452   2505 000061B4 43F8 10FE       		LEA	BKIHEAD,A1		; set address of list-head
    2453   2506 000061B8 60D2            		BRA	UNLINK			; unlink entry from this list
    2454   2507                          	
    2455   2508                          	
    2456   2509                          	*	Reset BUFfer
    2457   2510 000061BA 43F8 1102       	RBTBUF	LEA	BUFHEAD,A1		; set address of list-headEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         22-May-88  Page   56
Err Source Ref. Address   value
    line   line

    2458   2511 000061BE 60CC            		BRA	UNLINK			; unlink entry from this list
    2459   2512                          	
    2460   2513                          	
    2461   2514                          	*	---26---	BLOCK INPUT REQUEST
    2462   2515                          	*	Block input is more complicated...each Bin request may start
    2463   2516                          	*	a series, OR continue an already-started sequence.  It is terminated
    2464   2517                          	*	by a Terminate-Block-Input request;  until that is received, we must
    2465   2518                          	*	buffer any data received after the last Bin service.
    2466   2519 000061C0 08EC 0006 0001  	BOK2	BSET	#PF_BKI,P_FLAGS(Rp)	; set Block-input active
    2467   2520 000061C6 6618            		BNE	BOK22			; already set...don't do it again
    2468   2521 000061C8 61F0            		BSR	RBTBUF			; wasn't set...insure buffer not on list
    2469   2522 000061CA 3078 10FC       		MOVE.W	BLKFREE,A0		; get an entry off free-list
    2470   2523 000061CE 31D0 10FC       		MOVE.W	(A0),BLKFREE		; unlink from free-list
    2471   2524 000061D2 30B8 10FE       		MOVE.W	BKIHEAD,(A0)		; link block-input list to this element
    2472   2525 000061D6 3178 10A0 0002  		MOVE.W	PORTNO,2(A0)		; install the port number
    2473   2526 000061DC 31C8 10FE       		MOVE.W	A0,BKIHEAD		; install element as new list-head
    2474   2527                          	
    2475   2528 000061E0 08AC 0007 0001  	BOK22	BCLR	#PF_BFD,P_FLAGS(Rp)	; clear Block FilleD
    2476   2529 000061E6 3978 10AA 0014  		MOVE.W	DAT3,BI_TCN(Rp)
    2477   2530 000061EC 6100 F3B2       		BSR	RDPDP
    2478   2531 000061F0 E089            		LSR.L	#8,D1
    2479   2532 000061F2 2941 0010       		MOVE.L	D1,BI_TAR(Rp)
    2480   2533 000061F6 426C 0016       		CLR.W	BI_LCN(Rp)
    2481   2534 000061FA 426C 0018       		CLR.W	BI_BYT(Rp)
    2482   2535 000061FE 2478 103A       		MOVE.L	.FASTC,A2		; record current time
    2483   2536 00006202 2952 000C       		MOVE.L	(A2),BI_TIM(Rp)
    2484   2537 00006206 4A2C 001E       		TST.B	BCT(Rp)			; anything already in buffer?
    2485   2538 0000620A 6700 F9FA       		BEQ	HOSTOUT			; no
    2486   2539 0000620E 6100 0940       		BSR.L	BU_BK			; yes...try to empty the buffer
    2487   2540 00006212 6000 F9F2       		BRA	HOSTOUT			; then quit
    2488   2541                          	
    2489   2542                          	
    2490   2543                          	*	---2A---	TERMINATE BLOCK OUTPUT
    2491   2544 00006216 11FC 002D 10A8  	BOK3	MOVE.B	#$2D,DAT1		; acknowledge request
    2492   2545 0000621C 6104            		BSR	BKOTERM			; send termination
    2493   2546 0000621E 6000 F9E6       		BRA	HOSTOUT
    2494   2547                          	
    2495   2548                          	
    2496   2549                          	*	Terminate Block-output -- DAT1 = reason
    2497   2550 00006222 11F8 10A1 10A9  	BKOTERM	MOVE.B	PORTNO+1,DAT2		; build message
    2498   2551 00006228 6100 F574       		BSR	WAITDAT			; wait, then write DAT into host
    2499   2552 0000622C 6100 F5AA       		BSR	PUTIFC
    2500   2553 00006230 6100 FF4E       		BSR	RBTBKO			; cancel block-output
    2501   2554 00006234 4E75            		RTS
    2502   2555                          	
    2503   2556                          	
    2504   2557                          	
    2505   2558                          	
    2506   2559                          	*	---2C---	TERMINATE BLOCK INPUT
    2507   2560 00006236 11FC 002B 10A8  	BOK4	MOVE.B	#$2B,DAT1
    2508   2561 0000623C 6118            		BSR	BKITERM			; send termination-messageEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		H O S T   O U T P U T         22-May-88  Page   57
Err Source Ref. Address   value
    line   line

    2509   2562 0000623E 6100 FF6C       		BSR.L	RBTBKI			; reset Block-input
    2510   2563 00006242 6100 082C       		BSR.L	BU_RG			; attempt to flush buffer
    2511   2564 00006246 4A6C 001E       		TST.W	BCT(Rp)			; anything left there?
    2512   2565 0000624A 6700 F9BA       		BEQ	HOSTOUT			; no...we're done
    2513   2566 0000624E 6100 08E8       		BSR.L	BU_ADD			; yes...insure it will be flushed
    2514   2567 00006252 6000 F9B2       		BRA	HOSTOUT			; and quit
    2515   2568                          	
    2516   2569                          	
    2517   2570                          	*	Terminate Block-input -- Reason in DAT1
    2518   2571 00006256 11F8 10A1 10A9  	BKITERM	MOVE.B	PORTNO+1,DAT2		; set up message
    2519   2572 0000625C 31EC 0016 10AA  		MOVE.W	BI_LCN(Rp),DAT3		; # of characters sent
    2520   2573 00006262 426C 0016       		CLR.W	BI_LCN(Rp)		; ...and reset count
    2521   2574 00006266 6100 F536       		BSR	WAITDAT			; wait, then write DAT into host
    2522   2575 0000626A 6100 F56C       		BSR	PUTIFC
    2523   2576 0000626E 08EC 0007 0001  		BSET	#PF_BFD,P_FLAGS(Rp)	; set Block FilleD
    2524   2577 00006274 4E75            		RTS
    2525   2578                          	
    2526   2579                          	
    2527   2580                          	*	---2E---	REQ FOR BLK I/O PORTS
    2528   2581 00006276 6100 F526       	BOK5	BSR	WAITDAT			; wait, then return DAT into host
    2529   2582 0000627A 6100 F55C       		BSR	PUTIFC
    2530   2583 0000627E 6000 F986       		BRA	HOSTOUT
    2531   2584                          	
    2532   2585                          	
    2533   2586                          	*	OMSG $33 - Set New timeout value
    2534   2587 00006282 31F8 10AA 1050  	SNTO	MOVE.W	DAT3,HOSTTO		; set new value
    2535   2588 00006288 31F8 10AA 1052  		MOVE.W	DAT3,TOHOST		; ...and how long we'll wait
    2536   2589 0000628E 6000 F976       		BRA	HOSTOUT			; that's all there is to this one...



    2538   2591                          		TTL	'E B U S  --  PDP-10 Base Code,		I S I S   I N P U T'EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           22-May-88  Page   58
Err Source Ref. Address   value
    line   line

    2540   2593                          	*		I S I S   R I N G   I N P U T
    2541   2594                          	
    2542   2595                          	
    2543   2596                          	
    2544   2597                          	
    2545   2598                          	*	Convenient Exit routines
    2546   2599                          	
    2547   2600                          	*	Place port number at DAT2 and send DAT to host
    2548   2601 00006292 11F8 10A1 10A9  	PUTPN	MOVE.B	PORTNO+1,DAT2		; place port number
    2549   2602                          	
    2550   2603                          	*	send DAT to host
    2551   2604 00006298 6100 F506       	SENDDAT	BSR	WRDAT
    2552   2605                          	
    2553   2606                          	*	all routines exit to here to clean up
    2554   2607 0000629C 6100 F210       	CLEANUP	BSR	ELIR
    2555   2608                          	
    2556   2609                          	*	INPUT TO PDP RING FROM ISIS RING
    2557   2610 000062A0 4A38 108B       	ISISIN	TST.B	HTDWN
    2558   2611 000062A4 6600 05FC       		BNE.L	VERIFY			; Host not up, try Half-second logic
    2559   2612 000062A8 6100 F52E       		BSR	PUTIFC
    2560   2613 000062AC 4A78 10F0       		TST.W	IRRN			; time to throttle input?
    2561   2614 000062B0 6D00 05F0       		BLT.L	VERIFY			; yes
    2562   2615 000062B4 6100 F170       		BSR	LOOK			; no...anything in ISIS ring?
    2563   2616 000062B8 6700 05E8       		BEQ.L	VERIFY			; No...go do Half-second stuff
    2564   2617 000062BC 31C4 109E       		MOVE.W	D4,INTYBT		; yes...save input Type-byte
    2565   2618 000062C0 6100 F544       		BSR	FDRGSZ			; compute INRGSP
    2566   2619                          	
    2567   2620                          	*	Distinguish between Needles, Port-0, data, and control
    2568   2621 000062C4 3238 109E       		MOVE.W	INTYBT,D1		; get Type byte
    2569   2622 000062C8 6700 0142       		BEQ.L	NEEDLE			; special processing for needles
    2570   2623 000062CC 3038 10A0       		MOVE.W	PORTNO,D0		; port 0?
    2571   2624 000062D0 6700 0506       		BEQ.L	IPZ			; special processing for port 0
    2572   2625 000062D4 0C41 009E       		CMP.W	#$9E,D1			; data?
    2573   2626 000062D8 6C00 02D2       		BGE.L	IMESS			; Special processing if not
    2574   2627                          	
    2575   2628                          	*	We have a data-message to process
    2576   2629 000062DC 4A6C 001E       		TST.W	BCT(Rp)			; is anything already buffered?
    2577   2630 000062E0 6670            		BNE	IS_BU			; add to buffer if so
    2578   2631 000062E2 082C 0006 0001  		BTST	#PF_BKI,P_FLAGS(Rp)	; is Block-input active?
    2579   2632 000062E8 6600 00A6       		BNE.L	BLOKIN			; skip if block-input in progress
    2580   2633 000062EC 082C 0004 0001  		BTST	#PF_HBP,P_FLAGS(Rp)	; has host applied back-pressure?
    2581   2634 000062F2 6654            		BNE	IS_BUF			; skip to place in buffer if so
    2582   2635 000062F4 3638 109C       		MOVE.W	INRGSP,D3		; space in ring
    2583   2636 000062F8 674E            		BEQ	IS_BUF			; skip to place in buffer if none
    2584   2637 000062FA 5543            		SUBQ	#2,D3			; allow for header
    2585   2638                          	
    2586   2639                          	*	Limit ourself to 30-byte messages to host
    2587   2640 000062FC 0C43 001E       		CMP.W	#30,D3			; ring-space > 30 chars?
    2588   2641 00006300 6F04            		BLE	ISISIN1			; less...normal processing
    2589   2642 00006302 363C 001E       		MOVE.W	#30,D3			; yes...make ring-space = 30EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           22-May-88  Page   59
Err Source Ref. Address   value
    line   line

    2590   2643                          	
    2591   2644 00006306 B641            	ISISIN1	CMP.W	D1,D3			; ring < MSG length?
    2592   2645 00006308 6F02            		BLE	ISISIN2			; yes
    2593   2646 0000630A 3601            		MOVE.W	D1,D3			; message-length is number to move
    2594   2647                          	
    2595   2648 0000630C 11C3 10A8       	ISISIN2	MOVE.B	D3,DAT1			; New type-byte
    2596   2649 00006310 0038 0080 10A8  		OR.B	#$80,DAT1		; Header is text length + $80
    2597   2650 00006316 11F8 10A1 10A9  		MOVE.B	PORTNO+1,DAT2		; set output port number
    2598   2651 0000631C 41F8 10AA       		LEA	DAT3,A0			; where to begin placing the characters
    2599   2652 00006320 6100 F128       	ISISIN3	BSR	GETCH			; copy chars
    2600   2653 00006324 10C0            		MOVE.B	D0,(A0)+
    2601   2654 00006326 5378 109E       		SUB.W	#1,INTYBT
    2602   2655 0000632A 5343            		SUB.W	#1,D3			; done yet?
    2603   2656 0000632C 6EF2            		BGT	ISISIN3			; no
    2604   2657 0000632E 43F8 10A8       		LEA	DAT,A1			; set up transmit cursor
    2605   2658                          	
    2606   2659 00006332 2219            	ISISIN4	MOVE.L	(A1)+,D1		; write DAT into host
    2607   2660 00006334 6100 F46E       		BSR	WRPDP
    2608   2661 00006338 B0C9            		CMPA	A1,A0
    2609   2662 0000633A 6EF6            		BGT	ISISIN4			; repeat for entire message
    2610   2663 0000633C 4A78 109E       		TST.W	INTYBT			; have we split data?
    2611   2664 00006340 6700 FF5A       		BEQ	CLEANUP			; no...finish message and on to next
    2612   2665 00006344 6100 F492       		BSR	PUTIFC			; yes...insure host sees it...buffer rest
    2613   2666                          	
    2614   2667                          	
    2615   2668                          	
    2616   2669                          	*	Buffer data because host said to...or because we split a message
    2617   2670 00006348 4A6C 001E       	IS_BUF	TST.W	BCT(Rp)			; anything already there?
    2618   2671 0000634C 6604            		BNE	IS_BU			; yes...just go do it
    2619   2672 0000634E 6100 07E8       		BSR.L	BU_ADD			; no...add this port to list
    2620   2673                          	
    2621   2674                          	*	Move ISIS message to buffer
    2622   2675 00006352 3038 109E       	IS_BU	MOVE.W	INTYBT,D0
    2623   2676 00006356 D06C 001E       		ADD.W	BCT(Rp),D0		; calculate amount to be in buffer
    2624   2677 0000635A B078 10EE       		CMP.W	BKPR,D0			; time to set back-pressure?
    2625   2678 0000635E 6D14            		BLT	IS_BU1			; not yet
    2626   2679 00006360 08EC 0003 0001  		BSET	#PF_IBP,P_FLAGS(Rp)	; set back-pressure applied
    2627   2680 00006366 660C            		BNE	IS_BU1			; already was set
    2628   2681 00006368 3638 10A0       		MOVE.W	PORTNO,D3		; for port
    2629   2682 0000636C 183C 00A0       		MOVE.B	#$A0,D4			; apply back-pressure
    2630   2683 00006370 6100 F07E       		BSR	SENDQI			; send Quick ISIS message
    2631   2684 00006374 6100 F0D4       	IS_BU1	BSR	GETCH			; copy char to buffer
    2632   2685 00006378 6100 F56A       		BSR	DWCI
    2633   2686 0000637C 0C00 001B       		CMP.B	#ESC,D0			; escape code?
    2634   2687 00006380 6604            		BNE	IS_BU2			; no
    2635   2688 00006382 6100 F560       		BSR	DWCI			; yes...escape it
    2636   2689 00006386 5378 109E       	IS_BU2	SUB.W	#1,INTYBT
    2637   2690 0000638A 6EE8            		BGT	IS_BU1
    2638   2691 0000638C 6000 FF0E       		BRA	CLEANUP			; finish this message and do next
    2639   2692                          	
    2640   2693                          	EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           22-May-88  Page   60
Err Source Ref. Address   value
    line   line

    2641   2694                          	*	BLOCK-INPUT
    2642   2695 00006390 082C 0007 0001  	BLOKIN	BTST	#PF_BFD,P_FLAGS(Rp)	; was Block FilleD?
    2643   2696 00006396 66BA            		BNE	IS_BU			; yes...place data into buffer
    2644   2697                          	
    2645   2698                          	*	Copy from ISIS-Ring to Block:  If terminated by Block-full
    2646   2699                          	*	then report termination.
    2647   2700 00006398 382C 0014       	IS_BK	MOVE.W	BI_TCN(Rp),D4		; get total count for block
    2648   2701 0000639C 6100 F3E0       		BSR	GETBLK			; get the word
    2649   2702 000063A0 366C 0018       		MOVE.W	BI_BYT(Rp),A3		; cursor within DAT
    2650   2703 000063A4 47EB 10A8       		LEA	DAT(A3),A3		; position of next byte
    2651   2704 000063A8 4A78 109E       	IS_BK1	TST.W	INTYBT			; test if anything to get
    2652   2705 000063AC 6724            		BEQ	IS_BK2			; skip if not
    2653   2706 000063AE B86C 0016       		CMP.W	BI_LCN(Rp),D4		; see if any space left
    2654   2707 000063B2 671E            		BEQ	IS_BK2			; skip if not
    2655   2708 000063B4 6100 F094       		BSR	GETCH			; OK...get from ring
    2656   2709 000063B8 5378 109E       		SUB.W	#1,INTYBT		; decrement data-counter
    2657   2710 000063BC 526C 0016       		ADD.W	#1,BI_LCN(Rp)		; count another char input
    2658   2711 000063C0 16C0            		MOVE.B	D0,(A3)+		; and save char
    2659   2712 000063C2 B6FC 10AC       		CMPA.W	#DAT5,A3		; have we exhausted DAT?
    2660   2713 000063C6 6DE0            		BLT	IS_BK1			; no
    2661   2714 000063C8 6100 F38C       		BSR	WRBLK			; yes
    2662   2715 000063CC 47F8 10A8       		LEA	DAT,A3			; reset word cursor
    2663   2716 000063D0 60D6            		BRA	IS_BK1
    2664   2717                          	
    2665   2718 000063D2 96FC 10A8       	IS_BK2	SUB.W	#DAT,A3			; compute displacement
    2666   2719 000063D6 394B 0018       		MOVE.W	A3,BI_BYT(Rp)		; save it for next time
    2667   2720 000063DA 6708            		BEQ	IS_BK3			; at beginning of word
    2668   2721 000063DC 6100 F378       		BSR	WRBLK			; no...write word into PDP
    2669   2722 000063E0 53AC 0010       		SUB.L	#1,BI_TAR(Rp)		; back up word-cursor
    2670   2723 000063E4 B86C 0016       	IS_BK3	CMP.W	BI_LCN(Rp),D4		; have we filled block?
    2671   2724 000063E8 670C            		BEQ	IS_BK4			; yes
    2672   2725 000063EA 2478 103A       		MOVE.L	.FASTC,A2		; no...record current time
    2673   2726 000063EE 2952 000C       		MOVE.L	(A2),BI_TIM(Rp)
    2674   2727 000063F2 6000 FEA8       		BRA	CLEANUP			; close this message and go do next
    2675   2728                          	
    2676   2729                          	*	Block-input terminated
    2677   2730 000063F6 11FC 0027 10A8  	IS_BK4	MOVE.B	#$27,DAT1
    2678   2731 000063FC 6100 FE58       		BSR	BKITERM			; terminate block-input
    2679   2732                          	
    2680   2733 00006400 4A78 109E       		TST.W	INTYBT			; see if more to do
    2681   2734 00006404 6600 FF4C       		BNE	IS_BU			; yes...go copy rest of message to buffer
    2682   2735 00006408 6000 FE92       		BRA	CLEANUP			; go clean upEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           22-May-88  Page   61
Err Source Ref. Address   value
    line   line

    2684   2737                          	*		ROUTINES TO PROCESS INDIVIDUAL ISIS MESSAGES
    2685   2738                          	
    2686   2739                          	
    2687   2740                          	*	A NEEDLE REQUEST IS PROCESSED HERE
    2688   2741 0000640C 7004            	NEEDLE	MOVEQ	#4,D0			; we'll need 4 bytes in the ISIS ring
    2689   2742 0000640E 6100 EF30       		BSR	ROOM			;  ...for a response
    2690   2743 00006412 6600 048E       		BNE.L	VERIFY			; Ignore this pass if not enough room there
    2691   2744 00006416 3638 10A0       		MOVE.W	PORTNO,D3		; port number
    2692   2745 0000641A 383C 00B9       		MOVE.W	#$B9,D4			; type = set transmit limit
    2693   2746 0000641E 6100 EF58       		BSR	SLOR
    2694   2747 00006422 701E            		MOVEQ	#30,D0			; ...to 30d
    2695   2748 00006424 6100 EF72       		BSR	PUTCH
    2696   2749 00006428 6100 EFCC       		BSR	ELOR
    2697   2750 0000642C 3238 109C       		MOVE.W	INRGSP,D1		; Also assume we'll need at least 80 bytes
    2698   2751 00006430 0C41 0050       		CMP.W	#80,D1			;  in the PDP to process a needle
    2699   2752 00006434 6D00 046C       		BLT.L	VERIFY			; Ignore this pass if not enough room there
    2700   2753 00006438 6100 F010       		BSR	GETCH			; key
    2701   2754 0000643C 6100 F04E       		BSR	GETW			; Invoice
    2702   2755 00006440 6100 F032       		BSR	GETH			; Dest. Host
    2703   2756 00006444 6100 F02E       		BSR	GETH			; Orig. Node
    2704   2757 00006448 31C0 10A2       		MOVE.W	D0,NORNODE
    2705   2758 0000644C 6100 F026       		BSR	GETH			; Orig. Host
    2706   2759 00006450 31C0 10A4       		MOVE.W	D0,NORHOST
    2707   2760 00006454 6100 F01E       		BSR	GETH			; Orig. Port
    2708   2761 00006458 31C0 10A6       		MOVE.W	D0,NORPORT
    2709   2762 0000645C 6100 F02E       		BSR	GETW			; Extra I.N. | XXX | TPC
    2710   2763 00006460 6100 F012       		BSR	GETH			; Dest. Node
    2711   2764 00006464 6100 EFE4       		BSR	GETCH			; CCT
    2712   2765 00006468 11C0 10DC       		MOVE.B	D0,NCCT
    2713   2766 0000646C 6100 EFDC       		BSR	GETCH			; size
    2714   2767 00006470 11C0 10DD       		MOVE.B	D0,NSIZ
    2715   2768                          	
    2716   2769                          	*	Move the username from needle to DAT
    2717   2770 00006474 1400            		MOVE.B	D0,D2			; number of bytes of username
    2718   2771 00006476 43F8 10AC       		LEA	DAT5,A1			; copy username into DAT5+
    2719   2772 0000647A 6100 EFCE       	GETUN	BSR	GETCH
    2720   2773 0000647E 12C0            		MOVE.B	D0,(A1)+
    2721   2774 00006480 5302            		SUB.B	#1,D2
    2722   2775 00006482 6EF6            		BGT	GETUN			; continue until copied
    2723   2776                          	
    2724   2777 00006484 4A38 1107       		TST.B	PFULL			; ports still available?
    2725   2778 00006488 6600 00A4       		BNE.L	NEE1			; no
    2726   2779 0000648C 4A38 108B       		TST.B	HTDWN			; yes...host up?
    2727   2780 00006490 6600 00C6       		BNE.L	NEE2			; no
    2728   2781 00006494 4A38 104E       		TST.B	HSTAT			; yes...answered?
    2729   2782 00006498 670C            		BEQ	NEEDLE1			; yes
    2730   2783 0000649A 1038 10AC       		MOVE.B	DAT5,D0			; no...shut
    2731   2784 0000649E 0C00 00A1       		CMP.B	#$A1,D0			; "!" (Shut override)?
    2732   2785 000064A2 6600 00CE       		BNE.L	NEE4			; no
    2733   2786                          	EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           22-May-88  Page   62
Err Source Ref. Address   value
    line   line

    2734   2787 000064A6 6100 F5A0       	NEEDLE1	BSR	RBTALL			; reset everything for port
    2735   2788 000064AA 08EC 0000 0001  		BSET	#PF_ACT,P_FLAGS(Rp)	; set port active
    2736   2789 000064B0 6100 F6AC       		BSR	IPORT			; bump number of active ports
    2737   2790 000064B4 1038 10DC       		MOVE.B	NCCT,D0			; translate CCT
    2738   2791 000064B8 0240 001F       		AND.W	#$1F,D0
    2739   2792 000064BC 41F8 390A       		LEA	CCTBD,A0
    2740   2793 000064C0 1970 0000 0003  		MOVE.B	0(A0,D0.W),IBRATE(Rp)	; record Input Baud rate in case host asks
    2741   2794                          	
    2742   2795 000064C6 11FC 0006 10A8  		MOVE.B	#6,DAT1			; type 6...New External Logon
    2743   2796 000064CC 11F8 10A1 10A9  		MOVE.B	PORTNO+1,DAT2		; port #
    2744   2797 000064D2 31F8 10A4 10AA  		MOVE.W	NORHOST,DAT3		; Origination host #
    2745   2798 000064D8 6100 F2C6       		BSR	WRDAT			; send DAT to host
    2746   2799                          	
    2747   2800 000064DC 11FC 0082 10A8  		MOVE.B	#$82,DAT1		; 2-byte Data message
    2748   2801 000064E2 11F8 10DC 10AA  		MOVE.B	NCCT,DAT3		; CCT
    2749   2802 000064E8 3038 10A2       		MOVE.W	NORNODE,D0
    2750   2803 000064EC EC48            		LSR.W	#6,D0
    2751   2804 000064EE 11C0 10AB       		MOVE.B	D0,DAT4			; high 6-bits of originating node
    2752   2805 000064F2 6100 F2AC       		BSR	WRDAT			; send DAT to Host
    2753   2806                          	
    2754   2807 000064F6 3038 10A2       		MOVE.W	NORNODE,D0
    2755   2808 000064FA 0240 003F       		AND.W	#$3F,D0			; low 6-bits of originating host
    2756   2809 000064FE 11C0 10AA       		MOVE.B	D0,DAT3
    2757   2810 00006502 11F8 10A6 10AB  		MOVE.B	NORPORT,DAT4		; originating port
    2758   2811 00006508 6100 F296       		BSR	WRDAT			; send DAT to host
    2759   2812                          	
    2760   2813                          	*	Now move the username from DAT into host
    2761   2814 0000650C 1438 10DD       		MOVE.B	NSIZ,D2			; number of bytes
    2762   2815 00006510 43F8 10AC       		LEA	DAT5,A1			; where to copy from
    2763   2816 00006514 0C02 0001       	PUTUN	CMP.B	#1,D2			; single byte?
    2764   2817 00006518 6604            		BNE	PUTUN1			; no
    2765   2818 0000651A 5338 10A8       		SUB.B	#1,DAT1			; yes...reduce count
    2766   2819 0000651E 31D9 10AA       	PUTUN1	MOVE.W	(A1)+,DAT3		; copy next pair of bytes
    2767   2820 00006522 6100 F27C       		BSR	WRDAT			; send DAT to host
    2768   2821 00006526 5502            		SUB.B	#2,D2			; reduce count
    2769   2822 00006528 6EEA            		BGT	PUTUN			; continue until name sent
    2770   2823 0000652A 6000 FD70       		BRA	CLEANUP			; Done
    2771   2824                          	
    2772   2825                          	*	Out of ports...Must zap circuit for current needle
    2773   2826 0000652E 41F8 657A 4E71  	NEE1	LEA	OOPMSG,A0		; set pointer to [host out of ports]
    2774   2827 00006534 6100 EED2       		BSR	SENDTEXT		; tell reason (with bells)
    2775   2828 00006538 6100 EE24       		BSR	WAITISW			; we'll need 1 word to return Zapper
    2776   2829 0000653C 3638 10A0       		MOVE.W	PORTNO,D3		; port number
    2777   2830 00006540 183C 00BE       		MOVE.B	#$BE,D4			; Type = Zap with reason
    2778   2831 00006544 6100 EE32       		BSR	SLOR
    2779   2832 00006548 4240            		CLR.W	D0			; reason = 0 -- out of ports
    2780   2833 0000654A 6100 EE4C       		BSR	PUTCH
    2781   2834 0000654E 6100 EEA6       		BSR	ELOR
    2782   2835 00006552 4242            		CLR.W	D2
    2783   2836 00006554 6000 FD46       		BRA	CLEANUP			; go clean up
    2784   2837                          	EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           22-May-88  Page   63
Err Source Ref. Address   value
    line   line

    2785   2838                          	*	Host down
    2786   2839 00006558 41F8 6590 4E71  	NEE2	LEA	HDNMSG,A0		; set pointer to [host down]
    2787   2840                          	
    2788   2841 0000655E 6100 EEA8       	NEE3	BSR	SENDTEXT		; tell user
    2789   2842 00006562 3638 10A0       		MOVE.W	PORTNO,D3
    2790   2843 00006566 183C 009E       		MOVE.B	#$9E,D4			; detach circuit
    2791   2844 0000656A 6100 EE84       		BSR	SENDQI
    2792   2845 0000656E 6000 FD2C       		BRA	CLEANUP			; go clean up needle
    2793   2846                          	
    2794   2847                          	*	Host Shut
    2795   2848 00006572 41F8 659E 4E71  	NEE4	LEA	HSHMSG,A0		; set pointer to [host shut]
    2796   2849 00006578 60E4            		BRA	NEE3			; and go clean up
    2797   2850                          	
    2798   2851 0000657A                 	OOPMSG	TEXTC	<$87,'[Host out of ports]',$87>
    2799   2859 00006590                 	HDNMSG	TEXTC	<$87,'[Host down]',$87>
    2800   2865 0000659E                 	HSHMSG	TEXTC	<$87,'[Host shut]',$87>EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           22-May-88  Page   64
Err Source Ref. Address   value
    line   line

    2802   2872                          	*	Determine handler for ISIS message -- D1 = INTYBT
    2803   2873 000065AC 0C41 00C1       	IMESS	CMP.W	#$C1,D1			; range check on type
    2804   2874 000065B0 6C00 EC28       		BGE	ISMGER			; Bad ISIS input MSG
    2805   2875 000065B4 0441 009E       		SUB.W	#$9E,D1			; bias type-code to tables
    2806   2876 000065B8 6D00 EC20       		BLT	ISMGER			; Bad ISIS input MSG
    2807   2877 000065BC 4240            		CLR.W	D0
    2808   2878 000065BE 103B 1012       		MOVE.B	TRISLN(PC,D1.W),D0	; is there space to proceed?
    2809   2879 000065C2 B078 109C       		CMP.W	INRGSP,D0		; space in ring
    2810   2880 000065C6 6C00 02DA       		BGE.L	VERIFY			; abort this go-roundie if not
    2811   2881 000065CA D241            		ADD.W	D1,D1			; *2
    2812   2882 000065CC 327B 1028       		MOVE.W	IMSTAB(PC,D1.W),A1	; look up handler address
    2813   2883 000065D0 4ED1            		JMP	(A1)			; ...and go there
    2814   2884                          	
    2815   2885                          	
    2816   2886                          	*	TRANSLATED ISIS MSG LENGTH
    2817   2887 000065D2 00              	TRISLN	DC.B	0			; 9E
    2818   2888 000065D3 02              		DC.B	2			; 9F
    2819   2889 000065D4 02              		DC.B	2			; A0
    2820   2890 000065D5 02              		DC.B	2			; A1
    2821   2891 000065D6 02              		DC.B	2			; A2
    2822   2892 000065D7 00              		DC.B	0			; A3
    2823   2893 000065D8 03              		DC.B	3			; A4
    2824   2894 000065D9 03              		DC.B	3			; A5
    2825   2895 000065DA 02              		DC.B	2			; A6
    2826   2896 000065DB 02              		DC.B	2			; A7
    2827   2897 000065DC 00              		DC.B	0			; A8
    2828   2898 000065DD 00              		DC.B	0			; A9
    2829   2899 000065DE 02              		DC.B	2			; AA
    2830   2900 000065DF 02              		DC.B	2			; AB
    2831   2901 000065E0 02              		DC.B	2			; AC
    2832   2902 000065E1 02              		DC.B	2			; AD
    2833   2903 000065E2 02              		DC.B	2			; AE
    2834   2904 000065E3 00              		DC.B	0			; AF
    2835   2905 000065E4 00              		DC.B	0			; B0
    2836   2906 000065E5 04              		DC.B	4			; B1
    2837   2907 000065E6 00              		DC.B	0			; B2
    2838   2908 000065E7 00              		DC.B	0			; B3
    2839   2909 000065E8 00              		DC.B	0			; B4
    2840   2910 000065E9 03              		DC.B	3			; B5
    2841   2911 000065EA 06              		DC.B	6			; B6
    2842   2912 000065EB 00              		DC.B	0			; B7
    2843   2913 000065EC 00              		DC.B	0			; B8
    2844   2914 000065ED 00              		DC.B	0			; B9
    2845   2915 000065EE 00              		DC.B	0			; BA
    2846   2916 000065EF 00              		DC.B	0			; BB
    2847   2917 000065F0 00              		DC.B	0			; BC
    2848   2918 000065F1 00              		DC.B	0			; BD
    2849   2919 000065F2 00              		DC.B	0			; BE
    2850   2920 000065F3 00              		DC.B	0			; BF
    2851   2921 000065F4 00              		DC.B	0			; C0EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           22-May-88  Page   65
Err Source Ref. Address   value
    line   line

    2852   2922 000065F5 00              		DC.B	0			; C1
    2853   2923                          	
    2854   2924                          	
    2855   2925                          	*	ISIS INPUT MESSAGE DISPATCH TABLE
    2856   2926 000065F6 629C            	IMSTAB	DC.W	CLEANUP			; 9E - DETACH, IGNORE
    2857   2927 000065F8 663E            		DC.W	ZAPPER			; 9F - ZAPPER, process and send on
    2858   2928 000065FA 6650            		DC.W	BPON			; A0 - SET BKPR, SEND ON
    2859   2929 000065FC 6658            		DC.W	BPOFF			; A1 - RELEASE BKPR, SEND ON
    2860   2930 000065FE 6660            		DC.W	GOBBLER			; A2 - GOBBLER, Send on
    2861   2931 00006600 629C            		DC.W	CLEANUP			; A3 - FLUSH INPUT, IGNORE
    2862   2932 00006602 6678            		DC.W	BLACK			; A4 - BLACK BALL
    2863   2933 00006604 6672            		DC.W	GRAY			; A5 - GRAY BALL
    2864   2934 00006606 669A            		DC.W	STREAM			; A6 - ENTER DEM, Send on
    2865   2935 00006608 669A            		DC.W	STREAM			; A7 - LEAVE DEM, Send on
    2866   2936 0000660A 629C            		DC.W	CLEANUP			; A8 - ENTER TRANSPARENCY, IGNORE
    2867   2937 0000660C 629C            		DC.W	CLEANUP			; A9 - LEAVE TRANSPARENCY, IGNORE
    2868   2938 0000660E 669A            		DC.W	STREAM			; AA - GREEN BALL, Send on
    2869   2939 00006610 669A            		DC.W	STREAM			; AB - RED BALL, Send on
    2870   2940 00006612 6680            		DC.W	YELLOW			; AC - YELLOW BALL, SEND ON
    2871   2941 00006614 66B2            		DC.W	ISP			; AD - ORANGE BALL, Send on immediately
    2872   2942 00006616 669A            		DC.W	STREAM			; AE - BREAK BEGIN, Send on
    2873   2943 00006618 629C            		DC.W	CLEANUP			; AF - HANG UP, IGNORE
    2874   2944 0000661A 629C            		DC.W	CLEANUP			; B0 - QUERY TERM CHAR, IGNORE
    2875   2945 0000661C 66DA            		DC.W	ITERM			; B1 - SET TERM CHAR
    2876   2946 0000661E 66F4            		DC.W	PNEDL			; B2 - PSEUDO NEEDLE
    2877   2947 00006620 51DA            		DC.W	ISMGER			; B3 - LOGON CHAR (we don't expect this)
    2878   2948 00006622 629C            		DC.W	CLEANUP			; B4 - LOGON STATUS, IGNORE
    2879   2949 00006624 6740            		DC.W	LOGFAL			; B5 - LOGON FAILED
    2880   2950 00006626 676C            		DC.W	ILOG			; B6 - LOGON OKAY
    2881   2951 00006628 51DA            		DC.W	ISMGER			; B7 - ACCOUNTING (we don't expect this)
    2882   2952 0000662A 629C            		DC.W	CLEANUP			; B8 - SUPER HANG, IGNORE
    2883   2953 0000662C 67C4            		DC.W	SMTLMT			; B9 - SET XMT LIMIT
    2884   2954 0000662E 629C            		DC.W	CLEANUP			; BA - BREAK END, IGNORE
    2885   2955 00006630 629C            		DC.W	CLEANUP			; BB - ZAP ACKNOWLEDGE, IGNORE
    2886   2956 00006632 629C            		DC.W	CLEANUP			; BC - ENTER ALT DEV MODE, IGNORE
    2887   2957 00006634 629C            		DC.W	CLEANUP			; BD - LEAVE ALT DEV MODE, IGNORE
    2888   2958 00006636 629C            		DC.W	CLEANUP			; BE - ZAP WITH REASON,IGNORE
    2889   2959 00006638 629C            		DC.W	CLEANUP			; BF - SIIX COMMAND, IGNORE
    2890   2960 0000663A 629C            		DC.W	CLEANUP			; C0 - TIIX COMMAND, IGNORE
    2891   2961 0000663C 51DA            		DC.W	ISMGER			; C1 - UUO (we don't expect this)
    2892   2962                          	
    2893   2963                          	
    2894   2964                          	*	9F -- Zapper
    2895   2965 0000663E 08AC 0000 0001  	ZAPPER	BCLR	#PF_ACT,P_FLAGS(Rp)	; test if port active (and reset it)
    2896   2966 00006644 676C            		BEQ	ISP			; no...just proceed
    2897   2967 00006646 6100 F52E       		BSR	DPORT			; yes...count it gone
    2898   2968 0000664A 6100 F3FC       		BSR	RBTALL			; reset everything
    2899   2969 0000664E 6062            		BRA	ISP			; ...and proceed
    2900   2970                          	
    2901   2971                          	
    2902   2972                          	*	A0 -- apply back-pressureEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           22-May-88  Page   66
Err Source Ref. Address   value
    line   line

    2903   2973 00006650 08EC 0002 0001  	BPON	BSET	#PF_OBP,P_FLAGS(Rp)	; set output back-pressure
    2904   2974 00006656 605A            		BRA	ISP
    2905   2975                          	
    2906   2976                          	*	A1 -- release back-pressure
    2907   2977 00006658 08AC 0002 0001  	BPOFF	BCLR	#PF_OBP,P_FLAGS(Rp)	; clear output back-pressure
    2908   2978 0000665E 6052            		BRA	ISP
    2909   2979                          	
    2910   2980                          	*	A2 -- Gobbler
    2911   2981 00006660 082C 0006 0001  	GOBBLER	BTST	#PF_BKI,P_FLAGS(Rp)	; block-input active?
    2912   2982 00006666 664A            		BNE	ISP			; yes...just pass it on
    2913   2983 00006668 6100 F2F8       		BSR	DEMPTY			; no...empty the buffer
    2914   2984 0000666C 6100 04B4       		BSR.L	BU_EMP			; release back-pressure
    2915   2985 00006670 6040            		BRA	ISP			; ...then pass it on
    2916   2986                          	
    2917   2987                          	
    2918   2988                          	*	A5 -- Gray ball
    2919   2989 00006672 4238 10AA       	GRAY	CLR.B	DAT3			; d3 = 0 for grey ball
    2920   2990 00006676 603A            		BRA	ISP			; then process as special message
    2921   2991                          	
    2922   2992                          	*	A4 -- Black Ball
    2923   2993 00006678 11FC 00FF 10AA  	BLACK	MOVE.B	#-1,DAT3		; special parameter
    2924   2994 0000667E 6032            		BRA	ISP
    2925   2995                          	
    2926   2996                          	
    2927   2997                          	*	AC - Yellow Ball
    2928   2998                          	*	Special handling for Block-input active, since Yellow-ball
    2929   2999                          	*	serves to indicate EOT.
    2930   3000 00006680 082C 0006 0001  	YELLOW	BTST	#PF_BKI,P_FLAGS(Rp)	; is block-input active?
    2931   3001 00006686 6712            		BEQ	STREAM			; no...process as normal in-stream code
    2932   3002 00006688 082C 0007 0001  		BTST	#PF_BFD,P_FLAGS(Rp)	; yes...test Block-FilleD
    2933   3003 0000668E 6610            		BNE	STREAM1			; was set...place yellow-ball into buffer
    2934   3004 00006690 11FC 0028 10A8  		MOVE.B	#$28,DAT1		; no...set Bin terminated by EOT
    2935   3005 00006696 6100 FBBE       		BSR	BKITERM			; terminate block-input
    2936   3006                          						; ...then proceed with in-stream usage
    2937   3007                          	
    2938   3008                          	
    2939   3009                          	*	Special Message...retain in-stream
    2940   3010 0000669A 4A6C 001E       	STREAM	TST.W	BCT(Rp)			; anything in buffer?
    2941   3011 0000669E 6712            		BEQ	ISP			; no...just pass it on
    2942   3012                          	
    2943   3013 000066A0 701B            	STREAM1	MOVEQ	#ESC,D0			; Yes...place escape
    2944   3014 000066A2 6100 F240       		BSR	DWCI			;  ...into buffer
    2945   3015 000066A6 3038 109E       		MOVE.W	INTYBT,D0		;   ...followed by ISIS Code
    2946   3016 000066AA 6100 F238       		BSR	DWCI
    2947   3017 000066AE 6000 FBEC       		BRA	CLEANUP			; done...escaped code will be removed later
    2948   3018                          	
    2949   3019                          	
    2950   3020                          	*	Single-byte ISIS message
    2951   3021                          	*	MSG types 9F, A0, A1, A2, A6, A7, AA, AB, AC, AD, AE
    2952   3022 000066B2 6104            	ISP	BSR	LOOKUP			; go translate message-type
    2953   3023 000066B4 6000 FBDC       		BRA	PUTPN			; go send itEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           22-May-88  Page   67
Err Source Ref. Address   value
    line   line

    2954   3024                          	
    2955   3025                          	*	Translate ISIS message-type to PDP type, place into DAT1
    2956   3026 000066B8 3238 109E       	LOOKUP	MOVE.W	INTYBT,D1
    2957   3027 000066BC 0441 009F       		SUB.W	#$9F,D1
    2958   3028 000066C0 11FB 1008 10A8  		MOVE.B	ISPTAB(PC,D1.W),DAT1	; translated message-type
                         4E71
    2959   3029 000066C8 4E75            		RTS
    2960   3030                          	
    2961   3031                          	*	Translation table for ISIS special ( > $9E ) messages
    2962   3032 000066CA 0B              	ISPTAB	DC.B	11			; 9F - Zapper
    2963   3033 000066CB 08              		DC.B	8			; A0 - Apply backpressure
    2964   3034 000066CC 09              		DC.B	9			; A1 - Release backpressure
    2965   3035 000066CD 0A              		DC.B	10			; A2 - Gobbler
    2966   3036 000066CE 00              		DC.B	0			; A3 -
    2967   3037 000066CF 15              		DC.B	21			; A4 - Black Ball
    2968   3038 000066D0 15              		DC.B	21			; A5 - Gray Ball
    2969   3039 000066D1 0C              		DC.B	12			; A6 - Enter DEM
    2970   3040 000066D2 0D              		DC.B	13			; A7 - Leave DEM
    2971   3041 000066D3 00              		DC.B	0			; A8 -
    2972   3042 000066D4 00              		DC.B	0			; A9 -
    2973   3043 000066D5 0E              		DC.B	14			; AA - Green Ball
    2974   3044 000066D6 0F              		DC.B	15			; AB - Red Ball
    2975   3045 000066D7 10              		DC.B	16			; AC - Yellow Ball
    2976   3046 000066D8 11              		DC.B	17			; AD - Orange Ball
    2977   3047 000066D9 2F              		DC.B	47			; AE - Break Begin
    2978   3048                          	
    2979   3049                          	
    2980   3050                          	*	B1 -- Terminal-characteristics response
    2981   3051 000066DA 11FC 0020 10A8  	ITERM	MOVE.B	#$20,DAT1		; type
    2982   3052 000066E0 6100 ED68       		BSR	GETCH			; parameter number
    2983   3053                          	*	CMP.B	#$10,D0			; *hack* remove this test when	<2.2
    2984   3054                          	*	BNE	NOJAP			; the PDP-10 code is fixed.	<2.2
    2985   3055                          	*	SUB.B	#1,D0			; translate 16d to 15d		<2.2
    2986   3056 000066E4 11C0 10AA       	NOJAP	MOVE.B	D0,DAT3			; parameter code
    2987   3057 000066E8 6100 ED60       		BSR	GETCH
    2988   3058 000066EC 11C0 10AB       		MOVE.B	D0,DAT4			; value
    2989   3059 000066F0 6000 FBA0       		BRA	PUTPN			; send it
    2990   3060                          	
    2991   3061                          	
    2992   3062                          	*	B2 -- Pseudo-Needle
    2993   3063 000066F4 6100 F352       	PNEDL	BSR	RBTALL			; first, clean up port
    2994   3064 000066F8 6100 ED50       		BSR	GETCH			; padding
    2995   3065 000066FC 6100 ED76       		BSR	GETH			; local key
    2996   3066 00006700 1940 0003       		MOVE.B	D0,AUXKEY(Rp)		; save it
    2997   3067 00006704 4A38 1107       		TST.B	PFULL			; room for another circuit?
    2998   3068 00006708 6618            		BNE	PFULL1			; skip if not
    2999   3069 0000670A 6100 F33C       		BSR	RBTALL			; reset everything for port
    3000   3070 0000670E 08EC 0001 0001  		BSET	#PF_ILI,P_FLAGS(Rp)	; set port In_Log-In
    3001   3071 00006714 6100 F448       		BSR	IPORT
    3002   3072 00006718 31FC FFFF 1060  		MOVE.W	#-1,AUXX		; enable another aux-request
    3003   3073 0000671E 6000 FB7C       		BRA	CLEANUP			; go clean upEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           22-May-88  Page   68
Err Source Ref. Address   value
    line   line

    3004   3074                          	
    3005   3075                          	*	Out of ports...Must zap circuit for B2
    3006   3076 00006722 6100 EC3A       	PFULL1	BSR	WAITISW			; we'll need 1 word to return Zapper
    3007   3077 00006726 3638 10A0       		MOVE.W	PORTNO,D3		; port number
    3008   3078 0000672A 183C 00BE       		MOVE.B	#$BE,D4			; Type = Zap with reason
    3009   3079 0000672E 6100 EC48       		BSR	SLOR
    3010   3080 00006732 4240            		CLR.W	D0			; reason = 0 -- out of ports
    3011   3081 00006734 6100 EC62       		BSR	PUTCH
    3012   3082 00006738 6100 ECBC       		BSR	ELOR
    3013   3083 0000673C 7008            		MOVEQ	#8,D0			; fake reason to "out of orig. ports"
    3014   3084 0000673E 6008            		BRA	LOGFAL1			; tell host that Aux-circuit attempt failed
    3015   3085                          	
    3016   3086                          	
    3017   3087                          	*	B5 -- Logon failure
    3018   3088 00006740 6100 F306       	LOGFAL	BSR	RBTALL			; clear the port
    3019   3089 00006744 6100 ED04       		BSR	GETCH			; get reason
    3020   3090 00006748 31FC FFFF 1060  	LOGFAL1	MOVE.W	#-1,AUXX		; enable another AUX attempt
    3021   3091 0000674E 11FC 0017 10A8  		MOVE.B	#$17,DAT1		; message type
    3022   3092 00006754 11F8 105B 10A9  		MOVE.B	AUXQ+1,DAT2		; AUX circuit key
    3023   3093 0000675A 11C0 10AA       		MOVE.B	D0,DAT3			; error code
    3024   3094 0000675E 6600 FB38       		BNE	SENDDAT			; send to PDP (unless 0)
    3025   3095 00006762 11FC 0007 10AA  		MOVE.B	#7,DAT3			; code 0 -> 7
    3026   3096 00006768 6000 FB2E       		BRA	SENDDAT
    3027   3097                          	
    3028   3098                          	
    3029   3099                          	*	B6 -- Logon OK
    3030   3100 0000676C 6100 ECDC       	ILOG	BSR	GETCH			; padding
    3031   3101 00006770 6100 ED1A       		BSR	GETW			; Invoice number
    3032   3102 00006774 6100 ECFE       		BSR	GETH			; orig. host
    3033   3103 00006778 3638 10A0       		MOVE.W	PORTNO,D3		; for this port,
    3034   3104 0000677C 383C 00B9       		MOVE.W	#$B9,D4			; ...set transmit limit
    3035   3105 00006780 6100 EBF6       		BSR	SLOR
    3036   3106 00006784 701E            		MOVEQ	#30,D0			; ...to 30d
    3037   3107 00006786 6100 EC10       		BSR	PUTCH
    3038   3108 0000678A 6100 EC6A       		BSR	ELOR
    3039   3109 0000678E 08AC 0001 0001  		BCLR	#PF_ILI,P_FLAGS(Rp)	; clear port In_Log-In
    3040   3110 00006794 08EC 0000 0001  		BSET	#PF_ACT,P_FLAGS(Rp)	; set port active
    3041   3111 0000679A 11FC 0007 10A8  		MOVE.B	#7,DAT1
    3042   3112 000067A0 11F8 10A1 10A9  		MOVE.B	PORTNO+1,DAT2
    3043   3113 000067A6 11EC 0003 10AA  		MOVE.B	AUXKEY(Rp),DAT3		; orig port
    3044   3114 000067AC 6100 EFF2       		BSR	WRDAT			; send DAT on to PDP
    3045   3115 000067B0 11FC 0017 10A8  		MOVE.B	#$17,DAT1		; tell PDP which AUX succeeded
    3046   3116 000067B6 11EC 0003 10A9  		MOVE.B	AUXKEY(Rp),DAT2		; orig port
    3047   3117 000067BC 4278 10AA       		CLR.W	DAT3			; set success-code
    3048   3118 000067C0 6000 FAD6       		BRA	SENDDAT			; send DAT to host
    3049   3119                          	
    3050   3120                          	
    3051   3121                          	*	B9 - SET XMT LIMIT
    3052   3122 000067C4 6100 EC84       	SMTLMT	BSR	GETCH			; get limit
    3053   3123 000067C8 5B00            		SUB.B	#5,D0			; round down
    3054   3124 000067CA 0200 00FC       		AND.B	#$FC,D0EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           22-May-88  Page   69
Err Source Ref. Address   value
    line   line

    3055   3125 000067CE 5400            		ADD.B	#2,D0			; round back up
    3056   3126 000067D0 1940 0002       		MOVE.B	D0,XMITLMT(Rp)		; save transmit-limit
    3057   3127 000067D4 6000 FAC6       		BRA	CLEANUP			; nothing to tell hostEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           22-May-88  Page   70
Err Source Ref. Address   value
    line   line

    3059   3129                          	*	PROCESS PORT-ZERO MESSAGES
    3060   3130                          	
    3061   3131                          	
    3062   3132                          	*	D0 = 0;  D1 = INTYBT
    3063   3133 000067D8 0C41 0010       	IPZ	CMP.W	#$10,D1			; is this valid Port 0 message?
    3064   3134 000067DC 6E00 E9FC       		BGT	ISMGER			; not in range -- crash
    3065   3135 000067E0 103B 1012       		MOVE.B	INISLN(PC,D1),D0	; will MSG fit?
    3066   3136 000067E4 B078 109C       		CMP.W	INRGSP,D0		; space in ring
    3067   3137 000067E8 6C00 00B8       		BGE.L	VERIFY			; no...go to VERIFY
    3068   3138 000067EC D241            		ADD.W	D1,D1			; 2*message type
    3069   3139 000067EE 327B 1016       		MOVE.W	IPZTAB(PC,D1),A1	; get the service address
    3070   3140 000067F2 4ED1            		JMP	(A1)			; go service port0 message
    3071   3141                          	
    3072   3142                          	*	INTRA-ISIS MSG LENGTH
    3073   3143 000067F4 00              	INISLN	DC.B	0			; 00
    3074   3144 000067F5 00              		DC.B	0			; 01
    3075   3145 000067F6 02              		DC.B	2			; 02
    3076   3146 000067F7 00              		DC.B	0			; 03
    3077   3147 000067F8 00              		DC.B	0			; 04
    3078   3148 000067F9 00              		DC.B	0			; 05
    3079   3149 000067FA 06              		DC.B	6			; 06
    3080   3150 000067FB 00              		DC.B	0			; 07
    3081   3151 000067FC 00              		DC.B	0			; 08
    3082   3152 000067FD 03              		DC.B	3			; 09
    3083   3153 000067FE 00              		DC.B	0			; 0A
    3084   3154 000067FF 00              		DC.B	0			; 0B
    3085   3155 00006800 00              		DC.B	0			; 0C
    3086   3156 00006801 02              		DC.B	2			; 0D
    3087   3157 00006802 00              		DC.B	0			; 0E
    3088   3158 00006803 00              		DC.B	0			; 0F
    3089   3159 00006804 00              		DC.B	0			; 10
    3090   3160                          	
    3091   3161                          	
    3092   3162                          	*	ISIS INTRA-NODE MESSAGE DISPATCH TABLE
    3093   3163 00006806 51DA            	IPZTAB	DC.W	ISMGER			; 00 RESTRT REQ -- Not Expected
    3094   3164 00006808 51DA            		DC.W	ISMGER			; 01 RESTRT RESP -- Not Expected
    3095   3165 0000680A 6828            		DC.W	SUPTAK			; 02 SUPERVISOR TAKEOVER
    3096   3166 0000680C 51DA            		DC.W	ISMGER			; 03 REPORT TO SUP -- Not Expected
    3097   3167 0000680E 51DA            		DC.W	ISMGER			; 04 HOST STATUS -- Not Expected
    3098   3168 00006810 51DA            		DC.W	ISMGER			; 05 ACCNTNG -- Not Expected
    3099   3169 00006812 683C            		DC.W	IPTIME			; 06 SUP TIME
    3100   3170 00006814 51DA            		DC.W	ISMGER			; 07 NORM CIR REQ -- Not Expected
    3101   3171 00006816 51DA            		DC.W	ISMGER			; 08 AUX CIR REQ -- Not Expected
    3102   3172 00006818 6864            		DC.W	AUXERR			; 09 AUX CIRCUIT ERROR
    3103   3173 0000681A 51DA            		DC.W	ISMGER			; 0A HOST PORT AVAIL -- Not Expected
    3104   3174 0000681C 6892            		DC.W	HSTUNA			; 0B HOST UNACCEPTABLE
    3105   3175 0000681E 51DA            		DC.W	ISMGER			; 0C HOST COST -- Not Expected
    3106   3176 00006820 6828            		DC.W	SUPTAK			; 0D SUPERVISOR LOST
    3107   3177 00006822 51DA            		DC.W	ISMGER			; 0E 1-DOWN -- Not Expected
    3108   3178 00006824 51DA            		DC.W	ISMGER			; 0F REPORT ALL HOSTS -- Not ExpectedEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		I S I S   I N P U T           22-May-88  Page   71
Err Source Ref. Address   value
    line   line

    3109   3179 00006826 51DA            		DC.W	ISMGER			; 10 HOST STATUS -- Not Expected
    3110   3180                          	
    3111   3181                          	
    3112   3182                          	
    3113   3183                          	*	0.2 -- Takeover (or 0.D -- Sup. Lost)
    3114   3184 00006828 31FC FFFF 1060  	SUPTAK	MOVE.W	#-1,AUXX		; cancel outstanding AUX requests
    3115   3185 0000682E 11FC 0005 10A8  		MOVE.B	#5,DAT1			; type 5
    3116   3186 00006834 4238 10A9       		CLR.B	DAT2			; port 0
    3117   3187 00006838 6000 FA5E       		BRA	SENDDAT			; send DAT to PDP
    3118   3188                          	
    3119   3189                          	
    3120   3190                          	*	0.6 -- GMT report
    3121   3191 0000683C 11FC 0023 10A8  	IPTIME	MOVE.B	#$23,DAT1
    3122   3192 00006842 4238 10A9       		CLR.B	DAT2			; for port 0...
    3123   3193 00006846 6100 EC02       		BSR	GETCH			; skip padding
    3124   3194 0000684A 6100 EC40       		BSR	GETW
    3125   3195 0000684E 21C0 10AA       		MOVE.L	D0,DAT3			; save all bytes
    3126   3196 00006852 6100 EF4C       		BSR	WRDAT			; send to PDP
    3127   3197 00006856 2238 10AC       		MOVE.L	DAT5,D1			; get next word
    3128   3198 0000685A 4241            		CLR.W	D1			; pad it out with 0
    3129   3199 0000685C 6100 EF46       		BSR	WRPDP			; and send it too
    3130   3200 00006860 6000 FA3A       		BRA	CLEANUP			; then exit
    3131   3201                          	
    3132   3202                          	
    3133   3203                          	*	0.9 -- AUX circuit error
    3134   3204 00006864 6100 EBE4       	AUXERR	BSR	GETCH			; padding
    3135   3205 00006868 6100 EC0A       		BSR	GETH			; local key
    3136   3206 0000686C 31FC FFFF 1060  		MOVE.W	#-1,AUXX		; re-enable Aux circuits
    3137   3207 00006872 11FC 0017 10A8  		MOVE.B	#$17,DAT1		; type 23d
    3138   3208 00006878 11C0 10A9       		MOVE.B	D0,DAT2			; local key (port # - who made request)
    3139   3209 0000687C 6100 EBCC       		BSR	GETCH			; error code
    3140   3210 00006880 11C0 10AA       		MOVE.B	D0,DAT3
    3141   3211 00006884 6600 FA12       		BNE	SENDDAT			; send DAT (unless error=0)
    3142   3212 00006888 11FC 0007 10AA  		MOVE.B	#7,DAT3			; 0 -> 7
    3143   3213 0000688E 6000 FA08       		BRA	SENDDAT			; send DAT
    3144   3214                          	
    3145   3215                          	
    3146   3216                          	*	0.0B -- HOST UNACCEPTABLE
    3147   3217 00006892 6100 EBB6       	HSTUNA	BSR	GETCH			; IGNORE FOR NOW *****
    3148   3218 00006896 6100 EBDC       		BSR	GETH
    3149   3219 0000689A 6100 EBAE       		BSR	GETCH
    3150   3220 0000689E 6000 F9FC       		BRA	CLEANUP



    3152   3222                          		TTL	'E B U S  --  PDP-10 Base Code,		H O S T   S T A T U S'EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		H O S T   S T A T U S         22-May-88  Page   72
Err Source Ref. Address   value
    line   line

    3154   3224                          	*		V E R I F Y   H O S T ,   C H E C K   C O N S I S T A N C Y
    3155   3225                          	
    3156   3226                          	
    3157   3227 000068A2 4A38 108B       	VERIFY	TST.B	HTDWN			; is host up?
    3158   3228 000068A6 6704            		BEQ	HALFSEC			; yes
    3159   3229 000068A8 6100 F144       		BSR	HODOWN			; no, tel SUP Host is Down
    3160   3230                          	
    3161   3231                          	
    3162   3232                          	*	Half-second logic.  Check if Host is up
    3163   3233 000068AC 2078 103A       	HALFSEC	MOVE.L	.FASTC,A0
    3164   3234 000068B0 2010            		MOVE.L	(A0),D0
    3165   3235 000068B2 B0B8 10E8       		CMP.L	LFASTC,D0		; LFASTC specifies NEXT time to do it!
    3166   3236 000068B6 6D00 0088       		BLT.L	HALFSEX			; not time yet
    3167   3237 000068BA 0680 0000 012C  		ADD.L	#300,D0			; we do this every half-second
    3168   3238 000068C0 21C0 10E8       		MOVE.L	D0,LFASTC		; set time for NEXT test
    3169   3239 000068C4 4A38 108B       		TST.B	HTDWN			; check current state...
    3170   3240 000068C8 6630            		BNE	HDOWNR			; was down..go to host-down code
    3171   3241                          	
    3172   3242                          	*	Host is believed up...read key
    3173   3243                          	*	If good, just reset timeout
    3174   3244                          	*	Else if 0, timeout is in effect
    3175   3245                          	*	Else, crash for bad key
    3176   3246 000068CA 7408            	HUPR	MOVEQ	#8,D2			; try to get key eight times
    3177   3247 000068CC 6100 F196       	HUPR1	BSR	DOKEY			; verify Key usage
    3178   3248 000068D0 671E            		BEQ	HUPR2			; got match...all is OK
    3179   3249 000068D2 4A81            		TST.L	D1			; did we read 0?
    3180   3250 000068D4 6600 F0C4       		BNE	BADKEY
    3181   3251 000068D8 4A38 1042       		TST.B	P10DAH			; check high-bits
    3182   3252 000068DC 6600 F0BC       		BNE	BADKEY			; wasn't zero (from last try)
    3183   3253 000068E0 5302            		SUB.B	#1,D2			; try again?
    3184   3254 000068E2 6CE8            		BGE	HUPR1			; yes
    3185   3255 000068E4 5378 1052       		SUB.W	#1,TOHOST		; no...decrement current timeout
    3186   3256 000068E8 6C00 0056       		BGE.L	HALFSEX			; not yet
    3187   3257 000068EC 6000 F0A4       		BRA	NOKEY			; timeout expired...go crash host
    3188   3258                          	
    3189   3259 000068F0 31F8 1050 1052  	HUPR2	MOVE.W	HOSTTO,TOHOST		; reset timeout period
    3190   3260 000068F6 6000 0048       		BRA.L	HALFSEX			; ...and exit
    3191   3261                          	
    3192   3262                          	*	Host believed down...read key
    3193   3263                          	*	if good, get parameters, begin talking to host
    3194   3264 000068FA 6100 F168       	HDOWNR	BSR	DOKEY			; do the key-stuff
    3195   3265 000068FE 6600 0038       		BNE.L	MNGOOD			; skip if no good
    3196   3266 00006902 5278 10EC       		ADD.W	#1,LASCOU
    3197   3267 00006906 3438 10EC       		MOVE.W	LASCOU,D2
    3198   3268 0000690A 0C42 0004       		CMP.W	#4,D2
    3199   3269 0000690E 6D30            		BLT	HALFSEX			; wait 2 seconds before believe host
    3200   3270                          	
    3201   3271                          	
    3202   3272                          	*	Host has just come up...read PDP's Ring-parameters
    3203   3273 00006910 6100 ED0A       		BSR	RDPDPRPEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		H O S T   S T A T U S         22-May-88  Page   73
Err Source Ref. Address   value
    line   line

    3204   3274                          	
    3205   3275 00006914 31FC 0380 10A8  		MOVE.W	#$380+DEBUG,DAT1	; set "RESET INTERFACE"
    3206   3276 0000691A 31FC 0202 10AA  		MOVE.W	#VERSION,DAT3
    3207   3277 00006920 6100 EE7C       		BSR.L	WAITDAT			; and send it
    3208   3278 00006924 6100 EE78       		BSR.L	WAITDAT			;  ...twice...just in case
    3209   3279                          	
    3210   3280 00006928 4238 108B       		CLR.B	HTDWN			; 0 = host is up
    3211   3281 0000692C 31FC 0001 1052  		MOVE.W	#1,TOHOST		; cancel timeouts in progress
    3212   3282 00006932 31FC 0001 1050  		MOVE.W	#1,HOSTTO
    3213   3283                          	
    3214   3284 00006938 4278 10EC       	MNGOOD	CLR.W	LASCOU
    3215   3285 0000693C 6100 F18C       		BSR	EMPTY			; empty ISIS input ring
    3216   3286                          	
    3217   3287                          	HALFSEX	*				; exit to here...
    3218   3288                          	*					 ...and fall through to DOBKOUT



    3220   3290                          		TTL	'E B U S  --  PDP-10 Base Code,		B L O C K   O U T P U T'EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		B L O C K   O U T P U T       22-May-88  Page   74
Err Source Ref. Address   value
    line   line

    3222   3292                          	*		BLOCK OUTPUT
    3223   3293                          	
    3224   3294                          	*	BLOCK OUTPUT IS BEING DONE HERE
    3225   3295 00006940 4A38 108B       	DOBKOUT	TST.B	HTDWN			; quit if host down
    3226   3296 00006944 6600 F274       		BNE	EXEC
    3227   3297 00006948 3038 1100       		MOVE.W	BKOHEAD,D0		; any Block-output in progress?
    3228   3298 0000694C 6700 0092       		BEQ.L	INBKTIM			; no...just skip
    3229   3299                          	
    3230   3300 00006950 3040            	BOUT	MOVE.W	D0,A0			; unchain pointer
    3231   3301 00006952 31D8 1104       		MOVE.W	(A0)+,SAVE1		; get NEXT
    3232   3302 00006956 3010            		MOVE.W	(A0),D0			; fetch port number
    3233   3303 00006958 6100 F0DE       		BSR	SETPORT			; set up port
    3234   3304 0000695C 082C 0002 0001  		BTST	#PF_OBP,P_FLAGS(Rp)	; check output back-pressure
    3235   3305 00006962 6674            		BNE	BOUTX			; set...don't output this time
    3236   3306 00006964 4241            		CLR.W	D1			; no back-pressure...set up to transmit
    3237   3307 00006966 122C 0002       		MOVE.B	XMITLMT(Rp),D1		; extract transmit-limit
    3238   3308 0000696A 302C 000A       		MOVE.W	BO_TCN(Rp),D0		; number of characters left
    3239   3309 0000696E B041            		CMP.W	D1,D0			; more than we can send?
    3240   3310 00006970 6F02            		BLE	BOUT1			; no
    3241   3311 00006972 3001            		MOVE.W	D1,D0			; yes...use limit instead
    3242   3312 00006974 3800            	BOUT1	MOVE.W	D0,D4			; count = message-type
    3243   3313 00006976 5640            		ADD.W	#3,D0			; ...and this is how much space we'll need
    3244   3314 00006978 6100 E9C6       		BSR	ROOM
    3245   3315 0000697C 665A            		BNE	BOUTX			; quit if not enough room in ring
    3246   3316 0000697E 3638 10A0       		MOVE.W	PORTNO,D3		; port number
    3247   3317 00006982 6100 E9F4       		BSR	SLOR
    3248   3318 00006986 362C 0008       		MOVE.W	BO_BYT(Rp),D3		; byte position
    3249   3319 0000698A 47F8 10A8       		LEA	DAT,A3			; compute address within DAT
    3250   3320 0000698E D6C3            		ADD.W	D3,A3
    3251   3321                          	
    3252   3322 00006990 6100 EC42       	BOUT2	BSR	RDBLK			; get another word of input
    3253   3323 00006994 101B            	BOUT3	MOVE.B	(A3)+,D0		; move another byte
    3254   3324 00006996 5243            		ADD.W	#1,D3			; advance cursor
    3255   3325 00006998 536C 000A       		SUB.W	#1,BO_TCN(Rp)		; number of characters left
    3256   3326 0000699C 6100 E9FA       		BSR	PUTCH
    3257   3327 000069A0 5344            		SUB.W	#1,D4			; done yet?
    3258   3328 000069A2 670E            		BEQ	BOUT4			; yes...clean up and quit
    3259   3329 000069A4 B6FC 10AC       		CMPA.W	#DAT5,A3		; is word exhausted?
    3260   3330 000069A8 66EA            		BNE	BOUT3			; not yet
    3261   3331 000069AA 47F8 10A8       		LEA	DAT1,A3			; pointer to initial byte
    3262   3332 000069AE 4243            		CLR.W	D3			; start at byte 0 again
    3263   3333 000069B0 60DE            		BRA	BOUT2
    3264   3334                          	
    3265   3335 000069B2 6100 EA42       	BOUT4	BSR	ELOR			; done...send it on it's way
    3266   3336 000069B6 426C 0008       		CLR.W	BO_BYT(Rp)		; assume next byte is byte 0
    3267   3337 000069BA 0C43 0004       		CMP.W	#4,D3			; is current word exhausted?
    3268   3338 000069BE 6C08            		BGE	BOUT5			; yes
    3269   3339 000069C0 53AC 0004       		SUB.L	#1,BO_TAR(Rp)		; no...back up pointer to read again
    3270   3340 000069C4 3943 0008       		MOVE.W	D3,BO_BYT(Rp)		; save position of next byte
    3271   3341 000069C8 4A6C 000A       	BOUT5	TST.W	BO_TCN(Rp)		; total number left..Done?EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		B L O C K   O U T P U T       22-May-88  Page   75
Err Source Ref. Address   value
    line   line

    3272   3342 000069CC 660A            		BNE	BOUTX			; no
    3273   3343 000069CE 11FC 0025 10A8  		MOVE.B	#$25,DAT1		; yes...report Bout done
    3274   3344 000069D4 6100 F84C       		BSR	BKOTERM			; terminate block-output
    3275   3345                          	
    3276   3346 000069D8 3038 1104       	BOUTX	MOVE.W	SAVE1,D0		; any more ports?
    3277   3347 000069DC 6600 FF72       		BNE	BOUT			; yes...service another
    3278   3348                          	*	...and fall through to INBKTIM



    3280   3350                          		TTL	'E B U S  --  PDP-10 Base Code,		C O D E'EBUS02.JMS                 E B U S  --  PDP-10 Base Code,		C O D E                       22-May-88  Page   76
Err Source Ref. Address   value
    line   line

    3282   3352                          	*		CHECK BLOCK INPUT TIMEOUT
    3283   3353                          	
    3284   3354                          	*	Check to see if 16-seconds has elapsed since last Block-in Data
    3285   3355 000069E0 3038 10FE       	INBKTIM	MOVE.W	BKIHEAD,D0		; anything to do?
    3286   3356 000069E4 6760            		BEQ	FL_BUF			; no...skip to service buffers
    3287   3357 000069E6 3040            	IBM	MOVE.W	D0,A0			; chain down list
    3288   3358 000069E8 31D8 1104       		MOVE.W	(A0)+,SAVE1		; save NEXT
    3289   3359 000069EC 3010            		MOVE.W	(A0),D0			; get port-number
    3290   3360 000069EE 6100 F048       		BSR	SETPORT
    3291   3361 000069F2 2078 103A       		MOVE.L	.FASTC,A0
    3292   3362 000069F6 2010            		MOVE.L	(A0),D0
    3293   3363 000069F8 90AC 000C       		SUB.L	BI_TIM(Rp),D0		; compute time elapsed since last input
    3294   3364 000069FC 0C80 0000 2580  		CMP.L	#9600,D0		; has it exceeded 16 seconds?
    3295   3365 00006A02 6D12            		BLT	IBK1			; no
    3296   3366 00006A04 082C 0007 0001  		BTST	#PF_BFD,P_FLAGS(Rp)	; set Block FilleD
    3297   3367 00006A0A 660A            		BNE	IBK1			; already was set
    3298   3368 00006A0C 11FC 0029 10A8  		MOVE.B	#$29,DAT1		; not set previously...
    3299   3369 00006A12 6100 F842       		BSR	BKITERM			; terminate Block-input
    3300   3370                          	
    3301   3371 00006A16 3038 1104       	IBK1	MOVE.W	SAVE1,D0
    3302   3372 00006A1A 66CA            		BNE	IBM
    3303   3373                          	
    3304   3374                          	
    3305   3375                          	*	Routine to put data from buffer to Host block
    3306   3376 00006A1C 3038 10FE       		MOVE.W	BKIHEAD,D0		; check block-input head
    3307   3377 00006A20 6724            		BEQ	FL_BUF			; nothing to do here
    3308   3378 00006A22 3040            	BBLNK	MOVE.W	D0,A0			; address of next entry
    3309   3379 00006A24 31D8 1104       		MOVE.W	(A0)+,SAVE1		; save NEXT of this block
    3310   3380 00006A28 3010            		MOVE.W	(A0),D0			; port number
    3311   3381 00006A2A 6100 F00C       		BSR	SETPORT			; set up port
    3312   3382 00006A2E 082C 0007 0001  		BTST	#PF_BFD,P_FLAGS(Rp)	; was Block FilleD?
    3313   3383 00006A34 660A            		BNE	MAD20			; yes
    3314   3384 00006A36 4A6C 001E       		TST.W	BCT(Rp)			; no...any of chars in buffer?
    3315   3385 00006A3A 6704            		BEQ	MAD20			; no
    3316   3386 00006A3C 6100 0112       		BSR.L	BU_BK			; yes...proceed to move to block
    3317   3387                          	
    3318   3388 00006A40 3038 1104       	MAD20	MOVE.W	SAVE1,D0		; done...is list exhausted?
    3319   3389 00006A44 66DC            		BNE	BBLNK			; no...do another
    3320   3390                          	*					  ...then fall through to next test
    3321   3391                          	
    3322   3392                          	*	Try to flush buffers to PDP's input-ring
    3323   3393 00006A46 3038 1102       	FL_BUF	MOVE.W	BUFHEAD,D0		; anything to do?
    3324   3394 00006A4A 6700 F16E       		BEQ	EXEC			; no...back to beginning of EXEC loop
    3325   3395 00006A4E 3040            	FL_BUF1	MOVE.W	D0,A0			; chain down list
    3326   3396 00006A50 31D8 1104       		MOVE.W	(A0)+,SAVE1		; save NEXT
    3327   3397 00006A54 3010            		MOVE.W	(A0),D0			; get port-number
    3328   3398 00006A56 6100 EFE0       		BSR	SETPORT
    3329   3399 00006A5A 6114            		BSR	BU_RG			; try to flush some stuff
    3330   3400 00006A5C 4A6C 001E       		TST.W	BCT(Rp)			; is buffer now empty?
    3331   3401 00006A60 6604            		BNE	FL_BUF2			; noEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		C O D E                       22-May-88  Page   77
Err Source Ref. Address   value
    line   line

    3332   3402 00006A62 6100 F756       		BSR	RBTBUF			; yes...remove buffer from list
    3333   3403                          	
    3334   3404 00006A66 3038 1104       	FL_BUF2	MOVE.W	SAVE1,D0		; any more in list?
    3335   3405 00006A6A 66E2            		BNE	FL_BUF1			; proceed if more to do
    3336   3406 00006A6C 6000 F14C       		BRA	EXEC			; done...back to start of EXEC loop
    3337   3407                          	
    3338   3408                          	
    3339   3409                          	*	Copy data from BUffer to PDP's input RinG for this port
    3340   3410 00006A70 4A6C 001E       	BU_RG	TST.W	BCT(Rp)			; anything in buffer?
    3341   3411 00006A74 6700 00AC       		BEQ.L	BU_EMP			; no, empty...quit
    3342   3412 00006A78 082C 0004 0001  		BTST	#PF_HBP,P_FLAGS(Rp)	; has PDP applied back-pressure?
    3343   3413 00006A7E 6600 00B6       		BNE.L	BU_XIT			; yes...quit this time around
    3344   3414 00006A82 31FC 001E 109E  		MOVE.W	#30,INTYBT		; no...pretend we're doing data
    3345   3415 00006A88 6100 ED7C       		BSR	FDRGSZ			; find space available
    3346   3416 00006A8C 5578 109C       		SUB.W	#2,INRGSP		; allow for header
    3347   3417 00006A90 6F00 00A4       		BLE.L	BU_XIT			; ...but quit if no room
    3348   3418 00006A94 0C78 001E 109C  		CMP.W	#30,INRGSP
    3349   3419 00006A9A 6F06            		BLE	BU_RG1
    3350   3420 00006A9C 31FC 001E 109C  		MOVE.W	#30,INRGSP		; don't send more than 30 bytes of data
    3351   3421 00006AA2 11F8 10A1 10A9  	BU_RG1	MOVE.B	PORTNO+1,DAT2
    3352   3422 00006AA8 4243            		CLR.W	D3			; clear data-counter
    3353   3423 00006AAA 4278 109E       		CLR.W	INTYBT			; used to record escaped chars
    3354   3424 00006AAE 47F8 10AA       		LEA	DAT3,A3			; place to (begin to) put data
    3355   3425 00006AB2 4A6C 001E       	BU_RG2	TST.W	BCT(Rp)			; anything left?
    3356   3426 00006AB6 672C            		BEQ	BU_RG4			; skip if no more
    3357   3427 00006AB8 6100 ED9C       		BSR	DGCI			; else get the data
    3358   3428 00006ABC 0C00 001B       		CMP.B	#ESC,D0			; see if escape
    3359   3429 00006AC0 6618            		BNE	BU_RG3			; skip if data
    3360   3430 00006AC2 4A6C 001E       		TST.W	BCT(Rp)			; still data left?
    3361   3431 00006AC6 6700 E726       		BEQ	BAD_ESC			; crash if none
    3362   3432 00006ACA 6100 ED8A       		BSR	DGCI			; else get it
    3363   3433 00006ACE 0C00 001B       		CMP.B	#ESC,D0			; see if escaped data
    3364   3434 00006AD2 6706            		BEQ	BU_RG3			; skip if so
    3365   3435 00006AD4 31C0 109E       		MOVE.W	D0,INTYBT		; else record it
    3366   3436 00006AD8 600A            		BRA	BU_RG4			; and skip
    3367   3437                          	
    3368   3438 00006ADA 16C0            	BU_RG3	MOVE.B	D0,(A3)+		; save in temp area
    3369   3439 00006ADC 5243            		ADD.W	#1,D3			; increment data-counter
    3370   3440 00006ADE B678 109C       		CMP.W	INRGSP,D3		; see if that's all that fits
    3371   3441 00006AE2 66CE            		BNE	BU_RG2			; continue if not
    3372   3442                          	
    3373   3443 00006AE4 11C3 10A8       	BU_RG4	MOVE.B	D3,DAT1			; save data-count
    3374   3444 00006AE8 671A            		BEQ	BU_COD			; skip if no data found
    3375   3445 00006AEA 0038 0080 10A8  		OR.B	#$80,DAT1		; make host data-MSG type
    3376   3446 00006AF0 5443            		ADD.W	#2,D3
    3377   3447 00006AF2 47F8 10A8       		LEA	DAT,A3
    3378   3448 00006AF6 221B            	BU_RG5	MOVE.L	(A3)+,D1		; move data to host-ring
    3379   3449 00006AF8 6100 ECAA       		BSR	WRPDP			; send it (no need to wait)
    3380   3450 00006AFC 5943            		SUB.W	#4,D3
    3381   3451 00006AFE 6EF6            		BGT	BU_RG5			; send it all
    3382   3452 00006B00 6100 ECD6       		BSR	PUTIFC			; make sure host sees itEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		C O D E                       22-May-88  Page   78
Err Source Ref. Address   value
    line   line

    3383   3453                          	
    3384   3454 00006B04 4A78 109E       	BU_COD	TST.W	INTYBT			; see if terminated by escaped char
    3385   3455 00006B08 6712            		BEQ	BU_RGX			; we're done if not
    3386   3456 00006B0A 6100 FBAC       		BSR	LOOKUP			; else go translate it
    3387   3457 00006B0E 11F8 10A1 10A9  		MOVE.B	PORTNO+1,DAT2		; install port #
    3388   3458 00006B14 6100 EC88       		BSR	WAITDAT			; wait, then write DAT into host
    3389   3459 00006B18 6100 ECBE       		BSR	PUTIFC			; make sure host sees it
    3390   3460                          	
    3391   3461 00006B1C 4A6C 001E       	BU_RGX	TST.W	BCT(Rp)			; is buffer now empty?
    3392   3462 00006B20 6614            		BNE	BU_XIT			; no
    3393   3463                          	
    3394   3464 00006B22 08AC 0003 0001  	BU_EMP	BCLR	#PF_IBP,P_FLAGS(Rp)	; clear back-pressure
    3395   3465 00006B28 670C            		BEQ	BU_XIT			; wasn't set
    3396   3466 00006B2A 3638 10A0       		MOVE.W	PORTNO,D3		; was set, must clear...for port,
    3397   3467 00006B2E 183C 00A1       		MOVE.B	#$A1,D4			; release back-pressure
    3398   3468 00006B32 6100 E8BC       		BSR	SENDQI			; send Quick ISIS message
    3399   3469                          	
    3400   3470 00006B36 4E75            	BU_XIT	RTS				; return
    3401   3471                          	
    3402   3472                          	
    3403   3473                          	*	Put the current port onto the buffer-list
    3404   3474 00006B38 3078 10FC       	BU_ADD	MOVE.W	BLKFREE,A0		; get an entry off free-list
    3405   3475 00006B3C 31D0 10FC       		MOVE.W	(A0),BLKFREE		; unlink from free-list
    3406   3476 00006B40 30B8 1102       		MOVE.W	BUFHEAD,(A0)		; link list-head to element
    3407   3477 00006B44 3178 10A0 0002  		MOVE.W	PORTNO,2(A0)		; second word is port-number
    3408   3478 00006B4A 31C8 1102       		MOVE.W	A0,BUFHEAD		; place this element as new list-head
    3409   3479 00006B4E 4E75            		RTS				; done...return
    3410   3480                          	
    3411   3481                          	
    3412   3482                          	*	Copy from Buffer to Block:  If terminated by Block-full
    3413   3483                          	*	or Yellow-Ball (EOT), then report termination;  if by EOT, then
    3414   3484                          	*	report Yellow-ball also.
    3415   3485 00006B50 382C 0014       	BU_BK	MOVE.W	BI_TCN(Rp),D4		; copy of # of chars expected
    3416   3486 00006B54 6100 EC28       		BSR	GETBLK			; get the current word
    3417   3487 00006B58 366C 0018       		MOVE.W	BI_BYT(Rp),A3		; cursor within DAT
    3418   3488 00006B5C 47EB 10A8       		LEA	DAT(A3),A3		; address of current byte
    3419   3489 00006B60 4278 109E       		CLR.W	INTYBT			; used to record control-codes
    3420   3490                          	
    3421   3491                          	*	Copy until buffer-empty, block-full, or found control-code
    3422   3492 00006B64 4A6C 001E       	BU_BK1	TST.W	BCT(Rp)			; anything there?
    3423   3493 00006B68 673E            		BEQ	BU_BK3			; no, buffer empty...skip
    3424   3494 00006B6A B86C 0016       		CMP.W	BI_LCN(Rp),D4		; block full?
    3425   3495 00006B6E 6738            		BEQ	BU_BK3			; no...skip
    3426   3496 00006B70 6100 ECE4       		BSR	DGCI			; get the char
    3427   3497 00006B74 0C00 001B       		CMP.B	#ESC,D0			; ESC?
    3428   3498 00006B78 6618            		BNE	BU_BK2			; no..skip to place the data
    3429   3499 00006B7A 4A6C 001E       		TST.W	BCT(Rp)			; yes...anything else there?
    3430   3500 00006B7E 6700 E66E       		BEQ	BAD_ESC			; no, buffer now empty...fatal error
    3431   3501 00006B82 6100 ECD2       		BSR	DGCI			; get the code
    3432   3502 00006B86 0C00 001B       		CMP.B	#ESC,D0			; ESC?
    3433   3503 00006B8A 6706            		BEQ	BU_BK2			; yes, data...skip to place it in blockEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		C O D E                       22-May-88  Page   79
Err Source Ref. Address   value
    line   line

    3434   3504 00006B8C 31C0 109E       		MOVE.W	D0,INTYBT		; no...save as termination-code
    3435   3505 00006B90 6016            		BRA	BU_BK3			; and skip to terminate copy
    3436   3506                          	
    3437   3507 00006B92 16C0            	BU_BK2	MOVE.B	D0,(A3)+		; save data char
    3438   3508 00006B94 526C 0016       		ADD.W	#1,BI_LCN(Rp)		; count it
    3439   3509 00006B98 B6FC 10AC       		CMPA.W	#DAT5,A3		; have we exhausted DAT?
    3440   3510 00006B9C 6DC6            		BLT	BU_BK1			; no
    3441   3511 00006B9E 6100 EBB6       		BSR	WRBLK			; yes
    3442   3512 00006BA2 47F8 10A8       		LEA	DAT,A3			; reset word cursor
    3443   3513 00006BA6 60BC            		BRA	BU_BK1
    3444   3514                          	
    3445   3515                          	*	done with copy (for this pass)
    3446   3516 00006BA8 96FC 10A8       	BU_BK3	SUB.W	#DAT,A3			; compute displacement
    3447   3517 00006BAC 394B 0018       		MOVE.W	A3,BI_BYT(Rp)		; save it for next time
    3448   3518 00006BB0 6708            		BEQ	BU_BK4			; at beginning of word?
    3449   3519 00006BB2 6100 EBA2       		BSR	WRBLK			; no...write partial word into PDP
    3450   3520 00006BB6 53AC 0010       		SUB.L	#1,BI_TAR(Rp)		; back up word-cursor
    3451   3521 00006BBA 11FC 0027 10A8  	BU_BK4	MOVE.B	#$27,DAT1		; assume terminated by FULL
    3452   3522 00006BC0 B86C 0016       		CMP.W	BI_LCN(Rp),D4
    3453   3523 00006BC4 6724            		BEQ	BU_BK5			; skip if that's reason
    3454   3524 00006BC6 5238 10A8       		ADD.B	#1,DAT1			; no...assume terminated by EOT
    3455   3525 00006BCA 0C78 00AC 109E  		CMP.W	#YB_CODE,INTYBT		; see if Yellow-ball found
    3456   3526 00006BD0 6718            		BEQ	BU_BK5			; skip if so
    3457   3527 00006BD2 2478 103A       		MOVE.L	.FASTC,A2		; else record current time
    3458   3528 00006BD6 2952 000C       		MOVE.L	(A2),BI_TIM(Rp)
    3459   3529 00006BDA 4A78 109E       		TST.W	INTYBT			; terminated by stream-code?
    3460   3530 00006BDE 6700 FF3C       		BEQ	BU_RGX			; no...just exit (but check for BP)
    3461   3531 00006BE2 6100 FF20       		BSR	BU_COD			; yes...send it to host
    3462   3532 00006BE6 6000 FF68       		BRA	BU_BK			; then continue copying
    3463   3533                          	
    3464   3534                          	*	Block-input terminated
    3465   3535 00006BEA 6100 F66A       	BU_BK5	BSR	BKITERM			; terminate block-input
    3466   3536 00006BEE 6000 FF14       		BRA	BU_COD			; send code if encountered, and exitEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		C O D E                       22-May-88  Page   80
Err Source Ref. Address   value
    line   line

    3468   3538                          	
    3469   3539                          	
    3470   3540                          	
    3471   3541                          		ORG	$7C00
    3472   3542                          	
    3473   3543                          	*	D0 is the high order 32 bits to write to pdp-10
    3474   3544                          	*	D1 last 4 bits are the low order 4 bits to write to 10
    3475   3545                          	*	D2 is the start addr of the test
    3476   3546                          	*	D3 is the ending addr of the test
    3477   3547                          	*	D4 is the counter of mismatch between read and write
    3478   3548                          	*	D5 is the high order 32 bits read from 10's memory
    3479   3549                          	*	D6 last 4 bits are the low order 4 bits read from 10
    3480   3550                          	
    3481   3551 00007C00 4A79 00D0 1038  	STARTES	TST.W	DEXCO			; Reset EBUS
    3482   3552 00007C06 4238 10DE       		CLR.B	BLK
    3483   3553 00007C0A 4284            		CLR.L	D4			; Initialize the mismatch counter
    3484   3554 00007C0C                 	STATE12	PUSHM	D0-D4
    3485   3556 00007C10 31C2 1048       		MOVE.W	D2,P10ADR		; move in addr(only half-word long)
    3486   3557 00007C14 21C0 1042       		MOVE.L	D0,P10DAH		; first 32 bits of data
    3487   3558 00007C18 0201 000F       		AND.B	#$0F,D1			; only need last 4 bits
    3488   3559 00007C1C 11C1 1046       		MOVE.B	D1,P10DLL		; last 4 bits of data
    3489   3560 00007C20 6100 DA6A       		BSR	WR10R			; write it to 10. memory
    3490   3561 00007C24 42B8 1042       		CLR.L	P10DAH			; clear out read area
    3491   3562 00007C28 4238 1046       		CLR.B	P10DLL
    3492   3563 00007C2C 6100 D896       		BSR	RD10R			; read it back from 10's memory
    3493   3564 00007C30                 		POPM	D0-D4
    3494   3566 00007C34 4285            		CLR.L	D5
    3495   3567 00007C36 4286            		CLR.L	D6
    3496   3568 00007C38 2A38 1042       		MOVE.L	P10DAH,D5		; first 32 bits read rom 10
    3497   3569 00007C3C 1C38 1046       		MOVE.B	P10DLL,D6
    3498   3570 00007C40 0201 000F       		AND.B	#$0F,D1
    3499   3571 00007C44 B085            		CMP.L	D5,D0
    3500   3572 00007C46 6608            		BNE	SUB7			; go mismatch routine
    3501   3573 00007C48 B206            		CMP.B	D6,D1
    3502   3574 00007C4A 6604            		BNE	SUB7			; go mismatch routine if not =
    3503   3575 00007C4C 4287            		CLR.L	D7			; no mismatch add 0 to counter(d4)
    3504   3576 00007C4E 6002            		BRA	NO77
    3505   3577                          	
    3506   3578 00007C50 7E01            	SUB7	MOVE.L	#1,D7			; add 1 to counter D4 on mismatch
    3507   3579 00007C52 D887            	NO77	ADD.L	D7,D4			; add to mismatch counter
    3508   3580 00007C54 5242            		ADD.W	#1,D2			; bump to next addr in 10 memory
    3509   3581 00007C56 B682            		CMP.L	D2,D3			; if biggert than end addr
    3510   3582 00007C58 6CB2            		BGE	STATE12			; no go another loop
    3511   3583 00007C5A 2249            	NOMLOP	MOVE.L	A1,A1
    3512   3584 00007C5C 60FC            		BRA	NOMLOP			; just dummy loopEBUS02.JMS                 E B U S  --  PDP-10 Base Code,		C O D E                       22-May-88  Page   81
Err Source Ref. Address   value
    line   line

    3514   3586                          	*	Special diagnostics for manual operation and testing
    3515   3587                          	
    3516   3588                          	
    3517   3589                          	
    3518   3590                          	
    3519   3591                          		ORG	$7D00
    3520   3592 00007D00 31C2 1048       	CONWRT	MOVE.W	D2,P10ADR
    3521   3593 00007D04 11FC 0001 1108  		MOVE.B	#1,DIAG			; set DIAG > 0
    3522   3594 00007D0A 21C0 1042       		MOVE.L	D0,P10DAH
    3523   3595 00007D0E 0201 000F       		AND.B	#$0F,D1
    3524   3596 00007D12 11C1 1046       		MOVE.B	D1,P10DLL
    3525   3597 00007D16 4A79 00D0 1038  	WRTERR	TST.W	DEXCO			; Reset EBUS
    3526   3598 00007D1C 6100 D96E       		BSR	WR10R
    3527   3599 00007D20 3A3C 0064       		MOVE.W	#100,D5
    3528   3600 00007D24 5345            	WRERL	SUB.W	#1,D5
    3529   3601 00007D26 66FC            		BNE	WRERL
    3530   3602 00007D28 60EC            		BRA	WRTERR
    3531   3603                          	
    3532   3604                          	
    3533   3605                          	
    3534   3606                          	
    3535   3607                          	
    3536   3608                          		ORG	$7E00
    3537   3609 00007E00 11FC 00FF 1108  		MOVE.B	#-1,DIAG		; set DIAG < 0
    3538   3610 00007E06 31C2 1048       		MOVE.W	D2,P10ADR
    3539   3611 00007E0A 4A79 00D0 1038  	REDERR	TST.W	DEXCO			; Reset EBUS
    3540   3612 00007E10 6100 D6B2       		BSR	RD10R
    3541   3613 00007E14 3A3C 0064       		MOVE.W	#100,D5
    3542   3614 00007E18 5345            	RELOP	SUB.W	#1,D5
    3543   3615 00007E1A 66FC            		BNE	RELOP
    3544   3616 00007E1C 60EC            		BRA	REDERR
    3545   3617                          	
    3546   3618                          	
    3547   3619                          	*	Return here on diagnostic error
    3548   3620 00007E1E 4A38 1108       	DIAGERR	TST.B	DIAG			; which diagnostic are we doing?
    3549   3621 00007E22 6DE6            		BLT	REDERR			; < 0...read diagnostic
    3550   3622 00007E24 6000 FEF0       		BRA	WRTERR			; > 0...write diagnostic
    3551   3623                          	
    3552   3624                          	
    3553   3625                          		TTL	'E B U S  --  PDP-10 Base Code'
    3554   3626 00007E28                 		END	ENTRYEBUS02.JMS                 E B U S  --  PDP-10 Base Code                                 22-May-88  Page   82

                               Symbol Table

 ADRERR      00005216   AUXC        00001062   AUXERR      00006864   AUXKEY      00000003   AUXQ        0000105A
 AUXTIM      0000105C   AUXX        00001060   BADKEY      0000599A   BAD_ESC     000051EE   BB          0000001A
 BBLNK       00006A22   BCRASH      000051A2   BCRASH1     000051B8   BCRASH2     000051C2   BCT         0000001E
 BE          0000001C   BFLSIZ      00000010   BI_BYT      00000018   BI_LCN      00000016   BI_TAR      00000010
 BI_TCN      00000014   BI_TIM      0000000C   BKIHEAD     000010FE   BKITERM     00006256   BKOHEAD     00001100
 BKOTERM     00006222   BKPR        000010EE   BLACK       00006678   BLK         000010DE   BLKFREE     000010FC
 BLKK1       000056C2   BLKK2       000054E4   BLKMAP      000050EC   BLOKIN      00006390   BOBCODE     00004F2E
 BOK1        00006138   BOK2        000061C0   BOK22       000061E0   BOK3        00006216   BOK4        00006236
 BOK5        00006276   BOUT        00006950   BOUT1       00006974   BOUT2       00006990   BOUT3       00006994
 BOUT4       000069B2   BOUT5       000069C8   BOUTX       000069D8   BO_BYT      00000008   BO_TAR      00000004
 BO_TCN      0000000A   BPOFF       00006658   BPON        00006650   BTRACE      00000000   BUFER       00008000
 BUFEREND    0000F000   BUFHEAD     00001102   BUSCRAS     000059C0   BUSERR      00005206   BU_ADD      00006B38
 BU_BK       00006B50   BU_BK1      00006B64   BU_BK2      00006B92   BU_BK3      00006BA8   BU_BK4      00006BBA
 BU_BK5      00006BEA   BU_COD      00006B04   BU_EMP      00006B22   BU_RG       00006A70   BU_RG1      00006AA2
 BU_RG2      00006AB2   BU_RG3      00006ADA   BU_RG4      00006AE4   BU_RG5      00006AF6   BU_RGX      00006B1C
 BU_XIT      00006B36   C1          0000598E   CARRTS      00005850   CARWRAP     00005822   CASHW       0000100C
 CCTBD       0000390A   CLEANUP     0000629C   CODCASH     00001004   CONWRT      00007D00   CTRACE      00000000
 DAT         000010A8   DAT1        000010A8   DAT2        000010A9   DAT3        000010AA   DAT4        000010AB
 DAT5        000010AC   DEBUG       00000000   DEMPTY      00005962   DEXC1       00D010B8   DEXCO       00D01038
 DGCI        00005856   DGCI1       0000588C   DGCI2       0000588E   DGCIH       000051F6   DIAG        00001108
 DIAGERR     00007E1E   DOBKOUT     00006940   DOKEY       00005A64   DOKEYX      00005A86   DPEEK       000058A2
 DPEEK1      000058D2   DPEEK2      000058D6   DPEEKX      000058E2   DPER        00D00138   DPORT       00005B76
 DPORT1      00005B88   DSENS       00D000B8   DTMOT       00D001B8   DWCI        000058E4   DWCI2       0000590A
 DWCI3       00005916   DWCI4       0000592E   DWCI5       0000593C   DWCIH       000051FE   ECHOFF      00005FF0
 ECHOON      00005FE8   ELIR        000054AE   ELIR2       000054BE   ELOR        000053F6   ELOR21      00005404
 EMP1        00005AD2   EMP2        00005AFA   EMP3        00005B08   EMP4        00005B0C   EMP5        00005B12
 EMP6        00005B20   EMPTY       00005ACA   ENDMEM      0003FFE0   ENDZERO     0000390A   ENGINE      FFFFF901
 ENGVECT     0000013C   ENTRY       00004F00   ENTRY1      00004F0E   ENTRY2      00004F1A   ESC         0000001B
 ESPACE      00E00000   ETRACE      0003FFE0   EVENBON     0000545A   EXEC        00005BBA   EXEC1       00005BCC
 EXEC2       00005BD6   EXEC3       00005BDA   EXEC4       00005BE2   FDRGSZ      00005806   FFCRA       00004F64
 FFCRA1      00004F88   FLUSH       000054A4   FL_BUF      00006A46   FL_BUF1     00006A4E   FL_BUF2     00006A66
 FREEBLK     0000110A   GEHTLN      00005CD2   GETBLK      0000577E   GETCH       0000544A   GETCH1      00005472
 GETH        00005474   GETH1       0000548A   GETIEC      000055FC   GETIOWA     00004F9C   GETIOWB     00004FB2
 GETOFC      0000560C   GETPDPL     00005570   GETPDPR     00005582   GETUN       0000647A   GETW        0000548C
 GETW1       000054A2   GOBBLER     00006660   GRAY        00006672   HALFSEC     000068AC   HALFSEX     00006940
 HCRASH      000056F4   HDN1        00005A0A   HDN2        00005A1C   HDN3        00005A2E   HDN4        00005A36
 HDNMSG      00006590   HDOWN       000059F4   HDOWNR      000068FA   HODOWN      000059EE   HOSTN       0000104A
 HOSTOUT     00005C06   HOSTP       0000104C   HOSTTO      00001050   HOUT1       00005C6A   HOUT2       00005C7A
 HOUT3       00005C88   HOUTX       00005C8C   HREPRT      00005A88   HREPRTX     00005AC8   HSHMSG      0000659E
 HST1        00005DC2   HST2        00005DCA   HSTAT       0000104E   HSTSAD      00005FB0   HSTUNA      00006892
 HTDWN       0000108B   HTM         000010E4   HUPR        000068CA   HUPR1       000068CC   HUPR2       000068F0
 HVERNO      00001054   IBK1        00006A16   IBM         000069E6   IBRATE      00000003   ILLINS      0000520E
 ILOG        0000676C   IMESS       000065AC   IMSSZ       00005B2C   IMSTAB      000065F6   INBKTIM     000069E0
 INISLN      000067F4   INIT0       0000500C   INIT1       00005086   INIT2       000050A2   INITIAL     00005000
 INRGSP      0000109C   INTRPT      00004F56   INTYBT      0000109E   IPAIOW      00000004   IPANMA      00000001
 IPASI       00000006   IPCRSH      00000003   IPDLOK      00000002   IPORT       00005B5E   IPORT1      00005B6C
 IPORT2      00005B6E   IPTIME      0000683C   IPZ         000067D8   IPZSZ       00005B50   IPZTAB      00006806
 IRING       00001032   IRRN        000010F0   IRSIZE      0000103E   ISISIN      000062A0   ISISIN1     00006306
 ISISIN2     0000630C   ISISIN3     00006320   ISISIN4     00006332   ISMGER      000051DA   ISP         000066B2
 ISPTAB      000066CA   ISTOME      00001012   IS_BK       00006398   IS_BK1      000063A8   IS_BK2      000063D2
 IS_BK3      000063E4   IS_BK4      000063F6   IS_BU       00006352   IS_BU1      00006374   IS_BU2      00006386
 IS_BUF      00006348   ITERM       000066DA   ITRACE      00000001   LASCOU      000010EC   LFASTC      000010E8EBUS02.JMS                 E B U S  --  PDP-10 Base Code                                 22-May-88  Page   83

 LNKEND      000061AA   LNKLOP      0000618E   LOGFAL      00006740   LOGFAL1     00006748   LOOK        00005426
 LOOKUP      000066B8   MAD20       00006A40   MAXPORT     00000100   MEMDMP      00005186   MEMDMP1     00005196
 MERROR      000059A2   METOIS      00001016   METOSL      0000101E   MNGOOD      00006938   MXPORT      00001056
 NARG        00000000   NBFLTS      000010F8   NCCT        000010DC   NEE1        0000652E   NEE2        00006558
 NEE3        0000655E   NEE4        00006572   NEEDLE      0000640C   NEEDLE1     000064A6   NO77        00007C52
 NOCAL       00005CE0   NOCAL5      00005CE4   NODALN      00005842   NOIRING     00005448   NOJAP       000066E4
 NOJAP1      0000603A   NOJAP2      000060BC   NOKEY       00005992   NOMLOP      00007C5A   NORHOST     000010A4
 NORNODE     000010A2   NORPORT     000010A6   NPORTS      00001058   NSIZ        000010DD   ODDBON      00005460
 OFFBP       00005E22   OMTAB       00005D36   ONBP        00005E0C   OOPMSG      0000657A   OPEN        00005D9E
 OPSHT       00005DA4   ORING       0000102E   ORRN        000010F2   ORSIZE      00001040   OTFRHST     00005D20
 P10ADR      00001048   P10DAH      00001042   P10DAL      00001044   P10DLL      00001046   PARERR      000059B8
 PATCHR      00004000   PCCASH      00001008   PDPIEC      00001098   PDPIFC      0000109A   PDPIRP      00001094
 PDPISZ      00001096   PDPOEC      00001092   PDPOFC      00001090   PDPORP      0000108C   PDPOSZ      0000108E
 PD_SIZ      00000020   PFULL       00001107   PFULL1      00006722   PF_ACT      00000000   PF_BFD      00000007
 PF_BKI      00000006   PF_BKO      00000005   PF_HBP      00000004   PF_IBP      00000003   PF_ILI      00000001
 PF_OBP      00000002   PNEDL       000066F4   PORTNO      000010A0   PORTS       0000190A   PRODID      00000091
 PTAL2       0000608E   PTALL       0000608C   PTERM       00006062   PTMSN1      000060C6   PTMSND      0000609C
 PUEVEN      000053B2   PUTC1       000053C2   PUTCH       00005398   PUTH        000053C8   PUTH11      000053DA
 PUTIFC      000057D8   PUTNOT0     000056E0   PUTODD      000053B8   PUTOEC      000057EA   PUTPDPL     00005726
 PUTPDPR     0000573E   PUTPN       00006292   PUTPORT     00005104   PUTUN       00006514   PUTUN1      0000651E
 PUTW        000053DC   PUTW11      000053EE   P_FLAGS     00000001   P_NUM       00000000   RBTALL      00005A48
 RBTBKI      000061AC   RBTBKO      00006180   RBTBUF      000061BA   RD101       00D0403A   RD102       00D0403E
 RD103       00D04038   RD104       00D0403C   RD10AG      000054CA   RD10R       000054C4   RD10R1      000054CC
 RD10R2      000054FA   RDBLK       000055D4   RDPDP       000055A0   RDPDP1      000055CA   RDPDPRP     0000561C
 RDSNB       00005534   RDSNB1      0000554E   REDERR      00007E0A   REGDMP      0000514E   REGDMPX     00005184
 RELOP       00007E18   RESET       00005DE0   RESETAK     00005E02   RNOWRAP     0000534E   ROOM        00005340
 ROOMB       00005358   ROOMG       00005356   RTRACE      00000001   R_TANK      000010FA   SAVE1       00001104
 SCLKR       00006134   SEND17      00005EF8   SENDDAT     00006298   SENDQI      000053F0   SENDTEXT    00005408
 SETBLKA     00005676   SETPORT     00005A38   SHNUM       000060E4   SHNUM1      000060FC   SHNUM2      000060FE
 SHNUM3      00006118   SHNUM4      0000611C   SHUT        00005DA2   SLOR        00005378   SLOWC       000010E0
 SLTOME      0000101A   SMTLMT      000067C4   SNDTXT1     0000541A   SNTO        00006282   SPEC        00005E5A
 SPEC1       00005E64   SPTAB       00005E7A   STARTES     00007C00   STATE12     00007C0C   STERM       00005FF6
 STERM1      00005FFE   STERM2      0000602A   STERM3      00006056   STKBOT      00000900   STKTOP      00001000
 STRACE      00020000   STREAM      0000669A   STREAM1     000066A0   SUB7        00007C50   SUPLOG      00005F0E
 SUPLOP      00005F80   SUPOUT      00005F46   SUPR1       00005ED6   SUPREC      00005EB4   SUPTAK      00006828
 TEXTEND     00005CC0   TEXTLOP     00005CA6   TEXTMSG     00005C90   TIMCHK      00005DB0   TMOC        00001106
 TMOUT       0000553C   TMOUT1      000059B0   TOHOST      00001052   TP          00005F92   TRACE0      0000521E
 TRACE1      00005220   TRACE2      0000522C   TRACE3      00005240   TRACE4      00005244   TRACING     00000001
 TRHSTLN     00005CE6   TRISLN      000065D2   TR_IIC      000052BC   TR_IIF      00005304   TR_IIH      000052D6
 TR_IIL      000052A4   TR_IIW      000052EE   TR_IOC      0000524A   TR_IOH      00005262   TR_IOS      0000528C
 TR_IOW      00005278   TR_PORT     00001010   TR_RIN      00005318   TR_ROUT     0000532C   TSLOWC      00005DD6
 TYPBYT      0000108A   UNLINK      0000618C   VCRASH      000059CE   VECTOR      00004E00   VERIFY      000068A2
 VERSION     00000202   WAIT        0000536E   WAITDAT     0000579E   WAITIS      00005366   WAITISW     0000535E
 WAITPDP     000057FC   WR10R       0000568C   WR10R1      0000568E   WRBLK       00005756   WRDAT       000057A0
 WRE         00005954   WREH        000059C8   WRERL       00007D24   WRINRG      000057C6   WRIRTS      000057CE
 WRPDP       000057A4   WRSNB       000056D8   WRTERR      00007D16   WT101       00D0803A   WT102       00D0803C
 WT103       00D0803E   WT104       00D08038   XMITLMT     00000002   YB_CODE     000000AC   YELLOW      00006680
 ZAP         00005E40   ZAPPER      0000663E   ZERO        0000104A   .BFLTS      000010F4   .FASTC      0000103A
 .MDSIZ      00001026   .MDUMP      00001022   .SLOWC      00001036   .SYNC       0000102A   .TRACE      00001000
   P0q'