



















                            The XEXEC Record                              
                         of 16:04 June 9, 1980

                       Preliminary specification
                         and design philosophy
                            for the proposed
                      Tymcom-X Executive Language
                         and Executive System.










                                                        William R. Soley
                                                  Tymshare, Incorporated
                                                  Technical R+D Division
                                                20705 Valley Green Drive
                                                   Cupertino, California
                                                                   95014
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


                                Abstract                                





This document deals with the specification, design and implementation of
the executive language and system.  It is not intended as a  user manual
or description of operation.

The contents of  this document reflect the  state of the project  at any
given  point in  time.   As decisions  are  made, the  document  will be
changed as necessary to reflect the changes.











































                                   i
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


                           Table of Contents                             




Chapter                                                             Page


    Abstract  i

I.    Introduction  1
    I.1    About this document...   1

II.   Evaluation of Existing Languages  2
    II.1   VM/370: CMS EXEC Control Language  3
         II.1.1  Overview  3
         II.1.2  Trace Facility  3
         II.1.3  Error Trapping  4
         II.1.4  Console Stack  4
    II.2   UNIX: Shell Command Interpreter  6
         II.2.1  Overview  6
         II.2.2  Input/Output Redirection  6
         II.2.3  Pipelines  7
         II.2.4  Multiple Processes  7
         II.2.5  Parameters and Variables  8
         II.2.6  File Name Expansion  9
    II.3   Tops-20 Batch System  10
         II.3.1  Overview  10
         II.3.2  Error Detection  10
         II.3.3  Directing the Command Stream  10
    II.4   The TROLL Macro Facility  12
         II.4.1  Overview  12
         II.4.2  Deallocation of Variables  12
         II.4.3  Prompting for Unspecified Values  12
         II.4.4  Trapping Errors and Warnings  12
    II.5   Computer Complex Executive  14
         II.5.1  Overview  14
         II.5.2  Linking Terminals  14
    II.6   CDC NOS Control Language  15
         II.6.1  Overview  15
    II.7   ITS DDT  16
         II.7.1  Overview  16
         II.7.2  ValRetting  16
         II.7.3  Pseudo locations  16
         II.7.4  Normal Program Termination  16
         II.7.5  Abnormal Program Termination  17
         II.7.6  Read/Write DDT and ITS variables  17
         II.7.7  Review of Exec Functions for a Child  17
    II.8   SmallTalk  18
         II.8.1  Overview  18
         II.8.2  Parsing in Smalltalk  18
         II.8.3  An object oriented Exec  19
         II.8.4  Event driven control structure  19
    II.9   Tops-20 Monitor  21


                                   ii
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


         II.9.1  Overview  21
         II.9.2  Types of Tokens  21
         II.9.3  Help Messages  23
         II.9.4  Review  23
    II.10  The SU-AI DO program  24
         II.10.1 Overview  24
         II.10.2 Special characters and responses  24
         II.10.3 file segments  24
         II.10.4 The BRICK (escape character)  25
         II.10.5 special character generation  25
         II.10.6 macro manipulation  25

III.  Requirements and Specifications  27
    III.1  Exec vs COMCON Usage  27
    III.2  Procedures (or commands)  27
    III.3  Top-down command files  28
    III.4  Operations Requiring License  29
    III.5  Services Available to Children  29
    III.6  Error Trapping  30
    III.7  Miscellaneous  30

IV.   Grammar  31

V.    Semantics  33
    V.1    Statement Evaluation  33
    V.2    Procedure Evaluation  33

VI.   Runtime Procedures  35
    VI.1   Declarations  35
         VI.1.1  IVAR, SVAR  35
         VI.1.2  DEF  35
         VI.1.3  GLOBAL  35
    VI.2   Execution Control  36
         VI.2.1  IF  36
         VI.2.2  WHILE  36
         VI.2.3  UNTIL  36
         VI.2.4  FOR  36
         VI.2.5  REPEAT  37
         VI.2.6  DONE  37
         VI.2.7  NEXT  37
         VI.2.8  CASE  37
         VI.2.9  QUIT  38
    VI.3   Subsystem Command Generators  38
         VI.3.1  DO  38
         VI.3.2  STEXT  38
         VI.3.3  PLINE  38
    VI.4   Infix Operators  38
         VI.4.1  Arithmetic  38
         VI.4.2  Assignment  38
         VI.4.3  Comparison  39
         VI.4.4  Booleans  39
    VI.5   Token Retrieval  39
         VI.5.1  GETVALUE  39
         VI.5.2  GETIVAL  40


                                  iii
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


         VI.5.3  GETTEXT  40
         VI.5.4  GETTOKEN  40
         VI.5.5  GETREFERENCE  40
         VI.5.6  RESCAN  40
    VI.6   String Functions  40
         VI.6.1  SUBSTR  40
         VI.6.2  LENGTH  41
    VI.7   Frame Operations  41
         VI.7.1  ERUN  41
         VI.7.2  RUN  41
         VI.7.3  XEXEC  41

VII.  Special Variables  42
    VII.1  Control Variables  42
    VII.2  Information (read only)  42

VIII. Macro Facility  43
    VIII.1 Indirect Macros  43
    VIII.2 Signal Macros  43
    VIII.3 Simple Macros  44

IX.   Pipes and Pipelines  45
    IX.1   Pipes  45
    IX.2   Redirection of Terminal IO  46
    IX.3   Pipelines  46

X.    PTY related things  47
    X.1    Definitions  47
    X.2    User Interface  47
    X.3    When PTYs are required  48
    X.4    When PTYs are not required  48
    X.5    Things that Control PTYs  48
         X.5.1   SCNSER: main port service routine  48
         X.5.2   RCVCHR: handles characters from PTY  48
         X.5.3   SNDCHR: handles characters to PTY  49

    Appendix A
       Schedule  50
           Fourth quarter  50
           First quarter 1980  51
           Second quarter 1980  51

    Appendix B
       Correspondence  54

    References  55

    Index  58








                                   iv
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


                               Chapter I                                

                              Introduction                              




The  executive  is a  program  or module  which  acts as  the  user user
interface to the operating system.

In Tymcom-X version P033 and earlier, the executive process was a module
of the monitor called COMCON.   In Tymcom-X version P034 and  later, the
user  will have  the  option of  providing  his own  executive,  using a
standard system executive, or using COMCON.

This  document is  concerned with  the standard  system  executive which
shall be known as XEXEC.

The duties of the exec are

    1)  to execute all commands which do not invoke subsystems

    2)  to invoke the proper programs for those commands which do

    3)  to provide  means for  the user to  monitor and  control (to
        whatever extent he is licensed) the programs which have been
        invoked

    4)  to  provide  certain services  (where  appropriate)  for any
        programs which have been invoked



I.1    About this document...         
In  Chapter  II  is  an  overview  of  other  executive   languages  and
systems,  as well  as  a few  general purpose  languages.   Features and
misfeatures which pertain  to the development  of XEXEC are  pointed out
and commented  on.  By reading  this section it  is possible to  see the
origin of many of the ideas discussed elsewhere.

In Chapter III is a  general specification based on the  estimated needs
of Tymcom-X  users and future  Tymcom-X users.  Since  we are  making it                       
possible to  perform many  tasks on the  Tymcom-X which  were previously
impractical, we must be careful  to anticipate the new needs of  the new
users and their new applications.

In the remaining sections, the both internal and external specifications
are detailed.  In Appendix B  is a copy of any correspondence  which has
been received pertaining to the exec.







                                   1
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


                               Chapter II                                

                    Evaluation of Existing Languages                       




In this section  we take a look  at several existing languages  and note
their merits  and demerits.   Some general  purpose languages  have been
evaluated in that our executive will contain a number of concepts shared
by general purpose languages.













































                                   2
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


II.1    VM/370: CMS EXEC Control Language            

The exec language most familar to people at Tymshare is probably the one
in use on the Tymcom-370  systems under the CMS operation  system.  This
is known as the CMS EXEC Control Language.  This evaluation is  based on
documentation [IBM GC20-1818-1]  and extensive  experience in  using the
system for application programming.


II.1.1    Overview          
The language  is well suited  for the control  of one process  (does not
support multiple processes at all).  The EXEC does not  normally process
commands from the standard input  device, but rather is invoked  only to
process  command  procedures.   It is  not  block  structured.   An exec
procedure is contained in a  file known as an EXEC file.   All variables
declared in  the procedure  are local (there  are 10  predeclared global
variables  available).   Procedure  calls  consist  of  a  CMS  command.
Invoking an EXEC file is a CMS command and this is the only way  to call
an  external  procedure  (there  is  no  way  to  declare   an  internal
procedure).   All variables  are strings  usually containing  one token.
Variables are expanded (their value is substituted) when the  command is
scanned (except as they  occur on the left  of the "=" in  an assignment
statement).   All variables  and special  reserved words  begin  with an
ampersand "&".


II.1.2    Trace Facility           
The  &CONTROL statement  allows several  options to  be  specified which
simplify the debugging process.  All of these options are desired in one
form or  another.  The options  are specified as  arguments to  the EXEC
command "&CONTROL" as follows.  [IBM GC20-1818-1]

    &CONTROL OFF       suppresses the display of CMS commands and of
                       EXEC control statements as they  execute, and
                       any  return codes  that may  result  from CMS
                       commands.

    &CONTROL ERROR     displays only those CMS commands  that result
                       in  an  error  and  also  displays  the error
                       message and the return code.

    &CONTROL CMS       (default) displays each CMS command as  it is
                       executed and all nonzero return codes.

    &CONTROL ALL       displays  CMD  command  and  EXEC  executable
                       statements  as they  execute as  well  as any
                       nonzero return codes from CMS commands.

    &CONTROL MSG       (default)  does  not suppress  the  "FILE NOT
                       FOUND"  message  if  it  is  issued   by  the
                       following commands when they are invoked from
                       an EXEC  procedure: ERASE,  LISTFILE, RENAME,
                       or STATE.



                                   3
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


    &CONTROL NOMSG     suppresses the "FILE NOT FOUND" message if it
                       is issued  when the ERASE,  LISTFILE, RENAME,
                       or STATE  commands are  invoked from  an EXEC
                       procedure.

    &CONTROL TIME      includes the time-of-day value with  each CMS
                       command printed in the execution summary, for
                       example:
                            14:36:30 TYPE A B
                       This operand is effective only if CMS  or ALL
                       is also specified.

    &CONTROL NOTIME    (default)  does not  include  the time-of-day
                       value  with  CMS  commands  printed   in  the
                       execution summary.

    &CONTROL PACK      (default)  packs the  lines of  the execution
                       summary  so that  surplus blanks  are removed
                       from the displayed lines.

    &CONTROL NOPACK    does  not  pack the  lines  of  the execution
                       summary.


II.1.3    Error Trapping           
Another extremely useful feature of the CMS EXEC language is the ability
to  trap errors  without  testing after  each procedure  call.   This is
accomplished  by the  &ERROR statement.   The statement  is  followed by
either the word &CONTINUE or an executable statement.  This statement is
executed whenever an error return is given from a CMS command.

It may be more desirable to  trap only those errors which have  not been
resolved.  A method for resolving errors would have to be  defined.  Any
errors which have not been  resolved would cause a trap when  an attempt
was made to execute the next command.


II.1.4    Console Stack           
A commonly used feature of  the EXEC language is the ability  to specify
strings to be stuffed in  the standard input stream.  This  operation is
known as stacking.  Lines may be stacked in either FIFO order  (first in
first out)  or LIFO  order (last  in first  out).  These  operations are
accomplished by  the EXEC  commands &STACK FIFO  <line> and  &STACK LIFO
<line>.  This is  not similar to the  AUXCAL available in  P033 monitors
which forces characters into the input buffer in that
    1)  forced characters may be lost by the monitor;
    2)  forced characters get intermixed with real characters.
Assuming that commands are  being read from the terminal,  the following
diagram  shows the  precedence of  the various  ways of  supplying input
lines:






                                   4
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record



                -------
"buffer":       |  5  |   <-  TERMINAL INPUT
                |  0  |
                -------
                   |
                   |
                   |    -------
"console stack":   |    |  3  |   <-  &STACK FIFO
                   |    |  1  |
                   |   =========
                   |    |  2  |
                   |    |  4  |   <-  &STACK LIFO
                   |    -------
                   |       |
                   |-------|------->  &READ


The above  diagram shows  the "buffering" and  "stacking" of  lines from
various different sources.  The input sequence was:
    <line [0] typed at terminal>
    &STACK FIFO [1]
    &STACK LIFO [2]
    &STACK FIFO [3]
    &STACK LIFO [4]
    <line [5] typed at terminal>

6 successive reads  (&READ) would result in  reading the 6 lines  in the
order [4] [2] [1] [3] [0] [5].

This can be paraphrased by saying that things are read in  the following
sequence:
    1)  all lines stacked LIFO (if any) in reverse order;
    2)  all lines stacked FIFO (if any) in correct order;
    3)  all lines entered from terminal in correct order.





















                                   5
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


II.2    UNIX: Shell Command Interpreter           

On the  Bell Telephone  Laboratory UNIX  operating system,  commands are
interpreted by  a program known  as the shell.   The evaluation  of this
language     is      based     on      documentation     [BTL PG-1C300],
[Ritchie and Thompson 1974] and  some limited experience.   The opinions
of people who use it regularly at Bell Labs have been noted also.


II.2.1    Overview          
The  SHELL language  will support  multiple processes  in  a significant
manner.  It is  concise:  the syntax allows  the user to  invoke several
processes with only one  command line.  It is somewhat  block structured
(compound statements are allowed in certain contexts).  Variables may be
declared as global  by name.  Indirect  files are supported  (using ".")
and they can nest.  The standard input, standard output and error output
devices  (files) may  all (or  any) be  specified on  the  command line.
Traps  may  be  enabled for  several  signals  (interrupts).   All shell
variables begin with the character "$" (dollar-sign).  Variables  may be
made readonly by a shell command so that no future  assignment statement
can change their value.


II.2.2    Input/Output Redirection           
The shell allows the user to specify alternate input and output files on
the  command line  using special  signal characters.   Implementation of
this very desirable feature in such a way that it will not conflict with
programs that allow this under P033 will be a significant pro  UNIX
does it like this:

Before a  command is  executed its  input and  output may  be redirected
using  special notation  interpreted by  the shell.   The  following may
appear anywhere in a simple  command or may precede or follow  a command
and are not passed on to the invoked command.  [BTL PG-1C300]

    <name          causes the file 'name' to be used as the standard
                   input of the associated command.

    >name          causes the file 'name' to be used as the standard
                   output  of  the  associated  command.   'Name' is
                   created if it  does not exist, and  superceded if
                   it does exist.

    >>name         same as  '>name' except if  'name' exists,  it is
                   appended to.

    %name          causes the  file 'name' to  be used as  the error
                   output  of  the  associated  command.   'Name' is
                   created if it  does not exist, and  superceded if
                   it does exist.

    %%name         same as  '%name' except if  'name' exists,  it is
                   appended to.



                                   6
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


    >%             causes  the standard  output to  go to  the error
                   output.

    %>             causes  the error  output to  go to  the standard
                   output.

If  any of  standard  input, standard  output  or error  output  are not
specified, they default to the values currently in effect for the shell.


II.2.3    Pipelines          
If there  are several  programs to  be run,  each one  providing further
processing of  the previous,  a pipeline  may be  used to  connect them.
[Morrison 1978] [BTL PG-1C300] A pipline in the UNIX Shell  is specified
as a list  of commands seperated by  a vertical-bar (|).  The  effect is
that each of the commands is executed in a seperate process  (frame) and
linked to eachother with pipes.  The standard output of the first is the
standard input of the second.  The standard output of the second  is the
standard  input of  the  third.  Etc.   An  example of  this  applied to
Tymcom-X tasks would be
    DIR | SORT | PRINT
The effect  of this  is to  sort a directory  and print  it on  the line
printer.  It is similar in effect to
    DIR >TMP1
    SORT <TMP1 >TMP2
    PRINT TMP2
except that when specified as a pipeline, all processes would execute in
parallel.

It  is not  clear  that a  pipeline would  be  any more  efficient  on a
timesharing system.  It may be  assumed that the only advantage  lies in
the fact  that it is  (probably) not  necessary to do  as much  disk IO.
This of course,  depends on the nature  of the application being  run in
the pipeline, and on the method of implementation of pipes.  It  is also
not  clear  what  the  impact  of  long  pipes  on  the  overall  system
performance would be.  (see Section IX.1 on pipes)


II.2.4    Multiple Processes           
It  was said  earlier that  the Shell  handles multiple  processes  in a
significant way.  UNIX Shell handles multiple (concurrent)  processes as
follows.  [BTL PG-1C300]

A simple command is a  sequence of non blank words seperated  by blanks.
The first word specifies the name of the command to be executed.  Except
where noted, the remaining words are passed as arguments to  the invoked
command.  The  command name  is passed as  argument 0.   The value  of a
simple  command  is  its  exit  status  if  it  terminates  normally  or
200+status if it terminates abnormally.

A  pipeline  is  a sequence  of  one  or more  commands  seperated  by a
vertical-bar (|).  The standard output  of each command but the  last is
connected by  a pipe to  the standard input  of the next  command.  Each



                                   7
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


command  is run  as a  seperate process.   The shell  waits of  the last
process to terminate.

A list is a sequence of  one or more pipelines seperated by  a semicolon
(;) or ampersand (&).  A list is optionally terminated with  a semicolon
(;) or ampersand (&).  The effect of the various separators are:
    semicolon (;)      lists are executed sequentially
    ampersand (&)      lists are executed concurrently

A side effect  of lists being executed  in parallel (with  ampersand) is
that  they  are  immune  to  interrupts  and  that  errors  are  handled
differently.


II.2.5    Parameters and Variables            
Worthy  of  note  is  the  way  in  which  the  shell  handles variables
(parameters)  which  have  no  value.   Parameters  and   variables  are
recognized by the prefix of a dollar-sign ($).  Formally,
    <param> ::= $<id>  |  ${<id>}  |  ${<id><op><wd>}
    <id>    ::= <digit>  |  *  |  <name>
    <op>    ::= -  |  =  |  ?  |  +
    <wd>    ::= <a word>

    $<digit>           substitute  the   value  of   the  <digit>'th
                       positional argument.

    $*                 substitute  the   value  of   all  positional
                       arguments seperated by single blanks.

    ${<id>-<wd>}       if  <id>  has  a  value  then  substitute it;
                       otherwise substitute <wd>.

    ${<id>=<wd>}       if  <id>  has  a  value  then  substitute it;
                       otherwise   set   <id>  to   <wd>   and  then
                       substitute it.

    ${<id>?<wd>}       if  <id>  has  a  value  then  substitute it;
                       otherwise print <wd> and exit.

    ${<id>+<wd>}       if  <id> has  a value  then  substitute <wd>;
                       otherwise substitute nothing.

(the  following are  not defined  in UNIX  Shell but  are shown  here as
extensions)

    ${<id>--<word>}if <id> has a value then substitute it; otherwise
                   print <wd>, read  a line and substitute  the line
                   read.

    ${<id>==<word>}if <id> has a value then substitute it; otherwise
                   print <wd>,  read a  line, set  <id> to  the line
                   read and then substitute it.




                                   8
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


II.2.6    File Name Expansion            
Each command word is scanned for  the characters *, ? and [.  If  one of
these  characters appears  then  the word  is  regarded as  a  file name
pattern.  The word is replaced with a list of alphabetically sorted file
names that match the pattern.  If no file name is found that matches the
pattern then the word is left unchanged.

This is  almost guaranteed  to lose.  The  worst problem  is that  it is
impossible  to specify  a wild-card  string which  causes  the resulting
expanded file name list to exceed 256 characters in length.  It  is also
not desirable to assume that any argument containing these characters is
intended as a  file name pattern.  Lastly,  a file name pattern  may not
always refer  to the  obvious structure:   it may  for example  refer to
files on a tape or on another system.  Only the program  (command) knows
what it wants - if it needs it expanded, let it do a call to the exec to
have it expanded after the fact.








































                                   9
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


II.3    Tops-20 Batch System          

The Tops-20 operating system (on the DecSYSTEM-20) has a  utility called
Batch which will  process background and  defered jobs in  an unattended
fashion.   Many of  the problems  in such  a system  map to  problems in
executing  a non-interactive  XEXEC  procedure.  The  evaluation  of the
features of Batch  are based on [DEC OBRMA]  and [DEC OBOGA] as  well as
personal experience with the  nearly identical Batch for the  DEC RSTS-E
operating system.


II.3.1    Overview          
The system is designed to take  command input from a deck of cards  or a
job  control file.   There is  no concept  of variables.   Processing is
typically  top down  with  the exception  of special  action  on labels.
There are two flavors of GOTO  - one for forward references and  one for
backward  references.  There  is no  way to  substitute parameters  in a
command line.  The most notable features are described below.


II.3.2    Error Detection           
Although very ugly, Batch will detect errors in programs which  have not
been modified  to return an  error code.  It  does this by  scanning for
certain  special  characters  in  column  one  of  the  terminal output.
Characters have the following significance:
    ?      Severe error
    %      Minor error or warning
    [      Informative message

Some  extension  of  this  method could  be  used  to  detect  errors in
unmodified P033 programs.  The suggestion is to use a statement  such as
EP to specify one or more templates to be used to detect lines which are
error messages.  For example,
    EP err EOL "?" errmsg EOL
would look for a "?" in column 1 and if found, would store the remaining
characters on that line in  variable ERRMSG.  The flag ERR would  be set
(which may cause a trap).


II.3.3    Directing the Command Stream             
Certain commands which one wishes to place in an XEXEC file are intended
for some subsystem (ie.  SPOOL, SORT, etc.).  Batch solves  this problem
by  looking  at  the  first  character  of  a  command.   The  following
assumptions are made about lines begining with the  indicated characters
(some have been omited):

    * (asterisk)       The  line  is  treated  as  input  to  a user
                       program.  If  there is  no user  job running,
                       this is treated as a comment.

    = (equal sign)     Same as "*" but <crlf> is suppressed.





                                   10
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


    @ (atsign)         The line is treated as a tops-20  command.  *
                       If a user program is running (in  input wait)
                       then the program is  stoped (as if a  ^C were
                       sent).

    ! (exclamation pt) The line is a comment.

This type  of direction or  filtering could replace  the necessity  of a
terminal input stack  as described in Section  II.1.4.  It is  not clear
that both are not desired.











































* Note: "@" is the Tops-20 monitor prompt


                                   11
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


II.4    The TROLL Macro Facility           

The National  Bureau of Economic  Research has a  system known  as TROLL
which is  used for  economic, management  and statistical  research.  To
supplement  the command  processor, a  macro processor  was  designed to
allow complex manipulation of command strings and flow.   The evaluation
of this facility is based solely on the user guide [Perron 1975].


II.4.1    Overview          
Commands to the macro  processor are intercepted by the  macro processor
during scanning and never reach the TROLL command processor.  A macro is
defined be creating  a disk file with  the desired name.   Arguments are
read by  referencing the variable  &0.  Each time  &0 is used,  the next
value is read from  the argument list.  The facility  supports variables
in the  sense that  one can  dynamically create  any number  of numbered
arguments and assign values to them without requiring that they  ever be
specified in a call.  There  also exists an entity called  &ifargs which
are not worthy  of further discussion.   With the exception  of trapping
warnings and errors, the only flow control is the &GOTO  statement.  The
only block structure exists in the form of nested macros.


II.4.2    Deallocation of Variables            
The  most unique  feature of  the TROLL  macro facility  is  the &DELETE
statement  which  deallocates a  variable  (or  argument).  Deallocation
occurs automatically when the macro in which the variable (argument) was
defined  in  is  exited.   This may  be  necessary  to  clean  up global
variables  which have  been allocated  for some  temporary use  (such as
TMPCOR).


II.4.3    Prompting for Unspecified Values             
The macro facility provides a  syntax for specifying a prompt  string to
be used if the value of a variable is unassigned when it  is referenced.
If the variable does have a value, no action is taken.  The form is
    &variable"prompt message"
The entire construct may appear anywhere where an variable may  be used.
If it is desired that the  value be prompted for (if necessary)  at some
point where  it is  not actually  needed, the  &IGNORE statement  may be
used.
    &IGNORE &6"Enter var 6:" &7"Enter var 7:"
The  &IGNORE  statement  simply  ignores  (but  evaluates)  all  of  its
arguments.   If  any of  the  variables are  undefined,  their  value is
prompted  for.  If  a  variable appears  without a  prompt  string being
specified, and the variable is undefined, TROLL issues a prompt  for the
data type that is expected (ie. date, integer, position, etc.).


II.4.4    Trapping Errors and Warnings             
The  TROLL  system  recognizes  two  levels  of  severity  of diagnostic
messages:  warnings and  errors.  The  user may  set seperate  traps for
these events.  This is performed by the statements
    &WARNING <msg> <act>


                                   12
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


    &ERROR <msg> <act>
where
    <msg> is either null or NOMSG to specify that the  error message
           is to be suppressed.
    <act> is one of &IGNORE, &RETURN, &EXIT, &ABORT or &GOTO.
When the trap  occurs, the variable &IFARG(0)  is loaded with  the error
code.

















































                                   13
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


II.5    Computer Complex Executive          

This section deals with the Computer Complex Executive for  the SDS-940.
The evaluation is based on documentation [CC 0271] only.


II.5.1    Overview          
This executive  is a  superset of the  one being  used on  the Tymcom-IX
systems by Tymshare.  Certain  commands have changed name.  There  is no
flow control, conditionals or traps in the exec language.  Command files
are executed  until an  error is encountered.   There are  no variables.
Standard input and output can be diverted from the terminal to a file by
command.


II.5.2    Linking Terminals           
The only feature of this executive worthy of note is the ability to link
the controlling terminals of two jobs together.  When two  terminals are
linked together,  any character  which would  normally appear  on either
terminal, appears on both - there is no effect on terminal  input.  This
is accomplished by giving  the LINK command and specifying  the terminal
to be linked  to as an  argument.  The link  is established only  if the
accept links bit is set for  the receiving job.  This bit is set  by the
ACCEPT  LINKS command,  and cleared  by the  REFUSE LINKS  command.  The
default is to refuse links.

This  has  considerable value  for  debugging and  training  as  well as
everyday communication.   Note that it  would be possible  to link  to a
PERP job to monitor its progress.



























                                   14
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


II.6    CDC NOS Control Language           

The  Network  Operating  System  (NOS)  for  CDC  Cyber  series  systems
incorporates a subsystem known  as Control Language to  handle commands.
The  evaluation  of  this control  language  is  based  on documentation
[CDC 1977] and several months of experience.


II.6.1    Overview          
The control language will  accept and evaluate expressions  as arguments
of  its  commands  where  appropriate.  There  are  a  number  of system
variables  some  of  which  are  readonly.   There  are  three  (3) user
variables known  as control registers  1, 2 and  3.  Some of  the system
variables have side effects, for  example, assigning a new value  to the
variable SS places you in a new subsystem.  Procedure files consist of a
file containing control language statements.  Procedures are called with
the CALL statement, or if the procedure is a system procedure, it may be
called  by  giving  its  name.  The  contents  of  the  control register
variables are  available to programs  and subsystems which  are invoked.
The current exit  mode and previous error  are available to  the control
language  programmer  through  special  variables.   The  IF   and  GOTO
statements provide flow control.   Reserved words and variables  have no
distinguishing syntax.

































                                   15
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


II.7    ITS DDT         

The  Massachusetts Institute  of Technology's  Incompatable Time-Sharing
system which  runs on  a PDP-10  incorporates a  special version  of DDT
(Dynamic Debugging Tool) as the executive language.  This  evaluation of
ITS DDT is based on documentation [Lewis 1977] and personal experience.


II.7.1    Overview          
ITS DDT is an extremely  obscure executive.  The idea however  of always
having a debugger  around when you  need it is  an obvious win.   If the
debugger is easy to use and understand for the non-programmer, which DDT
is not, it can be used to supply many of the features of the  exec which
would otherwise have to be  made into commands.  DDT may access  any job
running on  the system  (preferably only those  belonging to  the user).
DDT  is used  to access  itself  as a  means of  changing  and examining
variables.  DDT can be made to take commands from files, and subordinate
programs.  These commands may contain flow control  statements.  Linking
in DDT is very powerful in that allows partial links and advice  as well
as the typical link.  Commands (known as JCL) are preceded with a colon.
Otherwise,  commands are  passed  to the  called program  verbatim  in a
special buffer which the called program can request.


II.7.2    ValRetting          
DDT traps any illegal instructions in its children.  If a child executes
a .VALUE instruction, which is trapped by DDT as an illegal instruction,
it will interpret the effective  address as an ASCIZ string  of commands
to be executed by the DDT.   This only works if the terminal  belongs to
the job doing the .VALUE.


II.7.3    Pseudo locations           
There are a  number of pseudo locations  which behave exactly  like real
memory locations to  the user but actually  represent data which  may be
stored in the monitor or in  DDT.  Some of the variables also  have side
effects which take place when they are referenced or assigned to.


II.7.4    Normal Program Termination            
When  an  inferior  terminates  normally,  it  executes  the  .BREAK 16,
instruction.  The arguments  of this instruction allow  specification of
the type of fate that is  to come to the inferior process.   The options
are:
    return from $X (used by DDT)
    skip return (type <crlflf>*)
    clear terminal input (or suspend command file)
    kill job and type :KILL<crlf>* (because job is done)
    return from conditional breakpoint (true)
    return from conditional breakpoint (false)
    suppress any msgs normally printed
So it is noted that the  program being run has the ability  to determine
if  the frame  it is  running in  should be  destroyed or  not  when the
program completes (of course DDT can override this).


                                   16
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


II.7.5    Abnormal Program Termination            
When an inferior terminates abnormally, it executes the .LOSE  uuo.  The
.LOSE uuo backs the PC up to the instruction previous to the  .LOSE uuo.
In this way, an $P will retry the UUO that failed assuming that it was a
UUO.  The arguments to the .LOSE uuo are

    1000           means that the  instruction that failed is  a UUO
                   and the error message should be  calculated based
                   on how error codes are returned by that uuo.

    1000+errcode   report on the error code specified

    1400           some kind of file i/o uuo failed, the appropriate
                   message  should  be  printed  based  on  the  uuo
                   pointed to by the backed up PC.

    1400+errcode   report on the file error code specified

    1+intbit       report  the  error  pertaining  to  the specified
                   interrupt


II.7.6    Read/Write DDT and ITS variables              
The .BREAK 12, instruction and the .SUSET uuo are respectively  used for
reading  and  writting  DDT  and ITS  symbols  from  an  inferior.  Many
interesting values and parameters are available in this manner.


II.7.7    Review of Exec Functions for a Child                
All of the concepts  of allowing children to request  certain operations
of the exec are very desirable.  The illegal instruction or  illegal UUO
trap seems  to be a  simple method of  doing so.  If  the parent  is not
trapping this condition, then the  default action would be to die  of an
illegal operation.






















                                   17
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


II.8    SmallTalk        

Smalltalk is  a general  purpose object  oriented language.   The design
philosophy is such that  it provides some interesting metaphors  for the
design of our exec language.  This evaluation is based  on documentation
[Ingalls 1978] [Shoch 1979] and limited experience.

Smalltalk was  developed by  the Learning Research  Group at  Xerox PARC
with the  goal of studying  the ability of  children of various  ages to
learn  and  use an  object  oriented  language.  So  far  it  seems that
children  of  all ages  are  quite able  to  learn the  concepts  of the
language and put it to good use [Goldberg and Kay 1977] [Goldberg 1977].


II.8.1    Overview          
Many of the concepts of  Smalltalk are similar to those found  in SIMULA
[Birtwistle, Dahl, Myhrhaug and Nygaard 1973]   [Dahl and Nygaard 1966].
While most of us are used to a function oriented language,  Smalltalk is
an object oriented language.
    The principle  abstractions   which  define  Smalltalk   can  be
        presented very simply: [Shoch 1979]

    1)  Every  entity no  matter what  its name  or function,  is an
        object.

    2)  Every object  is an instance  of a class,  and behaves  in a
        manner prescribed by that class.

    3)  Every object  may maintain its  own local state,  or memory;
        some  aspects of  this memory  are unique  to  the instance,
        while others may be common to all members of the class.

    4)  Objects communicate with each other by sending messages.

    5)  Thus,  defining a  class consists  of enumerating  the valid
        messages   which  it   might  receive,   and   defining  the
        appropriate action or response associated with each message.

    6)  In  considering  the textual  representation  of  a program,
        control is  passed to  the first  object, and  the remaining
        text is its message.


II.8.2    Parsing in Smalltalk            
Most interesting to our project is the way in which Smalltalk parses the
program.  Actually, a Smalltalk program parses itself.  The first object
in the program  gets sent a message  consisting of the  entire remaining
program.  It may then nibble some things off the message and send one of
the next objects a message consisting of the still remaining code.  This
is  best  shown as  an  example of  how  a numeric  expression  would be
executed:  the expression 3+4 is evaluated by sending the object 3 (3 is
an  instance of  class integer  which is  a subclass  of  number...) the
message +4.  When 3 receives the +, it evaluates the rest of the message



                                   18
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


and returns the  result added to 3.   A more complicated example  is the
evaluation of 3+4+5; 3 is sent the message +4+5; it then notes the + and
evaluates 4+5 by sending  4 the message +5;  4 returns 9 (4+5)  which is
added to 3 and returned as the value of the expression.   Likewise, when
an  object  of class  string  receives  a message  begining  with  +, it
performs concatenation.

As a result, rather than having to teach the + function to cope with new
classes each time they are added, it is only necessary to teach  the new
class how to add.  In fact if the new class is a subclass of  some class
which already knows how to add,  then it is not even necessary  to teach
the new class unless some special action is necessary which is different
than its parent class.


II.8.3    An object oriented Exec             
If we were to apply these principles to our exec language, we might come
up with  a better way  of describing our  problem.  If we  call programs
objects of class program, the command line
    DIR DSK:ABC.*/AUTH
would be parsed by executed by sending the message DSK:ABC.*/AUTH to the
program DIR.  When DIR came across something in the message it could not
parse  itself,  it would  send  a  message to  the  proper  object.  For
example, it may send the message
    ABC.*
to the object
    DSK
Hopefully, DSK  would return  a list of  filenames fitting  the template
ABC.*.  In this  way, the concept of  modularity is obvious  because DIR
has complete control of how its message is interpreted (and parsed), yet
it  need not  know about  how to  expand filenames  for a  given device.
Indeed,  DIR need  not be  changed should  a new  device be  added which
requires special file name expansion.

Of course, there are also complications because in the command string to
DIR, the device may be  omited.  In fact logical names may  be specified
which  further  complicates  the  process  of  determining  the  message
recipient.


II.8.4    Event driven control structure             
This proposal (by [Knuth 1974]) provides a control structure in  which a
loop is entered which will terminate on a given set of events.  When the
loop terminates, a selection is made using a case statement to select an
exit statement.  This  type of control  structure may be  implemented in
Smalltalk as follows [Shoch 1979]:

        (
        until Return or Delete do                       "1"
            (
            ^character _ keyboard.
            display _ character.
            character = 13 => (Return).                 "2"
            character = 127 => (Delete).                "3"


                                   19
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


            )
        then case                                       "4"
            Return : ('deal with normal exit')
            Delete : ('deal with abnormal exit')
        )


Above, the until  statement (marked "1")  defines two events  Return and
Delete.  Within  the loop, these  events are conditionally  triggered by
statements "2" and "3".  When  either event occurs, then and  only then,
the  loop is  exited through  the exiting  case statement  (marked "4"),
which determines the cause of the exit.

This structure  may be especially  useful in the  exec language  for use
with interrupts (or  signals).  The event could  be triggered by  a trap
routine  in  response  to an  external  event  (ie.  character received,
circuit zapped, etc.) thus providing a much more pleasant exit  from the
loop.






































                                   20
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


II.9    Tops-20 Monitor         

The features of the Tops-20 Monitor which are significant are  the COMND
JSYS  and related  JSYS's.  This  instruction is  used by  the  exec and
programs alike to parse  commands from the standard input  device.  This
evaluation is based on documentation [DEC 4166C].


II.9.1    Overview          
This JSYS parses one field of  the command line at a time.   The command
line is obtained from the standard input which may be either  a terminal
or  file.   When  reading  commands  from  the  terminal,  the following
features are provided: [DEC 4166C]

    1)  Allows the input of a command (including the guide words) to
        be  given  in  abbreviated,  recognition  (ESC  and CTRL-F),
        and/or full input mode.

    2)  Allows the user to  edit his input with the  DELETE, CTRL-U,
        CTRL-W, and CTRL-R editing keys.

    3)  Allows fields of  the command to be  defaulted if an  ESC or
        CTRL-F is typed at the beginning of any field or if  a field
        is omitted  entirely.  The assumed  portion of the  input is
        shown by the monitor.

    4)  Allows a help message to be given if a question mark  (?) is
        typed at the beginning of any field.

    5)  Allows input of an  indirect file (@file) that  contains the
        fields for all or the remainder of the command.

    6)  Allows a recall of  the correct portion of the  last command
        (ie. up  to the beginning  of the field  where an  error was
        detected) if the next command line begins with  CTRL-H.  The
        correct portion of the command is retyped, and the  user can
        then continue typing from that point.

    7)  Allows input of a line to be continued onto the next line if
        the user types a hyphen (-) immediately preceding a carriage
        return.  (The  carriage return is  invisible to  the program
        executing the COMND call, although it is stored in  the text
        buffer.) The  hyphen can be  typed by the  user while  he is
        typing a  comment.  The comment  is then continued  onto the
        next line.


II.9.2    Types of Tokens            
The  COMND JSYS  recognizes  a number  of commonly  used  tokens.  These
tokens  are checked  for  validity before  being passed  to  the calling
program.  The types of tokens are:

    1)  Keyword:  a table of valid keywords is passed to the monitor
        and a pointer to the keyword entered is returned.


                                   21
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


    2)  Number:  the radix of the number is given and the  number is
        returned.

    3)  Guide  word:    optional  noise   words  (which   appear  in
        parenthesis) are returned.

    4)  Switch:  a switch of the form /<switch>:<value> or /<switch>
        is parsed.

    5)  Input  file:   return   a  pointer  to  the   existing  file
        specified.

    6)  Output file:  return a pointer to a file.

    7)  Arbitrary file:   return a pointer  to an arbitrary  file or
        group of files.

    8)  Arbitrary field:   any arbitrary  token entered  is returned
        without verification.

    9)  Confirm:  the user is asked to confirm and the boolean reply
        is returned.

    10)  Directory name:  the  directory number of the  directory is
        returned.

    11)  User name:  the directory number of the login  directory is
        returned.

    12)  Comma:  returns true if a comma is next.

    13)  Floating point number:  returns the number.

    14)  Device name:  returns the device designator.

    15)  Text:  return everything up to the next carriage return.

    16)  Date/Time:  the internal form of the date and time given is
        returned for the given date or time given.

    17)  Quoted string:  return the text between two quote marks.

    18)  Unquoted  string:   return  text  up  to  the   next  break
        character (supplied).

    19)  Literal:  the input is compared with a supplied string.

    20)  Leading number:  a number  is parsed ending with  the first
        non-numeric character.

    21)  Account:  return an account string.

    22)  Node name:  return a network node name.



                                   22
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


II.9.3    Help Messages           
The calling program may supply  a help string to be printed  in response
to a "?" should the user enter one.  If a help string is not supplied by
the user,  a default help  string will be  provided by the  system.  The
default string essentially describes  the type of field expected.   If a
"?" is entered, the help string is printed and the input up to where the
"?" was typed is reprinted  allowing the user to continue  entering from
where he typed the "?".


II.9.4    Review          
Although these features  may seem a  little eccentric, they  represent a
concise method of exchanging command information between a  user program
and the exec or  monitor.  It is far  more desirable to have  a standard
user interface than to have each program provide its own  user interface
along  with  its  own  idiosyncrasies.   This  method  will  probably be
extended  to include  obtaining evaluated  expressions from  the command
line so that local variables  do not interfere with variables  passed as
arguments which have the same name.





































                                   23
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


II.10    The SU-AI DO program            

The  SU-AI  DO  program exists  on  the  Stanford  University Artificial
Intelligence computer to allow command files to be executed  by stuffing
characters in the terminals  input buffer.  Although this method  is not
under  consideration,  several  features  of  the  user   interface  are
signifigant with respect  to the problem of  command files in  the exec.
This evaluation is based on documentation [Helliwell 1980].


II.10.1    Overview           
The DO program reads any standard text file and puts the characters from
the file into your input buffer. Then the program exits and  the monitor
reads the characters and does the rest.  If this causes a program  to be
run, it can then read any of the characters remaining in the  buffer, as
can any  subsequent programs or  the monitor if  the programs  return to
monitor level with some text still unread.


II.10.2    Special characters and responses              
The program scans the text in the file for special characters:

    <CR>     Ignored.

    <LF>     Ignored.

    ^H       Insert a deferred <CALL> at this point.

    ^B       Add a <CTRL> bit to the next converted character.
    <VT>     (same as ^B)

    ^C       Add a <META> bit to the next converted character.
    <FF>     (same as ^C)

    ^^       Quote the next character. (Pass it with no conversion.)

    |        Separates different DO functions (see below)

    ?        Takes the next character (other than RETURN or LINE) as
             a  variable name.   Suppose the  character is  A (i.e.,
             ?A).   If this  is the  first occurrence  of ?A  in the
             file, DO types out "A=     " and waits for you  to type
             in a  text string ending  with RETURN.  This  string is
             substituted  for every  occurrence of  ?A in  the file.
             (It is also rescanned after it is inserted.)


II.10.3    file segments            
To allow more than one DO function to be stored in the same  file (good,
for instance, because small  files are inefficient in using  disk space,
and other  reasons), the  vertical bar (|)  character can  be used  as a
separator.  The various function segments in a DO file may be labeled by
putting a label immediately followed  by a colon (:) as the  first thing



                                   24
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


in the segment.  A file segment is named by following the file name with
the segment name in parenthesis.


II.10.4    The BRICK (escape character)              
Following the POX convention, the escape character is called  the brick.
In the following, we will  use the backslash character "\" as  the brick
character in examples.

To specify a  brick character use the  sequence ?\<char> This  makes the
<char> the brick  character.  For example,  to specify backslash  as the
brick character use ?\\

The  brick character  appears  as the  first  character of  all  the new
commands.  Subsequent  characters are scanned  to determine  the command
and to get any needed arguments, etc.  Then normal processing is resumed
until the brick character is encountered again.

If the command is denoted by a special keyword the keyword  is delimited
on the right  by a dot  character "." and may  be in upper  and/or lower
case letters.


II.10.5    special character generation             
These commands  are used to  cause special characters  to appear  in the
text.
    \CR.           Return (same as )
    \LF.           Line (same as )
    \ALT.          Alt (same as )
    \TAB.          Tab
    \VT.           Vertical tab
    \FF.           Form
    \BS.           Backspace
    \C.            Add control bit to following character
    \M.            Add meta bit to following character
    \CM.           Add both control and meta bits to next character
    \"<char>       Quotes <char>
    \'<octal>      Generate character with given <octal> code number
    \=<decimal>    Generate  character  with  given  <decimal>  code
                   number
    \^<char>       Generate uparrow style character
    \?<char>       Generate SOS style character


II.10.6    macro manipulation            
There  is  a  set  of   128  string  variables,  whose  names   are  the
corresponding character.  In normal mode scanning these are set with the
?<char>  command.  The  following commands  allow a  limited  ammount of
manipulation of these  strings.  The symbol  <macro> will stand  for the
character which is the name of the macro variable.
    \_<macro><char><string-sans-char><char>   Sets     <macro>    to
                                   delimited string.
    \INPUT.<macro>                 Inputs <macro> from the terminal.



                                   25
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


    \&<macro1><macro2><macro3>     Like  SAIL  macro1  _   macro2  &
                                   macro3.
    \INSERT.<macro>                Patches <macro> directly into the
                                   output,   unlike   the   ?<macro>
                                   command  which  causes  it  to be
                                   rescanned.
    \;<char><string-sans-char><char>    Comment,   ignores   between
                                   <char>s.
















































                                   26
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


                              Chapter III                               

                    Requirements and Specifications                      




This section deals with the general specification of language and system
features.   This is  not intended  as a  complete  specification, rather
guideline to be used in developing a complete specification.

The language is  to be used to  express commands and groups  of commands
(procedures) to the  executive system.  The executive  language combined
with the executive system will replace and upgrade the  service provided
by the module COMCON in the P033 monitor.  Important and significant new
features include
    1)  control of more than one process from a single terminal
    2)  execution with flow control of commands from a file
    3)  preparsing of program arguments
    4)  ability to emulate several user interfaces
In addition to  this, compatibility with  the user interface  offered by
COMCON must be maintained (the albatross).



III.1    Exec vs COMCON Usage            
COMCON will be maintained in a skeleton form to service those people who
would rather  suffer.  As a  result, there will  be occasion  for people
running without an EXEC to invoke  one to perform a brief task  and then
dispose of it.

In general, the system will be designed with the user who is perpetually
running a top-level EXEC in  mind.  The action of a user  discarding his
top-level EXEC and later replacing  it will be comparable to  begining a
new session in that all  global storage (including TMPCOR) may  be lost.
Also note that if a subordinate EXEC is invoked, it will not necessarily
be able to access the global storage of its parent.  This type of global
access between generations is,  however, a desirable feature  and should
be considered.



III.2    Procedures (or commands)           
The term "procedure" will be  used to describe any task or  subtask that
may be invoked by the exec.  Procedures may be any of the following
    1)  a primative function
    2)  an internal function
    3)  an external function (commands file)
    4)  a compiled external function
    5)  an external program (executable file)

A primative  function is  a command which  is hardwired  in to  the exec
interpreter.  Few  of these functions  will be of  any use to  the user,



                                   27
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


rather they will be used to build useful functions.  *

An internal function is a  command procedure which has been  declared at
some point during this instantiation  of the exec.  This may be  done in
the exec profile.  The  profile is an external procedure  which executes
automatically  upon exec  instantiation  (similar to  an  init program).
Once a  procedure is defined,  it is stored  in an internal  form (after
macro expansion) for future calls as a procedure.

An external function is essentially a command file.  The file is  a text
file containing commands to be  executed.  The file has the name  of the
command which invokes it.

A compiled external function is  a command file which has  been compiled
into a series of machine executable calls to primative  functions.  This
executable code is saved  in a core image  file along with a  routine to
obtain  the  primative  function  library  routines  for  the particular
version of the exec the  file was compiled under.  The program  may then
be protected or given license as any core image file may.   The compiled
function  is therefore  not sensitive  to new  versions of  the  exec or
private  execs  which may  be  incompatible.  The  external  function is
treated in all ways identically to an external program by the exec which
is invoking it.

An external program is a program written in any language which  has been
compiled, linked and saved in  a core image file.  The  external program
is treated in all ways  identically to an external function by  the exec
which is invoking it.



III.3    Top-down command files           
The ability to obtain input data for subsystems from the same  stream as
commands  is  desirable in  many  instances.  At  the  sacrifice  of the
reliability  associated   with  the   do-with  construct   (see  Section
VI.3.1),  the  user shall  be  able  to specify  the  exec  procedure as
the default  standard input  for subsystems  (programs).  The  result is
that whenever  a program enters  input wait on  its standard  input, the
exec will supply the next statement from the procedure.  The declaration
of  StandardInput :=  "."  would have  effect  within the  scope  of the
current block.  Note the following example of how this will  easily lead
to chaos:
    {StandardInput _ "."
    SPOOL
    PRINT REMOTE
    QUIT
    }
Should  the spool  program have  a bug  which causes  it to  exit before


* If  statistical  analysis shows  that  a particular  command  is being
executed frequently and has high overhead associated with it, it  may be
coded  in  as a  primative  for efficiency  even  though it  may  not be
primative by definition.


                                   28
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


reading any input commands, the  exec would read "PRINT REMOTE"  and run
the lister program  which would try to  print the file REMOTE  on device
LPT:.  In this  example, the spool program  will not be allowed  to read
past the end of block "}".



III.4    Operations Requiring License           
All  functions of  the  exec which  require license  (ie.  sending mail,
GFDing, etc.) shall be  provided by licensed utility programs  which may
be executed by any unlicensed  exec.  This is to allow  private versions
of the exec to be  maintained by user groups without  requiring license.
Note  that the  system exec  may  actually be  licensed so  that  it may
perform some of these tasks internally for efficiency.

The utility programs provided for this purpose shall be written  in such
a way that  the calling program may  execute them, supply  all necessary
parameters, and receive all results  in a manner that is  transparent to
the user.  Any errors encountered should be able to be simply trapped by
the exec.



III.5    Services Available to Children            
Any program  which is executed  by the exec  will be a  child.  Children
will  be  able to  request  various  services from  the  parent  exec by
executing certain instructions.  The instruction executed would normally
be an  illegal instruction or  illegal UUO but  would be trapped  by the
exec which would take the  appropriate action.  If the parent is  not an
exec, or is a version which does not recognize this instruction,  or the
program is  an orphan,  the instruction  would be  treated as  any other
illegal instruction  and cause a  fatal error.  See  Section II.7  for a
description of this feature in ITS DDT.

Examples of services which may be provided are
    executing a string of commands for the program
    passing arguments to the program
    returning results from the program
    setting and examining exec variables

Note that by  nature of the  framing system, grandchildren  are normally
invisible  to  the   grandparent.   Therefore,  it  would   be  normally
impossible for the exec to handle requests from its  grandchildren.  The
most likely procedure for handling  these requests is to have  the child
trap the  request, and  in turn execute  a request  to its  parent which
passes a frame  handle to the grandchild  so that the exec  may actually
perform the operation.









                                   29
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


III.6    Error Trapping          
The user should have complete  control over how all errors  are handled.
The  prefered method  of implementation  involves providing  an internal
procedure  for  each  class   of  error.   These  procedures   would  be
initialized to  some default action  when the exec  is started  up.  The
user may then  redefine them at will  to contain any procedure  which he
may wish to execute for that error condition.

Note that a side  effect of this method  is that error handling  will be
local to  the block it  is declared  in.  If a  block (or  procedure) is
entered  which wishes  to  perform a  special function  on  a particular
error,   it  would   redeclare  the   particular  error   handler.   The
redefinition would be local to the block (or procedure) and would revert
to whatever was in effect  before the procedure call when  the procedure
exited.



III.7    Miscellaneous         
Several  other  subjects which  may  be considered  to  belong  here are
actually found elsewhere in a chapter of their own.  This is due  to the
enormity of material on each.


































                                   30
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


                               Chapter IV                                

                                Grammar                                




Below lies the proposed grammar.  Not shown is the presence of the macro
processor.  Macros  will be expanded  everywhere - even  inside strings.                                      
Macro processing is discussed fully under Chapter VIII.

    The notation closely resembles BNF except that  terminals, which
    are enclosed in curly braces ({}), are described in  english for
    simplicity, rather than defined in BNF.


<S>
        ::= <block> <sep>
<block>
        ::= <stmt>
        ::= <block> <sep> <stmt>
<stmt>
        ::= <proc> <args>
        ::= <expr>
        ::= {nil}
<expr>
        ::= <value>
        ::= <expr> <infix> <value>
<value>
        ::= "{" <block> "}"
        ::= "(" <expr> ")"
        ::= <scons>
        ::= <ncons>
        ::= <var>
<sep>
        ::= "\"
        ::= '12
<args>
        ::= <value>
        ::= <text>
        ::= <var>
        ::= <id>
<sconc>
        ::= {a quoted string constant}
<ncons>
        ::= {a signed numeric constant}
<text>  
        ::= {any arbitrary string of characters}
<proc>
        ::= {an <id> which names a procedure}
<var>
        ::= {an <id> which names a variable}
<id>
        ::= {any legal identifier}


                                   31
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


<infix>
        ::= {any declared infix operator}






















































                                   32
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


                               Chapter V                                

                               Semantics                               




Refering to the section on grammar (Section IV), this  section describes
the effect of the various constructs.



V.1    Statement Evaluation        
When evaluating a  statement (<stmt>), the first  token is looked  up in
the symbol table.

If  it  is any  of  the objects  classified  as <value>  then  the whole
statement is evaluated as an infix expression.

If it is a procedure,  a procedure call is made as  described elsewhere.
The  value  given  as  the arguments  of  the  return  statement  in the
procedure  is  the  value  of  the  statement.   Note  that  an external
procedure  call involves  scanning  all of  the UFD's  in  the procedure
search list (ie. is expensive).

If it is not one of these, it is flagged as an error.

Note that since a  block is a value, a  statement may be enclosed  in {}
and included in an  expression.  In the following example,  the variable
RPGtemp is assigned the name of the standard RPG temp file.
    SET RPGtemp = {SUBSTR ({PJOB}+1000) 2 INF} & "RPG.TMP"



V.2    Procedure Evaluation        
Procedures,  although  they  all  have  the  same  syntax   and  calling
conventions, are quite  various.  Primative procedures, or  runtimes are
very  efficient  since  they  are  coded  in  SAIL  and  they   are  not
interpreted.  Internal procedures  are second most efficient  since they
are always part of the core image, it is very efficient to  access them.
There are both external programs and procedures.  They have the  name of
the  procedure being  called and  the extension  determines the  type of
external  procedure.   When evaluating  a  procedure call,  the  in core
symbol table  is scanned to  determine if the  procedure is  internal or
runtime.   If this  should  fail, all  UFD's in  the  external procedure
search list will be scanned  until a program is found with  the external
procedure extension.   If this  should fail, all  UFD's in  the external
program search  list will be  scanned until a  program is found  with an
extension  denoting  a  core  image  file.   If  this  should  fail, the
procedure has been determined to be undefined.

In the case of internal procedures, and external procedures, the text of
the  procedure  is executed  within  a  block of  its  own.   The RETURN



                                   33
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


statement  may  be  used to  return  a  value, as  well  as  the SUCCEED
statement or the FAIL statement.   If none of these are done,  the value
of the last statement executed in the procedure will be returned  as the
value of the procedure call when the end of the procedure is reached.

In the case of external programs, the program is executed.   The program
will hopefully read its arguments via the RESCAN UUO or by calls  to the
exec.  At  any time, the  program may execute  various functions  of the
exec call to return a value, succeed or fail.  At program termination as
the result of  "normal" means, any values  passed by exec calls  will be
returned as the value of the procedure call.  If no values were given, a
null is returned.  If  the program terminates by some  "abnormal" means,
such as ILL MEM REF or PDL OV or HALT, an appropriate error code will be
given as the return value of the procedure call.










































                                   34
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


                               Chapter VI                                

                           Runtime Procedures                            




The group of statements  or procedures which are implemented  within the
exec itself as SAIL procedures are called runtimes or primitives.  These
provide functions upon  which all other  functions may be  defined.  The
proposed set of runtimes are described below:



VI.1    Declarations        
These runtimes  declare and allocate  storage for data  structures which
are accessible to the user.  The declarations follow block  structure in
that they are only visible withing the block in which they  are defined,
and  in that  they are  deallocated  when the  block in  which  they are
defined is exited.


VI.1.1    IVAR, SVAR           
The IVAR statement and SVAR statement have the form
    IVAR <var1>,<var2>...<varn>
    SVAR <var1>,<var2>...<varn>
IVAR produces an integer variable; SVAR produces a string variable.  The
named  variables  are  declared  local to  the  current  block.   If the
variable exists in a surrounding block, the value of the new variable is
initialized to that of the one in the surrounding block,  otherwise, the
value is initialized to null.


VI.1.2    DEF          
The DEF statement is of the form
    DEF <proc> = <proc'>
    DEF <proc> = <val>
    DEF <proc> = <val> <val'>
In the former  case, <proc> is made  identical to <proc'>.  In  the last
two  cases, the  block  of code  <val>  is stored  (unevaluated)  as the
procedure body for <proc>.  In  the last case, the block of  code <val'>
is also storred (unevalueted) as the help handler for <proc>.  If <proc>
is called with a single argument of question-mark (?), the  help handler
will be evaluated rather than the body.

If <proc> is already defined in the current block, an error  is flagged.
(<proc> may be defined in a surrounding block without error)


VI.1.3    GLOBAL          
The GLOBAL statement has the form
    GLOBAL IVAR <var1>,<var2>...<varn>
    GLOBAL SVAR <var1>,<var2>...<varn>
    GLOBAL DEF <proc> = <proc'>


                                   35
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


    GLOBAL DEF <proc> = {<body>}
This statement causes the items  to be declared in the  outermost block.
If any variable with the same name exists anywhere, it is an error.



VI.2    Execution Control         


VI.2.1    IF          
The IF statement has the form
    IF <be> THEN <val> ELSE <val'>
    IF <be> THEN <val>
    IF <be> ELSE <val'>
The value of  the statement is  the value of  <val> if <be>=true  or the
value  of  <val'> if  <be>=false.   Only  the <val>  to  be  returned is
evaluated.


VI.2.2    WHILE          
The WHILE statement has the form
    WHILE <be> DO <val>
The expresion  <be> is  evaluated repeatedly until  its value  is false.
After each evaluation which  is true, the expresion <val>  is evaluated.
The value of the last time <val> was evaluated is returned as  the value
of the statement.  If <val> is not evaluated (for any reason), the value
returned  is  null.   The  loop  may  also  be  terminated  by  the DONE
statement.


VI.2.3    UNTIL          
The UNTIL statement has the form
    UNTIL <be> DO <val>
The  expresion <be>  is evaluated  repeatedly until  its value  is true.
After each evaluation which is false, the expresion <val>  is evaluated.
The value of the last time <val> was evaluated is returned as  the value
of the statement.  If <val> is not evaluated (for any reason), the value
returned  is  null.   The  loop  may  also  be  terminated  by  the DONE
statement.


VI.2.4    FOR          
The FOR statement has the form
    FOR <var> = <val1> TO <val2> BY <val3> DO <val'>
    FOR <var> = <val1> TO <val2> DO <val'>
    FOR <var> = <val1> BY <val2> DO <val'>
    FOR <var> = <val1> DO <val'>
    FOR <var> OF <val1>,<val2>,<val3>...<valn> DO <val'>
<var> is  a declared  variable which is  assigned various  values before
evaluating <val'>.   The value  of the  statement is  the last  value of
<var> for which <val'> was  evaluated.  If <val'> is not  evaluated (for
any reason), the returned value is null.




                                   36
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


VI.2.5    REPEAT          
The REPEAT statement has the form
    REPEAT <val>
    REPEAT <val> UNTIL <val'>
    REPEAT <val> WHILE <val'>
The value of <val>  is computed repeatedly.  After each  evaluation, the
termination condition is tested by evaluating <val'>.  If  the condition
is  met (UNTIL  TRUE or  WHILE  FALSE), the  loop is  exited.   The DONE
statement may be used to exit regardless of the termination condition.


VI.2.6    DONE          
The DONE statement has the form
    DONE
The immediately enclosing loop is exited unconditionally.   This applies
to FOR, WHILE and REPEAT.


VI.2.7    NEXT          
the NEXT statement has the form
    NEXT
The remainder of the current iteration of the immediately enclosing loop
is  skiped.   The next  value  of  the iteration  variable  (if  any) is
assigned  and the  termination  condition (if  any) is  tested.   If the
termination condition is met, the loop terminates as normal.  Otherwise,
the loop body  is reevaluated from the  beginning with the new  value of
the iteration variable.


VI.2.8    CASE          
The CASE statement has the form
    CASE <val> OF {<val1> <val2> <val3> ... <valn> else <val'>}
    CASE <val> OF {[<val1>]<val1'> [<val2>]<val2'> ... else <val'>}
In the  unlabeled case  (first one), the  <val>'th item  in the  list is
evaluated and  its value returned.   If there is  no <val>'th  item, the
else item  is evaluated.   In the  labeled case,  the item  whose square
bracketed value  matches <val>  is evaluated.  If  none match,  the else
item is evaluated.  The else item is optional.  The " "               is
interchangeable with a <crlf>.  In  the labeled case, the values  may be
strings.  Note that if more  than one label is satisfied, they  will all
be  evaluated  and  the  last one  will  be  returned.   This  makes the
following reasonable:
        CASE true OF {
                [a=b] {TYPE "A=B"}
                [c=d] {TYPE "C=D"}
                [a=c] {TYPE "A=C"}
                else {TYPE "Nothing is equal!"}
        }

Note that order of execution is guaranteed.






                                   37
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


VI.2.9    QUIT          
the QUIT statement has the form
    QUIT
The current  instantiation of the  exec is terminated.   The job  is not
logged off.   Control passes  to the parent  or to  COMCON if  no parent
exists.



VI.3    Subsystem Command Generators          


VI.3.1    DO          
The DO statement has the form
    DO <val> WITH <val'>
The value  of the statement  is the value  of <val>, which  is evaluated
exactly once.   <val'> is  a dependant co-routine  (is evaluated  at the
same time as <val>) which supplies the standard input for  any functions
called by <val>.  The statements listed below are used within  <val'> to
provide input data and test the state of <val>.


VI.3.2    STEXT          
The STEXT statement (send text) has the form
    STEXT <val>
The string value of <val>  is provided as standard input to  the primary
statement of the enclosing DO statement.  This is only legal  within the
scope of the WITH clause of the DO statement.


VI.3.3    PLINE          
PLINE (prompt line) is  a special procedure variable which  contains the
last line of text sent  to the standard output by the  primary statement
of  the enclosing  DO statement.   The PLINE  procedure will  not return
until  the primary  statement  is waiting  for input  from  its standard
input.  This is only legal within the scope of the WITH clause of the DO
statement.



VI.4    Infix Operators         


VI.4.1    Arithmetic          
The  operators  "+","-","/"  and  "*"  perform  the  appropriate integer
arithmetic  on the  two operands.   If the  operands contain  other than
digits, the results will be undefined.


VI.4.2    Assignment          
The operator "_" (underscore) will provide assignment.  The  variable on
the left will be assigned the value of the expression on the right.  The
value of the operation will be the value assigned.



                                   38
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


VI.4.3    Comparison          
The operator "="  (equals) is used to  compare strings to  be identical.
Note that (0=00)  is not true because  the comparison is done  in string
mode.  It should be noted  however, that numeric values produced  by any
exec function will  always be canonical  integers, therefore, it  is not
unreasonable to  perform the  comparison in this  way for  integers (ie.
(00+0=0+0) is true).

An alternate  implementations is  to determine  if the  operands contain
only  digits  and  signs.   If  so,  the  comparison  would  be numeric,
otherwise, it would be string.  This  is not as much a problem  with "="
as it is with "<" and ">".

Yet  another alternate  implementations is  to use  another  operator to
compare strings (such as "?").


VI.4.4    Booleans          
The  operators "or"  and "and"  perform the  obvious  boolean functions.
These are not the bitwise logical functions.



VI.5    Token Retrieval         
In order to scan the  arguments to a procedure (command),  the following
runtimes may be  called from within a  procedure only to  return various
parameters which appear in the procedure call.

Note that most of the following routines have optional arguments  of the
form
    DEFAULT:<val>
    PROMPT:<val>
    ERROR:<val>
Should the DEFAULT clause be  missing, then the field is  mandatory:  it
will be prompted for if missing.  The PROMPT clause is the  message used
to obtain the value if a "?" was entered or if the field is  ommited and
there is no default.  Prompting  is available only when input is  from a
physical terminal.  If  the ERROR clause  is provided, no  error message
will be  issued if any  errors are detected,  rather an error  code (and
perhaps  message)  will  be  assigned  to  the  variable  and  the error
expresion will be evaluated.  The error expresion may use the statements
NEXT and DONE.  Any combination of these clauses is legal in any order.


VI.5.1    GETVALUE          
The GETVALUE statement has the form
    GETVALUE <var>
    GETVALUE <var> <clauses>
The value returned  is the value from  evaluating the next token  in the
procedure call  in the  context in  which the  procedure call  was made.
Multiple token expressions  are permited if they  are enclosed in  () or
{}.  If no more input exists in the procedure call, null is returned.




                                   39
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


VI.5.2    GETIVAL          
The GETIVAL statement has the form
    GETIVAL <var>
    GETIVAL <var> <clauses>
This identical to GETVALUE except  that it is an error if  the resulting
value is not an integer.


VI.5.3    GETTEXT          
The GETTEXT statement has the form
    GETTEXT <var>
    GETTEXT <var> <clauses>
This runtime will  scan exactly as far  as the GETVALUE runtime  but the
arguments will not be evaluated.  Everything scanned will be returned as
a string.


VI.5.4    GETTOKEN          
The GETTOKEN statement has the form
    GETTOKEN <var>
This  runtime will  return exactly  one unevaluated  token.  If  no more
input exists in the procedure call, null is returned.


VI.5.5    GETREFERENCE          
The GETREFERENCE statement has the form
    GETREFERENCE <var>
The next token  in the procedure  call is expected to  be the name  of a
variable.   This  routine  makes the  given  variable  into  a reference
variable.   The  variable may  be  used  in any  context  that  a normal
variable  may be  used but  assignments and  reads to  it  will actually
reference the variable named in the procedure call.


VI.5.6    RESCAN          
The RESCAN statement will return  the entire (including the call  to the
procedure) command line as one string.



VI.6    String Functions         


VI.6.1    SUBSTR          
The SUBSTR statement has of the form
    SUBSTR <val> <val1> <val2>
The  <val1> through  <val2>'th characters  of <val>  are  returned.  The
special  variable "$"  may be  used in  <val1> or  <val2> to  denote the
length of  the string.   That is  {SUBSTR "ABCD"  2 ($-1)}  would return
"BC".






                                   40
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


VI.6.2    LENGTH          
The LENGTH statement has the form
    LENGTH <val>
The length of <val> in characters is returned.



VI.7    Frame Operations         


VI.7.1    ERUN          
The ERUN statement has the form
    ERUN <prog>
    ERUN <prog> <val>
The program named will be run in a seperate fork.  When it is completed,
the fork will be destroyed and the previously current fork will  be made
current again.  If <val> is given, it is the core assignment in K.


VI.7.2    RUN          
The RUN statement has the form
    RUN <prog>
    RUN <prog> <val>
The program named will be run in the current fork.  The  current program
if any will be overlaid.  If  <val> is given, it is the  core assignment
in K.


VI.7.3    XEXEC          
The XEXEC statement has the form
    XEXEC
    XEXEC <prog>
The  named  program  replaces   the  current  exec  (all   children  are
destroyed).   The  default is  to  place  the user  in  XEXEC  mode (for
compatibility).





















                                   41
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


                              Chapter VII                               

                           Special Variables                            




There are a  number of variables which  are defined by the  exec.  These
typically have  special meaning as  described below:  Note  that reading
from and  assigning to  these variables  may have  side effects  (ie. do
things).



VII.1    Control Variables          
    ExecTrace          print statements as they are executed
    ProgSearch         list of dirs to run program from
    ImplyRun           if proc undefined, try running as program
    ImplyExec          if proc undefined, try command file
    MaxNest            max depth to allow block nesting (safety)
    TimeLimit          TRU limit to stop job after (0=never)
    SpareChild         number of spare children to keep
     ((incomplete))



VII.2    Information (read only)           
    DATE               current date as string
    TIME               current time as string
    XVER               version of XEXEC
    USER               user name
    TRUS               currently used TRUs
    CONN               connect time
    AUN                current AUN
    PPN                current PPN
    MVER               monitor version
     ((incomplete))



















                                   42
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


                              Chapter VIII                               

                             Macro Facility                              




Macros  will  be expanded  in  an expression  before  the  expression is
evaluated.  Macros will be expanded when found in arguments of a command
only when the  command asks for its  arguments (in fact, the  command is
not completely scanned until then).  There is one type of argument which
may be  declared for  a procedure  which will  not expand  its argument.
This is provided primarily to allow macros to be undefined or redefined.



VIII.1    Indirect Macros           
An indirect macro is not declared.  A call takes the form
    @filename
    @variable
    @(expresion)
    @{statement}
The atsign (@) is  part of the macro call  and it causes a  token break.
Note that  the closing  curly bracket  also causes  a token  break.  The
effect of this call is to substitute the contents of the named  file, or
the value of the variable, or  the value of the statement (which  may be
an infix  expression), for the  macro call.  The  apostrophe (')  may be
used for concatenation (see below).

Since the  "@" can be  detected by the  scanner's finite  state machine,
this type of macro is very efficient.  The trigger character (@)  can be
changed by  causing a  recompilation of the  finite state  machine.  The
scope of the trigger will always be global.



VIII.2    Signal Macros           
The  third type  of macro  call  is the  signal macro  after  the signal
response  mechanism of  the document  compiler PUB  [Tesler 1973].  This
facility allows the user to specify a template which acts as a macro
    AT <signal> <arglist> {<body>}
where
    <signal>    ::= "<sstr>"
    <arglist>   ::= <null>  |  <argspec> <arglist>
    <argspec>   ::= <pname> "<bstr>"
    <sstr>      ::= <<a signal string of any characters>>
    <bstr>      ::= <<a break string of any characters>>
    <pname>     ::= <<parameter name>>
    <body>      ::= <<a macro body>>

Whenever  the signal  string is  encountered (while  macro  expansion is
enabled), even in the middle of a token, the scanner is placed in signal
response mode.  In this mode, it will scan the arguments (which must all



                                   43
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


exist), and replace the text of the call with the macro body.  Note that
the  arguments  may contain  any  characters and  are  passed completely
verbatim.  If a signal response is declared with the same  signal string
as one previously declared,  it will supercede the  previous declaration
even if the arguments are totally different.  It is recommended that the
signal string and  the break string  contain at least  some punctuation.
If the break string is a blank, any of blank, tab or return will satisfy
the condition.

Signal macros will always have global scope.  They require recompilation
of the  finite state machine  to define and  undefine.  They may  not be
implimented due to excessive complication of the scanner.



VIII.3    Simple Macros           
A simple macro is declared with
    MACRO name (args) {body}
It is called  wherever its name appears  as a token.  An  apostrophe (')
which is immediately adjacent to a macro call will cause the  scanner to
generate a token break and then delete the character (known as the macro
concatenation symbol).  Thus the sequence
    MACRO foo {123}
    MACRO bar {456}
    DIR DSK:'foo'bar'.DAT,foo'bar'.LST
will expand to
    DIR DSK:123456.DAT,123456.LST

It has not yet been determined how macro parameters will be passed  in a
call.  Most likely  they will be  enclosed in macro  argument delimiters
(probably "<>") and immediately  follow the macro name.   The delimiters
may be made optional.

This type of macro would require an extra symbol table lookup  for every
token scanned and may not be implimented for efficiency reasons.





















                                   44
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


                               Chapter IX                                

                          Pipes and Pipelines                            




On the  issue of pipelines,  there are several  questions which  must be
resolved:
    1)  under what circumstances are they beneficial to the user?
    2)  under  what circumstances  are  they more  efficient  to the
        user?
    3)  what is the effect of long pipelines on system performance?
    4)  can some special scheduling algorithm be adopted  to improve
        their load on the system?
    5)  should there be special charging for their use?

On the issue of pipes, the  major problem is that they are  typically to
be used to carry off the output from some program into  another program.
The problem that  arises is that a  particular program may expect  to do
output to a terminal.  Another program may expect a disk file.  Thus,
    1)  how is a pipe to be connected to a program?
    2)  is there any hope for doing this with existing programs?
    3)  it is  important for  both AUXCALs and  CHANIOs to  work for
        pipes.
    4)  what  should  happen  when  a  program  attempts  an illegal
        operation on a pipe (ie. set baud rate, RENAME,  send yellow
        ball, etc.)?



IX.1    Pipes        
Pipes  may  also  be  known  as  pseudo  devices,  or  PTY's (pronounced
'pities').  Typically, a pipe will be used for two uses:
    1)  to simulate the command terminal
    2)  to simulate a non-existent device
Pipes  may also  be  used to  emulate  the function  of  sharable TTY's,
(pronounced 'shtities').  In the case of the non-existent  device, there
is no  compatibility problem  because the  user gets  to define  how the
device is  to operate.   In the  case of  the command  terminal however,
there are a large  number of existing programs which  have pre-conceived
notions of what a command  terminal is and what functions are  legal for
it.  More specifically,  the exec will want  to be able  to occasionally
pass a pipe to one of its children in place of the terminal in  order to
do such things as command file input and output to script files.

In the case  of the exec handling  command file input,  and simultaneous
script file  output, the exec  would create  a pipe and  pass it  to the
child as the command terminal.  Whenever the child requested  input, the
exec would read characters from the command file and send them  down the
pipe.  Any output received from the pipe would be sent to both  the real
terminal and to the script file.   Now, if the child program does  a set
output baud rate, the  exec should in turn do  the set baud rate  on the



                                   45
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


real terminal.   If the  child does a  rename on  the pipe,  this should
truely be illegal.



IX.2    Redirection of Terminal IO           
Although  pipes may  be  used to  emulate terminal  IO  redirection, and
indeed are necessary when output (for example) is to be directed to more
than one place as mentioned  above, it is desirable to have  the ability
within the  monitor to  redirect IO to  the command  port to  some other
device for  efficiency.  Note  that redirection is  anticipated to  be a
frequent  event.  The  fact  that the  exec  would have  to  handle each
character as it is passed  from the child program to its  destination is
not alone  significant.  The significant  inefficiency lies in  the fact
that in order to output one packet, the program must run and perform the
output call, the exec must then run to redirect the packet,  the program
will then run again to  produce the next packet, etc.   This alternation
will produce a  significant load on the  swapper and the  scheduler.  If
the  active  swapping  ratio  is 1  or  greater,  this  would  produce a
disastrous  effect similar  to  thrashing.  If  the program  were  to do
single character output calls  (which is quite common), the  packet size
would be  1.  The effect  is two trips  through the scheduler  to output
each character!

This problem could be relieved somewhat by providing buffers in pipes to
increase the effective packet size.   This is of course no help  for the
(few) cases where single character IO is actually necessary.



IX.3    Pipelines        
A pipeline is a the interconnection of a number of processors in  such a
way as the data flows  from some source, througheach of  the processors,
to some destination.  The processors are invoked simultaneously so as to
remove the necessity  of storing (all  of) the data  between processors.
It is  not clear that  this is a  gain or a  loss on a  single processor
timesharing system: the overhead of disk IO to entirely buffer  the data
between processes  is likely  to be  small compared  to the  overhead in
scheduling and swapping which  may be aggravated by thrashing.   One may
look at data  being passed between two  or more processors via  pipes in
the same way as we looked at the emulation of IO redirection  above.  In
fact it is technically the same  problem because the exec is in  a sense
processing  the data  in a  pipeline fashion  from the  program.  Please
refer to the above section on redirection.












                                   46
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


                               Chapter X                                

                           PTY related things                             




This  section  has  some  preliminary notions  on  how  to  handle PTY's
internally for the support of command files and recording  files.  These
thoughts are not final - are subject to change.



X.1    Definitions       
The following abbreviations are used throughout this section:
    ESID   exec standard input device
    ESOD   exec standard output device
    ESED   exec standard error device



X.2    User Interface        
The typical way to specify the standard devices for the exec is with the
commands:
    @filespec
    XEXEC filespec
    OPEN filespec INPUT [APPEND]
    OPEN filespec OUTPUT [COPY] [APPEND]
    OPEN filespec ERRORS [COPY] [APPEND]
    CLOSE INPUT
    CLOSE OUTPUT
    CLOSE ERRORS
Note that the  default frame devices are  the same as  the corresponding
exec devices.  The INPUT  file records all characters received  from the
current  standard input  device.   Note that  if the  standard  input is
changed with the @ command or something, this will not be seen:
    OPEN INPUT.REC INPUT
    @FOO.X
    CLOSE INPUT
will cause the file INPUT.REC to contain merely
    @FOO
    CLOSE INPUT
but the commands from file FOO.X will not appear in INPUT.REC.

If  COPY is  specified, the  output is  copied to  the file  and  to the
terminal.

If APPEND is specified, the  file is appended to if it  exists otherwise
it is created.







                                   47
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


X.3    When PTYs are required          
How to decide when a PTY is required:
    1)  When a frame is created and ESID is not a port.
    2)  When a OPEN command is given.



X.4    When PTYs are not required           
    1)  When there are no more reasons for having one.

There ought to be a count associated with a PTY indicating the number of
reasons for its  existance.  Each reason calls  PTYREL when it  is done.
PTYREL decriments this count and  if it reaches 0, then it  destroys the
PTY.



X.5    Things that Control PTYs          
This section describes  (mostly be pseudo  code) some routines  that are
currently expected to be the way to handle the PTYs.  This will  give an
idea of how things are structured.  This is very subject to change.


X.5.1    SCNSER: main port service routine             
SCNSER runs all the time (except for suspend due to interrogate).  It is
awakened by  interrupt driven events  (deffered!cause!on!interrupt).  It
polls all ports and takes the appropriate action.  Sometimes  the action
is immediate, and sometimes it involves waking another process.

procedure SCNSER                ! PRI=1, always present
forever do
    interrogate (PortCause)     ! wait for an interrupt
    POLPRT 
    for each PORT do
        while BITS do
            case JFFO(BITS) of
                [Zap] cleanup port stuff (and frame too?)
                [Char] resume RCVCHR
                [Lose] incriment counter
                [YBall] send YB to STD OUT
                [OBall] get char from STD IN or put on queue
                [Gobbler] send Gobbler to STD OUT


X.5.2    RCVCHR: handles characters from PTY             
RCVCHR is a process per PTY that runs at a high priority  slightly lower
than  SCNSER.   These are  created/destroyed  with the  PTY.   RCVCHR is
awakened whenever a PTY gets a character.  It sends the character on its
way to the standard output  device, which may block.  It is  awakened by
SCNSER by a resume.  This is  necessary so that events don't pile  up in
the event queue while the standard output is busy.

procedure RCVCHR                ! created along with port, PRI=2
forever do


                                   48
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


    suspend(myproc)
    while CharAvailable(port) do
        STDOUT(PORTIN(port))


X.5.3    SNDCHR: handles characters to PTY             
When SCNSER gets an OrangeBall, it means the frame is hungry and must be
fed a character.   Only one character may  be sent to avoid  type ahead.
SCNSER calls the routine SNDCHR which will immediately send  a character
if one is available, otherwise, it  will set a flag so that when  a char
is available, a YB will get  sent on the port who wanted  the character.
This will eventually result in SNDCHR getting called again.

procedure SNDCHR
integer char;
if STDIN(char) 
    then 
        PORTOUT(port,char)
        YBOUT(port)
    else 
        NeedYB _ port



































                                   49
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


                               Appendix A                                

                                Schedule                                




The  project  is divided  into  tasks  which are  measured  in  units of
manpower  called "units".   A  unit represents  3 man-days  of  work, or
typically 1 week of elapsed time.  This definition is subject to change.

The following tasks  are proposed at this  time and are  not necessarily
shown in the order of execution.  The approximate time involved is shown
and is subject to change.



    Fourth quarter     
The following is expected to be completed during fourth quarter 1979:

    1)  background research [2 units]
        Do research on grammar types, compiler design tools, etc.

    2)  survey of existing executive languages [2 units]
        Research  as  many  executive  languages  as   possible  and
        evaluate the advantages each would present in the context of
        our system.  Also evaluate any languages which have features
        or  grammars  which  relate  to  the  exec   language  being
        proposed.  Include comments on each in the journal.

    3)  define expected requirements of language [1 unit]
        Define  (in general  terms)  the known  requirements  of the
        language and provide specific examples illustrating possible
        methods of implementation.

    4)  define a proposed  grammar that meets  expected requirements
        [2 units]
        Publish  a  proposed  definition  of  the   language(s)  for
        evaluation by other groups.  Obtain feedback.

    5)  propose a set of primative functions [1 unit]
        Outline the function  and syntax of any  primative functions
        that are required.

    6)  reevaluate the proposed language [3 units]
        Call  a meeting  of all  interested parties  to  discuss the
        original proposal.  Based on the feedback from  the meeting,
        draft  a  final  proposal with  sufficient  detail  to begin
        implementation.

    7)  outline the  internal implementation  of the  interpreter [1
        unit]
        Provide a  sketchy outline of  the internal  organization of
        the interpreter.


                                   50
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


    First quarter 1980      
Expectations for the first quarter of  1980 are to have a subset  of the
proposed exec running and in  use by internal users and  perhaps certain
special customers.  This version of the exec would:
    1)  be able to entirely replace COMCON
    2)  be able to replace some functions of RPG.
    3)  support only one subordinate process
    4)  process commands from files
    5)  direct output to files
    6)  provide simple error handling
    7)  support simple deferred scheduling (a la PERP)
    8)  not support goto's or exits through multiple levels
    9)  not support compiled external functions
    10)  not support Katakana
    11)  support only the "@" style macros
    12)  perform statistical analysis and performance analysis
    13)  support some services for children



    Second quarter 1980      
At  the end  of first  quarter  1980, the  project has  been  delayed by
several weeks due to the following items:
    1)  lack of network access
    2)  PTY development
    3)  completion of framing uuos
    4)  RESCAN simulation development
These items were originally  scheduled to be completed earlier  and have
formed a critical path.  The completion of the framing  project involves
writting  several UUOs,  and rearranging  access rights.   I  will later
outline the specific changes that are necessary.  The  implimentation of
PTYs and the enhancement of RESCAN has prevented running anything except
detached jobs under the EXEC.

Below is a description of the  EXEC as it is expected to exist,  on June
30:
    1)  The  following  commands  will  be  processed  by  the EXEC:
        ATTACH, BYE, CCONTINUE,  CONTINUE, CORE 0, CSTART,  D, DATE,
        DAYTIME, DDT, DETACH, E, EXIT, GET, GO, KJOB, LOGOUT, PDP10,
        PJOB, PPN,  R, REENTER, RUN,  SAVBIN, SAVE,  SAVEBIN, SSAVE,
        START, TYMEX, VERSION, XEXEC,
    2)  The following  commands will be  supported by  calling other
        programs, including RPG and SYSTAT:  10EDIT, AID,  APL, CAL,
        CDEBUG, CFORTRAN, COMPILE,  COPY, CREATE, CREF,  CROSS, CT1,
        CT2,  CT3,  CT4,  CT5, CT6,  CT7,  CT8,  CT9,  CTEST, DEBUG,
        DECLARE,  DEFER,  DELETE, DIFFERENCES,  DIRECT,  DO, EDITOR,
        EXECUTE, FDC,  FDEBUG, FILES,  FTMAGNUM, GEXEC,  GFD, HELLO,
        HELP, LIST, LOAD, MAGNUM, MAIL, MAKE, MODIFY,  NBASIC, NEWS,
        OPER,  OPNOTICE,  PASSWORD, PERFORM,  PFDC,  POSTMAN, PRINT,
        PROJEC,  PSP, RENAME,  SEND, SETE,  SFORTRAN,  SPOOL, SYSNO,
        SYSTAT,  TAPE,  TBA,  TECO, TRY,  TYPE,  USERS,  WHERE, WHO,
        XBASIC,
    3)  The  following  commands  will  not  be  supported:  ADRBRK,



                                   51
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


        ASSIGN,  CLOSE,  CORE   n,  DEASSIGN,  DSK,   FINISH,  HALT,
        JCONTINUE, PCHECK, REASSIGN, RESOURCES, SCHEDULE, SET, TALK,
        TIME, TTY, VMINFO, WATCH,

The following terminal features will be implimented (using PTY's):
    1)  Command file input.
    2)  Record  file  output  (may  be  simultaneous  with  terminal
        output).
    3)  There  will  be  no  provision  for  filtering  output  from
        programs.

The following special  features will be  available in the  EXEC language
itself:
    1)  Leaving a block
    2)  Repeating a block
    3)  "@" style macros
    4)  Limited service to children: RESCAN

The following UUOs must be written to complete the current phase of EXEC
development:
    1)  !FOGET, !FORUN, !FOSAV,  !FOSSA:  get, run and  save another
        frame's  core  image;  needed  for  GET,  RUN,  SAVE, SSAVE,
        SAVEBIN and SAVBIN commands.
    2)  !FORES:  do a reset  on another frame's devices;  needed for
        FINSIH and CLOSE commands.
    3)  OPR:   make  an  arbitrary terminal  be  the  oper terminal,
        return the  current oper terminal  name; needed for  SET OPR
        and SET NOTOPR commands.
    4)  !FOPRV:   set another  frame's JBTPRV  word; needed  for SET
        NOATT, SET  LOGOUT, SET  DETACH, SET  CONTIN and  SET TIMOUT
        commands.
    5)  !FOSTS:   set another  frame's JBTSTS  word; needed  for SET
        SCHPRV, SET CLRSPR commands.
    6)  HAPPY:   clear alarm  bits, etc;  needed for  the  SET HAPPY
        command.
    7)  !FOLIM:  set TRU limit for another frame; needed for the SET
        LIMIT command.
    8)  !FOWSC:  set another frame's working set size  limit; needed
        for the SET WSMAX command.
    9)  !FOLOK:  set lock bits for another frame; needed for the SET
        LOCK and SET NOLOCK commands.
    10)  !FOCOR:  do equivalent of CORE uuo for another frame, or at
        least set segment sizes; needed for the CORE command.
    11)  !FOSTP:  stop another frame like HALT or ^C do;  needed for
        the HALT command.
    12)  JCONT:  continue  another frame as  if by  operator; needed
        for the JCONTINUE command.
    13)  !FOABK:  set  address break for  another frame;  needed for
        the ADRBRK command.
    14)  ASSIGN:   assign  jobs  by  console,  make  logical  device
        assignments; needed for the ASSIGN command.
    15)  !FOWAT:   set another  frame's watch  bits; needed  for the
        WATCH command.  (this may be emulated by the EXEC)



                                   52
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


    16)  EXEC calli:  cause a trap to the EXEC, fail if no parent or
        no parent enabled.

The following  new interrupts  are necessary to  complete this  phase of
development:
    1)  Child asked for RESCAN
    2)  Child did EXEC call CALLI
    3)  Yellow ball received
    4)  Attempt to set terminal characteristics

The following changes must be  made to the access rights required  to do
various operations in order that the EXEC provide service  comparable to
COMCON:
    1)  must be able  to read halt status  block ALWAYS in  order to
        print  advisory  and  diagnostic  messages  such  as "xxxxxx
        SETUP", "ILL MEM REF AT USER xxxxxx", etc.
    2)  must always be able to continue execution of a stopped frame
        as is done by the CONTINUE command provided that JERR is off
        (access  rights  for this  might  be okay,  it  may  just be
        broken).
    3)  !arATT and !arDET, attach and detach port rights need  to be
        reviewed.
    4)  !arTKP should be  !arTKC, in all cases,  it is okay  to take
        away a frame's parent, but taking a frame's child  should be
        restricted (ie. all parent's should have the right to disown
        their children).

In addition, some type of handle needs to be developed which is based on
the union of license and  access rights, which becomes invalid  when the
universal frame id changes.


























                                   53
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


                               Appendix B                                

                             Correspondence                             






Solon 11-Oct-79 

    Bill,

    Just a thought about the EXEC processor.  It might be  useful to
    have the concept of what is executable extended a little  bit in
    the command  processor to consider  command files  (whatever you
    will  call them)  executable  and to  apply file  security  in a
    similar manner.

    This  would allow  you  to have  a  command file  that  could be
    executed by someone without them being able to read it.

    HF license should be  similarly extended so that a  command file
    with HF could run another command file on its home  directory or
    run a program on its home directory even though the job  may not
    have access to the files.

    Sam

Indeed  this is  a very  useful feature  to have.   It is  impossible to
implement  in  an unlicensed  exec  processor unless  the  user  were to
actually save a  core image file containing  a data segment  which holds
the exec command file and a  bootstrap routine to bring up the  exec for
which it was written.  In this manner, when a person put license  on the
file,  he would  be blessing  not  only the  command file  but  the exec
processor.  Both must be trusted.




















                                   54
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


                               References                               





[Aho and Ullman]
    Alfred V. Aho; Jeffrey  D. Ullman. "Principles of  Compiler Design".
    Addison-Wesley, Reading, MA, 1977.

[Andrews, Boli, Poggio 1977]
    Donald I. Andrews;  Beverly R. Boli; Andrew  A. Poggio. "A  Guide to
    the Command Meta Language and the Command Language Interpreter". SRI
    Augmentation Research Center, 28744, Menlo Park, CA, January 1977.

[B1700]
    Burroughs. "B1700 System Software Operational Guide". publication no
    1068731, El Monte, CA, January 1976.

[Birtwistle, Dahl, Myhrhaug and Nygaard 1973]
    G M  Birtwistle; O-J  Dahl; B Myhrhaug;  K Nygaard.  "SIMULA BEGIN".
    Petrocelli/Charter, New York, 1973.

[BTL PG-1C300]
    Bell Telephone Laboratories  UNIX Support Group.  "UNIX Programmer's
    Manual;  section SH(I):  Shell  (Command Interpreter)".  pub  no PG-
    1C300, Murray Hill, NJ, March 1977.

[CC 0271]
    Computer Complex. "Executive Reference Manual". pub  no S001:R-0271-
    00, Houston, 1971.

[CDC 1977]
    Control Data Corp. "NOS version 1 Reference Manual". vol 1,  secs 4-
    6,12, St Paul, July 1977.

[Dahl and Nygaard 1966]
    Ole-Johan Dahl; Kristen Nygaard. "SIMULA - an ALGOL-Based Simulation
    Language". CACM, vol 9 no 9, September 1966.

[DEC 4166C]
    Digital Equipment Corporation. "DECSYSTEM-20 Monitor Calls Reference
    Manual". pub no AA-4166C-TM, Maynard, MA, January 1978.

[DEC 4179B]
    Digital Equipment Corporation.  "DECSYSTEM-20 User's Guide".  pub no
    AA-4179B-TM, Maynard, MA, May 1977.

[DEC OBOGA]
    Digital  Equipment   Corporation.  "DECSYSTEM-20   Batch  Operator's
    Guide". pub no DEC-20-OBOGA-A-D, Maynard, MA, February 1976.

[DEC OBRMA]



                                   55
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


    Digital   Equipment  Corporation.   "DECSYSTEM-20   Batch  Reference
    Manual". pub no DEC-20-OBRMA-A-D, Maynard, MA, February 1976.

[Goldberg 1977]
    Adele Goldberg. "Smalltalk in  the Classroom". Xerox PARC  paper SSL
    77-2, Palo Alto, CA, June 1977.

[Goldberg and Kay 1977]
    Adele  Goldberg; Alan  Kay.  "Methods for  Teaching  the Programming
    Language Smalltalk". Xerox PARC paper SSL 77-2, Palo Alto,  CA, June
    1977.

[Goldberg and Robson]
    Adele  Goldberg;  David  Robson.  "A  Metaphor  for  User  Interface
    Design". Xerox PARC Learning Research Group, Palo Alto, CA.

[Gries 1971]
    David  Gries.  "Compiler Constuction  for  Digital  Computers". John
    Wiley & Sons, New York, 1971.

[Helliwell 1980]
    Dick  Helliwell. "documentation  for  the program  DO".  Stanford AI
    Project, DO.RPH[UP,DOC], Stanford, CA, May 1980.

[HIS AG92A]
    Honeywell   Information  Systems.   "Multics   Programmer's  Manual:
    Commands and Active Functions".  pub no AG92A, Waltham,  MA, January
    1975.

[IBM GC20-1818-1]
    International Busines  Machines. "IBM Virtual  Machine Facility/370:
    CMS   Command  and   Macro  Reference;   section  5:   EXEC  Control
    Statements". pub no GC20-1818-1, Poughkeepsie, NY, August 1977.

[Ingalls 1978]
    Daniel H.  H. Ingalls. "The  Smalltalk-76 Programming  System Design
    and Implimentation". Proc. of the 5th Annual ACM Sym.  on Principles
    of Programming Languages. Tuscon, Arizona, January 1978.

[Kay 1977]
    Alan Kay. "Microelectronics  and the Personal  Computer". Scientific
    American, vol 237 no 3, September 1977, pp 230-244.

[Kay and Goldberg]
    Alan Kay; Adele  Goldberg. "Personal Dynamic Media".  IEEE Computer,
    March 1977, pp 31-41.

[Knuth 1974]
    Donald E. Knuth. "Structured Programming with go to Statements". ACM
    Computing Surveys, vol 6 no 4, December 1974.

[Lewis 1977]
    Ellen  Lewis. "An  Introduction to  ITS for  the MACSYMA  User". MIT



                                   56
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


    Laboratory  for  Computer  Science, Mathlab  memo  no  3, Cambridge,
    October 1977.

[Lewis, Resenkrantz and Stearns 1976]
    Philip Lewis; Daniel Rosenkrantz; Richard Stearns.  "Compiler Design
    Theory". Addison-Wesley, Reading, MA, 1976.

[Mitchell, Maybury and Sweet 1979]
    James  Mitchell;  William  Maybury;  Richard  Sweet.  "Mesa Language
    Manual". Xerox PARC Systems Development, CSL-79-3 version  5.0, Palo
    Alto, CA, April 1979.

[Morrison 1978]
    J.  P.  Morrison.  "Data  Stream  Linkage  Mechanism".  IBM  Systems
    Journal, vol 17 no 4, 1978.

[Perron 1975]
    Robert Perron. "User's Guide to the Troll Macro  Facility". National
    Bureau  of Economic  Research Computer  Research  Center, Cambridge,
    April 1975.

[Ritchie and Thompson 1974]
    Dennis  M. Ritchie,  Ken Thompson.  "The UNIX  Time-Sharing System".
    CACM, vol 17 no 7, July 1974.

[SDS 1969]
    Scientific  Data Systems.  "SDS  940 Time  Sharing  System Technical
    Manual". pub no SDS 90 11 16C, El Segundo, CA, March 1969.

[Shoch 1979]
    John Shoch. "An Overview of the Programming  Language Smalltalk-72".
    Sigplan Notices, vol 14 no 9, September 1979, pp 64-73.

[Tesler 1973]
    Larry  Tesler. "PUB:  The  Document Compiler".  Stanford  AI Project
    operating note 70, Stanford, CA, July 1973.




















                                   57
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record


                                 Index                                 




&BEGSTACK  4                          COMND JSYS  21
&CONTROL statement  3                 comparison  39
&ERROR statement  4                   compiled external function  27
&STACK  4                             compiled external functions  51
&STACK FIFO <line>  4                 Computer Complex  14
&STACK LIFO <line>  4                 concatenation  43
                                      concatenation symbol  44
                                      concurrent processes  7
.BREAK 12, instruction  17            console stack  4
.BREAK 16, instruction  16            Control Data Corp  15
.LOSE uuo  17                         control registers  15
.SUSET uuo  17                        core image file  33
.VALUE instruction  16                curly bracket  43
                                      current exit mode  15
                                      Cyber  15
abnormal termination  17
accept links  14
ACCEPT LINKS command  14              DDT  16
active swapping ratio  46             deallocation  12
advice  16                            debuging  3
albatross  27                         DecSYSTEM-20  10
ampersand  8                          DEF statement  35
apostrophe  43, 44                    DEFAULT clause  39
arithmetic  38                        DELETE statement  12
assignment  38                        diagnostic messages  12
atsign  43                            DO file segments  24
                                      DO program  24
                                      DO statement  38
Batch  10                             do-with  28
baud rate  45                         DO-WITH statement  38
Bell Labs  6                          dollar-sign  8
Bell Telephone Laboratory  6          DONE statement  37
break string  43                      Dynamic Debugging Tool  16
brick  25
buffers in pipes  46
                                      EP  10
                                      equals  39
CALL statement  15                    ERROR clause  39
canonical integers  39                error handler  30
CASE statement  37                    error output  6
CDC  15                               error trapping  4
CMS command  3                        errors  12
CMS EXEC Control Language  3          ERUN statement  41
CMS operation system  3               escape character  25
COMCON  1, 27, 51                     event driven control structure  19
COMCON vs exec  27                    exec call  34
command file  28                      EXEC file  3
command files  28                     exec profile  28
command processor  12                 exec vs COMCON  27
commands  27                          ExecTrace  42

                                   58
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record







execution control  36                 infix expression  33
executive  1                          infix operators  38
executive system  27                  init program  28
external function  27                 input buffer  24
external procedure  3, 33             integer variable  35
external procedure extension  33      internal function  27
external procedure search list  33    internal procedures  33
external procedures  33               interrupts  6
external program  27                  introduction  1
external program search list  33      iteration variable  37
                                      ITS  16
                                      IVAR statement  35
FAIL statement  34
FIFO order  4
file segments  24                     JCL  16
first in first out  4                 job control file  10
flow control  36
FOR statement  36
function oriented language  18        Katakana  51


general specifications  27            last in first out  4
GETIVAL statement  40                 Learning Research Group  18
GETREFERENCE statement  40            LENGTH statement  41
GETTEXT statement  40                 LIFO order  4
GETTOKEN statement  40                LINK command  14
GETVALUE statement  39
global  6
GLOBAL statement  35                  macro body  43
global variables  12                  macro manipulation  25
goto  51                              macro processor  12
GOTO statement  12, 15                macros  43
grammar  31                           Massachusetts Institute of
                                         Technology  16
                                      MaxNest  42
HALT  34                              MIT  16
help handler  35                      multiple processes  6, 7


IF statement  15, 36                  Network Operating System  15
IFARG(0)  13                          NEXT statement  37
ifargs  12                            non-existent device  45
IGNORE statement  12                  normal termination  16
ILL MEM REF  34                       NOS control language  15
ImplyExec  42                         numbered arguments  12
ImplyRun  42
Incompatable Time-Sharing
   system  16                         object oriented language  18
indirect files  6
indirect macro  43

                                   59
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record







P033 monitor  27                      RPG  51
parameter name  43                    RSTS-E  10
Parameters  8                         RUN statement  41
partial links  16                     runtimes  33, 35
PDL OV  34
PDP-10  16
performance analysis  51              SAIL procedures  35
PERP  51                              scheduler  46
pipeline  7, 46                       SCNSER  48
pipelines  45                         semantics  33
pipes  7, 45                          semicolon  8
PLINE  38                             send text  38
POX convention  25                    services for children  51
previous error  15                    sharable TTY's  45
primative function  27                shell  6
primative function library  28        side effects  15, 16
primative functions  35               signal macro  43
primative procedures  33              signal response  43
procedure  33                         signal response mode  43
procedure body  35                    signal string  43
Procedure files  15                   signal traps  6
procedure search list  33             signals  6
procedures  27                        simple macro  44
profile  28                           simulate a non-existent device  45
ProgSearch  42                        simulate the command terminal  45
PROMPT clause  39                     Smalltalk  18
prompt line  38                       SNDCHR  49
prompting  12                         SpareChild  42
pseudo devices  45                    special character generation  25
pseudo locations  16                  special characters  24
PTY control routines  48              special variables  42
PTY user interface  47                specifications  27
PTY's  45                             stacking  4
                                      standard input  3, 6
                                      standard output  6
question-mark  35                     standard system executive  1
QUIT statement  38                    StandardInput  28
quote characters  24                  Stanford AI  24
                                      statement  33
                                      statistical analysis  51
RCVCHR  48                            STEXT statement  38
readonly  6                           string variable  35
REFUSE LINKS command  14              stuffing the buffer  24
REPEAT statement  37                  SU-AI DO program  24
requirements  27                      SUBSTR statement  40
RESCAN statement  40                  SUCCEED statement  34
RESCAN UUO  34                        SVAR statement  35
reserved words  3                     swapper  46
return  33                            system procedure  15
RETURN statement  34

                                   60
Tymshare, Inc.             16:04 June 9, 1980           The XEXEC Record







tasks  50
termination condition  37
thrashing  46
TimeLimit  42
TMPCOR  12, 27
top-down command files  28
top-level EXEC  27
Tops-20  10
trace facility  3
traps  4, 6, 12
TROLL  12
Tymcom-370  3


underscore  38
units  50
UNIX operating system  6
UNTIL statement  36
user interface  1


valretting  16
variable deletion  12
variables  8


warnings  12
WHILE statement  36


Xerox PARC  18
XEXEC  1
XEXEC statement  41


yellow ball  45















                                   61
3X6h