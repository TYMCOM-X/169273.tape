.library RECORD.DFS;
.sec Evaluation of Existing Languages,LangEval:

In this section we take a look at several existing languages and
note their merits and demerits.
Some general purpose languages have been evaluated in that our
executive will contain a number of concepts shared 
by general purpose languages.
.SkipC; Ss VM/370: CMS EXEC Control Language,CMSeval:

The exec language most familar to people at Tymshare is probably the
one in use on the %Tymcom-370% systems under the %CMS operation system%.
This is known as the %CMS EXEC Control Language%.
This evaluation is based on documentation {BibRef CMS}
and extensive experience in using the
system for application programming.

.Sss Overview;
The language is well suited for the control of one process (does not
support multiple processes at all).
The EXEC does not normally process commands from the %standard input%
device, but rather is invoked only to process command procedures.
It is not block structured.
An exec procedure is contained in a file known as an EXEC file.
All variables declared in the procedure are local 
(there are 10 predeclared global variables available).
Procedure calls consist of a CMS command.
Invoking an %EXEC file% is a %CMS command% and this is the only way to
call an %external procedure%
(there is no way to declare an internal procedure).
All variables are strings usually containing one token.
Variables are expanded (their value is substituted) when the
command is scanned (except as they occur on the left of the "=" in
an assignment statement).
All variables and special %reserved words% begin with an ampersand "&".

.Sss Trace Facility; ind debuging; ind trace facility;
The %&CONTROL statement% allows several options to be specified which
simplify the debugging process.
All of these options are desired in one form or another.
The options are specified as arguments to the EXEC command
"&CONTROL" as follows.
{BibRef CMS}

.chart
==&CONTROL OFF\suppresses the display of CMS commands and of EXEC
control statements as they execute, and any return codes that 
may result from CMS commands.
==&CONTROL ERROR\displays only those CMS commands that result in an
error and also displays the error message and the return code.
==&CONTROL CMS\(default) displays each CMS command as it is executed
and all nonzero return codes.
==&CONTROL ALL\displays CMD command and EXEC executable statements as they
execute as well as any nonzero return codes from CMS commands.
==&CONTROL MSG\(default)
does not suppress the "FILE NOT FOUND" message if it is issued
by the following commands when they are invoked from an EXEC
procedure: ERASE, LISTFILE, RENAME, or STATE.
==&CONTROL NOMSG\suppresses the "FILE NOT FOUND" message if it is issued when
the ERASE, LISTFILE, RENAME, or STATE commands are invoked
from an EXEC procedure.
==&CONTROL TIME\includes the time-of-day value with each CMS command printed
in the execution summary, for example:
.continue
#####14:36:30 TYPE A B
.continue
This operand is effective only if CMS or ALL is also specified.
==&CONTROL NOTIME\(default)
does not include the time-of-day value with CMS commands
printed in the execution summary.
==&CONTROL PACK\(default) 
packs the lines of the execution summary so that surplus
blanks are removed from the displayed lines.
==&CONTROL NOPACK\does not pack the lines of the execution summary.
.endChart;

.Sss Error Trapping; ind error trapping; ind traps;
Another extremely useful feature of the CMS EXEC language is the
ability to trap errors without testing after each procedure call.
This is accomplished by the %&ERROR statement%.
The statement is followed by either the word &CONTINUE or an
executable statement.
This statement is executed whenever an error return is given from a
CMS command.

It may be more desirable to trap only those errors which have not been
resolved.
A method for resolving errors would have to be defined.
Any errors which have not been resolved would cause a trap when an
attempt was made to execute the next command.

.Sss Console Stack,CmsStack:
.ind console stack;
.ind &STACK; ind &BEGSTACK;
A commonly used feature of the EXEC language is the ability to specify
strings to be stuffed in the standard input stream.
This operation is known as %stacking%.
Lines may be stacked in either %FIFO order% (%first in first out%)
or %LIFO order% (%last in first out%).
These operations are accomplished by the EXEC commands
%&STACK FIFO <line>% and %&STACK LIFO <line>%.
This is not similar to the AUXCAL available in P033 monitors which
forces characters into the input buffer in that 
.MyList
--forced characters may be lost by the monitor;
--forced characters get intermixed with real characters.
.endList
Assuming that commands are being read from the terminal,
the following diagram shows the precedence of the various ways of
supplying input lines:
.begin verbatim group;

		-------
"buffer":       |  5  |   <-  TERMINAL INPUT
		|  0  |
		-------
		   |
		   |
		   |	-------
"console stack":   |	|  3  |	  <-  &STACK FIFO
		   |	|  1  |
	 	   |   =========
		   |	|  2  |
		   |	|  4  |	  <-  &STACK LIFO
		   |	-------
		   |	   |
		   |-------|------->  &READ

.end <<verbatim>> apart;

The above diagram shows the "buffering" and "stacking" of lines
from various different sources.
The input sequence was:

.chart
--<line [0] typed at terminal>
--&STACK FIFO [1]
--&STACK LIFO [2]
--&STACK FIFO [3]
--&STACK LIFO [4]
--<line [5] typed at terminal>
.endChart

6 successive reads (&READ) would result in reading the 6 lines in
the order [4] [2] [1] [3] [0] [5].

This can be paraphrased by saying that things are read in the following
sequence:

.myList
--all lines stacked LIFO (if any) in reverse order;
--all lines stacked FIFO (if any) in correct order;
--all lines entered from terminal in correct order.
.endList

.SkipC; Ss UNIX: Shell Command Interpreter,SHELLeval:

On the %Bell Telephone Laboratory% %UNIX operating system%,
commands are interpreted by a program known as the %shell%.
The evaluation of this language is based on documentation 
{BibRef SHELL},
{BibRef UTSS}
and some limited experience.
The opinions of people who use it regularly at %Bell Labs% have been
noted also.

.Sss Overview;
The SHELL language will support %multiple processes% in a significant
manner.
It is concise:
the syntax allows the user to invoke several processes with only
one command line.
It is somewhat block structured (compound statements are allowed in
certain contexts).
Variables may be declared as %global% by name.
.ind indirect files;
Indirect files are supported (using ".") and they can nest.
The %standard input%, %standard output% and %error output% devices
(files) may all (or any) be specified on the command line.
.ind signal traps; ind traps;
Traps may be enabled for several %signals% (%interrupts%).
All shell variables begin with the character "$" (dollar-sign).
Variables may be made %readonly% by a shell command so that no
future assignment statement can change their value.

.Sss Input/Output Redirection;
The shell allows the user to specify alternate input and output
files on the command line using special signal characters.
Implementation of this very desirable feature in such a way that
it will not conflict with programs that allow this under P033
will be a significant problem.
UNIX does it like this:

Before a command is executed its input and output may be redirected
using special notation interpreted by the shell.
The following may appear anywhere in a simple command or may precede
or follow a command and are not passed on to the invoked command.
{BibRef SHELL}

.chart 16
==<name\causes the file 'name' to be used as the standard input of
the associated command.
==>name\causes the file 'name' to be used as the standard output of
the associated command.
'Name' is created if it does not exist,
and superceded if it does exist.
==>>name\same as '>name' except if 'name' exists, it is appended to.
==%name\causes the file 'name' to be used as the error output of
the associated command.
'Name' is created if it does not exist,
and superceded if it does exist.
==%%name\same as '%name' except if 'name' exists, it is appended to.
==>%\causes the standard output to go to the error output.
==%>\causes the error output to go to the standard output.
.endChart

If any of standard input,
standard output or
error output
are not specified,
they default to the values currently in effect for the shell.

.Sss Pipelines;
If there are several programs to be run,
each one providing further processing of the previous,
a %pipeline% may be used to connect them. 
{BibRef DSLM} {BibRef SHELL}	
A pipline in the UNIX Shell is specified as a list of commands
seperated by a vertical-bar (|).
The effect is that each of the commands is executed in a seperate
process (frame) and linked to eachother with %pipes%.
The standard output of the first is the standard input of the second.
The standard output of the second is the standard input of the third.
Etc.
An example of this applied to Tymcom-X tasks would be
.chart
--DIR | SORT | PRINT
.endChart
The effect of this is to sort a 
directory and print it on the line printer.
It is similar in effect to
.chart
--DIR >TMP1 
--SORT <TMP1 >TMP2
--PRINT TMP2
.endChart
except that when specified as a pipeline,
all processes would execute in parallel.

It is not clear
that a pipeline would be any more efficient on a timesharing system.
It may be assumed that the only advantage lies in the fact that it
is (probably) not necessary to do as much disk IO.
This of course,
depends on the nature of the application being run in the pipeline,
and on the method of implementation of pipes.
It is also not clear what the impact of long pipes on the overall
system performance would be.
(see {SsRef pipes} on pipes)

.Sss Multiple Processes;
It was said earlier that the Shell handles multiple processes in
a significant way.
.ind multiple processes; ind concurrent processes;
UNIX Shell handles multiple (concurrent) processes as follows.
{BibRef SHELL}

A simple command is a sequence of non blank words seperated by blanks.
The first word specifies the name of the command to be executed.
Except where noted,
the remaining words are passed as arguments to the invoked command.
The command name is passed as argument 0.
The value of a simple command is its exit status if it terminates
normally or 200+status if it terminates abnormally.

A pipeline is a sequence of one or more commands seperated by a
vertical-bar (|).
The standard output of each command but the last is connected
by a pipe to the standard input of the next command.
Each command is run as a seperate process.
The shell waits of the last process to terminate.

A list is a sequence of one or more pipelines seperated by a
semicolon (;) or ampersand (&).
A list is optionally terminated with a %semicolon% (;) or
%ampersand% (&).
The effect of the various separators are:
.chart 20
--semicolon (;)\lists are executed sequentially
--ampersand (&)\lists are executed concurrently
.endChart

A side effect of lists being executed in parallel (with ampersand)
is that they are immune to interrupts and that errors are handled
differently.

.Sss Parameters and Variables;
Worthy of note is the way in which the shell handles variables
(parameters) which have no value.
%Parameters% and %variables% are recognized by the prefix of a
%dollar-sign% ($).
Formally,
.begin verbatim
    <param> ::=	$<id>  |  ${<id>}  |  ${<id><op><wd>}
    <id>    ::= <digit>  |  *  |  <name>
    <op>    ::= -  |  =  |  ?  |  +
    <wd>    ::= <a word>
.end

.chart 20
==$<digit>\substitute the value of the <digit>'th positional argument.
==$*\substitute the value of all positional arguments seperated by
single blanks.
==${<id>-<wd>}\if <id> has a value then substitute it;
otherwise substitute <wd>.
==${<id>=<wd>}\if <id> has a value then substitute it;
otherwise set <id> to <wd> and then substitute it.
==${<id>?<wd>}\if <id> has a value then substitute it;
otherwise print <wd> and exit.
==${<id>+<wd>}\if <id> has a value then substitute <wd>;
otherwise substitute nothing.
.endChart

(the following are not defined in UNIX Shell but are shown here
as extensions)
.chart 16
==${<id>--<word>}\if <id> has a value then substitute it;
otherwise print <wd>,
read a line and substitute the line read.
==${<id>==<word>}\if <id> has a value then substitute it;
otherwise print <wd>,
read a line,
set <id> to the line read and then substitute it.
.endChart

.Sss File Name Expansion;
Each command word is scanned for the characters *, ? and [.
If one of these characters appears then the word is regarded as
a file name pattern.
The word is replaced with a list of alphabetically sorted file
names that match the pattern.
If no file name is found that matches the pattern then the word is
left unchanged.

This is almost guaranteed to lose.
The worst problem is that it is impossible to specify a wild-card
string which causes the resulting expanded file name list to
exceed 256 characters in length.
It is also not desirable to assume that any argument containing these
characters is intended as a file name pattern.
Lastly,
a file name pattern may not always refer to the obvious structure:
it may for example refer to files on a tape or on another system.
Only the program (command) knows what it wants - if it needs it
expanded,
let it do a call to the exec to have it expanded after the fact.

.SkipC; Ss Tops-20 Batch System,BATCHeval:

The %Tops-20% operating system (on the %DecSYSTEM-20%)
has a utility called %Batch% which will process background and
defered jobs in an unattended fashion.
Many of the problems in such a system map to problems in
executing a non-interactive XEXEC procedure.
The evaluation of the features of Batch are based on {BibRef BRM}
and {BibRef BOG} as well as personal experience with the nearly
identical Batch for the DEC %RSTS-E% operating system.

.Sss Overview;
The system is designed to take command input from a deck of cards
or a %job control file%.
There is no concept of variables.
Processing is typically top down with the exception of special
action on labels.
There are two flavors of GOTO - one for forward references and
one for backward references.
There is no way to substitute parameters in a command line.
The most notable features are described below.

.Sss Error Detection;
Although very ugly,
Batch will detect errors in programs which have not been modified to
return an error code.
It does this by scanning for certain special characters in
column one of the terminal output.
Characters have the following significance:
.chart 8
--?\Severe error
--%\Minor error or warning
--[\Informative message
.endChart

Some extension of this method could be used to detect errors in 
unmodified P033 programs.
The suggestion is to use a statement such as %EP% to specify one
or more templates to be used to detect lines which are error messages.
For example,
.chart
--EP err EOL "?" errmsg EOL
.endChart
would look for a "?" in column 1 and if found,
would store the remaining characters on that line in variable ERRMSG.
The flag ERR would be set (which may cause a trap).

.Sss Directing the Command Stream;
Certain commands which one wishes to place in an XEXEC file are
intended for some subsystem (ie. SPOOL, SORT, etc.).
Batch solves this problem by looking at the first character of
a command.
The following assumptions are made about lines begining with the
indicated characters (some have been omited):
.chart 20
==* (asterisk)\The line is treated as input to a user program.
If there is no user job running,
this is treated as a comment.
=== (equal sign)\Same as "*" but <crlf> is suppressed.
==@ (atsign)\The line is treated as a tops-20 command.
$$Note: "@" is the Tops-20 monitor prompt*
If a user program is running (in input wait) then the program is
stoped (as if a ^C were sent).
==! (exclamation pt)\The line is a comment.
.endChart

This type of direction or filtering could replace the necessity
of a terminal input stack as described in {SssRef CmsStack}.
It is not clear that both are not desired.

.SkipC; Ss The TROLL Macro Facility,TROLLeval:
.ind TROLL;

The National Bureau of Economic Research has a system known as TROLL
which is used for economic, management and statistical research.
To supplement the command processor,
a macro processor was designed to allow complex manipulation of
command strings and flow.
The evaluation of this facility is based solely on 
the user guide {BibRef TROLL}.

.Sss Overview;
Commands to the macro processor are intercepted 
by the %macro processor%
during scanning and
never reach the TROLL %command processor%.
A macro is defined be creating a disk file with the desired name.
Arguments are read by referencing the variable &0.
Each time &0 is used,
the next value is read from the argument list.
The facility supports variables in the sense that
one can dynamically create any number of %numbered arguments%
and assign values to them without requiring that they ever be
specified in a call.
There also exists an entity called &%ifargs% which are not
worthy of further discussion.
With the exception of trapping %warnings% and %errors%,
the only flow control is the &%GOTO statement%.
The only block structure exists in the form of nested
macros.

.Sss Deallocation of Variables;
.ind variable deletion; ind deallocation;
The most unique feature of the TROLL macro facility is the
&%DELETE statement% which deallocates a variable (or argument).
Deallocation occurs automatically when the macro in which
the variable (argument) was defined in is exited.
This may be necessary to clean up %global variables% which have been
allocated for some temporary use (such as %TMPCOR%).

.Sss Prompting for Unspecified Values;
.ind prompting;
The macro facility provides a syntax for specifying a prompt string
to be used if the value of a variable is unass when it is 
referenced.
If the variable does have a value,
no action is taken.
The form is
.chart
--&variable"prompt message"
.endChart
The entire construct may appear anywhere where an variable may be
used.
If it is desired that the value be prompted for (if necessary)
at some point where it is not actually needed,
the &%IGNORE statement% may be used.
.chart
--&IGNORE &6"Enter var 6:" &7"Enter var 7:"
.endChart
The &IGNORE statement simply ignores (but evaluates) all of its
arguments.
If any of the variables are undefined,
their value is prompted for.
If a variable appears without a prompt string being specified,
and the variable is undefined,
TROLL issues a prompt for the data type that is expected
(ie. date, integer, position, etc.).

.Sss Trapping Errors and Warnings;
The TROLL system recognizes two levels of severity of %diagnostic
messages%: %warnings% and %errors%.
The user may set seperate %traps% for these events.
This is performed by the statements
.chart
--&WARNING <msg> <act>
--&ERROR <msg> <act>
.endChart
where 
.chart 8
--<msg> is either null or NOMSG to specify that the error message is
to be suppressed.
--<act> is one of &IGNORE, &RETURN, &EXIT, &ABORT or &GOTO.
.endChart
When the trap occurs,
the variable &%IFARG(0)% is loaded with the error code.

.SkipC; Ss Computer Complex Executive,CCEeval:
.ind Computer Complex;

This section deals with the Computer Complex Executive for the SDS-940.
The evaluation is based on documentation {BibRef CCERM} only.

.Sss Overview;
This executive is a superset of the one being used on the Tymcom-IX
systems by Tymshare.
Certain commands have changed name.
There is no flow control, conditionals or traps in the exec language.
Command files are executed until an error is encountered.
There are no variables.
Standard input and output can be diverted from the terminal to a
file by command.

.Sss Linking Terminals;
The only feature of this executive worthy of note is the ability
to link the controlling terminals of two jobs together.
When two terminals are linked together,
any character which would normally appear on either terminal,
appears on both - there is no effect on terminal input.
This is accomplished by giving the %LINK command% and specifying the
terminal to be linked to as an argument.
The link is established only if the %accept links% bit is set for
the receiving job.
This bit is set by the %ACCEPT LINKS command%, and cleared by the
%REFUSE LINKS command%.
The default is to refuse links.

This has considerable value for debugging and training as well as
everyday communication.
Note that it would be possible to link to a PERP job to monitor
its progress.

.SkipC; Ss CDC NOS Control Language,NOSCLeval:
.ind CDC; ind Control Data Corp; ind Network Operating System;
.ind NOS control language; ind Cyber;

The Network Operating System (NOS) for CDC Cyber series systems
incorporates a subsystem known as Control Language to handle commands.
The evaluation of this control language is based on 
documentation {BibRef NOS} and several months of experience.

.Sss Overview;
The control language will accept and evaluate expressions as
arguments of its commands where appropriate.
There are a number of system variables some of which are readonly.
There are three (3) user variables known as %control registers%
1, 2 and 3.
Some of the system variables have %side effects%,
for example,
assigning a new value to the variable SS places you in
a new subsystem.
%Procedure files% consist of a file containing control language
statements.
Procedures are called with the %CALL statement%,
or if the procedure is a %system procedure%,
it may be called by giving its name.
The contents of the control register variables are available to
programs and subsystems which are invoked.
The %current exit mode% and %previous error% are available to
the control language programmer through special variables.
The IF and GOTO statements provide flow control.
.ind IF statement; ind GOTO statement;
Reserved words and variables have no distinguishing syntax.

.SkipC; Ss ITS DDT,ITSeval:
.ind ITS; ind MIT; ind DDT;

The %Massachusetts Institute of Technology%'s
%Incompatable Time-Sharing system%
which runs on a %PDP-10%
incorporates a special version of DDT (%Dynamic Debugging Tool%)
as the executive language.
This evaluation of ITS DDT is based on documentation {BibRef ITS}
and personal experience.

.Sss Overview;
ITS DDT is an extremely obscure executive.
The idea however of always having a debugger around when you need it
is an obvious win.
If the debugger is easy to use and understand 
for the non-programmer,
which DDT is not,
it can be used to supply many of the features of the exec which would
otherwise have to be made into commands.
DDT may access any job running on the system (preferably only
those belonging to the user).
DDT is used to access itself as a means of changing and examining
variables.
DDT can be made to take commands from files, and subordinate programs.
These commands may contain flow control statements.
Linking in DDT is very powerful in that allows %partial links%
and %advice% as well as the typical link.
Commands (known as %JCL%) are preceded with a colon.
Otherwise, commands are passed to the called program verbatim in
a special buffer which the called program can request.

.Sss ValRetting;
.ind valretting;
DDT traps any illegal instructions in its children.
If a child executes a %.VALUE instruction%,
which is trapped by DDT as an illegal instruction,
it will interpret the effective address as an ASCIZ string of commands
to be executed by the DDT.
This only works if the terminal belongs to the job doing the .VALUE.

.Sss Pseudo locations;
There are a number of %pseudo locations% which behave exactly like real
memory locations to the user but actually represent data which may be
stored in the monitor or in DDT.
Some of the variables also have %side effects% which take place when 
they are referenced or assigned to.

.Sss Normal Program Termination;
.ind normal termination;
When an inferior terminates normally,
it executes the %.BREAK 16, instruction%.
The arguments of this instruction allow specification of the type
of fate that is to come to the inferior process.
The options are:
.chart 8
--return from $X (used by DDT)
--skip return (type <crlflf>*)
--clear terminal input (or suspend command file)
--kill job and type :KILL<crlf>* (because job is done)
--return from conditional breakpoint (true)
--return from conditional breakpoint (false)
--suppress any msgs normally printed
.endChart
So it is noted that the program being run has the ability to determine
if the frame it is running in should be destroyed or not when the
program completes
(of course DDT can override this).

.Sss Abnormal Program Termination;
.ind abnormal termination;
When an inferior terminates abnormally,
it executes the %.LOSE uuo%.
The .LOSE uuo backs the PC up to the instruction 
previous to the .LOSE uuo.
In this way, an $P will retry the UUO that failed assuming that it was
a UUO.
The arguments to the .LOSE uuo are
.chart 16
==1000\means that the instruction that failed is a UUO and the error
message should be calculated based on how error codes are returned by
that uuo.
==1000+errcode\report on the error code specified
==1400\some kind of file i/o uuo failed,
the appropriate message should be printed based on the uuo pointed to 
by the backed up PC.
==1400+errcode\report on the file error code specified
==1+intbit\report the error pertaining to the specified interrupt
.endChart

.Sss Read/Write DDT and ITS variables;
The %.BREAK 12, instruction% and the %.SUSET uuo% are respectively
used for reading and writting DDT and ITS symbols from an inferior.
Many interesting values and parameters are available in this manner.

.Sss Review of Exec Functions for a Child;
All of the concepts of allowing children to request certain operations
of the exec are very desirable.
The illegal instruction or illegal UUO trap seems to be a simple
method of doing so.
If the parent is not trapping this condition,
then the default action would be to die of an illegal operation.

.SkipC; Ss SmallTalk,STeval:

%Smalltalk% is a general purpose %object oriented language%.
The design philosophy is such that it provides some interesting
metaphors for the design of our exec language.
This evaluation is based on documentation {BibRef S76} {BibRef S72}
and limited experience.

Smalltalk was developed by the %Learning Research Group% at 
%Xerox PARC% with the goal of studying the ability of children
of various ages to learn and use an object oriented language.
So far it seems that children of all ages are quite able to
learn the concepts of the language and put it to good use
{BibRef MTPLS} {BibRef SC}.

.Sss Overview;
Many of the concepts of Smalltalk are similar to those found in
SIMULA {BibRef SIMULA} {BibRef SABSL}.
While most of us are used to a %function oriented language%,
Smalltalk is an %object oriented language%.
.myList
The principle abstractions which define Smalltalk 
can be presented very simply: {BibRef S72}
==Every entity no matter what its name or function, is an object.
==Every object is an instance of a class,
and behaves in a manner prescribed by that class.
==Every object may maintain its own local state, or memory;
some aspects of this memory are unique to the instance,
while others may be common to all members of the class.
==Objects communicate with each other by sending messages.
==Thus,
defining a class consists of enumerating the valid messages which 
it might receive,
and defining the appropriate action or response associated with each
message.
==In considering the textual representation of a program,
control is passed to the first object,
and the remaining text is its message.
.endList

.Sss Parsing in Smalltalk;
Most interesting to our project is the way in which Smalltalk
parses the program.
Actually, a Smalltalk program parses itself.
The first object in the program gets sent a message consisting of
the entire remaining program.
It may then nibble some things off the message and send one of the
next objects a message consisting of the still remaining code.
This is best shown as an example of how a numeric expression would
be executed:
the expression 3+4 is evaluated by sending the object 3 (3 is an
instance of class integer which is a subclass of number...) the
message +4.
When 3 receives the +,
it evaluates the rest of the message and returns the result
added to 3.
A more complicated example is the evaluation of 3+4+5;
3 is sent the message +4+5;
it then notes the + and evaluates 4+5 by sending 4 the message +5;  
4 returns 9 (4+5)
which is added to 3 and returned as the value of the expression.
Likewise,
when an object of class string receives a message begining with +,
it performs concatenation.

As a result,
rather than having to teach the + function to cope with new classes
each time they are added,
it is only necessary to teach the new class how to add.
In fact if the new class is a subclass of some class which already
knows how to add,
then it is not even necessary to teach the new class unless some
special action is necessary which is different than its parent class.

.Sss An object oriented Exec;
If we were to apply these principles to our exec language,
we might come up with a better way of describing our problem.
If we call programs objects of class program,
the command line
.chart
--DIR DSK:ABC.*/AUTH
.endChart
would be parsed by executed by sending the message
DSK:ABC.*/AUTH to the program DIR.
When DIR came across something in the message 
it could not parse itself,
it would send a message to the proper object.
For example,
it may send the message
.chart
--ABC.*
.endChart
to the object
.chart
--DSK
.endChart
Hopefully,
DSK would return a list of filenames fitting the template ABC.*.
In this way,
the concept of modularity is obvious because DIR has complete
control of how its message is interpreted (and parsed),
yet it need not know about how to expand filenames for a given device.
Indeed,
DIR need not be changed should a new device be added which requires 
special file name expansion.

Of course,
there are also complications because in the command string to
DIR, the device may be omited.
In fact logical names may be specified which further complicates
the process of determining the message recipient.

.Sss Event driven control structure;
.ind event driven control structure;
This proposal (by {BibRef Knuth})
provides a control structure in which
a loop is entered which will terminate on a given set of events.
When the loop terminates,
a selection is made using a case statement to select an exit statement.
This type of control structure may be implemented in Smalltalk
as follows {BibRef S72}:
.begin nofill

	(
	until Return or Delete do			"1"
	    (
	    ^character _ keyboard.
	    display _ character.
	    character = 13 => (Return).			"2"
	    character = 127 => (Delete).		"3"
	    )
    	then case					"4"
	    Return : ('deal with normal exit')
	    Delete : ('deal with abnormal exit')
	)

.end
Above,
the until statement (marked "1") defines two events Return and Delete.
Within the loop,
these events are conditionally triggered by statements "2" and "3".
When either event occurs,
then and only then,
the loop is exited through the exiting case statement (marked "4"),
which determines the cause of the exit.

This structure may be especially useful 
in the exec language for use 
with interrupts (or signals).
The event could be triggered by a trap routine in response to an
external event (ie. character received, circuit zapped, etc.) thus
providing a much more pleasant exit from the loop.

.SkipC; Ss Tops-20 Monitor,Tops20:

The features of the Tops-20 Monitor which are significant are
the %COMND JSYS% and related JSYS's.
This instruction is used by the exec and programs alike to
parse commands from the standard input device.
This evaluation is based on documentation {BibRef MCRM}.

.Sss Overview;
This JSYS parses one field of the command line at a time.
The command line is obtained from the standard input which may be 
either a terminal or file.
When reading commands from the terminal,
the following features are provided: {BibRef MCRM}

.myList
==Allows the input of a command (including the guide words) to
be given in abbreviated, recognition (ESC and CTRL-F), and/or
full input mode.
==Allows the user to edit his input with the DELETE, CTRL-U,
CTRL-W, and CTRL-R editing keys.
==Allows fields of the command to be defaulted if an ESC or
CTRL-F is typed at the beginning of any field or if a field
is omitted entirely.
The assumed portion of the input is shown by the monitor.
==Allows a help message to be given if a question mark (?) is
typed at the beginning of any field.
==Allows input of an indirect file (@file) that contains the 
fields for all or the remainder of the command.
==Allows a recall of the correct portion of the last command
(ie. up to the beginning of the field where an error was
detected) if the next command line begins with CTRL-H.  The
correct portion of the command is retyped, and the user can
then continue typing from that point.
==Allows input of a line to be continued onto the next line if
the user types a hyphen (-) immediately preceding a carriage
return.  (The carriage return is invisible to the program
executing the COMND call, although it is stored in the text
buffer.)  The hyphen can be typed by the user while he is
typing a comment.  The comment is then continued onto the
next line.
.endList

.Sss Types of Tokens;
The COMND JSYS recognizes a number of commonly used tokens.
These tokens are checked for validity before being passed to the
calling program.
The types of tokens are:
.myList
==Keyword:
a table of valid keywords is passed to the monitor and 
a pointer to the keyword entered is returned.
==Number:
the radix of the number is given and the number is returned.
==Guide word:
optional noise words (which appear in parenthesis) are returned.
==Switch:
a switch of the form /<switch>:<value> or /<switch> is parsed.
==Input file:
return a pointer to the existing file specified.
==Output file:
return a pointer to a file.
==Arbitrary file:
return a pointer to an arbitrary file or group of files.
==Arbitrary field:
any arbitrary token entered is returned without verification.
==Confirm:
the user is asked to confirm and the boolean reply is returned.
==Directory name:
the directory number of the directory is returned.
==User name:
the directory number of the login directory is returned.
==Comma:
returns true if a comma is next.
==Floating point number:
returns the number.
==Device name:
returns the device designator.
==Text:
return everything up to the next carriage return.
==Date/Time:
the internal form of the date and time given is returned
for the given date or time given.
==Quoted string:
return the text between two quote marks.
==Unquoted string:
return text up to the next break character (supplied).
==Literal:
the input is compared with a supplied string.
==Leading number:
a number is parsed ending with the first non-numeric character.
==Account:
return an account string.
==Node name:
return a network node name.
.endList

.Sss Help Messages;
The calling program may supply a help string to be printed in
response to a "?" should the user enter one.
If a help string is not supplied by the user, 
a default help string will be provided by the system.
The default string essentially describes the type of field expected.
If a "?" is entered, the help string is printed and the input up to
where the "?" was typed is reprinted allowing the user to continue
entering from where he typed the "?".

.Sss Review;
Although these features may seem a little eccentric,
they represent a concise method of exchanging command information
between a user program and the exec or monitor.
It is far more desirable to have a standard user interface than
to have each program provide its own user interface along with
its own idiosyncrasies.
This method will probably be extended to include obtaining
evaluated expressions from the command line so that local
variables do not interfere with variables passed as arguments which
have the same name.

.SkipC; Ss The SU-AI DO program,SUAIDO:
.ind SU-AI DO program; ind DO program; ind Stanford AI;

The SU-AI DO program exists on the Stanford University Artificial
Intelligence computer to allow command files to be executed by
stuffing characters in the terminals input buffer.
Although this method is not under consideration,
several features of the user interface are signifigant with
respect to the problem of command files in the exec.
This evaluation is based on documentation {BibRef RPH}.

.Sss Overview;
.ind input buffer; ind stuffing the buffer;
The DO program reads any standard text file and puts the characters
from the file into your input buffer. Then the program exits and the
monitor reads the characters and does the rest.  If this causes a
program to be run, it can then read any of the characters remaining in
the buffer, as can any subsequent programs or the monitor if the
programs return to monitor level with some text still unread.

.Sss Special characters and responses;
.ind special characters;
The program scans the text in the file for special characters:
.chart 10
==<CR>\Ignored.
==<LF>\Ignored.
==^H\Insert a deferred <CALL> at this point.
==^B\Add a <CTRL> bit to the next converted character.
--<VT>\(same as ^B)
==^C\Add a <META> bit to the next converted character.
--<FF>\(same as ^C)
.ind quote characters;
==^^\Quote the next character. (Pass it with no conversion.)
==|\Separates different DO functions (see below)
==?\Takes the next character (other than RETURN or LINE) as 
a variable name.  Suppose the character is A (i.e., ?A).
If this is the first occurrence of ?A in the file, DO types 
out "A=#####" and  waits for you to type in a text string 
ending with RETURN.  This string is substituted for every 
occurrence of ?A in the file.  (It is also rescanned after 
it is inserted.)
.endChart

.Sss file segments;
.ind DO file segments; ind file segments;
To allow more than one DO function to be stored in the same file (good,
for instance, because small files are inefficient in using disk space,
and other reasons), the vertical bar (|) character can be used as a
separator.  
The various function segments in a DO file may be labeled by putting a
label immediately followed by a colon (:) as the first thing in the
segment.  
A file segment is named by following the file name with the
segment name in parenthesis.

.Sss |The BRICK (escape character)|;
.ind brick; ind POX convention; ind escape character;
Following the POX convention, the escape character is called the brick.
In the following, we will use the backslash character "\" as
the brick character in examples.

To specify a brick character use the sequence
        ?\<char>
This makes the <char> the brick character.  For example, to specify
backslash as the brick character use
        ?\\

The brick character appears as the first character of all the new
commands.  Subsequent characters are scanned to determine the command
and to get any needed arguments, etc.  Then normal processing is
resumed until the brick character is encountered again.

If the command is denoted by a special keyword the keyword is delimited
on the right by a dot character "." and may be in upper and/or lower
case letters.

.Sss special character generation;
.ind special character generation;
These commands are used to cause special characters to appear in the
text.  
.chart 16
--\CR.\Return (same as )
--\LF.\Line (same as )
--\ALT.\Alt (same as )
--\TAB.\Tab
--\VT.\Vertical tab
--\FF.\Form
--\BS.\Backspace
--\C.\Add control bit to following character 
--\M.\Add meta bit to following character 
--\CM.\Add both control and meta bits to next character
--\"<char>\Quotes <char> 
--\'<octal>\Generate character with given <octal> code number
--\=<decimal>\Generate character with given <decimal> code number
--\^<char>\Generate uparrow style character 
--\?<char>\Generate SOS style character 
.endChart

.Sss macro manipulation;
.ind macro manipulation; 
There is a set of 128 string variables, whose names are the
corresponding character.  In normal mode scanning these are set with
the ?<char> command.  The following commands allow a limited ammount of
manipulation of these strings.  The symbol <macro> will stand for the
character which is the name of the macro variable.
.chart 32
--\_<macro><char><string-sans-char><char>##\Sets <macro> to delimited string.
--\INPUT.<macro>\Inputs <macro> from the terminal.
--\&<macro1><macro2><macro3>\Like SAIL macro1 _ macro2 & macro3.
--\INSERT.<macro>\Patches <macro> directly into the output, 
unlike the ?<macro> command which causes it to be rescanned.
--\;<char><string-sans-char><char>\ Comment, ignores between <char>s.
.endChart


MZ3