COMMENT \HISTORY
AUTHOR,REASON
023  102300000002 \;

COMMENT \
VERSION 19-1(2)  28-MAY-80 by SDD OUTSTR: .AXOPC at TYMSHARE,fix SUAI OUTSTR
VERSION 19-1(1)  05-FEB-80 by SDD get less and greater from comments
VERSION 19-1(0)  04-FEB-80 by SDD remove HEREFKs for new segment
VERSION 17-1(71) 24-JAN-80 by SDD GET RID OF EXPO MACRO
VERSION 17-1(70) 12-NOV-79 by SDD CSERR made fatal (STRING EXPRESSION).
VERSION 17-1(69) 25-OCT-79 by SDD new TMPIN,TMPOUT code, FIX to FIXUUO
VERSION 17-1(68) 20-OCT-79 by SDD more merge [TMPxx,USETx]
VERSION 17-1(67) 5-OCT-79 by SDD merge Rutgers/NIH code
VERSION 17-1(66) 2-OCT-79 by SDD guess at fixes wanted by NIH,...
VERSION 17-1(65) 13-DEC-79 by SDD put in 1022 hooks: OPEN,GETCHAN,RELEASE
VERSION 17-1(64) 16-NOV-78 by SDD blew acs in tpmcor code (p34)
VERSION 17-1(63) 10-OCT-78 by SDD rework TMPIN,TMPOUT (p32-34)
VERSION 17-1(62) 10-17-77 BY SDD merge tymshare code, change some ^V's
VERSION 17-1(61) 10-18-74 BY rls check herefks
VERSION 17-1(60) 10-14-74 BY JFR FIX BUG IN INPUT
VERSION 17-1(59) 10-14-74 BY JFR REMOVE HACK'S
VERSION 17-1(58) 10-13-74 BY JFR %BS% BREAK TABLE BUGS
VERSION 17-1(57) 10-11-74 BY JFR FIS TYPOS %BS%
VERSION 17-1(56) 10-11-74 BY JFR MINOR FIX TO INPUT %BS%
VERSION 17-1(55) 10-11-74 BY RHT FEAT %BQ% MAKE CLOSE TAKE INHIBIT BITS AS ARG
VERSION 17-1(54) 10-11-74 BY JFR REMOVE HEREFK'S
VERSION 17-1(53) 10-11-74 BY JFR FEAT %BS% NEW WAY TO DO BREAK TABLES
VERSION 17-1(52) 10-10-74 BY JFR FEAT %BS% NEW WAY TO DO BREAK TABLES
VERSION 17-1(51) 9-27-74 BY JFR FIX AUTHOR REASON STUFF
VERSION 17-1(50) 8-8-74 BY LDE BUG #TB# TYPO IN INPUT PREVENTED SETPL PAGENUM TO WORK
VERSION 17-1(49) 5-24-74 
VERSION 17-1(48) 5-24-74 
VERSION 17-1(47) 5-24-74 BY rht mode saibrk & saiprn to strser
VERSION 17-1(46) 5-24-74 
VERSION 17-1(45) 5-24-74 
VERSION 17-1(44) 5-24-74 
VERSION 17-1(43) 5-24-74 
VERSION 17-1(42) 5-24-74 
VERSION 17-1(41) 5-24-74 
VERSION 17-1(40) 5-19-74 
VERSION 17-1(39) 5-19-74 
VERSION 17-1(38) 5-19-74 
VERSION 17-1(37) 5-19-74 
VERSION 17-1(36) 5-5-74 BY RHT ADD $PRINT
VERSION 17-1(35) 5-5-74 
VERSION 17-1(34) 5-5-74 
VERSION 17-1(33) 5-5-74 BY  JRL BUG #RX# (CMU =B7=) LDE  SAYS SOSNUM,LINNUM,PAGNUM S/B INITIALIZED
VERSION 17-1(32) 3-26-74 BY RHT FEAT %AX% FINISH UP SETPL (POLISH IT LATER!!!)
VERSION 17-1(31) 3-26-74 BY RHT SOMEONE (ON 12 MARCH 1974) RAN SOS ON THIS FILE!
			IF ANY TIME BOMBS WERE PLANTED, WE WILL FIND OUT!
VERSION 17-1(30) 2-22-74 BY RHT FEAT %BG% ADD BREAKSET MODE "F"
VERSION 17-1(29) 2-1-74 BY RHT BUG #QY# USBSTS NEEDED PATCHING
VERSION 17-1(28) 2-1-74 
VERSION 17-1(27) 1-12-74 BY RHT MAKE COUNT RIGHT IN INOUT
VERSION 17-1(26) 1-12-74 
VERSION 17-1(25) 1-12-74 BY RHT FIX COMPIL FOR SAITTY
VERSION 17-1(24) 1-11-74 BY RHT TTYINL STUFF
VERSION 17-1(23) 1-11-74 BY RHT MERGE IN CMU CHANGES
VERSION 17-1(22) 1-11-74 
VERSION 17-1(21) 1-11-74 
VERSION 17-1(20) 1-11-74 
VERSION 17-1(19) 1-11-74 
VERSION 17-1(18) 12-15-73 BY RFS FIX BUGS QC,QD.
VERSION 17-1(17) 12-10-73 BY JRL REMOVE LAST REFERENCES TO PGNNO
VERSION 17-1(16) 12-10-73 
VERSION 17-1(15) 12-10-73 
VERSION 17-1(14) 12-8-73 BY JRL REMOVE SPECIAL STANFORD CHARACTERS(WHERE POSSIBLE)
VERSION 17-1(13) 12-8-73 BY RFS MAKE ALTMODE 33 FOR EXPORT SYSTEMS
VERSION 17-1(12) 12-5-73 BY RHT BUG #PO#
VERSION 17-1(11) 12-5-73 
VERSION 17-1(10) 12-5-73 
VERSION 17-1(9) 12-3-73 BY RFS REMOVE ALL III DISPLAY STUFF
VERSION 17-1(8) 12-2-73 BY RHT FIX INPUT
VERSION 17-1(7) 12-2-73 BY RLS EDIT
VERSION 17-1(6) 12-2-73 BY RHT ALSO SOME WRD SPARES
VERSION 17-1(5) 12-2-73 BY RHT FEAT %AV% CHNCDB.  ALSO SPARES ADDED TO OPN & BRK
VERSION 17-1(4) 12-2-73 
VERSION 17-1(3) 12-1-73 BY RLS BUG #PM#  DONT LOSE A CHAR IN INPUT
VERSION 17-1(2) 12-1-73 BY RLS ADD SETPL FUNCTION
VERSION 17-1(1) 7-27-73 BY JRL CHANGE OPEN TO FACT THAT RELEASE NOW TAKES TWO ARGUMENTS
VERSION 17-1(0) 7-26-73 BY RHT **** VERSION 17 ****
VERSION 16-2(45) 5-7-73 BY JRL CHANGE PTYALL TO HANDLE LARGER BUFFERS
VERSION 16-2(44) 3-21-73 BY JRL ADD COMPIL(SAIDM3)
VERSION 16-2(43) 2-25-73 BY RHT BUG #LP# GO TO OUT OF PROCESS SHOULDNT LOOP!
VERSION 16-2(42) 2-14-73 BY RHT BUG #LM# TYPO IN PITBND
VERSION 16-2(41) 1-9-73 BY RHT REPAIR COMPIL FOR SAIPIT
VERSION 16-2(40) 12-2-72 BY RHT MODIFY PIT STUFF FOR NEW INFOTAB &DATAB
VERSION 16-2(39) 12-1-72 BY JRL CHANGE LEAP INDEX USED TO CALL FRELS WITHIN BEXIT
VERSION 16-2(38) 11-28-72 BY RHT ADD CLEANUPS TO BEXIT CODE
VERSION 16-2(37) 9-24-72 BY JRL LIBRARY REQUESTS
VERSION 16-2(36) 9-21-72 BY JRL ADD DADDY CURSCB ETC TO DUM
VERSION 16-2(35) 8-31-72 BY JRL RELEASE VALUE SETS CORRECTLY IN STKUWD
VERSION 16-2(34) 8-27-72 BY RHT CHANGE SPOT IN WHICH STKUWD SAVES RETN
VERSION 16-2(33) 8-23-72 BY JRL ADD FORGET CONTEXT CODE TO BEXIT
VERSION 16-2(32) 8-14-72 BY RHT EVAL NOW NAMED APPLY
VERSION 16-2(31) 7-22-72 BY RHT ADD KILL LIST TO BEXIT
VERSION 16-2(30) 7-12-72 BY DCS BUG #IN# PTYALL INVALID REMCHR PROBLEM
VERSION 16-2(29) 7-3-72 BY DCS MANY THINGS
VERSION 16-2(28) 6-7-72 BY DCS BUG #HO# RETURN BOTH ADDRESSES FROM ..ARCOP FOR .MES2
VERSION 16-2(27) 5-24-72 BY RHT CHANGE STKUWD TO LOOK AT PPDA
VERSION 16-2(26) 5-15-72 BY JRL ARRPDP BUG AGAIN
VERSION 16-2(24) 5-11-72 BY DCS BUG #HC# BETTER EXPO OUTSTR
VERSION 16-2(23) 5-11-72 BY DCS BUG #HA# IMPRV. ERR. ENB, FIX MUDDY FEET IN EXPO
VERSION 16-2(22) 5-11-72 BY DCS BUG #GT# ALLOW LARGE OCTAL PPNS
VERSION 15-6(17-21) 5-4-72 
VERSION 15-6(17) 3-7-72 BY DCS FIX OUTSTR(NULL) GARBAGING
VERSION 15-6(7-16) 2-20-72 
VERSION 15-6(6) 2-18-72 BY RHT CREATE THE NEW WORLD
VERSION 15-2(5) 2-6-72 BY DCS BUG #FQ# (WD-ARRY)(IN-OUT) WORD COUNT KEPT RIGHT, IOERR OK, DUMP MODE OK
VERSION 15-2(4) 2-5-72 BY DCS BUG #GI# REMOVE TOPSTR
VERSION 15-2(3) 2-1-72 BY DCS BUG #GF# INCHWL BREAKS ON MORE THINGS, TELLS WHAT THEY ARE
VERSION 15-2(2) 1-25-72 BY DCS BUG #GD# Fix non-standard buffer size setup in OPEN
VERSION 15-2(1) 12-2-71 BY DCS INSTALL VERSION NUMBER

\;




COMMENT \Indices, Bits for IOSER \
	LSTON	(IOSER)

IFN ALWAYS,<BEGIN IOSER>
DSCR IOSER -- IOSER GENERAL DISCUSSION
 ;SEE GOGOL FOR MORE DETAILS
 ; FORMAT OF CDBs
 DMODE	__ 0	;DATA MODE
 DNAME	__ 1	;DEVICE
 BFHED	__ 2	;HEADER POINTERS
 OBPNT	__ 3	;OUTPUT BUFFER POINTER
 OBP	__ 4	;OUTPUT BYTE POINTER
 OCOWNT	__ 5	;OUTPUT BYTE COUNT
 ONAME	__ 6	;OUTPUT FILE NAME -- FOR INFORMATION ONLY
 OBUF	__ 7	;OUTPUT BUFFER LOCATION
 IBPNT	__10	;SAME STUFF FOR INPUT
 IBP	__11
 ICOWNT	__12
 INAME	__13
 IBUF	__14
 ICOUNT	__15	;INPUT DATA COUNT LIMIT ADDRESS
 BRCHAR	__16	;XWD TTYDEV FLAG, INPUT BREAK CHAR ADDR
 TTYDEV  __16	;LH -1 IF DEVICE IS A TTY -- USED BY OUT
 ENDFL	__17	;INPUT END OF FILE FLAG ADDR
 ERRTST	__20	;USER ERROR BITS SPECIFICATION WORD
 LINNUM  __21		;ADDR OF LINE NUMBER WORD (SETPL FUNCTION)
 PAGNUM  __22		;ADDR OF PAGE NUMBER WORD (SETPL FUNCTION)
 SOSNUM  __23		;ADDR OF SOS NUMBER WORD  (SETPL FUNCTION)

 ; SIMIO INDICES

;;SDD 5-OCT-79 [=I26=] IOSTATUS renamed to be IOERRPROC for clarity (?)
 ?IOERRPROC	__0	;was IOSTATUS
 ?IOIN		__1	;SEE EXPLANATIONS IN SIMIO ROUTINE
 ?IODIN		__2
 ?IOOUT		__3
 ?IODOUT	__4
 ?IOCLOSE	__5
 ?IORELEASE	__6
 ?IOINBUF	__7
 ?IOOUTBUF	__10
 ?IOSETI		__11
 ?IOSETO		__12
;;%##% A NEW GOODIE
?SETIOSTS	__13
 ?IOOPEN		__14
 ?IOLOOKUP	__15
 ?IOENTER	__16
 ?IORENAME	__17

COMPIL(SIM,,,,,,DUMMYFORSCISS)
TYMSHR <
COMPXX(SIM,<SIMIO,CHNIOV,CHNIOR,CSERR,LPRYER>,<GOGTAB,X22,.SKIP.,DDFINA,INTRPT>
	,<SIMIO,CSERR,LPRYER -- SUPPORT ROUTINES>)
>;TYMSHR
NOTYMSHR <
COMPXX(SIM,<SIMIO,CSERR,LPRYER>,<GOGTAB>
	  ,<SIMIO, CSERR, LPRYER -- SUPPORT ROUTINES>)
>;NOTYMSHR
COMMENT \Simio, Ioinst, Lpryer, Cserr \

DSCR SIMIO
CAL XCT INDEX,SIMIO
PAR AC field is index into instruction table (see below)
 CHNL contains I/O channel number
 other params can be gleaned from instruction table
RES an I/O instruction is executed. Routine skips if I/O instr did.
 If the INDEX is LEQ 12, and if the instruction skips (error or EOF),
 status is presented in LH of user's EOF vbl (@ENDFL(CDB)), so he
 can test it, or an error message is provided (depending on user-
 enabling). This simplifies many I/O routines.
SID NONE
DES This routine makes I/O instructions re-entrant. The problem is
 that the channel cannot be referenced indirectly.


^^SIMIO:
	PUSHJ	P,.+1		;SAVE PC OF XCT
	PUSH	P,C		;SAVE C
	MOVE	C,-1(P)		;ASSUME SKIP RETURN
	LDB	C,[POINT 4,-1(C),12] ;INDEX OF XCT
;;SDD 5-OCT-79 [CLH 7-AUG-77] a warning:
;WARNING:  Should you change GETSTS so it just does a GETSTS UUO
; rather than using the following JUMPE, please look at USETI
; under the DEC switch.  It uses IOERRPROC to do error recovery.
;; ^^ SDD 5-OCT-79 [CLH 7-AUG-77] ^^
	JUMPE	C,USTST		;WANT STATUS BITS ONLY
	CAIL	C,13		;NOW SPLIT HIGH AND LOW INDICES
	 JRST	 ALTIO		;SKIP RETURN CHECK ONLY
;;%##% CHECK TO NOT SCREW STANDARD DEC LOSERS
NOSTAN <
	CAIN	C,IOIN	;
	 JRST	ISIOU	;
	CAIE	C,IOOUT	;IN OR OUT ?
	 JRST	NOTIOU	;NOPE
ISIOU:	SKIPG	@USBTST(C)	;CHECK FOR NO BUFFERS (& MORE AT CMU)
	 JRST	USFUNY		;NO BUFFERS, ETC.
>;NOSTAN
NOTIOU:MOVE	C,IOINST(C)	;GET INSTRUCTION
TYMSHR <
	HLL	CHNL,C
	XCT	IOINS2(C)
>;TYMSHR
NOTYMSHR <
	DPB	CHNL,[POINT 4,C,12]	;CHANNEL NUMBER
	XCT	C		;DO OPERATION
>;NOTYMSHR
	 JRST	 USOUT		;ALL KOSHER, NO EOF OR ERR
USTST: 
NOTYMSHR <
	MOVE	C,[GETSTS C]	;WHAT HAPPENED?
	DPB	CHNL,[POINT 4,C,12];(check status)
	XCT	C
>;NOTYMSHR
TYMSHR <
	HRLI	CHNL,CIOGST
	CHANIO	CHNL,C
>;TYMSHR
;;%##%	SAVE STATUS BITS
	MOVEM	C,FSTATS(USER)
CMU <
USERF:
>;CMU
	TRZ	C,010000	;IOACT BIT, USER LOOKUP CHECK BIT
;;SDD 5-OCT-79 [=I25=] make user EOF non-zero for non-blocking failure
;WAS:	HRLZM	C,@ENDFL(CDB)	;GIVE USER THE BITS
	TRNN	C,760000	;If no error bits were set,
	 TRO	C,010000	; then use IOACT to force non-zero EOF
	HRLZM	C,@ENDFL(CDB)	;GIVE USER THE BITS
	TRZ	C,010000	;Turn it back off for the check below
;; ^^ SDD 5-OCT-79 [=I25=] ^^
	TDNN	C,ERRTST(CDB)	;ANY HE CAN'T HANDLE?
;; SDD 5-OCT-79 next was JUMPA CHAN, to give ac to ERR, not needed now
	 JRST	USSKIP		;NOPE, JUST SKIP-RETURN
;;%CQ% JFR 7-29-75 more information, please
;;	ERR	<I-O DEVICE ERROR ON CHANNEL >,7 ;JUMPA TO PROVIDE CHANNEL AC
	ERRSPL	1,[[ASCIZ /
I-O device error, channel @D status @B   @F: @F  @F/]
NOTYMSHR <
		PWORD	CHNL	;CHANNEL #
>;NOTYMSHR
TYMSHR <	
		PRIGHT	CHNL
>;TYMSHR
		PLEFT	@ENDFL(CDB)	;STATUS BITS
		PWORD	DNAME(CDB)	;DEVICE
		PWORD	INAME(CDB)	;INPUT FILE NAME
		PWORD	ONAME(CDB)]	;OUTPUT FILE NAME
;;%CQ% ^
USSKIP:	AOS	-1(P)		;SKIP-RETURN
USOUT:	POP	P,C		;RESTORE C
	POPJ	P,		;DONE

ALTIO:	MOVE	C,IOINST(C)	;GET INSTR
TYMSHR <	HLL CHNL,C
	XCT	IOINS2(C)
>;TYMSHR
NOTYMSHR <
	DPB	CHNL,[POINT 4,C,12]
	XCT	C		;DO IT
>;NOTYMSHR
	JRST	USOUT		;NO SKIP
	JRST	USSKIP		;SKIP
NOSTAN <
USFUNY:	
CMU <
	SKIPE	@USBTST(C)	;FUNNY DEVICE?
	JRST	REALTM		; YES.
>;CMU
	JUMP	CHNL,		;FOR THE ERR MSG
	ERR	<NO BUFFERS ASSIGNED FOR I-O CHAN >,7
	JRST	USSKIP
CMU <
	COMMENT \	THIS NONSENSE IS A SPECIAL MODE FOR
	THE CMU SPEECH DEVICES.  ESSENTIALLY, IT DOES EVERTHING
	AS NORMAL, EXCEPT THAT IT PICKS UP THE TIMING ERR AND
	RUN-OUT-OF BUFFERS BIT OF THE
	I/O  STATUS FROM THE STATUS WORD IN THE BUFFER HEADER,
	INSTEAD OF USING THE BIT FROM THE GETSTS.	
\
TIMERR__100000		;TIMING ERR BIT FOR SPEECH DEVICES
ROBERR__200000		;RUN-OUT-OF-BUFFER ERR

REALTM:	PUSH	P,D		;NEED ANOTHER AC
	CAIE	C,IOIN		;INPUTTING?
	JRST	REALOT		; NO
	MOVSI	C,(<IN>)
	DPB	CHNL,[POINT 4,C,12]	;CHAN #
	XCT	C			;DO THE INPUT
	JRST	REALOK			;NO ERR, SO FAR
	MOVE	C,[GETSTS C]	
	DPB	CHNL,[POINT 4,C,12]	;LOOKS FAMILIAR
	XCT	C
	TRZA	C,TIMERR!ROBERR		;TURN OFF THE ONES FROM THE GETSTS
REALOK:	MOVEI	C,0
	HRRZ	D,IBPNT(CDB)		;ADDRESS OF THE NEW BUFFER
	IOR	C,-1(D)			;THE BITS FROM THE BUFFER
REALRT:	POP	P,D			;RESTORE THE AC
	TRNN	C,760000		;ERR OR EOF?
	JRST	USOUT			; NO
	JRST	USERF			; YES, GO LOOK AT IT

REALOT:	MOVE	C,[GETSTS C]
	DPB	CHNL,[POINT 4,C,12]
	XCT	C
	TRNN	C,ROBERR		;STOPPED FOR A ROB?
	JRST	REAL5			; NO
	HRRI	D,(C)			;GET THE BITS
	TRZ	D,760000		;TURN OFF THE ERRS
	HRLI	D,(<SETSTS>)
	DPB	CHNL,[POINT 4,D,12]
	XCT	D
REAL5:	MOVSI	D,(<OUT>)
	DPB	CHNL,[POINT 4,D,12]
	XCT	D
	JRST	REALRT
	JRST	REALRT			;IGNORE NOW, CATCH THE NEXT TIME THRU

>;CMU

USBTST_.-1
	XWD	CDB,IBUF	;1
;;#QY# ! RHT 2-1-74 NEEDED A DUMMY HERE. 
	777777			;@ THRU THIS  WILL BE ILL MEM REF
	XWD	CDB,OBUF	;3
>;NOSTAN


DSCR INSTRUCTION TABLE

;; SDD 5-OCT-79 was IOSTATUS, renamed =I26=
IOINST_.-1		;IOERRPROC__ 0  Handle error
NOTYMSHR <
	IN		;IOIN     __ 1  BUFFERED INPUT
	IN D		;IODIN	  __ 2  DUMP MODE INPUT
	OUT		;IOOUT	  __ 3  BUFFERED OUTPUT
	OUT D		;IODOUT	  __ 4  DUMP MODE OUTPUT
	CLOSE (D)	;IOCLOSE  __ 5  CLOSE I,O, OR BOTH
;; ALLOW USE OF INHIBIT BITS IN RELEASE
	RELEASE	(D)	;IORELEASE__ 6
	INBUF (A)	;IOINBUF  __ 7
	OUTBUF (A)	;IOOUTBUF __10
	USETI (A)	;IOSETI	  __11
	USETO (A)	;IOSETO	  __12
;;%##% A NEW GOODIE
	SETSTS  (A)	; SET IO STATUS
	OPEN DMODE(CDB)	  ;IOOPEN	  __14
	LOOKUP FNAME(USER);IOLOOKUP__15
	ENTER FNAME(USER);IOENTER  __16
	RENAME FNAME(USER);IORENAME__17
>;NOTYMSHR
TYMSHR <	;;simio table.  lh=lh of chanio AC  --  rh=IOINS2 index
	XWD CIOIN,0	;IOIN     __ 1  BUFFERED INPUT
	XWD CIOIN,1	;IODIN	  __ 2  DUMP MODE INPUT 
	XWD CIOOUT,0	;IOOUT	  __ 3  BUFFERED OUTPUT 
	XWD CIOOUT,1	;IODOUT	  __ 4  DUMP MODE OUTPUT 
	XWD CIOCLS,2	;IOCLOSE  __ 5  CLOSE I,O, OR BOTH 
	XWD CIORLS,2	;IORELEASE__ 6 
	XWD CIOIBF,3	;IOINBUF  __ 7 
	XWD CIOOBF,3	;IOOUTBUF __10 
	XWD CIOUSI,3	;IOSETI	  __11 
	XWD CIOUSO,3	;IOSETO	  __12 
	XWD CIOSTS,3	; SET IO STATUS 
	XWD CIOOPN,4	;IOOPEN	  __14 
	XWD CIOLUK,5	;IOLOOKUP __15 
	XWD CIOENT,5	;IOENTER  __16 
	XWD CIOREN,5	;IORENAME __17 

IOINS2:	CHANIO CHNL,
	CHANIO CHNL,D
	CHANIO CHNL,(D)
	CHANIO CHNL,(A)
	CHANIO CHNL,DMODE(CDB)
	CHANIO CHNL,FNAME(USER)
>;TYMSHR

HACK <

;; ****** these two routines are badly misplaced
;; they ought to be removed from this compil someday
;; check with Bob Smith first, though
>;HACK

HERE(CSERR)
	MOVE	USER,GOGTAB
	POP	P,UUO1(USER)	;STANDARD PLACE
;;SDD 12-NOV-79 error made fatal (string expression cases leave SP bad)
;;		[changed ERR code from 13 to 12] 
	ERR	<CASE INDEX OVERFLOW, VALUE IS >,12
	JRST	@UUO1(USER)	;RETURN OK

HERE (LPRYER) 
	ERR	<DATUM OF ARRAY NOT THERE>,1
	POPJ	P,

TYMSHR <
COMMENT !
	CHNIOV(CHANNEL,ARG,FUNCTION NUMBER)
	CHNIOR IS SAME BUT ARG IS REFERENCE
	IF FUNCTION NUMBER HAS BITS IN LEFT HAF FOR CALL BY
	VALUE, ITS FOR AN "IMMEDIATE" TYPE INSTR LIKE SETSTS
	BOTH FUCNTIONS RETURN A VALUE BUT IT HAS MEANING ONLY
	IN SOME CASES (DEPENDS ON FUNCTION).
	SETS .SKIP.
!

;SDD- 04-FEB-80: lets recycle those spares  (why take both inputs)
;;was: HEREFK(CHNIOV,CHNCV.)
HERE(CHNIOV)
	POP	P,1		;RETURN ADDRESS
	EXCH	1,-1(P)		;NOW ITS ARGUMENT
	MOVE	2,[CHANIO 3,1]
CHNCLC:	POP	P,3		;FUNCTION
	TLNE	3,-1
	 HRR	2,1		;FOR IMMEDIATE
	SETOM	.SKIP.
	HRL	3,-1(P)		;CHANNEL NUMBER
	MOVSS	3		;CHANNEL IS IN LEFT HALF
	SKIPE	INTRPT
	 XCT	DDFINA
	XCT	2
	SETZM	.SKIP.
	SUB	P,X22
	JRST	@2(P)

;SDD- 04-FEB-80: lets recycle those spares  (why take both inputs)
;;was: HEREFK(CHNIOR,CHNCR.)
HERE(CHNIOR)
	POP	P,2
	EXCH	2,-1(P)		;NOW ITS PARAMETER ADDRESS
	MOVE	1,2		;IN CASE FUNCTION WITH BITS IN LH
	HRLI	2,(<CHANIO 3,>)
	JRST	CHNCLC
>;TYMSHR
ENDCOM(SIM)
COMPIL(CHN,<GETCHN,NOTOPN,GETCHAN>,<GOGTAB>,<GETCHN, NOTOPN, GETCHAN>)




COMMENT \Getchn \

DSCR Getchn, Getchan

PAR A -- addr of ASCII for routine name
 CHNL -- I/O channel number from SAIL call
RES -- CHNL contains actual I/O channel number (diff for shared TTY)
 CDB contains ptr to  actual CDB table for that channel
SID A(lh) is changed
DES normally just sets up CHNL and CDB
 if error occurs (channel out of bounds, already open), a fatal message
  is printed, using the address in A to get the routine name.
 This routine is called by most I/O routines, having saved ACs and 
  fetched CHNL.


GETCHN:
	HRLI	A,(<PUUO 3,0>)	;PREPARE FOR ERR MESS
	TRZE	CHNL,777760	;CHECK FOR VALID CHANNEL NO
	 JRST	 NOTVALID	;INVALID CHANNEL NUMBER
	SKIPE	CDB,@CDBLOC(USER) ;IS CHANNEL OPEN? (CDBLOC SET BY ALLOC)
	 POPJ	P,

NOTOPN:	
	XCT	A		;PRINT ROUTINE NAME
	ERR	<: CHANNEL OR FILE NOT OPEN>


NOTVALID:
	XCT	A		;ROUTINE NAME
	ERR	<: CHANNEL NUMBER INVALID>


DSCR INTEGER_GETCHAN;
CAL SAIL


HERE (GETCHAN)
	MOVE	USER,GOGTAB
;; SDD 13-DEC-78 1022 hook: instruction to execute on entry to GETCHAN
	skipe	bkgetc(user)	;anything magic to do?
	 xct	bkgetc(user)	; (1022 likes to allocate channels)
;; ^^ SDD 13-DEC-78 ^^
	ADD	USER,[XWD A,CHANS]	;MAKE @ WORD
	MOVEI	A,1			;START AT CHANNEL 1
CHLUP:	SKIPN	@USER			;IF CHANNEL IS FREE,
	 POPJ	P,			; RETURN
	CAIGE	A,17			;CYCLE TO 0?
	 AOJA	A,CHLUP			;NO, TRY NEXT
	MOVEI	A,0			;TRY 0
	SKIPE	@USER			;FREE?
	 HRROI	A,-1			;NOPE
	POPJ	P,			;DONE

ENDCOM(CHN)
COMPIL(FIL,<FILNAM>,<FLSCAN,X22>,<FILNAM SCANNING ROUTINE>)
COMMENT \Filnam \

DSCR FILNAM
CAL PUSHJ
PAR file name string on SP stack
 of form FILENAME<.EXT><[PROJ,PROG]>
RES FNAME(USER) : SIXBIT /filename/
 EXT(USER): SIXBIT /extension,,0/
 0
 PRPN(USER): SIXBIT /PRJ PRG/ (or zero)
SID uses D,X,Y (4-6), REMOVES STRING FROM STACK
***** SKIP RETURNS IF SUCCESSFUL *****


^^FILNAM:
	SUB	SP,X22		;ADJUST STACK
	FOR II_1,3 <
	SETZM	FNAME+II(USER)>
NOITS <
	MOVEI	X,FNAME(USER)	;WHERE TO PUT IT
	PUSHJ	P,FLSCAN	;GET FILE NAME
TYMSHR <
	CAIE	Y,"("
	 JRST	CHKEXT		;NOT USER NAME
	SETZM	FUSER(USER)
	SETZM	FUSER1(USER)
	HRRZS	1(SP)
	MOVEI	D,=12	;sdd: typo (need decimal) 12 CHRS MAX
	MOVEI	X,FUSER(USER)
	PUSHJ	P,FLSCAN+2
	CAIE	Y,")"
	 JRST	FLERR		;NOT DELIMITED PROPERLY
	MOVEI	X,FUSER(USER)
	HRRZM	X,FNAME+3(USER)		;STORE POINTER
	MOVEI	X,FNAME(USER)
	PUSHJ	P,FLSCAN
CHKEXT:
>; TYMSHR
	JUMPE	Y,FLDUN	;FILE NAME ONLY
	CAIE	Y,"."		;EXTENSION?
	 JRST	FLEXT		;NO, CHECK PPN
	MOVEI	X,FNAME+1(USER)
	PUSHJ	P,FLSCAN
FLEXT:	JUMPE	Y,FLDUN	;NO PPN SPECIFIED
	CAIE	Y,"["
	 JRST	FLERR		;INVALID CHARACTER
CMU <		;HANDLE PPNS VIA UUO, MAYBE
	HRRZS	1(SP)	;LENGTH PART
		;SNEAK A LOOK AT FIRST CHAR
	SKIPN	1(SP)	;IS THERE A FIRST CHAR?
	 JRST	FLERR	; NO.
	MOVE	X,2(SP)
	ILDB	X,X
;;=C4= 1 of several LDE 28-Jun-74	alull ppn within [].
	CAIN	X,"]"		;is it null?
	 JRST	OCTPPN		; yes -- let the other guy handle it.
;;
	CAIL	X,"0"
	 CAILE	X,"7"
	  SKIPA		; NOT OCTAL DIGIT
	  JRST	OCTPPN
	PUSH	P,A	;NEED MORE ROOM
	PUSH	P,B
	SETZM	A	;CLEAR THE AREA
	SETZM	B
	SETZM	C
	MOVEI	D,=13+1	;MAX #CHARS+1
	MOVE	X,[POINT 7,A]	;DUMP THEM THERE
FLN2:	SOSGE	1(SP)
	 JRST	FLERRC	;RAN OUT OF STRING
	ILDB	Y,2(SP)	;THE NEXT CHAR
;;=C4= 2 OF SEVERAL
	JUMPE	Y,FLN2	;IGNORE NULLS
;;
	CAIN	Y,"]"	;THE END?
	 JRST	GOTRB	; YES
	JUMPLE	D,FLERRC	;WE DON'T WANT ANY MORE CHARACTERS
	IDPB	Y,X	;STICK THE CHAR THERE
	SOJA	D,FLN2	;GET ANOTHER

GOTRB:	MOVEI	X,A	;THATS WHERE THE UUO WILL FIND THEM
	CALLI	X,-2		;CMUDEC UUO
	 JRST	FLERRC	;SOMETHING WRONG
	MOVEM	X,FNAME+3(USER)	;SAVE IT

	AOS	-2(P)		;INDICATE SUCCESS
FLERRC:	POP	P,B
	POP	P,A
	POPJ	P,
OCTPPN:
>;CMU
TYMSHR <
	SKIPE FNAME+3(USER)	;IGNORE IF USER NAME
	 JRST FLDUN		;TREAT AS DONE
>;TYMSHR
	PUSHJ	P,[

	RJUST:	SETZM	PROJ(USER)
		MOVEI	X,PROJ(USER)
		PUSHJ	P,FLSCAN	;GET PROJ OR PROG IN SIXBIT
IFN SIXSW,<
		MOVE	X,PROJ(USER)
		IMULI	D,-6		;SHIFT FACTOR
		LSH	X,(D)		;RIGHT-JUSTIFY THE PROJ OR PROG
>;IF SIXSW (SET IN HEAD, USUALLY CONDITIONED ON NOEXPO)
	
IFE SIXSW,<
		MOVEI	X,0
;;#GT# DCS 5-11-72 ALLOW LARGE OCTAL NUMBERS AT STD DEC SYSTEMS
;;=C4= 3 OF several LE03 28-JUN-74	ALLOW NULL PPN
;		MOVE	D,PROJ(USER)	;WAS A HLLZ
		SKIPN	D,PROJ(USER)
		POPJ	P,
;;
;;
	FBACK:	MOVEI	C,0
		LSHC	C,6		;GET A SIXBIT CHAR
		CAIL	C,'0'
		CAILE	C,'7'
		JRST	FLERR		;INVALID OCTAL
		LSH	X,3
		IORI	X,-'0'(C)
		JUMPN	D,FBACK
>;NOT SIXSW (USUALLY CONDITIONED ON EXPO)
	FPOP:	POPJ	P,]

	HRLZM	X,FNAME+3(USER)
	CAIE	Y,","
;;=C4 4 OF several
;	JRST	FLERR		;INVALID CHAR
	JRST	[JUMPE	X,FLDUN1	;ALLOW NULL PPN - CHECK FOR "]"
		 JRST	FLERR]		;A REAL ERROR.
;;
DEC<
IFE ALWAYS,<EXTERN MYPPN>
;;=I09=	FOR SFD, IF NULL ARG, TAKE FROM OUR PPN
	JUMPN	X,.+3	;IF NULL FIRST HALF,
	MOVE	X,MYPPN	;USE OUR PPN INSTEAD
	HLLM	X,FNAME+3(USER)
>;DEC
	PUSHJ	P,RJUST		;JUSTIFY(AND CONVERT IF EXPORT) PROG #
DEC<
	JUMPN	X,.+2
	 MOVE	X,MYPPN	;IF NULL SECOND HALF, USE OUR PPN
>;DEC
	HRRM	X,FNAME+3(USER)
;;=C4= 5 OF several.
FLDUN1:

;;=I09=	3 OF MANY
SFDS<
	CAIN	Y,"]"
	 JRST	FLDUN	;IF ], OK
	CAIE	Y,","	;IF "," MUST BE SFD COMING
	 JRST	FLERR	;IF NEITHER, ERROR
	SETZM	PATHBL(USER)	;INIT PATHBLOCK
	SETZM	PATHBL+1(USER)
	MOVE	C,PRPN(USER)	;GET PPN AND PUT IN PATH BLOCK
	MOVEM	C,PATHBL+2(USER)
	MOVEI	C,PATHBL(USER)	;AND PUT PTR TO PATH BLOCK IN PPN
	MOVEM	C,PRPN(USER)
	MOVEI	X,PATHBL+3(USER)	;FIRST SFD PLACE
	MOVEI	C,SFDLVL	;COUNTER - SFDLVL IS MAX NO. OF SFDS
FLSFD:	PUSHJ	P,FLSCAN	;GET SFD NAME
	CAIN	Y,"]"	;IF LAST ONE
	 JRST	FLSFD1	;FINISHED
	MOVEI	X,1(X)	;OTHERWISE LOOK AT NEXT
	CAIN	Y,","
	 SOJG	C,FLSFD	;UNLESS TOO MANY
	 JRST	FLERR	;WHICH IS ERROR
FLSFD1:	SETZM	1(X)	;PUT ZERO AT END OF PATH BLOCK
> ;SFDS
;;
;;%DP% ! JFR 8-13-76 by popular demand, allows trailing ] to be omitted
;;	CAIN	Y,"]"
FLDUN:	AOS	(P)		;SUCCESSFUL
FLERR:	POPJ	P,		;DONE, NOT NECESSARILY RIGHT
>;NOITS
ITS<
begin ENR
;its style command line scanner
;	non-skip return for null file spec
;clobbers acs with reckless abandon
break_a		;returns w/ character which broke the scan
dev_b		;returns dev,fn1,fn2,sname
fn1_c
fn2_d
sname_x
ac_y
char_z
acptr_q3
limbo_temp		;scanner read ahead character
			;cannot leave psname until 0
for a in (a,b,c,z,q3,temp)
<	push p,a
>
	hrrzs	1(sp)		;only want length part
	pushj	p,getfil
	jfcl
	movem	fn1,fname(user)
	movem	fn2,ext(user)
	movem	sname,prpn(user)
	cain	dev,0
fnrxit:	aos	-6(p)		;do a skip return
for a in (temp,q3,z,c,b,a)
<	pop	p,a
>
cpopj:	popj	p,

;filname subroutines
getcc:	skipn	break,limbo
	pushj	p,nextc
	setzm	limbo
	popj	p
nextc:	movei	break,0
	sosj	1(sp)
	ildb	break,2(sp)
	popj	p,
psname:	pushj	p,getcc		;break off word from input stream
	caie	break,40	;ignore leading spaces
	cain	break,11	;tabs too
	jrst	psname
	move	acptr,[440600,,ac]
	tdza	ac,ac
name1:	pushj	p,getcc
	pushj	p,brktst
	jrst	nambrk		;found a break character
name2:	tlne	acptr,770000
	idpb	char,acptr
	jrst	name1
nambrk:	jumpn	char,cpopj		;no trailing spaces
nambr1:	pushj	p,getcc
	caie	break,40		;ignore trailing spaces
	cain	break,11
	jrst	nambr1
	pushj	p,brktst
	popj	p,
	movem	break,limbo
	movei	break,40
	popj	p,
;converts break to sixbit and puts result in char
;^Q quotes next char
;fails to skip on break char
brktst:	cain	break,11
	movei	break,40
	pushj	p,sixtst
	jumpl	char,[	caie break,21	;^Q
			popj p,
			pushj p,getcc
			pushj p,sixtst
			jumpl char,cpopj
			jrst brkt1]
	jumpe	char,cpopj
	caie	char,':'
	cain	char,';'
	popj	p,
brkt1:	aos	(p)
	popj	p,
;convert break to sixbit
sixtst:	movni	char,1
	cail	break,40
	caile	break,"_"
	jrst	sixt1		;might be lower case
	movei	char,-40(break)
	popj	p,
sixt1:	cail	break,"a"
	caile	break,"z"
	popj	p,
	movei	char,<"A"-"a"-40>(break)
	popj	p,
;this routine scans cmd line for file spec
getfil:	setzb	fn1,fn2
	setzb	dev,sname
	setzm	limbo
	pushj	p,psname
	jumpe	ac,cpopj
	aosa	(p)
getf1:	pushj	p,psname		;break off first name
	jumpe	ac,cpopj
	cain	break,":"
	jrst	[	move dev,ac
			jrst getf1]
	cain	break,";"
	jrst	[	move sname,ac
			jrst getf1]
;this must be fn1 or fn2
	caie	break,40
	jrst	[	jumpn fn1,[	move fn2,ac
					popj p,]
			move fn1,ac
			popj p,]
	jumpn	fn1,[	move fn2,ac
			jrst getf1]
	move	fn1,ac
	jrst	getf1
bend FNR
>;ITS
ENDCOM(FIL)
COMPIL(FLS,<FLSCAN>,,<FLSCAN ROUTINE>)

COMMENT \Flscan \

DSCR FLSCAN
CAL PUSHJ
PAR X -- addr of destination SIXBIT
 1(SP), 2(SP) -- input string
RES sixbit for next filename, etc in word addressed by X
 break (punctuation) char in Y (0 if string exhausted)
 D,X, input string adjusted
SID only those AC changes listed above (Y, for instance)


^^FLSCAN:  
	HRRZS	1(SP)		;WANT ONLY LENGTH PART
	MOVEI	D,6		;MAX NUMBER PICKED UP
	SETZM	(X)		;ZERO DESTINATION
	HRLI	X,440600	;BYTE POINTER NOW
;;SDD 5-OCT-79 install octal file name code (but #???)
;; \UR#25\ JRL 6/20/78 ALLOW OCTAL DIGITS AS FILE NAMES
; Wish to allow #oooooooooooo as file name (where each o is an
; octal digit). Main reason is to allow SAIL programs to deal
; with funny filenames such as UFD's.
	MOVEI	Y,0		; BREAK CHAR IN CASE NO STRING
	SOSGE	1(SP)		; DECREMENT STRING LENGTH
	 POPJ	P,		;	NO STRING, RETURN
	ILDB	Y,2(SP)		; PICK UP CHAR
TYMSHR <
	CAIE	Y,"'"		; IS THIS AN OCTAL FILE NAME?
>;TYMSHR
printx choose a GOOD Octal file name delimiter. Allow # as DEC standard
NOTYMSHR <
	CAIE	Y,"#"		; IS THIS AN OCTAL FILE NAME?
>;NOTYMSHR
	 JRST	URNOCT		; NOPE, HANDLE NORMAL WAY.
	PUSH	P,X		; SAVE ADDRESS TO PLACE ANSWER
	MOVEI	D,=12		; OCTAL NAME MAY HAVE 12 DIGITS
	MOVEI	X,0		; ACCUMULATE ANSWER IN X
URFLN1: MOVEI	Y,0		; BREAK CHAR IF STRING EXHAUSTED
	SOSGE	1(SP)		; 
	 JRST	URFRET		; STRING EXHAUSTED, RETURN
	ILDB	Y,2(SP)		; PICK UP CHAR
	CAIE	Y,"."		; SEE IF BREAK CHARACTER.
	 CAIN	Y,"["		; 
	  JRST	URFRET		; 
	CAIE	Y,"]"		;
	 CAIN	Y,","		; 
	  JRST	URFRET
; NOT A BREAK CHARACTER. SEE IF DIGIT. IF NOT IGNORE IT.
	JUMPE	D,URFLN1	; ALREADY HAVE 12 DIGITS?
	CAIG	Y,"7"		; CHECK TO SEE IF DIGIT
	 CAIGE	Y,"0"
	  JRST	URFLN1	; NOT DIGIT. IGNORE
	ANDI	Y,7		; GET VALUE OF DIGIT.
	LSH	X,3		; ACCUMULATE DIGITS
	ORI	X,(Y)
	SOJA	D,URFLN1	; LOOP
URFRET: MOVEM	X,@(P)		; STORE ANSWER
	POP	P,X		; CLEAN-UP STACK
	POPJ	P,		; RETURN
FLN1:	MOVEI	Y,0		;ASSUME NO STRING LEFT
	SOSGE	1(SP)		;TEST 0-LENGTH STRING
	 POPJ	 P,
	ILDB	Y,2(SP)		;GET BYTE
URNOCT:			;NOT AN OCTAL FILE NAME
;; ?UR#25? END OF #OCTAL DIGIT FILE NAME CHNGS
;; ^^ SDD 5-OCT-79 ^^

TYMSHR <
	CAIE	Y,"("
	 CAIN	Y,")"
	  POPJ	P,
>;TYMSHR
	CAIE	Y,"."		;CHECK VALID BREAK CHAR
	 CAIN	Y,"["
	  POPJ	P,
	CAIE	Y,"]"
	 CAIN	Y,","
	  POPJ	P,
	JUMPE	D,FLN1		;NEED NO MORE CHARS
;;=C4=	6 of several.	IGNORE NULL CHARACTERS.
	JUMPE	Y,FLN2X
TYMSHR <
	CAIGE Y,40
	 JRST FLN2
>;TYMSHR
;;
	TRZN	Y,100		;MOVE 100 BIT TO 40 BIT
	 TRZA	Y,40		; TO CONVERT TO SIXBIT
	 TRO	Y,40		; (NO CHECKING)
	IDPB	Y,X		;PUT IT AWAY
;;=C4= 7 of several
FLN2X:
;;
	SOJA	D,FLN1		;CONTINUE

TYMSHR< FLN2:	MOVEI Y,0
	SOSGE 1(SP)
FLN3:	 POPJ P,
	ILDB Y,2(SP)	;JUST GET SOME CHRS
	SOJL D,FLN3	;RETURN IF DONE
	TRZN Y,100
	TRZA Y,40
	TRO Y,40
	IDPB Y,X
	JRST FLN2>;TYMSHR
ENDCOM(FLS)
COMPIL(OPN,<OPEN,RELEASE,SETPL,CHNCDB>
	  ,<GETCHN,SAVE,RESTR,CORGET,FLSCAN,SIMIO,X33,X22,X11,CORREL,GOGTAB>
	  ,<OPEN RELEASE AND SETPL FUNCTIONS>)
;; SDD 13-DEC-78 added GOGTAB to above (for 1022 IO hooks)
COMMENT \Open \

DSCR OPEN(CHAN,"DEV",MODE,IBFS,OBFS,@INCNT,@INBRCHR,@INEOF);
CAL SAIL

COMMENT \
Allocate IBFS input and OBFS output buffers on channel CHAN for
 device DEV(SAIL/GOGOL string). Store INCNT, and the INBCHR and INEOF 
 addresses in a newly allocated CDB (channel data block). Store 
 all necessary information to carry out I/O on this channel
 in the CDB. Mark the channel open.
\

.OPN:
HERE (OPEN)
;; SDD 13-DEC-78 hook for 1022, which needs channel control
	move	user,gogtab
	skipe	bkopen(user)	;is there anything to do?
	 xct	bkopen(user)	;sure is, go do it.
;; ^^ SDD 13-DEC-78 ^^
; FIRST RELEASE IF ALREADY OPEN
	PUSH	P,-7(P)
; RELEAS NOW TAKES TWO ARGS
	PUSH	P,[0]
	PUSHJ	P,RELEASE	;SIMPLE

; NEXT SAVE AC'S, SET UP USER REGISTER, OBTAIN A CDB

	PUSHJ	P,SAVE		;SAVE ACS
	MOVEI	C,IOTLEN	;SIZE
	PUSHJ	P,CORGET	;OBTAIN A BLOCK
	 JRST	 BADOPN		;CAN'T GET IT
	MOVE	CDB,B		;CDB ptr to CHANNEL TABLE
;;#WZ# JFR 6-17-76 ZERO OUT THE WHOLE THING. SUPERSEDES #RX# (CMU =B7=)
	SETZB	LPSA,(CDB)	;NOW GET READY IN CASE OF ERROR
	MOVSI	TEMP,(CDB)
	HRRI	TEMP,1(CDB)
	BLT	TEMP,IOTLEN-1(CDB)
;;#WZ# ^
	SUB	SP,X22

; FILL IT WITH NON-CONTROVERSIAL THINGS

	POP	P,TEMP		;RETURN ADDRESS
	POP	P,ENDFL(CDB)	;END OF FILE FLAG ADDRESS
	POP	P,BRCHAR(CDB)	;BREAK CHAR ADDRESS
	POP	P,ICOUNT(CDB)	;INPUT COUNT ADDRESS
	POP	P,OBUF(CDB)	;NUMBER OF OUTPUT BUFFERS
	POP	P,IBUF(CDB)	;NUMBER OF INPUT BUFFERS
	POP	P,Z		;DATA MODE
	POP	P,CHNL		;DATA CHANNEL
	CHKCHN	CHNL,<OPEN>	;ASSURE VALID
;;#HA# DCS 5-11-72 IMPROVE ERROR ENABLE. ALSO, IN EXPO SYSTEM,
;;		   AVOID REFERENCES TO PGNNO, WHICH IS same as ERRTST!
	HRRZI	X,750000	;ERROR BITS POSSIBLY ENABLED  -- WAS A HRROI
;;#HA#
	ANDCM	X,Z		;ERROR BITS ACTUALLY ENABLED ARE 0
	MOVEM	X,ERRTST(CDB)	;SAVE ENABLATIONS
	TRZ	Z,750000	;REMOVE IRRELEVANT BITS
ILLMOD __ 777777
DEC<ILLMOD__007777
>;DEC
CMU <
ILLMOD __ 377776		;BIT 400000 FOR SPECIAL DEVICE (CMU)
				;BIT 000001 FOR KEEPING NULLS
	TLZE	Z,10000	;IOACTIVE BIT TO BE SET ON OPEN ??? (LDE)
	TRO	Z,10000	;YES
>;CMU
	TLNE	Z,ILLMOD	;CHECK VALIDITY SOMEWHAT
	 ERR	 <OPEN: INVALID DATA MODE>,1
	MOVEM	Z,DMODE(CDB)	;STORE MODE

; GET DEVICE NAME

	MOVEI	X,DNAME(CDB) ;WHERE SIXBIT'S TO GO
	PUSHJ	P,FLSCAN	;GET DEVICE NAME
;;%##% ONLY GIVE ERROR MESSAGE IF NOT ASKED NOT TO
	JUMPN	Y,[
		SKIPN	@ENDFL(CDB)	;FLAGGED??
		ERR	<INVALID DEVICE NAME FOR OPEN>,1
		JRST	.+1
		]

;IF TTY, MARK TTYDEV FOR OUT

	HLRZ	TEMP,DNAME(CDB)	;GET LH DEVICE NAME
	MOVSI	Z,400000	;BIT TO MARK WITH
;;%##% DO A DEVCHR NOW
;;	CAIE	TEMP,'TTY'	;IF TTY OR PTY,
	CAIN	TEMP,'PTY'	; ,
	JRST	MRKTYB		;MARK AS A TTY
	MOVE	TEMP,DNAME(CDB)	;PICK UP DEVICE AGAIN (FULL SIXBIT)
	CALL6	(TEMP,DEVCHR)	;GET CHARACTERISTICS
	TLNE	TEMP,10		;A TTY???
MRKTYB:	 IORM	 Z,TTYDEV(CDB); IT'S A TTY
;;%##%

; NOW SET HEADER PTRS IN CDB

	HRRZI	Z,-1		;TO TEST RIGHT HALF
	SETZM	BFHED(CDB)	;CLEAR HEADER POINTER
	LDB	E,[POINT 4,DMODE(CDB),35] ;DATA MODE
	CAIL	E,15		;DUMP MODE?
	 JRST	 AGNN		; YES, NO BUFFER HEADER WORD
	MOVEI	TEMP,OBPNT(CDB)	;IF OUTPUT, SET POINTER
	TDNE	Z,OBUF(CDB)	;ANY OUTPUT BUFFERS?
	 HRLM	 TEMP,BFHED(CDB)
	MOVEI	TEMP,IBPNT(CDB)	;SAME FOR INPUT
	TDNE	Z,IBUF(CDB)	;ANY INPUT BUFFERS?
	 HRRM	 TEMP,BFHED(CDB)

; NOW OPEN THE FILE, GET THE BUFFERS,ETC.

AGNN:	XCT	IOOPEN,SIMIO		; OPEN CHAN,MODE
	 JRST	 [SKIPE @ENDFL(CDB) ;DOES USER WANT TO KNOW?
			 JRST	NORELO ;YES, RELEASE CDB, ERASE ALL OF ATTEMPT
			 JRST	RTRY]





COMMENT \
ERMAN'S IMPROVED BUFFER GETTER   ---  DEC. 1970
 If a buffer size is specified (lh #buf word), allocate that size,
else thestandard size (determined via a dummy XXXBUF, clever soul
that LDE is)."NOTICE WITH AWE THAT NO CORE IS EVER WASTED, AS IN THE
INFERIOR OLD WAY" (sic).
\
	MOVEI	Z,0		;FOR DUMMY (AND REAL) OUTBUF
	PUSHJ	P,GETBFS	;GET CORE, DO THE OUTBUFS (OR SIMULATIONS)
	ADDI	CDB,OBUF-OBPNT+1 ;RELOCATE FOR INPUT IN CDB
	MOVEI	Z,-1
	PUSHJ	P,GETBFS	;GET CORE, DO INBUFS
	SUBI	CDB,OBUF-OBPNT+1;RE-RELOCATE
CMU <	;FUNNY INPUT DEVICE
	SKIPL	DMODE(CDB)		;DID HE SPECIFY TO GET ERRS FROM
					; BUFFER HEADER?
	JRST	STNIT			;     NO.
	HRLZI	TEMP,400000
	SKIPE	IBUF(CDB)		;INPUT BUFFERS?
	JRST	[IORM	TEMP,IBUF(CDB)	; YES
		 JRST	STNIT]
	SKIPE	OBUF(CDB)		;OR OUTPUT BUFFERS?
	JUMPA	CHNL,[IORM	TEMP,OBUF(CDB)	; YES
			JRST	STNIT]
	ERR<OPEN: SPEECH DEV BUT NO BUFFERS, CHAN >,7
>;CMU

; FINISH OUT -- SET EOF FLAG IF DESIRED

STNIT:	;SETOM	JOBFF		;ONE MUST KNOW WHAT HE IS DOING TO USE
	MOVEM	CDB,@CDBLOC(USER) ;STORE CDB ADDR IN CHANS TABLE
	SETZM	@ENDFL(CDB)	;MARK OPEN SUCCESSFUL
	JRST	RESTR		;RESTORE ACS, RETURN

BADOPN:	HRRZ	TEMP,JOBREN	;NEXT START WILL ASK ALLOC
	HRRM	TEMP,JOBSA	;QUESTION
	ERR	<TOO MANY CHANNELS OR I/O BUFFERS REQUESTED>,1,<(TEMP)>

RTRY:	TERPRI	<OPEN: DEVICE NOT AVAILABLE>
	TERPRI	<TYPE "R" TO RETRY, "X" TO GO ON WITHOUT>
	PRINT	<?>
	PUUO	TEMP
	CAIE	TEMP,"r"
	CAIN	TEMP,"R"	;TRY AGAIN?
	 JRST	 AGNN		;YES
;;%##%
	SETOM	@ENDFL(CDB)	;MARK A LOSER
	JRST	 NORELO
;;%##%

GETBFS:	SETZM	ONAME(CDB)	;CLEAR FILE NAME
	HRRZ	Y,OBUF(CDB)	;NUMBER OF BUFFERS
	HLRZ	D,OBUF(CDB)	;SIZE
NOSTAN <
	HRRZS	OBUF(CDB)	;MARK FOR SPECIAL TEST
>;NOSTAN
	JUMPE	Y,GBUFRT	;NO BUFFERS
	JUMPE	D,GETDES	;WANTS DEFAULT SIZE
NOTYMSHR<	ANDI	D,7777		;MAX BUFFER SIZE>;NOTYMSHR
TYMSHR<ANDI D,37777>;TYMSHR
	HRLZ	A,D		;SIZE IN LH
	PUSHJ	P,GETCOR	;GET THE CORE (SURPRISE!)
	SETZM	OCOWNT(CDB)	;IN CASE NO ACTUAL INBUF (OUTBUF) DONE
	CAIL	E,15		;DUMP MODE?
	 JRST	 GBUFRT		; YES, DON'T ACTUALLY FUDGE UP BUFFERS
STANFO <;USE UINBF, UOUTBF
;;#GD# 01-25-72 DCS (1-2) set up JOBFF, Fix XCT, bad count
	MOVEM	B,JOBFF		;B FROM CORGET HAS BUFFER AREA ADDRESS
	SUBI	D,2		;GETCOR INCREMENTED
;;#GD#
	HRRZ	C,Y
	MOVE	A,[UINBF C]
	JUMPN	Z,.+2
	MOVE	A,[UOUTBF C]
	DPB	CHNL,[POINT 4,A,12]
;;#GD# 01-25-72 DCS (2-2) (was XCT CHNL, clearly wrong)
	XCT	A		;DO THE ALLOCATIONS
;;#GD#
	POPJ	P,
>;STANFO
NOSTAN <
	ADDI	B,1		;SECOND WORD
BUFC1:	HRR	A,B
	SOJLE	Y,BUFC2
	ADD	B,D		;NEXT ONE
	MOVEM	A,(B)		;MAKE POINT TO PREV
	JRST	BUFC1

BUFC2:	MOVE	B,OBUF(CDB)	;BACK TO FIRST
	MOVEM	A,1(B)		;LINK IT TOO
	HRLI	A,400000	;RING-USE BIQ
	MOVEM	A,OBPNT(CDB)	;BUFFER PTR
	POPJ	P,
>;NOSTAN

GETCOR:	ADDI	D,2		;+2 FOR ACCOUNTING
	MOVE	C,D
	IMUL	C,Y		;TOTAL CORE NEEDED
	PUSHJ	P,CORGET	;GRAB IT
	ERR	<OPEN: NOT ENUFF CORE FOR BUFFERS>
	HRRZM	B,OBUF(CDB)	;SAVE SO CAN RELEASE
	POPJ	P,

GETDES:	MOVEI	A,1		;1 DUMMY BUFFER
	CAIL	E,15		;GOOD OLD DUMP MODE?
	 JRST	 [MOVEI D,202	;ASSUME THIS, SINCE INBUF/OUTBUF WON'T
		  JRST GDIT]	; WORK IN DUMP MODE
;;#VE# UGLY CODE REPLACED BY DIFFERENT UGLY CODE
;	MOVEI	TEMP,BRKDUM-1(USER)
;	MOVEM	TEMP,JOBFF
	PUSH	P,[0]		;
	HRRZM	P,JOBFF		;
	PUSH	P,[0]		;MOST LIKEYL ONLY ONE PUSH IS ENOUGH, BUT ...
	PUSH	P,[0]		;
	PUSHJ	P,GETIOB	;DUMMY IN/OUBUF
	LDB	D,[POINT 17,-1(P),17] ;GET THE SIZE
	SUB	P,X33		;POP BACK
;;#VE# ^^
GDIT:	PUSHJ	P,GETCOR	;GET THE CORE
	SETZM	OCOWNT(CDB)	;CLEAR BYTE COUNT
	CAIL	E,15		;DUMP MODE?
	JRST	GBUFRT		;YES, NO BUFFER STRUCTURE
	MOVEM	B,JOBFF
	MOVE	A,Y		;NUMBER OF BUFFERS
	PUSHJ	P,GETIOB	;NOW FOR REAL
GBUFRT:	SETOM	JOBFF		;FOR SPITE
	POPJ	P,

GETIOB:	SKIPN	Z
	XCT	IOOUTBUF,SIMIO	;DO OUTBUF
	SKIPE	Z
	XCT	IOINBUF,SIMIO	;INBUF
	POPJ	P,
SUBTTL	RELEASE




COMMENT \Release \

DSCR RELEASE(CHANNEL NO,INHIBIT BITS);
CAL SAIL
DES THIS USES THE DEFAULT PARAMETER MECHANISM, 0 DEFAULT FOR INHIBIT BITS


COMMENT \
Release channel, i/o buffers, channel table if channel is open
Adjust special TTY stuff to reflect lossage if TTY channel
\


HERE(RELEASE)
.RELS:
;; SDD 13-DEC-78 hook for 1022, which needs channel control
	move	user,gogtab
	skipe	bkrels(user)	;is there anything to do?
	 xct	bkrels(user)	;sure is, go do it.
;; ^^ SDD 13-DEC-78 ^^
	SETOM	JOBFF		;MARK INVALID
	PUSHJ	P,SAVE		;SAVE REGS, GET USER, SAVE RETURN
;; FOLLOWING WAS MOVE LPSA,X22
	MOVE	LPSA,X33
;; FOLOWING WAS CHNL,-1(P)
	MOVE	CHNL,-2(P)	;CHANNEL #
	CHKCHN	CHNL,<RELEASE> ;VALIDATE
	SKIPN	CDB,@CDBLOC(USER) ;GET ADDR FROM CHANS TABLE-- CHANNEL OPEN?
	 JRST	 RESTR		;CHANNEL NOT OPEN, FORGET IT
	SETZM	@CDBLOC(USER)	;CLEAR CHANS TABLE ENTRY
;; INHIBIT BITS;
	HRRZ	D,-1(P)		;THE DEFAULT OR USER SPECIFIED INHIBIT BITS
	XCT	IORELEASE,SIMIO	;RELEASE CHAN,0
	HRRZ	B,IBUF(CDB)	;RELEASE ANY INPUT
	PUSHJ	P,BUFREL	; BUFFERS
	HRRZ	B,OBUF(CDB)	;ALSO OUTPUT
	PUSHJ	P,BUFREL	; BUFFERS
NORELO:	HRRZ	B,CDB		;WHERE TO RELEASE
	PUSHJ	P,CORREL	;GIVE CDB BACK
	JRST	RESTR		;RESTORE AND RETURN

BUFREL:	JUMPN	B,CORREL	;RELEASE IF ANY TO RELEASE
	POPJ	P,		;ELSE RETURN


DSCR SETPL(CHANNEL,@LINNUM,@PAGNUM,@SOSNUM)
CAL SAIL


HERE(SETPL)
	PUSHJ	P,SAVE
	MOVE	CHNL,-4(P)	;GET CHANNEL
	PUSHJ	P,GETCHN	;VALIDATE, LOAD CDB
	POP	P,TEMP		;RETURN ADDRESS (GET OUT OF WAY)
	POP	P,SOSNUM(CDB)
	SETZM	@SOSNUM(CDB)
	POP	P,PAGNUM(CDB)
	SETZM	@PAGNUM(CDB)
	POP	P,LINNUM(CDB)	;LINE NUMBER
	SETZM	@LINNUM(CDB)
	MOVE	LPSA,X11	;REMOVE CHANNEL NUMBER FROM STACK
	JRST	RESTR

;;%AV% -- rht
DSCR CHNCDB(CHANNEL);
CAL SAIL
DES RETURNS INTEGER = INPHDR,,OUTHDR
	(ACTUALLY COULD BE GOTTEN FROM CDB BY USER, BUT THIS
	PROMISSES MORE STABILITY)


HERE(CHNCDB)
	PUSHJ	P,SAVE		;
	MOVE	CHNL,-1(P)	;GET CHANNEL NUMBER
	PUSHJ	P,GETCHN	;CHECK & LOAD CDB
	MOVEI	1,DMODE(CDB)	;GET VALUE
	MOVEM	1,RACS+1(USER)	;SO RESTR WINS
	MOVE	LPSA,X22	;
	JRST RESTR		;RETURN

HERE(OPNSP1)			;PERHAPS PUT GETSTS HERE
;;%##% GOBBLED DOWN TWO SPARE HERES HERE FOR STATUS ROUTINES THAT FOLLOW
	ERR <DRYROT IN OPEN SPARES>

ENDCOM (OPN)
;;%##%
COMPIL(STS,<GETSTS,SETSTS>
	,<SAVE,RESTR,SIMIO,GOGTAB,GETCHN,X11,X33,X22>
	,<GETSTS AND SETSTS>)


COMMENT \GETSTS,SETSTS\

DSCR STATUS_GETSTS(CHANNEL);
CAL SAIL


.STS:
HERE(GETSTS)
	PUSHJ	P,SAVE
	LOADI7	A,<GETSTS>
	MOVE	CHNL,-1(P)	;CHANNEL #
	PUSHJ	P,GETCHN
;;SDD 5-OCT-79 [=I26=] install change, use RACS+A directly, TYMSHARE
;;			would rather use CHANIO [for more channels]
;;=I26= Don't use SIMIO here, as it sets EOF and does error recovery
NOTYMSHR <
	MOVE	C,[GETSTS RACS+A(USER)]	;do a GETSTS (result to user A)
	DPB	CHNL,[POINT 4,c,12]	;on the correct channel
	XCT	C		;DO it (never skips)
>;NOTYMSHR
TYMSHR <
	HRLI	CHNL,17		;=.CHGS (chanio for getsts)
	CHANIO	CHNL,RACS+A(USER)	;results to user A, never skips
>;TYMSHR
;; ^^ SDD 5-OCT-79 ^^
	MOVE	LPSA,X22
	JRST	RESTR

DSCR SETSTS(CHANNEL,STATURS);
CAL SAIL


HERE(SETSTS)
	PUSHJ	P,SAVE
	LOADI7	A,<SETSTS>
	MOVE	CHNL,-2(P)
	PUSHJ	P,GETCHN
	MOVE	A,-1(P)		;INTENDED STATUS BITS
	XCT	SETIOSTS,SIMIO	;XECUTE THE INST
	JFCL			;SHOULDN'T SKIP
	MOVE	LPSA,X33
	JRST	RESTR		;GO RESTORE

ENDCOM(STS)
COMPIL(LOK,<LOOKUP,ENTER,FILEINFO>
	  ,<SAVE,RESTR,GETCHN,FILNAM,SIMIO,X33,X22,GOGTAB>
	  ,<LOOKUP, ENTER, AND FILEINFO ROUTINES>)
COMMENT \Lookup, Enter \

DSCR LOOKUP(CHANNEL,"FILE NAME",@FAILURE FLAG);
CAL SAIL


Comment \
LOOKUP or ENTER file FILENAME on channel CHANNEL, where FILENAME has
	a format acceptable to FILNAM above. If successful,
	FAILURE!FLAG (called by reference) is zeroed. It is
	otherwise set to -1 in LH, error code in RH.
\


.LOK:
HERE (LOOKUP) PUSHJ	P,SAVE
	LOADI7	A,<LOOKUP>
	PUSH	P,[XCT	IOLOOKUP,SIMIO]	;LOOKUP CH,FILE
	MOVEI	B,INAME			;TO STORE FILE NAME
	JRST	LOKENT			;DO THE OPERATION

DSCR ENTER(CHANNEL,"FILE NAME",@FAILURE FLAG);
CAL SAIL


HERE (ENTER)
	PUSHJ	P,SAVE
	LOADI7	A,<ENTER>
	PUSH	P,[XCT IOENTER,SIMIO]	;ENTER CH,FILE
	MOVEI	B,ONAME			;TO STORE FILE NAME
LOKENT:
	MOVE	LPSA,X33		;PARAM ADJUST FOR RESTR
	MOVE	CHNL,-3(P)		;GET CHANNEL #
	PUSHJ	P,GETCHN		;VALIDATE
	SETZM	@-2(P)			;ASSUME SUCCESS
	PUSHJ	P,FILNAM		;GET FILE
	 JRST	 BADSPC			; NO GOOD, REPORT ERROR
	ADD	B,CDB			;ADDR OF FILE NAME HOLDER
	MOVEW	(<(B)>,<FNAME(USER)>)	;STORE IT
TYMSHR <	MOVEI X,5	;SPECIAL LOOKUP HERE
	EXCH X,FNAME(USER)
	EXCH X,FNAME+2(USER)
	MOVEM X,FNAME+4(USER)
	MOVE X,FNAME+3(USER)
	EXCH X,FNAME+1(USER)
	MOVEM X,FNAME+3(USER)>;TYMSHR
	POP	P,X			;INSTRUCTION TO DO
	MOVE	Y,[JRST ELERR]		;FAILURE
NOTYMSHR <	MOVE	Z,[JRST RESTR]		;SUCCESS>;NOTYMSHR
TYMSHR <	MOVE Z,[JRST LOKNT1]		;SUCCESS>;TYMSHR
ENF1:	JRST	X			;ENTER/LOOKUP

BADSPC:	POP	P,(P)			;REMOVE IO INSTRUCTION
	HRRZ	TEMP,ERRTST(CDB)	;GET USER-ENABLE BITS
	TRNE	TEMP,10000		;ENABLED FOR HANDLING BAD FILE SPECS?
	ERR	<LOOKUP OR ENTER: INVALID FILE SPECIFICATION>,1 ;NO, TELL HIM
	SKIPA	TEMP,[=8]		;ALWAYS REPORT NO GOOD LOOKUP/ENTER
ELERR:	TYMSHR <PUSHJ P,LOKNTC>;TYMSHR
NOTYMSHR<	HRRZ	TEMP,FNAME+1(USER)	;WHY DID IT BLOW?>;NOTYMSHR
	HRROM	TEMP,@-1(P)		;TELL THE USER
	JRST	RESTR
TYMSHR <
LOKNTC:	MOVE TEMP,FNAME+4(USER)
	EXCH TEMP,FNAME+2(USER)	;PUT THINGS BACK
	MOVEM TEMP,FNAME(USER)
	MOVE TEMP,FNAME+1(USER)
	EXCH TEMP,FNAME+3(USER)
	MOVEM TEMP,FNAME+1(USER)
	POPJ P,

LOKNT1:	PUSHJ P,LOKNTC
	JRST RESTR>;TYMSHR
     






COMMENT \Fileinfo \

DSCR FILEINFO(INTEGER ARRAY INFO[1:6]);
CAL SAIL


Comment \ This routine gives the user the entire 6 word block
  from the last LOOKUP, ENTER, or RENAME operation done by SAIL.
\

HERE (FILEINFO)
	MOVE	USER,GOGTAB
	POP	P,UUO1(USER)		;GET RID OF IT, MARK LAST SAIL CALL
	POP	P,LPSA			;ARRAY ADDRESS WHERE INFO IS TO GO
	SKIPGE	-2(LPSA)		;MAKE SURE IT'S NOT A STRING ARRAY
	 ERR	 <PASS 6 WORD INTEGER VECTOR TO FILEINFO>,1
	MOVE	TEMP,-1(LPSA)		;TOTAL ARRAY SIZE WORD
	CAML	TEMP,[XWD 1,6]		;MUST BE 1-D, AT LEAST 6 WORDS
	CAMLE	TEMP,[XWD 1,-1]		;BUT NOT 2-D
	 ERR	 <PASS 6 WORD INTEGER VECTOR TO FILEINFO>,1
	MOVEI	TEMP,5(LPSA)		;BLT TERMINATOR
	HRLI	LPSA,FNAME(USER)	;SOURCE OF VALUABLE INFORMATION
	BLT	LPSA,(TEMP)		;GIVE!
	JRST	@UUO1(USER)		;GONE

ENDCOM (LOK)
COMPIL(OUT,<OUT>,<SAVE,RESTR,GETCHN,SIMIO,NOTOPN,X11,X22>
	  ,<STRING OUTPUT ROUTINE>)
COMMENT \Out \

DSCR OUT(CHANNEL,"STRING");
CAL SAIL

COMMENT \
Simply places all characters of string in output buffer for channel.
Close file if device is TTY    
\
.OUT.:
HERE (OUT)
	PUSHJ	P,SAVE		;ACS, GET USER, SAVE RETURN FOR ERROR
	MOVE	LPSA,X22
	MOVE	CHNL,-1(P)	;CHANNEL NUMBER
	LOADI7	A,<OUT>
	PUSHJ	P,GETCHN	;VALIDATE AND GET CDB, ETC.
	HRRE	Z,-1(SP)	;#CHARS
	POP	SP,D
	SUB	SP,X11
;;#WZ# JFR 6-17-76 TRAP OUT WITH NO PLACE TO PUT STRING
	SKIPN	B,OBP(CDB)
	 JRST	[ERRSPL	1,[[ASCIZ/
OUT: No buffer. Channel @D file @F:  @F  @F/]
			PWORD	CHNL
			PWORD	DNAME(CDB)
			PWORD	INAME(CDB)
			PWORD	ONAME(CDB)]
		JRST	RESTR]
;;#WZ# ^
	MOVE	A,OCOWNT(CDB)
	JRST	.OUT1

.OUT:
;; SDD 5-OCT-79 [=I22=] make count consistent.  Now OCOWNT=free "chars"
;was:
;	SOJLE A,OUT1
;.OUT2:
	SOJL	A,OUT1		;NEED OUTPUT??
;; ^^ SDD 5-OCT-79 [=I22=] ^^
	ILDB	X,D		;GET A CHAR
	IDPB	X,B		;PUT IT AWAY
.OUT1:	SOJGE	Z,.OUT		;LOOP
OUTDUN:	MOVEM	B,OBP(CDB)	;PUT BP AWAY
	MOVEM	A,OCOWNT(CDB)	;COUNT AWAY
	SKIPGE	TTYDEV(CDB)	;TTY?
	XCT	IOOUT,SIMIO	; YES, FORCE OUTPUT
	JRST	RESTR
	JRST	RESTR

OUT1:	LDB	TEMP,[POINT 4,DMODE(CDB),35] ;MODE
	CAIL	TEMP,15		;DUMP?
	 JRST	 DMPO		;YES
	MOVEM	B,OBP(CDB)	;PUT REAL BP AWAY
	XCT	IOOUT,SIMIO	;DO THE OUTPUT
	JFCL			;ERRORS HANDLED IN SIMIO
	MOVE	B,OBP(CDB)	;NEW BP
	MOVE	A,OCOWNT(CDB)	;NEW COUNT
;; SDD 5-OCT-79 [=I22=] make count consistent (was JRST .OUT2 below)
	JRST	.OUT		;CONTINUE

; SPECIAL DUMP-MODE OUTPUT STUFF

DMPO:	PUSH	P,D
	HRRZ	D,OBUF(CDB)	;PTR TO BUFFER AREA
	SUBI	D,1		;ADDR-1 FOR IOWD
	HRLI	D,-=128		;-WORD COUNT
	MOVEI	D+1,0
	XCT	IODOUT,SIMIO	;OUT D,
	JFCL			;ERRORS HANDLED IN SIMIO
OKO:	HRRZ	B,D		;SAVE ADDR
	HRLI	D,1(D)		;BLT WORD
	HRRI	D,2(D)
	SETZM	-1(D)
	BLT	D,=128(B)	;CLEAR BUFFER
	POP	P,D		;RESTORE INPUT BYTE POINTER
	AOS	@ENDFL(CDB)	;SPECIAL TREATMENT
	HRLI	B,700		;POINT 7,-1(1ST WORD),35
	MOVEM	B,OBP(CDB)
	MOVEI	A,5*=128	;CHAR COUNT
	MOVEM	A,OCOWNT(CDB)
;; SDD 5-OCT-79 [=I22=] make count consistent (was JRST .OUT2 below)
	JRST	.OUT		;AFTER OUTPUT SIMULATION, GO ON

ENDCOM(OUT)
COMPIL(INP,<INPUT>
	  ,<SAVE,.SKIP.,INSET,RESTR,SIMIO,GETCHN,STRNGC,BRKMSK,BKTCHK,X33,NOTOPN,GOGTAB
>
	  ,<STRING INPUT ROUTINE>)




COMMENT \Input \

DSCR  "STRING"_INPUT(CHANNEL,BREAK TABLE NUMBER);
CAL SAIL
SID NO ACS SAVED BY INPUT!!!!!!


.IN.:
HERE (INPUT)	
	MOVE	USER,GOGTAB	;GET TABLE POINTER
;;%##% FOR BENEFIT OF ERR ROUTINE
	MOVE	TEMP,(P)
	MOVEM	TEMP,UUO1(USER)
;;%##%
	MOVEM	RF,RACS+RF(USER);SAVE F-REGISTER
	SKIPE	SGLIGN(USER)
	PUSHJ	P,INSET
	MOVE	X,-1(P)		;TABLE #
	MOVEI	TEMP,-1		;ERROR IF BLOCK NOT THERE, NEEDS TO BE INIT'ED
	PUSHJ	P,BKTCHK	;CHECHK OUT TABLE #
	 JRST	[PUSH	SP,[0]	;ERROR (return null)
		PUSH	SP,[0]
		SUB	P,X33
		JRST	@3(P)]
	PUSH	P,CDB		;SAVE POINTER TO CORGET BLOCK
	PUSH	P,CHNL		;SAVE RANGE 1 TO 18
	MOVE	CHNL,-4(P)	;CHANNEL #
	LOADI7	A,<IN>		;ROUTINE NAME
	PUSHJ	P,GETCHN	;SET UP, VALIDATE
	LDB	E,[POINT 4,DMODE(CDB),35] ;DATA MODE
	CAIGE	E,15		;DUMP MODE?
	 SETZM	@ENDFL(CDB)	;NO, HELP USER ASSUME NO EOF,ERR
	SETZM	@BRCHAR(CDB)	;ASSUME NO BREAK CHAR
CMU <
	SETZM	.SKIP.
>;CMU
	HRRZ	A,@ICOUNT(CDB)	;MAX COUNT FOR INPUT STRING
	ADDM	A,REMCHR(USER)
	SKIPLE	REMCHR(USER)	;ENOUGH ROOM?
	PUSHJ	P,STRNGC	;NO, TRY TO GET SOME
	POP	P,TEMP
	MOVE	FF,BRKMSK(TEMP)	;GET MASK FOR THIS TABLE
	POP	P,LPSA		;LPSA POINTS AT CORGET BLOCK
	ADD	TEMP,LPSA	;TEMP IS RELOCATED 1 TO 18
	MOVEM	TEMP,-1(P)	;SAVE THIS BLOODY THING ON THE STACK
	MOVEI	Z,1		;FOR TESTING LINE NUMBERS
	SKIPN	LINTBL(TEMP)	;DON'T LET TEST SUCCEED IF
	 MOVEI	 Z,0		;WE'RE TO LET LINE NUMBERS THRU
	MOVN	B,A		;NEGATE MAX CHAR COUNT
	PUSH	SP,[0]		;LEAVE ROOM FOR FIRST STR WORD
	PUSH	SP,TOPBYTE(USER)	;SECOND STRING WORD
	MOVE	Y,LPSA
	ADD	Y,[XWD D,BRKTBL] ;BRKTBL+RLC(LPSA)
	JUMPE	B,DONE1		; BECAUSE THE AOJL WON'T
NOCMU<
	MOVEI	C,0
>;NOCMU
CMU <
	MOVS	C,DMODE(CDB)	;FUNNY MODE BITS TO RH
>;CMU
;;%DQ% 2! JFR 8-17-76
	TRNE	FF,@BRKDUM(LPSA);TREAT NULLS LIKE ORDINARY CITIZENS?
	 IORI	C,1		;YES, FLAG BIT
	TRNE	FF,@BRKCVT(LPSA) ;DOING UC COERCION?
	 TLOA	C,400000	;YES
	  TLZ	C,400000	;NO
	
.IN:
;; SDD 5-OCT-79 [=I22=] make count consistent.  Now ICOWNT=avail "chars"
;was:	SOSG	ICOWNT(CDB)	;BUFFER EMPTY?
;	JRST	DOINP		;YES, GET MORE
;IN1:	
	SOSGE	ICOWNT(CDB)	;BUFFER EMPTY?
	 JRST	DOINP		;YES, GET MORE
;; ^^ SDD 5-OCT-79 [=I22=] ^^
	ILDB	D,IBP(CDB)	;GET NEXT CHARACTER
	TDNE	Z,@IBP(CDB)	;LINE NUMBER (ALWAYS SKIPS IF NOT WORRIED)?
	 JRST	INLINN		;YES, GO SEE WHAT TO DO
;; SDD 5-OCT-79 [=I22=] removed label IN2
	JUMPE	D,[ TRNN  C,1	;REALLY IGNORE NULL??
		    JRST  .IN	;YES
		    JRST  .+1	;NOPE
		   ]
;;%AX% ugh! another instruction
	SKIPE	LINNUM(CDB)	;COUNTING VIA SETPL?
	JRST	[ CAIN	D,12		;LF?
		  AOS	@LINNUM(CDB)	;YES -- BUMP COUNT
;; #TB# ! (CMU =C9) TYPO, USED TO BE CAIE C,14
		  CAIE	D,14		;FF?
		  JRST	.+1		;NOPE
		  SKIPN	PAGNUM(CDB)	;BE SURE NO MESSUP
		  ERR	<DRYROT -- SETPL LOSSAGE DETECTED IN INPUT>,1,NOCV.I
		  AOS	@PAGNUM(CDB)	;BUMP PAGE COUNT
		  SETZM	@LINNUM(CDB)	;THE LINE COUNT _ 0
		  JRST	NOCV.I		;SINCE KNOW NOT LOWER CASE
		]
;;%##%	COERCING ??
	JUMPGE	C,NOCV.I	;NOT COERCIING ??
	CAIL	D,"a"		;ONLY COERCE LOWER CASE
	CAILE	D,"z"		;
	JRST	.+2		;FAST SKIP
	TRZ	D,40		;MAKE UC
NOCV.I:	TDNE	FF,@Y		;MUST WE DO SOMETHING SPECIAL?
	JRST	INSPC		;YES, HANDLE

MOVEC:	IDPB	D,TOPBYTE(USER)	;LENGTHEN STRING
	AOJL	B,.IN		;GET SOME MORE
	JRST	DONE1

INSPC:	HLLZ	TEMP,@Y		;IGNORE OR BREAK?
	TDNN	TEMP,FF		;  (CHOOSE ONE)
	JRST	.IN		;IGNORE

;  BREAK -- STORE BREAK CHAR, FINISH OFF

DONE:	MOVEM	D,@BRCHAR(CDB)	;STORE BREAK CHAR
	MOVE	TEMP,-1(P)	;RELOCATED 1 TO 18
	SKIPN	Y,DSPTBL(TEMP)	;WHAT TO DO WITH BREAK CHAR?
	JRST	DONE1		;SKIP IT
	JUMPL	Y,APPEND	;ADD TO END OF INPUT STRING

RETAIN:	SOS	IBP(CDB)		;BACK UP TO GET IT NEXT TIME
	FOR II_1,4 <
	IBP	IBP(CDB)>
	AOS	ICOWNT(CDB)
	JRST	DONE1

APPEND:	IDPB	D,TOPBYTE(USER)	;PUT ON END
	AOJA	B,DONE1		;ONE MORE TO COUNT

INEOF1: POP	P,D+1		;LEFT OVER FROM DUMP MODE ROUT

;  DONE -- MARK STRING COUNT WORD

DONE1:	ADDM	B,REMCHR(USER)	;GIVE UP THOSE NOT USED
	ADD	B,@ICOUNT(CDB)	;HOW MANY DID WE ACTUALLY GET?
;;#GI# DCS 2-5-72 REMOVE TOPSTR
	HRROM	B,-1(SP)	;MARK RESULT, NON-CONSTANT
;;#GI#
	MOVE	RF,RACS+RF(USER);GET F-REGISTER BACK
	SUB	P,X33		;REMOVE INPUT PARAMETER, RETURN ADDRESS
	JRST	@3(P)		;RETURN

;  CAN EITHER DELETE LINE NUMBER (Y GT 0) OR STOP,
;  TELL THE USER (BRCHAR=-1), AND MARK LINE NUMBER
;  NOT A LINE NUMBER FOR NEXT TIME
; GET A NEW BUFFER

DOINP:
CMU <
	AOS	.SKIP.
>;CMU
	CAIL	E,15		;DUMP MODE?
	 JRST	 DMPI		; YES
	XCT	IOIN,SIMIO	;IN CHAN,0
;; SDD 5-OCT-79 [=I22=] make count consistent.  was JRST IN1
	 JRST	 .IN		;ALL OK, CONTINUE
	 JRST	 DONE1		;ERROR OR EOF, QUIT

; DUMP MODE SIMULATION OF SAME
DMPI:	PUSH	P,D+1
	HRRZ	D,IBUF(CDB)	;PTR TO BUFFER AREA
	SUBI	D,1
	HRLI	D,-=128
	MOVEI	D+1,0
	XCT	IODIN,SIMIO	;IN CHAN,D
	 JRST	OKI
	 JRST	INEOF1		;REMOVE D,QUIT
OKI:	POP	P,D+1
	AOS	@ENDFL(CDB)	;SPECIAL TREATMENT
	HRLI	D,700
	MOVEM	D,IBP(CDB)
	MOVEI	A,5*=128
	MOVEM	A,ICOWNT(CDB)
;; SDD 5-OCT-79 [=I22=] make count consistent.  was JRST IN1
	JRST	.IN		;DONE SIMULATING, RETURN

INLINN:
;;%AX% MORE SETPL STUFF
	SKIPE	SOSNUM(CDB)	;DOES THE USER WANT IT???
	JRST	[ MOVE	TEMP,@IBP(CDB) ;YES
		  MOVEM	TEMP,@SOSNUM(CDB);
		  JRST	.+1 ]
	MOVE	TEMP,-1(P)	;RELOCATED 1 TO 18
	SKIPGE	TEMP,LINTBL(TEMP) ;WHAT ABOUT LINE #?
	 JRST	 GIVLIN		; WANTS IT NEXT TIME OR SOMETHING
	JSP	TEMP,EATLIN	;TOSS IT OUT, AND 
	JRST	.IN		; CONTINUE

EATLIN:
	AOS	IBP(CDB)	;FORGET IT ENTIRELY
	MOVNI	A,5		;INDICATE SKIPPING SIX
	ADDB	A,ICOWNT(CDB)	;IN COUNT
				;OVERFLOW BUFFER?
;; SDD 5-OCT-79 [=I22=] make count consistent.  was JUMPG A,(TEMP)
	JUMPGE	A,(TEMP)	;NO, CONTINUE
	CAIL	E,15
	 ERR	 <CAN'T HANDLE THIS FILE IN DUMP MODE>
	XCT	IOIN,SIMIO	;YES, GET TAB FROM NEXT BUFFER
	 JRST	OKLN		;GOT IT, CONTINUE
	 JRST	DONE1

OKLN:	SOSG	ICOWNT(CDB)	;IF ONLY ONE CHAR,
	JRST	[MOVEI TEMP,20000	;THEN EOF COMES NEXT
		 IORM  TEMP,@ENDFL(CDB)
		 JRST  DONE1]	;ALL DONE
	IBP	IBP(CDB)	;GET OVER TAB FINALLY
;; SDD 5-OCT-79 [=I22=] make count consistent.  PM hack obviated
;;#PM  12-1-73 RLS  DONT LOSE A CHARACTER IN THE (NEW) BUFFER 
;	AOS	ICOWNT(CDB)	;INCREMENT COUNT
;;#PM
	JRST	(TEMP)		;AND CONTINUE


GIVLIN:	TRNE	TEMP,-1		;WANT LINE NO IN BRCHAR WORD?
	 JRST	 GVLLN		;NO, WANTS IT NEXT TIME.
	SKIPL	TEMP,@IBP(CDB)	;NEGATED LINE NO
	MOVNS	TEMP
	MOVEM	TEMP,@BRCHAR(CDB) ;STORE WHERE HE WANTS IT
	JSP	TEMP,EATLIN	;GO EAT UP LINE NUMBER AND
	JRST	DONE1		;FINISH UP
GVLLN:
	SETOM	@BRCHAR(CDB)	;TELL THE USER
	AOS	ICOWNT(CDB)	;REVERSE THE SOSLE
	MOVEI	Y,1		;TURN OFF LINE NUMBER 
	ANDCAM	Y,@IBP(CDB)	;  BIT
	MOVSI	Y,070000	;BACK UP BYTE POINTER
	ADDM	Y,IBP(CDB)
	JRST	DONE1		;FINISH OFF IN BAZE OF GORY

ENDCOM(INP)
COMPIL(NUM,<LREALIN,LREALSCAN,REALIN,REALSCAN,INTIN,INTSCAN>
	  ,<SIMIO,SAVE,RESTR,X11,X22,X33,X44,GETCHN,NOTOPN>
	  ,<STRING TO NUMBER CONVERSION>)




IFN ALWAYS,<BEGIN NUMIN>
HERE (REALIN)
	PUSHJ	P,SAVE
	PUSHJ	P,NUMIN		;SET UP TO GET CHARS FROM CHANNEL
	PUSHJ	P,RLNIN		;GOBBLE A REAL NUMBER
	SNGL	A,A
INRETA:	MOVEM	A,RACS+A(USER)
INRET:
	MOVEM	Z,@BRCHAR(CDB)	;FIX UP BREAK CHARACTER
	SOS	IBP(CDB)	;BACK UP TO GET IT NEXT TIME
FOR II_1,4 <
	IBP	IBP(CDB)>
	AOS	ICOWNT(CDB)
	MOVE	LPSA,X22	;GET RID OF CHANNEL AND RET. WD
	JRST	RESTR

HERE (REALSCAN)
	PUSHJ	P,SAVE
	PUSHJ	P,STRIN		;SET UP TO GET CHARS FROM A STRING
	PUSHJ	P,RLNIN
	SNGL	A,A
STRRTA:	MOVEM	A,RACS+A(USER)
STRRET:
	HRRZ	X,-2(P)
	SOJ	CDB,		;BACK UP BYTE POINTER
FOR II_1,4<
	IBP	CDB>
	MOVEM	CDB,(X)
	AOJ	CHNL,
	HRRM	CHNL,-1(X)
	MOVEM	Z,@-1(P)	;STORE BREAK CHARACTER
	MOVE	LPSA,X33	;GET RID OF BRK VAR, STR ADDR
	JRST	RESTR

FNDDIG:			;FIND DIGIT OR DECIMAL POINT, KEEP TRACK OF SIGN
	EXCH	A,(P)		;FIRST PUT "GET NEXT CHAR" INSTR ON STACK
	PUSH	P,A		;AHEAD OF RETURN WORD
FNDDI1:	XCT	-1(P)		;GET NEXT CHAR
	CAIL	D,"0"
	CAILE	D,"9"
	CAIN	D,"."
	 POPJ	P,
	JUMPL	D,.-1		;EOF OR END OF STRING
	CAIN	D,"-"
	 TLOA	FF,NUMNEG
	TLZ	FF,NUMNEG	;SIGN MUST IMMEDIATELY PRECEDE NUMBER
	JRST	FNDDI1

RLNIN:
	SETZ	FF,		;ZERO FLAGS
	PUSHJ	P,FNDDIG
	JUMPL	D,.+2
	 TLO	FF,NUMSAW	;THERE WAS PART OF A NUMBER
	PUSHJ	P,GETNUM	;TRY FOR AN INTEGER
	CAIE	D,"."
	 TRZA	C,-1		;NO DIGITS AFTER DEC PT.
	 PUSHJ	P,GETN1D	;FINISH UP FRACTION
	EXCH	C,(P)		;DIGIT COUNTS  NXTCHR INSTR
	PUSH	P,X		;PARTIAL RESULT
	PUSH	P,Y
	PUSH	P,FF		;FLAGS
	PUSH	P,C		;NXTCHR INSTR
	SETZ	FF,		;EXPONENT FLAGS
	CAIE	D,"@"
	CAIN	D,"E"
	 JRST	[XCT	(P)		;EAT A CHAR
		CAIE	D,"@"
		CAIN	D,"E"
	RLNIN2:	 XCT	(P)		;ALLOW FOR TWO OF THESE
		CAIN	D,"-"
		 TLOA	FF,NUMNEG
		CAIN	D,"+"
		 XCT	(P)		;PAST SIGN
		PUSHJ	P,GETNUM	;RECURSE FOR EXPONENT
		PUSHJ	P,TZMUL	;GET EXPONENT AS AN INTEGER
		JUMPN	C,RLNIN1
		 ERR	<NUMIN: Improper exponent>,1	;NO DIGITS APPEARED
		JRST	RLNIN1
		]
	CAIN	D,"D"
	 JRST	RLNIN2
	SETZB	X,Y		;EXPONENT IS ZERO
	SETZ	C,		;AND THERE WERE NO DIGITS IN IT
RLNIN1:
	MOVE	Z,D		;SAVE BRCHAR (COULD BE -1 FOR EOF)
	SUB	P,X11		;GET RID OF NXTCHR INSTR
	TLNN	FF,NUMNEG
	 SKIPA	D,Y		;LOW WD OF EXPONENT
	 MOVN	D,Y		;EXPONENT WAS NEG
	POP	P,FF		;FLAGS OF FRACTION
			;-2(P): FRACTION DIGIT COUNTS
			;-1(P), -0(P): FRACTION
	TLNN	C,-1		;IF ANY TRAILING ZEROES LEFT, A WHOPPING BIG EXP.
	SKIPE	X		;HIGH PART HAD BETTER BE ZERO
	 JRST	[SUB	P,X33	;WIPE OUT FRACTION AND DIGIT COUNTS
		 JRST	DFSERR]	;AND COMPLAIN
	POP	P,Y		;FRACTION PART
	POP	P,X
	POP	P,C		;DIGIT COUNTS OF FRACTON
	JRST	DFSC
	
;SDD- 04-FEB-80: lets recycle those spares  (why take both inputs)
;;was: HEREFK(LREALIN,LREA.IN)
HERE(LREALIN)
	PUSHJ	P,SAVE
	PUSHJ	P,NUMIN
	PUSHJ	P,RLNIN
	DMOVEM	A,RACS+A(USER)
	JRST	INRET

;SDD- 04-FEB-80: lets recycle those spares  (why take both inputs)
;;was: HEREFK(LREALSCAN,LREA.SCAN)
HERE(LREALSCAN)	
	PUSHJ	P,SAVE
	PUSHJ	P,STRIN
	PUSHJ	P,RLNIN
	DMOVEM	A,RACS+A(USER)
	JRST	STRRET

printx	**** INTIN (and INTSCAN) have been hacked by CLH.  
printx	**** unfortunately, this has not been tested on TOPS-10
HERE (INTIN)
	PUSHJ	P,SAVE
	PUSHJ	P,NUMIN
	PUSHJ	P,RLNIN
;;SDD 5-OCT-79 [CLH] RFIX will now do longReal to Integer directly
;	SNGL	A,A
	PUSHJ	P,RFIX
	JRST	INRETA

RFIX:			;SIGN(A)*FLOOR(ABS(A)+0.5) 
		;;expects bit NUMNEG on in FF iff number negative
		;;takes arg in A,A+1 returns A, mangles A+1,C
		;; REQUIRES: sign bit of A+1 OFF
;;SDD 5-OCT-79 [CLH] make RFIX do longReal to Integer directly
KI10 <
	caige	a,0	;take absolute value
	 dmovn	a,a	;negation is simple unless you are a KA
>;KI10
NOKI10 <
	jumpge	a,rfix1	;first, take absolute value
	setca	a,	;negation is ones complement
	movn	a+1,a+1	;and increment
	tlz	a+1,400000	;Note sign of second word should be 0
				;all positives can be negated
	jumpn	a+1,rfix1	;if we went from 377777,,777777 to 0
	 aoja	a,rfix1	;then we need to carry into high order word
rfix1:
>;NOKI10
	caml	a,[xwd 243777,777777]	;first part of 377777,,777777
	 jsr	c,vbig		;candidate for overflow, look closely
	ldb	c,[point 9,a,8]	;obtain exponent
	tlz	a,777000	;and remove it
	ashc	a,-233(c)	;shift to make integer (cant ovfl)
	tlne	a+1,200000	;this is the .5 bit, need we round?
	 addi	a,1		;sho nuff, (check above prevents ovfl)
signgo:	tlne	ff,numneg	;was negative? (presumptuous, isn't it)
	 movn	a,a		; in that case restore the sign bit
	popj	p,

vbig:	camg	a,[xwd 243777,777777]	;if w1 part bigger
	 caml	a+1,[xwd 377600,000000]	;or will round to 1B0
	  jrst	.+2			;then we know we will ovfl pos
	  jrst	(c)			;otherwise we will fit
	tlnn	ff,numneg		;could it be super-negative ?
	 jrst	rfixer			;no way jack, bitch
	caml	a,[xwd 244400,0]	;if less than super-neg in w1
	 camge	a,[xwd 000200,0]	;or won't round up
	  jrst		.+2		;  then don't error message 
rfixer:	err <RFIX: (INTIN or INTSCAN) Number too big>,1
	hrloi	a,377777	;return "infinity" (not zero)
	tlne	ff,numneg	;was negative? 
	 hrlzi	a,400000	; yes --- use minus infinity - 1 
	popj	p,		;and return

repeat 0,<
KI10<	JUMPL	A,.+3
	 FIXR	A,A
	 POPJ	P,
	MOVN	A,A
	FIXR	A,A
	MOVN	A,A
	POPJ	P,
>;KI10
NOKI10<	JUMPL	A,.+4
	 FADRI	A,(0.5)		;SORRY, 166 !
	 FIXUUO	A,A		;SDD 25-OCT-79 changed name for clarity
	 POPJ	P,
	MOVN	A,A
	FADRI	A,(0.5)
	FIXUUO	A,A		;SDD 25-OCT-79 changed name for clarity
	MOVN	A,A
	POPJ	P,
>;NOKI10
>;repeat 0
;; ^^ SDD 5-OCT-79 [CLH] ^^

HERE (INTSCAN)
	PUSHJ	P,SAVE
	PUSHJ	P,STRIN
	PUSHJ	P,RLNIN
;;SDD 5-OCT-79 [CLH] RFIX will now do longReal to Integer directly
;	SNGL	A,A
	PUSHJ	P,RFIX
	JRST	STRRTA

COMMENT \
.INSERT SAILPD.FAI[S,AIL]
	SAILPD	($REALIN,REAL,1,0,<INTEGR>)
	SAILPD	($INTIN,INTEGR,1,0,<INTEGR>)
	SAILPD	($REALSCAN,REAL,2,0,<STRING+REFERENCE,INTEGR+REFERENCE>)
	SAILPD	($INTSCAN,INTEGR,2,0,<STRING+REFERENCE,INTEGR+REFERENCE>)
	SAILPD	(LREALIN,DBLPRC+REAL,1,0,<INTEGR>)
	SAILPD	(LREALSCAN,DBLPRC+REAL,2,0,<STRING+REFERENCE,INTEGR+REFERENCE>)
\



NUMIN:			;SET UP TO READ FROM A CHANNEL
	MOVE	CHNL,-2(P)
	LOADI7	A,<IN>
	PUSHJ	P,GETCHN;	SET UP FOR INPUT
	SETZM	@ENDFL(CDB);	CLEAR EOF AND BREAK FLAGS
	SETZM	@BRCHAR(CDB)
	MOVE	A,[JSP A,NCH]	;instruction which reads a character
	MOVEI	Z,1;		FOR LINE NUMBER TEST
	POPJ	P,

NCH:
;;SDD 5-OCT-79 [=I22=] make counts on I/O consistent
;;was:	SOSG	ICOWNT(CDB);	DECREMENT CHARACTER COUNT
;;	 JRST	NCH2
;;NCH1:
	SOSGE	ICOWNT(CDB)	;decrement character count, we done?
	 JRST	NCH2		;ahh well, go read some more
;; ^^ SDD 5-OCT-79 [=I22=] ^^
	ILDB	D,IBP(CDB);	LOAD BYTE
	TDNE	Z,@IBP(CDB);	CHECK FOR LINE NUMBER
	 JRST	NCH5
	CAIN	D,15		;IGNORE CR
	 JRST	NCH
	JUMPE	D,NCH		;AND NUL
	SKIPN	LINNUM(CDB)	;WANT SETPL STUFF???
	 JRST	(A) 		;NO, RETURN
	CAIN	D,12		;YES, IS THIS A LF?
	 AOS	@LINNUM(CDB)	;YES, BUMP LINE COUNT
	CAIE	D,14		;A FF?
	JRST	(A)		;NOPE
	SKIPN	PAGNUM(CDB)	;BUG TRAP
	JRST    [ ERR	<DRYROT -- SETPL LOSSAGE DETECTED BY NUMIN>,1
		JRST	(A) ]
	AOS	@PAGNUM(CDB)	;BUMP PAGE COUNT
	SETZM	@LINNUM(CDB)	;ZERO LINE COUNT
	JRST	(A)		;RETURN
NCH2:	XCT	IOIN,SIMIO;	INPUT
;;SDD 5-OCT-79 [=I22=] make counts on I/O consistent (was NCH1 below)
	 JRST	NCH		;ALL OK
NCH7:	SETO	D,		;EOF OR DATA ERROR.
	JRST	(A)
NCH5:				;line number encountered
	SKIPE	SOSNUM(CDB)	;DOES THE LOSER WANT IT??
	 JRST	[MOVE	D,@IBP(CDB)	;YES, GET IT
		MOVEM	D,@SOSNUM(CDB)	;WHERE HE SAID TO PUT IT
		JRST	.+1]
	AOS	IBP(CDB)	;WE HAVE A LINE NUMBER
	MOVNI	D,5		;MOVE OVER IT
	ADDB	D,ICOWNT(CDB)
;;SDD 5-OCT-79 [=I22=] make counts on I/O consistent
;;was:	SKIPLE	D		;NOTHING LEFT
;;	 JRST	NCH		;DO ANOTHER INPUT
				;The Byte pointer and char count have
				;been advanced 6 bytes(init ch+1 word)
	jumpge	d,nch		;if we passed tab, ok (ICOWNT GEQ 4)
				;otherwise read tab from next buffer
				; [here ICOWNT should be -1]
;; ^^ SDD 5-OCT-79 [=I22=] ^^
	XCT	IOIN,SIMIO
NCH6:	SOSG	ICOWNT(CDB)	;REMOVE TAB
	 JRST	NCH7		;NONE THERE OR ERROR
	IBP	IBP(CDB)
	JRST	NCH

STRIN:			;SET UP TO READ FROM A STRING
	MOVE	A,[JSP A,NCHA]
	HRRZ	CHNL,-3(P)	;ADDR OF WD2
	MOVE	CDB,(CHNL)	;BP
	HRRZ	CHNL,-1(CHNL)	;LENGTH
	POPJ	P,

NCHA:	SOJL	CHNL,NCH7
	ILDB	D,CDB
	CAIN	D,15
	 JRST	NCHA		;IGNORE CR
	JUMPE	D,NCHA		;AND NUL
	JRST	(A)
;LNUMIN	NUMBER INPUT
COMMENT \
These routines form a character-string to number conversion package.
GETNUM eats characters one at a time until a non-digit is eaten;
GETNUM then returns intermediate information which can be used
by the other routines.
GETNU1 is the routine to call after GETNUM when a decimal point
is seen and you eventually want a floating point number.

GETNUM:	-1(P)	instruction to XCT, gets next character in D
	(P)	return word
	D	first digit
result:	as in GETNU1

GETNU1:	X,Y	double length partial integer result
	-1(P)	instruction to XCT, gets next character in D
	(P)	return word
	C	# trailing zeroes ,, power of 10 scale factor
	D	first digit
result:	X,Y	double length partial integer result
	(P)	instructin to XCT, gets next character in D
	FF	flags (sign, overflow)
	C	# trailing zeroes ,, scale factor + # digits since then
	D	break character

MAKINT:	X,Y	double length partial integer result
	(P)	return word
	FF	sign flag
	C	# trailing zeroes ,, junk
result:	A	integer value

DFSC:
	X,Y	double length partial integer result
	(P)	return word
	FF	flags
	C	# trailing zeroes ,, # digits since decimal point
	D	exponent
result:	A,B	floating point value

AC USAGE:

FF	flags
A,B	double temp		return word for JSP NCH
C	#tz ,, # digits
D	char
X,Y	double integer partial result
Z	1 (for testing line numbers)
CHNL	channel number, or # chars left in string
CDB	channel data block addr, or bp to string
RF	res.
LPSA	scale factor for DMUL	gen.temp.
TEMP	gen. temp.
USER	res.
SP	res.
P	res.

\



;GETNUM GETNU1

NUMNEG__400000
EXPNEG__200000
NUMSAW__100000

GETNUC:	XCT	-1(P)		;GET A CHAR FIRST
GETNUM:
	SETZB	X,Y		;INITIAL RESULT
	SETZ	C,		;DIGIT COUNTS
	JRST	2,@.+1		;CLEAR FLAGS
	GETNU1

GETN1D:	TRZA	C,-1		;NUMBER OF DIGITS SINCE DEC. PT IS ZERO
GETN1E:	AOBJN	C,.+1		;A TRAILING ZERO
GETN1C:	XCT	-1(P)		;GET NEXT CHAR
GETNU1:	CAIL	D,"0"
	CAILE	D,"9"
	 POPJ	P,		;NOT DIGIT
	SUBI	D,"0"		;CONVERT TO DIGIT NOW
	JUMPE	D,GETN1E	;A TRAILING ZERO
	ADDI	C,1		;ANOTHER DIGIT
	TLNE	C,-1		;WERE THERE TRAILING ZEROES BEFORE IT?
	 PUSHJ	P,TZMUL		;YES
	PUSHJ	P,M10ADD	;MULT BY =10 AND ADD D
	JRST	GETN1C

TZMUL:	HLRZ	TEMP,C		;# TRAILING ZEROES
	JUMPE	TEMP,CPOPJ	;QUIT IF NONE
	MOVEI	C,(C)		;WILL BE NONE IF WE FINISH WITHOUT OVERFLOW
;;%YZ%	pmf Feb 11 77
;	CAIN	TEMP,(C)
;	 JRST	CPOPJ		;TRAILERS WERE ALSO LEADERS!
	MOVEI	LPSA,(D)	;SAVE DIGIT
	SETZ	D,
	PUSHJ	P,M10ADD	;ADJUST VALUE TO ACCOUNT FOR TRAILING ZEROES
	SOJG	TEMP,.-2
	MOVEI	D,(LPSA)	;RESTORE D
	POPJ	P,

M10ADD:
	MOVE	A,Y		;LOW HALF
	MULI	A,=10
	TLO	A+1,400000	;PREVENT OVERFLOW
	ADDI	A+1,(D)		;ADD NEW DIGIT
	TLZN	A+1,400000	;WOULD THERE HAVE BEEN AN OVERFLOW?
	 ADDI	A,1		;YES. (THIS CAN'T OVERFLOW; A WAS AT MOST 9)
	MOVE	D,X		;HIGH HALF
	IMULI	D,=10
	 JOV	[ADD	C,X11	;PRETEND WE HAD A TRAILING ZERO
		SOJA	C,CPOPJ]
	TLO	D,400000	;PREVENT OVERFLOW
	ADDI	D,(A)		;CARRY IN FROM LOW HALF
	TLZN	D,400000	;WOULD THERE HAVE BEEN AN OVERFLOW?
	 JRST	@.-4		;YES
	MOVEM	A+1,Y		;STORE LOW HALF
	MOVEM	D,X		;AND HIGH HALF
CPOPJ:	POPJ	P,



;DFSC

;	FF	NUMNEG FLAG
;	C	# TRAILING ZEROES,, # DIGITS SINCE DECIMAL PT.
;	D	EXPONENT
;	X,Y	FRACTION

DFSC:
	MOVE	A,X		;BEGIN CONVERTING TO PURE FRACTION
	JFFO	A,DFSC1
	MOVE	A,X+1		;HIGH WD WAS ZERO
	JFFO	A,.+1
	ADDI	A+1,=35
DFSC1:	MOVEI	LPSA,-1(A+1)	;# OF PLACES TO SHIFT (REMEMBER SIGN BIT)
	ASHC	X,(LPSA)	;MAKE INTO PURE FRACTION
	SUBI	LPSA,=70
	MOVN	LPSA,LPSA	;EXPONENT OF 2 OF FRACTION
	
;***** SOMETHING FISHY HERE.  CONSIDER 12345.98@3
	SUBI	D,(C)		;DIGITS SINCE DECIMAL POINT DECREASE THE EXPONENT
	HLRZ	C,C
	ADDI	D,(C)		;BUT TRAILING ZEROES DONT COUNT
	JUMPE	D,DFSC2		;EXPONENT OF 10 IS ZERO
	JUMPG	D,DFSC3
	TLO	FF,EXPNEG	;EXPONENT WAS NEG
	MOVN	D,D
	SKIPA	TEMP,[EXP.M1,,FR.M1]	;USE THIS TABLE SINCE EXP WAS NEG
DFSC3:	MOVE	TEMP,[EXP.P1,,FR.P1]	;EXP WAS POS
	TRNE	D,777700	;CHECK EXPONENT RANGE
	 JRST	DFSERR
	TRNE	D,40		;E+-32 INVOLVED?
	TLNE	FF,EXPNEG	;YES. TOO BAD IF E-48
	 JRST	MULOOP		;OK
	TRNE	D,20		;E-48 ?
	 JRST	DFSERR
MULOOP:	TRZE	D,1		;SHOULD WE MULTIPLY?
	 PUSHJ	P,DMUL..	;YES
	JUMPE	D,DFSC2
	ASH	D,-1		;NEXT BIT INTO POSITION
	AOBJN	TEMP,.+1	;ADD 1 TO LH
	AOJA	TEMP,MULOOP	;AND 2 TO RH

DFSC2:
KI10<	DMOVE	A,X	>;KI10
NOKI10<	MOVE	A,X
	MOVE	A+1,X+1	>;NOKI10
	ASHC	A,-8		;MAKE ROOM FOR EXPONENT
	FSC	A,200(LPSA)	;INSERT IT
	JFOV	DFSERR
DFSC4:
	JUMPGE	Z,.+3		;IF RAN OUT OF CHARS
	 TLNE	FF,NUMSAW	; AND SAW NUMBER
	  MOVEI	Z,0		;  THEN FLAG IT THIS WAY
KI10<	TLNE	FF,NUMNEG
	 DMOVN	A,A
	POPJ	P,
>;KI10
NOKI10<	TLNN	FF,NUMNEG
	 POPJ	P,
	SETCA	A,		;ONES COMPLEMENT OF HIGH WORD
	MOVN	A+1,A+1		;TWOS COMPLEMENT OF LOW WORD
	TLZ	A+1,400000	;FORCE SIGN BIT OFF
	JUMPN	A+1,CPOPJ	;IF LOW SIGNIFICANCE, DONE
	AOJA	A,CPOPJ		;OTHERWISE TWOS COMPLEMENT OF HIGH WORD
>;NOKI10

DFSERR:	ERR	<NUMIN: Exponent range exceeded>,1
	SETOB	A,A+1
	TLNN	FF,EXPNEG
	 TLZA	A,400000	;EXPONENT WAS POS, GIVE AN INFINITY
	SETZB	A,A+1		;EXPONENT WAS NEG, GIVE ZERO
	JRST	DFSC4		;OF RIGHT SIGN



;DMUL..
;MULTIPLY TWO DOUBLE-LENGTH PURE FRACTIONS. ONE IS (TEMP), OTHER IS X,Y PAIR
;RETURN DOUBLE-LENGTH RESULT IN X,Y
;SCALE FACTOR KEPT IN LPSA

DMUL..:
NOKL10<	PUSH	P,X		;SAVE HIGH
	SETZM	X		;1ST WORD, FINAL PRODUCT
	MOVE	A,(TEMP)	;HIGH
	MULM	A,Y		;* LOW
				;IGNORING 3RD WORDS: 8 EXPONENT BITS TO BURN
	MOVE	A,1(TEMP)	;LOW
	MUL	A,(P)		;* HIGH
	TLO	A,400000	;PREVENT OVERFLOWS
	ADD	A,Y		;ADD 2ND WORDS
	TLZN	A,400000	;WOULD THERE HAVE BEEN AN OVERFLOW?
	 AOS	X		;YES, DO CARRY (SETS X TO 1)
	MOVEM	A,Y		;STORE LOW RESULT
	POP	P,A		;HIGH
	MUL	A,(TEMP)	;* HIGH
	TLO	A+1,400000	;PREVENT OVERFLOW
	ADD	A+1,Y		;COLLECT 2ND WORD
	TLZN	A+1,400000	;WOULD THERE HAVE BEEN AN OVERFLOW?
	 ADDI	A,1		;YES
	ADD	A,X		;COLLECT 1ST WORD (THIS CAN'T OVERFLOW)
>;NOKL10
KL10<
	DMOVE	A,X
	DMOVEM	A+2,X
	DMUL	A,(TEMP)
	DMOVE	A+2,X
>;KL10
	TLNE	A,(1B1)		;NORMALIZED FRACTION?
	 JRST	.+3		;YES
	ASHC	A,1		;NO, SHIFT OVER
	SUBI	LPSA,1		;AND ADJUST EXPONENT
	MOVS	TEMP,TEMP		;COLLECT EXPONENT CHANGES
	ADD	LPSA,(TEMP)
	MOVS	TEMP,TEMP
	MOVEM	A,X		;STORE RESULT SO FAR
	MOVEM	A+1,Y
	POPJ	P,

FR.P1:	240000,,0	;10^1		PURE FRACTION PART
	0
	310000,,0	;10^2
	0
	234200,,0	;10^4
	0
	276570,,200000	;10^8
	0
	216067,,446770	;10^16
	040000,,0
	235613,,266501	;10^32
	133413,,263574
EXP.P1:	4				;POWER OF 2 EXPONENT PART
	7
	16
	33
	66
	153

FR.M1:	314631,,463146	;10^-1
	146314,,631463
	243656,,050753	;10^-2
	205075,,314217
	321556,,135307	;10^-4
	020626,,245364
	253630,,734214	;10^-8
	043034,,737425
	346453,,122766	;10^-16
	042336,,053314
	317542,,172552	;10^-32
	051631,,227215
EXP.M1:	-3
	-6
	-15
	-32
	-65
	-152
ENDCOM(NUM)
COMPIL(TBB,<.CH.,.TEN.,.MT.>,,<TABLES FOR L PAUL'S ROUTINES>)




DSCR DATA TABLES FOR REALIN, INTSCAN, ETC.


^^.CH.:	4
	7
	16
	33
	66
	153
	777777777775
	777777777772
	777777777763
	777777777746
	777777777713
	777777777626
^^.MT.:	240000000000
	310000000000
	234200000000
	276570200000
	216067446770
	235613266501
	314631463147
	243656050754
	321556135310
	253630734215
	346453122767
	317542172553
^^.TEN.:	1
	=10
	=100
	=1000
	=10000
	=100000
	=1000000
	=10000000
	=100000000
	=1000000000
	=10000000000

ENDCOM(TBB)
IFN ALWAYS,<
	BEND
>;IFN ALWAYS
COMPIL(WRD,<ARRYOUT,WORDOUT,ARRYIN,WORDIN>
	  ,<GETCHN,SAVE,RESTR,GOGTAB,SIMIO,X22,X33,X44,NOTOPN>
	  ,<ARRYIN, ARRYOUT, WORDIN, AND WORDOUT>)




COMMENT \Arryout, Wordout \

DSCR ARRYOUT(CHANNEL,@STARTING LOC,EXTENT);
CAL SAIL


HERE (ARRYOUT)
	PUSHJ	P,SAVE
	MOVE	LPSA,[XWD 4,4]
ARO:	MOVE	CHNL,-3(P)
	LOADI7	A,<ARRYOUT>
	PUSHJ	P,GETCHN
;;%##% CONSIDER THIS
CMU <
	SETZM	@ENDFL(CDB)	;CLEAR ERROR FLAG
>;CMU
	LDB	TEMP,[POINT 4,DMODE(CDB),35] ;CHECK MODE
CMU <
;;=B4= 1 OF 13 -- FOR CMU SPECIAL MODES.
	MOVEI	Z,1		;ASSUME NOT IMP MODE
	CAIN	TEMP,3		;IS THE MODE 3?
	 TRZA	Z,-1		; YES - CMU 32-BIT IMP MODE.
				; WE WILL USE Z BOTH AS SIGNAL AND AS
				; A GUARANTEED 0 THAT CAN BE USED FOR A DPB
	CAIN	TEMP,4		; (THIS ONE IS CMU-IMAGE MODE)
	 JRST	OUTRAY		; THEN OKAY, NOT DUMP MODE EITHER.
;;=B4=
>;CMU
	CAIGE	TEMP,10		;MAKE SURE AT LEAST BINARY MODE
	 ERR	 <ARRYOUT: mode must be '14,'10, or '17, not >,6
	MOVE	0,[XCT IODOUT,SIMIO] ;IN CASE DUMP MODE
	CAIL	TEMP,15
	 JRST	 ARYDMP		;COMMON DUMP MODE ROUTINE

OUTRAY:	MOVE	A,-2(P)		;STARTING LOC
	SKIPGE	B,-1(P)		;EXTENT
	ERR	<ARRYOUT: negative word count, value is>,6

;;#FQ# DCS 2-6-72 (1-4) COUNT NO LONGER HELD EXCESSIVE

WOUT2:	SKIPG	E,OCOWNT(CDB)	;# WORDS LEFT IN BUFFER
	JRST	WOUT5		;BETTER GET ANOTHER BUFFER
	JUMPE	B,RESTR		;NOTHING LEFT TO DO
CMU <
;;=B4= 2 OF 13
	CAIN	Z,0		;IMP MODE?
	LSH	E,-2		;DIVIDE BY 4 TO GET WORD COUNT
;;=B4=
>;CMU
	IBP	OBP(CDB)	;MAKE SURE PTRS TO FIRST WORD
CMU <
;;=B4= 3 OF 13
	CAIN	Z,0		;IMP MODE?
	DPB	Z,[POINT 6,OBP(CDB),5]
;;=B4=
>;CMU
	MOVE	C,OBP(CDB)	;"TO" ADDR
	HRRZI	D,(C)		;FOR BLT TERMINATION CALCULATION
	HRLI	C,(A)		;"FROM" ADDR
	CAIGE	B,(E)		;ENUFF IN BUFFER?? (NOTICE THAT CAIGE
				;AS OPPOSED TO CAIG WILL FORCE AN OUTPUT
				;IF WE JUST FILL THE BUFFER)
	JRST	WOUT3		;YES
	ADDI	D,-1(E)		;FINAL ADDR
	BLT	C,(D)		;DO IT!
	ADDI	A,(E)		;UPDATE PTR
	SUBI	B,(E)		;AND COUNT
	SETZM	OCOWNT(CDB)
	HRRM	D,OBP(CDB)
WOUT5:	XCT	IOOUT,SIMIO	;DO THE OUTPUT
	JFCL			;ERRORS HANDLED ALREADY
	JRST	WOUT2		;TRY NEXT CHUNK

WOUT3:	JUMPLE	B,RESTR		;NOTHING TO MOVE
	SUBI	B,1
	ADD	D,B		;END OF BLOCK
	BLT	C,(D)		;MOVE IT
	SUBI	E,1(B)		;FIX LENGTH
CMU <
;;=B4= 4 OF 13
	CAIN	Z,0		;IMP MODE?
	 LSH	E,2		;MULTIPLY BY 4 FOR BYTE COUNT
;;=B4=
>;CMU
	MOVEM	E,OCOWNT(CDB)	;
	ADDM	B,OBP(CDB)	;FIX BYTE POINTER
;;#FQ# (1-4)
	JRST	RESTR		;LEAVE LIKE A TREE AND MAKE

DSCR WORDOUT(CHAN,VALUE);
CAL SAIL


HERE (WORDOUT)			;WRITE ONE WORD
	PUSHJ	P,SAVE
	MOVE	LPSA,X33
	MOVE	CHNL,-2(P)
	LOADI7	A,<WORDOUT>
	PUSHJ	P,GETCHN
;;%##% CONSIDER THIS
CMU <
	SETZM	@ENDFL(CDB)	;CLEAR ERROR FLAG
>;CMU
	LDB	A,[POINT 4,DMODE(CDB),35];DATA MODE
	CAIL	A,15		;A DUMP MODE?
	 JRST	 DMPWO		;WO IS ME, YES
;;#FQ# DCS 2-6-72 (2-4) WORD COUNT KEPT CORRECT, DUMP MODE OK
WDO:	SOSL	OCOWNT(CDB)	;BUFFER FULL?
	 JRST	 WOKO		;NO
	XCT	IOOUT,SIMIO	;YES, WRITE IT
	 JFCL			; ERRORS HANDLED ELSEWHERE
	JRST	WDO		;GO BACK AND DO IT RIGHT
WOKO:	MOVE	TEMP,-1(P)	;THING TO BE WRITTEN
	IDPB	TEMP,OBP(CDB)	;WRITE IT
	JRST	RESTR

DMPWO:	MOVE	LPSA,[XWD 7,7]	;ACCOUNT FOR EVERYTHING
	MOVEI	TEMP,-1(P)	;PNT TO WORD TO BE WRITTEN
	PUSH	P,-2(P)		;CHANNEL
	PUSH	P,TEMP		;ADDR OF WORD
	PUSH	P,[1]		;COUNT
	PUSHJ	P,ARO		;JOIN THE ROUTINE (RETAD JUST FOR STACK SYNCH)
;;#FQ# (2-4)




COMMENT \Arryin, Wordin \

DSCR ARRYIN(CHAN,@STARTING LOC,EXTENT);
CAL SAIL


HERE (ARRYIN)
	PUSHJ	P,SAVE
	MOVE	LPSA,X44
ARI:	MOVE	CHNL,-3(P)
	LOADI7	A,<ARRYIN>
	PUSHJ	P,GETCHN
	SETZM	@ENDFL(CDB)	;ASSUME NO END OF FILE
	LDB	TEMP,[POINT 4,DMODE(CDB),35] ;CHECK DUMP MODE
CMU <
;;=B4= 5 OF 13
	MOVEI	Z,1		;ASSUME NOT IMP MODE
	CAIN	TEMP,3		;IS THE MODE 3?
	 TRZA	Z,-1		; YES - CMU 32-BIT IMP MODE.
	CAIN	TEMP,4		;IF ONE OF THE SPECIAL CMU MODES,
	 JRST	INARY		; THEN OKAY, NOT DUMP MODE EITHER
;;=B4=
>;CMU
	CAIGE	TEMP,10
	 ERR	 <ARRYIN: mode must be '10 or '14 or '17, not >,6
	MOVE	0,[XCT IODIN,SIMIO] ;IN CASE DUMP MODE
	CAIL	TEMP,15
	 JRST	 ARYDMP		;USE COMMON ROUTINE

;;#FQ# DCS 2-6-72 (3-4) COUNT NO LONGER HELD EXCESSIVE
INARY:	MOVE	A,-2(P)		;STARTING LOC
	SKIPGE	B,-1(P)		;EXTENT
	ERR	<ARRYIN: negative word count, value is >,6
WIN3:	JUMPE	B,RESTR		;NOTHING LEFT TO DO
	SKIPG	E,ICOWNT(CDB)	;#LEFT IN BUFFER
	JRST	WIN5
CMU <
;;=B4= 6 OF 13
	CAIN	Z,0		;IMP MODE?
	 LSH	E,-2		;DIVIDE BY 4 TO GET WORD COUNT
;;=B4=
>;CMU
	IBP	IBP(CDB)	;MAKE SURE PTS TO NEXT
	HRL	C,IBP(CDB)	;ADDR OF FIRST WORD TO READ
	MOVEI	D,(A)		;FOR BLT TERMINATION
	HRR	C,A		;"TO" ADDRESS
	CAIG	B,(E)		;ENOUGH HERE?
	JRST	WIN4		;YES
	ADDI	D,-1(E)		;NO, FINISH THIS BUFFER
	BLT	C,(D)
	ADD	A,E		;FIX INPUT POINTER
	SUB	B,E		;FIX INPUT COUNT
WIN5:	XCT	IOIN,SIMIO	;DO INPUT
	JRST	WIN3		;OK, GO AHEAD
	JRST	WIEOF1		;EOF OR ERROR, LEAVE

WIN4:	ADDI	D,-1(B)		;FINISH UP
	BLT	C,(D)
	SUB	E,B		;FIX UP COUNT
CMU <
;;=B4= 7 OF 13
	CAIE	Z,0		;IMP MODE?
	 JRST	.+3
	LSH	E,2		;MULTIPLY BY 4 FOR BYTE COUNT
	DPB	Z,[POINT 6,IBP(CDB),5]
;;=B4=
>;CMU
	SUBI	B,1		;PREPARE TO CORRECT BP
	MOVEM	E,ICOWNT(CDB)	;UPDATE WORDS LEFT
	ADDM	B,IBP(CDB)	; POINTER
;;#FQ# (3-4)
	JRST	RESTR		;LEAVE

WIEOF1:	MOVE	TEMP,-1(P)	;#WORDS WANTED -1
	SUBM	TEMP,B		;#INPUT IN RH
WIN2:	HRRM	B,@ENDFL(CDB)	;#INPUT IN RH, ERR OR EOF BITS IN LH
	JRST	RESTR

DSCR VALUE_WORDIN(CHAN);
CAL SAIL


HERE (WORDIN)			;READ ONE WORD -- USE ARRYIN
	PUSHJ	P,SAVE
	MOVE	LPSA,X22
	LOADI7	A,<WORDIN>
	MOVE	CHNL,-1(P)	;CHANNEL NUMBER
	PUSHJ	P,GETCHN
;;#FQ# DCS 2-6-72 (4-4) WORD COUNT KEPT CORRECT, DUMP MODE OK
	LDB	TEMP,[POINT 4,DMODE(CDB),35];DATA MODE
	CAIL	TEMP,15		;DUMP MODE?
	 JRST	 DUMPWI		; YES
	SETZM	@ENDFL(CDB)
WI:	SOSL	ICOWNT(CDB)
	 JRST	 WOKI		;ALL OK
	XCT	IOIN,SIMIO
	 JRST	 WI		;OK, GO BACK TO KEEP COUNT RIGHT
	 TDZA	 A,A		;RETURN 0, WITH ERROR
WOKI:	ILDB	A,IBP(CDB)	;OK, RETURN NEXT WORD
	MOVEM	A,RACS+1(USER)	;RESULT
	JRST	RESTR

DUMPWI:	MOVE	LPSA,[XWD 6,6]
	MOVEI	TEMP,RACS+1(USER);RESULT GOES HERE
	PUSH	P,-1(P)		;CHANNEL
	PUSH	P,TEMP		;ADDRESS
	PUSH	P,[1]		;1 WORD TRANSFER
	PUSHJ	P,ARI		;WON'T RETURN, JUST SYNCH STACK
;;#FQ# (4-4)

ARYDMP:	
	MOVN	TEMP,-1(P)		;-WORD COUNT
	JUMPGE	TEMP,[ERR <DUMP MODE WORD COUNT NOT POSITIVE, VALUE IS >,6]
	SOS	D,-2(P)			;STARTING ADDR - 1
	HRL	D,TEMP			;IOWD -COUNT,STARTING ADDR -1
	MOVEI	D+1,0			;TERMINATE THE READ
	MOVE	A,[JRST RESTR] ;IF IT SUCCEEDS
	MOVE	B,[JRST RESTR] ;IF IT FAILS (EOF OR ERR, ALREADY HANDLED)
	JRST	0		;GO DO DUMP I/O

HERE(WRDSP1)
HERE(WRDSP2)
HERE(WRDSP3)

	ERR	<DRYROT WRD SPARES>

ENDCOM(WRD)
COMPIL(THR,<INOUT>,<SIMIO,SAVE,RESTR,GETCHN>
	,<THROUGH I/O ROUTINE>)


COMMENT \ INOUT \

DSCR INOUT(INCHAN,OUTCHAN,EXTENT);
CAL  SAIL


HERE (INOUT)
	PUSHJ	P,SAVE		;SAVE AC'S,GET GOGTAB
	MOVE	LPSA,[XWD 6,6]
	MOVE	CHNL,-2(P)	;OUTPUT CH NUMBER
	LOADI7	A,<INOUT (OUTPUT SIDE)>
	PUSHJ	P,GETCHN
	SETZM	@ENDFL(CDB)	;CLEAR ERROR INDICATOR
	LDB	TEMP,[POINT 4,DMODE(CDB),35] ;CHECK MODE
CMU <
;;=B4= 8 OF 13
	MOVEI	Z,1
	CAIN	TEMP,3		;IS THE MODE 3
	 TRZA	Z,-1		; YES!!!
	CAIN	TEMP,4		;OR CMU IMAGE MODE?
	 JRST	.+4		;UGLY, BE CAREFUL OF CODE CHANGES!
;;=B4=
>;CMU
	CAIL	TEMP,10		;MUST BE BINARY MODE
	CAILE	TEMP,14		;AND NOT DUMP MODE
	ERR	<INOUT (OUTPUT SIDE): ILLEGAL DATA MODE:>,6
	PUSH	P,CDB		;SAVE - 
	PUSH	P,CHNL		;WELL DO IT AGAIN
	MOVE	CHNL,-5(P)		;SEE...
	LOADI7	A,<INOUT (INPUT SIDE)>
	PUSHJ	P,GETCHN	;DO YOUR THING
	SETZM	@ENDFL(CDB)	;CLEAR ERROR INDICATOR
	LDB	TEMP,[POINT 4,DMODE(CDB),35]
CMU <
;;=B4= 9 OF 13
	MOVEI	Y,1
	CAIN	TEMP,3		;IS THE MODE 3
	 TRZA	Y,-1		;YES!!!
	CAIN	TEMP,4		;OR CMU IMAGE MODE
	 JRST	.+4		;CAREFUL OF RELATIVE JUMPS!
;;=B4=
>;CMU
	CAIL	TEMP,10
	CAILE	TEMP,14
	ERR	<INOUT (INPUT SIDE): ILLEGAL DATA MODE:>,6
	SKIPGE	B,-3(P)		;# OF WORDS
	HRLOI	B,377777	;ARBITRARILY LARGE NUMBER OF WDS
TH1:	JUMPE	B,RESTR		;NO MORE TO DO
	SKIPG	E,ICOWNT(CDB)	;#OF WORDS IN BUFFER
	JRST	TH5		;BETTER GET SOME MORE
CMU <
;;=B4= 10 OF 13
	CAIN	Y,0		;IMP MODE?
	 LSH	E,-2		;DIVIDE BY 4 TO GET WORD COUNT
;;=B4=
>;CMU
	IBP	IBP(CDB)	;MAKE SURE POINT TRIGHT
	HRL	C,IBP(CDB)	;INPUT POINTER
	EXCH	CHNL,(P)	;NOW FREEN OUTPUT STUFF
	EXCH	CDB,-1(P)
	SKIPG	OCOWNT(CDB)	;SOME LEFT
	XCT	IOOUT,SIMIO
	SKIPA
	JRST	THERR
	IBP	OBP(CDB)
	HRR	C,OBP(CDB)	;OUTPUT POINTER
	CAML	E,B		;FIND # OF WORDS
	MOVE	E,B		;TO BLIT
NOCMU <
;;=B4= 11 OF 13
	CAML	E,OCOWNT(CDB)	;=MIN(B,ICOWNT,OCOWNT)
	MOVE	E,OCOWNT(CDB)
>;NOCMU
CMU <
	CAMGE	E,OCOWNT(CDB)	;=MIN(B,ICOWNT,OCOWNT)
	JRST	.+4
	MOVE	E,OCOWNT(CDB)
	CAIN	Z,0		;IMP MODE?
	LSH	E,-2		;DIVIDE BYTE COUNT BY 4
;;=B4=
>;CMU
	MOVEI	D,(C)		;MAKE BLT TERMINATOR
	ADDI	D,-1(E)		;FINAL ADDRESS
	BLT	C,(D)		;CHOMP CHOMP
	SUB	B,E		;WE'VE DONE THESE
	MOVEI	A,-1(E)		;TO UPDATE BYTE POINTER
	ADDM	A,OBP(CDB)	;TOLD YOU SO
CMU <
;;=B4= 12 OF 13
	CAIE	Z,0		;IMP MODE?
	 JRST	.+3
	LSH	E,2		;MULTIPLY BY 4 FOR BYTE COUNT
	DPB	Z,[POINT 6,OBP(CDB),5]
;;=B4=
>;CMU
	SUBM	E,OCOWNT(CDB)	;UPDATE WORD COUNT
	MOVNS	OCOWNT(CDB)	;CLEVER,EH?
TH6:	EXCH	CHNL,(P)	;BACK TO INPUT SETUP
	EXCH	CDB,-1(P)
	ADDM	A,IBP(CDB)	;UPDATE INPUT PTR
CMU <
;;=B4= 13 OF 13
	CAIE	Y,0		;IMP MODE?
	 JRST	.+3
	LSH	E,2		;MULTIPLY BY 4 FOR BYTE COUNT
	DPB	Y,[POINT 6,IBP(CDB),5]
;;=B4=
>;CMU
	SUBM	E,ICOWNT(CDB)	;UPDATE WORD COUNT
	MOVNS	ICOWNT(CDB)	;SUBTRACTION WAS BACKWARDS
	JRST	TH1		;MORE OF SAME
TH5:	XCT	IOIN,SIMIO	;DO SOME INPUT
	JRST	TH1		;NOW GO PLAY
THERR:	SKIPGE	TEMP,-3(P)	;# THE GUY WANTED
	HRLOI	TEMP,377777	;IT WAS A FUDGE
	SUB	TEMP,B		;SUBTRACT #LEFT TO GET
	HRRM	TEMP,@ENDFL(CDB);#HE GOT
	JRST	RESTR

ENDCOM(THR)
COMPIL(LIN,<LINOUT>,<SIMIO,SAVE,RESTR,GETCHN,X33>,<LINOUT ROUTINE>)




COMMENT \Linout \

DSCR LINOUT(CHANNEL,VALUE);
CAL SAIL


HERE (LINOUT)
	PUSHJ	P,SAVE
	MOVE	CHNL,-2(P)	;CHANNEL
	LOADI7	A,<LINOUT>
	PUSHJ	P,GETCHN	;CHANNEL DATA
	MOVE	TEMP,OBP(CDB)	;ADJUST TO FULL WORD
	HRRZ	A,OCOWNT(CDB)	;DON'T FORGET COUNT
LINOLP:	TLNN	TEMP,760000	;LINED UP?
	 JRST	 OKLIGN		; YES
	IBP	TEMP		;0 WILL BE THERE
	SOJA	A,LINOLP

OKLIGN:	MOVEM	TEMP,OBP(CDB)
	MOVEM	A,OCOWNT(CDB)	;REPLACE UPDATED THINGS
	CAIGE	A,=10		;ENOUGH ROOM FOR 2 WORDS?
	 XCT	 IOOUT,SIMIO	;NO, OUTPUT
	 JFCL			;IN CASE OUTPUT HAPPENED

	SKIPGE	B,-1(P)		;GET LINE NUMBER
	 JRST	 [MOVNS B
		  MOVNI A,5	;ONLY PUT OUT 5 CHARS
		  JRST NOCONV]	;WAS GIVEN TO US IN TOTO
	MOVNI	A,6		;PUT OUT TAB AFTER
	MOVE	C,[<ASCII /00000/>/2] ;TO MAKE 5
	EXCH	B,C
	PUSH	P,LNBAK		;RETURN ADDR
LNCONV:	IDIVI	C,=10
	IORI	D,"0"
	DPB	D,[POINT 7,(P),6]
	SKIPE	C		;THE RECURSIVE PRINTER
	PUSHJ	P,LNCONV
	HLL	C,(P)		;ONE CHAR, LEFT JUST
	LSHC	B,7
LNBAK:	POPJ	P,.+1
	LSH	B,1
	TRO	B,1
NOCONV:	AOS	C,OBP(CDB)	;MOVE OUT A WORD
	MOVEM	B,(C)
	ADDM	A,OCOWNT(CDB)	;UPDATE COUNT
	MOVEI	B,11
	CAME	A,[-5]
	 IDPB	 B,OBP(CDB)	;OUTPUT A TAB
NOTAB:	MOVE	LPSA,X33
	JRST	RESTR		;THAT'S IT

ENDCOM(LIN)





COMMENT \Breakset,setbreak,stdbrk fakes\

;;%  % MOVED IT TO STRSER

COMPIL(CLS,<CLOSIN,CLOSO,CLOSE>,<SAVE,RESTR,SIMIO,X33>,<CLOSE ROUTINES>)




COMMENT \Close, Closin, Closo
  CLOSE(CHAN)     

CLOSIN closes only the input side
CLOSO closes only the output side

\
DSCR CLOSIN(CHAN)
CAL SAIL


HERE (CLOSIN) PUSHJ	P,SAVE		;CLOSE INPUT ONLY
	MOVEI	D,1
	JRST	CLSS

DSCR CLOSO(CHANNEL);
CAL SAIL

HERE (CLOSO)	
	PUSHJ	P,SAVE		;CLOSE OUTPUT ONLY
	MOVEI	D,2
	JRST	CLSS
DSCR CLOSE(CHANNEL);
CAL SAIL

.CLS:
HERE (CLOSE)				;CLOSE BOTH
	PUSHJ	P,SAVE		;SAVE ACS AND THINGS
CLSS:	
;;%BQ% RHT 10-11-74 ALLOW CLOSE TO TAKE INHIBIT BITS AS AN ARGUMENT
;; FOLLOWING WAS MOVE LPSA,X22
	MOVE	LPSA,X33
;; FOLOWING WAS CHNL,-1(P)
	MOVE	CHNL,-2(P)	;CHANNEL #
	HRRZ	D,-1(P)		;CHANNEL CLOSE INHIBIT BITS
;;%BQ% ^
	CHKCHN	CHNL,<CLOSE>	;VERIFY OK CHANNEL
	SKIPN	CDB,@CDBLOC(USER) ;GET CDB
	 JRST	 RESTR		;NOT OPEN, DON'T CLOSE
	XCT	IOCLOSE,SIMIO	;CLOSE CHAN,SPEC
	SETZM	INAME(CDB)
	SETZM	ONAME(CDB)	;NO FILE NAMES OPEN
	JRST	RESTR		;RETURN

ENDCOM(CLS)
COMPIL(MTP,<MTAPE,USETI,USETO,RENAME,ERENAME>
	  ,<SAVE,RESTR,GETCHN,SIMIO,FILNAM,X22,X33,X44>
	  ,<MTAPE, USETI, USETO, RENAME ROUTINES>)
COMMENT \Mtape \

DSCR MTAPE(CHANNEL,MODE);
CAL SAIL


.MTP:
HERE (MTAPE)
	PUSHJ	P,SAVE
	MOVE	LPSA,X33
	MOVE	CHNL,-2(P)		;CHANNEL NUMBER
	LOADI7	A,<MTAPE>
	PUSHJ	P,GETCHN
	LDB	C,[POINT 5,-1(P),35]	;PART OF COMMAND CHAR
NOSTAN <
	MOVEI	B,101
	CAIN	C,11			;MTAPE "I" DOES SPECIAL THINGS.
	 JRST	 MTAPQ			;GO SET IBM COMPABILITY MODE
>;NOSTAN
;;%##%	ALLOW MTAPE(NULL) TO DO A MTAPE 0 -- WAIT
	MOVEI	B,0
	JUMPE	C,MTAPQ			;THIS IS DEFINITELY NOT A NO-OP
	MOVE	A,OPTAB			;COMMAND BITS
	MOVE	B,OPTAB+1		;MORE
	TRZE	C,30			;COMPRESS TABLE
	ADDI	C,5
	LSH	C,2			;EACH COMMAND IS 4 BITS
	ROTC	A,(C)			;GET RIGHT COMMAND
	ANDI	B,17			;DO IF SYSTEM DOESN'T
	JUMPE	B,[ERR	<MTAPE: ILLEGAL CODE>,1
		JRST	RESTR]
MTAPQ:	HRLI	B,(<MTAPE>)		;CREATE MTAPE OPERATION
	DPB	CHNL,[POINT 4,B,12]
;%##%	TRNE	B,-1			;IS THERE AN OPERATION?
	XCT	B			;YES, DO IT
	JRST	RESTR

OPTAB:	BYTE (4) 16,17,0,0,3,6,7,13,10	;A,B,,,E,F,R,S,T
	BYTE (4) 11,0,1			;U,,W




COMMENT \ Useti, Useto, Rename \

DSCR USETI,USETO(CHANNEL,BLOCK #);
CAL SAIL

;;SDD 20-OCT-79 (=I19=) and (=I21=) [plus some] Fixes for DEC buffers
;;	changes here to "RENAME"
nodec < ;DEC style USETI/USETO made to work nicer (Cleaner at least)
HERE (USETI)
^^.USETI:
	SKIPA	LPSA,[XCT IOSETI,SIMIO]	;USETI
HERE (USETO)
^^.USETO:
	MOVE	LPSA,[XCT IOSETO,SIMIO] ;USETO
	PUSHJ	P,SAVE
	MOVE	CHNL,-2(P)
	LOADI7	A,<USET>
	PUSHJ	P,GETCHN
	MOVE	A,-1(P)			;VALUE TO USETO
	MOVE	LPSA+1,[JRST .+2]	;BE ABLE TO GET BACK
	JRST	LPSA			;GO TO USETI/O
	MOVE	LPSA,X33
	JRST	RESTR
>;nodec 
dec < ;DEC style USETI/USETO made to work nicer (Cleaner at least)
	;problem was you were left at an undetermined spot when you
	;a USETI, fixed by NIH/UOR(?) =I19= and =I21=
here(useti)
^^.useti:
	pushj	p,save		;save user registers
	loadi7	a,<USETI>	;for error report
	pushj	p,uset		;set up for USETI and force OBUFs out
				;[ie make sure data is there]
	xct	ioseti,simio	;or its simulation.
printx get Ernie to check some of this code, esp WAIT/USETI order
;;and while you are at it, USETI -1 is funny...
	soje	a,setirt	; USETI -1 is for OUTPUT, would set eof
	ldb	b,[point 4,dmode(cdb),35] ;get files data mode
	cail	b,15		;since DUMP mode IO needn't WAIT
	 jrst	setirt		; then skip it.
notymshr <
	move	b,[wait]	;but if buffered, need to flush current
	dpb	chnl,[point 4,b,12] ;set of buffers.  Construct WAIT ch,
	xct	b		;and WAIT for I/O to stop
>;notymshr
tymshr <
	hrli	chnl,25		;=.CHWT we WAIT with a different I/O uuo
	chanio	chnl,		;(this allows extended channel numbers)
>;tymshr
	skipn	d,ibpnt(cdb)	;set to clear buffer ring in use bits
	 jrst	1+[cai	chnl,	;but if no buffer ring, complain loudly
				;CAI is to supply proper channel number
		 err <USETI: no buffer assigned for I-O chan >,7
		 jrst	setirt]
	hrlzi	a,400000	;clear "buffer in use" bits
nxtbuf:	andcam	a,(d)		;clear bit for one buffer
	hrr	d,(d)		;advance buffer (note LH constant)
	came	d,ibpnt(cdb)	;but stop once we have come full circle
	 jrst	nxtbuf		; loop until done
printx why do an IN here, isn't a SETZM charcount OK?
;NB: d now has the address of a valid buffer(=ibpt even), lets do the IN
	move	lpsa,x33	;get this set for success exit
notymshr <
	hrli	d,(<in>)	;this must address a valid buffer, 
				;since we are "switching buffer rings"
	dpb	chnl,[point 4,d,12];put in the channel number
	xct	d
>;notymshr
tymshr <
	hrli	chnl,14		;=.CHIN set up for the IN
	chanio	chnl,(d)	;and do it [see address rationale above]
>;tymshr
	 jrst	restr		;success, we can leave
	xct	ioerrproc,simio	;bad return, let simio handle it
	 jfcl			;skips, oddly enough
setirt:	move	lpsa,x33	;restore and
	jrst	restr		;get back to the user

here(useto)
^^.useto:
	pushj	p,save		;save user registers
	loadi7	a,<USETO>	;for error report
	pushj	p,uset		;prepare for the operation
	xct	ioseto,simio	;and call simio to get it done
	move	lpsa,x33	;restore and
	jrst	restr		;get back to the user

uset:	move	chnl,-3(p)	;get channel number (stack is at +1)
	pushj	p,getchn	;validate its use
	ldb	b,[point 4,dmode(cdb),35] ;force out any pending output
	skipe	obp(cdb)	;no output pending if no buffers
	 cail	b,15		;or unbuffered mode IO
	  jrst	x.uset		;so no need to flush
	hrrz	b,obp(cdb)	;RH of buffer ptr
	hrrz	a,obpnt(cdb)	;loc. of buffer
	cain	b,1(a)		;if byte pointer unmoved
	 jrst	x.uset		; then no output (so we don't flush)
	xct	ioout,simio	;otherwise, dump buffer before moving 
	 jfcl			;  SIMIO can handle the errors
x.uset:	move	a,-2(p)		;get block number desired
	popj	p,		;and go back to USETI or USETO code
>;dec
;; ^^ SDD 20-OCT-79 (=I19=) and (=I21=) ^^

DSCR RENAME(CHANNEL,"NEW NAME",PROTECTION,@FAILURE FLAG);
     ERENAME(CHANNEL,"NEW NAME",PROT,DATE(0),TIME(0),MODE(0),@FLG);
CAL SAIL


HERE (RENAME)
^^.RENAME:
	PUSHJ	P,SAVE
	SETZM	@-1(P)
	MOVE	LPSA,X44
	LOADI7	A,<RENAME>
	MOVE	CHNL,-3(P)
	PUSHJ	P,GETCHN
	PUSHJ	P,FILNAM	;PARSE FILENAME SPEC
	 JRST	 BDSPC		;SPECIFICATION NO GOOD
	MOVE	TEMP,-2(P)
	TDZE	TEMP,[XWD 777777,777000] ;MAKE THIS RENAME STERILE
	ERR	<ATTEMPT TO SET MODE OR DATE VIA RENAME.
USE ERENAME INSTEAD>,1
	ROT	TEMP,-=9
.RENIT:	MOVEM	TEMP,FNAME+2(USER)
	XCT	IORENAME,SIMIO	;DO THE RENAME
	 JRST	 RNERR		;NO GOOD
	JRST	RESTR
BDSPC:	HRRZ	TEMP,ERRTST(CDB)	;SEE IF
	TRNE	TEMP,10000		;WILLING TO HANDLE ERROR
	ERR	<RENAME: INVALID FILE SPECIFICATION>,1 ;NO, TELL HIM
	SKIPA	TEMP,[=8]		;ALWAYS REPORT CODE
RNERR:	HRRZ	TEMP,FNAME+1(USER)	;RETURN HORSESHIT NUMBER
	HRROM	TEMP,@-1(P)		;TO THE USER
	JRST	RESTR
;;%BY%

;SDD- 04-FEB-80: lets recycle those spares  (why take both inputs)
;;was: HEREFK(ERENAME,ERENA.)
HERE(ERENAME)
	PUSHJ	P,SAVE
	SETZM	@-1(P)
	MOVE	LPSA,[XWD 7,7];
	LOADI7	A,<ERENAME>		;
	MOVE	CHNL,-6(P);
	PUSHJ	P,GETCHN
	PUSHJ	P,FILNAM		;PARSE ID SPEC;
	JRST	BDSPC			;LOST
	SKIPN	TEMP,-4(P)		;DATE
	JRST	EREN.1			;NO DATE
	LDB	C,[POINT 3,TEMP,=23]	;PICK UP HIGH ORDER BITS
	DPB	C,[POINT 3,FNAME+1(USER),=20] ;PUT THEM AWAY
EREN.1:	MOVE	C,-5(P)			;PROT
	DPB	C,[POINT =9,TEMP,=8]	;PUT AWAY
	MOVE	C,-2(P)			;MODE
	DPB	C,[POINT 4,TEMP,=12]	;PUT AWAY
	MOVE	C,-3(P)			;TIME
	DPB	C,[POINT =11,TEMP,=23]	;PUT AWAY
	JRST	.RENIT
;;%BY% ^

ENDCOM(MTP)




COMMENT \where Usercon used to be\






COMMENT \Ttyuuo functions \

DSCR TTYUUO FUNCTIONS
CAL SAIL


Comment \
INTEGER PROCEDURE INCHRW;
 RETURN A CHAR FROM TTCALL 0,

INTEGER PROCEDURE INCHRS;
 RETURN -1 IF NO CHAR WAITING, ELSE FIRST CHAR (TTCALL 2,)

STRING PROCEDURE INCHWL;
 WAIT FOR A LINE, THEN RETURN IT (TTCALL 4, FOLLOWED BY TTCALL 0'S)

STRING PROCEDURE INCHSL(REFERENCE INTEGER FLAG);
 FLAG_-1, STR_NULL IF NO LINE, ELSE FLAG_0, 
	STR_LINE (TTCALL 5, FOLLOWED BY TTCALL 0'S)

STRING PROCEDURE INSTR(INTEGER BRCHAR);
 RETURN ALL CHARS TO AND NOT INCLUDING BRCHAR (TTCALL 0'S)

STRING PROCEDURE INSTRL(INTEGER BRCHAR);
 WAIT FOR ONE LINE, THEN DO INSTR (TTCALL 4, FOLLOWED BY INSTR)

STRING PROCEDURE INSTRS(REFERENCE INTEGER FLAG; INTEGER BRCHAR);
 FLAG_-1, STR_NULL IF NO LINES, ELSE FLAG_0, 
  STR_INSTR(BRCHAR)


PROCEDURE OUTCHR(INTEGER CHAR);
 OUTPUT CHAR (TTCALL 1)

PROCEDURE OUTSTR(STRING STR);
 OUTPUT STR (TTCALL 3)


PROCEDURE CLRBUF;
 CLEARS INPUT BUFFER (TTCALL 11,)

TTYIN, TTYINS, TTYINL (TABLE, @BRCHAR);
 TTYIN WORKS WITH TTCALL 0'S; TTYINS DOES A SKIP
 ON LINE FIRST, RETURNING NULL AND -1 IN BREAK IF NO LINES
 TTYINL DOES A WAIT FOR LINE FIRST.
 FULL BREAKSET CAPABILITIES EXCEPT FOR 
 "R" MODE (AND OF COURSE, LINE NUM. STUFF)

	TITLE	TTYUUO
\

;;%##% ADD TTYUP TO ALL THIS
COMPIL(TTY,,,,,,DUMMYFORSCISS)
DEFINE IENT1 <INCHRW,INCHRS,INCHWL,INCHSL,INSTR,OUTCHR,OUTSTR,TTYUP>
DEFINE IENT2
<INSTRL,INSTRS,CLRBUF,TTYIN,TTYINS>
DEFINE IEXT1
<SAVE,RESTR,X11,X22,X33,INSET,CAT,STRNGC,GOGTAB,BRKMSK,BKTCHK,.SKIP.>
TYMSHR <DEFINE IEXT2 <DDFINA,INTRPT,.SONTP,SAVETY>
	DEFINE IENT3 <BACKUP,IONEOU,TTYINL>> ;TYMSHR
NOTYMSHR < 
DEFINE IEXT2 <.SONTP>
NOTENX <DEFINE IENT3 <NOSTANFO<BACKUP,>TTYINL>> ;NOTENX
TENX <DEFINE IENT3 <TTYINL> > ;TENX 
>;NOTYMSHR

COMPXX (TTY,<IENT1,IENT2,IENT3>,<IEXT1,IEXT2>,<TELETYPE FUNCTIONS>)
;;#GF# DCS 2-1-72 (1-3) INCHWL BREAKS ON ALL ACTIVATION, TELLS WHICH IN .SKIP.
; .SKIP. EXTERNAL ABOVE
;;#GF#

NOSTAN <
IFE ALWAYS,<
EXTERN OTSTRBF
>;IFE ALWAYS
>;NOSTAN

;;%##% FOR TTYUP THING
DEFINE KONVERT(AC) <
	SKIPN	TTYCVT(USER)
	JRST	.+5
	CAIL	AC,"a"
	CAILE	AC,"z"
	JRST	.+2
	TRZ	AC,40	;FORCE TO BE LOWER CASE
>
TYMSHR <
;SDD- 04-FEB-80: lets recycle those spares  (why take both inputs)
;;was: HEREFK(IONEOU,IONOU.)
HERE(IONEOU)
	SKIPE	INTRPT	; sdd: tymshare pre-io schedule check
	 XCT	DDFINA
	TTYUUO 15,-1(P)
	SUB P,X22
	JRST @2(P)
>;TYMSHR

HERE (INCHRW)
TYMSHR < SKIPE INTRPT
	XCT DDFINA>;TYMSHR
	TTCALL	A
;;%##%
	MOVE	USER,GOGTAB
	KONVERT	(A)
	POPJ	P,

HERE (INCHRS)	TTCALL	2,A		;SKIP IF CHAR WAITING
	MOVNI	A,1		;ELSE RETURN -1
;;%##%
	MOVE	USER,GOGTAB
	KONVERT(A)
	POPJ	P,

HERE (OUTCHR)
TYMSHR <
	SKIPE	INTRPT	;sdd: more sched checks
	 XCT	DDFINA 
>;TYMSHR
	TTYUUO	1,-1(P)		;OUTPUT THE PARAMETER
	SUB	P,X22		;REMOVE PARAMETER
	JRST	@2(P)

HERE (OUTSTR)
;;#FO# 11-18-71 DCS (1-2)
NOSTAN <
NOTYMSHR <
;;#FO#
;;#HC# 5-11-72 DCS MAKE OUTSTR BETTER IN EXPO VERSION (DUE TO LDE)
;;#MM# 5-25-73 ! MAKE SURE ITS LOADED BEFORE WE USE IT
	MOVE 	USER,GOGTAB
	EXCH	A,-1(SP)		;LENGTH OF STRING
	HRRZS	A			; REALLY
	EXCH	B,(SP)			;PTR TO THE STRING
	PUSH	P,C			;NEED ANOTHER AC
	JUMPLE	A,OU.OUT		;DON'T DO ANYTHING
OSLOOP:	MOVE	C,A
	SUBI	A,14*5-1		;# CHARS/CHOMP
	SKIPLE	A			;LOTS LEFT??
	MOVEI	C,14*5-1		; YES,
;;%##% BETTER PLACE THAN SGACS
	MOVE	LPSA,[POINT 7,OTSTRBF];AS GOOD A PLACE AS ANY
	ILDB	TEMP,B
	SKIPE	TEMP			;NULL??
	IDPB	TEMP,LPSA		; NO
	SOJG	C,.-3
	MOVEI	TEMP,0			;A NULL FOR THE END
	IDPB	TEMP,LPSA
	TTCALL	3,OTSTRBF		;RAISON D'ETRE
	JUMPG	A,OSLOOP
OU.OUT:	POP	SP,B
	POP	SP,A
	POP	P,C
;;#HC#
;;#FO# 11-18-71 DCS (2-2) MAKE OUTSTR WORK EFFICIENTLY USING TTYMES (STANFO ONLY)
>;NOTYMSHR
>;NOSTAN
TYMSHR <
ifndef .axopc,<.axopc__67>
	hrrzs	-1(sp)		;isolate count
	hrroi	temp,.axopc	;the nifty new system call
	auxcal	temp,-1(sp)	;and spit out the poor string
	sub	sp,x22
>;TYMSHR
STANFO <
;SDD 27-MAY-80 -- DON@SU-AI complains that big strings dont go out right
woutmx__=4095/5
rego:	HRRZ	TEMP,-1(SP)	;get length
	jumpe	temp,quit	;IF NULL STRING, QUIT
	caile	temp,woutmx*5	;too big to output in one shot?
	 jrst	[movei	temp,woutmx*5	;too big, put out in easy pieces
		 push	sp,temp
		 push	sp,-1(sp)
		 pushj	p,.+1
		 movni	temp,woutmx*5
		 addm	temp,-1(sp)	;shorten count
		 movei	temp,woutmx	;fast ADJBP (5 char/word)
		 addm	temp,(sp)
		 jrst	rego]		;and keep working on it
	dpb	temp,[point 12,(sp),17]	;clear size field, put in length
	MOVSI	TEMP,'TTY'		;DEVICE FOR TTYMES
	MOVEM	TEMP,-1(SP)
	MOVEI	TEMP,-1(SP)		;POINT AT SPEC
	CALLI	TEMP,400047		;WRITE FIRST CHAR FOR LENGTH CHARS
;THIS IS THE SPECIAL TTYMES UUO AS PROVIDED BY HELLIWELL
	 JFCL				;IT HAS BEEN KNOW TO SKIP-RETURN
QUIT:	SUB	SP,X22			;REMOVE THE ARGUMENT
>;STANFO
;;#FO#
	POPJ	P,			;DONE

TTWCHR__=100	;MAX NUMBER OF CHARS ON TTY INPUT
CMU <		;EXCEPT WE HAVE LARGER INPUT BUFFERS
TTWCHR__=140
>;CMU
REDSTR: TYMSHR <
	SKIPE INTRPT
	XCT DDFINA
	XCT @(P)
	PUSHJ P,SAVETY
	AOS -1(P)	;SKIP EXECUTED INSTRUCTION
> ; TYMSHR
	SKIPE	SGLIGN(USER)
	PUSHJ	P,INSET
	MOVEI	A,TTWCHR
	ADDM	A,REMCHR(USER)
	SKIPLE	REMCHR(USER)
	PUSHJ	P,STRNGC
	MOVNI	A,TTWCHR
	PUSH	SP,[0]		;NULL STRING IF NOTHING DONE
	PUSH	SP,TOPBYTE(USER)
TYMSHR <POP P,TEMP>;TYMSHR
	POPJ	P,

FINSTR:	CAIN	TEMP,15	;REMOVE LFD IF CR BROKE IT
	TTCALL	TEMP
FINS1:	ADDM	A,REMCHR(USER)	;NUMBER NOT USED
	ADDI	A,TTWCHR		;NUMBER USED
;;#GI# DCS 2-5-72 REMOVE TOPSTR
;;%##% ALLOW FOR ITERATIVE GETTING OF TTWCHR CHARS
	HRROS  -1(SP)		; TO STRING COUNT WORD
	ADDM	A,-1(SP)	;UPDATE COUNT WORD
;;#GI#
	JRST	RESTR

HERE (INSTR)
NOTYMSHR <	PUSHJ	P,SAVE>;NOTYMSHR
	PUSHJ	P,REDSTR
TYMSHR <JFCL>;TYMSHR
	MOVE	B,-1(P)		;BREAK CHAR
	MOVE	LPSA,X22	;# TO REMOVE

INS1:	PUUO	0,TEMP		;NEXT CHAR
;;%##%
	KONVERT	(TEMP)		;**** CONVERT BEFORE TEST BREAKEDNESS *****
INS2:	CAMN	TEMP,B		;BREAK?
	 JRST	 FINSTR		; YES, ALL DONE
	IDPB	TEMP,TOPBYTE(USER) ;PUT IT AWAY AND
;;%  %  LDE  BETTER NOT READ IN TOO MANY CHARACTERS
	AOJL	A,INS1		; IF ROOM, GO BACK FOR MORE
	PUSHJ	P,CHRMOR	;MAKE ROOM, THEN GO BACK
	JRST	INS1		;

HERE (INCHWL)
NOTYMSHR <	PUSHJ	P,SAVE>;NOTYMSHR
	PUSHJ	P,REDSTR
TYMSHR <	TTCALL 4,TEMP>;TYMSHR
	MOVE	LPSA,X11
NOTYMSHR<	TTCALL	4,TEMP>;NOTYMSHR
;;#GF# DCS 2-1-72 (2-3) DO LOOP HERE, DON'T USE INS1 LIKE BEFORE
NOTYMSHR <
INS3:	CAIE	TEMP,12
NOCMU <	;WE WILL JUST BREAK ON CR OR LF, THANK YOU
	CAIN	TEMP, STANFO< 175 ;>33	;stanford alt is esc elsewhere
	 JRST	 DNSTR
	CAIE	TEMP,15		;CR?
	TRNE	TEMP,600	;CONTROL BITS ON?
>;NOCMU
CMU <	CAIE	TEMP,15		;CR?
	CAIN	TEMP,12		; OR LF?
>;CMU
	 JRST	 DNSTR		;YES
>;NOTYMSHR
TYMSHR <
INS3:	CAIE TEMP,11
	CAIL TEMP,40
	SKIPA
	JRST DNSTR
>;TYMSHR
;;%##%
	KONVERT(TEMP)
	IDPB	TEMP,TOPBYTE(USER) ;PUT IT AWAY
;;=I08=
	TTCALL	4,TEMP		;GET ANOTHER AND
;;%##%  RHT -- MADE A BIT BETTER (ALLOW FOR GETTING MORE ROOM)
	AOJL	A,INS3		;GO HANDLE IT (IF STILL HAVE ROOM)
	PUSHJ	P,CHRMOR	;GET ROOM FOR MORE CHARS
	JRST	INS3		;GO HANDLE

DNSTR:	MOVEM	TEMP,.SKIP.	;SET BREAK CHAR
	JRST	FINSTR
;;#GF#

HERE (INCHSL)
NOTYMSHR <
	PUSHJ	P,SAVE
	MOVE	LPSA,X22	;PARAM (FLAG) AND RETURN
>;NOTYMSHR
	PUSHJ	P,REDSTR
TYMSHR <
	JFCL
	MOVE	LPSA,X22	;PARAM (FLAG) AND RETURN
>;TYMSHR
	SETOM	@-1(P)		;ASSUME FAILED
	TTCALL	5,TEMP		;ARE THERE CHARS?
	JRST	FINSTR		;NO
	SETZM	@-1(P)		;YES, GET THEM
;;#GF# DCS 2-1-72 (3-3)
	JRST	INS3		;USE INCHWL'S LOOP, NOT INSTR'S
;;#GF#

HERE (INSTRL)
NOTYMSHR <
	PUSHJ	P,SAVE
	MOVE	LPSA,X22
>;NOTYMSHR
	PUSHJ	P,REDSTR
	TTCALL 4,TEMP
TYMSHR <
	MOVE	LPSA,X22
>;TYMSHR
	MOVE	B,-1(P)
	JRST	INS2

HERE (INSTRS)
	PUSHJ	P,SAVE
	MOVE	LPSA,X33
	PUSHJ	P,REDSTR
	SETOM	@-2(P)
	TTCALL	5,TEMP
	JRST	FINSTR
	SETZM	@-2(P)
	MOVE	B,-1(P)
	JRST	INS2

HERE (CLRBUF)
	TTCALL	11,
	POPJ	P,

HERE (TTYINS)
NOTYMSHR <
	PUSHJ	P,SAVE
>;NOTYMSHR
	PUSHJ	P,REDSTR	;PREPARE TO MAKE A STRING
TYMSHR <
	JFCL
>;TYMSHR
	MOVE	LPSA,X33
	SETOM	@-1(P)		;ASSUME NO CHARS
	TTCALL	5,D		;SEE IF LINES WAITING
	 JRST	FINS1		;NONE WAINTING
;;%##% WILL DO INCHRW UUO IN LOOP
	MOVE	B,[TTCALL D]
	JRST	TYIN1		;GO AHEAD

HERE (TTYINL)
NOTYMSHR <
	PUSHJ	P,SAVE
	TTCALL	4,D		;WAIT FOR A LINE
	MOVE	B,[ TTCALL 4,D]
	JRST	TYIN

HERE (TTYIN)
	PUSHJ	P,SAVE
	TTCALL	D		;GET A CHAR
	MOVE	B,[TTCALL D]	;FOR LOOP

TYIN:	PUSHJ	P,REDSTR	;PREPARE STACK,A,STRNGC FOR A STRING
>;NOTYMSHR
TYMSHR<
	PUSHJ P,REDSTR
	TTCALL 4,TEMP
	MOVE B,.-1
	JRST TYIN
HERE (TTYIN)
	PUSHJ P,REDSTR
	TTCALL TEMP
	MOVE B,.-1

TYIN:	HRRI B,D
	MOVE D,TEMP
>;TYMSHR
	MOVE	LPSA,X33	;PREPARE TO RETURN
TYIN1:	SETZM	@-1(P)		;ASSUME NO BREAK CHAR
;;#TM# ! WAS -1(P)
	MOVE	X,-2(P)		;TABLE #
	MOVEI	TEMP,-1		;BLOCK MUST BE THERE AND TABLE MUST BE INIT'ED
	PUSHJ	P,BKTCHK	;CHECK TABLE #
	 JRST	FINS1		;ERROR OF SOME SORT
	MOVE	FF,BRKMSK(CHNL)	;GET MASK FOR THIS TABLE
	ADD	CHNL,CDB	;RELOCATE RANGE 1 TO 18
	MOVEI	Z,1		;FOR TESTING LINE NUMBERS
	SKIPN	LINTBL(CHNL)	;DON'T LET TEST SUCCEED IF
	 MOVEI	 Z,0		;WE'RE TO LET LINE NUMBERS THRU
;;%##% BREAK TABLE CONVERSION
	TRNE	FF,@BRKCVT(CDB)	 ;SPECIFY UC COERCION
	TLOA	C,400000	;YES
	TLZ	C,400000	;NO
;;%##%
	MOVE	Y,CDB
	ADD	Y,[XWD D,BRKTBL] ;BRKTBL+RLC(CDB)
	JRST	TTYN1
;;%##%
TTYN:	XCT	B		;1 CHAR
TTYN1:
;;%##%
	JUMPGE	C,TT.NUC	;COERCE BECAUSE OF BRK TBL ?
	CAIL	D,"a"		;ONLY IF LC
	CAILE	D,"z"
	JRST	TT.TSB		;GO TEST BREAK
	TRZ	D,40		;MAKE UC
	JRST	TT.TSB
TT.NUC:	KONVERT(D)		;MAY TURN TO UC BECAUSE OF TTY
TT.TSB:
;;%##%
	TDNE	FF,@Y		;BREAK OR OMIT?
	JRST	TTYSPC		; YES, FIND OUT WHICH
TTYC:	IDPB	D,TOPBYTE(USER)	;PUT IT AWAY
;;%##% BE SURE DONT EAT MORE AT A TIME THAN CAN BLOAT
	AOJL	A,TTYN		;COUNT AND CONTINUE
TTNMOR:	PUSHJ	P,CHRMOR	;ALLOW FOR MORE CHARS
	JRST	TTYN		;GO GO GO

TTYSPC:	HLLZ	TEMP,@Y		;WHICH?
	TDNN	TEMP,FF
	JRST	TTYN		;OMIT
	MOVEM	D,@-1(P)
	SKIPN	Y,DSPTBL(CHNL)	;GET DISPOSITION WORD FOR THIS TABLE
	JRST	FINS1		;DONE, NO SAVE
	JUMPL	Y,TTYAPP	;APPEND
	ERR	<TTYIN: cannot retain break char>,1,FINS1
TTYAPP:	IDPB	D,TOPBYTE(USER)	;COUNT THE BREAK CHAR
	ADDI	A,1		;ONE MORE HAPPY CHAR
	JRST	FINS1

;;%##% ALLOW FOR ANOTHER CHUNK OF CHARS

CHRMOR:	ADDI	A,TTWCHR	;A _ NUMBER CHARS USED
	ADDM	A,-1(SP)	;UPDATE COUNT
;;#UI# ! 1 OF 2
	PUSH	P,TEMP		;SOME PEOPLE HAVE A CHARACTER HERE
	PUSH	P,[TTWCHR]	;GET SOME MORE
	PUSHJ	P,.SONTP	;BE SURE ROOM & ALIGNED
;;#UI# ! 2 OF 2
	POP	P,TEMP		;WE JUST SAVED THIS
	MOVNI	A,TTWCHR	;REFRESH THE COUNT
	POPJ	P,



HERE(TTYUP)
;;%##%  FLAGS TTY TRANSLATION TO UPPER CASE & RETURNS OLD FLAG
	MOVE 	USER,GOGTAB
	MOVE	A,-1(P)
	EXCH	A,TTYCVT(USER)
	SUB	P,X22
	JRST	@2(P)		;RETURN


;;%CS%
NOTENX<
NOSTANFORD<
;SDD- 04-FEB-80: lets recycle those spares  (why take both inputs)
;;was: HEREFK(BACKUP,BACKU.)
HERE(BACKUP)
	TTYUUO	10,0
	 JFCL		;THIS CAN SKIP?
	POPJ	P,
>;NOSTANFORD
>;NOTENX
;;%CS% ^
ENDCOM(TTY)
COMPIL(PTY,,,,,,DUMMYFORSCISS)
NOSTAN <
NOTYMSHR <
COMPXX(PTY)
>;NOTYMSHR
TYMSHR <
COMPXX(PTY,<AUXCLV,AUXCLR>,<X22,.SKIP.,DDFINA,INTRPT>,<AUXCAL ROUTINES>)
COMMENT !
	AUXCLV (PORT,ARG,FUNCTION NUMBER)
	AUXCLR IS SAME BUT ARG IS BY REFERENCE
	IF FUNCTION NUMBER HAS BITS IN LEFT HAF FOR CALL BY
	VALUE, ITS FOR AN "IMMEDIATE" TYPE INSTR LIKE SETSTS
	BOTH FUCNTIONS RETURN A VALUE BUT IT HAS MEANING ONLY
	IN SOME CASES (DEPENDS ON FUNCTION).
	SETS .SKIP.
!

;SDD- 04-FEB-80: lets recycle those spares  (why take both inputs)
;;was: HEREFK(AUXCLV,AUXCV.)
HERE(AUXCLV)
	POP P,1		;RETURN ADDRESS
	EXCH 1,-1(P)	;NOW ITS ARGUMENT
	MOVE 2,[AUXCAL 3,1]
AUXCLC:	POP P,3		;FUNCTION
	TLNE 3,-1
	HRR 2,1		;FOR IMMEDIATE
	HRL 3,-1(P)	;GET PORT NUMBER
	SETOM .SKIP.
	SKIPE INTRPT
	XCT DDFINA
	XCT 2
	SETZM .SKIP.
	SUB P,X22
	JRST @2(P)

;SDD- 04-FEB-80: lets recycle those spares  (why take both inputs)
;;was: HEREFK(AUXCLR,AUXCR.)
HERE(AUXCLR)
	POP P,2
	EXCH 2,-1(P)	;NOW ITS PARAMETER ADDRESS
	MOVE 1,2		;IN CASE FUNCTION WITH BITS IN LH
	HRLI 2,(<AUXCAL 3,>)
	JRST AUXCLC
>;TYMSHR
>;NOSTAN
STANFO <
COMPXX(PTY,<PTYGET,PTYREL,PTIFRE,PTOCNT,PTCHRW,PTCHRS
ENTINT <PTOCHS,PTOCHW,PTOSTR,BACKUP,LODED,PTYALL,PTYSTR,PTYIN>
ENTINT <PTYSTL,PTYGTL>>
	  ,<SAVE,RESTR,X11,X22,X33,INSET,CAT,STRNGC,GOGTAB,BRKMSK,BKTCHK,.SKIP.>
	  ,<PTY ROUTINES>)




COMMENT \Ptyuuo functions \

	OPDEF	PTYUUO	[711B8]

DSCR PTYUUO FUNCTIONS
CAL SAIL

COMMENT \
BEGIN "PTYSPC"
INTEGER PROCEDURE PTYGET;
PROCEDURE PTYREL(INTEGER LINE);
INTEGER PROCEDURE PTIFRE(INTEGER LINE);
INTEGER PROCEDURE PTOCNT(INTEGER LINE);
INTEGER PROCEDURE PTCHRS(INTEGER LINE);
PROCEDURE PTOCHS(INTEGER LINE,CHAR);
PROCEDURE PTOCHW(INTEGER LINE,CHAR);
PROCEDURE PTOSTR(INTEGER LINE; STRING INFORMATION);
PROCEDURE LODED(STRING TRYAGAIN);
STRING PROCEDURE PTYALL(INTEGER LINE);
PROCEDURE BACKUP;
STRING PROCEDURE PTYSTR(INTEGER LINE,BRCHAR);
STRING PROCEDURE PTYIN(INTEGER LINE,BKTBL; REFERENCE INTEGER BRCHAR);

END "PTYSPC"

\


HERE (PTYGET)
	SETOM	.SKIP.
	MOVEI	A,0
	PTYUUO	A
	SETZM	.SKIP.
	POPJ	P,

HERE (PTYREL)
	POP	P,(P)
	EXCH	A,(P)
	PTYUUO	1,A
	POP	P,A
	JRST	@2(P)

HERE (PTYGTL) PUSH	P,(P)	;ANOTHER COPY OF RETURN ADDRESS.
	PTYUUO	13,-2(P);POINT AT PTY LINE NUMBER
	MOVE	A,-1(P)	;RESULT.
	SUB	P,X33
	JRST	@3(P)	;AND RETURN.

HERE (PTYSTL) PTYUUO 14,-2(P);POINTED AT LINE NUMBER!
	SUB	P,X33
	JRST	@3(P)

HERE (PTIFRE)
	MOVE	TEMP,[PTYUUO 2,0]
	JRST	%PTY1

HERE (PTOCNT)
	SKIPA	TEMP,[PTYUUO 3,0]

HERE (PTCHRW)
	MOVE	TEMP,[PTYUUO 5,0]
%PTY1:	POP	P,(P)
	EXCH	0,(P)
	XCT	TEMP
	POP	P,0
	JRST	@2(P)

HERE (PTCHRS)
	POP	P,(P)
	EXCH	0,(P)
	PTYUUO	4,0
	MOVNI	A,1
	POP	P,0
	JRST	@2(P)

HERE (PTOCHS)
	SKIPA	TEMP,[PTYUUO 6,0]

HERE (PTOCHW)
	MOVE	TEMP,[PTYUUO 7,0]
	SETOM	.SKIP.
	POP	P,(P)
	EXCH	A,(P)
	EXCH	0,-1(P)
	XCT	TEMP
	SETZM	.SKIP.
	POP	P,A
	POP	P,0
	JRST	@3(P)

HERE (LODED)
	MOVEI	TEMP,0
	EXCH	TEMP,(P)
	PUSH	P,TEMP
	SKIPA	TEMP,[PTYUUO 15,-1(SP)]

HERE (PTOSTR)
	MOVE	TEMP,[PTYUUO  11,-1(SP)]
	PUSH	P,TEMP
	MOVE	USER,GOGTAB
	PUSHJ	P,INSET
	PUSH	SP,[1]
	PUSH	SP,[POINT 7,[0]]
	PUSHJ	P,CAT
	POP	P,TEMP
	POP	P,(P)
	POP	P,-1(SP)
	XCT	TEMP
	SUB	SP,X22
	JRST	@2(P)

HERE (BACKUP)
	TTYUUO	10,
	POPJ	P,

HERE (PTYALL)
	PUSHJ	P,SAVE
	MOVE	0,-1(P)	;LINE NUMBER
	PTYUUO	3,0
	JUMPE	A,[PUSH SP,[0]
		   PUSH SP,[0]
		   JRST ALLQ]
	MOVEI	A,=450
	ADDM	A,REMCHR(USER)
	SKIPL	REMCHR(USER)
	PUSHJ	P,STRNGC
	PUSHJ	P,INSET
	PUSH	SP,-1(P)	;PTY LINE NUMBER
	PUSH	SP,TOPBYTE(USER)	;AND BYTE POINTER.
	PTYUUO	10,-1(SP)	;AND ASK FOR ALL THAT IS THERE.
	MOVEI	B,0
	MOVE	C,(SP)		;BYTE POINTER.
;;#IN# 7-11-72 DCS TOPBYTE INVALIDLY UPDATED (ONE TOO FAR)
SOMMOR:	MOVE	LPSA,C		;LAG BY ONE		#IN#
	ILDB	0,C		;GET CHAR
	JUMPE	0,ALLDUN
	AOJA	B,SOMMOR
ALLDUN:	CAILE	B,=445
	 ERR	 <PTYALL OVERFLOW -- IT JUST CAN'T HAPPEN!!!!>
	HRROM	B,-1(SP)	;SAVE AS RESULT.
	MOVEM	LPSA,TOPBYTE(USER);THIS IS WHERE TO START ENXT ITEM. #IN#
;;#IN#
	SUBI	B,=156		;-ESTIMATE
	ADDM	B,REMCHR(USER)	;AND UPDATE FREE COUTN.
ALLQ:	MOVE	LPSA,X22
	JRST	RESTR

%REDSTR:SKIPE	SGLIGN(USER)
	PUSHJ	P,INSET
	MOVEI	A,=100
	ADDM	A,REMCHR(USER)
	SKIPLE	REMCHR(USER)
	PUSHJ	P,STRNGC
	MOVNI	A,=100
	PUSH	SP,[0]		;NULL STRING IF NOTHING DONE
	PUSH	SP,TOPBYTE(USER)
	POPJ	P,

%FINSTR:	CAIN	TEMP,15	;REMOVE LFD IF CR BROKE IT
;;#PO# ! RHT THIS USED TO BE CDB (=11) & MUNGED 12
;; USE C & D INSTEAD
	PTYUUO	5,C		;HE USED TO SAY CDB
%FINS1:	ADDM	A,REMCHR(USER)	;NUMBER NOT USED
	ADDI	A,=100		;NUMBER USED
	HRROM	A,-1(SP)	; AND TO STRING COUNT WORD
	JRST	RESTR

HERE (PTYSTR)
	PUSHJ	P,SAVE
	PUSHJ	P,%REDSTR
;;#PO#
	MOVE	C,-2(P)
	MOVE	B,-1(P)		;BREAK CHAR
	MOVE	LPSA,X33	;# TO REMOVE
;;#PO# (2 LINES)
%INS1:	PTYUUO	5,C		;NEXT CHAR
%INS2:	CAMN	D,B		;BREAK?
	 JRST	 %FINSTR		; YES, ALL DONE
;;#PO#
	IDPB	D,TOPBYTE(USER) ;PUT IT AWAY AND
	AOJA	A,%INS1		; GO BACK FOR MORE

	JRST	%INS2

HERE (PTYIN) PUSHJ	P,SAVE
;;#PO# (2 LINES)
	MOVE	C,-3(P)
	PTYUUO	5,C

%TYIN:	PUSHJ	P,%REDSTR		;PREPARE STACK,A,STRNGC FOR A STRING
	MOVE	LPSA,[XWD 4,4]		;PREPARE TO RETURN
%TYIN1:	SETZM	@-1(P)		;ASSUME NO BREAK CHAR
	MOVE	X,-2(P)		;TABLE #
	MOVEI	TEMP,-1		;BLOCK MUST BE THERE AND BE INIT'ED
	PUSHJ	P,BKTCHK	;CHECK TABLE #
	 JRST	%FINS1		;ERROR OF SOME SORT
	MOVE	FF,BRKMSK(CHNL)	;GET MASK FOR THIS TABLE
	ADD	CHNL,CDB	;RELOCATE RANGE 1 TO 18
	MOVEI	Z,1		;FOR TESTING LINE NUMBERS
	SKIPN	LINTBL(CHNL)	;DON'T LET TEST SUCCEED IF
	 MOVEI	 Z,0		;WE'RE TO LET LINE NUMBERS THRU
	MOVE	Y,CDB		;BASE OF THIS GROUP
;;#PO# !
	ADD	Y,[XWD D,BRKTBL] ;BRKTBL+RLC(CDB)
	JRST	%TTYN1
;;#PO# !
%TTYN:	PTYUUO	5,C
%TTYN1:	TDNE	FF,@Y		;BREAK OR OMIT?
	JRST	%TTYSPC		; YES, FIND OUT WHICH
;;#PO# !
%TTYC:	IDPB	D,TOPBYTE(USER)	;PUT IT AWAY
	AOJL	A,%TTYN		;COUNT AND CONTINUE
	JRST	%FINS1		;DONE
%TTYSPC: HLLZ	TEMP,@Y		;WHICH?
	TDNN	TEMP,FF
	JRST	%TTYN		;OMIT
;;#PO# !
	MOVEM	D,@-1(P)
	SKIPN	Y,DSPTBL(CHNL)	;PICK UP DISPOSITION WORD
	JRST	%FINS1		;DONE, NO SAVE
	JUMPL	Y,%TTYAPP	;APPEND
	ERR	<PTYIN: cannot retain break char>,1,%FINS1
;;#PO#
%TTYAPP: IDPB	D,TOPBYTE(USER)	;COUNT THE BREAK CHAR
	ADDI	A,1		;ONE MORE HAPPY CHAR
	JRST	%FINS1

>;STANFO
ENDCOM(PTY)


IFE SEGS,<
;; 20-OCT-79 SDD [=F7=] LDE 22-JUN-76  Let's keep the hiseg to 13 K.
;;  was: IFnon-zero ((lnot segs)&1) which = is SEGS even. (SEGS is 0/1)

;;#XB ! JFR 6-17-76 TOPBYT and REMCHR removed from external list
COMPIL(TMP,<TMPIN,TMPOUT>
		 ,<GOGTAB,STRNGC,INSET,CORGET,CORREL,X22,X44>
		 ,<Tmpcor input and output routines>)
COMMENT	\  TMPIN (input from a tmpcor file)

;; SUBROUTINES SUPPLIED BY MJC -- 9 MARCH 1976
;; redone by SDD 20-OCT-78
Call from a Sail program:  STR_TMPIN(TMPFIL,@FLAG)
where TMPFIL and STR are strings and FLAG is boolean.

This routine fills STR with the contents of tmpcor file TMPFIL.  FLAG
is set to true if the tmpcor file doesn't exist, and false otherwise.
Accumulators A-F and USER are used and not reset.  Notice that nulls
and "line numbers" are ignored.

Nulls must be ignored since TMPCOR may give you up to three extra words
of 0's.  Line numbers are ignored because certain utilities may copy 
them across from a file.  Since it is not impossible someone may have 
output normal text with the low bits on, a line number is checked for 
(spaces or 5 decimal digits), and non-line numbers are treated as text.
Also, storage for TMPCOR read is now out of string space for 2 reasons: 
 (1) excessive GC invokation seems likely with the former technique,
 (2) setting the low order bit in string space may be quite dangerous.

The address of FLAG have been pushed onto the P stack, and TMPFIL's two 
descriptor words have been pushed onto the SP stack.  (Note that a Sail
string descriptor consists of two words:  
	[constant flag,,length], [byte pointer].)  
Hence the parameters are accessed as follows:
    -1 (P) contains the address of FLAG
     0(SP) contains the byte pointer to TMPFIL
    -1(SP) contains the flag/length word for TMPFIL.

TMPIN first asks the Sail system for enough storage to accommodate the 
largest possible tmpcor file.  It then does a TMPCOR uuo to read the 
contents of the desired tmpcor file into the block.  Accumulators
E and F are used to hold the two-word tmpcor information block.  
If the file doesn't exist, FLAG is set to true (non-0), storage is 
released, and null is returned.
If the file does exist, FLAG is set false, string storage is allocated
and a string descriptor is built based on the size of the TMPCOR file
in words.  Then all the non-null, non-lineno characters from the TMPCOR 
area are transferred into string space keeping track of how many 
characters were ignored.  The resultant string and string space itself 
is corrected by this factor (thus recycling string space) core is
de-allocated, and TMPIN returns to the caller.
Sail features used are the following:
    REMCHR(USER)	# characters remaining in string space, negated
    TOPBYT(USER)	byte pointer to the first free character 
			in string space
    SGLIGN(USER)	non-zero means string must begin on word bound.
    STRNGC		string storage manager
    INSET		aligns TOPBYT to a word boundary

\

;SDD- 04-FEB-80: lets recycle those spares  (why take both inputs)
;;was: HEREFK(TMPIN,TMPIN.)	; *** Sail wants this.
HERE(TMPIN)			; *** Sail wants this.

	BEGIN	TMPIN
	F_6
	G_7
	tmfmax__400		;maximum # of words for tmpcor request
	move	user,gogtab
	setzm	@-1(p)		;presume success
	hrrzi	c,tmfmax+1	;Get enough storage to do the TMPCOR+1
	PUSHJ	P,CORGET	;Get a buffer of the appropriate size.
	 JRST	[err <TMPIN: Insufficient CORE available>,1
		 setom	@-1(user)	;list it as an error
		 setzm	-1(sp)		;null string result
		 jrst	tinxit]
	push	p,b		;*** save base address of tmpcor block
	hrlzi	f,-tmfmax	;construct IOWD for TMPCOR UUO
	hrri	f,-1(b)		;into F for the TMPOP routine
	move	b,(sp)		;get temp file name for tmpop
	hrrz	c,-1(sp)	;
	hrlzi	a,1		;opcode for tmpcor read is 1
	pushj	p,tmpop
	 jrst	[hrrom	a,@-2(p);save return flag, make non-zero
		 jrst	nulret]
	jumple	a,nulret	;dont bother anyone if 0 word block
	caile	a,tmfmax	;check to make sure enough was read
	 jrst	[err <TMPIN: huge TMPCOR file found>,1
		 movei	a,tmfmax ;complain and set to max
		 jrst	.+1]
	movn	g,a		;save actual length read (words)
	imuli	a,5		;convert to character count
	skipe	sglign(user)	;do we want aligned string?
	 pushj	p,inset		;yup, align away
	addm	a,remchr(user)	;request string space (may be large)
	skiple	remchr(user)
	 jrst	[movem	rf,racs+rf(user) ;save frame to keep GC quiet
		pushj	p,strngc
		jrst	.+1]
	hrrom	a,-1(sp)	;save predicted length
	move	a,topbyte(user) ;and base byte pointer
	movem	a,(sp)		;as resultant string
	setz	e,		;clear "off by" count (for later adjust)
	hrlzi	d,(g)		;build AOBJN ptr to TMPCOR data
	hrr	d,(p)		;-count ,, base
;;	jrst	wrdlup		;and start

wrdlup:	skipn	b,(d)		;get word
	 jrst	[subi	e,5	;five gone (word of nulls)
		aobjn	d,wrdlup;go get more
		jrst	xfrend]	;unless that was it
	trze	b,1		;check for line number
	 jrst	chklin		;might be, check farther
notlin:	movei	c,5
bytlup: lshc	a,7		;get the next byte from B
	trnn	a,177		;is it null?
	 soja	e,.+2		;yep, lower our estimate by 1
	 idpb	a,topbyte(user)	;nope, move the byte
	sojg	c,bytlup
	aobjn	d,wrdlup
xfrend:	addm	e,remchr(user)	;return unused string space
	addm	e,-1(sp)	;and fix up string length of result
	jrst	strret		;clean up, and go home

chklin:	camn	b,[ascii/     /] ;is it an SOS page mark?
	 jrst	islino		;sho nuf, skip it
	xor	b,[ascii/00000/] ;are all digits in range
	tdnn	b,[byte(7) 160,160,160,160,160]; ["0":=15+"0"]?
	 add	b,[byte(7) 006,006,006,006,006] ; 9+6 leq 15
	tdnn	b,[byte(7) 160,160,160,160,160]; ["0":=9+"0"]?
	 jrst	islino	;either at least one digit had the top
			;three bits prove non-integer, or the
			;some digit+6 .gt. 15 (digit over 9)
	move	b,(d)		;wasn't linenum, use as text
	jrst	notlin
islino:	subi	e,5		;indicate lost 5 bytes
	aobjp	d,xfrend	;advance count (shouldn't be last)
	move	b,(d)		;pickup next word of tmpcor file
	lsh	b,7		;clear out the tab that follows linenos
	movei	c,4		;get bytes left in word count (5-1)
	soja	e,bytlup	;account for missing byte (the tab)


nulret:	setzm	-1(sp)		;clear result string
strret:	pop	p,b		;*** recover base of tmpcor block
	pushj	p,correl	;  and return it to the pool
tinxit:	sub	p,x22	;and return
	jrst	@2(p)

;The code for TMPOP is on the next page.

	BEND	TMPIN

COMMENT	\  TMPOUT (output to a tmpcor file)

Call from a Sail program:  TMPOUT(TMPFIL,STR,@FLAG)
where TMPFIL and STR are strings and FLAG is boolean.

This routine writes the string STR into tmpcor file TMPFIL.  FLAG is 
set to true if the tmpcor file could not be written, and false 
otherwise.  Accumulators A-G and USER are used and not reset.  Since 
the TMPCOR uuo will not write an empty tmpcor file, a null STR causes
FLAG to be set true.

The address of FLAG has been pushed onto the P stack, and the string 
descriptor words of TMPFIL and STR have been pushed onto the SP stack.
Hence the parameters are accessed as follows:
    -1( P) contains the address of FLAG
     0(SP) contains the byte pointer to STR
    -1(SP) contains the flag/length word for STR
    -2(SP) contains the byte pointer to TMPFIL
    -3(SP) contains the flag/length word for TMPFIL.

TMPOUT first ascertains the length of the string to be written and 
acquires a chunk of core of the appropriate size for use as a buffer.
It then converts the first three characters of TMPFIL to sixbit, copies
STR to the buffer in order to align it on a word boundary, and does 
the tmpcor output.  Accumulators E and F are used for the two-word 
tmpcor information block.  TMPOUT then sets FLAG and returns.

Sail features used are the following:
    CORGET		given the desired number of words of core in 
			C, returns the address of a block of that 
			size in B (skip return if success, direct
			return if failure)
    CORREL		given the address of a block in B, releases it
			to free storage (always direct return)
\

;SDD- 04-FEB-80: lets recycle those spares  (why take both inputs)
;;was: HEREFK(TMPOUT,TMPOU.)	;*** Sail wants this.
HERE(TMPOUT)			;*** Sail wants this.

	BEGIN	TMPOUT
	F_6
	G_7
;Get the right amount of buffer space and fill in tmpcor info IOWD.
	HRRZ	C,-1(SP)	;Get length of STR.
	ADDI	C,9		;Get enough words to hold the string 
	IDIVI	C,5		;plus an extra word, convert to words.
	PUSH	P,C		;Save length (need it for tmpcor info).
	PUSHJ	P,CORGET	;Get a buffer of the appropriate size.
	 JRST	NOSTG		;Couldn't get the core.
;;SDD we want a clear area, so zero it (no low order bits set)
	setzm	(b)		;clear first word
	movei	c,1(b)		;set up zeroing BLT ac
	hrli	c,(b)
	hrrz	d,(p)		;last address is size of buffer
	addi	d,(b)		;plus address of base of buffer
	blt	c,-1(d)		;minus one
;;SDD area now clear (warning: do not use value in C)
	MOVE	G,B		;Address of block in B, save in G.
	MOVEI	F,-1(B)		;construct IOWD for tmpcor info.
	POP	P,C		;which is XWD -length,,addr-1
	MOVNI	C,-1(C)		;decremented by 1 since an extra
	HRL	F,C		;word was CORGETed.

;Copy STR to the buffer.  Address of buffer is in B.
	HRLI	B,440700	;make byte pointer for buffer.
	MOVE	C,(SP)		;Get the byte pointer for STR.
	HRRZ	A,-1(SP)	;Length of STR.
	jumpe	a,cpydon	;get out right now if null string
LOOP:	ILDB	D,C		;No, copy another character.
	IDPB	D,B
	sojg	a,loop		;Done copying?
CPYDON:
;Get tmpcor file name, put it into tmpcor info, and output buffer.
	HRRZ	C,-3(SP)	;Get length of the tmpcor file name.
	MOVE	B,-2(SP)	;Get the byte pointer to the name.
	hrlzi	a,3		;opcode for tmpcor write is 3
	pushj	p,tmpop		;go do it
	 JRST	NOWRIT		;Couldn't do it.
	SETZB	A,@-1(P)	;Make FLAG "false" (0).
DONE:	MOVE	B,G		;Return the buffer to free storage.
	PUSHJ	P,CORREL
XIT:	SUB	SP,X44		;Pop all the string stuff.
	SUB	P,X22
	JRST	@2(P)		;Return.

;TMPCOR uuo direct-returned.  Probably no more space for tmpcor files.
NOWRIT:	hrrom	a,@-1(p)	;couldn't do output for some reason,
	hrroi	a,a		;make return value same as flag
	JRST	DONE		;so set flag and return

;CORGET direct-returned.
NOSTG:	ERR	<Couldn't get core for buffer.>	;*** Sail wants this.
	JRST	XIT		;*** P and SP screwed up right now.

;Code for TMPOP is on the next page.

	BEND	TMPOUT




comment \ TMPOP (perform a tempcor operation)
perform tmpcor operation lh(A) on tmpcor file name (ascii) with
length in C, pointer in B.  Name will be set up in E, F and G are
presumed set up for the operation already.  Direct return on failure,
skip return on success.  B,C,D clobbered, E set to sixbit of name,
A is the register used for the operation (hence may contain results
supplied by the system).
\

tmpop:	setz	e,	;e will hold sixbit(name)
	jumple	c,nameok;if no chars in name, don't translate
	caile	c,3
	 movei	c,3	;tmpcor names are only 3 chars long
	push	p,a	;save tmpcor op code
	move	a,[point 6,e]	;byte pointer for translated name
tranch:	ildb	d,b		;get a character
	trzn	d,100		;translate it to sixbit
	 trza	d,40		;ascii 0:77 map into SIXBIT 0:37,0:37
	 tro	d,40		;ascii 100:177 map into 40:77,40:77
	idpb	d,a		;store translated character
	sojg	c,tranch	;if any chars left, loop
	pop	p,a	;recover tmpcor op code
nameok:	hrri	a,e	;make A into  op,,loc.name
	tmpcor	a,	;perform tmpcor operation
	 popj	p,	; failure, take direct return
	aos	(p)	; success, take skip return
	popj	p,
ENDCOM(TMP)
>;IFE SEGS
IFN ALWAYS,<
BEND IOSER>
DSCR BEND IOSER


GZ;Yl