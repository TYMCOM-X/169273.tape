BEGIN "SYMBOL"

REQUIRE '10 VERSION; comment W.R.Soley 3/20/82;

FORWARD RECORD!CLASS FORHDR (INTEGER TYP,CNT1,CNT2,CNT3;
	 RECORD!POINTER (ANY!CLASS) TEXT,ARGSTR);
RECORD!CLASS MACTXT(INTEGER TYP,ARGNUM; STRING TXT;
	RECORD!POINTER (MACTXT) NEXT);
RECORD!CLASS MACALIST (STRING ARG;
	RECORD!POINTER (MACALIST) NEXT);
RECORD!CLASS MACDEF (INTEGER ARGN; RECORD!POINTER (MACTXT) TXT;
	RECORD!POINTER (MACALIST) ARGS);
RECORD!CLASS MACARG (RECORD!POINTER (MACARG) NEXT;
	RECORD!POINTER (MACTXT) ARGTXT);
RECORD!CLASS CURMAC (RECORD!POINTER (CURMAC)OLD;
	RECORD!POINTER (MACTXT,FORHDR) ORGTXT;
	RECORD!POINTER (MACARG) CURARG; RECORD!POINTER (MACTXT)
	CURTXT; STRING OLDSTR,OLDLST; INTEGER TYPE);
RECORD!CLASS FORHDR (INTEGER TYP,CNT1,CNT2,CNT3;
	RECORD!POINTER (MACTXT) TEXT,ARGSTR);
REQUIRE "<><>" REPLACE!DELIMITERS;
DEFINE MT!LINE=0,MT!FIN=1,MT!ARG=2,MT!MORE=3;

DEFINE UPRCAS=<"ABCDEFGHIJKLMNOPQRSTUVWXYZ">;
DEFINE LOWCAS=<"abcdefghijklmnopqrstuvwxyz">;
DEFINE ALPHABET=<LOWCAS&UPRCAS>;
DEFINE DIGITS=<"0123456789">;
DEFINE ALPHANUM=<ALPHABET&DIGITS>;

DEFINE FOR!ARITH=0,FOR!WORD=1,FOR!CHR=2;

DEFINE GETTRU=4,CURTRU=<CALL(-1 LSH 18+GETTRU,"GETTAB")>,
	SOKMAX='377,SOAKEMC=-'56,
	DOSOAK(S)=<CALLI((S),SOAKEMC)>;
REQUIRE 500 SYSTEM!PDL;
DEFINE HEADING=COMPILER!BANNER;
DEFINE IFBL1=LENGTH(SCANC(CVMS(HEADING),'12,NULL,"IS")),
 IFBL2=CVMS(HEADING)[IFBL1 TO ],
 IFBL3=CVMS(IFBL2)[LENGTH(SCANC(CVMS(IFBL2),"B",NULL,"IS")) FOR 1],
 IFBAIL=< not CVMS(IFBL3)="0">;
IFC IFBAIL THENC REQUIRE "(SAILIB)RECPRN" LOAD!MODULE;
 REQUIRE "SYS:BAIPD8" LOAD!MODULE;
 EXTERNAL PROCEDURE BAIL; ENDC

FORWARD RECORD!CLASS STORE(INTEGER A,B,Q; RECORD!POINTER(ANY!CLASS) C,D,F);
RECORD!CLASS FIXUP(INTEGER TYP,VAL1,VAL2;
	RECORD!POINTER (FIXUP) RPV1,RPV2);
RECORD!CLASS FIXHED(INTEGER COUNT; RECORD!POINTER (FIXUP)
	FIXUP; RECORD!POINTER (STORE) STORE);
RECORD!CLASS SYMBOL(STRING NAME; INTEGER TYP,SUBTYP,VALUE;
	RECORD!POINTER (SYMBOL) NEXT;
	RECORD!POINTER (FIXHED,STORE,MACDEF) FIXUP);
RECORD!CLASS STORE(INTEGER TYP,VAL,LOC; RECORD!POINTER (STORE)
	NEXT; RECORD!POINTER (FIXHED,SYMBOL) FIXHED;
	RECORD!POINTER (FIXUP)FIXUP);
SAFE RECORD!POINTER (SYMBOL) ARRAY SYMTAB,SAVSYA[0:100];
RECORD!POINTER (SYMBOL) CURSYM,SAVSYM,SYMSTD,INCLST,CURINCL;
INTEGER CNT,EOF,BCHR,VL,LNUM,PGNUM,SOSNUM,TY,STY,I,ASMPC;
INTEGER SCNT,SEOF,SBCHR,RELPC;
INTEGER SOSNUM2,SAVETRU,CURRAD,INPRAD,SCURRAD,SINPRAD;
STRING OPCOD,CMDSTR,THIS!ASSEMBLY;

DEFINE S!EOL=0,S!SYM=1,S!NUM=2,S!SPC=3;
DEFINE T!SMAC=6,T!SPC=4,T!MAC=5,T!PSD=2,T!OPC=1,T!SYM=3;
STRING CURSTR,CODSTR,LSTSTR,ERRSTR;
INTEGER SCNVAL,SCNCOD,J,CURHSH,JOBSA;
DEFINE EOL='12;
DEFINE C!XOR=1,C!OR=2,C!AND=3,C!PLS=4,C!MIN=5,C!MLT=6,
	C!DIV=7,C!MOD=8,C!SHR=9,C!SHL=10,C!NOT=11,C!SNG=12,
	C!LPR=13,C!DOL=14,C!NEG=15,C!DIG=16,C!LET=17,C!EOL=18,
	C!DOT=19,C!AT=20,C!PRC=21;
DEFINE B!LIN=12,B!SPC=2,B!SYM=3,B!NUM=4; COMMENT BREAK TABLES;
DEFINE B!FIL1=5,B!FIL2=6,B!FIL3=7,B!FIL4=8,B!IF=9,B!DEFINE=10;
DEFINE B!MACARG=11;
DEFINE V!UND=1,V!SET=2,V!EQU=3,V!PST=4,V!PEQ=5,V!ORGS='400000,
	V!USE='200000,V!MASK='177777,V!BD='10,V!H='20,
	V!PSW='40,V!SP='100,V!REG='200,V!Z80='400;
DEFINE MAXBYT=50,LPPMAX=50;
SAFE INTEGER ARRAY BYTARY[1:MAXBYT];
INTEGER CFLN,CFLNT,MSTLOC,BYTNUM,ERRCNT,ERRPG,LPP,LPP2;
INTEGER VAL,VTY,OSCAN,MAXPC,GENSYM,OSCAN!OP,MINPC;
BOOLEAN RUNNING,NOXMAC,TMPCOR,SPDFLG,CRFSW,DWNLSW,NOREL,ONEPAS;
RECORD!POINTER (FIXUP,SYMBOL) CODVAL;
INTEGER CH!IN,CH!OUT,CH!REL,CH!CTRL,CH!LOAD;
INTEGER CBCHR,CEOF,CCNT;
RECORD!CLASS FILE (STRING NAME,EXT,DEV;
	INTEGER SOSNUM,SOSNUM2,LNUM,PGNUM,CHNUM,CFLN; BOOLEAN USE;
	RECORD!POINTER (CURMAC) MACSAV;
	RECORD!POINTER (SYMBOL) INCLSAV,CURINCL;
	RECORD!POINTER (FILE) NEXT,NEXTI,OLDSRC);
RECORD!POINTER (FILE) RPSRC,RPHEAD,RPHSAV,INCLHED;
STRING SWT,CRFSTR,ACCUM;
EXTERNAL BOOLEAN RPGSW;
EXTERNAL INTEGER !SKIP!,JOBERR;
BOOLEAN MORFLG,LSTSW,RELSW,PASS1,LSTTTY,NOXSYM,NOSYMT;
BOOLEAN MACLST,NSTLST,MACLSTU,LSTRMB;
PRESET!WITH "JAN","FEB","MAR","APR","MAY","JUNE","JULY",
	"AUG","SEPT","OCT","NOV","DEC";
SAFE STRING ARRAY MONTAB[0:11];
RECORD!CLASS IFH(RECORD!POINTER (IFH) OLD; INTEGER PCNT);
RECORD!POINTER (IFH) IFHDR;
RECORD!POINTER (CURMAC) THISMAC;
STRING TITLE,SUBTITLE;

DEFINE ST!WRD=0,ST!BYT=1,ST!SYM=2,ST!FX1=3,ST!FX2=4,ST!DLT=5;
DEFINE ST!WRDF=6,ST!BYTR=7,ST!PAG=8;
DEFINE FXV!SYM=1,FXV!FXU=0;
DEFINE ORG!CAT!CHR=<"""">;

DEFINE UNSIMPLE=<>; COMMENT KNOWN NOT SIMPLE PROCEDURE;

DEFINE SAISCN=<FALSE>;
IFC SAISCN THENC
PRESET!WITH ['12] 17,C!EOL,['41-'13] 17,C!OR,17,17,C!DOL,C!PRC,C!AND,
	C!SNG,C!LPR,17,C!MLT,
	C!PLS,17,C!MIN,C!DOT,C!DIV,[10] C!DIG, [6] 17, C!AT, [26] C!LET,
	[6] 17, [26] C!LET, C!LPR, [4] 17;
ELSEC
DEFINE TFDIG='200000000000,TFLOW='100000000000,TFPREDG='040000000000,
TFCONTD=<'020000000000>,TFLAG=<'400000000000>,
SETRAD(A)=<TFPREDG LOR A>,SETDIG(A)=<TFDIG LOR TFCONTD LOR A LOR TFLAG>,
SETLDG(A)=<TFLAG LOR TFCONTD LOR A>,XXQ=1;
PRESET!WITH 17,0,[7] 17,0,C!EOL,['40-'13] 17,0,C!OR,17,17,
 SETRAD(16),SETRAD(2),C!AND,C!SNG,C!LPR,17,C!MLT,C!PLS,17,C!MIN,
 C!DOT,C!DIV,FORC XXQ_0 STEPC 1 UNTILC 9 DOC <SETDIG(XXQ),> ENDC
 [4] 17,SETRAD(10),17,SETRAD(8),SETLDG(10),TFPREDG LOR SETLDG(11),
 FORC XXQ_12 STEPC 1 UNTILC 15 DOC <SETLDG(XXQ),> ENDC
 TFLAG,TFLAG LOR SETRAD(16),[6] TFLAG,TFLAG LOR SETRAD(8),TFLAG,
 TFLAG LOR SETRAD(8),[9] TFLAG,[6] 17,TFLOW LOR SETLDG(10),
 TFLOW LOR TFPREDG LOR SETLDG(11),FORC XXQ_12 STEPC 1 UNTILC 15 DOC
 <TFLOW LOR SETLDG(XXQ),> ENDC TFLAG LOR TFLOW,TFLOW LOR TFLAG LOR SETRAD(16),
 [6] TFLAG LOR TFLOW,TFLAG LOR TFLOW LOR SETRAD(8),TFLAG LOR TFLOW,
 TFLAG LOR TFLOW LOR SETRAD(8),[9] TFLAG LOR TFLOW, C!LPR,[4] 17;
ENDC
SAFE INTEGER ARRAY CHRTABO[0:127]; SAFE INTEGER ARRAY CHRTAB[0:127];

SIMPLE STRING PROCEDURE CVHDD(INTEGER I);
RETURN (((I LSH -4) LAND '17)&(I LAND '17));

SIMPLE STRING PROCEDURE CVHDM(INTEGER I,J);
BEGIN STRING S;
S_NULL; WHILE (I_I-1) geq 0 DO BEGIN S_CVHDD(J)&S; J_J LSH -8 END;
RETURN(S) END "CVHDM";

FORWARD SIMPLE PROCEDURE ERRSET (INTEGER I; STRING S);

RECORD!POINTER (ANY!CLASS) RPTEMP,RPTEMP2,RPTEMP3,RPTEMP4;
SIMPLE RECORD!POINTER (FILE) PROCEDURE FILNAM(REFERENCE STRING SWTR);
BEGIN STRING STR,FN;
SIMPLE STRING PROCEDURE SWTCHK;
BEGIN STRING SWT;
IF CBCHR="(" THEN BEGIN SWT_SCAN(CMDSTR,B!FIL2,CBCHR)[2 FOR INF];
	STR_SCAN(CMDSTR,B!FIL4,CBCHR) END ELSE
 IF CBCHR neq "/" THEN RETURN(NULL) ELSE BEGIN
SWT_SCAN(CMDSTR,B!FIL3,CBCHR); STR_SCAN(CMDSTR,B!FIL4,CBCHR)
	END;
RETURN(SWT) END"SWTCHK";


STR_SCAN(CMDSTR,B!SPC,CBCHR);
SPDFLG_FALSE;
IF CBCHR="/" THEN SWTR_SWTR&SWTCHK;
IF CBCHR="," or CBCHR="_" or CBCHR=0 or CBCHR='12
	THEN BEGIN STR_SCAN(CMDSTR,B!FIL4,CBCHR);
		RETURN (NULL!RECORD) END;
FILE:USE[RPTEMP_NEW!RECORD(FILE)]_TRUE;
IF CBCHR="(" THEN BEGIN "USERNAME"
 FN_SCAN(CMDSTR,B!FIL2,CBCHR)&")";
 IF CBCHR=")" THEN STR_SCAN(CMDSTR,B!SPC,CBCHR) END ELSE FN_NULL;
STR_SCAN(CMDSTR,B!FIL4,CBCHR);
IF CBCHR=":" THEN BEGIN SPDFLG_TRUE; FILE:DEV[RPTEMP]_STR; STR_
	SCAN(CMDSTR,B!SPC,CBCHR); STR_SCAN(CMDSTR,B!FIL4,CBCHR) END;
FN_FN&STR;
IF CBCHR="." THEN BEGIN
 STR_SCAN(CMDSTR,B!FIL1,CBCHR);
 FN_FN&"."&(FILE:EXT[RPTEMP]_STR) END;
IF CBCHR="[" THEN
 FN_FN&"["&SCAN(CMDSTR,B!FIL1,CBCHR)&CBCHR&SCAN(CMDSTR,B!FIL1,CBCHR);
IF LENGTH(FILE:DEV[RPTEMP])=0 THEN FILE:DEV[RPTEMP]_"DSK";
IF CBCHR="(" THEN CMDSTR_"("&CMDSTR;
SWTR_SWTR&SWTCHK; FILE:NAME[RPTEMP]_FN; RETURN(RPTEMP) END "FILNAM";

SIMPLE PROCEDURE FINLIN (STRING STR);
BEGIN STRING SFK;
IF CBCHR neq '12 THEN SFK_SCAN(CMDSTR,B!LIN,CBCHR);
CBCHR_-1; OUTSTR ('12&'15&STR&'12&'15) END "FINLIN";

SIMPLE PROCEDURE ERRLIN (STRING STR);
BEGIN STRING SFK;
SFK_NULL;
IF CBCHR neq '12 THEN SFK_SCAN(CMDSTR,B!LIN,CBCHR);
CBCHR_-1; OUTSTR ('12&'15&STR&" "&SFK&'12&'15);
END "ERRLIN";

SIMPLE PROCEDURE EOFERR (STRING NAME);
BEGIN
FINLIN (NAME); EOF_0; ERRSET (1,"E"); LSTSTR_'12;
RUNNING_FALSE; COMMENT FORCE TERMINATION OF ASSEMBLY;
END "EOFERR";


FORWARD RECURSIVE INTEGER PROCEDURE ISCAN;
SIMPLE PROCEDURE UNINCLUDE;
BEGIN
IF CH!IN geq 0 THEN RELEASE(CH!IN);
CH!IN_FILE:CHNUM[INCLHED];
SOSNUM2_FILE:SOSNUM2[INCLHED];
LNUM_FILE:LNUM[INCLHED];
SOSNUM_FILE:SOSNUM[INCLHED];
PGNUM_FILE:PGNUM[INCLHED];
THISMAC_FILE:MACSAV[INCLHED];
INCLST_FILE:INCLSAV[INCLHED];
CFLN_FILE:CFLN[INCLHED];
EOF_0; ERRPG_-1;
RPSRC_FILE:OLDSRC[INCLHED];
INCLHED_FILE:NEXTI[INCLHED]
END "UNINCLUED";

SIMPLE PROCEDURE FINDINCLUDE;
BEGIN
 IF INCLST=NULL!RECORD THEN BEGIN UNINCLUDE; RETURN END;
 NOXSYM_TRUE;
 WHILE TRUE DO BEGIN
  CURSTR_INPUT(CH!IN,B!LIN);
  IF EOF neq 0 THEN DONE;
  IF ISCAN=S!SYM and EQU(ACCUM,"BEGIN") and ISCAN=S!SYM THEN BEGIN
   RPTEMP2_NULL!RECORD; RPTEMP_INCLST;
   WHILE RPTEMP neq NULL!RECORD DO IF EQU(ACCUM,SYMBOL:NAME[RPTEMP]) THEN BEGIN
    CURINCL_RPTEMP; IF RPTEMP2=NULL!RECORD THEN INCLST_SYMBOL:NEXT[RPTEMP]
	ELSE SYMBOL:NEXT[RPTEMP2]_SYMBOL:NEXT[RPTEMP];
    NOXSYM_FALSE; CURSTR_NULL; RETURN END
    ELSE RPTEMP_SYMBOL:NEXT[RPTEMP2_RPTEMP] END
  END; NOXSYM_FALSE; UNINCLUDE
END "FINDINCLUDE";


SIMPLE STRING PROCEDURE INSEXT (STRING NAME,EXT);
BEGIN STRING RSTRING;
RSTRING_NULL;
WHILE NULL neq NAME neq "[" DO RSTRING_RSTRING&LOP(NAME);
RETURN (RSTRING&"."&EXT&NAME);
END "INSEXT";

SIMPLE STRING PROCEDURE GETNAM (STRING ST);
BEGIN STRING FST;
IF ST="(" THEN WHILE (FST_LOP(ST)) neq ")" DO;
FST_NULL;
WHILE LENGTH(ST) neq 0 and ("[" neq ST neq ".") DO
FST_FST&LOP(ST);
RETURN (FST) END "GETNAM";

SIMPLE STRING PROCEDURE NXTSRC;
BEGIN
STRING SWT;
SWT_NULL;
IF INCLHED neq NULL!RECORD THEN BEGIN UNINCLUDE; RETURN(NULL) END;
IF LSTRMB and  not PASS1 THEN DO BEGIN RPTEMP_RPHSAV;
	RPHSAV_FILE:NEXT[RPTEMP] END UNTIL FILE:USE[RPTEMP] ELSE
IF CBCHR neq "," or (RPTEMP_FILNAM(SWT))=NULL!RECORD THEN BEGIN
	EOFERR ("UNEXPECTED END OF FILE"); RETURN("") END;
IF CH!IN<0 THEN CH!IN_GETCHAN;
OPEN (CH!IN,FILE:DEV[RPTEMP],0,2,0,CNT,BCHR,EOF);
SETPL (CH!IN,LNUM,PGNUM,SOSNUM);
SOSNUM2_LNUM_SOSNUM_0; PGNUM_1; ERRPG_-1;
LOOKUP (CH!IN,FILE:NAME[RPTEMP],EOF);
RPSRC_RPTEMP; CFLNT_CFLN_CFLNT+1;
IF  not LSTRMB or PASS1 THEN BEGIN
 IF CFLN neq 0 and RPGSW
	THEN OUTSTR("  "&GETNAM(FILE:NAME[RPTEMP])&'15&'12);
IF (RPTEMP2_RPHEAD)=NULL!RECORD THEN RPHEAD_RPTEMP ELSE BEGIN
	WHILE FILE:NEXT[RPTEMP2] neq NULL!RECORD DO RPTEMP2_FILE:NEXT[RPTEMP2];
	FILE:NEXT[RPTEMP2]_RPTEMP END END;
IF EOF=0 THEN RETURN(SWT);
IF LENGTH(FILE:EXT[RPTEMP])=0 THEN
LOOKUP (CH!IN,INSEXT(FILE:NAME[RPTEMP],"MIC"),EOF);
IF EOF neq 0 THEN EOFERR ("CAN NOT FIND "&FILE:NAME[RPTEMP]);
RETURN (SWT)
END "NXTSRC";

INTEGER TODAY;
SIMPLE PROCEDURE GETDATE;
TODAY _ CALL(0,"DATE");
REQUIRE GETDATE INITIALIZATION;

SIMPLE STRING PROCEDURE HEAD1(REFERENCE RECORD!POINTER (FILE) RP1);
RETURN (TITLE&"   "
	&CVS(TODAY MOD 31+1)&"-"&MONTAB[(TODAY/31)MOD 12]&"-"
	&CVS(TODAY/(12*31)+1964)&"   "
	&GETNAM(FILE:NAME[RP1]) );

COMMENT THE SYMBOL TABLE SEARCH PROCEDURE;

SIMPLE RECORD!POINTER (SYMBOL) PROCEDURE FNDSYM (STRING SYM);
BEGIN INTEGER I,J;

COMMENT FIRST GENERATE THE HASH;
J_0;
FOR I_1 STEP 6 UNTIL LENGTH(SYM) DO
	J_(J ROT 15) XOR CVSIX(SYM[I FOR 6]);
CURHSH_J_(J LAND '377777777777) MOD 101;

COMMENT NOW SEARCH THE SYMBOL TABLE FOR THIS ENTRY;
RPTEMP_SYMTAB[J];
WHILE RPTEMP neq NULL!RECORD DO
	IF EQU(SYM,SYMBOL:NAME[RPTEMP]) THEN RETURN (RPTEMP)
	 ELSE RPTEMP_SYMBOL:NEXT[RPTEMP];

COMMENT COULD NOT FIND IT. ADD NEW ENTRY TO SYMBOL TABLE;

SYMBOL:NEXT[RPTEMP_NEW!RECORD(SYMBOL)]_SYMTAB[J];
SYMBOL:NAME[SYMTAB[J]_RPTEMP]_SYM; RETURN (RPTEMP);
END "FNDSYM";

SIMPLE PROCEDURE ERRST3(STRING S); BEGIN
IF LSTSW THEN OUT(CH!OUT,S&'15&'12);
IF  not LSTTTY THEN OUTSTR(S&'15&'12);
END "ERRST3";

SIMPLE PROCEDURE ERRST2(STRING S);
BEGIN ERRCNT_ERRCNT+1; ERRST3(S) END "ERRST2";

SIMPLE BOOLEAN PROCEDURE MEMSTR (STRING ST; INTEGER I);
BEGIN
WHILE LENGTH(ST) neq 0 DO IF I=LOP(ST) THEN RETURN (TRUE);
RETURN (FALSE);
END "MEMSTR";

SIMPLE STRING PROCEDURE HEAD;
BEGIN STRING ST; INTEGER I;
ST_IF CFLN=0 and PGNUM=1 and LPP2=1 THEN NULL ELSE '14;
ST_ST&HEAD1(RPSRC)&"   PAGE "&CVS(PGNUM);
IF LPP2 neq 1 THEN ST_ST&"-"&CVS(LPP2);
IF LENGTH(SUBTITLE) THEN ST_ST&'15&'12& SUBTITLE;
RETURN (ST&'15&'12&'15&'12) END "HEAD";

SIMPLE STRING PROCEDURE FAKSYM(REFERENCE RECORD!POINTER (SYMBOL) SYM);
BEGIN STRING S;
S_CVS(MEMORY[LOCATION(SYM),INTEGER]);
S_"000000"[1 FOR 6-LENGTH(S)]&S;
RETURN (6&S);
END "FAKSYM";


FORWARD SIMPLE PROCEDURE NEWLIN;
SIMPLE BOOLEAN PROCEDURE NXTFOR (REFERENCE RECORD!POINTER (FORHDR) FORHD;
	BOOLEAN FIRST;
	REFERENCE RECORD!POINTER(MACARG) AARGS;
	REFERENCE RECORD!POINTER (MACTXT) TXT);
BEGIN STRING VALUE,VAL2;
RPTEMP_NULL!RECORD;
CASE FORHDR:TYP[FORHD] OF BEGIN
[FOR!CHR] BEGIN
   IF LENGTH(MACTXT:TXT[RPTEMP2_FORHDR:ARGSTR[FORHD]]) neq 0 THEN
	VALUE_LOP(MACTXT:TXT[RPTEMP2]) ELSE
   CASE MACTXT:TYP[RPTEMP2] OF BEGIN
	[MT!FIN] RETURN(FALSE);
	[MT!LINE] BEGIN
	   RPTEMP_RPTEMP2; RPTEMP2_MACTXT:NEXT[RPTEMP2];
	   RPTEMP3_NEW!RECORD(MACTXT);
	   MACTXT:TYP[MACTXT:NEXT[RPTEMP]_RPTEMP3]
		_MT!FIN END END END;
[FOR!WORD] BEGIN INTEGER PCNT,BPC;
   IF LENGTH(MACTXT:TXT[RPTEMP2_FORHDR:ARGSTR[FORHD]])=0 and 
	MACTXT:TYP[RPTEMP2]=MT!FIN THEN RETURN(FALSE);
   PCNT_0; VALUE_NULL;
   WHILE TRUE DO BEGIN
	IF LENGTH(MACTXT:TXT[RPTEMP2]) neq 0 THEN BEGIN
	   VALUE_VALUE&(BPC_LOP(MACTXT:TXT[RPTEMP2]));
	   IF BPC="," and PCNT leq 0 THEN BEGIN
		VALUE_VALUE[1 TO INF-1]; DONE END;
	   IF BPC="<" THEN PCNT_PCNT+1 ELSE IF BPC=">" THEN
		PCNT_PCNT-1 END ELSE
	CASE MACTXT:TYP[RPTEMP2] OF BEGIN
	[MT!FIN] DONE;
	[MT!LINE] BEGIN
	   MACTXT:TXT[RPTEMP4_NEW!RECORD(MACTXT)]_VALUE;
	   VALUE_NULL; MACTXT:TYP[RPTEMP4]_MT!LINE;
	   IF RPTEMP=NULL!RECORD THEN RPTEMP3_RPTEMP_RPTEMP4 ELSE
		MACTXT:NEXT[RPTEMP3]_RPTEMP4;
	   FORHDR:ARGSTR[FORHD]_RPTEMP2_MACTXT:NEXT[RPTEMP2] END
	END
   END;
   IF RPTEMP neq NULL!RECORD THEN BEGIN
	RPTEMP4_NEW!RECORD(MACTXT);
	MACTXT:TXT[MACTXT:NEXT[RPTEMP3]_RPTEMP4]_VALUE;
	MACTXT:TYP[RPTEMP4]_MT!FIN END END;
[FOR!ARITH] BEGIN
   IF (FORHDR:CNT2[FORHD]-FORHDR:CNT1[FORHD])*FORHDR:CNT3[FORHD]
	<0 THEN RETURN(FALSE);
   VALUE_CVS(FORHDR:CNT1[FORHD]);
   FORHDR:CNT1[FORHD]_FORHDR:CNT1[FORHD]+FORHDR:CNT3[FORHD] END
END;
IF RPTEMP=NULL!RECORD THEN BEGIN
   MACTXT:TYP[RPTEMP_NEW!RECORD(MACTXT)]_MT!FIN;
   MACTXT:TXT[RPTEMP]_VALUE END;
IF RPTEMP2=NULL!RECORD THEN RPTEMP2_RPTEMP;
MACARG:ARGTXT[AARGS_NEW!RECORD(MACARG)]_RPTEMP;
RPTEMP3_NEW!RECORD(MACARG);
MACARG:ARGTXT[MACARG:NEXT[AARGS]_RPTEMP3]_RPTEMP2;
RPTEMP2_FORHDR:TEXT[FORHD];
IF  not FIRST THEN BEGIN
  MACTXT:TXT[RPTEMP_NEW!RECORD(MACTXT)]_'12;
  MACTXT:NEXT[RPTEMP]_RPTEMP2;
  MACTXT:TYP[RPTEMP2_RPTEMP]_MT!LINE END;
TXT_RPTEMP2; RETURN(TRUE) END "NXTFOR";

RECORD!POINTER (CURMAC) CURP;
SIMPLE PROCEDURE STARTMAC(RECORD!POINTER (MACARG)AARGS;
	RECORD!POINTER (MACTXT) TTEXT; INTEGER TYPE;
	RECORD!POINTER (FORHDR) FORTXT);
BEGIN STRING ATM,ATM1,ATME,ATMC;
CURMAC:CURTXT[CURP_NEW!RECORD(CURMAC)]_TTEXT;
CURMAC:CURARG[CURP]_AARGS;
CURMAC:ORGTXT[CURP]_FORTXT;
CURMAC:TYPE[CURP]_TYPE;

CURMAC:OLDSTR[CURP]_CURSTR;
IF MACLSTU THEN BEGIN
 CURMAC:OLDLST[CURP]_LSTSTR[INF-LENGTH(CURSTR)+1 TO INF];
 ATM_LSTSTR[1 FOR INF-LENGTH(CURSTR)] END ELSE ATM_LSTSTR;
ATM1_CRFSTR; ATME_ERRSTR; ATMC_CODSTR;
CODSTR_CRFSTR_LSTSTR_NULL;
CURMAC:OLD[CURP]_THISMAC;
THISMAC_CURP;
NEWLIN;
CRFSTR_ATM1; ERRSTR_ATME; CODSTR_ATMC;
LSTSTR_ATM&(IF MACLSTU THEN "^" ELSE NULL)&LSTSTR;
END "STARTMAC";


RECORD!POINTER (ANY!CLASS) RPTEMP5;
SIMPLE PROCEDURE EXPANDMACRO;
BEGIN
DEFINE NEWMAC=<RPTEMP>,MAA=<RPTEMP2>,MTP2=<RPTEMP3>,MTP=<RPTEMP5>;
COMMENT NEWMAC REALLY (CURMAC), MAA (MACARG), MTP AND MTP2 (MACTXT);
STRING S1,S2;
INTEGER I;

MTP_CURMAC:CURTXT[THISMAC];
CURSTR_NULL;
WHILE TRUE DO CASE MACTXT:TYP[MTP] OF BEGIN "EXPANDTYPE"

[MT!LINE] BEGIN CURMAC:CURTXT[THISMAC]_MACTXT:NEXT[MTP];
	CURSTR_CURSTR&MACTXT:TXT[MTP];
	IF MACLSTU THEN LSTSTR_CURSTR;
	RETURN END;
[MT!MORE] BEGIN CURSTR_CURSTR&MACTXT:TXT[MTP];
	MTP_MACTXT:NEXT[MTP] END;
[MT!ARG] BEGIN MAA_CURMAC:CURARG[THISMAC];
	FOR I_2 STEP 1 UNTIL MACTXT:ARGNUM[MTP] DO
		MAA_MACARG:NEXT[MAA];
	MTP_MACTXT:NEXT[MTP];
	MTP2_MACARG:ARGTXT[MAA];
	IF MACTXT:TYP[MTP2]=MT!FIN THEN
		CURSTR_CURSTR&MACTXT:TXT[MTP2] ELSE
	BEGIN
	   NEWMAC_NEW!RECORD(CURMAC);
	   CURMAC:OLD[NEWMAC]_THISMAC;
	   CURMAC:CURTXT[THISMAC]_MTP;
	   THISMAC_NEWMAC;
	   CURMAC:CURTXT[THISMAC]_MTP_MTP2 END
	END;
[MT!FIN] BEGIN CURSTR_CURSTR&MACTXT:TXT[MTP];
	IF CURMAC:TYPE[THISMAC]=0 or  not 
	NXTFOR (CURMAC:ORGTXT[THISMAC],FALSE,CURMAC:CURARG[THISMAC],
	CURMAC:CURTXT[THISMAC]) THEN BEGIN
	S1_CURMAC:OLDSTR[THISMAC];
	S2_CURMAC:OLDLST[THISMAC];
	THISMAC_CURMAC:OLD[THISMAC];
	IF LENGTH (S1) neq 0 THEN BEGIN
	   IF MACLSTU THEN LSTSTR_CURSTR&"^"&S2; CURSTR_CURSTR&S1;
	   RETURN END END;
	MTP_CURMAC:CURTXT[THISMAC] END END "EXPANDTYPE"
END "EXPANDMACRO";
FORWARD SIMPLE STRING PROCEDURE CVHXD(INTEGER I);

SIMPLE STRING PROCEDURE CNVCOD(STRING CODE);
BEGIN STRING S; INTEGER I,K,J;
S_NULL;
IF CURRAD=16 THEN WHILE LENGTH(CODE) neq 0 DO
 S_S&(IF (I_LOP(CODE)) geq 16 THEN I ELSE CVHXD(I))
ELSE WHILE LENGTH(CODE) neq 0 DO BEGIN
 K_0;
 FOR J_0 STEP 1 WHILE LENGTH(CODE) neq 0 and CODE<16 DO
  IF J=4 THEN DONE ELSE K_K LSH 4+LOP(CODE);
 CASE J OF BEGIN
 [2] BEGIN GETFORMAT(I,J); SETFORMAT(-3,0); S_S&"   "&CVOS(K);
      SETFORMAT(I,J) END;
 [4] BEGIN GETFORMAT(I,J); SETFORMAT(-6,0); S_S&CVOS(K);
      SETFORMAT(I,J) END END;
 WHILE LENGTH(CODE) neq 0 and CODE geq 16 DO S_S&LOP(CODE)
END;
RETURN (S) END "CNVCOD" ;


SIMPLE PROCEDURE DMPLIN(BOOLEAN BLIST);
BEGIN STRING SAVSTR;
IF PASS1 THEN RETURN;
IF LSTSW or LENGTH(ERRSTR) neq 0 THEN BEGIN
 CODSTR_CNVCOD(CODSTR);
 IF LENGTH(ERRSTR) neq 0 and  not LSTTTY THEN BEGIN
  IF PGNUM neq ERRPG THEN BEGIN
   IF ERRPG<0 THEN OUTSTR(GETNAM(FILE:NAME[RPSRC])&"  ");
   OUTSTR ("PAGE "&CVS(PGNUM)&'15&'12) END; ERRPG_PGNUM END;
  SAVSTR_(IF LENGTH(ERRSTR)=0 THEN "  " ELSE ERRSTR&" ")&
   ((CODSTR[1 FOR 14]&"               ")[1 FOR 15])&" "&
   (IF  not BLIST THEN NULL ELSE (IF SOSNUM2 neq 0 THEN (IF SOSNUM neq 0 THEN CVASTR(SOSNUM)
    &'11 ELSE '11) ELSE NULL)&LSTSTR[1 FOR LENGTH(LSTSTR)-1])&'15&'12;
 DO BEGIN
  IF LSTSW THEN BEGIN
   IF LNUM=1 THEN BEGIN LNUM_2; LPP2_LPP_0 END;
   IF (LPP_LPPeq 0 THEN BEGIN LPP_LPPMAX; LPP2_LPP2+1;
    OUT(CH!OUT,HEAD) END;
   IF CRFSW THEN OUT(CH!OUT,IF  not BLIST THEN "      " ELSE
    '177&'102&CRFSTR&'177&'103); CRFSTR_NULL;
   OUT(CH!OUT,SAVSTR) END ELSE IF LENGTH(ERRSTR) neq 0 THEN OUTSTR(SAVSTR);
  CODSTR_(IF CURRAD=8 THEN "        " ELSE "      ")&CODSTR[15 TO ];
  SAVSTR_"  "&CODSTR[1 FOR 14]&'15&'12 END
 UNTIL LENGTH(CODSTR) leq (IF CURRAD=8 THEN 8 ELSE 6) END;
IF BLIST THEN BEGIN SOSNUM_0; LSTSTR_'12 END
END "DMPLIN";

FORWARD SIMPLE STRING PROCEDURE BRKSCN(REFERENCE STRING S);
SIMPLE PROCEDURE NEWLIN; BEGIN
IF LENGTH(LSTSTR) neq 0 THEN DMPLIN(TRUE);
CRFSTR_CODSTR_ERRSTR_NULL;
WHILE RUNNING DO BEGIN
IF THISMAC neq NULL!RECORD THEN EXPANDMACRO ELSE BEGIN
CURSTR_INPUT(CH!IN,B!LIN); MACLSTU_MACLST;
IF NSTLST or INCLHED=NULL!RECORD THEN LSTSTR_CURSTR END;
IF IFHDR neq NULL!RECORD THEN CURSTR_BRKSCN(CURSTR);
IF SOSNUM neq 0 THEN SOSNUM2_SOSNUM;
IF EOF neq 0 THEN NXTSRC ELSE DONE END;
END "NEWLIN";

SIMPLE PROCEDURE ERRSET(INTEGER I; STRING S); BEGIN
ERRCNT_ERRCNT+1;
ERRSTR_ERRSTR&S;
CASE I OF BEGIN
[0] CURSTR_NULL;
[1] CURSTR_EOL;
[2] END
END "ERRSET";

SIMPLE PROCEDURE EOLTST (INTEGER J);
BEGIN
IF J=S!EOL or (J=S!SPC and SCNVAL=";")
THEN CURSTR_NULL ELSE ERRSET (0,"Q") END "EOLTST";


SIMPLE STRING PROCEDURE BRKSCN(REFERENCE STRING STRNG);
BEGIN STRING VSTR; INTEGER BCH,VAL;
VSTR_NULL;
DO BEGIN
	VAL_IFH:PCNT[IFHDR];
	DO BEGIN
		VSTR_VSTR&SCAN(STRNG,B!IF,BCH);
		IF BCH="<" THEN VAL_VAL+1 ELSE
		 IF BCH=">" and (VAL_VAL-1)<0 THEN BCH_1;
		IF BCH neq NULL THEN VSTR_VSTR&BCH;
	END UNTIL VAL<0 or LENGTH(STRNG)=0;
	IF (IFH:PCNT[IFHDR]_VAL)<0 THEN IFHDR_IFH:OLD[IFHDR];
END UNTIL IFHDR=NULL!RECORD or LENGTH(STRNG)=0;
RETURN (VSTR&STRNG);
END "BRKSCN";

SIMPLE PROCEDURE CRFIT (INTEGER I;
	RECORD!POINTER (SYMBOL) SYM);
BEGIN STRING S; IF  not CRFSW or PASS1 THEN RETURN;
IF I neq 1 THEN CRFSTR_CRFSTR&I&LENGTH(S_SYMBOL:NAME[SYM])&S ELSE
CRFSTR_CRFSTR&I&FAKSYM(SYM);
END "CRFIT";

SIMPLE BOOLEAN PROCEDURE SIZCHK(INTEGER VALUE,SIZE);
IF 0 neq VALUE ASH -SIZE neq -1 THEN RETURN (TRUE) ELSE
RETURN (FALSE);

IFC FALSE THENC
SIMPLE PROCEDURE INCTRU(INTEGER CNT);
BEGIN INTEGER I;
CNT_(CNT*3.5)%10000;
WHILE CNT>0 DO BEGIN
  DOSOAK(I_CNT MIN SOKMAX);
   CNT_CNT-I END
END "INCTRU";
ELSEC DEFINE INCTRU(A)=<>;


FORWARD RECURSIVE INTEGER PROCEDURE EVLXPR(REFERENCE
	INTEGER I,J; REFERENCE RECORD!POINTER (SYMBOL,FIXUP) RP;
	INTEGER R);


COMMENT EVALUATE CONDITIONAL ASSEMBLY STUFF;

RECURSIVE PROCEDURE EVLIF;
BEGIN INTEGER VAL,OSCAN,VTY;
BOOLEAN STOP;
STRING STRN;
RECORD!POINTER (SYMBOL) SAVSYM;
RECORD!POINTER (SYMBOL,FIXUP) RP;
RECORD!POINTER (IFH) IFHP;

SAVSYM_CURSYM; COMMENT SAVE TO FIND TYPE;
SETBREAK (B!DEFINE,'12&"<",'1&'11&" ","ISN");
CASE SYMBOL:SUBTYP[SAVSYM] OF BEGIN
[0][1][2][3][4][5] BEGIN
   OSCAN_EVLXPR(VAL,VTY,RP,0);
   OSCAN_IF  not (S!EOL neq OSCAN neq S!SPC) THEN SCNVAL ELSE 0;
   IF RP neq NULL!RECORD THEN BEGIN ERRSET (1,"R"); RETURN END END;
[6][7] STRN_SCAN(CURSTR,B!DEFINE,OSCAN) END;
WHILE '12 neq OSCAN neq "<" DO 
	SCAN(CURSTR,B!DEFINE,OSCAN);
IF OSCAN='12 THEN BEGIN ERRSET (1,"Q"); RETURN END;
IFHP_NEW!RECORD(IFH);
IFH:OLD[IFHP]_IFHDR; IFHDR_IFHP;
STOP_FALSE;
CASE SYMBOL:SUBTYP[SAVSYM] OF BEGIN
[0] "IFE" IF VAL=0 THEN STOP_TRUE;
[1] "IFN" IF VAL neq 0 THEN STOP_TRUE;
[2] "IFGE" IF VAL geq 0 THEN STOP_TRUE;
[3] "IFG" IF VAL >0 THEN STOP_TRUE;
[4] "IFLE" IF VAL leq 0 THEN STOP_TRUE;
[5] "IFL" IF VAL <0 THEN STOP_TRUE;
[6] "IFB" IF LENGTH(STRN)=0 THEN STOP_TRUE;
[7] "IFNB" IF LENGTH(STRN) neq 0 THEN STOP_TRUE END;
IF STOP THEN BEGIN CURSTR_BRKSCN(CURSTR); RETURN END;
VAL_0; IFHDR_NULL!RECORD; COMMENT NEED TO SKIP THIS STUFF;
DO BEGIN IF LENGTH(CURSTR)=0 THEN NEWLIN;
SCAN(CURSTR,B!IF,OSCAN);
IF OSCAN="<" THEN VAL_VAL+1 ELSE IF OSCAN=">" THEN VAL_VAL-1;
END UNTIL VAL<0;
IFHDR_IFH:OLD[IFHP];
END "EVLIF";


FORWARD SIMPLE STRING PROCEDURE GETFIL(INTEGER I);
FORWARD RECORD!POINTER (MACTXT) PROCEDURE READMACROBODY(
	INTEGER ARGN; RECORD!POINTER (MACALIST) ARGLIST;
	INTEGER CATCR,OSCAN);

FORWARD RECURSIVE PROCEDURE EVLPRM(REFERENCE INTEGER VAL,VTY;
	REFERENCE RECORD!POINTER (SYMBOL,FIXUP) RP; INTEGER SV);

RECURSIVE PROCEDURE CALLMAC;
BEGIN
INTEGER NUMARGS,VAL,ARGBRK,PCNT,IN,IV,VTY;
RECORD!POINTER (MACARG) ARGTAIL,ARGSAV;
RECORD!POINTER (MACTXT) ATX,TXTSAV;
STRING ATM,ATM1;
RECORD!POINTER (FIXUP,SYMBOL) RP;
RECORD!POINTER(MACALIST) MTA,MTAO;
NUMARGS_MACDEF:ARGN[SYMBOL:FIXUP[CURSYM]];
MTAO_MACDEF:ARGS[SYMBOL:FIXUP[CURSYM]];
TXTSAV_MACDEF:TXT[SYMBOL:FIXUP[CURSYM]];
IF NUMARGS neq 0 THEN BEGIN "SCAN!ARGS"
ATM_SCAN(CURSTR,B!SPC,ARGBRK);
IF ARGBRK="(" THEN BEGIN ARGBRK_LOP(CURSTR); 
	WHILE CURSTR=1 DO ATM_LOP(CURSTR); PCNT_0 END ELSE
	PCNT_-1;
ARGSAV_ARGTAIL_NEW!RECORD(MACARG);
SETBREAK (B!MACARG,(IF ARGBRK="(" THEN "()" ELSE NULL)&
	";,"&'12,1,"ISN");
FOR IN_1 STEP 1 UNTIL NUMARGS DO BEGIN "SCAN!ARG2"
  MACARG:NEXT[ARGTAIL]_NEW!RECORD(MACARG);
  ARGTAIL_MACARG:NEXT[ARGTAIL];
   WHILE TRUE DO BEGIN "SCAN!ARG3"

	ATM_NULL;
   IF CURSTR="<" THEN BEGIN MACARG:ARGTXT[ARGTAIL]_
	ATX_READMACROBODY(0,NULL!RECORD,-1,-1);
	WHILE CURSTR=1 DO ATM_LOP(CURSTR); ARGBRK_LOP(CURSTR);
	IF ARGBRK=")" THEN PCNT_PCNT-1;
	DONE END ELSE
   IF CURSTR="\" THEN BEGIN "BACKSLASH"
	ATM_LOP(CURSTR); WHILE CURSTR=1 DO ATM_LOP(CURSTR);
	EVLPRM(VAL,VTY,RP,ISCAN);
	IF RP neq NULL!RECORD THEN ERRSET (2,"A");
	SCAN (CURSTR,B!SPC,ARGBRK);
	ARGBRK_LOP(CURSTR);
	WHILE CURSTR=1 DO ATM_LOP(CURSTR);
	IF ARGBRK=")" THEN PCNT_PCNT-1;
	ATM_CVS(VAL) END ELSE
   WHILE TRUE DO BEGIN "NORMAL!ARG"
	ATM_ATM&SCAN(CURSTR,B!MACARG,ARGBRK);
	IF ARGBRK="(" THEN BEGIN PCNT_PCNT+1; ATM_ATM&"(" END ELSE
	IF ARGBRK=")" THEN BEGIN IF (PCNT_PCNT-1)<0 THEN DONE
		ELSE ATM_ATM&")" END ELSE DONE END "NORMAL!ARG";
   MACARG:ARGTXT[ARGTAIL]_ATX_NEW!RECORD(MACTXT);
   MACTXT:TYP[ATX]_MT!FIN;
   MACTXT:TXT[ATX]_ATM; DONE END "SCAN!ARG3";
   IF ARGBRK=";" or ARGBRK='12 or (ARGBRK=")" and PCNT<0) THEN DONE;
   IF ARGBRK neq "," THEN ERRSET (2,"A");
   END "SCAN!ARG2";
FOR IV_IN+1 STEP 1 UNTIL NUMARGS DO BEGIN
   MACARG:NEXT[ARGTAIL]_NEW!RECORD(MACARG);
   ARGTAIL_MACARG:NEXT[ARGTAIL];
   MACARG:ARGTXT[ARGTAIL]_ATX_NEW!RECORD(MACTXT);
   MACTXT:TYP[ATX]_MT!FIN
   END;
IF ARGBRK=";" or ARGBRK='12 THEN CURSTR_ARGBRK&CURSTR;
ARGSAV_ARGTAIL_MACARG:NEXT[ARGSAV];
MTA_MTAO;
FOR IV_1 STEP 1 UNTIL NUMARGS DO BEGIN
   IF MACTXT:TYP[ATX_MACARG:ARGTXT[ARGTAIL]]=MT!FIN and 
	MACTXT:TXT[ATX]=NULL and 
	MACALIST:ARG[MTA]="%" THEN
	   MACTXT:TXT[ATX]_"GENSYM"&CVS(GENSYM_GENSYM+1);
   MTA_MACALIST:NEXT[MTA]; ARGTAIL_MACARG:NEXT[ARGTAIL] END;
END "SCAN!ARGS";

COMMENT NOW CALL THE MACRO;

STARTMAC(ARGSAV,TXTSAV,0,NULL!RECORD);
END "CALLMAC";

SIMPLE INTEGER PROCEDURE LINLOC;
RETURN((IF SOSNUM2=0 THEN LNUM ELSE
 CVD(CVASTR(SOSNUM2)))LSH 19+PGNUM LSH 7+CFLN);

SIMPLE STRING PROCEDURE LOCLIN(INTEGER J);
RETURN(CVS(J LSH -19)
	&"/"&CVS((J LSH -7) LAND '7777)&" IN "&
	GETFIL(J LAND '177));


COMMENT SCANNER. SCANS THE INPUT STRING IN CURSTR. IF
LENGTH(CURSTR) IS 0, NEWLIN WILL BE CALLED TO GET THE NEXT LINE OF
INPUT. SCAN DOES SEVERAL THINGS. SCAN RETURNS A TYPE AND
SETS SEVERAL GLOBAL VARIABLES

S!EOL	END OF LINE
S!SYM	SYMBOL. RECORD POINTER IN CURSYM
S!NUM	NUMBER. VALUE IN SCNVAL
S!SPC	SPECAIL CHARACTER (OR STRING LINE 'AND'.) CHR IN SCNVAL
	 SCNCOD IS SPECIAL CHARACTER CODE FROM THE TABLE CHRTAB
	 OR FROM SYMBOL:SUBTYP IN CASE OF A SYMBOL
;

RECURSIVE INTEGER PROCEDURE ISCAN; BEGIN
IFC SAISCN THENC
STRING THSSTR; INTEGER BCHR,ECM,I;

WHILE TRUE DO BEGIN "MSCAN"
IF LENGTH(CURSTR)=0 THEN NEWLIN;
THSSTR_SCAN(CURSTR,B!SPC,BCHR); COMMENT SKIP LEADING SPACES;
CASE (I_CHRTAB[CURSTR]) OF BEGIN
[C!EOL] BEGIN CURSTR_NULL; RETURN(S!EOL) END;
[C!LET] BEGIN "SYMBOLS"

COMMENT A SYMBOL;
THSSTR_SCAN(CURSTR,B!SYM,BCHR);
IF NOXSYM THEN BEGIN ACCUM_THSSTR; RETURN(S!SYM) END;
CURSYM_FNDSYM(THSSTR);
IF NOXMAC THEN RETURN (S!SYM);
CASE SYMBOL:TYP[CURSYM] OF BEGIN "SYMBOLS2"
	[0] BEGIN SYMBOL:TYP[CURSYM]_T!SYM; SYMBOL:VALUE[CURSYM]_LINLOC;
	   SYMBOL:SUBTYP[CURSYM]_V!UND; CRFIT(1,CURSYM);
	   RETURN (S!SYM) END;
[T!OPC][T!PSD] BEGIN CRFIT(3,CURSYM); RETURN (S!SYM) END;
[T!MAC] BEGIN CRFIT(5,CURSYM); CALLMAC END;
[T!SMAC] BEGIN CRFIT(3,CURSYM); EVLIF END;
[T!SYM] BEGIN IF SYMBOL:SUBTYP[CURSYM] LAND V!ORGS=0 THEN
	CRFIT(1,CURSYM);
	SYMBOL:SUBTYP[CURSYM]_SYMBOL:SUBTYP[CURSYM] LOR V!USE;
	RETURN (S!SYM) END;
[T!SPC] BEGIN SCNCOD_SYMBOL:SUBTYP[CURSYM]; SCNVAL_0; RETURN (S!SPC) END
END "SYMBOLS2" END "SYMBOLS";

COMMENT NOW NUMBERS;

[C!AT][C!DOL][C!PRC][C!DIG] BEGIN "NUMBER"
ECM_IF I=C!AT THEN 8 ELSE IF I=C!PRC THEN 2 ELSE IF I=C!DOL
	THEN 16 ELSE 0;
IF ECM neq 0 THEN DO I_LOP(CURSTR) UNTIL CURSTR neq 1;
THSSTR_SCAN(CURSTR,B!NUM,BCHR);
IF ECM=0 THEN BEGIN
ECM_IF BCHR="O" or BCHR="Q" THEN 8 ELSE IF BCHR="H" THEN 16
	ELSE 10; COMMENT SET RADIX;
IF ECM neq 10 THEN I_LOP(CURSTR) ELSE IF THSSTR[INF FOR 1]="B"
	THEN BEGIN ECM_2; THSSTR_THSSTR[1 TO INF-1] END END;
SCNVAL_0;
WHILE (I_LOP(THSSTR)) neq NULL DO 
	IF (I_IF I geq "A" THEN I-"A"+10 ELSE I-"0") geq ECM
	THEN BEGIN ERRSET(2,"N"); DONE END ELSE
	SCNVAL_SCNVAL*ECM+I;
RETURN (S!NUM) END "NUMBER";
[C!XOR][C!OR][C!AND][C!PLS][C!MIN][C!MLT][C!DIV][C!MOD][C!SHR]
[C!SHL][C!NOT][C!SNG][C!LPR][C!DOT][C!NEG][0] BEGIN "SPCHR"
SCNCOD_CHRTAB[SCNVAL_LOP(CURSTR)]; RETURN (S!SPC);
END "SPCHR" END;
END "MSCAN";
ELSEC

START!CODE
DEFINE P='17,SP='16,PTR='3,CNT='2,CHR='4,TBL='5,SCNT='6,
 SPTR='7,RADIX='6,VAL='7,FDIG='200000,FLOW='100000,
 FPREDG='040000,FCONTD='020000,DMOVE='120000000000;
LABEL LBL0,LBL1,LBL2,LETNUM,IDLP,IDLPC,LWRCAS,FIN,PREDIG,
 BADNUM,RTNSYM,SYMDEF,TBLSYM,SYMOP,SYMSYM,SYMSPC,SYMMAC,
 SYMSMC,FIN1,SYMDF1,SYMDF2,RTNSM1,
 NUMDON,DIGLP,NUMDN2,DIGIT,DIGT2,DIGT1;

LBL0:	MOVEI CNT,CURSTR;
	HRRZ CNT,-1(CNT);
	JUMPN CNT,LBL1;
	PUSHJ P,NEWLIN;
	JRST LBL0;
LBL1:	MOVE PTR,CURSTR;
LBL2:	ILDB CHR,PTR;
	SKIPN TBL,CHRTAB[0](CHR);
	SOJA CNT,LBL2;
	JUMPL TBL,LETNUM;
	TLNE TBL,FPREDG;
	SOJA CNT,PREDIG;
	MOVEM TBL,SCNCOD;
	MOVEM CHR,SCNVAL;
	MOVEI 1,S!SPC;
	CAIE TBL,C!EOL;
	SOJA CNT,FIN;
	MOVEI CNT,0;
	MOVEI 1,S!EOL;
	JRST FIN;

DIGIT:	MOVE SPTR,PTR;
	ADD PTR,['070000000000];
DIGT1:	ILDB CHR,SPTR;
	SKIPL TBL,CHRTAB[0](CHR);
	JRST DIGT2;
	TLNE TBL,FCONTD;
	JRST DIGT1;
	TLNN TBL,FPREDG;
	JRST DIGT2;
PREDIG:	MOVE RADIX,TBL;
	MOVEI VAL,0;
DIGLP:	ILDB CHR,PTR;
	SKIPL TBL,CHRTAB[0](CHR);
	JRST NUMDON;
	TLNN TBL,FCONTD;
	JRST NUMDON;
	HRRZS TBL;
	CAIL TBL,(RADIX);
	JRST BADNUM;
	IMULI VAL,(RADIX);
	ADDI VAL,(TBL);
	SOJA CNT,DIGLP;

NUMDON:	MOVEM VAL,SCNVAL;
	SKIPGE RADIX;
	SOJA CNT,NUMDN2;
	ADD PTR,['070000000000];
	SKIPGE PTR;
	SUB PTR,['430000000001];
NUMDN2:	MOVEI 1,S!NUM;
	JRST FIN;

DIGT2:	ADD SPTR,['070000000000];
	SKIPGE SPTR;
	SUB SPTR,['430000000001];
	LDB CHR,SPTR;
	MOVE TBL,CHRTAB[0](CHR);
	TLNN TBL,FPREDG;
	MOVE TBL,INPRAD;
	JRST PREDIG;


LETNUM:	TLNE TBL,FDIG;
	JRST DIGIT;
	DMOVE SCNT,CNT;
IDLP:	TLNE TBL,FLOW;
	JRST LWRCAS;
IDLPC:	ILDB CHR,PTR;
	SKIPGE TBL,CHRTAB[0](CHR);
	SOJA CNT,IDLP;
	SUBI CNT,1;
	SUB SCNT,CNT;
	ADD PTR,['070000000000];
	SKIPGE PTR;
	SUB PTR,['430000000001];
	MOVEM PTR,CURSTR;
	MOVEI PTR,CURSTR;
	HRRM CNT,-1(PTR);
	HLL SCNT,-1(PTR);
	ADD SPTR,['070000000000];
	SKIPGE SPTR;
	SUB SPTR,['430000000001];
	SKIPE NOXSYM;
	JRST RTNSM1;
	PUSH SP,SCNT;
	PUSH SP,SPTR;
	PUSHJ P,FNDSYM;
	MOVEM 1,CURSYM;
	SKIPE NOXMAC;
	JRST RTNSYM;
	MOVE CNT,2(1);
	XCT TBLSYM(CNT);
TBLSYM:	JRST SYMDEF;
	JRST SYMOP;
	JRST SYMOP;
	JRST SYMSYM;
	JRST SYMSPC;
	JRST SYMMAC;
	JRST SYMSMC;
SYMSPC:	SETZM SCNVAL;
	MOVE CNT,3(1);
	MOVEM CNT,SCNCOD;
	MOVEI 1,S!SPC;
	JRST FIN1;

SYMOP:	PUSH P,[3];
	PUSH P,CURSYM;
	PUSHJ P,CRFIT;
RTNSYM:	MOVEI 1,S!SYM;
	JRST FIN1;
SYMMAC:	PUSH P,[5];
	PUSH P,CURSYM;
	PUSHJ P,CRFIT;
	PUSHJ P,CALLMAC;
	JRST LBL0;

RTNSM1:	MOVEI CNT,ACCUM;
	MOVEM SCNT,-1(CNT);
	MOVEM SPTR,ACCUM;
	JRST RTNSYM;

SYMSMC:	PUSH P,[3];
	PUSH P,CURSYM;
	PUSHJ P,CRFIT;
	PUSHJ P,EVLIF;
	JRST LBL0;

SYMSYM:	MOVEI CNT,V!USE;
	IORB CNT,3(1);
	TRNE CNT,V!ORGS;
	JRST RTNSYM;
	PUSH P,[1];
	PUSH P,CURSYM;
	PUSHJ P,CRFIT;
	JRST RTNSYM;

SYMDEF:	MOVEI CNT,T!SYM;
	MOVEM CNT,2(1);
	MOVEI CNT,V!UND;
	MOVEM CNT,3(1);
	SKIPE CNT,SOSNUM2;
	JRST SYMDF1;
	SKIPLE 1,LNUM;
	SUBI 1,1;
	JRST SYMDF2;
SYMDF1:	PUSH P,CNT;
	PUSHJ P,CVASTR;
	PUSHJ P,CVD;
SYMDF2:	LSH 1,19;
	MOVE 2,PGNUM;
	LSH 2,7;
	ADD 1,2;
	ADD 1,CFLN;
	MOVE 2,CURSYM;
	MOVEM 1,4(2);
	JRST RTNSYM;

BADNUM:	PUSH P,[2];
	PUSH SP,[1];
	PUSH SP,["A"];
	PUSHJ P,ERRSET;
	JRST NUMDN2;
LWRCAS:	SUBI CHR,'40;
	DPB CHR,PTR;
	JRST IDLPC;

FIN:	MOVEM PTR,CURSTR;
	MOVEI PTR,CURSTR;
	HRRM CNT,-1(PTR);
FIN1:;
END;
ENDC
END "ISCAN";

STRING PROCEDURE REMLINE;
BEGIN INTEGER BCHR; STRING RSTR;
    COMMENT return the rest of the current line;
    SCAN(CURSTR,B!SPC,BCHR); 	COMMENT skip leading spaces;
    RSTR _ CURSTR[1 to inf-1];	COMMENT all but the CR;
    CURSTR _ CURSTR[inf for 1];	COMMENT just the CR;
    RETURN(RSTR);
END;

COMMENT EVALUATE A PIECE OF POLISH;
SIMPLE FORWARD PROCEDURE EMITBYTE (INTEGER I,J);
SIMPLE FORWARD PROCEDURE EMITWORD (INTEGER I,J);
SIMPLE FORWARD PROCEDURE EMITWORDF (INTEGER I,J);
SIMPLE FORWARD STRING PROCEDURE CVHX(INTEGER I,J);
FORWARD RECURSIVE PROCEDURE STORIT (INTEGER I,J; REFERENCE
	RECORD!POINTER (FIXUP) RF; REFERENCE 
	RECORD!POINTER (SYMBOL) RS; INTEGER R);
	
FORWARD RECURSIVE PROCEDURE UPDFIX(REFERENCE RECORD!POINTER(FIXUP) RP;
	REFERENCE RECORD!POINTER(FIXHED)RP2);

RECURSIVE INTEGER PROCEDURE VALPOL(RECORD!POINTER(FIXUP) RPF);
BEGIN
INTEGER TYP,V1,V2;
RECORD!POINTER(FIXUP) SPARE;
TYP_FIXUP:TYP[RPF];
V1_IF (SPARE_FIXUP:RPV1[RPF])=NULL!RECORD THEN
	FIXUP:VAL1[RPF] ELSE VALPOL(SPARE);
V2_IF (SPARE_FIXUP:RPV2[RPF])=NULL!RECORD THEN 
	FIXUP:VAL2[RPF] ELSE VALPOL(SPARE);

CASE TYP OF BEGIN
[C!XOR] V1_V1 XOR V2;
[C!OR] V1_V1 LOR V2;
[C!AND] V1_V1 LAND V2;
[C!PLS] V1_V1+V2;
[C!MIN] V1_V1-V2;
[C!MLT] V1_V1*V2;
[C!DIV] V1_V1/V2;
[C!MOD] V1_V1 MOD V2;
[C!SHR] V1_V1 LSH -V2;
[C!SHL] V1_V1 LSH V2;
[C!NOT] V1_LNOT V1;
[C!NEG] V1_(-V1) END;
RETURN (V1) END "VALPOL";

RECURSIVE PROCEDURE EVLPOL(INTEGER VAL; RECORD!POINTER(STORE)
	RST);
BEGIN
RECORD!POINTER (SYMBOL) NEWSYM; INTEGER TYP;
RECORD!POINTER (FIXUP) NEWFIX; RECORD!POINTER (FIXHED) NEWHED;

WHILE RST neq NULL!RECORD DO BEGIN
CASE STORE:TYP[RST] OF BEGIN
[ST!BYT] BEGIN EMITBYTE(STORE:VAL[RST],VAL);
	IF SIZCHK(VAL,8) THEN
	ERRST2 ('15&'12&"WORD IN BYTE FIELD FIXUP AT "
	   &LOCLIN(STORE:LOC[RST]));
	END;
[ST!WRD] BEGIN EMITWORD(STORE:VAL[RST],VAL);
	IF SIZCHK(VAL,16) THEN
	ERRST2 ('15&'12&"WORD FIXUP TOO BIG AT "
	   &LOCLIN(STORE:LOC[RST]));
	END;
[ST!SYM] BEGIN TYP_SYMBOL:SUBTYP[NEWSYM_STORE:FIXHED[RST]];
	STORIT (VAL,V!EQU,NULL!RECORD,NEWSYM,TYP LAND 1) END;
[ST!FX1] BEGIN FIXUP:VAL1[NEWFIX_STORE:FIXUP[RST]]_VAL;
	FIXUP:RPV1[NEWFIX]_NULL!RECORD;
	NEWHED_STORE:FIXHED[RST];
	TYP_FIXHED:COUNT[NEWHED]_
		FIXHED:COUNT[NEWHED]-1;
	IF TYP=0 THEN
	EVLPOL(VALPOL(FIXHED:FIXUP[NEWHED]),
		FIXHED:STORE[NEWHED]) END;
[ST!WRDF] BEGIN EMITWORDF(STORE:VAL[RST],VAL);
	IF SIZCHK(VAL,16) THEN
	ERRST2 ('15&'12&"WORD FIXUP TOO BIG AT"
	   &LOCLIN(STORE:LOC[RST]));
	END;
[ST!BYTR] BEGIN EMITBYTE(STORE:VAL[RST],VAL);
	IF SIZCHK(VAL,7) THEN
	ERRST2 ('15&'12&"WORD IN BYTE FIELD FIXUP AT "
	   &LOCLIN(STORE:LOC[RST]));
	END;
[ST!PAG] BEGIN EMITBYTE(STORE:VAL[RST],VAL);
	IF VAL LAND LNOT '377 neq 0 THEN
	ERRST2 ('15&'12&"WORD IN BYTE FIELD FIXUP AT "
	   &LOCLIN(STORE:LOC[RST]));
	END;


[ST!FX2] BEGIN FIXUP:VAL2[NEWFIX_STORE:FIXUP[RST]]_VAL;
	FIXUP:RPV2[NEWFIX]_NULL!RECORD;
	TYP_FIXHED:COUNT[NEWHED_STORE:FIXHED[RST]]_
		FIXHED:COUNT[NEWHED]-1;
	IF TYP=0 THEN
	EVLPOL(VALPOL(FIXHED:FIXUP[NEWHED]),
		FIXHED:STORE[NEWHED]) END;
[ST!DLT] END;
RST_STORE:NEXT[RST] END;
END "EVLPOL";

RECURSIVE PROCEDURE STORIT (INTEGER VAL,VTY; REFERENCE RECORD!POINTER
	(FIXUP) RPFQ; REFERENCE RECORD!POINTER (SYMBOL) SYM; INTEGER FLG);
BEGIN RECORD!POINTER (STORE) NEWSTR; INTEGER SYMSTY,SYMST2;
RECORD!POINTER (FIXUP,FIXHED) NEWFIX,RPF; RECORD!POINTER(FIXHED) NEWHED;

RPF_RPFQ;
IF  not (V!PST neq (SYMST2_(SYMSTY_SYMBOL:SUBTYP[SYM]) LAND V!MASK) neq V!PEQ) THEN BEGIN
	NEWSTR_FIXHED:STORE[SYMBOL:FIXUP[SYM]];
	WHILE NEWSTR neq NULL!RECORD DO BEGIN
		IF STORE:TYP[NEWSTR]=ST!SYM THEN STORE:TYP[NEWSTR]_ST!DLT;
		NEWSTR_STORE:NEXT[NEWSTR] END END;

IF RPF=NULL!RECORD THEN BEGIN
	IF SYMST2=V!UND and (NEWSTR_SYMBOL:FIXUP[SYM])
	 neq NULL!RECORD THEN EVLPOL(VAL,NEWSTR);
	VTY_IF VTY neq V!EQU THEN VTY ELSE IF FLG=0 THEN V!SET
		ELSE V!EQU END
ELSE BEGIN
	FIXHED:COUNT[NEWHED_NEW!RECORD(FIXHED)]_IF VAL=0 THEN
		1 ELSE VAL;
	IF VAL=0 THEN BEGIN
		FIXUP:RPV1[NEWFIX_NEW!RECORD(FIXUP)]_
		RPF; FIXUP:TYP[RPF_NEWFIX]_C!SNG;
		FIXUP:VAL1[NEWFIX]_FXV!SYM END;
	FIXHED:FIXUP[NEWHED]_RPF;
	UPDFIX(RPF,NEWHED);
	RPF_NEWHED;
	IF SYMST2=V!UND THEN BEGIN
		FIXHED:STORE[NEWHED]_NEWSTR_NEW!RECORD(STORE);
		STORE:NEXT[NEWSTR]_SYMBOL:FIXUP[SYM];
		STORE:TYP[NEWSTR]_ST!SYM;
		STORE:FIXHED[NEWSTR]_SYM END;
	VTY_IF FLG=0 THEN V!PST ELSE V!PEQ END;
SYMBOL:SUBTYP[SYM]_VTY LOR (SYMSTY LAND V!USE); SYMBOL:VALUE[SYM]_VAL;
SYMBOL:FIXUP[SYM]_RPF END "STORIT";


COMMENT GENERATE POLIST FIXUPS OF ONE OR TWO ARGUMENTS;

SIMPLE PROCEDURE UNYFIX(REFERENCE INTEGER VL; REFERENCE RECORD!POINTER
	(SYMBOL,FIXUP) RP;INTEGER FXNUM);
BEGIN

RPTEMP_NEW!RECORD(FIXUP);
FIXUP:TYP[RPTEMP]_FXNUM; COMMENT SET TYPE OF UNARY OP;
FIXUP:RPV1[RPTEMP]_RP;
IF VL neq 0 THEN FIXUP:VAL1[RPTEMP]_FXV!FXU ELSE
 FIXUP:VAL1[RPTEMP]_VL_FXV!SYM;

COMMENT SET COUNT OF UNDEF FIXUPS TO 1 IF UNDEF SYMBOL AND STORE;
RP_RPTEMP END "UNYFIX";

SIMPLE PROCEDURE DBLFIX(REFERENCE INTEGER VL; INTEGER VL2; REFERENCE
	RECORD!POINTER (SYMBOL,FIXUP) RP;
	RECORD!POINTER (SYMBOL,FIXUP) RP2; INTEGER FXNUM);
BEGIN
INTEGER TEMP;

RPTEMP_NEW!RECORD(FIXUP); FIXUP:TYP[RPTEMP]_FXNUM;

COMMENT THIS TIME DON'T KNOW IF VL IS A NUMBER
	OR A COUNT SO MUST LOOK AT RP. SAME FOR VL2 AND RP2;
TEMP_IF (FIXUP:RPV1[RPTEMP]_RP)=NULL!RECORD THEN
	VL ELSE (IF VL=0 THEN VL_FXV!SYM ELSE FXV!FXU);
FIXUP:VAL1[RPTEMP]_TEMP;
TEMP_IF (FIXUP:RPV2[RPTEMP]_RP2)=NULL!RECORD THEN
	VL2 ELSE (IF VL2=0 THEN VL2_FXV!SYM ELSE FXV!FXU);
FIXUP:VAL2[RPTEMP]_TEMP;
IF RP=NULL!RECORD THEN VL_0; IF RP2=NULL!RECORD THEN VL2_0;
VL_VL+VL2; RP_RPTEMP END "DBLFIX";

STRING PROCEDURE REDQT;
BEGIN STRING S; INTEGER I; S_NULL;
WHILE LENGTH(CURSTR) neq 0 DO
 IF (I_LOP(CURSTR))=1 THEN CONTINUE ELSE
 IF I neq "'" THEN S_S&(IF I="" THEN '15 ELSE IF I="" THEN '12 ELSE I) ELSE
 IF CURSTR="'" THEN S_S&LOP(CURSTR) ELSE RETURN(S);
ERRSET(0,"E"); RETURN(S) END "REDQT";



FORWARD RECURSIVE INTEGER PROCEDURE EVLOPC(BOOLEAN EVADR);

RECURSIVE INTEGER PROCEDURE EVLXPR(REFERENCE INTEGER VAL,VTY;
	REFERENCE RECORD!POINTER (SYMBOL,FIXUP) RP;
	INTEGER LEVEL);
BEGIN RECORD!POINTER (SYMBOL,FIXUP) RP2;
INTEGER VAL2,SCNCAS,CLEVL,CCOD;

COMMENT EVALUATE AN EXPRESSION;
IF LEVEL<-1 THEN BEGIN SCNCAS_-LEVEL-2; LEVEL_0 END
	ELSE SCNCAS_ISCAN;
IF LEVEL=-1 THEN IF SCNCAS=S!SYM and SYMBOL:TYP[CURSYM]=T!OPC
	THEN BEGIN RP_NULL!RECORD; VAL_EVLOPC(FALSE);
	VTY_V!EQU; RETURN(OSCAN!OP);
	END ELSE LEVEL_0;
EVLPRM(VAL,VTY,RP,SCNCAS); SCNCAS_ISCAN;
WHILE TRUE DO BEGIN
CASE SCNCAS OF BEGIN "CASEOUTER"
[S!SYM][S!NUM][S!EOL] RETURN (SCNCAS);
[S!SPC] CASE SCNCOD OF BEGIN "CASESPC"

[17][C!SNG][C!NOT][C!LPR] RETURN (SCNCAS);
[C!SHR][C!MOD][C!DIV][C!MLT][C!SHL] CLEVL_4;
[C!PLS][C!MIN] CLEVL_3;
[C!AND] CLEVL_2;
[C!OR][C!XOR] CLEVL_1 END "CASESPC" END "CASEOUTER";
IF CLEVL leq LEVEL THEN RETURN (SCNCAS);
CCOD_SCNCOD;	COMMENT SAVE IN A LOCAL VARIABLE;
SCNCAS_EVLXPR(VAL2,VTY,RP2,CLEVL);
VTY_V!EQU;	COMMENT CAN NOT BE SPECIAL SYMBOL IF OPERATOR;
IF RP=NULL!RECORD=RP2 THEN CASE CCOD OF BEGIN "DOITNOW"

[C!XOR] VAL_VAL XOR VAL2;
[C!OR] VAL_VAL LOR VAL2;
[C!AND] VAL_VAL LAND VAL2;
[C!MIN] VAL_VAL-VAL2;
[C!PLS] VAL_VAL+VAL2;
[C!MLT] VAL_VAL*VAL2;
[C!DIV] VAL_VAL/VAL2;
[C!MOD] VAL_VAL MOD VAL2;
[C!SHR] VAL_VAL LSH -VAL2;
[C!SHL] VAL_VAL LSH VAL2 END "DOITNOW"
	ELSE DBLFIX(VAL,VAL2,RP,RP2,CCOD) END;
END "EVLXPR";


COMMENT EVALUATE A PRIMARY EXPRESSION;

RECURSIVE PROCEDURE EVLPRM(REFERENCE INTEGER VAL,VTY;
	REFERENCE RECORD!POINTER (SYMBOL,FIXUP) RP; INTEGER SV);
BEGIN

RP_NULL!RECORD; VAL_0; VTY_V!EQU;
CASE SV OF BEGIN "PRIMSCAN"
[S!EOL] ERRSET(1,"O");
[S!NUM] VAL_SCNVAL;
[S!SYM] CASE SYMBOL:TYP[CURSYM] OF BEGIN "PRIMSYMBOL"

[T!OPC][T!PSD][0] ERRSET (1,"Q");
[T!SYM] CASE (V!PEQ+1) MIN
     (VTY_SYMBOL:SUBTYP[CURSYM] LAND V!MASK) OF BEGIN"SUBSYMBOL"
 [0][2][3][6]
	VAL_SYMBOL:VALUE[CURSYM];
 [V!UND][V!PST][V!PEQ] RP_CURSYM END "SYBSYMBOL" END"PRIMSYMBOL";
[S!SPC] CASE SCNCOD OF BEGIN "PRIMSPC"
 [C!DOT] VAL_ASMPC;
 [17][C!XOR][C!OR][C!AND][C!PLS][C!MLT][C!DIV][C!MOD]
	ERRSET(1,"E");
 [C!NOT] BEGIN EVLPRM(VAL,VTY,RP,ISCAN);
	VTY_V!EQU;
	IF RP=NULL!RECORD THEN VAL_LNOT VAL
	ELSE UNYFIX(VAL,RP,C!NOT) END;
 [C!MIN] BEGIN EVLPRM(VAL,VTY,RP,ISCAN);
	VTY_V!EQU;
	IF RP=NULL!RECORD THEN VAL_(-VAL)
	ELSE UNYFIX(VAL,RP,C!NEG) END;
[C!LPR] BEGIN SV_EVLXPR(VAL,VTY,RP,-1);
	IF SV neq S!SPC or ("}" neq SCNVAL neq ")") THEN ERRSET (2,"E");
	VTY_V!EQU END;
[C!SNG] BEGIN STRING S;
  IF  not (0<LENGTH(S_REDQT)<3) THEN ERRSET(1,"E");
  VAL_0; VTY_V!EQU;
  WHILE LENGTH(S)>0 DO VAL_VAL LSH 8+LOP(S) END
END "PRIMSPC" END "PRIMSCAN" END "EVLPRM";


COMMENT UPDATE THE FIXUP LIST FOR A FIXUP EXPRESSION;

COMMENT HAVE A POINTER TO A SYMBOL, ADD A STORE LIST ELEMENT;

SIMPLE PROCEDURE UPDFX2 (INTEGER CODE; RECORD!POINTER (SYMBOL) SYM;
	RECORD!POINTER (FIXUP) FIXPTR;
	RECORD!POINTER (FIXHED) FIXHPTR);
BEGIN
INTEGER TEMP;

RPTEMP_NEW!RECORD (STORE);
TEMP_IF CODE=1 THEN ST!FX1 ELSE ST!FX2; COMMENT WHICH ONE;
STORE:TYP[RPTEMP]_TEMP;
STORE:FIXHED[RPTEMP]_FIXHPTR;
STORE:FIXUP[RPTEMP]_FIXPTR;
IF (SYMBOL:SUBTYP[SYM] LAND V!MASK)=V!UND THEN BEGIN
STORE:NEXT[RPTEMP]_SYMBOL:FIXUP[SYM];
SYMBOL:FIXUP[SYM]_RPTEMP;
END ELSE BEGIN
STORE:NEXT[RPTEMP]_FIXHED:STORE[SYMBOL:FIXUP[SYM]];
FIXHED:STORE[SYMBOL:FIXUP[SYM]]_RPTEMP END;
END "UPDFX2";

COMMENT NOW THE RECURSIVE PROCEDURE FOR GOING DOWN THE FIXUP CHAIN;

RECURSIVE PROCEDURE UPDFIX (REFERENCE RECORD!POINTER (FIXUP) RP;
	REFERENCE RECORD!POINTER (FIXHED) HEAD);
BEGIN
RECORD!POINTER (FIXUP,SYMBOL) NEXTRP;

IF (NEXTRP_FIXUP:RPV1[RP]) neq NULL!RECORD THEN
	IF FIXUP:VAL1[RP]=FXV!FXU THEN UPDFIX(NEXTRP,HEAD)
	 ELSE UPDFX2(1,NEXTRP,RP,HEAD);
IF C!NEG neq FIXUP:TYP[RP] neq C!NOT and (NEXTRP_FIXUP:RPV2[RP])
 neq NULL!RECORD THEN
	IF FIXUP:VAL2[RP]=FXV!FXU THEN UPDFIX(NEXTRP,HEAD)
	 ELSE UPDFX2(2,NEXTRP,RP,HEAD);
END "UPDFIX";


COMMENT CODE EMITERS;

SIMPLE STRING PROCEDURE CVHXD(INTEGER I);
BEGIN RETURN (IF I>9 THEN "A"+I-10 ELSE "0"+I) END "CVHXD";

SIMPLE STRING PROCEDURE CVHXDD(INTEGER I);
BEGIN RETURN (CVHXD(((I LSH -4) LAND '17))&CVHXD(I LAND '17));
END "CVHXDD";

SIMPLE STRING PROCEDURE CVHX(INTEGER CNT,VAL);
BEGIN INTEGER I; STRING S;
S_NULL; FOR I_CNT STEP -1 UNTIL 1 DO
S_S&CVHXDD(VAL LSH -(8*(I-1))); RETURN (S);
END "CVHX";

SIMPLE PROCEDURE DMPBYT(INTEGER LOC);
BEGIN OWN INTEGER ORGLOC; INTEGER I,CKS;
IF BYTNUM neq 0 and RELSW and NOT PASS1 THEN BEGIN
OUT(CH!REL,":"&CVHXDD(BYTNUM)&CVHX(2,ORGLOC)&"00");
CKS_BYTNUM+ORGLOC+(ORGLOC LSH -8);
FOR I_1 STEP 1 UNTIL BYTNUM DO BEGIN
	OUT(CH!REL,CVHXDD(BYTARY[I])); CKS_CKS+BYTARY[I] END;
OUT (CH!REL,CVHXDD(((-CKS) LAND '377))&'15&'12) END;
BYTNUM_0; MSTLOC_ORGLOC_LOC END "DMPBYT";

SIMPLE PROCEDURE EMITBYTE (INTEGER LOC,BYTE);
BEGIN
IF LOC neq MSTLOC or BYTNUM=MAXBYT THEN DMPBYT(LOC);
BYTARY[BYTNUM_BYTNUM+1]_BYTE LAND '377;
MSTLOC_MSTLOC+1 END "EMITBYTE";

SIMPLE PROCEDURE EMITWORD (INTEGER LOC,WORD);
BEGIN
EMITBYTE(LOC,WORD); EMITBYTE (LOC+1,WORD LSH -8)
	END "EMITWORD";

SIMPLE PROCEDURE FINREL(INTEGER SA,LOW,HIGH);
BEGIN
IF RELSW THEN OUT(CH!REL,":02"&CVHX(2,LOW)&"03"&CVHX(2,HIGH-1)
	&'15&'12&":00"&CVHX(2,SA)&"00"&
	(IF SA<0 THEN "00" ELSE "01")&'15&'12&"$");
END "FINREL";

SIMPLE PROCEDURE EMITWORDF (INTEGER LOC,WORD);
BEGIN
EMITBYTE(LOC,WORD LSH -8); EMITBYTE (LOC+1,WORD)
	END "EMITWORD";


COMMENT GENERATE EIITHER A WORD OR BYTE AND POLISH LIST ELEMENTS;
SIMPLE PROCEDURE CODGEN (INTEGER VAL;
	 RECORD!POINTER (SYMBOL,FIXUP) RP; INTEGER PC,FLG);
COMMENT FLG IS ST!WRD FOR A WORD, ST!BYT FORR A BYTE;

BEGIN INTEGER NUTS;

IF RP neq NULL!RECORD THEN BEGIN "ADDRESSPOLISH"

RPTEMP3_NEW!RECORD(STORE);
STORE:TYP[RPTEMP3]_FLG; COMMENT 1 FOR BYTE 0 FOR WORD;
STORE:VAL[RPTEMP3]_PC; NUTS_LINLOC; STORE:LOC[RPTEMP3]_NUTS;
IF VAL=0 THEN IF (SYMBOL:SUBTYP[RP] LAND V!MASK)=V!UND THEN BEGIN "POLISH UNDEF"
STORE:NEXT[RPTEMP3]_SYMBOL:FIXUP[RP];
SYMBOL:FIXUP[RP]_RPTEMP3 END "POLISH UNDEF" ELSE
BEGIN "POLISH DEF" STORE:NEXT[RPTEMP3]_FIXHED:STORE[SYMBOL:FIXUP[RP]];
FIXHED:STORE[SYMBOL:FIXUP[RP]]_RPTEMP3 END "POLISH DEF" ELSE
BEGIN "POLISHPOLISH"
RPTEMP4_NEW!RECORD(FIXHED);
FIXHED:STORE[RPTEMP4]_RPTEMP3;
FIXHED:FIXUP[RPTEMP4]_RP;
FIXHED:COUNT[RPTEMP4]_VAL;
UPDFIX(RP,RPTEMP4);
END "POLISHPOLISH";
VAL_0 END "ADDRESSPOLISH";
CASE FLG OF BEGIN
[ST!WRD] BEGIN EMITWORD(PC,VAL); CODSTR_CODSTR&CVHDD(VAL LAND '377)
		&CVHDD(VAL LSH -8);
	IF SIZCHK(VAL,16) THEN
		ERRSET (2,"N") END;
[ST!BYT] BEGIN EMITBYTE(PC,VAL); CODSTR_CODSTR&CVHDD(VAL);
	IF SIZCHK(VAL,8) THEN
		ERRSET (2,"N") END;
[ST!WRDF] BEGIN EMITWORDF(PC,VAL); CODSTR_CODSTR&CVHDM(2,VAL);
	IF SIZCHK(VAL,16) THEN ERRSET (2,"N") END;
[ST!PAG] BEGIN EMITBYTE(PC,VAL); CODSTR_CODSTR&CVHDD(VAL);
	IF VAL LAND LNOT '377 neq 0 THEN ERRSET(2,"N") END;
[ST!BYTR] BEGIN EMITBYTE(PC,VAL); CODSTR_CODSTR&CVHDD(VAL);
	IF SIZCHK(VAL,7) THEN
		ERRSET (2,"N") END
END END "CODGEN";

SIMPLE BOOLEAN PROCEDURE LOOKX(INTEGER SCANVALUE);
RETURN (IF SCANVALUE=S!SYM and (SYMBOL:SUBTYP[CURSYM] LAND V!SP)
	 neq 0 THEN TRUE ELSE FALSE);


COMMENT EVALUATE AN OPCODE;

RECURSIVE INTEGER PROCEDURE EVLOPC (BOOLEAN EVADR);
BEGIN
INTEGER OPVAL,NEDADR,OSCAN,VAL,VTY,SHLV,FROM,TO;
BOOLEAN F1,F2;
RECORD!POINTER (SYMBOL,FIXUP) RP,RP2;
RECORD!POINTER (STORE) RPSTR;
RECORD!POINTER (FIXHED) RPFXD;
DEFINE ISBDHSP=<ISCAN=S!SYM and (SYMBOL:SUBTYP[CURSYM]
	LAND (V!H+V!SP+V!BD)) neq 0>;
DEFINE ISBD=<ISCAN=S!SYM and (SYMBOL:SUBTYP[CURSYM] LAND V!BD) neq 0>;
DEFINE ISBDSAVE=<(OSCAN_ISCAN)=S!SYM and (SYMBOL:SUBTYP[CURSYM]
	LAND V!BD) neq 0>;
DEFINE ISREG=<ISCAN=S!SYM and (SYMBOL:SUBTYP[CURSYM] LAND V!REG) neq 0>;
DEFINE ISBDHPSW=<ISCAN=S!SYM and (SYMBOL:SUBTYP[CURSYM]
	LAND (V!H+V!PSW+V!BD)) neq 0>;
DEFINE ISCOMA=<ISCAN=S!SPC and SCNVAL=",">;
DEFINE ND!NA=0,ND!WD=1,ND!CWD=2,ND!BYT=3,ND!CBYT=4;
DEFINE ND!IMDXI=5,ND!DXI=6,ND!XI=7,ND!IMDXIW=8,ND!REL=9;
DEFINE ND!BYT2=10,ND!WD2=11,ND!ZAI=12,ND!ZA=13,ND!OSC=14;
DEFINE ND!WDF=15,ND!RELPAG=16,ND!BYT3=17,ND!BYT4=18;
DEFINE ND!REL2=19,ND!BYT5=20,ND!WD3=21,ND!BYT2A=22;
DEFINE ND!PDP0=23,ND!PDP1=24,ND!PDP2=25;

COMMENT NEDADR TAKE ON THE VALUES
0	NO ADDRESS	(ND!NA)
1	ADDRESS (WORD)	(ND!WD)
2	COMMA ADDRESS (WORD)	(ND!CWD)
3	ARGUMENT (BYTE)	(ND!BYT)
4	COMMA ARGUMENT (BYTE)	(ND!CBYT)
;



SIMPLE INTEGER PROCEDURE CALLXI (INTEGER FLAG);
BEGIN
VAL_0; RP_NULL!RECORD;
IF  not LOOKX(OSCAN) and (OSCAN neq S!SPC or SCNVAL neq ",")
   and EVADR THEN OSCAN_EVLXPR(VAL,VTY,RP,-OSCAN-2);
IF (OSCAN=S!SPC and SCNVAL=",") or LOOKX(OSCAN) THEN BEGIN
   IF OSCAN=S!SPC and  not LOOKX(ISCAN) THEN ERRSET(1,"O");
   OSCAN_ISCAN;
   NEDADR_ND!BYT; RETURN(OPVAL LOR '40) END;
IF FLAG=0 or RP neq NULL!RECORD or  not (0 leq VAL<256) THEN BEGIN
   NEDADR_ND!IMDXIW; RETURN(OPVAL LOR '60) END;
NEDADR_ND!BYT; RETURN (OPVAL LOR '20)
END "CALLXI";

SIMPLE INTEGER PROCEDURE CALLDXI;
BEGIN
IF  not (OSCAN=S!SPC and SCNVAL="\") THEN
   RETURN (CALLXI(IF EVADR THEN 1 ELSE 0));
IF  not EVADR THEN OSCAN_ISCAN ELSE OSCAN_EVLXPR(VAL,VTY,RP,0);
NEDADR_ND!BYT; RETURN (OPVAL LOR '20)
END "CALLDXI";

SIMPLE INTEGER PROCEDURE ZEROABS;
BEGIN
IF OSCAN=S!SPC and SCNVAL="\" THEN BEGIN
   OSCAN_IF EVADR THEN EVLXPR(VAL,VTY,RP,0) ELSE ISCAN;
   NEDADR_ND!BYT2 END
ELSE BEGIN
   OSCAN_IF EVADR THEN EVLXPR(VAL,VTY,RP,-OSCAN-2) ELSE ISCAN;
   IF RP=NULL!RECORD and 0 leq VAL <256 and EVADR THEN NEDADR_ND!BYT2
   ELSE BEGIN NEDADR_ND!WD2; OPVAL_OPVAL+'10 END END;
RETURN (OPVAL);
END "ZEROABS";


SIMPLE INTEGER PROCEDURE CALLXZA(INTEGER INDEX);
BEGIN
OPVAL_ZEROABS;
IF OSCAN=S!SPC and SCNVAL="," THEN
   IF ISCAN=S!SYM and (SYMBOL:SUBTYP[CURSYM] LAND V!SP) neq 0
    and SYMBOL:VALUE[CURSYM] LAND INDEX neq 0 THEN
	BEGIN
	IF SYMBOL:VALUE[CURSYM]=INDEX THEN BEGIN
	   IF NEDADR=ND!WD2 THEN OPVAL_OPVAL+'14 ELSE
		OPVAL_OPVAL+'24; NEDADR_ND!WD2 END
	   ELSE OPVAL_OPVAL+'20;
	   OSCAN_ISCAN END
	ELSE ERRSET (1,"O");
RETURN (OPVAL)
END "CALLXZA";

SIMPLE INTEGER PROCEDURE CALLIXZA(INTEGER INDEX);
BEGIN
IF (OSCAN_ISCAN)=S!SPC and SCNVAL="#" THEN
   BEGIN OPVAL_OPVAL-4;
   OSCAN_IF EVADR THEN EVLXPR(VAL,VTY,RP,0) ELSE ISCAN;
   NEDADR_ND!BYT2 END
ELSE OPVAL_CALLXZA(INDEX);
RETURN(OPVAL)
END "CALLIXZA";

SIMPLE INTEGER PROCEDURE CALLZXA(INTEGER INDEX);
BEGIN
OSCAN_ISCAN;
OPVAL_ZEROABS;
IF OSCAN=S!SPC and SCNVAL="," THEN
   IF ISCAN=S!SYM and (SYMBOL:SUBTYP[CURSYM] LAND V!SP) neq 0
     and SYMBOL:VALUE[CURSYM] LAND INDEX neq 0 THEN
	BEGIN
	IF NEDADR=ND!WD2 THEN OPVAL_OPVAL+'10 ELSE OPVAL_OPVAL+'20;
	OSCAN_ISCAN;
	NEDADR_ND!BYT2 END
   ELSE ERRSET(1,"O");
RETURN(OPVAL)
END "CALLZXA";


COMMENT CODES RETURNED FROM Z80SCAN REPRESENT THE VARIOUS TYPES
   OF ARGUMENTS FOR THE Z80

 0:	A
 1:	(HL)
 2:	(IX+d) OR (IY+d)
 3:	n
 4:	B,C,D,E,H, OR L
 5:	HL
 6:	BC OR DE
 7:	(n)
 8:	IX OR IY
 9:	SP
10:	Z,NZ,NC,P,PO,PE,EQ,NE,GE, OR LT
11:	M
12:	I OR R
13:	(BC) OR (DE)
14:	AF
15:	(SP)
16:	(IX) OR (IY)
17:	(A)

;
SIMPLE INTEGER PROCEDURE Z80SCAN(INTEGER MAXVAL);
BEGIN INTEGER TYPE;
CASE OSCAN_ISCAN OF BEGIN
[S!EOL] RETURN (MAXVAL);
[S!NUM] BEGIN OSCAN_EVLXPR(VAL,VTY,RP,-S!NUM-2);
	RETURN (3 MIN MAXVAL) END;
[S!SYM] BEGIN VAL_SYMBOL:VALUE[CURSYM]; RP_NULL!RECORD;
 IF ((TYPE_SYMBOL:SUBTYP[CURSYM]) LAND V!REG) neq 0 THEN
  TYPE_IF VAL=7 THEN 0 ELSE IF VAL=6 THEN 11 ELSE 4
 ELSE IF (TYPE LAND V!Z80) neq 0 THEN TYPE_(TYPE LSH -9) LAND '77
 ELSE BEGIN OSCAN_EVLXPR(VAL,VTY,RP,-S!SYM-2);
	RETURN (3 MIN MAXVAL) END END;
[S!SPC] IF SCNVAL=";" or  not ("}" neq SCNVAL neq ")") THEN RETURN(MAXVAL)
 ELSE IF SCNVAL neq "(" THEN BEGIN
 OSCAN_EVLXPR(VAL,VTY,RP,-S!SPC-2); RETURN (3 MIN MAXVAL) END
 ELSE BEGIN CASE (TYPE_ISCAN) OF BEGIN
  [S!NUM][S!SPC] BEGIN OSCAN_EVLXPR(VAL,VTY,RP,-TYPE-2);
    TYPE_7 END;
  [S!EOL] RETURN (MAXVAL);
  [S!SYM] BEGIN VAL_SYMBOL:VALUE[CURSYM]; RP_NULL!RECORD;
   IF ((TYPE_SYMBOL:SUBTYP[CURSYM]) LAND V!Z80)=0 or 
     (TYPE_(TYPE LSH -9) LAND '77)>9 THEN BEGIN
	OSCAN_EVLXPR(VAL,VTY,RP,-S!SYM-2);
	TYPE_7 END
   ELSE BEGIN OSCAN_ISCAN; CASE TYPE OF BEGIN
    [0] TYPE_17;
    [1][2][3][4] RETURN(MAXVAL);
    [5] TYPE_1;
    [6] TYPE_13;
    [9] TYPE_15;
    [8] IF OSCAN neq S!SPC THEN RETURN (MAXVAL) ELSE IF
        SCNVAL=")" THEN BEGIN FROM_0; TYPE_16 END ELSE IF
        SCNVAL="+" THEN BEGIN OSCAN_EVLXPR(FROM,VTY,RP,0);
		TYPE_2 END ELSE IF
        SCNVAL="-" THEN BEGIN OSCAN_EVLXPR(FROM,VTY,RP,-S!SPC-2);
		TYPE_2 END ELSE RETURN(MAXVAL)
    END END END END;
   IF OSCAN neq S!SPC or SCNVAL neq ")" THEN RETURN (MAXVAL) END
END;
OSCAN_ISCAN; RETURN (MAXVAL MIN TYPE)
END "Z80SCAN";


SIMPLE PROCEDURE Z80CM1(INTEGER PRESCAN);
CASE PRESCAN OF BEGIN
[1][2][3][6][7][8][9][10][12] ERRSET (1,"O");
[4][11] BEGIN OPVAL_OPVAL+VAL; NEDADR_ND!OSC END;
[5] IF OSCAN neq S!SPC or SCNVAL neq "," THEN ERRSET (1,"O") ELSE
  CASE Z80SCAN(10) OF BEGIN
  [0][1][2][3][4][7][8][10] ERRSET (1,"O");
  [5][6][9] BEGIN VAL_((OPVAL LSH -18) LAND '377)+(VAL LSH 3);
    OPVAL_'355; NEDADR_ND!BYT2 END END;
[0] IF OSCAN neq S!SPC OR SCNVAL neq "," THEN BEGIN
   OPVAL_OPVAL+7; NEDADR_ND!OSC END ELSE
 BEGIN NEDADR_ND!OSC; CASE Z80SCAN(17) OF BEGIN
 [0][4] OPVAL_OPVAL+VAL;
 [1] OPVAL_OPVAL+6;
 [3] BEGIN OPVAL_OPVAL LSH -27; NEDADR_ND!BYT2A END;
 [2][16] BEGIN SHLV_VAL; VAL_(OPVAL LAND '377)+6; OPVAL_SHLV;
   NEDADR_ND!BYT3 END;
 [5][6][7][8][9][10][11][12][13][14][15][17] ERRSET (1,"O") END
 END
END;

SIMPLE INTEGER PROCEDURE PDP11SS2(REFERENCE INTEGER VAL,MODE,AC;
 REFERENCE RECORD!POINTER (SYMBOL,FIXUP) RP; REFERENCE BOOLEAN FLAG;
 INTEGER SCAND);
BEGIN INTEGER I; FLAG_FALSE;
COMMENT HANDLE MOST OF THE PDP-11 ADDRESSING MODE WORK;
IF SCAND=S!SYM and (SYMBOL:SUBTYP[CURSYM] LAND V!PSW) neq 0 THEN BEGIN
 AC_SYMBOL:VALUE[CURSYM]; MODE_0; RETURN(ISCAN) END
ELSE IF SCAND=S!SPC THEN
 IF SCNVAL="(" THEN BEGIN
  IF (SCAND_ISCAN)=S!SYM and (SYMBOL:SUBTYP[CURSYM] LAND V!PSW) neq 0 and 
   (SCAND_ISCAN)=S!SPC and SCNVAL=")" THEN BEGIN
    AC_SYMBOL:VALUE[CURSYM];
    IF (SCAND_ISCAN)=S!SPC and SCNVAL="+" THEN BEGIN MODE_2; SCAND_ISCAN
     END ELSE MODE_1
    END ELSE ERRSET(1,"O"); RETURN (SCAND)
  END ELSE
 IF SCNVAL="-" THEN BEGIN
  IF (SCAND_ISCAN)=S!SPC and SCNVAL="(" and (SCAND_ISCAN)=S!SYM and (SYMBOL:SUBTYP[
   CURSYM] LAND V!PSW) neq 0 and (SCAND_ISCAN)=S!SPC and SCNVAL=")" THEN BEGIN
    AC_SYMBOL:VALUE[CURSYM]; MODE_4; SCAND_ISCAN END ELSE ERRSET (1,"O");
  RETURN (SCAND) END ELSE
 IF SCNVAL="#" THEN BEGIN
  SCAND_EVLXPR(VAL,I,RP,0); FLAG_TRUE; AC_7; MODE_2; RETURN(SCAND) END;
IF (SCAND_EVLXPR(VAL,I,RP,-SCAND-2))=S!SPC and SCNVAL="(" THEN BEGIN
 IF (SCAND_ISCAN)=S!SYM and (SYMBOL:SUBTYP[CURSYM] LAND V!PSW) neq 0 and 
  (SCAND_ISCAN)=S!SPC and SCNVAL=")" THEN BEGIN AC_SYMBOL:VALUE[CURSYM];
   MODE_6; SCAND_ISCAN END ELSE ERRSET (1,"O") END ELSE
 BEGIN MODE_6; AC_7 END;
FLAG_TRUE; RETURN(SCAND)
END "PDP11SS2";


SIMPLE PROCEDURE Z80CM2(INTEGER PRESCAN,MAXCOND,TYPE,TYPE2);
BEGIN CASE PRESCAN MIN 12 OF BEGIN
[0][1][2][5][6][7][8][9][12] ERRSET (1,"O");
[3] BEGIN OPVAL_OPVAL ROT -18; NEDADR_TYPE; RETURN END;
[10] IF VAL>MAXCOND THEN ERRSET(1,"O") ELSE OPVAL_OPVAL+VAL;
[4] IF VAL neq 1 THEN ERRSET(1,"O") ELSE OPVAL_OPVAL+'30;
[11] IF MAXCOND<'70 THEN ERRSET(1,"O") ELSE OPVAL_OPVAL+'70 END;
IF OSCAN neq S!SPC OR SCNVAL neq "," THEN ERRSET(1,"O");
NEDADR_TYPE2
END "Z80CM2";

SIMPLE PROCEDURE Z80CM3(INTEGER FLAG);
CASE Z80SCAN(17) OF BEGIN
[0][4] BEGIN NEDADR_ND!BYT2; VAL_VAL+OPVAL; OPVAL_'313 END;
[1] BEGIN NEDADR_ND!BYT2; VAL_OPVAL+6; OPVAL_'313 END;
[2][16] BEGIN NEDADR_ND!BYT4; TO_OPVAL+6; OPVAL_VAL; VAL_'313 END;
[3][5][6][7][8][9][10][11][12][13][14][15][17]
   IF FLAG=0 THEN ERRSET (1,"O") ELSE NEDADR_ND!OSC END;

SIMPLE INTEGER PROCEDURE PDP11SS(REFERENCE INTEGER VAL,MODE;
 REFERENCE RECORD!POINTER (SYMBOL,FIXUP) RP; REFERENCE BOOLEAN FLAG);
BEGIN INTEGER I,SCAND;

IF (SCAND_ISCAN)=S!SPC and SCNVAL="@" THEN BEGIN
 SCAND_PDP11SS2(VAL,MODE,I,RP,FLAG,ISCAN);
 IF (MODE_MODE+1)=2 THEN ERRSET(1,"O") END
ELSE SCAND_PDP11SS2(VAL,MODE,I,RP,FLAG,SCAND);
MODE_MODE LSH 3+I; RETURN(SCAND) END "PDP11SS";


OPVAL_SYMBOL:VALUE[CURSYM];
NEDADR_ND!NA;
CASE (SHLV_SYMBOL:SUBTYP[CURSYM]) OF BEGIN "OPTYPE"

[0] NEDADR_ND!WD; COMMENT CALL OR JMP NEEDS ADDRESS;
[1] NEDADR_ND!BYT; COMMENT IN OUT CPI NEEDS BYTE;
[2] IF ISBDHSP THEN OPVAL_OPVAL+SYMBOL:VALUE[CURSYM] LSH 3
	ELSE ERRSET (1,"O"); COMMENT DAD,DCX,INX;
COMMENT [3] IS JUST DI,EI,RET ETC. NO ADDRESS;
[4] IF ISBDHSP THEN BEGIN NEDADR_ND!CWD;
	OPVAL_OPVAL+SYMBOL:VALUE[CURSYM] LSH 3 END
	ELSE ERRSET (1,"O"); COMMENT LXI;
[5] IF ISBD THEN OPVAL_OPVAL+SYMBOL:VALUE[CURSYM] LSH 3
	ELSE ERRSET(1,"O"); COMMENT LDAX, STAX;
[6] IF ISREG THEN OPVAL_OPVAL+SYMBOL:VALUE[CURSYM] LSH 3
	ELSE ERRSET (1,"O"); COMMENT INR,DCR;
[7] IF ISREG THEN BEGIN NEDADR_ND!CBYT;
	OPVAL_OPVAL+SYMBOL:VALUE[CURSYM] LSH 3 END
	ELSE ERRSET (1,"O"); COMMENT MVI;
[8] IF ISREG THEN BEGIN OPVAL_OPVAL+SYMBOL:VALUE[CURSYM] LSH 3;
	IF ISCOMA and ISREG THEN OPVAL_OPVAL+SYMBOL:VALUE[CURSYM]
		ELSE ERRSET (1,"O") END
	ELSE ERRSET (1,"O"); COMMENT MOV;
[9] IF ISREG  THEN OPVAL_OPVAL+SYMBOL:VALUE[CURSYM]
	ELSE ERRSET (1,"O"); COMMENT ADI,XRI;
[10] IF ISBDHPSW THEN OPVAL_OPVAL+SYMBOL:VALUE[CURSYM] LSH 3
	ELSE ERRSET (1,"O"); COMMENT PUSH, POP;
[33][11] BEGIN
	OSCAN_EVLXPR(VAL,VTY,RP,0); VTY_OPVAL LSH -18;
	IF SHLV=33 THEN BEGIN IF OSCAN neq 3 or SCNVAL neq "," THEN ERRSET(1,"O");
	  NEDADR_ND!REL END ELSE NEDADR_ND!OSC;
	SHLV_VTY LAND '7; FROM_(VTY LSH -3) LAND '77;
	TO_((VTY LSH -9) LAND '77)+FROM;
	IF RP=NULL!RECORD and FROM leq VAL leq TO THEN
	 OPVAL_(OPVAL LAND '700000777777)+(VAL LSH SHLV) ELSE ERRSET(1,"O") END;


[12] IF ISBD THEN BEGIN OPVAL_OPVAL+SYMBOL:VALUE[CURSYM] LSH 6;
	NEDADR_ND!IMDXI END ELSE ERRSET (1,"O");
[13] NEDADR_ND!IMDXI;
[14] IF ISBDSAVE THEN OPVAL_OPVAL+SYMBOL:VALUE[CURSYM] LSH 4
	ELSE NEDADR_ND!XI;
[15] NEDADR_ND!REL;
[16] BEGIN NEDADR_ND!XI; OSCAN_ISCAN END;
[17] IF ISBD THEN BEGIN OPVAL_OPVAL+SYMBOL:VALUE[CURSYM] LSH 6;
	OSCAN_ISCAN; NEDADR_ND!DXI END ELSE ERRSET (1,"O");
[18] BEGIN NEDADR_ND!DXI; OSCAN_ISCAN END;
[19] NEDADR_ND!IMDXIW;
[20] IF (OSCAN_ISCAN)=S!SPC and SCNVAL="#" THEN BEGIN
	OPVAL_OPVAL+'10;
	OSCAN_IF EVADR THEN EVLXPR(VAL,VTY,RP,0) ELSE ISCAN;
	NEDADR_ND!BYT2 END ELSE NEDADR_ND!ZAI;
[21] IF ISBDSAVE THEN OPVAL_OPVAL+4 ELSE NEDADR_ND!ZA;
[22] BEGIN OSCAN_ISCAN; OPVAL_ZEROABS END;
[23] IF (OSCAN_ISCAN)=S!SPC and SCNVAL="#" THEN BEGIN
	OPVAL_OPVAL-4;
	OSCAN_IF EVADR THEN EVLXPR(VAL,VTY,RP,0) ELSE ISCAN;
	NEDADR_ND!BYT2 END ELSE OPVAL_ZEROABS;
[24] BEGIN OSCAN_ISCAN; NEDADR_ND!ZA END;
[25] BEGIN NEDADR_ND!WD2;
	IF (OSCAN_ISCAN)=S!SPC and SCNVAL="(" THEN BEGIN
	   OSCAN_IF EVADR THEN EVLXPR(VAL,VTY,RP,0) ELSE ISCAN;
	   OPVAL_OPVAL+'40;
	   IF  not (OSCAN=S!SPC and SCNVAL=")") THEN ERRSET(1,"O");
	   OSCAN_ISCAN END
	ELSE IF EVADR THEN OSCAN_EVLXPR(VAL,VTY,RP,-OSCAN-2) END;
[26] OPVAL_CALLIXZA(2);
[27] OPVAL_CALLIXZA(1);
[28] BEGIN OSCAN_ISCAN; NEDADR_ND!ZAI END;
[29] OPVAL_CALLZXA(1);
[30] OPVAL_CALLZXA(2);
[31] IF ISCAN=S!SYM and (SYMBOL:SUBTYP[CURSYM] LAND (V!H+V!REG))=V!REG
	THEN OPVAL_OPVAL+SYMBOL:VALUE[CURSYM]
	LSH 3 ELSE ERRSET(1,"O");
[32] NEDADR_ND!WDF;
[34] BEGIN OSCAN_EVLXPR(VAL,VTY,RP,0); NEDADR_ND!OSC;
   TO_VTY LAND LNOT(V!ORGS+V!USE+V!REG);
   IF OSCAN neq 3 or SCNVAL neq "," or (TO neq 0 and (RP neq NULL!RECORD or VAL>11)) THEN
	ERRSET(1,"O");
   FROM_VAL; OSCAN_EVLXPR(VAL,VTY,RP,0); VTY_VTY LAND LNOT (V!ORGS+V!USE+V!REG);
   IF RP neq NULL!RECORD or (VTY neq 0 and (TO neq 0 or FROM neq 0)) THEN ERRSET(1,"O");
   WHILE TRUE DO BEGIN "FAKE1" WHILE TRUE DO BEGIN "FAKE2"
   CASE (IF TO=0 THEN FROM ELSE 12) OF BEGIN
   [16] IF VAL=4 THEN OPVAL_'35 ELSE DONE;
   [15] IF VAL=0 THEN OPVAL_'6 ELSE DONE;
   [12][13][14] IF VAL=0 THEN OPVAL_'120+FROM ELSE DONE;
   [11] IF VAL=0 THEN OPVAL_'7 ELSE DONE;
   [10] IF VAL=1 THEN OPVAL_'16 ELSE DONE;
   [9] IF VAL=10 THEN OPVAL_'15 ELSE DONE;
   [8] IF VAL=6 THEN OPVAL_'11 ELSE DONE;
   [7] IF VAL=0 THEN OPVAL_4 ELSE DONE;
   [6] IF VAL=8 THEN OPVAL_'10 ELSE DONE;
   [5] IF VAL=0 THEN OPVAL_5 ELSE DONE;
   [4] IF VAL=16 THEN OPVAL_'36 ELSE IF VAL=0 THEN OPVAL_'131 ELSE DONE;
   [3] IF VAL=0 THEN OPVAL_'13 ELSE DONE;
   [2] IF VAL=1 THEN OPVAL_'21 ELSE DONE;
   [1] IF VAL=10 THEN OPVAL_'17 ELSE IF VAL=2 THEN OPVAL_'20 ELSE DONE;
   [0] IF VTY neq 0 THEN IF VAL leq 11 THEN OPVAL_'100+VAL ELSE DONE ELSE
    CASE VAL OF BEGIN
    [0][1][2][6][8][9][10][16] DONE;
    [3] OPVAL_'12;
    [4] OPVAL_'111;
    [5] OPVAL_1;
    [7] OPVAL_0;
    [11] OPVAL_3;
    [15] OPVAL_2;
    [12][13][14] OPVAL_'100+VAL END END; DONE "FAKE1" END "FAKE2";
   ERRSET(1,"O"); DONE END "FAKE1" END;
[35] NEDADR_ND!RELPAG;


[36] "ADC,SBC" CASE SHLV_Z80SCAN(12) OF BEGIN
 [1] BEGIN OPVAL_OPVAL+6; NEDADR_ND!OSC END;
 [2][16] BEGIN SHLV_(OPVAL LAND '377)+6; OPVAL_VAL;
    VAL_SHLV; NEDADR_ND!BYT3 END;
 [3] BEGIN OPVAL_OPVAL LSH -27; NEDADR_ND!BYT2A END;
 ELSE Z80CM1(SHLV) END;
[37] "ADD" CASE (SHLV_Z80SCAN(12)) OF BEGIN
 [0][4][6][7][9][10][11][12] Z80CM1(SHLV);
 [1] BEGIN OPVAL_OPVAL+6; NEDADR_ND!OSC END;
 [2][16] BEGIN SHLV_(OPVAL LAND '377)+6; OPVAL_VAL;
    VAL_SHLV; NEDADR_ND!BYT3 END;
 [3] BEGIN OPVAL_OPVAL LSH -27; NEDADR_ND!BYT2A END;
 [5] IF OSCAN neq S!SPC or SCNVAL neq "," THEN ERRSET(1,"O") ELSE
  CASE Z80SCAN(10) OF BEGIN
  [0][1][2][3][4][7][8][10] ERRSET (1,"O");
  [5][6][9] BEGIN NEDADR_ND!OSC; OPVAL_(OPVAL LSH -18)+(VAL LSH 3)
	 END END;
 [8] BEGIN SHLV_VAL; OPVAL_(OPVAL LSH -18) LAND '377;
  IF OSCAN neq S!SPC or SCNVAL neq ","THEN ERRSET (1,"O") ELSE
  CASE Z80SCAN(10) OF BEGIN
  [0][1][2][3][4][7][5][10] ERRSET (1,"O");
  [8] IF VAL neq SHLV THEN ERRSET (1,"O") ELSE BEGIN
    VAL_OPVAL+'40; OPVAL_SHLV; NEDADR_ND!BYT2 END;
  [6][9] BEGIN VAL_(VAL LSH 3)+OPVAL; OPVAL_SHLV;
    NEDADR_ND!BYT2 END END END END;
[38] "AND,CMP,OR,SUB,XOR" CASE Z80SCAN(17) OF BEGIN
 [5][6][7][8][9][10][12][13][14][15][17] ERRSET (1,"O");
 [0][4][11] BEGIN OPVAL_OPVAL+VAL; NEDADR_ND!OSC END;
 [1] BEGIN OPVAL_OPVAL+6; NEDADR_ND!OSC END;
 [2][16] BEGIN SHLV_(OPVAL LAND '377)+6; OPVAL_VAL;
    VAL_SHLV; NEDADR_ND!BYT3 END;
 [3] BEGIN OPVAL_OPVAL LSH -27; NEDADR_ND!BYT2A END END;
[39] "SET,RES,BIT" IF (OSCAN_EVLXPR(VAL,VTY,RP,0)) neq S!SPC or SCNVAL neq "," or 
    RP neq NULL!RECORD or  not 0 leq VAL leq 7 THEN ERRSET (1,"O") ELSE
  BEGIN OPVAL_OPVAL+(VAL LSH 3);
   CASE Z80SCAN(17) OF BEGIN
   [5][3][6][7][8][9][10][11][12][13][14][15][17] ERRSET (1,"O");
   [0][4] BEGIN VAL_OPVAL+VAL; OPVAL_'313; NEDADR_ND!BYT2 END;
   [1] BEGIN VAL_OPVAL+6; OPVAL_'313; NEDADR_ND!BYT2 END;
   [2][16] BEGIN TO_OPVAL+6; OPVAL_VAL; VAL_'313; NEDADR_ND!BYT4 END END
  END;
[40] "CALL" Z80CM2(Z80SCAN(12),'70,ND!WD2,ND!WD);
[41] "CMPD,IM0, ETC."
     BEGIN VAL_OPVAL; OPVAL_'355; OSCAN_ISCAN; NEDADR_ND!BYT2 END;
[42] "DEC,INC" BEGIN NEDADR_ND!OSC; CASE Z80SCAN(17) OF BEGIN
  [0][4] OPVAL_OPVAL+(VAL LSH 3);
  [1] OPVAL_OPVAL+(6 LSH 3);
  [2][16] BEGIN VALOPVAL; VAL_(VAL+(6 LSH 3)) LAND '377;
	NEDADR_ND!BYT3 END;
  [8] BEGIN VALOPVAL; VAL_'40+(VAL LSH -18); NEDADR_ND!BYT2 END;
  [3][7][10][11][12][13][14][15][17] ERRSET (1,"O");
  [5][6][9] OPVAL_(OPVAL LSH -18)+(VAL LSH 3) END END;
[43] "EX" CASE Z80SCAN(16) OF BEGIN
 [14] IF OSCAN=S!SPC and SCNVAL="," and Z80SCAN(15)=14 and OSCAN=S!SPC and 
     SCNVAL="'" THEN OPVAL_8 ELSE ERRSET (1,"O");
 [6] IF VAL=2 and OSCAN=S!SPC and SCNVAL="," and Z80SCAN(6)=5 THEN
     BEGIN OPVAL_'353; NEDADR_ND!OSC END ELSE ERRSET (1,"O");
 [0][1][2][3][4][5][7][8][9][10][11][12][13][16] ERRSET (1,"O");
 [15] IF OSCAN neq S!SPC or SCNVAL neq "," THEN ERRSET (1,"O") ELSE
     CASE Z80SCAN(9) OF BEGIN
	[0][1][2][3][4][6][7][9] ERRSET (1,"O");
	[5] NEDADR_ND!OSC;
	[8] BEGIN OPVALVAL; NEDADR_ND!BYT2 END END
 END;


[44] "IN" CASE Z80SCAN(5) OF BEGIN
  [3] NEDADR_ND!BYT2A;
  [4] IF OSCAN neq S!SPC or SCNVAL neq "," THEN ERRSET(1,"O") ELSE BEGIN SHLV_VAL;
    IF Z80SCAN(18)=17 THEN BEGIN VAL_(OPVAL LSH -18)+(SHLV LSH 3);
     OPVAL_'355; NEDADR_ND!BYT2 END ELSE ERRSET (1,"O") END;
  [0] IF OSCAN neq S!SPC or SCNVAL neq "," THEN ERRSET(1,"O") ELSE
    CASE Z80SCAN(18) OF BEGIN
    [0][1][2][3][4][5][6][8][9][10][11][12][13][14][15][16][18]
	ERRSET (1,"O");
    [7] NEDADR_ND!BYT2A;
    [17] BEGIN NEDADR_ND!BYT2; VAL_(OPVAL LSH -18)+'70;
     OPVAL_'355 END END;
  [1][2][5] ERRSET (1,"O") END;
[45] "JMP" CASE (SHLV_Z80SCAN(17)) OF BEGIN
  [1] BEGIN OPVAL_'351; NEDADR_ND!OSC END;
  [16] BEGIN OPVAL_VAL; VAL_'351; NEDADR_ND!BYT2 END;
  [0][2][3][4][5][6][7][8][9][10][11][12][13][14][15][17]
	Z80CM2(SHLV,'70,ND!WD2,ND!WD) END;
[46] "JR" Z80CM2(Z80SCAN(12),'30,ND!REL2,ND!REL);
[47] BEGIN "LD" SHLV_Z80SCAN(17); TO_VAL; RP2_RP; NEDADR_ND!OSC;
  IF OSCAN neq S!SPC or SCNVAL neq "," THEN ERRSET(1,"O") ELSE
  CASE SHLV OF BEGIN
  [14][15][17] ERRSET(1,"O");
  [13] IF Z80SCAN(1) neq 0 THEN ERRSET(1,"O") ELSE OPVAL_2+(TO LSH 3);
  [1] CASE Z80SCAN(5) OF BEGIN
      [0][4] OPVAL_'160+VAL;
      [3] BEGIN OPVAL_'66; NEDADR_ND!BYT2A END;
      [1][2][5] ERRSET (1,"O") END;
  [2][16] CASE Z80SCAN(5) OF BEGIN
      [0][4] BEGIN OPVAL_TO; VAL_'160+VAL; NEDADR_ND!BYT3; RP_RP2 END;
      [3] BEGIN OPVAL_TO; TO_'66; NEDADR_ND!BYT5 END;
      [1][2][5] ERRSET (1,"O") END;
  [7] BEGIN CASE Z80SCAN(10) OF BEGIN
      [0] BEGIN NEDADR_ND!WD2; OPVAL_'62 END;
      [6][9] BEGIN NEDADR_ND!WD3; OPVAL_'355; FROM_'103+(VAL LSH 3)
	END;
      [5] BEGIN NEDADR_ND!WD2; OPVAL_'42 END;
      [8] BEGIN NEDADR_ND!WD3; OPVAL_VAL; FROM_'42 END;
      [1][2][3][4][7][10] ERRSET (1,"O") END;
      VAL_TO; RP_RP2 END;
  [0] CASE Z80SCAN(17) OF BEGIN
      [13] OPVAL_'12+(VAL LSH 3);
      [1] OPVAL_'176;
      [2][16] BEGIN OPVAL_VAL; VAL_'176; NEDADR_ND!BYT3 END;
      [7] BEGIN OPVAL_'72; NEDADR_ND!WD2 END;
      [0][4] OPVAL_'170+VAL;
      [12] BEGIN OPVAL_'355; NEDADR_ND!BYT2 END;
      [3] BEGIN OPVAL_'76; NEDADR_ND!BYT2A END;
      [5][6][8][9][10][11][14][15][17] ERRSET (1,"O") END;
  [4] BEGIN OPVAL_'100+(VAL LSH 3);
      CASE Z80SCAN(17) OF BEGIN
      [0][4] OPVAL_OPVAL+VAL;
      [1] OPVAL_OPVAL+6;
      [2][16] BEGIN OPVALVAL; VAL_VAL+6; NEDADR_ND!BYT3 END;
      [3] BEGIN OPVAL_OPVAL+(6-'100); NEDADR_ND!BYT2A END;
      [5][6][7][8][9][10][11][12][13][14][15][17] ERRSET (1,"O") END END;


  [6] CASE Z80SCAN(8) OF BEGIN
      [7] BEGIN OPVAL_'355; FROM_'113+(TO LSH 3); NEDADR_ND!WD3 END;
      [3] BEGIN OPVAL_1+(TO LSH 3); NEDADR_ND!WD2 END;
      [0][1][2][4][5][6][8] ERRSET (1,"O") END;
  [5] BEGIN NEDADR_ND!WD2; CASE Z80SCAN(8) OF BEGIN
      [3] OPVAL_'41;
      [7] OPVAL_'52;
      [0][1][2][4][5][6][8] ERRSET (1,"O") END END;
  [12] IF Z80SCAN(1) neq 0 THEN ERRSET (1,"O") ELSE BEGIN
      NEDADR_ND!BYT2; OPVAL_'355; VAL_TO-'20 END;
  [8] BEGIN OPVAL_VAL; NEDADR_ND!WD3; CASE Z80SCAN(8) OF BEGIN
      [3] FROM_'41;
      [7] FROM_'52;
      [0][1][2][4][5][6][8] ERRSET (1,"O") END END;
  [9] CASE Z80SCAN(9) OF BEGIN
      [0][1][2][4][6][9] ERRSET (1,"O");
      [7] BEGIN NEDADR_ND!WD3; OPVAL_'355; FROM_'173 END;
      [5] OPVAL_'371;
      [3] BEGIN NEDADR_ND!WD2; OPVAL_'61 END;
      [8] BEGIN OPVAL_VAL; VAL_'371; NEDADR_ND!BYT2 END END
  END END;
[48] "OUT" CASE Z80SCAN(18) OF BEGIN
  [3] NEDADR_ND!BYT2A;
  [17] IF OSCAN neq S!SPC or SCNVAL neq "," THEN ERRSET (1,"O") ELSE
   CASE Z80SCAN(5) OF BEGIN
   [0][4] BEGIN NEDADR_ND!BYT2; VAL_(OPVAL LSH -18)+(VAL LSH 3);
	OPVAL_'355 END;
   [1][2][3][5] ERRSET (1,"O") END;
  [7] BEGIN RP2_RP; FROM_VAL; IF OSCAN neq S!SPC or SCNVAL neq "," or Z80SCAN(1) neq 0
        THEN ERRSET (1,"O") ELSE BEGIN RP_RP2; VAL_FROM;
	NEDADR_ND!BYT2A END END;
  [0][1][2][4][5][6][8][9][10][11][12][13][14][15][16][18]
	ERRSET (1,"O") END;
[49] "POP,PUSH" BEGIN NEDADR_ND!OSC; CASE Z80SCAN(19) OF BEGIN
  [5][6][14] OPVAL_OPVAL+(VAL LSH 3);
  [4][18] IF (VAL LAND 1)=0 THEN OPVAL_OPVAL+(VAL LSH 3) ELSE
	ERRSET (1,"O");
  [8] BEGIN NEDADR_ND!BYT2; VALOPVAL; VAL_VAL+'40 END;
  [0][1][2][3][4][7][9][10][11][12][13][14][15][16][17][19]
	ERRSET (1,"O") END END;
[50] "RET"CASE Z80SCAN(12) OF BEGIN
 [10] BEGIN OPVAL_OPVAL+VAL; NEDADR_ND!OSC END;
 [11] BEGIN OPVAL_OPVAL+'70; NEDADR_ND!OSC END;
 [4] IF VAL neq 1 THEN ERRSET(1,"O") ELSE BEGIN OPVAL_OPVAL+'30;
	NEDADR_ND!OSC END;
 [0][1][2][3][5][6][7][8][9][12] BEGIN OPVAL_OPVAL LSH -18;
    NEDADR_ND!OSC END END;
[51] "RL,RR,SRA,SRL" Z80CM3(0);
[52] "RLC,RRC" Z80CM3(1);


[53] BEGIN OSCAN_PDP11SS(VAL,TO,RP,F1); OPVAL_OPVAL+TO;
      NEDADR_IF F1 THEN ND!PDP1 ELSE ND!PDP0 END;
[54] BEGIN OSCAN_PDP11SS(VAL,TO,RP,F1); IF OSCAN neq S!SPC or SCNVAL neq ","
      THEN ERRSET(1,"O"); OSCAN_PDP11SS(VTY,FROM,RP2,F2);
      OPVAL_OPVAL+TO LSH 6+FROM;
      IF F1 THEN NEDADR_IF F2 THEN ND!PDP2 ELSE ND!PDP1 ELSE
       IF F2 THEN BEGIN VAL_VTY; RP_RP2; NEDADR_ND!PDP1 END ELSE
       NEDADR_ND!PDP0 END;
[55] IF (OSCAN_ISCAN) neq S!SYM or (SYMBOL:SUBTYP[CURSYM] LAND V!PSW) neq 0 THEN
      ERRSET (1,"O") ELSE BEGIN OPVAL_OPVAL+SYMBOL:VALUE[CURSYM] LSH 6;
      OSCAN_PDP11SS(VAL,TO,RP,F1); OPVAL_OPVAL+TO;
      NEDADR_IF F1 THEN ND!PDP1 ELSE ND!PDP0 END;
[56] BEGIN OPVAL_OPVAL LSH -8+(2 LSH 33+1 LSH 32); NEDADR_ND!REL END;
[57] NEDADR_ND!PDP0
END "OPTYPE";


CASE NEDADR OF BEGIN
[ND!NA] OSCAN_ISCAN;
[ND!PDP2];
[ND!RELPAG][ND!WDF][ND!WD][ND!BYT][ND!REL] IF EVADR THEN OSCAN_EVLXPR(VAL,VTY,RP,0)
	ELSE OSCAN_ISCAN;
[ND!CWD][ND!CBYT] IF  not EVADR THEN OSCAN_ISCAN ELSE
	IF  not (ISCOMA) THEN BEGIN ERRSET (1,"O"); OSCAN_ISCAN END
	ELSE OSCAN_EVLXPR(VAL,VTY,RP,0);
[ND!XI] OPVAL_CALLXI(0);
[ND!DXI] OPVAL_CALLDXI;
[ND!IMDXI][ND!IMDXIW] IF (OSCAN_ISCAN)=S!SPC and SCNVAL ="#"
   THEN IF EVADR THEN OSCAN_EVLXPR(VAL,VTY,RP,0) ELSE
	OSCAN_ISCAN
   ELSE OPVAL_CALLDXI;
[ND!ZAI] IF OSCAN=S!SPC and SCNVAL="(" THEN BEGIN
	NEDADR_ND!BYT;
	OSCAN_IF EVADR THEN EVLXPR(VAL,VTY,RP,0) ELSE ISCAN;
	IF OSCAN=S!SPC and SCNVAL="," THEN
	   IF ISCAN=S!SYM and (SYMBOL:SUBTYP[CURSYM] LAND V!SP) neq 0
	 and SYMBOL:VALUE[CURSYM]=5 and 
		ISCAN=S!SPC and SCNVAL=")" THEN OSCAN_ISCAN
	   ELSE ERRSET(1,"O")
	ELSE IF OSCAN=S!SPC and SCNVAL=")" THEN
	   IF ISCAN=S!SPC and SCNVAL="," and ISCAN=S!SYM and 
		(SYMBOL:SUBTYP[CURSYM] LAND V!SP) neq 0
	 and SYMBOL:VALUE[CURSYM]=6 THEN BEGIN
		   OSCAN_ISCAN; OPVAL_OPVAL+'20 END
	   ELSE ERRSET(1,"O")
	ELSE ERRSET(1,"O")
	END
ELSE BEGIN OPVAL_OPVAL+4; OPVAL_CALLXZA(6) END;
[ND!ZA] OPVAL_CALLXZA(1)
END;

IF  not EVADR THEN BEGIN
   OSCAN!OP_OSCAN;
   CASE NEDADR OF BEGIN
    [ND!BYT2][ND!BYT3] RETURN((OPVAL LAND '377) LSH 8+VAL);
    [ND!BYT4][ND!BYT5] RETURN((OPVAL LAND '377) LSH 8+TO);
    [ND!WD3] RETURN((OPVAL LAND '377) LSH 8+FROM);
    [ND!PDP0][ND!PDP1][ND!PDP2] RETURN (OPVAL LAND '177777);
    [ND!BYT2A] END;
   RETURN (OPVAL LAND '377) END;

IF ND!PDP0 leq NEDADR leq ND!PDP2 THEN BEGIN
 EMITWORDF(RELPC,OPVAL LAND '177777); CODSTR_CVHDM(2,RELPC)&
  "  "&CVHDM(2,OPVAL) END ELSE
 BEGIN EMITBYTE(RELPC,OPVAL LAND '377);
 CODSTR_CVHDM(2,RELPC)&"  "&CVHDD(OPVAL) END;
CASE NEDADR OF BEGIN
[ND!NA][ND!OSC];
[ND!PDP0] BEGIN ASMPC_ASMPC+1; RELPC_RELPC+1 END;
[ND!PDP1] BEGIN CODGEN(VAL,RP,RELPC+2,ST!WRDF); ASMPC_ASMPC+3;
           RELPC_RELPC+3 END;
[ND!PDP2] BEGIN CODGEN(VAL,RP,RELPC+2,ST!WRDF);
           CODGEN(VTY,RP2,RELPC+4,ST!WRDF); ASMPC_ASMPC+5; RELPC_RELPC+5 END;
[ND!BYT5] BEGIN CODGEN(TO,NULL!RECORD,RELPC+1,ST!BYT);
  CODGEN(FROM,RP2,RELPC+2,ST!BYT); CODGEN(VAL,RP,RELPC+3,ST!BYT);
  RELPC_RELPC+3; ASMPC_ASMPC+3 END;
[ND!BYT4] BEGIN CODGEN(VAL,NULL!RECORD,RELPC+1,ST!BYT);
  CODGEN(FROM,RP,RELPC+2,ST!BYT); CODGEN(TO,NULL!RECORD,RELPC+3,ST!BYT);
  RELPC_RELPC+3; ASMPC_ASMPC+3 END;
[ND!WD3] BEGIN CODGEN(FROM,NULL!RECORD,RELPC+1,ST!BYT);
   CODGEN(VAL,RP,RELPC+2,ST!WRD); RELPC_RELPC+3; ASMPC_ASMPC+3 END;
[ND!WD2][ND!CWD][ND!WD] BEGIN CODGEN(VAL,RP,RELPC+1,ST!WRD);
	RELPC_RELPC+2; ASMPC_ASMPC+2 END;
[ND!BYT2A][ND!BYT2][ND!BYT][ND!CBYT][ND!IMDXI]
  BEGIN CODGEN(VAL,RP,RELPC_RELPC+1,ST!BYT); ASMPC_ASMPC+1 END;
[ND!WDF][ND!IMDXIW] BEGIN CODGEN(VAL,RP,RELPC+1,ST!WRDF);
	ASMPC_ASMPC+2; RELPC_RELPC+2 END;
[ND!RELPAG] BEGIN IF RP=NULL!RECORD THEN VAL_VAL-((ASMPC+1) LAND '177400)
	ELSE DBLFIX(VAL,(ASMPC+1) LAND '177400,RP,NULL!RECORD,C!MIN);
	CODGEN(VAL,RP,RELPC_RELPC+1,ST!PAG); ASMPC_ASMPC+1 END;
[ND!BYT3] BEGIN CODGEN(VAL,NULL!RECORD,RELPC+1,ST!BYT);
   CODGEN(FROM,RP,RELPC+2,ST!BYT); ASMPC_ASMPC+2; RELPC_RELPC+2 END;
[ND!REL2][ND!REL] BEGIN SHLV_ASMPC+OPVAL LSH -33;
	IF RP=NULL!RECORD THEN VAL_VAL-SHLV ELSE
	DBLFIX(VAL,SHLV,RP,NULL!RECORD,C!MIN);
        IF (OPVAL LAND (1 LSH 32)) neq 0 THEN IF RP=NULL!RECORD THEN
         VAL_VAL%2 ELSE DBLFIX(VAL,2,RP,NULL!RECORD,C!DIV);
        OPVAL_OPVAL LAND '7777;
	CODGEN(VAL,RP,RELPC_RELPC+1,ST!BYTR); ASMPC_ASMPC+1 END
END;
ASMPC_ASMPC+1; RELPC_RELPC+1;
RETURN (OSCAN) END "EVLOPC";


COMMENT SOME EXTRA PROCEDURES USED IN DEFINING SYMBOLS;

FORWARD RECURSIVE BOOLEAN PROCEDURE REFS(REFERENCE RECORD!POINTER (SYMBOL)
	SYM;REFERENCE RECORD!POINTER (FIXUP)FXUP);

RECURSIVE BOOLEAN PROCEDURE REFS2(RECORD!POINTER (SYMBOL) SYM;
	RECORD!POINTER (FIXUP) FXUP; INTEGER VAL);
COMMENT SEE IF SYM IS REFERENCED BY THIS FIXUP;
BEGIN RETURN (IF FXUP=NULL!RECORD THEN FALSE ELSE IF
	VAL neq 0 THEN FXUP=SYM ELSE REFS(SYM,FXUP)) END "REFS2";

RECURSIVE BOOLEAN PROCEDURE REFS(REFERENCE RECORD!POINTER (SYMBOL) SYM;
	REFERENCE RECORD!POINTER (FIXUP) FXUP);
BEGIN
RETURN (IF FXUP=NULL!RECORD THEN FALSE ELSE
REFS2(SYM,FIXUP:RPV1[FXUP],FIXUP:VAL1[FXUP]) or 
REFS2 (SYM,FIXUP:RPV2[FXUP],FIXUP:VAL2[FXUP])) END "REFS";

SIMPLE BOOLEAN PROCEDURE REFS1 (REFERENCE RECORD!POINTER (SYMBOL) SYM;
	REFERENCE RECORD!POINTER (SYMBOL,FIXUP) FXUP; INTEGER VAL);
BEGIN
IF FXUP=NULL!RECORD THEN RETURN (FALSE);
IF VAL neq 0 THEN RETURN (REFS(SYM,FXUP));
IF (SYMBOL:SUBTYP[FXUP] LAND V!MASK)=V!UND THEN RETURN (SYM=FXUP)
ELSE RETURN (REFS(SYM,FIXHED:FIXUP[SYMBOL:FIXUP[FXUP]]));
END "REFS1";


SIMPLE PROCEDURE COMSTR(INTEGER VAL,J;RECORD!POINTER (FIXUP,SYMBOL) RP;
	RECORD!POINTER (SYMBOL) SYM; INTEGER FLG);
BEGIN INTEGER I;
CODSTR_CVHDM(2,IF RP=NULL!RECORD THEN VAL ELSE 0);
IF LSTRMB and RP neq NULL!RECORD THEN ERRSET(0,"U") ELSE
IF REFS1(SYM,RP,VAL) THEN ERRSET(2,"C") ELSE
IF (I_(V!MASK LAND SYMBOL:SUBTYP[SYM]))=V!SET or I=V!UND or I=V!PST THEN
	STORIT (VAL,J,RP,SYM,FLG) ELSE
IF RP neq NULL!RECORD THEN ERRSET (0,"M") ELSE
IF VAL=SYMBOL:VALUE[SYM] THEN RETURN ELSE
IF LSTRMB and PASS1 THEN ERRST2("M "&LSTSTR) ELSE
ERRSET(2,IF LSTRMB THEN "P" ELSE "M");
END "COMSTR";

SIMPLE BOOLEAN PROCEDURE LEQSTR(STRING S1,S2);
BEGIN INTEGER I,J;
WHILE LENGTH(S1) neq 0 neq LENGTH(S2) DO IF (I_LOP(S1))<(J_LOP(S2)) THEN
RETURN (TRUE) ELSE IF I>J THEN RETURN (FALSE);
IF LENGTH(S1)=0 THEN RETURN (LENGTH(S2) neq 0) ELSE RETURN (FALSE);
END "LEQSTR";


SIMPLE STRING PROCEDURE GETFIL(INTEGER I);
BEGIN INTEGER J;
RPTEMP5_RPHEAD;
FOR J_1 STEP 1 UNTIL I DO RPTEMP5_FILE:NEXT[RPTEMP5];
RETURN ((IF EQU("DSK",FILE:DEV[RPTEMP5]) THEN NULL ELSE FILE:DEV[RPTEMP5]
	&":")&FILE:NAME[RPTEMP5]);
END "GETFIL";

SIMPLE BOOLEAN PROCEDURE MEMBER(STRING NAME,STR);
BEGIN INTEGER I;
WHILE LENGTH(STR) neq 0 DO IF EQU(SCAN (STR,B!SYM,I),NAME)
	THEN RETURN (TRUE);
RETURN (FALSE);
END "MEMBER";

RECURSIVE STRING PROCEDURE NEDLST(RECORD!POINTER (FIXUP) FXUP;
	STRING ST);
BEGIN RECORD!POINTER (FIXUP,SYMBOL) RP;
STRING STV;
IF (RP_FIXUP:RPV1[FXUP]) neq NULL!RECORD THEN BEGIN
IF FIXUP:VAL1[FXUP]=FXV!FXU THEN ST_NEDLST(RP,ST) ELSE
 IF  not MEMBER (STV_SYMBOL:NAME[RP],ST) THEN ST_IF LENGTH(ST)=0
	THEN STV ELSE ST&","&STV END;
IF (RP_FIXUP:RPV2[FXUP])=NULL!RECORD THEN RETURN (ST);
IF FIXUP:VAL2[FXUP]=FXV!FXU THEN RETURN(NEDLST(RP,ST));
IF  not MEMBER (STV_SYMBOL:NAME[RP],ST) THEN RETURN (
	IF LENGTH(ST)=0 THEN STV ELSE ST&","&STV);
RETURN (ST);
END "NEDLST";


COMMENT SOME SYMBOL TABLE ROUTINES;

COMMENT FIRST SORT THE SYMBOL TABLE AND RETURN IN ONE LIST;

SIMPLE RECORD!POINTER (SYMBOL) PROCEDURE SRTSYM;
BEGIN INTEGER I,J;
DEFINE CURRENT=<RPTEMP5>,HEADRC=<RPTEMP4>,TAIL=<RPTEMP3>
 ,FP=<RPTEMP2>;

FOR I_0 STEP 1 UNTIL 100 DO BEGIN CURRENT_SYMTAB[I];
HEADRC_NEW!RECORD(SYMBOL);
WHILE NULL!RECORD neq CURRENT neq SAVSYA[I] DO BEGIN
FP_SYMBOL:NEXT[CURRENT];
TAIL_HEADRC;
	WHILE SYMBOL:NEXT[TAIL] neq NULL!RECORD DO
	IF LEQSTR(SYMBOL:NAME[SYMBOL:NEXT[TAIL]],
		SYMBOL:NAME[CURRENT])
		THEN TAIL_SYMBOL:NEXT[TAIL] ELSE DONE;
	SYMBOL:NEXT[CURRENT]_SYMBOL:NEXT[TAIL];
	SYMBOL:NEXT[TAIL]_CURRENT;
CURRENT_FP END;
SYMTAB[I]_SYMBOL:NEXT[HEADRC] END;

COMMENT NOW MERGE ALL THE SYMBOLS;
HEADRC_TAIL_NEW!RECORD(SYMBOL);
WHILE TRUE DO BEGIN
J_-1;
FOR I_0 STEP 1 UNTIL 100 DO
IF SYMTAB[I] neq NULL!RECORD and (J<0 or 
 LEQSTR(SYMBOL:NAME[SYMTAB[I]],SYMBOL:NAME[SYMTAB[J]])) THEN
	J_I;
IF J<0 THEN DONE;
SYMBOL:NEXT[TAIL]_SYMTAB[J];
TAIL_SYMTAB[J];
SYMTAB[J]_SYMBOL:NEXT[TAIL] END;
SYMBOL:NEXT[TAIL]_NULL!RECORD;
RETURN (SYMBOL:NEXT[HEADRC]) END "SRTSYM";

SIMPLE PROCEDURE RELSYM(RECORD!POINTER (SYMBOL) SYMS);
BEGIN INTEGER I;
WHILE SYMS neq NULL!RECORD DO BEGIN
  I_255 MIN LENGTH(SYMBOL:NAME[SYMS]);
  OUT(CH!REL,":"&CVHXDD(I)&CVHX(2,SYMBOL:VALUE[SYMS])&
    (IF (SYMBOL:SUBTYP[SYMS] LAND V!USE)=0 THEN "02" ELSE "01")&
	SYMBOL:NAME[SYMS][1 TO I]&'15&'12);
  SYMS_SYMBOL:NEXT[SYMS] END
END "RELSYM";


COMMENT NOW CHECK FOR UNDEFFS AND ELIM FROM SYMBOL TABLE;

UNSIMPLE RECORD!POINTER (SYMBOL) PROCEDURE UDFSRC (RECORD!POINTER
	(SYMBOL) SYMS);
BEGIN RECORD!POINTER (SYMBOL) HEAD,TAIL;
INTEGER I,J;
STRING S;
HEAD_TAIL_NEW!RECORD(SYMBOL);
WHILE SYMS neq NULL!RECORD DO BEGIN
IF CRFSW and  not (T!MAC neq SYMBOL:TYP[SYMS] neq T!SYM)
	THEN OUT(CH!OUT,'177&'102&'11&FAKSYM(SYMS)
	&(I_6 MIN
	LENGTH(S_SYMBOL:NAME[SYMS]))&S[1 FOR I]&'177&'104);
IF SYMBOL:TYP[SYMS]=T!SYM THEN BEGIN
IF (I_(SYMBOL:SUBTYP[SYMS] LAND V!MASK))=V!UND THEN
	ERRST2 ("UNDEFINED SYMBOL "&SYMBOL:NAME[SYMS]&
	" FIRST USED AT "&LOCLIN(SYMBOL:VALUE[SYMS]))
ELSE IF I=V!PST or I=V!PEQ THEN
	ERRST2 ("UNDEFINED SYMBOL "&SYMBOL:NAME[SYMS]&
	" NEEDS "&NEDLST(FIXHED:FIXUP[SYMBOL:FIXUP[SYMS]],NULL))
ELSE IF I LAND V!ORGS =0 THEN
	BEGIN SYMBOL:NEXT[TAIL]_SYMS; TAIL_SYMS END END;
SYMS_SYMBOL:NEXT[SYMS] END;
SYMBOL:NEXT[TAIL]_NULL!RECORD;
RETURN (SYMBOL:NEXT[HEAD]) END "UDFSRC";

UNSIMPLE PROCEDURE SYMOUT(STRING ST);
BEGIN
IF (LPP_LPP-1) leq 0 THEN BEGIN LPP_LPPMAX; OUT(CH!OUT,HEAD); 
	PGNUM_PGNUM+1 END;
OUT(CH!OUT,ST&'15&'12);
END "SYMOUT";

UNSIMPLE PROCEDURE PRTSYM(RECORD!POINTER (SYMBOL) SYMS);
BEGIN INTEGER I,J,TW,MW,F1,F2,SYMSIZ; STRING ST,ST1;
SAFE RECORD!POINTER (SYMBOL) ARRAY SYMARY[1:4];
SAFE INTEGER ARRAY WDARY[1:4];
PGNUM_1; LPP_0; LPP2_1; CFLN_1; COMMENT FOR HEAD;
SYMSIZ_IF CURRAD=16 THEN 6 ELSE 8;
GETFORMAT(F1,F2); COMMENT IN CASE OCTAL;
FILE:NAME[RPSRC]_"SYMBOL TABLE";
WHILE TRUE DO BEGIN "PAGE LOOP"
TW_-5;
FOR I_1 STEP 1 UNTIL 4 DO BEGIN "SIZE CHECK"
MW_6; SYMARY[I]_SYMS;
FOR J_1 STEP 1 UNTIL LPPMAX DO BEGIN "COLUMN SIZE"
IF SYMS=NULL!RECORD THEN DONE;
MW_MW MAX LENGTH(SYMBOL:NAME[SYMS]);
SYMS_SYMBOL:NEXT[SYMS] END "COLUMN SIZE";
MW_MW MIN 30; IF MW+TW+5+SYMSIZ>70 THEN BEGIN
	SYMS_SYMARY[I]; SYMARY[I]_NULL!RECORD; DONE END;
TW_TW+MW+5+SYMSIZ; WDARY[I]_MW END "SIZE CHECK";
IF SYMARY[1]=NULL!RECORD THEN RETURN;
FOR J_1 STEP 1 UNTIL LPPMAX DO BEGIN "LINE PRINT"
IF SYMARY[1]=NULL!RECORD THEN DONE;
ST_NULL; SETFORMAT(-6,0); COMMENT IN CASE OCTAL;
FOR I_1 STEP 1 UNTIL 4 DO BEGIN "SYMBOL PRINT"
IF SYMARY[I]=NULL!RECORD THEN DONE;
ST1_SYMBOL:NAME[SYMARY[I]][1 FOR WDARY[I]];
IF I neq 1 THEN ST_ST&"     ";
ST_ST&ST1&
   "                                "[1 
 FOR WDARY[I]-LENGTH(ST1)]&"  "&(IF CURRAD=16 THEN CVHX(2,SYMBOL:VALUE
 [SYMARY[I]]) ELSE CVOS(SYMBOL:VALUE[SYMARY[I]]));
SYMARY[I]_SYMBOL:NEXT[SYMARY[I]];
END "SYMBOL PRINT"; SETFORMAT(F1,F2);
SYMOUT (ST) END "LINE PRINT"
END "PAGE LOOP" END "PRTSYM";


UNSIMPLE RECORD!POINTER (MACTXT) PROCEDURE READMACROBODY(
	INTEGER ARGN; RECORD!POINTER (MACALIST) ARGLIST;
	INTEGER CATCR,OSCAN);
BEGIN
STRING TXTSTR,SCNSTR,STRM,STRM2,STRM3,STRM4;
INTEGER BRKCNT,FLAG,BDYBRK;
RECORD!POINTER (MACTXT) MTP,MTPEND,MTPHEAD;
RECORD!POINTER (MACALIST) MA;


MTP_MTPEND_MTPHEAD_NEW!RECORD(MACTXT);
SETBREAK (B!DEFINE,'12&"<",NULL,"ISN");
IF OSCAN neq S!SPC and SCNVAL neq "<" THEN
WHILE RUNNING and BDYBRK neq "<" DO BEGIN
   IF LENGTH(CURSTR)=0 THEN NEWLIN;
   SCAN(CURSTR,B!DEFINE,BDYBRK) END;
BRKCNT_0; SETBREAK (B!DEFINE,'12&"<>"&ALPHABET&CATCR,1,"ISN");
TXTSTR_NULL; FLAG_0;

WHILE RUNNING DO BEGIN "MACROBODY"
STRM_SCAN(CURSTR,B!DEFINE,BDYBRK);
WHILE TRUE DO BEGIN "FAKEBODY"
ifc not SAISCN
  thenc IF CHRTAB[BDYBRK]<0 THEN BEGIN "POSSIBLE ARGUMENT"
  elsec IF CHRTAB[BDYBRK]=C!LET THEN BEGIN "POSSIBLE ARGUMENT"
  endc
   CURSTR_BDYBRK&CURSTR;
   SETBREAK(B!DEFINE,1&ALPHABET&DIGITS,1,"XRN");
   STRM2_SCAN(CURSTR,B!DEFINE,BDYBRK);
   SETBREAK(B!DEFINE,'12&"<>"&ALPHABET&CATCR,1,"ISN");
   COMMENT NOW CONVERT LOWER CASE TO UPPER CASE;
   STRM4_STRM2;
   STRM3_SCAN(STRM4,B!SYM,BDYBRK);
   BDYBRK_0;
   MA_ARGLIST;
   FOR I_1 STEP 1 UNTIL ARGN DO 
	IF (IF (SCNSTR_MACALIST:ARG[MA])="%" THEN
	   EQU (SCNSTR[2 TO INF],STRM3) ELSE EQU(SCNSTR,STRM3))
	THEN DONE ELSE MA_MACALIST:NEXT[MA];
   IF MA neq NULL!RECORD THEN BEGIN "REAL ARGUMENT"
	if FLAG=2 and Length(STRM) neq 0
	    then TXTSTR_TXTSTR & CATCR;
	MACTXT:TYP[MTPEND]_MT!MORE;
	MACTXT:TXT[MTPEND]_TXTSTR&STRM;
	MACTXT:NEXT[MTPEND]_MTP_NEW!RECORD(MACTXT);
	MACTXT:TYP[MTP]_MT!ARG;
	MACTXT:ARGNUM[MTP]_I;
	MACTXT:NEXT[MTP]_MTPEND_NEW!RECORD(MACTXT);
	TXTSTR_NULL; FLAG_1; DONE END "REAL ARGUMENT" ELSE
   STRM_STRM&STRM2 END "POSSIBLE ARGUMENT";
IF FLAG=2 THEN TXTSTR_TXTSTR&CATCR;
TXTSTR_TXTSTR&STRM;
IF BDYBRK=CATCR and (FLAG neq 1 or LENGTH(STRM) neq 0) THEN
	FLAG_2 ELSE FLAG_0;
IF BDYBRK='12 THEN BEGIN "MACRO!LINE!DONE"
   MACTXT:TXT[MTPEND]_TXTSTR&'12;
   MACTXT:NEXT[MTPEND]_MTP_NEW!RECORD(MACTXT);
   MACTXT:TYP[MTPEND]_MT!LINE; TXTSTR_NULL;
   MTPEND_MTP; NEWLIN
   END "MACRO!LINE!DONE" ELSE
IF BDYBRK="<" THEN BEGIN
   TXTSTR_TXTSTR&"<"; BRKCNT_BRKCNT+1;
   END ELSE
IF BDYBRK=">" THEN BEGIN
   IF (BRKCNT_BRKCNT-1)<0 THEN BEGIN "LAST OF BODY"
	MACTXT:TXT[MTPEND]_TXTSTR;
	MACTXT:TYP[MTPEND]_MT!FIN; RETURN (MTPHEAD);
	END "LAST OF BODY";
   TXTSTR_TXTSTR&">" END;
DONE END "FAKEBODY";
END "MACROBODY";
RETURN (MTPHEAD) END "READMACROBODY";


SIMPLE PROCEDURE READSYMBOLS(STRING ASSEMBLERNAME);
BEGIN INTEGER PPN; STRING SAVASM;

IF THIS!ASSEMBLY neq NULL and (ASSEMBLERNAME=NULL or 
	EQU(ASSEMBLERNAME,THIS!ASSEMBLY)) THEN RETURN;

IF CH!LOAD<0 THEN
OPEN(CH!LOAD_GETCHAN,"DSK",0,2,0,SCNT,SBCHR,SEOF);
IF (SAVASM_ASSEMBLERNAME)=NULL THEN ASSEMBLERNAME_"8080";
PPN_CALL(-'25,"GETTAB");
ASSEMBLERNAME_ASSEMBLERNAME&".SYM";
IF PPN neq 0 THEN ASSEMBLERNAME_ASSEMBLERNAME&"["&
	CVOS(PPN LSH -18)&","&CVOS(PPN LAND '777777)&"]";
CALLI('2000 LSH 18 LOR (PPN_CALL(-'20,"GETTAB")),-'10);
LOOKUP (CH!LOAD,ASSEMBLERNAME,SEOF);
IF SEOF neq 0 THEN USERERR(1,0,"LOOKUP FAILURE ON SYMBOL TABLE "&
	SAVASM&" "&CVOS(SEOF LAND '777777));
CALLI (PPN LAND LNOT ('2000 LSH 18),-'10);
SCNT_100;
ARRCLR(SYMTAB);
SETBREAK(1,","&'12," "&'11&'15&'14,"ISN");
ARRBLT(CHRTAB[0],CHRTABO[0],128);
INPRAD_SINPRAD_CVD(INPUT(CH!LOAD,1));
CURRAD_SCURRAD_CVD(INPUT(CH!LOAD,1));
WHILE (VL_CVO(INPUT(CH!LOAD,1))) geq 0 DO
 CHRTAB[VL]_CHRTAB[CVO(INPUT(CH!LOAD,1))];
WHILE TRUE DO BEGIN
 OPCOD_INPUT(CH!LOAD,1); IF SEOF neq 0 THEN DONE; VL_CVO(INPUT(CH!LOAD,1));
 TY_CVD(INPUT(CH!LOAD,1)); STY_CVD(INPUT(CH!LOAD,1));
 CURSYM_FNDSYM(OPCOD);
 IF SYMBOL:TYP[CURSYM] neq 0 THEN
  USERERR(1,0,"MULTIPLE DEFINITION "&OPCOD);
 IF TY=T!SYM THEN STY_STY LOR V!ORGS;
 SYMBOL:VALUE[CURSYM]_VL; SYMBOL:TYP[CURSYM]_TY;
 SYMBOL:SUBTYP[CURSYM]_STY END;
RELEASE(CH!LOAD); CH!LOAD_-1;
ARRTRAN(SAVSYA,SYMTAB); COMMENT SAVE ORIGINAL SYMBOL TABLE;

END "READSYMBOLS";


COMMENT MAIN PROGRAM;

CH!LOAD_CH!IN_CH!CTRL_CH!REL_CH!OUT_-1;
THIS!ASSEMBLY_NULL;
CALLI (CALL(-'20,"GETTAB") LAND LNOT ('2000 LSH 18),-'10);
COMMENT REMOVE HF LICENSE FROM ACTIVE STATUS;
SETBREAK(B!LIN,'12,'15&'14,"IAN");
SETBREAK(B!SPC,1&" "&'11,1,"XRN");
SETBREAK(B!SYM,1&UPRCAS&DIGITS,1,"XRNK");
SETBREAK(B!NUM,1&DIGITS&"ABCDEF",1,"XRNK");
SETBREAK(B!IF,"<>",1,"ISN");
SETBREAK (B!FIL1,"[,!(/_"&'12,'15,"ISNK");
SETBREAK (B!FIL2,")"&'12,'15,"ISNK");
SETBREAK (B!FIL3,UPRCAS,'15&"/","IANK");
SETBREAK (B!FIL4,"[!:,._/("&'12,'11&" "&'15,"ISNK");
IFHDR_NULL!RECORD; NOXSYM_NOXMAC_FALSE;
IFC IFBAIL THENC BAIL; ENDC
CH!CTRL_GETCHAN;
CMDSTR_NULL;
IF RPGSW THEN BEGIN
SAFE INTEGER ARRAY BUF[1:128],BLK[0:1];
BLK[0]_CVSIX("MIC");
BLK[1]_(-128) LSH 18 +POINT (0,BUF[1],35)-1; COMMENT IOWD;
I_CALL((2 LSH 18)+POINT (0,BLK[0],35),"TMPCOR");
IF !SKIP! THEN BEGIN
FOR J_1 STEP 1 UNTIL I DO CMDSTR_CMDSTR&CVASTR(BUF[J]);
TMPCOR_TRUE;

END ELSE BEGIN TMPCOR_FALSE;
OPEN (CH!CTRL,"DSK",0,2,0,CCNT,CBCHR,CEOF);
SWT_CVS(CALL(0,"PJOB")); SWT_"000"[1 FOR 3-LENGTH(SWT)]&SWT;
LOOKUP (CH!CTRL,SWT&"MIC.TMP",CEOF);
IF CEOF neq 0 THEN RPGSW_FALSE END END;

IF  not RPGSW THEN OPEN (CH!CTRL,"TTY",0,2,0,CCNT,CBCHR,CEOF);

MORFLG_TRUE; CCNT_100;
WHILE MORFLG DO BEGIN "FILE LOOP"
SAVETRU_CURTRU;
LSTRMB_NOSYMT_CRFSW_DWNLSW_NOREL_ONEPAS_LSTTTY_PASS1_RELSW_LSTSW_FALSE;
MACLST_MACLSTU_NSTLST_TRUE;
TITLE _ "MICRO-SYMBOL";
SUBTITLE _ NULL;
IF not RPGSW THEN OUTSTR ("*");
IF LENGTH(CMDSTR)=0 THEN BEGIN
 IF TMPCOR THEN CEOF_1 ELSE CMDSTR_INPUT(CH!CTRL,B!LIN) END;
SWT_NULL;
IF (RPSRC_FILNAM(SWT)) neq NULL!RECORD THEN BEGIN "REL FILE"
IF CBCHR="!" THEN BEGIN SAFE INTEGER ARRAY BLK[1:6];
	BLK[1]_CVSIX(IF SPDFLG THEN FILE:DEV[RPSRC] ELSE "SYS");
	BLK[2]_CVFIL(FILE:NAME[RPSRC],BLK[3],BLK[5]);
	BLK[4]_BLK[6]_0;
	CALL (POINT (0,BLK[1],35)+(IF RPGSW THEN '1000000 ELSE 0),
		"RUN");
END;

IF CH!REL<0 THEN CH!REL_GETCHAN;
RELSW_TRUE; OPEN (CH!REL,FILE:DEV[RPSRC],0,0,2,CNT,BCHR,EOF);
IF LENGTH(FILE:EXT[RPSRC])=0 THEN FILE:NAME[RPSRC]_
	INSEXT(FILE:NAME[RPSRC],"REL");
ENTER (CH!REL,FILE:NAME[RPSRC],EOF);
IF EOF neq 0 THEN FINLIN("CAN NOT ENTER REL FILE"
	&FILE:NAME[RPSRC]);
END "REL FILE";

IF CBCHR="," THEN BEGIN "LIST FILE"
LSTRMB_LSTSW_TRUE; SWT_NULL;
IF (RPSRC_FILNAM(SWT))=NULL!RECORD THEN ERRLIN ("ILLEGAL FORMAT");
IF CH!OUT<0 THEN CH!OUT_GETCHAN;
OPEN (CH!OUT,FILE:DEV[RPSRC],0,0,2,CNT,BCHR,EOF);
IF LENGTH(FILE:EXT[RPSRC])=0 THEN FILE:NAME[RPSRC]_
	INSEXT(FILE:NAME[RPSRC],"LST");
ENTER (CH!OUT,FILE:NAME[RPSRC],EOF);
IF EOF neq 0 THEN FINLIN ("CAN NOT ENTER LST FILE"
	&FILE:NAME[RPSRC]);
	I_CALLI(CH!OUT,'64);
	IF EQU(CVXSTR(I)[1 FOR 3],"TTY") THEN LSTTTY_TRUE;
IF MEMSTR(SWT,"C") THEN CRFSW_TRUE;
IF MEMSTR(SWT,"O") THEN ONEPAS_TRUE; PASS1_ not ONEPAS;
END "LIST FILE";
IF CEOF neq 0 THEN BEGIN CBCHR_-1; IF RPGSW THEN MORFLG_FALSE;
	END;
IF CBCHR geq 0 and CBCHR neq "_" THEN ERRLIN ("ILLEGAL FORMAT");
IF CBCHR geq 0 THEN BEGIN "SOURCE START"
CBCHR_",";
INCLHED_RPHSAV_RPHEAD_NULL!RECORD;
CFLNT_CFLN_-1;
SWT_NXTSRC;
CNT_200;
READSYMBOLS(SWT);
IF RPGSW THEN OUTSTR ("MICRO-SYMBOL: "&GETNAM(FILE:NAME[RPHEAD])&'15&'12);
IF CBCHR geq 0 THEN WHILE TRUE DO BEGIN "SOURCE GO"
RELPC_GENSYM_MAXPC_ASMPC_ERRCNT_0; MINPC_100000;
THISMAC_NULL!RECORD;
SUBTITLE_NULL;
RUNNING_TRUE;
IF CRFSW and  not PASS1 THEN OUT(CH!OUT,'177&'102&'20&
	HEAD1(RPHEAD)&'177&'104);

WHILE RUNNING DO CASE ISCAN OF BEGIN "MAIN"

[S!EOL] CURSTR_NULL;
[S!SPC] IF ";" neq SCNVAL THEN ERRSET (0,"Q")
	ELSE CURSTR_NULL;
[S!NUM] ERRSET (0,"Q");
[S!SYM] CASE SYMBOL:TYP[CURSYM] OF BEGIN "MAINSYMBOL"

[T!OPC] EOLTST(EVLOPC(TRUE));
[T!PSD] CASE SYMBOL:SUBTYP[CURSYM] OF BEGIN "PSEUDO"

[0] BEGIN "ORG" I_EVLXPR(VAL,VTY,CODVAL,0);
	IF CODVAL neq NULL!RECORD THEN ERRSET(0,"U") ELSE BEGIN
	 MAXPC_MAXPC MAX RELPC; MINPC_MINPC MIN VAL;
	 CODSTR_CVHDM(2,RELPC_ASMPC_VAL); EOLTST(I) END END "ORG";
[1] BEGIN "END" RUNNING_FALSE; MAXPC_MAXPC MAX RELPC; SUBTITLE _ NULL;
	IF (I_ISCAN)=S!EOL or (I=S!SPC and SCNVAL=";") THEN JOBSA_-1
	  ELSE BEGIN I_EVLXPR(JOBSA,VTY,CODVAL,-I-2);
	   IF CODVAL neq NULL!RECORD THEN ERRSET(0,"Q") END;
	EOLTST(I); DMPLIN(TRUE); IF MINPC=100000 THEN MINPC_0
	END "END";
[6][5] ERRSET (1,"O");
[2] BEGIN "DS" I_EVLXPR(VAL,VTY,CODVAL,0);
	IF CODVAL neq NULL!RECORD THEN ERRSET (0,"U")
	ELSE BEGIN CODSTR_CVHDM(2,ASMPC); ASMPC_ASMPC+VAL;
		RELPC_RELPC+VAL;
		EOLTST(I) END END "DS";
[3] BEGIN "DW" CODSTR_CVHDM(2,RELPC)&"  ";
WHILE TRUE DO BEGIN I_EVLXPR(VAL,VTY,CODVAL,0);
	CODGEN(VAL,CODVAL,RELPC,ST!WRD); ASMPC_ASMPC+2;
	RELPC_RELPC+2;
	IF I neq S!SPC or SCNVAL neq "," THEN DONE END;
EOLTST(I) END "DW";
[4] BEGIN "DB" CODSTR_CVHDM(2,RELPC)&"  ";
WHILE TRUE DO BEGIN
	IF (I_ISCAN) neq S!SPC or SCNVAL neq "'" THEN BEGIN
		I_EVLXPR(VAL,VTY,CODVAL,-(I+2));
		CODGEN(VAL,CODVAL,RELPC,ST!BYT); RELPC_RELPC+1;
		ASMPC_ASMPC+1
	END ELSE
	  BEGIN STRING BYTSTR;
	   BYTSTR_REDQT;
	   WHILE LENGTH(BYTSTR)>0 DO BEGIN
	    CODGEN(LOP(BYTSTR),NULL!RECORD,RELPC,ST!BYT);
	    RELPC_RELPC+1; ASMPC_ASMPC+1 END;
	   I_ISCAN END;
	IF I neq S!SPC or SCNVAL neq "," THEN DONE END;
EOLTST(I) END "DB";
[23] BEGIN "DT" STRING BYTSTR;
   CODSTR_CVHDM(2,RELPC)&"  ";
   IF(I_ISCAN) neq S!SPC or SCNVAL neq "'" THEN ERRSET(0,"E") ELSE
   BEGIN BYTSTR_LENGTH(BYTSTR_REDQT)&BYTSTR;
    WHILE LENGTH(BYTSTR)>0 DO BEGIN
     CODGEN(LOP(BYTSTR),NULL!RECORD,RELPC,ST!BYT);
     RELPC_RELPC+1; ASMPC_ASMPC+1 END
    END;
   EOLTST(ISCAN) END "DT";


[9] BEGIN "PHASE"
   I_EVLXPR(VAL,VTY,CODVAL,0);
   IF CODVAL neq NULL!RECORD THEN ERRSET (0,"U") ELSE BEGIN
   ASMPC_VAL; EOLTST(I) END END "PHASE";
[10] BEGIN "DEPHASE"
   ASMPC_RELPC; EOLTST(ISCAN) END "DEPHASE";
[11] BEGIN "WORD"
	CODSTR_CVHDM(2,RELPC)&"  ";
WHILE TRUE DO BEGIN I_EVLXPR(VAL,VTY,CODVAL,0);
	CODGEN(VAL,CODVAL,RELPC,ST!WRDF); ASMPC_ASMPC+2;
	RELPC_RELPC+2;
	IF I neq S!SPC or SCNVAL neq "," THEN DONE END;
EOLTST(I) END "WORD";

[12] "PRINTX" 
    IF PASS1 
	THEN REMLINE
	ELSE BEGIN outstr(REMLINE); outstr('15&'12) END;

[13] BEGIN "REPEAT"
 INTEGER FORCNT,DUM;
 RECORD!POINTER (FORHDR) FORHD;
 RECORD!POINTER (MACARG) MAG;
 RECORD!POINTER (MACTXT) MAT;
 RECORD!POINTER (SYMBOL,FIXUP) RP;

 FORHDR:TYP[FORHD_NEW!RECORD(FORHDR)]_FOR!ARITH;

 COMMENT REPEAT SIMULATES ARITHMETIC FOR;

 EVLPRM(FORCNT,DUM,RP,ISCAN);
 IF RP neq NULL!RECORD THEN ERRSET (1,"A");
 FORHDR:CNT2[FORHD]_FORCNT;
 FORHDR:CNT1[FORHD]_FORHDR:CNT3[FORHD]_1;
 CURHSH_0;
 FORHDR:TEXT[FORHD]_READMACROBODY(0,NULL!RECORD,-1,-1);
 IF NXTFOR(FORHD,TRUE,MAG,MAT) THEN STARTMAC(MAG,MAT,1,FORHD)
 END "REPEAT";

[15] "BEGIN" CURSTR_NULL;
[16] BEGIN "FINISH"
INTEGER I;
NOXSYM_TRUE; I_ISCAN; CURSTR_NULL; NOXSYM_FALSE;
IF I=S!SYM and CURINCL neq NULL!RECORD and 
   EQU(ACCUM,SYMBOL:NAME[CURINCL]) THEN FINDINCLUDE
END "FINISH";
[17] BEGIN "NOSYM" NOSYMT_TRUE; EOLTST(ISCAN) END "NOSYM";
[18] BEGIN "OPCODELOAD" SCAN(CURSTR,B!SPC,BCHR);
  IF LENGTH(ACCUM_SCAN(CURSTR,B!SYM,BCHR))=0 THEN ERRSET(0,"Q") ELSE
  IF EQU(THIS!ASSEMBLY,ACCUM) THEN EOLTST(ISCAN) ELSE
   IF  not LSTRMB or PASS1 THEN BEGIN
   FOR I_0 STEP 1 UNTIL 100 DO
    IF SAVSYA[I] neq SYMTAB[I] THEN ERRSET(2,"M");
   READSYMBOLS(ACCUM);
   EOLTST(ISCAN) END END "OPCODELOAD";


[22][14] WHILE TRUE DO BEGIN "INCLUDE"
 INTEGER SVCBC,SVTYP; STRING PGN;
 RECORD!POINTER (FILE) RP,RP2;
 RECORD!POINTER (SYMBOL) RPS;

 SVTYP_SYMBOL:SUBTYP[CURSYM]; COMMENT TYPE OF CALL;
 IF SVTYP=14 THEN CMDSTR SWAP CURSTR;
 SVCBC_CBCHR;
 PGN_NULL; IF SVTYP=14 or  not LSTRMB or PASS1 THEN RP_FILNAM(PGN) ELSE
   DO BEGIN RP_RPHSAV; RPHSAV_FILE:NEXT[RP] END UNTIL FILE:USE[RP];
 IF SVTYP=14 THEN BEGIN
  IF CBCHR neq 0 THEN CMDSTR_CBCHR&CMDSTR;
  CMDSTR SWAP CURSTR; CBCHR_SVCBC END;
 IF RP=NULL!RECORD THEN BEGIN ERRSET(0,"D"); DONE END;
 FILE:SOSNUM2[RP]_SOSNUM2;
 FILE:LNUM[RP]_LNUM;
 FILE:SOSNUM[RP]_SOSNUM;
 FILE:PGNUM[RP]_PGNUM;
 FILE:CHNUM[RP]_CH!IN;
 FILE:MACSAV[RP]_THISMAC; THISMAC_NULL!RECORD;
 FILE:INCLSAV[RP]_INCLST;
 FILE:CURINCL[RP]_CURINCL; CURINCL_INCLST_NULL!RECORD;
 FILE:NEXTI[RP]_INCLHED;
 FILE:OLDSRC[RP]_RPSRC;
 FILE:USE[RP]_SVTYP=22;
 FILE:CFLN[RP]_CFLN;
 INCLHED_RP; CH!IN_-1;
 EOLTST(ISCAN);
 IF LENGTH(PGN) neq 0 THEN BEGIN
  CURSTR_PGN&")"&CURSTR; PGN_NULL;
  NOXSYM_TRUE;
  WHILE ISCAN=S!SYM DO BEGIN
   SYMBOL:NAME[RPS_NEW!RECORD(SYMBOL)]_ACCUM;
   SYMBOL:NEXT[RPS]_INCLST; INCLST_RPS;
   IF ISCAN neq S!SPC or (PGN_SCNVAL) neq "," THEN DONE END;
  NOXSYM_FALSE;
  IF PGN neq ")" THEN BEGIN ERRSET(0,"Q"); UNINCLUDE; DONE END
  END;
 IF (CH!IN_GETCHAN)<0 THEN BEGIN
  ERRSET(0,"D"); UNINCLUDE; DONE END;
 OPEN(CH!IN,FILE:DEV[RP],0,2,0,CNT,BCHR,EOF);
 SETPL(CH!IN,LNUM,PGNUM,SOSNUM);
 LOOKUP (CH!IN,FILE:NAME[RP],EOF);
 IF EOF neq 0 and LENGTH(FILE:EXT[RP])=0 THEN
  LOOKUP(CH!IN,INSEXT(FILE:NAME[RP],"MIC"),EOF);
 IF EOF neq 0 THEN BEGIN ERRSET(0,"D"); UNINCLUDE; DONE END;
LNUM_FILE:LNUM[RP]; PGNUM_FILE:PGNUM[RP];
SOSNUM_FILE:SOSNUM[RP]; DMPLIN(TRUE); LSTSTR_NULL;
SOSNUM2_LNUM_SOSNUM_0; PGNUM_1; ERRPG_-1;
  RPSRC_RP; CFLNT_CFLN_CFLNT+1; IF  not LSTRMB or PASS1 THEN
   IF (RP2_RPHEAD)=NULL!RECORD THEN RPHEAD_RP ELSE BEGIN
   WHILE FILE:NEXT[RP2] neq NULL!RECORD DO RP2_FILE:NEXT[RP2];
    FILE:NEXT[RP2]_RP END;
IF INCLST neq NULL!RECORD THEN FINDINCLUDE; DONE END "INCLUDE";


[8] BEGIN "FOR"
INTEGER CATCR,ARGN,FORI,FORCNT,DUM;
RECORD!POINTER (SYMBOL,FIXUP) RP;
RECORD!POINTER (MACALIST) MATAIL;
RECORD!POINTER (FORHDR) FORHD;
RECORD!POINTER (MACARG) MAG;
RECORD!POINTER (MACTXT) MAT;


NOXSYM_TRUE; CATCR_ORG!CAT!CHR;
IF (DUM_ISCAN)=S!SPC and SCNVAL="@" THEN BEGIN "FORCAT"
   DO CATCR_LOP(CURSTR) UNTIL CATCR neq 1;
   COMMENT WE KNOW DUM=S!SPC IS AN ERROR AFTER THIS SO;
   IF CATCR neq '12 THEN DUM_ISCAN END "FORCAT";
IF DUM=S!SYM THEN BEGIN "FOR2"
   ARGN_1; FORHD_NEW!RECORD(FORHDR);
   MACALIST:ARG[MATAIL_NEW!RECORD(MACALIST)]_ACCUM;
   IF (DUM_ISCAN)=S!SPC and SCNVAL="," THEN BEGIN "FORARG2"
	ARGN_2; IF ISCAN=S!SYM THEN BEGIN
	  MACALIST:ARG[MACALIST:NEXT[MATAIL]_NEW!RECORD
		(MACALIST)]_ACCUM; DUM_ISCAN END ELSE
	COMMENT WE KNOW DUM=S!NUM IS AN ERROR; DUM_S!NUM
	END "FORARG2";
   NOXSYM_FALSE; IF DUM=S!SPC and SCNVAL="_" THEN BEGIN "FORARITH"
	FORHDR:CNT3[FORHD]_1;
	FOR FORI_1 STEP 1 UNTIL 3 DO BEGIN "FORNUM"
	   EVLPRM(FORCNT,DUM,RP,ISCAN);
	   IF RP neq NULL!RECORD THEN BEGIN ERRSET(1,"A"); DONE END;
	   CASE FORI-1 OF BEGIN
		FORHDR:CNT1[FORHD]_FORCNT;
		FORHDR:CNT2[FORHD]_FORCNT;
		FORHDR:CNT3[FORHD]_FORCNT END;
	   IF (FORCNT_ISCAN) neq S!SPC or SCNVAL neq "," THEN DONE
	END "FORNUM";
	IF FORI<2 THEN ERRSET(1,"A") ELSE FORHDR:TYP[FORHD]_FOR!ARITH+1;
	DUM_FORCNT;
   END "FORARITH" ELSE
   IF DUM=S!SYM THEN
	IF EQU (ACCUM,"IN") THEN BEGIN "FORIN"
	   FORHDR:ARGSTR[FORHD]_READMACROBODY(0,NULL!RECORD,-1,-1);
	   FORHDR:TYP[FORHD]_FOR!WORD+1 END "FORIN" ELSE
	IF EQU (ACCUM,"INCHR") THEN BEGIN "FORINC"
	   FORHDR:ARGSTR[FORHD]_READMACROBODY(0,NULL!RECORD,-1,-1);
	   FORHDR:TYP[FORHD]_FOR!CHR+1 END "FORINC" ELSE
   ERRSET(1,"A") END "FOR2";
IF (FORHDR:TYP[FORHD]_FORHDR:TYP[FORHD]-1) geq 0 THEN BEGIN "EXPFOR"
FORHDR:TEXT[FORHD]_READMACROBODY(ARGN,MATAIL,CATCR,DUM);
IF NXTFOR(FORHD,TRUE,MAG,MAT) THEN
	STARTMAC(MAG,MAT,1,FORHD) END "EXPFOR"
ELSE ERRSET(1,"A") END "FOR";

[19] BEGIN "LISTING"
     NOXMAC_NOXSYM_TRUE;
     WHILE (I_ISCAN) neq S!EOL DO
      IF I neq S!SYM THEN BEGIN ERRSET(0,"U"); DONE END ELSE
      IF EQU(ACCUM,"ON") THEN LSTSW_LSTRMB ELSE
      IF EQU(ACCUM,"OFF") THEN LSTSW_FALSE ELSE
      IF EQU(ACCUM,"MACRO") THEN MACLST_TRUE ELSE
      IF EQU(ACCUM,"NOMACRO") THEN MACLST_FALSE ELSE
      IF EQU(ACCUM,"NESTED") THEN NSTLST_TRUE ELSE
      IF EQU(ACCUM,"UNNESTED") THEN NSTLST_FALSE ELSE
      IF EQU(ACCUM,"TITLE") THEN TITLE_REMLINE ELSE
      IF EQU(ACCUM,"SUBTITLE") or EQU(ACCUM,"SUBTTL") THEN SUBTITLE_REMLINE ELSE
      BEGIN ERRSET(0,"U"); DONE END;
     NOXMAC_NOXSYM_FALSE END "LISTING";
[20][21] ERRSET(1,"O");

[7] BEGIN "DEFINE"
BOOLEAN PRCNTFLAG;
INTEGER CATCR,MACANUM,DUM;
RECORD!POINTER (MACDEF) DFNMAC;
RECORD!POINTER (MACALIST) MP,MAHEAD,MATAIL;

NOXMAC_TRUE;
IF ISCAN neq S!SYM THEN BEGIN NOXMAC_FALSE; ERRSET (1,"A") END
ELSE BEGIN "DEFINE2"
NOXMAC_FALSE;
CRFIT(6,CURSYM);
IF 0 neq SYMBOL:TYP[CURSYM] neq T!MAC THEN BEGIN
   SAVSYM_CURSYM;
   SYMBOL:NEXT[CURSYM_NEW!RECORD(SYMBOL)]_SYMTAB[CURHSH];
   SYMTAB[CURHSH]_CURSYM;
   SYMBOL:NAME[CURSYM]_SYMBOL:NAME[SAVSYM] END;
SYMBOL:TYP[CURSYM]_T!MAC;
SYMBOL:FIXUP[CURSYM]_DFNMAC_NEW!RECORD(MACDEF);
NOXSYM_TRUE;
CATCR_ORG!CAT!CHR;
IF (DUM_ISCAN)=S!SPC and SCNVAL="@" THEN BEGIN "CONCAT"
   DO CATCR_LOP(CURSTR) UNTIL CATCR neq 1;
   DUM_IF CATCR='12 THEN S!NUM ELSE ISCAN
   END "CONCAT";
IF DUM=S!SPC and SCNVAL="(" THEN BEGIN "MACARGS"
   MAHEAD_MATAIL_NEW!RECORD(MACALIST); MACANUM_0;
   WHILE TRUE DO BEGIN "ONEMACARG"
   IF (DUM_ISCAN)=S!SPC and SCNVAL="%" THEN BEGIN DUM_ISCAN;
	PRCNTFLAG_TRUE END ELSE PRCNTFLAG_FALSE;
   IF DUM neq S!SYM THEN BEGIN ERRSET (1,"A"); DONE END;
   MACANUM_MACANUM+1;
   MACALIST:NEXT[MATAIL]_MP_NEW!RECORD(MACALIST);
   MACALIST:ARG[MP]_IF PRCNTFLAG THEN "%"&ACCUM ELSE ACCUM;
   MATAIL_MP;
   IF ISCAN neq S!SPC THEN BEGIN ERRSET(1,"A"); DONE END;
   IF SCNVAL=")" THEN DONE;
   IF SCNVAL neq "," THEN BEGIN ERRSET (1,"A"); DONE END
   END "ONEMACARG";
   MACDEF:ARGN[DFNMAC]_MACANUM;
   MACDEF:ARGS[DFNMAC]_MACALIST:NEXT[MAHEAD] END "MACARGS";
MACDEF:TXT[DFNMAC]_READMACROBODY(MACDEF:ARGN[DFNMAC],
	MACDEF:ARGS[DFNMAC],CATCR,DUM);
NOXSYM_FALSE
END "DEFINE2" END "DEFINE" END "PSEUDO";


[T!SYM] BEGIN "DEFINES"
SAVSYM_CURSYM;
IF (I_ISCAN)=S!SYM and (TY_SYMBOL:TYP[CURSYM])=T!PSD
 and (STY_SYMBOL:SUBTYP[CURSYM])=6 THEN
	BEGIN "EQU"
IF CRFSW and  not PASS1 THEN CRFSTR_CRFSTR&'2;
I_EVLXPR(VAL,VTY,CODVAL,0);
COMSTR(VAL,VTY,CODVAL,SAVSYM,1);
EOLTST(I) END "EQU"

ELSE IF I=S!SYM and TY=T!PSD and STY=5 THEN BEGIN "SET"
IF CRFSW and  not PASS1 THEN CRFSTR_CRFSTR&'2;
I_EVLXPR(VAL,VTY,CODVAL,0);
COMSTR(VAL,VTY,CODVAL,SAVSYM,0);
EOLTST(I) END "SET"

ELSE IF I=S!SPC and SCNVAL=":" THEN BEGIN "COLON"
IF CRFSW and  not PASS1 THEN CRFSTR_CRFSTR&'2;
COMSTR (ASMPC,V!EQU,NULL!RECORD,SAVSYM,1) END "COLON"

ELSE ERRSET(0,"Q") END "DEFINES"
END "MAINSYMBOL" END "MAIN";
DMPBYT(-200); COMMENT GET OUT LAST PART;
IF LSTRMB and PASS1 THEN BEGIN PASS1_FALSE; RPHSAV_RPHEAD;
	LSTSTR_NULL; NXTSRC END ELSE BEGIN "END ASSEMBLY"
SYMSTD_UDFSRC(SRTSYM); COMMENT PRINT UNDEFS and SORT;
	IF RPGSW and ERRCNT=0 THEN LSTTTY_TRUE; COMMENT SUPRESS LISTING;
	ERRST3 ('15&'12&(IF ERRCNT=0 THEN "NO ERRORS DETECTED" ELSE
		IF ERRCNT=1 THEN "1 ERROR DETECTED" ELSE
		CVS(ERRCNT)& " ERRORS DETECTED"));
	ERRST3 ('15&'12&"PROGRAM BREAK IS "&CVHX(2,MAXPC));
JOBERR_JOBERR+ERRCNT;
IF LSTSW THEN PRTSYM(SYMSTD); COMMENT PRINT SYMBOL TABLE;
IF RELSW and  not NOSYMT THEN RELSYM(SYMSTD);
SYMSTD_NULL!RECORD; COMMENT MAKE AVAIL FOR GC;
ARRTRAN(SYMTAB,SAVSYA); CURRAD_SCURRAD; INPRAD_SINPRAD;
FINREL(JOBSA,MINPC,MAXPC);
IF CH!REL geq 0 THEN RELEASE (CH!REL);
IF CH!OUT geq 0 THEN RELEASE (CH!OUT);
CH!REL_CH!OUT_-1;
DONE END;
END "SOURCE GO";
END "SOURCE START"; INCTRU(CURTRU-SAVETRU) END "FILE LOOP";
CALL(0,"EXIT"); END "SYMBOL"
   L 