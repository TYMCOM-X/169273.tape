begin "SUBMIT"

require "SUBMIT.INF"         source!file;

define  SUBMIT!VERSION = (SUBMIT!MAJOR lsh 24) lor SUBMIT!EDIT;
require SUBMIT!VERSION version;

require "(SAILIB)SAIL.DEF"   source!file;
require "(SAILIB)UUOSYM.DEF" source!file;
require "(CARL)JQUEUE.DEF"   source!file;
require "SUBMIT.DEF"         source!file;
require "SUBPAR.REQ"         source!file;
require "SUBMSC.REQ"         source!file;
require "NEXTIM.REQ"         source!file;
require "(CARL)JQUE.REQ"     source!file;
require "(CARL)VMFILE.REQ"   source!file;
require "(CARL)DAYTIM.REQ"   source!file;
require "(CARL)ESCTRP.REQ"   source!file;
require "(CARL)XEXLIC.REQ"   source!file;
require "(CARL)LICSUB.REQ"   source!file;

define VERSION!STRING = { "%"&cvos(SUBMIT!MAJOR)&"("&cvos(SUBMIT!EDIT)&")" };


!	Various definitions
;

define Gettab(x,y)  = { calli( !xwd( (x), (y) ), calli!GETTAB ) };
define Device       = { "DSK" };
define SubmitPrompt = { "SUBMIT> " };
define spaces       = { "                              " } ;
define dashes       = { "--------------------" } ;
define DefaultParam = { "Jobname requ timel usern next" };
define PrtPpn(P)    = { (spaces[1 for 6]&cvos(!lh(P)))[inf-5 to inf]&","
			&(cvos(!rh(P))&spaces)[1 for 6] };

define !CAN         = { " X" };
define !PRO         = { " !" };
define !SCH         = { " +" };
define !HOL         = { " H" };
define !ABO         = { " *" };
define !Late        = { " <" };



string array OneDesc[ 1:31 ];

preset!with JL$$Str;	safe string array ARLog [ 0:JS$$Knt-1 ];
preset!with JD$$Str;	safe string array ARDisp[ 0:JD$$Knt-1 ];
preset!with JM$$Str;	safe string array ARMail[ 0:JM$$Knt-1 ];
preset!with JP$$Str;    safe string array ARMailer[ 0:JP$$Knt-1 ];
preset!with JS$$Str;    safe string array ARSpl[ 0:JS$$Knt-1 ];
preset!with JR$$Str;	safe string array ARRestart[ 0:JR$$Knt-1 ];
preset!with JU$$Str;	safe string array ARUniq[ 0:JU$$Knt-1 ];

preset!with "NO","YES"; safe string array NoYes[ 0:1 ];
preset!with "YES","NO"; safe string array YesNo[ 0:1 ];

preset!with ST$$Off;	safe integer array Stat  [ 0:ST$-1 ];
preset!with ST$$Str;	safe string  array SStat [ 0:ST$-1 ];
preset!with ST$$All;	safe string  array SSStat[ 0:ST$$Knt-1 ];


define NumParams  = 30 ;

! The following are column headings displayed with the LIST command. ;
preset!with 
	     "JobName   "          , "Request"            , "TimeLimit"
,	     "UserName    "        , "PPN          "       , "AUN          "
,	     "Privilege"           , "Next Run       "     , "License"
, "LogFile                       ", "CommandFile                   ", "Label"
,	     "TruLimit"            , "LogLimit"            , "Log       "
,	     "Dispose "            , "Mailer"              , "Spool     "
,	     "Mail"                , "Restart   "          , "Unique"
,	     "CtyLog"              , "Run "                , "Detach"
,	     "Logout"		   , "Priority"		   , "Halt"
,	     "CCL"		   , "Abort"		   , "All";
string array LiPs[ 0:NumParams - 1   ];

! The following declarations are necessary for the LIST command;
define $NEX =  7;		! NEXT RUN;
define $ALL =  NumParams-1;	! ALL;
define $ABO =  NumParams-2;	! ABORT;

! Keep track of which parameters were requested with LIST;
boolean array ListRequests[ 0:NumParams - 1   ];



define NumOptns   = 30 ;
preset!with 	"LABEL",      "TIMELIMIT", "TRULIMIT",  "",        "LOG",
		"LOGLIMIT",   "DISPOSE",   "MAILER",    "SPOOL",   "MAIL",
		"RESTART",    "UNIQUE",    "PARAMETERS","HELP",    "?",
		"ABORT",      "RUN",       "DETACH",    "HALT",    "CTYLOG",
		"PRIORITY",   "LOGOUT",	   "CCL",	"LOGFILE", "LICENSE",
		"DATES",      "EXPRESS",    "DISPLAY",   "TEST",   "SHOW";
string array Options[ 0:NumOptns - 1   ];

define NumExts = 5;	! Cmd file extensions indicating possible RUN YES. ;

preset!with "SAV","SHR","HGH","SWR","EXE";
string array RunExts[ 0:NumExts-1 ];


require " SUBMIT  help messages" message;

define HlpMsg = { 
"
Commands:
  Dates      Takes a date expression
  Insert     Insert job into the job queue
  Display    Displays all dates associated with date expressions
  Express    Rephrases the date expression
  Test       Executes both express and display commands

  Status     Types status of jobs belonging to user
  List       Lists all jobs for this user
  Modify     Modify an existing queue entry
  Delete     Deletes an existing job entry
  Rerun      Reenter an aborted job (possibly run it immediately)
  Requeue    Requeue an aborted job for the next scheduled time
  Version    Type version number
  Quit       Returns to exec
  Help       Types this message 

  Continue   Restart a paused or stopped job
  Pause      Cause a running job to pause
  Stop       Cause a job which is running or paused to stop
  Kill       Kill a running, paused, or stopped job
" };

define LABELHelp = {
"
Label     Name of label in command file from which to restart.  
	  Maximum length is 6 characters.
" };

define TIMELIMITHelp = {
"
Timelimit Maximum elapsed time for one run.
" };

define TRULIMITHelp = {
"
TRULimit  Maximum TRU's allowed for one run.
" };

define LOGLIMITHelp = {
"
LogLimit  Maximum logfile size in pages.
" };

define LOGHelp = {
"
Log       Specify the logging action to be performed.
          Values:
            NONE       No log file.
            APPEND     If a log file exists, then append new text to it.
            SUPERSEDE  Always create a new log file.
" };

define DISPOSEHelp = {
"
Dispose   Specify what to do with the log file after each run.
          Values:
            KEEP       Always KEEP the log file.
            DELETE     Always DELETE upon normal completion.
            NOERROR    Delete upon successful completion.
                       SAVE if job was aborted.
" };

define MAILERHelp = {
"
Mailer    Specify which mailer program to use.
          Values:
            TUMS       Tymnet Universal Mail System.
            RPG        Old mail system.
" };

define SPOOLHelp = {
"
Spool     Not implemented.
" };

define MAILHelp = {
"
Mail      When to send mail to the user who submitted this job.
          Values:
            NONE       Never send mail.
            ERROR      Send mail on error.
            SUCCESS    Send mail on success.
            ALWAYS     Send mail always.  (Default)
" };

define RESTARTHelp = {
"
Restart   Specify restart conditions.
          Values:
            NONE       Never restart.  (Default)
            CHECKPOINT Continue at label specified in command file.
            LABEL      Start at specified label.
            CONTINUE   Pick up from next line in command file.
            REPEAT     Pick up from current line in command file.
" };

define UNIQUEHelp = {
"
Unique    Specify unique conditions for job.
          Values:
            NONE       Job may be run at any time.
            USER       Job must be the only job for this user.
            DIR        Job must be the only job in this directory.
            PATH       Job must be the only job for this user in
                       this directory.
            JOB        Job must be the only job for this user in
                       this directory with this command file name.
" };

define PARAMETERSHelp = {
"
Parameter Specify job parameters.
          These are optional programmable parameters to be passed to
          the job.  Refer to the reference manual for more details.
" };

define HELPHelp = {
"
Help      Type  HELP  or  ?  for a list of valid options.
          Type  HELP option-name  for additional help.
" };

define ABORTHelp = {
"
Abort     Aborts the INSERT or MODIFY command.
" };

define RUNHelp = {
"
Run       Specify whether the job is a command file or a program.
          Vaules:
            NO         If specified file is a program to run. (Default)
            YES        If specified file is a command file.
" };

define DETACHHelp = {
"
Detach    Specify whether the job will have a port for logging output.
          Values:
            NO         Job will have a port connected to it.  (Default)
            YES        Job will run detached (no port).
" };

define HaltHelp = {
"
Halt      Specify whether the job is allowed to halt.
          Special license is required to use this option.
          Values:
            NO         Job will not restart if it halts.  (Default)
            YES        Job will restart if it halts.
                       (The restart option must be specified).
" };

define CTYLOGHelp = {
"
CTYLog    Specify whether job events will be logged to the system CTY.
          Special license is required to use this option.
          Values:
            NO         Job info will not be logged to CTY.  (Default)
            YES        Job info will be logged to CTY.
" };

define PRIORITYHelp = {
"
Priority  Set scheduling priority (1-9).  Default is 0.
          System privileged users may set priority 1-15.
          The default value 0 actually runs at priority 5.
" };

define LogoutHelp = {
"
LOGOUT    Specify that the program to run may log itself out and that
          this condition is NOT to be marked as an error.  If this
          option is not specified and the job logs itself out the job
          is marked with Abort-Logout.
" };

define CCLHelp = {
"
CCL       Specify that the program to run is to be started at the CCL
          address by setting the three character TMPCOR name to read
          when the program is started.
" };

define LOGFILEHelp = {
"
LogFile   Change the log file name.
" };

define LICENSEHelp = {
"
License   Set license on the job.
          Prompts for opername and password to validate license.
" };

define DeleteHelp = {
"
Delete    Delete a job from the queue.  The job may be specified by
          name or by request or by both name and request.
" };

define ComFilHelp = {
"
Enter the name of the command file to use.
" };



preset!with
"
Dates
  Use the command DATES to enter your date expression.  After you type the
  DATES command, SUBMIT will prompt you for the date expression.  The date
  expression is ended when you type a <cr>.  SUBMIT will then examine your
  date expression for correctness and will complain if it finds an error,
  at which point you may try again be re-typing DATES.  If your date
  expression was valid, SUBMIT will return to the SUBMIT prompt, ready for
  another command.  At this point you may want to use the EXPRESS command
  to confirm your date expression, and the DISPLAY command to see if your
  date expression will generate the run dates which you require.

Examples of date expressions.
  EVERY DAY.
  EVERY DAY AT 12:25.
  EVERY OTHER DAY.
  EVERY 3RD DAY AT 19:30.
  EVERY FRIDAY.
  EVERY WEEKDAY AT 8.
  EVERY OTHER FRIDAY.
  THE 23RD DAY OF EVERY MONTH.
  THE 2ND WEDNESDAY OF EVERY MONTH AT 13:45.

NOTE:
  Date expressions are terminated with a <cr>.
  The default run-time is 00:00 (midnight).
  All times are in 24 hour time (3:00 PM = 15:00).
",
"
Insert
  After SUBMIT has accepted your date expression, use the command INSERT
  to insert your job into the job queue.  You may include your command
  file name and your log file name on the command line.

Examples:
  INSERT CmdFil.Ext LogFile.Ext
  INSERT (UserName)CmdFil.Ext (UserName)LogFil.Ext
  INSERT (UserName)LogFil.Ext=(UserName)CmdFil.Ext

If you do not furnish file names then the system will prompt for the name of 
your command file, which must currently exist, and the name for your log file.

If you type a carriage-return (only) at the command-file prompt, then the
insert will be aborted.

NOTE:
  The default command file extension is '.CTL'.
",
"
Display
  After SUBMIT has accepted your date expression, use the command DISPLAY to
  confirm that SUBMIT will generate the run-dates which you require.  Upon
  entering DISPLAY, Submit will display the dates and times of future runs of
  your job as if the job were in the queue at this instant.
",
"
Express
  After SUBMIT has accepted your date expression, use the command EXPRESS
  to get SUBMIT to produce an English sentence to describe what it thinks
  you wanted when you typed your date expression.
",
"
Test
  After SUBMIT has accepted your date expression, use the command TEST to
  check it.  TEST merely executed EXPRESS and DISPLAY.
",
"
Delete
  Use the command DELETE to remove one of your job from the job queue.
  You will have to furnish the job-name (command-file name) and the
  request number so you may want to issue the command LIST to get these
  parameters.

Example:
  DELETE job-name request-number

If you do not furnish job-name and request-number along with the DELETE 
command then the system will prompt for them.  

If you respond with <cr> (only) at the Job-Name prompt You can still DELETE
the job by entering the request number at the request-number prompt.

If you give a valid job name at the Job-Name prompt but give no request
number at its prompt then every job with that job name wil be deleted.
",
"
Status
  Use the command STATUS to determine the current status of one of your 
  previously inserted jobs.
",
"
List
  Use the command LIST to display information on your jobs which are
  currently in the queue.  A list of parameters which may be supplied
  currently with LIST can be obtained by typing  HELP LIST.

Examples:
  LIST
  LIST ALL
  LIST USERNAME JOBNAME COMMANDFILE
  LIST USERNAME REQUEST NEXT TIMELIMIT
  LIST JOBNAME NEXT PRIORITY LOG

Jobs info is listed in columnar form.  Don't try to list more parameters
than your screen has room for.
",
"
Modify
  Use the command MODIFY to change the characteristics of your job.  You
  will have to furnish the job-name (command-file name) and the request
  number so you may want to issue the command LIST to get these parameters.
  You will then will get the options prompt at which you may change any
  parameters which you could normally set during an INSERT.

Example:
  MODIFY job-name request-number

If you do not furnish job-name and request-number then the system will
prompt for them.

If you respond with <cr> (only) at the Job-Name prompt You can still
MODIFY the job by entering the request number at the request-number
prompt.

If you give a valid job name at the Job-Name prompt but give no request
number at its prompt then every job with that job name wil be fetched
for modification.

",
"
Version
  Displays the current program version.
",
"
Quit
  The command QUIT terminates the current session immediately.
",
"
Exit
  The command EXIT terminates the current session immediately.
",
"
Bye
  The command EXIT terminates the current session immediately.
",
"
Help  (or ?)
  Help can be obtained by typing  ? or HELP at any prompt for general
  information.  Specific information can usually be obtained by typing
  HELP command-name   or  HELP option-name.
",
"
Help  (or ?)
  Help can be obtained by typing  ? or HELP at any prompt for general
  information.  Specific information can usually be obtained by typing
  HELP command-name   or  HELP option-name.
",
"
Code
  CODE is no longer available.
",
"
Look
  LOOK will display the date code for the last date expression.
", 
"
Undelete
  Use UNDELETE to un-cancel a cancelled job.

Example:
  UNDELETE job-name request-number
",
"
Show
  Show will retrieve a job from the queue and display information on that
  job.  You will have to furnish the job-name (command-file name) and the
  request number so you may want to issue the command LIST to get these
  parameters.

Example:
  SHOW job-name request-number

If you do not furnish job-name and request-number then the system will prompt
for them.

If you respond with <cr> (only) at the job-name prompt You can still SHOW
the job by entering the request number at the request-number prompt.

If you give a valid job name at the job-name prompt but give no request
number at its prompt then every job with that job name wil be displayed.

",
"
Cancel
  Use the command CANCEL to remove one of your job from the job queue.
  You will have to furnish the job-name (command-file name) and the
  request number so you may want to issue the command LIST to get these
  parameters.

Example:
  CANCEL job-name request-number

If you do not furnish job-name and request-number along with the CANCEL 
command then the system will prompt for them.  

If you respond with <cr> (only) at the job-name prompt You can still CANCEL
the job by entering the request number at the request-number prompt.

If you give a valid job name at the job-name prompt but give no request
number at its prompt then every job with that job name will be canceled.
",
"
Continue
  CONTINUE will re-start a job whose process state is either STOP or PAUSE.
",
"
Pause
  PAUSE will cause a job whose process state is RUN to finish the current
  line and then wait until a STOP, KILL, or CONTINUE command is issued.
",
"
Stop
  STOP will cause a job whose process state is RUN to stop immediately and
  wait until a KILL, or CONTINUE command is issued.
",
"
Kill
  KILL will terminate any running job without removing the job entry from
  the queue.
",
"
Rerun
  RERUN will reset the status of a job that has aborted or otherwise had
  an error that caused the job to abort during execution.  This command
  will simply re-enter the job in the queue.  If the nextrun date is in
  the past the job may be scheduled to run immediately.
",
"
Requeue
  REQUEUE will reset the status of a job that has aborted or otherwise
  had an error that caused the job to abort during execution.  This
  command will re-enter the job in the queue for the next scheduled run
  date in the future.
";
string array CommandsHelp[ 0:NumCmds - 1 ];


internal integer
	JobLic		! Status License enabled for this job ;
;

integer
	GI!CmdNum	! Set in getCommand depending on user's command. ;
,	JobAUN		! AUN (Accounting user number) logged-in director,	UseAUN		! AUN to use for entries ;
,	JobPPN		! PPN [GAN,UUN] connected directory ;
,	UsePPN		! PPN to use for entries ;
,	JobPrv		! Privileges enabled for this job ;
;

string
	MyString	! text of the action to be printed ;
;

internal string
	default,
	JobUser,	  ! actual username for this job ;
	UseUser,	  ! username to use for building records ;
	GS!Params;  	  ! Gets stuff from command line after the command. ;

boolean
	GB!Change	! true if a queue rec was modified, else no need to re-insert;
,	Super;


internal boolean
	DeBug;


internal integer array Template[ 0:E!Length-1 ];    ! a saved copy needed;
integer array Current[ 0:E!Length - 1 ]; 	! latest queue entry fetched;
safe integer array Spec[ S!Dev : S!Ext ];	! used for checking recs ;
integer array CopyForModRec[ 0:E!Length - 1 ];
     ! when an entry is fetched, a copy is made;
     ! immediately so that when a modified version is sent back to the;
     ! queue to overwrite original version, the original version can be;
     ! checked against the CopyForModRec to ensure that the queue entry;
     ! has not been changed by another user in the meantime;

! These are for the case statement in the driver;

define C!DATES    = { [0] };
define C!INSERT   = { [1] };
define C!DISPLAY  = { [2] };
define C!EXPRESS  = { [3] };
define C!TEST     = { [4] };
define C!DELETE   = { [5] [19]};
define C!STATUS   = { [6] };
define C!LIST     = { [7] };
define C!MODIFY   = { [8] };
define C!VERSION  = { [9] };
define C!QUIT     = { [10] [11] [12] };
define C!HELP     = { [13] [14] };
define C!CODE     = { [15] };
define C!LOOK     = { [16] };
define C!UNDELETE = { [17] };
define C!SHOW     = { [18] };
define C!MODACT   = { [20] [21] [22] [23] };
define C!RERUN    = { [24] };
define C!REQUEUE  = { [25] };
define C!USE      = { [26] };
define C!USEM     = { [27] };
define C!USEG     = { [28] };

preset!with "DATES","INSERT","DISPLAY","EXPRESS","TEST","DELETE","STATUS",
	    "LIST","MODIFY","VERSION","QUIT","EXIT","BYE","HELP","?",
	    "CODE","LOOK","UNDELETE","SHOW","CANCEL","CONTINUE","PAUSE",
	    "STOP","KILL","RERUN","REQUEUE","USE","USEM","USEG";
internal string array Commands[ 0:NumCmds - 1 ];

define $CON = { [20] };
define $PAU = { [21] };
define $STO = { [22] };
define $KIL = { [23] };



simple procedure IncLicense;		! put process license back ;
calli( JobLic, calli!SETLIC );



simple procedure DecLicense;		! take process license away ;
begin
    calli( !rh( JobLic ), calli!SETLIC );
end;


simple procedure LoadFileName( integer array Arr; ! Array in which to insert ;
			   string FNStr;    	  ! file name as furnished. ;
			   integer position       ! Where to insert in array. ;
			 );
! ----------------------------------------------------------------------;
!									;
! 		Places username into array positions:			;
!			 position+F!User - position+F!User+1		;
!		filename into position:					;
!			 position + F!Name				;
!		and extention into position:				;
!			 position + F!Ext				;
!									;
!		If FNStr = null then this proc. will clear array.	;
!									;
! ----------------------------------------------------------------------;
BEGIN "Load file name"
    own safe integer array FName[ S!Dev : S!Ext ];

    VMSpec( FNStr, FName );		! Separate file name components ;

    Arr[ position + F!Device ]_ FName[ S!Dev ];
    Arr[ position + F!User+0 ]_ FName[ S!Usr+0 ];
    Arr[ position + F!User+1 ]_ FName[ S!Usr+1 ];
    Arr[ position + F!Name ]_   FName[ S!Nam ];
    Arr[ position + F!Ext ]_    FName[ S!Ext ];


END "Load file name";


simple boolean procedure CheckLog( string FileName ); 
! ----------------------------------------------------------------------;
!									;
! 		See if log file name is a valid file name and		;
! 		make sure it can be opened and entered.			;
!		Do NOT permit anyone without QM license to create	;
!		a log file in directory (SYS).  For security reasons	;
!		QM license implies GAN of 3 for the SUBMIT program.	;
!									;
! ----------------------------------------------------------------------;
BEGIN "CheckLog"
	own safe integer array FName[ S!Dev : S!Ext ];
	integer	eof;

  if ( VMSpec( FileName, FName ) ) then		! check filename format ;
    BEGIN "syntax OK"
    if ( FName[ S!Usr+1 ] = 0 ) and		! user trying to log ;
       ( FName[ S!Usr ] = cvSix( "SYS" ) )	!  to (SYS)? ;
     then if not( ( JobLic land LC!!QM ) and	!  yes, then must have QM ;
		  ( !lh( JobAun ) = 3 ) )	!         and be in GAN 3 ;
	   then BEGIN
	      print( " Cannot write logfile to SYSTEM directory" );
	      return( false );
	   END;
    DecLicense;					! forget special license ;
    eof_ VMFile( FileName, VM$Write );		! eof gets -1, can't enter. ;
    if ( 0 < eof )
     then VMFree( eof, CL!Acs lor CL!Rst )	! Release the channel. ;
     else if ( !rh( eof ) = !ERFBM )		! file being modified? ;
	   then if ( 0 < eof_ VMFile( FileName, VM$Read ) )
		 then VMFree( eof, CL!Acs lor CL!Rst );
    IncLicense;					! get license back ;
    return( 0 < eof );				! true if enter succeeded. ;
    END "syntax OK"
  else
    BEGIN
    print( " Illegal logfile name" );
    return( false );
    end;

END "CheckLog";


simple boolean procedure ComIsOK( reference string FileName );
! ----------------------------------------------------------------------;
!									;
! 		See if the file 'FileName' is syntacticly OK and	;
! 		See if the file 'FileName' exists.			;
!									;
! ----------------------------------------------------------------------;
BEGIN "ComIsOK"
    own safe integer array FName[ S!Dev : S!Ext ];
    integer	NotFound;	! Becomes true if open or lookup fails. ;

  if ( VMSpec( FileName, FName ) ) then	! check file name format ;
    BEGIN "syntax OK"

    DecLicense;				! forget special license ;
    if ( 0 geq NotFound_ VMFile(FileName, VM$Read) ) then
      BEGIN "try extension"		! file wasn't found ;

      if not( FName[ S!Ext] ) then	! if there was no extension ;
        BEGIN "add extension"		!  then try filename.CTL ;
        NotFound_ VMFile( FileName_ FileName & ".CTL", VM$Read );
        END "add extension";

      if ( 0 geq NotFound ) then	! Still not found, so complain. ;
        BEGIN "bad filename"
        print( crlf,"Cannot find """, FileName[ 1 to inf-3 ] );
        if not( FName[ S!Ext] ) then
          print( """ or """, FileName );
        print( """.", crlf );
	IncLicense;
        return( false );
        END "bad filename";

      END "try extension";

    ! A command file was located. ;
    VMFree( NotFound, CL!ACS lor CL!RST );
    IncLicense;
    return( true );
    END "syntax OK"
  else
    BEGIN "weird filename"
    print( " Illegal file name" );
    return( false );
    END "weird filename";

END "ComIsOK";


simple integer procedure RunLocal( integer date );
return( CvtDTM( date, LPZone( JobPrv ), '20 ) );


simple string procedure LocalRun( integer array QRec; reference boolean late );
! ----------------------------------------------------------------------;
!									;
!	LocalRun simply gets the next-run date/time from the record.	;
!	Returns date/time as a string in users local time zone.		;
!									;
! ----------------------------------------------------------------------;
BEGIN "LocalRun"
    integer UserLocalTime;

  late_ false;				! initially on-time ;

  if ( LPPStat( QRec ) = ST$Proc )	! See if the job is active ;
   then return( "--Active--" );		!  Yes, it is in progress ;

 if ( Qrec[ E!RunTime ] = -1 )		! See if the job is at 'startup';
   then return( "--Startup--" );	!  Yes, so let them know ;

  late_ ( QRec[ E!Runtime ] < GetTDT );	! run time past? ;

  UserLocalTime_ RunLocal( QRec[ E!Runtime ] );

  if UserLocalTime = 0 then		! No run Date/Time for some reason;
    return( "--Unknown--" );		! So assume that job is about to ;

  return( TymDay( UserLocalTime ) );	! return what we calculated.;

END "LocalRun";


simple procedure RequestInfo( integer array QRec );
! ----------------------------------------------------------------------;
!									;
!	RequestInfo( Current )						;
!		Print a formatted JOBNAME req# nnn (username) line	;
!		for the given job queue record.				;
!									;
! ----------------------------------------------------------------------;
begin "request info"

    print( "  ", Cvxstr( QRec[ E!CmdFile + F!Name ] ), "  req# ",
	   ("        "& cvs( LPPReq( QRec ) )[inf-7 to inf]
	 );

    if ( JobLic land LC!!QM ) or ( JobPrv land JP!ASV )
     then print( "  (", cv6str( QREc[ E!Username ] ),
			cv6str( QRec[ E!Username+1 ],
		 ")" );

    print( crlf );

end "request info";


simple procedure DisplayARec( integer array QRec );
! ----------------------------------------------------------------------;
!									;
!		Displays info for a job pulled from queue.		;
!									;
! ----------------------------------------------------------------------;
BEGIN "show one record"
	integer BP,		! Byte pointer. ;
		BPI,		! Byte pointer index. ;
		ch,		! One character. ;
		num;		! Gets all kinds of things. ;
	string  parameters,	! For assembling PARAMETERS string. ;
		temp;		! ;
	boolean late,		! Becomes true if next run is in the past. ;
		NewLineYet;

  print( crlf &"Job: ",Cvxstr( QRec[ E!CmdFile + F!Name ] ) );	! JOB NAME ;
  print( "  ", InfJob( location( QRec[ E!Runtime ] ) ) );	! Request  ;


  print( Crlf &"Username: ",			        	! USERNAME ;
	 cv6str( QRec[ E!Username ] ), cv6str( QRec[ E!Username+1 ] ),
	 (if ( QRec[ E!AUN ] neq QRec[ E!PPN ] )	! GFD if different ;
	   then " ("& CvName( QRec[ E!PPN ] ) &")"
	   else null)  );
  if ( num_ QRec[ E!Network ] )					! NETWORK ;
   then print( "  Node:",
	cvos( (ldb( point(8,num,19) ) lsh 6) + ldb( point(6,num,27) ) ),
	(if ( num land '177 ) then "-"&cvos( num land '177 ) else null),
	" TID=", (case ldb( point(5,num,11) ) of (
		    "Aux", "A", "C", "E", "G", "B", "F", "J", "N", "<cr>",
		    "D", "I", "1200", "B1200", "Gateway-Aux", "Baudot",
		    "2400", "3270", "3270P", "4800", "9600", "M-PVC", "Audio",
		    "Video", "30","31","32","33","34","35","36","37" ) )
	);
  if ( QRec[ E!Project ] ) then					! PROJECT ;
    print( "  Project:",CvStr( QRec[ E!Project ] ),
			CvStr( QRec[ E!Project + 1 ] ),
			CvStr( QRec[ E!Project + 2 ] ) );


  print( crlf &"Limits:   Time:",				! TIMELIMIT ;
	 (if ( num_ LPPTimL( QRec ) )
	   then CvsTim( ( num lsh 18 ) DIV 1440 )
	   else "no limit" )
       );
  print( "  TRU:", (if ( num_ QRec[ E!TruLim ] )		! TRU LIMIT ;
		    then cvs(num) else "no limit" ) );
  if ( num_ LPPLogL( QRec ) )					! LOG LIMIT ;
   then print( "  LogSize:", num );
  print( "  Pri:", cvs( LPPJPri( QRec ) ) );			! PRIORITY ;

  if ( length( temp_ Cv6Str( LPPCCLF( QRec ) lsh 18 ) ) )	! CCL ;
   then print( "   CCL file:", temp );


  print( Crlf &"Options:  "&		! ** this line is 80 chars max ** ;
	"Log:",       ARLog[ num_ LPPLog( QRec ) ],		! LOG ;
	(if ( num )	! num = log option ;
	  then " Dispose:"& ARDisp[ LPPDisp( QRec ) ]		! DISPOSE ;
	  else null ),
!	" Spool:",   ARSpl[ LPPSpl( QRec ) ],			! SPOOL ;
	" Mail:",    ARMail[ LPPMail( QRec ) ],			! MAIL ;
!	" Mailer:",  ARMailer[ LPPMPrg( QRec ) ],		! MAILER ;
	" Restart:", ARRestart[ LPPRestart( QRec ) ],		! RESTART ;
	" Unique:",  ARUniq[ LPPUniq( QRec ) ]			! UNIQUE ;
	);

  temp_ null;
  if ( LPPRunf( QRec ) )					! RUN ;
   then temp_ temp & "Run  ";
  if ( LPPDetf( QRec ) )					! DETACH ;
   then temp_ temp & "Detach  ";
  if ( LPPLogF( QRec ) )					! LOGOUT ;
   then temp_ temp & "Logout  ";
  if ( LPPHaltf( QRec ) )					! NO HALT ;
   then temp_ temp & "No Halt  ";
  if ( LPPCtyF( QRec ) )					! CTYLOG ;
   then temp_ temp & "CTYLog  ";
  if ( length( temp ) )
   then print( crlf &"Flags:    ", temp );


  ! License if there is any ;
  if ( num_ !rh( QRec[ E!License ] ) )				! LICENSE ;
   then print( crlf&"License:  ",  LicPrt( num ) );


  Parameters_ null;						! PARAMETERS ;
  BP_ Point( 7, QRec[ E!Parameters ], -1 );
  For BPI_ 1 upto E!ParLength do 			! Assemble parameter ;
    If ( Ch_ Ildb( BP ) ) then				!   string. ;
      Parameters_ Parameters & Ch;
  if ( length( Parameters ) ) then			! If there were ;
    print( crlf &"Param(s): ", Parameters );		!  print any params. ;

  print( crlf &"Period:   ");					! EXPRESSION ;
  if ( 0 = LDB( PConn( QRec[ E!Descriptor + D!Type ] ) ) )
   then print( " IMMEDIATELY. "& crlf )		! No expression on INSERT ;
   else Express( QRec );			!  else give description ;

  print( "Run date: ", LocalRun( QRec,late ) );			! NEXT DATE ;
  print( if ( late ) then " * " else "   " );
  print( ("        "&SStat[num_ LPPStat(QRec)])[inf-12 to inf],	! STATUS   ;
	 "-", (SSStat[ LPPProc( QRec )+Stat[num] ]&"      ")[1 for 9] );


  if ( QRec[ E!Rantime ] )
   then print( crlf& "Last run: ", TymDay( RunLocal( QRec[ E!Rantime ] ) ) );

  print( crlf );				! final end of line ;

END "show one record";


simple boolean procedure GetOptions( boolean CalledFromMODIFY );
! ----------------------------------------------------------------------;
!									;
!	Prompt user for options before insertion.			;
!	Returns false if user types "ABORT" at the "OPTIONS:" prompt.	;
!	If "CalledFromMODIFY" parameter is passed non-zero then this	;
!	  procedure was called from ModJob, else it was called due	;
!	  to a regular insert.						;
!									;
! ----------------------------------------------------------------------;
BEGIN "getoptions"
	integer OptNum,		! Array position in Options array of an OPTION;
		Num,		! Holds number supplied as a parameter. ;
		WantLic,	! holds license wanted. ;
		HaveLic,	! holds license from OPER file. ;
		BP,		! Byte pointer. ;
		BPI;		! Byte pointer index. ;
	string	Reply,		! Response at OPTIONS prompt. ;
		FirstWord,	! First word from reply. ;
		Param,		! Gets the rest of Reply. ;
		Labl,		! Gets 2nd word of Reply for LABEL option. ;
		Parameters,	! Used with PARAMETERS option. ;
		OperName,	! Used with LICENSE option. ;
		LogFile,	! Used when changing log file. ;
		ComFile;	! Used for change in command file. ;

simple procedure OptionsMenu;
! ----------------------------------------------------------------------;
!									;
!		Print the options HELP menu.				;
!									;
! ----------------------------------------------------------------------;
BEGIN "OptionsMenu"

  ! Print the heading. ;
  print( crlf,"     Option           Values [Current setting]" );
  print( crlf,"     -------          ------" );

  ! One horizontal line for each option with an aray of parameters.  ;
  OpLine( "Log    ", LPPLog( Current ),    ARLog     );
  OpLine( "Dispose", LPPDisp( Current ),   ARDisp   );
  OpLine( "Mail   ", LPPMail( Current ),   ARMail    );
  OpLine( "Mailer ", LPPMprg( Current ),   ARMailer,  PRV$INV );
  OpLine( "Restart", LPPRestart( Current ),ARRestart );
  OpLine( "Run    ", LPPRunf( Current ),   NoYes     );
  OpLine( "Detach ", LPPDetf( Current ),   NoYes     );
  OpLine( "Logout ", LPPLogf( Current ),   NoYes     );
  OpLine( "Halt   ", LPPHaltf( Current ),  YesNo,     PRV$INV lor PRV$QM );
  OpLine( "CtyLog ", LPPCtyf( Current ),   NoYes,     PRV$INV lor PRV$QM );
  OpLine( "Unique ", LPPUniq( Current ),   ARUniq    );
  print( crlf );

  ! CCL option. ;
  reply_ Cv6Str( LPPCCLF( Current ) lsh 18 );
  if equ( reply, null ) then
    reply_ "None";
  print( crlf&"      CCL              ", reply ); 

  ! LABEL option. ;
  print( crlf&"      Label            " );
  if Current[ E!Label ] land ( '77 lsh 30 ) then
    print( Cv6Str( Current[ E!Label ] ) )
  else
    print( "#" & cvs( Current[ E!Label ] ) );

  ! Misc options. ;
  print( crlf&"      Priority         ", LPPJPri( Current ) );
  print( crlf&"      TimeLimit        ", LPPTiml( Current ), " minutes." );
  print( crlf&"      LogLimit         ", LPPLogl( Current )," minutes." );
  print( crlf&"      TruLimit         ", Current[ E!TRULim ], " TRUs." );

  ! PARAMETERS option. ;
  print( crlf&"      Parameters       " );
  Parameters_ null;				! Clear. ;
  BP_ Point( 7, Current[ E!Parameters ], -1 );	! Get byte pointer. ;
  For BPI_ 1 upto E!ParLength do		! String them together. ;
    if ( ILDB( BP ) ) then
      Parameters_ Parameters & LDB( BP );

    if ( length( Parameters ) = 0 ) then	! If there aren't any;
      print( "[none]" )				!   then say so ;
    else					! else ;
      print( "[",Parameters,"]" );		!   display them. ;
  if ( !rh( Current[ E!License ] ) ) then	! if any license, print it ;
    print( crlf&"      License          ",LicPrt(!rh(Current[ E!License ])) );

  print( crlf&crlf &"Type 'option-name ?'  for help with an option."&
	 crlf      &"     'Abort'          to exit without inserting."&
	 crlf      &" or  <return>         to insert."&
	 crlf );

END "OptionsMenu";

simple procedure Helper( string OptionName );
! ----------------------------------------------------------------------;
!									;
!		Called when user types HELP option-name st OPTIONS	;
!									;
! ----------------------------------------------------------------------;
BEGIN "help for specific option"
  OptNum_ FndKey( OptionName, Options );	! Find out which option. ;
  case OptNum of				! Display appropriate help. ;
    BEGIN "which option"
    print( LABELHelp  );
    print( TIMELIMITHelp  );
    print( TRULIMITHelp  );
    ;
    print( LOGHelp  );
    print( LOGLIMITHelp  );
    print( DISPOSEHelp  );
    ; ! print( MAILERHelp  );
    ; ! print( SPOOLHelp  );
    print( MAILHelp  );
    print( RESTARTHelp  );
    print( UNIQUEHelp  );
    print( PARAMETERSHelp  );
    print( HelpHelp );
    print( HelpHelp );
    print( ABORTHelp  );
    print( RUNHelp  );
    print( DETACHHelp  );
    print( HALTHelp  );
    print( CTYLOGHelp  );
    print( PRIORITYHelp  );
    print( LogoutHelp  );
    print( CCLHelp  );
    ;  ! print( LOGFILEHelp  );
    print( LICENSEHelp  );
    else if kequ( GS!ERR, null ) then
           print( "UNIDENTIFIED OPTION: '",OptionName,"'." )	! None such. ;
         else
	   print( GS!ERR )
    END "which option";
  print( crlf );

END "help for specific option" ;

simple boolean procedure NoConflicts;
! ----------------------------------------------------------------------;
!									;
!		Improper parameter combinations must prevent insertion.	;
!									;
! ----------------------------------------------------------------------;
BEGIN "NoConflicts"

  ! If Run if not set then there can be no detach. ;
  if LPPRunf( Current ) = 0 then	! Run is NO. ;
    BEGIN
    if LPPDetf( Current ) then		! But DETACH is YES. ;
      BEGIN				
      print( crlf, "DETACH CANNOT BE 'YES' IF RUN IS 'NO'. " );	! Complain. ;
      print( crlf );
      return( false );				! Can't insert, just return. ;
      END;
    END;

  return( true );		! Can't get to here unless no conflicts. ;

END "NoConflicts";


! ----------------------------------------------------------------------;
!		MAIN of GetOptions. 					;
! ----------------------------------------------------------------------;

! See if GetOptions was called from MODIFY rather than INSERT. ;
if not CalledFromMODIFY then	! GetOptions must have been called from INSERT;
  BEGIN "load defaults"		! so set parameters with standard defaults. ;
	string Extension;

  if not( InQue land que$Open )		! is the queue open already? ;
   then if not( OpnQue ) then		! read defaults from queue ;
	 BEGIN
	    print( "Job queue cannot be accessed at this time."& crlf &
		   "Please contact your system support organization."& crlf );
	    return( false );
	 END;

  Current[ E!Label ]_ 0;
  Current[ E!TRULim ]_ QQ( TRULim );	! Code to produce ILL MEM REF message.;
  Current[ E!LogLim ]_ QQ( LogLim );
  Current[ E!Action ]_ QQ( Action );

  ! See if specified command file name implies RUN YES (i.e. .SAV, .HGH, etc.);
  Extension_ cv6Str( Current[ E!CmdFile+F!Ext ] );
  if ( -1 < Vik( RunExts, Extension ) )
   then DPB( 1, PPRunf( Current ) );		   ! Yes, so set RUN YES. ;

  if Current[ E!LogFile + F!User ] = 0 then 	   ! No log file specified,   ;
    BEGIN
    if LPPRunF( Current ) then			   ! if run-bit set then;
      DPB( 1, PPDetF( Current ) );		   !   run detach;
    DPB( JL$None, PPLog( Current ) );		   !  so default must be none.;
    END
  else						   ! else		;
    DPB( JL$Supersede, PPLog( Current ) );	   ! Ask Carl. ;

  END "load defaults";

  ! Macro for checking validity of parameters supplied with a valid option. ;
  Define SetOpVal( OpNum, OpVal ) = {
  if ( 0 > OpNum_ FndKey( OpStr_ LopWrd( Reply ), OpVal ) ) then
    BEGIN
    print( OpStr," IS NOT A VALID PARAMETER FOR ",options[OptNum]," OPTION.", crlf );
    OpNum_ 0;
    END
  };

  ! Only re-insert rec pulled from queue for modify if it is changed. ;
  GB!Change_ false;			

  ! Display options prompt then evaluate response, inserting in rec if OK;
  while true do
    BEGIN "ask for options"
	string OpStr;

    print( "OPTIONS[Insert]: " );	     ! Get option and param.;
    Reply_ inchwl;

    if !skip! = #EOT then			! ^D gives QM lic. ;
      BEGIN "set lic"
      JobLic_ JobLic xor LC!!QM;
      continue;					! re-prompt after ^D. ;
      END "set lic"
    else
      if !skip! = #SUB then			! ^Z force immediate exit.;
	AUS
      else					! else if user wants to insert;
        if ( length( Reply ) = 0 ) then		! then <cr>(only) typed. ;
          if NoConflicts then			! If no conflicting parameter ;
            done				!  settings then leave loop ;
          else					!  to insert ;
	    BEGIN				! else conflicts were not ;
	    print( "CANNOT INSERT",crlf,#lf );	!  resolved so complain and;
            continue;				!  back to OPTIONS prompt. ;
	    END;

    FirstWord_ LopWrd( Reply );			     ! Get first word. ;
    Param_ reply;				     ! Save the rest. ;

    OptNum_ Vik( Options, FirstWord ) ;
    if OptNum neq -1 and not CryForHelp( FirstWord ) then
      GB!Change_ true;			! Valid and not HELP so assume change.;

    case OptNum  of 				 ! 1st word an option? ;
      BEGIN					     
      [ 0 ]  BEGIN					! LABEL .;
	     Labl_ LopWrd( Reply )[1 for 6];	   	! 1st 6 chars only. ;
	     Current[ E!Label ]_ CvSix( Labl );	
	     END;
      [ 1 ]  BEGIN					! TIMELIMIT .;
		num_ intscan( Reply,BrkChr );		! Look for integer. ;
		if BrkChr = -1 then			! Not integer. ;
		  BEGIN					! error ;
		  print( crlf, "?",Param, "? TIMELIMIT MUST BE IN MINUTES (INTEGER). ", crlf );
		  continue;
		  END
		else
		  DPB( num, PPTimL( Current ) ) ;	! else use it. ;
             END;
      [ 2 ]  BEGIN					! TRULIMIT .;
		num_ intscan( Reply,BrkChr );		! look for integer. ;
		if BrkChr = -1 then			! If not integer ;
		  BEGIN					! error ;
		  print( crlf &"?",Param,"? Requires integer only."& crlf );
		  continue;
		  END
		else
		  Current[ E!TruLim ]_ num;		! else use it. ;
             END;
      [ 4 ]  BEGIN					! LOG ACTION .;
	     if ( Current[ E!LogFile + F!Name ] )	! must have logfile ;
	      then begin "legal to change default"
		 SetOpVal( num, ARLog );		! See if valid. ;
		 DPB( num, PPLog( Current ) );		! yes, so insert ;
	      end "legal to change default"
              else print( crlf &"?No log file, cannot set LOG option"& crlf );
             END;
      [ 5 ]  BEGIN					! LOGLIMIT .;
	     if ( Current[ E!LogFile + F!Name ] )	! must have logfile ;
	      then begin "legal to change default"
		num_ intscan( Reply,BrkChr );		! Look for integer. ;
		if BrkChr = -1 then			! Not found. ;
		  BEGIN					! So complain. ;
		  print( crlf, "?",Param, "? LOGLIMIT must be in minutes."& crlf );
		  continue;
		  END
		else
		  DPB( num, PPLogL( Current ) ) ;	! So use it. ;
	      end "legal to change default"
              else print( crlf &"?No log file, cannot set LOGLIMIT option"& crlf );
             END;
      [ 6 ]  BEGIN					! DISPOSE .;
             SetOpVal( Num, ARDisp );
	     DPB( Num, PPDisp( Current ) );
	     END;
      [ 7 ]  BEGIN					! MAILER .;
!             SetOpVal( Num, ARMailer );
!	     DPB( Num, PPMprg( Current ) );
	     END;
      [ 8 ]  BEGIN					! SPOOL .;
!	     SetOpVal( Num, ARSpl );
!	     DPB( Num, PPSpl( Current ) );
	     END;
      [ 9 ]  BEGIN					! MAIL .;
             SetOpVal( Num, ARMail );
	     DPB( Num, PPMail( Current ) );
	     END;
      [ 10 ]  BEGIN					! RESTART .;
             SetOpVal( Num, ARRestart );
	     DPB( Num, PPRestart( Current ) );
	     END;
      [ 11 ]  BEGIN					! UNIQUE .;
             SetOpVal( Num, ARUniq );
	     DPB( Num, PPUniq( Current ) );
	     END;
      [ 12 ] BEGIN					! PARAMETERS .;
		Parameters_ Reply;	! Everything past the word PARAMETERS.;
		if ( length( Parameters ) > E!ParLength ) then ! Too long. ;
		  print( "PARAMETERS MUST BE 1-",E!ParLength,
			 " CHARACTERS LONG", crlf )
		else
                  BEGIN "insert parameters"
                  BP_ Point( 7, Current[ E!Parameters ], -1 );
                  For BPI_ 1 upto E!ParLength do 
                    IDPB( lop( Parameters ), BP );
		  if ( LPPRunF( Current ) and not( LPPCCLF( Current ) ) )
		   then DPB( Current[E!CmdFile+F!Name] lsh -18,
			     PPCCLF( Current ) );
                  END "insert parameters";
              END;
      [ 13 ]  [ 14 ] 
             BEGIN					! HELP - ? .;
	     if Kequ( Param, null ) then	! Was HELP by itself? ;
	       OptionsMenu			! Yes, so show whole help. ;
	     else				! else HELP was followed by ;
	       Helper( Param );			!   an option-name so show;
	     END;				!   HELP for that option only.;
      [ 15 ] Return( false );				! ABORT .;
      [ 16 ] BEGIN					! RUN .;
	     OpStr_ LopWrd( Reply );			! Get the rest. ;
	     if kequ( OpStr, null ) then		! No param means 'yes';
	       DPB( 1, PPRunf( Current ) )		! Set RUN YES. ;
	     else
	       BEGIN "Param supplied"
	       num_ Vik( NoYes, OpStr );	! See if YES or NO. ;
	       if OptNum = -1 then		! Not YES or NO so error. ;
	         BEGIN "complain"
	         print( OpStr," IS NOT A VALID PARAMETER FOR " );
	         print( options[OptNum]," OPTION.", crlf );
	         END "complain"
	       else
	         DPB( num, PPRunf( Current ) ) ; ! OK so insert. ;
	       END "Param supplied";

	     if LPPRunf( Current ) = 0 then		! If RUN is NO; 
	       BEGIN "detach should not be yes"
	       if LPPDetf( Current ) then		! and DETACH is YES ;
	         BEGIN "resolve the conflict"		! fix. ;
		 reply_ prompt( "CHANGE DETACH TO 'NO' [y] " );
		 num_ Vik( NoYes, reply ); 	! If YES response or <cr> then;
		 if num = 1 or length( reply ) = 0 then	! set DETACH to NO. ;
		   DPB( 0, PPDetf( Current ) ) ;	! else leave for now. ;
		 END "resolve the conflict";
	       END "detach should not be yes";
	     END;
      [ 17 ] BEGIN					! DETACH .;
	     if not( Current[ E!LogFile+F!Name ] )	! Cannot have LOGFILE;
	      then begin "ok to detach"
		 OpStr_ LopWrd( Reply );		! Get supplied param. ;
		 if kequ( OpStr, null ) then		! No param means 'yes';
		   DPB( 1, PPDetf( Current ) )		!   so load YES. ;
		 else
		   BEGIN "validate the param"
		   num_ Vik( NoYes, OpStr );		! YES or NO? ;
		   if OptNum = -1 then			! Something else so ;
		     BEGIN				!   error.;
		     print( OpStr," IS NOT A VALID PARAMETER FOR " );
		     print( options[OptNum]," OPTION.", crlf );
		     END
		       else
		     DPB( num, PPDetf( Current ) ) ;	! else use it. ;
		   END "validate the param";

		 if LPPDetf( Current ) then		! If DETACH = YES ;
		   BEGIN
		   if LPPRunf( Current ) = 0 then	! and RUN = NO ;
		     BEGIN				! Ask user. ;
		     reply_ prompt( "CHANGE 'RUN' TO 'YES' [y] " );
		     num_ Vik( NoYes, reply );		! YES/NO? ;
		     if num = 1 or length( reply ) = 0 then ! If YES of <cr> then ;
		       DPB( 1, PPRunf( Current ) ) ;	! change RUN to YES. ;
		     END;
		   END;
	      end "ok to detach"
	      else print( crlf &"?Cannot detach if writing a log file"& crlf );
	     END;
      [ 18 ] BEGIN					! HALT .;
             OpStr_ LopWrd( Reply );		! Get next word from reply;
	     if kequ( OpStr, null ) then		! No param means 'yes';
	       DPB( 0, PPHaltf( Current ) )		! So HALT = YES. ;
	     else
	       BEGIN
	       num_ Vik( YesNo, OpStr );
	       if OptNum = -1 then
	         BEGIN
	         print( OpStr," IS NOT A VALID PARAMETER FOR " );
	         print( options[OptNum]," OPTION.", crlf );
	         END
	       else
	         DPB( num, PPHaltf( Current ) ) ;
	       END;
	     END;
      [ 19 ] BEGIN					! CTYLOG .;
             OpStr_ LopWrd( Reply );		! Get next word from reply. ;
             if JobLic land LC!!QM then		! Check for QM license. ;
	       BEGIN "enough lic"		! OK so validate response. ;
	       if kequ( OpStr, null ) then		! No param means 'yes';
	         DPB( 1, PPCtyf( Current ) ) 	! so CTY gets YES. ;
	       else
	         BEGIN "check the param"
	         num_ Vik( NoYes, OpStr );	! YES/NO? ;
	         if OptNum = -1 then		! no, so error. ;
	           BEGIN "bitch bitch bitch"
	           print( OpStr," IS NOT A VALID PARAMETER FOR " );
	           print( options[OptNum]," OPTION.", crlf );
	           END "bitch bitch bitch"
	         else
	           DPB( num, PPCtyf( Current ) ) ; ! Make CTY = YES.;
                 END "check the param";
	       END "enough lic"
	     else
	       print( crlf, "? Requires QM", crlf,#lf );	! No QM. ;
	     END;
      [ 20 ] BEGIN					! PRIORITY .;
		num_ intscan( Reply,BrkChr );		! Get rest of reply. ;
		if BrkChr = -1 then			! Should be integer. ;
		  BEGIN "missing integer"
		  print( crlf, "?",Param,"? Requires integer only.", crlf );
		  continue;
		  END "missing integer"
		else
		  BEGIN "see if priority is OK"
	          if not JobLic land LC!!QM then		! If not QM lic ;
		    ! See if priority is within valid range for non-QM. ;
		    if not( JP$Min leq num leq (JP$Sys-1) ) then
			print( crlf,"PRIORITY MUST BE BETWEEN ",
			 JP$Min," AND ", JP$Sys-1,".", crlf )
		    else			 	! else it's within ;
		      DPB( num, PPJPri( Current ) )	!  range so use it. ;
                  else
		    ! See if priority is within valid range for those with QM.;
		    if not( JP$Min leq num leq JP$Max ) then
			print( crlf,"PRIORITY MUST BE BETWEEN ",
			 JP$Min," AND ", JP$Max,".", crlf )
		    else				! else it's within ;
		      DPB( num, PPJPri( Current ) ) ;	!  range so use it. ;
		  END "see if priority is OK";
             END;
      [ 21 ] BEGIN					! Logout. ;
             OpStr_ LopWrd( Reply );
	     if kequ( OpStr, null ) then		! No param means 'yes';
	       DPB( 1, PPLogf( Current ) ) 
	     else
	       BEGIN
	       num_ Vik( NoYes, OpStr );		! Validate the param. ;
	       if OptNum = -1 then			! -1 means invalid. ;
	         BEGIN "boo boo"
	         print( OpStr," IS NOT A VALID PARAMETER FOR " );
	         print( options[OptNum]," OPTION.", crlf );
	         END "boo boo"
	       else
	         DPB( num, PPLogf( Current ) ) ;	! OK, so use it. ;
               END;
	     END;
      [ 22 ] BEGIN					! CCL. ;
             OpStr_ LopWrd( Reply );
	     if kequ( OpStr, null ) then		! No param ;
		DPB( Current[E!CmdFile+F!Name] lsh -18, PPCCLF( Current ) )
	     else
	       BEGIN
	       if length( OpStr ) neq 3 then		! Max = 3 chars. ;
	         BEGIN
	         print( OpStr," IS NOT A VALID PARAMETER FOR " );
	         print( options[OptNum]," - MUST BE  3 CHARACTERS", crlf );
	         END
	       else
                 DPB( CvSix( OpStr ) lsh - 18,PPCCLF( Current ) ) ;
 	       END;
 	     END;
      [ 23 ] BEGIN					! New LOGFILE. ;
	     continue;				! *** No longer allowed *** ;
             OpStr_ LopWrd( Reply );	  ! OpStr will be new log file name. ;
	     if kequ( OpStr, null ) then	! Nothing supplied after ;
	       BEGIN "get rid of log file"	!   LOGFILE = remove logfile. ;
	       LoadFileName( Current, null, E!LogFile ); ! So load with null.;
	       print( "Log-File designation removed.",crlf ); ! Break the news;
	       END "get rid of log file"
	     else					! else user wants a ;
	       BEGIN "New log file"			!   log file. ;
	       if EqSign( OpStr, ComFile ) then		! Str=Str format?;
	         BEGIN "new command file"		! Yes, so insert the;
		 if ComIsOK( ComFile ) then		!  command file part ;
		   BEGIN "insert Ctl file name"		!  if it is valid.;
		   LoadFileName( Current,ComFile,E!CmdFile );
		   print( "Command file name changed.",crlf );
		   END "insert Ctl file name"
		 else				     ! Ctl file part was bad. ;
		   print( " ?New command file name was not understood.",crlf );
		 END "new command file";

	       LogFile_ OpStr;	   ! Do logfile part regardless of the above. ;
      	       if CheckLog( LogFile ) then 		! Log file valid? ;
		 BEGIN "insert LogFile"			! Yes so insert. ;
		 LoadFileName( Current, LogFile, E!LogFile );
		 print( "Log-File name changed."& crlf );
		 END "insert LogFile"
	       else		! Bogus log file so complain and forget it. ;
		 print( " ?New Log-File name was not understood."& crlf );
	         
	       END "New log file";
           END;
      [ 24 ] BEGIN					! License ;
	     WantLic_ LicRd( Reply );			!  if specified ;
	     if not( WantLic )				! must want it ;
	      then WantLic_ !rh( JobLic );
	     GetOpr( Current[ E!OperName ], OperName_ null );
	     if ( LicChk( HaveLic_ GetLic( Current[ E!OperName ], Num_ 0 ),
			  WantLic ) )
	      then Current[ E!License ]_ LicVal( HaveLic, WantLic )
	      else print( " ?No license set for Job."& crlf );
	     END;
      [ 25 ] BEGIN					! Date Expression;
             GS!Params_ Param;		! Expression may be on same line as DATES command.;
             GetExpFromUser( false, Current );	! User give date expression .;
             END;
      [ 26 ] BEGIN					! Express ;
             Express( Current );
             END;
      [ 27 ] BEGIN					! DISPLAY ;
             Display( Current );
	     Inchwl;		! Must clear else stray #lf will cause insert;
             END;
      [ 28 ] BEGIN					! TEST ;
             Test( Current );
	     Inchwl;		! Must clear else stray #lf will cause insert;
             END;
      [ 29 ] BEGIN					! SHOW ;
	     DisplayARec( Current );	! display record ;
	     END;
      else BEGIN		! Option specified was unknown. ;
           if length( GS!Err ) = 0 then		! If nothing in error string. ;
             print( "UNRECOGNIZED OPTION - TYPE 'HELP' FOR HELP", crlf )
           else
	     BEGIN "display error string"
	     print( GS!Err, crlf );
	     GS!Err_ null;
	     END "display error string";
	   END

      END ! case ;

    END "ask for options";

  return( true );
END "getoptions";


simple boolean procedure MakeRecord( integer DatNext );
! ----------------------------------------------------------------------;
!									;
! 		ConStructs the 24 word header ( positions 0 - 23 ).	;
!		Prompts for command file name and log file name.	;
!		Prompts for "OPTIONS".					;
!		Returns "TRUE" if all of the above are obtained.	;
!		Returns false if <cr> is typed at command file prompt.  ;
!									;
! ----------------------------------------------------------------------;
BEGIN "MakeRecord"
  string  ComFile,LogFile;

  Current[ E!RunTime ]_      DatNext;
  Current[ E!PPN ]_          UsePPN;      
  Current[ E!Privs ]_        JobPrv;    
  Current[ E!AUN ]_          UseAUN;  
  Current[ E!Username ]_     cvsix( UseUser[1 for 6] );
  Current[ E!username + 1 ]_ cvsix( UseUser[7 for 6] );
  Current[ E!License ]_ 0;		! set license in options section ;
  calli( !xwd( 0, location( Current[ E!Project ] ) ), calli!chprj );
  Current[ E!Network ]_ !xwd( 1, location( Current[ E!Network ] ) );

  start!code
    define !forfa = '36;
    hrloi	1,!forfa;
    uuo!FRMOP 1,Current[ E!Network ];
    setzm Current[ E!Network ];
    END;

  while true do
    BEGIN "Get command file"
    if length( GS!Params ) = 0 then 			! Must prompt for it. ;
      GS!Params_ Prompt( "Name of command file: " );

    if !skip! = 13 and length( GS!Params ) = 0 then
      BEGIN
      print( crlf,"INSERT ABORTED",crlf );
      return( false );
      END
    else
      if CryForHelp( GS!Params ) then 			! Help requested. ;
	BEGIN
        print( ComFilHelp );		! So do help then try again. ;
	GS!Params_ null;		! clear string ;
	END
      else
        BEGIN 
        ComFile_ GS!Params;
        if EqSign( GS!Params, ComFile ) then	! If there is a '=' then ;
          LogFile_ GS!Params
        else
	  BEGIN
	  ComFile_ LopWrd( GS!Params );
	  LogFile_ LopWrd( GS!Params );
	  END;

        if NOT ComIsOK( ComFile ) then
          continue
        else
	  BEGIN "load and exit"
          ! Stick the file name into the array at position based on 3rd parameter. ;
          LoadFileName( Current,ComFile,E!CmdFile );
	  done;
	  END "load and exit";
	END;

    END "Get command file";

  while true do
    BEGIN "Get log file name"
    if length( LogFile ) = 0 then 		! Furnished on command line? ;
      BEGIN "prompt for log file"		! No, so prompt for it. ;
      LogFile_ Prompt( "Name of log file: " );
      if !skip! = 13 and length( LogFile ) = 0 then
        done
      else
        if CheckLog( LogFile ) then		! If OK LogFile - done. ;
          done;
      END "prompt for log file"
    else					! Yes, so check it. ;
      if CheckLog( LogFile ) then
        done;
    print( crlf,"Cannot create log file: ", LogFile, "." );
    LogFile_ null; ! clear before next try;
    END "Get log file name";

  ! Stick the file name into the array at position based on 3rd parameter. ;
  if not equ( LogFile, null ) then
    LoadFileName( Current,LogFile,E!LogFile );

  return( true );

END "MakeRecord";


simple integer procedure
  IdentifyTheJob( reference string JobName; integer array Spec );
! ----------------------------------------------------------------------;
!									;
! 		First see if job name and/or request number was	;
! 		  furnished in command line.  If so then get them.	;
! 		else							;
! 		  Prompt for Job name and request number. 		;
!									;
! ----------------------------------------------------------------------;
BEGIN "get job and req"
	integer BrkChr;
	string resp, ReqStr, junk;

    if not( length( GS!Params ) )	! Nothing given with "MODIFY" ;
     then resp_ prompt( "Job Name: " )	! So get it now ;
     else resp_ GS!Params;		! else use rest of command line;

    if ( length( JobName_ LopWrd( resp ) ) )
     then VMSpec( JobName, Spec )	! read name, or (user)name ;
     else arrClr( Spec );

    if ( Spec[ S!Nam ] = cvsix( "*" ) )	! allow * for wild name ;
     then Spec[ S!Nam ]_ 0;		!  and clear the field ;

    if ( JobName neq "(" )		! did we see a username? ;
     then Spec[S!Usr]_Spec[S!Usr+1]_ 0;	! no, so clear field ;

    ReqStr_ LopWrd( resp );		! look for request #;

    while ( true )
     do begin "request loop"

	if not( length( ReqStr ) ) 	! Need request number? ;
	 then ReqStr_ prompt( "Request Number: " );

	if ( length( ReqStr ) )		! User types anything? ;
	 then begin "have request text"

	    if not( ValNum( ReqStr ) )	! If not integer then loop. ;
	     then begin "invalid request number"
		print( crlf &"Bad request number: ",ReqStr,
			" (Must be an integer)." );
		ReqStr_ null;
	     end "invalid request number"
	     else return( cvd( ReqStr ) );

	 end "have request text"
	 else return( 0 );

     end "request loop";

END "get job and req";


simple procedure QueErr( string Msg );
! ----------------------------------------------------------------------;
!									;
! 		Print the message passed. 				;
!		also print additional explanation based on value in 'QError.  ;
!									;
! ----------------------------------------------------------------------;
BEGIN "QueErr"
  print( Msg );						! Print error message.;
  case QError of					! Look at QError.;
    BEGIN					! Most cases are covered. ;
    [ err$COQ ]  Print( " (Cannot open queue)" );
!   [ err$ILL ]  Print( " (Illegal license)" );
    [ err$CMS ]  Print( " (Cannot map status page)" );
    [ err$CMA ]  Print( " (Cannot map area)" );
    [ err$CMR ]  Print( " (Cannot map job record)" );
    [ err$CFR ]  Print( " (Cannot find job record)" );
    [ err$MRM ]  Print( " (Modify job record mismatch)" );
    else	 print( " (Source unknown: ",QError,")" ) 
    END;
  print( crlf );
END "QueErr";


simple procedure Insert;
! ----------------------------------------------------------------------;
!									;
! 	Insert record into queue, being assigned a req# by ModRec.	;
!									;
! ----------------------------------------------------------------------;
BEGIN "Insert"
	integer NextD, tod, ReqNum, brk;
	string  JobName;

  ReqNum_ LPPReq( Current );		! get request number ;

  if ReqNum = 0 or ReqNum land !bit( 18 ) then  ! Must be a new entry;
    BEGIN "New job"
    tod_ GetTDT;			! Get current Date/time. ;

    if ( Current[ E!Runtime ] = 0 )	! Get next run Date/time. ;
     then NextD_ tod			! Immediate run (now). ;
     else NextD_ NexTim( Current[0],tod );	! Future. ;

    ! Get command file/log file names and options. ;
    if not MakeRecord( NextD )		! MakeRecord will return true unless ;
     then return;			!   user types <cr> (only) at prompt ;
					!   for command file name. ;

    if not GetOptions( false )		! GetOptions will return true unless ;
     then return;			!   user types "ABORT" at OPTIONS ;
					!   prompt. ;

    END "New job"
  else					! Request number in the rec was not ;
					!   zero so we must be re-inserting a ;
					!   modified job. ;
    print( "Modified " ); 		! So start message with 'MODIFIED' ;

  JobName_ Cv6str( Current[ E!CmdFile + F!Name ] );
  print( "Job """, JobName, """ " ); ! Message. ;

  ! Try to insert. ;
  if ModRec( Current[ E!Runtime ], CopyForModRec[ E!Runtime ] ) then
    BEGIN "OK insertion"			! insert the new entry. ;
    print("Inserted.  Req# ",LPPReq(Current));	! Tail end of the message. ;
    ArrClr( Current );				! Clear the arrays. ;
    ArrClr( CopyForModRec );
    END "OK insertion"
  else
    QueErr( " Could not be inserted." ); 	! ModRec failed. ;

  print( crlf );  

END "Insert";


simple procedure Prepare( integer array A, Name ); 
! ----------------------------------------------------------------------;
!									;
! 		Clear "A", Reset, insert:       			;
!			- nothing, if user has QM license.		;
!			- left half of AUN if user is acct. sup.	;
!			- else whole AUN.				;
!			- if user specified USERNAME.			;
!									;
! ----------------------------------------------------------------------;
BEGIN "Prepare"
  ArrClr( A );

  A[ E!CmdFile+F!Name ]_ Name[ S!Nam ];	! put any jobname in ;
  A[ E!Username ]_ Name[ S!Usr ];	! specified user ;
  A[ E!Username+1 ]_ Name[ S!Usr+1 ];	! specified user ;

  if not JobLic land LC!!QM then	! If not QM then. ;
    BEGIN "Not QM"
    if JobPrv land JP!ASV then		!  See if Acct supervisor. ;
      BEGIN "Acct Supervisor"
      A[ E!AUN ]_ UseAUN land lnot '777777;
      END "Acct Supervisor"
    else				! Since not QM and not Acct sup;
      BEGIN "Vanilla"			!   grant minimun rights. ;
      A[ E!AUN ]_ UseAUN;
      END "Vanilla";
    END "Not QM";
					! Nothing in E!AUN indicates QM. ;
END "Prepare";


simple procedure Message( string Vanilla,
				 AcctSup,
				 QMLic
			);
! ----------------------------------------------------------------------;
!									;
!		Print message depending on license.			;
!									;
! ----------------------------------------------------------------------;
BEGIN "message"

  if JobLic land LC!!QM then		! User has QM ;
    QueErr( QMLic )			!   so print his message.;
  else
    if JobPrv land JP!ASV then		! User has Acct Sup License. ;
      print( AcctSup )
    else				! else no license. ;
      print( Vanilla );

END "message";


simple boolean procedure RealRec( reference integer rec );
! ----------------------------------------------------------------------;
!									;
!									;
! ----------------------------------------------------------------------;
BEGIN "RealRec"
	boolean b;
  InQue_ InQue lor Que$Real;
  b_ GetRec( rec );
  InQue_ InQue land lnot Que$Real;
  return( b );
END "RealRec";


simple boolean procedure Delete;
! ----------------------------------------------------------------------;
!									;
!	Delete								;
!		Attempt to delete the specified record.			;
!									;
! ----------------------------------------------------------------------;
BEGIN "Delete"

    MyString_ "deleted";
    arrblt( CopyForModRec[ E!Runtime ], Current[ E!Runtime ], E!Length );

    dpb( ST$Cancel, PPstat( Current ) );	! Set Cancel. ;

    return( ModRec( Current[ E!Runtime ],	! return the ;
		    CopyForModRec[ E!Runtime ]	! result  ;
		)
	);
 
END "Delete";


simple boolean procedure DisplayMyRec;
! ----------------------------------------------------------------------;
!									;
!	true_ DisplayMyRec						;
!		Display the current record and return true.		;
!									;
! ----------------------------------------------------------------------;
begin "My display"

    MyString_ "show";
    DisplayARec( Current );
    return( true );

end "My display";


simple boolean procedure ModJob;
! ----------------------------------------------------------------------;
!									;
!	boolean_ ModJob							;
!		Called with a record setup in Current.  Prints a	;
!		brief description of the record and calls GetOptions	;
!		to modify the record.  Returns true if record is	;
!		actually modified.					;
!									;
! ----------------------------------------------------------------------;
BEGIN "ModJob"

    MyString_ "modified";
    arrblt( CopyForModRec[ E!Runtime ], Current[ E!Runtime ], E!Length );

    DisplayARec( Current );		! Display the job info. ;

    print( crlf );
    if ( GetOptions( true ) )
     then begin "Replace if modified"

	if ( GB!Change )
	 then Insert;

	return( GB!Change );

     end "Replace if modified"
     else return( false );

END "ModJob";


simple boolean procedure ReQueue;
! ----------------------------------------------------------------------;
!									;
!	boolean_ ReQueue						;
!		Requeue the current record.  If the record is active	;
!		this action will cause the current run of the record	;
!		to be it's last regardless of the period specified.	;
!		If the requeued record is periodic it will be placed	;
!		back in the queue with a new request number scheduled	;
!		for the next runtime after the current time, otherwise	;
!		it will be removed from the queue.			;
!									;
! ----------------------------------------------------------------------;
BEGIN "ReQueue"

    MyString_ "requeued";
    arrblt( CopyForModRec[ E!Runtime ], Current[ E!Runtime ], E!Length );

    dpb( Queued$Wait, PPstap( Current ) ); 	! Reset & Re-insert. ;

    Current[ E!Runtime ]_ NexTim( Current[ E!Runtime ], GetTDT );
    return( ModRec( Current[E!Runtime], CopyForModRec[E!Runtime] ) );

END "ReQueue";


simple boolean procedure ReRun;
! ----------------------------------------------------------------------;
!									;
!	boolean_ ReRun							;
!		Reset a request to run immediately.  This will now	;
!		work on any request.  If the request has a STARTUP	;
!		expression, the RanTime will be set to 0, thereby	;
!		causing a reschedule.  All other requests will have	;
!		their RunTime set to the current time.			;
!									;
! ----------------------------------------------------------------------;
BEGIN "ReRun"

    MyString_ "rerun";
    arrblt( CopyForModRec[ E!Runtime ], Current[ E!Runtime ], E!Length );

    dpb( Queued$Wait, PPstap( Current ) ); 	! Reset & Re-insert. ;

    if ( Current[ E!RunTime ] = -1 )		! if STARTUP ;
     then Current[ E!RanTime ]_ 0		!  then no previous run ;
     else Current[ E!Runtime ]_ GetTDT;		!  else runtime is now. ;

    return( ModRec( Current[ E!Runtime ], CopyForModRec[ E!Runtime ] ) );

END "ReRun";


simple procedure MyLoop( simple boolean procedure MyProc );
begin "My Loop"
    integer ReqNum, Count;
    string  JobName;

  ! See if the job name and/or request number were furnished along with the ;
  !   SUBMIT command.  If they were not then prompt for them and return what ;
  !   user types or null if the user answers the prompts with <cr> only. ;
  ReqNum_ IdentifyTheJob( JobName, Spec );	! Ask the user. ;

  ! Clear the array being passed, set the request number to -1, and set the ;
  !   AUN according to the users privilege level. ;
  Prepare( Current, Spec );
  dpb( '777777, PPReq( Current ) ); 	! Set req# to -1 so it starts at top;

  Count_ 0;				! initialize count ;

    if ( ReqNum )				! request # received ;
     then begin "One Record only"

	Dpb( ReqNum, PPReq( Current ) );	! put req# into array ;

	if RealRec( Current[ E!Runtime ] ) and	! if req found and ;
	   ( LPPstat( Current ) neq ST$Cancel )	! it's not cancelled ;
	 then MyProc				!  then process it ;
	 else Message(				! could not find req ;
	    crlf&"Request not found for your username."&crlf,
	    crlf&"Request not found."&crlf,
  	    crlf&"Request not in queue."&crlf
	    );

     end "One Record only"
     else begin "all with same name"

	while RealRec( Current[ E!Runtime ] ) and
	   ( LPPstat( Current ) neq ST$Cancel )	! it's not cancelled ;
	 do begin "Get each"

	    if ( MyProc )		! process the record ;
	     then begin "success"

		if not( Count )		! first time? ;
		 then print( MyString, ":"& crlf );

		RequestInfo( Current );	! tell us about it ;
		Count_ Count + 1;	! count how many succeeded ;

	     end "success";

	    Prepare( Current, Spec );	! setup for next iteration ;

	 end "Get each";

	if ( Count )			! anything done? ;
	 then print( crlf &"Processed ", Count, " requests." )
	 else print( crlf &"%No requests processed." );

     end "all with same name";

    ArrClr( Current );			! reset data at end of command ;

end "My Loop";


simple boolean procedure CheckListParams( integer array QRec );
! ----------------------------------------------------------------------;
!									;
!		Check the words following the LIST command to see	;
!		  if they are Listable.					;
!									;
! ----------------------------------------------------------------------;
BEGIN "CheckListParams"
	integer OptNum,		! Gets index of valid parameter. ;
		LineLength;	! Keep track of field widths. ;
	string  str;		! One word at a time from command line. ;
	boolean FoundOne;	! True iff at least one parameter was OK. ;

  FoundOne_ false;

  ! ListRequests is a boolean array whose positions are set true if user ;
  !   supplied that parameter. ;
  arrclr( ListRequests );

  LineLength_ 0;			! Must not exceed width of screen. ;

  while true do
    BEGIN "Validate parameters"

    Str_ LopWrd( GS!Params );			! Get next parameter. ;
    if kequ( str,null ) then			! Return if no more. ;
      done;

    OptNum_ Vik( LiPs, Str );		! In options array? ;

    if OptNum = $ABO then continue;	! ABORT option is not listable. ;

    if OptNum = $ALL then		! If one of the params is the ;
      BEGIN "allow nothing with ALL"	!   word ALL then we can ignore ;
      arrclr( ListRequests );		!   the rest end return to use ;
      ListRequests[ $ALL ]_ true;	!   a routine to dump the whole ;
      FoundOne_ true;			!   ueue rec to the screen. ;
      done;
      END "allow nothing with ALL";

    if OptNum neq -1 then
      BEGIN "record in ListRequests"
      FoundOne_ true;				! At least one good param. ;
      if not ListRequests[ OptNum ] then		! If a new param, ;
        LineLength_ LineLength + length( LiPs[ OptNum ] ); ! sum the lengths. ;
      if LineLength < 81 then			! If > screen width then ;
        ListRequests[ OptNum ]_ true		!    don't bother to record. ;
      END "record in ListRequests"
    else
      BEGIN "Invalid or ambiguous"
      if length( GS!Err ) = 0 then		! If Vik returned -1 and ;
        print( crlf, "?",Str,"? - UNKNOWN" )	!  GS!Err=null then invalid. ;
      else
        BEGIN "Ambiguity message"		! If Vik returned -1 and ;
        print( crlf, GS!Err );			!  GS!Err#null then Ambiguity.;
	GS!Err_ null;
	END "Ambiguity message";
      END "Invalid or ambiguous";

    END "Validate parameters";

  if NOT FoundOne then
    return( false )
  else
    return( true );

END "CheckListParams";


simple procedure ColumnHeadings;
! ----------------------------------------------------------------------;
!									;
! 		Now print the 'LIST' column headings. 			;
!									;
! ----------------------------------------------------------------------;
BEGIN "ColumnHeadings"
	integer ParamNum;

  if not ListRequests[ $ALL ] then
    print( crlf,"  " );		! Space for the "Cancelled" flag. ;

  for ParamNum_ 0 upto NumParams - 2 do		! Names for the columns. ;
    BEGIN "column headings"
    if ListRequests[ ParamNum ] then		! Has this param been selected?;
      BEGIN
      if ParamNum = $NEX then		! Next Run column heading requires ;
        BEGIN "ref time"		!   the current time for reference. ;
        print( LiPs[ ParamNum ][ 1 to 8 ] );	! Name of the param. ;
        print( "(",TheTime[ 1 for 5 ],") " );	! Current time in paren. ;
        print( "  " );			! Space for overdue indicator. ;
	END "ref time"
      else				! Rest of column headings required ;
        print( LiPs[ ParamNum ]," " );	!   will be set true. ;
      END;
    END "column headings";

  if not ListRequests[ $ALL ] then
    print( crlf,"  " );		! Space for the "Cancelled" flag. ;

  for ParamNum_ 0 upto NumParams - 2 do		! Underline the column headings.;
    BEGIN "underline headings"
    if ListRequests[ ParamNum ] then		! Underline if true. ;
      BEGIN
      print( dashes[ 1 for length( LiPs[ ParamNum ] ) ] ," " );
      if ParamNum = $NEX then		! NEXT RUN may require Space for ;
        print( "  " );			!    overdue indicator. ;
      END;
    END "underline headings";

END "ColumnHeadings" ;


simple procedure oneLISTline( integer array QRec );
! ----------------------------------------------------------------------;
!									;
!		Gets one queue rec at a time and produces one		;
!		  horizontal line of information on that job		;
!		  depending on what was furnished on the command	;
!		  line after the LIST command. 				;
!									;
! ----------------------------------------------------------------------;
BEGIN "oneLISTline"
	integer EachOption;		! Index for ListRequests. ;
	string  S;			! Holds info from wwithin a Q rec. ;
	boolean late;			! Becomes true if next run overdue. ;

  print( crlf );

  if ( LPPstat( QRec ) = ST$Proc )	! Print flag in left margin. ;
   then print( !PRO )
   else print( "  " );

  for EachOption_ 0 upto NumParams - 1 do	! Check each position in ;
    BEGIN "List each required"			!   the ListRequests array ;
    if ListRequests[ EachOption ] then		!   to determine whether ;
  						!   the user wants to see it. ;
      case EachOption of
      BEGIN
        [ 0 ]					! JobName. ;
	LJust( cv6str(QRec[E!CmdFile+F!Name]), length(LiPs[EachOption])+1 );
	[ 1 ]					! Request. ;
	LJust( cvs( LPPReq( QRec ) ), length(LiPs[EachOption])+1 );
	[ 2 ]					! TimeLimit. ;
	LJust( CvsTim((LPPTimL(QRec) lsh 18) DIV 1440)[ 1 for 5 ],
			length(LiPs[EachOption])+1 );
	[ 3 ]					! UserName. ;
	LJust( cvxStr(QRec[E!UserName])&cvxStr(QRec[E!UserName+1]),
			length(LiPs[EachOption])+1 );
	[ 4 ]					! PPN. ;
	LJust( PrtPPN( QRec[ E!PPN ] ), length(LiPs[EachOption])+1 );
	[ 5 ]					! AUN. ;
	LJust( PrtPPN( QRec[ E!AUN ] ), length(LiPs[EachOption])+1 );
	[ 6 ]					! Privilege. ;
	LJust( QRec[ E!Privs ], length(LiPs[EachOption])+1 );
	[ 7 ]					! NextRun. ;
	LJust( LocalRun(QRec,late)[1 for 15], length(LiPs[EachOption])+1 );
	[ 8 ]					! License. ;
	LJust( cvs(LicPrt(!rh(Qrec[E!License]))), length(LiPs[EachOption])+1 );
	[ 9 ]					! Log File. ;
	LJust( InfNam(location(QRec[E!LogFile])), length(LiPs[EachOption])+1 );
	[ 10 ]					! Command File.;
	LJust( InfNam(location(QRec[E!CmdFile])), length(LiPs[EachOption])+1 );
	[ 11 ]					! Label. ;
	LJust( if ( QRec[E!Label] land ('77 lsh 30) )
		then cv6str( QRec[E!Label] )
		else if ( QRec[E!Label] )
		      then "#"&cvs(QRec[E!Label]) else null,
		      	length(LiPs[EachOption])+1 );
	[ 12 ]					! TRULimit. ;
	LJust( cvs(QRec[E!TruLim]) , length(LiPs[EachOption])+1 );
	[ 13 ]					! LogLimit. ;
	LJust( cvs(LPPLogL(QRec)), length(LiPs[EachOption])+1 );
	[ 14 ]					! Log. ;
	LJust( ARLog[LPPLog(QRec)], length(LiPs[EachOption])+1 );
	[ 15 ]					!  Dispose. ;
	LJust( ARDisp[LPPDisp(QRec)], length(LiPs[EachOption])+1 );
	[ 16 ]					!  Mailer. ;
	; ! LJust( ARMailer[LPPMPrg(QRec)], length(LiPs[EachOption])+1 );
	[ 17 ]					!  spool. ;
	; ! LJust( "  *  ", length(LiPs[EachOption])+1 );
	[ 18 ]					!  Mail. ;
	LJust( ARMail[LPPMail(QRec)], length(LiPs[EachOption])+1 );
	[ 19 ]					!  Restart. ;
	LJust( ARRestart[LPPRestart(QRec)], length(LiPs[EachOption])+1 );
	[ 20 ]					!  Unique. ;
	LJust( ARuniq[LPPUniq(QRec)], length(LiPs[EachOption])+1 );
	[ 21 ]					! CTYLOG. ;
	LJust( LPPCtyF(QRec), length(LiPs[EachOption])+1 );
	[ 22 ]					!  run. ;
	LJust( NoYes[LPPRunf(QRec)], length(LiPs[EachOption])+1 );
	[ 23 ]					!  Detach. ;
	LJust( NoYes[LPPDetf(QRec)], length(LiPs[EachOption])+1 );
	[ 24 ]					! Logout. ;
	LJust( LPPLogF(QRec), length(LiPs[EachOption])+1 );
	[ 25 ]					! Priority. ;
	LJust( LPPJPri(QRec), length(LiPs[EachOption])+1 );
	[ 26 ]					! HALT. ;
	LJust( LPPHaltf(QRec), length(LiPs[EachOption])+1 );
	[ 27 ]					! CCL. ;
	LJust( Cv6Str( LPPCCLF(QRec) lsh 18 ), length(LiPs[EachOption])+1 );
	[ $ABO ]				!  Abort. ;
	LJust( "  *  ", length(LiPs[EachOption])+1 );
	[ $ALL ]				! Display all Params. ;
	DisplayARec( Qrec )

      END;
    END "List each required";
END "oneLISTline";


simple procedure list;
! ----------------------------------------------------------------------;
!									;
!									;
! ----------------------------------------------------------------------;
BEGIN "List"
	integer Count, ReqNum;
	boolean ParamsChecked;

  Count_ 0;
  ParamsChecked_ false;

  ArrClr( Spec );

  ! Clear the array being passed, set the request number to -1, and set the ;
  !   AUN according to the users privilege level. ;
  Prepare( Template, Spec );
  
  ! Template is retained as a Rec with only the AUN set. ;
  ! Now move Template to current to get next rec from Queue. ;
  ! When the next record from the queue needs to be obtained, a record cleared;
  !   except for the AUN is passed to getrec which will get the next rec. ;
  ! The first time around, GetRec gets an array with -1 in the request number;
  !   field, which will reset the pointer to the beginning of the queue. ;
  arrblt( Current[ E!Runtime ],Template[ E!Runtime ],E!Length ); 
  dpb( '777777, PPReq( Current ) ); 	! Set req# to -1 so it starts at top;
  
  while GetRec( Current[ E!Runtime ] ) do !  rest of recs with this username;
    BEGIN "List jobs"
    Count_ Count + 1;

    if kequ( GS!Params,null ) then		! No params supplied with LIST;
      GS!Params_ DefaultParam;			!   so use the defaults. ;

    if NOT ParamsChecked then
      BEGIN "First time around"
      if CheckListParams( Current ) then	! Something valid found. ;
	BEGIN "Start LIST"
	ColumnHeadings;			! Print Column headings. ;
        ParamsChecked_ true;		! Set flag. ;
        oneLISTline( Current );		! First line. ;
	END "Start LIST"
      else
	BEGIN "Error return"
	print( crlf,#lf, "NO LISTABLE PARAMETERS PROVIDED",crlf );
	return;
	END "Error return"
      END "First time around"
    else
      BEGIN "Subsequent loops"
      oneLISTline( Current ); 
      END "Subsequent loops";

    ! Template is a Rec with only the AUN set. ;
    ! Now move Template to current to get next rec from Queue. ;
    arrblt( Current[ 0 ],Template[ 0 ],E!Length ); ! move to Current;

    END "List jobs";

  if ListRequests[ $ALL ] then
    print( crlf,#lf,Count," ITEMS LISTED.",crlf );

  if count = 0 then
    Message( crlf&"NO JOBS FOR " &GetUserName&"."&crlf,
   	     crlf&"NO JOBS"&crlf,
	     crlf&"QUEUE EMPTY" );

END "List";


simple procedure status;
! ----------------------------------------------------------------------;
!									;
!		Display status of jobs in queue.			;
!									;
! ----------------------------------------------------------------------;
BEGIN "status"
	boolean found,		! Becomes true if GetRec ever succeeds. ;
		Stati,		! Becomes true if user has QM or Acct Sup. ;
		late;		! Becomes true if NextRun is in the past. ;
	string  Req,		! Gets request number from rec. ;
		STATE,		! Current state of a job. ;
		PROCESS,	! Current process. ;
		ComFil,		! Gets command file name. ;
		User;		! Gets user name from the rec. ;
	integer num;		! temporary hold for an integer. ;

  found_ false;

  ArrClr( Spec );

  ! Clear the array being passed, set the request number to -1, and set the ;
  !   AUN according to the users privilege level. ;
  Prepare( Template, Spec );

  ! Template is retained as a Rec with only the AUN set. ;
  ! Now move Template to current to get next rec from Queue. ;
  ! When the next record from the queue needs to be obtained, a record cleared;
  !   except for the AUN is passed to getrec which will get the next rec. ;
  ! The first time around, GetRec gets an array with -1 in the request number;
  !   field, which will reset the pointer to the beginning of the queue. ;
  arrblt( Current[ E!Runtime ],Template[ E!Runtime ],E!Length ); 
  dpb( '777777, PPReq( Current ) ); 	! Set req# to -1 so it starts at top;

  if JobPrv land JP!ASV or 		! If user is an acct supervisor or ;
     JobLic land LC!!QM then		!  has QM license ;
    Stati_ true				! then set flag to print the user name;
  else
    Stati_ false;
  
  InQue_ InQue land lnot que$Real;	! clear "real" flag ;
  ClsQue;				! close the queue and re-open ;

  while GetRec( Current[ E!Runtime ] ) do !  rest of recs with this username;
    BEGIN "Main loop"
    if ( LPPStat( Current ) = ST$Cancel )
     then continue "Main loop";		! skip cancelled/deleted records ;

    if not found then
      BEGIN
      found_ true;
      print( crlf, "Job    Req    " );
      if Stati then	! Only list usernames if user has status. ;
        print( "User         " );
      print( "Status-Type       Next Run(",TheTime[ 1 for 5 ],")" );
      print( crlf, "------ ---    " );
      if Stati then
        print( "----------   " );
      print( "-----------       ---------------" );
      END;

    Req_  cvs( LPPReq( Current ) );
    ComFil_ cv6Str( Current[ E!CmdFile + F!Name ] );
    User_ cvxStr( Current[ E!Username ]) & cvxStr( Current[ E!Username + 1 ] );

    State_ ("      " & SStat[ num_ LPPStat( Current ) ])[inf-5 to inf] &
	   "-"& SSStat[ Stat[ num ] + LPPProc( Current ) ];

    print( crlf );			! New line for each job. ;
    LJust( ComFil, 7 );			! Print Command file name. ;
    LJust( Req, 7 );			! Print Request number. ;
    if Stati then			! Print User name if status. ;
      LJust( User, 13 );
    LJust( State, 18 );			! Print Job state. ;

    ! If not running - show date in local time. ;
    if LPPStat( Current ) neq ST$Proc
     then print( LocalRun( Current, late )[ 1 for 15 ] );

    ! Template is a Rec with only the AUN set. ;
    ! Now move Template to current to get next rec from Queue. ;
    arrblt( Current[ 0 ],Template[ 0 ],E!Length ); ! move to Current;

    END "Main loop";

  if not found then
    Message( crlf&"NO JOBS FOR " &GetUserName&"."&crlf,
   	     crlf&"NO JOBS"&crlf,
	     crlf&"QUEUE EMPTY" )
  else
    print( crlf );

END "status";


simple boolean procedure UseCheck;
! ----------------------------------------------------------------------;
!									;
!	UseCheck	Routine to check special license, gan and	;
!			connected directory restrictions for special	;
!			undocumented commands.				;
!									;
! ----------------------------------------------------------------------;
begin "use check"

  if not( JobLic land LC!!QM )  or	! User must have QM ;
     not( !lh( JobAun ) = 3 )   or	!  and must be gan 3 ;
     not( JobPPN = !Xwd( 3,'416154 ) )	!  and gfd'd to SUBMIT ;
   then begin "no license"
      print( "?Unidentified command: #",GI!CmdNum,".",crlf );
      return( false );
   end "no license"
   else return( true );

end "use check";


simple procedure UseFile;
! ----------------------------------------------------------------------;
!									;
!	UseFile		Routine to setup an alternate queue file to	;
!			use as the current workspace.			;
!									;
! ----------------------------------------------------------------------;
begin "use file"

  if not( UseCheck )			! do we pass the security checks ;
   then return;				! guess not -- bye ;

  if ( length( GS!Params ) )		! did we get something? ;
   then GS!Params_ "(SUBMIT)"&GS!Params	! yes, prefix directory ;
   else GS!Params_ QueueFile;		! no, reset to default ;

  ClsQue;				! close the queue ;

  if not( UseQue( GS!Params ) )		! setup new queue file ;
   then print( "?Unidentified command: #",GI!CmdNum,"!",crlf );

end "use file";


simple procedure UseMasquerade;
! ----------------------------------------------------------------------;
!									;
!	UseMasquerade	Let a privileged user masquerade as another	;
!			user without the hassle of really changing	;
!			the job parameters.				; 
!									;
! ----------------------------------------------------------------------;
begin "use masque"

  if not( UseCheck )			! do we pass the security checks ;
   then return;				! guess not -- bye ;

  if ( length( GS!Params ) )		! did we get something? ;
   then begin "mask"
      UseUser_ GS!Params;		! yes, set new username ;
      UseAUN_ CvPPN( UseUser );		!      set new aun ;
   end "mask"
   else begin "restoration"
      UseUser_ JobUser;			! no,  restore username ;
      UseAUN_ JobAUN;			!      restore aun ;
   end "restoration";

end "use masque";



simple procedure UseGFD;
! ----------------------------------------------------------------------;
!									;
!	UseGFD		Routine to all a privileged user to change the	;
!			connected directory without actually changing	;
!			it.  See UseCheck for the definition of a real	;
!			privileged user.				;
!									;
! ----------------------------------------------------------------------;
begin "use gfd"

  if not( UseCheck )			! do we pass the security checks ;
   then return;				! guess not -- bye ;

  if ( length( GS!Params ) )		! did we get something? ;
   then UsePPN_ CvPPN( GS!Params )	! yes, set new ppn ;
   else UsePPN_ JobPPN;			! no,  restore ppn ;

end "use gfd";


simple string procedure ForceReply( string Question );
! ----------------------------------------------------------------------;
!									;
!									;
! ----------------------------------------------------------------------;
while true do
  BEGIN "ForceReply"
  	string reply;

    while length( reply_ Prompt( Question ) ) = 0
     do reply_ reply;

    if CryForHelp( reply )
     then print( crlf & HlpMsg )
     else return( reply )

  END "ForceReply";


integer procedure GetCommand;
! ----------------------------------------------------------------------;
!									;
!		Display SUBMIT prompt and validate response.		;
!									;
! ----------------------------------------------------------------------;
BEGIN "get command"

	procedure ListHelp;
        BEGIN "More help for list"
		integer index;
		string temp;

	print( crlf &
	    "The following arguments may be supplied with the LIST command:" &
	    crlf & crlf );

	for index_ 1 upto NumParams-1 do
	  BEGIN "show the parameters"
	  LJust( Lips[ index ], 20 );
!	  if index mod 4 = 0 then
  	    print( crlf  );
	  END "show the parameters";

        print(  crlf &
		crlf &"Example:  LIST CommandFile Request Next <cr>."&
		crlf &"- Lists control file names with request numbers and"&
		      "date-time of next run."&
		crlf &"Example:  LIST ALL <cr>."&
		crlf &"- Lists all parameters for all jobs."&
		crlf );

	END "More help for list";

while true do
  BEGIN "a command"
	integer index;
	string  reply,
		FirstWord,
		SecondWord;

  GS!ERR_ null;					! Initialize message ;
  reply_ ForceReply( SubmitPrompt );		! Get a response. ;
  FirstWord_ LopWrd( reply );			! get 1st word . ;
  GS!Params_ reply ;				! Save the rest. ;
    
  if CryForHelp( FirstWord ) then		! Was 1st word typed = "help"?;
    BEGIN "help requested"
    SecondWord_ LopWrd( reply );			! 2nd word of reply. ;
    index_ Vik( Commands, SecondWord );
    if index neq -1 then
      BEGIN
      print( CommandsHelp[ index ] );
      if kequ( SecondWord, "LIST" ) then
        ListHelp;
      END
    else
      if ( length( GS!ERR ) )
       then print( GS!ERR )
       else print( '42 & SecondWord & '42 & " IS NOT A COMMAND", crlf );
    END "help requested"
  else
    BEGIN "Validate the command"
    index_ Vik( Commands, FirstWord );
    if index neq -1 then
      return( index )
    else
      if ( length( GS!ERR ) )
       then print( GS!ERR )
       else print( '42 & FirstWord & '42 & " IS NOT A COMMAND", crlf );
    END "Validate the command";

  END "a command"
END "get command";



simple boolean procedure ChangedActive( integer Operation, index );
BEGIN
  redefine QRS(j) = { QQ(Runner-1+(j)) };
  redefine QRA(j) = { QQ(RunAct-1+(j)) };

  case Operation of
    BEGIN
    $CON BEGIN
         if LPPSTAP( Current ) = Proc$Stop or
            LPPSTAP( Current ) = Proc$Pause then
	   BEGIN
	   DPB( Proc$Run, PSTAP( QRS(index) ) );
	   return( true );
	   END;
         END;
    $PAU BEGIN
         if LPPSTAP( Current ) = Proc$Run then
	   BEGIN
	   DPB( Proc$Pause, PSTAP( QRS(index) ) );
	   return( true );
	   END;
         END;
    $STO BEGIN
         if LPPSTAP( Current ) = Proc$Run or
            LPPSTAP( Current ) = Proc$Pause then
	   BEGIN
	   DPB( Proc$Stop, PSTAP( QRS(index) ) );
	   return( true );
	   END;
         END;
    $KIL BEGIN
         if LPPSTAT( Current ) = ST$Proc and
            LPPPROC( Current ) < PSP$Cancel then
	   BEGIN
	   DPB( Proc$Cancel, PSTAP( QRS(index) ) );
	   return( true );
	   END;
         END;
    else BEGIN
         print( crlf,"UNKNOWN STATE." );
	 return( false );
         END
    END;

  print( crlf,"Cannot ", Commands[ Operation ], " Req# ", LPReq(QRS(index)),
	 " from it's current state." );
  return( false );

END;


simple procedure ModActiveJob( integer Operation );
BEGIN "ModActiveJob"
	integer ReqNum,
		i,
		Changes,		! count of jobs which were changed.;
		Attempts;		! count of attempts to change. ;
	string  JobName;
	boolean found;

  if not QQ( Active ) and
     not QQ( Running ) then
    BEGIN "Active area is empty"
    print( crlf, "There is nothing in the active area, can't " );
    print( Commands[ Operation ], "." );
    END "Active area is empty";

  ! See if the job name and/or request number were furnished along with the ;
  !   SUBMIT command.  If they were not then prompt for them and return what ;
  !   user types or null if the user answers the prompts with <cr> only. ;
  ReqNum_ IdentifyTheJob( JobName, Spec );

  ! Clear the array being passed, set the request number to -1, and set the ;
  !   AUN according to the users privilege level. ;
  Prepare( Template, Spec );

  ! Template is retained as a Rec with only the AUN set. ;
  ! Now move Template to current to get next rec from Queue. ;
  ! When the next record from the queue needs to be obtained, a record cleared;
  !   except for the AUN is passed to getrec which will get the next rec. ;
  ! The first time around, GetRec gets an array with -1 in the request number;
  !   field, which will reset the pointer to the beginning of the queue. ;
  arrblt( Current[E!Runtime], Template[E!Runtime], E!Length );
  dpb( '777777, PPReq( Current ) ); 	! Set req# to -1 so it starts at top;

  ! ----- "fetch it" is for the case where a request number ----- ;
  ! ----- has been furnished				    ----- ;
  if ReqNum > 0 then				! request # received ;
    BEGIN "fetch it"
    Dpb( ReqNum, PPReq( Current ) ); 		! put req# into array ;

    if i_ ActRec( Current[ E!Runtime ] ) then	! Get job from Queue. ;
      print( "Req# ", ReqNum,
	     (if ChangedActive( Operation, i )
	       then " is now " else " cannot be "),
	     Commands[ Operation ], "ED." )
     else
      BEGIN "GetRec failed"		! Message depends on License. ;
      If ( GetRec( Current[ E!Runtime ] ) ) then
        Print( crlf&"Job not active."&crlf )
       else
        Message( crlf&"Could not find this job with your username. "&crlf,
     	       crlf&"Could not find this job."&crlf,
  	       crlf&"Job not in queue. " );
      END "GetRec failed";

    END "fetch it"
  else
  ! ----- "Do all with same job name" is for the case where no     ----- ;
  ! ----- request number was provided, so every job with a given name ----- ;
  ! ----- must be done ;
  
    BEGIN "Do all with same job name"

    Changes_ Attempts_ 0;
    
    while i_ ActRec( Current[ E!Runtime ] ) do	! recs with this JobName;
      BEGIN "Same jobnames"

      ReqNum_ LPPReq( Current ); 			! Get req #. ;

      Attempts_ Attempts + 1;
      if ChangedActive( Operation, i ) then
	BEGIN
	print( "Req# ", ReqNum, " is now ", Commands[ Operation ], "ED." );
	changes_ changes + 1;
	END;

      ! Copy the Save array back into Current for next call of GetRec. ;
      arrblt( Current[E!Runtime], Template[E!Runtime], E!Length );

      END "Same jobnames";

    if not( attempts ) then
      BEGIN "check queue"
      Dpb( -1, PPReq( Current ) );
      if ( GetRec( Current[ E!Runtime ] ) ) then
        print( crlf&"Job not active."&crlf )
       else
        Message( crlf&"Could not find this job with your username. "&crlf,
     	       crlf&"Could not find this job."&crlf,
  	       crlf&"Job not in queue. " );
      END "check queue"
     else
      if not( Changes ) then
        print( "Req# ", ReqNum, " cannot be ", Commands[ Operation ], "ED." );

!    print( crlf,#lf, Changes, "/", Attempts, " Attempts were successful." );

  END "Do all with same job name";
END "ModActiveJob";


! main;

  print( "TYMCOM-X Job Processor  ",VERSION!STRING,"  ",
        CvSDat( TodaysIntrnDat )," ",TheTime, crlf );

  JobLic_ Gettab( -1,!gtLIC );		! Status License enabled ;
  JobPrv_ Gettab( -1,!gtPRV );		! Job Privileges ;
  UsePPN_ JobPPN_ Gettab( -1,!GTPPN );	! Connected Directory ;
  UseAUN_ JobAUN_ Gettab( -1,!GTAUN );	! Logged-in Directory ;
  UseUser_ JobUser_ cv6str( Gettab( -1,!gtUNM ) ) &
		    cv6str( Gettab( -1,!gtUN1 ) );

  while true do
    BEGIN "get a command and process"
    CASE GI!CmdNum_ GetCommand of
      BEGIN
      C!DATES           GetExpFromUser( true, Current );
      C!INSERT          Insert;
      C!DISPLAY         Display( Current );
      C!EXPRESS         Express( Current );
      C!TEST            Test( Current );
      C!DELETE          MyLoop( Delete );
      C!STATUS          Status;
      C!LIST            list;
      C!MODIFY          MyLoop( ModJob );
      C!VERSION         print( crlf,"Version ",VERSION!STRING,crlf );
      C!QUIT            AUS;
      C!HELP            print( HlpMsg );
      C!CODE            continue "get a command and process";
      C!LOOK            Look( Current );
      C!UNDELETE        Print( "?UNDELETE is illegal."& crlf );
      C!SHOW            MyLoop( DisplayMyRec );
      C!MODACT          ModActiveJob( GI!CmdNum );
      C!RERUN           MyLoop( ReRun );
      C!REQUEUE		MyLoop( ReQueue );
      C!USE		UseFile;
      C!USEM		UseMasquerade;
      C!USEG		UseGFD;
      else print( "?Unidentified command: #",GI!CmdNum,".",crlf )
      END 
    END "get a command and process"
END "SUBMIT";

   SnC2