begin "SUBMIT"

require "(SAILIB)SAIL.DEF"   source!file;
require "(SAILIB)UUOSYM.DEF" source!file;
require "(CARL)JQUEUE.DEF"   source!file;
require "(HELGEM)SUBMIT.DEF" source!file;
require "(HELGEM)SUBMSC.REQ" source!file;
require "(HELGEM)DAYTIM.REQ" source!file;
require "(HELGEM)LICSUB.REQ" source!file;
require "(HELGEM)NEXTIM.REQ" source!file;
require "(CARL)JQUE.REQ"     source!file;

require SUBMIT!VERSION version;		! %1 (100) 21-Mar-86 ;


define Device = { "DSK" };
! define SubmitPrompt = { "ENTER YOUR SUBMIT COMMAND:" } ;
define SubmitPrompt = { ":" };
define SpecialsPrompt = { "!" } ;
define FragmentComplaint = { "yawn..." } ;
define spaces = { "                    " } ;
define dashes = { "--------------------" } ;
define DefaultParam = { "Jobname sequ timel usern aun next" };
define PrtPpn(P) = { (spaces[1 for 6]&cvos(!lh(P)))[inf-5 to inf]&","
			&(cvos(!rh(P))&spaces)[1 for 6] };

define MaxExps = E!MaxItem;

define NumParams = 27 ;
define NumOptns = 20 ;
define NumLog = 4 ;
define NumDispose = 3 ;
define NumMail = 4 ;
define NumSpool = 3 ;
define NumMailer = 2 ;
define NumRestart = 5 ;
define NumUnique = 4 ;
define NumRun = 2 ;
define NumDetach = 2 ;

define HlpMsg = { 
"
           VALID SUBMIT COMMANDS
           ---------------------
[DA]TES    TAKES A DATE SENTENCE
[I]NSERT   INSERT JOB INTO THE JOB QUEUE
[DI]SPLAY  DISPLAYS ALL DATES ASSOCIATED WITH DATE SENTENCE
[E]XPRESS  REPHRASES THE DATE SENTENCE
[T]EST     EXECUTES BOTH EXPRESS AND DISPLAY COMMANDS
[DE]LETE   DELETES SPECIFIED JOB
[S]TATUS   TYPES STATUS OF SPECIFIED JOB BELONGING TO USER
[N]OW      SHOWS CURRENT DATE AND TIME
[L]IST     LISTS ALL JOBS FOR THIS USER
[G]ET      GETS ENTRY BACK FROM JOB LIST
[V]ERSION  TYPE VERSION NUMBER
[Q]UIT     RETURNS TO EXEC
[H]ELP     TYPES THIS MESSAGE 

[C]ODE     OPER ENTERS DATE CODE FOR TESTING/INTERPRETATION
[LO]OK     DISPLAYS CURRENT DATE CODE
[SP]ECIAL  SPECIAL QUEUE MANIPULATION STUFF" };



preload!with
"NONE","APPEND","SUPERSEDE","SPOOL";
string array ARLog[ 0:NumLog - 1   ];

preload!with
"NONE","DELETE","NOERROR";
string array ARDspos[ 0:NumDispose - 1   ];

preload!with
"RPG","TUMS";
string array ARMailer[ 0:NumMailer - 1   ];

preload!with
"NONE","LOGFILE","ERRORLOG";
string array ARSpl[ 0:NumSpool - 1   ];

preload!with
"NONE","ERROR","SUCCESS","ALWAYS";
string array ARMail[ 0:NumMail - 1   ];

preload!with
"NONE","CHECKPOINT","LABEL","CONTINUE","REPEAT";
string array ARRstrt[ 0:NumRestart - 1   ];

preload!with
"NONE","USER","PATH","JOB";
string array ARUniq[ 0:NumUnique - 1   ];

preload!with
"NO","YES";
string array ARRun[ 0:NumRun - 1   ];

preload!with
"NO","YES";
string array ARDetach[ 0:NumDetach - 1   ];

preload!with
"Jobname   ","Sequence","Timelimit","Username    ","PPN          ",
"AUN          ","Priviledge",
"Next Run          ","License",
"Logfile             ","Commandfile         ",
"Label","Trulimit",
"LogLimit","Dependency","Log       ","Dispose ","Mailer",
"Spool     ","Mail","Restart   ","Unique",
"Abort","Run ","Detach","TmpName","All";
string array ListParams[ 0:NumParams - 1   ];

preload!with
10,8,9,12,13,
13,5,
18,7,
24,24,
6,8,
8,10,10,8,6,
10,8,10,6,
5,4,6,7;
integer array fieldlengths[ 0:NumParams - 1 ];

boolean array WhichParams[ 0:NumParams - 1   ];

preload!with
"LABEL","TIMELIMIT","TRULIMIT","",
"LOGLIMIT","Dependency","LOG","DISPOSE","MAILER",
"SPOOL","MAIL","RESTART","UNIQUE","PARAMETERS",
"HELP","?","ABORT",
"RUN","DETACH","TMPNAME";
string array Options[ 0:NumOptns - 1   ];

integer
	I$DayCyc, ! globals contain imbedded "$";
	I$CmmdNum,
	I$Position;

string
	S$ListParameters,
	S$UsrsExp, ! date expression attempted by user;
	S$ThrownOut, ! depository for bad terms thrown out during ScanStr;
	S$Scanned, ! date expression after scanning;
	S$OneUnit, ! 12 char code string for one unit date exp;
	S$DatCod, ! One or more S$OneUnits;
	S$ErrMSG; ! explanation for problem encountered during parse;

boolean
	B$MonUnit, ! set true when a valid month-unit is parsed;
	B$MDYUnit, ! set true when a valid unit such as 9/9/85 or;
		   ! jan 3, 1986 is parsed;
	B$Coded,   ! set true when date code for a given unit has been started;
	B$DayCyc;

integer array Current[ 0:E!Length - 1 ]; ! latest queue entry fetched;
integer array SavEntr[ 0:E!Length - 1 ];      ! save a copy where needed;
integer array Confirm[ 0:E!Length - 1 ];  ! when an entry is fetched, a;
     ! copy is made immediately so that when a modified version is sent;
     ! back to the queue to overwrite original version, the original version;
     ! can be checked against the Confirm to ensure that the queue entry;
     ! has not been changed by another user in the meantime;
string array ModCheck[ 0:NumMods - 1   ];

preload!with
"JANUARY","FEBRUARY","MARCH","APRIL","MAY","JUNE",
"JULY","AUGUST","SEPTEMBER","OCTOBER","NOVEMBER","DECEMBER";
internal string array Mos[ 0:NumMnths - 1 ];

preload!with
"SATURDAY","SUNDAY","MONDAY",
"TUESDAY","WEDNESDAY","THURSDAY","FRIDAY";
internal string array WkDay[ 0:NumWkDay - 1 ];

preload!with
"DA","I","DI","E","T","DE","S","L",
"G","V","Q","H","?",
"C","LO","SP","N";
string array MinCom[ 0:NumCmds - 1 ];

preload!with
"DATES","INSERT","DISPLAY","EXPRESS","TEST","DELETE","STATUS","LIST",
"GET","VERSION","QUIT","HELP","?",
"CODE","LOOK","SPECIAL","NOW";
string array Commands[ 0:NumCmds - 1 ];

preload!with
"EVERY","EVERY","TODAY","TOMORROW","DAYS","MONTH","2",
"SUNDAY","AND","EVERY DAY","31 DAY","31","EVERY SUNDAY","1 DAY EVERY MONTH",
"EVERY MONDAY AND EVERY TUESDAY AND EVERY WEDNESDAY AND EVERY THURSDAY AND EVERY FRIDAY",
"HOURS","MINUTES",
"STARTUP";
string array GoodKey[ 0:NumKeys - 1 ];

preload!with
"EVERY","EACH","TODAY","TOMORROW","DAYS","MONTHS","OTHER",
"WEEKS","AND","DAILY","END","LAST","WEEKLY","MONTHLY",
"WEEKDAYS",
"HOURS","MINUTES",
"STARTUP";
string array Keys[ 0:NumKeys - 1 ];

preload!with
"AFTER","BEFORE",
"AFTER","BEFORE",
"STARTING","UNTIL",
"EXCEPT","EXCEPT","AND";
string array GoodMods[ 0:NumMods - 1   ];

preload!with
">","<",
"AFTER","BEFORE",
"STARTING","UNTIL",
"EXCEPT","NOT","AND";
string array Modifiers[ 0:NumMods - 1   ];


simple boolean procedure ValidTimeStr( reference string S );
! return true if a contiguous string of chars is of the;
! form HH:MM:SS;
BEGIN
	string HH,MM,SS,Copy;
	integer NonDigit;
  Copy_ S;				! save a copy;
  HH_ scan( S,NDigit,NonDigit );
  if NonDigit = ":" then			! was break a ":" ?;
  BEGIN
    if cvd( HH ) > 23 or cvd( HH ) < 0  then ! if yes,check hour in range;
    BEGIN 				! hour out of range 0-23;
      S$ErrMSG_ "?Hour (" & HH & ") - out of range.";
      return( false );
    END
    else 
    BEGIN ! hour is legal so find minute;
      MM_ scan( S,LnBrk,NonDigit );       ! get next number/letter;
      if NonDigit = ":" then 		! true if break was another ":";
      BEGIN
        if cvd( MM ) > 59 or cvd( MM ) < 0  then  ! does minute make sense;
        BEGIN 			! minute was not in range 0-59 so 86;
	  S$ErrMSG_ "?Minute (" & MM & ") - must be from 0 to 59";
	  return( false );
	END
	else 
	BEGIN 
	  SS_ S; 			! now include the second part;
          if cvd( SS ) > 59 or cvd( SS ) < 0  then  ! does minute make sense;
          BEGIN 			! minute was not in range 0-59 so 86;
            S$ErrMSG_ "?Second (" & SS & ") - must be from 0 to 59";
	    return( false );
	  END
	  else 
	  BEGIN 
	    S_ Copy;  ! restore ;
	    return( true );
	  END
	END
      END
      else
      BEGIN ! second break not ":" ;
	if NonDigit = 0 then
	BEGIN
	  S_ Copy;
	  return( true ); ! string such as HH:MM ;
	END
	else 
	BEGIN
 	  S$ErrMsg_ "?UNRECOGNIZABLE WORD: " & Copy & " " ;
	  return( false );
	END
      END
    END
  END  ! if NonDigit = ":" ;
  else 
  BEGIN 			! no ":" found so;
    S_ Copy; 		! restore original;
    return( false );
  END
END;

simple boolean procedure ValidDateStr( reference string S );
! return true if a contiguous string of chars is of the;
! form MM/DD/YY;
BEGIN
  preset!with 31,29,31,30,31,30,31,31,30,31,30,31;
  own safe integer array MonthLength[1:12];
  string MM,DD,YY,Copy;
  Copy_ S;				! save a copy;

  MM_ scan( S,LnBrk,BrkChr );		! scan until non-letter/number;
  if BrkChr = "/" then			! was break a "/" ?;
  BEGIN
    if cvd( MM ) > 12 or cvd( MM ) < 1  then ! if yes,check month in range;
    BEGIN 				! month out of range 1-12;
      S$ErrMSG_ "?Month (" & MM & ") - out of range.";
      return( false );
    END
    else
    BEGIN ! month is legal so find day;
      DD_ scan( S,LnBrk,BrkChr );       ! get next number/letter;
      if BrkChr = "/" then 		! true if break was another "/";
      BEGIN
        if not( 1 leq cvd( DD ) leq MonthLength[cvd(MM)] ) then  ! valid day?;
        BEGIN 			! day was not in range 1-31 so 86;
          S$ErrMSG_ "?Day (" & DD & ") - must be in range 1 to "
		    & Cvs(MonthLength[cvd(MM)]);
          return( false );
        END
        else
        BEGIN 
          YY_ S; 			! now include the year part;
          ! now change to form as "JANUARY 12, 85;
          S_ mos[cvd(MM)-1] & " " & DD & " " & YY;
          return( true );
        END
      END
      else
      BEGIN
        S_ Copy;
        return( false );
      END
    END
  END
  else
  BEGIN 			! no slash found so, see if dash ;
    if BrkChr = "-" then
    BEGIN
      DD_ MM;				! read "DD" of DD-MMM-YY ;
      MM_ scan( S,LnBrk,BrkChr );       ! get next number/letter;
      if BrkChr = "-" then 		! true if break was another dash;
      BEGIN
	if ( 0 leq FndKey( MM, mos ) ) then	! if yes,check month in range;
	BEGIN
	  MM_ cvs( FndKey( MM, mos )+1 );
	END
	else
	BEGIN 				! month out of range 1-12;
	  S$ErrMSG_ "?Unknown month name: " & MM;
	  return( false );
	END;
        if not( 1 leq cvd( DD ) leq MonthLength[cvd(MM)] ) then  ! does day make sense;
        BEGIN 			! day was not in range 1-31 so 86;
          S$ErrMSG_ "?Day (" & DD & ") - must be in range 1 to "
		  & cvs( MonthLength[ cvd(MM) ] );
          return( false );
        END
        else
        BEGIN 
          YY_ S; 			! now include the year part;
          ! now change to form as "JANUARY 12, 85;
          S_ mos[cvd(MM)-1] & " " & DD & " " & YY;
          return( true );
        END
      END
    END
    else
    BEGIN
      S_ Copy; 		! restore original;
      return( false );
    END
  END
END;


simple boolean procedure ValidDOW( string S );
! true if S is a day-of-the-week, ex: "MONDAY" ;
BEGIN
  integer i;
  for i_ 0 upto NumWkDay - 1 do			! check whole array;
    if EQU( S,WkDay[ i ] ) then
      return( true );
    return( false ); ! no match;
END;



simple boolean procedure ValidMOY( string S );
! validates words such as "AUGUST", or "MAY";
BEGIN
  integer i; 
  for i_ 0 upto NumMnths - 1 do		! check array for match;
    if EQU( S,Mos[ i ] ) then
      return( true );
  return( false ); ! no match;
END;


simple boolean procedure ValidKey( reference  string S );
! validates words such as "EVERY" or "AND";
! if a correct abbreviation is typed, the full word will be substituted;
BEGIN
  integer i; 
  if length( S ) < 3 then 
    return( false );
  for i_ 0 upto NumKeys - 1 do			! check array for match;
    if KEQU( S,Keys[ i ][ 1 for length( S ) ] ) then
    BEGIN
      S_ GoodKey[ i ]; 		! replace with match from array;
      return( true );
    END;
  return( false ); ! no match;
END;


simple boolean procedure ValidMODIFIER( string S );
! validates words such as "AFTER" or "EXCEPT";
BEGIN
  integer i;
  for  i_ 0 upto NumMods - 1  do
    if EQU( S,Modifiers[ i ] ) then
      return( true );
  return( false ); ! no match;
END;


simple boolean procedure ValOrdNum( reference string S );
! validates words such as "3RD" or "1ST";
! if a correct abbreviation is typed, the full word will be substituted;
BEGIN
  integer c,i,BrkChr;
  string temp;
  temp_ S; 				! save original string;
  for i_ 1 upto length( S ) do
  BEGIN
    c_ lop( S );			! get first char;
    if "0" leq c leq "9" then		! is it a number;
    BEGIN
      continue			! if yes then loop again for next char;
    END
    else				! non-number found;
    BEGIN
      if i < 2 then 			! better not be in first position;
      BEGIN
        S_ temp;			! if so then restore and return;
        return( false );
      END
      else				! else replace non-number;
      BEGIN
        S_ c & S;
        done;			! out of for loop;
      END
    END
  END;
  ! now check non-number part for the right two letters;
  if KEQU( S[ 1 for 2 ] ,"RD" ) or
    KEQU( S[ 1 for 2 ] ,"ST" ) or
    KEQU( S[ 1 for 2 ] ,"TH" ) or
    KEQU( S[ 1 for 2 ] ,"ND" ) then
  BEGIN
    S_ cvs( intscan( temp,BrkChr ) ); ! it's valid but just return number;
    if cvd( S ) > 31 then
      S_ "31";			
    return( true )
  END
  else
  S_ temp;				! invalid so restore;
  return( false );			! and return false;
END;


simple string procedure ScanStr( string EnglishStr );
! deletes un-identifyable words or fragments from the date;
! expression typed by the user;
BEGIN
  string OneWord,GoodStr,SS;
  S$ErrMSG_ GoodStr_ S$ThrownOut_ null;
  do
  BEGIN
    SS_ scan( EnglishStr,SkJunk,BrkChr ); 
    OneWord_ scan( EnglishStr,NxtWrd,BrkChr ); ! get next word;
    if Val( GoodMods,OneWord,NumMods ) then
      GoodStr_ GoodStr & OneWord & " "
    else
    if ValidKey( OneWord ) then
      GoodStr_ GoodStr & OneWord & " "
    else
    if ValNum( OneWord ) then
      GoodStr_ GoodStr & OneWord & " "
    else
    if Val( WkDay,OneWord,NumWkDay ) then
      GoodStr_ GoodStr & OneWord & " "
    else
    if ValidTimeStr( OneWord ) then
      GoodStr_ GoodStr & OneWord & " "
    else
    if ValidDateStr( OneWord ) then
      GoodStr_ GoodStr & OneWord & " "
    else
    if ValOrd( OneWord ) then
      GoodStr_ GoodStr & OneWord & " "
    else
    if Val( Mos,OneWord,NumMnths ) then
      GoodStr_ GoodStr & OneWord & " "
    else
    if ValOrdNum( OneWord ) then
      GoodStr_ GoodStr & OneWord & " "
    else
    if NOT KEQU( OneWord,"THE" ) and 
      NOT KEQU( OneWord,"OF" ) and
      NOT KEQU( OneWord,"AT" ) then
      S$ThrownOut_ S$ThrownOut & '42 & OneWord & '42 & " "; ! record discards;
  END
  until length( EnglishStr ) = 0;
  return( GoodStr );
END;


simple string procedure GetTodDate;
! returns MM DD YYYY (todays date);
BEGIN "GetTodDate"
  integer Day,Month,Year,Raw;
  Raw_calli(0,calli!DATE);
  Month_((Raw DIV 31) MOD 12) + 1;
  Day_(Raw MOD 31) + 1;Year_(Raw DIV 365) + 64;
  Return(CVS(Month)&" "&CVS(DAY)&" "&CVS(Year));
END "GetTodDate";


simple integer procedure TodaysIntrnDat;
! returns today's displacement in days from jan 1, 1964;
BEGIN
  own safe integer array Date[0:2];

  Date[0]_ calli( 0, calli!DATE );	! Date: DEC format ;
  Date[1]_ 0;				! Time: none given ;
  Date[2]_ '400000;			! New:  0-DEC ,, 400000-TYM ;
  calli( location(Date[0]), calli!DATUUO );
  return( Date[0] );			! converted date, TYM format ;

END;


simple integer procedure Today;
! Returns today's WkDay : 0 - 1 ( Saturday - Friday );
BEGIN

  return( (TodaysIntrnDat + 4 ) mod 7 );	! Jan 1st was a WED = 0 ;

END;


simple integer procedure DayNum( string Day );
! given name of day returns day number.;
! SAT - FRI = 0 - 6.;
BEGIN
  integer i;
  for i_ 0 upto 6 do			! check array for match;
    if KEQU( Day,WkDay[ i ] ) then
      return( i );
END;


simple integer procedure MonthNum( string Mon );
! given name of month returns month number.;
! JAN - DEC = 0 - 11.;
BEGIN
  integer i;
  Mon_ Upper( Mon );
  for i_ 0 upto 11 do			! check array for match;
    if KEQU( Mon[ 1 for 3 ],Mos[ i ][ 1 for 3 ] ) then
      return( i );
END;


simple procedure GetDateSpec;
! returns what user types upto a period followed by <cr>;
BEGIN
  print(crlf,"ENTER YOUR DATE/TIME SENTENCE",crlf );
  BrkChr_ 0;
  S$UsrsExp_ null;
  while BrkChr = 0 do
  BEGIN
    S$UsrsExp_ S$UsrsExp & inchwl & " ";	! get a line at a time;
    S$UsrsExp_ scan( S$UsrsExp,ToDot,BrkChr );	! waiting for a period;
  END;
END;


simple procedure SetCode( integer a,b,c,d,e );
BEGIN
  B$Coded_ true;
  if GetMult = 0 then
    PutMult( a );
  if GetType = 0 then
    PutType( b );
  if GetMoMult = 0 then
    PutMoMult( c );
  if GetBody = 0 then
    PutBody( d );
  if GetConn = 0 then
    PutConn( e );
END;


simple boolean procedure UNIT( string S;
				reference string S$ErrMSG
			     );
! returns true with S$ErrMSG = null if a valid unit was passed;
! returns false with S$ErrMSG = null if a fragment of a valid unit was passed;
! returns false with S$ErrMSG containing an error message if what was passed
contains a violation of the syntax;
BEGIN
  boolean DOW,MOY,Cyclic;
  integer MM,DD,YY,cycle,diff,TGTDay,BaseDayNum,NextDate,base;
  string Str,BaseDay;
  Cyclic_ false; ! becomes true if "every" is found;
  B$MDYUnit_ false; ! becomes true if the unit was MM/DD/YYYY or MMM DD, YYYY;
  Str_ LopWrd( S ); ! get first word;

  if KEQU( Str,"STARTUP" ) then
  BEGIN
    SetCode( 0,TypS,0,0,ENDCon );
    SREF( -1 );
    return( true );
  END;

  if KEQU( Str,"TODAY" ) then
  BEGIN
    SetCode( 0,TypS,0,0,ENDCon );
    B$MDYUnit_ true;
    SREF( TodaysIntrnDat );
    return( true );
  END;

  if KEQU( Str,"TOMORROW" ) then
  BEGIN
    SetCode( 0,TypS,0,0,ENDCon );
    B$MDYUnit_ true;
    SREF( TodaysIntrnDat + 1);
    return( true );
  END;

  if KEQU( Str,"EVERY" ) then
  BEGIN
    Cyclic_ true;
    Cycle_ 1;
    if length( S ) = 0 then
      return( false )
    else
      Str_ LopWrd( S ); 			! get word after "every";
  END;

  if ValidMOY( Str ) then 		! is the word a month such as "MARCH"?;
  BEGIN 
    if Cyclic then 		! "every" was encountered previously;
    BEGIN 		! expressions such as "every August" are invalid;
      S$ErrMSG_ "EVERY cannot be followed by a date or month";
      return( false );
    END;
    MM_ MonthNum ); 	! convert the month name to a number 0-11;
    if length( S ) = 0 then 	! month name must be followed by something.;
      return( false )		! false but no error since it may come next ;
    else	  	
      Str_ LopWrd( S ); 		! more to string so get next word;

    if ValNum( Str ) then     ! month had better be followed by a number;
    BEGIN
      DD_ cvd( Str ); 		! DD holds the day;
      if length( S ) = 0 then   ! so far so good but return false for more;
        return( false );
      Str_ LopWrd( S ); 	! there is more so check for year number;
      if ValNum( Str ) then   ! need number for year here;
      BEGIN
        YY_ cvd( Str[inf - 1 to inf] );  	! store the year in YY;
        if cvd( GetTodDate[inf - 1 to inf] ) > YY then
        BEGIN
          S$ErrMSG_ "DATE TOO FAR IN THE PAST OR YEAR > 1999";
          return( false );
        END
	else
	BEGIN 					! Date is OK ;
          SetCode( 0,TypS,0,0,ENDCon );
          SREF( CvDate( MM + 1,DD,YY ) );
          B$MDYUnit_ true;
          return( true );
	END
      END
      else
      BEGIN 	! month and day followed by something other than a year;
        S$ErrMSG_ "Month must be followed by DD YYYY";
        return( false );
      END
    END
    else
    BEGIN 	! month followed by something other than a day number;
      S$ErrMSG_ "Month must be followed by DD YYYY";
      return( false );
    END
  END;

  if KEQU( Str,"EVERY" ) then 		! "EVERY" here means fatal trouble;
  BEGIN
    if Cyclic then
      S$ErrMSG_ "CONSECUTIVE EVERY'S"
    else
      S$ErrMSG_ "EVERY must be in first position of a unit ";
    return( false ); 
  END;

  if ValNum( Str ) then 	! a number encountered at BEGINning of unit or;
  BEGIN                  	!   after an "EVERY";
    cycle_ cvd( Str ); 		! store the number in "cycle";
    if length( S ) = 0 then 	! so far so good, return for more;
      return( false )
    else
      Str_ LopWrd( S ); 	! stuff left in string so get next word;

    if KEQU( Str,"EVERY" ) then 	! such as in "10TH [OF] EVERY MONTH";
    BEGIN
      Str_ LopWrd( S ); 		! get next;
      if EQU( Str,null ) then
        return( false );
    END;

    if KEQU( Str[ 1 for 5 ],"MONTH" ) then
    BEGIN 
      if not B$Coded then 	! must be expression such as "EVERY nTH MONTH";
      BEGIN
        SetCode( 0,TypN,Cycle,1,ENDCon );
        return( true );
      END
      else 				! such as "... OF EVERY nTH MONTH";
      BEGIN
        if cycle > 9 then ! multiplier must be < 10;
          cycle_ 9;
      END;
    
      if B$DayCyc then 		! first unit of this same expression was days;
        SetCode( 0,TypN,Cycle,I$DayCyc,ENDCon )
      else 	     ! second part of exp as "1ST WED OF EVERY [cycle] MONTH";
        SetCode( 0,0,Cycle,0,ENDCon );
  
      B$MonUnit_ true; 		! second unit of 2 unit exp must be month unit;
      return( true );
    END ;

    if ValidDOW( Str ) then 	! for example: "EVERY MONDAY" or "2ND WED";
    BEGIN
      SetCode( Cycle,TypW,0,DayNum( Str) ,ENDCon );
      return( true );
    END;

    if KEQU( Str[1 for 3], "DAY" ) then 	! as in "EVERY nTH DAY";
    BEGIN
      I$DayCyc_ Cycle;
      SetCode( 1,TypN,0,Cycle,ENDCon );
      B$DayCyc_ true; 			! a cyclic day unit has been coded;
      return( true );
    END;

    if KEQU( Str[1 for 6], "MINUTE" ) then 	! as in "EVERY nTH MINUTE";
    BEGIN
      if Cycle > 1439 then
      BEGIN
        S$ErrMSG_ "MINUTES MUST NOT BE > 1439";
	return( false );
      END;
      SetCode( 0,TypT,0,Cycle,ENDCon );
      ! SREF( Cycle );
      return( true );
    END;

    if KEQU( Str[1 for 4], "HOUR" ) then 	! as in "EVERY nTH HOUR";
    BEGIN
      if Cycle > 23 then
      BEGIN
        S$ErrMSG_ "HOURS MUST NOT BE > 23";
	return( false );
      END;
      SetCode( 0,TypT,0,Cycle * 60,ENDCon );
      ! SREF( Cycle * 60 );
      return( true );
    END;

    S$ErrMSG_ S$ErrMSG & "(" & Str & ")" &
		 "EXPECTED 'MONTH' OR 'DAY' OR A DAY OF THE WEEK";
    return( false ); 			! Fall-through to here means error ;

  END; 						! if ValNum;

  if KEQU( Str[ 1 for 5 ],"MONTH" ) then 		! as "EVERY MONTH";
  BEGIN 
    if not B$Coded then 	! whole exp is "EVERY MONTH" or "MONTH";
    BEGIN
      if Cycle = 0 then
        Cycle_ 1; 		! "MONTH" becomes "EVERY MONTH" ;
      SetCode( 0,TypN,Cycle,1,ENDCon );
    END
    else
    BEGIN
      if B$DayCyc then ! second half of exp as: "nTH DAY EVERY [cycle] MONTHS";
        SetCode( 0,TypN,Cycle,I$DayCyc,ENDCon )
      else 	    ! it's the second unit of exp as "3RD MOND OF EVERY MONTH";
        SetCode( 0,0,1,0,ENDCon );
    END;
    B$MonUnit_ true; 		! second unit of 2 unit exp must be month unit;
    return( true );
  END;
  
  if ValidDOW( Str ) then 			! as in "EVERY MONDAY" (  );
  BEGIN
    if Cycle = 0 then ! Only the next DOW is required so figure the date ;
    BEGIN
      base_ TodaysIntrnDat;		! base is disp from 1-jan-64 ;
      TGTday_ DayNum( Str );
      BaseDayNum_ ( base + 4 ) mod 7;	! +4 = sat when mod 7 ;
      BaseDay_ WkDay[ BaseDay ];
      if BaseDayNum = TGTday then
        diff_ 0
      else
        if BaseDayNum < TGTday then
          diff_ abs( BaseDayNum - TGTday )
        else
          diff_ 7 - ( BaseDayNum - TGTday );
      NextDate_ base + diff; 
      SetCode( 0,TypS,0,0,ENDCon );
      if NextDate = base then
        SREF( NextDate + 7 )
      else
        SREF( NextDate );
      B$MDYUnit_ true;
      return( true );
    END
    else
    BEGIN
      SetCode( Cycle,TypW,0,DayNum( Str ),ENDCon );
      return( true );
    END
  END;

  if KEQU( Str[1 for 3], "DAY" ) then 			! as in "EVERY DAY" ;
  BEGIN
    if cycle = 0 then 				! need to know how many days;
    BEGIN
      S$ErrMSG_ "NEED HOW MANY DAYS OR EVERY DAY";
      return( false );
    END
    else
    BEGIN
      B$DayCyc_ true; 			   ! a cyclic day unit has been coded;
      SetCode( 1,TypN,0,cycle,ENDCon );
      return( true );
    END
  END;
  return( false );		! Valid Unit will never get to this point ;
END; ! proc UNIT;


simple boolean procedure ValidExpression( string S;
					  reference string S$ErrMSG
					);
! returns true with S$ErrMSG = null if a valid expression was passed;
BEGIN
  string SS;
  SS_ null;
  while true do				 ! get rid of leading blanks;
  BEGIN
    if EQU( S[1 for 1] , " " ) then
      S_ S[ 2 to inf ]
    else
      done;
  END;

  while not UNIT( SS,S$ErrMSG ) do
  BEGIN 
    if equ( S,null ) and equ( S$ErrMSG,null )  then 
    BEGIN
      if equ( SS[ inf for 1 ]," " ) then
        SS_ SS[ 1 to inf - 1 ];
      if ValidTimeStr( SS ) or ValNum( SS ) then
      BEGIN
        STIM( TFract( SS ) );
        B$MonUnit_ B$MDYUnit_ true;
        return( true );
      END
      else
      BEGIN
        ! if what was passed to UNIT was not enough for a;
        ! valid unit and there is none left then must be 86;
        S$ErrMSG_ "INVALID FRAGMENT (A)";
      END
    END;
    SS_ SS & LopWrd( S ) & " "; ! add next word to string, then retry UNIT;
    if EQU( S$ErrMSG,null ) then ! string passed to UNIT was not enough to be
      continue                ! valid but no detectable error yet.;
    else
      return( false ); ! error;
  END;

  B$DayCyc_ false;
  SS_ null;
  if length( S ) > 0 then ! must be another unit ( better be a month unit ) .;
  BEGIN ! check second unit of expression;
    B$MonUnit_ false; ! initialize,  B$MonUnit will become true if the next;
		      !  unit found is a month unit;
    while not UNIT( SS,S$ErrMSG ) do 		! same routine as above;
    BEGIN 
      if equ( S,null ) and equ( S$ErrMSG,null )  then 
      BEGIN
        if equ( SS[ inf for 1 ]," " ) then
          SS_ SS[ 1 to inf - 1 ];
        if ValidTimeStr( SS ) or ValNum( SS ) then
        BEGIN
          STIM( TFract( SS ) );
          B$MonUnit_ B$MDYUnit_ true;
          return( true );
        END
        else
        BEGIN
          ! if what was passed to UNIT was not enough for a;
          ! valid unit and there is none left then must be 86;
          S$ErrMSG_ "INVALID FRAGMENT (B)";
        END
      END;
      SS_ SS & LopWrd( S ) & " ";
      if EQU( S$ErrMSG,null ) then
        continue
      else
        return( false ); 			! error detected in UNIT;
    END;

    if NOT B$MonUnit then
    BEGIN
      S$ErrMSG_ "SECOND UNIT IN TWO UNIT EXPRESION MUST BE A MONTH UNIT";
      return( false );
    END
  END; 					! END checking second unit;

  if equ( S[ inf for 1 ]," " ) then
    S_ S[ 1 to inf - 1 ];
  if length( S ) > 0 then ! can't be more than 2 unit to the expression;
  BEGIN
    if ValidTimeStr( S ) or ValNum( S ) then
    BEGIN
      STIM( TFract( S ) );
      return( true );
    END
    else
    BEGIN
      S$ErrMSG_  "UNKNOWN TERMS: <" & s & ">";
      return( false );
    END
  END
  else
  BEGIN
    return( true );
  END
END; 						! proc ValidExpression ;


boolean procedure ValidGroup( string S;
			      reference string S$ErrMSG
			    );
! gets all up to next "AND" or the END of expression ;
BEGIN 
  integer ModDate,ModTime,ModNum;
  string SS,NxtWrd,LatestMod;
  SS_ LatestMod_ null;
  NxtWrd_ LopWrd( S );
  while true do 			! get all until a modifier or END;
  BEGIN 
    if ValidModifier( NxtWrd ) then	! mod found;
    BEGIN
      if EQU( SS,null ) then
      BEGIN 				! indicates a mod. not without date.;
        S$ErrMSG_ "DOUBLE MODIFIERS"; 
        return( false );
      END
      else
      BEGIN
        LatestMod_ NxtWrd; 		! store the modifier;
        done; 			! leave block to evaluate SS as expression;
      END 			! else;
    END
    else
    BEGIN
      SS_ SS & NxtWrd & " ";
      if length( S ) = 0 then
        done
      else
        NxtWrd_ LopWrd( S );
    END
  END;  		! while true;

  if NOT ValidExpression( SS,S$ErrMSG ) then ! evaluate what we've got ;
  BEGIN
    S$ErrMSG_ S$ErrMSG & " INVALID EXPRESSION!";
    return( false );
  END
  else
  BEGIN
    if length( S ) = 0 then  ! if END of string;
    BEGIN
      if EQU( LatestMod,null ) then
      BEGIN
        if GREF = 0 then
          SREF( TodaysIntrnDat ); ! make sure ref gets set to something ;
        I$Position_ I$Position + D!Length;		! add all on;
        If I$Position = E!Length then
        BEGIN
          S$ErrMSG_ "TOO MANY EXPRESSIONS. MAX = " & cvs( MaxExps );
          return( false );
        END
        else
          return( true );
      END
      else
      BEGIN		! some junk left over in string so something wrong;
        S$ErrMSG_ "INVALID DATE";
        return( false );
      END
    END
  END;

  if GREF = 0 then
    SREF( TodaysIntrnDat ); 	! make sure ref gets set to something ;
  I$Position_ I$Position + D!Length;     ! ready for a new expression ;
  If I$Position = E!Length then
  BEGIN
    S$ErrMSG_ "TOO MANY EXPRESSIONS. MAX = " & cvs( MaxExps );
    return( false );
  END;
  S_ LatestMod & " " & S;    ! modifier which caused break is Put back;

  ! there is more to expression after a mod so get it;
  while true do
  BEGIN
    SS_ LatestMod_ null;
    while true do
    BEGIN 
      NxtWrd_ LopWrd( S );
      if ValidModifier( NxtWrd ) then
      BEGIN
        if EQU( LatestMod,null ) then
        BEGIN
          LatestMod_ NxtWrd;
          if KEQU( LatestMod,"AND" ) then  ! 	!!!!! ;
          BEGIN
            NxtWrd_ LopWrd( S );
            if ValidModifier( NxtWrd ) then
              LatestMod_ NxtWrd
            else
              S_ S & " " & NxtWrd;
          END;
          case LatestMod[1 for 1] of
          BEGIN
            [ "A" ] ModNum_ ( AftCon );
            [ "B" ] ModNum_ ( BefCon );
            [ "S" ] ModNum_ ( StaCon );
            [ "U" ] ModNum_ ( UntCon );
            [ "E" ] ModNum_ ( ExcCon )
          END;
          if length( NxtWrd ) > 0 then
	  BEGIN
            continue
	  END
          else
	  BEGIN
            if EQU( SS,null ) then
            BEGIN
              S$ErrMSG_ "CONTIGUOUS MODIFIERS";
              return( false ); ! ##;
            END
            else
	    BEGIN
              done;
	    END
	  END
        END  		 ! if EQU( LatestMod,null );
        else
        BEGIN
          LatestMod_ NxtWrd;
          S_ LatestMod & " " & S;
          done;
        END
      END 				! if validmodifier;
      else
      BEGIN
        SS_ SS & " " & NxtWrd;
        if EQU( LatestMod,null ) then
        BEGIN
          S$ErrMSG_ "MODIFIER EXPECTED";
          return( false ); 
        END
        else
	BEGIN
          if length( S ) > 0 then
            continue
          else
            done;
	END
      END
    END;

    if ValidExpression( SS,S$ErrMSG ) then
    BEGIN 
      ModDate_ GREF;
      ModTime_ GTIM;
      if length( S )  > 0 then
      BEGIN 
        B$Coded_ true;
        I$Position_ I$Position - D!Length; 	! back up ;
        if ModNum = AftCon then			! if true, set ref date to mod;
        BEGIN
          SREF( ModDate );
        END
        else
        BEGIN
          PutConn( ModNum ) ;			! set the connector ;
          I$Position_ I$Position + D!Length;
          if GREF = 0 then
            SREF( TodaysIntrnDat );
        END;
        I$Position_ I$Position + D!Length;
        If I$Position = E!Length then
        BEGIN
          S$ErrMSG_ "TOO MANY EXPRESSIONS. MAX = " & cvs( MaxExps );
          return( false );
        END
        else
	BEGIN
          PutConn( 0 );
	END;
        continue;
      END
      else
      BEGIN 		! if there is 1 mod it is done here else this is 2nd ;
        if ModNum < 4 then
	BEGIN
          if Not B$MDYUnit then
          BEGIN
            print( crlf,"ModNum=<",ModNum,">" );
            S$ErrMSG_ "NEED A DATE WITH AFTER/UNTIL" & crlf &
                      "  EX: STARTING MMM DD, YYYY .";
            return( false );                
          END
	END;
        B$Coded_ true;
        I$Position_ I$Position - D!Length;
        if ModNum = AftCon then		! if true, set ref date to mod;
        BEGIN
          SREF( ModDate );
!          STIM( ModTime );
 ! print ("A");
        END
        else
        BEGIN
          PutConn( ModNum ) ;		! set the connector ;
          I$Position_ I$Position + D!Length;
          if GREF = 0 then
            SREF( TodaysIntrnDat );
        END;
    
        I$Position_ I$Position + D!Length;
        If I$Position = E!Length then
        BEGIN
          S$ErrMSG_ "TOO MANY EXPRESSIONS. MAX = " & cvs( MaxExps );
          return( false );
        END
        else
        BEGIN
          PutConn( 0 );
          return( true );
        END
      END
    END						! if valid expression;
    else
    BEGIN
      return( false );
    END
  END 						! while true;
END; 						! ValidGroup;


simple boolean procedure ParsedOK( string S;
				   reference string S$ErrMSG
				 );
! takes user's date sentence up to the end and sends it to routines to parse. ;
! If the sentence contains "and"'s, this procedure takes everything between ;
!   "and"'s and individually parses each until whole sentence is done. ;
! Returns true if no errors detected. ;
BEGIN
  string Onestring,SS;
  integer ANDcount;

  ANDcount_ HowMany( S,"AND" );
  while true do
  BEGIN
    Onestring_ S_ " " & S; 	! first word not a modifier so replace.;
    if ANDcount > 0 then
      Onestring_ LopTo( S,"AND" ); 	  ! get everthing upto next "and";
    if ValidGroup( Onestring,S$ErrMSG ) then 	! should be a valid group;
    BEGIN
      if ANDcount > 0 then 		! there is another "and" ahead;
      BEGIN
        B$Coded_ true;
        I$Position_ I$Position - D!Length;
        PutConn( AndCon ) ;
        I$Position_ I$Position + D!Length;
      END;
      ANDcount_ ANDcount - 1;
      if ANDcount < 0 then
        return( true )
      else
        continue;
    END
    else
    BEGIN
      return( false );
    END
  END 						! while true;
END;


simple procedure express;
! Translares date code into English and displays. ;
BEGIN
  integer Multiplier,MoMultiplier,Body,NumExps,i,j,refDate,
  Type,Connector,ExpS,TimFrac,Minutes,Hours;
  I$Position_ E!Descriptor;
  if GetConn = 0 then
  BEGIN
    print( "NO REQUEST HAS BEEN ENTERED",crlf );
    return;
  END;
  for I$Position_ E!Descriptor step D!Length until E!Length - 1 do
  BEGIN
    Multiplier_ GetMult;
    type_ GetType;
    MoMultiplier_ GetMoMult;
    body_ GetBody;
    Connector_ GetConn;
    refDate_ GREF;
    if EQU( type, TypW ) then
    BEGIN
      if MoMultiplier > 0 then
      BEGIN
        print(      if Multiplier = 1 then "THE FIRST "
                else if Multiplier = 2 then "THE SECOND "
                else if Multiplier = 3 then "THE THIRD "
                else if Multiplier = 0 then " ONCE ONLY:A "
                else if Multiplier = 9 then "THE LAST "
                else  "THE " & cvs( Multiplier ) & "TH " 
              );
        print( WkDay[ body ] );
        print(      if MoMultiplier = 1 then " OF EVERY MONTH "
                else if MoMultiplier = 2 then " OF EVERY OTHER MONTH"
                else if MoMultiplier = 3 then " OF EVERY THIRD MONTH"
                else if MoMultiplier > 3 then " OF EVERY " 
                                          & cvs( MoMultiplier ) & "TH MONTH"
                else null
              );
      END
      else
      BEGIN
        print(      if Multiplier = 1 then "EVERY "
                else if Multiplier = 2 then "EVERY OTHER "
                else if Multiplier = 0 then ""
                else if Multiplier = 3 then "EVERY 3RD "
                else "EVERY " & cvs( Multiplier ) & "TH "
              );
        print( WkDay[ body ] );
      END
    END;

    if type = TypN then
    BEGIN
      if MoMultiplier > 0 then
      BEGIN
        print( "THE " );
        print(       if body = 32 then "LAST DAY " 
                else if body = 1 then "FIRST DAY " 
                else if body = 2 then "SECOND DAY " 
                else if body = 3 then "THIRD DAY "
                else cvs( body ) & "TH DAY "
              );
        print(      if MoMultiplier = 1 then "OF EVERY MONTH "
                else if MoMultiplier = 2 then "OF EVERY OTHER MONTH"
                else if MoMultiplier = 3 then "OF EVERY THIRD MONTH"
                else if MoMultiplier > 3 then "OF EVERY " 
                     & cvs( MoMultiplier ) & "TH MONTH"
                else null
              );
      END
      else
      BEGIN
        print( "EVERY " );
        print(       if body = 1 then "DAY " 
                    else if body = 2 then "SECOND DAY " 
                    else if body = 3 then "THIRD DAY "
                    else cvs( body ) & "TH DAY "
              );
      END
    END;

    if type = TypT then
    BEGIN
      Minutes_ body;
      Hours_ Minutes Div 60;
      Minutes_ Minutes mod 60;
      if Hours > 0 then
      BEGIN
        print( "EVERY " , Hours , " HOURS" );
        if Minutes > 0 then
        BEGIN
          print( " AND " , Minutes , " MINUTES" );
        END
      END
      else
      BEGIN
        print( "EVERY ", Minutes ," MINUTES" );
      END;
      print( " BASED ON " );
      print( CvSTim( GTIM ) );
    END;

    if type = TypS then
    BEGIN
      if refDate = 262143 then
        print( "STARTUP" )
      else
        print( CvSDat( refDate ) );
    END;

    if not type = TypT and
       not refDate = 262143 then
    BEGIN
      TimFrac_ GTIM;
      print( if TimFrac = 0 then " AT MIDNIGHT"
            else " AT " & CvsTim( TimFrac )
            );
    END;

    if GREF > TodaysIntrnDat and
        not type = TypS       then
      print( " AFTER ",CvSDat( GREF ) );

    case connector of 
    BEGIN
      [  AndCon  ] print( " AND " );
      [  StaCon  ] print( " STARTING: " );
      [  BefCon  ] print( " BEFORE: " );
      [  ExcCon  ] print( " EXCEPT: " );
      [  UntCon  ] print( " UNTIL: " );
      [  ENDCon  ] print( "." );
      else 	! event of an unknown connector ( should never happen );
        print( crlf," ?" ,connector,"?",crlf,"              " )
    END;
    if Connector = ENDCon then
      done;
  END; ! for;
  print( crlf );
END; ! proc express;


simple procedure Display;
! Generates sample dates based on users date sentence. ;
BEGIN
  string date,DOW,stop;
  integer baseDT,dis,DatsDisplayed;
  I$Position_ E!Descriptor;
  if GetConn = 0 then
  BEGIN
    print( "NO REQUEST HAS BEEN ENTERED",crlf );
    return;
  END;    
  DatsDisplayed_ 0;
  baseDT_ !xwd( TodaysIntrnDat,TFract( TheTime ) );
  while true do
  BEGIN
    DatsDisplayed_ DatsDisplayed + 1;
    dis_ NexTim( Current,baseDT ); ! returns 0 if no further dates;
    baseDT_ dis;
    if dis = 0 or !lh( dis ) > 13148 then ! no dates after 12/31/1999;
    BEGIN
      print( crlf,"no further dates.",crlf );
      done;
    END;
    Date_ CvSDat( !lh( dis ) );
    DOW_ WkDay[ ( !lh( dis ) + 4 ) mod 7 ]; ! figure the day of the week;
    print( date," ",DOW );
    print( "          "[ 1 for ( 10 - length( DOW ) ) ] );
    print( " AT ",CvSTim( !rh( dis ) ) );
    if DatsDisplayed = 10 then 
    BEGIN
      print( " - enter a char for more dates else <cr> only." );
      if equ( inchrw,#cr ) then
        return
      else
        DatsDisplayed_ 0;
    END;
    print( crlf );
  END
END;


simple procedure Look;
! Shows date code generated by a date sentence. ;
BEGIN
  integer i;
  if GetConn = 0 then
    print( "NO REQUEST HAS BEEN ENTERED",crlf )
  else
  BEGIN
    for I$Position_ E!Descriptor step D!Length
    until ( E!Length - D!Length - 1 ) do
    BEGIN
      print( "/T  bbbbC      ( time )" );
      if GetConn = ENDCon then done;
    END;
    print( "/" );
    print( crlf );
    for I$Position_ E!Descriptor step D!Length
    until ( E!Length - D!Length - 1 ) do
    BEGIN
      print( GetMult    );
      print( GetType    );
      setformat( -2,2 );
      print( GetMoMult  );
      setformat( -4,4 );
      print( GetBody    );
      setformat( 0,7 );
      print( GetConn    );
      setformat( -5,5 );
      print( GREF );
!     print( !lh( Current[ I$Position + D!Daytime ] ) );
!     setformat( -6,6 );
      print( "," );
      print( CvSTim( GTIM ) );
      setformat( 0,7 );
      if GetConn = ENDCon then done;
    END
  END;
  print( crlf );
END;


simple procedure Test;
! Performs "express" and "display" commands. ;
  if GetConn = 0 then
  BEGIN
    print( "NO REQUEST HAS BEEN ENTERED",crlf );
    return;
  END
  else
  BEGIN
    express;
    Display;
  END;


simple procedure TrialCode;
! user want's to type his own date code;
BEGIN
  integer toda;
  string EStr,RD;
  toda_ TodaysIntrnDat;
  while true do
  BEGIN
    print( crlf,"type sample code as WTMMDDX " );
    print( crlf,"                   :" );
    if equ( EStr_ inchwl , null ) then
      done;
    if length( EStr ) = 7 then 
    BEGIN 
      PutMult( cvd( EStr[ 1 for 1 ] ) ) ;
      PutType( cvd( EStr[ 2 for 1 ] ) ) ;
      PutMoMult( cvd( EStr[ 3 for 2 ] ) );
      PutBody( cvd( EStr[ 5 for 2 ] ) ) ;
      PutConn( cvd( EStr[ 7 for 1 ] ) ) ;
      print( crlf,"type reference date as nnnnn [today]" );
      print( crlf,"                      :" );
      if equ( RD_ inchwl, null ) then
        SREF( toda )
      else
        SREF( cvd( RD ) );
      print( "Code with reference date (",CvSDat( toda ),"): " );
      for I$Position_ E!Descriptor step D!Length
        until ( E!Length - D!Length - 1 ) do
        BEGIN
          print( GetMult );
          print( GetType    );
          setformat( -2,2 );
          print( GetMoMult  );
          print( GetBody    );
          setformat( 0,7 );
          print( GetConn    );
          setformat( -5,5 );
          print( !lh( Current[ I$Position + D!Daytime ] )," " );
          ! print( !rh( Current[ I$Position + D!Daytime ] )," (date,time)" );
          setformat( 0,7 );
          print( crlf );
          if GetConn = ENDCon then done;
        END;
      done;
    END
    else
      print( #bel,"must be 7 characters, try again" );
    print( crlf );
  END
END;


simple string procedure GetComFrTerm(string PromptLine);
! prompts with PromptLine and returns user response.;
! Only certain character are echoed;
BEGIN
  string line,Response;
  line_ Response_ null;
  print(crlf,PromptLine," " ); 		! sEND the prompt to the term;
  clrbuf;
  auxclr(-1,memory['200],'64);		! turn off term echo;
  while true do
  BEGIN
    Response_ inchrw; 			! get one legal char;
    if Response = '15 then 
      if length( line ) = 0 then
      BEGIN
        print(crlf,PromptLine," " ); 		! try again ;
        line_ null;
        clrbuf;
        continue;
      END
      else
        done;
    if ( Response = #bs    or   	! implement backspace/delete;
          Response = #del ) then
    BEGIN
      if not equ( line,null ) then 	! but don't erase prompt ;
      BEGIN
        print( #bs & " " & #bs ); 	! bs/del on term;
        line_ line[ 1 to inf - 1 ];  	! remove from END of line;
      END
    END
    else
    BEGIN
      print( Response ); 		! since it is legal, echo it now;
      line_ line & Response;		! add legal char to line;
    END
  END;
  auxclr(-1,memory['000],'64);		! turn echo back on;
  if EQU( Line,null ) then		
    return( null ) 			! return null if <cr> (only) is typed;
  else
    return( upper( line ) );		! return what weve got in uppercase;
END; ! GetComFrTerm;


simple integer procedure GetCommand( string prompt );
! validates command words such as "DATES" or "EXPRESS";
! if a correct abbreviation is typed, the full word will be substituted;
BEGIN
  integer i;
  string Response,Word;
  S$ListParameters_ null;
  while true do
  BEGIN
    Response_ GetComFrTerm( prompt );
    Word_ LopWrd( Response ); ! get first word sans trailing blanks;
    for i_ 0 upto NumCmds - 1 do		! check array for match;
    BEGIN
      if KEQU( Word[ 1 for length( MinCom[ i ] ) ] , MinCom[ i ] ) then
      BEGIN
        if KEQU( Word,Commands[ i ][ 1 for length( Word ) ] ) then
        BEGIN	! match found, fill in what operator omitted;
          if i = 7 then ! "LIST" ;
	    S$ListParameters_ Response;
          print( Commands[ i ][ ( length( Word ) + 1 ) to inf ],crlf );
          return( i );
        END
      END
    END;
    print( crlf,'42 & Word & '42 & " IS NOT A COMMAND",crlf );
  END
END;


simple integer procedure Validate( string array AR ;
				   reference string S ;
				    integer ArrSize
				 );
BEGIN
  integer i,SavI ;string Str,Sav ; boolean MatchF ;
  Sav_ S; SavI_ -1; MatchF_ false ; Str_ null;
  if equ( S,null ) then
    return( 0 );
  while true do
  BEGIN "add to str"
    if length( S ) then
    BEGIN
      Str_ Str & Lop( S );
      MatchF_ false;
      for i_ 0 upto ArrSize do
      BEGIN
        if KEQU( Str,AR[ i ][ 1 for length( Str ) ] ) then
        BEGIN 	
          SavI_ i;
          if MatchF then
            continue "add to str" 
          else
            matchF_ true;
        END 
      END;
      if not MatchF then
      BEGIN
        S_ Sav;
        return( -1 );
      END
    END
    else
    BEGIN
      if SavI geq 0 then
      BEGIN
        S_ AR[ SavI ];
        return( SavI );
      END
      else
      BEGIN
        S_ Sav;
        return( -1 );
      END
    END
  END "add to str"; 
END;


simple procedure GetOptions;
! Prompt user for options before insertion. ;
BEGIN "getoptions"
  integer OptNum,Num,BP,BPI;
  integer TimeLimit,TRULimit,LogLimit,Dependency;
  string Response,Str;
  string Labl,Log,Dispose,Mail,Spool,Mailer,Restart,Unique,Parameters,
          Run,Detach,TMPNAME;
  integer LablNum,LogNum,DisposeNum,MailNum,SpoolNum,
  MailerNum,RestartNum,UniqueNum,RunNum,DetachNum,ParametersNum;

simple procedure HelpOption( String Head; Integer Index; String Array Names );
BEGIN
  integer I,L;

  print( Head );
  for I_ (L_ arrInfo(Names,1)) upto arrInfo(Names,2) do
  BEGIN
    if i neq L then
      print( "," );
    if i = Index then
      print( " [", Names[ i ], "]" )
     else
      Print( " ", Names[ i ] );
  END;
END;

simple procedure HelpRoutine;
BEGIN
  integer i;
  print( crlf,"     OPTIONS          PARAMETERS [CURRENT SETTING]" );
  print( crlf,"     -------          ----------" );

  HelpOption( crlf &"      LOG             ", LogNum,     ARLog    );
  HelpOption( crlf &"      DISPOSE         ", DisposeNum, ARDspos  );
  HelpOption( crlf &"      MAIL            ", MailNum,    ARMail   );
  HelpOption( crlf &"      MAILER          ", MailerNum,  ARMailer );
  HelpOption( crlf &"      RESTART         ", RestartNum, ARRstrt  );
  HelpOption( crlf &"      RUN             ", RunNum,     ARRun    );
  HelpOption( crlf &"      DETACH          ", DetachNum,  ARDetach );
  print( crlf );
  print( crlf,     "      LABEL            " );
  if equ( labl,null ) then
    print( "[null]" )
  else
    print( "[",Labl,"]" );

  print( crlf,     "      TIMELIMIT        ", "[",TimeLimit,"]" );
  print( crlf,     "      LOGLIMIT         ", "[",LogLimit,"]" );
  print( crlf,     "      TRULIMIT         ", "[",TRULimit,"]" );
  print( crlf,     "      DEPENDENCY       ", "[",Dependency,"]" );
  print( crlf,     "      PARAMETERS       " );

  Parameters_ null;
  BP_ Point( 7, Current[ E!Parameters ], -1 );
  For BPI_ 1 upto E!ParLength do
    if ( ILDB( BP ) ) then
      Parameters_ Parameters & LDB( BP );
  if ( length( Parameters ) = 0 ) then
    print( "[none]" )
  else
    print( "[",Parameters,"]" );
END;

  Labl_ Parameters_ null;

  Mail_ Spool_ Mailer_ Restart_ Unique_ 0;
  RunNum_ DetachNum_ 0;

  TimeLimit_ 60;
  TRULimit_ LogLimit_ Dependency_ 0;
  LogNum_ JL$Supersede;
  DisposeNum_ JD$None;
  SpoolNum_ JS$None;
  MailerNum_ JP$RPG;
  MailNum_ JM$Always;
  RestartNum_ JR$None;
  UniqueNum_ JU$None;

Define SetOpVal( OpNum, OpStr, OpVal ) = {
if ( 0 leq OpNum_ FndKey( OpStr_ LopWrd(Response), OpVal ) ) then
BEGIN
  print( OpStr," IS NOT A VALID PARAMETER FOR ",options[OptNum]," OPTION." );
  OpNum_ 0;
END
};

  while true do
  BEGIN
    Response_ Prompt( "OPTIONS: " );
    if ( length( Response ) = 0 ) then
      done;
    Str_ LopWrd( Response );
    case ( OptNum_ FndKey( Str, Options ) ) of
    BEGIN
      [ 0 ]  Labl_ LopWrd( Response )[1 for 6];
      [ 1 ]  BEGIN
		TimeLimit_ intscan( Response,BrkChr );
		if BrkChr = -1 then
		  TimeLimit_ 60;
             END;
      [ 2 ]  TRULimit_ intscan( Response,BrkChr );
      [ 4 ]  LogLimit_ intscan( Response,BrkChr );
      [ 5 ]  Dependency_ intscan( Response,BrkChr );
      [ 6 ]  SetOpVal( LogNum, Log, ARLog );
      [ 7 ]  SetOpVal( DisposeNum, Dispose, ARDspos );
      [ 8 ]  SetOpVal( MailerNum, Mailer, ARMailer );
      [ 9 ]  SetOpVal( SpoolNum, Spool, ARSpl );
      [ 10 ] SetOpVal( MailNum, Mail, ARMail );
      [ 11 ] SetOpVal( RestartNum, Restart, ARRstrt );
      [ 12 ] SetOpVal( UniqueNum, Unique, ARUniq );
      [ 13 ] BEGIN
		Parameters_ Response;
		If ( length( Parameters ) > E!ParLength ) then
		  print( "PARAMETERS MUST BE 1-",E!ParLength,
			 " CHARACTERS LONG" )
		else
                BEGIN
                  BP_ Point( 7, Current[ E!Parameters ], -1 );
                  For BPI_ 1 upto E!ParLength do 
                    IDPB( lop( Parameters ), BP );
                END
              END;
      [ 14 ] HelpRoutine;
      [ 15 ] HelpRoutine;
      [ 16 ] Return;
      [ 17 ] SetOpVal( RunNum, Run, ARRun );
      [ 18 ] SetOpVal( DetachNum, Detach, ARDetach );
      [ 19 ] TMPNAME_ CvSix( Response );

      else  print( "UNRECOGNIZED OPTION - TYPE H FOR HELP" )

    END ! case ;

  END; ! while ;

  Current[ E!Label ]_ CvSix( Labl );
  Current[ E!TruLim ]_ TRULimit;
  DPB( TMPNAME lsh -18,  PPTmpN( Current ) ); 
  DPB( LogLimit,         PPLogL( Current ) ); 
  DPB( TimeLimit,        PPTimL( Current ) ); 
  DPB( 0,                PPStat( Current ) );
  DPB( 0,                PPProc( Current ) ); 
  DPB( Dependency,       PPDepL( Current ) ); 
  DPB( 0,                PPSeq(  Current ) ); 
  DPB( LogNum,           PPLog(  Current ) );
  DPB( DisposeNum,       PPDisp( Current ) ); 
  DPB( SpoolNum,         PPSpl(  Current ) ); 
  DPB( MailNum,          PPMail( Current ) ); 
  DPB( MailerNum,        PPMPrg( Current ) ); 
  DPB( RestartNum,    PPRestart( Current ) ); 
  DPB( UniqueNum,        PPUniq( Current ) ); 

END "getoptions";


simple procedure InsertFN( integer array ENtr;
			   string FiName;
			   integer position
			 );
! places username into array positions position+F!User - position+F!User+1,
filename into position + F!Name, and extention in position + F!Ext;
BEGIN
  string Un,Fn,Ext,Dv;
  Dv_ Un_ Fn_ Ext_ null;
  if not Dv then
    Dv_ Device;
  ENtr[ position + F!Device ]_ CvSix( Dv );
  if EQU( FiName[ 1 for 1 ],"(" ) then
  BEGIN
    FiName_ FiName[ 2 to inf ];
    while not equ( FiName[ 1 for 1 ], ")" ) do
      Un_ Un & lop( FiName );
    FiName_ FiName[ 2 to inf ];
  END
  else
  BEGIN
    Un_      cvxStr( calli( !xwd( -1,!GTUNM ),calli!gettab ) );
    Un_ Un & cvxStr( calli( !xwd( -1,!GTUN1 ),calli!gettab ) );
  END;
  Entr[ position + F!User ]_ cvsix( Un[ 1 for 6 ] );
  Entr[ position + F!User + 1 ]_ cvsix( Un[ 7 for 6 ] );
  while not equ( FiName[ 1 for 1 ], "." ) and Length( FiName ) > 0 do
    Fn_ Fn & lop( FiName );
  Entr[ position + F!Name ]_ cvsix( Fn );
  if length( FiName ) > 0 then
    Ext_ FiName[ 2 to inf ];
  Entr[ position + F!Ext ]_ cvsix( Ext );
END;


simple integer procedure GeChan(string NameForTheNewFile); 
! create a new file for binary i/o;
BEGIN
  integer eof,NewFilChan;
  open(NewFilChan_getchan,"DSK",'14,0,4,0,0,eof);
  enter(NewFilChan,NameForTheNewFile,eof);
  if eof then
  BEGIN
    print( "Can't open ",NameForTheNewFile,crlf );
    return( -1 );
  END;
  return(NewFilChan);
END;


simple integer procedure OpChan(string NameOfTheFile);
! Open a currently existing file for binary i/o;
BEGIN
  integer eof,
  FilChan;
  open(FilChan_getchan,"DSK",'14,2,0,500,0,eof);
  LookUp(FilChan,NameOfTheFile,eof);
  if eof then
  BEGIN
    print( "Can't find ",NameOfTheFile,crlf );
    return( -1 );
  END;
  return(FilChan);
END;


simple procedure MakeHeader( integer DatNextRun,TimNextRun );
! conStructs the 24 word header ( positions 0 - 23 );
BEGIN
  integer ComFlChan,LogFlChan;
  string  ComFN,LogFN;
  Current[ E!RunTime ]_      !xwd( DatNextRun,TimNextRun ); 
  Current[ E!PPN ]_          calli( !xwd( -1,!GTPPN ),calli!gettab );      
  Current[ E!Privs ]_        calli( !xwd( -1,!GTPRV ),calli!gettab );    
  Current[ E!AUN ]_          calli( !xwd( -1,!GTAUN ),calli!gettab );  
  Current[ E!Username ]_     calli( !xwd( -1,!GTUNM ),calli!gettab );
  Current[ E!username + 1 ]_ calli( !xwd( -1,!GTUN1 ),calli!gettab );
  Current[ E!License ]_ !rh( calli( !xwd( -1,!GTLIC ),calli!gettab ) );
  calli( !xwd( 0, location( Current[ E!Project ] ) ), calli!chprj );
  Current[ E!Network ]_ !xwd( 1, location( Current[ E!Network ] ) );
  start!code
    define !forfa = '36;
    hrloi	1,!forfa;
    uuo!FRMOP 1,Current[ E!Network ];
    setzm Current[ E!Network ];
  END;
  Do 
  BEGIN
    ComFN_ Prompt( "NAME OF COMMAND FILE" );
  END
  until ( ComFlChan_ OpChan( ComFN ) ) neq -1;
  InsertFN( Current,ComFN,E!CmdFile );
  Do 
  BEGIN
    LogFN_ Prompt( "NAME OF LOG FILE" );
  END
  until ( LogFlChan_ GeChan( LogFN ) ) neq -1;
  InsertFN( Current,LogFN,E!LogFile );
  GetOptions;
END;


simple procedure ShowOneRec( integer array QRec );
BEGIN
integer desc,Conn,MoMult,Body,BP,BPI,ch;
  string parameters;
  if GetConn = 0 then
  BEGIN
    print( "NO CURRENT RECORD" );
    return;
  END;
  define ifprt(txt,val)= { if (val) neq 0 then (txt)&Cvs(val) else "" };
  print( "----------------------------------------------------------",
              "---------------" );
  print( crlf,"  ",Cvxstr( QRec[ E!CmdFile + F!Name ] ) );
  print( " ",LDB( PPSeq( QRec ) ) ); 
  print( " ",CvsTim( ( LDB( PPTimL( QRec ) ) lsh 18 ) DIV 1440 ) ); 
  print( " ",cvxStr( QRec[ E!Username ]), cvxStr( QRec[ E!username + 1 ] ) );
  print( " ",PrtPPN( QRec[ E!AUN ] ) );
  if ( QRec[ E!AUN ] neq QRec[ E!PPN ] )
   then print( "(", PrtPPN( QRec[ E!PPN ] ), ")" );
  print( " Run:",CvSDAT( !lh( QRec[ E!RunTime ] ) ),
          " ",CvSTim( !rh( QRec[ E!RunTime ] ) ) );

  !  print( "          Privs:",cvos( QRec[ E!Privs ] ) );
  print( Crlf&"          ",cv6Str( QRec[ E!LogFile + F!Device ] ),
              ":(",cv6Str( QRec[ E!LogFile + F!User ] ),
              cv6Str( QRec[ E!LogFile + F!User+1 ] ),")",
              cv6Str( QRec[ E!LogFile + F!Name ] ) ,
              ".",cv6Str( QRec[ E!LogFile + F!Ext ] ) );
  print( " = ",cv6Str( QRec[ E!CmdFile + F!Device ] ),
              ":(",cv6Str( QRec[ E!CmdFile + F!User ] ),
              cv6Str( QRec[ E!CmdFile + F!User+1 ] ),")",
              cv6Str( QRec[ E!CmdFile + F!Name ] ) ,
              ".",cv6Str( QRec[ E!CmdFile + F!Ext ] ) );

  if ( QRec[ E!Project ] )
   then print( " PROJ:",CvStr( QRec[ E!Project ] ),
              CvStr( QRec[ E!Project + 1 ] ),
              CvStr( QRec[ E!Project + 2 ] ) );
  if ( QRec[ E!Network ] )
   then print( " Nod-port:", cvos( QRec[ E!Network ] ) );

  if ( QRec[ E!TruLim ] or !lh(QRec[ E!Status ]) or QRec[ E!LogLim ] )
   then print( crlf );
  print( ifprt( "          TRU:",  QRec[ E!TruLim ] ) );
  print( ifprt( " Loglim:",    LDB( PPLogL( QRec ) ) ) );
  print( ifprt( " Status:",    LDB( PPStat( QRec ) ) ) ); 
  print( ifprt( " Proc:",      LDB( PPProc( QRec ) ) ) ); 
  print( ifprt( " Dep:",       LDB( PPDepL( QRec ) ) ) );

  print( crlf&"          Log:", ARLog[ LDB( PPLog( QRec ) ) ] ) ; 
  print( " Disp:",ARDspos[ LDB( PPDisp( QRec ))]); 
  if ( !rh( QRec[ E!License ] ) )
   then print( crlf&"License:",  LicPrt( !rh( QRec[ E!License ] ) ) );
  ! print( " Spool act:",ARSpl[LDB( PPSpl( QRec ) ) ]) ; 

  print( crlf&"          Mail: ", ARMail[LDB( PPMail( QRec ) ) ]);
  print( "  Mailer: ", ARMailer[LDB( PPMPrg( QRec ) ) ]); 
  print( "  Restart: ", ARRstrt[LDB( PPRestart( QRec ) ) ]); 
  print( "  Unique: ",   ARUniq[LDB( PPUniq( QRec ) ) ]); 

  Parameters_ null;
  BP_ Point( 7, Current[ E!Parameters ], -1 );
  For BPI_ 1 upto E!ParLength do 
    If ( Ch_ Ildb( BP ) )
     then Parameters_ Parameters & Ch;
  if ( length( Parameters ) ) then
    print( crlf &"Parameters: ",Parameters );

  print( crlf,"Date expression:");
  express;
  for Desc_ E!Descriptor step D!Length until ( E!Length - D!Length - 1 ) do
  BEGIN
    print( crlf,"Dat Code      =" );
    print( LDB( PMult( QRec[ Desc ] ) ) );
    print( LDB( PType( QRec[ Desc ] ) ) );
    MoMult_ LDB( PMoMult( QRec[ Desc ] ) );
    if MoMult = 0 then
      print( "00" )
    else
      if MoMult < 10 then
        print( "0",MoMult )
      else
        print( MoMult );
    Body_ LDB( PBody( QRec[ Desc ] ) );
    if body = 0 then
      print( "00" )
    else
      if Body < 10 then
        print( "0",Body )
      else
        print( Body );
    Conn_ LDB( PConn( QRec[ Desc + D!Type ] ) ); 
    Print( Conn );
    print( "  Ref Dat/Tim   =" );
    print( LDB( PDate( QRec[ Desc + D!Daytime ] ) )," " );
    print( CvSTim( LDB( PTime( QRec[ Desc + D!Daytime ] ) ) )," " );

    if Conn = ENDCon then 
      done;
  END
END;


integer procedure GetNDT( integer AfterDate );
BEGIN
  integer NDT;
  if AfterDate = 0 then
    AfterDate_ TodaysIntrnDat;
  NDT_ NexTim( Current,AfterDate );
  return( NDT );
END; ! proc GetNDT;


simple procedure GetNext;
BEGIN
  ArrClr( Current );
  if GetRec( Current[ E!Runtime ] ) then
  BEGIN
    arrblt( Confirm[ E!Runtime ], Current[ E!Runtime ], E!Length ); ! copy;
    print( "*NEXT IS CURRENT. " );
  END
  else
  BEGIN
    dpb( '777777, PPSeq( Current ) );
    if GetRec( Current[ E!Runtime ] ) then
    BEGIN
      arrblt( Confirm[ E!Runtime ], Current[ E!Runtime ], E!Length );
      print( "*NEXT IS CURRENT! " );
    END
    else
    BEGIN
      print( "*NO NEXT RECORD. " );
    END
  END;
  print( crlf );  
END;


simple procedure GetBySeqNum;
! Get a rec specified by a seq #;
BEGIN
  integer SeqNum;
  ArrClr( Current );
  Dpb( SeqNum_ IntRead( "Enter Sequence Number" ), PPSeq( Current ) );
  if GetRec( Current[ E!Runtime ] ) then
    print( "Entry with seq# ",SeqNum," is now current." )
  else
    print( "Entry with seq# ",SeqNum," is not found." );
  arrblt( Confirm[ E!Runtime ], Current[ E!Runtime ], E!Length ); ! copy;
  print( crlf );  
END;


simple procedure GetByJobName;
! Get a rec from job list;
BEGIN
  string ComFN;
  ArrClr( Current );
  dpb( '777777, PPSeq( Current ) ); ! reset ;
  ComFN_ prompt( "JOB NAME " );
  if equ( comFN,null ) then
  BEGIN
    return;
  END
  else
  BEGIN
    Current[ E!CmdFile + F!Name ]_ cvsix( ComFN[ 1 for 6 ] );
    if GetRec( Current[ E!Runtime ] ) then
      ShowOneRec( Current )
    else
      print( "JOB '", ComFN[ 1 for 6 ] ," NOT IN LIST" );
    arrblt( Confirm[ E!Runtime ], Current[ E!Runtime ], E!Length ); ! copy;
    print( crlf );  
  END
END;


simple procedure Delete;
BEGIN
  string ComFN;
  integer UN;
  UN_ Current[ E!UserName ];
  ComFN_ null;
  if UN = 0 then ! true if this proc. is being called from main prog;
  BEGIN
    dpb( '777777, PPSeq( Current ) ); ! reset ;
    Current[ E!Username ]_     calli( !xwd( -1,!GTUNM ),calli!gettab );
    Current[ E!Username + 1 ]_ calli( !xwd( -1,!GTUN1 ),calli!gettab );
    ComFN_ prompt( "JOB NAME " );
    if equ( ComFN,null ) then
      return;
    Current[ E!CmdFile + F!Name ]_ cvsix( ComFN[ 1 for 6 ] );
    if GetRec( Current[ E!Runtime ] ) then ! look for an entry with that file name;
    BEGIN
      arrblt( Confirm[ E!Runtime ], Current[ E!Runtime ], E!Length ); ! copy;
      Current[ E!RunTime ]_ 0; ! amounts to a delete;
      if ModRec( Current[ E!Runtime ], Confirm[ E!Runtime ] ) then
        print( "JOB DELETED " ) ! insert with no runTime;
      else
        print( "(1)JOB COULD NOT BE DELETED " );
      print( crlf );  
    END
    else
    BEGIN
      print( "JOB NOT IN LIST" );
    END;
    ArrClr( Current );
    print( crlf );  
  END
  else
  BEGIN
    Current[ E!RunTime ]_ 0; 		! amounts to a delete;
    if ModRec( Current[ E!Runtime ],Confirm[ E!Runtime ] ) then
      print( "JOB DELETED " ) ! insert with no runTime;
    else
      print( "(2)JOB COULD NOT BE DELETED " );
    print( crlf );  
  END
END;


simple boolean procedure SubList( integer array QRec );
BEGIN
integer i,OptNum,LineLength;
string str;
boolean FoundOne;
  FoundOne_ false;
  arrclr( WhichParams );
  LineLength_ 0;
  while true do
  BEGIN
    Str_ LopWrd( S$ListParameters );
    if equ( str,null ) then
      done;
    OptNum_ Validate( ListParams,Str,NumParams - 1 );
    if OptNum neq -1 then
      BEGIN
        FoundOne_ true;
        LineLength_ LineLength + fieldlengths[ OptNum ];
	if LineLength < 81 then
          WhichParams[ OptNum ]_ true
      END
    else
      print( " ?",Str,"? " );
     
  END;
  if NOT FoundOne then
    return( false );

  print( crlf );
  if WhichParams[ 0 ] then
    print( "  " );
  for i_ 0 upto NumParams - 2 do
  BEGIN
    if WhichParams[ i ] then
      print( ListParams[ i ]," " );
  END;
  print( crlf );
  if WhichParams[ 0 ] then
    print( "  " );
  for i_ 0 upto NumParams - 2 do
  BEGIN
    if WhichParams[ i ] then
      print( dashes[ 1 for length( ListParams[ i ] ) ] ," " );
  END;
  return( true );
END;


simple procedure LISTP( integer array QRec );
BEGIN
integer i,OptNum,LineLength;
string Str;
  print( crlf );
  LineLength_ 0;
  for i_ 0 upto NumParams - 1 do
  BEGIN
    if WhichParams[ i ] then
    BEGIN
      LineLength_ LineLength + fieldlengths[ i ];
      if LineLength > 80 then
        return;
      case i of
      BEGIN
        [ 0 ] BEGIN
		 Str_ cv6Str( QRec[ E!CmdFile + F!Name ] );
		 print( "  ",Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [  1 ] BEGIN
		 Str_ cvs( LDB(  PPSeq( QRec ) ) );
		 print( spaces[1 to fieldlengths[i] - length( Str )],Str," " );
               END;
        [ 2 ] BEGIN
		 Str_ CvsTim((LDB(PPTimL(QRec)) lsh 18) DIV 1440);
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [  3 ] BEGIN
		 Str_ cvxStr( QRec[ E!UserName ] ) & 
		      cvxStr( QRec[ E!UserName + 1 ] );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [  4 ] BEGIN
		 Str_ PrtPPN( QRec[ E!PPN ] );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [  5 ] BEGIN
		 Str_ PrtPPN( QRec[ E!AUN ] );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [  6 ] BEGIN
		 Str_ "*";
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [  7 ] BEGIN
		 Str_  ( CvSDAT( !lh( QRec[ E!RunTime ] ) ) ) & " " &
                       ( CvSTim( !rh( QRec[ E!RunTime ] ) ) ) ;
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [  8 ] BEGIN
		 Str_ cvs( LicPrt( !rh( Qrec[ E!License ] ) ) );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [  9 ] BEGIN
		 Str_ cv6Str( QRec[ E!LogFile + F!Device ] ) & 
                      ":(" & cv6Str( QRec[ E!LogFile + F!User ] ) & 
	              cv6Str( QRec[ E!LogFile + F!User+1 ] ) & ")" & 
	              cv6Str( QRec[ E!LogFile + F!Name ] )  & 
	              "." & cv6Str( QRec[ E!LogFile + F!Ext ] ) ;
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [  10 ] BEGIN
		 Str_ cv6Str( QRec[ E!CmdFile + F!Device ] ) & 
	              ":(" & cv6Str( QRec[ E!CmdFile + F!User ] ) & 
	              cv6Str( QRec[ E!CmdFile + F!User+1 ] ) & ")" & 
	              cv6Str( QRec[ E!CmdFile + F!Name ] )  & 
	              "." & cv6Str( QRec[ E!CmdFile + F!Ext ] ) ;

		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [  11 ] BEGIN
		 Str_ "*";
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 12 ] BEGIN
		 Str_ cvs( QRec[ E!TruLim ] ) ;
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 13 ] BEGIN
		 Str_ cvs( LDB(  PPLogL( QRec ) ) );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 14 ] BEGIN
		 Str_ cvs( LDB(  PPDepL( QRec ) ) );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 15 ] BEGIN
		 Str_ ( ARLog[ LDB(  PPLog( QRec ) ) ] );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 16 ] BEGIN
		 Str_ ( ARDspos[ LDB(  PPDisp( QRec ) ) ] );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 17 ] BEGIN
		 Str_ ( ARMailer[ LDB(  PPMPrg( QRec ) ) ] );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 18 ] BEGIN
		 Str_ "*";
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 19 ] BEGIN
		 Str_ ( ARMail[ LDB( PPMail( QRec ) ) ] );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 20 ] BEGIN
		 Str_ ( ARRstrt[ LDB( PPRestart( QRec ) ) ] );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 21 ] BEGIN
		 Str_ ( ARuniq[ LDB( PPUniq( QRec ) ) ] );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 22 ] BEGIN
		 Str_ "*";
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 23 ] BEGIN
		 Str_ "*";
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 24 ] BEGIN
		 Str_ "*";
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 25 ] BEGIN
		 Str_ "*";
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 26 ] BEGIN
		 print( crlf );
		 ShowOneRec( Qrec );
               END
      END;
    END;
  END;
END;


simple procedure list;
BEGIN
integer Count;
boolean found,ListParams;

  simple string procedure GetUserName;
  ! returns logged in user name. ;
  Return( cv6str(calli(-'22,'41)) & cv6str(calli(-'21,'41)) );

  Count_ 0;
  found_ ListParams_ false;
  ArrClr( SavEntr );
  ! prepare an array with only the username set;
  SavEntr[ E!Username ]_     calli( !xwd( -1,!GTUNM ),calli!gettab );
  SavEntr[ E!Username + 1 ]_ calli( !xwd( -1,!GTUN1 ),calli!gettab );
  
  arrblt( Current[ E!Runtime ],SavEntr[ E!Runtime ],E!Length ); ! move to Current;
  dpb( '777777, PPSeq( Current ) );
  while GetRec( Current[ E!Runtime ] ) do !  rest of recs with this username;
  BEGIN
    Count_ Count + 1;
    if equ( S$ListParameters,null ) then
      S$ListParameters_ DefaultParam;
    if equ( S$ListParameters,null ) and not ListParams then
    BEGIN
      ShowOneRec( Current ) ! GetRec returns found rec in Current;
    END
    else
    BEGIN
      if NOT ListParams then
      BEGIN
        if NOT SubList( Current ) then
	BEGIN
	  print( "NO LISTABLE PARAMETERS PROVIDED" );
	  return;
	END;
        ListParams_ true;
        ListP( Current );
      END
      else
      BEGIN
        ListP( Current );
      END;
    END;
    found_ true;
    if inchrs neq -1 then  ! stop if a keyboard char has been typed;
      done;
    arrblt( Current[ 0 ],SavEntr[ 0 ],E!Length ); ! move to Current;
  END;
  if ListParams then
    print( crlf,#lf,Count," ITEMS LISTED.",crlf );
  if not found then
    print( crlf,"NO JOBS FOR " ,GetUserName,".",crlf );
END;


simple procedure Insert;
! record inserted into queue, being assigned a seq# by ModRec;
BEGIN
  integer NextD,tod,SN;
  SN_ Ldb( PPSeq( Current ) );		! get sequence number ;
  I$Position_ E!Descriptor;
  if SN = 0 then 			! can only be a new entry;
  BEGIN 	! so there should be a new date code for a new q entry;
    if GetConn = 0 then
    BEGIN				! trouble;
      print( "MUST USE DATE COMMAND FIRST",crlf );
    END
    else
    BEGIN 				! new job needs to be inserted;
      tod_ TodaysIntrnDat;
      NextD_ NexTim( Current,tod );
      MakeHeader( !lh( NextD ),!rh( NextD ) );
      if ModRec( Current[ E!Runtime ], Confirm[ E!Runtime ] ) then
      BEGIN				! insert the new entry;
        print( "Record inserted. " );
        ArrClr( Current );
      END
      else
        print( "*new rec could not be inserted" );
    END
  END
  else 		! must have been a Current entry exists so re-insert;
  BEGIN
    if ModRec( Current[ E!Runtime ], Confirm[ E!Runtime ] ) then
    BEGIN
      print( "Record inserted. " );
      ArrClr( Current );
    END
    else
    BEGIN
      print( "*Record could not be inserted. " );
    END
  END;
  print( crlf );  
END;


simple procedure Modif;
BEGIN
  integer SN;
  SN_ Ldb( PPSeq( Current ) );		! get sequence number ;
  if SN = 0 then 			! no current rec;
  BEGIN
    print( "no current record" );
  END
  else
  BEGIN 				! modify current record;
    print( "MODIFY:" ); 
    GetOptions;
    if ModRec( Current[ E!Runtime ], Confirm[ E!Runtime ] ) then
      print( "Modified record inserted. " )
    else
      print( "Modified record could not be inserted. " );
  END;
  print( crlf );  
END;


simple procedure ShowAll;
BEGIN
  arrclr( Current ); ! clear so first rec will be returned in reset;
  dpb( '777777, PPSeq( Current ) ); ! reset ;
  if GetRec( Current[ E!Runtime ] ) then 
    ShowOneRec( Current )  
  else
    print( "QUEUE SEEMS TO BE EMPTY" );
  arrclr( Current ); ! clear so next rec will be returned;
  while GetRec( Current[ E!Runtime ] ) do ! loop in the rest of recs;
  BEGIN
    ShowOneRec( Current ); ! GetRec returns found rec in Current;
    arrclr( Current ); ! must clear each time so all recs will come;
    ! otherwise GetRec will be searching for;
    ! the previously returned rec, which will;
    ! never be found;
  END
END;


simple procedure specials;
BEGIN
  string ch,TstCod;
  integer Next,Bas,UN;

simple procedure menu;
BEGIN
  print( crlf,"          - SPECIALS MENU -" );
  print( crlf,"" );
  print( crlf,"N - Get Next Rec from queue" );
  print( crlf,"S - Get Rec by sequence  #" );
  print( crlf,"A - Get Rec by command file name" );
  print( crlf,"W - Print Whole Queue from BEGINing" );
  print( crlf,"T - Show current rec" );
  print( crlf,"X - express date expression from current rec" );
  print( crlf,"F - figure next run D-T from current rec",crlf );
  print( crlf,"I - Insert current rec" );
  print( crlf,"M - Modify current rec" );
  print( crlf,"D - Delete current rec" );
  print( crlf,"R - Reset" );
  print( crlf,"H - Menu" );
  print( crlf,"Q - Quit specials" );
  print( crlf,"E - Exit submit" );
  print( crlf,"" );
END;

  while true do
  BEGIN
    ch_ prompt( SpecialsPrompt );
    case ch of 
    BEGIN
      [ "n" ]  GetNext;
      [ "s" ]  GetBySeqNum;
      [ "a" ]  GetByJobName;
      [ "i" ]  Insert;
      [ "m" ]  Modif;
      [ "t" ]  BEGIN
                 ShowOneRec( Current );
               END;
      [ "f" ]  BEGIN
                 bas_ IntRead( "enter a date as 00000 " );
                 Next_ GetNDT( bas );
                 print( crlf,cvsdat( !lh( Next ) )," ",!rh( next ) );
              END;
      [ "w" ]  ShowAll;
      [ "x" ]  express;
      [ "d" ]  BEGIN
		 UN_ Current[ E!UserName ];
		 if UN = 0 then
		   print( crlf,"NO CURRENT JOB TO DELETE",crlf )
		 else
		   Delete;
	       END;
      [ "h" ]  menu;
      [ "r" ]  dpb( '777777, PPSeq( Current ) );
      [ "q" ]  done;
      [ "e" ]  BEGIN !  $$$ ;
                 ClsQue;
                 call( 0,"EXIT" );
               END;
        else print( crlf,"(",ch,") not implemented." )
    END
  END
END;


! main;

  print( "***   WELCOME TO TYMCOM-X   S U B M I T   ***" );
  print( crlf );
  print( "***   ",TheTime," version ", VERSION!STRING,"  ",
        CvSDat( TodaysIntrnDat ),"     ***" );
  ! WkDay[(TodaysIntrnDat + 4) mod 7][ 1 for 3 ],"  ***" );

  while true do
  BEGIN
    I$CmmdNum_ getCommand( SubmitPrompt );
    I$Position_ E!Descriptor;
    clrbuf;
    case I$CmmdNum of 
    BEGIN
      [ 0 ] BEGIN
              arrclr( ModCheck,false ); 
              arrclr( Current ); 
              S$UsrsExp_ null;
              B$Coded_ false;
              GetDateSpec;
              if length( S$UsrsExp ) < 3 then
              BEGIN
	        print( crlf, FragmentComplaint );
		continue;
	      END;
              S$Scanned_ ScanStr( S$UsrsExp )[ 1 to inf -1 ];
              if EQU( S$ErrMSG,null ) then
              BEGIN
	        if NOT ParsedOK( S$Scanned,S$ErrMSG ) then
	        BEGIN
	          print( S$ErrMSG,crlf );
	          if length( S$ThrownOut ) > 3 then
	            print( crlf,"UNIMPLEMENTED TERMS: " , S$ThrownOut , crlf );
	        END
	      END
              else 			! error detected during ScanStr;
	      BEGIN
                print( S$ErrMSG,crlf );
	      END;
!              if NOT EQU( S$ErrMSG,null ) then
                continue; ! error detected during Parse so re-prompt;
            END;
      [ 1 ] Insert;
      [ 2 ] Display;
      [ 3 ] Express;
      [ 4 ] Test;
      [ 5 ] BEGIN
              arrclr( Current ); 
              delete;
            END;
      [ 6 ] print( "status not implemented",crlf );
      [ 7 ] list;
      [ 8 ] GetByJobName;
      [ 9 ] print( "version not implemented",crlf );
      [ 10 ] BEGIN
               ClsQue;
               call( 0,"EXIT" );
             END;
      [ 11 ] print( HlpMsg );
      [ 12 ] print( HlpMsg );
      [ 13 ] TrialCode;
      [ 14 ] Look;
      [ 15 ] specials;
      [ 16 ] print( CvSDat( TodaysIntrnDat ),
                    " (",WkDay[(TodaysIntrnDat + 4) mod 7][ 1 for 3 ],") ",
                    TheTime );
      else print( "!UNIDENTIFIED COMMAND: #",I$CmmdNum,".",crlf )
    END ! case;
  END ! while;
END "SUBMIT";

  }@WE