begin "SUBMIT"

require "SUBMIT.INF"         source!file;

define  SUBMIT!VERSION = (SUBMIT!MAJOR lsh 24) lor SUBMIT!EDIT;
require SUBMIT!VERSION version;

require "(SAILIB)SAIL.DEF"   source!file;
require "(SAILIB)UUOSYM.DEF" source!file;
require "(CARL)JQUEUE.DEF"   source!file;
require "SUBMIT.DEF"         source!file;
require "SUBMSC.REQ"         source!file;
require "NEXTIM.REQ"         source!file;
require "(CARL)JQUE.REQ"     source!file;
require "(CARL)VMFILE.REQ"   source!file;
require "(CARL)DAYTIM.REQ"   source!file;
require "(CARL)ESCTRP.REQ"   source!file;
require "(CARL)XEXLIC.REQ"   source!file;
require "(CARL)LICSUB.REQ"   source!file;

define VERSION!STRING = { "%"&cvos(SUBMIT!MAJOR)&"("&cvos(SUBMIT!EDIT)&")" };


!	Various definitions
;

define Gettab(x,y)  = { calli( !xwd( (x), (y) ), calli!GETTAB ) };
define Device       = { "DSK" };
define SubmitPrompt = { "SUBMIT> " };
define spaces       = { "                              " } ;
define dashes       = { "--------------------" } ;
define DefaultParam = { "Jobname requ timel usern next" };
define PrtPpn(P)    = { (spaces[1 for 6]&cvos(!lh(P)))[inf-5 to inf]&","
			&(cvos(!rh(P))&spaces)[1 for 6] };

define !CAN         = { " X" };
define !PRO         = { " !" };
define !SCH         = { " +" };
define !HOL         = { " H" };
define !ABO         = { " *" };
define !Late        = { " <" };



string array OneDesc[ 1:31 ];

preset!with JL$$Str;	safe string array ARLog [ 0:JS$-1 ];
preset!with JD$$Str;	safe string array ARDisp[ 0:JD$-1 ];
preset!with JM$$Str;	safe string array ARMail[ 0:JM$-1 ];
preset!with JP$$Str;    safe string array ARMailer[ 0:JP$-1 ];
! preset!with JS$$Str; ! safe string array ARSpl[ 0:JS$-1 ];
preset!with JR$$Str;	safe string array ARRestart[ 0:JR$-1 ];
preset!with JU$$Str;	safe string array ARUniq[ 0:JU$-1 ];

preset!with "NO","YES"; safe string array NoYes[ 0:1 ];
preset!with "YES","NO"; safe string array YesNo[ 0:1 ];

preset!with ST$$Off;	safe integer array Stat  [ 0:ST$-1 ];
preset!with ST$$Str;	safe string  array SStat [ 0:ST$-1 ];
preset!with ST$$All;	safe string  array SSStat[ 0:ST$$Knt-1 ];


define NumParams  = 30 ;

! The following are column headings displayed with the LIST command. ;
preset!with 
	     "JobName   "          , "Request"            , "TimeLimit"
,	     "UserName    "        , "PPN          "       , "AUN          "
,	     "Privilege"           , "Next Run       "     , "License"
,	     "LogFile              ", "CommandFile          ", "Label"
,	     "TruLimit"            , "LogLimit"            , "Log       "
,	     "Dispose "            , "Mailer"              , "Spool     "
,	     "Mail"                , "Restart   "          , "Unique"
,	     "CtyLog"              , "Run "                , "Detachn"
,	     "CCL"		   , "Priority"		   , "Halt"
,	     "TmpName"		   ,"Abort"		   , "All";
string array LiPs[ 0:NumParams - 1   ];

! The following declarations are necessary for the LIST command;
define $NEX =  7;		! NEXT RUN;
define $ALL =  NumParams-1;	! ALL;
define $ABO =  NumParams-2;	! ABORT;

! Keep track of which parameters were requested with LIST;
boolean array ListRequests[ 0:NumParams - 1   ];



define NumOptns   = 29 ;
preset!with 	"LABEL",      "TIMELIMIT", "TRULIMIT",  "",        "LOG",
		"LOGLIMIT",   "DISPOSE",   "MAILER",    "SPOOL",   "MAIL",
		"RESTART",    "UNIQUE",    "PARAMETERS","HELP",    "?",
		"ABORT",      "RUN",       "DETACH",    "HALT",    "CTYLOG",
		"PRIORITY",   "CCL",	   "TMPNAME",	"LOGFILE", "LICENSE",
		"DATES",      "EXPRESS",    "DISPLAY",   "TEST";
string array Options[ 0:NumOptns - 1   ];

define NumExts = 5;	! Cmd file extensions indicating possible RUN YES. ;

preset!with "SAV","SHR","HGH","SWR","EXE";
string array RunExts[ 0:NumExts-1 ];


require " SUBMIT  help messages" message;

define HlpMsg = { 
"
Commands:
  Dates      Takes a date expression
  Insert     Insert job into the job queue
  Display    Displays all dates associated with date expressions
  Express    Rephrases the date expression
  Test       Executes both express and display commands

  Status     Types status of jobs belonging to user
  List       Lists all jobs for this user
  Modify     Modify an existing queue entry
  Delete     Deletes an existing job entry
  Rerun      Reenter an aborted job (possibly run it immediately)
  Requeue    Requeue an aborted job for the next scheduled time
  Version    Type version number
  Quit       Returns to exec
  Help       Types this message 

  Continue   Restart a paused or stopped job
  Pause      Cause a running job to pause
  Stop       Cause a job which is running or paused to stop
  Kill       Kill a running, paused, or stopped job
" };

define LABELHelp = {
"
Label     Name of label in command file from which to restart.  
	  Maximum length is 6 characters.
" };

define TIMELIMITHelp = {
"
Timelimit Maximum elapsed time for one run.
" };

define TRULIMITHelp = {
"
TRULimit  Maximum TRU's allowed for one run.
" };

define LOGLIMITHelp = {
"
LogLimit  Maximum logfile size in pages.
" };

define LOGHelp = {
"
Log       Specify the logging action to be performed.
          Values:
            NONE       No log file.
            APPEND     If a log file exists, then append new text to it.
            SUPERSEDE  Always create a new log file.
" };

define DISPOSEHelp = {
"
Dispose   Specify what to do with the log file after each run.
          Values:
            KEEP       Always KEEP the log file.
            DELETE     Always DELETE upon normal completion.
            NOERROR    Delete upon successful completion.
                       SAVE if job was aborted.
" };

define MAILERHelp = {
"
Mailer    Specify which mailer program to use.
          Values:
            TUMS       Tymnet Universal Mail System.
            RPG        Old mail system.
" };

define SPOOLHelp = {
"
Spool     Not implemented.
" };

define MAILHelp = {
"
Mail      When to send mail to the user who submitted this job.
          Values:
            NONE       Never send mail.
            ERROR      Send mail on error.
            SUCCESS    Send mail on success.
            ALWAYS     Send mail always.  (Default)
" };

define RESTARTHelp = {
"
Restart   Specify restart conditions.
          Values:
            NONE       Never restart.  (Default)
            CHECKPOINT Continue at label specified in command file.
            LABEL      Start at specified label.
            CONTINUE   Pick up from next line in command file.
            REPEAT     Pick up from current line in command file.
" };

define UNIQUEHelp = {
"
Unique    Specify unique conditions for job.
          Values:
            NONE       Job may be run at any time.
            USER       Job must be the only job for this user.
            DIR        Job must be the only job in this directory.
            PATH       Job must be the only job for this user in
                       this directory.
            JOB        Job must be the only job for this user in
                       this directory with this command file name.
" };

define PARAMETERSHelp = {
"
Parameter Specify job parameters.
          These are optional programmable parameters to be passed to
          the job.  Refer to the reference manual for more details.
" };

define HELPHelp = {
"
Help      Type  HELP  or  ?  for a list of valid options.
          Type  HELP option-name  for additional help.
" };

define ABORTHelp = {
"
Abort     Aborts the INSERT or MODIFY command.
" };

define RUNHelp = {
"
Run       Specify whether the job is a command file or a program.
          Vaules:
            NO         If specified file is a program to run. (Default)
            YES        If specified file is a command file.
" };

define DETACHHelp = {
"
Detach    Specify whether the job will have a port for logging output.
          Values:
            NO         Job will have a port connected to it.  (Default)
            YES        Job will run detached (no port).
" };

define HaltHelp = {
"
Halt      Specify whether the job is allowed to halt.
          Special license is required to use this option.
          Values:
            NO         Job will not restart if it halts.  (Default)
            YES        Job will restart if it halts.
                       (The restart option must be specified).
" };

define CTYLOGHelp = {
"
CTYLog    Specify whether job events will be logged to the system CTY.
          Special license is required to use this option.
          Values:
            NO         Job info will not be logged to CTY.  (Default)
            YES        Job info will be logged to CTY.
" };

define PRIORITYHelp = {
"
Priority  Set scheduling priority (1-9).  Default is 0.
          System privileged users may set priority 1-15.
          The default value 0 actually runs at priority 5.
" };

define CCLHelp = {
"
CCL       Specify CCL start address for a program to RUN.
          Values:
            NO         Run job at normal start address.
            YES        Run job at CCL address.
" };

define TMPNAMEHelp = {
"
TmpName   TMPCOR file name for programs which are run at CCL address.
          Setting a temp file name will use the CCL start address.
" };

define LOGFILEHelp = {
"
LogFile   Change the log file name.
" };

define LICENSEHelp = {
"
License   Set license on the job.
          Prompts for opername and password to validate license.
" };

define DatHelp = {
"
Examples of date expressions.
  EVERY DAY.
  EVERY DAY AT 12:25.
  EVERY OTHER DAY.
  EVERY 3RD DAY AT 19:30.
  EVERY FRIDAY.
  EVERY WEEKDAY AT 8.
  EVERY OTHER FRIDAY.
  THE 23RD DAY OF EVERY MONTH.
  THE 2ND WEDNESDAY OF EVERY MONTH AT 13:45.

NOTE:
  Date expressions are terminated with a <cr>.
  The default run-time is 00:00 (midnight).
  All times are in 24 hour time (3:00 PM = 15:00).
" };

define DeleteHelp = {
"
Delete    Delete a job from the queue.  The job may be specified by
          name or by request or by both name and request.
" };

define ComFilHelp = {
"
Enter the name of the command file to use.
" };



preset!with
"
Dates
  Use the command DATES to enter your date expression.  After you type the
  DATES command, SUBMIT will prompt you for the date expression.  The date
  expression is ended when you type a <cr>.  SUBMIT will then examine your
  date expression for correctness and will complain if it finds an error,
  at which point you may try again be re-typing DATES.  If your date
  expression was valid, SUBMIT will return to the SUBMIT prompt, ready for
  another command.  At this point you may want to use the EXPRESS command
  to confirm your date expression, and the DISPLAY command to see if your
  date expression will generate the run dates which you require.

Examples of date expressions.
  EVERY DAY.
  EVERY DAY AT 12:25.
  EVERY OTHER DAY.
  EVERY 3RD DAY AT 19:30.
  EVERY FRIDAY.
  EVERY WEEKDAY AT 8.
  EVERY OTHER FRIDAY.
  THE 23RD DAY OF EVERY MONTH.
  THE 2ND WEDNESDAY OF EVERY MONTH AT 13:45.

NOTE:
  Date expressions are terminated with a <cr>.
  The default run-time is 00:00 (midnight).
  All times are in 24 hour time (3:00 PM = 15:00).
",
"
Insert
  After SUBMIT has accepted your date expression, use the command INSERT
  to insert your job into the job queue.  You may include your command
  file name and your log file name on the command line.

Examples:
  INSERT CmdFil.Ext LogFile.Ext
  INSERT (UserName)CmdFil.Ext (UserName)LogFil.Ext
  INSERT (UserName)LogFil.Ext=(UserName)CmdFil.Ext

If you do not furnish file names then the system will prompt for the name of 
your command file, which must currently exist, and the name for your log file.

If you type a carriage-return (only) at the command-file prompt, then the
insert will be aborted.

NOTE:
  The default command file extension is '.CTL'.
",
"
Display
  After SUBMIT has accepted your date expression, use the command DISPLAY to
  confirm that SUBMIT will generate the run-dates which you require.  Upon
  entering DISPLAY, Submit will display the dates and times of future runs of
  your job as if the job were in the queue at this instant.
",
"
Express
  After SUBMIT has accepted your date expression, use the command EXPRESS
  to get SUBMIT to produce an English sentence to describe what it thinks
  you wanted when you typed your date expression.
",
"
Test
  After SUBMIT has accepted your date expression, use the command TEST to
  check it.  TEST merely executed EXPRESS and DISPLAY.
",
"
Delete
  Use the command DELETE to remove one of your job from the job queue.
  You will have to furnish the job-name (command-file name) and the
  request number so you may want to issue the command LIST to get these
  parameters.

Example:
  DELETE job-name request-number

If you do not furnish job-name and request-number along with the DELETE 
command then the system will prompt for them.  

If you respond with <cr> (only) at the Job-Name prompt You can still DELETE
the job by entering the request number at the request-number prompt.

If you give a valid job name at the Job-Name prompt but give no request
number at its prompt then every job with that job name wil be deleted.
",
"
Status
  Use the command STATUS to determine the current status of one of your 
  previously inserted jobs.
",
"
List
  Use the command LIST to display information on your jobs which are
  currently in the queue.  A list of parameters which may be supplied
  currently with LIST can be obtained by typing  HELP LIST.

Examples:
  LIST
  LIST ALL
  LIST USERNAME JOBNAME COMMANDFILE
  LIST USERNAME REQUEST NEXT TIMELIMIT
  LIST JOBNAME NEXT PRIORITY LOG

Jobs info is listed in columnar form.  Don't try to list more parameters
than your screen has room for.
",
"
Modify
  Use the command MODIFY to change the characteristics of your job.  You
  will have to furnish the job-name (command-file name) and the request
  number so you may want to issue the command LIST to get these parameters.
  You will then will get the options prompt at which you may change any
  parameters which you could normally set during an INSERT.

Example:
  MODIFY job-name request-number

If you do not furnish job-name and request-number then the system will
prompt for them.

If you respond with <cr> (only) at the Job-Name prompt You can still
MODIFY the job by entering the request number at the request-number
prompt.

If you give a valid job name at the Job-Name prompt but give no request
number at its prompt then every job with that job name wil be fetched
for modification.

",
"
Version
  Displays the current program version.
",
"
Quit
  The command QUIT terminates the current session immediately.
",
"
Exit
  The command EXIT terminates the current session immediately.
",
"
Bye
  The command EXIT terminates the current session immediately.
",
"
Help  (or ?)
  Help can be obtained by typing  ? or HELP at any prompt for general
  information.  Specific information can usually be obtained by typing
  HELP command-name   or  HELP option-name.
",
"
Help  (or ?)
  Help can be obtained by typing  ? or HELP at any prompt for general
  information.  Specific information can usually be obtained by typing
  HELP command-name   or  HELP option-name.
",
"
Code
  CODE is no longer available.
",
"
Look
  LOOK will display the date code for the last date expression.
", 
"
Undelete
  Use UNDELETE to un-cancel a cancelled job.

Example:
  UNDELETE job-name request-number
",
"
Show
  Show will retrieve a job from the queue and display information on that
  job.  You will have to furnish the job-name (command-file name) and the
  request number so you may want to issue the command LIST to get these
  parameters.

Example:
  SHOW job-name request-number

If you do not furnish job-name and request-number then the system will prompt
for them.

If you respond with <cr> (only) at the job-name prompt You can still SHOW
the job by entering the request number at the request-number prompt.

If you give a valid job name at the job-name prompt but give no request
number at its prompt then every job with that job name wil be displayed.

",
"
Cancel
  Use the command CANCEL to remove one of your job from the job queue.
  You will have to furnish the job-name (command-file name) and the
  request number so you may want to issue the command LIST to get these
  parameters.

Example:
  CANCEL job-name request-number

If you do not furnish job-name and request-number along with the CANCEL 
command then the system will prompt for them.  

If you respond with <cr> (only) at the job-name prompt You can still CANCEL
the job by entering the request number at the request-number prompt.

If you give a valid job name at the job-name prompt but give no request
number at its prompt then every job with that job name will be canceled.
",
"
Continue
  CONTINUE will re-start a job whose process state is either STOP or PAUSE.
",
"
Pause
  PAUSE will cause a job whose process state is RUN to finish the current
  line and then wait until a STOP, KILL, or CONTINUE command is issued.
",
"
Stop
  STOP will cause a job whose process state is RUN to stop immediately and
  wait until a KILL, or CONTINUE command is issued.
",
"
Kill
  KILL will terminate any running job without removing the job entry from
  the queue.
",
"
Rerun
  RERUN will reset the status of a job that has aborted or otherwise had
  an error that caused the job to abort during execution.  This command
  will simply re-enter the job in the queue.  If the nextrun date is in
  the past the job may be scheduled to run immediately.
",
"
Requeue
  REQUEUE will reset the status of a job that has aborted or otherwise
  had an error that caused the job to abort during execution.  This
  command will re-enter the job in the queue for the next scheduled run
  date in the future.
";
string arrayandsHelp[ 0:NumCmds - 1 ];


internal integer
	JobLic		! Status License enabled for this job ;
;

integer
	GI!DayCyc	! Number of days in a day cycle. ;
,	GI!CmdNum	! Set in getCommand depending on user's command. ;
,	GI!Pos		! Position in the descriptor. ;
,	JobAUN		! AUN (Accounting user number) logged-in directory ;
,	JobPPN		! PPN [GAN,UUN] connected directory ;
,	JobPrv		! Privileges enabled for this job ;
;

internal string
	default,
	GS!Params,  	  ! Gets stuff from command line after the command. ;
	GS!UsrsExp, 	  ! date expression attempted by user;
	GS!Undef, 	  ! depository for bad terms thrown out during ScanStr;
	GS!Scanned, 	  ! date expression after scanning;
	GS!OneUnit, 	  ! 12 char code string for one unit date exp;
	GS!DatCod, 	  ! One or more GS!OneUnits;
	GS!ERR; 	  ! explanation for problem encountered during parse;

boolean
	GB!MonUnit	! set true when a valid month-unit is parsed;
,	GB!SpecDat	! set true when a valid unit such as 9/9/85 or;
			! jan 3, 1986 is parsed;
,	GB!Coded	! true when date code for a given unit has been started;
,	GB!Change	! true if a queue rec was modified, else no need to re-insert;
,	GB!DayCyc
,	DeBug
,	Super
,	GB!Week;	! True is "WEEKDAYS" was found in date expression;


integer array Current[ 0:E!Length - 1 ]; 	! latest queue entry fetched;
integer array Template[ 0:E!Length - 1 ];        ! save a copy where needed;
integer array CopyForModRec[ 0:E!Length - 1 ];  	! when an entry is fetched, a;
     ! copy is made immediately so that when a modified version is sent;
     ! back to the queue to overwrite original version, the original version;
     ! can be checked against the CopyForModRec to ensure that the queue entry;
     ! has not been changed by another user in the meantime;
internal string array ModCheck[ 0:NumMods - 1   ];

preset!with "JANUARY","FEBRUARY","MARCH","APRIL","MAY","JUNE",
	    "JULY","AUGUST","SEPTEMBER","OCTOBER","NOVEMBER","DECEMBER";
internal string array Mos[ 0:NumMnths - 1 ];

preset!with "SATURDAY","SUNDAY","MONDAY",
	    "TUESDAY","WEDNESDAY","THURSDAY","FRIDAY";
internal string array WkDay[ 0:NumWkDay - 1 ];


! These are for the case statement in the driver;

define C!DATES    = { [0] };
define C!INSERT   = { [1] };
define C!DISPLAY  = { [2] };
define C!EXPRESS  = { [3] };
define C!TEST     = { [4] };
define C!DELETE   = { [5] [19]};
define C!STATUS   = { [6] };
define C!LIST     = { [7] };
define C!MODIFY   = { [8] };
define C!VERSION  = { [9] };
define C!QUIT     = { [10] [11] [12] };
define C!HELP     = { [13] [14] };
define C!CODE     = { [15] };
define C!LOOK     = { [16] };
define C!UNDELETE = { [17] };
define C!SHOW     = { [18] };
define C!MODACT   = { [20] [21] [22] [23] };
define C!RERUN    = { [24] };
define C!REQUEUE  = { [25] };

preset!with "DATES","INSERT","DISPLAY","EXPRESS","TEST","DELETE","STATUS",
	    "LIST","MODIFY","VERSION","QUIT","EXIT","BYE","HELP","?",
	    "CODE","LOOK","UNDELETE","SHOW","CANCEL","CONTINUE","PAUSE",
	    "STOP","KILL","RERUN","REQUEUE" ;
internal string array Commands[ 0:NumCmds - 1 ];

define $CON = { [20] };
define $PAU = { [21] };
define $STO = { [22] };
define $KIL = { [23] };


preset!with "EVERY","TODAY","TOMORROW","DAYS","MONTH","2",
	    "SUNDAY","SUNDAY","AND","EVERY DAY","31 DAY","31",
	    "EVERY SUNDAY","1 DAY EVERY MONTH",
	    "MONTH","WEEKDAYS",
	    "HOURS","MINUTES",
	    "STARTUP";
internal string array GoodKey[ 0:NumKeys - 1 ];

preset!with "EVERY","TODAY","TOMORROW","DAYS","MONTHS","OTHER",
	    "WEEK","WEEKS","AND","DAILY","END","LAST","WEEKLY","MONTHLY",
	    "MONTH","WEEKDAYS",
	    "HOURS","MINUTES",
	    "STARTUP";
internal string array Keys[ 0:NumKeys - 1 ];

preset!with "AFTER","BEFORE",
	    "AFTER","BEFORE",
	    "EXCEPT","EXCEPT","AND";
string array GoodMods[ 0:NumMods - 1   ];

preset!with "AFTER","BEFORE",
	    "STARTING","UNTIL",
	    "EXCEPT","NOT","AND";
internal string array Modifiers[ 0:NumMods - 1   ];



simple procedure IncLicense;		! put process license back ;
calli( JobLic, calli!SETLIC );



simple procedure DecLicense;		! take process license away ;
begin
    calli( !rh( JobLic ), calli!SETLIC );
end;


simple string procedure ScanStr( string EnglishStr );
! ----------------------------------------------------------------------;
!									;
! 		Deletes un-identifyable words and redundant spaces	;
!		from the date expression typed by the user.		;
!									;
! ----------------------------------------------------------------------;
BEGIN "scan string"
  string Target,GoodStr;

  GoodStr_ GS!Undef_ null;
  do
    BEGIN "each word"
    scan( EnglishStr,SkJunk,BrkChr ); 	! Discard preceeding junk. ;
    Target_ scan( EnglishStr,NxtWrd,BrkChr ); ! get next word;

    ! Now check the arrays to see if words are valid;
    ! Good words are assembled in GoodStr;
    if Vail( Modifiers,Target ) then
      GoodStr_ GoodStr & GoodMods[ Vik( Modifiers, Target ) ] & " "
    else
    if Vail( Keys, Target ) then
      GoodStr_ GoodStr & GoodKey[ Vik( Keys, Target ) ] & " "
    else
    if ValNum( Target ) then
      GoodStr_ GoodStr & Target & " "
    else
    if Vail( WkDay,Target ) then
      GoodStr_ GoodStr & Target & " "
    else
    if ValidTimeStr( Target ) then
      GoodStr_ GoodStr & Target & " "
    else
    if ValDateStr( Target ) then
      GoodStr_ GoodStr & Target & " "
    else
    if ValOrd( Target ) then
      GoodStr_ GoodStr & Target & " "
    else
    if Vail( Mos,Target ) then
      GoodStr_ GoodStr & Target & " "
    else
    if ValNmOrd( Target ) then
      GoodStr_ GoodStr & Target & " "
    else
    if not kequ( Target,"THE" ) and 	! Save all bad words except these 3;
       not kequ( Target,"OF" ) and	! They will be printed later if;
       not kequ( Target,"AT" ) then	!   GoodStr proves to be invalid;
      GS!Undef_ GS!Undef & '42 & Target & '42 & " "; 
    END "each word"
  until length( EnglishStr ) = 0;

  return( GoodStr[ 1 to inf-1 ] );


END "scan string";


simple procedure GetDateSpec;
! ----------------------------------------------------------------------;
!									;
! 		Prompt user for his date expression. 			;
! 		Returns what user types until <cr>.			;
!									;
! ----------------------------------------------------------------------;
BEGIN "Get date expression"
	string word;

  while true do
    BEGIN "keep trying"

    if length( GS!Params ) then			! Something after "DATES"? ;
      BEGIN "command string"			! Yes ;
      GS!UsrsExp_ GS!Params & " ";		!   Assume its a date exp. ;
      return;
      END "command string"
    else					! No, so prompt for it. ;
      BEGIN "ask for date expression"
      GS!UsrsExp_ prompt( "Enter your date-time expression:"& crlf );
      word_ LopWrd( GS!UsrsExp );		! grab first word. ;

      if CryForHelp( word ) then 		! "?" or "HELP" ? ;
        BEGIN "help then reprompt"		! HELP requested at DATES;
        print( DatHelp );			!  so provide then;
        continue "keep trying";			!  ask again. ;
        END "help then reprompt"
      else
        BEGIN "OK to return"
        GS!UsrsExp_ word & " " & GS!UsrsExp; 	! else put it back. ;
        return;					! return for parser. ;
	END "OK to return";
      END "ask for date expression";
    END "keep trying";

END "Get date expression";


require "  Parse and create date-code routines." message;

define D!Bug( m ) = { if DeBug then print( m ) };

simple procedure SetCode( integer a,b,c,d,e );
! ----------------------------------------------------------------------;
!									;
!									;
! ----------------------------------------------------------------------;
BEGIN
  GB!Coded_ true;

  if GetMult = 0 then 
    PutMult( a );
  if GetType = 0 then 
    PutType( b );
  if GetMoMult = 0 then 
    PutMoMult( c );
  if GetBody = 0 then 
    PutBody( d );
  if GetConn = 0 then 
    PutConn( e );
  SREF( TodaysIntrnDat );
END;

simple procedure ClearCode;
! ----------------------------------------------------------------------;
!									;
!									;
! ----------------------------------------------------------------------;
BEGIN
  PutMult( 0 );
  PutType( 0 );
  PutMoMult( 0 );
  PutBody( 0 );
  PutConn( 0 );
END;

simple procedure Connect( integer Con );
! ----------------------------------------------------------------------;
!									;
!									;
! ----------------------------------------------------------------------;
BEGIN
  D!Bug( Con );
  GI!Pos_ GI!Pos - D!Length;
  PutConn( Con );
  GI!Pos_ GI!Pos + D!Length;
END;


simple boolean procedure UNIT( string S;
				reference string GS!ERR
			     );
! ----------------------------------------------------------------------;
!									;
! Returns true with GS!ERR = null if a valid unit was passed.		;
! Returns false with GS!ERR = null if a fragment of a valid unit was passed.  ;
! Returns false with GS!ERR containing an error message if what was passed    ;
!   contains a violation of the syntax.					;
!									;
! ----------------------------------------------------------------------;
BEGIN "unit"
	boolean DOW,MOY,Cyclic;
	integer MM,DD,YY,cycle,diff,TGTDay,BaseDayNum,NextDate,base;
	string Str,BaseDay;

  D!Bug( crlf&"UNIT: "&S );
  Cycle_ 0;
  Cyclic_ false; 		! becomes true if "every" is found;
  GB!SpecDat_ false; 		! becomes true if the unit was a specific date;
  Str_ LopWrd( S ); 		! get first word;

  if KEQU( Str,"STARTUP" ) then
    BEGIN
    SetCode( 0,TypS,0,0,EndCon );
    SREF( -1 );
    return( true );
    END;

  if KEQU( Str,"TODAY" ) then
    BEGIN
    SetCode( 0,TypS,0,0,EndCon );
    GB!SpecDat_ true;
    return( true );
    END;

  if KEQU( Str[ 1 for 7 ],"WEEKDAY" ) then
    BEGIN
	integer i;
    for i_ 2 upto 5 do
      BEGIN
      SetCode( 1,TypW,0,i,AndCon );
      SREF( TodaysIntrnDat );
      GI!Pos_ GI!Pos + D!Length;
      END;
    GB!Week_ true;
    SetCode( 1,TypW,0,6,EndCon );
    return( true );
    END
  else
    if GB!Week then
      BEGIN
      GS!ERR_ "?WEEKDAYS CAN BE FOLLOWED ONLY BY A TIME, A MODIFIER, OR 'AND'";
      return( false );
      END;

  if KEQU( Str,"TOMORROW" ) then
    BEGIN
    SetCode( 0,TypS,0,0,EndCon );
    GB!SpecDat_ true;
    SREF( TodaysIntrnDat + 1);
    return( true );
    END;

  if KEQU( Str,"EVERY" ) then
    BEGIN
    Cyclic_ true;
    Cycle_ 1;
    if length( S ) = 0 then
      return( false )
    else
      Str_ LopWrd( S ); 			! get word after "every";
    END;

  !------------------;
  !	AS: "APRIL 3, 1986"						;
  !------------------;
  if ValidMOY( Str ) then 			! is the word as "MARCH"?;
    BEGIN  "units"
    if Cyclic then 		! "every" was encountered previously;
      BEGIN 		! expressions such as "every August" are invalid;
      GS!ERR_ "?EVERY cannot be followed by a date or month";
      return( false );
      END;
    MM_ Vik( Mos, Str ); 	! convert the month name to a number 0-11;
    if length( S ) = 0 then 	! month name must be followed by something.;
      return( false )		! false but no error since it may come next ;
    else	  	
      Str_ LopWrd( S ); 		! more to string so get next word;

    if ValNum( Str ) then     ! month had better be followed by a number;
      BEGIN
      DD_ cvd( Str ); 		! DD holds the day;
      if length( S ) = 0 then   ! so far so good but return false for more;
        return( false );
      Str_ LopWrd( S ); 	! there is more so check for year number;
      if ValNum( Str ) then   ! need number for year here;
        BEGIN
        YY_ cvd( Str[inf - 1 to inf] );  	! store the year in YY;
	if ( YY < cvd( CvSDat( TodaysIntrnDat )[inf-1 to inf] ) )
	 then
          BEGIN
          GS!ERR_ "?DATE TOO FAR IN THE PAST OR YEAR > 1999";
          return( false );
          END
	else
	  BEGIN 					! Date is OK ;
          SetCode( 0,TypS,0,0,EndCon );
          SREF( CvDate( MM + 1,DD,YY ) );
          GB!SpecDat_ true;
          return( true );
	  END
        END
      else
        BEGIN 	! month and day followed by something other than a year;
        GS!ERR_ "?Month must be followed by DD YYYY";
        return( false );
        END
      END
    else
      BEGIN 	! month followed by something other than a day number;
      GS!ERR_ "?Month must be followed by DD YYYY";
      return( false );
      END
    END;

  if KEQU( Str,"EVERY" ) then 		! "EVERY" here means fatal trouble;
    BEGIN
    if Cyclic then
      GS!ERR_ "?CONSECUTIVE EVERY'S."
    else
      GS!ERR_ "?EVERY must be in first position of a unit ";
    return( false ); 
    END;

  !------------------;
  !	AS: "EVERY 5 DAYS" OR "10TH DAY OF EVERY MONTH" OR "2ND MONDAY" etc.  ;
  !------------------;
  if ValNum( Str ) then 	! a number encountered at BEGINning of unit or;
    BEGIN                  	!   after an "EVERY";
    cycle_ cvd( Str ); 		! store the number in "cycle";
    if cycle = 0 then
        BEGIN
      GS!ERR_ "?CYCLE MUST BE GREATER THAN ZERO";
      return( false );
        END;
    if length( S ) = 0 then 	! so far so good, return for more;
      return( false )
    else
      Str_ LopWrd( S ); 	! stuff left in string so get next word;

    if KEQU( Str,"EVERY" ) then 	! such as in "10TH [OF] EVERY MONTH";
      BEGIN
      Str_ LopWrd( S ); 		! get next;
      if kequ( Str,null ) then
        return( false );
      END;

    if KEQU( Str[ 1 for 5 ],"MONTH" ) then
      BEGIN 
      if not GB!Coded then 	! must be expression such as "EVERY nTH MONTH";
        BEGIN
        SetCode( 0,TypN,Cycle,1,EndCon );
        return( true );
        END
      else 				! such as "... OF EVERY nTH MONTH";
        BEGIN
        if cycle > 9 then ! multiplier must be < 10;
          cycle_ 9;
        END;
    
      if GB!DayCyc then 		! first unit of this same expression was days;
        SetCode( 0,TypN,Cycle,GI!DayCyc,EndCon )
      else 	     ! second part of exp as "1ST WED OF EVERY [cycle] MONTH";
        SetCode( 0,0,Cycle,0,EndCon );
  
      GB!MonUnit_ true; 		! second unit of 2 unit exp must be month unit;
      return( true );
      END ;

    if ValidDaOfWk( Str ) then 	! for example: "EVERY MONDAY" or "2ND WED";
      BEGIN
      SetCode( Cycle,TypW,0,Vik( WkDay,  Str) ,EndCon );
      return( true );
      END;

    if KEQU( Str[1 for 3], "DAY" ) then 	! as in "EVERY nTH DAY";
      BEGIN
      GI!DayCyc_ Cycle;
      SetCode( 1,TypN,0,Cycle,EndCon );
      GB!DayCyc_ true; 			! a cyclic day unit has been coded;
      return( true );
      END;

    if KEQU( Str[1 for 6], "MINUTE" ) then 	! as in "EVERY nTH MINUTE";
      BEGIN
      if Cycle > 1439 then
        BEGIN
        GS!ERR_ "?MINUTES MUST NOT BE > 1439";
	return( false );
        END;
      SetCode( 0,TypT,0,Cycle,EndCon );
      STIM( Tfract( TheTime ) ); 	  ! Default ref-time is current time. ;
      ! SREF( Cycle );
      return( true );
      END;

    if KEQU( Str[1 for 4], "HOUR" ) then 	! as in "EVERY nTH HOUR";
      BEGIN
      if Cycle > 23 then
        BEGIN
        GS!ERR_ "?HOURS MUST NOT BE > 23";
	return( false );
        END;
      SetCode( 0,TypT,0,Cycle * 60,EndCon );
      STIM( Tfract( TheTime ) );	  ! Default ref-time is current time. ;
      ! SREF( Cycle * 60 );
      return( true );
      END;

    GS!ERR_ GS!ERR & "(" & Str & ")" &
		 "EXPECTED 'MONTH' OR 'DAY' OR A DAY OF THE WEEK";
    return( false ); 			! Fall-through to here means error ;

    END; 						! if ValNum;

  if KEQU( Str[ 1 for 5 ],"MONTH" ) then 		! as "EVERY MONTH";
    BEGIN 
    if not GB!Coded then 	! whole exp is "EVERY MONTH" or "MONTH";
      BEGIN
      if Cycle = 0 then
        Cycle_ 1; 		! "MONTH" becomes "EVERY MONTH" ;
      SetCode( 0,TypN,Cycle,1,EndCon );
      END
    else
      BEGIN
      if GB!DayCyc then ! second half of exp as: "nTH DAY EVERY [cycle] MONTHS";
        SetCode( 0,TypN,Cycle,GI!DayCyc,EndCon )
      else 	    ! it's the second unit of exp as "3RD MOND OF EVERY MONTH";
        SetCode( 0,0,1,0,EndCon );
      END;
    GB!MonUnit_ true; 		! second unit of 2 unit exp must be month unit;
    return( true );
    END;
  
  !------------------;
  !									;
  !------------------;
  if ValidDaOfWk( Str ) then 			! as in "EVERY MONDAY" (  );
    BEGIN
    if Cycle = 0 then ! Only the next DOW is required so figure the date ;
      BEGIN
      base_ TodaysIntrnDat;		! base is disp from 1-jan-64 ;
      TGTday_ Vik( WkDay,  Str );
      BaseDayNum_ ( base + 4 ) mod 7;	! +4 = sat when mod 7 ;
      BaseDay_ WkDay[ BaseDayNum ];
      if BaseDayNum = TGTday then
        diff_ 0
      else
        if BaseDayNum < TGTday then
          diff_ abs( BaseDayNum - TGTday )
        else
          diff_ 7 - ( BaseDayNum - TGTday );
      NextDate_ base + diff; 
      SetCode( 0,TypS,0,0,EndCon );
      if NextDate = base then
        SREF( NextDate + 7 )
      else
        SREF( NextDate );
      GB!SpecDat_ true;
      return( true );
      END
    else
      BEGIN
      SetCode( Cycle,TypW,0,Vik( WkDay,  Str ),EndCon );
      return( true );
      END
    END;

  if KEQU( Str[1 for 3], "MIN" ) then 		! as in "EVERY MINUTE" ;
    GS!ERR_ "?FORMAT IS 'EVERY n MINUTES'.";

  if KEQU( Str[1 for 3], "HOU" ) then 			! as in "EVERY HOUR" ;
    GS!ERR_ "?FORMAT IS 'EVERY n HOURS'." ;

  !------------------;
  !	as: "EVERY DAY".						;
  !------------------;
  if KEQU( Str[1 for 3], "DAY" ) then 			! as in "EVERY DAY" ;
    BEGIN
    if cycle = 0 then 				! need to know how many days;
      BEGIN
      GS!ERR_ "?NEED HOW MANY DAYS OR EVERY DAY";
      return( false );
      END
    else
      BEGIN
      GB!DayCyc_ true; 			   ! a cyclic day unit has been coded;
      SetCode( 1,TypN,0,cycle,EndCon );
      return( true );
      END
    END;
  return( false );		! Valid Unit will never get to this point ;
END "unit";


simple boolean procedure ValidExpression( string S;
					  reference string GS!ERR
					);
! ----------------------------------------------------------------------;
!									;
! returns true with GS!ERR = null if a valid expression was passed.	;
!									;
! ----------------------------------------------------------------------;
BEGIN "ValidExpression"
  string ExpSoFar;
  integer i;

  D!Bug( crlf&"EXPR: "&S );
  ExpSoFar_ null;
  GB!Week_ false;		! Will become true if expression is WEEKDAYS;

  while true do				 ! get rid of leading blanks;
    if kequ( S[1 for 1] , " " ) then
      S_ S[ 2 to inf ]
    else
      done;

  while not UNIT( ExpSoFar,GS!ERR ) do
    BEGIN "first unit"
    if kequ( S,null ) and kequ( GS!ERR,null )  then 
      GS!ERR_ "?INVALID EXPRESSION ";
    ExpSoFar_ ExpSoFar & LopWrd( S ) & " ";   ! add next word, then retry UNIT;
    if kequ( GS!ERR,null ) then   ! string passed to UNIT was not enough to be;
      continue                    ! valid but no detectable error yet.;
    else
      return( false ); ! error;
    END "first unit";

  GB!DayCyc_ false;
  ExpSoFar_ null;

  if length( S ) > 0 then
    BEGIN "possible second unit"
    GB!MonUnit_ false; ! true if unit found is a month unit;

    while not UNIT( ExpSoFar,GS!ERR ) do 	! same routine as above;
      BEGIN "find month unit or time"
      if kequ( S,null ) and kequ( GS!ERR,null )  then 
        BEGIN "nothing valid yet but no more"
        if kequ( ExpSoFar[ inf for 1 ]," " ) then
          ExpSoFar_ ExpSoFar[ 1 to inf - 1 ];
        if ValidTimeStr( ExpSoFar ) or ValNum( ExpSoFar ) then
          BEGIN "the run time"
 	  if ValNum( ExpSoFar ) and cvd( ExpSoFar ) > 24 then
	    BEGIN "invalid hour"
            GS!ERR_ "?Hour of THE DAY MUST NOT BE GREATER THAN 24.";
	    return( false );
	    END "invalid hour"
          else
	    BEGIN "load time"
	    if GB!Week then
	      BEGIN "load time for WEEKDAYS"
	      GI!Pos_ GI!Pos - ( 4 * D!Length ); ! Back up to Monday. ;
              for i_ 1 upto 5 do ! Insert the required time in each weekday. ;
                BEGIN "WEEKDAY times"
                STIM( TFract( ExpSoFar ) );
                GI!Pos_ GI!Pos + D!Length;
                END "WEEKDAY times";
	      END "load time for WEEKDAYS"
	    else
	      BEGIN "regular load time"
              STIM( TFract( ExpSoFar ) );
	      END "regular load time";
            GB!MonUnit_ GB!SpecDat_ true;
            return( true );
	    END "load time";
          END "the run time"
        else
          BEGIN "nothing left but not enough"
          GS!ERR_ "?INVALID EXPRESSION ";
          END "nothing left but not enough"
        END "nothing valid yet but no more";

      ExpSoFar_ ExpSoFar & LopWrd( S ) & " ";
      if kequ( GS!ERR,null ) then
        continue
      else
        return( false ); 			! error detected in UNIT;

      END "find month unit or time";

    if NOT GB!MonUnit then
      BEGIN 
      GS!ERR_ "?SECOND UNIT IN TWO UNIT EXPRESION MUST BE A MONTH UNIT.";
      return( false );
      END

    END "possible second unit";

  if kequ( S[ inf for 1 ]," " ) then
    S_ S[ 1 to inf - 1 ];

  if length( S ) > 0 then 
    BEGIN "time was after month unit"
    if ValidTimeStr( S ) or ValNum( S ) then
      BEGIN
      if ValNum( ExpSoFar ) and cvd( ExpSoFar ) > 24 then
        BEGIN
        GS!ERR_ "?(3)Hour of THE DAY MUST NOT BE GREATER THAN 24.";
        return( false );
        END;
      STIM( TFract( S ) );
      return( true );
      END
    else
      BEGIN
      GS!ERR_  "UNKNOWN TERMS: <" & s & ">";
      return( false );
      END
    END "time was after month unit"
  else
    BEGIN
    return( true );
    END
END "ValidExpression";


boolean procedure ValidGroup( string OrigStr;
			      reference string GS!ERR
			    );
! ----------------------------------------------------------------------;
!									;
! 		Gets all up to next "AND" or the END of expression.	;
!									;
! ----------------------------------------------------------------------;
BEGIN "ValidGroup"
  integer ModDate,ModTime,ModNum;
  string OneExpSoFar,NxtWrd,LatestMod;

  boolean procedure TooLong;
  BEGIN "TooLong"
    If GI!Pos = E!Length then
      BEGIN "too large"
      GS!ERR_ "?TOO MANY EXPRESSIONS. MAX = " & cvs( E!MaxItem );
      return( true );
      END "too large"
    else
      return( false );
  END "TooLong";

  D!Bug( crlf&"Grou: "&OrigStr );
  OneExpSoFar_ LatestMod_ null;
  NxtWrd_ LopWrd( OrigStr );

  while true do
    BEGIN "assemble first expression"
    if ValModifier( NxtWrd ) then	! mod found;
      BEGIN "modifier encountered"
      LatestMod_ NxtWrd; 		! store the modifier;
      done;	 			! first expression cpmplete. ;
      END "modifier encountered"
    else
      BEGIN "add latest word to our expression"
      OneExpSoFar_ OneExpSoFar & NxtWrd & " ";
      if length( OrigStr ) = 0 then
        done
      else
        NxtWrd_ LopWrd( OrigStr );
      END "add latest word to our expression"
    END "assemble first expression";

  if ValidExpression( OneExpSoFar,GS!ERR ) then ! evaluate what we've got ;
    BEGIN "first expression was valid"
    if length( OrigStr ) = 0 then  ! if END of string;
      BEGIN "no more"
      if kequ( LatestMod,null ) then
        BEGIN "wrap up"

        GI!Pos_ GI!Pos + D!Length;			D!Bug( "<1>" );

        if TooLong then
          return( false );

        return( true );

        END "wrap up"
      else
        BEGIN		
        GS!ERR_ "?MODIFIER MUST BE FOLLOWED BY A DATE";
        return( false );
        END
      END "no more"
    END "first expression was valid"
  else
    BEGIN 
    return( false );
    END;

  if TooLong then
    return( false );

  OrigStr_ LatestMod & " " & OrigStr;    ! modifier which caused break is Put back;

  ! OrigStr now consists of a modifier followed by more words. ;
  while true do
    BEGIN "loop once for each mod followed by a date"
    OneExpSoFar_ LatestMod_ null;
    while true do
      BEGIN  "loop once for each word"
      NxtWrd_ LopWrd( OrigStr );
      if ValModifier( NxtWrd ) then
        BEGIN "found a modifier"		D!Bug( " '"&NxtWrd&"' " );
        if kequ( LatestMod,null ) then
          BEGIN "first mod on this loop"
          LatestMod_ NxtWrd;
          case LatestMod[1 for 1] of
            BEGIN
            [ "A" ] [ "a" ] ModNum_ ( AftCon );
            [ "B" ] [ "b" ] ModNum_ ( BefCon );
            [ "S" ] [ "s" ] ModNum_ ( StaCon );
            [ "U" ] [ "u" ] ModNum_ ( UntCon );
            [ "E" ] [ "e" ] ModNum_ ( ExcCon )
            END;

          if length( OrigStr ) > 0 then
	    BEGIN "there is more"
            continue
	    END "there is more"
          else
	    BEGIN "nothing left"
            if kequ( OneExpSoFar,null ) then
              BEGIN "nothing between modifiers"
              GS!ERR_ "?CONTIGUOUS MODIFIERS";
              return( false );
              END "nothing between modifiers"
            else
	      BEGIN "enough for a new expression"
              done;
	      END "enough for a new expression"
	    END "nothing left"
          END "first mod on this loop"
        else
          BEGIN "replace newfound modifier"
          OrigStr_ NxtWrd & " " & OrigStr;
          done;
          END "replace newfound modifier"
        END "found a modifier"
      else
        BEGIN "not a mod so add it on"
        OneExpSoFar_ OneExpSoFar & " " & NxtWrd;
        if length( OrigStr ) > 0 then
          BEGIN "more to come"				D!Bug( " "&NxtWrd );
          continue;
          END "more to come"
        else
          done;
        END "not a mod so add it on"

      END "loop once for each word";

    GI!Pos_ GI!Pos + D!Length;   			D!Bug( "<f2>" );

    ! Modififier followed by some expression has been found so check it. ;
    if ValidExpression( OneExpSoFar,GS!ERR ) then
      BEGIN  "expression was valid"
      ModDate_ GREF;
      ModTime_ GTIM;

      if ModNum < 4 and Not GB!SpecDat then
        BEGIN
        print( crlf,"ModNum=<",ModNum,">" );
        GS!ERR_ "?NEED A DATE WITH AFTER/UNTIL" & crlf &
                  "  EX: STARTING MMM DD, YYYY .";
        return( false );                
        END;

      GB!Coded_ true;

      if ModNum = AftCon then			
        BEGIN
        GI!Pos_ GI!Pos - D!Length; 		D!Bug( "<b1>" );
        SREF( ModDate );			D!Bug( "(3)SREF" );
        GI!Pos_ GI!Pos + D!Length; 		D!Bug( "<f3>" );
        ClearCode;
        END
      else
        BEGIN  "mod was not after"
        Connect( ModNum ) ;			D!Bug("PConn(1):"&ModNum&" ");
        END "mod was not after";

      if TooLong then
        return( false );

      if length( OrigStr )  > 0 then
        continue
      else
        BEGIN
!        GI!Pos_ GI!Pos + D!Length; 	!	D!Bug( "<f4>" );
        return( true );
	END;

      END "expression was valid"
    else
      BEGIN
      return( false );
      END
    END  "loop once for each mod followed by a date";

END "ValidGroup";


simple boolean procedure ParsedOK( string S;
				   reference string GS!ERR
				 );
! ----------------------------------------------------------------------;
!									;
! takes user's date expression up to the end and sends it to routines	;
! to parse.  If the expression contains "and"'s, this procedure takes	;
! everything between AND's and individually parses each until whole	;
! expression is done.  	Returns true if no errors detected.		;
!									;
! ----------------------------------------------------------------------;
BEGIN
  string Onestring;
  integer ANDcount;

  D!Bug( crlf&"PaOK: "&S );
  GI!Pos_ E!Descriptor;
  if HowMany( S,"BEFORE" ) > 1 then
    BEGIN
    GS!ERR_ "?NO MORE THEN 1 BEFORE/UNTIL PER DATE SPECIFIER";
    return( false );
    END;

  ANDcount_ HowMany( S,"AND" );
  while true do
    BEGIN
    Onestring_ S_ " " & S; 	! first word not a modifier so replace.;
    if ANDcount > 0 then
      Onestring_ LopTo( S,"AND" ); 	  ! get everthing upto next "and";
    if ValidGroup( Onestring,GS!ERR ) then 	! should be a valid group;
      BEGIN
      if ANDcount > 0 then 		! there is another "and" ahead;
        BEGIN
        GB!Coded_ true;
        Connect( AndCon ) ;
        END;
      ANDcount_ ANDcount - 1;
      if ANDcount < 0 then
        BEGIN 
	PutConn( EndCon );
        return( true );
	END
      else
        continue;
      END
    else
      BEGIN
      return( false );
      END
    END 						! while true;
END;


simple boolean procedure NoDateExpression;
! ----------------------------------------------------------------------;
!									;
! 		See if there is a date expression in the array.		;
!									;
! ----------------------------------------------------------------------;
BEGIN "NoDateExpression"
  if GetConn = 0 then				! Empty. ;
    BEGIN "array is empty"
    print( "NO REQUEST HAS BEEN ENTERED",crlf );
    return( true );
    END "array is empty"
  else
    return( false );
END "NoDateExpression";



simple procedure express;
! ----------------------------------------------------------------------;
!									;
! 		Translates date code into English and displays. 	;
!									;
! ----------------------------------------------------------------------;
BEGIN "express"
  integer Multiplier,MoMultiplier,Body,NumExps,i,j,refDate,
  Type,Connector,ExpS,TimFrac,Minutes,Hours;

  GI!Pos_ E!Descriptor;				! Start from beginning. ;

  if NoDateExpression then
    return;

  for GI!Pos_ E!Descriptor step D!Length until E!Length - 1 do
    BEGIN "do each expression"
    Multiplier_   GetMult;
    type_         GetType;
    MoMultiplier_ GetMoMult;
    body_         GetBody;
    Connector_    GetConn;
    refDate_      GREF;

    case type of
      BEGIN
      [ typW ]
        BEGIN "type W"
        if MoMultiplier > 0 then
          BEGIN "day in cyclic month"
          print(       if Multiplier = 1 then "THE FIRST "
                  else if Multiplier = 2 then "THE SECOND "
                  else if Multiplier = 3 then "THE THIRD "
                  else if Multiplier = 0 then " ONCE ONLY:A "
                  else if Multiplier = 9 then "THE LAST "
                  else  "THE " & cvs( Multiplier ) & "TH " 
                );
          print( WkDay[ body ] );		 ! Some day-of-the-week. ;
          print(       if MoMultiplier = 1 then " OF EVERY MONTH "
                  else if MoMultiplier = 2 then " OF EVERY OTHER MONTH"
                  else if MoMultiplier = 3 then " OF EVERY THIRD MONTH"
                  else if MoMultiplier > 3 then " OF EVERY " 
                                            & cvs( MoMultiplier ) & "TH MONTH"
                  else null
                );
          END "day in cyclic month"
        else
          BEGIN "cyclic day"
          print(       if Multiplier = 1 then "EVERY "
                  else if Multiplier = 2 then "EVERY OTHER "
                  else if Multiplier = 0 then ""
                  else if Multiplier = 3 then "EVERY 3RD "
                  else "EVERY " & cvs( Multiplier ) & "TH "
                );
          print( WkDay[ body ] );		! Some day-of-the-week. ;
          END "cyclic day"
        END "type W";

      [ typN ]
        BEGIN "type N"
        if MoMultiplier > 0 then
          BEGIN "day number in cyclic month"
          print( "THE " );
          print(       if body = 32 then "LAST DAY " 
                  else if body = 1  then "FIRST DAY " 
                  else if body = 2  then "SECOND DAY " 
                  else if body = 3  then "THIRD DAY "
                  else cvs( body ) & "TH DAY "
                );
          print(      if MoMultiplier = 1  then "OF EVERY MONTH "
                  else if MoMultiplier = 2 then "OF EVERY OTHER MONTH"
                  else if MoMultiplier = 3 then "OF EVERY THIRD MONTH"
                  else if MoMultiplier > 3 then "OF EVERY " 
                       & cvs( MoMultiplier ) & "TH MONTH"
                  else null
                );
          END "day number in cyclic month"
        else
          BEGIN "every n days"
          print( "EVERY " );
          print(           if body = 1 then "DAY " 
                      else if body = 2 then "SECOND DAY " 
                      else if body = 3 then "THIRD DAY "
                      else cvs( body ) & "TH DAY "
                );
          END "every n days"
        END "type N";

      [ TypT ]
        BEGIN "type T"
        Minutes_ body;
        Hours_   Minutes Div 60;
        Minutes_ Minutes mod 60;
        if Hours > 0 then
          BEGIN "every n hours"
          print( "EVERY " , Hours , " HOURS" );
          if Minutes > 0 then
            BEGIN "and every n minutes"
            print( " AND " , Minutes , " MINUTES" );
            END "and every n minutes"
          END "every n hours"
        else
          BEGIN "every n minutes"
          print( "EVERY ", Minutes ," MINUTES" );
          END "every n minutes";
        print( " REFERENCE " );
        print( CvSTim( GTIM ) );
        END "type T";

      [ TypS ]
        BEGIN "type S"
        if refDate = 262143 then
          print( "STARTUP" )
        else
          print( CvSDat( refDate ) );
        END "type S"
      END; ! case ;

      if not type = TypT and		! Time of day. ;
       not refDate = 262143 then
      BEGIN "time of day"
      TimFrac_ GTIM;
      print( if TimFrac = 0 then " AT MIDNIGHT"
            else " AT " & CvsTim( TimFrac )
            );
      END "time of day";

    if refDate > TodaysIntrnDat and
        not type = TypS       then
      print( " AFTER ",CvSDat( GREF ) );

    case connector of 
      BEGIN "show connector"
      [  AndCon  ] print( crlf,"AND " );
      [  StaCon  ] print( " STARTING: " );
      [  BefCon  ] print( " BEFORE: " );
      [  ExcCon  ] print( " EXCEPT: " );
      [  UntCon  ] print( " UNTIL: " );
      [  EndCon  ] print( "." );
      else 	! event of an unknown connector ( should never happen );
        print( crlf," ?" ,connector,"?",crlf,"              " )
      END "show connector";
    if Connector = EndCon then
      done;
    END "do each expression";
  print( crlf );

END "express"; 


simple procedure Display;
! ----------------------------------------------------------------------;
!									;
! 		Generates sample dates based on users date expression. 	;
!									;
! ----------------------------------------------------------------------;
BEGIN "display"
	string  date,		! Temp hold for dd-mmm-yy string. ;
		DOW;		! Gets a day of the week (ex: MONDAY). ;
	integer GMTbase,	! After-Date supplied to nextime.;
				!   Nextime will find next run after GMTbase;
		dis,		! Gets date/time returned by NextTime;
		Count;		! Keep track of how many run dates have been;
				!   displayed on the screen. ;

  GI!Pos_ E!Descriptor;				! start at beginning. ;

  if NoDateExpression then
    return;

  Count_ 0;
  GMTbase_ GetTDT;		! First base date for NextTime will be NOW. ;
  while true do			! Go until no further dates or user stops it. ;
    BEGIN "once for each date"
    Count_ Count + 1;				! Keep track of how many dates;

    dis_ NexTim( Current[0],GMTbase ); 		! returns 0 if no more dates. ;

    GMTbase_ dis;				! base for next time around. ;

    if dis = 0 or !lh( dis ) > 13148 then 	! no dates after 12/31/1999;
      BEGIN "Out of dates"
      print( crlf,"no further dates.",crlf );
      done;
      END "Out of dates"
    else
      BEGIN "show the latest date"

      dis_ CvtDTM( dis, 0, '20 ); 		! Convert to local from GMT. ;
      Date_ CvSDat( !lh( dis ) );		! Convert to dd-mmm-yy. ;
      DOW_ WkDay[ ( !lh( dis ) + 4 ) mod 7 ]; 	! Figure the day of the week;
      print( date," ",DOW );			! Display the date and day. ;
      print( "          "[ 1 for ( 10 - length( DOW ) ) ] );
      print( " AT ",CvSTim( !rh( dis ) ) );	! Include time of day. ;

      if Count = 10 then 			! Display 10 at a time. ;
        BEGIN "pause after ten"
        print( crlf&"- <cr> ends list, any char for more:" );
        if kequ( inchrw,#cr ) then		! User typed <cr> only. ;
          BEGIN "thats all"			! So that's it. ;
	  print( crlf );
          return;
          END "thats all"
        else					! Else re-initialize counter;
          Count_ 0;				!   and continue. ;
        END "pause after ten";

      END "show the latest date";

    print( crlf );
    END "once for each date";

END "display";


simple procedure Look;
! ----------------------------------------------------------------------;
!									;
! 		Shows date code generated by a date expression.		;
! 		This procedure will screw up if the date expression	;
!		  is greater than the screen width.			;
! ----------------------------------------------------------------------;
BEGIN "look"

  if NoDateExpression then
    return
  else
    BEGIN "print date code"

    ! first print the heading. ;
    for GI!Pos_ E!Descriptor step D!Length until ( E!Length - D!Length - 1 ) do
      BEGIN "heading"
      print( "/T  bbbbC      ( time )" );
      if GetConn = EndCon then done;
      END "heading";
    print( "/" );
    print( crlf );

    ! Now the actual contents of the descriptor. ;
    for GI!Pos_ E!Descriptor step D!Length until ( E!Length - D!Length - 1 ) do
      BEGIN "show code"
      print( GetMult    );
      print( GetType    );
      setformat( -2,2 );
      print( GetMoMult  );
      setformat( -4,4 );
      print( GetBody    );
      setformat( 0,7 );
      print( GetConn    );
      setformat( -5,5 );
      print( GREF );
!     print( !lh( Current[ GI!Pos + D!Daytime ] ) );
!     setformat( -6,6 );
      print( "," );
      print( CvSTim( GTIM ) );
      setformat( 0,7 );
      if GetConn = EndCon then		! Quit at end of the date spec. ;
        done;
      END "show code"

    END "print date code";

  print( crlf );

END "look";


simple procedure Test;
! ----------------------------------------------------------------------;
!									;
! 		Performs "express" and "display" commands. 		;
!									;
! ----------------------------------------------------------------------;
  if NoDateExpression then
    return
  else
    BEGIN "do both"
    express;
    Display;
    END "do both";



simple procedure LoadFileName( integer array Arr; ! Array in which to insert ;
			   string FNStr;    	  ! file name as furnished. ;
			   integer position       ! Where to insert in array. ;
			 );
! ----------------------------------------------------------------------;
!									;
! 		Places username into array positions:			;
!			 position+F!User - position+F!User+1		;
!		filename into position:					;
!			 position + F!Name				;
!		and extention into position:				;
!			 position + F!Ext				;
!									;
!		If FNStr = null then this proc. will clear array.	;
!									;
! ----------------------------------------------------------------------;
BEGIN "Load file name"
    own safe integer array FName[ S!Dev : S!Ext ];

    VMSpec( FNStr, FName );		! Separate file name components ;

    Arr[ position + F!Device ]_ FName[ S!Dev ];
    Arr[ position + F!User+0 ]_ FName[ S!Usr+0 ];
    Arr[ position + F!User+1 ]_ FName[ S!Usr+1 ];
    Arr[ position + F!Name ]_   FName[ S!Nam ];
    Arr[ position + F!Ext ]_    FName[ S!Ext ];


END "Load file name";


simple boolean procedure CheckLog( string FileName ); 
! ----------------------------------------------------------------------;
!									;
! 		See if log file name is a valid file name and		;
! 		make sure it can be opened and entered.			;
!		Do NOT permit anyone without QM license to create	;
!		a log file in directory (SYS).  For security reasons	;
!		QM license implies GAN of 3 for the SUBMIT program.	;
!									;
! ----------------------------------------------------------------------;
BEGIN "CheckLog"
	own safe integer array FName[ S!Dev : S!Ext ];
	integer	eof;

  if ( VMSpec( FileName, FName ) ) then		! check filename format ;
    BEGIN "syntax OK"
    if ( FName[ S!Usr+1 ] = 0 ) and		! user trying to log ;
       ( FName[ S!Usr ] = cvSix( "SYS" ) )	!  to (SYS)? ;
     then if not( ( JobLic land LC!!QM ) and	!  yes, then must have QM ;
		  ( !lh( JobAun ) = 3 ) )	!         and be in GAN 3 ;
	   then BEGIN
	      print( " Cannot write logfile to SYSTEM directory" );
	      return( false );
	   END;
    DecLicense;					! forget special license ;
    eof_ VMFile( FileName, VM$Write );		! eof gets -1, can't enter. ;
    if ( 0 < eof )
     then VMFree( eof, CL!Acs lor CL!Rst )	! Release the channel. ;
     else if ( !rh( eof ) = !ERFBM )		! file being modified? ;
	   then if ( 0 < eof_ VMFile( FileName, VM$Read ) )
		 then VMFree( eof, CL!Acs lor CL!Rst );
    IncLicense;					! get license back ;
    return( 0 < eof );				! true if enter succeeded. ;
    END "syntax OK"
  else
    BEGIN
    print( " Illegal logfile name" );
    return( false );
    end;

END "CheckLog";


simple boolean procedure ComIsOK( reference string FileName );
! ----------------------------------------------------------------------;
!									;
! 		See if the file 'FileName' is syntacticly OK and	;
! 		See if the file 'FileName' exists.			;
!									;
! ----------------------------------------------------------------------;
BEGIN "ComIsOK"
    own safe integer array FName[ S!Dev : S!Ext ];
    integer	NotFound;	! Becomes true if open or lookup fails. ;

  if ( VMSpec( FileName, FName ) ) then	! check file name format ;
    BEGIN "syntax OK"

    DecLicense;				! forget special license ;
    if ( 0 geq NotFound_ VMFile(FileName, VM$Read) ) then
      BEGIN "try extension"		! file wasn't found ;

      if not( FName[ S!Ext] ) then	! if there was no extension ;
        BEGIN "add extension"		!  then try filename.CTL ;
        NotFound_ VMFile( FileName_ FileName & ".CTL", VM$Read );
        END "add extension";

      if ( 0 geq NotFound ) then	! Still not found, so complain. ;
        BEGIN "bad filename"
        print( crlf,"Cannot find """, FileName[ 1 to inf-3 ] );
        if not( FName[ S!Ext] ) then
          print( """ or """, FileName );
        print( """.", crlf );
	IncLicense;
        return( false );
        END "bad filename";

      END "try extension";

    ! A command file was located. ;
    VMFree( NotFound, CL!ACS lor CL!RST );
    IncLicense;
    return( true );
    END "syntax OK"
  else
    BEGIN "weird filename"
    print( " Illegal file name" );
    return( false );
    END "weird filename";

END "ComIsOK";

simple procedure Swap( reference string A, B );
! ----------------------------------------------------------------------;
!									;
! 		Exchange string A for string B.				;
!									;
! ----------------------------------------------------------------------;
BEGIN "swap"
	string temp;
  temp_ A;
  A_ B;
  B_ temp;
END "swap";


simple procedure GetExpFromUser( boolean NewRecord );
! ----------------------------------------------------------------------;
!									;
!		Get the date expression from the user.			;
!		NewRecord parameter is true if the date expression	;
!		  is being entered after a DATES command at the		;
!		  SUBMIT prompt, in which case the array is cleared.	;
!		NewRecord parameter is false if the user is at the	;
!		  OPTIONS prompt, in which case a backup of the 	;
!		  queue rec is made and the date area of the queue	;
!		  rec is cleared to receive a new date expression.	;
!		If the new date expression entered at OPTIONS is bad	;
!		  then the queue rec is restored to its original state.	;
!									;
! ----------------------------------------------------------------------;
BEGIN "GetExpFromUser"
  arrclr( ModCheck,false ); 

  if NewRecord then		! True if this is a new record, ;
    arrclr( Current ) 		! False if this is a modification. ;
  else
    BEGIN "make backup and clear date area"
    arrblt( Template[ E!Runtime ],Current[ E!Runtime ],E!Length ); 

    			  ! Clear date expression area so that it ;
    for GI!Pos_ E!Descriptor step D!Length until E!Length-1 do 
      ClearCode;          !    can accept a new date expresion. ;
    END "make backup and clear date area";

  GB!Coded_ false;			! Set true during parser. ;
  GS!ERR_ null;				! Clear error message. ;
  GetDateSpec;				! Prompt for date expression. ;
  GS!Scanned_ ScanStr( GS!UsrsExp );	! Clear out illegal words. ;

  if NOT ParsedOK( GS!Scanned,GS!ERR ) then	! Try to parse. ;
    BEGIN "bad date expression"			! No good, ;
    print( GS!ERR,crlf );			! Print error message. ;

    if length( GS!Undef ) > 3 then		! Junk found earlier. ;
      print( crlf,"UNIMPLEMENTED TERMS: " , GS!Undef , crlf );

    if not NewRecord then		! Restore if Bogus date expression ;
      arrblt( Current[ E!Runtime ],Template[ E!Runtime ],E!Length ); 

    END "bad date expression";

END "GetExpFromUser";


simple boolean procedure GetOptions( boolean CalledFromMODIFY );
! ----------------------------------------------------------------------;
!									;
!	Prompt user for options before insertion.			;
!	Returns false if user types "ABORT" at the "OPTIONS:" prompt.	;
!	If "CalledFromMODIFY" parameter is passed non-zero then this	;
!	  procedure was called from ModJob, else it was called due	;
!	  to a regular insert.						;
!									;
! ----------------------------------------------------------------------;
BEGIN "getoptions"
	integer OptNum,		! Array position in Options array of an OPTION;
		Num,		! Holds number supplied as a parameter. ;
		WantLic,	! holds license wanted. ;
		HaveLic,	! holds license from OPER file. ;
		BP,		! Byte pointer. ;
		BPI;		! Byte pointer index. ;
	string	Reply,		! Response at OPTIONS prompt. ;
		FirstWord,	! First word from reply. ;
		Param,		! Gets the rest of Reply. ;
		Labl,		! Gets 2nd word of Reply for LABEL option. ;
		Parameters,	! Used with PARAMETERS option. ;
		OperName,	! Used with LICENSE option. ;
		LogFile,	! Used when changing log file. ;
		ComFile;	! Used for change in command file. ;

simple procedure OptionsMenu;
! ----------------------------------------------------------------------;
!									;
!		Print the options HELP menu.				;
!									;
! ----------------------------------------------------------------------;
BEGIN "OptionsMenu"

  ! Print the heading. ;
  print( crlf,"     Option           Values [Current setting]" );
  print( crlf,"     -------          ------" );

  ! One horizontal line for each option with an aray of parameters.  ;
  OpLine( "Log    ", LPPLog( Current ),    ARLog     );
  OpLine( "Dispose", LPPDisp( Current ),   ARDisp   );
  OpLine( "Mail   ", LPPMail( Current ),   ARMail    );
  OpLine( "Mailer ", LPPMprg( Current ),   ARMailer,  PRV$INV );
  OpLine( "Restart", LPPRestart( Current ),ARRestart );
  OpLine( "Run    ", LPPRunf( Current ),   NoYes     );
  OpLine( "Detach ", LPPDetf( Current ),   NoYes     );
  OpLine( "Halt   ", LPPHaltf( Current ),  YesNo,     PRV$INV lor PRV$QM );
  OpLine( "CCL    ", LPPCCLf( Current ),   NoYes     );
  OpLine( "CtyLog ", LPPCtyf( Current ),   NoYes,     PRV$INV lor PRV$QM );
  OpLine( "Unique ", LPPUniq( Current ),   ARUniq    );
  print( crlf );

  ! TMPNAME option. ;
  reply_ Cv6Str( LPPTMPF( Current ) lsh 18 );
  if equ( reply, null ) then
    reply_ "None";
  print( crlf&"      TmpName          ", reply ); 

  ! LABEL option. ;
  print( crlf&"      Label            " );
  if Current[ E!Label ] land ( '77 lsh 30 ) then
    print( Cv6Str( Current[ E!Label ] ) )
  else
    print( "#" & cvs( Current[ E!Label ] ) );

  ! Misc options. ;
  print( crlf&"      Priority         ", LPPJPri( Current ) );
  print( crlf&"      TimeLimit        ", LPPTiml( Current ), " minutes." );
  print( crlf&"      LogLimit         ", LPPLogl( Current )," minutes." );
  print( crlf&"      TruLimit         ", Current[ E!TRULim ], " TRUs." );

  ! PARAMETERS option. ;
  print( crlf&"      Parameters       " );
  Parameters_ null;				! Clear. ;
  BP_ Point( 7, Current[ E!Parameters ], -1 );	! Get byte pointer. ;
  For BPI_ 1 upto E!ParLength do		! String them together. ;
    if ( ILDB( BP ) ) then
      Parameters_ Parameters & LDB( BP );

    if ( length( Parameters ) = 0 ) then	! If there aren't any;
      print( "[none]" )				!   then say so ;
    else					! else ;
      print( "[",Parameters,"]" );		!   display them. ;
  if ( !rh( Current[ E!License ] ) ) then	! if any license, print it ;
    print( crlf&"      License          ",LicPrt(!rh(Current[ E!License ])) );

  print( crlf&crlf &"Type 'option-name ?'  for help with an option."&
	 crlf      &"     'Abort'          to exit without inserting."&
	 crlf      &" or  <return>         to insert."&
	 crlf );

END "OptionsMenu";

simple procedure Helper( string OptionName );
! ----------------------------------------------------------------------;
!									;
!		Called when user types HELP option-name st OPTIONS	;
!									;
! ----------------------------------------------------------------------;
BEGIN "help for specific option"
  OptNum_ FndKey( OptionName, Options );	! Find out which option. ;
  case OptNum of				! Display appropriate help. ;
    BEGIN "which option"
    print( LABELHelp  );
    print( TIMELIMITHelp  );
    print( TRULIMITHelp  );
    ;
    print( LOGHelp  );
    print( LOGLIMITHelp  );
    print( DISPOSEHelp  );
    ; ! print( MAILERHelp  );
    ; ! print( SPOOLHelp  );
    print( MAILHelp  );
    print( RESTARTHelp  );
    print( UNIQUEHelp  );
    print( PARAMETERSHelp  );
    print( HelpHelp );
    print( HelpHelp );
    print( ABORTHelp  );
    print( RUNHelp  );
    print( DETACHHelp  );
    print( HALTHelp  );
    print( CTYLOGHelp  );
    print( PRIORITYHelp  );
    print( CCLHelp  );
    print( TMPNAMEHelp  );
    ;  ! print( LOGFILEHelp  );
    print( LICENSEHelp  );
    else if kequ( GS!ERR, null ) then
           print( "UNIDENTIFIED OPTION: '",OptionName,"'." )	! None such. ;
         else
	   print( GS!ERR )
    END "which option";
  print( crlf );

END "help for specific option" ;

simple boolean procedure NoConflicts;
! ----------------------------------------------------------------------;
!									;
!		Improper parameter combinations must prevent insertion.	;
!									;
! ----------------------------------------------------------------------;
BEGIN "NoConflicts"

  ! If Run if not set then there can be no detach. ;
  if LPPRunf( Current ) = 0 then	! Run is NO. ;
    BEGIN
    if LPPDetf( Current ) then		! But DETACH is YES. ;
      BEGIN				
      print( crlf, "DETACH CANNOT BE 'YES' IF RUN IS 'NO'. " );	! Complain. ;
      print( crlf );
      return( false );				! Can't insert, just return. ;
      END;
    END;

  return( true );		! Can't get to here unless no conflicts. ;

END "NoConflicts";


! ----------------------------------------------------------------------;
!		MAIN of GetOptions. 					;
! ----------------------------------------------------------------------;

! See if GetOptions was called from MODIFY rather than INSERT. ;
if not CalledFromMODIFY then	! GetOptions must have been called from INSERT;
  BEGIN "load defaults"		! so set parameters with standard defaults. ;
	string Extension;

  if not( InQue land que$Open )		! is the queue open already? ;
   then if not( OpnQue ) then		! read defaults from queue ;
	 BEGIN
	    print( "Job queue cannot be accessed at this time."& crlf &
		   "Please contact your system support organization."& crlf );
	    return( false );
	 END;

  Current[ E!Label ]_ 0;
  Current[ E!TRULim ]_ QQ( TRULim );	! Code to produce ILL MEM REF message.;
  Current[ E!LogLim ]_ QQ( LogLim );
  Current[ E!Action ]_ QQ( Action );

  ! See if specified command file name implies RUN YES (i.e. .SAV, .HGH, etc.);
  Extension_ cv6Str( Current[ E!CmdFile+F!Ext ] );
  if Vail( RunExts, Extension ) then
    DPB( 1, PPRunf( Current ) );		   ! Yes, so set RUN YES. ;

  if Current[ E!LogFile + F!User ] = 0 then 	   ! No log file specified,   ;
    BEGIN
    if LPPRunF( Current ) then			   ! if run-bit set then;
      DPB( 1, PPDetF( Current ) );		   !   run detach;
    DPB( JL$None, PPLog( Current ) );		   !  so default must be none.;
    END
  else						   ! else		;
    DPB( JL$Supersede, PPLog( Current ) );	   ! Ask Carl. ;

  END "load defaults";

  ! Macro for checking validity of parameters supplied with a valid option. ;
  Define SetOpVal( OpNum, OpVal ) = {
  if ( 0 > OpNum_ FndKey( OpStr_ LopWrd( Reply ), OpVal ) ) then
    BEGIN
    print( OpStr," IS NOT A VALID PARAMETER FOR ",options[OptNum]," OPTION.", crlf );
    OpNum_ 0;
    END
  };

  ! Only re-insert rec pulled from queue for modify if it is changed. ;
  GB!Change_ false;			

  ! Display options prompt then evaluate response, inserting in rec if OK;
  while true do
    BEGIN "ask for options"
	string OpStr;

    print( "OPTIONS[Insert]: " );	     ! Get option and param.;
    Reply_ inchwl;

    if !skip! = #EOT then			! ^D gives QM lic. ;
      BEGIN "set lic"
      JobLic_ JobLic xor LC!!QM;
      continue;					! re-prompt after ^D. ;
      END "set lic"
    else
      if !skip! = #SUB then			! ^Z force immediate exit.;
	AUS
      else					! else if user wants to insert;
        if ( length( Reply ) = 0 ) then		! then <cr>(only) typed. ;
          if NoConflicts then			! If no conflicting parameter ;
            done				!  settings then leave loop ;
          else					!  to insert ;
	    BEGIN				! else conflicts were not ;
	    print( "CANNOT INSERT",crlf,#lf );	!  resolved so complain and;
            continue;				!  back to OPTIONS prompt. ;
	    END;

    FirstWord_ LopWrd( Reply );			     ! Get first word. ;
    Param_ reply;				     ! Save the rest. ;

    OptNum_ Vik( Options, FirstWord ) ;
    if OptNum neq -1 and not CryForHelp( FirstWord ) then
      GB!Change_ true;			! Valid and not HELP so assume change.;

    case OptNum  of 				 ! 1st word an option? ;
      BEGIN					     
      [ 0 ]  BEGIN					! LABEL .;
	     Labl_ LopWrd( Reply )[1 for 6];	   	! 1st 6 chars only. ;
	     Current[ E!Label ]_ CvSix( Labl );	
	     END;
      [ 1 ]  BEGIN					! TIMELIMIT .;
		num_ intscan( Reply,BrkChr );		! Look for integer. ;
		if BrkChr = -1 then			! Not integer. ;
		  BEGIN					! error ;
		  print( crlf, "?",Param, "? TIMELIMIT MUST BE IN MINUTES (INTEGER). ", crlf );
		  continue;
		  END
		else
		  DPB( num, PPTimL( Current ) ) ;	! else use it. ;
             END;
      [ 2 ]  BEGIN					! TRULIMIT .;
		num_ intscan( Reply,BrkChr );		! look for integer. ;
		if BrkChr = -1 then			! If not integer ;
		  BEGIN					! error ;
		  print( crlf &"?",Param,"? Requires integer only."& crlf );
		  continue;
		  END
		else
		  Current[ E!TruLim ]_ num;		! else use it. ;
             END;
      [ 4 ]  BEGIN					! LOG ACTION .;
	     if ( Current[ E!LogFile + F!Name ] )	! must have logfile ;
	      then begin "legal to change default"
		 SetOpVal( num, ARLog );		! See if valid. ;
		 DPB( num, PPLog( Current ) );		! yes, so insert ;
	      end "legal to change default"
              else print( crlf &"?No log file, cannot set LOG option"& crlf );
             END;
      [ 5 ]  BEGIN					! LOGLIMIT .;
	     if ( Current[ E!LogFile + F!Name ] )	! must have logfile ;
	      then begin "legal to change default"
		num_ intscan( Reply,BrkChr );		! Look for integer. ;
		if BrkChr = -1 then			! Not found. ;
		  BEGIN					! So complain. ;
		  print( crlf, "?",Param, "? LOGLIMIT must be in minutes."& crlf );
		  continue;
		  END
		else
		  DPB( num, PPLogL( Current ) ) ;	! So use it. ;
	      end "legal to change default"
              else print( crlf &"?No log file, cannot set LOGLIMIT option"& crlf );
             END;
      [ 6 ]  BEGIN					! DISPOSE .;
             SetOpVal( Num, ARDisp );
	     DPB( Num, PPDisp( Current ) );
	     END;
      [ 7 ]  BEGIN					! MAILER .;
!             SetOpVal( Num, ARMailer );
!	     DPB( Num, PPMprg( Current ) );
	     END;
      [ 8 ]  BEGIN					! SPOOL .;
!	     SetOpVal( Num, ARSpl );
!	     DPB( Num, PPSpl( Current ) );
	     END;
      [ 9 ]  BEGIN					! MAIL .;
             SetOpVal( Num, ARMail );
	     DPB( Num, PPMail( Current ) );
	     END;
      [ 10 ]  BEGIN					! RESTART .;
             SetOpVal( Num, ARRestart );
	     DPB( Num, PPRestart( Current ) );
	     END;
      [ 11 ]  BEGIN					! UNIQUE .;
             SetOpVal( Num, ARUniq );
	     DPB( Num, PPUniq( Current ) );
	     END;
      [ 12 ] BEGIN					! PARAMETERS .;
		Parameters_ Reply;	! Everything past the word PARAMETERS.;
		If ( length( Parameters ) > E!ParLength ) then ! Too long. ;
		  print( "PARAMETERS MUST BE 1-",E!ParLength,
			 " CHARACTERS LONG", crlf )
		else
                  BEGIN "insert parameters"
                  BP_ Point( 7, Current[ E!Parameters ], -1 );
                  For BPI_ 1 upto E!ParLength do 
                    IDPB( lop( Parameters ), BP );
                  END "insert parameters";
              END;
      [ 13 ]  [ 14 ] 
             BEGIN					! HELP - ? .;
	     if Kequ( Param, null ) then	! Was HELP by itself? ;
	       OptionsMenu			! Yes, so show whole help. ;
	     else				! else HELP was followed by ;
	       Helper( Param );			!   an option-name so show;
	     END;				!   HELP for that option only.;
      [ 15 ] Return( false );				! ABORT .;
      [ 16 ] BEGIN					! RUN .;
	     OpStr_ LopWrd( Reply );			! Get the rest. ;
	     if kequ( OpStr, null ) then		! No param means 'yes';
	       DPB( 1, PPRunf( Current ) )		! Set RUN YES. ;
	     else
	       BEGIN "Param supplied"
	       num_ Vik( NoYes, OpStr );	! See if YES or NO. ;
	       if OptNum = -1 then		! Not YES or NO so error. ;
	         BEGIN "complain"
	         print( OpStr," IS NOT A VALID PARAMETER FOR " );
	         print( options[OptNum]," OPTION.", crlf );
	         END "complain"
	       else
	         DPB( num, PPRunf( Current ) ) ; ! OK so insert. ;
	       END "Param supplied";

	     if LPPRunf( Current ) = 0 then		! If RUN is NO; 
	       BEGIN "detach should not be yes"
	       if LPPDetf( Current ) then		! and DETACH is YES ;
	         BEGIN "resolve the conflict"		! fix. ;
		 reply_ prompt( "CHANGE DETACH TO 'NO' [y] " );
		 num_ Vik( NoYes, reply ); 	! If YES response or <cr> then;
		 if num = 1 or length( reply ) = 0 then	! set DETACH to NO. ;
		   DPB( 0, PPDetf( Current ) ) ;	! else leave for now. ;
		 END "resolve the conflict";
	       END "detach should not be yes";
	     END;
      [ 17 ] BEGIN					! DETACH .;
	     if not( Current[ E!LogFile+F!Name ] )	! Cannot have LOGFILE;
	      then begin "ok to detach"
		 OpStr_ LopWrd( Reply );		! Get supplied param. ;
		 if kequ( OpStr, null ) then		! No param means 'yes';
		   DPB( 1, PPDetf( Current ) )		!   so load YES. ;
		 else
		   BEGIN "validate the param"
		   num_ Vik( NoYes, OpStr );		! YES or NO? ;
		   if OptNum = -1 then			! Something else so ;
		     BEGIN				!   error.;
		     print( OpStr," IS NOT A VALID PARAMETER FOR " );
		     print( options[OptNum]," OPTION.", crlf );
		     END
		       else
		     DPB( num, PPDetf( Current ) ) ;	! else use it. ;
		   END "validate the param";

		 if LPPDetf( Current ) then		! If DETACH = YES ;
		   BEGIN
		   if LPPRunf( Current ) = 0 then	! and RUN = NO ;
		     BEGIN				! Ask user. ;
		     reply_ prompt( "CHANGE 'RUN' TO 'YES' [y] " );
		     num_ Vik( NoYes, reply );		! YES/NO? ;
		     if num = 1 or length( reply ) = 0 then ! If YES of <cr> then ;
		       DPB( 1, PPRunf( Current ) ) ;	! change RUN to YES. ;
		     END;
		   END;
	      end "ok to detach"
	      else print( crlf &"?Cannot detach if writing a log file"& crlf );
	     END;
      [ 18 ] BEGIN					! HALT .;
             OpStr_ LopWrd( Reply );		! Get next word from reply;
	     if kequ( OpStr, null ) then		! No param means 'yes';
	       DPB( 0, PPHaltf( Current ) )		! So HALT = YES. ;
	     else
	       BEGIN
	       num_ Vik( YesNo, OpStr );
	       if OptNum = -1 then
	         BEGIN
	         print( OpStr," IS NOT A VALID PARAMETER FOR " );
	         print( options[OptNum]," OPTION.", crlf );
	         END
	       else
	         DPB( num, PPHaltf( Current ) ) ;
	       END;
	     END;
      [ 19 ] BEGIN					! CTYLOG .;
             OpStr_ LopWrd( Reply );		! Get next word from reply. ;
             if JobLic land LC!!QM then		! Check for QM license. ;
	       BEGIN "enough lic"		! OK so validate response. ;
	       if kequ( OpStr, null ) then		! No param means 'yes';
	         DPB( 1, PPCtyf( Current ) ) 	! so CTY gets YES. ;
	       else
	         BEGIN "check the param"
	         num_ Vik( NoYes, OpStr );	! YES/NO? ;
	         if OptNum = -1 then		! no, so error. ;
	           BEGIN "bitch bitch bitch"
	           print( OpStr," IS NOT A VALID PARAMETER FOR " );
	           print( options[OptNum]," OPTION.", crlf );
	           END "bitch bitch bitch"
	         else
	           DPB( num, PPCtyf( Current ) ) ; ! Make CTY = YES.;
                 END "check the param";
	       END "enough lic"
	     else
	       print( crlf, "? Requires QM", crlf,#lf );	! No QM. ;
	     END;
      [ 20 ] BEGIN					! PRIORITY .;
		num_ intscan( Reply,BrkChr );		! Get rest of reply. ;
		if BrkChr = -1 then			! Should be integer. ;
		  BEGIN "missing integer"
		  print( crlf, "?",Param,"? Requires integer only.", crlf );
		  continue;
		  END "missing integer"
		else
		  BEGIN "see if priority is OK"
	          if not JobLic land LC!!QM then		! If not QM lic ;
		    ! See if priority is within valid range for non-QM. ;
		    if not( JP$Min leq num leq (JP$Sys-1) ) then
			print( crlf,"PRIORITY MUST BE BETWEEN ",
			 JP$Min," AND ", JP$Sys-1,".", crlf )
		    else			 	! else it's within ;
		      DPB( num, PPJPri( Current ) )	!  range so use it. ;
                  else
		    ! See if priority is within valid range for those with QM.;
		    if not( JP$Min leq num leq JP$Max ) then
			print( crlf,"PRIORITY MUST BE BETWEEN ",
			 JP$Min," AND ", JP$Max,".", crlf )
		    else				! else it's within ;
		      DPB( num, PPJPri( Current ) ) ;	!  range so use it. ;
		  END "see if priority is OK";
             END;
      [ 21 ] BEGIN					! CCL .;
             OpStr_ LopWrd( Reply );
	     if kequ( OpStr, null ) then		! No param means 'yes';
	       DPB( 1, PPCCLf( Current ) ) 
	     else
	       BEGIN
	       num_ Vik( NoYes, OpStr );		! Validate the param. ;
	       if OptNum = -1 then			! -1 means invalid. ;
	         BEGIN "boo boo"
	         print( OpStr," IS NOT A VALID PARAMETER FOR " );
	         print( options[OptNum]," OPTION.", crlf );
	         END "boo boo"
	       else
	         DPB( num, PPCCLf( Current ) ) ;	! OK, so use it. ;
               END;
	     END;
      [ 22 ] BEGIN					! TMPNAME. ;
             OpStr_ LopWrd( Reply );
	     if kequ( OpStr, null ) then		! No param means 'yes';
		continue
	     else
	       BEGIN
	       if length( OpStr ) neq 3 then		! Max = 3 chars. ;
	         BEGIN
	         print( OpStr," IS NOT A VALID PARAMETER FOR " );
	         print( options[OptNum]," - MUST BE  3 CHARACTERS", crlf );
	         END
	       else
                 DPB( CvSix( OpStr ) lsh - 18, PPTMPF( Current ) ) ;
 	       END;
 	     END;
      [ 23 ] BEGIN					! New LOGFILE. ;
	     continue;				! *** No longer allowed *** ;
             OpStr_ LopWrd( Reply );	  ! OpStr will be new log file name. ;
	     if kequ( OpStr, null ) then	! Nothing supplied after ;
	       BEGIN "get rid of log file"	!   LOGFILE = remove logfile. ;
	       LoadFileName( Current, null, E!LogFile ); ! So load with null.;
	       print( "Log-File designation removed.",crlf ); ! Break the news;
	       END "get rid of log file"
	     else					! else user wants a ;
	       BEGIN "New log file"			!   log file. ;
	       if EqSign( OpStr, ComFile ) then		! Str=Str format?;
	         BEGIN "new command file"		! Yes, so insert the;
		 if ComIsOK( ComFile ) then		!  command file part ;
		   BEGIN "insert Ctl file name"		!  if it is valid.;
		   LoadFileName( Current,ComFile,E!CmdFile );
		   print( "Command file name changed.",crlf );
		   END "insert Ctl file name"
		 else				     ! Ctl file part was bad. ;
		   print( " ?New command file name was not understood.",crlf );
		 END "new command file";

	       LogFile_ OpStr;	   ! Do logfile part regardless of the above. ;
      	       if CheckLog( LogFile ) then 		! Log file valid? ;
		 BEGIN "insert LogFile"			! Yes so insert. ;
		 LoadFileName( Current, LogFile, E!LogFile );
		 print( "Log-File name changed."& crlf );
		 END "insert LogFile"
	       else		! Bogus log file so complain and forget it. ;
		 print( " ?New Log-File name was not understood."& crlf );
	         
	       END "New log file";
           END;
      [ 24 ] BEGIN					! License ;
	     WantLic_ LicRd( Reply );			!  if specified ;
	     if not( WantLic )				! must want it ;
	      then WantLic_ !rh( JobLic );
	     GetOpr( Current[ E!OperName ], OperName_ null );
	     if ( LicChk( HaveLic_ GetLic( Current[ E!OperName ], Num_ 0 ),
			  WantLic ) )
	      then Current[ E!License ]_ LicVal( HaveLic, WantLic )
	      else print( " ?No license set for Job."& crlf );
	     END;
      [ 25 ] BEGIN					! Date Expression;
             GS!Params_ Param;		! Expression may be on same line as DATES command.;
             GetExpFromUser( false );	! User give date expression .;
             END;
      [ 26 ] BEGIN					! Express ;
             Express;
             END;
      [ 27 ] BEGIN					! DISPLAY ;
             Display;
	     Inchwl;		! Must clear else stray #lf will cause insert;
             END;
      [ 28 ] BEGIN					! TEST ;
             Test;
	     Inchwl;		! Must clear else stray #lf will cause insert;
             END;
      else BEGIN		! Option specified was unknown. ;
           if length( GS!Err ) = 0 then		! If nothing in error string. ;
             print( "UNRECOGNIZED OPTION - TYPE 'HELP' FOR HELP", crlf )
           else
	     BEGIN "display error string"
	     print( GS!Err, crlf );
	     GS!Err_ null;
	     END "display error string";
	   END

      END ! case ;

    END "ask for options";

  return( true );
END "getoptions";


simple boolean procedure MakeRecord( integer DatNext );
! ----------------------------------------------------------------------;
!									;
! 		ConStructs the 24 word header ( positions 0 - 23 ).	;
!		Prompts for command file name and log file name.	;
!		Prompts for "OPTIONS".					;
!		Returns "TRUE" if all of the above are obtained.	;
!		Returns false if <cr> is typed at command file prompt.  ;
!									;
! ----------------------------------------------------------------------;
BEGIN "MakeRecord"
  string  ComFile,LogFile;

  Current[ E!RunTime ]_      DatNext;
  Current[ E!PPN ]_          JobPPN;      
  Current[ E!Privs ]_        JobPrv;    
  Current[ E!AUN ]_          JobAUN;  
  Current[ E!Username ]_     Gettab( -1,!GTUNM );
  Current[ E!username + 1 ]_ Gettab( -1,!GTUN1 );
  Current[ E!License ]_ 0;		! set license in options section ;
  calli( !xwd( 0, location( Current[ E!Project ] ) ), calli!chprj );
  Current[ E!Network ]_ !xwd( 1, location( Current[ E!Network ] ) );

  start!code
    define !forfa = '36;
    hrloi	1,!forfa;
    uuo!FRMOP 1,Current[ E!Network ];
    setzm Current[ E!Network ];
    END;

  while true do
    BEGIN "Get command file"
    if length( GS!Params ) = 0 then 			! Must prompt for it. ;
      GS!Params_ Prompt( "Name of command file: " );

    if !skip! = 13 and length( GS!Params ) = 0 then
      BEGIN
      print( crlf,"INSERT ABORTED",crlf );
      return( false );
      END
    else
      if CryForHelp( GS!Params ) then 			! Help requested. ;
	BEGIN
        print( ComFilHelp );		! So do help then try again. ;
	GS!Params_ null;		! clear string ;
	END
      else
        BEGIN 
        ComFile_ GS!Params;
        if EqSign( GS!Params, ComFile ) then	! If there is a '=' then ;
          LogFile_ GS!Params
        else
	  BEGIN
	  ComFile_ LopWrd( GS!Params );
	  LogFile_ LopWrd( GS!Params );
	  END;

        if NOT ComIsOK( ComFile ) then
          continue
        else
	  BEGIN "load and exit"
          ! Stick the file name into the array at position based on 3rd parameter. ;
          LoadFileName( Current,ComFile,E!CmdFile );
	  done;
	  END "load and exit";
	END;

    END "Get command file";

  while true do
    BEGIN "Get log file name"
    if length( LogFile ) = 0 then 		! Furnished on command line? ;
      BEGIN "prompt for log file"		! No, so prompt for it. ;
      LogFile_ Prompt( "Name of log file: " );
      if !skip! = 13 and length( LogFile ) = 0 then
        done
      else
        if CheckLog( LogFile ) then		! If OK LogFile - done. ;
          done;
      END "prompt for log file"
    else					! Yes, so check it. ;
      if CheckLog( LogFile ) then
        done;
    print( crlf,"Cannot create log file: ", LogFile, "." );
    LogFile_ null; ! clear before next try;
    END "Get log file name";

  ! Stick the file name into the array at position based on 3rd parameter. ;
  if not equ( LogFile, null ) then
    LoadFileName( Current,LogFile,E!LogFile );

  return( true );

END "MakeRecord";


simple integer procedure RunLocal( integer date );
return( CvtDTM( date, LDB( point( 6,JobPrv,7 ) ), '20 ) );


simple string procedure LocalRun( integer array QRec; reference boolean late );
! ----------------------------------------------------------------------;
!									;
!	LocalRun simply gets the next-run date/time from the record.	;
!	Returns date/time as a string in users local time zone.		;
!									;
! ----------------------------------------------------------------------;
BEGIN "LocalRun"
    integer UserLocalTime;

  late_ false;				! initially on-time ;

  if ( LPPStat( QRec ) = ST$Proc )	! See if the job is active ;
   then return( "--Active--" );		!  Yes, it is in progress ;

 if ( Qrec[ E!RunTime ] = -1 )		! See if the job is at 'startup';
   then return( "--Startup--" );	!  Yes, so let them know ;

  late_ ( QRec[ E!Runtime ] < GetTDT );	! run time past? ;

  UserLocalTime_ RunLocal( QRec[ E!Runtime ] );

  if UserLocalTime = 0 then		! No run Date/Time for some reason;
    return( "--Unknown--" );		! So assume that job is about to ;

  return( TymDay( UserLocalTime ) );	! return what we calculated.;

END "LocalRun";


simple procedure DisplayARec( integer array QRec );
! ----------------------------------------------------------------------;
!									;
!		Displays info for a job pulled from queue.		;
!									;
! ----------------------------------------------------------------------;
BEGIN "show one record"
	integer BP,		! Byte pointer. ;
		BPI,		! Byte pointer index. ;
		ch,		! One character. ;
		num;		! Gets all kinds of things. ;
	string  parameters,	! For assembling PARAMETERS string. ;
		temp;		! ;
	boolean late,		! Becomes true if next run is in the past. ;
		NewLineYet;

  print( crlf &"JOB: ",Cvxstr( QRec[ E!CmdFile + F!Name ] ) );	! JOB NAME ;
  print( "  ", InfJob( location( QRec[ E!Runtime ] ) ) );	! Request  ;


  print( Crlf &"Username: ",			        	! USERNAME ;
	 cv6str( QRec[ E!Username ] ), cv6str( QRec[ E!Username+1 ] ),
	 (if ( QRec[ E!AUN ] neq QRec[ E!PPN ] )	! GFD if different ;
	   then " ("& CvName( QRec[ E!PPN ] ) &")"
	   else null)  );
  if ( num_ QRec[ E!Network ] )					! NETWORK ;
   then print( "  Node:",
	cvos( (ldb( point(8,num,19) ) lsh 6) + ldb( point(6,num,27) ) ),
	(if ( num land '177 ) then "-"&cvos( num land '177 ) else null),
	" TID=", (case ldb( point(5,num,11) ) of (
		    "Aux", "A", "C", "E", "G", "B", "F", "J", "N", "<cr>",
		    "D", "I", "1200", "B1200", "Gateway-Aux", "Baudot",
		    "2400", "3270", "3270P", "4800", "9600", "M-PVC", "Audio",
		    "Video", "30","31","32","33","34","35","36","37" ) )
	);
  if ( QRec[ E!Project ] ) then					! PROJECT ;
    print( "  Project:",CvStr( QRec[ E!Project ] ),
			CvStr( QRec[ E!Project + 1 ] ),
			CvStr( QRec[ E!Project + 2 ] ) );


  print( crlf &"Limits:   Time:",				! TIMELIMIT ;
	 (if ( num_ LPPTimL( QRec ) )
	   then CvsTim( ( num lsh 18 ) DIV 1440 )
	   else "no limit" )
       );
  print( "  TRU:", (if ( num_ QRec[ E!TruLim ] )		! TRU LIMIT ;
		    then cvs(num) else "no limit" ) );
  if ( num_ LPPLogL( QRec ) )					! LOG LIMIT ;
   then print( "  LogSize:", num );
  print( "  Pri:", cvs( LPPJPri( QRec ) ) );			! PRIORITY ;

  if ( length( temp_ Cv6Str( LPPTMPF( QRec ) lsh 18 ) ) )	! TMPNAME ;
   then print( "   Temp file:", temp );


  print( Crlf &"Options:  "&		! ** this line is 80 chars max ** ;
	"Log:",       ARLog[ num_ LPPLog( QRec ) ],		! LOG ;
	(if ( num )	! num = log option ;
	  then " Dispose:"& ARDisp[ LPPDisp( QRec ) ]		! DISPOSE ;
	  else null ),
!	" Spool:",   ARSpl[ LPPSpl( QRec ) ],			! SPOOL ;
	" Mail:",    ARMail[ LPPMail( QRec ) ],			! MAIL ;
!	" Mailer:",  ARMailer[ LPPMPrg( QRec ) ],		! MAILER ;
	" Restart:", ARRestart[ LPPRestart( QRec ) ],		! RESTART ;
	" Unique:",  ARUniq[ LPPUniq( QRec ) ]			! UNIQUE ;
	);

  temp_ null;
  if ( LPPRunf( QRec ) )					! RUN ;
   then temp_ temp & "Run  ";
  if ( LPPDetf( QRec ) )					! DETACH ;
   then temp_ temp & "Detach  ";
  if ( LPPCCLF( QRec ) )					! CCL ; 
   then temp_ temp & "CCL  ";
  if ( LPPHaltf( QRec ) )					! NO HALT ; 
   then temp_ temp & "No Halt  ";
  if ( LPPCtyF( QRec ) )					! CTYLOG ;
   then temp_ temp & "CTYLog  ";
  if ( length( temp ) )
   then print( crlf &"Flags:    ", temp );


  ! License if there is any ;
  if ( num_ !rh( QRec[ E!License ] ) )				! LICENSE ;
   then print( crlf&"License:  ",  LicPrt( num ) );


  Parameters_ null;						! PARAMETERS ;
  BP_ Point( 7, QRec[ E!Parameters ], -1 );
  For BPI_ 1 upto E!ParLength do 			! Assemble parameter ;
    If ( Ch_ Ildb( BP ) ) then				!   string. ;
      Parameters_ Parameters & Ch;
  if ( length( Parameters ) ) then			! If there were ;
    print( crlf &"Param(s): ", Parameters );		!  print any params. ;

  print( crlf &"Period:   ");					! EXPRESSION ;
  if ( 0 = LDB( PConn( QRec[ E!Descriptor + D!Type ] ) ) )
   then print( " IMMEDIATELY. "& crlf )		! No expression on INSERT ;
   else Express;				!  else give description ;

  print( "Run date: ", LocalRun( QRec,late ) );			! NEXT DATE ;
  print( if ( late ) then " * " else "   " );
  print( ("        "&SStat[num_ LPPStat(QRec)])[inf-12 to inf],	! STATUS   ;
	 "-", (SSStat[ LPPProc( QRec )+Stat[num] ]&"      ")[1 for 9] );


  if ( QRec[ E!Rantime ] )
   then print( crlf& "Last run: ", TymDay( RunLocal( QRec[ E!Rantime ] ) ) );

  print( crlf );				! final end of line ;

END "show one record";


simple procedure IdentifyTheJob( reference string JobName;
	 	          reference integer ReqNum );
! ----------------------------------------------------------------------;
!									;
! 		First see if job name and/or request number was	;
! 		  furnished in command line.  If so then get them.	;
! 		else							;
! 		  Prompt for Job name and request number. 		;
!									;
! ----------------------------------------------------------------------;
BEGIN "get job and req"
	integer BrkChr;
	string resp, ReqStr, junk;

  JobName_ null;
  ReqNum_ 0;

  if kequ( GS!Params,null ) then	! Nothing given with "MODIFY" ;
    resp_ prompt( "JOB NAME: " )	! So get it now ;
  else
    resp_ GS!Params;			! else use rest of command line;

  JobName_ LopWrd( resp );		! Get first word;
  ReqStr_ LopWrd( resp );		! look for request #;

  while true do
    BEGIN "request loop"

    if kequ( ReqStr, null ) then 	! If we don't have it yet. ;
      ReqStr_ prompt( "REQUEST NUMBER: " );	! Then get it. ;

    if kequ( ReqStr, null ) then 	! User types <cr> only so ;
      BEGIN				!   return zero as request number. ;
      ReqNum_ 0;
      return;
      END
    else				! else see if it is an integer. ;
      if not ValNum( ReqStr ) then
        BEGIN "invalid request number"	! If not integer then loop again. ;
        print( crlf,"BAD REQUEST NUMBER: ",ReqStr, " (MUST BE AN INTEGER)." );
        ReqStr_ null;
        END "invalid request number"
      else
        BEGIN "OK so far"
        ReqNum_ cvd( ReqStr );		! Change string into integer. ;
        done;
        END "OK so far";
      END "request loop";

END "get job and req";



simple procedure QueErr( string Msg );
! ----------------------------------------------------------------------;
!									;
! 		Print the message passed. 				;
!		also print additional explanation based on value in 'QError.  ;
!									;
! ----------------------------------------------------------------------;
BEGIN "QueErr"
  print( Msg );						! Print error message.;
  case QError of					! Look at QError.;
    BEGIN					! Most cases are covered. ;
    [ err$COQ ]  Print( " (Cannot open queue)" );
!   [ err$ILL ]  Print( " (Illegal license)" );
    [ err$CMS ]  Print( " (Cannot map status page)" );
    [ err$CMA ]  Print( " (Cannot map area)" );
    [ err$CMR ]  Print( " (Cannot map job record)" );
    [ err$CFR ]  Print( " (Cannot find job record)" );
    [ err$MRM ]  Print( " (Modify job record mismatch)" );
    else	 print( " (Source unknown: ",QError,")" ) 
    END;
  print( crlf );
END "QueErr";


simple procedure Insert;
! ----------------------------------------------------------------------;
!									;
! 	Insert record into queue, being assigned a req# by ModRec.	;
!									;
! ----------------------------------------------------------------------;
BEGIN "Insert"
	integer NextD,tod,ReqNum;
	string  JobName;

  ReqNum_ LPPReq( Current );		! get request number ;

  if ReqNum = 0 or ReqNum land !bit( 18 ) then  ! Must be a new entry;
    BEGIN "New job"
    tod_ GetTDT;			! Get current Date/time. ;

    ! Get next run Date/time. ;
    if GetConn = 0 then
      NextD_ tod			! Immediate run (now). ;
    else
      NextD_ NexTim( Current[0],tod );	! Future. ;

    ! Get command file/log file names and options. ;
    if not MakeRecord( NextD ) then	! MakeRecord will return true unless ;
      return;				!   user types <cr> (only) at prompt ;
					!   for command file name. ;

    ! Now prompt for options. ;
    if not GetOptions( false ) then	! GetOptions will return true unless ;
      return;				!   user types "ABORT" at OPTIONS ;
					!   prompt. ;

    END "New job"
  else					! Request number in the rec was not ;
					!   zero so we must be re-inserting a ;
					!   modified job. ;
    print( "MODIFIED " ); 		! So start message with 'MODIFIED' ;

  JobName_ Cvxstr( Current[ E!CmdFile + F!Name ] );
  JobName_ Trim( JobName );				! Get rid of spaces ;
  print( "JOB """, JobName, """ " ); ! Message. ;

  ! Try to insert. ;
  if ModRec( Current[ E!Runtime ], CopyForModRec[ E!Runtime ] ) then
    BEGIN "OK insertion"			! insert the new entry. ;
    print("INSERTED.  Req# ",LPPReq(Current));	! Tail end of the message. ;
    ArrClr( Current );				! Clear the arrays. ;
    ArrClr( CopyForModRec );
    END "OK insertion"
  else
    QueErr( " COULD NOT BE INSERTED." ); 	! ModRec failed. ;

  print( crlf );  

END "Insert";


simple procedure SetJobNam( string JobName );
! ----------------------------------------------------------------------;
!									;
! 		Clear current and insert command file name only. 	;
!									;
! ----------------------------------------------------------------------;
BEGIN "SetJobNam"
  ArrClr( Current );
  if not kequ( JobName, null ) then			! If no job name then;
    Current[ E!CmdFile + F!Name ]_ cvsix( JobName[ 1 for 6 ] ); ! don't bother;
END "SetJobNam";

simple procedure Prepare( integer array A ); 
! ----------------------------------------------------------------------;
!									;
! 		Clear "A", Reset, insert:       			;
!			- nothing, if user has QM license.		;
!			- left half of AUN if user is acct. sup.	;
!			- else whole AUN.				;
!									;
! ----------------------------------------------------------------------;
BEGIN "Prepare"
  ArrClr( A );
  dpb( '777777, PPReq( A ) ); 		! Set req# to -1 so it starts at top;
  if not JobLic land LC!!QM then	! If not QM then. ;
    BEGIN "Not QM"
    if JobPrv land JP!ASV then		!  See if Acct supervisor. ;
      BEGIN "Acct Supervisor"
      A[ E!AUN ]_ JobAUN land lnot '777777;
      END "Acct Supervisor"
    else				! Since not QM and not Acct sup;
      BEGIN "Vanilla"			!   grant minimun rights. ;
      A[ E!AUN ]_ JobAUN;
      END "Vanilla";
    END "Not QM";
					! Nothing in E!AUN indicates QM. ;
END "Prepare";

simple boolean procedure MisMatch( string JobName; integer ReqN );
! ----------------------------------------------------------------------;
!									;
!	If job with furnished request number is found and a job name	;
!	   was also furnished, then the job name furnished must be the 	;
!	   same as that in the record pulled from the queue.		;
!									;
! ----------------------------------------------------------------------;
BEGIN "Match"
  if not kequ( JobName,null ) then  		! was Job name rec'd? ;
    BEGIN "have JobName"
    if Current[ E!CmdFile + F!Name ] neq cvsix( JobName[ 1 for 6 ] ) then
      BEGIN "Not matched"
      print( crlf,"REQUEST NUMBER ", ReqN," DOES NOT MATCH " );
      print( "JOB: ",JobName,crlf );
      return( true );
      END "Not matched";

    END "have JobName";

  print( crlf );	! If there was no jobname then there cannot be ;
  return( false );	!   a mismatch. ;

END "Match";


simple procedure Message( string Vanilla,
				 AcctSup,
				 QMLic
			);
! ----------------------------------------------------------------------;
!									;
!		Print message depending on license.			;
!									;
! ----------------------------------------------------------------------;
BEGIN "message"

  if JobLic land LC!!QM then		! User has QM ;
    QueErr( QMLic )			!   so print his message.;
  else
    if JobPrv land JP!ASV then		! User has Acct Sup License. ;
      print( AcctSup )
    else				! else no license. ;
      print( Vanilla );

END "message";


simple boolean procedure RealRec( reference integer rec );
! ----------------------------------------------------------------------;
!									;
!									;
! ----------------------------------------------------------------------;
BEGIN "RealRec"
	boolean b;
  InQue_ InQue lor Que$Real;
  b_ GetRec( rec );
  InQue_ InQue land lnot Que$Real;
  return( b );
END "RealRec";


simple procedure ModJob( boolean OKtoModify );
! ----------------------------------------------------------------------;
!									;
!		Get a rec from job list then call GetOptions to query	;
!		  so user can modify the job.				;
!		If user furnishes only a job name then, in turn, 	;
!		  ModJob will return each job of that name for modification.  ;
!		If user furnishes only a request number, then ModJobs	;
!		  will return that rec only for modification.		;
!		If the user enters a Job name and a request number then;
!		  ModJob will seek a rec from the queue which has	;
!		  has both, error if not found. 			;
!		All modifications to the rec are done at OPTIONS prompt.;
!		Modifications are allowed only if OKtoModify is true. 	;
!		OKtoModify is false if this routine was called from	;
!		  SHOW, in which case we display the rec but do not	;
!		  allow any changes. 					;
!									;
! ----------------------------------------------------------------------;
BEGIN "ModJob"
	integer ReqNum;	
	string  JobName;

  ! Clear the array being passed, set the request number to -1, and set the ;
  !   AUN according to the users privilege level. ;
  Prepare( Current );

  ! See if the job name and/or request number were furnished along with the ;
  !   SUBMIT command.  If they were not then prompt for them and return what ;
  !   user types or null if the user answers the prompts with <cr> only. ;
  IdentifyTheJob( JobName, ReqNum );		! Ask the user. ;

  if ReqNum > 0 then				! request # received ;
    BEGIN "One Record only"
    Dpb( ReqNum, PPReq( Current ) ); 		! put req# into array ;

    if RealRec( Current[ E!Runtime ] ) then	! Get Rec of req #. ;
      BEGIN "GetRec success"			! Found it. ;

      if ( LPPstat( Current ) = ST$Cancel )	! But it's cancelled. ;
       then return;				! So complain and return. ;

      if MisMatch( JobName, ReqNum ) then	! If job name was supplied by ;
        return;					!   then it had better match ;
						!   that of the rec we obtained;
						!   from the queue. ;

      ! Save for ModRec in CopyForModRec. ;
      arrblt( CopyForModRec[ E!Runtime ], Current[ E!Runtime ], E!Length );

      DisplayARec( Current );			! Now display the record. ;

      if OKtoModify then		! This is a mod operation so ;
        BEGIN "modifying"
        print( crlf );
        if GetOptions( true ) then	! User modifies at OPTIONS prompt. ;
	  BEGIN
	  if GB!Change then		! Anything changed? ;
	    BEGIN "probably changed"	! Yes, so re-insert. ;
            ReqNum_ LPPReq( Current );
            print( crlf,"REPLACING REQUEST = ",ReqNum,"..." );
            Insert;
	    END "probably changed";
	  END
	else
          print( crlf,"MODIFY ABORTED." );

        END "modifying";

      ArrClr( Current );

      END "GetRec success"
    else
      BEGIN "complain"			! GetRec could not find that req. ;
      Message( crlf&"COULD NOT FIND THIS JOB WITH YOUR USER-NAME. "&crlf,
     	       crlf&"COULD NOT FIND THIS JOB."&crlf,
  	       crlf&"JOB NOT IN QUEUE. " );
      END "complain";

    END "One Record only"
  else
    BEGIN "Mod all with same name"

    ! Stick the file name into the array at position based on 3rd parameter. ;
    if not kequ( JobName, null ) then 		! was JobName furnished? ;
      LoadFileName( Current,JobName,E!CmdFile );	! then insert it. ;

    ! Get each job with same jobname: 'JobName'. ;
    while RealRec( Current[ E!Runtime ] ) do !  rest of recs with this JobName;
      BEGIN "Get each"
      ! Save for ModRec in CopyForModRec. ;
      arrblt( CopyForModRec[ E!Runtime ], Current[ E!Runtime ], E!Length );

      ReqNum_ LPPReq( Current );		! Get req of latest job. ;
    
!      print( crlf,#lf,"NEXT JOB =",ReqNum," " );	! Display it. ;

      DisplayARec( Current );       		! Display the job info. ;

      if OKtoModify then
        BEGIN "modifying"

        print( crlf );
        if GetOptions( true ) then
          BEGIN "Replace if modified"
          if GB!Change then
            BEGIN "probably changed"
            ReqNum_ LPPReq( Current );
            print( crlf,"REPLACED (MODIFIED)" );
            Insert;
            END "probably changed";
          END "Replace if modified"

        else
          BEGIN "Do not ReInsert"
          print( crlf,"REPLACED (NOT MODIFIED)" );
          SetJobNam( JobName ); ! Clear "Current" and insert Ctl fil.;
!         continue;
          END "Do not ReInsert";

      END "modifying";

      SetJobNam( JobName ); ! Clear "Current" and insert Ctl fil.;

      END "Get each";

    print( crlf,#lf,"NO FURTHER JOBS." );  

  END "Mod all with same name";
END "ModJob";


simple boolean procedure CanBeDeleted( string JobName; integer ReqNum );
! ----------------------------------------------------------------------;
!									;
!		This procedure deletes a record from the queue.		;
!		This is accomplished by setting the status bit to 	;
!		  canceled and re-inserting the rec using ModRec.	;
!		Returns true if the rec was re-inserted.		;
!									;
! ----------------------------------------------------------------------;
BEGIN "CanBeDeleted"

  dpb( ST$Cancel, PPstat( Current ) ); 				! Set Cancel. ;
  if ModRec( Current[ E!Runtime ], CopyForModRec[ E!Runtime ] ) then   ! Re-insert. ;
    BEGIN "success"
    print( crlf );
    LJust( JobName, 10 );
    print( "#" );
    LJust( cvs( ReqNum ), 5 );
    return( true );
    END "success"
  else
    return( false ); 					! ModRec failed. ;

END "CanBeDeleted";


simple procedure Delete;
! ----------------------------------------------------------------------;
!									;
!		Get a rec from job list then call CanBeDeleted		;
!		  to perform the delete operation.			;
!		If user furnishes only a job name then, in turn, 	;
!		  Delete will delete EVERY job with that name.		;
!		If user furnishes only a request number, then Delete	;
!		  will delete that rec only.				;
!		If the user enters a Job name and a request number then;
!		  Delete will seek a rec from the queue which has	;
!		  has both and delete it, error if not found. 		;
!									;
! ----------------------------------------------------------------------;
BEGIN "Delete"
	integer ReqNum,		! Request number furnished. ;
		count;		! Count of how many deletions. ;
	string  JobName;	! Job name furnished. ;

  ! Clear the array being passed, set the request number to -1, and set the ;
  !   AUN according to the users privilege level. ;
  Prepare( Current );	

  ! See if the job name and/or request number were furnished along with the ;
  !   SUBMIT command.  If they were not then prompt for them and return what ;
  !   user types or null if the user answers the prompts with <cr> only. ;
  IdentifyTheJob( JobName, ReqNum );

  ! ----- "fetch then delete" is for the case where a request number ----- ;
  ! ----- has been furnished					     ----- ;
  if ReqNum > 0 then				! request # received ;
    BEGIN "fetch then delete"
    Dpb( ReqNum, PPReq( Current ) ); 		! put req# into array ;

    if RealRec( Current[ E!Runtime ] ) then	! Get job from Queue. ;
      BEGIN "perform checks"

      if LPPstat( Current ) = ST$Cancel then
        BEGIN "complain and return"
        print( "REQ# ",ReqNum," ALREADY CANCELLED.",crlf );
        return;
        END "complain and return";

      if MisMatch( JobName, ReqNum ) then	! If Jobname was furnished ;
        return;					!   then must match that of ;
						!   the rec from queue. ;

      ! Save for ModRec in CopyForModRec. ;
      arrblt( CopyForModRec[ E!Runtime ], Current[ E!Runtime ], E!Length );

        if not CanBeDeleted( JobName, ReqNum ) then	! Try to delete it. ;
          QueErr( "JOB COULD NOT BE DELETED. " )	! Failed. ;
        else
	  count_ 1;

      END "perform checks"
    else
      BEGIN "GetRec failed"		! Message depends on License. ;
      Message( crlf&"COULD NOT FIND THIS JOB WITH YOUR USER-NAME. "&crlf,
     	       crlf&"COULD NOT FIND THIS JOB."&crlf,
  	       crlf&"JOB NOT IN QUEUE. " );
      END "GetRec failed";

    END "fetch then delete"
  else
  ! ----- "Delete all with same job name" is for the case where no    ----- ;
  ! ----- request number was provided, so every job with a given name ----- ;
  ! ----- must be deleted. ;
  
    BEGIN "Delete all with same job name"
    
    count_ 0;

    ! Stick the file name into the array at position based on 3rd parameter. ;
    if not kequ( JobName, null ) then 		! was JobName furnished? ;
      LoadFileName( Current,JobName,E!CmdFile );	! If not then obtain. ;

    while RealRec( Current[ E!Runtime ] ) do !  rest of recs with this JobName;
      BEGIN "Same jobnames"

      ! Save for ModRec in CopyForModRec. ;
      arrblt( CopyForModRec[ E!Runtime ], Current[ E!Runtime ], E!Length );

      ReqNum_ LPPReq( Current ); 			! Get req #. ;

      if count = 0 then
        print( "deleting:" );

      if not CanBeDeleted( JobName, ReqNum ) then	! Try to delete it. ;
        QueErr( "JOB COULD NOT BE DELETED. " )	! ModRec failed. ;
      else 
        count_ count + 1;

      SetJobNam( JobName ); 		! Clear "Current" and insert Ctl fil.;
      END "Same jobnames";

  END "Delete all with same job name";

  print( crlf, count, " job", if count = 1 then "s" else null,
	" deleted."& crlf )

END "Delete";


simple procedure ReRun;
! ----------------------------------------------------------------------;
!									;
!	Get a rec from job list then see if it needs rerunning.		;
!	If user furnishes only a job name then, in turn, 		;
!	  Rerun will reset EVERY job with that name.			;
!	If user furnishes only a request number, then ReRun		;
!	  will reset that rec only.					;
!	If the user enters a Job name and a request number then 	;
!	  ReRun will seek a rec from the queue which has		;
!	  has both and reset it, error if not found. 			;
!									;
! ----------------------------------------------------------------------;
BEGIN "ReRun"
	integer ReqNum,		! Request number furnished. ;
		
		count;		! Count of how many deletions. ;
	string  JobName;	! Job name furnished. ;

  ! Clear the array being passed, set the request number to -1, and set the ;
  !   AUN according to the users privilege level. ;
  Prepare( Current );	

  ! See if the job name and/or request number were furnished along with the ;
  !   SUBMIT command.  If they were not then prompt for them and return what ;
  !   user types or null if the user answers the prompts with <cr> only. ;
  IdentifyTheJob( JobName, ReqNum );

  if ReqNum > 0 then				! request # received ;
    BEGIN "fetch then reset"
    Dpb( ReqNum, PPReq( Current ) ); 		! put req# into array ;

    if RealRec( Current[ E!Runtime ] ) then	! Get job from Queue. ;
      BEGIN "perform checks"

      if ( LPPstat( Current ) neq ST$Abort ) and
	 ( LPPStap( Current ) neq Queued$Crash ) and
	 ( LPPStap( Current ) neq Hold$Restart ) then
        BEGIN "complain and return"
        print( "REQ# ",ReqNum," is not in the proper state.",crlf );
        return;
        END "complain and return";

      ! Save for ModRec in CopyForModRec. ;
      arrblt( CopyForModRec[ E!Runtime ], Current[ E!Runtime ], E!Length );

      dpb( Queued$Wait, PPstap( Current ) ); 	! Reset & Re-insert. ;
      if ModRec( Current[ E!Runtime ], CopyForModRec[ E!Runtime ] ) then
	BEGIN "success"
	print( crlf );
	LJust( JobName, 10 );
	print( "#" );
	LJust( cvs( ReqNum ), 5 );
	count_ 1;
	END "success"
      else
        QueErr( "JOB COULD NOT BE RERUN. " );	! Failed. ;

      END "perform checks"
    else
      BEGIN "GetRec failed"		! Message depends on License. ;
      Message( crlf&"COULD NOT FIND THIS JOB WITH YOUR USER-NAME."&crlf,
     	       crlf&"COULD NOT FIND THIS JOB."&crlf,
  	       crlf&"JOB NOT IN QUEUE." );
      END "GetRec failed";

    END "fetch then reset"
  else
    BEGIN "Reset all with same job name"
    
    count_ 0;

    ! Stick the file name into the array at position based on 3rd parameter. ;
    if not kequ( JobName, null ) then 		! was JobName furnished? ;
      LoadFileName( Current,JobName,E!CmdFile );	! If not then obtain. ;

    while RealRec( Current[ E!Runtime ] ) do !  rest of recs with this JobName;
      BEGIN "Same jobnames"

      ! Save for ModRec in CopyForModRec. ;
      arrblt( CopyForModRec[ E!Runtime ], Current[ E!Runtime ], E!Length );

      ReqNum_ LPPReq( Current );		! Get req #. ;

      if count = 0 then
        print( "requeing:" );

      dpb( Queued$Wait, PPstap( Current ) ); 	! Reset & Re-insert. ;
      if ModRec( Current[ E!Runtime ], CopyForModRec[ E!Runtime ] ) then
	BEGIN "success"
	print( crlf );
	LJust( JobName, 10 );
	print( "#" );
	LJust( cvs( ReqNum ), 5 );
	count_ count + 1;
	END "success"
      else
        QueErr( "JOB COULD NOT BE RERUN. " );	! Failed. ;

      SetJobNam( JobName ); 		! Clear "Current" and insert Ctl fil.;
      END "Same jobnames";

  END "Reset all with same job name";

  print( crlf, count, " job",if count = 1 then "s" else null,
	" rerun."& crlf );

END "ReRun";


simple procedure ReQueue;
! ----------------------------------------------------------------------;
!									;
!	Get a rec from job list then see if it needs requeuing.		;
!	If user furnishes only a job name then, in turn, 		;
!	  Requeue will reset EVERY job with that name.			;
!	If user furnishes only a request number, then Requeue		;
!	  will reset that rec only.					;
!	If the user enters a Job name and a request number then 	;
!	  Requeue will seek a rec from the queue which has		;
!	  has both and reset it, error if not found. 			;
!									;
! ----------------------------------------------------------------------;
BEGIN "ReQueue"
	integer ReqNum,		! Request number furnished. ;
		
		count;		! Count of how many deletions. ;
	string  JobName;	! Job name furnished. ;

  ! Clear the array being passed, set the request number to -1, and set the ;
  !   AUN according to the users privilege level. ;
  Prepare( Current );	

  ! See if the job name and/or request number were furnished along with the ;
  !   SUBMIT command.  If they were not then prompt for them and return what ;
  !   user types or null if the user answers the prompts with <cr> only. ;
  IdentifyTheJob( JobName, ReqNum );

  if ReqNum > 0 then				! request # received ;
    BEGIN "fetch then reset"
    Dpb( ReqNum, PPReq( Current ) ); 		! put req# into array ;

    if RealRec( Current[ E!Runtime ] ) then	! Get job from Queue. ;
      BEGIN "perform checks"

      if ( LPPstat( Current ) neq ST$Abort ) and
	 ( LPPStap( Current ) neq Queued$Crash ) and
	 ( LPPStap( Current ) neq Hold$Restart ) then
        BEGIN "complain and return"
        print( "REQ# ",ReqNum," is not in the proper state.",crlf );
        return;
        END "complain and return";

      ! Save for ModRec in CopyForModRec. ;
      arrblt( CopyForModRec[ E!Runtime ], Current[ E!Runtime ], E!Length );

      dpb( Queued$Wait, PPstap( Current ) ); 		! Reset ;
      if ( Current[ E!Runtime ]_ NexTim( Current[ E!Runtime ], GetTDT ) ) then
        if ModRec( Current[ E!Runtime ], CopyForModRec[ E!Runtime ] ) then   ! Re-insert. ;
	  BEGIN "success"
	  print( crlf );
	  LJust( JobName, 10 );
	  print( "#" );
	  LJust( cvs( ReqNum ), 5 );
	  count_ 1;
	  END "success"
        else
          QueErr( "JOB COULD NOT BE REQUEUED. " )	! Failed. ;
      else
        QueErr( "No Future run dates for job. " );

      END "perform checks"
    else
      BEGIN "GetRec failed"		! Message depends on License. ;
      Message( crlf&"COULD NOT FIND THIS JOB WITH YOUR USER-NAME. "&crlf,
     	       crlf&"COULD NOT FIND THIS JOB."&crlf,
  	       crlf&"JOB NOT IN QUEUE. " );
      END "GetRec failed";

    END "fetch then reset"
  else
    BEGIN "Reset all with same job name"
    
    count_ 0;

    ! Stick the file name into the array at position based on 3rd parameter. ;
    if not kequ( JobName, null ) then 		! was JobName furnished? ;
      LoadFileName( Current,JobName,E!CmdFile );	! If not then obtain. ;

    while RealRec( Current[ E!Runtime ] ) do !  rest of recs with this JobName;
      BEGIN "Same jobnames"

      ! Save for ModRec in CopyForModRec. ;
      arrblt( CopyForModRec[ E!Runtime ], Current[ E!Runtime ], E!Length );

      ReqNum_ LPPReq( Current );		! Get req #. ;

      if count = 0 then
        print( "requeing:" );

      dpb( Queued$Wait, PPstap( Current ) ); 		! Reset ;
      if ( Current[ E!Runtime ]_ NexTim( Current[ E!Runtime ], GetTDT ) ) then
        if ModRec( Current[ E!Runtime ], CopyForModRec[ E!Runtime ] ) then   ! Re-insert. ;
	  BEGIN "success"
	  print( crlf );
	  LJust( JobName, 10 );
	  print( "#" );
	  LJust( cvs( ReqNum ), 5 );
	  count_ count + 1;
	  END "success"
        else
          QueErr( "JOB COULD NOT BE REQUEUED. " )	! Failed. ;
      else
        QueErr( "No Future run dates for job. " );

      SetJobNam( JobName ); 		! Clear "Current" and insert Ctl fil.;
      END "Same jobnames";

  END "Reset all with same job name";

  print( crlf, count, " job",if count = 1 then "s" else null,
	" requeued."& crlf );

END "ReQueue";


simple boolean procedure CheckListParams( integer array QRec );
! ----------------------------------------------------------------------;
!									;
!		Check the words following the LIST command to see	;
!		  if they are Listable.					;
!									;
! ----------------------------------------------------------------------;
BEGIN "CheckListParams"
	integer OptNum,		! Gets index of valid parameter. ;
		LineLength;	! Keep track of field widths. ;
	string  str;		! One word at a time from command line. ;
	boolean FoundOne;	! True iff at least one parameter was OK. ;

  FoundOne_ false;

  ! ListRequests is a boolean array whose positions are set true if user ;
  !   supplied that parameter. ;
  arrclr( ListRequests );

  LineLength_ 0;			! Must not exceed width of screen. ;

  while true do
    BEGIN "Validate parameters"

    Str_ LopWrd( GS!Params );			! Get next parameter. ;
    if kequ( str,null ) then			! Return if no more. ;
      done;

    OptNum_ Vik( LiPs, Str );		! In options array? ;

    if OptNum = $ABO then continue;	! ABORT option is not listable. ;

    if OptNum = $ALL then		! If one of the params is the ;
      BEGIN "allow nothing with ALL"	!   word ALL then we can ignore ;
      arrclr( ListRequests );		!   the rest end return to use ;
      ListRequests[ $ALL ]_ true;	!   a routine to dump the whole ;
      FoundOne_ true;			!   ueue rec to the screen. ;
      done;
      END "allow nothing with ALL";

    if OptNum neq -1 then
      BEGIN "record in ListRequests"
      FoundOne_ true;				! At least one good param. ;
      if not ListRequests[ OptNum ] then		! If a new param, ;
        LineLength_ LineLength + length( LiPs[ OptNum ] ); ! sum the lengths. ;
      if LineLength < 81 then			! If > screen width then ;
        ListRequests[ OptNum ]_ true		!    don't bother to record. ;
      END "record in ListRequests"
    else
      BEGIN "Invalid or ambiguous"
      if length( GS!Err ) = 0 then		! If Vik returned -1 and ;
        print( crlf, "?",Str,"? - UNKNOWN" )	!  GS!Err=null then invalid. ;
      else
        BEGIN "Ambiguity message"		! If Vik returned -1 and ;
        print( crlf, GS!Err );			!  GS!Err#null then Ambiguity.;
	GS!Err_ null;
	END "Ambiguity message";
      END "Invalid or ambiguous";

    END "Validate parameters";

  if NOT FoundOne then
    return( false )
  else
    return( true );

END "CheckListParams";


simple procedure ColumnHeadings;
! ----------------------------------------------------------------------;
!									;
! 		Now print the 'LIST' column headings. 			;
!									;
! ----------------------------------------------------------------------;
BEGIN "ColumnHeadings"
	integer ParamNum;

  if not ListRequests[ $ALL ] then
    print( crlf,"  " );		! Space for the "Cancelled" flag. ;

  for ParamNum_ 0 upto NumParams - 2 do		! Names for the columns. ;
    BEGIN "column headings"
    if ListRequests[ ParamNum ] then		! Has this param been selected?;
      BEGIN
      if ParamNum = $NEX then		! Next Run column heading requires ;
        BEGIN "ref time"		!   the current time for reference. ;
        print( LiPs[ ParamNum ][ 1 to 8 ] );	! Name of the param. ;
        print( "(",TheTime[ 1 for 5 ],") " );	! Current time in paren. ;
        print( "  " );			! Space for overdue indicator. ;
	END "ref time"
      else				! Rest of column headings required ;
        print( LiPs[ ParamNum ]," " );	!   will be set true. ;
      END;
    END "column headings";

  if not ListRequests[ $ALL ] then
    print( crlf,"  " );		! Space for the "Cancelled" flag. ;

  for ParamNum_ 0 upto NumParams - 2 do		! Underline the column headings.;
    BEGIN "underline headings"
    if ListRequests[ ParamNum ] then		! Underline if true. ;
      BEGIN
      print( dashes[ 1 for length( LiPs[ ParamNum ] ) ] ," " );
      if ParamNum = $NEX then		! NEXT RUN may require Space for ;
        print( "  " );			!    overdue indicator. ;
      END;
    END "underline headings";

END "ColumnHeadings" ;


simple procedure oneLISTline( integer array QRec;
                              reference boolean flagC, flagR, flagS, flagH );
! ----------------------------------------------------------------------;
!									;
!		Gets one queue rec at a time and produces one		;
!		  horizontal line of information on that job		;
!		  depending on what was furnished on the command	;
!		  line after the LIST command. 				;
!		Purpose of the flags is to record which flags		;
!		  have been printed on the left side of the 		;
!		  LIST display to that I know which explanations	;
!		  to include on the bottom.				;
!									;
! ----------------------------------------------------------------------;
BEGIN "oneLISTline"
	integer EachOption;		! Index for ListRequests. ;
	string  S;			! Holds info from wwithin a Q rec. ;
	boolean late;			! Becomes true if next run overdue. ;

  print( crlf );

  case LPPstat( QRec ) of		! Print flags in left margin. ;
    BEGIN
    [ ST$Cancel ] BEGIN  print( !CAN ); flagC_ true;  END;
    [ ST$Proc   ] BEGIN  print( !PRO ); flagR_ true;  END;
    [ ST$Abort  ] BEGIN  print( !PRO ); flagR_ true;  END;
    [ ST$Done   ] BEGIN  print( !PRO ); flagR_ true;  END;
    [ ST$Sched  ] BEGIN  print( !SCH ); flagS_ true;  END;
    [ ST$Hold   ] BEGIN  print( !HOL ); flagH_ true;  END;
    else          print( "  " )
    END;

  for EachOption_ 0 upto NumParams - 1 do	! Check each position in ;
    BEGIN "List each required"			!   the ListRequests array ;
    if ListRequests[ EachOption ] then		!   to determine whether ;
  						!   the user wants to see it. ;
      case EachOption of
      BEGIN
        [ 0 ]					! JobName. ;
	LJust( cv6str(QRec[E!CmdFile+F!Name]), length(LiPs[EachOption])+1 );
	[ 1 ]					! Request. ;
	LJust( cvs( LPPReq( QRec ) ), length(LiPs[EachOption])+1 );
	[ 2 ]					! TimeLimit. ;
	LJust( CvsTim((LPPTimL(QRec) lsh 18) DIV 1440)[ 1 for 5 ],
			length(LiPs[EachOption])+1 );
	[ 3 ]					! UserName. ;
	LJust( cvxStr(QRec[E!UserName])&cvxStr(QRec[E!UserName+1]),
			length(LiPs[EachOption])+1 );
	[ 4 ]					! PPN. ;
	LJust( PrtPPN( QRec[ E!PPN ] ), length(LiPs[EachOption])+1 );
	[ 5 ]					! AUN. ;
	LJust( PrtPPN( QRec[ E!AUN ] ), length(LiPs[EachOption])+1 );
	[ 6 ]					! Privilege. ;
	LJust( QRec[ E!Privs ], length(LiPs[EachOption])+1 );
	[ 7 ]					! NextRun. ;
	LJust( LocalRun(QRec,late)[1 for 15], length(LiPs[EachOption])+1 );
	[ 8 ]					! License. ;
	LJust( cvs(LicPrt(!rh(Qrec[E!License]))), length(LiPs[EachOption])+1 );
	[ 9 ]					! Log File. ;
	LJust( FileSpec(QRec,E!LogFile), length(LiPs[EachOption])+1 );
	[ 10 ]					! Command File.;
	LJust( FileSpec(QRec,E!CmdFile), length(LiPs[EachOption])+1 );
	[ 11 ]					! Label. ;
	LJust( if ( QRec[E!Label] land ('77 lsh 30) )
		then cv6str( QRec[E!Label] )
		else if ( QRec[E!Label] )
		      then "#"&cvs(QRec[E!Label]) else null,
		      	length(LiPs[EachOption])+1 );
	[ 12 ]					! TRULimit. ;
	LJust( cvs(QRec[E!TruLim]) , length(LiPs[EachOption])+1 );
	[ 13 ]					! LogLimit. ;
	LJust( cvs(LPPLogL(QRec)), length(LiPs[EachOption])+1 );
	[ 14 ]					! Log. ;
	LJust( ARLog[LPPLog(QRec)], length(LiPs[EachOption])+1 );
	[ 15 ]					!  Dispose. ;
	LJust( ARDisp[LPPDisp(QRec)], length(LiPs[EachOption])+1 );
	[ 16 ]					!  Mailer. ;
	; ! LJust( ARMailer[LPPMPrg(QRec)], length(LiPs[EachOption])+1 );
	[ 17 ]					!  spool. ;
	; ! LJust( "  *  ", length(LiPs[EachOption])+1 );
	[ 18 ]					!  Mail. ;
	LJust( ARMail[LPPMail(QRec)], length(LiPs[EachOption])+1 );
	[ 19 ]					!  Restart. ;
	LJust( ARRestart[LPPRestart(QRec)], length(LiPs[EachOption])+1 );
	[ 20 ]					!  Unique. ;
	LJust( ARuniq[LPPUniq(QRec)], length(LiPs[EachOption])+1 );
	[ 21 ]					! CTYLOG. ;
	LJust( LPPCtyF(QRec), length(LiPs[EachOption])+1 );
	[ 22 ]					!  run. ;
	LJust( NoYes[LPPRunf(QRec)], length(LiPs[EachOption])+1 );
	[ 23 ]					!  Detach. ;
	LJust( NoYes[LPPDetf(QRec)], length(LiPs[EachOption])+1 );
	[ 24 ]					! CCL. ;
	LJust( LPPCCLF(QRec), length(LiPs[EachOption])+1 );
	[ 25 ]					! Priority. ;
	LJust( LPPJPri(QRec), length(LiPs[EachOption])+1 );
	[ 26 ]					! HALT. ;
	LJust( LPPHaltf(QRec), length(LiPs[EachOption])+1 );
	[ 27 ]					! TmpName. ;
	LJust( Cv6Str( LPPTMPF(QRec) lsh 18 ), length(LiPs[EachOption])+1 );
	[ $ABO ]				!  Abort. ;
	LJust( "  *  ", length(LiPs[EachOption])+1 );
	[ $ALL ]				! Display all Params. ;
	DisplayARec( Qrec )

      END;
    END "List each required";
END "oneLISTline";


simple procedure list;
! ----------------------------------------------------------------------;
!									;
!									;
! ----------------------------------------------------------------------;
BEGIN "List"
	integer Count, ReqNum;
	boolean ParamsChecked;
	boolean flagC, flagR, flagS, flagH;

  flagC_ flagR_ flagS_ flagH_ false;

  Count_ 0;
  ParamsChecked_ false;

  ! Clear the array being passed, set the request number to -1, and set the ;
  !   AUN according to the users privilege level. ;
  Prepare( Template );	
  
  ! Template is retained as a Rec with only the AUN set. ;
  ! Now move Template to current to get next rec from Queue. ;
  ! When the next record from the queue needs to be obtained, a record cleared;
  !   except for the AUN is passed to getrec which will get the next rec. ;
  ! The first time around, GetRec gets an array with -1 in the request number;
  !   field, which will reset the pointer to the beginning of the queue. ;
  arrblt( Current[ E!Runtime ],Template[ E!Runtime ],E!Length ); 
  
  ! The copy must have req = 0 or getrec will keep resetting. ;
  dpb( 0, PPReq( Template ) );

  while GetRec( Current[ E!Runtime ] ) do !  rest of recs with this username;
    BEGIN "List jobs"
    Count_ Count + 1;

    if kequ( GS!Params,null ) then		! No params supplied with LIST;
      GS!Params_ DefaultParam;			!   so use the defaults. ;

    if NOT ParamsChecked then
      BEGIN "First time around"
      if CheckListParams( Current ) then	! Something valid found. ;
	BEGIN "Start LIST"
	ColumnHeadings;			! Print Column headings. ;
        ParamsChecked_ true;		! Set flag. ;
        oneLISTline( Current, flagC, flagR, flagS, flagH ); ! First line. ;
	END "Start LIST"
      else
	BEGIN "Error return"
	print( crlf,#lf, "NO LISTABLE PARAMETERS PROVIDED",crlf );
	return;
	END "Error return"
      END "First time around"
    else
      BEGIN "Subsequent loops"
      oneLISTline( Current, flagC, flagR, flagS, flagH ); 
      END "Subsequent loops";

    ! Template is a Rec with only the AUN set. ;
    ! Now move Template to current to get next rec from Queue. ;
    arrblt( Current[ 0 ],Template[ 0 ],E!Length ); ! move to Current;

    END "List jobs";

  if ListRequests[ $ALL ] then
    print( crlf,#lf,Count," ITEMS LISTED.",crlf )
  else
  if ParamsChecked then
    BEGIN
    if flagC or flagR or flagS or flagH then
      print( crlf, #lf );
    if flagC then  print( !CAN, " = Canceled  " );
    if flagR then  print( !PRO, " = Process  " );
    if flagS then  print( !SCH, " = Scheduled  " );
    if flagH then  print( !HOL, " = Hold  " );
    print( crlf );
    END;

  if count = 0 then
    Message( crlf&"NO JOBS FOR " &GetUserName&"."&crlf,
   	     crlf&"NO JOBS"&crlf,
	     crlf&"QUEUE EMPTY" );

END "List";


simple procedure UnDelete;
! ----------------------------------------------------------------------;
!									;
!									;
! ----------------------------------------------------------------------;
BEGIN
	integer ReqNum, 
		CurrentStat;

  if GS!Params = null then	! If not on command line then ask. ;
    GS!Params_ prompt( "ENTER REQUEST NUMBER: " );

  if ValNum( GS!Params ) then
    ReqNum_ cvd( GS!Params )
  else
    BEGIN
    print( crlf,"REQUEST NUMBER MUST BE AN INTEGER",crlf );
    return;
    END;

  ! Clear the array being passed, set the request number to -1, and set the ;
  !   AUN according to the users privilege level. ;
  Prepare( Current ); 	

  Dpb( ReqNum, PPReq( Current ) ); 		! put req# into array ;
  if GetRec( Current[ E!Runtime ] ) then
    BEGIN "job found"

    CurrentStat_ LPPStat( Current );
    if CurrentStat = ST$Cancel then
      BEGIN "it is a cancelled job"
      arrblt( CopyForModRec[ E!Runtime ], Current[ E!Runtime ], E!Length ); ! copy;
      print( crlf, "UNDELETING REQ# ",GS!Params,"..." );
      dpb( 0, PPstat( Current ) );			 ! undelete it ;
      if ModRec( Current[ E!Runtime ], CopyForModRec[ E!Runtime ] ) then
        print( " REPLACED.",crlf )
      else
        QueErr( " COULD NOT RE-INSERT - " );
      END "it is a cancelled job"
    else
      BEGIN "it is active"
      print( crlf, "REQ# ",GS!Params," IS ACTIVE, CANNOT BE UN-DELETED..." );
      END "it is active";
    ArrClr( Current );

    END "job found"
  else
    BEGIN "job not found"
    Message( crlf&"COULD NOT FIND THIS JOB WITH YOUR USER-NAME. "&crlf,
     	     crlf&"COULD NOT FIND THIS JOB."&crlf,
  	     crlf&"JOB NOT IN QUEUE. " );
    END "job not found";

END;


simple procedure status;
! ----------------------------------------------------------------------;
!									;
!		Display status of jobs in queue.			;
!									;
! ----------------------------------------------------------------------;
BEGIN "status"
	boolean found,		! Becomes true if GetRec ever succeeds. ;
		STatus,		! Becomes true if user has QM or Acct Sup. ;
		late;		! Becomes true if NextRun is in the past. ;
	string  Req,		! Gets request number from rec. ;
		STATE,		! Current state of a job. ;
		PROCESS,	! Current process. ;
		ComFil,		! Gets command file name. ;
		User;		! Gets user name from the rec. ;
	integer num;		! temporary hold for an integer. ;

  found_ false;

  ! Clear the array being passed, set the request number to -1, and set the ;
  !   AUN according to the users privilege level. ;
  Prepare( Template );			

  ! Template is retained as a Rec with only the AUN set. ;
  ! Now move Template to current to get next rec from Queue. ;
  ! When the next record from the queue needs to be obtained, a record cleared;
  !   except for the AUN is passed to getrec which will get the next rec. ;
  ! The first time around, GetRec gets an array with -1 in the request number;
  !   field, which will reset the pointer to the beginning of the queue. ;
  arrblt( Current[ E!Runtime ],Template[ E!Runtime ],E!Length ); 

  ! The copy must have req = 0 or getrec will keep resetting. ;
  dpb( 0, PPReq( Template ) ); 		! Template MUST have req = 0 ;

  if JobPrv land JP!ASV or 		! If user is an acct supervisor or ;
     JobLic land LC!!QM then		!  has QM license ;
    STatus_ true			! then set flag to print the user name;
  else
    STatus_ false;
  
  while GetRec( Current[ E!Runtime ] ) do !  rest of recs with this username;
    BEGIN "Main loop"
    if not found then
      BEGIN
      found_ true;
      print( crlf, "JOB    REQ    " );
      if STatus then	! Only list usernames if user has status. ;
        print( "USER         " );
      print( "CLASS      STATE     NEXT RUN(",TheTime[ 1 for 5 ],")" );
      print( crlf, "====== ===    " );
      if STatus then
        print( "==========   " );
       print( "========== ========= ===============" );
      END;

    Req_  cvs( LPPReq( Current ) );
    ComFil_ cv6Str( Current[ E!CmdFile + F!Name ] );
    User_ cvxStr( Current[ E!Username ]) & cvxStr( Current[ E!Username + 1 ] );

    STATE_   SStat[ num_ LPPStat( Current ) ];	! Get STATE. ;
    PROCESS_ SSStat[ Stat[ num ] + LPPProc( Current ) ];

    print( crlf );			! New line for each job. ;
    LJust( ComFil, 7 );			! Print Command file name. ;
    LJust( Req, 7 );			! Print Request number. ;
    if STatus then			! Print User name if status. ;
      LJust( User, 13 );
    LJust( STATE, 11 );			! Print Job state. ;
    LJust( PROCESS, 10 );		! Print Process state. ;

    ! If not running - show date in local time. ;
    if LPPStat( Current ) neq ST$Proc then
      BEGIN "show date"
      print( LocalRun( Current, late )[ 1 for 15 ] );
      if late then			! If next run is in the past then ;
        print( !Late );			!   fly the late flag. ;
      END "show date";

    ! Template is a Rec with only the AUN set. ;
    ! Now move Template to current to get next rec from Queue. ;
    arrblt( Current[ 0 ],Template[ 0 ],E!Length ); ! move to Current;

    END "Main loop";

  if not found then
    Message( crlf&"NO JOBS FOR " &GetUserName&"."&crlf,
   	     crlf&"NO JOBS"&crlf,
	     crlf&"QUEUE EMPTY" )
  else
    print( crlf );

END "status";


simple string procedure ForceReply( string Question );
! ----------------------------------------------------------------------;
!									;
!									;
! ----------------------------------------------------------------------;
while true do
  BEGIN "ForceReply"
  	string reply;

  while length( reply_ Prompt( Question ) ) = 0 do

    case !skip! of
      BEGIN
      [ 4  ] JobLic_ JobLic xor LC!!QM;		! ^D ;
      [ 6  ] DeBug_ not DeBug;			! ^F ;
      else reply_ reply
      END;

    if CryForHelp( reply ) then
      print( crlf,HlpMsg )
    else
      return( reply )

  END "ForceReply";


integer procedure GetCommand;
! ----------------------------------------------------------------------;
!									;
!		Display SUBMIT prompt and validate response.		;
!									;
! ----------------------------------------------------------------------;
BEGIN "get command"

	procedure ListHelp;
        BEGIN "More help for list"
		integer index;
		string temp;
	print( crlf,"THE FOLLOWING PARAMETERS MAY BE SUPPLIED WITH THE LIST COMMAND:" );
	print( crlf, #lf );
	for index_ 1 upto NumParams-1 do
	  BEGIN "show the parameters"
	  LJust( Lips[ index ], 20 );
!	  if index mod 4 = 0 then
  	    print( crlf  );
	  END "show the parameters";
        print(  crlf &
		crlf &"Example:  LIST CommandFile Request Next <cr>."&
		crlf &"- Lists control file names with request numbers and"&
		      "date-time of next run."&
		crlf &"Example:  LIST ALL <cr>."&
		crlf &"- Lists all parameters for all jobs."&
		crlf );
	END "More help for list";

while true do
  BEGIN "a command"
	integer index;
	string  reply,
		FirstWord,
		SecondWord;

  reply_ ForceReply( SubmitPrompt );	! Get a response. ;
  FirstWord_ LopWrd( reply );			! get 1st word . ;
  GS!Params_ reply ;				! Save the rest. ;
    
  if CryForHelp( FirstWord ) then		! Was 1st word typed = "help"?;
    BEGIN "help requested"
    SecondWord_ LopWrd( reply );			! 2nd word of reply. ;
    index_ Vik( Commands, SecondWord );
    if index neq -1 then
      BEGIN
      print( CommandsHelp[ index ] );
      if kequ( SecondWord, "LIST" ) then
        ListHelp;
      END
    else
      if not equ( GS!ERR, null ) then
        print( GS!ERR )
      else
        print( '42 & SecondWord & '42 & " IS NOT A COMMAND", crlf );
    END "help requested"
  else
    BEGIN "Validate the command"
    index_ Vik( Commands, FirstWord );
    if index neq -1 then
      return( index )
    else
      if not equ( GS!ERR, null ) then
        print( GS!ERR )
      else
        print( '42 & FirstWord & '42 & " IS NOT A COMMAND", crlf );
    END "Validate the command";
  END "a command"
END "get command";



simple boolean procedure ChangedActive( integer Operation, index );
BEGIN
  redefine QRS(j) = { QQ(Runner-1+(j)) };
  redefine QRA(j) = { QQ(RunAct-1+(j)) };

  case Operation of
    BEGIN
    $CON BEGIN
         if LPPSTAP( Current ) = Proc$Stop or
            LPPSTAP( Current ) = Proc$Pause then
	   BEGIN
	   DPB( Proc$Run, PSTAP( QRS(index) ) );
	   return( true );
	   END;
         END;
    $PAU BEGIN
         if LPPSTAP( Current ) = Proc$Run then
	   BEGIN
	   DPB( Proc$Pause, PSTAP( QRS(index) ) );
	   return( true );
	   END;
         END;
    $STO BEGIN
         if LPPSTAP( Current ) = Proc$Run or
            LPPSTAP( Current ) = Proc$Pause then
	   BEGIN
	   DPB( Proc$Stop, PSTAP( QRS(index) ) );
	   return( true );
	   END;
         END;
    $KIL BEGIN
         if LPPSTAT( Current ) = ST$Proc and
            LPPPROC( Current ) < PSP$Cancel then
	   BEGIN
	   DPB( Proc$Cancel, PSTAP( QRS(index) ) );
	   return( true );
	   END;
         END;
    else BEGIN
         print( crlf,"UNKNOWN STATE." );
	 return( false );
         END
    END;

  print( crlf,"Cannot ", Commands[ Operation ], " Req# ", LPReq(QRS(index)),
	 " from it's current state." );
  return( false );

END;


simple procedure ModActiveJob( integer Operation );
BEGIN "ModActiveJob"
	integer ReqNum,
		i,
		Changes,		! count of jobs which were changed.;
		Attempts;		! count of attempts to change. ;
	string  JobName;
	boolean found;

  if not QQ( Active ) and
     not QQ( Running ) then
    BEGIN "Active area is empty"
    print( crlf, "There is nothing in the active area, can't " );
    print( Commands[ Operation ], "." );
    END "Active area is empty";

  ! Clear the array being passed, set the request number to -1, and set the ;
  !   AUN according to the users privilege level. ;
  Prepare( Template );

  ! Template is retained as a Rec with only the AUN set. ;
  ! Now move Template to current to get next rec from Queue. ;
  ! When the next record from the queue needs to be obtained, a record cleared;
  !   except for the AUN is passed to getrec which will get the next rec. ;
  ! The first time around, GetRec gets an array with -1 in the request number;
  !   field, which will reset the pointer to the beginning of the queue. ;
  arrblt( Current[E!Runtime], Template[E!Runtime], E!Length );

  ! See if the job name and/or request number were furnished along with the ;
  !   SUBMIT command.  If they were not then prompt for them and return what ;
  !   user types or null if the user answers the prompts with <cr> only. ;
  IdentifyTheJob( JobName, ReqNum );

  ! Stick the file name into the array at position based on 3rd parameter. ;
  if not kequ( JobName, null ) then 		! was JobName furnished? ;
    LoadFileName( Current,JobName,E!CmdFile );	! If not then obtain. ;

  ! ----- "fetch it" is for the case where a request number ----- ;
  ! ----- has been furnished				    ----- ;
  if ReqNum > 0 then				! request # received ;
    BEGIN "fetch it"
    Dpb( ReqNum, PPReq( Current ) ); 		! put req# into array ;

    if i_ ActRec( Current[ E!Runtime ] ) then	! Get job from Queue. ;
      print( "Req# ", ReqNum,
	     (if ChangedActive( Operation, i )
	       then " is now " else " cannot be "),
	     Commands[ Operation ], "ED." )
     else
      BEGIN "GetRec failed"		! Message depends on License. ;
      If ( GetRec( Current[ E!Runtime ] ) ) then
        Print( crlf&"Job not active."&crlf )
       else
        Message( crlf&"Could not find this job with your username. "&crlf,
     	       crlf&"Could not find this job."&crlf,
  	       crlf&"Job not in queue. " );
      END "GetRec failed";

    END "fetch it"
  else
  ! ----- "Do all with same job name" is for the case where no     ----- ;
  ! ----- request number was provided, so every job with a given name ----- ;
  ! ----- must be done ;
  
    BEGIN "Do all with same job name"

    Changes_ Attempts_ 0;
    
    ! Save a copy of an array with only the AUN and JOBNAME set. ;
    ! When the next record from the queue needs to be obtained, a record cleared;
    !   except for the AUN is passed to getrec which will get the next rec. ;
    ! The first time around, GetRec gets an array with -1 in the request number;
    !   field, which will reset the pointer to the beginning of the queue. ;
    arrblt( Current[E!Runtime], Template[E!Runtime], E!Length );
    
    ! The copy must have req = 0 or getrec will keep resetting. ;
    Dpb( 0, PPReq( Template ) );

    while i_ ActRec( Current[ E!Runtime ] ) do	! recs with this JobName;
      BEGIN "Same jobnames"

      ReqNum_ LPPReq( Current ); 			! Get req #. ;

      Attempts_ Attempts + 1;
      if ChangedActive( Operation, i ) then
	BEGIN
	print( "Req# ", ReqNum, " is now ", Commands[ Operation ], "ED." );
	changes_ changes + 1;
	END;

      ! Copy the Save array back into Current for next call of GetRec. ;
      arrblt( Current[E!Runtime], Template[E!Runtime], E!Length );

      END "Same jobnames";

    if not( attempts ) then
      BEGIN "check queue"
      Dpb( -1, PPReq( Current ) );
      if ( GetRec( Current[ E!Runtime ] ) ) then
        print( crlf&"Job not active."&crlf )
       else
        Message( crlf&"Could not find this job with your username. "&crlf,
     	       crlf&"Could not find this job."&crlf,
  	       crlf&"Job not in queue. " );
      END "check queue"
     else
      if not( Changes ) then
        print( "Req# ", ReqNum, " cannot be ", Commands[ Operation ], "ED." );

!    print( crlf,#lf, Changes, "/", Attempts, " Attempts were successful." );

  END "Do all with same job name";
END "ModActiveJob";


! main;

  print( "TYMCOM-X JOB PROCESSOR  ",VERSION!STRING,"  ",
        CvSDat( TodaysIntrnDat )," ",TheTime, crlf );

  JobLic_ Gettab( -1,!gtLIC );		! Status License enabled ;
  JobPrv_ Gettab( -1,!gtPRV );		! Job Privileges ;
  JobPPN_ Gettab( -1,!GTPPN );      	! Connected Directory ;
  JobAUN_ Gettab( -1,!GTAUN );		! Logged-in Directory ;

  while true do
    BEGIN "get a command and process"
    GI!Pos_ E!Descriptor;
    CASE GI!CmdNum_ GetCommand of
      BEGIN
      C!DATES           GetExpFromUser( true );
      C!INSERT          Insert;
      C!DISPLAY         Display;
      C!EXPRESS         Express;
      C!TEST            Test;
      C!DELETE          delete;
      C!STATUS          Status;
      C!LIST            list;
      C!MODIFY          ModJob( true );
      C!VERSION         print( crlf,"Version ",VERSION!STRING,crlf );
      C!QUIT            AUS;
      C!HELP            print( HlpMsg );
      C!CODE            continue "get a command and process";
      C!LOOK            Look;
      C!UNDELETE        UnDelete;
      C!SHOW            ModJob( false );
      C!MODACT          ModActiveJob( GI!CmdNum );
      C!RERUN           ReRun;
      C!REQUEUE		ReQueue;
      else print( "!UNIDENTIFIED COMMAND: #",GI!CmdNum,".",crlf )
      END 
    END "get a command and process"
END "SUBMIT";

 V