begin "SUBMIT"
require "(SAILIB)sail.def" source!file;
! require "(SAILIB)UUOSYM.DEF" Source!file;
require crlf&"[Put (SAILIB)UUOSYM.DEF back for production]"&crlf message;

require "(CARL)jqueue.def" Source!file;
define release = { "0.0" };
define Device = { "DSK" };
! define SubmitPrompt = { "ENTER YOUR SUBMIT COMMAND:" } ;
define SubmitPrompt = { ":" };
define SpecialsPrompt = { "!" } ;
define FragmentComplaint = { "yawn..." } ;
define spaces = { "                    " } ;
define dashes = { "--------------------" } ;
define DefaultParam = { "Jobname sequ timel usern aun next" };
define PrtPpn(P) = { (spaces[1 for 6]&cvos(!lh(P)))[inf-5 to inf]&","
			&(cvos(!rh(P))&spaces)[1 for 6] };

define !GTUNM = -'22;
define !GTUN1 = -'21;
define calli!gettab = '41;
define !GTPPN = '2;
define !GTPRV = '6;
define !GTAUN = -'23;
define !GTLIC = -'20;
define calli!chprj = -'61;
define UUO!FRMOP = '44 lsh '27;

define NumParams = 27 ;
define NumOptns = 20 ;
define NumLog = 4 ;
define NumDispose = 3 ;
define NumMail = 4 ;
define NumSpool = 3 ;
define NumMailer = 2 ;
define NumRestart = 5 ;
define NumUnique = 4 ;
define NumRun = 2 ;
define NumDetach = 2 ;

define  NumKeys = 18,
	NumOrds = 10,
	NumMnths = 12,
	NumWkDay = 7,
	NumCmds = 19,
	NumMods = 9,
	CodLnth = 12,
	NumOpts = 14,
	MaxExps = E!MaxItem;

define  AftCon = 1,
	BefCon = 2,
	StaCon = 3,
	UntCon = 4,
	ExcCon = 5,
	AndCon = 6,
	EndCon = 7; 
define  Typ = 0;
	!Block(Typ,N)			! TypN = 0 ;
	!Block(Typ,W)			! TypW = 1 ;
	!Block(Typ,S)			! TypS = 2 ;
	!Block(Typ,T)			! TypS = 3 ;
define  Alphs = {"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"} ,
	Digits = {"0123456789"} ,
	HlpMsg = { 
"
           VALID SUBMIT COMMANDS
           ---------------------
[DA]TES    TAKES A DATE SENTENCE
[I]NSERT   INSERT JOB INTO THE JOB QUEUE
[DI]SPLAY  DISPLAYS ALL DATES ASSOCIATED WITH DATE SENTENCE
[E]XPRESS  REPHRASES THE DATE SENTENCE
[T]EST     EXECUTES BOTH EXPRESS AND DISPLAY COMMANDS
[DE]LETE   DELETES SPECIFIED JOB
[S]TATUS   TYPES STATUS OF SPECIFIED JOB BELONGING TO USER
[N]OW      SHOWS CURRENT DATE AND TIME
[L]IST     LISTS ALL JOBS FOR THIS USER
[G]ET      GETS ENTRY BACK FROM JOB LIST
[V]ERSION  TYPE VERSION NUMBER
[Q]UIT     RETURNS TO EXEC
[H]ELP     TYPES THIS MESSAGE 

[C]ODE     OPER ENTERS DATE CODE FOR TESTING/INTERPRETATION
[LO]OK     DISPLAYS CURRENT DATE CODE
[SP]ECIAL  SPECIAL QUEUE MANIPULATION STUFF" };

define PutMult( x )   = { DPB( x, PMult(   Current[ I$Position ] ) ) };
define PutType( x )   = { DPB( x, PType(   Current[ I$Position ] ) ) };
define PutMoMult( x ) = { DPB( x, PMoMult( Current[ I$Position ] ) ) };
define PutBody( x )   = { DPB( x, PBody(   Current[ I$Position ] ) ) };
define PutConn( x )   = { DPB( x, PConn(   Current[ I$Position ] ) ) };

define GetMult     = { LDB( PMult(   Current[ I$Position ] ) ) };
define GetType     = { LDB( PType(   Current[ I$Position ] ) ) };
define GetMoMult   = { LDB( PMoMult( Current[ I$Position ] ) ) };
define GetBody     = { LDB( PBody(   Current[ I$Position ] ) ) };
define GetConn     = { LDB( PConn(   Current[ I$Position ] ) ) };

define SREF( x ) = { DPB( x, PDate( Current[ I$Position + 1 ] ) ) };
define GREF      = { LDB( PDate( Current[ I$Position + 1 ] ) ) };

define STIM( x ) = { DPB( x, PTime( Current[ I$Position + 1 ] ) ) };
define GTIM      = { LDB( PTime( Current[ I$Position + 1 ] ) ) };

require "(HELGEM)DAYTIM.REQ" source!file;
require "(HELGEM)LICSUB.REQ" source!file;

preload!with
"NONE","APPEND","SUPERSEDE","SPOOL";
string array ARLog[ 0:NumLog - 1   ];

preload!with
"NONE","DELETE","NOERROR";
string array ARDspos[ 0:NumDispose - 1   ];

preload!with
"RPG","TUMS";
string array ARMailer[ 0:NumMailer - 1   ];

preload!with
"NONE","LOGFILE","ERRORLOG";
string array ARSpl[ 0:NumSpool - 1   ];

preload!with
"NONE","ERROR","SUCCESS","ALWAYS";
string array ARMail[ 0:NumMail - 1   ];

preload!with
"NONE","CHECKPOINT","LABEL","CONTINUE","REPEAT";
string array ARRstrt[ 0:NumRestart - 1   ];

preload!with
"NONE","USER","PATH","JOB";
string array ARUniq[ 0:NumUnique - 1   ];

preload!with
"NO","YES";
string array ARRun[ 0:NumRun - 1   ];

preload!with
"NO","YES";
string array ARDetach[ 0:NumDetach - 1   ];

preload!with
"Jobname   ","Sequence","Timelimit","Username    ","PPN          ",
"AUN          ","Priviledge",
"Next Run          ","License",
"Logfile             ","Commandfile         ",
"Label","Trulimit",
"LogLimit","Dependency","Log       ","Dispose ","Mailer",
"Spool     ","Mail","Restart   ","Unique",
"Abort","Run ","Detach","TmpName","All";
string array ListParams[ 0:NumParams - 1   ];

preload!with
10,8,9,12,13,
13,5,
18,7,
24,24,
6,8,
8,10,10,8,6,
10,8,10,6,
5,4,6,7;
integer array fieldlengths[ 0:NumParams - 1 ];

boolean array WhichParams[ 0:NumParams - 1   ];

preload!with
"LABEL","TIMELIMIT","TRULIMIT","",
"LOGLIMIT","Dependency","LOG","DISPOSE","MAILER",
"SPOOL","MAIL","RESTART","UNIQUE","PARAMETERS",
"HELP","?","ABORT",
"RUN","DETACH","TMPNAME";
string array Options[ 0:NumOptns - 1   ];

integer
	I$DayCyc, ! globals contain imbedded "$";
	I$CmmdNum,
	I$Position;

integer
	ScanToBlank, ! the following integers are breaks;
	BrkChar,
	NonDigitBrk,
	SkipJunk,
	NextWord,
	ScanToDot,
	LnBrk;

string
	S$ListParameters,
	S$UsrsExp, ! date expression attempted by user;
	S$ThrownOut, ! depository for bad terms thrown out during ScanStr;
	S$Scanned, ! date expression after scanning;
	S$OneUnit, ! 12 char code string for one unit date exp;
	S$DatCod, ! One or more S$OneUnits;
	S$ErrMSG; ! explanation for problem encountered during parse;

boolean
	B$MonUnit, ! set true when a valid month-unit is parsed;
	B$MDYUnit, ! set true when a valid unit such as 9/9/85 or;
		   ! jan 3, 1986 is parsed;
	B$Coded,   ! set true when date code for a given unit has been started;
	B$DayCyc,
	B$Trace;   ! true when "trace" command is issued at command level;
		   !   enables user/programmer to see process of date-code;
		   !   generation, etc. for debugging purposes;

integer array Current[ 0:E!Length - 1 ]; ! latest queue entry fetched;
integer array SavEntr[ 0:E!Length - 1 ];      ! save a copy where needed;
integer array Confirm[ 0:E!Length - 1 ];  ! when an entry is fetched, a;
     ! copy is made immediately so that when a modified version is sent;
     ! back to the queue to overwrite original version, the original version;
     ! can be checked against the Confirm to ensure that the queue entry;
     ! has not been changed by another user in the meantime;
string array ModCheck[ 0:NumMods - 1   ];

preload!with
"FIRST","SECOND","THIRD","FOURTH","FIFTH",
"SIXTH","SEVENTH","EIGHTH","NINTH","TENTH";
string array ChkOrds[ 0:NumOrds - 1 ];

preload!with
"JANUARY","FEBRUARY","MARCH","APRIL","MAY","JUNE",
"JULY","AUGUST","SEPTEMBER","OCTOBER","NOVEMBER","DECEMBER";
string array Mos[ 0:NumMnths - 1 ];

preload!with
"SATURDAY","SUNDAY","MONDAY",
"TUESDAY","WEDNESDAY","THURSDAY","FRIDAY";
string array WkDay[ 0:NumWkDay - 1 ];

preload!with
"DA","I","DI","E","T","DE","S","L",
"G","V","Q","H","?",
"TR","OFF","C","LO","SP","N";
string array MinCom[ 0:NumCmds - 1 ];

preload!with
"DATES","INSERT","DISPLAY","EXPRESS","TEST","DELETE","STATUS","LIST",
"GET","VERSION","QUIT","HELP","?",
"TRACE","OFF","CODE","LOOK","SPECIAL","NOW";
string array Commands[ 0:NumCmds - 1 ];

preload!with
"EVERY","EVERY","TODAY","TOMORROW","DAYS","MONTH","2",
"SUNDAY","AND","EVERY DAY","31 DAY","31","EVERY SUNDAY","1 DAY EVERY MONTH",
"EVERY MONDAY AND EVERY TUESDAY AND EVERY WEDNESDAY AND EVERY THURSDAY AND EVERY FRIDAY",
"HOURS","MINUTES",
"STARTUP";
string array GoodKey[ 0:NumKeys - 1 ];

preload!with
"EVERY","EACH","TODAY","TOMORROW","DAYS","MONTHS","OTHER",
"WEEKS","AND","DAILY","END","LAST","WEEKLY","MONTHLY",
"WEEKDAYS",
"HOURS","MINUTES",
"STARTUP";
string array Keys[ 0:NumKeys - 1 ];

preload!with
"AFTER","BEFORE",
"AFTER","BEFORE",
"STARTING","UNTIL",
"EXCEPT","EXCEPT","AND";
string array GoodMods[ 0:NumMods - 1   ];

preload!with
">","<",
"AFTER","BEFORE",
"STARTING","UNTIL",
"EXCEPT","NOT","AND";
string array Modifiers[ 0:NumMods - 1   ];

require "(helgem)UTools.sai" source!file;

simple boolean procedure ValidTimeStr( reference string S );
! return true if a contiguous string of chars is of the;
! form HH:MM:SS;
BEGIN
	string HH,MM,SS,Copy;
	integer NonDigit;
  Copy_ S;				! save a copy;
  HH_ scan( S,NonDigitBrk,NonDigit );
  if NonDigit = '72 then			! was break a ":" ?;
  BEGIN
    if cvd( HH ) > 23 or cvd( HH ) < 0  then ! if yes,check hour in range;
    BEGIN 				! hour out of range 0-23;
      S$ErrMSG_ "?Hour (" & HH & ") - out of range.";
      return( false );
    END
    else 
    BEGIN ! hour is legal so find minute;
      MM_ scan( S,LnBrk,NonDigit );       ! get next number/letter;
      if NonDigit = '72 then 		! true if break was another ":";
      BEGIN
        if cvd( MM ) > 59 or cvd( MM ) < 0  then  ! does minute make sense;
        BEGIN 			! minute was not in range 0-59 so 86;
	  S$ErrMSG_ "?Minute (" & MM & ") - must be from 0 to 59";
	  return( false );
	END
	else 
	BEGIN 
	  SS_ S; 			! now include the second part;
          if cvd( SS ) > 59 or cvd( SS ) < 0  then  ! does minute make sense;
          BEGIN 			! minute was not in range 0-59 so 86;
            S$ErrMSG_ "?Second (" & SS & ") - must be from 0 to 59";
	    return( false );
	  END
	  else 
	  BEGIN 
	    S_ Copy;  ! restore ;
	    return( true );
	  END
	END
      END
      else
      BEGIN ! second break not ":" ;
	if NonDigit = 0 then
	BEGIN
	  S_ Copy;
	  return( true ); ! string such as HH:MM ;
	END
	else 
	BEGIN
 	  S$ErrMsg_ "?UNRECOGNIZABLE WORD: " & Copy & " " ;
	  return( false );
	END
      END
    END
  END  ! if NonDigit = '72 ;
  else 
  BEGIN 			! no ":" found so;
    S_ Copy; 		! restore original;
    return( false );
  END
END;

simple boolean procedure ValidNum( string S );
! true if whole of "S" consists of an integer;
BEGIN
	integer NonDigit;
  if equ( S,null ) then
    return( false );
  S_ scan( S,NonDigitBrk,NonDigit );
  if NonDigit then 
    return( false )
  else
    return( true );
END;

simple boolean procedure ValidDateStr( reference string S );
! return true if a contiguous string of chars is of the;
! form MM/DD/YY;
BEGIN
  string MM,DD,YY,Copy;
  Copy_ S;				! save a copy;
  MM_ scan( S,LnBrk,BrkChar );	! scan until non-letter/number;
  if BrkChar = '57 then			! was break a "/" ?;
  BEGIN
    if cvd( MM ) > 12 or cvd( MM ) < 1  then ! if yes,check month in range;
    BEGIN 				! month out of range 1-12;
      S$ErrMSG_ "?Month (" & MM & ") - out of range.";
      return( false );
    END
    else
    BEGIN ! month is legal so find day;
      DD_ scan( S,LnBrk,BrkChar );       ! get next number/letter;
      if BrkChar = '57 then 		! true if break was another "/";
      BEGIN
        if cvd( DD ) > 31 or cvd( DD ) < 1  then  ! does day make sense;
        BEGIN 			! day was not in range 1-31 so 86;
          S$ErrMSG_ "?Day (" & DD & ") - must be > 0 or < 31";
          return( false );
        END
        else
        BEGIN 
          YY_ S; 			! now include the year part;
          ! now change to form as "JANUARY 12, 85;
          S_ mos[cvd(MM)-1] & " " & DD & " " & YY;
          return( true );
        END
      END
      else
      BEGIN
        S_ Copy;
        return( false );
      END
    END
  END
  else
  BEGIN 			! no "/" found so;
    S_ Copy; 		! restore original;
    return( false );
  END
END;

simple boolean procedure ValidDOW( string S );
! true if S is a day-of-the-week, ex: "MONDAY" ;
BEGIN
  integer i;
  for i_ 0 upto NumWkDay - 1 do			! check whole array;
    if EQU( S,WkDay[ i ] ) then
      return( true );
    return( false ); ! no match;
END;

simple boolean procedure ValidOrd( reference string S );
! validates words such as "FIRST" or "FOURTH";
! if a correct abbreviation is typed, the full word will be substituted;
BEGIN
  integer i;
  if length( S ) < 3 then 
    return( false );
  for i_ 0 upto NumOrds - 1 do		! check array for match;
    if KEQU( S,ChkOrds[ i ][ 1 for length( S ) ] ) then
    BEGIN
      S_ cvs( i + 1 );		! replace ord with integer equiv;
      return( true );
    END;
  return( false ); ! no match;
END;

simple boolean procedure ValidMOY( string S );
! validates words such as "AUGUST", or "MAY";
BEGIN
  integer i; 
  for i_ 0 upto NumMnths - 1 do		! check array for match;
    if EQU( S,Mos[ i ] ) then
      return( true );
  return( false ); ! no match;
END;

simple integer procedure Val( string array AR ;
				reference string S ;
				integer ArrSize
			    );
BEGIN
  integer i,SavI ;string Str,Sav ; boolean MatchF ;
  Sav_ S; SavI_ -1; MatchF_ false ; Str_ null;
  if equ( S,null ) then
    return( false );
  while true do
  BEGIN "add to str"
    if length( S ) then
    BEGIN
      Str_ Str & Lop( S );
      ! print( crlf,"LOP:<",Str,">" );
      MatchF_ false;
      for i_ 0 upto ArrSize - 1 do
      BEGIN
        ! print(" ",i,":",AR[i][1 for length( Str) ] );
        if KEQU( Str,AR[ i ][ 1 for length( Str ) ] ) then
        BEGIN 	
          SavI_ i;
          if MatchF then
          BEGIN
            continue "add to str" ;
          END
          else
	  BEGIN
            matchF_ true;
          END
        END
      END; 
      if not MatchF then
      BEGIN
        S_ Sav;
        return( false );
      END
    END
    else
    BEGIN
      if SavI geq 0 then
      BEGIN
        S_ AR[ SavI ];
        return( true );
      END
      else
      BEGIN
        S_ Sav;
        return( false );
      END
    END
  END "add to str" ;
END;

simple boolean procedure ValidKey( reference  string S );
! validates words such as "EVERY" or "AND";
! if a correct abbreviation is typed, the full word will be substituted;
BEGIN
  integer i; 
  if length( S ) < 3 then 
    return( false );
  for i_ 0 upto NumKeys - 1 do			! check array for match;
    if KEQU( S,Keys[ i ][ 1 for length( S ) ] ) then
    BEGIN
      S_ GoodKey[ i ]; 		! replace with match from array;
      return( true );
    END;
  return( false ); ! no match;
END;

simple boolean procedure ValidMODIFIER( string S );
! validates words such as "AFTER" or "EXCEPT";
BEGIN
  integer i;
  for  i_ 0 upto NumMods - 1  do
    if EQU( S,Modifiers[ i ] ) then
      return( true );
  return( false ); ! no match;
END;

simple boolean procedure ValidOrdNum( reference string S );
! validates words such as "3RD" or "1ST";
! if a correct abbreviation is typed, the full word will be substituted;
BEGIN
  integer c,i,BrkChar;
  string temp;
  temp_ S; 				! save original string;
  for i_ 1 upto length( S ) do
  BEGIN
    c_ lop( S );			! get first char;
    if "0" leq c leq "9" then		! is it a number;
    BEGIN
      continue			! if yes then loop again for next char;
    END
    else				! non-number found;
    BEGIN
      if i < 2 then 			! better not be in first position;
      BEGIN
        S_ temp;			! if so then restore and return;
        return( false );
      END
      else				! else replace non-number;
      BEGIN
        S_ c & S;
        done;			! out of for loop;
      END
    END
  END;
  ! now check non-number part for the right two letters;
  if KEQU( S[ 1 for 2 ] ,"RD" ) or
    KEQU( S[ 1 for 2 ] ,"ST" ) or
    KEQU( S[ 1 for 2 ] ,"TH" ) or
    KEQU( S[ 1 for 2 ] ,"ND" ) then
  BEGIN
    S_ cvs( intscan( temp,BrkChar ) ); ! it's valid but just return number;
    if cvd( S ) > 31 then
      S_ "31";			
    return( true )
  END
  else
  S_ temp;				! invalid so restore;
  return( false );			! and return false;
END;

simple string procedure ScanStr( string EnglishStr );
! deletes un-identifyable words or fragments from the date;
! expression typed by the user;
BEGIN
  string OneWord,GoodStr,SS;
  if B$Trace then print( "ScanStr: " );
  S$ErrMSG_ GoodStr_ S$ThrownOut_ null;
  do
  BEGIN
    SS_ scan( EnglishStr,skipjunk,BrkChar ); 
    OneWord_ scan( EnglishStr,NextWord,BrkChar ); ! get next word;
    if Val( GoodMods,OneWord,NumMods ) then
      GoodStr_ GoodStr & OneWord & " "
    else
    if ValidKey( OneWord ) then
      GoodStr_ GoodStr & OneWord & " "
    else
    if ValidNum( OneWord ) then
      GoodStr_ GoodStr & OneWord & " "
    else
    if Val( WkDay,OneWord,NumWkDay ) then
      GoodStr_ GoodStr & OneWord & " "
    else
    if ValidTimeStr( OneWord ) then
      GoodStr_ GoodStr & OneWord & " "
    else
    if ValidDateStr( OneWord ) then
      GoodStr_ GoodStr & OneWord & " "
    else
    if ValidOrd( OneWord ) then
      GoodStr_ GoodStr & OneWord & " "
    else
    if Val( Mos,OneWord,NumMnths ) then
      GoodStr_ GoodStr & OneWord & " "
    else
    if ValidOrdNum( OneWord ) then
      GoodStr_ GoodStr & OneWord & " "
    else
    if NOT KEQU( OneWord,"THE" ) and 
      NOT KEQU( OneWord,"OF" ) and
      NOT KEQU( OneWord,"AT" ) then
      S$ThrownOut_ S$ThrownOut & '42 & OneWord & '42 & " "; ! record discards;
  END
  until length( EnglishStr ) = 0;
  if B$Trace then print( GoodStr,".",crlf );
    return( GoodStr );
END;

simple string procedure GetTodDate;
! returns MM DD YYYY (todays date);
BEGIN "GetTodDate"
  integer Day,Month,Year,Raw;
  Raw_calli(0,'14);
  Month_((Raw DIV 31) MOD 12) + 1;
  Day_(Raw MOD 31) + 1;Year_(Raw DIV 365) + 63;
  Return(CVS(Month)&" "&CVS(DAY)&" "&CVS(Year));
END "GetTodDate";

simple integer procedure TodaysIntrnDat;
! returns today's displacement in days from jan 1, 1964;
BEGIN
  string date; integer m,d,y,t;
  date_ GetTodDate;
  m_ intscan( date,BrkChar );
  d_ intscan( date,BrkChar );
  y_ intscan( date,BrkChar );
  t_ CvDate( m,d,y  );
  return( t );
END;

simple integer procedure trunc( real n );
  return( n div 1 );

simple integer procedure ZELLER( integer day,month,year );
! uses Zellers congruence to figure the day of the
week on which any dlls.
Returns 0 - 6 (Saturday - Friday).;
BEGIN
  integer m;
  if month > 2 then
  BEGIN
    m_ month
  END
  else
  BEGIN
    m_ month + 12;
    year_ year - 1;
  END;
  return( ( day + 2 * m + trunc(0.6 * (m + 1 )) + year
          + year div 4 - year div 100 + year div 400 + 2) mod 7 );
END;

simple integer procedure Today;
! Returns today's WkDay : 0 - 1 ( Saturday - Friday );
BEGIN
  string date;
  integer day,month,year;
  date_ GetTodDate;
  month_ intscan( date,BrkChar );
  day_ intscan( date,BrkChar );
  year_ intscan( date,BrkChar );
  return( ZELLER( day,month,year ) );
END;

simple integer procedure DayToNum( string Day );
! given name of day returns day number.;
! SAT - FRI = 0 - 6.;
BEGIN
  integer i;
  for i_ 0 upto 6 do			! check array for match;
    if KEQU( Day,WkDay[ i ] ) then
      return( i );
END;

simple integer procedure MoToNum( string Mon );
! given name of month returns month number.;
! JAN - DEC = 0 - 11.;
BEGIN
  integer i;
  Mon_ Upper( Mon );
  for i_ 0 upto 11 do			! check array for match;
    if KEQU( Mon[ 1 for 3 ],Mos[ i ][ 1 for 3 ] ) then
      return( i );
END;

simple string procedure getDOW( string date );
! given date in the form: "23-Jun-85", returns day-of-the-week ( 0-6 );
BEGIN
  integer d,m,y,dow;
  d_ cvd( date[1 for 2] );
  m_ MoToNum( date[4 for 3] );
  y_ cvd( date[8 for 2] ) + 1900;
  dow_ zeller( d,m + 1,y );
  return( WkDay[ dow ] );
END;

simple procedure GetDateSpec;
! returns what user types upto a period followed by <cr>;
BEGIN
  print(crlf,"ENTER YOUR DATE/TIME SENTENCE",crlf );
  BrkChar_ 0;
  S$UsrsExp_ null;
  while brkchar = 0 do
  BEGIN
    S$UsrsExp_ S$UsrsExp & inchwl & " "; ! get first line;
    S$UsrsExp_ scan( S$UsrsExp,ScanToDot,brkchar ); ! is there a period;
  END;
END;

simple integer procedure HowMany( string S,Target ); 
! returns number of times "Target" appears in string S;
BEGIN
  string NextWord;
  integer count;
  count_ 0;
  while length( S ) > 0 do 	! check the whole string;
  BEGIN
    NextWord_ LopWord( S );	! get next word;
    if KEQU( NextWord,Target ) then	! is it same as "Target";
      count_ count + 1;	! if so, increment counter;
  END;
  return( count );
END; ! HowMany;

simple boolean procedure ModUsedBefore( string m );
! the same modifier cannot be used twice in an expression;
BEGIN
  integer i;
  for i_ 0 upto NumMods - 1 do
  BEGIN 
    if KEQU( m,GoodMods[ i ] ) then
    BEGIN 
      if ModCheck[ i ]  then
      BEGIN
        S$ErrMsg_ "NO MORE THAN ONE " & GoodMods[ i ] & " CAN BE USED";
        return( true );
      END
      else
      BEGIN
        ModCheck[ i ]_ true; ! set the flag;
        return( false ); ! no problem;
      END
    END
  END
END;

simple procedure SetCode( integer a,b,c,d,e );
BEGIN
  B$Coded_ true;
  if GetMult = 0 then
    PutMult( a );
  if GetType = 0 then
    PutType( b );
  if GetMoMult = 0 then
    PutMoMult( c );
  if GetBody = 0 then
    PutBody( d );
  if GetConn = 0 then
    PutConn( e );
END;

simple boolean procedure UNIT( string S;
				reference string S$ErrMSG
			     );
! returns true with S$ErrMSG = null if a valid unit was passed;
! returns false with S$ErrMSG = null if a fragment of a valid unit was passed;
! returns false with S$ErrMSG containing an error message if what was passed
contains a violation of the syntax;
BEGIN
  boolean DOW,MOY,Cyclic;
  integer MM,DD,YY,cycle,diff,TGTDay,BaseDayNum,NextDate,base;
  string Str,BaseDay;
  if B$Trace then print( crlf,"Unit Rec'd: <",S,">" );
    Cyclic_ false; ! becomes true if "every" is found;
  B$MDYUnit_ false; ! becomes true if the unit was MM/DD/YYYY or MMM DD, YYYY;
  Str_ LopWord( S ); ! get first word;

  if KEQU( Str,"STARTUP" ) then
  BEGIN
    SetCode( 0,TypS,0,0,ENDCon );
    SREF( -1 );
    return( true );
  END;

  if KEQU( Str,"TODAY" ) then
  BEGIN
    SetCode( 0,TypS,0,0,ENDCon );
    B$MDYUnit_ true;
    SREF( TodaysIntrnDat );
    return( true );
  END;

  if KEQU( Str,"TOMORROW" ) then
  BEGIN
    SetCode( 0,TypS,0,0,ENDCon );
    B$MDYUnit_ true;
    SREF( TodaysIntrnDat + 1);
    return( true );
  END;

  if KEQU( Str,"EVERY" ) then
  BEGIN
    Cyclic_ true;
    Cycle_ 1;
    if length( S ) = 0 then
      return( false )
    else
      Str_ LopWord( S ); 			! get word after "every";
  END;

  if ValidMOY( Str ) then 		! is the word a month such as "MARCH"?;
  BEGIN 
    if Cyclic then 		! "every" was encountered previously;
    BEGIN 		! expressions such as "every August" are invalid;
      S$ErrMSG_ "EVERY cannot be followed by a date or month";
      return( false );
    END;
    MM_ MoToNum( Str ); 	! convert the month name to a number 0-11;
    if length( S ) = 0 then 	! month name must be followed by something.;
      return( false )		! false but no error since it may come next ;
    else	  	
      Str_ LopWord( S ); 		! more to string so get next word;

    if ValidNum( Str ) then     ! month had better be followed by a number;
    BEGIN
      DD_ cvd( Str ); 		! DD holds the day;
      if length( S ) = 0 then   ! so far so good but return false for more;
        return( false );
      Str_ LopWord( S ); 	! there is more so check for year number;
      if ValidNum( Str ) then   ! need number for year here;
      BEGIN
        YY_ cvd( Str[inf - 1 to inf] );  	! store the year in YY;
        if cvd( GetTodDate[inf - 1 to inf] ) > YY then
        BEGIN
          S$ErrMSG_ "DATE TOO FAR IN THE PAST OR YEAR > 1999";
          return( false );
        END
	else
	BEGIN 					! Date is OK ;
          SetCode( 0,TypS,0,0,ENDCon );
          SREF( CvDate( MM + 1,DD,YY ) );
          B$MDYUnit_ true;
          return( true );
	END
      END
      else
      BEGIN 	! month and day followed by something other than a year;
        S$ErrMSG_ "Month must be followed by DD YYYY";
        return( false );
      END
    END
    else
    BEGIN 	! month followed by something other than a day number;
      S$ErrMSG_ "Month must be followed by DD YYYY";
      return( false );
    END
  END;

  if KEQU( Str,"EVERY" ) then 		! "EVERY" here means fatal trouble;
  BEGIN
    if Cyclic then
      S$ErrMSG_ "CONSECUTIVE EVERY'S"
    else
      S$ErrMSG_ "EVERY must be in first position of a unit ";
    return( false ); 
  END;

  if ValidNum( Str ) then 	! a number encountered at BEGINning of unit or;
  BEGIN                  	!   after an "EVERY";
    cycle_ cvd( Str ); 		! store the number in "cycle";
    if length( S ) = 0 then 	! so far so good, return for more;
      return( false )
    else
      Str_ LopWord( S ); 	! stuff left in string so get next word;

    if KEQU( Str,"EVERY" ) then 	! such as in "10TH [OF] EVERY MONTH";
    BEGIN
      Str_ LopWord( S ); 		! get next;
      if EQU( Str,null ) then
        return( false );
    END;

    if KEQU( Str[ 1 for 5 ],"MONTH" ) then
    BEGIN 
      if not B$Coded then 	! must be expression such as "EVERY nTH MONTH";
      BEGIN
        SetCode( 0,TypN,Cycle,1,ENDCon );
        return( true );
      END
      else 				! such as "... OF EVERY nTH MONTH";
      BEGIN
        if cycle > 9 then ! multiplier must be < 10;
          cycle_ 9;
      END;
    
      if B$DayCyc then 		! first unit of this same expression was days;
        SetCode( 0,TypN,Cycle,I$DayCyc,ENDCon )
      else 	     ! second part of exp as "1ST WED OF EVERY [cycle] MONTH";
        SetCode( 0,0,Cycle,0,ENDCon );
  
      B$MonUnit_ true; 		! second unit of 2 unit exp must be month unit;
      return( true );
    END ;

    if ValidDOW( Str ) then 	! for example: "EVERY MONDAY" or "2ND WED";
    BEGIN
      SetCode( Cycle,TypW,0,DayToNum( Str) ,ENDCon );
      return( true );
    END;

    if KEQU( Str[1 for 3], "DAY" ) then 	! as in "EVERY nTH DAY";
    BEGIN
      I$DayCyc_ Cycle;
      SetCode( 1,TypN,0,Cycle,ENDCon );
      B$DayCyc_ true; 			! a cyclic day unit has been coded;
      return( true );
    END;

    if KEQU( Str[1 for 6], "MINUTE" ) then 	! as in "EVERY nTH MINUTE";
    BEGIN
      if Cycle > 1439 then
      BEGIN
        S$ErrMSG_ "MINUTES MUST NOT BE > 1439";
	return( false );
      END;
      SetCode( 0,TypT,0,Cycle,ENDCon );
      ! SREF( Cycle );
      return( true );
    END;

    if KEQU( Str[1 for 4], "HOUR" ) then 	! as in "EVERY nTH HOUR";
    BEGIN
      if Cycle > 23 then
      BEGIN
        S$ErrMSG_ "HOURS MUST NOT BE > 23";
	return( false );
      END;
      SetCode( 0,TypT,0,Cycle * 60,ENDCon );
      ! SREF( Cycle * 60 );
      return( true );
    END;

    S$ErrMSG_ S$ErrMSG & "(" & Str & ")" &
		 "EXPECTED 'MONTH' OR 'DAY' OR A DAY OF THE WEEK";
    return( false ); 			! Fall-through to here means error ;

  END; 						! if validnum;

  if KEQU( Str[ 1 for 5 ],"MONTH" ) then 		! as "EVERY MONTH";
  BEGIN 
    if not B$Coded then 	! whole exp is "EVERY MONTH" or "MONTH";
    BEGIN
      if Cycle = 0 then
        Cycle_ 1; 		! "MONTH" becomes "EVERY MONTH" ;
      SetCode( 0,TypN,Cycle,1,ENDCon );
    END
    else
    BEGIN
      if B$DayCyc then ! second half of exp as: "nTH DAY EVERY [cycle] MONTHS";
        SetCode( 0,TypN,Cycle,I$DayCyc,ENDCon )
      else 	    ! it's the second unit of exp as "3RD MOND OF EVERY MONTH";
        SetCode( 0,0,1,0,ENDCon );
    END;
    B$MonUnit_ true; 		! second unit of 2 unit exp must be month unit;
    return( true );
  END;
  
  if ValidDOW( Str ) then 			! as in "EVERY MONDAY" (  );
  BEGIN
    if Cycle = 0 then ! Only the next DOW is required so figure the date ;
    BEGIN
      base_ TodaysIntrnDat;
      TGTday_ DayToNum( Str );
      BaseDay_ GetDOW( CvSDat( base ) );
      BaseDayNum_ DayToNum( BaseDay );
      if BaseDayNum = TGTday then
        diff_ 0
      else
        if BaseDayNum < TGTday then
          diff_ abs( BaseDayNum - TGTday )
        else
          diff_ 7 - ( BaseDayNum - TGTday );
      NextDate_ base + diff; 
      SetCode( 0,TypS,0,0,ENDCon );
      if NextDate = base then
        SREF( NextDate + 7 )
      else
        SREF( NextDate );
      B$MDYUnit_ true;
      return( true );
    END
    else
    BEGIN
      SetCode( Cycle,TypW,0,DayToNum( Str ),ENDCon );
      return( true );
    END
  END;

  if KEQU( Str[1 for 3], "DAY" ) then 			! as in "EVERY DAY" ;
  BEGIN
    if cycle = 0 then 				! need to know how many days;
    BEGIN
      S$ErrMSG_ "NEED HOW MANY DAYS OR EVERY DAY";
      return( false );
    END
    else
    BEGIN
      B$DayCyc_ true; 			   ! a cyclic day unit has been coded;
      SetCode( 1,TypN,0,cycle,ENDCon );
      return( true );
    END
  END;
  return( false );		! Valid Unit will never get to this point ;
END; ! proc UNIT;

simple integer procedure CalcTimFrac( string ds );
BEGIN
  integer HOUR,MINUTE,SECOND,brkr,jift;
  HOUR_ intscan( ds,brkr );
  MINUTE_ intscan( ds,brkr );
  SECOND_ intscan( ds,brkr );
  jift_ (HOUR * 216000) + (MINUTE * 3600) + (SECOND * 60);
  start!code
    move  2,jift;
    setz  1,;
    ashc  1,18;
    div   1,[5184000];
  END
END;

simple boolean procedure ValidExpression( string S;
					  reference string S$ErrMSG
					);
! returns true with S$ErrMSG = null if a valid expression was passed;
BEGIN
  string SS;
  if B$Trace then print( crlf,"Exp:",S );
  SS_ null;
  while true do				 ! get rid of leading blanks;
  BEGIN
    if EQU( S[1 for 1] , " " ) then
      S_ S[ 2 to inf ]
    else
      done;
  END;

  while not UNIT( SS,S$ErrMSG ) do
  BEGIN 
    if equ( S,null ) and equ( S$ErrMSG,null )  then 
    BEGIN
      if equ( SS[ inf for 1 ]," " ) then
        SS_ SS[ 1 to inf - 1 ];
      if ValidTimeStr( SS ) or ValidNum( SS ) then
      BEGIN
        STIM( CalcTimFrac( SS ) );
        B$MonUnit_ B$MDYUnit_ true;
        return( true );
      END
      else
      BEGIN
        ! if what was passed to UNIT was not enough for a;
        ! valid unit and there is none left then must be 86;
        S$ErrMSG_ "INVALID FRAGMENT (A)";
      END
    END;
    SS_ SS & LopWord( S ) & " "; ! add next word to string, then retry UNIT;
    if EQU( S$ErrMSG,null ) then ! string passed to UNIT was not enough to be
      continue                ! valid but no detectable error yet.;
    else
      return( false ); ! error;
  END;

  if B$Trace then print( crlf );
  B$DayCyc_ false;
  SS_ null;
  if length( S ) > 0 then ! must be another unit ( better be a month unit ) .;
  BEGIN ! check second unit of expression;
    B$MonUnit_ false; ! initialize,  B$MonUnit will become true if the next;
		      !  unit found is a month unit;
    while not UNIT( SS,S$ErrMSG ) do 		! same routine as above;
    BEGIN 
      if equ( S,null ) and equ( S$ErrMSG,null )  then 
      BEGIN
        if equ( SS[ inf for 1 ]," " ) then
          SS_ SS[ 1 to inf - 1 ];
        if ValidTimeStr( SS ) or ValidNum( SS ) then
        BEGIN
          if not B$Coded then
            print( crlf,"%" );
          STIM( CalcTimFrac( SS ) );
          B$MonUnit_ B$MDYUnit_ true;
          return( true );
        END
        else
        BEGIN
          ! if what was passed to UNIT was not enough for a;
          ! valid unit and there is none left then must be 86;
          S$ErrMSG_ "INVALID FRAGMENT (B)";
        END
      END;
      SS_ SS & LopWord( S ) & " ";
      if EQU( S$ErrMSG,null ) then
        continue
      else
        return( false ); 			! error detected in UNIT;
    END;

    if B$Trace then print( crlf );
    if NOT B$MonUnit then
    BEGIN
      S$ErrMSG_ "SECOND UNIT IN TWO UNIT EXPRESION MUST BE A MONTH UNIT";
      return( false );
    END
  END; 					! END checking second unit;

  if equ( S[ inf for 1 ]," " ) then
    S_ S[ 1 to inf - 1 ];
  if length( S ) > 0 then ! can't be more than 2 unit to the expression;
  BEGIN
    if ValidTimeStr( S ) or ValidNum( S ) then
    BEGIN
      if not B$Coded then
        print( crlf,"@" );
      STIM( CalcTimFrac( S ) );
      return( true );
    END
    else
    BEGIN
      S$ErrMSG_  "UNKNOWN TERMS: <" & s & ">";
      return( false );
    END
  END
  else
  BEGIN
    return( true );
  END
END; 						! proc ValidExpression ;

boolean procedure ValidGroup( string S;
			      reference string S$ErrMSG
			    );
! gets all up to next "AND" or the END of expression ;
BEGIN 
  integer ModDate,ModTime,ModNum;
  string SS,NextWord,LatestMod;
  if B$Trace then print( crlf,"Group:",S );
  SS_ LatestMod_ null;
  NextWord_ LopWord( S );
  while true do 			! get all until a modifier or END;
  BEGIN 
    if ValidModifier( NextWord ) then	! mod found;
    BEGIN
      if EQU( SS,null ) then
      BEGIN 				! indicates a mod. not without date.;
        S$ErrMSG_ "DOUBLE MODIFIERS"; 
        return( false );
      END
      else
      BEGIN
        LatestMod_ NextWord; 		! store the modifier;
        done; 			! leave block to evaluate SS as expression;
      END 			! else;
    END
    else
    BEGIN
      SS_ SS & NextWord & " ";
      if length( S ) = 0 then
        done
      else
        NextWord_ LopWord( S );
    END
  END;  		! while true;

  if NOT ValidExpression( SS,S$ErrMSG ) then ! evaluate what we've got ;
  BEGIN
    S$ErrMSG_ S$ErrMSG & " INVALID EXPRESSION!";
    return( false );
  END
  else
  BEGIN
    if length( S ) = 0 then  ! if END of string;
    BEGIN
      if EQU( LatestMod,null ) then
      BEGIN
        if GREF = 0 then
          SREF( TodaysIntrnDat ); ! make sure ref gets set to something ;
        I$Position_ I$Position + D!Length;		! add all on;
        If I$Position = E!Length then
        BEGIN
          S$ErrMSG_ "TOO MANY EXPRESSIONS. MAX = " & cvs( MaxExps );
          return( false );
        END
        else
          return( true );
      END
      else
      BEGIN		! some junk left over in string so something wrong;
        S$ErrMSG_ "INVALID DATE";
        return( false );
      END
    END
  END;

  if GREF = 0 then
    SREF( TodaysIntrnDat ); 	! make sure ref gets set to something ;
  I$Position_ I$Position + D!Length;     ! ready for a new expression ;
  If I$Position = E!Length then
  BEGIN
    S$ErrMSG_ "TOO MANY EXPRESSIONS. MAX = " & cvs( MaxExps );
    return( false );
  END;
  S_ LatestMod & " " & S;    ! modifier which caused break is Put back;

  ! there is more to expression after a mod so get it;
  while true do
  BEGIN
    SS_ LatestMod_ null;
    while true do
    BEGIN 
      NextWord_ LopWord( S );
      if ValidModifier( NextWord ) then
      BEGIN
        if B$Trace then 				! show the modifier ;
          print( NextWord,":" );
        if EQU( LatestMod,null ) then
        BEGIN
          LatestMod_ NextWord;
          ! if ModUsedBefore( LatestMod ) then
            return( false );
          if KEQU( LatestMod,"AND" ) then  ! 	!!!!! ;
          BEGIN
            NextWord_ LopWord( S );
            if ValidModifier( NextWord ) then
              LatestMod_ NextWord
            else
              S_ S & " " & NextWord;
          END;
          case LatestMod[1 for 1] of
          BEGIN
            [ "A" ] ModNum_ ( AftCon );
            [ "B" ] ModNum_ ( BefCon );
            [ "S" ] ModNum_ ( StaCon );
            [ "U" ] ModNum_ ( UntCon );
            [ "E" ] ModNum_ ( ExcCon )
          END;
          if length( NextWord ) > 0 then
	  BEGIN
            continue
	  END
          else
	  BEGIN
            if EQU( SS,null ) then
            BEGIN
              S$ErrMSG_ "CONTIGUOUS MODIFIERS";
              return( false ); ! ##;
            END
            else
	    BEGIN
              done;
	    END
	  END
        END  		 ! if EQU( LatestMod,null );
        else
        BEGIN
          LatestMod_ NextWord;
          S_ LatestMod & " " & S;
          done;
        END
      END 				! if validmodifier;
      else
      BEGIN
        SS_ SS & " " & NextWord;
        if EQU( LatestMod,null ) then
        BEGIN
          S$ErrMSG_ "MODIFIER EXPECTED";
          return( false ); 
        END
        else
	BEGIN
          if length( S ) > 0 then
            continue
          else
            done;
	END
      END
    END;

    if ValidExpression( SS,S$ErrMSG ) then
    BEGIN 
      ModDate_ GREF;
      ModTime_ GTIM;
      if length( S )  > 0 then
      BEGIN 
        B$Coded_ true;
        I$Position_ I$Position - D!Length; 	! back up ;
        if ModNum = AftCon then			! if true, set ref date to mod;
        BEGIN
          SREF( ModDate );
          STIM( ModTime );
        END
        else
        BEGIN
          PutConn( ModNum ) ;			! set the connector ;
          I$Position_ I$Position + D!Length;
          if GREF = 0 then
            SREF( TodaysIntrnDat );
        END;
        I$Position_ I$Position + D!Length;
        If I$Position = E!Length then
        BEGIN
          S$ErrMSG_ "TOO MANY EXPRESSIONS. MAX = " & cvs( MaxExps );
          return( false );
        END
        else
	BEGIN
          PutConn( 0 );
	END;
        continue;
      END
      else
      BEGIN 		! if there is 1 mod it is done here else this is 2nd ;
        if ModNum < 4 then
	BEGIN
          if Not B$MDYUnit then
          BEGIN
            print( crlf,"ModNum=<",ModNum,">" );
            S$ErrMSG_ "NEED A DATE WITH AFTER/UNTIL" & crlf &
                      "  EX: STARTING MMM DD, YYYY .";
            return( false );                
          END
	END;
        B$Coded_ true;
        I$Position_ I$Position - D!Length;
        if ModNum = AftCon then		! if true, set ref date to mod;
        BEGIN
          SREF( ModDate );
          STIM( ModTime );
        END
        else
        BEGIN
          PutConn( ModNum ) ;		! set the connector ;
          I$Position_ I$Position + D!Length;
          if GREF = 0 then
            SREF( TodaysIntrnDat );
        END;
    
        I$Position_ I$Position + D!Length;
        If I$Position = E!Length then
        BEGIN
          S$ErrMSG_ "TOO MANY EXPRESSIONS. MAX = " & cvs( MaxExps );
          return( false );
        END
        else
        BEGIN
          PutConn( 0 );
          return( true );
        END
      END
    END						! if valid expression;
    else
    BEGIN
      return( false );
    END
  END 						! while true;
END; 						! ValidGroup;

simple boolean procedure ParsedOK( string S;
				   reference string S$ErrMSG
				 );
BEGIN
  string Onestring,SS;
  integer ANDcount;
  if B$Trace then print( crlf,"ParsedOK:",S );
  ANDcount_ HowMany( S,"AND" );
  while true do
  BEGIN
    Onestring_ S_ " " & S; 	! first word not a modifier so replace.;
    if ANDcount > 0 then
      Onestring_ LopUpto( S,"AND" ); 	  ! get everthing upto next "and";
    if ValidGroup( Onestring,S$ErrMSG ) then 	! should be a valid group;
    BEGIN
      if ANDcount > 0 then 		! there is another "and" ahead;
      BEGIN
        B$Coded_ true;
        I$Position_ I$Position - D!Length;
        PutConn( AndCon ) ;
        I$Position_ I$Position + D!Length;
      END;
      ANDcount_ ANDcount - 1;
      if ANDcount < 0 then
        return( true )
      else
        continue;
    END
    else
    BEGIN
      return( false );
    END
  END 						! while true;
END;

simple procedure express;
BEGIN
  integer Multiplier,MoMultiplier,Body,NumExps,i,j,refDate,
  Type,Connector,ExpS,TimFrac,Minutes,Hours;
  I$Position_ E!Descriptor;
  if GetConn = 0 then
  BEGIN
    print( "NO REQUEST HAS BEEN ENTERED",crlf );
    return;
  END;
  for I$Position_ E!Descriptor step D!Length until E!Length - 1 do
  BEGIN
    Multiplier_ GetMult;
    type_ GetType;
    MoMultiplier_ GetMoMult;
    body_ GetBody;
    Connector_ GetConn;
    refDate_ GREF;
    if EQU( type, TypW ) then
    BEGIN
      if MoMultiplier > 0 then
      BEGIN
        print(      if Multiplier = 1 then "THE FIRST "
                else if Multiplier = 2 then "THE SECOND "
                else if Multiplier = 3 then "THE THIRD "
                else if Multiplier = 0 then " ONCE ONLY:A "
                else if Multiplier = 9 then "THE LAST "
                else  "THE " & cvs( Multiplier ) & "TH " 
              );
        print( WkDay[ body ] );
        print(      if MoMultiplier = 1 then " OF EVERY MONTH "
                else if MoMultiplier = 2 then " OF EVERY OTHER MONTH"
                else if MoMultiplier = 3 then " OF EVERY THIRD MONTH"
                else if MoMultiplier > 3 then " OF EVERY " 
                                          & cvs( MoMultiplier ) & "TH MONTH"
                else null
              );
      END
      else
      BEGIN
        print(      if Multiplier = 1 then "EVERY "
                else if Multiplier = 2 then "EVERY OTHER "
                else if Multiplier = 0 then ""
                else if Multiplier = 3 then "EVERY 3RD "
                else "EVERY " & cvs( Multiplier ) & "TH "
              );
        print( WkDay[ body ] );
      END
    END;

    if type = TypN then
    BEGIN
      if MoMultiplier > 0 then
      BEGIN
        print( "THE " );
        print(       if body = 32 then "LAST DAY " 
                else if body = 1 then "FIRST DAY " 
                else if body = 2 then "SECOND DAY " 
                else if body = 3 then "THIRD DAY "
                else cvs( body ) & "TH DAY "
              );
        print(      if MoMultiplier = 1 then "OF EVERY MONTH "
                else if MoMultiplier = 2 then "OF EVERY OTHER MONTH"
                else if MoMultiplier = 3 then "OF EVERY THIRD MONTH"
                else if MoMultiplier > 3 then "OF EVERY " 
                     & cvs( MoMultiplier ) & "TH MONTH"
                else null
              );
      END
      else
      BEGIN
        print( "EVERY " );
        print(       if body = 1 then "DAY " 
                    else if body = 2 then "SECOND DAY " 
                    else if body = 3 then "THIRD DAY "
                    else cvs( body ) & "TH DAY "
              );
      END
    END;

    if type = TypT then
    BEGIN
      Minutes_ body;
      Hours_ Minutes Div 60;
      Minutes_ Minutes mod 60;
      if Hours > 0 then
      BEGIN
        print( "EVERY " , Hours , " HOURS" );
        if Minutes > 0 then
        BEGIN
          print( " AND " , Minutes , " MINUTES" );
        END
      END
      else
      BEGIN
        print( "EVERY ", Minutes ," MINUTES" );
      END;
      print( " BASED ON " );
      print( CvSTim( GTIM ) );
    END;

    if type = TypS then
    BEGIN
      if refDate = 262143 then
        print( "STARTUP" )
      else
        print( CvSDat( refDate ) );
    END;

    if not type = TypT and
       not refDate = 262143 then
    BEGIN
      TimFrac_ GTIM;
      print( if TimFrac = 0 then " AT MIDNIGHT"
            else " AT " & CvsTim( TimFrac )
            );
    END;

    if GREF > TodaysIntrnDat and
        not type = TypS       then
      print( " AFTER ",CvSDat( GREF ) );

    case connector of 
    BEGIN
      [  AndCon  ] print( " AND " );
      [  StaCon  ] print( " STARTING: " );
      [  BefCon  ] print( " BEFORE: " );
      [  ExcCon  ] print( " EXCEPT: " );
      [  UntCon  ] print( " UNTIL: " );
      [  ENDCon  ] print( "." );
      else 	! event of an unknown connector ( should never happen );
        print( crlf," ?" ,connector,"?",crlf,"              " )
    END;
    if Connector = ENDCon then
      done;
  END; ! for;
  print( crlf );
END; ! proc express;

require "(helgem)figur.sai" source!file;
require "(helgem)CurTim.sai" source!file;
require "(carl)jque.req" source!file;

simple procedure Display;
BEGIN
  string date,DOW,stop;
  integer baseDT,dis,DatsDisplayed;
  I$Position_ E!Descriptor;
  if GetConn = 0 then
  BEGIN
    print( "NO REQUEST HAS BEEN ENTERED",crlf );
    return;
  END;    
  DatsDisplayed_ 0;
  baseDT_ !xwd( TodaysIntrnDat,CalcTimFrac( CurrentTime ) );
  while true do
  BEGIN
    DatsDisplayed_ DatsDisplayed + 1;
    if B$Trace then
      print( crlf,"baseDT:",!lh( baseDT ),"-",CvSTim( !rh( baseDT ) ) );
    dis_ NextRun( Current,baseDT ); ! returns 0 if no further dates;
    baseDT_ dis;
    if dis = 0 or !lh( dis ) > 13148 then ! no dates after 12/31/1999;
    BEGIN
      print( crlf,"no further dates.",crlf );
      done;
    END;
    Date_ CvSDat( !lh( dis ) );
    DOW_ getDOW( Date ); ! figure the day of the week;
    print( date," ",DOW );
    print( "          "[ 1 for ( 10 - length( DOW ) ) ] );
    print( " AT ",CvSTim( !rh( dis ) ) );
    if B$Trace then stop_ inchwl;
    if DatsDisplayed = 10 then 
    BEGIN
      print( " - enter a char for more dates else <cr> only." );
      if equ( inchrw,#cr ) then
        return
      else
        DatsDisplayed_ 0;
    END;
    print( crlf );
  END
END;

simple procedure Look;
BEGIN
  integer i;
  if GetConn = 0 then
    print( "NO REQUEST HAS BEEN ENTERED",crlf )
  else
  BEGIN
    for I$Position_ E!Descriptor step D!Length
    until ( E!Length - D!Length - 1 ) do
    BEGIN
      print( "/T  bbbbC      ( time )" );
      if GetConn = ENDCon then done;
    END;
    print( "/" );
    print( crlf );
    for I$Position_ E!Descriptor step D!Length
    until ( E!Length - D!Length - 1 ) do
    BEGIN
      print( GetMult    );
      print( GetType    );
      setformat( -2,2 );
      print( GetMoMult  );
      setformat( -4,4 );
      print( GetBody    );
      setformat( 0,7 );
      print( GetConn    );
      setformat( -5,5 );
      print( GREF );
!     print( !lh( Current[ I$Position + D!Daytime ] ) );
!     setformat( -6,6 );
      print( "," );
      print( CvSTim( GTIM ) );
      setformat( 0,7 );
      if GetConn = ENDCon then done;
    END
  END;
  print( crlf );
END;

simple procedure Test;
  if GetConn = 0 then
  BEGIN
    print( "NO REQUEST HAS BEEN ENTERED",crlf );
    return;
  END
  else
  BEGIN
    express;
    Display;
  END;

simple procedure TrialCode;
! user want's to type his own date code;
BEGIN
  integer toda;
  string EStr,RD;
  toda_ TodaysIntrnDat;
  while true do
  BEGIN
    print( crlf,"type sample code as WTMMDDX " );
    print( crlf,"                   :" );
    if equ( EStr_ inchwl , null ) then
      done;
    if length( EStr ) = 7 then 
    BEGIN 
      PutMult( cvd( EStr[ 1 for 1 ] ) ) ;
      PutType( cvd( EStr[ 2 for 1 ] ) ) ;
      PutMoMult( cvd( EStr[ 3 for 2 ] ) );
      PutBody( cvd( EStr[ 5 for 2 ] ) ) ;
      PutConn( cvd( EStr[ 7 for 1 ] ) ) ;
      print( crlf,"type reference date as nnnnn [today]" );
      print( crlf,"                      :" );
      if equ( RD_ inchwl, null ) then
        SREF( toda )
      else
        SREF( cvd( RD ) );
      print( "Code with reference date (",CvSDat( toda ),"): " );
      for I$Position_ E!Descriptor step D!Length
        until ( E!Length - D!Length - 1 ) do
        BEGIN
          print( GetMult );
          print( GetType    );
          setformat( -2,2 );
          print( GetMoMult  );
          print( GetBody    );
          setformat( 0,7 );
          print( GetConn    );
          setformat( -5,5 );
          print( !lh( Current[ I$Position + D!Daytime ] )," " );
          ! print( !rh( Current[ I$Position + D!Daytime ] )," (date,time)" );
          setformat( 0,7 );
          print( crlf );
          if GetConn = ENDCon then done;
        END;
      done;
    END
    else
      print( #bel,"must be 7 characters, try again" );
    print( crlf );
  END
END;

simple string procedure GetComFrTerm(string PromptLine);
! prompts with PromptLine and returns user response.;
! Only certain character are echoed;
BEGIN
  string line,Response;
  line_ Response_ null;
  print(crlf,PromptLine," " ); 		! sEND the prompt to the term;
  clrbuf;
  auxclr(-1,memory['200],'64);		! turn off term echo;
  while true do
  BEGIN
    Response_ inchrw; 			! get one legal char;
    if Response = '15 then 
      if length( line ) = 0 then
      BEGIN
        print(crlf,PromptLine," " ); 		! try again ;
        line_ null;
        clrbuf;
        continue;
      END
      else
        done;
    if ( Response = #bs    or   	! implement backspace/delete;
          Response = #del ) then
    BEGIN
      if not equ( line,null ) then 	! but don't erase prompt ;
      BEGIN
        print( #bs & " " & #bs ); 	! bs/del on term;
        line_ line[ 1 to inf - 1 ];  	! remove from END of line;
      END
    END
    else
    BEGIN
      print( Response ); 		! since it is legal, echo it now;
      line_ line & Response;		! add legal char to line;
    END
  END;
  auxclr(-1,memory['000],'64);		! turn echo back on;
  if EQU( Line,null ) then		
    return( null ) 			! return null if <cr> (only) is typed;
  else
    return( upper( line ) );		! return what weve got in uppercase;
END; ! GetComFrTerm;

simple integer procedure GetCommand( string prompt );
! validates command words such as "DATES" or "EXPRESS";
! if a correct abbreviation is typed, the full word will be substituted;
BEGIN
  integer i;
  string Response,Word;
  S$ListParameters_ null;
  while true do
  BEGIN
    Response_ GetComFrTerm( prompt );
    Word_ LopWord( Response ); ! get first word sans trailing blanks;
    for i_ 0 upto NumCmds - 1 do		! check array for match;
    BEGIN
      if KEQU( Word[ 1 for length( MinCom[ i ] ) ] , MinCom[ i ] ) then
      BEGIN
        if KEQU( Word,Commands[ i ][ 1 for length( Word ) ] ) then
        BEGIN	! match found, fill in what operator omitted;
! print( crlf,"remainder:<",response,">" );
          if i = 7 then ! "LIST" ;
	    S$ListParameters_ Response;
          print( Commands[ i ][ ( length( Word ) + 1 ) to inf ],crlf );
          return( i );
        END
      END
    END;
    print( crlf,'42 & Word & '42 & " IS NOT A COMMAND",crlf );
  END
END;

simple integer procedure Validate( string array AR ;
				   reference string S ;
				    integer ArrSize
				 );
BEGIN
  integer i,SavI ;string Str,Sav ; boolean MatchF ;
  Sav_ S; SavI_ -1; MatchF_ false ; Str_ null;
  if equ( S,null ) then
    return( 0 );
  while true do
  BEGIN "add to str"
    if length( S ) then
    BEGIN
      Str_ Str & Lop( S );
      MatchF_ false;
      for i_ 0 upto ArrSize do
      BEGIN
        if KEQU( Str,AR[ i ][ 1 for length( Str ) ] ) then
        BEGIN 	
          SavI_ i;
          if MatchF then
            continue "add to str" 
          else
            matchF_ true;
        END 
      END;
      if not MatchF then
      BEGIN
        S_ Sav;
        return( -1 );
      END
    END
    else
    BEGIN
      if SavI geq 0 then
      BEGIN
        S_ AR[ SavI ];
        return( SavI );
      END
      else
      BEGIN
        S_ Sav;
        return( -1 );
      END
    END
  END "add to str"; 
END;

simple procedure GetOptions;
BEGIN "getoptions"
  integer  ScanToBlank,OptNum,BrkChar,Num,BP,BPI;
  integer TimeLimit,TRULimit,LogLimit,Dependency;
  string Response,Str;
  string Labl,Log,Dispose,Mail,Spool,Mailer,Restart,Unique,Parameters,
          Run,Detach,TMPNAME;
  integer LablNum,LogNum,DisposeNum,MailNum,SpoolNum,
  MailerNum,RestartNum,UniqueNum,RunNum,DetachNum,ParametersNum;

simple procedure HelpRoutine;
BEGIN
  integer i;
  print( crlf,"     OPTIONS          PARAMETERS [CURRENT SETTING]" );
  print( crlf,"     -------          ----------" );

  print( crlf,     "      LOG              " );
  for I_ 0 upto NumLog - 1 do
  BEGIN
    if i = LogNum then
      print( "[",ARLog[ i ],"], " )
    else
      print( ARLog[ i ],", " );
  END;

  print( crlf,     "      DISPOSE          " );
  for I_ 0 upto NumDispose- 1  do
  BEGIN
    if i = DisposeNum then
      print( "[",ARDspos[ i ],"], " )
    else
      print( ARDspos[ i ],", " );
  END;

  print( crlf,     "      MAIL             " );
  for I_ 0 upto NumMail- 1  do
  BEGIN
    if i = MailNum then
      print( "[",ARMail[ i ],"], " )
    else
      print( ARMail[ i ],", " );
  END;

  print( crlf,     "      MAILER           " );
  for I_ 0 upto NumMailer- 1  do
  BEGIN
    if i = MailerNum then
      print( "[",ARMailer[ i ],"], " )
    else
      print( ARMailer[ i ],", " );
  END;

  print( crlf,     "      RESTART          " );
  for I_ 0 upto NumRestart- 1  do
  BEGIN
    if i = RestartNum then
      print( "[",ARRstrt[ i ],"], " )
    else
      print( ARRstrt[ i ],", " );
  END;

  print( crlf,     "      RUN              " );
  for I_ 0 upto NumRun- 1  do
  BEGIN
    if i = RunNum then
      print( "[",ARRun[ i ],"], " )
    else
      print( ARRun[ i ],", " );
  END;

  print( crlf,     "      DETACH           " );
  for I_ 0 upto NumDetach- 1  do
  BEGIN
    if i = DetachNum then
      print( "[",ARDetach[ i ],"], " )
    else
      print( ARDetach[ i ],", " );
  END;

  print( crlf );
  print( crlf,     "      LABEL            " );
  if equ( labl,null ) then
    print( "[null]" )
  else
    print( "[",Labl,"]" );

  print( crlf,     "      TIMELIMIT        ", "[",TimeLimit,"]" );
  print( crlf,     "      LOGLIMIT         ", "[",LogLimit,"]" );
  print( crlf,     "      TRULIMIT         ", "[",TRULimit,"]" );
  print( crlf,     "      DEPENDENCY       ", "[",Dependency,"]" );
  print( crlf,     "      PARAMETERS       " );

  Parameters_ null;
  BP_ Point( 7, Current[ E!Parameters ], -1 );
  For BPI_ 1 upto E!ParLength do
    Parameters_ Parameters & ILDB( BP );
  if ( length( Parameters ) = 0 ) then
    print( "[none]" )
  else
    print( "[",Parameters,"]" );
END;

  Labl_ Parameters_ null;
  TimeLimit_ 60;
  LogNum_ JL$Supersede;
  Mail_ JM$Always;
  TRULimit_ LogLimit_ Dependency_ 0;
  Spool_ Mailer_ Restart_ Unique_ RunNum_ DetachNum_ 0;
  DisposeNum_ MailNum_ SpoolNum_ MailerNum_ RestartNum_ UniqueNum_ 0;
  setbreak( ScanToBlank_ getbreak," "&crlf," ","ins" );
  while true do
  BEGIN
    Response_ Prompt( "OPTIONS: " );
    if equ( Response,null ) then
      done;
    Str_ LopWord( Response );
    OptNum_ Validate( Options,Str,NumOptns - 1 );
    case OptNum of
    BEGIN
      [ 0 ]  BEGIN
               Labl_ LopWord( Response );
               Labl_ Labl[ 1 for 6 ];
             END;
      [ 1 ]  BEGIN
               TimeLimit_ intscan( Response,BrkChar );
               if BrkChar = -1 then
                 TimeLimit_ 60;
             END;
      [ 2 ]  BEGIN
               TRULimit_ intscan( Response,BrkChar );
             END;
      [ 4 ]  BEGIN
               LogLimit_ intscan( Response,BrkChar );
             END;
      [ 5 ]  BEGIN
               Dependency_ intscan( Response,BrkChar );
             END;
      [ 6 ]  BEGIN
               Log_ LopWord( Response );
               LogNum_ Validate( ARLog,Log,NumLog - 1 );
               if LogNum = -1 then
               BEGIN
                 print( Log," IS NOT A VALID PARAMETER FOR ",
                 		options[ OptNum ]," OPTION." );
                 LogNum_ 0;
               END
             END;
      [ 7 ]  BEGIN
               Dispose_ LopWord( Response );
               DisposeNum_ Validate( ARDspos,Dispose,NumDispose - 1 );
               if DisposeNum = -1 then
               BEGIN
                 print( Dispose," IS NOT A VALID PARAMETER FOR ",
                 		options[ OptNum ]," OPTION." );
                 DisposeNum_ 0;
               END
             END;
      [ 8 ]  BEGIN
               Mailer_ LopWord( Response );
               MailerNum_ Validate( ARMailer,Mailer,NumMailer - 1 );
               if MailerNum = -1 then
               BEGIN
                 print( Mailer," IS NOT A VALID PARAMETER FOR ",
                 		options[ OptNum ]," OPTION." );
                 MailerNum_ 0;
               END
             END;
      [ 9 ]  BEGIN
               Spool_ LopWord( Response );
               SpoolNum_ Validate( ARSpl,Spool,NumSpool - 1 );
               if SpoolNum = -1 then
               BEGIN
                 print( Spool," IS NOT A VALID PARAMETER FOR ",
                 		options[ OptNum ]," OPTION." );
                 SpoolNum_ 0;
               END
             END;
      [ 10 ]  BEGIN
                Mail_ LopWord( Response );
                MailNum_ Validate( ARMail,Mail,NumMail - 1 );
                if MailNum = -1 then
                BEGIN
                  print( Mail," IS NOT A VALID PARAMETER FOR ",
                  		options[ OptNum ]," OPTION." );
                  MailNum_ 0;
                END
              END;
      [ 11 ]  BEGIN
                Restart_ LopWord( Response );
                RestartNum_ Validate( ARRstrt,Restart,NumRestart - 1 );
                if RestartNum = -1 then
                BEGIN
                  print( Restart," IS NOT A VALID PARAMETER FOR ",
                  		options[ OptNum ]," OPTION." );
                  RestartNum_ 0;
                END
              END;
      [ 12 ]  BEGIN
                Unique_ LopWord( Response );
                UniqueNum_ Validate( ARUniq,Unique,NumUnique - 1 );
                if UniqueNum = -1 then
                BEGIN
                  print( Unique," IS NOT A VALID PARAMETER FOR ",
                  		options[ OptNum ]," OPTION." );
                  UniqueNum_ 0;
                END
              END;
      [ 13 ]  BEGIN
                Parameters_ Response;
                If ( length( Parameters ) > E!ParLength ) then
                  print( "PARAMETERS MUST BE 1-",E!ParLength,
                         " CHARACTERS LONG" )
                else
                BEGIN
                  BP_ Point( 7, Current[ E!Parameters ], -1 );
                  For BPI_ 1 upto E!ParLength do 
                    IDPB( lop( Parameters ), BP );
                END
              END;
      [ 14 ]  BEGIN
                HelpRoutine;
              END;
      [ 15 ]  BEGIN
                HelpRoutine;
              END;
      [ 16 ]  BEGIN
                Return;
              END;
      [ 17 ]  BEGIN
                Run_ LopWord( Response );
                RunNum_ Validate( ARRstrt,Run,NumRun - 1 );
                if RunNum = -1 then
                BEGIN
                  print( Run," IS NOT A VALID PARAMETER FOR ",
                  		options[ OptNum ]," OPTION." );
                  RunNum_ 0;
                END
              END;
      [ 18 ]  BEGIN
                Detach_ LopWord( Response );
                DetachNum_ Validate( ARRstrt,Detach,NumDetach - 1 );
                if DetachNum = -1 then
                BEGIN
                  print( Detach," IS NOT A VALID PARAMETER FOR ",
                                  options[ OptNum ]," OPTION." );
                  DetachNum_ 0;
                END
              END;
      [ 19 ]  BEGIN
                TMPNAME_ CvSix( Response );
              END;
      else    BEGIN
                print( "UNRECOGNIZED OPTION - TYPE H FOR HELP" );
              END    
    END ! case ;

  END; ! while ;

  Current[ E!Label ]_ CvSix( Labl );
  Current[ E!TruLim ]_ TRULimit;
!  DPB( TMPNAME lsh -18,  PTmpN( Current[ F!Ext ] ) ); 
  DPB( TMPNAME lsh -18,  PTmpN( Current[ E!Descriptor + F!Ext ] ) ); 
  DPB( LogLimit,         PLogL( Current[ E!LogLim ] ) ); 
  DPB( TimeLimit,        PTimL( Current[ E!LogLim ] ) ); 
  DPB( 0,                PStat( Current[ E!Status ] ) );
  DPB( 0,                PProc( Current[ E!Status ] ) ); 
  DPB( Dependency,       PDepL( Current[ E!Status ] ) ); 
  DPB( 0,                PSeq(  Current[ E!Status ] ) ); 
  DPB( LogNum,           PLog(  Current[ E!Action ] ) );
  DPB( DisposeNum,       PDisp( Current[ E!Action ] ) ); 
  DPB( SpoolNum,         PSpl(  Current[ E!Action ] ) ); 
  DPB( MailNum,          PMail( Current[ E!Action ] ) ); 
  DPB( MailerNum,        PMPrg( Current[ E!Action ] ) ); 
  DPB( RestartNum,    PRestart( Current[ E!Action ] ) ); 
  DPB( UniqueNum,        PUniq( Current[ E!Action ] ) ); 
END "getoptions";

simple procedure InsertFN( integer array ENtr;
			   string FiName;
			   integer position
			 );
! places username into array positions position+F!User - position+F!User+1,
filename into position + F!Name, and extention in position + F!Ext;
BEGIN
  string Un,Fn,Ext,Dv;
  Dv_ Un_ Fn_ Ext_ null;
  if not Dv then
    Dv_ Device;
  ENtr[ position + F!Device ]_ CvSix( Dv );
  if EQU( FiName[ 1 for 1 ],"(" ) then
  BEGIN
    FiName_ FiName[ 2 to inf ];
    while not equ( FiName[ 1 for 1 ], ")" ) do
      Un_ Un & lop( FiName );
    FiName_ FiName[ 2 to inf ];
  END
  else
  BEGIN
    Un_      cvxStr( calli( !xwd( -1,!GTUNM ),calli!gettab ) );
    Un_ Un & cvxStr( calli( !xwd( -1,!GTUN1 ),calli!gettab ) );
  END;
  Entr[ position + F!User ]_ cvsix( Un[ 1 for 6 ] );
  Entr[ position + F!User + 1 ]_ cvsix( Un[ 7 for 6 ] );
  while not equ( FiName[ 1 for 1 ], "." ) and Length( FiName ) > 0 do
    Fn_ Fn & lop( FiName );
  Entr[ position + F!Name ]_ cvsix( Fn );
  if length( FiName ) > 0 then
    Ext_ FiName[ 2 to inf ];
  Entr[ position + F!Ext ]_ cvsix( Ext );
END;

simple integer procedure GeChan(string NameForTheNewFile); 
! create a new file for binary i/o;
BEGIN
  integer eof,NewFilChan;
  open(NewFilChan_getchan,"DSK",'14,0,4,0,0,eof);
  enter(NewFilChan,NameForTheNewFile,eof);
  if eof then
  BEGIN
    print( "Can't open ",NameForTheNewFile,crlf );
    return( -1 );
  END;
  return(NewFilChan);
END;

simple integer procedure OpChan(string NameOfTheFile);
! Open a currently existing file for binary i/o;
BEGIN
  integer eof,
  FilChan;
  open(FilChan_getchan,"DSK",'14,2,0,500,0,eof);
  LookUp(FilChan,NameOfTheFile,eof);
  if eof then
  BEGIN
    print( "Can't find ",NameOfTheFile,crlf );
    return( -1 );
  END;
  return(FilChan);
END;

simple procedure MakeHeader( integer DatNextRun,TimNextRun );
! conStructs the 24 word header ( positions 0 - 23 );
BEGIN
  integer ComFlChan,LogFlChan;
  string  ComFN,LogFN;
  Current[ E!RunTime ]_      !xwd( DatNextRun,TimNextRun ); 
  Current[ E!PPN ]_          calli( !xwd( -1,!GTPPN ),calli!gettab );      
  Current[ E!Privs ]_        calli( !xwd( -1,!GTPRV ),calli!gettab );    
  Current[ E!AUN ]_          calli( !xwd( -1,!GTAUN ),calli!gettab );  
  Current[ E!Username ]_     calli( !xwd( -1,!GTUNM ),calli!gettab );
  Current[ E!username + 1 ]_ calli( !xwd( -1,!GTUN1 ),calli!gettab );
  Current[ E!License ]_ !rh( calli( !xwd( -1,!GTLIC ),calli!gettab ) );
  calli( !xwd( 0, location( Current[ E!Project ] ) ), calli!chprj );
  Current[ E!Network ]_ !xwd( 1, location( Current[ E!Network ] ) );
  start!code
    define !forfa = '36;
    hrloi	1,!forfa;
    uuo!FRMOP 1,Current[ E!Network ];
    setzm Current[ E!Network ];
  END;
  Do 
  BEGIN
    ComFN_ Prompt( "NAME OF COMMAND FILE" );
  END
  until ( ComFlChan_ OpChan( ComFN ) ) neq -1;
  InsertFN( Current,ComFN,E!CmdFile );
  Do 
  BEGIN
    LogFN_ Prompt( "NAME OF LOG FILE" );
  END
  until ( LogFlChan_ GeChan( LogFN ) ) neq -1;
  InsertFN( Current,LogFN,E!LogFile );
  GetOptions;
END;

procedure MakeQueEntry;
BEGIN
  integer position,i,desc,tim,NextD,tod;
  tod_ TodaysIntrnDat;
  NextD_ NextRun( Current,tod );
  MakeHeader( !lh( NextD ),!rh( NextD ) );
END;

simple procedure ShowOneRec( integer array QRec );
BEGIN
integer desc,Conn,MoMult,Body,BP,BPI,ch;
  string parameters;
  if GetConn = 0 then
  BEGIN
    print( "NO CURRENT RECORD" );
    return;
  END;
  define ifprt(txt,val)= { if (val) neq 0 then (txt)&Cvs(val) else "" };
  print( "----------------------------------------------------------",
              "---------------" );
  print( crlf,"  ",Cvxstr( QRec[ E!CmdFile + F!Name ] ) );
  print( " ",LDB( PSeq( QRec[ E!Status ] ) ) ); 
  print( " ",CvsTim( ( LDB( PTimL( QRec[ E!LogLim ] ) ) lsh 18 ) DIV 1440 ) ); 
  print( " ",cvxStr( QRec[ E!Username ]), cvxStr( QRec[ E!username + 1 ] ) );
  print( " ",PrtPPN( QRec[ E!AUN ] ) );
  if ( QRec[ E!AUN ] neq QRec[ E!PPN ] )
   then print( "(", PrtPPN( QRec[ E!PPN ] ), ")" );
  print( " Run:",CvSDAT( !lh( QRec[ E!RunTime ] ) ),
          " ",CvSTim( !rh( QRec[ E!RunTime ] ) ) );

  !  print( "          Privs:",cvos( QRec[ E!Privs ] ) );
  print( Crlf&"          ",cv6Str( QRec[ E!LogFile + F!Device ] ),
              ":(",cv6Str( QRec[ E!LogFile + F!User ] ),
              cv6Str( QRec[ E!LogFile + F!User+1 ] ),")",
              cv6Str( QRec[ E!LogFile + F!Name ] ) ,
              ".",cv6Str( QRec[ E!LogFile + F!Ext ] ) );
  print( " = ",cv6Str( QRec[ E!CmdFile + F!Device ] ),
              ":(",cv6Str( QRec[ E!CmdFile + F!User ] ),
              cv6Str( QRec[ E!CmdFile + F!User+1 ] ),")",
              cv6Str( QRec[ E!CmdFile + F!Name ] ) ,
              ".",cv6Str( QRec[ E!CmdFile + F!Ext ] ) );

  if ( QRec[ E!Project ] )
   then print( " PROJ:",CvStr( QRec[ E!Project ] ),
              CvStr( QRec[ E!Project + 1 ] ),
              CvStr( QRec[ E!Project + 2 ] ) );
  if ( QRec[ E!Network ] )
   then print( " Nod-port:", cvos( QRec[ E!Network ] ) );

  if ( QRec[ E!TruLim ] or !lh(QRec[ E!Status ]) or QRec[ E!LogLim ] )
   then print( crlf );
  print( ifprt( "          TRU:",  QRec[ E!TruLim ] ) );
  print( ifprt( " Loglim:",    LDB( PLogL( QRec[ E!LogLim ] ) ) ) );
  print( ifprt( " Status:",    LDB( PStat( QRec[ E!Status ] ) ) ) ); 
  print( ifprt( " Proc:",      LDB( PProc( QRec[ E!Status ] ) ) ) ); 
  print( ifprt( " Dep:",       LDB( PDepL( QRec[ E!Status ] ) ) ) );

  print( crlf&"          Log:", ARLog[ LDB( PLog( QRec[ E!Action ] ) ) ] ) ; 
  print( " Disp:",ARDspos[ LDB( PDisp( QRec[ E!Action ] ))]); 
  if ( !rh( QRec[ E!License ] ) )
   then print( crlf&"License:",  LicPrt( !rh( QRec[ E!License ] ) ) );
  ! print( " Spool act:",ARSpl[LDB( PSpl( QRec[ E!Action ] ) ) ]) ; 

  print( crlf&"          Mail: ", ARMail[LDB( PMail( QRec[ E!Action ] ) ) ]);
  print( "  Mailer: ", ARMailer[LDB( PMPrg( QRec[ E!Action ] ) ) ]); 
  print( "  Restart: ", ARRstrt[LDB( PRestart( QRec[ E!Action ] ) ) ]); 
  print( "  Unique: ",   ARUniq[LDB( PUniq( QRec[ E!Action ] ) ) ]); 

  Parameters_ null;
  BP_ Point( 7, Current[ E!Parameters ], -1 );
  For BPI_ 1 upto E!ParLength do 
    If ( Ch_ Ildb( BP ) )
     then Parameters_ Parameters & Ch;
  if ( length( Parameters ) ) then
    print( crlf &"Parameters: ",Parameters );

  print( crlf,"Date expression:");
  express;
  for Desc_ E!Descriptor step D!Length until ( E!Length - D!Length - 1 ) do
  BEGIN
    print( crlf,"Dat Code      =" );
    print( LDB( PMult( QRec[ Desc ] ) ) );
    print( LDB( PType( QRec[ Desc ] ) ) );
    MoMult_ LDB( PMoMult( QRec[ Desc ] ) );
    if MoMult = 0 then
      print( "00" )
    else
      if MoMult < 10 then
        print( "0",MoMult )
      else
        print( MoMult );
    Body_ LDB( PBody( QRec[ Desc ] ) );
    if body = 0 then
      print( "00" )
    else
      if Body < 10 then
        print( "0",Body )
      else
        print( Body );
    Conn_ LDB( PConn( QRec[ Desc + D!Type ] ) ); 
    Print( Conn );
    print( "  Ref Dat/Tim   =" );
    print( LDB( PDate( QRec[ Desc + D!Daytime ] ) )," " );
    print( CvSTim( LDB( PTime( QRec[ Desc + D!Daytime ] ) ) )," " );

    if Conn = ENDCon then 
      done;
  END
END;

integer procedure GetNDT( integer AfterDate );
BEGIN
  integer NDT;
  if AfterDate = 0 then
    AfterDate_ TodaysIntrnDat;
  NDT_ NextRun( Current,AfterDate );
  return( NDT );
END; ! proc GetNDT;

simple procedure GetNext;
BEGIN
  ArrClr( Current );
  if GetRec( Current ) then
  BEGIN
    arrblt( Confirm[ 0 ],Current[ 0 ],E!Length ); ! save a copy;
    print( "*NEXT IS CURRENT. " );
  END
  else
  BEGIN
    dpb( '777777, PSeq( Current[E!Status] ) );
    if GetRec( Current ) then
    BEGIN
      arrblt( Confirm[ 0 ],Current[ 0 ],E!Length ); 
      print( "*NEXT IS CURRENT! " );
    END
    else
    BEGIN
      print( "*NO NEXT RECORD. " );
    END
  END;
  print( crlf );  
END;

simple procedure GetBySeqNum;
! Get a rec specified by a seq #;
BEGIN
  integer SeqNum;
  ArrClr( Current );
  SeqNum_ IntRead( "Enter Sequence Number" );
  Current[ E!Status ]_ SeqNum;
  if GetRec( Current ) then
    print( "Entry with seq# ",SeqNum," is now current." )
  else
    print( "Entry with seq# ",SeqNum," is not found." );
  arrblt( Confirm[ 0 ],Current[ 0 ],E!Length ); ! copy;
  print( crlf );  
END;

simple procedure GetByJobName;
! Get a rec from job list;
BEGIN
  string ComFN;
  ArrClr( Current );
  dpb( '777777, PSeq( Current[E!Status] ) ); ! reset ;
  ComFN_ prompt( "JOB NAME " );
  if equ( comFN,null ) then
  BEGIN
    return;
  END
  else
  BEGIN
    Current[ E!CmdFile + F!Name ]_ cvsix( ComFN[ 1 for 6 ] );
    if GetRec( Current ) then
      ShowOneRec( Current )
    else
      print( "JOB ", ComFN[ 1 for 6 ] ," NOT IN LIST" );
    arrblt( Confirm[ 0 ],Current[ 0 ],E!Length ); ! copy;
    print( crlf );  
  END
END;

simple procedure Delete;
BEGIN
  string ComFN;
  integer UN;
  UN_ Current[ E!UserName ];
  ComFN_ null;
  if UN = 0 then ! true if this proc. is being called from main prog;
  BEGIN
    dpb( '777777, PSeq( Current[E!Status] ) ); ! reset ;
    Current[ E!Username ]_     calli( !xwd( -1,!GTUNM ),calli!gettab );
    Current[ E!Username + 1 ]_ calli( !xwd( -1,!GTUN1 ),calli!gettab );
    ComFN_ prompt( "JOB NAME " );
    if equ( ComFN,null ) then
      return;
    Current[ E!CmdFile + F!Name ]_ cvsix( ComFN[ 1 for 6 ] );
    if GetRec( Current ) then ! look for an entry with that file name;
    BEGIN
      arrblt( Confirm[ 0 ],Current[ 0 ],E!Length ); ! copy;
      Current[ E!RunTime ]_ 0; ! amounts to a delete;
      if ModRec( Current,Confirm ) then ! insert with no runTime;
        print( "JOB DELETED " )
      else
        print( "(1)JOB COULD NOT BE DELETED " );
      print( crlf );  
    END
    else
    BEGIN
      print( "JOB NOT IN LIST" );
    END;
    ArrClr( Current );
    print( crlf );  
  END
  else
  BEGIN
    Current[ E!RunTime ]_ 0; 		! amounts to a delete;
    if ModRec( Current,Confirm ) then ! insert with no runTime;
      print( "JOB DELETED " )
    else
      print( "(2)JOB COULD NOT BE DELETED " );
    print( crlf );  
  END
END;


simple boolean procedure SubList( integer array QRec );
BEGIN
integer i,OptNum,LineLength;
string str;
boolean FoundOne;
  FoundOne_ false;
  arrclr( WhichParams );
  LineLength_ 0;
  while true do
  BEGIN
    Str_ LopWord( S$ListParameters );
    if equ( str,null ) then
      done;
    OptNum_ Validate( ListParams,Str,NumParams - 1 );
    if OptNum neq -1 then
      BEGIN
        FoundOne_ true;
        LineLength_ LineLength + fieldlengths[ OptNum ];
	if LineLength < 81 then
          WhichParams[ OptNum ]_ true
      END
    else
      print( " ?",Str,"? " );
     
  END;
  if NOT FoundOne then
    return( false );

  print( crlf );
  if WhichParams[ 0 ] then
    print( "  " );
  for i_ 0 upto NumParams - 2 do
  BEGIN
    if WhichParams[ i ] then
      print( ListParams[ i ]," " );
  END;
  print( crlf );
  if WhichParams[ 0 ] then
    print( "  " );
  for i_ 0 upto NumParams - 2 do
  BEGIN
    if WhichParams[ i ] then
      print( dashes[ 1 for length( ListParams[ i ] ) ] ," " );
  END;
  return( true );
END;

simple procedure LISTP( integer array QRec );
BEGIN
integer i,OptNum,LineLength;
string Str;
  print( crlf );
  LineLength_ 0;
  for i_ 0 upto NumParams - 1 do
  BEGIN
    if WhichParams[ i ] then
    BEGIN
      LineLength_ LineLength + fieldlengths[ i ];
      if LineLength > 80 then
        return;
      case i of
      BEGIN
        [ 0 ] BEGIN
		 Str_ cv6Str( QRec[ E!CmdFile + F!Name ] );
		 print( "  ",Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [  1 ] BEGIN
		 Str_ cvs( LDB(  PSeq( QRec[ E!Status ] ) ) );
		 print( spaces[1 to fieldlengths[i] - length( Str )],Str," " );
               END;
        [ 2 ] BEGIN
		 Str_ CvsTim((LDB(PTimL(QRec[E!LogLim])) lsh 18) DIV 1440);
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [  3 ] BEGIN
		 Str_ cvxStr( QRec[ E!UserName ] ) & 
		      cvxStr( QRec[ E!UserName + 1 ] );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [  4 ] BEGIN
		 Str_ PrtPPN( QRec[ E!PPN ] );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [  5 ] BEGIN
		 Str_ PrtPPN( QRec[ E!AUN ] );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [  6 ] BEGIN
		 Str_ "*";
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [  7 ] BEGIN
		 Str_  ( CvSDAT( !lh( QRec[ E!RunTime ] ) ) ) & " " &
                       ( CvSTim( !rh( QRec[ E!RunTime ] ) ) ) ;
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [  8 ] BEGIN
		 Str_ cvs( LicPrt( !rh( Qrec[ E!License ] ) ) );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [  9 ] BEGIN
		 Str_ cv6Str( QRec[ E!LogFile + F!Device ] ) & 
                      ":(" & cv6Str( QRec[ E!LogFile + F!User ] ) & 
	              cv6Str( QRec[ E!LogFile + F!User+1 ] ) & ")" & 
	              cv6Str( QRec[ E!LogFile + F!Name ] )  & 
	              "." & cv6Str( QRec[ E!LogFile + F!Ext ] ) ;
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [  10 ] BEGIN
		 Str_ cv6Str( QRec[ E!CmdFile + F!Device ] ) & 
	              ":(" & cv6Str( QRec[ E!CmdFile + F!User ] ) & 
	              cv6Str( QRec[ E!CmdFile + F!User+1 ] ) & ")" & 
	              cv6Str( QRec[ E!CmdFile + F!Name ] )  & 
	              "." & cv6Str( QRec[ E!CmdFile + F!Ext ] ) ;

		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [  11 ] BEGIN
		 Str_ "*";
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 12 ] BEGIN
		 Str_ cvs( QRec[ E!TruLim ] ) ;
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 13 ] BEGIN
		 Str_ cvs( LDB(  PLogL( QRec[ E!LogLim ] ) ) );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 14 ] BEGIN
		 Str_ cvs( LDB(  PDepL( QRec[ E!Status ] ) ) );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 15 ] BEGIN
		 Str_ ( ARLog[ LDB(  PLog( QRec[ E!Action ] ) ) ] );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 16 ] BEGIN
		 Str_ ( ARDspos[ LDB(  PDisp( QRec[ E!Action ] ) ) ] );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 17 ] BEGIN
		 Str_ ( ARMailer[ LDB(  PMPrg( QRec[ E!Action ] ) ) ] );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 18 ] BEGIN
		 Str_ "*";
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 19 ] BEGIN
		 Str_ ( ARMail[ LDB( PMPrg( QRec[ E!Action ] ) ) ] );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 20 ] BEGIN
		 Str_ ( ARRstrt[ LDB( PRestart( QRec[ E!Action ] ) ) ] );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 21 ] BEGIN
		 Str_ ( ARuniq[ LDB( PUniq( QRec[ E!Action ] ) ) ] );
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 22 ] BEGIN
		 Str_ "*";
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 23 ] BEGIN
		 Str_ "*";
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 24 ] BEGIN
		 Str_ "*";
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 25 ] BEGIN
		 Str_ "*";
		 print( Str );
		 print( spaces[1 to fieldlengths[i] - length( Str )]  ," " );
               END;
        [ 26 ] BEGIN
		 print( crlf );
		 ShowOneRec( Qrec );
               END
      END;
    END;
  END;
END;

simple procedure list;
BEGIN
integer Count;
boolean found,ListParams;

simple string procedure GetUserName;
! returns logged in user name. ;
  Return( cv6str(calli(-'22,'41)) & cv6str(calli(-'21,'41)) );

  Count_ 0;
  found_ ListParams_ false;
  ArrClr( SavEntr );
  ! prepare an array with only the username set;
  SavEntr[ E!Username ]_     calli( !xwd( -1,!GTUNM ),calli!gettab );
  SavEntr[ E!Username + 1 ]_ calli( !xwd( -1,!GTUN1 ),calli!gettab );
  
  arrblt( Current[ 0 ],SavEntr[ 0 ],E!Length ); ! move to Current;
  dpb( '777777, PSeq( Current[E!Status] ) );
  while GetRec( Current ) do !  rest of recs with this username;
  BEGIN
    Count_ Count + 1;
    if equ( S$ListParameters,null ) then
      S$ListParameters_ DefaultParam;
    if equ( S$ListParameters,null ) and not ListParams then
    BEGIN
      ShowOneRec( Current ) ! GetRec returns found rec in Current;
    END
    else
    BEGIN
      if NOT ListParams then
      BEGIN
        if NOT SubList( Current ) then
	BEGIN
	  print( "NO LISTABLE PARAMETERS PROVIDED" );
	  return;
	END;
        ListParams_ true;
        ListP( Current );
      END
      else
      BEGIN
        ListP( Current );
      END;
    END;
    found_ true;
    if inchrs neq -1 then  ! stop if a keyboard char has been typed;
      done;
    arrblt( Current[ 0 ],SavEntr[ 0 ],E!Length ); ! move to Current;
  END;
  if ListParams then
    print( crlf,#lf,Count," ITEMS LISTED.",crlf );
  if not found then
    print( crlf,"NO JOBS FOR " ,GetUserName,".",crlf );
END;

simple procedure Insert;
! record inserted into queue, being assigned a seq# by ModRec;
BEGIN
  integer SN;
  SN_ Current[ E!Status ] ; ! get sequence number ;
  I$Position_ E!Descriptor;
  if SN = 0 then 			! can only be a new entry;
  BEGIN 	! so there should be a new date code for a new q entry;
    if GetConn = 0 then
    BEGIN   		          ! trouble;
      print( "MUST USE DATE COMMAND FIRST",crlf );
    END
    else
    BEGIN 				! new job needs to be inserted;
      MakeQueEntry;
      if ModRec( Current,Confirm ) then ! insert the new entry;
      BEGIN
        print( "Record inserted. " );
        ArrClr( Current );
      END
      else
        print( "*new rec could not be inserted" );
    END
  END
  else 		! must have been a Current entry exists so re-insert;
  BEGIN
    if ModRec( Current,Confirm ) then
    BEGIN
      print( "Record inserted. " );
      ArrClr( Current );
    END
    else
    BEGIN
      print( "*Record could not be inserted. " );
    END
  END;
  print( crlf );  
END;

simple procedure Modif;
BEGIN
  integer SN;
  SN_ Current[ E!Status ] ; ! get sequence number ;
  if SN = 0 then 				! no current rec;
  BEGIN
    print( "no current record" );
  END
  else
  BEGIN 					! modify current record;
    print( "MODIFY:" ); 
    GetOptions;
    if ModRec( Current,Confirm ) then
      print( "Modified record inserted. " )
    else
      print( "Modified record could not be inserted. " );
  END;
  print( crlf );  
END;

simple procedure ShowAll;
BEGIN
  arrclr( Current ); ! clear so first rec will be returned in reset;
  dpb( '777777, PSeq( Current[E!Status] ) ); ! reset ;
  if GetRec( Current ) then 
    ShowOneRec( Current )  
  else
    print( "QUEUE SEEMS TO BE EMPTY" );
  arrclr( Current ); ! clear so next rec will be returned;
  while GetRec( Current ) do ! loop in the rest of recs;
  BEGIN
    ShowOneRec( Current ); ! GetRec returns found rec in Current;
    arrclr( Current ); ! must clear each time so all recs will come;
    ! otherwise GetRec will be searching for;
    ! the previously returned rec, which will;
    ! never be found;
  END
END;

simple procedure specials;
BEGIN
  string ch,TstCod;
  integer Next,Bas,UN;

simple procedure menu;
BEGIN
  print( crlf,"          - SPECIALS MENU -" );
  print( crlf,"" );
  print( crlf,"N - Get Next Rec from queue" );
  print( crlf,"S - Get Rec by sequence  #" );
  print( crlf,"A - Get Rec by command file name" );
  print( crlf,"W - Print Whole Queue from BEGINing" );
  print( crlf,"T - Show current rec" );
  print( crlf,"X - express date expression from current rec" );
  print( crlf,"F - figure next run D-T from current rec",crlf );
  print( crlf,"I - Insert current rec" );
  print( crlf,"M - Modify current rec" );
  print( crlf,"D - Delete current rec" );
  print( crlf,"R - Reset" );
  print( crlf,"H - Menu" );
  print( crlf,"Q - Quit specials" );
  print( crlf,"E - Exit submit" );
  print( crlf,"" );
END;

  while true do
  BEGIN
    ch_ prompt( SpecialsPrompt );
    case ch of 
    BEGIN
      [ "n" ]  GetNext;
      [ "s" ]  GetBySeqNum;
      [ "a" ]  GetByJobName;
      [ "i" ]  Insert;
      [ "m" ]  Modif;
      [ "t" ]  BEGIN
                 ShowOneRec( Current );
               END;
      [ "f" ]  BEGIN
                 bas_ IntRead( "enter a date as 00000 " );
                 Next_ GetNDT( bas );
                 print( crlf,cvsdat( !lh( Next ) )," ",!rh( next ) );
              END;
      [ "w" ]  ShowAll;
      [ "x" ]  express;
      [ "d" ]  BEGIN
		 UN_ Current[ E!UserName ];
		 if UN = 0 then
		   print( crlf,"NO CURRENT JOB TO DELETE",crlf )
		 else
		   Delete;
	       END;
      [ "h" ]  menu;
      [ "r" ]  dpb( '777777, PSeq( Current[E!Status] ) );
      [ "q" ]  done;
      [ "e" ]  BEGIN !  $$$ ;
                 ClsQue;
                 call( 0,"EXIT" );
               END;
        else print( crlf,"(",ch,") not implemented." )
    END
  END
END;

simple procedure welcome;
BEGIN
print( "***   WELCOME TO TYMCOM-X   S U B M I T   ***" );
print( crlf );
print( "***   ",CurrentTime," RELEASE ",release,"  ",
        CvSDat( TodaysIntrnDat ),"     ***" );
! getDOW( CvSDat( TodaysIntrnDat ) )[ 1 for 3 ],"  ***" );
END;

! main;

  B$Trace_ false;
  SetBreaks;
  welcome;
  while true do
  BEGIN
    I$CmmdNum_ getCommand( SubmitPrompt );
    I$Position_ E!Descriptor;
    clrbuf;
    case I$CmmdNum of 
    BEGIN
      [ 0 ] BEGIN
              arrclr( ModCheck,false ); 
              arrclr( Current ); 
              S$UsrsExp_ null;
              B$Coded_ false;
              GetDateSpec;
              if length( S$UsrsExp ) < 3 then
              BEGIN
	        print( crlf, FragmentComplaint );
		continue;
	      END;
              S$Scanned_ ScanStr( S$UsrsExp )[ 1 to inf -1 ];
              if EQU( S$ErrMSG,null ) then
              BEGIN
	        if NOT ParsedOK( S$Scanned,S$ErrMSG ) then
	        BEGIN
	          print( S$ErrMSG,crlf );
	          if length( S$ThrownOut ) > 3 then
	            print( crlf,"UNIMPLEMENTED TERMS: " , S$ThrownOut , crlf );
	        END
	      END
              else 			! error detected during ScanStr;
	      BEGIN
                print( S$ErrMSG,crlf );
	      END;
!              if NOT EQU( S$ErrMSG,null ) then
                continue; ! error detected during Parse so re-prompt;
            END;
      [ 1 ] Insert;
      [ 2 ] Display;
      [ 3 ] Express;
      [ 4 ] Test;
      [ 5 ] BEGIN
              arrclr( Current ); 
              delete;
            END;
      [ 6 ] print( "status not implemented",crlf );
      [ 7 ] list;
      [ 8 ] GetByJobName;
      [ 9 ] print( "version not implemented",crlf );
      [ 10 ] BEGIN
               ClsQue;
               call( 0,"EXIT" );
             END;
      [ 11 ] print( HlpMsg );
      [ 12 ] print( HlpMsg );
      [ 13 ] B$Trace_ true;
      [ 14 ] B$Trace_ false;
      [ 15 ] TrialCode;
      [ 16 ] Look;
      [ 17 ] specials;
      [ 18 ] print( CvSDat( TodaysIntrnDat ),
                    " (",getDOW( CvSDat( TodaysIntrnDat ) )[ 1 for 3 ],") ",
                    CurrentTime );
      else print( "!UNIDENTIFIED COMMAND: #",I$CmmdNum,".",crlf )
    END ! case;
  END ! while;
END "SUBMIT";

  ' }z