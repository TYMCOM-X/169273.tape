


  





            Fortran-10 Version 10 -- Changes from V7 to V10


                                May 1985















    Copyright (c) 1985, Digital Equipment Corporation, Maynard, Mass., USA

         This software is furnished under a license and  may  be  used  and
    copied  only  in accordance with the terms of such license and with the
    inclusion of the above copyright notice.  This software  or  any  other
    copies  thereof  may not be provided or otherwise made available to any
    other person.  No title to and ownership  of  the  software  is  hereby
    transferred.

         The information in this software  is  subject  to  change  without
    notice and should not be construed as a commitment by Digital Equipment
    Corporation.

         Digital assumes no responsibility for the use  or  reliability  of
    its software on equipment which is not supplied by Digital.
   FORTRA.DOC -- Fortran-10 Version 10


           1.0     SUMMARY  . . . . . . . . . . . . . . . . . . . . . . 1
           1.1       Bibliography . . . . . . . . . . . . . . . . . . . 2
           1.2       Monitors . . . . . . . . . . . . . . . . . . . . . 2
           1.3       Related System Software  . . . . . . . . . . . . . 2
           2.0     NEW FEATURES . . . . . . . . . . . . . . . . . . . . 4
           2.1       INQUIRE Statement  . . . . . . . . . . . . . . . . 4
           2.1.1       Returned Values  . . . . . . . . . . . . . . . . 4
           2.1.2       INQUIRE By Unit  . . . . . . . . . . . . . . . . 6
           2.1.3       INQUIRE By File  . . . . . . . . . . . . . . . . 6
           2.1.4       Error Processing . . . . . . . . . . . . . . . . 8
           2.2       Compatibility Flagger  . . . . . . . . . . . . . . 9
           2.2.1       New Command Switches . . . . . . . . . . . . . . 9
           2.2.2       Warning Messages . . . . . . . . . . . . . . .  10
           2.3       Support Of Industry-Compatible Magtape . . . . .  11
           2.3.1       TAPEFORMAT Keyword . . . . . . . . . . . . . .  11
           2.3.2       RECORDTYPE Keyword . . . . . . . . . . . . . .  11
           2.3.3       CARRIAGECONTROL Keyword  . . . . . . . . . . .  13
           2.3.4       Implementation Note  . . . . . . . . . . . . .  13
           2.3.5       Reading And Writing Tapes Using Fortran V10  .  14
           2.3.5.1       Mounting And Dismounting Tapes . . . . . . .  14
           2.3.6       Reading And Writing Tapes On VMS . . . . . . .  14
           2.3.6.1       Mounting Tapes (Labeled And Unlabeled) . . .  14
           2.4       Changes In I/O Statements  . . . . . . . . . . .  15
           2.4.1       Changes Incompatible With Version 7  . . . . .  15
           2.4.2       Enhancements To Version 7  . . . . . . . . . .  15
           2.5       Comments Within Continuation Lines . . . . . . .  16
           2.6       Additional Features With The INCLUDE Statement .  16
           2.7       Change To The /DEBUG:ARGUMENTS Switch  . . . . .  16
           2.8       New Bit-Manipulation Routines  . . . . . . . . .  17
           2.9       Changes In The Use Of Octal Constants  . . . . .  18
           2.10      PARAMETER Statements With Expressions Of Type 
                     COMPLEX  . . . . . . . . . . . . . . . . . . . .  18
           2.11      IMPLICIT NONE Statement  . . . . . . . . . . . .  18
           2.12      Octal And Hexadecimal Values In DATA Statements   18
           2.13      PAUSE ON ERROR Command For FORDDT  . . . . . . .  18
           3.0     RESTRICTIONS . . . . . . . . . . . . . . . . . . .  20
           4.0     KNOWN BUGS AND DEFICIENCIES  . . . . . . . . . . .  20
           5.0     COMPATIBILITY WITH PREVIOUS VERSIONS . . . . . . .  20
           6.0     INTERNAL CHANGES . . . . . . . . . . . . . . . . .  20


   APPENDIX A      SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER

           A.1     SOURCE DIFFERENCES . . . . . . . . . . . . . . . . A-1
           A.2     DATA TYPES . . . . . . . . . . . . . . . . . . . . A-2
           A.3     EXPRESSIONS  . . . . . . . . . . . . . . . . . . . A-3
           A.4     SUBROUTINES AND FUNCTION ARGUMENT LISTS  . . . . . A-5
           A.5     SPECIFIC STATEMENTS  . . . . . . . . . . . . . . . A-5
           A.6     FORMAT STATEMENT . . . . . . . . . . . . . . . .  A-10
           A.7     INPUT/OUTPUT STATEMENTS  . . . . . . . . . . . .  A-11
           A.8     INTRINSIC FUNCTIONS AND FORTRAN-SUPPLIED 
                   SUBROUTINES  . . . . . . . . . . . . . . . . . .  A-13
           A.9     FUNCTIONS AND SUBROUTINES ON VMS NOT RECOGNIZED 
                   BY FORTRAN-10/20 . . . . . . . . . . . . . . . .  A-14
   FORTRA.DOC -- Fortran-10 Version 10                             Page 1


   1.0  SUMMARY

   Version 10 of Fortran-10 is  a  development  release  of  the  Fortran
   compiler,  FOROTS,  FORLIB  and  FORDDT.   Fortran-10  version  10  is
   validated at the full level of the Fortran-77 standard.

   The major new features include

         o  The INQUIRE statement

         o  A compatibility flagger which optionally  detects  extensions
            to  the  Fortran-77  standard, and incompatibilities with the
            VAX-11 Fortran currently running on the VAX under VMS.

         o  Support  of  unlabelled   industry-standard   magnetic   tape
            (Labelled tapes are NOT supported)

         o  Comments may be interspersed with continuation lines.

         o  G-Floating is supported for double precision real numbers

         o  FORDDT has a PAUSE ON ERROR command which will cause  a  trap
            to FORDDT whenever a runtime error is encountered.


   In addition, changes have been made to features which exist in V7:

         o  The global optimizer may now be used  even  though  there  is
            character data present in the program.

         o  The INCLUDE statement has two new options, and may be nested.

         o  Certain I/O statements have been changed in order to be  more
            compatible with the VAX/VMS Fortran.

         o  The IMPLICIT NONE statement has been added.

         o  The PARAMETER statement may contain expressions involving the
            multiplication,  division  and exponentiation of constants of
            type COMPLEX.

         o  Values in DATA  statements  may  be  expressed  as  Octal  or
            Hexadecimal constants in accordance with MIL-STD-1753.


   This tape contains copies of the version 10 compiler,  FOROTS  (called
   FORO10.EXE), FORLIB and FORDDT.
   FORTRA.DOC -- Fortran-10 Version 10                             Page 2


   1.1  Bibliography

   Two copies of each of the following manuals  are  enclosed  with  this
   release tape.

   The Fortran language and this  implementation  are  described  in  the
   reference manual:

           TOPS-10/20 Fortran Language Manual - AA-N383B-TK

   The installation procedures for this tape are described in:

           TOPS-10 Fortran Installation Guide - AA-P345B-TM

   There is also a booklet  that  provides  quick  reference  information
   about Fortran-10/20:

           TOPS-10/20 Fortran Pocket Guide - AA-P529B-TK

   The algorithms and accuracy of the math routines  in  FORLIB  will  be
   described in:

           TOPS-10/20 Common Math Library Reference Manual - AA-M400A-TK

   Similarities and differences between Fortran-10/20 and VAX/VMS Fortran
   are described in:

           Fortran-10/20 and VAX Fortran Compatibility Manual -
                   AA-Y868B-TK

   It is recommended that you also refer to

   American National Standard Programming Language FORTRAN
           ANSI X3.9-1978

   Copies of this standard may be obtained from:

           American National Standards Institute
           1430 Broadway
           New York, NY 10018



   1.2  Monitors

   This version of Fortran will run on Tops-10 releases 7.02 and 7.03.



   1.3  Related System Software

   The following system software must be used with Fortran version 10:
           LINK V5.1
   FORTRA.DOC -- Fortran-10 Version 10                             Page 3


   The following system software must be used to build Fortran version 10
   from sources:
           BLIS10 V7.5(227)
           MACRO V53.1(1152) or later

   The following optional software may be used with Fortran V10:

           SORT V4C
           DBMS V5A
           DIL V2
   FORTRA.DOC -- Fortran-10 Version 10                             Page 4


   2.0  NEW FEATURES

   2.1  INQUIRE Statement

   The INQUIRE statement is the first language  element  introduced  into
   the  FORTRAN  language  intended  to  find out information about files
   being used or potentially being  used  by  a  FORTRAN  program.   This
   statement is defined in the ANSI X3.9-1978 standard, section 12.10.3.

   There are 2 forms of  the  INQUIRE  statement,  INQUIRE  by  file  and
   INQUIRE by unit.

   An INQUIRE by file is a INQUIRE statement containing a FILE=  keyword,
   an  associated  file  specification,  and  no  UNIT=  keyword.   It is
   therefore used for finding out information about a file based  on  its
   name.  INQUIRE by file can be used to find out information about files
   which are "connected" - files for which an  OPEN  statement  has  been
   executed  or  for  which a data transfer statement has been executed -
   and also about files which are not "connected";  it  can  be  used  to
   find  out  about the existence of files before, during, and after they
   are used by the program, as well as files which are not  used  by  the
   program.

   An INQUIRE by unit is an INQUIRE statement containing a UNIT=  keyword
   and   no  FILE=  keyword.   It  is  therefore  used  for  finding  out
   information about files which may  be  "connected"  to  the  specified
   unit.

   Since Fortran does not actually open a  file  for  which  the  STATUS=
   value  is  'UNKNOWN'  and the ACCESS= value is 'SEQUENTIAL' (which are
   the defaults) until the first data transfer statement (READ or  WRITE)
   is  executed,  FOROTS  cannot  find  out  the  full file specification
   (including device) between the execution of an OPEN statement and  the
   execution of the first data transfer statement.  Note that once a data
   transfer statement has executed for a  particular  unit,  the  STATUS=
   value  is  'OLD'.   Once  a file is opened for output (either with the
   OPEN statement or by the first data transfer statement) that file will
   exist in the directory.



   2.1.1  Returned Values -

   If the INQUIRE statement proceeds to completion (i.e., there  were  no
   errors  in  the  arguments  given  to  the INQUIRE statement), program
   execution proceeds at the next executable statement, and the following
   values  are  returned  (the  argument  type  for the variable for each
   keyword is in parentheses):

        a.  IOSTAT (integer):  Returns 0.

        b.  EXIST (logical):  For INQUIRE by unit, always returns  .TRUE.
            For  INQUIRE  by  file,  returns  .TRUE.  if the file exists,
            .FALSE.  if not.
   FORTRA.DOC -- Fortran-10 Version 10                             Page 5


        c.  OPENED (logical):  .TRUE.  if open, .FALSE.  if not.

        d.  NUMBER (integer):  Returns unit number if open, variable  not
            touched if not open.

        e.  NAMED (logical):   If  file  is  open,  returns  .FALSE.   if
            STATUS='SCRATCH' and .TRUE.  otherwise;  if file is not open,
            returns .FALSE.

        f.  NAME  (character):   For  INQUIRE  by  file,   returns   full
            (expanded)  file string if the file exists (which will be the
            case if OPEN with STATUS other than 'UNKNOWN' or ACCESS other
            than  'SEQUENTIAL'  or  an  I/O  transfer  statement has been
            executed).  Otherwise, returns the string supplied  with  the
            FILE in the INQUIRE statement with defaults applied.

            For INQUIRE by unit, if the file is  not  open,  the  default
            file  specification  for  that  unit  is returned;  for files
            opened with STATUS='SCRATCH', blanks are  returned;   if  the
            file is open with STATUS other than 'SCRATCH' or 'UNKNOWN' or
            ACCESS other than SEQUENTIAL, or an  I/O  transfer  statement
            has  been  executed,  the  full  (expanded)  file  string  is
            returned;   if  file  is  open  with   STATUS='UNKNOWN'   and
            ACCESS='SEQUENTIAL'  and  no I/O statement has been executed,
            returns  the  file  string  given  by  the  associated   OPEN
            statement, with defaults applied.

            In all cases, if a string is to be returned, only the  device
            name is returned for non-disk devices.

        g.  ACCESS  (character):   If   the   file   is   open,   returns
            'SEQUENTIAL'  if  the file is opened for sequential access or
            'DIRECT' if the file is opened for  DIRECT  (RANDOM)  access;
            returns 'UNKNOWN' if the file is not open.

        h.  DIRECT (character):  Returns 'YES' if file can be opened  for
            DIRECT access (i.e., is a disk file) or 'NO' if it cannot.

        i.  SEQUENTIAL (character):  Returns 'YES' if  the  file  can  be
            opened for SEQUENTIAL access, 'NO' if it cannot.

        j.  FORM (character):  If the file is open,  returns  'FORMATTED'
            if  the file is opened for formatted I/O, or 'UNFORMATTED' if
            the file is opened for unformatted I/O;  returns 'UNKNOWN' if
            the file is not open.

        k.  FORMATTED (character):  Returns 'YES'  if  the  file  can  be
            opened with FORM='FORMATTED' (i.e., always).

        l.  UNFORMATTED (character):  Returns 'YES' if the  file  can  be
            opened with FORM='UNFORMATTED' (i.e., always).

        m.  RECL (integer):  If the file is open, returns the  recordsize
            of  file  (the  value given with the RECL keyword of the OPEN
            statement), zero if variable-length records;  returns zero if
   FORTRA.DOC -- Fortran-10 Version 10                             Page 6


            the file is not opened.

        n.  NEXTREC (integer):  returns the next  record  number  if  the
            file  is open;  zero is returned if the file is not opened or
            does not exist.  For ACCESS='APPEND', returns the  number  of
            records written by the program, plus one.

        o.  BLANK (character):  Returns  'NULL'  if  the  file  was  last
            opened  with  BLANK='NULL',  or 'ZERO' if the file was opened
            with BLANK='ZERO'.  Returns 'UNKNOWN' if the file is not open
            or is opened for unformatted I/O.

        p.  CARRIAGECONTROL  (character):   For  files  which  are  open,
            returns  a  string  representing  the value given in the OPEN
            statement (or default applied)  for  the  file,  one  of  the
            following:    'LIST',  'FORTRAN',  'TRANSLATED',  or  'NONE'.
            Returns 'UNKNOWN' if the file is not open.




   2.1.2  INQUIRE By Unit -

        1.  If there is a file open on the  specified  unit  with  STATUS
            other   than   UNKNOWN  or  SCRATCH,  or  ACCESS  other  than
            SEQUENTIAL, or an I/O transfer statement  has  been  executed
            using  the  specified unit, FOROTS returns the full, expanded
            file specification.

        2.  If the file is open on the specified unit as a result  of  an
            OPEN     statement     in    which    STATUS='UNKNOWN'    and
            ACCESS='SEQUENTIAL' were specified or  implied,  and  no  I/O
            transfer  statement  has  been  executed  using the specified
            unit, FOROTS returns the string given in the OPEN  statement,
            with   defaults   applied,   for  NAME=.   The  default  file
            specification is DSK:FORnn.DAT, where DSK:  is supplied if no
            device is given, and nn is the 2-digit Fortran logical unit.

        3.  If STATUS='SCRATCH' FOROTS returns blanks for NAME=.

        4.  If there has been no  OPEN  statement  and  no  I/O  transfer
            statement  has been executed using the specified unit, FOROTS
            returns the default file  specification  for  that  unit  for
            NAME=.




   2.1.3  INQUIRE By File - INQUIRE by file is quite a bit more complex:

        1.  If no device is given for the FILE= specifier, FOROTS uses  a
            default  of  'DSK';   If  no  extension is given, FOROTS uses
            'DAT'.
   FORTRA.DOC -- Fortran-10 Version 10                             Page 7


        2.  FOROTS then determines if the device specified is a disk.  If
            it is:

            a.  FOROTS  finds  out  if  a  file  exists  with  the   file
                specification given in the INQUIRE statement, and returns
                the answer (either .TRUE.  or .FALSE.)  in  the  variable
                specified by the EXIST= keyword, if any.  In the process,
                if  such  a  file  exists,  FOROTS  'expands'  the   file
                specification:   a logical device name is translated into
                a   physical   device   name.    The    resultant    file
                specification,  in  string  form,  will  be  referred  to
                hereafter as the 'full (expanded) file string'.

            b.  To determine the values to be returned  for  the  INQUIRE
                keywords OPENED= and NUMBER=, FOROTS searches for a match
                between the  file  specification  given  in  the  INQUIRE
                statement  and  a  file  specification  associated with a
                logical unit for which there is a  'connection'.   FOROTS
                looks  at  all  the  FORTRAN  logical units, in ascending
                order,  starting   zero,  for  which  there   is   a
                'connection'.    If  the  file  does  not  exist  on  the
                directory and an OPEN statement  has  been  executed  and
                STATUS='UNKNOWN'  and  ACCESS='SEQUENTIAL'  and  no  data
                transfer statements have been executed  using  the  unit,
                FOROTS  compares  the  file  specification  given  in the
                INQUIRE statement (with defaults applied) with the  exact
                file  specification  given  in  the  OPEN statement (with
                defaults applied).  If the file exists (which will be the
                case  if  OPEN with STATUS other than 'UNKNOWN' or ACCESS
                other than 'SEQUENTIAL' or an I/O transfer statement  has
                been  executed)  FOROTS  compares  the  full  file string
                associated with the unit with the  full  (expanded)  file
                string  given  in  the  INQUIRE  statement.  If either of
                these two comparisons are successful, FOROTS returns  the
                current  unit  number  in the variable specified with the
                NUMBER=  keyword,  and  returns  'YES'  in  the  variable
                specified  with  the  OPENED=  keyword.  Note that if the
                same file is connected on  several  units,  the  matching
                technique  described will return the smallest unit number
                for which there is a match.


        3.  For non-disk devices given in the file specification  in  the
            INQUIRE  statement,  FOROTS  looks at all the FORTRAN logical
            units in ascending order, starting with zero, for which there
            is a 'connection'.

            a.  If the device in the file string specified in the INQUIRE
                statement  is not the user's controlling terminal, FOROTS
                'expands' the file specification  given  in  the  INQUIRE
                statement  (thus  translating a logical name given as the
                device  into  its  corresponding  physical   name),   and
                compares   the   device   part   of  this  expanded  file
                specification with the device part of the full (expanded)
                file string associated with the logical unit.
   FORTRA.DOC -- Fortran-10 Version 10                             Page 8


            b.  If the device is the user's controlling terminal  (device
                'TTY'),  FOROTS  determines if the device associated with
                the logical unit is also the user's controlling terminal.

            Note that if the same device is connected on  several  units,
            this procedure will return the smallest unit number for which
            there is a match.




   2.1.4  Error Processing -

   If an error occurs during  the  execution  of  the  INQUIRE  statement
   (e.g.,  a  file specification was given which has a syntax error), the
   following occurs:

        1.  If neither an ERR nor IOSTAT keyword  are  specified  in  the
            INQUIRE  statement,  program  execution  is terminated and an
            appropriate error message is typed on the user's terminal.

        2.  If an IOSTAT keyword is specified, the variable specified  by
            it  is set to a positive, non-zero integer (see IOSTAT in the
            Fortran-10/20 Language Manual, section 10.4.8);   if  no  ERR
            keyword  is specified, program execution proceeds at the next
            executable statement.

        3.  If an ERR keyword is specified, program  execution  continues
            at  the  statement  specified  (see  ERR in the Fortran-10/20
            Language Manual, section 10.4.7).

   FORTRA.DOC -- Fortran-10 Version 10                             Page 9


   2.2  Compatibility Flagger

   The Compatibility Flagger  adds  to  Fortran  V10  the  capability  of
   producing  optional  warning  messages  whenever a language element is
   used which is

        a.  An extension to the ANSI Fortran-77 standard

        b.  A feature  not  found  in  VAX/VMS  Fortran  or  could  cause
            logically different results when used on the VAX/VMS system


   The compatibility flagging is invoked at the user's  discretion  by  a
   new switch recognized by the Fortran compiler command parser.

   The primary goal of this feature is to provide warning messages at any
   point  which  could  cause  conversion  problems  if  the user were to
   compile and execute the  program  on  the  VAX/VMS  system  or  on  an
   ANSI-compatible   system.    This   includes   not   only  compilation
   incompatibilities, but also problems that could occur at object time.



   2.2.1  New Command Switches -

   The /FLAG and /NOFLAG switches have been added to the compiler.

        /FLAG:ANSI        To give warning messages whenever the source is
                          an extension to the Fortran-77 standard

        /FLAG:VMS         To give warning messages whenever  the  program
                          could  cause  an  incompatibility  with VAX/VMS
                          Fortran

        /FLAG:ALL         To give warnings for both Fortran-77 and VMS

        /FLAG:NONE        To do no flagging

        /FLAG:NOANSI      To do no flagging of Fortran-77 extensions

        /FLAG:NOVMS       To do no flagging of VMS incompatibilities

        /NOFLAG           To do no flagging

   The /FLAG switch can have multiple arguments, e.g.  /FLAG:(ALL,NOVMS).

   If the /FLAG switch is not present in the command, no flagging will be
   done.   If  no  argument is given, then flagging will be done for both
   VMS and Fortran-77.

   The /NOFLAG switch takes no arguments.
   FORTRA.DOC -- Fortran-10 Version 10                            Page 10


   2.2.2  Warning Messages -

   The warning messages will be one of the following:

             %FTNxxx Extension to Fortran-77:  text
             %FTNxxx VMS incompatibility:  text
             %FTNxxx VMS and Fortran-77 incompatibility:  text

   where  'xxx'  is  a  unique  three-letter  code,  and  'text'  is   an
   explanation  of  the  specific  extension  or  incompatibility.   This
   suggested text is described with each element.

   In addition, certain incompatibilities are flagged  at  runtime.   The
   compiler   generates   a  global  symbol  specific  to  each  type  of
   compatibility flagging requested by the user:

             FLGV.        VMS flagging
             FLG77.       Fortran-77 flagging

   If the particular type of flagging  is  to  be  done,  the  associated
   global  (FLGV.  and/or FLG77.) will be set to a value of all ones;  if
   that flagging is not done, no global  value  will  be  generated.   In
   FORLIB,  separate  routines  will  each  contain  one  of  the  global
   definitions as an ENTRY,  with  a  value  of  all  zeroes,  and  these
   routines will be loaded if and only if the global value is not defined
   in one or more of the  compiled  programs  (i.e.   flagging  is  being
   done).   Thus  if  one or more of a series of linked programs has been
   compiled with the flagger on, then the execution  of  that  task  will
   cause FOROTS to do compatibility checking on all routines.

   The runtime flagging includes:

         o  Incompatible carriage control

         o  Incompatible values for I/O keywords

         o  Blanks at end of output line

         o  The use of intrinsic functions and subroutines not  supported
            by VMS and/or Fortran-77

   For a more detailed description of runtime flagging, see  Appendix  A,
   sections 7 and 8.
   FORTRA.DOC -- Fortran-10 Version 10                            Page 11


   2.3  Support Of Industry-Compatible Magtape

   Version 10 supports unlabelled magnetic tape processing  in  a  manner
   compatible with the VMS system.

   It is possible to read  and  write  single-file  labelled  tapes  with
   version  10,  but multi-file volumes (more than one file per tape) and
   multi-volume files (a file that  extends  beyond  one  reel  of  tape)
   cannot  be  handled.   Because  of  insufficient  testing,  the use of
   labelled tapes is unsupported.

   For more information on the industry-compatible recording mode see the
   Tops-10 Tape Processing Manual.



   2.3.1  TAPEFORMAT Keyword -

        1.  CORE-DUMP  -  This  is  the  usual  so-called  DEC-compatible
            format,  with  36  bits stored in 5 frames on a 9-track tape.
            This is the default format.

            The SET BLOCKSIZE command (or the monitor-supplied default if
            no  command  is  given)  is  interpreted  to be the number of
            36-bit words in the magtape blocks on the tape, and  is  used
            if no BLOCKSIZE keyword is given in the OPEN statement.  If a
            BLOCKSIZE is given in the OPEN statement, it  is  interpreted
            to  be  the  number  of  36-bit  words for both formatted and
            unformatted files.

        2.  INDUSTRY - Four 8-bit characters per word (left justified  in
            32  bits  in  FOROTS'  magtape buffer) are read or written in
            standard industry tape format.  The BLOCKSIZE  given  in  the
            OPEN statement specifies the number of bytes (frames) in each
            magtape block, regardless of whether it  is  a  formatted  or
            unformatted  file.   If no BLOCKSIZE is specified in the OPEN
            statement, the SET BLOCKSIZE command specifies the number  of
            words  in  each  magtape  block,  4  bytes  per  word.  If no
            magnetic tape format is  specified  in  the  OPEN  statement,
            FOROTS  will  not  attempt to set a default, but instead will
            find out the setting of the  tape  format  from  the  monitor
            (which  can  be set via the SET FORMAT command).  FOROTS will
            not attempt to stop a program from using a tape format  other
            than  COREDUMP  or  INDUSTRY.   However,  the results will be
            unpredictable.




   2.3.2  RECORDTYPE Keyword -

   The RECORDTYPE keyword required modification to the compiler such that
   it can be differentiated from RECORDSIZE, since these two keywords are
   identical in their first six characters.   Hereafter  RECORD  will  be
   recognized as an abbreviation for RECORDSIZE.
   FORTRA.DOC -- Fortran-10 Version 10                            Page 12


        1.  UNDEFINED or STREAM - for  36-bit  tape  format  (CORE-DUMP),
            this  is  stream  disk  image  format  -  36  bit  words  are
            transferred  to/from  the  tape  without  regard   to   their
            contents,  in  the  same  format as formatted and unformatted
            disk files.  For INDUSTRY  tape  format,  this  is  ANSI  "U"
            (undefined) record format.  This is the default record format
            for all tape formats.  This record format is stream format  -
            7-bit  or  8-bit bytes, respectively, are transferred to/from
            the tape as if they were being  transferred  to/from  a  disk
            stream file.

            For all tape formats, this record format specifies  that  for
            formatted  files  that  a standard stream record terminator -
            CRLF - is placed at the  end  of  each  record,  and  that  a
            standard  stream  terminator  is expected on input to delimit
            records.  For unformatted files the behavior is identical  to
            that   of   a  MODE='IMAGE'  disk  file  -  a  word  transfer
            word-aligns  the  pointer  and  transfers  a  word  of   data
            (containing four 8-bit bytes);  character data transfers need
            not be word-aligned, and are done  with  MOVSLJ  to/from  the
            (currently)  7-bit character variables defined by the FORTRAN
            compiler.

            With this record format, all physical blocks on the tape  are
            the same size except for the last block, which may be a short
            block.  For 36-bit mode (CORE-DUMP), the bytes  in  the  last
            36-bit  word  after the last character of data will be nulls.
            For all tape formats, if a  RECORDSIZE  is  specified  for  a
            formatted  file,  the  actual record read/written consists of
            the data, a CRLF,  and  the  number  of  nulls  necessary  to
            word-align the record.

        2.  DELIMITED or VARIABLE - for 36-bit tape  format  (CORE-DUMP),
            this  is not defined or supported.  For INDUSTRY, this is the
            standard ANSI "D" tape record format - records  are  variable
            in length, and the record data is written with no terminators
            or carriage control characters,  and  preceded  by  a  4-byte
            record  size  (referred  to  in  the  ANSI standard as Record
            Control Word or RCW).  Blocks are  variable  length,  not  to
            exceed  the block length specified in the OPEN statement.  If
            a RECORDSIZE is specified in the OPEN statement, this is  the
            maximum number of bytes specified in the 4-byte RCW preceding
            each record;  the record actually read  or  written  is  four
            characters less than this quantity.

            For input, the  RECORDSIZE  in  the  OPEN  statement  has  no
            relevance, since FOROTS expands its record buffer dynamically
            as needed.  For output, FOROTS will  truncate  records  which
            exceed  the  specified  RECORDSIZE  (and  give a supressable,
            trappable warning  message).   If  no  RECORDSIZE  is  given,
            FOROTS  will  use  the  size  specified  by the SET BLOCKSIZE
            command (or the monitor-supplied default  if  no  command  is
            given).
   FORTRA.DOC -- Fortran-10 Version 10                            Page 13


        3.  FIXED - for 36-bit format (CORE-DUMP), this is not defined or
            supported.   For INDUSTRY, this is the standard ANSI "F" tape
            record format - record data is written with no terminators or
            carriage   control  characters,  one  record  directly  after
            another, to exactly fill fixed-length blocks.  (If  the  last
            block  is not filled with records, it is a short block).  For
            this record format, a RECORDSIZE must  be  specified  in  the
            OPEN statement.




   2.3.3  CARRIAGECONTROL Keyword -

   Carriage control is an  attribute  of  a  file  rather  than  being  a
   directive.   None  of  these  values has any effect on input data, and
   except for TRANSLATED and NONE, these values have  no  effect  on  the
   output data.

        1.  LIST - When a record is printed or typed, a CRLF is  appended
            to  its  end.   For  "U" (UNDEFINED) record format, it has no
            effect, since CRLFs always  appear  in  the  file  as  record
            terminators.   This  is  the  default  value  for  "U" record
            format.

        2.  FORTRAN - When a  record  is  printed  or  typed,  the  first
            character  of  the  record  is converted into the appropriate
            carriage  control  characters  for  printing.   This  is  the
            standard  ANSI  "A"  format.  This is the default for "D" and
            "F" record formats.  For "U" (UNDEFINED) record  format  disk
            files,  a  bit  is set in the RIB so that for Tops-10 release
            7.03  and  later,   LPTSPL   will   print   the   file   with
            /FILE:FORTRAN,  converting the first character of each record
            to the appropriate carriage control characters for  printing,
            and  removing  the  CRLF  record  terminator.   (For  Tops-10
            release 7.02 and earlier, FORTRAN is equivalent to LIST).

        3.  NONE - When  each  record  is  printed  or  typed,  no  extra
            characters need be added for carriage control, and no special
            action is taken - the assumption is that any carriage control
            characters needed for printing exist within the record.  This
            is the standard ANSI "M" format.  For "U" (UNDEFINED)  record
            format,  this  value  has  a special effect - to suppress the
            normal CRLF which appears normally at the end of each  record
            as a record terminator.

        4.  TRANSLATED - Similar to NONE, but implies  that  upon  output
            FOROTS  has  interpreted  column 1 of each output record into
            the appropriate carriage control characters for  printing  or
            typing.   This  is  the ANSI "M" format.  There is no support
            possible for "F" record format, since the number of  carriage
            control characters after interpretation varies widely.

   FORTRA.DOC -- Fortran-10 Version 10                            Page 14


   Section 2.5.1 notes some incompatibilities with Fortran V7 with regard
   to these values.



   2.3.4  Implementation Note -

   If a magnetic  tape  file  is  OPENed  specifying  the  TAPEFORMAT  as
   INDUSTRY,  FOROTS  sets the device to be "ASCII-only";  if binary data
   is written to the file, FOROTS does  not  read  or  write  LSCWs,  but
   instead treats the data as if MODE='IMAGE' had been specified.



   2.3.5  Reading And Writing Tapes Using Fortran V10 -



   2.3.5.1  Mounting And Dismounting Tapes -

   To mount a tape a MOUNT command of the following form must be given to
   the operating system:

           .MOUNT MTA: LOGNAM/VOLID:VOLNAM/WRITE-ENABLE

   Where LOGNAM is the logical name for the  device  and  VOLNAM  is  the
   volume  identification.   The /WRITE-ENABLE switch is used only if you
   intend to write to the tape.

   To dismount a Magtape unit you use the

           DISMOUNT LOGNAM:

   command.  For more information on mounting  and  dismounting  magtapes
   see the Tops-10 Commands Reference Manual.



   2.3.6  Reading And Writing Tapes On VMS -



   2.3.6.1  Mounting Tapes (Labeled And Unlabeled) -

   When mounting a magnetic tape on a VMS system  you  must  specify  the
   physical  drive name that the tape will mounted on.  For VMS there are
   different mount command specifiers for labeled and unlabeled tapes.

   To mount an unlabeled tape on VMS  (also  called  foreign)  you  would
   specify:

           $ MOUNT/NOLABEL/BLOCKSIZE=nnn/RECORDSIZE=nnn DEVNAM: LOGNAM
   FORTRA.DOC -- Fortran-10 Version 10                            Page 15


   And for a labeled tape:

           $ MOUNT/OVERRIDE=OWNERIDENTIFICATION DEVNAM: VOLNAM LOGNAM

   Where DEVNAM:  is the physical device name, VOLNAM is the volume  name
   and  LOGNAM  is  any  logical  name  you've  chosen.   Note  that  the
   /BLOCKSIZE  and  /RECORDSIZE  are  required  for  any  unlabeled  tape
   operations.   The  /OVERRIDE  specifier  is  required if the label was
   written on a Tops-10 or Tops-20 system.  If you do not wish  to  write
   on  the  tape  you  should  specify  /NOWRITE;   write  enabled is the
   default.  For a full explanation of the VMS mount utility  you  should
   refer to the VAX/VMS Mount Utility Reference Manual.
   FORTRA.DOC -- Fortran-10 Version 10                            Page 16


   2.4  Changes In I/O Statements

   2.4.1  Changes Incompatible With Version 7 -

        1.  When a  file  is  created  by  the  runtime  system  it  will
            immediately  appear  in  the  user's  directory;  in previous
            versions of Fortran, created files  did  not  appear  in  the
            directory  until  that  file  was closed.  If the user should
            terminate the execution of the program  before  the  file  is
            closed, the previous version WILL NOT EXIST.

        2.  The definition of the CARRIAGECONTROL='FORTRAN' specifier  in
            OPEN  statements  will  more  nearly conform to VMS usage.  A
            replacement   for    the    present    'FORTRAN'    specifier
            ('TRANSLATED') has been implemented, and shipped on Autopatch
            tape 7 for  V7  customers.   For  Tops-10  release  7.02  and
            earlier,   'FORTRAN'  is  equivalent  to  'TRANSLATED';   for
            Tops-10 release 7.03 and later, 'TRANSLATED' will  cause  the
            first  character  of  a  formatted  line to be changed to the
            appropriate  carriage  control  characters;   'FORTRAN'  will
            leave  that first character in the record, but that character
            will be translated by the print spooler.

            For more discussion of CARRIAGECONTROL, see section 2.3.3.

        3.  A change in the  meaning  of  'BLOCKSIZE'  for  magtapes  was
            implemented  in V7:  that value was taken to count characters
            instead of words.  In  V10,  that  change  is  rescinded  for
            TAPEFORMAT  = 'CORE-DUMP':  BLOCKSIZE will specify words, not
            characters.

        4.  MODE='DUMP' is no longer supported.




   2.4.2  Enhancements To Version 7 -

        1.  The I/O keyword NML is a synonym  for  FMT  when  referencing
            namelists.

        2.  MODE='IMAGE' is accepted for the TTY device.  If the data  is
            being  read  into  (written  from)  non-character fields, the
            rightmost 7 bits of each word will be used;  if the  data  is
            being  read  into (written from) character fields, each 7-bit
            byte will be used.

            When using MODE='IMAGE', control characters have  no  special
            meaning.

            MODE='IMAGE' has been implemented in Fortran V7A on Autopatch
            tape #8.

   FORTRA.DOC -- Fortran-10 Version 10                            Page 17


   2.5  Comments Within Continuation Lines

   Fortran V7 will assume that a statement is completed as  soon  as  any
   comment  line is seen.  Fortran V10 supports the inclusion of comments
   within continuation lines.  For example, the following Fortran  source
   is now valid:

                A=B+C
          C This comment is inserted between two lines of the statement
               1  +D+E

   and will compile as    A=B+C+D+E



   2.6  Additional Features With The INCLUDE Statement

   The compiler will continue to assume that any INCLUDEd source is to be
   listed  unless  the  /NOLIST  switch is used in the INCLUDE statement.
   Since the VAX/VMS Fortran will list  the  source  only  if  explicitly
   requested,  Fortran-10/20  and VAX/VMS Fortran will do opposite things
   on default.  To relieve this incompatibility,  Fortran-10/20  V10  has
   added  the /LIST switch to the INCLUDE statement;  by specifying /LIST
   (or /NOLIST) the user can cause the VAX/VMS Fortran and  Fortran-10/20
   to  behave  in a like way.  For symmetry, Fortran-10/20 has also added
   the /CREF switch.  Fortran-10/20 will continue  to  assume  /LIST  and
   /CREF as the default.

   INCLUDEd source may contain INCLUDE statements.  INCLUDE may be nested
   up through 12 levels.



   2.7  Change To The /DEBUG:ARGUMENTS Switch

   The function of this compiler switch has been  enhanced  so  that  the
   following checking is done:

        1.  The length of array arguments will be checked at  LINK  time.
            If  the  length  of  array  actual  argument is less than the
            corresponding  array  dummy  argument,  LINK  will  issue   a
            non-fatal  error  message.   If  the size of the array is not
            known at compile time (adjustably dimensioned or assumed size
            arrays), the checking is not done.

        2.  The structure of statement function arguments will be checked
            at  compile  time.   If  a non-routine name is passed where a
            routine name is expected, or a routine name is passed where a
            non-routine  name is expected, Fortran will issue a non-fatal
            error message.

        3.  The  length  of  character  arguments  will  be  checked  for
            statement  functions  at  compile time.  If the length of the
            actual character expression being passed  to  a  function  or
            subroutine  is shorter than the formal variable, then Fortran
   FORTRA.DOC -- Fortran-10 Version 10                            Page 18


            will issue a non-fatal error message.




   2.8  New Bit-Manipulation Routines

   Several  new  intrinsic  functions,  and  one  subroutine,  have  been
   included in Version 10 in support of MIL-STD-1753.

   In the following descriptions, 'bit position' is taken from  right  to
   left,  i.e.   bit  0 is the right-most bit and bit 35 is the left-most
   bit.

   The instrinsic functions are:

        1.  IAND (K1,K2) - A bit-wise logical AND of integers K1 and  K2,
            producing an integer

        2.  IOR (K1,K2) - A bit-wise logical inclusive OR of integers  K1
            and K2, producing an integer

        3.  IEOR (K1,K2) - A  bit-wise  logical  exclusive  OR  (XOR)  of
            integers K1 and K2, producing an integer

        4.  NOT (K1) - A  bit-wise  logical  complement  of  integer  K1,
            producing an integer

        5.  ISHFT (K1,K2) - A logical shift of integer  K1  by  K2  bits,
            producing an integer.  If K2 is positive, the shift is to the
            left, a negative K2 causes a shift to the right.  The vacated
            bit positions are filled with zeroes.

        6.  ISHFTC (K1,K2,K3) - A logical rotation  by  K2  bits  of  the
            right-most  K3  bits  of  K1, producing an integer.  If K2 is
            positive the rotation is to the left, a negative K2 causes  a
            rotation to the right.

        7.  IBITS (K1,K2,K3) - Bits K2  through  K2+K3-1  of  integer  K1
            appear right justified in the integer result.

        8.  IBSET (K1,K2,K3) - The integer result  will  be  the  integer
            value K1, with bits K2 through K2+K3-1 set to ones.

        9.  IBCLR (K1,K2,K3) - The integer result  will  be  the  integer
            value K1, with bits K2 through K2+K3-1 set to zeroes.

       10.  BTEST (K1,K2) - The logical result will be .TRUE.  if bit  K2
            of integer K1 is a 1, and .FALSE.  if that bit is 0.


   There is one subroutine, MVBITS(M,K,LEN,N,J).  All  of  the  arguments
   are  integer.   Bits  K through K+LEN-1 of variable M are moved to bit
   positions J through J+LEN-1 of variable N.
   FORTRA.DOC -- Fortran-10 Version 10                            Page 19


   2.9  Changes In The Use Of Octal Constants

   Version 7 of Fortran ignores any leading zeroes in an octal  constant;
   thus  "0000000000001  (12  leading  zeroes)  would  be  treated  as  a
   single-precision constant.  Version 10 counts the  leading  zeroes  to
   determine  the  precision  of the constant, so that the above constant
   would be double precision.



   2.10  PARAMETER Statements With Expressions Of Type COMPLEX

   Fortran  V7  does  not  allow  the   PARAMETER   statement   to   have
   multiplication, division nor exponentiation involving operands of type
   COMPLEX.  Fortran V10 has removed that restriction.

   Since the calculations involving  PARAMETER  statements  are  done  at
   compile  time,  computation  involving complex data may use algorithms
   that differ from those used at runtime.  Thus it is possible that  the
   result of using a PARAMETER statement may differ in accuracy from that
   of runtime  calculation.   An  attempt  has  been  made  to  make  the
   PARAMETER statement produce results that are as accurate as possible.



   2.11  IMPLICIT NONE Statement

   The IMPLICIT NONE statement can  be  used  to  override  all  implicit
   default  type  declarations.   If the IMPLICIT NONE statement is used,
   the data type of all symbolic names in the program must  be  explicity
   declared,  and  no  other  IMPLICIT  statement  can be included in the
   program unit.



   2.12  Octal And Hexadecimal Values In DATA Statements

   The DATA statement may contain two additional forms  of  constants  in
   the data value lists, which will result in right-justified values.

        1.  O'ddddd - An octal constant containing the digits 0-7.

        2.  Z'hhhhh - A hexadecimal constant containing  the  digits  0-9
            and the letters A-F (to represent the decimal values 10-15).




   2.13  PAUSE ON ERROR Command For FORDDT

   The PAUSE ON ERROR command will cause FORDDT  to  inform  the  runtime
   system  that  it  must  trap  to  FORDDT  after displaying any runtime
   diagnostic message e.g.  integer overflow,  subscript  bounds  failure
   (if  /DEBUG:BOUNDS  is  specified at compile time).  This trap will be
   treated as if it were a normal PAUSE, and the user can use any of  the
   FORTRA.DOC -- Fortran-10 Version 10                            Page 20


   FORDDT  commands  to  display and/or alter data before proceeding with
   the CONTINUE command.

   To remove the trap, the REMOVE ON ERROR command is used.

   Note that after a trap on a fatal  I/O  error,  the  FORDDT  TYPE  and
   ACCEPT  commands  cannot be used, since they will cause an 'I/O within
   I/O' error.
   FORTRA.DOC -- Fortran-10 Version 10                            Page 21


   3.0  RESTRICTIONS

   None



   4.0  KNOWN BUGS AND DEFICIENCIES

   None



   5.0  COMPATIBILITY WITH PREVIOUS VERSIONS

   Fortran V10 will support programs that currently run under Fortran V7,
   within the guidelines listed below in this section.

        1.  Certain input/output statement specifiers have  been  changed
            (See section 2.4).

        2.  The /FLAG switch has  been  added  to  the  compiler  command
            parser (See 2.2.1).

        3.  The data type declaration REAL*16 is  now  converted  to  the
            more realistic REAL*8 instead of REAL*4 as was done in V7.  A
            warning message is still given.




   6.0  INTERNAL CHANGES

   FOROTS, the compiler, FORDDT and the math library have  been  modified
   to  support  the  new  features  that  are  in this release.  Complete
   revision histories are contained in  REVHST.MAC  (for  the  compiler),
   FORHST.MAC  (for  FOROTS), FORDDT.MAC (for FORDDT) and MTHHST.MAC (for
   the math library).












                                 APPENDIX A

           SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER



   A.1  SOURCE DIFFERENCES


        a.  Comments
            Messages: (BOTH) Non-standard character in column 1
                      (ANSI) Comment on statement

            The ANSI standard specifies that comment lines must have  the
            characters  C or asterisk (*) in column 1.  Fortran-10/20 and
            VMS allow the exclamation mark (!) to appear anywhere in  the
            source  line, to denote the start of a comment.  In addition,
            Fortran-10/20 allows the characters dollar ($)  or  slash (/)
            in column 1 to denote a comment line.

        b.  DEBUG lines
            Message: (ANSI) DEBUG lines

            Both Fortran-10/20 and  VMS  recognize  the  character  D  in
            column  1  to  denote a statement which is either compiled or
            treated as a comment, depending upon the presence or  absence
            of  a command switch at compile time.  The ANSI standard does
            not recognize this feature.

        c.  Long Identifiers

            Fortran-10/20 currently warns the user when an identifier  of
            more  than  six  characters  is used, and allows only letters
            and/or digits;  VMS allows up  to  31  characters,  including
            letters,   digits,   dollar ($)  and  underscore (_).   Since
            Fortran-10/20 currently complains, no change is made.

        d.  Identifiers and global names
            Messages: (VMS) xxxx is same as entry point
                            xxxx is same as NAMELIST name
                            xxxx is same as variable name
                            xxxx is the same as PARAMETER name

            Both Fortran-10/20 and VMS currently prohibit the name of any
            program,  subprogram,  entry point or COMMON block from being
            the same as any  other  subprogram,  entry  point  or  COMMON
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER        Page A-2


            block.

            VMS further prohibits any program, subprogram or entry  point
            to be the same as any identifier, PARAMETER or NAMELIST.

        e.  Multi-Statement lines
            Message: (BOTH) Multi-statement line

            Fortran-10/20 allows more than one statement to appear  on  a
            line,  with  the  semi-colon  (;) separator.  Neither VMS nor
            ANSI allows this.




   A.2  DATA TYPES


        a.  Hollerith constants
            Messages: (ANSI) Hollerith constant
                      (VMS)  Hollerith constant padded with spaces

            ANSI  does  not  recognize  constants  of  the  form   nHccc;
            Fortran-10/20 and VMS do allow them.  Fortran-10/20 pads such
            a constant with spaces in order to fill  a  word;   VMS  does
            not.

        b.  Octal constants
            Message: (BOTH) Octal constant

            ANSI  does  not   recognize   octal   constants.    VMS   and
            Fortran-10/20  do  allow  octal  constants, but Fortran-10/20
            expects them in the form "ddd (a quote followed by 1-24 octal
            digits), whereas VMS expects 'dddd'O (octal digits surrounded
            by apostrophes and delimited by the letter O).

        c.  Length specifiers
            Message: (ANSI) xxxxx  length  specifier    (xxxxx  is   data
            type)

            ANSI does not recognize certain  length  specifiers  in  data
            type  declarations  nor in FUNCTION statements.  Both VMS and
            Fortran-10/20 do allow them, but VMS has a  larger  selection
            of specifiers.

            The only length specifiers recognized by ANSI are CHARACTER*n
            and CHARACTER*(*).

            In addition to the ANSI  specifiers,  Fortran-10/20  and  VMS
            accept  INTEGER*4,  REAL*4,  REAL*8, COMPLEX*8 and LOGICAL*4.
            These five specifiers receive the new warning message if ANSI
            flagging is in effect.
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER        Page A-3


            Fortran-10/20 warns about:

                      INTEGER*2  (Uses INTEGER*4)
                      LOGICAL*1  (Uses LOGICAL*4)
                      REAL*16    (Uses REAL*8)
                      COMPLEX*16 (Uses COMPLEX*8)
                      COMPLEX*32 (Uses COMPLEX*8)

            and produces a fatal message for all others.  In order to  be
            more  compatible with VMS, Fortran-10/20 has been modified to
            allow LOGICAL*2 after producing a warning and changing it  to
            LOGICAL*4.   In all other cases, the current warning or fatal
            message is retained.




   A.3  EXPRESSIONS


        a.  Symbolic relational operators
            Message: (BOTH) Symbolic relational operator x
                                     (x replaced by operator)

            Fortran-10/20 treats the symbolic  relational  operators  (<,
            <=, >, >=, == and #) as the standard relationals (.LT., .LE.,
            .GT., .GE., .EQ.  and .NE.).  Neither VMS nor ANSI recognizes
            the symbolic versions.

        b.  Exponentiation operator (^)
            Message: (BOTH) Exponential operator ^

            Fortran allows the caret (^) as well as the  standard  double
            asterisk (**) to denote exponentiation.  Neither VMS nor ANSI
            recognizes this construct.

        c.  XOR operator
            Message: (ANSI) Logical .XOR. operator

            Fortran-10/20 and VMS support the logical operator .XOR. as a
            synonym for .NEQV., but ANSI does not allow it.

        d.  Consecutive arithmetic operators
            Messages: (ANSI) Consecutive arithmetic operators
                      (VMS)  Different precedence in exponentiation

            Both  Fortran-10/20  and  VMS  allow  the  unary   arithmetic
            operators  (-  and  +)  to follow a binary operator, but with
            slightly different precedence rules;   ANSI  does  not  allow
            this construct at all.

            Given the expression A**-B*C, Fortran-10/20 would parse it as
            (A**(-B))*C,  whereas  VMS gives the unique interpretation of
            A**(-(B*C)).
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER        Page A-4


        e.  Concantenation of character data of length (*).
            Message: (ANSI) Concantenation with variable of  non-specific
            length

            Subprograms may specify a dummy character argument as  having
            length  (*), meaning 'use the length of the actual argument'.
            ANSI  does  not   allow   such   variables   to   appear   in
            concantenation expressions, but both VMS and Fortran-10/20 do
            allow them.

        f.  Non-integers in an integer context
            Messages: (ANSI) Non-integer subscript
                             Non-integer substring bounds
                             Non-integer as index to computed GOTO
                             Non-integer as index to RETURN
                             Non-integer used with xxxx
                                          (xxxx becomes I/O keyword)

            ANSI does not allow non-integers in the above  contexts,  but
            both  VMS  and  Fortran-10/20 convert any numeric variable to
            integer.

        g.  Numeric expressions in logical context
            Messages: (BOTH) Mixing logical and numeric
                             Numeric operand in logical context

            ANSI does not allow mixed logical/numeric expressions.

            Fortran-10/20 treats any  numeric  expression  in  a  logical
            context  as if it were a bit string (typeless quantity).  VMS
            does  the  same  for  integer  expressions,  but  non-integer
            numeric  expressions  are allowed only when assigning such an
            expression to a logical variable.

            Fortran-10/20 tests the high-order (sign) bit of  a  variable
            for  true/false,  whereas  VMS  tests  the low-order bit.  If
            numeric  expressions  are  used   in   a   logical   context,
            incompatibilities could result.

        h.  Logical expressions in numeric context
            Messages: (BOTH) Mixing logical and numeric
                             Logical operand in numeric context

            ANSI does not allow mixed logical/numeric expressions.

            VMS treats the logical expression in this context  as  if  it
            were  an  integer,  whereas  Fortran-10/20  treats  it  as  a
            typeless quantity.

        i.  Numeric variables in character context
            Message: (ANSI) Numeric expression in character context

            ANSI does  not  allow  numeric  expressions  in  a  character
            context.  Both VMS and Fortran-10/20 allow numeric scalars or
            arrays that contain Hollerith data  to  be  used  in  certain
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER        Page A-5


            contexts, such as OPEN and CLOSE keywords and as arguments to
            some Fortran-supplied subroutines.

        j.  Overlap of character assignments
            Message: (ANSI) Assigned  variable   appears   in   character
            expression

            The ANSI standard forbids the right-hand side of a  character
            assignment  statement  from  referencing any of the character
            positions of the  character  variable  or  substring  on  the
            left-hand side.  Both VMS and Fortran-10/20 allow this.




   A.4  SUBROUTINES AND FUNCTION ARGUMENT LISTS


        a.  Return labels
            Messages: (ANSI) & used as return label
                      (BOTH) $ used as return label

            The ANSI standard specifies that an asterisk (*)  used  as  a
            dummy  argument  in a subprogram specifies an alternate point
            of return for the subprogram.  VMS allows an ampersand (&) as
            well  as  the  asterisk,  and  Fortran-10/20 allows asterisk,
            ampersand and dollar ($).

        b.  Passing values

            Fortran-10/20  passes  scalar  numeric  arguments  by  value,
            whereas  VMS  passes  them by reference.  This difference can
            produce different results in certain limited cases:

             o  When multiple copies of the same variable are passed to a
                subprogram

             o  When  a  passed  variable  is  also  referenced  by   the
                subprogram through COMMON

             o  When a subprogram contains more than one entry point, and
                the argument lists of the entry points do not agree.


            Each of these cases is specifically  forbidden  by  the  ANSI
            standard,   and  are  incompatibilities  not  caught  by  the
            flagger.

   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER        Page A-6


   A.5  SPECIFIC STATEMENTS


        a.  ACCEPT
            Message: (ANSI) ACCEPT statement

            The ACCEPT statement is supported by VMS  and  Fortran-10/20,
            but is not recognized by ANSI.

        b.  BACKFILE
            Message: (BOTH) BACKFILE statement

            The BACKFILE statement is supported by Fortran-10/20, but  by
            neither VMS nor ANSI.

        c.  COMMON
            Message: (BOTH) Character and non-character variables in
                                COMMON
                     (VMS)  Null padding before xxxxx
                                     (xxxxx is variable name)

            ANSI forbids the mixing of numeric and character data in  any
            one  common  block.   Both  Fortran-10/20  and  VMS allow it.
            Fortran-10/20 V7 always produces a warning in this case;  V10
            produces  the  warning  only  when  compatibility flagging is
            being done.

            Since non-character variables must start  at  a  36-bit  word
            boundary  in Fortran-10/20 but not on VMS, the second message
            is written if padding is introduced.

        d.  DATA
            Message: (ANSI) Substring bounds not constant

            ANSI  forbids  the  use  of  the  implied  DO   clause   when
            referencing  substring  bounds.   Both  Fortran-10/20 and VMS
            allow this.

        e.  DECODE
            Message: (ANSI) DECODE statement

            ANSI does not recognize the DECODE statement.  Both  VMS  and
            Fortran-10/20 do allow the DECODE, with these differences:

                 o Character count -- Fortran-10/20 treats the  character
                   count  as  an internal record size, whereas VMS treats
                   it as a total string count.

                 o Slash (/) format descriptor -- Fortran-10/20  advances
                   to  the  next  internal  record upon encountering this
                   descriptor, whereas VMS does not allow the descriptor.

        f.  DO with no statement label
            Message: (ANSI) DO without statement label
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER        Page A-7


            Both Fortran-10/20 and VMS accept a DO statement  which  does
            not specify a terminating statement label;  such a DO loop is
            instead terminated by an END DO  statement.   ANSI  does  not
            recognize this.

        g.  DO WHILE
            Message: (ANSI) DO WHILE statement

            Both VMS and Fortran-10/20 support  the  DO WHILE  statement,
            ANSI does not.

        h.  DO extended range
            Message: (ANSI) Transfer of control into DO loop

            Extended range DO loops make it possible to transfer  out  of
            the  loop,  execute  statements  in  another  section  of the
            program, and then transfer back into the DO  loop.   VMS  and
            Fortran-10/20 allow this, but ANSI does not.

            This condition is not flagged if the compilation is not being
            globally optimized, because it is only in that optimizer that
            the flow of control of a program is analyzed.

        i.  END DO
            Message: (ANSI) END DO statement

            The END DO statement terminates a DO WHILE or DO loop without
            the  terminating  statement  label.   This  is  supported  by
            Fortran-10/20 and VMS, but not by ANSI.

        j.  ENCODE
            Message: (ANSI) ENCODE statement

            The ENCODE statement is the reverse of the DECODE  statement,
            and the same incompatibilities occur (See DECODE above).

        k.  EQUIVALENCE
                 (ANSI) Character and non-character are EQUIVALENCE-d
                        Single subscript with multi-dimensioned array

            Both  VMS  and  Fortran-10/20  allow  the  use  of  a  single
            subscript  to specify the offset of a multi-dimensioned array
            in the EQUIVALENCE statement;  ANSI does not.

            ANSI forbids the mixing of numeric and character data in  any
            one  equivalence group.  Both Fortran-10/20 and VMS allow it.
            Fortran V7 always produces a warning in this  case;   in  V10
            that warning is issued only under compatibility flagging.

        l.  EXTERNAL
            Messages: (ANSI) * with external name
                      (BOTH) & with external name
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER        Page A-8


            VMS and Fortran-10/20 have  extended  the  ANSI  standard  to
            specify  that  a  user-supplied  subprogram  is to be used in
            place  of   an   intrinsic   function   or   Fortran-supplied
            subroutine.   This is done by placing an asterisk in front of
            the name.  Further, Fortran-10/20 allows an ampersand in this
            context, but VMS does not.

        m.  FIND
            Message: (ANSI) FIND statement

            The FIND statement is supported by VMS and Fortran-10/20, but
            not by ANSI.

        n.  Assigned GOTO
            Message: (VMS) List of labels

            VMS ignores the optional list of labels in an  assigned  GOTO
            statement.   Fortran-10/20  checks  at  runtime to see if the
            assigned variable matches one of the labels in the list,  and
            proceeds to the next statement if there is no match.

        o.  Two-branch logical IF
            Message: (BOTH) Two-branch logical IF

            Fortran-10/20 supports a statement of the form

                      IF (A .LT.  B) 10,20

            where statement label 10 is the 'true'  path,  and  statement
            label  20 is the 'false' path.  Neither VMS nor ANSI supports
            this variation of the IF statement.

        p.  INCLUDE
            Messages: (ANSI) INCLUDE statement
                      (VMS)  /NOCREF switch
                             /CREF switch
                             Default for VMS is /NOLIST

            ANSI does not support the INCLUDE statement.

            Fortran-10/20 lists the included source  unless  the  /NOLIST
            switch  is  used  with  the statement, whereas VMS lists that
            source only if the /LIST switch is used with the statement or
            if  the /SHOW=INCLUDE switch is used in the compiler command.
            VMS does not recognize the /CREF and /NOCREF switches used by
            Fortran-10/20.

        q.  NAMELIST
            Message: (ANSI) NAMELIST statement

            The NAMELIST statement is not  recognized  by  ANSI,  but  is
            supported by both VMS and Fortran-10/20.
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER        Page A-9


        r.  PARAMETER
            Message: (ANSI) No parentheses around PARAMETER list

            ANSI insists upon parentheses surrounding the  constant  list
            in  the  PARAMETER  statement, but both Fortran-10/20 and VMS
            accepts the statement without the parentheses.

            Note that both VMS and Fortran-10/20 assign to  the  constant
            the  data  type  of the symbol when parentheses are used, but
            assign to the symbol the  data  type  of  the  constant  when
            parentheses are not used.

        s.  PRINT
            Message: (BOTH) PRINT (Specifiers) statement

            Fortran-10/20 supports the PRINT statement of  the  following
            form:

                      PRINT (specifiers) iolist

            Neither VMS nor ANSI supports the (specifiers).

        t.  PUNCH
            Message: (BOTH) PUNCH statement

            Neither  VMS  nor  ANSI  supports  the  Fortran-10/20   PUNCH
            statement.

        u.  REREAD
            Message: (BOTH) REREAD statement

            The Fortran-10/20 REREAD statement is  supported  by  neither
            VMS nor ANSI.

        v.  SKIPFILE
            Message: (BOTH) SKIPFILE statement

            The Fortran-10/20 SKIPFILE statement is supported by  neither
            VMS nor ANSI.

        w.  SKIPRECORD
            Message: (BOTH) SKIPRECORD statement

            The  Fortran-10/20  SKIPRECORD  statement  is  supported   by
            neither VMS nor ANSI.

        x.  TYPE
            Message: (ANSI) TYPE statement

            The TYPE statement is supported by Fortran-10/20 and VMS, but
            not by ANSI.

        y.  UNLOAD
            Message: (BOTH) UNLOAD statement
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER       Page A-10


            The Fortran-10/20 UNLOAD statement is  supported  by  neither
            VMS nor ANSI.

        z.  WRITE
            Message: (BOTH) WRITE with default unit

            Fortran-10/20 supports a default unit in the WRITE statement,
            but neither VMS nor ANSI allows this.




   A.6  FORMAT STATEMENT


        a.  Format specifiers not supported by ANSI
            Messages: (ANSI) FORMAT edit descriptor x      (x is specific
            descriptor)
                      No decimal places specified with x

            Fortran-10/20 and VMS support $, O, Q, Z

            Fortran-10/20 (but not VMS) supports:

                 R
                 F, E, D, G in form Fw instead of Fw.0
                 G with character I/O

        b.  Default widths
            Message: (BOTH) Default widths with edit descriptor x

            Fortran-10/20 and VMS differ  on  the  field  width  that  is
            assumed if not explicitly specified.

        c.  Optional commas
            Message: (ANSI) Comma field separator is missing

            VMS and Fortran-10/20 allow  comma  field  separators  to  be
            omitted,  if  there  is no ambiguity in the interpretation of
            the format.  ANSI does not support this.

        d.  Formats in Arrays
            Message: (ANSI) Format in numeric array

            Both VMS and Fortran-10/20 allow  formats  to  be  stored  in
            numeric arrays as Hollerith constants.  ANSI does not support
            this.

   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER       Page A-11


   A.7  INPUT/OUTPUT STATEMENTS

   Many of these incompatibilities are detected  by  FOROTS  at  runtime,
   since  keyword  clauses  in  the  I/O  statements  could have variable
   arguments.  The compiler can detect incompatibilities if the arguments
   are constants.

        a.  Default file names
            Message: (VMS) Default file name

            VMS and Fortran-10/20 differ on the names of files for  which
            no explicit name is given.

        b.  Apostrophe form of record specifier
            Message: (ANSI) Apostrophe in I/O specifier

            ANSI does not support the Fortran-10/20 and VMS I/O specifier
            of the form

                      (unit'recordnumber ...)

        c.  Blanks at end of output line

            Normally, the X format edit  descriptor  cannot  be  used  to
            write  blanks  at  the end of a line.  Fortran-10/20 (but not
            VMS) has one exception:  if the line is written  with  the  $
            carriage-control, or the $ edit descriptor is used to end the
            line, those blanks are written.

            This is detected at runtime.

        d.  Carriage Control
            Message: (BOTH) Carriage control character x

            Neither VMS nor ANSI recognizes  the  Fortran-10/20  carriage
            control  characters  2, 3, -, *, /, $, period or comma.  This
            is detected at runtime.

        e.  NML= versus FMT=
            Messages: (ANSI) Use of NAMELIST
                      (VMS)  Keyword FMT instead of NML

            Fortran-10/20 accepts either keyword FMT= or NML= to  specify
            a NAMELIST in an I/O statement;  VMS accepts only NML=;  ANSI
            does not supports NAMELIST at all.

        f.  Keywords not recognized by ANSI
            Messages: (ANSI) Keyword xxxxx
                             Keyword value for xxxxx

            ACCESS='APPEND', 'SEQIN', 'SEQOUT', 'SEQINOUT', 'RANDOM' and
                   'RANDIN'
            ASSOCIATEVARIABLE=
            BLOCKSIZE=
            BUFFERCOUNT=
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER       Page A-12


            CARRIAGECONTROL=
            DENSITY=
            DEVICE=
            DIALOG and DIALOG=
            DIRECTORY=
            DISPOSE=
            FILE= with CLOSE
            FILESIZE=
            INITIALIZE=
            MODE=
            NAME=
            PADCHAR=
            PARITY=
            PROTECTION=
            READONLY
            RECORDSIZE=
            RECORDTYPE=
            STATUS='EXPUNGE' with OPEN or CLOSE
            STATUS='DELETE' or 'KEEP' with OPEN
            TAPEFORMAT=
            TYPE=
            VERSION=

        g.  Keywords not recognized by VMS
            Messages: (VMS) Keyword xxxxx
                            Keyword value for xxxxx

            ACCESS='SEQIN', 'SEQOUT', 'SEQINOUT', 'RANDOM' and 'RANDIN'
            CARRIAGECONTROL='DEVICE' and 'TRANSLATED'
            DENSITY=
            DEVICE=
            DIALOG and DIALOG=
            DIRECTORY=
            DISPOSE='EXPUNGE', 'LIST', 'PUNCH' and 'RENAME'
            FILESIZE=
            INITIALIZE=
            MODE=
            PADCHAR=
            PARITY=
            PROTECTION=
            STATUS (or TYPE)='DELETE' and 'KEEP' in the OPEN statement
            STATUS (or TYPE)='EXPUNGE' in the OPEN or CLOSE statements
            TAPEFORMAT=
            VERSION=

        h.  Keywords which are incompatible between Fortran-10/20 and VMS
            Messages: (VMS) Keyword xxxxx
                            Keyword value for xxxxx

            CARRIAGECONTROL=
            RECL=
            ASSOCIATEVARIABLE=
            DISPOSE='DELETE', 'KEEP', 'PRINT' and 'SAVE'
            TYPE='NEW', 'OLD', 'SCRATCH' and 'UNKNOWN'
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER       Page A-13


   A.8  INTRINSIC FUNCTIONS AND FORTRAN-SUPPLIED SUBROUTINES

   Messages: (VMS)  xxxxx is an intrinsic function on VMS
                    xxxxx is a Fortran-supplied routine on VMS
                    xxxxx is a generic function on VMS
                    xxxxx is not a generic function on VMS
             (ANSI) xxxxx is not an intrinsic function in Fortran-77
                    xxxxx is not a generic function in Fortran-77

   There are numerous differences between Fortran-10/20 and both VMS  and
   ANSI   in  the  names  of  intrinsic  functions  and  Fortran-supplied
   subroutines.

        a.  Fortran-10/20 Intrinsic Functions

            Instrinsic functions available on Fortran-10/20 which are not
            available on VMS:

               COTAN   DCOTAN

            Intrinsic functions available on Fortran-10/20 which are  not
            available in the Fortran-77 standard:

               BTEST   CMPLX   COSD    COTAN   DCOTAN  DFLOAT  IAND
               IBCLR   IBITS   IBSET   IEOR    IOR     ISHFT   ISHFTC
               NOT     SIND

        b.  Fortran-10/20 Fortran-supplied Subroutines

            Included here are those subroutines supplied by Fortran-10/20
            but not by VMS.

               CHKDIV  CLRFMT  DIVERT  DTOGA   DUMP    FFUNIT  GTODA
               ILL     LEGAL   OVERFL  PDUMP   QUIETX  SAVFMT  SAVRAN
               SETRAN  SORT    TRACE

            The  following  subroutine  is  available  on  both  VMS  and
            Fortran-10/20, but is not known to Fortran-77.

               MVBITS

        c.  VMS Generic Functions

            Included here are functions which are generic on VMS, but not
            generic in Fortran-10/20.

               COSD    SIND    TAND

        d.  Fortran-10/20 Generic Functions

            Included  here   are   functions   which   are   generic   in
            Fortran-10/20, but are generic on neither VMS nor Fortran-77.

               ALOG    ALOG10  AMAX1   AMIN1
   SPECIFICS OF INCOMPATIBILITIES DETECTED BY THE FLAGGER       Page A-14


        e.  Fortran-10/20 Subroutines versus VMS Intrinsic Functions

            Included  here  are  intrinsic  functions  on  VMS,  but  are
            Fortran-supplied subroutines in Fortran-10/20.

               CDSQRT  CDLOG   CDEXP   CDSIN

        f.  Differences in Subroutines

            Included here are those  Fortran-supplied  subroutines  which
            behave  differently,  or  which  have different arguments, on
            Fortran-10/20 and VMS.

               DATE    ERRSET  ERRSNS  EXIT    TIME




   A.9  FUNCTIONS AND SUBROUTINES ON VMS NOT RECOGNIZED BY FORTRAN-10/20

   These  subprograms  are  recognized  by  VMS  Fortran,  but   not   by
   Fortran-10/20.  No flagging is done with these subprograms.

        a.  VMS Intrinsic Functions

               ACOSD   DBLEQ   IIAND   JIAND   QACOS   QDIM    QSIN
               ASIND   DCMPLX  IIBCLR  JIBCLR  QACOSD  QEXP    QSIND
               ATAN2D  DCONJG  IIBITS  JIBITS  QASIN   QEXT    QSINH
               ATAND   DREAL   IIBSET  JIBSET  QASIND  QEXTD   QSQRT
               BITEST  DIMAG   IIEOR   JIEOR   QATAN   QLOG    QTAN
               BJTEST  DTAND   IIOR    JIOR    QATAN2  QLOG10  QTAND
               DACOSD          IISHFT  JISHFT  QATAN2D QMAX1   QTANH
               DASIND          IISHFTC JISHFTC QATAND  QMIN1   SNGLQ
               DATAN2D         INOT    JNOT    QCOS    QMOD    TAND
               DATAND          IZEXT   JZEXT   QCOSD   QSIGN   ZEXT
                                               QCOSH

        b.  VMS Fortran-supplied Subroutines

               ASSIGN  CLOSE   ERRTST  FDBSET  IDATE   IRAD50
               R50ASC  RAD50   RANDU   USEREX


   [End of FORTRA.DOC]
kmuU