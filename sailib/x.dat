$text SCANU;TokenType_ SCANU( @"arg" ).
TokenType_ SCANU( @"arg" );
simple integer procedure scanu(reference string arg);
Comment SCANU(string) acts as a simple scanner.  It returns
	an integer dependent on the element scanned.
	0 String is null (end of line).
	1 Identifier (say external string ACCUM and ACCUM will
	   contain the text).
	2 Number (integer) external integer SCNVAL has the number.
	3 Special character again SCNVAL has the value.
String will contain the remaining chrs after the call.
Leading blanks (and tabs) are ignored;


$text SCANSS;OldValue_ SCANSS( StopOnLetter ).
OldValue_ SCANSS( StopOnLetter );
SIMPLE BOOLEAN PROCEDURE SCANSS(BOOLEAN B);
Comment In some cases SCANU should stop after one character when
	the first non-blank character is a letter (i.e. p100).
	calling SCANSS(true) will enter this mode.  SCANSS(false)
	will return to normal identifier scanning.
	SCANSS returns its previous value.

$text SCANSN;OldValue_ SCANSN( SignSpecial ).
OldValue_ SCANSN( SignSpecial );
SIMPLE BOOLEAN PROCEDURE SCANSN(BOOLEAN B);
Comment normally SCANU treats + and - as possible signs for
	numbers.  In some cases, it may be desirable to have SCANU
	return these as special characters.  Calling SCANSN(false)
	will enter this mode.  SCANSN(TRUE) will leave this mode.
	SCANSN returns its previous value.

$text STRSRC;Index_ STRSRC( @array "names", "look", @exact ).
Index_ STRSRC( @array "names", "look", @exact );
SIMPLE INTEGER PROCEDURE STRSRC(STRING ARRAY NAMES;
	STRING LOOK; REFERENCE BOOLEAN EXACT);
Comment This routine is called with a string and a string
    array.  It searches for a match and returns the index
    into the array of the match.  To avoid confusion, the
    lower array bound should be 1 or greater.  If no match is
    found, 0 is returned.  The procedure will try to find
    an exact match.  Failing this, it will look for strings
    which match on all the characters in the string argument.
    The flag EXACT will be set true if an exact match is found.
    if no exact match is found and several partial matches exist
    the procedure will return 0.
    Call is STRSRC(array,string,flag);

$text RDDATE;SuccessMaybe_ RDDATE( @date, @ovscan, fstscn, @"str" ).
SuccessMaybe_ RDDATE( @date, @ovscan, fstscn, @"str" );
SIMPLE BOOLEAN PROCEDURE RDDATE(REFERENCE INTEGER DATE,
	OVSCAN; VALUE INTEGER FSTSCN; REFERENCE STRING STR);
Comment This procedure reads the date from the string passed.
	It uses SCANU and STRSRC.  It assumes that SCANU
	has been called before it and the value returned by
	SCANU is passed in FSTSCN.  It calls SCANU one extra time
	and returns the value in ovscan.  The date is returned
	in date in the standard DEC date format

		((yr-64)*12+month-1)*31+day-1
	It accepts dates in the following formats
		MM-DD-YY
		DD-MONTH-YY
		MONTH DD,YY
	DD is the day (as a number) MM the month (as a number)
	MONTH the name for the month (or a shortened version as
	SEP for SEPTEMBER).  The - may be omitted or replaced
	by a /.  The year (YY) may be either a 2 digit year as 76
	or a 4 digit year as 1976;

$text STDATE;"dateString"_ STDATE( date, flags ).
"dateString"_ STDATE( date, flags );
Comment This procedure takes an integer DATE in DEC date format
	and generates a string from it.  The integer FLAG controls
	the formatting for the string returned as follows:

	bits 33-35 (FLAGS land '7) is the general format
	 (DD indicates day as a number MM month as a number
	  MON month as text and YY year as a number (2 or 4 digits)
	 0 MM-DD-YY	 1 DD-MON-YY	 2 DD-MM-YY	 3 MON DD,YY
	 unassigned formats are the same as 1.
	bits 29-32 (FLAGS lsh -3 land '17) are the size of the
	 MON string (0 is full width) this is the max width.
	bit 28 (FLAGS land '200) indicates that the year is
	 4 digits not 2
	bits 26-27 (FLAGS lsh -8 land '3) give a character to replace
	 the - in formats 0,1, and 2: 0 is - 1 is / 2 is blank
	 3 is undefined (blank);

$text RDTIME;SuccessMaybe_ RDTIME( @time, @ovscan, fstscn, @"STR" ).
SuccessMaybe_ RDTIME( @time, @ovscan, fstscn, @"STR" );
SIMPLE BOOLEAN PROCEDURE RDTIME(REFERENCE INTEGER TIME,
	OVSCAN; VALUE INTEGER FSTSCN; REFERENCE STRING STR);
Comment This procedure reads the time from the string passed.
	It uses SCANU and assumes that SCANU has been called
	before it.  The value returned by SCANU is in FSTSCN.
	The time formats accepted are HHMM or HH:MM.  The time
	returned in time is in minutes since midnight.  OVSCAN is
	set to the output of SCANU for the next element of the
	line;

$text LOKDUL;"username"_ LOKDUL( ppn ).
"username"_ LOKDUL( ppn );
SIMPLE STRING PROCEDURE LOKDUL(INTEGER PPN);

Comment reads DUL to find correspondence to PPN.  Allocates a channel 
	with GETCHAN.  String returned if PPN is found in the DUL is 
	(user name).  If not found, string is [project,programmer].
    NOTE: if you expect to find anything in the DUL, you must have 
	Read Files license.

$text INIUFR;(any!class)_ INIUFR("name","ext",chan,bits(0),size(102)).
(ANY!CLASS)_ INIUFR( "name", "extension", channel, bits(0), size(102) );
This is one of two procedures which are used together to
read UFD's (directories).  There is a setup procedure and a 
procedure which returns the "next" file name.  A "partial" 
search of the UFD may be done by using names containing # or *.
The procedure for reading a UFD is:
	open the channel and lookup the UFD
		[it is the file (UFD)<ppn>.UFD where <ppn> is the
		 directory PPN (or GAN,,UUN) in binary (not text)]
	call INIUFR
	call NXTUFR until it returns the value false (eof)

SIMPLE RECORD!POINTER (ANY!CLASS) PROCEDURE INIUFR(
	STRING NAME,EXTENSION; INTEGER CHANNEL,BITS(0),SIZE(102));

The string arguments NAME and EXTENSION determine which files
to "find".  To look at all files used "*" for both names,
for all SAI files use "*" and "SAI", etc.  A # in the name will
match any character.  BITS indicates the information to be
returned about each file as follows:
(where information is included if BITS land x = 1)
	X	INFORMATION
	1	license
	2	date and time
	4	status bits
	8	size in blocks
	16	causes * and # in file name and extension
		to be treated as any other character

	32	convert date and time to time zone specified 
		in  (bits lsh -6) land '177

For the time zone conversion field '100 is days since JAN 1,1964
instead of DEC date format, '40 is daylight savings time and
'37 is the time zone.  If not given, DATE and TIME are in
GMT.  Left half is date, rh time since midnight in seconds.
Size is a parameter specifying how big to make the internal
storage array.  The size specified should be for the number
of pieces of file information which you want to fit in this
area.  Any number smaller than 1 will be set to 1 and any
number greater than 102 will be set to 102.
Both BITS and SIZE may be omitted.  BITS will be assumed 0
and SIZE 102.

$text NXTUFR;Successful_ NXTUFR( array data, (ANY!CLASS) record ).
Successful_ NXTUFR( array data, (ANY!CLASS) record );
This is one of two procedures which are used together to
read UFD's (directories).  There is a setup procedure and a 
procedure which returns the "next" file name.  A "partial" 
search of the UFD may be done by using names containing # or *.
The procedure for reading a UFD is:
	open the channel and lookup the UFD
		[it is the file (UFD)<ppn>.UFD where <ppn> is the
		 directory PPN (or GAN,,UUN) in binary (not text)]
	call INIUFR
	call NXTUFR until it returns the value false (eof)

SIMPLE BOOLEAN PROCEDURE NXTUFR(INTEGER ARRAY DATA;
	RECORD!POINTER (ANY!CLASS) RECORD);
This procedure provides the "next" file from the UFD.  The
record pointer passed is the one returned by INIUFR.
The array DATA is loaded with the information
from the UFD.  The format is:

first word	name (sixbit)
second word	extension (sixbit)
		size if requested
		license if requested
		time and date if requested
		status if requested

Everything except the name and extension will be "compacted" (i.e.  if
only the license were requested it would appear in the third word, not
the fourth).  True is returned unless an error or end of file
is encountered.  (Check the eof word for the channel to find out)
this routine uses GENARY (described below).

$text GENARY;GENARY( array args, loc ).
GENARY( array args, loc );
Comment The routine GENARY is designed to generate arrays to be stored 
	into records.  These arrays will be properly garbage collected 
	when the records are deleted.  GENARY takes two arguments.  The
	first is an integer array of one dimension.  The range of 
	indices may be anything desired.  The first value is the number
	of dimensions desired.  The second is the lower bound for the 
	first dimension, then the upper bound for the first dimension, 
	then the lower for the second dimension, etc.  The second 
	argument to genary is the address of the array argument in the 
	record. If RP is the record pointer, RC the record class, and 
	RA the array field in the record, then use LOCATION(RC:RA[RP])
	for the second argument;

SIMPLE PROCEDURE GENARY(INTEGER ARRAY ARGS; INTEGER LOC);

WARNING!!!!! This procedure goes around the "back door" to generate 
arrays.  It might stop working (although probably not).  There are 
dangers.  If an array from a record is passed as an argument to a 
procedure and the procedure then causes the record that the array came 
from to be garbage collected (before returning), the array may be 
garbage collected out from under the procedure.  This is an unusual 
situation but must be watched.

$text CNVDATE;NewDateTime_ CNVDATE( date, fromFormat, toFormat ).
NewDateTime_ CNVDATE( date, fromFormat, toFormat );

	CNVDATE converts a date from one time zone or form (days since
JAN 1,1964 or DEC format) to another.  The format of fromFormat and 
toFormat are the same as used by the system.  That is '400000 indicates
days since JAN 1,1964 instead of DEC format.  '40 is daylight savings 
time.  Argument land '37 is the time zone ('20 is GMT).  If argument 
land '77 is 0, the users time zone will be used.  The definitions:
	CALLI!DATUUO!DEC, CALLI!DATUUO!DAYS, CALLI!DATUUO!DST
	and CALLI!DATUUO!GMT
are all in the file (SAILIB)TYMCAL.DEF which may be required.
$text CNVDTIM;CNVDTIM( @date, @time, fromFormat, toFormat ).
CNVDTIM( @date, @time, fromFormat, toFormat );

	fromFormat and toFormat are as in CNVDATE.  DATE and TIME are
modified to reflect the time zone change.  TIME is in seconds since 
midnight.  CNVDTIM takes a time and date and converts from one time 
zone or form to another.
$text RPGINI;(any!class)_ RPGINI( "TempFileName" ).
(any!class)_ RPGINI( "TempFileName" );
  Constructs a record for RPGNXT's "temporary file" data access.  
Temporary files are used by RPG to communicate tasks to processors.  
RPGINI is called with a 'temp' file name and returns a record pointer. 
RPGNXT is then passed that record pointer and returns the next line 
from the 'temp' file.  These procedures take care of looking in both 
TMPCOR and DSK and of deleting the files they read from.  They may be 
used in any program which must interface to RPG.
  The string passed to this procedure should be three characters in 
length (as "MAC" or "SAI").  The procedure will check tmpcor for the 
name and, if it is not found, DSK:JJJNAM.TMP where JJJ is the current 
job number.
  A note on file deletion.  If the file is found in TMPCOR, it will be
deleted after the call to RPGINI.  If the file is on the disk, it will
not be deleted until RPGNXT returns false.

$text RPGNXT;ObtainedData_ RPGNXT( @"data", (any!class) rpgRecord ).
ObtainedData_ RPGNXT( @"data", (any!class) rpgRecord );
  RpgRecord is a record pointer returned by RPGINI.  If there is more 
data in the file, RPGNXT will return TRUE with the next line of data in
DATA.  The return and line feed will not be included in the text 
returned.  Line numbers will be ignored if present.
  A note on file deletion.  If the file is found in TMPCOR, it will be
deleted after the call to RPGINI.  If the file is on the disk, it will
not be deleted until RPGNXT returns false.

$text FSM;Multiple string search overview.
	These are three procedures which provide a multiple substring
search capability for SAIL programs.  The search characteristics are 
relatively high storage and setup costs (though these are certainly not
excessive) and an extremely low use cost.  Typical uses would be for 
searches of large bodies of text for a number of targets (for example, 
a document search system where several requests are pooled, run 
together, and the results are then distributed to the requestors). 

	The speed of the search is attained by constructing a finite 
state machine which is interpreted for the actual search.  The machine 
only passes each character to be searched once, having decided what to 
do during the construction phase of the program.  Features available 
include having completely ignorable characters (typically an ASCII 0 
would fall in this category), and treating sets of characters as 
equivalent (eg regarding upper and lower case characters as identical).
Noteable for their absense are any form of wild-card characters (there 
is no room to compactly express them in the automaton, and the storage 
requirements would mushroom with such a feature).

	You will need at least one record!class in order to communicate
your targets to the automata constructor (MAKFSM).  It (they) must have
the first three fields arranged as follows:

 first: STRING (a typical example of the string this target represents)
	This field is only examined by MAKFSM, it works with its own 
	copy during construction.
 second: RECORD!POINTER (a link field that MAKFSM uses to construct
	linkages to inform you about relationships among the various 
	targets that you constructed.)  There is no restriction on the 
	contents of this field when you call MAKFSM, but any 
	information there will be destroyed before it returns (this is 
	not guaranteed in the case of errors detected by MAKFSM).  This
	field is used for all sorts of nefarious purposes during MAKFSM,
	but, when it is done, you may destroy the contents (at the cost
	of losing some information).
 third: RECORD!POINTER (a link field that allows you to hand a list of
	of targets to MAKFSM in a single procedure call).  This field 
	is also only read by MAKFSM, but the linkage must eventually 
	terminate with null!record in this field (otherwise MAKFSM will
	never terminate).
  These fields may have any name you like (if you have more than one
kind of record!class for your targets, they may even be named 
differently in the different record!classes), but they must exist in 
precisely this order.  For the purposes of explaining the operation
of the procedures, I'll call them NAME, BACKP, and LINK, respectively.
After those three, MAKFSM doesn't care what the rest of your record
looks like.  WARNING: do not explicitly delete any records that you
told MAKFSM about without first deleting the state machine that you
had it construct (an exception is "null" string records as explained
below).

declarations:

EXTERNAL RECORD!CLASS Fsm ( INTEGER State0, State );
	This is not in fact the entire fsm record, but does include the
two fields that you need to use.  "State" is the current state of the 
machine stored in the record, and "State0" is the state which represents
no knowledge about the character stream.  When an automaton is first 
constructed, the "State" field is set to the contents of the "State0" 
field, and whenever you wish to start (not continue) a search, you 
should reset "State" to the "State0" value.  If you don't, you may be 
embarassed to find that a substring has been detected which is in 
neither of the searched character streams, but would exist had they been
concatenated (like finding "grandad" by searching two different strings 
"it's grand" and "daddy").  The "State" field really does contain the 
only machine state information, and you may save its contents in some 
integer, use the machine for some other search, restore the state field,
and proceed with the search as if it had not been interrupted.

$text MAKFSM;Construct a Finite State Machine.
(Fsm)_ MAKFSM( ARRAY Equivs, @(ANY!CLASS) Find );
EXTERNAL RECORD!POINTER (Fsm) PROCEDURE MakFsm( INTEGER ARRAY Equivs;
			REFERENCE RECORD!POINTER (ANY!CLASS) Find );
	This builds the state machine form a set of targets.  "Equivs" 
is an integer array with bounds that must include [-1:127], and which 
contains some permutation of those numbers.  This contains information 
about which characters are to be treated as equivalent, and which are to
 be ignored.  For any character which is to be considered unique, the 
entry in Equivs at its ASCII code should be that number.  For any set of
characters which are to be considered equivalent, the entry 
corresponding to first of them should contain the ASCII for the second; 
for the second, the third; ... and the last of the group should contain 
the ASCII for the first (thus forming a loop).  The reason -1 is there, 
is to provide a way to indicate ignore characters.  Simply treat -1 as 
if it were ASCII, and make any characters to be ignored equivalent to 
it.  Note that a table which contains -1 at entry -1 will ignore no 
characters; one that has -1,0 for elements -1 and 0 respectively will 
ignore only nulls, and so on.  Suggestion: use the "swap" operator on a 
table that has i at Equivs[i], and you will never create an invalid 
table.

	"Find" is a linked list of the target substrings (as typical 
matches) linked on the "LINK" field, with a typical example of the 
string in the "NAME" field.  The string in the "NAME" field may contain
omit characters, MAKFSM will notice that and produce a table that will 
find that string (and anything like it which doesn't contain the omit 
characters).  It is pointers to these records that the search routines 
return, so you may well want to keep other information in them.

	If some error in the arguments is detected (eg Equivs is not 
valid) NUCORD is returned, and the state of "Find" is not 
necessarily defined.  All of the target records are examined, and a 
linked list on field "BACKP" is created of those records which have no 
string specified after ignoring the "ignore characters".  That linked
list replaces "Find", and if there are no other records, MAKFSM will 
also return NULL!RECORD.  A state machine will then be built to 
recognize the remaining strings, and the other "BACKP" links are formed.
For any two of the remaining target records R and S, if R is a "proper 
tail" of S then there is a "BACKP" link from R that will eventually 
reach S.  If R and S represent the same string (after considering the 
effect of applying Equivs), then one (and only one) of them will have a 
"BACKP" link that reaches the other.  If R has no "proper tail", and 
either it is not "equivalent" to another target (in the sense of the 
previous sentence), or has been chosen as the inferior of all targets 
which are "equivalent" to it, then its "BACKP" field will be 
NULL!RECORD.  All of this means to say that, for any record!pointer R: 
its "BACKP" field terminates, and anything along the linkage has been 
recognized if R has been recognized.  In fact, the "length" (not 
counting ignores) of the string represented by anything on R's "BACKP" 
chain will be less than or equal to R's "length".  MAKFSM then cleans up
some of its mess, and returns a RECORD!POINTER to a state machine which 
will "recognize" all of the targets not already placed back into "Find" 
(which should always be recognized).
	If you have been confused by this explanation, very simply:
If MAKFSM finds some trouble, or nothing to do, it returns NULL!RECORD.
Otherwise, it makes a list of ignores for you in "Find", and constructs
a ready-to-run machine which it returns to you.

$text USEFSM;Perform search on buffer.
(ANY!CLASS)_ USEFSM( (Fsm) State, @Count, @Bytepointer );
EXTERNAL RECORD!POINTER (ANY!CLASS) PROCEDURE UseFsm(
			RECORD!POINTER (Fsm) State;
			REFERENCE INTEGER Count, Bytepointer );
	This is the actual searcher.  Given a machine that MAKFSM made 
(which hasn't been mangled by some other program), and a stream of data 
specified by count and bytepointer, this advances along the data with 
ILDB's until either the end of buffer is encountered (count is 
decremented just before each data character is passed over, and end-of-
buffer is when count goes negative) or some "target" just had its last 
character seen.  If the end-of-buffer was reached, NULL!RECORD is 
returned.  If it was a recognition, a RECORD!POINTER to one of the 
records that MAKFSM got is returned.  If a RECORD!POINTER is returned, 
then you should consider "found" the specified target and all targets on
 the "BACKP" linked list (that is, the list as of when MAKFSM returned 
this particular machine --I didn't change it, you must have).  In either
case, "Count" will be zero or negative if there are no characters left 
in the buffer, "Bytepointer" will be ready to "ILDB" the next byte (if 
any), and the machine will be ready to proceed. (to wit: you can 
immediately re-issue the same call, and everything will be set to go.)

Note: "Bytepointer" is not checked, and everything expects to get
numbers in the interval [0,127] when an ILDB is done.  If you give it
a bytepointer 8 bits wide or larger, you are just asking for trouble.

$text USEFST;Perform search on string.
(ANY!CLASS)_ USEFST( (Fsm) State, @"Strdata" );
EXTERNAL RECORD!POINTER (ANY!CLASS) PROCEDURE UseFst(
			RECORD!POINTER (Fsm) State;
			REFERENCE STRING Strdata );
	This is like UseFsm, only it uses a string for the stream of
data instead of a count and bytepointer.  The passed protion of the
string is simply gone (unlike SCAN), so if you want to look at what
was passed, save "Strdata" before the call to MakFst.  

$text MAPPING;Mapping to files in SAIL -Overview.
	The paging procedures provided here will manage a "mapping area"
for the SAIL programmer, providing SAIL procedures to map in, unmap, 
create and delete file pages, as well as a few other page-oriented 
operations.  The mapped pages are referenced through an array subfield 
of a record, which is pointed at the proper location in memory when the 
mapping operations are performed.  The user is not given the virtual 
page number for the file page, instead he will refer to the page by 
specifying the record that contains a pointer to the page.  In this way,
several pointers may use the same core locations, and a pointer may be 
re-directed whenever the package deems it desirable.

CAVEATS:
	(1) "emptor"
	(2) [to be fixed] the SAIL functions ARRTRAN and ARRCLR
		won't work on these arrays (but ARRBLT seems ok).

$text PageHolders;Descriptions of PageHolders, MAP1CR, MAP2CR.
	There are two classes of "page holder" records: one for singly-
dimensioned integer arrays (map1), and another for doubly-dimensional 
integer arrays (map2).  In addition to the array subfield, both classes 
have an integer subfield (ui) and a record!pointer (up) subfield which 
are reserved for the user's purposes.  These records also have subfields
used by the paging routines; their contents will be left unspecified 
(they may even change between various versions of the package).  Here 
are the declarations for the two classes:

    EXTERNAL RECORD!CLASS map1
	( INTEGER ARRAY a; INTEGER ui; RECORD!POINTER (ANY!CLASS) up );

    EXTERNAL RECORD!CLASS map2
	( INTEGER ARRAY a; INTEGER ui; RECORD!POINTER (ANY!CLASS) up );

	It is important that the paging package maintain internal 
accounting information about these records, so, rather than use 
NEW!RECORD, the following two procedures are provided to create new 
records of these two classes.

    EXTERNAL RECORD!POINTER (map1) PROCEDURE map1cr
	( INTEGER lower!bound, upper!bound, offset(0) );

EXTERNAL RECORD!POINTER (map2) PROCEDURE map2cr
	( INTEGER low!bnd1, upp!bnd1, low!bnd2, upp!bnd2, offset(0) );

	The array storage is not allocated by calling the creation
procedures above, nor are the records one-use only.  Basically, they
should be thought of as a way of specifying the format of the page being
examined.  The lower and upper bounds specify the ranges of the index 
values for the arrays, very much like a normal array declaration.  The 
offset argument is slightly harder to explain.  Imagine that the words 
in a page are numbered from 0 to 511.  The offset value will be the word
number (on the associated page) of the first array element.
	(map1:a[pnt][lower!bound] or map2:a[pnt][low!bnd1,low!bnd2])
	These procedures return NULL!RECORD if they detect any error in 
their arguments (total size of array + offset exceeds 512 words, offset
negative, upper and lower bounds incompatible...).


$text GETMAP;Code_ GETMAP( (map1,map2)holder, option, chan, fpage ).
	Now that you have obtained a holder for mapping, we come to the 
actual mapping functions.  Basically, they are all calls on a single 
function, with some options ignoring some of the arguments.  The 
declaration for the mapping function is:

    EXTERNAL INTEGER PROCEDURE getmap
	( RECORD!POINTER (map1,map2) holder;
	  INTEGER option, channel, pageinfile );

	In general, a negative return from getmap indicates some kind of
error while attempting to perform the operation.  If the error was 
detected by a UUO, the error number is stored in the variable !SKIP!, 
but !SKIP! is not always cleared if no error occurred.  (There doesn't 
seem to be a value that is not a possible error code.)

	"holder" is a record!pointer that points to a record obtained 
from either map1cr or map2cr, and the record is (almost always) 
manipulated or at least examined by getmap; disaster will strike if you 
aren't picky about what you put in here.  Option is a single-character
argument that indicates which of the many functions you want.  It is one
of the characters in "CDEFHKNOPRSUVWYZ" (see explanation below).  
Channel is the channel number with the file you wish to use in the 
mapping operation, and it is ignored if a channel is not used in the 
function.  Pageinfile is the FILE page number for the call, also ignored
if not needed (remember file page numbers start at 1, not 0).

$text OPTIONS;What GETMAP's various options do.
	The first letter of the "NAME" column is the character to use 
for the "option" argument. The "USES" column indicates which of the 
other arguments the procedure will pay attention to (Holder, Channel,
or Pageinfile).

NAME	 USES	DESCRIPTION
Cow	  HCP	map in file page Copy-On-Write,exclude
Delete	  -CP	removes page from file (mark all same C-P "exclude")
Existant  -CP	find first existant page in file on chan at or after
		page specified (errors: page<1, past eof, none found)
Fileop	  -CP	mark exclusive all pages using this channel-page
		(or channel if page=-1) returns # pages changed
Hole	  -CP	find first "hole" page in file on chan at or after
		page specified (errors: page<1, past eof, none found)
Kount	  H--	count other pointers looking at this "virtual page"
New	  HCP	create a new file page (use pageinfile=-1 for at EOF)
		and map in Write,include
Old	  HCP	same as New, but no failure if page already exists
Preref	  H--	"pre-reference" page pointed to by holder
Read	  HCP	map in file page Read,include
Status	  H--	read status of holder's page (0 if none)
Unmap	  H--	dissasociate holder with page pointed to (unmap it if
		this is the last association)
Validate  H--	start "validate" operation on holder's page
Write	  HCP	map in specified file page Write,include
Y (validate
 and wait)H--	same as "V", but waits until completion of validate
Zap	  H--	disassociate holder with its page, unmap if necessary,
		and then delete the record that holder points to.  You
		better not be pointing to it later; storage is released


$text RESULTS;What GETMAP returns.
	Whenever reasonable, "getmap" will try and point a record at an 
existing page (saves virtual address space).  There is a bit in its 
internal memory allocation table called the "exclusive" bit, which means
"don't let anyone else point at this."  When this bit is on, the same 
"channel-page-protection" specification in a map-in will not find the 
area talked about.  When a call to getmap requests a page (R,C,W,N,O), 
it may do so in either "include" or "exclude" mode.  Include mode means 
that getmap may use an existing page, and might not even perform a map 
operation.  The page that is obtained by an "include" mapping has its 
"exclude" bit cleared.  "Exclude" mode will always perform a map 
operation, and will turn on the "exclude" bit in the mapped page (thus 
obtaining a unique pointer to it.) Normally "Cow" is "exclude" and all 
others are "include", but by using a lower case letter, you complement 
the "include/exclude" part of the command.  In some cases you may want 
the exclude bit turned on for a page which is already mapped.  In this 
case, the "Fileop" function is used, with page=-1 if you want to mark 
everything from a particular channel (a good idea just before you close 
a channel, for example).

NAME		RETURNED VALUE (successful)
Cow		file page number
Delete		file page number
Existant	file page number
Fileop		number of pages that were changed
Hole		file page number
Kount		number of other records pointing at this "virtual page"
New		file page number
Old		file page number
Preref		0 if page access will fault, 1 if was in core
Read		file page number
Status		page status (bits for dirty,file,...)
Unmap		0
Validate	0
Write		file page number
Y (validate	0
 and wait)	
Zap		0

except for Status, a negative return indicates some kind of error.
	-1 means "some procedure noticed an argument error"
	-2 means "system call error, error code in !SKIP!"
	-3 means "couldn't get page for this mapping operation"
		[this only happens on actual maps (C,N,O,R or W)
		 which return the file page number on success]
$text ALLOW;added_ ALLOW( low, high ) -- mapping area.
mapping area:
	EXTERNAL INTEGER PROCEDURE allow( INTEGER low, high );
This tells the mapping system that pages low through high are available 
for its use.  These pages are not (yet) protected from SAIL's core 
allocation, and a collision between the two will cause SAIL to throw up 
its hands, but "allow" does do a little checking and will not use a page
in the specified range if it already exists.  Allow returns the number 
of pages that it added to the mapping area.  The mapping system is
initialized with pages 500 through 511 (decimal) at user initialization 
phase 0, so you should use phase 1 or 2 to add any more pages to the 
mapping area (NOTE: if you overlap the pre-declared area, nothing bad 
will happen; in fact, it is a good idea to do so since the initial 
values are not guaranteed to remain the same in later versions.)  There 
is no provision for removing pages from the mapping area, so be careful 
not to grab more space than you want to remain allocated for mapping.

$text OPFILE;ChannelNumber_ OPFILE( "FileName", "Options", ChannelToTry ).
ChannelNumber_ OPFILE( "FileName", "Options", ChannelToTry );
	Opfile is a procedure to open files for mapping operations.
Channels opened with this routine will not have the normal SAIL I/O 
acounting performed, so use of the standard routines (RELEASE, RENAME, 
CLOSE, INPUT, CHFDB, ...) is not available.  Opfile does, however, allow
use of all 32 channels on TYMSHARE's PDP-10's.  If the call is 
successful, it returns the channel number (0-31), otherwise it returns a
negative number of the form: -phase,,syserr.

Opfile obtains specified file (name same as in require file-name 
constructs) gets file on channel in specified mode. It always does OPEN,
does LOOKUP, ENTER as necessary.

	Currently, only "Mapped" opening is implemented.  Channel should
be between 0 and 31 inclusive (-1 will supply the system-provided lowest
unopen channel).  The channel is only available for mapping operations,
and is not a part of the normal SAIL channel handling, so use
"chaniov(chan,0,0)" instead of "release(chan)".  

valid options:	B,H,M,N,O,P,R,S,V, and W (described below).

	Read (use if you intend to read from the file),
	Write (use if you intend to write on it),

	New file (error if file exists),
	Supercede file (error if file doesn't exist),
	Old file (error if file doesn't exist),
	Version (new file if none exists, otherwise supercede),
	Base mode (old if exists, else create and use),

	H (thawed, multi-user enter used. Allows 2 writers at once),

	###P protection (owner,group,everyone) 047=ALL RD NO
		Note: this is only sure to work on creation.,

	Mapping access (must use for now)
;


$text RCHPTR;characterPosition_ RCHPTR( chan ).
characterPosition_ RCHPTR( chan );
	Returns the character position of the next character that an 
INPUT will examine (the character position of the first character of a 
file is 0).  This allows you to save a file position for later 
restoration with SCHPTR. 
	Chan is a text file channel number.  It must be open in mode 0 
or mode 1 (ie buffered ASCII text, 7-bit bytes).  Chan should only be in
use for input; buffered output will confuse it in the most exciting 
ways.  The channel should not be at the end-of-file either (results are 
not fully determined in this case, you may get -1 which indicates "at 
end of file", or you may get the character position of the mythical EOF 
character within the file).

$text SCHPTR;SCHPTR( chan, characterPosition ).
SCHPTR( chan, characterPosition );
	Sets the input side of the specified channel so that the next
character to be examined by INPUT will be the character at
characterPosition or to the end of the file if -1 is given as the
position (the position of the first character in a file is 0).  This
is basically a "restore file position" if called with the results of 
a previous RCHPTR.
	Chan is a text file channel number.  It must be open in mode 0
or mode 1 (ie buffered ASCII text, 7-bit bytes).  As in RCHPTR, Chan
should only be in use for input; buffered output may confuse it in the 
most exciting ways.  SCHPTR with positions not inside the file may lead 
to error messages or wierd behavior.  Channel-related variables BRK,EOF,
PAGE,LINE, and SOSNUM (see OPEN and SETPL) may be altered (note: the 
COUNT variable is preserved).

$text ASZSTR;"normalString"_ ASZSTR( byteSpecForAscizString ).
"normalString"_ ASZSTR( byteSpecForAscizString );
	Returns a string copy of the "ASCIZ" string pointed to by its 
argument (after the argument has been fixed up by "BYPOK").  That is, 
a string starting with the first character obtained by an "ILDB" 
instruction using the byte pointer, and continuing until (but not 
including) the first null character (ASCII 0) encountered.  (This 
format for strings is used by many JSYS'es).

$text BYPOK;sevenBitBytepointer_ BYPOK( byteSpec ).
sevenBitBytepointer_ BYPOK( byteSpec );
	Returns a 7-bit byte pointer suitable for the ILDB and IDPB
machine instructions (as POINT does) to the byte specified in the
call which must be a 'normal' 7-bit byte -- one of the following:
	point(7,word,-1), point(7,word, 6), point(7,word,13),
	point(7,word,20), point(7,word,27), point(7,word,34) .
   Besides normal byte pointers this procedure will also accept both 
location(word) and ( (-1 lsh 18) + location(word) ) as equivalent
to point(7,word,-1).  BYPOK will return 0 if byte.spec cannot be
coerced into the proper form (byte size wrong, specified byte is
not on normal byte boundaries, etc).  This is used by procedures 
such as CONSTR and ASZSTR to check and fix up their arguments, and 
is provided as a convenience for use by other programs.

$text CMPSTR;signedPositionOfDifference_ CMPSTR( "first", "second" ).
signedPositionOfDifference_ CMPSTR( "first", "second" );
	String comparison function.  If "first" is "less" than "second" 
then the result is negative, if "greater" then the result is positive,
and if they are "equal" then the result is zero.  If the two strings 
are different, the absolute value of the result is the character
position where they first differ.  CMPSTR( "abcdfe", "abcdef" ) is 5 
("f" > "e").  The "natural" use of this function is to compare it with 0
using the relational test desired (eg: for "is t1 `less' than t2", say:
"cmpstr(t1,t2) < 0").  The ordering function is the ASCII character 
order, with the end of a string supplying -1's for the comparison (in 
other words, essentially alphabetic, but without case mapping). 
WARNING: with "ADD", "bad", and "CAT":
    CMPSTR("ADD","CAT") < 0	and	CMPSTR("CAT","bad") < 0

Like:	for ch_ 1 step 1 while length(first)>0 and length(second)>0
	   do begin
		char1_ lop(first)
		char2_ lop(second)
		if char1 < char2 then return( -ch )
		if char1 > char2 then return( ch )
	      end
	if length(first)>0 then return( ch )
	if length(second)>0 then return( -ch )
	return(0)

$text CONSTR;"dangerousString"_ CONSTR( byteSpec, desiredSize ).
"dangerousString"_ CONSTR( byteSpec, desiredSize );
	Returns a string with length 'desired.size' whose first 
character is the character ILDB(BYPOK(bytepointer)).  The resulting 
string is not subject to garbage collection (since SAIL thinks of it as 
a constant string).  The string returned actually points to the same 
location that 'byte.spec' points to, and this is actually a very fast 
procedure.  However, because the resultant string does not have its 
characters actually stored in 'string space', it will change value (not 
length) whenever the bytes pointed to change.  Hence, the string, (and 
all substrings taken from it) is extremely unstable -- be very careful 
when using this procedure.  Causes a continueable USERERR if the 
bytepointer or count are invalid.


$text DYNSTR;"normalString"_ DYNSTR( byteSpec, desiredSize ).
"normalString"_ DYNSTR( byteSpec, desiredSize );
	This is very much like CONSTR, except it returns a normal SAIL 
string which is a copy of the characters specified by 'byte.spec', and 
hence does not change along with the data pointed to.  If the warnings 
in CONSTR have scared you, this is probably what you want (although it 
is somewhat slower).  This also can cause a continueable USERERR if the 
bytepointer or count are invalid.

$text STRACH;STRACH( stringConcatChan, characterToAppend ).
STRACH( stringConcatChan, characterToAppend );
	This appends 'character.to.append' to the specified 'string 
   concatenation channel' (see the general explanation of string
   concatenation channels for more details).

$text STRADD;STRADD( stringConcatChan, "stringToAppend").
STRADD( stringConcatChan, "stringToAppend");
	This Appends to!add to the specified 'string concatenation
   channel', in approximately the same way that STRACH adds a single
   character. (see the general explanation of string concatenation
   channels for more details).

$text STRCLS;"accumulatedString"_ STRCLS( @stringConcatChanToClose ).
"accumulatedString"_ STRCLS( @stringConcatChanToClose );
	If the 'string concatenation channel' specified is open, then 
close it, deallocate all storage associated with it (in particular: the 
buffer), set the reference argument to 0, and return the string that has
been built.  If there is no open 'string concatenation channel' with 
the specified value, then set the reference argument to -1, and return 
null (this procedure will not complain if the argument is invalid). (see
the general explanation of string concatenation channels for more 
details).

$text STRLEN;AccumulatedLength_ STRLEN( stringConcatChan ).
AccumulatedLength_ STRLEN( stringConcatChan );
	This returns the number of characters placed in the 'string 
   concatenation channel' so far. (will not do any concatenation).
   (see the general explanation of string concatenation channels for
   more details).


$text STROPN;stringConcatChan_ STROPN( bufferSizeInBytes ).
stringConcatChan_ STROPN( bufferSizeInBytes );
	Set up and return a new 'string concatenation channel',
   with a concatenation buffer at least buffersize bytes long.
   (see the general explanation of string concatenation channels
   for more details).


$text STRPEK;"accumulatedSoFar"_ STRPEK( stringConcatChan ).
"accumulatedSoFar"_ STRPEK( stringConcatChan );
	Peek at the contents of a 'string concatenation channel'
   NOTE: Don't do this too often, as that defeats the entire
   bufferring scheme that the 'string concatenation channel'
   code is meant to use.  (See the general explanation of string
   concatenation channels for more details).


$text STRSTF;updPtr_ STRSTF( ptr, "text", NotAsciz(false) ).
updatedBytptr_ STRSTF( byteSpec, "to-deposit", NoClosingNull(false) );
	Deposits str into byptr via idpb.  If nonull is false, (which 
means that a trailing null is desired), then a null character (ASCII 0) 
is deposited past the last character in the string.  Returns a 
bytepointer to the last character deposited from the string (not the 
trailing null), or 0 if byptr is invalid.  This is useful for setting up
JSYS calls that want either ASCIZ strings, or bytepointer and updated 
bytepointer values.  The return value is precisely the byte pointer that
you want to use if you want to deposit another string after the first 
one.  That is: strstf( strstf( byp, str1 ), str2 ) is the same as
strstf( byp, str1 & str2 ), except the concatenation is not actually 
performed.

$text SUBEQU;targetPosition_ SUBEQU( "target", "source" ).
targetPosition_ SUBEQU( "target", "source" );
	Find the first occurence of "target" in "source".  If none
exists (or if the target is the null string), return 0.  Otherwise
return the character position of the first occurence of a match.
[eg:  subequ("ver","I am very tired") = 6].


$text UPDSTR;"normalString"_ UPDSTR( byteSpec, updatedByteSpec ).
"normalString"_ UPDSTR( byteSpec, updatedByteSpec );
	Returns a string copy of the string that lies between byteSpec
and updatedByteSpec.  That is, a string starting at the first character 
loaded by byptr, and continuing until the character pointed to by 
updatedByteSpec.  (A standard TENEX string format used often for JSYS 
string returns).  Causes a continueable USERERR if the bytepointers are 
invalid.
$text CATCHAN;general explanation of string concatenation channels.
general explanation of string concatenation channels:
	A string concatenation channel is not actually a channel in the 
normal SAIL sense at all, the name was chosen because the operations on 
them are very much like input/output operations. In many programs there 
are strings which go through a long series of append operations before 
they are ever examined.  This use of strings can cause a tremendous 
amount of overhead (especially as the strings that are being used to 
accumulate the characters get long) since most often the collecting 
string needs to be copied before the concatenation can take place.  This
increases the number of calls to the string garbage collector in 
addition to the amount of time that must be spent copying strings.  The 
string concaten- ation channel is intended to alleviate this problem by 
buffering concatenation requests, doing a few large concatenations 
rather than a large number of small ones.  The buffer size that you
specify in the STROPN command should be large with respect to the 
average length of the strings that you are going to append to it.
An example may help:
	instead of:
		t_s_null;
		for i _ 1 step 1 until 99
		   do begin  s_ s & i;  t_ t & "," & cvs(i);  end;
		comment uses 18945 bytes of string space;
	use:
		sc_stropen(50); tc_stropen(100);
		for i _ 1 step 1 until 99
		   do begin  strach(sc,i);  
			     strach(tc,",");  stradd(tc,cvs(i));  end;
		s_strcls(sc); t_strcls(tc);
		comment uses 937 bytes of string space;

	Both produce 387 bytes of string in s and t at the end.  This
difference is more dramatic than the time (or storage) actually saved 
(since there is some storage overhead for each 'channel'), but this 
example should demonstate why the use of this feature will help out 
string munching programs, and perhaps prevent some programs from 
spending the majority of their CPU time in SAIL's string garbage 
collector.  What the STRADD and STRACH routines do is place their 
arguments in the appropriate buffer as long as there is room, and 
concatenate an entire buffer plus any spillover when the buffer fills 
up.  Clearly you would save even more string area if you allocate a 
buffer that is larger than the length of the string that STRCLS will 
return, but this may be an unecessarily large space for a buffer, and 
you might wind up using up your storage for the buffers themselves.   A 
word of warning: STRPEK must first flush the buffer, so if you intend to
use it very often (say every few calls to STRADD or STRCH), you will 
probably be better off just going ahead and using the concatenation in 
the first place.  Also, if your chosen buffer size is smaller than the 
length of most of the things you wish to 'append' then all will do is 
add procedure call overhead to the concatenations that will actually be 
performed.  A 'string concatenation channel' will always be a short 
(less than 18 bits) positive integer, and there is no a priori 
restriction on the number of 'channel's you can have open at one time.

$text READBR;bitFlag_ READBR( table, @"breaks", @"omits", @"modes" ).
bitFlag_ READBR( table, @"breaks", @"omits", @"modes" );
	Reads the contents of a break table, and returns enough 
information to rebuild it.  Given a valid break table number, this 
returns a 3-bit flag:
	bit 33 (4) => break table copies string,
	bit 34 (2) => break table has been reserved
			(getbreak can't return this table)
	bit 35 (1) => break table has been initialized
			(break, omit, and mode are valid)
			(this should not be on if bit 34 isn't)
If the break table has been initialized (bit 35), then the three 
reference strings are set so that
		relbreak( table )
		setbreak( table, break, omit, mode )
will set table to exactly the same break table as it currently contains.
If the first character of mode (at the time of the procedure call) is 
either "x" or "X", then the mode will begin with "X" (breaks by 
eXclusion) when the procedure returns, otherwise the mode will begin 
with "I" (breaks by Inclusion).  Default modes are shown explicitly 
("IPSF", not "I"), and the mode letters are always in the same order:
	{I or X}, {P,N,L,or E}, {S,A,or R}, {F or K}, {Z (if applies)}
So, if this returns 3 or 7, then modes will be either 4 or 5 characters 
long.
$text RVSCAN;"result"_ RVSCAN( @"source", break!table, @brchar ).
"result"_ RVSCAN( @"source", break!table, @brchar );
	Behaves like the standard SAIL runtime 'SCAN', but backwards.
The break character disposition is analogous to SCAN, and this will 
attempt to use 'proper' substrings whenever possible (rather than 
copying the string body).  (Useful for removing blanks from the end of 
a line for example).  More precisely, it behaves very much like the 
following code (Although more efficient by far).

    string procedure rvscan( reference string s; integer table;
				reference integer brchar );
	begin
		string procedure reverse( string s );
		begin string r; r_null;
		while length(s) do r_ lop(s) & r;
		return(r);
		end;
	   string result;
	s_reverse(s);
	result_ scan(s,break!table,brchar);
	s_reverse(s);
	return( result );
	end;
 1J3@