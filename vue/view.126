Title	View	Macro support subroutines for VUE
Subttl	VUEMAC	By Carl A Baltrunas - Tymshare Inc -

	Search	Jobdat

;Register Definitions -- See BLISS Manual

	s=0		; Sreg - PDL & Stack
	t=1		; SuperTemp - Don't expect anything
	f=2		; Freg - Formal parameter stack
	v=3		; Vreg - Value register
	a=4		; Temp
	b=5		; Temp
	c=6		; Temp
	d=7		; Temp
	e=10		; Temp

	Twoseg		; Generate Shareable code

	Reloc	400000	; Starting at normal address.

Subttl	VUEMAC	Version and relocation information

	loc	.jbver		; VUExxx defined in VUE.INF
	Byte (3) vuewho (9) vuever (6) vuemin (18) vueedt
	reloc

	Ftcommand=1		; Expect RESCAN capability

IFNDEF Ftdebug,<Ftdebug==-1>	; Allow (VUE) & (YEUX) as well as (SYS)

Subttl	Entry Points - Internal / External

	entry fef,fen,clulin,clupos,autblk,flush,silent,quiet
	entry scrsze,screen,curline,dskbuf,filblk,ppn,cucl,defdsk,base
	entry comchar,newcount,repcount,linesz
	entry readch,readcc,nowait,mcrdef,mcrptr
	entry p,lowend,lowptr,hbot,hptr,hend
	entry ttytyp,sst,mark,maxss,muncho,munchi,ocline,scrmod,muline
	entry altptr,ttyidle,reset,dskbfh,modpos
	entry putch,putstr,putoct,putnum,putrdx,putbcd,putpad,flubfr
	entry wrtoct,wrtnum,writestring,writeloss,updatecursor
	entry csnum,qreg,dorescan,setlab,submod,vuetyp
	entry physpos,physlin,tabsize,distbl,bfblk1,bfblk2,scroff,scrlen
	entry relcor,coresize,corecheck,rsrchr,rsrptr,rsrstk
	entry dmpbfr,dmpbsz,dmpin,dmpout
	entry ttype,tspeed,gettty,getwid,getlen,getaun,getppn,mail,getjob
	entry moveforward,moveback,quit,modblk
	entry eolbreak,eolchxr,eoltype,fmtbreak,fmtchxr
	entry whtbreak,whtchxr,whitespace,wbreak
	entry pbreak,blankline,findbreak,apbreak,blankprev
	entry getchx,ftp,therep

external metap,ctrlxr,ctrlxv,uctrlo,read,metaprefix,xprefix
external escvalue,delvalue,sosmod,leftmargin,goxy,toprompt
external rptr,cstk,caseok

Subttl	VUEMAC	TYMCOM-X / TOPS-10 Definitions 

Opdef	Auxcal	[042000,,0]	; Terminal / Aux Circuit calls
Opdef	Setmod	[Calli -26]	; Used to set status/mode of line
Opdef	Putlsa	[Calli -63]	; Writes a Stream Accounting Record
Opdef	Pjrst	[Jrst]		; Comment is Jrst to POPJ routine

.Axi8c==0	; Input character image and wait
.Axi8s==1	; Input character image and skip
.Axo8i==4	; Output character image immediate
.Axptr==5	; Output string using byte pointer
.Axsic==10	; skip if character
.Axobr==16	; Read Output baud rate code
.Axwid==27	; Terminal Width
.Axics==45	; input character and skip
.Axost==52	; Outstr to Aux port
.Axrvx==55	; reverse ^S/^Q enable
.Axcfs==64	; Setmod for Aux port
.Axttp==100	; Read terminal type

io.nee==1b27	; no-escape-echo bit
io.nec==1b28	; no-echo bit
io.fcs==1b29	; full-character-set bit

.ioimg==10	; image mode io
.iobin==14	; binary

.Gtfpn==-25	; Frame PPN
.Gtaun==-23	; Acct User Number (ppn)
.Gtlic==-20	; User license
.Gtppn==2	; Gfd'd PPN
.Gtnam==3	; Name!
.Gtprv==6	; Privilage word

Subttl	VUEMAC	Main subroutines - Shareable @ 400000
Subttl	VUEMAC	Reset

;Reset	- Reset i/o and do one-time only checks with PUTLSA & JP.TYM
;
;	Pushj	s,Reset		RESET()
;	 <Only Return>
;
Reset:	Calli	0		; Reset the world!
	Pushj	s,Getprv	; Get user privs.
	Movem	v,Usrprv	; Store them.
	Pushj	s,Getlic	; Get user license.
	Movem	v,Usrlic	; Store them.
	Pushj	s,Getnam	; Get program name.
	Movem	v,Usrnam	; Store it.
	Pushj	s,GetFPN	; Get Frame PPN (where program run from).
	Movem	v,UsrFPN	; Store it.
	Pushj	s,Getppn	; Get the GFD'd PPN
	Movem	v,UsrPPN	; Store it.
	Pushj	s,Getaun	; Get the Logged in PPN too.
	Movem	v,Usraun	; Store it.
	Skipe	UsrFPN		; See if FPN is good.
	  Jrst	BadFPN		; Yes, continue.
	Movem	16,Usrnam	; This guy is either an EXE file or...
	Movem	17,UsrFPN	;  he's been meddling.  Scrunch!!!

BadFPN:	Tdza	b,b		; Start fresh.
	 Tro	b,-44		; Make sure this is done right. (NEVER!)
	Movsi	a,'UTD'		; For file hackers!!! this is VUE - 10101
	Tlo	b,10101		; Here is the 10101 to add
	Addb	a,b		; ...
ifn Ftdebug,<
	Skipe	.Jbddt		; If DDT is loaded
	  Move	a,[sixbit 'dvue'];  then allow a different name!
    > ; End ifn Ftdebug
	Came	a,Usrnam	; Do they still match?
	  Jrst	Tattle		; No-- Tell someone!
	Movsi	b,1		; Build these too!
	Rot	b,24		; Put the 4 into position
	Tlo	b,1		; Set bits for 1,,4
	CAMN	b,UsrFPN	; is it a legal copy?
	  Jrst	Rested		; Seems ok -- DO next step
	Trc	b,4		; Clear the 4
	Tro	b,315372	; Set in UUN for (FTSYS)
	Camn	B,UsrFPN	; Compare
	  Jrst	Rested		; Seems ok -- DO next step
Ifn Ftdebug,<
	Move	a,Usrfpn	; Need to get this for later
	Movsi	b,6777		; get first part 3,3774...shifted some
	Addi	b,022000	; now add next part
	Rot	a,12		; shift test part
	CAME	a,b		; DEBUG COPY?
	CAMN	a,[6777,,024000]; NEW VERSION?
	  Jrst	Rested		; Seems ok -- DO next step
	Rot	a,-12		; No, So move everything back!
	> ; End Ifn Ftdebug

	Tdza	c,c		; Start fresh.
	 Tro	b,-44		; Make sure this is done right. (NEVER!)
	Movsi	b,'UTD'		; For file hackers!!! this is VUE - 10101
	Tlo	c,10101		; Here's the 10101 to add (left half)
	Addb	c,b
Tattle:	PUTLSA	b,		; make a stream record
	 JFCL
	Setz	c,		; Need some scratch
	Move	v,Usrlic	; First check license
	Trne	v,(2b17)	; Does he have WF?
	  Jrst	Delf		; Yes-- No need to check further
	Move	v,UsrFPN	; Get the frame ppn
	Camn	v,UsrPPN	; Does it match? (GFD'd PPN)
	  Tro	c,100		;  Yes!! Only needs Owner access
	Trz	v,-1		; Clear PN
	Hllz	b,Usrppn	; Get Project part
	Camn	v,b		; ... Do they match?
	  Tro	c,10		;  Yes!! Only needs Project access
	Move	v,Usrlic	; See if he has WP set?
	Trne	v,(1b17)	; Either that or WA... both ok.
	  Trz	c,10		;   Seems to - Clear project bit
Delf:	move	v,c		; Now, copy our flag.



	OPEN	[ 17
		  sixbit "DSK"
		  xwd 0,0]
	  Jrst	Rested		; Can't cope -- DO next step
	Skipn	Usrnam		; Get program name.
	  Jrst	cantell		; Can't cope -- Release Disk.
	MOVE	d,[point 18,[sixbit /LOWSHR/
			     sixbit /HGHSAV/
			     sixbit /SWREXE/
			     sixbit /XPN   /]]
Vuecpy:	Move	e+3,UsrFPN	; Reset the FPN (remembered from above)
	Move	e,Usrnam	; Save the name in the AC's LOOKUP block
	Ildb	c,d		; Get one of LOW SHR HGH SAV SWR 0
	 Jumpe	c,cantell	; All done?
	Movsm	c,e+1		; Not yet... store extension to try.
	Setzm	e+2		; Finish setup...
	LOOKUP	e		; Look it up in his directory [FPN]
	  Jrst	Vuecpy		;  Ignore errors - Just go to the next one.
	Jumpe	v,Okdelf	; Ok to delete if WF or WP... set, so go!
	ldb	c,[point 3,e+2,2]; get user protection
	Trne	v,100		; If same user, then...
	 jumpe	c,Okdelf	;  Let him delete it if possible
	Trne	v,100		;  Else ... he must rename it first.
	 jrst	Okrenf		;  ...
	ldb	c,[point 3,e+2,5]; get project protection
	Trne	v,10		; If same project, then...
	 jumpe	c,Okdelf	;  Let him delete it if possible
	Trne	v,10		;  Else ... he must rename it first.
	cail	c,2		;  ... IF that is possible!
	 caia			;  no - no - no!
	  jrst	Okrenf		;  ...  Ok!
	ldb	c,[point 3,e+2,8]; get anyone protection
	 jumpe	c,Okdelf	;  Let him delete it if possible
	cail	c,2		;  Else ... he must rename it first.
	  jrst	Vuecpy		;  ...  Can't!!! so try next file!
Okrenf:	movei	c,00017		;  Protection 0, mode 17
	Dpb	c,[point 13,e+2,12]; store it for the rename.
	Rename	e		; Change the protection
	  jrst	Vuecpy		; If error -- give up & try next one
	setzm	e+2		; Clear this field
	move	e+3,UsrFPN	; Restore the directory name
	hllzs	e+1		; Clear creation date and stuff
	Lookup	e		; Do a lookup again
	  jrst	Vuecpy		; Not there? -- Give up!
Okdelf:	SETZM	e		; Clear name
	RENAME	e		; Delete it
	 Jfcl			;  Ignore errors
	Jrst	Vuecpy		; Loop till all stolen files gone

Cantell: RELEAS			; Release the channel (DSK)
Rested:	movei	a,1b21		; JP.TYM
	tdne	a,Usrprv	; Does the user have license?
	  jrst	Noecho		;   Yes -- Turn off echo & GO!
	lsh	a,-7		; Shift word over and decipher the mode!
	andi	a,3		; Got it, now we have them run something else
	move	a,[sixbit /EDIT10/	; PDP-10 .JPMPD
		   sixbit /EDITOR/	; XEXEC  .JPMXE
		   sixbit /EDITOR/	; XEXECJ .JPMXJ
		   sixbit /EDITOR/](a)	; SUDS   .JPMSU
				; Fall into code to RUN (SYS) ((a))

Subttl	VUEMAC	Runccl	Cucl	RunRPG	Runcca

;Runccl	- Perform a "RUN" at start address + 1 for SYS:(a)
;
;	Move	a,[sixbit /program/]
;	Jrst	Runcca
;	  <never returns>
;
Runccl:	Move	b,[Xwd RPGBLK,e]; Remember this is from SYS:
	Blt	b,e+5		; Copy defaults from RPG
	Movem	a,e+1		; Now store the name
	Jrst	Runcca		; And run it at the CCL point

;Cucl	- Run CCL program at starting addr + 1
;RunRPG	- Run (SYS)RPG at atarting address + 1 to do the last RPG thing
;
;	Jrst	RunRPG		Cucl()  or  Runrpg()
;	  <never returns>
;
cucl:	Pushj	s,Fen		; Turn off the terminal
RunRPG:	Move	b,[Xwd RPGBLK,e]; We are running RPG right?
	Blt	b,e+5		; Copy defaults from RPGBLK
Runcca:	movsi	a,1		; Start offset = 1
	hrri	a,e		; Setup address of block
	run	a,		; Bye!
	  halt	.

RPGBLK:	sixbit/SYS/
	sixbit/RPG/
	0
	0
	1,,4
	0

Subttl	VUEMAC	Relcor	Coresize

;Relcor	- calculate for 500 extra characters above hend and release
;	  any memory assigned above that - *** watch Mapped pages ***
;
;	Push	s,[N]			Relcor(N)
;	Pushj	s,Relcor
;	  <only return>				or ERROR!EXIT
;
relcor:	move	v,hend			; Get Top of high buffer
	idivi	v,5			; Convert to an address
	addi	v,100			; Add room for 500 more chars
	add	v,p			; highest address used by vue.
	movem	v,.Jbff			; Set jobff
	ori	v,777
	movem	v,.Jbrel		; Set this number too.
	calli	v,11			; Get the core
	  jrst	E$$NEC			; Give error message and exit
	move	v,.Jbff			; Else return .Jbff
	popj	s,

;Coresize - Increase core by N words (if necessary?)
;
;	Push	s,[N]			Coresize(N)
;	Pushj	s,Coresize
;	  <only return>				or ERROR!EXIT
;					v contains (.JBFF)
;
Coresize:
	move	a,s			; Get the argument
	move	a,-1(a)			; Get requested length
	move	v,.Jbff			; Save Next free for return
	addm	a,.Jbff			; Increment .JBFF and .JBREL
	addb	a,.Jbrel		;  by the requested size
	calli	a,11			; Ask for it
	  jrst	E$$NEC			;  Nope - Give error & exit
	popj	s,


Subttl	VUEMAC	Corecheck

;Corecheck - 	Check to see if there is room in the gap
;		if so then return, otherwise expand memory
;
;	Pushj	s,Corecheck		Corecheck()
;	  <only return>
;
Corecheck:
	move	v,HBOT			; Get high bottom
	sub	v,LOWEND		;  and compare to see
	cail	v,20			;  if we need to expand
	  popj	s,			; Enough for now?  Return
	push	s,[1000]		; Ask for another page
	pushj	s,Coresize		;  of buffer memory
	pop	s,v			; Adjust the character
	addm	v,HPTR			;  ptr to the high end
	movei	v,5000			; Adjust the pointers
	addm	v,HBOT			;  for the high end and
	addb	v,HEND			;  calculate the number of
	sub	v,HBOT			;  characters above the gap
	jumpe	v,Cpopj			; None?  then just return
	idivi	v,5			; Convert to words
	movei	t,1(v)			;  and add 1 for zero base
	move	v,HEND			; Setup end-pointer for
	idivi	v,5			;  reverse BLT of data
	add	v,P			; From "real" top of buffer
revblt:	move	a,-1000(v)		; Get a word
	movem	a,(v)			; Put a word
	soj	v,			; Point at "next" previous
	sojg	t,revblt		; Loop till done
	popj	s,			; Return

Subttl	VUEMAC	Fef	Fen	TtyIdle

;Fef	- Save Characteristics & Setup Terminal
;
;	Pushj	s,FEF		FEF()
;	  <only return>
;
fef:	seto	a,		; Get the tty characteristics
	getlch	a		; Of your own port
	movem	a,tymtty	; Remember them
	tlo	a,220		; Magic bits NFC!NCM
	setlch	a		; Now setup special ones
	hrroi	a,.Axrvx	; ^S/^Q
	setzm	inirvx		; turn it off and save it
	Auxcal	a,inirvx
	Setom	tspeed		; Get the terminal speed
	hrroi	a,.Axobr	; ... for output anyway.
	Auxcal	a,tspeed	;  .. save it for later
Noecho:	Hrroi	a,.Axcfs	; Now setup port status
	Auxcal	a,io.nee!io.nec!io.fcs!.iobin
	move	a,[Xwd 41,5]	; Send a yellow ball throught the net
	Hiber	a,		;   then setup to wait up to 5 seconds
	  jfcl			;   for it to return.  Ignore errors.
Cpopj:	Popj	s,		; Then Return

;Fen	- Restore terminal characteristics
;
;	Pushj	s,Fen		FEN()
;	  <only return>
;
fen:	pushj	s,flubfr	;make sure everything is gone
	move	a,[Xwd 41,5]	; Send a yellow ball throught the net
	Hiber	a,		;   then setup to wait up to 5 seconds
	  jfcl			;   for it to return.  Ignore errors.
	move	a,tymtty	; Remember these characteristics?
	setlch	a		; Now set them back
	hrroi	a,.Axrvx	; ^S/^Q
	push	s,inirvx	; Make sure this doesn't get clobberred
	Auxcal	a,inirvx	; restore it
	pop	s,inirvx	;  ...
	Popj	s,		; Then return

;Ttyidle - Return True(1) or False(0) depending upon pending input
;
;	Pushj	s,TtyIdle	... Ttyidle() ...
;	  <only return>				v == 0 or 1
;	
ttyidle:
	hrroi	v,.Axsic	; Equiv of Skpinc
	Auxcal	v,		;  to see if anything there
Ret1:
ifn v,<	 skipa	v,[1]>		;    1 == True
ife v,<	 tdza	v,v		; Simulate "skipa v,[1]"
	 caia
	 aosa	v>
Ret0:	 setz	v,		;    0 == False
	popj	s,

Subttl	VUEMAC	Readcc/Readch - reads a char and returns it in v

;Readch	- Read a character from the current input source into V
;
;	Pushj	s,Readch	char _ Readch()
;	  <only return>				v _ char
;
readcc:	setom	PreCmd		; Possibly a prefix-ed command
readch:	pushj	s,flubfr	; Everyone wants this, so do it!
readnx:	move	a,csnum		; The stack index (-1 for TTY)
	skipn	v,cstk(a) 	; Do we have a real pointer?
	  jrst	usetty		;  No -- Use TTY
	hlrz	v,v		; Copy left part
	cain	v,-1		; If -1,,-n (-n) then it's a file
	  jrst	usefil		; Yes -- From a file
	ildb	v,cstk(a) 	;  No -- Get a character
readcm:	skipn	PreCmd		; Is it a command character?
	  jrst	readdn		;  No -- Pass it on (For now!)
	came	v,MetaPrefix	; Is it a Meta?
	  jrst	readc2		; No -- continue
	skipe	PreMeta		; Previous Meta?
	  jrst	readpm		; Yes -- pass meta
	setom	PreMeta		; Set meta-flag
	jrst	readnx		; Go for another char
readc2:	came	v,XPrefix	; Is it eXtend-Prefix
	  jrst	readc4		; No -- continue
	skipe	PreeXt		; Previous eXtend
	  jrst	readpe		; Yes -- pass extend
	setom	PreeXt		; Set extend-flag
	jrst	readnx		; Go for another char
readpm:		; Same for now
readpe:		; Same for now
readc4:	skipe	PreMeta		; Is meta set?
	  addi	v,200		; Yes -- increment value
	skipe	PreeXt		; Is eXtend set?
	  addi	v,400		; Yes -- increment value
	setzm	PreCmd		; Clear command flag --Always--
	setzm	PreMeta		; Clear prefixes for next char
	setzm	PreeXt		;  so there is no confusion
readdn:	skipn	mcrdef		; Are we in define mode?
	  popj	s, 		;  No! -- Just return
	cain	v,7		; (For now, hard-code Bell!)
	  jrst	readdd		; Yes! -- Done defining
	idpb	v,mcrptr	; No! -- insert char in buffer
	popj	s,		; and return.
readdd:	setzm	mcrdef		; Clear define mode
	movei	v,400+")"	; Get terminator
	idpb	v,mcrptr	; deposit it
	push	s,[Exp [Asciz/Finished macro define mode./],^D27]
	pushj	s,ToPrompt	; print it
	pop	s,v		; pop stack
	jrst	readch		; and go for another char

Subttl	Usetty - Usefil:  Readch sub-functions

usetty:	skipn	nowait		; See if we're special
	  jrst	usettc		;  No -- go ahead with it
	hrroi	a,.Axsic	; Yes -- see if input
	seto	v,		; Default to "no-input"
	Auxcal	a,		; Anything ready to read
	  popj	s,		;  No -- Return v = -1 for nothing here
usettc:	hrroi	a,.Axi8c	; Yes -- attempt to read it
	Auxcal	a,v		; Inchrw equivalent (preserve Image mode)
	  jrst	[movei	v,1
		 sleep	v,
		 jrst	usettc]	; Loop (waiting for port)
    ; test & skip if this terminal type wants all 8 bits!!!
	trz	v,200		; Else zap parity
	jrst	readcm 		; return (to common return code)


usefil:	push	s,[4]		; (Using channel 4)
	pushj	s,read		; Read a char from the file
	pop	s,a
	jumpl	v,popout	; Branch on EOF
	jumpe	v,usefil	; In files...
	caie	v,15		;   ignore NULL,
	cain	v,12		;       CR and LF
	  jrst	usefil		;
	caie	v,"?"		; Check for <control escape>
	  jrst	readcm		;   No, -- return (through common code)
usefi1:	push	s,[4]		; Yes --- (Use channel 4)
	pushj	s,read		; Read another character
	pop	s,a
	jumpl	v,popout	; Branch on EOF
	jumpe	v,usefi1	; In files... always ignore NULL
;	caie	v,15		;   But here give a
;	cain	v,12		;       CR and LF
;	  jrst	fromfx		;   Cause an error!!!
	cain	v,"?"		; Our <control escape>?
	  jrst	readcm		;  Yes -- Return (through common code)
	cail	v,"a"		; Case map all to upper
	caile	v,"z"		; ... only alpha for now
	  caia			; No change, skip
	movei	v,-40(v)	; Map them -- UPPER CASE
	movei	v,-100(v)	; Map them -- CONTROL CHARACTERS
	skipl	v		;  Check if legal?
	  jrst	readcm		;   Yes -- Return (through common code)

popout:	pushj	s,metap		; EOF or illegal character
	jrst	readch		; Now continue?

Subttl	VUEMAC	Munchi

;MUNCHI - Routine to "munch" the input file by ignoring nulls and LF's
;
;	Push  s,[pointer]	or	Munchi(pointer);
;	Pushj s,Munchi
;	  <only return>
;

munchi:	move	b,s		; Setup for argument
	move	b,-1(b)		; Get byte pointer to storage
munchj:	movni	c,6		; Get number of bytes in a line-number
	movei	d,1		; Get a bit to test for later.
gloop:	sosge	dskbfh+2	; Count characters/check buffer
	  jrst	getbf		; Need another one...
	ibp	dskbfh+1	; Increment buffer pointer
	tdnn	d,@dskbfh+1	; Check line-number bit
	  jrst noline		; No! - Skip this stuff
	addm	c,dskbfh+2	; Decrement the count.
	aos	dskbfh+1	; Bump the pointer 5 bytes (ascii)
	ibp	dskbfh+1	; Bump the pointer 1 more byte
noline:	ldb	v,dskbfh+1	; Get a byte
	caie	v,0		;  Skip Nulls
	cain	v,12		;  and LF's
	  jrst	gloop		;   wherever found!
	idpb	v,b		; Store it in the right place.
	aos	e,lowend	; Increment and copy current point
	camge	e,hbot		; Are we out of room?
	  jrst	gloop		; No! - Get next byte
	movem	b,save		; Yes!
	pushj	s,corecheck	;   Get more core
	move	b,save		;
	jrst	munchj		; Loop for next, resetting constants.

getbf:	in	2,		; Get a buffer
	  jrst	gloop		;   Ok, Got one.
	popj	s,		; Finished? Assume we are done.

muncho:	move	c,s
	move	a,-1(c)		;ptr
	move	b,-2(c)		;length
ploop:	sosge	b		; Any characters left?
	  jrst	ret1		; No!  All done.
	ildb	c,a		; Get the byte
putcc:	sosg	dskbfh+2	; Disk buffer full?
	  jrst	putbf		;   Yes! Clear it first
putc:	idpb	c,dskbfh+1	; Dump char in buffer
	caie	c,15		; Is it a CR?
	  jrst	ploop		; No! - Get next character
	movei	c,12		; Yes! Get a LF
	jrst	putcc		; See if we can put it out

putbf:	out	2,
	  jrst	putc	errors, go home.
	jrst	ret0		;write failed.

Subttl	VUEMAC	Quiet	Putch	Putchi	Putchv	Flubfr

;Quiet	- Toggle the state of .SILENT
;
;	Pushj	s,Quiet		Quiet()
;
quiet:	Move	v,silent	; Get flag
	Jumpn	v,quiet0	; If non zero - Make zero
	Setom	silent		; else make non-zero
	popj	s,		; Return.
quiet0:	Setzm	silent		; Make zero
	popj	s,		; Return.

;Putch	- Output a character (put it into buffer)
;
;	Push	s,[char]	Putch(.char)
;	Pushj	s,Putch
;	  <only return>
;
putch:	move	v,s		; Get the character
	move	v,-1(v)		;   from the top of the stack
putchi:	skipe	silent		; If we're being quiet
	  popj	s,		;   then don't say a word
putchv:	skipe	altptr		; Skip (normal) if no alternate pointer
	  jrst	putalt		;   else deposit into alternate buffer
	jumpe	v,putchz	; Zero bytes must get special handling.
	sosge	ttysfd		; Any room left?
	  pushj	s,flubfr	;   No -- Flush the buffer
	idpb	v,bufptr	; Put it into the buffer
	popj	s,		; and Return

putchz:	pushj	s,flubfr	; flush buffer so we can type null
	hrroi	v,.Axo8i	; setup for output
	auxcal	v,0		; output a null
	popj	s,		; and Return

putalt:	idpb	v,altptr	; deposit byte
	popj	s,		; and Return

;Flubfr	- Output the buffer
;
;	Pushj	s,Flubfr	Flubfr()
;	  <only return>
;
flubfr:	setz	a,		; Put a NULL character
	idpb	a,bufptr	;   at the end of the buffer
	movei	a,ttybuf	; Get the address of the buffer
	hrli	a,(Point ^D9)	; Make a byte pointer (9-bits)
	movem	a,bufptr	; Store it for next time
	movei	a,4*ttybfs-1	; Calculate the buffer size
	movem	a,ttysfd	; Store it for next time
	hrroi	a,.Axptr	; Output String to aux-port using
	Auxcal	a,bufptr	;   bufptr ending at first null
	Popj	s,		; And return

Subttl	VUEMAC	PutOct	WrtOct	PutNum	WrtNum	PutRdx

;Output number routines - names are obvious

PutOct:	Tdza	t,t		; *PUT*
WrtOct:	seto	t,		; *Wrt*
	movem	t,PutWrt	; Set flag.
	movei	t,10		; Octal
	movem	t,Radix		; For the divisor
	move	v,s		; Get the dividend
	move	v,-1(v)		; From the stack
	Jrst	PutRdx		; -----

PutNum:	Tdza	t,t		; *Put*
WrtNum:	seto	t,		; *Wrt*
	movem	t,PutWrt	; Set flag.
	movei	t,12		; Decimal
	movem	t,Radix		; For the divisor
	move	v,s		; Get the dividend
	move	v,-1(v)		; From the stack
	jumpge	v,PutRdx	; -------
	skipe	silent		; Do we really need to do this work?
	  popj	s,		; No! -- Don't bother
	movm	v,v		; Get magnitude
	push	s,v		; Save it
	movei	v,"-"		; Get sign
	pushj	s,chrout	; And print it
	pop	s,v		; Restore number
PutRdx:	skipe	silent		; Do we have any work to do?
	  popj	s,		; No! -- Go home
PutRd0:	idiv	v,Radix		; Divide by radix - remainder in "a"
	exch	s,v		; Swap
	hrlm	a,(v)		; Store remainder on stack
	exch	s,v		; Swap
	skipe	v		; Are we done?
	pushj	s,PutRd0	; No -- Get next digit
	exch	s,a		; Swap
	hlrz	v,(a)		; Get digit to print
	exch	s,a		; Swap
	movei	v,"0"(v)	; Make printable
	pjrst	chrout		; Output character


Subttl	VUEMAC	Putstring	Writestring

;Putstring -	Routine to write a string to the screen.
;Writestring -	Routine to write a string to the screen taking care of
;		possibly funny characters.
;
;	Push	s,[Asciz /TEXT/]	Putstring(plit asciz 'TEXT');
;	Pushj	s,???string		Writestring(plit asciz 'TEXT');
;	  <only return>
;
PUTSTRING::				;  global routine putstring(foo)
	Tdza	v,v			;  *Put* entry point
WRITESTRING::				;  global routine writestring(foo)
	Seto	v,			;  *Wrt* entry point
	Movem	v,PutWrt		;  Set put/wrt flag
	Skipe	Silent			;   If .silent
	  Popj	s,			;       then return;
	Move	v,s			;
	Hrrzi	v,@-1(v)		;   WS$Ptr _ Point 7,.foo
	Hrli	v,(Point 7)		;
	Movem	v,WS$Ptr		;
WS$LP:	Ildb	v,WS$Ptr		;   v_scani(WS$Ptr);
	 Jumpe	v,Cpopj			;   if .v eql 0 then return;
	pushj	s,chrout		;   Put char into the buffer;
	Jrst	WS$LP			; end while .v neq 0;

chrout:	Skipe	PutWrt			; consider status of *Put* ! *Wrt*
	  PJrst	WLOSSV			; *Wrt*
	PJrst	Putchv			; *Put*

Subttl	VUEMAC	Writeloss

;Writeloss -	Routine to write a possibly funny character
;
;	Push	s,[char]		Writeloss("char");
;	Pushj	s,Writeloss
;	  <only return>
;
WRITELOSS::				; Global routine writeloss(foo)
	Skipe	Silent			;   If .silent
	  Popj	s,			;       then return;
	Move	v,s			;
	Move	v,-1(v)			; v _ .foo
WLOSSV:	Cail	v," "			; If .foo geq " "
	Cail	v,177			;     and lss .Rub
	  Jrst	WLOSS0			; NO
	Pushj	s,PUTCHV		;     Putchv(.foo)
	Aos	Physpos			;     Physpos _ Physpos+1
	  Popj	s,			;   end; Return;

WLOSS0:	Cain	v,15			; else If .foo eql #cr
	Jrst	LEFTMARGIN		;         then return Leftmargin()
	Caie	v,11			; else If .foo eql #tab
	  Jrst	WLOSS2			; NO
	Push	s,[Exp 11]		;	then begin
	Push	s,PHYSPOS		;
	Pushj	s,UPDATECURS		;	  Updatecursor(#tab,.Physpos)
	Sub	s,[2,,2]		;
	Push	s,v			;
	Push	s,PHYSLIN		;
	Pushj	s,GOXY			;	  Goxy( .v, .Physlin)
	Sub	s,[2,,2]		;
	Popj	s,			;	Return;

WLOSS2:	Came	v,ESCVALUE		; else If .foo eql .EscValue
	  Jrst	WLOSS4			; NO
	Movei	v,"$"			;      then
	Pushj	s,PUTCHV		;	  Putchv("$")
	Aos	PHYSPOS			;	  Physpos _ .Physpos + 1
	Popj	s,			;	  Return

WLOSS4:	Cain	v,177			; else if .foo eql .Rub
	  Movni	v,35			;	then foo _ "#"-#100;
	Push	s,v			; else+rubout ...
	Movei	v,"^"			;
	Pushj	s,PUTCHV		;	  Putchv("^")
	Pop	s,v			;
	Addi	v,100			;
	Pushj	s,PUTCHV		;	  Putchv(.foo+#100)
	Aos	PHYSPOS			;
	Aos	PHYSPOS			;	  Physpos _ .Physpos + 2
	Popj	s,			;	Return;

Subttl	VUEMAC	UpdateCursor

;UpdateCursor -	Routine to calculate the next character position
;		beginning at .foo if the character is .xc
;
;	Push	s,["char"]		UpdateCursor (xc,foo);
;	Push	s,[position]
;	Pushj	s,UpdateCursor
;	  <only return>
;

UPDATECURS::			
	Move	t,s			;
	Move	v,-1(t)			; Formal (.foo)
	Move	t,-2(t)			; Formal (.xc)
	Caie	t,11			;
	  Jrst	UPDCUR			;
	Soj	v,			;	.foo - 1
	Idiv	v,TABSIZE		;	  % .tabsize
	Imul	v,TABSIZE		;	    * .tabsize
	Add	v,TABSIZE		;	 + .tabsize
	Aoja	v,Cpopj			;	 + 1

UPDCUR:	Cail	t," "			; else if .xc geq " "
	Cail	t,177			;     and .xc lss .Rub
	  Caia				; NO
	Aoja	v,Cpopj			;	then .foo + 1
	Camn	t,ESCVALUE		; else if .xc eql .EscValue
	  Aoja	v,Cpopj			;	then .foo + 1
	Addi	v,2			; else .foo + 2
	Popj	s,			; Global Return!

Subttl	OLD Q-REGister MACRO space 100 words * n return a pointer to it

;Qreg	- Returns a byte pointer to q-space indexed by (a to z)
;
;	Push	s,["a"]		tp _ Qreg("a")
;	Pushj	s,qreg
;	  <only return>				v _ [Point 7,qspace("a")]
;
qreg:	movei	v,qspace	; Address of q-space
	hrli	v,441100	; Build a pointer
	move	a,s		; Get the name from the stack
	move	a,-1(a)
	cail	a,"a"		; Allow both UPPER and LOWER case
	 movei	a,-40(a)	;  to map into A-Z
	movei	a,-"A"(a)	; Offset from 0
	imuli	a,qwsize	; 100 words of storage for each
	add	v,a		; add for offset into q-space
	popj	s,		; Return a byte pointer in V

Subttl	VUEMAC	Dorescan - Rescan the command line

dorescan:
	rescan			; Allow the last line to be read
	 skpinl			; Anything there?
	   popj	s,		;  No! Just return

ifn ftcommand,<
reresc:	movei b,6		; Setup a temp buffer
	setzm	rsrwrd		;   for the command name
	move	a,[point 6,rsrwrd]
	movem	a,rsrwpt	; and a pointer to it
>
rescn:	hrroi	a,.Axi8s	; Look for a filename argument
	Auxcal	a,a		;  (Use Aux port so won't kill image mode)
	 skipa
	  trza	a,200
	popj s,			;Flopped:  no hyphen
	caie	a,"("		;[CB @ GC] *** Allow "(" since monitor does
	cain	a,";"		;for visit file
	jrst	vfile
	cain	a,"!"		;for old buffer
	jrst	obuff
ife ftcommand,<
	caie	a,"-"		;[CB] Hack attack
>
ifn ftcommand,<
	cain	a,"-"
	  jrst	rfile		;for read file
	cail	a,"a"
	caile	a,"z"
	  caia
	movei	a,-40(a)
	movei	a,-40(a)	;make sixbit
	 jumple	a,restst	;test word for monitor command
	sojle	b,rescn
	idpb	a,rsrwpt	;save the character
>
	jrst	rescn		;Look again
rfile:	pushj	s,ctrlxr	;Found the filename arg, process it
lrt:
	hrroi	a,.Axi8s	;eat the line feed if we can
	Auxcal	a,a		; (Use Aux port so won't kill image mode)
	 skipa
	  trza	a,200
	popj	s,
	popj	s,
vfile:	pushj	s,ctrlxv
	jrst	lrt		;eat the line feed if we can.
obuff:	pushj	s,uctrlo
	jrst	lrt		;eat the line feed if we can.
ifn ftcommand,<
restst:	caige	b,0
	  setz	b,
	imuli	b,6
	seto	a,
	lsh	a,(b)
	move	b,[sixbit/vue/]
	and	a,b
	camn	a,rsrwrd
	  jrst	rfile
	move	a,[sixbit/ct4/]
	camn	a,rsrwrd
	  jrst	rfile
	move	a,[sixbit/vue/]
	camn	a,rsrwrd
	  jrst	rfile
	jrst	reresc
> ; end ifn ftcommand
Subttl	VUEMAC	Setlab	- Set re-enter address and save bliss stuff

setlab:	movem	s,saveds	; Save S and next 4 BLISS registers
	movem	1,saveds+1	;	????
	movem	2,saveds+2	;	FREG
	movem	3,saveds+3	;	VREG
	move	a,s		; Get address of where to start
	move	a,0(a)		; ...as in RE-Start
	movem	a,place		; Store it some place
	movei	a,readr		; Get REEnter address
	movem	a,.Jbren	; Set REEnter address.
	popj	s,		; Return

quit:	pushj	s,fen		; Reset the terminal
	exit	1,		; Bye.
; *** maybe need to reset inirvx here ***
	pushj	s,fef		; Oh?  Turn it back on.
	popj	s,		; Return to where we came from

exerr:	pushj	s,fen		; Reset the terminal
	exit	1,		; Bye.
readr:	movei	a,1		; Set repeat count to 1
	movem	a,repcount
	setz	a,		; Clear ...
	movem	a,rptr		; Rptr	(pop their stack)
	movem	a,csnum		; Csnum	(tty input)
	move	s,saveds	; Restore saved values...
	move	1,saveds+1
	move	2,saveds+2
	move	3,saveds+3
	pushj	s,fef		; Setup the terminal again
	jumpa	@place

Subttl	VUEMAC	Gettty	Getwid	Getaux	Getlen

gettty:	skipa	a,[-1,,.axttp]	; (100) Terminal type
getwid:	hrroi	a,.axwid	;  (27) Line width
getaux:	seto	v,		; Read my port
	auxcal	a,v		; Value returned in v
	popj s,

getlen:	seto	v,	; Tymcom-X doesn't do this at all
	popj s,

Subttl	VUEMAC	Getaun	Getab	Mail

Mail:	hrroi	v,.gtprv	; Look at user privs
	gettab	v,		;    in the monitor tables
	  setz	v,		; Well?
	tdnn	v,[1b8!1b23]	; Check for MAIL-WAITING bit(s)
	  tdza	v,v		;  No! Clear all other bits & skip
	movei	v,1		; Yes! Make it TRUE
	popj	s,		; Return

getnam:	hrroi	v,.gtnam	; Program name
	jrst	getab
getlic:	hrroi	v,.gtlic	; User license
	jrst	getab
getprv:	hrroi	v,.gtprv	; User privilages
	jrst	getab

getfpn:	skipa	v,[-1,,.gtfpn]	; Frame ppn
getaun:	hrroi	v,.gtaun	; Accounting User Number
getab:	gettab	v,		;    for this user
	  setz	v,		; Hmmmm. well indicate FALSE
	popj	s,		; Return

Subttl	VUEMAC	Getppn	Getjob

Getppn:	Calli	v,24		; Getppn v,
	  jfcl			; Jacct skip if 1,2
	popj	s,		; Return

Getjob:	Pjob	v,		; Get my job number
	popj	s,		; Return

Subttl	VUEMAC	PutBCD	PutPad

PutBCD:	skipe	silent
	  popj	s,
	move	v,s		;for indexing.
	move	v,-1(v)		;the argument.
	idivi	v,12		;divide by 10. 2 has x/10, 3 has rem.
	lsh	v,4		;shift l
	add	v,a		;now r2 has bcd version.
	pushj	s,putchv
	popj	s,

PutPad:	skipe	silent
	  popj	s,
	move	v,s		;for indexing.
	move	a,-1(v)		;the padding width.
	move	v,-2(v)		;the number.
	move	b,a		;save a copy thereof.
	move	c,v		; ...
	idivi	c,12		; divide
	push	s,d		; save on stack
	 sojg	a,.-2		; loop!
	pop	s,v		; get number
	addi	v,"0"
	pushj	s,putchv
	 sojg	b,.-3		; to pop - loop
	popj	s,

Subttl	VUEMAC	Moveforward - Move pointer forward n bytes

movefo:	setzm	ctrlct
	move	a,curlin
	movem	a,ocl		;save to see if passed a cr.
	move	a,s		;can not indirect off of sp with this bliss.
	move	a,-1(a)		;get the number of bytes we are to move.
	move	c,lowend	;get .lowend of buffer.
	idivi	c,5		;make an address
	add	c,table(c+1)	;convert to an ildb pointer
	add	c,p		;offset from buffer address
	move	d,hbot		;get .hbot of buffer.
	idivi	d,5		;make an address
	add	d,table(d+1)	;convert to an ildb pointer
	add	d,p		;offset from buffer address
	addm	a,lowend
	addm	a,hbot
lp1:	sosge	a		;do loop ctr.
	  jrst	car		;go home after checking ocl with curlin.
	ildb	e,d		;get byte
	idpb	e,c		;dump it
	caie	e,15		;return?
	cain	e,14		;form-feed?
	  caia			;yes, skip
	 jrst	lp1		;no, loop
	caie	e,15		;skip if a c-ret
	  jrst	.+4		;no, do ff
	aos	curlin		;count lines
	aos	bfrlin		;count lines in buffer
	jrst	lp1
	aos	ctrlct		;count of these.
	aos	bfrpag		;count pages in buffer
	setzm	bfrlin		;clear line-count (0-n)
	jrst	lp1

Subttl	VUEMAC	Moveback - Move the pointer backward n bytes

moveba:	setzm	ctrlct
	move	a,curlin	;save curlin
	movem	a,ocl		;in ocl.
	move	a,s		;can not indirect off of sp with this bliss.
	move	a,-1(a)		;get the number of bytes we are to move.
	move	c,lowend	;get lowend of buffer
	idivi	c,5		;make an address
	add	c,table+1(c+1)	;convert to a ldb pointer
	add	c,p		;offset from buffer address
	move	d,hbot		;get the hbot value
	idivi	d,5		;make an address
	add	d,table+1(d+1)	;convert to a ldb pointer
	add	d,p		;offset from buffer address
	movn	b,a		;negate to subtract
	addm	b,lowend	;decrement value
	addm	b,hbot		;of lowend and hbot
lp2:	sosge	a		;do loop ctr.
	  jrst	car		;go home and set muline perhaps
	add	c,[7b5]		;decrement number
	caig	c,0
	  sub	c,[430000,,1]
	ldb	e,c		;get byte
	add	d,[7b5]		;decrement the thing.
	caig	d,0
	  sub	d,[430000,,1]
	dpb	e,d		;dump it
	caie	e,15		;return?
	cain	e,14		;form-feed?
	  caia			;yes, skip
	 jrst	lp2		;no, loop
	caie	e,15		;skip if a c-ret
	  jrst	.+4		;no, do ff
	sos	curlin		;count lines
	sos	bfrlin		;count lines in buffer
	jrst	lp2
	sos	ctrlct		;count of these.
	sos	bfrpag		;count pages in buffer
	setzm	bfrlin		;clear line-count (0-n)
	jrst	lp2


car:	skipe	ctrlct
	  jrst	mulpag
	move	a,ocl
	camn	a,curlin
	  popj	s,
	movei	a,1
	movem	a,muline
	popj	s,

mulpag:	movei	a,1
	movem	a,muline
	movem	a,scrmod
	popj	s,

Subttl	VUEMAC	Makptr, Getchxr( loc )

getchx:	movei	v,15		;prepare to return a <cr>.
	move	a,s
	skipg	a,-1(a)		;1 is start, get desired char.
	 popj	s,
	camge	a,lowend	;compare arg with lowend
	 jrst	norel		;in low part of gap.
	add	a,hbot		;add this in.
	sub	a,lowend	;just do the formula
	caml	a,hend
	 popj	s,
norel:	idivi	a,5		;a is count/5, a+1 is remainder
	add	a,table+1(a+1)	;convert to a ldb pointer
	add	a,p		;offset from the buffer address
	ldb	v,a		;magic
	popj	s,

table:	100700-1,,-1		; fourth byte last-word
	 10700-1,,-1		; fifth  byte last-word
	350700,,0		; first  byte
	260700,,0		; second byte
	170700,,0		; third  byte
	100700,,0		; fourth byte


Subttl	VUEMAC	Therep, Ftp	(keep near GETCHXR & TABLE)

therep:	move	a,s		; convert char pos in arg 2 to an ildb ptr.
	move	b,-1(a)		; the char ptr.
	camge	b,lowend	;compare arg with lowend
	 jrst	norel2		;in low part of gap.
	add	b,hbot		;add this in.
	sub	b,lowend	;just do the formula
norel2:	idivi	b,5		;b is count/5, b+1 is remainder
	add	b,p
	add	b,table(c)	;magic byte ptr we will use.
	jrst	ftpae		;alt entry to ftp

	;Fast version of therep. Takes as arg 1 (-2(sp)) the line we're
	;looking for, and as arg 2 (-1(sp)) the ildb byte ptr to use.

ftp:	move	a,s		;get the sp somewhere useful.
	move	b,-1(a)		;the byte ptr to use.
ftpae:	move	a,-2(a)		;the ptr to line
	move	c,0(a)		;the size field
	hrli	a,004400	;make a pointer (point 36,loc,35)
	movei	v,0		;return false by default.

ftplp:	sojl	c,ftpwon	;if we are equal.
	ildb	d,b		;get a buffer char.
	ildb	e,a		;get search char.
	xor	e,d		;determine intersection set.
	 jumpe	e,ftplp		;ok! equal - try next
	caie	e,40		;differ by case?
	 popj	s,		;no! return.
	trz	d,40		;will make lower case upper
	cail	d,"A"		;less than "A" is ok.
	 caile	d,"Z"		;less than "Z".
	  popj	s,		;non alphabetic! return.
	skipe	caseok		;either case ok?
	 popj	s,		;no!  must match.  return.
	jrst	ftplp		;increment loop
ftpwon:	movei	v,1		;return true.
	popj	s,

Subttl	VUEMAC	EolChxr	EolBreak  - End of line check (CR or FF)

; routine eolchxr (i) = eolbreak( getchxr(.i) );
;	  eolchxr returns 1 if ith char is an end-of-line/page
; routine eolbreak (ch) = ("?M" eql .ch or "?L" eql .ch);
;	  eolbreak returns 1 if at end-of-line end-of-page
; routine eoltype (i) returns 1 if eol-char is FF & SOS mode is true.

EOLCHXR::
	move	v,s		; Get the character position
	move	v,-1(v)		;   from the top of the stack
	push	s,v		; Push for GET-CHAR
	pushj	s,GETCHXR	; Get the char
	sub	s,[1,,1]	; pop argument
	jrst	.+3		; jump into code
EOLBREAK::
	move	v,s		; Get the character
	move	v,-1(v)		;   from the top of the stack
	caie	v,15		; Compare with CR
	cain	v,14		;   and FF
L.RET1:	 skipa	v,[1]		; A match!!! (SKIP)
L.RET0:	setz	v,		; no match.
	popj	s,		; Return result.


EOLTYPE::
	skipn	sosmod		; If not Page-Mode this is moot
	  jrst	L.RET0		;   so return FALSE
	move	v,s		; Get the character position
	move	v,-1(v)		;   from the top of the stack
	push	s,v		; Push for GET-CHAR
	pushj	s,GETCHXR	; Get the char
	sub	s,[1,,1]	; pop argument
	caie	v,14		; Compare if FF
	  jrst	L.RET0		; No! ----- Return FALSE
	 jrst	L.RET1		; Yes! ---- Return TRUE

Subttl	VUEMAC	FmtChxr	FmtBreak - Formated text check ("@" and ".")

; routine fmtchxr (i) = fmtbreak( getchxr(.i) );
;	  fmtchxr returns 1 if ith char is an "@" or "."
; routine fmtbreak (ch) = ("@" eql .ch or "." eql .ch);
;	  fmtbreak returns 1 if the ith character is an "@" or "."

FMTCHXR:
	move	v,s		; Get the character position
	move	v,-1(v)		;   from the top of the stack
	push	s,v		; Push for GET-CHAR
	pushj	s,GETCHXR	; Get the char
	sub	s,[1,,1]	; pop argument
	jrst	.+3		; jump into code
FMTBREAK:
	move	v,s		; Get the character
	move	v,-1(v)		;   from the top of the stack
	caie	v,"."		; Compare with period
	cain	v,"@"		;   and at-sign
	 skipa	v,[1]		; A match!!! (SKIP)
	setz	v,		; no match.
	popj	s,		; Return result.

Subttl	VUEMAC	WhtChxr  WhtBreak  WhiteSpace  WBreak

; routine whtchxr (i) = whtbreak( getchxr(.i) );
;	  whtbreak returns 1 if at some horizontal whitespace
; routine whtbreak (ch) = (" " eql .ch or "?I" eql .ch);
;	  whtchxr returns 1 if ith char is horizontal whitespace

WHTCHXR:
	move	v,s		; Get the character position
	move	v,-1(v)		;   from the top of the stack
	push	s,v		; Push for GET-CHAR
	pushj	s,GETCHXR	; Get the char
	sub	s,[1,,1]	; pop argument
	jrst	.+3		; jump into code
WHTBREAK:
	move	v,s		; Get the character
	move	v,-1(v)		;   from the top of the stack
	caie	v," "		; Compare with space
	cain	v,11		;   and Tab
	 skipa	v,[1]		; A match!!! (SKIP)
	setz	v,		; no match.
	popj	s,		; Return result.

; routine whitespace returns 1 if char is "white" or "eol"

WHITESPACE::
	move	t,s		; Get character from
	move	t,-1(t)		;  the stack
	push	s,t		; and then just check
	pushj	s,WHTBREAK	;  to see if it's white
	 jumpn	v,L1.RT1	; Yes?  Pop stack and return TRUE
	pop	s,t		; restore character
	jrst	EOLBREAK	;  and return through EOL check

; routine wbreak returns 1 if char is not alphanumeric (a-z,A-Z,0-9)

WBREAK::
	move	t,s		; Get character from
	move	t,-1(t)		;  the stack
	setz	v,		; Default to FALSE
	cail	t,"a"		; Check for lower-case
	caile	t,"z"		;  letters first
	  caia			; No!  so skip and continue
	 popj	s,		; Yes! so return FALSE
	cail	t,"A"		; Check for upper-case
	caile	t,"Z"		;  letters next
	  caia			; No!  so skip and continue
	 popj	s,		; Yes! so return FALSE
	cail	t,"0"		; Check for numbers
	caile	t,"9"		;  last of all
	  movei	v,1		; No!  so return TRUE
	 popj	s,		; Yes! so return FALSE

Subttl	VUEMAC	PBreak	- whether we are at a paragraph break

;;
;;   A paragraph break occurs at:
;;	the beginning of the buffer
;;	the end of the buffer
;;	a formfeed
;;	a carriage return followed by a blank line
;;	a carriage return followed by @ or .
;;			(SCRIBE or PUB commands)

;global routine pbreak (i) = begin
;    register char;
;    if (.i leq 1) or				! beginning-of-buffer
;       (.i geq .hend-1+.lowend-.hbot)		! end-of-buffer
;     then return 1;
;    char_ getchxr(.i);
;    if "?L" eql .char				! get char
;	    then return 1			! ff
;	    else if "?M" eql .char
;		  then if .i eql .hend-.hbot+.lowend-1
;			then return 1		! cr end-of-buffer
;			else if blankline(.i+1)
;			      then return 1	! cr [wh] cr/end-of-buffer
;			      else if fmtchxr(.i+1)
;				   then return 1;	! cr @/.
;    return 0
;end;

PBREAK::
	move	t,s		; Get the character position
	move	t,-1(t)		;   from the top of the stack
	move	v,hend		; Get end of buffer space
	sub	v,hbot		; Minus end of buffer text
	add	v,lowend	; Plus current loc
	caile	t,1		; Char pos leq 1
	caml	t,v		;   or outside buffer
	  jrst	L.RET1		; Yes! ----- Return TRUE (exceeded limits)
	push	s,t		; Push for GET-CHAR
	pushj	s,GETCHXR	; Get the char
	pop	s,t		; restore position argument
	cain	v,14		; Compare if FF
	  jrst	L.RET1		;   jump if TRUE (PARA-END)
	caie	v,15		; Compare with CR
	  jrst	L.RET0		;   jump if FALSE (not PARA-END)
	aoj	t,		; Increment pointer
	push	s,t		;  and save it for call
	pushj	s,FMTCHXR	;  to check for "@" or "."
	pop	s,t		; Restore pointer
	 jumpn	v,L.RET1	; If non-zero we have a match
	jrst	BL.LN1		; else check for blank line (next page)

Subttl	VUEMAC	BlankLine	- checks for blank space to next EOL

;routine blankline (i) = begin
;    register char;
;    if .i lss 1 or .i geq .hend-.hbot+.lowend-1
;     then return 0;
;    char_ getchxr(.i);
;    while not eolbreak( .char )
;     do begin
;       if not whtbreak( .char )
;	 then return 0;
;       i _ .i + 1;
;       if .i geq .hend-.hbot+.lowend-1
;	 then exitloop;
;	char_ getchxr(.i);
;     end;
;    return 1
;end;

BLANKLINE:
	move	t,s		; Get the character position
	move	t,-1(t)		;   from the top of the stack
	caige	t,1		; Char pos geq 1
	  jrst	L.RET0		; No! ----- Return FALSE (too small)
BL.LN1:	move	v,hend		; Get end of buffer space
	sub	v,hbot		; Minus end of buffer text
	add	v,lowend	; Plus current loc
	caml	t,v		; Char pos inside buffer
	  jrst	L.RET1		; No! ----- Return TRUE (ran out)

; *** Later think about just "Ldb v,a" instead of GETCHXR call ***

	push	s,t		; Push for GET-CHAR
	pushj	s,GETCHXR	; Get the char
	pop	s,t		; restore position argument
	caie	v,15		; Compare with CR
	cain	v,14		;   and FF
	  jrst	L.RET1		; jump if TRUE (EOL)
	caie	v," "		; Compare with space
	cain	v,11		;   and Tab
	  caia			; whitespace! skip on..
	 jrst	L.RET0		; return false
	aoja	t,BL.LN1	; loop till hit EOL or run out

Subttl	VUEMAC	FindBreak	- finds first break before pointer

; findbreak is called with a character position.  it returns the position
; of the first character following the paragraph break at or before the
; given argument.
;
;routine findbreak (i) = 
;    decr j from .i to 1 do if apbreak(.j) then return .j;

FINDBREAK:
	move	t,s		; Get initial "I"
	move	t,-1(t)		;  from the stack
FIND.0:	jumpe	t,FIND.1	; Finished when reached 0
	push	s,t		; Push again... See if at
	pushj	s,APBREAK	;   end of paragraph break
	pop	s,t		; Pop argument
	skipn	v		; Find a break?
	  sojg	t,FIND.0	; No! ----- Keep looking
FIND.1:	move	v,t		; Report home with the news
	popj	s,		; ...


L1.RT0:	tdza	v,v		; Clear flag and skip
L1.RT1:	movei	v,1		; Set flag to TRUE
	sub	s,[1,,1]	; Pop argument off stack
	popj	s,		; and return

Subttl	VUEMAC	APBreak	- checks for "after" a paragraph break

; ----------------------------------------------------------------------
; apbreak returns 1 if the given character position is the end of
; a legal paragraph break
; ----------------------------------------------------------------------
;
;global routine apbreak (i) = begin register char;
;	if (.i leq 1) or				! beginning of buffer
;	   (.1 geq .hend-1+.lowend-.hbot)		! end of buffer
;	 then return 1;
;	char_ getchxr(.i);
;	if "?L" eql getchxr(.i-1) or			! beginning of page
;	   "?L" eql .char				! end of page
;	 then return 1;
;	if "?M" neq getchxr(.i-1) then return 0;	! prev cr
;	return if .char eql "@" or .char eql "."
;	     then 1					! cr/ff  @/.
;	     else blankprev(.i-2);			! blank cr
;    end;

APBREAK::
	move	t,s		; Get the character position
	move	t,-1(t)		;   from the top of the stack
	move	v,hend		; Get end of buffer space
	sub	v,hbot		; Minus end of buffer text
	add	v,lowend	; Plus current loc
	caile	t,1		; Char pos leq 1
	caml	t,v		;    or outside buffer
	  jrst	L.RET1		; Yes! ----- Return TRUE (out of range)
	push	s,t		; Push for GET-CHAR
	pushj	s,GETCHXR	; Get the char
	pop	s,t		; restore position argument
	cain	v,14		; Compare with FF
	  jrst	L.RET1		; jump if TRUE (EOL)
	soj	t,		; Backup a character
	push	s,v		; Save this character for later
	push	s,t		;   and setup to look at
	pushj	s,GETCHXR	;   the previous character.
	pop	s,t		; Restore counter
	cain	v,14		; Compare with FF
	  jrst	L1.RT1		; A match! -- Pop S & return TRUE
	caie	v,15		; Compare with CR
	  jrst	L1.RT0		; No! ----- Pop S & return FALSE
	pop	s,v		; Yes! ---- Check for CR, "@" or "."
	caie	v,"."		; PUB or RUNOFF user?
	cain	v,"@"		;  ou peut-etre SCRIBE?
	  jrst	L.RET1		; We allow it for now.
	cain	v,15		; Compare with CR
	  jrst	L.RET1		; Hmmmm. usually not possible.
	soja	t,BL.PV1	; Well, look for prev. blank line

Subttl	VUEMAC	BlankPrev	- checks for previous blank line

;routine blankprev (i) = begin
;    register char;
;    if .i lss 1 or .i geq .hend-.hbot+.lowend-1
;     then return 1;
;    char_ getchxr(.i);
;    while not eolbreak( .char )
;     do begin
;	if not whtbreak( .char )
;	 then return 0;
;	.i _ .i - 1;
;	if .i lss 1 then exitloop;
;	char_ getchxr(.i);
;     end;
;    return 1
;end;

BLANKPREV:
	move	t,s		; Get the character position
	move	t,-1(t)		;   from the top of the stack
	move	v,hend		; Get end of buffer space
	sub	v,hbot		; Minus end of buffer text
	add	v,lowend	; Plus current loc
	caml	t,v		; Char pos inside buffer
	  jrst	L.RET0		; No! ----- Return FALSE (not enough)
BL.PV1:	caige	t,1		; Char pos geq 1
	  jrst	L.RET1		; No! ----- Return TRUE (ran out)
	push	s,t		; Push for GET-CHAR
	pushj	s,GETCHXR	; Get the char
	pop	s,t		; restore position argument
	caie	v,15		; Compare with CR
	cain	v,14		;   and FF
	  jrst	L.RET1		; jump if TRUE (EOL)
	caie	v," "		; Compare with space
	cain	v,11		;   and Tab
	  caia			; whitespace! skip on..
	 jrst	L.RET0		; return false
	soja	t,BL.PV1	; loop till hit EOL or run out


Subttl	VUEMAC	Dmpin/Dmpout - (Chan, Addr, Size)

; args are channel,address,size
dmpin:	move	a,s
	move	b,-1(a)		;the size
	move	a,-2(a)		;the address
	movn	b,b		;negate it.
	hrlm	b,dmblk		;put the size down
	subi	a,1		;calc address.
	hrrm	a,dmblk		;
	movei	v,1		;won
	in	2,dmblk		;dump mode block
	  popj	s,
	movei	v,0		;error return -> lost.
	popj	s,

dmpout:	move	a,s
	move	b,-1(a)		;the size
	move	a,-2(a)		;the address
	movn	b,b		;negate it.
	hrlm	b,dmblk		;put the size down
	subi	a,1		;calc address.
	hrrm	a,dmblk		;
	output	2,dmblk		;dump mode block
	popj	s,

Subttl	VUEMAC	Error message routines - E$$COD, E$$NEC

E$$COD:	Outstr	[Asciz\
?
?VUECOD	Cannot Open Device for file rename(s) - Please recover with Olde buffer
\]
		Jrst	exerr			; Exit

E$$NEC:	Outstr	[Asciz\
?
?VUENEC Not enough core to edit file
\]
	jrst	exerr


	Reloc	; 0

place:	0
saveds:	block	4		; register save area.

silent:	0			; quiet flag - 0 is noisy - #0 is quiet
scrlen: ^D18
scrsze:	^D18
modpos: ^D18
maxss:	^D27			; Make sure this = # used * 132
screen:	block	^D27*<^D135/5>	; Change 25==>27 hazeltine 2000

ttybfs=^D100			; tty buffer size in words.
radix:	^d10			; initially decimal
putwrt:	0			; flag for put/wrt routines
ws$ptr:	0			; Storage - Pointer for Writestring/Putstring
altptr:	0			; Alternate buffer pointer - initially 0
bufptr:	Point ^D9,ttybuf	; Pointer for tty output
ttybuf: block ttybfs		; tty buffer
ttysfd: 4*ttybfs-1		; tty buffer size

qwsize==^D40			; 40 * 4-chars (9-bit bytes)
mcrdef:	block	1		; flag for macro by define
mcrptr:	block	1		; pointer into qspace for define
qspace: block ^D26*qwsize	; 160 chars by 26 macros.

distbl:	.+1			; pointer to table
	block ^D512		; command dispatch table

physpos: 1
physlin: 1
tabsize: ^D8
csnum: 0
linesz: ^D79
clulin:	0
clupos: 0
scrmod: 1
muline: 1
ocline: -1
comchar:	0
newcount:	0
repcount:	0

DmpBfr::		; --- This is the buffer environment ---
p:	0		; address of buffer begin
hend:	0		; high end of buffer
hbot:	0		; high bottom (first point after gap)
hptr:	0		; Pointer to char(.lowend+1) after-gap
lowend:	0		; low end of buffer
lowbot:	1		; low bottom (always 1)
lowptr:	0		; Pointer to char(.lowend) before-gap
curlin:	1		; current line
curpag:	1		; current page
UsrPPN:			; User GFD'd PPN  -- only 1 word ---
ppn: 0			; User GFD'd PPN
vuetyp:	0		; VUE type
submod:	0		; SUB Mode
bfrlin:	0		; line user is on
bfrpag:	0		; page user is on
scroff: 0		; offset of buffer in screen.

filblk: sixbit/dsk/	; device
	sixbit/delete/	; file
	Exp 0,0,0,0	; ext, prot-cre, ppn, extra
	Exp 0,0		; Username (2w)
DmpBsz==.-DmpBfr	; --- This is the end of the buffer environment ---

save: 0
mark: 0

ttytyp: 0			; Terminal type (numeric)
ttype:	0			; Terminal type in sixbit
tspeed:	0			; Terminal output speed

Usrprv:	z			; User privilage word
Usrlic:	z			; User license word
Usrnam:	z			; User program name
UsrAUN:	z			; User Account Number
UsrFPN:	z			; User FRAME PPN

flush:	0
base:	0
precmd:	0			; possible command character (readcc)
premeta:0			; meta-seen flag for readch
preext:	0			; extend-seen flag for readch
tymtty:	block	1		; Remember tty characteristics GETLCH
inirvx:	block	1		; Remember tty characteristics XON
nowait:	0			; decide whether to wait in Reader

dskbfh:	block	3
dskbuf:	block	200		; Disk buffer for DMPIN/DMPOUT

sst:	block	^D132		; Search string

rsrptr:	point	7,rsrbuf	;pointer into buffer
rsrpnt:	point	7,rsrbuf	;pointer into buffer
rsrcnt:	block	1		;count character space
rsrchr:	block	1		;Rescan break character, -;(
rsrwrd:	block	1
rsrwpt:	point	6,rsrwrd
rsrbuf:	block	<^D135*2>/5	;Room for 2 lines at 132 chars
	rsrend=.
	rsrmax=<rsrend-rsrbuf>*5 ;# characters maximum

;;cstk:	block	35		;max depth of  macro calls.
rsrstk:	block	1		;place for rescan pointer

ocl:	0
ctrlct:	0
dmblk:	0
	0


bakx: sixbit/bak/
defdsk: sixbit/dsk/
zapdev:	0
	sixbit/dsk/
	0

bfblk1:	sixbit	/dsk/
	sixbit	/main/
	sixbit	/vue/
	Exp 0,0,0
	Exp 0,0		; Username

bfblk2:	sixbit	/dsk/
	sixbit	/main/
	sixbit	/vue/
	Exp 0,0,0
	Exp 0,0		; Username

autblk: sixbit/dsk/
	sixbit/vue/
	sixbit/tmp/
	Exp 0,0,0
	Exp 0,0		; Username

modblk:	sixbit/dsk/
	sixbit/init/
	sixbit/exe/
	Exp 0,0,0
	Exp 0,0		; Username


	Reloc	; 400000		; Literals, etc should be shareable

	End
   @qVG