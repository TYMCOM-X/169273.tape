.lm0;.rm 80;.fill;.just
.figure 20;.c;FINE
.s2
.c;A Display Editor for the DEC-10/20
.s3;.c;Mike Kazar (CMU)
.s2;.c;Modified for TYMCOM-X on 25-Dec-80
.s2;.c;By
.s2;.c;Carl A Baltrunas (Tymshare)
.s3;.c;Manual last updated 26-Dec-80
.page
.number 1
.hl 1 Introduction

^&FINE\& stands for ^&FINE Is Not Emacs\&.  It is a screen editor for use on
display terminals.  The basic philosophy behind ^&FINE\& is that when
someone is modifying a file at a particular position, s(he) would
really like to see the text surrounding that point.  A secondary point
of philosophy is that the user would like to type the minimum number of
keystrokes to get something accomplished.  These combine to make editing a
file much easier, since it is not necessary to type commands to the
editor to see the neighborhood surounding the area you are editing,
as an entire page of text is on the screen.
.s1
Now, on to the description of the actual editor.
A word that will be used extensive in this manual is BUFFER.  A
buffer is simply the term used to describe the information that you are
currently editing, usually a copy of a file.  Indeed, a buffer is
basically just that, a copy of the file you are editing which contains
the up-to-the-minute copy that you have produced.  When you have
finished getting this buffer into the shape you want it in, you
will then write the buffer back out into the file where it came from
(you actually have the option of writing the buffer out to a different
file, or even several different files, but these details will be
covered later).
.s1
The way that ^&FINE\& works is to keep a window into the buffer such
that the window shows you the area of the file near where you are
currently editing.  The window contains the line that has the cursor in
it, and several lines on either side, depending on the screen size.  As
the user moves the cursor around the file, the window automatically
follows, hopefully doing the minimum amount of redisplay necessary.
.s1
The editor has a fair sized set of commands.  The vast majority of these
commands cause some action to be performed, and the question comes up,
what part of the text is modified by a particular command?  The answer
is that ^&FINE\& is a character-oriented editor.  The buffer containing
the file is divided into two sections, the portion before the cursor,
and the portion after the cursor.  The cursor is the (usually blinking)
short line on the terminal where the computer types.  The character that
appears under the cursor is actually the first character in the section
that I refer to as "the portion after the cursor".  Thus the ^&FINE\&
cursor is between the character before the blinking line and the
character under it.  Virtually all commands do their work at this point.
For instance, the delete-forward command (usually invoked by typing _^D)
deletes the first character in the section after the cursor.  The
delete-backwards command deletes the character immediately preceding
the cursor.  When you insert a character, it appears right where the
cursor is.  Some other more complex commands are still quite polarized
around this concept of changes near and around the cursor.  For
instance, there is a command to re-justify a paragraph, and the
paragraph that it picks is the one containing the cursor at the time
the command is typed.
.s1
Now another definition.  A ^&line\& is simply the region between two
carriage returns.  Note that when a file contains a cr-lf pair, the lf
is deleted when the file is read in, and is put back when the file is
written out.  This is done with the philosophy that a cr-lf pair is
really supposed to mean "new line" and should not be two separate
characters.  For regular text files, this should be ^&completely\&
invisible to you.  If you don't understand this paragraph, it's main
point is that lines are separated from their neighbors by a ^&single\&
invisible character, which can be treated as any other (e.g.  it can be
inserted, deleted, searched for or any other operation that can be
performed on other characters).  This character is typed by hitting the
carriage return key on the terminal (not surprisingly).

In the following, "_^" is used to signify that the character following
it is struck while at the same time depressing the CTRL key.  The prefix
"Control-" is used for the same thing.  Also note that "_^A" and "_^a" are
identical in effect, where "A" stands for any letter.
.s1
Similarly, the term meta characters is used to speak of those
characters struck while holding down the meta key.  Since none of the
terminals here at CMU ^&have\& meta keys, a special convention is used
to type these characters in.  The convention is that one types the
character _<esc_> (escape) directly in front of the character.  For
instance, to type "Meta-A", you would hit the _<esc_> key followed by the
"A" key.  This is known as using _<esc_> as a prefix character, since
characters prefixed by _<esc_> are treated differently from those typed
otherwise.  There is rarely a fixed relationship that the meta-ized
version of a character holds with respect to the normal version, though
in some cases you will note some similarities (e.g.  Ctrl-F moves
forward a ^&character\&, while Meta-F moves forward over a ^&word\&).
.s1
Similarly, prefixing a character with a Ctrl-X character causes it to
be treated as yet another command.  It should be noted that the reason
for these prefix characters is simply that there aren't enough
control characters to provide commands for all the functions that
^&FINE\& provides.
.s1
In addition to all of these fancy commands typed by using exotic shift
keys and bizarre prefixes (which really are only three in number and
thus not that hard to deal with), there are the commands which are
typed without holding down the Ctrl key, or typing either _<esc_> or
Ctrl-X as a prefix.  These commands are very simple, they simply insert
the character specified.  For example, just hitting the "a" key causes
an "a" to be inserted in the text right where the cursor is located.
.s1
Next we have a list of all of the commands ^&FINE\& understands.

.page

.hl 2 Basic Commands
.lm+12;.ts12
.b1;.i-12;_!"...012...ABC...abc...	All standard printing characters:
These characters simply insert themselves into the buffer at the
current cursor position.
.b1;.i-12;_^A	Left-margin.  Move the cursor to the left margin
of the current line (the line containing the cursor).
.b1;.i-12;_^B	Back.  Move the cursor *Backwards one character.
It moves over carriage returns, too.
.b1;.i-12;_^C	Call.  Get out to the Monitor.
Use this for interrupting the editor. It will leave you at monitor
level. You may type .ree or .cont to reenter on TOPS-10 systems, and
the equivalent @ree and @continue to TOPS-20.
.b1;.i-12;_^D	Delete.  *Delete the character immediately following
the cursor (it appears under the cursor).
.b1;.i-12;_^E	Right-margin.  This command moves the cursor to the right margin of
the current line, i.e.  to the *End of the line.
.b1;.i-12;_^F	Forward.  Move the cursor *Forward one character.
.b1;.i-12;_^G	Escape.  This command does nothing.
It is the *General escape (*Gasp) character.
Typing it at any time should get you back to the standard input mode.
the next time that a character is read by ^&FINE\&.
It does not cause an ^&interrupt\&.  If ever you do not know what ^&FINE\&
is doing, typing this should fix things.
.b1;.i-12;_^H	Back-delete.  This command is the same as rubout.  It deletes the
character just preceding the cursor in the buffer.
.b1;.i-12;_^I	Tab.  This command is self-inserting, and inserts a tab
character.
.b1;.i-12;_^J	This command generally indents somehow, depending on what mode you
are in.  For example, in text mode, it is the same as a carriage return,
except that it indents the new line the same number of tabs as the
previous line was intented.
.b1;.i-12;_^K	Kill-line.  *Kill characters to the end of the line.  If the line
is null, i.e.  consists of a single carriage return, then control-K
deletes that carriage return, otherwise, it deletes characters up to
the carriage return, but leaves the carriage return alone.  In addition,
control-K puts the killed text in the kill buffer so it can be
retrieved.  If the previous command was a control-W or a control-K, then
control-K adds the new killed data to the end of the kill buffer,
otherwise, it empties out the kill buffer first.  See the description of
the kill buffer for more information.
.b1;.i-12;_^L	Refresh.  Clear the screen and redisplay the screen.  If it is given
an argument (see Control-U) then it ^&sets the screen size\& to
that value.  Thus _^u10_^L sets the screen size to ten lines and
redisplays the screen.  The buffer window will be shifted so that the
cursor is near the top of the screen if you have the "center new
screens" variable set to true (1).  If i is set to false (0), which is
the default, then ^&FINE\& simply redraws the screen ^&exactly\& as it
was.  This is useful when your screen gets messed up because of a .send
or something.
.b1;.i-12;_^M	Return.  Insert a carriage return, i.e., it self-inserts.
.b1;.i-12;_^N	Dow*n-line.  Move the cursor down one line.
In other words, this moves the cursor to the *Next line.
.b1;.i-12;_^O	Open.  Insert a carriage return and back up over it.  It is the same
as CarriageReturn Control-B.  Mnemonically this *Opens some space in
the file.
.b1;.i-12;_^P	U*p-line.  Move the cursor u*P one line.
.b1;.i-12;_^Q	Quote.  *Quote the next character.  For example, to insert a
control-n into the buffer, you must precede the control-n by a
control-q so that it does not cause the editor to move up one line.
To get a control-q through to CMU computers, you must
type two of them!  This is due to a monitor bug.
.b1;.i-12;_^R	Reverse-search.  Do a *Reverse search in the buffer.  It starts at
the cursor and looks backwards for the searched-for string.  If the
string is not found, the current position in the buffer is unchanged,
otherwise, the cursor is placed at the beginning of the located string.
After typing the command, the system prompts at bottom of the screen,
and waits for the user to type the string to be located.  Type the
string, ending with an _<escape_> character.  If no string is typed, the
last searched-for string will be used.
.b1;.i-12;_^S	*Search.  This works the same as control-r, except that the
search is performed forward from the cursor's position, the prompt is
different, and the position of the cursor after a successful search is
at the ^&end\& of the located string.  Note that the search command does
not distinguish between capital and small letters.
.b1;.i-12;_^T	*Twiddle.  Exchange (transpose) the two characters immediately
preceding the cursor.  Useful for quickly fixing many typos.
.b1;.i-12;_^U	*Use-argument.  Give an argument to a command.  In general, giving
an argument to a command causes it to perform that command the argument
number of times.  There are two formats for control-u.  The first is
typing control-u followed by a number followed by the command to get
the argument.  This causes the command to be invoked with the specified
argument.  If no number is specified, i.e.  control-u command is typed,
the argument defaults to four.  If a number (N) of control-u's are
typed, and then a command, the argument 4**n is given to that command.
Thus _^u_^u_^d deletes sixteen characters in the forward direction and
_^u_^u_^u_^d would delete 64 characters.  Some commands use ther
argument as something aside from the number of times to perform the
operation, for instance the justify paragraph command uses its argument
to allow you to tell it what width the paragraph should be justified
to.
.b1;.i-12;_^V	Advance.  Move the cursor down to the middle of the
next screen. From the french, *Va.  Its reverse is _$V, see below.
.b1;.i-12;_^W	*Wipe.  Delete text between the cursor and the mark position.  It
is a good idea to use _^x_^x first to make sure you know what you are
killing.  Control-w command empties out the kill buffer and puts the
just-killed text in the kill buffer.  Mnemonically, this stands for
*Wipe to mark.  This command clears the mark position.
.b1;.i-12;_^X	E*xternal prefix.  See below.  Yet another prefix character.
.b1;.i-12;_^Y	*Yank-buffer.  Bring back the kill buffer, and insert it before
the cursor.  It does not modify the kill buffer at all.  It *Yanks the
text back from the kill buffer.  This command can be used both for
moving text around and for recovering from accidentally deleting a
large section of text.
.b1;.i-12;_^Z	Glitch screen down a line.  This command moves the screen down one
line (N lines if given an argument N) and redraws the screen cleverly.
.b1;.i-12;_^_^	Invert case.  This command inverts the case of an alphabetic
character, then moves forward one character.  The character which is
case reversed is the one under the cursor.
.b1;.i-12;_^@	Mark.  Set the mark position to be the current position.  If given
an argument of exactly four (_^U_^@) then it ^&clears\& the mark,
which is useful for preventing accidents when _^W is typed by mistake.
.b1;.i-12;_^]	Macro parameter substitution.  This is followed by one of the
following, and is interpreted by the ^&reader\& (not the command
dispatcher) to mean one of the following.
.list
.le;"0"..."7": Substitute macro parameter N for this string.
.le;"r": Pop an I/O level.  This is put automatically at the end of ^&every\&
macro parameter automatically, and thus no user should ever see one or
need to type one.  It is included here for completeness.
.le;":": This is a colon. It tells the editor that the value of the string
.le;"_^]:" is simply a "_^]".  This is how these things are quoted.  The
reason that this different quoting convnentin is used for these
characters is that I didn't want to use _^Q due to the large number of
them that would have to be typed to insert a real _^Q into the buffer
(it would probably have been eight!).  Thus to send a real "_^]" to
^&FINE\& you would type "_^]:".
.end list
It is unfortunately important to understand the difference between the
command dispatcher and the character reader.  The command dispatcher is
the routine which reads a command from the input device and invokes the
proper function bound to that key.  As such, it of course is only
invoked when ^&FINE\& is about to read a command.  However, this is
not at all an acceptable restriction on where macro parameters may be
used, since it is not hard to generate cases where one would wish to
search for the string passed in as a macro parameter, for example.
Thus the character reader comes in.  It is the actual routine that
chooses which device (macro, macro parameter, file or the terminal) the
next input character should come from.  It is invoked by ^&everyone\&
who needs an input character, (such as when the search routine needs a
character) and so it is this routine that handles the macro parameter
substitution.
.b1;.i-12;ESC	Word-mode prefix.  (ESC is the ESCAPE or ALTMODE key.)  See
below. More prefixes.
.lm-12
.page
.hl 2 Control-X prefix commands

.lm+12
.i-12;_^X_^B	List *Buffers.  This command lists all the buffers that you
have active in ^&FINE\&.  It does not count buffers lying around from
previous editing sessions in _.FIN files.
.b1;.i-12;_^X_^C	*Call.  Leave the editor.  It simply calls the monitor, it does
not write out the buffer to the file.
.b1;.i-12;_^X_^E	*Exit+Run.  This does a _^X_^S followed by running COMPIL at an
offset of 1, causing it to perform the last compil-class operation over
again.  This is _^X_^&External command.  When called from RDMAIL or
POST, this writes the file out and returns to the caller.  It also
writes the buffer back to the _.FIN file.  This command only works on
TOPS-10 systems.
.b1;.i-12;_^X_^F	Exit (*Finish).  This does the same as a _^X_^S followed by a
_^X_^C.  In other words, it is the same as ex_$_$ in TECO or "e" in SOS.
When called from RDMAIL or POST (TOPS-10 only), it writes the file out
and returns to the caller.  It also writes the buffer back to the _.FIN
file.
.b1;.i-12;_^X_^G	Escape.  This command is illegal, and is part of the notion that
control-*g gets you "out" of whatever mode you are in.
.b1;.i-12;_^X_^I	*Insert-file.  This command is used to insert a file at the
current location in the buffer.  The text previously in the buffer is
not damanged, the file is read in at the current location and the
location is left at then end of the inserted file.  The file name
associated with the buffer is not changed.
.b1;.i-12;_^X_^L	*Load Key.  This command is used to load a key with a macro.  It
prompts for the name of a macro (a letter) and then a command.  From
that point on, when you type that command, the specified macro will be
run.
.b1;.i-12;_^X_^O	*Old Buffer.  This command is used to use a buffer that exists
from a previous session, such as a buffer that was written out before a
system crash.  This command writes the current buffer out unless the
buffer name being switched to is the same as you are in now, in which
case you just get the one from the disk.  Thus it can be used to get the
old version of the current buffer safely.  See the buffer documentation
for more details.
.b1;.i-12;_^X_^R	*Read-file.  This prompts for a file name, and *Reads it in.
If no filename is given, the last one given is used again.  Note that
filenames are delimited by either a carriage-return or an escape.  It is
on when you enter the editor.  See _$S for further details (Meta-S).
.b1;.i-12;_^X_^S	*Save.  This command writes the contents of the buffer back to
the file they came from.  It differs from _^X_^W_<carriage return_> in that
_^X_^W clears out the ppn and device fields back to the default, while
_^X_^S uses the values from the _^X_^R done to this buffer, if one ^&was\&
done.  If no read was done into this buffer, then the defaults for _^X_^S
are the same as for _^X_^W_<carriage return_>.
.b1;.i-12;_^X_^T	*Take file.  This command is used to tell ^&FINE\& to read a
file as if it were typed directly to ^&FINE\&, i.e.  process a wholle of ^&FINE\& commands.  Currently _<cr_>'s, _<lf_>'s, and NULL's (_^@)
are all ^&ignored\& when found in such a file.  To actually insert
them, a convention is used.  "_\m" provides a carriage return, "_\j"
provides a line feed, "_\@" provides a NULL and "_\_\" provides a
back-slash(\).  This enables readable command files to be typed in,
since they can be formatted pleasingly.
.b1;.i-12;_^X_^V	*Visit file.  This is used to simplify using multiple buffers in
^&FINE\&.  When you want to edit a different file, you use _^X_^V instead of
_^X_^R.  What this does is, when given the file "foo.bar", checks to see
if there is a buffer named "foo" first.  If there is, we just switch to
it, otherwise, we create the buffer "foo" and then read foo.bar into
it.  We ^&then\& switch to the buffer foo.  Using this command enables
you to edit several files at the same time without losing your place in
the files you aren't ^&actively\& editing at a particular time.  When
you switch back to a buffer that you were using, ^&FINE\& restores the
cursor to the same point in the file that it was when you were last
editing that buffer, and furthermore even aligns the screen in the same
manner (the line containing the cursor should be on the same physical
line on the screen).
.b1;.i-12;_^X_^W	*Write.  This prompts for a file name, and *Writes out the
current buffer to the file.  The same file name rules are used as for
_^X_^R.  Note that the version of the file that is about to be bashed is
renamed to have a .BAK extension and a new file is created each time.
The old .BAK file is deleted.  This means that the .BAK file has the
second most recent version of the file.  If you type only a partial file
specification ^&FINE\& will get the missing parts from the previous
file name.  A corollary of this is that typing a carriage return uses
the last file name again.  Note that the writing of .BAK files occurs in
^&all\& commands that write out the buffer to a file.  Furthermore, in
all of these commands, files protected _<2xx_> or greater are simply
overwritten rather than having .BAK files created.
.b1;.i-12;_^X_^X	*Exchange-mark.  Exchange the position of the current location
and the mark's location.
.b1;.i-12;_^X_^Z	Glitch bar up.  This command glitches the window-separator bar up
one line.  The bar that it uses is the one at the ^&bottom\& of the
window in which the command is issued.  It prints "error" if the command
is issued while in the bottom window.
.b1;.i-12;_^X2	Split window.  This command is used to split the current window in
half.  It leaves you in the bottom half.  It defaults to split the window
in ^&two\& equal parts, but if it is given an argument, it is interpreted
as the number of lines to be allocated to the top window.
.b1;.i-12;_^Xb	Change *Buffer.  This command is used to change to a different
buffer.  It prompts for a buffer name.  If the buffer was not created by
this run of ^&FINE\&, the buffer is emptied before it is entered, so
you do not have to worry about getting garbage from earlier editing
sessions.
.b1;.i-12;_^Xc	*Create window.  This command breaks the current window into two
windows, and leaves you in the lower one.  The place where the window is
broken is whereever the cursor is at the time that the command is
typed.
.b1;.i-12;_^Xd	*Delete window.  This command deletes the window containing the
cursor.  The screen space is given to the window above the window being
deleted.  If you are in the topmost window the space is given to the
window immediately below it.
.b1;.i-12;_^Xl	*Load Key(2).  This command is used for moving the definition of
a key to another key.  It prompts for the old key, whose function is to
be moved to the new key (prompted for next).  As usual, _^X and _<esc_>
prefix commands are also valid when specifying which key to move from
or to.  ^&NB.  characters such as "a" or "b" are marked as
"self-inserting", not as "inserting an a".  Thus this can not be used to
exchange the thing to be inserted by two keys, since both will remain
marked as "self-inserting" and will thus still insert themselves
into the buffer when typed\&.
.b1;.i-12;_^Xm	*Macro.  This is used for defining *Macros.  It is described
in detail below in the Macro section.
.b1;.i-12;_^Xn	Move dow*n one window.  This command moves the cursor to the
*next lower window on the screen.  If there is none, it complains.
.b1;.i-12;_^Xp	Move u*p one window.  This command moves the cursor to the next
higher window on the screen.  Again, if there is none, it will complain.
.b1;.i-12;_^Xz	Glitch bar down.  This command glitches the window-separator bar
down one line.  The bar that it uses is the one at the ^&bottom\& of the
window in which the command is issued.  It prints "error" if the command
is issued in the bottom window.
.b1;.i-12;_^X]	This command is used for prompting for a macro parameter.  It is
followed by a single digit in the range from 0 to 7 and immediately
thereafter a string used for prompting, terminated by an _<esc_>
character. For example,  to ask for parameter 0 with a prompt of
"apples", you would do
.b2;	^&_^X]0Apples_$\&
.lm-12

.page
.hl 2 META commands
These commands are prefixed by an altmode or escape (ESC).  On keyboards
with a meta key, you type meta-x instead of ESC followed by x.  The meta
(ESC) key is abbreviated "_$".  Here they are:
.lm+12
.b1;.i-12;_$A	*Ask user. This command asks the user whether (s)he wishes to
continue or not with the current macro.  An answer of "y", "Y" or "#"
means yes, all others mean no.  _^G as usual aborts the entire macro
run.  The way this is done is that when called from a macro, it reads
one character from the physical tty.  If the answer is ^&yes\&, then it
simply continues, otherwise it forces an early return from the macro
containing the _$A command.  Thus macro writers can use it to provide
querying of the user as to whether or not this particular case should
be processed or not by the macro.
.b1;.i-12;_$B	*Back-word.  Move cursor *Backwards over one word.
.b1;.i-12;_$C	*Call macro.  This command is followed by a one character lower-case
macro name which is to be called.  Thus to call macro buffer "d", you
would type "_<esc_>cd".
.b1;.i-12;_$D	*Delete-word.  *Delete forward over one word.
.b1;.i-12;_$E	Call *Editor.  This macro causes the editor to call itself
recursively.  Use the _$P command to return to the caller.  This is most
useful when used in a macro, where it allows the macro to suspend
execution and allow the user go and type stuff.
.b1;.i-12;_$F	Forward-word.  Move the cursor *Forward over one word.
.b1;.i-12;_$H	Rubout-word.  This is also the same as _$RUBOUT, below.  It deletes
backwards over a word.
.b1;.i-12;_$I	*Tabify line.  This command adds a tab to the space at
the start of the line on which it is typed.  It is not really a tab,
but the proper number of spaces and/or tabs that represents indentation
size. It does re-optimization of converting spaces into tabs.
.b1;.i-12;_$J	*Justify-paragaph.  This command justifies the paragraph containing
the cursor.  Current paragraph breaks are _^L (formfeeds), _^M_^M (two
carriage returns in a row), _^M_^I (a line starting with a tab), the top
of the file and the end of file.  This command now understands about
SCRIBE and RUNOFF commands, too.  It uses the variable "Margin for
Justification" as the default width of a paragraph, but this can be
overridden by giving _$J an explicit argument with _^U.  See _$S to se how
to change the values of the variable "Margin for Justification".
.b1;.i-12;_$K	*Kill blankspace.  This commands kills all blanks and tabs from
the current cursor position to the next non-blank character.
.b1;.i-12;_$L	*Load a macro buffer.  This command loads the entire buffer into
the macro name that you provide when _$L prompts.  It is useful for
debugging macros.  See the multiple buffer section to find out how to
use more than one buffer (and the commands _^X_^B and _^Xb).
.b1;.i-12;_$M	*Mode change.  This command prompts for a mode name.  The mode of
the editor changes, and in general a different set of commands is now
valid.  Most commands will be valid in all modes, but this may not be
true all the time.  See the mode section of this manual for more
information on modes.
.b1;.i-12;_$O	Toggle *Output.  This command toggles a bit that tells ^&FINE\&
if it should print anything or not.  If this is typed, ^&FINE\& will
stop doing redisplays and all prompts will be thrown away.  This is
useful for ^&very\& slow terminals and for use in FINE.INI files where
you do not want to see what ^&FINE\& is doing.
.b1;.i-12;_$P	Return to FINE (From the MIT-ITS DDT *_$] command).  If a macro
has paused after having encountered an _$e command in the body of the
macro, then when the user types this command, execution of the macro
resumes.  This command is also put at the end of a ^&FINE\& command
file to cause a return to the main command reader.
.b1;.i-12;_$Q	*Query-replace.  This mode is described later in this document.
.b1;.i-12;_$R	*Replace.  This mode asks for an old string and a new string and
then replaces all occurrences of the old string with the new string,
starting at the cursor and going to the end of the file.  Each string is
delimited with by _<escape_>.
.b1;.i-12;_$S	*Set-symbol.  This prompts and sets ^&FINE\& internal variables.
See the section on setting symbols for more information.
.b1;.i-12;_$U	*Untabify line. This removes the equivalent of the
indentation level number of spaces from the beginning of a line, if
they were present.  It also re-optimizes the spaces into tabs.
.b1;.i-12;_$V	Retreat.  This command moves the cursor up to the screenful of text
immediately preceding the screenful currently being displayed.  The
cursor is put at the top of the screen.  Its inverse is _^&V, described
above.
.b1;.i-12;_$W	*Wipe-search.  This command is "kill to start of search string".
It sets the mark at the current position, asks for a string and
searches for it.  If it finds the string, it kills from the just set
mark to the start of the found string.  If it is given an argument of
exactly 4, it does the search in a reverse direction, and kills to the
begining of the located string.  This is easily typed as _^U_$W (using the
_^U default).  Yeah, it's a crock.
.b1;.i-12;_$Z	Glitch screen up a line (N with an argument).  Inverse of _^Z.
.b1;.i-12;_$_^H	Rubout-word.  This is the same as _$RUBOUT, below.
.b1;.i-12;_$_^I	This command *indents the region from point to mark by
one indentation distance.
.b1;.i-12;_$_^R	This command is incremental *reverse search.  See incremental
search section for more information.
.b1;.i-12;_$_^S	This command is incremental forward *search.  See the
incremental search section for more information.
.b1;.i-12;_$_^U	This command *un-indents the region from point to mark by one
indentation distance.
.b1;.i-12;_$_^W	Load kill buffer.  This command loads the region between the point
and the mark into the kill buffer, without ever killing it.  It provides
a smoother redisplay than *_W]_^Y, unless you type very fast or the
system is slow.
.b1;.i-12;_$_^	Invert case of word.  (Type meta-_^)
.b1;.i-12;_$RUBOUT	Rubout-word.  Delete backward from the cursor's current
position one word.  By now it should be apparent that there are a lot of
ways to type meta-rubout.  It is a very popular command.
.b1;.i-12;_$_<	Top-of-file.  This command moves the cursor to the beginning of the
file.
.b1;.i-12;_$_>	End-of-file.  This command moves the cursor to the end of the file.
.b1;.i-12;_$,	Top-of-page.  This command moves the cursor to the top of the
screen.  Mnemonically this is meta-unshift-_<.
.b1;.i-12;_$.	End-of-page.  This command moves the cursor to the bottom of the
screen.  Mnemonically this is meta-unshift-_>.
.b1;.i-12;_${	Top-SOS-Page.  This command moves you to the top of the current
SOS-style page.
.b1;.i-12;_$}	Bottom-SOS-Page.  This command moves you to the bottom of the
current SOS-style page.
.b1;.i-12;_$[	Up-paragraph.	This command moves the cursor up one paragraph.
.b1;.i-12;_$]	Down-paragraph.  This command moves the cursor down one paragraph.
.b1;.i-12;_$(	Find matching left parenthesis.  This command moves you to the left
parenthesis that matches the right parenthesis under the cursor.
.b1;.i-12;_$)	Find matching right parenthesis.  This command moves you to the
right parenthesis matching the left parenthesis under the cursor.
.b1;.i-12;_$!	See you at the top.  This command is used to move the current
line to the top of the screen.
.b1;.i-12;_$_^_^	Invert case from point to mark.  (Type meta-control-_^)
.b1;.i-12;_$?	On-line documentation.  Try it, you'll like it.  It lists out a short
summary of all of the ^&FINE\& commands.
.lm-12

.hl 1 Random Details
There are two other things that are mentioned above that are very
useful and important for editing.  The first is the ^&mark\&, which is just
a saved cursor position.  You can set the mark to the current position
by using the _^@ command, you can position to the mark with the _^X_^X
command, and you can delete all the text between the cursor and the
mark with the _^W command.  You can load the kill buffer with text
without actually killing the text by using the _$_^W command instead of
the _^W command.
.s1
The ^&kill buffer\& is very useful for moving text around.  When a _^W,
_$_^W or a sequence of _^K commands is given in a row, then the text that
has been deleted is put in a special buffer called the kill buffer.
This buffer can be recalled with the _^Y command.  When a _^W, _$_^W or a
series of _^K commands are given, the old contents of the kill buffer
are lost.  Thus to move a section of text from one place to another,
simply put the mark at one end of the text, move the cursor to the
other end, do a _^X_^X command to make sure that you know exactly what
will be killed, and then do a _^W command.  This kills the text.  Then
simply move to the new place, and type _^Y to bring back the deleted
text.  Note that giving _^K an argument is the same as typing a series of
_^K commands, and will thus cause all of the text deleted by the series
to be put into the kill buffer, as is usually desired. ^&At no time
during the moving should you do any _^K or _^W commands, or the contents
of the kill buffer will be lost.  Also, note that the kill buffer is
only big enough to hold 25000 bytes at one time.  An overflow leaves the
contents of the kill buffer undefined.\&  If an overflow occurs, you
will be asked to confirm if you want to kill the text anyway.  Type "y"
or "#" to say yes, other things mean no.
.s1
You can bring back the contents of the kill buffer as many times as you
like.
.s1
Note that the default file name is "delete.me" in the current
working directory, on device dsk.
.s1
In addition, courtesy of Cris Perdue, there is now a way of passing
^&FINE\& an initial file name at startup on CMU machines.  To do this,
do
.s1;	_.r fine -foo.bar
.s1
for example. This causes a _^X_^R command to be issued for the appropriate
file. Furthermore, doing
.s1
	_.r fine ;foo.bar
.s1
causes a visit file (_^X_^V) command to be issued instead of a read file
command (_^X_^R).  The space before the "-" or ";" is optional.
.s1
Lastly, doing
.s1;	_.r fine !foo
.s1
causes fine to use _^X_^O to read in the old buffer of the specified
name.
.s1
.hl 1 File Considerations
Basically, there are two types of files that ^&FINE\& manages on your
directory. These are .BAK files and _.FIN files.  The .BAK files are the
last version of the file you are editing, i.e. if you were editing
foo.pl1, then foo.bak is the last version thereof.  The _.FIN files are
buffers and contain the file that you were editing in that buffer last,
at either the time of the last autosave or the last buffer switch.
.s1
Either of these file may be deleted at any time after you have left the
editor.
.s1
Note also that the only time that your file is written out to the file
that you are editing (and thus the only time that the .BAK file is also
changed) is when you explicitly write out the file, with either _^X_^S,
_^X_^S, _^X_^F or _^X_^E.  Autosave only modifies the _.FIN file.
.s1
.hl 1 Macro facility
There is a cheap macro facility available which is useful for such
things as complex replace operations and such.
.s1
There are 26 macro registers named a, b, c, ...  y, and z.  Each may
contain up to five hundred bytes of ^&FINE\& commands.  Basically, when
meta-c is typed, then the next character is interpreted as the name of
the macro register to execute.  Each macro register can of course call
other ones, too.  To return from a macro register, use the meta-p
command.  A meta-p command is inserted automatically at the end of the
macro buffer when the closing delimeter is seen, so you do not have to
type one when defining a macro.
.s1
To insert text in a macro register, use the _^xm command. _^xm
takes the first character after the m to be the name of the macro
register to use. It stops immediately if this is not in the proper
range. The next character after the name is take to be the delimeter,
and may be any character. The text between the first occurrence of
the delimeter character and the second occurrence thereof is placed
in the macro register. For example, to make a macro that replaces foo with
bar in  the file, we would do:
.s1
	_^xma/_^sfoo_$_^u3_<del_>bar_$p/
.s1
where _<del_> is the delete character. This would define the macro
and put it in macro buffer a. To use it, do _$ca. If you want to
do this a lot, do _^U10000_$ca. The first search that fails will cause
a return to be made from the macro.  Other terminating conditions are
doing any command that moves forward in the buffer while at the end of
the buffer, or doing any command that moves backwards in the buffer
while at the begining of the buffer.
.s1
What actually happens when a macro returns is important to understand
if you are going to use them much.  If the macro _$ca in the above
example does a _^N at the end of the file, then the macro returns
immediately. In addition, the reptition count of the macro call is set
to zero, so that no further calls are made to that macro if it was
called with _^U.  Thus, you can write a macro that deletes the first
character in a line, and use it to do this to all the lines in a file
by typing _^U100000_$ca.  As soon as it hits the end of the file, it will
complete, rather than spinning its wheels at the end of the file.
.s1
If at some point in a macro you desire to stop and let the user type
some ^&FINE\& commands and then continue execution, you should put a meta-e
command in the macro at that point.  When the meta-e is encountered, the
editor will recursively call itself, executing commands from the
terminal as usual.  When the user wants to resume macro execution,
s(he) types meta-p.  Typing ctrl-g pops you out of all macros to the top
level.
.s1
In a similar vein, putting an _$a command in the macro will cause the
macro to pause execution.  If the user types "Y", "y" or "#", _$a will
return normally, otherwise the particular invocation of the macro
containing the _$a will terminate immediately.  Thus query-replace can be
approximated as follows (more powerful things can be done with this
feature, but query-replace is a good example to use anyway.
Query-replace mode is described later in the manual):
.s1
	_^xma/_^sString1_$_$a_^u7_^HString2/
.s1
The above example defines a macro named "a" which searches for a
"String1".  When it is found, it "asks" the user (by waiting) if this is
the right one (the cursor will be positioned after this occurrence of
String1).  If the user answers negatively, the macro is done, otherwise
String1 is rubbed out and String2 is inserted.  Note that if you had
typed _^U99999_$ca to do this macro a large number of times, answering no
to the _$a query would ^&not\& terminate all 99999 of the iterations,
but just the one answered negatively, just as is required to simulate a
query-replace mode.
.s1
.hl 1 Replacement
There are two functions that can be used to make string replacements in
the text.  The first is meta-r, which asks for two strings, and replaces
all occurrences of the first with the second.  However, in general,
people want more control over the changes that are made.  Thus we have
Query-Replace mode (meta-q)!  Query-replace mode is entered by typing
meta-q.  The editor prompts for the string to be searched for and the
string that is to replace it.  It then moves the cursor to after the
first occurrence of the first string, and waits.  There are several
possible responses:
.list
.le;Altmode (_$): Leave Query-replace mode, leaving this occurrence untouched.
.le;Space ( ): Replace this occurrence of the string with string B,
and prompt again at the next occurrence.
.le;Ctrl-G: Same as altmode.
.le;Period (.): Same as space followed by altmode. Replaces the current
occurrence and exits query replace mode.
.le;Exclamation Point (!): Replace this occurrence of the string, and
all further ones without prompting further (as if a meta-r were
given at this point).
.le;Rubout (_<rubout_>): Leave this occurrence of the string ^&utouched\&,
move to the next occurrence and prompt again. ^&This\& is the default, i.e.
what happens if the character typed is not one of the above).
.le;Question mark(?): Gives on-line help.
.le;Anything else is interpreted the same as typing a rubout.
.end list

Thus we have full control over which items are changed on an individual
basis.  Note that when query-replace mode reaches the end of file, it
will tell you (in the prompt area).
.s1
.hl 1 Buffers
There are things called buffers in ^&FINE\&.  A buffer usually holds
the contents of a file, and remembers which file is associated with it.
It also remembers where on the screen that file was displayed, and
similar state.  The idea is for you to be able to edit more than one
file at the same time without losing the state (such as position in the
file) that you have built up while editing the first file.  It is also
convenient for certain modes, such as the dired mode, to be able to get
a scratch area to use for whatever they are trying to do without
bashing your buffer or writing it back out to the file that it came
from.  _^X_^B is used to get a list of all the active buffers, i.e.
buffers that were created since you last entered ^&FINE\&.  _^Xb is used
to get to a new buffer.  Note that buffers are implemented as files with
the name _<buffername_>.fin and are written on your login directory.  A
buffer is written every time that you switch from that buffer to
another one, so that all the buffers except for the one being displayed
at the moment are actually on the disk somewhere.  The current one being
displayed is also written out periodically by the autosave code.  The
default period is every 100 commands.
.s1
It is important to understand the basics of how buffers are
implemented, as when the system crashes, much of your work is quite
likely still around in a usable form.  When you switch from buffer foo
to buffer bar, the current buffer (foo) is writen into FOO.FIN and the
file BAR.FIN is loaded to make buffer bar.  If you hadn't used that
buffer previously in this editing session, the buffer is empty, and no
file is actually read.  The autosave feature writes out the current
buffer to its corresponding _.FIN file periodically (it is described
shortly) so the chances are that when the system crashes, your work is
probably in a
_.FIN file.  Thus all you do to recover is use the _^X_^O command to slurp
that buffer into ^&FINE\&.  The _^X_^O command is just like _^Xb except
that the old buffer is loaded from the _.FIN file even if no buffer by
that name was prevously edited during this run of ^&FINE\&.  Its
primary purpose in life is recovery from system crashes.
.s1
.hl 1 Windows
It is possible to divide up one's screen into any number of windows.
A window is best thought of as a window onto an arbitrary buffer full
of text.  There can be more than one window pointing onto a particular
buffer, and it is not necessary that all of the windows in a particular
screen point onto the same buffer.
.s1
The operations that you can perform on windows are few and simple.  You
can divide the window that contains the cursor into two parts; this
division is performed at the point where the cursor is.  The text in the
window properly above the cursor becomes one window, the text in the
window properly below the cursor becomes another window and the line
where the cursor was becomes the dividing line.  This is what the _^Xc
command is for.
.s1
You can divide the current window up into two parts by telling
^&FINE\& how many lines should go in the first of the two new windows
(the reaminder go to the second, minus one line for the dividing line).
This is what the _^X2 command is for.
.s1
You can delete the window that the cursor is in, by using the _^Xd
command.  The space on the screen is given to the window above the
deleted window.  If there is no such window, the space is given to the
window below the deleted window.
.s1
You can move from one window to another by typing _^Xn to move down one
window, and _^Xp to move up one window.
.s1
The commands _^X_^Z and _^Xz move the separator bar up and down one line,
respectively.  The separator bar used is the one at the bottom of the
window containing the cursor when the command was issued.
.s1
.hl 1 SOS-style page marks
^&FINE\& supports SOS-style page marks, which are _^L characters. The
redisplay treats text between _^L's as if it were all the text that is
in the buffer, i.e.  you can not see text on either side of the _^L's
that surround the section of text that you are editing.  You can move
through these page marks however, in which case the redisplay will
treat the new section that you are in as the "current page" which will
be all that you see.  To insert a _^L in a file, you use the _^Q command.
On CMU-A, B or D this means you type _^Q_^Q_^L.
.s1
.hl 1 AutoSave Feature
When the editor comes up, it has the autosave flag set, and the current
buffer will be dumped to the corresponding _.FIN file every 100
keystrokes.  If you wish to change this frequency, use the _$S command
described in this document.
.s1
To recover after a crash, let us say your buffer name was foo.  Then
you type
.s1;
	_.r fine
.b1;	_^X_^Ofoo			;read in old buffer foo.
.s1
Note that if you do not know what buffer you were in, you can look to
see what _.FIN files are on your login directory.  If you do not use
multiple buffers at all, the buffer name was "main".  If you type _^X_^O
followed immediately by a carriage return, it defaults to the buffer
^&main\&.
.s1
.hl 1 Modes
A mode is basically a special state that ^&FINE\& can be put in to
allow certain commands to know what type of information you are
editing.  For example, in BLISS mode, the line-feed command knows how to
indent BLISS programs.  The default mode is FINI mode, which stands for
^&FINE\& Initial mode.
.s1
There are various modes that ^&FINE\& supports.  A mode is basically a
state that the editor can enter where certain commands are bound to
special procedures which are mode specific.  Some modes are designed to
let you enter text more easily, while others are designed for certain
programming languages.  Basically, entering a new mode rebinds some of
the commands to execute different procedures, thus providing different
functions.  The code for the different modes is no longer in a separate
high segment, but is now linked in with the rest of ^&FINE\& in the
high segment to provide better sharing of the base code of ^&FINE\&.
.s1
.hl 1 Text Mode
There is a mode called text mode which is useful for writing papers.
Basically there are a few new commands and a few differences.  The main
difference is that when you type a space past the indentation column,
it will delete the last word and insert a carriage return and then
re-type the word it just deleted at the start of the new line.
.s1;.lm+12
.i-12;_<Space_>	This command causes a space to be inserted, except when typed
when beyond the indentation column, when it will cause the last word
typed to be saved and deleted, and then a new line to be created and
this word to be put at the start of the new line.
.lm-12
.s1
.hl 1 Dired Mode
Another mode is called dired mode.  It is used to get directory
listings.  Basically, it always enters a buffer named "dired" so that
your current buffer doesn't get damaged.  When you leave dired mode, it
will switch you back to the buffer you called it from.  ^&To leave
Dired mode, switch back to your previous mode, such as text mode, using
the _$m command.\&  The commands are as listed here:
.s1;.lm+12
.i-12;_$M	This command is used to leave dired mode.  You give it
the name of a mode that it should enter.  It restores you to the buffer
you were in before you started the dired, and then switches modes.
.b1;.i-12;_^X_^D	This command prompts for a directory, which must be given in
brackets.  The directory listing is inserted in the dired buffer.
.b1;.i-12;_^X_^R	This command does the same as _^X_^D.
.lm-12

.hl 1 BLISS Mode
This mode is used to type in BLISS programs.  When typing in code, the
line-feed command is used for getting a new line and indenting it.
There are also useful commands for other things.  Here is a list of what
is implemented so far.
.lm+12
.b1;.i-12;_^J	The line-feed command.  This is does a carriage return and then it
indents the proper number of spaces and tabs to get to where it thinks
you want to be.  Hopefully it will not be wrong too often.
.b1;.i-12;_$1	This is the comment enterer.  It gets you to a reasonable place to
put the comment, and prints the comment prompt, too.  This place can be
changed with the _$S command.
.lm-12

.hl 1 Pascal Mode
This mode is used to type in Pascal programs.  When typing in code, the
line-feed command is used for getting a new line and indenting it.
There are also useful commands for other things.  Here is a list of what
is implemented so far.  Thanks go to James Gosling for implementing this
mode.
.lm+12
.b1;.i-12;_^J	The line-feed command.  This is does a carriage return and then it
indents the proper number of spaces and tabs to get to where it thinks
you want to be.
.b1;.i-12;_${	This is used to begin a comment.  It does the right thing in trying
to put you in a reasonable column for a comment.  If you do not like
where this column is, you can change it with the _$s command.
.b1;.i-12;_$}	This is used to end a comment.  It puts in a space, a "}" and then
does a linefeed command.
.b1;.i-12;:	This character is typed at the end of a label.  It will shift the
label to the right margin.
.lm-12

.hl 1 Setting Parameters
The _$S (meta-s) command is used to set the values of various parameters
to ^&FINE\&.  These parameters all have integral values (plus, minus and 0
are all acceptable).  If the parameter is a boolean variable, the
convention is like in BLISS, specifically 1 is true and 0 is false.
.s1
You will notice that these names are quite long.  Fortunately, typing _$
(_<escape_>) or carriage return at any time will run the command
completion code, so all you have to type is a unique prefix.  After the
name of the variable to be set is typed and accepted, ^&FINE\& will
prompt for the value, which must be an integer.
.s1
You can type "?" to the symbol name prompt and get a list of all the
possible variables to set.
.s1
The ones that you can set, with their names, are:
.lm+12
.b1;.i-12;"Repetition count for _^U":	 This is used to set the value that _^U uses
for a multiplier as a default.  It starts out as 4.
.b1;.i-12;"Center new screens":	 This is a boolean (1 for true, 0 for false)
variable which tells whether _^L will center the new screen or not.
.b1;.i-12;"Autosave frequency":	 This is a variable which tells how often
autosaving will be done.  If it is set to 0, none will be performed.
.b1;.i-12;"Indentation for language modes":	 This tells for BLISS and Pascal
modes, how far each newly-indented block is to be indented from the
previous block, in units of spaces.
.b1;.i-12;"Margin for justification":	 The right margin for the justify command.
.b1;.i-12;"Comment position":	 For the language modes, this tells in which column
you like to see your comments.
.b1;.i-12;"TTY type":	 The ^&FINE\& internal variable where the tty type
is stored.  The main reason this is here is that people who run
^&FINE\& on systems that can not tell what the terminal type is, but
who always use the same one, can tell ^&FINE\& in their init file what
their terminal type really is.
.lm-12

.hl 1 Multiple Modes
Except for FINI mode, switching to a particular mode leaves the old
command bindings in effect, when possible.  For instance, if you were in
Pascal mode and switched to Bliss mode, the binding for _${ would be
left as it was in Pascal mode, because Bliss mode does not respecify
this command.  Furthermore, for some commands, such as "_<space_>", it is
possible that ^&both\& bindings will remain in effect.  With "_<space_>",
the FINI mode command simply inserts a space, while the TEXT mode
command checks for line overflow, and ^&and then executes the
functions previously bound to "_<space_>".\&  If some of these left-overs
are actually irritating, switching to FINI mode will clear out this
table.
.s1
If too many of these patches are made (by switching modes too often),
you will get a message saying "CONS Space Overflow, you are now in FINI
mode".  You will then have to switch back to whatever mode you were in
by hand.  This should occur very rarely.
.s1
.hl 1 Rebinding Commands
There are two commands for rebinding what a particular key (e.g.  "_$a",
"_^Xd" or just plain old "f") does.  If you want the key to do what some
other key now does, use the _^XL command, which will prompt for the old
key (the one currently performing the function) and then a new key
(which will be redefined to ^&also\& perform this function.  Note the
^&also\&:  the original key's definition is not changed.
.s1
If however the function is performed by a macro, then you use the _^X_^L
command, which instead of asking for a key providing the function, asks
for the name of a macro instead.  It then asks for a key to have perform
this macro.  ^&Do\& not bind a macro to a key that is contained in that
macro, or you will find out what recursion is not all about).  You of
course can bind a key using _^XL to its own definition, this has no
effect whatsoever.
.s1
Switching to FINI mode resets all the command bindings.
.s1
.hl 1 Macro Parameters
There now is a way to pass parameters to a macro.  You invoke the macro
(either with _$c or by binding a key to it) and then pass it 0-8
strings, terminated by _$ (escape) characters.  In the macro, do
_^X]_<n_>_<string_>_<esc_>, where _<n_> is a number between 0-7 causes the
argument to be read and bound to a variable (there is a set of these
variables for each invocation of a macro or "take" file, so there is no
need to worry about "name"conflicts among various macros).  _<string_> is
a prompt and the _<esc_> is how the prompt is terminated.  Then in that
same macro, _^]_<n_> is substituted by the actual parameter.  Parameters to
one macro can be passed on as other parameters to macros that the first
one calls, too.
.s1
^&However, there is a very tricky part.\&  These parameter
substiutions are always enabled.  Thus it is hard to type the symbols
that are replaced by a parameter, because ^&FINE\& tries to do the
substitution when you type it!  In particular, it is very hard to type
a _^] for this reason.  Thus aside from _^]_<n_> having a meaning, _^]: is
defined to be just a bare _^].  Thus if you were typing in a macro
definition, you would type (to get a macro that simply inserts its
single parameter)
.s1;	_^xma/_^x]0foo_$_^]:0/
.s1
This macro prompts with "foo" in the prompt line, and then takes its
argument (terminated by a escape) and performs it.  This ^&exact\& same
line, if it were to appear in a FINE.INI file, would initialize the
macro a with that definition, so it is wise to note that the quoting is
needed there too, since it is possible to pass parameters to a
_^X_^T-loaded file via the same mechanism (indeed, these files are
treated just as macros only the bit source is a file instead of the
macro definition you just typed).  Note that the ":" must actually
appear in the file following the _^], otherwise the parameter
substitution will be performed erroneously when the FINE.INI file is
being ^&read\&.

.hl 1 Incremental Searching
Incremental searching is normally enabled on keys _$_^S and _$_^R.  These
two commands provide a simpler search mode than the regular one.  They
can be moved to more useful keys (_^S and _^R for example) by your
FINE.INI file if you like them.
.s1
The way that incremental search works is as follows.  When you type _$_^S
to ^&FINE\& the string "I-Search" appears in the prompt line.  The
cursor however remains where it was in the text, and as you type to
^&FINE\&, it incrementally does the search, thus if you were searching
for "abc", as you type that string, ^&FINE\& would search for "a",
"ab" and finally "abc", so that you can see exactly where you are after
each character is typed.  If you type _^S while in incremental search
mode, it searches for the next occurrence of the string that has been
typed so far.  As usual _^Q is used for quoting characters in the search
string.
.s1
When the search fails in incremental search mode, you do not leave the
search mode, but instead you are notified by a change in the status
line that the search has failed, and you enter a mode called failing
I-Search mode, in which you can type rubouts to the search string to
correct it!  Thus if you meant  to search for "apl" and you typed
"apx", then if there was no "apx", you would enter failing I-Search
mode.  If you hit rubout followed by "l", you would then search for
"apl", which is what you wanted in the first place.
.s1
Note that while in I-Search mode, regular ^&FINE\& commands are
available!  However, to allow the typing of a single _<esc_> to terminate
the search, the meta prefix character is rebound to "_^\" while you are
in incremental search mode.
.s1
.hl 1 Continuing FINE
Often you are forcibly detached from your job, due to a front-end crash
or some other system malfunction that resets some or all of the
terminal characteristics.  The proper way to re-enter ^&FINE\& is to
type
.s1;	_.tty concept		;or whatever tty you are on.
.b1;	_.ree			;you are now back in Fine.
.b1;	_^L			;to Fine, to redraw the screen.
.s1
Some or all of this is not necessary, depending upon the reason for the
detaching, but if you do all of these commands, you should get ^&FINE\&
back into a reasonable state.
    =>s