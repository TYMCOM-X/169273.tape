;F@n doesn't work (and never did); FND gets set and fakes it out
;  need to come out of ASKITR with FND turned off

;F@n is signalled by ITR and no VAL - if this holds, do SETRNG

TITLE	BITVIR - BIT EDITOR
SUBTTL	A CHRISTOPHER HALL FECIT

	TWOSEG

CUSTVR==0		;DEC DEVELOPMENT
HALVER==3		;MAJOR VERSION
HALMVR==2		;MINOR VERSION
HALEVR==37		;EDIT NUMBER

	LOC 137
	BYTE	(3)CUSTVR (9)HALVER (6)HALMVR (18)HALEVR
	RELOC

;AC ASSIGNMENTS

A=1
B=2
C=3
D=4
E=5
F=6		;FOR FLAGS
J=12
FM=13		;NUMBER OF FRAME BEING REFERENCED
WD=14		;WORD NUMBER (SET UP BY HDLCMD)
CH=15		;FOR CHARACTERS
PT=16		;IOWD PTR INTO BUFFER
P=17		;PUSH DOWN STACK

;CHANNEL ASSIGNMENTS

IO==7
IN==10
OU==11
LPT==12

;FLAGS

STT==1		;BEEN THROUGH NEWFIL BEFORE (NEWFIL)
FND==2		;FOUND A NUMBER (STRIN & VALIN)
SPC==4		;SAVE INPUT IN SPEC BUFFER (STRIN & VALIN)
PPN==10		;OUTPUT PPN HAS BEEN SEEN (GETFIL)
OUF==20 	;USER GAVE AN OUTPUT FILE (GETFIL)
VAL==40 	;SAVED SOME PART OF A VALUE (ASKME)
ITR==100	;FOUND AN ITERATION VALUE (ASKME)
COM==200	;SEEN A COMMA (HELPS OUT FIND) (ASKME)
MNS==400	;GOT A NEGATIVE RELATIVE RANGE (ASKME)
WRT==1000	;WRITE FILE; NO EXIT (WRITE)
SUB==2000	;MAKE A SUBSTITUTION (SUBST)
LIS==4000	;LPT LISTING REQUESTED (LIST)
OFT==10000	;GIVE SPECIAL FORMAT WITH OUTPUT (OUTFMT)
RTP==20000	;PRINT ONE WORD AND RETURN (CHANGE)
LSI==40000	;LAST BLOCK FOR AN INSERT OR DELETE
DLT==100000	;DELETE HAS BEEN DONE (DELETE)
DL1==200000	;DELETE IS BEING DONE (DELETE)
COP==400000	;A COPY OF THE INPUT FILE WAS MADE (COPY)

;FLAGS IN LH OF F

R10==1		;OUTPUT WORD NUMBERS IN DECIMAL (VALIN ET AL)
RDO==2		;ACCESS IS READ ONLY

ALF==FND!PPN!OUF!VAL!ITR!COM!MNS!OFT!SPC!COP

;FLAGS FOR SPECIAL COMMANDS, IN LH OF COMMAND WORD

FINDER==40000
DELTER==100000
PRNTER==200000
SPCFLG==400000

	OPDEF	PJRST[JRST]

	RELOC	400000

NEWFIL:	SKIPA	P,[IOWD 20,STACK];SET UP STACK POINTER
	JRST	CCLSET		;HERE FROM NON-VIRTUAL BITED - READ FILE SPECS
	RESET			;CHUCK ALL BUFFERS AND PARTIAL FILES
	TRON	F,STT		;BEEN HERE BEFORE?
	PUSHJ	P,GETSCN	;NO - SET UP FILE GIVEN IN RUN, IF ANY

	TRZ	F,ALF		;CLEAR ALL THE CLEARABLE FLAGS
	SETZM	FILPTR		;CLEAR PRESENT LOCATION PTR
	SETZM	RELFIL		;CLEAR RELOCATION
	MOVSI	A,'DSK'		;GET DEFAULT DEVICE NAME
	MOVEM	A,INBLK+1	;RESTORE TO INPUT OPEN
	MOVEM	A,IOBLK+1	;  AND TO OUTPUT OPEN
	SETZM	FRMNUM		;PREPARE FOR BLT
	MOVE	A,[XWD FRMNUM,FRMNUM+1]
	BLT	A,FILSIZ	;CLEAR ALL FILE SPECS
	MOVEI	A,5		;RESET NUMBER OF ARGS TO EXTENDED LOOKUP
	MOVEM	A,INFIL
NOFILE: MOVE	D,[POINT 7,SPECS];GET POINTER TO SPEC BUFFER
	TRO	F,SPC		;SET FLAG TO SAVE SPECS
	PUSHJ	P,GETFIL	;GET FILE SPECS
	SKIPN	INFIL+2		;SOME FILE GIVEN?
	JRST	NOFILE		;NO - ASK AGAIN
	SETZ	A,		;GET A NULL
	IDPB	A,D		;SAVE AS END OF SPECS
NEWFL1:	OPEN	IN,INBLK	;FIND THE INPUT FILE
	  HALT
	LOOKUP	IN,INFIL	;DO EXTENDED LOOKUP
	  JRST	LUKERR
	TLNE	F,RDO		;READ ONLY?
	JRST	[MOVE  A,INFIL+1;YES - SET UP INPUT PPN
		 MOVEM A,IOFIL+3
		 JRST  NEWFL2]	;AND DO NOT COPY
	TRZE	F,OUF!PPN	;OUTPUT FILE SAME AS INPUT FILE?
	PUSHJ	P,COPY		;NO - CREATE OUTPUT FILE
	RELEAS	IN,		;GET RID OF INPUT FILE
	DMOVE	A,IOFIL 	;COPY FILE SPECS FOR ENTER
	DMOVEM	A,IOFIL1
	DMOVE	A,IOFIL+2	;..
	DMOVEM	A,IOFIL1+2
NEWFL2:	OPEN	IO,IOBLK	;NOW SET UP FILE FOR EDITING
	  HALT
	LOOKUP	IO,IOFIL	;WORK ON THE OUTPUT FILE
	  JRST	LUKERR		;ASSUME HE MADE A MISTAKE
	TLNE	F,RDO		;READ ONLY?
	JRST	READHI		;YES - DON'T SET FOR OUTPUT
	ENTER	IO,IOFIL1
	  JRST	ENTERR		;ASSUME HE MADE ANOTHER MISTAKE

;NOW READ IN HIGHEST BLOCK OF FILE

READHI:	MOVE	A,FILSIZ	;GET FILE SIZE
	JFFO    A,.+1           ;SEE HOW MANY DIGITS ARE NEEDED
	MOVEI   A,^D36
	SUB     A,B
	IDIVI   A,3
	AOJ     A,
	MOVEM	A,NUMSIZ	;SAVE WORD NUMBER SIZE

	MOVE	A,FILSIZ	;GET FILE SIZE AGAIN
	IDIVI	A,200		;GET BLOCK # IN A, SIZE IN B
	MOVNS	B		;NEGATE IT
	SKIPE	B		;IF FILE ENDS ON BOUND'Y, USE -200
	HRLM	B,CCWL		;SET UP IN CHANNEL COMMAND
	MOVEI	B,FRAME5-1	;POINT TO FRAME
	HRRM	B,CCWL		;SAVE IN LAST-BLOCK CCW
	AOJ	A,		;IT WAS ONE TOO SMALL
	MOVEM	A,FRMNUM+4	;PUT IT AMONG FRAME NUMBERS
	USETI	IO,(A)		;POINT TO IT
	INPUT	IO,CCWL 	;READ IN LAST BLOCK
	SOS	FILSIZ		;DECREMENT FILE SIZE FOR EDITING

WOTNOW: TRZ	F,LIS!SUB!VAL!ITR!COM!SPC!RTP!LSI!DL1
	PUSHJ	P,ASKME 	;GET A COMMAND STRING
	SKIPL	E,COMAND	;GET COMMAND INDEX - NO ARGS?
	JRST	@E		;NO - JUST DO COMMAND (RETURN TO WOTNOW)

;CHECK RANGE OF STRLOC AND ENDLOC, SET UP A PTR IN PT,
;DISPATCH TO THE COMMAND GIVEN, AND LOOP THROUGH ALL PTRS

	TRNN	F,FND!COM	;GOT ANY VALUES AT ALL?
	PUSHJ	P,SETRNG	;NO - SET UP DEFAULT RANGE
	MOVE	A,FILSIZ	;GET MAX VALUE
	CAMGE	A,ENDLOC	;END TOO LARGE?
	MOVEM	A,ENDLOC	;YES - SET TO MAX
	CAMGE	A,STRLOC	;START TOO LARGE?
	MOVEM	A,STRLOC	;YES - SET TO MAX
	MOVE	A,RELFIL	;GET MIN VALUE
	CAMLE	A,STRLOC	;START TOO SMALL?
	MOVEM	A,STRLOC	;YES - SET TO MIN
	MOVE	A,STRLOC	;GET ADJUSTED START
	CAMLE	A,ENDLOC	;IS ENDLOC .GE. STRLOC
	MOVEM	A,ENDLOC	;NO - MAKE IT STRLOC

	TLNE	E,DELTER	;GOT A DELETE?
	JRST	DELETE		;YES - GO DO IT NOW
	TLNN	E,PRNTER	;GOT A PRINT COMMAND?
	JRST	HDLCMD		;NO - SKIP THIS STUFF
	TRNE	F,MNS		;WORKING BACKWARDS?
	MOVEM	A,FILPTR	;YES - SAVE STRLOC AS NEXT POINTER
	SUB	A,ENDLOC	;GET NUMBER OF WORDS IN RANGE
	CAMGE	A,[-1]		;MORE THAN ONE LINE?
	MOVNM	A,OLLINE	;YES - SAVE AS DEFAULT NUMBER OF LINES

HDLCMD: SKIPGE	D,STRLOC	;GET STARTING ADDRESS - ANY?
	JRST	WOTNOW		;NO - COMMAND DONE - GET A NEW ONE
	MOVE	WD,D		;SET UP AS WORD NUMBER
	MOVE	B,D		;AND FOR WORDCOUNT CALCULATION
	MOVE	PT,D		;AND FOR IOWD POINTER
	ANDI	PT,177		;MAKE PTR LESS THAN 200
	LDB	C,[POINT 29,B,28];GET PAGE NUMBER FOR CHECKER
	ORI	D,177		;SET TO TOP OF PAGE
	CAML	D,ENDLOC	;IS END ADDRESS WITHIN THIS PAGE?
	JRST	HDLCM1		;YES - MAKE THIS THE LAST IOWD
	MOVEM	D,STRLOC	;NO - START NEXT TIME AT
	AOS	STRLOC		;  START OF NEXT PAGE
	SUB	B,STRLOC	;GET NEGATIVE WORDCOUNT
	HRL	PT,B		;SET UP IN IOWD
	JRST	CHKRES		;GET PAGE IN CORE AND EXECUTE COMMAND

HDLCM1:	SUB	B,ENDLOC	;GET NEGATIVE WORDCOUNT
	SUBI	B,1		;PLUS NEGATIVE ONE
	HRL	PT,B		;SET UP AS WORDCOUNT
	SETOM	STRLOC		;SET TO SHOW COMMAND IS DONE
	MOVE	A,ENDLOC	;GET END LOCATION
	TRNN	F,MNS		;WORKING BACKWARDS?
	MOVEM	A,FILPTR	;NO - SAVE AS FILE POINTER

;NOW SEE IF THIS PAGE IS IN CORE, AND TO GET IT IF NOT
;PAGE NUMBER IS IN C

CHKRES:	MOVEI	FM,4		;SET UP INDEX
	AOJ	C,		;PAGE # WAS ONE TOO SMALL, ACTUALLY
CHKRE1:	CAMN	C,FRMNUM(FM)	;IS IT THE RIGHT ONE?
	JRST	GOTPAG		;YES - COMPUTE FRAME ADDRESS
	SOJGE	FM,CHKRE1	;NO - CHECK THE NEXT FRAME

;PAGE IS NOT IN CORE - OVERWRITE LEAST RECENTLY REFERENCED ONE

	AOS	FM,FRMACS	;BUMP AND GET ACCESS COUNTER
	ANDI	FM,3		;ONLY CARE ABOUT LAST FOUR BITS
	SKIPE	FRMWRT(FM)	;DOES THIS FRAME NEED TO BE WRITTEN?
	PUSHJ	P,WRTPAG	;YES - WRITE IT
	HRRM	C,FRMNUM(FM)	;SAVE BLOCK NUMBER IN STATUS
	USETI	IO,(C)		;GET THIS BLOCK
	MOVE	B,FRAMES(FM)	;MAKE IOWD TO READ 200
	SOJ	B,		;  WORDS INTO THIS FRAME
	HRRM	B,CCW		;SAVE AS CHANNEL COMMAND WORD
	ADD	PT,FRAMES(FM)	;MAKE POINTER INTO ABSOLUTE ADDRESS
	IN	IO,CCW		;INPUT IT
	  JRST	@COMAND 	;O.K. - EXECUTE COMMAND
	OUTSTR	[ASCIZ /FILE INPUT ERROR
/]				;this happens at the most gawdawful times
	JRST	WOTNOW		;FORGIVE HIM

;HERE IF PAGE WAS IN CORE

GOTPAG:	ADD	PT,FRAMES(FM)	;MAKE POINTER ADDRESS ABSOLUTE
	JRST	@COMAND		;GO EXECUTE COMMAND

;SUBROUTINE TO WRITE THE FRAME WHOSE INDEX IS IN AC FM

WRTPAG: MOVE	B,FRMNUM(FM)	;GET BLOCK NUMBER
	USETO	IO,(B)		;POINT TO IT ON DISK
	MOVE	B,FRAMES(FM)	;GET ADDRESS OF THE FRAME
	SOJ	B,		;LESS ONE FOR IOWD
	HRRM	B,CCW		;SAVE IN CHANNEL COMMAND
	SETZM	FRMWRT(FM)	;CLEAR THE NEEDS-WRITING FLAG
	OUTPUT	IO,CCW		;OUTPUT THE BLOCK
	POPJ	P,

;SUBROUTINE TO SET UP THE RANGE FOR THE USER, SAME AS LAST TIME

SETRNG: MOVE	A,FILPTR	;GET FILE POINTER
	TLNE	E,FINDER	;WANT A FIND OR SUBSTITUTE?
	AOJA	A,SETFND	;YES - BUMP START PTR AND SET UP DIFFERENTLY
	TRNE	F,MNS		;NEGATIVE RELATIVE?
	JRST	SETRN1		;YES - DO IT BACKWARDS
	MOVEM	A,STRLOC	;SAVE AS START
	ADD	A,OLLINE	;ADD IN NUMBER TO PRINT
	MOVEM	A,ENDLOC	;SAVE AS END
	POPJ	P,		;RETURN TO FLOW

SETRN1: MOVEM	A,ENDLOC	;SAVE AS END
	SUB	A,OLLINE	;MINUS NUMBER TO PRINT
	MOVEM	A,STRLOC	;SAVE AS START
	POPJ	P,		;BACK TO FLOW

SETFND:	MOVEM	A,STRLOC	;SAVE AS START
	MOVE	A,FILSIZ	;GET END OF FILE
	MOVEM	A,ENDLOC	;SAVE AS END
	MOVE	A,OLVALU	;REMEMBER WHAT TO LOOK FOR
	MOVEM	A,VALUE 	;SAVE IT
	MOVE	E,VALUE1	;GET OLD NEW VALUE
	MOVE	A,OLMASK	;GET OLD MASK
	MOVEM	A,MASK		;REMEMBER THAT, TOO
	TRO	F,RTP		;SET SO WON'T SAVE THE ABOVE PARAMS
	SKIPN	ITERAT		;GOT SOME OCCURRENCES TO LOOK FOR?
	AOS	ITERAT		;NO - LOOK FOR ONE, THEN
	POPJ	P,		;BACK TO FLOW

;some error messages

LUKERR: OUTSTR	[ASCIZ /  FILE NOT FOUND, OR IS PROTECTED
/]
	CAIA			;ONE MESSAGE AT A TIME
ENTERR: OUTSTR	[ASCIZ /  CANNOT WRITE TO OUTPUT AREA
/]
	CLRBFI			;CLEAR INPUT BUFFER
	JRST	NEWFIL		;GIVE HIM ANOTHER CHANCE

;SUBROUTINE TO COPY INPUT FILE INTO OUTPUT FILE

COPY:	TRO	F,COP		;SAY THAT A COPY WAS MADE
	OPEN	IO,IOBLK
	  HALT
	ENTER	IO,IOFIL
	  JRST	ENTERR		;ASSUME HE MADE A MISTAKE
	MOVEI	A,FRAME1-1	;GET TARGET ADDRESS
	HRLI	A,-1200 	;AND SIZE
	MOVEM	A,CCW		;SAVE AS CHANNEL COMMAND WORD
	MOVE	A,FILSIZ	;GET SIZE OF FILE
COPY1:	CAIG	A,1200		;TOO BIG FOR BUFFERS?
	JRST	COPY2		;NO - DO LAST I/O
	SUBI	A,1200		;YES - MOVE 1000 WORDS
	INPUT	IN,CCW		;GET THE WORDS
	OUTPUT	IO,CCW		;CHUCK THEM OUT
	JRST	COPY1		;LOOP UNTIL FILE COPIED

COPY2:	MOVNS	A		;NEGATE FINAL WORDCOUNT
	HRLM	A,CCW		;SAVE IN CHANNEL COMMAND
	INPUT	IN,CCW		;GET THE LAST PART OF THE FILE
	OUTPUT	IO,CCW		;CHUCK IT OUT
	CLOSE	IO,		;MAKE OUTPUT FILE PERMANENT
	RELEAS	IO,
	CLOSE	IN,		;GET RID OF INPUT FILE
	MOVNI	A,200		;GET WORDCOUNT FOR EDITING
	HRLM	A,CCW		;SAVE IN CHANNEL COMMAND
	POPJ	P,		;RETURN TO PROCESS OUTPUT FILE

;SUBROUTINE TO INPUT A STRING OF UP TO SIX SIXBIT CHARACTERS
;EXCESS IGNORED (ENTRY STRIN), OR AN OCTAL VALUE OR ONE
;ASCII CHARACTER (ENTRY VALIN).  INPUT IS A BYTE POINTER IN C
;(FOR STRING); OUTPUT IS VALUE OR STRING IN B, DELIMITER IN A.

STRIN:	SETZ	B,		;CLEAN OUT FOR MASK, AND RESULT
STRGET: INCHWL	A		;GET A CHARACTER
	TRNE	F,SPC		;WANT TO SAVE FILE SPECS?
	IDPB	A,D		;YES - STASH THE CHARACTER
	CAIGE	A,"0"		;TOO SMALL TO BE USEFUL?
	JRST	STRSPC		;YES - SEE IF IT'S SPECIAL
	CAIG	A,"9"		;NUMERIC?
	JRST	STRSAV		;YES - CONVERT IT
	CAIGE	A,"A"		;BIG ENOUGH FOR A CHARACTER?
	POPJ	P,		;NO - RETURN WITH DELIMITER
	CAIG	A,"Z"		;IS IT A CHARACTER?
	JRST	STRSAV		;YES - SAVE IT
	CAIL	A,"a"		;IS IT A LOWER CASE CHARACTER?
	CAILE	A,"z"		;..
	POPJ	P,		;NO - NONE OF ABOVE - RETURN
	SUBI	A,40		;YES - CONVERT TO UPPER
STRSAV:	TLNN	C,770000	;GOT SIX CHARACTERS?
	JRST	STRGET		;YES - IGNORE THIS CHARACTER
	SUBI	A," "		;MAKE SIXBIT
	IDPB	A,C		;SAVE CHAR (POINTER IS IN C)
	JRST	STRGET		;AND GET SOME MORE

STRSPC:	CAIE	A,12		;IS IT A LINEFEED,
	CAIN	A," "		;  OR A SPACE?
	JRST	STRGET		;YES - IGNORE IT
	POPJ	P,		;ELSE RETURN WITH DELIMITER

;SUBROUTINE TO INPUT A VALUE (BUT NOT A RANGE)

VALIN:	TRZ	F,FND		;CLEAR FOUND-A-VALUE FLAG
	SETZB	E,B		;CLEAN OUT FOR MASK, AND RESULT
VALGET: INCHWL	A		;GET A CHARACTER
	TRNE	F,SPC		;WANT TO SAVE FILE SPECS?
	IDPB	A,D		;YES - STASH THE CHARACTER
VALIN0:	CAIGE	A,"0"		;TOO SMALL FOR A DIGIT?
	JRST	VALSPC		;YES - SEE IF IT'S SPECIAL
	CAILE	A,"7"		;IS IT A GOOD OCTAL DIGIT?
	JRST	VALSP1		;NO - CHECK FOR HIGH SPECIALS
	LSH	E,3		;SHIFT MASK ONE OCTAL BYTE
VALGE1:	TRO	F,FND		;FOUND A VALUE
	SUBI	A,"0"		;GET AN OCTAL DIGIT
	LSH	B,3		;B*8
	ADD	B,A		;  + NEW VALUE
	JRST	VALGET		;AND GET SOME MORE

VALSPC:	CAIE	A,12		;IS IT A LINEFEED?
	CAIN	A," "		;IS IT A SPACE?
	JRST	VALGET		;YES - IGNORE IT
	POPJ	P,		;NO - RETURN THE CHARACTER TO CALLER

VALSP1:	CAIE	A,"?"		;IS THIS A WILD BYTE?
	POPJ	P,		;NO - RETURN IT TO CALLER
	LSH	E,3		;SHIFT MASK ONE OCTAL BYTE
	ADDI	E,7		;MASK THIS BYTE
	MOVEI	A,"0"		;GET A ZERO
	JRST	VALGE1		;  TO PUT IN THE NUMBER

;SUBROUTINE TO INPUT A RANGE VALUE

RNGIN:	TRZ	F,FND		;CLEAR FOUND-A-VALUE FLAG
	SETZ	B,		;CLEAN OUT RESULT
RNGGET: INCHWL	A		;GET A CHARACTER
	CAIGE	A,"0"		;TOO SMALL FOR A DIGIT?
	JRST	RNGSPC		;YES - SEE IF IT'S SPECIAL
	CAIG	A,"7"		;IS IT A GOOD OCTAL DIGIT?
	JRST	RNGGE1		;YES - PROCESS IT
	TLNE	F,R10		;USING RADIX 10?
	CAILE	A,"9"		;YES - GOT AN 8 OR 9?
	POPJ	P,		;NO - RETURN IT TO CALLER

RNGGE1:	TRO	F,FND		;FOUND A VALUE
	SUBI	A,"0"		;GET AN OCTAL DIGIT
	IMUL	B,RADIX		;B*RADIX
	ADD	B,A		;  + NEW VALUE
	JRST	RNGGET		;AND GET SOME MORE

RNGSPC:	CAIE	A,12		;IS IT A LINEFEED?
	CAIN	A," "		;IS IT A SPACE?
	JRST	RNGGET		;YES - IGNORE IT
	CAIN	A,"*"		;WANT END-OF-FILE VALUE?
	JRST	MAKEND		;YES - GO DO IT
	CAIE	A,"."		;WANT PRESENT-LOCATION VALUE?
	POPJ	P,		;NO - RETURN THE CHARACTER TO CALLER

MKHERE: JUMPN	B,INERR		;TROUBLE IF SOME VALUE TYPED
	MOVE	B,FILPTR	;GET PRESENT LOCATION
	TRO	F,FND		;SET FOUND-A-VALUE FLAG
	JRST	RNGGET		;GET MORE GAFF

MAKEND: JUMPN	B,INERR 	;STILL TROUBLE IF MORE INPUT
	MOVE	B,[377777,,777777] ;GET LARGEST VALUE
	TRO	F,FND		;SET FOUND-A-VALUE FLAG
	JRST	RNGGET		;GO BACK FOR MORE

;SUBROUTINE TO GET EITHER A LETTER OR A VALUE FOR THE "O" COMMAND
;GIVES SKIP RETURN IF NOT A LETTER

CMDIN:	TRO	F,FND		;SET FOUND-A-VALUE FLAG
	INCHWL	A		;GET A CHARACTER
	CAIGE	A,"A"		;TOO SMALL FOR A CHARACTER?
	JRST	CMDSPC		;YES - SEE IF IT'S SPECIAL
	CAIG	A,"Z"		;UPPER CASE CHARACTER?
	POPJ	P,		;YES - RETURN WITH IT
	CAIL	A,"a"		;LOWER CASE CHARACTER?
	CAILE	A,"z"		;..
	JRST	CMDIN0		;NO - TREAT IT LIKE A VALUE
	SUBI	A,40		;YES - CONVERT TO UPPER
	POPJ	P,		;AND RETURN

CMDSPC:	CAIE	A," "		;IS IT A SPACE,
	CAIN	A,12		;  OR A LINEFEED?
	JRST	CMDIN+1 	;YES - IGNORE IT
CMDIN0: SETZB	E,B		;CLEAR MASK AN TARGET FOR VALIN
	TRZ	F,FND		;CLEAR FOUND-A-VALUE FLAG
	AOS	(P)		;GIVE SKIP RETURN EVENTUALLY
	PJRST	VALIN0		;GET THE VALUE

INERR:	OUTSTR	[ASCIZ / ERROR WITH . OR */]
	CLRBFI			;CLEAN OUT INPUT BUFFER
	POP	P,A		;KILL TOP OF STACK
	JRST	ASKME		;START FROM SCRATCH

;SUBROUTINE TO INPUT A COMPLETE COMMAND STRING

ASKME:	SETZM	VALUE		;ZERO EVERYTHING
	SETZM	STRLOC
	SETZM	ENDLOC
	SETZM	COMAND
	SETZM	ITERAT
	SETOM	MASK		;MASK EVERYTHING
	OUTSTR	PROMPT		;TELL USER IT'S UP TO HIM
	PUSHJ	P,CMDIN 	;GET THE COMMAND
	  JRST	ASKME0		;STORE THE LEGAL COMMAND
	TRNN	F,FND		;FOUND ANYTHING?
	CAIE	A,15		;NO - JUST A CARRIAGE RETURN?
	JRST	CMDERR		;NO - IT'S AN ERROR
	JRST	ASKME		;YES - LONE <CR> - DO IT OVER

;NOW SAVE OFF COMMAND, A SINGLE LETTER

ASKME0:	MOVE	A,CMDTBL-101(A)	;GET COMMAND
	MOVEM	A,COMAND	;SAVE IT
	CAIN	A,OUTFMT	;IS IT AN O COMMAND?
	JRST	ASKO		;YES - HANDLE SEPARATELY

;NOW GET THE RANGE, OF FORM N, N:N, N+N, OR N-N

	PUSHJ	P,RNGIN 	;GET A VALUE
	MOVEM	B,STRLOC	;SAVE FIRST WORD OF RANGE
	CAIN	A,15		;CARRIAGE RETURN?
	POPJ	P,		;DONE - FINISH OFF
	TRZ	F,MNS		;NO MORE NEGATIVE ADDRESSING
	CAIN	A,"/"		;END OF RANGE?
	JRST	ASKVAL		;YES - GET VALUE
	CAIN	A,"@"		;GO DIRECTLY TO ITERATIONS?
	JRST	ASKITR		;YUP

	MOVEM	A,D		;NO - SAVE DELIMITER
	PUSHJ	P,RNGIN 	;GET SECOND VALUE
	CAIN	D,"+"		;POSITIVE RELATIVE ADDRESSING?
	JRST	PLSHDL		;YES - TAKE CARE OF IT
	CAIN	D,"-"		;NEGATIVE RELATIVE ADDRESSING?
	JRST	MNSHDL		;YES - TAKE CARE OF IT, TOO
	CAIE	D,":"		;RANGE?
	JRST	CMDERR		;NO - BOMB TIME
	MOVEM	B,ENDLOC	;YES - SAVE END ADDRESS

ASKRN1:	CAIN	A,15		;CARRIAGE RETURN?
	POPJ	P,		;YES - FINISHED
	CAIE	A,"/"		;BETTER BE A SLASH
	JRST	CMDERR		;IT ISN'T

;NOW GET THE VALUE, OF FORM N OR N,N OR N,,N, WITH MASK

ASKVAL: PUSHJ	P,VALIN 	;GET PART (ANYWAY) OF VALUE
	CAIE	A,","		;ONLY HALF THE WORD?
	JRST	ASKVA1		;NO - FINISH OFF THE VALUE
	PUSHJ	P,COMHDL	;SAVE LEFT HALF VALUE
	JRST	ASKVAL		;GET OTHER HALF

ASKVA1: PUSHJ	P,VALHDL	;NO - SAVE RH OR WHOLE VALUE
	CAIN	A,15		;WAS A CARRIAGE RETURN?
	POPJ	P,		;YES - RETURN
	CAIN	A,"="		;WANT SECOND VALUE?
	JRST	ASKVA2		;YES - SET UP FOR IT
	CAIE	A,"@"		;AT IS THE ONLY THING ALLOWED
	JRST	CMDERR		;AND THIS ISN'T IT

;NOW CHECK FOR NUMBER OF ITERATIONS

ASKITR:	PUSHJ	P,VALIN 	;GET NUMBER OF ITERATIONS
	MOVEM	B,ITERAT	;SAVE NUMBER OF ITERATIONS
	TRO	F,ITR		;SET FOUND-AN-ITER FLAG
	CAIN	A,15		;IS HE DONE WITH COMMAND?
	POPJ	P,		;YES - ESCAPE AND PROCESS
	JRST	CMDERR		;NO - ERROR

ASKVA2: MOVE	B,VALUE 	;GET FIRST VALUE
	MOVEM	B,VALUE1	;IT'S REALLY THE SECOND ONE
	TRZ	F,VAL		;VAL FLAG SHOULDN'T HAVE BEEN SET
	JRST	ASKVAL		;GET REST OF COMMAND

;HERE TO HANDLE THE O COMMAND - ARG CAN BE A SINGLE LETTER
;OR A VECTOR OF UP TO 5 BYTE SIZES

ASKO:	MOVE	D,[XWD -5,BYTTAB];POINT TO FIVE WORD TABLE
ASKO1:	PUSHJ	P,CMDIN		;GET SOMETHING
	  JRST	ASKO2		;IT'S A CHARACTER
	TRNN	F,FND		;DID HE GIVE A NUMBER AT ALL?
	POPJ	P,		;NO - JUST RETURN
	JUMPE	B,ERRBYT	;ZERO BYTE SIZE IS ILLEGAL
	MOVEM	B,(D)		;NUMBER - SAVE
	CAIN	A,","		;MORE?
	AOBJN	D,ASKO1 	;YES - GET 'EM
	CAIE	A,15		;CARRIAGE RETURN?
	JRST	CMDERR		;NO - MISTAKE
	SETO	B,		;DONE - WRITE A -1
	MOVEM	B,1(D)		;..
	POPJ	P,		;THEN RETURN

ASKO2:	MOVEM	A,STRLOC	;SAVE FORMAT CHARACTER
	INCHWL	A		;GET END OF LINE
	CAIN	A,15		;IS IT?
	POPJ	P,		;YES - RETURN
	JRST	CMDERR		;NO - ERROR

COMHDL: TRON	F,VAL		;HIT A SECOND COMMA?
	TRNN	F,FND		;NO - GOT ANYTHING TO SAVE?
	POPJ	P,		;NO - OR MANY COMMAE - RETURN
	TRO	F,COM		;SET FOUND-A-COMMA FLAG
	HRLZM	B,VALUE 	;SAVE LEFT HALF
	HRLM	E,MASK		;AND LH OF MASK
	POPJ	P,		;AND RETURN

VALHDL: TRNN	F,FND		;GOT A VALUE AT ALL?
	POPJ	P,		;NO - SET NOTHING
	TROE	F,VAL		;GOT A LEFT HALF?
	JRST	VALHD1		;YES - FLAG IS RIGHT ALREADY
	MOVEM	B,VALUE 	;SAVE FULL WORD
	MOVEM	E,MASK		;SAVE THE WHOLE MASK
	POPJ	P,		;AND RETURN
VALHD1: HRRM	B,VALUE 	;SAVE RIGHT HALF ONLY
	HRRM	E,MASK		;SAVE RIGHT-HALF MASK
	POPJ	P,		;AND RETURN

PLSHDL: ADD	B,STRLOC	;MAKE ENDING LOCATION
	MOVEM	B,ENDLOC	;SAVE IT
	JRST	ASKRN1		;BACK TO FLOW

MNSHDL: MOVE	C,STRLOC	;GET STARTING LOCATION
	MOVEM	C,ENDLOC	;IT'S REALLY ENDING LOCATION
	SUB	C,B		;MAKE STARTING LOC
	MOVEM	C,STRLOC	;AND SAVE IT
	TRO	F,MNS		;SET FLAG FOR FILE POINTER
	JRST	ASKRN1		;BACK TO FLOW

ERRBYT: OUTSTR	[ASCIZ /CANNOT HAVE BYTE SIZE ZERO/]
	JRST	.+2		;IGNORE AND GET

CMDERR: OUTSTR	[ASCIZ / ERROR IN COMMAND STRING/]
	CLRBFI			;CLEAN OUT INPUT BUFFER
	JRST	ASKME		;THEN  FOR ANOTHER TRY

;SUBROUTINE TO SET UP THE FILE SPECS GIVEN IN THE RUN COMMAND

GETSCN: RESCAN			;GO TO START OF RUN LINE
GETSC1: INCHRS	A		;GET A CHARACTER - ANY?
	POPJ	P,		;NO - DONE
	CAIE	A,";"		;BEGINNING OF COMMAND?
	JRST	GETSC1		;NO - KEEP LOOKING
	MOVEI	B,-1		;SET TO KILL FILE PROMPT
	POPJ	P,		;AND RETURN WITH THEM SET UP

;SUBROUTINE TO INPUT FILE SPECIFICATIONS

GETFIL: CAIE	B,-1		;GOT SPECS WAITING?
	OUTSTR	QUERY		;NO - PROMPT FOR THEM, THEN
	TLZ	F,RDO		;CLEAR READ-ONLY FLAG
GETFL1:	MOVE	C,SIXPTR	;SAVE POINTER IN C
	PUSHJ	P,STRIN 	;GET A CHARACTER
	CAIN	A,15		;CARRIAGE RETURN?
	JRST	GETFL5		;YES - DONE
	CAIN	A,":"		;GOT DEVICE NAME?
	JRST	GETFL3		;YES - SAVE IT
	CAIN	A,"["		;GOT A PPN COMING?
	JRST	GETFL5+1	;YES - HANDLE THIS AND GET PPN
	CAIN	A,"="		;WAS THIS AN OUTPUT FILE?
	JRST	GETFL9		;YES - GET READY FOR IN SPECS
	CAIN	A,"/"		;READ ONLY SWITCH?
	JRST	[TLO  F,RDO	;YES - SET FOR READ ONLY
		 CLRBFI		;KILL OTHER INPUT
		 POPJ P,]	;AND RETURN
	CAIE	A,"."		;END OF NAME?
	JRST	GETERR		;NO - MUST BE ERROR
	MOVEM	B,INFIL+2	;SAVE NAME
	TRNN	F,OUF		;ALREADY GOT AN OUTPUT FILE?
	MOVEM	B,IOFIL		;NO - MAKE OUT SAME AS IN
	JRST	GETFL1		;GET SOME MORE
GETFL3: MOVEM	B,INBLK+1	;SAVE DEVICE FOR INPUT
	TRNN	F,PPN		;ALREADY AN OUTPUT DEVICE?
	MOVEM	B,IOBLK+1	;NO - SAVE HERE, TOO
	JRST	GETFL1		;SEE WHAT ELSE HE HAS TO SAY
GETFL5: JUMPE	B,CPOPJ 	;RETURN IF ONLY A <CR>
	SKIPN	INFIL+2		;GOT A FILE YET?
	JRST	GETFL6		;NO - THIS MUST BE IT
	MOVEM	B,INFIL+3	;OTHERWISE SAVE EXT
	TRNN	F,OUF		;ALREADY AN OUTPUT EXT?
	MOVEM	B,IOFIL+1	;NO - SAVE HERE ALSO
	JRST	.+4		;SEE IF PPN COMING
GETFL6: MOVEM	B,INFIL+2	;SAVE FILE NAME
	TRNN	F,OUF		;GOT AN OUTPUT FILE YET?
	MOVEM	B,IOFIL		;NO - SAVE HERE, TOO
	CAIE	A,"["		;PPN COMING?
CPOPJ:	POPJ	P,		;NO - RETURN
	TRO	F,OUF		;YES - THEN I- AND O- FILES ARE DIFFERENT
	PUSHJ	P,VALIN 	;GET PROJ NUMBER
	CAIN	A,15		;CARRIAGE RETURN?
	JRST	GETERR		;<CR> NOW IS BAD
	CAIE	A,","		;BETTER END WITH A COMMA
	JRST	GETERR		;NOPE - WRONG
	HRLM	B,INFIL+1	;SAVE PROJ
	PUSHJ	P,VALIN 	;GET PROG NUMBER
	CAIN	A,15		;CARRIAGE RETURN?
	JRST	.+5		;YES - O.K.
	CAIE	A,"]"		;OR A BRACKET,
	CAIN	A,"="		;  OR AN EQUAL ?
	JRST	.+2
	JRST	GETERR		;NO - TRY AGAIN
	HRRM	B,INFIL+1	;SAVE PROG
	CAIN	A,15		;DID HE TYPE A <CR>?
	POPJ	P,		;YES - RETURN
	CAIE	A,"="		;DID HE END WITH AN EQUAL?
	JRST	GETFL1		;NO - GO BACK FOR MORE

GETFL9: TRO	F,PPN		;KEEP WHATEVER PPN THERE IS
	PUSHJ	P,GETFL5	;FINISH WORK FOR OUTPUT SPECS
	SKIPE	INFIL+2		;DID HE GIVE AN INPUT FILE?
	TRO	F,OUF		;YES - SET GOT-OUTPUT-SPECS FLAG
	SKIPE	B,INFIL+1	;GET OUTPUT PPN - ANY?
	MOVEM	B,IOFIL+3	;YES - SAVE IN THE RIGHT PLACE
	SETZM	INFIL+1 	;\
	SETZM	INFIL+2 	; - CLEAR INPUT FILE SPECS
	SETZM	INFIL+3 	;/
	JRST	GETFL1		;GET INPUT SPECS
GETERR: OUTSTR	[ASCIZ /  BAD FILE SPECIFICATIONS
/]
	CLRBFI			;CLEAN OUT INPUT BUFFER
	JRST	GETFIL		;GIVE ANOTHER CHANCE

;HERE WHEN DONE - EXIT TO SAVE CHANGES; QUIT TO FORGET THEM
;ALSO TO SAVE A FILE AND RETURN TO PROCESSING

WRITE:	TRO	F,WRT		;SET WRITE-ONLY FLAG
	TLNE	F,RDO		;READ ONLY?
	JRST	RDOERR		;YES - ILLEGAL COMMAND
EXOUT:	TLNE	F,RDO		;READ ONLY?
	JRST	QUITIT		;YES - JUST DO A QUIT
	MOVEI	FM,3		;POINT TO LAST FRAME
EXOUT1: SKIPE	FRMWRT(FM)	;DOES THIS FRAME NEED WRITING?
	PUSHJ	P,WRTPAG	;YES - OUTPUT IT
	SOJGE	FM,EXOUT1	;LOOP THROUGH FRAMES
	SKIPN	FRMWRT+4	;DOES LAST FRAME NEED WRITING
	JRST	EXOUT2		;NO - SKIP THIS
	USETO	IO,@FRMNUM+4	;YES - POINT TO LAST BLOCK
	OUTPUT	IO,CCWL 	;OUTPUT IT

EXOUT2: TRNE	F,RTP		;WANT A RETURN?
	POPJ	P,		;YES (TO INSERT OR DELETE)
	TRZE	F,WRT		;WRITE ONLY?
	JRST	WOTNOW		;YES - GET NEW COMMAND
QUITIT:	CLRBFI			;CLEAN OUT THE INPUT BUFFER
	TRZE	F,DLT		;GOT SOME GARBAGE AT TOP OF FILE?
	PUSHJ	P,COLAPS	;YES - MAKE THE FILE SMALLER
	EXIT			;AND GET LOST

QUIT:	TRNN	F,COP		;GOT A COPY TO GET RID OF?
	JRST	QUITIT		;NO - JUST GO
	SETZM	IOFIL		;CLEAR FILE NAME
	RENAME	IO,IOFIL	;DELETE THE FILE
	  EXIT			;QUIT IN ANY CASE
	EXIT			;AND LEAVE

;SUBROUTINE TO READ AND WRITE FILE AND DELETE GERBAGE WORDS FROM THE END

COLAPS:	CLOSE	IO,		;CLOSE UPDATING
	HLLZS	IOFIL+1		;CLEAN UP FILESPECS
	SETZM	IOFIL+2
	SETZM	IOFIL+3
	LOOKUP	IO,IOFIL	;SET UP FOR INPUT
	  HALT
	OPEN	OU,INBLK	;AND OUTPUT
	  HALT
	HLLZS	IOFIL+1		;CLEAN UP FILESPECS
	SETZM	IOFIL+2
	SETZM	IOFIL+3
	ENTER	OU,IOFIL	;..
	  HALT
	MOVEI	C,FRAME1-1	;GET ADDRESS OF FRAME
	MOVEM	C,CCW		;..
	MOVE	A,FILSIZ	;GET REAL SIZE OF FILE
	AOJ	A,		;PLUS ONE
	IDIVI	A,1200		;GET NUMBER OF LOOP CHUNKS AND REMAINDER
	JUMPE	A,COLLAS	;JUMP IF NO FIVE-BLOCK CHUNKS
	HRLI	C,-1200 	;SET UP CCW FOR READ AND WRITE
	MOVEM	C,CCW		;..
COLPS1: INPUT	IO,CCW		;READ A 1200-WORD CHUNK
	OUTPUT	OU,CCW		;WRITE IT OUT AGAIN
	SOJG	A,COLPS1	;LOOP THROUGH CHUNKS

COLLAS: MOVN	A,B		;NEGATE SIZE OF LAST CHUNK
	HRLM	A,CCW		;SAVE IN CCW
	INPUT	IO,CCW		;READ LAST BLOCK
	OUTPUT	OU,CCW		;WRITE IT
	CLOSE	IO,		;CLOSE OFF THE FILE
	CLOSE	OU,
	MOVNI   A,200           ;SET THE USUAL BLOCK SIZE UP AGAIN
	HRLM    A,CCW
	POPJ	P,		;AND RETURN

;SUBROUTINE TO GET A VALUE AND CHANGE POINTED FILE WORD TO IT

GETCHG: SETOM	FRMWRT(FM)	;MARK THIS FRAME AS NEEDING WRITING
GTCHG0:	PUSHJ	P,PRTWD 	;PRINT LINE NUMBER
	OUTCHR	["/"]		;SLASH AS A PROMPT
	SETOM	MASK		;MASK EVERYTHING
	TRZ	F,VAL		;RESET FOUND-PART-OF-A-VALUE FLAG
GTCHG1: PUSHJ	P,VALIN 	;GET A VALUE
	CAIN	A,15		;CARRIAGE RETURN?
	JRST	GTCHG2		;YES - FINISHED
	CAIE	A,","		;JUST LEFT HALF?
	JRST	GETCER		;NO - THEN IT'S AN ERROR
	PUSHJ	P,COMHDL	;HANDLE LEFT HALF
	JRST	GTCHG1		;GET MORE

GTCHG2: PUSHJ	P,VALHDL	;HANDLE LEFT HALF
	MOVE	A,VALUE 	;GET WHOLE VALUE
	MOVE	C,(PT)		;GET OLD VALUE
	AND	C,MASK		;GET RID OF UNWANTED PARTS
	OR	C,A		;REPLACE THEM WITH NEW STUFF
	MOVEM	C,(PT)		;SAVE THE RESULT
;	TRNE	F,RTP		;HERE FROM THE INSERT ROUTINE?
	POPJ	P,		;YES - DON'T ECHO
;	PJRST	PRINT		;ECHO IT BACK AND RETURN

GETCER:	OUTSTR	[ASCIZ /VALUE ERROR
/]
	CLRBFI			;CLEAN OUT BUFFER
	JRST	GETCHG		;TRY AGAIN

;HERE IF AN UNIMPLEMENTED COMMAND HAS BEEN TYPED

NOTYET: OUTSTR	[ASCIZ / ILLEGAL COMMAND/]
	CLRBFI			;CLEAN OUT INPUT BUFFER
	JRST	WOTNOW		;AND GET ANOTHER COMMAND

RDOERR: OUTSTR	[ASCIZ / ILLEGAL WITH READ ONLY/]
	CLRBFI			;CLEAN OUT INPUT BUFFER
	JRST	WOTNOW		;AND GET ANOTHER COMMAND

;SUBROUTINE TO DO OUTPUT TO THE LINEPRINTER

LIST:	TROE	F,LIS		;ALREADY PRINTING?
	JRST	LIST0		;YES - CONTINUE
	OPEN	LPT,LPTBLK	;SET UP THE FILE
	  HALT
	ENTER	LPT,LPTFIL
	  HALT
	SETZ	A,		;CLEAR # LINES COUNTER

	MOVE	D,WD		;GET LOCATION
	ANDI	D,7		;JUST LAST DIGIT
	IMULI	D,17		;# OF SPACES NEEDED
	ADDI	D,6		;TO ALIGN FIRST LINE
	PUSHJ	P,SPACES	;OUTPUT 'EM

LIST0:	TRNE	WD,7		;LOCATION # EVERY 8 FOR LPT
	JRST	LIST1		;SO SKIP IT THIS TIME
	TRNN	WD,70		;PRINTED 8 LINES?
	PUSHJ	P,LISSKP	;YES - DO SOMETHING
	AOS	A		;BUMP # LINES PRINTED
	PUSHJ	P,CRLFL		;PUT ON A NEW LINE
	PUSHJ	P,LISWD 	;LINE NUMBER
	PUSHJ	P,SLASHL	;AND A SLASH
LIST1:	PUSHJ	P,SPACE3	;YES - SPACE OVER
	MOVE	D,(PT)		;GET FILE WORD
	PUSHJ	P,LISFWD	;PRINT A FULL WORD
	AOS	WD		;BUMP WORD COUNTER
	AOBJN	PT,LIST0	;PRINT UNTIL COUNTER NEGATIVE
	SKIPL	STRLOC		;GOT MORE TO OUTPUT?
	JRST	HDLCMD		;YES - SET IT UP
	RELEAS	LPT,		;AND GIVE UP THE PRINTER
	JRST	WOTNOW		;AND GET ANOTHER COMMAND

LISFWD: MOVE	C,FSXPTR	;GET FULL WORD POINTER
	TLNN	C,770000	;DONE YET?
	POPJ	P,		;YES
	ILDB	CH,C		;GET A BYTE
	ADDI	CH,"0"		;MAKE ASCII
	PUSHJ	P,LISCHR	;PRINT IT
	JRST	LISFWD+1	;GET ANOTHER ONE

LISWD:	MOVE	B,WD		;GET WORD NUMBER
	MOVE	CH,NUMSIZ	;SET UP COUNTER
LISWD1:	IDIV	B,RADIX		;GET LAST DIGIT
	ADDI	C,"0"		;CONVERT TO ASCII
	HRLM	C,(P)		;STORE DIGIT ON STACK
	SOSLE	CH		;DONE 5 DIGITS?
	PUSHJ	P,LISWD1	;NO - CALL RECURSIVELY
	HLR	CH,(P)		;YES - RESTORE DIGIT
				;AND OUTPUT IT

LISCHR: SOSG	LPTBF+2 	;BUFFER FULL YET?
	OUTPUT	LPT,		;YES - SHIP IT OUT
	IDPB	CH,LPTBF+1	;CHUCK CHARACTER
	POPJ	P,		;AND RETURN

SLASHL:	MOVEI	CH,"/"
	PJRST	LISCHR

CRLFL:	MOVEI	CH,15		;CARRIAGE RETURN
	PUSHJ	P,LISCHR
	MOVEI	CH,12		;LINEFEED
	PJRST	LISCHR

SPACE3: MOVEI	D,3		;PRINT 3 SPACES
SPACES: MOVEI	CH," "		;GET THE CHARACTER
	PUSHJ	P,LISCHR	;OUTPUT TO PRINTER
	SOJG	D,.-1		;AND REPEAT UNTIL EXHAUSTED
	POPJ	P,		;THEN RETURN

LISSKP: CAIGE	A,56		;OUTPUT .GE. 46 LINES YET?
	PJRST	CRLFL		;NO - JUST SKIP AN EXTRA LINE
	SETZ	A,		;CLEAR COUNT
	MOVEI	CH,14		;GET A FORMFEED
	PJRST	LISCHR		;OUTPUT IT TO PRINTER

;SUBROUTINE TO DO OUTPUT TO THE SCREEN

PRINT:	PUSHJ	P,PRTWD 	;OUTPUT IT
	OUTCHR	["/"]		;AND A SLASH
	MOVE	D,(PT)		;GET FILE WORD
	PUSHJ	P,PRTFWD	;PRINT A FULL WORD
	PUSHJ	P,PRTCHK	;NO - FINISH OFF TTY OUTPUT
	TRNE	F,RTP		;DOING FIND OR SUBSTITUTE?
	POPJ	P,		;YES - JUST PRINT ONE WORD
	AOJ	WD,		;BUMP WORD ADDRESS
	AOBJN	PT,PRINT	;PRINT UNTIL COUNTED OUT
	JRST	HDLCMD		;LOOP ON IOWDS

;HERE TO OUTPUT OCTAL BYTES OF SIZE GIVEN BY BYTTAB AND A CRLF
;ALSO ROUTES TO ROUTINES FOR ASCII, SIXBIT, OR HEX

PRTCHK: TRNN	F,OFT		;WANT SPECIAL FORMAT?
	PJRST	CRLF		;NO - JUST A CRLF AND GET OUT
	OUTCHR	[11]		;GIVE A TAB

	MOVEI	CH,^D36 	;GET ONE WORDSWORTH OF BITS
	SKIPGE	A,BYTTAB	;GET SIZE OF BYTE - SPECIAL?
	JRST	PRTAOS		;YES - GO THERE (PUFF, PUFF)	ooo
	MOVEI	J,BYTTAB-1	;POINT TO TABLE
PRTBY0: AOJ	J,		;POINT TO NEXT ONE
PRTB1:	SKIPGE	A,(J)		;GET BYTE COUNT - END OF LIST?
	SOJA	J,PRTB1 	;YES - USE LAST ONE AGAIN
	IDIVI	A,3		;# OCTAL CHUNKS IN A; ODD BIT COUNT IN B

;NOW OUTPUT BYTES. TOTAL BITS IN CH, NUMBER OF 3-BIT BYTES IN A,
;SIZE OF ODD PIECE IN B

	JUMPE	B,PRTBY2	;NO ODD BYTES - SO THERE MUST BE SOME CHUNKS
	SETZ	C,		;CLEAR FOR INPUT
	LSHC	C,@B		;GET ODD BITS
	ADDI	C,"0"		;TO ASCII
	OUTCHR	C		;AND OUT
	JUMPE	A,PRTBY3	;MAYBE HE ONLY WANTED ONE OR TWO
PRTBY2: SETZ	C,		;CLEAR FOR INPUT AGAIN
	LSHC	C,3		;GET AN OCTAL BYTE
	ADDI	C,"0"		;CONVERT
	OUTCHR	C		;AND OUT
	SOJG	A,PRTBY2	;LOOP THROUGH BYTE
PRTBY3: MOVE	B,(J)		;GET BYTE COUNT
	CAIG	B,2		;THREE OR BETTER,
	SKIPLE	1(J)		;  AND NOT DONE WITH LIST?
	OUTCHR	[" "]		;YES - PUT A SPACE BETWEEN BYTES
	SUB	CH,B		;DECREMENT COUNT OF BITS DONE
	JUMPG	CH,PRTBY0	;GET ANOTHER BYTE IF THERE IS ONE
	PJRST	CRLF		;ELSE RETURN ON THE NEXT LINE

;HERE TO OUTPUT IN ASCII (7 BIT) OR SIXBIT (6 BIT, DUMMY) CHARACTERS

PRTAOS: MOVNS	A		;MAKE BYTE SIZE POSITIVE
	SUB	CH,A		;REMOVE ONE SET OF CHARACTERS FROM COUNT
PRTAS0: SETZ	C,		;CLEAR FOR INPUT
	LSHC	C,@A		;SHIFT IN A CHARACTER
	CAIN	A,4		;WANT HEXADECIMAL?
	JRST	PRTHEX		;YES - CHECK BITS
	CAIN	A,6		;WANT SIXBIT?
	ADDI	C," "		;YES - CONVERT TO ASCII
	CAIL	C,40		;CONTROL CHARACTER?
	JRST	PRTAS1		;NO - GO IT AS IS
	CAIL	C,10		;IS IT A GOOD
	CAIL	C,16		;  CONTROL CHARACTER?
	JRST	PRTAS2		;NO - OUTPUT A LINE THEN
	OUTSTR	CHTABL-10(C)	;YES - OUTPUT IT
	JRST	.+2		;SKIP OVER OTHER OUTPUT
PRTAS1: OUTCHR	C		;KICK CHARACTER
	SUB	CH,A		;DECREMENT COUNT
	JUMPGE	CH,PRTAS0	;LOOP THROUGH WORD
CRLF:	OUTSTR	[ASCIZ /
/]				;CARRIAGE RETURN
	POPJ	P,

PRTAS2:	OUTCHR	["<"]		;OUTPUT <nnn>
	ROT	C,-3		;GET ONLY 1ST DIGIT OF NUMBER
	ADDI	C,"0"		;OUTPUT IT
	OUTCHR	C
	TRZ	C,777
	ROT	C,3		;GET 2ND DIGIT
	ADDI	C,"0"		;OUTPUT IT
	OUTCHR	C
	MOVEI	C,">"
	JRST	PRTAS1		;CONTINUE THE FLOW

;HERE TO SET UP HEXADECIMAL FORMAT

PRTHEX: TRNN	CH,7		;OUTPUT A SPACE BETWEEN
	OUTCHR	[" "]		;  EVERY TWO CHARACTERS
	ADDI	C,"0"		;CONVERT TO ASCII
	CAILE	C,"9"		;TO BIG FOR A DIGIT?
	ADDI	C,7		;YES - CONVERT TO A-F
	JRST	PRTAS1		;AND USE THAT

CHTABL: ASCIZ /<BS>/
	ASCIZ /<TB>/
	ASCIZ /<LF>/
	ASCIZ /<VT>/
	ASCIZ /<FF>/
	ASCIZ /<CR>/

PRTFWD: MOVE	C,FSXPTR	;GET FULL WORD POINTER
	TLNN	C,770000	;DONE YET?
	POPJ	P,		;YES
	TLNN	C,550000	;AT HALF-WORD POINT?
	OUTSTR	[ASCIZ /,,/]	;YES - PRINT TWO COMMAE
	ILDB	CH,C		;GET A BYTE
	ADDI	CH,"0"		;MAKE ASCII
	OUTCHR	CH		;PRINT IT
	JRST	PRTFWD+1	;GET ANOTHER ONE

;SUBROUTINE TO LINE NUMBER IN THE GIVEN RADIX

PRTWD:	MOVE	B,WD		;GET WORD NUMBER
	MOVE	CH,NUMSIZ       ;SET UP COUNTER
PRTWD1:	IDIV	B,RADIX		;GET LAST DIGIT
	ADDI	C,"0"		;CONVERT TO ASCII
	HRLM	C,(P)		;STORE DIGIT ON STACK
	SOSLE	CH		;DONE 5 DIGITS?
	PUSHJ	P,PRTWD1	;NO - CALL RECURSIVELY
	HLR	B,(P)		;YES - RESTORE DIGIT
	OUTCHR	B		;AND PRINT IT
	POPJ	P,		;RETURN RECURSIVELY AND FINALLY

;SUBROUTINE TO PRINT FROM LOCATION GIVEN BY RIGHT HALF OF
;LAST LINE PRINTED.
;why not just set up new values and restart at WOTNOW+3 or so?

GOTO:	TRON	F,FND		;DID HE GIVE A VALUE?
	SKIPA	A,FILPTR	;NO - USE LAST LINE TYPED
	HRRZ	A,PT		;GET POINTER
	HRRZ	A,@A		;STARTING LOCATION VALUE
	HLRE	B,PT		;GET NUMBER OF WORDS

;see if page is in, and make new IOWD with same LH

	MOVNI	B,-1(B) 	;MAKE IT 1-NUMBER
	SKIPN	ENDLOC		;DID HE GIVE AN END?
	MOVE	B,OLLINE	;NO - SET UP DEFAULT LIMIT
	ADD	B,A		;AND MAKE RELATIVE TO STARTING LOCATION
	MOVEM	B,ENDLOC	;SAVE IT
	MOVEM	A,STRLOC	;SAVE STARTING LOCATION, TOO
	PJRST	PRINT		;GO PRINT IT

	MOVE	B,OLLINE	;GET # LINES PRINTED LAST TIME
	POPJ	P,		;CONTINUE

;HERE TO SET RELOCATION INDEX

RELOK:	MOVE	A,STRLOC	;GET RELOCATION
	MOVEM	A,FILPTR	;POINT TO FIRST LINE OF FILE
	MOVN	B,RELFIL	;GET NEG OF OLD RELOCATION
	MOVEM	A,RELFIL	;SAVE NEW RELOCATION VALUE
	ADD	A,B		;DIF BET OLD AND NEW RELOCS
	ADDM	A,FILSIZ	;RELOCATE RELATIVE
;	SUBM	A,FILBAS	;  AND ABSOLUTE BASES
;	MOVNS	FILBAS		;TAKE NEGATIVE OF BASE
	JRST	WOTNOW		;GET ANOTHER COMMAND

;SUBROUTINE TO TOGGLE OUTPUT RADIX OF WORD NUMBERS BETWEEN DECIMAL AND OCTAL

BASE:	TLCE	F,R10		;FLIP RADIX - WAS IT 10?
	SKIPA	A,[10]		;YES - SET IT TO 8
	MOVEI	A,12		;NO - SET IT TO 10
	MOVEM	A,RADIX 	;MAKE THAT THE NEW RADIX
	JRST	WOTNOW		;GET ANOTHER COMMAND

;SUBROUTINE TO HANDLE SPECIAL FORMAT OUTPUT SPECIFIERS - FOR ASCII/SIXBIT,
;INSTRUCTION FORMAT, OR USER-GIVEN BYTE SIZE

OUTFMT:	SKIPN	A,STRLOC	;WANT A SPECIAL FORMAT?
	JRST	OUTFM0		;NO - JUST SAVE IT
	TRO	F,FND		;SHOULD BE SET IF COMMAND IS GOOD
	CAIN	A,"A"		;ASCII FORMAT?
	JRST	OUTFMA		;YES - SET IT UP
	CAIN	A,"S"		;HOW ABOUT SIXBIT?
	JRST	OUTFMS		;RIGHT
	CAIN	A,"I"		;INSTRUCTION FORMAT?
	JRST	OUTFMI		;YES - HANDLE IT LIKE NO ARG
	CAIN	A,"H"		;HEX, MAYBE?
	JRST	OUTFMH		;YUH
	OUTSTR	[ASCIZ /IMPROPER FORMAT VALUE/]
	CLRBFI			;HE BLEW IT. CLEAN BUFFER
	JRST	WOTNOW		;AND TRY AGAIN

OUTFMI: MOVEI	A,4		;FAKE O 11,4,1,4,22
	MOVEM	A,BYTTAB+1	;  WHICH IS INSTRUCTION FORMAT
	MOVEM	A,BYTTAB+3
	MOVEI	A,1
	MOVEM	A,BYTTAB+2
	MOVEI	A,22
	MOVEM	A,BYTTAB+4
	SKIPA	A,[11]		;FINISH OFF WITH STARTING BYTE

OUTFMH: MOVNI	A,4		;SET UP FOR HEXADECIMAL
	JRST	OUTFM1		;SAVE AND RETURN

OUTFMA: SKIPA	A,[-7]		;SET UP FOR ASCII
OUTFMS: MOVNI	A,6		;SET UP FOR SIXBIT

OUTFM1:	MOVEM	A,BYTTAB	;SAVE BYTE SIZE
OUTFM0:	TRNE	F,FND		;DID HE GIVE A NUMBER?
	TROA	F,OFT		;YES - SET FLAG FOR SPECIAL FORMATS
	TRC	F,OFT		;NO - TOGGLE FORMAT FLAG
	JRST	WOTNOW		;NEXT?

;SUBROUTINE TO OUTPUT THE FILE SPECS PRESENTLY IN USE

TSPECS: OUTSTR	SPECS		;OUTPUT 'EM
	OUTSTR	[ASCIZ /
/]				;CARRIAGE RETURN
	JRST	WOTNOW		;GET NEW COMMAND

;SUBROUTINE TO CHANGE CONTENTS OF STRLOC TO VALUE

CHANGE:	TLNE	F,RDO		;READ ONLY?
	JRST	RDOERR		;YES - ILLEGAL COMMAND
	TRNE	F,VAL		;GET A VALUE?
	JRST	CHANG2		;YES - PUT IT IN
CHANG1:	PUSHJ	P,GETCHG	;NO - GET ONE AND MAKE CHANGE
	AOJ	WD,		;BUMP WORD NUMBER
	AOBJN	PT,CHANG1	;  AND LOOP THROUGH CHANGES
	JRST	HDLCMD		;DONE - GET NEW IOWD, MAYBE

CHANG2:	MOVE	E,VALUE 	;GET NEW VALUE
	PUSHJ	P,CHANG0	;MAKE THE CHANGE
	JRST	CHANG1+1	;CONTINUE THE FLOW

CHANG0: SETOM	FRMWRT(FM)	;MARK THIS FRAME AS NEEDING WRITING
	MOVE	C,(PT)		;GET VALUE OF LOCATION
	AND	C,MASK		;MASK OFF THE BAD PARTS
	OR	C,E		;REPLACE THEM WITH GOOD ONES
	MOVEM	C,(PT)		;AND SAVE THE CHANGE
	TRNN	F,SUB		;GOT HERE FROM SUBSTITUTE?
	POPJ	P,		;NO - JUST RETURN
	PJRST	PRINT		;PRINT CHANGED LINE (AND RANGE)

;SUBROUTINE TO DELETE LINE STRLOC, OR STRLOC-ENDLOC
;THIS JUST SHUFFLES THE FILE; THE ACTUAL DELETE IS DONE AT EXIT TIME

DELETE:	TLNE	F,RDO		;READ ONLY?
	JRST	RDOERR		;YES - ILLEGAL COMMAND
	MOVE	A,STRLOC	;COMPUTE NUMBER OF WORDS DELETED
	SUB	A,ENDLOC	;  (THE NEGATIVE, THAT IS)
	SOJ	A,		;..
	TRO	F,DLT!DL1!RTP	;SET FLAGS FOR EXIT AND INSERT TIMES
	PUSHJ	P,EXOUT 	;WRITE ANYTHING THAT NEEDS WRITING
	MOVE	WD,ENDLOC	;GET ENDING LOCATION
	CAMN	WD,FILSIZ	;DELETING TO END OF FILE?
	JRST	DELALL		;YES - HANDLE IT
	MOVEM	A,FRMNUM+1	;SAVE NUMBER DELETED FOR FILSIZ CALCULATION
	AOS	FILSIZ		;BUMP SIZE OF FILE
	LDB	FM,[POINT 29,STRLOC,28];GET BLOCK OF STARTING LOCATION
	LSH	WD,-7		;AND BLOCK OF END
	MOVE	D,FM		;SET UP NUMBERS OF FIRST WORD OF BLOCKS
	HRL	D,WD		;..
	LSH	D,7		;SHIFT BOTH INTO BLOCK NUMBERS
	AOJ	FM,		;GET THE REAL BLOCK NUMBERS
	AOJ	WD,		;..
	MOVEI	B,FRAME2-1	;GET ADDRESS OF FIRST FRAME
	HRRM	B,CCW		;SAVE IN CHANNEL COMMAND
	CAML	FM,FRMNUM+4	;DOES DELETE START IN LAST BLOCK?
	JRST	DELLST		;YES - READ IT, AND GO TO DELPAR
	USETI	IO,(FM) 	;POINT TO IT
	INPUT	IO,CCW		;READ IT
	CAMN	WD,FM		;ALL WITHIN THE SAME BLOCK?
	JRST	DELPAR		;YES - HANDLE IT

;HERE IF DELETE IS ACROSS BLOCKS. READ FIRST AND LAST ONES AND COLLAPSE
;INTO FRAME1 & FRAME2

	MOVNI	A,200		;SET UP CCW TO SECOND FRAME
	CAML	WD,FRMNUM+4	;DOES DELETE END IN LAST BLOCK?
	HLR	A,CCWL		;YES - GET NEG WORDCOUNT OF LAST BLOCK
	HRLI	A,FRAME3-1	;..
	MOVSM	A,CCWI		;SAVE IT
	USETI	IO,(WD) 	;POINT TO LAST BLOCK OF DELETE
	INPUT	IO,CCWI 	;READ IT IN
	HRL	A,ENDLOC	;GET END OF DELETE
	HRR	A,STRLOC	;AND START OF DELETE
	SUB	A,D		;RELATIVE TO THE START OF THE FRAME
	ADD	A,[FRAME3+1,,FRAME2];MAKE IT ABSOLUTE
	BLT	A,FRAME3+177	;ZAP THE HOLE SHUT (MOVING A BUNCH)
	HRRZ	D,A		;COMPUTE SIZE OF REMAINDER
	HLRZS	A		;..
	SUB	D,A		;..
	ADDI	D,400		;..
DELET2:	CAIL	D,200		;MORE THAN ONE BLOCK LEFT?
	PUSHJ	P,DELWRT	;YES - WRITE AND SHUFFLE
	MOVEM	D,FRMNUM	;SAVE SIZE OF GOOD STUFF
	CAML	WD,FRMNUM+4	;AT THE LAST BLOCK?
	JRST	DELONE		;YES - HANDLE SEPARATELY
	ADDI	D,FRAME1-1	;GET ADDRESS FOR INSERT-TYPE BLT
	MOVEI	A,FRAME1-1	;POINT TO FIRST FRAME
	HRRM	A,CCW		;  FOR INPUT
	HRRM	D,CCWI		;SAVE AS OUTPUT POINTER
	SOJ	FM,
	AOJA	WD,PUSHUP	;THREAD THROUGH THE REST OF THE FILE

;SUBROUTINE TO OUTPUT LOWER BLOCK OF >1 BLOCK GOOD STUFF

DELWRT: USETO	IO,(FM) 	;WRITE THE FIRST 200 WORDS
	OUTPUT	IO,CCW		;..
	MOVE	A,[FRAME3,,FRAME2]
	BLT	A,FRAME2+177	;PULL THE TAIL INTO THE 2ND FRAME
	SUBI	D,200		;FIX UP THE SIZE
	AOJA	FM,CPOPJ	;BUMP PTR AND RETURN TO FLOW

;HERE TO MOVE LAST BLOCK FROM FRAME5, INSTEAD OF READING IT

DELLST: MOVE	A,[FRAME5,,FRAME2]
	BLT	A,FRAME2+177	;MOVE THE LAST BLOCK INTO POSITION
				;AND FALL INTO DELPAR

;HERE IF DELETE IS ALL WITHIN THE SAME BLOCK

DELPAR: MOVE	A,STRLOC	;GET STARTING LOCATION
	HRL	A,ENDLOC	;  AND ENDING LOCATION, FOR BLT
	ADD	A,[FRAME2+1,,FRAME2];MAKE THE ADDRESSES ABSOLUTE
	SUB	A,D		;BUT RELATIVE TO THE START OF THIS BLOCK
	MOVE	C,ENDLOC	;GET END OF DELETE
	SUB	C,STRLOC	;MINUS START
	AOJ	C,		;IT WAS ONE TOO SMALL
	MOVEI	D,FRAME3-1	;GET ADDRESS OF LAST WORD OF FRAME
	SUB	D,C		;MINUS DELETE SIZE, GIVES LAST BLT WORD
	BLT	A,(D)		;PULL THE TOP DOWN
	HRRM	D,CCWI		;SAVE AS INPUT LOCATION
	SUBI	D,FRAME2-1	;GET SIZE OF THE GOOD STUFF
	MOVEM	D,FRMNUM	;SAVE FOR INSERT
	MOVEM	D,FRMNUM+1	;FOR FILSIZ ADJUSTER, TOO
	ADDI	D,FRAME1-1	;GET ADDRESS FOR INSERT-TYPE BLT
	MOVNI	A,200		;GET A NICE NUMBER
	ADDM	A,FRMNUM+1	;ADD IT TO FILSIZ ADJUSTER
	CAML	WD,FRMNUM+4	;IS THIS THE LAST BLOCK?
	JRST	DELON0		;YES - SET IT UP SPECIAL
	ADDM	A,CCW		;BACK UP A BLOCK FOR INPUT
	ADDM	A,CCWI		;  AND OUTPUT
	HRLM	A,CCWI		;ALSO SET UP WORDCOUNT FOR INPUT
	SOJ	FM,		;BUMP OUTPUT POINTER
	AOJA	WD,PUSHUP	;THREAD THROUGH REST OF FILE

;HERE TO SET UP TO OUTPUT LAST BLOCK

DELON0: MOVE	D,FRMNUM+1
DELONE: HLRO	A,CCWL		;GET NEGATIVE SIZE OF LAST BLOCK OF FILE
	SUB	A,D		;MINUS WORDS DELETED
	HRLM	A,CCW		;SAVE AS WORDCOUNT
	JRST	OUT2A		;OUTPUT AND FINISH

;HERE IF DELETE IS FROM SOMEWHERE TO THE END - JUST CHANGE SIZE OF FILE

DELALL:	ADDM	A,FILSIZ	;CUT FILSIZ DOWN TO SIZE
	JRST	WOTNOW		;THAT WAS SIMPLE, WASN'T IT?

;SUBROUTINE TO INSERT LINES FROM STRLOC TO ENDLOC, PUSHING THE
;REST OF THE FILE UP.  VALUE, IF GIVEN, IS PUT INTO STRLOC.

INSERT:	TLNE	F,RDO		;READ ONLY?
	JRST	RDOERR		;YES - ILLEGAL COMMAND
	MOVE	WD,STRLOC	;GET STARTING LOCATION (ALSO FOR GETCHG)
	AOS	FILSIZ		;BUMP SIZE OF FILE
	CAMLE	WD,FILSIZ	;IS STRLOC WITHIN OR AT TOP OF FILE?
	JRST	CMDERR		;NO - ERROR
	SKIPN	ENDLOC		;DID HE GIVE AN ENDING LOCATION?
	MOVEM	WD,ENDLOC	;NO - MAKE IT SAME AS START
	TRO	F,RTP		;SET TO GET A RETURN
	PUSHJ	P,EXOUT 	;WRITE ANYTHING THAT NEEDS WRITING

	MOVE	A,ENDLOC	;GET ENDING LOCATION
	SUB	A,WD		;GET NUMBER OF LINES TO INSERT
	AOJLE	A,CMDERR	;ADD ONE - ERROR IF NEGATIVE
	MOVEM	A,FRMNUM	;SAVE NUMBER FOR LATER

	LDB	FM,[POINT 29,STRLOC,28]
	AOJ	FM,		;GET NUMBER OF BLOCK FOR INSERT
	CAML	FM,FRMNUM+4	;INSERT TO LAST FRAME?
	PUSHJ	P,INSADJ	;YES - ADJUST THE CCW WORDCOUNTS
	USETI	IO,(FM)		;POINT TO IT
	MOVEI	C,FRAME1-1	;SET TO READ INTO FRAME1
	HRRM	C,CCW		;..
	INPUT	IO,CCW		;READ IN THE FRAME

	ADD	C,FRMNUM	;GET ADDRESS OF PLACE TO INSERT
	HRRM	C,CCWI		;SAVE AS PLACE TO ZAP THE INPUT
	MOVNI	D,200		;SET UP COUNTER - # WORDS TO MOVE
	LDB	C,[POINT 7,STRLOC,35];GET NUMBER OF STARTING WORD
	MOVEM	C,STRLOC	;SAVE FOR LATER
	ADD	D,C		;FINISH MAKING COUNTER
	MOVEI	PT,FRAME2	;POINT TO MOVE TARGET + 1
	ADD	PT,FRMNUM
	MOVE	C,[IOWD 1,FRAME2]

	SOJ	PT,		;POINT TO NEXT TARGET
	POP	C,(PT)		;ZAP A WORD
	AOJL	D,.-2		;LOOP THROUGH WORDS

	SUB	PT,FRMNUM	;POINT TO START OF NEW AREA
INSLUP:	SETZM	(PT)		;CLEAR OUT THE NEW PART
	PUSHJ	P,GTCHG0	;GET THE NEW FIRST WORD
	AOJ	PT,		;BUMP WORD POINTER
	CAME	WD,ENDLOC	;END OF INSERT?
	AOJA	WD,INSLUP	;NO - GET ANOTHER WORD

	MOVEI	WD,1(FM)	;SET UP USETI POINTER
	TRNE	F,LSI		;WORKING ON LAST BLOCK?
	JRST	OUT3		;YES - GO DIRECTLY TO LAST OUTPUT
	MOVEI	D,FRAME1-1	;GET ADDRESS FOR BLT BELOW
	ADD	D,FRMNUM	;..

OUT1:	USETO	IO,(FM)		;POINT TO THE BLOCK JUST READ
	OUTPUT	IO,CCW		;OUTPUT THE BLOCK
PUSHUP:	MOVE	C,[FRAME2,,FRAME1]
	BLT	C,(D)		;SHUFFLE THE HIGH WORDS DOWN
	CAMN	WD,FRMNUM+4	;AT LAST BLOCK?
	AOJA	FM,OUT2		;YES - HANDLE SEPARATELY
	USETI	IO,(WD)		;POINT TO INPUT FRAME
	INPUT	IO,CCWI 	;PUT NEXT BLOCK AT THE TOP
	AOJ	WD,		;BUMP BLOCK POINTERS
	AOJA	FM,OUT1		;NO - LOOP ON A COMPLETE BLOCK

;HERE TO HANDLE LAST BLOCK OF FILE

OUT2:	HLRO	C,CCWL		;GET NEGATIVE SIZE OF LAST BLOCK
	HRLM	C,CCWI		;SAVE AS NEW INPUT WORDCOUNT
	SUB	C,FRMNUM	;ADD IN NEW WORDS
	HRLM	C,CCW		;SAVE AS NEW OUTPUT WORDCOUNT
	USETI	IO,(WD)		;POINT TO IT
	INPUT	IO,CCWI 	;READ LAST BLOCK
OUT2A:	USETO	IO,(FM)		;POINT BACK TO LAST BLOCK
	OUTPUT	IO,CCW		;WRITE IT

INSOUT:	MOVE	A,FRMNUM	;GET NUMBER OF WORDS INSERTED
	TRZE	F,DL1		;CAME HERE FROM DELETE?
	MOVE	A,FRMNUM+1	;YES - GET NUMBER SET UP BY THAT ROUTINE
	ADDM	A,FILSIZ	;ADJUST SIZE OF FILE
INSOU1:	SETZB	B,C		;GET TWO ZEROS
	DMOVEM	B,FRMNUM	;CLEAR THE FRAME NUMBERS
	DMOVEM	B,FRMNUM+2	;  (THEY ALL MIGHT NEED TO BE RE-READ)
	MOVNI	A,200		;PUT WORDCOUNT BACK IN CCW
	HRLM	A,CCW		;..
	HRLM	A,CCWI		;..
	JRST	READHI		;RE-SET LAST BLOCK AND GET NEW COMMAND

;SUBROUTINE TO ADJUST THE CCW WORDCOUNTS FOR THE LAST FILE BLOCK

INSADJ: HLRO	C,CCWL		;GET NEGATIVE SIZE OF LAST BLOCK
	HRLM	C,CCW		;SAVE AS NEW INPUT WORDCOUNT
	SUB	C,FRMNUM	;ADD IN NEW WORDS
	HRLM	C,CCWI		;SAVE AS NEW OUTPUT WORDCOUNT
	TRO	F,LSI		;SET FLAG FOR LAST BLOCK
	POPJ	P,		;RETURN

;HERE IF FILE IS LESS THAN ONE BLOCK LONG

OUT3:	MOVEI	B,FRAME1-1	;OUTPUT FROM BEGINNING OF FRAME
	HRRM	B,CCWI		;..
	USETO	IO,(FM)		;POINT TO LAST BLOCK
	OUTPUT	IO,CCWI 	;DO THE OUTPUT
	JRST	INSOUT		;GET A NEW COMMAND

;SUBROUTINE TO FIND ALL OCCURRENCES OF A WORD OR HALF WORD
;(ENTRY FIND), ALSO TO SUBSTITUTE A GIVEN WORD OR HALF WORD
;FOR IT (ENTRY SUBST)

SUBST:	TLNE	F,RDO		;READ ONLY?
	JRST	RDOERR		;YES - ILLEGAL COMMAND
	TRO	F,SUB		;SET SUBSTITUTION FLAG (CLEARED AT WOTNOW)
	MOVE	E,VALUE1	;GET VALUE TO SUBSTITUTE
FIND:	TROE	F,RTP		;SET SEARCH FLAG - WAS IT ALREADY?
	JRST	FIND1		;YES - SKIP INITIALIZATION
	MOVE	A,VALUE 	;GET VALUE TO LOOK FOR
	MOVEM	A,OLVALU	;SAVE IT FOR NEXT TIME
	MOVE	A,MASK		;SAVE MASK FOR NEXT TIME, TOO
	MOVEM	A,OLMASK	;..
FIND1:	MOVE	B,(PT)		;GET VALUE OF LOCATION
	TDZ	B,MASK		;MASK OUT UNWANTED PARTS
	CAMN	B,VALUE 	;MATCH WITH GIVEN VALUE?
	JRST	FIND2		;YES - TELL HIM IT IS FOUND
	AOJ	WD,		;BUMP WORD ADDRESS
FIND0:	AOBJN	PT,FIND1	;LOOK THROUGH RANGE
	JRST	HDLCMD		;DONE - GET NEW IOWD, MAYBE

FIND2:	TRNE	F,SUB		;WANT A SUB?
	JRST	FIND2A		;YES - MAKE CHANGE AND PRINT IT
	PUSHJ	P,PRINT		;NO - PRINT THE VALUE
FIND2B: SOSE	ITERAT		;DECREMENT COUNTER - ZERO?
	AOJA	WD,FIND0	;NO - KEEP LOOKING
	MOVEM	WD,FILPTR	;YES - SAVE LAST HIT AS FILE PTR
	JRST	WOTNOW		;COMMAND DONE

FIND2A:	PUSHJ	P,CHANG0	;MAKE AND PRINT CHANGE
	JRST	FIND2B		;RETURN TO FLOW

;HERE ON CCL ENTRY, TO READ IN FILE SPECS FROM TEMP CORE

CCLSET: MOVE	A,[2,,TBLOCK]	;READ AND DELETE TMPCOR FILE
	TMPCOR	A,
	  JRST	NEWFIL		;(PROBABLY NO TMPCOR FILE - START FROM SCRATCH)
	HLLZS	IOFIL+1 	;CLEAR BITS OUT OF EXTENSION
	SETZM	IOFIL+2 	;AND NEXT WORD
	HLLZS	INFIL+3 	;SAME WITH INFILE SPECS
	SETZM	INFIL+4
	SETZB	INFIL+5
	MOVE	F,SAVEF 	;RESTORE FLAGS
	RESET			;CHUCK ALL BUFFERS AND PARTIAL FILES
	MOVE	P,[IOWD 20,STACK];SET UP STACK POINTER
	JRST	NEWFL1		;CONTINUE WITH THE OPENS

;SUBROUTINE TO OUTPUT HELP MESSAGE

HELP:	OUTSTR	HLPMES		;GIVE THE POOR GUY A HAND
	JRST	WOTNOW		;THAT'S ENOUGH

DEFINE HELL,<			;SUBTERFUGE TO SAVE CREF OUTPUT
HLPMES: ASCIZ	?COMMANDS TO BITED

C <range> [/ <value>]		CHANGE first word of <range>
D <range>			DELETE all words of <range>
E				EXIT, saving output file
F <range> / <value> [@ <number>] FIND all occurrences of <value> in <range>
  [<range>]			GOTO the word given by the RH of the first word
H				HELP (types this message)
I <range> [/ <value>]		INSERT new words in <range>
L <range>			LIST <range> to lineprinter
N				NEWFILE wanted; drop present file
O [<n>,...,<n> or A,H,I,S]	OUTFORMAT - output in special pattern
P [<range>]			PRINT <range> to tty
Q				QUIT, dropping everything
  <number>			RELOCATE line 0 as line <number>
S <range> / <value1> = <value2> [@ <number>]
				SUBSTITUTE <value1> for all <value2> in <range>
T				TYPE out the FILESPECS currently in effect
W				WRITE file; do not exit?
>
				;NOW LIST IT
	XLIST
	HELL
	LIST

;DISPATCH TABLE OF COMMANDS

CMDTBL: NOTYET
	BASE
	XWD	SPCFLG,CHANGE
	XWD	SPCFLG!DELTER,DELETE
	EXOUT
	XWD	SPCFLG!FINDER,FIND
	XWD	SPCFLG,GOTO
	HELP
	INSERT
	NOTYET
	NOTYET
	XWD	SPCFLG,LIST
	NOTYET
	NEWFIL
	OUTFMT
	XWD	SPCFLG!PRNTER,PRINT
	QUIT
	RELOK
	XWD	SPCFLG!FINDER,SUBST
	TSPECS
	NOTYET
	NOTYET
	WRITE
	NOTYET
	NOTYET
	NOTYET
QUERY:	ASCIZ /FILE=/
PROMPT: ASCIZ	/
*/
SIXPTR: POINT	6,B		;POINTER FOR NAME INPUT
FSXPTR: POINT	3,D		;POINTER TO A WORD OF OCTAL

;STORAGE

	XLIST			;PUT LITERALS AT END OF HIGH SEGMENT
	LIT
	LIST
	RELOC			;BACK TO LOW SEGMENT

STACK:	BLOCK	20		;PUSH-DOWN STACK
SPECS:	BLOCK	10		;FILE SPECS
;FILBAS: 0			;ABSOLUTE BASE OF EDITED FILE
FILPTR: 0			;POINTER TO POSITION IN FILE
RELFIL: 0			;RELOCATION FACTOR
COMAND: 0			;COMMAND LETTER
STRLOC: 0			;STARTING LOCATION OF CMND
ENDLOC: 0			;ENDING LOCATION OF CMND
VALUE:	0			;VALUE FOR CMND
VALUE1: 0			;VALUE TO BE SUBSTITUTED
MASK:	0			;MASK FOR WILD OCTAL BYTES
BYTTAB: EXP 11,4,1,4,22,-1	;5 WORDS FOR BYTE SIZES (+1 FOR END MARKER)
				;START WITH INSTRUCTION FORMAT
OLLINE: 10			;NUMBER OF LINES PRINTED FOR THE LAST P CMND
OLVALU: 0			;WORD FOUND FOR THE LAST F COMMAND
OLMASK: 0			;MASK USED FOR THE LAST F COMMAND
OLDSUB: 0			;NEW WORD FOR LAST S COMMAND
ITERAT: 0			;NUMBER OF COPIES OF WORD TO BE FOUND
NUMSIZ: 0			;NUMBER OF DIGITS FOR WORD NUMBER OUTPUT
RADIX:	10			;LINE NUMBER RADIX - STARTS AT 8

FRMACS:	3			;NUMBER OF NEXT FRAME TO USE
FRAME1:	BLOCK	200
FRAME2:	BLOCK	200
FRAME3:	BLOCK	200
FRAME4:	BLOCK	200
FRAME5:	BLOCK	200		;ALWAYS HAS LAST BLOCK OF FILE
FRAMES:	FRAME1
	FRAME2
	FRAME3
	FRAME4
	FRAME5
FRMWRT:	BLOCK	5
FRMNUM:	BLOCK	5		;BLOCK FROM HERE TO FILSIZ
IOFIL1:	BLOCK	4		;  CLEARED BY BLT AT START

IOFIL:	BLOCK	4
INFIL:	5
	BLOCK	4
FILSIZ:	0
INBLK:	16			;DUMP MODE
	SIXBIT	/DSK/
	0
IOBLK:	16
	SIXBIT	/DSK/
	0
SAVEF:	0
	EXP	0,0,0

LPTBLK:	0
	SIXBIT	/LPT/
	XWD	LPTBF,0
LPTFIL:	BLOCK	4
LPTBF:	BLOCK	3

CCW:	XWD	-200,0		;CHANNEL COMMAND LIST FOR NORMAL I/O
	0
CCWI:	XWD	-200,0		;SECOND CCL FOR INSERT AND DELETE
	0
CCWL:	XWD	-200,0
	0

TBLOCK: SIXBIT	/BTD/
	IOWD	24,IOFIL

	END	NEWFIL

   ^ y_