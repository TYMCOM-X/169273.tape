LALL
TITLE	TECO   VERSION 23 -- EXTENDED		
SUBTTL	TEXT EDITOR AND CORRECTOR	RC CLEMENTS/PMH/CAM/CJJ/MFR

;********************************************************
;*                                                      *
;*      THIS IS NOT A DEC PROGRAM (ANY MORE !!)         *
;*      MODIFIED AT THE COORDINATED SCIENCE             *
;*      LABORATORY 1974-1975 BY CHARLES J. JACOBUS      *
;*        FURTHER MODIFICATIONS BY MIKE RUDE            *
;*                                                      *
;*      NO RESPONSIBILITY IS TAKEN FOR PROPER           *
;*      FUNCTIONING OF THE FOLLOWING SOFTWARE           *
;*      (NOTE HOWEVER THAT WE WOULD APPRECIATE          *
;*      INFORMATION CONCERNING ANY PROBLEMS THAT        *
;*      MIGHT OCCUR DURING OPERATION)                   *
;*                                                      *
;*      MODIFICATIONS MAY CAUSE THIS PROGRAM TO         *
;*      FAIL IF NOT A DISK SYSTEM                       *
;*                                                      *
;********************************************************
MEDIT==32		;LOCAL EDIT NUMBER
EDIT==162
VERSION==XWD 602302,EDIT+<MEDIT*1000>
DEFINE VPRINT<
IFGE SHORTV,<
VERS1==VERSION_<-41>
VERS2==VERSION_<-30>&777
VERS3==VERSION_<-22>&77
	VPRNT2 \EDIT,\VERS1,\VERS2,VERS3,\MEDIT
>>
DEFINE VPRNT2(AA,BB,CC,DD,FF,%EE)<
	PUSH	P,[POINT 7,VMESS1]
	PUSHJ	P,STRGPZ
	IFN	DD,<OUTCHR VMESS3>
	PUSH	P,[POINT 7,VMESS2]
	PUSHJ	P,STRGPZ
	JRST	%EE
VMESS1:
IFE SHORTV,<
	ASCIZ	/TECO eXtended Version 'CC'/
>
IFN SHORTV,<
	ASCIZ	/TECOx ['CC'/
>
VMESS2:
IFE SHORTV,<
	ASCIZ	/('AA')-'BB'<'FF'>
/>
IFN SHORTV,<
	ASCIZ	/('AA')-'BB'<'FF'>]
/>
VMESS3:
	IFN	DD,<EXP DD+"A"-1>
%EE:>

;THIS HAS BEED EXTENSIVELY MODIFIED BY CHARLES JACOBUS AT THE
;COORDINATED SCIENCE LABORATORY, UNIVERSITY OF ILLINOIS
;IF PROBLEMS ARE ENCOUNTERD ... SCREW IT !!
;
;EDIT 114-	REMOVES CODE WHICH CHANGED BAK FILE PROTECTION TO
;	STANDARD, CHANGES SEARCH COMMAND TO ACCEPT LOWER CASE
;	FS AND FN, PROVIDES FOR $ IN Q REGISTER BY RETURNING
;	TO NEXT LEVEL WHEN $ SEEN RATHER THAN REINITIALIZING
;	AREAS AFFECTED: GO, RCH2, ALTMOD, MAC,BKCLS2
;		FILSP2, FCMD, EQM
;[BJ 3-11-74(INSERTED CODE TO GIVE BACKUP FILE SAVE PROTECTION AS
;ORIGINAL FILE)]
;	BJ SPR# 10-11,045 DATED DEC 15 '73
;EDIT 115- FIXES PERTAIN TO LINE SEQUENCE NUMBER PROCESSING
;	CHANGES INSERTION OF 5 SPACECES AND TAB
;	CHANGES SEQ# CHECK SO THAT 5 SPACES AND TAB ARE
;	 ACCEPTED AS LINE SEQ# (THIS ELIMINATES THE INSERTION
;	 AFTER THE FIRST TIME AND ALLOWS THEM TO BE REMOVED
;	 USING THE /SUPLSN SWITCH)
;	AREAS AFFECTED:PPA06, PPA08
;	BJ SPR# 10-11,265 DATED DEC-1 '73
;EDIT 116- CHANGES GARBAGE COLLECTION ROUTINE TO CHECK FOR
;	ANYTHING TO SAVE PRIOR TO ATTEMTING A BLT.
;	AREAS AFFECTED: GCS2
;	BJ SPR# 10-11,361 DATED DEC-1 '73
;EDIT 117-CHANGES SEARCH ROUTINE TO PROVIDE PROPER OPERATION
;	OF ^S, TECO'S "WILD DELIMITER", WHEN THE DELIMITER
;	IS THE FIRST BUFFER CHARACTER.
;	AREAS AFFECTED: S1,S4A,BCOUNT [ED#117]
;	BJ SPR# 10-11,627 DATED DEC 15, '73
;EDIT 118- CHANGES OPERATION OF ET COMMAND TO CONFORM TO 
;	DOCUMENTATION.  ET SHOULD SUPPRESS CASE FLAGGING.
;	AREAS AFFECTED: TYO
;	BJ SPR# 10-11,425 DATED DEC 15 '73
;EDIT 119- PROVIDES WARNING MESSAGE WHEN TECO
;	DETECTS SEQUENCED FILE WITH NO LSN SWITCHES,
;	ADDS CLEAR OF OUTPUT BUFFER PRIOR TO PACKING
;	TO INSURE AGAINST SPURIOUS BIT35 SETTING,
;	AREAS AFFECTED: YNKSEQ,PPA05
;	BJ SPR# 10-11,438 DATED DEC 15, '73
;SPR# 10-13,203 REMOVED INSERT AT PPA05+11 WHICH CLEARED BUFFER.
;BJ 7 24 74
;EDIT 122- FIXES HP COMMAND TO SET BIT 35 FOR FIRST
;	LINE NUMBER IN THE BUFFER.
;	AREAS AFFECTED:  HOLE
;	BJ SPR# 10-9935  DATED DEC 15 '73
;EDIT 123-REDEFINES OUTPUT BUFFERS AFTER SECOND OPEN FOR
;	FILES WHICH ARE SUPERSEDED.  THIS FIXES THE "ADDRESS
;	CHECK FOR DEVICE DSK" PROBLEM
;	AREAS AFFECTED: OPNW3
;	BJ SPR# 10-11,890 DATED DEC 15 '73
;EDIT 124- REMOVES THE %SUPERSEDING EXISTING FILE MESSAGE
;	FOR NON-DIRECTORY DEVICES AND LIB: FILES.
;	AREAS AFFECTED: OPNW2,OPNW3
;EDIT 131- CORRECTS PORTION OF EDIT 124 WHICH CHECKED WRONG STATUS
;	BIT, AREAS AFFECTED: OPNW3B
;EDIT 125- CORRECTS "ILL MEM REF AT USER PC 403647" BY ADDING
;	A CHECK FOR SHORT ERROR MESSAGES USED PRIOR TO
;	PERFORMANG CORE CONTRACTION
;	AREAS AFFECTED: ERRP7
;EDIT 133- MAKES EB WORK PROPERLY FOR FILES OUTSIDE USERS PPN,
;	SHOULD JUST DO ER/EW UNDER THIS CONDITION INSTEAD OF TRYING
;	TO RENAME FILES.
;	AREAS AFFECTED:	EBAKUP
;EDIT BJ02-ALLOW USEAGE OF Q-REGISTERS WITH ^E,
;	I.E. S^E<QI>.
;	AREAS AFFECTED: CNTLEB
;	BJ 3-11-74
;EDIT 132- ADDS CHECK FOR DATA IN Q-REGISTER PRIOR TO ALLOWING
;	INCREMENT (% COMMAND) AND GENERATES ERROR MESSAGE IF
;	ATTEMPTED WITH TEXT.  AREAS AFFECTED:  PCNT
;	BJ SPR# 10-12,334 ER
;EDIT 135- REPLACES EDIT 132 TO PUT ERROR MESSAGE IN STANDARD FORM
;	AND PROVIDE FOR CHECK ON Q COMMAND AS WELL AS %
;	ALSO PROVIDES PROPER OPERATION WITH A NEGATIVE INTEGER.
;	 AREAS AFFECTED: PCNT, QREG
;EDIT BJ-4-10-74
;	TECO HAS BEEN CHANGED TO PROTECT USERS FROM ACCIDENTLY
;TYPING A "Y" OR "_" COMMAND AND DESTROYING THEIR PROGRAM.
;
;IF THE FOLLOWING CONDITIONS EXIST:
;  1) AN EB WAS DONE. (I.E. TECO COMMAND)
;  2) IT IS THE FIRST TIME IN THIS COMMAND. (SINCE LAST $$)
;  3) THE CURRENT PAGE IS NOT BLANK
;  4) NO ^B COMMAND HAS BEEN TYPED (SEE END OF NOTICE)
;AND YOU DO A "Y" OR "_", TECO WILL ASK:
;
;"_" DESTROYS BUFFER, ARE YOU SURE?("Y" OR "N"):
;
;ANSWER WITH A SINGLE CHARACTER--A Y FOR YES, ANYTHING ELSE FOR NO.
;
;	A ^B COMMAND WILL SUPPRESS THIS FEATURE.  A SECOND
;^B WILL NULLIFY THE FIRST ^B.
;AREAS AFFECTED LARR,YANK,COMMAND DISPATCH TABLE
;
;EDIT 1-CJJ-8-9-74
;	ADDED CHECKPOINTING, TOP LEVEL COMMAND STRING, INCREMENTAL BACKUPS
;	AREAS AFFECTED--
;	DEFINES, START UP INITIALIZATION, TTY INPUT ROUTINES (TYI),
;	COMMAND DECODER (MAIN ONE AT CLIS:), E COMMAND PROCESSOR
;	(ECTABL:, FINIS1:, EBAKUP:, BAKCLS:), PREVIOUS PATCH
;	(CHKYLA:), ERROR PROCESSOR (ERRP0:)
;
;	COMMANDS ADDED:
;		EA -- SAME AS EB EXCEPT RENAMES BACKUP TO .Z## IN LUE
;			OF .BAK AFTER A SCAN THRU THE UFD ON THE
;			APPROPRIATE PACK SO AS TO TAKE THE NEXT ## IN
;			SEQUENCE
;		EP -- LIKE EX WITHOUT EXITING (FILE IS FLUSHED THRU)
;		ED -- LIKE :
;			^C
;			START
;		EE -- LIKE EP FOLLOWED BY 
;			^C
;			START
;	FIXES -- PREVIOUS PATCH VERIFY NOW THRU TECO'S INPUT ROUTINES
;		SO AS TO HAVE VERIFY CHECKPOINTED
;		ALSO NOW ACCEPTS UPPER AND LOWER CASE Y AS AFFIRMATIVE
;	OTHER -- TECOX USES FILE SYS:(OR DSK:)TECOX.TAB TO INIT
;		AUTOFS, TYCASF, AND ERRLEN. SEE COMMENTS IN TECOX.TAB
;		FOR TABLE ENTRY FORMAT.
;
;EDIT 2-CJJ-10-15-74
;	EP MODIFIED TO NOT CANCEL COMMAND STRING...JUST CLOSES INPUT
;	AND OUTPUT
;	NEW Q-REGISTERS ADDED 
;		ON N,IMR (M COMMAND)
;		Q-REG * GETS N (NUMERIC)
;		Q-REG + GETS I (NUMERIC)
;		AFTER ER<FILE-SPEC><ALT>
;		QREG - GETS THE <FILE-SPEC><ALT> STRING (ALSO AFTER EA AND EB)
;		AFTER EW<FILE-SPEC><ALT>
;		QREG , GETS THE <FILE-SPEC><ALT> ... AFTER EA OR EB GETS
;			#EB#<ALT>
;		AFTER EACH COMMAND STRING Q-REG . GETS THE OLD COMMAND STRING
;			(AS THO * COMMAND TYPED)
;		Q-REG / ADDED BUT NOT ANY DIFFERENT FROM 0-9 AND A-Z
;
;
;EDIT 3-CJJ-10-28-74
;	MODIFIED SO THAT DURING CHECKPOINT UPDATE ^O TURNS OFF
;	OUTPUT UNTIL UPDTAE THRU
;	EL COMMAND ADDED--LIKE ES ONLY TURNS OFF AND ON
;		LINE NUMBER PRINTING (RELATIVE) ON DISPLAYS
;		FOR NT COMMAND...TURNS ON WITH AUTO TYPEOUT
;		AFTER SEARCH AS SPEC IN INIT FILE
;
;EDIT 4-CJJ-11-10-74
;	CHANGED SO DEFAULT OUTPUT PROTECTION CODE IS <155>.
;EDIT 5-CJJ-4-6-75
;	FIXED SO THAT CHECKPOINT GOES ON FROM CCL ENTRY
;	SO THAT AFTER RESTART CHECKPOINT GOES ON (APPENDING TO OLD
;		CHECKPOINT FILE)
;	NEW INIT FILE FORMAT INSTITUTED (LIKE CHECKPOINT SORT OF)
;	CHANGED /R SO THAT DOES NOT CAUSE PRINT ... ONLY MOVES POINTER TO
;		END OF BUFFER
;	THIS ONE SHOULD BE TECO COMPATIBLE
;	ON RESTART COMPLETE CHECKPOINT FILE NAME MAY BE GIVEN
;	EF AND EX HAVE BEEN CHANGED SO THAT A FILE IF GIVEN
;		IS ASSUMED TO BE A PROGRAM THAT IS TO BE RUN
;		IF NO FILE GIVEN THEY WORK AS ADVERTIZED
;		(TOO BAD I CAN'T SPELL)
;	TTY LINE CHARACTERISTICS HAVE BEEN GRABBED IN A DIFFERNT SPOT
;		SO THAT LC AND UC MAYBE CHANGE AFTER A ^C AND
;		WILL BE REFLECTED DURING THE FOLLOWING COMMAND STRING
;		INSTEAD OF THE NEXT
;	MAGTAPE EX ING HAS BEEN FIXED
;EDIT 6-CJJ 4-11-75
;	SFD OPEN AND CLOSING ADDED
;	FOR E COMMANDS AND RESTART
;EDIT 7-CJJ 4-19-75
;	ADDED OPTION TO ALLOW ^H TO BE USED AS RUBOUT
;	FIXED PROB WITH SPECIAL Q-REGS AND GARGAGE COLLECT
;	ADDED EN SO THAT ERS WITH ERRORS CAN BE TRAPPED
;	EN=0 MEANS DO ER ERRORS, =1 MEANS RETURN FILE STATUS ON ERROR
;EDIT 8-CJJ 4-25-75
;	ADDED Q-REGS ) AND ( ... STARTED USING /
;	) FOR MACRO EXECUTED AFTER <ALT><ALT>
;	( FOR MACRO EXECUTED ON SUCCESSFUL SEARCHES
;	/ FOR TEXT IN EC
;	ADDED EC FOR FILE RENAME/DELET ... NO FILE NAME SPECIFIED
;	MEANS DELETE THE LAST ER'ED FILE
;	AFTER THIS OP NO INPUT FILES ARE OPEN
;	ADDED F= ... <ALT>
;		DOES MATCH OF ... TO BUFFER AS IN SEARCH BUT
;		HOOKS THE POINTER.. IF SUCCESS POINTER IS AFTER
;		MATCHED STRING. IF FAILURE POINTER DOES NOT MOVE
;		: ARE OK WITH THIS COMMAND AS IN FN FS S N AND _
;EDIT 9-CJJ 4-25-75
;	ADDED /Q TO TURN OFF T COMMANDS ON RESTART
;EDIT 10-CJJ 4-26-75
;	ADDED N^T TO TYPE N AS IMAGE OUTPUT CHARACTER
;	^T STILL SAME
;	ADD "$ ... ' THIS IS AN ELSE CLAUSE FOR ALL OTHER " ... ' COMMANDS
;	ADD Q-REG ' TO INDICATE ITERATION LEVEL (+1 FOR < -1 FOR >)
;		IS CLEAR AT COMMAND LEVEL
;EDIT 11-CJJ 4-27-75
;	ADDED NW WHERE N IS AN ARGUMENT.
;		N=0 TEST FOR TTY OUTPUT BUFFER EMPTY (TERMOP)
;			RETURN -1 AS VALUE IF IS EMPTY OR
;			THIS TERMOP IS NOT IMPLEMENTED
;			RETURN 0 IF NOT EMPTY
;		N=-1 TEST FOR TTY INPUT BUFFER EMPTY (TERMOP)
;			RETURN -1 IF IS OR TERMOP IS NOT
;			IMPLEMENTED
;			RETURN 0 IF NOT EMPTY
;		N=POSITIVE NUMBER, HIBERNATE FOR N MILLISEC
;			(IF NO HIBER THEN USES SLEEP)
;	ADDED W WITH NO ARGUMENT
;		INSERTS BEFORE THE POINTER THE NEXT COMMAND
;		CHARACTER AFTER THE M (MACRO) COMMAND
;		IN THE LAST MACRO CONTEXT. I.E.
;		MS ... $ MAY CAUSE MACRO S TO READ ... BY
;		SUCCESIVE W COMMANDS. THIS ALLOWS IMPLEMENTATION
;		OF STRING MACROS.
;	ADDED -2EU FOR SETTING LC FLAGGING REGARDLESS OF
;		TT LC COMMANDS
;		2EU FOR SETTINT UC FLAGGING REGARDLESS OF
;		TT LC COMMANDS
;EDIT 12-CJJ 5-6-75
;	REMOVED Q-REGS ()' REPLACED BY &S &D AND &L
;	ADDED &0-&9, &A-&Z THESE TO BE USED FOR ADDITIONAL
;	SPECIAL VALUES AND TEMPS FOR DISPLAY PURPOSES
;		&A -- CONTAINS LAST COMMAND ISSUED NOT CONTAINING
;			AN M&B OR AN M&A
;			THIS IS THE "AGAIN" REGISTER
;		&B -- CONTAINS THE STRING LAST IN &A
;			THIS IS ONE LEVEL OF BACKUP FOR &A
;		&C -- USED IN DISPLAY MACROS FOR THE CURSOR MACRO
;		&D -- THIS MACRO GETS EXECUTED EVERY SUCCESSFUL COMMAND
;			SEQUENCE ($$). IF IS SET TO 0 IS NOT
;			EXECUTED
;		&E -- THIS GETS THE NUMERIC ATTACHED TO
;			THE /E:NNN SWITCH (NNN IS + OR -)
;		&F -- THIS COUNTS OCCURANCES OF FORM FEED
;		&I -- THIS HOLDS THE ITERATION COUNT.
;			INCREMENTED FOR EACH < AND DECR FOR EACH >
;			ZEROED AT COMMAND LEVEL
;		&J -- THIS HOLDS THE MACRO DEPTH COUNT.
;			COPIED FROM AN INTERNAL VALUE AFTER EACH
;			M COMMAND. INCREMENTED FOR EACH MACRO CALL.
;		&K -- THIS GETS ANY TEXTED KILLED OR DELETED FROM
;			THE TEXT BUFFER IN A D OR K COMMAND
;		&L -- THIS COUNTS LINE FEEDS
;		&M -- THIS GETS THE MACRO TO BE EXECUTED FOR THE /E
;			SWITCH IN MASTER COMMAND STRING
;		&N -- THIS GETS THE LAST SEARCH ARGUMENT. IF SET
;			TO A STRING VALUE AND S$$ COMMANDS WILL
;			USE THE VALUE IN THE REGISTER.
;			IF SET TO 0 S$$ USES VALUE KEPT
;			INTERNALLY
;		&O -- THIS GETS SET TO THE COMMAND LEVEL CHARACTER COUNT
;		&P -- USED AS THE PARAMETER REGISTER FOR THE
;			AUTO TYPEOUT MACRO. MAY BE LOADED WITH THE
;			/P:NNN SWITCH (NNN IS + OR - NUMBER)
;		&R -- THIS GETS INCREMENTED FOR EACH VERTICAL
;			TAB PRINTED
;		&S -- THIS IS EXECUTED ON EVERY SUCCESSFUL SEARCH IF
;			IT CONTAINS TEXT. (THE AUTOTYPEOUT MACRO)
;		&T -- THIS CONTAINS THE LAST CHARACTER STRING TO BE
;			INSERTED INTO THE TEXT BUFFER
;			IT IS SET BY THE INSERT COMMAND (I ... $,
;			NNNI$), THE W COMMAND, THE FW COMMAND,
;			THE FS COMMAND AND THE FN COMMAND (SECOND
;			ARGUMENT OF THE F CLASS
;			SEARCH COMMANDS).
;		&U -- THIS CONTAINS THE SEARCH FLAG. -1 IF
;			THE LAST SEARCH SUCCEEDED
;			0 IF FAILED. MAY BE SET.
;		&V -- THIS IS USED TO HOLD THE LENGTH
;			OF THE LAST TEXT ARGUMENT PROCESSED
;			(VCMD IF ONE)
;		&W -- THIS USED BY THE DISPLAY MACRO TO HOLD
;			THE LOW END OF THE DISPLAY WINDOW POINTER
;		&X -- THIS USED BY THE DISPLAY MACRO TO HOLD
;			THE HIGH END OF THE DISPLAY WINDOW POINTER
;		&Y -- THIS GETS THE CURRENT PAGE WHEN A Y COMMAND
;			IS DONE (NOT AFTER A P OR A _)
;		CURRENTLY &G, &H, &Q, AND &Z
;		ARE NOT BEING USED BUT THESE ARE RESERVED FOR
;		FUTURE EXPANSION
;		&0-&9 ARE FREE FOR USER PURPOSES
;	ADD FW
;		LIKE W WITH NO PARM EXCEPT HAS PARM
;		0=GET NEXT CHAR AT SAME LEVEL
;		POS N=GET CHAR FROM LEVEL N ON STACK
;			(COMMAND LEVEL IS 1 OR FIRST ON STACK)
;		NEG N=GET CHAR FROM LEVEL N DOWN FROM CURRENT
;			(I.E. -1FW IS IDENTICAL TO W)
;	ADD FO
;		ARGUMENT IS A NUMBER TO BE TYPED IMAGE (LIKE N^T ABOVE
;	N^T REMOVED DUE TO INCOMPATIBLITY WITH DEC TECO
;	ADDED :N= AND :N==
;		SAME AS N= AND N== (N IS NUMBER) EXCEPT THAT
;		NO CR, LF IS PRINTED FOLLOWING NUMBER OUTPUT
;EDIT 13-CJJ-7-17-75
;	ADDED @ FILES IN COMMAND STRING
;		SAME AS /C EXCEPT:
;		ON ERRORS REVERTS TO CONSOLE
;		DOES NOT CONTINUE THRU EX$ TYPE COMMANDS
;	ADDED /H AND /D CODE TO ALLOW SPECIFICATION
;		OF ANY FILE TO BE READ
;		/H FILE DEFAULTS TO HLP:TECOX.HLP THEN SYS:TECOX.HLP
;		/D FILE DEFAULTS TO DOC:TECOX.DOC THEN SYS:TECOX.DOC
;EDIT 136- CLEAN UP EDIT 123, REMOVE ROUTINE NOT NEEDED WITH EDIT 133
;	MAKE DEVICE DTA WORK PROPERLY
;	OPNRD,EBAKUP,OPNWR,BAKCLS
;EDIT 137- ELIMINATES OLD ALTMODE CONVERSION TO 33 IF TT NO ALTMODE SET
;	ALTIN, TYI
;EDIT 140- MAKE NNN<Y> MORE EFFICIENT (KEEPING MY OWN DEBUG SWITCH)
;	TECO,LIS03,YANK2,YNKSEQ,CMDBFR
;EDIT 141- REMOVE UNNEC. PORTION OF EDIT 121, 130. WORK ON LINE SEQ. PROC.,
;	PPA04, PPA05
;EDIT 142- FIXED DISPATCH TABLE ENTRIES TO PRESERVE NUMERIC ARGS FOR CR AND LF
;	DTB
;EDIT 143- MAKE CODE FOR Q-REG MORE EFFICIENT
;	QREG,QTXTST
;EDIT 144- MAKES EH COMMAND USE STACK PROPERLY
;	ERRSET
;EDIT 145- MAKE EW TO OTHER PPN WORK
;	OPNW33
;EDIT 146- MAKES EB'S WORK FOR ERSATZ DEVICES
;	EBAKU2
;EDIT 147- CHANGES OPEN EB COMMAND TO PHYS ONLY. FOR PROPER RENAME SEQ
;	OPNW4, BKCLS4
;EDIT 150- MODIFY LSN PROC. TO HANDLE SOS PAGE MARKS
;	PPA08,PPA13,YANK5
;EDIT 151- BLABLA, NOT DONE
;EDIT 152- FOOBAR, THIS ALREADY FIXED
;EDIT 153- SPECIAL CHECK FOR ERSATZ DEVICES, TO INSURE SUPERSEDING MESSAGE APPEARS
;	FILSP7
;EDIT 154- MAKE EDIT 147 MORE EFFICIENT
;	OPNW44
;EDIT 155- DELAY CLEARING EB AND OUTPUT OPEN FLAGS ON EX IF ERROR
;	OCCURS, CLOSEF
;EDIT 156- ERROR MESSAGE IF TAG TOO LONG
;	OG1
;EDIT 157- ???? RESERVED?
;EDIT 160- FIX LOOP IF 3EH SET AND ERROR FILE NOT FOUND
;	ERRP5
;EDIT 161- CHANGES CRAP ON STACK FOR <>
;	DEC CHANGED LSSTH AND INCMA2, I HAD TO FIX FW, AND W COMMANDS
;EDIT 162- FIXES PROB CAUSED BY EDITS 147,154, AND 160.
;	ERRP5,OPNW44,BKCLS4
;EDIT 14-CJJ-29-MAY-75
;	FIXED EDIT 150. WOULDN'T WORK ON BASIC FILES SO
;	REVERTED IT MOSTLY BACK TO EDIT 115 (WITH SOME MODS)
;EDIT 15-CJJ-6-9-75
;	GOT BLOWN. FIXED UP LINE NUMBER JAZZ. USE EQ TO SET SEQUENCE
;	INCREMENT. EV IF SET MAKES EB LIKE EA AND EA LIKE EB.
;	SOS PAGE MARKS TO FF IF /SUPLSN
;	FF TO PAGE MARKS IF /GENLSN
;	/XBASIC IF OUTPUT BASIC FORMAT LINE #
;		(OR .BAS EXT)
;EDIT 16-CJJ-17-JUN-75
;	ADDED SWITCH.INI COMPATIBILITY FOR INITIAL INPUT COMMAND STRING
;	AFTER <TERM>TECOX TEXT TO NEXT TERMINATOR IS APPENDED
;	TO END OF LINE TYPED
;EDIT 17-CJJ-24-JUN-75
;	ADDED CODE TO ALLOW TECO TO BE OPTIONALLY STARTED
;	DIRECTLY FROM THE MONITOR RATHER THAN THRU COMPIL
;	REMOVED DEBUGGING SWITCH BECAUSE CAN DEBUG USING
;	/SYMSEG:HIGH
;EDIT 20-CJJ-26-JUN-75
;	FIXED ANNOYANCE DUE TO DEFAULT EXTENTIONS IN SWITCH.INI
;	FIXED SO /C COMMAND STRINGS DON'T GO TO EDS
;EDIT 21-CJJ-28-JUN-75
;	PUT IN FIX SO THAT CHECKPOINT OCCURS ON $$, LF, AND DISK BUFFER FULL
;	TIRED OF LOSING JUNK IN THE MIDDLE OF AN INSERT
;EDIT 22-CJJ-2-JUL-75
;	ADDED /F TO TURN OFF ALL SPECIAL Q-REGISTER JAZZ
;	ALSO DIDDLE Q-REG STUFF SO THAT D
;	DO NOT LOAD ANY (&K)
;	OPTIONAL GRABS SWITCH FROM TEMCORE
;	(IF TEMP IS SET)
;EDIT 23-CJJ-17-JUL-75
;	ADDED /T TO CONTROL READING OF TAB FILE
;	OLD /T IS NOW /O
;	ADDED /- SYNTAX FOR INVERTING SWITCH VALUES
;	/-- SAME AS SIMPLE /
;	INVERTED MEANINGS OF SWITCHES WHEN APPROP. BECAUSE OF NEW SYNTAX
;		/W MEANS READ SWITCH.INI
;		/T MEANS READ TECOX.TAB FIRST
;		/L MEANS READ TECOX.TAB FROM USER FIRST
;	CAN SET DEFAULT VALUE OF SWITCH BY SETTING
;	<SWITCH LETTER>SWTCH TO 1 (ON) OR 0 (OFF)
;EDIT 24-CJJ-29-JUL-75
;	FIXED CORE MESSAGE SO THAT THE HIGH SEGMENT WILL NOT GET ZAPPED
;	UPPED LOWSEGMENT SIZE SO COULD FIT A REASONABLE PAGE
;	MADE &9 THE USER'S PROG #
;		&8 USER'S PROJ #
;EDIT 25-CJJ-30-JUL-75
;	FIXED ^O PROB, AND SWITCH DEFAULTS
;		&7 USER'S JOB NUMBER
;EDIT 26-CJJ-10-NOV-75
;	FIXED CORE MESSAGES ON INPUT. FIXED ILLEGAL MEMORY REF. IF
;	/A'ING A LARGE FILE
;EDIT 27-CJJ-9-DEC-75
;	FIXED PROBLEM WITH LONG STRINGS FROM EDS, CHANGED DEFAULT
;	HIGSEG TO 740000 SO VMDDT COULD LOAD
;EDIT 30-CJJ-13-JAN-76
;	FIXED FUNNY PROBLEM IT HAD WHEN THE ] WAS LEFT OFF THE INPUT
;	STRING
;EDIT 31-CJJ-11-FEB-76
;	FIXED EL SO THAT -2T AT BUFFER START PRINTS NO LINE NUMBER
;	FIXED SO " ... " FORM OF MACRO PARAMETERS GO INTO EDS TERMINATED
;	WITH $"$ SO THAT WON'T SCREW UP AS BAD ON NEXT TECO COMMAND
;	CHANGED BACK .CHP FILE STUFF SO USES DEFAULT PATH LIKE .TMP
;	FILES IN CCL LINKAGE STUFF. THIS IS PROBABLY THE WRONG WAY BUT
;	WE SHOULD BE CONSISENT
;
;
;
;COPYRIGHT 1970,1971,1972, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
;DEFAULT DEFINITIONS FOR ASSEMBLY SWITCHES & PARAMETERS:

IFNDEF NOFMES,  <NOFMES==0>	;YOU FIGURE OUT THIS ONE
IFNDEF SHORTV,  <SHORTV==0>	;LONG VERSION MESSAGE
IFNDEF PROTCD,	<PROTCD==047>	;DEFAUTPUT PROTECTION CODE
IFNDEF PROTCB,	<PROTCB==057>	;DEFAULT BACKUP FILE PROTECTION CODE
IFNDEF PROTSF,  <PROTSF==775>	;DEFAULT SFD CREATION PROTECTION CODE
IFNDEF CCL,	<CCL==1>		;CCL CAPABILITY
IFNDEF TEMP,	<TEMP==1>		;TMPCOR UUO CAPABILITY
IFNDEF PDP6,	<PDP6==0>		;PDP-10 VERSION
IFNDEF ERRMSG,	<ERRMSG==2>	;ERROR LEVEL
IFNDEF AUTOFS,	<AUTOFS==0>	;PRINT OUT AFTER SEARCH
IFNDEF TYCASW,	<TYCASW==0>	;LOWER CASE FLAGING
IFNDEF NORUNS,	<NORUNS==0>		;RUN UUO CAPABILITY
IFNDEF SRCHSW,	<SRCHSW==0>		;DEFAULT PREVAILING SEARCH MODE IS ACCEPT
					;EITHER LC OR UC ALPHABETICS AS A MATCH
IFNDEF TTBSIZ,  <TTBSIZ==20>	;TTY BUFFER SIZE
IFNDEF BUFSIZ,	<BUFSIZ==^D128>		;128 WORD I/O BUFFERS
IFNDEF LPDL,	<LPDL==120>		;80 WORD PDL
IFNDEF LPF,	<LPF==40>		;32 WORD Q-REGISTER PDL
IFNDEF VC,	<VC==1>		;V COMMAND IMPLEMENTED
IFNDEF EOVAL,	<EOVAL==2>		;THE STANDARD SETTING OF THE EO FLAG FOR
					;THIS VERSION IS 2
IFNDEF CMDSTZ,	<CMDSTZ==^D160>	;160 CHAR COMMAND BUFFER (FOR COMMAND STRING PARSE)
IFNDEF	LNCFGG,	<LNCFGG==0>	;SET LINE PRINT DEFAULT
IFNDEF  ERSWRT,  <ERSWRT==0>	;ER ERROR SWITCH
IFNDEF SFDCNT,  <SFDCNT==0>	;SET LEVEL OF SFD QUALIFICATION
IFNDEF CHECKP,  <CHECKP==1>	;CKECKPOINT
IFNDEF SPBACK,  <SPBACK==1>	;SUPERBACK UPS ON
IFNDEF INITFL,  <INITFL==1>	;USES AN INIT FILE
IFNDEF RUBSW,  <RUBSW==0>	;MONITOR LIKE RUBOUTS
IFNDEF BACKSP,  <BACKSP==1>	;MAKE ^H LIKE RUBOUT (NO ECHO)
IFNDEF SEQDFL,<SEQDFL==12>	;INCREMENT 10 FOR RE-SEQ
IFNDEF SWITRD,<SWITRD==1>	;READS SWITCH.INI
IFNDEF DIRCAL,<DIRCAL==CCL>	;DIRECT MONITOR CALLABLE (MUST HAVE CCL)
IFNDEF HIGSTR,<HIGSTR==400000>	;A VERY HIGH, HIGH SEGMENT
IFN TEMP,<
IFL    CMDSTZ-^D50,<CMDSTZ==^D50>	;FOR TEMP CORE
>
IFNDEF ASWTCH,<ASWTCH==0>	;NO AUTO APPEND
IFNDEF NSWTCH,<NSWTCH==0>	;CHECKPOINT ON
IFNDEF FSWTCH,<FSWTCH==0>	;NOT FAST
IFNDEF TSWTCH,<TSWTCH==1>	;USE TAB
IFNDEF RSWTCH,<RSWTCH==0>	;NOT RE-EDIT
IFNDEF MSWTCH,<MSWTCH==0>	;NOT MAKE
IFNDEF HSWTCH,<HSWTCH==0>	;NOT HELP
IFNDEF DSWTCH,<DSWTCH==0>	;NOT DOC
IFNDEF LSWTCH,<LSWTCH==1>	;USE USRS TAB FIRST
IFNDEF WSWTCH,<WSWTCH==1>	;USE SWITCH.INI
IFNDEF OSWTCH,<OSWTCH==1>	;USE SYS:TECO.ERR
IFNDEF CSWTCH,<CSWTCH==0>	;NOT RESTORE
IFNDEF QSWTCH,<QSWTCH==1>	;SILENT
IFNDEF BSWTCH,<
IFNDEF ZSWTCH,<ZSWTCH==1>>	;/Z IS DEFAULT (FOR RUN ONLY)
IFNDEF ZSWTCH,<
ZSWTCH==<1-BSWTCH>>
SWIT.A==0
SWIT.Z==0
SWIT.N==0
SWIT.B==0
SWIT.F==0
SWIT.F==0
SWIT.T==0
SWIT.R==0
SWIT.M==0
SWIT.H==0
SWIT.D==0
SWIT.L==0
SWIT.W==0
SWIT.O==0
SWIT.C==0
SWIT.Q==0
IFN ASWTCH,<SWIT.A==APNBIT>
IFE ZSWTCH,<SWIT.Z==BAKBIT>
IFE NSWTCH,<SWIT.N==1>
IFN FSWTCH,<SWIT.F==1>
IFE TSWTCH,<SWIT.T==1>
IFN RSWTCH,<SWIT.R==RESBIT>
IFN MSWTCH,<SWIT.M==MAKBIT>
IFN HSWTCH,<SWIT.H==HELPRB>
IFN DSWTCH,<SWIT.D==DOCBIT>
IFE LSWTCH,<SWIT.L==LTBBIT>
IFN OSWTCH,<SWIT.O==1>
IFN CSWTCH,<SWIT.C==1>
IFE WSWTCH,<SWIT.W==NOWBIT>
IFN QSWTCH,<SWIT.Q==1>


;FOR ANY OTHER VERSION ASSEMBLE AS FOLLOWS:
;.R MACRO
;*TECO_TTY:,DSK:TECO.MAC
;<ASSEMBLY SWITCH CHANGES OF THE FORM SSSSS=N
;	WHERE SSSSS IS THE SWITCH VALUE AND
;	N IS THE NEW VALUE>
;^Z
;^Z
;
;
;THIS FILE CONTAINS A BRIEF DESCRIPTION OF THE TECOX
;ASSEMBLY TIME SWITCHES. MANY OF THE FOLLOWING EXIST ALSO
;IN DEC TECO VERSION 23A
;
;
;SWITCH		DESCRIPTION

;SHORTV		=0 FOR FULL VERSION MESSAGE
;		   "C. S. L. TECO EXTENDED VERSION XXXXXXX"
;		=1 FOR ABREVIATED VERSION MESSAGE
;		   "TECOX [XXXXXXXXXXXX]"
;		=-1 FOR NO VERSION MESSAGE

;PROTCD		DEFAULT PROTECTION CODE FOR FILE PARSES (USED IN EW)
;		=155 FOR <155> DEFAULT

;PROTCB		DEFAULT FIRST BACKUP PROTECTION (FURTHER BACKUP PROTECTION
;		CODES DEFAULT TO THE SETTING OF THE FIRST
;		DEFAULT IS =055.

;PROTSF		DEFAULT PROTECTION CODE FOR .SFD CREATION

;CCL		=1 FOR CCL CAPABILITY
;		=0 FOR ONLY R OR RU CAPABILITY

;TEMP		=1 FOR TEMPCORE CAPABILITY (USED IN CCL)
;		=0 FOR CCL PARAMETER PASSING THRU FILES ONLY

;PDP6		=1 FOR PDP6 VERSION (I DOUBT IT WORKS)
;		=0 FOR PDP10 VERSION

;ERRMSG		MESSAGE LEVEL SET LIKE THE EH FLAG

;AUTOFS		=0 FOR NO AUTOTYPE OUT
;		=N FOR TYPE CHARACTER WHOSE VALUE IS N IN AUTOTYPE OUT
;		SAME AS ES FLAG

;TYCASW		=0 LOWER CASE FLAGGING
;		=1 UPPER CASE FLAGGING
;		=-1 NO CASE FLAGGING
;		=2 UPPER CASE FLAGGING EVEN IF TT LC SET
;		=-2 LOWER CASE FLAGGING EVEN IF TT UC SET

;NORUNS		=1 FOR NO RUN UUO
;		=0 FOR USE RUN UUO (IN EF, EX, ..., EG)

;SRCHSW		=0 SEARCH FOR EITHER CASE AS MATCH
;		=1 REQUIRE EXACT MATCH (LIKE ^X COMMAND)

;TTBSIZ		= TTY BUFFER SIZE IN WORDS

;BUFSIZ		= DSK BUFFER SIZE IN WORDS

;LPDL		TECOX'S STACK SIZE

;LPF		Q-REGISTER STACK SIZE

;VC		NO V COMMAND IF =0
;		=1 HAS A V COMAND
;		THIS COMMAND RETURNS AS A VALUE
;		THE NUMBER OF CHARACTERS MOVED IN
;		THE LAST TEXT MANIPULATION

;EOVAL		TECO'S VERSION FLAG (EO)

;CMDSTZ		INITIAL COMMAND BUFFER SIZE IN CHARACTERS
;		USED FOR CCL TOO...SHOULD BE LONG ENOUGH FOR THE
;		LARGEST LEGAL INITIAL COMMAND STRING

;LNCFGG		LINE COUNT PRINT FLAG (EL) =0 FOR NO LINE NUMBERS
;		=1 FOR LINE NUMBERS ON LINE ORIENTED T COMMANDS

;ERSWRT		ER ERROR SWITCH SETTING =0 FOR ER ERRORS ON LOOKUP
;		FAILURE
;		=1 FOR ER VALUE RETURNS...NO ERRORS

;SFDCNT		=0 FOR NO SFD PARSING
;		=N FOR PARSING UP TO N DEEP

;CHECKP		=0 FOR NO CHECKPOINT CAPABILITIES
;		=1 FOR CHECKPOINT CAPABILITIES

;SPBACK		=0 FOR NO REVOLVING BACKUP CAPABILITIES
;		=1 FOR MULTIPLE BACKUPS

;INITFL		=0 FOR NO INITIALIZATION FILE CAPABILITY
;		=1 FOR INITIALIZATION FILE CAPABILITY

;RUBSW		=0 FOR STANDARD RUBOUT ECHOING
;		=1 FOR MONITOR LIKE ECHO

;BACKSP		=0 FOR NO CONTROL H TRAPPING IN SCANNER
;		(I.E. NO CHARACTER ERASE ON CONTROL H)
;		=1 CHARACTER ERASE ON CONTROL H

;SEQDFL		NUMBER USED AS DEFAULT SEQUENCE NUMBER INCREMENT
;		FOR /GENLSN

;SWITRD		=1 READS SWITCH.INI FOR SUPPLIMENTARY SWITCHES

;DIRCAL		=1 MAY BE RUN FROM THE SYSTEM COMMAND DECODER DIRECTLY
;			(TECO OR MAKE COMMANDS ARE DECODED)
;		=0 MAY ONLY BE RUN THRU THE R (RU) COMMAND OR COMPIL

;HIGSTR		THE START OF THE HIGH SEGMENT (WE USE 700000 SO WE CAN APPEND
;			LARGE FILES
;		FOR DIRCAL=1 CCL MUST ALSO =1
;		=0 DOES NOT READ IT


;MASTER COMMAND STRING DEFAULT SWITCH SETTING SWITCHES:
;
;SWITCH NAME	SWITCH LETTER	CURRENT DEFAULT
;
;ASWTCH		/A		=0 ;NOT ON
;ZSWTCH		/Z		=1 ;ON (FOR RUN ENTRY)
;NSWTCH		/N		=0 ;NOT ON (CHECKPOINT ENABLED AS DEFAULT)
;BSWTCH		/B		=0 ;NOT ON (INVERSE OF /Z)
;FSWTCH		/F		=0 ;NOT ON
;TSWTCH		/T		=1 ;ON (READS TAB FILE)
;RSWTCH		/R		=0 ;NOT ON
;MSWTCH		/M		=0 ;NOT ON
;HSWTCH		/H		=0 ;NOT ON
;DSWTCH		/D		=0 ;NOT ON
;LSWTCH		/L		=1 ;ON (USE USER'S TAB FILE FIRST)
;WSWTCH		/W		=1 ;ON (READS SWITCH.INI)
;OSWTCH		/O		=0 ;NOT ON
;CSWTCH		/C		=0 ;NOT ON
;QSWTCH		/Q		=1 ;ON (QUIETLY RESTARTS)
;ACCUMULATOR ASSIGNMENTS

FF=	0	;CONTROL FLAGS
P=	1	;PUSH DOWN POINTER
		;*** A, AA AND B MUST BE CONTIGUOUS AND IN THAT ORDER ***
A=	2
AA=	3	;TYPE-IN POINTER TO COMMAND BUFFER & SEARCH TABLE INDEX
		;*** B AND E MUST BE ADJACENT AND B<11 ***
B=	4	;COMMAND BUFFER END ADDRESS
E=	5
C=	6
D=	7
F2=	10	;MORE CONTROL FLAGS
T=	11
		;*** T, TT AND TT1 MUST BE ADJACENT ***
TT=	12
TT1=	13
I=	14
OU=	15
CH=	16	;CHARACTER AC
PF=	17	;Q-REGISTER PDL PTR
;CONTROL FLAGS
;RIGHT HALF - AC FF

ALTF==	1		;ALT-MODE SEEN
ARG2==	2		;THERE IS A SECOND ARGUMENT
ARG==	4		;THERE IS AN ARGUMENT
FSRCH==	10		;REPLACEMENT SEARCH
SLSL==	20		;@ SEEN
PCHFLG==40		;N SEARCH
COLONF==100		;COLON SEEN
SYLF==	200		;SYLLABLE FLAG
XPLNFL==400		;HAVE TYPED EXTENSION OF ERROR MESSAGE ALREADY
EMFLAG==1000		;HAVE TYPED 1ST LINE OF ERROR MESSAGE
FINDR==	2000		;LEFT ARROW SEARCH
QMFLG==	4000		;PROSESSING ERROR MESSAGE
SEQUIN==10000		;OUTPUT: AFTER EOL NEXT 5 CHARS ARE SEQ #
			;INPUT:  IGNORE CHAR AFTER SEQ# IF IT'S TAB
TRACEF==20000		;? SEEN
SEQF==	40000		;SEQUENCE NUMBER SEEN ON INPUT
BELLF==	100000		;^G SEEN
DDTMF==	200000		;NEED TO TYI IN DDT MODE
FORM==	400000		;A FORM FEED TERMINATED THE LAST YANK OR APPEND COMMAND
;
;FOR COMMAND STRING PARSE
;
APNBIT==1	;APPEND TO CORE
BAKBIT==10	;SET REGULAR BACKUPS
RESBIT==20	;RESTART OPTION
EXEBIT==40	;TECO MACRO EXEC
LTBBIT==100	;LOCAL INIT TABLE READ
MAKBIT==200	;MAKE FILE BIT
COMBIT==400	;COMMA FOUND BIT
EQLBIT==1000	;EQUAL SIGN FOUND
PERBIT==2000	;PARAMETER BIT
NOSTRG==4000	;STRING TYPED
NOSPST==10000	;NO SPECIAL SWITCH (/E /P)
HELPRB==20000	;HELP WANTED
DOCBIT==40000	;DOC WANTED
NOWBIT==100000	;NO SWITCH.INI READING WANTED

;LEFT HALF - AC FF

PMATCH==2		;PREVAILING MATCH MODE
IFN VC,<
TABSRT==4		;TAB CORRECTION FOR VVAL
	>
TMPFLG==40		;TMPCOR UUO ALLOWED
FINF==	100		;INPUT CLOSED BY EOF
UREAD==	200		;INPUT FILE IS OPEN
UWRITE==400		;OUTPUT FILE IS OPEN
UEBTMP==1000		;EB FUNCTION TEMPORARY FLAG
FILWD==	2000		;FILE WORD BEING ASSEMBLED.
FEXTF==	4000		;FILE EXT EXPECTED (.TYPED).
UBAK==	20000		;EB IN EFFECT
GKTLKF==40000		;MESSAGE TYPE OUT IN GRABAK?
TYOF==	100000		;NEED TO OUTPUT A BUFFER
TYOCTF==200000		;ALLOW CONTROL CHARS TYPED WITHOUT "^"
;CONTROL FLAGS
;RIGHT HALF - AC F2

CTLV==	1		;^V SEEN INSIDE TEXT
CTLVV==	2		;DOUBLE ^V SEEN INSIDE TEXT
CTLW==	4		;^W SEEN INSIDE TEXT
CTLWW== 10		;DOUBLE ^W SEEN INSIDE TEXT
XMATCH==20		;EXACT MATCH SEARCH MODE
EMATCH==40		;TEMPORARILY ACCEPT EITHER UPPER OR LOWER CASE
LINCHR==100		;TTY LINE HAS LC BIT ON
TYMSGF==200		;TYPE MESSAGE WITH NO CASE FLAGGING
OCTALF==400		;OCTAL RADIX
CTLR==	1000		;^R SEEN AT INPUT TIME
SKIMRF==2000		;WATCH FOR ^R WHEN SKIMMING
SKIMQF==4000		;WATCH FOR ^Q WHEN SKIMMING
NOTRAC==10000		;DISABLE TRACING
TYSPCL==20000		;TYPE <CR>, ETC INSTEAD OF PRINTER CONTROLS
SKANFS==40000		;SKANNING FS OR FN
TXTCTL==100000		;NO CONTROL COMMANDS IN TEXT EXCEPT ^T, ^R
LCASE==	200000		;CONVERT UPPER CASE TO LOWER CASE BY DEFAULT
UCASE==	400000		;CONVERT LOWER CASE TO UPPER CASE BY DEFAULT

;LEFT HALF - AC F2

GOING== 1		;A COMMAND STRING HAS BEEN SEEN
CTLN==	2		;^N IN SEARCH ARGUMENT
SUPYLA==20		;YANK VERIFY BITS
YBKARW==10
NOALT=4		;NO ALTMODE CONVERSION

;CALLI UUOS

RESET==	0
DEVCHR==4
CORE==	11
EXIT==	12
TIMER==	22
GETPPN==24
SWITCH==20
UTPCLR==13
PJOB==	30
REMAP==	37
GETTAB==41
TMPCOR==44
DSKCHR==45

;TTCALLS

CLRBFI==11
CLRBFO==12

;I-O CHANNELS

INCHN==	2
OUTCHN==3
TTY==	4	;CHANNEL FOR TTY IO
CCLCHN==5	;CHANNEL FOR THE CCL TMP FILE
ERRCHN==6	;CHANNEL FOR ERROR MESSAGE FILE
BAKCHN==7	;CHANNEL FOR MULTIPLE BACKUPS
CHPCHN==8	;CHANNEL FOR TTY INPUT CHECKPOINTING
INITCH==9	;INIT CHANNEL
;MISC PARAMETERS

				;START WITH &
ALT==	033	;TECO'S ALTMODE
BEGPAG==200	;FAKE ASCII CHAR == BEGINNING OF BUFFER
ENDPAG==201	;FAKE ASCII CHAR == END OF BUFFER IF NO EOL AT END
SPCTAB==202	;FAKE ASCII CHAR == SIGNAL TO SEARCH FOR A STRING OF SPACE/TABS
STABLN==^D131	;LENGTH OF SEARCH TABLE
IOEOT==	2000
DVDIR==4	;[136] DIRECTORY DEV
DVMTA== 20	;MTA DEVICE CHARACTERISTIC BIT
DVDTA== 100	;DTA DEVICE CHARACTERISTIC BIT
DVDSK==200000	;[136] DSK DEVICE
CNFTBL==11	;FOR GETTAB UUO
STATES==17	;DITTO
SERES5==3400	;DITTO
JBTPRG==3	;JOBNAME TABLE
LVDTBL==16	;LEVEL D PARAMETERS TABLE
STNPRT==12	;SYSTEM STANDARD PROTECTION WORD
GCTBL==	100
SAVEXT=='SAV'	;PDP-10 SAVE FILE EXTENSION
IFN PDP6,<SAVEXT=='DMP'>	;PDP-6 SAVE FILE EXTENSION
EE1==1B12	;PRINT UUO ERROR CODE AFTER ?XXX
EE2==2B12	;PRINT I/O ERROR CODE AFTER ?XXX
EE3==3B12	;PRINT NOTHING AFTER ?XXX BECAUSE NO CORE FOR ERROR FILE

EO21==	1	;TURN OFF SPECIAL VERSION 22+ FEATURES IF EO VALUE == 1
LF==12
VT==13
FFORM==14
CR==15
;OPERATORS


;CHECK EO FLAG: CHKEO	EO#,ADDR
;IF EOFLAG > EO#, RETURN AT CALL+1
;OTHERWISE GO TO ADDR

DEFINE	CHKEO(E,A)
	<1B22+<E>B30,,A>

;TYPE ERROR MSG: ERROR	E.XXX
;TYPE MESSAGE CORRESPONDING TO 'XXX'
;THEN GO TO GO

DEFINE	ERROR(X)
	<1B8+'X'
	'X'==<''X''>&777777>

OPDEF	TYPR1 [2B8]
EXTERN	.JBREL,.JBFF,.JB41,.JBSA,.JBUUO

JOBREN=124
JOBVER=137

LOC JOBVER
	EXP	VERSION		;VERSION #

LOC JOBREN
	EXP	REE		;REENTRY ADDRESS


;MACRO TO DEFINE DATA LOCATIONS

DEFINE U(A,B)<
RELOC
A:	BLOCK	B
RELOC
>


TWOSEG	HIGSTR

RELOC	0
RELOC	HIGSTR

U RUN222,1		;RUN FLAGS
IFN DIRCAL,<U SAVCHR,1>
U RUNCNT,1		;
U LOCORE,0		;START OF DATA AREA

;PSEUDO RUN UUO IF NEEDED

IFN NORUNS,<
IFN CCL,<
NORUN1:	IOWD	.-.,INHERE	;MODIFIED FOR LENGTH
	0
NORUN2:	CALLI	15,11
	CALLI	12		;NOT ENOUGH CORE TO GET COMPIL
	IN	CCLCHN,NORUN1	;READ THE FILE
	JRST	NORBLT		;TO THE ACS
	CALLI	12		;NO GOOD.

INHERE:				;WHERE CODE APPEARS
NORAC:				;WHERE TO READ AC DATA FROM
	PHASE	0
NORBLT:	BLT	NORTOP,.-.	;ADR MODIFIED
	CALLI	0
	AOS	1,.JBSA		;ADR + 1
	JRST	(1)		;START COMPIL
NORTOP:	XWD	INHERE+1,75	;MOVE COMPIL DOWN
	DEPHASE
	>>
;STARTUP TIME INITIALIZATION

TEC2:	TTCALL	CLRBFI,
IFN CCL,<
	SKIPE	CCLSW
	CALLI	1,EXIT
U CCLSW,1>
TECO:
IFE CCL,<JFCL>
IFN CCL,<
	TDZA	B,B
	MOVNI	B,1		;THE CCL ENTRY
	>
	MOVE	P,[XWD -LPDL,PDL]	;START ONE WORD DOWN
IFN DIRCAL,<SETZM SAVCHR>	;INIT CHAR SAVE
	SKIPE	B
	JRST	TECOSK
	SKIPE	RUNCNT
	JRST	TECOSK
IFN DIRCAL,<
	RESCAN
	SKPINL
	JRST	TEC$01
TEC$00:	INCHWL	CH	;GET CHAR
	MOVEM	CH,SAVCHR	;SAVE CHARACTER
	PUSHJ	P,UCCVT	;CONVERT
	CAIN	CH," "
	JRST	TEC$00
	CAIN	CH,TAB
	JRST	TEC$00
	SKIPN	CH
	JRST	TEC$00
	CAIN	CH,"T"
	JRST	TECOSK
	CAIN	CH,"M"
	JRST	TECOSK
>
TEC$01:	VPRINT
TECOSK:	CALLI	RESET		;INITIALIZE ALL IO
	MOVEI	A,LOWTPP	;GET ACTUAL CORE TOP
	CALLI	A,11	;FREE CORE
	SETZM	LOCORE		;CLR DATA IN CASE OF ^C,ST
	MOVE	A,[XWD LOCORE,LOCORE+1]
	BLT	A,@.JBREL
IFN CCL,<MOVEM	B,KINDC
	MOVEM	B,CCLSW>
	SETZM	FF
	SETZM	F2
IFE PDP6,<MOVE A,[PUSHJ P,UUOH]>	;SET UUO TRAP
IFN PDP6,<MOVE A,[JSR UUOH]>	;PDP-6 ASSUMES TRAP SET WITH JSR
	MOVEM	A,.JB41
	MOVEI	A,LOWTOP
	MOVEM	A,.JBFF
	ADD	A,[677,,-1]	;CBUF=[000700,,FF-1]
	MOVEM	A,CBUF
	MOVEI	A,201(A)
	IMULI	A,5
	MOVEM	A,BEG		;BEG:=(CBUF+200)*5
	MOVEM	A,PT		;PT:=(CBUF+200)*5
	MOVEM	A,Z		;Z:=(CBUF+200)*5
	MOVEM	A,QRBUF		;QRBUF:=(CBUF+200)*5
	CALLI	A,GETPPN	;GET USER'S PROJ-PROG #
	HRRZM	A,QPROGN	;SET TO &9
	HLRZM	A,QPROJN	;SET TO &8
	MOVEM	A,USRPPN
	SETOM	MONITR		;GET MONITOR SERIES NUMBER
	MOVE	A,[XWD STATES,CNFTBL]
	CALLI	A,GETTAB	;WHICH MONITOR?
	JRST	TECO2		;3 SERIES (MONITR=-1)
	TLNE	A,SERES5
	AOS	MONITR		;5 SERIES (MONITR=+1)
	AOS	MONITR		;4 SERIES (MONITR=0)
TECO2:	CALLI	A,PJOB		;GET JOB #
	MOVEM	A,JOBN
	HRRZM	A,QPJOBN	;SET JOB NUMBER
	MOVEI	C,3		;SET CTR
JOBLUP:	IDIVI	A,12		;CONVERT JOB# TO DECIMAL ASCII IN LEFT HALF
	ADDI	AA,20
	LSHC	AA,-6
	SOJG	C,JOBLUP
	HRRI	B,(SIXBIT /TEC/)	;FORM NAME ###TEC
	MOVEM	B,TMPTEC	;SAVE
	HRRZI	A,EOVAL		;INITIALIZE EO FLAG
	MOVEM	A,EOFLAG
;COMMAND STRING INTERPRETER/INITIALIZER
;
SUM.SW=SWIT.A+SWIT.Z
SUM.SW=SUM.SW+SWIT.B
SUM.SW=SUM.SW+SWIT.R
SUM.SW=SUM.SW+SWIT.M
SUM.SW=SUM.SW+SWIT.H
SUM.SW=SUM.SW+SWIT.D
SUM.SW=SUM.SW+SWIT.L
SUM.SW=SUM.SW+SWIT.W
	MOVE	FF,[EXP SUM.SW]
IFN CHECKP,<IFN SWIT.N,<SETOM CHKPNT>>
IFN SWIT.F,<SETOM FASTEC>
IFN INITFL,<IFN SWIT.T,<SETOM NOTABF>>
IFN SWIT.O,<SETOM ERRFLG>
IFN CHECKP,<
IFN SWIT.Q,<SETOM SILENT>
IFN SWIT.C,<SETOM CHKEXE>
>
;THIS PAGE CONTAINS THE COMMAND READER FOR THE CCL SYSTEM

IFE CCL,<
	JRST	CCLSKP

>
IFN CCL,<
	SKIPN	KINDC
	JRST	CCLSKP
	AOS	RUNCNT
	JRST	CCLIN

U CCLB,3			;THE HEADER FOR CCL FILE IO

CCLERR:	PUSH	P,[POINT 7,[ASCIZ /?No parameters -- CCL Linkage aborted
/]]
	PUSHJ	P,STRGPT
	JRST	TEC2
;
;
CCLIOE:	PUSH	P,[POINT 7,[ASCIZ /?Input Error or End-of-File reading ###EDT.TMP -- CCL Linkage aborted
/]]
	PUSHJ	P,STRGPT
	JRST	TEC2

CCLOPN:
IFN TEMP,<
	MOVE	T,[XWD 1,TT]	;GET READ CODE
	JRST	CCLOCO
>
CCLDEL:
IFN TEMP,<
	MOVE	T,[XWD 2,TT]	;READ DELET
CCLOCO:	HLLZ	TT,-1(P)	;GET NAME
	HRLZI	TT1,-10	;AND COUNT
	HRR	TT1,-1(P)	;AND BUFFER SIZE
	SOJ	TT1,	;TO AN IOWD
	CALLI	T,TMPCOR	;GET TEMP CORE
	JRST	CCLDSK	;NONE
	TLO	FF,TMPFLG	;SET DOING TEMPCORE
	MOVE	T,[POINT 7,0]	;GET POINTER
	HRR	T,-1(P)	;GET ADDRESS
	JRST	CCLORT
>
CCLDSK:	HLLZ	B,TMPTEC	;GET SIXBIT JOB #
	HLR	B,-1(P)	;GET NAME
	MOVEM	B,FILNAM
	MOVSI	B,(SIXBIT /TMP/)
	MOVEM	B,FILNAM+1
	MOVE	T,.JBFF		;USE BUFFER SPACE BRIEFLY
	MOVEI	B,LOWTPP	;GET CORE TOP
	MOVEM	B,.JBFF
	INIT	CCLCHN,0
	SIXBIT	/DSK/		;TO READ THE FILE
	EXP	CCLB		;INPUT BUFFER
	JRST	CCLERR		;IF NO DSK, SAY "*"
	INBUF	CCLCHN,1	;DONT ADR CHECK
	SETZM	FILNAM+2
	SETZM	FILNAM+3
	LOOKUP	CCLCHN,FILNAM	;OPEN THE FILE
	JRST	CCLERR		;IT WASNT THERE?
	INPUT	CCLCHN,0
	STATZ	CCLCHN,760000
	JRST	CCLIOE
	MOVEM	T,.JBFF		;GIVE BACK SPACE
	MOVE	T,CCLB+1	;GET POINTER FROM MONITOR
CCLORT:	POP	P,TT	;POP RETURN
	MOVEM	TT,(P)	;BACK
	POPJ	P,	;RETURN

CCLCH:	ILDB	CH,T	;GET CHARACTER
	POPJ	P,	;RETURN

CCLIN2:	MOVE	T,[POINT 7,CMSTRB]	;GET FAKE POINTER
	JRST	CCLIN3	;SKIP
CCLIN:	PUSH	P,[XWD 'EDT',CMSTRB]	;PUSH ARG
	PUSHJ	P,CCLDEL	;OPEN CCL FILE
CCLIN3:	MOVE	A,[POINT 7,CMSTR2]	;GET OUTPUT BUFFER
	MOVEI	CH," "	;GET BLANK
	IDPB	CH,T	;OVER LINED S
CCLTM1:	PUSHJ	P,CCLCH	;GET CHAR
	MOVEM	A,CCLPTR	;SAVE POINTER
	IDPB	CH,A	;SAVE IT
	CAIL	CH,40	;BLANK ?
	CAILE	CH,174	; ?
	JRST	CCLIL1	;SPECIAL
	JRST	CCLTM1	;NOT
CCLIL1:	CAIG	CH,15		;WAS BREAK A CRLF?
	JRST	CCLDU3
	TRO	FF,MAKBIT
	JRST	CCLDUN
CCLDU3:
IFN ZSWTCH,<TRO FF,BAKBIT>
IFE ZSWTCH,<TRZ FF,BAKBIT>
	TRZ	FF,MAKBIT
CCLDUN:	MOVEI	B,ALT
	DPB	B,A
U CCLIND,1
	TLZE	FF,TMPFLG	;TMPCOR UUO IN PROGRESS?
	JRST	CCLDU2		;YES, DONT CLOSE DSK
	CLOSE	CCLCHN,0	;NOW FLUSH FILE
	SETZM	FILNAM		;BY RENAME TO 0
	SETZM	FILNAM+1	;..
	RENAME	CCLCHN,FILNAM	;GO.
	JFCL			;NOGO?
CCLDU2:	RELEAS	CCLCHN,
	MOVE	A,[POINT 7,CMSTR2]	;GET POINTER
	MOVEM	A,KINDCP
	JRST	CCLDON
U CCLPTR,1
>

;
;COMMAND READER
;	RETRUNS CHAR IN CH
;
CCGET:
IFN SWITRD,<
	SKIPN	SWITFG	;SKIP IF SWITCH.INI
	JRST	SW$11	;JRST
	SKIPE	SWCHIC	;SKIP IF SWITCH ON DISK
	JRST	SW$20	;SKIP I/O
	SKIPGE	IBUF	;SKIP IF ALREADY INPUTED
	INPUT	INCHN,
	STATZ	INCHN,20000
	JRST	SW$12
SW$20:	SKIPN	IBUF+2	;SKIP IF NO CHARS
	JRST	SW$12	;RETURN IF IS
	ILDB	CH,IBUF+1	;GET BYTE
	SOSLE	IBUF+2	;DECR COUNT
	JRST	CCGET2	;JMP IF STILL HAVE CHARS
	SKIPE	SWCHIC	;SKIP IF NOT IN CORE
	JRST	SW$12	;IF IS GIVE HIM A TERMINATOR
U SWCHIC,1
	INPUT	INCHN,
	STATZ	INCHN,20000
	PUSHJ	P,SW$12
	STATZ	INCHN,740000
	PUSHJ	P,SW$13
	JRST	CCGET2
SW$13:	PUSH	P,[POINT 7,[ASCIZ /%Input Error on SWITCH.INI -- Proceeding
/]]
SW$14:	PUSHJ	P,STRGPT
SW$12:	MOVEI	CH,ALT
	POPJ	P,
>
SW$11:
IFN CCL,<
	SKIPE	KINDC	;SKIP NOT CCL
	JRST	CCLGET
>
	INCHWL	CH	;READ CHARACTER
CCGETR:	SKIPN	CH
	JRST	CCGET
IFN CCL,<IDPB CH,CCLPTR
	CAIN	CH," "
	POPJ	P,
	CAIN	CH,TAB
	POPJ	P,
	PUSHJ	P,TERMCK
	POPJ	P,
	SETOM	CCLIND
>
	POPJ	P,
IFN CCL,<
CCLGET:	ILDB	CH,KINDCP	;GET CHAR FROM BUFFER
>
CCGET2:	SKIPN	CH
	JRST	CCGET
	POPJ	P,
IFN CCL,<
U KINDCP,1
CCLSKP:	SETZM	KINDC
U KINDC,1
	>
IFE CCL,<CCLSKP:>
;COMAND STRING DECOMPSITION PART I

	SKIPE	RUNCNT
	JRST	CMSTS2
	AOS	RUNCNT
IFN DIRCAL,<
	SKIPN	SAVCHR
	JRST	TEC$02
	MOVE	CH,SAVCHR	;GET FIRST CHAR
	JRST	TEC$03
TEC$02:>
	RESCAN	;WANT TO LOOK AT RUN
	SKPINL
	JRST	CMSTS2
IFN DIRCAL,<
LP$01:	PUSHJ	P,CCGET	;GET A CHAR
TEC$03:	PUSHJ	P,UCCVT
	CAIN	CH,"S"	;START ?
	JRST	CMSTSK	;YES
	CAIN	CH,"T"	;TECO COMMAND ?
	JRST	LP$02	;YES
	CAIN	CH,"R"	;RUN ?
	JRST	CMSTSK	;YES
	CAIE	CH,"M"	;MAKE ?
	JRST	LP$01	;LOOP IF NONE OF THE ABOVE
	TRO	FF,MAKBIT
	SKIPA
LP$02:	TRO	FF,BAKBIT
	SETOM	CCLSW	;INDICATE CCL (FOR EXIT ON ERRORS)
	SETOM	SPCCL	;INDICATE DIRECT MONITOR CALL
>
CMSTSK:	PUSHJ	P,CCGET	;GET CHAR
	PUSHJ	P,TERMCK	;TERMINATOR ?
	JRST	LP$05	;YES
	CAIN	CH,";"	;COMMAND START ?
	JRST	CMSTS3	;YES
IFN DIRCAL,<
	SKIPN	SPCCL	;SKIP IF DIRECT CALL
	JRST	CMSTSK
U SPCCL,1
	CAIN	CH," "	;BLANK ?
	JRST	LP$03	;YES
	CAIN	CH,TAB	;TAB ?
	JRST	LP$03
>
	JRST	CMSTSK	;LOOP
IFN DIRCAL,<
LP$03:	PUSHJ	P,CCGET	;GET CHAR
	PUSHJ	P,TERMCK	;TERMINATOR ?
	JRST	LP$04	;YES
	CAIN	CH,TAB	;TAB ?
	JRST	LP$03	;YES
	CAIN	CH," "	;BLANK ?
	JRST	LP$03	;LOOP
	SETOM	SKIPON
	SETOM	CCLIND
U SKIPON,1
	JRST	CMSTS3	;GO SCANN COMMAND
LP$04:	CAIN	CH,CR
	PUSHJ	P,CCGET
	PUSH	P,[XWD 'EDS',CMSTR2]
	PUSHJ	P,CCLOPN	;GET FILE
LP$06:	PUSHJ	P,CCLCH	;GET CHAR
	CAIN	CH," "	;BLANKS ?
	JRST	LP$06	;YES
	CAIN	CH,TAB	;TABS ?
	JRST	LP$06	;YES
LP$07:	PUSHJ	P,IDCHK	;IDENT ?
	JRST	LP$08	;BLANKS
	JRST	LP$09	;ALPHANUM
	JRST	LP$08	;TERM
LP$09:	PUSHJ	P,CCLCH	;GET CHAR
	JRST	LP$07	;LOOP
LP$08:	MOVE	A,[POINT 7,CMSTRB]	;GET POINTER
	MOVEI	CH,"S"	;LINED S
	IDPB	CH,A
LP$11:	PUSHJ	P,CCLCH	;GET CHAR
	PUSHJ	P,TERMCK	;TERMINATOR ?
	JRST	LP$10	;YES
	IDPB	CH,A	;SET IT
	JRST	LP$11
LP$10:	MOVEI	CH,ALT	;GET ALT
	TRNN	FF,MAKBIT
	MOVEI	CH,CR
	IDPB	CH,A	;SET IT
	SETOM	KINDC	;SET CCL FLAGS
	TLO	FF,TMPFLG	;ZAP TEMPCORE
	CLOSE	CCLCHN,
	RELEAS	CCLCHN,
	JRST	CCLIN2	;CCL ENTRY FAKE
>
LP$05:	CAIN	CH,CR	;CR ?
	PUSHJ	P,CCGET	;THRU IT

IFN DIRCAL,<
	SKIPE	SPCCL
	JRST	LP$04	;TRY TMP: IF T OR M
>

CMSTS2:	OUTCHR	[EXP "#"]	;PROMPT
CMSTS3:
IFN CCL,<
	MOVE	A,[POINT 7,CMSTR2]
	MOVEM	A,CCLPTR
>
IFN DIRCAL,<
	SKIPE	SKIPON
	IDPB	CH,CCLPTR	;SAVE FIRST CHARACTER
>
CCLDON:
IFN CCL,<SKIPN SKIPON
	SETZM CCLIND>
	SETZM	CMSTRB	;SET NONE INDICATOR
	MOVE	A,[POINT 7,CMSTRB]	;GET AREA POINTER
	MOVEI	B,CMDSTZ-1	;GET SIZE
CMST01:
IFN DIRCAL,<AOSE SKIPON>	;SKIP IF FIRST ALLREADY READ
	PUSHJ	P,CCGET	;GET CHAR
CMST1A:	MOVEI	C,CMSTTB	;GET TERMINATOR TABLE
	MOVEI	D,<CMSTTE-CMSTTB>/2	;GET LENGTH
CMST02:	CAMN	CH,(C)	;SAME ?
	XCT	1(C)	;EXEC INSTR
	ADDI	C,2	;TO NEXT
	SOJG	D,CMST02	;LOOP
CMST08:	IDPB	CH,A	;SAVE CHAR
	SOJG	B,CMST01	;GO FOR NEXT
CMST8A:	PUSH	P,[POINT 7,[ASCIZ /
?Command string overflow
/]]
	PUSHJ	P,STRGPT
	JRST	TEC2
IFN CHECKP,<
ATPROC:	SETOM	INDY
	JRST	CMST01
CMSTTB:	"@"	;INDIRECT
	JRST	ATPROC
U INDY,1	;INDIRECT FILE INDICATOR
>
IFE CHECKP,<
CMSTTB:>
	TAB
	JRST	CMST01
	"["	;PPN
	JRST	CMST3A
	"/"	;SWITCH
	JRST	CMST03
	" "
	JRST	CMST01
	","	;COMMA SET
	TRO	FF,COMBIT
	"="	;EQUAL SET
	TRO	FF,EQLBIT
	"_"	;EQUAL SET
	TRO	FF,EQLBIT
	"%"	;PARAMETER START
	JRST	CMST3B
CMSTTT:	CR
	JRST	CMST6A
	LF
	JRST	CMST06
	FFORM
	JRST	CMST06
	VT
	JRST	CMST06
	ALT
	JRST	CMST06
CMSTET:	CMSTTE:
CMST3A:	IDPB	CH,A	;DEPOSIT CHAR
	SOSG	B	;DEC COUNT
	JRST	CMST8A
	PUSHJ	P,CCGET	;GET NEXT
	PUSHJ	P,FENDCK
	JRST	CMSTX8	;BR TO DEPOSIT
	JRST	CMST3A	;BR IF NOT
CMSTX8:	PUSHJ	P,TERMCK
	JRST	CMST1A
	JRST	CMST08


FENDCK:	CAIN	CH,"]"
	POPJ	P,
TERMCK:	CAIN	CH,ALT
	POPJ	P,
	CAIN	CH,CR
	POPJ	P,
	CAIN	CH,LF
	POPJ	P,
	CAIN	CH,FFORM
	POPJ	P,
	CAIN	CH,VT
	POPJ	P,
	AOS	(P)
	POPJ	P,


CMST3B:	TRO	FF,PERBIT	;FLAG PARAMETER
	IDPB	CH,A	;SET INTO BUFFER
	SOSG	B
	JRST	CMST8A
	PUSHJ	P,CCGET	;GET NEXT
	CAIE	CH,42	;IS IT A QUOTE ?
	JRST	CMST3C	;BR IF NOT
CMST3D:	IDPB	CH,A	;SET IT
	SOSG	B	;
	JRST	CMST8A
	PUSHJ	P,CCGET	;GET NEXT
	CAIE	CH,42	;SKIP IF IS
	JRST	CMST3D
	IDPB	CH,A	;DEPOSIT
	SOSG	B
	JRST	CMST8A
	PUSHJ	P,CCGET	;GET NEXT
	CAIN	CH,42	;ALSO A "
	JRST	CMST3D	;BR IF IS
	JRST	CMST1A	;BACK
CMST3C:	MOVEI	C,CMSTTT
	MOVEI	D,<CMSTET-CMSTTT>/2
CMST3E:	CAMN	CH,(C)	;SAME ?
	XCT	1(C)	;JUMP
	ADDI	C,2
	SOJG	D,CMST3E	;LOOP
	IDPB	CH,A	;SET
	SOSG	B
	JRST	CMST8A
	PUSHJ	P,CCGET
	JRST	CMST3C
CMST03:	PUSHJ	P,CCGET	;GET SWITCH
	PUSHJ	P,UCCVT		;CONVERT TO UC
	MOVEI	C,CMSTAB	;GET SWITCH TABLE
	MOVEI	D,<CMSTED-CMSTAB>/3	;GET LENGTH
CMST04:	CAME	CH,(C)	;SAME ?
	JRST	CMST07
	XCT	1(C)	;BR IF IS
NEGS05:	PUSH	P,[EXP CMST1A]
SWTCHE:	PUSHJ	P,CCGET	;GET CHAR
	PUSHJ	P,IDCHK	;IDENT CHECK
	JRST	SWTCHE	;LOOP FOR TAB, BLANK
	JRST	SWTCHE	;LOOP FOR CHAR
	POPJ	P,	;RET FOR TERM
NEGSWT:	PUSHJ	P,CCGET	;GET CHAR
	PUSHJ	P,UCCVT
	MOVEI	C,CMSTAB
	MOVEI	D,<CMSTED-CMSTAB>/3
NEGS04:	CAME	CH,(C)	;SAME ?
	JRST	NEGS07	;NOPE
	XCT	2(C)
	JRST	NEGS05
NEGS07:	ADDI	C,3	;INCR
	SOJG	D,NEGS04	;LOOP
	JRST	NEGS06
IDCHK:	PUSHJ	P,UCCVT
	CAIN	CH," "
	POPJ	P,
	CAIN	CH,TAB
	POPJ	P,
	CAIGE	CH,"0"	;SKIP IF COULD BE NUMERIC
	JRST	SWTCH3
	CAIG	CH,"9"	; ?
	JRST	SWT$01	;LOOP IF IS
SWTCH3:	CAIGE	CH,"A"
	JRST	SWT$02
	CAIG	CH,"Z"
	JRST	SWT$01
SWT$02:	AOS	(P)	;BUMP
SWT$01:	AOS	(P)
	POPJ	P,
;
;
;CONVERT TO UPPER CASE
;	(CHAR IN CH)
;
UCCVT:	CAIGE	CH,"A"+40
	POPJ	P,
	CAILE	CH,"Z"+40
	POPJ	P,
	SUBI	CH,40
	POPJ	P,
;
;
CMST07:	ADDI	C,3	;TO NEXT
	SOJG	D,CMST04	;LOOP
NEGS06:	PUSH	P,[POINT 7,[ASCIZ /?Unknown switch
/]]
	PUSHJ	P,STRGPT
	JRST	TEC2
;
;
;SWITCH TABLE
;
CMSTAB:	"-"
	JRST	NEGSWT
	JRST	CMST03
	"P"
	JRST	PARSWR
	JRST	NEGS06
	"A"
	TRO	FF,APNBIT
	TRZ	FF,APNBIT
	"G"
	JRST	IOSWT1
	JRST	NEGS06
	"S"
	JRST	IOSWT2
	JRST	NEGS06
	"Z"
	TRZ	FF,BAKBIT
	TRO	FF,BAKBIT
	"X"
	JRST	IOSWT3
	JRST	NEGS06
	"Y"
	JRST	IOSWT4
	JRST	NEGS06
	"N"
	SETZM	CHKPNT	;SET OFF
	SETOM	CHKPNT
	"B"
	TRO	FF,BAKBIT
	TRZ	FF,BAKBIT
	"F"
	SETOM	FASTEC	;WE WANT THIS TO RUN FASTER
	SETZM	FASTEC
U FASTEC,1
	"T"
	SETZM	NOTABF
	SETOM	NOTABF
U NOTABF,1
	"R"
	TRO	FF,RESBIT
	TRZ	FF,RESBIT
	"E"
	JRST	EXESWR
	JRST	NEGS06
	"M"
	TRO	FF,MAKBIT
	TRZ	FF,MAKBIT
	"H"
	TRO	FF,HELPRB
	TRZ	FF,HELPRB
	"D"
	TRO	FF,DOCBIT
	TRZ	FF,DOCBIT
	"I"
	JRST	INCRSW
	JRST	NEGS06
	"L"
	TRZ	FF,LTBBIT
	TRO	FF,LTBBIT
	"W"
	TRZ	FF,NOWBIT
	TRO	FF,NOWBIT
	"O"
	SETOM	ERRFLG
	SETZM	ERRFLG
IFN CHECKP,<
	"C"
	SETOM	CHKEXE	;SET ON CHECPOINT
	SETZM	CHKEXE
	"Q"
	SETOM	SILENT
	SETZM	SILENT
>
CMSTED:
EXESWR:	TRO	FF,EXEBIT	;SET MACROS BIT
	PUSHJ	P,SWTCHE	;SKIM UP TO NON ALPHA
	SETZM	ECOUNT
U ECOUNT,1
U EBUFER,2
	CAIE	CH,":"	;VALUE ?
	JRST	CMST1A	;NOPE
	PUSH	P,[POINT 7,EBUFER]	;PUSH POINTER
	PUSHJ	P,NUMPAR	;PARSE NUMERIC
	POP	P,ECOUNT	;SAVE COUNT
	JRST	CMST1A	;LOOP
PARSWR:	PUSHJ	P,SWTCHE
	SETZM	PCOUNT
U PCOUNT,1
U PBUFER,2
	CAIE	CH,":"	;VALUE ?
	JRST	CMST1A
	PUSH	P,[POINT 7,PBUFER]
	PUSHJ	P,NUMPAR	;GET PARM
	POP	P,PCOUNT
	JRST	CMST1A
INCRSW:	PUSHJ	P,SWTCHE	;SCAN IDENT
	SETZM	ICOUNT	;ZAP COUNT
U ICOUNT,1
U IBUFER,2
	CAIE	CH,":"	;CHECK FOR DELIM
	JRST	CMST1A	;NONE
	PUSH	P,[POINT 7,IBUFER]	;PUSH POINTER
	PUSHJ	P,NUMPAR	;GET PARM
	POP	P,ICOUNT	;POP COUNT
	JRST	CMST1A		;RETURN
NUMPAR:	PUSH	P,P
	SETZM	(P)	;ZERO COUNT
	MOVEI	D,6	;GET MAX COUNT
ELOOP1:	PUSHJ	P,CCGET	;GET A CHAR
	CAIN	CH,"-"
	JRST	NUMT2A
	CAIN	CH,"+"
	JRST	NUMT2A
	CAIN	CH," "
	JRST	ELOOP1
	CAIN	CH,TAB
	JRST	ELOOP1
	CAIGE	CH,"0"	;SKIP IF IS POSSIBLY NUMERIC
	JRST	NUMT1A	;BACK
	CAILE	CH,"9"	;SKIP IF IS NUM
	JRST	NUMT1A	;BACK
NUMT2A:	AOS	(P)	;INCR COUNT
	IDPB	CH,-2(P)	;DEPOSIT
	SOJGE	D,ELOOP1	;LOOP
	PUSH	P,[POINT 7,[ASCIZ /?Numeric Argument Too Long
/]]
	PUSHJ	P,STRGPT
	JRST	TEC2
NUMT1A:	POP	P,-2(P)	;RETURN THE COUNT
	POPJ	P,
IOSWT4:	MOVE	C,[POINT 7,IOSWTD]
	SKIPA
IOSWT3:	MOVE	C,[POINT 7,IOSWTC]
	SKIPA
IOSWT1:	MOVE	C,[POINT 7,IOSWTA]
	SKIPA
IOSWT2:	MOVE	C,[POINT 7,IOSWTB]
	MOVEI	D,7
IOLOOP:	ILDB	CH,C
	IDPB	CH,A
	SOSG	D
	JRST	IOSWT0
	SOJG	B,IOLOOP
	JRST	CMST8A
IOSWT0:	PUSHJ	P,SWTCHE
	JRST	CMST1A
IOSWTA:	ASCII	"/GENLSN"
IOSWTB:	ASCII	"/SUPLSN"
IOSWTC:	ASCII	"/XBASIC"
IOSWTD:	ASCII	"/YBASIC"
U ERRFLG,1
;
;
;HELPER
;
CMDHLP:	INIT	INCHN,0
	SIXBIT	/SYS/
	XWD	0,IBUF
	JRST	CMDHL2
CMDHL3:	MOVE	C,[XWD HELP1,HELP2]
	BLT	C,HELP2+3
	LOOKUP	INCHN,HELP2
	JRST	CMDHL2
CMDHL9:	PUSHJ	P,OPNIN
CMDHL5:	INPUT	INCHN,
	STATZ	INCHN,740000
	PUSHJ	P,HLPIOE
	STATZ	INCHN,20000
	JRST	CMDHL6
CMDHL4:	ILDB	CH,IBUF+1
	CAIE	CH,FFORM
	JRST	CMDHL7
	PUSH	P,[POINT 7,[ASCIZ /
Type Space to Continue, <CR> to Restart:/]]
	PUSHJ	P,STRGPT
	TTCALL	CLRBFI,
	INCHRW	C
	PUSH	P,[POINT 7,[ASCIZ /
/]]
	PUSHJ	P,STRGPT
	CAIN	C,CR
	JRST	TEC2
CMDHL7:	OUTCHR	CH
	PUSHJ	P,CHCHK
	SOSG	IBUF+2
	JRST	CMDHL5
	JRST	CMDHL4
CMDHL6:	RELEAS	INCHN,
	JRST	TEC2
CMDHL2:	INIT	INCHN,0
	SIXBIT	/DSK/
	XWD	0,IBUF
	JRST	CMDHL8
	MOVE	C,[XWD HELP4,HELP2]
	BLT	C,HELP2+3
	LOOKUP	INCHN,HELP2
	SKIPA
	JRST	CMDHL9
CMDHL8:	PUSH	P,[POINT 7,[ASCIZ /%Sorry, No Help for the Feeble Minded
/]]
	PUSHJ	P,STRGPT
	JRST	TEC2
U HELP3,3
U HELP2,4
HELP1:	SIXBIT	/TECOX/
	SIXBIT	/HLP/
	EXP	0,0
HELP4:	SIXBIT	/TECOX/
	SIXBIT	/HLP/
	EXP	0
	XWD	11334,247122	;PPN OF MIKERUDE

;
;DOCUMENTATION
;
CMDDOC:	INIT	INCHN,0
	SIXBIT	/SYS/
	XWD	0,IBUF
	JRST	CMDDL2
CMDDL3:	MOVE	C,[XWD DOCUM1,HELP2]
	BLT	C,HELP2+3
	LOOKUP	INCHN,HELP2
	JRST	CMDDL2
	JRST	CMDHL9
CMDDL2:	INIT	INCHN,0
	SIXBIT	/DSK/
	XWD	0,IBUF
	JRST	CMDDL8
	MOVE	C,[XWD DOCUM2,HELP2]
	BLT	C,HELP2+3
	LOOKUP	INCHN,HELP2
	SKIPA
	JRST	CMDHL9
CMDDL8:	PUSH	P,[POINT 7,[ASCIZ /%Sorry, No Documentation in the Achives
/]]
	PUSHJ	P,STRGPT
	JRST	TEC2
;
DOCUM1:	SIXBIT	/TECOX/
	SIXBIT	/DOC/
	EXP	0,0
DOCUM2:	SIXBIT	/TECOX/
	SIXBIT	/DOC/
	EXP	0
	XWD	11334,247122	;PPN OF MIKERUDE
;
HLPIOE:	PUSH	P,[POINT 7,[ASCIZ /
%Input Error reading Help or Documentation File -- Continuing
/]]
	PUSHJ	P,STRGPT
	POPJ	P,

CMST6A:	PUSHJ	P,CCGET	;GET LF
CMST06:
IFN SWITRD,<
	TRNE	FF,NOWBIT
	JRST	SW$01
	SKIPE	SWITFG	;SKIP IF HAVEN'T READ SWITCH.INI
	JRST	SW$01	;JMP IF HAVE
	TRZ	FF,NOSTRG
	SKIPE	CMSTRB	;EMPTY ?
	TRO	FF,NOSTRG
	SETOM	SWITFG	;SET FLAGS
IFN TEMP,<
	MOVEI	CH,'SWI'	;GET SWITCH NAME
	HRLZM	CH,IBUF	;SET TO CORE
	MOVE	CH,[IOWD 1,IBUF+2]	;FAKE READ TO SEE CORE TO GET
	MOVEM	CH,IBUF+1
	MOVE	TT1,[XWD 1,IBUF]	;GET CODE
	CALLI	TT1,TMPCOR	;CALL FOR TEMP CORE
	JRST	SW$22	;NOT THERE
	MOVN	CH,TT1
	ADDI	TT1,LOWTPP	;GET NEW CORE TOP REQUIRED
	CALLI	TT1,11	;GET CORE
	JRST	SW$22	;CAN'T GET CORE SO FUCK IT
	HRLZ	CH,CH	;MAKE IT RIGHT
	HRRI	CH,LOWTPP	;GET ADDRESS
	SOJ	CH,
	MOVEM	CH,IBUF+1	;SET TO AREA
	MOVE	TT1,[XWD 1,IBUF]	;SET UP AGAIN
	CALLI	TT1,TMPCOR	;GET IT
	JRST	SW$22
	IMULI	TT1,5	;MAKE BYTES
	MOVEM	TT1,IBUF+2	;SET COUNT TO CORE
	MOVE	TT1,[POINT 7,LOWTPP]	;GET POINTER
	MOVEM	TT1,IBUF+1	;SET CODE
	SETOM	SWCHIC	;SET SWITCH IS IN CORE
	JRST	SW$5A	;GOTO THE SCAN
>
SW$22:	INIT	INCHN,0
	SIXBIT	/DSK/
	XWD	0,IBUF
	JRST	SW$02
	MOVE	CH,[XWD SWTLOK,HELP2]
	BLT	CH,HELP2+3
	LOOKUP	INCHN,HELP2	;FIND IT
	JRST	SW$03
	PUSHJ	P,OPNIN
U SWITFG,1
U NMHOLD,1
U NMCNT,1
U NMPRT,1
	JRST	SW$5A
SW$04:	PUSHJ	P,CCGET	;GET CHAR
	CAIE	CH,"("	;PAREN ?
	JRST	SW$09	;NO
SW$10:	PUSHJ	P,CCGET	;GET CHAR
	SKIPN	SWCHIC
	JRST	SW$30
	SKIPN	IBUF+2
	JRST	SW$01
	JRST	SW$31
SW$30:	STATZ	INCHN,20000	;CHECK EOF
	JRST	SW$01	;BYE IF IS
SW$31:	CAIN	CH,")"	;CLOSE ?
	JRST	SW$10	;NO
SW$09:	PUSHJ	P,TERMCK	;TERMINATOR ?
	JRST	SW$05		;YES
	JRST	SW$04	;NO LOOP
SW$05:	SKIPN	SWCHIC
	JRST	SW$32
	SKIPN	IBUF+2
	JRST	SW$01
	JRST	SW$33
SW$32:	STATZ	INCHN,20000
	JRST	SW$01
SW$33:
SW$5A:	MOVE	CH,[POINT 6,NMHOLD]
	MOVEM	CH,NMPRT
	MOVEI	CH,6
	MOVEM	CH,NMCNT
	SETZM	NMHOLD
SW$06:	PUSHJ	P,CCGET	;GET CHAR
	PUSHJ	P,IDCHK	;IDENT CHECK
	JRST	SW$06	;LOOP ON TAB, BLANK
	JRST	SW$07	;CHAR
	JRST	SW$08	;END OF IDENT
SW$07:	SUBI	CH,40	;TO SIXBIT
	SOSL	NMCNT	;SKIP IF MORE THAN 6
	IDPB	CH,NMPRT	;BUFFER
	JRST	SW$06	;LOOP
SW$08:	MOVE	T,[SIXBIT /TECOX/]
	CAMN	T,NMHOLD	;SKIP IF NOT SAME
	JRST	CMST1A		;GO BACK
	PUSHJ	P,TERMCK	;TERMINATOR ?
	JRST	SW$05		;YES
	JRST	SW$04		;NO BUT GET ONE
SWTLOK:	SIXBIT	/SWITCH/
	SIXBIT	/INI/
IFE SFDCNT,<
	EXP	0,0
>
IFN SFDCNT,<
	EXP	0,SWTPTH
U SWTPTH,4		;FAKE PATH FOR SWITCH
>
SW$02:
SW$03:
SW$01:	RELEAS	INCHN,
	SKIPE	SWITFG	;SKIP IF NOT READING SWITCH
	JRST	SW$1A
>
	TRZ	FF,NOSTRG
	SKIPE	CMSTRB	;EMPTY ?
	TRO	FF,NOSTRG
SW$1A:	MOVEI	CH,ALT	;GET ALTMODE
	IDPB	CH,A	;SET STANDARD TERMINATOR
IFN CHECKP,<
	SKIPN	INDY	;SKIP IF INDIRECT FILE
	JRST	PARTII	;SKIP CHP SETTING
	SETZM	CHKPNT	;NO CHECKPOINT ON
	SETOM	CHKEXE	;AND CHECKPOINT READ ON
>
;THIS SECTION IS THE COMMAND STRING 2ND PASS
;
PARTII:
IFN CCL,<
	SKIPE	INDY	;SKIP IF NOT @
	JRST	LP$31	;BR IF IS
	SKIPE	CHKEXE	;SKIP IF NOT /C
	JRST	LP$12	;SKIP EDS WRITE IF /C
LP$31:	SKIPN	CCLIND
	JRST	LP$12
	MOVEI	T,ALT	;GET DELIM
	DPB	T,[POINT 7,TMPSAV+7,20]	;
	DPB	T,[POINT 7,TMPSAV+7,34]	;SET TERMINATOR
	MOVEI	T,42	;GET CODE
	DPB	T,[POINT 7,TMPSAV+7,27]	;DEPOSIT $"$
	MOVE	T,[ASCII /TECO /]
	MOVEM	T,TMPSAV
IFN TEMP,<
	MOVE	TT,[XWD 'EDS',0]
	MOVE	TT1,[IOWD 10,TMPSAV]
	MOVE	T,[XWD 3,TT]
	CALLI	T,TMPCOR
	SKIPA
	JRST	LP$12
>
	HLLZ	B,TMPTEC
	HRRI	B,'EDS'
	MOVEM	B,FILNAM
	MOVSI	B,'TMP'
	MOVEM	B,FILNAM+1
	MOVE	T,.JBFF
	MOVEI	B,LOWTPP
	MOVEM	B,.JBFF
	INIT	CCLCHN,0
	SIXBIT	/DSK/
	XWD	CCLB,0
	JRST	CCLOER
	SETZM	FILNAM+2
	SETZM	FILNAM+3
	ENTER	CCLCHN,FILNAM
	JRST	CCLOEE
	OUTPUT	CCLCHN,
	STATZ	CCLCHN,760000
	JRST	CCLOPE
	MOVEI	A,^D50
	MOVE	B,[POINT 7,TMPSAV]
LP$13:	ILDB	CH,B
	IDPB	CH,CCLB+1
	SOJG	A,LP$13
	JRST	CCLORL
CCLOER:	PUSH	P,[POINT 7,[ASCIZ /%Can't Open ###EDS.TMP -- Proceeding
/]]
	JRST	CCLORP
CCLOEE:	PUSH	P,[POINT 7,[ASCIZ /%Can't Enter ###EDS.TMP -- Proceeding
/]]
	JRST	CCLORP
CCLOPE:	PUSH	P,[POINT 7,[ASCIZ /%Output Error on ###EDS.TMP -- Proceeding
/]]
CCLORP:	PUSHJ	P,STRGPT
CCLORL:	MOVEM	T,.JBFF
	CLOSE	CCLCHN,
	RELEAS	CCLCHN,
>
LP$12:
IFE CHECKP,<JRST CMSR01>
IFN CHECKP,<
	SKIPN	CHKEXE	;SKIP IF THIS IS CHECKPOINT UPDATE
	JRST	CMSR01	;BR IF NOT
	MOVE	AA,[POINT 7,CMSTRB]	;GET POINTER
	MOVEM	AA,SFPART	;SAVE IT
	SETOM	SFPARS	;SET SWITHCE
>
U	SFPART,1
U	SFPARS,1
IFN CHECKP,<
IFN SFDCNT,<
	MOVEI	AA,CHPPTH	;GET PAT ADDR
	MOVEM	AA,FILSFP	;SET
U CHPPTH,5+SFDCNT
>
	PUSHJ	P,FILSPC	;CALL PARSER
	SETZM	SFPARS
	MOVSI	AA,'CHP'	;GET DEFAULT
	SKIPE	INDY	;SKIP IF NOT INDIRECT
	MOVSI	AA,'CCL'	;GET DEFAULT
	SKIPN	SFPARI	;SKIP IF NO EXT
	MOVEM	AA,FILNAM+1	;SET EXT
	MOVE	AA,FILNAM	;GET NAM
	MOVEM	AA,CHKLKP	;SET
	MOVEM	AA,CHKLK2	;
	MOVE	AA,FILNAM+1	;GET EXT
	MOVEM	AA,CHKLKP+1	;SET
	MOVEM	AA,CHKLK2+1	;
	MOVE	AA,FILPPN	;GET PPN
IFN SFDCNT,<
	SKIPE	CHPPTH+SFDCNT+4
	MOVEI	AA,CHPPTH
>
	MOVEM	AA,CHKLKP+3	;GET PPN
	MOVEM	AA,CHKLK2+3	;
	MOVE	AA,FILDEV	;GET DEVICE
	MOVEM	AA,CHKOPN+1	;SET
	JRST	TABSET	;GO OPEN
>
CMSR01:	TRNE	FF,HELPRB!DOCBIT	;SKIP IF NEITHER
	SKIPA
	JRST	CMSR1A	;BR
	MOVE	AA,[POINT 7,CMSTRB]	;GET POINTER
	MOVEM	AA,SFPART	;SET
	SETOM	SFPARS	;SET FUNNY FILE NAME
IFN SFDCNT,<
	MOVEI	AA,HELPPT	;GET PATH
	MOVEM	AA,FILSFP
U HELPPT,5+SFDCNT
>
	PUSHJ	P,FILSPC
	SKIPE	FILNAM	;SKIP IF NO FILENAME SEEN
	JRST	HLPSPC	;BR IF SPECIFIED
	TRNN	FF,DOCBIT	;SKIP IF DOC
	JRST	CMDHLP	;HELPER
	JRST	CMDDOC	;DOCUMENTATION
HLPSPC:	MOVSI	AA,'DOC'	;GET DEFAULT EXTENTION
	TRNN	FF,DOCBIT	;SKIP IF DOC
	MOVSI	AA,'HLP'	;OTHER DEFAULT
	SKIPN	SFPARI		;SKIP IF EXT
	MOVEM	AA,FILNAM+1	;SET IN
	MOVE	AA,FILPPN
IFN SFDCNT,<
	SKIPE	HELPPT+SFDCNT+4
	MOVEI	AA,HELPPT
>
	MOVEM	AA,FILNAM+3	;SAVE IT
	SKIPN	SFPADV	;CHECK FOR OPENNING GIVEN DEVICE
	JRST	CMSR1B	;BR
	SETZM	HELP3
	MOVE	AA,FILDEV	;GET DEVICE
	MOVEM	AA,HELP3+1
	MOVE	AA,[XWD 0,IBUF]
	MOVEM	AA,HELP3+2	;SAVE
	OPEN	INCHN,HELP3	;TRY
	JRST	CMSR1C
CMSR1F:	LOOKUP	INCHN,FILNAM	;LOOKUP
	JRST	CMSR1C	;NOPE
	JRST	CMDHL9	;GO AN DO THE PRINTING
CMSR1B:	TRNN	FF,DOCBIT	;SKIP IF DOC
	JRST	CMSR1D
	INIT	INCHN,0
	SIXBIT	/DOC/
	XWD	0,IBUF
	JRST	CMSR1E
	JRST	CMSR1F
CMSR1D:	INIT	INCHN,0
	SIXBIT	/HLP/
	XWD	0,IBUF
	JRST	CMSR1E
	JRST	CMSR1F
CMSR1E:	INIT	INCHN,0
	SIXBIT	/SYS/
	XWD	0,IBUF
	SKIPA
	JRST	CMSR1F
CMSR1C:	MOVE	AA,[POINT 7,[ASCIZ /?Can't Find Specified Documentation File
/]]
	TRNN	FF,DOCBIT
	MOVE	AA,[POINT 7,[ASCIZ /?Can't Find Specified Help File
/]]
	PUSH	P,AA
	PUSHJ	P,STRGPT
	JRST	TEC2
CMSR1A:	MOVEI	A,CMDSTZ	;GET COUNT
	MOVEM	A,CCCNT	;SET
	MOVE	A,[POINT 7,CMSTR2]	;GET TTY BUFFER POINTER
	MOVEM	A,CCPTR	;SET POINTER
U CCCNT,1
U CCPTR,1
	MOVE	AA,[POINT 7,CMSTRB]	;GET FROM POINTER
;
;THIS SECTION DOES /E:NNN AND /P:NNN
;
	TRZ	FF,NOSPST
	SKIPN	ECOUNT
	JRST	CHKPCT	;BR TO CHECK FOR /P
	PUSH	P,[XWD ECOUNT,EBUFER]
	PUSHJ	P,STUFF0	;STUFF A NUMERIC ARGUMENT
	PUSHJ	P,STUFF1	;STUFF Q-REG LOAD
	XWD	4,STFMPM
	TRO	FF,NOSPST
CHKPCT:	SKIPN	PCOUNT
	JRST	CHKRES
	PUSH	P,[XWD PCOUNT,PBUFER]
	PUSHJ	P,STUFF0
	PUSHJ	P,STUFF1
	XWD	4,STFPPM
	TRO	FF,NOSPST
CHKRES:	SKIPN	ICOUNT	;SKIP IF SEQ SET
	JRST	CHKRS2	;SKIP IF NOT
	PUSH	P,[XWD PCOUNT,PBUFER]	;PUSH POINTERS
	PUSHJ	P,STUFF0	;SET IT
	PUSHJ	P,STUFF1	;AND COMMAND
	XWD	4,STFIPM	;COMMAND POINTERS
	TRO	FF,NOSPST	;SET COMMAND STUFFED
CHKRS2:	TRNN	FF,NOSPST!NOSTRG
	JRST	TABSET
	SETOM	SPECSI
	TRNN	FF,NOSTRG	;SKIP IF STRING PRESENT
	JRST	CMSRDN
;
;THIS SECTION CHECKS FOR MACRO SET UP
;
	TRNN	FF,COMBIT!PERBIT!EXEBIT	;A MACRO ?
	JRST	CMSR03	;BR IF NOT
	PUSHJ	P,STUFF1
	XWD	2,STFMLD
	PUSHJ	P,STUFF2
	PUSHJ	P,STUFF1
	XWD	^D20,STFMC2
	TRNN	FF,COMBIT	;COMMA ?
	JRST	CMSR07	;BR IF NOT
;
;THIS SECTION DOES EW'S, EB'S OR EA'S
;
CMSR03:	TRNN	FF,EQLBIT!MAKBIT	;EW ?
	JRST	CMSR04	;BR IF NOT
	PUSHJ	P,STUFF1
	XWD	2,STFEWC
	PUSHJ	P,STUFF2
	TRNN	FF,EQLBIT	;ER TOO ?
	JRST	CMSR11	;BR IF NOT
	PUSHJ	P,STUFF1
	XWD	3,STFERC
	PUSHJ	P,STUFF2
	JRST	CMSR06
CMSR04:	TRNN	FF,BAKBIT	;EB OR EA ?
	JRST	CMSR08	;BR IF EA
	PUSHJ	P,STUFF1
	XWD	2,STFEBC
	PUSHJ	P,STUFF2
	JRST	CMSR06
CMSR08:	PUSHJ	P,STUFF1
	XWD	2,STFEAC
	PUSHJ	P,STUFF2
;
;THIS SECTION COMPLETES THE COMMAND STRING
;
CMSR06:
CMSR07:	TRNN	FF,APNBIT
	JRST	CMSR11
	PUSHJ	P,STUFF1
	XWD	^D26,STFAPN
	TRNN	FF,RESBIT
	JRST	CMSR11
	PUSHJ	P,STUFF1
	XWD	3,STFREN
	JRST	CMSR11
;
;STUFF0 -- STUFF A NUMERIC ARGUMENT
;	CALLED:
;		PUSH	P,[XWD <ADDRESS OF COUNT>,<ADDRESS OF STRING>]
;		PUSHJ	P,STUFF0
;
;	USES STUFF1
;	T, TT, AND TT1 ARE ZAPPED
;
STUFF0:	HLRZ	T,-1(P)	;GET ADDRESS OF COUNT
	HRL	TT,(T)	;GET COUNT
	HRR	TT,-1(P)	;GET ADDRESS
	MOVE	T,[PUSHJ P,STUFF1]
	MOVE	TT1,[JRST STFRT0]
	JRST	T	;GO AND EXEC
STFRT0:	POP	P,-1(P)	;COMPRESS
	POPJ	P,
;
;STUFF1 -- STUFF THE TTY BUFFER WITH A LITTERAL
;	CALLED:
;		PUSHJ	P,STUFF1
;		XWD	<CHARS>,<HALFWORD POINTER TO AREA>
;	A IS THE BUFFER POINTER
;	B IS DESTROYED
;	D IS DESTROYED
;
STUFF1:	HLRZ	D,@(P)	;GET COUNT
	MOVE	B,[POINT 7,.-.]
	HRR	B,@(P)	;GET COUNT
	AOS	(P)	;BUMP TO RETURN
STFLP1:	ILDB	CH,B	;GET CHAR
	IDPB	CH,A	;STORE
	SOSG	CCCNT
	JRST	CMST8A
	SOJG	D,STFLP1	;LOOP
	POPJ	P,
;
;STUFF2 -- STUFF STRING FROM COMMAND STRING BUFFER INTO
;	TTY BUFFER, STOP ON TERMINATOR
;	CALLED:
;		PUSHJ	P,STUFF2
;	A IS BUFFER POINTER (TTY)
;	AA IS COMMAND BUFFER POINTER
;
STUFF2:	ILDB	CH,AA	;GET CHAR
STUF2X:	CAIN	CH,"["	;A PPN START ?
	JRST	STUFF3	;BR IF IS
	CAIN	CH,","	;COMMA ?
	POPJ	P,
	CAIN	CH,"="	;EQUAL ?
	POPJ	P,
	CAIN	CH,"_"	;LARR ?
	POPJ	P,
	CAIN	CH,"%"	;PERCENT ?
	POPJ	P,
	CAIN	CH,ALT	;ALT ?
	POPJ	P,
STUFF4:	IDPB	CH,A	;SET
	SOSG	CCCNT
	JRST	CMST8A
	JRST	STUFF2	;LOOP
STUFF3:	IDPB	CH,A
	SOSG	CCCNT
	JRST	CMST8A
	ILDB	CH,AA
	PUSHJ	P,TERMCK
	JRST	STUF2X
	PUSHJ	P,FENDCK
	JRST	STUFF4
	JRST	STUFF3	;NO
;
;STUFF5 -- STUFF A PARAMETER STRING
;	INTO THE TTY BUFFER WITH THE APPROPRIATE MASSAGES
;	CALLED:
;		PUSHJ	P,STUFF5
;	A IS BUFFER POINTER (TTY)
;	AA IS COMMAND STRING BUFFER POINTER
;	B IS DESTROYED
;
STUFF5:	ILDB	CH,AA	;GET FIRST
	CAIE	CH,42	;A "
	JRST	STUFF6	;BR IF NOT
STUFF7:	ILDB	CH,AA	;GET NEXT
	CAIE	CH,42	;A "
	JRST	STUFF8	;BR IF NOT
	ILDB	CH,AA	;GET NEXT HAR
	CAIE	CH,42	;IS IT A " TOO ?
	POPJ	P,	;RETURN
	JRST	STUFF8	;BR IF IS
STUFF8:	IDPB	CH,A	;SET TO BUFFER
	SOSG	CCCNT
	JRST	CMST8A
	JRST	STUFF7
STUFF6:	CAIN	CH,ALT
	POPJ	P,	;RETURN
	IDPB	CH,A	;SET
	SOSG	CCCNT
	JRST	CMST8A
	ILDB	CH,AA	;GET NEXT
	JRST	STUFF6
;
;THE LITERRAL PARTS OF THE TTY BUFFER COMMAND STRING
;
STFMLD:	ASCII	/ER/
STFMC2:	ASCII	/<A-(^N+1);>HX&MHK/
STFEWC:	ASCII	/EW/
STFERC:	ASCII	/ER/
STFEAC:	ASCII	/EA/
STFEBC:	ASCII	/EB/
STFINS:	ASCII	/I/
STFMCL:	ASCII	/M&M/
STFAPN:	ASCII	/<A-(^N+1);^E"NZJ12I0J'>/
STFREN:	ASCII	/ZJ/
STFALT:	ASCII	//
STFYAK:	ASCII	/Y/
STFMPM:	ASCII	/U&E/
STFPPM:	ASCII	/U&P/
STFIPM:	ASCII	/EQ/
;
;
;SOME FINAL FUN
;
CMSR11:	TRNN	FF,EXEBIT!PERBIT!COMBIT
	JRST	CMSR09
	TRNN	FF,PERBIT	;PARMS ?
	JRST	CMSR10	;NO
	PUSHJ	P,STUFF1
	XWD	2,STFINS
	PUSHJ	P,STUFF5
CMSR10:	PUSHJ	P,STUFF1
	XWD	4,STFMCL
	JRST	CMSR12
CMSR09:	TRNN	FF,MAKBIT	;EW ?
	JRST	CMSR13	;BR IF NOT
	TRNN	FF,EQLBIT	;ER TOO ?
	JRST	CMSR12	;BR IF NOT
CMSR13:	TRNE	FF,APNBIT	;APPEND ?
	JRST	CMSR12	;YES
	PUSHJ	P,STUFF1
	XWD	3,STFYAK
	JRST	CMSRDN
CMSR12:	PUSHJ	P,STUFF1
	XWD	1,STFALT
CMSRDN:
	PUSHJ	P,STUFF1
	XWD	1,STFALT
;THIS SECTION SETS UP INITIALIZATION OF
;	TECO TO REFLECT THE TTY THE USER
;	HAS LOGGED IN UNDER
;
IFN INITFL,<
TABSET:	SKIPE	NOTABF	;SKIP IF NO FAS
	JRST	INTDN3
	MOVE	A,[SIXBIT /TECOX/]	;GET INIT TABLE FILE NAME
	MOVEM	A,INITLK	;SET
	MOVSI	A,'TAB'	;GET EXT
	MOVEM	A,INITLK+1	;SET
IFN SFDCNT,<
	MOVEI	A,INITPT
	MOVEM	A,INITLK+3	;SET UP PATH
>
	MOVSI	A,'DSK'	;GET SYSTEM ONE
	MOVEM	A,INITDV+1	;SET
	MOVE	A,[XWD 0,INITBF]	;GET HEADER
	MOVEM	A,INITDV+2	;SET
	PUSH	P,.JBFF	;SAVE
	MOVEI	A,INBUF1
	MOVEM	A,.JBFF	;SET
	TRNE	FF,LTBBIT	;SKIP IF NOT LOCAL
	JRST	CMST10	;BR IF IS
	OPEN	INITCH,INITDV
	JRST	INTER0	;BR IF CAN'T
	LOOKUP	INITCH,INITLK
	JRST	TRYLCL	;TRY LOCAL
	JRST	INTRDR
INTER0:	PUSH	P,[POINT 7,[ASCIZ /%Can't open DSK: for reading TECOX.TAB -- Using defaults
/]]
	PUSHJ	P,STRGPT
	JRST	INTDN3
INTER1:	PUSH	P,[POINT 7,[ASCIZ /%Can't open SYS: for reading TECOX.TAB -- Using defaults
/]]
	PUSHJ	P,STRGPT
	JRST	INTDN3
INTER2:	PUSH	P,[POINT 7,[ASCIZ /%Can't find TECOX.TAB in SYS: or DSK: -- Using defaults
/]]
	PUSHJ	P,STRGPT
	JRST	INTDN3	;BR TO INIT
;
INITIO:	PUSH	P,[POINT 7,[ASCIZ /
%Input Error reading TECOX.TAB -- Continuing
/]]
	PUSHJ	P,STRGPT
	POPJ	P,
;
TRYLCL:
CMST10:
	MOVSI	A,'SYS'	;GET DEVICE
	MOVEM	A,INITDV+1	;SET
	RELEASE	INITCH,
	SETZM	INITLK+2
IFN SFDCNT,<
	MOVEI	A,INITPT
	MOVEM	A,INITLK+3
>
IFE SFDCNT,<
	SETZM	INITLK+3
>
	OPEN	INITCH,INITDV
	JRST	INTER1
	LOOKUP	INITCH,INITLK
	JRST	INTER2
INTRDR:	INBUF	INITCH,1	;GET BUFFERS
	POP	P,.JBFF	;REST
U INITBF,3
U INITLK,4
U INITDV,3
U INITPT,4	;FAKE PATH
	SETOM	INTSWR	;TELL THAT INIT IS IN AFFECT
	SETOM	INTSW2
U INTSWR,1	;INIT TIME SWITCH
U INTSW2,1
	GETLIN	A,	;GET LINE
	MOVEM	A,TTYNMS	;SAVE NAME FOR LATER
U	TTYNMS,1	;AREA FOR SAVING
>
;******DO NOT SEPARATE THE FOLLOWING
U TMPSAV,1
U CMSTR2,<CMDSTZ+4>/5	;COMMAND BUFFER
IFE INITFL,<TABSET:>
INTDN3:	MOVEI	AA,ERSWRT
	MOVEM	AA,NOERRQ
	HRREI	AA,TYCASW
	MOVEM	AA,TYCASF
	HRREI	AA,ERRMSG-2
	MOVEM	AA,ERRLEN
	HRREI	AA,AUTOFS
	MOVEM	AA,AUTOF
	MOVEI	AA,LNCFGG
	MOVEM	AA,TECLNI
	MOVEI	AA,SEQDFL	;GET SEQ INCR
	MOVEM	AA,SEQLNI	;SET IT
IFN CHECKP,<
;CHECKPOINT FILE INITIALIZATION
;
	SKIPN	CHKEXE	;RESTART ? (SKIP IF IS)
	SKIPN	CHKPNT	;IS CHECKPOINT ON ?
	JRST	JAKCPS	;BR IF NOT
	MOVE	A,TMPTEC	;GET TEM NAME
	MOVEM	A,CHKLKP	;INIT INPUT SIDE NAME
	MOVEM	A,CHKLK2	;INIT OUTPUT SIDE NAME
	MOVSI	A,'CHP'	;GET EXT
	MOVEM	A,CHKLKP+1	;SET
	MOVEM	A,CHKLK2+1	;
	SETZM	CHKLK2+2
	SETZM	CHKLKP+2
	SETZM	CHKLKP+3
	SETZM	CHKLK2+3
	MOVSI	A,'DSK'	;GET DEVICE
	MOVEM	A,CHKOPN+1	;SET
	MOVEI	A,1
	MOVEM	A,CHPBLK	;INIT BLOCK #
U	CHPBLK,1
	OPEN	CHPCHN,CHKOPN
	JRST	CHPER0
	ENTER	CHPCHN,CHKLK2
	JRST	CHPER1
	CLOSE	CHPCHN,
	PUSHJ	P,CHKSV2
	JRST	JAKCP2
CHPER0:	PUSHJ	P,CHPRR0	;CALL ERROR PRINT
	SETZM	CHKPNT	;OFF WITH CHECKPOINT
	RELEASE	CHPCHN,
	JRST	JAKCP2	;BYE
CHPER1:	PUSHJ	P,CHPRR1	;CALL ERROR PRINT
	SETZM	CHKPNT
	RELEASE	CHPCHN,
	JRST	JAKCP2	;BYE
CHPRR0:	PUSH	P,[POINT 7,[ASCIZ /
%Can't open checkpoint file -- Checkpointing stops
/]]
	PUSHJ	P,STRGPT
	POPJ	P,
CHPRR1:	PUSH	P,[POINT 7,[ASCIZ /
%Can't enter checkpoint file -- Checkpointing stops
/]]
	PUSHJ	P,STRGPT
	POPJ	P,
CHPRR2:	PUSH	P,[POINT 7,[ASCIZ /
%Can't lookup checkpoint file -- Checkpointing stops
/]]
	PUSHJ	P,STRGPT
	POPJ	P,
;
CHPIOE:	PUSH	P,[POINT 7,[ASCIZ /
%Input Error reading checkpoint file -- Continuing
/]]
	PUSHJ	P,STRGPT
	POPJ	P,
;
CHPOTE:	PUSH	P,[POINT 7,[ASCIZ /
%Output Error writing checkpoint file -- Checkpointing stops
/]]
	PUSHJ	P,STRGPT
	SETZM	CHKPNT
	RELEAS	CHPCHN,
	POPJ	P,
;
CHPER2:	PUSHJ	P,CHPRR2
	JRST	TEC2
JAKCPS:	SKIPN	CHKEXE	;CHECKPOINT RSTART ?
	JRST	JAKCP2	;BR IF NOT
	SETZM	CHKLKP+2
	SETZM	CHKLK2+2
	MOVE	A,[XWD 0,CHBF]
	MOVEM	A,CHKOPN+2
	OPEN	CHPCHN,CHKOPN
	JRST	CHPER0	;BR IF ERROR
	LOOKUP	CHPCHN,CHKLKP
	JRST	CHPER2	;BR IF ERROR
	PUSH	P,.JBFF
	MOVEI	A,CHBUF
	MOVEM	A,.JBFF
	INBUF	CHPCHN,1
	POP	P,.JBFF
	INPUT	CHPCHN,
	STATZ	CHPCHN,740000
	PUSHJ	P,CHPIOE
	MOVEI	A,1
	MOVEM	A,CHPBLK	;SAVE BLOCK #
	STATO	CHPCHN,20000
	JRST	JAKCP2
JAKCP4:	CLOSE	CHPCHN,
	PUSHJ	P,CHKSV2	;CALL FOR CHECKPOINTING
	SETZM	CHKEXE
>
JAKCP2:
	SETZM	FF
	SETZM	F2	;RESET FLAGS
;COMPUTE A VALUE WHICH IS 2/3 THE SIZE OF THE CHARACTER BUFFER.IF
;1/3 IS LESS THAN 128 CHARACTERS, THE BUFFER WILL BE 2/3 FILLED ON
;A "Y" OR "A" COMMAND,OTHERWISE, THE BUFFER WILL BE FILLED TO THE
;TOTAL AVAILABLE BUFFER - 128 CHARACTERS. PAYING ATTENTION TO THE
;FORM FEED AND LF OPERATORS.

;IT SHOULD BE NOTED THAT IN THE CASE OF AUTOMATIC 
;MEMORY EXPANSION, THESE INSTRUCTIONS MUST BE RE-EXECUTED
;TO INSURE PROPER MEMORY BOUNDS.

	PUSH	P,INITG		;FOR IN LINE CODING POPJ
CRE23:	MOVE	A,.JBFF		;LATEST VALUE OF FF
	IMULI	A,5		;5 CHARACTERS PER MEM WORD
	MOVEM	A,MEMSIZ	;MEMSIZ:=C(.JBFF)*5
INITG:	POPJ	P,.+1		;EXIT OR CONTINUE

	MOVE	A,CBUF
	MOVEI	A,1(A)
	MOVEM	A,CBUFH		;CBUFH:=CBUF+1
	MOVEI	A,SYL
	MOVEM	A,DLIM		;DLIM:=SYL
	MOVE	A,[XWD 10014,-1]
	MOVEM	A,NROOM2	;NROOM2:=XWD 10014,-1
	MOVEI	FF,0		;CLEAR FLAG REGISTER
	SKIPE	SRHMOD		;IF DEFAULT SEARCH MODE IS NOT 0,
	TLOA	FF,PMATCH	;MAKE EXACT MODE CURRENT
GOE:	TRZA	FF,777777-TRACEF-QMFLG-FORM-SEQF
GO:	TRZ	FF,777777-TRACEF-FORM-SEQF
	SETZM	ARMED
	SETZM	QLEVER	;ZAP LEVEL COUNT
	SETOM	RUN222	;ENABLE REE
	TRZ	F2,NOTRAC
	TLZ	F2,YBKARW
	MOVE	P,CBUF
	MOVEM	P,CCSV2
	MOVEM	P,CCSV1
U CCSV2,1
U CCSV1,1
	MOVE	P,[XWD -LPDL,PDL]	;INITIALIZE PUSHDOWN LIST
	SETZM	PDL		;FLAG PDL TOP - NOTE: PDL FLAGS ARE
				;0 = TOP OF PDL
				;-1= LAST ITEM IS AN ITERATION
				;+1= LAST ITEM IS A PARENTHESIS
				;>1= LAST ITEM IS A MACRO
;GO+4	INSERTED 1 INSTRUCTION [ED# 114]
	SETZM	EQM		;CLEAR MACRO LEVEL COUNT
	MOVE	PF,[XWD -LPF-1,PFL-1]
	JRST	CLIS

;FROM REE COMMAND DISTRIBUTION IN THE MONITOR

REE:	SKIPN	RUN222
	JRST	REEERR
	TTCALL	CLRBFO,		;STOP TYPEOUT
	PUSHJ	P,TTOPN1
	JRST	GO		;GO AND LISTEN FOR INPUT
REEERR:	PUSH	P,[POINT 7,[ASCIZ /?Can't Re-enter until Started
/]]
	PUSHJ	P,STRGPT
	TTCALL	CLRBFI,
	CALLI	0,EXIT
;ROUTINE TO RETURN NON-NULL TTY CHARACTER IN CH.
;CALL	PUSHJ PDP,TYI 
;	RETURN

TYI:
IFN INITFL,<
	SKIPE	INTSWR	;SKIP IF NOT INIT
	JRST	INTGET	;GET IT
>
	SKIPN	SPECSI	;SKIP IS IS FUNNY COMMANDS
	JRST	TYII3	;BR IF NOT
TYII2:	ILDB	CH,CCPTR	;GET CHAR (WE KNOW THIS WILL STOP)
	JRST	TYI3
TYII3:
IFN CHECKP,<
	SKIPE	CHKEXE	;SKIP IF NO CHECKPOINT READING
	JRST	CHKGET	;BR TO CHECKPOINT READ
	SKIPN	FUNNYR	;SKIP IF TO PRINT MESSAGE
	JRST	FUNTYS	;BR
	PUSHJ	P,TTOPN1	;OPEN TTY
	PUSH	P,[POINT 7,[ASCIZ /
[Restart Complete]
/]]
	PUSHJ	P,STRGPT
	SETZM	FUNNYR
>
FUNTYS:	TLZE	FF,TYOF		;NEED A TYO?
	OUTPUT	TTY,0		;YES. DO SO.
TYI0:	SOSG	TIB+2		;CHARS IN NORMAL MODE?
	JRST	TYI1		;NONE LEFT
TYI2:	ILDB	CH,TIB+1	;YES. GET ONE
	JUMPE	CH,TYI0		;FLUSH NULLS
TYI3:	TRZ	FF,DDTMF	;CLR TTCALL REQUEST FLAG
IFN RUBSW,<
	SETO	A,		;AIM AT THIS TTY
	TTCALL	6,A		;GETSTS
	TLNN	A,4		;SUPPRESS ECHO?
	>
	CAIE	CH,7		;BELL?
	JRST	ALTLIN		;NO, BUT WATCH OUT FOR OLD ALTMODES
	PUSHJ	P,TYOM
	JRST	CHKSAV

TYI1:	TRNE	FF,DDTMF	;SHOULD TYI BE TTCALL?
	JRST	TYIDDT		;YES
	INPUT	TTY,0		;NO. ORDINARY.
	STATO	TTY,20000	;END OF FILE?
	JRST	TYI2
	PUSHJ	P,TTOPEN	;CLEAR EOF THE HARD WAY
	JRST	TYI0		;^Z WAS SEEN ALREADY. GET ANOTHER CH

;CONVERT 175 & 176 TO ALTMODE (033) UNLESS TTY LC IS ON

ALTLIN:	CAIL	CH,175		;OLD ALTMODE?
	CAILE	CH,176
	JRST	CHKSAV
	TRNN	F2,NOALT	;[137]TEST TTY NOALT BIT
ALTX:	MOVEI	CH,ALT		;NOT ON, SO CONVERT TO 033
	JRST	CHKSAV

;CONVERT 175 & 176 TO ALTMODE (033) IF EO = 1

ALTEO:	CAIE	CH,175		;OLD ALTMODE?
	CAIN	CH,176
	CHKEO	EO21,ALTX	;RUNNING OLD MACRO? IF SO, CONVERT
	POPJ	P,
IFN CHECKP,<
TYIVF:	SKIPE	INDY	;SKIP IF NOT INDIRECT
	JRST	TYIDTC	;IS INDIRECT FILE
	SKIPE	CHKEXE	;NO CHECKPOINTING
	JRST	TYI
>
IFE CHECKP,<TYIVF:>
TYIDTC:
TYIDDT:	TLZE	FF,TYOF		;CHARACTERS WAITING FOR OUTPUT?
	OUTPUT	TTY,0		;YES, FORCE THEM OUT
	TTCALL	0,CH		;WAIT FOR A SINGLE CHARACTER
	JRST	TYI3

TTOPEN:	SKIPE	INTSW2
	JRST	TTOPN0
	SKIPN	CHKEXE	;SKIP IF CHECKPOINT ON
	JRST	TTOPN1	;BR
TTOPN0:	SKIPE	CHKTOP	;SKIP IF 1ST TIME
	POPJ	P,	;RETURN
U	CHKTOP,1
	SETOM	CHKTOP	;SET 1ST TIME IND
	SKIPA
TTOPN1:	SETZM	CHKTOP
	MOVEI	T,TTYBFS
	EXCH	T,.JBFF		;SET .JBFF AND SAVE IT
	INIT	TTY,100		;INIT THE CONSOLE
	SIXBIT	/TTY/
	XWD	TOB,TIB		;SHOULD BE 
	JRST	.-3		;I REALLY WANT TTY
	INBUF	TTY,1
	OUTBUF	TTY,1		;KEEP IT SMALL
	MOVEM	T,.JBFF		;RESTORE .JBFF
	POPJ	P,
IFN INITFL,<
INTGET:	TLZE	FF,TYOF	;CHAR TO PUT ?
	OUTPUT	TTY,	;DO IT
	MOVE	CH,INTSWR	;GET SWITCH
	PUSH	P,A	;SAVE A
	JRST	STABLE(CH)	;JUMP TO PROPER DECODER
	JRST	PASAAC	;LOOKING FOR LAST ALTMODE
	JRST	PASSCH	;SCAN FOR AN ALTMODE
	JRST	SCANFT	;LOOK FOR THE PROPER TTY NUMBER
	JRST	PASWAC	;LOOK FOR 2ND ALTMODE (DEFAULT STRING)
	JRST	PASSCH	;SCAN FOR ALTMODE
STABLE:
PASSCH:	PUSHJ	P,ICHARG	;GET CHAR
PASSET:	SOS	INTSWR	;NEXT STATE
INTRT2:	SKIPN	INTSWR
	JRST	BYEBY2
INTRET:	POP	P,A	;REST REG
	SKIPN	CH
	JRST	TYI
	JRST	TYI3
PASWAC:	PUSHJ	P,ICHARG	;GET CHARACTER
	JRST	PASSET	;TO NEXT STATE
PASRES:	AOS	INTSWR	;BACK TO LAST STATE
	JRST	INTRT2	;RETURN
PASAAC:	PUSHJ	P,ICHARG	;GET CHAR
	SKIPA
	JRST	PASRES	;BACK TO LAST STATE
	CLOSE	INITCH,
	RELEASE	INITCH,
	SETZM	INTSWR	;RESET INIT TIME SW
	JRST	INTRET	;RETURN
SCANFT:	PUSH	P,AA	;SAVE ANOTHER REG
SCNSK8:	PUSH	P,[POINT 6,A]	;SET POINTER
	MOVEI	AA,6	;GET COUNT
	SETZM	A
SCNLP1:	PUSHJ	P,ICHARG	;GET CHAR
	JFCL
	SKIPN	INTSWR	;SKIP IF NOT EOF
	JRST	BYEBYE	;BR IF IS
	PUSHJ	P,UCCVT
	CAIGE	CH,"A"	;CHECK ALHA
	JRST	SCNSK1	;BR IF NOT
	CAIG	CH,"Z"	; ?
	JRST	SCNSK2	;BR IF IS ALPHA
SCNSK1:	CAIGE	CH,"0"	;IS IT NUM ?
	JRST	SCNSK3	;BR IF NOT
	CAILE	CH,"9"	; ?
	JRST	SCNSK3	;BR IF NOT
SCNSK2:	SUBI	CH,40	;TO SIXBIT
	SOSL	AA	;SKIP IF MORE THAN 6
	IDPB	CH,(P)	;TO HOLDER
	JRST	SCNLP1	;LOOP
SCNSK3:	CAIE	CH,":"	;DONE WITH NAME ?
	JRST	SCNLP1	;NO
	CAMN	A,[SIXBIT /OTHER/]	;OTHER ?
	JRST	SCNSK4	;YES BR
	CAMN	A,TTYNMS	;HIS TTY ?
	JRST	SCNSK4	;YES
SCNLP2:	PUSHJ	P,ICHARG	;GET CHAR
	JRST	SCNSK5	;BR IF ALT
SCNSK6:	SKIPN	INTSWR	;SKIP IF EOF
	JRST	BYEBYE
	JRST	SCNLP2	;LOOP
SCNSK5:	PUSHJ	P,ICHARG	;GET CHAR
	JRST	SCNSK7	;GO BACK FOR SCAN
	JRST	SCNSK6	;
SCNSK7:	POP	P,A	;POP POINTR
	JRST	SCNSK8	;LOOP
SCNSK4:	SOS	INTSWR	;TO NEXT STATE
	POP	P,AA	;POP REG
	POP	P,AA	;
	JRST	PASSCH	;RETURN
BYEBYE:	PUSH	P,[POINT 7,SCNMES]
	PUSHJ	P,STRGPT
	SETZM	INTSW2
	POP	P,AA	;POP REG
	POP	P,AA	;
	JRST	INTRET	;RETURN
BYEBY2:	PUSH	P,[POINT 7,SCNMES]
	PUSHJ	P,STRGPT
	SETZM	INTSW2
	JRST	INTRET
SCNMES:	ASCIZ /%Premature End-Of-File on TECOX.TAB Initialization File
/
ICHARG:	SETZM	CH
	SKIPGE	INITBF	;CHECK FOR 1ST I/O
	PUSHJ	P,ICHAR2	;GET CHAR
	ILDB	CH,INITBF+1	;GET CHAR
	SOSG	INITBF+2	;DECR COUNT
	PUSHJ	P,ICHAR2	;CALL FOR CHAR
	CAIN	CH,ALT	;ALT ?
	JRST	ICHARE	;YEAH
	CAIN	CH,175	;?
	JRST	ICHARE	; Y
	CAIN	CH,176	;?
	JRST	ICHARE	; Y
	AOS	(P)	;TO NEXT WORD
ICHARE:	POPJ	P,

ICHAR2:	INPUT	INITCH,
	STATZ	INITCH,740000
	PUSHJ	P,INITIO
	STATO	INITCH,20000
	POPJ	P,	;RETUN IF NOT EOF
	POP	P,INTSWR	;POP MY RETURN
	SETZM	INTSWR	;INDICATE
	AOS	(P)	;TO NON ALT RETRUN
	POPJ	P,	;POP FOR ICHARG
>

IFN CHECKP,<
U	CHKOPN,3
U	CHKLKP,4
U	CHKLK2,4
U	CHKEXE,1
U	CHKPNT,1
U	CHBCNT,1
CHKGET:	TLZE	FF,TYOF	;CHARS FOR OUTPUT ?
	OUTPUT	TTY,0	;DO THEM
	ILDB	CH,CHBF+1	;GET CHARACTER
	SOSLE	CHBF+2	;DEC COUNT
	JRST	CHKGT1	;BR IF GOT ONE
	AOS	CHPBLK	;INCR COUNT
	INPUT	CHPCHN,	;GET CHARS
	STATZ	CHPCHN,740000
	PUSHJ	P,CHPIOE
	STATO	CHPCHN,20000	;EOF ?
	JRST	CHKGT1	;BR IF NOT
	CLOSE	CHPCHN,
	PUSHJ	P,CHKSV2	;OPN CHECKPOINTING
	SETZM	CHKEXE
U	FUNNYR,1
	SETOM	FUNNYR	;SET SO NEXT REQ FOR INPUT
			;PRINTS MESSAGE
CHKGT1:	SKIPN	CH	;NULL ?
	JRST	TYI	;TRY NEXT IF IS
IFN RUBSW,<
	SKIPE NOECHO
	JRST	TYI3
>
IFN BACKSP,<
	CAIE	CH,"H"-100
	JRST	CHKGTA
	PUSHJ	P,TYOA
	TLZE	FF,TYOF
	OUTPUT	TTY,
	JRST	TYI3
>
CHKGTA:	PUSHJ	P,TYOM	;TYPE AS MESSAGE
	TLZE	FF,TYOF
	OUTPUT	TTY,
	JRST	TYI3
CHKSAV:	SKIPN	INTSW2	;SKIP IF INIT'ING
	SKIPN	CHKPNT	;CHECKPOINT ?
	POPJ	P,	;NO
	SKIPE	CHKEXE
	POPJ	P,
	IDPB	CH,CHBF+1	;SAVE IT
	SOSLE	CHBF+2	;DEC COUNT
	JRST	CHKSV3	;BR
	AOS	CHPBLK	;INCR BLOCK COUNT
	CLOSE	CHPCHN,
	PUSHJ	P,CHKSV2
	POPJ	P,
CHKSV2:	SKIPN	CHKPNT	;SKIP IF CK ON
	POPJ	P,	;RETURN IF NOT
	PUSH	P,A
	MOVE	A,[XWD CHBF,0]
	MOVEM	A,CHKOPN+2	;SET THEM
	SETZM	A
IFN SFDCNT,<
	SKIPE	CHPPTH+SFDCNT+4
	MOVEI	A,CHPPTH
>
	MOVEM	A,CHKLKP+3	;SET TO LOOKUP BLOCK
	MOVEM	A,CHKLK2+3
	POP	P,A
	OPEN	CHPCHN,CHKOPN	;OPEN CHANNEL
	JRST	CHPER3	;BR IF CAN'T
	LOOKUP	CHPCHN,CHKLKP	;LOOKUP
	JRST	CHPER5
	ENTER	CHPCHN,CHKLK2	;ENTER
	JRST	CHPER4	;ERROR
	USETO	CHPCHN,@CHPBLK	;POINT TO NEXT BLOCK
	PUSH	P,.JBFF
	PUSH	P,A
	MOVEI	A,CHBUF
	MOVEM	A,.JBFF
	OUTBUF	CHPCHN,1
	OUTPUT	CHPCHN,
	STATZ	CHPCHN,740000
	PUSHJ	P,CHPOTE
	POP	P,A
	POP	P,.JBFF
	POPJ	P,
CHPER3:	PUSHJ	P,CHPRR0	;ERROR PRINT
CHPER6:	SETZM	CHKPNT
	POPJ	P,
CHPER4:	PUSHJ	P,CHPRR1	;ERROR
CHPER7:	CLOSE	CHPCHN,
	RELEASE	CHPCHN,
	JRST	CHPER6
CHPER5:	PUSHJ	P,CHPRR2	;ERROR
	JRST	CHPER7
CHKSV3:	CAIN	CH,LF	;THIS A LF ?
	JRST	SAV$01	;YES
	TRNN	FF,ALTF	;LAST AN ALT ?
	POPJ	P,	;RETURN IF NOT
	CAIE	CH,ALT	;THIS ONE ?
	POPJ	P,	;RETURN IF NOT
SAV$01:	PUSH	P,A	;SAVE REG
	MOVE	A,[XWD CHBF,CHSAVB]
	BLT	A,CHSAVB+<3+BUFSIZ+3>-1
	CLOSE	CHPCHN,
	PUSHJ	P,CHKSV2
	MOVE	A,[XWD CHSAVB,CHBF]
	BLT	A,CHBF+<3+BUFSIZ+3>-1
	POP	P,A	;REST A
	POPJ	P,
>
IFE CHECKP,<
CHKSAV:	POPJ	P,
U CHKEXE,1
U CHKPNT,1
>
IFE INITFL,<
U INTSWR,1
U INTSW2,1
>
;ROUTINE TO TYPE A CHARACTER.
;CALL AS FOLLOWS:
;FOR TYPING TEXT:		FOR TYPING MESSAGES:
;	MOVE CH,CHARACTER		MOVE CH,CHARACTER
;	PUSHJ P,TYO			PUSHJ P,TYOM
;	RETURN				RETURN
;UNLESS TYOCTF IS TRUE, CONTROL CHARACTERS ARE TYPED WITH "^"
;FOLLOWED BY THE CORRESPONDING PRINTING CHARACTER.

TYOS:	TROA	F2,TYSPCL	;TYPE <CR>, ETC INSTEAD OF PRINTER CONTROLS
TYOM:	TRZ	F2,TYSPCL	;CLR SPECIAL TYPEOUT FLAG
	TROA	F2,TYMSGF	;SET NO-CASE-FLAGGING FLAG
TYO:	TRZ	F2,TYMSGF+TYSPCL	;CLR NO-CASE-FLAGGING FLAG & SPECIAL FLAG
	PUSH	P,CH		;SAVE CHAR IN CASE ^ OR ' NEEDED
	TLNE	FF,TYOCTF	;ET IN EFFECT?
;TYO+3 INSTRUCTION CHANGED			[EDIT#118]
	JRST	TYOB		;YES, TYPE ALL CHARACTERS AS IS
	PUSHJ	P,ALTEO		;CONVERT OLD ALTMODES IF EO=1
	CAIGE	CH,11
	JRST	TYO1		;BELOW TAB
	TRZN	F2,TYSPCL	;WANT <CR>, ETC INSTEAD OF PRINTER CONTROLS?
	JRST	TYOJ		;NO
	CAIG	CH,15		;IS IT A PRINTER CONTROL?
	JRST	TYOH		;YES
	CAIE	CH,ALT		;OR AN ALTMODE?
	JRST	TYOG		;NO, DO NORMAL THING
	MOVEI	CH,16		;ADJUST INDEX FOR ALTMODE
TYOH:	MOVEI	A,5		;5 CHAR. CTR
	MOVE	AA,[POINT 7,TSPTAB-11]	;& PTR TO RIGHT COMBINATION
	ADDI	AA,(CH)
TYOI:	ILDB	CH,AA		;TYPE <CR> OR WHATEVER
	SOJLE	A,TYOB		;LAST CHAR GOES OUT VIA TYOB (TO POP CH)
	PUSHJ	P,TYOA
	JRST	TYOI
TYOJ:	CAIG	CH,15		;NO, TAB, LF, VT, FF, OR CR?
	JRST	TYOB		;YES. TYPE IT AND RETURN
	CAIN	CH,ALT
	MOVEI	CH,"$"		;YES TYPE DOLLAR SIGN
TYOG:	CAIGE	CH,40		;NO. ANY OTHER CONTROL CHARACTER?
	JRST	TYO1		;YES.
TYOC:	PUSH	P,A	;SAVE A
	MOVE	A,TYCASF	;GET CASE FLAGS
	CAMN	A,[EXP -2]	; CHECK -2
	JRST	TYODL	;TYPE LC FLAGGED
	CAIN	A,2	;2 ?
	JRST	TYODM	;TYPE UC FLAGGED
	POP	P,A
	TRNE	F2,LINCHR+TYMSGF	;TTY LC ON? OR TYPING A MESSAGE?
	JRST	TYOB		;YES, NO CASE FLAGGING
	move	a,tycasf
	JUMPL	A,TYOB		;NOTHING
	JUMPG	A,TYOD		;UPPER CASE RANGE
	SKIPA
TYODL:	POP	P,A
	caige	ch,141		;skip if lc
	JRST	TYOB		;NO, SO DON'T FLAG IT
TYOE:	MOVEI	CH,47		;YES, FLAG IT WITH '
	PUSHJ	P,TYOA
	MOVE	CH,(P)		;GET BACK THE CHARACTER
	TRZ	CH,40		;MAKE IT UPPER CASE
TYOB:	PUSHJ	P,TYOA		;TYPE CH.
	POP	P,CH		;RESTORE CH
	CAIN	CH,7		;IF BELL AND ET IS OFF, WE MUST
	TLNE	FF,TYOCTF	;FALL INTO TYOA TO GET A DING
	POPJ	P,		;RETURN
TYOA:	TLO	FF,TYOF		;MARK WILL NEED TO OUTPUT
	SOSG	TOB+2		;OUTPUT SPACE AVAIL?
	OUTPUT	TTY,0		;NO. OUTPUT.
	IDPB	CH,TOB+1
	PUSHJ	P,CHCHK		;UPDATE STUFF
	CAILE	CH,14		;FORCE OUTPUT ON LF,FF ETC
	POPJ	P,		;NO
	OUTPUT	TTY,0
	TLZ	FF,TYOF		;NO LONGER NEED TO OUTPUT
	POPJ	P,

TYO1:	PUSH	P,CH		;TYPE CONTROL CHARACTER IN FORM "^CH"
	MOVEI	CH, "^"
	PUSHJ	P,TYOA		;TYPE ^
	POP	P,CH
	ADDI	CH,100		;CONVERT TO PRINTING CHARACTER
	JRST	TYOB		;AND TYPE IT.

TYODM:	POP	P,A	;POP
TYOD:	CAIL	CH,101		;IS THIS UPPER CASE?
	CAILE	CH,132
	JRST	TYOB		;NO
	JRST	TYOE		;YES, FLAG IT WITH '

IFN CHECKP,<
STRGVF:	SKIPE	INDY
	JRST	STRGPT
	SKIPN	CHKEXE
	JRST	STRGPT
>
IFE CHECKP,<STRGVF:>
STRGPZ:	PUSH	P,CH
	JRST	STRGP2
STRGPT:	PUSH	P,CH	;SAVE REGISTER CH
	SKPINC		;DO THIS TO ZAP ^O'S
	JFCL
STRGP2:
STRGLP:	ILDB	CH,-2(P)	;GET CHAR
	JUMPE	CH,STRGSK	;BR IF NULL
	OUTCHR	CH	;PRINT
	PUSHJ	P,CHCHK	;CHECK IT
	JRST	STRGLP
STRGSK:	MOVE	CH,-1(P)
	MOVEM	CH,-2(P)
	POP	P,CH
	SUB	P,[XWD 1,1]
	POPJ	P,

CHCHK:	CAIN	CH,FFORM	;FORM ?
	JRST	FFCNT
	CAIN	CH,VT	;VT ?
	JRST	VTCNT
	CAIN	CH,LF	;LF ?
	JRST	LFCNT
	POPJ	P,
LFCNT:	PUSH	P,[EXP QLINES]
	JRST	CHINCR
VTCNT:	PUSH	P,[EXP QVTABS]
	JRST	CHINCR
FFCNT:	PUSH	P,[EXP QPAGES]
CHINCR:	PUSH	P,A
	PUSH	P,AA
	MOVE	A,-2(P)	;GET PTR
	MOVE	AA,(A)	;GET VALUE
	CAIG	AA,^D200	;SKIP IF GTR THAT 200
	SKIPGE	AA	;SKIP IF 0 OR POS
	JRST	CHBYE	;BR IF NEITHER
	AOS	(A)	;INCR IT
CHBYE:	POP	P,AA	;REST
	POP	P,A
	SUB	P,[XWD 1,1]	;POP WORD
	POPJ	P,	;RETUN

U TTYBFS,TTBSIZ*2+6			;100 MODE TTY BFRS
		;+ SOME FOR LARGE CCL STRINGS
U TIB,3				;BUFFER HEADER
U TOB,3				;DITTO
U JOBN,1			;JOB #
U USRPPN,1			;USER PROJ-PROG #
U MONITR,1			;MONITOR LEVEL: 0=3,1=4,2=5
U INBUF1,BUFSIZ+3
U CHBF,3
U CHBUF,BUFSIZ+3
U CHSAVB,3+BUFSIZ+3	;SAVE FOR CHBF AND CHBUF
U IBUF,3			;
U OBF,3				;
U IBUF1,2*<BUFSIZ+3>		;
U OBUF1,2*<BUFSIZ+3>		;

;PRINT THESE INSTEAD OF PRINTER CONTROLS IF TYSPCL FLAG IS ON

TSPTAB:	ASCII	/<TAB>/
	ASCII	/<LF>/
	ASCII	/<VT>/
	ASCII	/<FF>/
	ASCII	/<CR>/
	ASCII	/<ALT>/
;MESSAGE TYPE-OUT
;CALL	JSP A,CONMES
;	ASCIZ /MESSAGE/
;	RETURN

CONMES:	HRLI	A,440700	;A=POINT 7,MESSAGE-ADDR
	ILDB	CH,A		;GET MSG CHAR
	JUMPE	CH,1(A)		;RETURN WHEN 0 FOUND
	PUSHJ	P,TYOM		;TYPE WITH NO CASE FLAGGING
	JRST	.-3

;ROUTINE TO OUTPUT DECIMAL (OCTAL IF OCTALF IS ON) INTEGER
;CALL	MOVE B,INTEGER
;	MOVEI A,ADDRESS OF OUTPUT ROUTINE
;	PUSHJ P,DPT
;	RETURN

DPT:	MOVEM	A,LISTF5
	JUMPGE	B,DPT1		;NUMBER > 0?
	MOVEI	CH,"-"		;NO. OUTPUT -
	PUSHJ	P,@LISTF5
	MOVMS	B		;B:=ABSOLUTE VALUE OF B
DPT1:	MOVEI	A,12		;RADIX 10
	TRNE	F2,OCTALF	;OCTAL RADIX?
	MOVEI	A,10		;YES, CHANGE TO RADIX 8
	IDIVI	B,(A)		;E:=DIGIT
	HRLM	E,(P)		;PUT DIGIT ON LEFT HALF OF TOP OF PUSH DOWN LIST
	JUMPE	B,.+2		;DONE?
	PUSHJ	P,.-3		;NO. PUSH THIS DIGIT AND PRINT RETURN ADDRESS.
	HLRZ	CH,(P)		;YES. CH:=DIGIT
	ADDI	CH,60		;CONVERT IT TO ASCII.
	JRST	@LISTF5		;PRINT IT

;ROUTINE TO TYPE CARRIAGE RETURN LINE FEED
;CALL	PUSHJ P,CRR
;	RETURN
CRR:	PUSH	P,A
	JSP	A,CONMES	;OUTPUT CRLF
	ASCIZ	/
/
	POP	P,A
	POPJ	P,
;RETURN NEXT COMMAND CHAR AT CURRENT LEVEL
;CALL:	PUSHJ	P,SKRCH
;	ERROR RETURN IF NO MORE CHARS AT THIS LEVEL
;	NORMAL RETURN WITH CHAR IN CH

SKRCH:	SKIPG	COMCNT		;ANY CHARS LEFT?
	POPJ	P,		;NO, TAKE ERROR RETURN
	PUSHJ	P,RCH		;YES, GET NEXT
CPOPJ1:	AOS	(P)		;SKIP RETURN
	POPJ	P,

;ROUTINE TO RETURN NEXT CHARACTER FROM COMMAND BUFFER.
;CALL	PUSHJ P,RCH
;	RETURN ALWAYS WITH CHARACTER IN CH

RCH:	SOSGE	COMCNT		;DECREMENT COMMAND BUFFER CHARACTER COUNT
				;IS COMMAND BUFFER EMPTY?
	JRST	RCH2		;YES. POP UP TO HIGHER MACRO LEVEL.
	ILDB	CH,CPTR		;NO. GET COMMAND CHARACTER IN CH
	PUSHJ	P,ALTEO		;CONVERT OLD ALTMODES IF EO = 1
	TRNE	FF,TRACEF	;IN TRACE MODE?
	TRNE	F2,NOTRAC	;TRACE ENABLED?
	POPJ	P,		;NO, RETURN
	CAIE	CH,LF		;SKIP IF LF
	CAIN	CH,CR		;OR CR
	POPJ	P,
	JRST	TYOM		;YES, TYPE THE COMMAND

RCH2:	POP	P,CH		;SAVE RETURN FOR POPJ IN CH
	POP	P,COMCNT	;GET RID OF FLAG
;RCH2+2 INSERTED 2 INSTRUCTIONS	[ED#114]
	SKIPE	EQM		;DON'T ALLOW NEG MACRO COUNT
	SOS	EQM		;DECREMENT THE MACRO LEVEL
	PUSH	P,EQM
	POP	P,QMACLV
	SOSG	COMCNT		;IF ANG BRAK ON PDL, ITS A INCOMPLETE MACRO
	ERROR	E.IAB
	POP	P,COMCNT	;GET COUNT FROM NEXT MACRO LEVEL
	POP	P,CPTR		;CURRENT POINTER TOO
	POP	P,COMAX		;NUMBER OF COMMANDS
	PUSH	P,CH		;GET RETURN BACK ON PDL.
	JRST	RCH		;TRY AGAIN.

;GET NEXT CHAR FROM CURRENT COMMAND LEVEL WHERE A CHAR IS
;KNOWN TO BE THERE, AND NO TRACING IS WANTED

GCH:	SOS	COMCNT		;REDUCE CHAR COUNT
	ILDB	CH,CPTR		;GET CHAR.
	JRST	ALTEO		;CONVERT OLD ALTMODES AND RETURN
;SCAN COMMAND STRING FOR CHARACTER IN TT
;IGNORING PAIRS STARTING WITH CHAR. IN TT1 AND ENDING WITH (TT)
;ASSUMED THAT CPTR IS SET
;NON-SKIP RETURN IF (TT) CAN'T BE FOUND
;SKIP RETURN IF FOUND
;CPTR LEFT SET FOR NEXT CHAR. IN COMMAND STRING

SKAN:	TRO	F2,NOTRAC	;INHIBIT TRACE ACTION WHILE SKANNING
	MOVEI	C,0		;CTR FOR <> AND "...' PAIRS
SKAN0:	TRZ	F2,SKIMQF+SKIMRF+SKANFS	;CLR SKIM FLAGS
	PUSHJ	P,SKRCH2	;GET COMMAND CHAR.
	CAIN	CH,(TT1)	;SECONDARY CHARACTER?
	AOJA	C,SKAN1		;YES, COUNT IT
	CAIN	CH,(TT)		;PRIMARY CHAR?
	JRST	SKAN10		;YES!
SKAN1:	CHKEO	EO21,SKAN0	;OLD STYLE SKAN IF EO = 1
	MOVEI	T,SKNTAB	;NO, WATCH OUT FOR TEXT STRINGS
SKAN00:	PUSHJ	P,DISPAT
	JRST	SKAN0		;NOT A TEXT-ARG COMMAND, IGNORE IT
SKAN2:	PUSHJ	P,SKRCH2	;GET CHAR AFTER "^"
	CAIN	CH,"A"
	JRST	SKAN7		;^A COMMAND
	CAIN	CH,"^"
	JRST	SKAN11		;^^ COMMAND
	JRST	SKAN0		;ORDINARY CTRL-COMMAND, FORGET IT
SKAN3:	PUSHJ	P,SKRCH2
	MOVEI	T,SK3TAB	;WHICH E COMMAND?
	JRST	SKAN00
SKAN4:	PUSHJ	P,SKRCH2	;WHAT FOLLOWS @?
	MOVEI	T,SK4TAB
	PUSHJ	P,DISPAT
	JRST	SKAN4		;MUST BE 1 OF THESE 4
SKAN9:	PUSHJ	P,SKIM		;IGNORE TO $
	JRST	SKAN0
SKAN7:	MOVEI	T,1		;IGNORE TO ^A
	JRST	SKAN5
SKAN8:	MOVEI	T,"!"		;IGNORE TO !
SKAN5:	PUSHJ	P,SKIM1		;IGNORE TO CHAR IN T
	JRST	SKAN0
SKAN1B:	TRZ	F2,SKANFS	;F= IS LIKE S NOT FS
	JRST	SKAN12
SKAN1C:	TRZ	F2,SKANFS	;IBID
SKAN6:	PUSHJ	P,SKRCH2	;GET SEARCH DELIMITER
	SKIPA	T,CH		;IGNORE TO NEXT OCCURRENCE
SKAN12:	MOVEI	T,ALT		;DELIMITER IS ALTMODE
	PUSHJ	P,SKIMRQ	;SKIP TO DELIMITER & WATCH OUT FOR ^Q,^R
	JRST	SKAN0
SKAN13:	PUSHJ	P,SKRCH2	;GET INSERT DELIMITER
	SKIPA	T,CH		;IGNORE TO NEXT OCCURRENCE
SKAN14:	MOVEI	T,ALT		;DELIMITER IS ALTMODE
	PUSHJ	P,SKIM.R	;SKIP TO DELIMITER & WATCH OUT FOR ^R
	JRST	SKAN0
SKAN1A:	PUSHJ	P,SKRCH2
	CAIE	CH,"&"	;FUNNY Q ?
	JRST	SKAN0
SKAN11:	PUSHJ	P,SKRCH2	;IGNORE NEXT CHAR.
	JRST	SKAN0
SKAN16:	MOVEI	T,SK5TAB	;TABLE FOR @F
	JRST	SKAN17
SKAN15:	MOVEI	T,SK1TAB	;TABLE FOR F COMMANDS
SKAN17:	TRO	F2,SKANFS	;SIGNAL FS OR FN IN PROGRESS
	PUSHJ	P,SKRCH2	;GET CHAR AFTER F
	JRST	SKAN00
SKAN10:	SOJGE	C,SKAN0		;IF MATCH JUST ENDS A PAIR, LOOP BACK
	TRZ	F2,NOTRAC	;ENABLE TRACING
	JRST	CPOPJ1		;OTHERWISE, WE HAVE WHAT WE WANT

;SKIM OVER TEXT
;ENTER AT SKIM TO SKIP TO NEXT ALTMODE, GIVING ^R & ^Q NO SPECIAL TREATMENT
;ENTER AT SKIM1 TO SKIP OVER ARBITRARY CHAR IN T, GIVING ^R & ^Q NO SPECIAL TREATMENT
;ENTER AT SKIM.R TO SKIP TO ARBITRARY CHAR IN T, UNLESS IT IS AFTER ^R
;ENTER AT SKIMRQ TO SKIP TO ARBITRARY CHAR IN T, UNLESS IT IS AFTER EITHER ^R OR ^Q

SKIMRQ:	TRO	F2,SKIMQF	;CK FOR ^Q AND ^R
SKIM.R:	TROA	F2,SKIMRF	;CK FOR ^R
SKIM:	MOVEI	T,ALT		;SKIP TO NEXT ALTMODE
SKIM1:	PUSHJ	P,SKRCH		;GET NEXT TEXT CHAR.
	JRST	APOPJ		;ERROR RETURN FROM SKAN ROUTINE
	CAIN	CH,(T)		;CHARACTER WE WANT?
	JRST	SKIM3		;YES
	CAIN	CH,21		;^Q?
	TRNN	F2,SKIMQF	;YES, CK FLAG ON?
	JRST	.+2		;NO
	JRST	SKIM2		;YES
	CAIN	CH,22		;^R?
	TRNN	F2,SKIMRF	;YES, CK FLAG ON?
	JRST	SKIM1		;NO, KEEP LOOKING
SKIM2:	PUSHJ	P,SKRCH		;GOBBLE UP NEXT CHARACTER
	JRST	APOPJ		;ERROR RETURN FROM SKAN
	JRST	SKIM1		;CONTINUE SKIMMING
SKIM3:	TRZE	F2,SKANFS	;SKIMMING OVER FS OR FN?
	JRST	SKIM1		;YES, IGNORE 1ST DELIMITER
	POPJ	P,

;GET A SINGLE CHARACTER FROM COMMAND STRING
;TAKE ERROR RETURN FROM SKAN IF THERE ARE NO MORE

SKRCH2:	PUSHJ	P,SKRCH		;GET A COMMAND CHAR.
APOPJ:	POP	P,A		;ERROR RETURN FROM SKAN IF NO MORE CHARS.
	POPJ	P,
;SKAN ROUTINE DISPATCH TABLES

SKNTAB:	XWD	SKAN15,"F"
	XWD	SKAN14,"I"
	XWD	SKAN14,11	;TAB
	XWD	SKAN12,"_"
	XWD	SKAN9,"O"
	XWD	SKAN8,"!"
	XWD	SKAN7,1		;^A
	XWD	SKAN11,36	;^^
	XWD	SKAN2,"^"
	XWD	SKAN3,"E"
	XWD	SKAN1A,"U"
	XWD	SKAN1A,"Q"
	XWD	SKAN1A,"X"
	XWD	SKAN1A,"G"
	XWD	SKAN1A,"M"
	XWD	SKAN1A,"%"
	XWD	SKAN1A,"["
	XWD	SKAN1A,"]"
	XWD	SKAN4,"@"
	XWD	SKAN11,42	;"
	XWD	SKAN12,"S"	;S
	XWD	SKAN12,"N"	;N
	XWD	0,0		;LIST TERMINATOR
SK1TAB:	XWD	SKAN1B,"="
	XWD	SKAN12,"S"	;FS
	XWD	SKAN12,"N"	;FN
	XWD	0,0		;LIST TERMINATOR

SK3TAB:	XWD	SKAN9,"E"	;EE
	XWD	SKAN9,"A"	;EA
	XWD	SKAN9,"F"	;EF
	XWD	SKAN9,"X"	;EX
	XWD	SKAN9,"G"	;EG
	XWD	SKAN9,"C"	;EC
	XWD	SKAN9,"P"	;EP
	XWD	SKAN9,"B"	;EB
	XWD	SKAN9,"R"	;ER
	XWD	SKAN9,"W"	;EW
	XWD	SKAN9,"Z"	;EZ
	XWD	0,0

SK4TAB:	XWD	SKAN16,"F"	;@F
	XWD	SKAN13,"I"	;@I
	XWD	SKAN6,"_"	;@_
	XWD	SKAN6,"S"	;@S
	XWD	SKAN6,"N"	;@N
	XWD	0,0
SK5TAB:	XWD	SKAN1C,"="	;F=
	XWD	SKAN6,"S"	;@FS
	XWD	SKAN6,"N"	;@FN
	XWD	0,0
;MAIN COMMAND READER
CLIS1:	SETOM	STOQM
U STOQM,1
	SKIPN	INTSWR
	PUSHJ	P,CRR		;TYPE CRLF
	SKIPA
CLIS:	SETZM	STOQM
	PUSHJ	P,TTOPEN
	SKIPE	INTSWR
	JRST	LIS01
	SKIPE	SPECSI	;SKIP IF FUNNY COMMAND STRING
			;NOT BEING USED
	JRST	LIS01	;SAME AS CCL ONLY BUFFER ALREADY STUFFED

LIS0:	TRNE	FF,QMFLG	;1ST CHAR IN YET ?
	JRST	LIS01		;YES
	MOVEI	CH,"*"
	SKIPN	INTSWR
	PUSHJ	P,TYOM		;TYPE *
LIS01:	TRON	FF,QMFLG	;UNLESS ONE ALREADY IN
	PUSHJ	P,TYI
	SKIPE	STOQM
	JRST	LIS02A
	CAIE	CH,"*"		;1ST CHAR AN ASTERISK?
	JRST	LIS02		;NO, CONTINUE NORMALLY

;SAVE PREVIOUS COMMAND STRING IN NAMED Q-REGISTER

	TLNE	F2,GOING	;ANY CMD STRG SEEN YET? IF NOT, * IS ILLEGAL
	JRST	LIS03		;OK
	PUSHJ	P,CRR		;MUST PUT CR/LF BEFORE ?NCS
	ERROR	E.NCS
LIS03:	MOVE	C,COMLEN	;LENGTH OF STRING
	ADDI	C,2		;OMIT LAST ALTMODE
	MOVEI	B,@CBUF	;POSITION OF FIRST CHAR. IN BYTES
	AOS	B
	IMULI	B,5
	SETOM	NOMOVY
	PUSHJ	P,X3S		;TRANSFER STRING TO Q-REG
	PUSHJ	P,TYI		;GET Q-REG NAME FOR * COMMAND
	CAIE	CH,"&"	;FUNNY ?
	JRST	LIS03B	;BR IF NOT
	MOVEI	CH,44
	MOVEM	CH,QTCAL
	PUSHJ	P,TYI	;GET NAME
	PUSHJ	P,QREGV5	;STORE 400000 IN QTAB
	SKIPA
LIS03B:	PUSHJ	P,QREGV2
	MOVEM	B,QTAB-"0"(CH)
	TRZ	FF,QMFLG	;NEXT INPUT CHAR NOT IN
	JRST	LIS02A	;BR
LIS02:	SKIPE	FASTEC	;SKIP IF THIS IS NOT FAST
	JRST	LIS02A	;SKIP THIS JAZZ
	TLNN	F2,GOING	;ANY ?
	JRST	LIS02A	;NO
	PUSH	P,CH	;SAVE CH
	MOVE	C,COMLEN	;GET LENGTH
	ADDI	C,2	;VOMIT LAST ALT
	MOVEI	B,@CBUF	;COMMAND BUFFER ADDRESS
	AOS	B
	IMULI	B,5	;
	SETOM	NOMOVY
	PUSHJ	P,X3S	;INTO Q REG
	MOVEM	B,QTAB-"0"+"."	;SAVE POINTER
	SKIPE	NOMCOM	;SKIP IF LAST COMMAND WAS NOT M&A OR M&B
	JRST	LIS02B
	MOVE	CH,QAGAIN	;GET ONE BACK
	MOVEM	CH,QBACKO	;SET
	MOVE	C,COMLEN	;GET LENGTH
	ADDI	C,2	;VOMIT LAST ALT
	MOVEI	B,@CBUF	;COMMAND BUFFER ADDRESS
	AOS	B
	IMULI	B,5	;
	SETOM	NOMOVY
	PUSHJ	P,X3S	;INTO Q REG
	MOVEM	B,QAGAIN	;SAVE IT
LIS02B:	SETZM	NOMCOM	;SET TO ZERO
U NOMCOM,1
	POP	P,CH	;RESTER
LIS02A:	SETZM	COMCNT		;COMCNT:=0
	SETZM	SYMS
	MOVE	T,[XWD SYMS,SYMS+1]
	BLT	T,SYMEND-1
	MOVE	AA,CBUF
	MOVE	B,CBUFH

LI1:	TRZ	FF,ALTF+BELLF+XPLNFL+EMFLAG
LI2:	CAILE	B,(AA)		;COMMAND BUFFER EXCEEDED?
	JRST	LI3		;NO


;TO SEE IF TECO WILL NEED MORE CORE FOR COMMAND 
;BUFFER EXPANSION. IF SO, GET IT

	MOVE	C,Z		;GET THE NUMBER OF CHARACTERS NOW
	ADDI	C,500		;WILL WE OVERFLOW IF THIS IS REQUESTED?
	CAMG	C,MEMSIZ	;WILL THIS OVERFLOW?
	JRST	.+5		;NO, FORGET THIS EVER HAPPENED
	PUSH	P,17		;WILL OVERFLOW, THEREFORE, SAVE AC#17
	MOVE	17,C		;THIS IS THE REQUEST FOR MEMORY
	PUSHJ	P,GRABKQ	;GET THE NECESSARY CORE
	POP	P,17		;RESTORE AC#17
;OK, EXPAND THE COMMAND BUFFER CONFIDENTLY

	ADDI	B,100		;YES. EXPAND COMMAND BUFFER 100 WORDS.
	MOVE	C,Z
	IDIVI	C,5		;C:=DATA BUFFER END WORD ADDRESS.
	MOVE	D,QRBUF
	PUSH	P,F2		;KLUDGE TO PROTECT F2 UNTIL AC'S ARE REORDERED
	IDIVI	D,5		;D:=Q-REG BUFFER BASE WORD ADDRESS.
	POP	P,F2		;RESTORE FLAGS
	SUBM	C,D		;D:=NO. OF WORDS IN Q-REG BUFFER AND DATA BUFFER.
	MOVE	CH,(C)
	MOVEM	CH,100(C)	;MOVE Q-REG AND DATA BUFFERS UP 100 WORDS.
	SOS	C
	SOJGE	D,.-3
	MOVEI	C,500
	ADDM	C,BEG		;BEG:=C(BEG)+500
	ADDM	C,PT		;PT:=C(PT)+500
	ADDM	C,Z		;Z:=C(Z)+500
	ADDM	C,QRBUF		;QRBUF:=C(QRBUF)+500
	MOVE	D,Z
LI3:	MOVEM	B,CBUFH		;NO. RESET HIGH END OF COMMAND BUFFER.
	TRZN	FF,QMFLG	;1ST CHAR IN ALREADY?
	PUSHJ	P,TYI		;GET A NON-NULL CHARACTER IN CH
	CAIN	CH,177		;RUBOUT?
	JRST	RUBOUT		;YES
IFN BACKSP,<
	CAIE	CH,"H"-100	;^H ?
	JRST	LI3A	;NOT
	SKIPG	COMCNT
	JRST	CLIS1
	PUSHJ	P,BACKUP	;BACKUP
	JRST	LI1
>
LI3A:	AOS	A,COMCNT	;NO. INCREMENT COMMAND CHARACTER COUNT
	PUSH	P,A
	MOVE	A,CCSV1
	MOVEM	A,CCSV2
	MOVEM	AA,CCSV1
	POP	P,A
	IDPB	CH,AA		;STORE CHARACTER IN COMMAND BUFFER.
LI4:	CAIE	CH,ALT		;ALT-MODE?
	JRST	LI5		;NO
	TRZN	F2,CTLR		;PREVIOUS CHAR. A ^R?
	JRST	LI7		;NO
	CHKEO	EO21,LI7	;IF EO=1, NEVERMIND ^R
LI9:	TRZ	FF,BELLF	;ALTMODE CLEARS BELL FLAG
	JRST	LI2

LI7:	TRON	FF,ALTF		;YES. SET ALT-MODE FLAG. WAS IT ON?
	JRST	LI9		;NO
	MOVEM	A,COMAX		;SET COMMAND CHARACTER ADDRESS UPPER BOUND
	MOVEM	A,COMLEN	;SAVE IN CASE OF * COMMAND NEXT
	MOVEM	A,QCOUNT	;SAVE COMMAND CHARS AT 0 LEVEL
	MOVE	AA,CBUF		;INIT COMMAND BYTE PTR
	MOVEM	AA,CPTR
	SKIPN	SPECSI	;SPECIAL CSI ?
	JRST	SKP$10	;NOPE
	SKIPN	INTSW2	;STILL INITING ?
	JRST	SKP$11	;NOPE
	JRST	SKP$12
SKP$10:	SKIPE	INTSWR	;STILL HAVE INIT CHARS ?
	JRST	SKP$12	;YES
SKP$11:	SETOM	ARMED	;LET &D DO IT'S THING
SKP$12:	SKIPE	INTSW2
	JRST	LI7.5
	SKIPE	SPECSI
	JRST	LI7.5
	trnn	ff,tracef	;skip if tracing
	PUSHJ	P,CRR		;TYPE CRLF
U ARMED,1
LI7.5:	PUSH	P,A
	TRZ	F2,LINCHR	;CLR TTY LC BIT
	SETO	A,		;GETLCH ON THIS LINE
	TTCALL	6,A
	TLNE	A,20		;TTY LC ON?
	TRO	F2,LINCHR	;YES, SET TTY LC BIT
	HRRZ	TT1,A	;[137] GET UNIV I/O INDEX
;	MOVEI	TT,1026	;[137] GET CODE FOR ALT TEST
;	MOVE	A,[XWD 2,TT]	;[137] SET UP FOR TERMOP
;	TRMOP.	A,	;NOT IMPLEMENTED[140]
	LDB	A,[POINT 1,F2,29]	;[137] IF FAILS USE LC BIT
	SKIPE	A	;[137] SKIP IF SHOULD CONVERT
	TLOA	F2,NOALT
	TLZ	F2,NOALT	;[137] CONVERT
	POP	P,A
	SKIPE	INTSW2
	JRST	LI7.6
	SETZM	SPECSI	;ZAP FUNNY FLAG
	JRST	CD		;DECODE COMMAND
LI7.6:	SKIPN	INTSWR
	SETZM	INTSW2
	JRST	CD
U SPECSI,1
LI5:	CAIN	CH,22		;^R?
	JRST	CNTRLR		;YES
	TRZ	F2,CTLR		;NO, CLR FLAG IN CASE PRECEDING CHAR WAS
	CAIN	CH,25		;^U?
	JRST	CNTRLU		;YES
	CAIN	CH,7		;BELL?
	JRST	LI6		;YES
	TRZN	FF,BELLF	;NO, PREVIOUS CHAR A BELL?
	JRST	LI1		;NO, GET NEXT CHARACTER
	CAIE	CH," "		;YES, IS THIS A SPACE?
	JRST	LI2
RETYPE:	PUSHJ	P,BACKUP	;BACK OFF ^G<SPACE>
	SOS	D,COMCNT	;MARK CURRENT POSITION
	PUSHJ	P,BACKLN	;BACK UP TO BEG OF LINE
	JRST	RETYP3		;HIT BEG OF COMMAND STRING
RETYP1:	SKIPL	COMCNT	;[151]SEE IF ANY COMMANDS
	PUSHJ	P,TYOM		;TYPE A CHAR OF COMMAND LINE
RETYP4:	AOS	C,COMCNT	;ADVANCE COMMAND CTR
	CAIL	C,(D)		;BACK IN PLACE?
	JRST	RETYP2		;YES
	ILDB	CH,AA		;NO, GET NEXT CHAR
	JRST	RETYP1

RETYP2:	CAIN	CH,ALT		;LOOKING AT AN ALTMODE?
	TRO	FF,ALTF		;YES, BETTER SET FLAG
	JRST	LI2

RETYP3:	PUSH	P,CH		;SAVE 1ST CHAR
	PUSHJ	P,CRR		;TYPE CR-LF BEFORE COMMAND LINE
	POP	P,CH		;RETRIEVE 1ST CHARACTER
	JUMPE	CH,RETYP4	;DON'T PRINT ^@ IF NULL COMMAND STRING
	JRST	RETYP1

LI6:	TROE	FF,BELLF	;YES. SET BELL FLAG. TWO SUCCESSIVE BELLS?
	JRST	LI8		;YES, REJECT COMMAND
	TRO	FF,DDTMF	;GET ANOTHER CHAR WITH TTCALL 0
	JRST	LI2

LI8:	SUBI	A,1		;SAVE COMCNT-1 IN CASE * COMMAND FOLLOWS
	MOVEM	A,COMLEN
	TLO	F2,GOING	;SO YOU CAN DO *I AFTER ^G^G
	PUSHJ	P,CRR		;YES. TYPE A CRLF
	JRST	GO		;AND CLEAR COMMAND BUFFER.
;BACK UP BYTE POINTER IN AA, LOAD APPROPRIATE CHARACTER IN CH,
;AND ADJUST COMCNT

BACKUP:	ADD	AA,[7B5]	;BACK UP CHAR PTR
	JUMPG	AA,.+3		;OK NOW?
	SUBI	AA,1		;NO, NEEDS FURTHER FIXING
	HRLI	AA,010700
	LDB	CH,AA		;LOAD CHAR
	SOS	C,COMCNT	;DECREMENT COMMAND COUNT
	POPJ	P,

;BACKUP TO BEGINNING OF CURRENT LINE
;CALL:	PUSHJ	P,BACKLN
;	RETURN IF BACKUP WENT TO BEGINNING OF COMMAND STRING
;	RETURN IF CR-EOL COMBINATION FOUND

BACKLN:	PUSHJ	P,BACKUP	;BACK UP ONE CHAR
	JUMPLE	C,CPOPJ		;RETURN IF NOTHING LEFT
BACKL1:	PUSHJ	P,CKEOL		;IS THIS AN EOL CHAR?
	JRST	BACKLN		;NO, KEEP BACKING UP
	PUSHJ	P,BACKUP	;YES, BACK UP ONE MORE
	CAIE	CH,15		;IS THIS A CR?
	JRST	BACKL1		;NO, MAYBE ANOTHER EOL?
	JRST	CPOPJ1		;YES, TAKE SKIP RETURN

;PROCESS CONTROL-U

CNTRLU:
	PUSHJ	P,TYOM		;ECHO THE ^U
	PUSHJ	P,BACKLN	;BACK UP TO BEG OF LINE
	JUMPLE	C,CLIS1		;IF NOTHING LEFT, RETYPE *
	AOS	COMCNT		;KEEP CRLF
	IBP	AA
	PUSHJ	P,CRR		;CR-LF AFTER ^U
	JRST	LI1		;CONTINUE TYPE-IN

;CONTROL-R IN COMMAND MODE PREVENTS AN ALTMODE AFTER IT
;FROM BEING A TERMINATOR

CNTRLR:	TRZN	F2,CTLR		;^R ON ALREADY?
	TRO	F2,CTLR		;NO, SET FLAG
	JRST	LI1
;PROCESS RUBOUTS


RUBOUT:	SKIPG	COMCNT		;ANYTHING TYPED IN?
	JRST	CLIS1		;NO, RETYPE *
IFN RUBSW,<
	SETO	A,		;GETLCH ON THIS TTY
	TTCALL	6,A		;SET TO SUPPRESS ECHOING
	TLO	A,4
	TTCALL	7,A
	SETOM	NOECHO		;SHUT DOWN CHKGET ECHO TOO
U NOECHO,1
	PUSHJ	P,SPLAT		;ACT LIKE THE MONITOR
	JRST	RUB4
RUB1:	SKIPGE	COMCNT		;PAST BEGINNING OF COMMAND STRING YET?
	JRST	RUB3		;YES
	TRO	FF,DDTMF	;GET IT THE HARD WAY
	PUSHJ	P,TYI		;GET ONE CHARACTER
	CAIE	CH,177		;RUBOUT?
	JRST	RUB2		;NO
RUB4:	>
	LDB	CH,AA		;RELOAD THE CHAR.
	SKIPE	COMCNT		;UNLESS AT BEGINNING OF COMMAND STRING,
	PUSHJ	P,TYOM		;ECHO THE DELETED CHAR.
	PUSHJ	P,BACKUP	;BACK OVER THE CHAR.
IFE RUBSW,<JRST LI1>		;RESUME TYPE-IN
IFN RUBSW,<
	JRST	RUB1		;TRY NEXT INPUT CHAR.
RUB2:	PUSH	P,CH		;SAVE THIS GOOD GUY
	PUSHJ	P,SPLAT		;TYPE THE SECOND \
	POP	P,CH		;GET THAT CHAR. BACK
	CAIE	CH,25		;CTRL-U?
	PUSHJ	P,TYOM		;NO, ECHO IT
	PUSHJ	P,TTCREE	;RESET TTCALL FOR ECHOING
	JRST	LI3A		;PROCESS THIS CHAR.
RUB3:	PUSHJ	P,SPLAT		;SECOND \
	PUSHJ	P,TTCREE	;RESET TTCALL MODE TO NORMAL
	JRST	CLIS1		;START A NEW COMMAND STRING
	>

;TYPE BACKSLASH

IFN RUBSW,<
SPLAT:	MOVEI	CH,"\"
	JRST	TYOM
	>

;RESET TTCALL FOR ECHOING

IFN RUBSW,<
TTCREE:	SETO	A,		;GETLCH ON THIS TTY
	TTCALL	6,A
	TLZ	A,4		;TURN OFF NO ECHO BIT
	TTCALL	7,A
	SETZM	NOECHO
	POPJ	P,
	>
;COMMAND EXECUTION SETCION

CD:
RET:	move	a,cptr	;copy pointer
	ildb	ch,a	;sneek a look
	cain	ch,alt	;altmode ?
	jrst	ccdd	;br if is
	CAIN	CH,CR
	JRST	CCDD
	CAIN	CH,LF
	JRST	CCDD
	CAIN	CH," "
	JRST	CCDD
	trne	ff,tracef
	pushj	p,crr
ccdd:	TRZ	FF,ARG2+ARG+FINDR+PCHFLG+SEQUIN+FSRCH
	TLZ	FF,UEBTMP
	TRZ	F2,OCTALF	;OUT OF OCTAL STATE
	TLO	F2,GOING	;A COMMAND STRING IS IN
CD1:	SETZM	NUM		;NO ARGUMENT STRING SEEN
	SETZM	SYL
	MOVSI	A,(MOVE B,)	;STANDARD ARG OPERATOR IS MOVE B,SYL
CD3:	HLLM	A,DLIM
CD5:	PUSHJ	P,RCH
	CAIN	CH,37		;IS IT A ^_?
	JRST	CD5		;YES, IGNORE IT
CD9:	MOVE	A,CH		;GET COMMAND CHARACTER
	CAIL	CH,"0"		;IS IT A DIGIT?
	CAILE	CH,"9"
	TRZ	F2,OCTALF	;NO, CLEAR OCTAL RADIX FLAG
	CAIE	A,140		;140 IS ILLEGAL
	CAILE	A,172		;ALSO 173-177 ARE ILLEGAL
	MOVEI	A,0
	CAILE	A,137		;REDUCE LOWER CASE TO UPPER
	SUBI	A,40
	MOVE	A,DTB(A)	;GET COMMAND WORD
	TLNN	A,300000	;IS IT A JRST DISPATCH WITH NO ARG PROCESSING?
	JRST	(A)		;YES, DO IT
	MOVE	B,NUM		;NO, TAKE CARE OF ARGUMENTS
	XCT	DLIM		;NUM:=NUM (DLIM OPERATOR) SYL
	MOVEM	B,NUM
	MOVE	C,SARG		;SAVE SECOND ARGUMENT IN C.
	TRZ	FF,SYLF		;CLR DIGIT STRING BIT
	TRZ	F2,CTLV+CTLVV+CTLW+CTLWW+XMATCH+EMATCH+TXTCTL
	TLZ	A,100000	;CLR PUSHJ DISPATCH BIT
	TLZE	A,200000	;JRST OR PUSHJ DISPATCH?
	JRST	(A)
	PUSHJ	P,(A)
	JRST	RET


U DLIM,1			;
U NUM,1				;
U SYL,1				;
U SARG,1			;
;DIGITS FORM DECIMAL INTEGERS.

CDNUM:	TRON	FF,SYLF		;DIGIT STRING ALREADY STARTED?
	SETZM	SYL		;NO, INIT TO ZERO
	MOVEI	A,12		;RADIX 10
	TRNN	F2,OCTALF	;OCTAL FLAG ON?
	JRST	CDNUM1		;NO
	MOVEI	A,10		;YES, RADIX 8
	CAILE	CH,"7"		;FLAG 8 OR 9 IN OCTAL STRING
	ERROR	E.OCT
CDNUM1:	IMUL	A,SYL		;SCALE PREVIOUS VALUE
	ADDI	A,-60(CH)	;ADD IN NEW DIGIT

;SOME COMMANDS HAVE A NUMERIC VALUE
VALRET:	MOVEM	A,SYL
CD7:	TRO	FF,ARG
	JRST	CD5

ALTMOD:	SKIPN	COMCNT		;ANY COMMANDS LEFT?
;ALTMOD+1 REPLACED 1 INSTRUCTION	[ED#114]
	JRST	ALTM2		;NO
	MOVE	T,CPTR		;IF NEXT COMMAND CHARACTER IS ALT-MODE, GO
	ILDB	CH,T
	CAIE	CH,ALT
	JRST	CD
	JRST	altm3

;ALTM1+3 INSERTED 3 INSTRUCTIONS	[ED#114]
ALTM2:	SKIPN	EQM		;WITHIN A MACRO?
	SKIPA
	JRST	CD		;MACRO RETURN
altm3:
ALTM1:	TRNE	FF,TRACEF	;TRACING?
	PUSHJ	P,CRR		;YES, TYPE CR/LF BEFORE *
MACDO2:	SKIPN	ARMED
	JRST	GO
	MOVE	A,QDISPL	;&D
	TLZE	A,400000
	TLZE	A,377770	;SKIP IF TEXT
	JRST	GO
	SETZM	ARMED	;ONE TRY
	PUSH	P,CCSV2
	POP	P,CPTR	;BACK UP
	MOVEI	T,2
	MOVEM	T,COMCNT
	PUSHJ	P,QTXXT
	JRST	MACXX2	;DO IT
;^ MEANS THAT THE NEXT CHARACTER IS A CONTROL CHARACTER.

UAR:	PUSHJ	P,SKRCH		;GET NEXT COMMAND CHARACTER.
	ERROR	E.MEU
	TRZ	CH,140		;CHANGE IT TO CONTROL CHARACTER
	JRST	CD9		;DISPATCH
;IF A COMMAND TAKES TWO NUMERIC ARGUMENTS, COMMA IS USED TO SEPARATE THEM

COMMA:	MOVEM	B,SARG		;SAVE CURRENT ARGUMENT IN SARG.
	TRZE	FF,ARG		;WAS THERE A CURRENT ARGUMENT?
	TROE	FF,ARG2		;YES. WAS THERE ALREADY A SECOND ARGUMENT?
	ERROR	E.ARG
	JRST	CD1		;YES. CLEAR CURRENT ARGUMENT.

;() MAY BE USED TO OVERRIDE LEFT TO RIGHT OPERATOR SCAN FOR +,-,*,/,& AND #.

OPENP:	PUSH	P,NUM		;PUSH CURRENT ARGUMENT.
	PUSH	P,DLIM		;CURRENT OPERATOR
	PUSH	P,[1]		;SET PAREN FLAG ON PDL
	JRST	CD1

CLOSEP:	POP	P,T		;LAST THING ON PDL A LEFT PAREN?
	JUMPL	T,CLOSE1	;SOMETHING LIKE (...<...)
	SOJN	T,CLOSE2	;MISSING (
	MOVEM	B,SYL		;YES. SAVE CURRENT ARGUMENT.
	POP	P,DLIM		;RESTORE OPERATOR
	POP	P,NUM		;RESTORE ARGUMENT.
	JRST	CD7

CLOSE1:	ERROR E.PAR
CLOSE2:	ERROR E.MLP

;^O SETS FLAG FOR OCTAL RADIX INPUT

OCTIN:	TRO	F2,OCTALF
	JRST	CD5		;RETURN WITHOUT MESSING UP ARGUMENTS
;LOGICAL AND

CAND:	MOVSI	A,(AND B,)	;DLIM = AND B,SYL
	JRST	CD3

;LOGICAL OR

COR:	MOVSI	A,(OR B,)	;DLIM = OR B,SYL
	JRST	CD3

;ADD TAKES ONE OR TWO ARGUMENTS

PLUS:	MOVSI	A,(ADD B,)	;DLIM = ADD B,SYL
	JRST 	CD3

;SUBTRACT TAKES ONE OR TWO ARGUMENTS

MINUS:	MOVSI	A,(SUB B,)	;DLIM = SUB B,SYL
	JRST	CD3

;MULTIPLY TAKES TWO ARGUMENTS

TIMES:	MOVSI	A,(IMUL B,)	;DLIM = IMUL B,SYL
	JRST	CD3

;DIVIDE (TRUNCATES) TAKES TWO ARGUMENTS

SLASH:	MOVSI	A,(IDIV B,)	;DLIM = IDIV B,SYL
	JRST	CD3

;RETURNS THE VALUE OF THE FORM FEED FLAG

FFEED:	TRNE	FF,FORM		;IS IT SET?
	JRST	FFOK		;YES, RETURN A -1
				;NO, DO BEGIN ROUTINE
;RETURNS THE NUMERIC VALUE 0.

BEGIN:	MOVEI	A,0
	JRST	VALRET

;^N RETURNS VALUE OF EOF FLAG

EOF:	TLNN	FF,FINF		;EOF SEEN?
	JRST	BEGIN		;NO, RETURN 0
	JRST	FFOK		;YES, RETURN -1

;AN ABBREVIATION FOR B,Z

HOLE:	SETZM	SARG		;SET SECOND ARGUMENT TO 0.
	TRO	FF,SEQUIN	;INITIALIZE AS NEW LINE [ED#122]
	TRNE	FF,ARG2		;FLAG ANY ARGS BEFORE H
	ERROR	E.ARG
	TROA	FF,ARG2

;.=NUMBER OF CHARACTERS TO THE LEFT OF THE POINTER

PNT:	SKIPA	A,PT

;Z=NUMBER OF CHARACTERS IN THE BUFFER

END1:	MOVE	A,Z
	SUB	A,BEG
	JRST	VALRET

;RETURN LENGTH OF LAST TEXT STRING PROCESSED

IFN VC,<
VCMD:	MOVE	A,VVAL		;LENGTH OF LAST TEXT
	JRST	VALRET
	>

;N=	CAUSES THE VALUE OF N TO BE TYPED OUT.

PRNT:	TRNN	FF,ARG		;INSIST ON ARG BEFORE =
	ERROR	E.NAE
	MOVE	A,CPTR		;SNEAK A LOOK AT NEXT COMMAND CHAR.
	ILDB	CH,A
	CAIE	CH,"="		;ANOTHER = SIGN?
	JRST	PRNT9		;NO
	TRO	F2,OCTALF	;YES, THAT MEANS OCTAL RADIX TYPE-OUT
	PUSHJ	P,SKRCH		;SWALLOW THE EXTRA =
	TRZ	F2,OCTALF	;AT END OF MACRO
PRNT9:	PUSHJ	P,PRNT9S	;PRINT NUMBER
	TRZN	FF,COLONF
	JRST	CRR		;CRLF AND RETURN TO CALLER
	POPJ	P,	;RETURN W/NO CRR

;TYPE C(B) IN OCTAL

OCTMS:	TROA	F2,OCTALF	;SET OCTAL RADIX

;TYPE C(B) IN DECIMAL

DECMS:	TRZ	F2,OCTALF	;DECIMAL RADIX
PRNT9S:	MOVEI	A,TYO		;OUTPUT ON TTY
	PUSHJ	P,DPT		;TYPE NUMBER
	TRZ	F2,OCTALF	;CLR RADIX FLAG
	POPJ	P,



;CAUSES COMMAND INTERPRETATION TO STOP UNTIL THE USER TYPES A CHARACTER
;ON THE TELETYPE AND THEN HAS THE ASCII VALUE OF THE CHARACTER TYPED IN.


SPTYO:	TLZE	FF,TYOF
	OUTPUT	TTY,	;OUPUT IF NEC
	IONEOU	B	;IMAGE OUT THE CHARACTER
	JRST	RET
SPTYI:	TRO	FF,DDTMF
	PUSHJ	P,TYI		;GET A SINGLE CHAR.
	SKIPA	A,CH


;HAS THE VALUE OF ELAPSED TIME, IN 60THS OF A SECOND, SINCE MIDNITE.

GTIME:	CALLI	A,TIMER
	JRST	VALRET


;HAS THE VALUE OF THE CONSOLE DATA SWITCHES.

LAT:	CALLI	A,SWITCH
	JRST	VALRET

;HAS THE VALUE OF THE NEXT CHARACTER IN THE COMMAND STRING.

CNTRUP:	PUSHJ	P,SKRCH		;^^ HAS VALUE OF CHAR FOLLOWING IT
	ERROR	E.MUU
	MOVE	A,CH
	JRST	VALRET

;W COMMAND PROCESSOR

CHARGT:	TRNE	FF,ARG	;ARGUMENT ?
	JRST	SLEEPR	;BR IF ONE
	SKIPN	EQM	;SKIP IF IN A MACRO
	ERROR	E.NIM
	SETOM	WCOUNT	;SET BACK A LEVEL
U	WCOUNT,1
CHKDN:	MOVEI	A,(P)	;GET PDL POINTER
CHKAGN:	MOVE	CH,(A)	;GET FLAG
	SKIPN	CH	;SKIP IF NOT BOTTOM
	ERROR	E.TML
	SOSLE	CH	;SKIP IF ( OR <
	JRST	GOTIT	;BR IF A MACRO
CHKDEC:	SUBI	A,3	;POP FOR ()
	SKIPE	CH	;SKIP IF (
	SUBI	A,2	;FOR <>
	JRST	CHKAGN	;TRY NEXT LEVEL
GOTIT:	AOSL	WCOUNT
	JRST	GOTIT4
	SUBI	A,4
	JRST	CHKAGN
GOTIT4:	SOSGE	-1(A)	;DECR COUNT
	ERROR	E.WOV
	ILDB	CH,-2(A)	;GET BYTE
GOTIT2:	PUSHJ	P,ALTEO	;COONVERT ALTS
	TRNN	FF,TRACEF
	JRST	TABCL
	PUSH	P,CH	;SAVE CHARACTER
	MOVEI	CH,"?"	;GET FLAG
	PUSHJ	P,TYO	;PRINT FOR TRACE
	POP	P,CH	;GET BACK CHAR
	PUSHJ	P,TYO	;PRINT FOR TRACE
TABCL:	PUSH	P,[EXP TABRET]	;SET RETURN
	MOVE	A,PT	;GET PTR
	SUB	A,BEG		;GET OFFSET
	MOVEM	A,PTSAVE	;SAVE IT
	JRST	TAB2
SLEEPR:	SKIPG	B	;SKIP IF ARG IS POS
	JRST	WAITTY	;BR IF NOT
	IDIVI	B,^D1000	;TO SECONDS
	HRRZ	A,NUM	;GET ARG
	HIBER	A,	;HIBERNATE
	SLEEP	B,	;SLEEP INSTEAD
	JRST	RET	;RETURN
WAITTY:	MOVE	A,JOBN	;GET HIS JOB NUMBER
	TRMNO.	A,	;GET CONSOLE NUMBER
	ERROR	E.NTN
	MOVEM	A,UNIV+1	;SAVE IT
U UNIV,2
	MOVEI	A,1	;GET INPUT FUNCTION CODE
	SKIPN	NUM	;SKIP IF NEG
	MOVEI	A,2	;GET OUTPUT FUNC
	MOVEM	A,UNIV	;SET
	MOVE	B,[XWD 2,UNIV]	;GET CODES
	SETZM	A	;SET FAIL RET VALUE
	TRMOP.	B,
	SETOM	A	;SET SUCCESS (EMPTY)
	JRST	VALRET


;FW COMMAND

SPWCM:	SETZM	WCOUNT	;ZERO LEVEL
	TRNE	FF,ARG	;SKIP IF NO ARG
	MOVEM	B,WCOUNT	;SET IT
	SKIPE	WCOUNT	;SKIP IF THIS LEVEL
	JRST	CHKLPT
	PUSHJ	P,SKRCH
	ERROR	E.WOV
	JRST	GOTIT2
CHKLPT:	SKIPG	WCOUNT
	JRST	CHKDN	;LOOK DOWN
	ERROR	E.PLS
;HAS THE VALUE OF THE NUMBER REPRESENTED BY THE DIGITS (OR MINUS SIGN)
;FOLLOWING THE POINTER IN THE BUFFER.  THE SCAN TERMINATES ON ANY OTHER
;CHARACTER.  THE POINTER IS MOVED OVER THE NUMBER FOUND (IF ANY).

BAKSL:	TRZE	FF,ARG		;WHICH KIND OF BACKSLASH?
	JRST	BAKSL1		;ARG TO MEMORY
	MOVE	I,PT		;MEMORY TO VALRET
	CAML	I,Z		;CAN WE READ ANOTHER?
	JRST	BAKSL3		;NO
	PUSHJ	P,GETINC	;CK FOR +,- SIGN
	CAIN	CH,"+"
	JRST	BAKSLA		;IGNORE +
	CAIE	CH,"-"
	JRST	BAKSL0		;NO SIGN
	TRO	FF,ARG		;NEGATION FLAG
BAKSLA:	CAML	I,Z		;OVERDID IT ?
	JRST	BAKSL3		;YES. EXIT
	PUSHJ	P,GETINC	;NO. GET A CHAR
BAKSL0:	CAIG	CH,"9"		;DIGIT?
	CAIGE	CH,"0"		;DIGIT?
	SOJA	I,BAKSL2	;NOT A DIGIT. BACKUP AND LEAVE LOOP
	SUBI	CH,"0"		;CONVERT TO NUMBER
	EXCH	CH,SYL
	IMULI	CH,12
	ADDM	CH,SYL		;SYL:= 10.*SYL+CH
	JRST	BAKSLA		;LOOP

BAKSL3:	MOVE	I,Z		;HERE ON OVERFLOW
BAKSL2:	TRZE	FF,ARG		;MINUS SIGN SEEN?
	MOVNS	SYL		;YES. NEGATE
	MOVEM	I,PT		;MOVE POINTER PAST #
	JRST	CD7		;DONE


;NA (WHERE N IS A NUMERIC ARGUMENT) = VALUE IN 7-BIT ASCII OF THE
;CHARACTER TO THE RIGHT OF THE POINTER.

ACMD:	TRNN	FF,ARG		;DOES AN ARGUMENT PRECEED A?
	JRST	APPEND		;NO. THIS IN AN APPEND COMMAND.
	MOVE	A,Z		;IF POINTER IS AT END OF
	SUB	A,PT		; BUFFER OR IF BUFFER EMPTY,
	JUMPE	A,VALRET	; MUST GIVE 1A=0
	MOVE	I,PT		;YES.
	PUSHJ	P,GET		;CH:=CHARACTER TO THE RIGHT OF PT.
	MOVE	A,CH		;RETURN CH AS VALUE.
	JRST	VALRET
;NUI	PUTS THE NUMERIC VALUE N IN Q-REGISTER I.

USE:	TRNN	FF,ARG		;INSIST ON ARG BEFORE U
	ERROR	E.NAU
USEA:	PUSHJ	P,QREGVI	;YES. CH:=Q-REGISTER INDEX.
	MOVEM	B,QTAB-"0"(CH)	;STORE ARGUMENT IN SELECTED Q-REG.
	JRST	RET

;QI	HAS THE VALUE OF THE LATEST QUANTITY PUT INTO Q-REGISTER I.

;QREG REPLACED 1 INSTR [135]
QREG:	PUSHJ	P,QTXTST	;[135]GET Q-REGISTER INDEX AND CHECK FOR TEXT
	MOVE	A,QTAB-"0"(CH)	;A:=CONTENTS OF Q-REGISTER.
	JRST	VALRET

;ROUTINE TO RETURN Q-REGISTER INDEX IN CH AND CONTENT IN A.

QREGVI:	PUSHJ	P,SKRCH		;CH:=NEXT COMMAND STRING CHARACTER.
	ERROR	E.MIQ
	CAIE	CH,"&"	;SPECIAL ?
	JRST	QREGV2	;BR
	MOVEI	CH,44	;GET OFFSET
	MOVEM	CH,QTCAL	;SAVE IT
	PUSHJ	P,SKRCH
	ERROR	E.MIQ
	SKIPA
QREGV2:	SETZM	QTCAL
QREGV5:	CAIL	CH,140		;LC LETTER?
	TRZ	CH,40		;MAKE UC
	CAIGE	CH,"*"	;SPECIAL ?
	ERROR	E.IQN
	SKIPN	QTCAL
	JRST	QREGV3
	CAIGE	CH,"0"		;DIGIT ?
	ERROR	E.IQN
QREGV3:	CAIGE	CH,"0"		;DIGIT?
	JRST	QREGV4
	CAIG	CH,"9"
	JRST	QREGV4
	CAIL	CH,"A"		;LETTER?
	CAILE	CH,"Z"
	ERROR	E.IQN
	SUBI	CH,"A"-"9"-1	;TRANSLATE LETTERS DOWN BY NUMBER OF
QREGV4:	ADD	CH,QTCAL
	POPJ	P,		;CHARACTERS BETWEEN 9 AND A. ONLY 36 Q-REG'S
U	QTCAL,1


;%I	ADDS 1 TO THE QUANTITY IN Q-REGISTER I AND STANDS FOR THE
;	NEW VALUE

PCNT:	PUSHJ	P,QTXTST	;[135] GET Q-REG & CHECK FOR TEXT
	AOS	A,QTAB-"0"(CH)	;INCREMENT THE Q-REG
	JRST	VALRET		;RETURN NEW VALUE.
;AFTER PCNT ROUTINE ADDED NEW ROUTINE [135] 
QTXTST:	PUSHJ	P,QREGVI	;[135] GET Q-REG INDEX
	MOVE	A,QTAB-"0"(CH)	;[135] GET Q-REG CONTENTS
	TLZE	A,400000	;[135] DOES IT CONTAIN TEXT?
	TLZE	A,377770	;[135]
	POPJ	P,		;[135] NO,RETURN
	ERROR	E.NNQ
;M,NXI	COPIES A PORTION OF THE BUFFER INTO Q-REGISTER I.
;	IT SETS Q-REGISTER I TO A DUPLICATE OF THE (M+1)TH
;	THROUGH NTH CHARACTERS IN THE BUFFER.  THE BUFFER IS UNCHANGED.
;NXI	INTO Q-REGISTER I IS COPIED THE STRING OF CHARACTERS STARTING
;	IMMEDIATELY TO THE RIGHT OF THE POINTER AND PROCEEDING THROUGH
;	THE NTH LINE FEED.

X:
IFN VC,<SETZM	VVAL>		;CLR STRING LENGTH HOLD
	PUSHJ	P,GETARG	;C:=FIRST STRING ARGUMENT ADDRESS
				;B:=SECOND STRING ARGUMENT ADDRESS.
	PUSHJ	P,CHK1		;IS SECOND ARG. ADDR. > FIRST ARG. ADDR.?
	EXCH	B,C		;YES.
	PUSH	P,[-3]		;[CJJ-26] CAN'T USE HALF WORDS
	ADDM	B,(P)	;[CJJ-26] CAN'T USE HALF WORDS
	SUB	C,(P)	;[CJJ-26] CAN'T USE HALF WORDS
	MOVEI	A,-3	;[CJJ-26] CAN'T USE HALF WORDS
	ADD	A,C	;[CJJ-26] CAN'T USE HALF WORDS
	SUB	P,[1000001]	;[CJJ-26] CAN'T USE HALF WORDS
IFN VC,<MOVEM	A,VVAL>
	ADD	B,C		;B:=FIRST ARG ADDR + LENGTH OF STRING + 3
	PUSHJ	P,X3		;MOVE DATA TO Q-REG BUFR
	JRST	USEA		;NO, MAKE QTAB ENTRY NORMALLY.

;TRANSFER DATA TO Q-REGISTER BUFR

U	XSGETC,1
X3S:	SETOM	XSGETC	;SET FOR SILENT ENTRY
X3:	PUSH	P,PT
	ADDM	C,(P)		;(P):=PT + LENGTH OF STRING + 3.
	MOVE	D,BEG
	MOVEM	D,PT		;PT:=BEG
	PUSHJ	P,NROOM		;INSERT STRING AT BEG
	MOVE	OU,RREL		;RREL CONTAINS RELOCATION CONSTANT IF
				;GARBAGE COL. OCCURRED.
	ADDM	OU,(P)		;RELOCATE TOP OF STRING POINTER.
U NOMOVY,1
	SKIPN	NOMOVY	;SKIP B REL IF IS A FIXED STRING
	ADD	B,OU		;B:=FIRST ARG ADDR + LENGTH OF STRING + 3 + RREL
	SETZM	NOMOVY
	MOVE	OU,BEG		;OU:=ADDRESS OF Q-REG BUFFER
	ADDM	C,BEG		;BEG:=C(BEG)+LENGTH OF STRING + 3
	MOVE	CH,C		;FIRST CHAR OF BUFFER :=LEAST SIGNIFICANT 7 BITS
	PUSHJ	P,PUT		;OF LENGTH OF STRING + 3
	AOS	OU		;SECOND CHAR = MIDDLE 7 BITS OF LENGTH
	ROT	CH,-7
	PUSHJ	P,PUT
	ROT	CH,-7
	MOVE	I,B		;THIRD CHAR OF BUFFER := MOST SIGNIFICANT 7 BITS
				;OF LENGTH OF STRING + 3
	AOS	OU
X1:	PUSHJ	P,PUT		;MOVE STRING TO Q-REG BUFFER.
	AOS	OU
	CAIN	C,3
	JRST	X2
	PUSHJ	P,GETINC
	SOJA	C,X1
X2:	MOVE	B,PT		;QTAB ENTRY :=XWD 400000,Q-REG BUFFER
				;ADDRESS RELATIVE TO C(QRBUF)
	SUB	B,QRBUF
	TLO	B,400000
	POP	P,PT		;MOVE PT PAST STRING.
	SETZM	XSGETC	;ZAP IT
	POPJ	P,
;GI	THE TEXT IN Q-REGISTER I IS INSERTED INTO THE BUFFER AT THE
;	CURRENT LOCATION OF THE POINTER.  THE POINTER IS THEN PUT JUST
;	TO THE RIGHT OF THE INSERTION.  THE Q-REGISTER IS NOT CHANGED.

QGET:
IFN VC,<SETZM	VVAL>		;CLR STRING LENGTH HOLD
	PUSHJ	P,QTEXT		;INIT Q-REG ACCESS
	MOVE	B,CH		;SAVE INDEX
	PUSHJ	P,GTQCNT	;C:=LENGTH OF STRING
	PUSHJ	P,NROOMC	;MOVE FROM PT THROUGH Z UP C POSITIONS
	MOVE	OU,PT
	HRRZ	I,QTAB-"0"(B)
	ADD	I,QRBUF
	ADDI	I,3
QGET1:	JUMPE	C,RET		;MOVE STRING INTO DATA BUFFER
	PUSHJ	P,GETINC
	PUSHJ	P,PUT
	AOS	OU,PT
	SOJA	C,QGET1

;GET 21 BIT Q-REGISTER CHARACTER COUNT

GTQCNT:	PUSHJ	P,GETINC	;LOW ORDER 7 BITS
	MOVEM	CH,C
	PUSHJ	P,GETINC	;MIDDLE 7 BITS
	ROT	CH,7
	IORM	CH,C
	PUSHJ	P,GETINC	;HIGH 7 BITS
	ROT	CH,^D14
	IORM	CH,C
	SUBI	C,3		;LESS 3 WORDS USED TO STORE THIS COUNT
	POPJ	P,

;INITIALIZE ACCESS OF TEXT FROM A Q-REGISTER

QTEXT:	PUSHJ	P,QREGVI	;A=QTAB ENTRY, CH=Q-REG INDEX
	MOVE	A,QTAB-"0"(CH)
	TLZE	A,400000	;MAKE SURE IT CONTAINS TEXT
	TLZE	A,377770
	ERROR	E.NTQ
QTXXT:	ADD	A,QRBUF
	MOVE	I,A		;I=Q-REG BUFFER ADDRESS
	POPJ	P,
;MI	PERFORM NOW THE TEXT IN Q-REGISTER I AS A SERIES OF COMMANDS.

MAC:	TRNN	FF,ARG2	;2ND ARD ?
	JRST	MACX1	;BR IF NOT
	MOVEM	C,QTAB-"0"+"*"	;SAVE AWAY
MACX1:	TRNN	FF,ARG	;1ST ARG ?
	JRST	MACX2	;NO
	MOVEM	B,QTAB-"0"+"+"	;SAVE
MACX2:	PUSHJ	P,QTEXT		;INIT Q-REG ACCESS
	CAIN	CH,QAGAIN-QTAB+"0"	;&A ?
	SETOM	NOMCOM	;DIABLE &A SAVING
	CAIN	CH,QBACKO-QTAB+"0"	;&B ?
	SETOM	NOMCOM	;DIABLE &A SAVING
	SKIPA
MACXX2:	TRZ	FF,ARG2!ARG		;NO ARGS
	PUSH	P,COMAX		;SAVE CURRENT COMMAND STATE
	PUSH	P,CPTR
	PUSH	P,COMCNT
	PUSH	P,.		;FLAG MACRO ON PDL (LARGE POS. NO.)
	PUSHJ	P,GTQCNT	;GET NUMBER OF CHARACTERS IN MACRO
	MOVEM	C,COMCNT	;THAT MANY COMMANDS TO COUNT
	MOVEM	C,COMAX		;AND MAX.
	SUBI	I,1		;ADJUST TO SUIT BTAB
	IDIVI	I,5
	MOVE	OU,BTAB(OU)	;MAKE A BYTE POINTER
	HRR	OU,I
	MOVEM	OU,CPTR		;PUT IT IN CPTR
;MAC+15 INSERTED 1 INSTRUCTION	[ED#114]
	AOS	EQM		;INCREMENT THE MACRO LEVEL
	PUSH	P,EQM	;GET LEVEL
	POP	P,QMACLV	;SAVE IT
	JRST	CD5		;DON'T FLUSH ANY ARGUMENTS


;]I	POPS Q-REGISTER I OFF THE Q-REGISTER PUSHDOWN LIST.
;	THE Q-REGISTER PUSHDOWN LIST IS CLEARED EACH TIME $$ IS TYPED.

CLOSEB:	SKIPA	C,[POP PF,]

;[I	PUSHES Q-REGISTER I ONTO THE Q-REGISTER PUSHDOWN LIST.

OPENB:	MOVSI	C,261000+PF*40
	PUSHJ	P,QREGVI
	HRRI	C,QTAB-"0"(CH)	;C:=Q-REGISTER INDEX.
	XCT	C		;PUSH OR POP Q-REGISTER.
	JRST	RET
;E COMMANDS SELECT AND CONTROL FILE INPUT-OUTPUT MEDIA

ECMD:	PUSHJ	P,SKRCH		;GET CHAR AFTER E
	ERROR	E.MEE
	MOVEI	T,ECTABL	;INDEX DISPATCH TABLE
	PUSHJ	P,DISPAT
	ERROR	E.IEC

;E-COMMAND DISPATCH TABLE

ECTABL:	XWD	SEQSET,"Q"
	XWD	BACKMD,"V"
	XWD	ECHNGE,"C"
	XWD	NOERST,"N"
	XWD	TECLNO,"L"
	XWD	TECOC3,"E"
	XWD	JAKEPG,"P"
	XWD	JAKESB,"A"
	XWD	TECOCR,"D"
	XWD	TYOCTL,"T"
	XWD	OPNRX,"R"
	XWD	OPNWR,"W"
	XWD	CLOSEF,"F"
	XWD	ZERDIR,"Z"
	XWD	EMTAPE,"M"
	XWD	EBAKUP,"B"
	XWD	FINISH,"X"
IFN CCL,<XWD	CCLFIN,"G">
	XWD	OLDMOD,"O"
	XWD	TYCASE,"U"
	XWD	ERRSET,"H"
	XWD	AUTOTY,"S"
	XWD	0,0		;MARKS END OF LIST

U FILPPN,1	;FILE PROJ-PROG AREA
;***** KEEP FILDEV, FILNAM, & SWITC TOGETHER & IN THIS ORDER *****
U FILDEV,1	;FILSPC+1(0),FILSP1+1	
U FILNAM,4	;NAME IN SIXBIT.  FILSPC+2(0),FILLS1+5
		;(EXT)BLK #.  FILSPC+3(0),FILLS1+2
		;PROT,DATE.  FILSPC+4(0)
		;(PROJ)PROG.  FILSPC+5(0),FILSPS,FILSP6
U SWITC,1	;SWITCH BIT STORE (EACH BIT IS 1 SWITCH)
;*****************************************************************
U BAKNAM,2	;FOR THE BACKUP NAME
;RETURN TO START
;
TECOC3:	PUSHJ	P,FINIS1
	RELEAS	TTY,
	RELEAS	INCHN,
	RELEAS	OUTCHN,
	TLZ	FF,UREAD+UWRITE
TECOCR:	TLNE	FF,UWRITE
	JRST	TECVRF
TECOC2:	JRST	TECO
TECVRF:	PUSH	P,[POINT 7,[ASCIZ /Files open, are you sure?("Y" or "N"):/]]
	PUSHJ	P,STRGVF
	PUSHJ	P,TYIVF	;GET REP
	PUSH	P,[POINT 7,[ASCIZ /
/]]
	PUSHJ	P,STRGVF
	PUSHJ	P,UCCVT
	CAIN	CH,"Y"
	JRST	TECO
	JRST	GO

;MISCELLANEOUS CHARACTER DISPATCHER
;CALL:	MOVE	CH,CHARCATER
;	MOVEI	T,TABLE ADDR
;	PUSHJ	P,DISPAT
;	NOT FOUND RETURN
;ENTER AT DISP1 TO AVOID CONVERTING LC TO UC

DISPAT:	CAIG	CH,172		;CONVERT LC TO UC
	CAIG	CH,137
	JRST	DISP1
	TRZ	CH,40
DISP1:	PUSH	P,A		;SAVE AC A WHILE WE USE IT
DISP2:	MOVE	A,(T)		;GET TABLE ENTRY
	TRNN	A,777777	;ANYTHING LEFT?
	JRST	APOPJ		;NO -- RESTORE AC A & RETURN
	SUBI	A,(CH)		;COMPARE
	MOVSS	A
	TLNE	A,777777
	AOJA	T,DISP2		;NOT A MATCH
	MOVEM	A,-1(P)		;GOT IT -- PUT DISPATCH ADDR ON PDL
	JRST	APOPJ		;RESTORE AC A & DISPATCH
;EX -- FINISH OUTPUT AND RETURN TO THE TIME-SHARING EXEC.

FINIS1:	SETSTS	TTY,0		;RETURN TO NORMAL TTY MODE
	OUTPUT	TTY,0		;DUMMY OUTPUT TO LET SCNSER IN ON THE NEW MODE
	TRO	FF,PCHFLG	;NO FREE FORM FEEDS
	MOVSI	E,1		;A LARGE NUMBER OF PAGES
	PUSHJ	P,PUN1		;PUNCH THOSE PAGES
	JRST	CLOSEF		;CLOSE AND RENAME FILES

JAKEPG:	PUSHJ	P,FINIS1	;FINISH UP
	RELEAS	INCHN,0
	RELEAS	OUTCHN,0
	TLZ	FF,UREAD+UWRITE+FINF+UBAK	;IN CASE OF A CONTINUE
	POPJ	P,	;RETURN

FINISH:	PUSHJ	P,FINIS1	;FINISH UP.

;^Z -- RETURN TO THE MONITOR (SAME AS THE OLD ^G)

DECDMP:	RELEAS	TTY,0
	RELEAS	INCHN,0
	RELEAS	OUTCHN,0
	TLZ	FF,UREAD+UWRITE+FINF+UBAK	;IN CASE OF A CONTINUE
IFN CHECKP,<
	SKIPE	INDY
	JRST	INDYS1	;SKIP IF IS AN INDIRECT FILE
>
	SKIPE	CHKEXE
	JRST	CONTNO
IFN CHECKP,<
	SKIPA
INDYS1:	RELEAS	CHPCHN,
	SETZM	INDY
	SETZM	CHKEXE
>
	CALLI	1,EXIT
	PUSHJ	P,TTOPN1
	JRST	GO
CONTNO:	PUSHJ	P,TTOPN1
	PUSH	P,[POINT 7,[ASCIZ /[Continuing]
/]]
	PUSHJ	P,STRGPT
	JRST	GO		;IF HE CONTINUES

IFN CCL,<
CCLFIN:	PUSHJ	P,FINIS1	;FINISH FILE IO
	PUSH	P,[POINT 7,[ASCIZ /[rpg]
/]]
	PUSHJ	P,STRGPT
IFN NORUNS,<
	SKIPGE	MONITR		;CHECK FOR 4 SERIES MONITOR
	JRST	NORUN		;3 SERIES - SIMULATE RUN UUO
	>
	MOVEI	A,CCLBLK	;RUN rpg
	HRLI	A,1		;AT START ADR PLUS ONE
	CALLI	A,35		;RUN UUO
	JRST	DECDMP		;JUST EXIT IF NO RUN.

CCLBLK:	SIXBIT	/SYS/
	SIXBIT	/RPG   /	;RUN SYS:RPG
	REPEAT	4,<0>
	>
IFN NORUNS,<
IFN CCL,<
NORUN:	MOVE	1,[SIXBIT /COMPIL/]
	MOVSI	2,SAVEXT	;SIXBIT FOR SAV OR DMP
	SETZB	3,4
	INIT	CCLCHN,17
	SIXBIT	/SYS/
	0
	CALLI	12
	LOOKUP	CCLCHN,1
	CALLI	12
	CALL	1,[SIXBIT /SETNAM/]
	HLRO	15,4
	HRLM	15,NORUN1
	MOVNS	15
	MOVEI	16,73(15)
	ADDI	15,INHERE
	TRO	15,1777
	MOVSI	NORTOP,NORAC
	BLT	NORTOP,NORTOP
	HRR	NORBLT,16
	JRST	NORUN2
	>>
;ET COMMAND

TYOCTL:	POP	P,CH		;CLR RET. ADDR. FROM PDL
	TRNE	FF,ARG		;ARGUMENT?
	JRST	TYOCT1		;YES.
	TLNE	FF,TYOCTF	;NO, FLAG ON?
	JRST	FFOK		;YES, RETURN -1
	JRST	BEGIN		;NO, RETURN 0

TYOCT1:	TLZ	FF,TYOCTF	;CLEAR ET FLAG
	JUMPE	B,RET		;ARGUMENT NON-ZERO?
	TLO	FF,TYOCTF	;YES. SET ET FLAG
	JRST	RET		;RETURN

;EO COMMAND

OLDMOD:	POP	P,CH		;CLR RET. ADDR. FROM PDL
	TRNE	FF,ARG		;ARGUMENT?
	JRST	OLD1		;YES, SET FLAG
	MOVE	A,EOFLAG	;NO, RETURN VALUE OF EOFLAG
	JRST	VALRET

OLD1:	CAIG	B,0		;N <= 0?
	MOVEI	B,EOVAL		;YES, SET TO STANDARD
	CAILE	B,EOVAL		;N > STANDARD FOR THIS VERSION?
	ERROR	E.EOA
	MOVEM	B,EOFLAG	;SET EOFLAG
	JRST	RET		

U EOFLAG,1			;EDIT OLD FLAG

;EU COMMAND

TYCASE:	POP	P,CH		;CLR RET. ADDR. FROM PDL
	TRNE	FF,ARG		;ARGUMENT?
	JRST	TYCAS1		;YES
	MOVE	A,TYCASF	;NO, RETURN VALUE OF TYPE-OUT CASE FLAG
	JRST	VALRET

TYCAS1:	MOVEM	B,TYCASF	;SET TYPE-OUT CASE FLAG
	JRST	RET

U TYCASF,1			;TYPE-OUT CASE FLAG: 0 = TYPE ' BEFORE LC
				;+ = TYPE ' BEFORE UC; - = DON'T TYPE FLAGS
;ES COMMAND

AUTOTY:	POP	P,CH		;CLR RET ADDR FROM PDL
	TRNE	FF,ARG		;ARG?
	JRST	AUTOT1		;YES
	MOVE	A,AUTOF		;NO, RETURN VALUE OF FLAG
	JRST	VALRET

AUTOT1:	MOVEI	A,12		;USE LF FOR FLAG IF ARG = 1 TO 37
	CAIL	B,1
	CAILE	B,37
	MOVE	A,B		;OTHERWISE USE WHAT HE GAVE
	MOVEM	A,AUTOF		;SET NEW VALUE IN FLAG
	JRST	RET

U AUTOF,1			;NON-ZERO IMPLIES AUTOTYPE AFTER SEARCHES
				;POSITIVE IMPLIES TYPE AUTOF AS A PTR MARKER


TECLNO:	POP	P,CH
	TRNE	FF,ARG
	JRST	TECLN1
	MOVE	A,TECLNI
	JRST	VALRET
TECLN1:	MOVEM	B,TECLNI
	JRST	RET

U	TECLNI,1
;EV COMMAND
BACKMD:	POP	P,CH
	TRNE	FF,ARG
	JRST	BACK01
	MOVE	A,BACKWS
	JRST	VALRET
BACK01:	MOVEM	B,BACKWS
	JRST	RET
U	BACKWS,1
;EQ COMMAND
SEQSET:	POP	P,CH
	TRNE	FF,ARG
	JRST	SEQLN1
	MOVE	A,SEQLNI
	JRST	VALRET
SEQLN1:	MOVEM	B,SEQLNI
	JRST	RET
U	SEQLNI,1
;^V COMMAND

LOWCAS:	TRNE	FF,ARG		;ARG SEEN?
	JUMPE	B,CLRCAS	;YES, IF 0 CLEAR ALL PREVAILING CASE FLAGS
	TRZ	F2,UCASE	;CLEAR ^W FLAG
	TRO	F2,LCASE	;& SET ^V FLAG
	JRST	RET

;^W COMMAND

STDCAS:	TRNE	FF,ARG		;ARG SEEN?
	JUMPE	B,CLRCAS	;YES, IF 0 CLEAR ALL PREVAILING CASE FLAGS
	TRZ	F2,LCASE	;CLEAR ^V FLAG
	TROA	F2,UCASE	;& SET ^W FLAG

CLRCAS:	TRZ	F2,LCASE+UCASE	;0^V OR 0^W CLEARS BOTH FLAGS
	JRST	RET

;^X COMMAND

SETMCH:	TRNE	FF,ARG		;ANY ARGUMENT?
	JRST	SETMC1		;YES
	TLNE	FF,PMATCH	;NO, FORCED EXACT MATCH FLAG ON?
	JRST	FFOK		;YES, RETURN -1
	JRST	BEGIN		;NO, RETURN 0

SETMC1:	TLZ	FF,PMATCH	;CLR ^X FLAG
	JUMPE	B,RET		;IF ARG = 0, FLAG = 0
	TLO	FF,PMATCH	;OTHERWISE, SET FLAG
	JRST	RET

;EH COMMAND -- CHANGE ERROR MESSAGE DEFAULT

ERRSET:	POP	P,CH	;[144]
	TRNE	FF,ARG		;ARG SEEN?
	JRST	ERRSE1		;YES, RESET INDICATOR
	MOVE	A,ERRLEN	;NO, RETURN CURRENT VALUE OF FLAG
	ADDI	A,2		;CONVERT TO EXTERNAL VALUE
	JRST	VALRET

ERRSE1:	JUMPG	B,.+2		;TRANSLATE AS FOLLOWS:
	MOVEI	B,ERRMSG	;-N,0 IS SET TO STANDARD (ERRMSG)
	SUBI	B,2		;1 BECOMES -1 = SHORT MESSAGE
	MOVEM	B,ERRLEN	;2 BECOMES 0  = MEDIUM
	JRST	RET		;3 BECOMES +1 = LONG

;EN COMMND -- CHANGE ERROR FOR ER IND

NOERST:	POP	P,CH
	TRNE	FF,ARG		;ARG SEEN?
	JRST	ERRSQ1		;YES, RESET INDICATOR
	MOVE	A,NOERRQ	;NO, RETURN CURRENT VALUE OF FLAG
	JRST	VALRET

ERRSQ1:	MOVEM	B,NOERRQ	;2 BECOMES 0  = MEDIUM
	JRST	RET		;3 BECOMES +1 = LONG
U NOERRQ,1
;ER	PREPARE TO READ FILE

OPNRX:	PUSHJ	P,OPNRD	;ER CALL
	POPJ	P,

OPNRD:	TLZ	FF,FINF+UREAD	;NOT EOF & CLOSE PREVIOUS INPUT
	RELEAS	INCHN,0		;YES. RELEASE IT BEFORE OPENING NEW FILE.
IFN SFDCNT,<
	MOVEI	E,REAPTH	;GET READ PATH ADDR
	MOVEM	E,FILSFP	;SET
>
	PUSHJ	P,FILSPC	;GET FILE SPEC
	MOVE	E,FILDEV	;INITIALIZE OPEN UUO ARGUMENTS
	MOVEM	E,OPNR1
	MOVE	E,FILDVC	;GET DEV CHR
	MOVEM	E,DEVSAV	;SAVE FOR EB
	TLNN	E,4	;SKIP IF DISK
	JRST	OPNRDA	;BR IF NOT
	TLNE	E,10	;SKIP IF NOT ALSO A TTY
	JRST	OPNRDA
	SKIPE	FILNAM	;SKIP IF NONE
	JRST	OPNRDA	;BR
	JSP	A,CONMES	;MESSAGE
	ASCIZ	/%Input Open With No File Name
/
	POP	P,A	;POP RETURN
	TLNE	FF,UEBTMP
	POPJ	P,
	SKIPN	NOERRQ
	POPJ	P,
	POP	P,A
	MOVE	A,[EXP 777777000000]
	JRST	VALRET
OPNRDA:	SKIPE	FASTEC
	JRST	OPNRD$
	MOVE	C,FILSCT	;GET COUNT
	ADDI	C,3	;INCR COUNT
	MOVE	B,FILNPT
	SETOM	NOMOVY
	PUSHJ	P,X3	;SET
	MOVEM	B,QTAB-"0"+"-"	;SAVE
OPNRD$:	SETZM	OPNRI		;ASCII MODE
	MOVEI	E,IBUF
	MOVEM	E,OPNRB
	OPEN	INCHN,OPNRI	;OPEN INPUT FILE
	ERROR	E.IDV
	PUSHJ	P,OPNIN
	MOVE	E,FILNAM+3	;GET PPN
	MOVEM	E,REAPPN
	SKIPLE	MONITR		;IF SERIES 3 OR 4 MONITOR, SHORT LOOKUP
	TLNN	FF,UEBTMP	;IF SERIES 5 & DOING EB, LONG LOOKUP
	JRST	OPNRD1		;SHORT
	MOVE	E,DEVSAV	;[136] GET DEVICE CHAR
	TLNE	E,DVDTA		;[136] CHECK FOR DECTAPE
	JRST	OPNRD1	;[136] SHORT IF IS
	MOVE	E,[FILNAM,,.RBNAM]	;GET NAME & EXT TO EXT LOOK BLK
	BLT	E,.RBEXT
	MOVE	E,FILNAM+3	;ALSO PPN
IFN SFDCNT,<
	SKIPE	REAPTH+SFDCNT+4
U REAPTH,SFDCNT+5
	MOVEI	E,REAPTH	;GET PATH ADDRESS
>
	MOVEM	E,.RBPPN
	LOOKUP	INCHN,XFILNM	;EXTENDED LOOKUP
	JRST	LKUPE2		;ERROR
	MOVE	E,.RBEXT
	MOVEM	E,FILNAM+1
	MOVE	E,.RBPRV
	MOVEM	E,FILNAM+2
	MOVE	E,.RBPPN
	MOVEM	E,FILNAM+3
	JRST	OPNRD2
OPNRD1:
IFN SFDCNT,<
	SKIPN	REAPTH+SFDCNT+4
	JRST	OPNRD3
	MOVEI	E,REAPTH
	MOVEM	E,FILNAM+3
>
OPNRD3:	LOOKUP	INCHN,FILNAM	;SHORT LOOKUP
	JRST	LKUPER		;LOOKUP FAILURE
	MOVE	E,[XWD FILNAM,RSAVNM]
	BLT	E,RSAVNM+3
OPNRD2:
IFN SFDCNT,<
	MOVE	E,REAPTH+2	;GET PPN
	MOVEM	E,FILNAM+3	;SET FOR ERRORS
>
	MOVE	E,[XWD FILNAM,INFILE]	;SAVE INPUT FILENAME
	BLT	E,INFILE+1
	TLO	FF,UREAD	;INPUT FILE NOW OPEN
	MOVSI	E,SUPLSN+XBASIC	;CK SUPLSN SWITCH
	AND	E,SWITC		;GET SETTING
	MOVEM	E,INSWIT	;STORE SETTING FOR INPUT
	TLZ	E,XBASIC	;ZAP BASIC
	XORM	E,SWITC		;CLR SUPLSN IN SWITCH WORD
	TRZ	FF,SEQF		;CLR SEQUENCE NUMBER FLAG
	TLNE	FF,UEBTMP
	POPJ	P,
	SKIPN	NOERRQ
	POPJ	P,
	POP	P,A
	POP	P,A
	SETZM	A
	JRST	VALRET

OPNIN:	MOVEI	T,IBUF1		;GET INPUT BUFFERS
	EXCH	T,.JBFF
	INBUF	INCHN,2
	MOVEM	T,.JBFF
	POPJ	P,
U REAPPN,1
U RSAVNM,4
IFN SFDCNT,<U RNMPTH,SFDCNT+5>
ECHNGE:	TLNE	FF,UREAD
	TLNE	FF,UBAK
	ERROR	E.NIO
IFN SFDCNT,<MOVEI E,RNMPTH
	MOVEM	E,FILSFP>
	PUSHJ	P,FILSPC	;GET NEW STUFF
	SKIPE	FASTEC
	JRST	ECHG0$
	MOVE	B,FILNPT	;GET NAME PTR
	MOVE	C,FILSCT
	ADDI	C,3
	SETOM	NOMOVY
	PUSHJ	P,X3
	MOVEM	B,QTAB-"0"+"/"
ECHG0$:	MOVE	E,FILDVC
	TLNN	E,4
	ERROR	E.NDD
	HLLZ	E,RSAVNM+1
	SKIPN	SFPARI
	MOVEM	E,FILNAM+1
	SKIPE	PRTIND	;SKIP IF NO PROT SPEC
	JRST	ECHG01
	MOVE	E,RSAVNM+2
	LSH	E,-^D27	;SHIFT DOWN
	JRST	ECHG02
ECHG01:	MOVE	E,FILPRT
ECHG02:	LSH	E,^D27
	MOVEM	E,FILNAM+2
IFN SFDCNT,<
	SKIPN	REAPTH+SFDCNT+4
	JRST	ECHG03	;BR IF NOT AN SFD DEVICE
	SKIPE	FILNAM+3
	JRST	ECHG04
	MOVE	E,REAPPN	;GET OLD ONE
	MOVEM	E,RNMPTH+2
	JRST	ECHG05
ECHG04:	MOVE	E,FILPPN
ECHG05:	MOVEM	E,REAPTH+2
	MOVEI	E,RNMPTH
	SKIPN	SFDPRE
	MOVEI	E,REAPTH
	MOVEM	E,FILNAM+3
	RENAME	INCHN,FILNAM
	JRST	ECHGER
	JRST	ECHRL
>
ECHG03:	MOVE	E,REAPPN
	SKIPE	FILNAM+3
	MOVE	E,FILPPN
	MOVEM	E,FILNAM+3
	RENAME	INCHN,FILNAM
	JRST	ECHGR3
ECHRL:	TLZ	FF,UREAD
	RELEASE	INCHN,
	POPJ	P,
IFN SFDCNT,<
ECHGER:	MOVE	E,FILNAM+3
	MOVE	E,2(E)	;GET PPN
	MOVEM	E,FILNAM+3
>
ECHGR3:	PUSHJ	P,ECHRL
	EE1+ERROR	E.RNM
;EB, EA PROCESSOR

U SUPERB,1
JAKESB:	SETOM	SUPERB
IFN SPBACK,<SKIPA>
EBAKUP:	SETZM	SUPERB
IFN SPBACK,<
	SKIPE	BACKWS
	SETCMM	SUPERB
>
	TLNE	FF,UBAK		;FLAG IF EB ALREADY IN PROGRESS
	ERROR	E.EBO
	TLZ	FF,UBAK		;CLR FLAG IN CASE OF FAILURE
	TLO	FF,UEBTMP	;SET EB UUO FLAG
	MOVE	E,[XFILNM+1,,XFILNM+2]	;CLR EXTENDED LOOKUP ARG BLK
	SETZM	XFILNM+1
	BLT	E,.RBDEV
	MOVEI	E,16		;NUMBER OF ARGS USED
	MOVEM	E,XFILNM
	PUSHJ	P,OPNRD		;READ THE SPECIFIED FILE
IFN SFDCNT,<
	MOVE	E,[XWD REAPTH,WTRPTH]
	BLT	E,WTRPTH+SFDCNT+4	;COPY READ PAT TO WRITE PATH
U WTRPTH,5+SFDCNT
	MOVE	E,USRPPN
	MOVEM	E,WTRPTH+2
>
	MOVE	E,DEVSAV	;GET DEVICE CHARACTERISTICS
	TLNN	E,4		;FLAG IF NOT DTA OR DSK
	ERROR	E.EBD
	TLNE	E,DVDTA		;[136] DECTAPE ?
	JRST	EBAKU4		;[136] YES
	MOVE	E,USRPPN	;PROJ-PROG# = USER?
;EBUAKUP+16 REPLACED 1 INSTRUCTIONS [133] SPR#10-12419 BJ
IFE SFDCNT,<CAME E,.RBPPN		;[133]FILE IN USERS AREA?
>
IFN SFDCNT,<CAME E,REAPTH+2		;[133]FILE IN USERS AREA?
>
	JRST	EBAKU2		;NO, JUST DO ER-EW
	MOVE	E,FILDEV	;SAVE DEVICE NAME
	SKIPG	MONITR		;SERIES 5 MONITOR?
	JRST	EBAKU5		;NO
	MOVE	E,.RBSIZ	;COMPUTE # BLKS TO ASK FOR
	LSH	E,-7
	AOJ	E,
	MOVEM	E,FILNAM+3	;SAVE TEMPORARILY
	LDB	E,[POINT 9,.RBPRV,8]	;SAVE PROTECTION
	DPB	E,[POINT 9,FILNAM+2,8]
	MOVE	E,.RBDEV	;GET PHYSICAL UNIT NAME IN-FILE IS ON
	MOVEM	E,DCLOC		;DO A DSKCHR ON IT
	MOVE	E,[5,,DCLOC]
	CALLI	E,DSKCHR
EBAKU4:	SKIPA	E,FILDEV	;ERROR, USE BEST NAME WE HAVE
	MOVE	E,.STNAM	;GET NAME FOR FILESTR IN-FILE IS ON
	MOVEM	E,FILDEV	;SO WE CAN PUT NEW FILE ON SAME STR
EBAKU5:	MOVEM	E,EBDEV
	MOVE	E,FILNAM	;SAVE FILENAME
	MOVEM	E,BAKNAM	;IN BACKUP STORE
	HLLZ	E,FILNAM+1	;AND THE EXTENSION
IFN SPBACK,<
	SKIPN	SUPERB
	JRST	EBAKSS
	CAME	E,[SIXBIT /BAK/]
	JRST	EBAKST
	JSP	A,CONMES
	ASCIZ	/%Caution, If .Z## determination fails .BAK will be used
/
	JRST	EBAKST
>
EBAKSS:	CAMN	E,[SIXBIT /BAK/]	;CANNOT USE EB WITH FILE EXT = "BAK"
	ERROR	E.EBF
EBAKST:	MOVEM	E,BAKNAM+1
	MOVE	E,[.RBPRV,,.RBPRV+1]	;CLR EXTENDED ENTER ARG BLK
	SETZM	.RBPRV
	BLT	E,.RBDEV
	MOVE	E,FILNAM+3	;STORE ESTIMATED LENGTH
	MOVEM	E,.RBEST
	LDB	E,[POINT 9,FILNAM+2,8]	;SAVE PROTECTION OF INPUT FILE
	SKIPLE	MONITR		;SKIP IF 3 OR 4 SERIES MONITOR
	CAIGE	E,300		;MAY USER RENAME HIS FILE?
	CAIL	E,500		;REJECT 3+ IN LEVEL D, 5+ IN LEVEL C
	ERROR	E.EBP
	MOVEM	E,PROTEC
	MOVE	E,TMPTEC	;GET "###TEC"
	CAME	E,FILNAM	;FILNAM=###TEC?
	JRST	EBAKU1		;NO, OK
	HLRZ	A,FILNAM+1	;ALSO EXT="TMP"?
	CAIN	A,(SIXBIT /TMP/)	;EB###TEC.TMP ILLEGAL
	ERROR	E.EBF
	CAIE	A,(SIXBIT /CHP/)	;EB###TEC.CHP ?
	JRST	EBAKU1	;NO ?
	SKIPE	CHKPNT	;NOT CHECKPOINTED ?
	ERROR	E.CHO
	SKIPE	CHKEXE	;NOT CHECKPOINT EXECUTION
	ERROR	E.CHI
EBAKU1:	MOVEM	E,FILNAM
	MOVEM	E,.RBNAM
	MOVEM	E,BAKTMP	;SAVE FOR DTA RENAME
	MOVSI	E,(SIXBIT /TMP/)
	MOVEM	E,FILNAM+1
	MOVEM	E,.RBEXT
	SETZM	FILNAM+2
	SETZM	FILNAM+3
	PUSHJ	P,OPNW4		;WRITE THE TMP FILE
	PUSHJ	P,OPNW2
	TLO	FF,UBAK
EBAKU3:
IFN CCL,<SETZM	CCLSW>
	POPJ	P,

EBAKU2:	TLZ	FF,UEBTMP	;NO LONGER AN EB
;EBAKU2+1 INSERTED 1 INSTRUCTION [133] SPR#10-12419
IFN SFDCNT,<MOVE E,WTRPTH+2>
	MOVEM	E,FILPPN	;[133] EW MUST BE TO USERS'S AREA
	MOVE	E,[SIXBIT /DSK/]	;[146] ON DEVICE DISK
	MOVEM	E,FILDEV		;[146] RATHER THAN ERSATZ
	HLLZS	FILNAM+1	;RESTORE FILE SPECS
	SETZM	FILNAM+2
	SETZM	FILNAM+3
	PUSHJ	P,OPNW4		;EXECUTE EW INSTEAD OF EB
	PUSHJ	P,OPNW2
	JRST	EBAKU3

U OPNRI,1			;INPUT FILE OPEN ARGUMENTS, OPNRD+4(1)
U OPNR1,1			;INPUT DEVICE.  INIT+27(0),OPNRD+6
U OPNRB,1			;INITIALIZE TO XWD 0,INBUF. OPNRD+10
U BAKTMP,1			;FOR DECTAPE TEMP NAME
U PROTEC,1			;EB INPUT FILE PROTECTION
U DEVSAV,1			;DEVICE CHARACTERISTICS
U EBDEV,1			;EB DEVICE NAME
U TMPTEC,1			;SAVE FOR ###TEC. FILE NAME
;INPUT FILE LOOKUP ERROR

LKUPE2:	HRR	E,.RBEXT
	HRRM	E,FILNAM+1
	MOVE	E,.RBPRV
	MOVEM	E,FILNAM+2
LKUPER:
	TLNE	FF,UEBTMP
	JRST	LKUPR2
	SKIPN	NOERRQ
	JRST	LKUPR2
	POP	P,A
	POP	P,A
	HRRO	A,FILNAM+1
	JRST	VALRET
LKUPR2:
IFN SFDCNT,<
	SKIPN	REAPTH+SFDCNT+4
	JRST	LKUPR3
	MOVE	E,REAPTH+2	;GET PPN
	MOVEM	E,FILNAM+3	;SET
>
LKUPR3:	RELEAS	INCHN,0
	TLZ	FF,UREAD	;LET GO OF INPUT DEVICE
	EE1+ERROR E.FNF

;TYPE OUTPUT ERROR

ENTRR2:	HRR	E,.RBEXT
	HRRM	E,FILNAM+1
	MOVE	E,.RBPRV
	MOVEM	E,FILNAM+2
ENTERR:
IFN SFDCNT,<
	SKIPN	WTRPTH+SFDCNT+4
	JRST	ENTRR3
	MOVE	E,WTRPTH+2	;GET PPN
	MOVEM	E,FILNAM+3	;SET
>
ENTRR3:	RELEAS	OUTCHN,0
	TLZ	FF,UWRITE+UBAK	;LET GO OF OUTPUT DEVICE & EB FLAG
	HRRZ	E,.RBEXT	;GET ERROR CODE IF EXT ENTER
	TLZE	FF,UEBTMP	;EB ENTER?
	HRRM	E,FILNAM+1	;YES, PUT INTO POSITION FOR ERROR MSG
	LDB	E,[POINT 6,FILNAM+1,35]	;ERROR CODE
	JUMPN	E,ENTER2	;ERROR CODE 0?
	MOVE	A,WRICHR	;YES
	TLNE	A,DVDTA		;IF DTA ITS FULL, OTHERWISE ENTER ERROR
	ERROR	E.FUL
ENTER2:	EE1+ERROR E.ENT
;EW	SELECTS THE OUTPUT DEVICE AND OPENS THE FILE SPECIFIED (IF ANY)

OPNWR:	PUSHJ	P,OPNW1

OPNW2:	SKIPG	MONITR		;ALWAYS SHORT LOOKUP/ENTER
	JRST	OPNW3		;IF LEVEL 3 OR 4 MONITOR
	TLNN	FF,UEBTMP	;EB ENTER?
	JRST	OPNW3A		;NO, EXT LOOKUP & SHORT ENTER
;EDIT [136]
	TLNN	E,DVDTA		;CHEK FOR DECTAPE
	JRST	OPNW2A		;NOT
	ENTER	OUTCHN,XFILNM+2	;SHORT ENTER
	JRST	ENTRR2	;ERROR
	JRST	OPNW5
OPNW2A:	ENTER	OUTCHN,XFILNM	;YES, DO EXTENDED ENTER
	JRST	ENTRR2		;DIDN'T WORK
	JRST	OPNW5
;OPNW3-1/2 INSERTED NEW ROUTINE	[EDIT#124]
OPNW3A:	TLNN	E,DVDSK		;[136] DISK ?
	JRST	OPNW3		;[136] NO
	MOVEI	A,16		;SET UP 16 ELEMENT EXT LOOKUP
	MOVEM	A,XFILNM	;THIS WILL ALLOW CHECK FOR LIB
	MOVE	A,FILPPN	;FILE SO AS NOT TO GENERATE
	SKIPE	A	;SKIP IF PPN NOT SPECIFIED
	JRST	OPNW3O	;SKIP THE FOLLOWING BROO-HA-HA
	MOVE	A,USRPPN	;GET USER'S
	MOVEM	A,FILPPN	;SAVE IT
	MOVEM	A,FILNAM+3
OPNW3O:
IFN SFDCNT,<
	SKIPE	WTRPTH+SFDCNT+4
	MOVEI	A,WTRPTH
>
	MOVEM	A,.RBPPN	;THE %SUPERSEDING... MESSAGE
	MOVE	A,FILNAM	;FILE NAME
	MOVEM	A,.RBNAM
	HLLZ	A,FILNAM+1	;EXTENSION***DATE75***
	MOVEM	A,.RBEXT
	LOOKUP	OUTCHN,XFILNM	;PERFORM THE EXTENDED LOOKUP
	JRST	OPNW33		;FILE NOT THERE  THEN OK
	MOVE A,FILPPN	;IF PPN IS DIFFERENT THEN LIB
IFE SFDCNT,<CAMN	A,.RBPPN
	JRST	OPNW3B
	JRST	OPNW3C
>
IFN SFDCNT,<SKIPE	WTRPTH+SFDCNT+4
	JRST	OPNW3M
	CAMN	A,.RBPPN
	JRST	OPNW3B
	JRST	OPNW3C
OPNW3M:	CAMN	A,WTRPTH+2
	JRST	OPNW3B
	JRST	OPNW3C
>
OPNW3:
IFN SFDCNT,<
	SKIPN	WTRPTH+SFDCNT+4
	JRST	OPNW3D
	MOVEI	A,WTRPTH
	MOVEM	A,FILNAM+3
>
OPNW3D:	LOOKUP	OUTCHN,FILNAM	;IS THE FILE THERE ALREADY?
	JRST	OPNW33		;NO, OK
;OPNW3+2 CORRECT EDIT 124  NEXT 2 INSR[131] SPR#10-12297
OPNW3B:	MOVE	A,WRICHR	;[131]IF NOT A DIR DEV
	TLNN	A,4		;[131]THEN SKIP
	JRST	OPNW3C		;ELSE MESSAGE IS ORDER
	TLNE	A,10	;TTY TOO ?
	JRST	OPNW3C	;YES SKIP IS NUL:
	JSP	A,CONMES	;YES, WARN HIM
	ASCIZ	/%Superseding Existing File
/
OPNW3C:	PUSHJ	P,OPNW44	;[136] RE-INIT TO SUPER
OPNW33:	SETZM	E	;CLR PROT.+CREATE DATE
	TLNN	FF,UEBTMP	;EB ENTER ?
	MOVE	E,FILPRT	;GET PROTECTION
	LSH	E,^D27		;SHIFT TO PLACE
	MOVEM	E,FILNAM+2	;SET TO BLOCK
	MOVE E, FILPPN		;BJ  SPR#10-8179 FEB 1 '73
IFN SFDCNT,<
	SKIPN	WTRPTH+SFDCNT+4
	JRST	OPNW3N
	MOVEM	E,WTRPTH+2
	MOVEI	E,WTRPTH
>
OPNW3N:	MOVEM E, FILNAM+3	;BJ--
	HLLZS	FILNAM+1	;***DATE75***
	ENTER	OUTCHN,FILNAM
	JRST	ENTERR
OPNW5:	MOVE	A,[XWD FILNAM,OUTFIL]	;SAVE OUTPUT FILE NAME
	BLT	A,OUTFIL+1
	TLO	FF,UWRITE	;OUTPUT FILE NOW OPEN
	MOVSI	E,GENLSN+XBASIC+SUPLSN	;GET OUTPUT GENLSN & SUPLSN SWITCHES
	AND	E,SWITC
	TLNE	E,GENLSN	;ARE BOTH SET?
	TLNN	E,SUPLSN
	JRST	.+2		;NO, OK
	ERROR	E.COS
	MOVEM	E,OUTSWT	;STORE OUTPUT SWITCH
	MOVEI	E,0			;INIT LSN CTR
	MOVEM	E,LSNCTR
IFN CCL,<
	TLNN	FF,UEBTMP
	SETZM	CCLSW
>
	POPJ	P,

OPNW1:	TLNE	FF,UBAK
	ERROR	E.EBO
IFN SFDCNT,<
	MOVEI	E,WTRPTH
	MOVEM	E,FILSFP
>
	PUSHJ	P,FILSPC
	MOVE	E,FILDEV
	MOVEM	E,OPNWD
	MOVE	E,FILDVC	;GET DEV CHR
	MOVEM	E,WRICHR
	TLNN	E,4
	JRST	OPNW4X
	TLNE	E,10
	JRST	OPNW4X
	MOVE	E,FILNAM
	CAME	E,TMPTEC
	JRST	OPWW01
	HLRZ	E,FILNAM+1
	CAIE	E,'CHP'
	JRST	OPWW01
	SKIPE	CHKPNT
	ERROR	E.CHO
	SKIPE	CHKEXE
	ERROR	E.CHI
OPWW01:	SKIPE	FILNAM	;SKIP IF NONE
	JRST	OPNW4X	;BR IF ONE
	JSP	A,CONMES
	ASCIZ	/%Output Open With No File Name
/
	POP	P,A	;POP RETURN
	POPJ	P,	;RETURN
OPNW4:	MOVEI	B,[ASCII /#EB#/]
	SKIPE	SUPERB	;SKIP IF EB
	MOVEI	B,[ASCII /#EA#/]
	IMULI	B,5
	MOVEI	C,5
	MOVEM	C,FILSCT	;SET COUNT
	MOVE	E,FILDEV
	MOVEM	E,OPNWD
	PUSHJ	P,DEVCHK	;GET DEVICE CHARACTERISTICS
	MOVEM	E,WRICHR
	SKIPA
OPNW4X:	MOVE	B,FILNPT
	SKIPE	FASTEC
	JRST	OPNW4$
	MOVE	C,FILSCT	;GET COUNT
	ADDI	C,3	;INCR
	SETOM	NOMOVY
	PUSHJ	P,X3	;SET
	MOVEM	B,QTAB-"0"+","	;SET
OPNW4$:	TLZ	FF,UWRITE	;CALL HERE FROM EB
	RELEAS	OUTCHN,0
	SETZM	OPNWI
	MOVSI	E,OBF
	MOVEM	E,OPNWB
OPNW44:	MOVE	E,WRICHR	;[162] GET DEV CHAR
	TLNN	E,DVDSK		;[162] DISK ?
	JRST	OPNW45		;[162] NO
	MOVSI	T,400000	;[162] YES, DO PHYS
	TLNE	FF,UEBTMP	;[162] ONLY FOR EB
	IORM	T,OPNWI		;[162]
OPNW45:	OPEN	OUTCHN,OPNWI
	ERROR	E.ODV
	MOVEI	T,OBUF1
	EXCH	T,.JBFF
	OUTBUF	OUTCHN,2
	MOVEM	T,.JBFF
	POPJ	P,

U OPNWI,1			;OUTPUT FILE OPEN ARGUMENTS. OPNW1+4(1)
U OPNWD,1			;OUTPUT DEVICE.  OPNW1+6
U OPNWB,1			;OUTBUT BUFFER HEADER ADDRESS. OPNW1+10(OUTBUF)
U WRICHR,1			;CHARACTERISTICS OF WRITE DEVICE
U OUTFIL,2			;STORE FOR OUTPUT FILENAME
U INFILE,2			;STORE FOR INPUT FILENAME
;GET I-O DEVICE CHARACTERISTICS IN AC E
;IF TTY, IT MUST BE AVAILABLE & NOT CONTROLLING A JOB

DEVCHK:	CALLI	E,DEVCHR	;GET CHARACTERISTICS
	TLNN	E,10		;TTY?
	POPJ	P,		;NO
	TLNE	E,40		;YES, AVAILABLE?
	TLNE	E,20000		;CONTROLLING A JOB (INCLUDING USER)?
	ERROR	E.TTY
	POPJ	P,		;NO, IT'S OK

;EZ	SELECTS THE OUTPUT DEVICE, ISSUES A REWIND COMMAND TO IT,
;	ISSUES A COMMAND TO ZERO ITS DIRECTORY, AND OPENS THE FILE
;	SPECIFIED (IF ANY).

ZERDIR:	PUSHJ	P,OPNW1		;DETERMINE OUTPUT DEVICE
	CALLI	OUTCHN, UTPCLR	;CLEAR DIRECTORY OF OUTPUT DEVICE
	MTAPE	OUTCHN,1	;REWIND OUTPUT DEVICE
	JRST	OPNW2		;ENTER FILE




;EF	FINISHES OUTPUT ON THE CURRENT OUTPUT FILE WITHOUT
;	SELECTING A NEW OUTPUT FILE.

CLOSEF:	TLNN	FF,UWRITE	;[155]
	JRST	CLOSF2
	CLOSE	OUTCHN,2
	STATZ	OUTCHN,740000
	JRST	OUTERR
	TLNE	FF,UBAK		;EB IN PROGRESS?
	PUSHJ	P,BAKCLS	;YES
	RELEAS	OUTCHN,0
	TLZ	FF,UBAK+UWRITE	;[155]
CLOSF2:
IFN NORUNS,<POPJ	P,>
IFE NORUNS,<
	SETOM	SFNOSW
IFN SFDCNT,<
	SETZM	FILSFP
>
	PUSHJ	P,FILSPC
	SETZM	SFNOSW
	MOVSI	A,'SYS'
	SKIPN	SFPADV
	MOVEM	A,FILDEV
	SKIPN	FILNAM
	POPJ	P,
	OUTCHR	["["]
	MOVE	A,[POINT 6,FILNAM]
	MOVE	AA,6
EXCNTL:	ILDB	CH,A	;GET CH
	SKIPN	CH	;SKIP IF ONE
	JRST	EXCNTE	;JRST IF NOT
	ADDI	CH,40	;TO ASCII
	OUTCHR	CH
	SOJG	AA,EXCNTL	;LOOP
EXCNTE:	PUSH	P,[POINT 7,[ASCIZ /]
/]]
	PUSHJ	P,STRGPT
	MOVE	A,FILDEV	;GET DEV
U	RUNUBK,6
	MOVEM	A,RUNUBK
	MOVE	A,FILNAM	;GET NAME
	MOVEM	A,RUNUBK+1
	MOVE	A,FILNAM+1
	MOVEM	A,RUNUBK+2
	MOVE	A,FILNAM+3	;GET PPN
	MOVEM	A,RUNUBK+4	;SET
	MOVEI	A,RUNUBK
	RUN	A,
	PUSH	P,[POINT 7,[ASCIZ /%Can't run that program
/]]
	PUSHJ	P,STRGPT
	POPJ	P,
>
;EM	EXECUTE MTAPE UUO.

EMTAPE:	TLNN	FF,UREAD
	ERROR	E.EMD
	MOVE	E,OPNR1		;SET UP INPUT DEVICE NAME
	MOVEM	E,FILDEV	;IN CASE OF AN ERROR
	PUSHJ	P,CHK2
	CAIGE	B,1
	ERROR	E.EMA
	MTAPE	INCHN,0(B)
	OPEN	INCHN,OPNRI	;RE-INIT BUFFERS
	ERROR	E.IEM
	PUSHJ	P,OPNIN
	POPJ	P,
;THIS ROUTINE IS CALLED AT EF IF AN EB WAS DONE. IT DOES
;THE WORK OF MAKING THE INPUT FILE HAVE THE EXTENSION .BAK ,
;DELETING ANY PREVIOUS FILE.BAK, AND RENAMING THE NEW OUTPUT
;FILE AS THE ORIGINAL FILE.EXT

BAKCLS:	CLOSE	INCHN,0
	MOVE	E,EBDEV		;ORIGINAL EB DEVICE
	MOVEM	E,FILDEV	;IN CASE OF AN ERROR
	TLZN	FF,UREAD	;INPUT OPEN?
	JRST	BKCLS4		;NO
	CAMN	E,OPNR1		;ORIGINAL SAME AS CURRENT?
	JRST	BKCLS2		;YES
BKCLS4:	MOVEM	E,OPNR1		;NO, RE-OPEN ORIGINAL
;	EDIT [162]
	MOVE	E,WRICHR	;GET CHAR
	TLNN	E,DVDSK		;DISK ?
	JRST	BKCLS6		;NO
	MOVSI	E,400000	;GET PHYS
	IORM	E,OPNRI	;
BKCLS6:	OPEN	INCHN,OPNRI
	ERROR	E.IRN
BKCLS2:	MOVE	E,BAKNAM
	MOVEM	E,FILNAM
	MOVSI	E,(SIXBIT /BAK/)
	SKIPE	SUPERB	;SKIP IF NOT SUPER BAKUP TIME
	PUSHJ	P,FILEXF	;TRY FOR A NEATO KEEN EXTENTION
	HLLZ	E,E	;***DATE75***
	MOVEM	E,FILNAM+1	;***DATE75***
	CAME	E,[SIXBIT /BAK/]	;DID WE GET .BAK ?
	JRST	BAKCSS	;BR IF NO
	HLRZ	E,BAKNAM+1	;TEST FOR FILE OF .BAK
	CAIN	E,'BAK'	;TEST FOR .BAK
	ERROR	E.ZNF
BAKCSS:
IFE SFDCNT,<MOVE E,.RBPPN>
IFN SFDCNT,<
	MOVE	E,WTRPTH+2	;GET PPN
	MOVEM	E,WTRSVP
U WTRSVP,1
	SKIPE	WTRPTH+SFDCNT+4
	MOVEI	E,WTRPTH
>
	MOVEM	E,FILNAM+3
	MOVEM	E,FILOPT
U FILOPT,1
	MOVEI	B,PROTCB		;IF 0 RETURNED, ASSUME 055
	LOOKUP	INCHN,FILNAM
	JRST	BKCLS1
	LDB	B,[POINT 9,FILNAM+2,8]	;GET PROTECTION OF BACKUP FILE
	CLOSE	INCHN,0
	SETZM	FILNAM
	SKIPN	SUPERB	;SKIP IF SUPER BACKUP
	JRST	BKCLS0	;BR IF ORDINARY BACKUP
	HLLZ	E,FILNAM+1	;GET THE EXT***DATE75***
	CAME	E,[SIXBIT /BAK/]
	JRST	BKCLS1
BKCLS0:	MOVE	E,FILOPT
	MOVEM	E,FILNAM+3
	RENAME	INCHN,FILNAM
	1B12+ERROR E.BAK
BKCLS1:	MOVE	E,BAKNAM
	MOVEM	E,FILNAM
	HLLZ	E,BAKNAM+1
	MOVEM	E,FILNAM+1
IFN	SFDCNT,<MOVE E,WTRSVP
	MOVEM	E,WTRPTH+2>
	MOVE	E,FILOPT
	MOVEM	E,FILNAM+3
	LOOKUP	INCHN,FILNAM
	1B12+ERROR E.ILR
	CLOSE	INCHN,0
	SKIPG	MONITR		;SERIES 5?
	JRST	BKCLS5		;NO
	MOVE	E,PROTEC	;GET PROT OF INPUT FILE
	CAIGE	E,200		;IS IT IN THE 200 RANGE?
	JRST	BKCLS5		;NO
	XORI	E,300		;YES, THEN RENAME IT TO 100 RANGE --
	DPB	E,[POINT 9,FILNAM+2,8]	;SO WE CAN DO THE REAL RENAME TO .BAK
	MOVE	E,FILOPT
	MOVEM	E,FILNAM+3
	RENAME	INCHN,FILNAM
	1B12+ERROR E.IRB
BKCLS5:	MOVSI	E,(SIXBIT /BAK/)
IFN SPBACK,<
	SKIPE	SUPERB	;SKIP IF SUPER BACKUP
	MOVE	E,EXTEXT	;GET EXT FROM SAVE
>
	HLLM	E,FILNAM+1	;***DATE75***
	DPB	B,[POINT 9,FILNAM+2,8]	;GIVE BAK FILE SAME PROT AS OLD BAK FILE
	MOVE	E,FILOPT
	MOVEM	E,FILNAM+3
	RENAME	INCHN,FILNAM
	ERROR	E.IRB
	MOVE	E,DEVSAV	;GET INPUT DEVICE CHARCATERISTICS
	TLNN	E,DVDTA		;DECTAPE?
	JRST	BKCLS3		;NO
	MOVE	A,BAKTMP	;DECTAPE NEEDS A SECOND LOOKUP
	MOVEM	A,FILNAM	;ON ###TEC.TMP (SO DO MONITORS BEFORE 5 SERIES)
	MOVSI	A,(SIXBIT /TMP/)
	MOVEM	A,FILNAM+1
	SETZM	FILNAM+3
	LOOKUP	OUTCHN,FILNAM
	1B12+ERROR E.OLR
	CLOSE	OUTCHN,2	;CLOSE OUTPUT FOR RENAME
BKCLS3:	MOVE	E,BAKNAM	;RENAME ###TEC.TMP TO ORIGINAL NAME
	MOVEM	E,FILNAM
	MOVE	E,BAKNAM+1
	HLLZM	E,FILNAM+1
	MOVE	E,PROTEC	;EB OUTPUT FILE GETS SAME PROTECTION
	DPB	E,[POINT 9,FILNAM+2,8]	; AS INPUT FILE
	SETZ	E,
	DPB	E,[POINT 27,FILNAM+2,35]	;& CLR BITS 9-12
	MOVE	E,FILOPT
	MOVEM	E,FILNAM+3
	RENAME	OUTCHN,FILNAM
	1B12+ERROR E.RNO
	POPJ	P,
IFE SPBACK,<
FILEXF:	SETZM	SUPERB
	POPJ	P,
>
IFN SPBACK,<
;ROUTINE TO FIND A GOOD BAKUP FILE EXTENTION FOR SUPER BACKUPS
;
U	EXFOPN,3	;OPEN BLOCK FOR UFD LOOKUP
U	EXFLUK,4	;LOOKUP BLOCK FOR UFD
U	EXFRSV,1	;SAVE FOR .JBREL
U	EXFFSV,1	;SAVE FOR .JBFF
U	EXFBUF,3	;BUFFER RING HEADER
R2=2
R3=3
R4=4
FILEXF:
IFN SFDCNT,<
	SKIPE	WTRPTH+SFDCNT+4
	JRST	FILEXX
	SETZM	SUPERB
	POPJ	P,
>
FILEXX:	PUSH	P,R2	;SAVE SOME REGS
IFE SFDCNT,<
	MOVE	R2,WRICHR	;GET DEVICE CHAR
	TLNE	R2,200000	;SKIP IF NOT DISK
	JRST	FILEXY
	SETZM	SUPERB
	POP	P,R2	;POP REG
	POPJ	P,
>
FILEXY:	PUSH	P,R3	;
	PUSH	P,R4	;
	MOVEI	R2,10	;GET IMAGE MODE
	MOVEM	R2,EXFOPN	;INIT TO OPEN BLK
	MOVE	R2,FILDEV	;GET DEVICE OF BACKUP TEMP
	MOVEM	R2,EXFOPN+1	;TO OPEN BLK
	MOVE	R2,[XWD 0,EXFBUF]	;GET BUFFER POINTERS
	MOVEM	R2,EXFOPN+2	;TO OPEN BLK
	SETZM	EXFBUF	;ZAP THE RING POINTERS
	SETZM	EXFBUF+1	;
	SETZM	EXFBUF+2	;
	MOVE	R2,.JBFF	;GET HIGEST CORE
	MOVEM	R2,EXFFSV	;SAVE IT
	MOVE	R2,.JBREL	;GET HIGHEST CORE
	MOVEM	R2,.JBFF	;WE WANT CORE THAT IS VIRGIN
	MOVEM	R2,EXFRSV	;SAVE OLD CORE TOP
IFN SFDCNT,<
	SKIPE	WTRPTH+3
	JRST	FILEX2
>
	MOVE	R2,USRPPN	;GET HIS PPN
	MOVEM	R2,EXFLUK	;TO FILE NAME
	MOVSI	R2,'UFD'	;WE WANT HIS UFD
	MOVEM	R2,EXFLUK+1	;SET INTO BLOCK
	SETZM	EXFLUK+2	;SET FOR DEFAULT PROT
	MOVE	R2,[XWD 1,1]	;UFD'S AE IN [1,1]
	MOVEM	R2,EXFLUK+3	;INTO BLOCK
IFN SFDCNT,<
	JRST	FILEX5
U EXTPTH,SFDCNT+3	;DON'T NEED RETURN WORD OR ONE LEVEL OF QULIFICATION
FILEX2:	SETZM	EXTPTH
	SETZM	EXTPTH+1
	MOVE	R2,WTRPTH+2	;GET PPN
	MOVEM	R2,EXTPTH+2	;SET
	MOVEI	R2,EXTPTH+3	;GET PTR TO EXT SFD LIST
	MOVEI	R3,WTRPTH+3	;GET PTR TO ORDINARY SFD LIST
FILEX3:	SKIPN	1(R3)	;SKIP IF NOT THE LAST ENTRY
	JRST	FILEX4
	MOVE	R4,(R3)	;GET ENTRY
	MOVEM	R4,(R2)	;SET FOR EXT
	AOS	R3
	AOS	R2	;INCR COUNTERS
	JRST	FILEX3	;LOOP
FILEX4:	SETZM	(R2)	;SET ENDING
	MOVE	R2,(R3)	;GET LAST NAME (SFD NAME)
	MOVEM	R2,EXFLUK	;SET
	MOVSI	R2,'SFD'	;GET SFD EXT
	MOVEM	R2,EXFLUK+1	;SET
	MOVEI	R2,EXTPTH	;GET PATH
	MOVEM	R2,EXFLUK+3	;SET
	SETZM	EXFLUK+2	;SET PROT
>
FILEX5:	OPEN	BAKCHN,EXFOPN	;OPEN THE CHANNEL
	JRST	EXTER1	;BR IF CAN'T
	LOOKUP	BAKCHN,EXFLUK	;LOOKUP UFD
	JRST	EXTER2	;BR IF CAN'T
	MOVSI	E,'Z0/'	;GET INITIAL BACKUP EXT - 1
	LSH	E,-1	;RIGHT HIFTFOR LOGICAL COMP
EXTLP1:	JSP	R4,EXTRDR	;GET A WORD OF FILENAME
	CAMN	R2,BAKNAM	;SAME AS NAME FOR BACKUP ?
	JRST	EXTSK1	;BR IF IS
	JSP	R4,EXTRDR	;SKIP EXT
	JRST	EXTLP1	;RE-LOOP
EXTSK1:	JSP	R4,EXTRDR	;GET THE EXT
	MOVE	R3,R2	;COPY
	TDZ	R2,[007777777777]	;ZAP ALL BUT FIRST CHAR
	CAME	R2,[SIXBIT /Z/]	;IS IT A Z ?
	JRST	EXTLP1	;BR IF NOT
	TDZ	R3,[000000777777]	;ZAP LOW HALF
	LSH	R3,-1	;RIGHT ONE FOR LOGICAL COMP
	CAMLE	R3,E	;IS IT LARGER THAN THE ONE WEE HAVE ?
	MOVE	E,R3	;COPYIT IF IS
	JRST	EXTLP1	;RE-LOOP
EXTRTN:	LSH	E,1	;SHIFT BACK
	MOVE	R2,E	;COPY THE EXT TO RETURN -1
	TDZ	R2,[777700777777]	;ZAP ALL BUT LAST CHAR
	CAML	R2,[SIXBIT /  9   /]	;IS IT GTR 8
	JRST	EXTCRY	;BR IF IS (MUST CARRY ONE)
	MOVE	R2,E	;RECOPY
	ADD	R2,[000001000000]	;INCR TO NEXT FILE EXT
	JRST	EXTRT2	;BR TO CLOSE SHOP
EXTCRY:	MOVE	R2,E	;RECOPY
	TDZ	R2,[000077777777]	;ZAP LAST DIGIT
	ADD	R2,[000120000000]	;ADD 10
EXTRT2:	CLOSE	BAKCHN,	;CLOSE THE UFD CHANNEL
	RELEAS	BAKCHN,	;RELEASE IT
	MOVEM	R2,EXTEXT	;SAVE NEXT EXT
U	EXTEXT,1
	MOVE	R2,EXFFSV	;GET OLD LOWSEG EXTENT
	MOVEM	R2,.JBFF	;PUT BACK OLD JBFF
	MOVE	R2,EXFRSV	;GET BACK OLD CORE TOP
	CALLI	R2,11	;FREE CORE
	JRST	.+1	;SHOULD ALWAYS WORK
	POP	P,R4	;RESTORE REGS
	POP	P,R3	;
	POP	P,R2	;
	POPJ	P,	;RETURN

EXTRDR:	SOSG	EXFBUF+2	;DEC COUNT
	IN	BAKCHN,	;GET A BUFFER
	JRST	EXTRS1	;BR IF NO ERROR
	STATZ	BAKCHN,20000	;TEST FOR EOF
	JRST	EXTRTN	;BR IF EOF
	PUSH	P,[POINT 7,[ASCIZ /%Error in reading ppn.UFD[1,1] for super backup -- Using .BAK extension
/]]
	PUSHJ	P,STRGPT
	JRST	EXTER4	;BR TO CLEAN UP THE MESS
EXTER1:	PUSH	P,[POINT 7,[ASCIZ /%Can't open ppn.UFD[1,1] for super backup -- Using .BAK extension
/]]
	PUSHJ	P,STRGPT
	JRST	EXTER4	;BR TO CLEAR UP MESS
EXTER2:	PUSH	P,[POINT 7,[ASCIZ /%Can't lookup ppn.UFD[1,1] for super backup -- Using .BAK extension
/]]
	PUSHJ	P,STRGPT
EXTER4:	MOVSI	E,'BAK'	;GET .BAK EXT
	MOVE	R2,E	;COPY IT
	JRST	EXTRT2	;BR TO RETURN
EXTRS1:	ILDB	R2,EXFBUF+1	;GET A WORD
	JRST	@R4	;RETURN
>

;ROUTINE TO PARSE FILE DESIGNATOR

FILSPC:	TLZ	FF,FILWD+FEXTF
	SETZM	SFPADV	;ZAP DEVICE RET
U	SFPADV,1
	SETZM	SFPARI	;ZAP EXT RETURN
U	SFPARI,1	;LOC
	SETZM	PRTIND
U PRTIND,1
	MOVEI	E,PROTCD	;GET DEFAULT OUTPUT PROTECTION CODE
	MOVEM	E,FILPRT	;SET
	MOVE	E,USRPPN	;& INIT PROJ-PROG # TO USER
	MOVEM	E,FILPPN
IFN SFDCNT,<
	SETZM	SFDPRE
U SFDPRE,1
	MOVEI	A,@FILSFP	;GET PTR
	SKIPN	A
	JRST	FILSPX
	SETZM	(A)
	SETZM	1(A)
	MOVEM	E,2(A)
	SETZM	3(A)
>
FILSPX:	SETZB	E,FILDEV	;CLEAR FILE DESIGNATOR ARGUMENTS.
	MOVE	A,CPTR
	IBP	A	;TO NEXT
	PUSH	P,A
	HRRZ	A,A
	IMULI	A,5	;X 5 FOR REL CHAR TO WORD
	EXCH	A,(P)	;GET BACK PTR
	LSH	A,6-^D36	;SHIFT DOWN P
	SUBI	A,^D29	;INVERT
	MOVN	A,A
	PUSH	P,[EXP 7]
	POP	P,FILNPT
	IDIVM	A,FILNPT
	POP	P,A	;GET OTHER
	ADDM	A,FILNPT	;ADD
	SETZM	FILSCT	;SET COUNT
	MOVE	A,[FILDEV,,FILNAM]
	BLT	A,SWITC

;FROM FILSPL+21,FILSP1+3,FILSP3+3,FILSP6+1


FILSPL:	PUSHJ	P,FILCHR	;GET NEXT COM CHAR.
	CAIN	CH,ALT
	JRST	FILSP2		;ALT MODE
	CAIN	CH,"<"		;PROTECTION ?
	JRST	FILPRP		;YES
	CAIN	CH,"/"		;SWITCH DELIMITER?
	JRST	FILSWT		;YES
	CAIN	CH,":"
	JRST	FILSP1		;DEVICE
	CAIN	CH,"."
	JRST	FILSP3		;EXTENSION MARK
	CAIN	CH,"["
	JRST	FILSP4		;PROJ PROG PAIR
	PUSHJ	P,CKSYM		;SYMBOL CHARACTER?
	TRZA	B,777700	;YES. CKSYM LEAVES CHARACTER IN B AND CH.
DEFINE	FERRS(AA,EE,%BB,%CC,%DD)<
	JRST	%BB
	JRST	%CC
%BB:	SKIPE	SFPARS
	JRST	%DD
	ERROR	AA
%DD:	PUSH	P,[POINT 7,EE]
	PUSHJ	P,STRGPT
	JRST	TEC2
%CC:
>
	FERRS	E.IFN,<[ASCIZ /?Illegal character in file specification
/]>
	TRC	B,40		;CONVERT TO SIXBIT.
	ROT	B,-6
	TLNN	E,770000	;SIX CHARACTERS YET?
	ROTC	B,6		;NO. PACK IT INTO E
	TLO	FF,FILWD	;YES.
	JRST	FILSPL

;GET A CHAR FOR FILEPSPECIFICATION
;IGNORE SPACE, TAB, LF, VT, FF, CR; CONVERT LC TO UC

FILCHR:	SKIPE	SFPARS
	JRST	SFPCHG
	PUSHJ	P,SKRCH
	ERROR	E.UFS
	JRST	FILCHC
SFPCHG:	ILDB	CH,SFPART
FILCHC:	AOS	FILSCT
	CAIL	CH,141
	CAILE	CH,172
	JRST	.+2
	TRZ	CH,40
	CAIN	CH,40
	JRST	FILCHR
U FILSCT,1
U FILNPT,1
	CAIL	CH,11
	CAILE	CH,15
	POPJ	P,
	JRST	FILCHR
;END OF DESIGNATOR.  STORE FILE NAME OR EXTENSION AND RETURN
;THROW IN DSK IF NEEDED

;FILSP2 INSERTED 1 INSTRUCTION	[ED#114]
FILSP2:	PUSHJ	P,ALTEO		;[EDIT#114]
	PUSHJ	P,FILLSH
FILSP7:	HLRZ	E,FILNAM+1	;GET EXT
IFN SFDCNT,<
	CAIE	E,'SFD'	;SFD ?
	JRST	FIL$05	;NOPE
	SKIPE	PRTIND	;SKIP IF NONE YET
	JRST	FIL$05
	MOVEI	B,PROTSF	;GET DEFAULT
	MOVEM	B,FILPRT	;SET IT
>
FIL$05:	CAIE	E,'BAS'	;BASIC ?
	JRST	FILS7X		;NO
	MOVE	E,SWITC		;GET SWITCHES
	TLZN	E,YBASIC	;SKIP IF /YBASIC
	TLO	E,XBASIC	;SET BASIC
	MOVEM	E,SWITC		;SE BACK
FILS7X:	MOVE	E,SWITC
	TLZ	E,YBASIC
	MOVEM	E,SWITC


IFN NOFMES,<
	PUSH	P,A
	SKIPE	SFPARS
	JRST	SKIFMS
	MOVE	A,FILNAM
	CAMN	A,[SIXBIT /TECO/]
	JRST	FUNMSG
	CAME	A,[SIXBIT /TECOX/]
	JRST	SKIFMS
FUNMSG:	JSP	A,CONMES
	ASCIZ	/Hey, you better not screw this file up.
Its' dear to my heart!!!
/
SKIFMS:	POP	P,A
>
	MOVSI	E,(SIXBIT /DSK/)
	SKIPN	FILDEV
	MOVEM	E,FILDEV
;	EDIT [153]
IFN SFDCNT,<
	MOVEM	E,PATH	;SET UP FOR PATH
	MOVE	E,[XWD 4,PATH]	;GET POINTER
	PATH.	E,		;DO IT
	JRST	SKIPTJ	;JRST IF FAILED
	MOVE	E,PATH+1	;GET STATUS BITS
	MOVE	B,PATH+2	;
	TRNE	E,IGNPPN	;WILL USER'S PPN BE IGNORED ?
	MOVEM	B,FILPPN	;YEAH
	TRNE	E,IGNPPN
	MOVEM	E,FILNAM+3
U PATH,4
>
IGNPPN=40			;USER PPN WILL BE IGNORED
SKIPTJ:	MOVE	E,FILDEV
	PUSHJ	P,DEVCHK	;GET DEVICE CHAR
	MOVEM	E,FILDVC
U FILDVC,1
IFN SFDCNT,<
	MOVEI	B,@FILSFP
	SKIPN	B
	POPJ	P,
U FILSFP,1
	SETOM	SFDCNT+4(B)	;SET HAS SFD FLAG
	PUSH	P,FILPPN
	POP	P,2(B)	;MAKE PROPER SFD PPN
	TLNN	E,200000	;SKIP IF IS A DISK UNIT
	JRST	FIL$06
	SKIPN	FILNAM+3	;SKIP IF PPN SPECIFIED
	SKIPE	SFDPRE	;SKIP IF PRESENT
	POPJ	P,
	HRL	E,JOBN	;GET JOB NUMBER
	HRRI	E,-1	;GET -1
	MOVEM	E,(B)	;SET BACK
	HRLI	E,SFDCNT+4	;GET SIZE
	HRRI	E,(B)	;GET ADDRESS
	PATH.	E,	;DO IT
	JRST	FIL$07	;NO PATHS
	SETZM	(B)	;FIX AARGS
	SETZM	1(B)	;
	MOVE	E,2(B)	;GET PPN
	MOVEM	E,FILPPN
	MOVEM	E,FILNAM+3
	POPJ	P,
FIL$07:	SETZM	(B)
	SETZM	1(B)
	MOVE	E,FILPPN
	MOVEM	E,2(B)
	SETZM	3(B)
	POPJ	P,
FIL$06:	SETZM	SFDCNT+4(B)	;SET NO SFDS
	SKIPE	3(B)	;SKIP IF NOT PATH
	FERRS	E.SFD,<[ASCIZ /?Device does not support SFDs
/]>
>
	POPJ	P,


;ROUTINE TO LEFT JUSTIFY E AND STORE IN FILE NAME OR FILE EXTENSION.
;CALL	MOVE E,SIXBIT NAME RIGHT JUSTIFIED
;	SET FILWD OR FEXTF FLAG
;	PUSHJ P,FILLSH
;	RETURN
;FROM FILSP1,FILSP3,FILSP4

FILLSH:	SKIPE	E		;NULL NAME?
	TLNE	E,770000	;NO. LEFT JUSTIFIED?
	JRST	FILLS1		;YES.
	LSH	E,6		;NO.
	JRST	.-3
FILLS1:	TLZN	FF,FEXTF	;EXTENSION?
	JRST	FIL$01		;NO.
	SKIPN	SFPARI		;SKIP IF HAVE ONE
	HLLZM	E,FILNAM+1	;YES. STORE IT.
	AOS	SFPARI
	TLZ	FF,FILWD
FIL$01:	TLZE	FF,FILWD	;FILE NAME?
	MOVEM	E,FILNAM	;YES. STORE IT.
	POPJ	P,		;NO. RETURN.
;DEVICE NAME

FILSP1:	TLZ	FF,FILWD+FEXTF	;RESET THESE FLAGS FOR DEVICE LOAD
	PUSHJ	P,FILLSH	;LEFT JUSTIFY IT.
	MOVEM	E,FILDEV
	SETOM	SFPADV
FILS1A:	MOVEI	E,0
	JRST	FILSPL

;FILE NAME EXTENSION FOLLOWS

FILSP3:	PUSHJ	P,FILLSH	;STORE FILE NAME.
	TLO	FF,FEXTF	;GET EXTENSION.
	JRST	FILS1A

;PROJECT-PROGRAMMER PAIR

FILSP4:	PUSHJ	P,FILLSH	;STORE NAME OR EXTENSION.
	MOVEI	B,","		;SCAN FOR ,
	PUSHJ	P,FILSPP
FILSP5:	HRLZM	E,FILNAM+3	;STORE PROJECT NUMBER.
	MOVEI	B,"]"		;SCAN FOR ]
	PUSHJ	P,FILSPP
FILSP6:	HRRM	E,FILNAM+3
	MOVE	E,FILNAM+3	;SAVE IN CASE DOING EB
	MOVEM	E,FILPPN
IFE SFDCNT,<
	CAIN	CH,ALT
	JRST	FILPP2
>
IFN SFDCNT,<
	CAIN	CH,ALT
	JRST	FILS1D
	CAIN	CH,","
	JRST	FILS1C	;BR IF SFD TYPED
FILS1D:	MOVEI	E,@FILSFP
	SKIPN	E
	JRST	FILS1E
	MOVE	B,FILPPN
	MOVEM	B,2(E)
	MOVE	B,USRPPN
	SKIPN	2(E)
	MOVEM	B,2(E)
FILS1E:	CAIN	CH,ALT
	JRST	FILPP2
>
	JRST	FILS1A
IFN SFDCNT,<

;SFD STRING PARSE

FILS1C:	MOVEI	E,@FILSFP	;GET POINTER
	SKIPN	E
	ERROR	E.SFE
	ADDI	E,2
	MOVE	B,FILPPN	;GET PPN
	MOVEM	B,(E)	;SET
	MOVE	B,USRPPN	;GET USER'S
	SKIPN	(E)	;SKIP IF ONE
	MOVEM	B,0(E)
	AOS	E	;SKIP
	PUSH	P,[EXP SFDCNT]	;GET COUNT
FILSLP:	PUSH	P,[POINT 6,0]	;GET POINTER BASE
	ADDM	E,(P)	;ADD ADDRESS
	SETZM	(E)	;INITIALIZE
	PUSH	P,[EXP 6]	;GET SFD NAME COUNT
FILSL2:	PUSHJ	P,FILCHR	;GET CHAR
	CAIN	CH,ALT	;ENT OF STRING ?
	JRST	FIEN2	;YEAH
	CAIN	CH,"]"	;END OF SFDS ?
	JRST	FIEN1	;YES
	CAIN	CH,","	;END OF THIS SFD ?
	JRST	FILENL	;YES
	PUSHJ	P,CKSYM	;CHECK SYMBOL
	TRZA	B,777700
	FERRS	E.ISN,<[ASCIZ /?Illegal character in SFD name
/]>
	SUBI	CH,40	;TO SIXBIT
	SOSL	(P)	;SKIP IF MORE THAN 6
	IDPB	CH,-1(P)	;DEPOSIT
	JRST	FILSL2	;LOOP
FILENL:	SUB	P,[EXP 2000002]	;POP PTR AND COUNT
	AOS	E	;INCTR POINTER
	SOSLE	(P)	;SKIP IF TOO MANY SFDS
	JRST	FILSLP	;LOOP
	FERRS	E.TMS,<[ASCIZ /?Too many SFD names Specified
/]>
FIEN1:	SETOM	SFDPRE
	AOS	E	;NEXT
	SETZM	(E)	;MARK END
	SUB	P,[EXP 3000003]	;POP STACK
	SETZM	E	;SET NULL NAME
	JRST	FILSPL	;NEW FILE FIELD
FIEN2:	SETOM	SFDPRE
	AOS	E	;NEXT
	SETZM	(E)	;MARK END
	SUB	P,[EXP 3000003]	;POP STACK
>
FILPP2:	SETZM	E	;SET NULL NAME
	JRST	FILSP2	;END OF STRING

;PROTECTION PARSE

FILPRP:	PUSHJ	P,FILLSH
	MOVEI	E,0
FILPR1:	PUSHJ	P,FILCHR
	CAIN	CH,ALT	;END ?
	JRST	FILPR2	;YES
	CAIN	CH,76	;END OF PRT ?
	JRST	FILPR3
	XORI	CH,60
	CAIL	CH,10
	FERRS	E.PRT,<[ASCIZ /?Illegal character in Protection Code
/]>
	LSH	E,3
	ADDI	E,(CH)
	JRST	FILPR1
FILPR2:	MOVEM	E,FILPRT
	SETOM	PRTIND
	JRST	FILPP2
FILPR3:	MOVEM	E,FILPRT
	SETOM	PRTIND
	JRST	FILS1A
U FILPRT,1

FILSPP:	MOVEI	E,0
FILS4L:	PUSHJ	P,FILCHR	;GET NEXT COMMAND CHARACTER.
	CAIN	CH,(B)		;DELIMITER?
	POPJ	P,		;YES
IFN SFDCNT,<
	CAIN	CH,","	;SFD ?
	POPJ	P,	;YES
>
	CAIE	CH,ALT	;ALT ?
	JRST	FILS5L	;NO
	CAIN	B,"]"	;THIS PROJECT ?
	POPJ	P,	;YES
FILS5L:	PUSHJ	P,FILSOC
	JRST	FILS4L


FILSOC:	XORI	CH,60
	CAIL	CH,10		;OCTAL DIGIT?
	FERRS	E.PPN,<[ASCIZ /?Illegal character in Project-Programmer Number
/]>
	LSH	E,3
	ADDI	E,(CH)
	POPJ	P,
;SWITCH

FILSWT:	SKIPE	SFNOSW
U	SFNOSW,1
	JRST	FILSWX
	PUSHJ	P,FILLSH	;STORE FILNAME
FILSW0:	MOVEI	E,0		;INIT CHAR CTR
	MOVE	AA,[POINT 6,SWITHL]	;INIT SWITCH NAME HOLD
	SETZM	SWITHL
FILSW1:	PUSHJ	P,FILCHR	;GET SWITCH CHAR
	MOVEI	B,(CH)		;CK IF CHAR IS ALPHA
	PUSHJ	P,CKSYM2
	JRST	FILSW2		;YES
	CAIE	CH,ALT		;NO, IS IT ALTMODE?
	CAIN	CH,"/"		;OR ANOTHER SWITCH?
	JRST	FILSW4		;YES, OK
FILSWX:	ERROR	E.IOS
FILSW4:	PUSH	P,CH		;SAVE TERMINATOR
	MOVEI	E,SWITAB	;INIT SWITCH TABLE INDEX
	MOVE	B,SWITHL	;GET SWITCH NAME
FILSW5:	SKIPN	(E)		;END OF SWITAB?
	ERROR	E.UIS
	CAME	B,(E)		;GIVEN SWITCH MATCH TABLE ENTRY?
	AOJA	E,FILSW5	;NO, INCR. INDEX & GO FOR NEXT
	SUBI	E,SWITAB	;YES, GET REL POSITION OF MATCH
	MOVNS	E
	MOVSI	B,400000	;SET CORRESP BIT OF SWITCH HOLD
	LSH	B,(E)
	IORM	B,SWITC
	POP	P,CH		;GET BACK TERMINATOR
	CAIN	CH,"/"		;SLASH?
	JRST	FILSW0		;YES, GET NEXT SWITCH
	JRST	FILSP7		;NO, MUST BE ALTMODE

FILSW2:	CAIL	E,6		;CTR < 6?
	JRST	FILSW1		;NO, IGNORE CHAR
	SUBI	CH,40		;CONVERT TO SIXBIT
	IDPB	CH,AA		;STORE CHAR
	AOJA	E,FILSW1	;INC CTR & GO FOR NEXT CHAR
;FILE SELECTION COMMAND SWITCH TABLE

SWITAB:	SIXBIT	/GENLSN/	;GENERATE LINE SEQ#'S ON OUTPUT
	SIXBIT	/SUPLSN/	;SUPPRESS LSN (INPUT OR OUTPUT)
	SIXBIT	/XBASIC/	;IT'S BASIC FOLKS !
	SIXBIT	/YBASIC/
	0

U SWITHL,1			;SWITCH CHAR HOLD
U INSWIT,1			;INPUT SWITCHES
U OUTSWT,1			;OUTPUT SWITCHES
U LSNCTR,1			;LSN GENERATION CTR

;SWITCH BITS -- LEFT HALF

GENLSN=1B18
SUPLSN=1B19
XBASIC=1B20
YBASIC=1B21


;Y	RENDER THE BUFFER EMPTY.  READ INTO THE BUFFER UNTIL
;	(A)  A FORM FEED CHARACTER IS READ, OR
;	(B)  THE BUFFER IS WITHIN ONE THIRD OR
;128 CHARACTERS OF CAPACITY AND A LINE FEED IS READ, OR
;	(C)  AN END OF FILE IS READ, OR
;	(D)  THE BUFFER IS COMPLETELY FULL.
;THE FORM FEED (IF PRESENT) DOES NOT ENTER THE BUFFER.

YANK:	MOVE	A,[ASCIZ /"Y" /]	;[BJ 4-9-74]INSERT 2 INSTRUCTIONS TO NOTIFY USER OF Y
	PUSHJ	P,CHKYLA
	MOVE	B,BEG	;GET BEGINING
	MOVE	C,Z	;AND END
	PUSH	P,[-3]	;[CJJ-26] CAN'T USE HALF WORDS
	ADDM	B,(P)	;[CJJ-26] CAN'T USE HALF WORDS
	SUB	C,(P)	;[CJJ-26] CAN'T USE HALF WORDS
	SUB	P,[1000001]	;[CJJ-26] CAN'T USE HALF WORDS
	ADD	B,C	;ADD TO B
	SKIPE	FASTEC
	JRST	YANK1
	PUSHJ	P,X3	;TO Q
	MOVEM	B,QTEXTY	;SAVE IT IN &Y

YANK1:	MOVE	OU,BEG
	MOVEM	OU,PT		;PT:=BEG

YANK2:	TLNE	FF,FINF		;[140] IF FINISHED
	JRST	YANK51		;[140] THEN OUT
	TRZ	FF,FORM		;RESET THE YANK,APPEND FORM FEED FLAG
	TLNN	FF,UREAD	;ERROR IF INPUT NOT SPECIFIED
	ERROR	E.NFI

;MAINTAIN AT LEAST A MINIMUM SIZE BUFFER OF 4000 
;CHARACTERS AT ALL TIMES, WHEN TECO ASKS FOR INPUT FROM
;ANYTHING BUT THE CONSOLE.

	MOVE	C,PT		;GET .
	MOVEM	C,Z		;TELL NROOM IT'S AN EXPAND
	SUBM	OU,C		;BUT EXPAND WITH REAL Z IN MIND
	ADDI	C,^D4000	;NEED 4000 ABOVE Z
	PUSHJ	P,NROOM
YANK6:	ADD	OU,RREL		;RELOCATE IN CASE GARBAGE COLLECTION DONE
	MOVE	TT,MEMSIZ	;TOP OF BUFFER
	MOVE	CH,TT
	SUB	TT,OU
	IDIVI	TT,3
	SUBM	CH,TT
	MOVEM	TT,M23		;M23 HAS 2/3 PT
	SUBI	CH,200
	MOVEM	CH,M23PL	;M23PL HAS 200 BELOW TOP
YANK4:	CAMGE	OU,M23		;2/3 FULL YET?
	JRST	YANK3		;NO, KEEP GOING
	CAMG	OU,M23PL	;YES, GETTING NEAR TOP?
	CAIN	CH,12		;NO. LINE FEED?
	JRST	YANK51		;YES. THAT'S ALL.
				;NO. GET MORE.

YANK3:	SOSLE	IBUF+2		;IS DEVICE BUFFER EMPTY?
	JRST	YANK5		;NO.
	INPUT	INCHN,0		;YES. FILL IT.
	STATZ	INCHN,740000	;ERROR?
	JRST	INERR		;YES.
	STATO	INCHN,20000	;NO. END OF FILE?
	JRST	YANK5		;NO.
	TLO	FF,FINF
	JRST	YANK51		;CLEAR BUFFER AND RETURN.
YANK5:	ILDB	CH,IBUF+1	;CH:=NEXT CHARACTER.
YANK52:	JUMPE	CH,YANK3	;IF NULL, IGNORE IT.
	MOVE	T,@IBUF+1
	TRNE	T,1		;SEQUENCE NUMBER?
	JRST	YNKSEQ		;YES
YANK50:	PUSHJ	P,PUT		;NO. PUT CHARACTER IN DATA BUFFER.
	CAIE	CH,14		;FORM FEED?
	AOJA	OU,YANK4	;NO. UPDATE DATA BUFFER PTR AND CHECK FOR OVERFLOW.
	TRO	FF,FORM		;YANK AND/OR APPEND TERMINATED ON A LFORM FEED
YANK51:	MOVEM	OU,Z		;YES. SET END OF DATA BUFFER AND RETURN
	POPJ	P,

YNKSEQ:	MOVE	T,INSWIT	;SUPPRESS SEQ# FLAG ON?
	TLNE	T,SUPLSN
	JRST	YNKSEZ		;YES, STRIP THEM OFF AS IN DAYS OF YORE
;YNKSEQ+3 REPLACE 2 INSTRUCTIONS WITH THE FOLLOWING 	[ED#119]
	TRON	FF,SEQF		;SET SEQ FILE AND	[ED#119]
				;JRST IF ALREADY SEEN	[ED#119]
	TLNE	T,GENLSN	;DOES USER WANT LSN'S?	[ED#119]
	JRST	YANK50		;IF SO DON'T BOTHER HIM	[ED#119]
;HERE IF NO LSN SWITCH AND SEQUENCED FILE
;TELL USER WHAT'S ABOUT TO HAPPEN			[ED#119]
	MOVE	T,CH		;SAVE THE CHARACTER	[ED#119]
	JSP	A,CONMES	;OUTPUT THE MESSAGE	[ED#119]
	ASCIZ	/%Line number detected -- Line Sequence Numbers will be generated
/
	MOVE	CH,T		;RESTORE CHARACTER	[ED#119]
	JRST	YANK50		;			[ED#119]
YNKSEZ:	MOVE	T,INSWIT		;GET SWITCHES
	TLNN	T,XBASIC		;BASIC ?
	JRST	YNKSZW			;NO
YNKSZX:	MOVEI	T,4		;CTR FOR REST OF SEQ #
YNKSZY:	IBP	IBUF+1		;MOVE PTR OVER THIS CHAR
	SOS	IBUF+2		;& CTR TOO
	SOJG	T,.-2
	JRST	YANK3
YNKSZW:	MOVEI	T,5
	CAIE	CH," "		;PAGE MARK ?
	JRST	YNKSZY		;SKIP NUMBER
	MOVEI	T,6		;SKIP PAGE MARK
	JRST	YNKSZY		;

INERR:	GETSTS	INCHN,B		;SAVE ERROR FLAGS
	RELEAS	INCHN,0
	TLZ	FF,UREAD
	EE2+ERROR E.INP



;A   APPEND TO THE END OF THE BUFFER FROM THE SELECTED INPUT
;	TERMINATING THE READ IN THE SAME MANNER AS Y.  THE POINTER
;	IS NOT MOVED BY A.

APPEND:	MOVE	OU,Z		;STORE DATA AT END OF BUFFER.
	PUSHJ	P,YANK2
	JRST	RET
;^ITEXT$	INSERTS AT THE CURRENT POINTER LOCATION THE ^I (TAB)
;	AND THE TEXT FOLLOWING THE ^I UP TO BUT NOT INCLUDING THE
;	ALT MODE.  THE POINTER IS PUT TO THE RIGHT OF THE INSERTED
;	MATERIAL.

TAB:	TRZ	FF,ARG		;NO ARGUMENT WANTED
	PUSHJ	P,TAB2		;INSERT TAB
IFN VC,<TLO	FF,TABSRT>	;ADJUST VVAL

;ITEXT$	INSERT, AT THE CURRENT POINTER LOCATION, THE TEXT FOLLOWING
;	THE I UP TO BUT NOT INCLUDING THE FIRST ALT. MODE.  THE
;	POINTER IS PUT TO THE RIGHT OF THE INSERTED MATERIAL.

INSERT:	MOVE	C,PT	;GET POINTER
	SUB	C,BEG	;GET OFFSET FROM BUFFER START
	MOVEM	C,PTSAVE	;SAVE IT
	TRNE	FF,ARG		;IS THERE AN ARGUMENT?
	JRST	INS1A		;YES. NI COMMAND.
	MOVEI	CH,ALT		;NORMAL TERMINATOR
	TRZN	FF,SLSL		;DID @ PRECEED I?
	JRST	INSERA		;NO, TERMINATOR = ALTMODE
	PUSHJ	P,SKRCH		;YES. CH:=USER SELECTED TERMINATOR.
	ERROR	E.UIN
INSERA:	MOVEI	B,(CH)		;B=INSERTION TERMINATOR.
	PUSH	P,CPTR		;SAVE CURRENT POSITION IN CMD STRING
	PUSH	P,COMCNT
	MOVEI	C,0		;COUNT # CHARACTERS TO INSERT IN C AND
				;MOVE CPTR TO END OF STRING.
INSER0:	PUSHJ	P,SKRCH		;GET NEXT CHARACTER
	ERROR	E.UIN
	CAIN	CH,(B)		;IS IT THE TERMINATOR?
	JRST	INSER2		;YES, END OF 1ST PASS
	CHKEO	EO21,INSER1	;IF EO=1, CTRL-CHARS ARE JUST TEXT
	MOVEI	T,IN1TAB	;CK FOR ^V, ^W, ^R, ^T, ^^
	TRNE	F2,TXTCTL	;^T FLAG ON?
	MOVEI	T,IN2TAB	;YES, USE RESTRICTED TABLE
	PUSHJ	P,DISP1
	TRNN	F2,TXTCTL	;IF ^T ON, ALL OTHER CTL-CHARS LEGAL TEXT
	PUSHJ	P,CKNCC		;CHECK FOR OTHER CTRL-CHARS (THEY ARE ILLEGAL)
INSER1:	AOJA	C,INSER0	;COUNT TEXT CHARACTERS
INSER2:	MOVEM	C,VVAL		;SAVE LENGTH OF STRING
IFN VC,<
	TLZE	FF,TABSRT	;TAB INSERTED?
	AOS	VVAL		;YES, COUNT IT
	>
	TRZ	F2,TXTCTL	;REFRESH ^T FLAG
	TRNE	FF,FSRCH	;DOING FS OR FN?
	JRST	SERCHJ		;YES
	POP	P,COMCNT	;RESET TO BEGINNING OF INSERT TEXT
	POP	P,CPTR
	PUSHJ	P,NROOM		;YES. MOVE FROM PT THROUGH Z UP C POSITIONS.
;MOVE INSERTION INTO DATA BUFFER

INS1B:	MOVE	OU,PT
INS1C:	PUSHJ	P,GCH		;CH:=CHARACTER FROM COMMAND STRING.
INS1F:	CAIN	CH,(B)		;IS IT THE TERMINATOR?
	JRST	TABRT2	;EXIT
	CHKEO	EO21,INS1D	;IF EO=1, THERE ARE NO CTL-CHAR. COMMANDS
	MOVEI	T,INSTAB	;CK FOR CONTROL CHARACTERS
	TRNE	F2,TXTCTL	;^T FLAG ON?
	MOVEI	T,INTTAB	;YES, ONLY ^T AND ^R ARE SPECIAL
	PUSHJ	P,DISP1
INS1E:	PUSHJ	P,CASE		;CONVERT UC TO LC IF FLAGS WARRANT
INS1D:	PUSHJ	P,PUT		;NO. STORE CHARACTER IN DATA BUFFER TO RIGHT OF PT.
	AOS	PT		;PT:=PT+1
	JRST	INS1B		;LOOP
;DISPATCH TABLE FOR INSERT STRING CONTROL CHARACTERS (COUNT PASS)

IN1TAB:	XWD	INSER0,26	;^V
	XWD	INSER0,27	;^W
	XWD	INSER0,36	;^^
IN2TAB:	XWD	INSER4,24	;^T
	XWD	INSER3,22	;^R
	XWD	0,0		;END OF LIST

;GET CHARACTER AFTER ^R

INSER3:	PUSHJ	P,SKRCH		;DON'T COUNT ^R & DON'T DO CHECKS ON CHAR AFTER IT
	ERROR	E.UIN
	JRST	INSER1

;CHANGE NO-CONTROL-COMMANDS FLAG

INSER4:	TRC	F2,TXTCTL
	JRST	INSER0		;DON'T COUNT ^T
;DISPATCH TABLE FOR INSERT STRING CONTROL CHARACTERS (INSERT PASS)

INSTAB:	XWD	INSLOW,26	;^V
	XWD	INSSTD,27	;^W
	XWD	INSSPC,36	;^^
INTTAB:	XWD	INSMAC,24	;^T
	XWD	INSIGR,22	;^R
	XWD	0,0		;END OF LIST

;^V CAUSES THE NEXT CHARACTER TO BE CONVERTED TO LOWER CASE (IF UPPER CASE)
;^V^V SETS LOWER CASE MODE UNTIL THE END OF THE TEXT STRING (OR FURTHER NOTICE)

INSLOW:	PUSHJ	P,C.V		;SET ^V FLAGS
	JRST	INS1C		;CONTINUE TO NEXT CHAR.

;^W CAUSES NEXT CHAR. TO BE TAKEN AS IS (STANDARD MODE)
;^W^W SETS STANDARD MODE UNTIL END OF TEXT STRING (OR FURTHER NOTICE)

INSSTD:	PUSHJ	P,C.W		;SET ^W FLAGS
	JRST	INS1C		;CONTINUE TO NEXT CHAR.

;^R CAUSES NEXT CHAR. TO BE TAKEN AS TEXT
;EVEN IF IT IS A CONTROL CHAR. OR THE TEXT TERMINATOR

INSIGR:	PUSHJ	P,GCH		;GET NEXT CHAR.
	JRST	INS1E		;TREAT AS TEXT

;^^ -- IF NEXT CHAR IS @,[,\,],^, OR _, CONVERT IT TO LC RANGE

INSSPC:	PUSHJ	P,GCH		;GET NEXT CHAR
	PUSHJ	P,CVTSPC	;CONVERT IF WARRANTED
	JRST	INS1F

;CHANGE NO-CONTROL-COMMANDS MODE

INSMAC:	TRC	F2,TXTCTL	;COMPLEMENT ^T FLAG
	JRST	INS1C		;GO ON TO NEXT CHAR
;SET ^V FLAGS

C.V:	TRON	F2,CTLV		;SET ^V FLAG -- WAS IT ON BEFORE?
	POPJ	P,		;NO
	TRZ	F2,CTLV+CTLWW	;YES, SET ^V^V FLAG & CLR OTHERS
	TRO	F2,CTLVV
	POPJ	P,

;SET ^W FLAGS

C.W:	TRON	F2,CTLW		;SET ^W FLAG -- WAS IT ON BEFORE?
	POPJ	P,		;NO
	TRZ	F2,CTLW+CTLVV	;YES, SET ^W^W FLAG & CLR OTHERS
	TRO	F2,CTLWW
	POPJ	P,

;CONVERT ALPHABETIC CH TO UPPER OR LOWER CASE ACCORDING TO CASE CONTROL FLAGS

CASE:	CAIL	CH,"A"		;IS CHAR IN UPPER CASE RANGE?
	CAILE	CH,"Z"
	CAIL	CH,"A"+40	;IS IT IN LOWER CASE RANGE?
	CAILE	CH,"Z"+40
	JRST	CASE3		;NO
CASE2:	TRNE	F2,LCASE	;PREVAILING LOWER CASE?
	TRO	CH,40		;YES, CONVERT TO LOWER
	TRNE	F2,UCASE	;PREVAILING UPPER CASE?
	TRZ	CH,40		;YES, CONVERT TO UPPER
	TRNE	F2,CTLVV	;DOUBLE ^V ON?
	TRO	CH,40		;YES, CONVERT TO LC
	TRNE	F2,CTLWW	;DOUBLE ^W ON?
	TRZ	CH,40		;YES, CONVERT TO UC
	TRZE	F2,CTLV		;SINGLE ^V ON?
	TRO	CH,40		;YES, CONVERT TO LC
	TRZE	F2,CTLW		;SINGLE ^W ON?
	TRZ	CH,40		;YES, CONVERT TO UC
CASE3:	TRZ	F2,CTLV+CTLW	;CLR IN CASE NO CONVERSION
	POPJ	P,

;CONVERT @, [, \, ], ^, AND _ TO THE EQUIVALENT LC CHARACTER

CVTSPC:	CAIL	CH,"["
	CAILE	CH,"_"
	CAIN	CH,"@"
	TRO	CH,40		;CONVERT TO LOWER CASE RANGE
	POPJ	P,
;CHECK FOR NON-CONTROL CHARACTERS
;IF CH<10, OR 15<CH<33, OR 33<CH<40, CH IS AN ILLEGAL CTRL-CHAR

CKNCC:	CAIGE	CH,40
	CAIG	CH,15
	CAIGE	CH,10
	CAIN	CH,33
	POPJ	P,		;IT IS 10-15 OR 33 OR 40+
	MOVEI	B,(CH)		;SAVE CHAR FOR ERROR MSG ROUTINE
	ERROR	E.ICT
;NI	INSERT AT THE POINTER A CHARACTER WHOSE 7-BIT ASCII CODE IS N
;	(BASE 10).  THE POINTER IS MOVED TO THE RIGHT OF THE NEW CHARACTER.

INS1A:	CHKEO	EO21,INS1X	;IF EO=1 SKIP NEXT STUFF
	PUSHJ	P,SKRCH		;GET CHAR AFTER I
	ERROR	E.NAI
	CAIE	CH,ALT		;IT HAD BETTER BE AN ALTMODE
	ERROR	E.NAI
INS1X:	MOVE	CH,PT
	SUB	CH,BEG
	MOVEM	CH,PTSAVE
	PUSH	P,[EXP TABRT2]
	MOVE	CH,NUM		;CH:=NUM

;INSERT CH IN DATA BUFFER AT PT

TAB2:	MOVEI	C,1		;MOVE FROM PT THROUGH Z UP 1 POSITION.
	PUSHJ	P,NROOMC
	AOS	OU,PT		;PT:=PT+1
	SOJA	OU,PUT		;STORE CH AT PT-1

;NBACKSLASH	INSERT AT THE CURRENT POINTER LOCATION THE ASCII NUMBERS
;	EQUAL TO N.

BAKSL1:	MOVE	C,PT	;GET POINTER
	SUB	C,BEG
	MOVEM	C,PTSAVE
	MOVE	T,[XWD 700,STAB-1]
	MOVEI	C,0		;COUNT # DIGITS IN C.
	MOVEI	A,BAKSL4	;SET DPT TO RETURN TO BAKSL4
	PUSHJ	P,DPT		;CONVERT C(B) TO ASCII AND STORE STRING IN STAB.
	MOVE	B,[XWD 700,STAB-1]
	PUSHJ	P,NROOMC	;MOVE FROM PT THROUGH Z UP C POSITIONS.
BAKSL5:	MOVE	OU,PT		;POSITION TO PUT CHAR IN
	ILDB	CH,B		;GET NEXT CHAR OF THE #
	PUSHJ	P,PUT		;STORE THE CHAR
	AOS	PT		;MOVE THE POINTER
	SOJG	C,BAKSL5	;DECREMENT THE CHAR CTR
TABRET:	PUSH	P,[EXP RET]
TABRT2:	MOVE	C,PT	;GET PTR
	MOVE	B,PTSAVE	;GET BEFORE
	ADD	B,BEG	;GET CURRENT
	PUSH	P,[-3]	;[CJJ-26] CAN'T USE HALF WORDS
	ADDM	B,(P)	;[CJJ-26] CAN'T USE HALF WORDS
	SUB	C,(P)	;[CJJ-26] CAN'T USE HALF WORDS
	SUB	P,[1000001]	;[CJJ-26] CAN'T USE HALF WORDS
	ADD	B,C
	SKIPE	FASTEC
	POPJ	P,
	PUSHJ	P,X3
	MOVEM	B,QTEXTR
	POPJ	P,

BAKSL4:	IDPB	CH,T		;STORE DIGIT IN STAB
	AOJA	C,CPOPJ		;C:=C+1. RETURNS TO DPT CALL + 1 ON COMPLETION.

;@ COMMAND MODIFIER

ATSIGN:	TROA	FF,SLSL		;SET @ SEEN FLAG

;COLON COMMAND MODIFIER

COLON:	TRO	FF,COLONF	;SET : SEEN FLAG
	JRST	RET
;NT	TYPE OUT THE STRING OF CHARACTERS STARTING AT THE RIGHT OF THE
;	POINTER AND CONTINUING THROUGH THE NTH LINE FEED ENCOUNTERED.
;	IF N IS NEGATIVE, N LINES TO THE LEFT OF THE POINTER ARE TYPED.
;T	SAME AS 1T.
;I,JT	TYPE OUT THE (I+1)TH THROUGH THE JTH CHARACTER OF THE BUFFER.

TYPE:
	SKIPN	SILENT	;SKIP IF /Q GIVEN
	JRST	TYPE$1
	SKIPE	CHKEXE	;SKIP IF NOT NOW CHECKPOINT EXEC'ING
	POPJ	P,	;RETURN
	SETZM	SILENT
TYPE$1:	TRNE	FF,ARG2
	JRST	TYPE4
	SKIPN	TECLNI
	JRST	TYPE4
U	NUMFLG,1
U	NUMFLI,1
	SETZM	NUMFLG
	MOVM	CH,B	;GET MAG
	CAIG	CH,1	;MORE THAN 5 LINES
	JRST	TYPE4
	SETOM	NUMFLI
TYPE4:	MOVEI	D,TYO		;D:=ADDRESS OF OUTPUT ROUTINE.

TYPE0:	PUSHJ	P,GETARG	;C:=FIRST STRING ARGUMENT ADDRESS.
				;B:=SECOND STRING ARGUMENT ADDRESS.

TYPE1:	PUSHJ	P,CHK1		;C:=MAX(C(C),BEG), B:=MIN(C(B),Z)
	MOVE	I,C		;START GETTING CHARACTERS AT C.
	CAML	I,Z	;BUFFER END ?
	JRST	TYPE3	;YES
	CAMG	I,BEG	;IS IT START ?
	JRST	TYPE3X	;YES
	MOVE	TT,I		;NO. GET NEXT CHAR
	SOS	TT	;DECR POINTER
	IDIVI	TT,5		;THIS IS A COPY OF GETINC
	HLL	TT,BTAB(TT1)	;..
	LDB	CH,TT		;COPIED TO SPEED IT UP
	PUSHJ	P,CKEOL	;CHECK FOR LINE ALIGNMENT
	JRST	TYPE3Y	;BR IF NOT
TYPE3X:	CAML	I,B	;DONE ?
	JRST	TYPE5	;YES
	MOVEI	CH,LF
	PUSHJ	P,TYPLNO
	SKIPA
TYPE3Y:	AOS	NUMFLG
TYPE3:	CAML	I,B		;DONE?
	JRST	TYPE5		;YES.
	MOVE	TT,I		;NO. GET NEXT CHAR
	IDIVI	TT,5		;THIS IS A COPY OF GETINC
	HLL	TT,BTAB(TT1)	;..
	LDB	CH,TT		;COPIED TO SPEED IT UP
	ADDI	I,1		;..
	PUSHJ	P,(D)		;OUTPUT IT
	CAML	I,B	;LAST ?
	JRST	TYPE5	;YES
	PUSHJ	P,TYPLNO
	JRST	TYPE3		;LOOP
TYPE5:	SETZM	NUMFLI
	MOVEI	A,PPA		;IF TYPING OR I,JP DON'T APPEND FF.
	MOVEI	CH,14		;IF PUNCHING, APPEND FF.
	CAIE	A,(D)		;D=PPA?
	POPJ	P,		;NO
	TRNN	FF,PCHFLG	;IS THIS AN "N" SEARCH?
CPPA:	JRST	PPA3		;NO, APPEND A FORM FEED
	TRNN	FF,FORM		;DID LAST Y,A TERMINATE ON A FORM FEED?
	POPJ	P,		;NO,DO NOT APPEND ONE
				;YES, FALL INTO PPA2: TO APPEND FF
PPA3:	PUSHJ	P,PPA2	;SEND IT
	SETZM	PAGFLG	;ZAP FLAG
U PAGFLG,1
	POPJ	P,


TYPLNO:	SKIPN	NUMFLI
	POPJ	P,
	TRNE	FF,SEQF		;NO TYPING IF IS SEQUENCED
	POPJ	P,
	PUSHJ	P,CKEOL
	POPJ	P,
	PUSH	P,B
	MOVEI	A,TYO
	MOVE	B,NUMFLG
	PUSHJ	P,DPT
	MOVEI	CH,11
	PUSHJ	P,TYO
	AOS	NUMFLG
	POP	P,B
	POPJ	P,
;PAGE PROCESSOR

PPA2:	SKIPE	PAGFLG		;SKIP IF LAST WAS NOT A PAGE MARK
	POPJ	P,
PPA:	SETZM	PAGFLG		;ZAP FLAG
	TLNN	FF,UWRITE	;ERROR IF NO OUTPUT FILE
	ERROR	E.NFO
PPA05:	SOSLE	OBF+2		;YES. IS OUTPUT BUFFER FULL?
	JRST	PPA11		;NO.
	OUTPUT	OUTCHN,0	;YES. WRITE IT
	STATZ	OUTCHN,740000	;ERROR?
	JRST	OUTERR		;YES.
	MOVE	A,WRICHR
	TLNE	A,DVMTA
	STATO	OUTCHN,IOEOT	;A MAG TAPE AND AFTER EOT?
	SKIPA			;NO
	JRST	OUTERR
PPA11:	MOVE	A,OUTSWT	;GET OUTPUT SWITCHES
	TRNE	FF,SEQF		;SEQUENCED FILE?
	JRST	PPA02		;YES
	TLNE	A,GENLSN	;NO, OUTPUT GENLSN ON?
	JRST	PPA02		;YES, GENERATE LSN
	TRZ	FF,SEQUIN	;CLR SO AS NOT TO SCREW YANK
PPA01:	IDPB	CH,OBF+1	;CH TO OUTPUT BUFFER.
	POPJ	P,		;RETURN

OUTERR:	GETSTS	OUTCHN,B	;SAVE ERROR FLAGS
	RELEAS	OUTCHN,0	;CLOSE FILE AND RELEASE OUTPUT DEVICE.
	TLZ	FF,UWRITE+UBAK	;CLEAR OUTPUT FILE OPEN INDICATOR.
	EE2+ERROR E.OUT
PPA02:	TRNN	FF,SEQUIN	;WAS LAST CHAR AN EOL OR BEG OF BUFR?
	JRST	PPA03		;NO
	MOVE	A,OBF+2		;ROOM FOR SEQ# IN OUTPUT BUFR?
	CAIG	A,17
	JRST	PPA05		;NO, OUTPUT & COME BACK
	TRZ	FF,SEQUIN
PPA07:	LDB	A,[POINT 6,OBF+1,5]	;GET CURRENT BYTE POSITION IN OUT BUFR
	CAIG	A,1		;AT END OF WORD?
	JRST	PPA06		;YES
	IBP	OBF+1		;NO, PAD OUT WORD WITH NULLS
	SOS	OBF+2
	JRST	PPA07		;TRY AGAIN
PPA06:	TRNE	FF,SEQF		;GENERATE NEW LSN OR OUTPUT EXISTING LSN?
	JRST	PPA04		;OUTPUT EXISTING LSN

;OUTPUT NEW SEQUENCE NUMBERS

	MOVE	A,OUTSWT	;GET SWITCHES
	TLNE	A,XBASIC	;BASIC ?
	JRST	PPAX01		;YES
	CAIE	CH,FFORM		;FORMFEED ?
	JRST	PPAX01			;SEND NUMBER
PPAX02:	SETOM	PAGFLG		;SET PAGE FLAGE
	MOVE	A,[<"     ">B34+1]	;GET BLANKS
	AOS	OBF+1		;INCR POINTER
	MOVEM	A,@OBF+1	;SET THEM
	MOVE	A,[BYTE (7)CR,CR,FFORM,0,0]	;GET SECOND WORD
	AOS	OBF+1	;INCR POINTER
	MOVEM	A,@OBF+1	;SET THEM
	MOVE	A,OBF+2		;GET COUNT
	SUBI	A,11		;FIX COUNT
	MOVEM	A,OBF+2		;BACK
	TRO	FF,SEQUIN	;TELL HIM IT'S SEQ # TIME AGAIN
	POPJ	P,		;BYE
PPAX01:	MOVE	T,LSNCTR	;GET COUNTER
	ADD	T,SEQLNI	;ADD INCR
	MOVEM	T,LSNCTR	;SET BACK
	PUSH	P,[EXP 5]	;GET COUNT
DECPN1:	IDIVI	T,12		;GET A DIGIT
	ADDI	TT,60		;FIX REMAINDER
	LSH	A,-7		;A UP
	LSH	TT,^D36-7	;SHIFT TT UP
	ADD	A,TT		;TO A
	SOSLE	(P)		;SKIP IF DONE
	JRST	DECPN1		;LOOP
	POP	P,T		;POP THE COUNTER
PPA06A:	TRO	A,1			;SET FLAG
	AOS	OBF+1		;& OUTPUT THE 5 DIGITS + BIT 35
	MOVEM	A,@OBF+1
	MOVE	T,OUTSWT	;BASIC ?
	TLNE	T,XBASIC	;?
	JRST	PPA06B		;YES
	MOVEI	A,11		;FOLLOWED BY TAB
PPA06D:	IDPB	A,OBF+1
	MOVE	A,OBF+2		;ADJUST BUFR CTR
	SUBI	A,6
	MOVEM	A,OBF+2
	JRST	PPA03
PPA06B:	CAIE	CH,FFORM	;FF ?
	JRST	PPA06C		;NO
	MOVEI	A,CR		;GET CR
	SKIPN	CRONCE		;SKIP IF LAST WAS A CR
	JRST	PPA06D		;BACK
PPA06C:	MOVE	A,OBF+2	;GET COUNT
	SUBI	A,5	;NO TAB
	MOVEM	A,OBF+2	;SET BACK
PPA03:	CAIE	CH,CR		;THIS A CR ?
	JRST	PPA03X		;NO
	SKIPE	CRONCE		;ONE YET?
U CRONCE,1
	JRST	PPA03Y		;YES SKIP THIS ONE
	AOS	CRONCE		;RECORD THIS ONE
	SKIPA
PPA03X:	SETZM	CRONCE		;ZAP CR IND
	PUSHJ	P,CKEOL		;IS THIS CHAR AN EOL?
	JRST	PPA01		;NO
	TRO	FF,SEQUIN	;YES, SET EOL FLAG
	JRST	PPA01
PPA03Y:	AOS	OBF+2	;FIX SIDE EFFECT
	POPJ	P,		;RETURN

;OUTPUT EXISTING LSN WITH LEADING ZEROS

PPA04:	MOVEI	A,4		;INIT 5 DIGIT CTR
	MOVEM	A,LSNCTR
	MOVE	A,[<"00000">B34]	;INIT LSN ACCUMULATOR
	CAML	I,B			;DONE ?
	JRST	PPA08			;YEP
	CAIL	CH,"0"		;IS CURRENT CHAR A DIGIT?
	CAILE	CH,"9"
	JRST	PPA08		;NO, FILL IN 5 SPACES
	JRST	PPA12
PPA10:	SOSGE	LSNCTR		;DONE 5 DIGITS YET?
	JRST	PPA09		;YES
	ADDI	I,1		;INCREMENT TEXT PTR
PPA12:	LSH	A,7		;PUT DIGIT INTO ACCUMULATOR
	DPB	CH,[POINT 7,A,34]
	CAML	I,B
	JRST	PPA09A
	PUSHJ	P,GET		;GET NEXT BUFFER CHAR
	CAIL	CH,"0"		;IS IT A DIGIT?
	CAILE	CH,"9"
	JRST	PPA09		;NO
	JRST	PPA10		;YES, STORE IT

PPA08:	MOVE	T,OUTSWT	;GET SWITCHES
	TLNE	T,XBASIC	;GET BASIC SWITCH
	JRST	PPA09		;THIS IS FUCKED!!!!
PPAX03:	PUSHJ	P,CKEOL		;EOL ?
	SKIPA			;SKIP IF NOT
	JRST	PPAX02		;OK SEND OUT THE PAGE MARKER NOW
	CAML	I,B		;SKIP IF NOT THE END
	JRST	PPAX02		;PARK IT
	PUSHJ	P,GET		;GET CHAR
	ADDI	I,1		;INCR
	JRST	PPAX03		;LOOP
PPA09A:	MOVEI	CH,CR	;GET A CHARACTER
PPA09:	MOVE	AA,OUTSWT	;GET SWITCHES
	TRO	A,1		;SET BIT 35
	AOS	OBF+1		;& OUTPUT SEQ #
	MOVEM	A,@OBF+1
	MOVE	A,OBF+2		;& ADJUST BUFR CTR
	SUBI	A,5
	MOVEM	A,OBF+2
	ADDI	I,1		;INCR TEXT PTR
	JRST	PPA03		;YES, CONTINUE

;PW	OUTPUT THE ENTIRE BUFFER, FOLLOWED BY A FORM FEED CHARACTER.
;	TO THE SELECTED OUTPUT DEVICE.  BUFFER IS UNCHANGED AND POINTER
;	IS UNMOVED.
;P	IS IDENTICAL TO PWY.
;NP	IS IDENTICAL TO PP...P (P PERFORMED N TIMES).
;I,JP	OUTPUTS (I+1)TH THROUGH JTH CHARACTERS OF BUFFER.  NO FORM
;	FEED IS PUT AT THE END.  BUFFER UNCHANGED; POINTER UNMOVED.

PUNCHA:	MOVEI	D,CPPA		;SELECT PPA FOR OUTPUT INDIRECTLY IN CASE I,JP.
	TRNE	FF,ARG2		;I,JP?
	JRST	TYPE0		;YES. GET STRING ARGUMENTS AND OUTPUT.
	MOVE	E,B		;NO. E:=N
	MOVE	B,CPTR
	ILDB	T,B		;T:=COMMAND CHARACTER FOLLOWING P.
	TRZ	T,40		;FILTER L.C.
	JUMPL	E,CPOPJ		;IF N<0, IGNORE P.
	CHKEO	EO21,PUN1	;OLD STYLE P ALWAYS GIVES FORM FEED
	CAIE	T,"W"		;PW ALWAYS GIVES FORM FEED
	TRO	FF,PCHFLG	;OTHERWISE, FORM GOES OUT ONLY IF FORM CAME IN
PUN1:	PUSHJ	P,PUNCHR	;PUNCH OUT BUFFER
	SKIPE	COMCNT		;IF NO COMMANDS LEFT
	CAIE	T,"W"		;OR COMMAND IS NOT W
	JRST	PUN3		;READ NEXT PAGE
	CAIG	E,1		;ARG DOWN TO 1 YET?
	PUSHJ	P,RCH		;YES, THROW AWAY THE W
PUN4:	MOVE	C,Z
	CAMN	C,BEG		;EMPTY BUFFER?
	TLNN	FF,FINF		;NO. QUIT ON EOF
	SOJG	E,PUN1		;YES. E:=E-1. DONE?
CPOPJ:	POPJ	P,		;YES

PUN2:	MOVE	OU,BEG		;IF NOTHING READ IN, CLEAR THE BUFFER
	MOVEM	OU,PT
	TRZ	FF,FORM		;AND THE FORM FEED FLAG
	JRST	YANK51		;SET Z=BEG & POPJ

PUNCHR:	MOVE	C,BEG		;OUTPUT DATA BUFFER.
	MOVE	B,Z
	MOVEI	D,PPA
	CAME	B,C		;IS PAGE BUFFER EMPTY?
	JRST	PUNCH1		;NO
	TRNE	FF,FORM		;YES, IS THERE A FORM-FEED ON THIS BLANK PAGE?
	JRST	TYPE5		;YES, OUTPUT IT
	POPJ	P,		;NO, DON'T OUTPUT ANYTHING
PUNCH1:	TRO	FF,SEQUIN	;IF SEQUENCED FILE, START PAGE WITH SEQ#
	JRST	TYPE1

PUN3:	TLNE	FF,UREAD	;ANY INPUT FILE?
	TLNE	FF,FINF		;DONT TRY TO READ IF NO DATA LEFT
	JRST	PUN2
	PUSHJ	P,YANK1		;RENEW BUFFER
	JRST	PUN4		;CONTINUE
;NJ	MOVE THE POINTER TO THE RIGHT OF THE NTH CHARACTER IN THE
;	BUFFER. (I.E., GIVE "." THE VALUE N.)
;J	SAME AS 0J.

JMP:	ADD	B,BEG		;PT:=N+BEG
	JRST	JMP1



;NR	SAME AS .-NJ.

REVERS:	PUSHJ	P,CHK2		;MAKE SURE THERE IS AN ARGUMENT
	MOVNS	B		;B:=-C(B)
	SKIPA

;NC	SAME AS .+NJ.  NOTE THAT N MAY BE NEGATIVE.

CHARAC:	PUSHJ	P,CHK2		;MAKE SURE THERE IS AN ARGUMENT
	ADD	B,PT		;B:=PT+C(B)

;IF B LIES BETWEEN BEG AND Z, STORE IT IN PT.

JMP1:	PUSHJ	P,CHK		;IS C(B) WITHIN DATA BUFFER?
	MOVEM	B,PT		;YES. PT:=C(B)
	JRST	RET

;NL	IF N>0:	MOVE POINTER TO THE RIGHT, STOPPING WHEN IT HAS
;		PASSED OVER N LINE FEEDS.
;	IF N<0:	MOVE POINTER TO THE LEFT; STOP WHEN IT HAS PASSED
;		OVER N+1 EOL'S AND THEN MOVE IT TO THE RIGHT OF
;		THE LAST EOL PASSED OVER.
;L	SAME AS 1L.

LINE:	TRNE	FF,ARG2		;ERROR IF THERE ARE 2 ARGS
	ERROR	E.TAL
	PUSHJ	P,GETARG	;NO. C:=FIRST STRING ARGUMENT ADDRESS,
				;B:=SECOND STRING ARGUMENT ADDRESS.
	XOR	B,C
	XORM	B,PT
	JRST	RET
;ROUTINE TO RETURN CURRENT ARGUMENT IN B
;ASSUMES A VALUE OF 1 WITH SIGN OF LAST OPERATOR IF THERE IS NO CURRENT ARGUMENT
;CALL	PUSHJ P,CHK2
;	RETURN WITH B:=CURRENT ARG.,+1 OR -1

CHK2:	TROE	FF,ARG		;IS THERE AN ARGUMENT?
	POPJ	P,		;YES. IT'S ALREADY IN B.
CHK22:	LDB	B,[XWD 340200,DLIM]	;B:=1 WITH SIGN OF LAST OPERATOR.
	MOVNS	B
	AOJA	B,CPOPJ

;NK	PERFORM NL BUT DELETE EVERYTHING THE POINTER MOVES OVER.
;M,NK	DELETE THE (M+1)TH THROUGH THE NTH CHARACTER FROM THE BUFFER.
;	THE POINTER IS THEN PUT WHERE THE DELETION TOOK PLACE.
;K	SAME AS 1K

KILL:	PUSHJ	P,GETARG	;C:=FIRST STRING ARG. ADDRESS
				;B:=SECOND STRING ARG. ADDRESS
	PUSHJ	P,CHK1		;C:=MAX(C(C),BEG), B:=MIN(C(B),Z)
	MOVEM	C,PT		;PT:=C(C)
	SUB	B,C		;B:=NO. OF CHARACTERS TO KILL.
	JUMPE	B,RET		;IF NONE, RETURN. OTHERWISE, FALL INTO DELETE
	SETOM	DELIND
U DELIND,1
	SKIPA
;ND	DELETE N CHARACTERS FROM THE BUFFER: IF N IS POSITIVE, DELETE
;	THEM JUST TO THE RIGHT OF THE POINTER; IF N IS NEGATIVE, DELETE
;	THEM JUST TO ITS LEFT.
;D	SAME AS 1D

DELETE:	SETZM	DELIND
	PUSHJ	P,CHK2		;MAKE SURE B CONTAINS AN ARGUMENT
	MOVM	C,B
	PUSH	P,C
	PUSH	P,B
	SKIPL	B
	JRST	DELETA
	ADD	B,PT
	SKIPA
DELETA:	MOVE	B,PT
	ADDI	C,3	;INCR COUNT
	ADD	B,C
	SKIPE	FASTEC
	JRST	DELET$
	SKIPN	DELIND
	JRST	DELET$
	PUSHJ	P,X3
	MOVEM	B,QTEXTK	;SAVE IT IN &K
DELET$:	POP	P,B
	POP	P,C
	MOVNS	C		;C:=-ABS(B)
	ADD	B,PT		;B:=PT+B
	PUSHJ	P,CHK		;STILL IN DATA BUFFER?
	CAMGE	B,PT		;YES. IS N NEGATIVE?
	MOVEM	B,PT		;YES. MOVE PT BACK FOR DELETION.
	PUSHJ	P,NROOM		;MOVE FROM PT+ABS(C) THROUGH Z DOWN ABS(C) POSITIONS
	JRST	RET



;ROUTINE TO CHECK DATA BUFFER POINTER
;CALL	MOVE B,POINTER
;	PUSHJ P,CHK
;	RETURN IF B LIES BETWEEN BEG AND Z

CHK:	CAMG	B,Z
	CAMGE	B,BEG
	ERROR	E.POP
	POPJ	P,

;ROUTINE TO PUT STRING ARGUMENT ADDRESSES WITHIN DATA BUFFER
;BOUNDS AND CHECK ORDER RELATION.
;CALL	MOVE C,FIRST STRING ARGUMENT ADDRESS
;	MOVE B,SECOND STRING ARGUMENT ADDRESS
;	PUSHJ P,CHK1
;	RETURN
;C:=MAX(C(C),BEG), B:=MIN(C(B),Z)
;IF C>B, DOES NOT RETURN.

CHK1:	CAMG	C,BEG		;C:=MAX(C(C),BEG)
	MOVE	C,BEG
	CAML	B,Z		;B:=MIN(C(B),Z)
	MOVE	B,Z
	CAMLE	C,B		;C>B?
	ERROR	E.SAL
	POPJ	P,		;NO

;F= SEARCH

SEREQL:	SETOM	HOOKED
U HOOKED,1
	JRST	SERCH$
;_ SEARCH

LARR:	MOVE	A,[ASCIZ /"_" /];[BJ 4-9-74] 2 INSTR. TO CHK. IF INTENTIONAL
	PUSHJ	P,CHKYLA
	TROA	FF,FINDR	;FINDR:=1 FOR LEFT ARROW SEARCH

;N SEARCH

SERCHP:	TRO	FF,PCHFLG	;PCHFLG:=1 FOR N SEARCH

;S SEARCH

SERCH:	SETZM	HOOKED
SERCH$:	SKIPLE	E,B		;E=SEARCH COUNT
	JRST	SERCHA		;POSITIVE ARGUMENT
	TRNE	FF,ARG		;ILLEGAL 0 OR - SRH ARG
	ERROR	E.ISA
SERCHA:	MOVEI	CH,ALT		;USE ALT-MODE DELIMITER IF NO @ SEEN
	TRZN	FF,SLSL		;@ SEEN?
	JRST	SERCHB		;NO, TERMINATOR = ALTMODE
	PUSHJ	P,SKRCH		;YES. CH:=USER SPECIFIED DELIMITER.
	ERROR	E.USR
SERCHB:	MOVEM	CH,B		;B:=SEARCH STRING DELIMITER
	MOVEM	CH,ARGTRM	;SAVE TERMINATOR FOR FS INSERTION
	SETZM	STAB		;CLEAR SEARCH MATRIX
	MOVE	A,[XWD STAB,STAB+1]
	BLT	A,STAB+STABLN-1
	PUSHJ	P,SKRCH		;LOOK AHEAD 1 CHAR
	ERROR	E.USR
	CAIE	CH,(B)		;IS IT THE DELIMITER?
	JRST	SERCHT		;NO, AN ARGUMENT IS GIVEN
	MOVE	A,QTEXTS	;
	TLZE	A,400000
	TLZE	A,377770
	JRST	SERCLA
	MOVEI	CH,QTEXTS-QTAB+"0"	;GET CH
	MOVE	B,CH	;SAVE INDEX
	PUSHJ	P,QTXXT	;RELOCATE
	PUSHJ	P,GTQCNT	;GET SIZE
	HRRZ	I,QTAB-"0"(B)	;GET CONTENT
	ADD	I,QRBUF
	ADDI	I,3
	MOVE	AA,[POINT 7,SRHARG]
	SETZM	SRHCTR	;INIT COUNTS
SERQG:	JUMPE	C,SERQDN	;BR WHEN DONE
	PUSHJ	P,GETINC
	IDPB	CH,AA	;SET
	AOS	SRHCTR	;INCR COUNT
	PUSH	P,C	;SAVE
	MOVEI	C,^D80	;GET COUNT
	CAMGE	C,SRHCTR
	ERROR	E.STC
	POP	P,C
	SOJA	C,SERQG
SERCLA:	SKIPN	SRHCTR		;YES, USE PREVIOUS SEARCH STRING
	ERROR	E.SNA
	JRST	SERCH0

U ARGTRM,1			;FS, FN 2ND ARG TERMINATOR


;	ROUTINE [BJ 4-9-74] TO CHECK IF Y OR _ INTENTIONAL
;	ASK IF AN EB AND 1ST TIME IN COMMAND
;CALL:	MOVEI	A,"COMMAND"	;COMMAND IS 1 CHARACTER TO BE USED IN TYPE OUT
;	-RETURN HERE IF ALL WELL, NOT IF NOT-
CHKYLA:	TLNN	F2,SUPYLA	;SUPPRESS MESSAGE SET?
	TLNN	FF,UBAK	;NO,SOMETHING OTHER THAN EB?
	POPJ	P,		;YES, DON'T SPEAK
	PUSH	P,A	;SAVE COMMAND
	MOVE	A,Z		;GET # OF CHARACTERS IN BUFFER
	SUB	A,BEG
	CAIL	A,10		;FORGET MESSAGE IF <8 CHARS
	TLOE	F2,YBKARW	;NO, HAVE WE DONE IT BEFORE? SET 'DONE BEFORE' BIT
	JRST	CHKYL2
	PUSH	P,[POINT 7,0]
	HRRZI	CH,-1(P)	;GET PTR
	ADDM	CH,(P)	;CALC
	PUSHJ	P,STRGVF
	POP	P,A
	PUSH	P,[POINT 7,[ASCIZ	/Destroys buffer, are you sure?("Y" or "N"):/]]
	PUSHJ	P,STRGVF
	PUSHJ	P,TYIVF	;GO GET THE CHAR
	PUSH	P,[POINT 7,[ASCIZ	"
"]]
	PUSHJ	P,STRGVF
	PUSHJ	P,UCCVT
	CAIN	CH,"Y"		;REPLY A YES?
	POPJ	P,		;YEP, CONTINUE NORMALLY
IFN CHECKP,<SKIPN INDY>
	JRST	GO 		;NO, STOP COMMAND EXECUTION
IFN CHECKP,<
	SETZM	INDY
	SETZM	CHKEXE
	RELEAS	CHPCHN,
	JRST	GO
>
CHKYL2:	POP	P,A
	POPJ	P,

;HERE TO COMPLEMENT "SUPRESS MESSEGE" BIT [^B]
CNTRB:	TLC	F2,SUPYLA	;TOGGLE OF 'SUPRESS MESSAGE' BIT
	JRST	RET
;MOVE NEW STRING TO STORAGE

SERCHT:	SETZM	SRHCTR		;CLR STRING CTR
	MOVE	AA,[POINT 7,SRHARG]	;INIT STORAGE PTR
	JRST	SERCHD		;1ST CHAR ALREADY IN
SERCHC:	PUSHJ	P,SKRCH		;GET NEXT CHAR OF CMD STRING
	ERROR	E.USR
SERCHD:	CHKEO	EO21,SERCHE	;IF EO=1, ^R IS JUST TEXT
	CAIE	CH,22		;^R?
SERCHE:	CAIN	CH,21		;^Q?
	JRST	SERCHG		;YES, NEXT CHAR IS TEXT
	CAIN	CH,(B)		;THE DELIMITER?
	JRST	SERCH0		;YES
	CAIN	CH,24		;^T?
	JRST	SERCHU		;YES
	TRNE	F2,TXTCTL	;^T FLAG ON?
	JRST	SERCHF		;YES, ^V AND ^W ARE JUST TEXT
	CAIE	CH,26		;^V?
	CAIN	CH,27		;^W?
	TRO	F2,XMATCH	;YES, SET EXACT MATCH FLAG
SERCHF:	AOS	A,SRHCTR	;BUMP STRING CTR
	CAILE	A,^D80		;STILL FIT IN STORE?
	ERROR	E.STC
	IDPB	CH,AA		;STORE CHARACTER
	JRST	SERCHC		;& GO BACK FOR MORE

SERCHG:	AOS	SRHCTR		;COUNT THE ^R (^Q)
	IDPB	CH,AA		;& STORE IT
	PUSHJ	P,SKRCH		;GET NEXT CHAR
	ERROR	E.USR
	JRST	SERCHF		;STORE IT AS TEXT

SERCHU:	TRC	F2,TXTCTL	;COMPLEMENT CONTROL CMD DISABLING SWITCH
	JRST	SERCHF
;SET UP SEARCH MATRIX

SERCH0:	MOVEI	B,SRHARG
	IMULI	B,5
	MOVE	C,SRHCTR
	ADDI	C,3
	SKIPE	FASTEC
	JRST	SERQDN
	SETOM	NOMOVY
	PUSHJ	P,X3
	MOVEM	B,QTEXTS
SERQDN:	TRZ	F2,TXTCTL	;REFRESH ^T FLAG
	SETZM	SCESQB		;CLR ^E[...] NEST CTR
	MOVE	B,SRHCTR	;INIT STRING CTR
	MOVE	AA,[POINT 7,SRHARG]	;& POINTER
	MOVSI	D,400000	;INIT MATRIX BIT PTR

SERCH2:	ILDB	CH,AA		;CH:=NEXT SEARCH STRING CHARACTER.
	SKIPN	SCESQB		;GATHERING DATA FOR ^E[...]?
	JRST	.+3		;NO
	SOJL	B,CNTREE	;YES, ERRORS GO TO ?ICE
	JRST	.+2
	SOJL	B,SERCHI	;END OF STRING?
	MOVEI	T,S2TABL	;CK FOR CTL CHAR IN STRING
	TRNE	F2,TXTCTL	;^T FLAG ON?
	MOVEI	T,S3TABL	;YES, USE RESTRICTED TABLE
	PUSHJ	P,DISP1
	CHKEO	EO21,SRCH2B	;IF EO=1, FORCE EXACT MODE
	TRNN	F2,TXTCTL	;IF ^T FLAG ON, ALL ^CHARS ARE LEGAL
	PUSHJ	P,CKNCC		;CK FOR OTHER CTRL-CHARS (THEY ARE ILLEGAL)
SRCH2E:	TRNE	F2,EMATCH	;IGNORE XMATCH FLAG?
	JRST	SRCH2F		;YES, FORCE ACCEPT-EITHER SEARCH
	TRNN	F2,XMATCH	;NO, XMATCH ON?
	TLNE	FF,PMATCH	;NO, PREVAILING EXACT MATCH FLAG ON?
	JRST	SRCH2B		;EMATCH=0 & XMATCH OR PMATCH =1 IMPLIES EXACT MODE
SRCH2F:	CAIL	CH,141		;ACCEPT-EITHER SEARCH MODE
	CAILE	CH,172		;IS IT LOWER CASE ALPHA?
	SKIPA			;NO
	TRZ	CH,40		;YES, MAKE IT UPPER CASE
	CAIL	CH,"A"		;IS IT UPPER CASE ALPHA?
	CAILE	CH,"Z"
	JRST	SERCH4		;NO
	XORM	D,STAB+40(CH)	;ENABLE MATCH ON CORRESP. LC CHAR.
	JRST	SERCH4

SRCH2B:	PUSHJ	P,CASE		;EXACT MODE SEARCH -- ADJUST CASE
SERCH4:	XORM	D,STAB(CH)	;MARK CHARACTER TO MATCH
SERCH5:	SKIPE	SCESQB		;GATHERING DATA FOR A ^E[...]?
	POPJ	P,		;YES
	TLZN	F2,CTLN		;DOES ^N PRECEDE THIS CHAR POSITION?
	JRST	SERCH6		;NO
	ANDCAM	D,STAB+BEGPAG	;YES, CLEAR ALL FAKE BITS
	ANDCAM	D,STAB+ENDPAG
	ANDCAM	D,STAB+SPCTAB
SERCH6:	LSH	D,-1		;MOVE TO NEXT CHAR. POSITION IN MATRIX
	SETZM	SCESQB		;(BASE IS 0)
	JUMPN	D,SERCH2	;36 CHARS SEEN YET? IF NOT CONTINUE.
	JUMPE	B,SERCHI	;TOO MUCH IF STILL ANOTHER CHAR WAITING
	ERROR	E.STL
;SCAN INSERT ARGUMENT IF F-SEARCH

SERCHI:	TRNN	FF,FSRCH	;F-SEARCHING?
	JRST	SERCH1		;NO
	TRZ	F2,TXTCTL	;REFRESH ^T FLAG
	MOVE	CH,ARGTRM	;GET TERMINATOR TO WATCH FOR
	JRST	INSERA		;SCAN INSERT ARGUMENT

SERCHJ:	POP	P,COMBAK	;SAVE COMCNT & CPTR FOR THE INSERTION
	POP	P,CPTBAK
	MOVE	AA,CPTR	;GET CURRENT
	MOVEM	AA,CPTREL
U CPTREL,1	;FOR CALCULATING REL
				;THEN FALL INTO SERCH1

;START SEARCHING

SERCH1:	MOVE	AA,D		;END OF SEARCH MARKER
	MOVE	I,PT		;START SEARCHING AT PT
S1:	TRNE	FF,ARG		;IS THERE AN ARGUMENT?
	JUMPLE	E,FND		;YES. SEEN STRING N TIMES?
	MOVE	TT,I		;NO, FORM BYTE PTR WHICH WILL BE
	SUBI	TT,1		;INCREMENTED BEFORE USE
	IDIVI	TT,5
	HLL	TT,BTAB(TT1)
	CAMG	I,BEG		;AT BEG OF BUFR?
	SKIPL	STAB+BEGPAG	;& 1ST SERCH CHAR = BEG OF BUFR CHAR?
	JRST	S3		;NO
	MOVSI	D,200000	;YES, START SEARCH AT 2ND SEARCH CHAR
	MOVE	TT1,TT		;SET DYNAMIC PTR = STATIC PTR
;S1+13	INSERTED INSRRUCTION [ED#117]
	SETOM	BCOUNT		;FLAG 1ST IS BEGPAG
	JRST	S4B		;ENTER SEARCH LOOP

S3:	CAML	I,Z		;NO. REACHED TOP OF BUFFER?
	JRST	NOFND		;YES.
	MOVSI	D,400000	;START SEEKING MATCH FOR 1ST CHAR
	MOVE	TT1,TT		;SET DYNAMIC PTR=STATIC PTR
	JRST	S4A
S4:	TDNE	D,STAB+SPCTAB	;IS SPACE/TAB STRING BIT SET?
	JRST	SPTB		;YES
	ADDI	I,1		;LOOK AT NEXT LOC, XCEPT 1ST TIME THRU
S4C:	LSH	D,-1		;ADVANCE TO NEXT CHAR POSITION
S4B:	CAMN	D,AA		;END OF SEARCH TABLE?
	JRST	FND		;YES.
S4A:	ILDB	CH,TT1		;NO, GET NEXT CHAR
	TDNE	D,STAB(CH)	;IS IT A MATCH?
	JRST	S4		;YES, GO TO NEXT TABLE ENTRY.
;S4A+3 INSERTED 2 INSTRUCTIONS [ED#117]
	AOSN	BCOUNT		;IF WE FAILED WITH BEGPAG
	JRST	S3		;THEN TRY AGAIN WITH 1ST CHAR
	SKIPE	HOOKED
	JRST	NOFND
	AOS	I,PT		;NO MATCH. PT:=PT+1
	IBP	TT		;MOVE STATIC BYTE PTR
	JRST	S3		;KEEP LOOKING
FND:	CAMLE	I,Z		;REACH TOP OF BUFFER?
	JRST	NOFND		;YES. SEARCH FAILED.
	SETOM	SFINDF		;NO. SFINDF:=-1
	MOVE	A,I
	SUB	A,PT		;COMPUTE LENGTH OF SEARCH ARG
	MOVEM	I,PT		;MOVE PT PAST THE STRING
	SOJG	E,S1		;FIND IT N TIMES?
	TRNN	FF,FSRCH	;F-SEARCH?
	JRST	FND3		;NO
	MOVE	C,VVAL		;YES, GET INSERT SIZE
	SUB	C,A		;INSERT MINUS DELETE
	MOVNS	A		;SET PT TO BEGINNING OF STRING FOUND
	ADDM	A,PT
	PUSHJ	P,NROOM		;STRETCH OR SCRUNCH THE HOLE
	MOVE	B,ARGTRM	;GET TERMINATOR TO LOOK FOR
	MOVE	A,COMBAK	;RESET COMCNT & CPTR TO BEGINNING
	MOVEM	A,COMCNT	;  OF INSERT ARGUMENT
	MOVE	A,PT	;GET PT
	SUB	A,BEG
	MOVEM	A,PTSAVE
U PTSAVE,1
	PUSHJ	P,CPTRLC	;CALC RELOC
	MOVEM	A,CPTBAK	;SAVE FOR REL
	PUSHJ	P,INS1B		;INSERT THE 2ND ARG
	PUSHJ	P,ZEROTT	;DO AUTO-TYPE IF REQUIRED
	MOVE	CH,ARGTRM
	SKIPN	VVAL		;IS THERE A NON-NULL INSERT?
	CAIE	CH,ALT		;ALTMODE TERMINATOR?
	JRST	FND2		;NO
	MOVE	A,CPTRL2
	MOVEM	A,CPTREL
U CPTRL2,1
	PUSHJ	P,CPTRLC
	AOS	COMCNT	;FIX UP COUNT
	JRST	MACDO1
CPTRLC:	PUSH	P,TT	;SAVE
	PUSH	P,TT+1	;
	MOVE	A,CPTBAK	;GET INT FOR OLD BAK
	PUSHJ	P,FUCVC
	MOVE	TT,A	;SAVE IT
	MOVE	A,CPTR	;GET NEW
	MOVEM	A,CPTRL2	;SAVE AGAIN
	PUSHJ	P,FUCVC	;CONVERT
	ADD	TT,A	;ADD NEW
	MOVE	A,CPTREL	;GET OLD
	PUSHJ	P,FUCVC	;CONVERT
	SUB	TT,A	;SUB OLD
	IDIVI	TT,5	;BACK TO POINTERS
	HLL	TT,BTAB(TT+1)	;GET POINTER PART
	MOVE	A,TT	;COPY
	MOVEM	A,CPTR	;SET THE TURKEY
	POP	P,TT+1
	POP	P,TT
	POPJ	P,
FUCVC:	PUSH	P,TT	;SAVE
	PUSH	P,A	;SAVE
	LSH	A,-^D30	;SHIFT DOWN P BITS
	MOVEI	TT,4	;GET INIT
	SOSG	A	;SKIP IF GREATER
	JRST	FUCVS	;BR IF FOUND
FUCVL:	SOS	TT	;DECR INDEX
	SUBI	A,7	;DECR P
	JUMPG	A,FUCVL	;LOOP
FUCVS:	POP	P,A	;GET BACK POINTER
	HRRZ	A,A	;ZAP POINTER NOW
	IMULI	A,5	;GET CHAR ADDRESS
	ADD	A,TT	;ADD CHAR IN WORD
	POP	P,TT
	POPJ	P,	;RETURN
FND3:
IFN VC,<MOVEM	A,VVAL>		;SAVE LENGTH OF STRING
	PUSHJ	P,ZEROTT	;AUTOTYPE
FND2:	TRZN	FF,COLONF	;COLON MODIFIER?
	JRST	MACDO1		;NO

FFOK:	MOVNI	A,1		;YES. RETURN VALUE OF -1
	JRST	VALRET

MACDO1:	MOVE	A,QAUTPY	;AUTOTYPE OUT &S
	TLZE	A,400000
	TLZE	A,377770
	JRST	RET
	PUSHJ	P,QTXXT
	JRST	MACXX2

U COMBAK,1			;STORE FOR COMCNT DURING FS, FN
U CPTBAK,1			;DITTO CPTR
;AUTOTYPE AFTER SUCCESSFUL SEARCHES
;  IF AUTOF IS NON-ZERO
;  INCLUDE POINTER MARKER = ASCII CHAR IN AUTOF IF AUTOF > 0

ZEROTT:	TRNE	FF,COLONF	;NO AUTOTYPE ON COLON SEARCHES
	POPJ	P,
	SKIPL	-1(P)		;IN AN ITERATION?
	SKIPN	AUTOF
	POPJ	P,
	TRO	FF,ARG		;DO 0T
	SETZ	B,
	PUSHJ	P,TYPE4
	HRRZ	CH,AUTOF
	SKIPL	AUTOF		;PTR MARKER WANTED?
	PUSHJ	P,TYOM		;YES
	MOVEI	B,1		;DO 1T
	PUSHJ	P,TYPE4
	TRZ	FF,ARG
	POPJ	P,
NOFND:	CAMGE	I,Z	;AT ENDPAGE ?
	JRST	NOFND3		;NO SO WON'T MATCH E-O-L
	TDNN	D,STAB+ENDPAG	;ENDPAG GOOD FOR A MATCH HERE?
	JRST	NOFND3		;NO
	LSH	D,-1		;YES, BUT ONLY IF THIS IS LAST SRH CHAR
	CAMN	D,AA
	JRST	FND		;ENDPAG MATCHES!
NOFND3:	MOVE	I,BEG		;SEARCH FAILED
	SKIPN	HOOKED
	MOVEM	I,PT		;PT=BEG
	SETZM	SFINDF		;SFINDF=0
	TRNE	FF,PCHFLG+FINDR	;S SEARCH?
	JRST	NOFND1		;NO.


BEGIN1:	TRZN	FF,COLONF	;YES. COLON MODIFIER?
	JRST	NOFND2		;NO


BEGIN2:	TRZ	FF,PCHFLG+FINDR	;YES.
	JRST	BEGIN		;RETURN VALUE OF 0



NOFND1:	MOVEM	E,SRHCNT	;YES. SAVE SEARCH COUNT
	MOVEM	AA,SRHAA	;& SAVE END OF MATRIX MARKER
	MOVEI	B,1		;PUNCH 1 PAGE ONLY
	TRNE	FF,PCHFLG	;N SEARCH?
	PUSHJ	P,PUNCHA	;YES. PUNCH THIS BUFFER AND REFILL IT.
	TLNN	FF,UREAD	;ANY INPUT FILE?
	JRST	BEGIN1		;NO
	TLNE	FF,FINF		;MORE DATA?
	TRNE	FF,FORM
	JRST	NOFND4		;YES
	MOVE	E,BEG		;EOF & NO FORM SEEN
	CAMN	E,Z		;CHECK BUFFER CONTENTS
	JRST	BEGIN1		;NO MORE DATA
NOFND4:	TRNE	FF,FINDR	;LEFT ARROW SEARCH?
	PUSHJ	P,YANK1		;YES. FILL BUFFER.
	MOVE	E,SRHCNT	;RESTORE SEARCH COUNT.
	MOVE	D,SRHAA		;RESTORE END OF STRING MARKER
	JRST	SERCH1		;RESUME SEARCH


NOFND2:	SKIPGE	(P)		;IN AN ITERATION?
	JRST	RET		;RETURN
	ERROR	E.SRH

U SRHCNT,1			;SEARCH COUNT STORE
U SRHAA,1			;END OF SEARCH MATRIX MARKER

SRHMOD:	EXP	SRCHSW		;DEFAULT SEARCH MODE
;CNTR S MATCHES ANY SEPARATOR CHARACTER (I.E., ANY CHARACTER NOT
;A LETTER, NUMBER, PERIOD, DOLLAR SIGN OR PER CENT SYMBOL)

CNTRS:	MOVE	T,[-STABLN+3,,1] ;SET ALL CURRENT BITS EXCEPT NULL & SPCTAB
	PUSHJ	P,SETSTB	;  & ENDPAG, BUT DO INCLUDE BEGPAG
	XORM	D,STAB+"."	;NOW, SCRATCH ALL SYMBOL CHARS
	XORM	D,STAB+"%"
	XORM	D,STAB+"$"
	MOVE	T,[-^D10,,"0"]	;DIGITS
	PUSHJ	P,SETSTB
CNTLEA:	MOVE	T,[-^D26,,"A"]	;UC CHARS (ENTRY FOR ^EA)
	PUSHJ	P,SETSTB
CNTLEV:	MOVE	T,[-^D26,,141]	;LC CHARS (ENTRY FOR ^EV)
	JRST	CNTRXX

;CNTR X MATCHES ANY ARBITRARY CHARACTER

CNTRX:	MOVE	T,[-STABLN+4,,1] ;WANT TO ACCEPT ANYTHING AS A MATCH
CNTRXX:	PUSHJ	P,SETSTB	;  EXCEPT NULL & SPCTAB & BEGPAG & ENDPAG
	JRST	SERCH5

;CNTR N REVERSES THE SENSE OF THE SEARCH FOR THE NEXT CHARACTER

CNTRN:	MOVE	T,[-STABLN+4,,1]	;STAB CTR & PTR
	PUSHJ	P,SETSTB	;SET CURRENT POSITION BIT FOR ALL CHARS
	TLO	F2,CTLN		;SET ^N FLAG
	JRST	SERCH2

;SET STAB BITS AS INDICATED BY T & D

SETSTB:	XORM	D,STAB(T)
	AOBJN	T,.-1
	POPJ	P,

;DISPATCH TABLE FOR 2ND SCAN OF SEARCH STRING

S2TABL:	XWD	CNTRE,05	;^E
	XWD	CNTRX,30	;^X
	XWD	CNTRN,16	;^N
	XWD	CNTRS,23	;^S
	XWD	CNTRV,26	;^V
	XWD	CNTRW,27	;^W
	XWD	CNTRL,34	;^\
	XWD	CNTRU,36	;^^
S3TABL:	XWD	CNTRT,24	;^T
	XWD	CNTRQ,21	;^Q
	XWD	CNTRR,22	;^R
	XWD	CNTR33,ALT	;ALTMODE
	XWD	0,0		;END OF LIST
;^E COMMANDS

CNTRE:	CHKEO	EO21,SERCH4	;IF EO=1, ^E IS JUST TEXT
	ILDB	CH,AA		;GET CHAR. AFTER ^E
	SOJL	B,CNTREE	;NONE THERE
	MOVEI	T,S4TABL	;GO TO PROPER ^E COMMAND
	PUSHJ	P,DISPAT	;  TO SET SPECIFIED CHARACTER BITS
CNTREE:	ERROR	E.ICE

;DISPATCH TABLE FOR ^E COMMANDS

S4TABL:	XWD	CNTLEA,"A"	;^EA	ACCEPT ANY ALPHA
	XWD	CNTLEV,"V"	;^EV	ACCEPT ANY L.C. ALPHA
	XWD	CNTLEW,"W"	;^EW	ACCEPT ANY U.C. ALPHA
	XWD	CNTLED,"D"	;^ED	ACCEPT ANY DIGIT
	XWD	CNTLEL,"L"	;^EL	ACCEPT ANY E-O-L CHAR.
	XWD	CNTLES,"S"	;^ES	ACCEPT A STRING OF SPACES OR TABS
	XWD	CNTLEN,74	;^E<NNN>	ACCEPT ASCII <NNN>
	XWD	CNTLEB,133	;^E[A,B,C]	ACCEPT A OR B OR C
	XWD	0,0		;END OF LIST

U SCESQB,1			;SEARCH FOR ^E[...] NESTING COUNTER
;^EW

CNTLEW:	MOVE	T,[-^D26,,"A"]	;UPPER CASE ALPHABETIC CHARS.
	JRST	CNTRXX

;^ED

CNTLED:	MOVE	T,[-^D10,,"0"]	;DIGITS
	JRST	CNTRXX

;^EL

CNTLEL:	MOVE	I,Z		;IS LAST CHAR IN BUFR AN EOL?
	CAMG	I,BEG
	JRST	CNTLE3		;NO
	SUBI	I,1
	PUSHJ	P,GET
	CAIL	CH,12
	CAILE	CH,14
CNTLE3:	XORM	D,STAB+ENDPAG	;NO, ENDPAG IS GOOD FOR A MATCH
	MOVE	T,[-3,,12]	;LF, VT, FF
	JRST	CNTRXX

;^ES

CNTLES:	XORM	D,STAB+40	;SPACE
	XORM	D,STAB+11	;TAB
	XORM	D,STAB+SPCTAB	;& SPACE/TAB STRING BIT
	JRST	SERCH5

;SKIP OVER A STRING OF SPACES AND/OR TABS WHILE SEARCHING

SPTB:	ADDI	I,1		;ADVANCE TO NEXT BUFFER LOCATION
	CAML	I,Z		;END-OF BUFFER?
	JRST	S4C		;YES, NO MORE SPACE/TABS
	MOVEM	TT1,ERR1	;SAVE CURRENT BYTE PTR (USING ERR1 AS TMP)
	ILDB	CH,TT1		;LOOK AT NEXT CHAR
	CAIE	CH,40		;IS IT A SPACE?
	CAIN	CH,11		;OR TAB?
	JRST	SPTB		;YES, KEEP SKIPPING
	MOVE	TT1,ERR1	;NO, END OF SPACE/TAB STRING
	JRST	S4C		;  RESTORE BYTE-POINTER & CONTINUE SEARCH
;^E[A,B,C,...]

CNTLEB:	AOS	SCESQB		;BUMP ^E[...] NEST CTR
CNTLE0:	PUSHJ	P,SERCH2	;GET CHAR FROM OR-STRING
	ILDB	CH,AA		;GET SEPARATOR
	SOJL	B,CNTREE
	CAIN	CH,","		;MORE TO GO?
	JRST	CNTLE0		;COMMA IMPLIES YES
	CAIE	CH,"]"		;END OF OR-STRING?
	ERROR	E.ICE
	SOS	SCESQB		;DECREMENT ^E[...] NEST CTR
	JRST	SERCH5		;YES

;^E<NNN>	(NNN IS OCTAL FOR A SINGLE ASCII CHAR)

CNTLEN:	MOVEI	A,0		;CLR NUMBER ACCUMULATOR
CNTLE1:	ILDB	CH,AA		;GET A DIGIT
	SOJL	B,CNTREE	;SHOULDN'T RUN OUT
	CAIN	CH,76		;RIGHT ANGLE-BRACKET?
	JRST	CNTLE2		;YES, END OF NUMBER
	CAIL	CH,"0"		;IS IT A DIGIT?
	CAILE	CH,"7"
	JRST	CNTLE4
	LSH	A,3		;YES, SCALE UP THE PREVIOUS VALUE
	ADDI	A,-60(CH)	;AND ADD IN THE NEW DIGIT
	JRST	CNTLE1		;TRY FOR MORE
CNTLE4:	CAIE	CH,"Q"		;CHECK FOR Q-REGISTER
	ERROR	E.ICE
	ILDB	CH,AA		;GET CHARACTER
	SOJL	B,CNTREE	;SHOULDN'T RUN OUT
	CAIE	CH,"&"		;SPECIAL ?
	JRST	OLDCAL	;NO
	MOVEI	CH,44	;GET OFFSET
	MOVEM	CH,QTCAL	;SET
	ILDB	CH,AA	;GET OTHER
	SOJL	B,CNTREE
	SKIPA
OLDCAL:	SETZM	QTCAL
	ILDB	A,AA		;GET > (HOPEFULLY)
	CAIE	A,">"		;CHECK IT
	JRST	CNTREE		;NOPE
	SOJL	B,CNTREE
	PUSHJ	P,QREGV5
	MOVE	A,QTAB-"0"(CH)	;GET VALUE
CNTLE2:	ANDI	A,177		;EXTRACT AN ASCII CHAR.
	XORM	D,STAB(A)	;AND SET THE CORRESP. BIT
	JRST	SERCH5
;^R IS SAME AS ^Q (PROVIDED EO NOT = 1)
;EXCEPT IT DOESN'T CAUSE RUBOUT PROBLEMS

CNTRR:	CHKEO	EO21,SERCH4	;IF EO=1, ^R IS JUST TEXT

;^Q CAUSES NEXT CHAR TO BE TAKEN AS TEXT EVEN IF IT IS
;A CTRL CHAR. OR THE TERMINATOR

CNTRQ:	ILDB	CH,AA		;GET NEXT CHAR
	SOJA	B,SRCH2E	;& PROCESS AS ORDINARY TEXT

;^V CAUSES NEXT CHAR TO BE TAKEN AS LOWER CASE
;^V^V SETS LOWER CASE MODE UNTIL FURTHER NOTICE

CNTRV:	CHKEO	EO21,SERCH4	;IF EO=1, ^V IS JUST TEXT
	PUSHJ	P,C.V		;SET ^V FLAGS
	JRST	SERCH2

;^W CAUSES NEXT CHAR TO BE TAKEN WITHOUT CONVERSION
;^W^W SETS STANDARD CASE MODE UNTIL FURTHER NOTICE

CNTRW:	CHKEO	EO21,SERCH4	;IF EO=1, ^W IS JUST TEXT
	PUSHJ	P,C.W		;SET ^W FLAGS
	JRST	SERCH2

;FIRST ^\ CHANGES MATCH MODE TO ACCEPT EITHER UC OR LC
;SECOND ONE TURNS ACCEPT EITHER FLAG OFF

CNTRL:	CHKEO	EO21,SERCH4	;IF EO=1, ^\ IS JUST TEXT
	TRC	F2,EMATCH	;COMPLEMENT ACCEPT EITHER FLAG
	JRST	SERCH2

;IF SEARCHING FOR ALTMODE, AND IF EO=1, 033 & 175 ARE MATCHES

CNTR33:	CHKEO	EO21,.+2	;EO=1?
	JRST	SERCH4		;NO, ACCEPT 033 ONLY
	XORM	D,STAB+175	;YES, MARK 175 AS ACCEPTABLE MATCH
	JRST	SERCH4		;& 033

;^^ CAUSES IMMEDIATELY FOLLOWING @,[,\,],^,_ TO BE CONVERTED TO LC RANGE

CNTRU:	CHKEO	EO21,SERCH4	;IF EO=1, ^^ IS TEXT
	ILDB	CH,AA		;GET NEXT CHAR
	PUSHJ	P,CVTSPC	;CONVERT TO LC IF @, ETC
	SOJA	B,SRCH2E

;^T DISABLES ALL CNTRL COMMANDS EXCEPT ^Q,^R,^T AND ALLOWS ALL OTHER
;CNTRL CHARS AS TEXT.  THE NEXT ^T TURNS THE ^T SWITCH BACK OFF.

CNTRT:	CHKEO	EO21,SERCH4	;IF EO=1, ^T IS TEXT
	TRC	F2,TXTCTL
	JRST	SERCH2
;F SEARCHES

FCMD:	PUSHJ	P,SKRCH		;GET CHAR AFTER F
	ERROR	E.MEF
	CAIL	CH,"A"+40
	TRZ	CH,40	;TO UC
	CAIN	CH,"="
	JRST	SEREQL
	CAIN	CH,"O"		;FO ?
	JRST	SPTYO
	CAIN	CH,"W"		;FW ?
	JRST	SPWCM
	TRO	FF,FSRCH	;SET F-SEARCH FLAG
;FCMD+3 INSERTED 1 INSTRUCTION	[ED#114]
	CAIN	CH,"S"		;FS?
	JRST	SERCH		;YES
	CAIN	CH,"N"		;FN?
	JRST	SERCHP		;YES
	ERROR	E.IFC
;<>	ITERATION BRACKETS.  COMMAND INTERPRETATION IS SENT
;	BACK TO THE < WHEN THE > IS ENCOUNTERED.

LSSTH:	PUSH	P,ITERCT	;SAVE ITERATION COUNT
	PUSH	P,COMAX		;PUSH SOME SHIT[161]
	PUSH	P,CPTR		;SAVE COMMAND STATE
	PUSH	P,COMCNT
	SETOM	ITERCT		;ITERCT:=-1
	PUSH	P,ITERCT	;-1 FLAGS ITERATION ON PDL
	AOS	QLEVER	;INCR LEVEL COUNT
	TRZN	FF,ARG		;IS THERE AN ARGUMENT?
	JRST	RET		;NO
	JUMPLE	B,INCMA1	;IF ARG NOT > 0, SKIP OVER <>
	MOVEM	B,ITERCT	;YES. ITERCT:=ARGUMENT
	JRST	RET


GRTH:	SKIPGE	A,(P)		;IS THERE A LEFT ANGLE BRACKET?
	JRST	GRTH2		;YES. OTHERWISE ITS A MISSING < OR
	SOJE	A,GRTH9		;SOMETHING LIKE <...(...>
	ERROR	E.MLA
GRTH2:	SOSN	ITERCT		;ITERCT:=ITERCT-1. DONE?
	JRST	INCMA3		;YES
	MOVE	A,-2(P)		;NO. RESTORE COMMAND STATE TO START OF ITERATION.
	MOVEM	A,CPTR
	MOVE	A,-1(P)
	MOVEM	A,COMCNT
	JRST	RET

GRTH9:	ERROR E.MRP

U ITERCT,1			;
;;	IF NOT IN AN ITERATION, GIVES ERROR.  IF IN AN ITERATION AND
;	IF THE MOST RECENT SEARCH FAILED, SEND COMMAND TO FIRST UNMATCHED
;	> TO THE RIGHT.  OTHERWISE, NO EFFECT.

SEMICL:	SKIPL	(P)		;ERROR IF NOT IN <...>
	ERROR	E.SNI
	TRNN	FF,ARG		;YES. IF NO ARG,
	MOVE	B,SFINDF	;USE LAST SEARCH SWITCH (0 OR -1).
	JUMPL	B,CD		;IF ARG <0, JUST RET + EXECUTE LOOP
INCMA1:	MOVEI	TT,">"		;SKAN FOR >
	MOVEI	TT1,"<"		;IGNORE <...> STRINGS
	PUSHJ	P,SKAN

	ERROR	E.MRA
INCMA3:	SOS	QLEVER	;DECR LEVEL
INCMA2:	SUB	P,[XWD 3,3]	;POP OUT A LEVEL
	POP	P,COMAX	;[161]
	POP	P,ITERCT
	JRST	RET



;!TAG!	TAG DEFINITION.  THE TAG IS A NAME FOR THE LOCATION IT
;	APPEARS IN IN A MACRO, ITERATION OR COMMAND STRING.

EXCLAM:	PUSHJ	P,SKRCH		;LOOK FOR NEXT !
	ERROR	E.UTG
	CAIE	CH,"!"
	JRST	EXCLAM
	JRST	RET
;OTAG$	GO TO THE TAG NAMED TAG.  THE TAG MUST APPEAR IN THE 
;	CURRENT MACRO OR COMMAND STRING.

OG:	MOVE	A,CPTR
	MOVE	AA,A
	IDIVI	AA,17
	CAMN	A,SYMS(B)
	JRST	OGFND
	SKIPN	SYMS(B)
	JRST	OGNF
	CAMN	A,SYMS+1(B)

ES1:	AOJA	B,OGFND
	SKIPN	SYMS+1(B)
ES2:	AOJA	B,OGNF
	CAMN	A,SYMS+2(B)
	AOJA	B,ES1
	SKIPN	SYMS+2(B)
	ADDI	B,2

OGNF:	PUSH	P,CPTR
	PUSH	P,B
	MOVEI	D,STAB
OGW:	CAIG	D,STAB+STABLN-2	;[156]
	JRST	OG1	;[156]
	ERROR	E.TTL
OG1:	PUSHJ	P,SKRCH		;GET NEXT COMMAND CHAR

	ERROR	E.MEO
	MOVEM	CH,(D)		;STAB ... _ TAG
	CAIE	CH,ALT
	AOJA	D,OGW
	MOVEI	A,"!"		;TAG TERMINATOR
	MOVEM	A,(D)
	SETZM	1(D)
	MOVE	B,COMCNT	;MAKE PTR TO START OF THIS COMMAND LEVEL
	SUB	B,COMAX
	IDIVI	B,5
	ADD	B,CPTR
	JUMPE	E,OG7		;NO REMAINDER
	SOS	B
	MOVMS	E
	JRST	.(E)
	IBP	B
	IBP	B
	IBP	B
	IBP	B
OG7:	MOVEM	B,CPTR
	MOVE	B,COMAX		;GET # OF CMD CHARS AT THIS LEVEL
	MOVEM	B,COMCNT
OG2:	MOVEI	TT,"!"		;SKAN FOR !
	MOVEI	TT1,-1		;NO SECONDARY CHAR.
	PUSHJ	P,SKAN
	ERROR	E.TAG
	TRO	F2,NOTRAC	;DON'T TYPE EVERY TAG WHILE TRACING
	MOVEI	E,STAB		;INIT SEARCH STRING TO 1ST CHAR AFTER !
OG5:	SKIPN	(E)		;OVER STRING?
	JRST	OG3		;YES
	PUSHJ	P,SKRCH		;NO. GET A CHAR
	ERROR	E.TAG
	CAMN	CH,(E)		;MATCH ?
	AOJA	E,OG5		;YES. MOVE ON.
	CAIN	CH,"!"		;NO, ARE WE AT END OF A TAG?
	JRST	OG2		;YES, LOOK FOR ANOTHER
	MOVEI	E,"!"		;NO, SKIP TO NEXT !
OG6:	PUSHJ	P,SKRCH		;GET NEXT CHAR OF TAG
	ERROR	E.UTG
	CAIE	CH,(E)		;!?
	JRST	OG6		;NO, KEEP GOING
	JRST	OG2		;YES, LOOK FOR ANOTHER TAG

OG3:	TRZ	F2,NOTRAC	;RE-ENABLE TRACING
	POP	P,A		;GET INDEX TO SYMBOL TABLE
	POP	P,SYMS(A)	;SAVE POSITION OF THIS O COMMAND
	MOVE	B,COMCNT	;SAVE COMCNT FOR THIS TAG
	MOVEM	B,CNTS(A)
	MOVE	B,CPTR		;SAVE TAG POSITION IN COMMAND STRING
	MOVEM	B,VALS(A)
	JRST	RET


OGFND:	MOVE	A,VALS(B)
	MOVEM	A,CPTR
	MOVE	A,CNTS(B)
	MOVEM	A,COMCNT
	JRST	RET
;N"G	HAS NO EFFECT IF N IS GREATER THAT 0.  OTHERWISE,
;	SEND COMMAND INTERPRETATION TO NEXT MATCHING '.
;	THE " AND ' MATCH SIMILAR TO ( AND ).
;N"L	SEND COMMAND TO MATCHING ' UNLESS N<0.
;N"N	SEND COMMAND TO MATCHING ' UNLESS N NOT = 0.
;N"E	SEND COMMAND TO MATCHING ' UNLESS N=0.
;N"F	SEND COMMAND TO MATCHING ' UNLESS N=0.
;N"U	SEND COMMAND TO MATCHING ' UNLESS N=0.
;N"T	SEND COMMAND TO MATCHING ' UNLESS N<0.
;N"S	SEND COMMAND TO MATCHING ' UNLESS N<0.
;N"C	SEND COMMAND TO MATCHING ' UNLESS THE VALUE OF N AS AN ASCII
;	CHARACTER IS A LETTER, NUMBER, PERIOD (.), DOLLAR SIGN ($),
;	OR PER CENT (%).
;N"A	SEND COMMAND TO MATCHING ' UNLESS THE VALUE OF N AS AN ASCII
;	CHARACTER IS ALPHABETIC.
;N"D	SEND COMMAND TO MATCHING ' UNLESS THE VALUE OF N AS AN ASCII
;	CHARACTER IS A DIGIT.
;N"V	SEND COMMAND TO MATCHING ' UNLESS THE VALUE OF N AS AN ASCII
;	CHARACTER IS LOWER CASE ALPHABETIC.
;N"W	SEND COMMAND TO MATCHING ' UNLESS THE VALUE OF N AS AN ASCII
;	CHARACTER IS UPPER CASE ALPHABETIC.

DQUOTE:	PUSHJ	P,SKRCH		;GET CHAR AFTER "
	ERROR	E.MEQ
	CAIN	CH,"$"		;ELSE ?
	JRST	ELSE
	TRNN	FF,ARG		;ERROR IF NO ARG BEFORE "
	ERROR	E.NAQ
	MOVEI	T,DQTABL	;INDEX DISPATCH TABLE
	PUSHJ	P,DISPAT	;DISPATCH FOR CHAR. AFTER "
	ERROR	E.IQC

;" COMMAND DISPATCH TABLE

DQTABL:	XWD	DQ.G,"G"
	XWD	DQ.L,"L"
	XWD	DQ.N,"N"
	XWD	DQ.E,"E"
	XWD	DQ.C,"C"
	XWD	DQ.L,"T"
	XWD	DQ.E,"F"
	XWD	DQ.L,"S"
	XWD	DQ.E,"U"
	XWD	DQ.A,"A"
	XWD	DQ.D,"D"
	XWD	DQ.V,"V"
	XWD	DQ.W,"W"
	XWD	0,0		;END OF LIST
;EXECUTE INDIVIDUAL " COMMANDS

DQ.V:	TRZN	B,40		;EXECUTE "V
	JRST	NOGO		;IF BIT 30 NOT ON IT CAN'T BE L.C.
DQ.A:	TRZ	B,40		;EXECUTE "A -- TREAT UC & LC ALIKE
DQ.W:	CAIL	B,"A"		;EXECUTE "W
	CAILE	B,"Z"
	JRST	NOGO		;IT IS NOT A LETTER
	JRST	RET		;IT IS A LETTER
DQ.D:	CAIL	B,"0"		;EXECUTE "D
	CAILE	B,"9"
	JRST	NOGO		;IT IS NOT A DIGIT
	JRST	RET		;IT IS A DIGIT
DQ.C:	PUSHJ	P,CKSYM1	;EXECUTE "C
	JRST	RET		;IT IS A SYMBOL CHAR
	JRST	NOGO		;IT'S NOT A SYMBOL CHAR
DQ.G:	MOVNS	B		;EXECUTE "G
DQ.L:	JUMPL	B,RET		;EXECUTE "L
	JRST	NOGO		;TEST FAILED
DQ.N:	JUMPN	B,RET		;EXECUTE "N
	JRST	NOGO		;TEST FAILED
DQ.E:	JUMPE	B,RET		;EXECUTE "E, "F, "U
NOGO:	MOVEI	TT,47		;SKAN FOR '
	MOVEI	TT1,42		;IGNORE "...' STRINGS
	PUSHJ	P,SKAN
	ERROR	E.MAP
	MOVEI	CH,47	;GET '
	TRNE	FF,TRACEF	;SKIP IF TRACE OFF
	PUSHJ	P,TYOM
	MOVE	A,CPTR	;GET PTR
	ILDB	CH,A	;GET CHAR
	CAIE	CH,42	;IS IT " ?
	JRST	RET	;NO (BYE)
	PUSHJ	P,SKRCH	;GET CHAR
	ERROR	E.MEQ
	PUSHJ	P,SKRCH
	ERROR	E.MEQ
	CAIE	CH,"$"	; ?
	ERROR	E.NDL
	JRST	RET
ELSE:	MOVEI	TT,47	;GET LIMITS
	MOVEI	TT1,42
	PUSHJ	P,SKAN
	ERROR	E.MAP
	MOVEI	CH,47	;GET '
	TRNE	FF,TRACEF
	PUSHJ	P,TYOM
	JRST	RET
;ROUTINE TO TEST CHARACTER FOR $,%,.,0-9,A-Z
;CALL	PUSHJ P,CKSYM
;	RETURN IF $,%,.,0-9,A-Z
;	RETURN ON ALL OTHER CHARACTERS

CKSYM:	MOVEI	B,(CH)		;ENTER AT CKSYM1 IF CHAR ALREADY IN B
CKSYM1:	CAIE	B,"$"		;$ OR %?
	CAIN	B,"%"
	POPJ	P,		;YES
	CAIN	B,"."		;NO. POINT?
	POPJ	P,		;YES.
	CAIGE	B,"0"		;NO. DIGIT OR LETTER?
	JRST	CPOPJ1		;NO
	CAIG	B,"9"		;MAYBE. DIGIT?
	POPJ	P,		;YES.
CKSYM2:	TRZ	B,40		;LC TO UC
	CAIL	B,"A"		;LETTER?
	CAILE	B,"Z"
	JRST	CPOPJ1		;NO.
	POPJ	P,		;YES
;ERROR MESSAGE PRINTOUT

ERRP:	TRO	FF,QMFLG	;ERROR PROCEDURE IN PROGRESS
	SETZM	XSGETC	;WANT CORE MESSAGES FOR SURE
IFN CHECKP,<
	SKIPN	INDY	;SKIP IF INDIRECT
	JRST	ERRP0W
	SETZM	INDY
	SETZM	CHKEXE
	RELEAS	CHPCHN,
>
ERRP0W:	HRLZ	B,.JBUUO	;GET ERROR CODE
	TTCALL	CLRBFI,		;CLEAR TTY
	PUSHJ	P,TTOPEN
	MOVEI	CH,"?"		;TYPE ?
	PUSHJ	P,TYOM
	HLLZ	TT,B		;PRINT  CODE
	PUSHJ	P,SIXBMS
	LDB	D,[POINT 4,.JBUUO,12]	;GET SPECIAL TYPEOUT FLAG
	JUMPE	D,ERRP04	;NO SPECIAL ERROR EXTENSION
	CAIN	D,3		;FLAG=EE3?
	JRST	ERRP05		;YES
	MOVEI	CH,"-"		;YES, TYPE EXTENSION (MONITOR ERROR CODE)
	PUSHJ	P,TYOM
	LDB	B,[POINT 6,FILNAM+1,35]	;GET UUO ERROR FLAG
	SOJLE	D,ERRP03	;1 IMPLIES IT IS A UUO ERROR
	HRRZI	B,740000	;GET I-O ERROR FLAGS
	AND	B,ARGSTO
ERRP03:	PUSHJ	P,OCTMS		;TYPE ERROR CODE IN OCTAL
ERRP04:	MOVE	B,ERRLEN	;HOW MUCH MESSAGE WANTED?
	JUMPGE	B,ERRP02	;AT LEAST 1ST FULL LINE
	PUSHJ	P,CRR		;HE WANTS ONLY ?XXX, SO END LINE
	JRST	ERRP5		;BETTER SEE IF HE WANTS MORE
ERRP02:	MOVEI	CH,11		;1ST LINE OF MESSAGE AUTOMATIC
	PUSHJ	P,TYOM		;TYPE TAB
ERRP0:	SKIPE	ERRFLG	;SKIP IF NON-LOCAL ERRORS
	JRST	ERRP00	;BR IF LOCAL
	INIT	ERRCHN,0	;INIT INPUT FROM SYS:
	SIXBIT	/SYS/
	XWD	0,ERRHDR
	JRST	NOERRS		;CAN'T
	SETZM	TECERR+3
	JRST	ERRP0A
ERRP00:	INIT	ERRCHN,0
	SIXBIT	/DSK/
	XWD	0,ERRHDR
	JRST	NOERRS
	MOVE	A,[XWD 11334,247122]	;MOVE IN PPN OF MIKERUDE
	MOVEM	A,TECERR+3
ERRP0A:	MOVE	B,.JBREL	;SAVE CURRENT CORE
	MOVEM	B,RELSAV
	MOVE	TT,Z		;GET ACTUAL FIRST FREE LOC
	IDIVI	TT,5
	ADDI	TT,2
	MOVEI	T,<BUFSIZ+3>*2(TT)	;ROOM FOR 2 DISK BUFFERS?
	CAML	T,.JBFF
	PUSHJ	P,GRABJR	;NO, GET 1K CORE
	EXCH	TT,.JBFF	;GET INPUT BUFFER
	INBUF	ERRCHN,2
	MOVEM	TT,.JBFF
	MOVSI	A,(SIXBIT /ERR/)
	MOVEM	A,TECERR+1	;SET UP FILE EXTENSION
	SETZM	TECERR+2
	MOVE	A,[SIXBIT /TECOX/]
	MOVEM	A,TECERR
	LOOKUP	ERRCHN,TECERR	;FIND TECOX.ERR
	JRST	ERRP01		;NOT THERE, SO USE TECO.ERR
	JRST	ERRP1		;FOUND
ERRP01:	HRL	A,JOBN		;GET JOBNUMBER
	HRRI	A,JBTPRG	;& JOBNAME TABLE ADDRESS
	CALLI	A,GETTAB	;GET JOBNAME
	JRST	NOERRS		;CAN'T
	MOVEM	A,TECERR	;SET FILE NAME
	LOOKUP	ERRCHN,TECERR	;LOOKUP JOBNAME.ERR
	JRST	NOERRS		;NOT ON DEVICE
ERRP1:	PUSHJ	P,ERRCHR	;GET A CHAR. FROM TECOX.ERR
	CAIE	CH,"?"		;LOOK FOR START OF A MESSAGE
	JRST	ERRP1		;NO, TRY NEXT
	SETZ	T,		;YES, INIT RESULT ACCUMULATOR
	HRRZ	D,.JBUUO	;GET ERROR CODE AGAIN
ERRP2:	PUSHJ	P,ERRCHR	;GET NEXT CHAR
	CAIN	CH,11		;TAB?
	JRST	ERRP3		;YES
	LSH	T,6		;SCALE PREV. RESULT UP ONE CHAR
	ADDI	T,-40(CH)	;ADD NEW SIXBIT CHAR TO PREVIOUS RESULT
	JRST	ERRP2
ERRP3:	CAME	D,T		;IS THIS CODE EQUAL TO THE ERROR CODE?
	JRST	ERRP1		;NO, KEEP GOING
	PUSHJ	P,ERRPRN	;YES, PRINT EVERYTHING UP TO THE LF
	TRO	FF,EMFLAG	;NOTE THAT THE 1ST LINE HAS BEEN TYPED
	JRST	ERRP5
NOERRS:	TRO	FF,XPLNFL+EMFLAG	;CANT DO /
	JSP	A,CONMES	;PRINT BAD NEWS
	ASCIZ	/
?EEE	Unable to Read Error in Message File
/
ERRP5:	MOVE	A,COMAX
	SUB	A,COMCNT
	MOVEM	A,ERR1		;ERR1:=COMAX-COMCNT
	MOVE	A,CPTR
	MOVEM	A,ERR2		;ERR2:=CPTR
	MOVE	A,ERRLEN	;DOES HE WANT THE WHOLE THING AUTOMATICALLY?
	TRNN	FF,XPLNFL	;[162]
	JUMPG	A,XPLAIN	;YES

ERRP6:
IFN CCL,<
	SKIPN	CCLSW	;GET HERE FROM A "TECO" COMMAND?
	JRST	ERRP6A		;NO
	JRST	DECDMP		;YES, POP UP TO MONITOR
>
ERRP6A:	MOVEI	CH,"*"		;TYPE * FOR NEXT COMMAND
	PUSHJ	P,TYOM
	TRO	FF,DDTMF
	PUSHJ	P,TYI		;GET A CHARACTER NOW
	CAIN	CH,"?"		;QUESTION MARK?
	JRST	ERRTYP		;YES, TYPE BAD COMMAND
	TRNE	FF,XPLNFL	;EXPLANATION TYPED YET?
	JRST	ERRP7		;YES, CAN'T DO THAT AGAIN
	CAIE	CH,"/"		;NO, IS IT A SLASH?
	JRST	ERRP7		;NO
	TRNN	FF,EMFLAG	;YES, 1ST LINE DONE YET?
	JRST	ERRP0		;NO
	JRST	XPLAIN		;OK, TYPE MORE EXPLANATION OF ERROR

ERRP7:	RELEAS	ERRCHN,
;ERRP7+1 INSERTED 2 INSTRUCTIONS		[ED#125]
	TRNN	FF,XPLNFL+EMFLAG	;MED OF LONG MSG TYPED?
	JRST	GOE		;NO, SKIP CORE CONTRACTN
	MOVE	B,RELSAV	;GO BACK TO CORE WE HAD BEFORE
	CALLI	B,CORE
	JFCL			;REDUCTION WON'T FAIL
	JRST	GOE		;GET REST OF COMMAND

U TECERR,4			;LOOKUP SPECS FOR TECO.ERR
U ERRHDR,3			;RING HEADER FOR TECO.ERR
U RELSAV,1			;STORE FOR .JBREL
U ARGSTO,1			;STORE FOR ARGUMENT (IF ANY)
ERRPRN:	PUSHJ	P,ERRCHR	;GET A CHAR FROM ERR. FILE
ERRPR2:	CAIE	CH,16		;^N?
	JRST	ERRPR3		;NO, SKIP
	PUSHJ	P,ERRCHR	;GET 1ST DIGIT AFTER ^N
	MOVEI	T,-60(CH)
	IMULI	T,^D10		;PUT IT IN TEN'S PLACE
	PUSHJ	P,ERRCHR	;GET 2ND DIGIT
	ADDI	T,-60(CH)
	ROT	T,-1		;DIVIDE TOTAL BY 2 & SAVE BIT 35
	HLRZ	CH,ETABL(T)	;GET LEFT SIDE ADDR IN CASE EVEN
	TLNE	T,400000	;EVEN OR ODD?
	HRRZ	CH,ETABL(T)	;ODD, GET ADDR FROM RIGHT SIDE
	JRST	(CH)		;TYPE SPECIAL INFORMATION

ERRPR3:	PUSHJ	P,TYOM		;PRINT NORMAL CHARS.
	CAIE	CH,12		;LF?
	JRST	ERRPRN		;NO
	POPJ	P,

;GET A CHARACTER FROM SYS:TECO.ERR

ERRCHR:	SOSG	ERRHDR+2	;ANY CHARS. IN BUFFER?
	JRST	ERRCH2		;NO
ERRCH1:	ILDB	CH,ERRHDR+1	;YES, GET NEXT
	JUMPE	CH,ERRCHR	;IGNORE NULLS
	POPJ	P,
ERRCH2:	IN	ERRCHN,0	;GET NEXT BUFFER
	JRST	ERRCH1		;OK, NOW GET A CHAR.
ERRCH3:	POP	P,A		;UNABLE TO READ TECO.ERR
	JRST	NOERRS

;GET 1K CORE FOR ERROR MESSAGE FILE READ-IN

GRABJR:	ADDI	B,^D1024	;ADD 1K
	CALLI	B,CORE
	JRST	ERRCH3		;CAN'T GET IT
	POPJ	P,

;CAN'T PRINT ERROR FILE BECAUSE OF NO CORE

ERRP05:	TRO	FF,XPLNFL+EMFLAG
	JSP	A,CONMES
	ASCIZ	/	Storage Capacity Exceeded
/
	JRST	ERRP5
;ROUTINE TO TYPE C(TT) IN SIXBIT
;CALL	MOVE TT,[SIXBIT /MESSAGE/]
;	PUSHJ P,SIXBMS
;	RETURN


SIXBMS:	SKIPN	CH,TT		;ALL SPACES?
	JRST	SIXBM2		;YES
	MOVNI	B,6
	MOVE	E,[POINT 6,TT]
	ILDB	CH,E
	JUMPE	CH,CPOPJ
SIXBM2:	ADDI	CH,40
	PUSHJ	P,TYOM
	AOJL	B,.-4
	POPJ	P,
ERRTYP:	MOVE	AA,ERR2		;VALUE OF CPTR WHEN LAST ERROR OCCURRED.
	MOVEI	B,12
	SUBI	AA,2		;BACK POINTER UP 10 CHARACTERS.
	ILDB	CH,AA		;GET CHARACTER
	CAMG	B,ERR1		;WAS IT IN THE COMMAND BUFFER?
	PUSHJ	P,TYOM		;YES. TYPE IT.
	CAME	AA,ERR2		;HAVE WE REACHED THE BAD COMMAND?
	SOJA	B,.-4		;NO. DO IT AGAIN.
	JSP	A,CONMES	;PRINT A ? TO MARK END
	ASCIZ	/?
/
	JRST	ERRP6A

XPLA2:	PUSHJ	P,ERRPR2	;PRINT UP TO LF
XPLAIN:	PUSHJ	P,ERRCHR	;IS NEXT CHAR A "?" OR ^A,^B, ... ^H?
	CAIN	CH,"?"
	JRST	XPLA1		;YES
	CAILE	CH,10
	JRST	XPLA2		;NO, KEEP GOING
XPLA1:	TRO	FF,XPLNFL	;SET FLAG THAT XPLANATION IS TYPED
	JRST	ERRP6		;YES, STOP HERE

U ERR1,1			;
U ERR2,1			;
U COMLEN,1			;LENGTH OF BASIC COMMAND STRING
;DISPATCH TABLE FOR SPECIAL INFORMATION TYPEOUT
;BASED ON CHARACTER AFTER CONTROL-N

ETABL:	XWD	ECOMCH,EOUTFL	;00  01
	XWD	EFILEN,EERNUM	;02  03
	XWD	EDEVNM,EPROJN	;04  05
	XWD	EARG1,EPROTC	;06  07
	XWD	EEBFN,EINFIL	;08  09
	XWD	EEBFIL,EIOFLG	;10  11
	XWD	ESTAB,ESKIP	;12  13
	XWD	EISKIP,0	;14  15
	XWD	EEOVAL,EESRCH	;16  17
	XWD	EECTRL,EESWIT	;18  19
;SPECIAL INFORMATION TYPEOUT ROUTINES


EECTRL:	SKIPA	CH,ARGSTO	;GET BAD CHAR FROM TEXT STRING
ECOMCH:	LDB	CH,CPTR		;GET LAST COMMAND STRING CHAR.
	PUSHJ	P,TYOS
	JRST	ERRPRN

EOUTFL:	MOVEI	TT1,OUTFIL	;AIM AT OUTPUT FILENAME
EOUTF2:	MOVE	TT,(TT1)
	PUSHJ	P,SIXBMS	;PRINT FILENAME
	HLLZ	TT,1(TT1)
	JUMPE	TT,ERRPRN	;SKIP REST IF NO EXTENSION
	MOVEI	CH,"."
	PUSHJ	P,TYOM
EOUTF3:	PUSHJ	P,SIXBMS	;PRINT EXTENSION
	JRST	ERRPRN

EFILEN:	MOVEI	TT1,FILNAM	;GET FILENAME REF'D BY UUO
	JRST	EOUTF2

EERNUM:	LDB	B,[POINT 6,FILNAM+1,35]	;GET 2-DIGIT ERROR CODE
EERNU1:	PUSHJ	P,OCTMS		;TYPE IT
	JRST	ERRPRN

EDEVNM:	MOVE	TT,FILDEV	;GET DEVICE NAME
	JRST	EOUTF3

EPROJN:	HLRZ	B,FILNAM+3	;TYPE PROJECT NUMBER
	PUSHJ	P,OCTMS
	MOVEI	CH,","		;TYPE COMMA
	PUSHJ	P,TYOM
	HRRZ	B,FILNAM+3	;TYPE PROGRAMMER NUMBER
	JRST	EERNU1

EESWIT:	MOVE	TT,SWITHL	;GET I/O SWITCH NAME
	JRST	EOUTF3

EARG1:	MOVE	B,ARGSTO	;GET ARG BACK
EARG1A:	PUSHJ	P,DECMS		;PRINT IT
	JRST	ERRPRN

EPROTC:	LDB	B,[POINT 9,FILNAM+2,8]	;GET FILE PROTECTION
	JRST	EERNU1

EEBFN:	MOVE	TT,BAKNAM	;EB FILENAME
	JRST	EOUTF3		;PRINT IT WITHOUT EXTENSION

EINFIL:	MOVEI	TT1,INFILE	;AIM AT INPUT FILENAME
	JRST	EOUTF2

EEBFIL:	MOVEI	TT1,BAKNAM	;AIM AT EB ORIGINAL FILENAME
	JRST	EOUTF2
EIOFLG:	HRRZI	B,740000	;RETRIEVE I/O ERROR FLAGS
	AND	B,ARGSTO
	JRST	EERNU1

ESTAB:	MOVEI	TT,STAB		;INDEX STAB WHERE TAG RESIDES
ESTAB1:	MOVE	CH,(TT)
	JUMPE	CH,ERRPRN	;THAT'S ALL
	PUSHJ	P,TYOS
	AOJA	TT,ESTAB1

EISKIP:	LDB	TT,[POINT 4,ARGSTO,21]	;GET I/O ERROR FLAGS
	SKIPA
ESKIP:	LDB	TT,[POINT 6,FILNAM+1,35]
ESKIP2:	PUSHJ	P,ERRCHR	;LOOK FOR ^A
	CAIN	CH,2		;^B ENCOUNTERED?
	JRST	ERRPRN		;YES, PRINT DEFAULT MESSAGE
	CAIE	CH,1
	JRST	ESKIP2		;NOT ^A
	PUSHJ	P,ERRCHR	;GET 1ST DIGIT AFTER ^A
	MOVEI	T,-60(CH)
	LSH	T,3		;MULT BY 8
	PUSHJ	P,ERRCHR	;GET NEXT DIGIT
	ADDI	T,-60(CH)
	CAME	TT,T		;THIS THE NUMBER WE WANT?
	JRST	ESKIP2		;NO
	JRST	ERRPRN		;YES, NOW START PRINTING

EEOVAL:	MOVEI	B,EOVAL		;GET MAXIMUM EOFLAG FOR THIS VERSION
	JRST	EARG1A

EESRCH:	MOVE	TT,[POINT 7,SRHARG]	;GET PTR TO SEARCH STRING
	MOVE	B,SRHCTR	;& STRING CTR
EESRH2:	ILDB	CH,TT		;GET STRING CHAR
	PUSHJ	P,TYOS		;TYPE IT
	SOJE	B,ERRPRN	;WATCH STRING CTR
	JRST	EESRH2		;NOT FINISHED YET
;UUO HANDLER

UUOH:
IFN PDP6,<0>			;PDP-6 JSR ENTRY
	MOVEM	B,ARGSTO	;SAVE POSSIBLE ARG
	LDB	B,[POINT 9,.JBUUO,8]	;GET UUO TYPE
	CAIL	B,20		;CHKEO?
	JRST	CEO		;YES
	CAIN	B,1		;ERROR UUO?
	JRST	ERRP		;YES
UUOERR:	MOVEM	B,FILNAM+3
	HRRZ	B,(P)		;ADDRESS OF ILLEGAL UUO
	SUBI	B,1
	ERROR	E.UUO

U LISTF5,1			;OUTPUT DISPATCH

;CHKEO EO#,ADDR
;IF EOFLAG > EO#, RETURN AT CALL+1 (FEATURE IS LEFT ON)
;OTHERWISE GO TO ADDR (FEATURE IS TURNED OFF)

CEO:	PUSH	P,A		;SAVE AC
	LDB	B,[POINT 8,.JBUUO,12]	;GET EO TEST VALUE
	MOVE	A,EOFLAG	;GET LAST SETTING OF EOFLAG
	CAIG	A,(B)		;EOFLAG > TEST VALUE?
	JRST	CEO1		;NO
CEO2:	POP	P,A		;RESTORE AC A
	MOVE	B,ARGSTO	;RESTORE AC B
IFE PDP6,<POPJ	P,>		;RETURN
IFN PDP6,<JRST	@UUOH>

CEO1:	HRRZ	A,.JBUUO	;GET DISPATCH ADDR
	HRRM	A,-1(P)		;PUT ON PDL AS RET. ADDR.
	JRST	CEO2
;COMMAND TO COMPLEMENT TRACE MODE. "?" AS A COMMAND

QUESTN:	SKIPN	SILENT
	JRST	QUEST2
	SKIPE	CHKEXE
	JRST	RET
	SETZM	SILENT
QUEST2:	Trcn	FF,TRACEF	;COMPLEMENT TRACE FLAG
	JRST	RET
	pushj	p,crr
	jrst	ret

COMMEN:	PUSHJ	P,SKRCH		;GET A COMMENT CHAR
	ERROR	E.UCA
	CAIN	CH,1		;^A
	JRST	RET		;DONE
	TRNN	FF,TRACEF	;OMIT DOUBLE TYPE-OUT WHEN TRACING
	PUSHJ	P,TYOM		;TYPE IT
	JRST	COMMEN

;OLD ^G EXIT COMMAND AND ILLEGAL COMMANDS

BELDMP:	CHKEO	EO21,DECDMP	;IF EO=1, DO ^Z, OTHERWISE ^G IS ILLEGAL

ERRA:	ERROR	E.ILL
;ROUTINE TO RETURN STRING OPERATION STRING ARGUMENTS.
;ARGUMENTS ARE CHARACTER ADDRESSES IN THE DATA BUFFER.
;TRANSFORMS M,N OR N, WHERE THE LATTER SPECIFIES A NUMBER OF LINES,
;TO ARGUMENTS.
;CALL	PUSHJ P,GETARG
;	RETURN WITH FIRST ARGUMENT ADDRESS IN C, SECOND IN B.
;IF THE EO VALUE HAS BEEN SET TO 1, THE ONLY EOL CHAR IS LINE FEED.
;IF EO > 1, THE EOL CHARS ARE LF, VT, AND FF (& END OF BUFFER IF
;LAST CHAR IN BUFR IS NOT AN EOL)

GETARG:	TRNE	FF,ARG2		;IS THERE A SECOND ARGUMENT?
	JRST	GETAG6		;YES

;N	SIGN INDICATES DIRECTION RELATIVE TO PT.
GETNAG:	PUSHJ	P,CHK2		;NO, GET 1ST ARG (+ OR - 1 IF NONE THERE)
	MOVE	I,PT		;IN:=PT
GETAG4:	JUMPLE	B,GETAG2	;WAS LAST ARGUMENT FUNCTION -?
	CAMN	I,Z		;NO. ARGUMENT IS LOCATION OF NTH EOL FORWARD FROM PT.
				;IS PT AT END OF BUFFER?
	JRST	GETAG1		;YES.
	PUSHJ	P,GETINC	;NO. CH:=NEXT DATA BUFFER CHARACTER, IN:=IN+1
	PUSHJ	P,CKEOL		;IS IT AN EOL?
	JRST	GETAG4		;NO. TRY AGAIN.
	SOJG	B,GETAG4	;YES. NTH EOL?

GETAG1:	MOVE	B,I		;YES. RETURN FIRST ARGUMENT IN C
	MOVE	C,PT		;SECOND IN B.
	POPJ	P,

;M,N
GETAG6:	ADD	B,BEG		;C:=M+BEG
	ADD	C,BEG		;B:=N+BEG
	POPJ	P,

GETAG2:	SOS	I		;SET I FOR CHAR BEFORE PT
	CAMGE	I,BEG		;PASSED BEGINNING OF BUFFER?
	JRST	GETAG3		;YES. IN:=BEG
	PUSHJ	P,GETINC	;NO. CH:=NEXT DATA BUFFER CHARACTER. IN:=IN+1
	PUSHJ	P,CKEOL		;IS IT AN EOL?
	SOJA	I,GETAG2	;NO. BACK UP ONE POSITION AND TRY AGAIN.
	SOS	NUMFLG	;DECR BACKUP COUNT
	AOJLE	B,.-2		;YES. NTH EOL?

GETAG3:	CAML	I,BEG		;YES. PASSED BEGINNING OF BUFFER?
	JRST	GETAGZ
	MOVE	I,BEG		;YES. RESET TO BEGINNING.
	SOS	NUMFLG
GETAGZ:	AOSLE	NUMFLG
	SETZM	NUMFLI
	MOVE	C,I		;NO. RETURN FIRST ARGUMENT IN C.
	MOVE	B,PT		;SECOND IN B
	POPJ	P,
;ROUTINE TO RETURN IN CH THE CHARACTER TO THE RIGHT OF THE POINTER
;AND INCREMENT THE POINTER.
;CALL	MOVE I,POINTER (AS A CHARACTER ADDRESS)
;	PUSHJ P,GETINC
;	RETURN WITH CHARACTER IN CH AND POINTER TO CHARACTER IN IN.

GETINC:	PUSHJ	P,GET
	AOJA	I,CPOPJ

GET:	MOVE	TT,I
	IDIVI	TT,5
	HLL	TT,BTAB(TT1)
	LDB	CH,TT
	POPJ	P,

PUT:	MOVE	TT,OU
	IDIVI	TT,5
	HLL	TT,BTAB(TT1)
	DPB	CH,TT
	POPJ	P,

;CHARACTER TRANSLATION BYTE POINTER TABLE
;TRANSLATES 1 CHARACTER POSITION TO THE RIGHT OF A CHARACTER ADDRESS POINTER

BTAB:	XWD	350700,0
	XWD	260700,0
	XWD	170700,0
	XWD	100700,0
	XWD	10700,0

;CHECK IF CH = EOL CHARACTER
;CALL:	PUSHJ	P,CKEOL
;	RETURN IF CH NOT = EOL
;	RETURN IF CH IS EOL CHAR

CKEOL:	CAIN	CH,12		;LINE FEED?
	JRST	CPOPJ1		;YES, IT IS AN EOL!
	CHKEO	EO21,CPOPJ	;IF EO=1, LF IS ONLY POSSIBLE EOL
	CAIE	CH,13		;VERTICAL TAB?
	CAIN	CH,14		;FORM FEED?
	AOS	(P)		;YES, SKIP RETURN
	POPJ	P,		;NO
NROOMC:
IFN VC,<MOVEM	C,VVAL>		;SAVE LENGTH OF STRING
NROOM:	MOVEM	17,AC2+15	;SAVE 17
	MOVEI	17,NROOM9	;ANTICIPATE GARBAGE COLLECTION
	MOVEM	17,GCRET	;THIS THE EXIT DISPATCH
	SETZM	CRREL
	SETZM	RREL
	MOVE	17,PT
	CAMN	17,Z		;PT=Z? I.E., DATA BUFFER EXPANSION?
	JRST	NROOM1		;YES.
NROOM0:	MOVE	17,[XWD 2,AC2]	;NO. SAVE ACS 2 THROUGH 16.
	BLT	17,AC2+14
	JUMPL	C,NROOM6	;DELETION?
	SETOM	GCFLG		;NO.

;MOVE STRING STORAGE UP C CHARACTERS STARTING AT PT.

NROOM9:	MOVE	17,Z
	ADD	17,C
	CAML	17,MEMSIZ	;WILL REQUEST OVERFLOW MEMORY?
	JRST	GC		;YES. GARBAGE COLLECT.
;MOVE FROM PT THROUGH Z UP C POSITIONS
	MOVE	14,C		;NO.
	IDIVI	14,5		;AC14:=Q(REQ/5), AC15:=REM(REQ/5)
	IMULI	15,7		;AC15:=(REM(REQ/5))*7
	MOVN	13,15		;AC13:=-(REM(REQ/5))*7
	MOVEI	15,-43(15)	;AC15:=(REM(REQ/5))*7-43
	MOVE	11,PT
	IDIVI	11,5		;AC11:=Q(PT/5), AC12:=REM(PT/5)
	MOVNI	16,-5(12)
	IMULI	16,7		;AC16:=-(REM(PT/5)-5)*7
	DPB	16,[XWD 300600,NROOM2]	;SET SIZE FIELD OF LAST PARTIAL WORD POINTER.
	ADDI	14,1(11)	;AC14:=Q(REQ/5)+Q(PT/5)+1
	MOVE	16,Z
	IDIVI	16,5		;AC16:=Q(Z/5)
	MOVEI	B,1(16)
	SUB	B,11		;B:=Q(Z/5)+1-Q(PT/5)=NO. OF WORDS TO MOVE.
;PUT MOVE ROUTINE IN FAST ACS
	HRLI	11,200000+B+A*40	;AC11:=MOVE A,[Q(PT/5)](B)
	HRLOI	12,241000+A*40	;AC12:=ROT A,-1
	HRLI	13,245000+A*40	;AC13:=ROTC A,-(REM(REQ/5))*7
	HRLI	14,202000+B+AA*40	;AC14:=MOVEM AA,[Q(PT/5)+1](B)
	HRLI	15,245000+A*40	;AC15:=ROTC A,(REM(REQ/5))*7-43
	MOVE	17,[JRST,NROOM7]	;AC16:=SOJGE B,11
	MOVE	16,.+1		;AC17:=JRST NROOM7
	SOJGE	B,11		;B:=B-1. DONE?
NROOM7:	ROTC	A,43(13)	;YES. STORE LAST PARTIAL WORD.
	DPB	A,NROOM2
	ADDM	C,Z		;Z:=Z+REQ
NROOM5:	MOVE	17,[XWD 2,AC2]	;RESTORE ACS AND RETURN.
	MOVSS	17
	BLT	17,17
	POPJ	P,


U NROOM2,1			;POINTER TO LAST PARTIAL WORD ON UPWARD MOVE.
;A CALL FOR A BUFFER EXPANSION, WHERE PT=Z. IF
;THERE IS NOT ENOUGH ROOM, PERFORM THE GARBAGE COLLECTION ROUTINE
;IF THERE IS STILL NO ROOM, GET THE NECESSARY CORE FROM THE 
;MONITOR TO SATISFY THIS REQUEST

NROOM1:	ADD	17,C		;TOTAL SPACE REQUIREMENT
	CAMG	17,MEMSIZ	;IS THERE ENOUGH?
	JRST	.+4		;YES, THEREFORE, UPDATE Z AND EXIT
	MOVEI	17,GCRETA	;EXIT DISPATCH FOR THE
	MOVEM	17,GCRET	;GARBAGE COLLECTION ROUTINE
	JRST	NROOM0		;GO DO THE GARBAGE COLLECTION
	ADDM	C,Z		;UPDATE Z, SIZE IS OK
	MOVE	17,AC2+15	;RESTORE AC#17
	POPJ	P,		;EXIT OUT


;NOT ENOUGH ROOM FOR THE EXPANSION, GARBAGE COLLECTION HAS BEEN
;PERFORMED, IF NEED BE, GRAB A K FROM THE MONITOR (OR MORE)

GCRETA:	MOVE	17,Z		;GET TOTAL SO FAR
	ADD	17,C		;ADD IN THE REQUEST
	CAML	17,MEMSIZ	;STILL IN NEED OF CORE?
	PUSHJ	P,GRABAK	;YES, GET THE REQUIRED CORE FROM THE MONITOR
	ADDM	C,Z		;UPDATE Z AND EXIT
	JRST	NROOM5		;RESTORE ALL AC'S AND RETURN TO SEQUENCE

U GCRET,1			;GC EXIT DISPATCH
;MOVE FROM PT+ABS(C) THROUGH Z DOWN ABS(C) POSITIONS
NROOM6:	MOVE	14,PT		;INITIALIZE PARTIAL WORD POINTER.
	IDIVI	14,5		;AC14:=Q(PT/5), AC15:=REM(PT/5)
	MOVEM	14,B		;B:=Q(PT/5)
	HRRZM	14,NROOM4
	IMULI	15,7
	DPB	15,[XWD 300600,NROOM4]	;SIZE:=(REM(PT/5))*7
	MOVNI	15,-44(15)
	DPB	15,[XWD 360600,NROOM4]	;POSITION:=44-(REM(PT/5))*7
	MOVE	11,Z
	IDIVI	11,5		;AC11:=Q(Z/5)+1, AC12:=REM(Z/5)
	ADDI	11,1
	MOVE	13,C
	IDIVI	13,5
	ADDI	13,-1(11)	;AC13:=Q(Z/5)-Q(REQ/5)
	MOVNM	14,12		;AC12:=(REM(REQ/5))*7
	IMULI	12,7
	MOVNI	15,-43(12)	;AC15:=43-(REM(REQ/5))*7
	SUBI	B,1(13)		;B:=Q(PT/5)+Q(REQ/5)-Q(Z/5)-1:=# WORDS TO MOVE

NROOM8:	HRLI	11,200000+B+AA*40	;AC11:=MOVE AA,[Q(Z/5)+1](B)
	HRLI	12,245000+A*40	;AC12:=ROTC A,(REM(REQ/5))*7
	HRLI	13,202000+B+A*40	;AC13:=MOVEM A,[Q(Z/5)-Q(REQ/5)](B)
	MOVE	14,[ADDM A,@13]	;AC14:=ADDM A,@13
	HRLI	15,245000+A*40	;AC15:=ROTC A,43-(REM(REQ/5))*7
	MOVE	17,[JRST NROOM3]	;AC16:=AOJLE B,11
	ADDM	C,Z		;AC17:=JRST NROOM3
	LDB	C,NROOM4
	MOVE	A,@11		;Z:=C(Z)-REQ
	ROT	A,-1		;A:=Q(PT/5)+Q(REQ/5) RIGHT JUSTIFIED.
	MOVE	16,.+1
	AOJLE	B,11		;B:=B+1.  DONE?

NROOM3:	DPB	C,NROOM4	;YES. DEPOSIT PARTIAL WORD.
	JRST	NROOM5

U NROOM4,1			;PARTIAL WORD POINTER FOR DOWNWARD MOVE
GC:	AOSE	GCFLG		;FIRST ATTEMPT?
	JRST	PRENR9		;TRY TO EXPAND MEMORY
	SETOM	GCPTR		;YES. GCPTR:=-1
	SETZM	SYMS		;CLEAR SYMS,VALS AND CNTS TABLES
	MOVE	T,[XWD SYMS,SYMS+1]
	BLT	T,SYMEND-1
	MOVEI	T,CPTR		;COMMAND BUFFER
	PUSHJ	P,GCMA
	MOVEI	T,(P)
	PUSHJ	P,GCMA		;NO. GARBAGE COLLECT ALL BYTE POINTERS ON IT.
	CAILE	T,PDL+1
	SOJA	T,.-2
	HRRZ	T,AC2+PF-2	;GARBAGE COLLECT Q-REG PUSHDOWN LIST.
	CAIL	T,PFL
	PUSHJ	P,GCM
	CAILE	T,PFL
	SOJA	T,.-2
	MOVE	T,[XWD -6-44-44,QTABSP]	;GARBAGE COLLECT Q-REGISTERS.
	PUSHJ	P,GCM
	AOBJN	T,.-1
	MOVE	I,BEG		;MAKE SURE STUFF BEFORE BEG
	SUB	I,QRBUF		;IS COLLECTED
	MOVEI	T,0		;MARK THIS AS LAST COLLECTION
	PUSHJ	P,GCM3		;STORE IT ON TH GC LIST
	MOVE	I,QRBUF
GCS1A:	MOVSI	TT,200000	;TT>MAX. NO. CHARACTERS IN WORLD
	MOVE	OU,GCPTR	;GO BACKWARDS THROUGH GCTAB
GCS1:	HRRZ	A,GCTAB(OU)	;RELOCATE
	ADD	A,QRBUF
	CAMGE	A,I
	JRST	GCS2
	CAMGE	A,TT		;SET TT TO HIGHEST CHARACTER POSITION
	MOVE	TT,A
GCS2:	SOJGE	OU,GCS1
;GCS2+1	TWO INSTRUCTIONS INSERTED [EDIT#116]
	CAMN	TT,[1B1]	;ANYTHING IN GCTAB?  [EDIT#116]
	JRST	GCS4A		;NO,DON'T SAVE INFINITY[EDIT#116
	MOVE	F2,TT		;HIGHEST CHARACTER.
	IDIVI	I,5		;C(QRBUF)/5
	IDIVI	F2,5		;HIGH CHAR/5
	AOS	I		;C(QRBUF)/5+1
	MOVS	OU,F2
	MOVE	T,F2
	SUB	T,I		;HIGH CHAR/5-C(QRBUF)/5+1
	JUMPLE	T,GCS4A		;ANYTHING TO GET?
	HRR	OU,I		;XWD HIGH CH/5,C(QRBUF)/5+1=NREG
	MOVE	B,Z		;GET TOP OF BUFR FOR BLT
	HRRZ	F2,(P)		;SEE WHO CALLED NROOM
	CAIN	F2,YANK6	;WAS IT APPEND?
	MOVE	B,AC2+OU-2	;YES, MUST USE THE REAL Z FOR THE BLT
	IDIVI	B,5
	SUB	B,T		;Z/5-NREG
	BLT	OU,(B)		;MOVE STUFF DOWN
	MOVNS	OU,T
	IMULI	OU,5		;OUT:=-5*NREG
	ADDM	OU,BEG		;BEG:=C(BEG)-5*NREG
	ADDM	OU,PT		;PT:=C(PT)-5*NREG
	ADDM	OU,Z		;Z:=C(Z)-5*NREG
	ADDM	OU,RREL		;RREL:=C(RREL)-5*NREG
	MOVE	CH,GCPTR	;UPDATE INSERTER
GCS3:	HRRZI	TT1,GCTAB(CH)
	HRRZ	A,(TT1)
	ADD	A,QRBUF
	CAMGE	A,TT
	JRST	GCS4
	ADDM	OU,(TT1)
	HLRZ	A,(TT1)
	JUMPE	A,GCS4		;NO PTR TO BEG
	CAIN	A,CPTR		;IN COMMAND BUFFER?
	ADDM	T,CRREL		;YES. UPDATE COMMAND POINTER RELOCATION
	SKIPL	(A)		;Q-REG?
	ADDM	T,(A)		;NO
	SKIPGE	(A)		;Q-REG?
	ADDM	OU,(A)		;YES. RELOCATE BASE POINTER.

GCS4:	SOJGE	CH,GCS3		;DONE?
	ADD	TT,OU		;YES. IN:=C(TT)-5*NREG

GCS4A:	CAML	TT,BEG		;LAST COLLECTION?
	JRST	@GCRET		;YES, RETURN
	MOVE	I,TT
	PUSH	P,C
	PUSHJ	P,GTQCNT
	ADD	I,C
	POP	P,C
	JRST	GCS1A
GCM:	MOVE	I,(T)
	TLZE	I,400000	;DOES Q-REG CONTAIN TEXT?
	TLZE	I,377770
	POPJ	P,		;NO
	ADD	I,QRBUF		;YES. ENTER POINTER IN GCTAB

GCM2:	CAML	I,BEG		;REGION BEFORE TEXT BUFFER?
	POPJ	P,		;NO. FORGET IT.
	SUB	I,QRBUF		;YES. IN:=# CHARACTERS TO RETREIVE.
				; IN Q-REG BUFFER AREA?
	JUMPL	I,CPOPJ		;NO. FORGET IT.
GCM3:	AOS	TT,GCPTR	;YES. TO BE GRABBED.
	CAIL	TT,GCTBL	;AM I WINNING?
	ERROR	E.GCE
	HRL	I,T		;XWD ADDRESS OF BYTE POINTER,NO. CHARACTERS
	MOVEM	I,GCTAB(TT)	;SAVE DATA
	POPJ	P,		;DONE THIS POINTER

;IF T POINTS TO AN ASCII BYTE POINTER, IN:=CHARACTER ADDRESS OF TOP
;OF STRING - NO. OF CHARACTERS.
GCMA:	HLRZ	TT,(T)		;LEFT HALF OF PTR
	TRC	TT,700		;DOES T POINT TO A TEXT BYTE POINTER?
	TRNE	TT,7700
	POPJ	P,		;NO
	MOVE	I,-1(T)		;MAYBE. GET WORD BEFORE POINTER. (MAX)
	SUB	I,1(T)		;MAX-CT
	LSH	TT,-14		;BYTE POSITION
	IDIVI	TT,7		;NO. OF CHARACTERS
	MOVEI	TT1,4-3+1	;2
	SUB	TT1,TT		;2-NO. OF CHARACTERS
	HRRZ	TT,(T)		;POINTER WORD ADDRESS (UNRELOCATED)
	IMULI	TT,5		;5*ADDRESS
	ADD	TT,TT1
	SUBM	TT,I		;5*ADDRESS-NO. CHARS+2+CT-MAX
	JRST	GCM2
;**********AUTOMATIC MEMORY EXPANSION*********

;MEMORY WILL BE EXPANDED UNDER ONE OF THESE CONDITIONS.

;	1.AN INTERNAL BUFFER EXPANSION CANNOT BE PERFORMED,
;	  TO DO SO WOULD OVERFLOW THE PRESENT MEMORY
;	  CAPACITY. THE INTERNAL OPERATIONS WHICH DESCOVER
;	  THE NEED FOR EXPANSION ARE:

;	  A.COMMAND BUFFER EXPANDING
;	  B.THE Q-REG GET (GI)
;	  C.THE Q-REG LOAD (NXI)
;	  D.ANY OF THE INSERTS
;	  E.COMMAND ACCEPTANCE ROUTINE


;	2.THE DATA BUFFER WILL BE MAINTAINED AT A MINIMUM
;	  NUMBER OF 5000 CHARACTERS BEFORE NEW DATA IS LOADED
;	  FROM AN INPUT DEVICE OTHER THAN THE CONSOLE. Q-REG
;	  USAGE SHORTENS THE NUMBER OF AVAILABLE CHARACTERS
;	  DIRECTLY, AND NORMAL TECO COMMANDS ARE GREATLY IMPARED
;	  OTHERWISE.


;SAVE THE ACCUMULATORS


GRABAK:	SKIPN	XSGETC	;SKIP FOR QUIET GRAB IF SET
	TLOA	FF,GKTLKF	;TALKATIVE GRAB
GRABKQ:	TLZ	FF,GKTLKF	;GRAB A K QUIETLY
	MOVEM	CH,SAV16	;TO SAVE THE ACCUMULATORS
	MOVEI	CH,SAVE		;WHILE WE SCOOT ALL OVER THE
	BLT	CH,SAV16-1	;THE PLACE

;COUNT THE NUMBER OF BLOCKS NEEDED TO FILL THE REQUEST

	MOVEI	F2,^D4096	;4 BLOCK OF CORE
	MOVEI	B,1		;WE WILL NEED AT LEAST ONE BLOCK
	ADDM	F2,.JBFF	;UP THE FIRST FREE COUNT
	PUSHJ	P,CRE23		;COMPUTE A NEW MEMSIZ AND 2/3 VALUE
	CAML	17,MEMSIZ	;WILL THIS BE ENOUGH CORE?
	AOJA	B,.-3		;NO, COMPUTE ANOTHER BLOCK
;NUMBER OF BLOCKS HAVE BEEN FOUND
;OBTAIN THE NEEDED CORE FROM THE MONITOR

	MOVE	B,.JBFF		;TO HELP OUT THE MONITOR
	CAIL	B,HIGSTR	;CROSS OVER ?
	JRST	NOTANY		;GIVES UP WITHOUT A FIGHT
	CALLI	B,CORE		;MAKE THE CALL TO THE MONITOR
	JRST	NOTANY		;NO CORE (OR NOT ENOUGH) AVAILABLE
	TLNN	FF,GKTLKF	;MESSAGE DESIRABLE?
	JRST	EXITZ		;NO
	MOVEI	CH,"["
	PUSHJ	P,TYOM
	MOVE	B,.JBREL	;SIZE OF CORE NOW
	ADDI	B,1
	ASH	B,-12
	PUSHJ	P,DECMS		;PRINT
	JSP	A,CONMES
	ASCIZ	/K Core]
/

;RESTORE THE AC'S AND EXIT FROM THIS COR GET ROUTINE

EXITZ:	MOVSI	CH,SAVE		;FROM TO
	BLT	CH,CH		;ALL AC'S AS THEY WERE
	POPJ	P,		;AND EXIT

;NO CORE AVAILABLE (OR NOT ENOUGH)

NOTANY:	HLRZ	A,.JBSA		;GET LAST FIGURE OF CORE BOUND
	MOVEM	A,.JBFF		;AND STORE IT
	PUSHJ	P,CRE23		;COMPUTE THE MEMSIZE VALUES AGAIN
	MOVSI	CH,SAVE		;RESTORE THE ACCUMULATORS
	BLT	CH,CH		;& INFORM THE OUTSIDE WORLD THAT THEY LOSE
	EE3+ERROR E.COR

;THIS IS AN AUXILARY SPOT FOR ENTRANCE FROM GC2
;GET THE REQUIRED CORE TO SAVE THE JOB IF POSSIBLE

PRENR9:	PUSHJ	P,GRABAK	;GET THE REQUIRED CORE
	JRST	NROOM9		;GO TRY THE INSERT AGAIN
U BEG,1				;
U PT,1				;
U Z,1				;
U QRBUF,1			;
;*** DO NOT SEPARATE ***
U COMAX,1			;TOTAL # OF CHARS AT CUR. CMD. LEVEL
U CPTR,1			;EXECUTION-TIME CMD STRING PTR
U COMCNT,1			;# OF CHARS REMAINING TO BE EXECUTED AT THIS LEVEL
;*** DO NOT SEPARATE ***
U CBUFH,1			;
U CBUF,1			;
U MEMSIZ,1			;
U GCPTR,1			;
U CRREL,1			;
U GCFLG,1			;
U RREL,1			;


;CORRECT FOR 2/3 BUFFER FILLING ERROR.M23 IS 2/3'S AND M23PL IS 2/3
;PLUS THE OTHER THIRD-128 CHARACTERS.

U M23,1				;
U M23PL,1			;
;COMMAND DISPATCH TABLE

DEFINE	DSP (C1,A1,C2,A2)<
	XWD	<C1>B20,A1
	XWD	<C2>B20,A2>

;CODES INDICATE TYPE OF DISPATCH
JR=0	;FOR SIMPLE JRST DISPATCH
HR=1	;FOR DISPATCH TO A COMMAND PERFORMED BY A SUBROUTINE
MV=2	;FOR JRST DISPATCH AFTER PROCESSING PRECEDING NUMERIC ARGUMENTS

DTB:	DSP(JR,ERRA,JR,COMMEN)		;^@	^A
	DSP(JR,CNTRB,JR,ERRA)		;^B	^C
	DSP(JR,ERRA,JR,FFEED)		;^D	^E
	DSP(JR,LAT,JR,BELDMP)		;^F	^G
	DSP(JR,GTIME,HR,TAB)		;^H	TAB
	DSP(JR,CD5,JR,ERRA)		;LF	VT
	DSP(HR,TYO,JR,CD5)		;FF	CR
	DSP(JR,EOF,JR,OCTIN)		;^N	^O
	DSP(JR,ERRA,JR,ERRA)		;^P	^Q
	DSP(JR,ERRA,JR,ERRA)		;^R	^S
	DSP(MV,SPTYI,JR,ERRA)		;^T	^U
	DSP(MV,LOWCAS,MV,STDCAS)	;^V	^W
	DSP(MV,SETMCH,JR,ERRA)		;^X	^Y
	DSP(JR,DECDMP,JR,ALTMOD)	;^Z	^[
	DSP(JR,ERRA,JR,ERRA)		;^BKSLH	^]
	DSP(JR,CNTRUP,JR,ERRA)		;^^	^LFTARR
	DSP(MV,PLUS,JR,EXCLAM)		;SPACE	!
	DSP(MV,DQUOTE,MV,COR)		;"	#
	DSP(JR,ERRA,JR,PCNT)		;$	%
	DSP(MV,CAND,JR,CD)		;&	'
	DSP(JR,OPENP,MV,CLOSEP)		;(	)
	DSP(MV,TIMES,MV,PLUS)		;*	+
	DSP(MV,COMMA,MV,MINUS)		;,	-
	DSP(JR,PNT,MV,SLASH)		;.	/
	DSP(JR,CDNUM,JR,CDNUM)		;0	1
	DSP(JR,CDNUM,JR,CDNUM)		;2	3
	DSP(JR,CDNUM,JR,CDNUM)		;4	5
	DSP(JR,CDNUM,JR,CDNUM)		;6	7
	DSP(JR,CDNUM,JR,CDNUM)		;8	9
	DSP(MV,COLON,MV,SEMICL)		;:	;
	DSP(MV,LSSTH,HR,PRNT)		;<	=
	DSP(JR,GRTH,JR,QUESTN)		;>	?
	DSP(MV,ATSIGN,JR,ACMD)		;@	A
	DSP(JR,BEGIN,MV,CHARAC)		;B	C
	DSP(MV,DELETE,HR,ECMD)		;D	E
	DSP(MV,FCMD,JR,QGET)		;F	G
	DSP(JR,HOLE,HR,INSERT)		;H	I
	DSP(MV,JMP,MV,KILL)		;J	K
	DSP(MV,LINE,MV,MAC)		;L	M
	DSP(MV,SERCHP,JR,OG)		;N	O
	DSP(HR,PUNCHA,JR,QREG)		;P	Q
	DSP(MV,REVERS,MV,SERCH)		;R	S
	DSP(HR,TYPE,MV,USE)		;T	U
IFE VC,<
	DSP(JR,ERRA,MV,CHARGT)		;V	W
>
IFN VC,<
	DSP(JR,VCMD,MV,CHARGT)
>
	DSP(MV,X,HR,YANK)		;X	Y
	DSP(JR,END1,MV,OPENB)		;Z	[
	DSP(MV,BAKSL,MV,CLOSEB)		;BKSLH	]
	DSP(JR,UAR,MV,LARR)		;^	LFTARR
U ERRLEN,1			;TYPE OF ERROR MESSAGES WANTED BY DEFAULT
U AC2,16			;SAVE AC2-AC17 IN NROOM ROUTINE
U STAB,STABLN			;SEARCH MATRIX

XFILNM=STAB			;ARGUMENTS FOR EXTENDED ENTER
.RBPPN=STAB+1
.RBNAM=STAB+2
.RBEXT=STAB+3
.RBPRV=STAB+4
.RBSIZ=STAB+5
.RBVER=STAB+6
.RBSPL=STAB+7
.RBEST=STAB+10
.RBALC=STAB+11
.RBPOS=STAB+12
.RBFTI=STAB+13
.RBNCA=STAB+14
.RBMTA=STAB+15
.RBDEV=STAB+16

DCLOC=STAB+30
.UFTAL=STAB+31
.STTAL=STAB+32
.UNTAL=STAB+33
.STNAM=STAB+34

;INSERTED 1 LINE BJ [EDIT 117]
U BCOUNT,1			;BEGPAG MATCH FLAG FOR SEARCH1
U SYMS,22			;LIS+4(0),OG3+1,GC+3(0)
U VALS,22			;LIS+4(0),OG3+3,GC+3(0)
U CNTS,22			;LIS+4(0),OG3+2,GC+3(0)
U SYMEND,0			;
U EQM,1			;LEVEL OF MACRO NESTING	[ED#114]
U SRHCTR,1			;# OF CHARS IN SEARCH ARGUMENT (MUST PRECEDE SRHARG)
U SRHARG,^D16			;STORE FOR SEARCH ARGUMENT
U PFL,LPF			;
U GCTAB,GCTBL			;GCS3+4,GCM2+13
U QTABSP,6			;SPECIAL Q REGISTERS
U QTAB,44			;Q-REGISTER TABLE
				;USEA+1,PCNT+1
U QTABEX,44		;NEXT BUNCH
QPROGN=QTABEX+"9"-"0"		;&9
QPROJN=QTABEX+"8"-"0"		;&8
QPJOBN=QTABEX+"7"-"0"		;&7
SILENT=QTABEX+"Z"-"A"+"9"-"0"+1	;&Z
QTEXTY=QTABEX+"Y"-"A"+"9"-"0"+1	;&Y
QMACLV=QTABEX+"J"-"A"+"9"-"0"+1	;&J
QTEXTK=QTABEX+"K"-"A"+"9"-"0"+1	;&K
VVAL=QTABEX+"V"-"A"+"9"-"0"+1	;&V
QCOUNT=QTABEX+"O"-"A"+"9"-"0"+1	;&O
QDISPL=QTABEX+"D"-"A"+"9"-"0"+1	;&D
QAUTPY=QTABEX+"S"-"A"+"9"-"0"+1	;&S
QLEVER=QTABEX+"I"-"A"+"9"-"0"+1	;&I
QPAGES=QTABEX+"F"-"A"+"9"-"0"+1	;&F
SFINDF=QTABEX+"U"-"A"+"9"-"0"+1	;&U
QVTABS=QTABEX+"R"-"A"+"9"-"0"+1	;&R
QLINES=QTABEX+"L"-"A"+"9"-"0"+1	;&L
QTEXTR=QTABEX+"T"-"A"+"9"-"0"+1	;&T
QTEXTS=QTABEX+"N"-"A"+"9"-"0"+1	;&N
QAGAIN=QTABEX+"9"-"0"+1		;&A
QBACKO=QTABEX+"B"-"A"+"9"-"0"+1	;&B
U PDL,LPDL			;
U SAVE,16			;AC STORAGE FOR GC
U SAV16,1			;
U LOWTOP,<CMDSTZ+4>/5
U LOWTPP,0
CMSTRB=LOWTOP


	LIT			;SO PATCH SPACE IS AT TOP OF HI-SEG
PATCH:	END	TECO
  P