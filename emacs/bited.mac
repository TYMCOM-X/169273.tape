TITLE	BITED - BIT EDITOR
SUBTTL	A CHRISTOPHER HALL FECIT

EXTERN	.JBFF,.JBREL,.JBAPR,.JBTPC

TWOSEG		;MY STRENGTH IS AS THE STRENGTH OF TEN, BECAUSE MY CODE IS PURE

CUSTVR==0		;DEC DEVELOPMENT
HALVER==2		;MAJOR VERSION
HALMVR==6		;MINOR VERSION
HALEVR==37		;EDIT NUMBER

	LOC	137
	BYTE	(3)CUSTVR (9)HALVER (6)HALMVR (18)HALEVR
	RELOC

;AC ASSIGNMENTS

A=1
B=2
C=3
D=4
E=5
F=6		;FOR FLAGS
G=7
I=10
CH=14		;FOR CHARACTERS
WD=15		;STARTING WORD NUMBER
PT=16		;IOWD POINTER TO FILE
P=17		;PUSH DOWN STACK

;CHANNEL ASSIGNMENTS

IN==7
OUT==10
LPT==11

;FLAGS

FND==1		;FOUND A NUMBER (STRIN & VALIN)
SPC==2		;SAVE INPUT IN SPEC BUFFER (STRIN & VALIN)
MSK==4		;MASK HAS BEEN MODIFIED (VALIN)
CMD==10 	;THIS IS A COMMAND (CHKCMD)
PPN==20 	;OUTPUT PPN HAS BEEN SEEN (GETFIL)
OUF==40 	;USER GAVE AN OUTPUT FILE (GETFIL)
VAL==100	;SAVED SOME PART OF A VALUE (ASKME)
ITR==200	;FOUND AN ITERATION VALUE (ASKME)
COM==400	;SEEN A COMMA (HELPS OUT FIND) (ASKME)
MNS==1000	;GOT A NEGATIVE RELATIVE RANGE (ASKME)
WRT==2000	;WRITE FILE; NO EXIT (WRITE)
SUB==4000	;MAKE A SUBSTITUTION (SUBST)
RTP==10000	;RETURN FROM PRINT AFTER ONE WORD (SUBST)
OFT==20000	;GIVE SPECIAL FORMAT WITH OUTPUT (OUTFMT)
STT==40000	;BEEN THROUGH NEWFIL BEFORE (NEWFIL)

;LEFT HALF FLAGS

R10==1		;OUTPUT WORD NUMBER IN DECIMAL

ALF==FND!MSK!CMD!PPN!OUF!VAL!ITR!COM!MNS!OFT!SPC

;FLAGS IN LEFT HALF OF COMMAND TABLE

STP==400000	;IOWD SETUP NEEDED
PTR==200000	;PRINT COMMAND
FDR==100000	;FIND OR SUBSTITUTE COMMAND
INR==40000	;INSERT COMMAND

	OPDEF	PJRST[JRST]

	RELOC	400000

NEWFIL: RESET			;CHUCK ALL BUFFERS AND PARTIAL FILES
	TRON	F,STT		;BEEN HERE BEFORE?
	JRST	NEWFL1		;NO - DON'T SHRINK
	MOVE	A,JOBREL	;GET OLD MAX SIZE
	CORE	A,		;COLLAPSE
	  JFCL			;(CAN'T MISS)
	JRST	NEWFL2		;DON'T RE-DO THE FIRST-TIME STUFF

NEWFL1:	MOVE	P,[IOWD 20,STACK];SET UP STACK POINTER
	PUSHJ	P,GETSCN	;SET UP FILE GIVEN IN RUN, IF ANY
	MOVE	A,.JBREL	;GET PRESENT SIZE
	MOVEM	A,JOBREL	;SAVE IT FOR ABOVE

NEWFL2:	MOVEI	GETAK		;GET ADDRESS OF CORE ROUTINE
	HRRM	.JBAPR		;SAVE AS APR TRAP
	MOVEI	420000		;SET UP USER MEMORY PROTECTION VIOLATION TRAP
	APRENB	   		;  SO CORE IS EXPANDED AUTOMATICALLY
	TRZ	F,ALF		;CLEAR ALL THE CLEARABLE FLAGS
	SETZM	FILPTR		;CLEAR PRESENT LOCATION PTR
	SETZM	RELFIL		;CLEAR RELOCATION
	MOVE	A,[SIXBIT /DSK/];GET DEFAULT DEVICE
	MOVEM	A,INBLK+1	;RESTORE TO INPUT OPEN
	MOVEM	A,OUTBLK+1	;  AND TO OUTPUT OPEN
	SETZM	INFIL+1		;PREPARE FOR BLT
	MOVE	A,[XWD INFIL+1,INFIL+2]
	BLT	A,OUTFIL+3	;CLEAR ALL FILE SPECS
NOFILE: MOVE	I,[POINT 7,SPECS];GET POINTER TO SPEC BUFFER
	TRO	F,SPC		;SET FLAG TO SAVE SPECS
	PUSHJ	P,GETFIL	;GET FILE SPECS
	SKIPN	INFIL+2		;SOME FILE GIVEN?
	JRST	NOFILE		;NO - ASK AGAIN
	SETZ	A,		;GET A NULL
	IDPB	A,I		;SAVE AS END OF SPECS
	OPEN	IN,INBLK
	  HALT
	LOOKUP	IN,INFIL
	  JRST	LUKERR		;ASSUME HE MADE A MISTAKE
	MOVE	A,FILSIZ	;GET SIZE OF FILE
	CAILE	A,166000	;TOO LARGE TO FIT IN CORE (ABOUT 470 BLOCKS)?
	JRST	GETVIR		;YES - RUN VIRTUAL BITED INSTEAD
	OPEN	OUT,OUTBLK
	  HALT
	ENTER	OUT,OUTFIL
	  JRST	ENTERR		;ASSUME HE MADE ANOTHER MISTAKE
	TRZ	F,SPC		;CLEAR SAVE-THE-SPECS FLAG
	MOVE	A,.JBFF 	;GET FIRST AVAILABLE LOCATION
	MOVEM	A,CCW		;SAVE AS ADDRESS IN COMMAND LIST
	AOJ	A,		;ADD A WORD FOR SAFETY
	MOVEM	A,FILBAS	;SAVE AS START OF FILE
	PUSHJ	P,GETIT 	;READ IN THE FILE
WOTNOW:	PUSHJ	P,ASKME 	;GET A COMMAND STRING
	JUMPG	E,@E		;EXECUTE COMMAND IF NO SETUP NEEDED

;CHECK RANGE OF STRLOC AND ENDLOC, SET UP A PTR IN PT,
;DISPATCH TO THE COMMAND GIVEN, AND LOOP THROUGH ALL PTRS

	TRNN	F,FND!COM	;GOT ANY VALUES AT ALL?
	PUSHJ	P,SETRNG	;NO - SET UP DEFAULT RANGE
	MOVE	A,FILSIZ	;GET MAX VALUE
	TLNE	E,INR		;INSERT COMMAND?
	JRST	.+5		;YES - NO MAX'S NECESSARY
	CAMGE	A,ENDLOC	;END TOO LARGE?
	MOVEM	A,ENDLOC	;YES - SET TO MAX
	CAMGE	A,WD		;START TOO LARGE?
	MOVEM	A,WD		;YES - SET TO MAX
	MOVE	A,RELFIL	;GET MIN VALUE
	CAMLE	A,WD		;START TOO SMALL?
	SKIPA	WD,A		;YES - SET TO MIN
	MOVE	A,WD		;GET ADJUSTED START
	CAMLE	A,ENDLOC	;IS ENDLOC .GE. STRLOC
	MOVEM	A,ENDLOC	;NO - MAKE IT STRLOC

	TLNE	E,PTR		;GOT A PRINT COMMAND?
	JRST	[TRNE F,MNS	;YES - WORKING BACKWARDS?
		 MOVEM A,FILPTR	;YES - SAVE STRLOC AS NEXT POINTER
		 SUB   A,ENDLOC	;GET NUMBER OF WORDS IN RANGE
		 CAMGE A,[-1]	;MORE THAN ONE LINE?
		 MOVNM A,OLLINE	;YES - SAVE AS DEFAULT NUMBER OF LINES
		 SOJA  A,HDLCM1];ALREADY GOT WORDCOUNT

HDLCMD: SUB	A,ENDLOC	;GET NEGATIVE WORDCOUNT
	SOJ	A,		;PLUS NEGATIVE ONE
HDLCM1:	HRL	PT,A		;SET UP IOWD - COUNT IN LH
	HRR	PT,WD		;AND SET UP ADDRESS IN RH
	ADD	PT,FILBAS	;MAKE ADDRESS ABSOLUTE
	JRST	@E		;GO HANDLE COMMAND

;SUBROUTINE TO SET UP THE RANGE FOR THE USER, SAME AS LAST TIME

SETRNG: MOVE	A,FILPTR	;GET FILE POINTER
	TLNE	E,FDR		;WANT A FIND OR SUBSTITUTE?
	AOJA	A,SETFND	;YES - BUMP START PTR AND SET UP DIFFERENTLY
	TRNE	F,MNS		;NEGATIVE RELATIVE?
	JRST	SETRN1		;YES - DO IT BACKWARDS
	MOVEM	A,WD		;SAVE AS START
	ADD	A,OLLINE	;ADD IN NUMBER TO PRINT
	MOVEM	A,ENDLOC	;SAVE AS END
	POPJ	P,		;RETURN TO FLOW

SETRN1: MOVEM	A,ENDLOC	;SAVE AS END
	SUB	A,OLLINE	;MINUS NUMBER TO PRINT
	MOVEM	A,WD		;SAVE AS START
	POPJ	P,		;BACK TO FLOW

SETFND:	MOVEM	A,WD		;SAVE AS START
	MOVE	A,FILSIZ	;GET END OF FILE
	MOVEM	A,ENDLOC	;SAVE AS END
	DMOVE	A,OLVALU	;REMEMBER WHAT TO LOOK FOR
	DMOVEM	A,VALUE 	;SAVE IT
	TRO	F,RTP		;SET SO WON'T SAVE THE ABOVE PARAMS
	SKIPN	ITERAT		;GOT SOME OCCURRENCES TO LOOK FOR?
	AOS	ITERAT		;NO - LOOK FOR ONE, THEN
	POPJ	P,		;BACK TO FLOW

LUKERR: OUTSTR	[ASCIZ /  FILE NOT FOUND, OR IS PROTECTED
/]
	JRST	.+2		;ONE MESSAGE AT A TIME
ENTERR: OUTSTR	[ASCIZ /  CANNOT WRITE TO OUTPUT AREA
/]
	CLRBFI			;CLEAR INPUT BUFFER
	JRST	NEWFL2		;GIVE HIM ANOTHER CHANCE

;SUBROUTINE TO INPUT A STRING OF UP TO SIX SIXBIT CHARACTERS
;EXCESS IGNORED (ENTRY STRIN), OR AN OCTAL VALUE OR ONE
;ASCII CHARACTER (ENTRY VALIN).  INPUT IS A BYTE POINTER IN C
;(FOR STRING); OUTPUT IS VALUE OR STRING IN B, DELIMITER IN A.

STRIN:	SETZ	B,		;CLEAN OUT FOR MASK, AND RESULT
STRGET: INCHWL	A		;GET A CHARACTER
	TRNE	F,SPC		;WANT TO SAVE FILE SPECS?
	IDPB	A,I		;YES - STASH THE CHARACTER
	CAIGE	A,"0"		;TOO SMALL TO BE USEFUL?
	JRST	STRSPC		;YES - SEE IF IT'S SPECIAL
	CAIG	A,"9"		;NUMERIC?
	JRST	STRSAV		;YES - CONVERT IT
	CAIGE	A,"A"		;BIG ENOUGH FOR A CHARACTER?
	POPJ	P,		;NO - RETURN WITH DELIMITER
	CAIG	A,"Z"		;IS IT A CHARACTER?
	JRST	STRSAV		;YES - SAVE IT
	CAIL	A,"a"		;IS IT A LOWER CASE CHARACTER?
	CAILE	A,"z"		;..
	POPJ	P,		;NO - NONE OF ABOVE - RETURN
	SUBI	A,40		;YES - CONVERT TO UPPER
STRSAV:	TLNN	C,770000	;GOT SIX CHARACTERS?
	JRST	STRGET		;YES - IGNORE THIS CHARACTER
	SUBI	A," "		;MAKE SIXBIT
	IDPB	A,C		;SAVE CHAR (POINTER IS IN C)
	JRST	STRGET		;AND GET SOME MORE

STRSPC:	CAIE	A,15		;IS IT A <CR>
	CAIN	A," "		;  OR A SPACE?
	JRST	STRGET		;YES - IGNORE IT
	POPJ	P,		;ELSE RETURN WITH DELIMITER

;SUBROUTINE TO INPUT A VALUE (BUT NOT A RANGE)

VALIN:	TRZ	F,FND		;CLEAR FOUND-A-VALUE FLAG
	SETZB	G,B		;CLEAN OUT FOR MASK, AND RESULT
VALGET: INCHWL	A		;GET A CHARACTER
	TRNE	F,SPC		;WANT TO SAVE FILE SPECS?
	IDPB	A,I		;YES - STASH THE CHARACTER
	CAIGE	A,"0"		;TOO SMALL FOR A DIGIT?
	JRST	VALSPC		;YES - SEE IF IT'S SPECIAL
	CAILE	A,"7"		;IS IT A GOOD OCTAL DIGIT?
	JRST	VALSP1		;NO - CHECK FOR HIGH SPECIALS
	LSH	G,3		;SHIFT MASK ONE OCTAL BYTE
VALGE1:	TRO	F,FND		;FOUND A VALUE
	SUBI	A,"0"		;GET AN OCTAL DIGIT
	LSH	B,3		;B*8
	ADD	B,A		;  + NEW VALUE
	JRST	VALGET		;AND GET SOME MORE

VALSPC:	CAIE	A,15		;IS IT A <CR>,
	CAIN	A," "		;  OR A SPACE?
	JRST	VALGET		;YES - IGNORE IT
	POPJ	P,		;NO - RETURN THE CHARACTER TO CALLER

VALSP1:	CAIE	A,"?"		;IS THIS A WILD BYTE?
	POPJ	P,		;NO - RETURN IT TO CALLER
	LSH	G,3		;SHIFT MASK ONE OCTAL BYTE
	ADDI	G,7		;MASK THIS BYTE
	MOVEI	A,"0"		;GET A ZERO
	JRST	VALGE1		;  TO PUT IN THE NUMBER

;SUBROUTINE TO INPUT A RANGE VALUE

RNGIN:	TRZ	F,FND		;CLEAR FOUND-A-VALUE FLAG
	SETZ	B,		;CLEAN OUT RESULT
RNGGET: INCHWL	A		;GET A CHARACTER
	CAIGE	A,"0"		;TOO SMALL FOR A DIGIT?
	JRST	RNGSPC		;YES - SEE IF IT'S SPECIAL
	CAIG	A,"7"		;IS IT A GOOD OCTAL DIGIT?
	JRST	RNGGE1		;YES - PROCESS IT
	TLNE	F,R10		;USING RADIX 10?
	CAILE	A,"9"		;YES - GOT AN 8 OR 9?
	POPJ	P,		;NO - RETURN IT TO CALLER

RNGGE1:	TRO	F,FND		;FOUND A VALUE
	SUBI	A,"0"		;GET AN OCTAL DIGIT
	IMUL	B,RADIX		;B*RADIX
	ADD	B,A		;  + NEW VALUE
	JRST	RNGGET		;AND GET SOME MORE

RNGSPC:	CAIE	A,15		;IS IT A <CR>,
	CAIN	A," "		;  OR A SPACE?
	JRST	RNGGET		;YES - IGNORE IT
	CAIN	A,"*"		;WANT END-OF-FILE VALUE?
	JRST	MAKEND		;YES - GO DO IT
	CAIE	A,"."		;WANT PRESENT-LOCATION VALUE?
	POPJ	P,		;NO - RETURN THE CHARACTER TO CALLER

	JUMPN	B,INERR		;TROUBLE IF SOME VALUE TYPED
	MOVE	B,FILPTR	;GET PRESENT LOCATION
	TRO	F,FND		;SET FOUND-A-VALUE FLAG
	JRST	RNGGET		;GET MORE GAFF

MAKEND: JUMPN	B,INERR 	;STILL TROUBLE IF MORE INPUT
	MOVE	B,[377777,,777777] ;GET LARGEST VALUE
;	MOVE	B,FILSIZ	;GET END-OF-FILE
	TRO	F,FND		;SET FOUND-A-VALUE FLAG
	JRST	RNGGET		;GO BACK FOR MORE

;SUBROUTINE TO GET EITHER A LETTER OR A VALUE FOR THE "O" COMMAND
;GIVES SKIP RETURN IF NOT A LETTER

CMDIN:	TRO	F,FND		;SET FOUND-A-VALUE FLAG
	INCHWL	A		;GET A CHARACTER
	CAIGE	A,"A"		;TOO SMALL FOR A CHARACTER?
	JRST	CMDSPC		;YES - SEE IF IT'S SPECIAL
	CAIG	A,"Z"		;UPPER CASE CHARACTER?
	POPJ	P,		;YES - RETURN WITH IT
	CAIL	A,"a"		;LOWER CASE CHARACTER?
	CAILE	A,"z"		;..
	JRST	CMDIN0		;NO - TREAT IT LIKE A VALUE
	SUBI	A,40		;YES - CONVERT TO UPPER
	POPJ	P,		;AND RETURN

CMDSPC:	CAIE	A," "		;IS IT A SPACE,
	CAIN	A,15		;  OR A <CR>?
	JRST	CMDIN+1 	;YES - IGNORE IT

CMDIN0: SETZ	B,		;CLEAR TARGET FOR RNGIN
	TRZ	F,FND		;CLEAR FOUND-A-VALUE FLAG
	AOS	(P)		;GIVE SKIP RETURN EVENTUALLY
	PJRST	RNGGET+1	;GET THE VALUE, IN THE CURRENT RADIX

INERR:	OUTSTR	[ASCIZ / ERROR WITH . OR */]
	CLRBFI			;CLEAN OUT INPUT BUFFER
	POP	P,A		;KILL TOP OF STACK
				;AND START FROM ASKME AGAIN

;SUBROUTINE TO INPUT A COMPLETE COMMAND STRING

ASKME:	TRZ	F,VAL!ITR!COM!RTP
	SETZB	WD,VALUE	;\
	SETZM	ENDLOC		; - ZERO EVERYTHING
	SETZM	ITERAT		;/
	SETOM	MASK		;MASK EVERYTHING
	OUTSTR	PROMPT		;TELL USER IT'S UP TO HIM
	PUSHJ	P,CMDIN 	;GET THE COMMAND
	  JRST	ASKME0		;STORE THE LEGAL COMMAND
	TRNN	F,FND		;FOUND ANYTHING?
	CAIE	A,12		;NO - JUST A LINEFEED?
	JRST	CMDERR		;NO - IT'S AN ERROR
	JRST	ASKME		;YES - LONE <CR> - DO IT OVER

;NOW SAVE OFF COMMAND, A SINGLE LETTER

ASKME0:	MOVE	E,CMDTBL-101(A)	;GET COMMAND
	CAIN	E,OUTFMT	;IS IT AN O COMMAND?
	JRST	ASKO		;YES - HANDLE SEPARATELY

;NOW GET THE RANGE, OF FORM N, N:N, N+N, OR N-N

	PUSHJ	P,RNGIN 	;GET A VALUE
	MOVEM	B,WD		;SAVE AS START
	CAIN	A,12		;<LF>?
	POPJ	P,		;DONE - FINISH OFF
	TRZ	F,MNS		;NO MORE NEGATIVE ADDRESSING
	CAIN	A,"/"		;END OF RANGE?
	JRST	ASKVAL		;YES - GET VALUE
	CAIN	A,"@"		;GO DIRECTLY TO ITERATIONS?
	JRST	ASKITR		;YUP

	MOVEM	A,D		;NO - SAVE DELIMITER
	PUSHJ	P,RNGIN 	;GET SECOND VALUE
	CAIN	D,"+"		;POSITIVE RELATIVE ADDRESSING?
	JRST	PLSHDL		;YES - TAKE CARE OF IT
	CAIN	D,"-"		;NEGATIVE RELATIVE ADDRESSING?
	JRST	MNSHDL		;YES - TAKE CARE OF IT, TOO
	CAIE	D,":"		;RANGE?
	JRST	CMDERR		;NO - BOMB TIME
	MOVEM	B,ENDLOC	;YES - SAVE END ADDRESS

ASKRN1:	CAIN	A,12		;<LF>?
	POPJ	P,		;YES - FINISHED
	CAIE	A,"/"		;BETTER BE A SLASH
	JRST	CMDERR		;IT ISN'T

;NOW GET THE VALUE, OF FORM N OR N,N OR N,,N, WITH MASK

ASKVAL: PUSHJ	P,VALIN 	;GET PART (ANYWAY) OF VALUE
	CAIE	A,","		;ONLY HALF THE WORD?
	JRST	ASKVA1		;NO - FINISH OFF THE VALUE
	PUSHJ	P,COMHDL	;SAVE LEFT HALF VALUE
	JRST	ASKVAL		;GET OTHER HALF

ASKVA1: PUSHJ	P,VALHDL	;NO - SAVE RH OR WHOLE VALUE
	CAIN	A,12		;WAS IT A LINEFEED?
	POPJ	P,		;YES - RETURN
	CAIN	A,"="		;WANT SECOND VALUE?
	JRST	ASKVA2		;YES - SET UP FOR IT
	CAIE	A,"@"		;AT IS THE ONLY THING ALLOWED
	JRST	CMDERR		;AND THIS ISN'T IT

;NOW CHECK FOR NUMBER OF ITERATIONS

ASKITR:	PUSHJ	P,VALIN 	;GET NUMBER OF ITERATIONS
	MOVEM	B,ITERAT	;SAVE NUMBER OF ITERATIONS
	TRO	F,ITR		;SET FOUND-AN-ITER FLAG
	CAIN	A,12		;IS HE DONE WITH COMMAND?
	POPJ	P,		;YES - ESCAPE AND PROCESS
	JRST	CMDERR		;NO - ERROR

ASKVA2: MOVE	B,VALUE 	;GET FIRST VALUE
	MOVEM	B,VALUE1	;IT'S REALLY THE SECOND ONE
	TRZ	F,VAL		;VAL FLAG SHOULDN'T HAVE BEEN SET
	JRST	ASKVAL		;GET REST OF COMMAND

;HERE TO HANDLE THE O COMMAND - ARG CAN BE A SINGLE LETTER
;OR A VECTOR OF UP TO 5 BYTE SIZES

ASKO:	MOVE	D,[XWD -5,BYTTAB];POINT TO FIVE WORD TABLE
ASKO1:	PUSHJ	P,CMDIN		;GET SOMETHING
	  JRST	ASKO2		;IT'S A CHARACTER
	TRNN	F,FND		;DID HE GIVE A NUMBER AT ALL?
	POPJ	P,		;NO - JUST RETURN
	JUMPE	B,ERRBYT	;ZERO BYTE SIZE IS ILLEGAL
	MOVEM	B,(D)		;NUMBER - SAVE
	CAIN	A,","		;MORE?
	AOBJN	D,ASKO1 	;YES - GET 'EM
	CAIE	A,12		;LINEFEED?
	JRST	CMDERR		;NO - MISTAKE
	SETOM	1(D)		;DONE - WRITE A -1
	POPJ	P,		;THEN RETURN

ASKO2:	MOVEM	A,WD		;SAVE FORMAT CHARACTER
	CLRBFI			;IGNORE REST OF LINE
	POPJ	P,		;AND RETURN

COMHDL: TRON	F,VAL		;HIT A SECOND COMMA?
	TRNN	F,FND		;NO - GOT ANYTHING TO SAVE?
	POPJ	P,		;NO - OR MANY COMMAE - RETURN
	TRO	F,COM		;SET FOUND-A-COMMA FLAG
	HRLZM	B,VALUE 	;SAVE LEFT HALF
	HRLM	G,MASK		;AND LH OF MASK
	POPJ	P,		;AND RETURN

VALHDL: TRNN	F,FND		;GOT A VALUE AT ALL?
	POPJ	P,		;NO - SET NOTHING
	TROE	F,VAL		;GOT A LEFT HALF?
	JRST	VALHD1		;YES - FLAG IS RIGHT ALREADY
	MOVEM	B,VALUE 	;SAVE FULL WORD
	MOVEM	G,MASK		;SAVE THE WHOLE MASK
	POPJ	P,		;AND RETURN
VALHD1: HRRM	B,VALUE 	;SAVE RIGHT HALF ONLY
	HRRM	G,MASK		;SAVE RIGHT-HALF MASK
	POPJ	P,		;AND RETURN

PLSHDL: ADD	B,WD		;MAKE ENDING LOCATION
	MOVEM	B,ENDLOC	;SAVE IT
	JRST	ASKRN1		;BACK TO FLOW

MNSHDL:	MOVEM	WD,ENDLOC	;IT'S REALLY ENDING LOCATION
	SUB	WD,B		;MAKE STARTING LOC
	TRO	F,MNS		;SET FLAG FOR FILE POINTER
	JRST	ASKRN1		;BACK TO FLOW

ERRBYT: OUTSTR	[ASCIZ /CANNOT HAVE BYTE SIZE ZERO/]
	JRST	.+2		;IGNORE AND GET

CMDERR: OUTSTR	[ASCIZ / ERROR IN COMMAND STRING/]
	CLRBFI			;CLEAN OUT INPUT BUFFER
	JRST	ASKME		;THEN READY FOR ANOTHER TRY

;SUBROUTINE TO INPUT FILE - USES FILBAS IN A

GETIT:	MOVN	A,FILSIZ	;GET SIZE OF FILE FROM LOOKUP
	SOS	FILSIZ		;IT WAS ONE TOO BIG
	HRLM	A,CCW		;SAVE FILE SIZE IN CCW
	MOVE	A,FILSIZ	;GET SIZE OF FILE
	JFFO    A,.+1           ;SEE HOW MANY DIGITS ARE NEEDED
	MOVEI   A,^D36
	SUB     A,B
	IDIVI   A,3
	AOJ     A,
	MOVEM	A,NUMSIZ	;SAVE WORD NUMBER SIZE

	MOVE	A,FILSIZ	;GET SIZE OF FILE
	ADD	A,FILBAS	;ADD ADDRESS OF E AGAIN
	MOVEM	A,FILTOP	;SAVE AS TOP OF FILE
	SETZM	(A)		;WRITE IN TOP TO EXPAND, IF NEEDED
	IN	IN,CCW		;ZAP THE FILE IN
	CLOSE	IN,		;SHUT OFF THE INPUT
	POPJ	P,		;THAT'S ALL

;SUBROUTINE TO SEE IF MORE CORE IS NEEDED, AND GET SOME
;INPUT IS LOCATION WANTED, IN A, WHICH IS PRESERVED

GETAK:	HRRZ	C,.JBREL	;GET HIGHEST LOCATION
	ADDI	C,2000		;ADD A K
	CORE	C,		;TRY TO GET THE CORE
	  HALT			;OUT OF LUCK
	JRST	2,@.JBTPC	;GOT IT - RETURN FROM INTERRUPT

;SUBROUTINE TO SET UP THE FILE SPECS GIVEN IN THE RUN COMMAND

GETSCN: RESCAN			;GO TO START OF RUN LINE
GETSC1: INCHRS	A		;GET A CHARACTER - ANY?
	POPJ	P,		;NO - DONE
	CAIE	A,";"		;BEGINNING OF COMMAND?
	JRST	GETSC1		;NO - KEEP LOOKING
	MOVEI	B,-1		;SET A BIT TO KILL PROMPT
	POPJ	P,		;AND RETURN WITH THEM SET UP

;SUBROUTINE TO INPUT FILE SPECIFICATIONS

GETFIL: CAIE	B,-1		;GOT SPECS WAITING?
	OUTSTR	QUERY		;NO - PROMPT FOR THEM, THEN
GETFL1:	MOVE	C,[POINT 6,B]	;SAVE POINTER IN C
	PUSHJ	P,STRIN 	;GET A CHARACTER
	CAIN	A,12		;<LF>?
	JRST	GETFL5		;YES - HE'S DONE
	CAIN	A,":"		;GOT DEVICE NAME?
	JRST	GETFL3		;YES - SAVE IT
	CAIN	A,"["		;GOT A PPN COMING?
	JRST	GETFL5+1	;YES - HANDLE THIS AND GET PPN
	CAIN	A,"="		;WAS THIS AN OUTPUT FILE?
	JRST	GETFL9		;YES - GET READY FOR IN SPECS
	CAIE	A,"."		;END OF NAME?
	JRST	GETERR		;NO - MUST BE ERROR
	MOVEM	B,INFIL+2	;SAVE NAME
	TRNN	F,OUF		;ALREADY GOT AN OUTPUT FILE?
	MOVEM	B,OUTFIL	;NO - MAKE OUT SAME AS IN
	JRST	GETFL1		;GET SOME MORE
GETFL3: MOVEM	B,INBLK+1	;SAVE DEVICE FOR INPUT
	TRNN	F,PPN		;ALREADY AN OUTPUT DEVICE?
	MOVEM	B,OUTBLK+1	;NO - SAVE HERE, TOO
	JRST	GETFL1		;SEE WHAT ELSE HE HAS TO SAY
GETFL5: JUMPE	B,CPOPJ 	;RETURN IF ONLY A <CR>
	SKIPN	INFIL+2		;GOT A FILE YET?
	JRST	GETFL6		;NO - THIS MUST BE IT
	MOVEM	B,INFIL+3	;OTHERWISE SAVE EXT
	TRNN	F,OUF		;ALREADY AN OUTPUT EXT?
	MOVEM	B,OUTFIL+1	;NO - SAVE HERE ALSO
	JRST	.+4		;SEE IF PPN COMING
GETFL6: MOVEM	B,INFIL+2	;SAVE FILE NAME
	TRNN	F,OUF		;GOT AN OUTPUT FILE YET?
	MOVEM	B,OUTFIL	;NO - SAVE HERE, TOO
	CAIE	A,"["		;PPN COMING?
CPOPJ:	POPJ	P,		;NO - RETURN
	PUSHJ	P,VALIN 	;GET PROJ NUMBER
	CAIN	A,12		;<LF>?
	JRST	GETERR		;<CR> NOW IS BAD
	CAIE	A,","		;BETTER END WITH A COMMA
	JRST	GETERR		;NOPE - WRONG
	HRLM	B,INFIL+1	;SAVE PROJ
	PUSHJ	P,VALIN 	;GET PROG NUMBER
	CAIN	A,12		;<LF>?
	JRST	.+5		;YES - END OF LINE
	CAIE	A,"]"		;  OR A BRACKET
	CAIN	A,"="		;  OR AN EQUAL
	JRST	.+2
	JRST	GETERR		;NO - TRY AGAIN
	HRRM	B,INFIL+1	;SAVE PROG
	CAIN	A,12		;DID HE TYPE A <LF>?
	POPJ	P,		;YES - RETURN
	CAIE	A,"="		;DID HE END WITH AN EQUAL?
	JRST	GETFL1		;NO - GO BACK FOR MORE

GETFL9: TRO	F,PPN		;KEEP WHATEVER PPN THERE IS
	PUSHJ	P,GETFL5	;FINISH WORK FOR OUTPUT SPECS
	SKIPE	INFIL+2		;DID HE GIVE AN INPUT FILE?
	TRO	F,OUF		;YES - SET GOT-OUTPUT-SPECS FLAG
	SKIPE	B,INFIL+1	;GET OUTPUT PPN - ANY?
	MOVEM	B,OUTFIL+3	;YES - SAVE IN THE RIGHT PLACE
	SETZM	INFIL+1 	;\
	SETZM	INFIL+2 	; - CLEAR INPUT FILE SPECS
	SETZM	INFIL+3 	;/
	JRST	GETFL1		;GET INPUT SPECS
GETERR: OUTSTR	[ASCIZ /  BAD FILE SPECIFICATIONS
/]
	CLRBFI			;CLEAN OUT INPUT BUFFER
	JRST	GETFIL		;GIVE ANOTHER CHANCE

;HERE WHEN DONE - EXIT TO SAVE CHANGES; QUIT TO FORGET THEM
;ALSO TO SAVE A FILE AND RETURN TO PROCESSING

WRITE:	TRO	F,WRT		;SET WRITE-ONLY FLAG
EXOUT:	MOVN	A,FILSIZ	;GET NEGATIVE SIZE OF FILE
	SOJ	A,		;IT WAS ONE TOO BIG
	HRLM	A,CCW		;SAVE IN CHANNEL COMMAND LIST
	SETZM	CCW+1		;MAKE SURE LAST WORD IS ZERO
	OUTPUT	OUT,CCW 	;OUTPUT THE FILE
	CLOSE	OUT,
	TRZE	F,WRT		;WRITE ONLY?
	JRST	WOTNOW		;YES - GET ANOTHER COMMAND
QUIT:	CLRBFI			;CLEAN OUT THE INPUT BUFFER
	RESET			;CHOP EVERYTHING NOT CLOSED
	EXIT			;AND GET LOST

;HERE IF AN UNIMPLEMENTED COMMAND HAS BEEN TYPED

NOTYET: OUTSTR	[ASCIZ / ILLEGAL COMMAND/]
	CLRBFI			;CLEAN OUT INPUT BUFFER
	JRST	WOTNOW		;ET ANOTHER COMMAND

;SUBROUTINE TO PRINT GIVEN RANGE OF WORDS OF THE FILE ON LINEPRINTER

LIST:	MOVE	A,FILTOP	;FAKE OUT LPT BUFFER
	AOJ	A,		;  TO START AFTER THE FILE
	PUSH	P,.JBFF 	;SAVE THE REAL END
	MOVEM	A,.JBFF 	;COMPLETE THE FAKE
	OPEN	LPT,LPTBLK
	  HALT
	ENTER	LPT,LPTFIL
	  HALT
	SETZ	I,		;CLEAR # LINES COUNTER
	LDB	D,[POINT 3,WD,35];GET LAST DIGIT OF LOCATION
	IMULI	D,17		;# OF SPACES NEEDED
	ADDI	D,6		;TO ALIGN FIRST LINE
	PUSHJ	P,SPACES	;OUTPUT 'EM
LIST1:	TRNE	WD,7		;LOCATION # EVERY 8 FOR LPT
	JRST	LIST2		;SO SKIP IT THIS TIME
	PUSHJ	P,CRLFL		;PUT ON A NEW LINE
	TRNN	WD,70		;PRINTED 8 LINES?
	PUSHJ	P,LISSKP	;YES - SKIP A LINE OR A PAGE
	AOJ	I,		;BUMP # LINES PRINTED
	PUSHJ	P,LISWD		;OUTPUT LINE NUMBER
	PUSHJ	P,SLASH 	;AND A SLASH
LIST2:	PUSHJ	P,SPACE3	;SPACE OVER
	PUSHJ	P,LISFWD	;PRINT A FULL WORD
	AOJ	WD,		;BUMP WORD NUMBER
	AOBJN	PT,LIST1	;PRINT UNTIL COUNTER NEGATIVE
	CLOSE	LPT,		;YES - CLOSE FILE THEN
	RELEAS	LPT,		;AND GIVE UP THE PRINTER
	POP	P,.JBFF 	;RESTORE REAL END
	JRST	WOTNOW		;THEN GET ANOTHER COMMAND

LISFWD: MOVE	C,[POINT 3,(PT)];GET FULL WORD POINTER
	TLNN	C,770000	;DONE YET?
	POPJ	P,		;YES
	ILDB	CH,C		;GET A BYTE
	ADDI	CH,"0"		;MAKE ASCII
	PUSHJ	P,LISCHR	;PRINT IT
	JRST	LISFWD+1	;GET ANOTHER ONE

;SUBROUTINE TO OUTPUT LINE NUMBER IN THE GIVEN RADIX

LISWD:	MOVE	B,WD		;GET WORD NUMBER
	MOVE	CH,NUMSIZ	;SET UP COUNTER
LISWD1:	IDIV	B,RADIX		;GET LAST DIGIT
	ADDI	C,"0"		;CONVERT TO ASCII
	HRLM	C,(P)		;STORE DIGIT ON STACK
	SOJLE	CH,.+2		;DONE ALL THE DIGITS?
	PUSHJ	P,LISWD1	;NO - CALL RECURSIVELY
	HLR	CH,(P)		;YES - RESTORE DIGIT
				;AND FALL INTO OUTPUT

LISCHR: SOSG	LPTBF+2 	;BUFFER FULL YET?
	OUTPUT	LPT,		;YES - SHIP IT OUT
	IDPB	CH,LPTBF+1	;CHUCK CHARACTER
	POPJ	P,		;AND RETURN

SLASH:	MOVEI	CH,"/"
	PJRST	LISCHR

CRLFL:	MOVEI	CH,15		;CARRIAGE RETURN
	PUSHJ	P,LISCHR
	MOVEI	CH,12		;LINEFEED
	PJRST	LISCHR

SPACE3: MOVEI	D,3		;PRINT 3 SPACES
SPACES: MOVEI	CH," "		;GET THE CHARACTER
	PUSHJ	P,LISCHR	;OUTPUT TO PRINTER
	SOJG	D,SPACES+1	;AND REPEAT UNTIL EXHAUSTED
	POPJ	P,		;THEN RETURN

LISSKP: CAIGE	I,56		;OUTPUT .GE. 46 LINES YET?
	PJRST	CRLFL		;NO - JUST SKIP AN EXTRA LINE
	SETZ	I,		;CLEAR COUNT
	MOVEI	CH,14		;GET A FORMFEED
	PJRST	LISCHR		;OUTPUT IT TO PRINTER

;SUBROUTINE TO PRINT GIVEN RANGE OF WORDS OF THE FILE ON SCREEN

PRINT:	PUSHJ	P,PRTWD 	;LINE NUMBER
	OUTCHR	["/"]		;AND A SLASH
	TRNE	F,RTP		;COME HERE FROM SUBSTITUTE?
	PJRST	PRTFWD		;YES - PRINT ONE WORD AND RETURN
	PUSHJ	P,PRTFWD	;PRINT A FULL WORD
	AOJ	WD,		;BUMP WORD NUMBER
	AOBJN	PT,PRINT	;PRINT UNTIL COUNTER NEGATIVE
	SOJ	WD,		;POINT TO LAST WORD PRINTED
	TRNN	F,MNS		;NEGATIVE RELATIVE?
	HRRZM	WD,FILPTR	;NO - SAVE PRESENT LOCATION
	JRST	WOTNOW		;GET ANOTHER COMMAND

;SUBROUTINE TO OUTPUT WORDS AND ADDRESSES

PRTFWD: MOVE	C,[POINT 3,(PT)];GET FULL WORD POINTER
	TLNN	C,770000	;DONE YET?
	JRST	PRTCHK		;YES - SEE IF ANY SPECIAL BYTES
	TLNN	C,550000	;AT HALF-WORD POINT?
	OUTSTR	[ASCIZ /,,/]	;YES - PRINT TWO COMMAE
	ILDB	CH,C		;GET A BYTE
	ADDI	CH,"0"		;MAKE ASCII
	OUTCHR	CH		;PRINT IT
	JRST	PRTFWD+1	;GET ANOTHER ONE

;NOW OUTPUT OCTAL BYTES OF SIZE GIVEN BY BYTTAB AND A CRLF
;ALSO ROUTES TO ROUTINES FOR ASCII, SIXBIT, OR HEX

PRTCHK:	TRNN	F,OFT		;WANT SPECIAL FORMAT?
	PJRST	CRLF		;NO - JUST A CRLF AND GET OUT
	MOVE	D,(PT)		;GET DATA WORD
	OUTCHR	[11]
	MOVEI	CH,^D36 	;GET ONE WORDSWORTH OF BITS
	SKIPGE	A,BYTTAB	;GET SIZE OF BYTE - SPECIAL?
	JRST	PRTAOS		;YES - GO THERE (PUFF, PUFF)
	MOVEI	I,BYTTAB	;POINT TO TABLE
PRTB1:	SKIPGE	A,(I)		;GET BYTE COUNT - AT END OF LIST?
	SOJA	I,PRTB1 	;YES - USE LAST ONE AGAIN
	IDIVI	A,3		;# OCTAL CHUNKS IN A; ODD BIT COUNT IN B

;HERE TO OUTPUT BYTES. TOTAL BITS IN CH, NUMBER OF 3-BIT BYTES IN A,
;SIZE OF ODD PIECE IN B

	JUMPE	B,PRTBY2	;NO ODD BYTES - SO THERE MUST BE SOME CHUNKS
	SETZ	C,		;CLEAR FOR INPUT
	LSHC	C,@B		;GET ODD BITS
	ADDI	C,"0"		;TO ASCII
	OUTCHR	C		;AND OUT
	JUMPE	A,PRTBY3	;MAYBE HE ONLY WANTED ONE OR TWO
PRTBY2: SETZ	C,		;CLEAR FOR INPUT AGAIN
	LSHC	C,3		;GET AN OCTAL BYTE
	ADDI	C,"0"		;CONVERT
	OUTCHR	C		;AND OUT
	SOJG	A,PRTBY2	;LOOP THROUGH BYTE
PRTBY3: MOVE	B,(I)		;GET BYTE COUNT
	CAIG	B,2		;THREE OR BETTER,
	SKIPLE	1(I)		;  AND NOT DONE WITH LIST?
	OUTCHR	[" "]		;YES - PUT A SPACE BETWEEN BYTES
	SUB	CH,B		;DECREMENT COUNT OF BITS DONE
	JUMPLE	CH,CRLF		;FINISH WITH A <CR> IF DONE
	AOJA	I,PRTB1		;ELSE GO DO ANOTHER ONE

;HERE TO OUTPUT IN ASCII (7 BIT) OR SIXBIT (6 BIT, DUMMY) CHARACTERS

PRTAOS: MOVNS	A		;MAKE A POSITIVE
	SUB	CH,A		;REMOVE ONE SET OF CHARACTERS FROM COUNT
PRTAS0: SETZ	C,		;CLEAR FOR INPUT
	LSHC	C,@A		;SHIFT IN A CHARACTER
	CAIN	A,4		;WANT HEXADECIMAL?
	JRST	PRTHEX		;YES - CHECK BITS
	CAIN	A,6		;WANT SIXBIT?
	ADDI	C," "		;YES - CONVERT TO ASCII
	CAIGE	C,40		;CONTROL CHARACTER?
	JRST	PRTAS1		;YES - HANDLE SEPARATELY
PRTAS2: OUTCHR	C		;KICK CHARACTER
PRTAS3:	SUB	CH,A		;DECREMENT COUNT
	JUMPGE	CH,PRTAS0	;LOOP THROUGH WORD

CRLF:	OUTSTR	[ASCIZ /
/]
	POPJ	P,

PRTAS1:	CAIL	C,10		;IS IT A GOOD
	CAIL	C,16		;  CONTROL CHARACTER?
	JRST	PRAS1A		;NO - OUTPUT OCTAL VALUE
	OUTSTR	CHTABL-10(C)	;OUTPUT IT
	JRST	PRTAS3		;CONTINUE THE FLOW

PRAS1A:	OUTCHR	["<"]		;OUTPUT <nnn>
	ROT	C,-3		;GET ONLY 1ST DIGIT OF NUMBER
	ADDI	C,"0"		;OUTPUT IT
	OUTCHR	C
	TRZ	C,777
	ROT	C,3		;GET 2ND DIGIT
	ADDI	C,"0"		;OUTPUT IT
	OUTCHR	C
	OUTCHR	[">"]
	JRST	PRTAS3		;CONTINUE THE FLOW

;HERE TO SET UP HEXADECIMAL FORMAT

PRTHEX: TRNN	CH,7		;OUTPUT A SPACE BETWEEN
	OUTCHR	[" "]		;  EVERY TWO CHARACTERS
	ADDI	C,"0"		;CONVERT TO ASCII
	CAILE	C,"9"		;TO BIG FOR A DIGIT?
	ADDI	C,7		;YES - CONVERT TO A-F
	JRST	PRTAS2		;AND USE THAT

CHTABL: ASCIZ	/<BS>/
	ASCIZ	/<TB>/
	ASCIZ	/<LF>/
	ASCIZ	/<VT>/
	ASCIZ	/<FF>/
	ASCIZ	/<CR>/
	BYTE	(7) 174

;SUBROUTINE TO LINE NUMBER IN THE GIVEN RADIX

PRTWD:	MOVE	B,WD		;GET WORD NUMBER
	MOVE	CH,NUMSIZ	;SET UP COUNTER
PRTWD1:	IDIV	B,RADIX		;GET LAST DIGIT
	ADDI	C,"0"		;CONVERT TO ASCII
	HRLM	C,(P)		;STORE DIGIT ON STACK
	SOJLE	CH,.+2		;DONE ALL THE DIGITS?
	PUSHJ	P,PRTWD1	;NO - CALL RECURSIVELY
	HLR	B,(P)		;YES - RESTORE DIGIT
	OUTCHR	B		;AND PRINT IT
	POPJ	P,		;RETURN RECURSIVELY AND FINALLY

;SUBROUTINE TO PRINT FROM LOCATION GIVEN BY RIGHT HALF OF
;LAST LINE PRINTED.

GOTO:	HRRZ	WD,(PT) 	;GET ADDRESS POINTED TO
	HRR	PT,WD		;SET UP AS ADDRESS OF IOWD
	ADD	PT,FILBAS	;MAKE ABSOLUTE
	JRST	PRINT		;GO PRINT THE RANGE

;SUBROUTINE TO SET RELOCATION INDEX

RELOK:	MOVEM	WD,FILPTR	;POINT TO FIRST LINE OF FILE
	MOVN	B,RELFIL	;GET NEG OF OLD RELOCATION
	MOVEM	WD,RELFIL	;SAVE NEW RELOCATION VALUE
	ADD	WD,B		;DIF BETWEEN OLD AND NEW RELOCS
	ADDM	WD,FILSIZ	;RELOCATE RELATIVE
	SUBM	WD,FILBAS	;  AND ABSOLUTE BASES
	MOVNS	FILBAS		;TAKE NEGATIVE OF BASE
	JRST	WOTNOW

;SUBROUTINE TO TOGGLE OUTPUT RADIX OF WORD NUMBERS BETWEEN DECIMAL AND OCTAL

BASE:	TLCE	F,R10		;FLIP RADIX - WAS IT 10?
	SKIPA	A,[10]		;YES - SET IT TO 8
	MOVEI	A,12		;NO - SET IT TO 10
	MOVEM	A,RADIX 	;MAKE THAT THE NEW RADIX
	JRST	WOTNOW		;GET ANOTHER COMMAND

;SUBROUTINE TO HANDLE SPECIAL FORMAT OUTPUT SPECIFIERS - FOR ASCII/SIXBIT,
;INSTRUCTION FORMAT, OR USER-GIVEN BYTE SIZE

OUTFMT:	CAIG	WD,^D36		;IF LARGE, ASSUME SPECIAL FORMAT
	JRST	OUTFM0		;NO - JUST SAVE IT
	TRO	F,FND		;SHOULD BE SET IF COMMAND IS GOOD
	CAIN	WD,"I"		;INSTRUCTION FORMAT?
	JRST	OUTFM2		;HANDLE IT LIKE NO ARG
	CAIN	WD,"A"		;ASCII FORMAT?
	JRST	OUTFMA		;YES - SET IT UP
	CAIN	WD,"S"		;HOW ABOUT SIXBIT?
	JRST	OUTFMS		;RIGHT
	CAIN	WD,"H"		;HEX, MAYBE?
	JRST	OUTFMH		;YUH
	OUTSTR	[ASCIZ /IMPROPER FORMAT VALUE/]
	CLRBFI			;HE BLEW IT. CLEAN BUFFER
	JRST	WOTNOW		;AND TRY AGAIN

OUTFM1:	MOVEM	WD,BYTTAB	;SAVE BYTE SIZE
OUTFM0: TRC	F,OFT		;TOGGLE FORMAT FLAG
	TRNE	F,FND		;DID HE GIVE A NUMBER?
	TRO	F,OFT		;YES - SET FLAG FOR SPECIAL FORMATS
	JRST	WOTNOW		;NEXT?

OUTFM2: MOVEI	A,4		;FAKE O 11,4,1,4,22
	MOVEI	B,1		;  WHICH IS INSTRUCTION FORMAT
	DMOVEM	A,BYTTAB+1
	MOVEI	B,22
	DMOVEM	A,BYTTAB+3
	MOVEI	WD,11
	JRST	OUTFM1		;FINISH OFF

OUTFMH: MOVNI	WD,4		;SET UP FOR HEXADECIMAL
	JRST	OUTFM1		;BACK TO FLOW

OUTFMA: SKIPA	WD,[-7]		;SET UP FOR ASCII
OUTFMS: MOVNI	WD,6		;SET UP FOR SIXBIT
	JRST	OUTFM1		;BACK TO FLOW

;SUBROUTINE TO OUTPUT THE FILE SPECS PRESENTLY IN USE

TSPECS: OUTSTR	SPECS		;OUTPUT 'EM
	JRST	WOTNOW

;SUBROUTINE TO CHANGE CONTENTS WORDS IN GIVEN RANGE

CHANGE:	TRNN	F,VAL		;GET A VALUE?
	PUSHJ	P,GETCHG	;NO - GET ONE AND MAKE CHANGE
	MOVE	E,VALUE 	;GET VALUE TO CHANGE TO
CHANG1:	MOVE	C,(PT)		;GET VALUE OF LOCATION
	AND	C,MASK		;MASK OFF THE BAD PARTS
	OR	C,E		;REPLACE THEM WITH GOOD ONES
	MOVEM	C,(PT)		;AND SAVE THE CHANGE
	TRNE	F,RTP		;CAME HERE FROM SUBSTITUTE?
	PJRST	PRINT		;YES - JUST PRINT THIS LINE AND RETURN
	AOJ	WD,		;BUMP WORD NUMBER
	AOBJN	PT,CHANGE+1	;GET AND MAKE OTHER CHANGES
	JRST	WOTNOW		;DONE - GET ANOTHER COMMAND

;SUBROUTINE TO GET A VALUE FOR CHANGE

GETCHG:	PUSHJ	P,PRTWD		;PRINT LINE NUMBER
	OUTCHR	["/"]		;SLASH AS A PROMPT
	SETOM	MASK		;MASK EVERYTHING
	TRZ	F,VAL		;RESET FOUND-PART-OF-A-VALUE FLAG
	PJRST	ASKVAL		;GET VALUE AND RETURN

;SUBROUTINE TO DELETE LINES IN GIVEN RANGE

DELETE: HLRO	A,PT		;GET COUNT OF WORDS DELETED
	ADDM	A,FILTOP	;ADJUST ABSOLUTE AND
	ADDM	A,FILSIZ	;  RELATIVE ENDS-OF-FILE
	MOVMS	A		;GET POSITIVE COUNT
	ADD	A,PT		;FIND FIRST GOOD ADDRESS
	HRL	PT,A		;MAKE A BLT POINTER
	BLT	PT,@FILTOP	;CLOSE UP THE FILE
	JRST	WOTNOW

;SUBROUTINE TO INSERT LINES IN GIVEN RANGE, PUSHING THE
;REST OF THE FILE UP.  VALUE, IF GIVEN, IS PUT INTO FIRST WORD.

INSERT: MOVE	A,ENDLOC	;GET ENDING LOCATION
	MOVE	B,FILSIZ	;AND FILE SIZE
	SUB	A,WD		;GET DISTANCE TO MOVE THEM
	SUB	B,WD		;AND NUMBER OF WORDS TO MOVE
	CAIGE	B,0		;ADDING TO END OF FILE?
	AOJA	A,INSRT2	;YES - JUST GO ADJUST POINTERS
	HRLI	B,1(B)		;SET UP B+1 FOR POPPER
	HRR	B,FILTOP	;PUT IN ADDRESS OF TOP WORD
	ADD	A,[POP B,1(B)]	;SET UP REST OF INSTRUCTION

INSER1: XCT	A		;MOVE A WORD TO ITS NEW HOME
	CAILE	B,-1		;DONE?
	JRST	INSER1		;NO - CONTINUE
	HRRZS	A		;TURN INSTRUCTION BACK INTO A VALUE
INSRT2:	ADDM	A,FILSIZ	;ADJUST SIZE
	ADDM	A,FILTOP	;  AND TOP POINTERS
	PJRST	CHANGE		;AND GET NEW VALUES

;SUBROUTINE TO FIND ALL OCCURRENCES OF A WORD OR HALF WORD
;(ENTRY FIND), ALSO TO SUBSTITUTE A GIVEN WORD OR HALF WORD
;FOR IT (ENTRY SUBST)

SUBST:	MOVE	E,VALUE1	;GET NEW VALUE
	MOVEM	E,OLDSUB	;SAVE FOR NEXT TIME
	TROA	F,SUB		;SET SUBSTITUTION AND RETURN FLAGS
FIND:	TRZ	F,SUB		;FIND ONLY - ENSURE FLAG CLEAR
	TROE	F,RTP		;SET FOR RETURN - WAS IT ALREADY?
	JRST	FIND1		;YES - DON'T SAVE VALUES
	TRZN	F,ITR		;DID HE GIVE AN ITER AT ALL?
	SETOM	ITERAT		;NO - MAKE IT SO IT WON'T TURN ZERO
	SKIPN	ITERAT		;IS NUMBER ZERO?
	AOS	ITERAT		;YES - SET TO FIND ONE
	DMOVE	A,VALUE 	;GET VALUE TO LOOK FOR, AND MASK
	DMOVEM	A,OLVALU	;SAVE BOTH FOR NEXT TIME
FIND1:	MOVE	B,(PT)		;GET VALUE OF LOCATION
	TDZ	B,MASK		;MASK OUT UNWANTED PARTS
	CAMN	B,VALUE 	;MATCH WITH GIVEN VALUE?
	PUSHJ	P,FIND2 	;YES - TELL HIM IT IS FOUND
	AOJ	WD,		;BUMP WORD NUMBER
	AOBJN	PT,FIND1	;AND LOOP THROUGH RANGE
	JRST	WOTNOW		;THEN GET ANOTHER COMMAND

FIND2:	MOVEI	A,2
	SOSN	ITERAT		;DECREMENT COUNTER - ZERO?
	ADDM	A,(P)		;YES - PRINT THIS ONE AND QUIT
	MOVEM	WD,FILPTR	;SET UP NEW FILE POINTER HERE
	TRNN	F,SUB		;WANT A SUB?
	PJRST	PRINT		;NO - PRINT THE VALUE AND RETURN
	PJRST	CHANG1		;MAKE CHANGE, PRINT, AND RETURN

;SUBROUTINE TO WRITE IN TEMP CORE AND RUN VIRTUAL BITED (BITVIR)

GETVIR: MOVE	A,[3,,TBLOCK]	;WRITE FILE SPECS IN TEMP CORE
	MOVEM	F,SAVEF
	TMPCOR	A,
	  JFCL                  ;FAILED - JUST ASK USER FOR SPECS AGAIN
	OUTSTR	[ASCIZ /FILE TOO LARGE TO FIT IN CORE - RUNNING VIRTUAL EDITOR
/]
	MOVE	A,[1,,RUNFIL]	;RUN VIRTUAL BITED
	RUN	A,
	  HALT			;IN CASE OF ERROR

;SUBROUTINE TO OUTPUT HELP MESSAGE

HELP:	OUTSTR	HLPMES		;GIVE THE POOR GUY A HAND
	JRST	WOTNOW		;THAT'S ENOUGH

DEFINE HELL,<			;SUBTERFUGE TO SAVE CREF OUTPUT
HLPMES: ASCIZ	?COMMANDS TO BITED:
B				toggle BASE of word numbers
C <range> [/ <value>]		CHANGE words of <range>, 1st one to <value>
D <range>			DELETE all words of <range>
E				EXIT, saving output file
F <range> / <value> [@ <number>] FIND all occurrences of <value> in <range>
G [<range>]			GOTO the word given by the RH of the first word
H				HELP (types this message)
I <range> [/ <value>]		INSERT new words in <range>
L <range>			LIST <range> to lineprinter
N				NEWFILE wanted; drop present file
O [<n>,...,<n> or A,H,I,S]	OUTFORMAT - output in special pattern
P [<range>]			PRINT <range> to tty
Q				QUIT, dropping everything
R <number>			RELOCATE word 0 as word <number>
S <range> / <nvalue> = <ovalue> [@ <number>]
				SUBSTITUTE <nvalue> for all <ovalue> in <range>
T				TYPE out the FILESPECS currently in effect
W				WRITE file; do not exit?
>
				;NOW LIST IT
	XLIST
	HELL
	LIT			;PUT LITERALS IN HISEG
	LIST

;DISPATCH TABLE OF COMMANDS
;THE ONES WITH FLAGS ON THE LH WANT AN IOWD MADE OUT OF THE RANGE

CMDTBL: NOTYET
	BASE
	XWD	STP,CHANGE
	XWD	STP,DELETE
	EXOUT
	XWD	STP!FDR,FIND
	XWD	STP,GOTO
	HELP
	XWD	STP!INR,INSERT
	NOTYET
	NOTYET
	XWD	STP,LIST
	NOTYET
	NEWFIL
	OUTFMT
	XWD	STP!PTR,PRINT
	QUIT
	RELOK
	XWD	STP!FDR,SUBST
	TSPECS
	NOTYET
	NOTYET
	WRITE
	NOTYET
	NOTYET
	NOTYET

QUERY:	ASCIZ /FILE=/
PROMPT: ASCIZ	/
*/

;STORAGE

	RELOC			;BACK TO LOW SEGMENT

STACK:	BLOCK	20		;PUSH-DOWN STACK
SPECS:	BLOCK	10		;FILE SPECS
JOBREL: 0			;SAVE .JBREL
FILBAS: 0			;ABSOLUTE BASE OF EDITED FILE
FILTOP: 0			;ABSOLUTE TOP OF EDITED FILE
FILPTR: 0			;RELATIVE PRESENT LOCATION IN FILE
RELFIL: 0			;RELOCATION FACTOR
ENDLOC: 0			;ENDING LOCATION OF CMND
VALUE1: 0			;VALUE TO BE SUBSTITUTED
VALUE:	0			;VALUE FOR CMND
MASK:	0			;MASK FOR WILD OCTAL BYTES
BYTTAB: EXP 11,4,1,4,22,-1	;5 WORDS FOR BYTE SIZES (+1 FOR END MARKER)
				;START WITH INSTRUCTION FORMAT
OLLINE: 10			;NUMBER OF LINES PRINTED FOR THE LAST P CMND
OLVALU: 0			;WORD FOUND FOR THE LAST F COMMAND
OLMASK: 0			;MASK USED FOR THE LAST F COMMAND
OLDSUB: 0			;NEW WORD FOR LAST S COMMAND
ITERAT: 0			;NUMBER OF COPIES OF WORD TO BE FOUND
RADIX:	10			;FOR WORD NUMBERS
NUMSIZ: Z			;SIZE OF WORD NUMBERS
LPTBF:	BLOCK	3
LPTFIL: BLOCK	4
LPTBLK: 0
	SIXBIT	/LPT/
	XWD	LPTBF,0

OUTFIL: BLOCK	4
INFIL:	5			;FIVE ARGUMENTS FOR EXTENDED LOOKUP
	BLOCK	4
FILSIZ: Z			;SIZE OF FILE, FROM LOOKUP
INBLK:	16
	SIXBIT /DSK/
	Z
OUTBLK: 16
	SIXBIT	/DSK/
	0
SAVEF:	0
	EXP	0,0,0

CCW:	Z			;CHANNEL COMMAND WORD FOR INPUT
	Z			;END OF CHANNEL COMMAND LIST

TBLOCK: SIXBIT	/BTD/
	IOWD	24,OUTFIL
RUNFIL: SIXBIT	/DSK/
	SIXBIT	/BITVIR/
	0
	0
	1,,4

	END	NEWFIL
      7 \¯