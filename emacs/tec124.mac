	ERRMSG=1
SUBTTL	Text Editor and COrrector	RC CLEMENTS/PMH/CAM/JMP/GSB/RCM/CBD
SUBTTL	Introduction

  ;Version number

	TECVER==124
	TECMIN==1
	TECEDT==320
	TECWHO==7


	SEARCH	JOBDAT,MACTEN,UUOSYM	;UNIVERSAL FILES

	.DIRECTIVE	.XTABM	;TENEX STYLE MACRO'S

	TWOSEG	400K		;TWO SEGMENTS
	SALL

	SHOW.	%%JOBD		;JOBDAT VERSION NUMBER
	SHOW.	%%MACT		;MACTEN VERSION NUMBER
	SHOW.	%%UUOS		;UUOSYM'S VERSION NUMBER

OPDEF	AUXCAL	[42000,,0]

;COPYRIGHT 1970,1971,1972, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
;COPYRIGHT 1975 SNEVETS CORP.,BOHOKEN, J.N.
;COPYRIGHT 1976 ARMADILLO U., OSTENTATIOUS, USA
;COPYRIGHT 1976 MAJEBATH CORP.,UNIV. OF NH,DURHAM,NH
;	"BROUGHT TO YOU BY THE PEOPLE WHO BROUGHT YOU LOGIN"



IFN	0	<

THE FOLLOWING SYMBOL IS USED BY THE 'EE' COMMAND CONTINUE ROUTINE
TO DECIDE WHETHER THE VERSION OF TECO.SHR THAT IT GOTSEG WILL WORK
PROPERLY WITH THE LOW FILE THAT GOTSEG IT.  IT MUST BE INCREMENTED
EVERY TIME THE LOW SEGMENT OF TECO IS ALTERED	>

XP	%TECOV,	24

	LOC	.JBVER
	VRSN.	TEC		;VERSION NUMBER

	LOC	.JBREN
	EXP	REE		;REENTRY ADDRESS


	RELOC	400K
	SUBTTL	Table of Contents

;		TABLE OF CONTENTS FOR TECO - Text Editor and COrrector
;
;
;			   SECTION			      PAGE
;    1. Introduction . . . . . . . . . . . . . . . . . . . . .   1
;    2. Table of Contents. . . . . . . . . . . . . . . . . . .   2
;    3. REVISION HISTORY . . . . . . . . . . . . . . . . . . .   3
;    4. MACRO DEFINITIONS
;         4.1   .CLNAM . . . . . . . . . . . . . . . . . . . .   4
;         4.2   CHKEO, ERROR & U . . . . . . . . . . . . . . .   5
;    5. DEFAULT ASSEMBLY PARAMETERS. . . . . . . . . . . . . .   6
;    6. ACCUMULATOR ASSIGNMENTS. . . . . . . . . . . . . . . .   7
;    7. CONTROL FLAGS
;         7.1   AC FF. . . . . . . . . . . . . . . . . . . . .   8
;         7.2   AC F2. . . . . . . . . . . . . . . . . . . . .   9
;    8. I-O CHANNELS . . . . . . . . . . . . . . . . . . . . .  10
;    9. MISC PARAMETERS. . . . . . . . . . . . . . . . . . . .  11
;   10. PSEUDO RUN UUO IF NEEDED . . . . . . . . . . . . . . .  12
;   11. STARTUP TIME INITIALIZATION. . . . . . . . . . . . . .  13
;   12. TEXT BUFFER INITIALIZATION . . . . . . . . . . . . . .  14
;   13. REENTER COMMAND. . . . . . . . . . . . . . . . . . . .  15
;   14. INITIALIZATION OF JOB DEPENDENT PARAMETERS . . . . . .  16
;   15. CCL Command processor. . . . . . . . . . . . . . . . .  17
;   16. RETURN NON-NULL TTY CHARACTER IN CH. . . . . . . . . .  19
;   17. TYPE A CHARACTER . . . . . . . . . . . . . . . . . . .  21
;   18. MESSAGE TYPE-OUT & NUMBER TYPE-OUT . . . . . . . . . .  23
;   19. RETURN NEXT COMMAND CHAR AT CURRENT LEVEL. . . . . . .  24
;   20. SCAN COMMAND STRING FOR CHARACTER IN TT. . . . . . . .  25
;   21. SKAN ROUTINE DISPATCH TABLES . . . . . . . . . . . . .  28
;   22. ACCEPT COMMAND STRING ROUTINE. . . . . . . . . . . . .  29
;   23. EXPAND THE COMMAND BUFFER. . . . . . . . . . . . . . .  31
;   24. PROCESS SPECIAL COMMAND EDITING CHARACTERS . . . . . .  33
;   25. BACK UP BYTE POINTER IN AA, LOAD APPROPRIATE CHARACT .  35
;   26. RUBOUT PROCESSOR . . . . . . . . . . . . . . . . . . .  36
;   27. VIDEO RUBOUT PROCESSOR . . . . . . . . . . . . . . . .  37
;   28. COMMAND DECODER. . . . . . . . . . . . . . . . . . . .  40
;   29. NUMERIC INPUT, VALRET, & ALTMODE PROCESSOR . . . . . .  41
;   30. COMMA & PARENTHESES PROCESSOR. . . . . . . . . . . . .  42
;   31. MATHEMATICAL & LOGICAL OPERATORS . . . . . . . . . . .  43
;   32. FLAGS - EOF, FORM FEED & . H Z POSITIONS . . . . . . .  44
;   33. = & ^T COMMANDS. . . . . . . . . . . . . . . . . . . .  45
;   34. ^H, ^F AND ^^ COMMANDS . . . . . . . . . . . . . . . .  46
;   35. EXTENDED ^T OPERATIONS . . . . . . . . . . . . . . . .  47
;   36. BACKSLASH PROCESSOR - AND NA COMMAND . . . . . . . . .  48
;   37. Q-REGISTER COMMANDS
;        37.1   U & Q. . . . . . . . . . . . . . . . . . . . .  49
;        37.2   %. . . . . . . . . . . . . . . . . . . . . . .  50
;        37.3   X. . . . . . . . . . . . . . . . . . . . . . .  51
;        37.4   G. . . . . . . . . . . . . . . . . . . . . . .  53
;        37.5   M, W, [ & ]. . . . . . . . . . . . . . . . . .  54
;   38. MISCELLANEOUS CHARACTER DISPATCHER . . . . . . . . . .  55
;   39. ^G COMMAND (GETTAB OR EXIT). . . . . . . . . . . . . .  56
;   40. E COMMANDS
;        40.1   DISPATCH ROUTINE & TABLE . . . . . . . . . . .  57
;        40.2   EL (SETUP AND OUTPUT ROUTINES) . . . . . . . .  58
;        40.3   EE (SAVE TECO'S STATE) . . . . . . . . . . . .  60
;        40.4   NEL & EE (LOW CORE). . . . . . . . . . . . . .  62
;        40.5   EE (RESTART CODE). . . . . . . . . . . . . . .  63
;        40.6   EI & EP (EDIT INSERT & EDIT PUT) . . . . . . .  64
;        40.7   EX & EXIT ROUTINES . . . . . . . . . . . . . .  67
;	 40.71	EQ (EXIT AND REENTER). . . . . . . . . . . . .  67A
;        40.8   ED (RUN UUO ON EXIT) . . . . . . . . . . . . .  69
;        40.9   ET, EO & EU. . . . . . . . . . . . . . . . . .  70
;        40.10  ES . . . . . . . . . . . . . . . . . . . . . .  71
;        40.11  EH (CHANGE ERROR MESSAGE LEVEL). . . . . . . .  72
;        40.12  EV (SET TERMINAL CHARACTERISTICS). . . . . . .  73
;        40.13  TERMINAL CHARACTERISTICS TABLES. . . . . . . .  75
;        40.14  EK (KILL) AND EN (RENAME). . . . . . . . . . .  76
;        40.15  ER (PREPARE TO READ A FILE). . . . . . . . . .  77
;        40.16  FILE SPEC SETUP. . . . . . . . . . . . . . . .  79
;        40.17  EB (EDIT BACKUP PROCESSOR) . . . . . . . . . .  80
;        40.18  I/O ERROR ROUTINES . . . . . . . . . . . . . .  82
;        40.19  EW (EDIT WRITE). . . . . . . . . . . . . . . .  83
;        40.20  EZ & EF. . . . . . . . . . . . . . . . . . . .  86
;        40.21  EM (MTAPE UUO'S) . . . . . . . . . . . . . . .  87
;        40.22  EB (FINISH UP COMMAND) . . . . . . . . . . . .  88
;        40.23  EW (SUBROUTINES FOR EW). . . . . . . . . . . .  90
;        40.24  MISC. ROUTINES . . . . . . . . . . . . . . . .  91
;   41. ^V, ^W, ^X COMMANDS. . . . . . . . . . . . . . . . . .  93
;   42. ROUTINE TO PARSE FILE DESIGNATOR . . . . . . . . . . .  94
;   43. TABLES FOR FILSPEC PARSER. . . . . . . . . . . . . . .  98
;   44. Y. . . . . . . . . . . . . . . . . . . . . . . . . . . 101
;   45. ^Y ! ^P - QUICK PAGE SCAN COMMANDS . . . . . . . . . . 103
;   46. READ A CHARACTER FROM INPUT FILE . . . . . . . . . . . 104
;   47. INSERT COMMAND . . . . . . . . . . . . . . . . . . . . 105
;   48. ALPHA CASE CONVERTED . . . . . . . . . . . . . . . . . 109
;   49. CHECK FOR NON-CONTROL CHARACTERS . . . . . . . . . . . 110
;   50. NI . . . . . . . . . . . . . . . . . . . . . . . . . . 111
;   51. NT . . . . . . . . . . . . . . . . . . . . . . . . . . 112
;   52. PUT A CHARACTER IN THE OUTPUT FILE . . . . . . . . . . 113
;   53. PW . . . . . . . . . . . . . . . . . . . . . . . . . . 117
;   54. NJ, NC, & NL COMMANDS. . . . . . . . . . . . . . . . . 119
;   55. ROUTINE TO RETURN CURRENT ARGUMENT IN B. . . . . . . . 120
;   56. ND . . . . . . . . . . . . . . . . . . . . . . . . . . 121
;   57. SEARCH COMMANDS. . . . . . . . . . . . . . . . . . . . 122
;   58. SCAN INSERT ARGUMENT IF F-SEARCH . . . . . . . . . . . 127
;   59. ACTUAL SEARCH. . . . . . . . . . . . . . . . . . . . . 128
;   60. SEARCH STRING FOUND. . . . . . . . . . . . . . . . . . 129
;   61. AUTOTYPE AFTER SUCCESSFUL SEARCHES . . . . . . . . . . 131
;   62. V COMMAND. . . . . . . . . . . . . . . . . . . . . . . 134
;   63. ^E COMMANDS. . . . . . . . . . . . . . . . . . . . . . 135
;   64. ^EW, ^ED, ^EL, ^ES COMMANDS. . . . . . . . . . . . . . 136
;   65. ^E[A,B,C,. .]. . . . . . . . . . . . . . . . . . . . . 137
;   66. RANDOM ^<CHAR> PROCESSORS. . . . . . . . . . . . . . . 138
;   67. F SEARCHES . . . . . . . . . . . . . . . . . . . . . . 140
;   68. <> . . . . . . . . . . . . . . . . . . . . . . . . . . 141
;   69. OTAG$. . . . . . . . . . . . . . . . . . . . . . . . . 143
;   70. " ' PROCESSING . . . . . . . . . . . . . . . . . . . . 145
;   71. EXECUTE INDIVIDUAL " COMMANDS. . . . . . . . . . . . . 146
;   72. ROUTINE TO TEST CHARACTER FOR $,%,.,0-9,A-Z. . . . . . 147
;   73. ERROR MESSAGE PRINTOUT . . . . . . . . . . . . . . . . 148
;   74. ROUTINE TO TYPE C(TT) IN SIXBIT. . . . . . . . . . . . 153
;   75. ERROR PROCESSING ROUTINES. . . . . . . . . . . . . . . 154
;   76. DISPATCH TABLE FOR SPECIAL INFORMATION TYPEOUT . . . . 155
;   77. SPECIAL INFORMATION TYPEOUT ROUTINES . . . . . . . . . 156
;   78. UUO HANDLER. . . . . . . . . . . . . . . . . . . . . . 159
;   79. COMMAND TO COMPLEMENT TRACE MODE. "?" AS A COMMAND . . 160
;   80. ROUTINE TO RETURN STRING OPERATION STRING ARGUMENTS. . 161
;   81. ROUTINE TO RETURN IN CH THE CHARACTER TO THE RIGHT O . 162
;   82. ROUTINES TO MOVE CHARACTERS AROUND . . . . . . . . . . 163
;   83. GARBAGE COLLECTOR. . . . . . . . . . . . . . . . . . . 166
;   84. **********AUTOMATIC MEMORY EXPANSION*********. . . . . 170
;   85. COMMAND DISPATCH TABLE . . . . . . . . . . . . . . . . 172
;   86. LOW SEGMENT. . . . . . . . . . . . . . . . . . . . . . 173
	SUBTTL REVISION HISTORY

COMMENT	{
START OF VERSION 123A
205	FIX LOOPING EEE.
206	FIX FILE SPEC SCANNER WHEN TRACE MODE USED.
207	CHANGE CORE ERROR MESSAGE.
210	ADD ^G WITH NO ARGUMENT TO RETURN MY JOB NUMBER.
211	FIX :EP SO IT WORKS.
212	IMPLEMENT ^Y.
213	SO PEOPLE WITHOUT TECO.INI CAN ^G^G *I$$ FIRST COMMAND.
214	EI-EP SEES DEVICE.
215	NO TYPEOUT AFTER ^C^C REE.
216	EP[P,PN] INTERFERED WITH EB.
217	REMOVE FEATURE TO APPEND LOOKUP/ENTER/RENAME ERROR CODE TO PDL OV'S.
220	FIX RANDOM CORE MESSAGES FROM INI FILES.
221	INTERFACE TO JOBDAT.UNV AND CORRECT MISC BUGS.
	 A) FIX 'MAKE' OR 'TECO' FILE.'.' WORK CORRECTLY
	 B) SUPPORT SOS PAGE MARKS
	 C) SET TTY NO ALT COMPATIBLITY
	 D) DELAY IN CLEARING EB AND OUTPUT FLAGS ON EX
	    COMMAND IN CASE ERROR OCCURS IN PROCESSING
222	SEARCH MACTEN AS WELL AS JOBDAT
223	INTERFACE WITH MACTEN MORE COMPLETELY. CLEAN UP THE SUBTTLS AND
	CHANGE NUMERICS TO BE THE INSTRUCTIONS
224	FIX ENTER ERROR 17'S FOR PEEPLE WHO HAVE FANCY DISK ALLOCATION
	ON IN THE MONITOR.
225	FIX PROBLEM WITH U MACRO. ADD TED: AS THE DEFAULT DEVICE ON
	AN EI OR EP COMMAND.
226	MAKE EP DEFAULT TO DSK: INSTEAD OF TED:
227	MAKE ERROR MESSAGE FINDER FASTER
230	FIX ^Y WITH NO ARG TO NOT THROW AWAY CURRENT PAGE
231	ADD USETI ON ER'D FILE FOR CONVENIENCE.
232	FIX EA TO WORK IF FILE NO EXIST, MAKE TE FILE[NOT ME] TO
	WRITE FILE ON [DEFAULT]
233	PREVENT S^ES$ FROM ALLOWING "." TO ESCAPE THE TEXT BUFFER.
234	FIX :SEARCH IN AN ITERATION TO NOT LEAVE GARBAGE AROUND.
235	FIX PROBLEMS WITH TECENT-20 ERRORS. EXTENDED ENTER USED THE
	SAME AREA AS DID THE SEARCH MATRIX. THEREFORE TO SOLVE
	THE PROBLEM MAKE THAT AND THE DSKCHR BLOCK SEPERATE AREAS.

***START OF U. TX. REVISIONS****  (236-249 NOT USED;PATCHES ONLY,
				   SEE TEC124.DIF FOR NEW FEATURES)

250	INSTALLED DEBUG SWITCH TO SAVE SYMBOL TABLE AND READ TECO.ERR
	FROM [-] RATHER THAN SYS:.  (= DEC #140)
251	PATCH FOR LARGE Q-REG STACK (SPR # 13756)
252	DO AN INITIAL CORE UUO IF .JBFF > .JBREL-202 TO PREVENT
	ILL MEM REF'S.
253	MAKE ^G<SPACE> IGNORE ET SETTING AND ALWAYS USE ARROW MODE
254	FIX ^<LOWER CASE A> BUG  (SPR # 18802)
255	FIX ILL Q-REG NAME  (DEC EDIT # 170)
256	MAKE BYTE PTR. BACKUP MORE EFFICIENT
257	DONT LET EXTRA BLANKS IN AN ARITHMETIC EXPRESSION CAUSE TROUBLE
	(DEC EDIT # 167)
260	MAKE SURE M,NP FLAGS BIT 35 OF FIRST SEQ. NUMBER. 
	REMOVE DEC #122 WHICH ONLY DID IT FOR HP.
261	MORE SEQ# FIXING:  /SUPLSN NEEDS TO USE SLOW PUNCH ROUTINE
	FILES PROCESSED BY SOS NO LONGER MESSED UP.  INSTALL EQUIVALENTS
	OF DEC #'S 115, 141, 150.
262	STILL MORE SEQ# FIXING:  DON'T ALLOW NULL CHARACTERS IN FILE
	(INTENDED FOR STARTING SEQ #'S ON WORD BOUNDARIES) IF /SUPLSN
	IS SET.
263	ZERO DOUBLE ARG FLAG IN SEARCHES SO THAT SUBSEQUENT COMMANDS
	DON'T GET CONFUSED.
264	FIX :FS...$$ SO IT RECOGNIZES DOUBLE ALTMODE.  (SPR # 18199)
265	FIX GARBAGE COLLECTION BUG (DEC EDIT # 161)
266	FIX ?ILL COMMAND ^<CHAR>  (SPR # 18607)

NOTE:  ALL DEC EDITS THROUGH 171 OR THEIR EQUIVALENTS ARE IN.
START OF VERSION 124

267	FIX ADDRESS CHECK ON LOOKUP OF TMP FILE WHEN TMPCOR FAILS.
270	MAKE UUO ERROR MSG TYPE ENTIRE INSTRUCTION (SPR#19879)
271	FIX GARBAGE COLLECTION FROM EC AND EP.  Q-REGISTER STACK WASN'T
	GETTING COLLECTED SINCE AC 17 CLOBBERED.
272	FIX ILL. UUO MSG AFTER .REENTER WHILE AC'S HAVE FAST CODE TO
	MOVE CHARACTERS.  FIX MINOR BUGS IN FILESPEC SCANNER AND /R.
273	MAKE EXTENDED CCL COMMAND STRING WORK WITH .TMP FILES
274	FIX ILL. UUO. BUG RIGHT THIS TIME...(EDIT 272 GOOFED).
275	FIX BAD ARG PROCESSING TO MAKE THINGS LIKE -1^F= AND
	:5-1^T== AND -1A==  WORK PROPERLY. FINALLY GET EI ARG
	PROCESSING TO WORK PROPERLY.  M,NEIFILE$ WORKS, AS WELL AS
	MEIFILE$ AS WELL AS M,EIFILE$  (WHERE FILE HAS THE SECOND
	ARG ALREADY).
276	FIX BUG IN ERROR MSG FILE ACCESS.  MAKE ^G WITH ONLY ONE
	ARG DO A PEEK INSTEAD OF A GETTAB.
277	SAVE A WORD WASTED BY EDIT 261.  INSTALL DEC EDIT 172 (PROPER BOUNDS
	CHECKING). INSTALL EQUIVALENT OF DEC EDIT # 174.
300	FIX FAILURE WHEN RENAMING THE .TMP FILE (EB) IN AN AREA NOT
	YOUR OWN.

*** BACK TO STEVENS/RAPIDATA AGAIN

277A	FIX BUG IN REENTER (P MAY NOT CONTAIN A PDL)
300A	FIX ARGS FOR TRMOP. TO GET TTY WIDTH
301	CHANGE E<CHAR> SELECTION ALGORITHM
302	CHANGE .RB??? DEFINITIONS SO THAT THEY USE UUOSYM.
303	Removed.
304	CHANGE THE FLAG NAMES AND THE DEFINITIONS.  NOW USE THE TX??
	MACROS	FROM MACTEN FOR THE FLAGS.
	FF	FLAGS ==>  F.????
	F2	FLAGS ==>  S.????
305	BISSW was added to allow TECO to make limited use of the
	Business Instruction Set.  The code will not be removed,
	but it will also not be used.  It turns out to be considerably
	slower than TECO's old mechanism and move string backwards.
	is not possible.
306	Change the error code for Undefined Terminal Type
307	See edit 277.
310	Add /INPLACE so that EB will ER EW to same place.
311	Finish fixing the flags (Edit 304).
312	Remove the PDP6 feature test.

***BACK TO TEXAS...

313	Increase efficiency of FS when both strings are the same length
	by skipping character-moving code.
314	Work on CRT stuff some more.  Make treatment of no wrap-around
	better.  Add ^N20 to error routines to type list of valid CRT types.
315	Modify EW defaulting so that it won't use the ER device if it is
	an ersatz. (For the same reason that it won't use ER's PPN.)

	Equivalents of DEC EDITS up to 174 are in. Also 176.
316	Fix SKAN routine so that the character after a PW
	is not ignored and so that  @FD/.../ gets scanned properly.


320	Fixed EE command to gettab the FPN and NAM/wrs
317	 ADD IN UNH FEATURES SUCH AS "FTRESCAN","FTEAGAIN","FTSWTCH",
	AND "FTKL10"

	 ADD IN THE ^G_ COMMAND TO TYPE OUT THE CONTENTS OF THE
	SEARCH BUFFER	(FTNCM2)

	 ADD IN THE "V" FOR VERIFY COMMAND.	(FTNCM1)

	 ADD IN THE COMMANDS <LF> AND ^H; IF THESE ARE SEEN AS THE FIRST 
	CHARACTERS IN THE COMMAND STRING, THEN DO EITHER AN LT$$ OR A
	-LT$$ RESPECTIVELY.  THESE WORK JUST LIKE THE *A COMMAND TO PUT
	THE LAST COMMAND STRING INTO Q-REGISTER A 	(FTNCM0)

	 RE-DO THE TABLE OF CONTENTS TO BE ACCURATE

	B.J. THOMAS, UNH, DURHAM, NH	17-FEB-78

{
	SUBTTL	MACRO DEFINITIONS -- .CLNAM

COMMENT \

MACRO TO GENERATE TEXT CONTAINING CORRECT VERSION INFORMATION

DEFINE THE MACRO .NAME TO BE WHAT YOU WANT, FOR EXAMPLE:

	DEFINE	.NAME(V,M,E,W)<
	TITLE	PROGRAM %'V'M'('E')'W
	>

THEN CALL THE .CLNAM MACRO:
	.CLNAM	FOO
WHERE THERE ARE SYMBOLS DEFINED AS THE VERSION, MINOR VERSION
(1=A, 2=B, ETC), EDIT, AND "WHO" VALUE.  IT WILL GENERATE EXACTLY
WHAT'S IN THE .NAME DEFINITION, WITH THE DUMMY ARGS SUBSTITUTED
APPROPRIATELY (INCLUDING THE MINOR VERSION).
THE SYMBOLS "FOOVER", "FOOMIN", "FOOEDT", AND "FOOWHO" ARE USED
SIMILAR TO THE WAY THE VRSN. MACRO WORKS.
\

	DEFINE	.CLNAM(FOO)<
	  DEFINE  .CLNM(LETTER,WHO)<
	    IRPC LETTER,<
	      IFE "A"-"'LETTER'"+FOO'MIN-1,<
		STOPI
		IFIDN <LETTER><@>,<
		  IFE FOO'WHO< .NAME(\FOO'VER,,\FOO'EDT,)>
		  IFN FOO'WHO< .NAME(\FOO'VER,,\FOO'EDT,-WHO)>>
		IFDIF <LETTER><@>,<
		  IFE FOO'WHO< .NAME(\FOO'VER,LETTER,\FOO'EDT,)>
		  IFN FOO'WHO< .NAME(\FOO'VER,LETTER,\FOO'EDT,-WHO)>>>>>
	IFG	FOO'MIN-^D26,< FOO'MIN==0
	  PRINTX %MINOR VERSION TOO LARGE - IGNORED>
	IFG	FOO'WHO-7,< FOO'WHO==0
	  PRINTX %WHO VERSION TOO LARGE - IGNORED>
	.CLNM(@ABCDEFGHIJKLMNOPQRSTUVWXYZ,\FOO'WHO)
>
DEFINE	.NAME(V,M,E,W),<
	TITLE	TECO %'V'M(E)'W   TEXT EDITOR AND CORRECTOR
>

.CLNAM	TEC

	SUBTTL	MACRO DEFINITIONS -- CHKEO, ERROR & U

;CHECK EO FLAG: CHKEO	EO#,ADDR
;IF EOFLAG > EO#, RETURN AT CALL+1
;OTHERWISE GO TO ADDR

DEFINE	CHKEO(E,A)
	<1B22+<E>B30,,A>

;TYPE ERROR MSG: ERROR	E.XXX
;TYPE MESSAGE CORRESPONDING TO 'XXX'
;THEN GO TO GO

;THE FOLLOWING IS THE DEFINITION OF THE REGULAR ERROR UUO

DEFINE	ERROR(X)
	<1B8+'X'
	'X'=<''X''>&777777>

;THE FOLLOWING IS THE DEFINITION OF THE COLONABLE ERROR MESSAGES
;THIS IS USED FOR THE NEW ERROR HANDLING WITH COLON CONTRUCTION
;IF AN ERROR OCCURS AND THE ..ERROR UUO IS EXECUTED, THE COLON FLAG
;IS CHECKED TO SEE WHETHER YOU SHOULD RETURN A VALUE OF 0 OR PROCEED
;AND TYPE OUT THE ERROR MESSAGE

DEFINE	..ERROR(X)
	<1B8+10B12+'X'
	'X'=<''X''>&777777>

OPDEF	TYPR1 [2B8]
SUBTTL	DEFAULT ASSEMBLY PARAMETERS

NDS.	CCL,	 1			;CCL CAPABILITY
NDS.	TEMP,	 1			;TMPCOR UUO CAPABILITY
NDS.	RUBSW,	0			;DON'T MIMIC MONITOR
NDS.	NORUNS,	0			;RUN UUO CAPABILITY
NDS.	AUTOFS,	0			;DEFAULT IS NON-AUTOTYPE AFTER SEARCHES
NDS.	TYCASW,	0			;DEFAULT TYPE-OUT MODE CAUSES FLAGGING OF
					;CHARACTERS IN THE LOWER CASE RANGE WITH '
NDS.	SRCHSW,	0			;DEFAULT PREVAILING SEARCH MODE IS ACCEPT
					;EITHER LC OR UC ALPHABETICS AS A MATCH
NDS.	BUFSIZ,	^D128			;128 WORD I/O BUFFERS
NDS.	LPDL,	 120			;80 WORD PDL
NDS.	LPF,	 40			;32 WORD Q-REGISTER PDL
NDS.	VC,	0			;V COMMAND NOT IMPLEMENTED
NDS.	EOVAL,	2			;THE STANDARD SETTING OF THE EO FLAG FOR
					;THIS VERSION IS 2
BUGSW==1
NDS.	BUGSW,	0			;STANDARD IS DON'T SAVE SYMBOLS
NDS.	CRT,	1			;CRT RUBOUT HANDLING CAPABILITY
NDS.	BISSW,	0			;SUPPORT BIS (SLOW...)


;FOR ANY OTHER VERSION ASSEMBLE AS FOLLOWS:
;.R MACRO
;*TECO_TSK:TECO.MAC
;CCL=0				(IF CCL NOT WANTED)
;TEMP=0				(IF TMPCOR UUO NOT WANTED)
;ERRMSG=1			(IF SHORT ERROR MESSAGES WANTED OR
;				 =3 IF EXTRA LONG ERROR MESSAGES WANTED)
;NORUNS=1			(IF RUN UUO SIMULATION WANTED)
;AUTOFS=-1			(IF DEFAULT = AUTOTYPE AFTER SEARCHES WANTED)
;TYCASW=1			(IF TYPE-OUT CASE FLAGGING DEFAULT VALUE
;				 TO FLAG UPPER CASE INSTEAD OF LOWER CASE
;				 CHARS. WANTED)
;TYCASW=-1			(IF TYPE-OUT CASE FLAGGING DEFAULT VALUE
;				 FOR NO FLAGGING WANTED)
;SRCHSW=1			(IF EXACT MODE WANTED AS THE DEFAULT VALUE
;				 OF THE PREVAILING SEARCH MODE)
;BUFSIZ=^D256			(IF 256-WORD I/O BUFFERS WANTED. ANY
;				 OTHER CONSTANT BESIDES 256 MAY BE USED.
;				 TECO USES STANDARD MONITOR BUFFERING,
;				 BUT IF THE MONITOR PROVIDES BUFFERS
;				 LARGER THAN 128 WORDS, BUFSIZ MUST BE
;				 CHANGED SO THAT SUFFICIENT SPACE IS
;				 RESERVED.
;LPDL=N				(WHERE N	120, IF LARGER PDL WANTED)
;LPF=N				(WHERE N	40, IF LARGER Q-REGISTER PDL WANTED)
;EOVAL=N			(WHERE 0<N<2, IF EO-CONTROLLED FEATURES ADDED
;				 SINCE EO=N WAS STANDARD ARE NOT WANTED)
;BUGSW=1			(IF SAVE OF SYMBOL TABLE IS DESIRED)
;CRT=0				(IF CRT RUBOUT HANDLING NOT WANTED)
;^Z
;^Z



;
;				IF NON-ZERO, THEN ...
FTSWTCH==0		;NO SWITCH.INI AT TYMSHARE
NDS.	FTSWTCH,	-1	; READ SWITCH.INI IF NO TECO.INI
NDS.	FTNCM0,		-1	; USE NEW COMMANDS " ","<^H>"
NDS.	FTNCM1,		-1	; THE "V" COMMAND
NDS.	FTNCM2,		-1	; PRINT OUT THE SEARCH BUFFER; "^G_" COMMAND
NDS.	FTFDAE,		-1	; ALLOW FOR FILE DAEMON
NDS.	FTKL10,		-1	; CPU HAS KL-10 INSTRUCTION SET
NDS.	FTEAGAIN,	-1	; ALLOW "EQ" FOR EDIT AGAIN
FTRESCAN==0
NDS.	FTRESCAN,	-1	; ALLOW "R TECO-FILESPEC"
IFN	FTRESCAN,<
	..TMP==CCL+TEMP-2
IFN	..TMP,<
	PRINTX ?FTRESCAN REQUIRES CCL AND TEMP
	PASS 2
	END
		>
	PURGE	..TMP
	>

IFN	FTNCM1,<
	IFN	VC,<PRINTX % V COMMAND WILL GIVE VERIFY
	VC==0	>>
SUBTTL	ACCUMULATOR ASSIGNMENTS

FF=	0	;CONTROL FLAGS
P=	1	;PUSH DOWN POINTER
		;*** A, AA AND B MUST BE CONTIGUOUS AND IN THAT ORDER ***
A=	2
AA=	3	;TYPE-IN POINTER TO COMMAND BUFFER & SEARCH TABLE INDEX
		;*** B AND E MUST BE ADJACENT AND B<11 ***
B=	4	;COMMAND BUFFER END ADDRESS
E=	5
C=	6
D=	7
F2=	10	;MORE CONTROL FLAGS
T=	11
		;*** TT AND TT1 MUST BE ADJACENT ***
TT=	12
TT1=	TT+1
I=	14
OU=	15
CH=	OU+1	;CHARACTER AC
PF=	17	;Q-REGISTER PDL PTR
SUBTTL	CONTROL FLAGS -- AC FF

;RIGHT HALF - AC FF

F.ALT==	1B35		;ALT-MODE SEEN
F.ARG2==1B34		;THERE IS A SECOND ARGUMENT
F.ARG==	1B33		;THERE IS AN ARGUMENT
F.SRCH==1B32		;REPLACEMENT SEARCH
F.SLSL==1B31		;@ SEEN
F.NSRH==1B30		;N SEARCH
F.COLN==1B29		;COLON SEEN
F.SYL==	1B28		;SYLLABLE FLAG
F.XPLN==1B27		;HAVE TYPED EXTENSION OF ERROR MESSAGE ALREADY
F.EM==	1B26		;HAVE TYPED 1ST LINE OF ERROR MESSAGE
F.LARW==1B25		;LEFT ARROW SEARCH
F.EMSG==1B24		;PROSESSING ERROR MESSAGE
F.SQIN==1B23		;OUTPUT: AFTER EOL NEXT 5 CHARS ARE SEQ #
			;INPUT:  IGNORE CHAR AFTER SEQ# IF IT'S TAB
F.TRAC==1B22		;? SEEN
F.SEQ==	1B21		;SEQUENCE NUMBER SEEN ON INPUT
F.BELL==1B20		;^G SEEN
F.DDTM==1B19		;NEED TO TYI IN DDT MODE
F.FORM==1B18		;A FORM FEED TERMINATED THE LAST YANK OR APPEND COMMAND

;LEFT HALF - AC FF

IFN	FTNCM0,<F.LFCM==1B17		; <LF> COMMAND >
IFE	FTNCM0,<F.XXXX==1B17		;***FREE***>
F.PMAT==1B16		;PREVAILING MATCH MODE
IFN VC,<
F.TABS==1B15		;TAB CORRECTION FOR VVAL
>
F.NNUL==1B14		;NON-NULL INSERT STRING (MIGHT BE ONLY ^V, SAY)
F.NEG==	1B13		;MINUS SIGN SEEN AS AN OPERATOR
F.TEMP==1B12		;TMPCOR UUO ALLOWED
F.EOFI==1B11		;INPUT CLOSED BY EOF
F.IOPN==1B10		;INPUT FILE IS OPEN
F.OOPN==1B09		;OUTPUT FILE IS OPEN
F.EBTP==1B08		;EB FUNCTION TEMPORARY FLAG
F.FILE==1B07		;AT LEAST ONE ELEMENT OF FILE SPEC GIVEN
F.PROT==1B06		;FILE PROTECTION WAS SPECIFIED
F.INIT==1B05		;INIT FILE READING
F.UBAK==1B04		;EB IN EFFECT
F.TALK==1B03		;MESSAGE TYPE OUT IN GRABAK?
F.TYOF==1B02		;NEED TO OUTPUT A BUFFER
F.TCTL==1B01		;ALLOW CONTROL CHARS TYPED WITHOUT "^"
F.CCL==	1B00		;TECO COMMAND REQUESTS Y AFTER EB
SUBTTL	CONTROL FLAGS -- AC F2

;RIGHT HALF - AC F2

S.CTLV==1B35		;^V SEEN INSIDE TEXT
S.CTVV==1B34		;DOUBLE ^V SEEN INSIDE TEXT
S.CTLW==1B33		;^W SEEN INSIDE TEXT
S.CTWW==1B32		;DOUBLE ^W SEEN INSIDE TEXT
S.XMAT==1B31		;EXACT MATCH SEARCH MODE
S.EMAT==1B30		;TEMPORARILY ACCEPT EITHER UPPER OR LOWER CASE
S.LCTT==1B29		;TTY LINE HAS LC BIT ON
S.NCFL==1B28		;TYPE MESSAGE WITH NO CASE FLAGGING
S.OCTL==1B27		;OCTAL RADIX
S.CTLR==1B26		;^R SEEN AT INPUT TIME
S.SKMR==1B25		;WATCH FOR ^R WHEN SKIMMING
S.SKMQ==1B24		;WATCH FOR ^Q WHEN SKIMMING
S.NTRC==1B23		;DISABLE TRACING
S.TXTC==1B22		;TYPE <CR>, ETC INSTEAD OF PRINTER CONTROLS
S.SFSN==1B21		;SKANNING FS OR FN
S.NCCT==1B20		;NO CONTROL COMMANDS IN TEXT EXCEPT ^T, ^R
S.LCAS==1B19		;CONVERT UPPER CASE TO LOWER CASE BY DEFAULT
S.UCAS==1B18		;CONVERT LOWER CASE TO UPPER CASE BY DEFAULT

;LEFT HALF - AC F2

S.GOIN==1B17		;A COMMAND STRING HAS BEEN SEEN
S.CTLN==1B16		;^N IN SEARCH ARGUMENT
S.NALT==1B15		;DON'T CONVERT OLD ALTMODES TO 033
			;**** S.NRAD & S.YANK ARE EQUAL, THIS IS OK
S.NRAD==1B14		;NULL REPLACEMENT ALTMODE DELIMITED
S.YANK==1B14		;^Y NOT ^P IN PROGRESS
S.LOPN==1B13		;LOG FILE OPEN
S.INFO==1B12		;INFORM USER OF ANY CORE CHANGE WHEN DONE
S.DOIT==1B11		;M<FILE> AS OPPOSED JUST HX*<FILE>
S.RTYP==1B10		;^G<BLANK> IN PROGRESS-ALWAYS USE ARROW MODE
S.EA==	1B09		;EDIT APPEND IN PROGRESS
S.MINS==1B08		;MINUS SEARCH
S.DELS==1B07		;TO DELETE TO FROM START TO PT SEARCH
S.ASTR==1B06		;DON'T PRINT STAR
S.SSEQ==1B05		;SUPPRESS SEQUENCE NOS ON INPUT
S.SLOG==1B04		;UNDER NO CIRCUMSTANCES SEN CHARACTER TO LOG FILE
S.OLOG==1B03		;WHEN AT TYOA, STICK IT IN THE LOG FILE ONLY
S.LIN==	1B02		;PUT YOUR TYPE IN IN THE LOG FILE
S.LOUT==1B01		;PUT TECO'S TYPE OUT IN THE LOG FILE
S.DPPN==1B00		;REMEMBER TO DEFAULT TO ZERO PPN
SUBTTL	I-O CHANNELS

;I-O CHANNELS

INCHN==	2
OUTCHN==3
TTY==	4	;CHANNEL FOR TTY IO
CCLCHN==5	;CHANNEL FOR THE CCL TMP FILE
ERRCHN==6	;CHANNEL FOR ERROR MESSAGE FILE
LOGCHN==7	;CHANNEL TO WRITE LOG FILE ON (IF ANY)
SAVCHN==10	;TO WRITE LOW SEG SAVE ON
INICHN==11	;TO READ INI FILE ON
SUBTTL	MISC PARAMETERS
.GTNAM==3	;GETTAB FOR NAME OF PROGRAM CURRENTLY RUNNING
.GTFPN==-25	;GETTAB FOR DIRECTORY CURRENT PROGRAM CAME FROM

BEGPAG==200	;FAKE ASCII CHAR = BEGINNING OF BUFFER
ENDPAG==201	;FAKE ASCII CHAR = END OF BUFFER IF NO EOL AT END
SPCTAB==202	;FAKE ASCII CHAR = SIGNAL TO SEARCH FOR A STRING OF SPACE/TABS
STABLN==^D131	;LENGTH OF SEARCH TABLE
GCTBL==	LPF+40
EE1==1B12	;PRINT UUO ERROR CODE AFTER ?XXX
EE2==2B12	;PRINT I/O ERROR CODE AFTER ?XXX
EE3==3B12	;PRINT NOTHING AFTER ?XXX BECAUSE NO CORE FOR ERROR FILE

EO21==	1	;TURN OFF SPECIAL VERSION 22+ FEATURES IF EO VALUE = 1


IFN	FTKL10,<			;; [BJT]
	OPDEF	ADJSP [105B8]		;; [BJT] KL-10 INSTRUCTIONS
	OPDEF	ADJBP [133B8]		;; [BJT]
	>				;; [BJT]
SUBTTL	PSEUDO RUN UUO IF NEEDED

IFN NORUNS,<
IFN CCL,<
NORUN1:	IOWD	.-.,INHERE	;MODIFIED FOR LENGTH
	0
NORUN2:	CORE	15,
	EXIT			;NOT ENOUGH CORE TO GET COMPIL
	IN	CCLCHN,NORUN1	;READ THE FILE
	JRST	NORBLT		;TO THE ACS
	EXIT			;NO GOOD.

INHERE:				;WHERE CODE APPEARS
NORAC:				;WHERE TO READ AC DATA FROM
	PHASE	0
NORBLT:	BLT	NORTOP,.-.	;ADR MODIFIED
	RESET
	AOS	1,.JBSA		;ADR + 1
	JRST	(1)		;START COMPIL
NORTOP:	XWD	INHERE+1,75	;MOVE COMPIL DOWN
	DEPHASE
	>>
SUBTTL	STARTUP TIME INITIALIZATION

	JRST	RST		;THIS MUST BE IN 400010 WHEN SSAVED
				;THIS IS USED BY THE EE COMMAND ROUTINE
				;SAVED IN THE LOW SEGMENT TO START TECO
				;AFTER A SAVE
TECO:
IFN CCL,<
	TDZA	B,B
	MOVNI	B,1		;THE CCL ENTRY
	>
	RESET			;INITIALIZE ALL IO
	SETZB	F2,LOCORE	;CLR DATA IN CASE OF ^C,ST & CLEAR F2
	MOVE	A,[XWD LOCORE,LOCORE+1]
IFE BUGSW,<BLT	A,@.JBREL>
IFN BUGSW,<BLT A,LOWEND-1>
IFN CCL,<MOVEM	B,CCLSW>
	MOVE	A,[PUSHJ P,UUOH];SET UUO TRAP
	MOVEM	A,.JB41
IFN	FTSWTCH,<
	SETZM	SW.INI		; ZERO SWITCH.INI FLAGS
	SETZM	INI.SW
	>
	MOVE	P,[XWD -LPDL,PDL]	;START ONE WORD DOWN
	HRRZ	B,.JBFF		;MAKE SURE WE HAVE AT LEAST 202 FREE WDS
	ADDI	B,202
	CAML	B,.JBREL
	CORE	B,
	JFCL			;KEEP GOING...WITH LUCK WE WILL AT LEAST GET
				;THE PROPER ?COR MESSAGE
	HRRZ	A,.JBREL	;.JBFF=.JBREL-202
	EXCH	A,.JBFF
IFN BUGSW,<MOVEM A,CMDBFR>
	ADD	A,[677,,-1]	;CBUF=[000700,,FF-1]
	MOVEM	A,CBUF
	MOVEI	A,201(A)
	IMULI	A,5
	MOVEM	A,BEG		;BEG:=(CBUF+200)*5
	MOVEM	A,PT		;PT:=(CBUF+200)*5
	MOVEM	A,Z		;Z:=(CBUF+200)*5
	MOVEM	A,QRBUF		;QRBUF:=(CBUF+200)*5
	PUSHJ	P,SETUP		;SET UP STUFF
	HRREI	A,TYCASW	;GET WHATEVER IS DEFAULT TYPE-OUT CASE FLAGGING MODE
	MOVEM	A,TYCASF	;AND MAKE IT CURRENT
	HRRZI	A,EOVAL		;INITIALIZE EO FLAG
	MOVEM	A,EOFLAG
	HRREI	A,AUTOFS	;INIT AUTOTYPE-AFTER-SEARCHES FLAG
	MOVEM	A,AUTOF
IFN CRT,<
	HLRZ	A,CRTGEN	;GET "GENERAL CRT" FLAGS
	MOVEM	A,CRTTYP	;STORE
	MOVEI	A,BACRUB
	HRLI	A,VCRT
	BLT	A,CTUSEQ
	>
	SETOM	INI		;REMEMBER TO DO INI FILE
IFN BISSW,< 			;BIS SUPPORT
	SETZM	A		;SEE IF KL10
	BLT	A,0		;...
	MOVEM	A,BIS		;NOTE RESULT
> ;END IFN BISSW
SUBTTL	TEXT BUFFER INITIALIZATION

;COMPUTE A VALUE WHICH IS 2/3 THE SIZE OF THE CHARACTER BUFFER.IF
;1/3 IS LESS THAN 128 CHARACTERS, THE BUFFER WILL BE 2/3 FILLED ON
;A "Y" OR "A" COMMAND,OTHERWISE, THE BUFFER WILL BE FILLED TO THE
;TOTAL AVAILABLE BUFFER - 128 CHARACTERS. PAYING ATTENTION TO THE
;FORM FEED AND LF OPERATORS.

;IT SHOULD BE NOTED THAT IN THE CASE OF AUTOMATIC
;MEMORY EXPANSION, THESE INSTRUCTIONS MUST BE RE-EXECUTED
;TO INSURE PROPER MEMORY BOUNDS.

	PUSH	P,INITG		;FOR IN LINE CODING POPJ
CRE23:	MOVE	A,.JBFF		;LATEST VALUE OF FF
	IMULI	A,5		;5 CHARACTERS PER MEM WORD
	MOVEM	A,MEMSIZ	;MEMSIZ:=C(.JBFF)*5
INITG:	POPJ	P,.+1		;EXIT OR CONTINUE

	MOVE	A,CBUF
	MOVEI	A,100(A)
	MOVEM	A,CBUFH		;CBUFH:=CBUF+77
	MOVEI	A,SYL
	MOVEM	A,DLIM		;DLIM:=SYL
	HRLOI	A,10014
	MOVEM	A,NROOM2	;NROOM2:=XWD 10014,-1
	MOVEI	FF,0		;CLEAR FLAG REGISTER
	SKIPE	SRHMOD		;IF DEFAULT SEARCH MODE IS NOT 0,
	TXOA	FF,F.PMAT	;MAKE EXACT MODE CURRENT
GOE:	TXZA	FF,777777-F.TRAC-F.EMSG-F.FORM-F.SEQ
GO:	TXZ	FF,777777-F.TRAC-F.FORM-F.SEQ
	TXZ	F2,S.SSEQ!S.SLOG!S.NTRC
	MOVE	P,[XWD -LPDL,PDL]	;INITIALIZE PUSHDOWN LIST
	MOVEM	P,PDLSAV
	SETZM	PDL		;FLAG PDL TOP - NOTE: PDL FLAGS ARE
				;0 = TOP OF PDL
				;-1= LAST ITEM IS AN ITERATION
				;+1= LAST ITEM IS A PARENTHESIS
				;>1= LAST ITEM IS A MACRO
	SETZM	XCTING		;NO LONGER DOING ANYTHING
	SETZM	EQM		;CLEAR THE MACRO LEVEL COUNT
	MOVE	PF,[XWD -LPF-1,PFL-1]
	AOSE	INI		;TO DO THE INI FILE?
	JRST	CLIS
	MOVSI	E,(MOVE B,)	;FIX ILL UUO PROB IN INI FILES
	HLLM	E,DLIM
	PUSHJ	P,CLREXT	;SET UP EXTENDED LOOKUP BLOCK
	TXO	F2,S.DOIT	;DO INI FILE
	SETOM	XCTING		;SO IT DO IT
	PUSHJ	P,TTOPEN	;OPEN THE TTY
	MOVSI	E,'INI'		;SET UP EXTENSION
IFN	FTSWTCH,<
	SETOM	INI.SW		; SAY WE WILL TRY TO READ SWITCH.INI
	>
	PUSHJ	P,INIFIL	;GET IT INTO CORE
IFN	FTSWTCH,<
	SETZM	INI.SW		; WELL, UN-DO THIS
	>
	JRST	CLIS		;GO DO REST
SUBTTL	REENTER COMMAND

REE:	CLRBFO			;STOP TYPEOUT
	MOVEM	P,TEMPP		;PRESERVE P
	PUSH	P,E
	MOVE	P,[IOWD 4,TEMPDL]	;SET UP STACK FOR SURE
	RELEAS	TTY,		;CLOSE TTY
	PUSHJ	P,TTOPEN	;REOPEN TTY
	POP	P,E		;RESTORE E, AFTER USE BY TTOPEN
	MOVE	P,TEMPP		;RESTORE P
	RELEAS	ERRCHN,		;FIX ADR CHECK
	AOSE	XCTING		;COMMAND IN PROGRESS?
	JRST	GO		;NO, GO AND LISTEN FOR INPUT
	JRSTF	@.JBOPC		;CONTINUE

;ROUTINE TO FIX PDL OV'S

PDLOV:	MOVSI	D,'PDL'		;FAKE AN ERROR MESSAGE
	TLNE	P,-1		;MAIN PDL ERROR?
	MOVSI	D,'PDQ'		;Q REG STACK
	HLRZM	D,.JBUUO	;PDL OV
	MOVEI	B,"["		;IN CASE PDQ
	SKIPE	CTGLEV		;WERE WE IN THE MIDDLE OF A ^G SEARCH?
	MOVEI	B,7		;YES
	MOVEM	B,ARGSTO	;SAVE IT
	SETZ	D,		;DON'T APPEND A LOOKUP/ENTER/RENAME ERROR CODE!
	JRSTF	ERRPDL		;CAUSE ERROR UUO TO HAPPEN
SUBTTL	INITIALIZATION OF JOB DEPENDENT PARAMETERS

SETUP:	MOVEI	A,PDLOV		;WHERE TO GO ON PDLOV
	MOVEM	A,.JBAPR	;SAVE
	MOVX	A,AP.REN!AP.POV	;ENABLE FOR PDL OV TRAPPING
	APRENB	A,		;SET TRAP
	HRROI	A,-23		;GET AUN
	GETTAB	A,
	 JFCL
	MOVEM	A,USRPPN
	SETOM	DEFPTH		;GET DEFAULT PATH
	MOVE	E,[11,,DEFPTH]
	PATH.	E,
	MOVEM	A,DEFPTH+2	;IF NOT, JUST PPN
	MOVSI	A,'DSK'		;DEFAULT DEVICE
	MOVEM	A,ERSPEC	;SAVE FOR DEFAULT ER COMMAND
	SETOM	MONITR		;GET MONITOR SERIES NUMBER
	MOVX	A,%CNSTS
	GETTAB	A,		;WHICH MONITOR?
	JRST	TECO2		;3 SERIES (MONITR=-1)
	TXNE	A,ST%TDS	;WHAT MONITOR ?
	AOS	MONITR		;5 SERIES (MONITR=+1)
	AOS	MONITR		;4 SERIES (MONITR=0)
TECO2:	PJOB	A,		;GET JOB #
	MOVEM	A,JOBN
	MOVEI	C,3		;SET CTR
JOBLUP:	IDIVI	A,12		;CONVERT JOB# TO DECIMAL ASCII IN LEFT HALF
	ADDI	AA,20
	LSHC	AA,-6
	SOJG	C,JOBLUP
	HRRI	B,(SIXBIT /TEC/);FORM NAME ###TEC
	MOVEM	B,TMPTEC	;SAVE
	HRROI	A,.GTWCH	;GOING TO GET ERROR MESSAGE LEVEL BITS
	GETTAB	A,		;GET WATCH BITS
	SETZ	A,
	TXNN	A,JW.WMS
	TXO	A,JW.WPR!JW.WFL	;ASSUME FIRST LINE!PREFIX
	TXNE	A,JW.WCN
	TXO	A,JW.WFL
	MOVEM	A,ERRLEN	;-1=SHORT, 0=MEDIUM, +1=LONG
	MOVEM	A,PRMERR	;SAVE FOR DEFAULT
	POPJ	P,
SUBTTL	CCL Command processor

IFN CCL,<
TTYPT:	XWD	440700,TTYBFS	;CCL COMMAND BUFFER PTR
TTYPT2:	XWD	260700,TTYBFS	;TO INSERT FILE NAME AFTER EW OR EB


CCLIN:
IFN TEMP,<
IFE	FTEAGAIN,<
	MOVE	A,[XWD 2,TT]	;SET UP FOR TMPCOR READ & DELETE
	>
IFN	FTEAGAIN,<
	MOVE	A,[XWD 1,TT]	; SET UP ARG BLOCK FOR READ AND NO DELETE
	>
	HRLZI	TT,'EDT'	;SET UP READ BLOCK FOR TMPCOR UUO
	HRLZI	TT1,-15		;INCREASE CAPACITY TO 75 CHARS.
	HRRI	TT1,SAVE-1	;PLACE TO READ TMPCOR FILE
	TMPCOR	A,		;READ AND DELETE FILE EDT
	JRST	CCLTMP		;NO FILE EDT OR NO TMPCOR UUO
	MOVE	T,TTYPT2	;SET UP DDTOUT BUFFER POINTER
	MOVEI	C,2		;INIT CHAR CTR
	HRRZI	AA,SAVE		;GET START OF BUFFER AREA
	HRLI	AA,350700	;PICK UP EDT CHARACTERS, SKIP LINED "S"
CCLTM1:	ILDB	B,AA		;GET NEXT EDT CHARACTER
	CAIE	B,.CHCRT	;ONLY TERMINATORS ARE CR AND OLD ALTMODE
	CAIN	B,.CHALT
	AOJA	C,CCLTM2	;WE MUST BE DONE
	CAIN	B,"%"		;WAS IT OUR PSEUDO ALTMODE?
	MOVEI	B,.CHESC	;YES, MAKE IT A REAL ALTMODE
	IDPB	B,T		;STORE THIS CHAR IN OUTPUT BUFFER
	AOJA	C,CCLTM1	;YES, GET REST OF CHARACTERS
CCLTM2:	TXO	FF,F.TEMP	;SET TMPCOR FLAG
	JRST	CCLIL1		;RETURN TO MAIN FLOW
CCLTMP:	>
	HLLZ	B,TMPTEC	;GET SIXBIT JOB #
	HRRI	B,(SIXBIT /EDT/);REST OF NAME
	MOVEM	B,XFILNM+.RBNAM
	MOVSI	B,(SIXBIT /TMP/)
	MOVEM	B,XFILNM+.RBEXT
	SETZM	XFILNM+.RBSIZ	;USE DEFAULT PATH, PREVENT ADR. CHK.
	MOVE	T,.JBFF		;USE BUFFER SPACE BRIEFLY
	INIT	CCLCHN,.IOASC
	SIXBIT	/DSK/		;TO READ THE FILE
	EXP	CCLB		;INPUT BUFFER
	JRST	TECO		;IF NO DSK, SAY "*"
	INBUF	CCLCHN,1	;DONT ADR CHECK
	LOOKUP	CCLCHN,XFILNM+.RBNAM	;OPEN THE FILE
	JRST	TECO		;IT WASNT THERE?
	INPUT	CCLCHN,0
	MOVEM	T,.JBFF		;GIVE BACK SPACE
	IBP	CCLB+.BFPTR	;SKIP THE LINED S
CCLIL0:	MOVE	T,TTYPT2	;OUTPUT CHARS
	MOVEI	C,2		;INIT CHAR CTR
CCLIL:
IFN	FTRESCAN,<
	SKIPE	CCLSW		; CCL ENTRY ???
	 JRST	CCLIL4		;NO, CONTINUE NORMALLY
	INCHRW	B		; NO , GET CHAR FROM INVOKING COMMAND
	JRST	CCLIL2		; AND THEN CONTINUE NORMALLY
CCLIL4:	>

	ILDB	B,CCLB+.BFPTR	;INPUT THE FILE NAME & EXT

IFN	FTRESCAN,<
CCLIL2:	SKIPE	CCLSW		; CCL IN PROGRESS OR RESCAN ??
	JRST	CCLIL3		; YES, DO  CCL
	CAIE	B,.CHESC	; ALT MODE IN RESCAN ??
	JRST	CCLIL3		; NO, CONTINUE
	AOJ	C,		; ADD ONE TO CHARACTER COUNT
	JRST	CCLIL1		; YES, FINISH COMMAND
	>
CCLIL3:	CAIN	B,.CHCRT	; WAS BREAK A <CR> ?
	 JRST	CCLIL		; YES: IGNORE IT
	CAIE	B,.CHLFD	;CHECK FOR LEGAL COMMAND CHAR
	CAIN	B,.CHALT	;EVERYTHING BUT LF AND OLD ALT
	AOJA	C,CCLIL1	;IT'S NOT
	CAIN	B,"%"		;IS IT OUR PSEUDO ALTMODE?
	MOVEI	B,.CHESC	;YES
	IDPB	B,T		;PUT IT IN THE DDT IN BUFFER
	AOJA	C,CCLIL		;MORE CHARS
CCLIL1:	MOVEI	A,"W"		;PREPARE FOR EW COMMAND
	CAILE	B,.CHCRT	;WAS BREAK A CRLF?
	JRST	CCLDUN		;NO. ALTMODE ASSUMED
	TXO	FF,F.CCL	;REQUEST Y AFTER EB
	MOVEI	A,"B"		;NOW PREPARE FOR EB
CCLDUN:	MOVEI	B,.CHESC
	IDPB	B,T		;TERMINATING TWO ALT'S
	IDPB	B,T		;LAST ALT
	ADDI	C,2		;COUNT 2ND ALT & ADD 1 TO FOOL TYI0
	MOVEI	B,"E"		;NOW FILL IN THE EB OR EW
	MOVE	T,TTYPT		;AT THE BEGINNING OF STRING
	MOVEM	T,TIB+.BFPTR	;ALSO INITIALIZE TO READ THIS
	IDPB	B,T		;STORE "E"
	IDPB	A,T		;AND EITHER W OR B
	MOVEM	C,TIB+.BFCNT	;SET BUFR CTR
IFN TEMP,<
IFE	FTRESCAN,<
	TXZE	FF,F.TEMP	;TMPCOR UUO IN PROGRESS?
	>
IFN	FTRESCAN,<
	TXZN	FF,F.TEMP	; TMPCOR UUO IN PROGRESS OR
	SKIPN	CCLSW		; ARE WE HERE FOR CCL ENTRY ??
	>
	JRST	CCLDU2>		;YES, DONT CLOSE DSK
	CLOSE	CCLCHN,0	;NOW FLUSH FILE
	SETZM	XFILNM+.RBNAM	;BY RENAME TO 0
	RENAME	CCLCHN,XFILNM+.RBNAM	;GO.
	  JFCL			;NOGO?
CCLDU2:	RELEAS	CCLCHN,
	POPJ	P,
	>
SUBTTL	RETURN NON-NULL TTY CHARACTER IN CH.

;CALL	PUSHJ PDP,TYI
;	RETURN

TYI:	TXZE	FF,F.TYOF	;NEED A TYO?
	OUTPUT	TTY,0		;YES. DO SO.
TYI0:	SOSG	TIB+.BFCNT	;CHARS IN NORMAL MODE?
	JRST	TYI1		;NONE LEFT
TYI2:	ILDB	CH,TIB+.BFPTR	;YES. GET ONE
	JUMPE	CH,TYI0		;FLUSH NULLS
TYI3:	TXZ	FF,F.DDTM	;CLR TTCALL REQUEST FLAG
IFN RUBSW,<
	SETO	A,		;AIM AT THIS TTY
	GETLCH	A		;GETSTS
	TXNN	A,GL.LCP	;SUPPRESS ECHO?
	>
	CAIE	CH,.CHBEL	;BELL?
	JRST	ECNTRL		;NO, BUT WATCH OUT FOR OLD ALTMODES
	TXO	F2,S.SLOG	;DON'T PUT THE ^G IN THE LOG FILE
	JSP	A,CONMES	;ECHO AN "^G" TOO
	ASCIZ	/^G/
	TXZ	F2,S.SLOG
	MOVEI	CH,.CHBEL	;GET BACK BELL
	POPJ	P,

TYI1:	TXNE	FF,F.DDTM	;SHOULD TYI BE TTCALL?
	JRST	TYIDDT		;YES
	INPUT	TTY,0		;NO. ORDINARY.
	STATO	TTY,IO.EOF	;END OF FILE?
	JRST	TYI2
	PUSHJ	P,TTOPEN	;CLEAR EOF THE HARD WAY
	JRST	TYI0		;^Z WAS SEEN ALREADY. GET ANOTHER CH

;ECHO ^<CHAR> FOR CONTROL CHARS
ECNTRL:	CAIL	CH," "		;CONTROL CHAR?
	JRST	ALTLIN		;NO, CHECK FOR OLD ALTMODE
	CAIN	CH,"H"-100	;CHECK FOR SPECIAL CASES
	POPJ	P,
	CAIN	CH,"I"-100
	POPJ	P,
	CAIN	CH,"M"-100
	POPJ	P,
	CAIN	CH,"J"-100
	POPJ	P,
	CAIN	CH,"L"-100
	POPJ	P,
	CAIN	CH,"U"-100
	POPJ	P,
	CAIN	CH,33
	POPJ	P,
	PUSH	P,CH
	MOVEI	CH,"^"		;TYPE AN UPARROW
	PUSHJ	P,TYOM
	MOVE	CH,(P)
	MOVEI	CH,100(CH)	;CONVERT CHAR TO UPPERCASE
	PUSHJ	P,TYOM		;AND TYPE IT OUT
	POP	P,CH		;RESTORE OLD CHAR
	POPJ	P,

;CONVERT 175 & 176 TO ALTMODE (033) UNLESS TTY LC IS ON

ALTLIN:	CAIL	CH,.CHALT	;OLD ALTMODE?
	CAILE	CH,.CHAL2
	POPJ	P,		;NO
	TXNN	F2,S.NALT	;TEST TTY NO ALT BIT
ALTX:	MOVEI	CH,.CHESC	;NOT ON, SO CONVERT TO 033
	POPJ	P,

;CONVERT 175 & 176 TO ALTMODE (033) IF EO = 1

ALTEO:	CAIE	CH,.CHALT	;OLD ALTMODE?
	CAIN	CH,.CHAL2
	CHKEO	EO21,ALTX	;RUNNING OLD MACRO? IF SO, CONVERT
	POPJ	P,		;NO, 175=RIGHT BRACE, 176=TILDE
TYIDDT:	TXZE	FF,F.TYOF	;CHARACTERS WAITING FOR OUTPUT?
	OUTPUT	TTY,0		;YES, FORCE THEM OUT
	INCHRW	CH		;WAIT FOR A SINGLE CHARACTER
	JRST	TYI3

;USE E INSTEAD OF T IN THIS ROUTINE, SINCE IT MAY BE CALLED
;	AFTER A REENTER, WHILE T IS BEING USED TO MOVE CHARACTERS
;	(FAST AC CODE).  E HAS BEEN SAVED AT REE:.
TTOPEN:	MOVEI	E,TTYBFS
	EXCH	E,.JBFF		;SET .JBFF AND SAVE IT
	OPEN	TTY,TTYBLK	; OPEN THE TTY:
	 JRST	.-1		; I REALLY WANT THAT TTY:
	INBUF	TTY,1
	OUTBUF	TTY,1		;KEEP IT SMALL
	MOVEM	E,.JBFF		;RESTORE .JBFF
IFN CCL,<
	SETZM	TYIPT		;SIGNAL CCL BUFFER EMPTY
	>
	POPJ	P,

TTYBLK:	IO.FCS!.IOASC		; ASCII MODE, FULL CHARACTER SET
	SIXBIT	\TTY\		; WANT THE TTY:
	XWD	TOB,TIB		; ADDRESS OF BUFFER HEADERS
SUBTTL	TYPE A CHARACTER.

;FOR TYPING TEXT:		FOR TYPING MESSAGES:
;	MOVE CH,CHARACTER		MOVE CH,CHARACTER
;	PUSHJ P,TYO			PUSHJ P,TYOM
;	RETURN				RETURN
;UNLESS F.TCTL IS TRUE, CONTROL CHARACTERS ARE TYPED WITH "^"
;FOLLOWED BY THE CORRESPONDING PRINTING CHARACTER.

TYOS:	TXOA	F2,S.TXTC	;TYPE <CR>, ETC INSTEAD OF PRINTER CONTROLS
TYOM:	TXZ	F2,S.TXTC	;CLR SPECIAL TYPEOUT FLAG
	TXOA	F2,S.NCFL	;SET NO-CASE-FLAGGING FLAG
TYO:	TXZ	F2,S.NCFL+S.TXTC	;CLR NO-CASE-FLAGGING FLAG & SPECIAL FLAG
	PUSH	P,CH		;SAVE CHAR IN CASE ^ OR ' NEEDED
	TXNE	F2,S.RTYP	;^G-SPACE IN PROGRESS?
	JRST	.+3		;YES, ALWAYS USE ^ FOR CONTROL CHARS
	TXNE	FF,F.TCTL	;IS ET IN EFFECT?
	JRST	TYOB		;YES, TYPE CONTROL CHARS LITERALLY
	PUSHJ	P,ALTEO		;CONVERT OLD ALTMODES IF EO=1
IFN CRT,<SKIPN	CRTTYP		;IF CRT IN USE,
	CAIL	CH,.CHTAB
	CAIGE	CH,.CHCNH	;THEN TYPE ^H LITERALLY
	>
IFE CRT,<CAIGE	CH,.CHTAB	;^H TYPED WITH ARROW
	>
	JRST	TYO1		;BELOW TAB
	TXZN	F2,S.TXTC	;WANT <CR>, ETC INSTEAD OF PRINTER CONTROLS?
	JRST	TYOJ		;NO
	CAIG	CH,.CHCRT	;IS IT A PRINTER CONTROL?
	JRST	TYOH		;YES
	CAIE	CH,.CHESC	;OR AN ALTMODE?
	JRST	TYOG		;NO, DO NORMAL THING
	MOVEI	CH,16		;ADJUST INDEX FOR ALTMODE
TYOH:	MOVEI	A,5		;5 CHAR. CTR
	MOVE	AA,[POINT 7,TSPTAB-10]	;& PTR TO RIGHT COMBINATION
	ADDI	AA,(CH)
TYOI:	ILDB	CH,AA		;TYPE <CR> OR WHATEVER
	SOJLE	A,TYOB		;LAST CHAR GOES OUT VIA TYOB (TO POP CH)
	PUSHJ	P,TYOA
	JRST	TYOI
TYOJ:	CAIG	CH,.CHCRT	;NO, TAB, LF, VT, FF, OR CR?
	JRST	TYOB		;YES. TYPE IT AND RETURN
	CAIN	CH,.CHESC
	MOVEI	CH,"$"		;YES TYPE DOLLAR SIGN
TYOG:	CAIGE	CH," "		;NO. ANY OTHER CONTROL CHARACTER?
	JRST	TYO1		;YES.
TYOC:	TXNE	F2,S.LCTT+S.NCFL	;TTY LC ON? OR TYPING A MESSAGE?
	JRST	TYOB		;YES, NO CASE FLAGGING
	MOVE	A,TYCASF	;WHAT SHOULD BE FLAGGED?
	JUMPL	A,TYOB		;NOTHING
	JUMPG	A,TYOD		;UPPER CASE RANGE
	CAIGE	CH,"A"+" "-1	;LOWER CASE. IS THIS LC?
	JRST	TYOB		;NO, SO DON'T FLAG IT
TYOE:	MOVEI	CH,"'"		;YES, FLAG IT WITH '
	PUSHJ	P,TYOA
	MOVE	CH,(P)		;GET BACK THE CHARACTER
	TXZ	CH,40		;MAKE IT UPPER CASE
TYOB:	PUSHJ	P,TYOA		;TYPE CH.
	POP	P,CH		;RESTORE CH
	CAIN	CH,.CHBEL	;IF BELL AND ET IS OFF, WE MUST
	TXNE	FF,F.TCTL	;FALL INTO TYOA TO GET A DING
	POPJ	P,		;RETURN
TYOA:	TXNE	F2,S.OLOG!S.LOUT	;PUT CHARACTER IN LOG FILE
	PUSHJ	P,LOGOUT	;RIGHT!
IFN	FTNCM0,<		; CONDITIONAL FOR <LF> COMMAND
	TXNE	FF,F.LFCM	; IF NO <LF> PRINT TO TTY:
	 POPJ	P,		; IF <LF> COMMAND, NO OUTPUT TO TTY:
			>
	TXO	FF,F.TYOF	;MARK WILL NEED TO OUTPUT
	SOSG	TOB+.BFCNT	;OUTPUT SPACE AVAIL?
	OUTPUT	TTY,0		;NO. OUTPUT.
	IDPB	CH,TOB+.BFPTR
	CAILE	CH,.CHFFD	;FORCE OUTPUT ON LF,FF ETC
	POPJ	P,		;NO
	OUTPUT	TTY,0
	TXZ	FF,F.TYOF	;NO LONGER NEED TO OUTPUT
	POPJ	P,

TYO1:	PUSH	P,CH		;TYPE CONTROL CHARACTER IN FORM "^CH"
	MOVEI	CH, "^"
	PUSHJ	P,TYOA		;TYPE ^
	POP	P,CH
	ADDI	CH,100		;CONVERT TO PRINTING CHARACTER
	JRST	TYOB		;AND TYPE IT.

TYOD:	CAIL	CH,100		;IS THIS UPPER CASE?
	CAILE	CH,137
	JRST	TYOB		;NO
	JRST	TYOE		;YES, FLAG IT WITH '


;PRINT THESE INSTEAD OF PRINTER CONTROLS IF S.TXTC FLAG IS ON

TSPTAB:	ASCII	/^H/
	ASCII	/<TAB>/
	ASCII	/<LF>/
	ASCII	/<VT>/
	ASCII	/<FF>/
	ASCII	/<CR>/
	ASCII	/<ALT>/
SUBTTL	MESSAGE TYPE-OUT & NUMBER TYPE-OUT

;CALL	JSP A,CONMES
;	ASCIZ /MESSAGE/
;	RETURN

CONMES:	HRLI	A,(POINT 7,,)	;A=POINT 7,MESSAGE-ADDR
	ILDB	CH,A		;GET MSG CHAR
	JUMPE	CH,1(A)		;RETURN WHEN 0 FOUND
	PUSHJ	P,TYOM		;TYPE WITH NO CASE FLAGGING
	JRST	.-3

;ROUTINE TO OUTPUT DECIMAL (OCTAL IF S.OCTL IS ON) INTEGER
;CALL	MOVE B,INTEGER
;	MOVEI A,ADDRESS OF OUTPUT ROUTINE
;	PUSHJ P,DPT
;	RETURN

DPT:	MOVEM	A,LISTF5
	JUMPGE	B,DPT1		;NUMBER > 0?
	MOVEI	CH,"-"		;NO. OUTPUT -
	PUSHJ	P,@LISTF5
	MOVMS	B		;B:=ABSOLUTE VALUE OF B
DPT1:	MOVEI	A,12		;RADIX 10
	TXNE	F2,S.OCTL	;OCTAL RADIX?
	MOVEI	A,10		;YES, CHANGE TO RADIX 8
	IDIVI	B,(A)		;E:=DIGIT
	HRLM	E,(P)		;PUT DIGIT ON LEFT HALF OF TOP OF PUSH DOWN LIST
	JUMPE	B,.+2		;DONE?
	PUSHJ	P,.-3		;NO. PUSH THIS DIGIT AND PRINT RETURN ADDRESS.
	HLRZ	CH,(P)		;YES. CH:=DIGIT
	ADDI	CH,"0"		;CONVERT IT TO ASCII.
	JRST	@LISTF5		;PRINT IT

;ROUTINE TO TYPE CARRIAGE RETURN LINE FEED
;CALL	PUSHJ P,CRR
;	RETURN
CRR:	JSP	A,CONMES	;OUTPUT CRLF
	ASCIZ	/
/
	POPJ	P,

OUTMES:	HRLI	A,(POINT 7,,)	;THIS ROUTINE WILL OUTPUT A STRING LITERALLY
	ILDB	CH,A
	JUMPE	CH,CPOPJ
	PUSHJ	P,TYOA
	TLNE	A,700000	;NO MORE THAN 5 CHARACTERS, THOUGH
	JRST	OUTMES+1
	POPJ	P,
SUBTTL	RETURN NEXT COMMAND CHAR AT CURRENT LEVEL

;CALL:	PUSHJ	P,SKRCH
;	ERROR RETURN IF NO MORE CHARS AT THIS LEVEL
;	NORMAL RETURN WITH CHAR IN CH

SKRCH:	SKIPG	COMCNT		;ANY CHARS LEFT?
	POPJ	P,		;NO, TAKE ERROR RETURN
	PUSHJ	P,RCH		;YES, GET NEXT
CPOPJ1:	AOS	(P)		;SKIP RETURN
	POPJ	P,

;ROUTINE TO RETURN NEXT CHARACTER FROM COMMAND BUFFER.
;CALL	PUSHJ P,RCH
;	RETURN ALWAYS WITH CHARACTER IN CH

RCH:	SOSGE	COMCNT		;DECREMENT COMMAND BUFFER CHARACTER COUNT
				;IS COMMAND BUFFER EMPTY?
	JRST	RCH2		;YES. POP UP TO HIGHER MACRO LEVEL.
	ILDB	CH,CPTR		;NO. GET COMMAND CHARACTER IN CH
	PUSHJ	P,ALTEO		;CONVERT OLD ALTMODES IF EO = 1
	HRRM	CH,EATCH	;IN CASE OF FAILURE DURING COLON ANYTHING
	TXNE	FF,F.TRAC	;IN TRACE MODE?
	TXNE	F2,S.NTRC	;TRACE ENABLED?
	POPJ	P,		;NO, RETURN
	JRST	TYO		;YES, TYPE THE COMMAND

RCH2:	POP	P,CH		;SAVE RETURN FOR POPJ IN CH
	POP	P,COMCNT	;GET RID OF FLAG
	SOSGE	EQM		;DECREMENT THE MACRO COUNT
	SETZM	EQM		;NEVER ALLOW IT TO GO NEG OR PEOPLE WILL SCREW UP
	SOSGE	COMCNT		;IF ANG BRAK ON PDL, ITS A INCOMPLETE MACRO
	ERROR	E.IAB
	POP	P,COMCNT	;GET COUNT FROM NEXT MACRO LEVEL
	POP	P,CPTR		;CURRENT POINTER TOO
	POP	P,COMAX		;NUMBER OF COMMANDS
	PUSH	P,CH		;GET RETURN BACK ON PDL.
	JRST	RCH		;TRY AGAIN.

;GET NEXT CHAR FROM CURRENT COMMAND LEVEL WHERE A CHAR IS
;KNOWN TO BE THERE, AND NO TRACING IS WANTED

GCH:	SOS	COMCNT		;REDUCE CHAR COUNT
	ILDB	CH,CPTR		;GET CHAR.
	JRST	ALTEO		;CONVERT OLD ALTMODES AND RETURN
SUBTTL	SCAN COMMAND STRING FOR CHARACTER IN TT

;IGNORING PAIRS STARTING WITH CHAR. IN TT1 AND ENDING WITH (TT)
;ASSUMED THAT CPTR IS SET
;NON-SKIP RETURN IF (TT) CAN'T BE FOUND
;SKIP RETURN IF FOUND
;CPTR LEFT SET FOR NEXT CHAR. IN COMMAND STRING

SKAN:	TXO	F2,S.NTRC	;INHIBIT TRACE ACTION WHILE SKANNING
	MOVEI	C,0		;CTR FOR <> AND "...' PAIRS
SKAN0:	TXZ	F2,S.SKMQ+S.SKMR+S.SFSN	;CLR SKIM FLAGS
	PUSHJ	P,SKRCH2	;GET COMMAND CHAR.
SKAN01:	CAIN	CH,(TT1)	;SECONDARY CHARACTER?
	AOJA	C,SKAN1		;YES, COUNT IT
	CAIN	CH,(TT)		;PRIMARY CHAR?
	JRST	SKAN10		;YES!
SKAN1:	CHKEO	EO21,SKAN0	;OLD STYLE SKAN IF EO = 1
	MOVEI	T,SKNTAB	;NO, WATCH OUT FOR TEXT STRINGS
SKAN00:	PUSHJ	P,DISPAT
	JRST	SKAN0		;NOT A TEXT-ARG COMMAND, IGNORE IT
SKAN2:	PUSHJ	P,SKRCH2	;GET CHAR AFTER "^"
	CAIE	CH,"A"+" "	;COULD BE LOWER CASE
	CAIN	CH,"A"
	JRST	SKAN7		;^A COMMAND
	CAIN	CH,"^"
	JRST	SKAN11		;^^ COMMAND
	JRST	SKAN0		;ORDINARY CTRL-COMMAND, FORGET IT
SKAN3:	PUSHJ	P,SKRCH2
	MOVEI	T,SK3TAB	;WHICH E COMMAND?
	JRST	SKAN00
SKAN4:	PUSHJ	P,SKRCH2	;WHAT FOLLOWS @?
	MOVEI	T,SK4TAB
	PUSHJ	P,DISPAT
	JRST	SKAN4		;MUST BE 1 OF THESE 4
SKAN09:	TXZ	F2,S.SFSN	;FOR FD CASE
	JRST	SKAN12
SKAN9:	PUSHJ	P,SKIM		;IGNORE TO $
	JRST	SKAN0
SKAN7:	MOVEI	T,1		;IGNORE TO ^A
	JRST	SKAN5
SKAN8:	MOVEI	T,"!"		;IGNORE TO !
SKAN5:	PUSHJ	P,SKIM1		;IGNORE TO CHAR IN T
	JRST	SKAN0
SKAN66:	TXZ	F2,S.SFSN	;FOR @FD CASE
SKAN6:	PUSHJ	P,SKRCH2	;GET SEARCH DELIMITER
	SKIPA	T,CH		;IGNORE TO NEXT OCCURRENCE
SKAN12:	MOVEI	T,.CHESC	;DELIMITER IS ALTMODE
	PUSHJ	P,SKIMRQ	;SKIP TO DELIMITER & WATCH OUT FOR ^Q,^R
	JRST	SKAN0
SKAN13:	PUSHJ	P,SKRCH2	;GET INSERT DELIMITER
	SKIPA	T,CH		;IGNORE TO NEXT OCCURRENCE
skan19:	skipe	eqm		;Ignore tabs inside of macros
	jrst	skan0
SKAN14:	MOVEI	T,.CHESC	;DELIMITER IS ALTMODE
	PUSHJ	P,SKIM.R	;SKIP TO DELIMITER & WATCH OUT FOR ^R
	JRST	SKAN0
SKAN11:	PUSHJ	P,SKRCH2	;IGNORE NEXT CHAR.
	JRST	SKAN0
SKAN16:	MOVEI	T,SK5TAB	;TABLE FOR @F
	JRST	SKAN17
SKAN15:	MOVEI	T,SK1TAB	;TABLE FOR F COMMANDS
SKAN17:	TXO	F2,S.SFSN	;SIGNAL FS OR FN IN PROGRESS
	PUSHJ	P,SKRCH2	;GET CHAR AFTER F
	JRST	SKAN00
SKAN18:	PUSHJ	P,SKRCH2	;CHECK FOR POSSIBLE "PW"
	CAIE	CH,"W"
	CAIN	CH,"W"+" "	
	JRST	SKAN0		;IT IS...FORGET IT
	JRST	SKAN01		;IT'S NOT...WE MUST CHECK THIS CHAR FURTHER
SKAN10:	SOJGE	C,SKAN0		;IF MATCH JUST ENDS A PAIR, LOOP BACK
	TXZ	F2,S.NTRC	;ENABLE TRACING
	JRST	CPOPJ1		;OTHERWISE, WE HAVE WHAT WE WANT
;SKIM OVER TEXT
;ENTER AT SKIM TO SKIP TO NEXT ALTMODE, GIVING ^R & ^Q NO SPECIAL TREATMENT
;ENTER AT SKIM1 TO SKIP OVER ARBITRARY CHAR IN T, GIVING ^R & ^Q NO SPECIAL TREATMENT
;ENTER AT SKIM.R TO SKIP TO ARBITRARY CHAR IN T, UNLESS IT IS AFTER ^R
;ENTER AT SKIMRQ TO SKIP TO ARBITRARY CHAR IN T, UNLESS IT IS AFTER EITHER ^R OR ^Q

SKIMRQ:	TXO	F2,S.SKMQ	;CK FOR ^Q AND ^R
SKIM.R:	TXOA	F2,S.SKMR	;CK FOR ^R
SKIM:	MOVEI	T,.CHESC	;SKIP TO NEXT ALTMODE
SKIM1:	PUSHJ	P,SKRCH		;GET NEXT TEXT CHAR.
	JRST	APOPJ		;ERROR RETURN FROM SKAN ROUTINE
	CAIN	CH,(T)		;CHARACTER WE WANT?
	JRST	SKIM3		;YES
	CAIN	CH,.CHCNQ	;^Q?
	TXNN	F2,S.SKMQ	;YES, CK FLAG ON?
	JRST	.+2		;NO
	JRST	SKIM2		;YES
	CAIN	CH,.CHCNR	;^R?
	TXNN	F2,S.SKMR	;YES, CK FLAG ON?
	JRST	SKIM1		;NO, KEEP LOOKING
SKIM2:	PUSHJ	P,SKRCH		;GOBBLE UP NEXT CHARACTER
	JRST	APOPJ		;ERROR RETURN FROM SKAN
	JRST	SKIM1		;CONTINUE SKIMMING
SKIM3:	TXZE	F2,S.SFSN	;SKIMMING OVER FS OR FN?
	JRST	SKIM1		;YES, IGNORE 1ST DELIMITER
	POPJ	P,

;GET A SINGLE CHARACTER FROM COMMAND STRING
;TAKE ERROR RETURN FROM SKAN IF THERE ARE NO MORE

SKRCH2:	PUSHJ	P,SKRCH		;GET A COMMAND CHAR.
APOPJ:	POP	P,A		;ERROR RETURN FROM SKAN IF NO MORE CHARS.
	POPJ	P,
SUBTTL	SKAN ROUTINE DISPATCH TABLES

SKNTAB:	XWD	SKAN15,"F"
	XWD	SKAN14,"I"
	XWD	SKAN19,.CHTAB	;TAB
	XWD	SKAN12,"_"
	XWD	SKAN9,"O"
	XWD	SKAN8,"!"
	XWD	SKAN7,.CHCNA	;^A
	XWD	SKAN11,.CHCCF	;^^
	XWD	SKAN2,"^"
	XWD	SKAN3,"E"
	XWD	SKAN11,"U"
	XWD	SKAN11,"Q"
	XWD	SKAN11,"X"
	XWD	SKAN11,"G"
	XWD	SKAN11,"W"
	XWD	SKAN11,"M"
	XWD	SKAN11,"%"
	XWD	SKAN11,"["
	XWD	SKAN11,"]"
	XWD	SKAN4,"@"
	XWD	SKAN11,""""	;"
	XWD	SKAN12,"S"
	XWD	SKAN12,"N"
	XWD	SKAN18,"P"
	XWD	0,0
SK1TAB:	XWD	SKAN12,"S"	;S OR FS
	XWD	SKAN12,"N"	;N OR FN
	XWD	SKAN09,"D"
	XWD	0,0		;LIST TERMINATOR

SK3TAB:	XWD	SKAN9,"I"
	XWD	SKAN9,"P"
	XWD	SKAN9,"B"	;EB
	XWD	SKAN9,"R"	;ER
	XWD	SKAN9,"W"	;EW
	XWD	SKAN9,"Z"	;EZ
	XWD	SKAN9,"D"
	XWD	SKAN9,"L"
	XWD	SKAN9,"E"
	XWD	SKAN9,"N"
	XWD	SKAN9,"A"
	XWD	SKAN9,"V"
	XWD	0,0

SK4TAB:	XWD	SKAN16,"F"	;@F
	XWD	SKAN13,"I"	;@I
	XWD	SKAN6,"_"	;@_
	XWD	SKAN6,"S"	;@S 
	XWD	SKAN6,"N"	;@N
	XWD	0,0
SK5TAB:	XWD	SKAN6,"S"	;@FS
	XWD	SKAN6,"N"	;@FN
	XWD	SKAN66,"D"	;@FD
	XWD	0,0
SUBTTL	ACCEPT COMMAND STRING ROUTINE

CLIS1:	PUSHJ	P,CRR		;TYPE CRLF
CLIS:
IFN CCL,<
	SKIPN	CCLSW		;NEED CCL COMMAND?
IFE	FTRESCAN,<
	JRST	LIS0		;NO
	>
IFN	FTRESCAN,<
	JRST	CLIS2		; SEE IF USER TYPED "R TECO-FILESPEC"
	>
	PUSHJ	P,CCLIN		;GET THE CCL COMMAND TO TYI BUFFER
	JRST	LIS02		;AND DONT SAY STAR
	>


IFN	FTRESCAN,<

CLIS2:	RESCAN	1		; RESET INPUT POINTER
	JRST	CLIS2A		; SOMETHING THERE
	JRST	LIS0		; NOTHING THERE

CLIS2A:	INCHRW	CH		; YES, GET A CHAR
	PUSHJ	P,CKEOL		; IS IT A BREAK CHARACTER ??
	CAIN	CH,.CHESC	; ALTMODE ?
	JRST	LIS0		; YES - GO TYPE A "*"
	CAIE	CH,.CHBEL	; A BELL ??
	CAIN	CH,.CHCNZ	; AN EOF ?
	JRST	LIS0		; YES, GO TYPE  "*"
	CAIE	CH,"-"		; IS IT A DASH (WHAT WE WANT ) ??
	JRST	CLIS2A		; NO, GET ANOTHER CHAR
	PUSHJ	P,CCLIL0	; YES, GO CALL CCL ENTRY
	SETOM	CCLSW		; FAKE CCL ENTRY
	JRST	LIS02		; CODE TO PICK UP FILE NAME
	>

LIS0:	AOS	INI		;ALLOW ^G^G *I$ ON FIRST COMMAND
	PUSHJ	P,TTOPEN	;GET TELETYPE
	TXNE	FF,F.EMSG	;1ST CHARACTER IN ALREADY?
	JRST	LIS01		;YES
	MOVEI	CH,"*"
	TXZ	F2,S.LCTT	;CLR TTY LC BIT
	SETO	A,		;GETLCH ON THIS LINE
	GETLCH	A
	TXNE	A,GL.LCM	;TTY LC ON?
	TXO	F2,S.LCTT	;YES, SET TTY LC BIT
	TXNN	F2,S.LIN	;WANT OUTPUT?
	TXO	F2,S.SLOG	;SUPPRESS * IN LOG FILE
	TXZ	FF,F.CCL	;NOT THIS AGAIN
	HRRZ	TT1,A		;GET UNIVERSAL I/O INDEX
	 TXO	F2,S.NALT	;DON'T CONVERT
IFN CRT,<
	HRROI	A,27		;GET TERM WIDTH
	AUXCAL	A,A
	MOVEM	A,TTYWID	;STORE IT
	>
	PUSHJ	P,TYOM		;TYPE *
LIS01:	TXZ	F2,S.SLOG
	TXON	FF,F.EMSG	;UNLESS ONE ALREADY IN
	PUSHJ	P,TYI
IFN	FTNCM0,<		; CHECK FOR NEW COMMANDS <LF>, <^H>
	TXZ	FF,F.LFCM	; SAY "NO LF YET"
	CAIE	CH,.CHLFD	; IS IT A SPACE ?
	 JRST	LIS010		; NO, CONTINUE
	TXO	FF,F.LFCM	; FLAG THAT WE HAD A <LF>
	OUTCHR	[.CHCRT]	; OUTPUT THE <CR>
	MOVE	AA,CBUF		; BYTE POINTER TO BUFFER
	MOVEI	A,4		; NUMBER OF CHARACTERS
	MOVEI	CH,"L"		; PUT AN L INTO THE BUFFER
	IDPB	CH,AA		; PLACE IT
	MOVEI	CH,"T"		; NOW, A T
	IDPB	CH,AA		; PLACE IT
	MOVEI	CH,.CHESC	; AND AN ESCAPE
	IDPB	CH,AA		; PLACE THIS, TOO
	IDPB	CH,AA		; FINISH THE COMMAND (LT$$)
	MOVEM	A,COMCNT	; SAVE THE COUNT
	TXO	FF,F.ALT	; SET THIS
	JRST	LI7
LIS010:	CAIE	CH,.CHCNH	; 1ST CHAR A ^H ?
	 JRST	LIS011		; NO, CONTINUE
	MOVE	AA,CBUF		; BUFFER POINTER
	MOVEI	A,5		; 5 CHARS TO GO
	MOVEM	A,COMCNT	; STORE NUMBER
	TXO	FF,F.ALT	; SET THIS
	MOVEI	CH,"-"		; MAKE UP THE COMMAND "-LT$$"
	IDPB	CH,AA		; AND PUT IT INTO THE COMMAND BUFFER
	MOVEI	CH,"L"
	IDPB	CH,AA
	MOVEI	CH,"T"
	IDPB	CH,AA
	MOVEI	CH,.CHESC	; 2 ESCAPES TO END THE COMMAND
	IDPB	CH,AA
	IDPB	CH,AA
	JRST	LI7		; GO DO IT
LIS011:	>
	CAIE	CH,"*"		;1ST CHAR AN ASTERISK?
	JRST	LIS02		;NO, CONTINUE NORMALLY

;SAVE PREVIOUS COMMAND STRING IN NAMED Q-REGISTER

	SETZM	EATCH		;NO CHARACTER READ YET
	TXNE	F2,S.GOIN	;ANY CMD STRG SEEN YET? IF NOT, * IS ILLEGAL
	JRST	LIS03		;OK
$NCS:	PUSHJ	P,CRR		;MUST PUT CR/LF BEFORE ?NCS
	ERROR	E.NCS
LIS03:	MOVE	C,COMLEN	;LENGTH OF STRING
	TXNE	F2,S.NRAD	;IS IT AN FS...$$?
	ADDI	C,1		;YES, DON'T OMIT LAST ALTMODE
	ADDI	C,2		;OMIT LAST ALTMODE
	MOVEI	B,CMDBFR	;POSITION OF FIRST CHAR. IN BYTES
IFN BUGSW,<MOVE B,CMDBFR>
	IMULI	B,5
	PUSHJ	P,X3		;TRANSFER STRING TO Q-REG
	PUSHJ	P,TYI		;GET Q-REG NAME FOR * COMMAND
	MOVEM	CH,EATCH	;SAVE IN CASE ERROR
	MOVE	A,TIB+.BFPTR	;GET POINTER TO CURRENT CH
	MOVEM	A,CPTR		;STORE FOR POSSIBLE ERROR
	PUSHJ	P,QREGV2	;STORE 400000 IN QTAB
	MOVEM	B,QTAB-"0"(CH)
	TXZ	FF,F.EMSG	;NEXT INPUT CHAR NOT IN
LIS02:	SETZM	COMCNT		;COMCNT:=0
	TXZ	F2,S.NRAD	;CLEAR FLAG
	SETZM	SYMS
	MOVE	T,[XWD SYMS,SYMS+1]
	BLT	T,SYMEND-1
	MOVE	AA,CBUF
	MOVE	B,CBUFH

LI1:	TXZ	FF,F.ALT+F.BELL+F.XPLN+F.EM
LI2:	TXZ	F2,S.SLOG	;THINGS MAY AGAIN ENTER LOG FILE
	CAILE	B,(AA)		;COMMAND BUFFER EXCEEDED?
	JRST	LI3		;NO


;TO SEE IF TECO WILL NEED MORE CORE FOR COMMAND
;BUFFER EXPANSION. IF SO, GET IT

	MOVE	C,Z		;GET THE NUMBER OF CHARACTERS NOW
	ADDI	C,500		;WILL WE OVERFLOW IF THIS IS REQUESTED?
	CAMG	C,MEMSIZ	;WILL THIS OVERFLOW?
	JRST	.+5		;NO, FORGET THIS EVER HAPPENED
	PUSH	P,17		;WILL OVERFLOW, THEREFORE, SAVE AC#17
	MOVE	17,C		;THIS IS THE REQUEST FOR MEMORY
	PUSHJ	P,GRABKQ	;GET THE NECESSARY CORE
	POP	P,17		;RESTORE AC#17
SUBTTL	 EXPAND THE COMMAND BUFFER

	ADDI	B,100		;YES. EXPAND COMMAND BUFFER 100 WORDS.
	MOVE	C,Z
	IDIVI	C,5		;C:=DATA BUFFER END WORD ADDRESS.
	MOVE	D,QRBUF
	PUSH	P,F2		;KLUDGE TO PROTECT F2 UNTIL AC'S ARE REORDERED
	IDIVI	D,5		;D:=Q-REG BUFFER BASE WORD ADDRESS.
	POP	P,F2		;RESTORE FLAGS
	SUBM	C,D		;D:=NO. OF WORDS IN Q-REG BUFFER AND DATA BUFFER.
	MOVE	CH,(C)
	MOVEM	CH,100(C)	;MOVE Q-REG AND DATA BUFFERS UP 100 WORDS.
	SOS	C
	SOJGE	D,.-3
	MOVEI	C,500
	ADDM	C,BEG		;BEG:=C(BEG)+500
	ADDM	C,PT		;PT:=C(PT)+500
	ADDM	C,Z		;Z:=C(Z)+500
	ADDM	C,QRBUF		;QRBUF:=C(QRBUF)+500
	MOVE	D,Z
LI3:	MOVEM	B,CBUFH		;NO. RESET HIGH END OF COMMAND BUFFER.
	TXZN	FF,F.EMSG	;1ST CHAR IN ALREADY?
	PUSHJ	P,TYI		;GET A NON-NULL CHARACTER IN CH
IFN CRT,<SKIPE	CRTTYP		;IF TTY, THEN NO AUX CHARACTER
	 CAME	CH,BACRUB	;EXTRA DELETE CHARACTER OR
	>
	CAIN	CH,.CHDEL	;RUBOUT?
	JRST	DELCHR		;YES
LI3A:	TXZ	F2,S.SLOG
	AOS	A,COMCNT	;NO. INCREMENT COMMAND CHARACTER COUNT
	IDPB	CH,AA		;STORE CHARACTER IN COMMAND BUFFER.
LI4:	CAIE	CH,.CHESC	;ALT-MODE?
	JRST	LI5		;NO
	TXZN	F2,S.CTLR	;PREVIOUS CHAR. A ^R?
	JRST	LI7		;NO
	CHKEO	EO21,LI7	;IF EO=1, NEVERMIND ^R
LI9:	TXZ	FF,F.BELL	;ALTMODE CLEARS BELL FLAG
	JRST	LI2
LI7:	TXON	FF,F.ALT	;YES. SET ALT-MODE FLAG. WAS IT ON?
	JRST	LI9		;NO
	MOVEM	A,COMAX		;SET COMMAND CHARACTER ADDRESS UPPER BOUND
	MOVEM	A,COMLEN	;SAVE IN CASE OF * COMMAND NEXT
	MOVE	AA,CBUF		;INIT COMMAND BYTE PTR
	MOVE	B,AA		;IN CASE INTO LOG FILE
	MOVEM	AA,CPTR
	SKIPE	CCLSW		;READING CCL CMD?
	PUSHJ	P,TTOPEN	;YES, INIT TTY
	TXNE	F2,S.LIN	;PUT YOUR TYPIN IN LOG FILE?
	PUSHJ	P,BUFTYP
	TXNN	F2,S.LIN	;INPUT TO FILE TOO?
	TXO	F2,S.SLOG	;NO, SO DON'T PUT THIS CRLF THERE
	PUSHJ	P,CRR		;TYPE CRLF
IFN	FTNCM0,<		; <LF> COMMAND CONDITIONAL
	TXZ	FF,F.LFCM	;ZERO THIS ALWAYS
			>	; END OF IFN FTNCM0
	TXZ	F2,S.SLOG
	SETZM	CCLSW		;FINISHED WITH CCL READ
	SETOM	XCTING		;SET NO SCREW I FLAG
	JRST	CD		;RIGHT, SO DECODE COMMAND
BUFTYP:	MOVE	A,COMCNT	;HOW MANY CHARACTERS TO TRANSFER
	TXNE	F2,S.LOUT
	TXO	F2,S.OLOG
LOGLP:	ILDB	CH,B		;GET CHARACTER
	TXNN	F2,S.LOUT	;SENDING OUTPUT TOO?
	PUSHJ	P,LOGOUT	;NO, SEND VERBATIM
	TXNE	F2,S.LOUT
	PUSHJ	P,TYOM		;SEND TO LOG FILE
	SOJG	A,LOGLP		;EMPTY BUFFER
	TXO	F2,S.OLOG	;ONLY IN LOG FILE IF ANYWHERE
	TXNN	F2,S.LOUT
	PUSHJ	P,CRR
	TXZ	F2,S.OLOG	;SO TYPE OUT HAPPENS CORRECTLY
	POPJ	P,
SUBTTL	PROCESS SPECIAL COMMAND EDITING CHARACTERS

LI5:	CAIN	CH,.CHCNR	;^R?
	JRST	CNTRLR		;YES
	TXZ	F2,S.CTLR	;NO, CLR FLAG IN CASE PRECEDING CHAR WAS
	TXO	F2,S.SLOG	;DON'T TYPE ANYTHING INTO LOG FILE HERE
	CAIN	CH,.CHCNU	;^U?
	JRST	CNTRLU		;YES
	CAIN	CH,.CHBEL	;BELL?
	JRST	LI6		;YES
	TXZN	FF,F.BELL	;NO, PREVIOUS CHAR A BELL?
	JRST	LI1		;NO, GET NEXT CHARACTER
	CAIN	CH,"."		;IS THIS A PERIOD?
	JRST	[MOVE  D,COMCNT
		 SUBI  D,2
		 SETZM COMCNT
		 MOVE  AA,CBUF
		 ILDB  CH,AA
		 SKIPN D
		 PUSHJ P,BACKUP
		 PUSHJ P,RETYP3
		 JRST LI2]	;RETYPE ENTIRE COMMAND
IFN	FTNCM2,<		; CONDITIONAL FOR ^G_ COMMAND
	CAIE	CH,"_"		; WAS IT A BACK ARROW ??
	 JRST	LI51
	PUSHJ	P,BACKUP	; BACK UP 1 CHAR
	PUSHJ	P,BACKUP	; BACK UP BY TWO
	PUSHJ	P,CRR		; TYPE A CRLF
	PUSH	P,D		; SAVE THIS
	MOVE	D,SRHCTR	; GET # OF CHARS IN BUFFER
	PUSH	P,AA		; SAVE THE BYTE POINTER
	MOVEI	AA,SRHARG	; ADDRESS OF BUFFER
	HRLI	AA,(POINT 7,,)	; MAKE IT A POINTER
LI50:	ILDB	CH,AA		; GET A CHARACTER
	PUSH	P,AA		; SAVE THIS
	PUSHJ	P,TYOS		; TYPE IT OUT
	POP	P,AA		; GET IT BACK
	SOJG	D,LI50		; TYPE TILL DONE
	PUSHJ	P,CRR		; OUTPUT A CRLF
	POP	P,AA		; RESTORE THE BYTE POINTER
	POP	P,D		; RETRIEVE THIS, TOO.
	JRST	LI2		; THEN EXIT
LI51:		>			; END OF IFN FTNCM2
	CAIE	CH," "		;YES, IS THIS A SPACE?
	JRST	LI1		;NO
	PUSHJ	P,RETYPE	;YES, GO DO A RETYPE
	JRST	LI2


RETYPE:	PUSHJ	P,BACKUP	;BACK OFF ^G<SPACE>
	SOS	D,COMCNT	;MARK CURRENT POSITION
	PUSHJ	P,BACKLN	;BACK UP TO BEG OF LINE
	JRST	RETYP3		;HIT BEG OF COMMAND STRING
RETYP1:	TXO	F2,S.RTYP	;FLAG ^G<SPACE> IN PROGRESS
RETY1A:	SKIPL	COMCNT		;SEE IF ANY COMMANDS
	PUSHJ	P,TYOM		;TYPE A CHAR OF COMMAND LINE
RETYP4:	AOS	C,COMCNT	;ADVANCE COMMAND CTR
	CAIL	C,(D)		;BACK IN PLACE?
	JRST	RETYP2		;YES
	ILDB	CH,AA		;NO, GET NEXT CHAR
	JRST	RETY1A

RETYP2:	CAIN	CH,.CHESC	;LOOKING AT AN ALTMODE?
	TXO	FF,F.ALT	;YES, BETTER SET FLAG
	TXZ	F2,S.RTYP	;END OF ^G<SPACE>
	POPJ	P,		;RETURN

RETYP3:	PUSH	P,CH		;SAVE 1ST CHAR
	PUSHJ	P,CRR		;TYPE CR-LF BEFORE COMMAND LINE
	MOVEI	CH,"*"		;RETYPE THE *
	PUSHJ	P,TYOM
	POP	P,CH		;RETRIEVE 1ST CHARACTER
	JUMPE	CH,RETYP4	;DON'T PRINT ^@ IF NULL COMMAND STRING
	JRST	RETYP1

LI6:	TXOE	FF,F.BELL	;YES. SET BELL FLAG. TWO SUCCESSIVE BELLS?
	SOJA	A,LI8		;YES, REJECT COMMAND
	TXO	FF,F.DDTM	;GET ANOTHER CHAR WITH TTCALL 0
	JRST	LI2

LI8:	MOVEM	A,COMLEN
	PUSHJ	P,CRR		;YES. TYPE A CRLF
	TXO	F2,S.GOIN!S.ASTR;SO YOU CAN DO *I AFTER ^G^G
	JRST	GO		;AND CLEAR COMMAND BUFFER.
SUBTTL	BACK UP BYTE POINTER IN AA, LOAD APPROPRIATE CHARACTER IN CH,

;AND ADJUST COMCNT

BACKUP:
IFE	FTKL10,<
	ADD	AA,[7B5]	;BACK UP CHAR PTR
	JUMPG	AA,.+2		;OK NOW?
	SUB	AA,[430000,,1]	;NO NEEDS FURTHER FIXING
	>
IFN	FTKL10,<
	PUSH	P,AA
	MOVNI	AA,1
	ADJBP	AA,(P)
	ADJSP	P,-1
	>
	LDB	CH,AA		;LOAD CHAR
	SOS	C,COMCNT	;DECREMENT COMMAND COUNT
	POPJ	P,

;BACKUP TO BEGINNING OF CURRENT LINE
;CALL:	PUSHJ	P,BACKLN
;	RETURN IF BACKUP WENT TO BEGINNING OF COMMAND STRING
;	RETURN IF CR-EOL COMBINATION FOUND

BACKLN:	PUSHJ	P,BACKUP	;BACK UP ONE CHAR
	JUMPLE	C,CPOPJ		;RETURN IF NOTHING LEFT
BACKL1:	PUSHJ	P,CKEOL		;IS THIS AN EOL CHAR?
	JRST	BACKLN		;NO, KEEP BACKING UP
	PUSHJ	P,BACKUP	;YES, BACK UP ONE MORE
	CAIE	CH,.CHCRT	;IS THIS A CR?
	JRST	BACKL1		;NO, MAYBE ANOTHER EOL?
	JRST	CPOPJ1		;YES, TAKE SKIP RETURN

;PROCESS CONTROL-U

CNTRLU:	PUSHJ	P,BACKLN	;BACK UP TO BEG OF LINE
	JUMPLE	C,CTLU1		;IF NOTHING LEFT, RETYPE *
	AOS	COMCNT		;KEEP CRLF
	IBP	AA
CTLU1:
IFN CRT,<SKIPE	CRTTYP		;SPECIAL TERMINAL?
	JRST	[MOVEI A,CTUSEQ	;YES, GET SPECIAL SEQUENCE
		 PUSHJ P,OUTMES	;OUTPUT IT
		 JRST .+2]
	>
	PUSHJ	P,CRR		;OUTPUT A REGULAR CRLF
	JUMPLE	C,CLIS		;IF NOTHING LEFT, START FROM SCRATCH
	JRST	LI1		;CONTINUE TYPE-IN

;CONTROL-R IN COMMAND MODE PREVENTS AN ALTMODE AFTER IT
;FROM BEING A TERMINATOR

CNTRLR:	TXZN	F2,S.CTLR	;^R ON ALREADY?
	TXO	F2,S.CTLR	;NO, SET FLAG
	JRST	LI1
SUBTTL RUBOUT PROCESSOR


IFE CRT,<
DELCHR:     >
RUBOUT:	TXO	F2,S.SLOG
	SKIPG	COMCNT		;ANYTHING TYPED IN?
	JRST	CLIS1		;NO, RETYPE *
IFN RUBSW,<
	SETO	A,		;GETLCH ON THIS TTY
	GETLCH	A		;SET TO SUPPRESS ECHOING
	TLO	A,4
	SETLCH	A
	PUSHJ	P,SPLAT		;ACT LIKE THE MONITOR
	JRST	RUB4
RUB1:	SKIPGE	COMCNT		;PAST BEGINNING OF COMMAND STRING YET?
	JRST	RUB3		;YES
	PUSHJ	P,TYIDDT	;GET ONE CHARACTER
	CAIE	CH,.CHDEL	;RUBOUT?
	JRST	RUB2		;NO
RUB4:	>
	LDB	CH,AA		;RELOAD THE CHAR.
	SKIPE	COMCNT		;UNLESS AT BEGINNING OF COMMAND STRING,
	PUSHJ	P,TYOM		;ECHO THE DELETED CHAR.
	PUSHJ	P,BACKUP	;BACK OVER THE CHAR.
IFN	RUBSW,<JUMPLE	C,RUB1>
IFE	RUBSW,<JUMPLE	C,LI1>
	CAIN	CH,"R"-100	;IF PREVIOUS CHARACTER WAS ^R
	TXO	F2,S.CTLR	;RESET FLAG
IFE RUBSW,<JRST LI1>		;RESUME TYPE-IN
IFN RUBSW,<
	JRST	RUB1		;TRY NEXT INPUT CHAR.
RUB2:	PUSH	P,CH		;SAVE THIS GOOD GUY
	PUSHJ	P,SPLAT		;TYPE THE SECOND \
	POP	P,CH		;GET THAT CHAR. BACK
	CAIE	CH,.CHCNU	;CTRL-U?
	PUSHJ	P,TYOM		;NO, ECHO IT
	PUSHJ	P,TTCREE	;RESET TTCALL FOR ECHOING
	JRST	LI3A		;PROCESS THIS CHAR.
RUB3:	PUSHJ	P,SPLAT		;SECOND \
	PUSHJ	P,TTCREE	;RESET TTCALL MODE TO NORMAL
	JRST	CLIS1		;START A NEW COMMAND STRING
	>

;TYPE BACKSLASH

IFN RUBSW,<
SPLAT:	MOVEI	CH,"\"
	JRST	TYOM
	>

;RESET TTCALL FOR ECHOING

IFN RUBSW,<
TTCREE:	SETO	A,		;GETLCH ON THIS TTY
	GETLCH	A
	TLZ	A,4	;TURN OFF NO ECHO BIT
	SETLCH	A
	POPJ	P,
	>
SUBTTL VIDEO RUBOUT PROCESSOR
IFN CRT,<

DELCHR:	MOVE	A,CRTTYP	;GET CRT FLAGS
	CAIN	CH,.CHDEL	;IF ITS A DELETE,
	TRNN	A,.CRUB.	;AND IT GETS NORMAL TREATMENT
	SKIPN	CRTTYP		;OR CRTTYP IS 0
	JRST	RUBOUT		;THEN GO TO OLD ROUTINE
	TXO	F2,S.SLOG	;NOTHING GOES INTO LOG FILE
	MOVEI	A,CANRUB	;CANCEL THE EFFECT, IF ANY, OF THE RUBOUT
	CAIE	CH,.CHDEL
	MOVEI	A,CANBAK	;OR THE BACKSPACE
	PUSHJ	P,OUTMES
	SKIPG	COMCNT		;HAS ANYTHING BEEN SEEN?
	JRST	BACNON		;NO
	PUSHJ	P,HORPOS	;GO FIGURE OUT HORIZONTAL POSITION
	LDB	CH,AA		;GET DOOMED CHARACTER
	CAIG	CH,.CHBEL	;^G OR LESS?
	JRST	BACDUB		;YES, THEY ARE TWO WIDE
	CAIN	CH,.CHCNH	;BACKSPACE?
	JRST	BACBAK
	CAIN	CH,.CHTAB	;TAB?
	JRST	BACTAB
	CAIG	CH,.CHFFD	;EOL? (LF, VT, FF)
	JRST	BACEOL
	CAIN	CH,.CHCRT	;CARRIAGE RETURN?
	JRST	BACCR
	CAIE	CH,.CHESC	;ALTMODE,
	CAIL	CH," "		;BLANK OR GREATER?
	JRST	BACNOR

BACDUB:	PUSHJ	P,BACTWO	;HERE TO RUBOUT A CHAR OF WIDTH 2
BACNOR:	PUSHJ	P,BACONE
DELDON:	PUSHJ	P,BACKUP	;WIPE IT FROM COMMAND STRING
	CAIL	E,(OU)		;ARE WE BACK TO A FREE CRLF?
	JRST	LI1		;NO, RETURN
DELFIN:	PUSHJ	P,HORPOS	;YES, GO RECALCULATE LENGTH
	PUSHJ	P,BACREW	;AND RETYPE ABOVE LINE
	JRST	LI1		;AND RETURN

BACEOL:	MOVEI	T,1		;GET MULTIPLIER (LF=1)
	CAIE	CH,.CHLFD	;IF NOT LF,
	MOVE	T,VTMUL-13(CH)	;GET REAL MULTIPLIER
	MOVEI	TT,DELLF-12(CH)	;GET PROPER STRING
	MOVEI	A,FORCHR	;GET READY TO UNDO THE BACKSPACE
	MOVE	CH,CRTTYP	;GET THE FLAGS FOR THIS CRT
	TRNE	CH,.CWAP.	;IF THIS CRT DOES WRAP AROUND,
	SKIPE	E		;OR IF WE ARE NOT AT THE LEFT MARGIN
	PUSHJ	P,OUTMES	;THEN CANCEL THE BACKSPACE
EOL1:	JUMPLE	T,DELDON	;FINISHED?
	MOVE	A,TT		;GET STRING
	PUSHJ	P,OUTMES	;AND TYPE IT
	SOJA	T,EOL1		;LOOP

BACCR:	MOVEI	A,DELCR
	PUSHJ	P,OUTMES
	IBP	AA
	AOS	COMCNT
	PUSHJ	P,RETYPE	;FAKE A ^G<SPACE>
	JRST	LI2		;WE'RE DONE

BACBAK:	MOVEI	A,FORCHR	;CANCEL A BACKSPACE
	PUSHJ	P,OUTMES
	PUSHJ	P,BACKUP
	JRST	LI1

BACNON:	MOVE	CH,CRTTYP	;GET FLAGS
	TRNE	CH,.CNCR.	;SHOULD WE SEND A LONE CR?
	JRST	CLIS		;NOPE
	MOVEI	CH,.CHCRT	;TYPE A CR
	PUSHJ	P,TYOA
	JRST	CLIS		;AND RETYPE *

HORPOS:	MOVE	TT1,COMCNT	;SAVE CURRENT CHARACTER COUNT
	SETZ	E,		;INIT LINE WIDTH TO 0
	LDB	CH,AA		;GET CURRENT CHAR
	PUSHJ	P,BACKL1	;BACK UP TO THE BEGINNING OF CURRENT LINE
	AOS	E		;IF INITIAL LINE, THEN ACCOUNT FOR *
	MOVE	T,AA		;SAVE POINTER
	MOVE	TT,COMCNT	;AND COMMAND COUNT
	IBP	T		;BUMP THE POINTER UP, TO PLEASE RETYPE
POS2:	MOVE	OU,E		;SAVE LENGTH
	ILDB	CH,AA		;GET NEXT CHAR
	PUSHJ	P,LENCHR	;CALCULATE LENGTH OF CHARACTER
	AOS	D,COMCNT	;BUMP CHAR COUNT
	CAIL	D,(TT1)		;ARE WE BACK IN PLACE YET?
	POPJ	P,		;YES
	JRST	POS2

BACTAB:	PUSHJ	P,BACKUP	;GET RID OF THE TAB
	CAIGE	E,(OU)		;ARE WE AT A FREE CRLF?
	JRST	DELFIN		;YES
	SUBI	E,1(OU)		;GET LENGTH OF TAB-1
BTAB1:	JUMPLE	E,LI1		;RETURN IF LENGTH IS 0
	MOVEI	A,BACCHR	;BACK UP
	PUSHJ	P,OUTMES
	SOJA	E,BTAB1		;LOOP

BACREW:	MOVEM	T,AA		;HERE WHEN WE BACK UP OVER A FREE CRLF
	MOVEM	TT,COMCNT	;RESTORE AA AND COMCNT (LAST TIME POS=0)
	SKIPN	DELLF		;IF DELLF IS NULL, DONT BOTHER WITH THIS
	JRST	BACRW0
	MOVEI	A,DELLF
	PUSHJ	P,OUTMES	;MOVE UP TWO LINES
	PUSHJ	P,OUTMES
	PUSHJ	P,CRR		;TYPE A CRLF TO RESET HOR. POS.
BACRW0:	MOVEI	CH,"*"		;ARE WE AT THE BEGINING OF A COMMAND?
	SKIPN	COMCNT
	PUSHJ	P,TYOA		;YES
BACRW1:	LDB	CH,AA
	PUSHJ	P,CKEOL		;WE DONT WANT EOL'S
	PJRST	RETYP1		;GO FAKE ^G<SPACE>
	IBP	AA		;GET THE NEXT ONE
	AOS	COMCNT
	JRST	BACRW1		;LOOP

BACONE:	MOVEI	A,BACSEQ	;TO BACK OVER AND BLANK OUT A CHARACTER
	PJRST	OUTMES

BACTWO:	PUSHJ	P,BACONE	;HERE TO DELETE A DOUBLE CHAR
	MOVEI	A,BACCHR
	PJRST	OUTMES

;ROUTINE TO CALCULATE THE WIDTH OF A CHARACTER

LENCHR:	SETZ	D,
	CAIE	CH,.CHESC	;AN ALTMODE
	CAIL	CH," "		;OR ANYTHING " " OR OVER
	AOJA	D,LEN1		;IS OF WIDTH 1
	CAIN	CH,.CHCNH	;A BACKSPACE IS -1
	SOJA	D,LEN2
	CAIN	CH,.CHLFD	;A LINEFEED IS 0
	JRST	LEN1
	CAIN	CH,.CHVTB	;A VERTICAL TAB MAY BE SPECIAL
	JRST	[ADD D,VTWID
		 JRST LEN1]
	CAIN	CH,.CHFFD	;A FORM FEED MIGHT ALSO
	JRST	[ADD D,FFWID
		 JRST LEN1]
	CAIE	CH,.CHTAB	;A TAB?
	JRST	[ADDI D,2	;NOPE, ALL ELSE OF WIDTH 2
		 JRST LEN1]
	ADDI	E,10		;STANDARD TAB WIDTH
	TXZ	E,7		;BUT MUST BE MULTIPLE OF 8
	MOVEI	D,10
	SKIPA
LEN1:	ADD	E,D		;THIS IS THE NEW LENGTH
LEN2:	CAMG	E,TTYWID
	POPJ	P,
	MOVE	E,D		;WE ARE AT A FREE CRLF
	MOVE	T,AA		;SO SAVE THE BP AND THE COUNT
	MOVE	TT,COMCNT
	POPJ	P,	>	;END OF CRT CONDITIONAL
SUBTTL	COMMAND DECODER

STOP:	MONRT.			;SIMULATE ^C AT MACRO LEVEL
CD:RET:	HRRZS	EATCH		;FLAG NOT TO EAT AFTER : ANYTHING FAILS
	TXZE	FF,F.COLN	;F.COLN WHATEVER?
	JRST	FFOK		;RETURN -1, WHATEVER IT WAS IT WAS SUCCESSFUL
RETRET:	TXZ	FF,F.EBTP!F.ARG2!F.ARG!F.LARW!F.NSRH!F.SQIN!F.SRCH
	TXZ	F2,S.SSEQ!S.DPPN!S.OLOG!S.SLOG!S.MINS!S.DOIT!S.INFO!S.DELS
	SKIPE	INI		;IF INI FILE IN PROGRESS, NO COMMAND SEEN
	TXO	F2,S.GOIN	;A COMMAND STRING IS IN
CD1:	SETZM	NUM		;NO ARGUMENT STRING SEEN
	SETZM	SYL
	TXZ	FF,F.NEG	;CLEAR MINUS SIGN FLAG
	MOVX	A,<MOVE B,>	;STANDARD ARG OPERATOR IS MOVE B,SYL
CD3:	HLLM	A,DLIM
CD5:	PUSHJ	P,RCH
CD9:	SKIPN	XCTING		;KEEP GOING?
	JRST	GO		;NO STOP
	MOVE	A,CH		;GET COMMAND CHARACTER
	CAIL	CH,"0"		;IS IT A DIGIT?
	CAILE	CH,"9"
	TXZ	F2,S.OCTL	;NO, CLEAR OCTAL RADIX FLAG
	CAIE	A,140		;140 IS ILLEGAL
	CAILE	A,172		;ALSO 173-177 ARE ILLEGAL
	MOVEI	A,0
	CAILE	A,137		;REDUCE LOWER CASE TO UPPER
	SUBI	A,40
	ROT	A,-1		;DIV BY 2
	JUMPL	A,CD92		;ODD CHARACTER
	HLRZ	A,DTB(A)	;GET CODE & ADDR FOR EVEN CHAR.
	JRST	CD93
CD92:	HRRZ	A,DTB(A)	;GET CODE & ADDR FOR ODD CHAR.
CD93:	TXZ	F2,S.DOIT!S.INFO!S.MINS!S.EA!S.DPPN!S.YANK	;CLEAR INI FILE FLAGS
	TXZ	FF,F.INIT!F.FILE
	TRNN	A,300000	;IS IT A JRST DISPATCH WITH NO ARG PROCESSING?
	JRST	(A)		;YES, DO IT
	MOVE	B,NUM		;NO, TAKE CARE OF ARGUMENTS
	MOVE	C,DLIM		;GET DLIM
	TLNE	C,777K		;IF NO OPERATION DON'T DO IT!
	XCT	C		;NUM:=NUM (DLIM OPERATOR) SYL
	MOVEM	B,NUM
	SETZM	SYL		;CLEAR OLD OPERAND
	MOVSI	C,(MOVE B,)	;DON'T USE THE SAME OP TWICE!
	HLLM	C,DLIM		;SO RESET DLIM
	MOVE	C,SARG		;SAVE SECOND ARGUMENT IN C.
	TXZ	FF,F.SYL	;CLR DIGIT STRING BIT
	TXZ	F2,S.CTLV+S.CTVV+S.CTLW+S.CTWW+S.XMAT+S.EMAT+S.NCCT
	MOVEM	P,PDLSAV
	TRZ	A,100000	;CLR PUSHJ DISPATCH BIT
	TRZE	A,200000	;JRST OR PUSHJ DISPATCH?
	JRST	(A)
	PUSHJ	P,(A)
	JRST	RET
SUBTTL	NUMERIC INPUT, VALRET, & ALTMODE PROCESSOR

;DIGITS FORM DECIMAL INTEGERS.

CDNUM:	TXON	FF,F.SYL	;DIGIT STRING ALREADY STARTED?
	SETZM	SYL		;NO, INIT TO ZERO
	MOVEI	A,12		;RADIX 10
	TXNN	F2,S.OCTL	;OCTAL FLAG ON?
	JRST	CDNUM1		;NO
	MOVEI	A,10		;YES, RADIX 8
	CAILE	CH,"7"		;FLAG 8 OR 9 IN OCTAL STRING
	ERROR	E.OCT
CDNUM1:	IMUL	A,SYL		;SCALE PREVIOUS VALUE
	ADDI	A,-60(CH)	;ADD IN NEW DIGIT

;SOME COMMANDS HAVE A NUMERIC VALUE
VALRET:	HRRZS	EATCH		;CLEAR THE EAT FLAG
	MOVEM	A,SYL
CD7:	TXO	FF,F.ARG
	JRST	CD5

ALTMOD:	SKIPN	COMCNT		;ANY COMMANDS LEFT?
	JRST	ALTM2		;NO
	MOVE	T,CPTR		;IF NEXT COMMAND CHARACTER IS ALT-MODE, GO
	ILDB	CH,T
	CAIE	CH,.CHESC
	JRST	CD
ALTM1:	TXNE	FF,F.TRAC	;TRACING?
	PUSHJ	P,CRR		;YES, TYPE CR/LF BEFORE *
	JRST	GO
ALTM2:	SKIPN	EQM		;WITHOUT A MACRO ?
	JRST	GO		;NO
	JRST	CD		;MACRO RETURN

;^ MEANS THAT THE NEXT CHARACTER IS A CONTROL CHARACTER.

UAR:	PUSHJ	P,SKRCH		;GET NEXT COMMAND CHARACTER.
	ERROR	E.MEU
	TRZ	CH,140		;CHANGE IT TO CONTROL CHARACTER
	JRST	CD9		;DISPATCH
SUBTTL	COMMA & PARENTHESES PROCESSOR

;IF A COMMAND TAKES TWO NUMERIC ARGUMENTS, COMMA IS USED TO SEPARATE THEM

COMMA:	MOVEM	B,SARG		;SAVE CURRENT ARGUMENT IN SARG.
	TXZE	FF,F.ARG	;WAS THERE A CURRENT ARGUMENT?
	TXOE	FF,F.ARG2	;YES. WAS THERE ALREADY A SECOND ARGUMENT?
	ERROR	E.ARG
	JRST	CD1		;YES. CLEAR CURRENT ARGUMENT.

;() MAY BE USED TO OVERRIDE LEFT TO RIGHT OPERATOR SCAN FOR +,-,*,/,& AND #.

OPENP:	PUSH	P,NUM		;PUSH CURRENT ARGUMENT.
	PUSH	P,DLIM		;CURRENT OPERATOR
	PUSH	P,[1]		;SET PAREN FLAG ON PDL
	JRST	CD1

CLOSEP:	POP	P,T		;LAST THING ON PDL A LEFT PAREN?
	JUMPL	T,CLOSE1	;SOMETHING LIKE (...<...)
	SOJN	T,CLOSE2	;MISSING (
	MOVEM	B,SYL		;YES. SAVE CURRENT ARGUMENT.
	POP	P,DLIM		;RESTORE OPERATOR
	POP	P,NUM		;RESTORE ARGUMENT.
	JRST	CD7

CLOSE1:	ERROR	E.PAR
CLOSE2:	ERROR	E.MLP

;^O SETS FLAG FOR OCTAL RADIX INPUT

OCTIN:	TXO	F2,S.OCTL
	JRST	CD5		;RETURN WITHOUT MESSING UP ARGUMENTS


;IF 'HE' CAN HAVE ^F READ THE SWITCHES I CAN HAVE N^F RETURN
;THE TTY NUMBER OF JOB N + 200000 OCTAL OR ZERO IF NONE!!!!

WHERE:	TRMNO.	B,		;WHAT TTY HE ON
	JRST	BEGIN		;ZERO, NOT ONE ONE
	MOVE	A,B		;RETURN VALUE
	JRST	VALRET		;...
SUBTTL	MATHEMATICAL & LOGICAL OPERATORS

;LOGICAL AND

CAND:	MOVSI	A,(AND B,)	;DLIM = AND B,SYL
	JRST	CD3

;LOGICAL OR

COR:	MOVSI	A,(OR B,)	;DLIM = OR B,SYL
	JRST	CD3

;ADD TAKES ONE OR TWO ARGUMENTS

PLUS:	MOVSI	A,(ADD B,)	;DLIM = ADD B,SYL
	JRST 	CD3

;SUBTRACT TAKES ONE OR TWO ARGUMENTS

MINUS:	MOVSI	A,(SUB B,)	;DLIM = SUB B,SYL
	TXO	FF,F.NEG	;SET FLAG FOR -L, -T, ETC...
	JRST	CD3

;MULTIPLY TAKES TWO ARGUMENTS

TIMES:	MOVSI	A,(IMUL B,)	;DLIM = IMUL B,SYL
	JRST	CD3

;DIVIDE (TRUNCATES) TAKES TWO ARGUMENTS

SLASH:	MOVSI	A,(IDIV B,)	;DLIM = IDIV B,SYL
	JRST	CD3
SUBTTL	FLAGS - EOF, FORM FEED & . H Z POSITIONS

;RETURNS THE VALUE OF THE FORM FEED FLAG

FFEED:	TXNE	FF,F.FORM	;IS IT SET?
	JRST	FFOK		;YES, RETURN A -1
	JRST	BEGIN		;NO, DO BEGIN ROUTINE
;RETURNS THE NUMERIC VALUE 0.

ABEGIN:	SKIPL	EATCH		;TO MUNCH?
	JRST	BEGIN		;NO, PIG!
	MOVEI	B,.CHESC	;TECO'S ALTMODE
	HRRZS	CH,EATCH	;GET LAST CHARACTER INPUT FROM COMMAND
SAMECH:	CAMN	CH,B		;SAME?
	JRST	BEGIN		;RETURN FAILURE VALUE
READNT:	PUSHJ	P,SKRCH		;GET ANOTHER CHARACTER IF NOT
	ERROR	E.UCS
	JRST	SAMECH		;LOOP TIL U SEE IT
BEGIN:	MOVEI	A,0
	JRST	VALRET

;^N RETURNS VALUE OF EOF FLAG

EOF:	TXNN	FF,F.EOFI	;EOF SEEN?
	JRST	BEGIN		;NO, RETURN 0
	JRST	FFOK		;YES, RETURN -1

;AN ABBREVIATION FOR B,Z

HOLE:	SETZM	SARG		;SET SECOND ARGUMENT TO 0.
	TXNE	FF,F.ARG2	;FLAG ANY ARGS BEFORE H
	ERROR	E.ARG
	TXOA	FF,F.ARG2

;.=NUMBER OF CHARACTERS TO THE LEFT OF THE POINTER

PNT:	SKIPA	A,PT

;Z=NUMBER OF CHARACTERS IN THE BUFFER

END1:	MOVE	A,Z
	SUB	A,BEG
	JRST	VALRET

;RETURN LENGTH OF LAST TEXT STRING PROCESSED

IFN VC,<
VCMD:	MOVE	A,VVAL		;LENGTH OF LAST TEXT
	JRST	VALRET
	>
SUBTTL	= & ^T COMMANDS

;N=	CAUSES THE VALUE OF N TO BE TYPED OUT.

PRNT:	TXNN	FF,F.ARG	;INSIST ON ARG BEFORE =
	ERROR	E.NAE
	MOVE	A,CPTR		;SNEAK A LOOK AT NEXT COMMAND CHAR.
	ILDB	CH,A
	CAIE	CH,"="		;ANOTHER = SIGN?
	JRST	PRNT9		;NO
	TXO	F2,S.OCTL	;YES, THAT MEANS OCTAL RADIX TYPE-OUT
	PUSHJ	P,SKRCH		;SWALLOW THE EXTRA =
	TXZ	F2,S.OCTL	;AT END OF MACRO
PRNT9:	PUSHJ	P,PRNT9S	;PRINT NUMBER
	TXZN	FF,F.ARG2	;TWO ARGS?
	JRST	CRR		;CRLF AND RETURN TO CALLER
	JUMPL	C,CRR		;NEG ARG MEANS CRLF WANTED
	JUMPE	C,CPOPJ		;NOTHING IF ZERO
	MOVE	CH,C		;GET CHARACTER TO BE OUTPUT
	JRST	TYO		;ELSE TYPE CHAR AND RETURN

;TYPE C(B) IN OCTAL
OCTMS:	TXOA	F2,S.OCTL	;SET OCTAL RADIX
DECMS:	TXZ	F2,S.OCTL	;DECIMAL RADIX
PRNT9S:	MOVEI	A,TYO		;OUTPUT ON TTY
	PUSHJ	P,DPT		;TYPE NUMBER
	TXZ	F2,S.OCTL	;CLR RADIX FLAG
	POPJ	P,

;CAUSES COMMAND INTERPRETATION TO STOP UNTIL THE USER TYPES A CHARACTER
;ON THE TELETYPE AND THEN HAS THE ASCII VALUE OF THE CHARACTER TYPED IN.

SPTYI:	SETZM	XCTING		;SO NO WAIT FOR INPUT ON ^C REE
	TXZE	FF,F.COLN	;EXTENDED TTY OPERATIONS?
	JRST	EXTTTY		;YES
	TXO	FF,F.DDTM
	PUSHJ	P,TYI		;GET A SINGLE CHAR.
	SETOM	XCTING		;RESET FLAG, HAVE CHARACTER
	SKIPA	A,CH

SUBTTL	^H, ^F AND ^^ COMMANDS

;HAS THE VALUE OF ELAPSED TIME, IN 60THS OF A SECOND, SINCE MIDNITE.

GTIME:	TIMER	A,
	JRST	VALRET

;HAS THE VALUE OF THE CONSOLE DATA SWITCHES.

LAT:	TXZE	FF,F.ARG+F.ARG2	;EITHER OF THESE ON GO TO WHERE
	JRST	WHERE		;...
	SWITCH	A,
	JRST	VALRET

;HAS THE VALUE OF THE NEXT CHARACTER IN THE COMMAND STRING.

CNTRUP:	PUSHJ	P,SKRCH		;^^ HAS VALUE OF CHAR FOLLOWING IT
	ERROR	E.MUU
	MOVE	A,CH
	JRST	VALRET
SUBTTL	EXTENDED ^T OPERATIONS

;TABLE FOR EXTENDED TTY OPERATIONS
;FORMAT FIRST WORD 1B<TTCALL #> ON = LEGAL TTCALL
;	SECOND WORD 1B<TTCALL #> ON = SHOULD SKIP (0 RETURNED IF NOT)
;	THIRD WORD 1B<TTCALL #> ON = RETURNS A VALUE ELSE NOTHING

TABLE1:	^B111011111111110000000000000000000000
TABLE2:	^B001001000001100000000000000000000000
TABLE3:	^B101011100000000000000000000000000000

EXTTTY:	MOVE	A,C		;I LIKE TO DO IT THIS WAY!!
	MOVN	E,B		;GET - TTCALL NUMBER
	SKIPLE	E		;WAS IT A NEGATIVE TTCALL?
	JRST	HACK		;YES
	MOVSI	CH,400K		;TO DETERMINE WHAT TO DO
	LSH	CH,(E)		;GET IT
	TDNN	CH,TABLE1	;LEGAL?
	ERROR	E.ITT
	CAIN	B,<RSCN==10>	;RESCAN FUDGE FUNCTIONS?
	JRST	REFUDG		;YES, DO THEM
	TXZ	FF,F.ARG2	;SO NO TWO ARGS RETURNS
	MOVE	E,[TTCALL 0,A]	;FOR XCT
	DPB	B,[POINT 4,E,12]	;MAKE A TTCALL N,
	XCT	E		;DO IT
	JRST	NOSKP		;SEE WHAT TO DO
	SETOM	XCTING		;RESET I AM DOING SOMETHING FLAG
	TDNN	CH,TABLE3	;DOES HE GET -1 OR C(A)
	SETO	A,		;-1
	JRST	VALRET		;MAKE IT AVAILABLR
NOSKP:	SETOM	XCTING		;FIX ACTIVE FLAG
	TDNE	CH,TABLE2	;SHOULD HAVE SKIPPED
	JRST	BEGIN		;RETURN ZERO
	TDNN	CH,TABLE3	;RETURN A VALUE?
	JRST	RET		;NO
	JRST	VALRET		;ELSE THROW THING IN A AT HIM


REFUDG:	SETOM	XCTING		;KEEP GOING!!!!
	MOVE	E,[RESCAN 1]	;ASSUME GOING TO RESCAN COMMAND LINE
	TXZE	FF,F.ARG2	;TWO ARGS = RETURN VALUE OF CCL FLAG
	MOVE	E,[SKIPE CCLSW]	;TEST CCL SWITCH
	XCT	E
	JRST	FFOK		;COMMAND THERE = -1
	JRST	BEGIN		;0, NOTHING THERE

HACK:	SETOM	XCTING
	CAILE	E,2		;LEGAL?
	ERROR	E.ITT
	SETSTS	TTY,@NOECHO-1(E)
	JRST	RET

NOECHO:	EXP	IO.SUP!IO.FCS!.IOASC
ECHO:	EXP	IO.FCS!.IOASC
SUBTTL	BACKSLASH PROCESSOR - AND NA COMMAND

;HAS THE VALUE OF THE NUMBER REPRESENTED BY THE DIGITS (OR MINUS SIGN)
;FOLLOWING THE POINTER IN THE BUFFER.  THE SCAN TERMINATES ON ANY OTHER
;CHARACTER.  THE POINTER IS MOVED OVER THE NUMBER FOUND (IF ANY).

BAKSL:	TXZE	FF,F.ARG	;WHICH KIND OF BACKSLASH?
	JRST	BAKSL1		;ARG TO MEMORY
	MOVE	I,PT		;MEMORY TO VALRET
	CAML	I,Z		;CAN WE READ ANOTHER?
	JRST	BAKSL3		;NO
	PUSHJ	P,GETINC	;CK FOR +,- SIGN
	CAIN	CH,"+"
	JRST	BAKSLA		;IGNORE +
	CAIE	CH,"-"
	JRST	BAKSL0		;NO SIGN
	TXO	FF,F.ARG	;NEGATION FLAG
BAKSLA:	CAML	I,Z		;OVERDID IT ?
	JRST	BAKSL3		;YES. EXIT
	PUSHJ	P,GETINC	;NO. GET A CHAR
BAKSL0:	CAIG	CH,"9"		;DIGIT?
	CAIGE	CH,"0"		;DIGIT?
	SOJA	I,BAKSL2	;NOT A DIGIT. BACKUP AND LEAVE LOOP
	SUBI	CH,"0"		;CONVERT TO NUMBER
	EXCH	CH,SYL
	IMULI	CH,12
	ADDM	CH,SYL		;SYL:= 10.*SYL+CH
	JRST	BAKSLA		;LOOP

BAKSL3:	MOVE	I,Z		;HERE ON OVERFLOW
BAKSL2:	TXZE	FF,F.ARG	;MINUS SIGN SEEN?
	MOVNS	SYL		;YES. NEGATE
	MOVEM	I,PT		;MOVE POINTER PAST #
	JRST	CD7		;DONE


;NA (WHERE N IS A NUMERIC ARGUMENT) = VALUE IN 7-BIT ASCII OF THE
;CHARACTER TO THE RIGHT OF THE POINTER.

ACMD:	TXNN	FF,F.ARG	;DOES AN ARGUMENT PRECEED A?
	JRST	APPEND		;NO. THIS IN AN APPEND COMMAND.
	MOVE	I,PT		;GET POINT
	CAMN	I,Z		;BUFFER EMPTY OR PT=Z
	JRST	BEGIN		;RETURN 0
	PUSHJ	P,GET		;CH:=CHARACTER TO THE RIGHT OF PT.
	MOVE	A,CH		;RETURN CH AS VALUE.
	JRST	VALRET
SUBTTL	Q-REGISTER COMMANDS --  U & Q

;NUI	PUTS THE NUMERIC VALUE N IN Q-REGISTER I.

USE:	TXNN	FF,F.ARG	;INSIST ON ARG BEFORE U
	ERROR	E.NAU
USEA:	PUSHJ	P,QREGVI	;YES. CH:=Q-REGISTER INDEX.
	MOVEM	B,QTAB-"0"(CH)	;STORE ARGUMENT IN SELECTED Q-REG.
	JRST	RET

;QI	HAS THE VALUE OF THE LATEST QUANTITY PUT INTO Q-REGISTER I.

QREG:	PUSHJ	P,QTXTST	;GET Q-REGISTER INDEX & CHECK FOR TEXT
	JRST	VALRET
	PUSHJ	P,QTEXEI	;GET Q REG ADR
	PUSHJ	P,GTQCNT	;# CHARS IN Q REG
	MOVE	B,CPTR		;GET COMMAND POINTER
	ILDB	CH,B		;QA= (IE TYPE TEXT IN Q REG)?
	CAIE	CH,"="		;...
	..ERROR	E.NNQ
	PUSHJ	P,SKRCH		;EAT =
	..ERROR	E.NNQ
	MOVE	OU,I		;BEG OF Q REG
	MOVE	B,OU		;START CHARACTER
	ADD	B,C		;END
	MOVEI	D,TYO		;ROUTINE TO TYPE CHARS
	SETZM	XCTING		;SO ^C^C REE WORKS PROPERLY
	PUSHJ	P,TYPEQ		;TYPE CONTENTS OF Q-REG
	SETOM	XCTING		;DONE TYPING
	JRST	RET		;DONE

;ROUTINE TO RETURN Q-REGISTER INDEX IN CH AND CONTENT IN A.

QREGVI:	PUSHJ	P,SKRCH		;CH:=NEXT COMMAND STRING CHARACTER.
	ERROR	E.MIQ
QREGV2:	CAIE	CH,"*"		;EI REG?
	JRST	NOTEI
	MOVEI	CH,"Z"-<"A"-"9"-1>+1	;INDEX INTO QTAB
	POPJ	P,
NOTEI:	CAIL	CH,"A"+" "-1	;LC LETTER?
	TXZ	CH,40		;MAKE UC
	CAIGE	CH,"0"		;DIGIT?
	ERROR	E.IQN		;BAD NAME
	CAIG	CH,"9"
	POPJ	P,		;YES
	CAIL	CH,"A"		;LETTER?
	CAILE	CH,"Z"
	ERROR	E.IQN		;BAD NAME
	SUBI	CH,"A"-"9"-1	;TRANSLATE LETTERS DOWN BY NUMBER OF
	POPJ	P,		;CHARACTERS BETWEEN 9 AND A. ONLY 36 Q-REG'S


SUBTTL	Q-REGISTER COMMANDS -- %
;%I	ADDS 1 TO THE QUANTITY IN Q-REGISTER I AND STANDS FOR THE
;	NEW VALUE

PCNT:	PUSHJ	P,QTXTST	;GET Q-REG AND CHECK FOR TEXT
	AOSA	A,QTAB-"0"(CH)	;INCREMENT Q-REG.
	..ERROR	E.NNQ
	JRST	VALRET		;RETURN NEW VALUE.

QTXTST:	PUSHJ	P,QREGVI	;GET Q-REG INDEX
	MOVE	A,QTAB-"0"(CH)	;GET Q-REG CONTENTS
	TLNE	A,400000	;DOES IT CONTAIN TEXT?
	TLNE	A,377777
	POPJ	P,		;YES, NON-SKIP RETURN
	JRST	CPOPJ1		;ELSE CONTAINS TEXT
SUBTTL	Q-REGISTER COMMANDS -- X
;M,NXI	COPIES A PORTION OF THE BUFFER INTO Q-REGISTER I.

;	IT SETS Q-REGISTER I TO A DUPLICATE OF THE (M+1)TH
;	THROUGH NTH CHARACTERS IN THE BUFFER.  THE BUFFER IS UNCHANGED.
;NXI	INTO Q-REGISTER I IS COPIED THE STRING OF CHARACTERS STARTING
;	IMMEDIATELY TO THE RIGHT OF THE POINTER AND PROCEEDING THROUGH
;	THE NTH LINE FEED.

X:
IFN VC,<SETZM	VVAL>		;CLR STRING LENGTH HOLD
	PUSHJ	P,GETARG	;C:=FIRST STRING ARGUMENT ADDRESS
				;B:=SECOND STRING ARGUMENT ADDRESS.
COPYEI:	PUSHJ	P,CHK1		;IS SECOND ARG. ADDR. > FIRST ARG. ADDR.?
	EXCH	B,C		;YES.
	SUBI	C,-3(B)		;C:=LENGTH OF STRING+3.
	MOVEI	A,-3(C)		;STORE LENGTH OF STRING SAVED
IFN VC,<MOVEM	A,VVAL>
	ADD	B,C		;B:=FIRST ARG ADDR + LENGTH OF STRING + 3
	PUSHJ	P,X3		;MOVE DATA TO Q-REG BUFR
	TXNN	FF,F.INIT	;INI FILE THING?
	JRST	USEA		;NO, MAKE QTAB ENTRY NORMALLY.
	MOVEM	B,QTAB-"0"+<STAR==124>	;INTO * Q-REG
	POPJ	P,		;AND RETURN
;TRANSFER DATA TO Q-REGISTER BUFR

X3:	PUSH	P,PT
	ADDM	C,(P)		;(P):=PT + LENGTH OF STRING + 3.
	MOVE	D,BEG
	MOVEM	D,PT		;PT:=BEG
	PUSHJ	P,NROOM		;INSERT STRING AT BEG
	MOVE	OU,RREL		;RREL CONTAINS RELOCATION CONSTANT IF
				;GARBAGE COL. OCCURRED.
	ADDM	OU,(P)		;RELOCATE TOP OF STRING POINTER.
	ADD	B,OU		;B:=FIRST ARG ADDR + LENGTH OF STRING + 3 + RREL
	MOVE	OU,BEG		;OU:=ADDRESS OF Q-REG BUFFER
	ADDM	C,BEG		;BEG:=C(BEG)+LENGTH OF STRING + 3
	MOVE	CH,C		;FIRST CHAR OF BUFFER :=LEAST SIGNIFICANT 7 BITS
	PUSHJ	P,PUT		;OF LENGTH OF STRING + 3
	AOS	OU		;SECOND CHAR = MIDDLE 7 BITS OF LENGTH
	ROT	CH,-7
	PUSHJ	P,PUT
	ROT	CH,-7
	MOVE	I,B		;THIRD CHAR OF BUFFER := MOST SIGNIFICANT 7 BITS
				;OF LENGTH OF STRING + 3
	AOS	OU
X1:	PUSHJ	P,PUT		;MOVE STRING TO Q-REG BUFFER.
	AOS	OU
	CAIN	C,3
	JRST	X2
	PUSHJ	P,GETINC
	SOJA	C,X1
X2:	MOVE	B,PT		;QTAB ENTRY :=XWD 400000,Q-REG BUFFER
				;ADDRESS RELATIVE TO C(QRBUF)
	SUB	B,QRBUF
	TLO	B,400000
	POP	P,PT		;MOVE PT PAST STRING.
	POPJ	P,
SUBTTL	Q-REGISTER COMMANDS -- G
;GI	THE TEXT IN Q-REGISTER I IS INSERTED INTO THE BUFFER

;	AT THE CURRENT LOCATION OF THE POINTER.  THE POINTER IS THEN PUT JUST
;	TO THE RIGHT OF THE INSERTION.  THE Q-REGISTER IS NOT CHANGED.

QGET:
IFN VC,<SETZM	VVAL>		;CLR STRING LENGTH HOLD
	PUSHJ	P,QTEXT		;INIT Q-REG ACCESS
	MOVE	B,CH		;SAVE INDEX
	PUSHJ	P,GTQCNT	;C:=LENGTH OF STRING
	PUSHJ	P,NROOMC	;MOVE FROM PT THROUGH Z UP C POSITIONS
	MOVE	OU,PT
	HRRZ	I,QTAB-"0"(B)
	ADD	I,QRBUF
	ADDI	I,3
QGET1:	JUMPE	C,RET		;MOVE STRING INTO DATA BUFFER
	PUSHJ	P,GETINC
	PUSHJ	P,PUT
	AOS	OU,PT
	SOJA	C,QGET1

;GET 21 BIT Q-REGISTER CHARACTER COUNT

GTQCNT:	PUSHJ	P,GETINC	;LOW ORDER 7 BITS
	MOVEM	CH,C
	PUSHJ	P,GETINC	;MIDDLE 7 BITS
	ROT	CH,7
	IORM	CH,C
	PUSHJ	P,GETINC	;HIGH 7 BITS
	ROT	CH,^D14
	IORM	CH,C
	SUBI	C,3		;LESS 3 WORDS USED TO STORE THIS COUNT
	POPJ	P,

;INITIALIZE ACCESS OF TEXT FROM A Q-REGISTER

QTEXT:	PUSHJ	P,QREGVI	;A=QTAB ENTRY, CH=Q-REG INDEX
QTEXEI:	MOVE	A,QTAB-"0"(CH)
	TLZE	A,400000	;MAKE SURE IT CONTAINS TEXT
	TLZE	A,377777
	..ERROR	E.NTQ		;NO TEXT
	ADD	A,QRBUF
	MOVE	I,A		;I=Q-REG BUFFER ADDRESS
	POPJ	P,
SUBTTL	Q-REGISTER COMMANDS -- M, W, [ & ]
;MI	PERFORM NOW THE TEXT IN Q-REGISTER I AS A SERIES OF COMMANDS.

MJRST:	SKIPE	EQM		;W @ CMD LEVEL = M
	JRST	QACCES		;ELSE OK

MAC:	PUSHJ	P,QTEXT		;INIT Q-REG ACCESS
MAC1:	PUSH	P,COMAX		;SAVE CURRENT COMMAND STATE
	PUSH	P,CPTR
	PUSH	P,COMCNT
	PUSH	P,.		;FLAG MACRO ON PDL (LARGE POS. NO.)
	AOSA	EQM		;INCREMENT THE MACRO LEVEL
QACCES:	PUSHJ	P,QTEXT		;INIT Q REG ACCESS FOR W COMMAND
	PUSHJ	P,GTQCNT	;GET NUMBER OF CHARACTERS IN MACRO
	MOVEM	C,COMCNT	;THAT MANY COMMANDS TO COUNT
	MOVEM	C,COMAX		;AND MAX.
	SUBI	I,1		;ADJUST TO SUIT BTAB
	IDIVI	I,5
	MOVE	OU,BTAB(OU)	;MAKE A BYTE POINTER
	HRR	OU,I
	MOVEM	OU,CPTR		;PUT IT IN CPTR
	JRST	CD5		;DON'T FLUSH ANY ARGUMENTS


;]I	POPS Q-REGISTER I OFF THE Q-REGISTER PUSHDOWN LIST.
;	THE Q-REGISTER PUSHDOWN LIST IS CLEARED EACH TIME $$ IS TYPED.

CLOSEB:	HLRZ	C,PF		;GET PDL COUNT
	MOVEI	B,"]"		;POP
	CAIG	C,-LPF-1	;UNDERFLOW?
	ERROR	E.PDQ
	SKIPA	C,[POP PF,]

;[I	PUSHES Q-REGISTER I ONTO THE Q-REGISTER PUSHDOWN LIST.

OPENB:	MOVSI	C,261000+PF*40
	PUSHJ	P,QREGVI
	HRRI	C,QTAB-"0"(CH)	;C:=Q-REGISTER INDEX.
	XCT	C		;PUSH OR POP Q-REGISTER.
	JRST	RET
SUBTTL	MISCELLANEOUS CHARACTER DISPATCHER

;CALL:	MOVE	CH,CHARACTER
;	MOVEI	T,TABLE ADDR
;	PUSHJ	P,DISPAT
;	NOT FOUND RETURN
;ENTER AT DISP1 TO AVOID CONVERTING LC TO UC

DISPAT:	CAIG	CH,"Z"+" "	;CONVERT LC TO UC
	CAIG	CH,137
	JRST	DISP1
	TXZ	CH,40
DISP1:	PUSH	P,A		;SAVE AC A WHILE WE USE IT
DISP2:	MOVE	A,(T)		;GET TABLE ENTRY
	JUMPE	A,APOPJ		;END OF TABLE
	CAIE	CH,(A)		;SAME
	AOJA	T,DISP2		;NOT A MATCH
	HLRZM	A,-1(P)		;GOT IT -- PUT DISPATCH ADDR ON PDL
	JRST	APOPJ		;RESTORE AC A & DISPATCH



;USETI ON ER'D FILE PROCESSOR
;USETI ONLY LEGAL IF NOT EB AND ER IS TRUE

IUSET:	JUMPLE	B,USTERR	;ARG LESS THAN OR = ZERO LOSES
	TXNN	FF,F.UBAK	;MUST NOT BE EB IN FORCE
	TXNN	FF,F.IOPN	;BUT MUST HAVE INPUT FILE OPEN
USTERR:	ERROR	E.UST
	USETI	INCHN,(B)	;DO THE USETI
	MOVX	T,BF.IOU	;MUST CLEAR ALL THE USE BITS
	HRRZ	A,IBUF		;STARTING HERE
	HRRZ	B,A		;ENDING HERE TOO
USTILP:	ANDCAM	T,(A)		;CLEAR THE BIT
	HRRZ	A,(A)		;NEXT BUFFER
	CAME	A,B		;DONE?
	JRST	USTILP		;LOOP FOR ALL BUFFERS
	SETZM	IBUF+.BFCNT	;FORCE A READ (IN)
	STATO	INCHN,IO.ERR!IO.EOF	;ANY PROBLEM ARISE?
	POPJ	P,		;NO, RETURN TO HIM
	USETI	INCHN,1		;BACK TO START OF FILE
	ERROR	E.UST
SUBTTL ^G COMMAND (GETTAB OR EXIT)

;ROUTINE TO EXIT IF EO = 1 (OLD ^G) OR DO GETTAB

BELDMP:	CHKEO	EO21,DECDMP	;OLD EXIT
	TXNE	FF,F.ARG	;IF NO ARG THEN RETURN JOB NUMBER
	JRST	BELDP0		;THERE IS AN ARG...
	PJOB	A,		;JOB NUMBER
	JRST	VALRET		;RETURN IT
BELDP0:	MOVE	A,B		;GET ADR OR TABLE NO.
	TXZN	FF,F.ARG2	;TWO ARGS?
	JRST	BELPEK		;NOPE, DO A PEEK
	HRL	A,C		;FORM GETTAB WORD
	GETTAB	A,		;DO THE GETTAB
	  SETZ	A,		;RETURN ZERO ON ERROR
	JRST	VALRET		;ELSE RETURN WHATEVER
BELPEK:	PEEK	A,		;WILL IT WORK?
	JRST	VALRET		;WE'LL NEVER KNOW...
SUBTTL E COMMANDS -- DISPATCH ROUTINE & TABLE

ECMD:	PUSHJ	P,SKRCH		;GET CHAR AFTER E
	ERROR	E.MEE
	CAIG	CH,"Z"+" "	;LOWER CASE GOES TO UPPER
	CAIGE	CH,"A"+" "	;...
	  CAIA
	SUBI	CH," "		;TO UPPER CASE
	HRREI	TT,-"A"(CH)	;CONVERT TO TABLE OFFSET
	SKIPL	TT		;NEG IS ERROR
	CAILE	TT,"Z"-"A"	;IS BOUNDS
E$$IEC:	ERROR	E.IEC
	LSHC	TT,-1		;CALCULATE TABLE WORD & HALF
	MOVE	TT,ECTABL(TT)	;GET ADRS OF PROCESSORS
	SKIPL	TT1		;HAVE IT
	MOVSS	TT		;NO, NEED OTHER HALF
	JRST	(TT)		;GO

;E-COMMAND DISPATCH TABLE

ECTABL:	XWD	OPNWRA,EBAKUP	;EA,EB
	XWD	ECORE,RUNFX	;EC,ED
	XWD	EECMD,CLOSEF	;EE,EF
IFN CCL,<XWD	CCLFIN,ERRSET	;EG,EH> XWD	E$$IEC,ERRSET
	XWD	EICMD,E$$IEC	;EI,<EJ>
	XWD	EKILL,MAKLOG	;EK,EL
	XWD	EMTAPE,RENAM	;EM,EN
	XWD	OLDMOD,EPCMD	;EO,EP
IFE	FTEAGAIN,<	XWD	E$$IEC,OPNRD	;<EQ>,ER	>
IFN	FTEAGAIN,<	XWD	EAGAIN,OPNRD	; EQ,ER	>
	XWD	AUTOTY,TYOCTL	;ES,ET
	XWD	TYCASE,VIDEO	;EU,EV
	XWD	OPNWR,FINISH	;EW,EX
	XWD	YANK,ZERDIR	;EY,EZ
SUBTTL E COMMANDS -- EL (SETUP AND OUTPUT ROUTINES)

LOGOUT:	TXZN	F2,S.ASTR
	TXNE	F2,S.SLOG	;SKIP LOG FILE?
	POPJ	P,		;RIGHT
	SOSG	OLOG+.BFCNT	;DECREMENT BUFFER COUNTER
	OUTPUT	LOGCHN,		;DUMP BUFFER IF NO ROOM
	IDPB	CH,OLOG+.BFPTR	;PUT CHARACTER
	TXNE	F2,S.OLOG	;MISUSING TYOM?
	POP	P,CH		;YES, FORCE NICE RETURN
	POPJ	P,		;AND RETURN

MAKLOG:	TXNE	FF,F.ARG	;ARGUMENT?
	JRST	CHANGL		;YES, CHANGE OUTPUT SPECIFICATION
	TXNE	F2,S.LOPN	;DO WE HAVE AN OPEN LOG FILE?
	RENAME	LOGCHN,LOGFL	;FINAL RENAME FOR PROTECTION
	  JFCL			;"IMPOSSIBLE ERROR"
	SETZM	LOGOPN+.OPMOD	;ASCII MODE FOR LOG FILE
	TXZ	F2,S.LIN!S.LOUT!S.LOPN!S.OLOG
	PUSHJ	P,DSPEC		;GET FILE SPEC AND DEFAULT
	MOVSI	E,OLOG		;BUFFER HEADER
	MOVEM	E,LOGOPN+.OPBUF	;SAVE
	MOVEI	B,"L"		;TO MAKE CORRECT ERROR MESSAGE TYPE
	OPEN	LOGCHN,LOGOPN	;OPEN DEVICE
	..ERROR	E.ODV
	SKIPN	A,XFILNM+.RBEXT	;SPECIFY AN EXT?
	MOVSI	A,'LOG'		;THIS IS DEFAULT
	MOVEM	A,XFILNM+.RBEXT	;SAVE IT
	MOVE	B,SWITC		;GET SWITCHES
	TLNN	B,FS.APP	;TO SUPERSEDE OLD FILE?
	JRST	ENTLOG		;YES
	MOVEI	E,LOGCHN	;SET UP FOR CHKDEF
	LOOKUP	LOGCHN,XFILNM	;SEE FILE
	SKIPA			;NOT THERE
	PUSHJ	P,CHKPTH	;SEE IF FOUND ON SPECIFIED DIRECTORY
ENTLOG:	SETZM	LOGOPN+1	;NOPE
ENT02:	SKIPN	LOGOPN+1	;TO APPEND?
	CLOSE	LOGCHN,		;NO, CLOSE FILE
	PUSHJ	P,PPNSPC	;SET UP PPN IN CASE WIPED
	ENTER	LOGCHN,XFILNM	;ENTER LOG FILE
	EE1+..ERROR E.ENT	;ENTER ERROR ON LOG FILE
	MOVEI	E,LOGFL		;SAVE FILESPEC
	PUSHJ	P,SPCSAV
	SKIPE	LOGOPN+1	;TO USETO?
	USETI	LOGCHN,-1	;DO IT
	MOVEI	E,LOGSPC
	EXCH	E,.JBFF
	OUTBUF	LOGCHN,1
	MOVEM	E,.JBFF		;RESTORE .JBFF FOR LATER
	TXO	F2,S.LIN!S.LOUT!S.LOPN	;ASSUME ALL INTO LOG FILE
	TLNE	B,FS.NOO
	TXZ	F2,S.LOUT
	TLNE	B,FS.NOI
	TXZ	F2,S.LIN
	POPJ	P,		;AND RETURN

DSPEC:	PUSHJ	P,FILSPC	;GET FILE SPEC
DSPEC1:	SKIPN	E,XFILNM+.RBNAM	;SPECIFY A NAME?
	MOVE	E,['TECO  ']
	MOVEM	E,XFILNM+.RBNAM
	SKIPN	E,FILDEV	;HE SPECIFY A DEVICE
	MOVSI	E,'DSK'		;ASSUME DSK
	MOVEM	E,LOGOPN+1	;SAVE IN OPEN BLOCK
	MOVEM	E,FILDEV	;FIX IN CASE ERROR
	MOVEM	E,SPCDEV
	PUSHJ	P,PPNSET	;SET UP DEFAULT DIRECTORY IF NECESSARY
	POPJ	P,

ERRILD:	RELEAS	LOGCHN,
	..ERROR	E.ILD
SUBTTL E COMMANDS -- EE (SAVE TECO'S STATE)

EECMD:	MOVEM	17,SAVEAC+17	;PRESERVE 17
	MOVEI	17,SAVEAC	;TO SAVE ALL AC'S
	BLT	17,SAVEAC+16	;SAVE THEM
	MOVE	17,SAVEAC+17	;RESTORE AC 17
	MOVX	E,S.LIN!S.LOUT!S.OLOG!S.LOPN	;CLEAR LOG FILE I-O FLAGS
	ANDCAM	E,SAVEAC+F2	;RESAVE FLAG
	MOVX	E,F.OOPN!F.IOPN!F.UBAK	;NO FILES OPEN
	ANDCAM	E,SAVEAC+FF	;SAVE IN LOW SEG
	PUSHJ	P,DSPEC		;DEFAULT
	SKIPN	E,XFILNM+.RBEXT	;SPECIFY AN EXT?
	MOVSI	E,'SAV'		;DEFAULT
	MOVEM	E,XFILNM+.RBEXT	;SAVE IT
	MOVSI	E,OSAV		;FOR OUTPUT
	MOVEM	E,LOGOPN+.OPBUF	;SAVE IT
	MOVE	E,LOGOPN+.OPDEV	;GET DEVICE WE WILL OPEN
	DEVCHR	E,		;WHAT IS IT
	JUMPE	E,ERRNXD	;DOESN'T EXIST
	TXNE	E,DV.OUT	;OUTPUT DEVICE MUST BE CAPABLE OF OUTPUT
	TXNN	E,DV.M13	;IN IMAGE BINARY
	..ERROR	E.ILD
	MOVEI	E,.IOIBN	;IB FOR SAVE FILE
	MOVEM	E,LOGOPN+.OPMOD	;SAVE IT
	OPEN	SAVCHN,LOGOPN	;OPEN IT
	..ERROR	E.ODV
	MOVE	E,[GETBLK,,STARTL]
	BLT	E,STARTL+12	;MAKE LITTLE PROGRAM IN LOW SEG
	HRROI	E,.GTNAM	;GET FILE NAME OF THIS TECO
	GETTAB	E,
	 SKIPA
	  MOVEM	E,STARTL+1
	HRROI	E,.GTFPN	;GET FILE DIR OF THIS TECO
	GETTAB	E,
	 SKIPA
	  MOVEM	E,STARTL+4
	ENTER	SAVCHN,XFILNM	;ENTER THE OUTPUT FILE
	EE1+..ERROR E.ENT	;ERROR
	MOVEI	E,EEFL		;SAVE FILE SPEC
	PUSHJ	P,SPCSAV
	PUSH	P,.JBSA		;SAVE FOR LATER RESTORE
	PUSH	P,.JBCOR	;...
	MOVEI	E,STARTL+6	;WHERE TO START
	HRRM	E,.JBSA		;FIX JOBSA
	MOVE	E,.JBFF		;GET .JBFF NOW
	HRLM	E,.JBSA
	HRLM	E,.JBCOR	;SO SUBSEQUENT SAV-GET PAIRS WORK
	HRRZ	A,.JBREL	;THIS IS OUR SIZE
	HRRM	A,.JBCOR	;FIX ILL MEM REF PROB FOR EE
	OUTBUF	SAVCHN,1	;1 OUTPUT BUFFER
	MOVEM	E,.JBFF		;SO WE NOT SAVE IT
	MOVEI	A,.JBPFI+1	;START SAVE AT 115
SAVTOP:	SKIPN	(A)		;ZERO?
	JSP	E,MORE		;MORE TO GO?
	CAML	A,.JBFF		;STOP?
	JRST	SAVSTP		;RIGHT!
	MOVE	B,A		;SAVE FIRST NON ZERO WORD
	SKIPE	(A)		;ZERO?
	JSP	E,MORE		;NO, SEE IF MORE
	SUBM	B,A		;NEG NO OF WORDS
	MOVSS	A		;FORM IOWD
	HRRI	A,-1(B)		;FORMED
	PUSHJ	P,SAVOUT	;SEND TO FILE
	MOVE	E,A		;GET IOWD
	MOVE	A,1(E)		;GET WORD
	PUSHJ	P,SAVOUT	;SEND TO FILE
	AOBJN	E,.-2		;LOOP FOR THIS GROUP
	HRRZI	A,1(E)		;NEXT WORD
	CAMGE	A,.JBFF		;DONE?
	JRST	SAVTOP		;NO, LOOP
SAVSTP:	MOVE	A,[JRST	STARTL+6]	;SO CORRECT THING HAPPENS
	PUSHJ	P,SAVOUT	;OUTPUT IT
	RENAME	SAVCHN,EEFL	;FINAL RENAME FOR PROTECTION
	  JFCL			;"IMPOSSIBLE ERROR"
	RELEAS	SAVCHN,		;CLOSE AND RELEASE CHANNEL FOR SAVE FILE
	POP	P,.JBCOR
	POP	P,.JBSA
	POPJ	P,		;DONE

SAVOUT:	SOSGE	OSAV+.BFCNT	;ROOM THIS BUFFER
	JRST	OUTSAV		;NO, DUMP AND COME BACK
	IDPB	A,OSAV+.BFPTR	;STICK WORD
	POPJ	P,		;RETURN
OUTSAV:	OUT	SAVCHN,		;DUMP BUFFER
	JRST	SAVOUT		;GO BACK
	GETSTS	SAVCHN,B	;ERROR STATUS
	POP	P,.JBCOR
	POP	P,.JBSA
	EE2+..ERROR E.OUT

MORE:	CAML	A,.JBFF		;MORE?
	JRST	(E)		;NO
	AOJA	A,-2(E)		;NO RETURN .-2
SUBTTL E COMMANDS -- NEL & EE (LOW CORE)

GETBLK:	('DSK')
	'TECO  '
REPEAT	4,<0>
	MOVEI	E,STARTL
	GETSEG	E,
	HALT
	MOVEI	E,%TECOV	;TO MAKE SURE HI AND LOW SEG AGREE
	JRST	400010

;ROUTINE TO CHANGE LOG FILE OUTPUT PARAMETERS

CHANGL:	PUSHJ	P,SKRCH		;GET ANOTHER CHARACTER
	 ..ERROR E.NAL
	CAIE	CH,.CHESC	;MUST HAVE ALTMODE AFTER NEL
	..ERROR	E.NAL
	TXNN	F2,S.LOPN	;HAVE A LOG FILE OPEN?
	..ERROR	E.NLF
	TXZ	F2,S.LIN!S.LOUT	;ELSE CLEAR ALL
	TRNE	B,1		;OUTPUT?
	TXO	F2,S.LOUT	;YES
	TRNE	B,2		;INPUT?
	TXO	F2,S.LIN	;YES
	JUMPGE	B,CPOPJ		;UNLESS B WAS NEGATIVE,
	RENAME	LOGCHN,LOGFL	;RENAME FOR PROTECTION
 	  JFCL			;CANT HAPPEN
	RELEAS	LOGCHN,		;IN WHICH CASE JUST CLOSE THE FILE
	TXZ	F2,S.LIN!S.LOUT!S.LOPN!S.OLOG	;AND ZERO THE FLAGS
	POPJ	P,		;OK, NOW DO THAT
SUBTTL E COMMANDS -- EE (RESTART CODE)

RST:	CAIN	E,%TECOV	;WILL THIS WORK
	JRST	RST1		;YES
	OUTSTR	[ASCIZ	.?TECWVT Wrong version of TECO GETSEG'd
.]
	EXIT
RST1:	MOVEI	E,REE		;RESET REN ADR
	MOVEM	E,.JBREN	;SAVE
	MOVE	E,[PUSHJ P,UUOH]	;FIX .JB41
	MOVEM	E,.JB41		;...
	MOVSI	17,SAVEAC	;TO RESTORE AC'S
	BLT	17,17		;DO IT
	PUSHJ	P,TTOPEN	;REOPEN TTY
	PUSHJ	P,SETUP		;RESET ALL DEFAULTS
	POP	P,E		;THROW OUT WHERE YOU CAME FROM
	MOVEI	A,TECO		;START ADR
	HRRM	A,.JBSA		;SAVE IT
	JRST	RET		;CONTINUE


;EDIT CORE (IE GARBAGE COLLECT AND SMALLIFY)

ECORE:	MOVEI	E,CORER		;WHERE GC WILL RETURN
	MOVEM	E,GCRET
	SETOM	GCFLG		;GARBAGE COLLECT!
	MOVEM	F2,SAVEAC	;PRESERVE FLAGS
	MOVEM	PF,AC2+PF-2	;PUT PF WHERE GC EXPECTS IT
	PUSH	P,.JBREL	;SAVE SIZE NOW IN CASE NO CHANGE
	JRST	GC		;DO IT
CORER:	HRRZ	A,.JBCOR	;DON'T GET SMALLER THAN THIS
	MOVE	F2,SAVEAC	;RESTORE FLAGS
	MOVE	B,Z		;CHARACTER ADR OF LAST CHARACTER
	IDIVI	B,5		;WORD ADR
	AOJ	B,		;YES
	CAMGE	B,A		;WELL?
	MOVE	B,A		;ELSE FORCE MIN TO (A)
	CORE	B,		;DO IT
	JFCL
	MOVE	A,.JBREL
	MOVEM	A,.JBFF
	PUSHJ	P,CRE23		;RECOMPUTE SIZE OF TEXT BUFFER
	POP	P,A		;GET OLD .JBREL BACK
	CAMN	A,.JBREL	;DIFFERENT?
	POPJ	P,		;NO, NO MESSAGE
	TXO	FF,F.INIT	;FAKE OUT CORE ROUTINE
	JRST	CORES		;SAY SIZE AND CONTINUE
SUBTTL E COMMANDS -- EI & EP (EDIT INSERT & EDIT PUT)

EICMD:	TXZ	FF,F.COLN	;IGNORE : ON EI
	TXOA	F2,S.DOIT	;NOTE TO DO MI WHEN DONE READING
EPCMD:	TXZ	F2,S.DOIT	;JUST READ IT INTO THE Q REG *
	PUSHJ	P,FILSPC	;GET FILE SPEC
	MOVEI	A,24		;EI DEFAULT
	PUSHJ	P,EIDFSP	;SET THEM UP
	TXNE	F2,S.DOIT	;DO IT?
	SKIPE	FILPPN		;ANY PPN ?
	 JRST	.+4		;YES
;	MOVSI	E,'TED'		;GET THE DEFAULT DEVICE
	MOVSI	E,'DSK'		;; [UNH] USE DSK: AS DEVICE
	SKIPN	FILDEV		;ANY DEVICE SPECIFIED ?
	MOVEM	E,FILDEV	;AND SAVE
	SKIPN	E,XFILNM+.RBEXT	;SPECIFY EXT?
	MOVSI	E,'TEC'		;'TEC' IS DEFAULT FOR EI-EP
	TXOA	F2,S.INFO	;TELL USER OF ANY CORE CHANGE WHEN THRU
INIFIL:	TXZ	F2,S.INFO	;NEVER DO THIS!
	MOVEM	E,XFILNM+.RBEXT	;SAVE IT
	PUSHJ	P,DSPEC1	;DEFAULT DEVICE ETC
	MOVE	E,USRPPN	;GET LOGGED IN PPN
	TXNN	F2,S.INFO	;IF .INI USE LOGGED IN PPN
	MOVEM	E,XFILNM+1	;SAVE
	TXO	FF,F.INIT	;INIT FILE READ IN PROGRESS
	SETZM	LOGOPN+.OPMOD	;ASCII MODE
	MOVEI	E,IINI		;INPUT BUFFER HEADER
	MOVEM	E,LOGOPN+.OPBUF	;SAVE IT
	MOVE	E,LOGOPN+.OPDEV	;DEVICE
	DEVCHR	E,		;CHARACTERISTICS=?
	JUMPE	E,ERRNXD	;NO SUCH DEVICE
	TXNE	E,DV.IN		;INPUT DEVICE SHOULD BE CAPABLE OF INPUT
	TXNN	E,DV.M0		;IN ASCII MODE
	..ERROR	E.ILD
	OPEN	INICHN,LOGOPN	;OPEN DEVICE
	..ERROR	E.IDV
	LOOKUP	INICHN,XFILNM	;LOOK FOR FILE
	JRST	LOOKIN		;INI LOOKUP FAILED OK?
INIFI0:	PUSH	P,.JBREL	;SAVE FOR LATER
	MOVE	E,Z		;END OF TEXT BUFFER
	SUB	E,BEG		;#CHARS IN IT
	MOVEM	E,SAVEAC	;REMEMBER IT FOR LATER CLEAN UP
	MOVE	TT,Z		;WHERE TO PUT BUFFER
	IDIVI	TT,5		;IN WORD ADR
	ADDI	TT,2		;ASSUME LEFT OVER + 1
	MOVEM	TT,.JBFF	;FIX IT
	INBUF	INICHN,1	;1 INPUT BUFFER
	MOVE	OU,.JBFF	;WHERE WE WILL PUT THIS
	IMULI	OU,5		;ADR AS A NUMBER OF CHARACTERS
	MOVEM	OU,SAVEAC+1	;SAVE FOR LATER TRANSFER
	PUSH	P,17		;PRESERVE 17
	SETZM	17		;CLEAR FOR 1 K EXPAND
INILP:	SOSGE	IINI+.BFCNT	;MORE TO READ?
	JRST	[IN	INICHN,	;NO, READ SOME
		 JRST	INILP	;AND CONTINUE
		 GETSTS	INICHN,B	;GET ERROR BITS
		 TRNN	B,IO.ERR	;ERROR?
		 JRST	INIDON	;NO
		 JRST	EE2ERR]	;SAY INPUT ERROR
	ILDB	CH,IINI+.BFPTR	;GET CHARACTER
	JUMPE	CH,INILP	;IGNORE IT
IFN	FTSWTCH,<
	SKIPN	SW.INI		; ARE WE SUPPOSED TO BE READING SWITCH.INI
	JRST	INILP0		; NO, SO CONTINUE
	CAIN	CH,"/"		;A SLASH ??
	MOVEI	CH,.CHESC	; MAKE IT AN ALTMODE
	CAIE	CH,.CHCRT	; DO WE HAVE A <CR> ?
	 JRST	INILP0		; NO, CONTINUE
	SETZM	SW.INI		; MAKE SURE TO UN-SET FLAG
	SETZM	INI.SW		; DO NOT TRY TO READ IT AGAIN
	OUTSTR	[BYTE(7) .CHCRT,.CHLFD,.CHNUL]
	JRST	INIDON		; AND GO FINISH
	>
INILP0:	PUSHJ	P,CHKPUT	;PUT IT IN CORE SOMEWHERE
	JRST	INILP		;AND CONTINUE

CHKPUT:	CAML	OU,MEMSIZ	;FIT?
	PUSHJ	P,GRABKQ	;GET A K
	PUSHJ	P,PUT		;STICK IT IN TEXT BUFFER
	AOJA	OU,CPOPJ	;DO REST OF IT
INIDON:	RELEAS	INICHN,		;WE ARE DONE
	TXNE	F2,S.INFO	;IF THIS OFF, INI FILE
	JRST	SAVSIZ		;SAV SIZE
	MOVEI	CH,.CHESC	;TECO'S ALTMODE
	PUSHJ	P,CHKPUT
	PUSHJ	P,CHKPUT
SAVSIZ:	POP	P,17		;RESTORE 17
	MOVEM	OU,Z		;SAVE ALL THAT STUFF
	MOVE	C,SAVEAC+1	;START OF IT
	MOVE	B,Z		;END OF IT
	PUSHJ	P,COPYEI	;COPY INTO * Q-REG
	MOVE	B,BEG		;WHERE IT ALL STARTS
	ADD	B,SAVEAC	;+ LENGTH
	MOVEM	B,Z		;WHERE IT ENDS
	IDIVI	B,5		;FOR NEW .JBFF
	ADDI	B,2		;ASSUME LEFT OVER +1
	IORI	B,1777		;MAKE LIKE A JOBREL
	SOJ	B,		;SAFE
	MOVEM	B,.JBFF		;SAVE
	PUSHJ	P,CRE23		;YOU KNOW BY NOW!!
;THIS POP HAS TO BE DONE BEFORE THIS!  COPYEI MIGHT DO A GC!
;	POP	P,17		;RESTORE 17
	POP	P,E		;RESTORE OLD JOBREL
	CAMGE	B,E		;E<B?
	MOVE	B,E
	MOVE	A,B		;SAVE FOR LATER
	CORE	B,		;SMALLIFY YOURSELF
	  JFCL			;JUST BEING NICE!
	TXNN	F2,S.INFO	;HE WISH TO KNO?
	JRST	NOKNOW		;NO
	CAME	A,E		;SAME?
	PUSHJ	P,CORES		;NO, SAY SIZE
;FOLLOWING REMOVED TO ALLOW INITIAL ARG IN MACRO
;	TXNN	FF,F.COLN	;IF F.COLN IS ONE WANT PROCESSING
;	HRRZS	DLIM		;DON'T WANT DOUBLE ARG PROCESSING
	MOVE	B,NUM		;GET ARG
	MOVEM	B,SYL		;AND FAKE FOR DOUBLE ARG PROCESSING
NOKNOW:	TXZ	FF,F.INIT	;CLEAR SO AS TO NOT SCREW UP GRABK
	TXZN	F2,S.DOIT	;DO IT?
	POPJ	P,		;RETURN
	MOVEI	CH,STAR		;VALUE OF Q-REG *
	POP	P,E		;THROW AWAY HOW YOU GOT HERE
	PUSHJ	P,QTEXEI	;INITIALIZE Q-REG ACCESS
	JRST	MAC1		;DO IT
SUBTTL E COMMANDS -- EX & EXIT ROUTINES

FINIS1:	SETSTS	TTY,0		;RETURN TO NORMAL TTY MODE
	OUTPUT	TTY,0		;DUMMY OUTPUT TO LET SCNSER IN ON THE NEW MODE
	TXO	FF,F.NSRH	;NO FREE FORM FEEDS
	TXNE	FF,F.SEQ	;SEQUENCED FILE?
	JRST	IDIOT		;GARBAGE IT UP SOMEHOW
	MOVE	E,BEG		;GET BEGIN OF BUF
	CAME	E,Z		;IF = TO END SKIP PUNCH
	PUSHJ	P,PUNCHR	;PUNCH OUT THE CURRENT BUFFER
	TXO	FF,F.SQIN	;FIX BEGINNING OF BUFFER FOR FS.GEN
	TXNE	FF,F.IOPN	;DON'T INPUT IF NO FILE
FINIS2:	PUSHJ	P,@INCH		;READ A CHARACTER FROM THE INPUT FILE
	JRST	CLOSEF		;NONE LEFT, RENAME FILES ETC.
	TXNN	FF,F.OOPN	;CAN WRITE?
	ERROR	E.NFO
	PUSHJ	P,@OUTCH	;WRITE CHARACTER OUT
	SKIPN	XCTING		;HE TYPE ^C REE?
	PUSHJ	P,CKEOL		;CAN'T STOP UNLESS EOL
	JRST	FINIS2		;DO THEM ALL!
	JRST	YANK1		;GET A BUFFERFUL

FINISH:	PUSHJ	P,FINIS1	;FINISH UP.

;^Z -- RETURN TO THE MONITOR (SAME AS THE OLD ^G)

DECDMP:	RELEAS	TTY,0
	RELEAS	INCHN,0
	TXNE	F2,S.LOPN	;IF WE HAVE A LOG FILE,
	RENAME	LOGCHN,LOGFL	;DO A RENAME FOR PROTECTION
	  JFCL			;CANT HAPPEN
	RELEASE	LOGCHN,
	TXNE	FF,F.UBAK!F.OOPN	;IF WE HAVE AN OUTPUT FILE
	RENAME 	OUTCHN,OUTFIL		;DO THE SAME
	  JFCL
	RELEAS	OUTCHN,0
	TXZ	FF,F.IOPN+F.OOPN+F.EOFI+F.UBAK	;IN CASE OF A CONTINUE
	TXZ	F2,S.LIN!S.LOUT!S.LOPN
	RESET
	SKIPE	RUNIT+1		;TO RUN SOMETHING
	JRST	[MOVEI	A,RUNIT	;YES
		 HLL	A,RUNIT+5	;MAYBE STARTING ADR INCREMENT
		 RUN	A,
		 HALT]
	MONRT.
	MOVX	E,AP.REN!AP.POV	;RE-ENABLE FOR PDL OV'S
	APRENB	E,
	JRST	GO		;IF HE CONTINUES

IFN CCL,<
CCLFIN:	PUSHJ	P,FINIS1	;FINISH FILE IO
IFN NORUNS,<
	SKIPGE	MONITR		;CHECK FOR 4 SERIES MONITOR
	JRST	NORUN		;3 SERIES - SIMULATE RUN UUO
	>
	MOVEI	A,CCLBLK	;RUN COMPIL
	HRLI	A,1		;AT START ADR PLUS ONE
	RUN	A,		;RUN UUO
	JRST	DECDMP		;JUST EXIT IF NO RUN.

CCLBLK:	SIXBIT	/SYS/
	SIXBIT	/RPG/		;RUN SYS:RPG
	REPEAT	4,<0>
	>


IFN	FTEAGAIN,<

EAGAIN:	PUSHJ	P,FINIS1	; FINISH ALL I/O
	SETOM	CCLSW		; FAKE CCL ENTRY
	PUSHJ	P,TTOPEN	; FAKE TTY OPEN SO THAT WE DO NOT GET
	JRST	GO		; ADDRESS CHECKS, THEN GO....
>
SUBTTL E COMMANDS -- ED (RUN UUO ON EXIT)

IFN NORUNS,<
IFN CCL,<
NORUN:	MOVE	1,[SIXBIT /COMPIL/]
	MOVSI	2,SAVEXT	;SIXBIT FOR SAV OR DMP
	SETZB	3,4
	INIT	CCLCHN,.IODMP
	SIXBIT	/SYS/
	0
	EXIT
	LOOKUP	CCLCHN,1
	EXIT
	CALL	1,[SIXBIT /SETNAM/]
	HLRO	15,4
	HRLM	15,NORUN1
	MOVNS	15
	MOVEI	16,73(15)
	ADDI	15,INHERE
	TXO	15,1777
	MOVSI	NORTOP,NORAC
	BLT	NORTOP,NORTOP
	HRR	NORBLT,16
	JRST	NORUN2
	>>


;ROUTINE TO SET UP FOR RUN UUO ON EXIT

RUNFX:	HRLZM	B,RUNIT+5	;SAVE STARTING ADR INCREMENT
	PUSHJ	P,FILSPC	;WHAT WE WILL RUN
	SKIPN	E,FILDEV	;HE SPECIFY A DEVICE?
	MOVSI	E,'SYS'		;DEFAULT TO 'SYS'
	MOVEM	E,RUNIT		;PUT IT IN THE BLOCK
	MOVE	A,[XFILNM+.RBNAM,,RUNIT+1]
	BLT	A,RUNIT+4	;SAVE FILE SPEC
	MOVE	A,[FILPTH,,RUNIT+6]
	BLT	A,RUNIT+17	;SAVE PATH
	POPJ	P,		;DONE

IDIOT:	MOVSI	E,1
	PUSHJ	P,PUN1
	JRST	CLOSEF
SUBTTL E COMMANDS -- ET, EO & EU

;ET COMMAND

TYOCTL:	POP	P,CH		;CLR RET. ADDR. FROM PDL
	TXNE	FF,F.ARG	;ARGUMENT?
	JRST	TYOCT1		;YES.
	TXNE	FF,F.TCTL	;NO, FLAG ON?
	JRST	FFOK		;YES, RETURN -1
	JRST	BEGIN		;NO, RETURN 0

TYOCT1:	TXZ	FF,F.TCTL	;CLEAR ET FLAG
	JUMPE	B,RET		;ARGUMENT NON-ZERO?
	TXO	FF,F.TCTL	;YES. SET ET FLAG
	JRST	RET		;RETURN

;EO COMMAND

OLDMOD:	POP	P,CH		;CLR RET. ADDR. FROM PDL
	TXNE	FF,F.ARG	;ARGUMENT?
	JRST	OLD1		;YES, SET FLAG
	MOVE	A,EOFLAG	;NO, RETURN VALUE OF EOFLAG
	JRST	VALRET

OLD1:	CAIG	B,0		;N <= 0?
	MOVEI	B,EOVAL		;YES, SET TO STANDARD
	CAILE	B,EOVAL		;N > STANDARD FOR THIS VERSION?
	ERROR	E.EOA
	MOVEM	B,EOFLAG	;SET EOFLAG
	JRST	RET

;EU COMMAND

TYCASE:	POP	P,CH		;CLR RET. ADDR. FROM PDL
	TXNE	FF,F.ARG	;ARGUMENT?
	JRST	TYCAS1		;YES
	MOVE	A,TYCASF	;NO, RETURN VALUE OF TYPE-OUT CASE FLAG
	JRST	VALRET

TYCAS1:	MOVEM	B,TYCASF	;SET TYPE-OUT CASE FLAG
	JRST	RET
SUBTTL E COMMANDS -- ES

AUTOTY:	POP	P,CH		;CLR RET ADDR FROM PDL
	TXNE	FF,F.ARG	;ARG?
	JRST	AUTOT1		;YES
	MOVE	A,AUTOF		;NO, RETURN VALUE OF FLAG
	JRST	VALRET

AUTOT1:	MOVEI	A,.CHLFD	;USE LF FOR FLAG IF ARG = 1 TO 37
	CAIL	B,1
	CAILE	B,37
	MOVE	A,B		;OTHERWISE USE WHAT HE GAVE
	MOVEM	A,AUTOF		;SET NEW VALUE IN FLAG
	JRST	RET


SUBTTL E COMMANDS -- EH (CHANGE ERROR MESSAGE LEVEL)

ERRSET:	POP	P,CH		;YOU GOT HERE BY PUSHJ DUMMY!!
	TXNE	FF,F.ARG	;ARG SEEN?
	JRST	ERRSE1		;YES, RESET INDICATOR
	HLLZ	B,ERRLEN	;NO, RETURN CURRENT VALUE OF FLAG
	MOVSI	E,-3		;NUMBER OF POSSIBILITIES
	TDNE	B,JWTABL(E)	;BIT ON?
	MOVEI	A,1(E)
	AOBJN	E,.-2		;NO, LOOP
	JRST	VALRET

JWTABL:	XWD	JW.WPR_-22,JW.WPR_-22
	XWD	JW.WFL_-22,<JW.WPR!JW.WFL>_-22
	XWD	JW.WCN_-22,<JW.WPR!JW.WFL!JW.WCN>_-22

ERRSE1:	CAILE	B,3		;3 IS HIEST
	MOVEI	B,3		;FORCE IT DOWN IF GREATER
	MOVE	A,PRMERR	;ASSUME DEFAULT
	SKIPLE	B		;OK ASSUMPTION?
	HRLZ	A,JWTABL-1(B)	;NO
	MOVEM	A,ERRLEN	;2 BECOMES 0  = MEDIUM
	JRST	RET		;3 BECOMES +1 = LONG
SUBTTL E COMMANDS -- EV (SET TERMINAL CHARACTERISTICS)

VIDEO:
IFE CRT,<..ERROR  E.CRT>
IFN CRT,<
	POP	P,CH		;GET RID OF RETURN ADR
	TXNE	FF,F.ARG	;ARG SEEN?
	JRST	VIDCHG		;YES, GO POKE
	SETZ	E,		;INIT SIXBIT NAME
	MOVE	OU,[POINT 6,E]	;INIT POINTER
	MOVSI	I,770000	;INIT MASK FOR PARTIAL NAME
VID1:	PUSHJ	P,SKRCH		;GET NEXT CHARACTER
	..ERROR	E.UTV		;NO MORE
	CAIN 	CH,.CHESC	;ALTMODE?
	JRST	VID2		;YES
	PUSHJ	P,CKSYM		;LEGAL CHARACTER?
	SKIPA			;YES
	..ERROR	E.ICV		;NO
	MOVE	CH,B		;PUT CHARACTER BACK IN CH
	PUSHJ	P,PAKSIX	;PACK THE CHARACTER
	JRST	VID1		;LOOP

VID2:	MOVEM	E,SWITHL	;SAVE IN CASE ITS BAD
	SETZM	SWINDX		;NO MATCH YET
	MOVSI	T,-NUMCRT	;SET UP INDEX POINTER
VID3:	CAMN	E,CRTTAB(T)	;EXACT MATCH?
	JRST	VID5		;YES
	MOVE	OU,CRTTAB(T)	;GET IT
	AND	OU,I		;AND MASK IT
	CAME	OU,E		;HOW ABOUT NOW?
	JRST	VID4		;NOPE
	SKIPE	SWINDX		;GOT IT--IS THIS THE FIRST?
	..ERROR	E.ABT		;NOPE-AMBIGUOUS NAME
	MOVEM	T,SWINDX	;STORE IT
VID4:	AOBJN	T,VID3		;GO TRY THE NEXT
	SKIPN	T,SWINDX	;DID WE GET ONE?
	..ERROR	E.UTT		;UNKNOWN

VID5:	HLRZ	A,CRTDSP(T)	;GET 1ST PARAMETER
	MOVEM	A,CRTTYP
	MOVEI	A,BACRUB	;NOW SET UP BLT FOR REST OF PARAMETERS
	HRL	A,CRTDSP(T)	;WITH APPROPRIATE TERMINAL
	BLT	A,CTUSEQ
	JRST	RET		;WE'RE DONE


;HERE IF EV HAD NUMERICAL ARGUMENTS.

VIDCHG:	PUSHJ	P,SKRCH		;GET ANOTHER CHARACTER
	..ERROR	E.NAV
	CAIE	CH,.CHESC	;MUST BE ALTMODE
	..ERROR	E.NAV
	TXZN	FF,F.ARG2	;ONLY ONE ARG?
	JRST	RETEV		;YES, GO RETURN THE VALUE
	SKIPLE	C
	CAILE	C,20		;MAKE SURE FIRST ARG IS BETWEEN 1 AND 16.
	..ERROR	E.VOR
	CAIE	C,20		;EQUAL TO 16?
	JRST	VDC1		;NO
	CAMN	B,[-1]		;YES, IS ARG -1?
	HRLZI	B,032120	;YES, CHANGE TO CRLF (SHIFTED 1 RIGHT)
VDC1:	CAILE	C,6		;IS THE 1ST ARG GREATER THAN 6?
	LSH	B,1		;YES, SHIFT (TECO CAN'T HANDLE BIG NEG. #S)
	MOVEM	B,CRTTYP-1(C)	;STORE VALUE
	JRST	RET

RETEV:	SKIPLE	B		;CHECK RANGE
	CAILE	B,20
	..ERROR	E.VOR
	MOVE	A,CRTTYP-1(B)	;GET VALUE
	CAILE	B,6		;NEED TO SHIFT AN ASCIZ TO MAKE IT POS?
	LSH	A,-1		;YES
	JRST	VALRET
SUBTTL	E COMMANDS -- TERMINAL CHARACTERISTICS TABLES

CRTTAB:	SIXBIT	/TTY/		;TYPES OF CRT'S
	SIXBIT	/CRT/
	SIXBIT	/BEE/
	SIXBIT	/ADM2/
	SIXBIT	/ADM3/
	SIXBIT	/DPT/
	SIXBIT	/CDC/
	SIXBIT	/H1200/
	SIXBIT	/H2000/
	SIXBIT	/VT05/
	SIXBIT	/VT52/
	SIXBIT	/DGC/
NUMCRT==.-CRTTAB

;FLAG BITS--STORED IN CRTTYP (PARAMETER 1).
.CCRT.==1		;TERMINAL IS A CRT
.CNCR.==2		;DON'T OUTPUT LONE CR TO TERMINAL
.CRUB.==4		;RUBOUT GETS TRADITIONAL TREATMENT  (FOR GENERAL "CRT")
.CWAP.==10		;TERMINAL DOESN'T WRAP AROUND ON BACKSPACE FROM LEFT MARGIN

;ADDRESSES OF TERMINAL BLOCKS
;LEFT HALF CONTAINS VALUE OF CRTTYP (PARAMETER 1)

CRTDSP:	XWD	0,VTTY		;FOR TTY, ONLY THE 0 MATTERS-REST IS GARBAGE
CRTGEN:	XWD	.CWAP.+.CRUB.+.CCRT.,VCRT	;GENERAL CRT SETTING.
	XWD	.CCRT.,VBEE
	XWD	.CCRT.,VADM2
	XWD	.CWAP.+.CCRT.,VADM3
	XWD	.CWAP.+.CCRT.,VDPT
	XWD	.CCRT.,VCDC
	XWD	.CCRT.,VHZL1
	XWD	.CCRT.,VHZL2
	XWD	.CWAP.+.CCRT.,VVT05
	XWD	.CWAP.+.CCRT.,VVT52
	XWD	.CCRT.,VDGC



VBEE:	EXP	10,0,0,4,10
	BYTE	(7) 10
	BYTE	(7) 33,103
	BYTE	(7) 40,10
	BYTE	(7) 33,101
	BYTE	(7) 33,101
	BYTE	(7) 33,101
	0
	BYTE	(7) 10
	0
	BYTE	(7) 15,33,113,15

VADM2:	EXP	10,0,1,1,1
	BYTE	(7) 10
	BYTE	(7) 14
	BYTE	(7) 40,10
	BYTE	(7) 13
	BYTE	(7) 12
	BYTE	(7) 10
	0
	BYTE	(7) 10
	0
	BYTE	(7) 15,33,124,15

VTTY:				;DUMMY ADDRESS - ALL THIS IS IGNORED
VCRT:				;GENERAL CRT SETTING = ADM3
VADM3:	EXP	10,0,0,0,0
	BYTE	(7) 10
	BYTE	(7) 40
	BYTE	(7) 40,10
	BYTE	(7) 13
	0
	0
	BYTE	(7) 13
	BYTE	(7) 10
	0
	BYTE	(7) 15,12

VDPT:	EXP	10,0,0,4,8
	BYTE	(7) 10,31
	BYTE	(7) 40
	BYTE	(7) 36		;THIS MAY BE A LOCAL MOD AT U. OF T.
	BYTE	(7) 32
	BYTE	(7) 32
	BYTE	(7) 32
	BYTE	(7) 32
	BYTE	(7) 10,31
	BYTE	(7) 31
	BYTE	(7) 15,36

VCDC:	EXP	10,0,0,4,8
	BYTE	(7) 10
	BYTE	(7) 25
	BYTE	(7) 40,10
	BYTE	(7) 32
	BYTE	(7) 32
	BYTE	(7) 32
	0
	BYTE	(7) 10,40,10,10
	0
	BYTE	(7) 15,12		;EOL SEEMS TO BE DISABLED ON A CDC (SHOULD BE ^V)

VHZL1:	EXP	10,0,0,1,1
	BYTE	(7) 10
	0
	BYTE	(7) 20,10
	BYTE	(7) 12
	0
	0
	0
	BYTE	(7) 10
	0
	BYTE	(7) 15,12

VHZL2:	EXP	10,0,0,0,0
	BYTE	(7) 10
	BYTE	(7) 40
	BYTE	(7) 40,10
	0
	0
	0
	0
	BYTE	(7) 10
	0
	BYTE	(7) 176,23,177

VVT05:	EXP	10,0,0,4,8
	BYTE	(7) 10
	BYTE	(7) 40
	BYTE	(7) 40,10
	BYTE	(7) 32
	BYTE	(7) 32
	BYTE	(7) 32
	BYTE	(7) 32
	BYTE	(7) 10
	0
	BYTE	(7) 15,36

VVT52:	EXP	0,0,0,4,10
	BYTE	(7) 10
	BYTE	(7) 33,103
	BYTE	(7) 40,10
	BYTE	(7) 33,101
	BYTE	(7) 33,101
	BYTE	(7) 33,101
	BYTE	(7) 33,101
	BYTE	(7) 10
	0
	BYTE	(7) 15,33,113,15

VDGC:	EXP	0,0,0,6,10
	BYTE	(7) 31
	BYTE	(7) 30
	BYTE	(7) 40,31
	BYTE	(7) 27
	BYTE	(7) 27
	BYTE	(7) 27
	0
	BYTE	(7) 31
	0
	BYTE	(7) 15,13
SUBTTL E COMMANDS -- EK (KILL) AND EN (RENAME)

EKILL:	MOVEI	E,OUTCHN
	RESDV.	E,		;DISCARD FILE
	CLOSE	OUTCHN,CL.RST	;DO THE BEST WE CAN
	TXZ	FF,F.UBAK+F.OOPN	;ZERO EB AND EW FLAGS
	POPJ	P,		;AND RETURN



RENAM:	TXNE	FF,F.UBAK	;EB IN PROGRESS
	..ERROR	E.EBO
	PUSHJ	P,FILSPC	;GET A FILE SPEC (IF ANY)
	SKIPE	FILDEV
	..ERROR	E.END
	TXZN	FF,F.IOPN	;ER IN PROGRESS?
	..ERROR	E.ENO
	TXNN	FF,F.FILE	;DID WE SEE ANY FILSPEC AT ALL
	JRST	RENAM1		;NO, MUST BE A DELETE
	PUSHJ	P,ERDFSP	;YES, SO FILL IN ALL MISSING PARTS
	HRRZ	E,INFILE+1	;INCLUDING DATE STUFF- <000> NEEDS THIS
	HRRM	E,XFILNM+.RBEXT
	MOVE	E,INFILE+2
	TXNE	FF,F.PROT	;WAS A FILE PROTECTION SPECIFIED?
	TLZ	E,777000	;YES, SO CLEAR OLD PROTECTION
	IORM	E,XFILNM+.RBPRV	;STORE IT
RENAM1:	RENAME	INCHN,XFILNM	;CHANGE NAME OR DELETE
	JRST	RENFLD
	RELEASE	INCHN,
	POPJ	P,		;SUCCESSFUL
RENFLD:	RELEASE	INCHN,
	EE1+..ERROR E.RNF
SUBTTL E COMMANDS -- ER (PREPARE TO READ A FILE)

OPNRD:	TXZ	FF,F.EOFI+F.IOPN	;NOT EOF & CLOSE PREVIOUS INPUT
	RELEAS	INCHN,0		;YES. RELEASE IT BEFORE OPENING NEW FILE.
	PUSHJ	P,CLREXT	;CLEAR LOOKUP BLOCK
	PUSHJ	P,FILSPC	;GET FILE SPEC
	SETZM	NFORMS		;HAVE NOT SEEN ANY FORM FEEDS YET
	SETZM	OPNRI+.OPMOD	;ASCII MODE
	PUSHJ	P,ERDFSP	;NO SO SET UP DEFAULT FILE SPEC
	SKIPN	FILPPN		;IS PPN 0?
	PUSHJ	P,PPNDEF	;YES, MAKE SURE DEFAULT IS SET
	MOVE	E,FILDEV	;INITIALIZE OPEN UUO ARGUMENTS
	MOVEM	E,OPNR1
	PUSHJ	P,DEVCHK	;GET DEVICE CHARACTERISTICS
	MOVEM	E,DEVSAV	;SAVE FOR EB
	JUMPE	E,ERRNXD	;NO SUCH DEVICE
	TXNE	E,DV.IN		;MUST BE ABLE TO INPUT
	TXNN	E,DV.M0		;IN ASCII MODE
	..ERROR	E.ILD
	MOVEI	E,IBUF
	MOVEM	E,OPNRB
	OPEN	INCHN,OPNRI	;OPEN INPUT FILE
	..ERROR	E.IDV
	PUSHJ	P,OPNIN
	HLLZS	XFILNM+.RBEXT	;CLEAR EXT RH FOR MON ERR ON DTA
	SKIPG	MONITR		;IF SERIES 3 OR 4 MONITOR, SHORT LOOKUP
	JRST	OPNRD1		;SHORT
	MOVE	E,DEVSAV	;GET DEVICE CHARACTERISTICS SPR 10-8431
	TXNE	E,DV.DTA	;IS IT A DECTAPE? SPR 10-8431
	JRST	OPNRD1		;YES, SHORT LOOKUP SPR 10-8431
	LOOKUP	INCHN,XFILNM	;EXTENDED LOOKUP
	JRST	LKUPER		;ERROR
	JRST	OPNRD2
OPNRD1:	LOOKUP	INCHN,XFILNM+.RBNAM	;SHORT LOOKUP
	JRST	LKUPER		;LOOKUP FAILURE
OPNRD2:	MOVEI	E,INFILE	;SAVE INPUT SPECS
	PUSHJ	P,SPCSAV
	TXO	FF,F.IOPN	;INPUT FILE NOW OPEN
	MOVSI	E,FS.SUP!FS.NOL	;CK SUPLSN SWITCH
	AND	E,SWITC		;GET SETTING
	MOVEM	E,INSWIT	;STORE SETTING FOR INPUT
	TXZ	FF,F.SEQ	;CLR SEQUENCE NUMBER FLAG
	IN	INCHN,		;READ A BUFFER IN
	JRST	.+3
	PUSHJ	P,ANERR		;SOME ERROR, OR JUST EOF
	JRST	OPNRD3		;IT WAS EOF-FILE EMPTY MEANS UNSEQUENCED
	MOVE	B,IBUF+.BFPTR	;GET ADR OF BUFR
	MOVE	A,1(B)		;FIRST WORD OF BUFR
	IOR	A,2(B)		;!2ND
	MOVEI	B,RI		;SLOW INPUT ROUTINE
	TLNN	E,FS.NOL	;NO LSN'S
	TRNN	A,1		;SEQF
OPNRD3:	MOVEI	B,RIQ		;USE QUICK ONE
	MOVEM	B,INCH		;SET UP INPUT ROUTINE
	CAIN	B,RI		;SLOW?
	TXO	FF,F.SEQ	;THEN MUST BE SEQUENCED FILE
	TXNN	FF,F.CCL	;ARE WE HERE FROM A .TECO COMMAND?
	POPJ	P,		;NO
	MOVE	B,SWITC		;GET I/O SWITCHES
	TLNN	B,FS.REA	;DOES HE WANT READ ONLY? (/R)
	POPJ	P,		;NOPE
	TXZ	FF,F.EBTP	;YES, NO LONGER AN EB
	POP	P,B		;GET RID OF RETURN ADDRESS
	JRST	EBAKU3		;GO STRAIGHT TO THE YANK

OPNIN:	MOVEI	T,IBUF1		;GET INPUT BUFFERS
	EXCH	T,.JBFF
	INBUF	INCHN,2
	MOVEM	T,.JBFF
	POPJ	P,
SUBTTL E COMMANDS -- FILE SPEC SETUP

ERDFSP:	TDZA	A,A
EWDFSP:	MOVEI	A,12
EIDFSP:	SKIPN	E,XFILNM+.RBNAM	;HE TYPE A NAME?
	MOVE	E,ERSPEC+1(A)	;NO, GET DEFAULT
	MOVEM	E,ERSPEC+1(A)	;SAVE IT
	MOVEM	E,XFILNM+.RBNAM
	SKIPN	E,XFILNM+.RBEXT	;HE TYPE EXT?
	MOVE	E,ERSPEC+2(A)	;NO, GET DEFAULT
	MOVEM	E,ERSPEC+2(A)	;SAVE
	MOVEM	E,XFILNM+.RBEXT
	MOVSI	B,ERSPEC+4(A)	;SET UP PPN
	HRRI	B,FILPPN
	MOVS	I,B
	SKIPE	FILPPN
	JRST	DFSP1
	TXNE	F2,S.DPPN
	HRLI	B,DEFPTH+2	;HE WANTS [-]
	PUSHJ	P,CHKERZ	;CHECK FOR ERSATZ DEVICE
	HRLI	B,SPCPPN	;IT WAS ERSATZ--GET RIGHT PPN
	BLT	B,FILPPN+5
	HRRI	B,SPCPPN	;PUT IT HERE TOO
	BLT	B,SPCPPN+5
	SKIPA			;DONT MAKE AN ERSATZ PPN THE DEFAULT
DFSP1:	BLT	I,ERSPEC+9(A)	;NOW MAKE IT THE NEW DEFAULT
	MOVE	E,FILPPN
	MOVEM	E,XFILNM+.RBSIZ	;FOR SHORT LOOKUPS AND ENTERS
	SKIPN	E,FILDEV	;HE TYPE A DEVICE?
	MOVE	E,ERSPEC(A)	;NO, GET DEFAULT
	MOVEM	E,ERSPEC(A)	;SAVE
	MOVEM	E,FILDEV
	POPJ	P,
SUBTTL E COMMANDS -- EB (EDIT BACKUP PROCESSOR)

EBAKUP:	TXNE	FF,F.UBAK	;BACKUP IN PROGRESS NOW?
	..ERROR	E.EBO
	TXO	FF,F.EBTP	;SET EB UUO FLAG
	PUSHJ	P,OPNRD		;READ THE SPECIFIED FILE
	MOVE	E,DEVSAV	;GET DEVICE CHARACTERISTICS
	TXNN	E,DV.DIR	;DEVICE MUST HAVE DIRECTORY
	..ERROR	E.EBD
	TXNE	E,DV.DTA	;SKIP IF NOT DECTAPE (E.G. DSK) SPR 10-8431
	JRST	EBAKU4		;DO SHORT LOOKUP/ENTER. SPR 10-8431
	HLLZS	XFILNM+.RBEXT	;CLEAR EXT RH
	MOVE	E,SWITC		;GET FILE SWITCHES
	TLNN	E,FS.INP	;/INPLACE EDIT?
	JRST	EBAKU0		;NO
	TXZ	FF,F.EBTP	;NO LONGER EB
	JRST	EBAKU6		;DO ER/EW
EBAKU0:	MOVEI	E,INCHN
	PUSHJ	P,CHKDEF	;CHECK TO SEE IF SAME AS DEFAULT
	JRST	EBAKU2		;NOPE-JUST DO ER-EW
	MOVE	E,FILDEV	;SAVE DEVICE NAME
	SKIPG	MONITR		;SERIES 5 MONITOR?
	JRST	EBAKU5		;NO
	MOVE	E,XFILNM+.RBSIZ	;COMPUTE # BLKS TO ASK FOR
	LSH	E,-7
	AOJ	E,
	MOVEM	E,XFILNM+.RBEST	;SAVE
	MOVE	E,XFILNM+.RBDEV	;GET PHYSICAL UNIT NAME IN-FILE IS ON
	MOVEM	E,DCLOC		;DO A DSKCHR ON IT
	MOVE	E,[5,,DCLOC]
	DSKCHR	E,
EBAKU4:	SKIPA	E,FILDEV	;ERROR, USE BEST NAME WE HAVE
	MOVE	E,DCLOC+.DCSNM	;GET NAME FOR FILESTR IN-FILE IS ON
	MOVEM	E,FILDEV	;SO WE CAN PUT NEW FILE ON SAME STR
EBAKU5:	MOVEM	E,EBDEV
	MOVE	E,XFILNM+.RBNAM	;SAVE FILENAME
	MOVEM	E,BAKNAM	;IN BACKUP STORE
	HLRZ	E,XFILNM+.RBEXT	;AND THE EXTENSION
	CAIN	E,(SIXBIT /BAK/)	;CANNOT USE EB WITH FILE EXT = "BAK"
	..ERROR	E.EBF
	HRLZM	E,BAKNAM+1
	LDB	E,[POINT 9,XFILNM+.RBPRV,8]	;SAVE PROTECTION OF INPUT FILE
	SKIPLE	MONITR		;SKIP IF 3 OR 4 SERIES MONITOR
IFN	FTFDAE,<	JRST	[	CAIGE	E,300		; CHECK
					 JRST	EBAKU7		; PROTECTIONS
					CAIGE	E,400		; THIS IS OK
					 JRST	EBAKU8		; ERROR
					CAIL	E,600		; CHECK THIS
					 JRST	EBAKU8		; ERROR
					JRST	EBAKU7	]	; IS OK>
IFE	FTFDAE,<	CAIGE	E,300		;MAY USER RENAME HIS FILE?>
	CAIL	E,500		;REJECT 3+ IN LEVEL D, 5+ IN LEVEL C
EBAKU8:	..ERROR	E.EBP
EBAKU7:	MOVEM	E,PROTEC	;SAVE INPUT FILE PROTECTION
	SKIPE	A,SPCPRO
	LDB	E,[POINT 9,A,8]
	MOVEM	E,BAKPRO	;THIS IS THE DESIRED PROT. FOR THE NEW FILE
	MOVSI	E,100000	;MEANWHILE, USE <100> FOR .TMP FILE
	MOVEM	E,SPCPRO	;SO FINAL RENAME NEVER FAILS.
	MOVE	E,TMPTEC	;GET "###TEC"
	CAME	E,XFILNM+.RBNAM	;FILNAM=###TEC?
	JRST	EBAKU1		;NO, OK
	HLRZ	A,XFILNM+.RBEXT	;ALSO EXT="TMP"?
	CAIN	A,(SIXBIT /TMP/)	;EB###TEC.TMP ILLEGAL
	..ERROR	E.EBF
EBAKU1:	MOVEM	E,XFILNM+.RBNAM
	MOVEM	E,BAKTMP	;SAVE FOR DTA RENAME
	MOVSI	E,(SIXBIT /TMP/)
	MOVEM	E,XFILNM+.RBEXT
EBAKU6:	PUSHJ	P,OPNW4		;WRITE THE TMP FILE
	PUSHJ	P,OPNW2
	TXNE	FF,F.EBTP	;UNLESS NOT BACK-UP,
	TXO	FF,F.UBAK	;SET IN PROGRESS
EBAKU3:	TXZE	FF,F.CCL	;EB OR TECO COMMAND?
	PUSHJ	P,YANK		;TECO, DO A Y ALSO
	POPJ	P,

EBAKU2:	TXZ	FF,F.EBTP	;NO LONGER AN EB
	SETZM	SPCPPN		;FAKE DEFAULT PATH
	HLLZS	XFILNM+.RBEXT	;RESTORE FILE SPECS
	MOVSI	E,(SIXBIT /DSK/)
	MOVEM	E,FILDEV	;MAKE SURE DSK AND NOT SOME ERSATZ.
	MOVEM	E,SPCDEV	;HERE TOO
	JRST	EBAKU6
SUBTTL	E COMMANDS -- I/O ERROR ROUTINES

LKUPER:	RELEAS	INCHN,0
	TXZ	FF,F.IOPN	;LET GO OF INPUT DEVICE
	EE1+..ERROR E.FNF

;TYPE OUTPUT ERROR

ENTERR:	RELEAS	OUTCHN,0
	TXZ	FF,F.OOPN+F.UBAK;LET GO OF OUTPUT DEVICE & EB FLAG
	LDB	E,[POINT 6,XFILNM+.RBEXT,35]	;ERROR CODE
	CAIE	E,2		;ERROR CODE 2?
	JRST	ENTER2		;NO
	MOVE	E,WRICHR	;GET DEVICE BITS
	TXNE	E,DV.DTA	;IF DTA ITS FULL, OTHERWISE ENTER ERROR
	..ERROR	E.FUL
ENTER2:	EE1+..ERROR E.ENT

LOOKIN:
IFN	FTSWTCH,<
	SKIPN	INI.SW		; ARE WE TRYING TO READ SWITCH.INI ?
	 JRST	LOOKI0		; NO, SO DON'T SCREW AROUND
	PUSHJ	P,DSPEC1	; SET UP DEFAULT SPECS
	MOVE	E,['SWITCH']	; FILE NAME
	MOVEM	E,XFILNM+.RBNAM	; PLACE TO STORE IT
	LOOKUP	INICHN,XFILNM	;TRY TO FIND IT
	JRST	LOOKI0		; NOPE SO LET IT DIE
	IN	INICHN,		; GET A BLOCK
	SKIPA
	POPJ	P,		; INPUT ERROR, PRETEND FILE IS NOT THERE
INI00:	MOVSI	AA,-4		; LOOP FOR 4 CHARS
	SETZ	A,
INI01:	PUSHJ	P,INI10		; GET A CHARACTER
	CAIG	CH,"@"		; ALPHABETIC ??
	JRST	INI01		; NO, GET ANOTHER
	LSH	A,7		; SHIFT IT
	ADD	A,CH		; BUILD A WORD
	SETZ	CH,
	AOBJN	AA,INI01	; LOOP
	LSH	A,^D8		; MAKE ASCIZ
	CAME	A,[ASCII!TECO!]
	JRST	INI20		; NO MATCH , FIND NEXT <CRLF>
INI02:	PUSHJ	P,INI10		; GET A CHAR
	CAIN	CH,""""			; CHECK FOR "
	 JRST	INI40		; FOUND SOME TEXT, PRINT IT
	CAIE	CH,"/"		; A SLASH YET
	JRST	INI02		; GET ANOTHER TO FIND FIRST SLASH
	SETOM	SW.INI		; SET SWITCH TO SAY THAT YOU FOUND IT
	JRST	INIFI0		; AND RETURN

INI10:	SOSGE	IINI+.BFCNT
	JRST	INI30
	ILDB	CH,IINI+.BFPTR
	POPJ	P,

INI20:	PUSHJ	P,INI10
	CAIE	CH,.CHCRT
	JRST	INI20
	PUSHJ	P,INI10		; GET <LF>
	JRST	INI00

INI30:	IN	INICHN,
	JRST	INI10
	SETZM	SW.INI
	POP	P,A
	JRST	LOOKI0

INI40:	PUSHJ	P,INI10		; GET A CHAR
	CAIN	CH,""""		; END QUOTE ?
	 JRST	INI02		; YES, LOOK FOR A /
	OUTCHR	CH		; NO, TYPE THE TEXT
	JRST	INI40		; KEEP GOING

>
LOOKI0:	RELEAS	INICHN,		;DON'T WANT CHANNEL ANYMORE
	TXZN	F2,S.INFO	;WE PUSH ANYTHING?
	POPJ	P,		;NO, DON'T WORRY
	EE1+..ERROR E.FNF
SUBTTL E COMMANDS -- EW (EDIT WRITE)

OPNWRA:	TXOA	F2,S.EA		;WE ARE GOING TO APPEND
OPNWR:	TXZ	F2,S.EA
	PUSHJ	P,OPNW1

OPNW2:	MOVE	E,WRICHR	;GET DEVCHR WORD
	TXNN	E,DV.DTA	;DECTAPE?
	SKIPG	MONITR		;OR OLD MONITOR
	JRST	SHRTLK		;SHORT LOOKUP - ENTER
	TXNN	E,DV.DSK	;A DSK?
	JRST	SHRTLK		;NO, NO NEED FOR EXTENDED LOOKUP - ENTER
	SETO	B,		;SET FOR FANCY DISK ALLOCATION
	TXNE	FF,F.EBTP	;THIS AN EB TEMP FILE ENTER?
	JRST	XENTER		;YES, CARE NOT OF SUPERCEDE
	PUSHJ	P,PPNSET	;SET UP DEFAULT, IF NECESSARY
	AOS	FILPTH+1	;NO SCANNING
	LOOKUP	OUTCHN,XFILNM	;FILE THERE?
	JRST	XENTER		;NO, JUST ENTER IT
	MOVE	B,FILPPN	;SAVE PPN
	PUSHJ	P,PPNSET	;RESET PPN
	TXNE	F2,S.EA		;APPENDING?
	JRST	XENTRE		;YES, DON'T SCREW UP PROT/DATE
	CLOSE	OUTCHN,		;NO, CLOSE FOR SUPERCEDE
XENTER:	SETZM	XFILNM+.RBPRV	;CREATION DATE NOW
	HLLZS	XFILNM+.RBEXT	;...
	MOVE 	E,SPCPRO	;NOW SET UP RIGHT PROT.
	TRNE	E,1		;IF <000>, MAKE IT <100>
	TLO	E,100000
	HLLZM	E,XFILNM+.RBPRV
XENTRE:	SETZM	XFILNM+.RBALC	;CLEAR ALLOCATION
	ENTER	OUTCHN,XFILNM	;ENTER THE FILE
	JRST	ENTERR		;???
	CAMN	B,FILPPN	;FILE IN SAME AREA?
	PUSHJ	P,SUPERC	;YES, THEN SUPERCEDING
	TXNE	F2,S.EA		;TO APPEND?
	USETI	OUTCHN,-1	;YES, TELL GOD
	SETSTS	OUTCHN,0	;CLEAR IOBKTL IF USETI ON ENTER ONLY



OPNW5:	MOVEI	T,OBUF1		;WHERE OUTPUT BUFFERS MUST BE
	EXCH	T,.JBFF		;TELL MONITOR TO PUT THEM THERE
	OUTBUF	OUTCHN,2	;TWO OF THEM
	MOVEM	T,.JBFF		;AND RESTORE JOBFF
	MOVEI	E,OUTFIL	;SAVE FILESPEC
	PUSHJ	P,SPCSAV
	MOVSI	E,FS.GEN+FS.SUP	;GET OUTPUT FS.GEN & FS.SUP SWITCHES
	AND	E,SWITC
	MOVEI	B,PPAQ		;ASSUME QUICK ROUTINE
	TLNN	E,FS.GEN	;MUST GENERATE LSN'S?
	TXNE	FF,F.SEQ	;OR SEQUENCED FILE
	MOVEI	B,PPA		;= USE SLOW ONE
;THE FOLLOWING WAS REMOVED BECAUSE THE SLOW ROUTINE ALSO TAKES CARE OF
;SUPPRESSING LSN'S!!!
;	TLNE	E,FS.SUP	;IF TO SUPPRESS LSN'S USE NO PROCESS ROUTINE
;	MOVEI	B,PPAQ		;QUICK OUTPUT
	MOVEM	B,OUTCH		;SAVE IT
	TXO	FF,F.OOPN	;OUTPUT FILE NOW OPEN
	TLNE	E,FS.GEN	;ARE BOTH SET?
	TLNN	E,FS.SUP
	JRST	.+2		;NO, OK
	..ERROR	E.COS
	MOVEM	E,OUTSWT	;STORE OUTPUT SWITCH
	MOVE	E,[<"00000">B34+1]	;INIT LSN GENERATION CTR
	MOVEM	E,LSNCTR
	POPJ	P,

DEVICL:	MOVE	E,OPNWI+.OPDEV	;DEVICE NAME
	DEVCHR	E,		;WHAT IS IT
	CAIN	E,0
ERRNXD:	..ERROR E.NXD
	TXNE	E,DV.OUT	;MUST BE CAPABLE OF OUTPUT
	TXNN	E,DV.M0		;IN ASCII MODE
	..ERROR	E.ILD
	POPJ	P,
OPNW1:	TXZE	FF,F.UBAK
	TXZA	FF,F.OOPN
	SKIPA
	CLOSE	OUTCHN,CL.RST
	PUSHJ	P,FILSPC
	PUSHJ	P,EWDFSP	;SET UP DEFAULTS
	SKIPE	E,FILDEV	;DO WE HAVE A DEVICE?
	JRST	OPNW11		;YES
	MOVE	E,ERSPEC	;NO, GET ER'S
	MOVE	T,[XWD 3,E]	;CHECK IF ITS ERSATZ
	PATH.	T,
	TRNE	E+1,40		;WELL?
	MOVSI	E,'DSK'		;IT IS ERSATZ...SO MAKE IT DSK:
OPNW11:	MOVEM	E,FILDEV	;STORE DEVICE
	MOVEM	E,SPCDEV	;HERE TOO 
	SKIPN	E,XFILNM+.RBNAM	;HAVE A NAME?
	MOVE	E,ERSPEC+1	;USE ER'S NAME IF NOT
	MOVEM	E,XFILNM+.RBNAM	;SAVE IT
	SKIPN	E,XFILNM+.RBEXT	;GET EXT?
	MOVE	E,ERSPEC+2	;NO, USE ER'S
	HLLZM	E,XFILNM+.RBEXT
	MOVSI	B,(SIXBIT /SFD/);CHECK FOR AN .SFD FILE
	CAMN 	B,XFILNM+.RBEXT
	JRST	OPNW4		;IS AN .SFD, DONT GET DEFAULT PROT.
	SKIPE	E,SPCPRO	;WAS A PROTECTION SPECIFIED?
	JRST	OPNW1A		;YES, GO MAKE IT THE DEFAULT
	TXNN	F2,S.EA		;IF WE ARE DOING AN EA,
	SKIPN	E,EWSPEC+3	;OR IF NO PREVIOUS DEFAULT
	JRST	OPNW4		;THEN DONT FIDDLE WITH ANYTHING
	MOVEM	E,SPCPRO	;MAKE DEFAULT PROT THE CURRENT PROT
OPNW1A:	MOVEM	E,EWSPEC+3	;AND THE NEW DEFAULT
	TXO	FF,F.PROT	;AND SAY WE'VE GOT ONE
;	JRST	OPNW4		;FALL

OPNW4:	TXZE	FF,F.OOPN	;CALL HERE FROM EB
	RENAME	OUTCHN,OUTFIL
	  JFCL			;CANT HAPPEN
	RELEAS	OUTCHN,0
	SETZM	OPNWI+.OPMOD
	MOVE	E,FILDEV
	MOVEM	E,OPNWD
	PUSHJ	P,DEVCHK	;GET DEVICE CHARACTERISTICS
	MOVEM	E,WRICHR
	MOVSI	E,OBF
	MOVEM	E,OPNWB
	PUSHJ	P,DEVICL	;LEGAL DEVICE?
	OPEN	OUTCHN,OPNWI
	..ERROR	E.ODV
ifn 0,<
	MOVEI	B,"A"
	MOVEI	E,OUTCHN
	DEVTYP	E,		;TYPE OF DEVICE
	JRST	OILDER
	TXNE	F2,S.EA		;EDIT APPEND (IE DSK ONLY)?
	TRNN	E,77		;.TYDSK?
	SKIPA
	JRST	OILDER
>;end ifn 0 (no devtyp uuo at tymshare)
	MOVEI	T,OBUF1
	EXCH	T,.JBFF
	OUTBUF	OUTCHN,2
	MOVEM	T,.JBFF
	POPJ	P,
OILDER:	RELEAS	OUTCHN,
	..ERROR	E.ILD

SUBTTL E COMMANDS -- EZ & EF

;GET I-O DEVICE CHARACTERISTICS IN AC E
;IF TTY, IT MUST BE AVAILABLE & NOT CONTROLLING A JOB

DEVCHK:	DEVCHR	E,		;GET CHARACTERISTICS
	TXNN	E,DV.TTY	;TTY?
	POPJ	P,		;NO
	TXNE	E,DV.AVL	;YES, AVAILABLE?
	TXNE	E,DV.TTA	;CONTROLLING A JOB (INCLUDING USER)?
	..ERROR	E.TTY
	POPJ	P,		;NO, IT'S OK

;EZ	SELECTS THE OUTPUT DEVICE, ISSUES A REWIND COMMAND TO IT,
;	ISSUES A COMMAND TO ZERO ITS DIRECTORY, AND OPENS THE FILE
;	SPECIFIED (IF ANY).

ZERDIR:	PUSHJ	P,OPNW1		;DETERMINE OUTPUT DEVICE
	UTPCLR	OUTCHN,		;CLEAR DIRECTORY OF OUTPUT DEVICE
	MTAPE	OUTCHN,1	;REWIND OUTPUT DEVICE
	JRST	OPNW2		;ENTER FILE




;EF	FINISHES OUTPUT ON THE CURRENT OUTPUT FILE WITHOUT
;	SELECTING A NEW OUTPUT FILE.

CLOSEF:	TXNN	FF,F.OOPN
	POPJ	P,
	CLOSE	OUTCHN,CL.IN
	STATZ	OUTCHN,IO.ERR
	JRST	OUTERR
	TXNE	FF,F.UBAK	;EB IN PROGRESS?
	PUSHJ	P,BAKCLS	;YES (THIS WILL SKIP RETURN)
	RENAME	OUTCHN,OUTFIL	;IF NOT EB, THEN RENAME FOR PROTECTION
	  JFCL			;CANT HAPPEN
	RELEAS	OUTCHN,0
	TXZ	FF,F.UBAK!F.OOPN	;CLEAR WRITE AND EB FLAGS
	POPJ	P,
SUBTTL E COMMANDS -- EM (MTAPE UUO'S)

EMTAPE:	TXNN	FF,F.IOPN
	ERROR	E.EMD
	MOVE	E,OPNR1		;SET UP INPUT DEVICE NAME
	MOVEM	E,FILDEV	;IN CASE OF AN ERROR
	PUSHJ	P,CHK2
	CAIGE	B,1
	ERROR	E.EMA
	MTAPE	INCHN,0(B)
	OPEN	INCHN,OPNRI	;RE-INIT BUFFERS
	ERROR	E.IEM
	PJRST	OPNIN
SUBTTL E COMMANDS -- EB (FINISH UP COMMAND)

;THIS ROUTINE IS CALLED AT EF IF AN EB WAS DONE. IT DOES
;THE WORK OF MAKING THE INPUT FILE HAVE THE EXTENSION .BAK ,
;DELETING ANY PREVIOUS FILE.BAK, AND RENAMING THE NEW OUTPUT
;FILE AS THE ORIGINAL FILE.EXT

BAKCLS:	CLOSE	INCHN,0
	MOVE	E,EBDEV		;ORIGINAL EB DEVICE
	MOVEM	E,FILDEV	;IN CASE OF AN ERROR
	TXZN	FF,F.IOPN	;INPUT OPEN?
	JRST	BKCLS4		;NO
	CAMN	E,OPNR1		;ORIGINAL SAME AS CURRENT?
	JRST	BKCLS2		;YES
BKCLS4:	MOVEM	E,OPNR1		;NO, RE-OPEN ORIGINAL
	MOVE	E,WRICHR	;GET DEVICE CHARACTERISITECS
	TXNN	E,DV.DSK	;IS IT DISK ?
	 JRST	BKCLS6		;NO - JUST DO NORMAL OPEN
	MOVX	E,UU.PHS	;YES - DO PHYS ONLY OPEN
	IORM	E,OPNRI+.OPMOD	;. . .
BKCLS6:	MOVEI	E,<E.IRN=='IRN'>	;SETUP ERROR CODE
	OPEN	INCHN,OPNRI
	JRST	BKCERR		;ERROR ROUTINE
BKCLS2:	MOVE	E,BAKNAM
	MOVEM	E,XFILNM+.RBNAM
	MOVSI	E,(SIXBIT /BAK/)
	MOVEM	E,XFILNM+.RBEXT
	SETZM	XFILNM+.RBSIZ	;LOOKUP OLD BACKUP ON DEFAULT PATH
	MOVE	B,PROTEC	;GET PROTECTION OF INPUT FILE
	TRZE	B,600		;ALWAYS ALLOW OWNER DELETION
	TRO	B,100		;IF OWNER FIELD >1 LEAVE IT AS 1
	LOOKUP	INCHN,XFILNM+.RBNAM
	JRST	BKCLS1
	LDB	B,[POINTR (XFILNM+.RBPRV,RB.PRV)]	;GET PROTECTION OF BACKUP FILE
	SETZM	XFILNM+.RBNAM
	MOVEI	E,<E.BAK=='BAK'>	;ERROR CODE IN CASE WE NEED IT
	RENAME	INCHN,XFILNM+.RBNAM
	JRST	BKCERR		;ERROR
BKCLS1:	SETZM	XFILNM+.RBSIZ	;FIND BACKUP ON DEFAULT PATH
	MOVE	E,BAKNAM
	MOVEM	E,XFILNM+.RBNAM
	HLLZ	E,BAKNAM+1
	MOVEM	E,XFILNM+.RBEXT
	MOVEI	E,<E.ILR=='ILR'>	;ERROR CODE
	LOOKUP	INCHN,XFILNM+.RBNAM
	JRST	BKCERR		;ERROR
	SKIPG	MONITR		;SERIES 5?
	JRST	BKCLS5		;NO
	MOVE	E,PROTEC	;GET PROT OF INPUT FILE
	CAIGE	E,200		;IS IT IN THE 200 RANGE?
	JRST	BKCLS5		;NO
IFE	FTFDAE,<	XORI	E,300	;YES, RENAME IT TO 100 RANGE -- >
IFN	FTFDAE,<	MOVE	B,E		; GET FILE PROT.
			TRZE	E,600		; MAKE THIS CORRECT
			 TRO	E,100		; AS IT SHOULD BE
			CAIGE	B,400		; 400 + LEVEL ?
			 JRST	BKCLS8		; NO, CONTINUE
			CAIL	B,600		; 500 - LEVEL ?
			 JRST	BKCLS8		; NO, CONTINUE
			TRZ	B,700		; MAKE THIS 400 LEVEL
			TRO	B,400		; .BAK FILE
			JRST	BKCLS7		; FINISH UP
		BKCLS8:	TRZE	B,600		; MAKE THIS 100 LEVEL
			 TRO	B,100		; .BAK FILE
BKCLS7:	>
	DPB	E,[POINTR (XFILNM+.RBPRV,RB.PRV)]	;SO WE CAN DO THE
							;  REAL RENAME TO .BAK
	SETZM	XFILNM+.RBSIZ
	MOVEI	E,<E.IRB=='IRB'>	;ERROR
	RENAME	INCHN,XFILNM+.RBNAM
	JRST	BKCERR		;ERROR
BKCLS5:	MOVSI	E,(SIXBIT /BAK/)
	HLLM	E,XFILNM+.RBEXT	;DATE75
	DPB	B,[POINTR (XFILNM+.RBPRV,RB.PRV)]	;GIVE BAK FILE SAME PROT AS OLD BAK
	SETZM	XFILNM+.RBSIZ
	MOVEI	E,<E.IRB=='IRB'>	;ERROR CODE IN CASE WE NEED IT
	RENAME	INCHN,XFILNM+.RBNAM
	JRST	BKCERR		;ERROR
	MOVE	E,DEVSAV	;GET INPUT DEVICE CHARCATERISTICS
	TXNN	E,DV.DTA	;DECTAPE?
	JRST	BKCLS3		;NO
	MOVEI	E,<E.OLR=='OLR'>	;ERROR CODE
	LOOKUP	OUTCHN,OUTFIL	;DECTAPE, <5 SERIES MONITORS NEED EXTRA LOOKUP
	JRST	BKCERR		;ERROR
	CLOSE	OUTCHN,2	;CLOSE OUTPUT FOR RENAME
BKCLS3:	MOVE	E,BAKNAM	;RENAME ###TEC.TMP TO ORIGINAL NAME
	MOVEM	E,XFILNM+.RBNAM
	HLLZ	E,BAKNAM+1
	MOVEM	E,XFILNM+.RBEXT
	MOVE	E,BAKPRO	;GET PROTECTION WE WANTED
	SETZM	XFILNM+.RBPRV
	DPB	E,[POINTR (XFILNM+.RBPRV,RB.PRV)]	;PUT IT IN
	SETZM	XFILNM+.RBSIZ
	MOVEI	E,<E.RNO=='RNO'>	;ERROR CODE
	RENAME	OUTCHN,XFILNM+.RBNAM
	JRST	BKCERR		;ERROR
	JRST	CPOPJ1		;DO A SKIP RETURN


;ERROR ROUTINE TO MAKE SURE THE .TMP FILE GETS CLOSED WITH THE CORRECT
;PROTECTION

BKCERR:	MOVE	B,BAKPRO	;GET INTENDED PROTECTION.
	DPB	B,[POINT 9,OUTFIL+2,8]	;DEPOSIT IT
	RENAME	OUTCHN,OUTFIL	;PUT IN THE RIGHT ONE
	JFCL			;TOO BAD!! WE'VE ALREADY GOT ONE ERROR ON
				;OUR HANDS! WE TRIED.
	CAIE	E,'IRN'		;UNLESS ITS THE IRN ERROR,
	TLO	E,400		;FLAG THE UUO ERROR CODE TYPE OUT
	TLO	E,001000	;FINISH BUILDING THE ERROR UUO
	XCT	E		;DO IT!

SUBTTL E COMMANDS -- EW (SUBROUTINES FOR EW)

SHRTLK:	LOOKUP	OUTCHN,XFILNM+.RBNAM	;FILE THERE?
	JRST	SHRTOK		;NO, ENTER IT
	PUSHJ	P,SUPERC	;SAY SUPERCEDING MAYBE
	TXNE	F2,S.EA		;TO APPEND IS AN ERROR
	JRST	OILDER
SHRTOK:	CLOSE	OUTCHN,		;CLOSE FOR NO UPDATING
	MOVE	A,FILPPN	;GET THE FILE PPN BACK
	MOVEM	A,XFILNM+.RBSIZ	;SAVE IT
SHRTEN:	ENTER	OUTCHN,XFILNM+.RBNAM	;AND ENTER THE FILE
	JRST	ENTERR		;TOUGH COKIES
	JRST	OPNW5		;FIX BUFFERS, SWITCHES ETC.


SUPERC:	MOVE	E,WRICHR	;GET DEVICE CHARACTERISTICS
	TXNN	FF,F.EBTP	;TEMP FILE ENTER?
	TXNN	E,DV.DIR	;MUST BE DIRECTORY DEVICE
	POPJ	P,		;ELSE DO NOTHING
	TXNE	F2,S.EA		;NO MESSAGE IF APPENDING
	POPJ	P,		;SO RETURN
	JSP	A,CONMES	;TYPE %SUPERSEDING...
	ASCIZ	.%Superseding existing file
.
	POPJ	P,

SUBTTL E COMMANDS -- MISC. ROUTINES

CLREXT:	MOVE	E,[XFILNM+1,,XFILNM+2]	;CLR EXTENDED LOOKUP ARG BLK
	SETZM	XFILNM+1
	BLT	E,SPCPRO
	MOVEI	E,16
	MOVEM	E,XFILNM
	POPJ	P,
;ROUTINE TO CHECK WHETHER THE PATH FILE WAS FOUND ON WAS THE ONE WE
;WANTED TO FIND IT ON.

CHKPTH:	MOVE	T,[SPCPPN(E)]	;WE WANT TO CHECK SPECIFIED PATH
	SKIPN	SPCPPN		;UNLESS ITS 0, IN WHICH CASE...
CHKDEF:	MOVE	T,[DEFPTH+2(E)]	;CHECK AGAINST DEFAULT PATH
	MOVEM	E,FILPTH
	MOVE	E,[11,,FILPTH]
	PATH.	E,
	JFCL				;USE THE BEST WE HAVE
	MOVSI	E,-6		;CHECK FOR INTENDED PATH
	MOVE	A,@T
	CAME	A,FILPPN(E)
	POPJ	P,		;NOT EQUAL
	AOBJN	E,.-3
	JRST	CPOPJ1		;EQUAL, SKIP RETURN

PPNSET:	SKIPN	SPCPPN		;WAS A PATH SPECIFIED?
	PUSHJ	P,CHKERZ	;NO, CHECK FOR ERSATZ DEVICE
	  JFCL
PPNSPC:	MOVE	E,[SPCPPN,,FILPTH+2]	;SET UP DIRECTORY PATH
	SKIPN	SPCPPN		;DEFAULT IF NOT SPECIFIED
PPNDEF:	MOVE	E,[DEFPTH+2,,FILPTH+2]	;ENTER HERE FOR DEFAULT PATH
	BLT	E,FILPTH+7
	SETZM	FILPTH+1	;ZERO THE SCAN SWITCH
	POPJ	P,


SPCSAV:	MOVE	A,E		;ROUTINE TO SAVE A FILESPEC
	HRLI	A,XFILNM+.RBNAM
	BLT	A,2(E)
	SETZM	3(E)
	MOVE	A,SPCPRO	;PUT CORRECT PROTECTION IN
	ROT	A,11		;POSITION IT
	TXNE	FF,F.PROT	;IF SPECIFIED
	DPB	A,[POINT 9,2(E),8]
	POPJ	P,

;ROUTINE TO CHECK FOR AN ERSATZ DEVICE

CHKERZ:	SKIPN	SPCDEV		;WAS DEVICE SPECIFIED?
	JRST	CPOPJ1		;NO, SKIP RETURN
	MOVE	E,[11,,SPCDEV]	;SET UP PATH.
	PATH.	E,
	  JRST	CPOPJ1		;PATH. FAILED, ASSUME NOT ERSATZ
	MOVE	E,SPCDEV+.PTSWT	;GET SCAN BITS
	TXNN	E,PT.IPP	;IS IT AN ERSATZ DEVICE?
	JRST	CPOPJ1		;NO, SKIP RETURN
	SETZM	SPCPPN+.PTSWT	;YES, DO THE MONITORS JOB--WE DONT WANT SFDS
	POPJ	P,		;RETURN
SUBTTL	^V, ^W, ^X COMMANDS

;^V COMMAND

LOWCAS:	TXNE	FF,F.ARG	;ARG SEEN?
	JUMPE	B,CLRCAS	;YES, IF 0 CLEAR ALL PREVAILING CASE FLAGS
	TXZ	F2,S.UCAS	;CLEAR ^W FLAG
	TXO	F2,S.LCAS	;& SET ^V FLAG
	JRST	RET

;^W COMMAND

STDCAS:	TXNE	FF,F.ARG	;ARG SEEN?
	JUMPE	B,CLRCAS	;YES, IF 0 CLEAR ALL PREVAILING CASE FLAGS
	TXZ	F2,S.LCAS	;CLEAR ^V FLAG
	TXOA	F2,S.UCAS	;& SET ^W FLAG

CLRCAS:	TXZ	F2,S.LCAS+S.UCAS	;0^V OR 0^W CLEARS BOTH FLAGS
	JRST	RET

;^X COMMAND

SETMCH:	TXNE	FF,F.ARG	;ANY ARGUMENT?
	JRST	SETMC1		;YES
	TXNE	FF,F.PMAT	;NO, FORCED EXACT MATCH FLAG ON?
	JRST	FFOK		;YES, RETURN -1
	JRST	BEGIN		;NO, RETURN 0

SETMC1:	TXZ	FF,F.PMAT	;CLR ^X FLAG
	JUMPE	B,RET		;IF ARG = 0, FLAG = 0
	TXO	FF,F.PMAT	;OTHERWISE, SET FLAG
	JRST	RET
SUBTTL	ROUTINE TO PARSE FILE DESIGNATOR

FILSPC:	HRROS	EATCH		;IF THIS COMMAND FAILS, U MUST EAT TIL ALT
	PUSHJ	P,CLREXT	;CLEAR EXTENDED ARG BLOCK
	SETZM	SWITC
	MOVNI	A,5		;INITIALIZE SFD COUNTER
	MOVEM	A,PTHCNT
	MOVEI	A,1		;INITIALIZE STATE TO 1
	PUSHJ	P,ENDPUT	;INIT PACKING WORDS
	TXZ	FF,F.FILE!F.PROT	;BUT WE HAVEN'T SEEN ANY PART OF FILESPEC YET

FILSP1:	PUSH	P,A		;SAVE OUR STATE!
	PUSHJ	P,FILCHR	;GET A CHAR
	POP	P,A		;RESTORE THE DAMN THING
	ASH	A,1		;A HAS CURRENT STATE
	CAIG	B,6		;B HAS CHAR TYPE
	JRST	FILSP2
	SUBI	B,6		;MUNG FOR OFFSET
	AOS	A
FILSP2:	IMULI	B,6
	MOVE	T,STPROC-2(A)	;GET PROCEDURE
	ROT	T,(B)
	ANDI	T,77		;T NOW HAS PROC. NUM.
	PUSHJ	P,@FILPRO-1(T)	;DO IT
	MOVE	A,STNEXT-2(A)	;GET NEXT STATE
	ROT	A,(B)
	ANDI	A,77
	CAIE	A,^D15		;IF STATE=15, WE'RE DONE
	JRST	FILSP1
	POPJ	P,

FILCHR:	PUSHJ	P,SKRCH		;GET A CHAR.
	ERROR	E.UFS
	CAIL	CH,.CHLFD	;< LF OR
	CAILE	CH,.CHCRT	;> CR
	JRST	TOUP		;OK SO FAR
	JRST	FILCHR		;IGNORE LF,FF,CR,VT
TOUP:	CAIL	CH,"A"+" "	;CONVERT LOWER CASE
	CAILE	CH,"Z"+" "
	SKIPA
	TXC	CH," "
	MOVEI	T,FILDSP	;NOW WE CLASSIFY THE CHARACTER
FILCH1:	MOVE	B,(T)
	JUMPE	B,FILCH2
	CAIE	CH,(B)
	AOJA	T,FILCH1
	HLRZS	B
	POPJ	P,
FILCH2:	PUSHJ	P,CKSYM		;IS IT A-Z, 0-9, %, $?
	SKIPA	B,[1]		;YES
	MOVEI	B,^D12		;NO, MUST BE OTHER
	CAIL	CH,"0"		;BUT MIGHT BE OCTAL
	CAILE	CH,"7"		;...
	POPJ	P,		;NOPE
	AOJA	B,CPOPJ		;YES, B=2

PAKSIX:	SUBI	CH," "		;CONVERT TO SIXBIT
	TLNE	OU,770K		;IS THERE STILL ROOM?
	IDPB	CH,OU		;YES, PACK IT
	TLNE	E,7700		;SHIFT MASK?
	ASH	I,-6		;YES
	POPJ	P,

PAKOCT:	LSH	E,3		;STANDARD NUMBER PACKING
	IORI	E,-"0"(CH)
	POPJ	P,

PUTDEV:	JUMPE	E,ENDPUT	;DONT STORE NULL DEVICE
	SKIPE	FILDEV		;ALREADY GOT ONE?
	..ERROR	E.DDV		;YEP
	MOVEM	E,FILDEV	;STORE IT
	MOVEM	E,SPCDEV	;HERE TOO
	JRST	ENDPUT

PUTFIL:	JUMPE	E,ENDPU1	;DON'T SAVE NULL FILE NAMES
	SKIPE	XFILNM+.RBNAM	;DOUBLE FILE NAME?
	..ERROR	E.DFN
	MOVEM	E,XFILNM+.RBNAM	;SAVE IT
	JRST	ENDPUT		;GO RESET PACKING


PUTEXT:	IORI	E,1		;SAID .<NULL> SO REMEMBER NOT TO DEFAULT
	SKIPE	XFILNM+.RBEXT	;DOUBLE EXT ILLEGAL
	..ERROR	E.DEX
	MOVEM	E,XFILNM+.RBEXT	;STORE IT
	JRST	ENDPUT

PUTPRO:	SKIPE	XFILNM+.RBPRV	;DOUBLE PROTECTION LOSES
	..ERROR	E.DPR
	CAILE	E,777		;IS IT A LEGAL PROTECTION
	..ERROR	E.PRO		;NOPE
	DPB	E,[POINT 9,SPCPRO,8]	;SAVE IT HERE
	SKIPE	E		;IF <000>,
	JRST	.+3
	MOVEI	E,100		;THEN MAKE IT 100, SO RENAME WORKS
	AOS	SPCPRO		;AND FLAG SPCPRO
	DPB	E,[POINT 9,XFILNM+.RBPRV,8]	;PUT IT AWAY
	TXO	FF,F.PROT	;A PROTECTION WAS SPECIFIED
	JRST	ENDPUT

PUTPRJ:	SKIPN	FILPPN		;DO WE ALREADY HAVE A DIRECTORY?
	TXNE	F2,S.DPPN	;NO, BUT MAYBE HE SPECIFIED DEFAULT
	..ERROR	E.DDR		;2 DIRECTORY SPECS LOSE
	CAIN	E,0		;IS PROJ 0?
	HLRZ	E,USRPPN	;YES, GET LOGGED-IN PROJ
	HRLZM	E,FILPPN	;STORE IT
	JRST	ENDPUT

PUTPRG:	CAIN	E,0		;IS PROG 0?
	HRRZ	E,USRPPN	;YES, GET LOGGED-IN PROG
	HRRM	E,FILPPN	;STORE IT
	MOVE	E,FILPPN
	MOVEM	E,XFILNM+.RBSIZ
	MOVEM	E,SPCPPN	;SAVE IT HERE TOO
	JRST	ENDPUT

PUTPTH:	JUMPE	E,ENDPUT	;DONT STORE NULL SFD'S
	AOSLE	T,PTHCNT	;COUNT TOTAL SFD'S
	..ERROR	E.TMS		;TOO MANY
	MOVEM	E,FILSFD+4(T)	;STORE IT
	MOVEM	E,SPCPPN+5(T)	;SAVE HERE TOO
ENDPUT:	TXO	FF,F.FILE	;WE'VE SEEN AT LEAST ONE PART OF FILESPEC
ENDPU1:	SETZ	E,		;ZERO PACKING WORD
	MOVE	OU,[POINT 6,E]	;INIT SIXBIT BYTE POINTER
	MOVSI	I,770K		;INIT SWITCH MASK
	POPJ	P,

PUTSWI:	MOVEM	E,SWITHL	;SAVE IN CASE BAD
	SETZM	SWINDX		;NO SWITCH SEEN YET
	MOVSI	T,-SWS		;NUMBER OF SWITCHES IN THE WORLD
SWLOOP:	CAMN	E,SWITAB(T)	;THIS IS IT?
	JRST	SETSWH		;YES, SET IT
	MOVE	OU,SWITAB(T)	;YES, GET SWITCH FROM TABLE
	AND	OU,I		;APPLY MASK TO SWITCH
	CAME	OU,E		;SAME?
	JRST	SWHLP		;NO, LOOP
	SKIPE	SWINDX		;ALREADY HAVE MATCH?
	..ERROR	E.ABS
	MOVEM	T,SWINDX	;ELSE SAVE INDEX AND GO ON
SWHLP:	AOBJN	T,SWLOOP	;LOOP FOR ALL (MAYBE)
	SKIPN	T,SWINDX	;HAVE SEEN A MATCH?
	..ERROR	E.UIS
SETSWH:	MOVSI	OU,400K		;LITE SIGN BIT
	MOVNS	T
	LSH	OU,(T)		;SHIFT INTO POSITION
	IORM	OU,SWITC	;AND SAVE IT
	JRST	ENDPUT

DEFDIR:	SKIPN	FILPPN		;DOUBLE DIRECTORY LOSES
	TXOE	F2,S.DPPN	;SET THE DEFAULT DIRECTORY BIT
	..ERROR	E.DDR		;EVEN DOUBLE DEFAULT LOSES-WE ARE MEAN
	JRST	ENDPUT

FILERR:	MOVE	A,STNEXT-2(A)	;IN THE CASE OF AN ERROR, "NEXT STATE"
	ROT	A,(B)		;IS REALLY THE ERROR NUMBER
	ANDI	A,77
	JRST	FILERT-1(A)	;GO TO IT

FILERT:	..ERROR	E.IFN		;ERROR DISPATCH TABLE
	..ERROR	E.DEX
	..ERROR	E.BFS
	..ERROR	E.DIR
	..ERROR	E.IOS

SUBTTL  TABLES FOR FILSPEC PARSER

;CHARACTER TYPE CLASSIFICATION TABLE

FILDSP:	^D3,,.CHESC
	^D4,," "
	^D4,,.CHTAB
	^D5,,","
	^D7,,"."
	^D8,,"/"
	^D9,,":"
	^D10,,"["
	^D11,,"]"
	^D6,,"-"
	^D10,,"<"
	^D11,,">"
	0,,0

;PROCEDURE DISPATCH TABLE

FILPRO:	EXP	PAKSIX
	EXP	PAKOCT
	EXP	PUTDEV
	EXP	PUTFIL
	EXP	PUTEXT
	EXP	PUTPRJ
	EXP	PUTPRG
	EXP	PUTPTH
	EXP	PUTSWI
	EXP	CPOPJ
	EXP	FILERR
	EXP	DEFDIR
	EXP	PUTPRO

	RADIX	10		;NOTE!!!!

;PROCEDURE TABLE

STPROC:	BYTE	(6)1,1,4,4,11,11,4,4,3,4,11,11		;STATE 1
	BYTE	(6)1,1,5,5,11,11,11,5,11,5,11,11	;STATE 2
	BYTE	(6)11,2,11,6,6,12,11,11,11,11,13,11	;STATE 3
	BYTE	(6)11,2,7,7,7,11,7,7,11,11,7,11		;STATE 4
	BYTE	(6)1,1,8,8,8,11,8,8,11,11,8,11		;STATE 5
	BYTE	(6)1,1,9,9,11,11,9,9,11,9,11,11		;STATE 6
	BYTE	(6)1,1,10,10,11,11,10,10,11,11,10,11	;STATE 7
	BYTE	(6)1,1,10,10,10,11,10,10,11,11,10,11	;STATE 8
	BYTE	(6)11,11,11,10,10,11,11,11,11,11,11,11	;STATE 9

;"NEXT STATE" TABLE

STNEXT:	BYTE	(6)1,1,15,1,1,1,2,6,1,3,1,1	;STATE 1
	BYTE	(6)2,2,15,1,1,1,2,6,3,3,1,1	;STATE 2
	BYTE	(6)1,3,3,9,4,7,3,3,3,3,1,1	;STATE 3
	BYTE	(6)4,4,15,8,5,4,2,6,4,4,1,4	;STATE 4
	BYTE	(6)5,5,15,8,5,4,2,6,4,4,1,4	;STATE 5
	BYTE	(6)6,6,15,1,1,1,2,6,3,3,1,1	;STATE 6
	BYTE	(6)1,1,15,7,4,4,2,6,3,4,1,1	;STATE 7
	BYTE	(6)1,1,15,13,5,4,2,6,3,4,1,4	;STATE 8
	BYTE	(6)4,4,4,14,4,4,4,4,4,4,4,4	;STATE 9


	RADIX	8
;FILE SELCTION COMMAND SWITCH TABLE

DEFINE	SWTCHS,<
SW APPEND	;;APPEND TO THE LOG FILE (NOT SUPERSEDE)
SW GENLSN	;;GENERATE LINE SEQUENCE NUMBER ON OUTPUT
SW INPLACE	;;.TECO <FILESPEC> DOES ER/EW TO SAME FILESPEC
SW NOIN		;;NO INPUT FROM TTY IN THE LOG FILE
SW NOLSN	;;INTELLIGENT PERSON NOT WANTING LSN'S
SW NOOUT	;;NO TTY TYPEOUT IN THE LOG FILE
SW READ		;;READ ONLY WHEN .TECO <FILESPEC>
SW SUPLSN	;;SUPPRESS LINE SEQUENCE NUMBERS ON INPUT
>
DEFINE	SW,(SWT),<
	EXP	SIXBIT	/SWT/
	FS.'SWT==<.BIT.==.BIT._-1>>
.BIT.==1B17

SWITAB:	SWTCHS		;GENERATE SWITCH TABLE
SWS==.-SWITAB
SUBTTL	Y	RENDER THE BUFFER EMPTY.  READ INTO THE BUFFER

;	UNTIL (A)  A FORM FEED CHARACTER IS READ, OR
;	(B)  THE BUFFER IS WITHIN ONE THIRD OR
;128 CHARACTERS OF CAPACITY AND A LINE FEED IS READ, OR
;	(C)  AN END OF FILE IS READ, OR
;	(D)  THE BUFFER IS COMPLETELY FULL.
;THE FORM FEED (IF PRESENT) DOES NOT ENTER THE BUFFER.

YANKER:	SKIPN	EQM		;Y ILLEGAL FROM TTY
	ERROR	E.UEY
YANK:

YANK1:	MOVE	OU,BEG
	MOVEM	OU,PT		;PT:=BEG

YANK2:	TXZ	FF,F.FORM	;RESET THE YANK,APPEND FORM FEED FLAG
	TXNN	FF,F.IOPN	;ERROR IF INPUT NOT SPECIFIED
	ERROR	E.NFI

;MAINTAIN AT LEAST A MINIMUM SIZE BUFFER OF 3000
;CHARACTERS AT ALL TIMES, WHEN TECO ASKS FOR INPUT FROM
;ANYTHING BUT THE CONSOLE.

	MOVE	C,PT		;GET .
	MOVEM	C,Z		;TELL NROOM IT'S AN EXPAND
	SUBM	OU,C		;BUT EXPAND WITH REAL Z IN MIND
	ADDI	C,^D3000	;NEED 3000 ABOVE Z
	PUSHJ	P,NROOM
YANK6:	ADD	OU,RREL		;RELOCATE IN CASE GARBAGE COLLECTION DONE
	MOVE	TT,MEMSIZ	;TOP OF BUFFER
	MOVE	CH,TT
	SUB	TT,OU
	IDIVI	TT,3
	SUBM	CH,TT
	MOVEM	TT,M23		;M23 HAS 2/3 PT
	SUBI	CH,200
	MOVEM	CH,M23PL	;M23PL HAS 200 BELOW TOP
	MOVE	TT,OU		;CHAR ADR
	IDIVI	TT,5		;TO WORD ADR
	HLL	TT,BTAB-1(TT1)	;MAKE BYTE POINTER
YANK4:	CAMGE	OU,M23		;2/3 FULL YET?
	JRST	YANK3		;NO, KEEP GOING
	CAMG	OU,M23PL	;YES, GETTING NEAR TOP?
	CAIN	CH,.CHLFD	;NO. LINE FEED?
	JRST	YANK51		;YES. THAT'S ALL.
				;NO. GET MORE.
YANK3:	PUSHJ	P,@INCH		;READ A CHARACTER
	JRST	YANK51		;NONE LEFT, CLEAR BUFFER AND RETURN.
	IDPB	CH,TT		;PUT CHARACTER IN MEMORY
	CAIE	CH,.CHFFD	;FORM FEED?
	AOJA	OU,YANK4	;NO. UPDATE DATA BUFFER PTR AND CHECK FOR OVERFLOW.
	TXO	FF,F.FORM	;YANK AND/OR APPEND TERMINATED ON A FORM FEED
YANK51:	MOVEM	OU,Z		;YES. SET END OF DATA BUFFER AND RETURN
	SKIPE	XCTING		;IF OFF STOP
	POPJ	P,
	JRST	GO		;RESTART

;A   APPEND TO THE END OF THE BUFFER FROM THE SELECTED INPUT
;	TERMINATING THE READ IN THE SAME MANNER AS Y.  THE POINTER
;	IS NOT MOVED BY A.

APPEND:	MOVE	OU,Z		;STORE DATA AT END OF BUFFER.
	PUSHJ	P,YANK2
	JRST	RET
SUBTTL	^Y ! ^P - QUICK PAGE SCAN COMMANDS

QYANK:	TXO	F2,S.YANK	;NOTE QUICK YANK
QPAGE:	TXNN	FF,F.ARG	;NO ARG MEANS RETURN # OF FF'S SEEN
	JRST	[MOVE	A,NFORMS	;# FF'S SEEN
		 JRST	VALRET]		;SAY IT UNTO THE USER
	SKIPLE	B		;ZERO IS ILLEGAL ARG
	CAMGE	B,NFORMS	;BACKWARD OR NEGATIVE ARG?
	..ERROR	E.IPA
	CAMN	B,NFORMS	;REQUEST IS FOR THIS PAGE?
	JRST	RET		;YES, GO AWAY FROM HERE MY BROTHER
	TXNE	FF,F.EOFI	;EOF?
QERR:	..ERROR	E.PTL
	PUSH	P,B		;SAVE PAGE WE WANT FOR LATER AND
	TXO	FF,F.NSRH	;NO FREE FORM FEEDS
	TXNN	F2,S.YANK	;NO OUTPUT?
	PUSHJ	P,PUNCHR	;PUNCH ANY BUFFER THERE NOW
	MOVE	B,BEG		;WHERE TEXT BUFFER STARTS
	MOVEM	B,Z		;NOTHING IN IT NOW
	MOVEM	B,PT		;PT ALSO = BEG
	POP	P,B		;GET THE ARGUMENT BACK
	SOJ	B,		;MINUS 1 SO THAT WHEN NFORMS = B
				;WE WANT THE NEXT PAGE
	TXNN	FF,F.IOPN	;SOMETHING TO READ?
	..ERROR	E.NFI
	TXNN	F2,S.YANK	;^Y REQUIRES NO OUTPUT FILE
	TXNE	FF,F.OOPN	;FILE MUST BE OPEN FOR OUTPUT HERE
	CAIA
	ERROR	E.NFO
	TXNE	FF,F.SEQ	;SEQUENCED FILE= USE STUPID ROUTINE
	JRST	STUPID
QLOOP:	CAMG	B,NFORMS	;FOUND IT YET?
	JRST	APPEND		;YES, YANK AND RETURN
	PUSHJ	P,@INCH		;READ A CHARACTER
	AOJA	B,QERR		;END OF FILE = BAD PAGE ARG
	TXNN	F2,S.YANK	;NO OUTPUT ON ^Y
	PUSHJ	P,@OUTCH	;SEND IT TO OUTPUT FILE
	SKIPN	XCTING		;HE WANT ME TO STOP?
	PUSHJ	P,CKEOL		;YES, BUT STOP ON EOL
	  JRST	QLOOP		;NOT EOL OR NOT TO STOP
	JRST	APPEND		;AND YANK A PAGE

STUPID:	MOVEM	B,SAVEAC	;SAVE B
	PUSH	P,[RET]		;WHERE TO RETURN TO
GETBAK:	CAMG	B,NFORMS	;DONE
	JRST	YANK		;YANK AND RETURN
	TXNE	FF,F.EOFI	;STUFF LEFT?
	AOJA	B,QERR		;NO
	SETZ	T,		;INSURE YANK AFTER OUTPUT
	TXNN	F2,S.YANK	;^Y =  NO OUTPUT
	PUSHJ	P,PUN1
	MOVE	B,SAVEAC
	JRST	GETBAK
SUBTTL	READ A CHARACTER FROM INPUT FILE

RI:	SOSGE	IBUF+.BFCNT	;MORE IN THE BUFFER?
	JRST	RI3		;NO, CAUSE THERE TO BE MORE
RI0:	ILDB	CH,IBUF+.BFPTR	;GET ONE
	JUMPE	CH,RI		;EAT NULLS
	CAIN	CH,.CHFFD	;FF?
	AOS	NFORMS		;NOTE IT IN CASE NEW ^P COMMAND USED
	TXZN	F2,S.SSEQ	;LAST THIS WAS A SUPPRESSED SEQUENCE #?
	JRST	RI1		;NO..
	CAIE	CH,.CHCRT	;CR (FOR SOS) OR
	CAIN	CH,.CHTAB	;<TAB> FOLLOWING IT?
	JRST	RI		;= EAT IT UP
RI1:	LDB	T,[POINT 1,@IBUF+.BFPTR,35]	;GET BIT 35 OUT OF CURRENT WORD
	JUMPE	T,CPOPJ1	;LEAVE,  A LSN
	MOVE	T,INSWIT	;SUPPRESS SEQ # FLAF ON?
	TLNN	T,FS.SUP	;?
	JRST	CPOPJ1
RI2:	MOVEI	T,4		;THINGS TO EAT
	IBP	IBUF+.BFPTR	;INCREMENT BYTE POINTER
	SOS	IBUF+.BFCNT	;DECREMENT COUNT
	SOJG	T,.-2		;A BUNCH OF TIMES
	TXO	F2,S.SSEQ	;JUST ATE A SEQUENCE NUMBER
	JRST	RI		;NEXT CHARACTER PLS

RI3:	IN	INCHN,		;GET A BUFFER
	JRST	RI		;AND CHAR TOO
ANNERR:	TXO	FF,F.EOFI	;ELSE ASSUME EOF
ANERR:	STATO	INCHN,IO.ERR	;ERROR?
	POPJ	P,		;SINGLE RETURN

INERR:	GETSTS	INCHN,B		;SAVE ERROR FLAGS
	RELEAS	INCHN,0
	TXZ	FF,F.IOPN
EE2ERR:	EE2+ERROR E.INP

RIQ:	SOSGE	IBUF+.BFCNT	;MORE THERE?
	JRST	[IN	INCHN,	;GET SOME
		 JRST	RIQ	;YANK CHAR
		 JRST	ANNERR]	;CHECK FOR ERRORS OR EOF
	ILDB	CH,IBUF+.BFPTR	;GET CHARACTER
	CAIN	CH,.CHFFD	;<FF>?
	AOS	NFORMS		;YES, COUNT IT
	JUMPN	CH,CPOPJ1	;AND RETURN
	JRST	RIQ		;ELSE LOOP
SUBTTL	INSERT COMMAND

;^ITEXT$	INSERTS AT THE CURRENT POINTER LOCATION THE ^I (TAB)
;	AND THE TEXT FOLLOWING THE ^I UP TO BUT NOT INCLUDING THE
;	ALT MODE.  THE POINTER IS PUT TO THE RIGHT OF THE INSERTED
;	MATERIAL.

TAB:	skipe	eqm		;tab is a no op inside macros
	popj	p,
	TXZ	FF,F.ARG	;NO ARGUMENT WANTED
	PUSHJ	P,TAB2		;INSERT TAB
IFN VC,<TXO	FF,F.TABS>	;ADJUST VVAL

;ITEXT$	INSERT, AT THE CURRENT POINTER LOCATION, THE TEXT FOLLOWING
;	THE I UP TO BUT NOT INCLUDING THE FIRST ALT. MODE.  THE
;	POINTER IS PUT TO THE RIGHT OF THE INSERTED MATERIAL.

INSERT:	TXNE	FF,F.ARG	;IS THERE AN ARGUMENT?
	JRST	INS1A		;YES. NI COMMAND.
	MOVEI	CH,.CHESC	;NORMAL TERMINATOR
	TXZN	FF,F.SLSL	;DID @ PRECEED I?
	JRST	INSERA		;NO, TERMINATOR = ALTMODE
	PUSHJ	P,SKRCH		;YES. CH:=USER SELECTED TERMINATOR.
	ERROR	E.UIN
INSERA:	MOVEI	B,(CH)		;B=INSERTION TERMINATOR.
	SETZM	CTGLEV		;ZERO THE ^G NEST COUNTER
	MOVEI	T,INSER0	;AND SET ^G ROUTINE RETURN POINT
	MOVEM	T,CTGRET
	PUSH	P,CPTR		;SAVE CURRENT POSITION IN CMD STRING
	PUSH	P,COMCNT
	MOVEI	C,0		;COUNT # CHARACTERS TO INSERT IN C AND
				;MOVE CPTR TO END OF STRING.
INSER0:	PUSHJ	P,SKRCH		;GET NEXT CHARACTER
	JRST	INS0A		;NO MORE CHARS AT THIS LEVEL
	SKIPN	CTGLEV		;IF WE ARE IN A ^G NEST, IGNORE TERMINATOR
	CAIE	CH,(B)		;IS IT THE TERMINATOR?
	TRNA			;NO, SKIP
	JRST	INSER2		;YES, END OF 1ST PASS
	TXO	FF,F.NNUL	;FLAG NON-NULL STRING (FOR F-SEARCH)
	CHKEO	EO21,INSER1	;IF EO=1, CTRL-CHARS ARE JUST TEXT
	MOVEI	T,IN1TAB	;CK FOR ^V, ^W, ^R, ^T, ^^
	TXNE	F2,S.NCCT	;^T FLAG ON?
	MOVEI	T,IN2TAB	;YES, USE RESTRICTED TABLE
	PUSHJ	P,DISP1
	TXNN	F2,S.NCCT	;IF ^T ON, ALL OTHER CTL-CHARS LEGAL TEXT
	PUSHJ	P,CKNCC		;CHECK FOR OTHER CTRL-CHARS (THEY ARE ILLEGAL)
INSER1:	AOJA	C,INSER0	;COUNT TEXT CHARACTERS
INSER2:	MOVEM	C,VVAL		;SAVE LENGTH OF STRING
IFN VC,<
	TXZE	FF,F.TABS	;TAB INSERTED?
	AOS	VVAL>		;YES, COUNT IT
	TXZ	F2,S.NCCT	;REFRESH ^T FLAG
	TXNE	FF,F.SRCH	;DOING FS OR FN?
	JRST	SERCHJ		;YES
	POP	P,COMCNT	;RESET TO BEGINNING OF INSERT TEXT
	POP	P,CPTR
	PUSHJ	P,NROOM		;YES. MOVE FROM PT THROUGH Z UP C POSITIONS.
;MOVE INSERTION INTO DATA BUFFER

INS1B:	MOVE	OU,PT
	SETZM	CTGLEV		;ZERO ^G NEST COUNTER
	MOVEI	T,INS1C		;AND SET RETURN POINT
	MOVEM	T,CTGRET
INS1C:	PUSHJ	P,GCH		;CH:=CHARACTER FROM COMMAND STRING.
	SKIPGE	COMCNT		;END OF COMMAND AT THIS LEVEL?
	JRST	INS0A		;YES
INS1F:	CAIN	CH,(B)		;IS IT THE TERMINATOR?
	SKIPE	CTGLEV		;YES, BUT IGNORE IT IF IN ^G NEST
	TRNA			;NO, SKIP
	POPJ	P,		;BUT WE'RE NOT, SO LEAVE
	CHKEO	EO21,INS1D	;IF EO=1, THERE ARE NO CTL-CHAR. COMMANDS
	MOVEI	T,INSTAB	;CK FOR CONTROL CHARACTERS
	TXNE	F2,S.NCCT	;^T FLAG ON?
	MOVEI	T,INTTAB	;YES, ONLY ^T AND ^R ARE SPECIAL
	PUSHJ	P,DISP1
INS1E:	PUSHJ	P,CASE		;CONVERT UC TO LC IF FLAGS WARRANT
INS1D:	PUSHJ	P,PUT		;NO. STORE CHARACTER IN DATA BUFFER TO RIGHT OF PT.
	AOS	OU,PT		;PT:=PT+1
	JRST	INS1C		;LOOP
;DISPATCH TABLE FOR INSERT STRING CONTROL CHARACTERS (COUNT PASS)

IN1TAB:	XWD	CTRGI,7		;^G
	XWD	INSER0,.CHCNV	;^V
	XWD	INSER0,.CHCNW	;^W
	XWD	INSER0,.CHCCF	;^^
IN2TAB:	XWD	INSER4,.CHCNT	;^T
	XWD	INSER3,.CHCNR	;^R
	XWD	0,0		;END OF LIST

;GET CHARACTER AFTER ^R

INSER3:	PUSHJ	P,SKRCH		;DON'T COUNT ^R & DON'T DO CHECKS ON CHAR AFTER IT
	ERROR	E.UIN
	JRST	INSER1

;CHANGE NO-CONTROL-COMMANDS FLAG

INSER4:	TXC	F2,S.NCCT
	JRST	INSER0		;DON'T COUNT ^T


;^GI CAUSES THE CONTENTS OF Q REG I TO BE INSERTED INTO THE TEXT STRING
;AT THIS POINT

CTRGI:	PUSHJ	P,SKRCH		;GET THE NAME OF THE Q-REG
	ERROR	E.ICG		;NOT THERE
	PUSH	PF,CPTR		;SAVE POINTER
	PUSH	PF,COMCNT	;AND COUNT
	PUSH	P,C		;AND LENGTH OF STRING SO FAR
	AOS	CTGLEV		;BUMP ^G NEST COUNTER
	PUSHJ	P,QREGV2	;ACCESS THE Q REGISTER
	PUSHJ	P,QTEXEI
	PUSHJ	P,GTQCNT	;LENTH OF Q REG STRING IN C
	MOVEI	A,(I)
	IDIVI	A,5		;FIX THE POINTER
	HLL	A,BTAB-1(A+1)
	MOVEM	A,CPTR		;AND STORE IT
	MOVEM	C,COMCNT	;THE NEW COUNT
	POP	P,C		;RESTORE INSERT STRING LENGTH
	JRST	@CTGRET		;RETURN

INS0A:	SKIPN	CTGLEV		;ARE WE IN A Q-REGISTER?
	ERROR	E.UIN		;NO, UNTERMINATED INSERT COMMAND
	POP	PF,COMCNT	;RESTORE COUNT
	POP	PF,CPTR		;AND POINTER
	SOS	CTGLEV		;DECREMENT NEST COUNT
	JRST	@CTGRET		;RETURN
;DISPATCH TABLE FOR INSERT STRING CONTROL CHARACTERS (INSERT PASS)

INSTAB:	XWD	CTRGI,7		;^G
	XWD	INSLOW,.CHCNV	;^V
	XWD	INSSTD,.CHCNW	;^W
	XWD	INSSPC,.CHCCF	;^^
INTTAB:	XWD	INSMAC,.CHCNT	;^T
	XWD	INSIGR,.CHCNR	;^R
	XWD	0,0		;END OF LIST

;^V CAUSES THE NEXT CHARACTER TO BE CONVERTED TO LOWER CASE (IF UPPER CASE)
;^V^V SETS LOWER CASE MODE UNTIL THE END OF THE TEXT STRING (OR FURTHER NOTICE)

INSLOW:	PUSHJ	P,C.V		;SET ^V FLAGS
	JRST	INS1C		;CONTINUE TO NEXT CHAR.

;^W CAUSES NEXT CHAR. TO BE TAKEN AS IS (STANDARD MODE)
;^W^W SETS STANDARD MODE UNTIL END OF TEXT STRING (OR FURTHER NOTICE)

INSSTD:	PUSHJ	P,C.W		;SET ^W FLAGS
	JRST	INS1C		;CONTINUE TO NEXT CHAR.

;^R CAUSES NEXT CHAR. TO BE TAKEN AS TEXT
;EVEN IF IT IS A CONTROL CHAR. OR THE TEXT TERMINATOR

INSIGR:	PUSHJ	P,GCH		;GET NEXT CHAR.
	JRST	INS1E		;TREAT AS TEXT

;^^ -- IF NEXT CHAR IS @,[,\,],^, OR _, CONVERT IT TO LC RANGE

INSSPC:	PUSHJ	P,GCH		;GET NEXT CHAR
	PUSHJ	P,CVTSPC	;CONVERT IF WARRANTED
	JRST	INS1F

;CHANGE NO-CONTROL-COMMANDS MODE

INSMAC:	TXC	F2,S.NCCT	;COMPLEMENT ^T FLAG
	JRST	INS1C		;GO ON TO NEXT CHAR
SUBTTL	ALPHA CASE CONVERTED

;SET ^V FLAGS

C.V:	TXON	F2,S.CTLV	;SET ^V FLAG -- WAS IT ON BEFORE?
	POPJ	P,		;NO
	TXZ	F2,S.CTLV+S.CTWW	;YES, SET ^V^V FLAG & CLR OTHERS
	TXO	F2,S.CTVV
	POPJ	P,

;SET ^W FLAGS

C.W:	TXON	F2,S.CTLW	;SET ^W FLAG -- WAS IT ON BEFORE?
	POPJ	P,		;NO
	TXZ	F2,S.CTLW+S.CTVV	;YES, SET ^W^W FLAG & CLR OTHERS
	TXO	F2,S.CTWW
	POPJ	P,

;CONVERT ALPHABETIC CH TO UPPER OR LOWER CASE ACCORDING TO CASE CONTROL FLAGS

CASE:	CAIL	CH,"A"		;IS CHAR IN UPPER CASE RANGE?
	CAILE	CH,"Z"
	CAIL	CH,"A"+40	;IS IT IN LOWER CASE RANGE?
	CAILE	CH,"Z"+40
	JRST	CASE3		;NO
CASE2:	TXNE	F2,S.LCAS	;PREVAILING LOWER CASE?
	TRO	CH,40		;YES, CONVERT TO LOWER
	TXNE	F2,S.UCAS	;PREVAILING UPPER CASE?
	TRZ	CH,40		;YES, CONVERT TO UPPER
	TXNE	F2,S.CTVV	;DOUBLE ^V ON?
	TRO	CH,40		;YES, CONVERT TO LC
	TXNE	F2,S.CTWW	;DOUBLE ^W ON?
	TRZ	CH,40		;YES, CONVERT TO UC
	TXZE	F2,S.CTLV	;SINGLE ^V ON?
	TRO	CH,40		;YES, CONVERT TO LC
	TXZE	F2,S.CTLW	;SINGLE ^W ON?
	TRZ	CH,40		;YES, CONVERT TO UC
CASE3:	TXZ	F2,S.CTLV+S.CTLW	;CLR IN CASE NO CONVERSION
	POPJ	P,

;CONVERT @, [, \, ], ^, AND _ TO THE EQUIVALENT LC CHARACTER

CVTSPC:	CAIL	CH,"["
	CAILE	CH,"_"
	CAIN	CH,"@"
	TRO	CH,40		;CONVERT TO LOWER CASE RANGE
	POPJ	P,
SUBTTL	CHECK FOR NON-CONTROL CHARACTERS

;IF CH<10, OR 15<CH<33, OR 33<CH<40, CH IS AN ILLEGAL CTRL-CHAR

CKNCC:	CAIGE	CH," "
	CAIG	CH,.CHCRT
	CAIGE	CH,.CHCNH
	CAIN	CH,.CHESC
	POPJ	P,		;IT IS 10-15 OR 33 OR 40+
	MOVEI	B,(CH)		;SAVE CHAR FOR ERROR MSG ROUTINE
	ERROR	E.ICT
SUBTTL	NI	INSERT AT THE POINTER A CHARACTER WHOSE 7-BIT ASCII CODE IS N

;	(BASE 10).  THE POINTER IS MOVED TO THE RIGHT OF THE NEW CHARACTER.

INS1A:	CHKEO	EO21,INS1X	;IF EO=1 SKIP NEXT STUFF
	PUSHJ	P,SKRCH		;GET CHAR AFTER I
	ERROR	E.NAI
	CAIE	CH,.CHESC	;IT HAD BETTER BE AN ALTMODE
	ERROR	E.NAI
INS1X:	MOVE	CH,NUM		;CH:=NUM

;INSERT CH IN DATA BUFFER AT PT

TAB2:	MOVEI	C,1		;MOVE FROM PT THROUGH Z UP 1 POSITION.
	PUSHJ	P,NROOMC
	AOS	OU,PT		;PT:=PT+1
	SOJA	OU,PUT		;STORE CH AT PT-1

;NBACKSLASH	INSERT AT THE CURRENT POINTER LOCATION THE ASCII NUMBERS
;	EQUAL TO N.

BAKSL1:	MOVE	T,[XWD 700,STAB-1]
	MOVEI	C,0		;COUNT # DIGITS IN C.
	MOVEI	A,BAKSL4	;SET DPT TO RETURN TO BAKSL4
	PUSHJ	P,DPT		;CONVERT C(B) TO ASCII AND STORE STRING IN STAB.
	MOVE	B,[XWD 700,STAB-1]
	PUSHJ	P,NROOMC	;MOVE FROM PT THROUGH Z UP C POSITIONS.
BAKSL5:	MOVE	OU,PT		;POSITION TO PUT CHAR IN
	ILDB	CH,B		;GET NEXT CHAR OF THE #
	PUSHJ	P,PUT		;STORE THE CHAR
	AOS	PT		;MOVE THE POINTER
	SOJG	C,BAKSL5	;DECREMENT THE CHAR CTR
	JRST	RET

BAKSL4:	IDPB	CH,T		;STORE DIGIT IN STAB
	AOJA	C,CPOPJ		;C:=C+1. RETURNS TO DPT CALL + 1 ON COMPLETION.

;@ COMMAND MODIFIER

ATSIGN:	TXOA	FF,F.SLSL	;SET @ SEEN FLAG

;COLON COMMAND MODIFIER

COLON:	TXO	FF,F.COLN	;SET : SEEN FLAG
	JRST	RETRET
SUBTTL	NT	TYPE OUT THE STRING OF CHARACTERS

;	STARTING AT THE RIGHT OF THE
;	POINTER AND CONTINUING THROUGH THE NTH LINE FEED ENCOUNTERED.
;	IF N IS NEGATIVE, N LINES TO THE LEFT OF THE POINTER ARE TYPED.
;T	SAME AS 1T.
;I,JT	TYPE OUT THE (I+1)TH THROUGH THE JTH CHARACTER OF THE BUFFER.

TYPE:	SETZM	XCTING		;SO ^C^C REE WORKS PROPERLY
	PUSHJ	P,TYPE4		;TYPE IT
	SETOM	XCTING		;KEEP GOING
	POPJ	P,		;RETURN

TYPE4:	MOVEI	D,TYO		;D:=ADDRESS OF OUTPUT ROUTINE.

TYPE0:	PUSHJ	P,GETARG	;C:=FIRST STRING ARGUMENT ADDRESS.
				;B:=SECOND STRING ARGUMENT ADDRESS.

TYPE1:	PUSHJ	P,CHK1		;C:=MAX(C(C),BEG), B:=MIN(C(B),Z)
	MOVE	I,C		;START GETTING CHARACTERS AT C.
	MOVE	OU,C		;STARTING CHAR
TYPEQ:	IDIVI	OU,5		;WORD ADR
	HLL	OU,BTAB-1(OU+1)	;FORMED POINTER
	JUMPG	OU,.+2
	SUB	OU,[430000,,1]	;ADJUST IF CHAR IS IN PREV WORD.
	LDB	CH,OU		;PICK UP PREVIOUS CHARACTER
	PUSHJ	P,CKEOL		;IS IT AN EOL?
	CAMN	I,BEG		;NO, ARE WE AT BEG. OF BUFFER?
	TXO	FF,F.SQIN	;YES, START WITH A SEQ # IF NECESSARY
TYPE3:	CAML	I,B		;DONE?
	JRST	TYPE5		;YES.
	ILDB	CH,OU		;CHARACTER
	PUSHJ	P,(D)		;OUTPUT IT
	AOJA	I,TYPE3		;LOOP FOR ALL
TYPE5:	MOVE	A,OUTCH		;IF TYPING OR I,JP DON'T APPEND FF
	MOVEI	CH,.CHFFD	;IF PUNCHING, APPEND FF.
	CAIE	A,(D)		;D=PPA?
	POPJ	P,		;NO
	TXNN	FF,F.NSRH	;IS THIS AN "N" SEARCH?
	JRST	CPPA
	TXNN	FF,F.FORM	;DID LAST Y,A TERMINATE ON A FORM FEED?
	POPJ	P,
CPPA:	TXNN	FF,F.OOPN	;WE HAVE AN OUTPUT FILE OPEN?
	ERROR	E.NFO
	JRST	@OUTCH		;DISPATCH TO OUTPUT A CHARACTER
SUBTTL	PUT A CHARACTER IN THE OUTPUT FILE

PPA:
PPA05:	SOSGE	OBF+.BFCNT	;YES. IS OUTPUT BUFFER FULL?
	JRST	OUTBFR
	MOVE	A,OUTSWT	;GET OUTPUT SWITCHES
	TXNN	FF,F.SEQ	;SEQUENCED FILE?
	TLNE	A,FS.GEN	;NO, OUTPUT FS.GEN ON?
	JRST	PPA02		;YES, GENERATE LSN
	TXZ	FF,F.SQIN
PPA01:	IDPB	CH,OBF+.BFPTR	;CH TO OUTPUT BUFFER.
	POPJ	P,		;RETURN

OUTBFR:	OUT	OUTCHN,		;DUMP BUFFER
	JRST	PPA05		;AND CONTINUE
OUTERR:	GETSTS	OUTCHN,B	;SAVE ERROR FLAGS
	RELEAS	OUTCHN,0	;CLOSE FILE AND RELEASE OUTPUT DEVICE.
	TXZ	FF,F.OOPN+F.UBAK	;CLEAR OUTPUT FILE OPEN INDICATOR.
	EE2+ERROR E.OUT

PPAQ:	SOSGE	OBF+.BFCNT	;MORE ROOM?
	JRST	[OUT	OUTCHN,	;DUMP BUFFER
		 JRST	PPAQ	;LOOP
		 JRST	OUTERR]	;ELSE ERROR
	IDPB	CH,OBF+.BFPTR	;SAVE CHARACTER
	POPJ	P,		;LEAVE
PPA02:	TXNN	FF,F.SQIN	;WAS LAST CHAR AN EOL OR BEG OF BUFR?
	JRST	PPA03		;NO
	MOVE	AA,OUTSWT	;GET OUTPUT SWITCHES
	TLNE	AA,FS.SUP	;IF WE ARE SUPRESSING SEQUENCE #'S,
	JRST	PPA06		;DON'T WORRY ABOUT PADDING WITH NULLS
	MOVE	A,OBF+.BFCNT	;ROOM FOR SEQ# IN OUTPUT BUFR?
	CAIG	A,.CHLFD
	JRST	PPA05		;NO, OUTPUT & COME BACK
PPA07:	LDB	A,[POINT 6,OBF+.BFPTR,5]	;GET CURRENT BYTE POSITION IN OUT BUFR
	CAIG	A,1		;AT END OF WORD?
	JRST	PPA06		;YES
	IBP	OBF+.BFPTR	;NO, PAD OUT WORD WITH NULLS
	SOS	OBF+.BFCNT
	JRST	PPA07		;TRY AGAIN
PPA06:	TXZ	FF,F.SQIN
	TXNE	FF,F.SEQ	;GENERATE NEW LSN OR OUTPUT EXISTING LSN?
	JRST	PPA04		;OUTPUT EXISTING LSN
	MOVE	A,LSNCTR	;GET LAST CREATED LSN WITH BIT 35 ON
	ADD	A,[BYTE (7)106,106,106,107]	;& ADD ASCII 10 TO IT
	MOVE	T,A
	AND	T,[BYTE (7)60,60,60,60]
	LSH	T,-3
	MOVE	TT,A
	AND	TT,[BYTE (7)160,160,160,160]
	IOR	T,TT
	SUB	A,T
	ADD	A,[BYTE (7)60,60,60,60]
	MOVEM	A,LSNCTR	;STORE NEW LSN
PPA06A:	AOS	OBF+.BFPTR	;& OUTPUT THE 5 DIGITS + BIT 35
	MOVEM	A,@OBF+.BFPTR
	MOVEI	A,.CHTAB	;FOLLOWED BY TAB
	IDPB	A,OBF+.BFPTR
	MOVNI	A,6		;ADJUST BUFR CTR
	ADDM	A,OBF+.BFCNT
PPA03:	PUSHJ	P,CKEOL		;IS THIS CHAR AN EOL?
	JRST	PPA01		;NO
	TXO	FF,F.SQIN
	JRST	PPA01
;OUTPUT EXISTING LSN WITH LEADING ZEROS

PPA04:	MOVEI	A,4		;INIT 5 DIGIT CTR
	MOVEM	A,LSNCTR
	MOVE	A,[<"00000">B34]	;INIT LSN ACCUMULATOR
	CAIL	CH,"0"		;IS CURRENT CHAR A DIGIT?
	CAILE	CH,"9"
	JRST	PPA08		;NO, FILL IN 5 SPACES
	JRST	PPA12
PPA10:	SOSGE	LSNCTR		;DONE 5 DIGITS YET?
	JRST	PPA09		;YES
PPA12:	LSH	A,7		;PUT DIGIT INTO ACCUMULATOR
	DPB	CH,[POINT 7,A,34]
	CAML	I,B
	JRST	PPA09
	ILDB	CH,OU		;GET THE NEXT FUCKING CHARACTER
	ADDI	I,1		;INCREMENT TEXT PTR
	CAIL	CH,"0"		;IS IT A DIGIT?
	CAILE	CH,"9"
	JRST	PPA09		;NO
	JRST	PPA10		;YES, STORE IT

PPA08:	MOVE	A,[<"     ">B34]	;GET 5 SPACES
PPA08X:	CAIE	CH," "		;SPACE?
	JRST	PPA08B		;NO, INSERT 5 SPACES
	SOSGE	LSNCTR		;HAVE WE SEEN 5 SPACES?
	JRST	PPA08C		;IF SO, CHECK FOR TAB OR CR
	ILDB	CH,OU		;GET NEXT CHARACTER
	AOJA	I,PPA08X	;TRY AGAIN

;	HERE IF WE'VE SEEN 5 SPACES MAY BE TECO BLANK SEQUENCE NUMBER,
;	SOS PAGE MARK, OR SPACES THE USER HAS INSERTED.
PPA08C:	ILDB	CH,OU		;GET THE CHAR
	AOS	I
	CAIE	CH,.CHCRT	;TEST FOR CR (FOR SOS) OR
	CAIN	CH,.CHTAB	;TAB TO BE OUTPUT WITH SPACES
	JRST	PPA09		;OUTPUT 5 SPACES + CHAR IN CH

;	HERE IF NOT 5 SPACES FOLLOWED BY TAB OR CR.  THIS IMPLIES
;	THAT ANY SPACES SEEN WERE USERS'S TEXT.
PPA08B:	SUBI	I,4		;BACK UP TO FIRST CHARACTER
	ADD	I,LSNCTR	;AND OUTPUT IT WITH BLANK LSN
	MOVE	OU,I		;FIX BYTE POINTER
	IDIVI	OU,5
	HLL	OU,BTAB-1(OU+1)
	ILDB	CH,OU		;GET PROPER CHARACTER
	MOVE	AA,OUTSWT	;GET SWITCHES
	TLNE	AA,FS.SUP	;SUPPRESS SEQ#
	JRST	PPA01		;YES
	TRO	A,1		;NO SET BIT 35
	JRST	PPA06A		;OUTPUT SEQ# WITH A TAB
PPA09:	MOVE	AA,OUTSWT	;GET SWITCHES
	TLNE	AA,FS.SUP	;SUPPRESS SEQ#'S?
	JRST	PPA13		;YES
	TRO	A,1		;SET BIT 35
	AOS	OBF+.BFPTR	;& OUTPUT SEQ #
	MOVEM	A,@OBF+.BFPTR
	MOVNI	A,5
	ADDM	A,OBF+.BFCNT	;& ADJUST BUFR CTR
	JRST	PPA03		;CONTINUE

PPA13:	CAIE	CH,.CHCRT	;ELEMINATE CR (FOR SOS)
	CAIN	CH,.CHTAB	;IS TERMINATOR A TAB?
	AOSA	OBF+.BFCNT	;YES, ADJUST BYTE COUNT
	JRST	PPA01		;NO, OUTPUT IT
	POPJ	P,		;AND OMIT IT
SUBTTL	PW	OUTPUT THE ENTIRE BUFFER, FOLLOWED BY A FORM FEED CHARACTER.

;	TO THE SELECTED OUTPUT DEVICE.  BUFFER IS UNCHANGED AND POINTER
;	IS UNMOVED.
;P	IS IDENTICAL TO PWY.
;NP	IS IDENTICAL TO PP...P (P PERFORMED N TIMES).
;I,JP	OUTPUTS (I+1)TH THROUGH JTH CHARACTERS OF BUFFER.  NO FORM
;	FEED IS PUT AT THE END.  BUFFER UNCHANGED;POINTER UNMOVED.

PUNCHA:	MOVEI	D,CPPA		;SELECT PPA FOR OUTPUT INDIRECTLY IN CASE I,JP.
	TXNE	FF,F.ARG2	;I,JP?
	JRST	TYPE0		;YES. GET STRING ARGUMENTS AND OUTPUT.
	MOVE	E,B		;NO. E:=N
	MOVE	B,CPTR
	ILDB	T,B		;T:=COMMAND CHARACTER FOLLOWING P.
	TRZ	T,40		;FILTER L.C.
	JUMPL	E,CPOPJ		;IF N<0, IGNORE P.
	CHKEO	EO21,PUN1	;OLD STYLE P ALWAYS GIVES FORM FEED
	CAIE	T,"W"		;PW ALWAYS GIVES FORM FEED
	TXO	FF,F.NSRH	;OTHERWISE, FORM GOES OUT ONLY IF FORM CAME IN
PUN1:	PUSHJ	P,PUNCHR	;PUNCH OUT BUFFER
	SKIPE	COMCNT		;IF NO COMMANDS LEFT
	CAIE	T,"W"		;OR COMMAND IS NOT W
	JRST	PUN3		;READ NEXT PAGE
	CAIG	E,1		;ARG DOWN TO 1 YET?
	PUSHJ	P,RCH		;YES, THROW AWAY THE W
PUN4:	SKIPN	XCTING
	JRST	GO
	MOVE	C,Z
	CAMN	C,BEG		;EMPTY BUFFER?
	TXNN	FF,F.EOFI	;NO. QUIT ON EOF
	SOJG	E,PUN1		;YES. E:=E-1. DONE?
CPOPJ:	POPJ	P,		;YES

PUN2:	MOVE	OU,BEG		;IF NOTHING READ IN, CLEAR THE BUFFER
	MOVEM	OU,PT
	TXZ	FF,F.FORM	;AND THE FORM FEED FLAG
	JRST	YANK51		;SET Z=BEG & POPJ

PUNCHR:	MOVE	C,BEG		;OUTPUT DATA BUFFER.
	MOVE	B,Z
	MOVE	D,OUTCH
	CAME	B,C		;IS PAGE BUFFER EMPTY?
	JRST	PUNCH1		;NO
	TXNE	FF,F.FORM	;YES, IS THERE A FORM-FEED ON THIS BLANK PAGE?
	JRST	TYPE5		;YES, OUTPUT IT
	POPJ	P,
PUNCH1:	TXNN	FF,F.OOPN	;CAN WRITE?
	ERROR	E.NFO
	JRST	TYPE1
PUN3:	TXNE	FF,F.IOPN	;ANY INPUT FILE?
	TXNE	FF,F.EOFI	;DONT TRY TO READ IF NO DATA LEFT
	JRST	PUN2
	PUSHJ	P,YANK1		;RENEW BUFFER
	JRST	PUN4		;CONTINUE
SUBTTL	NJ, NC, & NL COMMANDS

;NJ	MOVE THE POINTER TO THE RIGHT OF THE NTH CHARACTER IN THE
;	BUFFER. (I.E., GIVE "." THE VALUE N.)
;J	SAME AS 0J.

JMP:	ADD	B,BEG		;PT:=N+BEG
	JRST	JMP1



;NR	SAME AS .-NJ.

REVERS:	PUSHJ	P,CHK2		;MAKE SURE THERE IS AN ARGUMENT
	MOVNS	B		;B:=-C(B)
	SKIPA

;NC	SAME AS .+NJ.  NOTE THAT N MAY BE NEGATIVE.

CHARAC:	PUSHJ	P,CHK2		;MAKE SURE THERE IS AN ARGUMENT
	ADD	B,PT		;B:=PT+C(B)

;IF B LIES BETWEEN BEG AND Z, STORE IT IN PT.

JMP1:	PUSHJ	P,CHK		;IS C(B) WITHIN DATA BUFFER?
	MOVEM	B,PT		;YES. PT:=C(B)
	JRST	RET

;NL	IF N>0:	MOVE POINTER TO THE RIGHT, STOPPING WHEN IT HAS
;		PASSED OVER N LINE FEEDS.
;	IF N<0:	MOVE POINTER TO THE LEFT;STOP WHEN IT HAS PASSED
;		OVER N+1 EOL'S AND THEN MOVE IT TO THE RIGHT OF
;		THE LAST EOL PASSED OVER.
;L	SAME AS 1L.

LINE:	TXNE	FF,F.ARG2	;ERROR IF THERE ARE 2 ARGS
	ERROR	E.TAL
	PUSHJ	P,GETARG	;NO. C:=FIRST STRING ARGUMENT ADDRESS,
				;B:=SECOND STRING ARGUMENT ADDRESS.
	XOR	B,C
	XORM	B,PT
	JRST	RET
SUBTTL	ROUTINE TO RETURN CURRENT ARGUMENT IN B

;ASSUMES A VALUE OF 1 WITH SIGN OF LAST OPERATOR IF THERE IS NO CURRENT ARGUMENT
;CALL	PUSHJ P,CHK2
;	RETURN WITH B:=CURRENT ARG.,+1 OR -1

CHK2:	TXOE	FF,F.ARG	;IS THERE AN ARGUMENT?
	POPJ	P,		;YES. IT'S ALREADY IN B.
CHK22:	MOVEI	B,1		;B=1*SIGN OF LAST OP
	TXZE	FF,F.NEG	;WAS IT A MINUS SIGN?
	MOVNS	B		;YUP
	POPJ	P,		;RETURN

;NK	PERFORM NL BUT DELETE EVERYTHING THE POINTER MOVES OVER.
;M,NK	DELETE THE (M+1)TH THROUGH THE NTH CHARACTER FROM THE BUFFER.
;	THE POINTER IS THEN PUT WHERE THE DELETION TOOK PLACE.
;K	SAME AS 1K

KILL:	PUSHJ	P,GETARG	;C:=FIRST STRING ARG. ADDRESS
				;B:=SECOND STRING ARG. ADDRESS
	PUSHJ	P,CHK1		;C:=MAX(C(C),BEG), B:=MIN(C(B),Z)
	MOVEM	C,PT		;PT:=C(C)
	SUB	B,C		;B:=NO. OF CHARACTERS TO KILL.
	JUMPE	B,RET		;IF NONE, RETURN. OTHERWISE, FALL INTO DELETE
SUBTTL	ND	DELETE N CHARACTERS FROM THE BUFFER

;	IF N IS POSITIVE, DELETE
;	THEM JUST TO THE RIGHT OF THE POINTER;IF N IS NEGATIVE, DELETE
;	THEM JUST TO ITS LEFT.
;D	SAME AS 1D

DELETE:	PUSHJ	P,CHK2		;MAKE SURE B CONTAINS AN ARGUMENT
DEL1:	MOVM	C,B
	MOVNS	C		;C:=-ABS(B)
	ADD	B,PT		;B:=PT+B
	PUSHJ	P,CHK		;STILL IN DATA BUFFER?
	CAMGE	B,PT		;YES. IS N NEGATIVE?
	MOVEM	B,PT		;YES. MOVE PT BACK FOR DELETION.
	PUSHJ	P,NROOM		;MOVE FROM PT+ABS(C) THROUGH Z DOWN ABS(C) POSITIONS
	TXZE	F2,S.DELS	;FROM A SEARCH AND DESTROY MISSION?
	JRST	FND2		;YES, MAYBE COLON MODIFIER PRESENT
	JRST	RET



;ROUTINE TO CHECK DATA BUFFER POINTER
;CALL	MOVE B,POINTER
;	PUSHJ P,CHK
;	RETURN IF B LIES BETWEEN BEG AND Z

CHK:	MOVE	TT,[MOVE B,SYL]
	MOVEM	TT,DLIM
	CAMG	B,Z
	CAMGE	B,BEG
	..ERROR	E.POP
	POPJ	P,

;ROUTINE TO PUT STRING ARGUMENT ADDRESSES WITHIN DATA BUFFER
;BOUNDS AND CHECK ORDER RELATION.
;CALL	MOVE C,FIRST STRING ARGUMENT ADDRESS
;	MOVE B,SECOND STRING ARGUMENT ADDRESS
;	PUSHJ P,CHK1
;	RETURN
;IF C>B, DOES NOT RETURN.
;C:=MIN(MAX(C,BEG),Z)
;B:=MIN(MAX(B,BEG),Z)

CHK1:	CAMLE	C,B		;C>B?
	ERROR	E.SAL
	CAMGE	C,BEG		;C:=MAX(C(C),BEG)
	MOVE	C,BEG
	CAMLE	C,Z		;C:=MIN(C(C),Z)
	MOVE	C,Z
	CAMGE	B,BEG		;B:=MAX(C(B),BEG)
	MOVE	B,BEG
	CAMLE	B,Z		;B:=MIN(C(B),Z)
	MOVE	B,Z
	POPJ	P,		;RETURN
SUBTTL	SEARCH COMMANDS

BOUNDS:	PUSHJ	P,GETAG6	;GET THE STRING POINTERS
	TXZ	FF,F.NSRH!F.LARW!F.ARG	;FN + N GO TO FS AND S
	CAMLE	C,Z		;TOO BIG
	MOVE	C,Z
	CAMGE	C,BEG		;TOO SMALL
	MOVE	C,BEG
	MOVEM	C,PT		;PLACE TO START SEARCHIN'
	CAML	B,C		;MINUS IMPLIED?
	JRST	SAVESH		;NO, SAVE BOUNDS
	EXCH	C,B		;YES, EXCHANGE ARGS
	TXO	F2,S.MINS	;SAY MINUS SEARCH
SAVESH:	MOVEM	C,LOWERB
	MOVEM	B,UPPERB
	JRST	SERCHA		;SEARCH

;_ SEARCH

LARR:	TXOA	FF,F.LARW	;F.LARW:=1 FOR LEFT ARROW SEARCH

;N SEARCH

SERCHP:	TXO	FF,F.NSRH	;F.NSRH:=1 FOR N SEARCH

;S SEARCH

SERCH:	MOVE	E,PT		;OLD POINT
	MOVEM	E,SAVEAC	;SAVE IN CASE THE SEARCH FAILS
	SETZ	E,		;ASSUME FIRST OCCURRENCE IN CASE BOUNDED
	TXZE	FF,F.ARG2	;TWO ARGS = BOUNDED SEARCH
	JRST	BOUNDS		;BOUNDED SEARCH
	SETZM	LOWERB		;SAVE AS DEFAULT LOWER BOUND
	SETZM	UPPERB		;SAVE
	PUSHJ	P,CHK2		;GET 1ST ARG
	SKIPE	B		;ZERO?
	JRST	SERC33		;NO
	TXNE	FF,F.ARG	;THERE MUST BE NO ARG
ERRISA:	ERROR	E.ISA
SERC33:	SKIPGE	E,B		;GET ARG WHERE IT WANTS IT
	TXO	F2,S.MINS	;MINUS SEARCH
SERCHA:	MOVE	A,BEG		;GOOD LOWER BOUND
	MOVE	B,Z		;GOOD UPPER BOUND
	CAMLE	A,LOWERB
	MOVEM	A,LOWERB
	CAMGE	B,LOWERB
	MOVEM	B,LOWERB
	SKIPE	UPPERB		;FIX ZERO UPPER BOUND
	CAMGE	B,UPPERB
	MOVEM	B,UPPERB
	CAMLE	A,UPPERB
	MOVEM	A,UPPERB
	MOVMS	E		;FOR CORRECT MINUS SERCH
;THE FOLLOWING NOT NEEDED ANYMORE
;	MOVE	A,[MOVE	B,SYL]	;IN CASE F.COLN ON
;	MOVEM	A,DLIM
	MOVEI	CH,.CHESC	;USE ALT-MODE DELIMITER IF NO @ SEEN
	TXZN	FF,F.SLSL	;@ SEEN?
	JRST	SERCHB		;NO, TERMINATOR = ALTMODE
	PUSHJ	P,SKRCH		;YES. CH:=USER SPECIFIED DELIMITER.
	ERROR	E.USR
SERCHB:	MOVEM	CH,B		;B:=SEARCH STRING DELIMITER
	MOVEM	CH,ARGTRM	;SAVE TERMINATOR FOR FS INSERTION
	SETZM	STAB		;CLEAR SEARCH MATRIX
	MOVE	A,[XWD STAB,STAB+1]
	BLT	A,STAB+STABLN-1
	PUSHJ	P,SKRCH		;LOOK AHEAD 1 CHAR
	ERROR	E.USR
	CAIE	CH,(B)		;IS IT THE DELIMITER?
	JRST	SERCHT		;NO, AN ARGUMENT IS GIVEN
	SKIPN	SRHCTR		;YES, USE PREVIOUS SEARCH STRING
	ERROR	E.SNA
	JRST	SERCH0
;MOVE NEW STRING TO STORAGE

SERCHT:	SETZM	SRHCTR		;CLR STRING CTR
	MOVE	AA,[POINT 7,SRHARG]	;INIT STORAGE PTR
	JRST	SERCHD		;1ST CHAR ALREADY IN
SERCHC:	PUSHJ	P,SKRCH		;GET NEXT CHAR OF CMD STRING
	ERROR	E.USR
SERCHD:	CHKEO	EO21,SERCHE	;IF EO=1, ^R IS JUST TEXT
	CAIE	CH,.CHCNR	;^R?
SERCHE:	CAIN	CH,.CHCNQ	;^Q?
	JRST	SERCHG		;YES, NEXT CHAR IS TEXT
	CAIN	CH,(B)		;THE DELIMITER?
	JRST	SERCH0		;YES
	CAIN	CH,.CHCNT	;^T?
	JRST	SERCHU		;YES
	TXNE	F2,S.NCCT	;^T FLAG ON?
	JRST	SERCHF		;YES, ^V AND ^W ARE JUST TEXT
	CAIE	CH,.CHCNV	;^V?
	CAIN	CH,.CHCNW	;^W?
	TXO	F2,S.XMAT	;YES, SET EXACT MATCH FLAG
SERCHF:	AOS	A,SRHCTR	;BUMP STRING CTR
	CAILE	A,^D80		;STILL FIT IN STORE?
	ERROR	E.STC
	IDPB	CH,AA		;STORE CHARACTER
	JRST	SERCHC		;& GO BACK FOR MORE

SERCHG:	AOS	SRHCTR		;COUNT THE ^R (^Q)
	IDPB	CH,AA		;& STORE IT
	PUSHJ	P,SKRCH		;GET NEXT CHAR
	ERROR	E.USR
	JRST	SERCHF		;STORE IT AS TEXT

SERCHU:	TXC	F2,S.NCCT	;COMPLEMENT CONTROL CMD DISABLING SWITCH
	JRST	SERCHF
;SET UP SEARCH MATRIX

SERCH0:	TXZ	F2,S.NCCT	;REFRESH ^T FLAG
	SETZM	SCESQB		;CLR ^E[...] NEST CTR
	SETZM	CTGLEV		;CLR ^G NEST CTR
	MOVE	B,SRHCTR	;INIT STRING CTR
	MOVE	AA,[POINT 7,SRHARG]	;& POINTER
	MOVSI	D,400000	;INIT MATRIX BIT PTR

SERCH2:	ILDB	CH,AA		;CH:=NEXT SEARCH STRING CHARACTER.
	SKIPN	SCESQB		;GATHERING DATA FOR ^E[...]?
	JRST	.+3		;NO
	SOJL	B,CNTREE	;YES, ERRORS GO TO ?ICE
	JRST	.+2
	SOJL	B,SERCHI	;END OF STRING?
	MOVEI	T,S2TABL	;CK FOR CTL CHAR IN STRING
	TXNE	F2,S.NCCT	;^T FLAG ON?
	MOVEI	T,S3TABL	;YES, USE RESTRICTED TABLE
	PUSHJ	P,DISP1
	CHKEO	EO21,SRCH2B	;IF EO=1, FORCE EXACT MODE
	TXNN	F2,S.NCCT	;IF ^T FLAG ON, ALL ^CHARS ARE LEGAL
	PUSHJ	P,CKNCC		;CK FOR OTHER CTRL-CHARS (THEY ARE ILLEGAL)
SRCH2E:	TXNE	F2,S.EMAT	;IGNORE S.XMAT FLAG?
	JRST	SRCH2F		;YES, FORCE ACCEPT-EITHER SEARCH
	TXNN	F2,S.XMAT	;NO, S.XMAT ON?
	TXNE	FF,F.PMAT	;NO, PREVAILING EXACT MATCH FLAG ON?
	JRST	SRCH2B		;S.EMAT=0 & S.XMAT OR F.PMAT =1 IMPLIES EXACT MODE
SRCH2F:	CAIL	CH,"A"+" "	;ACCEPT-EITHER SEARCH MODE
	CAILE	CH,"Z"+" "	;IS IT LOWER CASE ALPHA?
	SKIPA			;NO
	TRZ	CH,40		;YES, MAKE IT UPPER CASE
	CAIL	CH,"A"		;IS IT UPPER CASE ALPHA?
	CAILE	CH,"Z"
	JRST	SERCH4		;NO
	XORM	D,STAB+40(CH)	;ENABLE MATCH ON CORRESP. LC CHAR.
	JRST	SERCH4

SRCH2B:	PUSHJ	P,CASE		;EXACT MODE SEARCH -- ADJUST CASE
SERCH4:	XORM	D,STAB(CH)	;MARK CHARACTER TO MATCH
SERCH5:	SKIPE	SCESQB		;GATHERING DATA FOR A ^E[...]?
	POPJ	P,		;YES
	TXZN	F2,S.CTLN	;DOES ^N PRECEDE THIS CHAR POSITION?
	JRST	SERCH6		;NO
	ANDCAM	D,STAB+BEGPAG	;YES, CLEAR ALL FAKE BITS
	ANDCAM	D,STAB+ENDPAG
	ANDCAM	D,STAB+SPCTAB
SERCH6:	LSH	D,-1		;MOVE TO NEXT CHAR. POSITION IN MATRIX
	SETZM	SCESQB		;(BASE IS 0)
	JUMPN	D,SERCH2	;36 CHARS SEEN YET? IF NOT CONTINUE.
	JUMPE	B,SERCHI	;TOO MUCH IF STILL ANOTHER CHAR WAITING
	ERROR	E.STL
SUBTTL	SCAN INSERT ARGUMENT IF F-SEARCH

SERCHI:	SKIPE	CTGLEV		;ARE WE IN A Q-REG NEST?
	JRST	CNTRG2		;YES, GO RESTORE PREV. LEVEL
	TXNN	FF,F.SRCH	;F-SEARCHING?
	JRST	SERCH1		;NO
	TXZ	F2,S.NCCT	;REFRESH ^T FLAG
	MOVE	CH,ARGTRM	;GET TERMINATOR TO WATCH FOR
	TXZ	FF,F.NNUL	;RESET NON-NULL STRING FLAG
	JRST	INSERA		;SCAN INSERT ARGUMENT

SERCHJ:	POP	P,COMBAK	;SAVE COMCNT & CPTR FOR THE INSERTION
	POP	P,CPTBAK
				;THEN FALL INTO SERCH1

SUBTTL	ACTUAL SEARCH

SERCH1:	MOVE	AA,D		;END OF SEARCH MARKER
	MOVE	I,PT		;START SEARCHING AT PT
S1:	TXNE	FF,F.ARG	;IS THERE AN ARGUMENT?
	JUMPLE	E,FND		;YES. SEEN STRING N TIMES?
	MOVE	TT,I		;NO, FORM BYTE PTR WHICH WILL BE
	SUBI	TT,1		;INCREMENTED BEFORE USE
	IDIVI	TT,5
	HLL	TT,BTAB(TT1)
	CAMG	I,BEG		;AT BEG OF BUFR?
	SKIPL	STAB+BEGPAG	;& 1ST SERCH CHAR = BEG OF BUFR CHAR?
	JRST	S3		;NO
	MOVSI	D,200000	;YES, START SEARCH AT 2ND SEARCH CHAR
	MOVE	TT1,TT		;SET DYNAMIC PTR = STATIC PTR
	SETOM	BCOUNT		;FLAG 1ST IS BEGPAG
	JRST	S4B		;ENTER SEARCH LOOP

S3:	CAML	I,LOWERB
	CAMLE	I,UPPERB	;NO. REACHED TOP OF BUFFER?
	JRST	NOFND		;YES.
	MOVSI	D,400000	;START SEEKING MATCH FOR 1ST CHAR
	MOVE	TT1,TT		;SET DYNAMIC PTR=STATIC PTR
	JRST	S4A
S4:	TDNE	D,STAB+SPCTAB	;IS SPACE/TAB STRING BIT SET?
	JRST	SPTB		;YES
	CAML	I,UPPERB	;DONT ALLOW I OUTSIDE BOUNDS
	JRST	S4D		;...
	ADDI	I,1		;LOOK AT NEXT LOC, XCEPT 1ST TIME THRU
S4C:	LSH	D,-1		;ADVANCE TO NEXT CHAR POSITION
S4B:	CAMN	D,AA		;END OF SEARCH TABLE?
	JRST	FND		;YES.
S4A:	ILDB	CH,TT1		;NO, GET NEXT CHAR
	TDNE	D,STAB(CH)	;IS IT A MATCH?
	JRST	S4		;YES, GO TO NEXT TABLE ENTRY.
S4D:	AOSN	BCOUNT		;IF WE FAILED WITH BEGPAG
	JRST	S3		;THEN TRY AGAIN WITH 1ST CHAR
	TXNN	F2,S.MINS	;BACKWARDS SEARCH
	AOSA	I,PT		;NO MATCH. PT:=PT+1
	JRST	SR4A
	CAML	I,UPPERB	;TOO FAR?
	JRST	NOFND3
	IBP	TT		;MOVE STATIC BYTE PTR
	JRST	S3		;KEEP LOOKING
SR4A:	SOS	I,PT		;DECREMENT PT
	CAMGE	I,LOWERB	;DONE
	JRST	NOFND3
	ADD	TT,[7B5]	;PREVIOUS BYTE (MAYBE)
	JUMPGE	TT,S3		;DEFINITELY
	HRLI	TT,(POINT 7,,34);FIX
	SOJA	TT,S3		;DECREMENT AND GO
SUBTTL	SEARCH STRING FOUND

FND:	SETOM	SFINDF		;NO. SFINDF:=-1
	MOVE	A,I
	SUB	A,PT		;COMPUTE LENGTH OF SEARCH ARG
	MOVE	B,I		;SAVE CURRENT POINTER
	TXNN	F2,S.MINS
	JRST	NOTMIN
	CAMLE	I,SAVEAC	;LEGAL FIND?
	SOSA	I,PT
	SOSA	I,PT
	JRST	S1
NOTMIN:	MOVEM	I,PT		;ELSE GO FORWARD
	SOJG	E,S1		;FIND IT N TIMES?
	MOVEM	B,PT
	TXNE	F2,S.DELS	;SEARCH AND DESTROY
	JRST	[MOVE	B,SAVEAC	;GET OLD PT
		 SUB	B,PT		;MINUS POINT AFTER SEARCH
		 JRST	DEL1]		;DELETE !(B)!
	TXNN	FF,F.SRCH	;F-SEARCH?
	JRST	FND3		;NO
	MOVE	C,VVAL		;YES, GET INSERT SIZE
	SUBI	C,(A)		;INSERT MINUS DELETE
	MOVNS	A		;SET PT TO BEGINNING OF STRING FOUND
	ADDM	A,PT
	PUSHJ	P,NROOM		;STRETCH OR SCRUNCH THE HOLE
	MOVE	B,ARGTRM	;GET TERMINATOR TO LOOK FOR
	MOVE	A,COMBAK	;RESET COMCNT & CPTR TO BEGINNING
	MOVEM	A,COMCNT	;OF INSERT ARGUMENT
	MOVE	A,CPTBAK
	MOVEM	A,CPTR
	PUSHJ	P,INS1B		;INSERT THE 2ND ARG
	PUSHJ	P,ZEROTT	;DO AUTO-TYPE IF REQUIRED
	MOVE	CH,ARGTRM
	TXZN	FF,F.NNUL	;WAS THERE A NON-NULL INSERT?
	CAIE	CH,.CHESC	;ALTMODE TERMINATOR?
	JRST	FND2		;NO
	TXO	F2,S.NRAD	;FLAG SO 2ND ALTMODE STAYS AROUND
	JRST	ALTM1		;YES, FS<STRING>$$ TERMINATES EXECUTION
FND3:
IFN VC,<MOVEM	A,VVAL>		;SAVE LENGTH OF STRING
	PUSHJ	P,ZEROTT	;AUTOTYPE
FND2:	TXZE	FF,F.COLN	;COLON MODIFIER?
	JRST	FFOK		;YES, RETURN VALUE
	SKIPL	(P)		;IN AN ITERATION?
	JRST	RET		;NO, RETURN NO VALUE

FFOK:	MOVNI	A,1		;YES. RETURN VALUE OF -1
	JRST	VALRET
SUBTTL	AUTOTYPE AFTER SUCCESSFUL SEARCHES

;IF AUTOF IS NON-ZERO
;INCLUDE POINTER MARKER = ASCII CHAR IN AUTOF IF AUTOF > 0

ZEROTT:	TXNE	FF,F.COLN	;NO AUTOTYPE ON COLON SEARCHES
	POPJ	P,
	SKIPL	-1(P)		;IN AN ITERATION?
	SKIPN	AUTOF		;AUTOTYPE WANTED?
	POPJ	P,
	TXO	FF,F.ARG	;DO 0T
	SETZ	B,
	PUSHJ	P,TYPE
	HRRZ	CH,AUTOF
	SKIPL	AUTOF		;PTR MARKER WANTED?
	PUSHJ	P,TYOM		;YES
	MOVEI	B,1		;DO 1T
	PUSHJ	P,TYPE
	TXZ	FF,F.ARG
	POPJ	P,
NOFND:	TDNN	D,STAB+ENDPAG	;ENDPAG GOOD FOR A MATCH HERE?
	JRST	NOFND3		;NO
	LSH	D,-1		;YES, BUT ONLY IF THIS IS LAST SRH CHAR
	CAMN	D,AA
	JRST	FND		;ENDPAG MATCHES!
NOFND3:	MOVE	I,BEG		;SEARCH FAILED
	MOVEM	I,PT		;PT=BEG
	SETZM	SFINDF		;SFINDF=0
	TXNE	F2,S.MINS	;THIS IS ALWAYS S SEARCH
	JRST	RESTPT
	TXNE	FF,F.NSRH+F.LARW	;S SEARCH?
	JRST	NOFND1		;NO.
RESTPT:	MOVE	A,SAVEAC	;GET OLD PT
	MOVEM	A,PT		;RESTORE IT

BEGIN1:	TXZN	FF,F.COLN	;YES. COLON MODIFIER?
	JRST	NOFND2		;NO


BEGIN2:	TXZ	FF,F.NSRH+F.LARW	;YES.
	TXNN	FF,F.SRCH	;F-SEARCH?
	JRST	BEGIN		;NO, RETURN VALUE OF 0
	MOVE	CH,ARGTRM	;GET INSERT TERMINATOR
	TXZN	FF,F.NNUL	;WAS IT A NULL INSERT?
	CAIE	CH,.CHESC	;YES, WAS IT AN ALTMODE TERMINATOR?
	JRST	BEGIN		;NO, RETURN 0 VALUE
	JRST	ALTM1		;YES, FS...$$ TERMINATES EXECUTION


NOFND1:	MOVEM	E,SRHCNT	;YES. SAVE SEARCH COUNT
	MOVEM	AA,SRHAA	;& SAVE END OF MATRIX MARKER
	MOVEI	B,1		;PUNCH 1 PAGE ONLY
	SETZ	T,		;TELL PUNCHER TO APPEND FORM FEED
	TXNE	FF,F.NSRH	;N SEARCH?
	PUSHJ	P,PUN1		;YES. PUNCH THIS BUFFER AND REFILL IT.
	TXNN	FF,F.IOPN	;ANY INPUT FILE?
	JRST	BEGIN1		;NO
	TXNE	FF,F.EOFI	;MORE DATA?
	TXNE	FF,F.FORM
	JRST	NOFND4		;YES
	MOVE	E,BEG		;EOF & NO FORM SEEN
	CAMN	E,Z		;CHECK BUFFER CONTENTS
	JRST	BEGIN1		;NO MORE DATA
NOFND4:	TXNE	FF,F.LARW	;LEFT ARROW SEARCH?
	PUSHJ	P,YANK1		;YES. FILL BUFFER.
	MOVE	E,SRHCNT	;RESTORE SEARCH COUNT.
	MOVE	A,BEG
	MOVEM	A,LOWERB
	MOVE	A,Z
	MOVEM	A,UPPERB
	MOVE	D,SRHAA		;RESTORE END OF STRING MARKER
	JRST	SERCH1		;RESUME SEARCH


NOFND2:	SKIPGE	(P)		;IN AN ITERATION?
	JRST	BEGIN2		;YES. RETURN VALUE OF 0
	ERROR	E.SRH

SRHMOD:	EXP	SRCHSW		;DEFAULT SEARCH MODE
;CNTR S MATCHES ANY SEPARATOR CHARACTER (I.E., ANY CHARACTER NOT
;A LETTER, NUMBER, PERIOD, DOLLAR SIGN OR PER CENT SYMBOL)

CNTRS:	MOVE	T,[-STABLN+3,,1]	;SET ALL CURRENT BITS EXCEPT NULL & SPCTAB
	PUSHJ	P,SETSTB	;& ENDPAG, BUT DO INCLUDE BEGPAG
	XORM	D,STAB+"."	;NOW, SCRATCH ALL SYMBOL CHARS
	XORM	D,STAB+"%"
	XORM	D,STAB+"$"
	MOVE	T,[-^D10,,"0"]	;DIGITS
	PUSHJ	P,SETSTB
CNTLEA:	MOVE	T,[-^D26,,"A"]	;UC CHARS (ENTRY FOR ^EA)
	PUSHJ	P,SETSTB
CNTLEV:	MOVE	T,[-^D26,,"A"+" "]	;LC CHARS (ENTRY FOR ^EV)
	JRST	CNTRXX

;CNTR X MATCHES ANY ARBITRARY CHARACTER

CNTRX:	MOVE	T,[-STABLN+4,,1]	;WANT TO ACCEPT ANYTHING AS A MATCH
CNTRXX:	PUSHJ	P,SETSTB	;EXCEPT NULL & SPCTAB & BEGPAG & ENDPAG
	JRST	SERCH5

;CNTR N REVERSES THE SENSE OF THE SEARCH FOR THE NEXT CHARACTER

CNTRN:	MOVE	T,[-STABLN+4,,1]	;STAB CTR & PTR
	PUSHJ	P,SETSTB	;SET CURRENT POSITION BIT FOR ALL CHARS
	TXO	F2,S.CTLN	;SET ^N FLAG
	JRST	SERCH2

;SET STAB BITS AS INDICATED BY T & D

SETSTB:	XORM	D,STAB(T)
	AOBJN	T,.-1
	POPJ	P,

;DISPATCH TABLE FOR 2ND SCAN OF SEARCH STRING

S2TABL:	XWD	CNTRE,.CHCNE	;^E
	XWD	CNTRG,.CHBEL	;^G
	XWD	CNTRX,.CHCNX	;^X
	XWD	CNTRN,.CHCNN	;^N
	XWD	CNTRS,.CHCNS	;^S
	XWD	CNTRV,.CHCNV	;^V
	XWD	CNTRW,.CHCNW	;^W
	XWD	CNTRL,.CHCBS	;^\
	XWD	CNTRU,.CHCCF	;^^
S3TABL:	XWD	CNTRT,.CHCNT	;^T
	XWD	CNTRQ,.CHCNQ	;^Q
	XWD	CNTRR,.CHCNR	;^R
	XWD	CNTR33,.CHESC	;ALTMODE
	XWD	0,0		;END OF LIST
IFN	FTNCM1,<
	SUBTTL	VERIFY COMMAND  "V"

VERIFY:	TXNE	FF,F.ARG2		; 2 ARGS ARE ILLEGAL
	ERROR	E.TAV			; TOLD YOU SO
	PUSHJ	P,CHK2			; FIND OUT THE 1 ARG
	PUSH	P,B			; SAVE IT ON THE STACK
	MOVNS	B,B			; NEGATE IT
	ADDI	B,1			; MAKE IT 1-(B)
	TXO	FF,F.ARG		; FLAG THAT WE HAVE ONE ARG
	PUSHJ	P,TYPE			; TYPE THE LINE
	POP	P,B			; GET THIS ARG
	PUSHJ	P,TYPE			; TYPE (B) LINES
	TXZ	FF,F.ARG		; TURN THIS OFF
	JRST	RET			; AND RETURN
>
SUBTTL	^E COMMANDS

CNTRE:	CHKEO	EO21,SERCH4	;IF EO=1, ^E IS JUST TEXT
	ILDB	CH,AA		;GET CHAR. AFTER ^E
	SOJL	B,CNTREE	;NONE THERE
	MOVEI	T,S4TABL	;GO TO PROPER ^E COMMAND
	PUSHJ	P,DISPAT	;TO SET SPECIFIED CHARACTER BITS
CNTREE:	ERROR	E.ICE

;DISPATCH TABLE FOR ^E COMMANDS

S4TABL:	XWD	CNTLEA,"A"	;^EA	ACCEPT ANY ALPHA
	XWD	CNTLEV,"V"	;^EV	ACCEPT ANY L.C. ALPHA
	XWD	CNTLEW,"W"	;^EW	ACCEPT ANY U.C. ALPHA
	XWD	CNTLED,"D"	;^ED	ACCEPT ANY DIGIT
	XWD	CNTLEL,"L"	;^EL	ACCEPT ANY E-O-L CHAR.
	XWD	CNTLES,"S"	;^ES	ACCEPT A STRING OF SPACES OR TABS
	XWD	CNTLEN,74	;^E<NNN>	ACCEPT ASCII <NNN>
	XWD	CNTLEB,133	;^E[A,B,C]	ACCEPT A OR B OR C
	XWD	0,0		;END OF LIST
SUBTTL	^EW, ^ED, ^EL, ^ES COMMANDS

;^EW

CNTLEW:	MOVE	T,[-^D26,,"A"]	;UPPER CASE ALPHABETIC CHARS.
	JRST	CNTRXX

;^ED

CNTLED:	MOVE	T,[-^D10,,"0"]	;DIGITS
	JRST	CNTRXX

;^EL

CNTLEL:	MOVE	I,Z		;IS LAST CHAR IN BUFR AN EOL?
	CAMG	I,BEG
	JRST	CNTLE3		;NO
	SUBI	I,1
	PUSHJ	P,GET
	CAIL	CH,.CHLFD
	CAILE	CH,.CHFFD
CNTLE3:	XORM	D,STAB+ENDPAG	;NO, ENDPAG IS GOOD FOR A MATCH
	MOVE	T,[-3,,.CHLFD]	;LF, VT, FF
	JRST	CNTRXX

;^ES

CNTLES:	XORM	D,STAB+40	;SPACE
	XORM	D,STAB+11	;TAB
	XORM	D,STAB+SPCTAB	;& SPACE/TAB STRING BIT
	JRST	SERCH5

;SKIP OVER A STRING OF SPACES AND/OR TABS WHILE SEARCHING

SPTB:	ADDI	I,1		;ADVANCE TO NEXT BUFFER LOCATION
	CAML	I,UPPERB	;END-OF BUFFER?
	JRST	S4C		;YES, NO MORE SPACE/TABS
	MOVEM	TT1,ERR1	;SAVE CURRENT BYTE PTR (USING ERR1 AS TMP)
	ILDB	CH,TT1		;LOOK AT NEXT CHAR
	CAIE	CH," "		;IS IT A SPACE?
	CAIN	CH,.CHTAB	;OR TAB?
	JRST	SPTB		;YES, KEEP SKIPPING
	MOVE	TT1,ERR1	;NO, END OF SPACE/TAB STRING
	JRST	S4C		;RESTORE BYTE-POINTER & CONTINUE SEARCH
SUBTTL	^E[A,B,C,...]

CNTLEB:	AOS	SCESQB		;BUMP ^E[...] NEST CTR
CNTLE0:	PUSHJ	P,SERCH2	;GET CHAR FROM OR-STRING
	ILDB	CH,AA		;GET SEPARATOR
	SOJL	B,CNTREE
	CAIN	CH,","		;MORE TO GO?
	JRST	CNTLE0		;COMMA IMPLIES YES
	CAIE	CH,"]"		;END OF OR-STRING?
	ERROR	E.ICE
	SOS	SCESQB		;DECREMENT ^E[...] NEST CTR
	JRST	SERCH5		;YES

;^E<NNN>	(NNN IS OCTAL FOR A SINGLE ASCII CHAR)

CNTLEN:	MOVEI	A,0		;CLR NUMBER ACCUMULATOR
CNTLE1:	ILDB	CH,AA		;GET A DIGIT
	SOJL	B,CNTREE	;SHOULDN'T RUN OUT
	CAIN	CH,">"		;RIGHT ANGLE-BRACKET?
	JRST	CNTLE2		;YES, END OF NUMBER
	CAIL	CH,"0"		;IS IT A DIGIT?
	CAILE	CH,"7"
	ERROR	E.ICE
	LSH	A,3		;YES, SCALE UP THE PREVIOUS VALUE
	ADDI	A,-60(CH)	;AND ADD IN THE NEW DIGIT
	JRST	CNTLE1		;TRY FOR MORE
CNTLE2:	ANDI	A,177		;EXTRACT AN ASCII CHAR.
	XORM	D,STAB(A)	;AND SET THE CORRESP. BIT
	JRST	SERCH5
SUBTTL	RANDOM ^<CHAR> PROCESSORS

;^R IS SAME AS ^Q (PROVIDED EO NOT = 1)
;EXCEPT IT DOESN'T CAUSE RUBOUT PROBLEMS

CNTRR:	CHKEO	EO21,SERCH4	;IF EO=1, ^R IS JUST TEXT

;^Q CAUSES NEXT CHAR TO BE TAKEN AS TEXT EVEN IF IT IS
;A CTRL CHAR. OR THE TERMINATOR

CNTRQ:	ILDB	CH,AA		;GET NEXT CHAR
	SOJA	B,SRCH2E	;& PROCESS AS ORDINARY TEXT

;^V CAUSES NEXT CHAR TO BE TAKEN AS LOWER CASE
;^V^V SETS LOWER CASE MODE UNTIL FURTHER NOTICE

CNTRV:	CHKEO	EO21,SERCH4	;IF EO=1, ^V IS JUST TEXT
	PUSHJ	P,C.V		;SET ^V FLAGS
	JRST	SERCH2

;^W CAUSES NEXT CHAR TO BE TAKEN WITHOUT CONVERSION
;^W^W SETS STANDARD CASE MODE UNTIL FURTHER NOTICE

CNTRW:	CHKEO	EO21,SERCH4	;IF EO=1, ^W IS JUST TEXT
	PUSHJ	P,C.W		;SET ^W FLAGS
	JRST	SERCH2

;FIRST ^\ CHANGES MATCH MODE TO ACCEPT EITHER UC OR LC
;SECOND ONE TURNS ACCEPT EITHER FLAG OFF

CNTRL:	CHKEO	EO21,SERCH4	;IF EO=1, ^\ IS JUST TEXT
	TXC	F2,S.EMAT	;COMPLEMENT ACCEPT EITHER FLAG
	JRST	SERCH2

;IF SEARCHING FOR ALTMODE, AND IF EO=1, 033 & 175 ARE MATCHES

CNTR33:	CHKEO	EO21,.+2	;EO=1?
	JRST	SERCH4		;NO, ACCEPT 033 ONLY
	XORM	D,STAB+175	;YES, MARK 175 AS ACCEPTABLE MATCH
	JRST	SERCH4		;& 033

;^^ CAUSES IMMEDIATELY FOLLOWING @,[,\,],^,_ TO BE CONVERTED TO LC RANGE

CNTRU:	CHKEO	EO21,SERCH4	;IF EO=1, ^^ IS TEXT
	ILDB	CH,AA		;GET NEXT CHAR
	PUSHJ	P,CVTSPC	;CONVERT TO LC IF @, ETC
	SOJA	B,SRCH2E

;^T DISABLES ALL CNTRL COMMANDS EXCEPT ^Q,^R,^T AND ALLOWS ALL OTHER
;CNTRL CHARS AS TEXT.  THE NEXT ^T TURNS THE ^T SWITCH BACK OFF.

CNTRT:	CHKEO	EO21,SERCH4	;IF EO=1, ^T IS TEXT
	TXC	F2,S.NCCT
	JRST	SERCH2

;^GI CAUSES THE TEXT IN Q REGISTER I TO BE SUBSTITUTED INTO THE
;SEARCH STRING AT THIS POINT.

CNTRG:	CHKEO	EO21,SERCH4	;IF EO=1, ^G IS PLAIN TEXT
	ILDB	CH,AA		;GET NAME OF Q-REG
	SOJL	B,CNTRGE	;IF NO MORE, THEN ERROR
	SKIPE	SCESQB		;CANT BE IN THE MIDDLE OF A ^E[...]
	JRST	CNTRGE		;...
	PUSH	PF,AA		;SAVE POINTER  (MUST USE Q-REG STACK)
	PUSH	PF,B		;AND COUNT
	AOS	CTGLEV		;INCREMENT Q-REG NEST COUNTER
	PUSH	P,CPTR		;SET UP CPTR IN CASE OF ERROR (PAIN!)
	MOVEM	AA,CPTR		;NOW Q REG ERROR WILL GET THE RIGHT CHAR
	PUSHJ	P,QREGV2	;INIT Q-REG ACCESS
	PUSHJ	P,QTEXEI
	PUSHJ	P,GTQCNT	;NUMBER OF CHARACTERS IN C
	POP	P,CPTR		;RESTORE CPTR
	MOVE	AA,I		;SET UP NEW CHARACTER POINTER
	IDIVI	AA,5
	HLL	AA,BTAB-1(AA+1)
	MOVE	B,C		;SET UP NEW COUNT
	JRST	SERCH2		;RESUME SCANNING SEARCH STRING

CNTRG2:	POP	PF,B		;END OF Q-REG TEXT--RESTORE PREV LEVEL
	POP	PF,AA
	SOS	CTGLEV		;DECREMENT NEST COUNTER
	JRST	SERCH2

CNTRGE:	ERROR	E.ICG		;ERROR IN ^G TEXT ARGUMENT
SUBTTL	F SEARCHES

FCMD:	PUSHJ	P,SKRCH		;GET CHAR AFTER F
	ERROR	E.MEF
	TXO	FF,F.SRCH	;SET F-SEARCH FLAG
	TRZ	CH,40		;UPPER OR lower CASE
	CAIN	CH,"S"		;FS?
	JRST	SERCH		;YES
	CAIN	CH,"N"		;FN?
	JRST	SERCHP		;YES
	TXZ	FF,F.SRCH	;MUST NOT BE ON
	CAIE	CH,"D"		;SEARCH AND DESTROY
	ERROR	E.IFC
	TXO	F2,S.DELS	;TO DELETE
	JRST	SERCH		;S SEARCH ONLY
SUBTTL	<>	ITERATION BRACKETS.  COMMAND INTERPRETATION IS SENT

;	BACK TO THE < WHEN THE > IS ENCOUNTERED.

LSSTH:	PUSH	P,ITERCT	;SAVE ITERATION COUNT
	PUSH	P,COMAX		;KEEP MAX FOR GARBAGE COLLECTION
	PUSH	P,CPTR		;SAVE COMMAND STATE
	PUSH	P,COMCNT
	SETOM	ITERCT		;ITERCT:=-1
	PUSH	P,ITERCT	;-1 FLAGS ITERATION ON PDL
	TXZN	FF,F.ARG	;IS THERE AN ARGUMENT?
	JRST	RET		;NO
	JUMPLE	B,INCMA1	;IF ARG NOT > 0, SKIP OVER <>
	MOVEM	B,ITERCT	;YES. ITERCT:=ARGUMENT
	JRST	RET


GRTH:	SKIPN	XCTING		;CONTINUE?
	JRST	GO
	SKIPGE	A,(P)		;IS THERE A LEFT ANGLE BRACKET?
	JRST	GRTH2		;YES. OTHERWISE ITS A MISSING < OR
	SOJE	A,GRTH9		;SOMETHING LIKE <...(...>
	ERROR	E.MLA
GRTH2:	SOSN	ITERCT		;ITERCT:=ITERCT-1. DONE?
	JRST	INCMA2		;YES
	MOVE	A,-2(P)		;NO. RESTORE COMMAND STATE TO START OF ITERATION.
	MOVEM	A,CPTR
	MOVE	A,-1(P)
	MOVEM	A,COMCNT
	TXNE	FF,F.TRAC	;TRACING?
	PUSHJ	P,CRR		;YES. OUTPUT CRLF
	JRST	RET

GRTH9:	ERROR	E.MRP
;;	IF NOT IN AN ITERATION, GIVES ERROR.  IF IN AN ITERATION AND
;	IF THE MOST RECENT SEARCH FAILED, SEND COMMAND TO FIRST UNMATCHED
;	> TO THE RIGHT.  OTHERWISE, NO EFFECT.

SEMICL:	SKIPL	(P)		;ERROR IF NOT IN <...>
	ERROR	E.SNI
	TXNN	FF,F.ARG	;YES. IF NO ARG,
	MOVE	B,SFINDF	;USE LAST SEARCH SWITCH (0 OR -1).
	JUMPL	B,CD		;IF ARG <0, JUST RET + EXECUTE LOOP
INCMA1:	MOVEI	TT,">"		;SKAN FOR >
	MOVEI	TT1,"<"		;IGNORE <...> STRINGS
	PUSHJ	P,SKAN

	ERROR	E.MRA
INCMA2:	SUB	P,[XWD 3,3]	;POP OUT A LEVEL
	POP	P,COMAX		;RESTORE MAX. COUNT
	POP	P,ITERCT
	JRST	RET



;!TAG!	TAG DEFINITION.  THE TAG IS A NAME FOR THE LOCATION IT
;	APPEARS IN IN A MACRO, ITERATION OR COMMAND STRING.

EXCLAM:	PUSHJ	P,SKRCH		;LOOK FOR NEXT !
	ERROR	E.UTG
	CAIE	CH,"!"
	JRST	EXCLAM
	JRST	RET
SUBTTL	OTAG$	GO TO THE TAG NAMED TAG.

;	 THE TAG MUST APPEAR IN THE

;	CURRENT MACRO OR COMMAND STRING.

OG:	MOVE	A,CPTR
	MOVE	AA,A
	IDIVI	AA,17
	CAMN	A,SYMS(B)
	JRST	OGFND
	SKIPN	SYMS(B)
	JRST	OGNF
	CAMN	A,SYMS+1(B)

ES1:	AOJA	B,OGFND
	SKIPN	SYMS+1(B)
ES2:	AOJA	B,OGNF
	CAMN	A,SYMS+2(B)
	AOJA	B,ES1
	SKIPN	SYMS+2(B)
	ADDI	B,2

OGNF:	PUSH	P,CPTR
	PUSH	P,B
	MOVEI	D,STAB
OG1:	PUSHJ	P,SKRCH		;GET NEXT COMMAND CHAR

	ERROR	E.MEO
	CAIL	D,STAB+STABLN-1	;DON'T RAVAGE YOURSELF
	ERROR	E.TTL
	MOVEM	CH,(D)		;STAB ... _ TAG
	CAIE	CH,.CHESC
	AOJA	D,OG1
	MOVEI	A,"!"		;TAG TERMINATOR
	MOVEM	A,(D)
	SETZM	1(D)
	MOVE	B,COMCNT	;MAKE PTR TO START OF THIS COMMAND LEVEL
	SUB	B,COMAX
	IDIVI	B,5
	ADD	B,CPTR
	JUMPE	E,OG7		;NO REMAINDER
	SOS	B
	MOVMS	E
	JRST	.(E)
	IBP	B
	IBP	B
	IBP	B
	IBP	B
OG7:	MOVEM	B,CPTR
	MOVE	B,COMAX		;GET # OF CMD CHARS AT THIS LEVEL
	MOVEM	B,COMCNT
OG2:	MOVEI	TT,"!"		;SKAN FOR !
	MOVEI	TT1,-1		;NO SECONDARY CHAR.
	PUSHJ	P,SKAN
	ERROR	E.TAG
	TXO	F2,S.NTRC	;DON'T TYPE EVERY TAG WHILE TRACING
	MOVEI	E,STAB		;INIT SEARCH STRING TO 1ST CHAR AFTER !
OG5:	SKIPN	(E)		;OVER STRING?
	JRST	OG3		;YES
	PUSHJ	P,SKRCH		;NO. GET A CHAR
	ERROR	E.TAG
	CAMN	CH,(E)		;MATCH ?
	AOJA	E,OG5		;YES. MOVE ON.
	CAIN	CH,"!"		;NO, ARE WE AT END OF A TAG?
	JRST	OG2		;YES, LOOK FOR ANOTHER
	MOVEI	E,"!"		;NO, SKIP TO NEXT !
OG6:	PUSHJ	P,SKRCH		;GET NEXT CHAR OF TAG
	ERROR	E.UTG
	CAIE	CH,(E)		;!?
	JRST	OG6		;NO, KEEP GOING
	JRST	OG2		;YES, LOOK FOR ANOTHER TAG

OG3:	TXZ	F2,S.NTRC	;RE-ENABLE TRACING
	POP	P,A		;GET INDEX TO SYMBOL TABLE
	POP	P,SYMS(A)	;SAVE POSITION OF THIS O COMMAND
	MOVE	B,COMCNT	;SAVE COMCNT FOR THIS TAG
	MOVEM	B,CNTS(A)
	MOVE	B,CPTR		;SAVE TAG POSITION IN COMMAND STRING
	MOVEM	B,VALS(A)
	JRST	RET


OGFND:	MOVE	A,VALS(B)
	MOVEM	A,CPTR
	MOVE	A,CNTS(B)
	MOVEM	A,COMCNT
	JRST	RET
SUBTTL	" ' PROCESSING

;N"G	HAS NO EFFECT IF N IS GREATER THAT 0.  OTHERWISE,
;	SEND COMMAND INTERPRETATION TO NEXT MATCHING '.
;	THE " AND ' MATCH SIMILAR TO ( AND ).
;N"L	SEND COMMAND TO MATCHING ' UNLESS N<0.
;N"N	SEND COMMAND TO MATCHING ' UNLESS N NOT = 0.
;N"E	SEND COMMAND TO MATCHING ' UNLESS N=0.
;N"F	SEND COMMAND TO MATCHING ' UNLESS N=0.
;N"U	SEND COMMAND TO MATCHING ' UNLESS N=0.
;N"T	SEND COMMAND TO MATCHING ' UNLESS N<0.
;N"S	SEND COMMAND TO MATCHING ' UNLESS N<0.
;N"C	SEND COMMAND TO MATCHING ' UNLESS THE VALUE OF N AS AN ASCII
;	CHARACTER IS A LETTER, NUMBER, PERIOD (.), DOLLAR SIGN ($),
;	OR PER CENT (%).
;N"A	SEND COMMAND TO MATCHING ' UNLESS THE VALUE OF N AS AN ASCII
;	CHARACTER IS ALPHABETIC.
;N"D	SEND COMMAND TO MATCHING ' UNLESS THE VALUE OF N AS AN ASCII
;	CHARACTER IS A DIGIT.
;N"V	SEND COMMAND TO MATCHING ' UNLESS THE VALUE OF N AS AN ASCII
;	CHARACTER IS LOWER CASE ALPHABETIC.
;N"W	SEND COMMAND TO MATCHING ' UNLESS THE VALUE OF N AS AN ASCII
;	CHARACTER IS UPPER CASE ALPHABETIC.

DQUOTE:	TXNN	FF,F.ARG	;ERROR IF NO ARG BEFORE "
	ERROR	E.NAQ
	PUSHJ	P,SKRCH		;GET CHAR AFTER "
	ERROR	E.MEQ
	MOVEI	T,DQTABL	;INDEX DISPATCH TABLE
	PUSHJ	P,DISPAT	;DISPATCH FOR CHAR. AFTER "
	ERROR	E.IQC

;" COMMAND DISPATCH TABLE

DQTABL:	XWD	DQ.G,"G"
	XWD	DQ.L,"L"
	XWD	DQ.N,"N"
	XWD	DQ.E,"E"
	XWD	DQ.C,"C"
	XWD	DQ.L,"T"
	XWD	DQ.E,"F"
	XWD	DQ.L,"S"
	XWD	DQ.E,"U"
	XWD	DQ.A,"A"
	XWD	DQ.D,"D"
	XWD	DQ.V,"V"
	XWD	DQ.W,"W"
	XWD	0,0		;END OF LIST
SUBTTL	EXECUTE INDIVIDUAL " COMMANDS

DQ.V:	TRZN	B,40		;EXECUTE "V
	JRST	NOGO		;IF BIT 30 NOT ON IT CAN'T BE L.C.
DQ.A:	TRZ	B,40		;EXECUTE "A -- TREAT UC & LC ALIKE
DQ.W:	CAIL	B,"A"		;EXECUTE "W
	CAILE	B,"Z"
	JRST	NOGO		;IT IS NOT A LETTER
	JRST	RET		;IT IS A LETTER
DQ.D:	CAIL	B,"0"		;EXECUTE "D
	CAILE	B,"9"
	JRST	NOGO		;IT IS NOT A DIGIT
	JRST	RET		;IT IS A DIGIT
DQ.C:	PUSHJ	P,CKSYM1	;EXECUTE "C
	JRST	RET		;IT IS A SYMBOL CHAR
	JRST	NOGO		;IT'S NOT A SYMBOL CHAR
DQ.G:	MOVNS	B		;EXECUTE "G
DQ.L:	JUMPL	B,RET		;EXECUTE "L
	JRST	NOGO		;TEST FAILED
DQ.N:	JUMPN	B,RET		;EXECUTE "N
	JRST	NOGO		;TEST FAILED
DQ.E:	JUMPE	B,RET		;EXECUTE "E, "F, "U
NOGO:	MOVEI	TT,"'"		;SKAN FOR '
	MOVEI	TT1,""""	;IGNORE "...' STRINGS
	PUSHJ	P,SKAN
	ERROR	E.MAP
	JRST	RET
SUBTTL	ROUTINE TO TEST CHARACTER FOR $,%,.,0-9,A-Z

;CALL	PUSHJ P,CKSYM
;	RETURN IF $,%,.,0-9,A-Z
;	RETURN ON ALL OTHER CHARACTERS

CKSYM:	MOVEI	B,(CH)		;ENTER AT CKSYM1 IF CHAR ALREADY IN B
CKSYM1:	CAIE	B,"$"		;$ OR %?
	CAIN	B,"%"
	POPJ	P,		;YES
	CAIN	B,"."		;NO. POINT?
	POPJ	P,		;YES.
	CAIGE	B,"0"		;NO. DIGIT OR LETTER?
	JRST	CPOPJ1		;NO
	CAIG	B,"9"		;MAYBE. DIGIT?
	POPJ	P,		;YES.
CKSYM2:	TRZ	B,40		;LC TO UC
	CAIL	B,"A"		;LETTER?
	CAILE	B,"Z"
	JRST	CPOPJ1		;NO.
	POPJ	P,		;YES
SUBTTL	ERROR MESSAGE PRINTOUT

ERRP:	MOVE	P,PDLSAV	;RESTORE PDL
	HRRZ	B,.JBUUO	;GET ERROR CODE
	LDB	D,[POINT 4,.JBUUO,12]	;GET SPECIAL CODE
	CAIE	B,'COR'		;CORE IS ALWAYS FATAL
	TRNN	D,10		;COLONABLE ERROR?
	TXZ	FF,F.COLN	;NO,TURN OFF FLAG
	TXZE	FF,F.COLN
	JRST	ABEGIN
ERRPDL:	SETZM	XCTING		;NO LONGER XCTING
	MOVE	B,.JBREL	;.JBREL NOW
	MOVEM	B,RELSAV
	SETZM	CCLSW		;NO PECULIAR THINGS FOR ME
	TXO	FF,F.EMSG	;ERROR PROCEDURE IN PROGRESS
	HRLZ	B,.JBUUO	;GET ERROR CODE
	CLRBFI			;CLEAR TTY
	PUSHJ	P,TTOPEN
	MOVEI	CH,"?"		;TYPE ?
	PUSHJ	P,TYOM
	MOVSI	TT,'TEC'
	HLR	TT,B
	MOVX	A,JW.WPR	;HOW MUCH WE PRINT
	TDNE	A,ERRLEN	;WELL
	PUSHJ	P,SIXBMS
	TRZ	D,10		;SPECIAL FLAG
	JUMPE	D,ERRP04	;NO SPECIAL ERROR EXTENSION
	CAIN	D,3		;FLAG=EE3?
	JRST	ERRP05		;YES
	MOVEI	CH,"-"		;NO, TYPE EXTENSION (MONITOR ERROR CODE)
	PUSHJ	P,TYOM
	LDB	B,[POINT 6,XFILNM+.RBEXT,35]	;GET UUO ERROR FLAG
	SOJLE	D,ERRP03	;1 IMPLIES IT IS A UUO ERROR
	HRRZI	B,IO.ERR	;GET I-O ERROR FLAGS
	AND	B,ARGSTO
ERRP03:	PUSHJ	P,OCTMS		;TYPE ERROR CODE IN OCTAL
ERRP04:	MOVE	B,ERRLEN	;HOW MUCH MESSAGE WANTED?
	TXNE	B,JW.WFL
	JRST	ERRP02
	PUSHJ	P,CRR		;HE WANTS ONLY ?XXX, SO END LINE
	JRST	ERRP5		;BETTER SEE IF HE WANTS MORE
ERRP02:	MOVEI	CH," "		;1ST LINE OF MESSAGE AUTOMATIC
	PUSHJ	P,TYOM		;TYPE TAB
ERRP0:	INIT	ERRCHN,IO.SYN	;INIT INPUT FROM SYS:
IFE BUGSW<	SIXBIT	/DSK/>
IFN BUGSW<	SIXBIT	/DSK/>		;IF DEBUGGING THEN GET TECO.ERR FROM DSK
	XWD	0,ERRHDR
	JRST	NOERRS		;CAN'T
	MOVE	TT,Z		;GET ACTUAL FIRST FREE LOC
	IDIVI	TT,5
	ADDI	TT,2
	MOVEI	T,<BUFSIZ+3>*2(TT)	;ROOM FOR 2 DISK BUFFERS?
	MOVE	B,.JBREL	;NO COMMENT
	CAML	T,.JBFF
	PUSHJ	P,GRABJR	;NO, GET 1K CORE
	EXCH	TT,.JBFF	;GET INPUT BUFFER
	INBUF	ERRCHN,2
	MOVEM	TT,.JBFF
	MOVSI	A,(SIXBIT /ERR/)
	MOVEM	A,TECERR+1	;SET UP FILE EXTENSION
	SETZM	TECERR+2
	SETZM	TECERR+3
	HRL	A,JOBN		;GET JOBNUMBER
	HRRI	A,.GTPRG	;& JOBNAME TABLE ADDRESS
	GETTAB	A,		;GET JOBNAME
	JRST	ERRP01		;CAN'T
	MOVEM	A,TECERR	;SET FILE NAME
	LOOKUP	ERRCHN,TECERR	;LOOKUP JOBNAME.ERR
	JRST	ERRP01		;NOT THERE, SO USE TECO.ERR
	JRST	ERRP1		;FOUND
ERRP01:	MOVE	A,[SIXBIT /TECO/]
	MOVEM	A,TECERR
	HRROI	A,-25		;(.GTFPN)
	GETTAB	A,
	JRST	NOERRS
	MOVEM	A,TECERR+3	;READ FROM TECO'S HOME DIRECTORY
	LOOKUP	ERRCHN,TECERR	;FIND TECO.ERR
	JRST	NOERRS		;NOT ON SYS:
ERRP1:	HRRZ	D,.JBUUO	;GET ERROR CODE AGAIN
ERRP2:	PUSHJ	P,ERRWRD	;GET A WORD FROM FILE IN A
	CAIN	D,(A)		;IS THIS THE CODE WE WANT?
	JRST	ERRP3		;YES
	JUMPN	A,ERRP2		;NO, KEEP LOOKING IF NOT END OF INDEX
;FALL INTO ?TECEEE IF END OF INDEX
NOERRS:	TXO	FF,F.XPLN+F.EM	;CANT DO /
	JSP	A,CONMES	;PRINT BAD NEWS
	ASCIZ	/
?TECEEE	Unable to Read Error Message File
/
	JRST	ERRP5
ERRP3:	HLRZS	A		;GET DISK ADR OF MESSAGE
	IDIVI	A,BUFSIZ	;GET DISK BLOCK AND WORD ADDR
	USETI	ERRCHN,1(A)	;TELL MONITOR WHAT BLOCK I WANT
	IN	ERRCHN,0	;GET THAT BLOCK
	CAIA			;BETTER WORK
	JRST	NOERRS		;DIDN'T
	ADDM	AA,ERRHDR+.BFPTR	;FIX ADDR
	IMULI	AA,5		;CHANGE TO CHARS
	SUB	AA,ERRHDR+.BFCNT	;GET CORRECT COUNT
	MOVNM	AA,ERRHDR+.BFCNT	;FIX IT
	PUSHJ	P,ERRPRN	;YES, PRINT EVERYTHING UP TO THE LF
	TXO	FF,F.EM		;NOTE THAT THE 1ST LINE HAS BEEN TYPED
ERRP5:	MOVE	A,COMAX
	SUB	A,COMCNT
	MOVEM	A,ERR1		;ERR1:=COMAX-COMCNT
	MOVE	A,CPTR
	MOVEM	A,ERR2		;ERR2:=CPTR
	MOVE	A,ERRLEN	;DOES HE WANT THE WHOLE THING AUTOMATICALLY?
	TXNE	FF,F.XPLN	;MAYBE PREVENT LOOPING IF NO ERROR MES FILE
	JRST	ERRP6
	TXNE	A,JW.WCN
	JRST	XPLAIN

ERRP6:	TXZN	FF,F.CCL	;GET HERE FROM A "TECO" COMMAND?
	JRST	ERRP6A		;NO
	LDB	CH,[POINT 6,XFILNM+.RBEXT,35]	;CHECK FOR ?FNF-00
	JUMPN	CH,ERRP6A	;IT'S NOT
	HRRZ	CH,.JBUUO	;MAYBE
	CAIN	CH,(SIXBIT /FNF/)
	MONRT.			;EXIT, BUT ALLOW CONT "/" FOR ERROR
ERRP6A:	MOVEI	CH,"*"		;TYPE * FOR NEXT COMMAND
	PUSHJ	P,TYOM
	TXO	FF,F.DDTM
	PUSHJ	P,TYI		;GET A CHARACTER NOW
	CAIN	CH,"?"		;QUESTION MARK?
	JRST	ERRTYP		;YES, TYPE BAD COMMAND
	TXNE	FF,F.XPLN	;EXPLANATION TYPED YET?
	JRST	ERRP7		;YES, CAN'T DO THAT AGAIN
	CAIE	CH,"/"		;NO, IS IT A SLASH?
	JRST	ERRP7		;NO
	TXNN	FF,F.EM		;YES, 1ST LINE DONE YET?
	JRST	ERRP0		;NO
	JRST	XPLAIN		;OK, TYPE MORE EXPLANATION OF ERROR

ERRP7:	RELEAS	ERRCHN,
	TXNN	FF,F.XPLN!F.EM	;MED OR LONG MSG TYPED ?
	JRST	GOE		;NO, SKIPE CORE CONTRACTION
	MOVE	B,RELSAV	;GO BACK TO CORE WE HAD BEFORE
	CORE	B,
	JFCL			;REDUCTION WON'T FAIL
	JRST	GOE		;GET REST OF COMMAND
ERRPRN:	PUSHJ	P,ERRCHR	;GET A CHAR FROM ERR. FILE
ERRPR2:	CAIE	CH,.CHCNN	;^N?
	JRST	ERRPR3		;NO, SKIP
	PUSHJ	P,ERRCHR	;GET 1ST DIGIT AFTER ^N
	MOVEI	T,-60(CH)
	IMULI	T,^D10		;PUT IT IN TEN'S PLACE
	PUSHJ	P,ERRCHR	;GET 2ND DIGIT
	ADDI	T,-60(CH)
	ROT	T,-1		;DIVIDE TOTAL BY 2 & SAVE BIT 35
	HLRZ	CH,ETABL(T)	;GET LEFT SIDE ADDR IN CASE EVEN
	TLNE	T,400000	;EVEN OR ODD?
	HRRZ	CH,ETABL(T)	;ODD, GET ADDR FROM RIGHT SIDE
	JRST	(CH)		;TYPE SPECIAL INFORMATION

ERRPR3:	PUSHJ	P,TYOM		;PRINT NORMAL CHARS.
	CAIE	CH,.CHLFD	;LF?
	JRST	ERRPRN		;NO
	POPJ	P,

;GET A CHARACTER FROM SYS:TECO.ERR

ERRCHR:	SOSGE	ERRHDR+.BFCNT	;ANY CHARS. IN BUFFER?
	JRST	ERRCH2		;NO
	ILDB	CH,ERRHDR+.BFPTR	;YES, GET NEXT
	POPJ	P,		;DO NOT IGNORE NULLS
ERRCH2:	IN	ERRCHN,0	;GET NEXT BUFFER
	JRST	ERRCHR		;OK, NOW GET A CHAR.
ERRCH3:	POP	P,A		;UNABLE TO READ TECO.ERR
	JRST	NOERRS

;GET 1K CORE FOR ERROR MESSAGE FILE READ-IN

GRABJR:	ADDI	B,^D1024	;ADD 1K
	CORE	B,
	JRST	ERRCH3		;CAN'T GET IT
	POPJ	P,

;CAN'T PRINT ERROR FILE BECAUSE OF NO CORE

ERRP05:	TXO	FF,F.XPLN+F.EM
	RELEAS	INICHN,
	JSP	A,CONMES
	ASCIZ	/ Storage Capacity Exceeded
/
	PUSHJ	P,ECORE		;GARBAGE COLLECT AND SMALLIFY
	MOVE	B,.JBREL	;.JBREL NOW
	MOVEM	B,RELSAV	;SO AS TO NOT CAUSE HUGIFICATION
	JRST	ERRP6A		;DON'T GET I-O TO UNASSIGNED CHANNEL
SUBTTL	ROUTINE TO TYPE C(TT) IN SIXBIT

;CALL	MOVE TT,[SIXBIT /MESSAGE/]
;	PUSHJ P,SIXBMS
;	RETURN


SIXBMS:	SKIPN	CH,TT		;ALL SPACES?
	JRST	SIXBM2		;YES
	MOVNI	B,6
	MOVE	E,[POINT 6,TT]
	ILDB	CH,E
	JUMPE	CH,CPOPJ
SIXBM2:	ADDI	CH," "
	PUSHJ	P,TYOM
	AOJL	B,.-4
	POPJ	P,
SUBTTL	ERROR PROCESSING ROUTINES

ERRTYP:	SKIPN	AA,ERR2		;VALUE OF CPTR WHEN LAST ERROR OCCURRED.
	JRST	[MOVEI	CH,"*"	;THIS HAD TO BE IT
		 PUSHJ	P,TYOM	;TYPE IT
		 SKIPE	CH,EATCH	;GET Q REG NAME IF GOT THAT FAR
		 PUSHJ	P,TYOM	;TYPE IT
		 JRST	LASTQ]	;AND TYPE FINAL QUESTION MARK
	MOVEI	B,12
	SUBI	AA,2		;BACK POINTER UP 10 CHARACTERS.
	ILDB	CH,AA		;GET CHARACTER
	CAMG	B,ERR1		;WAS IT IN THE COMMAND BUFFER?
	PUSHJ	P,TYOM		;YES. TYPE IT.
	CAME	AA,ERR2		;HAVE WE REACHED THE BAD COMMAND?
	SOJA	B,.-4		;NO. DO IT AGAIN.
LASTQ:	JSP	A,CONMES	;PRINT A ? TO MARK END
	ASCIZ	/?
/
	JRST	ERRP6A

XPLA2:	PUSHJ	P,ERRPR2	;PRINT UP TO LF
XPLAIN:	PUSHJ	P,ERRCHR	;IS NEXT CHAR A "?" OR ^A,^B, ... ^H?
	CAILE	CH,10		;TEXT ENDS WITH A NULL OR CONTROL-A OR B
	JRST	XPLA2		;NO, KEEP GOING
XPLA1:	TXO	FF,F.XPLN	;SET FLAG THAT XPLANATION IS TYPED
	JRST	ERRP6		;YES, STOP HERE

;ROUTINE TO READ A WORD FROM THE FILE OPEN IN ASCII MODE

ERRWRD:	SOSGE	ERRHDR+.BFCNT	;ANY LEFT?
	JRST	ERRWR2		;NO, GET SOME
	MOVNI	A,4		;SUBTRACT 5 FROM COUNT
	ADDM	A,ERRHDR+.BFCNT	;(1 SUBTRACTED BY SOS ABOVE)
	AOS	A,ERRHDR+.BFPTR	;INCR ADR
	MOVE	A,(A)		;GET THE WORD
	POPJ	P,
ERRWR2:	IN	ERRCHN,0	;GET NEXT BUFFER
	JRST	ERRWRD		;READ
	JRST	ERRCH3		;ERROR
SUBTTL	DISPATCH TABLE FOR SPECIAL INFORMATION TYPEOUT

;BASED ON CHARACTER AFTER CONTROL-N

ETABL:	XWD	ECOMCH,EOUTFL	;00  01
	XWD	EFILEN,EERNUM	;02  03
	XWD	EDEVNM,EPROJN	;04  05
	XWD	EARG1,EPROTC	;06  07
	XWD	EEBFN,EINFIL	;08  09
	XWD	EEBFIL,EIOFLG	;10  11
	XWD	ESTAB,ESKIP	;12  13
	XWD	EISKIP,0	;14  15
	XWD	EEOVAL,EESRCH	;16  17
	XWD	EECTRL,EESWIT	;18  19
	XWD	EECRTS,0	;20  21
SUBTTL	SPECIAL INFORMATION TYPEOUT ROUTINES


EECTRL:	SKIPA	CH,ARGSTO	;GET BAD CHAR FROM TEXT STRING
ECOMCH:	LDB	CH,CPTR		;GET LAST COMMAND STRING CHAR.
	PUSHJ	P,TYOS
	JRST	ERRPRN

EOUTFL:	MOVEI	TT1,OUTFIL	;AIM AT OUTPUT FILENAME
EOUTF2:	MOVE	TT,(TT1)
	PUSHJ	P,SIXBMS	;PRINT FILENAME
	HLLZ	TT,1(TT1)
	JUMPE	TT,ERRPRN	;SKIP REST IF NO EXTENSION
	MOVEI	CH,"."
	PUSHJ	P,TYOM
EOUTF3:	PUSHJ	P,SIXBMS	;PRINT EXTENSION
	JRST	ERRPRN

EFILEN:	MOVEI	TT1,XFILNM+.RBNAM	;GET FILENAME REF'D BY UUO
	JRST	EOUTF2

EERNUM:	LDB	B,[POINT 6,XFILNM+.RBEXT,35]	;GET 2-DIGIT ERROR CODE
EERNU1:	PUSHJ	P,OCTMS		;TYPE IT
	JRST	ERRPRN

EDEVNM:	MOVE	TT,FILDEV	;GET DEVICE NAME
	JRST	EOUTF3

EPROJN:	HLRZ	B,FILPPN	;TYPE PROJECT NUMBER
	PUSHJ	P,OCTMS
	MOVEI	CH,","		;TYPE COMMA
	PUSHJ	P,TYOM
	HRRZ	B,FILPPN	;TYPE PROGRAMMER NUMBER
	PUSHJ	P,OCTMS
	MOVE	TT1,[XWD -5,FILSFD]	;TYPE SFD'S
ERSFDS:	SKIPN	TT,(TT1)	;GET ONE
	JRST	ERRPRN		;IF ZERO, WE'RE DONE
	MOVEI	CH,","
	PUSHJ	P,TYOM
ERSFD1:	PUSHJ	P,SIXBMS
	AOBJN	TT1,ERSFDS	;LOOP BACK
	JRST	ERRPRN
EECRTS:
IFN CRT,<
	MOVE	TT1,[IOWD NUMCRT,CRTTAB+1]	;TYPE OUT VALID CRT TYPES
	MOVE	TT,(TT1)
	JRST	ERSFD1   >
IFE CRT,<JRST	ERRPPN>
EESWIT:	MOVE	TT,SWITHL	;GET I/O SWITCH NAME
	JRST	EOUTF3

EARG1:	MOVE	B,ARGSTO	;GET ARG BACK
EARG1A:	PUSHJ	P,DECMS		;PRINT IT
	JRST	ERRPRN

EPROTC:	LDB	B,[POINT 9,XFILNM+.RBPRV,8]	;GET FILE PROTECTION
	JRST	EERNU1

EEBFN:	MOVE	TT,BAKNAM	;EB FILENAME
	JRST	EOUTF3		;PRINT IT WITHOUT EXTENSION

EINFIL:	MOVEI	TT1,INFILE	;AIM AT INPUT FILENAME
	JRST	EOUTF2

EEBFIL:	MOVEI	TT1,BAKNAM	;AIM AT EB ORIGINAL FILENAME
	JRST	EOUTF2
EIOFLG:	HRRZI	B,IO.ERR	;RETRIEVE I/O ERROR FLAGS
	AND	B,ARGSTO
	JRST	EERNU1

ESTAB:	MOVEI	TT,STAB		;INDEX STAB WHERE TAG RESIDES
ESTAB1:	MOVE	CH,(TT)
	JUMPE	CH,ERRPRN	;THAT'S ALL
	PUSHJ	P,TYOS
	AOJA	TT,ESTAB1

EISKIP:	LDB	TT,[POINT 4,ARGSTO,21]	;GET I/O ERROR FLAGS
	SKIPA
ESKIP:	LDB	TT,[POINT 6,XFILNM+.RBEXT,35]
ESKIP2:	PUSHJ	P,ERRCHR	;LOOK FOR ^A
	CAIN	CH,2		;^B ENCOUNTERED?
	JRST	ERRPRN		;YES, PRINT DEFAULT MESSAGE
	CAIE	CH,1
	JRST	ESKIP2		;NOT ^A
	PUSHJ	P,ERRCHR	;GET 1ST DIGIT AFTER ^A
	MOVEI	T,-60(CH)
	LSH	T,3		;MULT BY 8
	PUSHJ	P,ERRCHR	;GET NEXT DIGIT
	ADDI	T,-60(CH)
	CAME	TT,T		;THIS THE NUMBER WE WANT?
	JRST	ESKIP2		;NO
	JRST	ERRPRN		;YES, NOW START PRINTING

EEOVAL:	MOVEI	B,EOVAL		;GET MAXIMUM EOFLAG FOR THIS VERSION
	JRST	EARG1A

EESRCH:	MOVE	TT,[POINT 7,SRHARG]	;GET PTR TO SEARCH STRING
	MOVE	B,SRHCTR	;& STRING CTR
EESRH2:	ILDB	CH,TT		;GET STRING CHAR
	PUSHJ	P,TYOS		;TYPE IT
	SOJE	B,ERRPRN	;WATCH STRING CTR
	JRST	EESRH2		;NOT FINISHED YET
SUBTTL	UUO HANDLER

UUOH:
	MOVEM	B,ARGSTO	;SAVE POSSIBLE ARG
	LDB	B,[POINT 9,.JBUUO,8]	;GET UUO TYPE
	CAIL	B,20		;CHKEO?
	JRST	CEO		;YES
	CAIN	B,1		;ERROR UUO?
	JRST	ERRP		;YES
UUOERR:	HRRZ	B,(P)		;ADDRESS OF ILLEGAL UUO
	SUBI	B,1
	MOVE	D,@B		;GET COMPLETE UUO INSTRUCTION
	MOVEM	D,FILPPN	;STORE IT
	SETZM	FILPPN+1	;WE DON'T WANT ANY SFD'S TYPED!
	ERROR	E.UUO

;CHKEO EO#,ADDR
;IF EOFLAG > EO#, RETURN AT CALL+1 (FEATURE IS LEFT ON)
;OTHERWISE GO TO ADDR (FEATURE IS TURNED OFF)

CEO:	PUSH	P,A		;SAVE AC
	LDB	B,[POINT 8,.JBUUO,12]	;GET EO TEST VALUE
	MOVE	A,EOFLAG	;GET LAST SETTING OF EOFLAG
	CAIG	A,(B)		;EOFLAG > TEST VALUE?
	JRST	CEO1		;NO
CEO2:	POP	P,A		;RESTORE AC A
	MOVE	B,ARGSTO	;RESTORE AC B
	POPJ	P,		;RETURN

CEO1:	HRRZ	A,.JBUUO	;GET DISPATCH ADDR
	HRRM	A,-1(P)		;PUT ON PDL AS RET. ADDR.
	JRST	CEO2
SUBTTL	COMMAND TO COMPLEMENT TRACE MODE. "?" AS A COMMAND

QUESTN:	TXCN	FF,F.TRAC	;COMPLEMENT TRACE FLAG
	JRST	RET
	PUSHJ	P,CRR		;TYPE CR/LF AFTER TRACE MODE EXIT
	JRST	RET

COMMEN:	PUSHJ	P,SKRCH		;GET A COMMENT CHAR
	ERROR	E.UCA
	CAIN	CH,1		;^A
	JRST	[TXNN	FF,F.TRAC
		 OUTPUT	TTY,	;FORCE OUTPUT TO TTY
		 JRST	RET]	;AND LEAVE
	TXNN	FF,F.TRAC	;OMIT DOUBLE TYPE-OUT WHEN TRACING
	PUSHJ	P,TYOM		;TYPE IT
	JRST	COMMEN

;ILLEGAL CHARACTER OR COMMAND

ERRA:	MOVE	B,CH		;DONT USE TEXT BUFFER, SO THAT ^<CHAR> WORKS
	ERROR	E.ILL
SUBTTL	ROUTINE TO RETURN STRING OPERATION STRING ARGUMENTS.

;ARGUMENTS ARE CHARACTER ADDRESSES IN THE DATA BUFFER.
;TRANSFORMS M,N OR N, WHERE THE LATTER SPECIFIES A NUMBER OF LINES,
;TO ARGUMENTS.
;CALL	PUSHJ P,GETARG
;	RETURN WITH FIRST ARGUMENT ADDRESS IN C, SECOND IN B.
;IF THE EO VALUE HAS BEEN SET TO 1, THE ONLY EOL CHAR IS LINE FEED.
;IF EO > 1, THE EOL CHARS ARE LF, VT, AND FF (& END OF BUFFER IF
;LAST CHAR IN BUFR IS NOT AN EOL)

GETARG:	TXNE	FF,F.ARG2	;IS THERE A SECOND ARGUMENT?
	JRST	GETAG6		;YES

;N	SIGN INDICATES DIRECTION RELATIVE TO PT.
GETNAG:	PUSHJ	P,CHK2		;NO, GET 1ST ARG (+ OR - 1 IF NONE THERE)
	MOVE	I,PT		;IN:=PT
GETAG4:	JUMPLE	B,GETAG2	;WAS LAST ARGUMENT FUNCTION -?
	CAMN	I,Z		;NO. ARGUMENT IS LOCATION OF NTH EOL FORWARD FROM PT.
				;IS PT AT END OF BUFFER?
	JRST	GETAG1		;YES.
	PUSHJ	P,GETINC	;NO. CH:=NEXT DATA BUFFER CHARACTER, IN:=IN+1
	PUSHJ	P,CKEOL		;IS IT AN EOL?
	JRST	GETAG4		;NO. TRY AGAIN.
	SOJG	B,GETAG4	;YES. NTH EOL?

GETAG1:	MOVE	B,I		;YES. RETURN FIRST ARGUMENT IN C
	MOVE	C,PT		;SECOND IN B.
	POPJ	P,

;M,N
GETAG6:	ADD	B,BEG		;C:=M+BEG
	ADD	C,BEG		;B:=N+BEG
	POPJ	P,

GETAG2:	SOS	I		;SET I FOR CHAR BEFORE PT
	CAMGE	I,BEG		;PASSED BEGINNING OF BUFFER?
	JRST	GETAG3		;YES. IN:=BEG
	PUSHJ	P,GETINC	;NO. CH:=NEXT DATA BUFFER CHARACTER. IN:=IN+1
	PUSHJ	P,CKEOL		;IS IT AN EOL?
	SOJA	I,GETAG2	;NO. BACK UP ONE POSITION AND TRY AGAIN.
	AOJLE	B,.-1		;YES. NTH EOL?

GETAG3:	CAMGE	I,BEG		;YES. PASSED BEGINNING OF BUFFER?
	MOVE	I,BEG		;YES. RESET TO BEGINNING.
	MOVE	C,I		;NO. RETURN FIRST ARGUMENT IN C.
	MOVE	B,PT		;SECOND IN B
	POPJ	P,
SUBTTL	ROUTINE TO RETURN IN CH THE CHARACTER TO THE RIGHT OF THE POINTER

;AND INCREMENT THE POINTER.
;CALL	MOVE I,POINTER (AS A CHARACTER ADDRESS)
;	PUSHJ P,GETINC
;	RETURN WITH CHARACTER IN CH AND POINTER TO CHARACTER IN IN.

GETINC:	PUSHJ	P,GET
	AOJA	I,CPOPJ

GET:	MOVE	TT,I
	IDIVI	TT,5
	HLL	TT,BTAB(TT1)
	LDB	CH,TT
	POPJ	P,

PUT:	MOVE	TT,OU
	IDIVI	TT,5
	HLL	TT,BTAB(TT1)
	DPB	CH,TT
	POPJ	P,

;CHARACTER TRANSLATION BYTE POINTER TABLE
;TRANSLATES 1 CHARACTER POSITION TO THE RIGHT OF A CHARACTER ADDRESS POINTER

	XWD	440700,0
BTAB:	XWD	350700,0
	XWD	260700,0
	XWD	170700,0
	XWD	100700,0
	XWD	10700,0

;CHECK IF CH = EOL CHARACTER
;CALL:	PUSHJ	P,CKEOL
;	RETURN IF CH NOT = EOL
;	RETURN IF CH IS EOL CHAR

CKEOL:	CAIN	CH,.CHLFD	;LINE FEED?
	JRST	CPOPJ1		;YES, IT IS AN EOL!
	CHKEO	EO21,CPOPJ	;IF EO=1, LF IS ONLY POSSIBLE EOL
	CAIE	CH,.CHVTB	;VERTICAL TAB?
	CAIN	CH,.CHFFD	;FORM FEED?
	AOS	(P)		;YES, SKIP RETURN
	POPJ	P,		;NO
SUBTTL	ROUTINES TO MOVE CHARACTERS AROUND

NROOMC:
IFN VC,<MOVEM	C,VVAL>		;SAVE LENGTH OF STRING
NROOM:	JUMPE	C,CPOPJ		;IF 0, THERE'S NOTHING TO DO
	MOVEM	17,AC2+15	;SAVE 17
	MOVEI	17,NROOM9	;ANTICIPATE GARBAGE COLLECTION
	MOVEM	17,GCRET	;THIS THE EXIT DISPATCH
	SETZM	CRREL
	SETZM	RREL
	MOVE	17,PT
	CAMN	17,Z		;PT=Z? I.E., DATA BUFFER EXPANSION?
	JRST	NROOM1		;YES.
NROOM0:	MOVE	17,[XWD 2,AC2]	;NO. SAVE ACS 2 THROUGH 16.
	BLT	17,AC2+14
	JUMPL	C,NROOM6	;DELETION?
	SETOM	GCFLG		;NO.

;MOVE STRING STORAGE UP C CHARACTERS STARTING AT PT.

NROOM9:	MOVE	F2,AC2+F2-2	;IN CASE CORE ERROR
	MOVE	17,Z
	ADD	17,C
	CAML	17,MEMSIZ	;WILL REQUEST OVERFLOW MEMORY?
	JRST	GC		;YES. GARBAGE COLLECT.
;MOVE FROM PT THROUGH Z UP C POSITIONS
	MOVE	14,C		;NO.
	IDIVI	14,5		;AC14:=Q(REQ/5), AC15:=REM(REQ/5)
	IMULI	15,7		;AC15:=(REM(REQ/5))*7
	MOVN	13,15		;AC13:=-(REM(REQ/5))*7
	MOVEI	15,-43(15)	;AC15:=(REM(REQ/5))*7-43
	MOVE	11,PT
	IDIVI	11,5		;AC11:=Q(PT/5), AC12:=REM(PT/5)
	MOVNI	16,-5(12)
	IMULI	16,7		;AC16:=-(REM(PT/5)-5)*7
	DPB	16,[XWD 300600,NROOM2]	;SET SIZE FIELD OF LAST PARTIAL WORD POINTER.
	ADDI	14,1(11)	;AC14:=Q(REQ/5)+Q(PT/5)+1
	MOVE	16,Z
	IDIVI	16,5		;AC16:=Q(Z/5)
	MOVEI	B,1(16)
	SUB	B,11		;B:=Q(Z/5)+1-Q(PT/5)=NO. OF WORDS TO MOVE.
;PUT MOVE ROUTINE IN FAST ACS
	HRLI	11,200000+B+A*40	;AC11:=MOVE A,[Q(PT/5)](B)
	HRLOI	12,241000+A*40	;AC12:=ROT A,-1
	HRLI	13,245000+A*40	;AC13:=ROTC A,-(REM(REQ/5))*7
	HRLI	14,202000+B+AA*40	;AC14:=MOVEM AA,[Q(PT/5)+1](B)
	HRLI	15,245000+A*40	;AC15:=ROTC A,(REM(REQ/5))*7-43
	MOVE	17,[JRST,NROOM7]	;AC16:=SOJGE B,11
	MOVE	16,.+1		;AC17:=JRST NROOM7
	SOJGE	B,11		;B:=B-1. DONE?
NROOM7:	ROTC	A,43(13)	;YES. STORE LAST PARTIAL WORD.
	DPB	A,NROOM2
	ADDM	C,Z		;Z:=Z+REQ
NROOM5:	MOVE	17,[XWD 2,AC2]	;RESTORE ACS AND RETURN.
	MOVSS	17
	BLT	17,17
	POPJ	P,

;A CALL FOR A BUFFER EXPANSION, WHERE PT=Z. IF
;THERE IS NOT ENOUGH ROOM, PERFORM THE GARBAGE COLLECTION ROUTINE
;IF THERE IS STILL NO ROOM, GET THE NECESSARY CORE FROM THE
;MONITOR TO SATISFY THIS REQUEST

NROOM1:	ADD	17,C		;TOTAL SPACE REQUIREMENT
	CAMG	17,MEMSIZ	;IS THERE ENOUGH?
	JRST	.+4		;YES, THEREFORE, UPDATE Z AND EXIT
	MOVEI	17,GCRETA	;EXIT DISPATCH FOR THE
	MOVEM	17,GCRET	;GARBAGE COLLECTION ROUTINE
	JRST	NROOM0		;GO DO THE GARBAGE COLLECTION
	ADDM	C,Z		;UPDATE Z, SIZE IS OK
	MOVE	17,AC2+15	;RESTORE AC#17
	POPJ	P,		;EXIT OUT


;NOT ENOUGH ROOM FOR THE EXPANSION, GARBAGE COLLECTION HAS BEEN
;PERFORMED, IF NEED BE, GRAB A K FROM THE MONITOR (OR MORE)

GCRETA:	MOVE	17,Z		;GET TOTAL SO FAR
	ADD	17,C		;ADD IN THE REQUEST
	MOVE	F2,AC2+F2-2
	CAML	17,MEMSIZ	;STILL IN NEED OF CORE?
	PUSHJ	P,GRABAK	;YES, GET THE REQUIRED CORE FROM THE MONITOR
	ADDM	C,Z		;UPDATE Z AND EXIT
	JRST	NROOM5		;RESTORE ALL AC'S AND RETURN TO SEQUENCE
;MOVE FROM PT+ABS(C) THROUGH Z DOWN ABS(C) POSITIONS
NROOM6:IFN BISSW,< ;KL10 BIS SUPPORT
	SKIPN	BIS		;KL10?
	JRST	NBIS6		;NO
	MOVE	15,PT		;CHARACTER ADDRESS OF TEXT POINTER
	IDIVI	15,5		;WORD ADDR
	HLL	15,BTAB-1(16)	;BYTE POINTER TO DESTINATION
	MOVE	11,Z		;LAST BYTE ADDR IN TEXT BUFFER
	ADDM	C,Z		;UPDATE Z
	MOVMS	12,C		;NUMBER OF CHARACTERS TO MOVE DOWN
	ADD	12,PT		;SOURCE BYTE
	SUB	11,12		;# BYTES TO MOVE
	MOVE	14,11		;# BYTES TO MOVE TO DESTINATION
	IDIVI	12,5		;SOURCE WORD ADDR
	HLL	12,BTAB-1(13)	;SOURCE BYTE POINTER
	SETZM	13		;NOT USED BY US
	EXTEND	11,[MOVSLJ	;MOVE STRING LEFT JUSTIFIED
		    EXP	0]	;NO FILL
E$$EMF:	ERROR	(EMF)		;EXTENDED MOVE FAILED
	JRST	NROOM3		;RESTORE ACS
NBIS6:> ;END IFN BISSW
	MOVE	14,PT		;INITIALIZE PARTIAL WORD POINTER.
	IDIVI	14,5		;AC14:=Q(PT/5), AC15:=REM(PT/5)
	MOVEM	14,B		;B:=Q(PT/5)
	HRRZM	14,NROOM4
	IMULI	15,7
	DPB	15,[XWD 300600,NROOM4]	;SIZE:=(REM(PT/5))*7
	MOVNI	15,-44(15)
	DPB	15,[XWD 360600,NROOM4]	;POSITION:=44-(REM(PT/5))*7
	MOVE	11,Z
	IDIVI	11,5		;AC11:=Q(Z/5)+1, AC12:=REM(Z/5)
	ADDI	11,1
	MOVE	13,C
	IDIVI	13,5
	ADDI	13,-1(11)	;AC13:=Q(Z/5)-Q(REQ/5)
	MOVNM	14,12		;AC12:=(REM(REQ/5))*7
	IMULI	12,7
	MOVNI	15,-43(12)	;AC15:=43-(REM(REQ/5))*7
	SUBI	B,1(13)		;B:=Q(PT/5)+Q(REQ/5)-Q(Z/5)-1:=# WORDS TO MOVE

NROOM8:	HRLI	11,200000+B+AA*40	;AC11:=MOVE AA,[Q(Z/5)+1](B)
	HRLI	12,245000+A*40	;AC12:=ROTC A,(REM(REQ/5))*7
	HRLI	13,202000+B+A*40	;AC13:=MOVEM A,[Q(Z/5)-Q(REQ/5)](B)
	MOVE	14,[ADDM A,@13]	;AC14:=ADDM A,@13
	HRLI	15,245000+A*40	;AC15:=ROTC A,43-(REM(REQ/5))*7
	MOVE	17,[JRST NROOM3]	;AC16:=AOJLE B,11
	ADDM	C,Z		;AC17:=JRST NROOM3
	LDB	C,NROOM4
	MOVE	A,@11		;Z:=C(Z)-REQ
	ROT	A,-1		;A:=Q(PT/5)+Q(REQ/5) RIGHT JUSTIFIED.
	MOVE	16,.+1
	AOJLE	B,11		;B:=B+1.  DONE?

NROOM3:	DPB	C,NROOM4	;YES. DEPOSIT PARTIAL WORD.
	JRST	NROOM5
SUBTTL	GARBAGE COLLECTOR

GC:	AOSE	GCFLG		;FIRST ATTEMPT?
	JRST	PRENR9		;TRY TO EXPAND MEMORY
	SETOM	GCPTR		;YES. GCPTR:=-1
	SETZM	SYMS		;CLEAR SYMS,VALS AND CNTS TABLES
	MOVE	T,[XWD SYMS,SYMS+1]
	BLT	T,SYMEND-1
	MOVEI	T,CPTR		;COMMAND BUFFER
	PUSHJ	P,GCMA
	MOVEI	T,(P)
	PUSHJ	P,GCMA		;NO. GARBAGE COLLECT ALL BYTE POINTERS ON IT.
	CAILE	T,PDL+1
	SOJA	T,.-2
	HRRZ	T,AC2+PF-2	;GARBAGE COLLECT Q-REG PUSHDOWN LIST.
	CAIL	T,PFL
	PUSHJ	P,GCM
	CAILE	T,PFL
	SOJA	T,.-2
	MOVE	T,[XWD -45,QTAB]	;GARBAGE COLLECT Q-REGISTERS.
	PUSHJ	P,GCM
	AOBJN	T,.-1
	MOVE	I,BEG		;MAKE SURE STUFF BEFORE BEG
	SUB	I,QRBUF		;IS COLLECTED
	MOVEI	T,0		;MARK THIS AS LAST COLLECTION
	PUSHJ	P,GCM3		;STORE IT ON TH GC LIST
	MOVE	I,QRBUF
GCS1A:	MOVSI	TT,200000	;TT>MAX. NO. CHARACTERS IN WORLD
	MOVE	OU,GCPTR	;GO BACKWARDS THROUGH GCTAB
GCS1:	HRRZ	A,GCTAB(OU)	;RELOCATE
	ADD	A,QRBUF
	CAMGE	A,I
	JRST	GCS2
	CAMGE	A,TT		;SET TT TO HIGHEST CHARACTER POSITION
	MOVE	TT,A
GCS2:	SOJGE	OU,GCS1
	CAMN	TT,[1B1]	;ANYTHING IN GCTAB ?	[EDIT #116]
	JRST	GCS4A		;NO, DON'T SAVE INFINITY[EDIT #116]
	MOVE	F2,TT		;HIGHEST CHARACTER.
	IDIVI	I,5		;C(QRBUF)/5
	IDIVI	F2,5		;HIGH CHAR/5
	AOS	I		;C(QRBUF)/5+1
	MOVS	OU,F2
	MOVE	T,F2
	SUB	T,I		;HIGH CHAR/5-C(QRBUF)/5+1
	JUMPLE	T,GCS4A		;ANYTHING TO GET?
	HRR	OU,I		;XWD HIGH CH/5,C(QRBUF)/5+1=NREG
	MOVE	B,Z		;GET TOP OF BUFR FOR BLT
	HRRZ	F2,(P)		;SEE WHO CALLED NROOM
	CAIN	F2,YANK6	;WAS IT APPEND?
	MOVE	B,AC2+OU-2	;YES, MUST USE THE REAL Z FOR THE BLT
	IDIVI	B,5
	SUB	B,T		;Z/5-NREG
	BLT	OU,(B)		;MOVE STUFF DOWN
	MOVNS	OU,T
	IMULI	OU,5		;OUT:=-5*NREG
	ADDM	OU,BEG		;BEG:=C(BEG)-5*NREG
	ADDM	OU,PT		;PT:=C(PT)-5*NREG
	ADDM	OU,Z		;Z:=C(Z)-5*NREG
	ADDM	OU,RREL		;RREL:=C(RREL)-5*NREG
	MOVE	CH,GCPTR	;UPDATE INSERTER
GCS3:	HRRZI	TT1,GCTAB(CH)
	HRRZ	A,(TT1)
	ADD	A,QRBUF
	CAMGE	A,TT
	JRST	GCS4
	ADDM	OU,(TT1)
	HLRZ	A,(TT1)
	JUMPE	A,GCS4		;NO PTR TO BEG
	CAIN	A,CPTR		;IN COMMAND BUFFER?
	ADDM	T,CRREL		;YES. UPDATE COMMAND POINTER RELOCATION
	SKIPL	(A)		;Q-REG?
	ADDM	T,(A)		;NO
	SKIPGE	(A)		;Q-REG?
	ADDM	OU,(A)		;YES. RELOCATE BASE POINTER.
	CAIN	A,CPTR
	ADDM	T,CPTBAK	;ALSO MOVE POINTER FOR FS COMMAND

GCS4:	SOJGE	CH,GCS3		;DONE?
	ADD	TT,OU		;YES. IN:=C(TT)-5*NREG

GCS4A:	CAML	TT,BEG		;LAST COLLECTION?
	JRST	@GCRET		;YES, RETURN
	MOVE	I,TT
	PUSH	P,C
	PUSHJ	P,GTQCNT
	ADD	I,C
	POP	P,C
	JRST	GCS1A
GCM:	MOVE	I,(T)
	TLZE	I,400000	;DOES Q-REG CONTAIN TEXT?
	TLZE	I,377777
	POPJ	P,		;NO
	ADD	I,QRBUF		;YES. ENTER POINTER IN GCTAB

GCM2:	CAML	I,BEG		;REGION BEFORE TEXT BUFFER?
	POPJ	P,		;NO. FORGET IT.
	SUB	I,QRBUF		;YES. IN:=# CHARACTERS TO RETREIVE.
				;IN Q-REG BUFFER AREA?
	JUMPL	I,CPOPJ		;NO. FORGET IT.
GCM3:	AOS	TT,GCPTR	;YES. TO BE GRABBED.
	CAIL	TT,GCTBL	;AM I WINNING?
	ERROR	E.GCE
	HRL	I,T		;XWD ADDRESS OF BYTE POINTER,NO. CHARACTERS
	MOVEM	I,GCTAB(TT)	;SAVE DATA
	POPJ	P,		;DONE THIS POINTER
;IF T POINTS TO AN ASCII BYTE POINTER, IN:=CHARACTER ADDRESS OF TOP
;OF STRING - NO. OF CHARACTERS.
GCMA:	HLRZ	TT,(T)		;LEFT HALF OF PTR
	TRC	TT,700		;DOES T POINT TO A TEXT BYTE POINTER?
	TRNE	TT,7700
	POPJ	P,		;NO
	MOVE	I,-1(T)		;MAYBE. GET WORD BEFORE POINTER. (MAX)
	SUB	I,1(T)		;MAX-CT
	LSH	TT,-14		;BYTE POSITION
	IDIVI	TT,7		;NO. OF CHARACTERS
	MOVEI	TT1,4-3+1	;2
	SUB	TT1,TT		;2-NO. OF CHARACTERS
	HRRZ	TT,(T)		;POINTER WORD ADDRESS (UNRELOCATED)
	IMULI	TT,5		;5*ADDRESS
	ADD	TT,TT1
	SUBM	TT,I		;5*ADDRESS-NO. CHARS+2+CT-MAX
	JRST	GCM2
SUBTTL	**********AUTOMATIC MEMORY EXPANSION*********

;MEMORY WILL BE EXPANDED UNDER ONE OF THESE CONDITIONS.

;	1.AN INTERNAL BUFFER EXPANSION CANNOT BE PERFORMED,
;	  TO DO SO WOULD OVERFLOW THE PRESENT MEMORY
;	  CAPACITY. THE INTERNAL OPERATIONS WHICH DESCOVER
;	  THE NEED FOR EXPANSION ARE:

;	  A.COMMAND BUFFER EXPANDING
;	  B.THE Q-REG GET (GI)
;	  C.THE Q-REG LOAD (NXI)
;	  D.ANY OF THE INSERTS
;	  E.COMMAND ACCEPTANCE ROUTINE


;	2.THE DATA BUFFER WILL BE MAINTAINED AT A MINIMUM
;	  NUMBER OF 5000 CHARACTERS BEFORE NEW DATA IS LOADED
;	  FROM AN INPUT DEVICE OTHER THAN THE CONSOLE. Q-REG
;	  USAGE SHORTENS THE NUMBER OF AVAILABLE CHARACTERS
;	  DIRECTLY, AND NORMAL TECO COMMANDS ARE GREATLY IMPARED
;	  OTHERWISE.


;SAVE THE ACCUMULATORS


GRABAK:	TXOA	FF,F.TALK	;TALKATIVE GRAB
GRABKQ:	TXZ	FF,F.TALK	;GRAB A K QUIETLY
	MOVEM	CH,SAV16	;TO SAVE THE ACCUMULATORS
	MOVEI	CH,SAVE		;WHILE WE SCOOT ALL OVER THE
	BLT	CH,SAV16-1	;THE PLACE

;COUNT THE NUMBER OF BLOCKS NEEDED TO FILL THE REQUEST

	MOVEI	F2,^D1024	;1 BLOCK OF CORE
	MOVEI	B,1		;WE WILL NEED AT LEAST ONE BLOCK
	ADDM	F2,.JBFF	;UP THE FIRST FREE COUNT
	PUSHJ	P,CRE23		;COMPUTE A NEW MEMSIZ AND 2/3 VALUE
	CAML	17,MEMSIZ	;WILL THIS BE ENOUGH CORE?
	AOJA	B,.-3		;NO, COMPUTE ANOTHER BLOCK
;NUMBER OF BLOCKS HAVE BEEN FOUND
;OBTAIN THE NEEDED CORE FROM THE MONITOR

	MOVE	B,.JBFF		;TO HELP OUT THE MONITOR
	CAMG	B,.JBREL	;NEED TO ASK?
	JRST	EXITZ		;NO
	CORE	B,		;MAKE THE CALL TO THE MONITOR
	JRST	NOTANY		;NO CORE (OR NOT ENOUGH) AVAILABLE
	TXNN	FF,F.INIT	;IF PROCESSING INI FILE NO RANDON [NK...
	TXNN	FF,F.TALK	;MESSAGE DESIRABLE?
	JRST	EXITZ		;NO
CORES:	MOVEI	CH,"["
	PUSHJ	P,TYOM
	MOVE	B,.JBREL	;SIZE OF CORE NOW
	ADDI	B,1
	ASH	B,-12
	PUSHJ	P,DECMS		;PRINT
	JSP	A,CONMES
	ASCIZ	/K Core]
/
	TXNE	FF,F.INIT	;INIT FILES NEED NO AC RESTORE!
	POPJ	P,		;SO DON'T

;RESTORE THE AC'S AND EXIT FROM THIS COR GET ROUTINE

EXITZ:	MOVSI	CH,SAVE		;FROM TO
	BLT	CH,CH		;ALL AC'S AS THEY WERE
	POPJ	P,		;AND EXIT

;NO CORE AVAILABLE (OR NOT ENOUGH)

NOTANY:	HLRZ	A,.JBSA		;GET LAST FIGURE OF CORE BOUND
	MOVEM	A,.JBFF		;AND STORE IT
	PUSHJ	P,CRE23		;COMPUTE THE MEMSIZE VALUES AGAIN
	MOVSI	CH,SAVE		;RESTORE THE ACCUMULATORS
	BLT	CH,CH		;& INFORM THE OUTSIDE WORLD THAT THEY LOSE
	EE3+ERROR E.COR

;THIS IS AN AUXILARY SPOT FOR ENTRANCE FROM GC2
;GET THE REQUIRED CORE TO SAVE THE JOB IF POSSIBLE

PRENR9:	PUSHJ	P,GRABAK	;GET THE REQUIRED CORE
	JRST	NROOM9		;GO TRY THE INSERT AGAIN
SUBTTL	COMMAND DISPATCH TABLE

DEFINE	DSP (C1,A1,C2,A2)<
	XWD	<<C1>B20+A1>,<<C2>B20+A2>>

;CODES INDICATE TYPE OF DISPATCH
JR==0	;FOR SIMPLE JRST DISPATCH
HR==1	;FOR DISPATCH TO A COMMAND PERFORMED BY A SUBROUTINE
MV==2	;FOR JRST DISPATCH AFTER PROCESSING PRECEDING NUMERIC ARGUMENTS

DTB:	DSP(JR,ERRA,JR,COMMEN)		;^@	^A
	DSP(JR,ERRA,JR,STOP)		;^B	^C
	DSP(JR,ERRA,JR,FFEED)		;^D	^E
	DSP(MV,LAT,MV,BELDMP)		;^F	^G
	DSP(JR,GTIME,HR,TAB)		;^H	TAB
	DSP(JR,CD5,JR,ERRA)		;LF	VT
	DSP(HR,TYO,JR,CD5)		;FF	CR
	DSP(JR,EOF,JR,OCTIN)		;^N	^O
	DSP(MV,QPAGE,JR,ERRA)		;^P	^Q
	DSP(JR,ERRA,JR,ERRA)		;^R	^S
	DSP(MV,SPTYI,HR,IUSET)		;^T	^U
	DSP(MV,LOWCAS,MV,STDCAS)	;^V	^W
	DSP(MV,SETMCH,MV,QYANK)		;^X	^Y
	DSP(JR,DECDMP,JR,ALTMOD)	;^Z	^[
	DSP(JR,ERRA,JR,ERRA)		;^BKSLH	^]
	DSP(JR,CNTRUP,JR,ERRA)		;^^	^LFTARR
	DSP(MV,PLUS,JR,EXCLAM)		;SPACE	!
	DSP(MV,DQUOTE,MV,COR)		;"	#
	DSP(JR,ERRA,JR,PCNT)		;$	%
	DSP(MV,CAND,JR,CD)		;&	'
	DSP(JR,OPENP,MV,CLOSEP)		;(	)
	DSP(MV,TIMES,MV,PLUS)		;*	+
	DSP(MV,COMMA,MV,MINUS)		;,	-
	DSP(JR,PNT,MV,SLASH)		;.	/
	DSP(JR,CDNUM,JR,CDNUM)		;0	1
	DSP(JR,CDNUM,JR,CDNUM)		;2	3
	DSP(JR,CDNUM,JR,CDNUM)		;4	5
	DSP(JR,CDNUM,JR,CDNUM)		;6	7
	DSP(JR,CDNUM,JR,CDNUM)		;8	9
	DSP(MV,COLON,MV,SEMICL)		;:	;
	DSP(MV,LSSTH,HR,PRNT)		;<	=
	DSP(JR,GRTH,JR,QUESTN)		;>	?
	DSP(MV,ATSIGN,MV,ACMD)		;@	A
	DSP(JR,BEGIN,MV,CHARAC)		;B	C
	DSP(MV,DELETE,HR,ECMD)		;D	E
	DSP(MV,FCMD,JR,QGET)		;F	G
	DSP(JR,HOLE,HR,INSERT)		;H	I
	DSP(MV,JMP,MV,KILL)		;J	K
	DSP(MV,LINE,JR,MAC)		;L	M
	DSP(MV,SERCHP,JR,OG)		;N	O
	DSP(HR,PUNCHA,JR,QREG)		;P	Q
	DSP(MV,REVERS,MV,SERCH)		;R	S
	DSP(HR,TYPE,MV,USE)		;T	U
IFN	FTNCM1,<
	DSP(MV,VERIFY,JR,MJRST)		;V	W	>
IFE	FTNCM1,<
	DSP(JR,ERRA,JR,MJRST)		;V	W	>
	DSP(MV,X,HR,YANKER)		;X	Y
	DSP(JR,END1,MV,OPENB)		;Z	[
	DSP(MV,BAKSL,MV,CLOSEB)		;BKSLH	]
	DSP(JR,UAR,MV,LARR)		;^	LFTARR
	SUBTTL	LOW SEGMENT
	RELOC	0		;TO THE LOW SEGMENT
LOCORE==.			;START OF THE LOW SEGMENT
IFN BISSW,<
BIS:	BLOCK	1		;FLAG TO INDICATE KL-10
>
INI:	BLOCK	1		;FLAG FOR TO DO INI FILE
TEMPP:	BLOCK	1		;PLACE TO SAVE P ON REENTER
TEMPDL:	BLOCK	1		;TEMP PDL
IFN CCL,<
CCLB:	BLOCK	3		;THE HEADER FOR CCL FILE IO
TYIPT:	BLOCK	1
> ;END IFN CCL
TTYBFS:	BLOCK	46		;100 MODE TTY BFRS
TIB:	BLOCK	3		;BUFFER HEADER
TOB:	BLOCK	3		;DITTO
JOBN:	BLOCK	1		;JOB #
USRPPN:	BLOCK	1		;USER PROJ-PROG #
MONITR:	BLOCK	1		;MONITOR LEVEL: 0=3,1=4,2=5
IBUF:	BLOCK	3
OBF:	BLOCK	3
IBUF1:	BLOCK	2*<BUFSIZ+3>
OBUF1:	BLOCK	2*<BUFSIZ+3>
EATCH:	BLOCK	1		;FOR LAST INPUT CHARACTER IN CASE ERROR OCCURS
DLIM:	BLOCK	1
NUM:	BLOCK	1
SYL:	BLOCK	1
SARG:	BLOCK	1
PDLSAV:	BLOCK	1
VVAL:	BLOCK	1		;LENGTH OF LAST TEXT STRING PROCESSED
XFILNM:	BLOCK	17
FILDEV:	BLOCK	1		;DEVICE SPECIFIED
FILPTH:	BLOCK	2		;DIRECTORY BLOCK
FILPPN:	BLOCK	1
FILSFD:	BLOCK	5		;UP TO 5 SFD'S
SWITC:	BLOCK	1		;SWITCH BIT STORE (EACH BIT IS 1 SWITCH)
SPCDEV:	BLOCK	2		;FOR SAVING DEVICE LAST SPECIFIED (1 EXTRA WD FOR PATH. UUO)
SPCPPN:	BLOCK	7		;FOR SAVING PATH LAST SPECIFIED
SPCPRO:	BLOCK	1		;FOR SAVING PROTECTION
BAKNAM:	BLOCK	2		;FOR THE BACKUP NAME
PTHCNT:	BLOCK	1		;TO COUNT SFD'S

	;***** DO NOT SEPARATE
ERSPEC:	BLOCK	12		;FOR DEFAULT ER FILE SPEC (SEE EWSPEC FOR FORMAT)
EWSPEC:	BLOCK	12		;FOR DEFAULT EW FILE SPEC (SAME AS XFILNM ABOVE EXCEPT
				;EWSPEC=DEVICE, EWSPEC+(4 - 9) = PATH
EISPEC:	BLOCK	12		;FOR DEFAULT INI FILE SPEC
	;***** DO NOT SEPARATE
RUNIT:	BLOCK	17		;FOR RUN ON SOMETHING WHEN YOU EXIT
PRMERR:	BLOCK	1		;FOR PERMANENT ERROR BITS
LOGOPN:	BLOCK	3		;FOR LOG FILE OPEN BLOCK AND FLAG FOR APPEND
OLOG:	BLOCK	3		;BUFFER HEADER FOR LOG FILE
EEFL:	BLOCK	4		;BLOCK FOR STORING EE FILSPEC
LOGFL:	BLOCK	4		;FOR LOG FILE FILESPEC
IINI:	BLOCK	3		;BUFR HEADER FOR INI FILES
LOGSPC:	BLOCK	BUFSIZ+3	;RESERVE 200 WORDS IN CASE A LOG FILE IS DESIRED
OSAV:	BLOCK	3		;OUTPUT BUFFER HEADER FOR SAVE CHANNEL
STARTL:	BLOCK	13		;FOR GET SEG STUFF
EOFLAG:	BLOCK	1		;EDIT OLD FLAG
TYCASF:	BLOCK	1		;TYPE-OUT CASE FLAG: 0 = TYPE ' BEFORE LC
				;+ = TYPE ' BEFORE UC;- = DON'T TYPE FLAGS
AUTOF:	BLOCK	1		;NON-ZERO IMPLIES AUTOTYPE AFTER SEARCHES
				;POSITIVE IMPLIES TYPE AUTOF AS A PTR MARKER
IFN CRT,<
TTYWID:	BLOCK	1		;CURRENT LINE WIDTH
CRTTYP:	BLOCK	1		;TYPE OF CRT IN USE
BACRUB:	BLOCK	1		;AUXILLARY DELETE CHAR, RIGHT JUSTIFIED
VTWID:	BLOCK	1		;WIDTH OF VERTICAL TAB
FFWID:	BLOCK	1		;WIDTH OF FORM FEED
VTMUL:	BLOCK	1		;MULTIPLIER FOR DELVT
FFMUL:	BLOCK	1		;MULTIPLIER FOR DELFF
BACCHR:	BLOCK	1		;BACKSPACE CHARACTER SEQUENCE
FORCHR:	BLOCK	1		;NONDESTRUCTIVE FORWARD CURSOR, OR BLANK
BACSEQ:	BLOCK	1		;BACKUP AND DELETE SEQUENCE
DELLF:	BLOCK	1		;EOL RUBOUT STRINGS (LF, VT, FF)
DELVT:	BLOCK	1
DELFF:	BLOCK	1
DELCR:	BLOCK	1		;CARRIAGE RETURN RUBOUT STRING
CANRUB:	BLOCK	1		;STRING TO CANCEL RUBOUT
CANBAK:	BLOCK	1		;STRING TO CANCEL BACKSPACE
CTUSEQ:	BLOCK	1		;STRING TO PROCESS CONTROL-U

> ;END IFN CRT
OUTCH:	BLOCK	1		;ADR OF OUTPUT ROUTINE
INCH:	BLOCK	1		;ADR OF INPUT ROUTINE
OPNRI:	BLOCK	1		;INPUT FILE OPEN ARGUMENTS, OPNRD+4(1)
OPNR1:	BLOCK	1		;INPUT DEVICE.  INIT+27(0),OPNRD+6
OPNRB:	BLOCK	1		;INITIALIZE TO XWD 0,INBUF. OPNRD+10
BAKTMP:	BLOCK	1		;FOR DECTAPE TEMP NAME
PROTEC:	BLOCK	1		;EB INPUT FILE PROTECTION
DEVSAV:	BLOCK	1		;DEVICE CHARACTERISTICS
EBDEV:	BLOCK	1		;EB DEVICE NAME
TMPTEC:	BLOCK	1		;SAVE FOR ###TEC. FILE NAME
BAKPRO:	BLOCK	1		;DESIRED PROTECTION FOR THE NEW FILE
OPNWI:	BLOCK	1		;OUTPUT FILE OPEN ARGUMENTS. OPNW1+4(1)
OPNWD:	BLOCK	1		;OUTPUT DEVICE.  OPNW1+6
OPNWB:	BLOCK	1		;OUTBUT BUFFER HEADER ADDRESS. OPNW1+10(OUTBUF)
WRICHR:	BLOCK	1		;CHARACTERISTICS OF WRITE DEVICE
OUTFIL:	BLOCK	4		;STORE FOR OUTPUT FILENAME
INFILE:	BLOCK	4		;STORE FOR INPUT FILENAME
SWINDX:	BLOCK	1		;FOR SWITCH INDEX SCAN
SWITHL:	BLOCK	1		;SWITCH CHAR HOLD
INSWIT:	BLOCK	1		;INPUT SWITCHES
OUTSWT:	BLOCK	1		;OUTPUT SWITCHES
LSNCTR:	BLOCK	1		;LSN GENERATION CTR
CTGRET:	BLOCK	1		;RETURN ADDRESS FOR ^G ROUTINE
ARGTRM:	BLOCK	1		;FS, FN 2ND ARG TERMINATOR
COMBAK:	BLOCK	1		;STORE FOR COMCNT DURING FS, FN
CPTBAK:	BLOCK	1		;DITTO CPTR
SRHCNT:	BLOCK	1		;SEARCH COUNT STORE
SRHAA:	BLOCK	1		;END OF SEARCH MATRIX MARKER
SCESQB:	BLOCK	1		;SEARCH FOR ^E[...] NESTING COUNTER
CTGLEV:	BLOCK	1		;SEARCH FOR TEXT IN Q-REG NEST COUNTER
ITERCT:	BLOCK	1
SFINDF:	BLOCK	1
TECERR:	BLOCK	4		;LOOKUP SPECS FOR TECO.ERR
ERRHDR:	BLOCK	3		;RING HEADER FOR TECO.ERR
RELSAV:	BLOCK	1		;STORE FOR .JBREL
ARGSTO:	BLOCK	1		;STORE FOR ARGUMENT (IF ANY)
ERR1:	BLOCK	1
ERR2:	BLOCK	1
COMLEN:	BLOCK	1		;LENGTH OF BASIC COMMAND STRING
LISTF5:	BLOCK	1		;OUTPUT DISPATCH
NROOM2:	BLOCK	1		;POINTER TO LAST PARTIAL WORD ON UPWARD MOVE.
GCRET:	BLOCK	1		;GC EXIT DISPATCH
NROOM4:	BLOCK	1		;PARTIAL WORD POINTER FOR DOWNWARD MOVE
BEG:	BLOCK	1
PT:	BLOCK	1
Z:	BLOCK	1
QRBUF:	BLOCK	1
	;*** DO NOT SEPARATE ***
COMAX:	BLOCK	1		;TOTAL # OF CHARS AT CUR. CMD. LEVEL
CPTR:	BLOCK	1		;EXECUTION-TIME CMD STRING PTR
COMCNT:	BLOCK	1		;# OF CHARS REMAINING TO BE EXECUTED AT THIS LEVEL
	;*** DO NOT SEPARATE ***
CBUFH:	BLOCK	1
CBUF:	BLOCK	1
MEMSIZ:	BLOCK	1
IFN CCL,<
CCLSW:	BLOCK	1
> ;END IFN CCL
GCPTR:	BLOCK	1
CRREL:	BLOCK	1
GCFLG:	BLOCK	1
RREL:	BLOCK	1
M23:	BLOCK	1
M23PL:	BLOCK	1
ERRLEN:	BLOCK	1		;TYPE OF ERROR MESSAGES WANTED BY DEFAULT
AC2:	BLOCK	16		;SAVE AC2-AC17 IN NROOM ROUTINE
STAB:	BLOCK	STABLN		;SEARCH MATRIX
DEFPTH:	BLOCK	11		;DEFAULT PATH
DCLOC:	BLOCK	5		;DSKCHR BLOCK
NFORMS:	BLOCK	1		;NUMBER OF FORM FEED SEEN
XCTING:	BLOCK	1
BCOUNT:	BLOCK	1
SYMS:	BLOCK	22		;LIS+4(0),OG3+1,GC+3(0)
VALS:	BLOCK	22		;LIS+4(0),OG3+3,GC+3(0)
CNTS:	BLOCK	22		;LIS+4(0),OG3+2,GC+3(0)
SYMEND:	BLOCK	0
EQM:	BLOCK	1		;LEVEL OF MACRO NESTING
SRHCTR:	BLOCK	1		;# OF CHARS IN SEARCH ARGUMENT (MUST PRECEDE SRHARG)
SRHARG:	BLOCK	^D16		;STORE FOR SEARCH ARGUMENT
PFL:	BLOCK	LPF+1
GCTAB:	BLOCK	GCTBL		;GCS3+4,GCM2+13
QTAB:	BLOCK	45		;Q-REGISTER TABLE
				;USEA+1,PCNT+1
PDL:	BLOCK	LPDL+1
SAVEAC:	BLOCK	2		;THIS MUST BE IMMEDIATELY BEFORE SAVE!
	LOWERB==SAVEAC+1
	UPPERB==SAVEAC+2
SAVE:	BLOCK	16		;AC STORAGE FOR GC
SAV16:	BLOCK	1
IFN	FTSWTCH,<
SW.INI:	BLOCK	1
INI.SW:	BLOCK	1
>
IFE BUGSW,<
CMDBFR:	BLOCK	0		;COMMAND BUFFER
> ;END IFE BUGSW
IFN BUGSW,<
CMDBFR:	BLOCK	1
>;END IFN BUGSW
LOWEND==.-1


	RELOC
	LIT			;SO PATCH SPACE IS AT TOP OF HI-SEG
PATCH:	END	TECO

    i2^/