UNIVERSAL LGNUNV - Parameter file for LOGIN version 63(1115) - 12-Jan-84
SUBTTL	Larry Campbell /TW/DJB/DAL/RCC/JSL/DAL/LC/HRB/BAH/WCL/KPY/MSL/WSM/DPM

;	LOGIN - The program for gaining access to the
;		DECsystem-10 Timesharing System


;COPYRIGHT (C) 1969, 1974, 1979, 1980, 1981, 1982, 1983, 1984 BY
;DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.

IF1, <PRINTX [Searches UUOSYM, MACTEN, SCNMAC, ACTSYM, UFDPRM]> 
	SEARCH	UUOSYM,MACTEN,SCNMAC,ACTSYM,UFDPRM

IF2, <	PRINTX
	PRINTX [Loads with REL:SCAN, REL:WILD, REL:HELPER, REL:FACTOR, REL:UFDSET]>
	.REQUEST REL:SCAN,REL:WILD,REL:HELPER
	.REQUEST REL:FACTOR,REL:UFDSET

	SALL

	TWOSEG

	LGNVER==63
	LGNMIN==0
	LGNEDT==1115
	LGNWHO==0

	LOC	137
	VRSN.	(LGN)

;               TABLE OF CONTENTS FOR LOGIN
;
;
;                        SECTION                                   PAGE
;    1. Edit history..............................................   3
;    2. Parameters................................................  15
;    3. Message macros............................................  17
;    4. Inter-module globals......................................  18
;    5. Storage definitions.......................................  19
;    6. Type first message, check states bits.....................  29
;    7. SESSION command scanning..................................  34
;    8. TERMSW
;         8.1   Handle /TERMINAL:(args) switch        [744].......  40
;    9. Switch tables
;         9.1   LOGIN switches (definition).......................  43
;         9.2   LOGIN switches (expansion)........................  44
;         9.3   ATTACH switches (definition)......................  45
;         9.4   ATTACH switches (expansion).......................  45
;         9.5   TERMINAL arguments (definition)...................  46
;         9.6   TERMINAL arguments (expansion)....................  47
;   10. LGNSCN storage............................................  48
;   11. Search ACCT.SYS...........................................  53
;   12. Check ACCT.SYS entry......................................  57
;   13. Write USAGE/FACT file entry...............................  59
;   14. SWITCH.INI handling.......................................  60
;   15. PROMPT user for ACCOUNT and REMARK........................  62
;   16. Get the account string....................................  63
;   17. Get the REMARK string.....................................  65
;   18. Fact file header setup....................................  66
;   19. Expiration date conversion      [754].....................  67
;   20. Password encryption routines..............................  68
;   21. VALIDATION accounting message.............................  70
;   22. LOGIN account message.....................................  71
;   23. SESSION account message...................................  72
;   24. ATTACH accounting message.................................  73
;   25. Support routines..........................................  74
;   26. IPCF message routines.....................................  77
;   27. CHKJSP - check If ATTACH Preferred Over LOGIN.............  78
;   28. Turn on echo, diddle some bits............................  81
;   29. Build scheduler table.....................................  82
;   30. Search AUXACC.SYS.........................................  86
;   31. Subroutine to set up a UFD................................  91
;   32. Subroutine to create a path............................... 106
;   33. Set user profile
;        33.1   privileged GALAXY SETUUOs......................... 108
;        33.2   privileged SETUUO's............................... 109
;        33.3   non-privileged SETUUOs............................ 116
;   34. Set user parameters
;        34.1   subroutines....................................... 123
;   35. LOGIN messages............................................ 130
;   36. I/O subroutines........................................... 134
;   37. Error conditions.......................................... 138
;   38. Error message routine..................................... 139
;   39. Error message printer..................................... 141
;   40. ERRWTO - ROUTINE TO WTO IMPORTANT ERROR MESSAGES.......... 142
;   41. Random messages........................................... 144
;   42. Data and storage.......................................... 146
	SUBTTL	Conditional assembly switches

ND SUPNOT,1		;SUPPRESS NOTICE.TXT IF / IN PPN
ND FASTLG,1		;INCLUDE DIRECTORY OF ACCT.SYS IN HI SEG
ND SETTTY,1		;INCLUDE CODE TO SET TTY CHARACTERISTICS
ND BATMAX,0		;[505] INCLUDE CODE TO CHECK BATMAX (REQUIRES
			;[505] EDIT 1055 OF BATCON)
ND NCRYPT,0		;[557] PASSWORD ENCRYPTION
ND PSWCHG,0		;[557] ALLOW USER TO CHANGE OWN PASSWORD
ND FTCMPR,1		;[667] ZERO COMPRESS UFDS WHEN RECOMPUTING QUOTA
ND FTMAIL,0		;[760] CALL EXTERNAL RNMAIL ROUTINE
ND FTUSAG,1		;DO USAGE ACCOUNTING
ND FACTSW,1		;DO FACT FILE ACCOUNTING (7.01 ONLY)
ND FAILOG,1		;LOG LOGIN/ATTACH FAILURES IN FACT FILE
IFE FACTSW,<FAILOG==0>	;NO POINT IF NO FACT FILE

;OTHER PARAMETER VALUES

ND TTYSLP,2		;NO. OF MINS TO SLEEP AWAITING TTY INPUT BEFORE DYING
ND PDLSIZ,60		;DEPTH OF STACK
ND DVICES,20		;[470] NUMBER OF DEVICES ASSIGNABLE BY /ASSIGN
ND EXPWRN,^D31		;DAYS TO WARN IF PPN WILL EXPIRE SOON
ND STRMAX,^D36		;MAXIMUM NUMBER OF STRS IN SYSTEM
ND TTYBSZ,^D24		;NUMBER OF WORDS IN TTY OUTPUT BUFFER
	SUBTTL	Declaration macro

IF1,<
DEFINE	LGNDCL,<
	.XCREF
	LALL
;



;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1969, 1974, 1979, 1980, 1981, 1984 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
	TWOSEG
	RELOC	400000
	IFNDEF	BIGLST,<SALL>
	LOWVAR
	GLOBS
	.CREF
>>
	SUBTTL	Edit history

;316)	FIX TEST FOR WEEKEND TO PREVENT NON-PRIME-TIME USERS FROM
;	LOGGING IN DURING PRIME TIME (SPRS 10-14,021 AND 10-14,046)

;317)	ENLARGE PARAMETER BLOCK FOR STRUUO SO POINTER TO AUXACC
;	ENTRY (RDHED) DOESN'T GET OVERWRITTEN.
;		SPRS 10-14,219 AND 10-14,083

;320)	MAKE LOGIN PREFIX EACH STR.TXT TYPEOUT WITH THE NAME OF THE
;	FILE STRUCTURE FROM WHICH IT CAME.  SPR 10-14,031

;321)	REALLY IMPLEMENT /HELP	(SPR 10-14,031)

;322)	CHANGE PREFIX FOR WARNING ERROR MESSAGES FROM ? TO %
;	TO PREVENT BATCH JOBS FROM FLUSHING.
;		SPRS 10-14,145 AND 10-14,172.

;323)	FIX SECURITY BREACH WHERE BOTH NAME AND PSWD ARE REQUIRED AND
;	NEITHER IS ASKED FOR.	SPR 10-14,306.

;324)	PUT IN TEST SO SETUUO IS SKIPPED IF NO BITS WANT TO BE SET.
;		SPR 10-14190.

;325)	FIX ?LGNIPS IF NO SPACE BETWEEN PPN AND SWITCHES.
;		SPR 10-14,031


;326)	MOVE MISPLACED CLOSE CONDITIONAL	(SPR 10-14,244)

;327)	MAKE LOGIN LOOK AT PHYSICAL CORE LIMIT EVEN IN KA MONITORS.
;		SPR 10-14,264.

;330)	ALLOW PPN TO BE ENCLOSED IN SQUARE BRACKETS ON LOGIN.

;331)	REMOVE ALL REFERENCES TO FL.BRK -- OBSOLETE BATCH HACK.
;		SPR 10-14,021.

;332)	IMPLEMENT /NOWATCH	SPR 10-14,145

;333)	FIX EDITS 221 AND 226 SO LOGIN REALLY WON'T PRINT NOTICE.TXT
;	TO AN OPSER SUBJOB.

;334)	MAKE LOGIN SLEEP BETWEEN RETRIES AFTER BAD PASSWORDS ONLY
;	ONLY ON PTY'S.  SPR 10-14,021.

;335)	CLEAR TMPCOR AT BEGINNING OF FLOW RATHER THAN END
;		SO /TMPCOR SWITCH WORKS.

;336)	FIX EDIT 332, WHICH ONLY DID HALF THE JOB.

;337)	FIX EDIT 333, WHICH COMPLETELY MADE NOTICE.TXT GO AWAY, OPSER
;		SUBJOB OR NOT!
;340)	MAKE ISOPSR ONLY LOOK AT IMMEDIATELY CONTROLLING JOB SO
;		NOTICE.TXT WILL GET PRINTED FOR BATCH JOBS.

;341)	ANOTHER FIX TO THE INFAMOUS EDIT 333, WHICH SOMETIMES
;		TURNED THE TTY INTO A LOCAL COPY TERMINAL
;		(SUPER NO-ECHO).

;342)	WHEN SETTING UP TEMP SEARCH LIST TO READ SWITCH.INI, ONLY LOOK
;		AT STRS WHOSE NAMES BEGIN WITH DSK (DSKA, DSKB, ETC.).

;343)	EXIT ON ^Z.

;344)	IMPLEMENT SWITCHES TO SET TERMINAL CHARACTERISTICS.

;345)	FIX TO EDIT 344 WHERE JOBS WHICH DIDN'T NEED PASSWORDS
;		DIDN'T GET TTY CHARACTERISTICS SET.

;346)	WHEN SETTING UP TO READ SWITCH.INI, ENABLE SYS (IN CASE
;		OF SYSTEMS WITH FUNNY-NAMED FILE STRUCTURES).

;347)	PRINT NOTICE.TXT AND /NOTE:FILE EVEN IF CAN'T LOG IN
;		(SYS NOT AVAILABLE, BATCH ONLY, ETC.)


;350)	MAKE LOGIN GET NAME IF REQUIRED ON ATTACH
;		(SPR 10-14,593)

;351)	MISCELLANEOUS CODE CLEANUP AND SPEEDUP.

;352)	ADD CODE TO SET ENQ/DEQ QUOTAS.

;353)	MAKE SURE RP.LOG GETS SET WHEN RECOMPUTING DISK USAGE.

;354)	ADD "SYSTEM IS UNATTENDED" MESSAGE

;355)	MAKE /NAME LOGIC WORK RIGHT.

;356)	ADD CHECK FOR ACCT.SYS FORMAT VERSION 4 AND DON'T
;		SET ENQ/DEQ QUOTAS IF NOT VERSION 4.

;357)	MISCELLANEOUS CODE CLEANUP ON SUGGESTIONS BY DAL.

;360)	MORE CODE CLEANUP.

;361)	IF DEVPPN ON SYS FAILS, WE USE GARBAGE.  LET'S USE [1,4].

;362)	MAKE /NOTE PRINT OUT BEFORE NOTICE.TXT.

;363)	DO ALL NON-PRIV. SETUUO'S AFTER PRINTING NOTICES.  THIS IS SO
;		THE TRMOP.'S (LIKE SPEED) WON'T SCREW UP PRINTING NOTES.

;364)	DON'T SETUUO THE SPOOL BITS IF SYSTEM DOESN'T HAVE SPOOLING.

;365)	ADD /DEFER AND /NODEFER SWITCHES, AND PREVENT /SPOOL:ALL FROM
;		SETTING BIT FOR DEFERRED SPOOLING.
;366)	FIX BUG INTRODUCED BY EDIT 324 WHERE /DSKFUL:PAUSE NO LONGER
;		WORKS.

;367)	ADD CODE TO SLEEP UNTIL OUTPUT BUFFER EMPTY BEFORE DOING
;		TRMOP.S WHICH MIGHT GARBLE TTY OUTPUT.

;370)	REMOVE ALL REFERENCES TO DATE75 CONDITIONAL

;371)	CODE CLEANUP.

;372)	MAKE LGNUNV INTO A SEPARATE (UNIVERSAL) FILE TO SPEED ASSEMBLY.

;373)	ADD ERROR MESSAGE IN CASE SETUUO FOR DEFER BIT FAILS.

;374)	CHECK ST%GAL (GALAXY) BIT IN 2ND STATES WORD AND DON'T TRY
;	TO SET DEFER BIT IF ZERO.

;375)	IMPROVE ERROR MESSAGE IF TRMOP. FAILS TO TELL FUNCTION CODE.

;376)	IF USER TYPES BAD PATH OR PSWD AND RETRIES, HIS PATH
;	IS SCREWED UP.  FIX: CLEAR PATH BLOCK EACH TIME AROUND.

;377)	DON'T DOUBLE-SPACE /NOTE OR /STR TYPEOUT

;400)	ADD FTINHOUSE CONDITIONAL AND ENCLOSE IN IT THE CODE
;	WHICH WILL ONLY ALLOW FILE STRUCTURES WHOSE NAMES BEGIN WITH
;	'DSK' TO GO INTO YOUR SEARCH LIST WHEN READING SWITCH.INI.
;	THIS CODE FIXES THE BUG IN WHICH SWITCH.INI WAS NOT READ
;	IF 7 OR 8 PRIVATE PACKS PRECEDE THE PUBLIC PACKS IN THE
;	RETURNS FROM SYSSTR.  SINCE THIS IS ONLY A PROBLEM IN
;	SYSTEMS WITH 9 OR MORE FILE STRUCTURES, THE CODE WILL BE
;	CONDITIONED OUT IN FIELD-IMAGE.

;401)	PREVENT /MESSAGE:ALL FROM TURNING ON RANDOM WATCH BITS

;402)	RANDOM CODE CLEANUP -- ALSO REMOVE CODE FOR ENQ/DEQ SO IT
;	CAN BE PUT INTO V57 ALONG WITH SCHED. STUFF IN
;	ONE FELL SWOOP

;403)	IMPROVE LOGIC FOR READING AUXACC.SYS

;404)	(SIGH) FIX EDIT 333 AGAIN.  

;405)	REMOVE EDIT 372.

;406)	SLEEP ON DATASETS AS WELL AS PTY'S FOR RETRIES.

;****	RELEASE VERSION 56 -- -- START VERSION 57  ****
;	  NEXT EDIT NUMBER WILL BE 420 TO LEAVE ROOM FOR
;	  MAINTENANCE EDITS.

;420)	CHECK LINE NUMBER JUST BEFORE ATTACH UUO SO JOB WHICH
;	BECOMES DETACHED DURING ATTACH COMMAND CAN'T STEAL TTY0
;					[SPR 15329]
;421)	FIX TEST FOR DETACHED LINE.  [SPR 15330]

;422)	FIX BUG IN RECOMPUTING LOGIC.  [SPR 15396]

;423)	ADD /RTCOMPATABILITY SWITCH.

;424)	MAKE LOGIN USE ALL OF HIGH SEG FOR ACCT.SYS (LOGIN
;	USED TO ALWAYS EXPAND CORE EVEN IF NOT NECESSARY)

;425)	ADD CODE TO READ SCDMAP.SYS AND SET SCHEDULER CLASSES.

;426)	FIX ENQ/DEQ QUOTA ROUTINE.

;427)	CHECK FOR END OF STR LIST IN SYSTEMS WITHOUT FENCE AT USRST1.

;430)	MAKE A -1 ENQ QUOTA ENTRY MEAN DON'T SET THE QUOTA SO ON THE
;	FIRST ENQ UUO MONITOR WILL SUPPLY SYSTEM-WIDE DEFAULT QUOTA

;431)	JUMP AROUND ABOUT 30 INSTRUCTIONS IF NON-6.02 MONITOR
;	WHICH ONLY APPLY TO 6.02.  AREA AFFECTED: PRVSET, PRSET3.

;432)	DO A CRLF AFTER TYPING "NO OPERATOR COVERAGE."

;433)	FIX POSSIBLE BUG IN SCHED. TABLE BUILDING LOGIC, AND CLEAN
;	UP SOME CODE AND ERROR MESSAGES.

;434)	ALLOW /HELP TO BE TYPED WITHOUT A PPN

;435)	ALLOW CR IN RESPONSE TO # PROMPT WITHOUT NASTY ERROR MESSAGE

;436)	ADD CODE TO CALL TSKCHK MODULE.  THIS IS USED ON OUR IN-HOUSE
;	TIMESHARING SYSTEM TO ASK FOR AND RECORD IN THE FACT FILE
;	A COST CENTER AND TASK FOR ACCOUNTING PURPOSES.  THIS CODE
;	IS UNDER THE FTTASK SWITCH WHICH WILL REMAIN 0 IN FIELD IMAGE.
;	THIS CODE IS FOR INFORMATIONAL PURPOSES ONLY AND IS NOT
;	SUPPORTED.  [NOTE SWITCH REMOVED AS PART OF EDIT 716]

;437)	WHEN LOGIN BELIEVES IN ENQ/DEQ AND SCHED. CLASSES, IT
;	FORGETS ALL ABOUT VM.  FIX - SET NEWACT=-1 IF ACCT.SYS
;	VERSION NUMBER IS 3 OR GREATER (NOT JUST 3).

;440)	WHEN SAYING "OTHER JOBS SAME PPN", TELL HIM WHAT JOBS.

;441)	MAKE START ADDRESS AND PROGRAM NAME WORK RIGHT.

;442)	MOVE CALL TO .OSCAN SO A) USER HAS SEARCH LIST WHEN IT IS
;	CALLED AND B) /NAME SWITCH WORKS CORRECTLY WITHOUT THE
;	NECESSITY OF HACKS LIKE EDIT 355.

;443)	FINISH THE JOB OF EDIT 442 BY REMOVING (AT LAST!) SETTMP
;	AND CLRTMP.
;444)	ADD TWO ROUTINES: LOCK TO WRITE-ENABLE HI SEG AND LOCK
;	OUT CTRL-C AND OTHER JOBS WHO WANT TO MODIFY HI SEG, AND
;	UNLOCK TO DO THE REVERSE.

;445)	DON'T TELL [1,2] JOBS WHICH JOBS ARE ALSO LOGGED IN UNDER
;	[1,2] - THERE'RE USUALLY VERY MANY AND YOU DON'T WANT TO KNOW

;446)	FIX SPURIOUS ERROR MESSAGE IN TINY MONITOR, AND DO SOME
;	RANDOM CODE CLEANUP

;447)	MAKE .LOGIN [PROJ,PROG,SFD,SFD,..]/SWITCH WORK

;450)	ADD /NOTICE:ARG SWITCH TO CONTROL PRINTING OF NOTICE.TXT
;	ARG=ALWAYS TO ALWAYS SEE NOTICE
;	ARG=SOMETIMES TO WORK LIKE PROJ/PPN
;	ARG=NEVER TO NEVER SEE IT

;451)	ALLOW USER TO SPECIFY DIFFERENT DEFAULT PATH THEN LOGGED-IN
;	PPN

;452)	USE SECOND 512 ENTRIES OF SCDMAP.SYS FOR BATCH JOBS.

;453)	MAKE DEFAULT FOR /NOTICE BE SOMETIMES.

;454)	FIX BUG IN SFD LOGIC AND TYPO IN /NOTICE LOGIC.

;455)	MAKE /VERBOSITY WORK RIGHT.

;456)	USE BUFFERED TTY OUTPUT.  THIS WILL SPEED UP LOGIN IN
;	REAL TIME ON HEAVILY-LOADED DUAL-CPU SYSTEMS.

;457)	ADD /PATH SWITCH TO DO THE OBVIOUS THING.  THIS WILL OVERRIDE
;	A PATH TYPED ON THE LOGIN COMMAND LINE - I.E.,
;	.LOG [34,35,FOO]/PATH:[24,25,BAR] WILL LOG THE USER IN
;	TO [34,35] WITH A PATH OF [24,25,BAR].

;460)	WHEN RECOMPUTING DISK USAGE, DO AN OUTPUT TTY AFTER EACH
;	STR SO USER THINKS SYSTEM IS STILL ALIVE

;461)	SPRINKLE A FEW OUTPUT TTY,S THROUGHOUT LOGIN SO STUFF
;	GETS TYPED A LITTLE AT A TIME, RATHER THAN A LONG
;	WAIT AND THEN A GUSH OF TTY OUTPUT.  ALSO, RELEASE TTY
;	BEFORE ATTACH SO 2,5 JOBS DON'T GET LEFT LYING AROUNG
;	IN TO WAIT.

;462)	WHEN ATTACHING TO A JOB WHOSE PPN REQUIRES NAME, ONLY ASK
;	NAME IF THERE IS ONE IN ACCT.SYS TO CHECK IT AGAINST

;463)	FIX POSSIBLE BUG IN SCHED. TABLE LOGIC

;464)	REMEMBER TO RESERVE BATMIN JOBS FOR BATCH - I.E., FOR A T/S JOB,
;	ALLOW LOGIN ONLY IF LOGMAX-BATMIN-LOGNUM+BATNUM>0 [SPR 10-15847]

;465)	ADD OUTPUT TTY, TO TYPE RTN TO KEEP USERS PATIENT.
;466)	SAVE ERROR CODE OVER CALL TO UFDSMB AT LGNCAS. [SPR 10-15873]

;467)	MAKE /PATH IN SWITCH.INI WORK.

;470)	ADD /ASSIGN:PHYS:LOG SWITCH TO DO THE OBVIOUS.

;471)	IN EDIT 467, AT NOZAP-1, THE BLT DIDN'T HAVE A -1 AFTER IT
;	SO IT BLT'ED THE SPOOL BITS.  FIX: ADD A -1.

;472)	SPLIT TRMOP.S INTO TWO CLASSES - THOSE WHICH SHOULD BE DONE
;	BEFORE PRINTING NOTICE.TXT, AND THOSE WHICH SHOULD BE DONE
;	AFTER.  CURRENTLY ONLY SPEED IS SET AFTER PRINTING NOTICES.

;473)	/ASSIGN:DEV (NO LOG. NAME) MAKES SCAN HALT.  FIX: IF EOL IS
;	SEEN WHILE PROCESSING /ASSIGN, SET FLAG (R.EOL) SO NO MORE
;	INPUT WILL BE DONE AND REEAT ONE CHAR SO SCAN WILL SEE EOL.

;474)	FIX POSSIBLE STACK PHASE PROBLEM IN PARSE.

;475)	ADD TIMEOUT TO WAITO ROUTINE IN LGNSET & CLEAN UP SOME CODE

;476)	FIX BAD RETURN FROM ERROR RECOVERY ROUTINE IN LGNDSK (UFDSE3)

;477)	CHECK LOGMAX FOR BATCH JOBS AND ADD A NEW CLASS OF ERROR MESSAGE
;	FOR BATCON: REQUE, ERROR CODE 5, MEANING REQUE THIS JOB AND
;	DON'T SCHEDULE ANYBODY ELSE FOR A LITTLE WHILE

;500)	REMOVED BY EDIT 505.

;501)	WHEN SCANNING THRU ALL JOB NUMBERS, SCAN UP TO HIGHJOB, NOT
;	LOGNUM.

;502)	IN A SEQUENCE OF /ASSIGNS, THE LAST ONE IS NOT DONE.
;	CURE: CHANGE AOJL TO AOJLE.

;503)	WHEN LOGMAX IS EXCEEDED LOGIN TELLS YOU AND THEN CLEVERLY
;	PROCEEDS TO LOG YOU IN.  FIX: TREAT REQUE AS A FATAL ERROR.

;504)	EQACT WAS MISTAKENLY PUT IN THE LOW SEG. PUT IT IN THE HI SEG.

;505)	REMOVE EDIT 500, AND CHECK BATMAX RATHER THAN LOGMAX FOR BATCH
;	JOBS.  LOGMAX IS NOW DEFINED TO MEAN THE GREATEST NUMBER OF
;	INTERACTIVE, USER JOBS LOGGED IN.  ALSO ADD CONDITIONAL ASSEMBLY
;	SWITCH BATMAX WHICH WILL TURN ON THE NEW BATMAX/LOGMAX
;	CODE.  THIS REQUIRES EDIT 1055 IN BATCON.

;506)	MAKE .LOG 3,4[5,6] WORK.

;507)	ADD AN ERROR MESSAGE IF THE ENQC. UUO FAILS.

;510)	CLEAN UP SOME ERROR MESSAGES AND ADD SOME HUMAN ENGINEERING.

;511)	FIX BUG IN /CORE LOGIC; ADD SOME ERROR MESSAGES FOR 'THIS
;	CAN NEVER HAPPEN' TYPE STUFF; DO SOME CODE CLEANUP.
;512)	ADD A CHECK IN TYPE ROUTINE TO POPJ RIGHT OUT IF NAME
;	OF FILE IS 0 (NO NAME, NO WILDCARDS) TO AVOID AN
;	INCREDIBLY BIZARRE BUG IN WILD.

;513)	DON'T TURN ECHO OFF UNTIL ENTIRE COMMAND LINE(S) TYPED,
;	SO CONTINUATION LINES WILL ECHO.

;514)	IF UFD INTERLOCK IS BUSY TOO LONG GET NASTY AND BREAK
;	THE DOOR DOWN.

;515)	MAKE SURE RP.LOG ALWAYS GETS SET [QAR 3638]

;516)	CODE CLEANUP.

;517)	DON'T TYPE 'NO OPERATOR COVERAGE' ON EVERY RETRY.

;520)	DON'T BOTHER CLEARING TMPCOR, CLEAN UP SOME COSMETICS.
;	ALSO LOCK OUT CTRL-C WHILE WE HAVE UFD INTERLOCK.

;521)	FIX HANDLING OF /CORE.
;	THIS WILL BE LAST EDIT IN VERSION 57.  NEXT EDIT NUMBER
;	WILL BE 540 TO LEAVE ROOM FOR MAINTENANCE EDITS.

;540)	CHECK CREATION DATE-TIME OF ATING FILES AND REBUILD
;	HIGH SEGMENT DATA BASE IF THEY HAVE CHANGED.

;541)	IF NOT JACCTED, GIVE WARNING MESSAGE.

;542)	FIX /VERB AND /MESSAG.

;543)	MOVE CALL TO RNMAIL TO BEFORE THE LOGIN UUO SO IT HAS
;	JACCT AND CAN RENAME MAIL TO USER'S AREA.

;544)	.REQUEST SCAN, WILD, AND HELPER TO SIMPLIFY ASSEMBLY & LOADING

;545)	FIX ONE MORE BUG IN /CORE.

;546)	DETERMINE WHETHER TTY IS A 2741 EARLIER SO IF WE DO THE
;	NUMBER-SIGN PROMPT WE GO INTO TI WAIT RATHER THAN
;	HIBERNATING SO THE KEYBOARD UNLOCKS.

;547)	ALLOW /QUOTA TO FORCE RECOMPUTING EVEN IF OTHER JOBS SAME PPN.

;550)	ADD /SFDPROT:055 SWITCH TO DO THE OBVIOUS.

;551)	REWROTE CODE AT NSPOOL+1 SO /CORE WILL FINALLY WORK CORRECTLY

;552)	REORDERED CODE AROUND ACCT1 THRU ACCT3 AND MOVED
;	CODE FOR TYPING DATE AND TIME TO DAYMES,
;	WHERE IT BELONGS

;553)	FIX BUG IN WAITO ROUTINE.

;554)	ADD /UFDPROT:N SWITCH TO DO THE OBVIOUS.
;555)	DON'T ALLOW ATTACHES AFTER KSYS UNLESS OPR OR SON-OF-OPR

;556)	CLEAN UP THE LISTING

;557)	ADD 2 SECURITY FEATURES.  ASSEMBLY SWITCH NCRYPT CAUSES CODE TO
;	BE GENERATED TO ENCRYPT PASSWORDS BEFORE COMPARING THEM TO THE
;	PASSWORD IN ACCT.SYS (WHICH WAS ENCRYPTED BY REACT ALREADY).
;	THE ENCRYPTION FUNCTION IS A NON-INVERTIBLE FUNCTION SO HACKERS
;	CAN READ ACCT.SYS ALL THEY WANT AND NOT GET INTO SOMEONE'S PPN.
;	ASSEMBLY SWITCH PSWCHG ALLOWS USERS TO CHANGE THEIR OWN PSWDS
;	AT LOGIN TIME BY SPECIFYING THE /PASSWORD SWITCH IN THE LOGIN
;	COMMAND LINE.  THIS CAUSES LOGIN TO PROMPT FOR A NEW PASSWORD
;	AND WRITE IT INTO ACCT.SYS.  NOTE: THE ENCRYPTION FEATURE
;	REQUIRES VERSION 32 OF REACT.

;560)	REMOVE THE SIGNIFICANCE OF SLASH IN PPN (REPLACED BY /NOTICE)

;561)	DO AN EXTENDED LOOKUP OF THE FACT FILES SO WE ALWAYS GET
;	THE FILE'S LENGTH IN WORDS AND DON'T MAKE FACT.SYS SEEM
;	TO BE MESSED UP (HIATUS RECORDS).

;562)	IF WE GET THE SKIP RETURN FROM THE IN UUO THAT READS
;	ACCT.SYS, CHECK THE ERROR CODE RATHER THAN ASSUMING THAT IT
;	IS END-OF-FILE.  IF IT ISN'T, GIVE A MORE ILLUMINATING ERROR
;	MESSAGE THAN "INVALID ENTRY - TRY AGAIN".

;563)	DON'T ENABLE CONTROL-C IF THE USER IS LOCKED INTO RUNNING
;	A PROGRAM BY ACCT.SYS.

;564)	CLEAN UP THE EXIT SEQUENCE.

;565)	RE-INIT STACK EVERY TIME THROUGH LOGIN3.

;566)	TURN RP.LOG OFF IF USER CONTROL-C'S DURING RECOMPUTING
;	SO HE WON'T RECOMPUTE NEEDLESSLY NEXT TIME.

;567)	IF EITHER HALF OF LIB PPN IS ZERO, USE USER'S HALF AS DEFAULT.

;570)	CLEAN UP THE CODE.

;571)	REMOVE FACT FILE CODE FROM LOGIN.  MOVE IT TO A SEPARATE MODULE
;	CALLED FACTOR AND CALL THIS MODULE FROM LOGIN.

;572)	ADD CHECK TO BYPASS BLANK AUXACC.SYS ENTRIES.

;573)	FIX ?LGNSND ERROR IN MONITORS WITH LIMLVL=5.

;574)	SAVE M, N, AND CH OVER STUFBS IF THE MESSAGE IS TYPED
;	SO GARBAGE QUOTAS ARE NOT TYPED.

;575)	MAKE BATCH JOBS WAIT TWICE AS LONG ON UFD INTERLOCKS
;	AS INTERACTIVE JOBS, AND DON'T LET THEM BREAK IT DOWN.

;576)	FIX ?ILL MEM REF WHEN CUSP-TO-RUN DOESN'T EXIST
;577)	ALLOW LOGIN WITH NO AUXACC.SYS IF OPR OR HIS OFFSPRING

;600)	DON'T TYPE ERROR SEVERITY TO ANYTHING BUT A BATCH JOB.

;601)	ADD TWOSEG TO LGNDCL MACRO SO LOGIN COMPILES WITH
;	MACRO V.51

;602)	CHECK JBTLIM TO SEE IF BATCH JOB SO WE DON'T DEPEND
;	ON BATCON BEING CALLED BATCON

;603)	CHECK TIMES-TO-LOG IN FOR BATCH JOBS AND AC.BAT

;604)	FIX PROBLEM WITH 2ND TRY AT LOGGING IN WITH /ASSIGN
;	GIVES ? NULL DEVICE ILLEGAL FROM SCAN

;605)	REWRITE CODE AT NOJBMS THRU TTYDET TO FIX BUG
;	INTRODUCED BY EDITS 602 AND 603

;606)	ALLOW ATTACH AND LOGIN AFTER KSYS FROM LOCAL TTY'S

;607)	FIX PROBLEM IN EDIT 605.

;610)	PASSWORDS IN ACCT.SYS ENTRIES WHICH SPAN DISK BLOCKS CANNOT
;	BE CHANGED.  CURE: REMEMBER ONLY POINTER TO PASSWORD,
;	DON'T WORRY IF WHOLE ENTRY CAN'T BE READ IN ONE DSK READ

;611)	PREVENT STRANGE RACES IN ATTACHES

;612)	MAKE ?MAY NOT LOGIN REMOTE/DATASET/BATCH/BATCH SUBJOB
;	ERRORS FATAL SO BATCON WON'T WASTE TIME
;	TRYING TO LOG THE JOB IN

;613)	CLEAN UP THE LISTING; REMOVE UNREACHABLE CODE AND
;	UNREFERENCED DATA

;614)	EDIT 573 IS MISSING A POPJ. CURE: YES.

;615)	SETNAM TO LOGIN RATHER THAN FLUSH TO EVADE KLUDGE IN STOP1C.

;616)	DON'T CHANGE UFD PROTECTION UNLESS /UFDPROTECT SPECIFIED.

;617)	MORE CHANGES TO CONFORM TO MACRO 52.

;620)	IMPLEMENT /DEFPROT:NNN TO SET DEFAULT FILE PROTECTION.

;621)	DON'T PRINT STRANGE GARBAGE IF USER TYPES .R LOGIN

;622)	DON'T LOG IN A USER WHOSE SCHEDULER CLASS HAS A ZERO
;	CPU QUOTA IF THE CLASS SCHEDULER IS RUNNING.

;623)	ENTRY POINT TO FACTOR IS NOW CALLED .FACTR

;624)	PICK UP WHERE EDIT 610 LEFT OFF AND REALLY FIX /PASSWORD.
;625)	SLEEP BEFORE TYPING ?LGNIET TO MAKE IT HARDER TO BREAK
;	SECURITY (EASIER THAN SLEEPING BEFORE ASKING FOR PASSWORD
;	AND TRAPPING FOR CONTROL-C'S WHILE SLEEPING)

;626)	IF WE DON'T HAVE JACCT, WE'RE BEING DEBUGGED - SO DON'T
;	RECOMPUTE DISK USAGE

;627)	/ASSIGN:PHYS-NAME WITH NO LOGICAL NAME LOSES.  FIX IT.

;630)	MAKE "NO OPR COVERAGE" INFORMATIONAL RATHER THAN WARNING.

;631)	LAST-MINUTE CODE CLEANUP.  THIS WILL BE THE LAST EDIT
;	IN VERSION 60.

;632)	DON'T TRY TO SET SCHEDULER CLASS QUOTAS IF 6.03 SCHEDULER
;	RUNNING IN WMU MODE

;633)	LOCATE USER AT CENTRAL SITE IF LOGGING IN ON A NODE WITHOUT
;	AN LPT
;634)	SEE EDIT HISTORY FOR 672 EDIT

;%60A(634)	SHIPPED WITH 6.03A

;635-637) RESERVED FOR DEC 6.03 SUPPORT

;640)	DO PHYSICAL-ONLY RUN UUO FOR CUSP-TO-RUN (SECURITY)

;641)	DISABLE CONTROL-C JUST BEFORE LOGIN UUO AND ENABLE ONLY IF
;	NO CUSP-TO-RUN SPECIFIED

;642)	IF A LINE OF SWITCH.INI ENDS WITH A /ASSIGN, AND THE NEXT LINE
;	CONTAINS A /ASSIGN, YOU GET ?SCNILC ILLEGAL CHAR IN CMD
;	FIX: CLEAR R.EOL EACH TIME THROUGH ASSIGN

;643)	ENQ QUOTA DOESN'T GET SET UP; SENSE OF TEST INSTRUCTION IS BACKWARDS
;	AT PRSET3+5

;644)	FIX YET ANOTHER CASE OF OFF-BY-ONE ARITHMETIC AT UFDEX1-2

;645)	DELETE SEARCH LIST IF USER TYPES ^C WHILE LOGGED OUT

;646)	?LGNCWR UNDESERVEDLY - WRONG GETTAB VALUE BEING USED

;647)	FIX SWITCH.INI NOT BEING READ IF FACTSW TURNED OFF

;650)	RESERVE BATMIN JOB SLOTS FOR BATCON'S USE

;651)	FIX BUG IN /PASSWORD (BUG ONLY IF NCRYPT TURNED ON)

;652)	DON'T ATTEMPT TO CREATE SFD'S ON STRS THAT ARE WRITE-LOCKED

;653)	REMOVE EDIT 547 WHICH ALLOWS USERS TO AVOID QUOTAS

;654)	FIX EDIT 650 SO ATTACH WORKS DESPITE BATMIN.  SPR#10-23336

;655)	SUPPORT "<" AS PPN DELIMITER ON ATTACH.  THIS IS FOR 2741.
;	SPR #10-23335

;656)	TEACH LOGIN ABOUT FIXED VS. UNFIXED CLASS QUOTAS.  SPR#10-23094.

;657)	DON'T PERMIT DATA-SET LOGINS AFTER KSYS.

;660)	PERMIT DETACHED [1,2] JOB TO LOGIN PTY SUBJOBS. SPR #10-23725.
;	NOTE: ONLY PERMITS SON OF [1,2] NOT SON OF DETACHED OPR OR CTY.

;661)	MOVE LOGIN UUO AFTER MESSAGE TYPE-OUT TO PERMIT PROPER /STR
;	OPERATION.  SPR #10-23847

;662)	EDIT 661 WAS NOT VERY GOOD.  REMOVE IT AND TRY AGAIN.

;663)	FIX UP ALL DATES AND COPYRIGHT STATEMENTS

;664)	DON'T PERMIT MORE THAN LOGMAX JOBS IF BATMAX TESTING
;	IS DISABLED.  SPR #10-24354.

;665)	LOGMAX+1 JOBS CAN LOGIN; SHOULD BE LOGMAX.  SPR #10-24354

;666)	IMPLEMENT ACCOUNT AND REMARK PROMPTS TO ENTER AN ACCOUNT STRING
;	AND A REMARK

;667)	DO UFD ZERO COMPRESSION WHEN RECOMPUTING QUOTA.
;	THIS USES THE DISK. UUO FUNCTION CODE 7 WHICH IS NEW FOR
;	7.01.  THE EFFECT OF UFD COMPRESSION IS TO SPEED UP
;	LOOKUPS AND ENTERS.

;670)	FIX BAD POPJ ON ERROR RETURN FROM CTLJOB UUO. SPR #10-24481

;671)	FIX SOME PROBLEMS INTRODUCED BY EDIT 666.

;672)	ADD BACKROUND BATCH SUPPORT.

;673)	IMPLEMENT ACCOUNT VALIDATION

;674)	PUT IN TEMPORARY FIX SO BATCH JOBS CAN RUN WITH ACCOUNT VALIDATION

;675)	IMPLEMENT /TYPE SWITCH TO SET TERMINAL TYPE.

;676)	SPR # 10-25342  WCL  JUNE-27-78
;	Fix code that checks for necessary job slots for Batch so it checks
;	how many Batch jobs are already logged in
;	Areas affected: PPNGO
;677)	FIX BUG IN 675.  AT NOTTYP INSERT  POP	T,T1.
;700)	FIX BUG WHERE CODE AT BACHEK NEVER GETS EXECUTED.
;701)	IMPLEMENT USAGE ACCOUNTING, SPECIFICALLY ACCOUNT VALIDATION (LGNUSG MODULE)
;702)	FIX A VALIDATION ERROR. ALSO MAKE THE LOGIN MESSAGE REPORT THE TIME
;	AS HH:MM INSTEAD OF HHMM.
;703)	FIX BUGS INTRODUCED WITH 702
;704)	DON'T LOSE OWNER PPN FOR NESTED PTY SUBJOBS. SPR #10-27223
;705)	MAKE  /PATH[,,SFD] USE LOGGED-IN PPN AS DEFAULT. SPR #10-27073
;706)	/BAH
;	1)  ADD ATTACH, LOGIN, AND SESSION IPCF MESSAGES SO THE ACCOUNT
;	DAEMON CAN DO USAGE ACCOUNTING WITH SESSION ENTRIES. 
;	2)  ADD /BATSEQ, /BATNAM, AND /REQID SWITCHES SO BATCON CAN PASS
;	BATCH JOB INFORMATION TO THE ACCOUNT DAEMON VIA LOGIN IPCF MESSAGES
;707)	/BAH ADD SETUUO FUNCTION TO SET OPERATOR PRIVILEGES FOR GALAXY 4 SUPPORT
;	3)  FIX UP EDIT 701'S ERROR MESSAGES
;710	REPEAT LOGMAX CHECK JUST PRIOR TO LOGIN UUO
;	SPR 10-27195
;711	CHECK THAT STR NAME IN AUXACC IS "FULL FILE STRUCTURE NAME"
;	SPR 10-27402
;712	/MSL/BAH 22-MAY-79 Display SEARCH, .REQUEST info during compilation
;713)	/MSL/BAH 22-MAY-79 Limit /DSKPRI value by ACCT.SYS
;714)	/MSL/BAH 22-MAY-79 Warn user if account expires within one month
;715)	/MSL/BAH 22-MAY-79 Let user logging in attach if PPN already has detached job
;716)	/MSL/BAH 22-MAY-79 Set up search list before calling OSCAN (for SWITCH.INI), thus
;	allowing account switches, UFD defaults, etc. in SWITCH.INI
;	This rewrite completely changes the order of things (such as 
;	where account validation and accounting is done).  As a result,
;	the FTTASK switch (an unsupported switch used by our in-house
;	systems) no longer applied as written and has been removed.
;717)	/MSL/BAH 22-MAY-79 No NOTICE.TXT if Job Capacity Exceeded
;720)	/MSL/BAH 22-MAY-79 Clear search list before LOGOUT when flushing (c.f. ed.645)
;721)	/MSL/BAH 22-MAY-79 Fix so last error try also gets a FACT entry
;722)	/MSL/BAH 22-MAY-79 Make ENCODE global (SPR 10-23055)
;723)	/MSL/BAH 22-MAY-79 Clear FL.ACC when done with ACCT instead of waiting for AUXACC
;724)	/MSL/BAH 22-MAY-79 Fill AUXACC pointer table, even if early EOF
;725)	/BAH 31-MAY-79 IF A JOB REQUIRES AN ACCOUNT AND/OR REMARK AND THE
;	TERMINAL IS A PTY AND AN ACCOUNT/REMARK WAS NOT SUPPLIED, USE THE
;	CONTROLLING JOB'S ACCOUNT (IF IT EXISTS) AND ALLOW A NULL REMARK.
;726	IF A USER HAS ZERO LOGGED-IN QUOTA ON A STR IN HIS SEARCH LIST
;	DON'T TRY TO CREATE AN SFD ON IT.
;727	COMMAND LIST IS ONE TOO LONG.  ALSO FIX A PJRST P,.USAGE
;730	SEARCH OF AUXACC.SYS FOR PPN IS OFF BY 1.
;	SPR 10-28333.
;731	REMOVE EDIT 730
;732	20-SEP-79/BAH CORE UUO TO EXPAND HIGH SEGMENT CAN FAIL IF 1) SOMEONE
;	IS SAVING LOGIN OR IF 2) IN AN SMP ENVIRONMENT, ANOTHER CPU IS
;	EXECUTING THE SAME CODE WITH THE HIGH SEGMENT WRITE-ENABLED.
;	TO GIVE THE MONITOR TIME TO CATCH UP, SLEEP A SECOND AND TRY AGAIN
;	(3 TIMES) IF THE CORE UUO FAILS.
;733	4-OCT-79/BAH  ADD ATTACH:ARG SWITCH.  IF ATTACH:IGNORE IS IN SWITCH.INI OR TYPED,
;	THEN DON'T PROMPT USER FOR ATTACH MESSAGE IF ANY DETACHED
;	JOBS UNDER HIS PPN.  IF ATTACH:ASK IS IN SWITCH.INI OR TYPED, THEN
;	ASK USER IF HE WANTS TO ATTACH OR LOGIN.  THE DEFAULT IS
;	ALWAYS ASK IF ANY DETACHED JOBS.  SEE EDIT 715.
;734	22-OCT-79/BAH SET U.ACTS AND U.RMRK TO -1 FOR SCAN.  ALSO ZERO  THEM
;	BEFORE FILLING IN THE CHARACTERS SO THE USAGE FILES GET THEM RIGHT.
;735	7-NOV-79/BAH  MAKE LOGIN SEARCH ACTSYM.UNV INSTEAD OF ACCSYM.UNV.
;736	25-JAN-80/BAH  EDIT 723 CLEARED FL.ACC TOO SOON CAUSING PASSWORDS
;	NOT TO BE CHANGED.  ALSO EDIT 716 DELETED THE CALL TO .USAGE THAT
;	SENT A LOGIN MESSAGE TO THE ACCOUNT DAEMON.  ALSO CHANGE THE CALL TO
;	.SIXSW FOR THE /BATNAM SWITCH TO .SIXQW.
;737	14-FEB-80/BAH IF A USER TRIES TO LOGIN WITH AN ILLEGAL PROGRAMMER
;	NUMBER, THEN LOGIN GOES INTO A LOOP READING ACCT.SYS AND REBUILDING
;	ITS TABLE.
;740	SPR 10-28750 Edit 627 caused SCAN to read the slash after a name
;	twice in an /ASSIGN switch if there were more switches.
;741	11-Apr-80/BAH QAR 10-03985 Don't type out error message setting
;	operator privileges if the monitor version number is earlier than
;	7.00.
;742	24-Apr-80/BAH LOGIN doesn't send the terminal designator in its
;	LOGIN and ATTACH IPCF messages to the account daemon.  Include
;	a common routine to find the terminal designator, line number and
;	node name of the job -- SETTNL.  Also include a switch to defer
;	TTY output /TTDEFER.
;743	29-april-80/FRS SPR 10-28831
;	Change put in FACTOR to check to see if job being attached to
;	is DAEMON and [1,2].  If so, skip trying to write FACT entry.
;744	5-May-80/WSM Allow new form for specifing settty switches for LOGIN.
;	ie /TERMINAL:(NOPAGE,SPEED:300,WIDTH:80,TYPE:VT52) instead of a
;	random set of several switches. Also, cleanup some SCAN switch
;	handling. Use standard version macro from MACTEN.
;	Fix recovery from %LGNTTI Terminal type invalid errors
;745	6-May-80/WSM Improve command scanning especially for SESSION
;746	6-MAY-80/WSM Fix the bug that didnt set path to area that
;	already existed if user had no login quota or software write-locked
;	Also, type warning if any PATH. uuo fails.
;747	1-Jun-80/WSM Complete implementation of /TERMINAL by adding 
;	keywords [no]UC, NOFILL and [no]TIDY. Also, dont prompt with 
;	password if the user types it on the same line.
;750	2-Jun-80/WSM Include debugged DDT patch for testing LOGIN under 7.01 
;	(QAR 10-04145) Add /DEFBUFFER:n switch to set default number
;	of disk buffers, like .SET DEFAULT BUFFER n command
;751	3-Jun-80/WSM (QARs 10-42046, 10-04172) LOGIN loops if invalid PPN given.
;	Edit 737 didnt fix the problem as reported.
;
;;61(751) released with 7.01
;Start V62 for Galaxy 4.1
;
;752	17-Jun-80/WSM Fix the usage accounting entries for ATTACH and
;	SESSION commands.  Remove unreachable code.
;753	27-Jun-80/DPM
;	Add /BATINT:[NO/YES] and /BATSTR:ooo so BATCON can set the Batch
;	operator intervention values and Batch stream numbers. This is
;	required for Galaxy 4.1 and later versions of QUASAR and ORION.
;	These switches apply only to Batch jobs and are ignored for
;	timesharing jobs. Also before we open the TTY, determine if the job
;	is a Batch job and don't turn off echoing. Note: SCNSER must also
;	check this at TTYRS1 plus a few and not turn off echoing when an
;	unlogged in job starts running LOGIN.
;754	8-Jul-80/WSM Add some fixes for accounting support
;	  1) Include expiration date in UFD (.RBDED)
;	  2) Dont type NOTICE.TXT on errors with SESSION command
;	  3) Expand ATTACH message to include target job number
;	  4) Dont allow retries on SESSION command
;	  5) Dont do checks to see if user can LOGIN if SESSION command
;	  6) Flush receive queue correctly when waiting for ACK
;	  Improve date/time printing (use SCANs routines)
;	  Add lost instruction @RICC to fix ^C problems
;755	SPR #10-29629	RKB	14-Jul-80
;	(published 15-Jul as edit 752) Fix a bug in edit 651 so /PASSWORD
;	will work properly with NCRYPT set.
;756	Be consistant in handling account string and remark. If its
;	-1 (for SCAN and ACTDAE's benifit) it hasnt been specified.
;	Anything else should be treated as ASCIZ text
;757	SPR #10-29879		12 AUG 80
;	Creating SFDs on all structures is annoying, so lets let the
;	user say whether he wants it to happen or not. Install the
;	/[NO]SFDCREATE switch, which allows him to say 'DONT CREATE'
;760	If you logged in and recomputed disk usage at or before 4 minutes
;	22.192 seconds after midnight, LOGIN would die with ?Illegal
;	address in UUO trying to compress the UFD.
;	Also, change REPEAT 0 to IFN FTMAIL for RNMAIL routine.
;761	23-Sep-80/WSM Convert to more UUOSYM and ACTSYM symbols
;	Allow /LOCATE to take sixbit node name
;	Improve usage accounting routines--Dont let user in if account
; 	 validation is required, and ACTDAE isnt around or talking to us
;762	28-Sep-80/WSM Cleanup error messages and interface with BATCON.
;	In the process, fix ?Job capacity errors from dumping the job.
;	Dont output ^D when you fail to login. Thats old stuff.
;	Define new bit in error macros to WTO to operator. This removes
;	all the "Please call the operator" messages. If ORION isnt running
;	that text is appended to the users output.
;763	30-Sep-80/WSM (QAR 10-04663) Improve ATTACH query logic. Give 
;	a small SYSTAT output (job, program, state), and if/when we
;	attach to a job, preserve the user/monitor state.
;764	Use ND to set number of days for warning on %PPN will expire message
;765	6-Oct-80/WSM (QAR 10-04728) Improve things a little
;	bit if the unsupported PSWCHG feature test is turned on
;	by asking for new password twice with echo off
;766	20-Oct-80/WSM Remove part of edit 761 which allowed LOCATE to take SIXBIT name.
;	It requires more monitor/GALAXY support than was thought.
;	Dont create a UFD of AUXACC says its write-locked.
;	(QAR 10-04816) Change BLANK to BLANKS to be consistent with
;	INITIA and monitor SET TTY commands
;767	24-Nov-80/WSM (QAR 10-04969) LOGIN is too hard to be debugged.
;	Add more tests for R.DBUG
;770	24-Nov-80/WSM LOGIN loses /OPTION when asking for detached jobs.
;	Save /OPTION around second .PSCAN call. Requires kludge that assumes
;	SCANs OPTION storage is .NMUL##-3 (until OPTION made global)

;771	16-Dec-80/WSM Add support for ACTDAE returning an account string
;	from a validation request. (It may be a default, or case changed)
;772	15-Jan-81/WSM (QAR 10-05259) Allow switches on ATTACH to attach to
;	the job in either user or monitor mode.
;773	15-Jan-81/WSM Allow OPR[1,2] to login in w/o an account string if
;	the PID of ACTDAE doesnt exist in 5 seconds.
;	Dont complain if the LOCATE UUO fails and he is trying to locate
;	to the central site (node 0)
;774	30-JAN-81/WSM (QAR 10-05356) Allow SESSION command to be invoked
;	from CCL entry point and look for TMP:LGN. Always send account
;	string to ACTDAE for possible defaulting.
;	(QAR 10-05356) Path not also set correctly if we cant create an
;	SFD in the path. Get around SCAN bug with .LOGIN/ACCOUNT:"" using
;	SWITCH.INI when it shouldnt
;775	17-Feb-81/WSM (QAR 10-05478) Fix up more scanning problems with
;	the /ACCOUNT switch.  Change some UUOSYM symbols that changed.
;	Allow indirect command files for SESSION command.
;776	19-Mar-81/WSM (QAR 10-05786) Fix blanks in TERMINAL scanning
;	(QAR 10-05797) Dont type expiration date on ATTACH
;777	7-Apr-81/WSM (QAR 10-05931) Fix a one instruction race
;	(QAR 10-05925) Remove checks for level C disk service!
;	(QAR 10-05942) Check response from ATTACH question for YES/NO
;	(no QAR) Remove checks for old scanner service
;1000	9-Apr-81/WSM Move setting batch stream number before STRUUOs
;	to change search list so we dont confuse QUASAR.
;
;1001	9-Jul-81/WSM Increase MAXFS to 7.01 defined value of 10; handle
;	more AUXACC entries than can fix in a S/L more gracefully.
;1002	16-Nov-81/WSM Bypass accounting if we are attaching to the
;	ACTDAE job so we dont get hung if ACTDAE is ^Ced.
;	Improve ATTACH job query logic to show default and preserve
;	/OPTION around .PSCAN better.
;1003	23-Nov-81/WSM Insert fix for ^C, and removed window where user
;	can ^C out of cusp-to-run. This was incorrectly published as
;	edit 754 to LOGIN as CMCO 571.1.
;1004	9-Mar-82/WSM (QAR 10-06880) Explicitly BLT scan block words to
;	zero in routine PARSE.
;	(QAR 10-06495) /SCAN not set /NOSFDCREATE and the SFD doesnt exist.
;1005	27-Aug-82/DPM (QAR #10-02018) Correct logic to GETTAB ACTDAE pid.
;Start of version 63 for 7.02
;
;1100	14-JUL-81/WSM Add support for new terminal switches, and /DEFAULT:(BIGBUF)
;	Allow new batch switch syntax of /BATCH:(args) too.
;1101	30-Jul-81/BCM (SPR 10-30609) Add a new UUO to do LOGMAX/BATMAX
;	quota checking.  This is necessary to eliminate race between two
;	simultaneous LOGINs where LOGNUM could be 1 greater than LOGMAX.
;1102	21-Aug-81/BCM (SPR 10-30832) Correct test for no
;	class scheduler at PRSET4 and NOTHER.
;1103	8-Sep-81/WSM Add (under FTMAIL) /[no]MAILCHECK switch to control
;	scanning for new mail. Check for mail on ATTACH too.
;1104	3-Feb-82/WSM Add new TRMOP. to see if we are on a full-SCNSER-PTY
;	so we know we can turn the echo off.
;1105	26-Apr-82/WSM Rip out lots of code, and call DPM's new UFDSET routine
;	to handle UFD setup. This is the same routines that PULSAR/MDA
;	use, so it should all do it the same way.
;1106	29-Jun-82/WSM Fix up all error messages and macros (This also
;	fixing the ^C ?Ill mem ref bug introduced with edit 1105)
;
;1107	22-Apr-83/DPM
;	1. Turn on echo if called by SCAN for continuation lines.
;	2. Don't make junk FACT file entries on LOGIN failures.
;	3. Allow /QUOTA:(str,...).
;	4. If a name is required, make sure it's non-zero.
;
;1110	26-Apr-83/DPM
;	Eliminate problems with I/O to unassigned channel by doing buffered
;	OUTSTRs to the TTY.  This is a lot more efficient than doing buffered
;	I/O and saves lots of OUTPUT TTY, instructions.
;
;1111	 8-Jul-83/DPM
;	1. Add a few missing calls to TTYOUT.
;	2. Disconnect line if too many command format errors.
;	3. Call .ISLGI to determine logged-in/out status in FLUSH routine.
;	4. Finally after all these years, add verbosity checking in ERRMSG
;	   routine.  Attn. future LOGIN hackers: calls to .PSCAN wipe .FLVRB!
;	5. Fix up listing stuff in .ERR. macro.
;
;1112	31-Aug-83/DPM
;	Don't set UFD protection to <000> when recomputing disk usage on
;	structures not in AUXACC.
;
;1113	12-Sep-83/DPM
;	1. FATAL, WARN, INFO, etc. still don't list.
;	2. Make references to .POPJ1 external in LGNMS.
;
;1114	21-Sep-83 /DPM
;	1. Remove ZEROSL.  No longer needed now that the LOGOUT UUO does this.
;	2. Remove unreferenced and non-existant symbols from GLOB macros.
;	3. Remove unreferenced low seg locations.
;	4. Repeated ^Cs typed while recomputing disk usage gives ill mem ref.
;	   ERRMSG isn't recursive. Fix Control-C trap.
;
;1115	12-Jan-84 /DPM
;	Add missing AC in test instruction (UFDSET + a bunch).
;
;63(1115) released with 7.02
;This patch will allow you to debug LOGIN under normal timesharing
; The patch is executed via FILDDT and causes your terminal to 
; run LOGIN from HAKSTR/HAKPPN while all other terminals use SYSPPN. 

;This patch has been tested under the 7.01 monitor


	REPEAT 0,<

PATCH/	HAKPPN:	10,,3146
PATCH+1/	0	HAKSTR:	$"/DSKQ/
PATCH+2/	0	LOGHAK:	PUSHJ P,.+2
LOGHAK+1/	0	JRST MSTART
LOGHAK+2/	0	LGHAK1:	PUSHJ P,SAVE1
LGHAK1+1/	0	MOVEI P1,(U)
LGHAK1+2/	0	LOGLDB:	CAIE P1,-1
LOGLDB+1/	0	POPJ P,
LOGLDB+2/	0	MOVE P1,SGANAM+.JDAT
LOGLDB+3/	0	CAME P1,LOGTXT
LOGLDB+4/	0	POPJ P,
LOGLDB+5/	0	MOVE P1,JBTSTS(J)
LOGLDB+6/	0	TLNE P1,JLOG
LOGLDB+7/	0	POPJ P,
LOGLDB+10/	0	MOVE P1,HAKSTR
LOGLDB+11/	0	MOVEM P1,SGADEV+.JDAT
LOGLDB+12/	0	MOVE P1,HAKPPN
LOGLDB+13/	0	MOVEM P1,SGAPPN+.JDAT
LOGLDB+14/	0	POPJ P,

COMCON$:
SGST1B-FTMP/	JRST MSTART	JRST LOGHAK
GJOB2 5/	SETZM 0(P)	JFCL
CLOGIN 1/	JRST LOGDET	JRST RUNAME

.CPJOB[	70	$Q<JOBNOX:
TTYTAB JOBNOX[	150022
$Q DDBLDB[	711622	$Q<LDB:
LOGLDB/	CAIE P1,-1	CAIE P1,LDB

>>>;END REPEAT 0
	SUBTTL	Parameters -- AC assignments

F=0	;FLAGS

T1=1	;TEMP AC'S
T2=2
T3=3
T4=4

P1=5	;PRESERVED
P2=6	; ..
P3=7	; ..
N=7	;NUMBERS INPUT
C=10	;CHARACTERS (THIS AC IS READ-ONLY, EDIT 102)
PP=12	;PROJECT PROGRAMMER PAIR
M=13	;MESSAGE ADDRESSES
CH=14	;CHARACTER FOR TYPE-OUT OR ANALYSIS
WD=16	;WORDS
P=17	;PUSHDOWN POINTER

	SUBTTL	Parameters -- IO channels

;0	;USED BY SCAN & WILD
;TTY==1	;TELETYPE
UFD==2	;FOR DISK IO
USR==3	;FOR CHECKING USER FILES
US1==4	;THESE TWO USED BY UFDSET
FCT==6	;FOR THE FACT FILE
	SUBTTL	Parameters -- Flags in F

SHFWAT==^D12	;BITS TO SHIFT WATCH BITS TO POSITION FOR SET UUO

;LEFT HALF

L.PEND==1	;STUFF IN TTY OUTPUT BUFFER
L.MANY==2	;ON IF MORE THAN ONE CONTROLLING JOB IN CHAIN
FL.WKD==4	;ON IF THIS IS A WEEKDAY
FL.FDX==10	;ON IF THIS IS A FULL-DUPLEX LINE
FL.RAS==20	;READ ACCOUNT FILE SYNC (I.E., TO RD 1ST WD)
FL.DET==40	;DETACHED (DISCONNECTED)
FL.ACC==200	;SET IF READING ACCT.SYS, NOT IF AUXACC.SYS
FL.BSJ==1000	;SET IF BATCH JOB SUBJOB
FL.ERR==2000	;SET TO WATCH FOR ERRORS IN UFD SCAN
FL.BAT==4000	;SET IF THIS JOB IS A BATCH JOB
FL.GPN==10000	;GENERATE A PROGRAMMER NUMBER
L.OPR==20000	;SET IF MY TTY IS OPR OR CTY
L.SOPR==40000	;SET IF I AM ON PTY UNDER OPR, CTY OR A 1,2 JOB
FL.ATT==100000	;SET IF ATTACH COMMAND
FL.WLD==200000	;WILD CARD PROGRAMER

;RH OF F

R.ACRE==1	;SET IF ANY CREATES ALLOWED ON ANY STR'S
R.ASTR==2	;SET IF ANY STR'S IN THIS JOB'S SEARCH LIST
R.PTYJ==10	;PTY JOB
R.COMA==20	;[440] COMMA HAS BEEN TYPED WHEN TELLING OTHER JOBS
R.2MNY==40	;[470] TOO MANY DEVICES MESSAGE HAS BEEN TYPED
R.EOL==100	;[473] END OF LINE SEEN WHILE DOING /ASSIGN
R.UIB==200	;[514] UFD INTERLOCK WAS BUSY TOO LONG & WE'RE
		;[514] GETTING IMPATIENT
R.UIBM==400	;[514] WE HAVE ALREADY TYPED A WAIT PLS MSG FOR THIS STR
R.DBUG==1000	;[626] WE'RE BEING DEBUGGED
R.NXSW==2000	;[627] NEXT SWITCH SEEN (DURING /ASSIGN PROCESSING)
R.SESS==4000	;SESSION COMMAND
R.RCOM==10000	;SET IF WE HAVE RECOMPUTED ALREADY
R.RDU==20000	;SET IF [RECOMPUTING DISK USAGE] ALREADY CAME OUT

;SPECIAL PPN CHARACTERS

UNISYM=="#"	;CHARACTER FOR CREATE UNIQUE PPN
UNIPRG==777776	;INTERNAL VALUE FOR UNIQUE PPN
	SUBTTL	Parameters -- Block lengths and versions

TRANSZ==10	;MAX SIZE OF FACT.SYS ENTRY
MAXENT==20	;MAX SIZE OF ENTRY IN ACCT.SYS

ACC506==2	;VERSION NUMBER OF OLD ACCT.SYS
ACC601==3	;VERSION NUMBER OF NEW ACCT.SYS
ACC602==4	;[356] VERSION NUMBER OF ACCT.SYS FOR 6.02
AC1FOR==0	;FORMAT VERSION NUMBER FOR AUXACC.SYS

FBMTRY==^D10	;TIMES TO RETRY TO ENTER OR RENAME UFD
IFNDEF	RP.NQC,<	
RP.NQC=2000	;DO NOT INCLUDE FILES WITH THIS BIT SET IN
		; .RBSTS IN LOGGED OUT QUOTA CHECK
>
SCDSIZ==^D1024/4 ;[425] SIZE OF SCHEDULER CLASS TABLE

MAXFS==^D10		;MAXIMUM NUMBER OF FILE STRUCTURES PER USER

AC1BLK==5		;NUMBER OF WORDS PER BLOCK IN AUXACC.SYS ENTRIES

EXLLEN==.RBDED+1	;[754]LENGTH OF ARGUMENT LIST FOR EXTENDED LOOKUP/ENTER/RENAME
	SUBTTL	Message macros

;ERROR CODES FOR TYPES OF LOGIN ERRORS (FOR PTY JOBS)
;**** NOTE ERROR COMMENTS SHOULD ALL BEGIN WITH A QUESTION MARK
;**** AND FOR PTY JOBS INCLUDE AN ERROR TYPE OF THE FORM
;**** (#) WHERE # IS ONE OF THE FOLLOWING:

;ERR.NF==1	;NON FATAL (Not used by BATCON or LOGIN)
;ERR.SF==2	;SEMI FATAL (Not used by BATCON or LOGIN)
 ERR.FT==3	;FATAL - CANCEL JOB
 ERR.SS==4	;STOP SCHEDULING (Shutdown batch stream but requeue job)
 ERR.RQ==5	;REQUE JOB (Requeue job)

IF1,<

;FLAGS IN LEFT HALF OF EF
EF.SYS==1B1	;SYSTEM ERROR
EF.ERR==1B2	;FATAL ERROR
EF.WRN==1B3	;WARNING
EF.INF==1B4	;INFORMATION LINE (IN [])
EF.REQ==1B5	;REQUE JOB
EF.WTO==1B6	;WTO ERROR TO OPERATOR (ANY ERROR MESSAGE TYPE)
EF.SIL==1B7	;SUPPRESS NOTICE.TXT TYPEOUT ON FATAL ERRORS
EF.FMT==1B8	;FORMAT ERROR (USER GETS TO RETRY)

;SUPER FATAL ERROR -- NEVER RETURNS
;THE BATCH STREAM IS SHUTDOWN, AND THE JOB IS REQUEUED
	DEFINE	STOP(PFX,TXT,FLG,MOR),<
	.ERR.	EF.SYS,PFX,<TXT>,FLG,MOR
>

;FATAL ERROR (HOWEVER, SYSTEM IS STILL OK)
	DEFINE	FATAL(PFX,TXT,FLG,MOR),<
	.ERR.	EF.ERR,PFX,<TXT>,FLG,MOR
>

;WARNING MESSGAE
;CALL WITH:
;	WARN	PREFIX,<TEXT>
	DEFINE	WARN(PFX,TXT,FLG,MOR),<
	.ERR.	EF.WRN,PFX,<TXT>,FLG,MOR
>

;SEMI-FATAL ERROR--BATCON SHOULD REQUE JOB AND STOP SCHEDULING
;FOR A LITTLE WHILE
;CALL WITH:
;		REQUE	PREFIX,<TEXT>
;		  NEVER RETURN
	DEFINE	REQUE(PFX,TXT,FLG,MOR),<
	.ERR.	EF.REQ,PFX,<TXT>,FLG,MOR
>

;INFORMATION MESSAGE (PRINTED IN [])
;CALL WITH:
;	INFO	PREFIX,<TEXT>
	DEFINE	INFO(PFX,TXT,FLG,MOR),<
	.ERR.	EF.INF,PFX,<TXT>,FLG,MOR
>

	DEFINE	.ERR.	(TYP,PFX,TXT,FLG,MOR),<
LGN'PFX:PUSHJ	P,[XLIST
		   PUSHJ P,ERRMSG	;CALL ERROR MESSAGE
		   IFB  <MOR>,<XWD 0,''PFX''>
		   IFNB <MOR>,<XWD MOR,''PFX''>
		   IFB  <FLG>,<TYP![ASCIZ\TXT\]>
		   IFNB <FLG>,<TYP!FLG![ASCIZ\TXT\]>
		   LIST]
	>

> ;END IF1
	SUBTTL	Inter-module globals

IF1,<
	DEFINE	GLOBS,<
GLOB <ACCT,AD.YN,ALAST,CLRRIB,DATEPR,ATTIGN>
GLOB <W.ACCT,W.AUX,W.SCED>		;[540]
GLOB <LGNWFV,BADNAM>
GLOB <DAYMES,DSKFER,DSKFPA,ENTPTH>
GLOB <ERRMSG,ETOLO,FLUSH,FRUN,GET2WD,GETCOD>
GLOB <GETACT,.USAGE,ACTVLD>
GLOB <GETNAM,ISBATC,LAST>
GLOB <LOKBLK,LOKBLN,LOGBLN,LOGBLK,NOATT>
GLOB <NOSYS,NEWLIN,DIEMSG>
GLOB <PPERR1,PRVSET,PSWOK,RDACCT,RDUFD,GLXSET>
	IFN	PSWCHG,<
GLOB <WTUFD>
	>;END	PSWCHG
GLOB <SNOOZE,SPLBTS,STYO,TOLO>
GLOB <TOLO1,TRANSZ,TRYAGN,TTYGET,TTYGO,TYI,TYO>
GLOB <USRSET,POSTMS,WATBTS,WTCHDA>	;[472]
GLOB <ACCTA,CODGET,FLUSHX,LOGIN3,CRLFPD>	;[517]
GLOB <SCDTBL,SCDBLT,BLDSCD,LOK,UNLOCK>		;[425] SCHED STUFF
IFN FASTLG,<GLOB <ENTSIZ,DACCFL,DLOCK,DAUXFL,DACCL,PDACC,NEWACT,EQACT>>

;STUFF IN LGNLOW
GLOB <PDPLST,LGIARG,FCTAHD,FCTHED,FCTFMD,FCTWD,FCTFWD>
	>>

GLOB <RDUFLG,UFDNDL>
	SUBTTL	Global storage definitions

;MACRO TO DEFINE COMMON LOWSEG FOR ALL MODULES
IF1,<
	DEFINE	LOWVAR,<
LBLOCK	ZZBEG,0		;;START OF BLT TO ZERO
LWORD	TTYPTR,		;;BYTE POINTER TO TTY BUFFER
LWORD	TTYCNT,		;;BYTE COUNT
LBLOCK	TTYBUF,TTYBSZ	;;TTY OUTPUT BUFFER
LBLOCK	INTBLK,4	;;CONTROL-C INTERCEPT BLOCK
LWORD	CCWAIT,		;;IF 0 DO CONTROL-C WHEN TYPED.
			;;IF -1 WAIT FOR CRTITICAL CODE TO COMPLETE
LWORD	CCTYPE,		;;-1 IF CONTROL-C TYPED.
LBLOCK	LASTX,0		;;LAST PIECE OF CODE
LWORD	SAVERG,		;;USED TO SAVE A REGSTER BY LGNDSK
LWORD	HELP,		;;POINTER TO HELP STRING
LWORD	HPOS,		;;POSITION ON LINE
LBLOCK	WILDBK,.FXLEN	;;BLOCK USED BY WILD
LBLOCK	JUNK,4		;;[422] PLACE TO THROW AWAY SHORT LOOKUP BLOCK
LWORD	RDUFLG,		;;RECOMPUTING DISK USAGE TYPEOUT FLAG
LBLOCK	UFDBUF,200	;;[571] BUFFER FOR READING UFD'S
LBLOCK	PTHBUF,11	;;
LBLOCK	CHRBUF,.DCSAJ+1	;;BUFFER FOR DSKCHR
LBLOCK	SRCBUF,EXLLEN	;;
LBLOCK	SECBUF,.RBTIM+1	;;[540]
LWORD	UFDFSN,		;;FILE STRUCTURE NAME
LWORD	UFDMTP,		;;
LWORD	UFDDMJ,		;;
LWORD	UFDDMP,		;;
LBLOCK	UFDDMF,MAXFS*3+1;;[371]
LBLOCK	UFDARG,.UFSIZ	;;ARGS TO .UFD IN UFDSET.MAC
LBLOCK	SAVAUX,MAXFS*5+1;;Save AUXACC entries while setting S.L.
LWORD	FCTFNC		;;FACTOR writes in FCTDAT-1 the .FACT function
LBLOCK	FCTDAT,TRANSZ	;;
LBLOCK	RDHED,2		;;
IFN PSWCHG,<		;;[557]
LBLOCK	WTHED,2		;;[557] I/O CMD LIST FOR WRITING ACCT.SYS
LWORD	SAVBLK,		;;[610] BLOCK CONTAINING OUR PSWD
LWORD	SAVPOS,		;;[610] PTR TO WORD WITHIN BLK CONTAINING PSWD
>			;;[557] END IFN PSWCHG
LWORD	FL2741,		;;-1 IF THIS IS A 2741
LBLOCK	PDL,PDLSIZ+1	;;PUSH DOWN LIST
LWORD	MFDPPN,		;;PPN FOR MFD
LWORD	ALPPPN,		;;ALL PRIVS
LWORD	UFDPRT,		;;[557] STANDARD UFD PROTECTION
LBLOCK	ENTRY,MAXENT	;;DATA FROM ACCT.SYS
LWORD	LOGTRY,		;;TRIES AT LOGGING IN
LWORD	TTBITS,		;;TELETYPE DESCRIPTOR
LWORD	STATES,		;;SYSTEM STATES
LWORD	STATS2,		;;[374] SECOND STATES WORD
LWORD	XPDDTM,		;;[754] Universal date/time expiration date
IFE FASTLG,<
LWORD	NEWACT,		;;-1 IF NEW ACCT.SYS, 0 IF OLD
LWORD	ENTSIZ,		;;SIZE OF AN ACCT.SYS ENTRY
> ;END FASTLG

LWORD	NOWBIT,		;;TIME OF DAY AS A BIT
LWORD	ACCTLN,		;;LENGTH OF ACCT.SYS IN BLOCKS
LWORD	ACCKNT,		;;NUMBER OF BLOCKS READ ON ACCT.SYS
LWORD	SAVEDA,		;;SAVED DATE
LWORD	SYSPPN,		;;[1,4]
LWORD	MYTTY,		;;NAME OF MY TTY
LWORD	TTYUDX,		;;UDX OF MY TTY
LWORD	RECFLG,		;;
LWORD	UFDDAT,		;;DATE OF MOST RECENT UFD
LWORD	UFDTIM,		;;AND ITS TIME
LWORD	UFDNDL,		;;0 IF UFD CAN BE RENAMED, -1 IF IT CAN NOT
LWORD	THSJOB,		;;THIS JOB NUMBER
LWORD	DEVPTR,		;;[470] POINTER TO DEVTAB
LWORD	WLDPNT,		;;TEMP FOR WILD LOOKUPS
LBLOCK	IPS.BL,4	;;IPCF SEND BLOCK
LBLOCK	IPR.BL,6	;;IPCF RECEIVE BLOCK
LBLOCK	PAGBLK,2	;;ARGUMENT BLOCK OF A PAGE. UUO
LWORD	ACTPID,		;;ACCOUNT DAEMON PID
LWORD	ACTMES,		;;TYPE OF ACCOUNTING MESSAGE TO BE SENT
LWORD	MONLNO,		;;LINE NUMBER FOR USAGE ACCOUNTING
LWORD	MONNOD,		;;NODE NAME FOR USAGE ACCOUNTING
LWORD	MONTDE,		;;TERMINAL DESIGNATOR FOR USAGE ACCOUNTING
LWORD	ACTACK		;;UNIQUE MESSAGE IDENTIFIER
LBLOCK	QTATAB,STRMAX	;;TABLE OF STRS TO RECOMPUTE
LWORD	LSTSTR,		;;LAST STR FOR /QUOTA
LWORD	STRMSK,		;;STR MASK FOR /QUOTA
;;***START OF BLOCK SET TO 0 ON CALLS TO SCAN

LBLOCK	Z.STRT,0	;;START OF BLT

LBLOCK	NOTSPC,.FXLEN	;;/NOTE SPEC
LBLOCK	LIBSPC,.FXLEN	;;/LIB SPEC
LBLOCK	TYPSPC,.FXLEN	;;TEMP FOR TYPE
LBLOCK	U.PATH,.FXLEN	;;AREA FOR USER'S PATH SPEC
LBLOCK	PTHSPC,.FXLEN	;;[457] /PATH SWITCH AREA
LBLOCK	DEVTAB,DVICES*2	;;[470] TABLE OF DEV PHYS AND LOG NAMES
LWORD	U.SPL,		;;SPOOL REQUEST
LWORD	U.WAT,		;;WATCH REQUEST
LWORD	U.DPRI,		;;DISK PRIORITY

LBLOCK	Z.END,0		;;END OF BLT
;;***START OF BLOCK SET TO -1 ON CALLS TO SCAN

LBLOCK	OOBEG,0		;;START OF BLT FOR SCAN

LWORD	U.ATT		;;ASK OR IGNORE ATTACH MESSAGE IF DETACHED JOB WHEN LOGGING IN
LWORD	U.BINT		;;Batch operator intervention
LWORD	U.BNAM		;;BATCH JOB NAME
LWORD	U.BSEQ		;;BATCH SEQUENCE NUMBER
LWORD	U.BSTR		;;Batch stream number
LWORD	U.BREQ		;;BATCH REQUEST ID
LBLOCK	U.ACTS,10	;;ACCOUNT STRING
LBLOCK	U.RMRK,10	;;REMARK
LWORD	U.TIME,		;;TIME LIMIT REQUEST
LWORD	U.CORE,		;;CORE LIMIT
LBLOCK	U.NAME,2,	;;/NAME
LWORD	U.NEW,		;;NEW BIT
LWORD	U.NOTC,		;;[450] /NOTICE
LWORD	U.NWAT,		;;[336] /NOWATCH
LWORD	U.DFER,		;;[365] DEFERRED SPOOLING BIT
LWORD	U.SYS,		;;SYS BIT
LWORD	U.DFUL,		;;DISK FULL CONDTION
LWORD	U.LIMI,		;;1 IF /NOGUIDELINE, 0 IF /GUIDELINE
LWORD	U.GUID,		;;1 IF /GUIDELINE, 0 IF /NOGUIDELINE
LWORD	U.CPPL,		;;CURRENT PHYSICAL PAGE LIMIT
LWORD	U.CVPL,		;;CURRENT VIRTUAL PAGE LIMIT
LWORD	U.SFDCRE,	;;[757] IF SFD CREATION IS DESIRED
LWORD	U.SFDP,		;;[550] PROTECTION FOR CREATED SFD'S
LWORD	U.UFDP,		;;[554] PROTECTION FOR CREATED UFD'S
LWORD	U.DFPR,		;;[620] DEFAULT FILE PROTECTION
LWORD	U.DFBU,		;;[750] DEFAULT BUFFERS COUNT
LWORD	U.DFBB,		;;DEFAULT BIGBUF
IFN FTMAIL,<
LWORD	U.MAIL,		;;MAILCHECK SWITCH
>;END IFN FTMAIL
LWORD	U.MODE,		;;ATTACH MODE (MONITOR=0, USER=1)
IFN PSWCHG,<		;;[557] IF ALLOWING PASSWORD CHANGING
LWORD	U.NPSW,		;;[557] NEW PASSWORD
> ;;[557] END IFN PSWCHG
LWORD	U.SCAN,		;;SCAN SWITCH FOR PATH UUO
LWORD	U.STR,		;;STRUCTURE SWITCH
LWORD	U.QTA,		;;FOR RECOMPUTING DISK USAGE ON STRS IN JSL
LWORD	U.STA,		;;STATION NUMBER

IFN	SETTTY,<
LWORD	U.ALTM,		;;[344] ALTMODE CONVERSION
LWORD	U.BLNK,		;;[344] DO NOT TYPE BLANK LINES
LWORD	U.CRLF,		;;[344] FREE CRLF AT RIGHT MARGIN
LWORD	U.DBRK,		;;[344] DEBREAK (2741 TERM.)
LWORD	U.DISP,		;;[743] DISPLAY MODE
LWORD	U.ECHO,		;;[344] GUESS
LWORD	U.FILL,		;;[344] FILLER CLASS
LWORD	U.FFHO,		;;HOME ON FF
LWORD	U.FFSI,		;;SIMULATE FF WITH LF'S
LWORD	U.FFST,		;;STOP ON FF'S
LWORD	U.FORM,		;;[344] TTY HAS FORM FEEDS
LWORD	U.GAG,		;;[344] ALLOW SENDS ONLY AT MON. MODE OR RIGHT MARGIN
LWORD	U.LC,		;;[344] TTY HAS LOWER CASE
LWORD	U.LENG,		;;TTY PAGE LENGTH
LWORD	U.PAGE,		;;[344] ^S-^Q MODE
LWORD	U.PGSZ,		;;[344] PAGE SIZE
LWORD	U.RSPD,		;;[344] RECEIVE SPEED
LWORD	U.RTC,		;;[423] /RTCOMPATABILITY
LWORD	U.SBEL,		;;TTY SBELL
LWORD	U.SETT,		;;[344] /SETTTY /NOSETTY
LWORD	U.SPED,		;;[344] XMIT/RCV SPEED
LWORD	U.STOP,		;;TTY STOP n
LWORD	U.SSTO,		;;TTY SSTOP n
LWORD	T.STOP,		;;TTY STOP BIT (NOT SET BY SCAN)
LWORD	T.SSTOP,	;;TTY SSTOP BIT (NOT SET BY SCAN)
LWORD	U.TABS,		;;[344] TTY HAS HARDWARE TABS
LWORD	U.TAPE,		;;[344] XON STARTS PTR
LWORD	U.TIDY,		;;[747] TTY IS TIDY
LWORD	U.TTDE,		;;DEFER TTY OUTPUT
LWORD	U.TYPE,		;;[675] /TYPE
LWORD	U.UC,		;;[747] TTY HAS UPPER CASE
LWORD	U.WDTH,		;;[344] CARRIAGE WIDTH
LWORD	U.XONXO		;;TTY XONXOFF
LWORD	U.XSPD,		;;[344] XMIT SPEED
> ;;[344] END IFN SETTTY

LBLOCK	OOMAX,0		;;END OF BLT FOR SCAN
;;***END OF BLOCK SET TO -1 ON CALLS TO SCAN
LWORD	RPERCT,		;;FLAG FOR FILES FOUND WITH ERRORS
LWORD	SAVKNT,		;;TEMP FOR BUILDING AUX DIR
LWORD	CODE,		;;PASSWORD
LWORD	TDATE,		;;[477] TODAY'S DATE
LWORD	SAVOPR,		;;PLACE TO SAVE NAME OF OPR'S TTY
LWORD	SAOFST,		;;STARTING ADDRESS OFFSET FOR SCAN
LWORD	SVPROT,		;;USED TO SAVE UWP
LWORD	CNTLJT,		;;CONTROLLING JOB'S LINE CHARACTERISTICS
LWORD	CNTLJP,		;;CONTROLLING JOB'S PPN
LWORD	ATTJOB,			;;JOB NUMBER TO ATTACH
LWORD	INISCN,			;;[744] -1 IF IN .OSCAN
LBLOCK	WTOBLK,.QUARV+3		;;WTO MESSAGE BLOCK
LBLOCK	ERRACS,20		;;SAVED AC'S DURING ERROR PROCESSOR
;;***ARGUMENT BLOCK FOR LOGIN UUO****
LWORD	PPN,		;;USERS PPN
LWORD	PRIVWD,		;;PRIV WORD
LWORD	NAME,		;;FIRST HALF OF USER NAME
LWORD	NAME2,		;;SECOND HALF OF USER NAME
LWORD	CHGNO,		;;CHARGE NUMBER
;;***END OF LOGIN WORD
IFN FTCMPR, <		;;[667] ARGS FOR ZERO COMPRESSION
LBLOCK	CMPBLK,4	;;[667] UFD COMPRESSION FILE SPEC
LWORD	CMPDSK,		;;[667] DISK. UUO ARGUMENT BLOCK
>			;;[667] END UFD COMPRESSION ARGUMENTS
LBLOCK	ZZMAX,0		;;END OF BLT TO ZERO
>

DEFINE	LWORD(A),<	EXTERNAL A>
DEFINE	LBLOCK(A,B),<	EXTERNAL A>

> ;END IF1


	PRGEND
	TITLE	LOGIN - Initialization for LOGIN
	SUBTTL	LOGIN - Initialization for LOGIN

	SEARCH	UUOSYM,MACTEN,SCNMAC,LGNUNV,ACTSYM,UFDPRM

	LGNDCL

COPYRIGHT (C) DIGITAL EQUIPMENT CORPORATION 1969,1984.


;START HERE

LOGIN::	TDZA	17,17		;CLEAR AC17 ON A NORMAL START
	MOVEI	17,1		;SETUP A 1 ON A CCL START
	SETZB	0,ZZBEG		;PREPARE TO CLEAR CORE
	MOVEI	16,1		;CLEAR THE AC'S
	BLT	16,16		; ..
	MOVE	T1,[ZZBEG,,ZZBEG+1] ;CLEAR OUT THE LOWSEG
	BLT	T1,ZZMAX-1	; ..
	MOVEM	17,SAOFST	;SAVE STARTING OFFSET
	MOVE	T1,[4,,RICC##]	;LOAD UP JOBINT BLOCK
	MOVEM	T1,INTBLK	; ..
	MOVX	T1,ER.ICC	;ASK FOR CONTROL-C
	MOVEM	T1,INTBLK+1	; INTERCEPT
	MOVEI	T1,INTBLK	;CONTROL-C INTERCEPT BLOCK
	MOVEM	T1,.JBINT##	;STORE FOR THE MONITOR
	RESET

	MOVE	P,PDPLST	;Set up the stack
	PJOB	T1,		;Get our job number
	MOVEM	T1,THSJOB	;Store for later
	PUSHJ	P,ISBATC	;Is this a Batch job ?
	SKIPA			;No
	TLO	F,FL.BAT!L.SOPR	;This guy is a real son of a batch
	MOVX	T1,.IOASC	;Assume a Batch job
	TLNN	F,FL.BAT	;Is it ?
	PUSHJ	P,TTYINI##	;INITIAL TTY
	PUSHJ	P,TTYNEC##	;SET TTY NO ECHO
	INIT	UFD,.IODMP	;GET A DISK IN DUMP MODE
	SIXBIT	/SYS/		;LOOKUP ACCOUNTING FILES IN SYS
	XWD	0,0		;NO HEADERS
	  LOGOUT		;THIS IS ALSO UNFIXABLE
	SETOM	RECFLG		;SET FLAG FOR RECOMP MESSAGE
	MOVNI	T3,1		;GET THE TTY CHARACTERISTICS
	GETLCH	T3
	CAMN	T3,[-1]		;IF A NOOP, ASSUME HDX
	MOVX	T3,GL.HDP
	MOVEM	T3,TTBITS
	MOVEM	T3,CNTLJT
	TXNN	T3,GL.ITY!GL.HDP!GL.LCP!GL.PTM	;SKIP IF HALF DUPLEX
	TLO	F,FL.FDX	;SET FULL DUPLEX FLAG
	MOVX	T1,.TOFSP	;Full SCNSER PTY function
	SETO	T2,		;My UDX
	MOVE	T3,[2,,T1]	;Point to args
	TRMOP.	T3,		;Read it
	 MOVEI	T3,0		;Cant
	CAIE	T3,0		;Is it set?
	 TLO	F,FL.FDX	;Yes--Set full duplex for full SCNSER PTYs
	MOVX	T1,%CNSTS	;MAGIC CODES FOR LOC STATES IN SYS
	GETTAB	T1,		;GET TABLE ENTRY
	  SETZ	T1,		;ZERO IF ERROR RETURN
	MOVEM	T1,STATES	;SAVE FOR LATER
	MOVX	T1,%CNST2	;[374] GET SECOND STATES WORD
	GETTAB	T1,		;[374] ..
	  SETZ	T1,		;[374] ..
	MOVEM	T1,STATS2	;[374] SAVE FOR A RAINY DAY
	MOVX	T1,%CNOPR	;GET OPR DEVICE NAME
	GETTAB	T1,		; FROM MONITOR
	  MOVSI T1,(SIXBIT /CTY/)	;ASSUME CTY IF IT WONT TELL US
	MOVEM	T1,SAVOPR	;STORE FOR LATER USE
	GETLIN	T1,		;GET MY TTY NAME
	MOVEM	T1,MYTTY	;SAVE IT
	TXNN	T3,GL.CTY	;IS MY TTY THE CTY?
	CAMN	T1,SAVOPR	;OR THE OPR?
	TLO	F,L.OPR		;YES. REMEMBER THAT IN FLAG AC
	MOVE	T3,THSJOB	;[351] GET OUR JOB NUMBER
	TRMNO.	T3,		;[345] GET TTY UDX
	  SETZ	T3,		;[345] SO WHAT?
	MOVEM	T3,TTYUDX	;[345] SALT AWAY FOR TRMOP. STUFF
	JUMPE	T3,NT2741	;[546] NOT A 2741
	MOVE	T1,[2,,T2]	;[546] ARG POINTER FOR TRMOP.
	MOVX	T2,.TO2741	;[546] READ THE 2741 BIT
	TRMOP.	T1,		;[546] ..
	  SETZ	T1,		;[546] ASSUME NOT 2741
	SKIPE	T1		;[546] IS THIS A 2741?
	SETOM	FL2741		;[546] YES - SET THE FLAG
NT2741:	SETOM	OOBEG		;SET SCAN SWITCH BLOCK TO -1
	MOVE	T1,[XWD OOBEG,OOBEG+1]
	BLT	T1,OOMAX-1
	MOVEI	T1,^D5		;LET THE GUY TRY 5 TIMES
	MOVEM	T1,LOGTRY
	MOVX	T1,%LDFFA	;PPN THAT HAS THE PRIVS
	GETTAB	T1,		;GET IT FROM MONITOR
	  MOVE	T1,[1,,2]	;DEFAULT
	MOVEM	T1,ALPPPN	;SAVE IT FOR LATER
	MOVX	T1,%LDMFD	;GET THE MFD PPN
	GETTAB	T1,		; FROM THE MONITOR
	  MOVE	T1,[1,,1]	;DEFAULT
	MOVEM	T1,MFDPPN	;STORE FOR LATER USE
	MOVSI	T1,(SIXBIT .SYS.)
	DEVPPN	T1,		;GET PPN FOR SYS
	  MOVE	T1,[1,,4]	;[361] DEFAULT
	MOVEM	T1,SYSPPN
	MOVX	T1,%LDUFP	;[557] GET STANDARD UFD PROTECTION
	GETTAB	T1,		;[557] ..
	  MOVSI	T1,775000	;[557] EH?
	ROT	T1,^D9		;[557] RIGHT-JUSTIFY IT
	MOVEM	T1,UFDPRT
	DATE	T1,
	MOVEM	T1,TDATE	;[557] SAVE FOR LATER

	PJRST	LGNSCN##	;GO OFF TO COMMAND SCANNER

	PRGEND	LOGIN
	TITLE	LGNSCN - Command scanner for LOGIN

	SEARCH	UUOSYM,MACTEN,SCNMAC,LGNUNV,ACTSYM,UFDPRM
	LGNDCL

LGNSCN::MOVEI	T1,[ASCIZ /LOGIN/]
	MOVEM	T1,HELP
	MOVE	T1,[XWD 6,SCIBLK]
	PUSHJ	P,.ISCAN##	;CALL SCAN TO GET COMMAND
	MOVE	P1,T1		;SAVE COMMAND VALUE
	SKIPN	SAOFST		;CCL RUN?
	CAIN	P1,2		;IS IT A SESSION COMMAND?
	TRO	F,R.SESS	;YES--FLAG SESSION
	SKIPE	.JBDDT##	;IS DDT LOADED?
	JRST	LGIN2B		;YES--LET IT GO
	MOVN	T1,THSJOB	;MAKE NEGATIVE
	JOBSTS	T1,		;READ JOB STATUS
	  JRST	LOGIN2		;ASSUME OK IF NO JOB STATUS
	TXNE	T1,JB.UJC	;IF JACCT IS CLEAR THERE IS NO HARM TRYING
	TXNN	T1,JB.ULI	;IF JACCT IS SET JLOG MUST BE CLEAR
	JRST	LOGIN2		;OK--EITHER NO PRIVS OR LOGGED OUT
	TRNE	F,R.SESS	;IS IT A SESSION COMMAND?
	JRST	LOGIN2		;YES LET IT GO
	FATAL	KOD,<Please KJOB or DETACH>,EF.SIL
LOGIN2:	TXNE	T1,JB.UJC	;[541] JACCT?
	  JRST	LGIN2A		;[541] YES
	WARN	IDJ,<I do not have JACCT>
LGIN2B:	TRO	F,R.DBUG	;[626] SET DEBUG FLAG; WE'RE BEING DEBUGGED
LGIN2A:	TRNE	F,R.SESS	;SESSION COMMAND?
	JRST	NOJBMS		;YES
	JUMPLE	P1,LOGDIS	;IF R, RUN, OR  LOGIN COMMAND
;HERE IF ATTACH

	MOVE	T1,[XWD ATTBLN,ATTBLK]	;POINT TO ATTACH SWITCHES
	PUSHJ	P,.PSCAN##	;GO SET UP FOR PARTIAL SCAN
	  PJRST	FLUSH		;SHOULD NEVER HAPPEN
	PUSHJ	P,CHKSWT	;CHECK FOR SWITCHES NOW
				;(CURRENTLY MONITOR WILL NOT ALLOW ANY, BUT..)
	MOVEI	T1,[ASCIZ /a job number/]
	MOVEM	T1,HELP
	PUSHJ	P,.DECNW##	;READ JOB NUMBER TO BE ATTACHED TO
	MOVEM	N,ATTJOB	;SAVE JOB NUMBER
	TLO	F,FL.ATT	;NOTE ATTACH
	SETOM	NOWBIT		;CAN ALWAYS ATTACH
ATTD1:	JUMPLE	C,FLUSH		;MUST BE POSITIVE NUMBER
	CAIE	C,"<"		;[655] CHECK FOR PPN FROM 2741
	CAIN	C,"["		;SKIP IF NOT YET TO PPN
	JRST	ATTD2		;READ PPN
	PUSHJ	P,TYI		;READ NEXT CHAR
	JRST	ATTD1		;AND LOOP TILL [
ATTD2:	PUSHJ	P,.OCTNW##	;READ PROJECT NUMBER
	TLNN	N,-1		;ONLY 6 DIGITS
	CAIE	C,","		;MUST END WITH COMMA
	 FATAL	BPN,<Invalid format for project-programmer number>,EF.FMT
	JUMPE	N,LGNBPN		;MUST BE SOMETHING THERE
	HRLZ	PP,N		;SAVE PROJECT NUMBER
	PUSHJ	P,.OCTNW##	;READ PROGRAMMER NUMBER
	JUMPE	N,LGNBPN		;MUST BE SOMETHING THERE
	TLNE	N,-1		;BUT NOT TOO MUCH
	JRST	LGNBPN
	CAIE	C,">"		;USER TERMINATE?
	 CAIN	C,"]"		;..
	  PUSHJ	P,TYI		;YES--GET NEXT CHAR
	HRR	PP,N		;SAVE PROGRAMMER NUMBER
	MOVEM	PP,PPN		;STORE PPN
	MOVEI	N,.GTPPN	;CHECK TO SEE THAT THIS
	HRL	N,ATTJOB	; JOB HAS THE PPN HE
	GETTAB	N,		; CLAIMED IT DOES. THE MONITOR
	  SETZ	N,		; MAKES THIS CHECK BUT LOGIN
	CAME	N,PPN		; COULD HAVE A BUG WHICH WOULD
	JRST	NOATT		; ZAP A USER.
	PUSHJ	P,CHKSWT	;CHECK FOR SWITCHES HERE
	JRST	NOJBMS		;OK, PROCEED WITH ATTACH

;PROCESS SWITCHES (IF ANY) FOR ATTACH

CHKSWT:	CAIN	C," "		;A SPACE?
	 PUSHJ	P,TYI		;YES--GET A REAL CHAR
	CAIE	C,"/"		;SWITCH COMING?
	 POPJ	P,		;NO--RETURN
	PUSHJ	P,.KEYWD##	;YES--ASK SCAN TO PROCESS
	 JRST	LGNNSS		;ERROR IF NO SWITCH
	JRST	CHKSWT		;AND LOOP

	FATAL	NSS,<No switch specified>
	SUBTTL	Type first message, check states bits

;HERE TO TYPE JOB NUMBER, MONITOR NAME, AND TTY NUMBER

LOGDIS:	MOVEI	T1,[ASCIZ/JOB /]
	PUSHJ	P,.TSTRG##
	MOVE	T1,THSJOB	;GET JOB NUMBER
	PUSHJ	P,.TDECW##
	PUSHJ	P,.TSPAC##
	MOVNI	T3,5
CONFLP:	MOVEI	T1,.GTCNF
	HRLI	T1,5(T3)
	GETTAB	T1,		;GET NEXT WORD OF MONITOR NAME
	  JRST	ONTTY
	MOVEM	T1,UFDBUF
	SETZM	UFDBUF+1
	MOVEI	T1,UFDBUF
	PUSHJ	P,.TSTRG##	;**TEMP** UFDBUF
	AOJL	T3,CONFLP
	PUSHJ	P,.TSPAC##
ONTTY:	MOVE	T1,MYTTY	;GET TTY NAME
	PUSHJ	P,.TSIXN##	;PRINT IT
	PUSHJ	P,.TCRLF##

NOJBMS:	MOVE	T3,TTBITS
	MOVE	T2,STATES	;GET STATES WORD
	TXNN	T3,GL.ITY	;[605] PTY?
	  JRST	TTYGO		;[605] NO: NO SPECIAL CHECKS THEN

	TRO	F,R.PTYJ	;MARK AS A PTY JOB
	TLNE	F,FL.BAT	;Is this a Batch job ?
	JRST	TTYGO		;[605] TRUST BATCON AND SKIP CHECKS

;[605] HERE IF NON-BATCH PTY JOB TO CHECK SUPERIOR JOBS

NOTBAT:	PUSHJ	P,FNDCTL	;FIND CONTROLLING JOB NUMBER
	 JRST	TTYDET		;CAN'T
	  JRST	BJSJ		;BATCH JOB SUBJOB
	MOVEM	T2,CNTLJP	;SAVE CONTROLLER'S PPN
	HRLZ	T1,T3		;T1=SIXBIT LINE NUMBER
	CAME	T3,[SIXBIT/CTY/]	;[660] SKIP IF ATTACHED CTY
	CAMN	T3,SAVOPR	;IS IT THE OPR?
	TLO	F,L.SOPR	;FLAG SUBJOB OF OPR.
	SETZ	T3,
	MOVE	T4,[POINT 6,T1]
	JUMPN	T1,ISPTY1	;JUMP IF NOT CTY
	MOVX	T3,%CNPTY
	GETTAB	T3,
	  SETO	T3,
	HLRES	T3		;T3=OFFSET FOR FIRST PTY
	SUBI	T3,1		;-1=LINE NUMBER OF CTY
	JUMPGE	T3,ISPTY2	;JUMP IF HAVE CTY LINE NUMBER
	MOVX	T3,GL.CTY	;NO, FAKE TTBITS
	JRST	ISPTY3		;WE KNOW ITS THE CTY

ISPTY1:	ILDB	WD,T4
	JUMPE	WD,ISPTY2	;JUMP IF NO MORE CHARS
	LSH	T3,3
	ADDI	T3,-20(WD)
	JRST	ISPTY1

TTYDET:	SKIPA	T3,[GL.REM+GL.DSL]	;MAKE HIM NON-LOCAL

ISPTY2:	GETLCH	T3		;GET LINE BITS FOR CONTROL JOB TTY
ISPTY3:	MOVEM	T3,CNTLJT	;SAVE LINE BITS FOR CONTROL JOB TTY
	JRST	TTYGO		;GO DO THE ACCOUNTING

BJSJ:	TLO	F,FL.BSJ	;REMEMBER WE'RE A BATCH JOB SUBJOB
	MOVEM	T2,CNTLJP	;CONTROLLING PPN=PPN OF BATCH JOB
	MOVX	T3,GL.REM	;PRETEND REMOTE
	MOVEM	T3,CNTLJT	;SAVE FAKE TTY BITS
	JRST	TTYGO		;GO DO CHECKING
;ROUTINE TO FIND JOB'S ULTIMATE CONTROLLER FOR PURPOSES OF ACCESS CHECKING
;STOP SCANNING IF REACH: [1,2] JOB, TOP LEVEL JOB, DETACHED JOB, OR BATCH JOB
;CALL:	PUSHJ	P,FNDCTL
;	 CPOPJ IF CAN'T FIND JOB (ASSUME WE'RE DETACHED)
;	  CPOPJ1 IF BATCH JOB SUBJOB (ASSUME REMOTE)
;	    CPOPJ2 WITH AC'S SET UP AS FOLLOWS:
;		T1=CONTROLLING JOB NUMBER
;		T2=CONTROLLING JOB'S PPN
;		T3=CONTROLLING JOB'S PHYSICAL TTY NAME
FNDCTL:	SETO	T1,		;FIRST, GET IMMEDIATE CONTROLLING JOB
	CTLJOB	T1,		;..
	  JRST	CPOPJ		;ASSUME WE'VE BECOME DETACHED
	JUMPL	T1,CPOPJ	;DITTO

FNDCT1:	HRLZ	T3,T1		;GET THIS JOB'S TTY DDB ADDRESS
	HRRI	T3,.GTTTY	;..
	GETTAB	T3,		;..
	  JRST	CPOPJ
	PEEK	T3,		;GET PHYSICAL TTY NAME
				;[660] REMOVED 3 INSTRUCTIONS
	PUSH	P,T1		;SAVE T1
	MOVE	T1,T2		;SAVE LAST PPN IN CASE SON-OF-OPR
	HRLZ	T2,(P)		;GET THIS JOB'S PPN (JOB # ON STACK)
	HRRI	T2,.GTPPN	;..
	GETTAB	T2,
	  SETZ	T2,
	CAMN	T2,ALPPPN	;HAVE WE HIT A [1,2] JOB YET?
	  JRST	SONOPR		;YES: WE'RE SON-OF-OPR
	HRRZ	T1,(P)		;GET JOB NO. BACK AGAIN
	PUSHJ	P,ISBATC	;IS THIS JOB A BATCH JOB?
	  JRST	NOTBSJ
	POP	P,T1		;FIX UP STACK
	JRST	CPOPJ1		;WE'RE A BATCH JOB SUBJOB

NOTBSJ:	MOVE	T1,(P)		;RESTORE T1 FOR A BIT
	CTLJOB	T1,		;ANOTHER LEVEL?
	  JRST	TPOPJ		;[670] RESTORE T1 AND RETURN
	AOJE	T1,TOPLVL	;IF T1=-1 WE'VE HIT TOP LEVEL
	TLO	F,L.MANY	;FLAG MORE THAN ONE SUPERIOR
	POP	P,T3		;[704] ADJUST STACK
	SOJA	T1,FNDCT1	;[704] GO THRU NEXT LEVEL


SONOPR:	TLO	F,L.SOPR	;REMEMBER WE'RE SPAWN OF OPR
	MOVE	T2,T1		;USE LAST NON-[1,2] PPN AS CONTROLLER
	TLNN	F,L.MANY	;UNLESS [1,2] IS IMMEDIATE CONTROLLER
	  MOVE	T2,ALPPPN	;IN WHICH CASE USE [1,2]
TOPLVL:	POP	P,T1		;JOB # WE WANT IS ON STACK
CPOPJ2:	AOS	(P)
CPOPJ1:	AOSA	(P)		;[670]
TPOPJ:	POP	P,T1		;[670] RESTORE T1
CPOPJ:	POPJ	P,
;SUBROUTINE TO PARSE THE LOGIN COMMAND LINE
;CALL WITH:
;	PUSHJ	P,PARSE
;	RETURN HERE IF OK
;
PARSE::	TLZ	F,FL.WLD	;[355]
	TRZ	F,R.EOL		;[604] CLEAR FLAGS WHICH NEED IT
	SETZM	Z.STRT		;INIT SOME SWITCHES TO 0
	MOVE	T1,[XWD Z.STRT,Z.STRT+1];SETUP BLT
	BLT	T1,Z.END-1	;CLEAR THEM OUT
	SETOM	OOBEG		;[355] CLEAR OUT SWITCH BLOCK
	MOVE	T1,[XWD OOBEG,OOBEG+1]	;[355]
	BLT	T1,OOMAX-1	;[355]
	MOVE	T1,[IOWD DVICES*2+1,DEVTAB] ;[470] INIT PTR TO DEV TABLE
	MOVEM	T1,DEVPTR	;[470] ..
	TRNE	F,R.SESSION	;[745] SESSION COMMAND?
	 JRST	PARSES		;[745] YES--GO PARSE IT
	MOVE	T1,[LOGBLN,,LOGBLK]	;SETUP UP TO DO A PARTIAL
	PUSHJ	P,.PSCAN##	; SCAN.
	 PUSHJ	P,GIVNBR##	;GIVE NUMBER SIGN PROMPT IF NEEDED
	SETZB	PP,RDHED	;[451] THIS IS A GOOD IDEA
LOOP:	PUSHJ	P,.TIAUC##	;[330] GET NEXT CHAR
	JUMPLE	C,PARSE		;[506] ALLOW BLANK LINES
	CAIN	C," "		;[330] EAT SPACES
	JRST	LOOP		;[330]
	CAIL	C,"0"		;[330] NOT SPACE OR BRACKET - IS IT
	CAILE	C,"7"		;[330] AN OCTAL DIGIT?
	  JRST	PTHSWT		;[446] NO - GO GET PPN, PATH, & SWITCHES
	PUSHJ	P,.OCTNC##	;[745][447] GET PROJ NO (HAVE 1ST DIGIT)
	JUMPL	C,[JUMPE N,PARSE ;IGNORE BLANK LINES
		   JRST  LGNBPN]	;INVALID ENTRY
	CAIE	C,"/"		;SLASH BREAK?
	CAIN	C,","		;ORDINARY COMMA BREAK?
	SKIPN	N		;NON-ZERO NUMBER
	JRST	LGNBPN		;NO GOOD
	TLNE	N,-1		;ALSO ONLY 6 DIGITS
	JRST	LGNBPN
	HRLZ	PP,N		;PUT IN AC PP
	PUSHJ	P,.TIAUC##	;LOOK AT NEXT CHAR
	CAIE	C,UNISYM	;WANT UNIQUE PPN?
	JRST	GPRGMN		;NO, COLLECT PROGRAMMER NO
	PUSHJ	P,.TIAUC##	;GET SEPARATOR INTO CH
	MOVEI	N,UNIPRG	;PUT UNIQUE CODE INTO N
	TLOA	F,FL.WLD	;NOTE UNIQUE PROGRAMMER NO
GPRGMN:	PUSHJ	P,.OCTNC##	;COLLECT PROGRAMMER, 1ST CHAR IN CH
	JUMPE	N,LGNBPN		;THIS SHOULD CATCH FORMAT ERRORS
	TLNE	N,-1		;..
	JRST	LGNBPN		;NO GOOD.
	HRR	PP,N		;MAKE AN XWD
	JUMPLE	C,NOSWIT	;[442] NO PATH OR SWITCES IF EOL FOUND
;HERE HANDLE PATH DEFINITION AND LOGIN SWITCHES

PTHSWT:	PUSHJ	P,.REEAT##	;[325] BACK UP ONE CHARACTER
	PUSHJ	P,.FILIN##	;[434] GO SCAN OFF THE PATH
	MOVEI	T1,U.PATH	;NOW GO COPY THE SPEC
	MOVEI	T2,.FXLEN	;  INTO LOGIN'S CORE
	PUSHJ	P,.GTSPC##	;  AREA
NOSWIT:	SKIPN	PP		;[447] NON-PATH PPN TYPED?
	  MOVE	PP,U.PATH+.FXDIR;[447] NO - GET PATH PPN
	TLNE	PP,-1		;[447] MAKE SURE BOTH HALVES
	 TRNN	PP,-1		;[447] ARE NON-ZERO
	  JRST	LGNBPN		;[447] NOPE - COMPLAIN
	MOVEM	PP,PPN		;[447] YES - SALT PPN AWAY FOR LOGIN UUO
	PUSHJ	P,TTYNEC##	;SET TTY NO ECHO

	MOVEI	T1,U.PATH	;[457] GET ADDR OF PATH SPEC TO CHECK
	PUSHJ	P,CHKPTH	;[457] MAKE SURE IT'S A NICE PATH SPEC
	  FATAL IPS,<Invalid path specification>,EF.FMT
	MOVEI	T1,PTHSPC	;[457] GET ADDR OF PATH SWITCH SPEC
	MOVE	T4,PTHSPC+.FXDIR;[474] DON'T WANT CHKPTH TO DEFAULT THIS
	PUSHJ	P,CHKPTH	;[457] MAKE SURE IT'S OK
	  JRST	LGNIPS		;BAD BOY
	SKIPN	PTHSPC+.FXDIR+2	;[705] WAS SFD TYPED IN PATH?
	JRST	NOSWT1		;[705] NO, SO LEAVE PTHSPC ALONE
	TLNN	T4,-1		;[705] ELSE: - IS PROJECT ZERO?
	HLL	T4,PP		;[705] YES - DEFAULT TO USER'S
	TRNN	T4,-1		;[705] IS PROG NO. ZERO?
	HRR	T4,PP		;[705] YES - DEFAULT TO USER'S
NOSWT1:	MOVEM	T4,PTHSPC+.FXDIR;[474][705] GET DESIRED PPN BACK
	SKIPN	U.PATH+.FXDIR+2	;[457] WERE SFD'S TYPED WITHOUT /PATH?
	POPJ	P,		;[457] NO - ALL IS OK
	SKIPN	PTHSPC+.FXDIR+2	;[457] YES - WAS AN SFD TYPED IN /PATH?
	POPJ	P,		;[457] NO - STILL OK
	JRST	LGNIPS		;YES - THAT IS A CONFLICT - COMPLAIN
	SUBTTL	SESSION command scanning

PARSES:	GETPPN	PP,			;SETUP PPN
	 JFCL
	MOVEM	PP,PPN			;STASH AWAY
PARSS2:	MOVE	T1,[LOGBLN,,LOGBLK]	;SETUP UP TO DO A PARTIAL
	PUSHJ	P,.PSCAN##		;SCAN
	 POPJ	P,			;IF PROMPT NEEDED, RETURN
	PUSHJ	P,.TIAUC##		;PRIME THE PUMP
PARSS1:	CAIN	C," "			;A SPACE?
	 PUSHJ	P,.TIAUC##		;YES--GET A REAL CHAR
	CAIN	C,"@"			;SEE IF INDIRECT CMD FILE
	 JRST	[PUSHJ	P,.GTIND##	;YES--SETUP FOR IT
		 JUMPLE	C,PARSS2	;LOOP IF EOL
		 JRST	E.ILSC##]	;ELSE ERROR
	CAIE	C,"/"			;SWITCH COMING?
	 JRST	LGNISF			;NO--ERROR
	PUSHJ	P,.KEYWD##		;YES--GO PROCESS IT
	 JRST	LGNISF			;NO SWITCH--ERROR
	JUMPG	C,PARSS1		;LOOP IF MORE
	POPJ	P,			;ELSE RETURN

	FATAL	ISF,<Illegal SESSION command format>

;[457] ROUTINE TO CHECK LEGALITY OF PATH SPEC (NO WILDCARDS ALLOWED)
;[457] CALL:	MOVE	T1,ADDRESS-OF-PATH-SPEC
;[457]		PUSHJ	P,CHKPTH
;[457]		  BAD PATH
;[457]		OKAY
;[457] THIS ROUTINE ALSO PLUGS IN LOGGED-IN PPN IF NO PPN GIVEN

CHKPTH:	MOVSI	T2,'DSK'	;FORCE DEFAULT OF DSK
	SKIPN	.FXDEV(T1)	;DEFAULT SUPPLIED BY SCAN
	  MOVEM	T2,.FXDEV(T1)	;STORE CORRECTED DEVICE
	MOVE	T3,.FXDEV(T1)	;GET THE DEVICE NAME
	DEVCHR	T3,		;GET ITS DEVICE TYPE
	TXNE	T3,DV.DSK	;MUST BE A DISK
	 SKIPE	.FXNAM(T1)	;NOR FILE NAME
	  JRST	.POPJ##		;BOMB HIM ON THAT
	SKIPE	.FXEXT(T1)	;CAN'T EVEN GIVE EXT
	  JRST	.POPJ##
	MOVSI	T3,-.FXLND	;ENTRIES IN A FULL PATH SPEC
	ADD	T3,T1		;[457] BASE ADDR OF PATH SPEC
PTHCHK:	SKIPN	.FXDIR(T3)	;WAS A DIRECTORY GIVEN?
	  JRST	.PLUS5		;NO, WE'VE REACHED END OF LIST
	AOSE	.FXDIM(T3)	;YES, WERE WILD CARDS GIVEN?
	  JRST	.POPJ##		;YES, MUSTN'T DO THAT
	AOJ	T3,
	AOBJN	T3,PTHCHK	;LOOP TO CHECK ENTIRE PATH
.PLUS5:	HLLZ	T2,.FXDIR(T1);DID HE GIVE A PROJ?
	SKIPN	T2
	  HLLM	PP,.FXDIR(T1);NO--JAM IT IN
	HRRZ	T2,.FXDIR(T1);DID HE GIVE A PROG. NO.
	SKIPN	T2
	  HRRM	PP,.FXDIR(T1);NO--GO DO THE DEFAULT
	JRST	.POPJ1##	;[457] GIVE GOOD RETURN
;HERE TO GET NAME

GETNAM:	MOVEI	T1,[ASCIZ /your name/]
	MOVEM	T1,HELP
	MOVE	T1,U.NAME	;GET THE USER NAME
	MOVE	T2,U.NAME+1	;GET THE SECOND HALF
	CAME	T1,[-1]		;NAME GIVEN?
	JRST	GETNM1		;YES--DO NOT NEED TO ASK
	MOVE	T1,ENTRY+.ACNM1	;[462] PICK UP NAME FROM ACCT.SYS
	MOVE	T2,ENTRY+.ACNM2	;[462] ..
	JUMPN	T1,.+3		;[462] IS THERE ONE?
	 TLNE	F,FL.ATT	;[462] NO - ARE WE ATTACHING?
	  JRST	GETNM1		;[462] YES - DON'T ASK, THEN
	PUSHJ	P,TTYECH##	;SET TTY ECHO
	MOVEI	T1,[ASCIZ/Name: /]
	PUSHJ	P,TTYPMT##	;[443] PROMPT
	PUSHJ	P,GET2WD	;GET NAME
	PUSH	P,T1		;SAVE FROM DESTRUCTION
	PUSHJ	P,TTYNEC##	;SET TTY NO ECHO
	POP	P,T1		;RESTORE FIRST WORD OF NAME
GETNM1:	MOVEM	T1,NAME
	MOVEM	T2,NAME2
	MOVE	T3,ENTRY+.ACPRO	;GET PROFILE WORD
	TXNN	T3,AC.NRT	;IS NAME REQUIRED?
	SKIPE	ENTRY+.ACNM1	;SKIP IF ACCT.SYS = 0
	JRST	GETCOD		;GO COLLECT PASSWORD
	MOVEM	T1,ENTRY+.ACNM1	;NO--FORCE A VALID NAME BY
	MOVEM	T2,ENTRY+.ACNM2	; OVERWRITING NAME IN ACCT.SYS ENTRY
	TXNN	T3,AC.PRT 	;NEED PASSWORD
	JRST	PSWOK		;NO--CHARGE AHEAD
;HERE TO GET PASSWORD

GETCOD:	MOVEI	T1,[ASCIZ /a valid password/]	;HELP
	MOVEM	T1,HELP		; TEXT FOR TIMEOUT
	PUSHJ	P,CODGET
IFN	NCRYPT,<	;[755] NEED TO HASH THE PASSWORD?
	MOVE	P1,T1		;[755] GET SET FOR THE HASHING ROUTINE
	PUSH	P,T2		;[755] SAVE T2 SO ENCODE WON'T SMASH IT
	PUSHJ	P,ENCODE##	;[755] DO THE HASHING ONCE AND ONLY ONCE
	MOVE	T1,P1		;[755] PUT THE CODE INTO THE RIGHT AC
	POP	P,T2		;[755] GET T2 BACK
>	;[755] END OF IFN NCRYPT
	MOVEM	T1,CODE		;SAVE THE PASSWORD TO INCLUDE IN FACT FILE
	JUMPN	T2,TRYAGN	;CAN'T BE MORE THE 6 LETTERS
	MOVE	T1,ENTRY+.ACPRO	;[355] GET PROFILE WORD
	TXNN	T1,AC.NRT	;[355] NAME REQUIRED?
	JRST	NAMEOK		;[355] NO -- PROCEED
	SKIPN	T1,ENTRY+.ACNM1	;IF NAME NON-ZERO, THEN MUST MATCH FILE
	JRST	NAME1		;SEE IF NON-ZERO NAME SPECIFIED
	MOVE	T2,ENTRY+.ACNM2	;CHECK THE NAME.
	CAMN	T1,NAME		;..
	CAME	T2,NAME2	;SECOND HALF
	JRST	BADNAM
	JRST	NAMEOK		;ONWARD

NAME1:	MOVE	T1,NAME		;GET NAME
	IOR	T1,NAME2	; THE USER GAVE US
	JUMPE	T1,BADNAM	;IF NAME IS REQUIRED, IT MUST BE NON-ZERO

NAMEOK:	MOVE	P1,CODE		;[557] GET PASSWORD TYPED
	CAME	P1,ENTRY+.ACPSW	;[557] DOES PASSWORD MATCH?
	  JRST	TRYAGN		;NO. HE LOSES.
IFN	PSWCHG,<		;[557] IF ALLOWING PSWD CHANGES
	SKIPG	U.NPSW		;[557] USER WANT TO CHANGE HER PSWD?
	  JRST	PSWOK		;[557] NO - SKIP THIS STUFF
NOWAY:	MOVEI	T1,[ASCIZ /a new password/]
	MOVEM	T1,HELP		;[557] HELP TEXT FOR TIMEOUT
	MOVEI	T1,[ASCIZ/New password: /]
	PUSHJ	P,TTYPMT##	;PROMPT
	PUSHJ	P,GET2WD	;[557] GET THE ANSWER
	PUSHJ	P,.TCRLF##	;ECHO THE CRLF
	SKIPN	P1,T1		;[557] MAKE SURE NON-NULL
	  JRST	NOWAY		;[557] NULL PSWD IS A NO-NO
	JUMPN	T2,NOWAY	;[557] PASSWORD TOO LONG
	MOVEI	T1,[ASCIZ/Reenter to verify: /]
	PUSHJ	P,TTYPMT##	;PROMPT
	PUSHJ	P,GET2WD	;READ PASSWORD AGAIN
	PUSHJ	P,.TCRLF##	;ECHO THE CRLF
	CAMN	P1,T1		;SAME AS BEFORE?
	 CAIE	T2,0		;OR TOO LONG?
	  CAIA			;LOOKS BAD
	   JRST OKWAY		;LOOKS GOOD
	WARN	PDV,<Passwords didnt verify; Try again>
	JRST	NOWAY		;AND ASK AGAIN

OKWAY:
IFN	NCRYPT,<		;[557] ENCRYPTING PSWDS?
	PUSHJ	P,ENCODE##	;[557] YES - MUNGE IT
>				;[557] END IFN NCRYPT
	MOVEM	P1,ENTRY+.ACPSW	;[557] REPLACE OLD PSWD WITH NEW
	PUSHJ	P,WTUFD		;[557] WRITE THE BLOCK TO ACCT.SYS
	>			;[557] END IFN PSWCHG
	JRST	PSWOK		;CHARGE AHEAD
;SUBROUTINE TO SCAN OFF DISK PRIORITY
;
SWDSKP:	PUSHJ	P,.OCTNW##	;READ THE NUMBER
	CAML	N,[-3]		;TOO SMALL
	CAILE	N,3		;TOO BIG
	JRST	SDSKPE		;YES--ERROR
	MOVEM	N,U.DPRI	;STORE THE ANSWER
	PJRST	.SWDON##	;RETURN

SDSKPE:	M.FAIO	<Invalid argument to /DSKPRI:>


;[470] SUBROUTINE TO STORE ARGS TO /ASSIGN:PHYS:LOG
;
ASSIGN:	TRZ	F,R.NXSW!R.EOL	;[627] CLEAR NEXT-SWITCH-SEEN FLAG AND END-OF-LINE FLAG
	AOS	(P)		;[470] SKIP RETURN TO BYPASS .SWDPB
	PUSHJ	P,.+1		;[470] DO THIS TWICE - ONCE FOR PHYS
				;[470] NAME, ONCE FOR LOG NAME
	TRNE	F,R.EOL		;[473] EOL SEEN YET?
	  POPJ	P,		;[473] YES-SCAN BARFS IF WE CALL .SIXSW
	MOVE	T1,DEVPTR	;[470] GET POINTER TO TABLE
	AOBJP	T1,LGNA2M	;[470] TOO MANY /ASSIGN SWITCHES
	SETZ	T2,		;[627] ZAP T2 IN CASE NO LOGICAL NAME
	TRNE	F,R.NXSW	;[627] ARE WE ABOUT TO READ THE NEXT SWITCH?
	  JRST	ASIGN1		;[627] YES - DON'T!
	PUSH	P,T1		;[470] SAVE T1 OVER .SIXQW
	PUSHJ	P,.SIXSW##	;[470] GET SIXBIT STRING
	CAIN	C,"/"		;[627] NEXT SWITCH?
	TRO	  F,R.NXSW	;[627] REMEMBER TO STOP NOW
	SKIPG	C		;[473] EOL YET?
	TRO	  F,R.EOL	;[627] EOL - REMEMBER IT
	POP	P,T1		;[470] GET T1 BACK AGAIN
	MOVE	T2,.NMUL##	;[470] PICK UP ARG FROM SCAN
ASIGN1:	MOVEM	T2,(T1)		;[627] STORE AWAY IN TABLE
	MOVEM	T1,DEVPTR	;[470] SAVE POINTER TO TABLE
	POPJ	P,		;[470] RETURN

	WARN	A2M,<Attempt to assign too many devices with /ASSIGN>
	POPJ	P,		;AND RETURN
;SUBROUTINE TO READ /ACCOUNT SWITCH
;CALL:	PUSHJ	P,ACCTSW
;	RETURN HERE
;
ACCTSW:	PUSHJ	P,.SWASQ##	;READ THE QUOTED STRING
	MOVEI	N,1		;FAKE SCAN
	MOVE	T2,[POINT 7,.NMUL##];POINT TO STORAGE
	MOVEI	T3,^D39		;MAXIMUM NUMBER OF CHARACTERS IN ACCOUNT STRING
ACCTS1:	ILDB	T1,T2		;GET A CHAR
	JUMPE	T1,.SWDPB##	;NOTE THAT VALIDATION IS DONE LATER
	CAIGE	T1,176		;NO. CHECK FOR ILLEGAL CHARACTERS
	 CAIGE	T1," "
	  FATAL	ICA,<Illegal character in account string>,EF.FMT,.TFCHR##
	SOJGE	T3,ACCTS1	;LOOP FOR ALL
	FATAL	ATL,<Account string too long>,EF.FMT

;SUBROUTINE TO READ /REMARK SWITCH
;CALL:	PUSHJ	P,RMRKSW
;	RETURN HERE
;
RMRKSW:	PUSHJ	P,.SWASQ##	;READ THE QUOTED STRING
	MOVE	N,.NMUL##	;MAKE SCAN HAPPY
	MOVE	T2,[POINT 7,.NMUL##];POINT TO IT
	MOVEI	T3,^D39		;SET MAXIMUM LENGTH
RMRKS1:	ILDB	T1,T2		;GET A CHAR
	JUMPE	T1,.SWDPB##	;GO STORE IF THE END
	CAIGE	T1,176		;NO. CHECK FOR ILLEGAL CHARACTERS
	 CAIGE	T1," "
	  MOVEI	T1,"\"		;IF ILLEGAL, SUBSTITUTE A BACKSLASH
	DPB	T1,T2		;STORE THE CHAR
	SOJGE	T3,RMRKS1	;LOOP FOR ALL
	WARN	RST,<REMARK string truncated to 39 characters>
	MOVEI	T1,0		;INSURE NULL AT END
	DPB	T1,T2		;STICK IT IN
	JRST	.SWDPB##	;AND RETURN TO STORE

;SUBROUTINE TO READ /BATNAM:"NAME" SWITCH
BATNAM:	PUSHJ	P,.SIXQW##	;[744] READ QUOTED SIXBIT STRING
	MOVE	N,.NMUL##	;[744] RETURN FIRST WORD
	JRST	.SWDPB##	;[744] AND LET SCAN STORE
	SUBTTL	TERMSW - Handle /TERMINAL:(args) switch	[744]

IFN SETTTY,<
TERMSW:	MOVEI	T1,TERSWT		;POINT TO SUB-TABLE
	PJRST	KEYWRD			;HANDLE THE KEYWORDS
>

	SUBTTL	DEFASW -- Handle /DEFAULT:(args) switch

DEFASW:	MOVEI	T1,DEFSWT		;POINT TO SUB-TABLE
	PJRST	KEYWRD			;HANDLE THE KEYWORDS


	SUBTTL	BATCSW -- Handle /BATCH:(args) switch

BATCSW:	MOVEI	T1,BATSWT		;POINT TO SUB-TABLE
	PJRST	KEYWRD			;HANDLE THE KEYWORDS
;THIS ROUTINE IS SIMILIAR TO .KEYWD IN SCAN, EXCEPT IT DOESNT HANDLE
;ALSO THE CASES THAT SCAN'S DOES. BUT, IT HANDLES THE SIMPLE SN,SP,SL
;SUB-SWITCHES THAT LOGIN USERS FOR /TERMINAL:. MAYBE SOMEDAY IF SCAN
;CHANGES, WE CAN REMOVE THIS CODE
					;  AND P2 (LOCAL/REMOTE INDEX)
KEYWRD:	PUSHJ	P,.SAVE2##		;SAVE P1 (SWITCH INDEX)
	MOVEI	P2,(T1)			;SAVE POINTER TO SWITCH TABLE
	PUSHJ	P,SIXSW			;GET NAME
	MOVE	T1,SWA(P2)		;GET POINTER TO TABLES
	PUSHJ	P,SWTNAM		;LOOKUP IN TABLE
	 SKIPA				;CAN'T FIND, TRY HARDER
	  JRST	KEYWDG			;GOT IT
	JUMPG	T1,E.UKK##		;AMBIGUOUS IF MORE THAN ONE
	TLC	N,'NO '			;SEE IF /NOXYZ
	TLCE	N,'NO '			;..
	 JRST	E.UKK##			;NO--ISSUE ERROR
	PUSH	P,N			;SAVE WORD
	LSH	N,^D12			;STRIP "NO"
	MOVE	T1,SWA(P2)		;POINT TO TABLES AGAIN
	PUSHJ	P,SWTNAM		;LOOKUP
	 JRST	[POP   P,N		;ERROR--RESTORE WORD
		 JRST	E.UKK]		;AND ISSUE ERROR
	POP	P,N			;RESTORE NAME
	TLO	P1,-1			;FLAG /NOXYZ
	MOVX	T1,FS.NOS 		;GET YES/NO BIT
	TDNN	T1,@SWD(P2)		;SEE IF YES/NO SWITCH
	 JRST	[MOVNI	T1,1		;ELSE PRETEND UNKNOWN
		 JRST	E.UKK##]	;FOR SCAN
KEYWDG:	MOVE	T2,@SWD(P2)		;GET DEFAULT
	MOVEI	N,(T2)			;COPY INTO N
	MOVE	T1,@SWM(P2)		;GET PROCESSOR OR TABLE POINTER
	TXNE	T2,FS.NOS		;SEE IF "NO" SWITCH
	JRST	[HLRZ N,P1		;IF SN STYLE, GET NO INDICATOR
		 MOVEI N,1(N)		;SET N=0 IF NO, 1 IF NOT NO
		 JRST KEYWDA]		;GO STUFF RESULT
	CAIN	C,":"			;SEE IF VALUE SPECIFIED
	JRST	KEYWD2			;YES--GO CHECK INTO IT
;HERE WHEN DEFAULT NEEDED
KEYWD1:	TXNE	T2,FS.VRQ		;SEE IF VALUE REQUIRED
	 JRST	E.SVR##			;YES--GIVE ERROR
	TLNN	T1,-1			;SEE IF MAX SET
	JUMPN	T1,KEYWDJ		;NO--DIRECT ACTION
	JRST	KEYWD8			;YES--GO STORE DEFAULT
;HERE WHEN VALUE SPECIFIED BY USER (MAY BE NULL)
KEYWD2:	;JUMPE	T1,E$$NMA		;IF NO VALUE LEGAL, GIVE ERROR
	JUMPG	T1,KEYWDJ		;IF SPECIAL PROCESSOR, GO DO IT

	PUSHJ	P,SIXSW			;VALUE IS ANOTHER KEYWORD--GET IT
	MOVE	T1,@SWM(P2)		;REFETCH SUB-KEY POINTER
	PUSHJ	P,.NAME			;LOOK IT UP
	  JRST	E.UKK##			;ERROR
	SUB	T1,@SWM(P2)		;DETERMINE INDEX AS VALUE
	MOVEI	N,(T1)			;PLACE IN VALUE (1,2,...)
	JRST	KEYWD8			;AND GO STORE IT AWAY

;HERE IF SN SWITCH TO LOOK FOR VALUES

KEYWDA:	JUMPE	N,KEYWD8		;IF NO, PROCEED (NO VALUES)
	CAIE	C,":"			;SEE IF VALUE COMING
	JRST	KEYWD8			;NO--THAT'S IT
KEYWDB:	PUSHJ	P,SIXSW		;GET VALUE AS NAME
	MOVE	T1,[IOWD YNTABL,YNTAB] 	;TRY YES-NO TABLE
	PUSHJ	P,.NAME			;LOOK UP NAME
	 JRST	E.UKK##			;UNKNOWN
	MOVEI	N,(T1)			;GET LOCATION OF MATCH
	SUBI	N,YNTAB			;GET OFFSET IN TABLE
	ANDI	N,1			;GET YES/NO SETTING
	JRST	KEYWD8			;RETURN THAT VALUE

;HERE TO GO TO SWITCH PROCESSOR
KEYWDJ:	PUSHJ	P,(T1)			;GO DO IT
	 JFCL				;GO STORE
;HERE TO STORE SWITCH
KEYWD8:	LDB	T1,@SWP(P2)		;GET STORED VALUE
	CAME	T1,[-1]			;SEE IF SET
	 JRST	[CAME	T1,N		;SAME AS BEFORE?
		  SKIPE	INISCN		;IN SWITCH.INI?
		   JRST	.SWDON##	;YES--JUST FORGET
		 JRST	E.DSI##]	;NO--ERROR
	DPB	N,@SWP(P2)		;NO--STORE VALUE
	JRST	.SWDON##		;AND RETURN W/O STORE

;TABLE OF YES/NO VALUES--MUST BE NO/YES PAIRS
YNTAB:	SIXBIT	/0/
	SIXBIT	/1/
	SIXBIT	/NO/
	SIXBIT	/YES/
	SIXBIT	/OFF/
	SIXBIT	/ON/
YNTABL==.-YNTAB

;ROUTINE TO READ SIXBIT WORD IGNORING LEADING SPACES
SIXSW:	PUSHJ	P,.TIAUC##		;Prime the pump
	CAIN	C," "			;Space?
	 PUSHJ	P,.TIAUC##		;Yes--Get a real char
	PJRST	.SIXSC##		;Read SIXBIT (char in C)

;ROUTINE TO LOOKUP SWITCH IN TABLE
SWTNAM:	PUSHJ	P,.NAME##		;LOOKUP IN TABLE
	 POPJ	P,			;NOT FOUND
	HRRZ	T2,SWN(P2)		;GET START
	MOVEI	P1,(T1)			;GET MATCH
	SUBI	P1,(T2)			;COMPUTE OFFSET
	JRST	.POPJ1##		;AND SKIP RETURN
;SUBROUTINE TO ASK FOR AND READ PASSWORD
;VALUES	T1=SIXBIT PASSWORD

CODGET:	PJUMPG	C,GET2WD	;[747] IF USER ALREADY TYPED, NO PROMPTS
	SKIPE	FL2741		;[546] IS THIS A 2741?
	  JRST	PW2741		;[546] YES - DO 2741 THINGS
	TLNE	F,FL.FDX	;SKIP IF NOT FDX LINE
	JRST	FDXCOD		;YES.
	MOVEI	T3,3		;THREE OVERLAYS
MASKLP:	PUSHJ	P,PRMASK	;PRINT THE MASK
	MOVX	T1,.CHCRT	;JUST A CR
	PUSHJ	P,.TCHAR##	;TYPE IT
	SOJG	T3,MASKLP	;GO BACK 3 TIMES
	PUSHJ	P,TTYOUT##	;FORCE OUTPUT
	PUSHJ	P,GET2WD	;COLLECT THE PASSWORD
	MOVEI	CH,"*"		;MASK FOR DISPLAY TERMINALS
	MOVEI	N,6		;COUNT
	PUSHJ	P,TYO		;PRINT ENOUGH TO ERASE PASSWORD
	SOJG	N,.-1		;LOOP
	PJRST	.TCRLF##	;[747] EASY

PW2741:	MOVEI	T1,[ASCIZ "Password: #$%&*@"]
	PUSHJ	P,PBACK6	;SEND 6 BACKSPACES
	PUSHJ	P,PRMASK	;PRINT A MASK
	PUSHJ	P,BACK6		;SEND 6 BACKSPACES
	PUSHJ	P,PRMASK	;PRINT A MASK
	PUSHJ	P,BACK6		;BACKSPACE OVER IT
	MOVEI	T1,[ASCIZ "######"] ;MAKE IT BLACK
	PUSHJ	P,PBACK6	; ..
	MOVEI	T1,[ASCIZ "@@@@@@"] ; ..
	PUSHJ	P,PBACK6
	PUSHJ	P,TTYOUT##	;FORCE OUTPUT
	JRST	CODCRL		;[747] READ PASSWORD

PBACK6:	PUSHJ	P,.TSTRG##	;TYPE STRING IN T1
BACK6:	MOVEI	T1,[BYTE (7)10,10,10,10,10,10,0]
	PJRST	.TSTRG##	;TYPE 6 BACKSPACES


;ROUTINE TO PRINT A MASK
PRMASK:	TIMER	T1,		;MUST MAKE MASK
	ADDB	T1,MSKMEM	;PROTECT AGAINST FAST SYSTEM
	TRO	T1,1		;FOR RANDOM NUMBERS
	MOVNI	T2,6		;6 CHARS LONG
MASK1:	IMULI	T1,-3		;RANDOM CHAR
	HRRZ	N,T1
	IDIVI	N,76		;NO SPACE OR QUEST MK
	MOVEI	CH,41(N+1)	;THE CHAR
	PUSHJ	P,TYO		;OUTPUT IT
	AOJL	T2,MASK1	;MAKE A LINE
	POPJ	P,0		;RETURN

FDXCOD:	MOVEI	T1,[ASCIZ/Password: /]	;REQUEST CODE
	PUSHJ	P,TTYPMT##	;PROMPT
CODCRL:	PUSHJ	P,GET2WD	;[747] READ PASSWORD
	PJRST	.TCRLF##	;[747] CRLF AND RETURN
LOGBLK:	IOWD	LOGSWL,LOGSWN
	XWD	LOGSWD,LOGSWM
	XWD	0,LOGSWP
	SIXBIT	/LOGIN/		;[320] TYPE HLP:LOGIN.HLP ON /HELP
LOGBLN==.-LOGBLK

ATTBLK:	IOWD	ATTSWL,ATTSWN
	XWD	ATTSWD,ATTSWM
	XWD	0,ATTSWP
	SIXBIT	/LOGIN/
ATTBLN==.-ATTBLK

SCIBLK:	IOWD	COMLEN,COMLST
	XWD	SAOFST,'LGN'
	XWD	TTYGET,STYO
	XWD	0,0
	XWD	SCNPMT##,FLUSH	
	EXP	FS.ICL

COMLST:	<SIXBIT	/LOGIN/>
	<SIXBIT	/ATTACH/>
	<SIXBIT	/SESSION/>
COMLEN==.-COMLST

LOKBLK:	XWD	[WILDBK],0
	XWD	JUNK,SECBUF	;[422] THROW AWAY 4-WORD LOOKUP BLK SO
	XWD	.FXLEN,.RBSTS+1	;[422] IT WON'T OVERWRITE AUXACC.SYS DATA
	XWD	0,WLDPNT
LOKBLN==.-LOKBLK

;OFFSETS INTO SWT TABLES FOR KEYWRD ROUTINE

	SWA==-1
	SWN==0
	SWP==1
	SWM==2
	SWD==3

IFN SETTTY,<			;[744]
	IOWD	TERM.L,TERM.N	;[744] POINTER TO SWITCH KEYWORDS
TERSWT:	TERM.N(P1)		;[744] SWITCH POINTERS FOR /SETTTY 
	TERM.P(P1)		;[744]
	TERM.M(P1)		;[744]
	TERM.D(P1)		;[744]
>;END IFN SETTTY		;[744]

	IOWD	DEFA.L,DEFA.N	;POINTER TO SWITCH KEYWORDS
DEFSWT:	DEFA.N(P1)		;SWITCH POINTERS FOR /DEFAULT:(args)
	DEFA.P(P1)
	DEFA.M(P1)
	DEFA.D(P1)

	IOWD	BATC.L,BATC.N	;POINTER TO SWITCH KEYWORDS
BATSWT:	BATC.N(P1)		;SWITCH POINTERS FOR /BATCULT:(args)
	BATC.P(P1)
	BATC.M(P1)
	BATC.D(P1)
	SUBTTL	Switch tables -- LOGIN switches (definition)

DM	COR,^D0,^D262143,^D262143	;[551]
DM	DPR,3,0,1
DM	FIL,.FXLEN,0,0
DM	LOC,77,0,0
DM	QTA,1,0,0
DM	TIM,0,0,^D60
DM	YN,1,0,1

KEYS	ATT,<ASK,IGNORE>
KEYS	DSKF,<ERROR,PAUSE>
KEYS	SPOL,<LPT,PLT,PTP,CDP,CDR>
KEYS	WTCH,<FILES,MTA,VERSION,WRITE,READ,WAIT,RUN,DAY>
KEYS	NOTC,<ALWAYS,SOMETIMES,NEVER>

	DEFINE SWTCHS,<
SP	ACCOUNT,<*P,<POINT ^D65-^D8,U.ACTS>>,ACCTSW,,FS.VRQ
SP	ASSIGN,<*F,DEVTAB>,ASSIGN,,FS.VRQ	;[470]
SL	ATTACH,<*F,U.ATT>,ATT,ATTASK
SP	BATCH,,BATCSW,,FS.VRQ
SN	BATINT,<*F,U.BINT>,			;Batch only - OPR intervention
SP	BATNAM,<*F,U.BNAM>,BATNAM,,FS.VRQ	;BATCH ONLY - BATCH JOB NAME
SP	BATSEQ,<*F,U.BSEQ>,.SWDEC##,,FS.VRQ	;BATCH ONLY - BATCH SEQUENCE NUMBER
SP	BATSTR,<*F,U.BSTR>,.SWOCT##,,FS.VRQ	;Batch only - Stream number
SP	CORE,<*F,U.CORE>,.SWCOR##,COR,FS.VRQ
SN	DEFER,<*F,U.DFER>,
SP	DEFAULT,,DEFASW,,FS.VRQ
SP	DEFBUFFER,<*F,U.DFBU>,.SWDEC##,BUF,	;[750]
SP	DEFPROT,<*F,U.DFPR>,.SWOCT##,PRO,FS.VRQ	;[620]
SL	DSKFUL,<*F,U.DFUL>,DSKF,DSKFPA
SP	DSKPRI,<*F,U.DPRI>,SWDSKP,DPR,FS.VRQ
SN	GUIDELINE,<*F,U.GUID>
SP	LIB,<*F,LIBSPC>,.SWFIL##,FIL,FS.VRQ
SN	LIMIT,<*F,U.LIMIT>
SP	LOCATE,<*F,U.STA>,.SWOCT##,LOC,FS.VRQ
IFN FTMAIL,<
SN	MAILCHECK,<*F,U.MAIL>,
>;END IFN FTMAIL
SP	NAME,<*P,<POINT ^D65-2,U.NAME>>,.SIXQW##,,FS.VRQ
SN	NEW,<*F,U.NEW>,
SS	NOLIB,<*F,LIBSPC+.FXDIR>,0
SP	NOTE,<*F,NOTSPC>,.SWFIL##,FIL,FS.VRQ
SL	NOTICE,<*F,U.NOTC>,NOTC,0,FS.VRQ	;[450] /NOTICE:
SS	NOWATCH,<*F,U.NWAT>,0
IFN	PSWCHG,<				;[557]
SN	PASSWORD,<*F,U.NPSW>, 			;[557]
	>					;[557] END IFN PSWCHG
SP	PATH,<*F,PTHSPC>,.SWFIL##,FIL,FS.VRQ	;[456] /PATH SWITCH
SP	*PHYSICAL,<*F,U.CPPL>,.SWCOR##,COR,FS.VRQ
SP	QUOTA,<*F,U.QTA>,QUOTAS##,QTA
SP	REMARK,<*P,<POINT ^D65-^D8,U.RMRK>>,RMRKSW,,FS.VRQ
SP	REQID,<*F,U.BREQ>,.SWDEC##,,FS.VRQ		;BATCH ONLY - BATCH REQUEST ID
SN	SCAN,<*F,U.SCAN>, 
SN	SFDCREATE,<*F,U.SFDC>,			;[757]
SP	SFDPROT,<*F,U.SFDP>,.SWOCT##,,FS.VRQ
SL	SPOOL,<*F,U.SPL>,SPOL,0,FS.OBV
SN	STR,<*F,U.STR>, 
SN	SYS,<*F,U.SYS>, 
SP	TIME,<*F,U.TIME>,.SWDEC##,TIM,FS.VRQ
SP	UFDPROT,<*F,U.UFDP>,.SWOCT##,,FS.VRQ	;[553]
SP	VIRTUAL,<*F,U.CVPL>,.SWCOR##,COR,FS.VRQ
SL	WATCH,<*F,U.WAT>,WTCH,0,FS.OBV


;**NOTE** DO NOT ADD NEW SETTTY SWITCHES HERE. ADD THEM IN THE OTHER
;KEYWORD TABLE ON THE NEXT PAGE. SOMEDAY THE STAND-ALONE SETTTY SWITCHES
;LISTED BELOW MAY BE REMOVED

IFN	SETTTY,<		;[344] TTY CHARACT. SWITCHES
SN	ALTMODE,<*F,U.ALTM>,
SN	BLANK,<*F,U.BLNK>,
SN	CRLF,<*F,U.CRLF>,
SN	DEBREAK,<*F,U.DBRK>,
SN	ECHO,<*F,U.ECHO>,
SP	FILL,<*F,U.FILL>,.SWOCT##,FLL
SN	FORM,<*F,U.FORM>,
SN	GAG,<*F,U.GAG>,
SN	LC,<*F,U.LC>,
SN	PAGE,<*F,U.PAGE>,
SP	PAGESIZE,<*F,U.PGSZ>,.SWDEC##,PSZ,FS.VRQ
SL	RCVSPEED,<*F,U.RSPD>,SPED,0,FS.VRQ
SN	RTCOMP,<*F,U.RTC>,
SL	SPEED,<*F,U.SPED>,SPED,0,FS.VRQ
SN	SETTTY,<*F,U.SETT>,			;[744]
SN	TABS,<*F,U.TABS>,
SN	TAPE,<*F,U.TAPE>,
SP	TERMINAL,,TERMSW,,FS.VRQ		;[744]
SN	TTDEFER,<*F,U.TTDE>,
SP	TYPE,<*F,U.TYPE>,.SWSIX##,,FS.VRQ	;[675]
SP	WIDTH,<*F,U.WDTH>,.SWDEC##,WTH,
SL	XMTSPEED,<*F,U.XSPD>,SPED,0,FS.VRQ
	>			;[344] END IFN SETTTY

>
	SUBTTL	Switch tables -- LOGIN switches (expansion)

	DOSCAN(LOGSW)			;LOGIN SWITCHES
	SUBTTL	Switch tables -- ATTACH switches (definition)

DEFINE SWTCHS,<
IFN FTMAIL,<
	SN	MAILCHECK,<*F,U.MAIL>,
>;END IFN FTMAIL
	SS	MONITOR,<*F,U.MODE>,0
	SS	USER,<*F,U.MODE>,1
>


	SUBTTL	Switch tables -- ATTACH switches (expansion)

	DOSCAN(ATTSW)			;ATTACH SWITCHES
	SUBTTL	Switch tables -- TERMINAL arguments (definition)

;[744] ADD ALL NEW TERMINAL SWITCHS HERE
IFN SETTTY,<

DM	FLL,3,0,2
DM	PSZ,^D255,^D255,^D24
DM	WTH,^D255,^D80,^D132

KEYS	SPED,<50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,EXTA,EXTB>
DEFINE SWTCHS,<
SN	ALTMODE,<*F,U.ALTM>,
SN	BLANKS,<*F,U.BLNK>,
SN	CRLF,<*F,U.CRLF>,
SN	DEBREAK,<*F,U.DBRK>,
SN	DEFER,<*F,U.TTDE>,
SN	DISPLAY,<*F,U.DISP>,
SN	ECHO,<*F,U.ECHO>,
SN	FFHOME,<*F,U.FFHO>,
SN	FFSIMULATE,<*F,U.FFSI>
SN	FFSTOP,<*F,U.FFST>
SP	FILL,<*F,U.FILL>,.SWOCT##,FLL
SN	FORM,<*F,U.FORM>,
SN	GAG,<*F,U.GAG>,
SN	LC,<*F,U.LC>,
SP	LENGTH,<*F,U.LENG>,.SWDEC##,PSZ,FS.VRQ
SS	NOFILL,<*F,U.FILL>,0			;[747]
SS	NOSTOP,<*F,U.STOP>,0
SS	NOSSTOP,<*F,U.SSTO>,0
SN	PAGE,<*F,U.PAGE>,
SP	PAGESIZE,<*F,U.PGSZ>,.SWDEC##,PSZ,FS.VRQ
SL	RCVSPEED,<*F,U.RSPD>,SPED,0,FS.VRQ
SN	RTCOMP,<*F,U.RTC>,
SN	SBELL,<*F,U.SBEL>,
SL	SPEED,<*F,U.SPED>,SPED,0,FS.VRQ
SP	STOP,<*F,U.STOP>,.SWDEC##,PSZ,FS.VRQ
SP	SSTOP,<*F,U.SSTO>,.SWDEC##,PSZ,FS.VRQ
SN	TABS,<*F,U.TABS>,
SN	TAPE,<*F,U.TAPE>,
SN	TIDY,<*F,U.TIDY>,			;[747]
SP	TYPE,<*F,U.TYPE>,.SIXSW##,,FS.VRQ	;[675]
SN	UC,<*F,U.UC>,				;[747]
SP	WIDTH,<*F,U.WDTH>,.SWDEC##,WTH,
SN	XONXOFF,<*F,U.XONXO>,
SL	XMTSPEED,<*F,U.XSPD>,SPED,0,FS.VRQ
>;END DEFINE SWTCHS
	SUBTTL	Switch tables -- TERMINAL arguments (expansion)

	DOSCAN	(TERM.)		;[744] EXPAND THE SUBTABLE POINTERS

>;END IFN SETTTY
	SUBTTL	Switch tables -- DEFAULT arguments (definition)

DM	PRO,777,0,0
DM	BUF,777,0,2
DM	BIG,^D31,0,^D4

DEFINE SWTCHS,<
SP	BIGBUFFER,<*F,U.DFBB>,.SWDEC##,BIG,
SP	BUFFER,<*F,U.DFBU>,.SWDEC##,BUF,
SP	PROTECTION,<*F,U.DFPR>,.SWOCT##,PRO,FS.VRQ
>
	SUBTTL	Switch tables -- DEFAULT arguments (expansion)

	DOSCAN	(DEFA.)		;EXPAND THE SUBTABLE POINTERS
	SUBTTL	Switch tables -- BATCH arguments (definition)

DEFINE SWTCHS,<
SN	INTERVENTION,<*F,U.BINT>,
SP	NAME,<*F,U.BNAM>,BATNAM,,FS.VRQ
SP	SEQUENCE,<*F,U.BSEQ>,.SWDEC##,,FS.VRQ
SP	STREAM,<*F,U.BSTR>,.SWOCT##,,FS.VRQ
SP	REQUESTID,<*F,U.BREQ>,.SWDEC##,,FS.VRQ
>
	SUBTTL	Switch tables -- BATCH arguments (expansion)

	DOSCAN	(BATC.)
	SUBTTL	LGNSCN storage

	WCHLSH==:^D17-WTCHDA	;AMOUNT TO SHIFT BITS RETURNED BY
				; SCAN FOR SETUUO

;LOWSEG STORAGE FOR LGNSCN
	RELOC
MSKMEM:	BLOCK	1	;MEMORY FOR MASK PRINTER
	RELOC
	PRGEND
	TITLE	LGNACT - Accounting module for LOGIN

	SEARCH	UUOSYM,MACTEN,SCNMAC,LGNUNV,ACTSYM,UFDPRM

	LGNDCL

;ENTER HERE WITH	T3=TTBITS FOR TTY OR CONTROL JOB TTY

TTYGO:	MOVE	T2,STATES	;GET STATES BITS
	TLNE	F,L.OPR!L.SOPR	;OPER OR HIS SUB?
	TLNE	F,FL.BAT	;[700]  AND NON-BATCH JOB?
	SKIPA			;[700]  NO--CONTINUE
	JRST	PPNGO4		;[1101] YES. OK TO GO
	TXNN	T2,ST%NLG	;NO LOGIN?
	JRST	SYSAVL		;NO--SYSTEM IS AVAIL
	STOP	SNA,<System not available>
SYSAVL:	TXNE	T3,GL.DSL!GL.REM	;NON-LOCAL?
	TXNN	T2,ST%NRL	;AND STATES SAYS LOCAL ONLY?
	JRST	NOTRMT		;NO. OK
	REQUE	NRU,<No remote users; Try again later>
NOTRMT:	TLNE	F,FL.ATT	;[555] SKIP IF LOGIN, NOT IF ATTACH
	  JRST	PPNGO4		;[654] DON'T NEED TO CHECK LOGMAX FOR ATTACH
NT2MNY:	TLNE	F,FL.BAT	;BATCH JOB?
	JRST	PPNGO		;YES, GO CHECK JOBMAX
	TXNN	T2,ST%BON	;NO. BATCH ONLY ONES ALLOWED?
	JRST	PPNGO		;NO
	FATAL	OBU,<Only batch users may LOGIN>
PPNGO:	MOVSI	T1,(AC.MAX)	;[1101] SETUP TO CHECK LOGMAX
IFN BATMAX,<
	TLNE	F,FL.BAT	;[1101] IS THIS GUY BATCH?
	TLO	T1,(AC.BMX)	;[1101] YES, CHECK BATMAX
>
	ACCLG.	T1,		;[1101] SEE IF WE CAN GET ACCESS
	  JRST	ACCERR		;[1101] NO, FIND OUT WHY AND GIVE AN ERROR

PPNGO4:	MOVX	T1,%NSKTM	;FIND OUT IF SYSTEM IS DOWN
	GETTAB	T1,
	  SETZ	T1,
	JUMPE	T1,PPNGO1	;OK TO GO
	JUMPG	T1,PPNGO3	;JUMP IF SYSTEM GOING DOWN SOON
	TLNN	F,L.OPR!L.SOPR	;[606] IF OPR OR SUB OF OPR OR 1,2
 	 TXNN	T3,GL.REM!GL.DSL	;[657] OR LOCAL TTY
	  JRST	PPNGO1		;[606] THEN LET HIM IN ANYWAY
	STOP	TIO,<Timesharing is over>
PPNGO3:	CAIL	T1,^D24*^D60	;OVER A DAY TO GO?
	JRST	PPNGO1		;YES--SKIP WARNING
	INFO	TCI,<Timesharing will cease in >,,E.TCI
	JRST	PPNGO1

E.TCI:	PUSH	P,T1		;SAVE MINUTES TILL KSYS
	IDIVI	T1,^D60
	MOVE	T4,T2		;SAVE REMAINDER (MINUTES)
	JUMPE	T1,E.TCI1	;SEE IF HOURS NONZERO
	PUSHJ	P,.TDECW##	;YES. PRINT HOURS
	MOVEI	T1,[ASCIZ/ hours /]
	PUSHJ	P,.TSTRG##
E.TCI1:	MOVE	T1,T4		;GET MINUTES
	PUSHJ	P,.TDECW##
	MOVEI	T1,[ASCIZ/ minutes at /]
	PUSHJ	P,.TSTRG##	;TYPE
	MSTIME	T1,		;GET NOW
	IDIVI	T1,^D60*^D1000	;MAKE MINUTES
	POP	P,T2		;RESTORE KSYS TIMER
	ADD	T1,T2		;COMBINE
	CAILE	T1,^D24*^D60	;WRAP AROUND?
	 SUBI	T1,^D24*^D60	;YES--FIX UP
	IMULI	T1,^D60*^D1000	;BACK INTO MILLISECONDS FOR SCAN
	PJRST	.TTIME##	;TYPE AND RETURN

;HERE TO BEGIN CHECKING PPN

PPNGO1:	TLNE	F,FL.ATT	;[555] LOGIN OR ATTACH?
	  JRST	ATTCHK		;[555] ATTACH


;HERE TO COMPUTE BIT IN TIMES WORD TO CHECK

	MOVE	T1,STATES	;[354] GET STATES WORD
	TXNN	T1,ST%NOP	;[354] IS THERE AN OPERATOR?
	JRST	LOGIN3		;[354,360] YES -- PROCEED
	INFO	NOC,<No operator coverage>

LOGIN3:	MOVE	P,PDPLST	;[565] RE-INIT STACK
	TLZ	F,FL.WKD+FL.RAS	;TRY AGAIN ENTRY
	PUSHJ	P,.GTNOW##	;GO GET TODAYS DATE
	HLRZ	T1,T1		;SAVE THE DAY
	IDIVI	T1,7		;FIGURE OUT THE DAY
	CAIL	T2,3		;[316] SATURDAY??
	CAILE	T2,4		;[316]  OR SUNDAY??
	TLO	F,FL.WKD	;NO--FLAG AS WEEKDAY
	MOVEM	T2,SAVEDA	;SALT AWAY
	MSTIME	T1,
	IDIV	T1,[EXP ^D1000*^D60*^D60]
	MOVSI	T2,400000	;MAKE A BIT FOR THE CURRENT HOUR
	TLNN	F,FL.WKD	;WEEKDAY?
	MOVEI	T2,4000		;NO. USE LOW 12 BITS
	TLNN	F,FL.WKD	;WEEKDAY?
	ASH	T1,-1		;NO. USE TWO-HOUR SHIFTS
	MOVNS	T1
	LSH	T2,0(T1)	;PUT BIT IN TUNE WITH TIME
	MOVEM	T2,NOWBIT	;SAVE.

	PUSHJ	P,PARSE##	;GO PARSE LOGIN LINE
ATTCHK:	CAME	PP,SYSPPN	;SYSPPN CAN ALWAYS LOGIN
	CAME	PP,MFDPPN	;BUT IF MFDPPN IS NOT SYSPPN,
	JRST	STACCT
	FATAL	MLB,<May not LOGIN as MFD PPN>,EF.FMT

;	HERE IF ACCLG. UUO FAILED

ACCERR:	MOVEI	T2,3		;[1101] 1=ALWAYS, 2=SOMETIMES, 3=NEVER
	MOVEM	T2,U.NOTC	;[1101] Simulate /NOTICE:NEVER
	CAIE	T1,ACLMX%	;[1101] DID LOGMAX FAIL?
	  JRST	ACCBMX		;[1101] NO, SO CHECK BATMAX
	REQUE	JCE,<Job capacity exceeded>;[1101]
ACCBMX:	CAIE	T1,ACLBM%	;[1101] did BATMAX fail?
	  JRST	ACCJLG		;[1101] NO, CHECK FOR JLOG ERROR
	REQUE	BJC,<Batch job capacity exceeded>
ACCJLG:	CAIE	T1,ACLJL%	;[1101] WAS JLOG ON?
	  JRST	ACCILL		;[1101] NO, SEE IF BAD ARGUMENT
	STOP	JLG,<Decrement tried with JLOG on>,EF.WTO
ACCILL:	CAIE	T1,ACLIL%	;[1101] WAS IT A BAD ARGUMENT?
	  JRST	ACCDCR		;[1101] NO, CHECK FOR DECR ERROR
	STOP	ARG,<Illegal argument detected>,EF.WTO
ACCDCR:	CAIE	T1,ACLDC%	;[1101] WAS IT A BAD DECR
	  JRST	ACCDIE		;[1101] NO, WE HAVE AN UNKNOWN ERROR
	STOP	DCR,<Decrement tried with PD.LGN on>,EF.WTO
ACCDIE:	STOP	UKN,<Unknown error detected from ACCLG. UUO>,EF.WTO
	SUBTTL	Search ACCT.SYS

;HERE TO SEARCH ACCT.SYS FOR USER'S ENTRY

STACCT:	PUSHJ	P,CLRRIB	;[540] CLEAR EXTENDED LOOKUP BLOCK
	MOVE	T1,[SIXBIT /ACCT/]	;LOOK FOR THE SYSTEM FILE
	MOVEM	T1,SECBUF+.RBNAM	;[540] PUT INTO LOOKUP BLOCK
	MOVSI	T1,(SIXBIT /SYS/)	;[540] GET EXTENSION
	MOVEM	T1,SECBUF+.RBEXT	;[540] STUFF IT
	MOVE	T1,SYSPPN	;[540] GET SYS: PPN
	MOVEM	T1,SECBUF+.RBPPN;[540] STUFF IT
	MOVEI	T1,.RBTIM	;[540] GET ARGUMENT COUNT
	MOVEM	T1,SECBUF+.RBCNT;[540] ..
	SETZM	ENTRY		;[540] CLEAR ENTRY IN CASE NO ACCT.SYS
	MOVE	T4,[XWD ENTRY,ENTRY+1]
	BLT	T4,ENTRY+MAXENT-1
	LOOKUP	UFD,SECBUF	;[540] TRY TO READ IT
	  JRST	NOSYS		;CANT. GO DIE.
	MOVE	T1,SECBUF+.RBSIZ;[540] GET NO. OF WORDS WRITTEN
	ADDI	T1,^D127	;[540] COUNT 1 FOR LAST PARTIAL BLOCK
	IDIVI	T1,^D128	;[540] CONVERT TO BLOCKS
	MOVEM	T1,ACCTLN	;ALWAYS SAVE BLOCKS
	SETZM	ACCKNT		;CLEAR COUNT OF READS ON ACCT.SYS
	TLO	F,FL.ACC	;SET FLAG TO NOTE READING ACCT.SYS

;HERE TO FIND DIRECTORY OF ACCT.SYS, IF ANY,
;	AND BUILD IT IN THE HI SEGMENT IF NONE.
IFN	FASTLG,<
	MOVE	T2,SECBUF+.RBTIM;[540] GET CREATION DATE-TIME
	CAME	T2,W.ACCT	;[540] COMPARE WITH LAST DATE-TIME
	  JRST	REBILD		;[540] IF CHANGED, REBUILD TABLE
	SKIPE	DACCFL		;IF TABLE NOT BUILT
	CAME	T1,DACCL	;OR LENGTHS DIFFER
	JRST	REBILD		;BUILD TABLE IMMEDIATELY
	PUSHJ	P,SNOOZE	;ELSE SLEEP
	JRST	LUKUPP		;UNTIL TABLE FINISHED
				;OR WE GET IMPATIENT
REBILD:	SETZM	RDHED		;[444] FORCE NEXT READ TO INPUT
	PUSHJ	P,LOK		;[444] LOCK OUT CTRL-C, WRITE-ENABLE HI SEG
	SETOM	SCDBLT		;[463] INVALIDATE SCHED. TABLE
	SETOM	DACCFL		;INDICATE BUILD-IN-PROGRESS
	AOSG	DLOCK		;CHECK LOCK
	JRST	BDACCT		;GO BUILD TABLE
	PUSHJ	P,SNOOZE	;IN-PROGRESS, WAIT AWHILE
	JRST	RSPROT		;GOT BUILT WHILE WE WAITED
				;FALL OUT HERE IF NO ACTION IN 10 SECS
BDACCT:	MOVE	T1,ACCTLN	;LENGTH OF ACCT.SYS
	MOVEM	T1,DACCL	;SAVE IN HI-SEG
	LSH	T1,1		;DOUBLE BECAUSE WE NEED 2 DIRECTORIES
	SKIPN	WD,PDACC	;UNLESS WE'VE DONE THIS BEFORE,
	HLRZ	WD,.JBHRL	;[424]  GET HIGHEST WE GOT
	TRO	WD,400000	;[424]
	MOVEM	WD,PDACC	;SETUP POINTER TO DIRECTORIES
	ADDI	T1,(WD)		;THAT'S HOW MUCH WE NEED NOW
	HRRZ	WD,.JBHRL
	CAIG	T1,(WD)		;DO WE NEED MORE?
	JRST	COREOK		;NO, DON'T BOTHER THE MONITOR
	HRLZS	T1		;SETUP TO GET MORE
	CORE	T1,
	  JRST	NOSYS		;FATAL ERROR-INSUFFICIENT CORE
COREOK:	PUSHJ	P,RDUFD		;GET FORMAT WORD
	  JRST	NOSYS		;WHA???
	LDB	T1,[POINTR WD,AC.LEN];GET SIZE OF ENTRIES IN ACCT.SYS
	MOVEM	T1,ENTSIZ	;SAVE
	LDB	WD,[POINTR WD,AC.VRS];GET FORMAT VERSION
	CAIL	WD,ACC506	;[356] IS THIS ACCT.SYS A FORMAT
	CAILE	WD,ACC602	;[356] WE KNOW ABOUT?
	JRST	LGNWFV		;NO -- CROAK
	CAIL	WD,ACC602	;[356] SETTING 6.02 STUFF?
	SETOM	EQACT		;[356] YES -- SET FLAG TO REMEMBER
	CAIL	WD,ACC601	;IS THIS THE NEW FORMAT
	SETOM	NEWACT		;YES--SET THE FLAG
	MOVEI	T1,200		;BLOCK LENGTH
	IDIV	T1,ENTSIZ	;OVER ENTRY SIZE IS ENTRIES PER BLOCK
				;T2 GETS REMAINDER
	HRRZ	T1,PDACC	;GET ADDR OF TABLE
	MOVEI	T3,1		;FIRST WORD OF BLOCK IS ALREADY USED
NXTABC:	MOVE	PP,UFDBUF(T3)	;GET FIRST PPN OF THIS BLOCK
	MOVEM	PP,0(T1)	;STORE IN TABLE
	SUB	T3,T2		;POINT TO FIRST PPN IN NEXT BLOCK
	JUMPGE	T3,.+2		;DON'T LET IT GO NEGATIVE
	ADD	T3,ENTSIZ	;KEEP RESULT MODULO ENTSIZE
	SETZM	RDHED		;FORCE A READ
	PUSHJ	P,RDUFD
	  JRST	.+2		;ALL DONE-EOF
	AOJA	T1,NXTABC	;LOOK FOR PPN IN THIS BLOCK
	SETZB	T1,DAUXFL	;FORCE REBUILD OF AUX TABLE
	HRLOM	T1,DACCFL	;SET TABLE-FINISHED SW
	SETOM	DLOCK		;UNLOCK THE CODE
	MOVE	T1,SECBUF+.RBTIM;[540] GET CREATION DATE-TIME OF ACCT.SYS
	MOVEM	T1,W.ACCT	;[540] SAVE IN HI-SEG
RSPROT:	PUSHJ	P,UNLOCK	;[444] UNLOCK CTRL-C
;HERE TO FIND USER'S PPN IN TABLE

LUKUPP:	MOVE	PP,PPN		;GET USER'S PPN
	TRNE	PP,1B18		;WILD PPN?
	HRRI	PP,UNIPRG	;YES--LOOK FOR RIGHT GUY
	MOVN	T1,DACCL	;LENGTH OF TABLE
	HRLZ	T1,T1		;[371] FOR AOBJN LOOP
	HRR	T1,PDACC	;GET ADDR OF TABLE
	CAML	PP,0(T1)	;SCAN FOR HIGHER PPN
	AOBJN	T1,.-1		;CONTINUE SEARCH IF NOT
	JUMPL	T1,NLSTPP	;IS THIS THE LAST ENTRY IN THE TABLE?
	SKIPN	-1(T1)		;IF SO, IS PPN REACT'S TRAILING ZERO?
	SOJ	T1,		;YES TO BOTH. MUST BE IN PRECEDING BLOCK
NLSTPP:	HRRZ	T1,T1		;[371] DISCARD COUNTER IN A LEFT
	SUB	T1,PDACC	;GET OFFSET WITHIN TABLE
	SOJL	T1,PPERR1	;BEWARE THE RIDICULOUS
	HRRZM	T1,ACCKNT	;SET POINTER INTO ACCT.SYS
	USETI	UFD,1(T1)	;SETUP FOR DESIRED BLOCK

;	FIND THE ADDRESS OF THE FIRST PPN IN THIS BLOCK

	MOVE	T4,ENTSIZ	;JUST TO HAVE IT THERE
	HRRZ	T2,T1		;COPY BLOCK COUNT
	ASH	T2,7		;TIMES 200 (BLOCK LENGTH)
	IDIV	T2,T4
	MOVN	T2,T3		;NEGATIVE REMAINDER
	AOJGE	T2,.+2		;ALLOW ONE FOR FORMAT WORD
	ADD	T2,T4		;GET POINTER INTO BLOCK
	MOVNI	T3,177(T4)	;-(BLOCK LEN + ENTSIZ - 1)
	IDIV	T3,T4		;T3 GETS -(NO OF ENTRIES/BLOCK)
	SETZM	RDHED		;FORCE A READ
	PUSHJ	P,RDUFD		;GET THE RIGHT BLOCK
	  JRST	PPERR1		;I HOPE IT'S HIS FAULT
	MOVE	WD,UFDBUF(T2)	;GET FIRST PPN OF BLOCK
	ADD	T1,PDACC	;POINT DIRECTLY TO TABLE ENTRY
	CAME	WD,0(T1)	;CHECK TABLE ACCURACY
	JRST	BADTAB		;IT LIED--REBUILD IT
	HRLI	T2,-200(T2)	;REMAINING COUNT IN BLOCK
	HRRI	T2,UFDBUF-1(T2)	;MAKES IOWD FOR FIRST PPN OF BLOCK
	MOVEM	T2,RDHED	;THAT ENABLES USE OF RDUFD, WHICH
				;MASKS BLOCK BOUNDARIES
>;*** END OF CONDITIONAL ON FASTLG
;HERE TO FIND USER'S ENTRY (IF ANY)

RDACCT:	MOVN	T1,ENTSIZ	;GET SIZE AS A COUNT
	HRLZS	T1		;FOR AOBJN
RDACT1:	PUSHJ	P,RDUFD		;GET A WORD
	  JRST	PPERR1		;GOT TO EOF
	MOVEM	WD,ENTRY(T1)	;STORE IN TEMP BLOCK
	IFN	PSWCHG,<	;[610] IF ALLOWING /PASSWORD
	HRRZ	T2,T1		;[624] STRIP OFF COUNT
	CAIE	T2,.ACPSW	;[624] DID WE JUST READ THE PSWD?
	  JRST	RDACT2		;[610] NO
	HRRZ	T2,RDHED	;[610] YES: GET PTR TO WORD WITHIN BLOCK
	MOVEM	T2,SAVPOS	;[610] SAVE FOR LATER
	MOVE	T2,ACCKNT	;[610] PICK UP BLOCK THIS IS IN
	MOVEM	T2,SAVBLK	;[610] AND REMEMBER FOR LATER
RDACT2:	>			;END IFN PSWCHG
	AOBJN	T1,RDACT1	;GET REST OF ENTRY
	MOVE	T1,ENTRY+.ACPPN	;CHECK FOR THE PPN
	HLRZ	T2,T1		;PROJ. IN FILE
	HLRZ	T4,PPN		;PROJ SUPPLIED
	CAMLE	T2,T4		;PASSED IT YET?
	JRST	PPERR1		;YES. NOT THERE.
	CAMN	T1,PPN		;IS THIS IT?
	JRST	PPNHIT		;YES. LOOK AT ENTRY
	CAME	T2,T4		;SAME PROJECT
	JRST	NXTPP		;NO. DON'T LOOK FOR #
	MOVE	WD,PPN		;PICK UP PPN
	TRNN	WD,1B18		;WILD ENTRY?
	JRST	[HRRZ	T2,T1	;GET PROGRAMMER NUMBER IN FILE
		HRRZ	T4,PPN	;GET PROGRAMMER NUMBER USER TYPED
		CAMLE	T2,T4	;HAVE WE PASSED IT BY YET?
		JRST	PPERR1	;YES. NON-EXISTANT PPN
		JRST	NXTPP]	;NO. READ NEXT ENTRY
	HRRZI	T1,(T1)		;COPY PROG NBR.
	CAIN	T1,UNIPRG	;MATCH WILD NO
	JRST	PPNHIT		;YES. LOOK AT ENTRY
IFE	FASTLG,<
	JRST	RDACCT		;GO FOR NEXT
NXTPP==	RDACCT	>
IFN	FASTLG,<
NXTPP:	AOJL	T3,RDACCT	;MORE IN THIS BLOCK?

;	WE HAVE NOW READ AN ENTIRE BLOCK WITHOUT FINDING THIS PPN
;	EITHER THE TABLE WAS INCORRECT, OR PPN DOESN'T EXIST
;	ACCKNT points to block we are using

	MOVE	T1,ACCKNT	;GET TABLE POINTER
	ADD	T1,PDACC	;ADDRESS THE TABLE
	MOVE	T1,-1(T1)	;[751]GET FIRST PPN THIS BLOCK
	CAMN	T1,ENTRY+.ACPPN
	JRST	PPERR1		;IF MATCH, TABLE IS OK, SO PPN IS BAD
	PUSHJ	P,RDUFD		;HOWEVER, OUR ESTIMATE OF ENTRIES/BLOCK
	  JRST	PPERR1		;  MAY BE OFF BY 1, SO CHECK THE NEXT
	MOVE	T1,ACCKNT	;READ MAY HAVE INCREMENTED BLOCK NO
	ADD	T1,PDACC	;POINT INTO TABLE AGAIN
	CAMN	WD,-1(T1)	;[751]IS TABLE CORRECT FOR THIS BLOCK?
	JRST	PPERR1		;PPN IS WRONG
BADTAB:	USETI	UFD,1		;PREPARE TO SCAN ENTIRE FILE
	JRST	REBILD		;AND BUILD A NEW TABLE
>;*** END OF CONDITIONAL ON FASTLG
	SUBTTL	Check ACCT.SYS entry
;HERE TO DECIDE IF USER MAY LOGIN

PPNHIT:	TLZ	F,FL.ACC	;Clear flag to stop counting
	TRNE	F,R.SESSION	;[754] SESSION Command?
	 JRST	PSWOK		;[754] Yes--Skip all this stuff
	TLNE	F,FL.ATT	;Attach?
	 JRST	NOTWRN		;Yes--No expiration messages
	LDB	T1,[POINTR ENTRY+.ACESE,AC.EXP]	;[754] Get expiration date of PPN
	PUSHJ	P,FIXXPD	;[754] Change into universal format
	MOVEM	T1,XPDDTM	;[754] Save
	LDB	T1,[POINTR ENTRY+.ACESE,AC.EXP]	;GET EXPIRATION DATE OF PPN
	CAML	T1,TDATE	;[477] SKIP IF DATE L TODAY
	JRST	NOTEXP		;PPN IS OK
	FATAL	PHE,<PPN has expired>
NOTEXP:	;Give warning if PPN is about to expire
	SUBI	T1,EXPWRN	;subtract off threshold
	CAML	T1,TDATE	;skip if we're close
	 JRST	NOTWRN		;OK, no need for warning
	LDB	T1,[POINTR ENTRY+.ACESE,AC.EXP]	;get expiration date
	WARN	PWE,<PPN will expire on >,,.TDATE##
NOTWRN:	MOVE	T3,ENTRY+.ACPRO
	MOVE	T1,TTBITS
	TXNN	T1,GL.ITY	;SKIP IF PTY
	JRST	ASKLOK		;SEE IF MAY LOGIN AT THIS TERMINAL
	TLNE	F,FL.BSJ	;SKIP IF NOT BATCH JOB SUBJOB
	 TXNE	T3,AC.SBJ	;SKIP IF MAY NOT LOGIN AS SUBJOB
	  SKIPA			;[603] OK
	   JRST	NOLGTS
	TLNE	F,FL.BAT	;[603] BATCH JOB?
	 TXNE	T3,AC.BAT	;[603] YES - ALLOWED TO BE ONE?
	  SKIPA			;[603] NOT BATCH OR BATCH & ALLOWED TO BE
	   JRST	NOLGTS		;[603] BATCH & SHOULDN'T BE - COMPLAIN
	TLNE	F,FL.BAT	;[603] BATCH JOB?
	  JRST	CHEKIT		;[603] YES - CHECK TIMES TO LOG IN
	MOVE	T2,CNTLJP	;CONTROL JOB PPN
	CAME	T2,ALPPPN	;OK IF RUN BY JOB WITH ALL PRIVILEGES
	CAMN	T2,PPN		;OK IF RUN BY SAME PPN
	JRST	PSWOK
	MOVE	T1,CNTLJT	;GET LINE BITS FOR CONTROL JOB
ASKLOK:	TLNE	F,L.OPR!L.SOPR	;OK IF OPR OR SUB OF OPR OR 1,2
	JRST	LOGOK
	MOVX	T2,AC.LOC	;LOCAL BIT
	TXNE	T1,GL.REM	;SKIP IF NOT REMOTE HARDWIRED TTY
	MOVX	T2,AC.RMT	;REMOTE BIT
	TXNE	T1,GL.DSL	;SKIP IF NOT DATA SET TTY
	MOVX	T2,AC.DST
	TDNN	T2,T3		;SKIP IF MAY LOGIN AT THIS TERMINAL
	JRST	NOLGTS
CHEKIT:	MOVE	T2,ENTRY+.ACLIT	;[603] PICK UP TIME TO LOGIN WORD
	TLNN	F,FL.ATT	;Attach?
	TDNE	T2,NOWBIT	;IS HE ALLOWED NOW?
	JRST	LOGOK		;YES
	REQUE	SOT,<PPN not valid for this time of day>
LOGOK:	TLNE	F,FL.BAT	;BATCH JOB?
	JRST	PSWOK		;YES. DON'T PROMPT
	SKIPN	ENTRY+.ACNM1	;DO WE HAVE A DEFAULT NAME IN
				; ACCT.SYS
	JRST	GETNAM		;YES--HAVE HIM TYPE HIS NAME
	TXNN	T3,AC.PRT	;SKIP IF PASSWORD REQUIRED
	JRST	PSWOK		;NO, DONT ASK
	TXNN	T3,AC.NRT	;SKIP IF NAME REQUIRED
	JRST	GETCOD		;NO, GET PASSWORD
	JRST	GETNAM		;[323] YES, GET NAME AND PASSWORD

NOLGTS:	TLNE	F,FL.ATT	;SKIP IF LOGIN, NOT IF ATTACH
	 FATAL	MNA,<May not ATTACH >,EF.SIL,E.MNA
	FATAL	MNL,<May not LOGIN >,EF.SIL,E.MNL

E.MNL:!
E.MNA:	MOVEI	T1,[ASCIZ/local/]
	TXNE	T2,AC.RMT	;SKIP IF NOT REMOTE HARDWIRED TTY
	MOVEI	T1,[ASCIZ/remote/]
	TXNE	T2,AC.DST	;SKIP IF NOT DATA SET TTY
	MOVEI	T1,[ASCIZ/data set/]
	TXNE	T2,AC.ROP	;SKIP IF NOT REMOTE CTY OR OPR
	MOVEI	T1,[ASCIZ/remote CTY or OPR/]
	TLNE	F,FL.BSJ	;SKIP IF NOT BATCH JOB SUBJOB
	MOVEI	T1,[ASCIZ/as a BATCH job subjob/]
	TLNE	F,FL.BAT	;[603] BATCH JOB?
	MOVEI	T1,[ASCIZ/as a BATCH job/]
	PJRST	.TSTRG##		;TYPE AND RETURN
	SUBTTL	Write USAGE/FACT file entry

ACCT:	MOVEI	T1,UGLGN$	;[752] ASSUME LOGIN MESSAGE
	TRNE	F,R.SESS	;[752] SESSION COMMAND?
	 MOVEI	T1,UGSES$	;[752] YES--SESSION MESSAGE
	TLNE	F,FL.ATT	;[752] ATTACH COMMAND?
	 MOVEI	T1,UGATT$	;[752] YES--ATTACH MESSAGE
	PUSHJ	P,.USAGE	;[752] TELL THE ACCOUNT DAEMON
IFN FACTSW,<
	PUSHJ	P,ACCTA		;PUT IN ACCOUNTING DATA
	MOVE	P2,FCTWD	;GET CONTROL WORD
	TXNN	F,R.SESS	;DON'T MAKE FACT ENTRY IF SESSION
	PUSHJ	P,.FACTR##	;[571] STICK IT INTO FACT.SYS
>;[647] END IFN FACTSW
	RELEAS	UFD,0		;MAKE WAY FOR LATER IO
	JRST	LAST
	SUBTTL	SWITCH.INI handling

;SUBROUTINE TO BE CALLED WHEN READY TO READ SWITCH.INI OF THE USER.  THIS
;	ALSO FILLS IN THE ACCOUNT AND REMARK IF REQUIRED BY THE TWO BITS
;	AC.ACT AND AC.RMK FOUND IN THE USER PROFILE WORD OF ACCT.SYS.  IF
;	AN ACCOUNT IS REQUIRED (OR THE USER TYPED ONE) AND VALIDATION IS SET IN
;	THE SYSTEM STATES WORD, A CALL TO LGNUSG TO VALIDATE THAT ACCOUNT WILL BE DONE.

SW.INI::TLNE	F,FL.ATT	;SKIP IF LOGIN, NOT IF ATTACH
	 POPJ	P,		;[752] NEED NO MORE FOR ATTACH
	TXNN	F,R.SESS	;Skip if SESSION, not if LOGIN
	 SKIPE	PTHSPC+.FXDIR	;[467] WAS THERE A /PATH SWITCH?
	  JRST	NOZAP		;[467] YES - LEAVE IT ALONE
	SETZM	PTHSPC		;[467] NO - CLEAR OUT /PATH SPEC
	MOVE	T1,[PTHSPC,,PTHSPC+1]	;[467] AREA SO .OSCAN WILL
	BLT	T1,PTHSPC+.FXLEN-1	;[470] FILL IT IN
NOZAP:	MOVE	T1,[XWD LOGBLN,LOGBLK]	;[442] POINTER TO SWITCH TABLE
	SETOM	INISCN		;[744] FLAG IN SWITCH.INI OSCAN
	TLNN	F,FL.WLD	;[442] FUNNY PPN'S GET NO SWITCH.INI
	PUSHJ	P,.OSCAN##	;[442] READ SWITCH.INI
	SETZM	INISCN		;[744] DONE WITH SWITCH.INI
	PUSHJ	P,PROMPT	;PROMPT THE USER FOR MORE STUFF IF NECESSARY
				; (ACCOUNT AND REMARK FOR NOW)
	MOVE	T1,ENTRY+.ACNM1	;[442] GET USER NAME
	MOVE	T2,ENTRY+.ACNM2	;[442] FROM ACCT.SYS
	MOVE	T3,U.NAME	;[442] GET NAME FROM SWITCHES
	AOSN	T3		;[442] NAME GIVEN IN SWITCH?
	  JRST	ACCT3		;[442] NO - USE ACCT.SYS VALUE
	MOVE	T1,U.NAME	;[442] YES - PICK UP NAME
	MOVE	T2,U.NAME+1	;[442] FROM SWITCHES
ACCT3:	MOVEM	T1,NAME		;[442] STORE NAME AWAY
	MOVEM	T2,NAME2	;[442] FOR LOGIN UUO
	SKIPN	U.PATH+.FXDIR+2	;WERE SFD'S TYPED WITHOUT /PATH?
	CAME	PP,U.PATH+.FXDIR ;OR IS PATH PPN .NE. LOGGED-IN PPN?
	  JRST	NOBLT		;[506] YES - USE IT
	MOVE	T1,[PTHSPC,,U.PATH]	;[457] NO - BLT IN THE PATH SPEC
	BLT	T1,U.PATH+.FXLEN-1	;[457] TYPED IN THE /PATH SWITCH
NOBLT:	POPJ	P,		;[1101] RETURN
	SUBTTL	PROMPT user for ACCOUNT and REMARK

;PROMPT - ROUTINE TO BE CALLED IN CASE USER HAS TO BE PROMPTED FOR ANYTHING
;	MORE AFTER SYSTEM ACCESS CHECKING AND READING SWITCH.INI.
;	THE USERS'S SEARCH LIST HAS ALREADY BEEN SET UP, BUT NO UFD HANDLING
;	HAS TAKEN PLACE YET.

PROMPT:	PUSHJ	P,GETACT	;PROMPT THE USER FOR ACCOUNT IF REQUIRED.
				;THE ACCOUNT, IF GIVEN, WILL ALSO BE VALIDATED
	PUSHJ	P,GETRMK	;PROMPT FOR THE REMARK IF REQUIRED
	POPJ	P,
	SUBTTL	Get the account string

;GETACT - subroutine to provide accounting support. It works in the 
;following ways:
;1) If an account switch is given, always validate with ACTDAE.
;2) If no account is given, and one is NOT required, validate/default
;	the null account with ACTDAE.
;3) If no account is given and one IS required, prompt the user for it,
;	and validate whatever he typed (including the null string)
;Note that if accounting validation is turned off, the validation is
;ignored.

GETACT:	MOVE	T1,U.ACTS
	AOJN	T1,GETAC3	;HAS USER TYPED AN ACCOUNT SWITCH OR HAD IT IN SWITCH.INI?
	MOVE	T1,ENTRY+.ACPRO	;GET PROFILE WORD
	TXNE	T1,AC.ACT	;IS ACCOUNT STRING REQUIRED?
	 JRST	GETACP		;YES--PROMPT
	TRNE	F,R.SESSION	;SESSION COMMAND?
	 POPJ	P,		;YES--NO CHANGE IN ACCOUNT THEN
	SETZM	U.ACTS		;NOW ZERO THE ACCOUNT STRING AREA
	MOVE	T1,[U.ACTS,,U.ACTS+1]
	BLT	T1,U.ACTS+7
	JRST	GETAC3		;AND SEND NULL TO VALIDATE FOR DEFAULS

GETACP:	MOVE	T1,TTBITS	;IF WE ARE A PTY, PROMPTING WILL CAUSE
	TXNE	T1,GL.ITY	; BATCON, OPSER, ETC. TO DO ERROR REPORTING
	JRST	GETAC2		; SO, JUST TRY FOR A CONTROLLING JOB'S ACCOUNT
	SETZM	U.ACTS		;NOW ZERO THE ACCOUNT STRING AREA
	MOVE	T1,[U.ACTS,,U.ACTS+1]
	BLT	T1,U.ACTS+7
	MOVEI	T1,[ASCIZ/Account: /]	;PROMPT THE USER
	PUSHJ	P,TTYPMT##
	MOVEI	T1,[ASCIZ/a valid account string/]
	MOVEM	T1,HELP		;HELP TEST
	PUSHJ	P,TTYECH##	;SET TTY ECHO
	PUSHJ	P,.SAVE2##
	MOVE	P1,[POINT 7,U.ACTS]
	MOVEI	P2,^D39		;MAXIMUM LENGTH IS 39 CHARACTERS
GETAC1:	PUSHJ	P,.TICHE##	;GET CHARACTER
	JUMPLE	C,GETAC3	;DONE WITH INPUT?
	CAIGE	C,176		;NO. CHECK FOR ILLEGAL CHARACTERS
	CAIGE	C," "
	 FATAL	ICA,<Illegal character in account string>,EF.FMT
	IDPB	C,P1		;NOW STORE CHARACTER
	SOJGE	P2,GETAC1	;LOOP UNTIL WE HAVE THE WHOLE THING
	FATAL	ATL,<Account string too long>,EF.FMT
;HERE TO VALIDATE THE ACCOUNT IF NECESSARY.  IF AN ACCOUNT WAS REQUIRED BUT
;	HASN'T BEEN ENTERED YET, SEE IF THE JOB HAS A CONTROLLING JOB.  IF THE
;	JOB IS CONTROLLED BY ANOTHER AND BOTH JOBS ARE UNDER THE SAME PPN,
;	USE THE ACCOUNT THE CONTROLLING JOB IS LOGGED IN UNDER.  TO AVOID RACES
;	VALIDATE AGAIN EVEN THOUGH (MOST OF THE TIME) THE CONTROLLING JOB'S
;	ACCOUNT WAS VALIDATED.
GETAC2:	SETO	T3,		;IS THERE A CONTROLLING JOB?
	CTLJOB	T3,
	   FATAL NAS,<No account string specified>
	JUMPL	T3,LGNNAS	;NO CONTROLLING JOB. REPORT NO ACCOUNT
	HRL	T1,T3		;
	HRRI	T1,.GTPPN	;GET THE CONTROLLING JOB'S PPN
	GETTAB	T1,
	  JRST	LGNNAS		;ERROR. JUST REPORT NO ACCOUNT
	CAME	T1,PPN		;IS IT THE SAME PPN?
	JRST	LGNNAS		;NO. REPORT NO ACCOUNT SPECIFIED
	MOVE	T1,[.ACTRD,,T2]	;YES. USE THE CONTROLLING JOB'S ACCOUNT
	MOVEI	T2,2		;SET UP THE READ ACCOUNT UUO. JOB # IS IN T3
	MOVEI	T4,U.ACTS	;PUT IT THERE
	ACCT.	T1,
	  JRST	LGNNAS		;ERROR. REPORT NO ACCOUNT SPECIFIED
GETAC3:	MOVEI	T1,UGVAL$	;VALIDATION ID
	PJRST	.USAGE		;GO VALIDATE AND RETURN
	SUBTTL	Get the REMARK string

;GETRMK - ROUTINE TO PROMPT FOR AN REMARK IF THE USER IS REQUIRED TO
;	PROVIDE ONE.  IF MORE THAN 39 CHARACTERS ARE TYPED, THE REMARK
;	WILL BE TRUNCATED TO 39 CHARACTERS WITH NO WARNING TO THE USER.
;	IF ILLEGAL CHARACTERS ARE TYPED IN, A BACKSLASH WILL BE SUBSTITUTED
;	FOR THE CHARACTER, AGAIN, WITH NO WARNING TO THE USER.

GETRMK:	MOVE	T1,U.RMRK
	AOJN	T1,GETRM3	;HAS A /REMARK: SWITCH BEEN SEEN?
	MOVE	T1,ENTRY+.ACPRO
	TXNN	T1,AC.RMK	;IS A REMARK REQUIRED?
	JRST	GETRM3		;NO. DON'T BOTHER THE USER WITH A PROMPT
	MOVE	T1,TTBITS	;IF WE ARE A PTY, PROMPTING WILL CAUSE
	TXNE	T1,GL.ITY	; BATCON, OPSER, ETC. TO DO ERROR REPORTING
	JRST	GETRM3		; SO, JUST ALLOW FOR A NULL REMARK
	SETZM	U.RMRK		;NO. ZERO THE REMARK AREA
	MOVE	T1,[U.RMRK,,U.RMRK+1]
	BLT	T1,U.RMRK+7
	MOVEI	T1,[ASCIZ/Remark: /]	;PROMPT THE USER
	PUSHJ 	P,TTYPMT##	; ..
	MOVEI	T1,[ASCIZ/a remark string/]
	MOVEM	T1,HELP
	PUSHJ	P,TTYECH##	;SET TTY ECHO
	MOVE	P1,[POINT 7,U.RMRK]
	MOVEI	P2,^D39		;LIMIT IS 39 CHARACTERS
GETRM2:	PUSHJ	P,.TICHE##	;GET A CHARACTER
	JUMPLE	C,GETRM3
	CAIGE	C,176		;NO. CHECK FOR ILLEGAL CHARACTERS
	CAIGE	C," "
	MOVEI	C,"\"		;IF ILLEGAL, SUBSTITUTE A BACKSLASH
	CAIL	P2,1		;IF ROOM
	 IDPB	C,P1		; STORE THE CHARACTER
	SOJA	P2,GETRM2	;AND LOOP UNTIL EOL
GETRM3:	POPJ	P,
	SUBTTL	Fact file header setup
	IFN	FACTSW,<	;[647]
ACCTA:	MOVE	T1,MYTTY	;[351] TTY LINE NAME
	TLNE	T1,-1		;[421] DO WE HAVE A LINE?
	  JRST	ACCTA1		;[421] YES -- NOT DETACHED
	MOVNI	T1,2		;DET BECOMES -2
	JRST	ACCTA4
ACCTA1:	HRLZ	T4,T1		;D=LINE NUMBER
	JUMPE	T4,ACCTA3	;JUMP IF CTY
	MOVE	T3,[POINT 6,T4]
	SETZ	T1,
ACCTA2:	ILDB	T2,T3		;GET NEXT CHAR OF LINE NUMBER
	JUMPE	T2,ACCTA4	;JUMP IF NO MORE CHARS
	IMULI	T1,10		;CONVERT TO BINARY
	ADDI	T1,-20(T2)	;FROM OCTAL SIXBIT
	JRST	ACCTA2
ACCTA3:	SETO	T1,		;CTY BECOMES -1
ACCTA4:	LSH	T1,6		;SHIFT LEFT 6 BITS
	ANDI	T1,777700	;JUST 12 BITS
	TLNN	F,FL.ATT	;SKIP IF ATTACH, NOT IF LOGIN
	JRST	ACCTA5		;LOGIN
	IOR	T1,FCTAHD	;ATTACH HEADER
	MOVE	T2,ATTJOB	;TARGET JOB
	JRST	ACCTA6		;GO STORE THEM
ACCTA5:	IOR	T1,FCTHED	;LOGIN HEADER
	MOVE	T2,THSJOB	;GET JOB NUMBER
ACCTA6:	MOVEM	T1,FCTDAT	;PUT IN ENTRY
	DPB	T2,[POINT 9,FCTDAT,17]
	MOVE	T1,PPN
	MOVEM	T1,FCTDAT+1	;PROJ PROG NO. TO FACT ENTRY
	MOVSI	T1,(1B8)	;TURN ON BIT IN TYPE CODE
	IORM	T1,FCTDAT	; ..
	PUSHJ	P,.GTNOW##	;GET TODAYS DATE
	MOVEM	T1,FCTDAT+2	;STORE IN FACT FILE ENTRY

	POPJ	P,		;RETURN TO WRITE IT

> ;END FACTSW


	SUBTTL	Expiration date conversion 	[754]

;Call:
;	MOVE	T1,React-expiration date
;	PUSHJ	P,FIXXPD
;Returns with T1=Universal date/time (0=none, .INFIN=never)

FIXXPD:	JUMPE	T1,.POPJ##	;Leave zero alone
	CAIL	T1,77777	;See if large (from REACT)
	 JRST	FIXX.1		;Yes--Make .INFIN
	MOVEI	T2,0		;No time (we'll fix later)
	EXCH	T1,T2		;Switch for SCAN
	PUSHJ	P,.CNVDT##	;Convert to universal format
	ADD	T1,[1,,0]	;Bump to next day as PPN really expires
				;  one millisecond before midnite
	POPJ	P,		;And return
FIXX.1:	MOVX	T1,.INFIN	;Get largest date
	POPJ	P,		;And return
	SUBTTL	Password encryption routines

	IFN	NCRYPT,<	;[557] IF ENCRYPTING PSWDS

;ROUTINE TO HASH-CODE THE PASSWORD FOR GREATER SECURITY
;HASHING FUNCTION IS NON-INVERTIBLE
;CALL:	MOVE	P1,[PASSWORD]
;	PUSHJ	P,ENCODE##
;	RETURN HERE WITH HASHED PASSWORD IN P1

ENCODE::MOVE	T2,P1		;GET PSWD IN T2
	MOVE	T1,T2		;AND T2
	HRRZ	T4,PPN		;GET PROGRAMMER NUMBER
	IDIVI	T2,(T4)		;DIVIDE INTO PASSWORD
	MOVM	T3,T3		;GET ABS(REMAINDER)
	MOVE	T4,T3		;COPY FOR A LOOP COUNTER
FOO:	MUL	T1,T1		;SQUARE THE PASSWORD
	ROTC	T1,^D18		;GET MIDDLE 36 BITS OF RESULT
	JUMPN	T1,.+2		;MAKE SURE NON-ZERO
	MOVE	T1,T2		;IF ZERO, PICK UP PSWD AGAIN
	SOJG	T4,FOO		;DO THIS A LARGE (RANDOM) NO. OF TIMES
	XOR	T1,P1		;MUNGE IT STILL MORE
	IDIVI	T3,^D35		;DIVIDE LOOP COUNTER
	ROT	T1,1(T4)	;ROTATE T1 BY REMAINDER
	MOVE	P1,T1		;COPY FINAL RESULT BACK TO P1
	POPJ	P,		;ALL DONE!
	>			;[557] END IFN NCRYPT
	PRGEND
	TITLE	LGNUSG - USAGE accounting, IPCF, and validation
	SEARCH	UUOSYM,MACTEN,SCNMAC,LGNUNV,ACTSYM,UFDPRM
	LGNDCL

;THIS ROUTINE HANDLES ALL THE IPCF HANDLING NEEDED TO SUPPORT THE
;	USAGE FILE ACCOUNTING.  IT INCLUDES VALIDATION, ATTACH, LOGIN
;	AND SESSION IPCF MESSAGES TO THE ACCOUNTING DAEMON.   ACCOUNT
;	VALIDATION IS ALSO DONE BY THE ACCOUNTING DAEMON VIA IPCF.
;	THE CALL TO THIS MODULE IS:
;	T1/	FUNCTION (SEE ACTSYM.MAC FOR A LIST OF FUNCTIONS)
;	RETURN HERE.  IF THERE IS ANY ERROR (E.G., A VALIDATION ERROR),
;			THEN LOGIN WILL HANDLE ITS OWN ERROR REPORTING IN LGNERR.
;			THIS IS WHY THERE IS NO SKIP RETURN.

.USAGE:
IFE FTUSAG,<
	POPJ	P,		;USAGE FEATURE TEST IS TURNED OFF
> ;END IFE FTUSAG

IFN FTUSAG,<
	MOVEM	T1,ACTMES	;SAVE THE MESSAGE TYPE
	PUSHJ	P,WATPID	;WAIT FOR ACCOUNTING DAEMON
	 POPJ	P,		;NOT THERE AND VALIDATION NOT REQUIRED
				; OR VALIDATION REQUIRED BUT DEBUGING SYSTEM
				; AND ON A LOCAL TERMINAL
	MOVE	T1,ACTMES	;NOW GO DO THE IPCF MESSAGE
	CAIG	T1,UGATT$	;ANYTHING GREATER THAN ATTACH IS ILLEGAL IN LOGIN
	PJRST	@USGDSP(T1)
	STOP	IIM,<Illegal accounting message>,EF.WTO

;DISPATCH TABLE FOR IPCF MESSAGES IN LOGIN

USGDSP:	LGNIIM			;ILLEGAL MESSAGE TYPE
	USVALD			;VALIDATION MESSAGE
	USLOGN			;USER IS LOGGING IN MESSAGE
	USSESS			;USER HAS TYPED A SESSION COMMAND MESSAGE
	USATTA			;USER HAS ATTACHED TO HIS JOB
	SUBTTL	VALIDATION accounting message

;USVALD - ROUTINE TO SEND AND RECEIVE IPCF MESSAGES WITH THE ACCOUNTING DAEMON
;	TO VALIDATE ACCOUNTS.
USVALD:	PUSHJ	P,GETPAG	;GET A PAGE FOR IPCF SEND, T2 CONTAINS THE ADDRESS
	MOVE	T1,ACTMES	;GET THE MESSAGE TYPE
	MOVEM	T1,UV$TYP(T2)	;PUT THE MESSAGE TYPE IN THE IPCF SEND
	MOVE	T1,PPN		;GET THE PPN TO BE VALIDATED
	MOVEM	T1,UV$PPN(T2)
	HRLI	T1,U.ACTS	;WHERE TO BLT THE ACCOUNT FROM
	HRRI	T1,UV$ACT(T2)	;WHERE TO BLT THE ACCOUNT TO
	BLT	T1,UV$ACE(T2)
	PUSHJ	P,DATTIM	;GET THE DATE/TIME FOR A UNIQUE MESSAGE IDENTIFIER
	MOVEM	T1,UV$ACK(T2)
	PUSHJ	P,USSEND	;SEND THE MESSAGE
	PUSHJ	P,USRWAT	;DON'T DO ANYTHING UNTIL MESSAGE HAS BEEN RECEIVED
	PUSHJ	P,USGCHK	;CHECK TO SEE IF MESSAGE A-OK
	SKIPN	UC$ACT(T1)	;ACTDAE ANSWER US WITH AN ACCOUNT STRING?
	 POPJ	P,		;NO--USE WHAT WE HAD FIRST
	HRLI	T2,UC$ACT(T1)	;YES--SETUP BLT
	HRRI	T2,U.ACTS	;INTO OUR ACCOUNT STRING
	BLT	T2,U.ACTS+7	;COPY IT OVER
	POPJ	P,		;AND RETURN WITH NEW ACCOUNT STRING
	SUBTTL	LOGIN account message

;USLOGN - ROUTINE TO SEND A IPCF MESSAGE TO THE ACCOUNTING DAEMON
;	TO DENOTE THE FACT THAT THIS JOB IS LOGGING IN.
USLOGN:	PUSHJ	P,GETPAG	;GET A PAGE FOR IPCF SEND, T2 CONTAINS ADDRESS OF PAGE
	MOVEI	T1,UGLGN$	;MESSAGE TYPE
	MOVEM	T1,UL$TYP(T2)
	MOVE	T1,[SIXBIT /LOGIN/]
	MOVEM	T1,UL$PRG(T2)	;PROGRAM NAME
	MOVE	T1,.JBVER	;VERSION NUMBER
	MOVEM	T1,UL$VER(T2)
	HRLI	T1,U.ACTS	;ACCOUNT STRING
	HRRI	T1,UL$ACT(T2)
	BLT	T1,UL$ACE(T2)
	PUSHJ	P,DATTIM	;SESSION START DATE/TIME, ALSO UNIQUE MESSAGE IDENTIFIER
	MOVEM	T1,UL$ACK(T2)
	MOVEM	T1,UL$BEG(T2)
	TLNN	F,FL.BAT	;IS THIS A BATCH JOB?
	JRST	[MOVEI	T1,ULJTI$	;NO.
		MOVEM	T1,UL$JTY(T2)	;SKIP GATHERING OF BATCH INFORMATION
		JRST	USLOG1]
	MOVEI	T1,ULJBA$	;YES. INDICATE A BATCH JOB
	MOVEM	T1,UL$JTY(T2)
	MOVE	T1,U.BSEQ	;BATCH SEQUENCE NUMBER
	MOVEM	T1,UL$BSQ(T2)
	MOVE	T1,U.BNAM	;BATCH JOB NAME
	MOVEM	T1,UL$BNM(T2)
	MOVE	T1,U.BREQ	;BATCH REQUEST ID
	MOVEM	T1,UL$BRI(T2)
USLOG1:	HRLI	T1,U.RMRK	;SESSION REMARK
	HRRI	T1,UL$RMK(T2)
	BLT	T1,UL$RME(T2)
	LDB	T1,[POINTR ENTRY+.ACESE,AC.SCD]
	MOVEM	T1,UL$CLS(T2)	;SCHEDULING CLASS
	MOVE	T1,PPN		;USER'S PPN
	MOVEM	T1,UL$PPN(T2)
	MOVE	T1,ENTRY+.ACNM1	;USER'S NAME IN ACCT.SYS
	MOVEM	T1,UL$NM1(T2)
	MOVE	T1,ENTRY+.ACNM2
	MOVEM	T1,UL$NM2(T2)
	MOVE	T1,THSJOB	;GET THE JOB NUMBER
	PUSHJ	P,SETTNL	;FIND LINE NUMBER, NODE NAME, TERMINAL DESG.
	MOVE	T1,MONLNO	;LINE NUMBER
	MOVEM	T1,UL$LIN(T2)	;STORE THE LINE NUMBER
	MOVE	T1,MONNOD	;NODE NAME
	MOVEM	T1,UL$NOD(T2)
	MOVE	T1,MONTDE	;LINE DESIGNATOR
	MOVEM	T1,UL$TDE(T2)
	PUSHJ	P,USSEND	;SEND THE MESSAGE
	PUSHJ	P,USRWAT	;WAIT
	PJRST	USGCHK		;CHECK TO SEE IF MESSAGE A-OK
	SUBTTL	SESSION account message

;USSESS - ROUTINE TO SEND A IPCF MESSAGE TO THE ACCOUNTING DAEMON TO
;	DENOTE THE FACT THAT THIS USER HAS DONE A SESSION COMMAND.

USSESS:	PUSHJ	P,GETPAG	;GET A PAGE FOR IPCF MESSAGE
	MOVEI	T1,UGSES$	; T2 CONTAINS ADDRESS OF PAGE
	MOVEM	T1,US$TYP(T2)	;MESSAGE TYPE
	MOVE	T1,[SIXBIT /LOGIN/]
	MOVEM	T1,US$PRG(T2)	;PROGRAM NAME
	MOVE	T1,.JBVER	;VERSION NUMBER
	MOVEM	T1,US$VER(T2)
	HRLI	T1,U.ACTS	;NEW ACCOUNT STRING
	HRRI	T1,US$ACT(T2)
	BLT	T1,US$ACE(T2)
	PUSHJ	P,DATTIM
	MOVEM	T1,US$ACK(T2)	;UNIQUE MESSAGE IDENTIFIER
	MOVEM	T1,US$BEG(T2)	;SESSION START DATE/TIME
	HRLI	T1,U.RMRK	;NEW SESSION REMARK
	HRRI	T1,US$RMK(T2)
	BLT	T1,US$RME(T2)
	PUSHJ	P,USSEND	;SEND THE MESSAGE
	PUSHJ	P,USRWAT	;HAVE TO WAIT BECAUSE THE ACCOUNT DAEMON
				; GETTAB'S DYNAMIC DATA FOR USAGE ENTRY
	PJRST	USGCHK		;CHECK TO SEE IF MESSAGE A-OK
	SUBTTL	ATTACH accounting message

;USATTA - ROUTINE TO SEND AN IPCF MESSAGE TO THE ACCOUNTING DAEMON TO DENOTE
;	THE FACT THAT THE USER HAS TYPED AN ATTACH COMMAND AND MAY HAVE CHANGED
;	NODES AND/OR LINE NUMBERS.

USATTA:	PUSHJ	P,GETPAG	;GET A PAGE FOR IPCF SEND, T2 CONTAINS PAGE ADDRESS
	MOVEI	T1,UGATT$	;ATTACH MESSAGE TYPE
	MOVEM	T1,UA$TYP(T2)
	MOVE	T1,[SIXBIT /LOGIN/]
	MOVEM	T1,UA$PRG(T2)	;PROGRAM NAME
	MOVE	T1,.JBVER	;VERSION NUMBER OF LOGIN
	MOVEM	T1,UA$VER(T2)
	MOVE	T1,THSJOB	;GET THE JOB NUMBER
	PUSHJ	P,SETTNL	;FIND TERMINAL DESIGNATOR, LINE NO., NODE NAME
	MOVE	T1,MONLNO	;LINE NUMBER
	MOVEM	T1,UA$LIN(T2)	;STORE THE LINE NUMBER
	MOVE	T1,MONNOD	;NODE NAME
	MOVEM	T1,UA$NOD(T2)
	MOVE	T1,MONTDE	;TERMINAL DESIGNATOR
	MOVEM	T1,UA$TDE(T2)
	MOVE	T1,ATTJOB	;[754] Get target job
	MOVEM	T1,UA$TJN(T2)	;[754] 
	PUSHJ	P,DATTIM
	MOVEM	T1,UA$ACK(T2)	;UNIQUE MESSAGE IDENTIFIER
	PUSHJ	P,USSEND	;SEND THE MESSAGE
	PUSHJ	P,USRWAT	;WAIT
	PJRST	USGCHK		;CHECK TO SEE IF MESSAGE A-OK
	SUBTTL	Support routines
;GETPAG - ROUTINE TO CREATE A PAGE AND PUT ITS ADDRESS IN THE SEND/RECEIVE
;	ARGUMENT BLOCKS (IPS.BL AND IPR.BL). IT ALSO RETURNS THE PAGE ADDRESS IN T2

GETPAG:	MOVE	T1,.JBREL	;CREATE A PAGE
	ADDI	T1,1
	MOVE	T2,T1		;SAVE THE ADDRESS IN T2
	LSH	T1,-11		;CONVERT TO A PAGE NUMBER
	MOVEM	T1,PAGBLK+1	;STORE IN THE PAGE. ARGUMENT BLOCK
	MOVEM	T1,IPS.BL+.IPCFP ;SEND ARGUMENT BLOCK
	MOVEM	T1,IPR.BL+.IPCFP ;RECEIVE ARGUMENT BLOCK
	MOVEI	T1,1		;LENGTH OF ARGUMENT BLOCK
	MOVEM	T1,PAGBLK
	MOVE	T1,[.PAGCD,,PAGBLK]
	PAGE.	T1,
	  SKIPA
	POPJ	P,		;GOT THE PAGE
	STOP	PUE,<PAGE. UUO error for USAGE accounting>,EF.WTO

ZAPPAG:	TXO	T1,PA.GAF	;DESTORY A PAGE
	MOVEM	T1,PAGBLK+1	;STORE ARG
	MOVEI	T1,1		;LENGTH OF BLOCK
	MOVEM	T1,PAGBLK	;STORE
	MOVE	T1,[.PAGCD,,PAGBLK];FUNCTION
	PAGE.	T1,		;ZAP PAGE
	 JRST	LGNPUE		;FAILED
	POPJ	P,		;PAGE IS GONE

;USPIDW - ROUTINE TO SLEEP 5 SECONDS OR UNTIL THE ACCOUNTING DAEMON PID
;	EXISTS
;WATPID - WAIT FOR ACCOUNTING DAEMON TO START
WATPID:	MOVX	T1,%CNDBG	;GET DEBUGGIN STATUS WORD
	GETTAB	T1,		;FROM MONITOR
	 MOVEI	T1,0		;NONE I GUESS
	TXNN	T1,ST%DBG	;DEBUGGING?
	 JRST	WATPI1		;NO
	MOVE	T1,TTBITS	;GET TERMINAL BITS
	TXNN	T1,GL.REM!GL.RBS;REMOTE LINE?
	 POPJ	P,		;NO--GET HIM LOGIN W/O ACTDAE
WATPI1:	TLNN	F,FL.ATT	;ATTACHING?
	 JRST	WATPI2		;NO
	MOVX	T1,%SIACT	;FIND ACTDAE'S PID
	GETTAB	T1,		;..
	 MOVEI	T1,0		;ASSUME NOT THERE
	JUMPE	T1,WATPI2	;JUMP IF NO ACTDAE YET
	MOVX	T2,%IPCPM	;GET PID MASK
	GETTAB	T2,		;..
	 JRST	WATPI2		;WHAT?
	AND	T1,T2		;MASK TO FORM PIDTAB INDEX
	HRLZS	T1		;INDEX TO LH
	HRRI	T1,.GTPID	;POINT TO PIDTAB GETTAB
	GETTAB	T1,		;GET ITS PID ENTRY
	 JRST	WATPI2		;WHAT?
	AND	T1,T2		;MASK TO JOB NUMBER
	CAMN	T1,ATTJOB	;ATTACHING TO ACTDAE?
	 POPJ	P,		;YES! LET HIM GO W/O A HASSLE
WATPI2:	SETZB	T1,T2		;DONT WAIT
	PUSHJ	P,CHKPID	;SEE IF ACTDAE THERE
	 CAIA			;NO
	  JRST	.POPJ1##	;YES--RETURN NOW
	MOVE	T1,STATS2	;GET SECOND STATES WORD
	TXNN	T1,ST%ACV	;ACCOUNT VALIDATION REQUIRED?
	 POPJ	P,		;NO--LET HIM IN W/O ACTDAE
	MOVEI	T1,^D5		;TRY 5 TIMES
	MOVEI	T2,^D1		;WAITING 1 SECOND
	PUSHJ	P,CHKPID	;SEE IF ACTDAE THERE
	 CAIA			;NO
	  JRST	.POPJ1##	;YES--RETURN NOW
	PUSHJ	P,CHKOPR	;SEE IF OPR AND WE CAN LET HIM IN
	 POPJ	P,		;YES
	INFO	WFA,<Waiting for accounting daemon to start>
	MOVEI	T1,^D30		;TRY 30 TIMES
	MOVEI	T2,^D10		;WAITING 10 SECONDS
	PUSHJ	P,CHKPID	;SEE IF ACTDAE THERE
	 CAIA			;NO
	  JRST	.POPJ1##	;YES--RETURN NOW
	STOP	ADN,<Accounting daemon not running>,EF.WTO;NO--FINALLY DIE

;CHKPID - ROUTINE TO CHECK AND WAIT FOR ACTDAE PID
;T1/ TIMES TO TRY   T2/ SECONDS TO SLEEP IN BETWEEN

CHKPID:	MOVX	T3,%SIACT	;PID OF ACTDAE
	GETTAB	T3,		;ASK MONITOR
	 POPJ	P,		;SURELY NOT THERE
	JUMPN	T3,[MOVEM T3,ACTPID	;HES THERE--SAVE HIS PID
		    JRST  .POPJ1##]	;AND SKIP RETURN
	SOJLE	T1,.POPJ##	;COUNT DOWN
	SLEEP	T2,		;ZZZZ
	JRST	CHKPID		;AND TRY AGAIN

;CHKOPR - SEE IF [1,2] AND NO ACCOUNT STRING. READ THE SYSTEM DEFAULT
;AND USE THAT IF WE CAN

CHKOPR:	MOVE	T1,PPN		;GET PPN
	CAME	T1,ALPPPN	;OPR?
	 JRST	.POPJ1##	;NO--BETTER WAIT
	MOVE	T1,U.ACTS	;GET ACCOUNT STRING
	CAME	T1,[-1]		;SEE IF SPECIFIED
	 JUMPN	T1,.POPJ1##	;YES--BETTER WAIT
	MOVE	T1,[.ACTRD,,T2]	;READ ACCOUNT STRING
	MOVEI	T2,2		;2 ARGS
	MOVEI	T3,0		;NULL JOB (SYSTEM DEFAULT)
	MOVEI	T4,U.ACTS	;INTO OUR ACCOUNT STRING
	ACCT.	T1,		;DO IT
	 JFCL			;CANT SAY WE DIDNT TRY
	POPJ	P,		;AND LET HIM IN

;SETTNL - SUBROUTINE TO SET UP TERMINAL DESIGNATOR, NODE NAME AND LINE NUMBER
;	FOR THE JOB IN T1.  STORES VALUES IN MONTDE, MONLNO, AND MONNOD WHICH
;	IS WHERE THE ROUTINES USLOGN AND USATTA WOULD LIKE TO FIND THEM.
;USES T1-T4

SETTNL:	PUSHJ	P,.PSH4T##	;SAVE TEMPS
	MOVSI	T4,(ASCIZ/D/)	;ASSUME DETACHED
	TRMNO.	T1,		;GET TERMINAL DESIGNATOR
	  JRST	SETTN1		;DETACHED
	DPB	T1,[POINT 9,MONLNO,35] ;STORE IN CASE NO NETWORKS
	GETLCH	T1		;GET LINE CHARACTERISTICS
	MOVSI	T4,(ASCIZ/T/)	;ASSUME REGULAR TTY
	TXNE	T1,GL.CTY	;THE SYSTEM CTY
	MOVSI	T4,(ASCIZ/C/)	;YES
	TXNE	T1,GL.ITY	;INVISIBLE (PSEUDO) TTY
	MOVSI	T4,(ASCIZ/P/)	;YES
	HRRZS	T1		;GET RID OF GETLCH BITS
	GTNTN.	T1,		;CONVERT TO NODE AND LINE
	  JRST	SETTN1		;NO NETWORKS
	HRRZM	T1,MONLNO	;STORE REAL LINE NUMBER
	HLRZ	T3,T1		;ISOLATE NODE NUMBER
	HRRI	T2,2		;NUMBER OF ARGUMENTS
	MOVE	T1,[.NDRNN,,T2]	;RETURN NODE NAME FOR NUMBER
	NODE.	T1,		;ASK TODD
	  SKIPA			;FAILED?
	MOVEM	T1,MONNOD	;STORE SIXBIT NODE NAME
SETTN1:	MOVEM	T4,MONTDE	;STORE TERMINAL DESIGNATOR
	PUSHJ	P,.POP4T##	;RESTORE TEMPS
	POPJ	P,		;AND RETURN

;DATTIM - ROUTINE TO GETTAB THE INTERNAL DATE AND TIME (%CNDTM) AND STORE IT
;	IN ACTACK SO IPCF MESSAGES AND THEIR RESPONSES CAN BE SYNCRONIZED AND
;	ALSO ENSURE SYSTEM SECURITY AND ACCOUNTING DATA INTEGRITY.
;	RETURNS THE DATE/TIME WORD IN T1

DATTIM:	MOVX	T1,%CNDTM
	GETTAB	T1,
	  MOVEI	T1,0		;CAN'T HAPPEN
	MOVEM	T1,ACTACK	;SAVE IT AS A UNIQUE NUMBER
	POPJ	P,
	SUBTTL	IPCF message routines

;ROUTINE TO SEND A PAGE TO THE ACCOUNTING DAEMON.
USSEND:	MOVX	T1,IP.CFV	;SEND A PAGE
	IORM	T1,IPS.BL+.IPCFL
	MOVE	T1,ACTPID
	MOVEM	T1,IPS.BL+.IPCFR
	MOVEI	T1,1000
	HRLM	T1,IPS.BL+.IPCFP
	MOVE	T1,[4,,IPS.BL]
	IPCFS.	T1,
	  CAIA		;ERROR
	POPJ	P,
	STOP	ISF,<IPCF send failed for USAGE accounting>,EF.WTO

;ROUTINE TO WAIT FOR IPCF MESSAGE
USRWAT:	PUSHJ	P,USRECV	;TRY TO RECIEVE A MESSAGE
	 CAIA			;NONE THERE
	  POPJ	P,		;GOT IT
	MOVEI	T1,^D10*^D1000	;WAIT 10 SECONDS
	TXO	T1,HB.IPC	;WAITING FOR IPCF MESSAGE
	HIBER	T1,		;ZZZ
	 JFCL			;OH WELL
	PUSHJ	P,USRECV	;TRY TO GET IT NOW
	 CAIA			;NONE THERE
	  POPJ	P,		;GOT IT
	INFO	WFR,<Waiting for response from accounting daemon>
	MOVEI	T4,^D10		;WAIT 10 TIMES
USRWA1:	MOVEI	T1,^D60*^D1000	;OF A MINUTE EACH
	TXO	T1,HB.IPC	;WAITING FOR IPCF MESSAGE
	MOVEI	T2,^D60		;IN CASE HIBER FAILS
	HIBER	T1,		;ZZZ
	 SLEEP	T2,		;NOT GOOD, BUT TRY
	PUSHJ	P,USRECV	;TRY TO GET IT NOW
	 CAIA			;NONE THERE
	  POPJ	P,		;GOT IT
	SOJG	T4,USRWA1	;WAIT AGAIN
	STOP	NRF,<No response from accounting daemon>,EF.WTO

;ROUTINE TO RECEIVE A PAGE.
USRECP:	HRRZ	T1,IPR.BL+.IPCFP;[754] GET PAGE WE RECEIVED
	PUSHJ	P,ZAPPAG	;[754] GET RID OF IT
USRECV:	MOVX	T1,IP.CFV!IP.CFB ;NON-BLOCKING RECEIVE OF A PAGE
	IORM	T1,IPR.BL+.IPCFL
	MOVEI	T1,1000
	HRLM	T1,IPR.BL+.IPCFP
	MOVE	T1,[6,,IPR.BL]	;IPCF RECEIVE ARGUMENT LIST
	IPCFR.	T1,		;RECEIVE A PACKET
	 CAIA			;ERROR
	  JRST	USREC1		;RECEIVE OK
	CAIN	T1,IPCNP%	;NO PACKET ERROR?
	 POPJ	P,		;YES--NONSKIP RETURN
	CAIE	T1,IPCPR%	;IS IT A NOT A PAGE?
	 JRST	LGNIRF		;NO, WHOOPS
	MOVX	T1,IP.CFT	;[754] TRUNCATE MESSAGE TO ZERO LENGTH
	MOVEM	T1,IPR.BL+.IPCFL;STORE THAT
	HRRZS	IPR.BL+.IPCFP	;[754] INDICATE ZERO LENGTH ARG
	IPCFR.	T1,		;PITCH THE PACKET
	 JRST	LGNIRF		;SHOULDN'T HAPPEN
	JRST	USRECV		;RECEIVE ANOTHER PACKET
USREC1:	LDB	T1,[POINTR IPR.BL+.IPCFL,IP.CFM];[754] GET TURNAROUND CODE
	CAIN	T1,.IPCFN	;[754] A TURNED AROUND MESSAGE?
	 JRST	LGNADN		;YES--ACTDAE MUST HAVE DIED
	LDB	T1,[POINTR IPR.BL+.IPCFL,IP.CFE];[754] GET ERROR FIELD
	JUMPN	T1,USRECP	;[754] PITCH IT IF IN ERROR
	HRRZ	T1,IPR.BL+.IPCFP
	LSH	T1,11		;GET THE ADDRESS OF THE MESSAGE
	MOVE	T2,UC$ACK(T1)	;GET THE UNIQUE IDENTIFIER
	CAME	T2,ACTACK	;IS THIS THE ANSWER TO THE MESSAGE WE SENT?
	 JRST	USRECP		;[754] NO--KEEP RECEIVING UNTIL WE GET AN ANSWER
	JRST	.POPJ1##	;YES--GOOD RETURN


	STOP	IRF,<IPCF receive failed for USAGE accounting>,EF.WTO

;USGCHK - ROUTINE TO CHECK IF RESPONSES TO IPCF SENDS ARE TRUE OR FALSE.

USGCHK:	HRRZ	T1,IPR.BL+.IPCFP ;GET THE PAGE ADDRESS OF THE DATA
	LSH	T1,11		;CONVERT TO AN ADDRESS
	MOVE	T2,UC$RES(T1)	;GET THE RESPONSE TO THE VALIDATION MESSAGE
	CAIN	T2,UGTRU$	;IS IT A VALID ACCOUNT FOR THIS PPN?
	POPJ	P,		;YES. RETURN
	MOVEI	T1,UC$ERR(T1)		;GET THE ASCIZ ERROR MESSAGE
	FATAL	ACT,<Accounting error: >,EF.FMT,.TSTRG##
> ;END OF IFN FTUSAG
	PRGEND
	TITLE	LGNDSK - Directory logic for LOGIN

	SEARCH	UUOSYM,MACTEN,SCNMAC,LGNUNV,ACTSYM,UFDPRM
	LGNDCL


SUBTTL CHKJSP - check If ATTACH Preferred Over LOGIN

;07-Apr-78/RNH
;Subroutine to see if there are any detached jobs around with the
;same PPN as the one to which this job is trying to log in and
;to give the user the opportunity to attach to one if (s)he so
;desires.  Called by:
;
;	PUSHJ	P,CHKJSP	;Check for detached jobs with same PPN
;	always return here, flags may be different if ATTACH preferred
;
;AC's are vulnerable except P1 through P4.
;
;Apologies to CHKWLD routine in LGNDSK, but to fix it up seemed too
;much a kludge.

CHKJSP::TLNN	F,FL.WLD	;User want unique PPN?
	 TDNE	F,[FL.ATT,,R.SESS] ; or already trying to attach or SESSION?
	  POPJ	P,		;Yes, then this code is pointless
	MOVE	T1,U.ATT	;DID USER TYPE /ATTACH?
	CAIN	T1,ATTIGN	;DID THE USER TYPE IGNORE?
	POPJ	P,		;YES. DON'T PROMPT
	MOVE	T2,PPN		;
	MOVE	T1,TTBITS	;If one disallows PTY's
	TXNN	T1,GL.ITY	; then one unkludges CTL and ATO files
	 CAMN	T2,ALPPPN	;Prevent confusion by preventing OPR, too
	  POPJ	P,		;Exclude such situations

	MOVEI	T1,[ASCIZ /LOGIN or ATTACH preference/]  ;
	MOVEM	T1,HELP		;Supply time-out with a message

	PUSHJ	P,.SAVE4##	;Using preserved AC's
	MOVX	P1,%NSHJB	;Get highest job number to check
	GETTAB	P1,		;
	 MOVEI	P1,^D200		;Use reasonable default on error
	MOVNS	P1		;Form AOBJN pointer to step through jobs
	HRLZS	P1		;
	HRRI	P1,1		;Skip job 0
	MOVEI	P2,0		;Indicate no jobs found yet
;Next page has the main loop for checking jobs and user response.
CJSP1:	HRRI	T1,.GTPPN	;Check a job's PPN
	HRLI	T1,(P1)		;
	GETTAB	T1,		;
	 JRST	CJSP3		;No check if can't get PPN
	CAME	T1,PPN		;PPN matches one for logging in?
	 JRST	CJSP3		;No, on to next job
	HRRZI	T1,(P1)		;Matches, but there are still questions
	CAMN	T1,THSJOB	;Dealing with our own job?
	 JRST	CJSP3		;Yes, skip rest of loop
	TRMNO.	T1,		;Find if detached by getting its TTY
	 CAIE	T1,0		;Zero on error return sez detached
	  JRST	CJSP3		;Non-zero or good return sez not useful
	HRLZI	T1,(P1)		;JOB NUMBER
	HRRI	T1,.GTDFL	;GET DEFAULT
	GETTAB	T1,		;FIND OUT IF USER WANTED TO BE ASKED
	  MOVEI	T1,0		;ALWAYS DEFAULT TO ASK THE USER
	TXNE	T1,JD.DAD	;DOES THIS JOB WANT TO PROMPT?
	 JRST	CJSP3		;NO. CONTINUE THE LOOP
	MOVEI	T1,[ASCIZ /Other jobs detached with same PPN:
/]				;
	CAIN	P2,0		;Any found yet?
	 PUSHJ	P,.TSTRG##	;No, Type the header
	MOVEI	T1,(P1)		;Copy job number
	PUSHJ	P,DETSTS	;Show his job status
	ADDI	P2,1		;Count jobs found
	MOVEI	P3,(P1)		;Save the job (in case only one)
CJSP3:	AOBJN	P1,CJSP1	;Loop through all jobs
	JUMPE	P2,.POPJ##	;Return if no jobs found
CJSP2:	SOJN	P2,CJSP6	;Jump if more than one found
	MOVEI	P2,(P3)		;Save found job
	MOVEI	T1,0		;No switches
	MOVE	P1,.OPTN##	;Save /OPTION
	PUSH	P,.FLVRB##	;Save /MESSAGE
	PUSHJ	P,.PSCAN##	;Initialize 
	 PUSHJ	P,[MOVEI T1,[ASCIZ/Do you want to ATTACH to this job? [Y] /];Get text
		   PJRST TTYPMT##] ;and type
	MOVEM	P1,.OPTN##	;Restore /OPTION
	POP	P,.FLVRB##	;Restore /MESSAGE
	PUSHJ	P,.SIXSW##	;Read a sixbit word
	JUMPG	C,E.INCL##	;Error if not EOL
	JUMPE	N,CJSP7		;<CR> means YES
	MOVE	T1,[IOWD YNLEN,YNTAB];Point to answers
	PUSHJ	P,.NAME##	;Check them out
	 JRST	E.UKK##		;Error
	MOVEI	T1,-YNTAB(T1)	;Form index
	JUMPN	T1,.POPJ##	;Return if NO
CJSP7:	MOVEI	N,(P2)		;Get the found job
	JRST	CJSP8		;and join processing

CJSP6:	MOVEI	T1,0
	MOVE	P1,.OPTN##	;Save /OPTION
	PUSH	P,.FLVRB##	;Save /MESSAGE
	PUSHJ	P,.PSCAN##	;
	 PUSHJ	P,[MOVEI T1,[ASCIZ /Type job number to ATTACH or carriage-return to LOGIN new job: /]	;
		   PJRST TTYPMT##] ;Type it
	MOVEM	P1,.OPTN##	;Restore /OPTION
	POP	P,.FLVRB##	;Restore /MESSAGE
	PUSHJ	P,.DECNW##	;Read decimal number
	JUMPG	C,E.INCL##	;Error if not EOL
	JUMPE	N,.POPJ##	;Assume LOGIN if none given
;Here with N=job to try to ATTACH to
CJSP8:	HRRI	T1,.GTPPN	;Got one, check if legit
	HRLI	T1,(N)		;
	GETTAB	T1,		;
	 JRST	CJSP5		;
	CAME	T1,PPN		;Check again for PPN match
	 JRST	CJSP5		;
	HRRZI	T1,(N)		;
	TRMNO.	T1,		; and DETACHed status
	 JUMPE	T1,CJSP4	;Zero on error sez detached
CJSP5:	MOVEI	T1,[ASCIZ /?LGNCAJ Can't ATTACH to that job
/]	;
	PUSHJ	P,.TSTRG##	;
	JRST	CJSP6		;
;Here to proceed to ATTACH to the job
CJSP4:	TLO	F,FL.ATT	;From now on, we're attaching to a job
	HRRZM	N,ATTJOB	;Set things up as ATTACH command
	SETOM	NOWBIT		;
	MOVEI	T1,[ASCIZ /.ATTACH /]	;Give a reassuring ATTACH message
	PUSHJ	P,.TSTRG##	;
	HRRZI	T1,(N)		;
	PUSHJ	P,.TDECW	;
	MOVE	T1,PPN		;
	PUSHJ	P,.TPPNW##	;
	PJRST	NEWLIN

YNTAB:	SIXBIT	/YES/
	SIXBIT	/NO/
YNLEN==.-YNTAB
;DETSTS - Type job status
DETSTS:	PUSHJ	P,.SAVE1##	;Save P1
	MOVEI	P1,(T1)		;Copy job number
	MOVEI	T1,[ASCIZ/  Job /];Get text
	PUSHJ	P,.TSTRG##	;Type
	MOVEI	T1,(P1)		;Get job number
	PUSHJ	P,.TDECW##	;Type
	PUSHJ	P,.TSPAC##	;Space
	HRLZI	T1,(P1)		;Get job number
	HRRI	T1,.GTPRG	;Get program name
	GETTAB	T1,		;Ask monitor
	 MOVEI	T1,0		;Not today
	PUSHJ	P,.TSIXN##	;Type program name
	MOVEI	T1,(P1)		;Get job number
	MOVNS	T1		;Setup for JOBSTS
	JOBSTS	T1,		;Find state
	 JRST	DETS.1		;Cant
	TXNE	T1,JB.URN	;Running?
	 SKIPA	T1,[[ASCIZ/ running/]];Yes
	  MOVEI	T1,[ASCIZ/ stopped/];No
	PUSHJ	P,.TSTRG##	;Type
DETS.1:	PUSHJ	P,.TCRLF##	;Finish off
	POPJ	P,		;And return
	SUBTTL	Turn on echo, diddle some bits

;HERE IF ALL TYPEINS NEEDED TO LOGIN ARE VALIDATED

PSWOK:	TLNE	F,FL.FDX	;SKIP IF HALF DUPLEX
	PUSHJ	P,TTYECH##	;SET TTY ECHO
	PUSHJ	P,CHKJSP	;Check for detached jobs/same PPN and
				;set FL.ATT if user prefers to attach
	TLNE	F,FL.ATT	;ENOUGH IF ATTACH
	JRST	ACCT		;DONT NEED TO SET UP UFD'S, ETC.
	TRNE	F,R.SESS	;IF SESSION COMMAND, NEED TO CHECK FOR
	JRST	[PUSHJ	P,SW.INI	;ACCOUNTS AND REMARKS
		JRST ACCT]
	MOVE	T1,ENTRY+.ACPRV	;AND PRIV WD
	MOVEM	T1,PRIVWD	;STORE PRIV WORD
	MOVE	T1,ENTRY+.ACCNO
	MOVEM	T1,CHGNO	;CHARGE NUMBER
	PUSHJ	P,GLXSET	;SETUP GALAXY SETUUOS
	CLOSE	UFD,0		;NOW CLEAR SOME IO
	SETZB	T3,RDHED	;..
	SUBTTL	Build scheduler table

CHKJOB:	TLNN	F,FL.WLD	;WILDCARD PROGRAMMER NUMBER?
	JRST	CHKJ.1		;NO
	HLLZS	T1,PPN		;MAKE SURE NO JUNK IN RH
	MOVEM	T1,.MYPPN##	;TELL SCAN
	TLO	F,FL.GPN	;REMEMBER TO TELL UFDSET TO GENERATE A PPN
	JRST	NOTHER		;ONWARD - LET UFDSET FIX UP PPN

CHKJ.1:	SETOM	RDUFLG		;INIT RECOMP TYPEOUT FLAG
	MOVE	T1,PPN		;GET OUR PPN
	MOVEM	T1,.MYPPN##	;TELL SCAN
	CHGPPN	T1,		;CHANGE TO OUR PPN NOW
	  JRST	NOTHER		;NOT IMPLEMENTED
	GETPPN	T1,		;DONT CARE ABOUT OTHER USERS,
	  JRST	NOTHER		;BUT WOULD TELL IF OTHERS SAME PPN
	INFO	JSP,<Other jobs same PPN>,,E.JSP
	JRST	NOTHER		;AND CHARGE ON

E.JSP:	MOVE	T1,PPN		;GET PPN
	CAMN	T1,ALPPPN	;IS IT [1,2]?
	 POPJ	P,		;YES--SKIP THIS STUFF
	PUSHJ	P,.TCOLN##	;TYPE A COLON
	MOVX	T1,%NSHJB	;GET HGHJOB
	GETTAB	T1,		;WITH A GETTAB
	 POPJ	P,		;NOT LIKELY, BUT..
	MOVN	T1,T1		;NEGATE IT
	HRLZ	P2,T1		;MAKE P2 AN AOBJN POINTER
	AOS	P2		;DON'T BOTHER WITH THE NULL JOB
JOBLUP:	HRRI	T1,.GTPPN	;CODE FOR JBTPPN TABLE
	HRL	T1,P2		;GET JOB NUMBER TO TRY
	GETTAB	T1,		;GET HIS PPN
	  SETZ	T1,		;AGAIN NOT LIKELY, BUT
	CAME	T1,PPN		;IS HE UNDER THIS GUY'S PPN?
	  JRST	LUPER		;NO - KEEP LOOKING
	HRRZ	T2,P2		;GET JOB NUMBER
	CAMN	T2,THSJOB	;THIS JOB?
	  JRST	LUPER		;YES - HE KNOWS ABOUT THIS ONE
	TROE	F,R.COMA	;COMMA TYPED YET?
	PUSHJ	P,.TCOMA##	;TYPE A COMMA
	HRRZ	T1,P2		;GET JOB NUMBER
	PUSHJ	P,.TDECW##	;LET SCAN DO THE TYPING
LUPER:	AOBJN	P2,JOBLUP	;KEEP CHECKING
	POPJ	P,		;AND RETURN FROM PRINTING


NOTHER:	SKIPL	EQACT		;[425] 6.02-STYLE ACCT.SYS?
	JRST	CHECK1		;[425] NO
	MOVE	T1,STATS2	;[425] GET 2ND STATES WORD
;**;[1102] at NOTHER plus 3 delete 1 line
	TXNN	T1,ST%NCS	;[632] SKIP THIS IF 6.03 SCHEDULER IN WMU MODE
	TXNN	T1,ST%SHC	;[425] DOES MONITOR HAVE SCHED. UUO?
	JRST	CHECK1		;[425] NO -- DON'T WASTE TIME HERE
	PUSHJ	P,CLRRIB	;[540] CLEAR LOOKUP BLOCK
	MOVEI	T1,.RBTIM	;[540] GET ARGUMENT COUNT
	MOVEM	T1,SECBUF+.RBCNT;[540] STUFF IT
	MOVE	T1,[SIXBIT .SCDMAP.]
	MOVEM	T1,SECBUF+.RBNAM;[540] STUFF INTO LOOKUP BLOCK
	MOVSI	T1,(SIXBIT .SYS.)
	MOVEM	T1,SECBUF+.RBEXT;[540]
	MOVE	T1,SYSPPN	;[540] GET A GOOD PPN
	MOVEM	T1,SECBUF+.RBPPN;[540] AND USE IT
	SETZM	RDHED		;[425] FORCE FIRST READ TO INPUT
	LOOKUP	UFD,SECBUF	;[425] IS IT THERE?
	  JRST	[WARN CFS,<Can't find SCDMAP.SYS>,EF.WTO
		JRST	NSCHED]	;[425] CAN'T GET AT SCDMAP.SYS
	SKIPE	SCDBLT		;[540] HAS TABLE BEEN BUILT YET?
	  JRST	BILDIT		;[540] NO - BUILD IT
	MOVE	T1,SECBUF+.RBTIM;[540] YES - SEE WHEN SCDMAP WAS CREATED
	CAMN	T1,W.SCED	;[540] SAME ONE?
	  JRST	CHECK1		;[540] YES - USE CURRENT TABLE
BILDIT:	SKIPL	BLDSCD		;[540] IS BUILD IN PROGRESS?
	  JRST	BUILD		;[556] NO - BUILD IT NOW
	PUSHJ	P,ZZZZ		;[540] YES - TAKE A NAP
	  JRST	CHECK1		;[540] TABLE BUILT BY SOMEONE ELSE

;	20-SEP-79/BAH CORE UUO TO EXPAND HIGH SEGMENT CAN FAIL IF 1) SOMEONE
;	IS SAVING LOGIN OR IF 2) IN AN SMP ENVIRONMENT, ANOTHER CPU IS
;	EXECUTING THE SAME CODE WITH THE HIGH SEGMENT WRITE-ENABLED.
;	TO GIVE THE MONITOR TIME TO CATCH UP, SLEEP A SECOND AND TRY AGAIN
;	(3 TIMES) IF THE CORE UUO FAILS.


BUILD:	MOVEI	T3,3		;SET UP A COUNT FOR CORE UUO'S
BUILD1:	MOVE	T2,DACCL	;[556] GET SIZE OF ACCT.SYS
	LSH	T2,1		;[425] DOUBLE IT BECAUSE 2 TABLES
	ADD	T2,PDACC	;[425] ADD BASE ADDRESS OF TABLES
	ADDI	T2,SCDSIZ	;[425] ADD SIZE OF SCHED. TABLE
	HRRZ	T1,.JBHRL	;[425] GET HIGHEST ADR IN HI SEG
	CAMG	T2,T1		;[425] ENOUGH ROOM?
	  JRST	ENUF		;[425] YES -- PLOW ON
	HRLZ	T1,T2		;[425] NO -- SET UP TO EXPAND HI SEG
	CORE	T1,		;[425] GET BIGGER
	  JRST	[SOJLE	T3,LGNCUF	;TRIED 3 TIMES--REPORT CORE UUO FAILED
		MOVEI	T1,1		;SLEEP FOR A SECOND
		SLEEP	T1,
		JRST	BUILD1]		;TRY THE CORE UUO AGAIN
ENUF:	PUSHJ	P,LOK		;[444] WRITE-ENABLE HI SEG, LOCK OUT CTRL-C
	SUBI	T2,SCDSIZ	;[425] MAKE BASE ADDRESS OF TABLE
	MOVEM	T2,SCDTBL	;[425] SAVE ADDR OF SCHED CLASS TABLE
	HRLI	T2,-SCDSIZ	;[425] MAKE AN AOBJN POINTER
	SETOM	BLDSCD		;[425] FLAG BUILD IN PROGRESS


SCDLUP:	PUSHJ	P,RDUFD		;[425] GET A WORD
	  JRST	[WARN PEF,<Premature EOF reading SCDMAP.SYS>,EF.WTO
		JRST	RSCHED]	;[425] 
	MOVEM	WD,(T2)		;[425] STORE WORD IN TABLE
	AOBJN	T2,SCDLUP	;[425] AND GO AGAIN

	SETZM	BLDSCD		;[425] FLAG BUILD NOT IN PROGRESS
	SETZM	SCDBLT		;[425] FLAG TABLE BUILT
	CLOSE	UFD,0		;[425] ALL DONE
	MOVE	T1,SECBUF+.RBTIM;[540] GET CREATION DATE-TIME OF SCDMAP
	MOVEM	T1,W.SCED	;[540] SAVE IN HI-SEG
	PUSHJ	P,UNLOCK	;[444] UNLOCK THIS CODE
	JRST	CHECK1		;[425] GO DO AUXACC.SYS STUFF

RSCHED:	CLOSE	UFD,0
	SETZM	BLDSCD		;[425] FLAG BUILD NOT IN PROGRESS
	SETOM	SCDBLT		;[425] FLAG TABLE NOT BUILT
	PUSHJ	P,UNLOCK	;[444] UNLOCK THIS CODE
NSCHED:	MOVX	T1,ST%SHC	;[516] SOMETHING BROKE SO PRETEND
	ANDCAM	T1,STATS2	;[425] NO SCHED. UUO
	JRST	CHECK1		;[425] MOVE ON

ZZZZ:	MOVEI	T1,^D60		;[425] WAIT ONE MIN. THEN REBUILD
	SKIPL	SCDBLT		;[433] TABLE BUILT YET?
	POPJ	P,		;[425] YES -- NON-SKIP RETURN
	MOVEI	T2,1		;[425] SLEEP ONE SECOND
	SLEEP	T2,
	SOJG	T1,ZZZZ+1	;[425] WAIT ONE MINUTE
	AOS	(P)		;[425] THEN SKIP RETURN TO 
	POPJ	P,		;[425] REBUILD TABLE


	SUBTTL	Search AUXACC.SYS

CHECK1:	PUSHJ	P,CLRRIB	;[540] CLEAR LOOKUP BLOCK
	MOVEI	T1,.RBTIM	;[540] GET ARG COUNT
	MOVEM	T1,SECBUF+.RBCNT;[540] SALT AWAY
	MOVE	T1,[SIXBIT .AUXACC.]
	MOVEM	T1,SECBUF+.RBNAM;[540] SET UP NAME
	MOVSI	T1,(SIXBIT .SYS.)
	MOVEM	T1,SECBUF+.RBEXT;[540] AND EXTENSION
	MOVE	T1,SYSPPN	;[540] GET SYS: PPN
	MOVEM	T1,SECBUF+.RBPPN;[540] ..
	SETZM	RDHED		;[540]
	LOOKUP	UFD,SECBUF	;[540] LOOK FOR AUXACC.SYS
	  JRST	NOAUXA		;NOPE
	TLZ	F,FL.ACC	;NOTE READING AUXACC.SYS NOW
IFN	FASTLG,<
	SKIPN	DAUXFL		;[540] AUX TABLE BUILT YET?
	  JRST	BLDAUX		;[540] NO - BUILD IT NOW
	MOVE	T1,SECBUF+.RBTIM;[540] CREATION DATE-TIME OF AUXACC
	CAMN	T1,W.AUX	;[540] CHANGED SINCE LAST TIME?
	  JRST	LUKAUX		;[540] NO - WE'RE ALL SET
>;END FASTLG COND
BLDAUX:	PUSHJ	P,RDUFD		;[540] READ 1ST WORD, CONTAINS FORMAT VERSION NUMBER
	  JRST	NOAUXA		;NOT THERE?
	HLRZ	WD,WD		;[403] WD=FORMAT VERSION NUMBER
	CAIN	WD,AC1FOR
	  JRST	AXFMOK
	STOP	BFA,<Bad format in AUXACC.SYS>,EF.WTO
AXFMOK:	IFE	FASTLG,<
	HLRE	T1,T4
	JUMPGE	T1,.+2		;IF +, NO OF BLOCKS, ELSE WORDS
	IDIV	T1,[-^D128]	;APPROXIMATION OF POSITION IN FILE BASED
	IMUL	T1,ACCKNT	;ON POSITION OF USER IN ACCT.SYS
	IDIV	T1,ACCTLN	;BLOCKS READ IN ACCT*LENGTH AUXACC/LENGTH ACCT
	SKIPN	T1
	MOVEI	T1,1		;A MUST BE AT LEAST 1
	CAIN	T1,1
	JRST	ACC1A
	SETZM	RDHED		;IF NOT 1ST BLOCK, FORCE NEW INPUT
	>			;[556] END OF IFE FASTLG
	IFN	FASTLG,<
	PUSHJ	P,LOK		;[444] LOCK OUT OTHER MODIFIERS
	MOVE	T1,ACCKNT	;ACCT.SYS POSITIION
	MOVEM	T1,SAVKNT	;PROTECT TEMPORARILY
	SETZM	ACCKNT
	TLO	F,FL.ACC	;LIES: IT ENABLES COUNTING ON AUXACC
	MOVN	T1,DACCL	;LENGTH OF ACCT.SYS
	HRLZ	T1,T1		;[403] FOR AOBJN
	ADD	T1,PDACC	;[403] SETUP POINTER
	MOVE	T2,DACCL	;[403] FOR AUXACC.SYS TABLE
	HRLI	T2,T1		;INDIRECT POINTER TO DACC+DACCL 
				;INDEXED BY A
;STILL IN FASTLG COND
AUXSCN:	PUSHJ	P,RDUFD
	  JRST	AUXEND		;END OF FILE
	AOJN	WD,AUXSCN	;SCAN FOR -1 (BEGIN OF ENTRY FLAG)
	PUSHJ	P,RDUFD		;GET AND IGNORE ENTRY LENGTH
	  JRST	AUXEND
	PUSHJ	P,RDUFD		;GET PPN
	  JRST	AUXEND
AUXSC1:	CAMGE	WD,0(T1)	;[403] IS THIS PPN .GE. THAT IN DACC TABLE?
	JRST	AUXSCN		;NO, GO GET NEXT
	MOVE	T3,ACCKNT	;[403] PICK UP CURRENT BLOCK NO
	MOVEM	T3,@T2		;[403] STORE IN FREE TABLE LOCATION
	AOBJN	T1,AUXSC1	;[403] GO FOR MORE IF ROOM
AUXDUN:	TLZ	F,FL.ACC	;DISABLE BLOCK COUNTING
	MOVE	T1,SAVKNT	;GET POINTER INTO ACCT.SYS
	MOVEM	T1,ACCKNT	;RESTORE COUNTER
	SETOM	DAUXFL		;INDICATE TABLE OK
	MOVE	T1,SECBUF+.RBTIM;[540] GET CREATION DATE-TIME OF AUXACC
	MOVEM	T1,W.AUX	;[540] SAVE IN HI SEG
	PUSHJ	P,UNLOCK	;[444] UNLOCK THE HI SEG
LUKAUX:	MOVE	T1,ACCKNT	;WHERE WERE WE IN ACCT.SYS?
	ADD	T1,DACCL	;CORRECT ADDRESS IN AUX TABLE
	ADD	T1,PDACC	;POINT INTO TABLE
	MOVE	T1,0(T1)	;[731][730] PICK UP AUX BLOCK
	AOJLE	T1,LGNHMU	;[511] SHOULDN'T NEVAH BE NEG
	>			;[556] END IFN FASTLG
;We have now read (if necessary) AUXACC.SYS and have an appropriate pointer
;into the file.  The following code was revised (ed.716) so that the 
;scheme of things is as follows:
;	1)  Find the entry for this user and read it one structure
;	    at a time.
;	2)  During this initial pass, remember the structure name/quotas/etc.
;	    but merely put the structure in the search list.
;	3)  with the search list set up, go read SWITCH.INI and do any
;	    final user interaction (account validation, etc.).
;	4)  If all is well and it's truly OK to LOGIN, loop through
;	    up UFDs and SFDs with the proper quotas and the proper
;	    protections, etc.  Also turn on STRUCTURE-IN-USE bit and
;	    do any needed recomps.

ACC1E:	USETI	UFD,(T1)
	SETZM	RDHED		;FORCE READ OF THAT BLOCK
ACC1A:	PUSHJ	P,RDUFD		;NOW TRY TO FIND START OF ENTRY
	  JRST	BACKUP		;TOO FAR, BACK UP 1
	AOJN	WD,ACC1A	;ALL ONES (-1) STARTS ENTRY
	PUSHJ	P,RDUFD		;READ LENGTH OF ENTRY
	  JRST	BACKUP
	MOVNI	P2,-1(WD)
	PUSHJ	P,RDUFD		;READ PPN
	  JRST	BACKUP
	CAMLE	WD,PPN		;PASSED USER?
	JRST	BACKUP		;YES, BACK UP 1 BLOCK
ACC1F:	CAME	WD,PPN		;THIS USER?
	JRST	SKACC1		;NO, READ FORWARD TO FIND HIM
ACC1G:	JUMPGE	P2,NOSTR	;JUMP IF NO STR'S FOR THIS USER
	MOVEM	P2+1,SAVERG	;SAVE RANDOM REGISTER
	IDIVI	P2,AC1BLK	;DIVIDE BY SIZE OF EACH BLOCK IN ENTRY
	MOVE	P2+1,SAVERG	;RESTORE REG WIPED BY DIVIDE
	TRZ	F,R.ACRE!R.ASTR	;CLEAR ANY CREATE AND ANY STR FLAGS
	SETZ	P1,		;Clear index into stash area
ACC1B:	PUSHJ	P,RDUFD		;READ NEXT FILE STRUCTURE NAME
	  JRST	ACC1J
	MOVE	M,WD		;M=STR NAME FOR UFDSET
	PUSHJ	P,RDUFD		;RESERVED QUOTA
	  JRST	ACC1J
	MOVE	T2,WD		;T2=RESERVED QUOTA FOR UFDSET
	PUSHJ	P,RDUFD		;FIRST COME, FIRST SERVED QUOTA
	  JRST	ACC1J
	MOVE	T3,WD		;T3=FCFS QUOTA FOR UFDSET
	PUSHJ	P,RDUFD		;LOGGED-OUT QUOTA
	  JRST	ACC1J
	MOVE	T4,WD		;D=LOGGED OUT QUOTA FOR UFDSET
	PUSHJ	P,RDUFD		;BITS ABOUT FILE STRUCTURE
	  JRST	ACC1J
	MOVE	T1,[XWD 1,M]
	DSKCHR	T1,		;SEE IF STR IS IN SYSTEM
	  JRST	ACC1H		;NO, DO NOT PUT IN SEARCH LIST
	TXNE	T1,DC.SAF	;SKIP IF NOT SINGLE ACCESS
	JRST	ACC1H		;CANT BE FOR US YET SO DONT INCLUDE THIS STR
	LDB	T1,[POINTR(T1,DC.TYP)] ;[711] GET STR TYPE
	CAIE	T1,.DCTFS	;[711] IS IT FULL FILE STRUCTURE NAME?
	JRST	ACC1H		;[711] NO - IGNORE INVALID NAME
	CAIL	P1,MAXFS*5	;TOO MANY STRS IN S/L?
	 JRST	[WARN	MTS,<More than >,,E.MTS;YES--WARN WE CANT ADD THIS ONE
		 JRST	ACC1H]		;AND LOOP FOR ALL AUXACC ENTRIES
	MOVEM	M,SAVAUX(P1)	;save info from AUXACC for 2nd pass
	MOVEM	T2,SAVAUX+1(P1)
	MOVEM	T3,SAVAUX+2(P1)
	MOVEM	T4,SAVAUX+3(P1)
	MOVEM	WD,SAVAUX+4(P1)
	PUSHJ	P,ADDSTR	;add structure to search list
	ADDI	P1,5		;bump up pointer
ACC1H:	AOJL	P2,ACC1B	;LOOP FOR ALL STRS IN ENTRY
	SETZM	SAVAUX(P1)	;set end marker for 2nd pass
	PUSHJ	P,SW.INI##	;Read SWITCH.INI and validate account
	TDZA	P1,P1		;reset pointer and skip
ACC2A:	 ADDI	P1,5		;when looping, step to next entry
	SKIPN	M,SAVAUX(P1)	;another one in the wings?
	 JRST	ACC2H		;No, all done
	MOVE	T2,SAVAUX+1(P1)	;Yes, recover stashed data
	MOVE	T3,SAVAUX+2(P1)	;	then go process this
	MOVE	T4,SAVAUX+3(P1)	;	as originally coded to
	MOVE	WD,SAVAUX+4(P1)	;	set up UFD's, etc.
	TXNN	WD,DF.SWL!DF.SNC;CAN WE CREATE ON THIS STR
	TRO	F,R.ACRE	;YES-INDICATE CREATION POSSIBLE
	PUSHJ	P,UFDSET	;SET UP UFD FOR USER ON THIS STR
	TLZ	F,FL.ATT	;CLEAR ATTACH FLAG
	JRST	ACC2A		;loop til no more strs
ACC2H:	PUSHJ	P,QTANXT	;GET NEXT STR TO RECOMPUTE USAGE ON
	  JRST	ACC2I		;DONE
	PUSHJ	P,UFDRCP	;SET UP UFDSET AND DO IT
	JRST	ACC2H		;LOOP
ACC2I:	TRO	F,R.RCOM	;FLAG THAT WE HAVE RECOMPUTED
	TRZN	F,R.ASTR	;[613] ARE ANY STR'S DEFINED IN SEARCH LIST?
	JRST	NOSTRX		;NO, WARN SO
	TRNE	F,R.ACRE	;ARE ANY CREATES ALLOWED?
	JRST	ACCT
	WARN	NCR,<Search list does not allow creates>
	JRST	ACCT
NOSTR:	WARN	SLE,<Search list is empty>
	JRST	TOACCT		;Final cleanup, then go to ACCT

NOSTRX:	WARN	SLX,<Search list is empty>
	JRST	ACCT

E.MTS:	MOVEI	T1,MAXFS	;GET THE MAX
	PUSHJ	P,.TDECW##	;OUTPUT
	MOVEI	T1,[ASCIZ/ structures in search list; cannot add structure /]
	PUSHJ	P,.TSTRG##
	MOVE	T1,M		;GET STR BACK
	PJRST	.TSIXN##	;TYPE AND RETURN

ACC1J:	STOP	XRE,<Format or read error in AUXACC.SYS>,EF.WTO

	STOP	CUF,<CORE UUO failed>,EF.WTO

	STOP	HMU,<High segment messed up>,EF.WTO

IFN	FASTLG,<
AUXEND:	MOVE	WD,ACCKNT	;AT END OF FILE, FORCE LAST BLOCK
	MOVEM	WD,@T2
	AOBJN	T1,.-1		;Fill table with "last" value
	JRST	AUXDUN		;AND PROCEED>
BACKUP:	SOJE	T1,SKACC2	;BACK UP BLOCK COUNTER AND STOP READING IF BEGINNING
	JRST	ACC1E		;READ NEXT PREVIOUS BLOCK IN UFD

SKACC1:	PUSHJ	P,RDUFD		;SKIP FORWARD TO USER
	  JRST	NOINAU		;EOF - NOT THERE
	AOJN	WD,SKACC1	;SEARCH FOR -1 FLAG--START OF ENTRY
	PUSHJ	P,RDUFD		;READ NUMBER OF WORDS THAT FOLLOW
	  JRST	NOINAU
	MOVNI	P2,-1(WD)	;-LENGTH - USED AT ACC1G
	PUSHJ	P,RDUFD		;READ PPN
	  JRST	NOINAU
	CAMG	WD,PPN		;PAST USER?
	JRST	ACC1F		;NO - KEEP LOOKING FOR HIM
SKACC2:	HLLO	T3,PPN		;T3=PROJ,-1=DEFAULT
	CAMLE	WD,T3		;PAST DEFAULT?
	JRST	NOINAU		;YES - NOT THERE
	CAMN	WD,T3		;AT DEFAULT?
	JRST	ACC1G		;YES - USE THIS
	HRLZ	T2,PPN		;PROG NO TO T2 LEFT
	JUMPGE	T2,ACC1F	;KEEP LOOKING UNLESS WILD PROG NO
	HRRI	T3,UNIPRG	;COMPARE AGAINST WILD CARD
	CAME	WD,T3		;ONE OF THOSE?
	JRST	ACC1F		;KEEP LOOKING
	JRST	ACC1G		;GOT IT


NOAUXA:	TLNE	F,L.OPR!L.SOPR	;[577] OPR OR SON-OF-OPR?
	  JRST	NOAUX1		;[577] YES - LET HIM IN ANYWAY
	STOP	CRA,<Can not read AUXACC.SYS>,EF.WTO
NOAUX1:	WARN	CRX,<Can not read AUXACC.SYS>
	JRST	NOSTR		;[577] TELL HIM NO S.L.
NOINAU:	WARN	NXE,<No entry in AUXACC.SYS>
TOACCT:	PUSHJ	P,SW.INI##	;Even people with strange search lists
				;use switches and charge their usage
	JRST	ACCT
	SUBTTL	UFD SETUP -- Call .UFD to mount/setup STR/UFD

;SUBROUTINE TO SET UP A UFD FOR USE  
;ARGS:	T2=RESERVED QUOTA
;	T3=FIRST COME FIRST SERVED QUOTA
;	T4=LOGGED OUT QUOTA
;	M=NAME OF STR
;
;IF T4=-1 ASSUME NO UFD DESIRED - PERFORM OTHER OPERATIONS
;
;CALL	PUSHJ	P,UFDSET
;ERROR	DONT PROCEED (MESSAGE TYPED)
;OK	STR IS IN SEARCH LIST (WARNING MAY BE TYPED)
;
UFDSET:	MOVEM	M,UFDFSN		;Save STR name
	PUSHJ	P,GETLOK		;Get UFD interlock
	PUSHJ	P,UFDINI		;Setup arg block
	MOVEM	T2,UFDARG+.UFQTR	;Save reserved
	MOVEM	T3,UFDARG+.UFQTF	;And FCFS
	MOVEM	T4,UFDARG+.UFQTO	;And logged out quota
	MOVEM	WD,UFDARG+.UFSTS	;Save status from AUXACC
	MOVE	T1,PPN			;Get the PPN to use
	MOVEM	T1,UFDARG+.UFPPN	;Set it
	MOVE	T1,XPDDTM		;UFD expiration
	MOVEM	T1,UFDARG+.UFDED	;Save
	MOVE	T1,U.UFDP		;Get /UFDPROTECTION
	MOVEM	T1,UFDARG+.UFPRO	;Save (-1=NONE specified)
	MOVEI	T1,UFDTYO		;Error typer
	MOVEM	T1,UFDARG+.UFTYO	;Save
	MOVX	T1,UF.LGI!UF.NLK!UF.AIS!INSVL.(.UFMNT,UF.FNC)	;Mount and set logged in (have interlock)
	TLZE	F,FL.GPN		;Generate a unique programmer number?
	 TXO	T1,UF.WLD		;Yes--Tell UFDSET
	MOVEM	T1,UFDARG+.UFFLG	;Save flags
	MOVE	T1,UFDARG+.UFSTR	;Get str name
	PUSHJ	P,QTADSK		;Need to recompute quotas?
	  TDZA	T2,T2			;No
	MOVX	T2,UF.ARD		;Yes
	IORM	T2,UFDARG+.UFFLG	;Set flag (maybe)
	MOVEI	T1,UFDARG		;Point to args
	PUSHJ	P,.UFD##		;Set it up
	 JRST	UFDDON			;Error--Just finish up
	MOVE	T1,UFDARG+.UFFLG	;Get the flag word
	TXNE	T1,UF.NDL		;RIPNDL turned on for this UFD?
	 SETOM	UFDNDL			;Yes
	TXNE	T1,UF.NUE		;No UFD exist?
	 JRST	UFDDON			;Yes--No UFD
	TRO	F,R.ASTR		;No--Got a UFD
	MOVE	T1,UFDARG+.UFCDT	;Creation date
	MOVE	T2,UFDARG+.UFCTM	;Creation time
	CAMGE	T1,UFDDAT		;Old?
	JRST	UFDDON			;Yes.
	CAME	T1,UFDDAT		;Same?
	JRST	UFDEXB			;No--New. Update.
	CAMGE	T2,UFDTIM		;Same date. Time old?
	JRST	UFDDON			;No.
UFDEXB:	MOVEM	T1,UFDDAT		;Store newest time
	MOVEM	T2,UFDTIM		;And date
UFDDON:	MOVX	T1,UF.WLD		;Get the wild PPN bit
	TDNN	T1,UFDARG+.UFFLG	;Was it on?
	 PJRST	CLRLOK			;NO--Release interlock and return
	MOVE	T1,UFDARG+.UFPPN	;Yes--Get real PPN used
	MOVEM	T1,PPN			;Save for LOGIN
	MOVEM	T1,.MYPPN##		;Save for SCAN
	PJRST	CLRLOK			;Release interlock and return
	SUBTTL	UFD SETUP -- Recompute disk usage on random structures


UFDRCP:	MOVEM	T1,UFDFSN		;Save STR name
	PUSHJ	P,GETLOK		;Get UFD interlock
	PUSHJ	P,UFDINI		;Setup arg block
	SETOM	UFDARG+.UFQTR		;Don't
	SETOM	UFDARG+.UFQTF		; Set
	SETOM	UFDARG+.UFQTO		;  Quotas
	MOVE	T1,PPN			;Get the PPN to use
	MOVEM	T1,UFDARG+.UFPPN	;Set it
	MOVE	T1,U.UFDP		;Get /UFDPROTECTION
	MOVEM	T1,UFDARG+.UFPRO	;Save (-1=NONE specified)
	MOVEI	T1,UFDTYO		;Error typer
	MOVEM	T1,UFDARG+.UFTYO	;Save
	MOVX	T1,UF.NLK!UF.ARD!INSVL.(.UFRDU,UF.FNC)	;Always recomput
	MOVEM	T1,UFDARG+.UFFLG	;Save flags
	MOVEI	T1,UFDARG		;Point to args
	PUSHJ	P,.UFD##		;Set it up
	 JRST	UFDDON			;Error--Just finish up
	PJRST	CLRLOK			;Release interlock and return
	SUBTTL	UFD SETUP -- Handle typeout of errors from .UFD

UFDTYO:	HRRZ	T1,UFDARG+.UFPFX	;Get prefix
	CAIE	T1,'MNT'		;MOUNT msg?
	 CAIN	T1,'AJL'		;ADD S/L msg?
	  POPJ	P,			;Yes--Too verbose
	CAIN	T1,'NUC'		;No UFD created msg?
	 POPJ	P,			;Yes--We dont want either
	CAIN	T1,'RDU'		;Recomputing?
	 AOSN	RDUFLG			;Yes--Already seen it?
	  CAIA				;Ok
	   POPJ	P,			;Yes--Once is enough
	HLRZ	T1,UFDARG+.UFPFX	;Get error char
	PUSHJ	P,.TCHAR##		;Type
	HRRZ	T1,UFDARG+.UFPFX	;Error prefix
	HRLI	T1,'LGN'		;Prefix
	PUSHJ	P,.TSIXN##		;Type
	PUSHJ	P,.TSPAC##		;Space over
	MOVE	T1,UFDARG+.UFTXT	;Addess of text
	PUSHJ	P,.TSTRG##		;Type
	HLRZ	T1,UFDARG+.UFPFX	;Error char
	CAIN	T1,"["			;Informational?
	 PUSHJ	P,.TRBRK##		;Yes--Close it
	PUSHJ	P,.TCRLF##		;CRLF
	POPJ	P,			;And return
	SUBTTL	UFD SETUP -- Initialize block

UFDINI:	MOVE	T1,[UFDARG,,UFDARG+1]	;Setup BLT
	SETZM	UFDARG			;Clear first
	BLT	T1,UFDARG+.UFSIZ-1	;Zero them all
	MOVE	T1,UFDFSN		;Get STR name
	MOVEM	T1,UFDARG+.UFSTR	;Save structure
	SETOM	UFDARG+.UFPPN		;Default PPN
	SETOM	UFDARG+.UFJOB		;And job
	POPJ	P,			;Return
	SUBTTL	UFD SETUP -- Add a structure to search list

ADDSTR:	MOVEM	M,UFDFSN		;Save STR name
	PUSHJ	P,UFDINI		;Set up block
	MOVEI	T1,UFDTYO		;Get typer
	MOVEM	T1,UFDARG+.UFTYO	;Save
	MOVX	T1,.UFAJL		;Add to search list
	DPB	T1,[POINTR UFDARG+.UFFLG,UF.FNC];Store
	MOVEI	T1,UFDARG		;Point to args
	PUSHJ	P,.UFD##		;Add the str
	 JFCL				;Dont care
	POPJ	P,			;And return
	SUBTTL	UFD SETUP -- Get UFD interlock

	ND	UFDSEC,^D5*^D60		;Wait 5 minutes for interlock

GETLOK:	TLNE	F,FL.WLD		;Wildcard programmer number?
	 POPJ	P,			;Yes - no need to get interlock
	PUSHJ	P,UFDINI		;Setup block
	MOVSI	T1,UFDSEC		;Second to wait for interlock
	TLNE	F,FL.BAT		;Batch?
	 LSH	T1,1			;Yes--Twice as tough
	HRRI	T1,^D10			;Message after 10 seconds
	MOVEM	T1,UFDARG+.UFLOK	;Save lock timer
	MOVEI	T1,LOKTYO		;Typer
	MOVEM	T1,UFDARG+.UFTYO	;Set
	MOVX	T1,.UFSUI		;Set UFD interlock
	DPB	T1,[POINTR UFDARG+.UFFLG,UF.FNC];Store
	MOVEI	T1,UFDARG		;Point to block
	SETOM	CCWAIT##		;Dont allow ^C
	PUSHJ	P,.UFD##		;Get the interlock
	 TLNN	F,FL.BAT		;Batch?
	  POPJ	P,			;No--Give in and get him go
	REQUE	UBT,<UFD interlock busy too long>;Yes--Try again later

LOKTYO:	MOVE	T1,UFDARG+.UFERR	;Get error code
	CAIN	T1,UFUBT%		;Busy too long?
	 POPJ	P,			;Yes--No message
	PJRST	UFDTYO			;Else type the standard way


	SUBTTL	UFD SETUP -- Clear the UFD interlock

CLRLOK:	TLNE	F,FL.WLD		;Wildcard programmer number?
	 POPJ	P,			;Yes - no interlock to clear
	PUSHJ	P,UFDINI		;Setup block
	MOVX	T1,.UFCUI		;Clear interlock
	DPB	T1,[POINTR UFDARG+.UFFLG,UF.FNC];Store code
	MOVEI	T1,UFDARG		;Point to args
	PUSHJ	P,.UFD##		;Clear the interlock
	 JFCL				;Dont care
	PJRST	CTLCOK##		;Check/clear ^C
; /QUOTA switch processing.  This routine will expand abbreviated
; structure names and "ALL".  It also special cases "DSK" to mean
; all strustures in the job's search list.  When switch scanning
; is done, the job's search list is unknown so we light a flag
; and go away.  "DSK" cannot be expanded.
QUOTAS::PUSHJ	P,.SIXSW##		;GET STR NAME
	SETZM	LSTSTR			;INIT "LAST" STR
	MOVE	T3,N			;GET STR
	CAME	T3,['DSK   ']		;WAS IT DSK?
	JRST	QUOTA0			;NO
	AOS	U.QTA			;INDICATE /QUOTA:DSK
	JRST	.POPJ1##		;AND RETURN WITHOUT STORE

QUOTA0:	CAMN	T3,['ALL   ']		;ALL STRS IN SYSTEM?
	TDZA	N,N			;ALLOW ALL STRS TO MATCH

QUOTA1:	PUSHJ	P,.MKMSK##		;GENERATE A MASK
	MOVEM	T1,STRMSK		;SAVE MASK

QUOTA2:	MOVE	T1,LSTSTR		;GET LAST STR
	SYSSTR	T1,			;GET NEXT
	  JRST	QUOTA4			;ILLEGAL STR
	JUMPE	T1,.POPJ1##		;RETURN IF NO MORE
	MOVEM	T1,LSTSTR		;SET NEW "LAST" STR
	JUMPE	N,QUOTA3		;ALL?
	AND	T1,STRMSK		;MASK NAME
	CAME	T1,N			;MATCH?
	JRST	QUOTA2			;NO--TRY THE NEXT ONE
	MOVE	T1,LSTSTR		;RELOAD STR NAME

QUOTA3:	PUSHJ	P,QTAPUT		;ADD TO QTATAB
	JRST	QUOTA2			;LOOP FOR ALL STRS

QUOTA4:	WARN	(ISN,<Illegal structure name ">,QUOTA5)
	JRST	.POPJ1##		;RETURN WITHOUT STORE

QUOTA5:	MOVE	T1,N			;GET STR NAME
	PUSHJ	P,.TSIXN##		;TYPE IT
	MOVEI	T1,""""			;GET A DOUBLE QUOTE
	PJRST	.TCHAR##		;TYPE IT AND RETURN
; Here to put the structure name in QTATAB
QTAPUT:	MOVE	T2,T1			;GET STR NAME
	MOVE	T1,[-STRMAX,,QTATAB]	;AOBJN POINTER TO TABLE

QTAPU1:	SKIPN	(T1)			;ENTRY IN USE?
	JRST	QTAPU2			;NO
	CAME	T2,(T1)			;ALREADY IN TABLE?
	AOBJN	T1,QTAPU1		;NO--KEEP CHECKING
	POPJ	P,			;RETURN

QTAPU2:	MOVEM	T2,(T1)			;STORE STR NAME
	POPJ	P,			;RETURN


QTANXT::MOVE	T2,[-STRMAX,,QTATAB]	;AOBJN POINTER TO TABLE
	SKIPN	T1,(T2)			;GET AN ENTRY
	AOBJN 	T2,.-1			;LOOP 'TIL WE FIND ONE
	JUMPGE	T2,.POPJ##		;RETURN IF TABLE EMPTY
	SETZM	(T2)			;ZERO OUT ENTRY
	JRST	.POPJ1##		;AND RETURN

QTADSK::PUSHJ	P,QTASTR		;SEE IF IN QTATAB
	  SKIPL	U.QTA			;/QUOTA?
	AOS	(P)			;SKIP
	POPJ	P,			;RETURN

QTASTR::MOVE	T2,[-STRMAX,,QTATAB]	;AOBJN POINTER TO TABLE
	CAME	T1,(T2)			;WANT TO RECOMPUTE ON THIS STR?
	AOBJN	T2,.-1			;LOOP THROUGH EACH ENTRY
	JUMPGE	T2,.POPJ##		;RETURN OF NO MATCH
	SETZM	(T2)			;MARK THIS ONE DONE
	JRST	.POPJ1##		;AND SKIP
;[444] ROUTINE TO WRITE-ENABLE HI SEG AND LOCK OUT ANY OTHER JOBS
;[444] WHICH MIGHT TRY TO MODIFY IT.  ALSO LOCKS OUT CONTROL-C
;[444] SO USER CAN'T LEAVE HI SEG IN FUNNY STATE

LOK:	SETOM	CCWAIT		;[444] LOCK OUT CONTROL-C
	SETZ	T1,		;[444] WRITE-ENABLE HI SEG
	SETUWP	T1,		;[444] ..
	  JRST	LGNCLH		;[444] PRETEND THIS DIDN'T REALLY HAPPEN
	MOVEM	T1,SVPROT	;[444] SAVE OLD HI SEG PROT CODE
	POPJ	P,		;[444] RETURN

	STOP	CLH,<Can't lock high segment>,EF.WTO

;[444] ROUTINE TO UNDO EVERYTHING THE ABOVE ROUTINE DID

UNLOCK:	MOVE	T1,SVPROT	;[444] GET OLD HI SEG PROT CODE
	SETUWP	T1,		;[444] RESTORE IT
	  JRST	LGNCUH		;[444] A FATE TOO EVIL TO CONSIDER
	PJRST	CTLCOK##	;[444] GO ENABLE CONTROL-C AGAIN

	STOP	CUH,<Can't unlock high segment>,EF.WTO
;[540] SUBROUTINE TO ZERO EXTENDED LOOKUP BLOCK

CLRRIB:	SETZM	SECBUF		;[540] CLEAR A WORD
	MOVE	T1,[SECBUF,,SECBUF+1]	;[540] 
	BLT	T1,SECBUF+.RBTIM;[540] SPREAD IT AROUND
	POPJ	P,		;[540] ALL DONE!

;SUBROUTINE TO SLEEP A WHILE OR UNTIL DACCFL IS SET POS

SNOOZE:	MOVE	T2,ACCTLN	; SET SLEEP TIME
	LSH	T2,-3		;   TO FILE LENGTH/8
	CAILE	T2,^D60		;IS SLEEP TIME OVER 60 SECONDS?
	MOVEI	T2,^D60		;YES--CHOP DOWN TO 60
SNOOZ1:	IFN	FASTLG,<
	SKIPLE	DACCFL		;IS DIRECTORY THERE?
	POPJ	P,		;YES, NON-SKIP RETURN
	>			;[556] END IFN FASTLG

	MOVEI	T1,1		;SETUP FOR THE LITTLE SLEEP
	SLEEP	T1,
	SOJG	T2,SNOOZ1	;KEEP YOUR PANTS ON
	AOS	0(P)		;FOR A WHILE, THEN
	POPJ	P,		;RETURN IMPATIENT
	SUBTTL	Subroutine to create a path

;ARGS:	U.PATH=PATH DESIRED
;	UFDFSN=STR NAME
;CALL WITH:
;	MOVEI	T1,1		;TO CREATE SFDS
;	MOVEI	T1,0		;TO NOT CREATE SFDS
;	PUSHJ	P,ENTPTH
;	RETURN HERE ALWAYS (PTHBUF SET UP FOR PATH. UUO)

ENTPTH:	PUSHJ	P,.SAVE3##	;[746] SAVE P1 AND P2 AND P3
	MOVEI	P3,(T1)		;[746] SAVE FLAG TO CREATE SFDS
	HRRZ	T1,U.PATH+.FXDIR;GET PROG NUMBER
	CAIN	T1,UNIPRG	;IS IT #
	HRRZ	T1,PPN		;YES--CORRECT FOR ACTUAL NO.
	HRRM	T1,U.PATH+.FXDIR;STORE BACK CORRECTED NUMBER
	SETZM	PTHBUF+.PTFCN	;IGNORED ON ENTER
	MOVEI	T1,.PTSCN	;/SCAN:NO
	MOVEM	T1,PTHBUF+.PTSWT;STORE THE SWITCH
	MOVE	T1,U.PATH+.FXDIR;GET PPN
	MOVEM	T1,PTHBUF+.PTPPN;STORE IN PATH
	MOVEI	P1,PTHBUF+.PTPPN+1	;WHERE PATH GOES
	MOVEI	P2,U.PATH+.FXDIR+2	;WHERE PATH COMES FROM
	HRLI	P1,-<.FXLND-1>		;[573] INIT MAX LOOP CNTR
ENTPTL:	SKIPN	(P2)		;ANOTHER SFD GIVEN?
	POPJ	P,		;NO. DONE
	SETZM	(P1)		;[746] MAKE END OF LIST
	MOVE	T1,(P2)		;[746] GET NAME OF SFD
	JUMPE	P3,ENTPT2	;[746] JUMP IF DOESNT WANT SFDS MADE
	MOVEI	T2,17		;[746] MODE
	MOVE	T3,UFDFSN	;[746] STR NAME
	SETZM	T4		;[746] NO BUFFERS
	OPEN	USR,T2		;[746] OPEN STR
	  POPJ	P,		;A FATE TOO EVIL TO CONSIDER
	MOVSI	T2,'SFD'	;EXTENSION IS SFD
	SKIPGE	T3,U.SFDP	;[550] /SFDPROT SPECIFIED?
	  SETZM	T3		;[550] NO - ASSUME STANDARD
	ANDI	T3,777		;[550] MASK OUT JUNK
	LSH	T3,^D27		;[550] SLING OVER TO LEFT HALF
	MOVEI	T4,PTHBUF	;PATH POINTER
	ENTER	USR,T1		;TRY TO ENTER SFD
	  SKIPA			;CAN NOT--SEE WHY
	JRST	ENTPT1		;WE WON.
	HRRZ	T3,T2		;GET ERROR CODE
	CAIE	T3,ERFBM%	;IS FILE BEING MODIFIED?
	CAIN	T3,ERCSD%	;OR DOES IT EXIST YET?
	JRST	ENTPT1		;MODIFIED OR EXITSING -- ALL OK
	PUSH	P,T3		;SAVE T3
	CAIN	T3,ERLVL%	;LEVEL ERROR?
LGNSND:	SKIPA	T1,[[ASCIZ /%LGNSND SFD's nested too deeply(/]]
LGNSEF:	MOVEI	T1,[ASCIZ /%LGNSEF SFD enter failure (/]
	PUSHJ	P,.TSTRG##	;TYPE THE STRING
	POP	P,T1		;RESTORE NUMBER
	PUSHJ	P,.TOCTW##	;TYPE CODE
	MOVEI	T1,[ASCIZ /) /] ;LOAD UP A DELIMITER
	PUSHJ	P,.TSTRG##	;TYPE IT OUT
	MOVE	T1,UFDFSN	;LOAD UP STR NAME
	PUSHJ	P,.TSIXN	;TYPE IT OUT
	MOVEI	T1,":"		;LOAD UP A :
	PUSHJ	P,.TCHAR##	;TYPE IT OUT
	MOVE	T1,(P2)		;GET SFD NAME
	PUSHJ	P,.TSIXN##	;TYPE THAT OUT TOO
	MOVEI	T1,[ASCIZ /.SFD/] ;WE KNOW THE EXTENSION
	PUSHJ	P,.TSTRG##	;SO TELL THE USER
	MOVEI	T1,[PTHBUF]	;[746] POINT TO PATH. BLOCK
	PUSHJ	P,.TDIRB##	;[746] LET SCAN TYPE IT
	PUSHJ	P,.TCRLF##	;TYPE A CRLF
	MOVEI	P3,0		;INDICATE NOT TO CREATE ANY MORE SFDS
	MOVE	T1,(P2)		;RESTORE SFD NAME
ENTPT1:	CLOSE	USR,0		;[454] CLOSE OUT THE SFD
ENTPT2:	MOVEM	T1,(P1)		;[746] STORE T1 (SFD NAME FROM ABOVE)
				; SO SFD'S NEST CORRECTLY.
	ADDI	P2,2		;POINT TO NEXT NAME
	AOBJN	P1,ENTPTL	;[573] LOOP OVER THE PATH
;[614] ENTPT1+4			/LC
	POPJ	P,

	PRGEND
	TITLE	LGNSET - Module to set up user profile for LOGIN

	SEARCH	UUOSYM,MACTEN,SCNMAC,LGNUNV,ACTSYM,UFDPRM
	LGNDCL

	SUBTTL	Set user profile -- privileged GALAXY SETUUOs

GLXSET:
; Set WTO/WTOR privs
	SKIPGE	T1,U.BINT	;Get /BATINT value
	 MOVEI	T1,1		;Assume YES incase BATCON forgot this switch
	MOVE	T1,[.OBNWR	;WTO allowed
		    .OBALL](T1)	;WTO and WTOR allowed
	HRLI	T1,.STWTO	;SETUUO function code
	MOVE	T2,['WTO',,[ASCIZ/write to operator privileges/]]
	TLNE	F,FL.BAT	;Do this only for a Batch job
	PUSHJ	P,SETIT		;Set WTO/WTOR GXivs

; Set Batch stream number
	SKIPGE	T1,U.BSTR	;Get /BATSTR value
	 JRST	GXSET0		;There wan't one
	HRLI	T1,.STBSN	;SETUUO function code
	MOVE	T2,['BSN',,[ASCIZ/Batch stream number/]]
	TLNE	F,FL.BAT	;Do this only for a Batch job
	PUSHJ	P,SETIT		;Set Batch stream number

GXSET0:	POPJ	P,		;And return
	SUBTTL	Set user profile -- privileged SETUUO's

;ROUTINE TO DO PRIVILEGED SETUUO'S
;ARGS:	U.TIME,U.SPL,U.CORE,U.DFER
;CALL WITH:
;	PUSHJ	P,PRVSET
;	RETURN HERE
;
PRVSET:	TXNE	F,R.SESS	;IF SESSION COMMAND, JUST SET THE ACCOUNT
	JRST	PRSET5

	SKIPGE	T1,U.TIME	;WANT TIME LIMIT SET?
	JRST	PRSET1		;NO--CHECK SPOOL
	HRLI	T1,.STTLM	;YES--SET UP ENTIRE ARGUMENT
	MOVE	T2,['STL',,[ASCIZ/time limit/]]
	PUSHJ	P,SETIT		;DO THE SET UUO
PRSET1:	HRROI	T1,.GTSPL	;[364] GET SPOOL BITS FOR JOB TO SEE
	GETTAB	T1,		;[364] IF SYSTEM HAS SPOOLING. IF NOT,
	  JRST	NSPOOL		;[364] DON'T TRY TO SET SPOOL BITS.
	LDB	T1,SPLBTS	;GET SPOOL BITS FROM ACCT.SYS 
	IOR	T1,U.SPL	;OR IN ONES REQUESTED BY  USER
	HRLI	T1,.STSPL	;COMPLETE ARGUMENT
	MOVE	T2,['SSB',,[ASCIZ/spool bits/]]
	TRZ	T1,-JS.PAL-1	;[365,371] CLEAR BITS WHICH AREN'T DEVICES
	PUSHJ	P,SETIT		;GO SET IT
	MOVE	T1,STATS2	;[374] GET SECOND STATES WORD
	TXNN	T1,ST%GAL	;[374] CAN WE SUPPORT GALAXY-10?
	JRST	NSPOOL		;[374] NO -- DON'T TRY, THEN
	MOVX	T1,%CNVER	;GET THE MONITOR'S VERSION NUMBER
	GETTAB	T1,
	  JRST	PRST1C		;ERROR. SKIP THE SETUUO
	LDB	T2,[POINT 6,T1,23] ;MONITOR VERSION NUMBER
	CAIGE	T2,7		;IS THIS 7.00 OR LATER MONITOR?
	JRST	PRST1C		;NO. SKIP THIS SETUUO
	LDB	T1,[POINTR ENTRY+.ACPRO,AC.OPR]	;YES. GET OPERATOR PRIVILEGE CODE
	HRLI	T1,.STOPP
	MOVE	T2,['SOP',,[ASCIZ/operator privileges/]]
	PUSHJ	P,SETIT
PRST1C:	SKIPGE	T1,U.DFER	;[365] WAS THERE A /DEFER SWITCH?
	JRST	NSPOOL		;[365] NO -- SAVE A UUO
	HRLI	T1,.STDFR	;[365] SETUUO CODE FOR DEFERRED SPOOLING
	MOVE	T2,['SDS',,[ASCIZ/deferred spooling bit/]]
	PUSHJ	P,SETIT		;[365] DO THE SETUUO

NSPOOL:	LDB	T2,[POINTR ENTRY+.ACCIP,AC.NPP]	;[521] GET PHYS. LIMIT
	LSH	T2,^D9		;[551] CONVERT TO WORDS
	SKIPG	T1,U.CORE	;[551] GET /CORE ARG IF ONE
	JRST	PRST1B		;[551] NO ARG--USE PHYS. LIMIT
	CAIL	T1,1000		;[551] IS ARG ALREADY IN WORDS ?
	JRST	PRST1A		;[551] YES--SKIP ON
	CAILE	T1,^D256	;[551] IS ARG UNREASONABLE ?
	LSH	T1,^D9		;[551] YES--ASSUME HE MEANT P AND CONVERT
	CAIG	T1,^D256	;[551] IS ARG IN K ?
	LSH	T1,^D10		;[551] YES--CONVERT TO WORDS
PRST1A:	CAML	T1,T2		;[551] IS ARG < OR = PHYS. LIMIT
PRST1B:	MOVE	T1,T2		;[551] NO--USE PHYS. LIMIT FROM ACCT.SYS
	HRLI	T1,.STCLM	;SET UUO CODE FOR CORE
	MOVE	T2,['SCL',,[ASCIZ/core limit/]]
	PUSHJ	P,SETIT		;SET THE CORE LIMIT
	SKIPL	NEWACT		;[613] DO WE HAVE NEW ACCT.SYS?
	POPJ	P,0		;NO--ALL DONE
	MOVE	T1,STATS2	;[374] GET SECOND STATES WORD
	TXNN	T1,ST%VMS	;SKIP IF VM MONITOR
	JRST	PRSET3		;NOT VM DO NOT TRY UUO'S
	MOVE	T1,[.STUVM,,T3]	;LOAD POINTER TO STUFF
	LDB	T3,[POINTR ENTRY+.ACCIP,AC.NPP] ;GET PHYSICAL LIM
	LDB	T4,[POINTR ENTRY+.ACCIP,AC.NVP] ;GET VIRT LIM
	SKIPE	T3		;DO NOT TURN 0 INTO 1
	AOS	T3		;ELSE INCREMENT
	SKIPE	T4
	AOS	T4
	HRL	T3,T4		;MAKE XWD VIRT,,PHYS
	MOVE	T2,['SVM',,[ASCIZ /maximum virtual and physical limits/]]
	PUSHJ	P,SETIT		;GO DO THE SET
PRSET3:	SKIPL	EQACT		;[356] SET 6.02 STUFF?
	JRST	PRSET5		;[431] NO
	LDB	T1,[POINTR ENTRY+.ACESE,AC.EDQ]	;[352] GET QUOTA
	HRLZ	T1,T1		;[426] PUT QUOTA IN LEFT HALF
	TLC	T1,777		;[446] SEE IF QUOTA=-1
	TLCN	T1,777		;[643] ..
	  JRST	PRSET4		;[430] YES -- DON'T DO ENQC.
	HRR	T1,THSJOB	;[426] AND JOB NUMBER IN RIGHT HALF
	MOVE	T2,[XWD 2,T1]	;[352] SET UP POINTER TO ARG
	ENQC.	T2,		;[352] DO IT UP
	 SKIPA			;[507] WOOPS - CHECK IT OUT
	  JRST	PRSET4		;[507] OK - KEEP ON TRUCKIN
	CAMN	T2,[XWD 2,T1]	;[507] AC UNCHANGED (UUO NOT IMPLEMENTED)?
	  JRST	PRSET4		;[507] YES - DON'T BOTHER USER THEN
	MOVE	T1,T2		;PICK UP ERROR CODE
	WARN	EUF,<ENQC. UUO failed; Error code = >,EF.WTO,.TOCTW##

PRSET4:	MOVE	T1,STATS2	;[425] GET 2ND STATES WORD
;**;[1102] after PRSET4 plus 1 line insert 1 line
	TXNN	T1,ST%NCS	;[1102] SKIP THIS IF 6.03 SCHEDULER IN WMU MODE
	TXNN	T1,ST%SHC	;[425] DOES MONITOR HAVE SCHED. UUO?
	  JRST	PRSET5		;[425] NO -- SKIP THIS STUFF
	LDB	T1,[POINTR ENTRY+.ACESE,AC.SCD]	;[425] GET SCHED TYPE
	IDIVI	T1,4		;[425] GET INDEX INTO TABLE
	ADD	T1,SCDTBL	;[425] ADD TABLE BASE ADDRESS
	TLNE	F,FL.BAT	;[452] BATCH JOB?
	  ADDI	T1,SCDSIZ/2	;[452] YES - INDEX INTO BATCH PART OF TBL
	LDB	T4,BYTTAB(T2)	;[425] INDEX BYTE POINTER BY REMAINDER
				;[622]  TO GET CPU CLASS IN T4
	MOVX	T1,%SSMSI	;[622] NOW GETTAB THE MEDIUM-TERM
	GETTAB	T1,		;[622] SCHEDULING INTERVAL TO SEE
	  JRST	PRSET5		;[622] IF THE CLASS SCHEDULER IS RUNNING
	JUMPE	T1,PRST4B	;[672] [622] IF INTERVAL=0, CLASS SCHEDULER
				;[622]  ISN'T RUNNING SO SKIP CHECKS
	MOVX	T1,%SSSET	;[672] CHECK FLAG FOR CLASS
	GETTAB	T1,		;[672] SCHEDULING
	  SETO	T1,		;[672] NOT WMU CLASS SCHEDULER
	JUMPE	T1,PRST4B	;[672] SKIP CHECKS IF RUNNING ROUND ROBIN
	HRRZI	T1,.GTCQP	;[672] NOW GET CPU QUOTA FOR THIS CLASS
	HRL	T1,T4		;[672] T4 HAS OUR CLASS
	GETTAB	T1,		;[672]
	  JRST	PRSET5		;[672] MONITOR NOT BUILT FOR CLASS SCHEDULAR
	TRNE	T1,-1		;[672] IF PRIMARY % NON-ZERO,
	JRST	PRST4B		;[672]  WERE OK
	MOVE	T2,[%SSBBQ]	;[672] CHECK BACKROUND BATCH
	GETTAB	T2,		;[672] GET BB CLASS
	  SETO	T2,		;[672] NO BB
	CAMN	T2,T4		;[672] IS USER IN BB?
	  JRST	PRST4B		;[672] YES, HE IS OK
	JUMPL	T1,PRST4A	;[672] GIVE ERROR IF FIXED SWAPIN BIT SET
	HRRZI	T1,.GTSQP	;[672] NOW GETTAB SECONDARY ALLOCATION
	HRL	T1,T4		;[672] FOR THIS CLASS
	GETTAB	T1,		;[672]
	  JRST	PRST4B		;[672_] NOT WMU SCHEDULAR
	JUMPN	T1,PRST4B	;[672] OK IF THERE IS A SECONDARY QUOTA
PRST4A:	FATAL	CWR,<CPU class quota is zero; You would never run>

PRST4B:	HRLI	T4,-1		;[425] -1 MEANS THIS JOB
	MOVE	T1,[1,,T2]	;[425] SET UP POINTER FOR SCHED. UUO
	MOVE	T2,[.SCSJC,,T3]	;[425] XWD FUNC, LOC OF ARG LIST
	MOVEI	T3,1		;[425] ONLY ONE ARGUMENT
	SCHED.	T1,		;[425] ZAP!
	 CAMN	T1,[1,,T2]	;FAILED--SEE IF NOT IMPLEMENTED
	  JRST	PRSET5		;OK, OR NOT IMPLEMENTED
	WARN	SCF,<SCHED. UUO failed; Error code = >,EF.WTO,.TOCTW##
	JRST	PRSET5		;AND CONTINUE

BYTTAB:	POINT	9,(T1),8	;[425] BYTE PTR FOR REMAINDER=0
	POINT	9,(T1),17	;[425] REMAINDER=1
	POINT	9,(T1),26	;[425] T1 HAS ADDR OF WORD TO LOOK AT
	POINT	9,(T1),35

PRSET5:	MOVE	T1,U.ACTS	;GET ACCOUNT STRING
	AOJE	T1,PRSET6	;JUMP IF NOT THERE
	MOVE	T1,[.ACTCH,,T2]
	MOVEI	T2,1		;ONE ARGUMENT
	HRROI	T3,U.ACTS	;SEVEN BIT BYTE POINTER TO ACCOUNT STRING
	ACCT.	T1,		;TELL THE MONITOR THE USER'S ACCOUNT STRING
	  PUSHJ	P,LGNCSA	;ERROR
PRSET6:	TXNE	F,R.SESS	;IF SESSION COMMAND JUST SET THE ACCOUNT
	POPJ	P,
	MOVE	T1,STATS2	;[356,374] GET 2ND STATES WORD
	TXNN	T1,ST%IPC	;DO WE HAVE IPCF?
	POPJ	P,0		;NO--RETURN NOW
	MOVE	T1,[%IPCCP]	;GET THE PID OF [SYSTEM]IPCF
	GETTAB	T1,		; ..
	  POPJ	P,0		;CAN NOT FAIL
	MOVEM	T1,TOPID	;SAVE AS TARGET OF THIS MESSAGE
	MOVX	T1,IP.CFP	;INDICATE THAT I HAVE PRIVS AND
	MOVEM	T1,IPCFLG	; WANT TO USE THEM
	MOVE	T1,[3,,IPCMSG]	;POINTER TO THE MESSAGE
	MOVEM	T1,IPCPTR	; ..
	MOVX	T1,.IPCSQ	;WANT TO SET QUOTA
	MOVEM	T1,IPCMSG	;STORE AS FUNCTION
	HRRZ	T1,ENTRY+.ACCIP	;GET IPCF QUOTAS
	MOVEM	T1,IPCQTA	;STORE IT AWAY
	MOVE	T1,THSJOB	;[351] GET MY JOB NUMBER
	MOVEM	T1,IPCJOB	;STORE THAT AWAY
	MOVEM	T1,FMPID	;ALSO LOAD AS SENDERS PID
	MOVE	T1,[4,,IPCFLG]	;POINTER TO THE MESSAGE
	IPCFS.	T1,		;SEND IT
	  JRST	IPCSER		;SEND ERROR
	MOVX	T1,IP.CFB	;SAY WE DON'T WANT TO BLOCK
	MOVEM	T1,IPCFLG
	MOVE	T1,[4,,IPCFLG]	;SET UP TO GET BACK AN
	IPCFR.	T1,		; ANSWER.
	  JRST	IPCRER		;NO ANSWER
	MOVE	T1,IPCFLG	;GET THE FALGS WORD
	TXNN	T1,IP.CFE	;ANY ERROR CODE?
	POPJ	P,0		;NO--RETURN
	WARN	ESI,<Error from [SYSTEM]IPCF>,EF.WTO
	  POPJ	P,0		;ALL DONE
	JRST	IPCQER		;TELL HIM MORE


IPCSER:	WARN	EIS,<Error in send to [SYSTEM]IPCF>,EF.WTO
	JRST	IPCQER		;TELL HIME MORE
IPCRER:	CAIN	T1,IPCNP%	;QUEUE EMPTY?
	POPJ	P,0		;YES--ALL IS WELL
	WARN	EIR,<Error in receive from [SYSTEM]IPCF>,EF.WTO
IPCQER:	PUSHJ	P,.TCRLF##	;OUTPUT CRLF
	WARN	IQS,<IPCF quotas may not be set correctly>
	POPJ	P,0		;RETURN


LGNCSA:	TRNE	F,R.DBUG	;WE DEBUGGING?
	 JRST	LGNDSA		;YES--DONT WTO IT
	MOVE	T1,STATS2	;GET SECOND STATES WORD
	TXNN	T1,ST%ACV	;ACCOUNT VALIDATION REQUIRED?
	 JRST	LGNWSA		;NO--JUST WARN HIM
	STOP	FSA,<Cannot set the account string>,EF.WTO

	WARN	WSA,<Cannot set the account string>,EF.WTO
	POPJ	P,		;AND RETURN

	WARN	DSA,<Cannot set the account string>
	POPJ	P,


;[344] TABLES FOR ROUTINE TO DO TRMOP.S AND SET TERMINAL STUFF

IFN	SETTTY,<

	DEFINE X(TCODE,ARG,FLAGS),<
	XWD	ARG,FLAGS!TCODE+1000 >

;FLAGS
TF.CMP==1B18		;USE COMPLEMENT OF VALUE STORED BY SCAN

TTAB:	X .TOTRM,U.TYPE,0	;[675] DO TYPE SETTING FIRST THEN ALTER
				;[675] THE DEFAULTS.
	X .TOALT,U.ALTM,TF.CMP	;[472] TRMOP.S WHICH ARE DONE BEFORE
	X .TOBLK,U.BLNK,TF.CMP	;[472] PRINTING NOTICE.TXT
	X .TONFC,U.CRLF,TF.CMP
	X .TODBK,U.DBRK,0
	X .TOLCP,U.ECHO,TF.CMP
	X .TOFLC,U.FILL,0
	X .TOFRM,U.FORM,0
	X .TOSND,U.GAG,TF.CMP
	X .TOLCT,U.LC,TF.CMP
	X .TOPAG,U.PAGE,0
	X .TOPSZ,U.PGSZ,0
	X .TORTC,U.RTC,0
	X .TOTAB,U.TABS,0
	X .TOTAP,U.TAPE,0
	X .TOWID,U.WDTH,0
	X .TODEM,U.TTDE,0
	X .TODIS,U.DISP,0	;[743]
	X .TOLCT,U.UC,0		;[747]
	X .TOTDY,U.TIDY,0	;[747]
;;	X .TOFFH,U.FFHO,0
;;	X .TOFFF,U.FFSI,0
;;	X .TOFFS,U.FFST,0
	X .TOLNB,U.LENG,0
	X .TOSBL,U.SBEL,0
	X .TOSSZ,U.SSTO,0	;STOP SIZE
	X .TOSSZ,U.STOP,0	; "     "
	X .TOXNF,U.XONXO,0
	X .TOSTO,T.STOP,0	;STOP BIT
	X .TOSST,T.SSTOP,0	;SSTOP BIT
TTLNTH=.-TTAB

PTAB:	X .TORSP,U.RSPD,0	;[472] TRMOP.S WHICH SHOULD BE DONE
	X .TOTSP,U.XSPD,0	;[472] AFTER PRINTING NOTICE.TXT
PTLNTH=.-PTAB			;[472]

	>		;[344] END IFN SETTTY

	SUBTTL	Set user profile -- non-privileged SETUUOs
 
;HERE AFTER LOGIN UUO IS DONE TO SET OPTIONAL STUFF
USRSET:	HRROI	T1,.GTWCH	;[446] TRY GETTAB TO GET THIS JOB'S
	GETTAB	T1,		;[446] WATCH BITS. IF GETTAB FAILS,
	  JRST	TINY		;[446] THIS MUST BE A 1040 MONITOR
	LDB	T1,WATBTS	;GET WATCH BITS
	LSH	T1,SHFWAT
	HRRZ	T2,U.WAT	;GET WATCH BITS
	LSH	T2,WCHLSH##	;SHIFT TO CORRECT PLACE
	IOR	T1,T2		;OR IN THE USER SETTINGS
	MOVE	T2,ENTRY+.ACPRO	;GET THE PROFILE WORD
	TXNE	T2,AC.WVR	;WANT TO WATCH VERSIONS?
	TRO	T1,(JW.WVR)	;YES--TURN ON VERSION WATCHING
	SKIPE	NEWACT		;IF OLD ACCT.SYS FORMAT
	TXNE	T2,AC.WMT	; OR USER WANTS MTA WATCHING
	TRO	T1,(JW.WMT)	; TURN ON WATCH MTA
	TXNE	T2,AC.WFL	;USER WANTS FILE WATCHING
	TRO	T1,(JW.WFI)
	MOVE	T2,.FLVRB##	;[455] GET /VERBOSITY FROM SCAN
	LSH	T2,^D6		;[542] SHIFT OVER TO RIGHT PLACE
	ANDI	T2,700		;[542] THROW AWAY GARBAGE BITS
	IOR	T1,T2		;[455] OR INTO WATCH BITS
	HRLI	T1,.STWTC	;SET WATCH FUNCTION
	MOVE	T2,['SWB',,[ASCIZ/watch bits/]]
	SKIPE	U.NWAT		;[336] SKIP THE SETUUO IF /NOWATCH
	PUSHJ	P,SETIT		;DO THE SET UUO
TINY:	SETOM	UFDFSN		;[446] START WITH FIRST STR
USRST1:	MOVE	T2,UFDFSN	;GET STR NAME
	MOVE	T1,[3,,T2]	;[652] POINTER TO ARG BLOCK
	JOBSTR	T1,		;GET NEXT STR
	  JRST	USRST3		;SKIP ALL THE STR STUFF
	JUMPE	T2,USRST2	;JUMP IF WE ARE UP TO FENCE
	AOJE	T2,USRST2	;[427] OR END OF LIST IN ONE-STR SYSTEMS
	SOS	T2		;[427] ACCOUNT FOR AOJE
	MOVEM	T2,UFDFSN	;SAVE STR NAME
	MOVE 	T1,[2,,T2]	;[726] POINTER TO ARG BLOCK
	DSKCHR	T1,		;[726] GET AMOUNT OF LOGGED-IN QUOTA
	 JRST	USRSS1		;[746][726] FAIL-SKIP THIS STR
	TRNN	T3,-1		;[726] ANY BLOCKS LEFT?
	 JRST	USRSS1		;[746][726] NO - SKIP THIS STR
	TXNE	T4,DF.SWL	;[746][652] UNLESS SOFTWARE W/L STR
USRSS1:	 TDZA	T1,T1		;[746] INDICATE DONT CREATE SFDS
	  MOVEI	T1,1		;[746] FLAG TO CREATE SFDS
	SKIPN	U.SFDCREATE	;[757] USER WANT THEM CREATED?
	 MOVEI	T1,0		;[757] NO--FLAG NOT TO CREATE EVEN IF WE COULD
	PUSHJ	P,ENTPTH	;CREATE SFD'S AS NEEDED
	JRST	USRST1		;LOOP OVER ALL ACTICE STRS
USRST2:	HRREI	T1,.PTFSD	;FUNCTION TO SET DEFAULT PATH
	MOVEM	T1,PTHBUF+.PTFCN ;STORE IN ARGUMENT BLOCK
	SKIPGE	T1,U.SCAN	;SCAN SWITCH GIVEN
	MOVEI	T1,AD.YN	;NO--SETUP DEFAULT
	ADDI	T1,.PTSCN	;ADJUST TO START OF RANGE
	MOVEM	T1,PTHBUF+.PTSWT ;SAVE SWITCH IN ARGUMENT BLOCK
	MOVE	T1,[.PTMAX,,PTHBUF] ;DO THE PATH UUO TO SET
	PATH.	T1,		; DEFAULT PATH
	 PUSHJ	P,[WARN	CSP,<Can not set default path>
		   SETZM PTHBUF+.PTSFD	;CLEAR SFDS IN CASE THEY DIDNT EXIST
		   MOVE  T1,[.PTMAX,,PTHBUF];SETUP ARGS AGAIN
		   PATH. T1,		;ONE MORE TRY
		    WARN  CSS,<Can not set /SCAN switch> ;THAT LOST TOO
		   POPJ P,]		;WON! AT LEAST /SCAN GOT SET
	SETZM	PTHBUF+.PTSWT	;CLEAR THE SWITCHES
	SKIPN	LIBSPC+.FXDIR	;IF THERE IS NO LIB REQUESTED
	SETZM	PTHBUF+.PTPPN	;CLEAR THE LIB PPN
	HRREI	T1,.PTFSL	;CHANGE FUNCTION TO SET DEFAULT
	MOVEM	T1,PTHBUF+.PTFCN ; LIBRARY
	SKIPGE	T1,U.SYS	;WAS /SYS GIVEN?
	MOVEI	T1,AD.YN	;NO--SET DEFAULT
	JUMPE	T1,USRS2A	;JUMP IF NOSYS
	MOVX	T1,PT.SSY	;ELSE ADD SYS BIT
	IORM	T1,PTHBUF+.PTSWT ; INTO ARGUMENT
USRS2A:	SKIPGE	T1,U.NEW	;WAS /NEW GIVEN
	MOVEI	T1,AD.YN	;NO--SUPPLY ABSENT DEFAULT
	JUMPE	T1,USRS2B	;JUMP IF NONEW
	MOVX	T1,PT.SNW	;SET THE NEW BIT IN
	IORM	T1,PTHBUF+.PTSWT ; PATH. UUO ARGUMENT BLOCK
USRS2B:	SKIPN	T1,LIBSPC+.FXDIR ;GET LIB PPN
	JRST	USRS2C		;JUMP IF NONE
	TLNN	T1,-1		;[567] IS PROJECT # ZERO?
	  HLL	T1,PP		;[567] YES - USE USER'S
	TRNN	T1,-1		;[567] ZERO PROGRAMMER NO.?
	  HRR	T1,PP		;[567] DEFAULT TO USER'S OWN
	MOVEM	T1,PTHBUF+.PTPPN ;STORE PPN
	MOVX	T1,PT.LIB	;SET THE LIB BIT
	IORM	T1,PTHBUF+.PTSWT ;SET /LIB
USRS2C:	MOVE	T1,[.PTMAX,,PTHBUF] ;DO THE PATH UUO
	PATH.	T1,		; ..
	  JFCL			; ..
USRST3:	SKIPGE	T2,U.DFUL	;GET DISK FULL SWITCH
	JRST	USRST4		;JUMP IF NOT GIVEN
	CAIN	T2,DSKFER	;ERROR?
	MOVX	T1,.DFERR	;YES--SET ERROR ARG
	CAIN	T2,DSKFPA	;PAUSE?
	MOVX	T1,.DFPSE	;YES--SET THAT
	HRLI	T1,.STDFL	;SET FUNCTION
	MOVE	T2,['SDF',,[ASCIZ/disk full/]]
	PUSHJ	P,SETIT		;GO SET IT


USRST4:	SKIPN	T1,U.DPRI	;GET DISK PRIORITY
	JRST	USRST5		;NONE SPECIFIED
	LDB	T2,[POINTR PRIVWD,AC.DSP];Get value from ACCT.SYS
	JUMPE	T2,USRST5	;None allowed
	CAILE	T1,(T2)		;Is switch value within limits?
	MOVEI	T1,(T2)		;No, use ACCT.SYS value
	HRLI	T1,-2
	MOVE	T2,[.DUPRI,,T1]	;ARG POINTER
	DISK.	T2,		;DO THE UUO
	 WARN	SDP,<Can not set disk priority>
USRST5:	MOVE	T1,U.STA	;GET STATION
	CAME	T1,[-1]		;SEE IF SPECIFIED
	  JRST	USRSTL		;[633] ONE WAS SPECIFIED, USE IT
	MOVEI T1,.GTLOC		;[633] GETTAB FOR NODE # OF CENTRAL SITE
	GETTAB	T1,		;[633] GET CENTRAL SITE NODE NUMBER
	  JRST	USRS5A		;[633] MONITOR MUST NOT SUPPORT NETWORKS
	HRROI	T2,.GTLOC	;[633] THIS JOB'S LOCATION
	GETTAB	T2,		;[633] GET THAT
	  JRST	USRS5A		;[633] NO NETWORK SOFTWARE
	CAMN	T1,T2		;[633] ALREADY LOCATED AT CENTRAL SITE?
	JRST	USRS5A		;[633] YES, NO POTENTIAL PROBLEMS THEN
	MOVEM	T2,NODLOC	;[633] STORE THIS JOB'S LOCATION IN NODE BLOCK
	MOVEI	T2,4		;[633] LENGTH OF THE ARGUMENT BLOCK
	MOVEM	T2,NODLEN	;[633] STORE IN NODE UUO ARGUMENT BLOCK
	MOVEI	T2,.TYLPT	;[633] DEVICE TYPE
	MOVEM	T2,NODDEV	;[633] STORE THAT IN THE ARGUMENT BLOCK
	MOVE	T2,[.NDRCI,,NODBLK] ;[633] NODE UUO ARGUMENT
	NODE.	T2,		;[633] GET NODE CONFIGURATION INFORMATION
	  JRST	USRS5A		;[633] NOT IMPLEMENTED?
	HLRZ	T2,NODDEV	;[633] NUMBER OF LPT'S AT THIS NODE
	JUMPN	T2,USRS5A	;[633] JUMP IF THERE ARE SOME

;[633] IF NO LPT'S AT THIS NODE, LOCATE JOB AT CENTRAL SITE

USRSTL:	LOCATE	T1,
	 CAIN	T1,0		;FAILED--SEE IF FOR CENTRAL SITE
	  SKIPA			;OK OR FOR CENTRAL SITE
	   WARN	LUF,<LOCATE UUO failed>
USRS5A:	MOVE	T1,[.STDEF,,T2]	;[620] SETUUO FOR DEFAULTS
	HRRZI	T2,.STDPC	;[620] FUNCTION CODE FOR FILE PROTECTION
	SKIPGE	T3,U.DFPR	;[745][620] SWITCH SPECIFIED?
	  JRST	USRS5C		;[620] NO - SKIP THE SETUUO
	SETUUO	T1,		;[620] SET IT
	  JFCL			;[620] PROBABLY NOT IMPLEMENTED
;HERE TO SET DEFAULT FOR LOGIN TO ASK FOR ATTACH IF ANY DETACHED JOBS
USRS5C:	MOVE	T1,[.STDEF,,T2]
	MOVSI	T2,1
	HRRI	T2,.STDAD
	SKIPL	T3,U.ATT	;DID USER TYPE A /ATTACH SWITCH?
	CAIE	T3,ATTIGN	;YES. DID HE SAY TO IGNORE ATTACH PROMPTING?
	TDZA	T3,T3		;NO.  DEFAULT TO ASK
	SETOM	T3		;YES. SET JOB'S DEFAULT TO DON'T ASK
	SETUUO	T1,
	  JFCL			;NOT IMPLEMENTED YET
;HERE TO SET DEFAULT BUFFERS
	MOVE	T1,[.STDEF,,T2]	;[750] SETUP ARGS
	MOVEI	T2,.STDNB	;[750] SUBFUNCTION DEFAULT BUFFERS
	SKIPL	T3,U.DFBU	;[750] GET USERS SWITCH VALUE
	 SETUUO	T1,		;[750] DO IT IF HE GAVE IT
	  JFCL			;[750] NOT IMPLEMENTED OR NOT GIVEN
;HERE TO SET DEFAULT BIGBUF
	SKIPGE	T3,U.DFBB	;SEE IF BIGBUF GIVEN
	 JRST	USRST6		;NO
	HRLZS	T3		;POSITION TO LH FOR JOB-WIDE DEFAULT
	MOVE	T1,[.STDEF,,T2]	;SETUP ARGS
	MOVEI	T2,.STDSB	;SUBFUNCTION DEFAULT BIGBUF
	SETUUO	T1,		;DO IT IF HE GAVE IT
	 JFCL			;NOT IMPLEMENTED OR NOT GIVEN
;HERE TO SET CURRENT VM LIMITS
USRST6:	MOVE	T1,STATS2	;GET SECOND STATES WORD
	TXNN	T1,ST%VMS	;DO WE HAVE VM?
	JRST	USRST7		;NO--TRY NEXT THING
	MOVEI	T3,0		;PRESET ANSWER TO ZERO
	SKIPGE	T1,U.CVPL	;GET CURRENT VIRT LIMIT
	JRST	USRS6A		;NONE SUPPLIED
	PUSHJ	P,FIXPGS	;CONVERT TO PAGES
	HRL	T3,T1		;USER SUPPLIED ONE -- USE IT
USRS6A:	SKIPGE	T1,U.CPPL	;GET CURRENT PHYS LIMIT
	JRST	USRS6B		;NONE SUPPLIED--LEAVE ZERO
	PUSHJ	P,FIXPGS	;MAKE SURE WE HAVE PAGES
	HRR	T3,T1		;USER SPECIFIED ONE -- USE IT
USRS6B:	JUMPE	T3,USRST7	;JUMP IF NOTHING REQUESTED
	SKIPG	U.LIMIT		;SKIP IF /LIMIT
	SKIPN	U.GUID		;SKIP UNLESS /NOGUIDELINE GIVEN
	TRO	T3,400000	;SET THE BIT
	MOVE	T1,[.STCVM,,T3]	;ARGUMENT TO SET UUO
	MOVE	T2,['SCV',,[ASCIZ/current virtual and physical limits/]]
	PUSHJ	P,SETIT		;DO THE SETUUO

USRST7:	IFN	SETTTY,<	;[344]
	SKIPN	U.SETT		;[344] DID HE SAY /NOSETTY?
	JRST	USRST8		;[344] YES -- SKIP THE WHOLE BIT
	SKIPG	T1,U.SPED	;[344] DID HE SAY /SPEED:N?
	JRST	.+3		;[344] NOPE
	MOVEM	T1,U.RSPD	;[344] YES -- SET BOTH RCV AND XMIT
	MOVEM	T1,U.XSPD	;[344] SPEED TO N
;FIX UP STOP/SSTOP
	MOVEI	T1,1		;A BIT
	SKIPG	U.STOP		;STOP?
	 SKIPLE	U.SSTOP		;OR SSTOP?
	  MOVEM	T1,T.STOP	;YES--SET STOP
	SKIPLE	U.SSTOP		;SSTOP?
	 MOVEM	T1,T.SSTOP	;YES--SET SSTOP TOO
	MOVE	T1,[-TTLNTH,,TTAB] ;[472] TABLE OF PRE-NOTICE TRMOP.S
	PUSHJ	P,DOTRMP	;[472] DO THE TRMOP.S
	>			;[472] END IFN SETTTY



USRST8:	MOVEI	P1,DEVTAB	;[470] MAKE PTR TO LIST
	HLRE	T1,DEVPTR	;[470] GET -NUMBER OF WORD PAIRS LEFT
	ADDI	T1,DVICES*2	;[470] MAKE +NUMBER OF PAIRS USED
	JUMPL	T1,USRS8C	;[470] NO /ASSIGN SWITCH TYPED
	CAILE	T1,DVICES*2	;[470] TOO MANY?
	  MOVEI	T1,DVICES*2	;[631] YES - USE MAX
	LSH	T1,-1		;[470] HALVE BECAUSE WORD PAIRS
	MOVN	P2,T1		;[470] MAKE AOJL COUNTER
USRS8A:	SETZB	T1,T3		;[470] SET UP OPEN BLOCK
	MOVE	T2,(P1)		;[470] GET PHYSICAL NAME
	OPEN	UFD,T1		;[470] OPEN ON SOME RANDOM CHANNEL
	  JRST	NDEV		;[470] LOSE
	AOS	P1		;[470] BUMP POINTER
	MOVEI	T1,UFD		;[470] CHANNEL NUMBER
	SKIPN	T2,(P1)		;[470] PICK UP LOGICAL NAME
	  JRST	.+3		;[470] NONE - KEEP GOING
	DEVLNM	T1,		;[470] ASSIGN LOGICAL NAME
	  JRST	NODEV		;[470] LOST
	MOVE	T1,THSJOB	;[470] SET ASSCON BY REASSI
	MOVEI	T2,UFD		;[470] CHANNEL NUMBER
	REASSI	T1,		;[470] ZAP!
USRS8B:	CLOSE	UFD,		;[470] TIDY UP
	AOS	P1		;[470] BUMP POINTER
	AOJLE	P2,USRS8A	;[502] LOOP THRU DEVICE LIST

USRS8C:	POPJ	P,		;[470] ALL DONE


NODEV:	SOS	P1		;[470] DROP BACK TO POINT AT PHYS NAME
NDEV:	WARN	CAD,<Could not assign device >,,E.CAD
	JRST	USRS8B		;KEEP ON TRUCKIN

E.CAD:	MOVE	T1,(P1)		;GET PHYSICAL NAME
	PUSHJ	P,.TSIXN##	;TYPE IT
	AOS	P1		;BUMP POINTER
	SKIPN	(P1)		;LOGICAL NAME SPECIFIED?
	 POPJ	P,		;NO - DON'T TALK ABOUT IT
	MOVEI	T1,[ASCIZ/ logical name /]	;[470]
	PUSHJ	P,.TSTRG##
	MOVE	T1,(P1)		;GET LOGICAL NAME
	PUSHJ	P,.TSIXN##	;TYPE IT
	PJRST	.TSIXN##	;TYPE IT AND RETURN

;[472] ROUTINE TO DO POST-NOTICE TRMOP.S
POSTMS:	IFN	SETTTY,<	;[472]
	SKIPN	U.SETT		;[472] DID HE SAY /NOSETTTY?
	  POPJ	P,		;[556] YES- SKIP IT
	PUSHJ	P,WAITO		;[472] WAIT UNTIL OUTPUT BUFFER EMPTY
	MOVE	T1,[-PTLNTH,,PTAB] ;[472] TABLE OF POST-NOTICE TRMOP.S
	PUSHJ	P,DOTRMP	;[472] DO THEM UP
	>			;[472] END IFN SETTTY
	POPJ	P,		;[472]

	IFN SETTTY,<		;[556]
DOTRMP:	MOVE	P1,[XWD 3,T2]	;[472] SET UP ARG POINTER
TLOOP:	SETZ	P2,		;[344] CLEAR FLAGS
	HLRZ	T4,(T1)		;[344] GET ADDR OF ARG FOR TRMOP.
	MOVE	T4,(T4)		;[344] GET ACTUAL ARGUMENT
	CAMN	T4,[-1]		;[675] IF -1,
	JRST	LEAVE		;[675]  SCAN DIDN'T TOUCH IT
	HRRZ	T2,(T1)		;[344] GET TRMOP. FUNCTION CODE & FLAGS
	TRZE	T2,TF.CMP	;[344] CLEAR FLAGS OUT OF T2 SO IT
	TRO	P2,TF.CMP	;[344] WILL BE A REAL TRMOP. CODE
	MOVE	T3,TTYUDX	;[344] GET TTY UDX
	TRNE	P2,TF.CMP	;[344] COMPLEMENT ARGUMENT?
	TRC	T4,1		;[344] YUP
	TRMOP.	P1,
	  JRST	WHA		;[344] OOPS -- CHECK IT OUT
LEAVE:	AOBJN	T1,TLOOP	;[344] GO ROUND AGAIN
FORGET:	POPJ	P,		;[475] ALL DONE
	>			;[470] END IFN SETTTY


	IFN	SETTTY,<	;[556]
;[344] HERE IF TRMOP. UUO FAILS
WHA:	CAIN	P1,TOPRC%	;[344] NOT PRIVILEGED?
	JRST	IGNORE		;[344] ACT LIKE IT DIDN'T HAPPEN
	JUMPE	P1,IGNORE	;[344] IF FUN. NOT IMPLEMENTED, IGNORE
	CAMN	P1,[XWD 3,T2]	;[344] IF UUO NOT IMPLEMENTED, FORGET
	JRST	FORGET		;[475] THE WHOLE THING
	PUSH	P,T1		;[375] WATCH OUT FOR T1
	HRRZ	T1,(T1)		;[675] PICK UP FUNCTION CODE
	CAIN	T1,.TOTRM+1000	;[675] TRYING TO SET TERMINAL TYPE
	JRST	NOTTYP		;[675] YES, NO SUCH TTY TYPE
	WARN	TUF,<TRMOP. UUO failed. Function code = >,,.TOCTW##
	POP	P,T1		;[677] GET T1 BACK AGAIN

IGNORE:	MOVE	P1,[XWD 3,T2]	;[344] RESTORE POINTER
	JRST	LEAVE		;[344] AND RETURN

;[675] TERMINAL TYPE INVALID ERROR
NOTTYP:	POP	P,T1		;[677]  GET T1 BACK AGAIN
	WARN	TTI,<Terminal type invalid;  Using defaults>
	JRST	IGNORE		;[744] AND RETURN

;[367] ROUTINE TO SLEEP UNTIL FINISHED OUTPUTTING ON TTY
WAITO:	MOVEI	P1,^D120	;[475] WAIT FOR TTY OUTPUT FOR 2 MIN.
WAITO1:	MOVE	T1,[XWD 2,T2]	;[553] SET UP POINTER FOR TRMOP.
	MOVEI	T2,.TOSOP	;[367] SKIP IF OUTPUT BUFFER NON-EMPTY
	MOVE	T3,TTYUDX	;[367] OUR UNIVERSAL I/O INDEX
	TRMOP.	T1,		;[367] IF OUTPUT BUFFER EMPTY OR TRMOP.
	  POPJ	P,		;[367] FAILS, ASSUME OK AND RETURN
	MOVEI	T4,1		;[367] SLEEP FOR ONE SECOND
	SLEEP	T4,
	SOJG	P1,WAITO1	;[553] IF STILL PATIENT, KEEP SLEEPING
	POPJ	P,		;[475] WAITED TOO LONG - GIVE UP

	>			;[357] END IFN SETTTY

	SUBTTL	Set user parameters -- subroutines

;SUBROUTINE TO DO A SET UUO
;CALL WITH:
;	T1 = SET UUO ARGUMENT
;	LH(T2) =  3 LETTER CODE IN SIXBIT
;	RH(T2) = ADDRESS OF ASCIZ STRING
;	PUSHJ	P,SETIT
;	RETURN HERE IN ALL CASES
SETIT:	SETUUO	T1,		;SET THE PARAMETER
	  SKIPA			;LOST--PRINT MESSAGE
	POPJ	P,0		;WORKED--RETURN
	PUSH	P,T2		;SAVE T2
	PUSHJ	P,NEWLIN	;START WITH CLEAN LINE
	MOVEI	T1,[ASCIZ/%LGN/] ;PRINT PREFIX
	PUSHJ	P,.TSTRG##	; ..
	HLLZ	T1,(P)		;COPY 3 LETTER CODE
	PUSHJ	P,.TSIXN##	;PRINT THAT OUT
	MOVEI	T1,[ASCIZ/ SETUUO failed attempting to set /]
	PUSHJ	P,.TSTRG##	;TYPE THE FIRST STUFF
	HRRZ	T1,(P)		;COPY REST OF STRING
	PUSHJ	P,.TSTRG##	;PRINT IT
	POP	P,T2		;CLEAN UP STACK
	PJRST	.TCRLF##	;ADD A CRLF
;SUBROUTINE TO CONVERT CORE ARGUMENT TO PAGES
;CALL WITH:
;	MOVE	T1,ANSWER-FROM-.SWCOR
;	PUSHJ	P,FIXPGS
;	RETURN HERE # OF PAGES IN T1
;USES NO AC'S
FIXPGS:	CAIG	T1,^D512	;JUST A NUMBER?
	IMULI	T1,^D1024	;YES--CONVERT TO WORDS
	LSH	T1,-9		;CONVERT TO PAGES
	POPJ	P,0		;RETURN
;LOWSEG STUFF FOR LGNSET
	XLIST
	LIT
	LIST

	RELOC
IPCFLG:	BLOCK	1		;IPCF FLAGS
FMPID:	BLOCK	1		;MY PID
TOPID:	BLOCK	1		;SENDER'S PID
IPCPTR:	BLOCK	1		;POINTER TO MESSAGE
IPCMSG:	BLOCK	1		;FUNCTION FOR [SYSTEM]IPCF TO DO
IPCJOB:	BLOCK	1		;JOB TO DO IT TO
IPCQTA:	BLOCK	1		;IPCF QUOTA
NODBLK:
NODLEN:	BLOCK	1		;[633] LENGTH OF NODE UUO ARGUMENT BLOCK
NODLOC:	BLOCK	1		;[633] NODE NUMBER
	BLOCK	1		;[633] RESERVED ARGUMENT
NODDEV:	BLOCK	1		;[633] NUMBER OF DEVICES,,DEVICE TYPE
	PRGEND
	TITLE	LGNIO - Input output module for LOGIN

	SEARCH	UUOSYM,MACTEN,SCNMAC,LGNUNV,ACTSYM,UFDPRM
	LGNDCL

; Initialize terminal
TTYINI::PUSH	P,T1			;SAVE T1
	SETZM	TTYBUF##		;CLEAR FIRST WORD OF BUFFER
	MOVE	T1,[TTYBUF##,,TTYBUF##+1] ;SET UP BLT
	BLT	T1,TTYBUF##+TTYBSZ-1	;CLEAR OUR BUFFER
	MOVE	T1,[POINT 7,TTYBUF##]	;SET UP
	MOVEM	T1,TTYPTR##		; BYTE POINTER
	MOVEI	T1,<TTYBSZ*5>-1		;SET UP
	MOVEM	T1,TTYCNT##		; BYTE COUNT
	POP	P,T1			;RESTORE T1
	POPJ	P,			;AND RETURN


; Output entire buffer
TTYOUT::TLNE	F,FL.DET		;DETACHED?
	SETZM	TTYBUF			;YES--NEVER DO OUTPUT
	SKIPE	TTYBUF##		;ANYTHING IN BUFFER?
	OUTSTR	TTYBUF			;YES--DUMP IT
	PJRST	TTYINI			;RESET POINTER AND COUNT


; Output a character
TTYTYO::SOSGE	TTYCNT			;COUNT CHARACTERS
	PUSHJ	P,TTYOUT		;BUFFER FULL--OUTPUT
	IDPB	CH,TTYPTR		;STORE CHARACTER
	CAIN	CH,.CHCRT		;CARRAGE RETURN?
	SETZM	HPOS			;YES--BACK TO START OF LINE
	CAIL	CH," "			;CONTROL CHARACTER?
	AOS	HPOS			;NO--UPDATE POSITION
	CAIN	CH,.CHLFD		;LINE FEED?
	PJRST	TTYOUT			;YES--FORCE BUFFER OUT
	POPJ	P,			;RETURN


; Output a prompt and force output
TTYPMT::PUSH	P,T1			;SAVE PROMPT TEXT
	PUSHJ	P,NEWLIN		;TYPE A CRLF IF NEEDED
	POP	P,T1			;RESTORE T1
	PUSHJ	P,.TSTRG##		;TYPE PROMPT STRING
	PJRST	TTYOUT			;FORCE OUTPUT


; Set terminal echo status
TTYECH::SKIPA	T1,[TXZ	T1,GL.NEC]	;ECHO
TTYNEC::MOVE	T1,[TXO	T1,GL.NEC]	;NO ECHO
	PUSH	P,T1			;SAVE INSTRUCTION
	MOVNI	T1,1			;-1 FOR OUR LINE
	GETLCH	T1			;GET LINE CHARACTERISTICS
	XCT	(P)			;SET OR CLEAR ECHO
	SETLCH	T1			;SET LINE CHARACTERISTICS
	POP	P,(P)			;TRIM STACK
	POPJ	P,			;RETURN
;SUBROUTINE TO INPUT CHARS TO 1ST NON-SIXBIT CHAR - SAVE 2 WORDS OF CHARS
;VALUES	T1,T2=SIXBIT CHARS
;	CH=TERMINATING CHAR
;	FL.BRK BIT IN LH F=1 IF TERMINATING CHAR IS A BREAK CHAR

GET2WD:	PUSHJ	P,.SAVE1##	;SAVE P1
	SETZB	T1,T2
	MOVE	P1,[POINT 6,T1]
GETNL:	PUSHJ	P,.TICHE##	;GET A CHAR. WITH THE RIGHT
				; AMOUNT OF CONVERSION.
	JUMPLE	C,.POPJ##	;[456] JUMP IF END OF LINE
	CAIL	C,"A"+40	;CONVER LOWER CASE
	CAILE	C,"Z"+40	; TO UPPER CASE
	SKIPA
	SUBI	C,40	
	MOVEI	CH,-40(C)	;CONVERT TO SIXBIT
	CAME	P1,[600,,T2]	;POINTER EXPIRED
	IDPB	CH,P1		;NO--STASH AWAY
	JRST	GETNL		;GET THE NEXT CHAR
;SUBROUTINE TO DETERMINE IF JOB NUMBER IN T1 IS A BATCH JOB
;ARGS	T1=JOB NUMBER
;RETURN	.POPJ IF JOB IS NOT BATCH
;	.POPJ1 IF JOB IS BATCH

ISBATC:	HRLZ	T4,T1
	HRRI	T4,.GTLIM	;[602] GETTAB INDEX FOR JBTLIM
	GETTAB	T4,		;[602] GET BITS
	  SETZ	T4,
	TXNN	T4,JB.LBT	;[602] BATCH JOB?
	  POPJ	P,		;[602] NO
	JRST	.POPJ1##	;[602] YES - SKIP RETURN

;[333] SUBROUTINE TO DETERMINE WHETHER THIS JOB IS A SUBJOB OF OPSER.
;[333] RETURN	POPJ IF NOT
;[333]		POPJ1 IF IT IS

ISOPSR:	SETO	T1,		;[333,340] THIS JOB
	CTLJOB	T1,		;[333] WHO CONTROLS ME?
	  POPJ	P,		;[333] I DUNNO
	MOVE	T2,T1		;[404] REMEMBER CNTRL JOB NO.
	TRMNO.	T1,		;[333] WHERE'S HIS TTY AT?
	  POPJ	P,		;[333,340] DUNNO
	GETLCH	T1		;[333,341] WHAT KIND OF TERMINAL
	TXNE	T1,GL.ITY	;[333] PTY?
	POPJ	P,		;[333,340] YES--PROBABLY BATCON
	HRLZ	T1,T2		;[337,340,404] GET JOB NO.
	HRRI	T1,.GTPRG	;[333] SET UP FOR GETTAB
	GETTAB	T1,		;[333] GET PROGRAM NAME
	  POPJ	P,		;[333] A REAL LOSER
	CAME	T1,[SIXBIT /OPSER/]
	POPJ	P,
	JRST	.POPJ1##
STYO:	MOVE	CH,T1		;CHARACTER OUTPUT FOR SCAN & WILD
TYO:	JRST	TTYTYO

TYI:	PUSHJ	P,.TIAUC##	;GET CHAR BY SCAN'S SUBROUTINE
	MOVE	CH,C		;[331] COPY CHAR
	POPJ	P,
;SUBROUTINE TO GET ONE CHAR AND BOMB USER FOR BEING
; SLOW.
;
;CALLED ONLY FROM SCAN -- MAY CHANGE NO AC'S

TTYGET:	PUSHJ	P,.SAVE2##	;SAVE P1 AND P2
	SKIPN	FL2741		;IS THIS A 2741?
	TRNE	F,R.PTYJ	;PTY JOB?
	JRST	TTGET2		;YES -- GO INTO TI WAIT
	MOVEI	P2,TTYSLP	;NUMBER OF MINS. TO SLEEP
TTGET1:	SKPINL			;ANYTHING THERE??
	  SKIPA			;NO--LOOP
	JRST	TTGET2		;YES--GO GET IT
	MOVE	P1,[HB.RTL!HB.RWJ!^D60000]
	HIBER	P1,		;HIBER FOR 1 MIN.
	  JRST	TTGET2		;TINY MONITOR
	SKPINL
	  SKIPA
	JRST	TTGET2
	SOJG	P2,TTGET1	;LOOP FOR A WHILE
	FATAL	(WFS,<Waiting for >,EF.SIL,HELPR)

TTGET2:	INCHWL	C		;GET A CHAR. INTO C
	CAIE	C,.CHCNC	;CONTROL-C?
	CAIN	C,.CHCNZ	;[343] OR CONTROL-Z?
	PJRST	RICC##		;YES--GO EXIT
	CAIN	C,.CHCRT	;IS IT A CARRAGE RETURN?
	SETZM	HPOS		;YES--UPDATE HORIZ. POSITION
	CAIL	C," "		;PRINTING CHARACTER?
	AOS	HPOS		;YES--UPDATE HORIZ POSITION
	POPJ	P,		;RETURN


;HERE IF USER DOES NOT TYPE ANYTHING WITHIN 2 MIN.
HELPR:	MOVE	T1,HELP		;POINT TO HELP TEXT
	PUSHJ	P,.TSTRG##	;TYPE IT
	MOVEI	T1,[ASCIZ /; please start over/]
	PJRST	.TSTRG##	;TYPE END OF ERROR AND RETURN


; SUBROUTINE TO PROMPT FOR A PPN
GIVNBR::PUSHJ	P,NEWLIN	;GIVE A CRLF IF NEEDED
	MOVEI	CH,[ASCIZ /project-programmer number/]
	MOVEM	CH,HELP		;STORE REASON FOR WAITING
				;FALL INTO SCNPMT


; SUBROUTINE TO PROMPT.  CALLED FROM SCAN
SCNPMT::PUSHJ	P,TTYECH	;SET TTY ECHO
	TLNE	F,FL.BAT	;ARE WE A BATCH JOB?
	FATAL	(EIB,<Error in BATCON - LOGIN aborted>)
	MOVEI	T1,"#"		;ALWAYS PROMPT WITH "#" WHETHER
	PUSHJ	P,.TCHAR##	;FIRST OR CONTINUATION LINE
	PJRST	TTYOUT		;FORCE OUTPUT AND RETURN


;SUBROUTINE TO TYPE A CRLF IF ONE IS NEEDED
NEWLIN:	SKIPN	HPOS		;IS A CRLF NEEDED?
	POPJ	P,0		;NO--JUST RETURN
	PJRST	.TCRLF##	;YES--GO TYPE ONE
	SUBTTL	LOGIN messages

	MSGOK==1		;FLAG TO TYPE MEESSAGE EVEN IF USER
				; HAS SEEN IT.
	FNAME==2		;FLAG TO REQUEST FILE NAME PRINTING
	STONLY==4		;[357] FLAG TO PRINT STR NAME ONLY

;HERE TO PRINT RANDOM FILES USER GETS ON LOGIN

DAYMES:	PUSHJ	P,.SAVE1##	;SAVE P1
	MOVE	T1,PPN		;GET PPN
	TLNE	F,FL.WLD	;WILD PPN?
	 INFO	LIA,<You are logged in as >,,.TXWDW##
	MSTIME	T1,		;GET TIME OF DAY
	IDIVI	T1,^D60000	;TO MINUTES
	IDIVI	T1,^D60		;NOW BREAK IN MINS AND HRS
	PUSH	P,T2		;SAVE MINUTES
	MOVEI	T2,"0"		;[754] ZERO FILL
	PUSHJ	P,.TDEC2##	;[754]TYPE HOURS
	PUSHJ	P,.TCOLN##	;TYPE A COLON
	POP	P,T1		;[754]MINUTES
	MOVEI	T2,"0"		;[754] ZERO FILL
	PUSHJ	P,.TDEC2##	;[754]TYPE
	PUSHJ	P,.TTABC##	;TAB
	PUSHJ	P,.TDATN##	;[754] And current date
	PUSHJ	P,.TTABC##
	MOVE	T1,SAVEDA	;DAY OF WEEK
	MOVEI	T1,WEEKDA(T1)
	PUSHJ	P,.TSTRG##	;TYPE DAY OF WEEK
	PUSHJ	P,.TCRLF##

	MOVEI	T1,2		;[454] GET DEFAULT FOR /NOTICE
	MOVE	P1,U.NOTC	;[453] GET SWITCH TYPED
	AOSN	P1		;[453] WAS A SWITCH TYPED?
	  MOVEM	T1,U.NOTC	;[453] NO - USE DEFAULT
	MOVEI	T1,NOTSPC	;[362] /NOTE FILESPEC
	MOVEI	P1,FNAME	;[362] PRINT FILE NAME
	PUSHJ	P,TYPE		;[362] TYPE IT
	PUSHJ	P,ISOPSR	;[333] IS THIS AN OPSER SUBJOB?

DIEMSG:	SKIPA	T1,[DAYSPC]	;[333,337] NO--PRINT NOTICE.TXT
	POPJ	P,0		;[662] [333] YES--DON'T PRINT IT
	TRNE	F,R.SESSION	;[754] SESSION Command?
	 POPJ	P,		;[754] Yes--No message for him either
	MOVEI	P1,0		;FLAGS
	PJRST	TYPE		;GO PRINT IT AND RETURN

;[662]	CREATE SEPERATE /STR PRINTER
STRMES::SKIPG	U.STR		;/STR GIVEN
	POPJ	P,0		;NO--RETURN
	MOVEI	T1,STRSPC	;STR.TXT SPEC
	MOVEI	P1,MSGOK!FNAME!STONLY	;[357] OK TO TYPE MESSAGE
	PJRST	TYPE		;PRINT IT

;FILE SPEC FOR SYS:NOTICE.TXT/PHYSICAL/NOSTR
DAYSPC:	SIXBIT	/SYS/
	SIXBIT	/NOTICE/
	EXP	-1
	XWD	'TXT',-1
	EXP	FX.PHY!FX.NOM
	EXP	FX.STR!FX.PHY!FX.NOM
	BLOCK	.FXLEN-<.-DAYSPC>

;FILE SPEC FOR SYS:STR.TXT/PHYSICAL/STRS
STRSPC:	SIXBIT	/ALL/
	SIXBIT	/STR/
	EXP	-1
	XWD	'TXT',-1
	EXP	FX.PHY!FX.STR
	EXP	FX.PHY!FX.STR
	XWD	1,4
	XWD	-1,-1
	BLOCK	.FXLEN-<.-STRSPC>
;SUBROUTINE TO TYPE A FILE
;CALL WITH:
;	MOVEI	T1,ADDRESS-OF-SCAN-STYLE-FILESPEC
;	MOVEI	P1,FLAGS
;	PUSHJ	P,TYPE
;	RETURN HERE
TYPE:	SKIPN	.FXNAM(T1)	;[512] ANY NAME OR MASK SPECIFIED?
	  POPJ	P,		;[512] NO - SKIP IT
	HRLZ	T1,T1		;FLIP AROUND
	HRRI	T1,TYPSPC	;ADDRESS OF OUT SPEC
	BLT	T1,TYPSPC+.FXLEN-1 ;[436] COPY THE FILESPEC
	SETZM	WLDPNT		;CLEAR MEMORY FOR FIRST CALL
	MOVX	T1,FX.NOM!FX.PRT ;/OKNONE AND /OKPROT
	IORM	T1,TYPSPC+.FXMOD;FORCE SWITCH TO BE
	IORM	T1,TYPSPC+.FXMOM; SET ON ALL CALLS TO WILD
TYPE1:	MOVE	T1,[4,,[[TYPSPC],,0
			UFDBUF,,SECBUF
			.FXLEN,,.RBPRV+1
			UFD,,WLDPNT]]
	MOVX	T2,.IOASC	;SET UP ASCII MODE
	MOVEM	T2,UFDBUF	; ..
	PUSHJ	P,.LKWLD##	;LOOK FOR FILE
	  POPJ	P,0		;ALL DONE
	MOVEI	T1,B.DC##	;SET UP ADDRESS OF BUFFER HEADER
	MOVEM	T1,UFDBUF+2	; ..
	OPEN	UFD,UFDBUF	;OPEN THE FILE
	  PJRST	E.DFO##		;CAN'T
	LOOKUP	UFD,SECBUF	;LOOKUP FILE
	JRST	[PUSHJ P,E.DFL## ;REPORT ERROR
		 JRST  TYPE1]	;LOOK FOR NEXT FILE
IFN SUPNOT,<
	TRNE	P1,MSGOK	;WANT MESSAGE ALWAYS?
	JRST	TYPE3		;YES--GO TYPE IT
	SKIPE	UFDNDL		;SKIP IF UFD CAN BE DELETED
	JRST	TYPE2		; SAW THE MESSAGE
	LDB	T1,[POINTR(SECBUF+.RBPRV,RB.CRD)]
	LDB	T2,[POINTR(SECBUF+.RBEXT,RB.CRX)] ;GET TOP 3 BITS OF DATE
	LSH	T2,^D12		;MOVE OVER TO CORRECT PLACE
	IORI	T1,(T2)		;COMBINE
	CAMLE	T1,UFDDAT	;IS FILE NEWER THAN UFD?
	JRST	TYPE3		;YES--PRINT ANYWAY
	CAME	T1,UFDDAT	;SAME DAY?
	JRST	TYPE2		;NO--DISTINCTLY OLDER
	LDB	T2,[POINTR(SECBUF+.RBPRV,RB.CRT)]
	CAML	T2,UFDTIM	;IS MESSAGE NEWER THAN UFD
	JRST	TYPE3		;YES--GO PRINT
TYPE2:	MOVE	T1,U.NOTC	;[450] GET /NOTICE VALUE
	CAIL	T1,2		;[450,453] SOMETIMES OR NEVER?
	JRST	TYPE1		;[453] YES -LOOK FOR NEXT FILE
>
TYPE3:	MOVE	T1,U.NOTC	;[450] GET /NOTICE VALUE
	CAIN	T1,3		;[450] NEVER PRINT?
	  JRST	TYPE1		;[450] YES - SKIP IT
	TXNE	P1,FNAME	;WANT TO SEE FILE NAME?
	PUSHJ	P,TYPFIL	;TYPE THE FILE SPEC
TYPE4:	PUSHJ	P,.NXDTW##	;GET A BYTE
	  JRST	TYPE1		;END OF FILE
	PUSHJ	P,.TCHAR##	;TYPE IT
	JRST	TYPE4
;SUBROUTINE TO TYPE A FILESPEC
;CALL WITH:
;	UFDBUF = OPEN BLOCK
;	SECBUF = LOOKUP BLOCK
;	PUSHJ	P,TYPFIL
;	RETURN HERE
TYPFIL:	PUSHJ	P,NEWLIN	;[377] DON'T DOUBLE-SPACE
	MOVE	T1,UFDBUF+1	;GET DEVICE NAME
	PUSHJ	P,.TSIXN##	;TYPE IT
	PUSHJ	P,.TCOLN##	;TYPE IT
	TXNE	P1,STONLY	;[357] ONLY WANT STR NAME?
	PJRST	.TSPAC##	;[357] YES -- FINISH UP
	MOVE	T1,SECBUF+.RBNAM ;GET FILE NAME
	PUSHJ	P,.TSIXN##	;TYPE IT
	MOVEI	T1,"."		;TYPE A DOT
	PUSHJ	P,.TCHAR##	;TYPE THE DOT
	HLLZ	T1,SECBUF+.RBEXT;TYPE THE EXTENSION
	PUSHJ	P,.TSIXN##	;TYPE EXTENSION
	MOVEI	T1,SECBUF+.RBPPN;POINT TO PPN
	PUSHJ	P,.TDIRB##	;PRINT IT
	PJRST	NEWLIN		;START A NEW LINE AND RETURN

	SUBTTL	I/O subroutines

RDUFD:	SKIPGE	WD,RDHED
	JRST	RDUFD1		;ALREADY READING
	MOVE	WD,[IOWD 200,UFDBUF]
	MOVEM	WD,RDHED
	SETZM	RDHED+1
	TLNE	F,FL.ACC	;SKIP IF READING AUXACC.SYS
	AOS	ACCKNT		;KEEP COUNT OF BLOCKS READ ON ACCT.SYS
	IN	UFD,RDHED
	  JRST	RDUFD1		;[562] ALL SET
	STATO	UFD,IO.EOF	;[562] END OF FILE?
	  JRST	NOSYS		;[562] NO - ANYTHING ELSE IS FATAL
	POPJ	P,0		;YES. NONSKIP RETURN

RDUFD1:	AOBJN	WD,.+1		;NEXT WORD
	MOVEM	WD,RDHED
	MOVE	WD,0(WD)	;GET DATUM

IFE	FASTLG,<
	TLON	F,FL.RAS	;FIRST WORD?
	JRST	RDUFD2		;YES. GO MAKE SPECIAL CHECKS
>
IFN	FASTLG,<
	TLO	F,FL.RAS	;JUST SET IT, NO SKIP
>
	AOS	0(P)		;SKIP RETURN
	POPJ	P,0


	IFN	PSWCHG,<		;[557]

;ROUTINE TO UPDATE ACCT.SYS IN PLACE WITH NEW PASSWORD
;WE SIMPLY ENTER ACCT.SYS IN UPDATE MODE AND REWRITE
;THE RELEVANT BLOCK WITH THE NEW PASSWORD
;CAUTION - WTHED IS USED FOR TWO DIFFERENT THINGS:
;THE I/O CMD LIST FOR WRITING ACCT.SYS IF IT CAN BE ENTERED,
;OR THE NUMBER OF TIMES LEFT TO RETRY IF IT CAN'T

WTUFD:	MOVEI	T1,^D60		;[557] # OF TIMES TO RETRY
	MOVEM	T1,WTHED	;[557] SAVE IT AWAY
	PUSHJ	P,CLRRIB	;[557] CLEAR EXTENDED LOOKUP BLOCK
	MOVE	T1,[SIXBIT /ACCT/]
	MOVEM	T1,SECBUF+.RBNAM
	MOVSI	T1,(SIXBIT /SYS/)
	MOVEM	T1,SECBUF+.RBEXT
	MOVE	T1,SYSPPN
	MOVEM	T1,SECBUF+.RBPPN
	MOVEI	T1,.RBTIM	;[557] GET ARG COUNT
	MOVEM	T1,SECBUF+.RBCNT
	LOOKUP	UFD,SECBUF	;[557] LOOK IT UP
	  JRST	NOSYS		;[557] THIS IS FATAL
	MOVE	T1,W.ACCT	;[557] GET LAST CREATION DATE-TIME
	CAME	T1,SECBUF+.RBTIM;[557] CHANGED?
	   JRST	NOPE		;[557] YES - DON'T TRY ANYTHING THEN
	HLLZ	T1,SECBUF+.RBEXT
	MOVEM	T1,SECBUF+.RBEXT
	MOVSI	T1,777000	;[557] MASK ALL BUT PROTECTION BITS
	ANDM	T1,SECBUF+.RBPRV;[557] ..

AGAIN:	ENTER	UFD,SECBUF	;[557] TRY TO ENTER FOR UPDATE
	  JRST	ANALYZ		;[557] FIGURE OUT WHAT HAPPENED
	MOVE	T1,SAVBLK	;[624] GET DESIRED BLOCK NUMBER
	USETI	UFD,(T1)	;[557] SET UP TO READ IT
	MOVE	T1,[IOWD 200,UFDBUF]
	MOVEM	T1,WTHED	;[557] SET UP I/O CMD LIST
	SETZM	WTHED+1		;[557] ..
	IN	UFD,WTHED	;[557] READ THE BLOCK
	 SKIPA			;[557] OK
	  JRST	NOSYS		;[557] THIS SHOULD NEVER HAPPEN


;****STILL IN IFN PSWCHG

	MOVE	T2,SAVPOS	;[557] GET POINTER TO WORD WITHIN BLOCK
	MOVE	T1,(T2)		;[624] GET PSWD FROM FILE
	MOVE	P1,CODE		;[651] GET PSWD WE LOGGED IN WITH
	CAME	T1,P1		;[557] SAME AS ONE WE LOGGED IN WITH?
	  JRST	NOPE		;[557] NO - DON'T TRY ANYTHING
	MOVE	T1,ENTRY+.ACPSW	;[557] GET NEW PSWD
	MOVEM	T1,(T2)		;[624] REPLACE OLD ONE
	MOVE	T1,SAVBLK	;[624] GET BLOCK TO WRITE
	USETO	UFD,(T1)	;[557] SELECT IT
	OUT	UFD,WTHED	;[557] WRITE IT
	  JRST	WTUFD1		;[624] ALL SET
NOPE:	WARN	CCP,<Couldn't change password>
WTUFD1:	CLOSE	UFD,0		;[624] FINISH UP AND
	POPJ	P,		;[557] RETURN


ANALYZ:	HRRZ	T1,SECBUF+.RBEXT;[557] GET ERROR CODE
	CAIE	T1,ERFBM%	;[557] FILE BEING MODIFIED?
	  JRST	NOPE		;[557] NO - GIVE UP
	SOSGE	WTHED		;[557] COUNT DOWN TIMER
	  JRST	NOPE		;[557] LOST PATIENCE
	MOVEI	T1,1		;[557] SLEEP FOR
	SLEEP	T1,		;[557] ONE SECOND
	JRST	AGAIN		;[557] KEEP GOING
	>			;[557] END IFN PSWCHG

IFE	FASTLG,<
RDUFD2:	HRRZM	WD,ENTSIZ	;SAVE SIZE OF ENTRIES
	HLRZS	WD
	CAIL	WD,ACC506	;[356] 
	CAILE	WD,ACC602	;[356] 
	JRST	LGNWFV
	CAIN	WD,ACC601
	SETOM	NEWACT		;FLAG WE HAVE THE NEW FORMAT
	POP	P,0(P)		;REMOVE SUBR ENTRY
	JRST	RDACCT		;AND TRY AGAIN TO READ A BLOCK
>;*** END OF CONDITIONAL ON FASTLG

WEEKDA:	ASCIZ	.Wed.
	ASCIZ	.Thur.
	ASCIZ	.Fri.
	ASCIZ	.Sat.
	ASCIZ	.Sun.
	ASCIZ	.Mon.
	ASCIZ	.Tue.

	PRGEND
	TITLE	LGNERR - Error messages and typeout for LOGIN

	SEARCH	UUOSYM,MACTEN,SCNMAC,LGNUNV,ACTSYM,UFDPRM

	LGNDCL

	SUBTTL	Error conditions

PPERR1:	TDNE	F,[FL.BAT,,R.SESSION];BATCH JOB OR SESSION COMMAND?
	 JRST	TRYAGN		;YES--DONT MAKE BATCON UNHAPPY GOING INTO TI
	PUSHJ	P,CODGET	;GET PSW TO MAKE IT LOOK GOOD
	IFN	NCRYPT,<	;[755] NEED TO ENCODE THIS PASSWORD?
	MOVE	P1,T1		;[755] SET UP FOR HASHING ROUTINE
	PUSHJ	P,ENCODE##	;[755] DO THE HASHING
	MOVE	T1,P1		;[755] GET CODE BACK IN T1
	>;[755] END OF IFN NCRYPT
	MOVEM	T1,CODE		;SAVE THE PASSWORD HE TRIED

BADNAM:			;ALL SAME ERROR, SO DONT HELP HACKERS
TRYAGN:	MOVE	T2,TTBITS	;[625] GET BITS FOR CNTRLNG TTY
	TXNN	T2,GL.DSL!GL.ITY;[625] DATASET OR PTY?
	  JRST	ERR1		;[625] NO - DON'T SLEEP, THEN
	MOVEI	T2,3		;[625] YES - SLEEP TO MAKE IT HARD
	SLEEP	T2,		;[625] TO BREAK SECURITY

ERR1:
IFE FAILOG,<
	TLNE	F,FL.ATT	;ATTACHING?
	JRST	NOATT		;YES--NO RETRIES ALLOWED
> ;END IFE FAILOG

IFN	FAILOG,<
	PUSHJ	P,ACCTA		;SETUP FACT FILE ENTRY FOR FAILURE
	MOVE	T1,FCTFMD	;MOD HEADER FOR FAILURE TYPE AND EXTENDED LEN
	ADDM	T1,FCTDAT
	MOVE	T1,CODE		;THIS IS THE PASSWORD HE TRIED
	MOVEM	T1,FCTDAT+3	;HANG ONTO IT
	MOVE	T1,CNTLJP	;THIS IS THE PPN OF THE CONTROL JOB
	MOVEM	T1,FCTDAT+4
	MOVE	P2,FCTFWD	;GET FAILURE HEADER WORD
	PUSHJ	P,.FACTR##	;[623] STICK THE WHOLE THING INTO FACT.SYS
	TLNE	F,FL.ATT	;ATTACH?
	JRST	NOATT		;YES, NO RETRIES
>;END OF CONDITIONAL ON FAILOG
	FATAL	(IET,<Invalid entry - Try again>,EF.FMT)
NOATT:	FATAL	CAJ,<Can't ATTACH to job>,EF.SIL

NOSYS:	TLNE	F,L.OPR!L.SOPR	;SKIP IF NOT OPR OR SON OF OPR
	JRST	PSWOK		;CTY OR OPR CAN LOGIN EVEN IF NO ACCT.SYS
	STOP	CAF,<Can't access system files>,EF.WTO
	STOP	WFV,<Wrong format version number in system files>,EF.WTO

FLUSH:	PUSHJ	P,.CLRBF##	;CLEAR TYPE-AHEAD
	PUSHJ	P,.ISLGI##	;ARE WE LOGGED IN?
	  SKIPA	T1,[KLGMSG]	;POINT TO KJOB TEXT
	JRST	FLUSHX		;YES--GO FINISH UP
	PUSHJ	P,.TSTRG##	;TYPE TEXT
	PUSHJ	P,TTYOUT##	;FORCE OUTPUT
	TRNN	F,R.DBUG	;DEBUGGING?
	SKIPLE	LOGTRY		;FAILED SEVERAL TIMES TO LOGIN?
	JRST	FLUSHX		;DON'T DISCONNECT THE LINE
	MOVEI	T1,3		;WAIT A BIT SO THE
	SLEEP	T1,		; KJOB TEXT GETS OUT
	MOVE	T1,[.NDTDS,,T2]	;SET UP UUO
	MOVEI	T2,2		;TWO WORDS
	MOVE	T3,MYTTY	;SIXBIT TTY NAME
	NODE.	T1,		;DISCONNECT OUR LINE
	  TLZA	F,FL.DET	;IT'S OK IF DISCONNECT FAILED
	TLO	F,FL.DET	;INDICATE NOW DETACHED
	JRST	FLUSHX		;GO CLEAR CORE AND KJOB
	SUBTTL	Error message printer

;CALLED ONLY BY MACROS
ERRMSG:	MOVEM	T1,ERRACS+1	;SAVE T1
	MOVE	T1,[2,,ERRACS+2];SETUP BLT
	BLT	T1,ERRACS+16	;EXCLUDE F(0) AND P(17)
	HRRZ	P1,(P)		;GET ADDRESS OF ARGS FROM CALL
	POP	P,(P)		;GET EXTRA PUSHJ OFF THE STACK
	PUSHJ	P,.VERBO##	;GET VERBOSITY BITS
	PUSH	P,T1		;SAVE THEM FOR LATER
	PUSHJ	P,NEWLIN	;GET START OF A NEW LINE
	MOVE	P2,1(P1)	;GET FLAGS
	TXNE	P2,EF.REQ	;[477] REQUE BATCH JOB?
	MOVE	T1,["?",,[ASCIZ/?(5)/]]  ;[477] YES
	TXNE	P2,EF.SYS	;SYSTEM FAILURE
	MOVE	T1,["?",,[ASCIZ/?(4)/]] ;YES--DATA FOR THAT
	TXNE	P2,EF.ERR	;FATAL ERROR
	MOVE	T1,["?",,[ASCIZ/?(3)/]]
	TXNE	P2,EF.WRN	;WARNING?
	MOVE	T1,["%",,[ASCIZ/%/]]
	TXNE	P2,EF.INF	;INFORMATIONAL
	MOVE	T1,["[",,[ASCIZ/[/]]
	TLNN	F,FL.BAT	;[600] BATCH JOB?
	  JRST	[HLRZ  T1,T1	;NO--PUT CHAR IN RH
		 PUSHJ P,.TCHAR## ;TYPE IT
		 JRST  ERMSG1]	;CONTINUE
	HRRZ	T1,T1		;CLEAR LH
	PUSHJ	P,.TSTRG##	;TYPE THE MESSAGE

ERMSG1:	MOVE	T1,(P)		;GET VERBOSITY BITS
	TXNN	T1,JWW.PR	;/MESSAGE:PREFIX?
	JRST	ERMSG2		;NO
	HRRZ	T1,(P1)		;GET PREFIX
	HRLI	T1,'LGN'	;INCLUDE OUR NAME
	PUSHJ	P,.TSIXN##	;TYPE IN SIXBIT

ERMSG2:	PUSHJ	P,.TSPAC##	;PRINT A SPACE
	POP	P,T1		;GET VERBOSITY BITS
	TXNN	T1,JWW.FL	;/MESSAGE:FIRST?
	JRST	ERMSG3		;NO
	HRRZ	T1,1(P1)	;GET TEXT ADDRESS
	PUSHJ	P,.TSTRG##	;YES--PRINT THE STRING
	HLRZ	T1,(P1)		;GET MORE ADDRESS
	JUMPE	T1,ERMSG3	;NONE
	PUSH	P,P2		;SAVE FLAGS
	PUSH	P,T1		;SAVE IT
	MOVE	16,[ERRACS+1,,1];RESTORE ACS
	BLT	16,16		;..
	PUSHJ	P,@(P)		;CALL CONTINUATION ROUTINE
	POP	P,(P)		;FIX STACK
	POP	P,P2		;RESTORE FLAGS
ERMSG3:	TXNE	P2,EF.WTO	;WTO THIS ERROR?
	 PUSHJ	P,ERRWTO	;YES--DO IT NOW
	TXNE	P2,EF.INF	;INFORMATION?
	 PUSHJ	P,.TRBRK##	;YES
	PUSHJ	P,.TCRLF##	;CRLF
	TXNE	P2,EF.FMT	;FORMAT ERROR? (LET HIM RETRY)
	 JRST	ERMSG6		;YES
	TXNE	P2,EF.ERR!EF.SYS!EF.REQ	;FATAL?
	 JRST	ERMSG4		;YES--GO FLUSH USER
	MOVE	16,[ERRACS+1,,1];RESTORE ACS
	BLT	16,16		;..
	POPJ	P,		;AND RETURN

ERMSG4:	PUSHJ	P,.TCRLF##	;[347] DO A CRLF
	TXNE	P2,EF.SIL!EF.FMT ;SUPRESS NOTICE.TXT OR FORMAT ERROR?
	 JRST	ERMSG5		;YES
	MOVE	T1,[SIXBIT /LOGIN/]	;[615]
	SETNAM	T1,		;[357] CLEAR JACCT
	PUSHJ	P,DIEMSG	;[621] TYPE MESSAGES OF THE DAY
	PUSHJ	P,STRMES##	;[662] AND DO /STR IF DESIRED
ERMSG5:	PJRST	FLUSH		;[347] AND DIE

ERMSG6:	PUSHJ	P,.CLRBF##	;CLEAR TYPE-AHEAD
	TDNN	F,[FL.BAT,,R.SESSION];Batch or SESSION?
	 SOSG	LOGTRY		;Another chance??
	  JRST	FLUSH		;No, bye-bye
	JRST	LOGIN3		;[517]
	SUBTTL	ERRWTO - ROUTINE TO WTO IMPORTANT ERROR MESSAGES

ERRWTO:	TRNE	F,R.DBUG		;DEBUG?
	 JRST	ERRWO			;YES--DONT BOTHER REAL OPR
	MOVX	T1,.QUWTO		;FUNCTION CODE
	DPB	T1,[POINTR WTOBLK+.QUFNC,QF.FNC];STORE
	SETOM	WTOBLK+.QUNOD		;CENTRAL SITE OPR
	SETZM	WTOBLK+.QURSP		;NO RESPONCE BLOCK
	MOVX	T1,<INSVL.(WTOLEN,QA.LEN)!INSVL.(.QBTYP,QA.TYP)>;SETUP ARGS
	MOVEM	T1,WTOBLK+.QUARG	;STORE 1ST ARG
	MOVEI	T1,WTOTXT		;GET ADDR OF TEXT
	MOVEM	T1,WTOBLK+.QUARV	;STORE 1ST VALUE
	MOVX	T1,<INSVL.(^D16,QA.LEN)!INSVL.(.QBMSG,QA.TYP)>;SETUP ARGS
	MOVEM	T1,WTOBLK+.QUARG+2	;STORE 2ND ARG
	HRRZ	T1,1(P1)		;GET TEXT ADDRESS
	MOVEM	T1,WTOBLK+.QUARV+2	;STORE 2ND VALUE
	MOVE	T1,[.QUARV+3,,WTOBLK]	;POINT TO BLOCK
	QUEUE.	T1,			;WTO
	 CAIA				;FAILED
	  POPJ	P,			;OK
ERRWO:	MOVEI	T1,[ASCIZ/; Please call the operator/];JUST GIVE HIM
	PJRST	.TSTRG##		;THE TEXT W/O THE WTO

WTOTXT:	ASCIZ/LOGIN error/		;WTO HEADER
WTOLEN==.-WTOTXT
	SUBTTL	Random messages

KLGMSG:	ASCIZ	/
.KJOB
./
CRLFPD:	ASCIZ	/
./
	SUBTTL	Data and storage

;STORAGE

WATBTS:	POINTR	ENTRY+.ACPRO,AC.WDT!AC.WRT!AC.WWA!AC.RED!AC.WRI
SPLBTS:	POINTR	ENTRY+.ACPRO,AC.CDR!AC.CDP!AC.PTP!AC.PLT!AC.LPT
IFN	FASTLG,<
ENTSIZ:	.ACLEN			;SIZE OF ACCT.SYS ENTRIES
DACCFL:	0			;DIRECTORY IS NOT BUILT
DLOCK:	-1			;AND NO-ONE IS BUILDING IT
DAUXFL:	0			;AUX TABLE MUST ALSO BE BUILT
DACCL:	0			;EXPECTED LENGTH OF ACCT.SYS = LENGTH OF TABLE
PDACC:	0			;ADDR OF DIRECTORY OF ACCT.SYS
NEWACT:	0			;-1 IF NEW ACCT.SYS 0 IF V2
EQACT:	0			;[504] -1 IF SETTING 6.02 STUFF

;THE FOLLOWING WORDS CONTAIN THE CREATION DATE-TIME OF
;THE ACCOUNTING FILES THE LAST TIME THEY WERE READ SO WE CAN
;TELL IF THEY HAVE CHANGED.
W.ACCT:	0			;[540] ACCT.SYS
W.AUX:	0			;[540] AUXACC.SYS
W.SCED:	0			;[540] SCDMAP.SYS
>;*** END OF CONDITIONAL ON FASTLG
SCDTBL::0			;[425] ADDR OF SCHED TABLE
BLDSCD::0			;[425] -1 MEANS SCHED TABLE BEING BUILT
SCDBLT::-1			;[425] -1 MEANS TABLE NOT YET BUILT
	PRGEND
	TITLE	LGNEND - Exit sequence for LOGIN

	SEARCH	UUOSYM,MACTEN,SCNMAC,LGNUNV,ACTSYM,UFDPRM
	LGNDCL



;SUBROUTINE TO ALLOW CONTROL-C'S TO WORK AGAIN
;CALL WITH:
;	PUSHJ	P,CTLCOK
;	RETURN HERE IF NO CONTROL-C TYPED
;
CTLCOK::SETZM	CCWAIT		;CLEAR THE CONTROL-C DELAY FLAG
	AOSE	CCTYPED		;WAS A CONTROL-C TYPED?
	POPJ	P,0		;NO--RETURN TO CALLER
				;YES--FALL INTO RICC
;HERE WHEN A CONTROL-C TYPED
RICC::	PUSH	P,INTBLK+2	;SAVE OLD PC
	SKIPL	CCWAIT		;DO WE WANT CONTROL-C HELD UP?
	JRST	CCEXIT		;NO--CHARGE AHEAD
	INFO	WFC,<Please wait for Control-C>
	SETZM	INTBLK+2	;REENABLE INTERRUPTS
	SETOM	CCTYPED		;SET THE FLAG
	POPJ	P,0		;RETURN

CCEXIT:	PUSHJ	P,.ISLGI##	;ARE WE LOGGED IN?
	AOJE	T1,.MNRET##	;NO--EXIT
	WARN	LAC,<LOGIN aborted by Control-C - job is LOGGED-IN>
	JRST	CCLAST		;EXIT QUICKLY
LAST:	TLNE	F,FL.ATT	;SKIP IF LOGIN, NOT IF ATTACH
	JRST	ALAST		;FINISH UP ATTACH
	PUSHJ	P,PRVSET	;DO PRIV. SET UUOS
	TXNE	F,R.SESS	;IF SESSION JUST EXIT
	JRST	NORUN
IFN FTMAIL,<			;[760] CALL EXTERNAL MODULE TO SEE IF
	PUSHJ	P,RNMAIL##	;[543] USER HAS ANY MAIL
>;[760] END IFN FTMAIL

	PUSHJ	P,STRMES##	;[662] DO /STR IF DESIRED
	SETOM	CCWAIT		;[641] DISABLE CONTROL-C
	MOVE	T1,LGIARG	;NOW LOG THE GUY IN
	LOGIN	T1,
	  JFCL
	SKIPN	ENTRY+.ACPGM	;[563] UNLESS WE'RE GOING TO RUN A CUSP,
	  PUSHJ	P,CTLCOK	;[563] ALLOW CONTROL-C TO WORK AGAIN
	PUSHJ	P,USRSET	;[363] DO ORDINARY SETUUO'S (AND TRMOP.S)
	PUSHJ	P,DAYMES	;[472] PRINT OUT DAILY MESSAGES
	PUSHJ	P,POSTMS	;[472] DO POST-MESSAGE TRMOP.S (SPEED)
	SKIPN	ENTRY+.ACPGM	;SKIP IF USER IS LOCKED INTO A PROGRAM
	PUSHJ	P,.RUNCM##	;PROCESS /RUN IF ANY
CCLAST:	SKIPN	T4,ENTRY+.ACPGM	;SKIP IF RUN UUO TO BE EXECUTED
	JRST	NORUN		;NO, DONT SET IT UP
	SKIPN	T3,ENTRY+.ACDEV	;YES, SKIP IF DEVICE SPECIFIED
	MOVSI	T3,(SIXBIT .SYS.)	;NO, ASSUME SYS
	SETZB	P1,P2
	MOVE	N,ENTRY+.ACDIR	;PPN
NORUN:	SETZB	M,LASTX		;CLEAR CORE
	MOVE	WD,TOLO1
NORUN1:	PUSHJ	P,TTYOUT##	;FORCE OUT ANY REMAIN TEXT IN OUTPUT BUFFER
	MOVE	T1,[XWD LASTX,LASTX+1]
	SKIPN	.JBDDT##	;SKIP THIS IF DDT IS LOADED
	BLT	T1,@.JBREL
	SETZM	.JBSA		;CLEAR START ADDRESS SINCE PROG NO LONGER THERE
	MOVE	T1,[XWD TOLO,LASTX]
	BLT	T1,LASTX+ETOLO-TOLO	;TRANSFER TO LOW SEG
	MOVEM	WD,LASTX+TOLO1-TOLO
	JUMPE	T4,LASTX+FRUN-TOLO	;JUMP IF NO RUN UUO
	SETZB	T3+3,T3+5	;CLEAR UNUSED ARGS
	JRST	LASTX		;DO RUN UUO
;THE CODE ON THIS PAGE IS COPIED TO THE LOWSEG AND EXECUTED
; FROM THERE. THIS IS DONE WITHOUT BENIFIT OF RELOCATION
; SO BE CAREFUL

TOLO:	MOVEI	WD,T3
	RUN	WD,UU.PHY	;[640] RUN CUSP, PHYSICAL-ONLY
FRUN:	SETZ	T1,		;NO RUN UUO OR RUN UUO FAILED
	SETNAM	T1,		;CLEAR NAME
	HRLI	T1,1		;[576] GET RID OF HI SEG
	HRRI	T1,1		;[576] AND SHRINK LOW SEG TO 1K
	SKIPN	.JBDDT##
	CORE	T1,
	  JFCL
TOLO1:	MONRT.
ETOLO:	EXIT			;AND EXIT IN CASE OF CONTINUE
ALAST:	MOVEI	T1,.GTPPN	;GET PPN OF JOB THAT I AM ABOUT
	HRL	T1,ATTJOB	;  TO ATTACH TO
	GETTAB	T1,		;[157]
	  JRST	NOATT		;     CAN'T GET PPN, CAN'T ATTACH
	CAME	T1,PPN		;PPN'S DIFFER?
	  JRST	NOATT		;  YES, CAN'T ATTACH
	HRRZ	T1,ATTJOB	;[611] JOB NO. TO ATTACH TO
	TRMNO.	T1,		;[611] SEE OF SOMEONE ALREADY THERE
	  JRST	ALAST1		;[611] LOOKS OK SO FAR
	JRST	NOATT		;[611] DON'T DETACH - SQUATTER'S RIGHTS
ALAST1:	MOVN	N,ATTJOB	;[611] DO MORE CHECKING ON JOB
	JOBSTS	N,		;[611] ..
	  JRST	NOATT		;[611] FUNNY JOB NUMBER?
IFN FTMAIL,<
	PUSH	P,N		;SAVE N
	PUSHJ	P,RNMAIL##	;CHECK OUT MAIL
	POP	P,N		;RESTORE N
>;END IFN FTMAIL
	JUMPGE	N,NOATT		;[611] IF JNA NOT SET, DIE
	SKIPE	U.MODE##	;USER REQUESTED MONITOR MODE?
	 TXNN	N,JB.URN	;RUNNING?
	  JRST	ALAST3		;NO--GIVE HIM DOT
	INFO	ATJ,<Attaching to job >,,E.ATJ
	MOVX	N,AT.UUM	;INDICATE USER MODE
	JRST	ALAST2		;AND SKIP THIS
ALAST3:	MOVEI	T1,CRLFPD
	PUSHJ	P,.TSTRG##	;MAKE IT LOOK GOOD
	PUSHJ	P,TTYOUT##	;FORCE OUTPUT
	MOVX	N,AT.UMM	;INDICATE MONITOR MODE
ALAST2:	SETO	T1,		;[420] MAKE T1=-1
	GETLCH	T1		;[420] GET LINE NUMBER AND BITS
	CAME	T1,[-1]		;[420] IF GETLCH A NO-OP OR
	TRNN	T1,-1		;[420] LINE IS DETACHED, THEN
	  JRST	NOATT		;[420] ATTACH HAD BETTER LOSE
	TRZ	T1,600000	;[420] CLEAR UDX BITS
	MOVSI	T1,(T1)		;SET UP LINE NUMBER
	TDO	T1,N		;INCLUDE MODE BITS FROM ABOVE
	HRR	T1,ATTJOB	;[420] GET JOB NUMBER
	ATTACH	T1,		;ATTACH JOB TO TTY
	  JRST	NOATT		;WOOPS, COULDNT!

FLUSHX:	RESET			;TURN ON ECHOING
	MOVSI	T1,(AC.DCR)	;[1101] GET THE DECREMENT BIT
	ACCLG.	T1,		;[1101] TRY TO COUNT DOWN
	  JFCL			;[1101] IF ERROR IGNORE AND CONTINUE
	SKIPE	T1,.JBDDT##	;SKIP IF NO DDT
	 JRST	(T1)		;GO TO DDT
	SETZB	T4,LASTX	;CLEAR CORE IF UNSUCCESSFUL LOGIN
	MOVE	WD,[LOGOUT]	;KILL KJOB
	TRNE	F,R.SESSION	;[754] SESSION command?
	 MOVE	WD,[MONRT.]	;[754] Yes--Pretty up exit
	JRST	NORUN1

E.ATJ:	MOVE	T1,ATTJOB	;GET TARGET JOB
	PUSHJ	P,.TDECW##	;TYEP
	MOVEI	 T1,[ASCIZ/ running /];GET TEXT
	PUSHJ	P,.TSTRG##	;TYPE
	HRLZ	T1,ATTJOB	;GET TARGET JOB
	HRRI	T1,.GTPRG	;FIND ITS NAME
	GETTAB	T1,		;ASK MONITOR
	 MOVEI	T1,0		;NOT TODAY
	PUSHJ	P,.TSIXN##	;TYPE PROGRAM NAME
	MOVEI	T1,[ASCIZ/ in user mode/]
	PJRST	.TSTRG##

	PRGEND
	TITLE	LGNLOW - Low segment for LOGIN

	SEARCH	UUOSYM,MACTEN,SCNMAC,LGNUNV,ACTSYM,UFDPRM
	GLOBS		;DECLARE GLOBALS

DEFINE	LWORD(A),<
A::	BLOCK	1
>

DEFINE	LBLOCK(A,B),<
A::	BLOCK	B
>

	TWOSEG
	RELOC	400000
IFN FACTSW,<
FCTAHD:	XWD	240000,3
FCTHED:	XWD	100000,3
FCTFMD:	XWD	20000,2		;MODIFIER FOR FAILURE-TYPE ENTRIES
;** DO NOT SEPARATE THESE TWO LINES **

FCTWD:	XWD	-3,FCTDAT
FCTFWD:	XWD	-5,FCTDAT	;APPEND CONTROL WORD FOR FAILURES
>

LGIARG:	XWD	PPN-CHGNO-1,PPN	;ARGUMENT TO LOGIN UUO
PDPLST:	IOWD	PDLSIZ,PDL

	RELOC
	LOWVAR
	END
    H!\