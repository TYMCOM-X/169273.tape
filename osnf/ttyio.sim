BASE 0


GLOBAL %GETDLM,%INITTTY,%QUERY,%PQUERY,%GETNUM,%GETOCT,%GETTOKEN
GLOBAL %CHR.OUT,%OCTWD.OUT,%OCTNUM,%OCTOUT,%OUT,%NUMOUT,%SIXOUT
GLOBAL %MAKE.SIXBIT,%LISTABLE,%SHORT.OUT,%DATOUT,%CHOOSE,%MATCH
GLOBAL %SPOUT,%SPOCT,%BYPT

GLOBAL TOKEN(80), FILNO, RETADR

TABLE TEN(9)[1,10,100,1000,10000,100000,1000000,10000000,100000000]
TABLE EIGHT(12)[OCT 1,OCT 10,OCT 100,OCT 1000,OCT 10000,OCT 100000 &
		,OCT 1000000,OCT 10000000,OCT 100000000,OCT 1000000000 &
		,OCT 10000000000,OCT 10000000000]

FIND CH.OUT,P,NUMBER

LOCAL MINUSF
LOCAL GBLDLM,COUNT,TEMP,CHAR,TOKENP,PTR,DISP,I
LOCAL %FILL.IN.TOKEN,%TTYIO

!THE FOLLOWING MACRO COMPUTES A GENERAL BYT POINTER SO THAT NCHV ON
!THE PDP-10 WILL DO ILDB'S FOR ANY BYTE SIZE
%BYPT(Y,P1,S)
RETURN [6,6,6,18]*[IF P1>=0 THEN 36-S*(P1 MOD(36/S)-1)&
	ELSE 36-S*(36/S-(-P1)MOD(36/S)+1),S,0,&
	IF P1>=0 THEN Y+P1/(36/S) ELSE Y+(P1+1)/(36/S)-1]
END BYPT

DEF NBYV     AS NCHV
DEF BYV      AS CHV

DEF ALPHA    AS 0
DEF NUMERIC  AS 1
DEF USERNAME AS 2
DEF OCTAL    AS 3
DEF ONEDLM   AS 4
DEF ANY      AS 5  


DEF IFCHAR(A) AS ($A <= A <= $Z) OR IFNUMBER(A) OR A=$.
DEF IF.OCT.NUMBER(A) AS $0 <= A <= $7
DEF IFNUMBER(A) AS $0 <= A <= $9
DEF COLON AS CHR.OUT($:)
DEF CR AS CHR.OUT(CARRET)
DEF MINUS AS $-
DEF SLASH AS CHR.OUT($/)
DEF SPACE AS $ 
DEF SP AS CHR.OUT(SPACE)
DEF IFNAME.CHAR(A) AS IFCHAR(A) OR IFNUMBER(A) OR A=SPACE OR &
	A=$* OR A=$. OR A=$- OR A=$/ OR A=$:
DEF WHAT AS [MSG('?$'); GO ^RETADR]
DEF STILL.MORE AS INC ANS <= N.TAB
DEF SET.PTR AS PTR _ CHPT(NAME.TAB(ANS),-1)
DEF SETCOUNT AS [TOKENP _ CHPT(TOKEN,-1); COUNT _ -1;&
 WHILE NCHV TOKENP # EOLIT THEN INC COUNT; TOKENP _ CHPT(TOKEN,-1)]
DEF VERSION AS 7



%TTYIO



%INITTTY(INIT:)
    FILNO _ TEL
    P _ CHPT(IMAGE,-1)
    RETADR _ INIT
    RETURN
END INITTTY


%GETTOKEN(KIND)
    MOVE 80 FROM ALL EOLIT TO TOKEN
    TOKENP _ CHPT(TOKEN,-1)
    IF NCHV P=CARRET OR CHV P=EOLIT THEN P _ GETLINE(FILNO) ELSE PCHV P
    FILL.IN.TOKEN(KIND)
    WHILE NCHV P = SPACE THEN NULL; PCHV P	! Skip over next spaces
    RETURN
END GETTOKEN


%FILL.IN.TOKEN(KIND)
    LOCAL ENDT:,NOFLG			!=0 TIL A NON-SPACE TYPED...
    MINUSF _ NOFLG _ 0
    IF KIND = ANY THEN INC NOFLG
    NOSAVE: WHILE CHAR _ NCHV P # CARRET AND CHAR # EOLIT THEN DO
	IF CHAR > OCT 140 THEN CHAR - _ OCT 40	! Make UPPERCASE
	IF KIND # ANY THEN [IF CHAR = SPACE THEN GO ENDT]
	IF CHAR = $? THEN GO ^RETADR
	IF CHAR > OCT 140 THEN CHAR + _ OCT 40
	DO KIND OF ALPHA:ANY
	    ALPHA: IF IFCHAR(CHAR) THEN INC NOFLG ELSE  WHAT
	    NUMERIC: IF CHAR = MINUS THEN DO
		    IF NOFLG # 0 OR MINUSF # 0 THEN WHAT
		    INC MINUSF; GO NOSAVE
		END
		IF IFNUMBER(CHAR) THEN INC NOFLG ELSE [PCHV P; GO ENDT]
	    USERNAME: IF IFNAME.CHAR(CHAR) THEN INC NOFLG ELSE WHAT
	    OCTAL: IF IF.OCT.NUMBER(CHAR) THEN INC NOFLG ELSE WHAT
	    ONEDLM: IF CHAR = GBLDLM THEN DO
		    INC NOFLG; NCHV TOKENP _ CHAR; GO ENDT
		END
		IF CHAR # SPACE THEN WHAT ELSE GO NOSAVE
	    ANY: NULL
	END ! KIND OF ALPHA:ANY
	NCHV TOKENP _ CHAR		! Add CHAR to TOKEN
    END ! WHILE CHAR # CARRET or EOLIT
    PCHV P
    IF KIND = ONEDLM THEN RETURN
    ENDT: NCHV TOKENP _ EOLIT		! Always put EOLIT at end of token
    RETURN
END FILL.IN.TOKEN


%QUERY(QUES)
    MSG(QUES); MSG('? ')
    LOOP DO
	P _ GETLINE(FILNO); TEMP _ NCHV P
	WHILE NCHV P # EOLIT THEN NULL
	IF TEMP > OCT 140 THEN TEMP - _ OCT 40
	EIF TEMP = $Y OR TEMP = CARRET THEN RETURN 1
	ORIF TEMP = $? THEN GO ^RETADR
	ELSE IF TEMP = $N THEN RETURN 0
	MSG(QUES); MSG(' (Y or N): ')
    END
END QUERY


%PQUERY(QUES)
    IF NCHV P=EOLIT OR CHV P=CARRET THEN DO
	MSG(QUES); MSG('? ')
	P_ GETLINE(FILNO)
    END ELSE PCHV P
    LOOP DO 
	WHILE NCHV P = OCT 40  or  CHV P = OCT 11 THEN NULL
	TEMP _ CHV P
	WHILE NCHV P#EOLIT and CHV P#OCT 40 and CHV P#OCT 11 THEN NULL
	PCHV P
	IF TEMP > OCT 140 THEN TEMP - _ OCT 40
	EIF TEMP = $Y OR TEMP = CARRET THEN RETURN 1
	ORIF TEMP = $? THEN GO ^RETADR
	ELSE IF TEMP = $N THEN RETURN 0
	CR; MSG(QUES); MSG(' (please type Y or N): ')
	WHILE NCHV P#EOLIT THEN NULL
    END
END PQUERY



%GETDLM(DLM)
GBLDLM _ DLM; GETTOKEN(ONEDLM)
IF CH(TOKEN)=DLM THEN RETURN 1 ELSE RETURN 0
END GETDLM



%GETNUM			!RETURN DECIMAL NUMBER IN NUMBER
    GETTOKEN(NUMERIC); SETCOUNT; NUMBER _ 0
    FOR I_COUNT TO 0 BY -1 NUMBER+_(NCHV TOKENP-$0)*TEN(I)
    IF MINUSF # 0 THEN NUMBER-_
    RETURN NUMBER
END GETNUM



%GETOCT
LOCAL GOT:
	!INPUT AN OCTAL NUMBER INTO NUMBER
GOT: NUMBER _ 0
GETTOKEN(OCTAL); SETCOUNT
DISP _ BITS.PER.WORD
IF COUNT > BITS.PER.WORD/3 THEN &
	[MSG('$NUMBER IS TOO LARGE - REENTER: '); GO GOT]
 REPEAT BITS.PER.WORD/3-COUNT-1 DISP-_3
WHILE CHAR_NCHV TOKENP#EOLIT THEN [DISP-_3; BYT(NUMBER,3,DISP)_(CHAR-$0) BAND 7]
RETURN NUMBER
END GETOCT




%CHR.OUT(A)
W(CH.OUT,A)
RETURN
END CHR.OUT



%OCTWD.OUT(A)
OCTOUT(HW(@A,0)); CHROUT($,); OCTOUT(HW(@A,1))
RETURN
END OCTWD.OUT



%OUT(A)
	!OUTPUT A MESSAGE
TEMP _ CHPT(A,-1)
WHILE CHAR_NCHV TEMP#EOLIT THEN [IF CHAR=$$ THEN CHAR_CARRET;&
			CHR.OUT(CHAR)]
RETURN
END OUT



%NUMOUT(N)
	!OUTPUT DECIMAL NUMBER
IF N<0 THEN [CHR.OUT($-); N-_]
IF N>=TEN(6) THEN [OUT('>1000000.'); RETURN]
I_0; WHILE N>=TEN(I+1) THEN INC I
WHILE I>=0 THEN [CHR.OUT($0+N/TEN(I)); N_N MOD TEN(I); DEC I]
RETURN
END NUMOUT


%OCTNUM(N)
	!OUTPUT AN OCTAL NUMBER
LOCAL FLAG, CHAR
FLAG_ 0; DISP _ BITS.PER.WORD/2
WHILE DISP > 0 THEN DO
    DISP-_3
    IF 0 # (FLAG _ FLAG MAX (CHAR_ BYT(N,3,DISP) )) THEN CHR.OUT($0+CHAR)
END
RETURN
END OCTNUM



%OCTOUT(N)
	!OUTPUT AN OCTAL HALF WORD
DISP _ BITS.PER.WORD/2
WHILE DISP > 0 THEN [DISP-_3; CHR.OUT($0+BYT(N,3,DISP))]
RETURN
END OCTOUT



%SIXOUT(ADR,N)
	!OUTPUT N CHARACTERS IN SIXBIT
PTR _ BYPT(ADR,1,6)
REPEAT N CHR.OUT(SPACE+NBYV PTR)
RETURN 
END SIXOUT



%MAKE.SIXBIT(FROMADR,TOADR,N)
	!CHANGE N CHARACTERS FROM ASCII IN FROMADR TO SIXBIT IN TOADR
LOCAL FROMP,CHAR
FROMP _ CHPT(FROMADR,-1)
PTR _ BYPT(TOADR,1,6)
REPEAT N DO
IF CHAR _ NCHV FROMP # EOLIT THEN NBYV PTR _ (CHAR-SPACE) BAND OCT 77 &
		ELSE NBYV PTR _ EOLIT
END
RETURN
END MAKE.SIXBIT



%LISTABLE(N.TAB,TAB(),COUNT,TEXT)
	!LIST ENTIRE TABLE, WITH ENTRIES SEPARATED BY COMMAS...
	!TABLE MUST HAVE >1 ENTRY...DOES NOT TYPE ENTRIES OF -1
LOCAL WD.CNT
I _ 1; WD.CNT _ 0
WHILE TAB(I)=-1 THEN INC I
MSG(TAB(I)); INC I
WHILE I <= N.TAB THEN DO
    IF TAB(I) # -1 THEN DO
	INC WD.CNT
	IF I#N.TAB THEN DO
	    MSG(TEXT)
	    IF WD.CNT = COUNT THEN [CR; WD.CNT _ 0]
	END ELSE MSG(' or ')
	MSG(TAB(I))
    END
    INC I
END
RETURN
END LISTABLE



%SPOUT(A,B)
IF A = 0 THEN [REPEAT B SP; RETURN]
TEMP _ B
WHILE A < TEN(TEMP) THEN [SP; DEC TEMP]
RETURN
END SPOUT


%SPOCT(A,B)
IF A = 0 THEN [REPEAT B SP; RETURN]
TEMP _ B
WHILE A < EIGHT(TEMP) THEN [SP; DEC TEMP]
RETURN
END SPOCT



%SHORT.OUT(PTR,N)
	!OUTPUT TEXT ONLY IN N SPACES...
REPEAT N DO
IF CHAR _ NCHV PTR = EOLIT THEN [SP; PCHV PTR] ELSE CHR.OUT(CHAR)
END
RETURN
END SHORT.OUT




%DATOUT
	!OUTPUT DATE AND TIME
LOCAL MON,HOURS,DAY,MINUTE
TEMP _ EXU(OCT 47,OCT 1,OCT 14)
[TEMP; DAY] _ TEMP DIVMOD 31
[TEMP; MON] _ TEMP DIVMOD 12
NUMOUT(MON+1);SLASH; NUMOUT(DAY+1);SLASH; NUMOUT(64+TEMP); SP; SP
TEMP _ EXU(OCT 47, OCT 1,OCT 22)
[TEMP; ] _ TEMP DIVMOD 3600
[HOURS;MINUTE] _ TEMP DIVMOD 60
NUMOUT(HOURS); COLON
IF MINUTE < 10 THEN CHR.OUT($0)
IF MINUTE = 0 THEN CHR.OUT($0) ELSE NUMOUT(MINUTE)
RETURN
END DATOUT



%CHOOSE(N.TAB,NAME.TAB())	!FIND A UNIQUE MATCH IN NAM.TAB WITH TOKEN
    LOCAL ANS,FIRST,T
    ANS _ 0
    WHILE STILL.MORE THEN DO
	IF T _ MATCH = 2 THEN RETURN ANS
	IF T = 1 THEN DO
	    FIRST_ANS
	    WHILE STILL.MORE THEN &
	       [IF MATCH=1 THEN [MSG('$Not unique$');RETURN -1]]
	    RETURN FIRST
	END
    END
    RETURN 0


%MATCH	!RETURN 0 IF NO MATCH, 1 IF MATCH, 2 IF EXACT MATCH (STOP LOOKING)
    LOCAL P,COUNT
    SET.PTR
    P _ CHPT(TOKEN,-1)
    COUNT _ 0
    WHILE NCHV PTR # EOLIT THEN INC COUNT
    SET.PTR
    IF NCHV P # NCHV PTR THEN RETURN 0
    DEC COUNT
    WHILE NCHV P # EOLIT THEN [IF CHV P # NCHV PTR THEN RETURN 0; DEC COUNT]
    IF COUNT = 0 THEN RETURN 2 ELSE RETURN 1
END MATCH
END CHOOSE


END TTYIO
 