BASE 0

!PROCEDURES

GLOBAL %NONAME

FIND %INITTTY, %QUERY, %PQUERY, %GETNUM, %GETOCT, %GETTOKEN, %LISTABLE
FIND %CHR.OUT, %OCTWD.OUT, %OCTOUT, %OCTNUM, %OUT, %NUMOUT
FIND %CHOOSE, %DATOUT, %SHORT.OUT, %SPOUT, %SPOCT, %SIXOUT, %MAKE.SIXBIT
FIND %HASH, %GETULC

LOCAL %INITNONAME, %HEADING, %DISPLAY.USER, %SELECT.CHANGE
LOCAL %OPEN.AND.LUD.LOOK, %LUD.LOOK, %LUD.OVERFLOW, %LUD.SEQ, %LUD.CHK
LOCAL %OPEN.AND.DUL.LOOK, %DUL.LOOK, %DUL.OVERFLOW, %DUL.SEQ, %DUL.CHK
LOCAL %DO.LIST, %DO.NAMES, %GET.CHANGE, %CHANGE.IT, %MAKE.ROOM
LOCAL %LIST.RECORD, %LIST.EACH, %LIST.ENTRY
LOCAL %CALL.UUO, %ERROR, %CHK.IO.ERR, %NEXT.TEN

DEF RELEASE AS OCT 106
DEF VERSION AS OCT 43

DEF SIZE.BLK AS 128

!ID'S
FIND TOKEN(0)

GLOBAL NUMBER, NAME.HASH, LOC.HASH, P, CH.OUT
GLOBAL USER.NAME(2), LISTFLG

GLOBAL GETCMD:, LUD.ERR:, CHK.ERR:, CK.DUL:

LOCAL THIS.PPN, THIS.GAN, UUN, THIS.DIST, THIS.A.S, THIS.TYM, THIS.NAME(2)
LOCAL GOD, OPER, C.SER.FLG, CAN.LOOK, THIS.AREA
LOCAL DULFLG, SAVCP, BADBLK, BADFIL
LOCAL OLDBLK, TYPE, GAN, DIST, SITE, K.ALL
LOCAL CH.LUD, CH.DUL, IO.ADR, CMD, LIST, LIST.TYPE, ENT.TYPE
LOCAL SEQ.FLG, LOCAL.NET
LOCAL D.INDEX, D.BLK(SIZE.BLK), D.BLKNO
LOCAL L.INDEX, L.BLK(SIZE.BLK), L.BLKNO, LUD.SIZE
LOCAL TEMP, TEMP1, TEMP.INDEX, BUD.INDEX
LOCAL CH.NUM, ACCT.NUM, DIST.NUM
LOCAL A.S.SAV, TYM.SAV, SUP.SAV, I.BIT.SAV, I.FILE.SAV, I.USER.SAV(2)
LOCAL ZONE.SAV, DAY.L.SAV, MODE.SAV, RCM.SAV, RUB.SAV
LOCAL Q.IN.SAV, Q.OUT.SAV, CORE.SAV, GFD.SAV, PC.SAV
LOCAL SHUT.SAV, BILL.SAV
LOCAL AUTO.SAV, STOPLOG.SAV, SHUTFLAG, BILLFLAG


!COMMANDS
DEF CMD.LIST   AS 1	! LIST
DEF CMD.CHANGE AS 2	! CHANGE
DEF CMD.NAMES  AS 3	! NAMES
DEF CMD.HELP   AS 4	! HELP
DEF CMD.INSTR  AS 5	! INSTRUCTIONS
DEF CMD.ENDIT  AS 6	! QUIT
DEF CMD.VERIFY AS 7	! VERIFY
DEF CMD.USER   AS 8	! USER

DEF N.CMDS     AS 8	!NUMBER OF PRIMARY COMMANDS
DEF U.CMDS     AS 6	!NUMBER OF USER COMMANDS

GLOBAL TABLE USER.CMDS(1:N.CMDS)['LIST','CHANGE','NAMES','HELP',&
   'INSTRUCTIONS','QUIT','VERIFY','USER']

!FLAGS IN LISTFLG
DEF USER.LST AS 1	!   list/change USER
DEF ACCT.LST AS 2	!   list/change Account/GAN
DEF DIST.LST AS 3	!   list/change District
DEF ALL.SET AS -1	!   list/change everything

!LIST AND CHANGE COMMANDS
DEF LST.USER AS 1	!LIST USER
DEF LST.ACCT AS 2	!LIST ALL USERS IN SAME GAN
DEF LST.PPN  AS 3	!LIST PROJECT-PROGRAMMER
DEF LST.DIST AS 4	!LIST ALL USERS IN SAME DISTRICT
DEF LST.LUD  AS 5	!LIST ALL USERS IN THE LUD
DEF LST.RUB  AS 6	!LIST ALL USERS WITH RUB ON

DEF N.LIST.CMDS AS 6	!NUMBER OF LIST COMMANDS
DEF T.LIST.CMDS AS 4	!NUMBER OF TYM SUPERVISOR LIST COMMANDS
DEF S.LIST.CMDS AS 3	!NUMBER OF SUPERVISOR LIST COMMANDS
DEF U.LIST.CMDS AS 1	!NUMBER OF USER LIST COMMANDS

GLOBAL TABLE LIST.CMDS(1:N.LIST.CMDS)['USER','ACCOUNT','PPN','DISTRICT','LUD','RUB']


!CHANGES TO BE MADE

DEF ENT.NAME AS  0	! User name - always seeable, never changeable
DEF ENT.MIN  AS  1	! Minimum entry item
DEF ENT.USER AS  7	! Maximum entry item for any user
DEF ENT.SUP  AS 13	! Maximum entry item for supervisor
DEF ENT.OPER AS 14	! Maximum entry item for operations
DEF ENT.VAL  AS 17	! Maximum entry item for validations
DEF ENT.MAX  AS 19	! Maximum entry item

! User changeable options
DEF CH.MSG  AS  1	! Suppress loginn message
DEF CH.MODE AS  2	! Mode: PDP, TYMEX [XEXEC], GE [XEXECJ], SUDS
DEF CH.ZONE AS  3	! Time zone
DEF CH.GFD  AS  4	! GFD allowed by others in same account
DEF CH.INIT AS  5	!*Init program
DEF CH.DISC AS  6	! Disconnect option: LOGOUT, DETACH, CONTINUE, TIMEOUT
DEF CH.ATT  AS  7	! Attach option: ALLOW, FORCE, RESTRICT

! Supervisor changeable options
DEF CH.PC   AS  8	! Project-code required/omitted
DEF CH.LIC  AS  9	! License: TYM ACT.SUP
DEF CH.NOLG AS 10	! Multiple/Single/None:Files-only logins allowed
DEF CH.ALOG AS 11	! Inactivity auto-logout enable/disable
DEF CH.SLOG AS 12	! Logout-on-stop environment protection enable/disable
DEF CH.RCM  AS 13	! Commands: Restricted

! Operations changeable options
DEF CH.STR  AS 14	!*Quota DSKB: in, out

! Validations changeable options
DEF CH.CORE AS 15	! Core limits (Settable and Maximum)
DEF CH.RUB  AS 16	! Restricted user bit

! Cannot change with this program
DEF CH.BUD  AS 17	!*Budget set

! Special options requiring special privileges
DEF CH.SHUT AS 18	! Local shut override (2020s and F3s)
DEF CH.BILL AS 19	! Billable user (2020s and F3s)

GLOBAL TABLE CHANGES(1:ENT.MAX+3)['','NONE','HELP',&
    'BANNER','MODE','TIME-ZONE','GFD','INITIALIZATION', &
    'DISCONNECT','ATTACH',&
    'PROJECT-CODE','LICENSE','LOGIN','INACTIVITY-LOGOUT',&
	'ENVIRONMENT','COMMANDS',&
    'QUOTA','MEMORY','RESTRICTED',-1 !*Budget*! ,&
    'SHUT-OVERRIDE','BILLABLE-USER']


!Option tables

DEF N.MODES AS 4	!Number of modes
GLOBAL TABLE MODES(1:N.MODES)['PDP10','XEXEC','XEXECJ','SUDS']

DEF N.ZONES AS 26 	! Number of time zones
GLOBAL TABLE ZONES(0:N.ZONES)[6(-1),'HAWAII AND ALASKA',-1,'PACIFIC',&
    'MOUNTAIN','CENTRAL','EASTERN','ATLANTIC',3(-1),'LONDON',&
    'WESTERN EUROPE',7(-1),'TOKYO','BRISBANE']

LOCAL DISC.SAV	! Detach:values
DEF DB.LOG  AS 0	! LOGOUT ON DISCONNECT
DEF DB.D    AS 1 	! DETACH ON DISCONNECT - NO TIMEOUT - STOP JOB
DEF DB.CONT AS 2	! DETACH ON DISCONNECT - NO TIMEOUT - CONT RUNNING
DEF DB.D.TO AS 3	! DETACH ON DISCONNECT - 15 MINUTE TIMEOUT
DEF N.DET.OPTS AS 4	!Number of detach options
GLOBAL TABLE DET.OPTS(1:N.DET.OPTS)['LOGOUT','DETACH','CONTINUE','TIMEOUT']

LOCAL ATT.SAV	! Attach:values
DEF ATT.ALLOW AS 0	! Allow attach
DEF ATT.FORCE AS 1	! Force attach
DEF ATT.NONE  AS 2	! No attach allowed
DEF N.ATT.OPTS AS 3	!Number of attach options
GLOBAL TABLE ATT.OPTS(1:N.ATT.OPTS)['ALLOW','FORCE','NONE']

LOCAL LOG.SAV	! Login:values
DEF LOG.MULTI AS 0	! Allow multiple jobs
DEF LOG.ONE   AS 1	! Allow a single job
DEF LOG.NONE  AS 2	! Allow no jobs (Files-only)
DEF N.LOGINS  AS 3	!NUMBER OF LOGIN OPTIONS
GLOBAL TABLE LOGINS(1:N.LOGINS)['MULTIPLE','ONE','NONE']

!FLAGS IN STATUS
DEF NO.CHG  AS 0
DEF OLD.OUT AS 1	!OLD BLK WAS WRITTEN OUT.WITHOUT THIS USER

!ERROR MESSAGES FOR READ DATA ERRORS
DEF NODUL.BAD AS 1
DEF HASH.BAD  AS 2
DEF BLKNO.BAD AS 3
DEF NOLUD.BAD AS 4
DEF GARBAGE   AS 5
DEF BAD.PPNS  AS 6
DEF OVER.BAD  AS 7


!MACRO'S

DEF ACCT.GAN AS 4
DEF JAPANESE AS 23
DEF C.S.BIT(A) AS BYT(A,1,20)

DEF L.GAN      AS HW(@LUD(0),0)		! Global account number {PROJ}
DEF L.UUN      AS HW(@LUD(0),1)		! Universal user number {PROG}
DEF OV.BLK     AS HW(@LUD(0),1)		! Overflow block pointer

DEF DIST.BITS  AS BYT(LUD(1),8,0)	! (28-35) District

DEF NOLOG.BIT  AS BYT(LUD(2),1,35)	!**(0) No logins allowed [Files only]
DEF SUPMSG.BIT AS BYT(LUD(2),1,34)	!  (1) Suppress banner message
DEF RUB.BIT    AS BYT(LUD(2),1,33)	!  (2) Restricted user
DEF GFD.BIT    AS BYT(LUD(2),1,32)	!  (3) GFD allowed by same GAN
DEF TRU.BIT    AS BYT(LUD(2),1,31)	!  (4) TRU control if budget set
DEF ATT.BIT    AS BYT(LUD(2),2,29)	!(5-6) Allow/Force/No Login-Attach
DEF MLJOB.BIT  AS BYT(LUD(2),1,28)	!**(7) Single job per user [if set]
DEF PC.BIT     AS BYT(LUD(2),1,27)	!  (8) Omit project code

DEF SHUTFLAG   AS BYT(LUD(2),1,16)	! (19) Local shut override
DEF BILLFLAG   AS BYT(LUD(2),1,15)	! (20) Local billable flag
					! (21-26) Letters waiting 6-1

DEF INIT.BIT   AS BYT(LUD(2),1,8)	! (27) Init program exists
DEF SIZE.LUD.ENT AS BYT(LUD(2),7,0)	! (29-35) Entry size in words

DEF STOPLOGOUT AS BYT(LUD(3),1,35)	!     (0) Logout on stop - environment
DEF DAYLIG.BIT AS BYT(LUD(3),1,33)	!     (2) Daylight saving applies
DEF ZONE.BITS  AS BYT(LUD(3),5,28)	!   (3-7) User Time Zone
DEF NEW.MAIL   AS BYT(LUD(3),1,27)	!     (8) "New" [mail waiting]
DEF AUTOLOGOUT AS BYT(LUD(3),1,26)	!     (9) Default autologout enabled
DEF SC.MODE    AS BYT(LUD(3),1,25)	!    (10) Special command mode
DEF CORE2.LUD  AS BYT(LUD(3),7,18)	! (11-17) Maximum user core limit
DEF DISC.BIT   AS BYT(LUD(3),2,15)	! (19-20) Disconnect option
DEF TYM.BIT    AS BYT(LUD(3),1,14)	!    (21) Tymnet proprietary bit
DEF ACTSUP.BIT AS BYT(LUD(3),1,13)	!    (22) Account supervisor
DEF RCM.BIT    AS BYT(LUD(3),1,9)	!    (26) Restricted command mode
DEF MODE.BIT   AS BYT(LUD(3),2,7)	! (27-28) Mode (PDP,XEXEC,XEXECJ,SUDS)
DEF CORE1.LUD  AS BYT(LUD(3),7,0)	! (29-35) Maximum core limit


DEF BIG AS NOT(LITTLE)

DEF CR AS CHR.OUT(CARRET)
DEF DASH AS CHR.OUT($-)
DEF EQUALS AS CHR.OUT($=)
DEF SP AS CHR.OUT(SPACE)
DEF SPACE AS $ 
DEF COLON AS MSG(': ')
DEF COMMA AS MSG(', ')
DEF DOTS AS OUT('...')
DEF ENTER.NAME AS 'Enter user name: '

DEF CHK.OPER AS [IF OPER = 0 THEN [MSG('$You may not execute this ');&
   MSG('command.'); RETURN 0]]
DEF MORE(A) AS [IF NCHV P=EOLIT OR CHV P=CARRET THEN A; PCHV P]

DEF DISTOUT AS [SPOUT(DIST.BITS,4); NUMOUT(DIST.BITS)]
DEF DUL(A) AS D.BLK(D.INDEX+A)
DEF DUL.READ AS [RB(CH.DUL,SIZE.BLK,D.BLK); D.INDEX _ 0]
DEF FIXCP(A) AS (A-1)*SIZE.BLK	!COMPUTE CURSOR POS. FROM BLK. NO.
DEF GAN.OUT AS [SPOCT(L.GAN,6); OCTNUM(L.GAN)]
DEF GET.GAN AS [MORE(MSG('Account: ')); GAN _ GETOCT]
DEF GET.UUN AS [MORE(MSG('UUN: ')); UUN _ GETOCT]
DEF GET.PPN AS [GET.GAN; GET.UUN; HW(@TEMP,0) _ GAN; HW(@TEMP,1) _ UUN]
DEF GET.NAME(MSG.TEXT) BY IF OPER=1 OR THIS.A.S=1 THEN DO
	MORE(MSG.TEXT); GETTOKEN(2); MAKE.SIXBIT(TOKEN,USER.NAME,12)
    END ELSE DO
	MOVE 72/CHARS.PER.WORD FROM ALL 0 TO IMAGE
	USER.NAME(0) _ THIS.NAME(0)
	USER.NAME(1) _ THIS.NAME(1)
    END ENDM GET.NAME
DEF KEEP.CP AS [TEMP _ CP(CH.LUD); TEMP-_SIZE.BLK; SETCP(CH.LUD,TEMP)]
DEF LEGAL.AS AS (OPER # 0 OR (THIS.A.S # 0 AND SAMACCT))
DEF LEGAL AS (LEGAL.AS OR SAMUSR)
DEF LEGAL.CH(A) AS (OCT 37 < A < OCT 133) OR A = 0
DEF LITTLE AS (LISTFLG = USER.LST or CMD = CMD.CHANGE)
DEF LUD(A) AS L.BLK(L.INDEX+A)
DEF LUD.READ AS [RB(CH.LUD,SIZE.BLK,L.BLK); L.INDEX _ 0]
DEF LUD.TEMP(A) AS LUD(TEMP.INDEX+A)
DEF LUD.WRIT AS [KEEP.CP; WB(CH.LUD,SIZE.BLK,L.BLK)]
DEF MOVE.DOWN AS [TEMP1_TRU.BIT;FOR TEMP_TEMP1+5 TO TEMP1+7 &
    LUD(TEMP+3) _ LUD(TEMP)]


DEF NAMOUT AS SIXOUT(@DUL(1),12)
DEF N.LUD.BLKS AS SIZE(CH.LUD)/SIZE.BLK
DEF NO AS 0
DEF NOT.VALID AS [MSG('$Not a valid user$'); RETURN 0]
DEF OPEN.LUD(A) AS CH.LUD _ OPEN('(SYS)LUD.SYS',DIRECT+A+WORD,LUD.ERR)
DEF OPEN.TEL AS CH.OUT _ OPEN('TEL',SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)
DEF OPEN.DUL AS CH.DUL _ OPEN('(SYS)DUL.SYS',DIRECT+INPUT+WORD,CHK.ERR)
DEF OPER.PPN AS OCT 1000021
DEF OUT.WHERE AS [MORE(MSG('Output to: ')); GETTOKEN(0); &
	CH.OUT _ OPEN(TOKEN,SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)]
DEF PPN.OUT AS OCTWD.OUT(LUD(0))
DEF PROT.FAILURE AS [MSG('$You do not have access to that user name$'); RETURN 0]
DEF SAMACCT AS THIS.GAN = L.GAN
DEF SAMUSR AS THIS.PPN = LUD(0)
DEF SET.TEMP AS [IF INIT.BIT = 1 THEN TEMP.INDEX _ 3;&
   IF BUD.INDEX _ TRU.BIT = 1 THEN INC TEMP.INDEX]
DEF SIZE.INC AS SIZE.LUD.ENT _ SIZE.LUD.ENT + 3
DEF SIZE.DEC AS SIZE.LUD.ENT _ SIZE.LUD.ENT - 3
DEF TYPSPACE(A) AS [REPEAT A SP]
DEF USER.MISSING AS [PPN.OUT; OUT(' Missing from dul.$')]
DEF UUN.OUT AS [SPOCT(L.UUN,6); OCTNUM(L.UUN)]
DEF YES AS 1


%NONAME					! MAINLINE
LOCAL ENDLUD:

START: INITNONAME
\\->START
    ALTLOC _ GETCMD; ON.ALT
    CR

GETCMD: LOOP DO
    CMD _ LISTFLG _ SEQ.FLG _ IO.ADR _ 0
    CLOSE.ALL; OPEN.TEL
    CR; MSG(': ')
    NCHV P_ EOLIT; PCHV P; GETTOKEN(0)
    TEMP_ U.CMDS
    IF OPER # 0 THEN TEMP_ N.CMDS
    IF CMD _ CHOOSE(TEMP,USER.CMDS) <= 0 THEN CMD _ CMD.HELP

    DO CMD OF 1:N.CMDS			! case 1:n.cmds of cmd

	CMD.LIST:   DO.LIST		! CMD = 1 for CMD.LIST
	CMD.CHANGE: DO.LIST		! CMD = 2 for CMD.CHANGE
	CMD.NAMES:  DO.NAMES
	CMD.ENDIT:  CLOSE.ALL; EXIT

	CMD.HELP: MSG('Legal commands are:$')
	    TEMP_ U.CMDS
	    IF OPER = 1 THEN TEMP_ N.CMDS
	    LISTABLE(TEMP,USER.CMDS,-1,', '); MSG('.$')

	CMD.INSTR: MSG('See (*6NEWS)NONAME.INF')
	    IF OPER = 1 OR THIS.GAN = ACCT.GAN THEN &
		MSG(' and (SYSNEWS)NONAME.OPR')
	    CR

	CMD.VERIFY: OUT.WHERE; OPEN.LUD(INPUT); OPEN.DUL; LUD.CHK
	    CK.DUL: DUL.CHK

	CMD.USER: GET.PPN; CR
	    IF OPEN.AND.DUL.LOOK(TEMP) # 0 THEN [NAMOUT; CR] &
		ELSE [LUD(0) _ TEMP; USER.MISSING]

    END

    ENDLUD: CMD _ 0		! must have something, sigh
END

LUD.ERR: IF SEQ.FLG # 0 THEN GO GETCMD ELSE CHK.IO.ERR


%LUD.SEQ				!READ NEXT SEQUENTIAL LUD ENTRY
    TEMP.INDEX _ 0
    LOOP DO
	L.INDEX+_SIZE.LUD.ENT
	IF LUD(0)<0 THEN LUD.OVERFLOW
	WHILE LUD(0) = 0 THEN LUD.READ
	IF LUD(4) # 0 THEN [SET.TEMP; RETURN]
    END
END LUD.SEQ



%DUL.SEQ				!READ NEXT SEQUENTIAL DUL ENTRY
    LOCAL J
    D.INDEX + _ 3
    WHILE DUL(0) = 0 THEN DO
	LOOP DO
	    FOR J _ 1 TO SIZE.BLK-1-D.INDEX &
	    IF DUL(J)#0 THEN [BADBLK_D.BLKNO; ERROR(GARBAGE); REPEAT 0]
	    REPEAT 0
	END
	INC D.BLKNO; DUL.READ
    END
    RETURN
END DUL.SEQ


%OPEN.AND.LUD.LOOK(MODE)
	!LOOK UP NAME IN ADR, ADR+1 IN LUD
    OPEN.LUD(MODE)
    RETURN LUD.LOOK(USER.NAME)
END OPEN.AND.LUD.LOOK


%LUD.LOOK(ADR)
    TEMP.INDEX _ 0
    HASH(^ADR,^(ADR+1))
    OLDBLK _ LOC.HASH
    SETCP(CH.LUD,FIXCP(LOC.HASH)); LUD.READ 
    WHILE NAME.HASH # LUD(4) THEN DO	
	L.INDEX+_SIZE.LUD.ENT
	IF LUD(0)=0 THEN RETURN 0
	IF LUD(0)<0 THEN LUD.OVERFLOW
    END
    SET.TEMP
    RETURN 1
END LUD.LOOK


%OPEN.AND.DUL.LOOK(PP)
	!LOOK UP PP IN DUL
    OPEN.DUL
    %%DUL.LOOK(PP)
    IF PP < 0 THEN [MSG('$Illegal PPN.$'); GO GETCMD]
    SETCP(CH.DUL,FIXCP((PP MOD 101)+1)); DUL.READ
    WHILE DUL(0) # PP THEN DO
	D.INDEX+_3
	IF DUL(0)=0 THEN RETURN 0
	IF DUL(0)<0 THEN DUL.OVERFLOW
    END
    RETURN 1
END OPEN.AND.DUL.LOOK


%LUD.OVERFLOW
	!READ LUD OVERFLOW BLOCK
    SETCP(CH.LUD,OV.BLK*SIZE.BLK); OLDBLK _ OV.BLK
    LUD.READ
    RETURN
END LUD.OVERFLOW


%DUL.OVERFLOW
	!READ DUL OVERFLOW BLOCK
    SETCP( CH.DUL, (HW(@DUL(0),1)-1)*SIZE.BLK )
    DUL.READ
    RETURN
END DUL.OVERFLOW


%CHK.IO.ERR	!TAKE CARE OF ALL I/O ERRORS FROM IOCS.
CHK.ERR: IF ERRNUM=EOFERR AND IO.ADR # 0 THEN GO ^IO.ADR
CLOSE.ALL; MSG('Error on '); WFID(FIDP); MSG('...$'); OPEN.TEL
  DO ERRNUM OF TMFERR:CORERR
    TMFERR: MSG('Too many files open')
    FMDERR: MSG('Bad file mode or type')
    IFDERR: MSG('Illegal file identifier')
    FNFERR: MSG('File not found')
    IUSERR: MSG('Invalid user name')
    PRTERR: MSG('Protection failure')
    FBSERR: MSG('File busy')
    EOFERR: MSG('End of file')
  END
MSG('.$Error ');NUMOUT(ERRNUM);EXIT
END CHK.IO.ERR


%INITNONAME				!INIT PROGRAM
    LOCAL THIS.UUN
    IOCS(2); INITTTY(GETCMD)

    TEMP_ CALL.UUO( OCT 4000071,OCT 41,1 )	! Check KS-10 or F3
    LOCAL.NET _ IF BYT(TEMP,1,14) or BYT(TEMP,1,11) THEN 1 ELSE 0

    MSG('$User validation program - version %'); OCTNUM(VERSION)
    MSG('('); OCTNUM(RELEASE); MSG(')    '); DATOUT
    MOVE 72/CHARS.PER.WORD FROM ALL 0 TO TOKEN
    THIS.PPN _ CALL.UUO(-OCT 23 BAND OCT 777777 BOR (-1 SHL 18),OCT 41,1)
 
    OPEN.DUL
    IF OPEN.AND.DUL.LOOK(THIS.PPN) = 0 THEN &
	[OCTWD.OUT(THIS.PPN); MSG(' Not in DUL'); EXIT]
    THIS.NAME(0) _ DUL(1); THIS.NAME(1) _ DUL(2)
    OPEN.LUD(INPUT); LUD.SIZE _ N.LUD.BLKS
    IF LUD.LOOK(@DUL(1)) = 0 THEN [NAM.OUT; MSG(' Not in LUD'); EXIT]

    THIS.DIST _ DIST.BITS; THIS.AREA _ THIS.DIST/10
    THIS.A.S _ ACTSUP.BIT
    THIS.TYM _ TYM.BIT
    THIS.GAN _ HW(@THIS.PPN,0); THIS.UUN _ HW(@THIS.PPN,1)

    OPER _ BYT(TEMP _ CALL.UUO(-OCT 20,OCT 41,1),1,15)
    GOD _  BYT(TEMP,1,9)			! JL

    IF GOD = 1 THEN OPER _ 1			! OP license or GOD
    CAN.LOOK _ BYT(TEMP,1,3) BOR BYT(TEMP,1,1)	! 1 if RF/RA or WF/WA license

    C.SER.FLG _ -1	!-1 MEANS FLAG NOT SET AS YET
			! 0 MEANS NOT C.SER
			! 1 MEANS C.SER

    RETURN
END INITNONAME


%DO.LIST
    LOCAL LISTNUM
    LIST.TYPE _ U.LIST.CMDS; ENT.TYPE _ ENT.USER
    IF THIS.A.S # 0 THEN [LIST.TYPE_ S.LIST.CMDS; ENT.TYPE _ ENT.SUP]
    IF THIS.A.S # 0 AND THIS.TYM # 0 THEN LIST.TYPE_ T.LIST.CMDS
    IF OPER # 0  OR  CAN.LOOK # 0  THEN DO
	LIST.TYPE_ IF CMD = CMD.CHANGE THEN T.LIST.CMDS ELSE N.LIST.CMDS
	ENT.TYPE _ IF CMD = CMD.CHANGE THEN ENT.OPER ELSE ENT.VAL
    END
    IF GOD # 0 THEN DO
      IF CMD = CMD.CHANGE and THIS.GAN # 3 THEN DO
	LIST.TYPE_ T.LIST.CMDS		! Set again here for completeness
	ENT.TYPE _ ENT.VAL		! God can do anything?
      END ELSE DO
	LIST.TYPE_ N.LIST.CMDS		! Set again here for completeness
	ENT.TYPE _ ENT.VAL		! God can do anything?
      END
    END

    IF LIST.TYPE = U.LIST.CMDS THEN LIST_ LST.USER ELSE DO
	LIST_ 0
	IF NCHV P=EOLIT OR  CHV P=CARRET THEN DO
	    LISTABLE(LIST.TYPE,LIST.CMDS,6,', '); COLON
	    CHV P_ EOLIT
	END
	PCHV P
    END
    WHILE LIST <= 0 THEN DO
	GETTOKEN(0)
	IF LIST_ CHOOSE(LIST.TYPE,LIST.CMDS) <= 0 THEN DO
	    LISTABLE(LIST.TYPE,LIST.CMDS,6,', '); COLON
	    NCHV P_ EOLIT; PCHV P
	END
    END

    DO LIST OF LST.USER:LST.RUB

	LST.USER: GET.NAME(MSG(ENTER.NAME))
	    LISTFLG _ USER.LST
	    IF NOT( DISPLAY.USER ) THEN RETURN 0

	LST.ACCT: LISTFLG _ ACCT.LST
	    IF OPER # 0 THEN DO
		MORE(MSG('Account: '))
		ACCT.NUM _ GETOCT
	    END ELSE ACCT.NUM _ THIS.GAN
	    IF CMD = CMD.LIST THEN DO
		HEADING
		OPEN.LUD(INPUT); LUD.SEQ; INC SEQ.FLG
		LOOP DO
		    IF LEGAL AND (ACCT.NUM = L.GAN) THEN LIST.RECORD(ALL.SET,OLD)
		    LUD.SEQ
		END
		CLOSE(CH.LUD)
	    END ELSE DO
		IF SELECT.CHANGE # 0 AND GET.CHANGE # 0 THEN DO
		    OFF.ALT
		    OPEN.LUD(UPDATE); LUD.SEQ; INC SEQ.FLG
		    LOOP DO
			IF LEGAL AND (ACCT.NUM = L.GAN) THEN DO
			    CHANGE.IT; LUD.WRIT
			    LIST.RECORD(0,OLD); SP
			    LIST.RECORD(CH.NUM,NEW)
			END
			LUD.SEQ
		    END
		    CLOSE(CH.LUD)
		    ON.ALT
		END
	    END

	LST.PPN: LISTFLG _ USER.LST
	    IF OPER # 0 THEN GET.PPN ELSE &
		[GET.UUN; HW(@TEMP,0) _ THIS.GAN; HW(@TEMP,1) _ UUN]
	    IF OPEN.AND.DUL.LOOK(TEMP) # 0 THEN DO
		USER.NAME(0) _ DUL(1); USER.NAME(1) _ DUL(2)
		IF NOT( DISPLAY.USER ) THEN RETURN 0
	     END ELSE [LUD(0) _ TEMP; USER.MISSING]

	LST.DIST: LISTFLG _ DIST.LST
	    IF OPER # 0 THEN DO
		MORE(MSG('District: '))
		DIST.NUM_ GETNUM
	    END ELSE DIST.NUM _ THIS.DIST
	    IF CMD = CMD.LIST THEN DO
		HEADING
		OPEN.LUD(INPUT); LUD.SEQ; INC SEQ.FLG
		LOOP DO
		    IF LEGAL AND (DIST.NUM = DIST.BITS) THEN LIST.RECORD(ALL.SET,OLD)
		    LUD.SEQ
		END
		CLOSE(CH.LUD) END ELSE DO
		IF SELECT.CHANGE # 0 AND GET.CHANGE # 0 THEN DO
		    OFF.ALT
		    OPEN.LUD(UPDATE); LUD.SEQ; INC SEQ.FLG
		    LOOP DO
			IF LEGAL AND (DIST.NUM = DIST.BITS) THEN DO
			    CHANGE.IT; LUD.WRIT
			    LIST.RECORD(0,OLD); SP
			    LIST.RECORD(CH.NUM,NEW)
			END
			LUD.SEQ
		    END
		    CLOSE(CH.LUD)
		    ON.ALT
		END
	    END

	LST.LUD: CHK.OPER
	    IF CMD = CMD.LIST THEN DO
		IO.ADR _ ENDLUD
		OUT.WHERE; OPEN.LUD(INPUT); INC SEQ.FLG; LUD.SEQ
		LOOP DO
		    IF OPEN.AND.DUL.LOOK(LUD(0)) # 0 THEN DO
			NAMOUT; GAN.OUT; SP; DISTOUT; SP
			NUMOUT(TYM.BIT); CR
		     END
		    CLOSE(CH.DUL); LUD.SEQ
		END
	    END ELSE DO
		IF TEMP _ GETULC < 0 THEN RETURN 0
		IF C.S.BIT(TEMP) # 1 THEN RETURN 0	! Requires CS
		IF SELECT.CHANGE # 0 AND GET.CHANGE # 0 THEN DO
		    OFF.ALT
		    OPEN.LUD(UPDATE); LUD.SEQ; INC SEQ.FLG
		    LOOP DO
			IF LEGAL THEN DO
			    CHANGE.IT; LUD.WRIT
			    LIST.RECORD(0,OLD); SP
			    LIST.RECORD(CH.NUM,NEW)
			END
			LUD.SEQ
		    END
		    CLOSE(CH.LUD)
		    ON.ALT
		END
	    END

	LST.RUB: IF CMD = CMD.CHANGE THEN [MSG('Cannot change RUB$');RETURN 0]
	    CHK.OPER; IO.ADR _ ENDLUD
	    OUT.WHERE; OPEN.LUD(INPUT); INC SEQ.FLG; LUD.SEQ
	    LOOP DO
		IF OPEN.AND.DUL.LOOK(LUD(0)) # 0 AND RUB.BIT # 0 THEN DO
		    NAMOUT; SP
		    NUMOUT(TYM.BIT); CR
		END
		CLOSE(CH.DUL); LUD.SEQ
	    END

     END				! end of DO LIST OF ...:...
    RETURN
END DO.LIST


%DO.NAMES
    IO.ADR _ ENDLUD; OUT.WHERE
    IF THIS.A.S # 0 THEN DO
	OPEN.LUD(INPUT); INC SEQ.FLG; LUD.SEQ
	LOOP DO
	   IF SAMACCT THEN DO
		IF OPEN.AND.DUL.LOOK(LUD(0)) = 0 THEN &
			USER.MISSING ELSE [NAMOUT; CR]
		CLOSE(CH.DUL)
	   END
	   LUD.SEQ
	END
    END ELSE [SIXOUT(THIS.NAME,12); CR]
    RETURN
END DO.NAMES


%LIST.ENTRY(LISTNUM,WHICH)

LOCAL SAV.LST

    DO LISTNUM OF ENT.NAME:ENT.MAX

ENT.NAME: IF LITTLE THEN DO
	MSG('User name: ');  NAMOUT
	IF LISTFLG = USER.LST THEN DO
	    MSG('  District: '); DISTOUT
	    MSG('    Account: '); OCTNUM(L.GAN); COMMA; OCTNUM(L.UUN)
	    CR
	END ELSE SP
    END ELSE DO
	NAMOUT
	IF  OPER = 0  OR   LISTFLG = ACCT.LST  THEN  DISTOUT
	IF  OPER # 0  AND  LISTFLG = DIST.LST  THEN  GAN.OUT
	UUN.OUT; SP
    END

CH.MSG: SAV.LST _ IF WHICH = OLD THEN SUPMSG.BIT ELSE SUP.SAV
    IF LITTLE THEN DO
	MSG('Banner message ')
	IF SAV.LST = 1 THEN MSG('suppress') ELSE MSG('print')
	MSG('ed at login.$')
    END ELSE [IF SAV.LST=0 THEN OUT('TYP') ELSE OUT('SUP'); SP]

CH.ZONE: SAV.LST _ IF WHICH = OLD THEN ZONE.BITS ELSE ZONE.SAV
    IF LITTLE THEN DO
	MSG('Time zone: ')
	IF SAV.LST#0 THEN MSG(ZONES(SAV.LST)) ELSE MSG('Not set.')
	SAV.LST _ IF WHICH = OLD THEN DAYLIG.BIT ELSE DAY.L.SAV
	IF SAV.LST = 1 THEN MSG(' (daylight savings).$') ELSE MSG(' (standard).$')
    END ELSE DO
	IF ZONES(SAV.LST)=-1 OR SAV.LST=0 THEN OUT('Not set') ELSE DO
	    TEMP_CHPT(ZONES(SAV.LST),-1)
	    SHORT.OUT(TEMP,5); DASH
	    SAV.LST _ IF WHICH = OLD THEN DAYLIG.BIT ELSE DAY.L.SAV
	    IF SAV.LST = 1 THEN CHR.OUT($D) ELSE CHR.OUT($S)
	END
	TYPSPACE(4)
    END

CH.LIC: IF LITTLE THEN MSG('License: ')
    SAV.LST _ IF WHICH = OLD THEN TYM.BIT ELSE TYM.SAV
    IF SAV.LST = 1 THEN OUT('TYM. ') ELSE OUT('     ')
    SAV.LST _ IF WHICH = OLD THEN ACTSUP.BIT ELSE A.S.SAV
    IF SAV.LST = 1 THEN OUT('ACT.SUP.') ELSE OUT('        ')
    IF BIG THEN SP ELSE CR

CH.MODE: IF CMD#CMD.CHANGE OR (THIS.AREA#JAPANESE AND DIST.BITS/10#JAPANESE) THEN DO
	SAV.LST _ IF WHICH = OLD THEN MODE.BIT ELSE MODE.SAV
	IF LITTLE THEN DO
	    MSG('Mode: ')
	    MSG(MODES(SAV.LST+1))
	    CR
	END ELSE DO
	    TEMP_CHPT(MODES(SAV.LST+1),-1)
	    SHORT.OUT(TEMP,6)
	    SP
	END
    END

CH.INIT: SAV.LST _ IF WHICH = OLD THEN INIT.BIT ELSE I.BIT.SAV
    IF SAV.LST = 1 THEN DO
	IF LITTLE THEN MSG('Initialization program: ')
	IF WHICH = OLD THEN DO
	    IF LUD(6+BUD.INDEX)#0 OR LUD(7+BUD.INDEX)#0 THEN &
		[CHR.OUT($();SIXOUT(@LUD(6+BUD.INDEX),12); CHR.OUT($))]
	END ELSE DO
	    IF I.USER.SAV(0) # 0 OR I.USER.SAV(1) # 0 THEN &
		[CHR.OUT($(); SIXOUT(I.USER.SAV,12); CHR.OUT($))]
	END
	IF WHICH = OLD THEN  SIXOUT(@LUD(5+BUD.INDEX),6) ELSE &
	    SIXOUT(@I.FILE.SAV,6)

    END ELSE IF LITTLE THEN MSG('No inititialization program.')
    IF BIG THEN [CR; NAMOUT; TYPSPACE(5)] ELSE CR	! 2nd line of listing

CH.DISC: SAV.LST _ IF WHICH = OLD THEN DISC.BIT ELSE DISC.SAV
    IF LITTLE THEN DO
	MSG('Disconnect: ')
	DO SAV.LST OF DB.LOG:DB.D.TO
	    DB.LOG:  MSG('Logout.')
	    DB.D:    MSG('Detach - stop running.')
	    DB.CONT: MSG('Detach - continue running.')
	    DB.D.TO: MSG('Detach - set time out.')
	END
	CR
    END ELSE DO
	DO SAV.LST OF DB.LOG:DB.D.TO
	    DB.LOG:  OUT('Log    ')
	    DB.D:    OUT('Det-S  ')
	    DB.CONT: OUT('Det-C  ')
	    DB.D.TO: OUT('Det-T  ')
	END
    END

CH.STR: IF LITTLE THEN [MSG('Quota on '); SIXOUT(@LUD.TEMP(5),6)]
    SAV.LST _ (IF WHICH = OLD THEN LUD.TEMP(6) ELSE Q.IN.SAV)/4
    IF LITTLE THEN MSG('  in: '); SPOUT(SAV.LST,6)
    NUMOUT(SAV.LST); SP; IF LITTLE THEN MSG('pages.')
    SAV.LST _ (IF WHICH = OLD THEN LUD.TEMP(7) ELSE Q.OUT.SAV)/4
    IF LITTLE THEN MSG('  out: '); SPOUT(SAV.LST,6)
    NUMOUT(SAV.LST); SP; IF LITTLE THEN MSG('pages.')
    IF LITTLE THEN CR

CH.CORE: SAV.LST _ IF WHICH = OLD THEN CORE1.LUD ELSE CORE.SAV
    IF LITTLE THEN MSG('Amount of memory: ')
    IF TEMP _ SAV.LST = 0 THEN DO
	IF LITTLE THEN MSG('System default$') ELSE OUT('Def')
    END ELSE DO
	TEMP _ (TEMP+1) * 2
	IF BIG THEN SPOUT(TEMP,3)
	NUMOUT(TEMP)
	IF LITTLE THEN CR
    END

CH.GFD: SAV.LST _ IF WHICH = OLD THEN GFD.BIT ELSE GFD.SAV
    IF SAV.LST = 0 THEN DO
	IF LITTLE THEN MSG('No ') ELSE OUT(' No ')
    END ELSE IF BIG THEN OUT(' Yes')
    IF LITTLE THEN MSG('GFD access by others in same account.$')

CH.PC: SAV.LST _ IF WHICH = OLD THEN PC.BIT ELSE PC.SAV
    IF LITTLE THEN DO
	MSG('Project-code: ')
	IF SAV.LST = 1 THEN MSG('Omitted.$') ELSE MSG('Required.$')
    END ELSE IF SAV.LST = 1 THEN OUT(' No ') ELSE OUT(' Yes')

CH.RUB: IF LITTLE THEN DO
	MSG('RUB: '); IF RUB.BIT # 1 THEN MSG('NOT '); MSG('SET.$')
    END

CH.BUD: IF TYM.BIT AND LITTLE THEN DO
	MSG('Budget: ')
	IF TRU.BIT = 0 THEN MSG('NOT SET.') ELSE NUMOUT(LUD(5)/10000)
	CR
    END

CH.RCM: IF LITTLE THEN DO
	MSG('Commands: ')
	IF RCM.BIT = 0 THEN MSG('Not ')
	MSG('Restricted.$')
    END

CH.ATT: SAV.LST _ IF WHICH = OLD THEN ATT.BIT ELSE ATT.SAV
    IF LITTLE THEN DO
	DO SAV.LST OF ATT.ALLOW:ATT.NONE
	    ATT.ALLOW: MSG('Allow')
	    ATT.FORCE: MSG('Force')
	    ATT.NONE:  MSG('No')
	END
	MSG(' attach on login.$')
    END

CH.NOLG: SAV.LST _ IF WHICH = OLD THEN (NOLOG.BIT SHL 1) + MLJOB.BIT &
				  ELSE LOG.SAV
    IF LITTLE THEN DO
	MSG('Login: ')
	DO SAV.LST OF LOG.MULTI:LOG.NONE
	    LOG.MULTI: MSG('Multiple jobs.')
	    LOG.ONE:   MSG('Only ONE job.')
	    LOG.NONE:  MSG('Not allowed.')
	END
	CR
    END

CH.ALOG: SAV.LST _ IF WHICH = OLD THEN AUTOLOGOUT ELSE AUTO.SAV
    IF LITTLE THEN DO
	MSG('Inactivity auto-logout ')
	IF SAV.LST = 1 THEN MSG('enabled.$') ELSE MSG('disabled.$')
    END

CH.SLOG: SAV.LST _ IF WHICH = OLD THEN STOPLOGOUT ELSE STOPLOG.SAV
    IF LITTLE THEN DO
	MSG('Environment protection ')
	IF SAV.LST = 1 THEN MSG('en') ELSE MSG('dis')
	MSG('abled.$')
    END

CH.SHUT: SAV.LST _ IF WHICH = OLD THEN SHUTFLAG ELSE SHUT.SAV
    IF LITTLE THEN DO
	MSG('Shut-override on local system ')
	IF SAV.LST = 1 THEN MSG('enabled.$') ELSE MSG('disabled.$')
    END

CH.BILL: SAV.LST _ IF WHICH = OLD THEN BILLFLAG ELSE BILL.SAV
    IF LITTLE THEN DO
	IF SAV.LST = 1 THEN MSG('Billable') ELSE MSG('Not billable')
	CR
    END

END
RETURN
END LIST.ENTRY


%LIST.EACH(NUMBER,TYPE)		! Listing: case out CHANGE flag items

DO NUMBER OF ENT.NAME:ENT.MAX
! Anyone:
    ENT.NAME: &
    CH.MSG:  CH.ZONE: CH.MODE: CH.DISC:  CH.ATT:  CH.GFD:  CH.INIT: &
					   LIST.ENTRY(NUMBER,TYPE)

! Account-Sup:
    CH.LIC:  CH.PC:   CH.NOLG: CH.ALOG: CH.SLOG: CH.RCM:  &
	IF CMD#CMD.CHANGE OR LEGAL.AS THEN LIST.ENTRY(NUMBER,TYPE)

! Oper: IF CMD#CMD.CHANGE OR OPER#0   THEN LIST.ENTRY(NUMBER,TYPE)

! Validations:
    CH.STR:  CH.CORE: CH.RUB:  &
	IF CMD#CMD.CHANGE OR GOD#0    THEN LIST.ENTRY(NUMBER,TYPE)

! *cannot change*
    CH.BUD:  &
	IF CMD#CMD.CHANGE             THEN LIST.ENTRY(NUMBER,TYPE)

! *2020 only*
    CH.SHUT: CH.BILL: &
	IF LOCAL.NET # 0              THEN LIST.ENTRY(NUMBER,TYPE)

END

RETURN
END LIST.EACH


%LIST.RECORD(LISTNUM,OLD.OR.NEW)
	!LIST RECORD POINTED TO BY L.INDEX...LIST ONLY
	!ITEMS THAT CAN BE CHANGED IF USER WANTS TO CHANGE...LIST ONLY
	!SELECTIVE ITEMS IF ALL DIST OR ALL ACCT. REQUESTED

    IF OPEN.AND.DUL.LOOK(LUD(0))=0 THEN DO
	CLOSE(CH.DUL)
	USER.MISSING
	RETURN
    END
    CLOSE(CH.DUL)

    IF LISTNUM=ALL.SET THEN DO
	IF BIG THEN DO
	    FOR LISTNUM _ ENT.NAME, CH.LIC, CH.MSG, CH.INIT, &
		    CH.ZONE, CH.DISC, CH.MODE, CH.STR, CH.CORE, CH.GFD, CH.PC &
		LIST.EACH(LISTNUM,OLD.OR.NEW); CR
	END ELSE DO
	    FOR LISTNUM _ ENT.NAME TO ENT.MAX LIST.EACH(LISTNUM,OLD.OR.NEW)
	    CR
	END
    END ELSE LIST.EACH(LISTNUM,OLD.OR.NEW)

RETURN
END LIST.RECORD


%DISPLAY.USER
    IF OPEN.AND.LUD.LOOK(INPUT) = 0 THEN NOT.VALID
    IF NOT( LEGAL ) THEN PROT.FAILURE
    LIST.RECORD(ALL.SET,OLD)
    IF CMD = CMD.CHANGE THEN LOOP DO
	IF SELECT.CHANGE = 0 THEN RETURN 0
	IF GET.CHANGE = 1 THEN DO
	    OFF.ALT
	    OPEN.AND.LUD.LOOK(UPDATE)
	    CHANGE.IT; LUD.WRIT
	    CLOSE(CH.LUD)
	    ON.ALT
	    LIST.RECORD(CH.NUM,NEW)
	END
    END
    RETURN 1
END DISPLAY.USER



%SELECT.CHANGE
    LOOP DO
	MSG('Change item: ')
	NCHV P_ EOLIT; PCHV P; GETTOKEN(0)
	CH.NUM _ CHOOSE(ENT.TYPE+3,CHANGES) - 3	! Subtract offset
	IF CH.NUM >  0 THEN RETURN CH.NUM	! Valid choice
	IF CH.NUM = -1 or CH.NUM = -2 THEN RETURN 0	! Typed 'NONE' or CR

	MSG('Available items:')
	MSG(' None,		Help		Banner'); CR
	MSG('Mode		 Time-zone	GFD		Initialization'); CR
	MSG('Disconnect	 Attach')

	IF ( THIS.A.S # 0  or  OPER # 0 ) THEN DO
	    MSG('		Project-code	License'); CR
	    MSG('Login		 Inactivity-logout		Environment'); CR
	    MSG('Commands')
	    IF ( OPER # 0 ) THEN DO
		MSG('	 Quota')
		IF ( GOD # 0 ) THEN DO
		    MSG('		Memory		Restricted')
		END
		CR
		IF LOCAL.NET # 0 THEN DO
		    MSG('Shut-override	 Billable-user'); CR
		END
	    END ELSE CR
	END ELSE CR
	CR				! Extra blank line for separation
    END
END SELECT.CHANGE


%GET.CHANGE
! CHANGE ITEM CH.NUM IN LUD

LOCAL TMP1, C.CNT

IF CH.NUM < ENT.MIN OR CH.NUM > ENT.MAX THEN RETURN 0

DO CH.NUM OF ENT.MIN:ENT.MAX

CH.LIC: IF OPER = 0 THEN RETURN 0
    TYM.SAV _ PQUERY('Tymnet proprietary')
    A.S.SAV _ PQUERY('Account supervisor')

CH.MSG: SUP.SAV _ (PQUERY('Print banner message at login')+1) BAND 1

CH.INIT: IF LISTFLG # USER.LST THEN RETURN 0
    I.FILE.SAV _ I.USER.SAV(0) _ I.USER.SAV(1) _ 0
    IF I.BIT.SAV _ PQUERY('Do you want to set an initialization program') = YES THEN DO
	NCHV P_ EOLIT; PCHV P
	MSG('Program name: '); GETTOKEN(0); C.CNT _ 0; P _ CHPT(TOKEN,-1)
	WHILE NCHV P # $. AND CHV P # 0 THEN INC C.CNT
	IF C.CNT > 6 THEN C.CNT _ 6
	MAKE.SIXBIT(TOKEN,@I.FILE.SAV,C.CNT)
	MSG('Directory: '); GETTOKEN(2)
	MAKE.SIXBIT(TOKEN,I.USER.SAV,12)
    END

CH.ZONE: IF LUD(0) = OPER.PPN THEN DO
	MSG('$OPER can not have its time zone changed.')
	RETURN 0
    END
    LOOP DO
	MORE( MSG('Enter time zone: ') ); GETTOKEN(0)
	WHILE ZONE.SAV _ CHOOSE(N.ZONES,ZONES) = 0
	NCHV P_ EOLIT; PCHV P
	MSG('Valid time zones are:$'); LISTABLE(N.ZONES,ZONES,5,', '); CR
    END
    DAY.L.SAV _ PQUERY('Subject to daylight saving')

CH.DISC: LOOP DO
	More( MSG('Disconnect option (Logout,Detach,Continue,Timeout): ') )
	GETTOKEN(0)
	WHILE DISC.SAV _ CHOOSE(N.DET.OPTS,DET.OPTS) = 0
	NCHV P_ EOLIT; PCHV P
	MSG('Valid options are '); LISTABLE(N.DET.OPTS,DET.OPTS,4,', '); CR
    END
    DISC.SAV - _ 1

CH.MODE: IF THIS.AREA = JAPANESE OR DIST.BITS/10 = JAPANESE THEN RETURN 0
    LOOP DO
	More( MSG('Mode: ') ); GETTOKEN(0)
	WHILE MODE.SAV _ CHOOSE(N.MODES,MODES) = 0
	NCHV P_ EOLIT; PCHV P
	MSG('Valid modes are '); LISTABLE(N.MODES,MODES,4,', '); CR
    END
    MODE.SAV - _ 1

CH.STR:	IF TEMP _ GETULC < 0 THEN RETURN 0
    IF C.S.BIT(TEMP) # 1 THEN RETURN 0		! Requires CS license
    More([CR;SIXOUT(@LUD.TEMP(5),6);MSG(' quota');CR;MSG('  in (in pages): ')])
    Q.IN.SAV _ GETNUM*4
    More( MSG(' out (in pages): ') )
    Q.OUT.SAV _ GETNUM*4

CH.GFD:   GFD.SAV     _ PQUERY('Allow others in this account to GFD')
CH.PC:	  PC.SAV      _ (PQUERY('Require project code')+1) BAND 1

CH.RCM:	  RCM.SAV     _ PQUERY('Restrict user commands')
CH.RUB:   RUB.SAV     _ PQUERY('Set restricted user')

CH.ATT: LOOP DO
	More( MSG('Attach on login (None,Allow,Force): ') ); GETTOKEN(0)
	WHILE ATT.SAV _ CHOOSE(N.ATT.OPTS,ATT.OPTS) = 0
	NCHV P_ EOLIT; PCHV P
	MSG('Valid options are '); LISTABLE(N.ATT.OPTS,ATT.OPTS,4,', '); CR
    END
    ATT.SAV - _ 1

CH.NOLG:  LOOP DO
	  More( MSG('Login option (None,One,Multiple): ') ); GETTOKEN(0)
	  WHILE LOG.SAV _ CHOOSE(N.LOGINS,LOGINS) = 0
	  NCHV P_ EOLIT; PCHV P
	  MSG('Valid options are '); LISTABLE(N.LOGINS,LOGINS,4,', '); CR
      END
      LOG.SAV - _ 1

CH.ALOG:  AUTO.SAV    _ PQUERY('Enable inactivity autologout')
CH.SLOG:  STOPLOG.SAV _ PQUERY('Enable protected environment')
CH.BUD:   MSG('Cannot change BUDGET'); CR; RETURN 0

CH.CORE: IF GOD = 0 THEN DO		! Must be GOD
	MSG('Cannot change memory allocation.$')
	RETURN 0
    END
    More( MSG('Enter amount of memory: ') )
    IF GETNUM > 256 THEN NUMBER _ 256
    TMP1 _ NUMBER/2
    IF TMP1 * 2 # NUMBER THEN DO
	NUMBER+_1
	MSG('Amount of memory must be even.')
    END
    IF NUMBER # 0 THEN NUMBER _ (NUMBER/2)-1
    CORE.SAV _ NUMBER

CH.SHUT:  SHUT.SAV    _ PQUERY('Enable local shut-override')
CH.BILL:  BILL.SAV    _ PQUERY('Enable local billable flag')

END
RETURN 1
END GET.CHANGE


%MAKE.ROOM
	!MAKE ROOM FOR AN ADDITIONAL 3 WORDS IN ENTRY...CREATE OVERFLOW
	!BLOCK IF NECESSARY
    LOCAL TMP,I,SAVENT(20)
    TMP _ SIZE.LUD.ENT
    MOVE TMP FROM @LUD(0) TO SAVENT
    MOVE SIZE.BLK-L.INDEX-TMP FROM @LUD(TMP) TO @LUD(0)
    WHILE LUD(0)#0 THEN L.INDEX+_SIZE.LUD.ENT
    MOVE TMP FROM SAVENT TO @LUD(0)
    IF L.INDEX+SIZE.LUD.ENT+3<SIZE.BLK THEN RETURN
    HW(@LUD(0),0) _ -1; OV.BLK _ LUD.SIZE+ _ 1
    LUD.WRIT; SETCP(CH.LUD,(LUD.SIZE+1)*SIZE.BLK)
    L.INDEX _ 0
    MOVE SIZE.BLK FROM ALL 0 TO LBLK
    MOVE TMP FROM SAVENT TO @LUD(0)
    RETURN

END MAKE.ROOM


%HEADING
    OUT.WHERE
    CR; DATOUT
    IF LISTFLG = ACCT.LST THEN [OUT('$Account: '); OCTNUM(ACCT.NUM)]
    IF LISTFLG = DIST.LST THEN [OUT('$District: ');NUMOUT(DIST.NUM)]
    OUT('$User         ')
    IF OPER = 0 OR LISTFLG=ACCT.LST THEN OUT('Dist ')
    IF OPER # 0 AND LISTFLG=DIST.LST THEN OUT('Acct   ')
    OUT('UUN      License     Msg Init program$')
    OUT('                   Zone     Det     Mode    Q-in   Q-out  Core GFD  PC$')
    OUT('                                             (in pages)$')
    RETURN

END HEADING


%CHANGE.IT

   DO CH.NUM OF ENT.MIN:ENT.MAX

CH.LIC: ACTSUP.BIT _ A.S.SAV; TYM.BIT _ TYM.SAV
CH.MSG: SUPMSG.BIT _ SUP.SAV

CH.INIT: IF I.BIT.SAV = 1 THEN DO
   IF INIT.BIT # 1 THEN [INIT.BIT _ 1; MAKE.ROOM; MOVE.DOWN; SIZE.INC]
   MOVE 2 FROM I.USER.SAV TO @LUD(TRU.BIT+6)
   LUD(BUD.INDEX+5) _ I.FILE.SAV
END ELSE DO
   IF INIT.BIT = 1 THEN DO
	INIT.BIT _ 0; SIZE.DEC
   MOVE (SIZE.BLK-(L.INDEX+SIZE.LUD.ENT)) FROM &
	@LUD(BUD.INDEX+8) TO @LUD(BUD.INDEX+5)
   MOVE 3 FROM ALL 0 TO L.BLK(126)
   END
END

CH.ZONE: ZONE.BITS   _ ZONE.SAV; DAYLIG.BIT  _ DAY.L.SAV
CH.DISC: DISC.BIT    _ DISC.SAV
CH.MODE: MODE.BIT    _ MODE.SAV
CH.STR:  LUD.TEMP(6) _ Q.IN.SAV; LUD.TEMP(7) _ Q.OUT.SAV
CH.CORE: CORE1.LUD   _ CORE.SAV; CORE.2.LUD  _ CORE.SAV
CH.GFD:  GFD.BIT     _ GFD.SAV
CH.PC:	 PC.BIT      _ PC.SAV
CH.RCM:  RCM.BIT     _ RCM.SAV
CH.RUB:  RUB.BIT     _ RUB.SAV
CH.ATT:  ATT.BIT     _ ATT.SAV
CH.NOLG: NOLOG.BIT   _ LOG.SAV SHR 1; MLJOB.BIT _ LOG.SAV
CH.ALOG: AUTOLOGOUT  _ AUTO.SAV
CH.SLOG: STOPLOGOUT  _ STOPLOG.SAV
CH.SHUT: SHUTFLAG    _ SHUT.SAV
CH.BILL: BILLFLAG    _ BILL.SAV

END
RETURN 1
END CHANGE.IT



%CALL.UUO(AC,ADDR,SKPFLG)
LOCAL DIDIT:
^OCT 12 _AC
EXU(OCT 47, OCT 12, ADDR, DIDIT)
IF SKPFLG = 1 THEN [MSG('$UUO failed.'); EXIT]
DIDIT: RETURN ^OCT 12
END CALL.UUO


%NEXT.TEN(PTR)
LOCAL T
T_ PTR
CHR.OUT($<); IF CHV T # EOLIT THEN CHR.OUT(CHV T); CHR.OUT($>)
WHILE NCHV T # EOLIT THEN CHR.OUT(CHV T); MSG('<eolit>'); CR

END NEXT.TEN


%LUD.CHK
	!READ THRU LUD, LOOKING UP AND VERIFYING EACH ENTRY IN DUL
LOCAL %CK.LUD.SEQ, %L.FIRST
LOCAL DULFLG, LP1:
IO.ADR _ CK.DUL
MSG('Verify LUD against DUL$')
SETCP(CH.LUD,0); L.BLKNO _ 1; LUD.READ; L.FIRST; GO LP1
LOOP DO
   LP1:WHILE LUD(4) = 0 THEN CK.LUD.SEQ
   IF DULFLG _ DUL.LOOK(LUD(0)) = 1 THEN DO
	HASH(DUL(1),DUL(2))
	IF NAME.HASH # LUD(4) THEN ERROR(HASH.BAD)
	IF LOC.HASH # L.BLKNO THEN ERROR(BLKNO.BAD)
   END ELSE ERROR(NODUL.BAD)
   CK.LUD.SEQ
END

%CK.LUD.SEQ
LOCAL J
L.INDEX + _ SIZE.LUD.ENT
%%L.FIRST
WHILE LUD(0) = 0 THEN DO
   LOOP DO
   FOR J_1 TO SIZE.BLK-1-L.INDEX IF LUD(J)#0 THEN &
	[BADBLK_L.BLKNO; ERROR(GARBAGE); REPEAT 0]
   REPEAT 0
   END
   INC L.BLKNO; LUD.READ
END
RETURN
END CK.LUD.SEQ
END LUDCHK


%DULCHK
	!READ THRU DUL, LOOKING UP ENTRY IN LUD
LOCAL ENDDUL:
IO.ADR _ ENDDUL
MSG('Verify DUL against LUD$')
DUL.READ; D.INDEX _ -3
LOOP DO
   DUL.SEQ
   IF LUD.LOOK(@DUL(1)) # 0 THEN DO
	IF LUD(0) # DUL(0) THEN ERROR(BAD.PPNS)
   END ELSE ERROR(NOLUD.BAD)
END
ENDDUL: RETURN
END DULCHK



%ERROR(ERR)
	!TYPE OUT DATA ERRORS TO USER
DO ERR OF NODUL.BAD:OVER.BAD
   NODUL.BAD: OUT('NO DUL ENTRY FOR ');  PPN.OUT
   HASH.BAD: OUT('HASH OF '); PPN.OUT; EQUALS
	OCTWD.OUT(NAME.HASH); CR; OUT('ENTRY IN LUD = ')
	OCTWD.OUT(LUD(4))
   BLKNO.BAD: OUT('HASH BLK. NO. OF '); PPN.OUT; EQUALS
	OCTOUT(LOC.HASH); CR; OUT('ENTRY IS IN BLK. NO. ')
	NUMOUT(L.BLKNO); DOTS; NAM.OUT
   NOLUD.BAD: OUT('NO LUD ENTRY FOR '); OCTWD.OUT(DUL(0)); DOTS
	NAM.OUT
   GARBAGE: OUT('GARBAGE IN BLOCK '); NUMOUT(BADBLK)
	OUT(' NOT FOUND')
   BAD.PPNS: OUT('LUD PPN = '); PPN.OUT; DOTS
	OUT('DUL PPN = '); OCTWD.OUT(DUL(0))
   OVER.BAD: OUT('OVERFLOW POINT IN '); OUT(BADFIL); OUT(' IS IN WORD ')
	NUMOUT(BADBLK); OUT(' BLOCK '); NUMOUT(L.BLKNO)
	CR; CLOSE.ALL; EXIT
END
CR
RETURN
END ERROR

END NONAME
    'c!