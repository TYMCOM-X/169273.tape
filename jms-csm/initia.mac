SUBTTL	AUTHOR:P.CONKLIN /PMW/JNG/WLH/KPY/WCL/GMU/CDO/TARL
; OLD AUTHOR INITIALS:/RCC/DAL/PFC

	TTWMAX==0	;CSM does not want TTY STOMPER


;COPYRIGHT (C) 1970,1971,1972,1973,1974,1975,1976,1977,1978,1980,1982,1984 BY
;DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.

INTWHO==2		; LAST MODIFIER Joe Smith @ CSM
INTVER==10		; MAJOR VERSION
INTMIN==0		; MINOR VERSION
INTEDT==220		; EDIT LEVEL

	SALL				; CLEAN ASSEMBLY LISTINGS

	SEARCH	JOBDAT,MACTEN,UUOSYM

	TITLE. (INT,INITIA,SYSTEM START-UP PROGRAM)
	INTTTL
	INTPTX

; JOB DATA AREA
	INT137

; SHOW VERSIONS OF UNIVERSAL FILES
	%%JOBD==%%JOBD			; SHOW VERSION OF JOBDAT
	%%MACT==%%MACT			; VERSION OF MACTEN
	.REQUEST  REL:HELPER		; USES HELPER [10(146)]

;ASSEMBLY INSTRUCTIONS:
;	.LOAD INITIA



;ASSEMBLY PARAMETERS

ND	L$PDL,20	;LENGTH OF PUSH-DOWN LIST
ND	L$TTBF,^D100	;SIZE OF TTY OUTPUT BUFFER IN WORDS
ND	N$HSGF,^D50	;NUMBER OF FILES WHICH CAN BE REMEMBERED
ND	N$STRS,^D36	;NUMBER OF STRUCTURES IN S/L (MAX)
ND	FLN$MX,^D80	;NUMBER OF CHARACTERS TO BUFFER TO FRCLIN
ND	CTYHPQ,1	;HPQ TO RUN IN ON THE CTY
ND	NETSLP,^D5	;NETWORK SLEEP TIME IN FILCON
ND	TTWMAX,^D05	;.GT. 0 THEN FRCLIN INITIA STOMPS ON "OPEN" TTY LINES
			; WHERE "OPEN" := .GE. TTWMAX CHARS PER SECOND INPUT
ND	TTWSLP,^D60	;TIME TO SLEEP 'TWIXT SAMPLINGS
ND	LNTPAG,600	;START PAGE TO USE TO MAP IN LINTAB
ND	LDBPAG,640	;START PAGE TO USE TO MAP IN LDBS
SUBTTL	TABLE OF CONTENTS

;               TABLE OF CONTENTS FOR INITIA
;
;
;                        SECTION                                   PAGE
;    1. TABLE OF CONTENTS.........................................   2
;    2. REVISION HISTORY..........................................   3
;    3. DEFINITIONS...............................................   6
;    4. INITIALIZATION............................................   8
;    5. CODE TO HANDLE SPECIAL STARTUP CONDITIONS.................  10
;    6. MAIN PROGRAM
;         6.1   HANDLE COMMAND SCANNING AND DISPATCH..............  12
;    7. HANDLE COMMAND LINE.......................................  16
;    8. SUBROUTINE TO IDENTIFY AND SAVE COMMAND...................  20
;    9. DEFINE SYSTEMS WHICH NEED SPECIAL SET-UP..................  21
;   10. SYSTEM TABLES.............................................  22
;   11. STANDARD COMMAND TABLES...................................  23
;   12. ROUTINES FOR VARIOUS COMMANDS.............................  25
;   13. NO COMMAND HANDLER........................................  25
;   14. RCV/XMT SPEED COMMAND HANDLER.............................  25
;   15. PAGE COMMAND HANDLER......................................  26
;   16. DIAL COMMAND HANDLER......................................  26
;   17. ROUTINE TO SETUP TTY......................................  27
;   18. ROUTINE TO SETUP TTY "TYPE"...............................  29
;   19. TTY CONTROL LIST ROUTINE..................................  30
;   20. ROUTINE TO KJOB IF SYSTEM GOING DOWN......................  31
;   21. SPECIAL PROCESSORS........................................  32
;   22. FILEX PROCESSOR...........................................  32
;   23. OMOUNT PROCESSOR..........................................  32
;   24. DAEMON PROCESSOR..........................................  32
;   25. CHKPNT PROCESSOR..........................................  32
;   26. OPSER PROCESSOR...........................................  32
;   27. PRINTR PROCESSOR..........................................  32
;   28. SYSDPY PROCESSOR..........................................  32
;   29. LOGIN TO 1,2 AND RUN CUSP NAMED IN T4.....................  33
;   30. START UP CUSP NAMED IN T2.................................  33
;   31. KILL JOB ROUTINE..........................................  34
;   32. SUBROUTINE TO LIST STRUCTURE NOTES........................  35
;   33. HELP ROUTINE..............................................  35
;   34. SUBROUTINES TO LIST SYSTEM, AND TEXT NOTICES..............  36
;   35. SUBROUTINE TO TYPE TTY SETTINGS...........................  38
;   36. ROUTINE TO TYPE PAGE:N OR NOPAGE..........................  39
;   37. ROUTINE TO FORMAT SPEED...................................  39
;   38. ROUTINE TO TYPE TYPE:XXXXXX...............................  39
;   39. ROUTINE TO FORMAT DECIMAL.................................  39
;   40. ROUTINE TO FORMAT BIT VALUES..............................  39
;   41. TTY SETUP PROCESSORS......................................  40
;   42. TERMINET ROUTINE..........................................  40
;   43. INPUT ROUTINES............................................  41
;   44. TABLE SEARCH ROUTINE......................................  41
;   45. SKIP TO VALUE ROUTINE.....................................  42
;   46. DECIMAL READ ROUTINE......................................  42
;   47. OCTAL READ ROUTINE........................................  42
;   48. SIXBIT NAME ROUTINE (GETSIX)..............................  43
;   49. TTY EXPANSION ROUTINE (XPNTTY)............................  44
;   50. CVTSIX....................................................  45
;   51. SIXBIT WORD ROUTINE (GETWRD)..............................  46
;   52. CHARACTER ROUTINE (GETCHA)................................  47
;   53. SUBROUTINE TO READ FROM COMMAND TTY.......................  47
;   54. COMMAND LINE PROCESSOR....................................  48
;   55. SUBROUTINE TO TYPE CONTENTS OF FILE.......................  48
;   56. SUBROUTINE TO READ FROM FILE..............................  54
;   57. SUBROUTINES...............................................  55
;   58. SUBROUTINE TO LOGIN A JOB.................................  55
;   59. SUBROUTINE TO TYPE SIGN ON MESSAGE........................  60
;   60. SUBROUTINE TO TYPE KSYS MESSAGE...........................  62
;   61. ERROR HANDLERS............................................  63
;   62. TYPEOUT ROUTINES..........................................  63
;   63. GTNTN. ROUTINE............................................  66
;   64. SPECIAL TTY SETUP SEQUENCES...............................  66
;   65. STORAGE AREA..............................................  67
SUBTTL	REVISION HISTORY

;%3	OCT, 71

;40	UPDATE DEC APR TABLES
;41	(10-11146) CORRECT FILEX PPN
;42	CONVERT TO C AND MAKE REENTRANT
;43	ADD APR S/N TO SIGNON MESSAGE
;44	HANDLE CASE OF .HELLO (TTY DATASET ANSWER)
;45	CHANGE TERMINET OPTION TO COMMAND LINE
;46	ADD STRUCTURE COMMAND TO COMMAND LINE
;47	LOOK AT FILE SYS:TTY.INI. LINES ARE ALL, OTHER, TTYX,TTYX-Y
;50	ADD ALL TRMOP'S FROM TTY.INI
;51	ADD HELP
;52	ADD KSYS OPTION
;53	ADD JOB # AND USER NAME IF LOGGED IN
;54	ADD ".LOGIN A,B" WHEN LOGGING IN
;55	ADD NOTICE OPTION
;56	ADD TTY OPTION
;57	GET REAL S/L IF POSSIBLE
;60	IMPLEMENT DIAL OPTION
;61	ALLOW CONTINUATION IN FILE TTY.INI AND COMMENTS ON
;	ALL COMMANDS
;62	ENSURE . IS ALWAYS TYPED JUST ONCE AT EXIT
;63	USE C AS A UNIVERSAL
;64	ADD NONAME
;65	ADD NORUN
;66	ADD NOSETTTY
;67	IF LOGGED IN, ALSO USE SWITCH.INI
;70	ALLOW TT: FOR TTY:
;71	DEFAULT TO NOSETTTY IF LOGGED IN
;72	SEPARATE USER SETTABLE TTY STUFF IN TTY TYPEOUT
;73	FIX BUGS REPORTED IN QAR-1563 (WPI)
;74	ALLOW () IN .INI OPTIONS
;%4(74)	JUNE, 1974
;75	HAVE INITIA REMEMBER TTY.INI AND STR.TXT IN HISEG
;76	CHANGE ALL OUTCHR UUO'S TO SUBROUTINE CALLS AND DO
;	BUFFERED TTY OUTPUT FOR SPEED
;77	ADD RTCOMPAT TO LIST OF TTY SWITCHES
;100	USE NON-BLOCKING TTY I/O TO AVOID GETTING HUNG IN 'TO'
;	STATE.
;101	(10-13,784) GET JOB NUMBER CORRECTLY IF JOBSTS FAILS
;102	(10-13,784) ADD OPTION FOR DAEMON
;103	OUTPUT "OR ATTACH" ONLY IF SOME DETACHED JOBS
;104	(SER 922) DON'T PRINT SPEED:0
;105	(10-13,595) REMOVE INICER MESSAGE ON NULL COMMAND
;106	(10-14,000) FIX BUG WHICH MISSED OTHER IN SWITCH.INI
;107	SUPPRESS "PLEASE LOGIN" IF SCHED 7
;110	(CER S70-725) WHEN LISTING USER NAME, ALSO GIVE PPN
;111	HANDLE UP TO 36 STRS IN S/L
;112	SET DEFAULT PHY & VIRT LIMITS TO 1000P
;113	REMOVE KSYS CALL OF KJOB (OPSER 5A DOES IT)
;114	DON'T LOGIN [1,2] UNLESS LOCAL TERMINAL
;115	PREVENT LOOP IF UNMATCHED '(' IN TTY.INI OR SWITCH.INI
;116	IMPLEMENT BATCH KEYWORD
;117	FIX HILOOK BUG
;120	IMPLEMENT TEXT KEYWORD
;121	BE SUSPICIOUS OF DEAD HI-SEG INTERLOCKS -- SLOWS SYS START UP
;122	ADD SYSV52 AND SYSV61 [TTY.INI COMMANDS--SYSVFT AND SYSVSO]
;123	FIX PROBLEM WITH CORE UUO FAILURE
;124	DON'T GIVE ALL PRIVILEGES TO REMOTE OPR
;125	UNKNOWN.
;126    CHANGES  TO  IMPLEMENT  'DETECT  XXXX'   FOR   SPEED
;       DEPENDENT SETUP OF DIAL-UP LINES, 'LINSPD' FOR LINES
;       RUNNING AT SPECIFIED BAUD, AND  'OTHSPD'  FOR  LINES
;       NOT AT THE SPECIFIED BAUD.
;127	ADD NETWORK CAPABILITIES FOR DIRECT ACCESS TO PHYSICAL TTY'S
;130	MERGE EDITS 126-127.
;131-132 CLEAN UP LISTING.
;133	CLEAR EOF BIT BEFORE READING ACCOUNTING FILE.
;134	FIX BUG IN NTKSYS ROUTINE..USED WRONG
;	UUO TO GET STATION STATUS.
;135	FIX BUG THAT SETUP NETWORK LINES IMPROPERLY.
;136	INSTALL CONTROL-C INTERCEPT SO HIGH SEGMENT DOESN'T
;	GET LEFT IN AN INTERLOCKED STATE.
;137	DON'T TYPE NETWORK STUFF UNLESS WERE ON A NODE,
;	QAR#631.
;	FIX CTY BUG IN XPNTTY ROUTINE.
;	USE TITLE. MACRO FROM MODUNV.UNV.
;140	MINOR FIXUPS...QAR'S 10-00671 & 10-00681
;141	MAKE SURE THAT NO LINE, LOCAL OPR OR NOT, GETS TO
;	BE A REMOTE OPR, IF IT'S ON NODE 0.
;142	1) EDIT 136 ALLOWS CONTROL-C INTERCEPT TO HAPPEN FOR ALL
;	JOBS RUNNING AT SYSTEM STARTUP TIME....DON'T DO THAT.
;	TURN THE INTERCEPT OFF AGAIN AS SOON AS WE FIND OUT
;	THAT WE'RE GOING TO WAIT FOR SOMEONE ELSE TO DO THE
;	DIRTY WORK!
;	2) PURGE REMOTE STATION STUFF..RUNNING OF REMLOD ETC.
;	AND CHANGE CODE FOR CENTRAL OPR TO GET CENTRAL OPR AND
;	NOT LOCAL OPR.
;143	CLEAN UP LISTING. REMOVE VRSN. MACRO.
;144	FIX FAULTY COMPARE AT NOTFND ROUTINE. CAUSED REMOTE
;	STATION OPR TERMINAL NOT TO COME UP.
;145	MAKE 144 WORK. CHANGE TO VERSION 7 FOR DISTRIBUTION.
;	CHANGE KEYWORD "BLANK" TO "BLANKS" IN STANDARD COMMAND TABLES.
;146	1) FIX TO HANDLE TTY0 AT CENTRAL SITE.
;	2) GET HELPER.REL FROM REL: RATHER THAN DSK:  IN ".REQUEST"
;	   PSEUDO-OP.
;	3) ELIMINATE REFERENCE TO MODUNV.UNV FILE.
;	   MACROS DEFINED IN MACTEN.UNV.
;147	(WEM) MAKE 'TTY.INI' AND 'AUXACC.SYS' LOOKUPS PHYSICAL
;	      ONLY.
;150	(WEM) MAKE INITIA USE THE HIBER AND WAKE UUO'S IN ORDER
;	      TO LESSEN THE AMOUNT OF TIME IT SPENDS WAITING ON
;	      THE HIGH-SEGMENT INTERLOCK.
;151	(KPY) FIX SOME BUGS INTRODUCED WITH EDIT 150
;	      AND REMOVE SOME EXTRANEOUS CODE.
;152    MAKE IT SKIP TABS PRECEDING COMMAND
;153    INCLUDE SKIPPING OF TABS WITHIN COMMAND LINE
;154    FIX RESCANNING OF COMMENT AT END OF LINE
;155	REMOVE CHECK IF TTY# EQUALS PHYSICAL LINE #
;	(HISTORICAL REASONS ONLY) THUS PRINT MESSAGE
;	"CONNECTED TO NODE" IN ANY CASE.
;156	ADD CODING FOR SETTING/REPORTING TERMINAL TYPE
;157	MAKE TERMINAL TYPE COMPATIBLE WITH "NO" CONSTRUCTION
;160	MORE ON "NO" CONSTRUCTION FOR TERMINAL TYPE
;161	MAKE TERMINAL TYPE SETTING SAME AS OTHER TTY SETUP FEATURES
;162	MAKE CHANGE FOR NEW TRMOP. WHICH RETURNS TERMINAL TYPE
;	IN SIXBIT
;163	ADD LOCATE:NN COMMAND WHICH WILL LOCATE USER TO NODE
;	SPECIFIED.  OR IN THE ABSENCE OF A LOCATE COMMAND, LOCATE TO
;	THE CENTRAL SITE IF HE IS BEING LOGGED IN ON A NODE WITHOUT
;	AN LPT
;164	CHANGE ORDER OF TRMOP.S,  DO TYPE BEFORE PAGESIZE
;	(IN DOTTYT: .TOTRM BEFORE .TOPSZ)
;165	ON A FORCED RUN OF INITIA AT SYSTEM STARTUP, ONLY ONE COPY OF
;	INITIA WAS RUNNING AT A TIME.  THIS IS ONLY NEEDED WHEN THE
;	FIRST ONE TO RUN IS READING THE FILES INTO THE HIGH SEG.
;	AFTER THIS IS DONE, ALLOW ALL OTHER COPIES TO RUN CONCURRENTLY.
;	ALSO DO SOME PERFORMANCE WORK TO MAKE INITIA RUN FASTER AT
;	SYSTEM STARTUP.
;166	ADD GALOPR COMMAND IN TTY.INI TO GIVE CCL RUN TO GALAXY OPR
;167	PUSH THE CONTENTS OF SYS:SYSJOB.INI DOWN FRCLIN DURING SYSTEM STARTUP
;170	DO SETUUO TO SETUP OPR PRIVILEGES BEFORE LOGGING IN
;	SET ONLY REMOTE OPR PRIV IF LOGGING IN A REMOTE OPR
;171	MORE OF EDIT 165
;172	RE-FORMAT OUTPUT OF TTY CHARACTERISTICS
;173	FIX BUG WHICH ALLOWED "INITIA SETTTY NO REMOTE" IN SWITCH.INI
;	TO ACTUALLY SET THE LINE NO REMOTE
;174	ACCEPT "DEFER" IN TTY.INI/SWITCH.INI FOR DEFERED ECHOING
;	REPORT SAME IN TYPTTY.
;**** SHIPPED WITH 701
;**** START VERSION 10
;175	SPR #30106	BCM	10-DEC-80
;	DETACH FROM FRCLIN SO COMMANDS CAN START TO BE PROCESSED
;176	SPR #30351	RKB	31-DEC-80
;	THE CODE AROUND FILE.1 WAS NOT READING SYS:TTY.INI PROPERLY FOR
;	NODES NAMED "OTHER", "DETECT", "LINSPD", OR "OTHSPD".
;177	NO SPR		RDH	14-JAN-81
;	ADD "CONNECT" PSEUDO-COMMAND TO TTY.INI
;200	NO SPR		RDH	20-JAN-81
;	IF TTWMAX .GT. 0 THEN HAVE FRCLIN INITIA HANG AROUND AND WATCH FOR
;	TTY LINES RUNNING OPEN AND STOMP ON 'EM
;201	SPR #30510	BCM	16-Apr-81
;	REMOVE OBSOLETE "BATCH" OPTION SINCE MPB IS GONE
;	ALSO CHANGE THE OPR PRIV. SINCE UUOSYM CHANGED
;202	SPR #30875	BCM	16-Apr-81
;	IF SYSJOB.INI DOES NOT EXIST, DIE GRACEFULLY
;203	NO SPR		TARL	21-apr-81
;	MORE EDIT 200. MAKE INITIA ASSIGN THE OPEN LINES, SO THEY WON'T
;	WAKE UP AGAIN WHEN THE -11 SENDS THE DISCONNECT MESSAGE. ALSO
;	LOG INITIA IN, SO IT LOOKS LESS LIKE A MUNCHING PROGRAM AND
;	DOESNT GET CAUGHT BY KILL DOING A 'ZAP *'
;204	NO SPR	TARL	23-Jul-81
;	ADD XONXOFF TO LIST OF CHARACTERISTICS DISPLAYED ON .I TTY
;	[KEEP WSM HAPPY]
;205	NO SPR	TARL	8-Aug-81
;	CHANGE INPUT BUFFER CHECK IN FRCLIN PROCESSING FROM .TOSIP TO
;	A .TOTTC, SINCE A .TOSIP WILL MAKE RESCANS FROM FRCLIN FAIL.
;206	NO SPR TARL 9-Aug-81
;	MORE EDIT 200. CLEAN UP SOME EDIT 203, AND GIVE MORE INFORMATIVE
;	MESSAGES WHEN WE STOMP ON A LINE
;207	NO SPR TARL 18-oct-81
;	CLEAN UP CLEAN UP PROCEDURES FOR TTY STOMPER.
;210	NO SPR TARL 19-jan-82
;	MAKE TTY STOMPER GIVE SIXBIT LOGICAL NAMES TO THE TTYS IT OPENS.
;211	NO SPR TARL 16-Feb-82
;	FIX STACK SKEW PROBLEM WITH EDIT 206
;212	NO SPR TARL 24-aug-82
;	GIVE AN ERROR (TNF) IF SYS:TTY.INI CAN'T BE FOUND.
;213	NO SPR TARL 24-aug-82
;	MAKE TTY STOMPER SET IT'S PROGRAM NAME TO SOMETHING RECOGNIZABLE
;	AND FINDABLE BY WHO: "STOMPR". ALSO DO CLRBFI'S ON ALL TTY LINES
;	THAT HAVE ANY CHARACTERS IN THEIR INPUT BUFFERS.
;214	NO SPR Tarl 11-Apr-83
;	ASSORTED CLEANUPS.
;	  ALLOW TURNING OFF TTY STOMPER (MISSING ANGLE BRACKET)
;	  ALLOCATE ONLY ENOUGH ENTRIES FOR REAL TTYS (LH %CNPTY) IN STOMPER
;		TABLES.
;	  MAKE MESSAGES FROM STOMPER SAY "%%TTY STOMPER -". RESERVE THE HEADING
;		"%%FRCLIN INITIA" TO ITS FRCLIN STAGE.
;	  MAKE STOMPR LESS VICIOUS. IF A TERMINAL IS BUSY, MERELY FLAG THE FACT
;		AND DON'T GET CHARACTER COUNTS. WE'LL GET THEM WHEN TTY IS FREE.
;	  MAKE STOMPR FASTER. MAP IN LINTAB AND LDBS, SO WE CAN CHECK FAST IF
;		TTY IS BUSY. IF NO DDB, WE GO THROUGH NORMAL ALGORITHM.
;215	NO SPR Tarl 25-Apr-83
;	MORE 214. ALLOW TURNING OFF TTY STOMPER AGAIN. MAKE SURE INITIA GOES
;	AWAY IF HE DECIDES TO LOG OUT.
;216	QAR 125089 Tarl 25-Apr-83
;	MAKE THE STOMPR FUNCTION DEPENDANT ON THE "STOMP" KEYWORD BEING
;	PRESENT IN TTY.INI. ALSO MAKE "STOMP" INLINE COMMAND WORK VIA
;	JUMPPR, SO THAT WE ARE APPROPRIATLEY CLEANED UP.
;	NOTE THAT IT IS NO LONGER NECESSARY TO TURN OFF STOMPR VIA TTWMAX,
;	YOU CAN MERELY NOT INCLUDE THE STOMP COMMAND IN TTY.INI
;217	QAR 125113 Tarl 25-Apr-83
;	MAKE INITIA RUN THE RIGHT VERSION OF SYSDPY DEPENDING ON WHAT TERMINAL
;	TYPE YOU ARE. ALL SYSDPY KEYWORDS NOW DISPATCH TO THE SAME LOCATION,
;	WHICH WILL DETERMINE TERMINAL TYPE, AND THEN RUN A VERSION OF SYSDPY.
;
;	CUSTOMERS: TO ADD TERMINAL TYPES, LOOK AT "DPYNAM" MACRO.
;
;220	QAR        Tarl 22-May-83
;	KEEP IT RUNNABLE ON KI'S. CHANGE ADJSP TO POP P,(P)
;
;
;
;END OF EDIT HISTORY

;CSM1	Change TYPE command to use a general SIXBIT input routine.
;	Add SPEED:AUTO for documentation purposes.
;
;CSM2	Define SYSJOB command to force contents of SYS:TTYnnn.INI into
;	the input buffer (like FRCLIN but for other TTYs).
;
;CSM3	Add command ASKID:LA36 to ask the terminal to identify itself
;	(via ESC-Z or ESC-[c-ESC-\) to see if it is a VT52 or VT100.
;	If no response, use the argument to the ASKID command.
;	For VT100's, type out SYS:VT100.TTY (double width double height).
;
;CSM4	Add SETUP:LA34 to send the contents of ASCII file SYS:LA34.TTY
;	to the terminal (for setting tab stops, etc).  This replaces
;	the TERMINET routine.  Add BLOAD:8080 to send the contents of
;	SYS:8080.BIN to the intelligent terminal using PIM.
;
;CSM5	Raise DTR on all lines, and drop DTR at startup on datasets.
;
;CSM6	Look for SYS:NOTICE.T?? in NOTE command
;
;End of CSM Revision History
SUBTTL	DEFINITIONS

;AC NAMES

F=0	;FLAGS
T1=1	;TEMPORARIES
T2=2
T3=3
T4=4
T5=5
T6=6
T7=7
T8=10
I=11	;INDEX INTO HISEG TABLES
OC=12	;TEMP FOR TTYSTR LUUO

WD=13	;LAST INPUT WORD
CH=14	;LAST INPUT CHARACTER
BP=15	;BOMB OUT PC
ME=16	;TTY NAME OF THIS TTY
P=17	;PUSHJ-DOWN LIST POINTER


;INPUT/OUTPUT CHANNELS

IO==0	;USED FOR TEMP FILES
TI==1	;TTY.INI
TTY==2	;TTY OUTPUT
TTZ==3	;FOR USE CHECKING IN FILCON
;FLAG BITS

F.LOGI==1B0		;LOGGED IN
F.LOGX==1B1		;OK IF ALREADY LOGGED IN
F.CCL==1B2		;FORCE CCL STARTING POINT
F.NOHD==1B3		;SUPPRESS HEADER TYPEOUT
F.PRIV==1B4		;GIVE JOB ALL PRIVILEGES
F.CCLC==1B5		;CALLED FROM CCL MODE
F.REMO==1B6		;REMOTE OPR
F.ANSW==1B8		;JUST ANSWERED TTY MODEM
F.ICMD==1B9		;INITIA COMMAND
F.ECMD==1B10		;END OF COMMAND LINE
F.EOF==1B11		;END OF FILE
F.NO==1B12		;NO XXX
F.CERR==1B13		;COMMAND ERROR
F.BIN==1B14		;READ IN BINARY
F.ALIN==1B15		;SOME LINE FOUND IN TTY.INI
F.RTTY==1B16		;RESCANNED TTY, BUT NOT REEATENYET
F.TSOL==1B17		;TYPED SOMETHING ON THIS LINE

F.PARN==1B18		;PAREN LIST OF TTYS
F.PHYS==1B19		;RUN JOB VIA PHYSICAL RUN
F.NJBS==1B20		;SET IF NO JOBSTS UUO
F.CTY==1B21		;RUNNING ON CTY
F.FLN==1B22		;RUNNING ON FRCLIN
F.PCR==1B23		;[CSM3] Preserve CR and DEL in HISEG file


;USEFUL OPDEFS

OPDEF	BOMB$	[JSP BP,E$$BMB]	;DEBUGGING AID--PERMANENT FEATURE

;[CSM3] Change to TTYSTR LUUO for TRMTYP routine
;FOR LUUOS, IF AC1 IS ON, POPJ AFTER DOING LUUO
;[CSM3] If AC2 is on, dump output buffer after doing LUUO

OPDEF	TTYCHR	[1B8]	;IMMEDIATE MODE OUTCHR LUUO
OPDEF	TTYSTR	[2B8]	;OUTSTR LUUO

OPDEF	CTYSTR	[3B8]	;OUTSTR TO THE CTY
OPDEF	CTYCHR	[4B8]	;OUTCHR TO THE CTY



	TWOSEG
	RELOC	400000


COPYRIGHT (C) DIGITAL EQUIPMENT CORPORATION 1970,1984.


SUBTTL	INITIALIZATION

INITIA:	TDZA	F,F		;ALLOW FOR CCL ENTRY
	MOVX	F,F.NOHD!F.CCLC	;IF CCL CALL, SUPPRESS HEADER
	RESET			;CLEAR THE WORLD
	SETZB	1,ZER		;CLEAR OUT STORAGE
	MOVE	P,[ZER,,ZER+1]
	BLT	P,EZER
	MOVE	P,[1,,2]
	BLT	P,P
	MOVE	P,[IOWD L$PDL,PDL]  ;INITIALIZE PUSH-DOWN LIST

;NOW FIND SOME INITIAL SYSTEM VALUES

	MOVX	T1,%LDFFA	;GET [1,2]
	GETTAB	T1,		;PPN
	  MOVE	T1,[1,,2]	;(DEFAULT)
	MOVEM	T1,FFAPPN	;SAVE FOR LATER

	MOVX	T1,%LDSYS	;GET SYS:
	GETTAB	T1,		; PPN
	  MOVE	T1,[1,,4]	;(DEFAULT)
	MOVEM	T1,SYSPPN	;SAVE FOR LATER

	MOVX	T1,%CNFLN	;FRCLIN GETTAB INDEX
	GETTAB	T1,		;GET FRCLIN TTY LINE NUMBER
	 SETO	T1,		;OOPS - NO SUCH BEAST
	TXO	T1,.UXTRM	;FAKE IT INTO A UDX
	MOVEM	T1,FLNNUM	;REMEMBER FRCLIN NUMBER

	GETPPN	T1,		;GET THIS JOB'S PPN
	  JFCL			;(IN CASE OF JACCT)
	MOVEM	T1,MYPPN	;SAVE FOR LATER USE
	PJOB	T1,		;GET THIS JOB NUMBER
	MOVEM	T1,JOBN		;REMEMBER IT
	MOVN	T2,T1		;NEGATIVE JOB NUMBER FOR JOBSTS TO
	JOBSTS	T2,		;GET THIS JOB'S STATUS
	  JRST	[TXO   	F,F.NJBS	;INDICATE JOBSTS FAILED
		MOVX   T2,%LDHLP	;CAN'T TELL--GET
		GETTAB T2,		;HELP PPN (UNLOGGED JOB)
		  MOVE T2,[2,,5]	; FROM SYSTEM
		CAME   T2,MYPPN		;SEE IF SAME
		TXO    F,F.LOGI		;NO--MUST BE LOGGED IN
		JRST   .+1]		;AND PROCEED
	TXNE	T2,JB.ULI	;SEE IF LOGGED IN YET
	TXO	F,F.LOGI	;YES. REMEMBER THAT

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

	MOVE	T3,FFAPPN	;GET FULL-FILE-ACCESS (OPR) PPN
	SETOM	T1		;-1 := PROGRAM'S CONTROLLING TTY
	GETLCH	T1		;GET OUR LINE CHARACTERISTICS
	HRRZ	T2,T1		;COPY OF JUST LINE INDEX
	MOVEM	T2,TERNUM	;REMEMBER TERMINAL UDX
	CAMN	T2,FLNNUM	;RUNNING ON FRCLIN?
	TXO	F,F.FLN		;YES, NOTE THAT FACT
	TXNE	F,F.FLN		;RUNNING ON FRCLIN?
	JRST	INITI2		;YES
	TXNN	T1,GL.CTY	;ON THE CTY?
	JRST	INITI4		;NO
	TXNE	F,F.LOGI	;ARE WE LOGGED IN?
	CAMN	T3,MYPPN	;YES, AS OPR?
	TXOA	F,F.CTY		;NOT LOGGED IN OR LOGGED IN AS OPR
	JRST	INITI4		;LOGGED IN AS RANDOM USER, NO CTY-SPECIAL
INITI2:	TXNN	F,F.LOGI	;ALREADY LOGGED IN?
	CHGPPN	T3,		;NO, REALLY WANT PRIVILEGES (FOR HPQ OR FRCUUO)
	 JFCL			;OH WELL, BLUNDER ONWARDS
IFG CTYHPQ,<			;IF WANT TO RUN IN HPQ
	MOVEI	T3,CTYHPQ	;SELECT DESIRED HPQ
	HPQ	T3,		;AND ASK MONITOR FOR PREFERENTIAL TREATMENT
	 JFCL			;HOHUM
> ;END IFG CTYHPQ

INITI4:	OPEN	TTY,[UU.AIO+.IOASC
		     SIXBIT /TTY/
		     XWD TTYOBF,0]
	  JRST	LOGOF$		;CAN NOT FIX THIS
	MOVE	T1,[BF.VBR+TTYBUF+1] ;SETUP BUFFER HEADER
	MOVEM	T1,TTYOBF	; TO POINT TO OUR
	MOVE	T1,[POINT 7,0,35] ; OVERSIZED TTY
	MOVEM	T1,TTYPNT	; BUFFER
	MOVE	T1,[L$TTBF+1,,TTYBUF+1]
	MOVEM	T1,TTYBUF+1	;STORE POINTER IN BUFFER
	MOVE	T1,[PUSHJ P,LUUO] ;SET UP LOCATION 41
	MOVEM	T1,.JB41

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

	MOVSI	T1,'CTY'	; GET NODE,LINE FOR CENTRAL STATION
	PUSHJ	P,GTNTN$
	HRRZM	T1,NL.CTY
	IORI	T1,.UXTRM	;MAKE INTO A UDX
	HRRZM	T1,CTYNUM	;REMEMBER UDX FOR THE CTY

; NOW GET THE SIXBIT TTY NAME FOR THE CTY

	TLZ	T1,-1		; CLEAR OUT THE NODE
	PUSHJ	P,CVTSIX	; CONVERT TO SIXBIT
	LSH	T1,-^D18	; SHIFT NUMBER INTO RIGHT HALF
	HRLI	T1,'TTY'	; PLANT TTY
	MOVEM	T1,CTYTTY	; AND STORE AWAY FOR LATER

	MOVE	T1,['OPR0  ']	; GET NODE,LINE FOR CENTRAL OPR
	PUSHJ	P,GTNTN$
	MOVEM	T1,NL.OPR

	GETLIN	ME,0
	MOVE	T1,ME
	PUSHJ	P,GTNTN$
	MOVEM	T1,NL.ME

	LSH	T1,-^D18	; SHIFT NODE TO RIGHT HALF
	PUSHJ	P,CVTSIX	; CONVERT TO SIXBIT-LEFT JUSTIFIED
	MOVEM	T1,MYNNUM	; SAVE SIXBIT NODE NUMBER
	LSH	T1,-^D18	; SHIFT RESULT TO RIGHT HALF
	HRLI	T1,'OPR'
	PUSHJ	P,GTNTN$	; GET OUR, POSSIBLY LOCAL, OPR
	MOVEM	T1,NL.LOP
	MOVE	T2,[2,,T3]	; NODE. UUO ARGUMENT POINTER
	MOVEI	T3,2		; COUNT
	HLRZ	T4,NL.ME	; MY NODE
	NODE.	T2,0
	 MOVE	T2,['CENTRA']
	MOVEM	T2,MYNNAM	; SAVE SIXBIT NODE NAME
	MOVX	T1,%CNSER	;GET APR
	GETTAB	T1,		; SERIAL
	  MOVEI	T1,0		; NUMBER
	MOVEM	T1,APRSN	;SAVE FOR LATER
	MOVE	T2,JOBN		;GET JOB NUMBER
	IDIVI	T2,^D36		;COMPUTE WORD AND POSITION FOR MY JOB
	MOVSI	T1,(1B0)	;IN "JOB WAITING FOR HIGHSEG LOCK" TABLE
	MOVNS	T3		;TO SPEED UP SYSTEM STARTUP
	LSH	T1,(T3)		;BY ONLY WAKING UP THE JOBS ACTUALLY
	MOVEM	T1,MYBIT	;WAITING, THIS PREVENTS LOTS OF
	ADDI	T2,JOBWAT	;JOBS FIGHTING FOR THE INTERLOCK
	MOVEM	T2,MYWRD

INIT.1:	MOVE	T2,TERNUM	;GET TERMINAL NUMBER
	MOVEI	T1,.TORSP	; GET RECEIVE SPEED
	MOVE	T3,[2,,T1]
	TRMOP.	T3,
	 SETO	T3,		; IF FAILS, USE ONES
	MOVEM	T3,MYSPD

;[CSM5] Raise DTR on all lines (since RSX20F doesn't)  (at INIT.1+6)
	MOVE	T2,TERNUM	;TTY number
	GETLCH	T4		;Line characteristics
	MOVEI	T1,.TODSE	;DataSet Enable
	MOVE	T2,TERNUM	;TTY number
	MOVE	T3,[2,,T1]
	TXNN	T4,GL.DSL	;Dataset line?
	 TRMOP.	T3,		;No, raise DTR on all hardwired lines
	  JFCL

;[CSM5] If INITIA is running on a dataset line while the system is coming up,
;[CSM5] drop DTR to hang up and LOGOUT quickly to let other INITIAs run.

	MOVE	T1,[%CNSUP]	;Get system uptime
	GETTAB	T1,
	  MOVEI	T1,^D<60*60>+1
	CAIG	T1,^D<60*60>	;System startup (less than 1 min uptime)?
	TXNN	T4,GL.DSL	;And a dataset line?
	 JRST	INIT.Z		;No to one of those

	MOVEI	T1,.TODSF	;DataSet oFf
	MOVE	T2,TERNUM
	MOVE	T3,[2,,T1]
	TRMOP.	T3,		;Drop DTR to force hangup at startup
	  JFCL
	JRST	LOGO1$		;KJOB
INIT.Z:				;[CSM5] End of hack
SUBTTL	CODE TO HANDLE SPECIAL STARTUP CONDITIONS

;HERE TO SEE IF THIS IS DUE TO A SYSTEM GOING DOWN OPERATION
;THE IDEA IS THAT INITIA WILL HAVE BEEN INVOKED BY OPSER
;OVER A PTY IN ORDER TO CALL KJOB IN A DETACHED FASHION

REPEAT 0,<	;NO LONGER NEEDED (SINCE OPSER V.5A)
	MOVX	T1,%NSKTM	;GET THE KSYS COUNTER
	GETTAB	T1,		; FROM THE MONITOR
	  JRST	NTKSYS		;IF NOT, MUST BE PRE-KSYS
	JUMPGE	T1,NTKSYS	;SEE IF BEYOND SHUT DOWN
	SETOM	T1		;YES--SEE IF WE ARE A SUBJOB
	CTLJOB	T1,		; BY SEEING IF WE ARE CONTROLLED
	  JRST	NTKSYS		;NOT KSYS IF NO SUCH UUO
	TLNE	ME,-1		;SEE IF DETACHED
	JUMPL	T1,NTKSYS	;JUMP IF ATTACHED TO REAL TTY
	JRST	KSYS		;KILL OFF IF DET. OR CONTROLLED
>; END REPEAT 0

NTKSYS:	MOVE	T1,NL.ME	; GET OUR NODE/LINE
	TLNN	T1,-1		; NODE ZERO?
	JRST	NOTREM		; YES, CAN'T BE REMOTE OPR THEN
	CAMN	T1,NL.LOP	; AM I A REMOTE OPR?
	CAMN	T1,NL.OPR	; ..
	JRST	NOTREM		; NO
	TXO	F,F.REMO	; YES, FLAG AS A REMOTE OPERATOR
;HERE TO SEE IF CALLED FROM FORCED .HELLO COMMAND OR
;IF NORMAL COMMAND WITH ARGUMENTS.

NOTREM:	TLNE	ME,-1		;SEE IF DETACHED
	TXNE	F,F.CCLC	;OR IF CCL CALL
	JRST	INIC.6		;RIGHT--NO RESCAN

;HERE TO SEE IF WE HAVE COMMANDS ON LINE

	MOVEI	T1,TTYIN	;SET FOR TTY INPUT
	MOVEM	T1,GETCH	; IN CHARACTER GETTER
	RESCAN	1		;RETRY LINE
	  SKPINC		;SEE IF SOMETHING THERE
	    JRST INIC.3		;NOTHING--CHECK FOR FORCED CALL
	TXO	F,F.RTTY	;INDICATE COMMITMENT TO REEAT LINE
	PUSHJ	P,GETWRD	;SEE IF INITIA
	CAIN	CH,":"		;SEE IF DEVICE
	JRST	.-2		;YES--TRY AGAIN
	XOR	WD,['INITIA']	;SEE IF INITIA COMMAND
	TDNN	WD,T1		; OR ABBREVIATION
	JRST	INIC.2		;YES--GO SET FLAG
INIC.1:	CAIN	CH,"("		;SEE IF THIS FORM
	JRST	INIC.2		;YES--FLAG COMMAND
	PUSHJ	P,GETWRD	;NO--MOVE ON FOR (...) FORM
	TXNE	F,F.ECMD!F.EOF	;SEE IF END OF LINE YET
	JRST	INIC.6		;YES--GIVE UP
	JRST	INIC.1		;NO--LOOP ONWARDS
INIC.2:	TXO	F,F.ICMD	;SET COMMAND FLAG
	JRST	INIC.6		;AND PROCEED

;HERE IF NO COMMAND IN INPUT BUFFER.

INIC.3:			;COULD CHECK FOR .HELLO HERE
	TXNN	F,F.LOGI	;SEE IF LOGGED IN
	TXO	F,F.ANSW	;NO--INDICATE ANSWER MODE
INIC.6:
;CONTINUED ON NEXT PAGE
SUBTTL	MAIN PROGRAM--HANDLE COMMAND SCANNING AND DISPATCH

;CONTINUED FROM PREVIOUS PAGE

;HERE WHEN DONE WITH COMMAND ANALYSIS AND READY TO ISSUE
;THE SYSTEM SIGNON MESSAGE

INIS.0:	SETZM	GETCH		;CLEAR CHARACTER GETTER

;HERE TO LOOK FOR FILE SYS:TTY.INI

	MOVSI	T5,(UU.PHS)	;ASCII MODE, PHYSICAL ONLY.
	MOVSI	T6,'SYS'	;DEVICE SYS:
	MOVEI	T7,IBF		;POINT TO BUFFER HEADER
	MOVSI	T1,'TTY'	;FILE NAMED
	MOVSI	T2,'INI'	;  TTY.INI[-]
	SETZB	T3,T4		;  ..
	PUSHJ	P,HILOOK	;LOOK IN HISEG OR ON DSK:
	  INTERR(TNF,<SYS:TTY.INI not found>,<JRST TYIN.2>)
	MOVEI	T1,FILINC	;SET FOR FILE INPUT
	MOVEM	T1,GETCH	; FOR CHARACTER GRABBER
	TXZ	F,F.ECMD!F.EOF!F.ALIN ;CLEAR SCANNING FLAGS

;HERE TO LOOP OVER LINES IN FILE TO FIND ONE FOR THIS TTY

TYIN.1:	PUSHJ	P,FILELC	;CONDITIONALLY DO THIS LINE
	JUMPGE	CH,TYIN.1	;UNLESS EOF, LOOP THROUGH FILE
	SETZM	GETCH		;CLEAR CHARACTER GETTER
	SETZM	LOWPTR		;CLEAR PTR TO HISEG
TYIN.2:	RELEAS	TI,		;RELEASE FILE
;HERE TO LOOK FOR ENTRY IN DSK:SWITCH.INI[,]/PHY IF LOGGED IN

	TXNN	F,F.LOGI	;SEE IF LOGGED IN
	JRST	SWIN.3		;NO--SKIP SWITCH.INI
	MOVX	T1,UU.PHS	;YES--SET /PHYSICAL
	MOVSI	T2,'DSK'	;DSK:
	MOVEI	T3,IBF		;BUFFER HEADER
	OPEN	TI,T1		;OPEN
	  JRST	SWIN.3		;IGNORE IF CAN'T OPEN
	MOVE	T1,['SWITCH']	;FILE
	MOVSI	T2,'INI'	; SWITCH.INI
	MOVEI	T3,0		; ..
	MOVE	T4,MYPPN	; [,]
	LOOKUP	TI,T1		;GET FILE
	  JRST	SWIN.3		;IGNORE IF NOT THERE
	MOVEI	T1,FILINC	;SET FOR FILE INPUT
	MOVEM	T1,GETCH	; FOR CHARACTER GRABBER
	TXZ	F,F.ECMD!F.EOF!F.ALIN ;CLEAR SCANNING FLAGS

;HERE TO LOOP OVER LINES IN FILE TO FIND ONE FOR INITIA THIS TTY

SWIN.1:	PUSHJ	P,GETWRD	;GET FIRST WORD OF LINE
	CAME	WD,['INITIA']	;SEE IF FOR INITIA
	JRST	[PUSHJ P,FILELS	;NO--SKIP LINE
		 JRST  SWIN.2]	;AND FINISH LINE
	CAIE	CH,":"		;YES--SEE IF OPTION
	JRST	[PUSHJ P,FILELN	;NO--ASSUME ALL
		 JRST  SWIN.2]	;AND FINISH LINE
	PUSHJ	P,FILELC	;YES--DO IF THIS TTY
SWIN.2:	JUMPGE	CH,SWIN.1	;LOOP TO EOF
	SETZM	GETCH		;CLEAR CHARACTER GRABBER
SWIN.3:	RELEAS	TI,		;FREE CHANNEL
;HERE TO LOOK FOR THIS PROCESSOR S/N IN TABLE

	PUSHJ	P,DOCMD		;GO HANDLE COMMAND LINE
	PUSHJ	P,DOTTYS	;GO DO TTY SETUP
	TXNE	F,F.FLN		;FRCLIN?
	 JRST	INIF.0		;YES, START DUMPING STUFF DOWN FRCLIN
	SKIPE	T1,JUMPPR	;SEE IF PROCESSOR SET
	JRST	(T1)		;YES--GO DO THAT
	MOVE	T1,APRSN	;GET APR S/N
	MOVSI	T2,-APRTBL	;INITIALIZE FOR SEARCH ON APR S/N
	CAME	T1,APRTAB(T2)	;TEST FOR MATCH
	AOBJN	T2,.-1		;NO--LOOP UNTIL DONE
				;IF NOT FOUND, USE CATCHALL SET

;HERE TO LOOK THROUGH SPECIAL PROCESSING TABLE

	HRRZ	T3,APRTBV(T2)	;GET ADDRESS OF JUMP TABLE
	HLRZ	T2,APRTBV(T2)	;GET ADDRESS OF NAME TABLE
	HRLI	T2,T1		;ADD INDEXING
	HRLI	T3,T1		; ..

	MOVSI	T1,-SPTABL	;INITIALIZE FOR SEARCH ON NAME
TTYS.1:	SKIPN	T4,@T2		;FETCH TTY NAME, CHECK FOR END
	JRST	NOTFND		;END OF TABLE
	CAME	ME,T4		;TEST FOR MATCH
	AOBJN	T1,TTYS.1	;NO--LOOP UNTIL DONE
	JUMPGE	T1,NOTFND	;YES--IF NOT FOUND, GIVE UP
	HLRZ	T2,@T3		;SEE IF ANY TTY SET-UP NEEDED
	SKIPE	T2		;NO--SKIP
	PUSHJ	P,(T2)		;YES--SEND IT VIA SPECIAL ROUTINES
	HRRZ	T2,@T3		;GET SPECIAL PROCESSOR
	JUMPN	T2,(T2)		;GO TO IT IF NEEDED


;HERE IF NO SPECIAL PROCESSING REQUESTED IN TABLES
;SEE IF DEVICE OPR:, IF SO, BRING UP OPSER IN CCL MODE.
;THIS WILL CAUSE OPSER TO READ THE AUTO FILE AUTOMATICALLY.

NOTFND:	MOVX	T1,%CNOPR	;GET NAME OF
	GETTAB	T1,		; DEVICE OPR:
	  JRST	GEN		; IGNORE IF UNKNOWN
	TXNN	F,F.REMO	;YES--SEE IF REMOTE OPR
	CAMN	T1,ME		;NO--SEE IF LOCAL OPR
	JRST	OPSER1		;YES--GO DO OPSER CCL
;HERE FOR NON-INTERESTING TERMINAL

GEN:	MOVX	T1,%CNSTS	;GET SYSTEM STATES
	GETTAB	T1,		; FROM MONITOR
	  MOVEI	T1,0		;(ASSUME OK)
	TXNN	T1,ST%BON!ST%NRL!ST%NLG ;IF LOGIN ALLOWED,
	TXNN	F,F.ANSW	;SEE IF FORCED COMMAND
	JRST	GEN.4		;NO--JUST FINISH UP
	TTYSTR	[ASCIZ \Please LOGIN\]
	TXNE	F,F.NJBS	;SEE IF JOBSTS WORKED
	JRST	GEN.2		;NO--SKIP THIS LOGIC
	MOVEI	T1,1		;YES--START AT JOB 1
GEN.1:	MOVE	T2,T1		;GET THIS JOB NUMBER
	TRMNO.	T2,		;GET ITS TERMINAL
	  JRST	[JUMPN  T2,GEN.2 ;FAILED--IF NO ANSWER, GIVE UP
		 MOVN   T2,T1	;GET JOB
		 JOBSTS T2,	;GET ITS STATUS
		   JRST GEN.3	;OK IF NONE
		 HRLZ   T3,T1	;GET JOB NUMBER
		 HRRI   T3,.GTPPN ;GET ITS PPN
		 GETTAB T3,	;(FROM MONITOR)
		   MOVEI T3,0	; ..
		 CAME   T3,FFAPPN ;UNLESS [1,2],
		 JUMPL  T2,GEN.2 ; IF DETACHED, ISSUE MESSAGE
		 JRST   .+1]	;ELSE, CONTINUE LOOP
	AOJA	T1,GEN.1	;LOOP
GEN.2:	TTYSTR	[ASCIZ / or ATTACH/]
GEN.3:	TTYSTR	CRLFM

GEN.4:	JRST	KILJOB		;JUST TYPE SYSTEM START-UP MESSAGE
				; AND RETURN TO MONITOR
;Routine to output terminal type

THISTT:	TTYSTR	[ASCIZ /This terminal is /] ;[CSM3]
	SKIPE	TRMDSC		;[CSM3] Did TRMTYP provide a description?
	 JRST	[TTYSTR	@TRMDSC	  ;[CSM3] ASCIZ description
		 SKIPGE	TRMDSC	  ;[CSM3] If 1B0 was set,
		  TTYSTR [ASCIZ / in VT52 mode/]
		 JRST	THIST3]	  ;[CSM3] Finish up
	TTYCHR	"a"		;[CSM3] No, set up for "a" or "an"
	MOVEI	T3,.TOTRM	;[CSM3] Get type from monitor
	SETO	T4,		;[CSM3] This line
	MOVE	T2,[2,,T3]	;[CSM3] Arg list
	TRMOP.	T2,		;[CSM3] Get what monitor really thinks
	  MOVSI	T2,'???'	;[CSM3] Can never fail in 7.01 or later
	LDB	T1,[POINT 6,T2,5] ;[CSM3] Get first letter
	MOVE	T3,[POINT 6,VOWELS] ;[CSM3] Point to table

THIST1:	ILDB	T4,T3		;[CSM3] Get a vowel
	JUMPE	T4,THIST2	;[CSM3] Stop if no match
	CAME	T4,T1		;[CSM3] Match?
	 JRST	THIST1		;[CSM3] No, try next one
	TTYCHR	"n"		;[CSM3] Yes, type "an" instead of "a"
THIST2:	TTYCHR	" "		;[CSM3]
	PUSHJ	P,TYPSIX	;[CSM3] Output T2 in SIXBIT
THIST3:	TTYSTR	CRLFM		;[CSM3] Finish with CRLF
	POPJ	P,		;[CSM3] End of THISTT

VOWELS:	SIXBIT /AEHILOU /	;[CSM3] "an ADM3", "an H19", "an LA36"
SUBTTL	Process SYSJOB command from TTY.INI

; Put SYS:TTYnnn.INI in the input buffer of terminals other than FRCLIN.
; For instance, SYS:TTY1.INI might say "R SYSDPY" and "Q" to display
; GALAXY 4.1 queues, and SYS:TTY2.INI might say "DO MIC:TTY2.MIC".

	TXTMAX==^D256	;[CSM2] Max number of characters of typeahead

SYSJOB:	TXO	F,F.LOGX	;[CSM2] OK to be already logged in
	MOVE	T4,['OPR @ ']	;[CSM2] User name = "OPR @ TTY1"
	PUSHJ	P,LOGI12	;[CSM2] LOGIN as [1,2] if not logged in
	MOVSI	T5,(UU.PHS)	;[CSM2] Physical only
	MOVSI	T6,'SYS'	;[CSM2] Device
	MOVEI	T7,IBF		;[CSM2] Input only
	OPEN	TI,T5		;[CSM2] Open channel to SYS:
	  POPJ	P,		;[CSM2] What??
	MOVE	T1,ME		;[CSM2] Get TTY name (SIXBIT/TTY1/)
	MOVSI	T2,'INI'	;[CSM2] File extension
	SETZB	T3,T4		;[CSM2] Defaults
	LOOKUP	TI,T1		;[CSM2] (Don't waste HISEG space)
	  JRST	SYSJB9		;[CSM2] No such file, release TI, return
	SETZM	LOWPTR		;[CSM2] Force reading of file
	TXZ	F,F.EOF!F.BIN	;[CSM2] Clear flags for normal read

;Read entire file and force as type-ahead (256 bytes max)

SYSJB1:	MOVE	T1,[POINT 7,TXTBUF] ;[CSM2] Point to buffer
	MOVEI	T2,TXTMAX	;[CSM2] Set the byte count

SYSJB2:	PUSHJ	P,FILIN		;[CSM2] Get a char
	  JUMPLE CH,SYSJB3	;[CSM2] Quit at end of file
	CAIN	CH,.CHLFD	;[CSM2] Linefeed?
	 MOVEI	CH,.CHCRT	;[CSM2] Yes, convert to CR
	IDPB	CH,T1		;[CSM2] Put char in buffer
	SOJG	T2,SYSJB2	;[CSM2] Loop until 256 chars

;Put entire buffer in the terminal's input buffer and execute it

SYSJB3:	MOVEI	T2,0		;[CSM2] End with
	IDPB	T2,T1		;[CSM2]  ASCIZ
	MOVE	T1,[3,,T2]	;[CSM2] Point to TRMOP. args
	MOVX	T2,.TOTYP	;[CSM2] To type into input buffer
	MOVE	T3,TERNUM	;[CSM2] For our linenumber
	MOVEI	T4,TXTBUF	;[CSM2] Point to buffer
	TRMOP.	T1,		;[CSM2] Stuff the line(s) like MIC does
	  TTYSTR [ASCIZ /?Could not process SYSJOB command/]
SYSJB9:	RELEAS	TI,		;[CSM2] Done with channel
	EXIT	1,		;[CSM2] Go process typeahead
	EXIT			;[CSM2] File should not say "CONTINUE"
	SUBTTL	FRCLIN PROCESSING

;HERE TO FIND SYS:SYSJOB.INI AND FORCE IT DOWN FRCLIN'S THROAT

;Set DF.WFL in DEBUGF to have FRCLIN output go to the CTY.

INIF.0:	CTYSTR	[ASCIZ\[FRCLIN INITIA: running]
\]				;LEAVE INCONTESTABLE TRACKS
	RELEAS	TTY,		;LEGGO OF TTY (AKA FRCLIN)
	MOVSI	T1,-1		;-1,,0 = DETACH
	ATTACH	T1,		;DETACH FROM FRCLIN
	 JRST	[CTYSTR	[ASCIZ\?FRCLIN INITIA: Unable to DETACH from FRCLIN
\]
		JRST	LOGO1$]		;SLIP BACK INTO THE CRACKS
	MOVE	T1,[-4,,T2]	;I'M DETACHED, ITS SAFE TO LOG IN AS [1,2]
	MOVE	T2,FFAPPN	;PPN WE ARE GOING TO LOGIN TO. (OPR JOB)
	SETO	T3,		;FULL PRIV WORD (WE WANT LOTSA PRIVS)
	DMOVE	T4,[SIXBIT /TTY STOMPER/] ;USER NAME, MNEMONIC FOR JOB
IFG TTWMAX,<LOGIN T1,>		;LOG US IN, TO KEEP US SAFE FROM PROGRAMS
IFLE TTWMAX,<CHGPPN T2,>	;[CSM] Set PPN to [1,2], don't set JLOG
	JFCL			;Documentation claims this is an error return.
	MOVSI	T5,(UU.PHS)	;PHYSICAL ONLY SYS
	MOVSI	T6,'SYS'
	MOVEI	T7,IBF		;THE INPUT BUFFER
	MOVE	T1,[SIXBIT/SYSJOB/]
	MOVSI	T2,'INI'	;THE FILE TO READ
	SETZB	T3,T4		;REST OF THE LOOKUP BLOCK
	SETZM	LOWPTR		;IN CASE JUNK THERE
	OPEN	TI,T5		;OPEN DEVICE FOR SYSJOB
	 JRST	INIF.1		;SYS ISN'T THERE? LOSE.
	LOOKUP	TI,T1		;FIND SYSJOB.INI
	 JRST	INIF.1		;HMM. TELL CTY WE CAN'T FIND SYSJOB
	TXZ	F,F.EOF		;HAVEN'T SEEN EOF YET
	SETZM	FLNPNT		;NEED TO INIT BYTE STUFFER
	MOVEI	CH,.CHCNC	;A CONTROL-C TO START THINGS OFF WITH A BANG
	TXO	F,F.ECMD	;"EOL"
	JRST	INIF.5		;ENTER SYSJOB.INI LOOP

INIF.1:	CTYSTR	[ASCIZ\%FRCLIN INITIA: Can't read SYS:SYSJOB.INI
\]
	JRST	TTWINI		;KEEP GOING
;LOOP SENDING SYSJOB.INI TO FRCLIN

INIF.3:	PUSHJ	P,FILIN		;GET ANOTHER CHARACTER
	 TXOA	F,F.ECMD	;EOL
	JRST	INIF.5		;NORMAL CHARACTER, STUFF IT
	MOVEI	CH,.CHCRT	;GET EOL INDICATOR

;HERE WITH CHARACTER IN CH FOR FRCLIN

INIF.5:	SKIPN	FLNPNT		;READY FOR CHARACTERS?
	JRST	[MOVEI	T1,FLN$MX-1	;MAXIMUM BYTE COUNT
		MOVEM	T1,FLNCNT	;SET THAT FOR CHAR LOOP
		MOVE	T1,[POINT 7,FLNBUF]  ;INITIAL BYTE POINTER
		MOVEM	T1,FLNPNT	;SET FOR CHAR LOOP
		JRST	.+1]		;CONTINUE WITH CHARACTER
	IDPB	CH,FLNPNT	;STASH THIS CHARACTER
	SOSLE	FLNCNT		;IF BUFFER FULL,
	TXNE	F,F.ECMD	;OR IF EOL
	CAIA			;EOL, OR BUFFER FULL
	JRST	INIF.3		;WANT MORE CHARACTERS

;TYPE THE CHARACTER STRING INTO FRCLIN AS A COMMAND

	MOVEI	T4,0		;A NULL
	IDPB	T4,FLNPNT	;ASCIZIZE THE STRING
	MOVEI	T4,FLNBUF	;THE BUFFER/STRING ADDRESS
	MOVE	T3,FLNNUM	;FRCLIN UDX
	MOVEI	T2,.TOTYP	;"TYPE" FUNCTION
	MOVE	T1,[3,,T2]	;TRMOP. ARG POINTER TO
	TRMOP.	T1,		;TYPE INTO FRCLIN
	 JRST	[CTYSTR	[ASCIZ\?FRCLIN INITIA: Error typing SYSJOB.INI into FRCLIN
\]
		JRST	TTWINI]		;KEEP GOING
	SETZB	T4,FLNPNT	;RESET BYTE POINTER
	TXZN	F,F.ECMD	;WAS THAT EOL, OR LONG LINE?
	JRST	INIF.3		;LONG LINE, STILL LOOKING FOR EOL
	TXZE	F,F.EOF		;EOL, ANY MORE FILE TO DO?
	JRST	TTWINI		;NO, JUST SLIP AWAY
	MOVEI	T2,.TOTTC	;SKIP IF INPUT IN PROGRESS
INIF.8:	MOVE	T1,[2,,T2]	;TRMOP. ARG POINTER TO
	TRMOP.	T1,		;SEE IF INPUT IN PROGRESS ON FRCLIN
	 JRST	INIF.9		;THIS CAN'T FAIL.
	JUMPE	T1,INIF.3	;WHEN INPUT BUFFER EMPTY, GIVE HIM MORE
	SLEEP	T4,		;WAIT TWO TICS
	JRST	INIF.8		;SEE IF READY YET

INIF.9:	CTYSTR	[ASCIZ \%FRCLIN INITIA - Problem checking FRCLIN buffer
\]
	JRST LOGO2$		;QUIT
;HERE WHEN SYSJOB.INI HAS BEEN STUFFED DOWN FRCLIN'S THROAT.
;NOW WATCH FOR OPEN TTY LINES BOGGING DOWN THE SYSTEM, IF SO DESIRED.

TTWINI:
IFLE TTWMAX,<JRST LOGO2$>	;NO STOMPR DESIRED, GO AWAY.
IFG TTWMAX,<
	SKIPN	TTWFLG		;START UP STOMPR?
	JRST	[CTYSTR [ASCIZ \%%TTY STOMPER - Not starting
\]
		JRST LOGO2$]
	RELEASE	TI,		;LET GO OF ANYTHING ON THIS CHANNEL, SINCE
				;WE ARE GOING TO BE AROUND FOREVER.
	CTYSTR	[ASCIZ \%%TTY STOMPER - Starting
\]
	MOVE	T1,[SIXBIT \STOMPR\] ;SET NAME TO SOMETHING RECOGNIZABLE.
	SETNAM	T1,		;(SINCE WE DON'T NEED JACCT ANY MORE)

	MOVE	T1,[%FTDEB]	;GETTAB TABLE WITH FTRSP IN IT
	GETTAB	T1,		;FIND OUT THIS SET OF FEATURE TESTS
	 SKIPA			;FAIL
	TRNN	T1,F%RSP&777777	;DO WE HAVE FTRSP?
	 JRST	[CTYSTR[ASCIZ\?TTY STOMPER - FTRSP is turned off, aborting
\]
		JRST LOGO2$]
	SKIPE	TTWPCT		;GOT POINTERS?
	JRST	TTWIN0		;YES
	AOS	T1,.JBREL	;CALCULATE START ADDRESS OF CHAR COUNT BUFFER
	HRLI	T1,(<1B0 (T7)>)	;SO INDIRECT INDEXES OFF OF T7
	MOVEM	T1,TTWPCT	;SET LINE-INDEXED CHAR COUNT POINTER
	ADD	T1,NL.CTY	;ALLOW FOR ALL POSSIBLE TTY'S
	MOVEM	T1,TTWPTM	;SET LINE-INDEXED COUNT TIMER
	ADD	T1,NL.CTY	;ALLOW FOR ALL POSSIBLE TTY'S
	MOVEM	T1,TTWPRS	;SET LINE-INDEXED CHANNEL,,RECEIVE SPEED
	ADD	T1,NL.CTY	;T1 := FIRST ADDRESS PAST LAST DESIRED ADDRESS
	TLZ	T1,-1		;CLEAR JUNK OUT OF LEFT HALF
	MOVEM	T1,.JBFF	;NOTIFY .JBFF OF HAVING GRABBED MEMORY
	SUBI	T1,1		;T1 := LAST DESIRED ADDRESS
	CORE	T1,		;EXPAND MEMORY AS NEEDED FOR BUFFERS
	 JRST	[CTYSTR	[ASCIZ\?TTY STOMPER - Memory expansion failure
\]
		JRST	LOGO2$]		;GO AWAY

;MAP LINTAB AND LDBS IN, SO WE DON'T HAVE TO EXPEND UUOS.

	MOVE	T1,[%CNLNP]	;POINTER TO LINTAB
	GETTAB	T1,		;ASK MONITOR FOR POINTER
	 JRST	[CTYSTR[ASCIZ\?TTY STOMPER - Gettab failed
\]
		JRST LOGO2$]
	HRRZS	T2,T1		;CLEAR LEFT HALF, COPY ADDRESS
	ADD	T2,NL.CTY	;POINT TO END OF LINTAB
	LSHC	T1,-9		;CONVERT TO PAGE NUMBERS
	HLRZ	T4,T2		;COPY OFFSET WITHIN PAGE TO LINTAB
	SUBI	T1,1(T2)	;CONVERT TO NUMBER OF PAGES
	ADDI	T2,1(T1)	;POINT TO STARTING PAGE
	HRLZ	T2,T2		;PUT IN LEFT HALF AS MONITOR SOURCE ADDRESS
	HRRI	T2,LNTPAG	;PAGE IN OUR ADDRESS SPACE
	MOVE	T3,[.PAGSP,,T1]	;ARG FOR PAGE UUO
	PAGE.	T3,		;MAP IN LINTAB
	 JRST	[CTYSTR[ASCIZ\?TTY STOMPER - PAGE. to map LINTAB failed
\]
		JRST LOGO2$]	;GO AWAY.
	HRLI	T4,LNTPAG	;OUR PAGE FOR LINTAB
	LSH	T4,-9		;RIGHT JUSTIFY
	HRLI	T4,(<1B0(T7)>)	;MAKE IT AN INDIRECT POINTER
	MOVEM	T4,LINTAB	;ESTABLISH POINTER TO LINTAB
;MAP LDBS
	SETZ	T7,		;GET ZEROETH LDB
	HRRZ	T1,@LINTAB	;GET POINTER TO FIRST LDB
	MOVE	T7,NL.CTY	;NUMBER OF LDBS
	SUBI	T7,1		;POINT TO LAST
	HRRZ	T2,@LINTAB	;GET LAST LDB
	LSHC	T1,-9		;CONVERT TO PAGE NUMBERS
	SUBI	T1,1(T2)	;CONVERT TO NUMBER OF PAGES
	ADDI	T2,1(T1)	;CONVERT TO STARTING PAGE
	HRLZ	T2,T2		;PUT IN LEFT HALF AS MONITOR SOURCE PAGE
	HRRI	T2,LDBPAG	;PAGE IN OUR ADDRESS SPACE
	MOVE	T4,T2		;SAVE FOR LATER
	MOVE	T3,[.PAGSP,,T1]	;ARG FOR PAGE UUO
	PAGE.	T3,		;ASK FOR THE PAGES
	 JRST	[CTYSTR[ASCIZ\?TTY STOMPER - PAGE. to map LDBs failed
\]
		JRST LOGO2$]	;GO AWAY
	HLRZ	T1,T4		;MONITOR'S PAGE
	SUBI	T1,(T4)		;MINUS OUR PAGE
	ASH	T1,9		;CONVERT TO ADDRESS (OFFSET)
	MOVEM	T1,LDBOFF	;SAVE AS OFFSET FROM LDB ADDR TO VIRTUAL ADDR

TTWIN0:	HRRZ	T8,NL.CTY	;LAST PHYSICAL TTY IN SYSTEM
	MOVNI	T8,-1(T8)	;(NEGATIVE) LAST "USER" TTY IN SYSTEM
	HRLZ	T8,T8		;T8 := MASTER AOBJN INDEXER FOR TTW LOOP

;FIRST MAKE A PASS OVER THE TTY LINES GETTING BASE VALUES

TTWIN2:	MOVE	T7,T8		;COPY OF AOBJN INDEXER
TTWIN3:	MOVEI	T3,.UXTRM(T7)	;TTY UDX
	MOVEI	T2,.TOICT	;TOTAL INPUT CHARACTER COUNT
	MOVE	T1,[2,,T2]	;TRMOP. ARG POINTER TO
	TRMOP.	T1,		;READ TERMINAL INPUT CHARACTER COUNT
	 SETZ	T1,		;FAILED? ASSUME 0
	MOVEM	T1,@TTWPCT	;SAVE COUNT FOR THIS LINE
	MSTIME	T4,		;TIME OF DAY (MILLISECONDS)
	MOVEM	T4,@TTWPTM	;REMEMBER WHEN THE LAST COUNT WAS TAKEN
	SKIPE	@TTWPRS		;BETTER NOT HAVE ANY LINES HANGING AROUND
	HALT	.+1		;OH WELL
	SETZM	@TTWPRS		;CLEAR NEED-TO-GRAB FLAG
	AOBJN	T7,TTWIN3	;LOOP FOR ALL REAL TTY'S
	MOVX	T1,%SCNRI	;GETTAB INDEX TO
	GETTAB	T1,		;READ TOTAL SYSTEM CHARACTER COUNT
	 JRST	LOGO2$		;DON'T BOTHER
	MOVEM	T1,TTWNRI	;SAVE LAST TOTAL SYSTEM COUNT
	MOVEM	T4,TTWNTM	;AND THE TIME IT WAS SAMPLED

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;NOW CHECK ONCE A MINUTE FOR LINES RUNNING OPEN

TTWSL:
	MOVEI	T1,TTWSLP	;SLEEP INTERVAL
	SLEEP	T1,		;A (YAWN) QUICK NAP
TTWSL2:	MOVX	T1,%SCNRI	;GETTAB ITEM TO
	GETTAB	T1,		;OBTAIN SYSTEM CHARACTERS RECEIVED
	 JFCL			;CAN'T HAPPEN
	SUB	T1,TTWNRI	;T1 := INCREMENTAL CHARACTER COUNT
	ADDM	T1,TTWNRI	;ACCUMULATE TOTAL
	MSTIME	T4,		;GET CURRENT TIME OF DAY
	SUB	T4,TTWNTM	;T4 := MILLISECONDS SINCE LAST SAMPLE
	ADDM	T4,TTWNTM	;KEEP TOTAL UP TO DATE
	JUMPLE	T4,TTWIN2	;IF WRAPPED PAST MIDNIGHT, RESET
	IMULI	T1,^D1000	;ALLOW FOR UNITS CONVERSION
	IDIVI	T1,(T4)		;T1 := SYSTEM CHARACTERS PER SECOND THIS SAMPLE
	HRRZ	T2,NL.CTY	;NUMBER OF PHYSICAL TTY'S POSSIBLE
	ASH	T2,-4		;SCALE IT DOWN
	CAMGE	T1,T2		;SEEING MUCH TTY ACTIVITY?
	JRST	TTWSL		;NO

TTWCHN:	MOVEI	T5,20		;FIRST CHANNEL WE USE
TTWCH0:	CAMLE	T5,TTWMCN	;PAST HIGHEST CHANNEL YET?
	 JRST	TTWSP		;YUP - GO AND CHECK FOR NEW OPEN LINES.
	HRLZ	T2,T5		;GET COPY OF CHANNEL NUMBER
	HRRI	T2,.FOGET	;FUNCTION CODE TO FILOP
	MOVE	T1,[XWD 1,T2]	;1 WORD, AND IT IS IN T2
	FILOP.	T1,		;GET STATUS OF THIS DEVICE
	 AOJA	T5,TTWCH0	;NOTHING THERE, TRY NEXT CHANNEL
	TRNE	T1,IO.ERR	;ANY ERROR ON IT?
	 JRST	TTWDET		;YES, LET GO OF THIS TTY
	MOVE	T2,T5		;GET THE CHANNEL NUMBER
	IONDX.	T2,		;GET THE UDX FOR THE CHANNEL
	 AOJA	T5,TTWCH0	;LOST. IGNORE THIS CHANNEL.
	MOVEI	T1,.TOICT	;NUMBER OF CHARACTERS SEEN (SHOULD BE 0)
	MOVE	T4,[2,,T1]	;ARG FOR TRMOP.
	TRMOP.	T4,		;GET NUMBER OF CHARACTER SINCE LAST TIME
	 SETZ	T4,		; WE RESET IT. IF WE CAN'T, ASSUME 0.
	SKIPN	T4		;DID WE GET ANYTHING?
	 AOJA	T5,TTWCH0	;NOPE - IGNORE THIS TERMINAL
	MOVEI	T1,.TOCIB	;CLEAR INPUT BUFFER
	MOVE	T4,[2,,T1]	;ARG FOR TRMOP
	TRMOP.	T4,		;CLEAR HIS INPUT BUFFER
	 AOJA	T5,TTWCH0	;NO CAN DO, MONITOR IS CONFUSED
	MOVEI	T1,.TORSP	;GET THE RECEIVE SPEED.
	MOVE	T4,[2,,T1]	;ARG FOR TRMOP.
	TRMOP.	T4,		;GET THE RECEIVE SPEED FOR THIS TERMINAL
	 AOJA	T5,TTWCH0	;THE MONITOR IS CONFUSED, IGNORE HIM.
	JUMPE	T4,TTWCH1	;SPEED IS ALREADY ZERO. CAN'T HELP THIS.
	SETZ	T3,		;MAKE HIS SPEED 0
	ADDI	T1,.TOSET	;SET FUNCTION.
	MOVE	T4,[3,,T1]	;ARG FOR TRMOP UUO.
	TRMOP.	T4,		;ZAP HIS SPEED.
	 AOJA	T5,TTWCH0	;THIS CANNOT HAPPEN. (KNOCK ON WOOD)
	CTYSTR	[ASCIZ \%TTY STOMPER: Zero-bauded line at \]
	PUSHJ	P,TTCNOD	;TYPE NODE SPECIFICATION FOR TTY ON CTY
TTWCH1:	MOVE	T7,T2		;LETS CLEAN THAT TTY A BIT.
	TRZ	T7,777000	;LEAVE ONLY THE LINE NUMBER.
	PUSHJ	P,TTWTCL	;CLEAN UP INPUT AND OUTPUT.
	AOJA	T5,TTWCH0	;AND GO ON TO THE NEXT TERMINAL

TTWDET:	MOVE	T3,T5		;TYPE THE CHANNEL NUMBER IN OCTAL
	PUSHJ	P,TTCOCT	; SO WE CAN TRACK WHEN WE GRABBED WHAT.
	CTYSTR	CRLFM		;END LINE
	MOVE	T3,T5		;GET COPY OF CHANNEL
	RESDV.	T3,		;RELEASE THE CHANNEL.
	 JFCL			;NO ERROR RECOVERY HERE.
	AOJA	T5,TTWCH0	;TRY NEXT CHANNEL

;NOW SEE IF ANY LINES ARE BEHAVING OBNOXIOUSLY

TTWSP:	MOVE	T7,T8		;RESET LINE INDEXER
	SETZ	T6,		;OPEN LINES FLAG
TTWSP1:	MOVE	T1,@LINTAB	;GET LINTAB ENTRY FOR THIS TTY
	SUB	T1,LDBOFF	;CONVERT TO USER VIRTUAL ADDRESS
	HRRZ	T1,0(T1)	;GET DDB ADDRESS
	JUMPN	T1,[SETOM @TTWPTM ;FLAG DDB OCCUPIED
		   JRST TTWSP2]	;AND JOIN COMMON CODE
	MOVEI	T3,.UXTRM(T7)	;TTY UDX
	MOVEI	T2,.TOICT	;TOTAL INPUT CHARACTER COUNT
	MOVE	T1,[2,,T2]	;TRMOP. ARG POINTER TO
	TRMOP.	T1,		;SEE HOW MANY CHARACTERS THIS LINE HAS SEEN
	 MOVE	T1,@TTWPCT	;DUH? ASSUME NO CHANGE
	MSTIME	T4,		;TIME OF DAY
	SKIPGE	@TTWPTM		;MAKE SURE WE COUNTED LAST TIME THROUGH.
	 JRST	[MOVEM T1,@TTWPCT ;WE DIDN'T, SET THINGS UP NOW
		MOVEM T4,@TTWPTM
		JRST TTWSP2]	;AND FALL INTO COMMON CODE.
	SUB	T1,@TTWPCT	;T1 := COUNT OF CHARACTERS SINCE LAST TIME
	ADDM	T1,@TTWPCT	;UPDATE TOTAL FOR NEXT ITERATION
	SUB	T4,@TTWPTM	;T4 := MILLISECONDS ELAPSED TIME
	ADDM	T4,@TTWPTM	;UPDATE TOTAL FOR NEXT ITERATION
	JUMPL	T4,TTWIN2	;IF WRAPPED AROUND MIDNIGHT, RESET EVERYTHING
	JUMPLE	T1,TTWSP2	;IF NO INPUT ACTIVITY THEN TTY IS OK
	IMULI	T1,^D1000	;SAME MULTIPLE AS TIME OF DAY
	IDIVI	T1,(T4)		;T1 := CHARACTERS PER SECOND
	CAIL	T1,TTWMAX	;SEEING "LOTS" OF ACTIVITY
	SETOB	T6,@TTWPRS	;FLAG TO STOMP ON THIS TTY
TTWSP2:	AOBJN	T7,TTWSP1	;SEE WHAT ELSE IS RUNNING OPEN
	JUMPE	T6,TTWSL	;IF NO LIKELY CANDIDATES, GO BACK TO SLEEP

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;AT LEAST ONE LIKELY CANDIDATE, SEE IF RUNNING OPEN, AND STOMP ON IT IF SO

	MOVE	T7,T8		;RESET AOBJN INDEXER
TTWSP4:	SKIPN	@TTWPRS		;WANT TO CHECK THIS LINE?
	JRST	TTWSP7		;NO
	HRRZ	T1,T7		;YES, GET LINE NUMBER
	PUSHJ	P,CVTSIX	;MAKE SIXBIT NNN
	IORI	T1,'TTY'	;MAKE INTO TTY NAME (SWAPPED)
TTWSP5:	MOVS	T3,T1		;PHYSICAL NAME OF THE TERMINAL
	SETZ	T4,		;NO BUFFERS
	MOVX	T2,UU.PHS+IO.SUP+.IOASC;NO ECHO, BUT ALLOW ^C
	MOVE	T1,[FO.PRV!FO.ASC+.FORED]  ;"OPEN" FILOP. FUNCTION
	MOVE	WD,[4,,T1]	;FILOP. ARG POINTER TO
	FILOP.	WD,		;OPEN THE TTY AS AN I/O DEVICE
	 JRST	[SETZM	@TTWPRS		;ASSUME IN USE AND VALID
		JRST	TTWSP7]		;CHECK THE REST
	LDB	T1,[POINTR T1,FO.CHN]  ;GET MONITOR-ALLOCATED CHANNEL
	CAMLE	T1,TTWMCN	;GREATER THAN MAX. CHANNEL?
	 MOVEM	T1,TTWMCN	;YUP. SAVE AWAY NEW HIGH.
	PUSH	P,T3		;SAVE DEVICE NAME FOR A WHILE
	GTNTN.	T3,		;CONVERT TO NODE,,LINE
	 JRST	[RESDV.	T1,	;NOT CONNECTED ANYWHERE - LET GO OF HIM.
		 JFCL		;IF WE CAN'T GET RID OF HIM, DON'T WORRY.
		POP	P,(P)	;POP DEVICE NAME OFF FOR A WHILE.
		SETZM	@TTWPRS	;ASSUME IN USE.
		JRST	TTWSP7]	;KEEP ON CHECKING FOR OTHER TTYS
;BUILD A LOGICAL NAME THAT LOOKS LIKE "NODE_TTY", WHERE NODE IS TWO DIGITS,
;AND TTY IS THREE DIGITS. IF NODE .GT. 100 (OCTAL), THE TOP DIGIT WILL BE JUNK.
TTWNAM:	HLRZ	T4,T3		;GET NODE NUMBER
	LSHC	T4,-3		;DROP LOW ORDER BYTE DIGIT FOR A WHILE
	ADDI	T4,'0'		;MAKE IT A SIXBIT NUMBER
	LSH	T4,3		;MAKE ROOM FOR PART OF A SIXBIT DIGIT
	LSHC	T4,3		;MAKE ROOM FOR THE REST, BRINGING IT IN.
	ADDI	T4,'0'		;MAKE IT A SIXBIT DIGIT
	LSH	T4,6		;MAKE ROOM FOR ANOTHER SIXBIT DIGIT
	ADDI	T4,'_'		;ADD IT IN
	MOVS	T5,T4		;SAVE NODE NUMBER FOR A WHILE
				;NOW DO THE TTY NUMBER
	LSHC	T3,-6		;DROP LOW ORDER TWO BYTES FOR A WHILE
	ANDI	T3,7		;KEEP ONLY HUNDREDS (64'S) DIGIT
	ADDI	T3,'0'		;MAKE IT SIXBIT
	LSH	T3,3		;MAKE ROOM FOR PART OF NEXT DIGIT
	LSHC	T3,3		;ROOM FOR REST, BRINGING IT IN
	ADDI	T3,'0'		;MAKE IT SIXBIT
	LSH	T3,3		;ROOM FOR LAST DIGIT
	LSHC	T3,3		;..
	ADDI	T3,'0'		;.....
	HLL	T3,T5		;GET "NODE_"
	POP	P,T2		;AND GET BACK TTY NAME
	DEVLNM	T2,		;SET LOGICAL NAME TO NODE,,LINE
	 JFCL			;IGNORE ANY ERROR.
	HRLOM	T1,@TTWPRS	;SAVE THE CHANNEL NUMBER AWAY

;NOW TRY TO CALM THE TTY DOWN

	MOVEI	T3,.UXTRM(T7)	;TTY UDX
	MOVEI	T2,.TORSP	;TTY RECEIVE SPEED
	MOVE	T1,[2,,T2]	;TRMOP. ARG POINTER TO
	TRMOP.	T1,		;READ TTY RECEIVE SPEED
	 SETO	T1,		;DUH?
	HRRM	T1,@TTWPRS	;SAVE AWAY OLD TERMINAL RECEIVE SPEED
	MOVEI	T4,0		;0 BAUD
	MOVEI	T2,.TORSP+.TOSET;TTY RECEIVE SPEED
	MOVE	T1,[3,,T2]	;TRMOP. ARG POINTER TO
	TRMOP.	T1,		;SET TERMINAL RECEIVE SPEED
	 JFCL			;OH WELL
	PUSHJ	P,TTWTCL	;CLEAR OUT ANY CHARACTERS
	AOS	T6		;FLAG WE DID SOMETHING
	PUSH	P,T3		;Save UDX for this terminal
	CTYSTR	[ASCIZ \%%TTY STOMPER: Quieting open line on TTY\]
	HRRZ	T3,T7		;GET TTY NUMBER
	PUSHJ	P,TTCOCT	;TYPE DIGITS
	CTYSTR	[ASCIZ	\ at \]
	POP	P,T2		;GET UDX BACK INTO T2
	PUSHJ	P,TTCNOD	;AND TYPE OUT THE NETWORK SPECIFICATION
TTWSP7:	AOBJN	T7,TTWSP4	;LOOK FOR ANY MORE TERMINALS
	JUMPL	T6,TTWSL	;IF NOTHING ACCOMPLISHED, BACK TO SLEEP

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

;NOW WAIT AROUND A BIT FOR THE LINES TO SETTLE DOWN

TTWSQ:	MOVEI	T6,4		;REPEATITION COUNTER
TTWSQ0:	MOVE	T7,T8		;RESET INDEXER
TTWSQ1:	SKIPE	@TTWPRS		;POUNDING ON THIS TERMINAL?
	PUSHJ	P,TTWTCL	;YES, EAT ANY STRAGGLING CHARACTERS
	AOBJN	T7,TTWSQ1	;CHECK EM ALL
	MOVEI	T1,1		;A FEW SECONDS
	SLEEP	T1,		;TO WAIT FOR STRAGGLERS
	SOJG	T6,TTWSQ0	;LOOK FOR STRAGGLING STRAGGLERS

;NOW RESET THE TERMINALS TO A WORKABLE STATE

TTWSR:	MOVE	T7,T8		;RESET AOBJN INDEXER
TTWSR1:	SKIPN	T6,@TTWPRS	;HAVE WE GRABBED THIS LINE?
	JRST	TTWSR7		;NO
	HRRE	T4,T6		;GET ORIGINAL TERMINAL RECEIVE SPEED
	JUMPL	T4,TTWSR3	;IF NO RECEIVE SPEED DON'T RESET IT
	MOVEI	T3,.UXTRM(T7)	;TTY UDX
	MOVEI	T2,.TORSP+.TOSET;TTY RECEIVE SPEED
	MOVE	T1,[3,,T2]	;TRMOP. ARG POINTER TO
	TRMOP.	T1,		;RESTORE TERMINAL RECEIVE SPEED
	 JFCL			;TOO BAD
TTWSR3:	SETZM	@TTWPRS		;THIS TTY LINE OF NO FURTHER INTEREST
TTWSR7:	AOBJN	T7,TTWSR1	;LOOP FOR EM ALL
	JRST	TTWSL2		;BACK AND TRY AGAIN


;HELPER TO CLEAR TTY INPUT AND OUTPUT (ASSUMES T7 IS LINE NUMBER)

TTWTCL:	MOVEI	T3,.UXTRM(T7)	;TTY UDX
	MOVEI	T2,.TOCIB	;CLEAR INPUT BUFFER FUNCTION
	MOVE	T1,[2,,T2]	;TRMOP. ARG POINTER TO
	TRMOP.	T1,		;EAT ALL INPUT PENDING
	 JFCL			;DUH?
	MOVEI	T2,.TOCOB	;CLEAR OUTPUT BUFFER FUNCTION
	MOVE	T1,[2,,T2]	;TRMOP. ARG POINTER TO
	TRMOP.	T1,		;EAT ALL OUTPUT TOO
	 JFCL			;SHOULDN'T HAPPEN
	MOVE	T1,[3,,T2]	;WE ARE GOING TO SET A VALUE THIS TIME
	MOVEI	T2,.TOICT+.TOSET;NUMBER OF CHARACTERS SEEN. RESET IT.
	SETZ	T4,		;TO ZERO. (SO WE CAN DO A SKIPN TO CHECK)
	TRMOP.	T1,		;CLEAR NUMBER OF CHARACTERS SEEN.
	 JFCL			;SHOULDN'T HAPPEN, CAN'T HELP IT IF IT DOES.
	POPJ	P,		;ALL CHARACTERS EATEN

;Type out a node specification for a TTY on the CTY
;Assumes UDX is in T2

TTCNOD:	MOVE	T1,T2		;UDX, TO GET THE NODE NUMBER
	GTNTN.	T1,		;WE GET NODE,,LINE NUMBER
	 JRST	TTCGER		;FAILED??
	HLRZM	T1,NODLOC	;GET NODE NUMBER
	MOVEI	T3,2		;LENGTH OF ARGLIST
	MOVEM	T3,NODLEN	;NUMBER OF WORDS FOR NODE UUO
	MOVE	T3,[.NDRNN,,NODBLK];ARGUMENT FOR NODE. UUO
	NODE.	T3,		;TRANSALATE NODE NUMBER TO NODE NAME
	 JRST	TTCNER		;THIS SHOULDN'T HAPPEN.
	PUSHJ	P,TTCSIX	;TYPE IT OUT ON THE CTY
	CTYSTR	[ASCIZ \_TTY\]	;NODE_TTYNNN SEPARATOR
TTWT1O:	HRRZ	T3,T1		;LINE NUMBER
	PUSHJ	P,TTCOCT	;TYPE THE OCTAL LINE NUMBER ON CTY
	CTYSTR	CRLFM		;END LINE WITH CRLF
	POPJ	P,		;FINISHED DUMPING JUNK.

TTCGER:	CTYSTR	[ASCIZ\ GTNTN. failed, code \]
	TRNA			;FALL INTO TYPEOUT CODE
TTCNER:	CTYSTR	[ASCIZ\ NODE. failed, code \]
	JRST	TTWT1O		;TYPE OUT T1 IN OCTAL

;Type out an octal number on the CTY.
;Assumes octal number in T3

TTCOCT:	IDIVI	T3,10		;GET OUT A DIGIT
	PUSH	P,T4		;PUSH THE DIGIT
	SKIPE	T3		;HAVE WE EXTRACTED ALL WE CAN?
	 PUSHJ	P,TTCOCT	;NOPE, TRY FOR ANOTHER DIGIT OR TWO.
	POP	P,T4		;GET TOP DIGIT (FIRST DIGIT)
	CTYCHR	"0"(T4)		;TYPE OUT THE DIGIT CORRESPONDING.
	POPJ	P,		;RETURN, EITHER MORE DIGITS, OR TO USER.

TTCSIX:	JUMPE	T3,CPOPJ	;IF NOTHING LEFT, RETURN
	SETZ	T4,		;CLEAR DESTINATION
	ROTC	T3,6		;SHIFT BY ONE CHARACTER
	CTYCHR	" "(T4)		;OUTPUT THE CHARACTER IN ASCII ON THE CTY
	JRST	TTCSIX		;AND TRY FOR A FEW MORE CHARACTERS.
>;END IFG TTWMAX
SUBTTL	HANDLE COMMAND LINE

;SUBROUTINE TO HANDLE COMMAND LINE

DOCMD:	TXNE	F,F.RTTY	;IF NO COMMAND LEFT, RETURN
	TXNN	F,F.ICMD	;SEE IF COMMAND
CPOPJ:	POPJ	P,		;NO--GIVE UP
	MOVEI	T1,TTYIN	;SET FOR TTY
	MOVEM	T1,GETCH	; IN CHARACTER GRABBER
	MOVEI	CH,0		;CLEAR CHARACTER GRABBER
	TXZ	F,F.ECMD!F.EOF!F.ALIN ;CLEAR SCANNING FLAGS
DOCM.1:	TXNN	F,F.ECMD!F.EOF	;SEE IF END OF COMMAND
	CAIN	CH,")"		;SEE IF END OF COMMAND YET
	JRST	DOCM.3		;YES--ALL DONE
	PUSHJ	P,GETWRD	;GET NEXT COMMAND WORD
	JUMPE	WD,DOCM.2	;LOOP IF NULL
	MOVE	T2,[IOWD CMDLL,CMDT]	;POINT TO POSSIBILITIES
	PUSHJ	P,FNDCMD	;FIND AND STORE COMMAND
	INTERR	(CER,Command Error,<JRST KILJOB>)
DOCM.2:	CAIN	CH,"-"		;SEE IF -XYZ
	PUSHJ	P,NO$		;YES--SET NOXYZ
	TXZN	F,F.CERR	;SEE IF ERROR
	JRST	DOCM.1		;NO--LOOP

;HERE AT END OF COMMAND--CLEAN UP LINE

DOCM.3:	TXZE	F,F.ECMD!F.EOF	;SEE IF END OF LINE
	JRST	DOCM.4		;YES--RETURN
	PUSHJ	P,GETWRD	;NO--GET NEXT WORD
	JRST	DOCM.3		;LOOP UNTIL DONE
DOCM.4:	SETZM	GETCH		;CLEAR CHARACTER GRABBER
	POPJ	P,		;RETURN
;ROUTINES TO HANDLE A LINE IN TTY.INI
;FILELC--CONDITIONAL BASED ON FIRST WORD BEING THIS TTY
;FILELN--ALWAYS
;FILELS--NEVER
;ALL RETURN AT END OF LINE

FILELC:	HLL	T8,NL.ME	;GET OUR NODE NUMBER
	HRR	T8,TERNUM	;AND THE 10'S TTY NUMBER
	TXZ	T8,.UXTRM	;CLEAR OUT 200000 BIT
	TXZ	F,F.PARN	;CLEAR PAREN INDICATOR
FILE.1:	PUSHJ	P,GETSIX	;GET NAME OR NODE NUMBER
	CAIE	CH,"_"		;IS IT A NODE NAME?
	 JRST	FILE.2		;NO, MUST BE SOMETHING ELSE
	MOVE	T8,NL.ME	;GET OUR NODE # AND RELATIVE LINE #
	CAME	WD,MYNNUM	;SAME AS MY OCTAL NODE NUMBER?
	CAMN	WD,MYNNAM	;  OR MY NODE NAME?
	JRST	FILE.1		;YES, SO PROCESS THIS LINE
	JRST	FILELS		;NO, WE ENCOUNTER A BUMMER
FILE.2:	CAMN	WD,['OTHER ']	;SEE IF OTHER
	TXNE	F,F.ALIN	;YES--SEE IF NOTHING YET
	CAMN	WD,['ALL   ']	;SEE IF FOR THIS TTY
	JRST	FILELN		;ALL--GO DO IT
	CAMN	WD,['DETECT']	; SEE IF FOR DETECTION
	 JRST	FILDET
	CAMN	WD,['LINSPD']	; SEE IF ALL SUCH SPEEDS
	 JRST	FILASP
	CAMN	WD,['OTHSPD']	; SEE IF OTHER SUCH SPEEDS
	 JRST	FILOSP
	CAMN	WD,['CONNEC']	;SEE IF WANT TO CONNECT NETWORK LINES
	 JRST	FILCON		;YES (BUT ONLY IF CTY)
	CAMN	WD,['STOMP ']	;SEE IF WANT TO FLAG TTY STOMPR
	 JRST	STOMP
	JUMPE	WD,[CAIN CH,"("		;IF NULL, SEE IF LIST [10(146)]
		TXOE	F,F.PARN	;YES--SET PAREN FLAG
		JRST	FILELS		;NO--SKIP THIS LINE
		JRST	FILE.1]		;YES--LOOP FOR TTY
	PUSHJ	P,XPNTTY	;FORMAT THE TTY NAME
	PUSHJ	P,CVTBIN	;MAKE BINARY IN THE RIGHT HALF
	HLL	WD,NL.ME	;GET OUR NODE NUMBER
	CAIE	CH,"-"		;SEE IF TTYX-Y MODE
	JRST	FILE.3		;NO--GO SEE IF SINGLE
	MOVE	T7,WD		;SAVE FIRST COMPONENT
	PUSHJ	P,GETSIX	;GET NEXT HALF
	JUMPG	WD,[HLRZS WD	;IF DIGITS, MOVE RIGHT
		    HRLI   WD,'TTY'	;MERGE IN LEFT HALF (TTY)
		    JRST  .+1]	;AND PROCEED
	PUSHJ	P,XPNTTY	;EXPAND TT: TO TTY:
	PUSHJ	P,CVTBIN	;BINARY RIGHT HALF
	HLL	WD,T7		;INSERT THE NODE NUMBER
	CAMLE	T7,WD		;SEE IF
	EXCH	T7,WD		; IN ORDER (ELSE, SWAP)
	CAMG	T7,T8		;SEE HOW WE
	CAMGE	WD,T8		;COMPARE
	JRST	FILE.5		;NO--SKIP THIS ONE
	JRST	FILE.4		;YES--DO IT
FILE.3:	CAME	WD,T8		;SINGLE--SEE IF US
	JRST	FILE.5		;NO--PROCEED
FILE.4:	TXO	F,F.ALIN	;YES--INDICATE SOMETHING
	JRST	FILELN		;DO THIS LINE
FILE.5:	CAIN	CH,","		;TEST IF LIST
	TXNN	F,F.PARN	; INSIDE PARENS
	JRST	FILELS		;NO--SKIP LINE
	JRST	FILE.1		;YES--GO TRY ANOTHER SHOT

FILELN:	TXZE	F,F.PARN	;DO COMMAND--SEE IF IN LIST
	JRST	[CAIN  CH,")"	;YES--SEE IF DONE YET
		 JRST  .+1	;YES--PROCEED
		 PUSHJ P,GETSIX	;NO--GET ANOTHER WORD
		 CAIN CH,.CHLFD	;CHECK FOR END-OF-LINE
		 JRST	FILE.6	;FOUND IT, STOP LOSING SEARCH
		 JUMPE CH,FILE.6 ;STOP ON END-OF-FILE TOO
		 JRST	.]	;AND LOOP
	PUSHJ	P,DOFILE	;DO THIS COMMAND
FILELS:	JUMPLE	CH,FILE.7	;IF END OF FILE, SKIP ON
	CAIN	CH,.CHLFD	;IF END OF LINE,
	JRST	FILE.7		;  SKIP ON
	PUSHJ	P,GETWRD	;ELSE, SKIP THIS LINE
	JRST	FILELS		; AND LOOP

;HERE WHEN TIME TO PROCEED ON THROUGH FILE

FILE.6:	PUSHJ	P,ERRFCR	;UNMATCHED LEFT PAREN -- COMPLAIN
FILE.7:	TXZ	F,F.ECMD	;CLEAR END OF COMMAND LINE
	TXZ	F,F.PARN	;CLEAR PAREN INDICATOR
	POPJ	P,		;RETURN

	; ROUTINES TO SCAN LINES BASED ON SPEEDS

SCNSPD:	; SCAN OFF THE SPEED PART
	PUSHJ	P,SKIPTV	;SKIP TO VALUE
	PUSHJ	P,GETSIX	;GET SIXBIT WORD
	MOVE	T2,[IOWD SPEEDL,SPEEDT]
	PUSHJ	P,FNDWRD	;FIND SPEED
	 SKIPA			; TRY SPEED UNKNOWN
	POPJ	P,		;RETURN
	MOVNI	T2,2		; USE -2 FOR ERROR, -1 FOR UNKNOWN
	MOVE	T3,['UNKNOW']	; SEE IF UNKNOWN
	AND	T3,T1		; GET TO RIGHT LENGTH
	CAMN	WD,T3		; SEE IF SAME
	 SETO	T2,		; YES, USE -1
	POPJ	P,
FILASP:	PUSHJ	P,SCNSPD	; GET THE SPEED INDICATED
	CAME	T2,MYSPD	; SAME AS MINE?
	 JRST	FILE.5		; NO, TRY ANOTHER LINE
	JRST	FILE.4		; YES, DO THIS LINE

FILOSP:	PUSHJ	P,SCNSPD	; GET THE SPEED
	CAMN	T2,MYSPD	; SAME AS MINE?
	 JRST	FILE.5		; YES, TRY ANOTHER
	JRST	FILE.4		; NO, SO DO THIS ONE

FILDET:	PUSHJ	P,SCNSPD	; GET SPEED
	CAME	T2,MYSPD	; SAME AS MINE?
	 JRST	FILE.5		; NO
	TXNN	F,F.ANSW	; ARE WE DOING .HELLO?
	 JRST	FILE.5		; NO
	JRST	FILE.4		; YES

;HERE TO FLAG STOMP SEEN IN TTY.INI

STOMP:	TXNN	F,F.FLN		;RUNNING ON FRCLIN?
	JRST	FILELS		;NO, IGNORE THIS COMMAND
	SETOM	TTWFLG		;FLAG THAT WE SHOULD START STOMPER
	JRST	FILELS		;AND IGNORE THE REST OF THE LINE

;HERE TO CONNECT REMOTE NETWORK TERMINALS

FILCON:	TXNN	F,F.CTY		;RUNNING ON THE CTY?
	JRST	FILELS		;NO, IGNORE THE CONNECT COMMAND(S)
	MOVEI	T1,NETSLP	;GET SECONDS TO WAIT
	MOVEM	T1,FILCWT	;SET MAXIMUM WAITABILITY

;LOOP READING NODE_TTY PAIRS FROM TTY.INI

FILCO2:	PUSHJ	P,GETSIX	;GET A NODE ID
	CAIE	CH,"_"		;LOOK LIKE A NODE?
	JRST	FILELS		;NO, EAT THE LINE
FILCO3:	MOVE	T3,WD		;YEAH, POSITION
	PUSHJ	P,NDNAM		;AND TRY TO DECIPHER THE NODE ID
 	JUMPLE	T2,[SOSGE FILCWT	;TIME TO FLICK IT IN?
		JRST	FILCE3		;YES
		MOVEI	T1,1		;NO,
		SLEEP	T1,		;GIVE THE NETWORK A CHANCE TO COME UP
		JRST	FILCO3]		;AND TRY AGAIN
	MOVE	T6,T1		;SAVE REAL NODE NAME
	HRLZ	T8,T2		;SAVE NODE NUMBER
	PUSHJ	P,GETSIX	;READ IN THE TTY ID
	PUSHJ	P,XPNTTY	;FORCE INTO KNOWN FORMAT
	PUSHJ	P,CVTBIN	;AND CONVERT TO LINE NUMBER
	JUMPLE	T8,FILCO7	;IF UNKNOWN NODE, JUST IGNORE IT
	HRR	T8,WD		;MAKE NODE,,LINE ARG
	MOVEI	T7,2		;LENGTH OF NODE. ARG LIST BLOCK
FILCO4:	MOVE	WD,[.NDTCN,,T7]	;ARG POINTER TO
	NODE.	WD,		;TRY TO CONNECT NETWORK TERMINAL
	 JRST	[SOSGE	FILCWT		;WILLING TO WAIT AROUND A BIT?
		JRST	FILCE4		;TIMED OUT, JUST IGNORE IT
		MOVEI	WD,1		;ONE SECOND
		SLEEP	WD,		;WAIT TO GIVE THE NET A CHANCE
		JRST	FILCO4]		;TRY TO CONNECT AGAIN
	MOVX	T1,UU.PHS	;PHYSICAL ONLY
	MOVE	T2,WD		;RESULTANT TERMINAL NAME
	SETZ	T3,		;NO BUFFER RINGS
	OPEN	TTZ,T1		;IS TERMINAL IN USE?
	 JRST	FILCO7		;YES, DON'T FORCE AN INITIA ON IT
	MOVEI	T8,TTZ		;NO, TERMINAL IS FREE,
	IONDX.	T8,		;GET ITS UDX
	 JRST	FILCO7		;THIS JUST CAN'T FAIL
	RELEAS	TTZ,		;NO, RETURN IT TO MONITOR
	MOVE	T7,['INITIA']	;YOURS TRULY
	MOVE	T1,[2,,T7]	;FRCUUO ARG POINTER TO
	FRCUUO	T1,		;RUN INITIA ON NEW-FOUND LINE
	 JRST	FILCE6		;WIN A FEW, LOSE A FEW . . .

;SEE IF MORE TO DO

FILCO7:	CAIE	CH,.CHLFD	;END OF LINE?
	JUMPG	CH,FILCO2	;NO, MORE TO DO
	JRST	FILE.7		;MARK END OF COMMAND
;VARIOUS "CONNECT" COMMAND ERRORS OF NOTE

;NO SUCH NODE

FILCE3:	TTYSTR	[ASCIZ\% No such node "\]
	MOVE	T2,WD		;COPY OF THE NODE NAME
	PUSHJ	P,TYPSIX	;TYPE SIXBIT NODE NAME
	TTYSTR	[ASCIZ\" in CONNECT command\]
	TTYSTR	CRLF		;CAP OFF WITH A CRLF
	JRST	FILCO7		;CONTINUE WITH TTY.INI

;CAN'T CONNECT TO TERMINAL

FILCE4:	TTYSTR	[ASCIZ\% Can't CONNECT to \]
	PUSHJ	P,FILCET	;TYPE NODE_TTY
	TTYSTR	CRLF		;CAP OFF WITH A CRLF
	JRST	FILCO7		;CONTINUE WITH TTY.INI

;CAN'T FORCE AN INITIA

FILCE6:	TTYSTR	[ASCIZ\% Can't force an INITIA on \]
	PUSHJ	P,FILCET	;LIST THE NODE_TTY
	TTYSTR	[ASCIZ\ (\]
	MOVE	T2,WD		;GET -10'S TTY NAME
	PUSHJ	P,TYPSIX	;TYPE THE RESULTANT TTY NAME
	TTYCHR	")"		;END PARENTHESIZED TTY NAME
	TTYSTR	CRLF		;CAP OFF WITH A CRLF
	JRST	FILCO7		;CONTINUE WITH TTY.INI

;TYPE NODE_TTY

FILCET:	MOVE	T2,T6		;COPY OF RESULTANT NODE NAME
	PUSHJ	P,TYPSIX	;LIST SIXBIT NODE NAME
	TTYSTR	[ASCIZ\_TTY\]	;SEPARATE NODE NAME FROM TTY NAME
	HRRZ	T1,T8		;GET NODE LINE NUMBER
	PJRST	TYPOCT		;AND LIST OCTAL LINE NUMBER
;SUBROUTINE TO HANDLE LINE OF COMMAND FILE
;CALLED AFTER FIRST WORD OF LINE IS FOR US

DOFILE:	TXNE	F,F.ECMD!F.EOF	;SEE IF END OF COMMAND
	POPJ	P,		;YES--RETURN
	PUSHJ	P,GETSIX	;GET NEXT WORD
	JUMPE	WD,DOFI.1	;IF NULL, IGNORE IT
	MOVE	T6,WD		;[CSM] Save for ERRFCR
	MOVE	T2,[IOWD CMDL,CMDT]	;FULL COMMAND TABLE
	PUSHJ	P,FNDCMD	;FIND AND STORE COMMAND
	  JRST	ERRFCR		;ERROR IF MISSING
DOFI.1:	CAIN	CH,"-"		;SEE IF - XYZ
	PUSHJ	P,NO$		;YES--SET NOXYZ
	TXZN	F,F.CERR	;SEE IF ERROR
	JRST	DOFILE		;NO--LOOP

ERRFCR:	INTWRN	(FCR,File command error)
	MOVE	T2,T6		;[CSM] Get the bad command
	PUSHJ	P,TYPSIX	;[CSM] Output T2 in SIXBIT
	OUTSTR	CRLFM
	POPJ	P,0
SUBTTL	SUBROUTINE TO IDENTIFY AND SAVE COMMAND

;CALL:	MOVE	T2,[IOWD LENGTH,LIST]
;	PUSHJ	P,FNDCMD
;NON-SKIP RETURN IF ERROR
;SKIP RETURN IF DONE

FNDCMD:	MOVE	T7,T2		;SAVE A COPY OF LIST
FNDC.1:	PUSHJ	P,FNDWRD	;LOOK WD UP IN TABLE
	  JRST	[XOR   WD,['NO    ']
		 TLNE  WD,777700  ;SEE IF NOXYZ
		 POPJ  P,	;NO--ERROR
		 PUSHJ P,NO$	;YES--SET FLAG
		 LSH   T1,^D12	;ADJUST MASK
		 LSH   WD,^D12	;ADJUST REST OF WORD
		 MOVE  T2,T7	;RESTORE LIST OF WORDS
		 JRST  FNDC.1]	;AND TRY AGAIN

;The command processor dispatch table has the following format:
;      -1,,ADDR		;JRST to ADDR on exit (OPSER, SYSDPY, etc)
;	0,,ADDR		;PUSHJ P,ADDR to get a special value (SPEED etc)
;	1,,ADDR		;Set bit 35 of ADDR (set flag ON)
;	2,,ADDR		;Clear bit 35 of ADDR (set flag OFF)
;	3,,ADDR		;Illegal
;	4,,ADDR		;Get decimal arg and store at ADDR
;	5,,ADDR		;[CSM1] Get SIXBIT arg and store at ADDR (TYPE)

	SKIPGE	T1,CMDP(T2)	;GET PROCESSOR
	HRRZM	T1,JUMPPR	;IF -1,,ADDR, GIVES FINAL ROUTINE
	TXNE	F,F.NO		;SEE IF NO XXX
	JUMPL	T1,CPOPJ	;IF ROUTINE, ERROR
	HLRE	T2,T1		;GET POSSIBLE VALUE
	JUMPLE	T2,FNDC.2	;IF JUMP/ROUTINE, GO HANDLE
	TXZE	F,F.NO		;SEE IF NO XXX
	TRC	T2,3		;YES--INTERCHANGE 1-2
	CAIE	T2,1		;SEE IF YES
	CAIN	T2,2		;SEE IF NO
	MOVEM	T2,(T1)		;YES--STORE VALUE
	CAIG	T2,3		;SEE IF BIT VALUE
	JRST	CPOPJ1		;YES--ALL OK
	CAIN	T2,4		;[CSM1] Get a decimal value?
	 JRST	FNDC.D		;[CSM1] Yes
	CAIN	T2,5		;[CSM1] Get a SIXBIT value?
	 JRST	FNDC.S		;[CSM1] Yes
	POPJ	P,		;NO--MUST BE ERROR

;Here to get a decimal value
FNDC.D:	PUSH	P,T1		;SAVE LOCATION
	PUSHJ	P,SKIPTV	;SKIP TO VALUE
	PUSHJ	P,GETDEC	;GET DECIMAL VALUE
	POP	P,T2		;RESTORE LOCATION
	HRROM	T1,(T2)		;STORE VALUE
	JRST	CPOPJ1		;GIVE GOOD RETURN
FNDC.2:	TLNN	T1,-1		;SEE IF 0,,ADDR
	PUSHJ	P,(T1)		; CALL ROUTINE
	TXZE	F,F.CERR	;SEE IF COMMAND ERROR
	POPJ	P,		;YES--GIVE ERROR
	JRST	CPOPJ1		;NO--GIVE SUCCESS

;[CSM1] Here to get a SIXBIT value.  'NO xxx' will return zero value.

FNDC.S:	PUSH	P,T1		;[CSM1] Save address
	TXZE	F,F.NO		;[CSM1] Test and clear bit
	 JRST	[SETZ	WD,	  ;[CSM1] For NO xxx return zero
		 JRST	FNDC.3	] ;[CSM1] Continue
	PUSHJ	P,SKIPTV	;[CSM1] Skip to value
	PUSHJ	P,GETSIX	;[CSM1] Get a SIXBIT word
	JUMPN	WD,FNDC.3	;[CSM1] Must be non-blank
	INTWRN	(NVS,No value specified)
	POP	P,T2		;[CSM1] Do not change current value
	JRST	CPOPJ1		;[CSM1] Give OK return anyway

FNDC.3:	POP	P,T2		;[CSM1] Get back the addr of variable
	MOVEM	WD,(T2)		;[CSM1] Store the result
	JRST	CPOPJ1		;[CSM1] Give OK return
SUBTTL	DEFINE SYSTEMS WHICH NEED SPECIAL SET-UP

	DEFINE	APRS,<
	X 546
;OTHERS MAY BE ADDED--EACH REQUIRES A SP MACRO
>



;DEFINE TABLE OF APR S/N TO PROCESS

	DEFINE	X(A),<
			XLIST
			EXP A
			LIST
>


	RADIX	10
APRTAB:	APRS
APRTBL==.-APRTAB
	RADIX	8



;DEFINE LIST OF TTY NAME TABLE AND PROCESSING TABLE

	DEFINE	X(A),<
			XLIST
			XWD TT'A,JJ'A
			LIST
>

APRTBV:	APRS
	XWD	TTXXX,JJXXX	;CATCHALL
SUBTTL	SYSTEM TABLES

;SYSTEM 546 TABLES
	DEFINE	SP546,<
>

;CATCHALL TABLES FOR UNRECOGNIZED SYSTEMS
	DEFINE	SPXXX,<
>
;PEEL OUT THE TTY NAMES

T.==0

	DEFINE	X(A),<
	XLIST
TT'A:	SP'A
	0
	IFG	.-TT'A-T.,<T.==.-TT'A>
	LIST
>

	DEFINE	Y(A,B,C),<EXP SIXBIT /A/>

	APRS
	X XXX

SPTABL==T.		;SAFETY FACTOR FOR LOOP


;PEEL OUT JUMP TABLES

	DEFINE	X(A),<	XLIST
JJ'A:	SP'A
	LIST>

	DEFINE	Y(A,B,C),<XWD C,B>

	APRS
	X XXX
SUBTTL	STANDARD COMMAND TABLES

;FOR EACH KEYWORD, DEFINE LOCATION OF
;PROCESSOR AND WHETHER OR NOT COMMAND CAN GIVE
;[CSM1] Add a general purpose SIXBIT input routine
;W	KEY,PROCESSOR,X,Y
;		X=C IF COMMAND ALLOWED
;		  blank if allowed from TTY.INI only
;		Y=J IF CALLED WITH JRST
;		  B IF SET A BIT
;		  I IF INVERT (OFF) A BIT
;		  D IF DECIMAL NUMBER
;		  S if SIXBIT value [CSM1]
;		  blank means to call with PUSHJ

	DEFINE	CMDLST(J,B,I,D,S),<;;[CSM1] Add S option

;;FIRST THE COMMANDS ET AL

W	BLOAD,BLOAD,C,S		;;[CSM4] Binary load Personal Computer
W	H,HELP,C,
W	HELP,HELP,C,
W	KSYS,FLKSYS,C,B
W	LOAD,SETUP,C,S		;;[CSM4] Set up terminal from data file
W	NAME,FLNAME,C,I
W	NO,NO$,C,
W	NORUN,GEN,C,J
W	NOTICE,FLNOTC,C,B
W	SETUP,SETUP,C,S		;;[CSM4] Set up terminal from data file
W	STRUCTURES,FLSTR,C,B
W	SYSTEM,SYSIN$,C,
W	STOMP,STOMP$,C,
W	TEXT,FLTEXT,C,B
W	UN,NO$,C,

;Commands from TTY.INI that run programs

W	AUTOMATIC,OPSER1,,J
W	CHKPNT,CHKPNT,,J
W	CRASH,FILEX,,J
W	DAEMON,DAEMON,,J
W	GALOPR,GALOPR,,J
W	LOCATE,LOCAT,,D
W	OMOUNT,OMOUNT,,J
W	OPSER,OPSER,,J
W	SYSDLT,SYSDPY,,J
W	SYSDPA,SYSDPY,,J
W	SYSDPB,SYSDPY,,J
W	SYSDPY,SYSDPY,,J
W	SYSHZL,SYSDPY,,J
W	SYSJOB,SYSJOB,,J	;;[CSM2] Force SYS:TTYnnn.INI as input
W	SYSV52,SYSDPY,,J
W	SYSV61,SYSDPY,,J
W	SYSVFT,SYSDPY,,J
W	SYSVSO,SYSDPY,,J
;;THEN THE TTY PARAMETERS

W	ALTMODE,ALT,,I
W	ASKID,ASKID,,S		;;[CSM3] Ask terminal to identify itself
W	BLANKS,BLANK,,I
W	CRLF,CRLF,,I
W	DEBREAK,DEBR,,B
W	DEFER,ECHDEF,,B
W	DIALOUT,DIAL$,,
W	DISPLAY,DISP,,B
W	ECHO,ECHO,,I
W	ELEMENT,ELEM,,D
W	FILL,FILL,,D
W	FORM,FORM,,B
W	GAG,GAG,,I
W	HDX,HDX,,B
W	LC,LC,,I
W	LENGTH,LENGTH,,D
W	PAGE,PAGCMD,,
W	RCVSPEED,RCV$,,
W	REMOTE,REM,,B
W	RTCOMPATABILITY,RTCOMP,,B
W	SBELL,SBELL,,B
W	SET,FLSET,C,I		;;[CSM4] Abbr for SETTTY vs SETUP
W	SETTTY,FLSET,C,I
W	SLAVE,SLAVE,,B
W	SPEED,SPEED$,,
W	SSIZE,SSIZE,,D
W	SSTOP,SSTOP,,B
W	STOP,STOP,,B
W	TABS,TAB,,B
W	TAPE,TAPE,,B
;;[CSM4] W TERMINET,TRMNET,C,	;;Superseded by "SETUP TRMNET" command
W	TIDY,TIDY,,B
W	TTY,FLTTY,C,B
W	TYPE,TYPE,,S		;;[CSM1] Set terminal type, using "S"
W	UC,LC,,B
W	WIDTH,WIDTH,,D
W	XMTSPEED,XMT$,,
W	XONXOFF,XONXOF,,B
>
	XALL
	DEFINE	W($KEY,$PROC,$COM,$JUMP),<
IFIDN	<$COM><C>,<
	EXP	<SIXBIT /$KEY/>	; $KEY
>>

	;TABLE OF COMMAND NAMES
CMDT:	CMDLST	(-1,1,2,4,5)	;[CSM1]
CMDLL==.-CMDT

	DEFINE	W($KEY,$PROC,$COM,$JUMP),<
IFDIF	<$COM><C>,<
	EXP	<SIXBIT /$KEY/>	; $KEY
>>
	CMDLST	(-1,1,2,4,5)	;[CSM1]
CMDL==.-CMDT


	DEFINE	W($KEY,$PROC,$COM,$JUMP),<
IFIDN	<$COM><C>,<
	XWD	$JUMP,$PROC		; $KEY
>>

	;LIST OF PROCESSORS
CMDP:	CMDLST	(-1,1,2,4,5)	;[CSM1]

	DEFINE	W($KEY,$PROC,$COM,$JUMP),<
IFDIF	<$COM><C>,<
	XWD	$JUMP,$PROC		;$KEY
>>
	CMDLST	(-1,1,2,4,5)	;[CSM1]
	SALL

SUBTTL	ROUTINES FOR VARIOUS COMMANDS

SUBTTL	NO COMMAND HANDLER

NO$:	TXOE	F,F.NO		;SET NO FLAG
	TXO	F,F.CERR	;IF ON, ERROR
	POPJ	P,		;RETURN

SUBTTL	RCV/XMT SPEED COMMAND HANDLER

SPEED$:	MOVEI	T7,3		;BOTH SPEEDS
	JRST	SPEED		;GO HANDLE
RCV$:	MOVEI	T7,2		;REC SPEED
	JRST	SPEED		;GO HANDLE
XMT$:	MOVEI	T7,1		;XMT SPEED
SPEED:	PUSHJ	P,SKIPTV	;SKIP TO VALUE
	PUSHJ	P,GETSIX	;GET SIXBIT WORD
	MOVE	T2,[IOWD SPEEDL,SPEEDT]
	PUSHJ	P,FNDWRD	;FIND SPEED
	  TXO	F,F.CERR	;ERROR IF UNKNOWN
	CAIN	T2,SPDATO-SPEEDT;[CSM1] SPEED:AUTOBAUD ?
	 POPJ	P,		;[CSM1] Yes, for documentation purposes
	TXZE	F,F.NO		;SEE IF NO
	TXO	F,F.CERR	;YES--COMMAND ERROR
	TRNE	T7,2		;SEE IF RCV
	HRROM	T2,RCV		;YES
	TRNE	T7,1		;SEE IF XMT
	HRROM	T2,XMT		;YES
	TRNE	T7,2		; IF RECEIVE SPEED
	 HRRZM	T2,MYSPD	; CHANGE MYSPEED
	POPJ	P,		;RETURN

SPEEDT:	SIXBIT	/0/
	SIXBIT	/50/
	SIXBIT	/75/
	SIXBIT	/110/
	SIXBIT	/134/
	SIXBIT	/150/
	SIXBIT	/200/
	SIXBIT	/300/
	SIXBIT	/600/
	SIXBIT	/1200/
	SIXBIT	/1800/
	SIXBIT	/2400/
	SIXBIT	/4800/
	SIXBIT	/9600/
	SIXBIT	/EXTA/
	SIXBIT	/EXTB/
SPDATO:	SIXBIT	/AUTOBA/	;[CSM3] SPEED:AUTOBAUD (documentation only)
SPEEDL==.-SPEEDT
SUBTTL	PAGE COMMAND HANDLER

PAGCMD:	PUSHJ	P,SKIPTV	;SKIP TO VALUE IF ANY
	CAIN	CH,":"		;SEE IF VALUE
	JRST	PAGCM1		;YES--SETTING NUMBER
	CAIL	CH,"0"		;OR
	CAILE	CH,"9"		; DECIMAL
	JRST	PAGCM2		;NO--MUST JUST BE ON/OFF
PAGCM1:	TXZE	F,F.NO		;NUMBER
	TXO	F,F.CERR	;NO IS ERROR
	PUSHJ	P,GETDEC	;GET DECIMAL PAGE COUNT
	HRROM	T1,PAGE		;SET PAGE NUMBER
PAGCM2:	TXZE	F,F.NO		;ON/OFF--SEE IF OFF
	TDZA	T1,T1		;NO SO OFF
	MOVEI	T1,1		;ELSE ON
	HRROM	T1,PAGEON	;SET FOR PAGE FLAG
	POPJ	P,		;RETURN

SUBTTL	DIAL COMMAND HANDLER

DIAL$:	PUSHJ	P,SKIPTV	;SKIP TO VALUE
	SETOM	DIAL		;FILL WITH MARKERS
	SETOM	DIAL+1		;..
	MOVE	T7,[POINT 4,DIAL]
	MOVEI	T6,^D18		;PROTECTIVE COUNT
DIAL.1:	PUSHJ	P,GETCHA	;GET NEXT DIGIT
	CAIE	CH,"	"	;SEE IF TAB
	CAIN	CH," "		; OR SPACE
	JRST	DIAL.1		;YES--DISCARD
	CAIN	CH,"-"		;SEE IF SEPARATOR
	JRST	DIAL.1		;YES--DISCARD
	CAIE	CH,"("		;SEE IF
	CAIN	CH,")"		; AREA CODE SEPARATOR
	JRST	DIAL.1		;YES--DISCARD
	CAIN	CH,"*"		;SEE IF DELAY MARKER
	JRST	[MOVEI CH,16	;YES--INDICATE THAT
		 JRST  DIAL.2]	;AND STORE
	CAIL	CH,"0"		;SEE IF
	CAILE	CH,"9"		; DIGIT
	POPJ	P,		;NO--MUST BE END
DIAL.2:	IDPB	CH,T7		;STORE DIGIT
	SOJG	T6,DIAL.1	;SEE IF OVERFLOW
	TXO	F,F.CERR	;YES--SET ERROR
	SETZM	DIAL		;AND CLEAR
	SETZM	DIAL+1		; RESULT
	POPJ	P,		;RETURN
SUBTTL	ROUTINE TO SETUP TTY

DOTTYS:	SKIPN	T1,FLSET	;SEE IF
	TXNN	F,F.LOGI	; (IF DIDN'T SAY, AND LOGGED IN, ASSUME NO)
	TRNE	T1,1		; USER SAID NOSETTTY
	JRST	DOTT.2		;RIGHT--SKIP THIS
	MOVE	T1,FFAPPN	;GET [1,2]
	CHGPPN	T1,		;CHANGE TO IT FOR
	  JFCL			; PRIVILEGED TRMOP.S

;[CSM3] The command "ASKID:DM1521" says to set TYPE:DM1521 if terminal does
;[CSM3]  not respond to either $Z or $[c$\ escape sequences.

	SKIPN	ASKID		;[CSM3] Was ASKID:type in TTY.INI?
	 JRST	DOTT.0		;[CSM3] No, don't ask for identification
	MOVX	T1,%NSUPT	;[CSM3] Get the system uptime
	GETTAB	T1,		;[CSM3]
	  MOVEI	T1,0		;[CSM3] Can never fail
	CAIG	T1,^D3600	;[CSM3] Up for more than 1 minute?
	 JRST	SDEFLT		;[CSM3] No, do not ask terminal for ID
	SETSTS	TTY,IO.SUP	;[CSM3] Suppress echo
	TTYSTR	2,CRLFM		;[CSM3] Output CRLF, "2," dumps buffers

	PUSHJ	P,TRMTYP##	;[CSM3] Ask terminal to identify itself

;[CSM3] TRMTYP returns with type in T1, addr of description in T2, and
;[CSM3] nonzero in T3 if terminal has 80/132 columns.

	JUMPE	T1,SDEFLT	;[CSM3] Use default if unknown
	MOVEM	T2,TRMDSC	;[CSM3] Save description
	MOVEM	T3,WIDTH	;[CSM3] Use 0, 80, or 132 as appropriate
	JRST	TYPEOK		;[CSM3] Use type in T1

SDEFLT:	SKIPN	T1,ASKID	;[CSM3] Unknown, get argument to ASKID
	 JRST	DOTT.0		;[CSM3] Totally unknown, leave as 'TTY'

TYPEOK:	CAMN	T1,['CRT   ']	;[CSM3] User hit CR during input?
	SKIPN	T2,ASKID	;[CSM3] And default type set?
	 SKIPA			;[CSM3] No
	  MOVE	T1,T2		;[CSM3] Yes, use ASKID:type
	CAMN	T1,['VT52  ']	;[CSM3] Does it act like a VT52,
	CAME	T2,['VIS200']	;[CSM3]  but TTY.INI says ASKID:VIS200?
	 SKIPA			;[CSM3] No
	  MOVE	T1,T2		;[CSM3] Yes, terminal is a Visual-200
	CAMN	T1,['VK100 ']	;[CSM3] The unpopular name?
	 MOVE	T1,['GIGI  ']	;[CSM3] Yes, set it to better name
	MOVEM	T1,TYPE		;[CSM3] Set terminal type
	SETZM	DISP		;[CSM3] Monitor knows correct setting

DOTT.0:	SETSTS	TTY,.IOASC	;[CSM3] Restore echo

	MOVSI	T7,-DOTTYU	;SET LOOP LENGTH
	TXNE	F,F.LOGI	;JOB LOGGED IN
	MOVSI	T7,-DOTTLG	;YES, DON'T ALLOW SPECIAL THINGS FROM TTY.INI
DOTT.1:	MOVE	T1,[3,,T2]	;POINTER FOR TRMOP
	HLRZ	T2,DOTTYT(T7)	;GET TRMOP FUNCTION
	CAIL	T2,1000		;SEE IF READ TRMOP.
	ADDI	T2,.TOSET	;YES--CHANGE TO SET
	MOVE	T3,TERNUM	;GET TERMINAL NUMBER
	HRRZ	T5,DOTTYT(T7)	;GET POINTER TO VALUE
	HLRZ	T4,DOTTYT(T7)	;GET TRMOP FUNCTION
	CAIN	T4,.TOTRM	;IS IT .TOTRM?
	 SKIPA	T4,(T5)		;YES--GET FULL WORD
	HRRZ	T4,(T5)		;GET VALUE IF ANY
	SKIPE	(T5)		;UNLESS NULL,
	TRMOP.	T1,		; SET VALUE
	  JFCL			;IGNORE ERRORS
	AOBJN	T7,DOTT.1	;LOOP FOR ALL FUNCTIONS
	MOVE	T1,MYPPN	;RECOVER ORIGINAL PPN
	CHGPPN	T1,		;CHANGE BACK TO IT
	  JFCL			;(IGNORE IF CAN'T)

	MOVE	T1,[4,,T2]	;POINTER FOR TRMOP
	MOVEI	T2,.TODSC	;INDICATE CALL
	MOVE	T3,TERNUM	;GET OUR NUMBER
	MOVE	T4,DIAL		;GET FIRST HALF OF NUMBER
	SKIPE	T5,DIAL+1	;IF SET,
	TRMOP.	T1,		; MAKE CALL
	  JFCL			;IGNORE ERRORS

;[CSM3] If the terminal is a VT100, then type the CONFIG name in double-
;[CSM3] width double-height inverse video.  Use ReGIS to do the same on
;[CSM3] a GIGI.  TYPE$ is mandatory for VIS200's, since ESCape-Z causes
;[CSM3] unpredictible scrolling until the screen is erased.

	SKIPE	T1,TYPE		;[CSM3] If terminal type is known,
	 PUSHJ	P,TYPE$		;[CSM3]  type banner file (clear screen)
;Here when all terminal characteristics are set up

DOTT.2:	SKIPE	T1,BLOAD	;[CSM4] Check if BLOAD was requested
	 PJRST	BLOAD$		;[CSM4] Do a binary load of PC
	SKIPE	T1,SETUP	;[CSM4] If SETUP (or LOAD) was requested
	 PUSHJ	P,SETUP$	;[CSM4] Send ASCII file to set tab stops
	PUSHJ	P,SIGNON	;ISSUE SIGNON MESSAGE
	MOVE	T1,FLKSYS	;SEE IF
	TRNE	T1,1		; USER WANTS KSYS
	PUSHJ	P,TYKSYS	;YES--ISSUE IT
	MOVE	T1,FLTEXT
	TRNE	T1,1
	PUSHJ	P,TEXT
;[201] Deleted BATCH command
	MOVE	T1,FLSTR	;SEE IF STRUCT
	TRNE	T1,1		; ..
	PUSHJ	P,STRUCT	;YES--TYPE STRUCTURE NOTES
	MOVE	T1,FLTTY	;GET TTY FLAG
	TRNE	T1,1		;SEE IF SET
	PUSHJ	P,TYPTTY	;YES--TYPE TTY SETTINGS
	MOVE	T1,FLNOTC	;GET NOTICE FLAG
	TRNE	T1,1		;SEE IF SET
	PUSHJ	P,NOTICE	;YES--TYPE NOTICE.TXT
	POPJ	P,		;RETURN

SUBTTL	ROUTINE TO SETUP TTY "TYPE"

;[CSM1] The routine moved to FNDC.S to get a SIXBIT value for more than
;[CSM1] just the TYPE command.
;[CSM1]	TYPE$:	TXZE	F,F.NO		;TEST AND ZERO NO BIT
;[CSM1]		 JRST	[SETZ	WD,	;BIT ON--CLEAR WD
;[CSM1]			 JRST	TYPE$1]	;AND WRAPUP
;[CSM1]		PUSHJ	P,SKIPTV	;SKIP TO VALUE
;[CSM1]		PUSHJ	P,GETSIX	;GET TERMINAL NAME
;[CSM1]		JUMPN	WD,TYPE$1	;WAS ANYTHING SPECIFIED?
;[CSM1]		INTWRN	(NTS,No type specified)
;[CSM1]		POPJ	P,		;OK RETURN
;[CSM1]	TYPE$1:	MOVEM	WD,TYPE		;STORE TERMINAL TYPE
;[CSM1]		POPJ	P,		;OK RETURN
SUBTTL	TTY CONTROL LIST ROUTINE
;FORMAT IS XWD TRMOP.,VALUE

DOTTYT:
	.TOELE,,ELEM	;TTY ELEMENT
	.TOTRM,,TYPE	;TTY TYPE:XXXXXX
	.TORSP,,RCV	;TTY RCV:XX
	.TOTSP,,XMT	;TTY XMT:XX
	.TOLCP,,ECHO	;TTY NO ECHO
	.TODEM,,ECHDEF	;TTY DEFER
	.TOWID,,WIDTH	;TTY WIDTH:N
	.TOLNB,,LENGTH	;TTY LENGTH:N
	.TOSSZ,,SSIZE	;TTY STOP:N
	.TOSST,,SSTOP	;TTY SSTOP
	.TOSTO,,STOP	;TTY STOP
	.TOFLC,,FILL	;TTY FILL:N
	.TOLCT,,LC	;TTY LC
	.TOTAB,,TAB	;TTY TAB
	.TOFRM,,FORM	;TTY FORM
	.TONFC,,CRLF	;TTY NO CRLF
	.TOSND,,GAG	;TTY NO GAG
	.TOSBL,,SBELL	;TTY SBELL
	.TODIS,,DISP	;TTY DISPLAY
	.TOTAP,,TAPE	;TTY TAPE
	.TOPAG,,PAGEON	;TTY PAGE
	.TOPSZ,,PAGE	;TTY PAGE:N
	.TOBLK,,BLANK	;TTY NO BLANKS
	.TOALT,,ALT	;TTY ALT
;[CSM1]	.TODBK,,DEBR	;TTY DEBREAK	;Removed because they look ugly
;[CSM1]	.TOTDY,,TIDY	;TTY TIDY	;CSM has no 2741 terminals.
	.TORTC,,RTCOMP	;TTY RTCOMP
	.TORMT,,REM	;TTY REMOTE (NOT LOCAL for LOGIN privileges)
	.TOXNF,,XONXOFF	;TTY XONXOFF

DOTTLG==.-DOTTYT

;THE FOLLOWING ARE NOT SETTABLE BY THE USER, FOR TYPEOUT ONLY, AND MUST BE LAST

	.TOSLV,,SLAVE	;TTY SLAVE
;[CSM1]	.TOHLF,,HDX	;TTY HDX (HALF-DUPLEX)	;More worthless info

DOTTYU==.-DOTTYT
SUBTTL	ROUTINE TO KJOB IF SYSTEM GOING DOWN

REPEAT 0,<	;NO LONGER NEEDED
KSYS:	MOVE	T1,[3,,['KJO',,0
			IOWD KSYSL,KSYSC]]
	TMPCOR	T1,		;WRITE  KJOB COMMAND TO TMPCOR
	  JRST	.+2		;CAN'T--TRY DISK
	JRST	KJOB1		;DID--CALL KJOB AT CCL ENTRY

;HERE WHEN CAN'T DO IT IN TMPCOR--TRY THE DISK

	OPEN	IO,DSKOPN	;OPEN DISK CHANNEL
	  BOMB$		;GIVE UP IF CAN'T
	MOVE	T1,JOBN		;GET FILE NAME
	MOVEI	T4,3		;BY TIME-HONORED NAME MAKER
KSYSFN:	IDIVI	T1,^D10		;GET NEXT DIGIT
	ADDI	T2,'0'		;CONVERT TO SIXBIT
	LSHC	T2,-6		;CONCATENATE WITH ANSWER
	SOJG	T4,KSYSFN	;LOOP UNTIL DONE WITH 3 DIGITS
	HRRI	T3,'KJO'	;APPEND FILE CODE
	MOVSI	T4,'TMP'	;GET EXTENSION
	SETZB	T5,T6		;CLEAR DIRECTORY
	ENTER	IO,T3		;MAKE  FILE
	  BOMB$		;GIVE UP IF ILLEGAL
	OUTPUT	IO,[IOWD KSYSL,KSYSC
			0]
	RELEASE	IO,		;COMPLETE OPERATION

;HERE WHEN CCL FILE WRITTEN AND TIME TO CALL KJOB

KJOB1:	MOVE	T2,[SIXBIT /KJOB/]  ;GET CUSP NAME
	JRST	CUSP1		;RUN IT AT CCL ENTRY

DSKOPN:	1B0+17		;PHYSICAL DISK OPEN
	'DSK   '
	0

KSYSC:	ASCIZ	\KJOB KSYS.LOG=/W/B
\
KSYSL==.-KSYSC
>; END REPEAT 0
SUBTTL	SPECIAL PROCESSORS

;HERE TO START UP FILEX UNDER [10,1] TO SAVE CRASH

SUBTTL	FILEX PROCESSOR
FILEX:	MOVX	T2,%LDCRP	;GET NUMBER OF CRASH STORAGE AREA
	GETTAB	T2,		;FROM THE MONITOR
	  MOVE	T2,[10,,1]	;(FOR PRE 5.3)
	TLNE	T2,777760	;HACK TO GET AROUND 5.2 BUG
	MOVE	T2,[10,,1]	;WHICH GAVE JUNK IN 16,,16
	MOVE	T4,[SIXBIT /FILEX/]  ;GET CUSP NAME
	JRST	LOGCSP		;GO LOGIN AND RUN CUSP

SUBTTL	OMOUNT PROCESSOR
OMOUNT:	MOVE	T4,[SIXBIT /OMOUNT/]  ;GET CUSP NAME
	JRST	CUSP12		;GO LOGIN AND RUN IT

SUBTTL	DAEMON PROCESSOR
DAEMON:	MOVE	T4,[SIXBIT /DAEMON/]  ;GET THE CUSP NAME
	JRST	CUSP12		;GO LOGIN AND RUN IT

SUBTTL	CHKPNT PROCESSOR
CHKPNT:	MOVE	T4,[SIXBIT /CHKPNT/]  ;GET THE CUSP NAME
	JRST	CUSP12		;GO LOGIN AND RUN IT

SUBTTL	OPSER PROCESSOR
OPSER1:	TXO	F,F.CCL		;FORCE CCL ENTRY POINT
OPSER:	MOVE	T4,[SIXBIT /OPSER/]  ;GET CUSP NAME
	JRST	CUSP12		;LOGIN AND RUN IT

SUBTTL	PRINTR PROCESSOR
PRINTR:	MOVE	T4,[SIXBIT /PRINTR/]  ;GET THE CUSP NAME
	JRST	CUSP12		;AND LOGIN AND START IT

SUBTTL	GALOPR PROCESSOR
GALOPR:	TXO	F,F.CCL		;FORCE CCL RUN
	MOVSI	T4,'OPR'	;NAME OF PROGRAM
	JRST	CUSP12		;LOGIN AND START IT

SUBTTL	SYSDPY PROCESSOR

DEFINE	DPYNAM,<
        X VT05A,SYSDPA
	X VT05B,SYSDPB
;[CSM]	X VT06 ,SYSDPY
	X VT50 ,SYSV50
	X VT52 ,SYSDPY		;[CSM] Forget about VT06
	X VT61 ,SYSV61
	X VK100,SYSANS		;GIGI
	X VT100,SYSANS
	X VT101,SYSANS
	X VT102,SYSANS
	X VT103,SYSANS
	X VT125,SYSANS
	X VT180,SYSANS
	X VT185,SYSANS
;NON-STANDARD TERMINAL TYPES, MONITOR DOESN'T KNOW ABOUT THEM.
	X HAZELT,SYSHZL		;HAZELTINE 2000
	X DELTA ,SYSDLT		;DELTA DATATERM
	X VB10C ,SYSVBC		;VB10C. HAH!
>

DEFINE X(TERM,PROG),<SIXBIT \TERM\>
DPYTRM:	DPYNAM
DPYOFF=.-DPYTRM

DEFINE X(TERM,PROG),<SIXBIT \PROG\>
DPYPRG:	DPYNAM

	PURGE X
DPYTAB:	IOWD DPYOFF,DPYTRM


SYSDPY:	MOVE	T1,[2,,T2]	;ARG FOR TRMOP
	MOVEI	T2,.TOTRM	;TERMINAL TYPE
	SETO	T3,		;MYSELF
	TRMOP.	T1,		;ASK
	 SETZ	T1,		;GIVE A NONEXISTANT TERMINAL TYPE
	MOVE	T2,DPYTAB	;AOBJN POINTER TO TERMINAL TYPE TO SYSDPY NAME
	CAME	T1,(T2)		;IS THIS THE RIGHT NAME?
	AOBJN	T2,.-1		;NO, TRY NEXT NAME
	SKIPL	T2		;DID WE GET A NAME?
	 SKIPA	T4,[SIXBIT \SYSDPY\] ;[CSM] Default is SYSDPY for VT52
	MOVE	T4,DPYOFF(T2)	;GET PROGRAM NAME TO RUN
        TXO	F,F.LOGX	;FLAG OK TO RUN UNDER ANY NUMBER
SUBTTL	LOGIN TO 1,2 AND RUN CUSP NAMED IN T4

CUSP12:	PUSH	P,T4		;SAVE T4
	PUSHJ	P,LOGI12	;LOG INTO 1,2 TO DISPLAY PRIVILEGED INFORMATION
	JRST	CUSPXX		;GO FINISH RUNNING CUSP

;HERE TO DO ARBITRARY LOGIN TO (T2) AND RUN CUSP IN (T4)

LOGCSP:	PUSH	P,T4		;SAVE COPY OF CUSP NAME
	PUSHJ	P,LOGIN$	;GO DO LOGIN

CUSPXX:	POP	P,T2		;RESTORE T2

SUBTTL	START UP CUSP NAMED IN T2

CUSP:	PUSH	P,T2		;SAVE NAME
	TTYSTR	[ASCIZ /.R /]
	PUSHJ	P,TYPSIX	;TYPE NAME
	TTYSTR	CRLFM
	POP	P,T2		;RECOVER NAME
	TXNN	F,F.CCL		;SEE IF FORCED CCL ENTRY POINT
	TLZA	T1,-1		;CLEAR RUN OFFSET
CUSP1:	MOVSI	T1,1		;SET RUN OFFSET FOR CCL ENTRY
	MOVEM	T2,RUNBLK+1	;SAVE CUSP NAME
	MOVSI	T2,(SIXBIT /SYS/)  ;GET CUSPS FROM SYS
	MOVEM	T2,RUNBLK	;SAVE DEVICE
	HRRI	T1,RUNBLK	;SET POINTER FOR RUN UUO
	MOVEM	F,SAVEF		;SAVE FLAGS FOR LATER
	PUSHJ	P,TTYPBF	;DUMP TTY BUFFER
	MOVE	T2,[RUN T1,]	;GET RUN UUO
	TXNE	F,F.PHYS	;SEE IF PHYSICAL NEEDED
	TXO	T2,UU.PHY	;YES--SET IT
	XCT	T2		;GO RUN THE CUSP
	MOVE	P,[IOWD L$PDL,PDL]  ;IN CASE OF FAILURE--LOGOUT
	MOVEI	ME,0		;CLEAR GARBAGE
	MOVE	F,SAVEF		;RESTORE FLAGS
	INTERR	(NFD,,<JRST .+1>)
	MOVE	T2,RUNBLK+1	;GET CUSP NAME
	PUSHJ	P,TYPSIX	;TYPE IT OUT
	TTYSTR	[ASCIZ / not found
/]
SUBTTL	KILL JOB ROUTINE

KILJOB:	TXNE	F,F.RTTY	;SEE IF STILL SOME TO REEAT
	PUSHJ	P,TTYIND	;YES--EAT IT UP
	TXNN	F,F.LOGI	;SEE IF LOGGED IN
	TTYSTR	[ASCIZ	/
./]				;NO--GIVE CONVENTIONAL DOT
LOGOF$:	PUSHJ	P,TTYPBF	;EMPTY TTY BUFFER
LOGO1$:	LOGOUT	1,		;EXIT WITH JUST A DOT
IFLE TTWMAX,<	;Can use LOGOUT uuo if CHGPPN uuo was used instead of LOGIN
LOGO2$:	CLRBFI			;[CSM]
	CLRBFO			;[CSM]
>  ;End of IFLE TTWMAX
LOGOU$:	LOGOUT			;DESTROY THE JOB

IFG TTWMAX,<	;After LOGIN uuo, only SYS:LOGOUT can kill the job
LOGO2$:	CTYSTR	[ASCIZ \%FRCLIN INITIA - Logging out
\]
	MOVEI	1,[SIXBIT \SYS\
		SIXBIT \LOGOUT\
		EXP 0,0,0,0]	;SYS:LOGOUT, NOTHING FANCY.
	RUN	1,
	 JFCL
	LOGOUT			;IF RUN FAILED, GIVE UP.
>  ;End of IFG TTWMAX
SUBTTL	SUBROUTINE TO LIST STRUCTURE NOTES

STRUCT:	MOVEI	T7,0		;PRESET FOR SYSSTR
	MOVE	T6,.JBFF	;SAVE FREE CORE
STRUCL:	MOVEM	T6,.JBFF	;RESTORE FREE CORE
	SYSSTR	T7,		;GET NEXT STR IN SYSTEM
	  POPJ	P,		;GIVE UP IF NOT LEVEL-D
	JUMPE	T7,CPOPJ	;RETURN WHEN DONE
	PUSH	P,T6		;SAVE TWO AC'S
	PUSH	P,T7		; ..
	MOVX	T5,UU.PHS	;ACCESS /PHYSICAL
	MOVE	T6,T7		;GET STR NAME
	MOVEI	T7,IBF		;POINT TO INPUT BUFFER HEADER
	MOVSI	T1,'STR'	;PREPARE
	MOVSI	T2,'TXT'	; FILE
	MOVEI	T3,0		; STR.TXT[1,4]
	MOVE	T4,SYSPPN	; ON EACH STRUCTURE
	PUSHJ	P,HILOOK	;LOOKUP FILE ON DISK OR HISEG
	  JRST	STRUCO		;IGNORE IF MISSING OR SCREWY
	MOVE	T2,(P)		;GET STR NAME
	PUSHJ	P,TYPSIX	;TYPE IT
	TTYSTR	[ASCIZ /:	/]
	PUSHJ	P,TYPFIL	;GO TYPE FILE
STRUCO:	POP	P,T7		;RESTORE STR NAME
	POP	P,T6		;RESTORE .JBFF
	SETZM	LOWPTR		;FORGET ABOUT FILE
	RELEAS	TI,		;RELEASE CHANNEL
	HLLZS	.JBINT		;CLEAR INTERCEPT
	TXZ	F,F.EOF		;CLEAR EOF FLAG
	JRST	STRUCL		;LOOP FOR NEXT STR
SUBTTL	SYSTEM STARTUP COMMAND (FORCE INITIA ON FRCLIN)

SYSIN$:	TXNN	F,F.CTY		;ARE WE A GOOD GUY?
	JRST	SYSINE		;NO
	MOVE	T3,FLNNUM	;GET FRCLIN UDX
	MOVE	T2,['INITIA']	;INITIA COMMAND
	MOVE	T1,[2,,T2]	;FRCUUO ARG POINTER TO
	FRCUUO	T1,		;FORCE AN INITIA COMMAND ON FRCLIN
	 JFCL			;OH WELL
	POPJ	P,		;SUCCESSFUL RETURN

SYSINE:	INTERR	(SLC,<SYSTEM command legal only from [OPR] on CTY:>,<JRST .+1>)
	TXO	F,F.CERR	;FLAG ERROR
	POPJ	P,		;AND DISAPPEAR

;NOTE, THAT IF WE GET HERE, WE DO NOT DO INITIA NORMAL STUFF
STOMP$:
	MOVE	T1,MYPPN	;FIND OUT WHAT I AM
	CAMN	T1,FFAPPN	;ARE WE GOD?
	 JRST	STOMP1		;I'M O.K. - GO AHEAD.
	INTERR	(STC,<STOMP command legal only from [OPR]>,<JRST .+1>)
	TXO	F,F.CERR	;FLAG AN ERROR
	POPJ	P,		;AND RETURN TO COMMAND PARSER

STOMP1:	SETOM	TTWFLG		;FLAG THAT WE WANT TO START STOMPING.
	MOVEI	T1,STOMP3	;ROUTINE TO START STOMPING WITH
	MOVEM	T1,JUMPPR	;WILL CATCH THIS AT END OF PROCESSING.
	POPJ	P,		;AND RETURN


STOMP3:	OUTSTR	[ASCIZ \%%TTY STOMPER detaching from terminal
\]
	HRROI	T1,		;SET UP FOR DETACH
	ATTACH	T1,		;LET GO OF THE TERMINAL
	 JRST	[INTERR (ATF,<ATTACH uuo to detach failed!!!>,<POPJ P,>)]
	JRST	TTWINI		;JUMP INTO TTY STOMPER CODE


SUBTTL	HELP ROUTINE

HELP:	MOVE	T1,['INITIA']
	PUSHJ	P,.HELPR##	;GO GIVE HELP
	JRST	KILJOB		;GO KILL JOB
SUBTTL	SUBROUTINES TO LIST SYSTEM, AND TEXT NOTICES

;ROUTINE TO TYPE OUT INITIA.TXT FROM SYS:

TEXT:	MOVEI	T5,0		;READ IN ASCII MODE
	MOVSI	T6,'SYS'	;SYS:
	MOVEI	T7,IBF		;INPUT BUFFER
	MOVE	T1,['INITIA']	;LOOKUP
	MOVSI	T2,'TXT'	; FILE
	SETZB	T3,T4		; SYS:INITIA.TXT[-]
	PUSHJ	P,HILOOK	;FIND FILE IN HISEG
	  POPJ	P,		;GIVE UP IF NO FILE
	PUSHJ	P,TYPFIL	;TYPE CONTENTS OF FILE
	SETZM	LOWPTR		;FORGET FILE
	RELEAS	TI,		;RELEASE CHANNEL
	TXZ	F,F.EOF		;CLEAR EOF INDICATOR
	POPJ	P,		;RETURN

NOTICE:	MOVEI	T1,'T00'	;[CSM6] Change to read NOTICE.T00 - .T99
	MOVEM	T1,NOTEXT	;[CSM6]

NOTIC1:	MOVEI	T5,0		;READ IN ASCII MODE
	MOVSI	T6,'SYS'	;SYS:
	MOVEI	T7,IBF		;INPUT BUFFER
	MOVE	T1,['NOTICE']	;LOOKUP
	MOVS	T2,NOTEXT	;[CSM6]
	SETZB	T3,T4		; SYS:NOTICE.TXT[-]
	PUSHJ	P,HILOOK	;FIND FILE IN HISEG
	  JRST	NOTIC2		;[CSM6] Give up if no file
	PUSHJ	P,TYPFIL	;TYPE CONTENTS OF FILE
	SETZM	LOWPTR		;FORGET FILE
	RELEAS	TI,		;RELEASE CHANNEL
	TXZ	F,F.EOF		;CLEAR EOF INDICATOR
NOTIC2:	AOS	T1,NOTEXT	;[CSM6] Increment extension
	CAIG	T1,'T09'	;[CSM6] Done T00 thru T09?
	 JRST	NOTIC1		;[CSM6] No, keep looking
	CAIN	T1,'T99'+1	;[CSM6] Done T99 yet?
	 POPJ	P,		;RETURN
	MOVEI	T1,'T99'	;[CSM6] No, check the temporary notice next
	MOVEM	T1,NOTEXT	;[CSM6]
	JRST	NOTIC1		;[CSM6]

SUBTTL	BLOAD and SETUP - send data file to terminal

;[CSM4] Call with file name in T1
;The format of a BLOAD file is up to 32768 bytes of 8 bits each.  The
;bytes are stored 4 per word in the high order 32 bits.  The first 2
;have the count of bytes to follow.

BLOAD$:	MOVEI	T5,.IOBIN	;[CSM4] Read data file in binary mode
	MOVSI	T6,'SYS'	;[CSM4] Device SYS:
	MOVEI	T7,IBF		;[CSM4] Input buffer
	MOVSI	T2,'BIN'	;[CSM4] Extension
	SETZB	T3,T4		;[CSM4] Defaults
	TXO	F,F.BIN		;[CSM4] Binary mode
	OPEN	TI,T5		;[CSM4] Init SYS:
	  SKIPA			;[CSM4] Can never happen
	LOOKUP	TI,T1		;[CSM4] Find the binary file
	  INTWRN (CFB,<Cannot find BLOAD file>,<POPJ P,>)
	MOVSI	T1,(POINT 8,0)	;[CSM4] Set up byte pointer
	MOVEM	T1,IBF+.BFPTR	;[CSM4]  for 8 bit bytes
	INPUT	TI,		;[CSM4] Get first buffer
	IBP	IBF+.BFPTR	;[CSM4] Skip over 1st 2 bytes
	SOS	IBF+.BFCTR	;[CSM4]
	IBP	IBF+.BFPTR	;[CSM4]
	SOS	IBF+.BFCTR	;[CSM4]
	MOVE	T1,@IBF+.BFPTR	;[CSM4] Get the word of data with count
	ASH	T1,-<^D36-^D16>	;[CSM4] Make into a signed integer
	JUMPLE	T1,BLOAD9	;[CSM4] Must be between 1 and 32767

BLOAD1:	PUSHJ	P,FILIN		;[CSM4] Get a byte from SYS:xxx.BIN
	  JRST	BLOAD9		;[CSM4] End of file, byte count is wrong
	IONEOU	CH		;[CSM4] Send it to the terminal
	SOJG	T1,BLOAD1	;[CSM4] Send specified number of bytes

BLOAD9:	SETZM	LOWPTR		;[CSM4] Forget file
	RELEAS	TI,		;[CSM4] Release disk input channel
	TXZ	F,F.EOF!F.BIN	;[CSM4] Clear End of File and Binary
	POPJ	P,		;[CSM4] Return


;Routine to clear screen, draw pictures, etc.
;Call with terminal type (such as VT100) in T1

TYPE$:	MOVSI	T2,'TTY'	;[CSM3] Extension
	SETZB	T3,T4		;[CSM3] Defaults
	MOVEI	T5,.IOASC	;[CSM3] Normal file
	MOVSI	T6,'SYS'	;[CSM3] Device SYS:
	MOVEI	T7,IBF		;[CSM3] Input buffer
	TXO	F,F.PCR		;[CSM3] Preserve CR and DEL
	PUSHJ	P,HILOOK	;[CSM3] Find the file
	  SKIPA			;[CSM3] Not found
	JRST	LOAD1		;[CSM3] Copy it to the terminal

;Output SYS:VT100.TTY for VT101,VT102,VT105,VT180,VT220,VT241,etc

	HLRZ	T1,TYPE		;[CSM3] Get terminal type
	CAIE	T1,'VT1'	;[CSM3] VT100 series?
	CAIN	T1,'VT2'	;[CSM3] VT200 series?
	 SKIPA			;[CSM3] Yes
	  POPJ	P,		;[CSM3] No, cannot find file
	MOVE	T1,['VT100 ']	;[CSM3] File name
	MOVSI	T2,'TTY'	;[CSM3] Extension
	SETZB	T3,T4		;[CSM3] Defaults
	MOVEI	T5,.IOASC	;[CSM3] Normal file
	MOVSI	T6,'SYS'	;[CSM3] Device SYS:
	MOVEI	T7,IBF		;[CSM3] Input buffer
	TXO	F,F.PCR		;[CSM3] Preserve CR and DEL
	PUSHJ	P,HILOOK	;[CSM3] Find the file
	  POPJ	P,		;[CSM3] Can't find that one either
	JRST	LOAD1		;[CSM3] Copy it to the terminal

;Routine to set up a terminal by sending escape sequences
;Call with file name in T1, error if file not found

SETUP$:	MOVSI	T2,'TTY'	;[CSM4] Extension
	SETZB	T3,T4		;[CSM4] Defaults
	MOVEI	T5,.IOASC	;[CSM4] Normal file
	MOVSI	T6,'SYS'	;[CSM4] Device SYS:
	MOVEI	T7,IBF		;[CSM4] Input buffer
	TXO	F,F.PCR		;[CSM3] Preserve CR and DEL
	PUSHJ	P,HILOOK	;[CSM4] Find the file
	  INTWRN (CFS,<Cannot find SETUP file>,<POPJ P,>)

;Routine to output the file in image mode to get around TTY NO FORM and
;TTY WIDTH.

LOAD1:	PUSHJ	P,FILIN		;[CSM3] Get a byte
	  JUMPL	CH,LOAD2	;[CSM3] Stop at EOF, not at LF
	PUSHJ	P,PEVEN8	;[CSM3] Send 1 byte with even parity
	JRST	LOAD1		;[CSM3] Loop

LOAD2:	TXZ	F,F.PCR		;[CSM3] Cancel preserve-CR flag
	POPJ	P,		;[CSM3] Return

;[201] Deleted BATCH command
SUBTTL	SUBROUTINE TO TYPE TTY SETTINGS

TYPTTY:
TYPT.1:	MOVSI	T7,-DOTTYU	;LOOP OF TTY SETUP TABLE
	SETZB	WD,CHRSOU	;CLEAR NUMBER OF THINGS TYPED
TYPT.2:	MOVE	T1,[2,,T2]	;ARG POINTER
	HLRZ	T2,DOTTYT(T7)	;GET FUNCTION
	CAIGE	T2,1000		;SEE IF READ FUNCTION
	JRST	TYPT.6		;NO--IGNORE IT
	HRRZ	T6,DOTTYT(T7)	;GET STORAGE
	MOVSI	T5,-TYPTTU	;LOOP OVER SPECIAL FORMATTERS
TYPT.3:	HRRZ	T4,TYPTTT(T5)	;GET ITS STORAGE
	CAME	T4,T6		;SEE IF SAME
	AOBJN	T5,TYPT.3	;NO--LOOP
	MOVE	T6,TYPTTW(T5)	;YES OR END--GET NAME
	HLR	T5,TYPTTT(T5)	;GET ADDRESS OF FORMATTER
	JUMPL	T5,TYPT.5	;IF FOUND, GO DO IT
	HRRZ	T6,DOTTYT(T7)	;RESTORE MATCHING VALUE
	MOVSI	T5,-CMDL	;ELSE LOOP OVER COMMAND TABLE
TYPT.4:	HRRZ	T4,CMDP(T5)	;GET ITS STORAGE
	CAME	T4,T6		;SEE IF SAME
	AOBJN	T5,TYPT.4	;NO--LOOP
	JUMPG	T5,TYPT.6	;IGNORE IF NOT IN EITHER TABLE
	MOVE	T6,CMDT(T5)	;GET NAME
	HLRE	T5,CMDP(T5)	;GET FORMAT INDICATOR
	JUMPLE	T5,TYPT.6	;IF SPECIAL ROUTINE, IGNORE
	CAIL	T5,3		;SEE IF 4
	MOVEI	T5,3		;YES--MERGE INTO SEQUENCE
	MOVE	T5,[TYPBON	;1=BIT ON
		    TYPBOF	;2=BIT OFF
		    TYPVAL]-1(T5) ;3/4=DECIMAL VALUE
;HERE WHEN STYLE IDENTIFIED
TYPT.5:	MOVE	T3,TERNUM	;GET TTY NUMBER
	TRMOP.	T1,		;READ VALUE
	  JRST	TYPT.6		;IGNORE IF ERROR
	PUSHJ	P,(T5)		;FORMAT OUTPUT
	SKIPN	T1,CHRSOU	;GET CHARACTERS TYPED
	JRST	TYPT.6		;NO OUTPUT THIS TIME
	AOS	WD		;NUMBER OF THINGS TYPED
	TLC	T7,-1		;THIS IS TO BUM THE TABS AFTER THE LAST ITEM
	TLCE	T7,-1		;ONLY WORKS BECAUSE "REMOTE" TYPES SOMETHING
	TRNN	WD,3		;DO ONLY 4 PER LINE
	JRST	[TTYSTR CRLFM	;END THIS LINE
		JRST TYPT.6]	;AND GET THE NEXT THING
	CAIGE	T1,^D8		;NUMBER OF CHARACTERS TYPED
	TTYCHR	"	"	;SMALL, NEED 2 TABS
	TTYCHR	"	"	;ALIGN NEXT OUTPUT FIELD
TYPT.6:	SETZM	CHRSOU		;COUNT FRESH
	AOBJN	T7,TYPT.2	;LOOP OVER TRMOP TABLE
	POPJ	P,		;RETURN
TYPTTT:			;TABLE OF SPECIAL FORMATTERS,,VALUE
;	TYPAGA,,PAGEON
;	TYPAGB,,PAGE
	TYPT.6,,PAGEON	;TTY PAGE (OBSOLETE)
	TYPT.6,,PAGE	;TTY PAGE:N (OBSOLETE)
	TYPSSI,,SSIZE	;TTY STOP N (DEFER UNTIL TTY STOP)
	TYPSST,,SSTOP	;TTY SSTOP  (DEFER UNTIL TTY STOP)
	TYPSTP,,STOP	;TTY STOP (ONE OF: NO STOP; STOP:N; SSTOP:N)
	TYPSPD,,RCV
	TYPSPD,,XMT
	TYPTYP,,TYPE
	TYPECA,,ECHO
	TYPECB,,ECHDEF
TYPTTU==.-TYPTTT

TYPTTW:			;TABLE OF NAMES OF ABOVE
	SIXBIT	/PAGE/
	SIXBIT	/PAGE/
	SIXBIT	/SSIZE/
	SIXBIT	/SSTOP/
	SIXBIT	/STOP/
	SIXBIT	/RCV/
	SIXBIT	/XMT/
	SIXBIT	/TYPE/
	SIXBIT	/ECHO/
	SIXBIT	/ECHO/
;ROUTINE TO TYPE ECHO:DEFER OF NO ECHO OR JUST ECHO

TYPECA:	MOVEM	T1,ECHO		;SAVE FOR ECHO:DEFER LOGIC
	JUMPN	T1,TYPBOF	;TYPE NO ECHO IF SET
	POPJ	P,		;ELSE WAIT FOR THE NEXT OONE
TYPECB:	SKIPE	ECHO		;DID WE ALREADY SAY "NO ECHO"
	POPJ	P,		;YES, THAT'S VERBOSE ENOUGH
	JUMPE	T1,TYPBOF	;NO, JUST SAY "ECHO" IF NOT DEFERED
	TTYSTR	1,[ASCIZ/ECHO:DEFER/] ;OUTPUT IT AND RETURN

;ROUTINE TO TYPE PAGE:N OR NOPAGE

TYPAGA:	MOVEM	T1,PAGEON	;SAVE FOR PAGE:N LOGIC
	JUMPE	T1,TYPBON	;IF NO PAGE, GO TYPE
	POPJ	P,		;ELSE, RETURN
TYPAGB:	SKIPN	PAGEON		;SEE IF NO PAGE
	POPJ	P,		;YES--RETURN
	JUMPE	T1,TYPBOF	;NO--IF PAGE:0 TYPE PAGE
	JRST	TYPVAL		;ELSE, TYPE DECIMAL PAGE

;ROUTINE TO FORMAT SPEED

TYPSPD:	ANDI	T1,17		;PROTECT AGAINST JUNK
	JUMPE	T1,CPOPJ	;IGNORE IF ZERO
	PUSH	P,T1		;SAVE VALUE
	MOVE	T2,T6		;GET NAME
	PUSHJ	P,TYPSIX	;TYPE IN SIXBIT
	TTYSTR	[ASCIZ /SPEED:/]
	POP	P,T1		;RECOVER SPEED INDEX
	MOVE	T2,SPEEDT(T1)	;GET SPEED
	PJRST	TYPSIX		;TYPE IN SIXBIT

;ROUTINE TO TYPE TYPE:XXXXXX

TYPTYP:	MOVE	T2,T1		;PUT TYPE IN T2
	TTYSTR	[ASCIZ /TYPE:/]
	PJRST	TYPSIX		;TYPE IT OUT

;HANDLE STOP PARAMETER(S)

TYPSTP:	JUMPE	T1,TYPBNO	;TYPE "NO STOP" IF TTY NO STOP
	SKIPN	SSIZE		;OR IF TTY STOP:0
	JRST	TYPBNO		;THEN "TTY NO STOP"
	SKIPE	SSTOP		;SUPER-STOP SET?
	TTYSTR	[ASCIZ\S\]	;YES, SO INDICATE
	TTYSTR	[ASCIZ\STOP:\]	;NAME THE FIELD/FUNCTIONALITY
	MOVE	T1,SSIZE	;GET AUTO-STOP SIZE
	PJRST	TYPDEC		;AND LIST DECIMAL LINES

TYPSSI:	MOVEM	T1,SSIZE	;SAVE SSIZE PARAMETER FOR TYPSTP
	POPJ	P,		;BUT OTHERWISE IGNORE

TYPSST:	MOVEM	T1,SSTOP	;SAVE SSTOP PARAMETER FOR TYPSTP
	POPJ	P,		;BUT OTHERWISE IGNORE IT
;ROUTINE TO FORMAT DECIMAL

TYPVAL:	PUSH	P,T1		;SAVE VALUE
	MOVE	T2,T6		;GET NAME
	PUSHJ	P,TYPSIX	;TYPE IN SIXBIT
	TTYCHR	":"		;SEPARATE FROM VALUE
	POP	P,T1		;RESTORE VALUE
	PJRST	TYPDEC		;TYPE IN DECIMAL

;ROUTINE TO FORMAT BIT VALUES

TYPBOF:	TRC	T1,1		;VALUE NORMALLY ON SO SWITCH
TYPBON:	TRNN	T1,1		;SEE IF SET
TYPBNO:	TTYSTR	[ASCIZ /NO/]	;NO--INDICATE
	MOVE	T2,T6		;GET NAME
	PJRST	TYPSIX		;TYPE IN SIXBIT
SUBTTL	TTY SETUP PROCESSORS


;NOTE--ALL MUST PRESERVE T1, T3

SUBTTL	TERMINET ROUTINE
;TRMNET -- SETUP TERMINET 300 TABS
REPEAT 0,<	;[CSM3] Made obsolete by "TYPE:TRMNET" or "SETUP:TRMNET"
TRMNET:	MOVEI	T2,TRMIMG	;GET SPECIAL TEXT TO SEND
	PUSHJ	P,SNDIMG	;SEND TO UNIT
	SETOM	T2		;FLAG FOR THIS UNIT
	GETLCH	T2		;GET LINE CHARACTERISTICS
	TXO	T2,GL.TAB	;SET TABS FLAG
	SETLCH	T2		;SET LINE CHARACTERISTICS
	POPJ	P,		;RETURN

;TERMINET 300--SET TABS AT 4,12,... (4 IS THEN C.RET.POINT)
TRMIMG:	BYTE	(7)15,12,33,62,177,177,15,40,40,40,33,61,40,40,40,40,40,40,40,40,33,61,40,40,40,40,40,40,40,40,33,61,40,40,40,40,40,40,40,40,33,61,40,40,40,40,40,40,40,40,33,61,40,40,40,40,40,40,40,40,33,61,40,40,40,40,40,40,40,40,33,61,40,40,40,40,40,40,40,40,33,61,40,40,40,40,40,40,40,40,33,61,15,0
>  ;End of REPEAT 0	;[CSM3]
SUBTTL	INPUT ROUTINES

;SUBROUTINE TO FIND A WORD IN A TABLE
;CALL:	MOVE	WD,WORD IN SIXBIT
;	MOVE	T1,MASK OF WHAT TYPED
;	MOVE	T2,[IOWD LEN,TABLE]
;	PUSHJ	P,FNDWRD
;	ERROR RETURN
;	FOUND WITH T2=INDEX OF RESULT
;USES T3, T4, T5

SUBTTL	TABLE SEARCH ROUTINE
FNDWRD:	MOVE	T3,T2		;SAVE POINTER
	MOVEI	T5,0		;CLEAR ABBREVIATION POINTER
FNDW.1:	MOVE	T4,1(T3)	;GET NEXT TRIAL
	XOR	T4,WD		;COMPARE
	JUMPE	T4,FNDW.3	;GOOD MATCH
	TDNE	T4,T1		;SEE IF OK AS ABBREVIATION
	JRST	FNDW.2		;NOT ABBREVIATION
	SKIPE	T5		;SEE IF ABBREVIATION KNOWN
	SETOM	T5		;YES--SET FLAG
	SKIPN	T5		;SEE IF ANY ABBREVIATION
	HRRZ	T5,T3		;SAVE POINTER
FNDW.2:	AOBJN	T3,FNDW.1	;LOOP OVER LIST
	SKIPG	T3,T5		;RECOVER ABBREVIATION
	POPJ	P,		;ERROR RETURN IF NONE
FNDW.3:	SUBI	T3,(T2)		;GET INDEX
	MOVEI	T2,(T3)		;COPY RESULT
CPOPJ1:	AOS	(P)		;SUCCESS
	POPJ	P,		;RETURN
;SUBROUTINE TO SKIP TO VALUE IF ANY
;SKIPS ONE : OR SEVERAL SPACES/TABS

SUBTTL	SKIP TO VALUE ROUTINE
SKIPTV:	CAIN	CH,":"		;SEE IF :
	POPJ	P,		;YES--OK TO PROCEED
SKTV.1:	CAIE	CH," "		;SEE IF SPACE
	CAIN	CH,"	"	; OR TAB
	JRST	[PUSHJ P,GETCHA	;YES--SKIP ON
		 JRST  SKTV.1]	;AND LOOP
	TXNN	F,F.ECMD	;IF END OF LINE NOT REACHED,
	HRROM	CH,REEAT	;REEAT LAST CHAR
	POPJ	P,		;RETURN

;ROUTINE TO READ A DECIMAL NUMBER
;RETURNS VALUE IN T1; USES T2

SUBTTL	DECIMAL READ ROUTINE
SUBTTL	OCTAL READ ROUTINE
GETOCT:	SKIPA	T2,[10]	; LOAD OCTAL BASE
GETDEC:	MOVEI	T2,^D10	; LOAD DECIMAL BASE
	MOVEI	T1,0		; CLEAR RESULT
	PUSHJ	P,GETCHA	;GET LEAD CHARACTER
	CAIE	CH,"#"		;SEE IF OCTAL FORCER
	JRST	GTDC.1		;NO--START ACCUMULATION
	MOVEI	T2,10		;YES--CHANGE TO OCTAL RADIX
	PUSHJ	P,GETCHA	;AND REPLACE FIRST CHARACTER
GTDC.1:	CAIL	CH,"0"		;SEE IF
	CAIL	CH,"0"(T2)	; NUMERIC
	JRST	GTDC.2		;NO--MUST BE DONE
	IMULI	T1,(T2)		;YES--ROUND UP
	ADDI	T1,-"0"(CH)	;INCLUDE THIS DIGIT
	PUSHJ	P,GETCHA	;GET NEXT CHARACTER
	JRST	GTDC.1		;LOOP
GTDC.2:	CAIN	CH,"."		;SEE IF DECIMAL SUFFIX
	PUSHJ	P,GETCHA	;YES--SKIP IT
	POPJ	P,		;RETURN VALUE
;SUBROUTINE TO GET A SIXBIT NAME
;RETURNS SIXBIT NAME IN WD, TERMINATOR IN CH, MASK IN T1

SUBTTL	SIXBIT NAME ROUTINE (GETSIX)
GETSIX:	SETZB	T1,WD		;CLEAR RESULTS
GETSI1:	PUSHJ	P,GETCHA	;GET NEXT CHARACTER
	CAIL	CH,"0"		;SEE IF
	CAILE	CH,"9"		; NUMERIC
	SKIPA			;NO
	JRST	GETSI2		;YES
	CAIL	CH,"A"		;SEE IF ALPHA
	CAILE	CH,"Z"+40	; ..
	JRST	GETSI3		;NO--EXIT
	CAILE	CH,"Z"
	CAIL	CH,"A"+40
	SKIPA
	JRST	GETSI3		;NO--EXIT
	TRZ	CH,40		;FORCE UPPER CASE
GETSI2:	TLOE	T1,(77B5)	;MASK NEXT CHAR ON
	JRST	GETSI1		;LOOP
	ROT	T1,6		;POSITION MASK
	LSH	WD,6		;POSITION SIXBIT NAME
	IORI	WD,-40(CH)	;INCLUDE NEXT CHAR
	JRST	GETSI1		;LOOP FOR MORE
GETSI3:	CAIE	CH,"	"	;SEE IF TAB OR
	CAIN	CH," "		;BLANK SEPARATOR
	JUMPE	T1,GETSIX	;IF BLANK OR TAB FIELD, SKIP LEADING BLANKS
	JUMPE	T1,CPOPJ	;RETURN IF NULL
	TLNE	T1,(77B5)	;SEE IF LEFT ADJUSTED
	POPJ	P,		;YES--RETURN
	LSH	T1,6
	LSH	WD,6
	JRST	GETSI3
;SUBROUTINE TO CHANGE TTXXX: INTO TTYXXX:
;THIS ALLOWS 2 LETTER GENERIC DEVICE NAMES
;ROUTINE ALSO INSERTS LEADING 0 IN TTY NUMBERS TO SIMPLIFY
;COMPARES

SUBTTL	TTY EXPANSION ROUTINE (XPNTTY)
XPNTTY:	CAMN	WD,[SIXBIT /CTY/]
	MOVE	WD,CTYTTY	; GET TTY NNN FOR CTY
	MOVE	T1,WD		; COPY WORD
	TLC	T1,'TT0'	;TEST TT THEN DIGIT
	TRNN	T1,77		;MUST BE LE 5 CHARS
	TLNE	T1,777770	;AND THAT FORM
	JRST	XPNT.1		;NOT--LEAVE ALONE
	MOVE	T1,WD		;MAKE ANOTHER COPY
	LSHC	T1,-^D24	;IS--SEPARATE GENERIC PART
	LSH	T1,6		;MOVE OVER
	TRO	T1,'Y'		;INCLUDE THE Y
	LSHC	T1,^D18		;REJOIN
	MOVE	WD,T1		;RESTORE TO NORMAL AC
XPNT.1:	TRNN	WD,77		;SEE IF LESS THAN 6 CHARS
	TRNN	WD,-1		;SEE IF GREATER THAN 3
	POPJ	P,		;NO--RETURN
	HRRZ	T1,WD		;YES--GET RIGHT HALF
	TRC	T1,'0  '	;REMOVE DIGIT OFFSET
	TRNE	T1,7700		;SEE IF SECOND DIGIT
	TRC	T1,'0 '		;YES--REMOVE ITS OFFSET
	TRNE	T1,707070	;VERIFY ALL DIGITS
	POPJ	P,		;NO--LEAVE ALONE
	HRRZ	T1,WD		;OK--GET CLEAN COPY
	SKIPA			;ALL DIGITS
	LSH	T1,-6		; ADJUST
	TRNN	T1,77		; DIGITS
	JRST	.-2		; ..
	TRNN	T1,770000	;SEE IF FILL NEEDED
	TRO	T1,'0  '	;YES--FILL WITH 0
	TRNN	T1,7700		;SEE IF MORE FILL
	TRO	T1,'0 '		;YES--AGAIN
	HRR	WD,T1		;RETURN TO ANSWER
	POPJ	P,		;RETURN
SUBTTL	CVTSIX
;SUBROUTINE CVTSIX - CONVERT OCTAL NUMBERS IN THE RANGE
; 0-777 TO LEFT-JUSTIFIED SIXBIT. ON ENTRY T1=BINARY, ON
; RETURN T1=SIXBIT VALUE
; NOTE: THIS SUBROUTINE STRIPS TRAILING ZEROS.
CVTSIX:	TDZ	T1,[-1,,777000] ; CLEAR OUT GARBAGE
	MOVE	T3,[POINT 6,T1]	; PREPARE BYTE POINTER
CVTLOP:	IDIVI	T1,10	; DIVIDE OCTAL
	HRLM	T2,(P)		; STACK REMAINDER
	SKIPE	T1		; QUIT WHEN DONE
	PUSHJ	P,CVTLOP	; ELSE LOOP
	HLRZ	T2,(P)		; UNSTACK
	TRO	T2,20		; SIXBITIZE
	IDPB	T2,T3		; STORE IN LEFT HALF OF T1
	POPJ	P,0

;SUBROUTINE CVTBIN - CONVERT RIGHT HALF OCTAL TO SIXBIT
;CALL	MOVE	WD,ARG
;	PUSHJ	P,CVTBIN
;RETURN	CPOPJ

CVTBIN:	PUSH	P,WD+1
	TDZ	WD,[XWD -1,707070]
	LSHC	WD,-3
	LSH	WD,-3
	LSHC	WD,-3
	LSH	WD,-3
	LSHC	WD,6
	POP	P,WD+1
	POPJ	P,
;SUBROUTINE TO GET A SIXBIT WORD
;RETURNS WORD IN WD, TERMINATOR IN CH, MASK IN T1

SUBTTL	SIXBIT WORD ROUTINE (GETWRD)
GETWRD:	SETZB	T1,WD		;CLEAR RESULTS
GETWR1:	PUSHJ	P,GETCHA	;GET NEXT CHARACTER
	CAIL	CH,"A"		;SEE IF ALPHA
	CAILE	CH,"Z"+40	; ..
	JRST	GETWR2		;NO--EXIT
	CAILE	CH,"Z"
	CAIL	CH,"A"+40
	SKIPA
	JRST	GETWR2		;NO--EXIT
	TRZ	CH,40		;FORCE UPPER CASE
	TLOE	T1,(77B5)	;MASK NEXT CHAR ON
	JRST	GETWR1		;LOOP
	ROT	T1,6		;POSITION MASK
	LSH	WD,6		;POSITION WORD
	IORI	WD,-40(CH)	;INCLUDE NEXT CHAR
	JRST	GETWR1		;LOOP FOR MORE
GETWR2:	CAIE	CH,"	"	;TAB?
	CAIN	CH," "		;BLANK SEPARATOR?
	JUMPE	T1,GETWRD	;YES--IF SPACE OR TAB, SKIP THEM
	JUMPE	T1,CPOPJ	;RETURN IF NULL
	TLNE	T1,(77B5)	;SEE IF LEFT ADJUSTED
	POPJ	P,		;YES--RETURN
	LSH	T1,6
	LSH	WD,6
	JRST	GETWR2
;SUBROUTINE TO GET NEXT CHARACTER
;RETURNS CHARACTER IN CH

SUBTTL	CHARACTER ROUTINE (GETCHA)
GETCHA:	SKIPE	REEAT		;SEE IF REPEATING CHAR
	JRST	[HRRE  CH,REEAT  ;REPEAT IT
		 SETZM REEAT	;ONLY ONCE
		 POPJ  P,]	;RETURN
	SETOM	CH		;PRESET EOF
	TXNE	F,F.EOF		;SEE IF EOF ALREADY
	POPJ	P,		;YES--RETURN
	MOVEI	CH,.CHLFD	;PRESET EOL
	TXNE	F,F.ECMD	;SEE IF END ALREADY
	POPJ	P,		;RETURN IF SO
	SKIPE	CH,GETCH	;SEE IF INPUT ROUTINE
	PUSHJ	P,(CH)		;YES--GO READ
	  TXOA	F,F.ECMD	;END OF LINE--SET FLAG
	POPJ	P,		;ELSE, RETURN
	MOVEI	CH,0		;CLEAR CH IF END
	POPJ	P,		;RETURN

SUBTTL	SUBROUTINE TO READ FROM COMMAND TTY
;SKIP RETURNS WITH VALUE IN CH
;NON-SKIPS IF END OF LINE (BREAK)

TTYIN:	GETLIN	ME,		;GET CURRENT LINE
	TLNE	ME,-1		;IF DETACHED, ALL DONE
	INCHSL	CH		;GET CHARACTER
	  JRST	TTYI.2		;ALL DONE IF BUFFER EMPTY
	JUMPE	CH,TTYIN	;IGNORE IF NULL
	CAIE	CH,.CHCRT	;ALSO IF C.RET.
	CAIN	CH,.CHDEL	; OR NULL
	JRST	TTYIN		; IGNORE
	CAIE	CH,"!"		;SEE IF COMMENT
	CAIN	CH,";"		; OR OTHER FORM
	JRST	TTYIND		;YES--GO DISCARD LINE
TTYI.1:	CAIE	CH,.CHBEL	;IF BELL
	CAIN	CH,.CHESC	; OR ESCAPE,
	JRST	TTYI.2		;IT IS ALL DONE
	CAIL	CH,.CHLFD	;IF LESS THAN LINE FEED
	CAILE	CH,.CHFFD	; OR GREATER THAN FORM FEED
	JRST	CPOPJ1		; THEN OK
TTYI.2:	TXZ	F,F.RTTY	;INDICATE SUCCESSFUL REEATING
	POPJ	P,		;ELSE, ALL DONE
TTYIND:	INCHSL	CH		;GET CHARACTER TO DISCARD
	  JRST	TTYI.2		;RETURN IF DONE
	PUSHJ	P,TTYI.1	;ANALYZE RESULT
	  POPJ	P,		;RETURN IF EOL
	JRST	TTYIND		;LOOP UNTIL DONE
SUBTTL	COMMAND LINE PROCESSOR
; SUBROUTINE TO INPUT FROM FILE DISCARDING
; COMMENTS AND HANDLING CONTINUATIONS

FILINC:	SKIPE	CH,FILICH	;SEE IF LEFT OVER CHARACTER
	JRST	FILI.1		;YES--REUSE IT
	PUSHJ	P,FILI.3	;NO--GET NEXT FROM FILE
	  POPJ	P,		;AT END, RETURN
FILI.1:	SETZM	FILICH		;CLEAR LEFT OVERS
	CAIE	CH,"-"		;SEE IF CONTINUATION
	JRST	CPOPJ1		;NO--GOOD RETURN
FILI.2:	PUSHJ	P,FILI.3	;YES--SKIP ON
	  JRST	FILINC		;IF END, GET CONTINUATION
	CAIE	CH,"	"	;IGNORE TRAILING
	CAIN	CH," "		; SPACES AND TABS
	JRST	FILI.2		;LOOP
	MOVEM	CH,FILICH	;NOT EOL, MUST BE REAL -
	MOVEI	CH,"-"		;RETURN IT
	JRST	CPOPJ1		;SAVING NEXT CHAR FOR LATER ON

;SUBROUTINE TO STRIP COMMENTS

FILI.3:	PUSHJ	P,FILIN		;GET NEXT CHAR
	  POPJ	P,		;IF EOL, INDICATE THAT
	CAIE	CH,"!"		;ELSE SEE IF COMMENT
	CAIN	CH,";"		; OR OLD FORM
	SKIPA			;YES
	JRST	CPOPJ1		;NO--GOOD RETURN
FILI.4:	PUSHJ	P,FILIN		;SKIP REST OF LINE
	  POPJ	P,		;GIVE EOL RETURN
	JRST	FILI.4		;LOOP

SUBTTL	SUBROUTINE TO TYPE CONTENTS OF FILE

TYPFIL:	TXO	F,F.TSOL	;INDICATE NOT AT START OF LINE
	TXZ	F,F.ECMD!F.EOF	;INDICATE NOT AT EOF
TYPF.1:	PUSHJ	P,FILIN		;GET NEXT CHARACTER
	  JUMPL	CH,TYPF.2	;RETURN AT EOF
	CAIN	CH,.CHLFD	;IF LINE FEED,
	TXZA	F,F.TSOL	;AT EOL, CLEAR LINE FULL FLAG
	TXOA	F,F.TSOL	;NOT EOL, INDICATE SOMETHING TYPED
	TTYCHR	.CHCRT		; OUTPUT C.RET.
	TTYCHR	(CH)		;OUTPUT CHARACTER
	JRST	TYPF.1		;LOOP UNTIL DONE

TYPF.2:	TXZE	F,F.TSOL	;SEE IF ANYTHING ON THIS LINE
	TTYSTR	CRLFM
	POPJ	P,		;NOW RETURN
;SUBROUTINE TO LOOKUP A FILE (MAYBE IN HISEG)
;CALL WITH:
;	T1 THRU T4 SET TO 4-WORD LOOKUP BLOCK
;	T5 THRU T7 SET TO OPEN BLOCK
;	PUSHJ	P,HILOOK
;	  RETURN HERE IF FILE NOT FOUND
;	RETURN HERE IF FILE EXISTS (LOWPTR SET TO BYTE PTR OR 0)
HILOOK:	TXZ	F,F.ECMD!F.EOF	;[CSM3] Clear in case JRST to HILK.7
	TXNN	F,F.ANSW	;IS THIS A FORCED COMMAND?
	JRST	HILK.7		;NO--DO THE SLOW THING
	PUSHJ	P,HIFIND	;IS THIS IN THE HISEG TABLES?
	  JRST	HILK.2		;NO--GO MEMORIZE THE FILE
HILK.1:	SKIPN	T1,HS$PTR(I)	;DOES THE FILE EXIST?
	 JRST	HILK.E		;[CSM3] No, return non-skip with F.EOF
	MOVEM	T1,LOWPTR	;REMEMBER BYTE POINTER TO STRING
	TXZ	F,F.EOF		;[CSM3] Clear this so FILIN uses LOWPTR
	JRST	CPOPJ1		;GIVE GOOD RETURN

;HERE TO REMEMBER A FILE
HILK.2:	PUSHJ	P,HILOCK	;INTERLOCK THE HISEG
	  JRST	HILK.7		;GIVE UP IF CAN'T LOCK
	PUSHJ	P,HIFIND	;GO FIND THE FILE IN THE HISEG TABLE
				; ON THE CHANCE THAT IT SNUCK IT.
	  SKIPA			;NO--THAT IS WHAT I THOUGHT
	JRST	HILK.1		;YES--IT HAS SNUCK IT
	MOVE	I,JOBN		;GET OUR JOB NUMBER
	CAME	I,LOKJOB	;DO WE OWN THE INTERLOCK
	AOS	ITLCNT		;NO, COUNT IT BUT TRY TO CONTINUE
	MOVSI	I,-N$HSGF	;MAKE AN AOBJN POINTER
HILK.3:	SKIPE	HS$DEV(I)	;IS THIS SLOT FREE?
	AOBJN	I,.-1		;NO--KEEP LOOKING
	JUMPGE	I,HILK.7	;TABLE FULL?
	PUSH	P,T6		;REMEMBER DEVICE, BUT NOT SO THAT HIFIND
				;FINDS IT BEFORE FILE ACTUALLY GETS IN
				;(PUT IT IN HS$DEV(I) ON COMPLETION)
	SETOM	HS$DEV(I)	;RESERVE THIS SLOT
	SETZM	HS$PTR(I)	;ZERO POINTER
	MOVEM	T1,HS$FIL(I)	;REMEMBER FILE NAME
	MOVEM	T2,HS$EXT(I)	;REMEMBER EXTENSION
	MOVEM	T4,HS$PPN(I)	;REMEMBER PPN
	OPEN	TI,T5		;OPEN DEVICE
	  JRST	HILK.8		;FILE NOT FOUND
	LOOKUP	TI,T1		;FIND THE FILE
	  JRST	HILK.8		;FILE NOT FOUND
;HERE TO COPY FILE INTO THE HISEG
	HLRZ	T2,.JBHRL	;FIND WHERE IN HIGH SEGMENT
	TRO	T2,400000	;PUT IN HIGH-SEG BIT
	MOVE	T1,HIPTR	;GET POINTER TO STRING
	TRNN	T1,-1		;IF NOT SET...
	HRRI	T1,1(T2)	;...GET FIRST FREE IN HIGH SEG
	MOVEM	T1,HIPTR	;INITIALIZE IT
	MOVEM	T1,HS$PTR(I)	;REMEMBER FOR THE FUTURE
	TXZ	F,F.EOF		;[CSM] So FILIN will read the file
HILK.4:	HRRZ	T1,HIPTR	;GET POINTER TO STRING
	ADDI	T1,10		;AVOID USUAL END EFFECTS
	HRRZ	T2,.JBHRL	;GET SIZE OF HISEG
	CAMG	T1,T2		;WILL WE NEED MORE CORE
	JRST	HILK.5		;NO--KEEP GOING
	HRLZ	T1,T1		;DO A CORE UUO FOR HISEG
	CORE	T1,		; ..
	  JRST	[AOS	CORCNT	;COUNT THE FAILURE FOR DEBUGGING
		 SETZM HS$DEV(I);FORGET THE FILE
		 SETZM HS$PTR(I);AND THE POINTER
		 POP	P,T6
		 SETZM	LOWPTR	;FILE NOT FOUND
		 JRST	CPOPJ1]	;BUT STILL SET UP
HILK.5:	PUSHJ	P,FILIN		;GET A BYTE
	  JUMPL	CH,HILK.6	;EOF?
	IDPB	CH,HIPTR	;STORE THE BYTE IN THE HISEG
	JRST	HILK.4		;KEEP LOOKING
HILK.6:	SETZM	CH		;FLAG END OF FILE
	IDPB	CH,HIPTR	; ..
	IDPB	CH,HIPTR	; ..
HILK.8:	POP	P,HS$DEV(I)	;NOW, REMEMBER DEVICE IN TABLE
	JRST	HILK.1		;RETURN TO STORE POINTERS

;HERE IF USER IS LOGGED IN -- JUST DO THE LOOKUPS
HILK.7:	SETZM	LOWPTR		;MAKE SURE WE READ FILE
	OPEN	TI,T5		;OPEN THE DEVICE
	  JRST	HILK.E		;[CSM3] File not found
	LOOKUP	TI,T1		;LOOK FOR THE FILE
	  JRST	HILK.E		;[CSM3] File not found
	JRST	CPOPJ1		;FILE SETUP

HILK.E:	TXO	F,F.EOF		;[CSM3] Set EOF for non-existant file
	POPJ	P,		;[CSM3]
;SUBROUTINE TO FIND A FILE IN HISEG TBALES
;CALL WITH:
;	T1 = FILE NAME
;	T2 = EXTENSION
;	T4 = PPN
;	T6 = DEVICE
;	PUSHJ	P,HIFIND
;	  HERE IF NOT IN TABLE
;	HERE IF IN TABLE (INDEX IN I)
HIFIND:	MOVSI	I,-N$HSGF	;AOBJN PTR
HFND.1:	CAME	T6,HS$DEV(I)	;RIGHT DEVICE
	JRST	HFND.2		;NO.
	CAME	T1,HS$FIL(I)	;RIGHT FILE
	JRST	HFND.2		;NO.
	CAME	T2,HS$EXT(I)	;RIGHT EXTENSION
	JRST	HFND.2		;NO
	CAMN	T4,HS$PPN(I)	;RIGHT PPN
	JRST	CPOPJ1		;YES--WE WON
HFND.2:	AOBJN	I,HFND.1	;LOOP OVER WHOLE TABLE
	POPJ	P,0		;NOT THERE
;SUBROUTINE TO INTERLOCK THE HISEG
;CALL WITH:
;	PUSHJ	P,HILOCK
;	  ERROR RETURN IF CAN'T GET HISEG
;	RETURN HERE
;NOTE: HISEG IS RELEASED ON POPJ
;
HILOCK:	MOVE	T8,[[XWD 4,INTLOC
		    XWD 0,ER.ICC!ER.OFL
		    0
		    0],,INTBLK]
	BLT	T8,INTBLK+3
	MOVEI	T8,INTBLK	; POINT TO TRAP BLOCK
	MOVEM	T8,.JBINT	; SET FOR TRAPPING!
TR.SET:	MOVEI	T8,0		;CLEAR USER WRITE PROTECT
	SETUWP	T8,		; ..
	  JRST	[SETZM NOINT
		POPJ	P,0]
	SETOM	NOINT		; NOT INTERRUPTABLE
	AOSN	LOCKWD		;GET THE INTERLOCK
	JRST	HLCK.2		;IF THE RESULT IS ZERO WE WON
	SETZM	NOINT		;DIDN'T GET INTERLOCK, MAKE
				; INTERRUPTABLE AGAIN
HLCK.1:	MOVE	T8,MYBIT	;BIT SAYING WE ARE WAITING FOR THE INTERLOCK
	IORM	T8,@MYWRD	;LIGHT FOR OWNER TO SEE
	MOVEI	T8,^D15000	;SLEEP FOR 15 SECONDS
	HIBER	T8,		;
	JRST	[MOVEI	T8,10	;SLEEP 8 SECONDS
		 SLEEP	T8,	;SLEEP IF HIBER NOT IMPLEMENTED
		 JRST	.+1]	;CONTINUE
	MOVE	T8,MYBIT	;GET BIT AGAIN
	ANDCAM	T8,@MYWRD	;NOT ACTUALLY WAITING ANYMORE
	PUSHJ	P,HIFIND	;SEE IF THE FILE IS IN CORE YET
	  CAIA			;NO, MUST WAIT FOR IT
	JRST	UNLK.4		;RETURN WITHOUT INTERLOCK
	SETOM	NOINT		;LOCK OUT INTS.
	AOSN	LOCKWD		;OPEN YET??
	 JRST	HLCK.2		;YES. PROCEED
	SETZM	NOINT		;STILL LOCKED. BETTER INVESTIGATE THIS...
HLCK.5:	PUSH	P,LOKJOB	;SAVE A COPY FOR CHECKING
	PUSH	P,LOKTTY	;GET HIM TOO
	HRLZ	T8,-1(P)	;POINT TO INTERLOCKER'S JBTSTS
	GETTAB	T8,		;GET IT
	  JRST	FORCE		;??? FORCE THE LOCK
	TLC	T8,440000	;RUN+JNA
	TLCE	T8,440000	;BOTH ON?
	  JRST	FORCE		;NO, SOMETHING WRONG
	HRLZ	T8,-1(P)	;SET UP JOB # AGAIN
	HRRI	T8,.GTPRG	;LOOK FOR PROGRAM NAME
	GETTAB	T8,		;GET IT
	  JRST	FORCE		;TOO BAD
	CAME	T8,['INITIA']	;RIGHT GUY?
	  JRST	FORCE		;NO, TOO BAD
	MOVE	T8,(P)		;GET OWNER'S TTY UDX
	DEVTYP	T8,		;LOOK AT TTY'S PROPERTIES
	  JRST	FORCE		;TOO BAD
	LDB	T8,[POINTR(T8,TY.JOB)]	;GET JOB # USING IT
	CAME	T8,-1(P)	;RIGHT GUY?
	 JRST	FORCE		;NO, GOT HIM!!
	SUB	P,[2,,2]	;RESTORE THE PDL
	JRST	HLCK.1		;GOOD LOCK, RETURN
HLCK.2:	POP	P,T8		;GET RETURN PC
	PUSH	P,JOBN		;GET OUR JOB #
	POP	P,LOKJOB	;STORE FOR OTHERS
	PUSH	P,TERNUM	;AND OUR LINE
	POP	P,LOKTTY	;SAVE IT AWAY
	PUSHJ	P,1(T8)		;SKIP CALL COROUTINE
UNLOCK:	  SOS	(P)		;INDICATE FAILURE
	MOVE	T8,JOBN		;GET OUR JOB NUMBER
	CAME	T8,LOKJOB	;WE OWN THE INTERLOCK?
	JRST	UNLK.4		;NO
	MOVE	T8,TERNUM	;GET OUR TTY NUMBER
	CAME	T8,LOKTTY	;WE OWN IT?
	JRST	UNLK.4		;NO
	SETZM	LOKJOB		;CLEAR OWNER
	SETZM	LOKTTY		;AND OWNER'S TTY
	SETOM	LOCKWD		;RESET INTERLOCK
	PUSH	P,T1		;SAVE A FEW ACS
	PUSH	P,T2		;...
	PUSH	P,T3		;...
	MOVSI	T1,-JBWATL	;NUMBER OFF ENTRIES IN JOBWAT TABLE
	SKIPN	T2,JOBWAT(T1)	;ANYBODY WAITING HERE
	AOBJN	T1,.-1		;NO, LOOK SOME MORE
	JUMPGE	T1,UNLK.1	;NOBODY WAITING FOR THE INTERLOCK
	JFFO	T2,.+1		;GET WAITERS BIT
	MOVEI	T2,(T1)		;GET THE WORD NUMBER
	IMULI	T2,^D36		;TO A JOB NUMBER
	ADDI	T2,(T3)		;...
	WAKE	T2,		;WAKE UP THE JOB
	  JFCL			;OH WELL
	MOVSI	T2,(1B0)	;FIGURE OUT THE BIT TO CLEAR
	MOVNS	T3		;...
	LSH	T2,(T3)		;POSITION IT
	ANDCAM	T2,JOBWAT(T1)	;SO OTHER INITIAS DONT TRIP OVER A STALE JOB
UNLK.1:	POP	P,T3		;RESTORE
	POP	P,T2		;...
	POP	P,T1		;...
UNLK.4:	MOVEI	T8,1		;GO AND WRITE PROTECT
	SETUWP	T8,		; THE HISEGMENT AGAIN
	  JFCL
	SETZM	.JBINT		; TURN OFF TRAPPING
	SETZM	NOINT		; CLEAR NO INTERRUPT WORD
	JRST	CPOPJ1		;GIVE SKIP RETURN

;HERE TO FORCE THE LOCK
FORCE:	AOS	FRCTRY		;COUNT ATTEMPTS TO FORCE THE LOCK
	MOVE	T8,LOKJOB	;GET CURRENT OWNER OF LOCK
	CAME	T8,-1(P)	;SAME AS WE CHECKED?
	JRST	FORCE1		;NO
	MOVE	T8,LOKTTY	;GET TTY OF OWNER
	CAME	T8,0(P)		;SAME AS WE CHECKED?
	JRST	FORCE1		;NO
	SETZM	LOKJOB		;NO OWNER
	SETZM	LOKTTY		;  OR TTY
	SETOM	LOCKWD		;GIVE UP INTERLOCK
	AOS	FRCCNT		;COUNT NUMBER OF ACTUAL FORCES
	SUB	P,[2,,2]	;RESTORE PDL
	JRST	HLCK.1		;RE-JOIN THE COMPETITION
FORCE1:	SUB	P,[2,,2]	;RESTORE THE PDL
	JRST	HLCK.5		;CHECK AGAIN
; HERE TO PROCESS CONTROL-C INTERCEPT
INTLOC:	MOVEM	T1,TEMP1	; SAVE T1
	HLRZ	T1,INTBLK+3	; GET REASON FOR INTERRUPT
	CAIN	T1,ER.OFL	; DSK OFF LINE?
	JRST	OFLPRC		; YES, GO PROCESS IT
	CAIE	T1,ER.ICC	; NO, CONTROL-C INTERRUPT?
	HALT			; NO, MY GOD!
	SKIPL	NOINT		; INTERRUPTABLE?
	EXIT		; YES, SO QUIT IF THAT'S WHAT HE WANTS
	OUTSTR	[ASCIZ /
Interlocked/]
OFLENT:	EXCH	T1,TEMP1	; RESTORE T1
	PUSH	P,INTBLK+2	; SETUP FOR POPJ RETURN
	SETZM	INTBLK+2	; SET FOR ANOTHER TRAP
BADTRP:	POPJ	P,0		; RETURN TO SEQUENCE
; HERE ON DSK OFF LINE INTERRUPTS
OFLPRC:	MOVEI	T1,STRUCO	; GET DESIRED RETURN ADDRESS
	MOVEM	T1,INTBLK+2	; AND FUDGE IT
	JRST	OFLENT		; GO DO THE STANDARD STUFF
SUBTTL	SUBROUTINE TO READ FROM FILE
;SKIP RETURNS WITH VALUE IN CH
;NON-SKIPS IF END OF LINE (CH=-1 AT EOF)

FILIN:	TXNE	F,F.EOF		;SEE IF EOF
	JRST	FLIN.3		;YES--REPEAT THAT
	ILDB	CH,LOWPTR	;GET A BYTE FROM HISEG
	JUMPN	CH,FLIN.1	;JUMP IF VALID DATA
	SKIPE	LOWPTR		;SKIP IF WE NEVER SETUP HISEG
	JRST	FLIN.3		;ELSE THIS IS THE EOF MARK
	SOSGE	IBF+.BFCTR	;COUNT DOWN BYTES
	JRST	FLIN.2		;EMPTY--GET NEXT BUFFER
	IBP	IBF+.BFPTR	;INCREMENT TO NEXT BYTE
	TXNE	F,F.BIN		;SEE IF BINARY FILE
	JRST	[LDB  CH,IBF+.BFPTR
		 JRST CPOPJ1]	;IF SO, RETURN WORD
	MOVE	CH,@IBF+.BFPTR	;GET NEXT WORD
	TRNE	CH,1		;SEE IF SEQUENCED
	JRST	[AOS IBF+.BFPTR	;YES--SKIP 5
		 MOVNI CH,5	; MORE CHARS
		 ADDM CH,IBF+.BFCTR
		 JRST FILIN]	;AND TRY AGAIN
	LDB	CH,IBF+.BFPTR	;GET CHARACTER
	JUMPE	CH,FILIN	;IGNORE NULLS
	TXNE	F,F.PCR		;[CSM3] Preserve CR and DEL?
	 JRST	FLIN.1		;[CSM3] Yes, needed for SETUP$, TYPE$
	CAIE	CH,.CHCRT	;ALSO C.RET.
	CAIN	CH,.CHDEL	; AND DELETE
	JRST	FILIN		;--JUST LOOP FOR NEXT
FLIN.1:	CAIL	CH,.CHLFD	;IF LESS THAN LINE FEED
	CAILE	CH,.CHFFD	; OR GT FORM FEED,
	JRST	CPOPJ1		; GIVE SKIP RETURN
	POPJ	P,		;ELSE, GIVE END OF LINE

FLIN.2:	IN	TI,		;INPUT NEXT BUFFER
	  JRST	FILIN		;LOOP IF OK
	STATZ	TI,IO.ERR	;SEE IF ERROR BITS
	INTERR	(IOE,<I/O Error>,<JRST FLIN.3>)
FLIN.3:	SETOM	CH		;SET FLAG
	TXO	F,F.EOF		;SET END FLAG
	POPJ	P,		;RETURN
SUBTTL	SUBROUTINES
SUBTTL	SUBROUTINE TO LOGIN A JOB
;CALL:	T2/ PROJECT,,PROGRAMMER NUMBER
;	T4/ "USER" NAME IN SIXBIT
;	PUSHJ	P,LOGIN$
;RETURNS IF SUCCESSFUL

LOGI12:	TXO	F,F.PRIV	;FLAG TO GET ALL PRIVILEGES
	MOVE	T2,FFAPPN	;GET [1,2]
	TXNN	F,F.REMO	;SEE IF REMOTE OPR
	JRST	LOGI.1		;NO--PROCEED
	HLRZ	T1,NL.ME	;YES--GET STATION NUMBER
	HRLI	T2,100(T1)	;USE [100+SN,2]
	JRST	LOGIN$		;AND GO LOGIN
;HERE IF LOGIN TO [1,2]
LOGI.1:	TXNE	F,F.LOGI	;SEE IF LOGGED IN
	JRST	LOGIN$		;YES--NO SPECIAL TEST
	SETOM	T3		;NO--GET MY TTY
	GETLCH	T3		; CHARACTERISTICS
	TXNE	T3,GL.ITY!GL.DSL!GL.REM ;MAKE SURE LOCAL
	JRST	KILJOB		;NO--GO EXIT INSTEAD
LOGIN$:	TXNN	F,F.LOGI	;SEE IF ALREADY LOGGED IN
	JRST	LOGI.2		;NO--GO LOG IT IN
	TXNN	F,F.LOGX	;SEE IF OK TO BE DIFFERENT
	CAMN	T2,MYPPN	;NO--SEE IF DIFFERENT
	POPJ	P,		;NO--RETURN
	JRST	KILJOB		;YES--GO EXIT INSTEAD
LOGI.2:	MOVSI	T1,.STOPP	;CODE TO SET (NO) OPERATOR PRIVS
	HRRI	T1,.OBNOP	;SET NO OPERATOR PRIVS BY DEFAULT
	TXNE	F,F.PRIV	;NEED PRIVS?
	HRRI	T1,.OBSOP	;[201] YES, MAKE THIS JOB A SYSTEM OPR
	TXNE	F,F.REMO	;ARE WE BECOMING A REMOTE OPR?
	HRRI	T1,.OBROP	;YES, ONLY GIVE REMOTE OPR PRIVS
	SETUUO	T1,		;GIVE THE APPROPRIATE PRIV
	 JFCL			;OH WELL, WE TRIED!
;[CSM2] Change to set 2nd word of username when doing LOGIN
;[CSM2] T4 has first word, such as OPSER or SYSDPY
	MOVE	T1,[-4,,T2]	;[CSM2] Set up pointer for UUO
	PUSH	P,T5		;[CSM2] Preserve T5 (program name in T4)
	MOVE	T5,ME		;[CSM2] Put TTY name in user name
	TRNN	T5,77		;[CSM2] If 5 chars (such as TTY12),
	 LSH	T5,-6		;[CSM2]  change to "SYSDPY TTY12"
	TXNN	F,F.PRIV	;SEE IF PRIVILEGES NEEDED
	TDZA	T3,T3		;NO--CLEAR THEM
	MOVSI	T3,-1		;YES--SET ALL DEC PRIVILEGES.
	TXNE	F,F.REMO	;UNLESS REMOTE OPR
	MOVE	T3,[JP.NSP]	;WHO ONLY NEEDS UNSPOOLING
	MOVEM	T2,REQPPN	;SAVE REQUESTED PPN
	LOGIN	T1,		;TRY
	POP	P,T5		;[CSM2] Restore T5
	TTYSTR	[ASCIZ /.LOGIN /]
	HLRZ	T1,REQPPN	;GET PROJECT
	PUSHJ	P,TYPOCT	;TYPE IN OCTAL
	TTYCHR	","		;SEPARATE
	HRRZ	T1,REQPPN	;GET PROGRAMMER
	PUSHJ	P,TYPOCT	;TYPE IN OCTAL
	TTYSTR	CRLFM
;HERE TO LOCATE USER TO NODE SPECIFIED IN /LOCATE:NN OR
;IN THE ABSENCE OF A LOCATE COMMAND, TO THE CENTRAL SITE
;IF HE IS BEING LOGGED IN ON A NODE WITHOUT AN LPT

LOCAT$:	SKIPGE	T1,LOCAT	;DID USER SPECIFY LOCATE?
	 JRST	LOCAT0		;YES--LOCATE HIM THERE
LOCAT2:	MOVEI T1,.GTLOC		;GETTAB FOR NODE # OF CENTRAL SITE
	GETTAB	T1,		;GET CENTRAL SITE NODE NUMBER
	  JRST	NOLOC		;MONITOR MUST NOT SUPPORT NETWORKS
	HRROI	T2,.GTLOC	;THIS JOB'S LOCATION
	GETTAB	T2,		;GET THAT
	  JRST	NOLOC		;NO NETWORK SOFTWARE
	CAMN	T1,T2		;ALREADY LOCATED AT CENTRAL SITE?
	JRST	NOLOC		;YES, NO POTENTIAL PROBLEMS THEN
	MOVEM	T2,NODLOC	;STORE THIS JOB'S LOCATION IN NODE BLOCK
	MOVEI	T2,4		;LENGTH OF THE ARGUMENT BLOCK
	MOVEM	T2,NODLEN	;STORE IN NODE UUO ARGUMENT BLOCK
	MOVEI	T2,.TYLPT	;DEVICE TYPE
	MOVEM	T2,NODDEV	;STORE THAT IN THE ARGUMENT BLOCK
	MOVE	T2,[.NDRCI,,NODBLK]  ;NODE UUO ARGUMENT
	NODE.	T2,		;GET NODE CONFIGURATION INFORMATION
	  JRST	NOLOC		;NOT IMPLEMENTED?
	HLRZ	T2,NODDEV	;NUMBER OF LPT'S AT THIS NODE
	JUMPN	T2,NOLOC	;JUMP IF THERE ARE SOME
	JRST	LOCAT1		;NO LPT'S AT THIS NODE,
				;LOCATE JOB AT CENTRAL SITE

LOCAT0:	HRRZS	T1		;CLEAR LH
	CAIG	T1,^D77		;NODE NUMBER .GT. 77?
	 JRST	LOCAT3		;NO--CONTINUE
	INTWRN	(NTL,NODE NUMBER TOO LARGE)
	JRST	LOCAT2		;CANNOT LOCATE HIM, SAME AS IF NO SWITCH
LOCAT3:	IDIVI	T1,^D10		;CONVERT NODE TO OCTAL
	LSH	T1,3		;...
	ADD	T1,T2		;...

LOCAT1:	LOCATE	T1,		;LOCATE USER

	OUTSTR	[ASCIZ /%INTLUF LOCATE UUO failed.
/]
;HERE TO FIND THE PPN IN SYS:AUXACC.SYS IF POSSIBLE
;IF ANY PROBLEMS, PROCEED ONWARD AND DUPLICATE THE SYS S/L

NOLOC:	MOVE	T1,[UU.PHS!.IOBIN]	;BINARY MODE, PHYSICAL ONLY.
	MOVSI	T2,'SYS'	;SYS:
	MOVEI	T3,IBF		;INPUT BUFFER HEADER
	OPEN	TI,T1		;GET DEVICE
	  JRST	STRN.6		;GIVE UP IF UNAVAILABLE!
	MOVE	T1,['AUXACC']	;FILE
	MOVSI	T2,'SYS'	; NAMED
	SETZB	T3,T4		; SYS:AUXACC.SYS[-]
	LOOKUP	TI,T1		;GET IT
	  JRST	STRN.6		;GIVE UP IF MISSING
	TXO	F,F.BIN		;TELL INPUTTER BINARY
	TXZ	F,F.EOF		;CLEAR EOF FLAG
	PUSHJ	P,FILIN		;GET FIRST WORD
	  JRST	STRN.6		;IF NULL FILE, GIVE UP
	JUMPN	CH,STRN.6	;ONLY FORMAT V.0 WORKS
;BACK HERE TO LOOP OVER PPNS IN FILE
STRN.1:	PUSHJ	P,FILIN		;GET INDICATOR
	  JRST	STRN.6		;OUR PPN MISSING!
	AOJN	CH,STRN.6	;-1 IS FLAG
	PUSHJ	P,FILIN		;GET SIZE
	  JRST	STRN.6		;BAD FILE
	SOSGE	T6,CH		;GET COUNT LESS PPN
	JRST	STRN.6		;ERROR IF NEGATIVE SIZE
	PUSHJ	P,FILIN		;GET PPN
	  JRST	STRN.6		;BAD FILE
	MOVE	T1,CH		;GET PPN
	XOR	T1,REQPPN	;COMPARE TO DESIRED
	TRC	CH,-1		;SEE IF FILE IS WILD
	TRNN	CH,-1		;TEST WILD
	TRZ	T1,-1		;YES--PROGRAMMER ALWAYS MATCHES
	JUMPE	T1,STRN.3	;JUMP IF MATCH!!!
;LOOP TO SKIP ENTRY WE WANT TO IGNORE
STRN.2:	PUSHJ	P,FILIN		;DISCARD
	  JRST	STRN.6		;(BAD FILE)
	SOJG	T6,STRN.2	;UNTIL COUNT EXHAUSTED
	JRST	STRN.1		;THEN TRY NEXT PPN
;HERE WHEN ENTRY MATCHES
STRN.3:	IDIVI	T6,5		;GET STR COUNT
	JUMPN	T7,STRN.6	;ERROR IF NOT MULTIPLE OF 5
	MOVEI	T7,1		;START INDEX INTO ANSWER
;LOOP OVER STRS FOR THIS PPN
STRN.4:	JUMPE	T6,STRN.5	;EXIT WHEN DONE
	CAIGE	T7,ENDSTR-STRBLK  ;SEE IF OVERFLOW
	PUSHJ	P,FILIN		;NO--GET NEXT STR
	  JRST	STRN.5		;EXIT IF EOF (EVEN THO ERROR)
	MOVEM	CH,STRBLK(T7)	;SAVE STR NAME
	SETZM	STRBLK+1(T7)	;CLEAR PPN OF THIS STR
	PUSHJ	P,FILIN		;GET/IGNORE NEXT WORD
	  JRST	STRN.5		;(ERROR)
	PUSHJ	P,FILIN		;GET/IGNORE NEXT WORD
	  JRST	STRN.5		;(ERROR)
	PUSHJ	P,FILIN		;GET/IGNORE NEXT WORD
	  JRST	STRN.5		;(ERROR)
	PUSHJ	P,FILIN		;GET STATUS BIT WORD
	  JRST	STRN.5		;(ERROR)
	MOVEM	CH,STRBLK+2(T7)	;SAVE BITS
	MOVE	T1,[1,,T2]	;POINTER FOR DSKCHR
	MOVE	T2,STRBLK(T7)	;GET STR NAME
	DSKCHR	T1,		;GET ITS STATUS
	  SETOM	T1		;ERROR
	TXC	T1,<.DCTFS_<ALIGN.(DC.TYP)>>
	TXNN	T1,<DC.SAF!DC.NNA!DC.TYP>  ;MUST BE MULTI-ACCESS
			; ,ACCESSIBLE, AND A FILE-STRUCTURE
	ADDI	T7,3		;YES--ADVANCE ANSWER POINTER
	SOJG	T6,STRN.4	;LOOP OVER ALL STRS THIS PPN
;HERE WHEN A LIST HAS BEEN BUILT IN CORE
STRN.5:	RELEAS	TI,		;RELEASE INPUT CHANNEL
	TXZ	F,F.BIN!F.EOF	;CLEAR BINARY INDICATOR AND EOF
	MOVE	T1,T7		;POSITION COUNTER
	JRST	STRN.8		;PROCEED TO TELL MONITOR

;HERE WHEN CAN'T USE SYS:AUXACC.SYS FOR ANY REASON
STRN.6:	RELEAS	TI,		;RELEASE INPUT CHANNEL
	TXZ	F,F.BIN!F.EOF	;CLEAR BINARY INDICATOR AND EOF
;HERE TO COPY THE SYS: SEARCH LIST

	SETZM	GETSTR		;SET GOBSTR ARGS TO JOB 0
	MOVE	T1,SYSPPN	;GET [1,4]
	MOVEM	T1,GETSTR+1	;SET SYS PPN AS PPN IN QUESTION
	SETOM	GETSTR+2	;SET TO START OF LIST
	MOVNI	T1,2		;PRESET ANSWER BLOCK

STRN.7:	MOVE	T3,[5,,GETSTR]	;GET POINTER FOR GOBSTR
	ADDI	T1,3		;ADVANCE ANSWER POINTER
	CAIGE	T1,ENDSTR-STRBLK  ;SEE IF FULL
	GOBSTR	T3,		;NO--GET NEXT STR
	  JRST	STRN.8		;CAN'T--GO SEE IF CAN SET IT UP
	SKIPE	T3,GETSTR+2	;GET STR NAME
	CAMN	T3,[-1]		;CHECK FOR FENCE
	JRST	STRN.8		;YES--GO SEE IF CAN SET IT UP
	MOVEM	T3,STRBLK(T1)	;OK--STORE STR
	MOVE	T3,GETSTR+3	;GET PPN JUST IN CASE IT EVER COUNTS
	MOVEM	T3,STRBLK+1(T1)  ;STORE IN STRUUO BLOCK
	MOVE	T3,GETSTR+4	;GET STATUS BITS
	MOVEM	T3,STRBLK+2(T1)  ;STORE IN BLOCK
	JRST	STRN.7		;LOOP BACK FOR MORE

STRN.8:	SETZM	STRBLK		;SET FUNCTION FOR STRUUO
	MOVE	T3,['DSKB  ']	;SET FOR DSKB JUST IN CASE NONE
	SKIPN	STRBLK+1	;SEE IF ANY STR SETUP
	MOVEM	T3,STRBLK+1	;NO--FILL IN DEFAULT
	HRLZI	T1,(T1)		;GET LENGTH OF LIST
	TLNN	T1,-2		;SEE IF ANYTHING THERE
	HRLZI	T1,4		;NO--SET FOR AT LEAST ONE STR
	HRRI	T1,STRBLK	;POINT TO BLOCK
	STRUUO	T1,		;TELL MONITOR
	  JFCL			;WELL--NICE TRY
	MOVE	T1,[.STUVM,,[1000,,1000]] ;SET PHYS & VIRT LIMITS
	SETUUO	T1,		; TO ALLOW JOB TO GO VIRTUAL
	  JFCL			;IGNORE ERROR
	POPJ	P,		;RETURN IF SUCCESSFUL
SUBTTL	SUBROUTINE TO TYPE SIGN ON MESSAGE
;CALL:	PUSHJ	P,SIGNON
;USES ALL TEMPS

SIGNON:	MOVE	T1,FLNAME	;SEE IF USER
	TRNN	T1,1		;  SAID NONAME
	TXNE	F,F.NOHD	;SEE IF HEADER SUPPRESSED
	POPJ	P,		;YES--RETURN QUICKLY
	TTYSTR	CRLFM
	MOVSI	T7,-5		;SETUP POINTER TO READ
	MOVX	T6,%CNFG0	;SYSTEM HEADER LINE

SIGN.1:	MOVE	T5,T6		;MAKE POINTER
	GETTAB	T5,		;GET THE HEADER
	  MOVEI	T5,0		;DON'T REALLY CARE IF THIS FAILS
	MOVEM	T5,T1(T7)	;STORE IN ARRAY
	ADD	T6,[1,,0]	;ADVANCE INDEX
	AOBJN	T7,SIGN.1	;LOOP FOR TITLE

	MOVEI	T6,0		;GUARANTEE CLEAN END
	TTYSTR	T1		;TYPE HEADER
	TTYCHR	" "		;SEND A SPACE
	MSTIME	T4,		;GET TIME OF DAY
	IDIVI	T4,^D1000	;CONVERT TO SECONDS
	IDIVI	T4,^D3600	;GET HOURS
	PUSHJ	P,TYPD2		;TYPE HOURS
	MOVE	T4,T5		;RE-POSITION REMAINDER
	IDIVI	T4,^D60		;GET MINUTES
	PUSHJ	P,TYPD2C	;TYPE COLON, MINUTES
	MOVE	T4,T5		;GET SECONDS
	PUSHJ	P,TYPD2C	;TYPE COLON, SECONDS
	TTYCHR	" "		;SEND A SPACE
	MOVE	T2,ME		;GET TTY NAME
	PUSHJ	P,TYPSIX	;TYPE IT
	TTYSTR	[ASCIZ / system /]
	MOVE	T1,[%CCSER]	;GET CPU0 SERIAL NUMBER
	GETTAB	T1,		;...
	MOVE	T1,APRSN	;USE DEFAULT
	MOVNI	T7,6*2		;PRESET FOR 6 CPU'S
SIGN.2:	PUSHJ	P,TYPDEC	;LIST IN DECIMAL
	AOS	T1,T7		;TRY NEXT CPU
	ADD	T1,[%CCSER+6*2+1]  ;GET APR S/N
	GETTAB	T1,		; FROM MONITOR
	  MOVEI	T1,0		;STOP IF NO CPU
	JUMPLE	T1,SIGN.3	;END LOOP IF JUNK
	TTYCHR	"/"		;SEPARATE
	AOJL	T7,SIGN.2	;LOOP UNTIL DONE

;CONTINUED ON NEXT PAGE
;CONTINUED FROM PREVIOUS PAGE

SIGN.3:	TTYSTR	[ASCIZ /
Connected to Node /]
	MOVE	T2,MYNNAM	; GET SIXBIT NODE NAME
	PUSHJ	P,TYPSIX	; TYPE NODE NAME
	TTYSTR	[ASCIZ /(/]
	HLRZ	T1,NL.ME	; GET NODE NUMBER
	PUSHJ	P,TYPOCT
	TTYSTR	[ASCIZ /) Line # /]
	HRRZ	T1,NL.ME
	PUSHJ	P,TYPOCT
SIGN3A:	TTYSTR	CRLFM
	PUSHJ	P,THISTT	;[CSM3] Output "This terminal is a ..."
	TXNN	F,F.LOGI	;SEE IF LOGGED IN
	POPJ	P,		;NO--ALL DONE
	TTYSTR	[ASCIZ /Job /]
	MOVE	T1,JOBN		;GET JOB NUMBER
	PUSHJ	P,TYPDEC	;TYPE IN DECIMAL
	HRROI	T2,.GTNM1	;GET USER'S NAME
	GETTAB	T2,		; FROM MONITOR
	  JRST	SIGN.4		;IGNORE IF UNAVAILABLE
	JUMPE	T2,SIGN.4	;OR MISSING
	TTYSTR	[ASCIZ /   User /]
	PUSHJ	P,TYPSX6	;TYPE SIX CHARACTERS
	HRROI	T2,.GTNM2	;GET 2ND HALF OF NAME
	GETTAB	T2,		; FROM MONITOR
	  MOVEI	T2,0		;(IMPOSSIBLE)
	PUSHJ	P,TYPSIX	;TYPE IN SIXBIT AND RETURN
	TTYSTR	[ASCIZ /   [/]	;THEN ISSUE PPN
	HLRZ	T1,MYPPN	;GET MY PROJECT
	PUSHJ	P,TYPOCT	;ISSUE IN OCTAL
	TTYCHR	","		;SEPARATE WITH COMMA
	HRRZ	T1,MYPPN	;GET MY PROGRAMMER
	PUSHJ	P,TYPOCT	;ISSUE IN OCTAL
	TTYCHR	"]"		;END PPN
SIGN.4:	TTYSTR	1,CRLFM
SUBTTL	SUBROUTINE TO TYPE KSYS MESSAGE
;CALL:	PUSHJ	P,TYKSYS
;USES ALL TEMPS

TYKSYS:	MOVX	T1,%NSKTM	;GET TIME TO GO
	GETTAB	T1,		; FROM MONITOR
	  POPJ	P,		;RETURN IF NOT IMPLEMENTED
	SKIPE	T1		;SEE IF SET
	CAIL	T1,^D24*^D60	; AND LESS THAN 24 HRS.
	POPJ	P,		;NO--RETURN
	JUMPL	T1,TYKS.2	;SEE IF ALREADY DOWN
	TTYSTR	[ASCIZ /
Timesharing will cease in /]	;[CSM3] Added extra CRLF before message
	PUSH	P,T1		;SAVE TIME
	IDIVI	T1,^D60		;GET HOURS
	JUMPE	T1,TYKS.1	;JUMP IF LT 1 HOUR
	PUSHJ	P,TYPDEC	;TYPE IN DECIMAL
	TTYSTR	[ASCIZ / hours /]
TYKS.1:	MOVE	T1,(P)		;GET TIME AGAIN
	IDIVI	T1,^D60		;GET MINUTES
	MOVE	T1,T2		; INTO RIGHT AC
	PUSHJ	P,TYPDEC	;TYPE IN DECIMAL
	TTYSTR	[ASCIZ / minutes, at /]
	MSTIME	T1,		;GET TIME OF DAY
	IDIVI	T1,^D60000	;GET MINUTES OF DAY
	POP	P,T2		;RESTORE KSYS TIMER
	ADD	T1,T2		;FIND TIME OF DAY
	CAIL	T1,^D24*^D60	;SEE IF TOMORROW
	SUBI	T1,^D24*^D60	;YES--CORRECT TIME
	IDIVI	T1,^D60		;GET HOURS
	PUSH	P,T2		;SAVE MINUTES
	MOVE	T4,T1		;POSITION HOURS
	PUSHJ	P,TYPD2		;TYPE HOURS AS TWO DIGITS
	POP	P,T4		;RESTORE MINUTES
	PUSHJ	P,TYPD2C	;TYPE AS :TWO DIGITS
	JRST	TYKS.3		;AND FINISH LINE

;HERE IF KSYS TIMER ALREADY RUN OUT
TYKS.2:	TTYSTR	[ASCIZ /Timesharing is over/]
TYKS.3:	TTYSTR	1,[ASCIZ /.
/]
SUBTTL	ERROR HANDLERS

;HERE IF LOGICAL INCONSISTENCY IN PROGRAM--NOTE BP=ADDR. OF PROBLEM

E$$BMB:	INTERR	(BMB,<Bomb out >,<JRST .+1>)
	MOVEI	T1,(BP)		;GET ADDRESS
	SUBI	T1,INITIA+1	;CONVERT TO RELATIVE
	PUSHJ	P,TYPOCT	;ISSUE IN OCTAL
EBMB.1:	OUTSTR	CRLFM		;END LINE
	SUBI	BP,INITIA+1	;SUBTRACT RELOCATION AND PC INCREMENT
	LIGHTS	BP,		;FOR DEBUGGING, SEND TO LIGHTS
	JRST	KILJOB		;GO KILL OFF JOB

SUBTTL	TYPEOUT ROUTINES

;SUBROUTINE TO TYPE TWO DECIMAL DIGITS
;WARNING--THIS DOES NOT HANDLE NEGATIVE NUMBERS OR NUMBERS
;	GREATER THAN 99.
;CALL:	MOVE	T4,NUMBER
;	PUSHJ	P,TYPD2
;USES T1, T2

TYPD2C:	TTYCHR	":"

TYPD2:	MOVE	T1,T4		;GET NUMBER
	IDIVI	T1,^D10		;GET TENS
	TTYCHR	"0"(T1)		;TYPE IT
	TTYCHR	1,"0"(T2)	;TYPE IT AND RETURN



;SUBROUTINE TO TYPE A DECIMAL/OCTAL NUMBER
;CALL:	MOVE	T1,NUMBER
;	PUSHJ	P,TYPDEC/OCT
;USES T1,T2,T3

TYPOCT:	SKIPA	T3,[10]		;SET OCTAL RADIX
TYPDEC:	MOVEI	T3,^D10		;SET DECIMAL RADIX
TYPRAD:	SKIPGE	T1		;IF NEGATIVE,
	TTYCHR	"-"		; ISSUE MINUS
TYPR.1:	IDIVI	T1,(T3)		;GET LOWEST DIGIT
	MOVMS	T2		;GET POSITIVE OF REMAINDER
	HRLM	T2,(P)		;STACK IT
	SKIPE	T1		;UNLESS DONE
	PUSHJ	P,TYPR.1	;  TRY AGAIN
	HLRZ	T1,(P)		;GET TOP DIGIT
	TTYCHR	1,"0"(T1)	;OUTPUT IT AND RETURN

;SUBROUTINE TO TYPE 6 SIXBIT CHARACTERS
;CALL:	MOVE	T2,WORD
;	PUSHJ	P,TYPSX6
;USES T1, T2, T3

TYPSX6:	MOVEI	T3,6		;SET COUNT
TYPS.1:	MOVEI	T1,0		;CLEAR NEXT CHARACTER
	LSHC	T1,6		;GET NEXT CHAR
	TTYCHR	40(T1)		;TYPE IT
	SOJG	T3,TYPS.1	;LOOP UNTIL COUNT DONE
	POPJ	P,		;THEN RETURN

;SUBROUTINE TO TYPE A SIXBIT WORD
;CALL:	MOVE	T2,WORD
;	PUSHJ	P,TYPSIX
;USES T1, T2

TYPSIX:	MOVEI	T1,0		;CLEAR NEXT CHAR
	LSHC	T1,6		;GET NEXT CHAR
	TTYCHR	"A"-'A'(T1)	;TYPE  IT
	JUMPN	T2,TYPSIX	;LOOP UNTIL ALL DONE
	POPJ	P,		;THEN RETURN

;SUBROUTINE TO TYPE AN ASCII STRING IN IMAGE MODE
;CALL:	MOVEI	T2,STRING POINTER
;	PUSHJ	P,SNDIMG
;	RETURN
;USES T2 and CH


SNDIMG:	HRLI	T2,(POINT 7,)	;TURN INTO BYTE POINTER
	PUSH	P,T2		;[CSM3] Save it
SNDI.1:	ILDB	CH,(P)		;[CSM3] Get next character
	JUMPE	CH,SNDI.2	;[CSM3] Stop at null
	PUSHJ	P,PEVEN8	;[CSM3] Print with even parity
	JRST	SNDI.1		;[CSM3] Loop
SNDI.2:	POP	P,T2		;[CSM3] Put updated byte pointer in T2
	POPJ	P,		;[CSM3]

;Routine to output a character in image mode with even parity
			;THE FOLLOWING COMES FROM 5.04 UUOCON(PEVEN8)
PEVEN8:	MOVEI	T2,(CH)		;[CSM3] MAKE A COPY OF BYTE
	LSH	T2,-4		;FOLD INTO LOW 4 BITS
	XORI	T2,(CH)		; ..
	TRCE	T2,14		;CHECK BITS
	TRNN	T2,14		; 32 AND 33
	TRC	CH,200		;IF EVEN, COMPLIMENT RESULT
	TRCE	T2,3		;CHECK BITS
	TRNN	T2,3		; 34 AND 35
	TRC	CH,200		;IF EVEN, COMPLEMENT RESULT
	IONEOU	CH		;SEND OUT VIA IMAGE MODE
	POPJ	P,		;[CSM3]
SUBTTL	LUUO HANDLER
;IT SCRATCHES OC AND PRESERVES ALL OTHERS

LUUO:	MOVE	OC,.JBUUO	;GET UUO
	TLNE	OC,(Z 1,0)	;AC1 ON IN LUUO
	POP	P,(P)		;YES, REMOVE CALL
	TLNE	OC,(Z 2,0)	;[CSM3] AC2 on in LUUO?
	 PUSH	P,[TTYPBF]	;[CSM3] Yes, dump buffer afterwords
	LSH	OC,-^D27	;ISOLATE OPCODE
	CAIN	OC,1		;IS IT TTYCHR
	JRST	$TTOUT		;YES--GO PROCESS IT
	CAIN	OC,2		;TTYSTR?
	JRST	$TTSTR		;YES
	CAIN	OC,3		;CTYSTR?
	JRST	$CTSTR		;YES
	CAIN	OC,4		;CTYCHR?
	JRST	$CTCHR		;YES
	OUTSTR	[ASCIZ\? Illegal LUUO\]  ;OOPS
	EXIT			;DIE
;HERE ON A TTYSTR LUUO

$TTSTR:	MOVSI	OC,(POINT 7,)	;SETUP BYTE POINTER
	HLLM	OC,.JBUUO	; IN LOW CORE
TTSTR2:	ILDB	OC,.JBUUO	;GET A BYTE
	JUMPE	OC,CPOPJ	;RETURN ON NULL
	PUSHJ	P,TTCHR1	;TYPE IT
	JRST	TTSTR2		;LOOP OVER STRING

;HERE ON A TTYCHR LUUO
;WARNING--THIS IS IMMEDIATE MODE, UNLIKE OUTCHR

$TTOUT:	HRRZ	OC,.JBUUO	;GET THE BYTE
TTCHR1:	SOSG	TTYCNT		;COUNT DOWN SPACE IN BUFFER
	PUSHJ	P,TTYPBF	;WRITE THE DATA
	IDPB	OC,TTYPNT	;STORE THE BYTE
	AOS	CHRSOU		;COUNT CHARACTERS FOR TYPTTY
	POPJ	P,		;RETURN

;SUBROUTINE TO DUMP THE TTY OUTPUT BUFFER
TTYPBF:	OUT	TTY,		;DO THE OUTPUT
	  POPJ	P,		;ALL IS OK
	STATZ	TTY,IO.ERR	;ANY ERRORS?
	JRST	LOGO1$		;YES--SEEMS SORT OF BAD
	PUSH	P,T1		;SAVE AN AC
	PUSH	P,[EXP ^D10]	;NUMBER OF MINUTES TO WAIT
TTYP.1:	MOVE	T1,[HB.RIO+^D6000]
	HIBER	T1,
	  JRST	LOGO1$		;MUST WORK
	OUT	TTY,		;TRY AGAIN
	  JRST	TTYP.2		;WE ARE DONE
	SOSLE	(P)		;KEEP WAITING
	JRST	TTYP.1		;YES--WAIT
	CLRBFO			;NO--BOMB OUT
	JRST	LOGO1$		;GO LOGOUT
TTYP.2:	POP	P,T1
	POP	P,T1
	POPJ	P,
;HERE FOR CTYSTR (OUTSTR TO THE CTY)

$CTSTR:	PUSH	P,T2		;NEED
	PUSH	P,T3		; SOME
	PUSH	P,T4		;  ACS
	HRRZ	T4,.JBUUO	;ADDRESS OF ASCIZ STRING
	MOVE	T3,CTYNUM	;UDX FOR CTY
	MOVEI	T2,.TOOUS	;OUTPUT STRING FUNCTION
	MOVE	OC,[3,,T2]	;TRMOP. ARG POINTER TO
	TRMOP.	OC,		;OUTPUT ASCIZ STRING TO THE CTY
	 JFCL			;OH WELL
	POP	P,T4		;  RESTORE
	POP	P,T3		; USED
	POP	P,T2		;ACS
	POPJ	P,		;RETURN TO CALLER


;HERE FOR CTYCHR LUUO

$CTCHR:	PUSH	P,T2		;NEED
	PUSH	P,T3		; SOME
	PUSH	P,T4		;  ACS
	HRRZ	T4,.JBUUO	;GET CHARACTER TO SEND
	ANDI	T4,177		;AND ONLY THE CHARACTER
	HRRZ	T3,CTYNUM	;UDX FOR THE CTY
	MOVEI	T2,.TOOUC	;SEND CHARACTER FUNCTION
	MOVE	OC,[3,,T2]	;TRMOP. ARG BLOCK TO
	TRMOP.	OC,		;OUTPUT SINGLE CHARACTER TO THE CTY
	 JFCL			;HOHUM
	POP	P,T4		;  RESTORE
	POP	P,T3		; THE
	POP	P,T2		;ACS
	POPJ	P,		;RETURN TO CALLER
SUBTTL	GTNTN. ROUTINE

; SUBROUTINE TO GET NODE,,LINE# FOR DEVICE SPECIFIED IN T1 IN T1

GTNTN$:	GTNTN.	T1,0		; TRY DIRECTLY
	SKIPA			; NOW THE HARD WAY
	POPJ	P,0		; RETURN
	PUSH	P,T1		; SAVE DEVICE NAME
	IONDX.	T1,0		; GET THE LINE # + 200000
	  SETZ	T1,0		; NICE TRY
	TXZ	T1,.UXTRM	; CLEAR BIT 1
	EXCH	T1,(P)		; GET DEVICE AGAIN IN T1
	WHERE	T1,0		; GET THE NODE NUMBER
	  SETZ	T1,0		; NICE TRY
	HRLM	T1,(P)
	POP	P,T1
	POPJ	P,0		; RETURN
	SUBTTL	NDNAM TURN A NODE SPEC INTO A NODE NAME

;NDNAM  --  TRY TO MAKE A NAME OUT OF A NODE SPECIFIER
;CALL IS:
;
;	MOVX	T3,<NODE>
;	PUSHJ	P,NDNAM
;	RETURN
;
;WHERE <NODE> IS SIXBIT NODE NAME, SIXBIT NODE NUMBER, OR OCTAL NODE NUMBER.
;
;ON RETURN T1 WILL HAVE THE NODE NAME IF <NODE> IS MEANINGFUL, OTHERWISE
;T1 WILL HAVE <NODE>, ASSUMING WHOEVER WANTS TO USE IT WILL BE BETTER
;SITUATED TO COMPLAIN ABOUT NO SUCH NODE. T2 WILL HAVE THE NODE NUMBER
;ASSOCIATED WITH THE NAME IN T1, IF ANY.

NDNAM::	PUSH	P,T3		;SAVE INPUT
	CAMN	T3,MYNNAM	;LOCAL (KNOWN) NAME?
	JRST	NDNAM5		;YES, THEN ALL SET
	TLNN	T3,770000	;SIXBIT OF SOME SORT?
	JRST	NDNAM3		;NO, MUST BE OCTAL NODE NUMBER
	MOVE	T1,[.NDRNN,,T2]	;YES, MAY BE SIXBIT NODE NUMBER
	MOVEI	T2,2		;SO ASK MONITOR FOR OCTAL NODE NUMBER
	NODE.	T1,		;SINCE WE CAN'T TELL THE DIFFERENCE
	 JRST	NDNAM5		;JUNK, PRESERVE INPUT
	MOVE	T3,T1		;SET UP NODE NUMBER
NDNAM3:	MOVE	T1,[.NDRNN,,T2]	;ARG POINTER
	MOVEI	T2,2		;AND ARG BLOCK LENGTH
	NODE.	T1,		;TO READ NODE NAME GIVEN NODE NUMBER
NDNAM5:	 MOVE	T1,0(P)		;NO SUCH NODE, RETURN INPUT SPECIFIER
	PUSH	P,T1		;SAVE NODE NAME
	MOVE	T3,T1		;POSITION NAME IN T3
	MOVE	T1,[.NDRNN,,T2]	;ARG POINTER
	MOVEI	T2,2		;AND ARG BLOCK LENGTH
	NODE.	T1,		;TO READ NODE NUMBER FOR NAME
	 SETO	T1,		;NONE KNOWN
	MOVE	T2,T1		;RETURN NODE NUMBER IN T2
	POP	P,T1		;AND NODE NAME IN T1
	POP	P,T3		;ADJUST STACK
	POPJ	P,		;AND RETURN
SUBTTL	STORAGE AREA

;STORAGE AREA

	XLIST	;LITERALS
	LIT
	LIST

CRLFM:	ASCIZ	/
/


;TABLES SHARED AMONG ALL COPIES OF INITIA
LOCKWD:	EXP	-1		;INTERLOCK FOR HISEG
LOKJOB:	BLOCK	1		;JOB # THAT HAS INTERLOCK
LOKTTY:	BLOCK	1		;ABOVE JOB'S TTY LINE
FRCTRY:	BLOCK	1		;NUMBER OF TIMES WE GOT TO FORCE
FRCCNT:	BLOCK	1		;NUMBER OF TIMES THAT WE ACTUALLY FORCED THE LOCK
ITLCNT:	BLOCK	1		;NUMBER OF TIMES WE THOUGHT WE HAD
				;THE HIGH-SEG INTERLOCK BUT WE DIDN'T
CORCNT:	BLOCK	1		;NUMBER OF TIMES THE CORE UUO TO
				;INCREASE THE HIGH-SEG FAILED
JOBWAT:	BLOCK	<^D512+^D35>/^D36 ;BIT TABLE FOR JOBS WAITING FOR THE INTERLOCK
JBWATL==.-JOBWAT		;NUMBER OF ENTRIES IN THE TABLE

HIPTR:	POINT	7,0		;BYTE POINTER TO TEXT STORAGE
HS$DEV:	BLOCK	N$HSGF		;DEVICE NAMES
HS$FIL:	BLOCK	N$HSGF		;FILE NAMES
HS$EXT:	BLOCK	N$HSGF		;EXTENSIONS
HS$PPN:	BLOCK	N$HSGF		;PPN'S
HS$PTR:	BLOCK	N$HSGF		;BYTE POINTER TO CONTENTS OF
				; THE FILE.  IF THIS WORD IS 0
				; THE FILE DOES NOT EXIST
	SUBTTL	IMPURE DATA

	RELOC

ZER:!			;START OF AREA TO ZERO ON RESTART
PDL:	BLOCK	L$PDL+1	;PUSH-DOWN LIST
GETCH:	BLOCK	1	;ADDRESS OF TTY INPUT ROUTINE IF ANY
REEAT:	BLOCK	1	;CHARACTER TO REEAT
FILICH:	BLOCK	1	;REUSABLE CHARACTER IN STRIPPER
JUMPPR:	BLOCK	1	;ADDRESS OF SPECIAL STARTUP ROUTINE
SYSPPN:	BLOCK	1	;PPN OF SYS:
MYPPN:	BLOCK	1	;PPN OF THIS JOB
TERNUM:	BLOCK	1	;INDEX OF THIS TTY
MYNNAM:	BLOCK	1	;SIXBIT NODE NAME
MYNNUM:	BLOCK	1	;SIXBIT NODE NUMBER
JOBN:	BLOCK	1	;OUR JOB NUMBER
MYBIT:	BLOCK	1	;BIT FOR THIS JOB IN JOBWAT TABLE
MYWRD:	BLOCK	1	;ADDRESS OF THE WORD CONTAING THE BIT
MYSPD:	BLOCK	1	;MY RECEIVE SPEED AS DETECTED
FFAPPN:	BLOCK	1	;PPN OF [1,2]
REQPPN:	BLOCK	1	;REQUESTED PPN
; SYMBOLIC LOCATIONS OF THE FORM "NL.???" STORE VALUES IN THE FORM
; XWD NODE,LINE
NL.CTY:	BLOCK	1	; CENTRAL STATION (CTY)
NL.OPR:	BLOCK	1	; CENTRAL OPR
NL.LOP:	BLOCK	1	; OUR LOCAL OPR
NL.ME:	BLOCK	1	; OUR LOCATION
CTYTTY:	BLOCK	1	; SIXBIT TTY NAME FOR CTY
CTYNUM:	BLOCK	1	;UDX FOR CTY
FLNNUM:	BLOCK	1	;UDX FOR FRCLIN
APRSN:	BLOCK	1	;APR SERIAL NUMBER
IBF:	BLOCK	3	;BUFFER HEADER BLOCK
RUNBLK:	BLOCK	6	;RUN UUO PARAMETERS
INTBLK:	BLOCK	4	;INTERCEPT BLOCK
TEMP1:	BLOCK	1	; TEMPORARY STORAGE FOR INTERCEPT
NOINT:	BLOCK	1	; IF NEGATIVE DON'T INTERRUPT
SAVEF:	BLOCK	1	;PLACE TO HOLD F
FLKSYS:	BLOCK	1	;FLAG TO TYPE KSYS TIME
FLNAME:	BLOCK	1	;FLAG NONAME (SUPPRESS HEADER LINE)
FLSET:	BLOCK	1	;FLAG NOSETTTY (SUPRESS TTY SETUP)
FLSTR:	BLOCK	1	;FLAG TO DO STRUCTURE NOTES
FLTEXT:	BLOCK	1	;FLAG TO PRINT TEXT MSG
FLNOTC:	BLOCK	1	;FLAG TO TYPE NOTICE.TXT
FLTTY:	BLOCK	1	;FLAG TO TYPE TTY SETTINGS
DIAL:	BLOCK	2	;NUMBER TO DIAL
LOCAT:	BLOCK	1	; LOCATE USER
NODBLK:			;START OF NODE. UUO ARGUMENT BLOCK
NODLEN:	BLOCK	1	;LENGTH OF NODE UUO ARGUMENT BLOCK
NODLOC:	BLOCK	1	;NODE NUMBER
	BLOCK	1	;RESERVED ARGUMENT
NODDEV:	BLOCK	1	;NUMBER OF DEVICES,,DEVICE TYPE
FILCWT:	BLOCK	1	;SLEEP COUNTER IN FILCON
;TTY PARAMETERS

ALT:	BLOCK	1	;TTY ALT
BLANK:	BLOCK	1	;TTY BLANK
CRLF:	BLOCK	1	;TTY CRLF
DEBR:	BLOCK	1	;TTY DEBREAK
DISP:	BLOCK	1	;TTY DISPLAY
ECHO:	BLOCK	1	;TTY ECHO
ECHDEF:	BLOCK	1	;TTY DEFER
ELEM:	BLOCK	1	;TTY ELEMENT
FILL:	BLOCK	1	;TTY FILL
FORM:	BLOCK	1	;TTY FORM
GAG:	BLOCK	1	;TTY GAG
HDX:	BLOCK	1	;TTY HDX
LC:	BLOCK	1	;TTY LC
LENGTH:	BLOCK	1	;TTY LENGTH
PAGEON:	BLOCK	1	;TTY PAGE
PAGE:	BLOCK	1	;TTY PAGE:N
RCV:	BLOCK	1	;TTY RCVSPEED
REM:	BLOCK	1	;TTY REMOTE
RTCOMP:	BLOCK	1	;TTY RTCOMP
SBELL:	BLOCK	1	;TTY SBELL (RING BELL ON AUTO-STOP)
SLAVE:	BLOCK	1	;TTY SLAVE
SSIZE:	BLOCK	1	;TTY STOP N (THE "N" OF STOP EVERY N LINES)
SSTOP:	BLOCK	1	;TTY SSTOP
STOP:	BLOCK	1	;TTY STOP
TAB:	BLOCK	1	;TTY TAB
TAPE:	BLOCK	1	;TTY TAPE
TIDY:	BLOCK	1	;TTY TIDY
TYPE:	BLOCK	1	;TTY TYPE
WIDTH:	BLOCK	1	;TTY WIDTH
XMT:	BLOCK	1	;TTY XMTSPEED
XONXOF:	BLOCK	1	;TTY XONXOF
LOWPTR:	BLOCK	1	;POINTER TO HISEG TEXT
CHRSOU:	BLOCK	1	;COUNT OF CHARACTERS OUTPUT FOR TYPTTY
TTYOBF:	BLOCK	1	;TTY OUTPUT RING HEADER
TTYPNT:	BLOCK	1	;TTY OUTPUT BYTE POINTER
TTYCNT:	BLOCK	1	;TTY OUTPUT BYTE COUNT
TTYBUF:	BLOCK	L$TTBF+3 ;SIZE OF OUTPUT BUFFER

FLNCNT:	BLOCK	1	;BYTE COUNTER FOR TYPER
FLNPNT:	BLOCK	1	;BYTE POINTER FOR TYPER
FLNBUF:	BLOCK	<FLN$MX+4>/5	;BYTE BUFFER FOR TYPER

GETSTR:	BLOCK	5	;ARGUMENT BLOCK FOR GOBSTR UUO
STRBLK:	BLOCK	1+3*N$STRS	;ARGUMENT BLOCK FOR STRUUO
ENDSTR==.

TTWFLG:	BLOCK	1	;FLAG THAT WE WILL/ARE STOMP/ING
TTWNRI:	BLOCK	1	;TOTAL CHARACTER COUNT
TTWNTM:	BLOCK	1	;LAST TIMER
TTWPCT:	BLOCK	1	;POINTER (INDEXES T7) TO LINE-DEPENDENT CHAR COUNT
TTWPTM:	BLOCK	1	;POINTER (INDEXES T7) TO PARALLEL TIME OF LAST SAMPLE
TTWPRS:	BLOCK	1	;POINTER (INDEXES T7) TO CHANNEL,,.TORSP
LINTAB:	BLOCK	1	;POINTER (INDEXES T7) TO ENTRY IN MAPPED LINTAB
TTWMCN:	BLOCK	1	;HIGHEST CHANNEL WE ARE USING.
LDBOFF:	BLOCK	1	;OFFSET FROM MONITOR LDB ADDR TO USER LDB ADDR.
ASKID:	BLOCK	1	;[CSM3] Default if terminal does not identify itself
TRMDSC:	BLOCK	1	;[CSM3] Pointer to ASCIZ description of terminal
BLOAD:	BLOCK	1	;[CSM4] Name of binary load file (SYS:xxx.BIN)
SETUP:	BLOCK	1	;[CSM4] Name of ASCII setup file (SYS:xxx.TTY)
TXTBUF:	BLOCK <TXTMAX/5>+1;[CSM2] Buffer for .TOTYP TRMOP.
NOTEXT:	BLOCK	1	;[CSM6] Extension for SYS:NOTICE.T??

EZER:	BLOCK	0	;LAST LOCATION, GETS ZEROED

	END	INITIA
      *@z