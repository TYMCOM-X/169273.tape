entry Sysno, Syswhere, !VerMaj, !VerMin, !VerEds, !VerDat,
      Cv.PPN, Cv.UFDStr, Cv.Username, Delete.Tmpcore.File, Do.Banner,
      File.Exists, Get.AUN, Get.Gfd.PPN, GetTab, Gfd.User.Name, GtChan,
      Is.Aux.Ckt, Is.Valid.PPN, Is.Wild.Spec, Logged.In.User.Name,
      Parse.Filespec, Read.Tmpcore.File, RescanCommandLine, Restore.Echo,
      Run.Pgm, Set.Version, Suppress.Echo, Tmpcore.File.Exists,
      Write.Tmpcore.File ;

define !  = "comment", !! = "comment";
!! title Module Sys ;
! *************************************************************************
*************************************+*************************************
*                                                                         *
*                                                                         *
*                                   Sys                                   *
*                                                                         *
*                                                                         *
*************************************+*************************************


        A handy collection of tools which rely in one way or another
        on the Tymcom-X operating system for their magic.


*************************************+*************************************

         !version(!ver('1, '0), !edit('55), !date(2-July-1986))

  edit history
     2-Jul-86   v1.0(54)  kmd   Change all open calls to use a new
                                getchan equivalent routine.  This does
                                not conflict with Carl's VMFILE
                                routines, and uses a more enlightened
                                approach to channel allocation.
    26-Jun-86   v1.0(53)  kmd   Add tmpcore routines.
    16-Jun-86   v1.0(52)  kmd   Rename 'Run' to 'Run.Pgm' to avoid
                                possible conflicts with SAIL runtimes.
                                Add symbols to lowlevel calls wherever
                                possible.
    16-Apr-86   v1.0(51)  kmd   Add Is.Wild.Spec and Is.Valid.PPN
    26-Mar-86   v1.0(50)  kmd   Split off from Util.Sai and merged
                                with version stuff from
                                Sys.Da.


**************************************************************************;


begin "Sys"
  require "(klib)sail.hdr" source!file;
  require "(klib)sys.req"  source!file;
  require "(klib)date.req" source!file;
  require "(klib)time.req" source!file;

  internal integer
    !VerEds,
    !VerMaj,
    !VerMin,
    Sysno;                              ! Current Host number;

  internal string
    !VerDat,
    Syswhere;                           ! Current Host Loacation Code;


! ************************************************************************;
!! title Rtn Cv.PPN ;
! =========================================================================
====================================+======================================
=                                                                         =
=                                                                         =
=                               Rtn Cv.PPN                                =
=                                                                         =
=                                                                         =
====================================+======================================


	Convert a PPN to a username.


==========================================================================;


  internal simple string procedure Cv.PPN (integer PPN);
  begin "Cv.PPN"
    integer
      Chan,
      Eof;
    own integer array
      LkB [0 : '30];

    arrclr(LkB);
    LkB[0] _ ub.rows(LkB);
    LkB[1] _ GetTab(0, !gtlvd);
    LkB[2] _ PPN;
    LkB[3] _ cvsix("UFD");

    open(Chan _ GtChan, "DSK", $F.DUMP, 0, 0, 0, 0, Eof);

    if (Eof) then
      return(false);

    chnior(Chan, LkB[0], !chlk);
      ! <<  We should check for error on lookup here (??)
      ;
    release(Chan);
    return(cv6str(LkB['27]) & cv6str(LkB['30]));
  end "Cv.PPN";


! ==================================+======================================
==========================================================================;
!! title Rtn Cv.UFDStr ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=                              Rtn Cv.UFDStr                              =
=                                                                         =
=                                                                         =
=====================================+=====================================

    Convert a UFD specification in the form of either "(Username)" or
    "[Gan,Uun]" to the corresponding PPN and return it.  Return 0 at
    the slightest hint of trouble.

==========================================================================;


  internal simple integer procedure Cv.UFDStr (string Str);
  begin "Cv.UFDStr"
    integer
      C;
    string
      Str1;

    require "{}{}" delimiters;

    define
      IsAlphabetic (X) = {("A" <= UpShift(X) <= "Z")},
      IsNumeric    (X) = {("0" <= X <= "9")},
      Is.Un.Char   (X) = {((IsAlphabetic(C)) or
          (IsNumeric(C)) or
          (C = "*") or (C = ".") or
          (C = "/") or (C = "-") or
          (C = sp))};

    Str1 _ null;
    
    if (Str = "(") then
    begin
      lop(Str);

      while ((C _ lop(Str)) neq ")") do
      begin
        if (not Is.Un.Char(C)) then
          return(0);

        appnd(Str1, C);
      end;

      if (C = ")" and length(Str) = 0) then
        return(Cv.Username(Str1))
      else
        return(0);
    end
    else if (Str = "[") then
    begin
      integer
        Gan,
        Uun;

      lop(Str);
      Gan _ Uun _ 0;

      while ((C _ lop(Str)) neq "]") do
      begin
        if (IsOctal(C)) then
          appnd(Str1, C)
        else if (C = ",") then
        begin
          if (not Gan and 0 < length(Str1) <= 6) then
          begin
            Gan  _ cvo(Str1);
            Str1 _ null;
          end
          else
            return(0);
        end
        else
          return(0);
      end;

      if (C = "]" and length(Str) = 0) then
      begin
        if (Gan) then
        begin
          if (0 < length(Str1) <= 6) then
          begin
            Uun _ cvo(Str1);
            return(xwd(Gan, Uun));
          end
          else
            return(0);
        end
        else if (0 < length(Str1) <= 12) then
          return(cvo(Str1))
        else
          return(0);
      end
      else
        return(0);
    end
    else
      return(0);
    require unstack!delimiters;
  end "Cv.UFDStr";


! ===================================+=====================================
==========================================================================;
!! title Rtn Cv.Username ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=			      Rtn Cv.Username				  =
=                                                                         =
=                                                                         =
=====================================+=====================================


                           Cv.Username(Username)

        Returns the PPN corresponding to the specified username, or 0
        if it cannot be found.


==========================================================================;


  internal simple integer procedure Cv.Username (string Username);
  begin "Cv.Username"
    integer
      Chan,
      Eof;
    own integer array
      Unm [0 : 1],                      ! Sixbit Username (12 characters);
      LkB [0 : 3];			! block for extended lookup;


    Unm[0] _ cvsix(Username[1 for 6]);
    Unm[1] _ cvsix(Username[7 for 6]);

    LkB[0] _ ub.rows(LkB);		! size of LkB;
    LkB[1] _ GetTab(0, !gtlvd); ! MFD PPN;
    LkB[2] _ location(Unm[0]);          ! Addr of SIXBIT user name;
    LkB[3] _ cvsix("UFD");		! extension;

    open(Chan_GtChan, "DSK", $F.DUMP, 0, 0, 0, 0, Eof);

    if (Eof) then
      return(0);                        ! very, very ill;

    chnior(Chan, LkB[0], !chlk);	! lookup UFD to get PPN;
    release(Chan);			! don't need the channel;

    return(if (lh(LkB[2])) then LkB[2] else 0);
  end "Cv.Username";


! ===================================+=====================================
==========================================================================;
!! title Rtn Delete.Tmpcore.File ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=                         Rtn Delete.Tmpcore.File                         =
=                                                                         =
=                                                                         =
=====================================+=====================================


==========================================================================;


  internal simple procedure Delete.Tmpcore.File (string Fn);
  begin "Delete.Tmpcore.File"
    integer
      Flag;

    tmpin(Fn, Flag);

    if (Flag) then
    begin
      ! No tmpcore file - try to delete the disk file.
      ;

      integer
        Ch;
      string
        Fn2;

      open(Ch _ GtChan, "DSK", $F.DUMP, 0, 0, 0, 0, Flag _ -1);
      
      if (Flag) then
        return;

      Fn2 _ cvs(1000 + calli(0, calli!pjob))[2 for 3] & Fn & ".TMP";
      lookup(Ch, Fn2, Flag);

      if (not Flag) then
        rename(Ch, 0, 0, Flag);

      release(Ch);
    end
    else
    begin
      own integer array
        Blk [0 : 1];

      Blk[0] _ cvsix(Fn[1 for 3]);
      Blk[1] _ 0;
      calli(xwd(!tcrdf, location(Blk[0])), calli!tmpcor);
    end;
  end "Delete.Tmpcore.File";


! ===================================+=====================================
==========================================================================;
!! title Rtn Do.Banner ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=                              Rtn Do.Banner                              =
=                                                                         =
=                                                                         =
=====================================+=====================================


==========================================================================;


  internal simple procedure Do.Banner (string Str; boolean Debug(false));
  begin "Do.Banner"
    print(crlf, Str, crlf, "[",
        if (Debug) then
          "Debugging "
        else
          null
        ,

        "Version ", cvos(!VerMaj), ".", cvos(!VerMin), " (",
            cvos(!VerEds), ") ",
        !VerDat, "]", crlf,
        Syswhere, Sysno,
        " ", CvS.Date(Get.Date),
        " ", CvS.Time(Get.Time), crlf
    );
  end "Do.Banner";


! ===================================+=====================================
==========================================================================;
!! title Rtn File.Exists ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=                             Rtn File.Exists                             =
=                                                                         =
=                                                                         =
=====================================+=====================================

    Check for the presence of the named file, and say "no" (rather
    cryptically) at the slightest hint of trouble.

==========================================================================;


  internal simple boolean procedure File.Exists (string Fs);
  begin "File.Exists"
    string
      Tmp;

    if (not Parse.Filespec(Fs, Tmp, Tmp, Tmp, Tmp)) then
      return(false)
    else
    begin
      integer
        Ch,
        Eof;

      open((Ch _ GtChan), "DSK", $F.DUMP, 0, 0, 0, 0, Eof _ -1);

      if (Eof) then
        return(false);

      lookup(Ch, Fs, Eof);
      release(Ch);
      return(Eof = 0);
    end;
  end "File.Exists";


! ===================================+=====================================
==========================================================================;
!! title Rtn Get.AUN ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=                               Rtn Get.AUN                               =
=                                                                         =
=                                                                         =
=====================================+=====================================


==========================================================================;


  internal simple integer procedure Get.AUN;
  begin "Get.AUN"
    return(GetTab(-1, !gtaun));
  end "Get.AUN";


! ===================================+=====================================
==========================================================================;
!! title Rtn Get.Gfd.PPN ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=                             Rtn Get.Gfd.PPN                             =
=                                                                         =
=                                                                         =
=====================================+=====================================


==========================================================================;


  internal simple integer procedure Get.Gfd.PPN;
  begin "Get.Gfd.PPN"
    return(GetTab(-1, !gtppn));
  end "Get.Gfd.PPN";


! ===================================+=====================================
==========================================================================;
!! title Rtn GetTab ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=				Rtn GetTab				  =
=                                                                         =
=                                                                         =
=====================================+=====================================


==========================================================================;


  internal simple integer procedure GetTab (integer Index, Table);
  begin "GetTab"
    start!code
      move	1, Table;
      hrl	1, Index;
      setom	!skip!;
      calli	1, calli!gettab;
       setzm	!skip!;
    end;
  end "GetTab";


! ===================================+=====================================
==========================================================================;
!! title Rtn Gfd.User.Name ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=			     Rtn Gfd.User.Name				  =
=                                                                         =
=                                                                         =
=====================================+=====================================


==========================================================================;


  internal simple string procedure Gfd.User.Name;
  begin "Gfd.User.Name"
    own integer array
      LkB [0:30];
    own integer
      Chan;


    LkB[0] _ ub.rows(LkB);
    LkB[1] _ xwd(1, 1);
    LkB[3] _ cvsix("UFD");
    LkB[2] _ GetTab(-1, !gtppn);

    open(Chan _ GtChan, "DSK", $F.DUMP, 0, 0, 0, 0, 0);
    chnior(Chan, LkB[0], !chlk);

    release(Chan);
    return(cv6str(LkB['27]) & cv6str(LkB['30]));
  end "Gfd.User.Name";


! ===================================+=====================================
==========================================================================;
!! title Rtn GtChan ;
! =========================================================================
=====================================+=====================================
=                                                                    =
=                                                                         =
=                               Rtn GtChan                                =
=                                                                         =
=                                                                         =
=====================================+=====================================

        Get the next availible channel.  Returns -1 if none availible.

==========================================================================;


  internal simple integer procedure GtChan;
  begin "GtChan"
    start!code
      define
        R1          = 1,
        R3          = 3;
      label
        X;

        movei           R1, R3;
        hrloi           R3, !chnxt;
        uuo!chanio      R3,;
          jrst          X;
        hrrzm           R3, R1;
        skipa           ;

      X:
        seto            R1,;
    end;
  end "GtChan";


! ===================================+=====================================
==========================================================================;
!! title Rtn Init.Sys.Stuff ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=			    Rtn Init.Sys.Stuff				  =
=                                                                         =
=                                                                         =
=====================================+=====================================


==========================================================================;


  simple procedure Init.Sys.Stuff;
  begin "Init.Sys.Stuff"
    string
      Tmp;

    Tmp      _ cvastr(calli(!gtcnf, calli!gettab));
    Sysno    _ cvd(Tmp[2 to inf]);
    Syswhere _ Tmp[1 for 1];
  end "Init.Sys.Stuff";
  require Init.Sys.Stuff initialization[0];


! ===================================+=====================================
==========================================================================;
!! title Rtn Is.Aux.Ckt ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=                             Rtn Is.Aux.Ckt                              =
=                                                                         =
=                                                                         =
=====================================+=====================================


        Return an indication of whether the specified port is attached
        to an auxiliary circuit.


==========================================================================;


  internal simple boolean procedure Is.Aux.Ckt (integer Port (-1));
  begin "Is.Aux.Ckt"
    integer
      Tmp;

    Tmp _ GetTab(Port, !gtlog);
    
    return((not (bit('17,11) land Tmp)) and ((bit('77,27) land Tmp) or 
        (bit('77,19) land Tmp)));
  end "Is.Aux.Ckt";


! ===================================+=====================================
==========================================================================;
!! title Rtn Is.Valid.PPN ;
! =========================================================================
====================================+======================================
=                                                                         =
=                                                                         =
=                            Rtn Is.Valid.PPN                             =
=                                                                         =
=                                                                         =
====================================+======================================

    Determine whether a given PPN is valid.

==========================================================================;


  internal simple boolean procedure Is.Valid.PPN (integer PPN);
  begin "Is.Valid.PPN"
    integer
      Chan,
      Eof;
    own integer array
      LkB [0 : '30];

    arrclr(LkB);
    LkB[0] _ ub.rows(LkB);
    LkB[1] _ GetTab(0, !gtlvd);
    LkB[2] _ PPN;
    LkB[3] _ cvsix("UFD");

    open(Chan _ GtChan, "DSK", $F.DUMP, 0, 0, 0, 0, Eof);

    if (Eof) then
      return(null);

    chnior(Chan, LkB[0], !chlk);
    release(Chan);
    return(not Eof);
  end "Is.Valid.PPN";


! ==================================+======================================
==========================================================================;
!! title Rtn Is.Wild.Spec ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=                            Rtn Is.Wild.Spec                             =
=                                                                         =
=                                                                         =
=====================================+=====================================


==========================================================================;


  internal simple boolean procedure Is.Wild.Spec (string Str);
  begin "Is.Wild.Spec"
    integer
      C;
    string
      Tmp,
      Fn,
      Ext;

    if (not Parse.Filespec(Str, Tmp, Fn, Ext, Tmp)) then
      return(false);

    while (C _ lop(Fn)) do
      if (C = "#" or C = "*") then
        return(true);

    while (C _ lop(Ext)) do
      if (C = "#" or C = "*") then
        return(true);

    return(false);
  end "Is.Wild.Spec";


! ===================================+=====================================
==========================================================================;
!! title Rtn Logged.In.User.Name ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=			  Rtn Logged.In.User.Name			  =
=                                                                         =
=                                                                         =
=====================================+=====================================


==========================================================================;


  internal simple string procedure Logged.In.User.Name;
  begin "Logged.In.User.Name"
    return(cv6str(GetTab(-1, !gtunm)) & cv6str(GetTab(-1, !gtun1)));
  end "Logged.In.User.Name";


! ===================================+=====================================
==========================================================================;
!! title Rtn Parse.Filespec ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=                           Rtn Parse.Filespec                            =
=                                                                         =
=                                                                         =
=====================================+=====================================


  Decompose a Tymcom-X Filespec, which must be of the following form:
 
  <FileSpec>	->	(<UserName>)(<FileName>) | (<FileName>)(<PPNSpec>)
  <UserName>	->	'(' repeat(<V1>, 1-12) ')
  <FileName>	->	<FilePart> (<ExtPart>)
  <FilePart>	->	repeat(<V2>, 1-6)
  <ExtPart>	->	'.' (repeat(<V2>, 0-3))
  <PPNSpec>	->	'[' <GanSpec> ',' <UunSpec> ']'
  <GanSpec>	->	repeat(<OctNum>, 1-6)
  <UunSpec>	->	repeat(<OctNum>, 1-6)
  
  <V1>		->	<Alpha> | <DecNum> | '*' | '.' | '/' | '-' | ' '
  <V2>		->	<Alpha> | <DecNum> | '|'
  
  <Alpha>	->	'A' - 'Z' | 'a' - 'z' 
  <DecNum>	->	'0' - '9'
  <OctNum>	->	'0' - '7'
  
  
  (The function repeat(Item, Minimum-Maximum) is replaced by between
  Minimum and Maximum number of occurences of Item.  The special symbol
  '*' indicates no limit.)
 
  The symbol 'ASCII' indicates the entire ASCII character set.
 
  Braces ('{' and '}') enclose set specifications - eg, '{ASCII - '"'}'
  means all characters except '"'.


==========================================================================;


  internal boolean procedure Parse.Filespec (string InStr; reference string UserName, File, Ext, PPN);
  begin "Parse.Filespec"
    require "{}{}" delimiters;
    label
      S0, S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11, S12, S13, SGood, SBad;
    integer
      C;
    string
      LUserName, LFile, LExt, LGanStr, LUunStr;
    define
      sp               = {" "},
      IsAlphabetic (X) = {("A" <= UpShift(X) <= "Z")},
      IsNumeric    (X) = {("0" <= X <= "9")},
      IsOctal      (X) = {("0" <= X <= "7")},
      IsWhiteSpace (X) = {(X = sp or X = ht)},
      IsWild       (X) = {(X = "*" or X = "#" or X = "?")},
      UpShift      (X) = {(X land (lnot bit(30)))};


    LUserName _
    LFile     _
    LExt      _
    LGanStr   _
    LUunStr   _
    UserName  _
    File      _
    Ext       _
    PPN       _ null;


    S0:
        ! Nothing seen - Look for username or filename ;

      C _ lop(InStr);
      if (IsAlphabetic(C)) then goto S4;
      if (IsNumeric(C))    then goto S4;
      if (IsWild(C))       then goto S4;
      if (C = "(") then goto S1;
      if (C = "[") then goto S9;
      goto SBad;


    S1:
        ! "(" Seen - Look for username ;

      if (not length(InStr)) then goto SBad;
      C _ lop(InStr);
      if ((IsAlphabetic(C)) or
          (IsNumeric(C)) or
          (C = "*") or (C = ".") or
          (C = "/") or (C = "-") or
          (C = sp)) then
        goto S2;
      goto SBad;


    S2:
        ! Username character seen - Collect more and look for ")" ;

      appnd(LUserName, ToUpper(C));
      if (not length(InStr)) then goto SBad;
      C _ lop(InStr);
      if ((IsAlphabetic(C)) or
          (IsNumeric(C)) or
          (C = "*") or (C = ".") or
          (C = "/") or (C = "-") or
          (C = sp)) then
        goto S2;
      if (C = ")") then goto S3;
      goto SBad;


    S3:
        ! ")" seen - Skip whitespace and look for filename ;

      if (not (length(InStr) and length(LUserName))) then goto SGood;
      C _ lop(InStr);
      if (IsAlphabetic(C)) then goto S4;
      if (IsNumeric(C))    then goto S4;
      if (IsWild(C))       then goto S4;
      if (IsWhiteSpace(C)) then goto S3;
      goto SBad;


    S4:
        ! Filename character seen - Collect more ;

      appnd(LFile, ToUpper(C));
      if (not length(InStr)) then goto SGood;
      C _ lop(InStr);
      if (IsAlphabetic(C)) then goto S4;
      if (IsNumeric(C))    then goto S4;
      if (IsWild(C))       then goto S4;
      if (C = "|")         then goto S4;
      if (C = ".")         then goto S6;
      if (C = "[")         then goto S9;
      if (IsWhiteSpace(C)) then goto S5;
      goto SBad;


    S5:
        ! Whitespace seen - gobble up more and look for dot ;

      if (not length(InStr)) then goto SGood;
      C _ lop(InStr);
      if (C = ".") then goto S6;
      if (C = "[") then goto S9;
      if (IsWhiteSpace(C)) then goto S5;
      goto SBad;


    S6:
        ! Dot seen - Look for extension ;

      appnd(LExt, C);
      if (not length(InStr)) then goto SGood;
      C _ lop(InStr);
      if (IsAlphabetic(C)) then goto S7;
      if (IsNumeric(C))    then goto S7;
      if (IsWild(C))       then goto S7;
      if (C = "[") then goto S9;
      if (IsWhiteSpace(C)) then goto S6;
      goto SBad;


    S7:
        ! Extension character seen - Look for more ;

      appnd(LExt, ToUpper(C));
      if (not length(InStr)) then goto SGood;
      C _ lop(InStr);
      if (IsAlphabetic(C)) then goto S7;
      if (IsNumeric(C))    then goto S7;
      if (IsWild(C))       then goto S7;
      if (C = "|")         then goto S7;
      if (C = "[") then goto S9;
      if (IsWhiteSpace(C)) then goto S8;
      goto SBad;


    S8:
        ! Whitespace seen - gobble up more ;

      if (not length(InStr)) then goto SGood;
      C _ lop(InStr);
      if (C = "[") then goto S9;
      if (IsWhiteSpace(C)) then goto S8;
      goto SBad;


    S9:
        ! "[" seen - Look for Gan ;

      if (not length(InStr)) then goto SBad;
      C _ lop(InStr);
      if (IsOctal(C)) then goto S10;
      goto SBad;


    S10:
        ! Gan digit seen - Collect more and look for "," ;

      appnd(LGanStr, ToUpper(C));
      if (not length(InStr)) then goto SBad;
      C _ lop(InStr);
      if (IsOctal(C)) then goto S10;
      if (C = ",") then goto S11;
      goto SBad;


    S11:
        ! "," seen - Look for Uun ;

      if (not length(InStr)) then goto SBad;
      C _ lop(InStr);
      if (IsOctal(C)) then goto S12;
      goto SBad;


    S12:
        ! Uun digit seen - Collect more ;

      appnd(LUunStr, ToUpper(C));
      if (not length(InStr)) then goto SBad;
      C _ lop(InStr);
      if (IsOctal(C)) then goto S12;
      if (C = "]")  then goto S13;
      goto SBad;


    S13:
        ! "]" seen ;

      if (not length(InStr)) then goto SGood;
      goto SBad;


    SGood:
        ! Many Happy Returns ;

      if (LFile[inf for 1] = "|" or LExt[inf for 1] = "|") then goto SBad;

        ! <<  This is a shameless hack prepared on the fly to avoid
        !     increasing the number of states involved in the parse. It
        !     should be removed.
        ;

      if (length(LUserName)) then
        UserName _ LUserName[1 for 12]
      else if (length(LGanStr) or length(LUunStr)) then
        PPN _ cvos(xwd(cvo(LGanStr[1 for 6]), cvo(LUunStr[1 for 6])));

      File _ LFile;
      Ext  _ LExt;

        ! We no longer truncate these to proper length, since the use of
        ! wildcards can change the e effective length of these fields.  In a
        ! later implementation, we should compute the real max length and use
        ! it to truncate.
        ;

      return(true);


    SBad:
        ! Oops - something smells funny ;

      UserName _ File _ Ext _ PPN _ null;

      return(false);
    require unstack!delimiters;
  end "Parse.Filespec";

! ===================================+=====================================
==========================================================================;
!! title Rtn Read.Tmpcore.File ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=                          Rtn Read.Tmpcore.File                          =
=                                                                         =
=                                                                         =
=====================================+=====================================


==========================================================================;


  internal simple string procedure Read.Tmpcore.File (string Fn);
  begin "Read.Tmpcore.File"
    integer
      Flag;
    string
      Str;

    Str _ tmpin(Fn, Flag);

    if (Flag) then
    begin
      integer
        Ch;
      string
        Fn2;

      Str _ null;
      open(Ch _ GtChan, "DSK", $F.ASCII, 4, 0, 0, 0, Flag _ -1);
      
      if (Flag) then
        return(Str);

      Fn2 _ cvs(1000 + calli(0, calli!pjob))[2 for 3] & Fn & ".TMP";
      lookup(Ch, Fn2, Flag);

      if (not Flag) then
      begin
        do
        begin
          appnd(Str, input(Ch, 0));
        end until (Flag);
      end;

      release(Ch);
    end;

    return(Str);
  end "Read.Tmpcore.File";


! ===================================+=====================================
==========================================================================;
!! title Rtn RescanCommandLine ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=                             Rtn RescanCommandLine                       =
=                                                                         =
=                                                                         =
=====================================+=====================================


        Rescan the command line.  Return the line, or null if none
        available.  (This can only be done once successfully.)

        <see (wrs:39)argpar.sai for more elaborate treatment.>


==========================================================================;


  internal simple string procedure RescanCommandLine;
  begin "RescanCommandLine"
    integer
      Flag;

    start!code
      setob     1, Flag;
      ttcall    6, 1;                   ! getlch 1 ;
      tlnn      1, '100000;             ! lc.ecs - command lines exists ;
        setzm   Flag;
    end;

    if (not Flag) then
      return(null);

    start!code
      ttcall      '10,;		        ! rescan ;
    end;

    return(inchwl);
  end "RescanCommandLine";


! ===================================+=====================================
==========================================================================;
!! title Rtn Restore.Echo ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=			     Rtn Restore.Echo				  =
=                                                                         =
=                                                                         =
=====================================+=====================================


	Restore echo-on-input to the terminal.


==========================================================================;


  internal simple procedure Restore.Echo;
  begin "Restore.Echo"
    start!code
      hrroi	1, !axcfs;
      auxcal	1, 0;
    end;
  end "Restore.Echo";


! ===================================+=====================================
==========================================================================;
!! title Rtn Run.Pgm ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=                               Rtn Run.Pgm                               =
=                                                                         =
=                                                                         =
=====================================+=====================================


	Run.Pgm(program,[start])

	Run another program (overlay).  Program name may contain
	user name and program name, no device.


==========================================================================;


  internal simple procedure Run.Pgm (string File; integer Def(0), Start(0));
  begin "Run.Pgm"
    integer
      PPN;
    own integer array
      RnB[0 : 5];
    string
      Usr,
      Fn,
      Ext,
      PPNStr;

    if (Parse.Filespec(File, Usr, Fn, Ext, PPNStr)) then
    begin
      if (length(Usr)) then
        PPN _ Cv.Username(Usr)
      else if (length(PPNStr)) then
        PPN _ cvo(PPNStr)
      else
        PPN _ Def;

      if (length(Ext)) then
        Ext _ Ext[2 to inf];

      RnB[0] _ cvsix("DSK");
      RnB[1] _ cvsix(Fn);
      RnB[2] _ cvsix(Ext);
      RnB[3] _ 0;
      RnB[4] _ PPN;
      RnB[5] _ 0;
      calli(xwd(Start, location(RnB[0])), calli!run);
    end;
  end "Run.Pgm";


! ===================================+=====================================
==========================================================================;
!! title Rtn Set.Version ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=                             Rtn Set.Version                             =
=                                                                         =
=                                                                         =
=====================================+=====================================


==========================================================================;


  internal simple procedure Set.Version (integer X, Y; string Z);
  begin "Set.Version"
    !VerMaj _ ((X) lsh -9);
    !VerMin _ ((X) land '000777);
    !VerEds _ ((Y) land '777777);
    !VerDat _ Z;
end "Set.Version";


! ===================================+=====================================
==========================================================================;
!! title Rtn Suppress.Echo ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=			     Rtn Suppress.Echo				  =
=                                                                         =
=                                                                         =
=====================================+=====================================


	Suppress echo-on-input to the terminal.


==========================================================================;


  internal simple procedure Suppress.Echo;
  begin "Suppress.Echo"
    start!code
      hrroi	1, !axcfs;
      auxcal	1, io!nec;
    end;
  end "Suppress.Echo";


! ===================================+=====================================
==========================================================================;
!! title Rtn Tmpcore.File.Exists ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=                         Rtn Tmpcore.File.Exists                         =
=                                                                         =
=                                                                         =
=====================================+=====================================


==========================================================================;


  internal simple boolean procedure Tmpcore.File.Exists (string Fn);
  begin "Tmpcore.File.Exists"
    integer
      Flag;

    tmpin(Fn, Flag);

    if (Flag) then
    begin
      string
        Fn2;

      Fn2 _ cvs(1000 + calli(0, calli!pjob))[2 for 3] & Fn & ".TMP";
      return(File.Exists(Fn2));
    end;

    return(true);
  end "Tmpcore.File.Exists";


! ===================================+=====================================
==========================================================================;
!! title Rtn Write.Tmpcore.File ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=                         Rtn Write.Tmpcore.File                          =
=                                                                         =
=                                                                         =
=====================================+=====================================


==========================================================================;


  internal simple procedure Write.Tmpcore.File (string Fn, Str);
  begin "Write.Tmpcore.File"
    integer
      Flag;

    tmpout(Fn, Str, Flag);

    if (Flag) then
    begin
      integer
        Ch;
      string
        Fn2;

      Delete.Tmpcore.File(Fn);
      open(Ch _ GtChan, "DSK", $F.ASCII, 0, 4, 0, 0, Flag _ -1);
      
      if (Flag) then
        return;

      Fn2 _ cvs(1000 + calli(0, calli!pjob))[2 for 3] & Fn & ".TMP";
      enter(Ch, Fn2, Flag);

      if (not Flag) then
        cprint(Ch, Str);

      release(Ch);
    end;
  end "Write.Tmpcore.File";


! ===================================+=====================================
==========================================================================;

end "Sys";


! ***********************************+*************************************
**************************************************************************;
    (