MODULE SAVE(STACK(0),SREG=#17,FREG=#16,VREG=#15,BREG=#14)=
BEGIN

%
VERSION 1, 22 JANUARY 1975, WRITTEN BY MIKE GEARY

THIS MODULE IS THE PART OF THE LOADER WHICH PRODUCES A "SAVE-FILE" (A FILE
WITH EXTENSION .SAV OR .LOW CONTAINING A ZERO-COMPRESSED LOW SEGMENT
AND A FILE WITH EXTENSION .HGH OR .SHR CONTAINING A HIGH SEGMENT).
THE ROUTINE LODSAV IS CALLED AT THE END OF LOADING TO WRITE THE FILES.  THESE
FILES ARE ESSENTIALLY THE SAME AS WRITTEN BY THE MONITOR SAVE AND SSAVE
COMMANDS, AND THEIR FORMAT IS DESCRIBED IN THE DECSYSTEM10 USER'S HANDBOOK.
%

!JOBDAT LOCATIONS

GLOBAL BIND JOB41=#41, JOBREL=#44, JOBDDT=#74, JOBSV=#76, JOBSDD=#114,
  JOBHRL=#115, JOBSA=#120, JOBS41=#122, JOBREN=#124, JOBCOR=#133,
  JOBVER=#137, JOBDA=#140;

BIND JOBHSA=0, JOBH41=1, JOBHCR=2, JOBHRN=3, JOBHVR=4, JOBHX1=5,
  JOBHSM=6, JOBHX2=7;

!LEFT AND RIGHT HALFWORD POINTERS

MACRO LH=18,18$, RH=0,18$;

!ARY IS USED FOR FORMAL PARAMETERS WHICH ARE ACTUALLY ARRAYS; IT ADDS
!A DOT, LETTING US REFER TO THE ARRAY AS IT WAS ORIGINALY DECLARED.

STRUCTURE ARY[I]=(..ARY+.I)<0,36>;  !THE <0,36> IS BECAUSE OF A BLISS FEATURE/BUG

FORWARD SAVEHI, SAVELO, COMPRESS, EXPAND,
  INITDSK, CLSFIL, RLSDSK, ENTFIL, DELFIL, WRTFIL;

BIND CHN=0;  !USED FOR ALL I/O - HOW CONVENIENT



GLOBAL ROUTINE LODSAV(SVFNAM,SVFEXT,SVFPPN,SSAVE,LO,HI)=
  %
  HERE IT IS - THE BIG ONE!  THIS IS THE MASTER DRIVER.
  SVFNAM = SAVE-FILE NAME (SIXBIT)
  SVFEXT = SAVE-FILE EXTENSION (LEFT-JUSTIFIED SIXBIT)
  SVFPPN = SAVE-FILE PPN
  SSAVE = 0 IF SAVE (.HGH), 1 IF SSAVE (.SHR)
  LO = LOCATION OF USER'S LOW SEGMENT
  HI = LOCATION OF USER'S HIGH SEGMENT
  IMPLICIT PARAMETERS:
  JOBDDT = IF NONZERO CHANGE SSAVE TO SAVE
  JOBHRL<LH> = IF NONZERO THERE IS A HIGH SEGMENT
  %
  BEGIN

  MAP ARY LO:HI;

  IF .LO[JOBDDT] NEQ 0 THEN SSAVE _ 0;  !IF DDT LOADED, DON'T ALLOW SHARABLE HIGH SEGMENT
  IF .SVFEXT EQL 0 THEN SVFEXT _ (IF .LO[JOBHRL]<LH> EQL 0 THEN SIXBIT'SAV' ELSE SIXBIT'LOW');
  INITDSK();  !INITIALIZE THE DISK
  LO[JOBCOR]<RH> _ .LO[JOBREL]<RH>;
  SAVEHI(.SVFNAM,.SVFPPN,.SSAVE,LO[0],HI[0]);  !SAVE HIGH SEGMENT
  SAVELO(.SVFNAM,.SVFEXT,.SVFPPN,LO[0]);  !SAVE LOW SEGMENT
  RLSDSK();  !RELEASE THE DISK AND WE'RE DONE
  END;  !OF LODSAV



ROUTINE SAVEHI(SVFNAM,SVFPPN,SSAVE,LO,HI)=
  %
  SAVES THE USER'S HIGH SEGMENT ON .HGH OR .SHR FILE - NO ZERO COMPRESSION.
  SVFNAM = SAVE-FILE NAME(SIXBIT)
  SVFPPN = SAVE-FILE PPN
  SSAVE = 0 IF SAVE .HGH), 1 IF SSAVE (.SHR)
  LO = LOCATION OF USER'S LOW SEGMENT
  HI = LOCATION OF USER'S HIGH SEGMENT
  IMPLICIT PARAMETERS:
  JOBHRL<LH> = LENGTH OF HIGH SEGMENT (0 IF NONE)
  JOBCOR<LH> = HIGHEST NONZERO LOCATION IN LOW SEGMENT
  %
  BEGIN

  MAP ARY LO:HI;

  IF .LO[JOBHRL]<LH> NEQ 0 THEN
    BEGIN
    ENTFIL(.SVFNAM,(IF .SSAVE THEN SIXBIT'SHR' ELSE SIXBIT'HGH'),.SVFPPN);
    !SET UP VESTIGIAL JOBDAT AT BEGINNING OF HISEG
    HI[JOBHSA] _ .LO[JOBSA];
    HI[JOBH41] _ .LO[JOB41];
    HI[JOBHCR] _ .LO[JOBCOR];
    HI[JOBHRN]<LH> _ .LO[JOBHRL]<LH>;
    HI[JOBHRN]<RH> _ .LO[JOBREN]<RH>;
    HI[JOBHVR] _ .LO[JOBVER];
    HI[JOBHX1] _ 0;
!   HI[JOBHSM] IS UNCHANGED
    HI[JOBHX2] _ 0;
    WRTFIL(HI[0],.LO[JOBHRL]<LH>);  !WRITE IT OUT
    CLSFIL();
    !DELETE .SHR IF WE WROTE .HGH AND VICE VERSA
    DELFIL(.SVFNAM,(IF .SSAVE THEN SIXBIT'HGH' ELSE SIXBIT'SHR'),.SVFPPN);
    !DELETE .LOW IF NONE WILL BE WRITTEN
    IF .LO[JOBCOR]<LH> LSS JOBDA THEN DELFIL(.SVFNAM,SIXBIT'LOW',.SVFPPN);
    END;
  END;  !OF SAVEHI



ROUTINE SAVELO(SVFNAM,SVFEXT,SVFPPN,LO)=
  %
  SAVES THE USER'S LOW SEGMENT ON .SAV OR .LOW FILE.  WORDS IN THE CORE IMAGE
  CONTAINING ZEROES ARE COMPRESSED OUT BEFORE THE FILE IS WRITTEN.
  SVFNAM = SAVE-FILE NAME (SIXBIT)
  SVFPPN = SAVE-FILE PPN
  LO = LOCATION OF USER'S LOW SEGMENT
  IMPLICIT PARAMETERS:
  JOBCOR<LH> = HIGHEST NONZERO LOCATION IN LOW SEGMENT
  JOBSA<LH> = HIGHEST LOCATION + 1 TO BE SAVED IN LOW SEGMENT
  LOCALS:
  LOTOP = SAME AS JOBSA<LH>-1
  CMPTOP = HIGHEST LOCATION IN COMPRESSED LOW SEGMENT
  STARTADR = PROGRAM START ADDRESS (JOBSA<RH>)
  %
  BEGIN

  LOCAL LOTOP, CMPTOP, STARTADR;
  MAP ARY LO;

  IF .LO[JOBCOR]<LH> GEQ JOBDA THEN
    BEGIN
    ENTFIL(.SVFNAM,.SVFEXT,.SVFPPN);
    LOTOP _ .LO[JOBSA]<LH>-1;
    STARTADR _ .LO[JOBSA]<RH>;
    LO[JOBS41] _ .LO[JOB41];
    LO[JOBSDD] _ .LO[JOBDDT];
    CMPTOP _ COMPRESS(LO[0],JOBSDD,JOBSV,.LOTOP);
    LO[.CMPTOP+1] _ #254000000000+.STARTADR;  !JRST .JOBSA<RH>
    WRTFIL(LO[JOBSV],.CMPTOP-JOBSV+2);
    CLSFIL();
    EXPAND(LO[0],JOBSV,.CMPTOP,.LOTOP);
    END;
  END;  !OF SAVLO



ROUTINE COMPRESS(R,FRUM,TU,TOP)=
  %
  COMPRESSES A CORE AREA.  WHEN CALLED, FROM MUST BE GREATER THAN TU.
  RETURNS HIGHEST LOCATION IN COMPRESSED IMAGE.
  R = RELOCATION TO GET INTO USER'S AREA
  FRUM = LOCATION BEING MOVED FROM (INITIALLY IS FIRST LOCATION TO COMPRESS)
  TU = LOCATION BEGIN MOVED INTO (INITIALLY IS LOCATION FOR FIRST IOWD)
  TOP = HIGHEST LOCATION IN ORIGINAL CORE AREA
  LOCALS:
  NZBASE = LOWEST LOCATION OF CURRENT NONZERO BLOCK
  NZSIZE = LENGTH OF CURRENT NONZERO BLOCK
  AC = BLT AC
  %
  BEGIN

  LOCAL NZBASE, NZSIZE;  REGISTER AC;
  MAP ARY R;
  MACHOP BLT=#251;

  WHILE .FRUM LEQ .TOP DO
    BEGIN  !LOOP EXECUTED ONCE FOR EACH ZERO-BLOCK/NONZERO-BLOCK PAIR
    WHILE .FRUM LEQ .TOP AND .R[.FRUM] EQL 0 DO FRUM _ .FRUM+1;  !SKIP ZEROES
    IF .FRUM LEQ .TOP THEN
      BEGIN  !GOT A NONZERO WORD, IT BEGINS A BLOCK
      NZBASE _ .FRUM;
      DO FRUM _ .FRUM+1 WHILE .FRUM LEQ .TOP AND .R[.FRUM] NEQ 0;  !SKIP TO END OF NONZERO BLOCK
      NZSIZE _ .FRUM-.NZBASE;
      R[.TU]<LH> _ -.NZSIZE;  R[.TU]<RH> _ .NZBASE-1;  !SET UP IOWD
      AC<LH> _ R[.NZBASE];  AC<RH> _ R[.TU+1];
      BLT(AC,R[.TU+.NZSIZE]);  !MOVE NONZERO BLOCK DOWN ABOVE ITS IOWD
      TU _ .TU+.NZSIZE+1;  !LOC FOR IOWD FOR NEXT BLOCK
      END;
    END;
  .TU-1
  END;  !OF COMPRESS



ROUTINE EXPAND(R,CMPBAS,CMPTOP,TOP)=
  %
  EXPANDS A CORE AREA.
  R = RELOCATION TO GET INTO USER'S AREA
  CMPBAS = LOWEST LOCATION IN COMPRESSED IMAGE (FIRST IOWD)
  CMPTOP = HIGHEST LOCATION IN COMPRESSED IMAGE
  TOP = HIGHEST LOCATION IN EXPANDED IMAGE
  LOCALS:
  FRUM = CURRENT LOCATION BEING MOVED FROM
  TU = CURRENT LOCATION BEING MOVED INTO
  IOWD = IOWD OF CURRENT BLOCK
  AC = BLT AC
  %
  BEGIN

  LOCAL FRUM, TU, IOWD;  REGISTER AC;
  MAP ARY R;
  MACHOP BLT=#251;

  MACRO ZERO(BOT,TOP)=  !ZEROES FROM BOT TO TOP
    IF BOT LEQ TOP THEN
      BEGIN
      R[BOT] _ 0;
      IF BOT LSS TOP THEN
        (AC<LH> _ R[BOT];  AC<RH> _ R[BOT]+1;  BLT(AC,R[TOP]));
      END;
    $;

  !MOVE COMPRESSED IMAGE UP TO VERY TOP OF CORE AREA.  THIS GREATLY SIMPLIFIES
  !THE REST OF THE CODE BY LETTING IT ALWAYS MOVE DOWN, NEVER UP.
  FRUM _ .CMPTOP;  TU _ .TOP;
  UNTIL .FRUM LSS .CMPBAS DO (R[.TU] _ .R[.FRUM];  FRUM _ .FRUM-1;  TU _ .TU-1);
  FRUM _ .CMPBAS+.TOP-.CMPTOP;  !FIRST IOWD LOC (IT GOT MOVED)
  TU _ .CMPBAS;  !FIRST LOC TO ZERO OUT
  WHILE .FRUM LEQ .TOP DO
    BEGIN  !LOOP EXECUTED ONCE FOR EACH NONZERO BLOCK AND THE ZERO AREA PRECEDING IT
    IOWD _ .R[.FRUM];  !IOWD FOR THIS NONZERO BLOCK
    ZERO(.TU,.IOWD<RH>);  !ZERO OUT ANYTHING BEFORE IT
    AC<LH> _ R[.FRUM+1];  AC<RH> _ R[.IOWD<RH>+1];
    TU _ (.IOWD<RH>-.IOWD<LH>+1) AND #777777;  !FIRST LOC OF NEXT ZERO BLOCK
    BLT(AC,R[.TU-1]);  !MOVE THE NONZERO BLOCK DOWN INTO PLACE
    FRUM _ (.FRUM-.IOWD<LH>+1) AND #777777;  !LOC OF NEXT IOWD
    END;
  ZERO(.TU,.TOP);  !DONE WITH ALL BLOCKS, ZERO OUT ANYTHING LEFT OVER AT THE TOP
  END;  !OF EXPAND



ROUTINE INITDSK=
  %
  INITS THE DISK
  %
  BEGIN
  MACHOP OPEN=#50, JRST=#254;
  IFSKIP OPEN(CHN,PLIT(#16,SIXBIT'DSK',0)) THEN 0 ELSE JRST(4);
  END;  !OF INITDSK



ROUTINE CLSFIL=
  %
  CLOSES THE DISK
  %
  BEGIN
  MACHOP CLOSE=#70;
  CLOSE(CHN);
  END;  !OF CLSFIL



ROUTINE RLSDSK=
  %
  RELEASES THE DISK
  %
  BEGIN
  MACHOP RELEASE=#71;
  RELEASE(CHN);
  END;  !OF RLSDSK



ROUTINE ENTFIL(NAME,EXT,PPN)=
  %
  ENTERS A DISK FILE.  GOES TO ENTFAL IF NO LUCK.  USES DTIN FOR THE FOUR-WORD
  ENTER BLOCK SO THAT THE MESSAGE PRINTING ROUTINE AT ENTFAL WILL WORK.
  NAME = FILE NAME (SIXBIT)
  EXT = FILE EXTENSION (SIXBIT LEFT-JUSTIFIED)
  PPN = FILE PPN
  %
  BEGIN

  EXTERNAL ENTFAL, DTIN[4];
  BIND ENTBLK=DTIN;
  MACHOP ENTER=#77;

  ENTBLK[0] _ .NAME;
  ENTBLK[1] _ .EXT AND #777777000000;
  ENTBLK[2] _ 0;
  ENTBLK[3] _ .PPN;
  IFSKIP ENTER(CHN,ENTBLK) THEN 0 ELSE ENTFAL();
  END;  !OF ENTFIL



ROUTINE DELFIL(NAME,EXT,PPN)=
  %
  DELETES A DISK FILE.  IGNORES ERRORS.
  NAME = FILE NAME (SIXBIT)
  EXT = FILE EXTENSION (LEFT-JUSTIFIED SIXBIT)
  PPN = FILE PPN
  %
  BEGIN

  LOCAL LOOKBLK[4];
  MACHOP LOOKUP=#76, RENAME=#55;
  LOOKBLK[0] _ .NAME;
  LOOKBLK[1] _ .EXT;
  LOOKBLK[3] _ .PPN;
  IFSKIP LOOKUP(CHN,LOOKBLK) THEN
    (LOOKBLK[0] _ 0;  IFSKIP RENAME(CHN,LOOKBLK) THEN 0);
  END;  !OF DELFIL



ROUTINE WRTFIL(LOC,SIZE)=
  %
  WRITES SOME STUFF INTO A FILE.  GOES TO LOSEBIG ON AN ERROR.
  LOC = BEGINNING OF AREA TO WRITE
  SIZE = NUMBER OF WORDS TO WRITE
  %
  BEGIN

  LOCAL CMDLST[2];
  EXTERNAL LOSEBIG;
  MACHOP OUT=#57;

  CMDLST[0]<LH> _ -.SIZE;
  CMDLST[0]<RH> _ .LOC-1;
  CMDLST[1] _ 0;
  IFSKIP OUT(CHN,CMDLST) THEN LOSEBIG();
  END;  !OF WRTFIL



END
ELUDOM
 